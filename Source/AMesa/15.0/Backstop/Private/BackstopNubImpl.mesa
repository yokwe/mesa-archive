-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- BackstopNubImpl.mesa  -- Edited by LXR     on  21-Apr-83 15:04:43DIRECTORY  BackstopInternal USING [Handle, LogEntry],  BackstopNub,  File USING [File, PageNumber],  Heap USING [systemZone],  Log USING [Index, nullIndex],  LogFile USING [GetAttributes, GetNext, GetBlock],  LogInternal USING [Type],  String USING [AppendString];BackstopNubImpl: PROGRAM IMPORTS Heap, LogFile, String EXPORTS BackstopNub =  BEGIN  Words: TYPE = RECORD [SEQUENCE COMPUTED CARDINAL OF WORD];  NotErrorEntry: PUBLIC SIGNAL = CODE;  GetNext: PUBLIC PROCEDURE [log: File.File, current: Log.Index, firstPageNumber: File.PageNumber]    RETURNS [next: Log.Index] =    BEGIN    size: CARDINAL;    temp: BackstopInternal.Handle;    nextType: LogInternal.Type ¬ null;    next ¬ current;    DO      WHILE nextType # block DO        next ¬ LogFile.GetNext[log, next, firstPageNumber];        [, nextType, , size] ¬ LogFile.GetAttributes[log, next, firstPageNumber];        IF next = Log.nullIndex THEN RETURN;        ENDLOOP;      temp ¬ LOOPHOLE[Heap.systemZone.NEW[Words[size]]];      [] ¬ LogFile.GetBlock[log, next, temp, firstPageNumber];      WITH temp SELECT FROM        error => {Heap.systemZone.FREE[@temp]; EXIT};        ENDCASE => {nextType ¬ null; Heap.systemZone.FREE[@temp]};      ENDLOOP;    END;  GetSize: PUBLIC PROCEDURE [log: File.File, current: Log.Index, firstPageNumber: File.PageNumber]    RETURNS [size: CARDINAL] =    BEGIN    temp: BackstopInternal.Handle;    [, , , size] ¬ LogFile.GetAttributes[log, current, firstPageNumber];    temp ¬ LOOPHOLE[Heap.systemZone.NEW[Words[size]]];    [] ¬ LogFile.GetBlock[log, current, temp, firstPageNumber];    WITH temp SELECT FROM      error => {        WITH error SELECT FROM          call => size ¬ SIZE[BackstopNub.ErrorEntry] + (msg.length + 1)/2;          ENDCASE => size ¬ SIZE[BackstopNub.ErrorEntry];        Heap.systemZone.FREE[@temp];        RETURN};      ENDCASE => {size ¬ 0; Heap.systemZone.FREE[@temp]};    END;  GetLogEntry: PUBLIC PROCEDURE [    log: File.File, current: Log.Index, place: BackstopNub.Handle, firstPageNumber: File.PageNumber] =    BEGIN    buffer: BackstopInternal.Handle;    size: CARDINAL;    [, , , size] ¬ LogFile.GetAttributes[log, current, firstPageNumber];    buffer ¬ LOOPHOLE[Heap.systemZone.NEW[Words[size]]];    LogFile.GetBlock[log, current, buffer, firstPageNumber];    WITH buffer SELECT FROM      error => {        place­ ¬ error;        WITH e: error SELECT FROM          call =>            WITH p: place SELECT FROM              call => {                p.msg.length ¬ 0;                String.AppendString[@p.msg, @e.msg]};              ENDCASE;          ENDCASE};      ENDCASE => SIGNAL NotErrorEntry;    Heap.systemZone.FREE[@buffer];    END;  END. 
-- ServicesRuntimeErrorImpl.mesaDIRECTORYCPSwapDefs,DebuggerSwap,Frame,PrincOps,ProcessOperations,ServicesRuntimeError,SpecialSpace;ServicesRuntimeErrorImpl: PROGRAM  IMPORTS DebuggerSwap, Frame, ProcessOperations, SpecialSpace  EXPORTS ServicesRuntimeError = {    proc: PROC ¬ NIL;    SetDebuggerFielder: PUBLIC PROC[debuggerFielder: PROC] = {    proc ¬ debuggerFielder };  InitializeAwaitDebuggerRequest: PROC = {    awaitDebuggerRequest: DebuggerSwap.AwaitDebuggerRequest;    LOOPHOLE[awaitDebuggerRequest, PrincOps.Port].out ¬ Frame.GetReturnFrame[];    pilotDebuggerFielder ¬ LOOPHOLE[LONG[DebuggerSwap.SetDebuggerFielder[@awaitDebuggerRequest]]];    DO  -- forever      pESV: LONG POINTER TO CPSwapDefs.ExternalStateVector = awaitDebuggerRequest[];      IF proc = NIL THEN pilotDebuggerFielder[pESV]      ELSE {        ProcessOperations.EnableInterrupts[];        [] ¬ DebuggerSwap.SetDebuggerFielder[LOOPHOLE[LOOPHOLE[pilotDebuggerFielder, PrincOps.ControlLink].port]];        proc[];	[] ¬ DebuggerSwap.SetDebuggerFielder[@awaitDebuggerRequest];	ProcessOperations.DisableInterrupts[] };      ENDLOOP };      pilotDebuggerFielder: PROC [pEsv: LONG POINTER TO CPSwapDefs.ExternalStateVector];  SpecialSpace.MakeGlobalFrameResident[    ServicesRuntimeErrorImpl !    SpecialSpace.SpecialError =>      IF error = alreadyResident THEN CONTINUE];  SpecialSpace.MakeProcedureResident[    InitializeAwaitDebuggerRequest !    SpecialSpace.SpecialError =>      IF error = alreadyResident THEN CONTINUE];  [] ¬ InitializeAwaitDebuggerRequest[];}..
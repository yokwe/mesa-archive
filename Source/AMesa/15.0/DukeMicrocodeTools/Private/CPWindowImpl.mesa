-- Copyright (C) 1984, 1985  by Xerox Corporation. All rights reserved. -- Last edit by RDH  	28-Jan-86 19:18:51-- from CPWindower.mesa, HGM, 14-Feb-84  1:13:28DIRECTORY  Exec USING [AddCommand, ExecProc, GetTTY, Handle, PrependCommands, ReleaseTTY, RemoveCommand],  Format USING [StringProc],  FormSW USING [    AllocateItemDescriptor, --BooleanItem,-- ClientItemsProcType, CommandItem,    DisplayItem, Enumerated, EnumeratedItem, newLine, NumberNotifyProcType,     NumberItem, ProcType, StringItem, ToggleVisibility],  Heap USING [systemZone],  Inline USING [LongCOPY],  MFile USING [Acquire, Error, Handle],  MLoader USING [Run],  Process USING [Detach, MsecToTicks, Pause],  Put USING [CR, Date, Decimal, Line, Text],  Runtime USING [ControlLink, GetBcdTime, IsBound],  Selection USING [Convert],  String USING [    AppendLongDecimal, AppendLongNumber, AppendString,    AppendStringAndGrow, CopyToNewString, Empty],  System USING [GetGreenwichMeanTime],  TextSW USING [ForceOutput],  Time USING [Append, Unpack],  Tool USING [Create, Destroy, MakeFormSW, MakeFileSW, MakeSWsProc, UnusedLogName],  ToolWindow USING [TransitionProcType],  TTY USING [Handle, PutLine, PutString],  UserInput USING [    CancelPeriodicNotify, CreatePeriodicNotify, PeriodicNotifyHandle, PeriodicProcType,    UserAbort],  Version USING [Append],  Window USING [Handle],    Bindweed USING [ReadMemoryBlock],  CommandFile USING [CommandsFromFile, Error, SomebodyRunning],  CPDefs USING [BanksImplemented, Cycle, RealCS, Task],  CPBreakDefs USING [ClearAllBreaks, EnumerateBreaks, Error, RemoveBreaks],  CPCommand USING [    Boot, Break, Error, Compare, Continue, CopyPanel, Load, LoadBootFile, LoadGerm, LoadRaw, LoadReal, LoadSymbols, PollCP, PrintState, Reset, Start, Stop, Unbreak],  CPCrossJump USING [CrossJump],  CPDestroyWindow USING [CPMesaDestroy, CPSymbolDebugDestroy],  CPKernelDefs USING [    Error, InKernel, ProbeForStateChange, State],  CPKernelOp USING [GetState],  CPPanel USING [Clear, Destroy, MakePanelSW, Refresh],  CPSymbl USING [    AppendAllRH, AppendAllRReg, AppendAllUReg, AppendNumber, AppendAllVirturalCS,    AppendIOIn, AppendIOOut, AppendLink, AppendMap, AppendOther,    AppendReal, AppendRealCS, AppendTpc,    AppendVirtural, AppendVirturalCS,    Error, Eval, nullRealCS, nullVirturalCS,    RealToVirturalCS, Symbol, VirturalCS, VirturalToRealCS];CPWindowImpl: PROGRAM  IMPORTS    Exec, FormSW, Heap, Inline, MFile, MLoader, Process, Put, Runtime, Selection,     String, System, TextSW, Time, Tool, TTY, UserInput, Version,    Bindweed, CommandFile, CPBreak: CPBreakDefs, CPCommand, CPCrossJump,    CPDestroyWindow, CPKernelDefs, CPKernelOp, CPPanel, CPSymbl  EXPORTS CPCommand =  BEGIN    -- TYPEs  BurdockWindows: TYPE = LONG POINTER TO BurdockWindowSeq;  BurdockWindowSeq: TYPE = RECORD  [ length: CARDINAL _ 0,    w: SEQUENCE maxlength: CARDINAL OF Window.Handle _ NULL];  -- global variables  bw: BurdockWindows _ NIL;  z: UNCOUNTED ZONE = Heap.systemZone;    typeIn, run: LONG STRING ¬ NIL;  log, form, panel: Window.Handle ¬ NIL;  initialized: BOOLEAN ¬ FALSE;  state: CPKernelDefs.State;  seq, boot: CARDINAL;  refreshNeeded, flushDuplicates, flushStateChange: BOOLEAN ¬ FALSE;  notifier: UserInput.PeriodicNotifyHandle;  clumpSize: CARDINAL ¬ 10;  bank: CARDINAL ¬ 0;    --pollCP: BOOLEAN ¬ TRUE;   Boot: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostDate[];    CPCommand.Boot[LogString, log];    END;  Load: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    filename: LONG STRING ¬ Selection.Convert[string];    PostDate[];    BEGIN ENABLE UNWIND => z.FREE[@filename];    CPCommand.Reset[LogString, log];    CPCommand.Load[LogString, log, filename, bank];    CPCommand.LoadSymbols[LogString, log, filename, bank];    z.FREE[@filename];    END;    END;  LoadMore: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    filename: LONG STRING ¬ Selection.Convert[string];    PostDate[];    BEGIN ENABLE UNWIND => z.FREE[@filename];    IF ~ CPKernelDefs.InKernel[] THEN       ERROR CPCommand.Error["Aborted...CP not in kernel"L];    CPCommand.Load[LogString, log, filename, bank];    CPCommand.LoadSymbols[LogString, log, filename, bank];    z.FREE[@filename];    END;    END;  Compare: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    filename: LONG STRING ¬ Selection.Convert[string];    PostDate[];    BEGIN ENABLE UNWIND => z.FREE[@filename];    CPCommand.Compare[LogString, log, filename];    z.FREE[@filename];    END;    END;  CrossJump: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    filename: LONG STRING ¬ Selection.Convert[string];    PostDate[];    BEGIN ENABLE UNWIND => z.FREE[@filename];    CPCrossJump.CrossJump[LogString, log, filename];    z.FREE[@filename];    END;    END;  Start: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    pc: LONG STRING ¬ Selection.Convert[string];    BEGIN ENABLE UNWIND => z.FREE[@pc];    IF pc = NIL THEN       ERROR CPCommand.Error ["No start location specified"L];    IF ~ CPKernelDefs.InKernel[] THEN       ERROR CPCommand.Error["Aborted...CP not in kernel"L];    PostDate[];    CPCommand.Start[LogString, log, pc, pc];    z.FREE[@pc];    END;    END;  Continue: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostDate[];    CPCommand.Continue[LogString, log];    END;  Stop: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostDate[];    CPCommand.Stop[LogString, log];    END;  Run: FormSW.ProcType =    BEGIN    filename: LONG STRING ¬ String.CopyToNewString[run, z];    IF String.Empty[filename] THEN filename ¬ Selection.Convert[string];    Put.CR[log];    flushStateChange ¬ TRUE;    FormSW.ToggleVisibility[form, runIx];    Process.Detach[FORK Runner[filename]];    -- Dally so Watcher can't sneak in and reset flushStateChange before     --  the process we just forked gets started.    FOR i: CARDINAL IN [0..10) DO      IF CommandFile.SomebodyRunning[] THEN EXIT;      Process.Pause[Process.MsecToTicks[100]];      ENDLOOP;    END;    Runner: PROCEDURE [filename: LONG STRING] =    BEGIN    BEGIN ENABLE CommandFile.Error =>      BEGIN      temp: STRING = [200];      String.AppendString[temp, "Error in command file at position "L];      String.AppendLongDecimal[temp, position];      String.AppendString[temp, ": "L];      String.AppendString[temp, reason];      TailMessage[temp];      CONTINUE;      END;    CommandFile.CommandsFromFile[LogString, log, Abort, filename];    END;    z.FREE[@filename];    FormSW.ToggleVisibility[form, runIx];    END;  LoadRaw: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    filename: LONG STRING ¬ Selection.Convert[string];    PostDate[];    BEGIN ENABLE UNWIND => z.FREE[@filename];    CPCommand.LoadRaw[LogString, log, filename, bank];    CPCommand.LoadSymbols[LogString, log, filename, bank];    z.FREE[@filename];    END;    END;  LoadNoSyms: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    filename: LONG STRING ¬ Selection.Convert[string];    PostDate[];    BEGIN ENABLE UNWIND => z.FREE[@filename];    CPCommand.Load[LogString, log, filename, bank];    z.FREE[@filename];    END;    END;  LoadSymbols: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    filename: LONG STRING ¬ Selection.Convert[string];    BEGIN ENABLE UNWIND => z.FREE[@filename];    CPCommand.LoadSymbols[LogString, log, filename, bank];    z.FREE[@filename];    END;    END;  LoadGerm: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    filename: LONG STRING ¬ Selection.Convert[string];    PostDate[];    BEGIN ENABLE UNWIND => z.FREE[@filename];    CPCommand.LoadGerm[LogString, log, filename];    z.FREE[@filename];    END;    END;  LoadReal: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    filename: LONG STRING ¬ Selection.Convert[string];    PostDate[];    BEGIN ENABLE UNWIND => z.FREE[@filename];    CPCommand.LoadReal[LogString, log, filename];    z.FREE[@filename];    END;    END;  LoadBoot: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    filename: LONG STRING ¬ Selection.Convert[string];    PostDate[];    BEGIN ENABLE UNWIND => z.FREE[@filename];    CPCommand.LoadBootFile[LogString, log, filename, 0];    z.FREE[@filename];    END;    END;  Refresh: FormSW.ProcType =    BEGIN    refreshNeeded ¬ flushStateChange ¬ TRUE;    END;  CopyPanel: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostDate[];    CPCommand.CopyPanel[LogString, log];    END;      ClearPanel: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    CPPanel.Clear[];    END;  CheckBankNumber: FormSW.NumberNotifyProcType = BEGIN    IF bank NOT IN CPDefs.BanksImplemented THEN BEGIN      bank ¬ oldValue;      PostMessage["Bad bank value."L];      END;    END;--CheckBankNumber--    What: FormSW.ProcType =    BEGIN ENABLE      CPSymbl.Error => BEGIN TailMessage[reason]; CONTINUE; END;    string: LONG STRING ¬ Selection.Convert[string];    temp: LONG STRING = [200];    value: CPSymbl.Symbol;    BEGIN ENABLE UNWIND => z.FREE[@string];    PostMessage["Decoding "L];    IF string = NIL THEN      BEGIN      TailMessage["  Selection required"L];      RETURN;      END;    TailMessage[string];    value ¬ CPSymbl.Eval[string];    WITH value SELECT FROM      number =>        BEGIN	String.AppendString[temp, "Number: "L];	AppendLotsOfModes[temp, n];	END;      tpc =>        BEGIN        CPSymbl.AppendTpc[temp, task];	AppendLotsOfModes[temp, task];	END;      link =>        BEGIN        CPSymbl.AppendLink[temp, link];	AppendLotsOfModes[temp, link];	END;      realCS =>        BEGIN	virt: CPSymbl.VirturalCS;	cycle: CPDefs.Cycle;	task: CPDefs.Task;	String.AppendString[temp, "RealCS: "L];        CPSymbl.AppendRealCS[temp, real];	AppendLotsOfModes[temp, real];	[virt, cycle, task] ¬ CPSymbl.RealToVirturalCS[real];	IF virt # CPSymbl.nullVirturalCS THEN	  BEGIN	  String.AppendString[temp, ", (VirturalCS = .CV "L];          CPSymbl.AppendNumber[temp, virt];          String.AppendString[temp, " = "L];          CPSymbl.AppendVirturalCS[temp, virt];	  String.AppendString[temp, ", "L];          AppendCycle[temp, cycle];	  String.AppendString[temp, ")"L];	  END;	END;      virtCS =>        BEGIN	real: CPDefs.RealCS;	cycle: CPDefs.Cycle;	task: CPDefs.Task;	String.AppendString[temp, "VirturalCS: "L];	String.AppendString[temp, ".CV "L];	CPSymbl.AppendNumber[temp, virt];        String.AppendString[temp, " = "L];        CPSymbl.AppendAllVirturalCS[temp, virt];	AppendLotsOfModes[temp, virt];	[real, cycle, task] ¬ CPSymbl.VirturalToRealCS[virt];	IF real # CPSymbl.nullRealCS THEN	  BEGIN	  String.AppendString[temp, ", (RealCS = "L];          CPSymbl.AppendRealCS[temp, real];	  String.AppendString[temp, ", "L];          AppendCycle[temp, cycle];	  String.AppendString[temp, ")"L];	  END;	END;      rReg, rAndRh =>        BEGIN	IF value.type = rAndRh THEN	  String.AppendString[temp, "(R+RH mode)"L];	String.AppendString[temp, "RReg: "L];	String.AppendString[temp, ".R "L];	CPSymbl.AppendNumber[temp, r];        String.AppendString[temp, " = "L];        CPSymbl.AppendAllRReg[temp, r];	AppendLotsOfModes[temp, r];	END;      rH =>        BEGIN	String.AppendString[temp, "RH: "L];	String.AppendString[temp, ".RH "L];	CPSymbl.AppendNumber[temp, r];        String.AppendString[temp, " = "L];        CPSymbl.AppendAllRH[temp, r];	AppendLotsOfModes[temp, r];	END;      uReg =>        BEGIN	String.AppendString[temp, "UReg: "L];	String.AppendString[temp, ".U "L];	CPSymbl.AppendNumber[temp, u];        String.AppendString[temp, " = "L];        CPSymbl.AppendAllUReg[temp, u];	AppendLotsOfModes[temp, u];	END;      ioIn =>        BEGIN        CPSymbl.AppendIOIn[temp, io];	AppendLotsOfModes[temp, io];	END;      ioOut =>        BEGIN        CPSymbl.AppendIOOut[temp, io];	AppendLotsOfModes[temp, io];	END;      map =>        BEGIN        CPSymbl.AppendMap[temp, map];	AppendLotsOfModes[temp, map];	END;      real =>        BEGIN        CPSymbl.AppendReal[temp, real];	AppendLotsOfModes[temp, LOOPHOLE[real]];	END;      virt =>        BEGIN        CPSymbl.AppendVirtural[temp, virt];	AppendLotsOfModes[temp, LOOPHOLE[virt]];	END;      other =>        BEGIN        CPSymbl.AppendOther[temp, other];	END;      pc =>        BEGIN        String.AppendString[temp, ".PC (a Speudo Register)"L];	END;      ENDCASE => ERROR;    TailMessage[temp];    z.FREE[@string];    END;    END;    AppendLotsOfModes: PROCEDURE [s: LONG STRING, d: LONG CARDINAL] =    BEGIN    String.AppendString[s, " = "L];    String.AppendLongNumber[s, d, 16];    String.AppendString[s, "'X = "L];    String.AppendLongNumber[s, d, 10];    String.AppendString[s, "'D = "L];    String.AppendLongNumber[s, d, 8];    String.AppendString[s, "'B"L];    END;    AppendCycle: PROCEDURE [s: LONG STRING, cycle: CPDefs.Cycle] =    BEGIN    SELECT cycle FROM      c1 => String.AppendString[s, "c1"L];      c2 => String.AppendString[s, "c2"L];      c3 => String.AppendString[s, "c3"L];      any => String.AppendString[s, "c*"L];      ENDCASE => ERROR;    END;   Break: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    where: LONG STRING ¬ Selection.Convert[string];    BEGIN ENABLE UNWIND => z.FREE[@where];    IF where = NIL THEN where ¬ String.CopyToNewString[typeIn, z];    IF where = NIL THEN      BEGIN      TailMessage["  Selection/Typein required"L];      RETURN;      END;    CPCommand.Break[LogString, log, where];    z.FREE[@where];    END;    END;   Unbreak: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    where: LONG STRING ¬ Selection.Convert[string];    BEGIN ENABLE UNWIND => z.FREE[@where];    CPCommand.Unbreak[LogString, log, where];    z.FREE[@where];    END;    END;   ClearAllBreaks: FormSW.ProcType =    BEGIN ENABLE CPBreak.Error =>      BEGIN      PostMessage["Oops, "L];      TailMessage[reason];      CONTINUE;      END;    PostMessage["Clearing All CP Breaks "L];    AppendMessage[" ... "L];    CPBreak.ClearAllBreaks[];    TailMessage["ok"L];    END;  ListBreaks: FormSW.ProcType =    BEGIN ENABLE CPBreak.Error =>      BEGIN      PostMessage["Oops, "L];      TailMessage[reason];      CONTINUE;      END;    i: CARDINAL ¬ 0;    PrintOne: PROCEDURE [pc: CPDefs.RealCS, cycle: CPDefs.Cycle, task: CPDefs.Task] =      BEGIN      temp: STRING = [200];      virt: CPSymbl.VirturalCS;      i ¬ i + 1;      Put.Text[log, "CP Break #"L];      Put.Decimal[log, i];      Put.Text[log, " is located at "L];      CPSymbl.AppendRealCS[temp, pc];      [virt, , ] ¬ CPSymbl.RealToVirturalCS[pc];      IF virt # CPSymbl.nullVirturalCS THEN        BEGIN        String.AppendString[temp, ", (VirturalCS = "L];        CPSymbl.AppendVirturalCS[temp, virt];        String.AppendString[temp, ")"L];        END;      String.AppendString[temp, ", "L];      AppendCycle[temp, cycle];      Put.Line[log, temp];      END;    Put.CR[log];    Put.Line[log, "CP Breakpoints:"L];    CPBreak.EnumerateBreaks[PrintOne];    Put.Line[log, "Done"L];    END;   RefreshWindow: PUBLIC PROCEDURE =    BEGIN    state ¬ CPKernelOp.GetState[];    refreshNeeded ¬ TRUE;    END;      Watcher: UserInput.PeriodicProcType =    BEGIN    IF CommandFile.SomebodyRunning[] --OR NOT pollCP-- THEN RETURN;    --ProbeForStateChange[];    IF ~refreshNeeded AND state = CPKernelOp.GetState[] THEN      BEGIN      refreshNeeded ¬ flushDuplicates ¬ flushStateChange ¬ FALSE;      RETURN;      END;    IF state # CPKernelOp.GetState[] THEN flushDuplicates ¬ FALSE;    state ¬ CPKernelOp.GetState[];    IF ~flushDuplicates THEN      BEGIN      PostDate[];      IF ~flushStateChange THEN AppendMessage["State changed: "L];      IF CPKernelDefs.InKernel[] THEN RemoveBreaks[];      PrintState[];      END;    IF CPKernelDefs.InKernel[] THEN BEGIN RemoveBreaks[]; CPPanel.Refresh[]; END;    FormSW.DisplayItem[form, stateIx];    refreshNeeded ¬ flushDuplicates ¬ flushStateChange ¬ FALSE;    END;      ProbeForStateChange: PROCEDURE =    BEGIN ENABLE CPKernelDefs.Error =>      BEGIN      PostMessage["Humm, "L];      TailMessage[reason];      refreshNeeded ¬ TRUE;      CONTINUE;      END;    CPKernelDefs.ProbeForStateChange[LogString, log];    END;      RemoveBreaks: PROCEDURE =    BEGIN ENABLE CPBreak.Error =>      BEGIN      PostMessage["Humm, "L];      TailMessage[reason];      CONTINUE;      END;    CPBreak.RemoveBreaks[];    END;      PollCP: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostDate[];    [] ¬ CPCommand.PollCP[LogString, log, TRUE];    END;      PrintState: PROCEDURE =    BEGIN ENABLE CPCommand.Error =>      BEGIN      PostMessage["Humm, "L];      TailMessage[reason];      CONTINUE;      END;    CPCommand.PrintState[LogString, log];    END;      PostDate: PROCEDURE =    BEGIN    Put.CR[log];    Put.Date[log, System.GetGreenwichMeanTime[], dateTime];    Put.Text[log, "  "L];    TextSW.ForceOutput[log];    flushDuplicates ¬ TRUE;    END;  PostMessage: PROCEDURE [s: LONG STRING] =    BEGIN    Put.CR[log];    Put.Text[log, s];    TextSW.ForceOutput[log];    END;  AppendMessage: PROCEDURE [s: LONG STRING] =    BEGIN    Put.Text[log, s];    TextSW.ForceOutput[log];    END;  TailMessage: PROCEDURE [s: LONG STRING] =    BEGIN    Put.Text[log, s];    Put.Line[log, "."L];    TextSW.ForceOutput[log];    END;    LogString: Format.StringProc =    BEGIN    Put.Text[clientData, s];    END;  Abort: PROCEDURE RETURNS [BOOLEAN] =    BEGIN    RETURN[UserInput.UserAbort[log]];    END;  Initialize: PROCEDURE [h: Exec.Handle] =    BEGIN    herald: STRING = [100];    bindweedFile: STRING = "BindweedConfig.bcd"L;    msg: STRING ¬ [80];    mfH: MFile.Handle;    ttH: TTY.Handle ¬ Exec.GetTTY[h];    IF  ~Runtime.IsBound[LOOPHOLE[Bindweed.ReadMemoryBlock, Runtime.ControlLink]] THEN       BEGIN      mfH ¬ MFile.Acquire[name: bindweedFile, access: readOnly, release: []!        MFile.Error => IF code = noSuchFile THEN GOTO noFile ELSE REJECT];      TTY.PutString[h: ttH, s: "  ... loading "L];      TTY.PutString[h: ttH, s: bindweedFile];      TTY.PutString[h: ttH, s: "..."L];      [] ¬ MLoader.Run[file: mfH];      TTY.PutLine[h: ttH, s: "done."L];      Exec.PrependCommands[h, "BindweedConfig.~"L]; -- start asynchronous notifier    EXITS    noFile =>         BEGIN	msg.length ¬ 0;        String.AppendString[to: msg, from: "  Please retrieve file "L];        String.AppendString[to: msg, from: bindweedFile];        String.AppendString[to: msg, from: " before trying again."L];        TTY.PutLine[h: ttH, s: msg];	Exec.ReleaseTTY[ttH];        RETURN;        END;      END;    String.AppendString[herald, "CPBermudaDaybreak "L];    Version.Append[herald];    String.AppendString[herald, " of "L];    Time.Append[herald, Time.Unpack[Runtime.GetBcdTime[]]];    RegisterBurdockWindow[Tool.Create[      name: herald,      cmSection: "CP Panel"L,      makeSWsProc: MakeSWs,      clientTransition: ClientTransition]];    initialized ¬ TRUE;    END;    MakeSWs: Tool.MakeSWsProc =    BEGIN    logFileName: STRING = [40];    Tool.UnusedLogName[logFileName, "CPDefs.log$"L];    log ¬ Tool.MakeFileSW[window: window, name: logFileName, h: 100];    form ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    panel ¬ CPPanel.MakePanelSW[window, log, ModifyTypeIn, @typeIn];    END;    stateChoices: ARRAY CPKernelDefs.State OF FormSW.Enumerated ¬ [    dead: ["CP/IOP Dead", CPKernelDefs.State[dead]],    halted: ["Halted", CPKernelDefs.State[halted]],    running: ["Running", CPKernelDefs.State[running]],    cpBreak: ["CPBreak", CPKernelDefs.State[cpBreak]],    booted: ["Booted", CPKernelDefs.State[booted]]];          runIx: CARDINAL = 6;  stateIx: CARDINAL = 14;  typeInIx: CARDINAL = 27;  MakeForm: FormSW.ClientItemsProcType =    BEGIN    nParams: CARDINAL = 28;    items ¬ FormSW.AllocateItemDescriptor[nParams];    items[0] ¬ FormSW.CommandItem[tag: "Boot"L, proc: Boot, place: FormSW.newLine];    items[1] ¬ FormSW.CommandItem[tag: "Load"L, proc: Load];    items[2] ¬ FormSW.CommandItem[tag: "LoadMore"L, proc: LoadMore];    items[3] ¬ FormSW.CommandItem[tag: "Start"L, proc: Start];    items[4] ¬ FormSW.CommandItem[tag: "Continue"L, proc: Continue];    items[5] ¬ FormSW.CommandItem[tag: "Stop"L, proc: Stop];    items[runIx] ¬ FormSW.CommandItem[tag: "Run"L, proc: Run];    items[7] ¬ FormSW.StringItem[tag: "File"L, string: @run, inHeap: TRUE];    items[8] ¬ FormSW.CommandItem[tag: "LoadRaw"L, proc: LoadRaw, place: FormSW.newLine];    items[9] ¬ FormSW.CommandItem[tag: "LoadNoSyms"L, proc: LoadNoSyms];    items[10] ¬ FormSW.CommandItem[tag: "LoadSymbols"L, proc: LoadSymbols];    items[11] ¬ FormSW.CommandItem[tag: "LoadGerm"L, proc: LoadGerm];    items[12] ¬ FormSW.CommandItem[tag: "LoadReal"L, proc: LoadReal];    items[13] ¬ FormSW.CommandItem[tag: "LoadBoot"L, proc: LoadBoot];    items[stateIx] ¬ FormSW.EnumeratedItem[      tag: "State"L, value: @state, readOnly: TRUE, place: FormSW.newLine,      choices: LOOPHOLE[LONG[DESCRIPTOR[stateChoices]]]];    items[15] ¬ FormSW.CommandItem[tag: "Refresh"L, proc: Refresh];    items[16] ¬ FormSW.CommandItem[tag: "CopyPanel"L, proc: CopyPanel];    items[17] ¬ FormSW.CommandItem[tag: "ClearPanel"L, proc: ClearPanel];    items[18] ¬ FormSW.NumberItem[      tag: "LoadBank"L, proc: CheckBankNumber, value: @bank, default: 0, notNegative: TRUE];    items[19] ¬ FormSW.CommandItem[tag: "ListBreaks"L, proc: ListBreaks, place: FormSW.newLine];    items[20] ¬ FormSW.CommandItem[tag: "ClearAllBreaks"L, proc: ClearAllBreaks];    items[21] ¬ FormSW.CommandItem[tag: "Unbreak"L, proc: Unbreak];    items[22] ¬ FormSW.CommandItem[tag: "Break"L, proc: Break];    items[23] ¬ FormSW.CommandItem[tag: "Compare"L, proc: Compare];    items[24] ¬ FormSW.CommandItem[tag: "CrossJump"L, proc: CrossJump];    items[25] ¬ FormSW.CommandItem[tag: "What"L, proc: What, place: FormSW.newLine];    --items[26] ¬ FormSW.BooleanItem[tag: "PollCP"L, proc: SetPollCP, switch:@pollCP];    items[26] ¬ FormSW.CommandItem[tag: "PollCP"L, proc: PollCP];    items[typeInIx] ¬ FormSW.StringItem[tag: "TypeIn"L, string: @typeIn, inHeap: TRUE];     RETURN[items, TRUE];    END;      <<SetPollCP: FormSW.NotifyProcType =    BEGIN    PostDate[];    Put.Line[log, "Setting PollCP....done"L];    END;>>       ModifyTypeIn: PROCEDURE [newTypeIn: LONG STRING, replace: BOOLEAN] =    BEGIN    IF newTypeIn = NIL OR replace THEN typeIn.length ¬ 0;    IF newTypeIn # NIL THEN String.AppendStringAndGrow[@typeIn, newTypeIn, z];    FormSW.DisplayItem[form, typeInIx];    END;        ClientTransition: ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      old = inactive =>        BEGIN	typeIn ¬ z.NEW[StringBody[20]];	run ¬ z.NEW[StringBody[20]];	state ¬ CPKernelOp.GetState[];	seq ¬ 0;	boot ¬ 0;	notifier ¬ UserInput.CreatePeriodicNotify[Watcher, window, Process.MsecToTicks[1000]];        END;      new = inactive =>        BEGIN	notifier ¬ UserInput.CancelPeriodicNotify[notifier];	CPPanel.Destroy[];	z.FREE[@typeIn];	z.FREE[@run];        END;      ENDCASE;    END;  -- PUBLIC PROC  RegisterBurdockWindow: PROCEDURE [window: Window.Handle] =    BEGIN    IF bw = NIL THEN bw ¬ z.NEW[BurdockWindowSeq[10] ¬ []]      ELSE IF bw.length >= bw.maxlength THEN      BEGIN      oldBW: BurdockWindows ¬ bw;      bw ¬ z.NEW[BurdockWindowSeq[oldBW.maxlength + 10] ¬ [oldBW.length]];      Inline.LongCOPY[from: @oldBW[0], to: @bw[0], nwords: SIZE[Window.Handle, oldBW.length]];      z.FREE[@oldBW];      END;    bw[bw.length] ¬ window;    bw.length ¬ bw.length + 1;    END;      UnloadBermuda: Exec.ExecProc =    BEGIN    Exec.RemoveCommand [h, "CPBermudaDaybreak.~"L];    CPDestroyWindow.CPMesaDestroy[];    CPDestroyWindow.CPSymbolDebugDestroy[];    IF bw # NIL THEN      BEGIN      FOR i: CARDINAL IN [0..bw.length) DO        Tool.Destroy [bw[i]];      ENDLOOP;      z.FREE[@bw];      END;    END;	  IgnoreCommandLine: Exec.ExecProc =    BEGIN IF NOT initialized THEN Initialize[h]; END;  StartUp: PROCEDURE =    BEGIN Exec.AddCommand[name: "CPBermudaDaybreak.~"L, proc: IgnoreCommandLine, unload: UnloadBermuda]; END;	  StartUp[];  END.-- Log of last edits-- JAC	30-May-85 16:42:36	CP renamed to CPDefs; CPBreak renamed to CPBreakDefs-- JAC	31-May-85  9:46:06	CPKernel renamed to CPKernelDefs; CPSymbols renamed to CPSymbl; CPKernelOps renamed to CPKernelOp-- JAC	21-Jun-85 15:30:33	rearrange command items-- JAC	21-Jun-85 16:13:13	destroy CPMesa window before unloading-- JAC	 8-Jul-85 11:06:04	make PollCP a command-- RDH	 9-Dec-85 15:53:59	Add Bank item for 8K-- RDH	28-Jan-86 19:19:04	Added CheckBankNumber for bank item.
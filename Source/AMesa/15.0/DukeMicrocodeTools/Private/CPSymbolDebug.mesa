-- Copyright (C) 1983, 1985  by Xerox Corporation. All rights reserved. -- CPSymbolDebug.mesa, JAC, 21-Jun-85 16:54:15DIRECTORY  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, CommandItem,    newLine, ProcType],  Put USING [CR, Decimal, Line, Number, Text],  Runtime USING [GetBcdTime],  String USING [AppendString],  Time USING [Append, Unpack],  Tool USING [Create, Destroy, MakeFormSW, MakeFileSW, MakeSWsProc,     UnusedLogName],  ToolWindow USING [TransitionProcType],  UserInput USING [UserAbort],  Window USING [Handle],    CPDefs USING [Cycle, RealCS, RReg, Task, UReg],  CPDestroyWindow,  CPSymbl USING [    AppendAllRReg, AppendAllRH, AppendAllUReg, AppendNumber, AppendVirturalCS,    EnumerateCSSymbols, EnumerateRRegSymbols, EnumerateRHSymbols,    EnumerateURegSymbols, EnumerateMap,    LookupInRHTable, LookupInRRegTable, LookupInURegTable, VirturalCS];CPSymbolDebug: PROGRAM  IMPORTS    FormSW, Put, Runtime, String, Time, Tool, UserInput, CPSymbl   EXPORTS CPDestroyWindow =  BEGIN    cpSymbolDebugWindow, form, log: Window.Handle;  CS: FormSW.ProcType =    BEGIN    n: CARDINAL ¬ 0;    PrintOne: PROCEDURE [s: LONG STRING, virt: CPSymbl.VirturalCS] =      BEGIN      n ¬ n + 1;      IF UserInput.UserAbort[log] THEN RETURN;      Put.Number[log, virt, [16, FALSE, TRUE, 4]];      Put.Text[log, "  "L];      Put.Text[log, s];      Put.CR[log];      END;    Put.Line[log, "Control Store symbols"L];    CPSymbl.EnumerateCSSymbols[PrintOne];    Put.Text[log, "There are "L];    Put.Decimal[log, n];    Put.Line[log, " Control Store symbols."L];    Put.CR[log];    END;  Map: FormSW.ProcType =    BEGIN    n: CARDINAL ¬ 0;    PrintOne: PROCEDURE [real: CPDefs.RealCS, virt: CPSymbl.VirturalCS, cycle: CPDefs.Cycle, task: CPDefs.Task] =      BEGIN      n ¬ n + 1;      IF UserInput.UserAbort[log] THEN RETURN;      Put.Number[log, real, [16, FALSE, TRUE, 4]];      Put.Number[log, virt, [16, FALSE, TRUE, 5]];      SELECT cycle FROM        c1 => Put.Text[log, " c1"L];        c2 => Put.Text[log, " c2"L];        c3 => Put.Text[log, " c3"L];        any => Put.Text[log, " c*"L];        ENDCASE => ERROR;      Put.Number[log, task, [16, FALSE, TRUE, 2]];      Put.CR[log];      END;    Put.Line[log, "Control Storage Map Info"L];    Put.Line[log, "real virt cy  t"L];    CPSymbl.EnumerateMap[PrintOne];    Put.Text[log, "There are "L];    Put.Decimal[log, n];    Put.Line[log, " active map slots."L];    Put.CR[log];    END;	  Info: FormSW.ProcType =    BEGIN    n: CARDINAL ¬ 0;    PrintOne: PROCEDURE [real: CPDefs.RealCS, virt: CPSymbl.VirturalCS, cycle: CPDefs.Cycle, task: CPDefs.Task] =      BEGIN      temp: STRING = [100];      n ¬ n + 1;      IF UserInput.UserAbort[log] THEN RETURN;      Put.Number[log, real, [16, FALSE, TRUE, 4]];      Put.Number[log, virt, [16, FALSE, TRUE, 5]];      SELECT cycle FROM        c1 => Put.Text[log, " c1"L];        c2 => Put.Text[log, " c2"L];        c3 => Put.Text[log, " c3"L];        any => Put.Text[log, " c*"L];        ENDCASE => ERROR;      Put.Number[log, task, [16, FALSE, TRUE, 2]];      Put.Text[log, "  "L];      CPSymbl.AppendVirturalCS[temp, virt];      Put.Text[log, temp];      Put.CR[log];      END;    Put.Line[log, "Control Storage Map+Symbol Info"L];    Put.Line[log, "real virt cy  t  symbol"L];    CPSymbl.EnumerateMap[PrintOne];    Put.Text[log, "There are "L];    Put.Decimal[log, n];    Put.Line[log, " active map slots."L];    Put.CR[log];    END;	  Duplicates: FormSW.ProcType =    BEGIN    PrintDuplicates: PROCEDURE [s: LONG STRING, virt: CPSymbl.VirturalCS] =      BEGIN      ok: BOOLEAN;      r: CPDefs.RReg;      u: CPDefs.UReg;      [ok, r] ¬ CPSymbl.LookupInRRegTable[s];      IF ok THEN        BEGIN	Put.Text[log, "CS symbol "L];	Put.Text[log, s];	Put.Text[log, " clashes with .R "L];        Put.Number[log, r, [16, FALSE, TRUE, 1]];	Put.Line[log, "."L];	END;      [ok, r] ¬ CPSymbl.LookupInRHTable[s];      IF ok THEN        BEGIN	Put.Text[log, "CS symbol "L];	Put.Text[log, s];	Put.Text[log, " clashes with .RH "L];        Put.Number[log, r, [16, FALSE, TRUE, 1]];	Put.Line[log, "."L];	END;      [ok, u] ¬ CPSymbl.LookupInURegTable[s];      IF ok THEN        BEGIN	Put.Text[log, "CS symbol "L];	Put.Text[log, s];	Put.Text[log, " clashes with .U "L];        Put.Number[log, u, [16, FALSE, TRUE, 2]];	Put.Line[log, "."L];	END;      END;    Put.Line[log, "Scaning for Duplicate symbols:"L];    CPSymbl.EnumerateCSSymbols[PrintDuplicates];    Put.Line[log, "Done."L];    END;	  RRegs: FormSW.ProcType =    BEGIN    n: CARDINAL ¬ 0;    PrintOne: PROCEDURE [s: LONG STRING, r: CPDefs.RReg] =      BEGIN      n ¬ n + 1;      IF UserInput.UserAbort[log] THEN RETURN;      Put.Number[log, r, [16, FALSE, TRUE, 4]];      Put.Text[log, "  "L];      Put.Text[log, s];      Put.CR[log];      END;    Put.Line[log, "R Register symbols"L];    CPSymbl.EnumerateRRegSymbols[PrintOne];    Put.Text[log, "There are "L];    Put.Decimal[log, n];    Put.Line[log, " R register symbols."L];    Put.CR[log];    END;  RRegsTable: FormSW.ProcType =    BEGIN    Put.Line[log, "R Register table"L];    FOR r: CPDefs.RReg IN CPDefs.RReg DO      temp: STRING = [200];      String.AppendString[temp, ".R "L];      CPSymbl.AppendNumber[temp, r];      String.AppendString[temp, " = "L];      CPSymbl.AppendAllRReg[temp, r];      Put.Text[log, temp];      Put.Line[log, "."];      ENDLOOP;    Put.CR[log];    END;      RHRegs: FormSW.ProcType =    BEGIN    n: CARDINAL ¬ 0;    PrintOne: PROCEDURE [s: LONG STRING, r: CPDefs.RReg] =      BEGIN      n ¬ n + 1;      IF UserInput.UserAbort[log] THEN RETURN;      Put.Number[log, r, [16, FALSE, TRUE, 4]];      Put.Text[log, "  "L];      Put.Text[log, s];      Put.CR[log];      END;    Put.Line[log, "RH Register symbols"L];    CPSymbl.EnumerateRHSymbols[PrintOne];    Put.Text[log, "There are "L];    Put.Decimal[log, n];    Put.Line[log, " RH register symbols."L];    Put.CR[log];    END;  RHRegsTable: FormSW.ProcType =    BEGIN    Put.Line[log, "RH Register table"L];    FOR r: CPDefs.RReg IN CPDefs.RReg DO      temp: STRING = [200];      String.AppendString[temp, ".RH "L];      CPSymbl.AppendNumber[temp, r];      String.AppendString[temp, " = "L];      CPSymbl.AppendAllRH[temp, r];      Put.Text[log, temp];      Put.Line[log, "."];      ENDLOOP;    Put.CR[log];    END;      URegs: FormSW.ProcType =    BEGIN    n: CARDINAL ¬ 0;    PrintOne: PROCEDURE [s: LONG STRING, u: CPDefs.UReg] =      BEGIN      n ¬ n + 1;      IF UserInput.UserAbort[log] THEN RETURN;      Put.Number[log, u, [16, FALSE, TRUE, 4]];      Put.Text[log, "  "L];      Put.Text[log, s];      Put.CR[log];      END;    Put.Line[log, "U Register symbols"L];    CPSymbl.EnumerateURegSymbols[PrintOne];    Put.Text[log, "There are "L];    Put.Decimal[log, n];    Put.Line[log, " U Register symbols."L];    Put.CR[log];    END;  URegsTable: FormSW.ProcType =    BEGIN    Put.Line[log, "U Register table"L];    FOR u: CPDefs.UReg IN CPDefs.UReg DO      temp: STRING = [200];      String.AppendString[temp, ".U "L];      CPSymbl.AppendNumber[temp, u];      String.AppendString[temp, " = "L];      CPSymbl.AppendAllUReg[temp, u];      Put.Text[log, temp];      Put.Line[log, "."];      ENDLOOP;    Put.CR[log];    END;      CPSymbolDebugDestroy: PUBLIC PROCEDURE = {Tool.Destroy[cpSymbolDebugWindow]};      Initialize: PROCEDURE =    BEGIN    herald: STRING = [40];    String.AppendString[herald, "CPSymbolDebug of "L];    Time.Append[herald, Time.Unpack[Runtime.GetBcdTime[]]];    cpSymbolDebugWindow ¬ Tool.Create[      name: herald,      cmSection: "CPSyms Debug"L,      initialState: inactive,      makeSWsProc: MakeSWs,      clientTransition: ClientTransition];    END;    MakeSWs: Tool.MakeSWsProc =    BEGIN    logFileName: STRING = [40];    Tool.UnusedLogName[logFileName, "CPSymsDebug.log$"L];    form ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    log ¬ Tool.MakeFileSW[window: window, name: logFileName];    END;    MakeForm: FormSW.ClientItemsProcType =    BEGIN    nParams: CARDINAL = 10;    items ¬ FormSW.AllocateItemDescriptor[nParams];    items[0] ¬ FormSW.CommandItem[tag: "CS"L, proc: CS, place: FormSW.newLine];    items[1] ¬ FormSW.CommandItem[tag: "Map"L, proc: Map];    items[2] ¬ FormSW.CommandItem[tag: "Info"L, proc: Info];    items[3] ¬ FormSW.CommandItem[tag: "Duplicates"L, proc: Duplicates];    items[4] ¬ FormSW.CommandItem[tag: "RRegs"L, proc: RRegs, place: FormSW.newLine];    items[5] ¬ FormSW.CommandItem[tag: "RRegsTable"L, proc: RRegsTable];    items[6] ¬ FormSW.CommandItem[tag: "RHRegs"L, proc: RHRegs, place: FormSW.newLine];    items[7] ¬ FormSW.CommandItem[tag: "RHRegsTable"L, proc: RHRegsTable];    items[8] ¬ FormSW.CommandItem[tag: "URegs"L, proc: URegs, place: FormSW.newLine];    items[9] ¬ FormSW.CommandItem[tag: "URegsTable"L, proc: URegsTable];    RETURN[items, TRUE];    END;       ClientTransition: ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      old = inactive =>        BEGIN        END;      new = inactive =>        BEGIN        END;      ENDCASE;    END;	  Initialize[];  END.-- Log of last edits-- JAC	30-May-85 16:42:36	CP renamed to CPDefs-- JAC	30-May-85 16:42:36	rename module; CPSymbols renamed to CPSymbl-- JAC	21-Jun-85 16:54:27	added proc to destroy window
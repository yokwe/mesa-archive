-- Copyright (C) 1983, 1985  by Xerox Corporation. All rights reserved. -- Last edit by RDH 		 9-Dec-85 16:22:12 -- from CPLoader.mesa, HGM, 23-Oct-83 18:33:47DIRECTORY  Environment USING [bytesPerWord, LongNumber, wordsPerPage],  Format USING [CR, Line, LongDecimal, StringProc, Text],  Heap USING [systemZone],  MStream USING [Error, ReadOnly],  Stream USING [Delete, EndOfStream, GetBlock, GetWord, Handle],  String USING [AppendExtensionIfNeeded, CopyToNewString],  System USING [GetClockPulses, Pulses, PulsesToMicroseconds],  CPDefs USING [Bank, Cycle, maxMIs, RealCS, sizeOfCS, wordsPerBank],  CPMIFormat USING [MI],  CPCommand USING [Error, RefreshWindow],  CPKernelDefs USING [    ContinueCP, DebuggeeReady, Error, OneMI, ReadBank, WriteCSBlock, WriteMemoryBlock, WriteTpc],  CPKernelOp,  CPSymbl USING [    AddCSSymbol, AddRHSymbol, AddRRegSymbol, AddToMap, AddURegSymbol,    Error, VirturalCS],  MassFileFormat USING [FinalBinaryRec, LabelSymbolRec];CPLoadImpl: PROGRAM  IMPORTS    Format, Heap, MStream, Stream, String, System,    CPCommand, CPKernelDefs, CPSymbl  EXPORTS CPCommand, CPKernelOp =  BEGIN    z: UNCOUNTED ZONE = Heap.systemZone;      --Load:  --Copy the MI's from the given file into the given bank of control store.  --log and arg are for messages.  Load: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER,     file: LONG STRING, bank: CARDINAL] =    BEGIN ENABLE CPKernelDefs.Error => ERROR CPCommand.Error[reason];    filename: LONG STRING;    stream: Stream.Handle;    filename ¬ String.CopyToNewString[file, z];    [] ¬ String.AppendExtensionIfNeeded[@filename, "fb"L, z];    Format.Text[log, "Loading CP from "L, arg];    Format.Text[log, filename, arg];    Format.Line[log, "."L, arg];    stream ¬ MStream.ReadOnly[filename, [] ! MStream.Error =>      ERROR CPCommand.Error["Can't read that file"] ];    CPKernelDefs.DebuggeeReady[];    LoadFromStream[log, arg, stream, bank !      UNWIND => BEGIN Stream.Delete[stream]; z.FREE[@filename]; END];    Stream.Delete[stream];    z.FREE[@filename];    CPKernelDefs.ContinueCP[];    CPCommand.RefreshWindow[];    END;          --LoadFromStream:  --Copy the MI's from the given stream into the given bank of control store.  --log and arg are for messages.  LoadFromStream: PROCEDURE [log: Format.StringProc, arg: LONG POINTER,     stream: Stream.Handle, bank: CPDefs.Bank] =    BEGIN ENABLE      BEGIN      Stream.EndOfStream => ERROR CPCommand.Error["Truncated fb file"L];      CPKernelDefs.Error => ERROR CPCommand.Error[reason];      END;    start, stop: System.Pulses;    ms: LONG CARDINAL;    instructions: CARDINAL ¬ 0;    fbrBytes: CARDINAL = Environment.bytesPerWord*SIZE[MassFileFormat.FinalBinaryRec];    b: POINTER = @fbr;    fbr: MassFileFormat.FinalBinaryRec ¬ TRASH;    pb: POINTER TO CPMIFormat.MI = LOOPHOLE[@fbr.partialBinary];    last: CARDINAL ¬ 0;    miInClump: CARDINAL ¬ 0;    clump: ARRAY [0..CPDefs.maxMIs) OF CPKernelDefs.OneMI;    offset: CARDINAL = bank * CPDefs.wordsPerBank; --Hack until Mass is smarter    start ¬ System.GetClockPulses[];    DO      bytes: CARDINAL;      [bytes, , ] ¬ Stream.GetBlock[          sH: stream,          block: [            blockPointer: b,	    startIndex: 0,            stopIndexPlusOne: fbrBytes]];      IF bytes # fbrBytes THEN ERROR CPCommand.Error["Truncated fb"];      IF fbr.addr >= CPDefs.sizeOfCS THEN EXIT;      fbr.addr ¬ fbr.addr + offset;      IF fbr.miNum = 0FFFFH THEN        BEGIN        CPKernelDefs.WriteTpc[fbr.partialBinary.task, fbr.addr];        END      ELSE        BEGIN	IF instructions # 0 THEN	  BEGIN	  IF last + 1 # fbr.addr OR miInClump = CPDefs.maxMIs THEN	    BEGIN	    CPKernelDefs.WriteCSBlock[miInClump, @clump];	    miInClump ¬ 0;	    END;	  END;	clump[miInClump] ¬ [fbr.addr, pb­];	last ¬ fbr.addr;	miInClump ¬ miInClump + 1;	instructions ¬ instructions + 1;        IF TRUE THEN	  BEGIN          cycle: CPDefs.Cycle;          cycle ¬ SELECT fbr.partialBinary.cycle FROM	    0 => any,            1 => c1,            2 => c2,            3 => c3,	    ENDCASE => ERROR;	  fbr.miNum ¬ fbr.miNum + offset;	  CPSymbl.AddToMap[fbr.addr, fbr.miNum, cycle, fbr.partialBinary.task];	  END;        END      ENDLOOP;    IF miInClump # 0 THEN CPKernelDefs.WriteCSBlock[miInClump, @clump];    stop ¬ System.GetClockPulses[];    ms ¬ System.PulsesToMicroseconds[[stop - start]]/1000;    Info[log, arg, ms, instructions];    END;      LoadFromMemory: PUBLIC PROCEDURE [fbFile: LONG POINTER, bank: CPDefs.Bank] =    BEGIN    fbr: LONG POINTER TO MassFileFormat.FinalBinaryRec ¬ fbFile;    miInClump: CARDINAL ¬ 0;    clump: ARRAY [0..CPDefs.maxMIs) OF CPKernelDefs.OneMI;    offset: CARDINAL = bank * CPDefs.wordsPerBank;  -- ***  Hack until Mass is smarter    last: CARDINAL ¬ fbr.addr + offset - 1;    DO      IF fbr.addr >= CPDefs.sizeOfCS THEN EXIT;      -- (WriteProtected) fbr.addr ¬ fbr.addr + offset;      IF fbr.miNum = 0FFFFH THEN        BEGIN        CPKernelDefs.WriteTpc[fbr.partialBinary.task, fbr.addr + offset];        END      ELSE        BEGIN        pb: LONG POINTER TO CPMIFormat.MI = LOOPHOLE[@fbr.partialBinary];	IF last + 1 # fbr.addr + offset OR miInClump = CPDefs.maxMIs THEN	  BEGIN          CPKernelDefs.WriteCSBlock[miInClump, @clump];	  miInClump ¬ 0;	  END;	last ¬ fbr.addr + offset;	clump[miInClump] ¬ [fbr.addr + offset, pb­];	miInClump ¬ miInClump + 1;        END;      fbr ¬ fbr + SIZE[MassFileFormat.FinalBinaryRec];      ENDLOOP;    IF miInClump # 0 THEN CPKernelDefs.WriteCSBlock[miInClump, @clump];    END;    <<  LoadOverlay: PUBLIC PROCEDURE [fbFile: LONG POINTER] =    BEGIN ENABLE      BEGIN      CPKernelDefs.Error => ERROR CPCommand.Error[reason];      END;    fbr: LONG POINTER TO MassFileFormat.FinalBinaryRec ¬ fbFile;    miInClump: CARDINAL ¬ 0;    clump: ARRAY [0..CPDefs.maxMIs) OF CPKernelDefs.OneMI;    offset: CARDINAL = CPKernelDefs.ReadBank[] * CPDefs.wordsPerBank;  -- ***  Hack until Mass is smarter    last: CARDINAL ¬ fbr.addr + offset - 1;    DO      IF fbr.addr >= CPDefs.sizeOfCS THEN EXIT;      IF fbr.miNum = 0FFFFH THEN  ERROR CPKernelDefs.Error["Can't set TPC in Overlay"L]      ELSE        BEGIN        pb: LONG POINTER TO CPMIFormat.MI = LOOPHOLE[@fbr.partialBinary];	IF miInClump = CPDefs.maxMIs THEN CPKernelDefs.Error["Overlay too big"L];	IF last + 1 # fbr.addr + offset THEN	  BEGIN	  CPKernelDefs.WriteCSBlock[miInClump, @clump];	  miInClump ¬ 0;	  END;	last ¬ fbr.addr + offset;      	clump[miInClump] ¬ [fbr.addr, pb­];	miInClump ¬ miInClump + 1;        END;      fbr ¬ fbr + SIZE[MassFileFormat.FinalBinaryRec];      ENDLOOP;    IF miInClump # 0 THEN CPKernelDefs.WriteCSBlock[miInClump, @clump];    END;>>      Info: PROCEDURE [log: Format.StringProc, arg: LONG POINTER, ms, instructions: LONG CARDINAL] =    BEGIN    Format.Text[log, "It took "L, arg];    Format.LongDecimal[log, ms, arg];    Format.Text[log, " ms to load "L, arg];    Format.LongDecimal[log, instructions, arg];    Format.Text[log, " instructions."L, arg];    IF ms # 0 THEN      BEGIN      Format.Text[log, " ("L, arg];      Format.LongDecimal[log, instructions*16*SIZE[CPMIFormat.MI]*1000/ms, arg];      Format.Text[log, " bits/sec)"L, arg];      END;    Format.CR[log, arg];    END;   LoadSymbols: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, file: LONG STRING, bank: CARDINAL] =    BEGIN    filename: LONG STRING;    stream: Stream.Handle;    filename ¬ String.CopyToNewString[file, z];    [] ¬ String.AppendExtensionIfNeeded[@filename, "st"L, z];    Format.Text[log, "Loading CP symbols from "L, arg];    Format.Text[log, filename, arg];    Format.Line[log, "."L, arg];    stream ¬ MStream.ReadOnly[filename, [] ! MStream.Error =>      ERROR CPCommand.Error["Can't read that file"] ];    LoadSymbolsFromStream[log, arg, stream, bank !      UNWIND => BEGIN Stream.Delete[stream]; z.FREE[@filename]; END ];    Stream.Delete[stream];    z.FREE[@filename];    END;      LoadSymbolsFromStream: PROCEDURE [log: Format.StringProc, arg: LONG POINTER, stream: Stream.Handle, bank: CARDINAL] =    BEGIN    start, stop: System.Pulses;    ms: LONG CARDINAL;    tags, rReg, rH, uReg: CARDINAL ¬ 0;    lsr: MassFileFormat.LabelSymbolRec ¬ TRASH;    bytesPerRec: CARDINAL = Environment.bytesPerWord*SIZE[MassFileFormat.LabelSymbolRec];    sym: LONG STRING = [100];    offset: CARDINAL = bank * CPDefs.wordsPerBank;  -- ***  Hack until Mass is smarter    start ¬ System.GetClockPulses[];    DO      bytes, wordsExpected: CARDINAL;      [bytes, , ] ¬ Stream.GetBlock[        sH: stream,        block: [          blockPointer: LOOPHOLE[LONG[@lsr]],	  startIndex: 0,          stopIndexPlusOne: bytesPerRec]];      IF bytes = 0 THEN EXIT;      IF bytes # bytesPerRec THEN ERROR CPCommand.Error["Symbol file truncated"L];      IF lsr.length = 0 THEN ERROR CPCommand.Error["Zero length tag"L];      IF lsr.length > sym.maxlength THEN ERROR CPCommand.Error["Huge label string"L];      wordsExpected ¬ (lsr.length + (Environment.bytesPerWord - 1))/Environment.bytesPerWord;      [bytes, , ] ¬  Stream.GetBlock[        sH: stream,        block: [          blockPointer: LOOPHOLE[@sym.text],	  startIndex: 0,          stopIndexPlusOne: Environment.bytesPerWord*wordsExpected]];      sym.length ¬ lsr.length;      BEGIN ENABLE CPSymbl.Error =>        BEGIN	Format.Text[log, "Troubles adding "L, arg];	Format.Text[log, sym, arg];	Format.Text[log, " to symbol table: "L, arg];	Format.Text[log, reason, arg];	Format.CR[log, arg];	CONTINUE;	END;      WITH lsr SELECT FROM        label =>	  BEGIN	  virt: CPSymbl.VirturalCS;	  IF miIndex >= 4096 THEN ERROR;	  virt ¬ miIndex + offset;	  CPSymbl.AddCSSymbol[sym, virt];	  tags ¬ tags + 1;	  END;        regR =>	  BEGIN	  CPSymbl.AddRRegSymbol[sym, addr];	  rReg ¬ rReg + 1;	  END;        regRH =>	  BEGIN	  CPSymbl.AddRHSymbol[sym, addr];	  rH ¬ rH + 1;	  END;        regU =>	  BEGIN	  CPSymbl.AddURegSymbol[sym, addr];	  uReg ¬ uReg + 1;	  END;        ENDCASE => ERROR CPSymbl.Error["Unrecognized type in symbol record"L];       END;      ENDLOOP;    stop ¬ System.GetClockPulses[];    ms ¬ System.PulsesToMicroseconds[[stop - start]]/1000;    InfoSymbols[log, arg, ms, tags, rReg, rH, uReg];    END;    InfoSymbols: PROCEDURE [    log: Format.StringProc, arg: LONG POINTER, ms: LONG CARDINAL, tags, rReg, rH, uReg: CARDINAL] =    BEGIN    Format.Text[log, "It took "L, arg];    Format.LongDecimal[log, ms, arg];    Format.Text[log, " ms to load "L, arg];    Format.LongDecimal[log, tags, arg];    Format.Text[log, " tags, "L, arg];    Format.LongDecimal[log, rReg, arg];    Format.Text[log, " R, "L, arg];    Format.LongDecimal[log, rH, arg];    Format.Text[log, " RH, and "L, arg];    Format.LongDecimal[log, uReg, arg];    Format.Line[log, " U Reg symbols."L, arg];    END;  LoadReal: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, file: LONG STRING] =    BEGIN    filename: LONG STRING;    stream: Stream.Handle;    filename ¬ String.CopyToNewString[file, z];    [] ¬ String.AppendExtensionIfNeeded[@filename, "cpr"L, z];    Format.Text[log, "Loading real memory from "L, arg];    Format.Text[log, filename, arg];    Format.Line[log, "."L, arg];    stream ¬ MStream.ReadOnly[filename, [] ! MStream.Error =>      ERROR CPCommand.Error["Can't read that file"] ];    LoadRealFromStream[log, arg, stream !      UNWIND => BEGIN Stream.Delete[stream]; z.FREE[@filename]; END ];    Stream.Delete[stream];    z.FREE[@filename];    CPCommand.RefreshWindow[];    END;  LoadRealFromStream: PROCEDURE [log: Format.StringProc, arg: LONG POINTER, stream: Stream.Handle] =    BEGIN ENABLE      Stream.EndOfStream => ERROR CPCommand.Error["Truncated cpr file"L];    buffer: ARRAY [0..Environment.wordsPerPage) OF WORD;    start, stop: System.Pulses;    ms: LONG CARDINAL;    wordsStored, blocks: LONG CARDINAL ¬ 0;    start ¬ System.GetClockPulses[];    DO      words, bytes: CARDINAL ¬ 0;      where: Environment.LongNumber;      words ¬ Stream.GetWord[stream];      IF words = 0 THEN EXIT;      IF words > Environment.wordsPerPage THEN        ERROR CPCommand.Error["CPR Block larger than a page"L];      where.highbits ¬ Stream.GetWord[stream];      where.lowbits ¬ Stream.GetWord[stream];      [bytes, , ] ¬ Stream.GetBlock[        sH: stream,        block: [	  blockPointer: LOOPHOLE[LONG[@buffer]],	  startIndex: 0,          stopIndexPlusOne: Environment.bytesPerWord*words]];      IF bytes # Environment.bytesPerWord * words THEN ERROR CPCommand.Error["Truncated CPR"L];      CPKernelDefs.WriteMemoryBlock[where.lp, words, @buffer        ! CPKernelDefs.Error => ERROR CPCommand.Error[reason] ];      blocks ¬ blocks + 1;      wordsStored ¬ wordsStored + words;      ENDLOOP;    stop ¬ System.GetClockPulses[];    ms ¬ System.PulsesToMicroseconds[[stop - start]]/1000;    InfoReal[log, arg, ms, wordsStored, blocks];    END;	  InfoReal: PROCEDURE [log: Format.StringProc, arg: LONG POINTER, ms, words, blocks: LONG CARDINAL] =    BEGIN    Format.Text[log, "It took "L, arg];    Format.LongDecimal[log, ms, arg];    Format.Text[log, " ms to load "L, arg];    Format.LongDecimal[log, words, arg];    Format.Text[log, " words in "L, arg];    Format.LongDecimal[log, blocks, arg];    Format.Text[log, " blocks."L, arg];    IF ms # 0 THEN      BEGIN      Format.Text[log, " ("L, arg];      Format.LongDecimal[log, words*16*1000/ms, arg];      Format.Text[log, " bits/sec)"L, arg];      END;    Format.CR[log, arg];    END;  END.-- Log of last edits-- JAC	30-May-85 16:42:36	CP renamed to CPDefs-- JAC	31-May-85  9:46:06	CPKernel renamed to CPKernelDefs; CPSymbols renamed to CPSymbl; CPMI renamed to CPMIFormat; CPKernelOps renamed to CPKernelOp-- JAC	28-Oct-85 16:08:38	don't ContinueCP if error in loading-- RDH	 9-Dec-85 16:21:55	Add bank parameter to Load, LoadSymbols commands.
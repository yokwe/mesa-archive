-- Copyright (C) 1984, 1985  by Xerox Corporation. All rights reserved. -- Last edit by RDH          3-Feb-86 16:43:13 -- from CPCommander.mesa, HGM, 21-Jan-84 15:27:03DIRECTORY  Format USING [Decimal, Line, Number, StringProc, Text],  Process USING [MsecToTicks, Pause],  String USING [AppendString, InvalidNumber, StringToNumber],  System USING [AdjustGreenwichMeanTime, GetGreenwichMeanTime, GreenwichMeanTime],    CommandFile USING [AbortProc],  CPDefs USING [Bank, Cycle, RealCS, Task],  CPMIFormat USING [MI],  CPCommand USING [Load, RefreshWindow],  CPBreakDefs USING [Break, Error, FindBreak,         GetLastBreakInfo, InstallBreaks, RemoveBreaks, Reset, Unbreak],  CPKernelDefs USING [AtBreak, Boot, ContinueAfterBreak, ContinueAfterStop,     Error, FindBanks, GetBreakID, InKernel, LoadKernel, LoadKernelHigh, PollCP,  ProbeForStateChange,     Reset, StartKernel, Start, State, Stop, WriteBank, WriteTpc],  CPKernelOp USING [GetState, SetNewState],  CPPanel USING [AppendPanelData, Initialize],  CPSymbl USING [    AppendRealCS, AppendVirturalCS, ClearSymbolTable, Error,     GetPcCycleAndTask, nullVirturalCS, RealToVirturalCS, VirturalCS];CPCommandImpl: PROGRAM  IMPORTS    Format, Process, String, System, CPBreak: CPBreakDefs, CPCommand,     CPKernelDefs, CPKernelOp, CPPanel, CPSymbl  EXPORTS CPCommand =  BEGIN  Error: PUBLIC ERROR [reason: LONG STRING] = CODE;    Boot: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER] =    BEGIN ENABLE      BEGIN      CPBreak.Error => ERROR Error[reason];      CPKernelDefs.Error => ERROR Error[reason];      END;    banks: CPDefs.Bank;    Format.Text[log, "Booting CP ... "L, arg];    CPSymbl.ClearSymbolTable[];		--Clear symbol table    CPBreak.Reset[];			--Clear all breaks    CPKernelDefs.Boot[];		--Set state to booted    banks ¬ CPKernelDefs.FindBanks[];	--Determine # of banks    Format.Text[log, "This machine has "L, arg];    Format.Decimal[log, banks, arg];    Format.Text[log, " banks of control store."L, arg];    Format.Text[log, "Loading Kernel for bank 0... "L, arg];    CPKernelDefs.LoadKernel[];  	--Load main kernel    Format.Line[log, "ok."L, arg];    FOR i: CARDINAL IN [1..banks) DO      Format.Text[log, "Loading Kernel for bank "L, arg];      Format.Decimal[log, i, arg];      Format.Text[log, " ... "L, arg];      CPKernelDefs.LoadKernelHigh[i]; 	--Load little kernel      Format.Line[log, "ok."L, arg];       ENDLOOP;       CPKernelDefs.StartKernel[];		--Start running in main kernel    --CPPanel.Initialize[];<<  banks ¬ CPKernelDefs.FindBanks[];    IF banks # 1 THEN      BEGIN      Format.Line[log, "ok."L, arg];      Format.Text[log, "This machine has "L, arg];      Format.Decimal[log, banks, arg];      Format.Text[log, " banks of control store.  Loading extra Kernels ... "L, arg];      FOR bank: CPDefs.Bank IN [1..banks) DO        CPKernelDefs.LoadKernelHigh[bank];        ENDLOOP;      CPKernelDefs.WriteBank[0];      END; >>    PrintState[log, arg];    CPCommand.RefreshWindow[];    END;  SetBank: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, s: LONG STRING] =    BEGIN ENABLE      BEGIN      CPKernelDefs.Error => ERROR Error[reason];      String.InvalidNumber => ERROR Error["Can't parse bank string"L];      END;    bank: CPDefs.Bank ¬ String.StringToNumber[s];    CPKernelDefs.WriteBank[bank];    Format.Text[log, "Now using bank "L, arg];    Format.Decimal[log, bank, arg];    Format.Line[log, "."L, arg];    END;  LoadRaw: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, filename: LONG STRING, bank: CARDINAL] =    BEGIN ENABLE      BEGIN      CPBreak.Error => ERROR Error[reason];      CPKernelDefs.Error => ERROR Error[reason];      END;    CPSymbl.ClearSymbolTable[];    CPBreak.Reset[];    CPKernelDefs.Boot[];    CPCommand.Load[log, arg, filename, bank];    CPKernelDefs.StartKernel[];    --CPPanel.Initialize[];    END;  Reset: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER] =    BEGIN ENABLE      BEGIN      CPBreak.Error => ERROR Error[reason];      CPKernelDefs.Error => ERROR Error[reason];      END;    IF ~ CPKernelDefs.InKernel[] THEN       ERROR CPKernelDefs.Error["Aborted... CP not in Kernel"L];    CPSymbl.ClearSymbolTable[];    CPBreak.Reset[];    CPKernelDefs.Reset[];    --CPPanel.Initialize[];    END;  SetPC: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, s: LONG STRING, s1: LONG STRING] =    BEGIN ENABLE CPKernelDefs.Error => ERROR Error[reason];    pc: CPDefs.RealCS;    cycle: CPDefs.Cycle;    task: CPDefs.Task;    Format.Text[log, "Setting PC to "L, arg];    Format.Text[log, s, arg];    [pc, cycle, task] ¬ CPSymbl.GetPcCycleAndTask[s ! CPSymbl.Error => ERROR Error[reason] ];    Format.Text[log, ", (.CR "L, arg];    Format.Number[log, pc, [16, FALSE, TRUE, 0], arg];    SELECT cycle FROM     c1 => NULL;     c2 => Format.Text[log, ", c2"L, arg];     c3 => Format.Text[log, ", c3"L, arg];     any => Format.Text[log, ", c*"L, arg];     ENDCASE => ERROR;    Format.Text[log, ")"L, arg];    IF cycle # c1 THEN ERROR Error["Can't set TPC to c2/c3/c*"L];    CPKernelDefs.WriteTpc[task, pc];    Format.Line[log, "."L, arg];    END;      Start: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, pc1: LONG STRING, pc2: LONG STRING] =    BEGIN ENABLE      BEGIN      CPBreak.Error => ERROR Error[reason];      CPKernelDefs.Error => ERROR Error[reason];      END;    SetPC[log, arg, pc1, pc2];    CPBreak.RemoveBreaks[];    CPBreak.InstallBreaks[];    CPKernelDefs.Start[];    CPCommand.RefreshWindow[];    END;     Continue: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, silent: BOOLEAN ¬ FALSE] =    BEGIN ENABLE      BEGIN      CPBreak.Error => ERROR Error[reason];      CPKernelDefs.Error => ERROR Error[reason];      END;    Format.Text[log, "Continuing CP ... "L, arg];    CPKernelDefs.ProbeForStateChange[log, arg];    SELECT CPKernelOp.GetState[] FROM      booted => ERROR CPKernelDefs.Error["Can't continue CP from boot"];      dead => ERROR CPKernelDefs.Error["CP and/or IOP is dead"];      halted => NULL;      running => ERROR CPKernelDefs.Error["CP is running"];      cpBreak => NULL;      ENDCASE => ERROR;    CPBreak.RemoveBreaks[];    IF CPKernelDefs.AtBreak[] THEN      BEGIN      location: CPDefs.RealCS;      cycle: CPDefs.Cycle;      task: CPDefs.Task;      mi: CPMIFormat.MI;      [location, cycle, task, mi] ¬ CPBreak.GetLastBreakInfo[];      Format.Text[log, "(from Break) "L, arg];      CPBreak.InstallBreaks[];      CPKernelDefs.ContinueAfterBreak[log, arg, mi, cycle, task];      END    ELSE  --start or continue from stop      BEGIN      CPBreak.InstallBreaks[];      CPKernelDefs.ContinueAfterStop[log, arg];      END;    -- Give easy breaks time to take => avoid double state change printout    Process.Pause[Process.MsecToTicks[250]];    IF ~silent THEN PrintState[log, arg];    CPCommand.RefreshWindow[];    END;    ContinueAndWait: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, abort: CommandFile.AbortProc, ms: LONG CARDINAL] =    BEGIN ENABLE      BEGIN      CPBreak.Error => ERROR Error[reason];      CPKernelDefs.Error => ERROR Error[reason];      END;    start: System.GreenwichMeanTime = System.GetGreenwichMeanTime[];    stop: System.GreenwichMeanTime = System.AdjustGreenwichMeanTime[start, (ms+999)/1000];    Continue[log, arg, FALSE];    DO      CPKernelDefs.ProbeForStateChange[log, arg];      IF CPKernelOp.GetState[] # running THEN EXIT;      Process.Pause[Process.MsecToTicks[500]];      IF abort[] THEN ERROR Error["UserAborted (STOP)"L];      IF ms = 0 THEN LOOP;  -- Forever case      IF System.GetGreenwichMeanTime[] > stop THEN ERROR Error["Didn't stop in time"L];      ENDLOOP;    CPBreak.RemoveBreaks[];    PrintState[log, arg];    CPCommand.RefreshWindow[];    END;    Stop: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER] =    BEGIN ENABLE CPKernelDefs.Error => ERROR Error[reason];    Format.Text[log, "Stopping CP ... "L, arg];    CPKernelDefs.Stop[log, arg];    CPCommand.RefreshWindow[];    END;    Break: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, s: LONG STRING] =    BEGIN ENABLE CPKernelDefs.Error => ERROR Error[reason];    pc: CPDefs.RealCS;    cycle: CPDefs.Cycle;    task: CPDefs.Task;    Format.Text[log, "Setting CP Break at "L, arg];    Format.Text[log, s, arg];    Format.Text[log, " = "L, arg];    [pc, cycle, task] ¬ CPSymbl.GetPcCycleAndTask[s ! CPSymbl.Error => ERROR Error[reason] ];    Format.Text[log, ".CR "L, arg];    Format.Number[log, pc, [16, FALSE, TRUE, 0], arg];    IF cycle = any THEN ERROR Error["Can't set breaks on c*"L];    CPBreak.Break[pc, cycle, task ! CPBreak.Error => ERROR Error[reason] ];    Format.Line[log, " ok."L, arg];<<  SELECT cycle FROM     c1 => NULL;     c2, c3 => Format.Line[log, "*** Warning: c2/c3 breaks are a bit flakey"L, arg];     ENDCASE => ERROR; >>  --is this still true?    END;    Unbreak: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, s: LONG STRING] =    BEGIN ENABLE CPKernelDefs.Error => ERROR Error[reason];    pc: CPDefs.RealCS;    cycle: CPDefs.Cycle;    task: CPDefs.Task;    Format.Text[log, "Clearing CP Break at "L, arg];    IF s # NIL THEN Format.Text[log, s, arg]    ELSE      BEGIN      Format.Text[log, "current break"L, arg];      IF ~CPKernelDefs.AtBreak[] THEN ERROR Error["Not at Break"L];      END;    Format.Text[log, " = "L, arg];    IF s = NIL THEN      BEGIN      [pc, cycle, task, ] ¬ CPBreak.GetLastBreakInfo[];      END    ELSE [pc, cycle, task] ¬ CPSymbl.GetPcCycleAndTask[s ! CPSymbl.Error => ERROR Error[reason] ];    Format.Text[log, ".CR "L, arg];    Format.Number[log, pc, [16, FALSE, TRUE, 0], arg];    CPBreak.Unbreak[pc, cycle, task ! CPBreak.Error => ERROR Error[reason] ];    Format.Line[log, " ok."L, arg];    END;      PollCP: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, bogus: BOOLEAN] RETURNS [BOOLEAN] =    BEGIN ENABLE CPKernelDefs.Error => ERROR Error[reason];    IF CPKernelDefs.PollCP[log, arg] THEN {      currentBreak: CARDINAL;      pc: CPDefs.RealCS;      temp: LONG STRING ¬ [200];      virtualPC: CPSymbl.VirturalCS;      temp.length ¬ 0;      Format.Text[log,"At break point #"L, arg];      currentBreak ¬ CPKernelDefs.GetBreakID[] + 1;      Format.Number[log, currentBreak, [10, FALSE, TRUE, 0], arg];      Format.Text[log,", located at "L,arg];      pc ¬ CPBreak.FindBreak[currentBreak];      CPSymbl.AppendRealCS[temp, pc];      [virtualPC, , ] ¬ CPSymbl.RealToVirturalCS[pc];      String.AppendString[temp, ", (VirtualCS = "L];      CPSymbl.AppendVirturalCS[temp, virtualPC];      String.AppendString[temp, ")"L];      Format.Line[log, temp, arg];      CPKernelOp.SetNewState[cpBreak];      CPCommand.RefreshWindow[];      RETURN[TRUE]};    Format.Line[log, "CP not at break"L, arg];    RETURN[FALSE];    END;      AutoPollCP: PUBLIC PROCEDURE [Format.StringProc, LONG POINTER] =     --this is only for CPCommand compatibility with Daisy    BEGIN    END;      PopIB: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER] =     --this is only for CPCommand compatibility with Daisy    BEGIN    END;      StartAndWait: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, pc1: LONG STRING, pc2: LONG STRING, abort: CommandFile.AbortProc, ms: LONG CARDINAL] =    --this is at present only for CPCommand compatibility with Daisy but should be implemented later    BEGIN ENABLE      BEGIN      CPBreak.Error => ERROR Error[reason];      CPKernelDefs.Error => ERROR Error[reason];      END;    start: System.GreenwichMeanTime = System.GetGreenwichMeanTime[];    stop: System.GreenwichMeanTime = System.AdjustGreenwichMeanTime[start, (ms+999)/1000];    Start[log, arg, pc1, pc2];    DO      CPKernelDefs.ProbeForStateChange[log, arg];      IF CPKernelOp.GetState[] # running THEN EXIT;      Process.Pause[Process.MsecToTicks[500]];      IF abort[] THEN ERROR Error["UserAborted (STOP)"L];      IF ms = 0 THEN LOOP;  -- Forever case      IF System.GetGreenwichMeanTime[] > stop THEN ERROR Error["Didn't stop in time"L];      ENDLOOP;    CPBreak.RemoveBreaks[];    PrintState[log, arg];    CPCommand.RefreshWindow[];    END;  CopyPanel: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER] =    BEGIN    Format.Line[log, " CopyPanel "L, arg];    CPPanel.AppendPanelData[arg];    END;      ClearPanel: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER] =    BEGIN    Format.Line[log, " Clearing panel "L, arg];    CPPanel.Initialize[];    END;      PrintState: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER] =    BEGIN    state: CPKernelDefs.State = CPKernelOp.GetState[];    SELECT state FROM      dead => Format.Text[log, "CP and/or IOP is dead"L, arg];      halted => Format.Text[log, "CP halted"L, arg];      running => Format.Text[log, "CP is running"L, arg];      cpBreak =>        BEGIN	temp: STRING = [200];	location: CPDefs.RealCS;        cycle: CPDefs.Cycle;        task: CPDefs.Task;	virt: CPSymbl.VirturalCS;        CPBreak.RemoveBreaks[ ! CPBreak.Error => ERROR Error[reason] ];        [location, cycle, task, ] ¬ CPBreak.GetLastBreakInfo[];	[virt, , ] ¬ CPSymbl.RealToVirturalCS[location];	Format.Text[log, "CP Break at "L, arg];        CPSymbl.AppendRealCS[temp, location];	IF virt # CPSymbl.nullVirturalCS THEN	  BEGIN	  String.AppendString[temp, ", ("L];          CPSymbl.AppendVirturalCS[temp, virt];	  String.AppendString[temp, ")"L];	  END;	String.AppendString[temp, ", "L];        AppendCycle[temp, cycle];	Format.Text[log, temp, arg];	END;      booted => Format.Text[log, "Booted"L, arg];      ENDCASE => ERROR;    Format.Line[log, "."L, arg];    END;      AppendCycle: PROCEDURE [s: LONG STRING, cycle: CPDefs.Cycle] =    BEGIN    SELECT cycle FROM      c1 => String.AppendString[s, "c1"L];      c2 => String.AppendString[s, "c2"L];      c3 => String.AppendString[s, "c3"L];      any => String.AppendString[s, "c*"L];      ENDCASE => ERROR;    END;      END.-- Log of last edits-- JAC	30-May-85 16:42:36	CP renamed to CPDefs; CPBreak renamed to CPBreakDefs-- JAC	31-May-85  9:46:06	CPKernel renamed to CPKernelDefs; CPSymbols renamed to CPSymbl; CPMI renamed to CPMIFormat; CPKernelOps renamed to CPKernelOp-- RDH	 6-Dec-85 14:37:29	Changed Boot for 8K control store.
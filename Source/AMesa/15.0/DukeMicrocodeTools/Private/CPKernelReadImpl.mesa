-- Copyright (C) 1983, 1985  by Xerox Corporation. All rights reserved. -- Last edit by JAC 		 9-Oct-85 14:25:26-- from CPKernelRead.mesa, HGM, 13-Jun-83 16:24:25DIRECTORY  Environment USING [LongNumber],  Inline USING [BITAND, BITNOT, BITSHIFT, LowHalf],  CPDefs USING [Link, IOReg, Map, MapEntry, mapOffset, OtherReg, RealMemory, RReg, UReg, VirturalMemory],  CPKernelDefs USING [ContinueCP, DebuggeeReady, Error, ReadRealMemory, WriteCS, WriteRealMemory],  CPKernelConst,  CPKernelOp USING [AddressOutOfRange, CantReadThatRegister],  CPMIFormat USING [FX, MI];CPKernelReadImpl: MONITOR   IMPORTS    Inline, CPKernelConst, CPKernelDefs, CPKernelOp  EXPORTS CPKernelDefs =  BEGIN OPEN CPKernelConst;    Nibble: TYPE = CARDINAL [0..16);    ReadRReg: PUBLIC ENTRY PROCEDURE [r: CPDefs.RReg] RETURNS [WORD] =    BEGIN ENABLE UNWIND => NULL;    RETURN[ReadRRegInternal[r]];    END;    ReadRRegInternal: INTERNAL PROCEDURE [r: CPDefs.RReg] RETURNS [WORD] =    BEGIN ENABLE UNWIND => NULL;    IF r ~IN CPDefs.RReg THEN CPKernelOp.AddressOutOfRange[];    CPKernelDefs.DebuggeeReady[];    CPKernelDefs.WriteCS[kRead, CPMIFormat.MI[      r, , za, rOrS, , , , , TRUE, , , , , , kReadPlus1]];    CPKernelDefs.WriteRealMemory[mailbox+1, readRegCommand];    CPKernelDefs.ContinueCP[];    Pause[];    RETURN[CPKernelDefs.ReadRealMemory[mailbox]];    END;      ReadRH: PUBLIC ENTRY PROCEDURE [rh: CPDefs.RReg] RETURNS [data: WORD] =    BEGIN ENABLE UNWIND => NULL;    RETURN[ReadRHRegInternal[rh]];    END;   ReadRHRegInternal: INTERNAL PROCEDURE [rh: CPDefs.RReg] RETURNS [data: WORD] =    BEGIN ENABLE UNWIND => NULL;    --kBuffer: IOPOData¬ RH<addr>, GOTO[kWait];    IF rh ~IN CPDefs.RReg THEN CPKernelOp.AddressOutOfRange[];    CPKernelDefs.DebuggeeReady[];    CPKernelDefs.WriteCS[kRead, CPMIFormat.MI[      , rh, dz, , , , , , TRUE, , ioxIn, , , [i[rh]], kReadPlus1]];      CPKernelDefs.WriteRealMemory[mailbox+1, readRegCommand];    CPKernelDefs.ContinueCP[];    Pause[];    RETURN[CPKernelDefs.ReadRealMemory[mailbox]];    END;    ReadRAndRH: PUBLIC ENTRY PROCEDURE [r: CPDefs.RReg] RETURNS [data: LONG POINTER] =    BEGIN    temp: Environment.LongNumber;    temp.high ¬ ReadRHRegInternal[r];    temp.low ¬ ReadRRegInternal[r];    RETURN[temp.lp];    END;   ReadUReg: PUBLIC ENTRY PROCEDURE [u: CPDefs.UReg] RETURNS [data: WORD] =    BEGIN ENABLE UNWIND => NULL;    RETURN[ReadURegInternal[u]];    END;  ReadURegInternal: INTERNAL PROCEDURE [u: CPDefs.UReg] RETURNS [data: WORD] =    BEGIN    addrH: Nibble ¬ Inline.BITAND[Inline.BITSHIFT[u, -4], 17B];    addrL: Nibble ¬ Inline.BITAND[u, 17B];    IF u ~IN CPDefs.UReg THEN CPKernelOp.AddressOutOfRange[];    CPKernelDefs.DebuggeeReady[];    CPKernelDefs.WriteCS[kBuffer, CPMIFormat.MI[      addrH, rK, dz, , wrB, , , TRUE, , , uAddr, , , [d[addrL]], kBuffer + 1]];    CPKernelDefs.WriteCS[kBuffer + 1, CPMIFormat.MI[      , , , , , , , , , , , , , , kBuffer + 2]];    CPKernelDefs.WriteCS[kBuffer + 2, CPMIFormat.MI[      , , , , , , , , , , , , , , kReadReg]];    CPKernelDefs.WriteCS[kRead, CPMIFormat.MI[      rK, , za, rOrS, noWr, , , , TRUE, , , , , , kReadPlus1]];    CPKernelDefs.WriteRealMemory[mailbox+1, bufferCommand];    CPKernelDefs.ContinueCP[];    Pause[];    RETURN[CPKernelDefs.ReadRealMemory[mailbox]];    END;       ReadOther: PUBLIC ENTRY PROCEDURE [other: CPDefs.OtherReg] RETURNS [data: WORD] =    BEGIN ENABLE UNWIND => NULL;    SELECT other FROM      q =>          BEGIN	CPKernelDefs.DebuggeeReady[];        CPKernelDefs.WriteCS[kRead, CPMIFormat.MI[          , , zq, , , , , , TRUE, , , , , , kReadPlus1]];	CPKernelDefs.WriteRealMemory[mailbox+1, readRegCommand];	CPKernelDefs.ContinueCP[];	Pause[];	data ¬ CPKernelDefs.ReadRealMemory[mailbox];        END;      ib =>  --IOXIn[C'x] ¬ibNA        BEGIN	ptr: CARDINAL ¬ Inline.BITAND[Inline.BITSHIFT[Inline.BITNOT[ReadIOInInternal[10]], -4], 3];	IF ptr = 0 THEN data ¬ 0        ELSE data ¬ ReadIOInInternal[0CH];        END;      pc16 =>        BEGIN	CPKernelDefs.DebuggeeReady[];	CPKernelDefs.WriteCS[kBuffer, CPMIFormat.MI[          , , , , , , , , , , , , , , kBuffer + 1]];        CPKernelDefs.WriteCS[kBuffer + 1, CPMIFormat.MI[          , rK, dz, rPlusS, wrB, , , , , , nibble, cinPC16, , [d[0]], kBuffer + 2]];        CPKernelDefs.WriteCS[kBuffer + 2, CPMIFormat.MI[	  , , dz, rPlusS, , , , , , , nibble, cinPC16, [d[0]], , kReadReg]];	CPKernelDefs.WriteCS[kRead, CPMIFormat.MI[	  , rK, zb, , , , , , TRUE, , , , , , kReadPlus1]];	CPKernelDefs.WriteRealMemory[mailbox+1, bufferCommand];        CPKernelDefs.ContinueCP[];	Pause[];        data ¬ CPKernelDefs.ReadRealMemory[mailbox];        END;      mInt =>        --kBuffer:   MesaIntBr, c1;        --kBuffer+3: BRANCH[MIZero, MIOne], c2;        --kBuffer+1: rK ¬ 0, GOTO[kReadReg], c3;        --kBuffer+2: rK ¬ 1, GOTO[kReadReg], c3;        BEGIN	CPKernelDefs.DebuggeeReady[];        CPKernelDefs.WriteCS[kBuffer, CPMIFormat.MI[          , , , , , , , , , dispBr, , , [b[mesaIntBr]], , kBuffer + 3]];        CPKernelDefs.WriteCS[          kBuffer + 3, CPMIFormat.MI[          , , , , , , , , , , , , , , kBuffer + 1]];        CPKernelDefs.WriteCS[          kBuffer + 1, CPMIFormat.MI[           , rK, za, rAndS, wrB, , , , , , , , , , kReadReg]];        CPKernelDefs.WriteCS[          kBuffer + 2, CPMIFormat.MI[            , rK, dz, , wrB, , , , , , nibble, , , [d[1]], kReadReg]];	CPKernelDefs.WriteCS[kRead, CPMIFormat.MI[	  , rK, zb, , , , , , TRUE, , , , , , kReadPlus1]];	CPKernelDefs.WriteRealMemory[mailbox+1, bufferCommand];        CPKernelDefs.ContinueCP[];	Pause[];        data ¬ CPKernelDefs.ReadRealMemory[mailbox];        END;      stackP =>  --low 4 bits of ~IOXIn[A'x]        BEGIN        data ¬ ReadIOInInternal[10];        data ¬ Inline.BITAND[Inline.BITNOT[data], 17B];        END;      ibPtr =>  --bits [10-11] of ~IOXIn[A'x]        BEGIN        data ¬ ReadIOInInternal[10];        data ¬ Inline.BITAND[Inline.BITSHIFT[Inline.BITNOT[data], -4], 3];        END;      ekErr =>  --bits [8-9] of IOXIn[A'x]        BEGIN        data ¬ ReadIOInInternal[10];        data ¬ Inline.BITAND[Inline.BITSHIFT[data, -6], 3];        END;      ENDCASE => CPKernelOp.CantReadThatRegister[];    RETURN[data];    END;    ReadIOIn: PUBLIC ENTRY PROCEDURE [io: CPDefs.IOReg] RETURNS [data: WORD] =    BEGIN    RETURN[ReadIOInInternal[io]];    END;  ReadIOInInternal: INTERNAL PROCEDURE [io: CPDefs.IOReg] RETURNS [data: WORD] =    BEGIN    IF io ~IN CPDefs.IOReg THEN CPKernelOp.AddressOutOfRange[];    IF io = 0BH THEN RETURN[ReadRHRegInternal[io]];    CPKernelDefs.DebuggeeReady[];    CPKernelDefs.WriteCS[kRead, CPMIFormat.MI[      , , dz, , , , , , TRUE, , ioxIn, , , [d[io]], kReadPlus1]];    CPKernelDefs.WriteRealMemory[mailbox+1, readRegCommand];    CPKernelDefs.ContinueCP[];    Pause[];    data ¬ CPKernelDefs.ReadRealMemory[mailbox];    END;      ReadLink: PUBLIC ENTRY PROCEDURE [link: CPDefs.Link] RETURNS [data: Nibble] =    BEGIN ENABLE UNWIND => NULL;    IF link ~IN CPDefs.Link THEN CPKernelOp.AddressOutOfRange[];    CPKernelDefs.DebuggeeReady[];    CPKernelDefs.WriteCS[kReadLink, CPMIFormat.MI[      , , , , , , , , , , , LOOPHOLE[link], , , kReadLinkPlus1]];    CPKernelDefs.WriteRealMemory[mailbox+1, readLinkCommand];    CPKernelDefs.ContinueCP[];    Pause[];    data ¬ CPKernelDefs.ReadRealMemory[mailbox];    END;  ReadMap: PUBLIC ENTRY PROCEDURE [map: CPDefs.Map] RETURNS [WORD] =    BEGIN ENABLE UNWIND => NULL;    RETURN[ReadMapInternal[map]];    END;   ReadMapInternal: INTERNAL PROCEDURE [map: CPDefs.Map] RETURNS [WORD] =    BEGIN    IF map ~IN CPDefs.Map THEN CPKernelOp.AddressOutOfRange[];    RETURN[CPKernelDefs.ReadRealMemory[LOOPHOLE[map + CPDefs.mapOffset]]];    END;   ReadVirturalMemory: PUBLIC PROCEDURE [virt: CPDefs.VirturalMemory] RETURNS [WORD] =    BEGIN    RETURN[CPKernelDefs.ReadRealMemory[MapAddress[virt]]];    END;   MapAddress: ENTRY PROCEDURE [virt: CPDefs.VirturalMemory] RETURNS [CPDefs.RealMemory] =    BEGIN ENABLE UNWIND => NULL;    a: LONG CARDINAL ¬ LOOPHOLE[virt];    page: CARDINAL = Inline.LowHalf[a/256];    offset: CARDINAL = Inline.LowHalf[a MOD 256];    mapEntry: CPDefs.MapEntry;    mapEntry ¬ LOOPHOLE[ReadMapInternal[page]];    IF mapEntry.w AND mapEntry.d THEN      ERROR CPKernelDefs.Error["Map entry is marked invalid"L];    a ¬ mapEntry.rpHigh*10000H + mapEntry.rpLow*256 + offset;    RETURN[LOOPHOLE[a]];    END;      Pause: PROCEDURE [msec: CARDINAL ¬ 50]		-- min pause time  	= {msec ¬ 0};  --just spend some time in local fram      END.-- Log of last edits-- JAC	30-May-85 16:42:36	CP renamed to CPDefs-- JAC	31-May-85  9:46:06	CPKernel renamed to CPKernelDefs; CPKernelConstants renamed to CPKernelConst; CPMI renamed to CPMIFormat; CPKernelOps renamed to CPKernelOp-- JAC	 9-Oct-85 14:25:43	import CPKernelConst for change in mailbox
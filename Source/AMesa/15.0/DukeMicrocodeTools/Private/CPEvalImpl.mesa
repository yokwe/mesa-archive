-- Copyright (C) 1983, 1985  by Xerox Corporation. All rights reserved. -- Last edit by JAC	31-May-85 10:44:40-- from CPEvaler.mesa, HGM, 13-Nov-83  0:53:57DIRECTORY  Ascii USING [CR, LF, FF, SP, TAB],  Inline USING [LowHalf],  String USING [AppendString, Equivalent, SubString, SubStringDescriptor],    CPDefs USING [    Cycle, IOReg, Link, Map, OtherReg, RealCS, RealMemory, RReg,    Task, UReg, VirturalMemory],  CPMIFormat USING [MI],  CPSymbl USING [    Error, LookupInCSTable, LookupInRRegTable, LookupInRHTable, LookupInURegTable,    nullRealCS, nullVirturalCS, RealToVirturalCS, Symbol, Type, VirturalCS, VirturalToRealCS],  Evaluate USING [Error, EvaluateSubString, Type, unspecified, Value],  StringExtras USING [StringToLongCardinal];CPEvalImpl: PROGRAM  IMPORTS Inline, String, CPSymbl, Evaluate, StringExtras  EXPORTS CPSymbl =  BEGIN    GetPcCycleAndTask: PUBLIC PROCEDURE [s: LONG STRING]    RETURNS [pc: CPDefs.RealCS, cycle: CPDefs.Cycle, task: CPDefs.Task] =    BEGIN    symbol: CPSymbl.Symbol ¬ Eval[s];    WITH symbol SELECT FROM      number =>        BEGIN	virt: CPSymbl.VirturalCS;	pc ¬ Inline.LowHalf[n];	[virt, cycle, task] ¬ CPSymbl.RealToVirturalCS[pc];	IF virt = CPSymbl.nullVirturalCS THEN ERROR CPSymbl.Error["Can't find task info"L];	END;      realCS =>        BEGIN	virt: CPSymbl.VirturalCS;	pc ¬ real;	[virt, cycle, task] ¬ CPSymbl.RealToVirturalCS[pc];	IF virt = CPSymbl.nullVirturalCS THEN ERROR CPSymbl.Error["Can't find task info"L];	END;      virtCS =>        BEGIN	[pc, cycle, task] ¬ CPSymbl.VirturalToRealCS[virt];	IF pc = CPSymbl.nullRealCS THEN ERROR CPSymbl.Error["Can't translate to a real CS address"L];	END;      ENDCASE => ERROR CPSymbl.Error["CP ControlStore address required"L];    END;	  GetPc: PUBLIC PROCEDURE [s: LONG STRING] RETURNS [pc: CPDefs.RealCS] =    BEGIN    symbol: CPSymbl.Symbol ¬ Eval[s];    WITH symbol SELECT FROM      number => pc ¬ Inline.LowHalf[n];      realCS => pc ¬ real;      virtCS =>        BEGIN	[pc, , ] ¬ CPSymbl.VirturalToRealCS[virt];	IF pc = CPSymbl.nullRealCS THEN ERROR CPSymbl.Error["Can't translate to a real CS address"L];	END;      ENDCASE => ERROR CPSymbl.Error["CP ControlStore address required"L];    END;	  Eval: PUBLIC PROCEDURE [s: LONG STRING] RETURNS [CPSymbl.Symbol] =    BEGIN    type: Evaluate.Type;    value: Evaluate.Value;    shortValue: ARRAY [0..SIZE[CPMIFormat.MI]) OF CARDINAL;    numberFound: CARDINAL ¬  0;    pointer: LONG POINTER;    t: CPSymbl.Type;    rAndRH: BOOLEAN ¬ FALSE;    ss: String.SubStringDescriptor ¬ [base: s, offset: 0, length: s.length];        Lookup: PROCEDURE [s: LONG STRING] RETURNS [type: Evaluate.Type, value: Evaluate.Value] =      BEGIN      ok: BOOLEAN;      virt: CPSymbl.VirturalCS;      r: CPDefs.RReg;      u: CPDefs.UReg;      symbol: CPSymbl.Symbol;      [ok, virt] ¬ CPSymbl.LookupInCSTable[s];      IF ok THEN RETURN[LOOPHOLE[CPSymbl.Type[virtCS]], LONG[virt]];      [ok, r] ¬ CPSymbl.LookupInRRegTable[s];      IF ok THEN RETURN[LOOPHOLE[CPSymbl.Type[rReg]], LONG[r]];      [ok, r] ¬ CPSymbl.LookupInRHTable[s];      IF ok THEN RETURN[LOOPHOLE[CPSymbl.Type[rH]], LONG[r]];      [ok, u] ¬ CPSymbl.LookupInURegTable[s];      IF ok THEN RETURN[LOOPHOLE[CPSymbl.Type[uReg]], LONG[u]];      [ok, symbol] ¬ StringAsSpecial[s];      IF ok THEN	BEGIN	type ¬ LOOPHOLE[symbol.type];	WITH symbol SELECT FROM	  number => value ¬ n;	  tpc => value ¬ task;	  link => value ¬ link;	  mi =>	    BEGIN	    shortValue ¬ LOOPHOLE[mi];	    value ¬ shortValue[0];	    END;	  realCS => value ¬ real;	  virtCS => value ¬ virt;	  rReg, rH => value ¬ r;	  uReg => value ¬ u;	  ioIn, ioOut => value ¬ io;	  map => value ¬ map;	  real => value ¬ LOOPHOLE[real];	  virt => value ¬ LOOPHOLE[virt];	  other => value ¬ LONG[LOOPHOLE[other]];	  pc => value ¬ 0;	  ENDCASE => ERROR;	RETURN;	END;      [ok, value] ¬ StringExtras.StringToLongCardinal[s];      IF ok THEN         BEGIN	shortValue[numberFound] ¬ Inline.LowHalf[value];        numberFound ¬ numberFound + 1;        RETURN[Evaluate.unspecified, value];	END;      BEGIN      temp: LONG STRING = [100];      String.AppendString[temp, "Undefined Symbol: "L];      String.AppendString[temp, s];      ERROR CPSymbl.Error[temp];      END;      END;    TrimSubString[@ss];    SELECT TRUE FROM      ss.base[ss.offset] = '$ =>        BEGIN        ss ¬ [base: ss.base, offset: ss.offset + 1, length: ss.length - 1];	rAndRH ¬ TRUE;        END;      ENDCASE => NULL;    [type, value] ¬ Evaluate.EvaluateSubString[@ss, Lookup !        Evaluate.Error => ERROR CPSymbl.Error[reason] ];    pointer ¬ LOOPHOLE[value];    t ¬ IF type = Evaluate.unspecified THEN number ELSE LOOPHOLE[type];    IF rAndRH THEN      BEGIN      IF t = rReg OR t = rH THEN t ¬ rAndRh      ELSE InconsistentExpression[];      END;    IF numberFound # 3 OR t # number      THEN shortValue[0] ¬ Inline.LowHalf[value]      ELSE t ¬ mi;    SELECT t FROM      number => RETURN[[number[value]]];      tpc =>        BEGIN	IF value ~IN CPDefs.Task THEN AddressOutOfRange[];        RETURN[[tpc[shortValue[0]]]];	END;      link =>        BEGIN	IF value ~IN CPDefs.Link THEN AddressOutOfRange[];        RETURN[[link[shortValue[0]]]];	END;      mi => RETURN[[mi[LOOPHOLE[shortValue]]]];      realCS => RETURN[[realCS[shortValue[0]]]];      virtCS => RETURN[[virtCS[shortValue[0]]]];      rReg =>        BEGIN	IF value ~IN CPDefs.RReg THEN AddressOutOfRange[];	RETURN[[rReg[shortValue[0]]]];	END;      rH =>        BEGIN	IF value ~IN CPDefs.RReg THEN AddressOutOfRange[];	RETURN[[rH[shortValue[0]]]];	END;      rAndRh =>        BEGIN	IF value ~IN CPDefs.RReg THEN AddressOutOfRange[];	RETURN[[rAndRh[shortValue[0]]]];	END;      uReg =>        BEGIN	IF value ~IN CPDefs.UReg THEN AddressOutOfRange[];	RETURN[[uReg[shortValue[0]]]];	END;      ioIn => RETURN[[ioIn[shortValue[0]]]];      ioOut => RETURN[[ioOut[shortValue[0]]]];      map =>        BEGIN	IF value ~IN CPDefs.Map THEN AddressOutOfRange[];	RETURN[[map[shortValue[0]]]];	END;      real => RETURN[[real[pointer]]];      virt => RETURN[[virt[pointer]]];      other => RETURN[[other[LOOPHOLE[shortValue[0]]]]];      pc => RETURN[[pc[]]];      ENDCASE => ERROR;    END;          StringAsSpecial: PROCEDURE [s: LONG STRING] RETURNS [BOOLEAN, CPSymbl.Symbol] =    BEGIN    SELECT TRUE FROM      String.Equivalent[s, ".CR"L] => RETURN[TRUE, [realCS[0]]];      String.Equivalent[s, ".CV"L] => RETURN[TRUE, [virtCS[0]]];      String.Equivalent[s, ".RH"L] => RETURN[TRUE, [rH[0]]];      String.Equivalent[s, ".R"L] => RETURN[TRUE, [rReg[0]]];      String.Equivalent[s, ".U"L] => RETURN[TRUE, [uReg[0]]];      String.Equivalent[s, ".TPC"L] => RETURN[TRUE, [tpc[0]]];      String.Equivalent[s, ".LINK"L] => RETURN[TRUE, [link[0]]];      String.Equivalent[s, ".MAP"L] => RETURN[TRUE, [map[0]]];      String.Equivalent[s, ".MR"L] => RETURN[TRUE, [real[NIL]]];      String.Equivalent[s, ".MV"L] => RETURN[TRUE, [virt[NIL]]];      String.Equivalent[s, ".IOIN"L] => RETURN[TRUE, [ioIn[0]]];      String.Equivalent[s, ".IOXIN"L] => RETURN[TRUE, [ioIn[0]]];      String.Equivalent[s, ".IOOUT"L] => RETURN[TRUE, [ioOut[0]]];      String.Equivalent[s, "Q"L] => RETURN[TRUE, [other[q]]];      String.Equivalent[s, ".Q"L] => RETURN[TRUE, [other[q]]];      String.Equivalent[s, ".IB"L] => RETURN[TRUE, [other[ib]]];      String.Equivalent[s, ".PC16"L] => RETURN[TRUE, [other[pc16]]];      String.Equivalent[s, ".STACKP"L] => RETURN[TRUE, [other[stackP]]];      String.Equivalent[s, ".IBPTR"L] => RETURN[TRUE, [other[ibPtr]]];      String.Equivalent[s, ".MINT"L] => RETURN[TRUE, [other[mInt]]];      String.Equivalent[s, ".EKERR"L] => RETURN[TRUE, [other[ekErr]]];      String.Equivalent[s, "L0"L] => RETURN[TRUE, [link[0]]];      String.Equivalent[s, "L1"L] => RETURN[TRUE, [link[1]]];      String.Equivalent[s, "L2"L] => RETURN[TRUE, [link[2]]];      String.Equivalent[s, "L3"L] => RETURN[TRUE, [link[3]]];      String.Equivalent[s, "L4"L] => RETURN[TRUE, [link[4]]];      String.Equivalent[s, "L5"L] => RETURN[TRUE, [link[5]]];      String.Equivalent[s, "L6"L] => RETURN[TRUE, [link[6]]];      String.Equivalent[s, "L7"L] => RETURN[TRUE, [link[7]]];      String.Equivalent[s, ".PC"L] => RETURN[TRUE, [pc[]]];      ENDCASE => RETURN[FALSE, ];    END;        InconsistentExpression: PROCEDURE =    BEGIN    foo: BOOLEAN ¬ TRUE;    IF foo THEN ERROR CPSymbl.Error["Inconsistent expression"L];    END;      AddressOutOfRange: PROCEDURE =    BEGIN    foo: BOOLEAN ¬ TRUE;    IF foo THEN ERROR CPSymbl.Error["Address out of range"L];    END;      TrimSubString: PROCEDURE [ss: String.SubString] =    BEGIN    FOR i: CARDINAL IN [ss.offset..ss.offset + ss.length) DO      IF ~BlankCharacter[ss.base[i]] THEN        BEGIN  --  remove leading blanks        ss.length ¬ ss.length - (i - ss.offset);        ss.offset ¬ i;	EXIT;	END;      REPEAT FINISHED =>        BEGIN  --all blanks	ss.length ¬ 0;        RETURN;	END;      ENDLOOP;    FOR i: CARDINAL DECREASING IN [ss.offset..ss.offset + ss.length) DO      IF ~BlankCharacter[ss.base[i]] THEN        BEGIN  --  remove trailing blanks        ss.length ¬ ss.length - (ss.offset + ss.length - 1 - i);	EXIT;	END;      ENDLOOP;    END;      BlankCharacter: PROCEDURE [c: CHARACTER] RETURNS [BOOLEAN] =    BEGIN    SELECT c FROM      Ascii.FF, Ascii.SP, Ascii.CR, Ascii.LF, Ascii.TAB => RETURN[TRUE];      ENDCASE => RETURN[FALSE];    END;    END.-- Log of last edits-- JAC	30-May-85 16:42:36	CP renamed to CPDefs-- JAC	31-May-85  9:46:06	CPSymbols renamed to CPSymbl; CPMI renamed to CPMIFormat
-- Copyright (C) 1983, 1985  by Xerox Corporation. All rights reserved. -- CPKernelBreakImpl.mesa-- from CPKernelBreaker.mesa, HGM,  7-Mar-83 17:14:50-- Last edit by RDH   12-Mar-86 17:33:50  DIRECTORY  Format USING [Line, StringProc, Text],  Inline USING [BITAND, BITSHIFT],  CPDefs USING [Bank, BankAndWordsPerBank, BankChanges, BanksImplemented, Cycle, RealCS, Task, wordsPerBank],  CPKernelDefs USING [Byte, Error, Nibble, ReadRealMemoryInternal, WriteCS, WriteRealMemoryInternal--, WriteTpcInternal--],  CPKernelConst ,  CPKernelOp USING [GetStateInternal],  CPMIFormat USING [MI];CPKernelBreakImpl: MONITOR   IMPORTS Format, Inline, CPKernelConst, CPKernelDefs, CPKernelOp  EXPORTS CPKernelDefs, CPKernelOp =  BEGIN OPEN CPKernelConst;    Nibble: TYPE = CPKernelDefs.Nibble;  Byte: TYPE = CPKernelDefs.Byte;    BreakIDReal: TYPE = MACHINE DEPENDENT RECORD[	--Structure of the break ID from the mailbox.    SELECT OVERLAID * FROM    breakID => [      pad: [0..0FH],      bank: [0..3],      cycle: [0..3],      breakID: [0..0FFH]],    word => [word: WORD],    ENDCASE];  currentBreakID: CARDINAL;  AtBreak: PUBLIC ENTRY PROCEDURE RETURNS [BOOLEAN] =    BEGIN RETURN[CPKernelOp.GetStateInternal[] = cpBreak]; END;    SaveCurrentBreakID: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE UNWIND => NULL;    currentBreakID ¬ Inline.BITAND[CPKernelDefs.ReadRealMemoryInternal[mailbox+2], 0FFH];    END;    GetBreakID: PUBLIC ENTRY PROCEDURE RETURNS [CARDINAL] =    BEGIN RETURN[currentBreakID]; END;      SetBreak: PUBLIC ENTRY PROCEDURE [pc: CPDefs.RealCS, cycle: CPDefs.Cycle, id: Byte] =    BEGIN ENABLE UNWIND => NULL;    idH: Nibble ¬ Inline.BITAND[Inline.BITSHIFT[id, -4], 17B];    idL: Nibble ¬ Inline.BITAND[id, 17B];    IF pc ~IN CPDefs.RealCS THEN ERROR;    CPKernelDefs.WriteCS[pc, CPMIFormat.MI[ , rHrK, , , , , , , , byte, nibble, loadRH, [d[idH]], [d[idL]], kEntry]];    END;  PrepareToContinueAfterBreak: PUBLIC ENTRY PROCEDURE [log: Format.StringProc, arg: LONG POINTER, mi: CPMIFormat.MI, cycle: CPDefs.Cycle, task: CPDefs.Task, bank: CPDefs.Bank] =    BEGIN ENABLE UNWIND => NULL;    breakID: BreakIDReal;    bankOffset: CARDINAL ¬ 0;    realCycle: CPDefs.Cycle;    breakID.word ¬ CPKernelDefs.ReadRealMemoryInternal[mailbox+2];    SELECT breakID.cycle FROM      1 => realCycle ¬ c2;      2 => realCycle ¬ c3;      3 => realCycle ¬ c1;      ENDCASE => ERROR CPKernelDefs.Error["Cycle from kernel confused"L];    IF realCycle # cycle AND cycle # any THEN {      Format.Text[log, "Cycle confusion.  Continuing in cycle "L, arg];      FormatCycle[log, arg, realCycle];      Format.Text[log, " not "L, arg];      FormatCycle[log, arg, cycle];      Format.Line[log, "."L, arg]};          IF breakID.bank # bank THEN ERROR       CPKernelDefs.Error["Bank from kernel confused"L];    IF bank ~IN CPDefs.BanksImplemented THEN ERROR      CPKernelDefs.Error["Bank confusion. No such bank"L];    IF breakID.bank = kernelMainBank THEN BEGIN      SELECT realCycle FROM	c1 => 	  BEGIN	  -- kBuffer:   Noop, c1;	  -- kBuffer+1: Noop, c2;	  -- KBuffer+3: Xbus ¬ uSaveDisp, XDisp, c3;	  -- kBuffer+2: <copy of original c1 inst>, c1;	  CPKernelDefs.WriteCS[	    kBuffer, CPMIFormat.MI[	    , , , , , , , , , , , , , , kBuffer + 1]];	  CPKernelDefs.WriteCS[	    kBuffer + 1, CPMIFormat.MI[	    , , , , , , , , , , , , , , kBuffer + 2]];	  CPKernelDefs.WriteCS[kBuffer + 2, CPMIFormat.MI[	    uKSaveDispH, , , , , , , TRUE, , dispBr, uAddr, , [b[xDisp]], [d[uKSaveDispL]], kBuffer + 3]];	  CPKernelDefs.WriteCS[kBuffer + 3, mi];	  END;	c2 =>	  --kBuffer:   Xbus ¬ UKSaveDisp, XDisp, c1;	  --kBuffer+1: <copy of original c2 inst>, c2;	  BEGIN	  CPKernelDefs.WriteCS[	    kBuffer , CPMIFormat.MI[	    uKSaveDispH, , , , , , , TRUE, , dispBr, uAddr, , [b[xDisp]], [d[uKSaveDispL]], kBuffer + 1]];	  CPKernelDefs.WriteCS[kBuffer + 1, mi];	  END;	c3 =>	  -- kBuffer:   Noop, c1;	  -- kBuffer+1: Xbus ¬ UKSaveDisp, XDisp, c2;	  -- kBuffer+2: <copy of original c3 inst>, c3;	  BEGIN  --write register before microinstruction	  CPKernelDefs.WriteCS[	    kBuffer, CPMIFormat.MI[	    , , , , , , , , , , , , , , kBuffer + 1]];	  CPKernelDefs.WriteCS[	    kBuffer + 1, CPMIFormat.MI[	    uKSaveDispH, , , , , , , TRUE, , dispBr, uAddr, , [b[xDisp]], [d[uKSaveDispL]], kBuffer + 2]];	  CPKernelDefs.WriteCS[kBuffer + 2, mi];	  END;	ENDCASE => ERROR;      END ELSE BEGIN  --If continuing into another bank--      -- Get into other bank's little kernel.      PrepareToChangeBanks[bank];      --Now put code in other bank's kernel.      bankOffset ¬ breakID.bank * CPDefs.wordsPerBank;      SELECT realCycle FROM	c1 =>	  BEGIN	  -- AltKernelBuffer:	Xbus ¬ uSaveDisp, XDisp, 	c3;	  -- AltKernelBuffer1:	<copy of original c1 inst>, 	c1;	  	  CPKernelDefs.WriteCS[bankOffset+AltKernelBuffer, CPMIFormat.MI[	    uKSaveDispH, , , , , , , TRUE, , dispBr, uAddr, , [b[xDisp]], [d[uKSaveDispL]], AltKernelBuffer1]];	  CPKernelDefs.WriteCS[bankOffset+AltKernelBuffer1, mi];	  END;	c2 =>	  BEGIN	  -- AltKernelBuffer:	Noop, 				c3;	  -- AltKernelBuffer1:	Xbus ¬ uSaveDisp, XDisp, 	c1; 	  -- AltKernelBuffer2:	<copy of original c2 inst>, 	c2;	  	  CPKernelDefs.WriteCS[bankOffset+AltKernelBuffer, CPMIFormat.MI[inia: AltKernelBuffer1]];	  CPKernelDefs.WriteCS[bankOffset+AltKernelBuffer1, CPMIFormat.MI[	    uKSaveDispH, , , , , , , TRUE, , dispBr, uAddr, , [b[xDisp]], [d[uKSaveDispL]], AltKernelBuffer2]];	  CPKernelDefs.WriteCS[bankOffset+AltKernelBuffer2, mi];	  END;	c3 =>	  BEGIN	  -- AltKernelBuffer:	Noop, 				c3;	  -- AltKernelBuffer1:	Noop, 				c1;	  -- AltKernelBuffer2:	Xbus ¬ uSaveDisp, XDisp, 	c2; 	  -- AltKernelBuffer3:	<copy of original c3 inst>, 	c3;	  	  CPKernelDefs.WriteCS[bankOffset+AltKernelBuffer, CPMIFormat.MI[inia: AltKernelBuffer1]];	  CPKernelDefs.WriteCS[bankOffset+AltKernelBuffer1, CPMIFormat.MI[inia: AltKernelBuffer2]];	  CPKernelDefs.WriteCS[bankOffset+AltKernelBuffer2, CPMIFormat.MI[	    uKSaveDispH, , , , , , , TRUE, , dispBr, uAddr, , [b[xDisp]], [d[uKSaveDispL]], AltKernelBuffer3]];	  CPKernelDefs.WriteCS[bankOffset+AltKernelBuffer3, mi];	  END;	ENDCASE => ERROR;      END; --IF breakID.bank = kernelMainBank THEN blah ELSE blah, blah    --CPKernelDefs.WriteTpcInternal[task, kBuffer + 4];    CPKernelDefs.WriteRealMemoryInternal[mailbox+1, bufferCommand];    END; --PrepareToContinueAfterBreak--      PrepareToStart: PUBLIC ENTRY PROCEDURE [pc: CPDefs.RealCS] =    BEGIN ENABLE UNWIND => NULL;    bankOffset: CARDINAL ¬ 0;    temp: CPDefs.BankAndWordsPerBank = LOOPHOLE[pc];    IF temp.bank = kernelMainBank THEN BEGIN      -- kBuffer:   Noop, c1;      -- kBuffer+1: Noop, c2;      -- KBuffer+2: Noop, GOTO[pc], c3;      CPKernelDefs.WriteCS[	kBuffer, CPMIFormat.MI[	, , , , , , , , , , , , , , kBuffer + 1]];      CPKernelDefs.WriteCS[	kBuffer + 1, CPMIFormat.MI[	, , , , , , , , , , , , , , kBuffer + 2]];      CPKernelDefs.WriteCS[	kBuffer + 2, CPMIFormat.MI[	, , , , , , , , , , , , , , pc]];      END ELSE BEGIN      -- Get into other bank's little kernel.      PrepareToChangeBanks[temp.bank];      bankOffset ¬ temp.bank * CPDefs.wordsPerBank;      CPKernelDefs.WriteCS[bankOffset+AltKernelBuffer, CPMIFormat.MI[inia: pc]];      END;--IF temp.bank = kernelMainBank THEN blah ELSE blah, blah--    CPKernelDefs.WriteRealMemoryInternal[mailbox+1, bufferCommand];    END;--PrepareToStart--      PrepareToContinueAfterStop: PUBLIC ENTRY PROCEDURE [log: Format.StringProc, arg: LONG POINTER, bank: CPDefs.Bank, pc: CPDefs.RealCS] =    BEGIN ENABLE UNWIND => NULL;    bankOffset: CARDINAL ¬ 0;    breakID: BreakIDReal;    realCycle: CPDefs.Cycle;    breakID.word ¬ CPKernelDefs.ReadRealMemoryInternal[mailbox+2];    SELECT breakID.cycle FROM      1 => realCycle ¬ c2;      2 => realCycle ¬ c3;      3 => realCycle ¬ c1;      ENDCASE => ERROR CPKernelDefs.Error["Cycle from kernel confused"L];    IF breakID.bank # bank THEN ERROR CPKernelDefs.Error["Bank number from kernel confused."L];    IF breakID.bank = kernelMainBank THEN BEGIN      SELECT realCycle FROM	c1 =>	  -- kBuffer:   Noop, c1;	  -- kBuffer+1: Noop, c2;	  -- kBuffer+2: Noop, GOTO[pc], c3;	  BEGIN  --write register before microinstruction	  CPKernelDefs.WriteCS[kBuffer, CPMIFormat.MI[	    , , , , , , , , , , , , , , kBuffer + 1]];	  CPKernelDefs.WriteCS[kBuffer + 1, CPMIFormat.MI[	    , , , , , , , , , , , , , , kBuffer + 2]];	  CPKernelDefs.WriteCS[kBuffer + 2, CPMIFormat.MI[	    , , , , , , , , , , , , , , pc]];		  END;  	c2 =>	  BEGIN	  -- kBuffer:   Noop, GOTO[pc], c1;	  CPKernelDefs.WriteCS[	    kBuffer, CPMIFormat.MI[	    , , , , , , , , , , , , , , pc]];	  END;	c3 =>	  --kBuffer:   Noop, c1;	  --kBuffer+1: Noop, GOTO[pc], c2;	  BEGIN	  CPKernelDefs.WriteCS[kBuffer, CPMIFormat.MI[	    , , , , , , , , , , , , , , kBuffer + 1]];	  CPKernelDefs.WriteCS[kBuffer + 1, CPMIFormat.MI[	    , , , , , , , , , , , , , , pc]];	  END;	ENDCASE => ERROR;      END ELSE BEGIN   --If continuing into another bank--      -- Get into other bank's little kernel.      PrepareToChangeBanks[bank];      --Now put code in other bank's kernel.      bankOffset ¬ breakID.bank * CPDefs.wordsPerBank;      SELECT realCycle FROM	c1 =>	  BEGIN	  -- AltKernelBuffer:	Noop, GOTO[pc], 		c3;	  CPKernelDefs.WriteCS[bankOffset+AltKernelBuffer, CPMIFormat.MI[inia: pc]];	  END;	c2 =>	  BEGIN	  -- AltKernelBuffer:	Noop, 				c3; 	  -- AltKernelBuffer1:	Noop, GOTO[pc], 		c1;	  CPKernelDefs.WriteCS[bankOffset+AltKernelBuffer, CPMIFormat.MI[inia: AltKernelBuffer1]];	  CPKernelDefs.WriteCS[bankOffset+AltKernelBuffer1, CPMIFormat.MI[inia: pc]];	  END;	c3 =>	  BEGIN	  -- AltKernelBuffer:	Noop, 				c3;	  -- AltKernelBuffer1:	Noop, 				c1; 	  -- AltKernelBuffer2:	Noop, GOTO[pc], 		c2;	  CPKernelDefs.WriteCS[bankOffset+AltKernelBuffer, CPMIFormat.MI[inia: AltKernelBuffer1]];	  CPKernelDefs.WriteCS[bankOffset+AltKernelBuffer1, CPMIFormat.MI[inia: AltKernelBuffer2]];	  CPKernelDefs.WriteCS[bankOffset+AltKernelBuffer2, CPMIFormat.MI[inia: pc]];	  END;	ENDCASE => ERROR;      END; --IF breakID.bank = kernelMainBank THEN blah ELSE blah, blah--    CPKernelDefs.WriteRealMemoryInternal[mailbox+1, bufferCommand];    END; --PrepareToContinueAfterStop--      PrepareToChangeBanks: PROCEDURE[newBank: CPDefs.Bank] = BEGIN    -- Get into other bank's little kernel.    -- kBuffer:   	Bank ¬ bankno, 				c1;    -- kBuffer+1: 	GOTOABS[AltKernelBuffer], 		c2;    -- AltKernelBuffer:    --	(first instruction executed in other bank), 		c3;    CPKernelDefs.WriteCS[kBuffer, CPMIFormat.MI[aS: dz, fS23: nibble,       fY: [n[bank]], fZ: [d [CPDefs.BankChanges[newBank]]], inia: kBuffer + 1]];     CPKernelDefs.WriteCS[kBuffer + 1, CPMIFormat.MI[inia: AltKernelBuffer]];    END;--PrepareToChangeBanks--          FormatCycle: PROCEDURE[Log: Format.StringProc, arg: LONG POINTER, cycle: CPDefs.Cycle] =    BEGIN    SELECT cycle FROM      c1 => Format.Text[Log, "c1"L, arg];      c2 => Format.Text[Log, "c2"L, arg];      c3 => Format.Text[Log, "c3"L, arg];      ENDCASE => ERROR;      END;  	  END.-- Log of last edits-- JAC	30-May-85 16:42:36	CP renamed to CPDefs; CPKernel renamed to CPKernelDefs-- JAC	31-May-85  9:46:06	CPKernelConstants renamed to CPKernelConst; CPMI renamed to CPMIFormat; CPKernelOps renamed to CPKernelOp-- JAC	24-Jun-85  9:56:04	changed PrepareToContinueAfterStop since pc now has dispatch bits or'd in-- JAC	 9-Oct-85 14:24:14	import CPKernelConst for change in mailbox-- RDH	 3-Feb-86 17:40:48	Modify PrepareTo* for 8K control store.-- RDH	10-Mar-86 16:31:29	Fix up Bank¬ in PrepareToSwitchBanks.-- RDH	12-Mar-86 17:34:02	Fix cycles in continuing from stop in 2nd bank.
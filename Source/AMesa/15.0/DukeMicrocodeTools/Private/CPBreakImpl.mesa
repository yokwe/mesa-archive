-- Copyright (C) 1983, 1985  by Xerox Corporation. All rights reserved. -- Last edit by JAC    		 8-Jul-85 13:37:34-- from CPBreaker.mesa, HGM,  7-Nov-83 17:12:44DIRECTORY  Heap USING [systemZone],  Inline USING [BITAND],  String USING [AppendNumber, AppendString],    CPDefs USING [Cycle, RealCS, Task],  CPMIFormat USING [MI],  CPBreakDefs USING [],  CPKernelDefs USING [    AtBreak, ContinueCP, Error, GetBreakID, InKernel, maxBreaks, ReadControlStore, ReadCS, SetBreak, StopCP, WriteCS, WriteTpc];CPBreakImpl: MONITOR  IMPORTS Heap, Inline, String, CPKernelDefs  EXPORTS CPBreakDefs =  BEGIN    z: UNCOUNTED ZONE = Heap.systemZone;    head: Breakpoint ¬ NIL;  breaksInstalled: BOOLEAN ¬ FALSE;    lastBreakInfo: RECORD [location: CPDefs.RealCS, cycle: CPDefs.Cycle, task: CPDefs.Task, mi: CPMIFormat.MI];    Error: PUBLIC ERROR [reason: LONG STRING] = CODE;    Breakpoint: TYPE = LONG POINTER TO  BreakpointInfo;  BreakpointInfo: TYPE = RECORD [    location: CPDefs.RealCS,    mi: CPMIFormat.MI,    cycle: CPDefs.Cycle,    task: CPDefs.Task,    next: Breakpoint];    Break: PUBLIC ENTRY PROCEDURE [location: CPDefs.RealCS, cycle: CPDefs.Cycle, task: CPDefs.Task] =    BEGIN ENABLE      BEGIN      CPKernelDefs.Error => ERROR Error[reason];      UNWIND => NULL;      END;    new: Breakpoint;    id: CARDINAL ¬ 1;  -- The one we want to add    RemoveBreaksInternal[];    FOR finger: Breakpoint ¬ head, finger.next UNTIL finger = NIL DO      IF finger.location = location THEN ERROR Error["Breakpoint already set there"L];      id ¬ id + 1;      ENDLOOP;    IF id >= CPKernelDefs.maxBreaks THEN ERROR Error["Too many breakpoints"L];    new ¬ z.NEW[BreakpointInfo];    new­ ¬ [location, CPKernelDefs.ReadControlStore[location], cycle, task, head];    head ¬ new;    END;	    Unbreak: PUBLIC ENTRY PROCEDURE [location: CPDefs.RealCS, cycle: CPDefs.Cycle, task: CPDefs.Task] =    BEGIN ENABLE      BEGIN      CPKernelDefs.Error => ERROR Error[reason];      UNWIND => NULL;      END;    previous: Breakpoint ¬ NIL;    RemoveBreaksInternal[];    FOR finger: Breakpoint ¬ head, finger.next UNTIL finger = NIL DO      IF finger.location = location THEN        BEGIN	temp: Breakpoint ¬ finger;  -- Rats, can't smash LOOP control variable	IF cycle # finger.cycle OR task # finger.task THEN	  ERROR Error["Cycle/Task confusion"L];	IF previous = NIL THEN head ¬ finger.next	ELSE previous.next ¬ finger.next;	z.FREE[@temp];	RETURN;	END;      previous ¬ finger;      ENDLOOP;    ERROR Error["Breakpoint not found"L];    END;    Reset: PUBLIC ENTRY PROCEDURE =    BEGIN    Smash[];    END;    ClearAllBreaks: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE UNWIND => NULL;    RemoveBreaksInternal[];    Smash[];    END;  Smash: INTERNAL PROCEDURE =    BEGIN    breaksInstalled ¬ FALSE;    UNTIL head = NIL DO      temp: Breakpoint ¬ head;      head ¬ head.next;      z.FREE[@temp];      ENDLOOP;    END;  EnumerateBreaks: PUBLIC ENTRY PROCEDURE [proc: PROCEDURE[CPDefs.RealCS, CPDefs.Cycle, CPDefs.Task]] =    BEGIN ENABLE UNWIND => NULL;    FOR finger: Breakpoint ¬ head, finger.next UNTIL finger = NIL DO      proc[finger.location, finger.cycle, finger.task];      ENDLOOP;    END;      FindBreak: PUBLIC ENTRY PROCEDURE [break: CARDINAL]     RETURNS [pc: CPDefs.RealCS] =    BEGIN    currentBreak: CARDINAL ¬ 1;    FOR finger: Breakpoint ¬ head, finger.next UNTIL finger = NIL DO      IF currentBreak = break THEN RETURN[finger.location];      currentBreak ¬ currentBreak + 1;      ENDLOOP;    END;    InstallBreaks: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE      BEGIN      CPKernelDefs.Error => ERROR Error[reason];      UNWIND => NULL;      END;    id: CARDINAL ¬ 0;    BeSureInKernel[];    IF breaksInstalled THEN {CPKernelDefs.ContinueCP[]; RETURN};    breaksInstalled ¬ TRUE;    FOR finger: Breakpoint ¬ head, finger.next UNTIL finger = NIL DO      finger.mi ¬ CPKernelDefs.ReadCS[finger.location];      CPKernelDefs.SetBreak[finger.location, finger.cycle, id];      id ¬ id + 1;      ENDLOOP;    CPKernelDefs.ContinueCP[];    IF id >= CPKernelDefs.maxBreaks THEN ERROR;    END;    BreakStillSet: PUBLIC ENTRY PROCEDURE [    location: CPDefs.RealCS, cycle: CPDefs.Cycle, task: CPDefs.Task, mi: CPMIFormat.MI] RETURNS [BOOLEAN] =    BEGIN ENABLE      BEGIN      CPKernelDefs.Error => ERROR Error[reason];      UNWIND => NULL;      END;    IF ~CPKernelDefs.InKernel[] THEN ERROR Error["Can't adjust breaks while running (or crashed)"L];    FOR finger: Breakpoint ¬ head, finger.next UNTIL finger = NIL DO      IF finger.location # location THEN LOOP;      IF finger.cycle # cycle OR finger.task # task THEN ERROR;      RETURN[TRUE];      ENDLOOP;    RETURN[FALSE];    END;    RemoveBreaks: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE UNWIND => NULL;    RemoveBreaksInternal[];    END;    RemoveBreaksInternal: INTERNAL PROCEDURE =  -- this procedure assumes that the debuggee is in the kernel     BEGIN ENABLE CPKernelDefs.Error => ERROR Error[reason];    id: CARDINAL ¬ 0;    currentBreakID: CARDINAL ¬ nullBreakID;    nullBreakID: CARDINAL = LAST[CARDINAL];    BeSureInKernel[];    IF ~breaksInstalled THEN {CPKernelDefs.ContinueCP[]; RETURN};    breaksInstalled ¬ FALSE;    IF CPKernelDefs.AtBreak[] THEN currentBreakID ¬ Inline.BITAND[CPKernelDefs.GetBreakID[], 0FFH];    FOR finger: Breakpoint ¬ head, finger.next UNTIL finger = NIL DO      IF id = currentBreakID THEN        BEGIN  -- In case it gets deleted	lastBreakInfo ¬ [finger.location, finger.cycle, finger.task, finger.mi];	currentBreakID ¬ nullBreakID;	CPKernelDefs.WriteTpc[finger.task, finger.location];	END;      CPKernelDefs.WriteCS[finger.location, finger.mi];      id ¬ id + 1;      ENDLOOP;    IF currentBreakID # nullBreakID THEN      BEGIN      text: STRING = [200];      String.AppendString[text, "Breakpoint confusion -- break probably hit on wrong cycle. ID = "L];      String.AppendNumber[text, currentBreakID, 16];      CPKernelDefs.ContinueCP[];      ERROR Error[text];      END;    CPKernelDefs.ContinueCP[];    END;    GetLastBreakInfo: PUBLIC PROCEDURE RETURNS [CPDefs.RealCS, CPDefs.Cycle, CPDefs.Task, CPMIFormat.MI] =    BEGIN    RemoveBreaks[];    RETURN[lastBreakInfo.location, lastBreakInfo.cycle, lastBreakInfo.task, lastBreakInfo.mi];    END;    BeSureInKernel: INTERNAL PROCEDURE =    BEGIN    IF ~CPKernelDefs.InKernel[] THEN ERROR Error["Can't adjust breaks while running (or crashed)"L];    CPKernelDefs.StopCP[];    END;    END.-- Log of last edits-- JAC	30-May-85 16:42:36	CP renamed to CPDefs; CPBreak renamed to CPBreakDefs-- JAC	31-May-85  9:46:06	CPKernel renamed to CPKernelDefs; CPMI renamed to CPMIFormat-- JAC	 1-Jul-85 13:36:24	ContinueCP in RemoveBreaksInternel if breaks not installed-- JAC	 8-Jul-85 13:37:23	add FindBreak
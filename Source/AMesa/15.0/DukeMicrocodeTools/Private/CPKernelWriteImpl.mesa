-- Copyright (C) 1983, 1985  by Xerox Corporation. All rights reserved. -- Last edit by JAC, 	 9-Oct-85 14:25:56 -- from CPKernelCommon.mesa, HGM, 27-Oct-83  2:25:02DIRECTORY  Environment USING [LongNumber],  Heap USING [systemZone],  Inline USING [BITAND, BITSHIFT, HighHalf, LowHalf],  CPDefs USING [    IOReg, Link, Map, MapEntry,  mapOffset, OtherReg, RealMemory, RReg, UReg, VirturalMemory],  CPKernelDefs USING [ContinueCP, DebuggeeReady, ReadRealMemory, WriteCS, WriteRealMemory],  CPKernelConst,  CPKernelOp USING [AddressOutOfRange],  CPMIFormat USING [FX, FYNorm, FZNorm, MI];CPKernelWriteImpl: MONITOR   IMPORTS    Heap, Inline, CPKernelConst, CPKernelDefs, CPKernelOp  EXPORTS CPKernelDefs, CPKernelOp =  BEGIN OPEN CPKernelConst;    z: UNCOUNTED ZONE = Heap.systemZone;  MaxBindweedSpace: LONG CARDINAL = 0FF000H;    Nibble: TYPE = CARDINAL [0..16);    Error: PUBLIC ERROR [reason: LONG STRING] = CODE;    WriteRReg: PUBLIC ENTRY PROCEDURE [r: CPDefs.RReg, data: WORD] =    BEGIN ENABLE UNWIND => NULL;    WriteRRegInternal[r, data];    END;    WriteRRegInternal: INTERNAL PROCEDURE [r: CPDefs.RReg, data: WORD] =    BEGIN ENABLE UNWIND => NULL;    -- kWrite: R<addr> ¬ MD, GOTO[SignalZero], c3;    IF r ~IN CPDefs.RReg THEN AddressOutOfRange[];    IF r = rMailBox THEN CantWriteThatRegister[];    CPKernelDefs.DebuggeeReady[];    CPKernelDefs.WriteCS[      kWrite, CPMIFormat.MI[      , r, dz, , wrB, , , , TRUE, , , , , , SignalZero]];    CPKernelDefs.WriteRealMemory[mailbox, data];    CPKernelDefs.WriteRealMemory[mailbox+1, writeRegCommand];    CPKernelDefs.ContinueCP[];    END;   WriteLink: PUBLIC ENTRY PROCEDURE [link: CPDefs.Link, data: Nibble] =    BEGIN ENABLE UNWIND => NULL;    -- kWriteLink: L<addr> ¬ 0, DISP4[WriteLinkTable], c1;    translate: ARRAY CPDefs.Link OF CPMIFormat.FX = [	  pCallRet0, pCallRet1, pCallRet2, pCallRet3,	  pCallRet4, pCallRet5, pCallRet6, pCallRet7];    IF link NOT IN CPDefs.Link THEN AddressOutOfRange[];    IF data NOT IN Nibble THEN DataOutOfRange[];    CPKernelDefs.DebuggeeReady[];    CPKernelDefs.WriteCS[      kWriteLink, CPMIFormat.MI[      , , , , , , , , , , , translate[link], , , WriteLinkTable]];    CPKernelDefs.WriteRealMemory[mailbox, data];    CPKernelDefs.WriteRealMemory[mailbox+1, writeLinkCommand];    CPKernelDefs.ContinueCP[];    END;      WriteRH: PUBLIC ENTRY PROCEDURE [rh: CPDefs.RReg, data: WORD] =    BEGIN ENABLE UNWIND => NULL;    WriteRHInternal[rh, data];    END;    WriteRHInternal: INTERNAL PROCEDURE [rh: CPDefs.RReg, data: WORD] =    BEGIN ENABLE UNWIND => NULL;    --kWrite:	RH<addr>¬ MD, GOTO[SignalZero];    IF rh ~IN CPDefs.RReg THEN AddressOutOfRange[];    IF rh = rHMailBox THEN CantWriteThatRegister[];    IF data ~IN [0..0FFH] THEN DataOutOfRange[];    CPKernelDefs.DebuggeeReady[];        CPKernelDefs.WriteCS[      kWrite, CPMIFormat.MI[      , rh, zb, rAndS, , , , , TRUE, , , loadRH, , , SignalZero]];    CPKernelDefs.WriteRealMemory[mailbox, data];    CPKernelDefs.WriteRealMemory[mailbox+1, writeRegCommand];    CPKernelDefs.ContinueCP[];    END;   WriteUReg: PUBLIC ENTRY PROCEDURE [u: CPDefs.UReg, data: WORD] =    BEGIN ENABLE UNWIND => NULL;    addrH: Nibble ¬ Inline.BITAND[Inline.BITSHIFT[u, -4], 0FH];    addrL: Nibble ¬ Inline.BITAND[u, 0FH];    --kWrite:   rK ¬ MD, c3;    --kWrite+1: U<addr>¬ rK, GOTO[kWait2], c1;    IF u ~IN CPDefs.UReg THEN AddressOutOfRange[];    CPKernelDefs.DebuggeeReady[];    -- rK ¬ MD, c3    CPKernelDefs.WriteCS[kWrite, CPMIFormat.MI[      , rK, dz, rOrS, wrB, , , , TRUE, , , , , , kWrite + 1]];      -- U<addr> ¬ rK, GOTO[kWait2], c1;    CPKernelDefs.WriteCS[kWrite + 1, CPMIFormat.MI[      addrH, rK, zb, rOrS, , , TRUE, TRUE, , , uAddr, , , [d[addrL]], kWait2]];    CPKernelDefs.WriteRealMemory[mailbox, data];    CPKernelDefs.WriteRealMemory[mailbox+1, writeRegCommand];    CPKernelDefs.ContinueCP[];    END;  WriteRAndRH: PUBLIC ENTRY PROCEDURE [r: CPDefs.RReg, data: LONG POINTER] =    BEGIN    WriteRHInternal[r, Inline.HighHalf[data]];    WriteRRegInternal[r, Inline.LowHalf[data]];    END;   WriteMap: PUBLIC ENTRY PROCEDURE [map: CPDefs.Map, data: WORD] =    BEGIN ENABLE UNWIND => NULL;    IF map ~IN CPDefs.Map THEN AddressOutOfRange[];    CPKernelDefs.WriteRealMemory[LOOPHOLE[map + CPDefs.mapOffset], data];    END;       WriteVirturalMemory: PUBLIC PROCEDURE [virt: CPDefs.VirturalMemory, data: WORD] =    BEGIN    CPKernelDefs.WriteRealMemory[MapAddress[virt], data];    END;   MapAddress: ENTRY PROCEDURE [virt: CPDefs.VirturalMemory] RETURNS [CPDefs.RealMemory] =    BEGIN ENABLE UNWIND => NULL;    a: LONG CARDINAL ¬ LOOPHOLE[virt];    page: CARDINAL = Inline.LowHalf[a/256];    offset: CARDINAL = Inline.LowHalf[a MOD 256];    mapEntry: CPDefs.MapEntry;    mapEntry ¬ LOOPHOLE[ReadMapInternal[page]];    IF mapEntry.w AND mapEntry.d THEN      ERROR Error["Map entry is marked invalid"L];    a ¬ mapEntry.rpHigh*10000H + mapEntry.rpLow*256 + offset;    RETURN[LOOPHOLE[a]];    END;      ReadMapInternal: PROCEDURE [map: CPDefs.Map] RETURNS [WORD] =    BEGIN    IF map ~IN CPDefs.Map THEN CPKernelOp.AddressOutOfRange[];    RETURN[CPKernelDefs.ReadRealMemory[LOOPHOLE[map + CPDefs.mapOffset]]];    END;      WriteIOOut: PUBLIC ENTRY PROCEDURE [io: CPDefs.IOReg, data: WORD] =    BEGIN ENABLE UNWIND => NULL;    WriteIOOutInternal[io, data];    END;  WriteIOOutInternal: PUBLIC INTERNAL PROCEDURE [io: CPDefs.IOReg, data: WORD] =    BEGIN    -- kWrite:  IOOut<addr> ¬ MD, GOTO[SignalZero], c3;    IF io ~IN [0..0FH] THEN AddressOutOfRange[];    CPKernelDefs.DebuggeeReady[];    CPKernelDefs.WriteCS[      kWrite, CPMIFormat.MI[      , , dz, , , , , , TRUE, ioOut, , , [d[io]], , SignalZero]];    CPKernelDefs.WriteRealMemory[mailbox, data];    CPKernelDefs.WriteRealMemory[mailbox+1, writeRegCommand];    CPKernelDefs.ContinueCP[];    END;  WriteOther: PUBLIC ENTRY PROCEDURE [other: CPDefs.OtherReg, data: WORD] =    BEGIN ENABLE UNWIND => NULL;    WriteOtherInternal[other, data];    END;   WriteOtherInternal: INTERNAL PROCEDURE [other: CPDefs.OtherReg, data: WORD] =    BEGIN    SELECT other FROM      q =>        --kWrite:  Q ¬ MD, GOTO[SignalZero];        --Write mailbox with data first        BEGIN	CPKernelDefs.DebuggeeReady[];        CPKernelDefs.WriteCS[kWrite, CPMIFormat.MI[          , , dz, , wrQ, , , , TRUE, , , , , , SignalZero]];	CPKernelDefs.WriteRealMemory[mailbox, data];	CPKernelDefs.WriteRealMemory[mailbox+1, writeRegCommand];        END;      ib =>        --kWrite:  IB ¬ MD, GOTO[SignalZero], c1;        --set mailbox to data.        BEGIN        CPKernelDefs.DebuggeeReady[];        CPKernelDefs.WriteCS[          kWrite, CPMIFormat.MI[          , , dz, , , , , , TRUE, , , , [n[loadIB]], , SignalZero]];	CPKernelDefs.WriteRealMemory[mailbox, data];	CPKernelDefs.WriteRealMemory[mailbox+1, writeRegCommand];        END;         pc16 =>        --kBuffer:   rK ¬ <data>+pc16, YDisp, GOTO[kBuffer] c1;        --kBuffer+3: BRANCH[KFlip, KNoFlip, 0E], c2;        --KFlip:    Cin ¬ pc16, GOTO[SignalZero], c3, at[kBuffer+1];        --KNoFlip:  GOTO[SignalZero], c3, at[kBuffer+2];        BEGIN        IF data ~IN [0..1] THEN DataOutOfRange[];	CPKernelDefs.DebuggeeReady[];        CPKernelDefs.WriteCS[          kBuffer, CPMIFormat.MI[          , rK, dz, rPlusS, wrB, , , , , dispBr, nibble, cinPC16, [b[yDisp]], [d[data]], kBuffer + 3]];        CPKernelDefs.WriteCS[          kBuffer + 3, CPMIFormat.MI[          , , , , , , , , , , , , , , kBuffer + 1]];        CPKernelDefs.WriteCS[          kBuffer + 1, CPMIFormat.MI[  --KFlip          , , , , , , , , , , , cinPC16, , , SignalZero]];        CPKernelDefs.WriteCS[          kBuffer + 2, CPMIFormat.MI[  --KNoFlip          , , , , , , , , , , , , , , SignalZero]];	CPKernelDefs.WriteRealMemory[mailbox, data];	CPKernelDefs.WriteRealMemory[mailbox+1, bufferCommand];        END;	       stackP =>        --kWrite:	stackP ¬ MD, GOTO[SignalZero], c1;        BEGIN        IF data ~IN [0..0FH] THEN DataOutOfRange[];	CPKernelDefs.DebuggeeReady[];        CPKernelDefs.WriteCS[          kWrite, CPMIFormat.MI[          , rK, dz, , wrB, , , , TRUE, , , , [n[loadStackP]], , kBuffer]];	CPKernelDefs.WriteCS[          kBuffer, CPMIFormat.MI[          , rK, zb, , , , , , , , , , [n[loadStackP]], , kWait2]];	CPKernelDefs.WriteRealMemory[mailbox, data];	CPKernelDefs.WriteRealMemory[mailbox+1, writeRegCommand];        END;	      ibPtr =>        --kBuffer:	IBPtr ¬ <data>, GOTO[kWait2], c1;        BEGIN	foo: CPMIFormat.FZNorm = IF data = 0 THEN iBPtrTo0 ELSE iBPtrTo1;        IF data ~IN [0..1] THEN DataOutOfRange[];	CPKernelDefs.DebuggeeReady[];        CPKernelDefs.WriteCS[          kBuffer, CPMIFormat.MI[          , , , , , , , , , , , , , [n[foo]], kWait2]];	CPKernelDefs.WriteRealMemory[mailbox+1, bufferCommand];        END;	        mInt =>        --kBuffer:  ClrIntErr, GOTO[kWait2], c1;	{if 0}        --kBuffer:  MesaIntRq, GOTO[kWait2], c1;	{if 1}        BEGIN	foo: CPMIFormat.FYNorm = IF data = 0 THEN clrIntErr ELSE mesaIntRq;        IF data ~IN [0..1] THEN DataOutOfRange[];	CPKernelDefs.DebuggeeReady[];        CPKernelDefs.WriteCS[          kBuffer, CPMIFormat.MI[          , , , , , , , , , , , , [n[foo]], , kWait2]];	CPKernelDefs.WriteRealMemory[mailbox+1, bufferCommand];        END;	        ekErr => CantWriteThatRegister[];	        ENDCASE => CantWriteThatRegister[];    CPKernelDefs.ContinueCP[];    RETURN;    END;        AddressOutOfRange: PUBLIC PROCEDURE =    BEGIN    ERROR Error["Address out of Range"L];    END;  DataOutOfRange: PUBLIC PROCEDURE =    BEGIN    ERROR Error["Data out of Range"L];    END;    CantReadThatRegister: PUBLIC PROCEDURE =    BEGIN    ERROR Error["Can't read that register"L];    END;  CantWriteThatRegister: PUBLIC PROCEDURE =    BEGIN    ERROR Error["Can't write that register"L];    END;        END.-- Log of last edits-- JAC	30-May-85 16:42:36	CP renamed to CPDefs-- JAC	31-May-85  9:46:06	CPKernel renamed to CPKernelDefs; CPKernelConstants renamed to CPKernelConst; CPMI renamed to CPMIFormat; CPKernelOps renamed to CPKernelOp-- JAC	 9-Oct-85 14:26:12	import CPKernelConst for change in mailbox
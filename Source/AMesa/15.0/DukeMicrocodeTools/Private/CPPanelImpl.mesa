-- Copyright (C) 1983, 1985  by Xerox Corporation. All rights reserved. -- Last edit by JAC 		10-Jun-85 14:19:09-- from CPPaneler.mesa, HGM, 21-Nov-83  0:19:16DIRECTORY  Heap USING [systemZone],  Inline USING [HighHalf, LowHalf],  String USING [AppendLongNumber, AppendNumber, AppendString, CopyToNewString],  Tool USING [AddThisSW],  ToolWindow USING [CreateSubwindow, nullBox],  Window USING [Box, Handle],  WindowFont USING [CharWidth, defaultFont, FontHeight, Handle],  CPDefs USING [Cycle, RealCS, RReg, UReg, Task],  CPMIFormat USING [MI],  CPKernelDefs USING [    Error, InKernel, ReadControlStore, ReadIOIn, ReadLink, ReadMap, ReadOther, ReadPC, ReadRealMemory, ReadRAndRH, ReadRH, ReadRReg, ReadTpc, ReadUReg, ReadVirturalMemory, WriteControlStore, WriteIOOut, WriteLink, WriteMap, WriteOther, WritePC, WriteRAndRH, WriteRealMemory, WriteRH,    WriteRReg, WriteTpc, WriteUReg, WriteVirturalMemory],  CPPanel USING [],  CPSymbl USING [    AppendMI, AppendSymbol, AppendVirturalCS, Error, Eval, nullRealCS, nullVirturalCS,    RealToVirturalCS, Symbol, VirturalCS, VirturalToRealCS],  PanelSW USING [    AppendPanelData, Clear, ClientError, ClientProcsObject, Create, Destroy, FreeRSProcType, LHTypeInEvalProcType, ModifyTypeInProcType, Handle, ReadTargetProcType, RegisterSpec, RHTypeInEvalProcType, SWType, TileLayout, Update];CPPanelImpl: PROGRAM  IMPORTS    Heap, Inline, String,    Tool, ToolWindow, WindowFont,    CPKernelDefs, CPSymbl, PanelSW  EXPORTS CPPanel =  BEGIN    z: UNCOUNTED ZONE = Heap.systemZone;  messages: Window.Handle = NIL;    font: WindowFont.Handle = WindowFont.defaultFont;  fontHeight: INTEGER = WindowFont.FontHeight[font];  digitWidth: INTEGER = WindowFont.CharWidth['0, font];  lineHeight: CARDINAL = fontHeight + 2;  tileHeight: CARDINAL = lineHeight;  tileRows: CARDINAL = 18;  tileColumns: CARDINAL = 3;  tileFlagLength: CARDINAL = digitWidth;  tileLVLength: CARDINAL = 12*digitWidth + 4;  tileRVLength: CARDINAL = 7*digitWidth + 5;  tileLength: CARDINAL = tileFlagLength + tileLVLength + tileRVLength;  tileBoxWidth: CARDINAL = tileColumns*tileLength + 12*digitWidth;  tilesPerRow: CARDINAL = tileBoxWidth/tileLength;  numTiles: CARDINAL = tileRows*tilesPerRow;  rowLayout: ARRAY [0..tileColumns) OF PanelSW.TileLayout ¬ [    [tileFlagLength, tileLVLength, tileRVLength],    [tileFlagLength, tileLVLength, tileRVLength],    [tileFlagLength, tileLVLength, tileRVLength + 21*digitWidth] ];  panelProcs: PanelSW.ClientProcsObject ¬ [    FreeRS, LHTypeInEval, NIL, ReadTarget, RHTypeInEval];  panel: PanelSW.Handle ¬ NIL;  RegisterSpec: TYPE = LONG POINTER TO RegisterSpecObject;  RegisterSpecObject: TYPE = CPSymbl.Symbol;  AbsToRep: PROCEDURE [rs: PanelSW.RegisterSpec] RETURNS [RegisterSpec] = INLINE    BEGIN RETURN[LOOPHOLE[rs, RegisterSpec]] END;  RepToAbs: PROCEDURE [rs: RegisterSpec] RETURNS [PanelSW.RegisterSpec] = INLINE    BEGIN RETURN[LOOPHOLE[rs, PanelSW.RegisterSpec]] END;  FreeRS: PanelSW.FreeRSProcType = BEGIN z.FREE[@rs]; END;  AllocateRegisterSpec: PROCEDURE [value: CPSymbl.Symbol]    RETURNS [PanelSW.RegisterSpec] =    BEGIN    rs: RegisterSpec;    rs ¬ z.NEW[CPSymbl.Symbol];    rs­ ¬ value;    RETURN[RepToAbs[rs]];    END;  ReadTarget: PanelSW.ReadTargetProcType =    BEGIN    myrs: RegisterSpec = AbsToRep[rs];    value: LONG CARDINAL;    s ¬ NIL;    IF rs = NIL THEN RETURN;    IF ~CPKernelDefs.InKernel[] THEN RETURN;    BEGIN ENABLE CPKernelDefs.Error => ERROR PanelSW.ClientError[unknown, reason];    WITH myrs SELECT FROM      number => ERROR;      tpc =>        BEGIN	real: CPDefs.RealCS;	virt: CPSymbl.VirturalCS;        s ¬ z.NEW[StringBody[200]];	real ¬ CPKernelDefs.ReadTpc[task];	[virt, , ] ¬ CPSymbl.RealToVirturalCS[real];	IF virt # CPSymbl.nullVirturalCS THEN CPSymbl.AppendVirturalCS[s, virt]	ELSE String.AppendNumber[s, real, 16];        RETURN;	END;      link => value ¬ CPKernelDefs.ReadLink[link];      realCS =>        BEGIN	mi: CPMIFormat.MI ¬ CPKernelDefs.ReadControlStore[real];        s ¬ z.NEW[StringBody[30]];	CPSymbl.AppendMI[s, mi];	RETURN;	END;      virtCS =>        BEGIN	real: CPDefs.RealCS;	mi: CPMIFormat.MI;	[real, , ] ¬ CPSymbl.VirturalToRealCS[virt];        s ¬ z.NEW[StringBody[30]];	IF real = CPSymbl.nullRealCS THEN	  BEGIN	  String.AppendString[s, "????"L];	  RETURN;	  END;	mi ¬ CPKernelDefs.ReadControlStore[real];	CPSymbl.AppendMI[s, mi];	RETURN;	END;      rReg => value ¬ CPKernelDefs.ReadRReg[r];      rH => value ¬ CPKernelDefs.ReadRH[r];      rAndRh => value ¬ LOOPHOLE[CPKernelDefs.ReadRAndRH[r]];      uReg => value ¬ CPKernelDefs.ReadUReg[u];      ioIn => value ¬ CPKernelDefs.ReadIOIn[io];      ioOut => ERROR PanelSW.ClientError[unknown, "Can't read output registers"L];      map => value ¬ CPKernelDefs.ReadMap[map];      real => value ¬ CPKernelDefs.ReadRealMemory[real];      virt => value ¬ CPKernelDefs.ReadVirturalMemory[virt];      other => value ¬ CPKernelDefs.ReadOther[other];      pc => value ¬ CPKernelDefs.ReadPC[];      ENDCASE => ERROR;    END;    s ¬ z.NEW[StringBody[16]];    IF Inline.HighHalf[value] # 0 THEN      BEGIN      low: CARDINAL = Inline.LowHalf[value];      String.AppendNumber[s, Inline.HighHalf[value], 16];      SELECT TRUE FROM        (low > 0FFFH) => NULL;        (low > 0FFH) => String.AppendString[s, "0"L];        (low > 0FH) => String.AppendString[s, "00"L];        ENDCASE => String.AppendString[s, "000"L];      String.AppendLongNumber[s, low, 16];      END    ELSE String.AppendLongNumber[s, value, 16];    END;  RHTypeInEval: PanelSW.RHTypeInEvalProcType =    BEGIN    myrs: RegisterSpec = AbsToRep[rs];    symbol: CPSymbl.Symbol;        display ¬ NIL;    IF rs = NIL OR typeIn = NIL OR typeIn.length = 0 THEN RETURN;    IF ~CPKernelDefs.InKernel[] THEN RETURN;    symbol ¬ CPSymbl.Eval[typeIn !      CPSymbl.Error => ERROR PanelSW.ClientError[unknown, reason] ];    BEGIN ENABLE CPKernelDefs.Error => ERROR PanelSW.ClientError[unknown, reason];    WITH myrs SELECT FROM      tpc => CPKernelDefs.WriteTpc[task, ExtractRealCS[symbol]];      link => CPKernelDefs.WriteLink[link, ExtractNumber[symbol]];      realCS => CPKernelDefs.WriteControlStore[real, ExtractMi[symbol]];      virtCS =>         BEGIN	real: CPDefs.RealCS;	[real, , ] ¬ CPSymbl.VirturalToRealCS[virt];	IF real # CPSymbl.nullRealCS THEN 	  CPKernelDefs.WriteControlStore[real, ExtractMi[symbol]];	END;      rReg => CPKernelDefs.WriteRReg[r, ExtractNumber[symbol]];      rH => CPKernelDefs.WriteRH[r, ExtractNumber[symbol]];      rAndRh => CPKernelDefs.WriteRAndRH[r, ExtractLongNumber[symbol]];      uReg => CPKernelDefs.WriteUReg[u, ExtractNumber[symbol]];      ioIn => ERROR PanelSW.ClientError[unknown, "Can't write input register"L];      ioOut => CPKernelDefs.WriteIOOut[io, ExtractNumber[symbol]];      map => CPKernelDefs.WriteMap[map, ExtractNumber[symbol]];      real => CPKernelDefs.WriteRealMemory[real, ExtractNumber[symbol]];      virt => CPKernelDefs.WriteVirturalMemory[virt, ExtractNumber[symbol]];      other => CPKernelDefs.WriteOther[other, ExtractNumber[symbol]];      pc => CPKernelDefs.WritePC[ExtractNumber[symbol]];      ENDCASE => ERROR;    END;    display ¬ ReadTarget[rs, TRUE];    END;    ExtractRealCS: PROCEDURE [symbol: CPSymbl.Symbol] RETURNS [CPDefs.RealCS] =    BEGIN    WITH symbol SELECT FROM      number => RETURN[Inline.LowHalf[n]];      realCS => RETURN[real];      virtCS =>        BEGIN	real: CPDefs.RealCS;	cycle: CPDefs.Cycle;	task: CPDefs.Task;	[real, cycle, task] ¬ CPSymbl.VirturalToRealCS[virt];	IF real = CPSymbl.nullRealCS THEN	  ERROR PanelSW.ClientError[unknown, "Can't translate that address to a .CR"L];	IF cycle # c1 THEN	  ERROR PanelSW.ClientError[unknown,"Please start in c1"L];      	RETURN[real];	END;      ENDCASE;    ERROR PanelSW.ClientError[unknown, "Unreasonable source/dest combination"L];    END;      ExtractMi: PROCEDURE [symbol: CPSymbl.Symbol] RETURNS [CPMIFormat.MI] =    BEGIN    WITH symbol SELECT FROM      mi => RETURN[mi];      ENDCASE;    ERROR PanelSW.ClientError[unknown, "Unreasonable source/dest combination"L];    END;    ExtractNumber: PROCEDURE [symbol: CPSymbl.Symbol] RETURNS [WORD] =    BEGIN    WITH symbol SELECT FROM      number => RETURN[Inline.LowHalf[n]];      real => RETURN[CPKernelDefs.ReadRealMemory[real]];      virt => RETURN[CPKernelDefs.ReadVirturalMemory[virt]];      ENDCASE;    ERROR PanelSW.ClientError[unknown, "Unreasonable source/dest combination"L];    END;  ExtractLongNumber: PROCEDURE [symbol: CPSymbl.Symbol] RETURNS [LONG UNSPECIFIED] =    BEGIN    WITH symbol SELECT FROM      number => RETURN[n];      ENDCASE;    ERROR PanelSW.ClientError[unknown, "Unreasonable source/dest combination"L];    END;  AppendPanelData: PUBLIC PROCEDURE [textSW: Window.Handle] = {    PanelSW.AppendPanelData[textSW, panel];    };  LHTypeInEval: PanelSW.LHTypeInEvalProcType =    BEGIN    value: CPSymbl.Symbol;    display ¬ NIL;    newRs ¬ NIL;    IF typeIn = NIL OR typeIn.length = 0 THEN RETURN;    value ¬ CPSymbl.Eval[typeIn !      CPSymbl.Error => ERROR PanelSW.ClientError[unknown, reason] ];    WITH value SELECT FROM      number => value ¬ [real[LOOPHOLE[n]]];      ENDCASE => NULL;    newRs ¬ AllocateRegisterSpec[value];    IF normalize THEN      BEGIN      temp: STRING ¬ [200];      CPSymbl.AppendSymbol[temp, value];      display ¬ String.CopyToNewString[temp, z];      END    ELSE display ¬ String.CopyToNewString[typeIn, z];    END;    MakePanelSW: PUBLIC PROCEDURE [    parent: Window.Handle,    err: Window.Handle,    modifyTypeIn: PanelSW.ModifyTypeInProcType,    typeIn: LONG POINTER TO LONG STRING] RETURNS [psw: Window.Handle] =    BEGIN    increment: LONG POINTER TO CARDINAL ¬ NIL;    box: Window.Box ¬ ToolWindow.nullBox;    box.dims.h ¬ tileRows*tileHeight;    panelProcs.modifyTypeIn ¬ modifyTypeIn;    psw ¬ ToolWindow.CreateSubwindow[parent: parent, box: box];    panel ¬ PanelSW.Create[      psw, err, numTiles, DESCRIPTOR[rowLayout], @panelProcs, typeIn, increment, NIL, , ];    Tool.AddThisSW[window: parent, sw: psw, swType: PanelSW.SWType[]];    END;      Destroy: PUBLIC PROCEDURE =    BEGIN    IF panel # NIL THEN PanelSW.Destroy[panel];    panel ¬ NIL;    END;      GetPanel: PUBLIC PROCEDURE RETURNS [PanelSW.Handle] = BEGIN RETURN[panel]; END;      Clear: PUBLIC PROCEDURE = BEGIN IF panel # NIL THEN PanelSW.Clear[panel]; END;      Refresh: PUBLIC PROCEDURE = BEGIN IF panel # NIL THEN PanelSW.Update[panel] END;      Initialize: PUBLIC PROCEDURE =    BEGIN    IF panel # NIL THEN PanelSW.Clear[panel];    END;      END.-- Log of last edits-- JAC	30-May-85 16:42:36	CP renamed to CPDefs-- JAC	31-May-85  9:46:06	CPKernel renamed to CPKernelDefs; CPSymbols renamed to CPSymbl; CPMI renamed to CPMIFormat-- JAC	10-Jun-85 14:18:55	PanelSW.Create has 3 more parameters
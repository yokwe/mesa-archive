{Copyright (C) 1984  by Xerox Corporation. All rights reserved.  File: DaybreakKernel.mc Created:  30-Jan-85 17:51:57 by JAC Last edit by JAC	29-Oct-85 10:54:43	change mailbox location Last edit by RDH	 4-Dec-85 11:38:29	Changes for multibank and move defs to defs file. This module contains the breakpoint handling code, code for starting/resuming execution of the microcode and the template for register reading and writing.} Reserve[1, 0F97];	rK ¬ 0, ClrIntErr,				c1, at[0];	rHMailBox ¬ locationHigh, ClrMPIntIOP, GOTO[SetUpMailBox],c2, at[0FAF];{The breakpointed instruction of any cycle points to kEntry.  The pending dispatch bits are saved in UKSaveDisp and the cycle number and break ID is saved in UBreakID.  The lower 8 bits of UBreakID contains the break ID and bits 6 and 7 (PrincOps numbering) contain the cycle information.} kEntry:	rK ¬ 0, GOTO[kSaveDisp],			c*, at[kEntryLoc];	rK ¬ 1, GOTO[kSaveDisp],			c*, at[1, 10, kEntry];	rK ¬ 2, GOTO[kSaveDisp],			c*, at[2, 10, kEntry];	rK ¬ 3, GOTO[kSaveDisp],			c*, at[3, 10, kEntry];	rK ¬ 4, GOTO[kSaveDisp],			c*, at[4, 10, kEntry];	rK ¬ 5, GOTO[kSaveDisp],			c*, at[5, 10, kEntry];	rK ¬ 6, GOTO[kSaveDisp],			c*, at[6, 10, kEntry];	rK ¬ 7, GOTO[kSaveDisp],			c*, at[7, 10, kEntry];	rK ¬ 8, GOTO[kSaveDisp],			c*, at[8, 10, kEntry];	rK ¬ 9, GOTO[kSaveDisp],			c*, at[9, 10, kEntry];	rK ¬ 0A, GOTO[kSaveDisp],			c*, at[0A, 10, kEntry];	rK ¬ 0B, GOTO[kSaveDisp],			c*, at[0B, 10, kEntry];	rK ¬ 0C, GOTO[kSaveDisp],			c*, at[0C, 10, kEntry];	rK ¬ 0D, GOTO[kSaveDisp],			c*, at[0D, 10, kEntry];	rK ¬ 0E, GOTO[kSaveDisp],			c*, at[0E, 10, kEntry];	rK ¬ 0F, GOTO[kSaveDisp],			c*, at[0F, 10, kEntry];	kSaveDisp:	UKSaveDisp ¬ rK,				c*;	rK ¬ RHrK, XC2npcDisp,				c*;kFindCycle1:	rK ¬ rK + 0FF + 1, BRANCH[$, kFoundCycle1, 0D],	c*;	XC2npcDisp, GOTO[kFindCycle1],			c*;	kFoundCycle1:	UBreakID ¬ rK,					c1;	rHMailBox ¬ locationHigh,			c2;		{At this point we should put the bank number into bits 4,5 of 	 UBreakID but since this is the main kernel in bank 0, 	 it is already there.}	 SetUpMailBox:	rMailBox ¬ locationPage,			c3, at[AltKernelEntry];	rMailBox ¬ rMailBox LRot8,			c1;	rMailBox ¬ rMailBox or locationLow,		c2;	Noop,						c3;	MAR ¬ [rHMailBox, rMailBox + 0], 		c1;	Noop,						c2;	rMailBox ¬ MD,					c3;	rMailBox ¬ rMailBox LRot8 {byteswap},		c1;	rMailBox ¬ rMailBox LRot4,			c2;	rMailBox ¬ rMailBox RShift1,			c3;	{save break ID in memory}	MAR ¬ [rHMailBox, rMailBox + 2], 		c1;	MDR ¬ rK, CANCELBR[$, 2], LOOPHOLE[wok],	c2;	rK ¬ UKSaveDisp,				c3;	{save dispatch bits in memory}	MAR ¬ [rHMailBox, rMailBox + 3], 		c1;	MDR ¬ rK, CANCELBR[$, 2], LOOPHOLE[wok],	c2;	rK ¬ 0,						c3;		{Signal to the debugger that the kernel is now ready to execute commands by placing a 0 in the high order bit of the command mailbox.}SignalZero:	MAR ¬ [rHMailBox, rMailBox + 1], 		c1, at[0FB4];	MDR ¬ 0, CANCELBR[$, 2], LOOPHOLE[wok],		c2;	CALL[GetCommand],				c3;			{Wait to get ready to call GetCommand to see if the debugger has a command ready.}	kWait2:	Noop,						c2, at[0FBC];kWait3:	CALL[SignalZero],				c3;		GetCommand: 	MAR ¬ [rHMailBox, rMailBox + 1], 		c1, at[0FA7];	Noop, CANCELBR[$, 2],				c2, at[0FA8];	rK ¬ MD, XHDisp,				c3, at[0FA6];		BRANCH[$, CommandReady, 2],			c1, at[0FA5];	Noop,						c2, at[0FAA];	GOTO[GetCommand],				c3, at[0FA9];	CommandReady:	Ybus ¬ rK, YDisp,				c2;	DISP3[kCommand], 				c3;		{In order to write an internal register, the debugger must put the value to be written in the mailbox.  The debuggee is then instructed to read from the mailbox into the register to be written.  The instruction at c3 is written by the debugger to contain "RH ¬ MD", "R ¬ MD" or "Q ¬ MD" and points to SignalZero.  If trying to write stackP or a U register, 2 instructions must be overlaid.  "rK ¬ MD" is written at the c3 instruction, and "StackP ¬ rK" or "UReg ¬ rK" is written in the next c1 instruction and execution continues at kWait2.}kCommand:	MAR ¬ [rHMailBox, rMailBox + 0], 		c1, at[0FF0]; {at[0, 8, kCommand];}	Noop,						c2;kWrite:	Noop, 						c3, at[0FB0];	Noop, GOTO[kWait2],				c1, at[0FB1];			{In order to read an internal register, the debuggee must be instructed to write the value of the register into the mailbox.  The debugger reads the value from the mailbox.  The instruction at c2 is written with one of the following: MDR ¬ RReg, MDR ¬ RH, or MDR ¬ Q.  Since MDR ¬ UReg has a timing error reading a U register requires writing "rK ¬ UReg, GOTOABS[0FF1]" at c3 of the buffer and MDR ¬ rK at kRead.}		MAR ¬ [rHMailBox, rMailBox + 0], 		c1, at[1, 8, kCommand];KRead:	Noop,						c2, at[0FB9];	CALL[SignalZero], 				c3, at[0FFB];			{In order to write a link register, the debugger puts the value in the mailbox and writes the location at kWriteLink with "Ln ¬ 0, GOTO[WriteLink]" and writes the command in the mailbox which says write a link register.}	MAR ¬ [rHMailBox, rMailBox + 0], 		c1, at[3, 8, kCommand];	Noop,						c2;	Xbus ¬ MD, XDisp, 				c3;kWriteLink:	DISP4[WriteLink], {Ln ¬ 0 is written here also}	c1, at[0FB5];		WriteLink:	GOTO[kWait3],				c2, at[WriteLinkTable];	GOTO[kWait3],				c2, at[1, 10, WriteLink];	GOTO[kWait3],				c2, at[2, 10, WriteLink];	GOTO[kWait3],				c2, at[3, 10, WriteLink];	GOTO[kWait3],				c2, at[4, 10, WriteLink];	GOTO[kWait3],				c2, at[5, 10, WriteLink];	GOTO[kWait3],				c2, at[6, 10, WriteLink];	GOTO[kWait3],				c2, at[7, 10, WriteLink];	GOTO[kWait3],				c2, at[8, 10, WriteLink];	GOTO[kWait3],				c2, at[9, 10, WriteLink];	GOTO[kWait3],				c2, at[0A, 10, WriteLink];	GOTO[kWait3],				c2, at[0B, 10, WriteLink];	GOTO[kWait3],				c2, at[0C, 10, WriteLink];	GOTO[kWait3],				c2, at[0D, 10, WriteLink];	GOTO[kWait3],				c2, at[0E, 10, WriteLink];	GOTO[kWait3],				c2, at[0F, 10, WriteLink];	{In order to read a link register, the c1 instruction is written with correct LnDisp. Remember that its INIA[7] must be 1.}kReadLink: 	Noop, {LnDisp is written here}			c1, at[4, 8, kCommand];	DISP4[ReadLink],				c2, at[0FBA];	ReadLink: 	rK ¬ 0, GOTO[kLink],				c3, at[0, 10, ReadLink];	rK ¬ 1, GOTO[kLink],				c3, at[1, 10, ReadLink];	rK ¬ 2, GOTO[kLink],				c3, at[2, 10, ReadLink];	rK ¬ 3, GOTO[kLink],				c3, at[3, 10, ReadLink];	rK ¬ 4, GOTO[kLink],				c3, at[4, 10, ReadLink];	rK ¬ 5, GOTO[kLink],				c3, at[5, 10, ReadLink];	rK ¬ 6, GOTO[kLink],				c3, at[6, 10, ReadLink];	rK ¬ 7, GOTO[kLink],				c3, at[7, 10, ReadLink];	rK ¬ 8, GOTO[kLink],				c3, at[8, 10, ReadLink];	rK ¬ 9, GOTO[kLink],				c3, at[9, 10, ReadLink];	rK ¬ 0A, GOTO[kLink],				c3, at[0A, 10, ReadLink];	rK ¬ 0B, GOTO[kLink],				c3, at[0B, 10, ReadLink];	rK ¬ 0C, GOTO[kLink],				c3, at[0C, 10, ReadLink];	rK ¬ 0D, GOTO[kLink],				c3, at[0D, 10, ReadLink];	rK ¬ 0E, GOTO[kLink],				c3, at[0E, 10, ReadLink];	rK ¬ 0F, GOTO[kLink],				c3, at[0F, 10, ReadLink];		kLink:;			MAR ¬ [rHMailBox, rMailBox + 0], 		c1, at[0FB6];	MDR ¬ rK,					c2;	Noop, CALL[SignalZero], 			c3;	{This buffer will be used to do various commands.  Commands include reading EKErr, ibPtr, and IOXIn as well as reading and writing pc16 and MesaInt.  It will also be used for continuing.  More space may be needed.}	kBuffer:	Noop, 						c1, at[5, 8, kCommand];	Noop,						c2, at[0FF6];	Noop, 						c3, at[0FF7];	Noop, GOTO[kWait2], {make assembler happy} 	c1, at[0FF8];	
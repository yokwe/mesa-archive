-- File: OthelloFetchImpl.mesa - last edit:-- caj           22-Oct-87 17:52:55-- dwr           12-Jan-87 16:08:39-- bjd           22-Jun-85 12:17:33-- rkj           26-Feb-84 15:24:23-- Copyright (C) 1984, 1985, 1987 by Xerox Corporation. All rights reserved. DIRECTORY  Auth,  Environment USING [bytesPerPage, bytesPerWord],  File USING [    Create, Delete, File, MakePermanent, nullFile, PageNumber, SetSize, Unknown],  FileTypes USING [tUntypedFile],  Heap USING [systemZone],  NSName,  NSString,  OthelloDefs USING [    AbortingCommand, CommandProcessor, Confirm, FlipCursor, GetLvIDFromUser,    GetName, IndexTooLarge, LeaderPage, leaderPages, lpNoteLength, lpVersion,    MyNameIs, Question, RegisterCommandProc, WriteLine, WriteString, Yes],  OthelloFetch USING [Destination, Handle, Object],  OthelloOps USING [    BootFileType, GetPhysicalVolumeBootFile, GetVolumeBootFile, MakeBootable,    MakeUnbootable, SetPhysicalVolumeBootFile, SetVolumeBootFile],  PhysicalVolume USING [ID],  Process ,  Profile ,  Space USING [Map, ScratchMap, Unmap],  Stream,  String ,  TemporaryBooting USING [InvalidParameters],  TemporaryBootingExtras USING [BootableFileError],  Volume USING [Close, ID, InsufficientSpace, Open, Unknown];OthelloFetchImpl: MONITOR  IMPORTS Auth, File, Heap, NSString, OthelloDefs, OthelloOps, Process,     Space, Stream, String, TemporaryBooting, TemporaryBootingExtras, Volume  EXPORTS OthelloDefs, OthelloFetch, Profile =  BEGIN    Object: TYPE = OthelloFetch.Object;    Handle: TYPE = OthelloFetch.Handle;    list: Handle ¬ NIL;    current: Handle ¬ NIL;    cmFile: LONG STRING ¬ NIL;  fileName: LONG STRING ¬ NIL;  z: UNCOUNTED ZONE = Heap.systemZone;  S: PROC [s: LONG STRING] RETURNS [NSString.String] = INLINE {    RETURN[NSString.StringFromMesaString[s]]};      -- Fetcher registration    Register: PUBLIC PROC [h: Handle] =    BEGIN    h.next ¬ list;    list¬ h;    END;    Select: PUBLIC PROC [h: Handle] =    BEGIN    IF current # NIL THEN current.Close[];    current¬ h;    END;    --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- String/Credentials Commands  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  domain, org: LONG STRING ¬ NIL;    GetDefaultDomain: --Profile--PUBLIC PROC [proc: PROC [LONG STRING]] = {    proc[domain]};    GetDefaultOrganization: --Profile--PUBLIC PROC [proc: PROC [LONG STRING]] = {    proc[org]};    GetID: --Profile--PUBLIC PROC [    flavor: Auth.Flavor, proc: PROC [id: Auth.IdentityHandle]] =    BEGIN    SELECT flavor FROM      simple => {        IF simple = NIL THEN simple ¬ MakeID[simple];	proc[simple]};      strong => {        IF strong = NIL THEN simple ¬ MakeID[strong];	proc[strong]};      ENDCASE => ERROR;    END;  Qualify: --Profile--PUBLIC PROC [    token, newToken: LONG STRING,    qualification: Profile.Qualification ¬ clearinghouse] = {    namePart: CARDINAL ¬ String.Length[token];    currentQual: Profile.Qualification ¬ none;    octalAddress: BOOLEAN ¬ TRUE; -- only '0..'7 and '# allowed    ss: String.SubStringDescriptor;    chChar: CHARACTER = ':;    regChar: CHARACTER = '.;    IF String.Length[token] = 0 THEN RETURN;    FOR i: CARDINAL IN [0..token.length) DO       SELECT token[i] FROM         regChar => {namePart ¬ i; currentQual ¬ registry};  -- look for last dot	 chChar => {namePart ¬ i; currentQual ¬ clearinghouse; EXIT}; -- first :	 IN['0..'7], '# => NULL;	 ENDCASE => octalAddress ¬ FALSE;       ENDLOOP;    IF currentQual = qualification OR octalAddress THEN {      String.AppendString[newToken, token]; RETURN};    ss ¬ [base: token, offset: 0, length: namePart];    String.AppendSubString[newToken, @ss];    SELECT qualification FROM      none => NULL;    <<registry =>        IF String.Length[defaultRegistry] > 0 THEN {	  String.AppendChar[newToken, regChar];	  String.AppendString[newToken, defaultRegistry]};>>      clearinghouse =>        IF String.Length[domain] > 0 OR 	   String.Length[org] > 0 THEN {	  String.AppendChar[newToken, chChar];	  String.AppendString[newToken, domain];	  String.AppendChar[newToken, chChar];	  String.AppendString[newToken, org]};      ENDCASE};        ClearinghouseCmd: PROC = {    OthelloDefs.MyNameIs[	  myNameIs: "Clearinghouse"L,	  myHelpIs: "Set defaults for Clearinghouse"L];    OthelloDefs.GetName["Domain: "L, @domain];    OthelloDefs.GetName["Organization: "L, @org]};    userName: PUBLIC LONG STRING ¬ NIL;  userPassword: PUBLIC LONG STRING ¬ NIL;  strong, simple: Auth.IdentityHandle ¬ NIL;    LoginCmd: PROC = {    OthelloDefs.MyNameIs[      myNameIs: "Login"L, myHelpIs: "Set user name & password"L];    OthelloDefs.GetName["User: "L, @userName];    OthelloDefs.GetName["Password: "L, @userPassword, stars];    IF simple # NIL THEN {Auth.FreeIdentity[@simple, z]; simple ¬ NIL};    IF strong # NIL THEN {Auth.FreeIdentity[@strong, z]; strong ¬ NIL}};  MakeID: PROC [flavor: Auth.Flavor] RETURNS [id: Auth.IdentityHandle] = {    myName: NSName.NameRecord ¬ [      org: S[org], domain: S[domain], local: S[userName]];    id ¬ Auth.MakeIdentity[      myName: @myName,      password: S[userPassword],      z: z,      style: flavor,      dontCheck: TRUE]};      directory: PUBLIC LONG STRING ¬ NIL;  Directory: PROC = {    OthelloDefs.MyNameIs[      myNameIs: "Directory"L,      myHelpIs: "Set Default FTP directory"L];    OthelloDefs.GetName["Directory: "L, @directory]};    -- Simple Fetches  FetchBoot: PROC = {    Fetch[pilot, "Boot file name: "L, "Fetch Boot File"L, "Fetch Boot File"L, "boot"L]};  FetchGerm: PROC = {    Fetch[germ,  "Germ file name: "L, "Germ Fetch"L, "Fetch Germ"L, "germ"L]};  FetchPilotMicrocode: PROC = {    Fetch[      softMicrocode,      "Pilot microcode file name: "L,      "Pilot Microcode Fetch"L,      "Fetch and Install Pilot Microcode"L,      "db"L]};  FetchDiagnosticMicrocode: PROC = {    Fetch[      hardMicrocode,      "Diagnostic microcode file name: "L,      "Diagnostic Microcode Fetch"L,      "Fetch and Install Diagnostic Microcode"L,      "db"L]};    Fetch: PROC [    type: OthelloOps.BootFileType, prompt, name, helpMsg, extension: STRING] = {    created: BOOLEAN;    file: File.File;    firstPage: File.PageNumber;    lvID: Volume.ID;    ok: BOOLEAN ¬ TRUE;    pvID: PhysicalVolume.ID;    OthelloDefs.MyNameIs[myNameIs: name, myHelpIs: helpMsg];    CheckOpen[];    [pvID: pvID, lvID: lvID] ¬ OthelloDefs.GetLvIDFromUser[];    OthelloDefs.GetName[prompt, @fileName];    Volume.Open[lvID];    [file, firstPage] ¬ OthelloOps.GetVolumeBootFile[lvID, type];    IF ~(created ¬ file = File.nullFile) THEN      OthelloOps.MakeUnbootable[file, type, firstPage !         File.Unknown, Volume.Unknown => {created ¬ TRUE; CONTINUE};        TemporaryBooting.InvalidParameters,          TemporaryBootingExtras.BootableFileError => {            OthelloDefs.WriteLine["Warning, trouble making unbootable"L];	    CONTINUE}];    IF created THEN file ¬ File.Create[lvID, 1, FileTypes.tUntypedFile];    current.Retrieve[fileName, [pilotFileSystemWrite[file]]      ! UNWIND => {IF created THEN File.Delete[file]; Volume.Close[lvID]}];    IF created THEN File.MakePermanent[file];    OthelloDefs.WriteString["Installing..."L];    OthelloOps.MakeBootable[file, type, OthelloDefs.leaderPages    ! TemporaryBooting.InvalidParameters,      TemporaryBootingExtras.BootableFileError => {ok ¬ FALSE;        OthelloDefs.WriteLine["Warning, trouble making bootable"L]; CONTINUE}];    << /// Begin Temporary /// >>    << Temporary until initial microcode can handle non-contiguous pilot microcode       and germ.  Keep trying until it makes a contiguous file.  >>    << Begin Temporary    BEGIN    old: File.File ¬ File.nullFile;    DO      current.Retrieve[fileName, [pilotFileSystemWrite[file]]        ! UNWIND => {IF created THEN File.Delete[file]; Volume.Close[lvID]}];      IF created THEN File.MakePermanent[file];      -- First time old is null, so write "installing"; after that old is always      -- the previous file that failed the MakeBootable contiguous test.      -- As soon as it makes it through MakeBootable, it exits the loop.      -- Note that the old one is not deleted to avoid recreating on top of      -- whatever broke up the old one to begin with.  The discards are temporary      -- and will disappear with booting.      IF old ~= File.nullFile        THEN {SpecialFile.MakeTemporary[old]; old ¬ File.nullFile}	ELSE OthelloDefs.WriteString["Installing..."L];      OthelloOps.MakeBootable[file, type, OthelloDefs.leaderPages        ! TemporaryBootingExtras.MultiGroupUCodeOrGerm => {old ¬ file; CONTINUE};	  TemporaryBooting.InvalidParameters,          TemporaryBootingExtras.BootableFileError => {ok ¬ FALSE;          OthelloDefs.WriteLine["Warning, trouble making bootable"L]; CONTINUE}];      IF old = File.nullFile THEN EXIT;      file ¬ File.Create[lvID, 1, FileTypes.tUntypedFile];      ENDLOOP;    END;    -- End Temporary >>    IF ok THEN OthelloOps.SetVolumeBootFile[file, type, OthelloDefs.leaderPages];    OthelloDefs.WriteLine["done"L];    IF type IN [hardMicrocode..germ] AND       OthelloDefs.Yes["Shall I also use this for the Physical Volume? "L       ! UNWIND => Volume.Close[lvID]] THEN      OthelloOps.SetPhysicalVolumeBootFile[file, type, OthelloDefs.leaderPages];    IF type = pilot THEN      {IF OthelloOps.GetPhysicalVolumeBootFile[pvID, type].file = file THEN        OthelloOps.SetPhysicalVolumeBootFile[	  file, type, OthelloDefs.leaderPages]};    Volume.Close[lvID]};      bufPages: CARDINAL = 8;  StartFeedback: PUBLIC SIGNAL = CODE;  GrabBitsFromStream: PUBLIC PROC [    rs: Stream.Handle, rsSizePages: LONG CARDINAL,    destination: OthelloFetch.Destination, note: LONG STRING ¬ NIL] = {    WITH destination SELECT FROM      pilotFileSystemWrite => {	buffer: LONG POINTER ¬ NIL;        base: File.PageNumber ¬ 0;	got: CARDINAL;        File.SetSize[localFile, rsSizePages + OthelloDefs.leaderPages	! Volume.InsufficientSpace => OthelloDefs.AbortingCommand["Volume Full"L]];	SetLeaderPage[localFile, note];	SIGNAL StartFeedback;	WHILE base < rsSizePages DO          thisPages: CARDINAL = CARDINAL[MIN[rsSizePages-base, bufPages]];	  size:      CARDINAL = thisPages*Environment.bytesPerPage;	  start:     CARDINAL ¬ 0;	  nProcesses ¬ 0;	  buffer ¬ Space.Map[	    window:[localFile, base+OthelloDefs.leaderPages, thisPages],	    life: dead].pointer;          DO	    [bytesTransferred: got] ¬ rs.GetBlock[[	      blockPointer: buffer, startIndex: start, stopIndexPlusOne: size] !	        Stream.EndOfStream => {	          got ¬ 0; start ¬ start + nextIndex; CONTINUE};	        UNWIND => [] ¬ Space.Unmap[buffer]];	    IF got = 0 THEN {[] ¬ Space.Unmap[buffer]; RETURN};            IF (start ¬ start + got) = size THEN EXIT;            ENDLOOP;	  ForkUnmap[buffer];          OthelloDefs.FlipCursor[];	  base ¬ base + thisPages;          ENDLOOP;	buffer ¬ Space.ScratchMap[1]; -- check for any leftover stuff	[bytesTransferred: got] ¬ rs.GetBlock[[	  blockPointer: buffer, startIndex: 0,	  stopIndexPlusOne: Environment.bytesPerPage] !	    Stream.EndOfStream => {got ¬ nextIndex; CONTINUE};	    UNWIND => [] ¬ Space.Unmap[buffer]];	[] ¬ Space.Unmap[buffer];	IF got # 0 THEN OthelloDefs.AbortingCommand[	  "File longer than advertised length"L]};      string => {	SIGNAL StartFeedback;	DO          stringOverhead: CARDINAL = SIZE[StringBody]*Environment.bytesPerWord;          string: LONG STRING = Space.ScratchMap[bufPages];          string­ ¬ [	    length: 0,	    maxlength: bufPages*Environment.bytesPerPage - stringOverhead,	    text: ];	  WHILE string.length < string.maxlength DO            got: CARDINAL;	    [bytesTransferred: got] ¬ rs.get[	      rs,	      [blockPointer: LOOPHOLE[@string.text],	       startIndex: string.length, stopIndexPlusOne: string.maxlength],	      rs.options	      ! Stream.EndOfStream => {	          got ¬ 0; string.length ¬ string.length + nextIndex; CONTINUE};                UNWIND => [] ¬ Space.Unmap[string]];	    IF got = 0 THEN {	      stringProc[string! UNWIND => [] ¬ Space.Unmap[string]];	      [] ¬ Space.Unmap[string]; RETURN};            string.length ¬ string.length + got;            ENDLOOP;          [] ¬ Space.Unmap[string];          OthelloDefs.AbortingCommand["Command file too long!"L];          ENDLOOP};      rawWrite =>{	buffer: LONG POINTER = Space.ScratchMap[1];        done:  BOOLEAN ¬ FALSE;        first: BOOLEAN ¬ TRUE;	options: Stream.InputOptions ¬ rs.options;	GetPage: PROC RETURNS [LONG POINTER] = {          got:   CARDINAL; index: CARDINAL ¬ 0;          IF first THEN {SIGNAL StartFeedback; first ¬ FALSE};	  WHILE ~done DO	    [bytesTransferred: got] ¬ rs.get[	      sH: rs,	      block: [blockPointer: buffer, startIndex: index,	       stopIndexPlusOne: Environment.bytesPerPage],	      options: options	      ! Stream.EndOfStream => {got ¬ nextIndex; done ¬ TRUE; CONTINUE}];            IF (index ¬ index + got) = Environment.bytesPerPage 	       OR done THEN {OthelloDefs.FlipCursor[]; EXIT}            ENDLOOP;          RETURN[IF done AND index = 0 THEN NIL ELSE buffer]};	options.signalEndOfStream ¬ TRUE;        linkProc[GetPage ! UNWIND => [] ¬ Space.Unmap[buffer]];        WHILE ~done DO [] ¬ GetPage[! UNWIND => [] ¬ Space.Unmap[buffer]] ENDLOOP;        [] ¬ Space.Unmap[buffer]};      ENDCASE => ERROR};     -- Initial Ucode Fetch Command  FetchInitialMicrocode: PUBLIC PROC [    InstallProc: PROC [getPage: PROC RETURNS [LONG POINTER]]] = {    CheckOpen[];    OthelloDefs.GetName["File name: "L, @fileName];    OthelloDefs.Confirm[];    current.Retrieve[fileName, [rawWrite[InstallProc]]]};      -- Command Files    AlternateGetCMFile: PUBLIC PROC [s: LONG STRING] = {    z.FREE[@cmFile];    cmFile ¬ z.NEW[StringBody[s.length+8]];    FOR i: CARDINAL IN [1..s.length) DO      String.AppendChar[cmFile, s[i]] ENDLOOP;    DoIndirect[]};  Indirect: PROC = {    OthelloDefs.MyNameIs[      myNameIs: "@", myHelpIs: "Run command file"L];    OthelloDefs.GetName["Command file: "L, @cmFile    ! OthelloDefs.Question => {      OthelloDefs.WriteLine["[Host]<Dir>Filename"L]; RESUME}];    DoIndirect[]};    DoIndirect: PROC = {    [] ¬ String.AppendExtensionIfNeeded[@cmFile, "othello"L, z];    FOR h: Handle ¬ list, h.next UNTIL h = NIL DO      IF h.DoIndirect[cmFile] THEN RETURN;      ENDLOOP;    OthelloDefs.AbortingCommand["Unrecognizable command file name"L]};      -- Misc. commands     nProcesses, maxProcesses: NATURAL ¬ LAST[NATURAL];   finished: CONDITION;       ForkUnmap: ENTRY PROCEDURE [buffer: LONG POINTER] =      BEGIN     BEGIN ENABLE Process.TooManyProcesses => {maxProcesses ¬ nProcesses; RETRY};     WHILE nProcesses >= maxProcesses DO       WAIT finished; ENDLOOP;     Process.Detach[LOOPHOLE[FORK DoUnmap[buffer]]];     nProcesses ¬ nProcesses+1;     END;     END;    DoUnmap: ENTRY PROCEDURE [buffer: LONG POINTER] =    --buffer ¬ Space.Unmap[buffer, return];     BEGIN     buffer ¬ Space.Unmap[buffer];     nProcesses ¬ MAX[nProcesses-1, 0];     NOTIFY finished;     END;       CloseCmd: PROC = {    OthelloDefs.MyNameIs[      myNameIs: "Close"L, myHelpIs: "Close currently open connection"L];    CloseFetch[]};    CloseFetch: PUBLIC PROC = {    Select[NIL]};    ListCmd: PROC = {    OthelloDefs.MyNameIs[      myNameIs: "List Files"L, myHelpIs: "Enumerate files matching pattern"L];    CheckOpen[];    OthelloDefs.GetName["Pattern: "L, @fileName    ! OthelloDefs.Question => {      OthelloDefs.WriteLine["pattern to match"L]; RESUME}];    current.List[fileName]};    CheckOpen: PROC = {    IF current = NIL THEN      OthelloDefs.AbortingCommand["You must execute an Open command first"L]};    SetLeaderPage: PUBLIC PROCEDURE [file: File.File, note: LONG STRING] =    BEGIN    lp: LONG POINTER TO OthelloDefs.LeaderPage ¬ Space.Map[[file, 0, OthelloDefs.leaderPages]].pointer;    lp.version ¬ OthelloDefs.lpVersion;    lp.length ¬ MIN[note.length, OthelloDefs.lpNoteLength];    FOR i: CARDINAL IN [0..lp.length) DO      lp.note[i] ¬ note[i];      ENDLOOP;    [] ¬ Space.Unmap[lp];    END;     -- command processor  commandProcessor: OthelloDefs.CommandProcessor ¬ [FetchCommands];  FetchCommands: PROC [index: CARDINAL] = {    SELECT index FROM      0 => Indirect[];      1 => ClearinghouseCmd[];      2 => CloseCmd[];      3 => Directory[];      4 => FetchBoot[];      5 => FetchDiagnosticMicrocode[];      6 => FetchGerm[];      7 => FetchPilotMicrocode[];      8 => ListCmd[];      9 => LoginCmd[];      ENDCASE => OthelloDefs.IndexTooLarge};  -- init  OthelloDefs.RegisterCommandProc[@commandProcessor];  END.
-- File: OthelloNS.mesa - last edit:-- BJD    .PA          15-Feb-85 16:10:58-- AOF		25-Jan-85 10:33:26-- Copyright (C) 1983 , 1985 by Xerox Corporation. All rights reserved. DIRECTORY  AddressTranslation USING [Error, PrintError, StringToNetworkAddress],  Auth USING [IdentityHandle],  NSBuffer USING [Buffer, ReturnBuffer],  ExtendedString USING [AppendNumber],  Format USING [StringProc],  Inline USING [HighByte, LowByte],  NSConstants USING [echoerSocket],  NSTypes USING [maxDataBytesPerEcho, wordsPerIDPHeader],  OthelloDefs,  Process USING [Detach, Pause, SecondsToTicks, Yield],  Profile USING [GetID],  Router USING [    FillRoutingTable, GetDelayToNet, infinity, endEnumeration, startEnumeration,    EnumerateRoutingTable],  Socket USING [    AssignNetworkAddress, Create, Delete, GetPacket, ChannelHandle,    PutPacket, GetSendBuffer, SetPacketBytes, GetPacketBytes,    SetWaitTime, TimeOut],  String USING [AppendString, StringBoundsFault],  System USING [NetworkAddress, SocketNumber, NetworkNumber, HostNumber];OthelloNS: PROGRAM  IMPORTS AddressTranslation, NSBuffer, ExtendedString, Inline, Profile, Process, Router,    String, Socket, OthelloDefs =  BEGIN OPEN OthelloDefs;  EchoUser: PROC =    BEGIN    bytesPerBuffer: CARDINAL;    funny, late:    LONG CARDINAL ¬ 0;    recv, sent:     LONG CARDINAL ¬ 0;    wrong:          LONG CARDINAL ¬ 0;    me, where:      System.NetworkAddress;    mySoc:          Socket.ChannelHandle;    packetNumber:   CARDINAL ¬ 0;    pleaseStop:     BOOLEAN ¬ FALSE;    routing:        CARDINAL;    Watch:          PROC = {[] ¬ ReadChar[]; pleaseStop ¬ TRUE};    PrintErrorNS:  PROC [b: NSBuffer.Buffer] = {      source: System.NetworkAddress ¬ b.ns.source;      NewLine[];      IF b.ns.packetType = error THEN {        len: CARDINAL = b.ns.pktLength;        WriteString["[Error packet, code="L];        WriteOctal[LOOPHOLE[b.ns.errorType]];        WriteString[", from: "L];        PrintNSAddress[@source];        WriteString["] "L];        FOR i: CARDINAL IN [0..len - NSTypes.wordsPerIDPHeader) DO          WriteChar[Inline.LowByte[b.ns.errorBody[i]]];	  WriteChar[Inline.HighByte[b.ns.errorBody[i]]];	  ENDLOOP}      ELSE {        WriteString[" ***** "L];        WriteString["Funny packet type = "L];        WriteOctal[LOOPHOLE[b.ns.packetType]];        WriteString[" ***** "L]};      NewLine[]};          identity: Auth.IdentityHandle ¬ NIL;    getID: PROC [id: Auth.IdentityHandle] = {identity ¬ id};    GetName["Echo to: "L, @echoName];    Profile.GetID[simple, getID];    [where, ] ¬ AddressTranslation.StringToNetworkAddress[echoName, identity !      AddressTranslation.Error => {        msg: LONG STRING ¬ [100];	appendErrorMsg: Format.StringProc = {	  String.AppendString[msg, s ! String.StringBoundsFault => RESUME[NIL]]};	AddressTranslation.PrintError[error: errorRecord, proc: appendErrorMsg];        OthelloDefs.AbortingCommand[msg]}];    where.socket ¬ NSConstants.echoerSocket;    routing ¬ Router.GetDelayToNet[where.net];    IF routing = Router.infinity THEN      AbortingCommand["Can't reach that network"L];    me ¬ Socket.AssignNetworkAddress[];    mySoc ¬ Socket.Create[me.socket];    Socket.SetWaitTime[mySoc, 2000];  --two second timeout    WriteString[".   ["L]; PrintNSAddress[@me]; WriteString["] => ["L];        PrintNSAddress[@where];    WriteChar[']]; NewLine[];    Process.Detach[FORK Watch[]];    bytesPerBuffer ¬ NSTypes.maxDataBytesPerEcho;    UNTIL pleaseStop DO      FOR len: CARDINAL IN [4..bytesPerBuffer] UNTIL pleaseStop DO        b: NSBuffer.Buffer ¬ Socket.GetSendBuffer[mySoc];	b.ns.destination ¬ where;        b.ns.packetType ¬ echo; b.ns.echoType ¬ echoRequest;        Socket.SetPacketBytes[b, len];        FOR i: CARDINAL IN [4..len - 4) DO b.ns.echoBytes[i] ¬ i; ENDLOOP;	b.ns.echoWords[0] ¬ b.ns.echoWords[1] ¬ (packetNumber ¬ packetNumber + 1);        Socket.PutPacket[mySoc, b]; sent ¬ sent + 1;        Process.Yield[];  -- be sure we don't hog machine	BEGIN        b ¬ Socket.GetPacket[mySoc ! Socket.TimeOut => GOTO late];	SELECT TRUE FROM	  (b.ns.packetType # echo) =>	    {funny ¬ funny + 1; PrintErrorNS[b]};	  (b.ns.echoWords[0] # packetNumber) => {WriteChar['#]; late ¬ late + 1};	  (b.ns.echoWords[1] # packetNumber) => {WriteChar['#]; late ¬ late + 1};	  (len # Socket.GetPacketBytes[b]) => {WriteChar['#]; late ¬ late + 1};	  ENDCASE =>	    FOR i: CARDINAL IN [4..len - 4) DO	      IF b.ns.echoBytes[i] # (i MOD 400B) THEN		{wrong ¬ wrong + 1; WriteChar['~]; EXIT};	      REPEAT FINISHED => {WriteChar['!]; recv ¬ recv + 1};	      ENDLOOP;	NSBuffer.ReturnBuffer[b];	EXITS late => {WriteChar['?]; late ¬ late + 1};	END;        ENDLOOP;      NewLine[];      ENDLOOP;    Socket.Delete[mySoc];    WriteString["Out: "L];    WriteLongNumber[sent];    WriteString[", In: "L];    WriteLongNumber[recv];    WriteString[" ("L];    WriteLongNumber[(recv*100)/sent];    WriteLine["%)"L];    IF late # 0 THEN {      WriteString["Late: "L]; WriteLongNumber[late];      WriteString[" ("L]; WriteLongNumber[(late*100)/sent]; WriteLine["%)"L]};    IF funny # 0 THEN {WriteLongNumber[funny]; WriteLine[" funny"L]};    IF wrong # 0 THEN {WriteLongNumber[wrong]; WriteLine[" wrong data"L]};    END;  PrintLocalRoutingTable: PROC =    BEGIN    string: STRING ¬ [20];    net: System.NetworkNumber;    Router.FillRoutingTable[Router.infinity];  --load 'em up    Process.Pause[Process.SecondsToTicks[2]];    FOR hop: CARDINAL IN[0..Router.infinity] DO      net ¬ Router.EnumerateRoutingTable[Router.startEnumeration, hop];      IF net = Router.endEnumeration THEN LOOP;  --don't print empties      WriteString["Networks "L];      WriteLongNumber[LONG[hop]];      WriteString[" hops away = {"L];      UNTIL net = Router.endEnumeration DO	ExtendedString.AppendNumber[@net, SIZE[System.NetworkNumber], 8, string];	WriteString[string]; string.length ¬ 0; WriteChar['B];        net ¬ Router.EnumerateRoutingTable[net, hop];	IF net # Router.endEnumeration THEN WriteString[", "L];	ENDLOOP;      WriteChar['}];      NewLine[];      ENDLOOP;    Router.FillRoutingTable[0];  --shut down the table    END;  --PrintLocalRoutingTable  PrintNSAddress: PROC [a: POINTER TO System.NetworkAddress] =    BEGIN    buffer: STRING ¬ [50];    ExtendedString.AppendNumber[@a.net, SIZE[System.NetworkNumber], 8, buffer];    buffer[buffer.length] ¬ '.; buffer.length ¬ buffer.length + 1;    ExtendedString.AppendNumber[@a.host, SIZE[System.HostNumber], 8, buffer];    buffer[buffer.length] ¬ '.; buffer.length ¬ buffer.length + 1;    ExtendedString.AppendNumber[@a.socket, SIZE[System.SocketNumber], 8, buffer];    WriteString[buffer];    END;  echoName: LONG STRING ¬ NIL;  Commands: PROC [index: CARDINAL] = {    SELECT index FROM      0 => {        MyNameIs[	  myNameIs: "Echo User"L,	  myHelpIs: "Echo user"L];	EchoUser[]};      1 => {        MyNameIs[	  myNameIs: "Routing Tables"L,	  myHelpIs: "Show NS network routing tables"L];	PrintLocalRoutingTable[]};      ENDCASE => IndexTooLarge};     commandProcessor: CommandProcessor ¬ [Commands];  -- initialization  RegisterCommandProc[@commandProcessor];  END.....
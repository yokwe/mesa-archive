-- Copyright (C) 1984, 1985, 1986  by Xerox Corporation. All rights reserved. -- FloppyEditIOSW.mesa  last edited: 24-Apr-86 10:13:52  by: CAJ-- This module implements I/O and the subwindow which contains parameters and commands for doing I/O for the floppy disk editor.DIRECTORY  Environment USING [PageCount, wordsPerPage],  FloppyChannel USING [    DiskAddress, Drive, Error, GetNextDrive, HeadCount, Nop, nullDrive,    ReadSectors, SectorCount, Status, WriteDeletedSectors, WriteSectors],  FloppyEditInternal USING [    ContextMatchesContextInEffect, data, DiskAddressToSectorNumber, heap,    InvalidateHandle, maxSectorWords, Msg, SectorBuffer,    SectorNumberToDiskAddress, SectorWords, swapWindowKey, ValidateDiskAddress,    ValidateSectorNumber],  FloppyFormat USING [nullSector, Sector],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType, CommandItem,    Display, DisplayItem, Enumerated, EnumeratedItem, line0, line1, line2, line3,    line4, line5, line6, line7, NumberItem, NumberNotifyProcType, ProcType,    StringItem, TagOnlyItem],  MsgSW USING [Clear],  Process USING [Yield],  RuntimeInternal USING [Bug],  Space USING [PageFromLongPointer, PagesFromWords, ScratchMap, Unmap],  String USING [AppendString, FreeString, MakeString],  System USING [GetGreenwichMeanTime, GreenwichMeanTime],  VM USING [Interval, MakeResident, MakeSwappable],  WindowSwap USING [    CurrentViewHandle, Error, UpdateDataFromView, UpdateViewFromData];FloppyEditIOSW: PROGRAM  IMPORTS    FloppyChannel, FloppyEditInternal, FormSW, MsgSW, Process, RuntimeInternal,    Space, String, System, VM, WindowSwap  EXPORTS FloppyEditInternal =  BEGIN  --//////////////////  -- Local TYPEs and variables  DiskOrSector: TYPE = {diskAddress, sectorNumber};  FormItems: TYPE = {    drive, verboseStatus, writesDisallowed, sectorNumber, diskAddress, cylinder,    head, sector, convert, diskToSector, sectorToDisk, use, ioCommand, retryCount,    terminationCondition, doit, completionStatus};  IOCommand: TYPE = {read, statusOnly, write, writeDeleted};  IOData: TYPE = LONG POINTER TO IODataObject;  IODataObject: TYPE = MACHINE DEPENDENT RECORD [    -- Note: Fill words are inserted to force word boundaries for each item.    driveIndex(0): FloppyChannel.Drive ¬ 0,    verboseStatus(1): BOOLEAN ¬ TRUE,    sectorNumber(2): FloppyFormat.Sector ¬ 0,    cylinder(3): CARDINAL ¬ 0,    head(4): FloppyChannel.HeadCount ¬ 0,    sector(5): FloppyChannel.SectorCount ¬ 0,    useDiskOrSector(6): DiskOrSector ¬ diskAddress,    ioCommand(7): IOCommand ¬ read,    retryCount(8): CARDINAL ¬ 0,    terminationCondition(9): TerminationCondition ¬ goodCompletion,    completionStatus(10): LONG STRING ¬ NIL];  TerminationCondition: TYPE = {goodCompletion, failure};  ioData: IOData ¬ NIL;  ioInProgress: BOOLEAN;  sectorBuffer: FloppyEditInternal.SectorBuffer ¬ NIL;  --//////////////////  -- Errors  BugType: TYPE = {impossibleEndcase, impossibleStatus, noHeap};  Bug: PROCEDURE [bug: BugType] = {RuntimeInternal.Bug[bug]};  --//////////////////  -- Procedures  ConvertDiskAddressToSectorNumber: FormSW.ProcType =    BEGIN    -- No sector/address rationality checks here: checked when I/O attempted    s: FloppyFormat.Sector;    MsgSW.Clear[FloppyEditInternal.data.msgSW];    s ¬ FloppyEditInternal.DiskAddressToSectorNumber[GetDiskAddress[]];    IF s = FloppyFormat.nullSector THEN FloppyEditInternal.Msg["No disk."L, TRUE]    ELSE      BEGIN      ioData.sectorNumber ¬ s;      FormSW.DisplayItem[sw, FormItems.sectorNumber.ORD];      END;    END;  -- ConvertDiskAddressToSectorNumber  ConvertSectorNumberToDiskAddress: FormSW.ProcType =    BEGIN    -- No sector/address rationality checks here: checked when I/O attempted    d: FloppyChannel.DiskAddress;    MsgSW.Clear[FloppyEditInternal.data.msgSW];    d ¬ FloppyEditInternal.SectorNumberToDiskAddress[ioData.sectorNumber];    IF d.sector = 0 THEN FloppyEditInternal.Msg["No disk."L, TRUE]    ELSE      BEGIN      ioData.cylinder ¬ d.cylinder;      ioData.head ¬ d.head;      ioData.sector ¬ d.sector;      FormSW.DisplayItem[sw, FormItems.cylinder.ORD];      FormSW.DisplayItem[sw, FormItems.head.ORD];      FormSW.DisplayItem[sw, FormItems.sector.ORD];      END;    END;  -- ConvertSectorNumberToDiskAddress  DoIO: FormSW.ProcType =    BEGIN    ENABLE WindowSwap.Error => IF type = noSuchKey THEN CONTINUE;    -- Keep going if trying to do I/O before views fully registered. In this case,    -- display will be updated in process of painting new view.    Error: TYPE = {      none, contextMismatch, invalidHandle, invalidDiskAddr, invalidSector,      notImplemented, notReady, writesDisallowed};    code: Error ¬ none;    BEGIN  -- scope of Error    ENABLE FloppyChannel.Error => IF type = invalidHandle THEN GOTO invalidHandle;    status: FloppyChannel.Status;    MsgSW.Clear[FloppyEditInternal.data.msgSW];    ioInProgress ¬ TRUE;    ioData.completionStatus.length ¬ 0;    FormSW.DisplayItem[sw, FormItems.completionStatus.ORD];    status ¬ FloppyChannel.Nop[FloppyEditInternal.data.handle];    SELECT ioData.ioCommand FROM      statusOnly =>        IF status = diskChange THEN FloppyEditInternal.InvalidateHandle[];      read, write, writeDeleted =>        BEGIN        bufferInterval: VM.Interval;        countDone: CARDINAL ¬ 0;        dAddr: FloppyChannel.DiskAddress;        IF ioData.ioCommand ~= read AND FloppyEditInternal.data.writesDisallowed          THEN {code ¬ writesDisallowed; GOTO aborted};        bufferInterval ¬ [          Space.PageFromLongPointer[sectorBuffer], Space.PagesFromWords[          FloppyEditInternal.SectorWords[]]];        IF status = notReady THEN {code ¬ notReady; GOTO aborted};        IF ~FloppyEditInternal.ContextMatchesContextInEffect[] THEN {          code ¬ contextMismatch; GOTO aborted};        IF ioData.useDiskOrSector = sectorNumber THEN          BEGIN          IF ~FloppyEditInternal.ValidateSectorNumber[ioData.sectorNumber] THEN {            code ¬ invalidSector; GOTO aborted};          dAddr ¬ FloppyEditInternal.SectorNumberToDiskAddress[            ioData.sectorNumber];          END        ELSE  -- diskAddress          BEGIN          dAddr ¬ GetDiskAddress[];          IF ~FloppyEditInternal.ValidateDiskAddress[dAddr] THEN {            code ¬ invalidDiskAddr; GOTO aborted};          END;        IF ioData.ioCommand = write THEN          WindowSwap.UpdateDataFromView[FloppyEditInternal.swapWindowKey];        VM.MakeResident[bufferInterval, wait];        THROUGH [0..ioData.retryCount] DO          SELECT ioData.ioCommand FROM            read =>              [status, countDone] ¬ FloppyChannel.ReadSectors[                handle: FloppyEditInternal.data.handle, address: dAddr,                buffer: sectorBuffer, count: 1, incrementDataPtr: FALSE];            write =>              [status, countDone] ¬ FloppyChannel.WriteSectors[                handle: FloppyEditInternal.data.handle, address: dAddr,                buffer: sectorBuffer, count: 1, incrementDataPtr: FALSE];            writeDeleted =>              [status, countDone] ¬ FloppyChannel.WriteDeletedSectors[                handle: FloppyEditInternal.data.handle, address: dAddr,                buffer: sectorBuffer, count: 1, incrementDataPtr: FALSE];            ENDCASE => Bug[impossibleEndcase];          IF            (ioData.terminationCondition = TerminationCondition[goodCompletion]              AND (status = goodCompletion))            OR              (ioData.terminationCondition = TerminationCondition[failure]                AND (status ~= goodCompletion)) THEN EXIT;          ENDLOOP;        VM.MakeSwappable[bufferInterval];        IF ioData.ioCommand = read THEN          BEGIN          WindowSwap.UpdateViewFromData[FloppyEditInternal.swapWindowKey];          FormSW.Display[            WindowSwap.CurrentViewHandle[FloppyEditInternal.swapWindowKey]];          END;        END;      ENDCASE => {code ¬ notImplemented; GOTO aborted};    PostStatus[status];    ioInProgress ¬ FALSE;    EXITS      aborted =>        BEGIN        FloppyEditInternal.Msg[          string:          SELECT code FROM            contextMismatch => "Context shown ~= context last set."L,            invalidDiskAddr => "Invalid disk address."L,            invalidSector => "Invalid sector number."L,            notImplemented => "Function not implemented."L,            notReady => "Drive not ready."L,            writesDisallowed => "Writes disallowed."L,            ENDCASE => NIL, blink: TRUE];        ioInProgress ¬ FALSE;        END;      invalidHandle =>        BEGIN        FloppyEditInternal.Msg[string: "Invalid handle."L, blink: TRUE];        FloppyEditInternal.InvalidateHandle[];        ioInProgress ¬ FALSE;        END;    END;  -- scope of Error    END;  -- DoIO  GetDiskAddress: PROCEDURE RETURNS [FloppyChannel.DiskAddress] = INLINE {    RETURN[      [cylinder: ioData.cylinder, head: ioData.head, sector: ioData.sector]]};  GetDrive: PUBLIC PROCEDURE RETURNS [drive: FloppyChannel.Drive] =    BEGIN    drive ¬ FloppyChannel.nullDrive;    THROUGH [0..ioData.driveIndex] DO      drive ¬ FloppyChannel.GetNextDrive[drive] ENDLOOP;    END;  -- Set up I/O at tool activation  InitIO: PUBLIC PROCEDURE =    BEGIN    -- InitIO precedes InitContext.    -- If there is separate I/O process, set it up here.    statusStringLength: CARDINAL = 30;    IF FloppyEditInternal.data = NIL THEN Bug[noHeap];    FloppyEditInternal.data.ioData ¬ ioData ¬ FloppyEditInternal.heap.NEW[      IODataObject];    -- Stash the ioData pointer in the tool data object so deactivate can free it.    ioData.completionStatus ¬ String.MakeString[      FloppyEditInternal.heap, statusStringLength];    FloppyEditInternal.data.sectorBuffer ¬ sectorBuffer ¬ Space.ScratchMap[      Space.PagesFromWords[FloppyEditInternal.maxSectorWords]];    ioInProgress ¬ FALSE;    END;  -- InitIO  MakeIOSW: PUBLIC FormSW.ClientItemsProcType =    BEGIN OPEN FSW: FormSW;    nItems: CARDINAL = FormItems.LAST.ORD + 1;    use: ARRAY [0..2) OF FSW.Enumerated ¬ [      ["disk address"L, 0], ["sector number"L, 1]];    ioCommand: ARRAY [0..4) OF FSW.Enumerated ¬ [      ["read"L, IOCommand[read]], ["statusOnly"L, IOCommand[statusOnly]], [      "write"L, IOCommand[write]], ["writeDeleted"L, IOCommand[writeDeleted]]];    terminationCondition: ARRAY [0..2) OF FSW.Enumerated ¬ [      ["goodCompletion"L, TerminationCondition[goodCompletion]], [      "failure"L, TerminationCondition[failure]]];    items ¬ FSW.AllocateItemDescriptor[nItems];    items[FormItems.drive.ORD] ¬ FSW.NumberItem[      tag: "Drive "L, place: [0, FSW.line0], signed: FALSE, notNegative: TRUE,      proc: SetDrive, default: 0, value: @ioData.driveIndex];    items[FormItems.verboseStatus.ORD] ¬ FSW.BooleanItem[      tag: "Verbose status"L, place: [180, FSW.line0],      switch: @ioData.verboseStatus];    items[FormItems.writesDisallowed.ORD] ¬ FSW.BooleanItem[      tag: "Writes disallowed"L, place: [320, FSW.line0],      switch: @FloppyEditInternal.data.writesDisallowed];    items[FormItems.sectorNumber.ORD] ¬ FSW.NumberItem[      tag: "Sector number "L, place: [0, FSW.line1], signed: FALSE,      notNegative: TRUE, default: 0, value: @ioData.sectorNumber];    items[FormItems.diskAddress.ORD] ¬ FSW.TagOnlyItem[      tag: "Disk Address:"L, place: [0, FSW.line2]];    items[FormItems.cylinder.ORD] ¬ FSW.NumberItem[      tag: "Cylinder "L, place: [96, FSW.line2], signed: FALSE, notNegative: TRUE,      default: 0, value: @ioData.cylinder];    items[FormItems.head.ORD] ¬ FSW.NumberItem[      tag: "Head "L, place: [221, FSW.line2], signed: FALSE, notNegative: TRUE,      default: 0, value: @ioData.head];    items[FormItems.sector.ORD] ¬ FSW.NumberItem[      tag: "Sector "L, place: [325, FSW.line2], signed: FALSE, notNegative: TRUE,      default: 0, value: @ioData.sector];    items[FormItems.convert.ORD] ¬ FSW.TagOnlyItem[      tag: "Convert..."L, place: [0, FSW.line3]];    items[FormItems.diskToSector.ORD] ¬ FSW.CommandItem[      tag: "Disk address -> sector number"L, place: [85, FSW.line3],      proc: ConvertDiskAddressToSectorNumber];    items[FormItems.sectorToDisk.ORD] ¬ FSW.CommandItem[      tag: "Sector number -> disk address"L, place: [290, FSW.line3],      proc: ConvertSectorNumberToDiskAddress];    items[FormItems.use.ORD] ¬ FSW.EnumeratedItem[      tag: "Use"L, place: [0, FSW.line4], feedback: all, choices: DESCRIPTOR[use],      value: @ioData.useDiskOrSector];    items[FormItems.ioCommand.ORD] ¬ FSW.EnumeratedItem[      tag: "I/O Command"L, place: [0, FSW.line5], feedback: all,      choices: DESCRIPTOR[ioCommand], value: @ioData.ioCommand];    items[FormItems.retryCount.ORD] ¬ FSW.NumberItem[      tag: "Retry count "L, place: [345, FSW.line5], signed: FALSE,      notNegative: TRUE, default: 1, value: @ioData.retryCount];    items[FormItems.terminationCondition.ORD] ¬ FSW.EnumeratedItem[      tag: "Termination condition"L, place: [0, FSW.line6], feedback: all,      choices: DESCRIPTOR[terminationCondition],      value: @ioData.terminationCondition];    items[FormItems.doit.ORD] ¬ FSW.CommandItem[      tag: "Do it"L, place: [315, FSW.line6], drawBox: TRUE, proc: DoIO];    items[FormItems.completionStatus.ORD] ¬ FSW.StringItem[      tag: "Completion status"L, place: [0, FSW.line7], readOnly: TRUE,      inHeap: FALSE, string: @ioData.completionStatus];    RETURN[items: items, freeDesc: TRUE];    END;  -- MakeIOSW  PostStatus: PROCEDURE [s: FloppyChannel.Status] =    BEGIN    -- string length known to be 0;    String.AppendString[      ioData.completionStatus,      SELECT s FROM        goodCompletion => "goodCompletion"L,        diskChange => "diskChange"L,        notReady => "notReady"L,        cylinderError => "cylinderError"L,        deletedData => "deletedData"L,        recordNotFound => "recordNotFound"L,        headerError => "headerError"L,        dataError => "dataError"L,        dataLost => "dataLost"L,        writeFault => "writeFault"L,        otherError => "otherError"L,        ENDCASE => "Bug[bogusError]"L];    FormSW.DisplayItem[      FloppyEditInternal.data.ioSW, FormItems.completionStatus.ORD];    END;  -- PostStatus  SetDrive: FormSW.NumberNotifyProcType =    -- [sw: Window.Handle, item: FormSW.ItemHandle, index: CARDINAL,    -- oldValue: UNSPECIFIED]    BEGIN    -- No checking for reasonable/present drive until actual access is attempted.    IF ioInProgress THEN WaitIOCompletion[];    FloppyEditInternal.InvalidateHandle[];    END;  -- SetDrive  ShutdownIO: PUBLIC PROCEDURE =    -- Wind down I/O and clean up this module's data allocations.    BEGIN    IF ioInProgress THEN      BEGIN      FloppyEditInternal.Msg["Waiting for I/O completion..."L, FALSE];      WaitIOCompletion[];      IF ioInProgress THEN FloppyEditInternal.Msg["Aborting."L, FALSE];      END;    IF ioData.completionStatus ~= NIL THEN      String.FreeString[FloppyEditInternal.heap, ioData.completionStatus];    [] ¬ Space.Unmap[sectorBuffer];    FloppyEditInternal.data.sectorBuffer ¬ NIL;    -- If there is separate I/O process, make it complete (state?).    END;  -- ShutdownIO  WaitIOCompletion: PROCEDURE =    -- Wait for I/O completion or timeout, whichever occurs first.    BEGIN    maxWait: System.GreenwichMeanTime = [60];  -- seconds, arbitrary    timeout: System.GreenwichMeanTime ¬ [System.GetGreenwichMeanTime[] + maxWait];    WHILE ioInProgress DO      IF System.GetGreenwichMeanTime[] > timeout THEN EXIT;      Process.Yield;      ENDLOOP;    END;  -- WaitIOCompletion  END...LOG24-Sep-84 18:02:10   CAJ	Created file.15-May-85 13:22:05   CAJ	Handle I/O before views finished registering.24-Apr-86  9:29:19   CAJ	Implement SetDrive.
-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- PilotTests>PhysicalVolumeCommands.mesa    5-Feb-87 12:38:03 by CJS   DIRECTORY  Ascii USING [CR, SP],  Command USING [Action, Catch, Entry, InstallTopLevel, Loop, QuitLevel, Scan],  Device USING [nullType, Type],  DeviceTypes,  PhysicalVolume USING [    AssertNotAPilotVolume, AssertPilotVolume, AwaitStateChange,    CreatePhysicalVolume, FinishWithNonPilotVolume, GetAttributes,    GetContainingPhysicalVolume, GetHandle, GetHints, GetNext,     GetNextBadPage, GetNextDrive, GetNextLogicalVolume, Handle, ID,     InterpretHandle, IsReady, Layout, MarkPageBad, maxNameLength,     nullBadPage, nullDeviceIndex, nullID, Offline, PageNumber,     VolumeType],  PilotCommand USING [    currentPhysicalVolumeID,defaultWindow, GetVIDCur, SetVIDCur, StorageCatch,    StringToUID, UIDToString],  String USING [    AppendChar, AppendLongNumber, AppendNumber, AppendOctal, AppendString,    AppendSubString, EquivalentStrings, EquivalentSubStrings, InvalidNumber,    StringToDecimal, StringToLongNumber, StringToNumber, StringToOctal, SubString,    SubStringDescriptor],  System USING [nullID, UniversalID],  TTY USING [    CharStatus, GetString, Handle, NewLine, PutChar, PutLongNumber, PutNumber,    PutString],  Volume USING [ID, maxNameLength];PhysicalVolumeCommands: PROGRAM  IMPORTS Command, PhysicalVolume, PilotCommand, String, TTY  EXPORTS PilotCommand =  BEGIN  tty: TTY.Handle = PilotCommand.defaultWindow;  entries: ARRAY [0..26) OF Command.Entry ¬ [    ["commands", CmdLoop],  -- must be first    ["Assert not a Pilot volume", CmdAssertNotPilot],    ["Assert Pilot volume", CmdAssertPilot],    ["Await state change", CmdAwaitStateChange],    ["Create physical volume", CmdCreatePhysicalVolume],    ["Current", CmdCurrentVars],    ["Finish with non-Pilot volume", CmdFinishWithNonPilotVolume],    ["Forcefully Set Handle", CmdForceSetHandle],    ["Forcefully Set Physical Volume ID", CmdForceSetPhysicalVolume],    ["Get attributes", CmdGetAttributes],    ["Get containing physical volume", CmdGetContainingPhysicalVolume],    ["Get handle", CmdGetHandle],    ["Get hints", CmdGetHints],    ["Get next bad page", CmdGetNextBadPage],    ["Get next drive", CmdGetNextDrive],    ["Get next logical volume", CmdGetNextLogicalVolume],    ["Get next physical volume", CmdGetNextPhysicalVolume],    ["Help", CmdHelp],    ["Interpret handle", CmdInterpretHandle],    ["Is ready?", CmdIsReady],    ["Mark page bad", CmdMarkPageBad],    ["Offline", CmdOffline],    ["Set current bad page", CmdSetCurrentBadPage],    ["Set current device", CmdSetCurrentDevice],    ["Set current physical volume", CmdSetCurrentPhysicalVolume],    ["quit", Command.QuitLevel]  -- must be last    ];  DeviceDescriptor: TYPE = RECORD [name: LONG STRING, type: Device.Type];  -- in the following table, "abreviations", e.g. Fp, should be first  -- so things such as Fp0  -- print as "Fp0" and not as "SA8000"  deviceTable: ARRAY [0..15) OF DeviceDescriptor = [    ["Rd",      DeviceTypes.anyPilotDisk],    ["SA1000",  DeviceTypes.sa1000],    ["SA1004",  DeviceTypes.sa1004],    ["SA4000",  DeviceTypes.sa4000],    ["SA4008",  DeviceTypes.sa4008],    ["T80",     DeviceTypes.t80],    ["T300",    DeviceTypes.t300],    ["CDC9730", DeviceTypes.cdc9730],    ["Q2000",      DeviceTypes.q2000],    ["Q2010",      DeviceTypes.q2010],    ["Q2020",      DeviceTypes.q2020],    ["Q2030",      DeviceTypes.q2030],    ["Q2040",      DeviceTypes.q2040],    ["Null",    Device.nullType],    ["Nil",     Device.nullType]];  stringSize: CARDINAL = MAX[    Volume.maxNameLength,  -- for volume names    PhysicalVolume.maxNameLength,  -- for physical volume names    1 + (SIZE[System.UniversalID] - 1)*8 + 6 + 1];  -- to hold one full sized UID  currentDeviceOrdinal: CARDINAL ¬ PhysicalVolume.nullDeviceIndex;  currentHandle: PhysicalVolume.Handle;  currentPhysicalVolumeID:  PUBLIC PhysicalVolume.ID ¬ PhysicalVolume.nullID;  currentBadPage: PhysicalVolume.PageNumber ¬ PhysicalVolume.nullBadPage;  currentPhysicalVolumeName: LONG STRING ¬ [stringSize];  currentChangeCount: CARDINAL ¬ 0;  PhysicalVolumeCmd: Command.Action =    BEGIN    TTY.PutChar[h, ' ];    Command.Scan[      h, DESCRIPTOR[BASE[entries], LENGTH[entries] - 1],      PilotCommand.StorageCatch]    END;  CmdLoop: Command.Action =    BEGIN    Command.Loop[      h, DESCRIPTOR[@entries[1], LENGTH[entries] - 1], PilotCommand.StorageCatch,      "physical volume "L]    END;  CmdAssertNotPilot: Command.Action = {    PhysicalVolume.AssertNotAPilotVolume[currentHandle]};  CmdAssertPilot: Command.Action =    BEGIN    PilotCommand.currentPhysicalVolumeID ¬       PhysicalVolume.AssertPilotVolume[currentHandle];    UIDToString[PilotCommand.currentPhysicalVolumeID, currentPhysicalVolumeName];    TTY.PutChar[h, Ascii.CR];    TTY.PutString[h, "  is volume "L];    TTY.PutString[h, currentPhysicalVolumeName];    END;  CmdAwaitStateChange: Command.Action =    BEGIN    changeCount: CARDINAL ¬ GetChangeCount[h];    deviceOrdinal: CARDINAL ¬ GetDeviceOrdinal[h];    currentChangeCount ¬ PhysicalVolume.AwaitStateChange[      changeCount, deviceOrdinal];    TTY.PutChar[h, Ascii.CR];    TTY.PutString[h, " Returned change count is "L];    PutNumber[h, currentChangeCount, 10];    END;  CmdCreatePhysicalVolume: Command.Action =    BEGIN    PilotCommand.currentPhysicalVolumeID ¬ PhysicalVolume.CreatePhysicalVolume[      currentHandle, GetNewPhysicalVolumeName[h]];    TTY.PutString[h, " Created with ID "L];    PutPhysicalVolumeID[h, PilotCommand.currentPhysicalVolumeID];    END;    CmdCurrentVars: Command.Action =    BEGIN    TTY.PutString[h, " Physical volume ID is "L];    PutPhysicalVolumeID[h, PilotCommand.currentPhysicalVolumeID];    TTY.PutChar[h, Ascii.CR];    TTY.PutString[h, "  Drive is "L];    PutDriveName[h, currentDeviceOrdinal];    TTY.PutString[h, ".  Bad page is "L];    IF currentBadPage = PhysicalVolume.nullBadPage THEN      TTY.PutString[h, "null "L]    ELSE       PutLongNumber[h, currentBadPage, 10];    END;    CmdFinishWithNonPilotVolume: Command.Action =    BEGIN PhysicalVolume.FinishWithNonPilotVolume[currentHandle]; END;  CmdForceSetHandle: Command.Action =    BEGIN    prompt: ARRAY [0..SIZE[PhysicalVolume.Handle]) OF LONG STRING = [      " Word 0: "L, "Word 1: "L, "Word 2: "L];    handleRep: LONG POINTER TO ARRAY [0..SIZE[PhysicalVolume.Handle]) OF WORD =      LOOPHOLE[@currentHandle];    FOR i: CARDINAL IN [0..SIZE[PhysicalVolume.Handle]) DO      handleRep[i] ¬ GetNumber[h, prompt[i], handleRep[i], 0, 8]; ENDLOOP;    END;  CmdForceSetPhysicalVolume: Command.Action =    BEGIN    TTY.PutString[h, "ID: "L];    TTY.GetString[h, currentPhysicalVolumeName, Terminator];    PilotCommand.currentPhysicalVolumeID ¬ LOOPHOLE[PilotCommand.StringToUID[      currentPhysicalVolumeName].id];    END;  CmdGetAttributes: Command.Action =    BEGIN    label: LONG STRING ¬ [stringSize];    layout: PhysicalVolume.Layout;    [currentHandle, layout] ¬ PhysicalVolume.GetAttributes[      PilotCommand.currentPhysicalVolumeID, label];    IF ~TTY.NewLine[h] THEN TTY.PutChar[h, Ascii.CR];    TTY.PutString[h, "   Has "L];    TTY.PutString[      h,      SELECT layout FROM        = partialLogicalVolume => "part of a logical volume on it"L,        = singleLogicalVolume => "a single, whole logical volume on it"L,        = multipleLogicalVolumes => "multiple logical volumes on it"L,	= empty => "no logical volumes on it"L,        ENDCASE => "an unknown layout"L];    TTY.PutChar[h, Ascii.CR];    TTY.PutString[h, "   Label is: "L];    TTY.PutString[h, label];    END;  CmdGetContainingPhysicalVolume: Command.Action =    BEGIN    PilotCommand.currentPhysicalVolumeID ¬ PhysicalVolume.GetContainingPhysicalVolume[      PilotCommand.GetVIDCur[]];    TTY.PutString[h, " is contained on physical volume "L];    PutPhysicalVolumeID[h, PilotCommand.currentPhysicalVolumeID];    END;  CmdGetHandle: Command.Action =    BEGIN    currentHandle ¬ PhysicalVolume.GetHandle[currentDeviceOrdinal];    END;  CmdGetHints: Command.Action =    BEGIN    label: STRING ¬ [stringSize];    id: PhysicalVolume.ID;    type: PhysicalVolume.VolumeType;    [id, type] ¬ PhysicalVolume.GetHints[currentHandle, label];    IF ~TTY.NewLine[h] THEN TTY.PutChar[h, Ascii.CR];    TTY.PutString[h, " ID: "L];    PutPhysicalVolumeID[h, id];    TTY.PutString[      h,      SELECT type FROM        = notPilot => " is not a Pilot volume"L,        = probablyNotPilot => "is probably not a Pilot volume"L,        = probablyPilot => "is probably a Pilot volume"L,        = isPilot => "is a Pilot volume"L        ENDCASE => ERROR];    TTY.PutChar[h, Ascii.CR];    TTY.PutString[h, "Label is: "L];    TTY.PutString[h, label];    END;  CmdGetNextBadPage: Command.Action =    BEGIN    currentBadPage ¬ PhysicalVolume.GetNextBadPage[      PilotCommand.currentPhysicalVolumeID, currentBadPage];    TTY.PutChar[h, ' ];    IF currentBadPage = PhysicalVolume.nullBadPage THEN      TTY.PutString[h, " null "L]    ELSE      PutLongNumber[h, currentBadPage, 10];    END;  CmdGetNextDrive: Command.Action =    BEGIN    [currentDeviceOrdinal] ¬ PhysicalVolume.GetNextDrive[      currentDeviceOrdinal];    PutDriveName[h, currentDeviceOrdinal];    END;      CmdGetNextLogicalVolume: Command.Action =    BEGIN    PilotCommand.SetVIDCur[      PhysicalVolume.GetNextLogicalVolume[      PilotCommand.currentPhysicalVolumeID, PilotCommand.GetVIDCur[]]];    TTY.PutChar[h, ' ];    PutLogicalVolumeID[h, PilotCommand.GetVIDCur[]];    END;  CmdGetNextPhysicalVolume: Command.Action =    BEGIN    PilotCommand.currentPhysicalVolumeID ¬ PhysicalVolume.GetNext[PilotCommand.currentPhysicalVolumeID];    TTY.PutChar[h, ' ];    PutPhysicalVolumeID[h, PilotCommand.currentPhysicalVolumeID];    END;  CmdHelp: Command.Action =    BEGIN    TTY.PutString[      h,      "Commands are:Assert not a Pilot volume           Asserts volume on current handle as non-PilotAssert Pilot volume                 Asserts volume on current handle as PilotAwait state change                  Waits until the change count on a (set of) drives changesCreate physical volume              Creates a new physical volumeCurrent                             Prints current state of Physical Volume commandFinish with non-Pilot volume        Terminates non-Pilot access to a physical volumeForcefully Set handle               Set current handle. No validity checking on the handleForcefully Set Physical Volume ID   Set current physical volume ID. No validity checking on the IDGet attributes                      Gets attributes of a Pilot physical volumeGet containing physical volume      Get physical volume containing a logical volumeGet handle                          Get a handle for a specified driveGet hints			    Get hints on whether physical volume is a Pilot volume or notGet next bad page                   Enumerate bad pages on a Pilot physical volumeGet next drive                      Enumerate the drives on the system elementGet next logical volume             Enumerates the logical volumes on a Pilot physical volume"L];    TTY.PutString[      h,"Get next physical volume            Enumerates the physical volumes currently known to PilotInterpret handle                    Get a device type and ordinal from the current handleIs ready                            Determine if a drive is readyMark page bad                       Mark a page on a Pilot physical volume as badOffline                             Take a Pilot physical volume offlineSet current device/                 Set corresponding field     physical volume/                (checked for validity)      bad page                        quit                                Returns to top level"L]    END;  CmdInterpretHandle: Command.Action =    BEGIN    currentDeviceType: Device.Type;    [currentDeviceType, currentDeviceOrdinal] ¬ PhysicalVolume.InterpretHandle[      currentHandle];    TTY.PutString[h, " Current handle is for drive "L];    PutDriveNameAndType[h, currentDeviceType, currentDeviceOrdinal];    END;  CmdIsReady: Command.Action =    BEGIN    ready: BOOLEAN = PhysicalVolume.IsReady[currentHandle];    TTY.PutString[h, " The drive referred to by the current handle is "L];    TTY.PutString[tty, IF ready THEN "ready"L ELSE "not ready"L];    END;  CmdMarkPageBad: Command.Action =    BEGIN    PhysicalVolume.MarkPageBad[PilotCommand.currentPhysicalVolumeID, currentBadPage];    END;  CmdOffline: Command.Action =    BEGIN PhysicalVolume.Offline[PilotCommand.currentPhysicalVolumeID]; END;  CmdSetCurrentBadPage: Command.Action = BEGIN [] ¬ GetBadPage[h]; END;  CmdSetCurrentDevice: Command.Action =    BEGIN [] ¬ GetDeviceOrdinal[h]; END;  CmdSetCurrentPhysicalVolume: Command.Action =    BEGIN [] ¬ GetPhysicalVolumeID[h]; END;  -- The following are exported to PilotCommand  GetDeviceCur: PUBLIC PROCEDURE RETURNS [index: CARDINAL] = {    RETURN[currentDeviceOrdinal]; };  GetPVIDCur: PUBLIC PROCEDURE RETURNS [PhysicalVolume.ID] = {    RETURN[PilotCommand.currentPhysicalVolumeID]};  ReadDeviceCur: PUBLIC PROCEDURE [h: TTY.Handle] = {    [] ¬ GetDeviceOrdinal[h]; };  ReadPVIDCur: PUBLIC PROCEDURE [h: TTY.Handle] = {[] ¬ GetPhysicalVolumeID[h]; };  SetDeviceCur: PUBLIC PROCEDURE [index: CARDINAL] =    BEGIN currentDeviceOrdinal ¬ index; END;  SetPVIDCur: PUBLIC PROCEDURE [id: PhysicalVolume.ID] =    BEGIN    PilotCommand.currentPhysicalVolumeID ¬ id;    PilotCommand.UIDToString[id, currentPhysicalVolumeName];    END;  StringToUID: PUBLIC PROCEDURE [s: LONG STRING]    RETURNS [valid: BOOLEAN, id: System.UniversalID] =    BEGIN    currentNumber: STRING ¬ [stringSize];    startPos: CARDINAL;    curPos: CARDINAL;    len: CARDINAL;    subStringDesc: String.SubStringDescriptor;    subString: String.SubString ¬ @subStringDesc;    p: POINTER TO ARRAY [0..SIZE[System.UniversalID]) OF UNSPECIFIED =      LOOPHOLE[@id];    valid ¬ TRUE;    -- Skip over any leading characters that are not octal digits    FOR startPos IN [0..s.length) DO      IF s[startPos] IN ['0..'7] THEN EXIT;      REPEAT FINISHED => GO TO nullReturn;  -- a bogus UID was given      ENDLOOP;    FOR word: [0..SIZE[System.UniversalID]) IN [0..SIZE[System.UniversalID]) DO      -- parse each word      curPos ¬ startPos;      WHILE s[curPos] IN ['0..'7] DO curPos ¬ curPos + 1; ENDLOOP;      IF s[curPos] = 'B OR s[curPos] = 'b THEN len ¬ curPos - startPos + 1      ELSE len ¬ curPos - startPos;      currentNumber.length ¬ 0;      subString­ ¬ [s, startPos, len];      String.AppendSubString[to: currentNumber, from: subString];      p[word] ¬ String.StringToOctal[        currentNumber ! String.InvalidNumber => GO TO nullReturn];      startPos ¬ startPos + len;      UNTIL s[startPos] IN ['0..'7] DO startPos ¬ startPos + 1 ENDLOOP;      ENDLOOP;    EXITS nullReturn => RETURN[FALSE, System.nullID];    END;  UIDToString: PUBLIC PROCEDURE [id: System.UniversalID, s: LONG STRING] =    BEGIN    p: POINTER TO ARRAY [0..SIZE[System.UniversalID]) OF UNSPECIFIED =      LOOPHOLE[@id];    s.length ¬ 0;    String.AppendChar[s, '[];    FOR i: [0..SIZE[System.UniversalID]) IN [0..SIZE[System.UniversalID] - 1) DO      String.AppendOctal[s, p[i]];      String.AppendString[to: s, from: ", "];      ENDLOOP;    String.AppendOctal[s, p[SIZE[System.UniversalID] - 1]];    String.AppendChar[s, ']];    END;  -- Utility routines used by the top level procedures to get information from the user  GetBadPage: PROCEDURE [h: TTY.Handle] RETURNS [PhysicalVolume.PageNumber] =    BEGIN    currentBadPage ¬ GetLongNumber[      h, " bad page number: "L, currentBadPage, PhysicalVolume.nullBadPage, 10];    RETURN[currentBadPage];    END;  GetChangeCount: PROCEDURE [h: TTY.Handle] RETURNS [CARDINAL] =    BEGIN    currentChangeCount ¬ GetNumber[      h, " change count: "L, currentChangeCount, 0, 10];    RETURN[currentChangeCount];    END;  GetDeviceOrdinal: PROCEDURE [h: TTY.Handle] RETURNS [CARDINAL] =    BEGIN    currentDeviceOrdinal ¬ GetNumber[      h, " device index : "L, currentDeviceOrdinal,      PhysicalVolume.nullDeviceIndex, 10];    RETURN[currentDeviceOrdinal];    END;        GetNewPhysicalVolumeName: PROCEDURE [h: TTY.Handle] RETURNS [LONG STRING] =    BEGIN    TTY.PutString[h, " physical volume name: "L];    TTY.GetString[h, currentPhysicalVolumeName, Terminator];    RETURN[currentPhysicalVolumeName];    END;  GetPhysicalVolumeID: PROCEDURE [h: TTY.Handle] RETURNS [id: PhysicalVolume.ID] =    BEGIN    valid: BOOLEAN;    type: Device.Type;    index: CARDINAL;    TTY.PutString[h, " physical volume ID: "L];    DO  -- Loop until we get one that we like      TTY.GetString[h, currentPhysicalVolumeName, Terminator];      [valid, id] ¬ ValidPVName[currentPhysicalVolumeName];      IF valid THEN {PilotCommand.currentPhysicalVolumeID ¬ id; RETURN; };      [valid, type, index] ¬ ValidDriveName[currentPhysicalVolumeName];      IF valid THEN        BEGIN        [valid, id] ¬ GetVolumeFromHandle[PhysicalVolume.GetHandle[index]];        IF valid THEN {PilotCommand.currentPhysicalVolumeID ¬ id; RETURN; };        END;      [valid, id] ¬ ValidPVIDName[currentPhysicalVolumeName];      IF valid THEN {PilotCommand.currentPhysicalVolumeID ¬ id; RETURN; };      TTY.PutChar[h, '?];      ENDLOOP;    END;    -- The following are utility routines that interpret the user's string arguments as  -- objects needed to call into Pilot  ConvertDeviceNameToDeviceType: PROCEDURE [s: LONG STRING]    RETURNS [valid: BOOLEAN, type: Device.Type] =    BEGIN    FOR i: CARDINAL IN [0..LENGTH[deviceTable]) DO      IF String.EquivalentStrings[s, deviceTable[i].name] THEN        RETURN[TRUE, deviceTable[i].type]      ENDLOOP;    RETURN[FALSE, Device.nullType];    END;  ConvertDeviceTypeToString: PROCEDURE [type: Device.Type, s: LONG STRING] =    BEGIN    FOR i: [0..LENGTH[deviceTable]) IN [0..LENGTH[deviceTable]) DO      IF type = deviceTable[i].type THEN {        String.AppendString[to: s, from: deviceTable[i].name]; RETURN}      ENDLOOP;    ERROR;    END;  GetVolumeFromHandle: PROCEDURE [h: PhysicalVolume.Handle]    RETURNS [valid: BOOLEAN, id: PhysicalVolume.ID] =    BEGIN    valid ¬ TRUE;    id ¬ PhysicalVolume.nullID;    WHILE (id ¬ PhysicalVolume.GetNext[id]) ~= PhysicalVolume.nullID DO      IF h = PhysicalVolume.GetAttributes[id].instance THEN RETURN; ENDLOOP;    valid ¬ FALSE;    END;  ValidDriveName: PROCEDURE [s: LONG STRING]    RETURNS [valid: BOOLEAN, type: Device.Type, index: CARDINAL] =    BEGIN    FOR i: CARDINAL IN [0..LENGTH[deviceTable]) DO      ordinalName: STRING ¬ [stringSize];      s1: String.SubStringDescriptor ¬ [        deviceTable[i].name, 0, deviceTable[i].name.length];      s2: String.SubStringDescriptor ¬ [s, 0, tableName.length];      tableName: String.SubString ¬ @s1;      userName: String.SubString ¬ @s2;      usersType: Device.Type = deviceTable[i].type;      usersIndex: CARDINAL;      IF String.EquivalentSubStrings[tableName, userName] THEN        BEGIN  -- Now see if the device ordinal makes any sense        ordinalName.length ¬ 0;        FOR j: CARDINAL IN [userName.length..s.length) DO          ordinalName[ordinalName.length] ¬ s[j];          ordinalName.length ¬ ordinalName.length + 1;          ENDLOOP;        usersIndex ¬ String.StringToNumber[          ordinalName, 10 ! String.InvalidNumber => GO TO invalid];        [index] ¬ PhysicalVolume.GetNextDrive[          PhysicalVolume.nullDeviceIndex];        WHILE type ~= Device.nullType AND index ~= PhysicalVolume.nullDeviceIndex          DO          IF type = usersType AND index = usersIndex THEN            RETURN[TRUE, type, index];          [index] ¬ PhysicalVolume.GetNextDrive[index];          ENDLOOP;        END;      ENDLOOP;    EXITS      invalid => RETURN[FALSE, Device.nullType, PhysicalVolume.nullDeviceIndex];    END;    ValidPVIDName: PROCEDURE [s: LONG STRING]    RETURNS [valid: BOOLEAN, id: PhysicalVolume.ID] =    BEGIN    usersID: PhysicalVolume.ID;    IF String.EquivalentStrings[s, "Nil"L] OR String.EquivalentStrings[s, "Null"L]      THEN RETURN[TRUE, PhysicalVolume.nullID];    usersID ¬ LOOPHOLE[PilotCommand.StringToUID[s].id];    valid ¬ TRUE;    id ¬ PhysicalVolume.nullID;    WHILE (id ¬ PhysicalVolume.GetNext[id]) ~= PhysicalVolume.nullID DO      IF id = usersID THEN RETURN; ENDLOOP;    valid ¬ FALSE;    END;  ValidPVName: PROCEDURE [s: LONG STRING]    RETURNS [valid: BOOLEAN, id: PhysicalVolume.ID] =    BEGIN    pvLabel: STRING ¬ [stringSize];    valid ¬ TRUE;    id ¬ PhysicalVolume.nullID;    WHILE (id ¬ PhysicalVolume.GetNext[id]) ~= PhysicalVolume.nullID DO      [] ¬ PhysicalVolume.GetAttributes[id, pvLabel];      IF String.EquivalentStrings[pvLabel, currentPhysicalVolumeName] THEN        RETURN[TRUE, id];      ENDLOOP;    valid ¬ FALSE;    END;  -- The following procedures are used to do I/O on the display  GetLongNumber: PROCEDURE [    h: TTY.Handle, prompt: LONG STRING, default: LONG UNSPECIFIED,    nullValue: LONG UNSPECIFIED, radix: CARDINAL]    RETURNS [num: LONG UNSPECIFIED] =    BEGIN    numberString: STRING ¬ [stringSize];    IF default = nullValue THEN String.AppendString[numberString, "Null"L]    ELSE String.AppendLongNumber[numberString, default, 10];    TTY.PutString[h, prompt];    DO  -- until we get one that we like      TTY.GetString[h, numberString, Terminator];      IF String.EquivalentStrings[numberString, "Null"L]        OR String.EquivalentStrings[numberString, "Nil"L] THEN RETURN[nullValue];      RETURN[        String.StringToLongNumber[          numberString, 10 ! String.InvalidNumber => {TTY.PutChar[h, '?]; LOOP}]];      ENDLOOP;    END;  GetNumber: PROCEDURE [    h: TTY.Handle, prompt: LONG STRING, default: UNSPECIFIED, nullValue: UNSPECIFIED,    radix: CARDINAL] RETURNS [num: UNSPECIFIED] =    BEGIN    numberString: STRING ¬ [stringSize];    IF default = nullValue THEN String.AppendString[numberString, "Null"L]    ELSE String.AppendNumber[numberString, default, 10];    TTY.PutString[h, prompt];    DO  -- until we get one that we like      TTY.GetString[h, numberString, Terminator];      IF String.EquivalentStrings[numberString, "Null"L]        OR String.EquivalentStrings[numberString, "Nil"L] THEN RETURN[nullValue];      RETURN[        String.StringToDecimal[          numberString ! String.InvalidNumber => {TTY.PutChar[h, '?]; LOOP}]];      ENDLOOP;    END;  PutDriveNameAndType: PROCEDURE      [h: TTY.Handle, type: Device.Type, index: CARDINAL] =    BEGIN    FOR i: CARDINAL IN [0..LENGTH[deviceTable]) DO      IF deviceTable[i].type = type THEN {        TTY.PutString[h, deviceTable[i].name]; EXIT};      REPEAT FINISHED => TTY.PutString[h, "UnknownType!"L];      ENDLOOP;    TTY.PutString[h, ", index = "];    IF index = PhysicalVolume.nullDeviceIndex THEN TTY.PutString[h, " null "L]    ELSE TTY.PutNumber[h, index, [10, FALSE, TRUE, 0]];    END;    PutDriveName: PROCEDURE [h: TTY.Handle, index: CARDINAL] =    BEGIN    TTY.PutString[h, ", index = "];    IF index = PhysicalVolume.nullDeviceIndex THEN TTY.PutString[h, " null "L]    ELSE TTY.PutNumber[h, index, [10, FALSE, TRUE, 0]];    END;    PutLongNumber: PROCEDURE [    h: TTY.Handle, num: LONG UNSPECIFIED, radix: CARDINAL] =    BEGIN TTY.PutLongNumber[h, num, [radix, FALSE, TRUE, 0]]; END;  PutNumber: PROCEDURE [h: TTY.Handle, num: UNSPECIFIED, radix: CARDINAL] =    BEGIN TTY.PutNumber[h, num, [radix, FALSE, TRUE, 0]]; END;      PutLogicalVolumeID: PROCEDURE [h: TTY.Handle, id: Volume.ID] =    BEGIN s: LONG STRING ¬ [stringSize]; UIDToString[id, s]; TTY.PutString[h, s]; END;  PutPhysicalVolumeID: PROCEDURE [h: TTY.Handle, id: PhysicalVolume.ID] =    BEGIN s: LONG STRING ¬ [stringSize]; UIDToString[id, s]; TTY.PutString[h, s]; END;  -- The following procedure is used to tell the TTY package when a token has ended.  Terminator: PROCEDURE [c: CHARACTER] RETURNS [status: TTY.CharStatus] =    BEGIN    IF c = Ascii.SP OR c = Ascii.CR THEN RETURN[stop] ELSE RETURN[ok];    END;  Command.InstallTopLevel[tty, ["physical volume", PhysicalVolumeCmd]];    END.LOGOctober 3, 1980  2:25 PM	AWL         Created file.4-Sep-81 14:50:41		SXY      Removed cdc9730 entry from deviceTable, LONGified the string in StringToUID & UIDToString.15-Oct-81 16:33:41		Rhodes   Added commands to help list.25-Nov-81  9:29:30		CAJ    Added new device types, removed diablo31 from deviceTable.25-Oct-82 16:29:32		WDK        Add quantum device types.10-Jan-83 13:48:29		EKN      Updated to Klamath:  Deleted all procedures dealing with logical volumes.  They will be moved to FileCommands. Updated code where GetNextDrive, GetHandle, and AwaitStateChange are used.    1-Apr-83 11:40:37	AWL         Dummy edit to change create date (cross-edits).12-Apr-83 16:23:25	JXP      Make compatible with new TTY interface.30-Jun-83 17:24:03	EKN      Add GetNextLogicalVolumeCmd from FileCommands 5-Feb-87 12:38:15	CJSSome STRINGs ¬ LONG STRING.
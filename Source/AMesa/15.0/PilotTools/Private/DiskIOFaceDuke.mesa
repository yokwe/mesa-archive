-- File: DiskIOFaceDuke.mesa - last edit:-- Kondoh:IWA:Fuji Xerox       26-Apr-89 10:10 JST-- Copyright (C) 1989 by Fuji Xerox Co., Ltd, Tokyo, Japan. All rights reserved.DIRECTORY  CompatibilityDiskFace USING [Command, Label, Operation],  DoveInputOutput USING [ByteSwappedPointer, ByteSwappedWord, ClientCondition, IOPBoolean, IOPCondition, IOPShortBoolean, NotifyMask, OpieAddress, TaskContextBlock],  Environment USING [Base, Byte],  PilotDiskFace USING [Command, DeviceHandle, DiskAddress],  Zone USING [Alignment];DiskIOFaceDuke: DEFINITIONS =  BEGIN OPEN PDF: PilotDiskFace, CDF: CompatibilityDiskFace;   Byte: TYPE = Environment.Byte;    ByteSwappedLongPointer: TYPE = LONG POINTER;    ClientCondition: TYPE = DoveInputOutput.ClientCondition;    << MACHINE DEPENDENT RECORD [    handlerID(0:0..7): HandlerID,    conditionRelMaskPtr(0:8..15): ConditionRelMaskPtr,    conditionPtr(1): ByteSwappedLinkPtr,    maskValue(2): WORD]; >>    ClientCount: TYPE = Byte [0..ORD[LAST[ClientType]]];    ClientDriveMask: TYPE = Byte;    ClientInfo: TYPE = MACHINE DEPENDENT RECORD [    currentClient(0:0..7): ClientType,    clientsToTest(0:8..15): ClientCount,    numberOfPossibleClients(1:0..7): ClientCount,    lastDriveMask(1:8..15): ClientDriveMask];    ClientType: TYPE = MACHINE DEPENDENT {rd0MesaClient(0), rd0IOPClient(1), rd1MesaClient(2), rd1IOPClient(3), rd2MesaClient(4), rd2IOPClient(5), rd3MesaClient(6), rd3IOPClient(7)};    ClockPulses: TYPE = RECORD [pulses: TimeUnit];    CommandDirection: TYPE = MACHINE DEPENDENT {fromMesa(0), toMesa(1)};  ControllerErrorType: TYPE = MACHINE DEPENDENT {    noError(0), controllerError(1), interruptTimeout(2),    controllerNotInIdleLoop(3)};  <<  The Device Context Block is a block of memory that holds the context information that is shared between the Head and the Handler.  >>    DataTransferDirection: TYPE = MACHINE DEPENDENT {read(0), write(1), execute(2), noDataOperation(3), (377B)};  DeviceContextBlockPointer, DCBPtr: TYPE = LONG POINTER TO DCB;  DeviceContextBlock, DCB: TYPE = MACHINE DEPENDENT RECORD [    mesaHead(0): IOCBPtr,	<< Head use only for queue maintanence >>    handlerMesaNext(1): IOCBPtr,    mesaTail(2): IOCBPtr,    blockMesaQueue(3): DoveInputOutput.IOPBoolean,    iopHead(4): DoveInputOutput.OpieAddress,      handlerIOPNext(6): DoveInputOutput.OpieAddress,      iopTail(8): DoveInputOutput.OpieAddress,    blockIOPQueue(10): DoveInputOutput.IOPBoolean,    currentDriveMask(11:0..7): DriveMask,    diskCommand(11:8..15): DiskCommand,    mesaClientCondition(12): DoveInputOutput.ClientCondition,    iopClientCondition(15): DoveInputOutput.ClientCondition,    currentIOCB(18): DoveInputOutput.OpieAddress,        recalibrate(20:0..0): BOOLEAN,  << recalibrate next iocb Initiated.  >>    driveExists(20:1..1): BOOLEAN,    useEcc(20:2..3): BOOLEAN,    selectMask(20:4..7):  DriveSelectMask,    diskState(20:8..11): MACHINE DEPENDENT {notThere(0), notReady(1), ready(3)},    dcbOffset(20:12..15): [0..16),    deviceInformation(21): DeviceInformation];    DeviceErrorType: TYPE = MACHINE DEPENDENT {otherError(0), protocolError(1), fieldError(2), unEncodedError(3)};    DeviceInformation: TYPE = MACHINE DEPENDENT RECORD [    pad(0:0..7): Byte ¬ 0,    driveType(0:8..15): DriveType,    sectorsPerTrack(1:0..7): Byte,    headsPerCylinder(1:8..15): Byte,    cylindersPerDrive(2): DoveInputOutput.ByteSwappedWord <<CARDINAL>>,    reduceWriteCurrentCylinder(3): DoveInputOutput.ByteSwappedWord <<CARDINAL>>,    precompensationCylinder(4): DoveInputOutput.ByteSwappedWord <<CARDINAL>>];    DeviceStatus: TYPE = MACHINE DEPENDENT RECORD [    inProgress(0:0..0): BOOLEAN ¬ FALSE,    complete(0:1..1): BOOLEAN ¬ FALSE,    errorDetected(0:2..2): BOOLEAN ¬ FALSE,    communicationError(0:3..3): BOOLEAN ¬ FALSE,    dmaTimeout(0:4..4): BOOLEAN ¬ FALSE,    fifoError(0:5..5): BOOLEAN ¬ FALSE,    illegalOperation(0:6..6): BOOLEAN ¬ FALSE,    ready(0:7..7): BOOLEAN ¬ FALSE,    protocolViolation(0:8..8): BOOLEAN ¬ FALSE,    writeFault(0:9..9): BOOLEAN ¬ FALSE,    illegalCylinder(0:10..10): BOOLEAN ¬ FALSE,    track00(0:11..11): BOOLEAN ¬ FALSE,    unused0(0:12..15): [0..15) ¬ 0,        sectorNotFound(1:0..0): BOOLEAN ¬ FALSE,    headerCRCError(1:1..1): BOOLEAN ¬ FALSE,    labelAddressMarkError(1:2..2): BOOLEAN ¬ FALSE,    labelIDError(1:3..3): BOOLEAN ¬ FALSE,    labelVerifyError(1:4..4): BOOLEAN ¬ FALSE,    labelCRCError(1:5..5): BOOLEAN ¬ FALSE,    dataAddressMarkError(1:6..6): BOOLEAN ¬ FALSE,    dataIDError(1:7..7): BOOLEAN ¬ FALSE,    dataVerifyError(1:8..8): BOOLEAN ¬ FALSE,    dataCRCorECCError(1:9..9): BOOLEAN ¬ FALSE,    unused1(1:10..15): [0..64) ¬ 0];          DiskControllerRegisters: TYPE = MACHINE DEPENDENT RECORD [    error(0:0..0): BOOLEAN,    done(0:1..1): BOOLEAN,    padA(0:2..5): [0..16),    lastCommand(0:6..7): DiskCommand,        emergencyStop(0:8..8): BOOLEAN,    diagnosticCommand(0:9..9): BOOLEAN,    padB(0:10..13): [0..16),    command(0:14..15): DiskCommand,        handlerPrivateRetryCount(1:0..7): Byte,    badDiskInterruptReason(1:8..15): Byte];  ByteSwappedDiskAddress: TYPE = MACHINE DEPENDENT RECORD [    cylinder(0): DoveInputOutput.ByteSwappedWord << CARDINAL >>,    sector(1:0..7): [0..256),    head(1:8..15): [0..256)];    DiskOperationBlock, DOB: TYPE = MACHINE DEPENDENT RECORD [    eccSyndrome(0): RECORD [a, b: WORD],    negativeSectorCount(2): DoveInputOutput.ByteSwappedWord << INTEGER >>,    sectorsPerTrack(3:0..7): Byte,    zero1(3:8..15): Byte ¬ 0,    headsPerCylinder(4:0..7): Byte,    currentVersion(4:8..15): Byte ¬ 0,    cylindersPerDrive(5): DoveInputOutput.ByteSwappedWord << CARDINAL >>,    startingSectorOnTrack(6:0..7): Byte ¬ 0,    zero3(6:8..15): Byte ¬ 0,    reducedWriteCylinder(7): DoveInputOutput.ByteSwappedWord << CARDINAL >>,    preCompensationCylinder(8): DoveInputOutput.ByteSwappedWord << CARDINAL >>,    writeEndCount(9:0..7): Byte,    zero4(9:8..15): Byte ¬ 0,    headerError(10): ErrorStatus,    labelError(11): ErrorStatus,    dataError(12): ErrorStatus,    lastError(13): ErrorStatus,    currentCylinder(14): DoveInputOutput.ByteSwappedWord << CARDINAL >>,    eccFlag(15:0..7): MACHINE DEPENDENT {ECC(0), CRC(1), (377B)},    zero5(15:8..15): Byte ¬ 0,    header(16): ByteSwappedDiskAddress,    sectorValid(18): DoveInputOutput.ByteSwappedWord,<<ARRAY OF BOOLEAN>>    reserved2(19): WORD ¬ 0,    driveAndControllerStatus(20): DriveAndControllerStatus,    operation(21:0..7): Operation,    zero6(21:8..15): Byte ¬ 0,    negativeFormatTrackCount(22): DoveInputOutput.ByteSwappedWord << INTEGER >>,    label(23): CDF.Label];    DiskCommand: TYPE = MACHINE DEPENDENT {goToIdleLoop(0), xferDOBToController(1), executeDOB(2), xferDOBFromController(3)};    DMAErrorType: TYPE = MACHINE DEPENDENT {    noError(0), diskDMAError(1), interruptTimeout(2), fifoNotEmpty(3)};    DMAStateInfo: TYPE = MACHINE DEPENDENT RECORD [    diskFIFODirection(0:0..0): FIFODirection,    bb1(0:1..1): MACHINE DEPENDENT {low(0), high(1)},    fifoNotfull(0:2..2): BOOLEAN,    fifoNotEmpty(0:3..3): BOOLEAN,    fifoBoundaryBar(0:4..4): BOOLEAN,    dmaInProgress(0:5..5): BOOLEAN,    dmaStateMachineNotRunning(0:6..6): BOOLEAN,    dmaError(0:7..7): BOOLEAN,            badDiskDMAInterruptReason(0:8..15): Byte];    DriveAndControllerStatus: TYPE = MACHINE DEPENDENT RECORD [    << DriveStatus >>    notReady(0:0..0): BOOLEAN,    notSeekCompleted(0:1..1): BOOLEAN,    zero(0:2..2): [0..2),    addressMarkOut(0:3..3): BOOLEAN,	<< Address Mark Detected >>    notStoredIndexMark(0:4..4): BOOLEAN,    notTrack0(0:5..5): BOOLEAN,    notWriteFault(0:6..6): BOOLEAN,    lockDetected(0:7..7): BOOLEAN,        << Controller Status >>    readDataFound(0:8..8): BOOLEAN,    notBDone(0:9..9): BOOLEAN,    fifoEmptyAtRead(0:10..10): BOOLEAN,    notSPMABit3(0:11..11): BOOLEAN,    notSPMAMaxCount(0:12..12): BOOLEAN,    fifoA1B1Same(0:13..13): BOOLEAN,    fifoEmptySynchonized(0:14..14): BOOLEAN,    fifoFullSynchonized(0:15..15): BOOLEAN];    DriveMask: TYPE = Byte;    DriveNumber: TYPE = [0..numberOfDrives);    DriveSelectMask:  TYPE = [0..16);    DriveType: TYPE = Byte;    ErrorType: TYPE = MACHINE DEPENDENT {noError(0), fifoEmptyAtGetCommandBlock(1), fifoNotEmpty(3), fifoFull(4), fifoEmpty(5), fifoNotEmptyAtLoadCommandBlock(7), lastFIFOError(0FH), firstHeaderError(10H), headerAddressMarkNotFound(11H), headerIDError(12H), headerVerifyError(13H), headerCRCorECCError(14H), lastHeaderError(1FH), firstLabelError(20H), labelAddressMarkNotFound(21H), labelIDError(22H), labelVerifyError(23H), labelCRCorECCError(24H), labelCRCAndVerifyError(25H), lastLabelError(2FH), firstDataError(30H), dataAddressMarkNotFound(31H), dataIDError(32H), dataVerifyError(33H), dataCRCorECCError(34H), dataCRCOrECCAndVerifyError(35H), lastDataError(3FH), oldSectorNotFound(80H), sectorNotFound(81H), cylinderTooBig(82H), currentCylinderUnknown(84H), writeFault(85H), illegalOperation(8AH), illegalDiagnosticOperation(8BH), protocolViolation(8CH), (0FFH)};    ErrorStatus: TYPE = MACHINE DEPENDENT RECORD [    error(0:0..7): ErrorType,    zero(0:8..15): Byte ¬ 0];    FIFODirection: TYPE = MACHINE DEPENDENT {fromMesa(0), toMesa(1)};    <<  The Function Context Block is an array of Device Context Blocks that hold the context information that is shared between the Head and the Handler.  There is an entry for each physical device.    >>    <<******* This device handle is for mugging pages *******>>  longWrite: PilotDiskFace.DeviceHandle = LOOPHOLE[0FFFEH];  <<******* This device handle is for mugging pages *******>>    tcbLength: NATURAL = SIZE[DoveInputOutput.TaskContextBlock];  fcbBase: NATURAL = 2 * tcbLength;    FunctionContextBlockPointer, FCBPtr: TYPE = LONG POINTER TO FCB;  FunctionContextBlock, FCB: TYPE = MACHINE DEPENDENT RECORD[    diskTask(0): DoveInputOutput.TaskContextBlock,    diskDMATask(tcbLength): DoveInputOutput.TaskContextBlock,    conditionDMAWork(fcbBase): DoveInputOutput.IOPCondition,    conditionDMADone(fcbBase+1): DoveInputOutput.IOPCondition,    conditionWork(fcbBase+2): DoveInputOutput.IOPCondition,    workMask(fcbBase+3): DoveInputOutput.NotifyMask,    lockMask(fcbBase+4): WORD,    mesaCleanupRequest(fcbBase+5): DoveInputOutput.IOPBoolean,    iopCleanupRequest(fcbBase+6): DoveInputOutput.IOPBoolean,    handlerStoppedForMesa(fcbBase+7): DoveInputOutput.IOPBoolean,    handlerStoppedForIOP(fcbBase+8): DoveInputOutput.IOPBoolean,    handlerStoppedForMesaCleanup(fcbBase+9): DoveInputOutput.IOPBoolean,    handlerStoppedForIOPCleanup(fcbBase+10): DoveInputOutput.IOPBoolean,    startHandlerForMesa(fcbBase+11): DoveInputOutput.IOPBoolean,    startHandlerForIOP(fcbBase+12): DoveInputOutput.IOPBoolean,    handlerState(fcbBase+13): HandlerState,    clientInfo(fcbBase+14): ClientInfo,    currentDrivePtr(fcbBase+16): DoveInputOutput.ByteSwappedPointer,    controllerRegisters(fcbBase+17): DiskControllerRegisters,    driveInfoAndDMAStatus(fcbBase+19): DMAStateInfo,    unexpectedDiskInterruptCount(fcbBase+20):  DoveInputOutput.ByteSwappedWord << CARDINAL >>,    unexpectedDiskDMAInterruptCount(fcbBase+21):  DoveInputOutput.ByteSwappedWord << CARDINAL >>,    dcb(fcbBase+22): ARRAY DriveNumber OF DCB];    GlobalState: TYPE = MACHINE DEPENDENT RECORD [    fcb: FCBPtr ¬ NIL,    eccErrorCnt: LONG CARDINAL ¬ 0,    eccFixCnt: LONG CARDINAL ¬ 0];    HandlerState: TYPE = MACHINE DEPENDENT {normalDiskHandlerState(0), diskControllerNotIdling(100H), badDiskInterrupt(200H), badDiskDMAInterrupt(300H), DMAerror(400H), resettingDMATask(500H), resettingDiskTask(600H), resettingHandler(177777B)};  <<    The Input Output Controller Block (IOCB) is Hexadecimally alligned and must not cross a page boundary!!!  It is split into four/five seperate sections.        Section 1:  The first section is the operation information taken from the associated Face (in this case the PilotDiskFace).  Although information that the Handler and/or the Controller may need may appear in the correct format in the operation it is unwise (and therefore forbidden) for them to access such information since it builds machine dependencies into the supposedly machine independent level of the software.  Any such information will be copied into an appropriate section of the IOCB for the Handler's/Controller's use.         Section 2:  This section contains information used by the client.  It is beleived that such information is not of interest to (and should not be accessed by) the Handler and/or the Controller.        Section 3:  This section contains the information that the Handler requires in order to carry out its task.        Section 4: This is an optional section which contains the information common to both the Handler and the Controller.        Section 5:  This section contains the information that is used by the Controller.  >>  IOContextBlockLongPointer, IOCBlongPtr: TYPE = LONG POINTER TO IOCB;  IOContextBlockPointer, IOCBPtr: TYPE = Environment.Base RELATIVE POINTER TO IOCB;  IOContextBlock, IOCB: TYPE = MACHINE DEPENDENT RECORD [    << Operation. >>    op(0): CDF.Operation,    << Head only information. >>    mesaNext(15B): IOCBPtr,    iopNext(16B): DoveInputOutput.OpieAddress,    type(20B:0..1): {normal, restore, labelFixup}, <<Set by InitIOCB for Poll>>    labelFixupType(20B:2..3): {none, readLabel, fixed, verifyErrorExpected},    labelFixupTry(20B:4..15): [0..7777B],    try(21B): CARDINAL,    command(22B): CDF.Command,    runLength(23B): CARDINAL,    pageLocalization(24B): CARDINAL,    preRestored(25B): BOOLEAN,    <<filler(26B): ARRAY [1..13] OF CARDINAL, <<for compatability>>>>    filler(26B): ARRAY [1..10] OF CARDINAL,    useBuffer(40B): BOOLEAN,    bufferHit(41B): BOOLEAN,    mapEntry(42B): CARDINAL,    << Handler information. >>    dataPtr(43B): DoveInputOutput.OpieAddress,    dataCommandTransfer(45B:0..0): BOOLEAN,    unused2(45B:1..6): [0..64) ¬ 0,    dataCommandDirection(45B:7..7): CommandDirection,    incrementDataPtr(45B:8..8): BOOLEAN,    complementDOB(45B:9..9): BOOLEAN ¬ TRUE,    etch(45B:10..10): MACHINE DEPENDENT {etch1(0), etch2(1)} ¬ etch1,    unused1(45B:11..12): [0..4) ¬ 0,    useLEDs(45B:13..13): BOOLEAN,    halt(45B:14..14): BOOLEAN,    diagnosticCommand(45B:15..15): BOOLEAN,    pageCount(46B): DoveInputOutput.ByteSwappedWord <<CARDINAL>>,    stopHandlerOnCompletion(47B:0..7): DoveInputOutput.IOPShortBoolean,    onlyDOBFromController(47B:8..15): DoveInputOutput.IOPShortBoolean,    error(50B:0..7): DoveInputOutput.IOPShortBoolean,    diskOperationBlockError(50B:8..15): DoveInputOutput.IOPShortBoolean,    controllerErrorType(51B:0..7): ControllerErrorType,    dmaErrorType(51B:8..15): DMAErrorType,    complete(52B:0..7): DoveInputOutput.IOPShortBoolean,    inProgress(52B:8..15): DoveInputOutput.IOPShortBoolean,    dataTransferDirection(53B:0..7): DataTransferDirection,    dmaTimedOut(53B:8..15): DoveInputOutput.IOPShortBoolean,    nextIOCB(54B): DoveInputOutput.OpieAddress,        << Handler & Controller information. >>        << Controller information. >>        dob(56B): DiskOperationBlock];  IORegion: TYPE = LONG BASE POINTER;    Operation: TYPE = MACHINE DEPENDENT {restore(0), formatTracks(1), readData(2), writeData(3), writeLabelAndData(4), readLabel(5), readLabelAndData(6), verifyData(7), readDiagnostic(8), readTrack(16), (0FFH)};    TimeUnit: TYPE = LONG CARDINAL;  << used to keep track of the difference in ClockPulses for a time out mechanism. >>    TransferMask: TYPE = WORD;  -- naked notify mask type    Use: TYPE = MACHINE DEPENDENT {off, opTriesGR1, on};  <<  Constants that are used/defined by the Head; the Handler; or the Controller.    >>  alignment: Zone.Alignment = a1;  defaultDriveAndControllerStatus: DriveAndControllerStatus = [    notReady: TRUE, notSeekCompleted: TRUE, zero: 0, addressMarkOut: FALSE,    notStoredIndexMark: TRUE, notTrack0: TRUE, notWriteFault: TRUE,    lockDetected: FALSE,    readDataFound: FALSE, notBDone: TRUE, fifoEmptyAtRead: FALSE,    notSPMABit3: TRUE, notSPMAMaxCount: TRUE, fifoA1B1Same: FALSE,    fifoEmptySynchonized: FALSE, fifoFullSynchonized: FALSE];  defaultWriteEndCount: Byte = 0FFH;      deviceStatusComErr: DeviceStatus = [    inProgress: FALSE, complete: TRUE, errorDetected: TRUE,    communicationError: TRUE, dmaTimeout: FALSE, fifoError: FALSE,    illegalOperation: FALSE, ready: FALSE, protocolViolation: FALSE,    writeFault: FALSE, illegalCylinder: FALSE, track00: FALSE, unused0: 0,    sectorNotFound: FALSE, headerCRCError: FALSE, labelAddressMarkError: FALSE,    labelIDError: FALSE, labelVerifyError: FALSE, labelCRCError: FALSE,    dataAddressMarkError: FALSE, dataIDError: FALSE, dataVerifyError: FALSE,    dataCRCorECCError: FALSE, unused1: 0];  deviceStatusInitial: DeviceStatus = [    inProgress: FALSE, complete: FALSE, errorDetected: FALSE,    communicationError: FALSE, dmaTimeout: FALSE, fifoError: FALSE,    illegalOperation: FALSE, ready: FALSE, protocolViolation: FALSE,    writeFault: FALSE, illegalCylinder: FALSE, track00: FALSE, unused0: 0,    sectorNotFound: FALSE, headerCRCError: FALSE, labelAddressMarkError: FALSE,    labelIDError: FALSE, labelVerifyError: FALSE, labelCRCError: FALSE,    dataAddressMarkError: FALSE, dataIDError: FALSE, dataVerifyError: FALSE,    dataCRCorECCError: FALSE, unused1: 0];    deviceStatusInProgress: DeviceStatus = [    inProgress: TRUE, complete: FALSE, errorDetected: FALSE,    communicationError: FALSE, dmaTimeout: FALSE, fifoError: FALSE,    illegalOperation: FALSE, ready: FALSE, protocolViolation: FALSE,    writeFault: FALSE, illegalCylinder: FALSE, track00: FALSE, unused0: 0,    sectorNotFound: FALSE, headerCRCError: FALSE, labelAddressMarkError: FALSE,    labelIDError: FALSE, labelVerifyError: FALSE, labelCRCError: FALSE,    dataAddressMarkError: FALSE, dataIDError: FALSE, dataVerifyError: FALSE,    dataCRCorECCError: FALSE, unused1: 0];    firstPageOfInitialMicrocode: PDF.DiskAddress = [    cylinder: 0, head: 1, sector: initialSector]; << Page 16 >>    firstPilotPage: PDF.DiskAddress = [    cylinder: 2, head: 0, sector: initialSector];  << Page 128 >>    formattingCommand:  PDF.Command = format;    initialSector: Byte = 0;    initialCurrentCylinder: CARDINAL = 0FFFFH;  nil: IOCBPtr = LOOPHOLE[0];    numberOfDrives: NATURAL = 2;    operationSize: CARDINAL = SIZE[IOCB];      -- Dove Rigid Disk Controller Constants:   selectMasks: ARRAY DriveNumber OF DriveSelectMask = [2B, 1B];  END.......LOGDEG:  9-Aug-88 18:38:53	Created from DiskIOFaceDove.mesa.MN:   8-Oct-88 22:50:42 Changed for TrackBuffering.MXK:	26-Apr-89  9:45:28	Added "longWrite" for mugging pages.
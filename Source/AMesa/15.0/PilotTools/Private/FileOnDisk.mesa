-- Copyright (C) 1988  by Xerox Corporation. All rights reserved. -- FileOnDisk.mesa	 4-May-88  8:20:42	CAJDIRECTORY  BackingStore USING [Run],  DiskBackingStore USING [DiskDataFromBSData],  Exec USING [AddCommand, ExecProc, OutputProc, RemoveCommand],  File USING [File, GetSize, nullFile, PageCount, PageNumber, Unknown],  FileTypes USING [tUnassigned],  Format USING [StringProc],  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, CommandItem, DisplayItem,    FilterProcType, ItemHandle, line0, line1, line2, line3, LongNumberItem,    LongNumberNotifyProcType, ProcType, StringEditProc, StringItem],  Heap USING [systemZone],  MFile USING [Acquire, Error, Handle, Release],  MsgSW USING [Clear],  PhysicalVolume USING [PageNumber],  Put USING [CR, LongDecimal, Text],  SpecialFile USING [GetBackingStoreRun],  SpecialMFile USING [GetCapaWithAccess],  Tool USING [    Create, Destroy, MakeFileSW, MakeFormSW, MakeMsgSW, MakeSWsProc,    UnusedLogName],  ToolWindow USING [Activate, TransitionProcType],  UserTerminal USING [BlinkDisplay],  Window USING [Handle];FileOnDisk: MONITOR  IMPORTS    DiskBackingStore, Exec, File, FormSW, Heap, MFile, MsgSW, Put,    SpecialFile, SpecialMFile, Tool, ToolWindow, UserTerminal =  BEGIN  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = MACHINE DEPENDENT RECORD [    msgSW(0): Window.Handle ¬ NIL,    formSW(2): Window.Handle ¬ NIL,    fileSW(4): Window.Handle ¬ NIL,    filename(6): LONG STRING ¬ NIL,    filePage(8): File.PageNumber ¬ 0,    pvPage(10): PhysicalVolume.PageNumber ¬ 0,    fileSize(12): File.PageCount ¬ 0,    file(14): File.File ¬ File.nullFile];  FormItems: TYPE = {    filename, filePage, next, back, diskPageForFilePage, pvPage, showRuns};  data: DataHandle ¬ NIL;  wh: Window.Handle ¬ NIL;  zone: UNCOUNTED ZONE ¬ Heap.systemZone;  busyBit: BOOLEAN ¬ FALSE;  Back:  FormSW.ProcType = {    ENABLE ABORTED => {Done[]; CONTINUE};    MsgSW.Clear[data.msgSW];    IF Busy[] THEN {Msg["Tool is busy.\n"L]; RETURN};    IF data.filePage = 0 THEN UserTerminal.BlinkDisplay[]    ELSE       {data.filePage ¬ data.filePage - 1;       FormSW.DisplayItem[sw, FormItems.filePage.ORD];       data.pvPage ¬ 0;       FormSW.DisplayItem[sw, FormItems.pvPage.ORD]};    Done[] };  Busy: ENTRY PROCEDURE RETURNS [isBusy: BOOLEAN] = {    ENABLE UNWIND => NULL;    isBusy ¬ busyBit;    busyBit ¬ TRUE };  ChangeFilename: FormSW.FilterProcType =    --[sw: Window.Handle, item: FormSW.ItemHandle, insert: CARDINAL,    -- string: LONG STRING]    BEGIN    MsgSW.Clear[data.msgSW];    FormSW.StringEditProc[sw, item, insert, string];    IF data.filename[0] = '[ THEN Msg["ID's not implemented"L];    data.file ¬ File.nullFile;    data.fileSize ¬ 0;    data.pvPage ¬ 0;    FormSW.DisplayItem[sw, FormItems.pvPage.ORD];    END;  -- ChangeFilename  ChangeFilePage: FormSW.LongNumberNotifyProcType =    BEGIN    data.pvPage ¬ 0;    FormSW.DisplayItem[sw, FormItems.pvPage.ORD];    END;  -- ChangeFilePage  ClientTransition: ToolWindow.TransitionProcType = {    SELECT TRUE FROM      old = inactive =>        BEGIN	IF data = NIL THEN data ¬ zone.NEW[Data ¬ []];	-- init file stuff	data.file ¬ File.nullFile;	data.fileSize ¬ 0;	data.pvPage ¬ 0;	END;      new = inactive =>        IF data # NIL THEN	  {zone.FREE[@data];	   data ¬ NIL};      ENDCASE;    };  DiskPageForFilePage:  FormSW.ProcType =    BEGIN ENABLE ABORTED => {Done[]; CONTINUE};    run: BackingStore.Run;    IF Busy[] THEN {Msg["Tool is busy.\n"L]; RETURN};    MsgSW.Clear[data.msgSW];    IF ~InitFile[] THEN GOTO fileProblem;    IF data.filePage >= data.fileSize THEN GOTO pageProblem;    run ¬ SpecialFile.GetBackingStoreRun[      data.file, data.filePage, FileTypes.tUnassigned].run;    data.pvPage ¬ DiskBackingStore.DiskDataFromBSData[run.data].volumePage;    FormSW.DisplayItem[sw, FormItems.pvPage.ORD];    Done[];    EXITS      fileProblem =>        {Msg["Can't access file."L]; UserTerminal.BlinkDisplay[]; Done[]};      pageProblem =>        {Msg["File page out of range."L]; UserTerminal.BlinkDisplay[]; Done[]};    END;  -- DiskPageForFilePage  Done: ENTRY PROCEDURE = {    ENABLE UNWIND => NULL;    busyBit ¬ FALSE};  ExecProc: Exec.ExecProc =    BEGIN    ToolWindow.Activate[wh];    END;  Help: Exec.ExecProc =    BEGIN    h.OutputProc[]["This tool provides a way to find the disk location of a given file, specified by filename (string) or ID (string of form '[n, n]')."L];    END;  Init: PROCEDURE = {    Exec.AddCommand["FileOnDisk.~"L, ExecProc, Help, Unload];    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default,      clientTransition: ClientTransition, name: "FileOnDisk"L,      cmSection: "FileOnDisk"L];    };  InitFile: PROCEDURE RETURNS [BOOLEAN] =    BEGIN    fH: MFile.Handle;    fH ¬ MFile.Acquire[data.filename, readOnly, []      ! MFile.Error => GOTO notThere];    data.file ¬ SpecialMFile.GetCapaWithAccess[fH      ! File.Unknown => GOTO notThere];    MFile.Release[fH];    data.fileSize ¬ File.GetSize[data.file];    RETURN[TRUE];    EXITS      notThere => RETURN[FALSE];    END;  MakeForm: FormSW.ClientItemsProcType = {    nItems: CARDINAL = FormItems.LAST.ORD + 1;    items ¬ FormSW.AllocateItemDescriptor[nItems];    items[FormItems.filename.ORD] ¬ FormSW.StringItem[      tag: "Filename/ID"L, place: [4, FormSW.line0], inHeap: TRUE,      string: @data.filename, filterProc: ChangeFilename];    items[FormItems.filePage.ORD] ¬ FormSW.LongNumberItem[      tag: "File page "L, place: [4, FormSW.line1], signed: FALSE,      value: @data.filePage, proc: ChangeFilePage];    items[FormItems.next.ORD] ¬ FormSW.CommandItem[      tag: "Next"L, place: [203, FormSW.line1], proc: Next];    items[FormItems.back.ORD] ¬ FormSW.CommandItem[      tag: "Back"L, place: [250, FormSW.line1], proc: Back];    items[FormItems.diskPageForFilePage.ORD] ¬ FormSW.CommandItem[      tag: "DiskPageForFilePage"L, place: [4, FormSW.line2],      proc: DiskPageForFilePage];    items[FormItems.pvPage.ORD] ¬ FormSW.LongNumberItem[      tag: "PV page "L, place: [168, FormSW.line2], signed: FALSE,      readOnly: TRUE, value: @data.pvPage];    items[FormItems.showRuns.ORD] ¬ FormSW.CommandItem[      tag: "ShowRuns"L, place: [4, FormSW.line3],      proc: ShowRuns];    RETURN[items: items, freeDesc: TRUE];    };  MakeSWs: Tool.MakeSWsProc = {    logName: LONG STRING ¬ [18];    Tool.UnusedLogName[unused: logName, root: "FileOnDisk.log"L];    data.msgSW ¬ Tool.MakeMsgSW[window: window];    data.formSW ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    data.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    };  Msg: Format.StringProc = {Put.Text[data.msgSW, s]};  Next:  FormSW.ProcType = {    ENABLE ABORTED => {Done[]; CONTINUE};    IF Busy[] THEN {Msg["Tool is busy.\n"L]; RETURN};    MsgSW.Clear[data.msgSW];    IF data.filePage >= data.fileSize - 1 THEN UserTerminal.BlinkDisplay[]    ELSE       {data.filePage ¬ data.filePage + 1;       FormSW.DisplayItem[sw, FormItems.filePage.ORD];       data.pvPage ¬ 0;       FormSW.DisplayItem[sw, FormItems.pvPage.ORD]};    Done[] };  NoOp: Exec.ExecProc = { };  ShowRuns: FormSW.ProcType =    BEGIN ENABLE ABORTED => {Done[]; CONTINUE};    page: File.PageNumber;    run: BackingStore.Run;    IF Busy[] THEN {Msg["Tool is busy.\n"L]; RETURN};    MsgSW.Clear[data.msgSW];    IF InitFile[] THEN      BEGIN      Put.CR[data.fileSW];      Put.Text[data.fileSW, "file: "L];      Put.Text[data.fileSW, data.filename];      Put.CR[data.fileSW];      FOR page ¬ 0, page + run.count UNTIL page >= data.fileSize DO        run ¬ SpecialFile.GetBackingStoreRun[          data.file, page, FileTypes.tUnassigned].run;        Put.Text[data.fileSW, "  filePage: "L];        Put.LongDecimal[data.fileSW, page];        Put.Text[data.fileSW, ",  pvPage: "L];        Put.LongDecimal[data.fileSW,          DiskBackingStore.DiskDataFromBSData[run.data].volumePage];        Put.Text[data.fileSW, ",  count: "L];        Put.LongDecimal[data.fileSW, run.count];        Put.CR[data.fileSW];        ENDLOOP;      END    ELSE {Msg["Can't access file."L]; UserTerminal.BlinkDisplay[]};    Done[];    END;  Unload: Exec.ExecProc = {    IF Busy[] THEN {      Exec.OutputProc[h]["Tool is busy. Sorry.\n"L];      RETURN[error] };    IF wh # NIL THEN Tool.Destroy[wh];    wh ¬ NIL;    IF data # NIL THEN      {zone.FREE[@data];       data ¬ NIL};    Exec.RemoveCommand[h, "FileOnDisk.~"L];    Done[] };  -- Mainline code  Init[];  -- this gets string out of global frame  END...LOG 4-May-88  8:18:12   CAJ	Created file.
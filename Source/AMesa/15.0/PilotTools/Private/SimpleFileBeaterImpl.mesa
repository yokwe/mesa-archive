-- <>Work>SimpleFileBeaterImpl.mesa-- Copyright (C) 1988, 1989  by Fuji Xerox Co., Ltd., All rights reserved.--  4-Dec-88 10:22:02	TXT  creadtedDIRECTORY  File,  FileTypes,  Format,  Heap,  Put,  Window,  System,  Tool,  ToolWindow,  FormSW,  Volume,  MsgSW,  UserTerminal;SimpleFileBeater:PROGRAM  IMPORTS File, FormSW, Heap, MsgSW, Put, UserTerminal, Tool, Volume =  BEGIN    DataHandle: TYPE = LONG POINTER TO Data;  -- Elements less than a word long are carefully sandwiched between full-word  -- values so that tool addressing will come out right.  Data: TYPE = RECORD [    msgSW: Window.Handle ¬ NIL,    formSW: Window.Handle ¬ NIL,    fileSW: Window.Handle ¬ NIL,    fileSize: File.PageCount ¬ 0,    fileID: LONG CARDINAL ¬ 0,    file: File.File ¬ File.nullFile,    state: State ¬ stopped,    side: {left, right} ¬ right,    volume: Volume.ID ¬ Volume.nullID];  FormItems: TYPE = {fileSize, create, delete, shrink, grow, fileID};    State: TYPE = {running, stopped, stopping, deactivating};      numberVolumes: CARDINAL [0..10) ¬ 0;  volumes: ARRAY [0..10) OF System.VolumeID ¬ ALL[Volume.nullID];  currentVolume: System.VolumeID ¬ Volume.nullID;  data: DataHandle ¬ NIL;  wh: Window.Handle ¬ NIL;  zone: UNCOUNTED ZONE ¬ Heap.systemZone;  numberFormat: Format.NumberFormat = [    base: 10, zerofill: FALSE, unsigned: TRUE, columns: 10];      Init: PROCEDURE =    BEGIN    wh ¬ Tool.Create[makeSWsProc: MakeSWs, initialState: default,      clientTransition: ClientTransition, name: "SimpleFileBeater"L,      cmSection: "SimpleFileBeater"L]    END;  MakeSWs: Tool.MakeSWsProc =    BEGIN    logName: LONG STRING ¬ "SimpleFileBeater.log"L;    --Tool.UnusedLogName[unused: logName, root: "SimpleFileBeater.log"L];    data.msgSW ¬ Tool.MakeMsgSW[window: window];    data.formSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeForm];    data.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    END; -- MakeSWs      MakeForm: FormSW.ClientItemsProcType =    BEGIN    OPEN FormSW;    nItems: CARDINAL = FormItems.LAST.ORD + 1;    items ¬ AllocateItemDescriptor[nItems];        items[FormItems.fileSize.ORD] ¬ LongNumberItem[      tag: "File Size"L, place: [3, line0], signed: FALSE, notNegative: TRUE,      value: @data.fileSize];    items[FormItems.create.ORD] ¬ CommandItem[      tag: "Create"L, place: [20, nextLine], proc: CreateFile];    items[FormItems.delete.ORD] ¬ CommandItem[      tag: "Delete"L, place: [83, sameLine], proc: Delete];    items[FormItems.shrink.ORD] ¬ CommandItem[      tag: "Shrink"L, place: [139, sameLine], proc: Shrink];    items[FormItems.grow.ORD] ¬ CommandItem[      tag: "Grow"L, place: [196, sameLine], proc: Grow];    items[FormItems.fileID.ORD] ¬ LongNumberItem[      tag: "FileID"L, place: [250, sameLine], readOnly: TRUE, signed: FALSE, notNegative: TRUE,  default: 0, value: @data.fileID];        RETURN[items: items, freeDesc: TRUE];    END;-- MakeForm      -- Create   CreateFile: FormSW.ProcType =    BEGIN        file: File.File;    volume: System.VolumeID;    WriteLog: PROCEDURE [s: LONG STRING] ={Put.LongString[data.fileSW, s]};        WHILE (currentVolume ¬ Volume.GetNext[currentVolume]) # Volume.nullID DO      IF Volume.GetStatus[currentVolume] = openReadWrite THEN {        volumes[numberVolumes] ¬ currentVolume;	numberVolumes ¬ SUCC[numberVolumes]};      ENDLOOP;              IF numberVolumes IN [0..1) THEN {      MsgSW.Clear[data.msgSW];      MsgSW.Post[data.msgSW, "No Volume available"L];       UserTerminal.BlinkDisplay[];      RETURN};        IF data.fileSize = 0 THEN {      MsgSW.Clear[data.msgSW];      MsgSW.Post[data.msgSW, " 0 size file can't be created.."L];      UserTerminal.BlinkDisplay[];      RETURN};        Put.CR[data.fileSW];    WriteLog["Creating new file, its size : "L];    Put.LongNumber[data.fileSW, data.fileSize, numberFormat];    WriteLog[" ..."L];      volume ¬ volumes[0];    file ¬ File.Create[volume, data.fileSize, FileTypes.tUntypedFile!      Volume.InsufficientSpace => {        Put.CR[data.fileSW]; WriteLog["Can't Allocate such Big file!!!"L];	Put.CR[data.fileSW]; WriteLog["Free Space = "L];	Put.LongNumber[data.fileSW, currentFreeSpace, numberFormat];	UserTerminal.BlinkDisplay[];	WriteLog[" ... aborted"L]; GOTO ret}];        data.fileID ¬ LOOPHOLE[file.fileID, LONG CARDINAL];    data.file ¬ file;        WriteLog["Done"L];        FormSW.Display[data.formSW, 0];          EXITS      ret => RETURN    END;      -- Delete   Delete: FormSW.ProcType =     BEGIN     IF numberVolumes IN [0..1) OR data.fileID = 0 THEN {      MsgSW.Clear[data.msgSW];      MsgSW.Post[data.msgSW, "At first, You should call Create!"L];      UserTerminal.BlinkDisplay[]; RETURN};        IF data.file = File.nullFile THEN {      MsgSW.Clear[data.msgSW];      MsgSW.Post[data.msgSW, " It's curious..  nullFile is specified.."L];      UserTerminal.BlinkDisplay[]; RETURN};      Put.CR[data.fileSW];      Put.LongString[data.fileSW, "Deleting File  ID: "L];      Put.LongNumber[data.fileSW, data.fileID, numberFormat];      Put.LongString[data.fileSW, " ..."L];      File.Delete[data.file];      Put.LongString[data.fileSW, " Done"L];           END; -- Delete        -- Shrink   Shrink: FormSW.ProcType =    BEGIN        oldFileSize, newFileSize: File.PageCount ¬ 0;        IF numberVolumes IN [0..1) OR data.fileID = 0 THEN {      MsgSW.Clear[data.msgSW];      MsgSW.Post[data.msgSW, "At first, You should call Create!"L];      UserTerminal.BlinkDisplay[]; RETURN};        IF data.file = File.nullFile THEN {      MsgSW.Clear[data.msgSW];      MsgSW.Post[data.msgSW, " It's curious..  nullFile is specified.."L];      UserTerminal.BlinkDisplay[]; RETURN};           oldFileSize ¬  File.GetSize[data.file];        ChangeFileSize[data.file, oldFileSize, data.fileSize, shrink];        END;   -- Grow    Grow: FormSW.ProcType =    BEGIN    oldFileSize, newFileSize: File.PageCount ¬ 0;        IF numberVolumes IN [0..1) OR data.fileID = 0 THEN {      MsgSW.Clear[data.msgSW];      MsgSW.Post[data.msgSW, "At first, You should call Create!"L];      UserTerminal.BlinkDisplay[]; RETURN};        IF data.file = File.nullFile THEN {      MsgSW.Clear[data.msgSW];      MsgSW.Post[data.msgSW, " It's curious..  nullFile is specified.."L];      UserTerminal.BlinkDisplay[]; RETURN};           oldFileSize ¬  File.GetSize[data.file];        ChangeFileSize[data.file, oldFileSize, data.fileSize, grow]    END;   --   ChangeFileSize: PROCEDURE[file:File.File ¬ File.nullFile, oldSize, newSize: File.PageCount, op: {shrink, grow} ¬ shrink] =      BEGIN                Put.CR[data.fileSW];    Put.LongString[data.fileSW, IF op = shrink THEN "Shrink"L ELSE "Grow"L];    Put.LongString[data.fileSW, " File -- FileID: "L];    Put.LongNumber[data.fileSW, data.fileID, numberFormat]; Put.CR[data.fileSW];    Put.LongString[data.fileSW, "Old fileSize: "L];    Put.LongNumber[data.fileSW, oldSize, numberFormat];    Put.LongString[data.fileSW, "   New fileSize: "L];    Put.LongNumber[data.fileSW, newSize, numberFormat];    Put.LongString[data.fileSW, "  ..."L];        File.SetSize[file, newSize!      Volume.InsufficientSpace => {        Put.CR[data.fileSW]; Put.LongString[data.fileSW,"Can't Allocate such Big file!!!"L];	Put.CR[data.fileSW]; Put.LongString[data.fileSW, "Free Space = "L];	Put.LongNumber[data.fileSW, currentFreeSpace, numberFormat];	UserTerminal.BlinkDisplay[];	Put.LongString[data.fileSW, " ... Aborted"L]; GOTO ret}];        Put.LongString[data.fileSW, " Done"L];        EXITS      ret => RETURN;    END;  -- ChangeFileSize       ClientTransition: ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      old = inactive =>        IF data = NIL THEN	  {data ¬ zone.NEW[Data ¬ []]};      new = inactive =>        IF data # NIL THEN	  {zone.FREE[@data]};      ENDCASE;    END; -- Main   Init[];      END. LOG. 4-Dec-88 10:22:23	TXT 	created from FileBeaterImpl.mesa
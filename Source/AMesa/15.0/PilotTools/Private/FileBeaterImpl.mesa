-- FileBeaterImpl.mesa-- Copyright (C) 1986, 1988  by Xerox Corporation. All rights reserved. <<  Last edited by:  FormSWLayoutTool on  8-Aug-84  9:56  RSV                 11-Jul-88 11:39:53>>DIRECTORY  FileTypes USING [tUntypedFile],  File USING  [    Create, Delete, File, GetSize, nullFile, PageCount, SetSize],  Format USING [NumberFormat],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType, CommandItem,    Enumerated, EnumeratedItem, line0, line1, line2, LongNumberItem,    NumberItem, NumberNotifyProcType, ProcType],  Heap USING [systemZone],  MsgSW USING [Clear, Post],  Process USING [    Detach, DisableAborts, DisableTimeout, InitializeCondition, Pause, Priority,    priorityBackground, priorityForeground, priorityNormal, Seconds,    SecondsToTicks, SetPriority, SetTimeout, Yield],  Put USING [CR, LongNumber, LongString, Number],  RandomDefs USING [GeneratorState, InitializeRandom, Random],  Runtime USING [IsBound],  String USING [AppendChar, AppendLongDecimal],  System USING [VolumeID],  Time USING [AppendCurrent],  Tool USING [    Create, MakeFileSW, MakeFormSW, MakeMsgSW, MakeSWsProc, UnusedLogName],  ToolWindow USING [State, TransitionProcType],  UserTerminal USING [BlinkDisplay],  Volume USING [    ID, GetAttributes, GetNext, GetStatus, InsufficientSpace, nullID, systemID],  Window USING [Handle];FileBeaterImpl: MONITOR  IMPORTS      File, FormSW, Heap, MsgSW, Process, Put, RandomDefs, Runtime, String,      Time, Tool, UserTerminal, Volume =  BEGIN    UsingVFM: BOOLEAN = TRUE;    DataHandle: TYPE = LONG POINTER TO Data;  -- Elements less than a word long are carefully sandwiched between full-word  -- values so that tool addressing will come out right.  Data: TYPE = RECORD [    msgSW: Window.Handle ¬ NIL,    formSW: Window.Handle ¬ NIL,    fileSW: Window.Handle ¬ NIL,    randomSeed: LONG UNSPECIFIED ¬ 2097151,    processes: CARDINAL ¬ 10,    priority: Priorities ¬ background,    statsInterval: CARDINAL ¬ 30,    verbose: BOOLEAN ¬ FALSE,    forkedProcesses: CARDINAL ¬ 0,    state: State ¬ stopped,    volume: Volume.ID ¬ Volume.nullID,    stats: LONG POINTER TO Statistics ¬ NIL,    random: RandomDefs.GeneratorState ¬ TRASH,    savedState: MACHINE DEPENDENT RECORD [      processes(0): CARDINAL ¬ 0,      priority(1): Priorities ¬ background,      randomSeed(2): LONG UNSPECIFIED ¬ 2097151]    ];  FormItems: TYPE = {randomSeed,    processes, priority, start, stats, stop, statsInterval, verbose};    Priorities: TYPE = MACHINE DEPENDENT {    background(0), normal(1), forground(2), random(3)};    State: TYPE = {running, stopped, stopping, deactivating};  StatData: TYPE = RECORD [    createdFiles: LONG CARDINAL ¬ 0,    deletedFiles: LONG CARDINAL ¬ 0,    grownFiles: LONG CARDINAL ¬ 0,    shrunkFiles: LONG CARDINAL ¬ 0];  Statistics: TYPE =  ARRAY [0..1) OF StatData;  numberVolumes: CARDINAL [0..10) ¬ 0;  volumes: ARRAY [0..10) OF System.VolumeID ¬ ALL[Volume.nullID];  currentVolume: System.VolumeID ¬ Volume.nullID;    --VolumeData: TYPE = RECORD [  --  selected: BOOLEAN ¬ TRUE,  --  volume: Volume.ID ¬ Volume.nullID,  --  label: LONG STRING];  --Volumes: TYPE = ARRAY [0..maxDrives) OF VolumeData;    fileCount: CARDINAL ¬ 0;  maxNumberOfFiles: CARDINAL = 500;  arrayOfFile: ARRAY [0..maxNumberOfFiles) OF File.File;    maxPagesPerFile: File.PageCount = LAST[CARDINAL];    data: DataHandle ¬ NIL;  wh: Window.Handle ¬ NIL;  zone: UNCOUNTED ZONE ¬ Heap.systemZone;  processStopped: CONDITION;  statsInterval: CONDITION;    numberFormat: Format.NumberFormat = [    base: 10, zerofill: FALSE, unsigned: TRUE, columns: 10];  Start: ENTRY FormSW.ProcType =    BEGIN    ENABLE UNWIND => NULL;    MsgSW.Clear[data.msgSW];    SELECT data.state FROM      running =>        BEGIN	MsgSW.Post[data.msgSW, "AlreadyRunning!"L];	UserTerminal.BlinkDisplay[];	RETURN;	END;      stopping => WHILE data.forkedProcesses > 0 DO WAIT processStopped ENDLOOP;      stopped =>        BEGIN	time: LONG STRING ¬ [64];	IF ~Runtime.IsBound[LOOPHOLE[RandomDefs.InitializeRandom]] THEN	  BEGIN	  MsgSW.Post[data.msgSW, "Please load an implementation of RandomDefs!"L];	  UserTerminal.BlinkDisplay[];	  RETURN;	  END;	data.savedState ¬	  [data.processes, data.priority, data.randomSeed];	data.random.seed ¬ data.randomSeed;	RandomDefs.InitializeRandom[@data.random];	data.state ¬ running;	Put.LongString[data.fileSW, "Starting with "L];        Put.Number[	  data.fileSW, data.processes,	  [base: 10, zerofill: FALSE, unsigned: TRUE, columns: 0]];        Put.LongString[data.fileSW, " processes, random seed of "L];	Put.LongNumber[	  data.fileSW, data.randomSeed,	  [base: 10, zerofill: FALSE, unsigned: TRUE, columns: 0]];	Put.LongString[data.fileSW, ", at "L];	Time.AppendCurrent[time];	Put.LongString[data.fileSW, time];        Put.CR[data.fileSW];	data.volume ¬ Volume.systemID;	data.stats[0] ¬	  [createdFiles: 0, deletedFiles: 0, grownFiles: 0, shrunkFiles: 0];		-- enumerate and find all open volumes of same type	numberVolumes ¬ 0;	WHILE (currentVolume ¬ Volume.GetNext[currentVolume]) # Volume.nullID DO	  IF Volume.GetStatus[currentVolume] = openReadWrite THEN {	    volumes[numberVolumes] ¬ currentVolume;	    numberVolumes ¬ numberVolumes + 1;};	  ENDLOOP;        THROUGH [0..data.processes) DO          Process.Detach[FORK BeaterProcess[]];          data.forkedProcesses ¬ data.forkedProcesses+1;          ENDLOOP;	IF ~data.verbose AND (data.statsInterval > 0)	  THEN BEGIN          Put.CR[data.fileSW];	  Put.LongString[data.fileSW,	    "Key: [file creates/deletes/grows/shrinks]"L];          Put.CR[data.fileSW];	  END;	data.forkedProcesses ¬ data.forkedProcesses+1;	Process.Detach[FORK StatsReporter[]];	END;      ENDCASE =>        BEGIN	MsgSW.Post[data.msgSW, "Unexpected Endcase!"L];	UserTerminal.BlinkDisplay[];	RETURN;	END;    END;  Stats:  FormSW.ProcType =    BEGIN    time: LONG STRING ¬ [64];    Put.CR[data.fileSW];    Put.LongString[data.fileSW, "Statistics at "L];    Time.AppendCurrent[time];    Put.LongString[data.fileSW, time];    Put.CR[data.fileSW];    -- build string, then print it)    Put.LongString[data.fileSW, "  Files created:   "L];      Put.LongNumber[data.fileSW, data.stats[0].createdFiles, numberFormat];      Put.CR[data.fileSW];    Put.LongString[data.fileSW, "  Files deleted: "L];      Put.LongNumber[data.fileSW, data.stats[0].deletedFiles, numberFormat];      Put.CR[data.fileSW];    Put.LongString[data.fileSW, "  Files Grown :      "L];      Put.LongNumber[data.fileSW, data.stats[0].grownFiles, numberFormat];      Put.CR[data.fileSW];    Put.LongString[data.fileSW, "  File Shrunk:     "L];      Put.LongNumber[data.fileSW, data.stats[0].shrunkFiles, numberFormat];      Put.CR[data.fileSW];    Put.CR[data.fileSW];    END;  Stop: ENTRY FormSW.ProcType =    BEGIN    MsgSW.Clear[data.msgSW];    IF data.state ~= running THEN      BEGIN      MsgSW.Post[data.msgSW, "Not running!"L];      UserTerminal.BlinkDisplay[];      RETURN;      END;    Put.LongString[data.fileSW, "Stopping all processes..."L];    data.state ¬ stopped;    BROADCAST statsInterval;  -- knock everybody out of WAIT in case it's long    WHILE data.forkedProcesses > 0 DO WAIT processStopped ENDLOOP;    Put.LongString[data.fileSW, "stopped."L];    Put.CR[data.fileSW];    data.volume ¬ Volume.nullID;    END;  ClientTransition: ENTRY ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      old = inactive =>        IF data = NIL THEN	  {data ¬ zone.NEW[Data ¬ []];	  data.stats ¬ zone.NEW[Statistics]};      new = inactive =>        IF data # NIL THEN	  {zone.FREE[@data.stats]; zone.FREE[@data]};      ENDCASE;    END;  Init: PROCEDURE =    BEGIN    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default,      clientTransition: ClientTransition, name: "FileBeater"L,      cmSection: "FileBeater"L];    Process.InitializeCondition[      @statsInterval, Process.SecondsToTicks[data.statsInterval]];    Process.DisableAborts[@statsInterval];    END;  MakeSWs: Tool.MakeSWsProc =    BEGIN    logName: LONG STRING ¬ [21];    Tool.UnusedLogName[unused: logName, root: "FileBeaterImpl.log"L];    data.msgSW ¬ Tool.MakeMsgSW[window: window];    data.formSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeForm];    data.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    END;  MakeForm: FormSW.ClientItemsProcType =    BEGIN    OPEN FormSW;    nItems: CARDINAL = FormItems.LAST.ORD + 1;    priority: ARRAY[0..4) OF Enumerated ¬ [      ["background"L, 0], ["normal"L, 1],      ["foreground"L, 2], ["random"L, 3]];    items ¬ AllocateItemDescriptor[nItems];    items[FormItems.randomSeed.ORD] _ LongNumberItem[      tag: "Random Seed"L, place: [3, line0], signed: FALSE, notNegative: TRUE,      value: @data.randomSeed];    items[FormItems.processes.ORD] _ NumberItem[      tag: "# Processes"L, place: [3, line1], signed: FALSE,      notNegative: TRUE, value: @data.processes];    items[FormItems.priority.ORD] _ EnumeratedItem[      tag: "Priority"L, place: [230, line1], choices: DESCRIPTOR[priority],      value: @data.priority];    items[FormItems.start.ORD] _ CommandItem[      tag: "Start"L, place: [26, line2], proc: Start];    items[FormItems.stats.ORD] _ CommandItem[      tag: "Stats"L, place: [83, line2], proc: Stats];    items[FormItems.stop.ORD] _ CommandItem[      tag: "Stop"L, place: [139, line2], proc: Stop];    items[FormItems.statsInterval.ORD] _ NumberItem[      tag: "Stats interval (seconds) "L, place: [209, line2], signed: FALSE,      notNegative: TRUE, value: @data.statsInterval, proc: StatsIntervalChange];    items[FormItems.verbose.ORD] _ BooleanItem[      tag: "verbose"L, place: [432, line2], switch: @data.verbose];    RETURN[items: items, freeDesc: TRUE];    END;  BeaterProcess: PROCEDURE [] =  --CHANGE--    BEGIN    BEGIN ENABLE ABORTED => GO TO Return;    pause: CARDINAL ¬ 10;    deleteFile: CARDINAL ¬ 30;    createFile: CARDINAL ¬ 50;    growFile: CARDINAL ¬ 70;    shrinkFile: CARDINAL ¬ 90;    switchPriority: CARDINAL = 100;    IncrementLongCardinal: ENTRY PROCEDURE [lc: LONG POINTER TO LONG CARDINAL] =      {lc^ ¬ lc^+1};    Stop: ENTRY PROCEDURE RETURNS [BOOLEAN] =      {RETURN [data.state ~= running]};          PickAFile: ENTRY PROCEDURE [] RETURNS [file: File.File] =      BEGIN      fileNumber: CARDINAL;      IF fileCount = 0 THEN RETURN [File.nullFile];      fileNumber ¬ RandomDefs.Random[@data.random, fileCount-1];      file ¬ arrayOfFile[fileNumber];      FOR i: CARDINAL IN [fileNumber..fileCount - 1) DO        arrayOfFile[i] ¬ arrayOfFile[i + 1];	ENDLOOP;      fileCount ¬ fileCount - 1;      END;          StoreAFile: ENTRY PROCEDURE [file: File.File] =      BEGIN      arrayOfFile[fileCount] ¬ file;      fileCount ¬ fileCount + 1;      END;          WaitABit: PROCEDURE = {Process.Pause[1+RandomNumber[100]]};    Process.SetPriority[      SELECT data.savedState.priority FROM        background => Process.priorityBackground,	normal => Process.priorityNormal,	forground => Process.priorityForeground,	random => RandomPriority[],	ENDCASE => Process.priorityBackground];    UNTIL Stop[] DO      createdFile: BOOLEAN;      file: File.File;      fileSize: File.PageCount;      FOR i: CARDINAL IN [0..numberVolumes) DO        volume: System.VolumeID ¬ volumes[i];	DO	  fileSize ¬ RandomFileSize[volume, 0];	  IF fileSize = 0 THEN EXIT;	  file ¬	    File.Create[volume, fileSize, FileTypes.tUntypedFile !	      Volume.InsufficientSpace =>		BEGIN		createdFile ¬ FALSE;		IF currentFreeSpace < (Volume.GetAttributes[volume].volumeSize / 20) THEN EXIT		ELSE fileSize ¬ RandomFileSize[volume, 0];		IF fileSize = 0 THEN EXIT;		WaitABit[];		RETRY;		END];	  IncrementLongCardinal[@data.stats[0].createdFiles];	  StoreAFile[file];	  IF Stop[] THEN GO TO Return ELSE WaitABit[];	  ENDLOOP;	ENDLOOP;  -- fill up all the volumes.	            DO -- until told to stop or no more files to work on (in which case, start      -- above and go again        IF Stop[] THEN EXIT; -- and kill ourselves	Process.Yield[]; -- for politeness!        SELECT RandomNumber[100] FROM	  IN [0..pause) => WaitABit[];	  IN [pause..deleteFile) => 	    BEGIN	    file ¬ PickAFile[];	    IF file = File.nullFile THEN EXIT;	    IF Volume.GetAttributes[file.volumeID].freePageCount >	      (Volume.GetAttributes[file.volumeID].volumeSize / 5) THEN {	      StoreAFile[file];	      LOOP;};	    File.Delete[file];	    IncrementLongCardinal[@data.stats[0].deletedFiles];	    END;	  IN [deleteFile..createFile) =>	    BEGIN	    volume: System.VolumeID ¬ volumes[RandomNumber[numberVolumes]];	    fileSize ¬ RandomFileSize[volume, 0];	    IF fileSize = 0 THEN LOOP;	    createdFile ¬ TRUE;            file ¬              File.Create[volume, fileSize, FileTypes.tUntypedFile !	        Volume.InsufficientSpace =>		  BEGIN 		  createdFile ¬ FALSE;		  CONTINUE;		  END];	    IF createdFile THEN	      BEGIN	      IncrementLongCardinal[@data.stats[0].createdFiles];	      StoreAFile[file];	      END;	    END;	  IN [createFile..growFile) =>	    BEGIN	    grewFile: BOOLEAN ¬ TRUE;	    newSize: File.PageCount;	    fileSize: File.PageCount;	    file ¬ PickAFile[];	    IF file = File.nullFile THEN EXIT;	    fileSize ¬ File.GetSize[file];	    newSize ¬ RandomFileSize[file.volumeID, fileSize];	    IF newSize = 0 THEN {StoreAFile[file]; LOOP};	    File.SetSize[file, newSize !	      Volume.InsufficientSpace =>	        BEGIN	        grewFile ¬ FALSE;		CONTINUE;		END];	    IF grewFile THEN IncrementLongCardinal[@data.stats[0].grownFiles];	    StoreAFile[file];	    END;	  IN [growFile..shrinkFile) =>	    BEGIN	    shrankFile: BOOLEAN ¬ TRUE;	    newSize: File.PageCount;	    fileSize: File.PageCount;            file ¬ PickAFile[];            IF file = File.nullFile THEN EXIT;	    IF Volume.GetAttributes[file.volumeID].freePageCount >	      (Volume.GetAttributes[file.volumeID].volumeSize / 5) THEN {	      StoreAFile[file];	      LOOP;};	    fileSize ¬ File.GetSize[file];	    newSize ¬ 1 + RandomNumber[CARDINAL[fileSize - 1]];	    File.SetSize[file, newSize];	    IncrementLongCardinal[@data.stats[0].shrunkFiles];	    StoreAFile[file];	    END;	  IN [shrinkFile..switchPriority) =>	    IF data.savedState.priority = random THEN	      Process.SetPriority[RandomPriority[]]	    ELSE NULL; -- and try again for a new command	  ENDCASE;        ENDLOOP;      ENDLOOP;    GO TO Return;    END    EXITS    Return =>      BEGIN      Dying: ENTRY PROCEDURE =        BEGIN	data.forkedProcesses ¬ data.forkedProcesses-1;	NOTIFY processStopped;	END;      Dying[];      END;    END;  -- BeaterProcess  BriefStats: PROCEDURE =    BEGIN    s: STRING = [45];    String.AppendChar[s, '[];    String.AppendLongDecimal[s, data.stats[0].createdFiles];    String.AppendChar[s, '/];    String.AppendLongDecimal[s, data.stats[0].deletedFiles];    String.AppendChar[s, '/];    String.AppendLongDecimal[s, data.stats[0].grownFiles];    String.AppendChar[s, '/];    String.AppendLongDecimal[s, data.stats[0].shrunkFiles];    String.AppendChar[s, ']];    Put.LongString[data.fileSW, s];    END;  RandomFileSize: ENTRY PROCEDURE [volume: Volume.ID, minimum: File.PageCount]    RETURNS [size: File.PageCount] =    BEGIN    maxFileSize: CARDINAL =      CARDINAL [        MIN [ maxPagesPerFile,	  IF UsingVFM THEN MAX[	    (Volume.GetAttributes[volume].freePageCount - 15), 0]	    --(Volume.GetAttributes[volume].freePageCount - Volume.GetAttributes[volume].volumeSize/5), 0]	  ELSE Volume.GetAttributes[volume].freePageCount]];    SELECT maxFileSize FROM      --0, 1 => RETURN [maxFileSize];      0, 1 => RETURN [0];      ENDCASE =>        RETURN [minimum + 1 +	  LONG[RandomDefs.Random[@data.random, maxFileSize - CARDINAL[(minimum + 1)]]]];    END;  RandomNumber: ENTRY PROCEDURE [max: CARDINAL] RETURNS [CARDINAL] =    {RETURN [RandomDefs.Random[@data.random, max]]};  RandomPriority: ENTRY PROCEDURE [] RETURNS [prority: Process.Priority] =    BEGIN    RETURN [      SELECT RandomDefs.Random[@data.random, 100] FROM        < 50 => Process.priorityBackground,        < 75 => Process.priorityNormal,        < 100 => Process.priorityForeground,        ENDCASE => Process.priorityBackground -- should never get here      ];    END;  StatsIntervalChange: FormSW.NumberNotifyProcType =    -- [sw: Window.Handle, item: FormSW.ItemHandle, index: CARDINAL,    --  oldValue: UNSPECIFIED]    BEGIN    ExchangeTimeout: ENTRY PROCEDURE =      {BROADCAST statsInterval};    IF data.statsInterval > 0 THEN      BEGIN      Process.SetTimeout[condition: @statsInterval,        ticks: Process.SecondsToTicks[data.statsInterval]];      IF oldValue = 0 THEN        {Put.LongString[data.fileSW, "Stats feedback enabled"L];	 Put.CR[data.fileSW]};      END    ELSE      BEGIN      Process.DisableTimeout[condition: @statsInterval];      Put.LongString[data.fileSW, "Stats feedback disabled"L];      Put.CR[data.fileSW];      END;    ExchangeTimeout[];    END;  StatsReporter: PROCEDURE =    BEGIN    Stop: ENTRY PROCEDURE RETURNS [BOOLEAN] =      BEGIN      WAIT statsInterval;      RETURN [data.state ~= running];      END;    KillingOurselves: ENTRY PROCEDURE =      BEGIN      data.forkedProcesses ¬ data.forkedProcesses-1;      NOTIFY processStopped;      END;    Process.SetPriority[Process.priorityForeground];    WHILE ~Stop[] DO      IF data.verbose THEN Stats[] ELSE BriefStats;      ENDLOOP;    KillingOurselves[];    END;  -- Mainline code  Init[];  -- this gets string out of global frame  END...  -- LOG-- RSV 11-Jul-88 11:40:11 Fixed BeaterProcess to not crash on Creating 0 length files during initialization loop on RETRY's.
-- Copyright (C) 1983, 1987  by Xerox Corporation. All rights reserved. -- File: PageScavengerInt.mesa - last edit by:-- RSV          25-Dec-87 17:05:35 For Labelless.-- PXK    	 9-Mar-83 11:59:05DIRECTORY  Format USING [CR, Line, LongDecimal, StringProc],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType,    CommandItem, newLine, NumberItem, ProcType, StringItem],  Heap USING [systemZone],  PageScavenger USING [    Action, DeviceIndex, DiskStatus, Error, PageNumber, Scavenge],  Put USING [CR, Line, Text],  String USING [InvalidNumber, StringToLongNumber],  Token USING [FreeStringHandle, FreeTokenString, Handle, Item, StringToHandle],  Tool USING [    Create, MakeFileSW, MakeFormSW, MakeMsgSW, MakeSWsProc, UnusedLogName],  ToolWindow USING [TransitionProcType],  UserTerminal USING [BlinkDisplay],  Window USING [Handle];PageScavengerInt: PROGRAM  IMPORTS    Format, FormSW, Heap, PageScavenger, Put, String, Token, Tool, UserTerminal =  BEGIN  -- TYPEs  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = RECORD [    msgSW: Window.Handle ¬ NIL,    fileSW: Window.Handle ¬ NIL,    firstTime: BOOLEAN ¬ TRUE,    formSW: Window.Handle ¬ NIL,    writable: BOOLEAN ¬ TRUE,    pages: LONG STRING ¬ NIL,    drive: PageScavenger.DeviceIndex ¬ 0];  notAPage: PageScavenger.PageNumber = LAST[PageScavenger.PageNumber];  toolData: DataHandle ¬ NIL;  toolWindow: Window.Handle;  LogProc: Format.StringProc = {Put.Text[toolData.fileSW, s]};      ScavengeSomePages: FormSW.ProcType = {    diskPage: PageScavenger.PageNumber;    tokenHandle: Token.Handle;    gotAPage: BOOLEAN ¬ FALSE;    Put.CR[toolData.msgSW];    IF toolData.firstTime THEN toolData.firstTime ¬ FALSE    ELSE Put.CR[toolData.fileSW];    IF toolData.pages # NIL THEN {      tokenHandle ¬ Token.StringToHandle[toolData.pages];      DO        s: LONG STRING = Token.Item[tokenHandle];	IF s = NIL THEN EXIT;	diskPage ¬ String.StringToLongNumber[s, 10 ! String.InvalidNumber => {	  Put.Text[toolData.msgSW, s];	  Put.Line[toolData.msgSW, ": invalid Number"L];	  diskPage ¬ notAPage;	  CONTINUE}];	IF diskPage # notAPage THEN {	  gotAPage ¬ TRUE;	  ScavengeOnePage[LogProc, diskPage, toolData.drive, toolData.writable]};	[] ¬ Token.FreeTokenString[s];	ENDLOOP;      [] ¬ Token.FreeStringHandle[tokenHandle]};    IF ~gotAPage THEN Put.Line[toolData.msgSW, "Please specify a page number."L]};          ScavengeOnePage: PROC [    log: Format.StringProc, diskPage: PageScavenger.PageNumber,    device: PageScavenger.DeviceIndex, overWrite: BOOLEAN] =    BEGIN    action: PageScavenger.Action;    contentsReliable: BOOLEAN;    diskStatus: PageScavenger.DiskStatus;    [action, contentsReliable, diskStatus] ¬       PageScavenger.Scavenge[device, diskPage, overWrite !          PageScavenger.Error => {	    Format.Line[	      proc: log,	      s: SELECT errorType FROM		driveNotAvailable => "Error[Drive not available]"L,		driveNotReady => "Error[Drive not ready]"L,		invalidPageNumber => "Error[Invalid page number]"L,		unknownDrive => "Error[Unknown drive]"L,		ENDCASE => "Unknown error variant"L];	     GO TO failed}];    log["Action: "L];       log[SELECT action FROM              fixDataCRCError => "fixDataCRCError"L,	      fixHardware => "fixHardware"L,	      boot => "boot"L,	      lvScavenge => "lvScavenge"L,	      pvScavenge => "pvScavenge"L,	      ENDCASE => "Unknown action"L];    log[".  Initial disk status is "L];       log[SELECT diskStatus FROM              goodCompletion => "goodCompletion"L,	      noSuchPage => "noSuchPage"L,	      seekFailed => "seekFailed"L,	      checkError => "checkError"L,	      dataError => "dataError"L,	      hardwareError => "hardwareError"L,	      notReady => "notReady"L,	      ENDCASE => "Unknown disk status"L];       Format.CR[log];    log["     "L];       Format.LongDecimal[log, diskPage];       log[" now has "L];       log[IF contentsReliable THEN "reliable"L ELSE "unreliable"L];       log[" contents."L];    Format.CR[log];    EXITS failed => UserTerminal.BlinkDisplay[];    END;  -- Tool needed routines  Transit: ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      old = inactive =>        IF toolData = NIL THEN toolData ¬ Heap.systemZone.NEW[Data ¬ []];      new = inactive =>        IF toolData # NIL THEN  Heap.systemZone.FREE[@toolData];      ENDCASE;    END;  Init: PROCEDURE =    BEGIN    toolWindow ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default,      clientTransition: Transit, name: "Page Scavenger Tool"L,      cmSection: "PageScavengerTool"L,      tinyName1: "Page"L, tinyName2: "Scavenger"L];    END;  MakeForm: FormSW.ClientItemsProcType =    BEGIN OPEN FormSW;    nItems: CARDINAL = 4;    items ¬ AllocateItemDescriptor[nItems];    items[0] ¬ CommandItem[      tag: "Scavenge"L, place: newLine, proc: ScavengeSomePages];    items[1] ¬ NumberItem[      tag: "RD"L, signed: FALSE, notNegative: TRUE,      boxWidth: 30, value: @toolData.drive];    items[2] ¬ BooleanItem[tag: "ReWrite"L, switch: @toolData.writable];    items[3] ¬ StringItem[tag: "Pages"L, string: @toolData.pages,inHeap: TRUE];    RETURN[items: items, freeDesc: TRUE];    END;  MakeSWs: Tool.MakeSWsProc =    BEGIN    nameRoot: STRING = "PageScavenger.log"L;    logName: STRING ¬ [17 + 4]; -- stupid compiler    Tool.UnusedLogName[unused: logName, root: nameRoot];    toolData.msgSW ¬ Tool.MakeMsgSW[window: window];    toolData.formSW ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    toolData.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    END;  -- Mainline code  Init[];  -- this gets string out of global frame  END...  
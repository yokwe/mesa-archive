-- Copyright (C) 1983, 1987  by Xerox Corporation. All rights reserved. -- TryPack.mesa    last edited by: RSV          27-Mar-87 15:05:06-- Test software for Pilot-- TryPack implements procedures to help its clients attempt Pilot operations and check the results.  Try uses the large enumerated type "SigsetDefs.Sig", that names all of Pilot's public signals, and "SigsetDefs.Sigset" objects, which are "sets" of values of type Sig.DIRECTORY  ByteBlt USING [StartIndexGreaterThanStopIndexPlusOne],  File USING [Error, MissingPages, Unknown],  Heap USING [Error],  PhysicalVolume USING [Error, NeedsScavenging],  PhysicalVolumeExtras USING [ErrorExtras],  PostAuxDefs USING [GetCurrentTick, Tick],  PostDefs USING [crString, Post, PostLine],  Process USING [InvalidProcess, TooManyProcesses],  Runtime USING [BoundsFault, CallDebugger, ConfigError, ControlFault,    DivideCheck, InvalidFrame, InvalidGlobalFrame, LinkageFault, NarrowFault,    PointerFault, PortFault, StartFault, UnboundProcedure, VersionMismatch,    ZeroDivisor],  Scavenger USING [Error],  SigsetAuxDefs USING [SigFromFileErrorType, SigFromHeapErrorType,    SigFromPhysicalVolumeErrorType, SigFromPhysicalVolumeExtrasErrorType,    SigFromRuntimeConfigErrorType, SigFromScavengerErrorType,    SigFromSpaceErrorType, SigFromTemporaryBootingExtrasErrorType,    SigFromVolumeErrorType, SigFromVolumeRootDirectoryErrorType],  SigsetDefs USING [Aqsigset, IsIn, Error, Monad, StringFromSig,    StringFromSigset],  Space USING [Error, InsufficientSpace, IOError],  SpecialRuntime USING [ResumeError],  Stream USING [Attention, EndOfStream, InvalidOperation, LongBlock, ShortBlock,    SSTChange, TimeOut],  String USING [EmptyString],  TemporaryBooting USING [InvalidParameters, InvalidVersion],  TemporaryBootingExtras USING [BootableFileError, MultiGroupUCodeOrGerm],  TryDefs,  UserTerminal USING [BitmapIsDisconnected],  Volume USING [Error, InsufficientSpace, NeedsScavenging, NotOnline, NotOpen,    ReadOnly, RootDirectoryError, Unknown],  VolumeExtras USING [AlreadyReadOpen, AlreadyWriteOpen];TryPack: PROGRAM  IMPORTS     ByteBlt, File, Heap, PhysicalVolume, PhysicalVolumeExtras, PostAuxDefs,    PostDefs, Process, Runtime, Scavenger, SigsetAuxDefs, SigsetDefs, Space,    SpecialRuntime, Stream, String, TemporaryBooting, TemporaryBootingExtras,    UserTerminal, Volume, VolumeExtras  EXPORTS TryDefs =BEGIN OPEN TryDefs;------------------------------------------ Global types, constants, and variablesbreakOnWarningFlag: BOOLEAN ¬ FALSE; -- May be set via the debugger.logNonRecoverableFlag: BOOLEAN ¬ FALSE; -- May be set via the debugger.------------------------------------------ Public procedures:  Get/Set TryPack's state.GetBreakOnWarning: PUBLIC PROCEDURE RETURNS [BOOLEAN] =  {RETURN[breakOnWarningFlag]};GetLoggingNonRecoverable: PUBLIC PROCEDURE RETURNS [BOOLEAN] =  {RETURN[logNonRecoverableFlag]};SetBreakOnWarning: PUBLIC PROCEDURE [newState: BOOLEAN] =  {breakOnWarningFlag ¬ newState};SetLoggingNonRecoverable: PUBLIC PROCEDURE [newState: BOOLEAN] =  {logNonRecoverableFlag ¬ newState};------------------------------------------ Special Public procedure CatchThisSignal.  -- Call CatchIt (from the client or from the debugger) if Try* has let an  -- unknown (ANY) resumable signal go by, and you want it to "catch" the  -- signal and continue.  (If the signal is non-resumable, merely Proceed  -- from the debugger, and Try* will catch the ResumeError.)CatchIt: PUBLIC PROCEDURE = {ERROR CatchThisUnknownSignal};------------------------------------------ Public procedures:  Trying Pilot operations  -- Ck: checks that 'ok' is TRUE.  If not, Ck logs a message in the  -- typescript and raises a signal to the debugger.  The string arguments are  -- included in both the logged message and the signal.Ck: PUBLIC PROCEDURE [aspect: LONG STRING, testee: LONG STRING ¬ NIL,   ok: BOOLEAN, warning: BOOLEAN ¬ FALSE] =  BEGIN  IF NOT ok    THEN BEGIN    heading: ARRAY BOOLEAN OF LONG STRING =      [FALSE: "Check of ", TRUE: "Warning--Check of "];    testeePrefix: ARRAY BOOLEAN OF LONG STRING = [FALSE: " of ", TRUE: NIL];    tick: PostAuxDefs.Tick = PostAuxDefs.GetCurrentTick[];    PostDefs.PostLine[heading[warning],      IF String.EmptyString[aspect] THEN LONG["something"L] ELSE aspect,      testeePrefix[String.EmptyString[testee]], testee, " failed."L];    IF ~warning OR breakOnWarningFlag      THEN SIGNAL CheckFailed[aspect: aspect, testee: testee, tick: tick];    END;  END;Ck1: PUBLIC PROCEDURE [aspect: LONG STRING, testee: LONG STRING ¬ NIL,   ok: BOOLEAN, warning: BOOLEAN ¬ FALSE] RETURNS [BOOLEAN] =  BEGIN  IF NOT ok THEN Ck[aspect, testee, FALSE, warning]; -- Else noop.  RETURN[ok];  END;-- The "Try" procedures execute some trial code in an environment that is prepared to catch any Pilot signals that may arise.  For more documentation, see the interface TryDefs.  -- TryP is the first form of "Try" procedure.  It takes the trial opertion  -- in the form of a procedure to invoke, and the mask in the form of a  -- Sigset.  All the other forms are implemented in terms of TryP.TryP: PUBLIC PROCEDURE [trial: PROCEDURE, mask: Sigset,    comment1, comment2, comment3: LONG STRING ¬ NIL] RETURNS [actual: Sig] =  BEGIN  letAnAnyPass: BOOLEAN ¬ FALSE; -- Did we see an ANY but not accept it?  Report: PROCEDURE [actualSig: Sig] =    BEGIN -- Log an error if actualSig wasn't one of the things we expected.    actual ¬ actualSig;    IF ~SigsetDefs.IsIn[mask, actualSig]      THEN LogError[actualSig, mask, comment1, comment2, comment3];    RETURN;    END;  ReportOther: PROCEDURE RETURNS [acceptTheSignal: BOOLEAN] =    BEGIN -- Catching ANY is a very special case...    actual ¬ other;    acceptTheSignal ¬ LogOther[letAnAnyPass, SigsetDefs.IsIn[mask, other],      comment1, comment2, comment3];    RETURN;    END;  ReportResumeError: PROCEDURE =    {IF actual = none THEN actual ¬ other; LogResumeError[]; RETURN};  IF SigsetDefs.IsIn[mask, nonRecoverable] THEN    {LogNonRecoverable[comment1, comment2, comment3]; RETURN[nonRecoverable]};  actual ¬ none; -- to satisfy the compiler's checks of initialized variables  BEGIN OPEN SigsetAuxDefs;  trial[ !    ByteBlt.StartIndexGreaterThanStopIndexPlusOne =>      {Report[byteBltStartIndexGreaterThanStopIndexPlusOne]; GOTO ErrorExit};    File.MissingPages =>      {Report[fileMissingPages]; GOTO ErrorExit};    File.Unknown =>      {Report[fileUnknown]; GOTO ErrorExit};    File.Error =>      {Report[SigFromFileErrorType[type]]; GOTO ErrorExit};    Heap.Error =>      {Report[SigFromHeapErrorType[type]]; GOTO ErrorExit};    PhysicalVolume.Error =>      {Report[SigFromPhysicalVolumeErrorType[error]]; GOTO ErrorExit};    PhysicalVolume.NeedsScavenging =>      {Report[physicalVolumeNeedsScavenging]; GOTO ErrorExit};    PhysicalVolumeExtras.ErrorExtras =>      {Report[SigFromPhysicalVolumeExtrasErrorType[error]]; GOTO ErrorExit};    Process.InvalidProcess =>      {Report[processInvalidProcess]; GOTO ErrorExit};    Process.TooManyProcesses =>      {Report[processTooManyProcesses]; GOTO ErrorExit};    Runtime.BoundsFault =>      {Report[runtimeBoundsFault]; GOTO ErrorExit};    Runtime.ConfigError =>      {Report[SigFromRuntimeConfigErrorType[type]]; GOTO ErrorExit};    Runtime.ControlFault =>      {Report[runtimeControlFault]; GOTO ErrorExit};    Runtime.DivideCheck =>      {Report[runtimeDivideCheck]; GOTO ErrorExit};    Runtime.InvalidFrame =>      {Report[runtimeInvalidFrame]; GOTO ErrorExit};    Runtime.InvalidGlobalFrame =>      {Report[runtimeInvalidGlobalFrame]; GOTO ErrorExit};    Runtime.LinkageFault =>      {Report[runtimeLinkageFault]; GOTO ErrorExit};    Runtime.NarrowFault =>      {Report[runtimeNarrowFault]; GOTO ErrorExit};    Runtime.PointerFault =>      {Report[runtimePointerFault]; GOTO ErrorExit};    Runtime.PortFault =>      {Report[runtimePortFault]; GOTO ErrorExit};    Runtime.StartFault =>      {Report[runtimeStartFault]; GOTO ErrorExit};    Runtime.UnboundProcedure =>      {Report[runtimeUnboundProcedure]; GOTO ErrorExit};    Runtime.VersionMismatch =>      {Report[runtimeVersionMismatch]; GOTO ErrorExit};    Runtime.ZeroDivisor =>      {Report[runtimeZeroDivisor]; GOTO ErrorExit};    Scavenger.Error =>      {Report[SigFromScavengerErrorType[error]]; GOTO ErrorExit};    Space.Error =>      {Report[SigFromSpaceErrorType[type]]; GOTO ErrorExit};    Space.InsufficientSpace =>      {Report[spaceInsufficientSpace]; GOTO ErrorExit};    Space.IOError =>      {Report[spaceIOError]; GOTO ErrorExit};    Stream.Attention =>      {Report[streamAttention]; GOTO ErrorExit};    Stream.EndOfStream =>      {Report[streamEndOfStream]; GOTO ErrorExit};    Stream.LongBlock =>      {Report[streamLongBlock]; GOTO ErrorExit};    Stream.ShortBlock =>      {Report[streamShortBlock]; GOTO ErrorExit};    Stream.SSTChange =>      {Report[streamSSTChange]; GOTO ErrorExit};    Stream.TimeOut =>      {Report[streamTimeOut]; GOTO ErrorExit};    Stream.InvalidOperation =>      {Report[streamInvalidOperation]; GOTO ErrorExit};    TemporaryBooting.InvalidParameters =>      {Report[temporaryBootingInvalidParameters]; GOTO ErrorExit};    TemporaryBooting.InvalidVersion =>      {Report[temporaryBootingInvalidVersion]; GOTO ErrorExit};    TemporaryBootingExtras.BootableFileError =>      {Report[SigFromTemporaryBootingExtrasErrorType[type]]; GOTO ErrorExit};    TemporaryBootingExtras.MultiGroupUCodeOrGerm =>      {Report[temporaryBootingExtrasMultiGroupUCodeOrGerm]; GOTO ErrorExit};    UserTerminal.BitmapIsDisconnected =>      {Report[userTerminalBitmapIsDisconnected]; GOTO ErrorExit};    Volume.Error =>      {Report[SigFromVolumeErrorType[error]]; GOTO ErrorExit};    Volume.RootDirectoryError =>      {Report[SigFromVolumeRootDirectoryErrorType[type]]; GOTO ErrorExit};    Volume.InsufficientSpace =>      {Report[volumeInsufficientSpace]; GOTO ErrorExit};    Volume.NeedsScavenging =>      {Report[volumeNeedsScavenging]; GOTO ErrorExit};    Volume.NotOnline =>      {Report[volumeNotOnline]; GOTO ErrorExit};    Volume.NotOpen =>      {Report[volumeNotOpen]; GOTO ErrorExit};    Volume.ReadOnly =>      {Report[volumeReadOnly]; GOTO ErrorExit};    Volume.Unknown =>      {Report[volumeUnknown]; GOTO ErrorExit};    VolumeExtras.AlreadyReadOpen =>      {Report[volumeExtrasAlreadyReadOpen]; GOTO ErrorExit};    VolumeExtras.AlreadyWriteOpen =>      {Report[volumeExtrasAlreadyWriteOpen]; GOTO ErrorExit};    CheckFailed, Test, TryFailed, UNWIND => REJECT; -- Reject our own signals.      -- These signals are raised when we want to continue after letting an      -- unknown (ANY) signal go by and to the debugger.    SpecialRuntime.ResumeError, CatchThisUnknownSignal =>      {ReportResumeError[]; GOTO ErrorExit};      --> NOTE:  This tries to catch ResumeError, in case we can't bind to      -->   SpecialRuntime and catch it explicitly.  We assume that the      -->   second ANY must be a ResumeError.    ANY => IF ReportOther[] -- Do some kind of reporting for this signal.             THEN GOTO ErrorExit -- Accept ANY only if asked to do so.             ELSE letAnAnyPass ¬ TRUE -- Remember that this happened.      ];  Report[none]; -- No signals were raised while executing the test code.  EXITS    ErrorExit => NULL;  END;  RETURN;  END; -- Of TryP.  -- TryP1 is a special case of TryP, the "mask" argument is just a Sig.TryP1: PUBLIC PROCEDURE [trial: PROCEDURE, mask: Sig,    comment1, comment2, comment3: LONG STRING ¬ NIL] RETURNS [actual: Sig] =  BEGIN  aqMaskSet: SigsetDefs.Aqsigset;  SigsetDefs.Monad[@aqMaskSet, mask];  actual ¬ TryP[trial, @aqMaskSet, comment1, comment2, comment3];  RETURN;  END; -- Of TryP1.  -- Try is like TryP, but the test operation is invoked by signalling Test.Try: PUBLIC PROCEDURE [mask: Sigset,    comment1, comment2, comment3: LONG STRING ¬ NIL] RETURNS [actual: Sig] =  BEGIN  TrialProc: PROCEDURE = {SIGNAL Test; RETURN};  actual ¬ TryP[TrialProc, mask, comment1, comment2, comment3];  RETURN;  END; -- Of Try.  -- Try1 is a special case of Try, the "mask" argument is just a Sig.  -- Note that Try1 could be implemented in terms of Try or TryP1, but it  -- is implemented directly in terms of TryP, in order to have a simpler  -- stack when a try fails and the debugger is summoned.Try1: PUBLIC PROCEDURE [mask: Sig,    comment1, comment2, comment3: LONG STRING ¬ NIL] RETURNS [actual: Sig] =  BEGIN  aqMaskSet: SigsetDefs.Aqsigset;  TrialProc: PROCEDURE = {SIGNAL Test; RETURN};  SigsetDefs.Monad[@aqMaskSet, mask];  actual ¬ TryP[TrialProc, @aqMaskSet, comment1, comment2, comment3];  RETURN;  END; -- Of Try1.------------------------------------------ Public errors and signals  -- When calling Try or Try1, the catch phrase for Test is used as the trial  -- operation.Test: PUBLIC SIGNAL = CODE;  -- CheckFailed is raised by Ck, when some check is not "ok".  It is meant to  -- be caught by the debugger.CheckFailed: PUBLIC SIGNAL [aspect, testee: LONG STRING,    tick: PostAuxDefs.Tick] = CODE;  -- TryFailed is raised by Try when some trial operation causes a signal or  -- not other than as expected.  It is meant to be caught by the debugger.TryFailed: PUBLIC SIGNAL [comment1, comment2, comment3,    expected: LONG STRING, actual: Sig, tick: PostAuxDefs.Tick] = CODE;------------------------------------------ Private procedures  -- LogError is called by Try when a trial operation raises a signal other  -- than as expected.  It logs a message and raises (another) signal to the  -- debugger, WHILE THE FIRST IS STILL ON THE STACK, and may be examined.  -- NOTE:  LogError must avoid rasing any non-TryPack errors, else Try might  -- catch them and confuse them with client-caused errors!LogError: PROCEDURE [actuality: Sig, expected: Sigset,    comment1, comment2, comment3: LONG STRING] =  BEGIN  actualSig: LONG STRING;  expectations: LONG STRING ¬ [400];  expectationsTooShort: BOOLEAN ¬ FALSE; -- Is "expectations" too short?  prefix: ARRAY BOOLEAN OF LONG STRING = [FALSE: "the signal ", TRUE: NIL];  suffix: ARRAY BOOLEAN OF LONG STRING = [FALSE: ".", TRUE: "...}."];  tick: PostAuxDefs.Tick = PostAuxDefs.GetCurrentTick[];  actualSig ¬ SigsetDefs.StringFromSig[actuality];  SigsetDefs.StringFromSigset[expected, expectations    ! SigsetDefs.Error => IF errortype = stringOverflow        THEN {expectationsTooShort ¬ TRUE; CONTINUE}];  PostDefs.Post["Failed "L, comment1, " ", comment2, " "];  PostDefs.Post[comment3, PostDefs.crString, "    Raised "L,    prefix[actuality = none], actualSig];  PostDefs.PostLine[" instead of one of "L, expectations,    suffix[expectationsTooShort]]; -- Suffix "compensates" for stringOverflow.  SIGNAL TryFailed[comment1: comment1, comment2: comment2,           comment3: comment3, expected: expectations, actual: actuality,           tick: tick];  END;  -- LogNonRecoverable is called by TryP when "nonRecoverable" is an element  -- of the "mask" Sigset.  It logs the appropriate message.LogNonRecoverable: PROCEDURE [comment1, comment2, comment3: LONG STRING] =  BEGIN  IF logNonRecoverableFlag THEN    BEGIN    PostDefs.Post["Test "L, comment1, " ", comment2, " "];    PostDefs.PostLine[comment3,      " skipped, since it might cause a non-recoverable error."L];    END;  RETURN;  END;  -- LogOther deals with an "other" (i.e., ANY) signal.  It posts the comment  -- strings into the typescript file as LogError would do, but doesn't post  -- the mask nor raise a signal to the debugger.  It also decides if Try*  -- should accept the signal (returns a boolean with the decision result).  --> NOTE: In the future, implement a "safeMode".  If "safeMode" is TRUE,  --> then LogOther should consult the user via the debugger if it should  --> really accept an "other" signal when so requested by the program.LogOther: PROCEDURE [letAnAnyPassBefore, otherIsInMask: BOOLEAN,    comment1, comment2, comment3: LONG STRING] RETURNS [acceptIt: BOOLEAN] =  BEGIN  acceptMsgs1: ARRAY BOOLEAN OF LONG STRING =    [FALSE: "Try* is NOT accepting a non Pilot-specific signal (ANY) raised by the test ",     TRUE: "Try* IS accepting a non Pilot-specific signal (ANY) raised by the test "];  acceptMsgs2: ARRAY BOOLEAN OF LONG STRING =    [FALSE: " since it was not requested to do so.",     TRUE: " since it was requested to do so."];  IF letAnAnyPassBefore --> NOTE: Assume the second ANY is a ResumeError!  THEN {LogResumeError[]; acceptIt ¬ TRUE}  ELSE BEGIN    IF otherIsInMask    THEN acceptIt ¬ TRUE    ELSE BEGIN      acceptIt ¬ FALSE;      Runtime.CallDebugger["Try* has intercepted a non Pilot-specific signal (ANY).  Set ""acceptIt ¬ TRUE"" to accept the signal (examine the signal first!)."L];      END;    PostDefs.Post[acceptMsgs1[acceptIt], comment1, " ", comment2, " "];    PostDefs.PostLine[comment3, acceptMsgs2[acceptIt]];    END;  RETURN;  END;  -- LogResumeError logs a msg for ResumeError or CatchThisUnknownSignal.LogResumeError: PROCEDURE =  {PostDefs.PostLine["The non Pilot-specific signal was uncaught.  Continuing the test at the request of the debugger or the client."L]; RETURN};------------------------------------------ Private signals  -- From the debugger (or the client), call the procedure CatchIt to raise  -- CatchThisUnknownSignal.  Try* will catch this signal as if it were a  -- ResumeError and continue.CatchThisUnknownSignal: ERROR = CODE;------------------------------------------ Main line code  -- None.END.LOG OF SIGNIFICANT CHANGESDate: July 17, 1979, By: JHM, Action: Created file.Date: December 6, 1979, By: JHM, Action: Defined the meaning of "nonRecoverable" in TryP's "mask" argument.Date: February 12, 1980, By: JHM, Action: Conversion for Amargosa.Date: August 20, 1980, By: JHM, Action: Converted to Mokelumne & Mesa 6.  Removed the MONITOR in favor of local Sigset variables (given bit-packed  arrays in Mesa 6).Date: August 21, 1980, By: JHM, Action: Added the current tick to the signals  CheckFailed & TryFailed.Date: September 29, 1980, By: JHM, Action: Widened strings to LONG.Date: October 2, 1980, By: JHM, Action: Expanded TryP to catch ResumeError,  CatchThisUnknownSignal.Date: October 27, 1980, By: JHM, Action: Removed "START SigsetPack".Date: November 19, 1980, By: JHM, Action: Modified LogError etc. to avoid  allocating storage (to avoid possible deadlocks).Date: February 19, 1981, By: JHM, Action: MINIMAL CONVERSION FOR RUBICON.  Removed references to Socket, which is now a private interface.  Also  removed use of the signal NetworkStream.AttentionTimeout, which was removed  in Rubicon.Date: March 9, 1981, By: JHM, Action: Full update for Rubicon--Removed Socket  (now a private interface) & NetworkStream & RS232C* (communications  interfaces, not Pilot;  and they change too much!);  added 2 new Scavenger  error codes;  switched from TryFailed1 (a temporary measure) to TryFailed.Date: 13-Jan-83 17:10:46, By: CAJ , Action: Update to Klamath.Date: 19-Aug-83 17:17:52, By: AWL      , Action:  Runtime.NoGlobalFrameSlots is obsolete.  Added Runtime.NarrowFaultDate: 25-Mar-87 12:11:23  By: RSV  Added TemporaryBootingExtras, PhysicalVolumeExtras, and VolumeExtras error catching.  Make various ARRAY mumble OF STRING into ARRAY mumble OF LONG STRING due to MDS relief.Date: 27-Mar-87 15:04:06  By: RSV  Use String.EmptyString instead of Storage.EmptyString.
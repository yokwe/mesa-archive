-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- PostPack.mesa    last edited by: CAJ     25-Apr-83 14:18:32-- Test software for Klamath Pilot.-- PostPack implements some procedures for simple I/O to the display and keyboard.  It serializes the messages, and should be the central manager of the display.  Post can post up to 5 strings in a single procedure call.  It also deals with some predefined messages in custom ways, e.g., "Tick" messages.DIRECTORY  Environment USING [charsPerPage],  Inline USING [LowHalf],  PostAuxDefs,  PostDefs,  Process USING [GetPriority, Priority, priorityNormal, SetPriority, Yield],  Runtime USING [CallDebugger],  Stream USING [SendNow],  String USING [AppendString],  System USING [isUtilityPilot],  Tool USING [UnusedLogName],  TTY USING [BackingStream, CharsAvailable, CharStatus, Create, Destroy, GetChar,    GetDecimal, GetEditedString, GetID, GetLine, GetLongDecimal,    GetLongNumber, GetLongOctal, GetNumber, GetOctal, GetString, Handle,    LineOverflow, NumberFormat, PutBackChar, PutChar, PutLongNumber,    PutLongString, PutNumber, PutString, RemoveCharacter, Rubout, SetBackingSize];PostPack: MONITOR  IMPORTS Inline, Process, Runtime, Stream, String, System, Tool, TTY  EXPORTS PostAuxDefs, PostDefs =BEGIN OPEN PostAuxDefs, PostDefs;------------------------------------------ Public exported variablescrString: PUBLIC RString ¬ ""; -- A string containing only a CR character [exported variable].------------------------------------------ Global types and constants  -- The 5 global values that would need to be restored on system restart  -- (crash recovery testing) are saved in a "RestoreData".  5 global  -- variables point into a record of this type.RestoreData: TYPE = MACHINE DEPENDENT RECORD [ -- Restore this data on restart  singleStepFlag (0): BOOLEAN,  traceFlag (1): BOOLEAN,  tickCounter (2): Tick,  tickPauseAt (4): Tick,  tickTraceAt (6): Tick];tickHeader: LONG STRING = "Tick:"; -- The header string for a Tick line.tickFormat: TTY.NumberFormat =  [base: 10, zerofill: FALSE, unsigned: TRUE, columns: 0];maximumTicksPerLine: CARDINAL = 60; -- Post this many tick messages per line.ckCreatedOften: BOOLEAN = FALSE; -- Compile-time switch.  -- It controls whether InlineCkCreated checks that the window is created or  -- noops.  InlineCkCreated is called from every I/O routine.  --> NOTE:  For new clients, recompile PostPack with "ckCreatedOften" set to  -->   TRUE, to help find bugs in the use of PostPack.------------------------------------------ Global variables (monitored data) -- The PostPack monitor covers the ticker, the I/O package, and these global state variables.  -- "staticData" holds our global "RestoreData" when we don't use Restorage  -- to save it for us.staticData: RestoreData ¬ RestoreData[singleStepFlag: FALSE, traceFlag: FALSE,    tickCounter: 0, tickPauseAt: LAST[Tick], tickTraceAt: LAST[Tick]];window: TTY.Handle; -- Our TTY window handle.windowCreated: BOOLEAN ¬ FALSE;tickCounter: LONG POINTER TO Tick ¬ @staticData.tickCounter; -- This points into "staticData" or "restoreData", where the tick count is kept.------------ The following variables are to be modified only by the private internal Tick procedures, but may be examined by any procedure within the monitor.anotherTickOkOnThisLine: BOOLEAN ¬ FALSE; -- Indicates if it's ok to put  -- another tick on this line, i.e., if the "Tick:" title is outstanding.  If  -- this is true, we don't have to title the next message if it is a Tick,  -- and we do have to preceed the next message with a CR if it's not a Tick.ticksOnThisLine: CARDINAL ¬ 0; -- Number of ticks we've posted on this line.------------ The values pointed to by the following variables are modified by the "global state control" procedures, and may also be modified via the debugger.singleStepFlag: LONG POINTER TO BOOLEAN ¬ @staticData.singleStepFlag; -- Set    -- this TRUE to single step the tests.  Then at each step, Ticker will    -- CallDebugger with the message "Ready for next step".traceFlag: LONG POINTER TO BOOLEAN ¬ @staticData.traceFlag; -- Enables trace    -- messages to the display & log.tickPauseAt: LONG POINTER TO Tick ¬ @staticData.tickPauseAt; -- Calls the    -- debugger with the message "Tick counter pause" when    -- tickCounter­ = tickPauseAt­.tickTraceAt: LONG POINTER TO Tick ¬ @staticData.tickTraceAt; -- Starts tracing    -- at this tick number.  -- Set spinWheels TRUE via the debugger to cause Ticker to spin til stopped  -- (i.e., until you unset it via the debugger).spinWheels: BOOLEAN ¬ FALSE;------------------------------------------ Public procedures:  Main control stuff.  -- Create creates a typescript and initializes the tick variables.  -- NOTE THAT THERE CAN ONLY BE ONE TYPESCRIPT AT A TIME PER PostPack  -- INSTANCE!  "wraparoundAt" specifies the max number of log pages, Post  -- will wraparound after that.  If "wraparoundAt = infinity", Post won't  -- wraparound at all.Create: PUBLIC ENTRY PROCEDURE [toolName: LONG STRING,    wraparoundAt: CARDINAL ¬ infinity] =  BEGIN ENABLE UNWIND => NULL;  unusedLogName: LONG STRING ¬ [40];  IF windowCreated THEN ERROR TypescriptAlreadyCreated;  IF System.isUtilityPilot    THEN String.AppendString[to: unusedLogName, from: toolName]    ELSE Tool.UnusedLogName[unused: unusedLogName, root: toolName];  window ¬ TTY.Create[unusedLogName]; windowCreated ¬ TRUE;  staticData ¬ RestoreData[singleStepFlag: FALSE, traceFlag: FALSE,    tickCounter: 0, tickPauseAt: LAST[Tick], tickTraceAt: LAST[Tick]];  anotherTickOkOnThisLine ¬ FALSE;  ticksOnThisLine ¬ 0;  IF wraparoundAt # infinity -- Set up a wraparound typescript.    THEN TTY.SetBackingSize[window,           LONG[wraparoundAt] * Environment.charsPerPage];  RETURN;  END;  -- Checkpoint checkpoints the log file.Checkpoint: PUBLIC ENTRY PROCEDURE =  BEGIN ENABLE UNWIND => NULL;  IF ~System.isUtilityPilot THEN Stream.SendNow[TTY.BackingStream[window]];  RETURN;  END;  -- Destroy cleans up the typescript, makes sure that the buffers are  -- emptied, and closes the typescript file.Destroy: PUBLIC ENTRY PROCEDURE =  BEGIN ENABLE UNWIND => NULL;  TerminateTickLine[];  TTY.Destroy[window]; windowCreated ¬ FALSE;  END;------------------------------------------ Public string & character output procedures-- Post, Post1String, PostChar, and PostLine are the basic procedures for posting a bunch of messages.  Post will post up to 5 messages.  Post1String will only take one message;  it is useful when a procedure of this TYPE is required, e.g., to pass as an argument in a procedure call.  PostChar takes only one character.  PostLine appends a carriage return to the messages.Post: PUBLIC ENTRY PROCEDURE [m1, m2, m3, m4, m5: LRString ¬ NIL] =  BEGIN ENABLE UNWIND => NULL;  TerminateTickLine[];  WriteLRString[m1];  WriteLRString[m2];  WriteLRString[m3];  WriteLRString[m4];  WriteLRString[m5];  RETURN;  END;Post1LString: PUBLIC ENTRY PROCEDURE [m: LRString] =  BEGIN ENABLE UNWIND => NULL;  TerminateTickLine[];  WriteLRString[m];  RETURN;  END;Post1String: PUBLIC ENTRY PROCEDURE [m: RString] =  BEGIN ENABLE UNWIND => NULL;  TerminateTickLine[];  WriteRString[m];  RETURN;  END;PostChar: PUBLIC ENTRY PROCEDURE [c: CHARACTER] =  BEGIN ENABLE UNWIND => NULL;  TerminateTickLine[];  TTY.PutChar[window, c];  RETURN;  END;PostLine: PUBLIC ENTRY PROCEDURE [m1, m2, m3, m4, m5: LRString ¬ NIL] =  BEGIN ENABLE UNWIND => NULL;  TerminateTickLine[];  WriteLRString[m1];  WriteLRString[m2];  WriteLRString[m3];  WriteLRString[m4];  WriteLRString[m5];  TTY.PutChar[window, cr];  RETURN;  END;RemoveCharacter: PUBLIC ENTRY PROCEDURE =  BEGIN ENABLE UNWIND => NULL;  -- This exists because TTY.PutChar[(backspace)] prints a representation of  -- backspace rather than backing up.  TerminateTickLine[];  TTY.RemoveCharacter[window, 1];  RETURN;  END;------------------------------------------ Public Trace procedures-- These procedures are like their like-named Post procedures, except they are noops if the global "trace flag" is FALSE.-- Theoretically, these should be entry procs (since they reference "traceFlag­").  In practice, it doesn't matter, since the traceFlag­ is normally changed only via the debugger.Trace: PUBLIC PROCEDURE [m1, m2, m3, m4, m5: LRString ¬ NIL] =   {IF traceFlag­ THEN Post[m1, m2, m3, m4, m5]; RETURN};Trace1LString: PUBLIC PROCEDURE [m: LRString] =   {IF traceFlag­ THEN Post1LString[m]; RETURN};Trace1String: PUBLIC PROCEDURE [m: RString] =   {IF traceFlag­ THEN Post1String[m]; RETURN};TraceChar: PUBLIC PROCEDURE [c: CHARACTER] =   {IF traceFlag­ THEN PostChar[c]; RETURN};TraceLine: PUBLIC PROCEDURE [m1, m2, m3, m4, m5: LRString ¬ NIL] =   {IF traceFlag­ THEN PostLine[m1, m2, m3, m4, m5]; RETURN};------------------------------------------ Public numeric output proceduresPostNumber: PUBLIC ENTRY PROCEDURE [n: UNSPECIFIED, fmt: NumberFormat,    trace: BOOLEAN ¬ FALSE] =  BEGIN ENABLE UNWIND => NULL;  IF ~trace OR traceFlag­ THEN    BEGIN    TerminateTickLine[];    TTY.PutNumber[window, n,      TTY.NumberFormat[fmt.base, fmt.zerofill, fmt.unsigned, fmt.columns]];    END;  RETURN;  END;PostLongNumber: PUBLIC ENTRY PROCEDURE [n: LONG UNSPECIFIED,    fmt: NumberFormat, trace: BOOLEAN ¬ FALSE] =  BEGIN ENABLE UNWIND => NULL;  IF ~trace OR traceFlag­ THEN    BEGIN    TerminateTickLine[];    TTY.PutLongNumber[window, n,      TTY.NumberFormat[fmt.base, fmt.zerofill, fmt.unsigned, fmt.columns]];    END;  RETURN;  END;------------------------------------------ Public input proceduresGetChar: PUBLIC ENTRY PROCEDURE RETURNS [CHARACTER] =  BEGIN ENABLE UNWIND => NULL;  TerminateTickLine[];  RETURN[TTY.GetChar[window]];  END;GetID: PUBLIC ENTRY PROCEDURE [bfr: LONG STRING] =  BEGIN ENABLE UNWIND => NULL;  TerminateTickLine[];  TTY.GetID[window, bfr !    TTY.LineOverflow => RESUME[SIGNAL LineOverflow[s]];    TTY.Rubout => BEGIN SIGNAL Rubout; RESUME; END];  END;GetLine: PUBLIC ENTRY PROCEDURE [bfr: LONG STRING] =  BEGIN ENABLE UNWIND => NULL;  TerminateTickLine[];  TTY.GetLine[window, bfr !    TTY.LineOverflow => RESUME[SIGNAL LineOverflow[s]];    TTY.Rubout => BEGIN SIGNAL Rubout; RESUME; END];  END;GetEditedString: PUBLIC ENTRY PROCEDURE [bfr: LONG STRING,      t: PROCEDURE [c: CHARACTER] RETURNS [status: TTY.CharStatus],      newString: BOOLEAN]    RETURNS [CHARACTER] =  BEGIN ENABLE UNWIND => NULL;  TerminateTickLine[];  RETURN[TTY.GetEditedString[window, bfr, t !    TTY.LineOverflow => RESUME[SIGNAL LineOverflow[s]];    TTY.Rubout => BEGIN SIGNAL Rubout; RESUME; END]];  END;GetString: PUBLIC ENTRY PROCEDURE [bfr: LONG STRING,    t: PROCEDURE [c: CHARACTER] RETURNS [status: TTY.CharStatus]] =  BEGIN ENABLE UNWIND => NULL;  TerminateTickLine[];  TTY.GetString[window, bfr, t !    TTY.LineOverflow => RESUME[SIGNAL LineOverflow[s]];    TTY.Rubout => BEGIN SIGNAL Rubout; RESUME; END];  END;-- Numeric input procedures:GetNumber: PUBLIC ENTRY PROCEDURE [default: UNSPECIFIED, radix: CARDINAL]    RETURNS [n: UNSPECIFIED] =  BEGIN ENABLE UNWIND => NULL;  TerminateTickLine[];  n ¬ TTY.GetNumber[window, default, radix !    TTY.LineOverflow => RESUME[SIGNAL LineOverflow[s]];    TTY.Rubout => BEGIN SIGNAL Rubout; RESUME; END];  RETURN[n];  END;GetDecimal: PUBLIC ENTRY PROCEDURE RETURNS [n: INTEGER] =  BEGIN ENABLE UNWIND => NULL;  TerminateTickLine[];  n ¬ TTY.GetDecimal[window !    TTY.LineOverflow => RESUME[SIGNAL LineOverflow[s]];    TTY.Rubout => BEGIN SIGNAL Rubout; RESUME; END];  RETURN[n];  END;GetOctal: PUBLIC ENTRY PROCEDURE RETURNS [n: UNSPECIFIED] =  BEGIN ENABLE UNWIND => NULL;  TerminateTickLine[];  n ¬ TTY.GetOctal[window !    TTY.LineOverflow => RESUME[SIGNAL LineOverflow[s]];    TTY.Rubout => BEGIN SIGNAL Rubout; RESUME; END];  RETURN[n];  END;GetLongNumber: PUBLIC ENTRY PROCEDURE [default: LONG UNSPECIFIED,    radix: CARDINAL] RETURNS [n: LONG UNSPECIFIED] =  BEGIN ENABLE UNWIND => NULL;  TerminateTickLine[];  n ¬ TTY.GetLongNumber[window, default, radix !    TTY.LineOverflow => RESUME[SIGNAL LineOverflow[s]];    TTY.Rubout => BEGIN SIGNAL Rubout; RESUME; END];  RETURN[n];  END;GetLongDecimal: PUBLIC ENTRY PROCEDURE RETURNS [n: LONG INTEGER] =  BEGIN ENABLE UNWIND => NULL;  TerminateTickLine[];  n ¬ TTY.GetLongDecimal[window !    TTY.LineOverflow => RESUME[SIGNAL LineOverflow[s]];    TTY.Rubout => BEGIN SIGNAL Rubout; RESUME; END];  RETURN[n];  END;GetLongOctal: PUBLIC ENTRY PROCEDURE RETURNS [n: LONG UNSPECIFIED] =  BEGIN ENABLE UNWIND => NULL;  TerminateTickLine[];  n ¬ TTY.GetLongOctal[window !    TTY.LineOverflow => RESUME[SIGNAL LineOverflow[s]];    TTY.Rubout => BEGIN SIGNAL Rubout; RESUME; END];  RETURN[n];  END;------------------------------------------ Public Tick and global state control proceduresGetCurrentTick: PUBLIC ENTRY PROCEDURE RETURNS [Tick] =  BEGIN ENABLE UNWIND => NULL;  InlineCkCreated[];  RETURN[tickCounter­];  END;GetPauseAtTick: PUBLIC ENTRY PROCEDURE RETURNS [Tick] =  BEGIN ENABLE UNWIND => NULL;  CkCreated[];  RETURN[tickPauseAt­];  END;GetSingleStep: PUBLIC ENTRY PROCEDURE RETURNS [BOOLEAN] =  BEGIN ENABLE UNWIND => NULL;  CkCreated[];  RETURN[singleStepFlag­];  END;GetTraceAtTick: PUBLIC ENTRY PROCEDURE RETURNS [Tick] =  BEGIN ENABLE UNWIND => NULL;  CkCreated[];  RETURN[tickTraceAt­];  END;GetTraceFlag: PUBLIC ENTRY PROCEDURE RETURNS [BOOLEAN] =  BEGIN ENABLE UNWIND => NULL;  CkCreated[];  RETURN[traceFlag­];  END;  -- SetCurrentTick sets the tick counter.  It is initialized to 0 by Create.SetCurrentTick: PUBLIC ENTRY PROCEDURE [tick: Tick ¬ 0] =  BEGIN ENABLE UNWIND => NULL;  CkCreated[];  tickCounter­ ¬ tick;  RETURN;  END;SetPauseAtTick: PUBLIC ENTRY PROCEDURE [tick: Tick ¬ LAST[Tick]] =  BEGIN ENABLE UNWIND => NULL;  CkCreated[];  tickPauseAt­ ¬ tick;  RETURN;  END;SetSingleStep: PUBLIC ENTRY PROCEDURE [bv: BOOLEAN ¬ TRUE] =  BEGIN ENABLE UNWIND => NULL;  CkCreated[];  singleStepFlag­ ¬ bv;  RETURN;  END;SetTraceAtTick: PUBLIC ENTRY PROCEDURE [tick: Tick ¬ LAST[Tick]] =  BEGIN ENABLE UNWIND => NULL;  CkCreated[];  tickTraceAt­ ¬ tick;  RETURN;  END;SetTraceFlag: PUBLIC ENTRY PROCEDURE [bv: BOOLEAN] =  BEGIN ENABLE UNWIND => NULL;  CkCreated[];  traceFlag­ ¬ bv;  RETURN;  END;  -- Ticker increments the tick counter and checks to see if we should pause  -- to the debugger now.   It also posts the a tick message occasionally.  -- Ticker should be called BEFORE each and every test trial operation.  -- If you set spinWheels TRUE via the debugger, you can proceed the debugee  -- and scroll thru the typescript.  Set it back to FALSE to continue.  --> Perhaps this should also print the time every ~512 ticks.Ticker: PUBLIC ENTRY PROCEDURE =  BEGIN ENABLE UNWIND => NULL;  InlineCkCreated[];  tickCounter­ ¬ tickCounter­ + 1;  PostTick[tickCounter­];  IF tickCounter­ = tickTraceAt­ THEN traceFlag­ ¬ TRUE;  SELECT TRUE FROM -- Check & act on debugging flags.    tickCounter­ = tickPauseAt­ => Runtime.CallDebugger["Tick counter pause"];    singleStepFlag­ => Runtime.CallDebugger["Ready for next step"];    ENDCASE;  IF spinWheels -- Toggle this flag via the debugger.  THEN    BEGIN    runningAtPriority: Process.Priority = Process.GetPriority[];      -- Set priority "normal", so we don't preempt the Tools Environment.    Process.SetPriority[Process.priorityNormal];    WHILE spinWheels -- Reset this flag via the debugger.      DO Process.Yield[]; ENDLOOP;    Process.SetPriority[runningAtPriority]; -- Reset our priority.    END;  END;------------------------------------------ Public interaction procedures  -- CharsAvailable returns the number of chars available in the input buffer.CharsAvailable: PUBLIC ENTRY PROCEDURE RETURNS [number: CARDINAL] =  BEGIN ENABLE UNWIND => NULL;  CkCreated[];  RETURN[TTY.CharsAvailable[window]];  END;  -- Confirm asks the user for confirmation.Confirm: PUBLIC ENTRY PROCEDURE RETURNS [confirmed: BOOLEAN] =  BEGIN ENABLE UNWIND => NULL;  char: CHARACTER;  TerminateTickLine[];  WriteRString[" [confirm] "L];  char ¬ TTY.GetChar[window];  SELECT char FROM    cr => confirmed ¬ TRUE;    'y, 'Y => {confirmed ¬ TRUE; TTY.PutChar[window, char]};    'n, 'N => {confirmed ¬ FALSE; TTY.PutChar[window, char]};    del => {confirmed ¬ FALSE; WriteRString[" XXX"L]};    ENDCASE =>      BEGIN      confirmed ¬ FALSE; TTY.PutChar[window, '?];      UNTIL TTY.GetChar[window] = del DO TTY.PutChar[window, '?]; ENDLOOP;      WriteRString[" XXX"L];      END;  TTY.PutChar[window, cr];  RETURN;  END;  -- PutBackChar puts a character back into the input buffer.PutBackChar: PUBLIC ENTRY PROCEDURE [c: CHARACTER] =  BEGIN ENABLE UNWIND => NULL;  CkCreated[];  TTY.PutBackChar[window, c];  RETURN;  END;------------------------------------------ Public signals--> NOTE:  PostPack's MONITOR LOCK IS HELD WHILE THESE SIGNALS ARE RAISED, hence any attempt to call a PostDefs or PostAuxDefs procedure from within a catch phrase for these signals WILL CAUSE A DEADLOCK!-- These first two signals may be raised by the edited input procedures, i.e., by any of the input procedures EXCEPT GetChar.LineOverflow: PUBLIC SIGNAL [s: LONG STRING] RETURNS [ns: LONG STRING] = CODE;Rubout: PUBLIC SIGNAL = CODE;------------------------------------------ Private tick procedures-- Note:  Only these private internal Tick procedures should modify the global state variables (monitor data) that deal with formatting ticks on a line.  -- PostTick posts a "tick", which counts progress thru the test steps.  If  -- the last thing posted was also a tick, then PostTick will just post the  -- new tick on the same line, up to maxTicksPerLine ticks on a line.  -- Otherwise, PostTick will start a new line with "Tick: ", and then post  -- the tick.  If a tick is followed by a non-tick message, then a CR will be  -- printed to separate the two messages.  -- To reduce the size of the typescript file, PostTick does:  -- If it's the first tick on the line, or (tick MOD 20) = 0, post a number.  -- Else if (tick MOD 5) = 0, post an "!".  Otherwise, post a ".".  -- Every checkpointResolution ticks, PostTick does a Checkpoint.PostTick: INTERNAL PROCEDURE [tick: Tick] =  BEGIN  tickMod20: CARDINAL; -- A temporary, to save a long division.    -- Consider starting a new line.  IF ~anotherTickOkOnThisLine  THEN -- Start a "Tick line".  Post the header and set the state variables.    BEGIN    TTY.PutString[window, tickHeader];    anotherTickOkOnThisLine ¬ TRUE;    ticksOnThisLine ¬ 0;    END;    -- Post this tick.  SELECT TRUE FROM    ticksOnThisLine = 0,    (tickMod20 ¬ Inline.LowHalf[tick MOD 20]) = 0 =>      {TTY.PutChar[window, sp]; TTY.PutLongNumber[window, tick, tickFormat]};    (tickMod20 MOD 5) = 0 => TTY.PutChar[window, '!];    ENDCASE => TTY.PutChar[window, '.];    -- Now increment the count of ticks on this line.  Perhaps end the line.  ticksOnThisLine ¬ ticksOnThisLine + 1;  IF ticksOnThisLine >= maximumTicksPerLine THEN TerminateTickLine[];  RETURN;  END;  -- TerminateTickLine checks to see if the current line holds ticks messages.  -- If so, it terminates them with a carriage-return, and resets the relevant  -- state variables.TerminateTickLine: INTERNAL PROCEDURE =  BEGIN  InlineCkCreated[];  IF anotherTickOkOnThisLine  THEN    BEGIN    TTY.PutChar[window, cr];    anotherTickOkOnThisLine ¬ FALSE;    ticksOnThisLine ¬ 0;    END;  RETURN;  END;------------------------------------------ Private syncronization procedures  -- CkCreated complains if the typescript (and window) is not created.CkCreated: INTERNAL PROCEDURE =  {IF ~windowCreated THEN ERROR TypescriptNotYetCreated; RETURN};InlineCkCreated: INTERNAL PROCEDURE = INLINE  {IF ckCreatedOften -- A compile-time switch.   THEN IF ~windowCreated THEN ERROR TypescriptNotYetCreated; RETURN};------------------------------------------ Other private proceduresWriteLRString: INTERNAL PROCEDURE [lrString: LRString] =  {IF lrString # NIL     THEN TTY.PutLongString[window, LOOPHOLE[lrString, LONG STRING]]};WriteRString: INTERNAL PROCEDURE [rString: RString] =  {IF rString # NIL THEN TTY.PutString[window, LOOPHOLE[rString, LONG STRING]]};------------------------------------------ Private signalsRestartError: SIGNAL [msg: LONG STRING] = CODE;TypescriptNotYetCreated: ERROR = CODE;TypescriptAlreadyCreated: ERROR = CODE;------------------------------------------ Main line code  -- noneEND.LOG OF SIGNIFICANT CHANGESDate: August 17, 1979, By: JHM, Action: Created file.Date: February 5, 1980, By: JHM, Action: Added Ticker software & PilotWisk  stuff.Date: July 7, 1980, By: JHM, Action: Made Ticks LONG CARDINALs.  Added  WraparoundTypescript and tickTraceAt.Date: August 20, 1980, By: JHM, Action: Added GetCurrentTick.  Converted to  Mesa 6.  Fixed the "spinWheels" bug (made it lower it's priority to 1 before  spinning).Date: August 22, 1980, By: JHM, Action: Converted to New Tajo.Date: August 22, 1980, By: JHM, Action: Redefined procs to get/set global  state flags, so FileTest can restore everything interesting each time it  boots to test crash recovery.Date: September 29, 1980, By: JHM, Action: Made the strings LONG, except for  input strings (which require TTY to handle LONG STRINGs first).Date: October 1, 1980, By: JHM, Action: Added stuff to allow PostPack to keep  some data in the Restorage heap.Date: February 20, 1981, By: JHM, Action: Minimal conversion for Rubicon.  Use "Process.priorityNormal" instead of 1.Date: March 6, 1981, By: JHM, Action: Switched from  TajoUtility.SetTypescriptSize (needed in Mokelumne) to TTY.SetBackingSize  (available in Rubicon).  Added the compile-time switch "ckCreatedOften", and  set it to FALSE, to save some overly-redundant checking.Date: March 30, 1981, By: JHM, Action: Redefined PostTick, it'll now post a  tick number for the first tick on each line.Date: 24-Apr-83 17:25:28, By: CAJ , Action: Update for Klamath; remove  RestorageDefs and RestoreDefs; provide for UtilityPilot, add RemoveCharacter.
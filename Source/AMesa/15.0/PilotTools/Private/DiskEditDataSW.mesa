-- Copyright (C) 1984, 1985, 1988  by Xerox Corporation. All rights reserved. -- DiskEditDataSW.mesa   2-Mar-88 13:55:50 by CAJ DIRECTORY  Ascii USING [CR],  DiskEditInternal USING [    dataPtr, dataSW, dataWindowKey, labels, labelSW, msgSW, paramSW],  Environment USING [wordsPerPage],  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, CommandItem, DisplayItem,    Enumerated, EnumeratedItem, EnumeratedNotifyProcType, line0, line1,    line2, line3, NumberItem, ProcType, StringItem, TagOnlyItem],  Heap USING [systemZone],  Inline USING [HighByte, LowByte],  MsgSW USING [Clear],  Put USING [Line],  String USING [    AppendChar, AppendNumber, AppendOctal, AppendString, FreeString, MakeString],  Window USING [Handle],  WindowSwap USING [CurrentViewHandle, EstablishViewsWindow];DiskEditDataSW: PROGRAM  IMPORTS DiskEditInternal, FormSW, Heap, Inline, MsgSW, Put, String, WindowSwap  EXPORTS DiskEditInternal =  BEGIN  DisplayOptions: TYPE = {    octal, octalByte, octalSwapped, decimal, hex, ascii};  FormItems: TYPE = {    changeItem, bufferIndex, value, displayOption, dataTag, sectorData};  defaultDisplayOption: DisplayOptions = octal;  defaultRadix: CARDINAL = 8;  displayOption: DisplayOptions ¬ defaultDisplayOption;  displayString: LONG STRING ¬ NIL;  bufferIndex: CARDINAL ¬ 0;  radix: CARDINAL ¬ defaultRadix;  newValue: WORD ¬ 0;    -- line formatting constants  addrChars: CARDINAL = 5;  maxCharsPerWord: CARDINAL = 6;  spaceChars: CARDINAL = 2;  wordsPerLine: CARDINAL = 8;  wpp: CARDINAL = Environment.wordsPerPage;  ChangeDisplayOption: FormSW.EnumeratedNotifyProcType =    BEGIN    MsgSW.Clear[DiskEditInternal.msgSW];    SELECT displayOption FROM      octal => radix ¬ 8;      hex => radix ¬ 16;      decimal => radix ¬ 10;      ascii => NULL;      ENDCASE =>        BEGIN	Put.Line[DiskEditInternal.msgSW, "Option not implemented."L];	displayOption ¬ oldValue;	FormSW.DisplayItem[	  WindowSwap.CurrentViewHandle[DiskEditInternal.dataWindowKey],	  FormItems.displayOption.ORD];	END;    IF (displayOption ~= DisplayOptions[oldValue])        AND (displayString.length > 0) THEN      BEGIN      FillDataSW[];      FormSW.DisplayItem[	WindowSwap.CurrentViewHandle[DiskEditInternal.dataWindowKey],        FormItems.sectorData.ORD];      END;    END;  ChangeItem: FormSW.ProcType =    BEGIN    MsgSW.Clear[DiskEditInternal.msgSW];    DiskEditInternal.dataPtr[bufferIndex] ¬ newValue;    FillDataSW[];    FormSW.DisplayItem[      WindowSwap.CurrentViewHandle[DiskEditInternal.dataWindowKey],      FormItems.sectorData.ORD];    END;  CleanupDataSW: PROCEDURE =    -- Make data buffer match display.    -- No action needed here since display is read only and data buffer is    -- modified as items are changed.    {};    DestroyDataSW: PROCEDURE =    -- Clean up for view going away for good    BEGIN    String.FreeString[z: Heap.systemZone, s: displayString];    displayString ¬ NIL;    END;  FillDataSW: PROCEDURE =    -- Make display match data buffer.    BEGIN    -- Check line formatting constants (global) if changing line print formats.   i: CARDINAL ¬ 0;    nLines: CARDINAL = (wpp + wordsPerLine - 1)/wordsPerLine;    s: STRING ¬ [6];    spaces: STRING ¬ "  "L;    -- The following two checks ensure that formatting here follows assumptions    -- made elsewhere about print format based on global constants.  If this    -- check fails, adjust to match.    -- ASSERT:--    sCheck: BOOLEAN [TRUE..TRUE] = (s.length = maxCharsPerWord);    spacesCheck: BOOLEAN [TRUE..TRUE] = (spaces.length = spaceChars);    FormatWord: PROCEDURE [word: WORD] =      BEGIN      -- Change (number) word to string, right justify, and fill leading blanks      fill: CARDINAL;      s.length ¬ 0;      SELECT displayOption FROM        octal, hex, decimal =>	  BEGIN          String.AppendNumber[s, word, radix];          fill ¬ s.maxlength - s.length;          FOR i: CARDINAL IN [1..s.length] DO            s[s.maxlength-i] ¬ s[s.length-i];	    ENDLOOP;          FOR i: CARDINAL IN [0..fill) DO s[i] ¬ ' ; ENDLOOP;          s.length ¬ s.maxlength;	  END;	ascii =>	  BEGIN	  s[0] ¬ s[1] ¬ ' ;	  s[2] ¬ LOOPHOLE[Inline.HighByte[word], CHAR];	  s[3] ¬ LOOPHOLE[Inline.LowByte[word], CHAR];	  s.length ¬ 4;	  END;	ENDCASE => {s ¬ " @"L; s.length ¬ 2};      END;  -- FormatWord        -- May be coming up from tiny.    IF displayString = NIL THEN displayString ¬ MakeDisplayBuffer[];    -- Turn whole data buffer into one long string    displayString.length ¬ 0;    THROUGH [0..nLines) DO      -- Quick and dirty line id      IF i < 100B THEN String.AppendChar[displayString, ' ];      IF i < 10B THEN String.AppendChar[displayString, ' ];      String.AppendOctal[displayString, i];      String.AppendChar[displayString, '/];      THROUGH [0..wordsPerLine) DO        String.AppendString[displayString, spaces];	FormatWord[DiskEditInternal.dataPtr[i]];        String.AppendString[displayString, s];	i ¬ i + 1;	ENDLOOP;      String.AppendChar[displayString, Ascii.CR];      ENDLOOP;    END;  MakeDataSW: PUBLIC FormSW.ClientItemsProcType =    BEGIN    nItems: CARDINAL = FormItems.LAST.ORD + 1;    displayOptions: ARRAY [0..6) OF FormSW.Enumerated ¬ [      ["octal"L, DisplayOptions[octal]], [      "octalByte"L, DisplayOptions[octalByte]], [      "octalSwapped"L, DisplayOptions[octalSwapped]], [      "decimal"L, DisplayOptions[decimal]], [      "hex"L, DisplayOptions[hex]], ["ascii"L, DisplayOptions[ascii]]];    displayString ¬ MakeDisplayBuffer[];    items ¬ FormSW.AllocateItemDescriptor[nItems];    items[FormItems.changeItem.ORD] ¬ FormSW.CommandItem[      tag: "ChangeItem"L, place: [0, FormSW.line0], proc: ChangeItem];    items[FormItems.bufferIndex.ORD] ¬ FormSW.NumberItem[      tag: "index "L, place: [120, FormSW.line0], signed: FALSE,      notNegative: TRUE, default: 0, value: @bufferIndex];    items[FormItems.value.ORD] ¬ FormSW.NumberItem[      tag: "value "L, place: [240, FormSW.line0], signed: FALSE,      notNegative: TRUE, default: 0, value: @newValue];    items[FormItems.displayOption.ORD] ¬ FormSW.EnumeratedItem[      tag: "Data display option"L, place: [0, FormSW.line1], feedback: all,      proc: ChangeDisplayOption, choices: DESCRIPTOR[displayOptions],      value: @displayOption];    items[FormItems.dataTag.ORD] ¬ FormSW.TagOnlyItem[      tag: "Data"L, place: [0, FormSW.line2], readOnly: TRUE];    items[FormItems.sectorData.ORD] ¬ FormSW.StringItem[      tag: NIL, place: [0, FormSW.line3], readOnly: TRUE, inHeap: FALSE,      string: @displayString];    RETURN[items, TRUE]    END;  MakeDisplayBuffer: PROCEDURE RETURNS [LONG STRING] =    BEGIN    lineChars: CARDINAL =      addrChars + wordsPerLine * (maxCharsPerWord + spaceChars) + 1;    maxLines: CARDINAL = (wpp + wordsPerLine - 1) / wordsPerLine;    RETURN[String.MakeString[      z: Heap.systemZone, maxlength: lineChars * maxLines]];    END;  -- MakeDisplayBuffer  -- Module initialization:  -- Register this subwindow as the default view for the data subwindow  InitializeViewSwappingWindow: PUBLIC PROCEDURE =    BEGIN    menuWindows: ARRAY [0..2) OF Window.Handle;    menuWindows[0] ¬ DiskEditInternal.paramSW;    menuWindows[1] ¬ DiskEditInternal.labelSW;    DiskEditInternal.dataWindowKey ¬ WindowSwap.EstablishViewsWindow[      menuName: "Data views"L,      viewH: DiskEditInternal.dataSW, -- sw already created when tool was created      viewName: "Data"L, viewFromDataProc: FillDataSW,      dataFromViewProc: CleanupDataSW,      destroyViewProc: DestroyDataSW,      otherWindows: DESCRIPTOR[BASE[menuWindows],        IF DiskEditInternal.labels THEN 2 ELSE 1]];    END;  END.LOG 3-Sep-81 10:11:47   WDK	LONGified20-Apr-83 18:28:55   EKT	Update to Klamath (Deleted Transaction from Imports list)29-Nov-83 16:46:26   EKT	Changed data.index and data.value to be displayed as decimal instead of octal.16-Apr-84 10:21:42   AWL	Display full window 5-Sep-84 13:59:39   CAJ	Add registering window via WindowSwap.13-May-85 15:20:56   CAJ	Change data display scheme from individual form items to display string + change commands; add radix choice; add DestroyDataSW. 2-Mar-88 13:54:34   CAJ	Rip msg subwindow out of the views menu.  Check whether to include a label sw.
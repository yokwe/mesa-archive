-- Copyright (C) 1984, 1985, 1986, 1987, 1988  by Xerox Corporation. All rights reserved. -- DiskEditParamSW.mesa   3-Mar-88 12:41:15 by CAJ DIRECTORY  CompatibilityDiskFace USING [Command, Label],  DiskChannel USING [    Create, defaultTries, DirectOperation, DiskChannelPrivate,    diskOpWordAlignment, DiskPageNumber, Drive, DoDirectIO, GetDriveAttributes,     GetNextDrive, GetPageAddress, GetPageNumber, goodCompletion, Handle,     IOStatus, nullDrive, nullHandle, operationSize],  DiskEditInternal USING [    CleanupLabelSW, dataPageCount, dataPtr, dataWindowKey, diskLabel,    FillLabelSW, labelPageCount, labels, labelSW, msgSW],  Environment USING [Base, first64K],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType, CommandItem,    Display, DisplayItem, Enumerated, EnumeratedItem, EnumeratedNotifyProcType,    ItemHandle, LabelItem, LongNumberItem, newLine, nextPlace, NumberItem,    ProcType],  MsgSW USING [Clear, Post],  PilotDiskFace USING [DiskAddress, Command],  ResidentHeap USING [FreeNode, MakeNode],  Space USING [PageFromLongPointer],  VM USING [MakeResident, MakeSwappable, ReturnWait],  UserTerminal USING [BlinkDisplay],  WindowSwap USING [    CurrentViewHandle, Error, UpdateDataFromView, UpdateViewFromData],  Zone USING [Status];DiskEditParamSW: PROGRAM  IMPORTS    DiskChannel, DiskEditInternal, FormSW, MsgSW, ResidentHeap, Space, VM,    UserTerminal, WindowSwap  EXPORTS DiskEditInternal  SHARES DiskChannel =  BEGIN  FormItems: TYPE = {    begin, deviceIndex, pageBase, pageOffset, pageNumber, daTag, daCyl, daHead,    daSector, convertToPage, convertToDA, useDA, usePage, command, repeatCount,    termCondition, doIt};  HeadAndSectorType: TYPE = [0..256);    TerminationCondition: TYPE = {goodCompletion, failure};  diskDrive: MACHINE DEPENDENT RECORD [    drive(0): DiskChannel.Drive,    pageNumberValid(2:0..15): BOOLEAN,    diskAddressValid(3:0..15): BOOLEAN,    pageNumberOffset(4): DiskChannel.DiskPageNumber,    cylinder(6): CARDINAL,    head(7:0..15): HeadAndSectorType,    sector(8:0..15): HeadAndSectorType,    useDiskAddress(9:0..15): BOOLEAN,    usePageNumber(10:0..15): BOOLEAN,    currentCommand(11:0..15): PilotDiskFace.Command,    channel(12): DiskChannel.Handle,    address(15): PilotDiskFace.DiskAddress,    driveIndex(17): CARDINAL,    repeatCount(18): CARDINAL,    terminationCondition(19): TerminationCondition,    pageNumberBase(20): DiskChannel.DiskPageNumber,    pageNumberIO(22): DiskChannel.DiskPageNumber] ¬      [DiskChannel.nullDrive, FALSE, FALSE, 0, 0, 0, 0, FALSE, TRUE,       PilotDiskFace.Command[read], DiskChannel.nullHandle,       [0, 0, 0], 0, 1, goodCompletion, 0, 0];  AllocateDirectOperation: PROC    RETURNS [      pOp: LONG POINTER TO DiskChannel.DirectOperation,      pStorage: Environment.Base RELATIVE POINTER TO UNSPECIFIED] =    -- pOp will be aligned per requirements of DoDirectIO.    -- pStorage should be used when freeing.    INLINE BEGIN    rpDirOp: Environment.Base RELATIVE POINTER TO DiskChannel.DirectOperation;    status: Zone.Status;    [pStorage, status] ¬ ResidentHeap.MakeNode[      n: DiskChannel.operationSize + DiskChannel.diskOpWordAlignment - 1,      alignment: a1];    IF status ~= okay THEN ERROR;    rpDirOp ¬ pStorage;    pOp ¬ @Environment.first64K[rpDirOp];    pOp ¬ LOOPHOLE[((LOOPHOLE[pOp, LONG CARDINAL] +      SIZE[DiskChannel.DiskChannelPrivate] + DiskChannel.diskOpWordAlignment-1)	/ DiskChannel.diskOpWordAlignment) * DiskChannel.diskOpWordAlignment	  - SIZE[DiskChannel.DiskChannelPrivate]];    END;  --AllocateDirectOperation  FreeDirectOperation: PROC [pStorage: Environment.Base RELATIVE POINTER] =    INLINE {status: Zone.Status ¬ ResidentHeap.FreeNode[pStorage];    IF status ~= okay THEN ERROR};  DiskAddressCommand: FormSW.ProcType =    BEGIN    IF ~ValidateDiskPageNumber[] THEN      BEGIN      MsgSW.Post[sw: DiskEditInternal.msgSW, string: "Page number invalid"L];      UserTerminal.BlinkDisplay[];      RETURN;      END;    diskDrive.address ¬ DiskChannel.GetPageAddress[      diskDrive.drive, GetDiskAddress[]];    diskDrive.cylinder ¬ diskDrive.address.cylinder;    diskDrive.sector ¬ diskDrive.address.sector;    diskDrive.head ¬ diskDrive.address.head;    FormSW.DisplayItem[sw, FormItems.daCyl.ORD];    FormSW.DisplayItem[sw, FormItems.daHead.ORD];    FormSW.DisplayItem[sw, FormItems.daSector.ORD];    END;  DoDiskIOCommand: FormSW.ProcType =    BEGIN    ENABLE WindowSwap.Error => IF type = noSuchKey THEN CONTINUE;    op: LONG POINTER TO DiskChannel.DirectOperation;    opStorage: Environment.Base RELATIVE POINTER;    returnWait: VM.ReturnWait ¬ wait;    status: DiskChannel.IOStatus;    -- First validate everything to be sure that a "reasonable" disk    -- and sector are addressed    IF ~ValidateDrive[] THEN RETURN;    IF diskDrive.usePageNumber THEN      IF ~ValidateDiskPageNumber[] THEN        BEGIN        MsgSW.Post[sw: DiskEditInternal.msgSW, string: "Page number invalid"L];        UserTerminal.BlinkDisplay[];        RETURN;        END      ELSE {}  -- Use the page number and it is valid    ELSE  -- using the disk address      IF ~ValidateDiskHead[] THEN        BEGIN        MsgSW.Post[          sw: DiskEditInternal.msgSW, string: "Disk head number invalid"L];        UserTerminal.BlinkDisplay[];        RETURN;        END      ELSE        IF ~ValidateDiskSector[] THEN          BEGIN          MsgSW.Post[            sw: DiskEditInternal.msgSW, string: "Disk sector number invalid"L];          UserTerminal.BlinkDisplay[];          RETURN;          END;    MsgSW.Clear[sw: DiskEditInternal.msgSW];    WindowSwap.UpdateDataFromView[DiskEditInternal.dataWindowKey];    VM.MakeResident[      [Space.PageFromLongPointer[DiskEditInternal.dataPtr],       DiskEditInternal.dataPageCount], returnWait];    IF DiskEditInternal.labels THEN      BEGIN      DiskEditInternal.CleanupLabelSW[];      VM.MakeResident[        [Space.PageFromLongPointer[DiskEditInternal.diskLabel],        DiskEditInternal.labelPageCount], returnWait];      END;    diskDrive.pageNumberIO ¬      IF diskDrive.usePageNumber THEN GetDiskAddress[]      ELSE DiskChannel.GetPageNumber[diskDrive.drive,        [cylinder: diskDrive.cylinder, head: diskDrive.head,	 sector: diskDrive.sector]];    diskDrive.address ¬       DiskChannel.GetPageAddress[diskDrive.drive, diskDrive.pageNumberIO];    FormSW.DisplayItem[sw, FormItems.pageNumber.ORD];    [op, opStorage] ¬ AllocateDirectOperation[];    op.diskOp ¬ [      clientHeader: diskDrive.address,      reserved1--(label)--: DiskEditInternal.diskLabel,      dataPtr: DiskEditInternal.dataPtr, pageCount: 1, incrementDataPtr: FALSE,      command: diskDrive.currentCommand, tries: DiskChannel.defaultTries,      device: DiskChannel.GetDriveAttributes[diskDrive.drive].deviceHandle];    THROUGH [0..diskDrive.repeatCount) DO      oldLabel: CompatibilityDiskFace.Label;      oldLabel ¬ DiskEditInternal.diskLabel­;      status ¬ DiskChannel.DoDirectIO[op, channelException].status;      IF DiskEditInternal.labels AND        NoLabelToLabelCommand[diskDrive.currentCommand] ~= [verify, read, read]	  THEN DiskEditInternal.diskLabel­ ¬ oldLabel;      IF        (diskDrive.terminationCondition = goodCompletion          AND status = DiskChannel.goodCompletion)        OR          (diskDrive.terminationCondition = failure            AND status ~= DiskChannel.goodCompletion) THEN EXIT;      ENDLOOP;    FreeDirectOperation[opStorage];    VM.MakeSwappable[      [Space.PageFromLongPointer[DiskEditInternal.dataPtr],       DiskEditInternal.dataPageCount]];    IF DiskEditInternal.labels THEN VM.MakeSwappable[      [Space.PageFromLongPointer[DiskEditInternal.diskLabel],       DiskEditInternal.labelPageCount]];    IF status ~= DiskChannel.goodCompletion THEN      BEGIN      MsgSW.Post[        sw: DiskEditInternal.msgSW,        string:	WITH ioStatus: status SELECT FROM	  invalidChannel => "invalidChannel"L,	  invalidDriveState =>	    IF DiskEditInternal.labels	      AND NoLabelToLabelCommand[diskDrive.currentCommand]	          = [verify, write, write]	        THEN "invalidDriveState (can't write label if system volume)"L		ELSE "invalidDriveState"L,	  disk =>  SELECT ioStatus.status FROM	    inProgress => "inProgress"L,	    notReady => "notReady"L,	    recalibrateError => "recalibrateError"L,	    seekTimeout => "seekTimeout"L,	    headerCRCError => "headerCRCError"L,	    reserved6 => "reserved6 (labelCRCError)"L,	    dataCRCError => "dataCRCError"L,	    headerNotFound => "headerNotFound"L,	    reserved9 => "reserved9 (labelVerifyError)"L,	    dataVerifyError => "dataVerifyError"L,	    overrunError => "overrunError"L,	    writeFault => "writeFault"L,	    memoryError => "memoryError"L,	    memoryFault => "memoryFault"L,	    clientError => "clientError"L,	    operationReset => "operationReset"L,	    otherError => "otherError"L,	    ENDCASE =>	      "An unknown PilotDiskFace error status has been returned"L,	            ENDCASE => "An unknown DiskChannel error status has been returned"L];      -- redisplay everything so the user sees the flakey data      IF DiskEditInternal.labels THEN        BEGIN        DiskEditInternal.FillLabelSW[];        FormSW.Display[DiskEditInternal.labelSW];	END;      WindowSwap.UpdateViewFromData[DiskEditInternal.dataWindowKey];      FormSW.Display[	WindowSwap.CurrentViewHandle[DiskEditInternal.dataWindowKey]];      UserTerminal.BlinkDisplay[];      END    ELSE -- status = DiskChannel.goodCompletion      IF DiskEditInternal.labels THEN        SELECT NoLabelToLabelCommand[diskDrive.currentCommand] FROM	  [verify, verify, read], [verify, read, read] =>            BEGIN            WindowSwap.UpdateViewFromData[DiskEditInternal.dataWindowKey];            FormSW.Display[	      WindowSwap.CurrentViewHandle[DiskEditInternal.dataWindowKey]];            IF NoLabelToLabelCommand[diskDrive.currentCommand].label = read THEN	      BEGIN              DiskEditInternal.FillLabelSW[];              FormSW.Display[DiskEditInternal.labelSW];	      END;	    END;	  [verify, verify, write], [verify, write, write] => NULL;	  ENDCASE => ERROR      ELSE -- no labels        SELECT diskDrive.currentCommand FROM	  read =>            BEGIN            WindowSwap.UpdateViewFromData[DiskEditInternal.dataWindowKey];            FormSW.Display[	      WindowSwap.CurrentViewHandle[DiskEditInternal.dataWindowKey]];            END;	  write => NULL;	  ENDCASE => ERROR;    END;  GetDiskAddress: PROCEDURE [] RETURNS [DiskChannel.DiskPageNumber] = INLINE    {RETURN[diskDrive.pageNumberBase+diskDrive.pageNumberOffset]};    LabelToNoLabelCommand: PROCEDURE [cmd: CompatibilityDiskFace.Command]    RETURNS [PilotDiskFace.Command] = INLINE    {RETURN[LOOPHOLE[cmd]]};  MakeParamSW: PUBLIC FormSW.ClientItemsProcType =    BEGIN    nItems: CARDINAL = 17;    items ¬ FormSW.AllocateItemDescriptor[nItems];    items[FormItems.begin.ORD] ¬ FormSW.LabelItem[      tag: NIL, invisible: TRUE, place: FormSW.newLine];    items[FormItems.deviceIndex.ORD] ¬ FormSW.NumberItem[      tag: "Device index"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, value: @diskDrive.driveIndex, proc: NoticeNewDiskDriveIndex,      place: FormSW.newLine];    items[FormItems.pageBase.ORD] ¬ FormSW.LongNumberItem[      tag: "Page Number Base"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, value: @diskDrive.pageNumberBase, place: FormSW.newLine];    items[FormItems.pageOffset.ORD] ¬ FormSW.LongNumberItem[      tag: "Page Number Offset"L, signed: FALSE, notNegative: TRUE,      radix: decimal, default: 0, value: @diskDrive.pageNumberOffset,      place: FormSW.nextPlace];    items[FormItems.pageNumber.ORD] ¬ FormSW.LongNumberItem[      tag: "Page Number for I/O"L, signed: FALSE, notNegative: TRUE,      radix: decimal, default: 0, value: @diskDrive.pageNumberIO,      readOnly: TRUE, place: FormSW.nextPlace];    items[FormItems.daTag.ORD] ¬ FormSW.LabelItem[      tag: "Disk Address"L, place: FormSW.newLine];    items[FormItems.daCyl.ORD] ¬ FormSW.NumberItem[      tag: "   Cylinder"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, value: @diskDrive.cylinder, place: FormSW.nextPlace];    items[FormItems.daHead.ORD] ¬ FormSW.NumberItem[      tag: "Head"L, signed: FALSE, notNegative: TRUE, radix: decimal, default: 0,      value: @diskDrive.head, place: FormSW.nextPlace];    items[FormItems.daSector.ORD] ¬ FormSW.NumberItem[      tag: "Sector"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, value: @diskDrive.sector, place: FormSW.nextPlace];    items[FormItems.convertToPage.ORD] ¬ FormSW.CommandItem[      tag: "Convert to page number"L, proc: PageNumberCommand,      place: FormSW.newLine];    items[FormItems.convertToDA.ORD] ¬ FormSW.CommandItem[      tag: "Convert to disk address"L, proc: DiskAddressCommand,      place: FormSW.nextPlace];    items[FormItems.useDA.ORD] ¬ FormSW.BooleanItem[      tag: "Use disk address"L, switch: @diskDrive.useDiskAddress,      proc: UseDiskAddressCommand, place: FormSW.newLine];    items[FormItems.usePage.ORD] ¬ FormSW.BooleanItem[      tag: "Use page number"L, switch: @diskDrive.usePageNumber,      proc: UsePageNumberCommand, place: FormSW.nextPlace];    BEGIN    enumeratedCommandTypes: ARRAY [0..4) OF FormSW.Enumerated ¬      IF DiskEditInternal.labels THEN        [[string: "vvr"L, value: LabelToNoLabelCommand[	    CompatibilityDiskFace.Command[verify, verify, read]]],         [string: "vvw"L, value: LabelToNoLabelCommand[	    CompatibilityDiskFace.Command[verify, verify, write]]],         [string: "vrr"L, value: LabelToNoLabelCommand[	    CompatibilityDiskFace.Command[verify, read, read]]],         [string: "vww"L, value: LabelToNoLabelCommand[	    CompatibilityDiskFace.Command[verify, write, write]]]]      ELSE  -- no labels        [[string: "read"L, value: PilotDiskFace.Command[read]],         [string: "write"L, value: PilotDiskFace.Command[write]],         [string: ""L, value: PilotDiskFace.Command[noOp]],         [string: ""L, value: PilotDiskFace.Command[noOp]]];    enumeratedTerminationConditions: ARRAY [0..2) OF FormSW.Enumerated ¬ [      [string: "goodCompletion"L, value: TerminationCondition[goodCompletion]], [      string: "failure"L, value: TerminationCondition[failure]]];    diskDrive.currentCommand ¬ IF DiskEditInternal.labels      THEN LabelToNoLabelCommand[[verify, read, read]]      ELSE PilotDiskFace.Command[read];    items[FormItems.command.ORD] ¬ FormSW.EnumeratedItem[      tag: "I/O Command"L, feedback: all, copyChoices: TRUE,      value: @diskDrive.currentCommand,      choices: DESCRIPTOR[enumeratedCommandTypes], place: FormSW.newLine];    items[FormItems.repeatCount.ORD] ¬ FormSW.NumberItem[      tag: "Repeat count"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 1, value: @diskDrive.repeatCount, place: FormSW.nextPlace];    items[FormItems.termCondition.ORD] ¬ FormSW.EnumeratedItem[      tag: "Termination condition"L, feedback: all, copyChoices: TRUE,      value: @diskDrive.terminationCondition,      choices: DESCRIPTOR[enumeratedTerminationConditions],      place: FormSW.newLine];    items[FormItems.doIt.ORD] ¬ FormSW.CommandItem[      tag: "Do it"L, proc: DoDiskIOCommand, place: FormSW.nextPlace];    END;    diskDrive.drive ¬ DriveFromIndex[diskDrive.driveIndex];    diskDrive.channel ¬      IF diskDrive.drive = DiskChannel.nullDrive THEN DiskChannel.nullHandle      ELSE DiskChannel.Create[diskDrive.drive];        RETURN[items, TRUE]    END;  NoLabelToLabelCommand: PROCEDURE [cmd: PilotDiskFace.Command]    RETURNS [CompatibilityDiskFace.Command] = INLINE    {RETURN[LOOPHOLE[cmd]]};  NoticeNewDiskDriveIndex: FormSW.EnumeratedNotifyProcType =    BEGIN    IF oldValue = diskDrive.driveIndex THEN RETURN;    diskDrive.drive ¬ DriveFromIndex[diskDrive.driveIndex];    diskDrive.channel ¬      IF diskDrive.drive = DiskChannel.nullDrive THEN DiskChannel.nullHandle      ELSE DiskChannel.Create[diskDrive.drive];    END;    PageNumberCommand: FormSW.ProcType =    BEGIN    IF ~ValidateDrive[] THEN RETURN;    diskDrive.pageNumberIO ¬ DiskChannel.GetPageNumber[      drive: diskDrive.drive,      page: [cylinder: diskDrive.cylinder, head: diskDrive.head,        sector: diskDrive.sector]];    diskDrive.pageNumberBase ¬ diskDrive.pageNumberIO;    diskDrive.pageNumberOffset ¬ 0;    FormSW.DisplayItem[sw, FormItems.pageBase.ORD];    FormSW.DisplayItem[sw, FormItems.pageOffset.ORD];    FormSW.DisplayItem[sw, FormItems.pageNumber.ORD];    END;  DriveFromIndex: PROCEDURE [index: CARDINAL]    RETURNS [DiskChannel.Drive] =    BEGIN    drive: DiskChannel.Drive;    found: BOOLEAN ¬ FALSE;    FOR drive ¬ DiskChannel.GetNextDrive[DiskChannel.nullDrive],        DiskChannel.GetNextDrive[drive] UNTIL drive = DiskChannel.nullDrive  DO      IF index = DiskChannel.GetDriveAttributes[drive].deviceOrdinal THEN        {found ¬ TRUE; EXIT;};      ENDLOOP;    IF found THEN RETURN[drive]    ELSE RETURN[DiskChannel.nullDrive];    END;  UseDiskAddressCommand: FormSW.ProcType =    BEGIN    IF ~ValidateDrive[] THEN RETURN;    diskDrive.usePageNumber ¬ FALSE;    IF DiskChannel.GetPageNumber[diskDrive.drive, diskDrive.address] IN      [0..DiskChannel.GetDriveAttributes[diskDrive.drive].nPages) THEN      diskDrive.diskAddressValid ¬ TRUE    ELSE diskDrive.diskAddressValid ¬ FALSE;    FormSW.DisplayItem[sw, FormItems.useDA.ORD];    FormSW.DisplayItem[sw, FormItems.usePage.ORD];    END;  UsePageNumberCommand: FormSW.ProcType =    BEGIN    IF ~ValidateDrive[] THEN RETURN;    diskDrive.useDiskAddress ¬ FALSE;    FormSW.DisplayItem[sw, FormItems.useDA.ORD];    IF GetDiskAddress[] IN      [0..DiskChannel.GetDriveAttributes[diskDrive.drive].nPages) THEN      diskDrive.pageNumberValid ¬ TRUE    ELSE diskDrive.pageNumberValid ¬ FALSE;    FormSW.DisplayItem[sw, FormItems.useDA.ORD];    FormSW.DisplayItem[sw, FormItems.usePage.ORD];    END;  ValidateDiskHead: PROCEDURE[] RETURNS [BOOLEAN] =    BEGIN RETURN[diskDrive.head IN [0..LAST[HeadAndSectorType]]]; END;  ValidateDiskPageNumber: PROCEDURE[] RETURNS [BOOLEAN] =    BEGIN    RETURN[      GetDiskAddress[] IN        [0..DiskChannel.GetDriveAttributes[diskDrive.drive].nPages)];    END;  ValidateDiskSector: PROCEDURE[] RETURNS [BOOLEAN] =    BEGIN RETURN[diskDrive.sector IN [0..LAST[HeadAndSectorType]]]; END;    ValidateDrive: PROCEDURE [] RETURNS [valid: BOOLEAN] =    BEGIN    valid ¬ (diskDrive.channel ~= DiskChannel.nullHandle);    IF ~valid THEN      BEGIN      MsgSW.Post[sw: DiskEditInternal.msgSW, string: "Invalid device specified"L];      UserTerminal.BlinkDisplay[];      RETURN;      END;    END;  END.LOG10-Sep-81  9:49:21   WDK       Converted to Tajo 8, Pilot 8.13-May-82 10:42:39   AWL         Drive enumeration should be on DeviceTypes.anyPilotDisk.  numDrives declared wrong.13-Oct-82 16:45:36   AWL         Support q2000 as the same device type as q2040.22-Apr-83 14:35:55   EKN      Update to Klamath 27-Jun-83 11:33:02   Yien   Bug fixed in procedure MakeParamSW 15-Jul-83 15:02:18   AWL         Add initialization code for diskDrive in MakeFormSw proc to acknowledge the initial drive.29-Nov-83 17:28:31	EKN      Changed items: diskDrive.driveIndex, diskDrive.pageNumber, diskDrive.cylinder, diskDrive.head, diskDrive.sector, diskDrive.repeatCountto display decimals instead of octals.10-Jan-84 17:33:21   KEK        DriveFromIndex always chose drive 0.12-Apr-84 17:37:40   AWL          Two part page numbers.21-Aug-84 15:09:48   CAJ     Convert to WindowSwap.22-Apr-85 16:34:35   CAJ     Make DoDiskIOCommand resilient to being called while window registering not quite complete.16-Sep-86 11:00:02   CAJ     Convert to handle either label or no-label operation.  I/O is now via DoDirectIO instead of DoIO.13-Jul-87 13:40:33   CAJ     Fix bug where UseDiskAddress didn't. 3-Mar-88 12:40:52   CAJ     Form index cleanup.
-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- VMTestDriver.mesa     25-Apr-83 16:30:55 by CAJ -- Virtual memory test program.-- VMTestDriver is the test driver for VMTest, a test program for Klamath Pilot.  VMTest is based on a model of Pilot Virtual Memory.DIRECTORY  Ascii USING [BS],  Environment USING [PageCount],  PostAuxDefs USING [    Checkpoint, Confirm, Create, Destroy, SetCurrentTick, SetPauseAtTick,    SetSingleStep, SetTraceFlag],  PostDefs USING [cr, crString, del, GetChar, GetNumber, Post, PostChar,    PostLine, RemoveCharacter, sp],  Process USING [Detach],  Runtime USING [CallDebugger, GetBcdTime],  ScriptOps USING [maxNameLength, DeregisterScript, GetNext, GetScript,    NoSuchScript, Shutdown],  String USING [AppendChar, InvalidNumber],  System USING [GetGreenwichMeanTime, GreenwichMeanTime],  Time USING [Append, Unpack],  VMTestDatabase USING [Initialize, Shutdown, TestVMTooBig],  VMTestScript USING [DefaultScript],  VMTestSpace USING [Shutdown];VMTestDriver: PROGRAM  IMPORTS    PostAuxDefs, PostDefs, Process, Runtime, ScriptOps, String, System, Time,    VMTestDatabase, VMTestScript, VMTestSpace =  BEGIN  ------------  -- GLOBAL variables, types and constants  Error: ERROR [type: ErrorType] = CODE;  ErrorType: TYPE = {phantomScript};  vmSize: CARDINAL ¬ 25;  -- This is the default setting for the number of pages in test VM.  It may be  -- changed via the "V" command.  -- Note use of CARDINAL here for value which is properly Environment.PageCount.  -- This is intended to limit its range of values.  -- Keep this for later use with exerciser mode:  -- initialRandomSeed: RandDefs.Seed ¬ 573923741;  ------------  -- PUBLIC procedures:  -- Public Procedure TopLevel, the top level driver of the test program VMTest.  TopLevel: PUBLIC PROCEDURE =    BEGIN    c: CHARACTER;    dateString: STRING ¬ [40];    OneTimeSetup[];    Time.Append[dateString, Time.Unpack[Runtime.GetBcdTime[]], TRUE];    PostDefs.PostLine[PostDefs.crString, "*** VMTest of "L, dateString, " ***"L];    DO  -- Keep repeating VMTest as requested.      PostDefs.Post[PostDefs.crString];      PostDefs.Post["-> "L];      c ¬ PostDefs.GetChar[];      SELECT c FROM        PostDefs.cr, PostDefs.sp => PostDefs.PostLine[];        '? =>          PostDefs.PostLine[            "? -- Commands are: ""- comment"", ""CoPilot"", ""DeregisterScript"", ""Quit"", ""Reset"", ""TestVM"", ""VMSize"""L];        '- => {PostDefs.Post["-- "L]; SoakUpComment[]};        'c, 'C =>          BEGIN          PostDefs.Post["CoPilot"L];          IF PostAuxDefs.Confirm[] THEN            Runtime.CallDebugger["Called from VMTest"L];          END;        'd, 'D => {PostDefs.Post["Deregister "L]; DumpScript[]};        'q, 'Q => {PostDefs.Post["Quit"L]; IF PostAuxDefs.Confirm[] THEN EXIT};        'r, 'R => {	  PostDefs.Post["Reset"L]; IF PostAuxDefs.Confirm[] THEN OneTimeSetup[]};        't, 'T => {          PostDefs.PostLine["TestVM"L]; TestVM[]};        'v, 'V => {PostDefs.Post["VMSize"L]; VMSize[]};        ENDCASE => {          PostDefs.PostChar[c];          PostDefs.PostLine[" - ???  Type ""?"" for help."L]};      ENDLOOP;    OneTimeCleanup[];    RETURN;  -- Terminating this process.    END;  ------------  -- PRIVATE procedures:  -- Implements the "D" (Deregister script) command.  Queries user for script  -- name then removes it from the list of available scripts.  Scripts come  -- to be registered by registering themselves at startup via  -- ScriptOps.RegisterScript.  DumpScript: PROCEDURE =    BEGIN    scriptName: STRING = [ScriptOps.maxNameLength];    GetName[scriptName];    SELECT scriptName[0] FROM      PostDefs.del, PostDefs.cr => PostDefs.PostLine["...aborted"L];      '* => PostDefs.PostLine["\\One at a time, please."L];      ENDCASE => ScriptOps.DeregisterScript[scriptName        ! ScriptOps.NoSuchScript => Error[phantomScript]];    END;  -- Query user for script name.  Persists until it receives a valid name  -- (i.e., matches registered script name) or one of the special character  -- names: *, CR, or DEL.  An initial '?' causes printing of all available names.  GetName: PROCEDURE [name: LONG STRING] =    BEGIN    Term: PROCEDURE [c: CHARACTER] RETURNS [BOOLEAN] = {RETURN[c = PostDefs.cr]};    ValidName: PROCEDURE RETURNS [BOOLEAN] =      BEGIN      [] ¬ ScriptOps.GetScript[name ! ScriptOps.NoSuchScript => GOTO invalidName];      RETURN[TRUE];      EXITS        invalidName => {PostDefs.PostLine["\\No such script"L]; RETURN[FALSE]};      END;    DO  -- until we get a usable name      PostDefs.Post["Script Name: "L];      name.length ¬ 1;      name[0] ¬ PostDefs.GetChar[];      SELECT name[0] FROM	'? => {PostDefs.PostChar[name[0]]; ListScripts[]; LOOP};          '* => {PostDefs.PostChar[name[0]]; EXIT};        PostDefs.cr, PostDefs.del => EXIT;        Ascii.BS => {name[0] ¬ PostDefs.del; EXIT};	ENDCASE =>	  BEGIN	  PostDefs.PostChar[name[0]];	  GetEditedString[name];	  IF name[0] = PostDefs.del THEN EXIT;          IF ValidName[] THEN EXIT;	  END;      ENDLOOP;    END;  -- GetEditedString is analagous to PostDefs/TTY.GetEditedString except  -- that Rubout is the only editing character recognized.  We have to have  -- our own version because the PostDefs/TTY version does not allow  -- continuing an already-started string (i.e, continuing to read a string  -- after determining the first character was not a special character).  GetEditedString: PROCEDURE [s: LONG STRING] =    BEGIN    char: CHARACTER;    WHILE (char ¬ PostDefs.GetChar[]) ~= PostDefs.cr DO      SELECT char FROM        Ascii.BS => {IF s.length ~= 0 THEN	  {PostDefs.RemoveCharacter[]; s.length ¬ s.length - 1}};	PostDefs.del => {s[0] ¬ PostDefs.del; s.length ¬ 1; EXIT};	ENDCASE => {PostDefs.PostChar[char]; String.AppendChar[s, char]}      ENDLOOP;    END;   -- Prints the names of all scripts which have been registered.  Includes  -- lines for the default script and for no script at all.  ListScripts: PROCEDURE =    BEGIN    name: LONG STRING ¬ NIL;    PostDefs.Post[PostDefs.crString];    PostDefs.PostLine["Scripts available:"L];    WHILE (name ¬ ScriptOps.GetNext[name]) ~= NIL DO      PostDefs.Post["  "L]; PostDefs.PostLine[name] ENDLOOP;    PostDefs.PostLine["  (all of the above: type *)"L];    PostDefs.PostLine["  (none of the above: type DEL)"L];    END;  -- Implements the "-" (Comment) command.  SoakUpComment: PROCEDURE =    BEGIN    char: CHARACTER;    DO      char ¬ PostDefs.GetChar[];      PostDefs.PostChar[char];  -- Echo the character.      IF char = PostDefs.cr THEN EXIT;      IF char = PostDefs.del THEN {PostDefs.PostLine[" XXX"L]; EXIT};      ENDLOOP;    END;  -- Implements the "T" (Test VM) command.  -- TestVM runs the VM Test once.  TestVM: PROCEDURE =    BEGIN    scriptName: STRING = [ScriptOps.maxNameLength];    script: PROCEDURE;    GetName[scriptName];    SELECT scriptName[0] FROM      PostDefs.del => GOTO skipIt;      PostDefs.cr =>        {script ¬ VMTestScript.DefaultScript; PostDefs.Post["(default)"L]};      '* =>        {PostDefs.Post["(do all scripts) "L];	 IF PostAuxDefs.Confirm[] THEN script ¬ NIL ELSE GOTO skipIt};      ENDCASE =>        script ¬ ScriptOps.GetScript[scriptName	  ! ScriptOps.NoSuchScript => Error[phantomScript]];    PostDefs.Post[PostDefs.crString];    -- Here we have a verified script, or NIL script indicating do all scripts    SetupTestInstance[ ! VMTestDatabase.TestVMTooBig => GOTO initFailed];    IF script ~= NIL THEN script[]    ELSE      BEGIN      name: LONG STRING ¬ NIL;      WHILE (name ¬ ScriptOps.GetNext[name]) ~= NIL DO        script ¬ ScriptOps.GetScript[name	  ! ScriptOps.NoSuchScript => Error[phantomScript]];	PostDefs.Post["Script: "L];	PostDefs.PostLine[name];	script[];	ENDLOOP;      END;    PostAuxDefs.Checkpoint[];    -- plug in exerciser mode here (see Morrison's SpaceTest program    --  (Pilot 6.0b) for extensive guidance)    CleanupTestInstance[];    EXITS      initFailed => {PostDefs.PostLine["Test VM too big: test aborted."L];		CleanupTestInstance[]};      skipIt => PostDefs.PostLine["\\ test skipped."L];    END;  -- Implements the "V" (VM size) command.  -- Show the current value for the number of pages in test VM.  Input (optional)  -- will reset VM size  VMSize: PROC =    BEGIN    ok: BOOLEAN ¬ TRUE;    errorPrompt: STRING = "\\ ¬ "L;    prompt: STRING ¬ " ¬ "L;    DO  -- until acceptable number      PostDefs.Post[prompt];      vmSize ¬ PostDefs.GetNumber[default: vmSize, radix: 10        ! String.InvalidNumber => {prompt ¬ errorPrompt; LOOP}];	  -- Note: calling PostDefs proc in catch phrase => PostDefs deadlock.      EXIT;      ENDLOOP;    PostDefs.Post[PostDefs.crString];    END;  -- OneTimeSetup is test program initialization and setup code to be executed  -- before stopping for user input.  When we stop for input, the user has a  -- convenient chance to modify "initial" variables via the debugger.  OneTimeSetup: PROCEDURE =    BEGIN    PostAuxDefs.SetCurrentTick[];    PostAuxDefs.SetPauseAtTick[];    PostAuxDefs.SetSingleStep[FALSE];    PostAuxDefs.SetTraceFlag[TRUE];    END;  -- OneTimeCleanup does final test shutdown before termination.  OneTimeCleanup: PROCEDURE =    BEGIN    ScriptOps.Shutdown[];    VMTestSpace.Shutdown[];    PostAuxDefs.Destroy[];  -- Destroy the window.    END;  -- SetupTestInstance is setup code to be executed each time TestVM is run.  -- This happens after stopping for user input, i.e., after the user has had  -- a chance to modify "initial" variables via the debugger.  SetupTestInstance: PROCEDURE =    BEGIN ENABLE UNWIND => NULL;    dateString: STRING ¬ [40];    Time.Append[dateString, Time.Unpack[System.GetGreenwichMeanTime[]], TRUE];    PostDefs.PostLine["*** Test begun "L, dateString, " ***"L, PostDefs.crString];    -- Keep for later use in exerciser mode    --RandDefs.InitInstanceGenerator[initialRandomSeed];    VMTestDatabase.Initialize[vmSize];    END;  -- Cleanup finishes up a run of VMTest.  CleanupTestInstance: PROCEDURE =    BEGIN    VMTestDatabase.Shutdown[];    PostDefs.PostLine["*** End of VMTest ***"L];    PostAuxDefs.Checkpoint[];    END;  -- Main line code  -- Initialize window handler  PostAuxDefs.Create["VMTest.log" --, default length = infinite-- ];  -- FORK the test and return to the tools notifier  Process.Detach[FORK TopLevel[]];  END.LOG OF SIGNIFICANT CHANGES20-Aug-82 16:36:52   CAJ    Created file.
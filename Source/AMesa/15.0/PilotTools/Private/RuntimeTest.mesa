-- Copyright (C) 1983, 1987  by Xerox Corporation. All rights reserved. -- RuntimeTest.mesa     10-Feb-87 11:30:20 by CJSDIRECTORY  Command USING [Action, Break, Confirm, InstallTopLevel],  ESCAlpha USING [aNILCKL],  Frame USING [Free, MyLocalFrame],  FrameExtras USING [GlobalOverhead, MyGlobalFrame],  Mopcodes USING [zBNDCK, zESC],  PilotCommand USING [defaultWindow],  PrincOps USING [ControlLink, Port, TrapLink, UnboundLink],  RandomDefs USING [GeneratorState, Randomize, Random],  Runtime,  SpecialRuntimeExtras USING [GlobalFrameFromProgram,  ProgramFromGlobalFrame],  String USING [AppendDecimal, AppendString],  TTY USING [Handle, PutLine, PutString];RuntimeTest: PROGRAM  IMPORTS Command, Frame, FrameExtras, PilotCommand, RandomDefs, Runtime,   SpecialRuntimeExtras, String, TTY =  BEGIN OPEN Runtime;    tty: TTY.Handle = PilotCommand.defaultWindow;  success: BOOLEAN;  stackMaxDepth: CARDINAL;  -- the number of items the stack will actually hold.  PtrfriendFrame: TYPE = LONG POINTER TO FRAME[RuntimeTest];  pFriendFrame: PtrfriendFrame;  friend: PROGRAM;  -- is also a ptrfriendFrame  self: PROGRAM =    SpecialRuntimeExtras.ProgramFromGlobalFrame[FrameExtras.MyGlobalFrame[]];  randomSeed: LONG POINTER TO RandomDefs.GeneratorState = RandomDefs.Randomize[0];  Report: PROCEDURE [success: BOOLEAN, case: STRING] =    BEGIN    TTY.PutString[tty, case];    TTY.PutString[tty, "  --  "L];    IF success THEN TTY.PutLine[tty, "succeeded."L]    ELSE {      TTY.PutString[tty, "failed."L];      Command.Break[tty, "runtime test failure"L]};    END;  CallGetCaller: PROCEDURE RETURNS [PROGRAM] = {RETURN[GetCaller[]]};  Undefined: PROCEDURE ¬ LOOPHOLE[PrincOps.TrapLink];  Defined: PROCEDURE = {Report[TRUE, "RESUME ControlFault"L]};  Unbound: PROCEDURE ¬ LOOPHOLE[PrincOps.UnboundLink];  Bound: PROCEDURE = {Report[TRUE, "RESUME UnboundProcedure"L]};    BndCheck: PROC [check, limit: CARDINAL] RETURNS [checkCopy: CARDINAL] =    --IF limit >= check THEN SIGNAL Runtime.BoundsFault; RETURN[checkCopy]    MACHINE CODE BEGIN Mopcodes.zBNDCK END;    LongNilCheck: PROC [p: LONG POINTER] RETURNS [copyP: LONG POINTER] =    -- if p=NIL THEN SIGNAL Runtime.PointerFault; RETURN[p]    MACHINE CODE BEGIN Mopcodes.zESC, ESCAlpha.aNILCKL END;    Destroy: PROCEDURE ¬ {SelfDestruct[]};  CauseStackErrorOverflow: PROCEDURE =    BEGIN    Push1: PROCEDURE [a: CARDINAL] = MACHINE CODE BEGIN END;    FOR k: CARDINAL ¬ 1, k + 1 --UNTIL stack overflows-- DO      stackMaxDepth ¬ k; Push1[k]; ENDLOOP;      -- actually, we will overflow the stack here when we attempt      -- to push k to increment it.  This is why we start counting      -- from 1 and not 0.    END;  RuntimeCmd: Command.Action =    BEGIN    message:    STRING ¬ [50];    HiddenSelf: POINTER = Frame.MyLocalFrame[];    In, Out:    PORT;    pIn:        POINTER TO PrincOps.Port = LOOPHOLE[@In];    pOut:       POINTER TO PrincOps.Port = LOOPHOLE[@Out];    PortCall: PROCEDURE = {Out[]};    Command.Confirm[h];    TTY.PutLine[h, "RuntimeTest of 14-Oct-8"L];    success ¬ TRUE;    ValidateGlobalFrame[LOOPHOLE[self] ! ANY => {success ¬ FALSE; CONTINUE}];    Report[success, "ValidateGlobalFrame"L];    success ¬ FALSE;    ValidateGlobalFrame[      HiddenSelf ! InvalidGlobalFrame => {success ¬ TRUE; CONTINUE}];    Report[success, "InvalidGlobalFrame"L];    success ¬ TRUE;    ValidateFrame[HiddenSelf ! ANY => {success ¬ FALSE; CONTINUE}];    Report[success, "ValidateFrame"L];    success ¬ FALSE;    ValidateFrame[HiddenSelf + 1 ! InvalidFrame => {success ¬ TRUE; CONTINUE}];    Report[success, "InvalidFrame"L];    Report[TRUE, "New not implemented"L];    success ¬ FALSE;    Undefined[ ! ControlFault => {success ¬ TRUE; CONTINUE}];    Report[success, "ControlFault"L];    pFriendFrame ¬ LOOPHOLE[SpecialRuntimeExtras.GlobalFrameFromProgram[NEW self]];    friend ¬ SpecialRuntimeExtras.ProgramFromGlobalFrame[LOOPHOLE[pFriendFrame]];      -- an alias    Report[GlobalFrame[pFriendFrame] = friend, "GlobalFrame[global frame]"L];    Report[GlobalFrame[HiddenSelf] = self, "GlobalFrame[local frame]"L];    Report[      GlobalFrame[LOOPHOLE[Destroy]] = self, "GlobalFrame[local procedure]"L];    Report[      GlobalFrame[LOOPHOLE[PortCall]] = self, "GlobalFrame[nested procedure]"L];    Report[      GlobalFrame[LOOPHOLE[pFriendFrame.Destroy]] = friend,      "GlobalFrame[external procedure]"L];    UnNew[friend];    Report[GlobalFrame[pFriendFrame] = NullProgram, "GlobalFrame[unnewed]"L];    pFriendFrame ¬ LOOPHOLE[SpecialRuntimeExtras.GlobalFrameFromProgram[NEW self]];    friend ¬ SpecialRuntimeExtras.ProgramFromGlobalFrame[LOOPHOLE[pFriendFrame]];    START pFriendFrame;    success ¬ FALSE;    START pFriendFrame[ ! StartFault => {success ¬ dest = friend; CONTINUE}];    Report[success, "StartFault"L];    pFriendFrame.Destroy[];    Report[      GlobalFrame[pFriendFrame] = NullProgram, "GlobalFrame[selfdestructed]"L];    Report[TRUE, "SelfDestruct[]"L];    success ¬ FALSE;    Unbound[ ! UnboundProcedure => {success ¬ TRUE}];    Report[success, "UnboundProcedure"L];    Report[CallGetCaller[] = self, "GetCaller[]"L];    Report[IsBound[LOOPHOLE[Report]], "IsBound[bound]"L];    Report[~IsBound[LOOPHOLE[Unbound]], "IsBound[unbound]"L];    Report[~IsBound[LOOPHOLE[Undefined]], "IsBound[null]"L];    THROUGH [0..10] DO      index:    CARDINAL = RandomDefs.Random[randomSeed, LAST[CARDINAL]];      limit:    CARDINAL = RandomDefs.Random[randomSeed, LAST[CARDINAL]];      returned: CARDINAL;      success ¬ (index < limit);      returned ¬ BndCheck[index, limit      ! Runtime.BoundsFault => {success ¬ (index >= limit); RESUME}];      Report[success AND (index=returned), "Bounds Fault"L];      ENDLOOP;        BEGIN    lp: LONG POINTER ¬ NIL;    THROUGH [0..10] DO      returned: LONG POINTER;      success ¬ (lp # NIL);      returned ¬ LongNilCheck[lp      ! Runtime.PointerFault => {success ¬ (lp = NIL); RESUME}];      Report[success AND (lp = returned), "LONG NIL check"L];      lp ¬ LOOPHOLE[        LONG[RandomDefs.Random[randomSeed, LAST[CARDINAL]]]	*LONG[RandomDefs.Random[randomSeed, LAST[CARDINAL]]]];      ENDLOOP    END;    CallDebugger["CallDebugger[] test. Type Proceed. Will be back here with a Stack Error next; at that time, type Quit."L];    Report[TRUE, "CallDebugger"L];    success ¬ FALSE;    CauseStackErrorOverflow[ !  --      -- A stack error takes us straight to the debugger.      -- The operator should Quit, which will raise ABORTED.      ABORTED => {success ¬ TRUE; CONTINUE}];    message.length ¬ 0;    String.AppendString[      to: message, from: "StackError (overflow)   (actual stack size is "L];    String.AppendDecimal[message, stackMaxDepth];    String.AppendString[to: message, from: ")"L];    Report[success, message];    success ¬ FALSE;    PortCall[ ! LinkageFault => {success ¬ TRUE; CONTINUE}];    Frame.Free[pOut.frame];  -- PortCall's frame, which was skipped by Signaller    Report[success, "LinkageFault"L];    success ¬ FALSE;    pOut­ ¬ [links[frame: NIL, fill: NULL, dest: [indirect[port[pIn]]]]];      -- CONNECT Out TO In    PortCall[ ! PortFault => { success ¬ TRUE; CONTINUE}];    Frame.Free[pOut.frame];  -- PortCall's frame, which was skipped by Signaller    Report[success, "PortFault"L];    END;    IF ~FrameExtras.GlobalOverhead[        SpecialRuntimeExtras.GlobalFrameFromProgram[self]].extra.copied      THEN Command.InstallTopLevel[tty, ["test runtime", RuntimeCmd]];  END.LOG   (For previous log entries, please see Mesa 8.0 archive version.)April 23, 1980  4:01 PM   AWL   Deleted GlobalFrame[UnNewed], SelfDestruct[] tests.   Produced AddressFault with new, "improved" ValidateGlobalFrame.June 16, 1980  11:04 AM   WDK   Test stack overflow for arbitrary stack size.August 13, 1980  10:55 PM   SXY   IODefs and Command are replaced by TTY and TTYCommand respectively.September 8, 1980  7:56 PM   SXY   TTYCommand is replaced by new Command.October 16, 1981  11:46 AM   XXR   Added Boundsfault and NILcheck tests20-Nov-81 17:14:02   CAJ   Updated LongNilCheck for new instructin set; deleted (short)NilCheck; mods for new global frame access.25-Oct-82 15:41:35   WDK	StackError no longer a SIGNAL.18-Aug-83 10:56:35   JXP	Convert to 11.0b.13-Jun-85 14:42:00   CJS	Error recovery, robustness.10-Feb-87 11:29:47   CJS	Frame.MyGlobalFrame ¬ FrameExtras.MyGlobalFrame, SpecialRuntime ¬ SpecialRuntimeExtras.   
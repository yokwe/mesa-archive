-- Copyright (C) 1983, 1986  by Xerox Corporation. All rights reserved. -- SpecialCommands.mesa (last edited by: RSV    on:  2-Sep-86 15:56:54)-- Code to find the drive number given a DiskBackingStore.Data.channelHandle-- has been commented out.  It can be added again when a facility is developed-- that lets you get away with not having to export a private interface. DIRECTORY  Ascii USING [CR, SP],  BackingStore USING [Run],  Boot USING [BootFileType],  Command USING [    Action, Catch, Confirm, Entry, InstallTopLevel, Loop, QuitLevel, Scan,    WriteError],  Device USING [Type],  File USING [File, GetSize, ID, PageNumber, Type],  KernelFile USING [GetBootLocation, GetRootFile, MakeBootable, MakeUnbootable],  PilotCommand,  PilotDiskFace USING [DiskAddress],  PilotFileTypes USING [tUnassigned],  Process USING [Pause, SecondsToTicks],  Snapshot USING [InLoad, OutLoad],  Space,  SpecialFile USING [    GetBackingStoreRun, InterpretBackingStoreRun, InvalidParameters, SetDebuggerFiles],  SpecialRuntime USING [VisitDebugger],  SpecialSpace USING [AllocateForCode],  String,  TTY USING [    Handle, GetID, GetLongNumber, PutChar, PutDecimal, PutLine, PutLongOctal,    PutOctal, PutString, UserAbort],  VM USING [Interval, MakeResident, MakeSwappable, ReturnWait];SpecialCommands: PROGRAM  IMPORTS    Command, File, KernelFile, PilotCommand, Process, Snapshot,     Space, SpecialFile, SpecialRuntime, SpecialSpace, String, TTY, VM  SHARES File =  BEGIN  -- Global variables    entries: ARRAY [0..15) OF Command.Entry ¬ [    ["commands", LoopCmd],  -- must be first    ["anywhere code space create", AnywhereCodeAllocateCmd],    ["code space create", CodeAllocateCmd],    ["exercise germ server", GermServerCmd],    ["exercise germ user", GermUserCmd],     ["in load", InLoadCmd],    ["interpret backingstore run", InterpretBackingStoreRunCmd],     ["make bootable", MakeBootableCmd],     ["make resident", MakeResidentCmd],    ["make swappable", MakeSwappableCmd],    ["make unbootable", MakeUnBootableCmd],    -- ["next file", NextFileCmd],    ["out load", OutLoadCmd],    ["pilot root", PilotRootFileCmd],    ["set debugger files", SetDebuggerFilesCmd],    ["quit", Command.QuitLevel]];     	     -- must be last      link: PilotDiskFace.DiskAddress;  tty: TTY.Handle = PilotCommand.defaultWindow;  run: BackingStore.Run ¬ [0, NULL];  -- Action procedures  SpecialCmd: Command.Action =    BEGIN    TTY.PutChar[h, Ascii.SP];    Command.Scan[h, DESCRIPTOR[BASE[entries], LENGTH[entries] - 1], SpecialCatch]    END;  AnywhereCodeAllocateCmd: Command.Action =    BEGIN    count: Space.PageCount;    TTY.PutString[h, " count: "];    count ¬ TTY.GetLongNumber[h: h, default: 1, radix: 8];    PilotCommand.SetSICur[      SpecialSpace.AllocateForCode[count: count, within: PilotCommand.GetSICur[]]];    PilotCommand.WriteSHCur[h]    END;  CodeAllocateCmd: Command.Action =    BEGIN    count: Space.PageCount;    TTY.PutString[h, " count: "];    count ¬ TTY.GetLongNumber[h: h, default: 1, radix: 8];    PilotCommand.SetSICur[      SpecialSpace.AllocateForCode[count: count, within: PilotCommand.GetSICur[]]];    PilotCommand.WriteSHCur[h]    END;  GermServerCmd: Command.Action =    BEGIN    i: CARDINAL;    fbEr, fbEe: CARDINAL;    fcEr, fcEe: File.File;    TTY.PutString[h, " Debuggee outload "L];    PilotCommand.ReadFIDCur[h];    fcEe ¬ PilotCommand.GetFileCur[];    PilotCommand.ReadFBCur[h];    fbEe ¬ PilotCommand.GetFBCur[];    TTY.PutString[h, " Debugger outload "L];    PilotCommand.ReadFIDCur[h];    fcEr ¬ PilotCommand.GetFileCur[];    PilotCommand.ReadFBCur[h];    fbEr ¬ PilotCommand.GetFBCur[];    TTY.PutLine[h, "Type STOP key to stop."];    FOR i ¬ 1, i + 1 WHILE ~Done[] DO      TTY.PutDecimal[h, i];      TTY.PutChar[h, Ascii.SP];      IF ~Snapshot.OutLoad[fcEr, fbEr].inLoaded THEN        BEGIN        IF i = 1 THEN          BEGIN          TTY.PutString[            h, "Proceed if Debuggee outLoad is valid (else reboot)..."L];          Command.Confirm[h]          END;        Snapshot.InLoad[NIL, NIL, 0, fcEe, fbEe]        END      ENDLOOP    END;  GermUserCmd: Command.Action =    BEGIN    i: CARDINAL;    Command.Confirm[h];    TTY.PutLine[h, "Type STOP key to stop."];    FOR i ¬ 1, i + 1 WHILE ~Done[] DO      SpecialRuntime.VisitDebugger[];  -- a CoPilot will automatically proceed...      TTY.PutDecimal[h, i];      TTY.PutChar[h, Ascii.SP]      ENDLOOP    END;  InLoadCmd: Command.Action = {    Snapshot.InLoad[      NIL, NIL, 0, PilotCommand.GetFileCur[], PilotCommand.GetFBCur[]]};  InterpretBackingStoreRunCmd: Command.Action =    BEGIN    file: File.File;    page: File.PageNumber;    fileType: File.Type;    IF run.count = 0 THEN      --do a GetBackingStoreRun first      BEGIN      TTY.PutChar[h, Ascii.CR];      TTY.PutString[h, "page: "L];      page ¬ TTY.GetLongNumber[h: h, default: 0, radix: 8];      run ¬ SpecialFile.GetBackingStoreRun[        file: PilotCommand.GetFileCur[], page: page,	type: PilotFileTypes.tUnassigned].run;      END;    [file, page, fileType] ¬ SpecialFile.InterpretBackingStoreRun[run];    TTY.PutChar[h, Ascii.CR];    PilotCommand.WriteFileIDs[h, file];    TTY.PutChar[h, Ascii.CR];    TTY.PutString[h, "  page = "L];    TTY.PutLongOctal[h, page];    TTY.PutChar[h, Ascii.CR];    TTY.PutString[h, "  fileType = "L];    TTY.PutOctal[h, fileType];    END;  LoopCmd: Command.Action =    BEGIN    Command.Loop[      h, DESCRIPTOR[@entries[1], LENGTH[entries] - 1], SpecialCatch, "special "L]    END;  MakeBootableCmd: Command.Action =    BEGIN    count: Space.PageCount;    page: File.PageNumber;    type : Boot.BootFileType;    Command.Confirm[h];    PilotCommand.ReadFBCur[h];    TTY.PutString[h, " count:"L];    count ¬ TTY.GetLongNumber[      h: h, default: File.GetSize[PilotCommand.GetFileCur[]], radix: 10];    «TTY.PutString[h, " link:"L];    LOOPHOLE[link, LONG CARDINAL] ¬ ReadLongNumber[      default: LOOPHOLE[link], radix: 8];»    TTY.PutString[h, " type: will default to pilot"L];    type ¬ pilot;    link ¬ KernelFile.MakeBootable[      PilotCommand.GetFileCur[], PilotCommand.GetFBCur[], count, type];    TTY.PutString[h, " gives link:"L];    WriteLongOctal[LOOPHOLE[link]];    TTY.PutChar[h, Ascii.CR];    TTY.PutString[h, " page: "L];    page ¬ TTY.GetLongNumber[h: h, default: 0, radix: 8];    TTY.PutString[h, " page: "L];    WriteBootLocation["(current)"L, PilotCommand.GetFileCur[], page];    PilotCommand.SetFBCur[PilotCommand.GetFBCur[] + CARDINAL[count]]    END;  MakeResidentCmd: Command.Action =    BEGIN    returnWait: VM.ReturnWait ¬ wait;    si: Space.Interval ¬ PilotCommand.GetSICur[];    vi: VM.Interval ¬ [Space.PageFromLongPointer[si.pointer], si.count];     Command.Confirm[h];    VM.MakeResident[vi, returnWait]    END;  MakeSwappableCmd: Command.Action =    BEGIN    si: Space.Interval ¬ PilotCommand.GetSICur[];    vi: VM.Interval ¬ [Space.PageFromLongPointer[si.pointer], si.count];    Command.Confirm[h];    VM.MakeSwappable[vi]    END;  MakeUnBootableCmd: Command.Action =    BEGIN    page: File.PageNumber;    count: Space.PageCount;    Command.Confirm[h];    PilotCommand.ReadFBCur[h];    TTY.PutString[h, " count:"L];    count ¬ TTY.GetLongNumber[      h: h, default: File.GetSize[PilotCommand.GetFileCur[]], radix: 10];    KernelFile.MakeUnbootable[      PilotCommand.GetFileCur[], PilotCommand.GetFBCur[], count];    TTY.PutString[h, " page: "L];    page ¬ TTY.GetLongNumber[h: h, default: 0, radix: 8];    TTY.PutChar[h, Ascii.CR];    WriteBootLocation["(current)"L, PilotCommand.GetFileCur[], page]    END;  «NextFileCmd: Command.Action =    BEGIN    --token needs to be set    token: VolTable.LVToken;    file: File.File ¬ PilotCommand.GetFileCur[];    -- file.volumeID is of wrong type to pass to GetNextFile    file.fileID ¬       VolFileMap.GetNextFile[file.volumeID, file.fileID, token];    PilotCommand.SetFileCur[file];    TTY.PutString[h, " is "L];    PilotCommand.WriteFileIDs[h, PilotCommand.GetFileCur[]]    END;»  OutLoadCmd: Command.Action = {    TTY.PutLine[      h,      IF ~Snapshot.OutLoad[      PilotCommand.GetFileCur[], PilotCommand.GetFBCur[]].inLoaded THEN      "(You should probably boot a different volume now.)"L ELSE "Resuming ..."L]};  PilotRootFileCmd: Command.Action =    BEGIN    file: File.File;    PilotCommand.ReadFTCur[h];    file.volumeID ¬ PilotCommand.GetVIDCur[];    file.fileID ¬ KernelFile.GetRootFile[file.volumeID, PilotCommand.GetFTCur[]];    PilotCommand.SetFileCur[file];    TTY.PutString[h, " is "L];    PilotCommand.WriteFileIDs[h, PilotCommand.GetFileCur[]]    END;  SetDebuggerFilesCmd: Command.Action =    BEGIN    dbgerPage, dbgeePage: File.PageNumber;    fbEr, fbEe: CARDINAL;    fcEr, fcEe: File.File;    TTY.PutString[h, " Debuggee outload "L];    PilotCommand.ReadFIDCur[h];    fcEe ¬ PilotCommand.GetFileCur[];    PilotCommand.ReadFBCur[h];    fbEe ¬ PilotCommand.GetFBCur[];    TTY.PutString[h, " Debugger outload "L];    PilotCommand.ReadFIDCur[h];    fcEr ¬ PilotCommand.GetFileCur[];    PilotCommand.ReadFBCur[h];    fbEr ¬ PilotCommand.GetFBCur[];    SpecialFile.SetDebuggerFiles[fcEr, fcEe, fbEr, fbEe];    TTY.PutChar[h, Ascii.CR];    TTY.PutString[h, "debugger page: "L];    dbgerPage ¬ TTY.GetLongNumber[h: h, default: 0, radix: 8];    TTY.PutChar[h, Ascii.CR];    TTY.PutString[h, "debuggee page: "L];    dbgeePage ¬ TTY.GetLongNumber[h: h, default: 0, radix: 8];    TTY.PutChar[h, Ascii.CR];    WriteBootLocation["Debugger"L, fcEr, dbgerPage];    WriteBootLocation["Debuggee"L, fcEe, dbgeePage];    END;  Done: PROCEDURE RETURNS [BOOLEAN] =    BEGIN    Process.Pause[Process.SecondsToTicks[1]];    RETURN[TTY.UserAbort[tty]]    END;  -- Other procedures  ReadLongNumber: PROCEDURE [default: LONG UNSPECIFIED, radix: CARDINAL]    RETURNS [LONG UNSPECIFIED] =    BEGIN    s: STRING = [20];    String.AppendLongNumber[s, default, radix];    TTY.GetID[tty, s];    RETURN[String.StringToLongNumber[s, radix]]    END;  SpecialCatch: Command.Catch --action--  =    BEGIN    ENABLE      SpecialFile.InvalidParameters =>        BEGIN Command.WriteError[h, "SpecialFile.InvalidParameters"]; CONTINUE END;    PilotCommand.StorageCatch[h, action]    END;  WriteBootLocation: PROCEDURE [    name: STRING, file: File.File, page: File.PageNumber] =    BEGIN    dT: Device.Type;    dO: CARDINAL;    diskAddress: PilotDiskFace.DiskAddress;    [dT, dO, diskAddress] ¬ KernelFile.GetBootLocation[file, page];    TTY.PutString[tty, name];    TTY.PutString[tty, ": [deviceType:"L];    TTY.PutOctal[tty, dT];    TTY.PutString[tty, ",deviceOrdinal:"L];    TTY.PutOctal[tty, dO];    PilotCommand.WriteFileIDs[tty, file];    TTY.PutString[tty, ",diskAddress:"L];    WriteLongOctal[LOOPHOLE[diskAddress]];    TTY.PutLine[tty, "]"L]    END;  WriteLongOctal: PROCEDURE [n: LONG UNSPECIFIED] =    BEGIN    s: STRING = [20];    String.AppendLongNumber[s, n, 8];    TTY.PutString[tty, s]    END;  Command.InstallTopLevel[tty, ["special", SpecialCmd]];  END.LOGTime: August 15, 1980  2:15 PM	By: SXY        Action: IODefs and Command are replaced by TTY and TTYCommand respectively.Time: August 22, 1980  12:09 PM	By: SXY   	Action: PilotFileTypes is replaced by FileTypes.Time: August 28, 1980  3:20 PM	By: SXY   	Action: PBKInputDefs is replaced by UserInput.Time: September 9, 1980  11:48 AM	By: SXY   	Action: TTYCommand is replaced by new Command.Time: September 12, 1980  11:04 AM	By: SXY   	Action: Removed UserInput and used UserAbort defined in TTY.Time:  4-Sep-81 15:35:59	By: SXY   	Action: Use OldEntry in VMMapLog instead of Entry (temporarily).Time: 24-Nov-81 16:49:02	By: CAJ 	Action: Convert from Directory to new file system, export VMMapLog.Entry concrete type, added firstPage in calls to Snapshot.InLoad and .OutLoad.Time: 20-Jan-82 14:55:57	By: CAJ 	Action: Change control-DEL references to STOP key.Time: 18-Jan-83 10:57:57	By: EKN   	Action: Update To KlamathTime:  1-Feb-83 10:27:31	By: EKN   	Action: Delete DiskBackingStore.GetDiskChannel usage Time:  8-Mar-83 10:54:27	By: EKN   	Action: deleted countBootFile variable, fixed compiler warnings on truncation. Fixed parameters to GetBackingStoreRun.Time:  8-Apr-83 16:55:02	By: EKN   	Action: Remove DiskBackingStore references.  SpecialFile.Link, .MakeBootable, .MakeUnbootable  ¬ KernelFile.Link, .MakeBootable, .MakeUnbootableTime:  2-Sep-86 15:56:54        By: RSV         Action: Changed KernelFile.MakeBootable parameters and references to KernelFile.Link.
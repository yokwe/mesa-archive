-- Copyright (C) 1988  by Xerox Corporation. All rights reserved. -- LFBeaterProcs.mesa	CAJ	 1-Jun-88 18:23:40DIRECTORY  BeaterProcs USING [BeaterListFull, countRegistered, RegisterBeaterProc, Select],  Frame USING [MyLocalFrame],  LFBeaterInternal USING [    AtLeastThisManyLeftToAlloc, Block, ProcLFn, RandomNumber],  PrincOps USING [FrameSizeIndex, frameSizeMap, localWordOffset],  RuntimeInternal USING [WorryCallDebugger];LFBeaterProcs: PROGRAM  IMPORTS BeaterProcs, Frame, LFBeaterInternal, RuntimeInternal  EXPORTS LFBeaterInternal =  BEGIN  << These procedures follow a common pattern, which is as follows.  Fill local frame with an identifiable value.  (Not all of the locals are available for this test value since some are used by the proc.)  If the depth parameter passed in has reached 0, start the return; otherwise, choose the next procedure.  Check that allocating the new proc's frame will be safe.  If not, start the return.  Otherwise go on to the new procedure with the depth decremented by one.  On the way back, via return or signal unwind, verify the local values and go to the debugger with a no-frame-alloc WorryCall if they don't still match.  >>  procLFnOverhead: CARDINAL =  -- locals needed just for template ProcLFn function    PrincOps.localWordOffset   -- frame overhead    + SIZE[LONG POINTER]       -- calling parameters    + SIZE[CARDINAL] + SIZE[UNSPECIFIED]  -- locals    + SIZE[LFBeaterInternal.ProcLFn];  Unwinder: PUBLIC SIGNAL = CODE;  -- ???? what's wrong with this????--  mainProblem: STRING = "LFBeater: locals problem in main";--  unwindProblem: STRING = "LFBeater: locals problem in unwind";  procsByFsi: ARRAY PrincOps.FrameSizeIndex OF LFBeaterInternal.ProcLFn =    [ProcLF0, ProcLF1, ProcLF2, ProcLF3, ProcLF4, ProcLF5, ProcLF6, ProcLF7,     ProcLF8, ProcLF9, ProcLF10, ProcLF11, ProcLF12, ProcLF13, ProcLF14,     ProcLF15, ProcLF16, ProcLF17, ProcLF18, ProcLF19, ProcLF20, ProcLF21,     ProcLF22, ProcLF23, ProcLF24, ProcLF25, ProcLF26, ProcLF27, ProcLF28,     ProcLF29, ProcLF30];  ProcLF0: LFBeaterInternal.ProcLFn =    -- [pDepth: LONG POINTER TO LFBeaterInternal.Depth]    -- Procedure requiring a local frame of fsi = 0.    -- size = 8, <= 4 words of locals    BEGIN ENABLE UNWIND => NULL;    IF pDepth­ = 0 THEN RETURN;    ProcLF0Helper[pDepth­ - 1];    END;  -- ProcLF0  ProcLF0Helper: PROCEDURE [nextDepth: CARDINAL] =    -- This guy exists because we can't do all the necessary processing    -- in an fsi=0 size frame.    BEGIN    nextProc: LFBeaterInternal.ProcLFn ¬ BeaterProcs.Select[      LFBeaterInternal.RandomNumber[BeaterProcs.countRegistered]];    IF HintNextFrameSafe[nextProc] THEN nextProc[@nextDepth];    END;  ProcLF1: LFBeaterInternal.ProcLFn =    -- [pDepth: LONG POINTER TO CallData]    --   where CallData = TYPE = RECORD[depth: CARDINAL, myRandom: CARDINAL]    -- Procedure requiring a local frame of fsi = 1.    -- size = 12, <= 8 words of locals    BEGIN    plainLocals: CARDINAL = PrincOps.frameSizeMap[1] - procLFnOverhead;    ourLF: UNSPECIFIED ¬ Frame.MyLocalFrame[];    locals: ARRAY[0..plainLocals) OF UNSPECIFIED;    BEGIN ENABLE UNWIND =>      {FOR i: CARDINAL IN [0..plainLocals) DO        IF locals[i] ~= ourLF THEN	  RuntimeInternal.WorryCallDebugger["LFBeater-unwind?"G];	ENDLOOP};    -- These internal BEGIN/END groups make local scopes to minimize local usage.    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO locals[i] ¬ ourLF ENDLOOP;    END;    LFBeaterInternal.Block[];    IF pDepth­ > 0 THEN      BEGIN      nextDepth: CARDINAL ¬ pDepth­ - 1;      nextProc: LFBeaterInternal.ProcLFn ¬ BeaterProcs.Select[        LFBeaterInternal.RandomNumber[BeaterProcs.countRegistered]];      IF HintNextFrameSafe[nextProc] THEN nextProc[@nextDepth];      END;    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO      IF locals[i] ~= ourLF THEN        RuntimeInternal.WorryCallDebugger["LFBeater-main?"G];      ENDLOOP;    END;    END;  -- scope of UNWIND    END;  -- ProcLF1  ProcLF2: LFBeaterInternal.ProcLFn =    -- [pDepth: LONG POINTER TO CallData]    --   where CallData = TYPE = RECORD[depth: CARDINAL, myRandom: CARDINAL]    -- Procedure requiring a local frame of fsi = 2.    -- size = 16, <= 12 words of locals    BEGIN    plainLocals: CARDINAL = PrincOps.frameSizeMap[2] - procLFnOverhead;    ourLF: UNSPECIFIED ¬ Frame.MyLocalFrame[];    locals: ARRAY[0..plainLocals) OF UNSPECIFIED;  -- put plain space first    BEGIN ENABLE UNWIND =>      {FOR i: CARDINAL IN [0..plainLocals) DO        IF locals[i] ~= ourLF THEN	  RuntimeInternal.WorryCallDebugger["LFBeater-unwind?"G];	ENDLOOP};    -- These internal BEGIN/END groups make local scopes to minimize local usage.    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO locals[i] ¬ ourLF ENDLOOP;    END;    LFBeaterInternal.Block[];    IF pDepth­ = 0 THEN RETURN;    BEGIN    nextDepth: CARDINAL ¬ pDepth­ - 1;    nextProc: LFBeaterInternal.ProcLFn ¬ BeaterProcs.Select[      LFBeaterInternal.RandomNumber[BeaterProcs.countRegistered]];    IF ~HintNextFrameSafe[nextProc] THEN RETURN;    nextProc[@nextDepth];    END;    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO      IF locals[i] ~= ourLF THEN        RuntimeInternal.WorryCallDebugger["LFBeater-main?"G];      ENDLOOP;    END;    END;  -- scope of UNWIND    END;  -- ProcLF2  ProcLF3: LFBeaterInternal.ProcLFn =    -- [pDepth: LONG POINTER TO CallData]    --   where CallData = TYPE = RECORD[depth: CARDINAL, myRandom: CARDINAL]    -- Procedure requiring a local frame of fsi = 3.    -- size = 20, <= 16 words of locals    BEGIN    plainLocals: CARDINAL = PrincOps.frameSizeMap[3] - procLFnOverhead;    ourLF: UNSPECIFIED ¬ Frame.MyLocalFrame[];    locals: ARRAY[0..plainLocals) OF UNSPECIFIED;  -- put plain space first    BEGIN ENABLE UNWIND =>      {FOR i: CARDINAL IN [0..plainLocals) DO        IF locals[i] ~= ourLF THEN	  RuntimeInternal.WorryCallDebugger["LFBeater-unwind?"G];	ENDLOOP};    -- These internal BEGIN/END groups make local scopes to minimize local usage.    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO locals[i] ¬ ourLF ENDLOOP;    END;    LFBeaterInternal.Block[];    IF pDepth­ = 0 THEN RETURN;    BEGIN    nextDepth: CARDINAL ¬ pDepth­ - 1;    nextProc: LFBeaterInternal.ProcLFn ¬ BeaterProcs.Select[      LFBeaterInternal.RandomNumber[BeaterProcs.countRegistered]];    IF ~HintNextFrameSafe[nextProc] THEN RETURN;    nextProc[@nextDepth];    END;    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO      IF locals[i] ~= ourLF THEN        RuntimeInternal.WorryCallDebugger["LFBeater-main?"G];      ENDLOOP;    END;    END;  -- scope of UNWIND    END;  -- ProcLF3  ProcLF4: LFBeaterInternal.ProcLFn =    -- [pDepth: LONG POINTER TO CallData]    --   where CallData = TYPE = RECORD[depth: CARDINAL, myRandom: CARDINAL]    -- Procedure requiring a local frame of fsi = 4.    -- size = 24, <= 20 words of locals    BEGIN    plainLocals: CARDINAL = PrincOps.frameSizeMap[4] - procLFnOverhead;    ourLF: UNSPECIFIED ¬ Frame.MyLocalFrame[];    locals: ARRAY[0..plainLocals) OF UNSPECIFIED;  -- put plain space first    BEGIN ENABLE UNWIND =>      {FOR i: CARDINAL IN [0..plainLocals) DO        IF locals[i] ~= ourLF THEN	  RuntimeInternal.WorryCallDebugger["LFBeater-unwind?"G];	ENDLOOP};    -- These internal BEGIN/END groups make local scopes to minimize local usage.    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO locals[i] ¬ ourLF ENDLOOP;    END;    LFBeaterInternal.Block[];    IF pDepth­ = 0 THEN RETURN;    BEGIN    nextDepth: CARDINAL ¬ pDepth­ - 1;    nextProc: LFBeaterInternal.ProcLFn ¬ BeaterProcs.Select[      LFBeaterInternal.RandomNumber[BeaterProcs.countRegistered]];    IF ~HintNextFrameSafe[nextProc] THEN RETURN;    nextProc[@nextDepth];    END;    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO      IF locals[i] ~= ourLF THEN        RuntimeInternal.WorryCallDebugger["LFBeater-main?"G];      ENDLOOP;    END;    END;  -- scope of UNWIND    END;  -- ProcLF4  ProcLF5: LFBeaterInternal.ProcLFn =    -- [pDepth: LONG POINTER TO CallData]    --   where CallData = TYPE = RECORD[depth: CARDINAL, myRandom: CARDINAL]    -- Procedure requiring a local frame of fsi = 5.    -- size = 28, <= 24 words of locals    BEGIN    plainLocals: CARDINAL = PrincOps.frameSizeMap[5] - procLFnOverhead;    ourLF: UNSPECIFIED ¬ Frame.MyLocalFrame[];    locals: ARRAY[0..plainLocals) OF UNSPECIFIED;  -- put plain space first    BEGIN ENABLE UNWIND =>      {FOR i: CARDINAL IN [0..plainLocals) DO        IF locals[i] ~= ourLF THEN	  RuntimeInternal.WorryCallDebugger["LFBeater-unwind?"G];	ENDLOOP};    -- These internal BEGIN/END groups make local scopes to minimize local usage.    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO locals[i] ¬ ourLF ENDLOOP;    END;    LFBeaterInternal.Block[];    IF pDepth­ = 0 THEN RETURN;    BEGIN    nextDepth: CARDINAL ¬ pDepth­ - 1;    nextProc: LFBeaterInternal.ProcLFn ¬ BeaterProcs.Select[      LFBeaterInternal.RandomNumber[BeaterProcs.countRegistered]];    IF ~HintNextFrameSafe[nextProc] THEN RETURN;    nextProc[@nextDepth];    END;    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO      IF locals[i] ~= ourLF THEN        RuntimeInternal.WorryCallDebugger["LFBeater-main?"G];      ENDLOOP;    END;    END;  -- scope of UNWIND    END;  -- ProcLF5  ProcLF6: LFBeaterInternal.ProcLFn =    -- [pDepth: LONG POINTER TO CallData]    --   where CallData = TYPE = RECORD[depth: CARDINAL, myRandom: CARDINAL]    -- Procedure requiring a local frame of fsi = 6.    -- size = 32, <= 28 words of locals    BEGIN    plainLocals: CARDINAL = PrincOps.frameSizeMap[6] - procLFnOverhead;    ourLF: UNSPECIFIED ¬ Frame.MyLocalFrame[];    locals: ARRAY[0..plainLocals) OF UNSPECIFIED;  -- put plain space first    BEGIN ENABLE UNWIND =>      {FOR i: CARDINAL IN [0..plainLocals) DO        IF locals[i] ~= ourLF THEN	  RuntimeInternal.WorryCallDebugger["LFBeater-unwind?"G];	ENDLOOP};    -- These internal BEGIN/END groups make local scopes to minimize local usage.    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO locals[i] ¬ ourLF ENDLOOP;    END;    LFBeaterInternal.Block[];    IF pDepth­ = 0 THEN RETURN;    BEGIN    nextDepth: CARDINAL ¬ pDepth­ - 1;    nextProc: LFBeaterInternal.ProcLFn ¬ BeaterProcs.Select[      LFBeaterInternal.RandomNumber[BeaterProcs.countRegistered]];    IF ~HintNextFrameSafe[nextProc] THEN RETURN;    nextProc[@nextDepth];    END;    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO      IF locals[i] ~= ourLF THEN        RuntimeInternal.WorryCallDebugger["LFBeater-main?"G];      ENDLOOP;    END;    END;  -- scope of UNWIND    END;  -- ProcLF6  ProcLF7: LFBeaterInternal.ProcLFn =    -- [pDepth: LONG POINTER TO CallData]    --   where CallData = TYPE = RECORD[depth: CARDINAL, myRandom: CARDINAL]    -- Procedure requiring a local frame of fsi = 7.    -- size = 40, <= 36 words of locals    BEGIN    plainLocals: CARDINAL = PrincOps.frameSizeMap[7] - procLFnOverhead;    ourLF: UNSPECIFIED ¬ Frame.MyLocalFrame[];    locals: ARRAY[0..plainLocals) OF UNSPECIFIED;  -- put plain space first    BEGIN ENABLE UNWIND =>      {FOR i: CARDINAL IN [0..plainLocals) DO        IF locals[i] ~= ourLF THEN	  RuntimeInternal.WorryCallDebugger["LFBeater-unwind?"G];	ENDLOOP};    -- These internal BEGIN/END groups make local scopes to minimize local usage.    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO locals[i] ¬ ourLF ENDLOOP;    END;    LFBeaterInternal.Block[];    IF pDepth­ = 0 THEN RETURN;    BEGIN    nextDepth: CARDINAL ¬ pDepth­ - 1;    nextProc: LFBeaterInternal.ProcLFn ¬ BeaterProcs.Select[      LFBeaterInternal.RandomNumber[BeaterProcs.countRegistered]];    IF ~HintNextFrameSafe[nextProc] THEN RETURN;    nextProc[@nextDepth];    END;    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO      IF locals[i] ~= ourLF THEN        RuntimeInternal.WorryCallDebugger["LFBeater-main?"G];      ENDLOOP;    END;    END;  -- scope of UNWIND    END;  -- ProcLF7  ProcLF8: LFBeaterInternal.ProcLFn =    -- [pDepth: LONG POINTER TO CallData]    --   where CallData = TYPE = RECORD[depth: CARDINAL, myRandom: CARDINAL]    -- Procedure requiring a local frame of fsi = 8.    -- size = 48, <= 44 words of locals    BEGIN    plainLocals: CARDINAL = PrincOps.frameSizeMap[8] - procLFnOverhead;    ourLF: UNSPECIFIED ¬ Frame.MyLocalFrame[];    locals: ARRAY[0..plainLocals) OF UNSPECIFIED;  -- put plain space first    BEGIN ENABLE UNWIND =>      {FOR i: CARDINAL IN [0..plainLocals) DO        IF locals[i] ~= ourLF THEN	  RuntimeInternal.WorryCallDebugger["LFBeater-unwind?"G];	ENDLOOP};    -- These internal BEGIN/END groups make local scopes to minimize local usage.    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO locals[i] ¬ ourLF ENDLOOP;    END;    LFBeaterInternal.Block[];    IF pDepth­ = 0 THEN RETURN;    BEGIN    nextDepth: CARDINAL ¬ pDepth­ - 1;    nextProc: LFBeaterInternal.ProcLFn ¬ BeaterProcs.Select[      LFBeaterInternal.RandomNumber[BeaterProcs.countRegistered]];    IF ~HintNextFrameSafe[nextProc] THEN RETURN;    nextProc[@nextDepth];    END;    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO      IF locals[i] ~= ourLF THEN        RuntimeInternal.WorryCallDebugger["LFBeater-main?"G];      ENDLOOP;    END;    END;  -- scope of UNWIND    END;  -- ProcLF8  ProcLF9: LFBeaterInternal.ProcLFn =    -- [pDepth: LONG POINTER TO CallData]    --   where CallData = TYPE = RECORD[depth: CARDINAL, myRandom: CARDINAL]    -- Procedure requiring a local frame of fsi = 9.    -- size = 56, <= 52 words of locals    BEGIN    plainLocals: CARDINAL = PrincOps.frameSizeMap[9] - procLFnOverhead;    ourLF: UNSPECIFIED ¬ Frame.MyLocalFrame[];    locals: ARRAY[0..plainLocals) OF UNSPECIFIED;  -- put plain space first    BEGIN ENABLE UNWIND =>      {FOR i: CARDINAL IN [0..plainLocals) DO        IF locals[i] ~= ourLF THEN	  RuntimeInternal.WorryCallDebugger["LFBeater-unwind?"G];	ENDLOOP};    -- These internal BEGIN/END groups make local scopes to minimize local usage.    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO locals[i] ¬ ourLF ENDLOOP;    END;    LFBeaterInternal.Block[];    IF pDepth­ = 0 THEN RETURN;    BEGIN    nextDepth: CARDINAL ¬ pDepth­ - 1;    nextProc: LFBeaterInternal.ProcLFn ¬ BeaterProcs.Select[      LFBeaterInternal.RandomNumber[BeaterProcs.countRegistered]];    IF ~HintNextFrameSafe[nextProc] THEN RETURN;    nextProc[@nextDepth];    END;    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO      IF locals[i] ~= ourLF THEN        RuntimeInternal.WorryCallDebugger["LFBeater-main?"G];      ENDLOOP;    END;    END;  -- scope of UNWIND    END;  -- ProcLF9  ProcLF10: LFBeaterInternal.ProcLFn =    -- [pDepth: LONG POINTER TO CallData]    --   where CallData = TYPE = RECORD[depth: CARDINAL, myRandom: CARDINAL]    -- Procedure requiring a local frame of fsi = 10.    -- size = 68, <= 64 words of locals    BEGIN    plainLocals: CARDINAL = PrincOps.frameSizeMap[10] - procLFnOverhead;    ourLF: UNSPECIFIED ¬ Frame.MyLocalFrame[];    locals: ARRAY[0..plainLocals) OF UNSPECIFIED;  -- put plain space first    BEGIN ENABLE UNWIND =>      {FOR i: CARDINAL IN [0..plainLocals) DO        IF locals[i] ~= ourLF THEN	  RuntimeInternal.WorryCallDebugger["LFBeater-unwind?"G];	ENDLOOP};    -- These internal BEGIN/END groups make local scopes to minimize local usage.    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO locals[i] ¬ ourLF ENDLOOP;    END;    LFBeaterInternal.Block[];    IF pDepth­ = 0 THEN RETURN;    BEGIN    nextDepth: CARDINAL ¬ pDepth­ - 1;    nextProc: LFBeaterInternal.ProcLFn ¬ BeaterProcs.Select[      LFBeaterInternal.RandomNumber[BeaterProcs.countRegistered]];    IF ~HintNextFrameSafe[nextProc] THEN RETURN;    nextProc[@nextDepth];    END;    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO      IF locals[i] ~= ourLF THEN        RuntimeInternal.WorryCallDebugger["LFBeater-main?"G];      ENDLOOP;    END;    END;  -- scope of UNWIND    END;  -- ProcLF10  ProcLF11: LFBeaterInternal.ProcLFn =    -- [pDepth: LONG POINTER TO CallData]    --   where CallData = TYPE = RECORD[depth: CARDINAL, myRandom: CARDINAL]    -- Procedure requiring a local frame of fsi = 11.    -- size = 80, <= 76 words of locals    BEGIN    plainLocals: CARDINAL = PrincOps.frameSizeMap[11] - procLFnOverhead;    ourLF: UNSPECIFIED ¬ Frame.MyLocalFrame[];    locals: ARRAY[0..plainLocals) OF UNSPECIFIED;  -- put plain space first    BEGIN ENABLE UNWIND =>      {FOR i: CARDINAL IN [0..plainLocals) DO        IF locals[i] ~= ourLF THEN	  RuntimeInternal.WorryCallDebugger["LFBeater-unwind?"G];	ENDLOOP};    -- These internal BEGIN/END groups make local scopes to minimize local usage.    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO locals[i] ¬ ourLF ENDLOOP;    END;    LFBeaterInternal.Block[];    IF pDepth­ = 0 THEN RETURN;    BEGIN    nextDepth: CARDINAL ¬ pDepth­ - 1;    nextProc: LFBeaterInternal.ProcLFn ¬ BeaterProcs.Select[      LFBeaterInternal.RandomNumber[BeaterProcs.countRegistered]];    IF ~HintNextFrameSafe[nextProc] THEN RETURN;    nextProc[@nextDepth];    END;    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO      IF locals[i] ~= ourLF THEN        RuntimeInternal.WorryCallDebugger["LFBeater-main?"G];      ENDLOOP;    END;    END;  -- scope of UNWIND    END;  -- ProcLF11  ProcLF12: LFBeaterInternal.ProcLFn =    -- [pDepth: LONG POINTER TO CallData]    --   where CallData = TYPE = RECORD[depth: CARDINAL, myRandom: CARDINAL]    -- Procedure requiring a local frame of fsi = 12.    -- size = 96, <= 92 words of locals    BEGIN    plainLocals: CARDINAL = PrincOps.frameSizeMap[12] - procLFnOverhead;    ourLF: UNSPECIFIED ¬ Frame.MyLocalFrame[];    locals: ARRAY[0..plainLocals) OF UNSPECIFIED;  -- put plain space first    BEGIN ENABLE UNWIND =>      {FOR i: CARDINAL IN [0..plainLocals) DO        IF locals[i] ~= ourLF THEN	  RuntimeInternal.WorryCallDebugger["LFBeater-unwind?"G];	ENDLOOP};    -- These internal BEGIN/END groups make local scopes to minimize local usage.    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO locals[i] ¬ ourLF ENDLOOP;    END;    LFBeaterInternal.Block[];    IF pDepth­ = 0 THEN RETURN;    BEGIN    nextDepth: CARDINAL ¬ pDepth­ - 1;    nextProc: LFBeaterInternal.ProcLFn ¬ BeaterProcs.Select[      LFBeaterInternal.RandomNumber[BeaterProcs.countRegistered]];    IF ~HintNextFrameSafe[nextProc] THEN RETURN;    nextProc[@nextDepth];    END;    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO      IF locals[i] ~= ourLF THEN        RuntimeInternal.WorryCallDebugger["LFBeater-main?"G];      ENDLOOP;    END;    END;  -- scope of UNWIND    END;  -- ProcLF12  ProcLF13: LFBeaterInternal.ProcLFn =    -- [pDepth: LONG POINTER TO CallData]    --   where CallData = TYPE = RECORD[depth: CARDINAL, myRandom: CARDINAL]    -- Procedure requiring a local frame of fsi = 13.    -- size = 112, <= 108 words of locals    BEGIN    plainLocals: CARDINAL = PrincOps.frameSizeMap[13] - procLFnOverhead;    ourLF: UNSPECIFIED ¬ Frame.MyLocalFrame[];    locals: ARRAY[0..plainLocals) OF UNSPECIFIED;  -- put plain space first    BEGIN ENABLE UNWIND =>      {FOR i: CARDINAL IN [0..plainLocals) DO        IF locals[i] ~= ourLF THEN	  RuntimeInternal.WorryCallDebugger["LFBeater-unwind?"G];	ENDLOOP};    -- These internal BEGIN/END groups make local scopes to minimize local usage.    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO locals[i] ¬ ourLF ENDLOOP;    END;    LFBeaterInternal.Block[];    IF pDepth­ = 0 THEN RETURN;    BEGIN    nextDepth: CARDINAL ¬ pDepth­ - 1;    nextProc: LFBeaterInternal.ProcLFn ¬ BeaterProcs.Select[      LFBeaterInternal.RandomNumber[BeaterProcs.countRegistered]];    IF ~HintNextFrameSafe[nextProc] THEN RETURN;    nextProc[@nextDepth];    END;    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO      IF locals[i] ~= ourLF THEN        RuntimeInternal.WorryCallDebugger["LFBeater-main?"G];      ENDLOOP;    END;    END;  -- scope of UNWIND    END;  -- ProcLF13  ProcLF14: LFBeaterInternal.ProcLFn =    -- [pDepth: LONG POINTER TO CallData]    --   where CallData = TYPE = RECORD[depth: CARDINAL, myRandom: CARDINAL]    -- Procedure requiring a local frame of fsi = 14.    -- size = 128, <= 124 words of locals    BEGIN    plainLocals: CARDINAL = PrincOps.frameSizeMap[14] - procLFnOverhead;    ourLF: UNSPECIFIED ¬ Frame.MyLocalFrame[];    locals: ARRAY[0..plainLocals) OF UNSPECIFIED;  -- put plain space first    BEGIN ENABLE UNWIND =>      {FOR i: CARDINAL IN [0..plainLocals) DO        IF locals[i] ~= ourLF THEN	  RuntimeInternal.WorryCallDebugger["LFBeater-unwind?"G];	ENDLOOP};    -- These internal BEGIN/END groups make local scopes to minimize local usage.    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO locals[i] ¬ ourLF ENDLOOP;    END;    LFBeaterInternal.Block[];    IF pDepth­ = 0 THEN RETURN;    BEGIN    nextDepth: CARDINAL ¬ pDepth­ - 1;    nextProc: LFBeaterInternal.ProcLFn ¬ BeaterProcs.Select[      LFBeaterInternal.RandomNumber[BeaterProcs.countRegistered]];    IF ~HintNextFrameSafe[nextProc] THEN RETURN;    nextProc[@nextDepth];    END;    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO      IF locals[i] ~= ourLF THEN        RuntimeInternal.WorryCallDebugger["LFBeater-main?"G];      ENDLOOP;    END;    END;  -- scope of UNWIND    END;  -- ProcLF14  ProcLF15: LFBeaterInternal.ProcLFn =    -- [pDepth: LONG POINTER TO CallData]    --   where CallData = TYPE = RECORD[depth: CARDINAL, myRandom: CARDINAL]    -- Procedure requiring a local frame of fsi = 15.    -- size = 148, <= 144 words of locals    BEGIN    plainLocals: CARDINAL = PrincOps.frameSizeMap[15] - procLFnOverhead;    ourLF: UNSPECIFIED ¬ Frame.MyLocalFrame[];    locals: ARRAY[0..plainLocals) OF UNSPECIFIED;  -- put plain space first    BEGIN ENABLE UNWIND =>      {FOR i: CARDINAL IN [0..plainLocals) DO        IF locals[i] ~= ourLF THEN	  RuntimeInternal.WorryCallDebugger["LFBeater-unwind?"G];	ENDLOOP};    -- These internal BEGIN/END groups make local scopes to minimize local usage.    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO locals[i] ¬ ourLF ENDLOOP;    END;    LFBeaterInternal.Block[];    IF pDepth­ = 0 THEN RETURN;    BEGIN    nextDepth: CARDINAL ¬ pDepth­ - 1;    nextProc: LFBeaterInternal.ProcLFn ¬ BeaterProcs.Select[      LFBeaterInternal.RandomNumber[BeaterProcs.countRegistered]];    IF ~HintNextFrameSafe[nextProc] THEN RETURN;    nextProc[@nextDepth];    END;    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO      IF locals[i] ~= ourLF THEN        RuntimeInternal.WorryCallDebugger["LFBeater-main?"G];      ENDLOOP;    END;    END;  -- scope of UNWIND    END;  -- ProcLF15  ProcLF16: LFBeaterInternal.ProcLFn =    -- [pDepth: LONG POINTER TO CallData]    --   where CallData = TYPE = RECORD[depth: CARDINAL, myRandom: CARDINAL]    -- Procedure requiring a local frame of fsi = 16.    -- size = 168, <= 164 words of locals    BEGIN    plainLocals: CARDINAL = PrincOps.frameSizeMap[16] - procLFnOverhead;    ourLF: UNSPECIFIED ¬ Frame.MyLocalFrame[];    locals: ARRAY[0..plainLocals) OF UNSPECIFIED;  -- put plain space first    BEGIN ENABLE UNWIND =>      {FOR i: CARDINAL IN [0..plainLocals) DO        IF locals[i] ~= ourLF THEN	  RuntimeInternal.WorryCallDebugger["LFBeater-unwind?"G];	ENDLOOP};    -- These internal BEGIN/END groups make local scopes to minimize local usage.    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO locals[i] ¬ ourLF ENDLOOP;    END;    LFBeaterInternal.Block[];    IF pDepth­ = 0 THEN RETURN;    BEGIN    nextDepth: CARDINAL ¬ pDepth­ - 1;    nextProc: LFBeaterInternal.ProcLFn ¬ BeaterProcs.Select[      LFBeaterInternal.RandomNumber[BeaterProcs.countRegistered]];    IF ~HintNextFrameSafe[nextProc] THEN RETURN;    nextProc[@nextDepth];    END;    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO      IF locals[i] ~= ourLF THEN        RuntimeInternal.WorryCallDebugger["LFBeater-main?"G];      ENDLOOP;    END;    END;  -- scope of UNWIND    END;  -- ProcLF16  ProcLF17: LFBeaterInternal.ProcLFn =    -- [pDepth: LONG POINTER TO CallData]    --   where CallData = TYPE = RECORD[depth: CARDINAL, myRandom: CARDINAL]    -- Procedure requiring a local frame of fsi = 17.    -- size = 192, <= 188 words of locals    BEGIN    plainLocals: CARDINAL = PrincOps.frameSizeMap[17] - procLFnOverhead;    ourLF: UNSPECIFIED ¬ Frame.MyLocalFrame[];    locals: ARRAY[0..plainLocals) OF UNSPECIFIED;  -- put plain space first    BEGIN ENABLE UNWIND =>      {FOR i: CARDINAL IN [0..plainLocals) DO        IF locals[i] ~= ourLF THEN	  RuntimeInternal.WorryCallDebugger["LFBeater-unwind?"G];	ENDLOOP};    -- These internal BEGIN/END groups make local scopes to minimize local usage.    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO locals[i] ¬ ourLF ENDLOOP;    END;    LFBeaterInternal.Block[];    IF pDepth­ = 0 THEN RETURN;    BEGIN    nextDepth: CARDINAL ¬ pDepth­ - 1;    nextProc: LFBeaterInternal.ProcLFn ¬ BeaterProcs.Select[      LFBeaterInternal.RandomNumber[BeaterProcs.countRegistered]];    IF ~HintNextFrameSafe[nextProc] THEN RETURN;    nextProc[@nextDepth];    END;    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO      IF locals[i] ~= ourLF THEN        RuntimeInternal.WorryCallDebugger["LFBeater-main?"G];      ENDLOOP;    END;    END;  -- scope of UNWIND    END;  -- ProcLF17  ProcLF18: LFBeaterInternal.ProcLFn =    -- [pDepth: LONG POINTER TO CallData]    --   where CallData = TYPE = RECORD[depth: CARDINAL, myRandom: CARDINAL]    -- Procedure requiring a local frame of fsi = 18.    -- size = 224, <= 220 words of locals    BEGIN    plainLocals: CARDINAL = PrincOps.frameSizeMap[18] - procLFnOverhead;    ourLF: UNSPECIFIED ¬ Frame.MyLocalFrame[];    locals: ARRAY[0..plainLocals) OF UNSPECIFIED;  -- put plain space first    BEGIN ENABLE UNWIND =>      {FOR i: CARDINAL IN [0..plainLocals) DO        IF locals[i] ~= ourLF THEN	  RuntimeInternal.WorryCallDebugger["LFBeater-unwind?"G];	ENDLOOP};    -- These internal BEGIN/END groups make local scopes to minimize local usage.    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO locals[i] ¬ ourLF ENDLOOP;    END;    LFBeaterInternal.Block[];    IF pDepth­ = 0 THEN RETURN;    BEGIN    nextDepth: CARDINAL ¬ pDepth­ - 1;    nextProc: LFBeaterInternal.ProcLFn ¬ BeaterProcs.Select[      LFBeaterInternal.RandomNumber[BeaterProcs.countRegistered]];    IF ~HintNextFrameSafe[nextProc] THEN RETURN;    nextProc[@nextDepth];    END;    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO      IF locals[i] ~= ourLF THEN        RuntimeInternal.WorryCallDebugger["LFBeater-main?"G];      ENDLOOP;    END;    END;  -- scope of UNWIND    END;  -- ProcLF18  ProcLF19: LFBeaterInternal.ProcLFn =    -- [pDepth: LONG POINTER TO CallData]    --   where CallData = TYPE = RECORD[depth: CARDINAL, myRandom: CARDINAL]    -- Procedure requiring a local frame of fsi = 19.    -- size = 252, <= 248 words of locals    BEGIN    plainLocals: CARDINAL = PrincOps.frameSizeMap[19] - procLFnOverhead;    ourLF: UNSPECIFIED ¬ Frame.MyLocalFrame[];    locals: ARRAY[0..plainLocals) OF UNSPECIFIED;  -- put plain space first    BEGIN ENABLE UNWIND =>      {FOR i: CARDINAL IN [0..plainLocals) DO        IF locals[i] ~= ourLF THEN	  RuntimeInternal.WorryCallDebugger["LFBeater-unwind?"G];	ENDLOOP};    -- These internal BEGIN/END groups make local scopes to minimize local usage.    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO locals[i] ¬ ourLF ENDLOOP;    END;    LFBeaterInternal.Block[];    IF pDepth­ = 0 THEN RETURN;    BEGIN    nextDepth: CARDINAL ¬ pDepth­ - 1;    nextProc: LFBeaterInternal.ProcLFn ¬ BeaterProcs.Select[      LFBeaterInternal.RandomNumber[BeaterProcs.countRegistered]];    IF ~HintNextFrameSafe[nextProc] THEN RETURN;    nextProc[@nextDepth];    END;    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO      IF locals[i] ~= ourLF THEN        RuntimeInternal.WorryCallDebugger["LFBeater-main?"G];      ENDLOOP;    END;    END;  -- scope of UNWIND    END;  -- ProcLF19  ProcLF20: LFBeaterInternal.ProcLFn =    -- [pDepth: LONG POINTER TO CallData]    --   where CallData = TYPE = RECORD[depth: CARDINAL, myRandom: CARDINAL]    -- Procedure requiring a local frame of fsi = 20.    -- size = 508, <= 504 words of locals    BEGIN    plainLocals: CARDINAL = PrincOps.frameSizeMap[20] - procLFnOverhead;    ourLF: UNSPECIFIED ¬ Frame.MyLocalFrame[];    locals: ARRAY[0..plainLocals) OF UNSPECIFIED;  -- put plain space first    BEGIN ENABLE UNWIND =>      {FOR i: CARDINAL IN [0..plainLocals) DO        IF locals[i] ~= ourLF THEN	  RuntimeInternal.WorryCallDebugger["LFBeater-unwind?"G];	ENDLOOP};    -- These internal BEGIN/END groups make local scopes to minimize local usage.    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO locals[i] ¬ ourLF ENDLOOP;    END;    LFBeaterInternal.Block[];    IF pDepth­ = 0 THEN RETURN;    BEGIN    nextDepth: CARDINAL ¬ pDepth­ - 1;    nextProc: LFBeaterInternal.ProcLFn ¬ BeaterProcs.Select[      LFBeaterInternal.RandomNumber[BeaterProcs.countRegistered]];    IF ~HintNextFrameSafe[nextProc] THEN RETURN;    nextProc[@nextDepth];    END;    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO      IF locals[i] ~= ourLF THEN        RuntimeInternal.WorryCallDebugger["LFBeater-main?"G];      ENDLOOP;    END;    END;  -- scope of UNWIND    END;  -- ProcLF20  ProcLF21: LFBeaterInternal.ProcLFn =    -- [pDepth: LONG POINTER TO CallData]    --   where CallData = TYPE = RECORD[depth: CARDINAL, myRandom: CARDINAL]    -- Procedure requiring a local frame of fsi = 21.    -- size = 764, <= 760 words of locals    BEGIN    plainLocals: CARDINAL = PrincOps.frameSizeMap[21] - procLFnOverhead;    ourLF: UNSPECIFIED ¬ Frame.MyLocalFrame[];    locals: ARRAY[0..plainLocals) OF UNSPECIFIED;  -- put plain space first    BEGIN ENABLE UNWIND =>      {FOR i: CARDINAL IN [0..plainLocals) DO        IF locals[i] ~= ourLF THEN	  RuntimeInternal.WorryCallDebugger["LFBeater-unwind?"G];	ENDLOOP};    -- These internal BEGIN/END groups make local scopes to minimize local usage.    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO locals[i] ¬ ourLF ENDLOOP;    END;    LFBeaterInternal.Block[];    IF pDepth­ = 0 THEN RETURN;    BEGIN    nextDepth: CARDINAL ¬ pDepth­ - 1;    nextProc: LFBeaterInternal.ProcLFn ¬ BeaterProcs.Select[      LFBeaterInternal.RandomNumber[BeaterProcs.countRegistered]];    IF ~HintNextFrameSafe[nextProc] THEN RETURN;    nextProc[@nextDepth];    END;    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO      IF locals[i] ~= ourLF THEN        RuntimeInternal.WorryCallDebugger["LFBeater-main?"G];      ENDLOOP;    END;    END;  -- scope of UNWIND    END;  -- ProcLF21  ProcLF22: LFBeaterInternal.ProcLFn =    -- [pDepth: LONG POINTER TO CallData]    --   where CallData = TYPE = RECORD[depth: CARDINAL, myRandom: CARDINAL]    -- Procedure requiring a local frame of fsi = 22.    -- size = 1020, <= 1016 words of locals    BEGIN    plainLocals: CARDINAL = PrincOps.frameSizeMap[22] - procLFnOverhead;    ourLF: UNSPECIFIED ¬ Frame.MyLocalFrame[];    locals: ARRAY[0..plainLocals) OF UNSPECIFIED;  -- put plain space first    BEGIN ENABLE UNWIND =>      {FOR i: CARDINAL IN [0..plainLocals) DO        IF locals[i] ~= ourLF THEN	  RuntimeInternal.WorryCallDebugger["LFBeater-unwind?"G];	ENDLOOP};    -- These internal BEGIN/END groups make local scopes to minimize local usage.    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO locals[i] ¬ ourLF ENDLOOP;    END;    LFBeaterInternal.Block[];    IF pDepth­ = 0 THEN RETURN;    BEGIN    nextDepth: CARDINAL ¬ pDepth­ - 1;    nextProc: LFBeaterInternal.ProcLFn ¬ BeaterProcs.Select[      LFBeaterInternal.RandomNumber[BeaterProcs.countRegistered]];    IF ~HintNextFrameSafe[nextProc] THEN RETURN;    nextProc[@nextDepth];    END;    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO      IF locals[i] ~= ourLF THEN        RuntimeInternal.WorryCallDebugger["LFBeater-main?"G];      ENDLOOP;    END;    END;  -- scope of UNWIND    END;  -- ProcLF22  ProcLF23: LFBeaterInternal.ProcLFn =    -- [pDepth: LONG POINTER TO CallData]    --   where CallData = TYPE = RECORD[depth: CARDINAL, myRandom: CARDINAL]    -- Procedure requiring a local frame of fsi = 23.    -- size = 1276, <= 1272 words of locals    BEGIN    plainLocals: CARDINAL = PrincOps.frameSizeMap[23] - procLFnOverhead;    ourLF: UNSPECIFIED ¬ Frame.MyLocalFrame[];    locals: ARRAY[0..plainLocals) OF UNSPECIFIED;  -- put plain space first    BEGIN ENABLE UNWIND =>      {FOR i: CARDINAL IN [0..plainLocals) DO        IF locals[i] ~= ourLF THEN	  RuntimeInternal.WorryCallDebugger["LFBeater-unwind?"G];	ENDLOOP};    -- These internal BEGIN/END groups make local scopes to minimize local usage.    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO locals[i] ¬ ourLF ENDLOOP;    END;    LFBeaterInternal.Block[];    IF pDepth­ = 0 THEN RETURN;    BEGIN    nextDepth: CARDINAL ¬ pDepth­ - 1;    nextProc: LFBeaterInternal.ProcLFn ¬ BeaterProcs.Select[      LFBeaterInternal.RandomNumber[BeaterProcs.countRegistered]];    IF ~HintNextFrameSafe[nextProc] THEN RETURN;    nextProc[@nextDepth];    END;    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO      IF locals[i] ~= ourLF THEN        RuntimeInternal.WorryCallDebugger["LFBeater-main?"G];      ENDLOOP;    END;    END;  -- scope of UNWIND    END;  -- ProcLF23  ProcLF24: LFBeaterInternal.ProcLFn =    -- [pDepth: LONG POINTER TO CallData]    --   where CallData = TYPE = RECORD[depth: CARDINAL, myRandom: CARDINAL]    -- Procedure requiring a local frame of fsi = 24.    -- size = 1532, <= 1528 words of locals    BEGIN    plainLocals: CARDINAL = PrincOps.frameSizeMap[24] - procLFnOverhead;    ourLF: UNSPECIFIED ¬ Frame.MyLocalFrame[];    locals: ARRAY[0..plainLocals) OF UNSPECIFIED;  -- put plain space first    BEGIN ENABLE UNWIND =>      {FOR i: CARDINAL IN [0..plainLocals) DO        IF locals[i] ~= ourLF THEN	  RuntimeInternal.WorryCallDebugger["LFBeater-unwind?"G];	ENDLOOP};    -- These internal BEGIN/END groups make local scopes to minimize local usage.    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO locals[i] ¬ ourLF ENDLOOP;    END;    LFBeaterInternal.Block[];    IF pDepth­ = 0 THEN RETURN;    BEGIN    nextDepth: CARDINAL ¬ pDepth­ - 1;    nextProc: LFBeaterInternal.ProcLFn ¬ BeaterProcs.Select[      LFBeaterInternal.RandomNumber[BeaterProcs.countRegistered]];    IF ~HintNextFrameSafe[nextProc] THEN RETURN;    nextProc[@nextDepth];    END;    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO      IF locals[i] ~= ourLF THEN        RuntimeInternal.WorryCallDebugger["LFBeater-main?"G];      ENDLOOP;    END;    END;  -- scope of UNWIND    END;  -- ProcLF24  ProcLF25: LFBeaterInternal.ProcLFn =    -- [pDepth: LONG POINTER TO CallData]    --   where CallData = TYPE = RECORD[depth: CARDINAL, myRandom: CARDINAL]    -- Procedure requiring a local frame of fsi = 25.    -- size = 1788, <= 1784 words of locals    BEGIN    plainLocals: CARDINAL = PrincOps.frameSizeMap[25] - procLFnOverhead;    ourLF: UNSPECIFIED ¬ Frame.MyLocalFrame[];    locals: ARRAY[0..plainLocals) OF UNSPECIFIED;  -- put plain space first    BEGIN ENABLE UNWIND =>      {FOR i: CARDINAL IN [0..plainLocals) DO        IF locals[i] ~= ourLF THEN	  RuntimeInternal.WorryCallDebugger["LFBeater-unwind?"G];	ENDLOOP};    -- These internal BEGIN/END groups make local scopes to minimize local usage.    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO locals[i] ¬ ourLF ENDLOOP;    END;    LFBeaterInternal.Block[];    IF pDepth­ = 0 THEN RETURN;    BEGIN    nextDepth: CARDINAL ¬ pDepth­ - 1;    nextProc: LFBeaterInternal.ProcLFn ¬ BeaterProcs.Select[      LFBeaterInternal.RandomNumber[BeaterProcs.countRegistered]];    IF ~HintNextFrameSafe[nextProc] THEN RETURN;    nextProc[@nextDepth];    END;    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO      IF locals[i] ~= ourLF THEN        RuntimeInternal.WorryCallDebugger["LFBeater-main?"G];      ENDLOOP;    END;    END;  -- scope of UNWIND    END;  -- ProcLF25  ProcLF26: LFBeaterInternal.ProcLFn =    -- [pDepth: LONG POINTER TO CallData]    --   where CallData = TYPE = RECORD[depth: CARDINAL, myRandom: CARDINAL]    -- Procedure requiring a local frame of fsi = 26.    -- size = 2044, <= 2040 words of locals    BEGIN    plainLocals: CARDINAL = PrincOps.frameSizeMap[26] - procLFnOverhead;    ourLF: UNSPECIFIED ¬ Frame.MyLocalFrame[];    locals: ARRAY[0..plainLocals) OF UNSPECIFIED;  -- put plain space first    BEGIN ENABLE UNWIND =>      {FOR i: CARDINAL IN [0..plainLocals) DO        IF locals[i] ~= ourLF THEN	  RuntimeInternal.WorryCallDebugger["LFBeater-unwind?"G];	ENDLOOP};    -- These internal BEGIN/END groups make local scopes to minimize local usage.    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO locals[i] ¬ ourLF ENDLOOP;    END;    LFBeaterInternal.Block[];    IF pDepth­ = 0 THEN RETURN;    BEGIN    nextDepth: CARDINAL ¬ pDepth­ - 1;    nextProc: LFBeaterInternal.ProcLFn ¬ BeaterProcs.Select[      LFBeaterInternal.RandomNumber[BeaterProcs.countRegistered]];    IF ~HintNextFrameSafe[nextProc] THEN RETURN;    nextProc[@nextDepth];    END;    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO      IF locals[i] ~= ourLF THEN        RuntimeInternal.WorryCallDebugger["LFBeater-main?"G];      ENDLOOP;    END;    END;  -- scope of UNWIND    END;  -- ProcLF26  ProcLF27: LFBeaterInternal.ProcLFn =    -- [pDepth: LONG POINTER TO CallData]    --   where CallData = TYPE = RECORD[depth: CARDINAL, myRandom: CARDINAL]    -- Procedure requiring a local frame of fsi = 27.    -- size = 2556, <= 2552 words of locals    BEGIN    plainLocals: CARDINAL = PrincOps.frameSizeMap[27] - procLFnOverhead;    ourLF: UNSPECIFIED ¬ Frame.MyLocalFrame[];    locals: ARRAY[0..plainLocals) OF UNSPECIFIED;  -- put plain space first    BEGIN ENABLE UNWIND =>      {FOR i: CARDINAL IN [0..plainLocals) DO        IF locals[i] ~= ourLF THEN	  RuntimeInternal.WorryCallDebugger["LFBeater-unwind?"G];	ENDLOOP};    -- These internal BEGIN/END groups make local scopes to minimize local usage.    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO locals[i] ¬ ourLF ENDLOOP;    END;    LFBeaterInternal.Block[];    IF pDepth­ = 0 THEN RETURN;    BEGIN    nextDepth: CARDINAL ¬ pDepth­ - 1;    nextProc: LFBeaterInternal.ProcLFn ¬ BeaterProcs.Select[      LFBeaterInternal.RandomNumber[BeaterProcs.countRegistered]];    IF ~HintNextFrameSafe[nextProc] THEN RETURN;    nextProc[@nextDepth];    END;    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO      IF locals[i] ~= ourLF THEN        RuntimeInternal.WorryCallDebugger["LFBeater-main?"G];      ENDLOOP;    END;    END;  -- scope of UNWIND    END;  -- ProcLF27  ProcLF28: LFBeaterInternal.ProcLFn =    -- [pDepth: LONG POINTER TO CallData]    --   where CallData = TYPE = RECORD[depth: CARDINAL, myRandom: CARDINAL]    -- Procedure requiring a local frame of fsi = 28.    -- size = 3068, <= 3064 words of locals    BEGIN    plainLocals: CARDINAL = PrincOps.frameSizeMap[28] - procLFnOverhead;    ourLF: UNSPECIFIED ¬ Frame.MyLocalFrame[];    locals: ARRAY[0..plainLocals) OF UNSPECIFIED;  -- put plain space first    BEGIN ENABLE UNWIND =>      {FOR i: CARDINAL IN [0..plainLocals) DO        IF locals[i] ~= ourLF THEN	  RuntimeInternal.WorryCallDebugger["LFBeater-unwind?"G];	ENDLOOP};    -- These internal BEGIN/END groups make local scopes to minimize local usage.    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO locals[i] ¬ ourLF ENDLOOP;    END;    LFBeaterInternal.Block[];    IF pDepth­ = 0 THEN RETURN;    BEGIN    nextDepth: CARDINAL ¬ pDepth­ - 1;    nextProc: LFBeaterInternal.ProcLFn ¬ BeaterProcs.Select[      LFBeaterInternal.RandomNumber[BeaterProcs.countRegistered]];    IF ~HintNextFrameSafe[nextProc] THEN RETURN;    nextProc[@nextDepth];    END;    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO      IF locals[i] ~= ourLF THEN        RuntimeInternal.WorryCallDebugger["LFBeater-main?"G];      ENDLOOP;    END;    END;  -- scope of UNWIND    END;  -- ProcLF28   ProcLF29: LFBeaterInternal.ProcLFn =    -- [pDepth: LONG POINTER TO CallData]    --   where CallData = TYPE = RECORD[depth: CARDINAL, myRandom: CARDINAL]    -- Procedure requiring a local frame of fsi = 29.    -- size = 3580, <= 3576 words of locals    BEGIN    plainLocals: CARDINAL = PrincOps.frameSizeMap[29] - procLFnOverhead;    ourLF: UNSPECIFIED ¬ Frame.MyLocalFrame[];    locals: ARRAY[0..plainLocals) OF UNSPECIFIED;  -- put plain space first    BEGIN ENABLE UNWIND =>      {FOR i: CARDINAL IN [0..plainLocals) DO        IF locals[i] ~= ourLF THEN	  RuntimeInternal.WorryCallDebugger["LFBeater-unwind?"G];	ENDLOOP};    -- These internal BEGIN/END groups make local scopes to minimize local usage.    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO locals[i] ¬ ourLF ENDLOOP;    END;    LFBeaterInternal.Block[];    IF pDepth­ = 0 THEN RETURN;    BEGIN    nextDepth: CARDINAL ¬ pDepth­ - 1;    nextProc: LFBeaterInternal.ProcLFn ¬ BeaterProcs.Select[      LFBeaterInternal.RandomNumber[BeaterProcs.countRegistered]];    IF ~HintNextFrameSafe[nextProc] THEN RETURN;    nextProc[@nextDepth];    END;    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO      IF locals[i] ~= ourLF THEN        RuntimeInternal.WorryCallDebugger["LFBeater-main?"G];      ENDLOOP;    END;    END;  -- scope of UNWIND    END;  -- ProcLF29   ProcLF30: LFBeaterInternal.ProcLFn =    -- [pDepth: LONG POINTER TO CallData]    --   where CallData = TYPE = RECORD[depth: CARDINAL, myRandom: CARDINAL]    -- Procedure requiring a local frame of fsi = 30.    -- size = 4092, <= 4088 words of locals    BEGIN    plainLocals: CARDINAL = PrincOps.frameSizeMap[30] - procLFnOverhead;    ourLF: UNSPECIFIED ¬ Frame.MyLocalFrame[];    locals: ARRAY[0..plainLocals) OF UNSPECIFIED;  -- put plain space first    BEGIN ENABLE UNWIND =>      {FOR i: CARDINAL IN [0..plainLocals) DO        IF locals[i] ~= ourLF THEN	  RuntimeInternal.WorryCallDebugger["LFBeater-unwind?"G];	ENDLOOP};    -- These internal BEGIN/END groups make local scopes to minimize local usage.    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO locals[i] ¬ ourLF ENDLOOP;    END;    LFBeaterInternal.Block[];    IF pDepth­ = 0 THEN RETURN;    BEGIN    nextDepth: CARDINAL ¬ pDepth­ - 1;    nextProc: LFBeaterInternal.ProcLFn ¬ BeaterProcs.Select[      LFBeaterInternal.RandomNumber[BeaterProcs.countRegistered]];    IF ~HintNextFrameSafe[nextProc] THEN RETURN;    nextProc[@nextDepth];    END;    BEGIN    FOR i: CARDINAL IN [0..plainLocals) DO      IF locals[i] ~= ourLF THEN        RuntimeInternal.WorryCallDebugger["LFBeater-main?"G];      ENDLOOP;    END;    END;  -- scope of UNWIND    END;  -- ProcLF30  HintNextFrameSafe: PROCEDURE [nextProc: LFBeaterInternal.ProcLFn]    RETURNS [BOOLEAN] =    BEGIN    -- Determines whether there is room to allocate a frame of size    -- required by nextProc.    -- The answer returned is true when we calculate it, but a lot can happen    -- before the procedure is actually called...    -- Small frame sizes have several options before allocating a page, but    -- for the time being we play it conservatively and be sure there's a page.    -- Larger frame sizes >= FrameImpl.largeFrameThresholdFsi (=12)    -- allocate pages for the frame.    pagesNeeded: CARDINAL ¬ SELECT nextProc FROM      -- small frames:      ProcLF0, ProcLF1, ProcLF2, ProcLF3, ProcLF4, ProcLF5, ProcLF6,      ProcLF7, ProcLF8, ProcLF9, ProcLF10, ProcLF11, ProcLF12,      -- large frames:      ProcLF13, ProcLF14, ProcLF15, ProcLF16, ProcLF17, ProcLF18, ProcLF19,      -- and special:      SignalDemon => 1,      -- continuing large frames:       ProcLF20, ProcLF21 => 2,      ProcLF22, ProcLF23 => 3,      ProcLF24 => 4,      ProcLF25 => 5,      ProcLF26 => 6,      ProcLF27 => 7,      ProcLF28 => 8,      ProcLF29 => 9,      ENDCASE --30-- => 10;    RETURN[LFBeaterInternal.AtLeastThisManyLeftToAlloc[pagesNeeded]];    END;  -- HintNextFrameSafe  RegisterByFrameWeights: PUBLIC PROCEDURE [    array: LONG DESCRIPTOR FOR ARRAY PrincOps.FrameSizeIndex OF CARDINAL] =    -- Register procs for each frame weight.  Parameter array specifies    -- the number of times to register the procedure for that frame size.    BEGIN     FOR i: CARDINAL IN [0..array.LENGTH) DO      FOR j: CARDINAL IN [0..array[i]) DO        BeaterProcs.RegisterBeaterProc[procsByFsi[i]];	ENDLOOP;      ENDLOOP;    END;  -- RegisterByFrameWeights  RegisterOther: PUBLIC PROCEDURE =    BEGIN ENABLE BeaterProcs.BeaterListFull => CONTINUE;    BeaterProcs.RegisterBeaterProc[SignalDemon];    END;  SignalDemon: LFBeaterInternal.ProcLFn =    -- When this one gets called, it raises a signal which starts unwinding    -- the call stack.    -- Passed in parameters are ignored.    {SIGNAL Unwinder};<<  FrameVec, frameSizeMap: ARRAY FrameSizeIndex OF [0..MaxFrameSize] = [   8, 12, 16, 20, 24, 28, 32, 40, 48, 56, 68, 80, 96, 112, 128, 148, 168, 192,   224, 252, 508, 764, 1020, 1276, 1532, 1788, 2044, 2556, 3068, 3580, 4092];   -- frameSizeMap[k] = SIZE[LocalOverhead] + nLocalVariables>>  END.LOG 1-Jun-88 18:23:36	CAJ	Created file.
-- FaultBrowser.mesa   21-Oct-87 16:31:31 by WDK-- Copyright (C) 1984, 1987  by Xerox Corporation. All rights reserved. -- This is a Sword-world Tool for groping around inside Pilot and determining the state of the world vis-a-vis fault handling.-- Written by WDK, February 5, 1981.-- THINGS TO DO:-- Display transferProc table-- Implement swap unit prev.-- Option to display busy swap units ONLY.-- Interpret usages.-- Usage menu item.-- Show outlaw map units.-- Look in between map units for pages.DIRECTORY  BackingStore USING [Data],  DebugUsefulDefs USING [    Lengthen, LongCopyREAD, LongREAD, NotFound, UserAborted],  DebugUsefulDefsExtras USING [Frame, GFlong],  DebugUsefulDefsExtras2 USING [GetPageState, GetVMSize, SwapState],  Environment USING [    LongPointerFromPage, maxPagesInMDS, PageCount,    PageFromLongPointer, PageNumber],  Exec USING [AddCommand, ExecProc, OutputProc, RemoveCommand],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType, CommandItem,    Enumerated, EnumeratedItem, line0, LongNumberItem,    nextLine, NotifyProcType, NumberItem, ProcType, sameLine],  Format USING [NumberFormat],  FrameImpl USING [],  Menu USING [Handle, Instantiate, Make, MCRType],  MsgSW USING [Clear, Post],  MSegment USING [FreeWords, GetWords],  MStoreImpl,  PageFaultImpl,  PageMap USING [Flags, flagsVacant, RealPageNumber],  PilotControl USING [countVM],  PrincOps USING [StateVector],  PSB USING [    NullStateVectorHandle, PDA, Priority, ProcessStateBlock, PsbIndex, PsbLink,    PsbNull, qFrameFault, qPageFault, Queue, qWriteProtectFault,    StateAllocationTable, StateVectorHandle],  Put USING [CR, Decimal, Line, LongDecimal, LongNumber, LongOctal, Number, Octal, Text],  Runtime USING [GetBcdTime],  Selection USING [LongNumber],  Space USING [Access, Life],   String USING [AppendString, InvalidNumber],  Time USING [Append, Unpack],  Tool USING [    Create, Destroy, MakeFileSW, MakeFormSW, MakeMsgSW, MakeSWsProc,    UnusedLogName],  ToolWindow USING [Activate, TransitionProcType],  UserInput USING [ResetUserAbort, UserAbort],  UserTerminal USING [BlinkDisplay],  VM USING [Interval, nullPage, PageCount],  VMData,  VMDataInternal,  VMDataImpl,  VMDataUtilities,  Window USING [Handle],  WindowFont USING [CharWidth];FaultBrowser: PROGRAM  IMPORTS    -- Sword:    DebugUsefulDefs, DebugUsefulDefsExtras, DebugUsefulDefsExtras2,     -- Tajo:    Exec, FormSW, Menu, MSegment, MsgSW, Put, Selection, Tool, ToolWindow,    UserInput, WindowFont,    -- Pilot:    Environment, Runtime, String, --Space,-- Time, UserTerminal  SHARES    FrameImpl,  -- frame fault queue    MStoreImpl,  -- reserved memory counters    PageFaultImpl,  -- page fault queue    PilotControl,  -- size of vm    VMDataImpl,  -- run table    VMDataUtilities --swap unit table-- =  BEGIN  OPEN DUD: DebugUsefulDefs, DUD2: DebugUsefulDefsExtras2;    -- PARAMETERS:  debug: BOOLEAN ¬ FALSE;  -- shall we go to the debugger on errors?  -- TYPEs:  -- TYPES of Faults:  FaultType: TYPE = {    addressFaultUnprocessed, addressFaultBeingProcessed, frame, notFault,    pageAwaitingHandler, pageBeingProcessed, pageUnprocessed, writeBeingProcessed,    writeUnprocessed};  -- TYPES and Constants of VMData:  IrregularSwapUnitData: TYPE = VMDataInternal.IrregularSwapUnitData;  NSwapUnits: TYPE = VMDataInternal.NSwapUnits;  PRun: TYPE = VMDataInternal.PRun;  PSwapUnit: TYPE = VMDataInternal.PSwapUnit;  Run: TYPE = VMDataInternal.Run;  SwapUnitState: TYPE = VMDataInternal.SwapUnitState;  UniformSwapUnitData: TYPE = VMDataInternal.UniformSwapUnitData;  nilPRun: PRun = VMDataInternal.nilPRun;  nilPSwapUnit: PSwapUnit = VMDataInternal.nilPSwapUnit;  pRunFirst: PRun = VMDataInternal.pRunFirst;  -- TYPES for FaultBrowser:  TableType: TYPE = {    faultQueues, readyQueue, runTable, swapUnitTable, pages, stateVectors};  KeyType: TYPE = {address, page, runPtr, runRelPtr};  -- FaultBrowser menu item type:  pageFromLongPointer: CARDINAL = FIRST[CARDINAL];  pageFromShortPointer: CARDINAL = pageFromLongPointer + 1;  longPointerFromPage: CARDINAL = pageFromShortPointer + 1;  shortPointerFromPage: CARDINAL = longPointerFromPage + 1;  LASTFaultBrowserMenuItemType: CARDINAL = shortPointerFromPage;  Module: TYPE = {    frameImpl, mStoreImpl, pageFaultImpl, pilotControl, vmDataImpl, vmDataUtilities};  PageFaultImplConstants: POINTER TO FRAME[PageFaultImpl] =  --    NIL;  -- for accessing module's TYPEs and compile-time constants.  ModuleDesc: TYPE = RECORD [name: LONG STRING, framePointer: LONG POINTER --TO FRAME-- ];  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = RECORD [    -- Note: enumerateds and booleans must be word boundary    --   aligned as addresses for them must be generated    msgSW: Window.Handle ¬ NIL,    fileSW: Window.Handle ¬ NIL,    formSW: Window.Handle ¬ NIL,    tableType: TableType ¬ FIRST[TableType],    alignB: WORD ¬ 0,    verbose: BOOLEAN ¬ FALSE,    alignA: WORD ¬ 0,    keyType: KeyType ¬ page,    startKey: LONG CARDINAL ¬ 0,  -- various types, actually.    count: CARDINAL ¬ 1,    -- Run Table Data:    runBase: VMDataInternal.RunBase ¬ NIL,  -- base ptr to run table.    pageTop: Environment.PageNumber ¬ 0,  -- highest implemented vm page.    pRunTop: PRun ¬ nilPRun,  -- Note: points to a top-of-table descriptor.    pRunCur: PRun ¬ nilPRun,  -- current run.    -- Swap Unit Table Data:    sBase: VMDataInternal.SwapUnitBase ¬ NIL,  -- base ptr to swap unit table.    pSwapUnitNextFree: PSwapUnit ¬ nilPSwapUnit,  -- end of swap unit table.    pageSwapUnitCur: Environment.PageNumber ¬ VM.nullPage,  -- for Next.    countSwapUnitCur: Environment.PageCount ¬ 0,  -- for Next.    pageSwapUnitParentLastPrinted: Environment.PageNumber ¬ VM.nullPage,    -- Queue processing:    psbsDisplayed: CARDINAL ¬ 0,    -- Module frame pointers:    module: ARRAY Module OF ModuleDesc ¬ ALL[[NIL, NIL]]];  PFrameImpl: PROCEDURE RETURNS [LONG POINTER TO FRAME[FrameImpl]] = INLINE {    RETURN[LOOPHOLE[d.module[frameImpl].framePointer]]};  PMStoreImpl: PROCEDURE RETURNS [LONG POINTER TO FRAME[MStoreImpl]] = INLINE {    RETURN[LOOPHOLE[d.module[mStoreImpl].framePointer]]};  PPageFaultImpl: PROCEDURE RETURNS [LONG POINTER TO FRAME[PageFaultImpl]] = INLINE {    RETURN[LOOPHOLE[d.module[pageFaultImpl].framePointer]]};  PPilotControl: PROCEDURE RETURNS [LONG POINTER TO FRAME[PilotControl]] = INLINE {    RETURN[LOOPHOLE[d.module[pilotControl].framePointer]]};  PVMDataImpl: PROCEDURE RETURNS [LONG POINTER TO FRAME[VMDataImpl]] = INLINE {    RETURN[LOOPHOLE[d.module[vmDataImpl].framePointer]]};  PVMDataUtilities: PROCEDURE RETURNS [LONG POINTER TO FRAME[VMDataUtilities]] = INLINE    {RETURN[LOOPHOLE[d.module[vmDataUtilities].framePointer]]};  -- Variables:  d: DataHandle ¬ NIL;  wh: Window.Handle;  nModules: CARDINAL =    LOOPHOLE[LAST[Module], CARDINAL] - LOOPHOLE[FIRST[Module], CARDINAL] + 1;  nTableTypes: CARDINAL =    LOOPHOLE[LAST[TableType], CARDINAL] - LOOPHOLE[FIRST[TableType], CARDINAL] +      1;  AbortThyself: SIGNAL = CODE;  LogicProblem: PRIVATE SIGNAL = CODE;  -- program logic or client data problem. Proceed at your own risk.  peeCeeCheck: BOOLEAN; -- used by CheckPCMemory to prevent "End of VM. End of VM. End of VM. End of VM. End of VM..."  --=======================================================  -- Initialization:  --=======================================================  Initialize: PROCEDURE =    BEGIN    herald: STRING ¬ [60];    Exec.AddCommand[      "FaultBrowser.~"L, FaultBrowserExec, FaultBrowserHelp, FaultBrowserUnload];    String.AppendString[herald, "Fault Browser of "L];    Time.Append[herald, Time.Unpack[Runtime.GetBcdTime[]]];    herald.length ¬ herald.length - 8;  -- omit hours, mins, zone.    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default,      clientTransition: ClientTransition,      name: herald, cmSection: "Fault Browser"L];    END;      FaultBrowserExec: Exec.ExecProc =    BEGIN    ToolWindow.Activate[wh];    END;      FaultBrowserHelp: Exec.ExecProc =    BEGIN    h.OutputProc[]["FaultBrowser grazes through the debuggee's VM database.  See <hacks>FaultBrowser.doc ."L];    END;      FaultBrowserUnload: Exec.ExecProc =    BEGIN    d ¬ NIL;    IF wh # NIL THEN Tool.Destroy[wh];    wh ¬ NIL;    [] ¬ Exec.RemoveCommand[h, "FaultBrowser.~"L];    END;  MakeSWs: Tool.MakeSWsProc =    BEGIN    logName: STRING ¬ [40];    menu: Menu.Handle;    menuStrings: ARRAY [0..LASTFaultBrowserMenuItemType] OF LONG STRING;    menuStrings[pageFromLongPointer] ¬ "page from long pointer"L;    menuStrings[pageFromShortPointer] ¬ "page from short pointer"L;    menuStrings[longPointerFromPage] ¬ "long pointer from page"L;    menuStrings[shortPointerFromPage] ¬ "short pointer from page"L;    menu ¬ Menu.Make[      name: "FaultBrowser"L, strings: DESCRIPTOR[menuStrings],      mcrProc: MenuCommandRoutine];    Tool.UnusedLogName[unused: logName, root: "FaultBrowser.log"L];    d.msgSW ¬ Tool.MakeMsgSW[window: window];    d.formSW ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    d.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    Menu.Instantiate[menu, window];    END;  MakeForm: FormSW.ClientItemsProcType --RETURNS [items, freeDesc]--  =    --           1         2         3         4         5         6    -- 0123456789012345678901234567890123456789012345678901234567890    -- Table: swap unit table   Display Table!   verbose    -- Display Table Items!   Next!   Prev!    --   Key Type: page   Start key: 000000B   Count: 000    --   Check Reserved Memory!         Check PC Memory!    --    BEGIN OPEN F: FormSW;    cw: CARDINAL = WindowFont.CharWidth['M];    nItems: CARDINAL = 11;    item: CARDINAL ¬ 0;        CurItemAndIncr: PROC RETURNS [curItem: CARDINAL] = {      IF (curItem ¬ item) >= nItems THEN ERROR; item ¬ SUCC[item]};    items ¬ F.AllocateItemDescriptor[nItems];    BEGIN    tableTypeNames: ARRAY TableType OF F.Enumerated ¬ [      ["fault queues"L, TableType[faultQueues]],      ["ready queue"L, TableType[readyQueue]],      ["run table"L, TableType[runTable]],      ["swap unit table"L, TableType[swapUnitTable]],      ["pages"L, TableType[pages]],      ["state vectors"L, TableType[stateVectors]]];    d.tableType ¬ FIRST[TableType];    items[CurItemAndIncr[]] ¬ F.EnumeratedItem[      tag: "Table"L, place: [0, F.line0], feedback: one, value: @d.tableType,      choices: LOOPHOLE[DESCRIPTOR[tableTypeNames], DESCRIPTOR FOR ARRAY [0..0) OF      F.Enumerated]];    END;    items[CurItemAndIncr[]] ¬ F.CommandItem[      tag: "Display Table"L, place: [25*cw, F.sameLine], proc: DisplayTable];    d.verbose ¬ FALSE;    items[CurItemAndIncr[]] ¬ F.BooleanItem[      tag: "verbose"L, place: [42*cw, F.sameLine], switch: @d.verbose];    items[CurItemAndIncr[]] ¬ F.CommandItem[      tag: "Display Table Items"L, place: [0*cw, F.nextLine],      proc: DisplayTableItems];    items[CurItemAndIncr[]] ¬ F.CommandItem[      tag: "Next"L, place: [23*cw, F.sameLine], proc: Next];    items[CurItemAndIncr[]] ¬ F.CommandItem[      tag: "Prev"L, place: [31*cw, F.sameLine], proc: Prev];    BEGIN    keyTypeNames: ARRAY KeyType OF F.Enumerated ¬ [      ["address"L, KeyType[address]], ["page"L, KeyType[page]], [      "run­"L, KeyType[runPtr]], ["run­R"L, KeyType[runRelPtr]]];    d.keyType ¬ page;    items[CurItemAndIncr[]] ¬ F.EnumeratedItem[      tag: "Key Type"L, place: [2*cw, F.nextLine], feedback: one,      value: @d.keyType,      choices: LOOPHOLE[DESCRIPTOR[keyTypeNames], DESCRIPTOR FOR ARRAY [0..0) OF      F.Enumerated]];    END;    d.startKey ¬ 0;    items[CurItemAndIncr[]] ¬ F.LongNumberItem[      tag: "Start key "L, place: [30*cw, F.sameLine], boxWidth: 10*cw,      drawBox: FALSE, signed: FALSE, notNegative: TRUE, value: @d.startKey];    d.count ¬ 1;    items[CurItemAndIncr[]] ¬      F.NumberItem[      tag: "Count "L, place: [51*cw, F.sameLine], drawBox: FALSE, signed: FALSE,      notNegative: TRUE, value: @d.count];    items[CurItemAndIncr[]] ¬ F.CommandItem[      tag: "Check Reserved Memory"L, place: [2*cw, F.nextLine], proc: CheckReservedMemory];    items[CurItemAndIncr[]] ¬ F.CommandItem[      tag: "Check PC Memory"L, place: [33*cw, F.sameLine], proc: CheckPCMemory];    RETURN[items: items, freeDesc: TRUE];    END;  ClientTransition: ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      (old = inactive) =>	IF d = NIL THEN {d ¬ MSegment.GetWords[SIZE[Data]]; d­ ¬ []};      (new = inactive) => IF d ~= NIL THEN {MSegment.FreeWords[d]; d ¬ NIL};      ENDCASE;    END;  NotifyClientOfFormAction: FormSW.NotifyProcType = {};  -- This procedure will be called whenever a potentially interesting state  -- change (user action) occurs in the Form subwindow.  --=======================================================  -- Error messages, text output, tool control:  --=======================================================  AbortMe: PROCEDURE =    BEGIN UserInput.ResetUserAbort[wh]; SIGNAL AbortThyself END;  PostErrorString: PROCEDURE [    text: LONG STRING, begin: {startsLine, continuingLine},    end: {endsLine, lineContinues}] =    -- Posts message both in Message sw and in log sw.    -- A CR is supplied if end = endsLine.    BEGIN    UserTerminal.BlinkDisplay[];    MsgSW.Post[      sw: d.msgSW, string: text, prefix: (begin=startsLine),      severity: warning, endOfMsg: (end=endsLine)];    Put.Text[d.fileSW, text];    IF end = endsLine THEN Put.CR[d.fileSW];    END;  PutBlock: PROCEDURE [    data: DESCRIPTOR FOR ARRAY OF UNSPECIFIED, format: Format.NumberFormat] =    BEGIN    FOR k: CARDINAL IN [0..LENGTH[data]] DO      Put.Number[d.fileSW, data[k], format]; ENDLOOP;    END;  Trouble: PROCEDURE[] = {    IF debug THEN SIGNAL LogicProblem;    PostErrorString["program logic error"L, startsLine, endsLine]};  Width: PROCEDURE [width: CARDINAL] RETURNS [Format.NumberFormat] = {    RETURN[[base: 10, zerofill: FALSE, unsigned: TRUE, columns: width]]};  WidthOctal: PROCEDURE [width: CARDINAL] RETURNS [Format.NumberFormat] = {    RETURN[[base: 8, zerofill: FALSE, unsigned: TRUE, columns: width]]};  --=======================================================  -- Worker routines:  --=======================================================  FindGlobalFrames: PROCEDURE =    BEGIN    FOR m: Module IN Module DO d.module[m].name ¬ NIL ENDLOOP;    d.module[frameImpl].name ¬ "FrameImpl" --G-- ;    d.module[mStoreImpl].name ¬ "MStoreImpl" --G-- ;    d.module[pageFaultImpl].name ¬ "PageFaultImpl" --G-- ;    d.module[pilotControl].name ¬ "PilotControl" --G-- ;    d.module[vmDataImpl].name ¬ "VMDataImpl" --G-- ;    d.module[vmDataUtilities].name ¬ "VMDataUtilities" --G-- ;    FOR m: Module IN Module DO      d.module[m].framePointer ¬	(IF d.module[m].name = NIL THEN NIL	 ELSE DebugUsefulDefsExtras.GFlong[DebugUsefulDefsExtras.Frame[	   d.module[m].name !	   DUD.NotFound => {	     PostErrorString[	       "can't find "L, startsLine, lineContinues];	     PostErrorString[	       d.module[m].name, continuingLine, endsLine];	     SIGNAL AbortThyself}]]);      ENDLOOP;    END;  --FindGlobalFrames--  CheckReservedMemory: FormSW.ProcType =    BEGIN    ENABLE DUD.UserAborted, AbortThyself => GO TO Aborted;    actualTotalReserved: Environment.PageCount;        TallyReservedInSwapUnit: SwapUnitProcessor  --      --[run, swapUnitPage, swapUnitCount, state] RETURNS [quitNow]--  =      -- Other actual results: tallys actualTotalReserved.      BEGIN      IF state.availability = busy THEN {	Put.Text[d.fileSW, "The swap unit at page "L];	Put.LongDecimal[d.fileSW, swapUnitPage];	Put.Line[d.fileSW, " is busy!"L]}      ELSE IF state.st.access = readOnly AND state.st.swappability = swappable THEN	BEGIN  --reserved memory--	FOR page: Environment.PageNumber IN [	  swapUnitPage..swapUnitPage + swapUnitCount) DO	  swapState: DUD2.SwapState;	  access: Space.Access;	  flags: PageMap.Flags;	  [swapState, access, flags,] ¬ DUD2.GetPageState[page];	  IF swapState = in THEN {	    actualTotalReserved ¬ actualTotalReserved.SUCC;	    IF access # readOnly OR NOT flags.readonly THEN Trouble[]};	  ENDLOOP;	END;  --reserved memory--      RETURN[quitNow: FALSE];      END;  --TallyReservedInSwapUnit--        mStoresCountReserved: Environment.PageCount;    MsgSW.Clear[d.msgSW];    FindGlobalFrames[];    Put.CR[d.fileSW];  -- blank line to separate from prev text.        InitializeSwapUnitTable[];    DUD.LongCopyREAD[      from: @PMStoreImpl[].countReserved,      to: @mStoresCountReserved, nwords: SIZE[Environment.PageCount]];    Put.Text[d.fileSW, "Pilot thinks there are "L];    Put.LongDecimal[d.fileSW, mStoresCountReserved];    Put.Line[d.fileSW, " reserved pages in memory."L];    actualTotalReserved ¬ 0;    EnumerateSwapUnitTable[TallyReservedInSwapUnit];    Put.Text[d.fileSW, "I found "L];    Put.LongDecimal[d.fileSW, actualTotalReserved];    Put.Line[d.fileSW, " reserved pages in memory."L];    EXITS Aborted => Put.Line[d.fileSW, "..aborted."L];    END;      CheckPCMemory: FormSW.ProcType =    BEGIN    ENABLE DUD.UserAborted, AbortThyself => GO TO Aborted;    vmPage: Environment.PageNumber ¬ --TRASH--0;  -- (avoid uninit warning)        CheckResident: SwapUnitProcessor  --      --[run, swapUnitPage, swapUnitCount, state] RETURNS [quitNow]--  =      -- Implicit parameters: vmPage      BEGIN      IF vmPage IN [swapUnitPage..swapUnitPage + swapUnitCount) AND        state.st.swappability = resident THEN       {Put.Text[d.fileSW, "WARNING: page "L]; Put.LongDecimal[d.fileSW, vmPage];        Put.Line[d.fileSW, " is ~pin'd~ in the PC bank!"L]};      RETURN[quitNow: FALSE];      END;  --CheckResident--          realPage: PageMap.RealPageNumber;    pCCount: CARDINAL ¬ 0;    PCstart, PCend: CARDINAL; --MStoreImpl.ShortRealPageNumber    vmSize: Environment.PageNumber ¬ DUD2.GetVMSize[];    peeCeeCheck ¬ TRUE;    MsgSW.Clear[d.msgSW];    FindGlobalFrames[];    Put.CR[d.fileSW];    DUD.LongCopyREAD[      from: @PMStoreImpl[].PCstart,      to: @PCstart, nwords: SIZE[CARDINAL]];    DUD.LongCopyREAD[      from: @PMStoreImpl[].PCend,      to: @PCend, nwords: SIZE[CARDINAL]];    Put.Text[d.fileSW, "Scanning VM... "L];    FOR vmPage: Environment.PageNumber IN [0..vmSize) DO      IF (realPage ¬ DUD2.GetPageState[vmPage].real) IN [PCstart..PCend) THEN	{pCCount ¬ pCCount + 1;	 InitializeSwapUnitTable[];    -- find it's swapUnit to see if it is resident	 EnumerateSwapUnitTable[CheckResident]};      ENDLOOP;    Put.Line[d.fileSW, "End of VM."L];    Put.Text[d.fileSW, "I found "L]; Put.LongDecimal[d.fileSW, pCCount];    Put.Line[d.fileSW, " pages mapped to the PC bank."L];    peeCeeCheck ¬ FALSE;    EXITS Aborted => Put.Line[d.fileSW, "..aborted."L];    END; --CheckPCMemory--  DisplayTable: FormSW.ProcType =    BEGIN    ENABLE DUD.UserAborted, AbortThyself => GO TO Aborted;    MsgSW.Clear[d.msgSW];    FindGlobalFrames[];    Put.CR[d.fileSW];  -- blank line to separate from prev text.    SELECT d.tableType FROM      faultQueues => DisplayFaultQueues[];      readyQueue => DisplayReadyQueue[];      runTable => DisplayRunTable[];      swapUnitTable => DisplaySwapUnitTable[];      pages => DisplayPages[];      stateVectors => DisplayStateVectors[];      ENDCASE => Trouble[];    EXITS Aborted => Put.Line[d.fileSW, "..aborted."L];    END;  DisplayTableItems: FormSW.ProcType =    BEGIN    ENABLE DUD.UserAborted, AbortThyself => GO TO Aborted;    MsgSW.Clear[d.msgSW];    FindGlobalFrames[];    Put.CR[d.fileSW];  -- blank line to separate from prev text.    SELECT d.tableType FROM      faultQueues => DisplayFaultItems[];      readyQueue => RETURN;      runTable => DisplayRunTableItems[];      swapUnitTable => DisplaySwapUnitTableItems[];      pages => DisplayPagesItems[];      stateVectors => RETURN;      ENDCASE => Trouble[];    EXITS Aborted => Put.Line[d.fileSW, "..aborted."L];    END;  Next: FormSW.ProcType =    BEGIN    ENABLE DUD.UserAborted, AbortThyself => GO TO Aborted;    MsgSW.Clear[d.msgSW];    FindGlobalFrames[];    SELECT d.tableType FROM      faultQueues => DisplayFaultNext[];      readyQueue => RETURN;      runTable => DisplayRunTableNext[];      swapUnitTable => DisplaySwapUnitTableNext[];      pages => DisplayPagesNext[];      stateVectors => RETURN;      ENDCASE => Trouble[];    EXITS Aborted => Put.Line[d.fileSW, "..aborted."L];    END;  Prev: FormSW.ProcType =    BEGIN    ENABLE DUD.UserAborted, AbortThyself => GO TO Aborted;    MsgSW.Clear[d.msgSW];    FindGlobalFrames[];    SELECT d.tableType FROM      faultQueues => DisplayFaultPrev[];      readyQueue => RETURN;      runTable => DisplayRunTablePrev[];      swapUnitTable => DisplaySwapUnitTablePrev[];      pages => DisplayPagesPrev[];      stateVectors => RETURN;      ENDCASE => Trouble[];    EXITS Aborted => Put.Line[d.fileSW, "..aborted."L];    END;  MenuCommandRoutine: Menu.MCRType --[index]-- =    BEGIN    ENABLE DUD.UserAborted, AbortThyself => GO TO Aborted;    argument: LONG CARDINAL;    pDebugeeMDS: LONG POINTER;    pageMDS: Environment.PageNumber;    MsgSW.Clear[d.msgSW];    argument ¬ Selection.LongNumber[      radix: 10 !      String.InvalidNumber => {	PostErrorString["Selection is not a valid number!"L, startsLine, endsLine];	GO TO Return}];    pDebugeeMDS ¬  -- ("1" since 0 collides with NIL.)      Order[DUD.Lengthen[LOOPHOLE[1, POINTER]] - 1];    pageMDS ¬      Environment.PageFromLongPointer[LOOPHOLE[pDebugeeMDS]];    SELECT index FROM      pageFromLongPointer => {	argAsLP: LONG ORDERED POINTER = LOOPHOLE[argument];	Put.LongOctal[d.fileSW, argAsLP];	Put.Text[d.fileSW, "­ = page "L];	Put.LongDecimal[d.fileSW, Environment.PageFromLongPointer[argAsLP]];	Put.Text[d.fileSW, " = page "L];	Put.LongOctal[d.fileSW, Environment.PageFromLongPointer[argAsLP]];	Put.CR[d.fileSW]};      pageFromShortPointer =>	BEGIN	IF argument > LAST[--POINTER--CARDINAL] THEN	  BEGIN	  PostErrorString[	    "Selection is not a short pointer!"L, startsLine, endsLine];	  END	ELSE {	  lpFromArg: LONG POINTER = DUD.Lengthen[LOOPHOLE[CARDINAL[argument]]];	  Put.Octal[d.fileSW, CARDINAL[argument]];	  Put.Text[d.fileSW, "­ = page "L];	  Put.LongDecimal[d.fileSW, Environment.PageFromLongPointer[lpFromArg]];	  Put.Text[d.fileSW, " = page "L];	  Put.LongOctal[d.fileSW, Environment.PageFromLongPointer[lpFromArg]];	  Put.CR[d.fileSW]};	END;      longPointerFromPage => {	Put.Text[d.fileSW, "page "L];	Put.LongDecimal[d.fileSW, argument];	Put.Text[d.fileSW, " = page "L];	Put.LongOctal[d.fileSW, argument];	Put.Text[d.fileSW, " = "L];	Put.LongOctal[	  d.fileSW, Environment.LongPointerFromPage[argument]];	Put.Line[d.fileSW, "­"L]};      shortPointerFromPage =>	BEGIN	IF argument < pageMDS OR	  argument - pageMDS >= Environment.maxPagesInMDS THEN	     PostErrorString[	       "Selection is not a page in the MDS!"L, startsLine, endsLine]	ELSE	  BEGIN	  Put.Text[d.fileSW, "page "L];	  Put.LongDecimal[d.fileSW, argument];	  Put.Text[d.fileSW, " = page "L];	  Put.LongOctal[d.fileSW, argument];	  Put.Text[d.fileSW, " = "L];	  Put.Octal[	    d.fileSW,	    CARDINAL[Environment.LongPointerFromPage[argument]-pDebugeeMDS]];	  Put.Line[d.fileSW, "­"L];	  END;	END;      ENDCASE => Trouble[];    EXITS      Aborted => Put.Line[d.fileSW, "..aborted."L];      Return => NULL;    END;  --=======================================================  -- Display Queue routines:  --=======================================================  DisplayReadyQueue: PROCEDURE = {    DisplayQueue[@PSB.PDA.ready, notFault]};  DisplayFaultQueues: PROCEDURE =    BEGIN    pRemoteQueue: LONG POINTER TO PSB.Queue;    d.psbsDisplayed ¬ 0;    DisplayQueue[      @PSB.PDA.fault[PSB.qWriteProtectFault].queue, writeUnprocessed];    DUD.LongCopyREAD[      from: @PPageFaultImpl[].writeFaultsBeingProcessed,      to: @pRemoteQueue, nwords: SIZE[LONG POINTER]];    DisplayQueue[pRemoteQueue, writeBeingProcessed];    DisplayQueue[@PSB.PDA.fault[PSB.qPageFault].queue, pageUnprocessed];    DUD.LongCopyREAD[      from: @PPageFaultImpl[].pageFaultsBeingProcessed,      to: @pRemoteQueue, nwords: SIZE[LONG POINTER]];    DisplayQueue[pRemoteQueue, pageBeingProcessed];    DisplayQueue[      LOOPHOLE[@PPageFaultImpl[].addressFaultsAwaitingProcessing],      addressFaultUnprocessed];    DisplayQueue[      LOOPHOLE[@PPageFaultImpl[].addressFaultsBeingProcessed],      addressFaultBeingProcessed];    DisplayQueue[      LOOPHOLE[@PPageFaultImpl[].clientPageFaultsAwaitingHandler],      pageAwaitingHandler];    DisplayQueue[@PSB.PDA.fault[PSB.qFrameFault].queue, frame];    IF d.psbsDisplayed = 0 THEN      Put.Line[d.fileSW, "No processes are faulted."L];    END;  DisplayQueue: PROCEDURE [    remoteQueue: LONG POINTER TO PSB.Queue, faultType: FaultType] =    BEGIN    localQueue: PSB.Queue = DUD.LongREAD[remoteQueue];    psbi: PSB.PsbIndex;    IF localQueue.tail ~= PSB.PsbNull THEN {      tail: PSB.PsbLink = DUD.LongREAD[@PSB.PDA.block[localQueue.tail].link];      psbi ¬ tail.next;  -- start at head of queue.      WHILE (psbi ¬ DisplayPsb[psbi, faultType]) ~= tail.next DO NULL ENDLOOP};    END;  DisplayFaultItems, DisplayFaultNext, DisplayFaultPrev: PROCEDURE = {    PostErrorString["not implemented."L, startsLine, endsLine]};  DisplayPsb: PROCEDURE [psbi: PSB.PsbIndex, faultType: FaultType]    RETURNS [nextPsb: PSB.PsbIndex] =    BEGIN    Faulted: PROCEDURE RETURNS [BOOLEAN] =      BEGIN      -- First check to see if on the ready list      readyQueue: PSB.Queue = DUD.LongREAD[@PSB.PDA.ready];      IF readyQueue.tail ~= PSB.PsbNull THEN        BEGIN	readyPsbi: PSB.PsbIndex;	readyPsb: PSB.ProcessStateBlock;        tail: PSB.PsbLink = DUD.LongREAD[@PSB.PDA.block[readyQueue.tail].link];        readyPsbi ¬ tail.next;  -- start at head of queue.        DO	  IF readyPsbi = psbi THEN RETURN [FALSE];	  DUD.LongCopyREAD[	    from: @PSB.PDA.block[readyPsbi], to: @readyPsb,	    nwords: SIZE[PSB.ProcessStateBlock]];	  readyPsbi ¬ readyPsb.link.next;	  IF readyPsbi = tail.next THEN EXIT;	  ENDLOOP;        END;      -- At this point process "psbi" is either waiting ML/CV or is faulted      RETURN [~(psb.flags.waiting OR psb.link.failed)];      END;    psb: PSB.ProcessStateBlock;    state: PrincOps.StateVector;    DUD.LongCopyREAD[      from: @PSB.PDA.block[psbi], to: @psb, nwords: SIZE[PSB.ProcessStateBlock]];    nextPsb ¬ psb.link.next;    Put.Text[d.fileSW, "PSB: "L];    Put.Octal[d.fileSW, psbi];    Put.Text[d.fileSW, ", priority: "L];    Put.Decimal[d.fileSW, psb.link.priority];    IF Faulted[] THEN  -- waiting on fault --      BEGIN      DUD.LongCopyREAD[	from: @PSB.PDA[psb.context.state], to: @state,	nwords: SIZE[PrincOps.StateVector]];      Put.Text[d.fileSW, ", L: "L];      Put.Octal[d.fileSW, state.frame];      SELECT faultType FROM	addressFaultUnprocessed => {	  Put.Text[d.fileSW, ", waiting address fault (unprocessed)"L];	  GO TO MemFault};	addressFaultBeingProcessed => {	  Put.Text[d.fileSW, ", waiting address fault (being processed)"L];	  GO TO MemFault};	frame => {	  Put.Text[d.fileSW, ", waiting frame fault"L];	  Put.Text[d.fileSW, ", fsi: "L];	  Put.Octal[d.fileSW, state.fsi]};	pageAwaitingHandler => {	  Put.Text[d.fileSW, ", waiting page fault (awaiting fault handler)"L];	  GO TO MemFault};	pageBeingProcessed => {	  Put.Text[d.fileSW, ", waiting page fault (being processed)"L];	  GO TO MemFault};	pageUnprocessed => {	  Put.Text[d.fileSW, ", waiting page fault (unprocessed)"L];	  GO TO MemFault};	writeBeingProcessed => {	  Put.Text[d.fileSW, ", waiting write fault (being processed)"L];	  GO TO MemFault};	writeUnprocessed => {	  Put.Text[d.fileSW, ", waiting write fault (unprocessed)"L];	  GO TO MemFault};	notFault => {  --	  -- Was faulted but fault has been satisfied.	  -- Now on readyList waiting to run and release its state vector. 	  Put.Text[d.fileSW, ", ready (fault satisfied, has state vector)."L];	  GO TO MemFault};  	ENDCASE => Trouble[];      Put.CR[d.fileSW];      EXITS	MemFault => {	  Put.Text[d.fileSW, ", pointer: "L];	  Put.LongOctal[d.fileSW, state.memPointer];	  Put.Text[d.fileSW, "­, page: "L];	  Put.LongOctal[d.fileSW, Environment.PageFromLongPointer[state.memPointer]]};      END    ELSE  -- not faulted --      BEGIN      Put.Text[d.fileSW, ", L: "L];      Put.Octal[d.fileSW, psb.context.frame];      IF psb.flags.waiting THEN Put.Text[d.fileSW, ", waiting condition."L]      ELSE	IF psb.link.failed THEN Put.Text[d.fileSW, ", waiting monitor."L]	ELSE	  IF DUD.LongREAD[@PSB.PDA.state[psb.link.priority]] =	    PSB.NullStateVectorHandle THEN	    Put.Text[d.fileSW, ", waiting state vector."L]	  ELSE Put.Text[d.fileSW, ", ready."L]      END;    Put.CR[d.fileSW];    d.psbsDisplayed ¬ d.psbsDisplayed.SUCC;    END;  --=======================================================  -- Display Run Table routines:  --=======================================================  DisplayRunTable: PROCEDURE =    BEGIN    DisplayRunTableOne: RunProcessor --[run] RETURNS [quitNow]--  = {      DisplayRun[run]; RETURN[quitNow: FALSE]};    InitializeRunTable[];    Put.Decimal[d.fileSW, ((d.pRunTop - pRunFirst)/SIZE[Run])];    Put.Line[d.fileSW, " runs in run table."L];    Put.Decimal[d.fileSW, DUD.LongREAD[@PVMDataImpl[].countRunTablePagesMapped]];    Put.Line[d.fileSW, " pages occupied by run table."L];    PrintRunTitle[];    EnumerateRunTable[runProcessor: DisplayRunTableOne];    END;  PrintRunTitle: PROCEDURE =    BEGIN    hdrA: STRING ¬  --      "  run   run swapU @swapU allOut begin end  usage   xProc"L;    hdrB: STRING ¬  --      "  page count type  data         mUnit mUnit    class ID ...backing store data ..."L;    -- pppppp ccccc unif ppppp  maybe  begin  end uuuu cc  ttt bbbbbbB bbbbbbB bbbbbbB bbbbbbB bbbbbbB bbbbbbB bbbbbbB bbbbbbB bbbbbbB bbbbbbB    -- 0123456789012345678901234567890123456789012345678901234567890123    IF ~d.verbose THEN hdrB.length ¬ 56;    Put.Line[d.fileSW, hdrA];    Put.Line[d.fileSW, hdrB];    END;  DisplayRunTableItems: PROCEDURE [] =    BEGIN    page: Environment.PageNumber;    itemsProcessed: CARDINAL ¬ 0;    DisplayRunTableItemsOne: RunProcessor  --[run] RETURNS [quitNow]--       =      BEGIN      IF run.interval.page + run.interval.count <= page THEN	RETURN[quitNow: FALSE];      IF run.interval.page > page AND itemsProcessed = 0 THEN {	Put.Text[d.fileSW, "page "L];	Put.LongDecimal[d.fileSW, page];	Put.Line[d.fileSW, " is not mapped."L]};      DisplayRun[run];      RETURN[quitNow: (itemsProcessed ¬ SUCC[itemsProcessed]) >= d.count];      END;    PrintRunTitle[];    InitializeRunTable[];    page ¬ PageFromStartKey[d.startKey];    EnumerateRunTable[runProcessor: DisplayRunTableItemsOne];    IF itemsProcessed = 0 THEN {      Put.Text[d.fileSW, "Page "L];      Put.LongDecimal[d.fileSW, page];      Put.Line[d.fileSW, " is not mapped."L]};    END;  --DisplayRunTableItems--  DisplayRunTableNext: PROCEDURE =    BEGIN    run: Run;    IF d.pRunCur >= d.pRunTop - SIZE[Run] THEN Put.Line[d.fileSW, "End of VM."L]    ELSE {      d.pRunCur ¬ d.pRunCur + SIZE[Run];      DebugUsefulDefs.LongCopyREAD[	from: @d.runBase[d.pRunCur], to: @run, nwords: SIZE[Run]];      DisplayRun[run]};    END;  DisplayRunTablePrev: PROCEDURE =    BEGIN    run: Run;    IF d.pRunCur <= pRunFirst THEN Put.Line[d.fileSW, "Beginning of VM."L]    ELSE {      d.pRunCur ¬ d.pRunCur - SIZE[Run];      DebugUsefulDefs.LongCopyREAD[	from: @d.runBase[d.pRunCur], to: @run, nwords: SIZE[Run]];      DisplayRun[run]};    END;  InitializeRunTable: PROCEDURE =    BEGIN    DUD.LongCopyREAD[      from: @PPilotControl[].countVM, to: @d.pageTop,      nwords: SIZE[Environment.PageCount]];    DUD.LongCopyREAD[      from: @PVMDataImpl[].runBase, to: @d.runBase,      nwords: SIZE[VMDataInternal.RunBase]];    d.pRunTop ¬ DUD.LongREAD[@PVMDataImpl[].pRunTop];    END;  RunProcessor: TYPE = PROCEDURE [run: Run] RETURNS [quitNow: BOOLEAN];  EnumerateRunTable: PROCEDURE [runProcessor: RunProcessor] =    BEGIN    run: Run;    FOR pDs: PRun ¬ pRunFirst, pDs + SIZE[Run] DO      DUD.LongCopyREAD[from: @d.runBase[pDs], to: @run, nwords: SIZE[Run]];      d.pRunCur ¬ pDs;  -- save in global for everybody.      --UNTIL--IF pDs = d.pRunTop THEN {	IF run.interval.page ~= d.pageTop THEN Trouble[];	Put.Line[d.fileSW, "End of VM."L];	EXIT};      IF runProcessor[run].quitNow THEN RETURN;      ENDLOOP;    END;  DisplayRun: PROCEDURE [run: Run] =    BEGIN    hintWrong: BOOLEAN ¬ FALSE;    -- See layout in DisplayRunTable[].    Put.LongNumber[d.fileSW, run.interval.page, Width[6]];    Put.LongNumber[d.fileSW, run.interval.count, Width[6]];    WITH r: run SELECT FROM      unitary => Put.Text[d.fileSW, " unit  self"L];      uniform => {	Put.Text[d.fileSW, " unif"L];	Put.Number[d.fileSW, r.uniformSwapUnitData, Width[6]]};      irregular => {	Put.Text[d.fileSW, "  irr"L];	Put.Number[d.fileSW, r.irregularSwapUnitData, Width[6]]};      ENDCASE => Put.Text[d.fileSW, "  (?)      "L];    Put.Text[d.fileSW, IF run.maybePartlyIn  THEN "  maybe"L ELSE "    yes"L];        IF ~run.maybePartlyIn THEN      BEGIN  --BURP if maybePartlyIn hint is in Wrong...      FOR thisPage: Environment.PageNumber IN [run.interval.page ..        run.interval.page+run.interval.count) DO	IF--UNTIL-- DUD2.GetPageState[thisPage].flags # PageMap.flagsVacant THEN {	  hintWrong ¬ TRUE; EXIT};	ENDLOOP;      END;        Put.Text[d.fileSW, IF run.startOfMapUnit THEN "  begin"L ELSE "       "L];    Put.Text[d.fileSW, IF run.endOfMapUnit THEN "  end"L ELSE "     "L];    Put.Number[d.fileSW, run.usage, Width[5]];    Put.Number[d.fileSW, run.class, Width[3]];    Put.Number[d.fileSW, run.transferProcID, Width[5]];    IF d.verbose THEN      BEGIN      FOR k: CARDINAL IN [0..SIZE[BackingStore.Data]) DO	Put.Number[d.fileSW, run.backingData.data[k], WidthOctal[8]]; ENDLOOP;      END;    IF hintWrong THEN Put.Text[d.fileSW, " This is NOT REALLY allOut!"L];    Put.CR[d.fileSW];    IF UserInput.UserAbort[wh] THEN AbortMe[];    END;  --DisplayRun--  --=======================================================  -- Display Swap Unit routines:  --=======================================================  DisplaySwapUnitTable: PROCEDURE =    BEGIN    countSwapUnitTablePagesMapped: VM.PageCount;    DisplaySwapUnitTableOne: SwapUnitProcessor  --      --[run, swapUnitPage, swapUnitCount, state] RETURNS [quitNow]--  = {      DisplaySwapUnit[run, swapUnitPage, swapUnitCount, state];      RETURN[quitNow: FALSE]};    InitializeSwapUnitTable[];        DUD.LongCopyREAD[      from: @PVMDataUtilities[].countSwapUnitTablePagesMapped,      to: @countSwapUnitTablePagesMapped, nwords: SIZE[VM.PageCount]];    Put.LongDecimal[d.fileSW, countSwapUnitTablePagesMapped];    Put.Line[d.fileSW, " pages occupied by swap unit table."L];    PrintRunTitle[];    PrintSwapUnitTitle[];    EnumerateSwapUnitTable[DisplaySwapUnitTableOne];    END;  DisplaySwapUnitTableItems: PROCEDURE [] =    BEGIN    page: Environment.PageNumber;    itemsProcessed: CARDINAL ¬ 0;    DisplaySwapUnitTableItemsOne: SwapUnitProcessor  --      --[run, swapUnitPage, swapUnitCount, state] RETURNS [quitNow]--  =      BEGIN      IF swapUnitPage + swapUnitCount <= page THEN RETURN[quitNow: FALSE];      IF swapUnitPage > page AND itemsProcessed = 0 THEN {	Put.Text[d.fileSW, "page "L];	Put.LongDecimal[d.fileSW, page];	Put.Line[d.fileSW, " is not mapped."L]};      DisplaySwapUnit[run, swapUnitPage, swapUnitCount, state];      RETURN[quitNow: (itemsProcessed ¬ SUCC[itemsProcessed]) >= d.count];      END;  --DisplaySwapUnitTableItemsOne--    PrintRunTitle[];    PrintSwapUnitTitle[];    InitializeSwapUnitTable[];    page ¬ PageFromStartKey[d.startKey];    EnumerateSwapUnitTable[DisplaySwapUnitTableItemsOne];    IF itemsProcessed = 0 THEN {      Put.Text[d.fileSW, "Page"L];      Put.LongDecimal[d.fileSW, page];      Put.Line[d.fileSW, " is not mapped."L]};    END;  --DisplaySwapUnitTableItems--  DisplaySwapUnitTableNext: PROCEDURE =    BEGIN    page: Environment.PageNumber;    itemsProcessed: CARDINAL ¬ 0;    DisplaySwapUnitTableNextOne: SwapUnitProcessor  --      --[run, swapUnitPage, swapUnitCount, state] RETURNS [quitNow]--  =      BEGIN      IF swapUnitPage + swapUnitCount <= page THEN	RETURN[quitNow: FALSE];      IF swapUnitPage > page THEN        BEGIN	Put.Text[d.fileSW, "page "L];	Put.LongDecimal[d.fileSW, page];	Put.Line[d.fileSW, " is not mapped."L];	END;      DisplaySwapUnit[  -- (updates d.pageSwapUnitCur)        run, swapUnitPage, swapUnitCount, state];      itemsProcessed ¬ itemsProcessed.SUCC;      RETURN[quitNow: TRUE];      END;  --DisplaySwapUnitTableNextOne--          InitializeSwapUnitTable[];    page ¬ d.pageSwapUnitCur + d.countSwapUnitCur;    IF page >= d.pageTop THEN Put.Line[d.fileSW, "End of VM."L]    ELSE      BEGIN      EnumerateSwapUnitTable[DisplaySwapUnitTableNextOne];      IF itemsProcessed = 0 THEN {	Put.Text[d.fileSW, "Page"L];	Put.LongDecimal[d.fileSW, page];	Put.Line[d.fileSW, " is not mapped."L]};      END;    END;  --DisplaySwapUnitTableNext--  DisplaySwapUnitTablePrev: PROCEDURE = {Put.Line[d.fileSW, "not implemented."L]};  InitializeSwapUnitTable: PROCEDURE =    BEGIN    InitializeRunTable[];    DUD.LongCopyREAD[      from: @PVMDataUtilities[].swapUnitBase, to: @d.sBase,      nwords: SIZE[VMDataInternal.SwapUnitBase]];    d.pSwapUnitNextFree ¬ DUD.LongREAD[@PVMDataUtilities[].pSwapUnitNextFree];    d.pageSwapUnitParentLastPrinted ¬ VM.nullPage;    END;  PrintSwapUnitTitle: PROCEDURE =    BEGIN    hdrA: STRING ¬  --      "    swapU swapU"L;    hdrB: STRING ¬  --      "     page count  ...swap unit state..."L;    --     ppppp ccccc avail  read swaps alive"L;    -- 01234567890123456789012345678901234567890    Put.Line[d.fileSW, hdrA];    Put.Line[d.fileSW, hdrB];    END;  SwapUnitProcessor: TYPE = PROCEDURE [    run: Run, swapUnitPage: Environment.PageNumber,    swapUnitCount: Environment.PageCount, state: SwapUnitState]    RETURNS [quitNow: BOOLEAN];  EnumerateSwapUnitTable: PROCEDURE [swapUnitProcessor: SwapUnitProcessor] =    BEGIN    sizeBuffer: CARDINAL = 512 - 12;  -- words (about two pages).    buffer: ARRAY [0..sizeBuffer] OF WORD;  -- (good place for large local frame)    run: Run;    FOR pDs: PRun ¬ pRunFirst, pDs + SIZE[Run] DO      DUD.LongCopyREAD[from: @d.runBase[pDs], to: @run, nwords: SIZE[Run]];      d.pRunCur ¬ pDs;      --UNTIL--IF pDs = d.pRunTop THEN {	IF run.interval.page ~= d.pageTop THEN Trouble[];	IF ~peeCeeCheck THEN Put.Line[d.fileSW, "End of VM."L];	EXIT};      WITH r: run SELECT FROM	unitary => {	  IF swapUnitProcessor[	    run, run.interval.page, run.interval.count, r.swapUnitState].quitNow	    THEN RETURN};	uniform =>	  BEGIN	  page: Environment.PageNumber;	  pageStop: Environment.PageNumber =	    run.interval.page + run.interval.count;	  uData: LONG POINTER TO UniformSwapUnitData = LOOPHOLE[LONG[@buffer]];  -- (type conversion)	  nSwapUnits: VMDataInternal.NSwapUnits;	  swapUnit: VMDataInternal.NSwapUnits;	  DUD.LongCopyREAD[	    from: @d.sBase[r.uniformSwapUnitData], to: uData,	    nwords: SIZE[UniformSwapUnitData [0]]];	  nSwapUnits ¬ uData.nSwapUnits;	  IF SIZE[UniformSwapUnitData [nSwapUnits]] > sizeBuffer THEN {	    PostErrorString[	      "buffer overflow!"L, startsLine, endsLine];	    EXIT};	  DUD.LongCopyREAD[	    from: @d.sBase[r.uniformSwapUnitData], to: uData,	    nwords: SIZE[UniformSwapUnitData [nSwapUnits]]];	  page ¬ run.interval.page;	  IF swapUnitProcessor[	    run, page, uData.firstSwapUnitSize, uData.state[0]].quitNow THEN	    RETURN;	  swapUnit ¬ 1;	  FOR page ¬ page + uData.firstSwapUnitSize, page + uData.swapUnitSize	    WHILE page < pageStop DO	    IF swapUnitProcessor[	      run, page, MIN[uData.swapUnitSize, pageStop - page], uData.state[	      swapUnit]].quitNow THEN RETURN;	    swapUnit ¬ SUCC[swapUnit];	    IF UserInput.UserAbort[wh] THEN AbortMe[];	    ENDLOOP;	  END;  --uniform--	irregular =>	  BEGIN	  page: Environment.PageNumber;	  pageStop: Environment.PageNumber =	    run.interval.page + run.interval.count;	  iData: LONG POINTER TO IrregularSwapUnitData = LOOPHOLE[LONG[@buffer]];	  -- (type conversion)	  nSwapUnits: VMDataInternal.NSwapUnits;	  DUD.LongCopyREAD[	    from: @d.sBase[r.irregularSwapUnitData], to: iData,	    nwords: SIZE[IrregularSwapUnitData [0]]];	  nSwapUnits ¬ iData.nSwapUnits;	  IF SIZE[IrregularSwapUnitData [nSwapUnits]] > sizeBuffer THEN {	    PostErrorString["buffer overflow!"L, startsLine, endsLine]; EXIT};	  DUD.LongCopyREAD[	    from: @d.sBase[r.irregularSwapUnitData], to: iData,	    nwords: SIZE[IrregularSwapUnitData [nSwapUnits]]];	  page ¬ run.interval.page;	  FOR swapUnit: NSwapUnits IN [0..nSwapUnits) DO	    IF swapUnitProcessor[	      run, page, iData.sizeAndState[swapUnit].size, iData.sizeAndState[	      swapUnit].state].quitNow THEN RETURN;	    page ¬ page + iData.sizeAndState[swapUnit].size;	    IF UserInput.UserAbort[wh] THEN AbortMe[];	    ENDLOOP;	  END;  --irregular--	ENDCASE => Trouble[];      IF UserInput.UserAbort[wh] THEN AbortMe[];      ENDLOOP;  --runs--    END;  DisplaySwapUnit: PROCEDURE [    run: Run, swapUnitPage: Environment.PageNumber,    swapUnitCount: Environment.PageCount, state: SwapUnitState] =    BEGIN    -- See layout in DisplaySwapUnitTable.    IF run.interval.page # d.pageSwapUnitParentLastPrinted THEN {      DisplayRun[run];      d.pageSwapUnitParentLastPrinted ¬ run.interval.page};    Put.LongNumber[d.fileSW, swapUnitPage, Width[9]];    Put.LongNumber[d.fileSW, swapUnitCount, Width[6]];    Put.Text[      d.fileSW, IF state.availability = available THEN " avail"L ELSE "  busy"L];    Put.Text[d.fileSW, IF state.st.access = readOnly THEN "  read"L ELSE " write"L];    Put.Text[      d.fileSW, IF state.st.swappability = swappable THEN " swaps"L ELSE " pin'd"L];    Put.Text[d.fileSW, IF state.st.life = alive THEN " alive"L ELSE "  dead"L];    Put.CR[d.fileSW];    d.pageSwapUnitCur ¬ swapUnitPage;    d.countSwapUnitCur ¬ swapUnitCount;    END;  --DisplaySwapUnit--  --=======================================================  -- Display Pages routines:  --=======================================================  DisplayPages: PROCEDURE =    BEGIN    DisplayPagesOne: SwapUnitProcessor  --      --[run, swapUnitPage, swapUnitCount, state] RETURNS [quitNow]--  =      BEGIN      DisplaySwapUnit[run, swapUnitPage, swapUnitCount, state];      DisplayPagesOfSwapUnit[swapUnitPage, swapUnitCount, state];      RETURN[quitNow: FALSE];      END;    PrintRunTitle[];    PrintSwapUnitTitle[];    PrintPagesTitle[];    InitializeSwapUnitTable[];    EnumerateSwapUnitTable[DisplayPagesOne];    END;  DisplayPagesItems: PROCEDURE [] =    BEGIN    page: Environment.PageNumber;    itemsProcessed: CARDINAL ¬ 0;    DisplayPagesItemsOne: SwapUnitProcessor  --      --[run, swapUnitPage, swapUnitCount, state] RETURNS [quitNow]--  =      BEGIN      IF swapUnitPage + swapUnitCount <= page THEN RETURN[quitNow: FALSE];      IF swapUnitPage > page AND itemsProcessed = 0 THEN {	Put.Text[d.fileSW, "page "L];	Put.LongDecimal[d.fileSW, page];	Put.Line[d.fileSW, " is not mapped."L]};      DisplaySwapUnit[run, swapUnitPage, swapUnitCount, state];      DisplayPagesOfSwapUnit[swapUnitPage, swapUnitCount, state];      itemsProcessed ¬ itemsProcessed + CARDINAL[swapUnitCount];      RETURN[quitNow: itemsProcessed >= d.count];      END;    PrintRunTitle[];    PrintSwapUnitTitle[];    PrintPagesTitle[];    InitializeSwapUnitTable[];    page ¬ PageFromStartKey[d.startKey];    EnumerateSwapUnitTable[DisplayPagesItemsOne];    IF itemsProcessed = 0 THEN {      Put.Text[d.fileSW, "Page"L];      Put.LongDecimal[d.fileSW, page];      Put.Line[d.fileSW, " is not mapped."L]};    END;  DisplayPagesNext: PROCEDURE = {    Put.Line[d.fileSW, "not implemented."L]};  DisplayPagesPrev: PROCEDURE = {    Put.Line[d.fileSW, "not implemented."L]};  PrintPagesTitle: PROCEDURE =    BEGIN    hdrA: STRING ¬  --      "       page count  --flags--    real"L;    --       ppppp ccccc dirty unrefd rrrrr"L;  (or)    --       ppppp ccccc    vacant"L;    -- 01234567890123456789012345678901234567890    Put.Line[d.fileSW, hdrA];    END;  DisplayPagesOfSwapUnit: PROCEDURE [    swapUnitPage: Environment.PageNumber,    swapUnitCount: Environment.PageCount, state: SwapUnitState] =    BEGIN    pageAllSame: Environment.PageNumber ¬ Environment.PageNumber.LAST;    countAllSame: Environment.PageCount ¬ 0;    swapStateAllSame: DUD2.SwapState;    accessAllSame: Space.Access;    flagsAllSame: PageMap.Flags;    realAllSame: PageMap.RealPageNumber;  -- for consistency in style.    FOR page: Environment.PageNumber IN [      swapUnitPage..swapUnitPage + swapUnitCount) DO      swapState: DUD2.SwapState;      access: Space.Access;      flags: PageMap.Flags;      real: PageMap.RealPageNumber;      [swapState, access, flags, real] ¬ DUD2.GetPageState[page];      IF countAllSame = 0 OR (  -- uninit warnings ok	countAllSame > 0 AND swapState = swapStateAllSame AND	access = accessAllSame AND flags = flagsAllSame AND	real = realAllSame) THEN	BEGIN  --start or continue run--	-- Accumulate run of all same pages:	pageAllSame ¬ MIN[pageAllSame, page];	END      ELSE	BEGIN  --prev run terminated by new run--	DisplayPageRun[	  pageAllSame, countAllSame, state, swapStateAllSame, accessAllSame, flagsAllSame, realAllSame];	pageAllSame ¬ page;	countAllSame ¬ 0;	END;      countAllSame ¬ countAllSame.SUCC;      swapStateAllSame ¬ swapState;      accessAllSame ¬ access;      flagsAllSame ¬ flags;      realAllSame ¬ real;      ENDLOOP;    DisplayPageRun[      pageAllSame, countAllSame, state, swapStateAllSame, accessAllSame, flagsAllSame, realAllSame];    END;  DisplayPageRun: PROCEDURE [    page: Environment.PageNumber, count: Environment.PageCount,    state: SwapUnitState, swapState: DUD2.SwapState,    access: Space.Access, flags: PageMap.Flags, real: PageMap.RealPageNumber] =    BEGIN    -- d.verbose controls display of real page    -- See layout in PrintPagesTitle.    Put.LongNumber[d.fileSW, page, Width[11]];    Put.LongNumber[d.fileSW, count, Width[6]];    IF flags = PageMap.flagsVacant THEN      Put.Text[d.fileSW, "   vacant"L]    ELSE      BEGIN      Put.Text[	d.fileSW, IF flags.dirty THEN " dirty"L ELSE " clean"L];      Put.Text[d.fileSW, IF flags.referenced THEN "  ref'd"L ELSE " unrefd"L];      IF state.availability = available THEN	IF (access = readOnly) # flags.readonly THEN	  Put.Text[d.fileSW, "  readOnly flag is WRONG!"L];      END;    IF state.availability = available AND swapState = in AND      access # state.st.access THEN      Put.Text[d.fileSW, " CONFUSED about Access!!"L];    SELECT swapState FROM      in =>	BEGIN	IF flags = PageMap.flagsVacant THEN	  Put.Text[d.fileSW, " CONFUSED about swap status!"L];	END;      out, unmapped =>	BEGIN	IF flags # PageMap.flagsVacant THEN	  Put.Text[d.fileSW, " CONFUSED about swap status!"L];	IF state.availability = available AND	  state.st.swappability = resident THEN	  Put.Text[d.fileSW, " CONFUSED about swappability!"L];	END;      ENDCASE => Trouble[];    IF d.verbose THEN {      IF flags # PageMap.flagsVacant THEN      Put.LongNumber[d.fileSW, real, Width[6]];      };    Put.CR[d.fileSW];    END;  --=======================================================  -- Display State Vector Pool routine:  --=======================================================  DisplayStateVectors: PROCEDURE =    BEGIN    stateAllocationTable: PSB.StateAllocationTable;    nState: CARDINAL;    DUD.LongCopyREAD[      from: @PSB.PDA.state, to: @stateAllocationTable,      nwords: SIZE[PSB.StateAllocationTable]];    Put.Line[d.fileSW, "priority nStateVectors"L];    FOR pri: PSB.Priority IN PSB.Priority DO      nState ¬ 0;      FOR rState: PSB.StateVectorHandle ¬ stateAllocationTable[pri], DUD.LongREAD[	@PSB.PDA[rState]] WHILE rState ~= PSB.NullStateVectorHandle DO	nState ¬ SUCC[nState] ENDLOOP;      Put.Number[d.fileSW, pri, Width[5]];      Put.Number[d.fileSW, nState, Width[8]];      Put.CR[d.fileSW];      ENDLOOP;    END;  --=======================================================  -- Utility routines:  --=======================================================  Order: PROC [lp: LONG POINTER] RETURNS [LONG ORDERED POINTER] = {    RETURN[LOOPHOLE[lp]]};  PageFromStartKey: PROCEDURE [key: LONG CARDINAL]    RETURNS [page: Environment.PageNumber] =    -- ASSUMES run table data has already been initialized!    BEGIN    SELECT d.keyType FROM      address => {page ¬ Environment.PageFromLongPointer[LOOPHOLE[key]]};      page => page ¬ key;      runPtr =>	BEGIN	lpRun: LONG ORDERED POINTER = LOOPHOLE[key];	IF lpRun NOT IN	  [Order[@d.runBase[pRunFirst]]..Order[@d.runBase[d.pRunTop]]) THEN	  BEGIN	  PostErrorString[	    "Run long pointer does not point into run table!"L,	    startsLine, endsLine];	  SIGNAL AbortThyself;	  END	ELSE	  BEGIN	  run: Run;	  DUD.LongCopyREAD[from: lpRun, to: @run, nwords: SIZE[Run]];	  page ¬ run.interval.page;	  END;	END;      runRelPtr =>	BEGIN	IF key >= LOOPHOLE[d.pRunTop, CARDINAL] THEN	  BEGIN	  PostErrorString[	    "Run relative pointer past end of run table!"L,	    startsLine, endsLine];	  SIGNAL AbortThyself;	  END	ELSE	  BEGIN	  pRun: PRun = LOOPHOLE[CARDINAL[key]];	  IF LOOPHOLE[pRun, CARDINAL] MOD SIZE[Run] # 0 THEN	    BEGIN	    PostErrorString[	      "Run relative pointer doesn't point to Run boundary!"L,	      startsLine, endsLine];	    SIGNAL AbortThyself;	    END	  ELSE	    BEGIN	    run: Run;	    DUD.LongCopyREAD[	      from: @d.runBase[pRun], to: @run, nwords: SIZE[Run]];	    page ¬ run.interval.page;	    END;	  END;	END;      ENDCASE => Trouble[];    END;  -- MAIN:  Initialize[];  END.LOG25-Jun-81 10:25:35   WDK        NewSession while inactive caused address fault. Implement menu routines.  Put date in header. 8-Nov-82  9:50:24   WDK         Redid all of internals for Klamath data structures, retaining only control structure of previous version. 3-Jan-83 18:18:27   WDK        Converted to Sierra.21-Apr-83 15:55:35   WDK        Page from long pointer truncated.27-Apr-83 13:00:28   WDK        Added facility to check reserved memory.16-Jun-83 10:35:01   WDK        Convert to run on Klamath.14-Sep-83 16:06:18   AWL         Convert to run on Klamath 11.0b.26-Jun-84 22:16:03   KEK        Add code that sees Run.maybePartlyIn.31-Aug-84 12:22:31   KEK        add check-pc-memory facility.  add nicer unloading stuff.11-Mar-87 13:29:37   RSV        Convert to MDS relief and Sword.11-Mar-87 16:45:36   RSV/AHL    More MDS relief edits.21-Oct-87 16:31:27   WDK   Add display of real pages. Print headings on Display Table Items commands, too.   Bug fix: Access check now ignores access of vacant pages.
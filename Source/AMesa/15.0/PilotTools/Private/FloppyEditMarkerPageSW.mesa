-- Copyright (C) 1984, 1985  by Xerox Corporation. All rights reserved. -- FloppyEditMarkerPageSW.mesa	last edited by: CAJ	 7-May-85 13:31:50-- This module implements an alternate view for the data display subwindow of the floppy disk editor.DIRECTORY  File USING [Type],  Floppy USING [FileID, PageCount],  FloppyEditInternal USING [data, heap, Msg, swapWindowKey],  FloppyEditUtilities USING [ReplaceFileID, ReplaceFileIDString],  FloppyFormat USING [MarkerPage, MarkerPageEntry, MarkerPageEntryType],  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, CommandItem, DisplayItem,    Enumerated, EnumeratedItem, EnumeratedNotifyProcType, FilterProcType,    FindItem, ItemHandle, line0, line1, line2, line3, line4, line5, line6, line7,    line8, line9, LineN, NumberItem, NumberNotifyProcType, ProcType,    StringEditProc, TagOnlyItem, ToggleVisibility, StringItem],  MsgSW USING [Clear],  RuntimeInternal USING [Bug],  String USING [Replace],  Window USING [Handle],  WindowSwap USING [CurrentViewHandle, RegisterView];FloppyEditMarkerPageSW: PROGRAM  IMPORTS    FloppyEditInternal, FloppyEditUtilities, FormSW, MsgSW, RuntimeInternal,    String, WindowSwap =  BEGIN  --//////////////////  -- Local TYPEs, constants, and variables  EntryData: TYPE = LONG POINTER TO EntryDataObject;  EntryDataObject: TYPE = RECORD [    variant: FloppyFormat.MarkerPageEntryType,    id: Floppy.FileID,    idString: LONG STRING,    type: File.Type,    padIndex: CARDINAL,    padValue: CARDINAL];  FormItems: TYPE = {    markerPage, seal, version, previous, lengthP, bodyVariantTypeP, fileIDP,    padIndexP, padValueP, fileTypeP, nextP, backP, next, lengthN,    bodyVariantTypeN, fileIDN, padIndexN, padValueN, fileTypeN, nextN, backN};  formModified: BOOLEAN ¬ FALSE;  markerPage: LONG POINTER TO FloppyFormat.MarkerPage ¬    LOOPHOLE[FloppyEditInternal.data.sectorBuffer];  nextData: EntryData ¬ NIL;  prevData: EntryData ¬ NIL;  undefinedVariant: FloppyFormat.MarkerPageEntryType = LAST[    FloppyFormat.MarkerPageEntryType];  --//////////////////  -- Errors  BugType: TYPE = {indexOutOfBounds, noData, noMarkerPage};  Bug: PROCEDURE [bug: BugType] = {RuntimeInternal.Bug[bug]};  --//////////////////  -- Procedures  BackNext: FormSW.ProcType =    BEGIN    MsgSW.Clear[FloppyEditInternal.data.msgSW];    nextData.padIndex ¬      IF nextData.padIndex = 0 THEN MaxPadIndex[@markerPage.next]      ELSE nextData.padIndex - 1;    GetPadValue[mpEntry: @markerPage.next, data: nextData];    FormSW.DisplayItem[sw, FormItems.padIndexN.ORD];    FormSW.DisplayItem[sw, FormItems.padValueN.ORD];    END;  -- BackNext  BackPrevious: FormSW.ProcType =    BEGIN    MsgSW.Clear[FloppyEditInternal.data.msgSW];    prevData.padIndex ¬      IF prevData.padIndex = 0 THEN MaxPadIndex[@markerPage.previous]      ELSE prevData.padIndex - 1;    GetPadValue[mpEntry: @markerPage.previous, data: prevData];    FormSW.DisplayItem[sw, FormItems.padIndexP.ORD];    FormSW.DisplayItem[sw, FormItems.padValueP.ORD];    END;  -- BackPrevious  ChangeFileType: FormSW.NumberNotifyProcType =    -- [sw: Window.Handle, item: FormSW.ItemHandle, index: CARDINAL,    -- oldValue: UNSPECIFIED]    BEGIN formModified ¬ TRUE; END;  -- ChangeFileType  ChangeNextFileID: FormSW.FilterProcType =    --[sw: Window.Handle, item: FormSW.ItemHandle, insert: CARDINAL,    -- string: LONG STRING]    BEGIN    FormSW.StringEditProc[sw, item, insert, string];    FloppyEditUtilities.ReplaceFileID[@nextData.idString, @nextData.id];    formModified ¬ TRUE;    END;  -- ChangeNextFileID  ChangeNextPadIndex: FormSW.NumberNotifyProcType =    -- [sw: Window.Handle, item: FormSW.ItemHandle, index: CARDINAL,    -- oldValue: UNSPECIFIED]    BEGIN    -- Ensure index value cannot be set out of bounds so users needn't check.    IF nextData.padIndex IN [0..MaxPadIndex[@markerPage.next]] THEN      BEGIN      GetPadValue[@markerPage.next, nextData];      FormSW.DisplayItem[sw, FormItems.padValueN.ORD];      END    ELSE      BEGIN      nextData.padIndex ¬ oldValue;      FloppyEditInternal.Msg["Index out of bounds", TRUE];      FormSW.DisplayItem[sw, FormItems.padIndexN.ORD];      END;    END;  --ChangeNextPadIndex  ChangeNextPadValue: FormSW.NumberNotifyProcType =    -- [sw: Window.Handle, item: FormSW.ItemHandle, index: CARDINAL,    -- oldValue: UNSPECIFIED]    BEGIN    -- called when pad value field is changed    IF nextData.padIndex IN [0..MaxPadIndex[@markerPage.next]] THEN      SetPadValue[mpEntry: @markerPage.next, data: nextData]    ELSE Bug[indexOutOfBounds];  -- shouldn't be able to set to bad value    formModified ¬ TRUE;    END;  -- ChangeNextPadValue  ChangeNextVariant: FormSW.EnumeratedNotifyProcType =    --[sw: Window.Handle, item: FormsSW.ItemHandle, index: CARDINAL,    -- oldValue: UNSPECIFIED]    BEGIN    IF oldValue = nextData.variant THEN RETURN;    RewriteEntry[@markerPage.next, nextData];    formModified ¬ TRUE;    IF nextData.padIndex > MaxPadIndex[@markerPage.next] THEN      nextData.padIndex ¬ 0;    IF FillEntryData[mpEntry: @markerPage.next, data: nextData].itemsInvisible ~=        FormSW.FindItem[sw, FormItems.fileIDN.ORD].flags.invisible THEN      BEGIN      FormSW.ToggleVisibility[sw: sw, index: FormItems.fileIDN.ORD];      FormSW.ToggleVisibility[sw: sw, index: FormItems.fileTypeN.ORD];      END;    FormSW.DisplayItem[sw, FormItems.fileIDN.ORD];    FormSW.DisplayItem[sw, FormItems.fileTypeN.ORD];    FormSW.DisplayItem[sw, FormItems.padIndexN.ORD];    FormSW.DisplayItem[sw, FormItems.padValueN.ORD];    END;  -- ChangeNextVariant  ChangePreviousFileID: FormSW.FilterProcType =    --[sw: Window.Handle, item: FormSW.ItemHandle, insert: CARDINAL,    -- string: LONG STRING]    BEGIN    FormSW.StringEditProc[sw, item, insert, string];    FloppyEditUtilities.ReplaceFileID[@prevData.idString, @prevData.id];    formModified ¬ TRUE;    END;  -- ChangePreviousFileID  ChangePreviousPadIndex: FormSW.NumberNotifyProcType =    -- [sw: Window.Handle, item: FormSW.ItemHandle, index: CARDINAL,    -- oldValue: UNSPECIFIED]    BEGIN    -- Ensure index value cannot be set out of bounds so users needn't check.    IF prevData.padIndex IN [0..MaxPadIndex[@markerPage.previous]] THEN      BEGIN      GetPadValue[@markerPage.previous, prevData];      FormSW.DisplayItem[sw, FormItems.padValueP.ORD];      END    ELSE      BEGIN      prevData.padIndex ¬ oldValue;      FloppyEditInternal.Msg["Index out of bounds", TRUE];      FormSW.DisplayItem[sw, FormItems.padIndexP.ORD];      END;    END;  --ChangePreviousPadIndex  ChangePreviousPadValue: FormSW.NumberNotifyProcType =    -- [sw: Window.Handle, item: FormSW.ItemHandle, index: CARDINAL,    -- oldValue: UNSPECIFIED]    BEGIN    -- called when pad value field is changed    IF prevData.padIndex IN [0..MaxPadIndex[@markerPage.previous]] THEN      SetPadValue[mpEntry: @markerPage.previous, data: prevData]    ELSE Bug[indexOutOfBounds];  -- shouldn't be able to set to bad value    formModified ¬ TRUE;    END;  -- ChangePreviousPadValue  ChangePreviousVariant: FormSW.EnumeratedNotifyProcType =    --[sw: Window.Handle, item: FormsSW.ItemHandle, index: CARDINAL,    -- oldValue: UNSPECIFIED]    BEGIN    IF oldValue = prevData.variant THEN RETURN;    RewriteEntry[@markerPage.previous, prevData];    formModified ¬ TRUE;    IF prevData.padIndex > MaxPadIndex[@markerPage.previous] THEN      prevData.padIndex ¬ 0;    IF FillEntryData[mpEntry: @markerPage.previous, data: prevData].itemsInvisible        ~= FormSW.FindItem[sw, FormItems.fileIDP.ORD].flags.invisible THEN      BEGIN      FormSW.ToggleVisibility[sw: sw, index: FormItems.fileIDP.ORD];      FormSW.ToggleVisibility[sw: sw, index: FormItems.fileTypeP.ORD];      END;    FormSW.DisplayItem[sw, FormItems.fileIDP.ORD];    FormSW.DisplayItem[sw, FormItems.fileTypeP.ORD];    FormSW.DisplayItem[sw, FormItems.padIndexP.ORD];    FormSW.DisplayItem[sw, FormItems.padValueP.ORD];    END;  -- ChangePreviousVariant  CleanupMarkerPageSW: PROCEDURE =    -- Make data buffer match display.    BEGIN    -- The seal, version, and the length fields of the previous and next    -- MarkerPageEntry records are all maintained in place.  Only the variant    -- record part must be updated from local data.    IF formModified THEN      BEGIN      RewriteEntry[pEntry: @markerPage.previous, data: prevData];      RewriteEntry[pEntry: @markerPage.next, data: nextData];      END;    END;  -- CleanupMarkerPageSW  DestroyMarkerPageSW: PROCEDURE =    -- Give back storage when going away for good.    BEGIN    String.Replace[@prevData.idString, NIL, FloppyEditInternal.heap];    String.Replace[@nextData.idString, NIL, FloppyEditInternal.heap];    FloppyEditInternal.heap.FREE[@prevData];    FloppyEditInternal.heap.FREE[@nextData];    prevData ¬ NIL;    nextData ¬ NIL;    END;  FillEntryData: PROCEDURE [    mpEntry: LONG POINTER TO FloppyFormat.MarkerPageEntry, data: EntryData]    RETURNS [itemsInvisible: BOOLEAN] =    BEGIN    pFile: LONG POINTER TO file FloppyFormat.MarkerPageEntry = LOOPHOLE[mpEntry];    WITH mp: mpEntry SELECT FROM      free =>        BEGIN        data.id ¬ pFile.file;  -- fake it        data.type ¬ pFile.type;        data.padValue ¬ mp.pad[data.padIndex];        itemsInvisible ¬ TRUE;        END;      file =>        BEGIN        data.id ¬ mp.file;        data.type ¬ mp.type;        data.padValue ¬ mp.pad[data.padIndex];        FloppyEditUtilities.ReplaceFileIDString[@data.idString, data.id];        itemsInvisible ¬ FALSE;        END;      fileList =>        BEGIN        data.id ¬ mp.file;        data.type ¬ mp.type;        data.padValue ¬ mp.pad[data.padIndex];        FloppyEditUtilities.ReplaceFileIDString[@data.idString, data.id];        itemsInvisible ¬ FALSE;        END;      badSectors =>        BEGIN        data.id ¬ pFile.file;  -- fake it        data.type ¬ pFile.type;        data.padValue ¬ mp.pad[data.padIndex];        itemsInvisible ¬ TRUE;        END;      ENDCASE =>        BEGIN        data.variant ¬ undefinedVariant;        data.id ¬ pFile.file;  -- fake it        data.type ¬ pFile.type;        data.padValue ¬ LOOPHOLE[mp, free FloppyFormat.MarkerPageEntry].pad[          data.padIndex];        itemsInvisible ¬ TRUE;        END;    END;  -- FillEntryData  FillMarkerPageSW: PROCEDURE =    -- Make display match data buffer.    BEGIN    nInvisible: BOOLEAN;    pInvisible: BOOLEAN;    sw: Window.Handle;    IF markerPage = NIL THEN Bug[noMarkerPage];    IF (prevData = NIL) OR (nextData = NIL) THEN Bug[noData];    sw ¬ WindowSwap.CurrentViewHandle[FloppyEditInternal.swapWindowKey];    prevData.variant ¬ markerPage.previous.type;    prevData.padIndex ¬ 0;    pInvisible ¬      FillEntryData[mpEntry: @markerPage.previous, data: prevData].itemsInvisible;    nextData.variant ¬ markerPage.next.type;    nextData.padIndex ¬ 0;    nInvisible ¬      FillEntryData[mpEntry: @markerPage.next, data: nextData].itemsInvisible;    formModified ¬ FALSE;    IF pInvisible ~=        FormSW.FindItem[sw, FormItems.fileIDP.ORD].flags.invisible THEN      BEGIN  -- Flip file ID and type visibility      FormSW.ToggleVisibility[sw: sw, index: FormItems.fileIDP.ORD];      FormSW.ToggleVisibility[sw: sw, index: FormItems.fileTypeP.ORD];      END;    IF nInvisible ~=        FormSW.FindItem[sw, FormItems.fileIDN.ORD].flags.invisible THEN      BEGIN  -- Flip file ID and type visibility      FormSW.ToggleVisibility[sw: sw, index: FormItems.fileIDN.ORD];      FormSW.ToggleVisibility[sw: sw, index: FormItems.fileTypeN.ORD];      END;    END;  -- FillMarkerPageSW  GetPadValue: PROCEDURE [    mpEntry: LONG POINTER TO FloppyFormat.MarkerPageEntry, data: EntryData] =    BEGIN    WITH mp: mpEntry­ SELECT FROM      free => data.padValue ¬ mp.pad[data.padIndex];      file => data.padValue ¬ mp.pad[data.padIndex];      fileList => data.padValue ¬ mp.pad[data.padIndex];      fileList => data.padValue ¬ mp.pad[data.padIndex];      badSectors => data.padValue ¬ mp.pad[data.padIndex];      ENDCASE =>        data.padValue ¬ LOOPHOLE[mp, free FloppyFormat.MarkerPageEntry].pad[          data.padIndex];    END;  -- GetPadValue  MakeMarkerPageSW: PUBLIC FormSW.ClientItemsProcType =    BEGIN OPEN FSW: FormSW;    nItems: CARDINAL = FormItems.LAST.ORD + 1;    variantTypes: ARRAY [0..5) OF FSW.Enumerated ¬ [      ["free"L, FloppyFormat.MarkerPageEntryType[free]], [      "file"L, FloppyFormat.MarkerPageEntryType[file]], [      "fileList"L, FloppyFormat.MarkerPageEntryType[fileList]], [      "badSectors"L, FloppyFormat.MarkerPageEntryType[badSectors]], [      "(undefined)"L, undefinedVariant]];    markerPage ¬ LOOPHOLE[FloppyEditInternal.data.sectorBuffer];    prevData ¬ FloppyEditInternal.heap.NEW[EntryDataObject];    nextData ¬ FloppyEditInternal.heap.NEW[EntryDataObject];    prevData.idString ¬ NIL;    nextData.idString ¬ NIL;    items ¬ FSW.AllocateItemDescriptor[nItems];    items[FormItems.markerPage.ORD] ¬ FSW.TagOnlyItem[      tag: "MarkerPage"L, place: [3, FSW.line0]];    items[FormItems.seal.ORD] ¬ FSW.NumberItem[      tag: "seal "L, place: [125, FSW.line0], signed: FALSE, notNegative: TRUE,      radix: octal, default: 177777B, value: @markerPage.seal];    items[FormItems.version.ORD] ¬ FSW.NumberItem[      tag: "version  "L, place: [235, FSW.line0], signed: FALSE,      notNegative: TRUE, radix: octal, default: 177777B,      value: @markerPage.version];    items[FormItems.previous.ORD] ¬ FSW.TagOnlyItem[      tag: "previous MarkerPageEntry"L, place: [16, FSW.line1]];    items[FormItems.lengthP.ORD] ¬ FSW.NumberItem[      tag: "length "L, place: [31, FSW.line2], signed: FALSE, notNegative: TRUE,      radix: octal, default: 177777B, value: @markerPage.previous.length];    items[FormItems.bodyVariantTypeP.ORD] ¬ FSW.EnumeratedItem[      tag: "MarkerPageEntryType"L, place: [31, FSW.line3], feedback: all,      choices: DESCRIPTOR[variantTypes], value: @prevData.variant,      proc: ChangePreviousVariant];    items[FormItems.fileIDP.ORD] ¬ FSW.StringItem[      tag: "file ID"L, place: [50, FSW.line4], inHeap: FALSE,      string: @prevData.idString, filterProc: ChangePreviousFileID];    items[FormItems.padIndexP.ORD] ¬ FSW.NumberItem[      tag: "pad index "L, place: [200, FSW.line4], signed: FALSE,      notNegative: TRUE, radix: octal, default: 0, value: @prevData.padIndex,      proc: ChangePreviousPadIndex];    items[FormItems.padValueP.ORD] ¬ FSW.NumberItem[      tag: "value "L, place: [345, FSW.line4], signed: FALSE, notNegative: TRUE,      radix: octal, default: 0, value: @prevData.padValue,      proc: ChangePreviousPadValue];    items[FormItems.fileTypeP.ORD] ¬ FSW.NumberItem[      tag: "file type"L, place: [50, FSW.line5], signed: FALSE, notNegative: TRUE,      radix: octal, default: 177777B, value: @prevData.type,      proc: ChangeFileType];    items[FormItems.nextP.ORD] ¬ FSW.CommandItem[      tag: "Next"L, place: [200, FSW.line5], proc: NextPrevious];    items[FormItems.backP.ORD] ¬ FSW.CommandItem[      tag: "Back"L, place: [260, FSW.line5], proc: BackPrevious];    items[FormItems.next.ORD] ¬ FSW.TagOnlyItem[      tag: "next MarkerPageEntry"L, place: [16, FSW.line6]];    items[FormItems.lengthN.ORD] ¬ FSW.NumberItem[      tag: "length "L, place: [31, FSW.line7], signed: FALSE, notNegative: TRUE,      radix: octal, default: 177777B, value: @markerPage.next.length];    items[FormItems.bodyVariantTypeN.ORD] ¬ FSW.EnumeratedItem[      tag: "MarkerPageEntryType"L, place: [31, FSW.line8], feedback: all,      choices: DESCRIPTOR[variantTypes], proc: ChangeNextVariant,      value: @nextData.variant];    items[FormItems.fileIDN.ORD] ¬ FSW.StringItem[      tag: "file ID"L, place: [50, FSW.line9], inHeap: FALSE,      string: @nextData.idString, filterProc: ChangeNextFileID];    items[FormItems.padIndexN.ORD] ¬ FSW.NumberItem[      tag: "pad index "L, place: [200, FSW.line9], signed: FALSE,      notNegative: TRUE, radix: octal, default: 0, value: @nextData.padIndex,      proc: ChangeNextPadIndex];    items[FormItems.padValueN.ORD] ¬ FSW.NumberItem[      tag: "value "L, place: [345, FSW.line9], signed: FALSE, notNegative: TRUE,      radix: octal, default: 0, value: @nextData.padValue,      proc: ChangeNextPadValue];    items[FormItems.fileTypeN.ORD] ¬ FSW.NumberItem[      tag: "file type"L, place: [50, FSW.LineN[10]], signed: FALSE,      notNegative: TRUE, radix: octal, default: 177777B, value: @nextData.type,      proc: ChangeFileType];    items[FormItems.nextN.ORD] ¬ FSW.CommandItem[      tag: "Next"L, place: [200, FSW.LineN[10]], proc: NextNext];    items[FormItems.backN.ORD] ¬ FSW.CommandItem[      tag: "Back"L, place: [260, FSW.LineN[10]], proc: BackNext];    RETURN[items, TRUE]    END;  -- MakeMarkerPageSW  MaxPadIndex: PROCEDURE [mpEntry: LONG POINTER TO FloppyFormat.MarkerPageEntry]    RETURNS [i: CARDINAL] =    BEGIN    WITH mp: mpEntry SELECT FROM      free => i ¬ LENGTH[mp.pad] - 1;      file => i ¬ LENGTH[mp.pad] - 1;      fileList => i ¬ LENGTH[mp.pad] - 1;      badSectors => i ¬ LENGTH[mp.pad] - 1;      ENDCASE =>        i ¬ LENGTH[LOOPHOLE[mp, free FloppyFormat.MarkerPageEntry].pad] - 1;    END;  -- MaxPadIndex  NextNext: FormSW.ProcType =    BEGIN    MsgSW.Clear[FloppyEditInternal.data.msgSW];    nextData.padIndex ¬      (nextData.padIndex + 1) MOD (MaxPadIndex[@markerPage.next] + 1);    GetPadValue[mpEntry: @markerPage.next, data: nextData];    FormSW.DisplayItem[sw, FormItems.padIndexN.ORD];    FormSW.DisplayItem[sw, FormItems.padValueN.ORD];    END;  -- NextNext  NextPrevious: FormSW.ProcType =    BEGIN    MsgSW.Clear[FloppyEditInternal.data.msgSW];    prevData.padIndex ¬      (prevData.padIndex + 1) MOD (MaxPadIndex[@markerPage.previous] + 1);    GetPadValue[mpEntry: @markerPage.previous, data: prevData];    FormSW.DisplayItem[sw, FormItems.padIndexP.ORD];    FormSW.DisplayItem[sw, FormItems.padValueP.ORD];    END;  -- NextPrevious  RewriteEntry: PROCEDURE [    pEntry: LONG POINTER TO FloppyFormat.MarkerPageEntry, data: EntryData] =    BEGIN    -- This rewrites the body portion of the MarkerPageEntry specified.  If the    -- variant value in data differs from the variant type of the current entry,    -- rewriting will change the variant.    pFree: LONG POINTER TO free FloppyFormat.MarkerPageEntry = LOOPHOLE[pEntry];    pFile: LONG POINTER TO file FloppyFormat.MarkerPageEntry = LOOPHOLE[pEntry];    pFileList: LONG POINTER TO fileList FloppyFormat.MarkerPageEntry =      LOOPHOLE[pEntry];    pBadSectors: LONG POINTER TO badSectors FloppyFormat.MarkerPageEntry =      LOOPHOLE[pEntry];    MsgSW.Clear[FloppyEditInternal.data.msgSW];    SELECT data.variant FROM      free => pEntry.body ¬ free[pFree.pad];      file => pEntry.body ¬ file[data.id, data.type, pFile.pad];      fileList => pEntry.body ¬ fileList[data.id, data.type, pFileList.pad];      badSectors => pEntry.body ¬ badSectors[pBadSectors.pad];      ENDCASE =>        BEGIN        -- Kludge up a FloppyFormat.MarkerPageEntry in which tag word is bogus        tagOffset: CARDINAL = 2;  -- offset into MarkerPageEntry of variant tag        zz: LONG POINTER TO ARRAY [0..SIZE[FloppyFormat.MarkerPageEntry]) OF          WORD ¬ LOOPHOLE[pEntry];        tag: WORD ¬ zz[tagOffset];        pEntry.body ¬ free[pFree.pad];        zz[tagOffset] ¬ tag;        END;    END;  -- RewriteVariant  SetPadValue: PROCEDURE [    mpEntry: LONG POINTER TO FloppyFormat.MarkerPageEntry, data: EntryData] =    BEGIN    WITH mp: mpEntry­ SELECT FROM      free => mp.pad[data.padIndex] ¬ data.padValue;      file => mp.pad[data.padIndex] ¬ data.padValue;      fileList => mp.pad[data.padIndex] ¬ data.padValue;      fileList => mp.pad[data.padIndex] ¬ data.padValue;      badSectors => mp.pad[data.padIndex] ¬ data.padValue;      ENDCASE =>        LOOPHOLE[mp, free FloppyFormat.MarkerPageEntry].pad[data.padIndex] ¬          data.padValue;    END;  -- Module initialization:  -- Register this subwindow as an alternate view for the data subwindow  WindowSwap.RegisterView[    key: FloppyEditInternal.swapWindowKey, viewName: "MarkerPage"L,    makeFormSW: MakeMarkerPageSW, viewFromDataProc: FillMarkerPageSW,    dataFromViewProc: CleanupMarkerPageSW, destroyViewProc: DestroyMarkerPageSW];  END.LOG25-Sep-84 16:45:27   CAJ	Created file. 7-May-85 13:31:43   CAJ	Added DestroyMarkerPageSW, use default heap in MakeForm.
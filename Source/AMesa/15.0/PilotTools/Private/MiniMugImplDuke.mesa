-- File: MiniMugImplDuke.mesa - last edit:-- Kondoh:IWA:Fuji Xerox       26-Apr-89 11:00 JST-- Copyright (C) 1988, 1989 by Fuji Xerox Co., Ltd, Tokyo, Japan. All rights reserved.DIRECTORY  Ascii		   USING [CR, SP],  Command	   USING [Aborted, Action, Confirm, Entry, InstallTopLevel,     QuitLevel, Scan],  Device,  DeviceTypes,  DiskIOFaceDuke   USING [longWrite],  File		   USING [nullFile],  Environment      USING [Base, first64K, PageCount, wordsPerPage],  Inline           USING [LowHalf],  PilotCommand     USING [defaultWindow, StorageCatch], << PilotDisk        USING [Label],>>  PilotDiskFace,  ResidentHeap     USING [MakeNode],  Space,  TTY		   USING [GetLongNumber, Handle, PutChar, PutLine, PutLongNumber,    PutString],  VM               USING [Interval, MakeResident, ReturnWait],  Zone             USING [Status];MiniMugImplDuke: PROGRAM  IMPORTS    Command, Inline, PilotCommand, PilotDiskFace, ResidentHeap,    Space, TTY, VM =  BEGIN    entries: ARRAY [0..4)  OF Command.Entry ¬ [    ["make Missing", MakeMissingCmd],    ["make Orphan", MakeOrphanCmd],    ["make Unreadable", MakeUnreadableCmd],    ["quit", Command.QuitLevel]];  h: TTY.Handle ¬ PilotCommand.defaultWindow;  PagePointer: TYPE = LONG POINTER TO Page;  Page: TYPE = ARRAY [0..256) OF WORD;  firstPage: Page ¬ ALL[0]; << labelRecord: MACHINE DEPENDENT RECORD [    label: PilotDisk.Label, fill: ARRAY [0..10) OF WORD ¬ ALL[0]];>>  space: Space.Interval = Space.Allocate[    count: 2, within: Space.virtualMemory, base: Space.defaultBase];  cyls, headsPerCyl, sectorsPerTrack: CARDINAL;  diskPages: LONG CARDINAL;  op: PilotDiskFace.OperationPtr    =@Environment.first64K[MakeNode[PilotDiskFace.operationSize]];  controller: PilotDiskFace.ControllerHandle    = PilotDiskFace.GetNextController[PilotDiskFace.nullControllerHandle];  device: PilotDiskFace.DeviceHandle    = PilotDiskFace.GetNextDevice[PilotDiskFace.nullDeviceHandle];  dT: Device.Type;          MakeMissingCmd: Command.Action =    { Run[makeMissing,    "Make Page Missing"L,   " missing."L] };      MakeOrphanCmd: Command.Action =    { Run[makeOrphan,     "Make Page Orphan"L,    " an orphan."L] };      MakeUnreadableCmd: Command.Action =    { Run[makeUnreadable, "Make Page Unreadable"L, " unreadable."L] };      MiniMugCmd: Command.Action =    BEGIN    TTY.PutChar[h, Ascii.SP];    Command.Scan[      h, DESCRIPTOR[entries], PilotCommand.StorageCatch];    END;        Run: PROC [function: Function, string, otherString: STRING]= {    page: LONG CARDINAL;    IF ~setup THEN Setup[];    TTY.PutString[h, "Disk page "L];    page ¬ TTY.GetLongNumber[h, LAST[LONG CARDINAL], 10, TRUE];    TTY.PutString[h, "About to permanently make RD0 disk page "L];    TTY.PutLongNumber[h, page, [8, FALSE, TRUE,5]];    TTY.PutString[h, "B"L];    TTY.PutLine[h, otherString];    Command.Confirm[h];    Perform[DiskAddressFromPage[page], function]};  Function: TYPE = {makeMissing, makeOrphan, makeUnreadable};      DiskAddressFromPage: PROC [p: LONG CARDINAL]    RETURNS [sa: PilotDiskFace.DiskAddress] = {    track: CARDINAL = Inline.LowHalf[p/sectorsPerTrack];    sa.cylinder ¬ track  /  headsPerCyl;    sa.head     ¬ track MOD headsPerCyl;    sa.sector   ¬ Inline.LowHalf[p MOD sectorsPerTrack]};      Perform: PROC [address: PilotDiskFace.DiskAddress, task: Function] =    BEGIN    status: PilotDiskFace.Status;    SELECT task FROM      makeMissing => {        TTY.PutString[h, "Unable to do that operation on a Duke"L];	RETURN};      makeOrphan => {        TTY.PutString[h, "Unable to do that operation on a Duke"L];	RETURN};      makeUnreadable => {        IF (status ¬ DoDiskIO[read, address, device])          # goodCompletion THEN {PrintStatus["read error: "L, status]; RETURN};	firstPage[1] ¬ 3;	(LOOPHOLE[space.pointer, PagePointer])­ ¬ firstPage;	status ¬ DoDiskIO[write, address, DiskIOFaceDuke.longWrite]};      ENDCASE => ERROR;  -- impossible command    PrintStatus["Corruption of page returns: "L, status];    END;    DoDiskIO: PROC [    cmd: PilotDiskFace.Command, address: PilotDiskFace.DiskAddress,    dH: PilotDiskFace.DeviceHandle]    RETURNS [status: PilotDiskFace.Status ¬ inProgress] =    BEGIN    opExtra: PilotDiskFace.OperationPtr;    op­ ¬ [      clientHeader:                address,      reserved1:  NIL, <<@LOOPHOLE[labelRecord.label, PilotDiskFace.Label],>>      dataPtr:                        space.pointer,      incrementDataPtr:              FALSE,      command:                         cmd,      tries:                           200,      pageCount:                         1,      deviceStatus:                   NULL,  -- set by Poll      diskHeader:                  [0,0,0],  -- not used by us      device:                          dH];    -- should lock out real driver somehow.    PilotDiskFace.Initiate[op];    WHILE status = inProgress DO      [status: status, op: opExtra] ¬ PilotDiskFace.Poll[controller];      ENDLOOP;   << labelRecord.label ¬ LOOPHOLE[opExtra.labelPtr­, PilotDisk.Label];>>    RETURN[status];    END;        PrintDriveInfo: PROC [    dT: Device.Type, cyls, headsPerCyl, sectorsPerTrack: CARDINAL] = {    types: ARRAY [0..13) OF RECORD [t: Device.Type, s: STRING] = [      [DeviceTypes.null,         "null"L],      [DeviceTypes.sa800,        "sa800"L],      [DeviceTypes.anyEthernet,  "anyEthernet"L],      [DeviceTypes.ethernet,     "ethernet"L],      [DeviceTypes.ethernetOne,  "ethernetOne"L],      [DeviceTypes.anyPilotDisk, "anyPilotDisk"L],      [DeviceTypes.sa1000,       "sa1000"L],      [DeviceTypes.sa1004,       "sa1004"L],      [DeviceTypes.sa4000,       "sa4000"L],      [DeviceTypes.sa4000,       "sa4008"L],      [DeviceTypes.t300,         "t300"L],      [DeviceTypes.t80,          "t80"L],      [DeviceTypes.cdc9730,      "cdc9730"L]];    FOR i: CARDINAL IN [0..LENGTH[types]) DO       IF types[i].t = dT THEN {        TTY.PutString[h, "Drive 0, type="L];	TTY.PutString[h, types[i].s]; EXIT};      REPEAT FINISHED => TTY.PutString[h,"Drive 0, type=unknown"L]      ENDLOOP;    TTY.PutString[h, ", cyls="L];    TTY.PutLongNumber[h, cyls, [8, FALSE, TRUE, 5]];    TTY.PutString[h, ", heads="L];    TTY.PutLongNumber[h, headsPerCyl, [8, FALSE, TRUE, 5]];    TTY.PutString[h, ", sectors="L];    TTY.PutLongNumber[h, sectorsPerTrack, [8, FALSE, TRUE, 5]];    TTY.PutChar[h, Ascii.CR]};        PrintStatus: PROC [s: STRING, status: PilotDiskFace.Status] = {    strings: ARRAY PilotDiskFace.Status OF STRING = [      inProgress:        "in Progress"L,      goodCompletion:    "successful"L,      notReady:          "not Ready"L,      recalibrateError:  "recalibrate Error"L,      seekTimeout:       "seek Timeout"L,      headerCRCError:    "header CRC Error"L,      reserved6:       "reserved6 Error"L,      dataCRCError:      "data CRC Error"L,      headerNotFound:    "header Not Found"L,      reserved9: 	"reserved9 Error"L,      dataVerifyError:   "data Verify Error"L,      overrunError:      "overrun Error"L,      writeFault:        "write Fault"L,      memoryError:       "memory Error"L,      memoryFault:       "memory Fault"L,      clientError:       "client Error"L,      operationReset:    "operation Reset"L,      otherError:        "other Error"L];    TTY.PutString[h, s]; TTY.PutLine[h, strings[status]]};            setup: BOOLEAN ¬ FALSE;  NoNode: ERROR = CODE;  MakeNode: PROC [size: CARDINAL] RETURNS [rp: Environment.Base RELATIVE POINTER] =    BEGIN    status: Zone.Status;    IF size=0 THEN RETURN[LOOPHOLE[0]];    [rp, status] ¬ ResidentHeap.MakeNode[n: size, alignment: a16];    IF status~ = okay THEN ERROR NoNode;    END;  Setup: PROC = {    wait: VM.ReturnWait ¬ wait;    vmSpace: VM.Interval ¬ [Space.PageFromLongPointer[space.pointer], space.count];    IF ~PilotDiskFace.DetermineDiskShape[device, op, quickReadOnly, space.pointer] THEN       BEGIN      TTY.PutString[h, "Can't determine disk shape...aborted"];       Command.Aborted[];      END;    [cylinders: cyls, movingHeads: headsPerCyl, sectorsPerTrack: sectorsPerTrack]      ¬ PilotDiskFace.GetDeviceAttributes[device];    diskPages ¬ LONG[cyls]*LONG[headsPerCyl]*LONG[sectorsPerTrack];    dT        ¬ PilotDiskFace.GetDeviceType[device];    PrintDriveInfo[dT, cyls, headsPerCyl, sectorsPerTrack];    [] ¬ Space.MapAt[space, [File.nullFile, 0, space.count]];    VM.MakeResident[vmSpace, wait];    setup ¬ TRUE};      Command.InstallTopLevel[h, ["miniMug", MiniMugCmd]];  END....  LOG30-Apr-82  9:59:23  FXH    	Created file from MugTorment.15-Feb-83 11:19:26  EKN   	Changed so it can install itself with PilotTests 8-Mar-83 17:48:07  EKN   	Changed length field of DESCRIPTOR passed to Command.Scan so quit command is seen 7-Oct-83 14:11:57  JXP   	Fix MapAt call in Setup10-Oct-85 14:06:11  RSV     Created Dove version from MiniMugImpl.mesa which was meant for DLions. 26-Apr-89  9:49:32  MXK     Added the rouyine for missing pages.
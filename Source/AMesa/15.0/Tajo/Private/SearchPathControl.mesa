-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- File: SearchPathControl.mesa - last edit:-- LXR    	25-Mar-82 10:15:55-- RES  	29-Jan-82 14:41:25-- RXR   	25-Feb-83 12:47:34-- CXH   	27-Jan-83 18:06:07-- AXD    	20-Jul-83 17:53:19DIRECTORY  Event USING [fileSystem],  EventTypes USING [    directoryCreated, directoryDeleted, newSearchPath, volumeOpened, volumeClosed],  ExecUtilities USING [searchPathToolWindow],  Format USING [StringProc],  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, CommandItem, ModifyEditable,    newLine, ProcType, SetTagPlaces, StringItem, ToggleFlag],  Heap USING [systemZone],  Menu USING [Error, Free, Handle, Instantiate, Make, MCRType, Uninstantiate],  MFile USING [    Acquire, AppendErrorMessage, Delete, dontRelease, EnumerateDirectory,     EnumerateProc, Error, ErrorCode, FreeSearchPath, GetFullName,     GetSearchPath, GetType, Handle, maxNameLength, PleaseReleaseProc, Release,     ReleaseChoice, SearchPath, SetSearchPath, Type],  Put USING [Line, Text],  Runtime USING [GetBcdTime],  SearchPathDefs USING [CreateDir, CWD, Pop, Push, StringToSearchPath],  String USING [    AppendChar, AppendString, CompareStrings, CopyToNewString, EquivalentStrings,     Empty, Length],  Supervisor USING [    AddDependency, AgentProcedure, CreateSubsystem, RemoveDependency,    SubsystemHandle],  Time USING [Append, Unpack],  Tool USING [    Create, MakeFormSW, MakeMsgSW, MakeSWsProc, UnusedLogName],  ToolDriver USING [Address, NoteSWs, RemoveSWs],  ToolWindow USING [TransitionProcType],  UserTerminal USING [BlinkDisplay],  Volume USING [    GetLabelString, GetNext, GetStatus, ID, maxNameLength, nullID, Status],  Window USING [Handle];  SearchPathControl: MONITOR  IMPORTS    Event, ExecUtilities, FormSW, Heap, Menu, MFile, Put, Runtime,    SearchPathDefs, String, Supervisor, Time, Tool, ToolDriver,    UserTerminal, Volume =  BEGIN    ----------------------------------------------------------------  -- TYPEs and Constants  ----------------------------------------------------------------  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = RECORD [    msgSW: Window.Handle ¬ NIL,    formSW: Window.Handle ¬ NIL,    dirMenu, spMenu: Menu.Handle ¬ NIL,    currentCopy: LONG STRING ¬ NIL,    directories: LONG STRING ¬ NIL];      StringSeq: TYPE = RECORD [seq: SEQUENCE n: CARDINAL OF LONG STRING];      DirHandle: TYPE = LONG POINTER TO DirObject;  DirObject: TYPE = RECORD[    next: DirHandle ¬ NIL,    name: LONG STRING ¬ NIL];  ----------------------------------------------------------------  -- Global variables  ----------------------------------------------------------------  data: DataHandle ¬ NIL;  wh: Window.Handle ¬ NIL;  z: UNCOUNTED ZONE = Heap.systemZone;  agent: Supervisor.SubsystemHandle ¬ Supervisor.CreateSubsystem[FileSystemEvent];    -- Initialization and Window Management  currentIndex: CARDINAL = 0;  dirIndex: CARDINAL = currentIndex+1;  popIndex: CARDINAL = dirIndex+1;  pushIndex: CARDINAL = popIndex+1;  cwdIndex: CARDINAL = pushIndex+1;  setIndex: CARDINAL = cwdIndex+1;  createIndex: CARDINAL = setIndex+1;  destroyIndex: CARDINAL = createIndex+1;      MakeForm: INTERNAL FormSW.ClientItemsProcType =    BEGIN OPEN FormSW;    nOptions: CARDINAL = 8;     tabs: ARRAY [0..3) OF CARDINAL ¬ [0, 7, 21];    items ¬ AllocateItemDescriptor[nOptions];    SetCurrentCopy[];    items[currentIndex] ¬ StringItem[      tag: "Current Search Path"L, place: newLine, string: @data.currentCopy,      readOnly: TRUE, inHeap: TRUE];    items[dirIndex] ¬ StringItem[      tag: "Directories"L, place: newLine, string: @data.directories,      inHeap: TRUE];    items[popIndex] ¬ CommandItem[tag: "Pop"L, place: newLine, proc: PopProc];    items[pushIndex] ¬ CommandItem[tag: "Push"L, proc: PushProc];    items[cwdIndex] ¬ CommandItem[tag: "Change Working Dir"L, proc: CWDProc];    items[setIndex] ¬ CommandItem[tag: "Set"L, place: newLine, proc: SetProc];    items[createIndex] ¬ CommandItem[tag: "Create Dir"L, proc: CreateProc];    items[destroyIndex] ¬ CommandItem[tag: "Destroy Dir"L, proc: DestroyProc];    SetTagPlaces[items, DESCRIPTOR[tabs], FALSE];    END;  Write: Format.StringProc = {IF data # NIL THEN Put.Text[data.msgSW, s]};      Writeln: Format.StringProc = {IF data # NIL THEN Put.Line[data.msgSW, s]};    WriteMFileError: PROCEDURE[code: MFile.ErrorCode, file: MFile.Handle] = {    msg: LONG STRING = [100];    MFile.AppendErrorMessage[msg, code, file]; Write[msg]};  SetCurrentCopy: INTERNAL PROCEDURE [] = {    sp: MFile.SearchPath ¬ MFile.GetSearchPath[];    BEGIN    ENABLE UNWIND => {MFile.FreeSearchPath[sp]};    FormSW.ToggleFlag[sw: data.formSW, index: currentIndex, flag: readOnly];    IF data.currentCopy # NIL THEN       FormSW.ModifyEditable[sw: data.formSW,         index: currentIndex, position: 0, length: String.Length[data.currentCopy]];    FOR i: CARDINAL IN [0..sp.length) DO      IF ~String.Empty[data.currentCopy] THEN        FormSW.ModifyEditable[sw: data.formSW, 	  index: currentIndex, position: data.currentCopy.length, length: 0, 	  new: "  "L];      FormSW.ModifyEditable[sw: data.formSW,         index: currentIndex, position: String.Length[data.currentCopy], length: 0, 	new: sp[i]];      ENDLOOP;    MFile.FreeSearchPath[sp];    FormSW.ToggleFlag[sw: data.formSW, index: currentIndex, flag: readOnly];    END;    };      PushFromMenu: Menu.MCRType =    {[] ¬ SearchPathDefs.Push[menu.items[index].keyword, Write]};      ThrowOutFromMenu: Menu.MCRType =    BEGIN    sp: MFile.SearchPath ¬ MFile.GetSearchPath[];    removedDir: LONG STRING ¬ sp[index];    FOR k: CARDINAL IN [index..sp.length-1) DO      sp[k] ¬ sp[k+1];      ENDLOOP;    sp.length ¬ sp.length-1;    [] ¬ MFile.SetSearchPath[sp];    sp[sp.length] ¬ removedDir;    sp.length ¬ sp.length+1;    MFile.FreeSearchPath[sp];    END;  SetProc: FormSW.ProcType = {    [] ¬ SearchPathDefs.StringToSearchPath[data.directories, Write]};  CreateProc: FormSW.ProcType = {    [] ¬ SearchPathDefs.CreateDir[data.directories, Write]};      DestroyProc: FormSW.ProcType =    BEGIN    ENABLE MFile.Error => {WriteMFileError[code, file]; CONTINUE};    name: LONG STRING = [MFile.maxNameLength];     f: MFile.Handle ¬ MFile.Acquire[data.directories, delete, MFile.dontRelease];    f.GetFullName[name];    IF f.GetType[] # directory THEN {      Writeln[""L]; Write[" Destroy operation aborted. "L];      Write[name]; Write[" not a directory!"L];      MFile.Release[f];      RETURN};    f.Delete[ ! UNWIND => f.Release[]];    Writeln[""L]; Write[" Destroyed directory "L]; Write[name];    END;      PushProc: FormSW.ProcType =    BEGIN    ENABLE MFile.Error => {WriteMFileError[code, file]; CONTINUE};    Writeln[""L];    IF SearchPathDefs.Push[data.directories, Write] # normal THEN       Writeln[" Working directory unchanged"L];    END;  PopProc: FormSW.ProcType = {[] ¬ SearchPathDefs.Pop[Write]};  CWDProc: FormSW.ProcType =    BEGIN    IF SearchPathDefs.CWD[dir: data.directories, Write: Write] # normal THEN {       Writeln[""L]; Write[" Failed to change working directory"L]}    ELSE {Writeln[""L]; Write[" Changed working directory"L]};    END;      MakeSWs: ENTRY Tool.MakeSWsProc =    BEGIN ENABLE UNWIND => NULL;     addresses: ARRAY [0..2) OF ToolDriver.Address;    fileName: STRING = [50];    Tool.UnusedLogName[unused: fileName, root: "SearchPathTool.log"L];    data.formSW ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    data.msgSW ¬ Tool.MakeMsgSW[window: window, lines: 5];    addresses ¬ [["msgSW"L, data.msgSW], ["formSW"L, data.formSW]];    ToolDriver.NoteSWs["SearchPath"L, DESCRIPTOR[addresses]];    wh ¬ window;    MakeDirMenu[];    FileSystemEvent[      event: EventTypes.newSearchPath, eventData: NIL, instanceData: NIL];    END;      GetNextVolumeName: PROCEDURE[oldID: Volume.ID, volumeName: LONG STRING]    RETURNS[newID: Volume.ID] =    BEGIN    status: Volume.Status;    temp: LONG STRING ¬ [Volume.maxNameLength];    volumeName.length ¬ 0;    newID ¬ Volume.GetNext[oldID, ALL[TRUE]];    IF newID = Volume.nullID THEN RETURN[Volume.nullID];    Volume.GetLabelString[newID, temp];    status ¬ Volume.GetStatus[newID];    IF status = openRead OR status = openReadWrite THEN {      String.AppendChar[volumeName, '<];      String.AppendString[volumeName, temp];      String.AppendChar[volumeName, '>]}    END;        MakeDirMenu: INTERNAL PROCEDURE [singleVolume: LONG STRING ¬ NIL] =    BEGIN    dirRoot: DirHandle ¬ NIL;    dirNames: LONG POINTER TO StringSeq ¬ NIL;    numDirs: CARDINAL ¬ 0;    volumeName: LONG STRING = [Volume.maxNameLength+3];    volID: Volume.ID ¬ Volume.nullID;    dirMenuChanged: BOOLEAN ¬ TRUE;    Build: MFile.EnumerateProc = {      -- the strings we allocate here will eventually get copied into the      -- sequence, and freed when it is freed      dirRoot ¬ z.NEW[DirObject ¬ [dirRoot, String.CopyToNewString[fullName, z]]];      numDirs ¬ numDirs + 1;      done ¬ FALSE};    IF singleVolume = NIL THEN { -- enumerate all volumes      UNTIL (volID  ¬ GetNextVolumeName[volID, volumeName]) = Volume.nullID DO        IF String.Empty[volumeName] THEN LOOP;        String.AppendString[volumeName, "**"L];        MFile.EnumerateDirectory[volumeName, Build, directoriesOnly !	  MFile.Error => LOOP];        ENDLOOP;      dirNames ¬ z.NEW[StringSeq[numDirs]];      FOR i: CARDINAL IN (0..numDirs] DO        temp: DirHandle ¬ dirRoot;        dirNames[numDirs-i] ¬ temp.name;        dirRoot ¬ temp.next;        z.FREE[@temp];        ENDLOOP}    ELSE { -- incrementally update for just this one volume      insertBefore: CARDINAL;      currentSize: CARDINAL = data.dirMenu.items.LENGTH;      IF singleVolume[0] # '< THEN String.AppendChar[volumeName, '<];      String.AppendString[volumeName, singleVolume];      IF singleVolume[singleVolume.length] # '>         THEN String.AppendChar[volumeName, '>];      String.AppendString[volumeName, "**"L];      MFile.EnumerateDirectory[volumeName, Build, directoriesOnly !        MFile.Error => GOTO noRootDirectory];      FOR insertBefore IN [0..currentSize) DO        SELECT String.CompareStrings[	  dirRoot.name, data.dirMenu.items[insertBefore].keyword] FROM        < 0,	= 0 => EXIT;        > 0 => NULL;        ENDCASE => ERROR;      REPEAT FINISHED => insertBefore ¬ currentSize;      ENDLOOP;            -- create range [0..currentSize+numDirs)      dirNames ¬ z.NEW[StringSeq[currentSize+numDirs]];            -- fill the range [0..insertBefore) ¬ [0..insertBefore)      FOR i: CARDINAL IN [0..insertBefore) DO        dirNames[i] ¬ data.dirMenu.items[i].keyword;	ENDLOOP;	      -- fill the range [insertBefore..insertBefore+numDirs) ¬ new stuff [0..numdirs)      FOR i: CARDINAL DECREASING IN [insertBefore..insertBefore+numDirs) DO        temp: DirHandle ¬ dirRoot;        dirNames[i] ¬ temp.name;        dirRoot ¬ temp.next;        z.FREE[@temp];        ENDLOOP;	      -- fill [insertBefore+numDirs..currentSize+numDirs) ¬ [insertBefore..currentSize)      FOR i: CARDINAL IN [insertBefore+numDirs..currentSize+numDirs) DO        dirNames[i] ¬ data.dirMenu.items[i-numDirs].keyword;	ENDLOOP;      EXITS noRootDirectory => dirMenuChanged ¬ FALSE};    IF dirMenuChanged THEN UpdateDirMenu[dirNames];    z.FREE[@dirNames];    END;      AddOneToDirNames: INTERNAL PROCEDURE[name: LONG STRING] =    BEGIN    oldNumItems: CARDINAL = data.dirMenu.items.LENGTH;    newSeq: LONG POINTER TO StringSeq ¬ z.NEW[StringSeq[oldNumItems+1]];    BEGIN -- so the exit can free the newSeq    index, i: CARDINAL;    fullName: LONG STRING ¬ [100];    fh: MFile.Handle;    fh ¬ MFile.Acquire[name, anchor, [] ! MFile.Error => {fh ¬ NIL; CONTINUE}];    IF fh = NIL THEN GOTO exit;    fh.GetFullName[fullName ! MFile.Error => {fullName.length ¬ 0; CONTINUE}];    IF fullName.length = 0 THEN {fh.Release[]; GOTO exit};    fh.Release[];    FOR index IN [0..oldNumItems) DO      SELECT String.CompareStrings[name, data.dirMenu.items[index].keyword] FROM        -1 --less-- => EXIT;        1 --greater-- => NULL;        0 --equal-- => GOTO exit;        ENDCASE => ERROR;      REPEAT FINISHED => index ¬ oldNumItems;      ENDLOOP;        FOR i IN [0..oldNumItems) DO      newSeq[IF i < index THEN i ELSE i + 1] ¬ data.dirMenu.items[i].keyword;      ENDLOOP;    newSeq[index] ¬ String.CopyToNewString[fullName, z];    UpdateDirMenu[newSeq];    z.FREE[@newSeq]; -- note: this frees the descriptor BUT NOT the strings.    EXITS      exit => z.FREE[@newSeq];    END;    END;      RemoveVolumeFromDirNames: INTERNAL PROCEDURE [volumeName: LONG STRING] =    BEGIN    newSeq: LONG POINTER TO StringSeq;    numDirs: CARDINAL ¬ 0;    dirRoot: DirHandle ¬ NIL;        FOR i: CARDINAL IN [0..data.dirMenu.items.LENGTH) DO      ddiik: LONG STRING = data.dirMenu.items[i].keyword;      -- use length-2 because the keyword is surrounded by <>      IF ddiik.length-2 < volumeName.length THEN LOOP;      FOR ix: CARDINAL IN [0..volumeName.length) DO        -- for all volumes # volumeName keep the old node        IF volumeName[ix] # ddiik[1+ix] THEN GOTO exit;  -- 1+ix skips '<        REPEAT          exit => {	    dirRoot ¬ z.NEW[DirObject ¬ [dirRoot, ddiik]]; numDirs ¬ numDirs+1};	  FINISHED => z.FREE[@data.dirMenu.items[i].keyword];        ENDLOOP;      ENDLOOP;    newSeq ¬ z.NEW[StringSeq[numDirs]];    FOR i: CARDINAL IN (0..numDirs] DO      temp: DirHandle ¬ dirRoot;      newSeq[numDirs-i] ¬ temp.name;      dirRoot ¬ temp.next;      z.FREE[@temp];      ENDLOOP;    UpdateDirMenu[newSeq ! UNWIND => {z.FREE[@newSeq]}];    z.FREE[@newSeq]; -- note: this frees the descriptor BUT NOT the strings.    END;    RemoveOneFromDirNames: INTERNAL PROCEDURE [name: LONG STRING] =    BEGIN    oldNumItems: CARDINAL = data.dirMenu.items.LENGTH;    newSeq: LONG POINTER TO StringSeq ¬ z.NEW[StringSeq[oldNumItems-1]];    BEGIN -- so the exit can free the newSeq    index: CARDINAL;    FOR index IN [0..oldNumItems) DO      IF String.EquivalentStrings[name, data.dirMenu.items[index].keyword] THEN EXIT;      REPEAT FINISHED => GOTO exit;      ENDLOOP;    z.FREE[@data.dirMenu.items[index].keyword];        FOR i: CARDINAL IN [0..oldNumItems-1) DO      newSeq[i] ¬ data.dirMenu.items[IF i < index THEN i ELSE i+1].keyword;      ENDLOOP;    UpdateDirMenu[newSeq];    z.FREE[@newSeq]; -- note: this frees the descriptor BUT NOT the strings.    EXITS      exit => z.FREE[@newSeq];    END;    END;    Cleanup: ENTRY ToolWindow.TransitionProcType =    BEGIN    ENABLE UNWIND => NULL;    SELECT TRUE FROM      new = inactive => {        Supervisor.RemoveDependency[client: agent, implementor: Event.fileSystem];        ToolDriver.RemoveSWs["SearchPath"L];        KillSpMenu[];	FOR i: CARDINAL IN [0..data.dirMenu.items.LENGTH) DO	  z.FREE[@data.dirMenu.items[i].keyword];	  ENDLOOP;        KillDirMenu[];        z.FREE[@data.currentCopy];        z.FREE[@data.directories];        z.FREE[@data]};      old = inactive => {	data ¬ z.NEW[Data ¬ []];        Supervisor.AddDependency[client: agent, implementor: Event.fileSystem]};      ENDCASE;    END;      KillSpMenu: INTERNAL PROCEDURE = {    IF data.spMenu = NIL THEN RETURN;    Menu.Uninstantiate[data.spMenu, wh];    Menu.Free[data.spMenu, TRUE]};      KillDirMenu: INTERNAL PROCEDURE = {    IF data.dirMenu = NIL THEN RETURN;    Menu.Uninstantiate[data.dirMenu, wh];    Menu.Free[data.dirMenu, FALSE]};      MakeSpMenu: INTERNAL PROCEDURE =    BEGIN    sp: MFile.SearchPath ¬ MFile.GetSearchPath[];    menuSeq: LONG POINTER TO StringSeq ¬ z.NEW[StringSeq[sp.length]];    KillSpMenu[];    FOR i: CARDINAL IN [0..sp.length) DO      menuSeq[i] ¬ sp[i];      ENDLOOP;    data.spMenu ¬ Menu.Make[      "Search Path", DESCRIPTOR[menuSeq­], ThrowOutFromMenu, TRUE];    Menu.Instantiate[data.spMenu, wh !      Menu.Error => {UserTerminal.BlinkDisplay[]; CONTINUE}];    MFile.FreeSearchPath[sp];    z.FREE[@menuSeq];    END;    UpdateDirMenu: INTERNAL PROCEDURE [dirNames: LONG POINTER TO StringSeq] =    BEGIN    KillDirMenu[];    data.dirMenu ¬ Menu.Make[      "All Directories", DESCRIPTOR[dirNames], PushFromMenu, FALSE];    Menu.Instantiate[data.dirMenu, wh !       Menu.Error => {UserTerminal.BlinkDisplay[]; CONTINUE}];    END;        Initialize: PROCEDURE =    BEGIN    name: STRING = [50];    String.AppendString[name, "SearchPath Tool of "L];    Time.Append[name, Time.Unpack[Runtime.GetBcdTime[]]];    wh ¬ Tool.Create[      name: name, makeSWsProc: MakeSWs, clientTransition: Cleanup,      initialBox: [[40, 40], [400, 250]],      cmSection: "SearchPathTool"L];    IF ExecUtilities.searchPathToolWindow = NIL THEN      ExecUtilities.searchPathToolWindow ¬ wh;    END;      FileSystemEvent: INTERNAL Supervisor.AgentProcedure =    BEGIN    volumeName: LONG STRING = [Volume.maxNameLength];    volumeId: LONG POINTER TO Volume.ID;    SELECT event FROM      EventTypes.newSearchPath => {SetCurrentCopy[]; MakeSpMenu[]};      EventTypes.volumeOpened => {        volumeId ¬ LOOPHOLE[eventData];        Volume.GetLabelString[volumeId­, volumeName];	MakeDirMenu[volumeName]};      EventTypes.volumeClosed => {        volumeId ¬ LOOPHOLE[eventData];        Volume.GetLabelString[volumeId­, volumeName];	RemoveVolumeFromDirNames[volumeName]};      EventTypes.directoryDeleted => RemoveOneFromDirNames[eventData];      EventTypes.directoryCreated => AddOneToDirNames[eventData];      ENDCASE;    END;      -- Mainline code        Initialize[];  END.
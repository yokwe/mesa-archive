-- File: RightsNotice.mesa - last edit:-- TXT			1-Oct-88 14:15:42-- DSC                  3-Oct-85 13:08:22-- DWR                 26-Sep-85 11:19:59-- kam                 27-Jun-85 11:32:49-- RKJ                 24-Mar-83 19:30:45-- Copyright (C) 1983, 1984, 1985 by Xerox Corporation. All rights reserved. DIRECTORY  Context USING [Create, DestroyProcType, Type, UniqueType],  Heap USING [systemZone],  Menu USING [Enumerate, EnumerateProcType, Handle, Uninstantiate],  Process USING [Detach, Pause, SecondsToTicks, Ticks],  Put USING [Text],  SpecialUserInput USING [Coords, GetMouseAndCursorPosition],  String USING [AppendStringAndGrow],  StringSW USING [Create],  Tool USING [AddThisSW, Create, Destroy, MakeSWsProc],  ToolWindow USING [Activate, CreateSubwindow, GetState, State, TransitionProcType],  UserInput USING [CreatePeriodicNotify, PeriodicProcType],  UserTerminal USING [screenHeight, screenWidth],  VersionExtras USING [AppendCopyright],  Window USING [    Dims, Error, GetChild, GetParent, Handle, Place, rootWindow, Stack,    ValidateTree],  WindowFont USING [CharWidth, FontHeight];RightsNotice: PROGRAM  IMPORTS    Context, Heap, Menu, Process, Put, SpecialUserInput, String, StringSW, Tool, ToolWindow,    UserInput, UserTerminal, VersionExtras, Window, WindowFont =  BEGIN    -- constants  cW: NATURAL = WindowFont.CharWidth['X];  cH: NATURAL = WindowFont.FontHeight[];  boxOrigin: Window.Place = [0, 30];  maxW: NATURAL = UserTerminal.screenWidth - boxOrigin.x;  maxH: NATURAL = UserTerminal.screenHeight - boxOrigin.y;  seconds: CARDINAL = 10;  aSecond: Process.Ticks = Process.SecondsToTicks[1];    tryingToBeObnoxious: BOOLEAN = FALSE;    Data: TYPE = RECORD [    message: LONG STRING ¬ NIL,    wiseGuy: BOOLEAN ¬ FALSE,    punishment: CARDINAL ¬ seconds  ];    data: LONG POINTER TO Data ¬ NIL;    destroyed: BOOLEAN ¬ FALSE;  stop: BOOLEAN ¬ FALSE;  -- Must be global since used in Transition proc.    DisplayNotice: PROCEDURE --UserInput.PeriodicProcType-- =    BEGIN        z: UNCOUNTED ZONE ¬ Heap.systemZone;        boxDims: Window.Dims ¬ [0, 0];    lineLength: CARDINAL ¬ 80;    lines: CARDINAL ¬ 0;          action: BOOLEAN ¬ FALSE;    w, sw: Window.Handle ¬ NIL;        contextType: Context.Type ¬ all;        oldCoords: SpecialUserInput.Coords =      SpecialUserInput.GetMouseAndCursorPosition[];        Action: PROCEDURE RETURNS [BOOLEAN] = {      RETURN[(action ¬ action        OR (SpecialUserInput.GetMouseAndCursorPosition[] # oldCoords))]};	    MakeSWs: Tool.MakeSWsProc = {      sw ¬ ToolWindow.CreateSubwindow[        parent: window, box: [[1, 1], [boxDims.w - 2, boxDims.h - 2]]];      StringSW.Create[        sw: sw, s: @data.message, options: [          access: read, menu: FALSE, split: FALSE, wrap: TRUE, scrollbar: FALSE,	  flushTop: FALSE, flushBottom: FALSE],	expandable: FALSE];      Tool.AddThisSW[window: window, sw: sw, h: boxDims.h - 2]};        RemoveMenus: PROCEDURE = {      m: Menu.Handle ¬ NIL;      Proc: Menu.EnumerateProcType = {m ¬ menu; stop ¬ TRUE};      DO        Menu.Enumerate[w, all, Proc];	IF m = NIL THEN EXIT;        Menu.Uninstantiate[m, w];        m ¬ NIL;	ENDLOOP};          -- Mainline code.    contextType ¬ Context.UniqueType[];    data ¬ z.NEW[Data ¬ [message: NIL]];        String.AppendStringAndGrow[to: @data.message, from: "\n"L, z: z, extra: 150];    VersionExtras.AppendCopyright[data.message];    String.AppendStringAndGrow[to: @data.message, from: "  This software material is proprietary information of Xerox Corporation.  Unless provided for in a separate agreement with Xerox, this material is confidential information of Xerox.  Any reproduction, in whole or in part, or outside disclosure or distribution is prohibited."L, z: z];        boxDims.w ¬ cW * lineLength + 4;    IF boxDims.w >= maxW THEN {boxDims.w ¬ maxW; lineLength ¬ (maxW - 4)/cW};    lines ¬ (data.message.length + lineLength - 1) / lineLength;    boxDims.h ¬ MIN[maxH, cH * (lines + 3)];          	    w ¬ Tool.Create[      name: "RightsNotice"L, makeSWsProc: MakeSWs, clientTransition: Trans,      initialState: active, initialBox: [boxOrigin, boxDims], named: FALSE];          Context.Create[type: contextType, data: data, proc: DestroyContext, window: w];        RemoveMenus[];          THROUGH [0.. seconds) UNTIL stop DO      ENABLE Window.Error => EXIT;       Process.Pause[aSecond];       TopWindow[w];     ENDLOOP;        UNTIL stop OR Action[] DO      ENABLE Window.Error => EXIT;       Process.Pause[aSecond];       TopWindow[w];     ENDLOOP;        IF tryingToBeObnoxious AND IsAWiseGuy[] THEN BEGIN     THROUGH [0.. data.punishment) DO	ENABLE Window.Error => EXIT; 	Process.Pause[aSecond];	TopWindow[w];	Gripe[NIL, " Have you read your rights yet?"L];      ENDLOOP;    END;        -- Time to say bye bye..    [] ¬ UserInput.CreatePeriodicNotify[proc: DestroyTool, window: w, rate: 0];        -- Tool.Destroy[w]; ++ too many race conditions        END;        TopWindow: PROCEDURE[w: Window.Handle] = BEGIN      [] ¬ UserInput.CreatePeriodicNotify[proc: Top, window: w, rate: 0];    END;        DestroyContext: Context.DestroyProcType = BEGIN      Heap.systemZone.FREE[@data.message];      Heap.systemZone.FREE[@data];    END;        DestroyTool: UserInput.PeriodicProcType = BEGIN    -- Cannot be nested      destroyed ¬ TRUE;      Tool.Destroy[window];    END;        Top:  UserInput.PeriodicProcType = {      state: ToolWindow.State ¬ tiny;      IF destroyed THEN RETURN;       << Don't want to destroy a previously destroyed window >>      state ¬ ToolWindow.GetState[window];      << User may have tinied the window by using the accelerator on the one-bit namestripe >>      SELECT state FROM      inactive, tiny => {        ToolWindow.Activate[window];	IF IsAWiseGuy[]  THEN 	  Gripe[NIL, " It's no use. "L] ELSE	  Gripe[NIL, " A wise guy, eh?"L];	SawAWiseGuy[];	      };      << Include inactive in the arm for good measure. I do think it is possible to deactivate it >>      ENDCASE;      IF window.GetParent.GetChild # window THEN {        << Uncover the window >>	window.Stack[window.GetParent.GetChild]; Window.rootWindow.ValidateTree}};        Trans: ToolWindow.TransitionProcType = BEGIN      SELECT new FROM      inactive => stop ¬ TRUE;      ENDCASE;     END;         SawAWiseGuy: PROCEDURE = BEGIN      data.wiseGuy ¬ TRUE;      data.punishment ¬ data.punishment * 2;     END;        Gripe: PROCEDURE [window: Window.Handle, s: LONG STRING] = BEGIN      IF tryingToBeObnoxious THEN Put.Text[NIL, s];    END;        IsAWiseGuy: PROCEDURE RETURNS [BOOLEAN] = BEGIN      RETURN[data.wiseGuy];    END;  -- Mainline    Process.Detach[FORK DisplayNotice[]];  END...Change log:Time:			By:		Action: 2-Oct-85 15:50:43	DSC		Fix  bug where I DestroyTool is a nested proc called from a PeriodicNotify. (DisplayNotice process has died, so DestroyTool is unbound) Also, the transition proc is cannot be nested either. 3-Oct-85 12:13:04	DSC		The string is freed frm a DestroyTool which may be called after the string is gone from the local frame).Attached Context to window and a corresponding destroy proc. Also, you could tiny the window during the first N seconds from the one-bit wide name stripe. So I detect that and reactivate the tool.  So I placed some punishment code to display the window for TWICE the time for all wise guys. 3-Oct-85 13:36:28	DSC		Wise counsel told me to take out the wise guy business. But if you want to do that, just recompile with the tryingToBeObnoxious set to TRUE 1-Oct-88 14:15:54	TXT  		Expand the string-size of RightNotice. 100 -> 150 
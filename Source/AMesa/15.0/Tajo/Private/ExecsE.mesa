-- Copyright (C) 1981, 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- ExecsE.mesa - last edited by  -- SXW   	12-Jul-81 13:34:41  -- LXR    	17-Jan-84 14:57:20  -- RXR   	26-Apr-83 11:01:51  -- BXM  	22-Feb-82 11:49:42  -- JGS	27-Jan-83 15:14:31  -- RXJ     	25-Apr-83 14:06:07  -- AXD    	19-Jul-83 15:41:08DIRECTORY  Exec USING [    CheckForAbort, DefaultUnloadProc, ExecProc, FreeTokenString, GetToken, Handle,    Outcome, OutputProc, RemovedStatus],  ExecInternal USING [],  Heap USING [Create, systemZone],  Format USING [CR, StringProc],  Inline USING [LongCOPY],  MLoader USING [Error, Handle, HandleFromProgram, Unload],  Runtime USING [GlobalFrame],  String USING [    AppendString, Compare, EmptyString, EquivalentString, InvalidNumber,    Length, StringLength, StringToLongNumber],  StringLookUp USING [ambiguous, GeneratorProcType, UsingGeneratorWithBuffer];ExecsE: MONITOR  IMPORTS    Exec, Format, Heap, Inline, MLoader, Runtime, String,    StringLookUp  EXPORTS Exec, ExecInternal =  BEGIN  initTableSize: CARDINAL = 40;  tableInc: CARDINAL = 10;  initRenameSize: CARDINAL = 5;   renameInc: CARDINAL = 3;   Link: TYPE = LONG POINTER TO CommandTableEntry;  CommandTableEntry: TYPE = RECORD [    name: LONG STRING ¬ NIL, link: Link ¬ NIL, infoIndex: CARDINAL ¬ 0,    original: BOOLEAN ¬ TRUE];  CommandTableSeq: TYPE = RECORD [    SEQUENCE COMPUTED CARDINAL OF CommandTableEntry];  CommandTableHandle: TYPE = LONG POINTER TO CommandTableSeq;  CommandIndexSeq: TYPE = RECORD [    SEQUENCE COMPUTED CARDINAL OF CARDINAL];  CommandIndexHandle: TYPE = LONG POINTER TO CommandIndexSeq;      InfoTableEntry: TYPE = RECORD [    proc, help, unload: Exec.ExecProc, clientData: LONG POINTER,    used: BOOLEAN ¬ FALSE];  InfoTableSeq: TYPE = RECORD [    SEQUENCE COMPUTED CARDINAL OF InfoTableEntry];  InfoTableHandle: TYPE = LONG POINTER TO InfoTableSeq;    RenameTableEntry: TYPE = RECORD [    name: LONG STRING,    indexInCommandTable: CARDINAL, used: BOOLEAN ¬ FALSE];  RenameTableSeq: TYPE = RECORD [    SEQUENCE COMPUTED CARDINAL OF RenameTableEntry];  RenameTableHandle: TYPE = LONG POINTER TO RenameTableSeq;            heap: UNCOUNTED ZONE = Heap.Create[initial: 2];  --Allocate storage for sequences  info: InfoTableHandle ¬ heap.NEW[InfoTableSeq [initTableSize]];  commands: CommandTableHandle ¬ heap.NEW[CommandTableSeq [initTableSize]];  renamed: RenameTableHandle ¬ heap.NEW[RenameTableSeq [initRenameSize]];  cI: CommandIndexHandle ¬     heap.NEW[CommandIndexSeq [initTableSize]];    numberOfBuiltins: CARDINAL;   infoTableSize, commandTableSize: CARDINAL ¬ initTableSize;  renameTableSize: CARDINAL ¬ initRenameSize;   commandCount: CARDINAL ¬ 0;  infoCount: CARDINAL ¬ 0;  renameCount: CARDINAL ¬ 0;  longestCommand: CARDINAL ¬ 0;  buffer: LONG STRING ¬ NIL;    SetBuiltInCommands: PUBLIC PROC = {numberOfBuiltins ¬ commandCount};    AdjustBuffer: PROC [length: CARDINAL] = {    IF longestCommand < length THEN {       longestCommand ¬ length;       IF buffer # NIL THEN heap.FREE[@buffer];      buffer ¬ heap.NEW[StringBody [longestCommand]]}};      LookUp: --INTERNAL-- PROC [key: LONG STRING] RETURNS [index: CARDINAL] = {    -- Warning: any key sent to this procedure should not be longer than buffer    currentItem: CARDINAL ¬ 0;    GenerateItems: StringLookUp.GeneratorProcType = {      buffer.length ¬ 0;      IF currentItem >= commandCount THEN RETURN;      IF String.EmptyString[commands[cI[currentItem]].name]      	--force to non-empty for StringLookUp        THEN String.AppendString[buffer, "   "L]        ELSE String.AppendString[buffer, commands[cI[currentItem]].name];      currentItem ¬ currentItem + 1};      RETURN[StringLookUp.UsingGeneratorWithBuffer[        key: key, generator: GenerateItems, buffer: buffer]]};  AddCommand: PUBLIC ENTRY PROC [    name: LONG STRING, proc: Exec.ExecProc, help: Exec.ExecProc ¬ NIL,    unload: Exec.ExecProc ¬ Exec.DefaultUnloadProc,     clientData: LONG POINTER ¬ NIL] = {    ENABLE UNWIND => NULL;    [] ¬ AddCommandInternal[name, proc, help, unload, clientData]};      AddIndexEntry: INTERNAL PROC [command: LONG STRING, cIndex: CARDINAL]    RETURNS[newSlot: CARDINAL ¬ 0] = {    -- commandCount has not been incremented yet    FOR newSlot IN [0..commandCount) DO      IF String.Compare[command, commands[cI[newSlot]].name] = -1         THEN EXIT;      ENDLOOP;    IF commandCount > 0 AND       String.Compare[command, commands[cI[newSlot]].name] = 1      THEN newSlot ¬ commandCount;    IF newSlot # commandCount THEN       FOR i: CARDINAL DECREASING IN [newSlot..commandCount) DO        cI[i + 1] ¬ cI[i];	ENDLOOP;    cI[newSlot] ¬ cIndex};      RemoveIndexEntry: --INTERNAL-- PROC [emptySlot: CARDINAL] = {    -- commandCount has already been decremented    FOR i: CARDINAL IN [emptySlot..commandCount) DO      cI[i] ¬ cI[i + 1]      ENDLOOP;    cI[commandCount] ¬ CARDINAL.LAST};      FindInfoSlot: INTERNAL PROC RETURNS [i: CARDINAL] = {    FOR i IN [0..infoTableSize) DO      IF info[i].used = FALSE THEN RETURN[i];      ENDLOOP};      FindCommandSlot: INTERNAL PROC RETURNS [i: CARDINAL] = {    FOR i IN [0..commandTableSize] DO      IF commands[i].name = NIL THEN RETURN[i];      ENDLOOP};    RemoveAliases: --INTERNAL-- PROC [firstNode: Link] = {    index: CARDINAL;    prev, current: Link;    prev ¬ firstNode;    current ¬ prev.link;    UNTIL current = firstNode OR current = NIL DO      current.original ¬ TRUE;      index ¬ LookUp[current.name];      commandCount ¬ commandCount - 1;      RemoveIndexEntry[index];      heap.FREE[@current.name];      prev.link ¬ NIL;      prev ¬ current;      current ¬ current.link;      ENDLOOP;    prev.link ¬ NIL};      AddCommandInternal: INTERNAL PROC [    name: LONG STRING, proc: Exec.ExecProc, help: Exec.ExecProc ¬ NIL,    unload: Exec.ExecProc ¬ Exec.DefaultUnloadProc,     clientData: LONG POINTER ¬ NIL]     RETURNS [newCommandIndex: CARDINAL] = {    ENABLE UNWIND => NULL;    aliasing: BOOLEAN ¬ proc = NIL;    oldInfoSlot, previousI, newInfoSlot, newCommandSlot: CARDINAL;    AdjustBuffer[name.length];    previousI ¬ LookUp[name];    IF previousI < commandCount THEN  {        -- reassign info      << if aliasing and new command already registered,         AddCommandInternal will not have been called   >>      oldInfoSlot ¬ commands[cI[previousI]].infoIndex;      info[oldInfoSlot] ¬ [proc, help, unload, clientData];      info[oldInfoSlot].used ¬ TRUE;      RemoveAliases[@commands[cI[previousI]]];      commands[cI[previousI]].original ¬ TRUE;      newCommandIndex ¬ previousI;      RETURN};    -- put new command in table    IF commandCount = commandTableSize THEN EnlargeCommandTable[];    IF infoCount = infoTableSize AND ~aliasing THEN EnlargeInfoTable[];    newInfoSlot ¬ FindInfoSlot[];    newCommandSlot ¬ FindCommandSlot[];    commands[newCommandSlot].name ¬ heap.NEW[StringBody [name.length]];    commands[newCommandSlot].name.length ¬ name.length;    FOR i: CARDINAL IN [0..name.length) DO      commands[newCommandSlot].name[i] ¬ name[i] ENDLOOP;    IF ~aliasing THEN {      commands[newCommandSlot].original ¬ TRUE;      commands[newCommandSlot].infoIndex ¬ newInfoSlot;      info[newInfoSlot] ¬ [proc, help, unload, clientData];      info[newInfoSlot].used ¬ TRUE;      infoCount ¬ infoCount + 1};    -- else infoIndex set in AliasCommand    newCommandIndex ¬ AddIndexEntry[name, newCommandSlot];    commandCount ¬ commandCount + 1};      DefaultUnloadProc: --INTERNAL-- PUBLIC Exec.ExecProc = {    -- clientData contains the name of the command to unload    index: CARDINAL ¬ LookUp[clientData];    proc: Exec.ExecProc;    rs: Exec.RemovedStatus;    IF index < commandCount THEN proc ¬       info[commands[cI[index]].infoIndex].proc;    IF LOOPHOLE[clientData, LONG STRING].length > longestCommand       OR index >=  commandCount THEN      RETURN[error];    RemoveCommand[h, clientData];    rs ¬ UnloadProgram[proc, h, clientData];    IF rs # ok THEN outcome ¬ error};  Unload: PUBLIC PROC [handle: MLoader.Handle] = {MLoader.Unload[handle]};    GetcI: PROC[index: CARDINAL] RETURNS [cIPos: CARDINAL] = {    FOR i: CARDINAL IN [0..commandCount) DO      IF cI[i] = index THEN RETURN[i];      ENDLOOP};  GetUnloadAndProc: INTERNAL PROC [index: CARDINAL, name: LONG STRING]    RETURNS [proc, unload: Exec.ExecProc, cd: LONG POINTER] = {    IF index >= commandCount THEN {      [index,] ¬ LookUpInRenameTable[name];      index ¬ GetcI[renamed[index].indexInCommandTable]};    proc ¬ info[commands[cI[index]].infoIndex].proc;    unload ¬ info[commands[cI[index]].infoIndex].unload;    RETURN[      info[commands[cI[index]].infoIndex].proc,      info[commands[cI[index]].infoIndex].unload,      info[commands[cI[index]].infoIndex].clientData]};       UnloadCommand: PUBLIC ENTRY PROC [h: Exec.Handle, name: LONG STRING]    RETURNS [status: Exec.RemovedStatus ¬ ok] = {    ENABLE UNWIND => NULL;    unload, proc: Exec.ExecProc;    cd: LONG POINTER;    outcome: Exec.Outcome ¬ normal;    cIndex: CARDINAL;    inTable: BOOLEAN;    IF String.StringLength[name] = 0 OR longestCommand < name.length THEN        RETURN[noCommand];    AdjustBuffer[name.length];    [cIndex, ,inTable] ¬ FindOriginal[name];    IF (cIndex >= commandCount AND ~inTable) -- command does not exist       OR cI[cIndex] < numberOfBuiltins THEN  -- can't unload a builtin       RETURN[noCommand];    [proc, unload, cd] ¬ GetUnloadAndProc[cIndex, name];    IF unload = DefaultUnloadProc       THEN {        outcome ¬ unload[h, name]; 	infoCount ¬ infoCount - 1;         IF outcome # normal THEN RETURN[noCommand]}      ELSE IF unload # NIL THEN {        outcome ¬ unload[h, cd];	infoCount ¬ infoCount - 1;         IF outcome # normal 	  THEN RETURN[noCommand] 	  ELSE RETURN[UnloadProgram[proc, h, name]]}};      CallUserUnloadProc: Exec.ExecProc = {    Write: Format.StringProc ¬ Exec.OutputProc[h];    token, switches: LONG STRING ¬ NIL;    removedStatus: Exec.RemovedStatus;    errorsSeen: BOOLEAN ¬ FALSE;    Cleanup: PROC = {      Heap.systemZone.FREE[@token];      Heap.systemZone.FREE[@switches]};    BEGIN ENABLE UNWIND => {Cleanup[]; outcome ¬ error};    DO      [token, switches] ¬ Exec.GetToken[h];      IF String.StringLength[token] = 0 THEN EXIT;      IF ~UnloadMLoaderHandle[token] THEN {        removedStatus ¬ UnloadCommand[h, token];        SELECT removedStatus FROM	  noCommand => {	    Write[token]; Write[" does not exist."L];	    Format.CR[Write];	    errorsSeen ¬ TRUE};	  noProgram => {	    Write["Unable to unload "L]; Write[token];	    Format.CR[Write];	    errorsSeen ¬ TRUE};	  ENDCASE => NULL};      Cleanup[];      ENDLOOP;    END;    outcome ¬ IF errorsSeen THEN error ELSE normal};      UnloadMLoaderHandle: PROC [token: LONG STRING] RETURNS [BOOLEAN] = {    unloaded: BOOLEAN ¬ TRUE;    h: MLoader.Handle ¬ NIL;    h ¬ String.StringToLongNumber[      s: token, radix: 8 ! String.InvalidNumber => CONTINUE];    IF h = NIL THEN unloaded ¬ FALSE    ELSE MLoader.Unload[h ! MLoader.Error => {unloaded ¬ FALSE; CONTINUE}];    RETURN[unloaded]};      CallUserUnloadHelp: Exec.ExecProc = {      Exec.OutputProc[h][      "Unload <CommandName> will unload the specified command by looking up the unload procedure associated with the command, determined at the time the command was registered with the Executive. Unload <Number> will unload the configuration that was loaded with MLoader.Handle = Number."L]};  FindOriginal: --INTERNAL-- PROC [command: LONG STRING]    RETURNS [cIndex, rIndex: CARDINAL ¬ 0, inRenameTable: BOOLEAN ¬ FALSE] = {    t1, t2: Link;    -- cycle thru aliases to find original    -- if original is not there, it better be in the rename table    cIndex ¬ LookUp[command];    IF cIndex < commandCount THEN {      t1 ¬ @commands[cI[cIndex]];      t2 ¬ t1;      IF ~t1.original THEN t1 ¬ t1.link;      UNTIL t1 = t2 DO  -- look thru entire list of aliases        IF t1.original THEN {          cIndex ¬ LookUp[t1.name]; EXIT};        t1 ¬ t1.link;        ENDLOOP};    [rIndex, inRenameTable] ¬ LookUpInRenameTable[command];    IF inRenameTable THEN       cIndex ¬ GetcI[renamed[rIndex].indexInCommandTable]};	      LookUpInRenameTable: --INTERNAL-- PROC [command: LONG STRING]    RETURNS [rIndex: CARDINAL ¬ 0, inTable: BOOLEAN ¬ FALSE] = {    FOR i: CARDINAL IN [0..renameCount) DO       IF renamed[i].used THEN        IF String.Compare[command, renamed[i].name] = 0 THEN RETURN[i, TRUE];      ENDLOOP};      UnloadProgram: --INTERNAL-- PROC [    proc: Exec.ExecProc, h: Exec.Handle, name: LONG STRING]    RETURNS [rs: Exec.RemovedStatus ¬ ok] = {    ENABLE UNWIND => NULL;    Write: Format.StringProc ¬ Exec.OutputProc[h];    program: PROGRAM;    pHandle: MLoader.Handle;    Write["Unloading "L];    Write[name]; Write[" ... "L];    program ¬ Runtime.GlobalFrame[LOOPHOLE[proc]];    pHandle ¬ MLoader.HandleFromProgram[program];    IF pHandle # NIL THEN  {      MLoader.Unload[pHandle];      Write["Done. "L]}    ELSE RETURN[noProgram]};      RemoveCommand: PUBLIC --INTERNAL-- PROC [h: Exec.Handle, name: LONG STRING] = {    ENABLE UNWIND => NULL;    cIndex, rIndex : CARDINAL;    ptr: Link;    inRenameTable: BOOLEAN ¬ FALSE;    IF longestCommand < name.length THEN RETURN;    [cIndex, rIndex, inRenameTable] ¬ FindOriginal[name];    IF cIndex >= commandCount THEN RETURN;    -- remove this command, all aliases and entries in renamed and info tables    ptr ¬ @commands[cI[cIndex]];    IF inRenameTable THEN {      renamed[rIndex].used ¬ FALSE; heap.FREE[@renamed[rIndex].name]};    info[commands[cI[cIndex]].infoIndex].used ¬ FALSE;    heap.FREE[@commands[cI[cIndex]].name];    commands[cI[cIndex]].original ¬ TRUE;    commandCount ¬ commandCount - 1;    RemoveIndexEntry[cIndex];    RemoveAliases[ptr]};      AliasCommand: PUBLIC ENTRY PROC [old, new: LONG STRING]    RETURNS[ok: BOOLEAN] = {    ENABLE UNWIND => NULL;    oldIndex, newIndex: CARDINAL;     save: CARDINAL ¬ longestCommand;    ok ¬ TRUE;    IF longestCommand < old.length THEN RETURN[FALSE];    oldIndex ¬ LookUp[old];    AdjustBuffer[new.length];    newIndex ¬ LookUp[new];    IF oldIndex >= commandCount OR newIndex < commandCount THEN {      --old command not there or new command already there      AdjustBuffer[save]; RETURN[FALSE]};      newIndex ¬ AddCommandInternal[new, NIL];    oldIndex ¬ LookUp[old];  -- oldIndex may have changed in AddCommandInternal    commands[cI[newIndex]].original ¬ FALSE;    commands[cI[newIndex]].infoIndex ¬       commands[cI[oldIndex]].infoIndex;    IF commands[cI[oldIndex]].link = NIL THEN      commands[cI[newIndex]].link ¬ @commands[cI[oldIndex]]    ELSE commands[cI[newIndex]].link ¬       commands[cI[oldIndex]].link;    commands[cI[oldIndex]].link ¬ @commands[cI[newIndex]]};    AliasCommandProc: Exec.ExecProc = {    old, new: LONG STRING;    ok: BOOLEAN;    Cleanup: PROC = {      Heap.systemZone.FREE[@old]; Heap.systemZone.FREE[@new]; old ¬ new ¬ NIL};    BEGIN ENABLE UNWIND => Cleanup[];    [old, ] ¬ Exec.GetToken[h];    [new, ] ¬ Exec.GetToken[h];    IF String.StringLength[old] = 0 OR String.StringLength[new] = 0 THEN      outcome ¬ error    ELSE {      ok ¬ AliasCommand[old, new];      IF ok = TRUE THEN outcome ¬ normal      ELSE outcome ¬ error};    END;    Cleanup[]};      AliasHelp: Exec.ExecProc = {    Exec.OutputProc[h][      "AliasCommand takes a pair of command names delimited by spaces.  The first command of the pair represents an already-registered command, and the second has not been previously registered with the Executive.  AliasCommand will register the new command and point it to the same procedure as the old one points to."L]};      FindRenameSlot: INTERNAL PROC RETURNS [i: CARDINAL] = {    FOR i IN [0..renameCount] DO      IF renamed[i].used = FALSE THEN RETURN[i];      ENDLOOP};        AddToRenameTable: INTERNAL PROC [old, new: LONG STRING, index: CARDINAL] = {    --ASSUMPTION: only commands added by AddCommand appear in the rename table    -- index is in terms of commands, not cI    oldIsOriginal: BOOLEAN ¬ commands[index].original;    alreadyInTable: BOOLEAN ¬ FALSE;    newSlot: CARDINAL;    commands[index].original ¬ FALSE;    alreadyInTable ¬ LookUpInRenameTable[new].inTable;      IF alreadyInTable THEN       commands[index].original ¬ TRUE;  -- putting back an original    IF oldIsOriginal AND ~alreadyInTable THEN {      IF renameCount = renameTableSize THEN EnlargeRenameTable[];      newSlot ¬ FindRenameSlot[];      renamed[newSlot].name ¬ heap.NEW[StringBody [old.length]];      FOR i: CARDINAL IN [0..old.length) DO        renamed[newSlot].name[i] ¬ old[i] ENDLOOP;      renamed[newSlot].name.length ¬ old.length;      renamed[newSlot].indexInCommandTable ¬ index;      renamed[newSlot].used ¬ TRUE;      commands[index].original ¬ FALSE;      renameCount ¬ renameCount + 1}};      AdjustIndex: INTERNAL PROC [oldcIPos: CARDINAL, newName: LONG STRING]    RETURNS [commandIndex: CARDINAL] = {    newcIPos: CARDINAL;    commandIndex ¬ cI[oldcIPos];    FOR newcIPos IN [0..commandCount) DO      IF String.Compare[newName, commands[cI[newcIPos]].name] = -1 THEN EXIT;      ENDLOOP;    IF newcIPos < oldcIPos THEN      FOR i: CARDINAL DECREASING IN (newcIPos..oldcIPos] DO        cI[i] ¬ cI[i-1];  ENDLOOP    ELSE IF oldcIPos < newcIPos THEN      FOR i: CARDINAL IN [oldcIPos..newcIPos) DO        cI[i] ¬ cI[i+1];  ENDLOOP;    cI[newcIPos] ¬ commandIndex;    RETURN[commandIndex]};    RenameCommand: PUBLIC ENTRY PROC [old, new: LONG STRING]    RETURNS [ok: BOOLEAN] = {    ENABLE UNWIND => NULL;    oldIndex, newIndex, indexInCommandTable: CARDINAL;    --most indexes are in terms of cI.  However, in this case, since    --entries are re-sorted, renamed[i].indexInCommandTable is in terms of commands    save: CARDINAL ¬ longestCommand;    ok ¬ TRUE;    IF longestCommand < old.length THEN RETURN[FALSE];    AdjustBuffer[new.length];    oldIndex ¬ LookUp[old];    newIndex ¬ LookUp[new];    IF oldIndex >= commandTableSize OR newIndex < commandCount THEN {      --old command not there or new command already there      AdjustBuffer[save]; RETURN[FALSE]};      IF old.length # new.length THEN {      heap.FREE[@commands[cI[oldIndex]].name];        commands[cI[oldIndex]].name ¬ heap.NEW[StringBody [new.length]]};    FOR i: CARDINAL IN [0..new.length) DO      commands[cI[oldIndex]].name[i] ¬ new[i] ENDLOOP;    commands[cI[oldIndex]].name.length ¬ new.length;    indexInCommandTable ¬ AdjustIndex[oldIndex, new];    AddToRenameTable[old, new, indexInCommandTable]};    RenameCommandProc: Exec.ExecProc = {    old, new: LONG STRING;    ok: BOOLEAN;    Cleanup: PROC = {      Heap.systemZone.FREE[@old]; Heap.systemZone.FREE[@new];      old ¬ new ¬ NIL};    BEGIN ENABLE UNWIND => Cleanup[];    [old, ] ¬ Exec.GetToken[h];    [new, ] ¬ Exec.GetToken[h];    IF String.StringLength[old] = 0 OR String.StringLength[new] = 0 THEN      outcome ¬ error    ELSE {      ok ¬ RenameCommand[old, new];      IF ok = TRUE THEN outcome ¬ normal      ELSE outcome ¬ error};    END;    Cleanup[]};      RenameCommandHelp: Exec.ExecProc = {    Exec.OutputProc[h][      "ChangeCommandName takes a pair of command names delimited by spaces. The first command in the pair will be renamed to the second"L]};      MaxStringLength: CARDINAL = 100;    ResolveConflict: PROC[command: LONG STRING, old: CARDINAL]     RETURNS [new: CARDINAL] = {    -- try resolving by adding a ".~"    newName: LONG STRING ¬ [MaxStringLength];    twiddle: LONG STRING = ".~"L;    IF String.Length[command] > (MaxStringLength-twiddle.length) THEN RETURN[old];    String.AppendString[newName, command];    String.AppendString[newName, twiddle];    new ¬ LookUp[newName];    };      LookupCommand: PUBLIC ENTRY PROC [command: LONG STRING]    RETURNS [      name: LONG STRING ¬ NIL, proc, help, unload: Exec.ExecProc ¬ NIL,       didExpand: BOOLEAN ¬ FALSE, clientData: LONG POINTER ¬ NIL] = {    ENABLE UNWIND => NULL;    index: CARDINAL;    IF longestCommand < command.length THEN RETURN;    index ¬ LookUp[command];    IF index = StringLookUp.ambiguous THEN       index ¬ ResolveConflict[command, index];    IF index >= commandCount THEN RETURN;    name ¬ commands[cI[index]].name;    proc ¬ info[commands[cI[index]].infoIndex].proc;    help ¬ info[commands[cI[index]].infoIndex].help;    unload ¬ info[commands[cI[index]].infoIndex].unload;    clientData ¬ info[commands[cI[index]].infoIndex].clientData;    didExpand ¬ command.length # commands[cI[index]].name.length};  EnumerateCommands: PUBLIC ENTRY PROC [    userProc: PROC [      name: LONG STRING, proc, help, unload: Exec.ExecProc,      clientData: LONG POINTER] RETURNS [stop: BOOLEAN]] = {    ENABLE UNWIND => NULL;    i: CARDINAL;    infoIndex: CARDINAL;    FOR i IN [0..commandCount) DO      infoIndex ¬ commands[cI[i]].infoIndex;      IF userProc[commands[cI[i]].name, info[infoIndex].proc,         info[infoIndex].help, info[infoIndex].unload,         info[infoIndex].clientData]        THEN EXIT; ENDLOOP};  EnlargeCommandTable: INTERNAL PROC = {    newCommands: LONG POINTER TO CommandTableSeq ¬ heap.NEW[      CommandTableSeq [commandTableSize + tableInc]];    newIndex: LONG POINTER TO CommandIndexSeq ¬ heap.NEW[      CommandIndexSeq [commandTableSize + tableInc]];    Inline.LongCOPY[      from: commands, nwords: commandTableSize*SIZE[CommandTableEntry],      to: newCommands];    Inline.LongCOPY[      from: cI, nwords: commandTableSize*SIZE[CARDINAL],      to: newIndex];    heap.FREE[@cI];    FOR i: CARDINAL IN [commandTableSize..commandTableSize + tableInc) DO      newCommands[i] ¬ [];      newIndex[i] ¬ CARDINAL.LAST;      ENDLOOP;    commandTableSize ¬ commandTableSize + tableInc;    commands ¬ newCommands;    cI ¬ newIndex};      EnlargeInfoTable: INTERNAL PROC = {    newInfo: LONG POINTER TO InfoTableSeq ¬      heap.NEW[InfoTableSeq [infoTableSize + tableInc]];    Inline.LongCOPY[      from: info, nwords: infoTableSize*SIZE[InfoTableEntry], to: newInfo];    heap.FREE[@info];    FOR i: CARDINAL IN [infoTableSize..infoTableSize + tableInc) DO      newInfo[i].used ¬ FALSE; ENDLOOP;    infoTableSize ¬ infoTableSize + tableInc;    info ¬ newInfo};      EnlargeRenameTable: INTERNAL PROC = {    newRename: LONG POINTER TO RenameTableSeq ¬      heap.NEW[RenameTableSeq [renameTableSize + renameInc]];    Inline.LongCOPY[      from: renamed, nwords: renameTableSize*SIZE[RenameTableEntry],       to: newRename];    heap.FREE[@renamed];    FOR i: CARDINAL IN [renameTableSize..renameTableSize + tableInc) DO      newRename[i].used ¬ FALSE; ENDLOOP;    renameTableSize ¬ renameTableSize + renameInc;    renamed ¬ newRename};        --Help procedure definitions  HelpHelp: Exec.ExecProc = {    out: Format.StringProc = Exec.OutputProc[h];    EnumerateHelpsPass1: PROC [      name: LONG STRING, proc, help, unload: Exec.ExecProc,      clientData: LONG POINTER]      RETURNS [stop: BOOLEAN] = {      IF (help # NIL) AND (help # HelpHelp) THEN {        out[name]; out[" "L]};      RETURN[Exec.CheckForAbort[h]]};    EnumerateHelpsPass2: PROC [      name: LONG STRING, proc, help, unload: Exec.ExecProc,      clientData: LONG POINTER]      RETURNS [stop: BOOLEAN] = {      IF (help = NIL) AND (~String.EquivalentString[name, "Help.~"]) THEN {        out[name]; out[" "L]};      RETURN[Exec.CheckForAbort[h]]};    DoEnumerate: PROC = {      out["The following commands have HELP procedures:\n\n"L];      EnumerateCommands[EnumerateHelpsPass1];      out["\n\nThe following commands do not have HELP procedures:\n\n"L];      EnumerateCommands[EnumerateHelpsPass2];      Format.CR[out]};    DoEnumerate[]};  -- HelpHelp  CallHelp: Exec.ExecProc = {    lProc: Exec.ExecProc;    hProc: Exec.ExecProc;    cd: LONG POINTER;    out: Format.StringProc ¬ Exec.OutputProc[h];    nextToken, s: LONG STRING ¬ NIL;    sawToken: BOOLEAN ¬ FALSE;    [nextToken, s] ¬ Exec.GetToken[h];    s ¬ Exec.FreeTokenString[s];    WHILE nextToken # NIL DO      sawToken ¬ TRUE;      [proc: lProc, help: hProc, clientData: cd] ¬ LookupCommand[nextToken];      IF hProc # NIL THEN [] ¬ hProc[h, cd]       ELSE {    --unknown command or no help available        out[" No help for "]; out[nextToken]};      nextToken ¬ Exec.FreeTokenString[s: nextToken];      Format.CR[Exec.OutputProc[h]];      [token: nextToken] ¬ Exec.GetToken[h];      ENDLOOP;    IF ~sawToken THEN [] ¬ HelpHelp[h]};  --CallHelp  HelpUnload: Exec.ExecProc = {    Exec.OutputProc[h][      "Unload takes a list of command names delimited by spaces, unloads the program associated with each command, and removes each command from the Executive"L]};  InitExec: PROC = {    FOR i: CARDINAL IN [0..commandTableSize) DO      commands[i] ¬ [];      info[i].used ¬ FALSE;      cI[i] ¬ CARDINAL.LAST;      ENDLOOP;    FOR i: CARDINAL IN [0..renameTableSize) DO      renamed[i].used ¬ FALSE; ENDLOOP;    AddCommand["Help.~"L, CallHelp, HelpHelp];    AddCommand["AliasCommand.~"L, AliasCommandProc, AliasHelp];    AddCommand["ChangeCommandName.~"L, RenameCommandProc, RenameCommandHelp];    AddCommand["Unload.~"L, CallUserUnloadProc, CallUserUnloadHelp]};  InitExec[];  END.
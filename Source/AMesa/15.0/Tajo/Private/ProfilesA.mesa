-- File: ProfilesA.mesa - last edit:-- Riggle.PA           29-Aug-86 11:44:38-- bjd                 24-May-85 14:05:03-- PXK    :	 6-Apr-82 19:00:14-- SXW   :	12-Jul-81 11:32:55-- Mark:	29-May-81 18:20:58-- BXM  :	13-Nov-81 15:28:03-- RXR   :	 4-Dec-81 16:47:42-- SXS   :	17-Mar-82 15:50:27-- RXJ     :	28-Sep-82 15:27:00-- AXD    :	30-Sep-82 23:30:14-- LXR    :	28-Oct-82 16:58:15-- AOF:		19-Oct-84 10:48:16-- DWR    	 6-Mar-85 10:02:26-- DSC  : 	 5-Mar-85 17:01:04-- Copyright (C) 1981, 1982, 1984, 1985, 1986 by Xerox Corporation. All rights reserved. DIRECTORY  Atom USING [ATOM, MakeAtom],  AtomicProfile USING [FetchStringProc, SetString],  Auth USING [AuthenticationError, CallError, CallProblem, ConversationHandle, Flavor, FreeIdentity, GetIdentityDetails, IdentityHandle, MakeIdentity],  CH USING [ConversationHandle, FreeConversationHandle, LookupDistinguishedName, MakeConversationHandle, maxDomainNameLength, maxOrgNameLength, maxLocalNameLength, ReturnCode],  Event USING [primaryCredentials, tajoDefaults],  EventTypes USING [    debugging, domain, fileServerProtocol, librarian, organization,    primaryCredentials, registry],  Heap USING [systemZone],  NSName USING [AppendNameToString, MakeName, maxLocalLength, Name, NameRecord, String],  NSString USING [AppendToMesaString, FreeString, MakeString, String, StringFromMesaString],  Profile USING [    BalanceBeamChoice, FileServerProtocol, noChange, Place, Qualification],  ProfileExtra USING [SetPositionBalanceBeamChoice, CaretShapes],  Runtime USING [UnboundProcedure],  String USING [AppendChar, AppendString, AppendSubString, Empty, Length, Replace, SubStringDescriptor],  Supervisor USING [NotifyDirectSubsystems],  TajoOps USING [],  ToolWindow USING [State];ProfilesA: MONITOR     IMPORTS Atom, AtomicProfile, Auth, CH, Event, Heap, NSName, NSString, Runtime, String, Supervisor    EXPORTS Profile, ProfileExtra, TajoOps =  BEGIN  strong: Auth.IdentityHandle ¬ NIL;  simple: Auth.IdentityHandle ¬ NIL;    z: UNCOUNTED ZONE = Heap.systemZone;  S: PROC [s: LONG STRING] RETURNS [NSString.String] = INLINE {    RETURN[NSString.StringFromMesaString[s]]};      balanceBeamChoice: PUBLIC Profile.BalanceBeamChoice ¬ always;  setPositionBalanceBeamChoice: PUBLIC ProfileExtra.SetPositionBalanceBeamChoice ¬ top;  caretShape: PUBLIC ProfileExtra.CaretShapes ¬ triangle;  debugging: PUBLIC BOOLEAN ¬ FALSE;  defaultDomain: LONG STRING ¬ NIL;  defaultOrganization: LONG STRING ¬ NIL;  defaultFileServerProtocol: PUBLIC Profile.FileServerProtocol ¬ ns;  defaultRegistry: LONG STRING ¬ NIL;  initialToolStateDefault: PUBLIC ToolWindow.State ¬ active;  librarianNamePrefix: LONG STRING ¬ NIL;  librarianNameSuffix: LONG STRING ¬ NIL;  librarian: LONG STRING ¬ NIL;  place: PUBLIC Profile.Place ¬ unknown;  swapCtrlAndCommand: PUBLIC BOOLEAN ¬ FALSE;  userName: LONG STRING ¬ NIL;  userPassword: LONG STRING ¬ NIL;  -- For a reserved AtomicProfile Atom.  fullUserName: LONG STRING ¬ NIL;  noChange: LONG STRING = Profile.noChange;    GetDefaultDomain: PUBLIC ENTRY PROC [proc: PROC [LONG STRING]] = {    ENABLE UNWIND => NULL;    proc[defaultDomain]};    GetDefaultOrganization: PUBLIC ENTRY PROC [proc: PROC [LONG STRING]] = {    ENABLE UNWIND => NULL;    proc[defaultOrganization]};    GetDefaultRegistry: PUBLIC ENTRY PROC [proc: PROC [LONG STRING]] = {    ENABLE UNWIND => NULL;    proc[defaultRegistry]};    GetLibrarianNames: PUBLIC ENTRY PROC [    proc: PROC [prefix, suffix: LONG STRING]] = {    ENABLE UNWIND => NULL;    proc[prefix: librarianNamePrefix, suffix: librarianNameSuffix]};    GetLibrarian: PUBLIC ENTRY PROC [proc: PROC [LONG STRING]] = {    ENABLE UNWIND => NULL;    proc[librarian]};    GetUser: PUBLIC PROC [proc: PROC [name, password: LONG STRING],    qualification: Profile.Qualification] = {    name: LONG STRING ¬ NIL;    Enter: ENTRY PROC = {      ENABLE UNWIND => IF name # NIL THEN z.FREE[@name];      IF qualification = none THEN proc[userName, userPassword]      ELSE {        name ¬ z.NEW[StringBody[          String.Length[userName] + 1 + (SELECT qualification FROM	      registry => String.Length[defaultRegistry],	      clearinghouse => 	        String.Length[defaultDomain] + 		String.Length[defaultOrganization] + 1,	      ENDCASE => 0)]];        Qualify[	  token: userName, newToken: name, qualification: qualification];        proc[name, userPassword]}};    Enter[];    IF name # NIL THEN z.FREE[@name]};    SetInitialToolStateDefault: PUBLIC ENTRY PROC [state: ToolWindow.State] = {    initialToolStateDefault ¬ state};      SetPlace: PUBLIC ENTRY PROC [p: Profile.Place] = {place ¬ p};    SetBalanceBeamChoice: PUBLIC ENTRY PROC [choice: Profile.BalanceBeamChoice] = {    balanceBeamChoice ¬ choice};       SetSetPositionBalanceBeamChoice: PUBLIC ENTRY PROC [choice: ProfileExtra.SetPositionBalanceBeamChoice] = {    setPositionBalanceBeamChoice ¬ choice};           SetCaretShape: PUBLIC ENTRY PROC [choice: ProfileExtra.CaretShapes] = {    caretShape ¬ choice};           SetDebugging: PUBLIC PROC [debug: BOOLEAN] = {    Entry: ENTRY PROC = {debugging ¬ debug};    Entry[];     Supervisor.NotifyDirectSubsystems[      event: [EventTypes.debugging], which: clients,       subsystem: Event.tajoDefaults]};        SetDefaultDomain: PUBLIC PROC [domain: LONG STRING] = {    Entry: ENTRY PROC = {      ENABLE UNWIND => NULL;      String.Replace[        to: @defaultDomain, from: domain, z: z]};    Entry[];     Supervisor.NotifyDirectSubsystems[      event: [EventTypes.domain], which: clients,       subsystem: Event.tajoDefaults]};      SetDefaultOrganization: PUBLIC PROC [organization: LONG STRING] = {    Entry: ENTRY PROC = {      ENABLE UNWIND => NULL;      String.Replace[        to: @defaultOrganization, from: organization, z: z]};    Entry[];     Supervisor.NotifyDirectSubsystems[      event: [EventTypes.organization], which: clients,       subsystem: Event.tajoDefaults]};      SetDefaultRegistry: PUBLIC PROC [registry: LONG STRING] = {    Entry: ENTRY PROC = {      ENABLE UNWIND => NULL;      String.Replace[to: @defaultRegistry, from: registry, z: z]};    Entry[];     Supervisor.NotifyDirectSubsystems[      event: [EventTypes.registry], which: clients,       subsystem: Event.tajoDefaults]};      SetFileServerProtocol: PUBLIC PROC [fsp: Profile.FileServerProtocol] = {    Entry: ENTRY PROC = {defaultFileServerProtocol ¬ fsp};    Entry[];     Supervisor.NotifyDirectSubsystems[      event: [EventTypes.fileServerProtocol], which: clients,       subsystem: Event.tajoDefaults]};      SetLibrarian: PUBLIC PROC [name, prefix, suffix: LONG STRING] = {    Entry: ENTRY PROC = {      ENABLE UNWIND => NULL;      MaybeReplace[old: @librarian, new: name];      MaybeReplace[old: @librarianNamePrefix, new: prefix];      MaybeReplace[old: @librarianNameSuffix, new: suffix]};    Entry[];     Supervisor.NotifyDirectSubsystems[      event: [EventTypes.librarian], which: clients,       subsystem: Event.tajoDefaults]};      SetSwapCtrlAndCommand: PUBLIC ENTRY PROC [swap: BOOLEAN] = {    swapCtrlAndCommand ¬ swap};      -- AtomicProfile fetch demon procedure.  GetName: ENTRY AtomicProfile.FetchStringProc = {    -- For CH.    convH: CH.ConversationHandle;    ok: BOOLEAN ¬  FALSE;    authCallError: Auth.CallProblem;    -- For Auth    maybeAlias: NSName.Name ¬ NSName.MakeName[z: z];    -- Result of GetIdentityDetails    nss: NSString.String ¬ NSString.MakeString[z: z, bytes: NSName.maxLocalLength];    -- Convert that to a Mesa String.    ms: LONG STRING ¬ [NSName.maxLocalLength];    rc: CH.ReturnCode;    CleanUp: PROCEDURE = {      NSString.FreeString[z: z, s: nss];      CH.FreeConversationHandle[conversation: @convH, heap: z];    };    BEGIN      ENABLE UNWIND =>  CleanUp[];    [conversation: convH, ok: ok, authCallError: authCallError] ¬ CH.MakeConversationHandle[identity: simple, heap: z];    IF ~ok THEN {      --Put.Line[NIL, "can't make MakeConversationHandle."L];      GOTO bad};    [name: maybeAlias] ¬ Auth.GetIdentityDetails[identity: simple];     rc ¬ CH.LookupDistinguishedName[conversation: convH, name: maybeAlias, distingName: maybeAlias];    IF rc.code # done THEN {     --Put.Line[NIL, "can't GetIdentityDetails."L];     GOTO bad};    nss ¬ NSName.AppendNameToString[nss, maybeAlias];    NSString.AppendToMesaString[ms, nss];    String.Replace[@fullUserName, ms, z];    CleanUp[];    RETURN[fullUserName, valid]    EXITS    bad => {     CleanUp[];     RETURN [NIL, invalid]};    END};    AuthOutcome: TYPE = MACHINE DEPENDENT {invalidName(0), invalidPassword(1), authServiceUnavailable(2), authProblem(3), spare(4), (LAST[CARDINAL])}; -- This must be defined in AtomicProfile in Mesa 13.0.  A code of this type is passed on to the HeraldWindow who posts appropriate errors when authentication fails.  okay: AuthOutcome = LAST[AuthOutcome];     SetUser: PUBLIC PROC [name, password: LONG STRING ¬ noChange] = {    authOutcome: AuthOutcome ¬ okay;    tempSimple, tempStrong: Auth.IdentityHandle ¬ NIL;    domain: LONG STRING = [CH.maxDomainNameLength];    org: LONG STRING = [CH.maxOrgNameLength];    localName: LONG STRING = [CH.maxLocalNameLength];    localPassword: LONG STRING = [CH.maxLocalNameLength];    Enter: ENTRY PROC = {      ENABLE UNWIND => NULL;      MaybeReplace[old: @userName, new: name];      MaybeReplace[old: @userPassword, new: password];      AtomicProfile.SetString[        atom: Atom.MakeAtom["fullUserName"L], string: NIL,        immutable: FALSE, fetchDemon: GetName];      IF simple # NIL THEN Auth.FreeIdentity[@simple, z];      IF strong # NIL THEN Auth.FreeIdentity[@strong, z];      simple ¬ tempSimple;  strong ¬ tempStrong;    };    String.AppendString[domain, defaultDomain];    String.AppendString[org, defaultOrganization];    String.AppendString[      localName, IF name = noChange THEN userName ELSE name];    String.AppendString[      localPassword, IF password = noChange THEN userPassword ELSE password];    -- call MakeID outside the monitor to allow other profile clients in while we're off to the auth service.    [tempStrong, authOutcome] ¬ MakeID[      flavor: strong, defaultOrganization: org, defaultDomain: domain,      userName: localName, userPassword: localPassword]; --  we don't care as much about strong right now, so overwrite with results of simple;    [tempSimple, authOutcome] ¬ MakeID[      flavor: simple, defaultOrganization: org, defaultDomain: domain,      userName: localName, userPassword: localPassword];    Enter[ ! Runtime.UnboundProcedure => CONTINUE];    Supervisor.NotifyDirectSubsystems[      event: [EventTypes.primaryCredentials], which: clients,       subsystem: Event.primaryCredentials,      eventData: LONG[LOOPHOLE[authOutcome]]]};  MakeID: PROC [    flavor: Auth.Flavor, defaultOrganization, defaultDomain,    userName, userPassword: LONG STRING]    RETURNS [id: Auth.IdentityHandle, outcome: AuthOutcome ¬ okay] = {    myName: NSName.NameRecord ¬ [      org:  S[defaultOrganization],      domain: S[defaultDomain],      local: S[userName]];    {    SELECT TRUE FROM -- authenticate unless password, domain or organization empty      String.Empty[userPassword] => {outcome ¬ invalidPassword; GOTO dontAuth};      String.Empty[defaultDomain] OR        String.Empty[defaultOrganization] => {	  outcome ¬ invalidName; GOTO dontAuth};      ENDCASE;    id ¬ Auth.MakeIdentity[      myName: @myName,      password: S[userPassword],      z: z,      style: flavor,      dontCheck: FALSE !        Auth.CallError =>  {	outcome ¬ SELECT reason FROM	  tooBusy, cannotReachAS, keysUnavailable => authServiceUnavailable,	  strongKeyDoesNotExist, simpleKeyDoesNotExist => invalidName,	  badKey => invalidPassword,	  ENDCASE => authProblem;	GOTO dontAuth};	Auth.AuthenticationError => {	outcome ¬ SELECT reason FROM	   credentialsInvalid=> invalidName,	  verifierInvalid => invalidPassword,	  ENDCASE => authProblem;	GOTO dontAuth}];       EXITS        dontAuth =>	  id ¬ Auth.MakeIdentity[	    myName: @myName, password: S[userPassword],	    z: z, style: flavor, dontCheck: TRUE]}};      GetID: PUBLIC PROC [flavor: Auth.Flavor, proc: PROC [id: Auth.IdentityHandle]] =    BEGIN    Enter: ENTRY PROCEDURE = {      ENABLE UNWIND => NULL;      SELECT flavor FROM	simple => proc[simple];	strong => proc[strong];	ENDCASE => ERROR};    Enter[];    END;  Qualify: PUBLIC PROC [    token, newToken: LONG STRING, qualification: Profile.Qualification] = {    namePart: CARDINAL ¬ String.Length[token];    currentQual: Profile.Qualification ¬ none;    octalAddress: BOOLEAN ¬ TRUE; -- only '0..'7 and '# allowed    ss: String.SubStringDescriptor;    chChar: CHARACTER = ':;    regChar: CHARACTER = '.;    IF String.Length[token] = 0 THEN RETURN;    FOR i: CARDINAL IN [0..token.length) DO       SELECT token[i] FROM         regChar => {namePart ¬ i; currentQual ¬ registry};  -- look for last dot	 chChar => {namePart ¬ i; currentQual ¬ clearinghouse; EXIT}; -- first :	 IN['0..'7], '# => NULL;	 ENDCASE => octalAddress ¬ FALSE;       ENDLOOP;    IF currentQual = qualification OR octalAddress THEN {      String.AppendString[newToken, token]; RETURN};    ss ¬ [base: token, offset: 0, length: namePart];    String.AppendSubString[newToken, @ss];    SELECT qualification FROM      none => NULL;      registry =>        IF String.Length[defaultRegistry] > 0 THEN {	  String.AppendChar[newToken, regChar];	  String.AppendString[newToken, defaultRegistry]};      clearinghouse =>        IF String.Length[defaultDomain] > 0 OR 	   String.Length[defaultOrganization] > 0 THEN {	  String.AppendChar[newToken, chChar];	  String.AppendString[newToken, defaultDomain];	  String.AppendChar[newToken, chChar];	  String.AppendString[newToken, defaultOrganization]};      ENDCASE};  MaybeReplace: PROC [new: LONG STRING, old: LONG POINTER TO LONG STRING] = {    IF new # noChange THEN String.Replace[to: old, from: new, z: z]};      StartProfiles: PUBLIC PROCEDURE =  {};  -- don't need this anymore; take out when we can change TajoOps.    END.LOGDWR    	10-Jan-85 14:58:47  added setPositionBalanceBeamChoiceDSC   	22-Feb-85 13:24:43  added GetName and SetString for AtomicProfile.DSC   	 5-Mar-85 17:01:11  fixed bug where I freed data returned from GetIdentityDetails.DWR    	 6-Mar-85 10:02:03  Changed default for setPositionBalanceBeamChoice to top.BJD	 3-May-85 11:48:15	authenticate id at logon
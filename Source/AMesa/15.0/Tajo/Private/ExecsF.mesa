-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved. -- File: ExecsF.mesa - last edited by:-- RXR   :	 18-May-83 16:50:26-- LXR    :	 17-Jan-84 11:17:37DIRECTORY  Ascii USING [CR, NUL],  Caret USING [ActOn],  Environment USING [Block, bytesPerWord],  Exec USING [AddCommand, ExecProc, GetChar, Handle, Object, Outcome, OutputProc],  ExecInternal USING [    bootSwitches, clientVolume, Do, LegalClientVolume, volumeLabel],  ExecUtilities USING [],  Expand USING [ExpandToTokens],  File USING [    Create, Error, File, MakePermanent, nullFile, Unknown],  FileStream USING [Create, InvalidHandle, InvalidOperation],  Format USING [Char, CR, Line, Octal, StringProc],  Heap USING [systemZone],  HeraldWindow USING [AlwaysConfirm, BootFromVolumeID, DefaultPost],  MesaDEFileTypes USING [tCascadeNub],  MFile USING [Acquire, dontRelease, Error, GetType, Handle, Release, Type],  MVolume USING [CloseAborted],  SpecialMFile USING [GetCapaWithAccess],  Stream USING [Handle, PutBlock, PutChar],  String USING [    AppendExtensionIfNeeded, CopyToNewString, EmptyString, Replace],  System USING [Switches],  Token USING [Filtered, FilterProcType, Handle, Line, Object],  UserInput USING [    CreatePeriodicNotify, GetDefaultWindow, nullPeriodicNotify,    PeriodicNotifyHandle, PeriodicProcType],  Volume USING [    Close, GetStatus, ID, InsertRootFile, LookUpRootFile, NeedsScavenging,    NotOpen, nullID, Open, RemoveRootFile, RootDirectoryError, systemID];    ExecsF: MONITOR  IMPORTS    Caret, Exec, ExecInternal, Expand, File, FileStream, Format, Heap,    HeraldWindow, MFile, MVolume, SpecialMFile, Stream, String, Token,    UserInput, Volume  EXPORTS ExecInternal, ExecUtilities =  BEGIN    -- Variables  z: UNCOUNTED ZONE = Heap.systemZone;    periodic: UserInput.PeriodicNotifyHandle ¬ UserInput.nullPeriodicNotify;  runWrite: Format.StringProc ¬ NIL;  runString: LONG STRING ¬ NIL;  FileNameError: ERROR [name: LONG STRING] = CODE;  ClientVolumeError: ERROR = CODE;    RunClient: PUBLIC ENTRY PROCEDURE [    h: Exec.Handle, clientData: LONG POINTER ¬ NIL]    RETURNS [outcome: Exec.Outcome ¬ normal] =    BEGIN    ENABLE UNWIND => NULL;    get: PROCEDURE [Token.Handle] RETURNS[CHARACTER] = {RETURN[Exec.GetChar[h]]};    t: Token.Object ¬ [getChar: get, break: Ascii.NUL];    IF periodic = UserInput.nullPeriodicNotify THEN {      runString ¬ Token.Filtered[@t, NULL, Token.Line];      runWrite ¬ Exec.OutputProc[h];      periodic ¬ UserInput.CreatePeriodicNotify[        CallClient, UserInput.GetDefaultWindow[], 0]};    END;      RunClientPrograms: PUBLIC ENTRY PROCEDURE [    cmdLine: LONG STRING, write: Format.StringProc] =    BEGIN    ENABLE UNWIND => NULL;    IF String.EmptyString[cmdLine] THEN RETURN;    IF periodic = UserInput.nullPeriodicNotify THEN {      runString ¬ String.CopyToNewString[cmdLine, z];      runWrite ¬ write;      periodic ¬ UserInput.CreatePeriodicNotify[        CallClient, UserInput.GetDefaultWindow[], 0]};    END;    CallClient: ENTRY UserInput.PeriodicProcType =    BEGIN    ENABLE UNWIND => NULL;    periodic ¬ UserInput.nullPeriodicNotify;    RunInternal[];    -- when next inloaded, CoPilot will raise a signal causing UNWIND, unlocking monitor    END;  FindSlash: PROC [s: LONG STRING] RETURNS [position: CARDINAL] = {    i: CARDINAL;    FOR i IN [0..s.length) DO IF s[i] = '/ THEN RETURN[i]; ENDLOOP;    RETURN[s.length]};  -- no slash  FindCopySwitch: PROC [item: LONG STRING, slashPos: CARDINAL, oldCopySwitch: BOOLEAN]    RETURNS [copySwitch: BOOLEAN] = {    sense: BOOLEAN ¬ TRUE;    copySwitch ¬ oldCopySwitch;    FOR i: CARDINAL IN [slashPos..item.length) DO      SELECT item[i] FROM        '~, '- => {sense ¬ ~sense; LOOP};        'c => copySwitch ¬ sense;        ENDCASE => NULL;      sense ¬ TRUE;      ENDLOOP;    RETURN[copySwitch]};      PutCommandInFile: PROCEDURE [] =    BEGIN    stream: Stream.Handle ¬ NIL;    i: CARDINAL ¬ 0;    writeFileID: BOOLEAN ¬ TRUE;    clientID: Volume.ID;    openedVolume: BOOLEAN ¬ FALSE;        Get: PROC =       BEGIN      clientID ¬ ExecInternal.clientVolume;      END;      Write: Format.StringProc = {      i: CARDINAL;      FOR i IN [0..s.length) DO Stream.PutChar[stream, s[i]]; ENDLOOP};          PostMsg: PROCEDURE[s: LONG STRING] = INLINE        BEGIN	Format.Line[HeraldWindow.DefaultPost, s];	END;	    OpenVolume: PROCEDURE =      BEGIN      SELECT clientID FROM         Volume.nullID => {PostMsg["No client volume specified.\n"L]; ERROR ClientVolumeError};         Volume.systemID => {PostMsg["Client volume cannot be current system volume.\n"L]; ERROR ClientVolumeError};        ENDCASE => SELECT Volume.GetStatus[clientID] FROM          openReadWrite => RETURN;	  unknown, partiallyOnLine, closedAndInconsistent => {            PostMsg["Client volume is unknown or inconsistent!\n"L];	    ERROR ClientVolumeError};	  ENDCASE;      Volume.Open[clientID ! Volume.NeedsScavenging => -- opens read-write for lower types	 {PostMsg["Client volume needs scavenging!\n"L]; ERROR ClientVolumeError}];      openedVolume ¬ TRUE;      END;          MyGetStream: PROCEDURE RETURNS [sh: Stream.Handle] =       BEGIN      file: File.File ¬ File.nullFile;      cantClose: BOOLEAN ¬ FALSE;      Cleanup: PROC =        BEGIN	IF sh # NIL THEN sh ¬ NIL;	IF openedVolume THEN  {	  Volume.RemoveRootFile[MesaDEFileTypes.tCascadeNub, clientID !            Volume.RootDirectoryError, Volume.NeedsScavenging, 	    Volume.NotOpen => CONTINUE];	  Volume.Close[	  clientID ! Volume.NeedsScavenging, Volume.NotOpen => CONTINUE;	    MVolume.CloseAborted => {cantClose ¬ TRUE; CONTINUE}];	  IF cantClose THEN PostMsg["Cannot close client volume!\n"L]};	END;      retry: BOOLEAN ¬ FALSE;      BEGIN      {ENABLE File.Error, FileStream.InvalidHandle,         FileStream.InvalidOperation, ClientVolumeError,	 Volume.RootDirectoryError => GOTO done;      OpenVolume[];      DO        {ENABLE Volume.RootDirectoryError => CONTINUE;	IF retry THEN Volume.RemoveRootFile[	  MesaDEFileTypes.tCascadeNub, clientID]        ELSE file ¬ Volume.LookUpRootFile[	  MesaDEFileTypes.tCascadeNub, clientID]};        IF file = File.nullFile OR retry THEN {           --file is not previously there or got a bogus one first time thru.	  retry ¬ FALSE;          file ¬ File.Create[	    clientID, 1, MesaDEFileTypes.tCascadeNub];          Volume.InsertRootFile[MesaDEFileTypes.tCascadeNub, file];	  File.MakePermanent[file]};        sh ¬ FileStream.Create[file ! File.Unknown => {retry ¬ TRUE; LOOP}];	EXIT;	ENDLOOP};      EXITS done => Cleanup[];      END;      END;          RecordMyVolume: PROCEDURE =      BEGIN      vol: Volume.ID ¬ Volume.systemID;      block: Environment.Block ¬ [        LOOPHOLE[LONG[@vol]], 0, Environment.bytesPerWord*SIZE[Volume.ID]];      Stream.PutBlock[stream, block];      END;      ProcessToken: PROCEDURE [item: LONG STRING] RETURNS [BOOLEAN] = {      Seven: TYPE = RECORD [a, b, c, d, e, f, g: UNSPECIFIED];      file: File.File;      fileInfo: POINTER TO Seven = @LOOPHOLE[file, Seven];      fh: MFile.Handle ¬ NIL;      fileName: LONG STRING;      slashPos, j: CARDINAL;            IF item = NIL THEN RETURN[TRUE];      -- make local copy of item for modifing length      fileName ¬ String.CopyToNewString[item, z];        BEGIN ENABLE UNWIND => z.FREE[@fileName];      slashPos ¬ FindSlash[fileName];      fileName.length ¬ slashPos;      IF fileName.length = 0 THEN {  -- output global switches        Format.Line[Write, item];        Format.Char[Write, ' ];        writeFileID ¬ FindCopySwitch[item, slashPos, writeFileID];        RETURN[FALSE]};	      IF ~FindCopySwitch[item, slashPos, writeFileID] THEN {        [] ¬ String.AppendExtensionIfNeeded[@fileName, ".bcd"L, z];	Format.Char[Write, '(];  -- signifies file name instead of ID        Write[fileName]}      ELSE {        fh ¬ MFile.Acquire[          fileName, anchor, MFile.dontRelease ! MFile.Error => CONTINUE];	IF fh # NIL AND MFile.GetType[fh] = directory THEN {	    MFile.Release[fh];	    fh ¬ NIL};        IF fh = NIL AND String.AppendExtensionIfNeeded[@fileName, ".bcd"L, z]	  THEN fh ¬ MFile.Acquire[fileName, anchor, MFile.dontRelease !	                           MFile.Error => CONTINUE];	IF fh = NIL THEN ERROR FileNameError[fileName];	file ¬ SpecialMFile.GetCapaWithAccess[fh];        Format.Octal[Write, fileInfo.a];        Format.Char[Write, ' ];        Format.Octal[Write, fileInfo.b];	Format.Char[Write, ' ];	Format.Octal[Write, fileInfo.c];        Format.Char[Write, ' ];	Format.Octal[Write, fileInfo.d];        Format.Char[Write, ' ];	Format.Octal[Write, fileInfo.e];        Format.Char[Write, ' ];	Format.Octal[Write, fileInfo.f];	Format.Char[Write, ' ];	Format.Octal[Write, fileInfo.g]};	      -- output local switches      FOR j IN [slashPos..item.length) DO Format.Char[Write, item[j]] ENDLOOP;      END;      Format.Char[Write, ' ];      z.FREE[@fileName];      IF fh # NIL THEN MFile.Release[fh];      RETURN[FALSE]};       ExecInternal.Do[Get];    stream ¬ MyGetStream[];    IF stream = NIL THEN ERROR ClientVolumeError;    BEGIN    ENABLE UNWIND => IF stream # NIL THEN stream.delete[stream];    RecordMyVolume[];    Expand.ExpandToTokens[runString, ProcessToken];    Stream.PutChar[stream, Ascii.CR];    Stream.PutChar[stream, ')];  --') signifies end of file    END;    stream.delete[stream];    IF openedVolume THEN {      Volume.Close[        clientID ! Volume.NeedsScavenging, Volume.NotOpen, MVolume.CloseAborted => CONTINUE];        openedVolume ¬ FALSE};     END;     RunInternal: PROCEDURE =    BEGIN    volumeLabel: LONG STRING ¬ NIL;    clientVolume: Volume.ID;    bootSwitches: System.Switches;    Get: PROC = {      String.Replace[@volumeLabel, ExecInternal.volumeLabel, z];      clientVolume ¬ ExecInternal.clientVolume;      bootSwitches ¬ ExecInternal.bootSwitches};    IF ~ExecInternal.LegalClientVolume[] THEN {      runWrite["Can't find client volume\n "L]; RETURN};    ExecInternal.Do[Get];    PutCommandInFile[!       FileNameError => {        runWrite[name]; runWrite[" not found\n"L]; GO TO out};      ClientVolumeError => {runWrite[        "Unable to proceed. Please close or scavenge client volume and try again.\n"L]; GO TO out}];    z.FREE[@runString]; runString ¬ NIL;    Caret.ActOn[clear];    HeraldWindow.BootFromVolumeID[      id: clientVolume, bootSwitches: bootSwitches,      confirmProc: HeraldWindow.AlwaysConfirm];    EXITS out => NULL;    END;      ClientRunHelp: Exec.ExecProc =    BEGIN    Exec.OutputProc[h]["Syntax: \"ClientRun <program>\".ClientRun looks for <program> on the current client volume and runs it.Switches: l -- use codelinks when loading	  d -- call the debugger after loading but before starting to e program	  a, i or t -- 	       start the program in the active, inactive or tiny state."L];    Format.CR[Exec.OutputProc[h]];    END;  Init: PROC = {    Exec.AddCommand[name: "ClientRun.~"L, proc: RunClient, help: ClientRunHelp]};      Init[];      END.            
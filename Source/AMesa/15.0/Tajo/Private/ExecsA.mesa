-- Copyright (C) 1980, 1981, 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- ExecsA.mesa; edited by -- RXJ     , 	15-Dec-80 13:31:29-- SXW   , 	13-Jul-81  8:13:18-- LXR    ,  	20-Dec-83 11:18:19-- BXM  , 	16-Jul-81 12:09:10-- RES  , 	 3-Apr-81 10:01:01-- JGS, 	24-Nov-81 18:00:39-- SXS   , 	 1-Mar-82 17:08:41-- RXR   ,	24-Feb-83 12:06:51-- AXD    ,	19-Apr-84 12:55:17-- MEW		16-May-85 11:28:37-- DWR		11-Jun-85 16:11:18DIRECTORY  Ascii USING [CR, NUL],  Exec USING [    AddCommand, CheckAbortProc, EnumerateCommands, ExecProc,    FeedbackProc, FreeTokenString, Handle, LookupCommand,    MatchPattern, Object, Outcome, OutputProc],  ExecInternal USING [    AddExtension, ExecsB, ExecsC, ExecsD, ExecsF,    ForceExtension, ProcessUserCm, SetDefaults, Object,    SimpleExec],  ExecUtilities USING [],  Expand USING [ExpandQueues, UnknownCommandFile],  Format USING [Char, CR, Line, StringProc],  Heap USING [systemZone],  MFile USING [    Acquire, AppendErrorMessage, CompleteFilename, dontRelease,    EnumerateDirectory, EnumerateProc, Error, GetType, Handle,    maxNameLength, Release],  Queue USING [    Concatenate, Copy, Count, Empty, GetF, GetR, Init, IsEmpty, PutF, PutR, Q,    QHead, QFToString, ShortQ, StringToQR],  SpecialMFile USING [EscapeMatch],  String USING [    AppendChar, AppendString, AppendSubString, Compare, Empty, EmptyString,    EquivalentString, LowerCase, StringBoundsFault, StringLength,    SubStringDescriptor],  Token USING [    FilterProcType, Handle, MaybeQuoted, QuoteProcType, nonQuote, Object,    StandardFilterState, UnterminatedQuote, WhiteSpace],  TTY USING [CharsAvailable, Create, Destroy, GetChar, Handle, nullHandle,     PutChar, PutCR, PutString, UserAbort],  Window USING [GetBox, Handle, Object],  WindowFont USING [CharWidth];ExecsA: PROGRAM  IMPORTS    Exec, ExecInternal, Expand, Format, Heap, MFile,      Queue, SpecialMFile, String, Token, TTY, Window, WindowFont  EXPORTS Exec, ExecInternal, ExecUtilities, Expand =  BEGIN  StringBoundsFault: PUBLIC ERROR [s: LONG STRING] = CODE;  BadBootSwitch: PUBLIC ERROR [i: CARDINAL] = CODE;  CR: CHARACTER = Ascii.CR;  CondSP: CHARACTER = 200C;  NoChar: CHARACTER = 377C;  MaxStringLength: CARDINAL = 100;  Q: TYPE = Queue.Q;  ShortQ: TYPE = Queue.ShortQ;  ExpandQ: PUBLIC TYPE = Queue.ShortQ;  Handle: PUBLIC TYPE = LONG POINTER TO Object;  Object: PUBLIC TYPE = ExecInternal.Object;  OutcomeAction: TYPE = {proceed, wait, stop};    z: UNCOUNTED ZONE = Heap.systemZone;  warningLevel, errorLevel: OutcomeAction ¬ stop;  execWindow, filetoolWindow, profileToolWindow, searchPathToolWindow,     commandCentralWindow: PUBLIC Window.Handle ¬ NIL;  Noop: PROCEDURE [LONG STRING] = {};  Abort: PUBLIC PROCEDURE RETURNS [error: ERROR] = {RETURN[ABORTED]};  AppendCommands: PUBLIC PROCEDURE [h: Handle, command: LONG STRING] = {    Queue.StringToQR[command, h.remQ];    IF command[command.length - 1] # Ascii.CR AND      command[command.length - 1] # '; THEN Queue.PutR[h.remQ,';]};  PrependCommands: PUBLIC PROCEDURE [h: Handle, command: LONG STRING] =    BEGIN    IF command[command.length - 1] # Ascii.CR AND      command[command.length - 1] # '; THEN Queue.PutF[h.remQ,';];    FOR i: CARDINAL DECREASING IN [0..command.length) DO      Queue.PutF[h.remQ, command[i]]; ENDLOOP;    END;  EndOfCommandLine: PUBLIC PROCEDURE [h: Handle] RETURNS [empty: BOOLEAN] = {    IF h.endOfCommandLine # NIL THEN RETURN[h.endOfCommandLine[h]]    ELSE {      tempQ: Queue.QHead ¬ Queue.Init[];      BEGIN ENABLE UNWIND => Queue.Empty[@tempQ];      Queue.Copy[from: h.comQ, to: @tempQ];      FOR j: CARDINAL IN [0..Queue.Count[@tempQ]) DO        IF ~Token.WhiteSpace[Queue.GetF[@tempQ], NIL]           THEN {Queue.Empty[@tempQ]; RETURN[FALSE]};        ENDLOOP;      Queue.Empty[@tempQ];      END};    RETURN[TRUE]};  TTYObjHandle: TYPE = LONG POINTER TO ttyObject;  ttyObject: TYPE = RECORD [exec: Handle, next: TTYObjHandle];  ttys: TTYObjHandle ¬ NIL;  GetTTY: PUBLIC PROCEDURE [h: Handle] RETURNS [tty: TTY.Handle] = {    IF h.w = TTY.nullHandle THEN {      t: TTYObjHandle ¬ z.NEW[ttyObject];      h.temporaryTTY ¬ TRUE;      h.w ¬ TTY.Create["TemporaryExec"L];      t.exec ¬ h;      t.next ¬ ttys;      ttys ¬ t};    RETURN[h.w]};  ReleaseTTY: PUBLIC PROCEDURE [tty: TTY.Handle] = {    t: TTYObjHandle ¬ ttys;    prev: TTYObjHandle ¬ NIL;    WHILE t # NIL AND t.exec.w # tty DO prev ¬ t; t ¬ t.next ENDLOOP;    IF t # NIL THEN      IF t.exec.temporaryTTY THEN {  -- should always succeed        TTY.Destroy[tty];        t.exec.w ¬ TTY.nullHandle;        t.exec.temporaryTTY ¬ FALSE;        IF prev = NIL THEN ttys ¬ t.next ELSE prev.next ¬ t.next;        z.FREE[@t]};    };  PutChar: PUBLIC PROCEDURE [h: Handle, c: CHARACTER] = {    Format.Char[h.output, c]};  OutputProc: PUBLIC PROCEDURE [h: Handle] RETURNS [proc: Format.StringProc] = {    RETURN[h.output]};      FeedbackProc: PUBLIC PROCEDURE [h: Handle] RETURNS [proc: Format.StringProc] = {    RETURN [IF h.userFeedback = NIL THEN h.output ELSE h.userFeedback]};   CallCheckForAbort, CheckForAbort: PUBLIC PROCEDURE [h: Handle] RETURNS [abort: BOOLEAN] = {    IF h. checkForAbort # NIL THEN RETURN[h.checkForAbort[h]];    IF h.w = TTY.nullHandle THEN RETURN [FALSE];    abort ¬ TTY.UserAbort[h.w]};  GetChar: PUBLIC PROC [h: Handle] RETURNS [char: CHARACTER] =    BEGIN    IF h.getchar # NIL THEN RETURN[h.getchar[h]]    ELSE {      IF Queue.IsEmpty[h.comQ] THEN        RETURN[Ascii.NUL];      char ¬ Queue.GetF[h.comQ]};    END;  GetName: PROCEDURE [q: ShortQ, name: STRING] =    BEGIN OPEN Queue;    nameQ: QHead ¬ Queue.Init[];    XferQWhile[GetF, PutF, q, PutR, @nameQ, IsntFileChar];    Empty[@nameQ];    XferQWhile[GetF, PutF, q, PutR, @nameQ, IsFileChar];    name.length ¬ 0;    QFToString[@nameQ, name];    RETURN    END;  IsAlphaNumeric: PUBLIC PROCEDURE [c: CHARACTER] RETURNS [BOOLEAN] = {    RETURN[      SELECT c FROM        IN ['a..'z], IN ['A..'Z], IN ['0..'9] => TRUE,        ENDCASE => FALSE]};  IsntAlphaNumeric: PUBLIC PROCEDURE [c: CHARACTER] RETURNS [BOOLEAN] = {    RETURN[~IsAlphaNumeric[c]]};  IsFileChar: PUBLIC PROCEDURE [c: CHARACTER] RETURNS [BOOLEAN] = {    RETURN[      SELECT c FROM        '+, '-, '., '!, '$, '<, '>, '\\ => TRUE,        ENDCASE => IsAlphaNumeric[c]]};  IsntFileChar: PROCEDURE [c: CHARACTER] RETURNS [BOOLEAN] = {    RETURN[~IsFileChar[c]]};  IsCommandChar: PUBLIC PROCEDURE [c: CHARACTER] RETURNS [BOOLEAN] = {    RETURN[SELECT c FROM '~, '?, '*, '# => TRUE, ENDCASE => IsFileChar[c]]};  IsntCommandChar: PROCEDURE [c: CHARACTER] RETURNS [BOOLEAN] = {    RETURN[~IsCommandChar[c]]};  IsItemChar: PROCEDURE [c: CHARACTER] RETURNS [BOOLEAN] = {    RETURN[c = '/ OR IsCommandChar[c]]};  XferQWhile: PUBLIC PROCEDURE [    sourceGet: PROCEDURE [Q] RETURNS [CHARACTER],    sourcePutBack: PROCEDURE [Q, UNSPECIFIED], sourceQ: ShortQ,    destPut: PROCEDURE [Q, UNSPECIFIED], destQ: ShortQ,    test: PROCEDURE [CHARACTER] RETURNS [BOOLEAN]] =    BEGIN    c: CHARACTER;    UNTIL Queue.IsEmpty[sourceQ] DO      IF test[c ¬ sourceGet[sourceQ]] THEN destPut[destQ, c]      ELSE {sourcePutBack[sourceQ, c]; EXIT};      ENDLOOP;    RETURN    END;  Twiddles: PUBLIC PROCEDURE [w: Handle] = {    width: CARDINAL =      IF w.window = NIL THEN 20      ELSE (Window.GetBox[w.window].dims.w/WindowFont.CharWidth['~]) - 2;    FeedBack:       Format.StringProc ¬ IF w.userFeedback = NIL THEN w.output         ELSE w.userFeedback;    Format.CR[FeedBack];    THROUGH [0..width) DO Format.Char[FeedBack, '~] ENDLOOP;    Format.CR[FeedBack]};  Write: PUBLIC PROCEDURE [w: TTY.Handle, u: UNSPECIFIED] = {    IF CARDINAL[u] > 255 THEN TTY.PutString[w, LOOPHOLE[u, STRING]]    ELSE TTY.PutChar[w, u]};  WriteF: PUBLIC PROCEDURE [    w: TTY.Handle, s: STRING, p1, p2, p3, p4: UNSPECIFIED ¬ 0] = {    i: CARDINAL ¬ 0;    UNTIL i >= s.length DO      IF s[i] = '* THEN        SELECT s[i ¬ i + 1] FROM          'n, 'N => TTY.PutChar[w, CR];          '1 => Write[w, p1];          '2 => Write[w, p2];          '3 => Write[w, p3];          '4 => Write[w, p4];          '* => Write[w, '*];          ENDCASE => {Write[w, '*]; Write[w, s[i]]}      ELSE Write[w, s[i]];      i ¬ i + 1;      ENDLOOP};  WriteLine: PUBLIC PROCEDURE [w: TTY.Handle, s: STRING] = {    TTY.PutString[w, s]; TTY.PutCR[w]};  ExpandESC: PUBLIC PROCEDURE [toQ, remQ: ShortQ]    RETURNS [nMatches: CARDINAL ¬ 0] =    BEGIN OPEN Queue;    fnQ: QHead ¬ Init[];    suffix: STRING = [MFile.maxNameLength];    prefix: STRING = [MFile.maxNameLength];    tempDesc: String.SubStringDescriptor;    noFiles, unique: BOOLEAN ¬ FALSE;    i: CARDINAL;    CommandEscMatch: PROCEDURE [      name: LONG STRING, proc, help, unload: Exec.ExecProc,       clientData: LONG POINTER ¬ NIL]      RETURNS [BOOLEAN] =      BEGIN      pos: CARDINAL;      IF ~Exec.MatchPattern[name, prefix] THEN RETURN[FALSE];      pos ¬ SpecialMFile.EscapeMatch[name, prefix, prefix.length - 1];      i ¬ 0;      nMatches ¬ nMatches + 1;      IF nMatches = 1 THEN {        tempDesc ¬ [base: name, offset: pos, length: name.length - pos];        String.AppendSubString[suffix, @tempDesc]}      ELSE {        WHILE i + pos < name.length AND i < suffix.length DO          IF String.LowerCase[name[i + pos]] # String.LowerCase[suffix[i]] THEN            EXIT;          i ¬ i + 1;          ENDLOOP;        suffix.length ¬ i};      RETURN[FALSE];      END;    XferQWhile[GetR, PutR, toQ, PutF, @fnQ, IsCommandChar];    QFToString[@fnQ, prefix];    IF prefix.length = 0 THEN GOTO done;    StringToQR[prefix, toQ];    [unique, nMatches] ¬ MFile.CompleteFilename[      prefix, suffix ! MFile.Error => {noFiles ¬ TRUE; CONTINUE}];    String.AppendChar[prefix, '*];    Exec.EnumerateCommands[CommandEscMatch ! ABORTED => suffix.length ¬ 0];    StringToQR[suffix, remQ];    EXITS done => NULL;    END;  GetSubsysName: PROCEDURE [q: ShortQ, name: STRING]    RETURNS [cmdName: LONG STRING ¬ NIL, proc: Exec.ExecProc ¬ NIL,     commandindex: CARDINAL ¬ 0, clientData: LONG POINTER ¬ NIL] =    BEGIN  ENABLE String.StringBoundsFault => ERROR StringBoundsFault[name];    prefaceQ, fileNameQ: Queue.QHead ¬ Queue.Init[];    XferQWhile[Queue.GetF, Queue.PutF, q, Queue.PutR, @prefaceQ, IsntCommandChar];    XferQWhile[Queue.GetF, Queue.PutF, q, Queue.PutR, @fileNameQ, IsCommandChar];    name.length ¬ 0;    Queue.QFToString[@fileNameQ, name];    IF name.length # 0 THEN {      [name: cmdName, proc: proc, clientData: clientData] ¬        Exec.LookupCommand[name];      Queue.StringToQR[        IF String.EmptyString[cmdName] THEN name ELSE cmdName, @fileNameQ];      prefaceQ ¬ Queue.Concatenate[@prefaceQ, @fileNameQ];      commandindex ¬ Queue.Count[@prefaceQ]};    q­ ¬ Queue.Concatenate[@prefaceQ, q];    RETURN    END;  MustRunBcd: PUBLIC PROCEDURE [comQ, remQ: ShortQ, systemName: STRING]    RETURNS [autoLoaded: BOOLEAN, commandlength: CARDINAL ¬ 0] = {    proc: Exec.ExecProc;    prefaceQ, switchesQ, tempQ: Queue.QHead ¬ Queue.Init[];    name: STRING ¬ [MaxStringLength];    ext: STRING ¬ [MaxStringLength];    BEGIN ENABLE String.StringBoundsFault => ERROR StringBoundsFault[name];    XferQWhile[      Queue.GetF, Queue.PutF, comQ, Queue.PutR, @prefaceQ, IsntCommandChar];    XferQWhile[Queue.GetF, Queue.PutF, comQ, Queue.PutR, @tempQ, IsCommandChar];    XferQWhile[Queue.GetF, Queue.PutF, comQ, Queue.PutR, @switchesQ, IsItemChar];    name.length ¬ 0;    Queue.QFToString[@tempQ, name];    IF name.length = 0 THEN {      Queue.StringToQR[name, @prefaceQ];      prefaceQ ¬ Queue.Concatenate[@prefaceQ, @switchesQ];      comQ­ ¬ Queue.Concatenate[@prefaceQ, comQ];      RETURN[FALSE, 0]};    [, proc, ] ¬ Exec.LookupCommand[name];    IF proc # NIL THEN {      Queue.StringToQR[name, @prefaceQ];      prefaceQ ¬ Queue.Concatenate[@prefaceQ, @switchesQ];      comQ­ ¬ Queue.Concatenate[@prefaceQ, comQ];      RETURN[FALSE, 0]};    systemName.length ¬ 0;    String.AppendString[to: systemName, from: name];    GetExtension[name, ext];    IF ext.length = 0 OR ProperExtension[ext, TRUE] THEN      BEGIN      IF CanLookup[name] THEN {        -- insert run of subsystem into comQ        Queue.StringToQR["Run.~ "L, @prefaceQ];        Queue.StringToQR[name, @prefaceQ];        Queue.Copy[from: @switchesQ, to: @prefaceQ];        Queue.StringToQR["; "L, @prefaceQ];        -- insert call on subsystem into remQ and remember name        Queue.Empty[@tempQ];        name.length ¬ 0;        IF ProperExtension[ext, FALSE] THEN          ExecInternal.ForceExtension[systemName, NIL];        String.AppendString[to: name, from: systemName];        Queue.StringToQR[name, @tempQ];        Queue.Copy[from: @switchesQ, to: @tempQ];        tempQ ¬ Queue.Concatenate[@tempQ, comQ];        commandlength ¬ Queue.Count[@tempQ];        remQ­ ¬ Queue.Concatenate[@tempQ, remQ];        Queue.Copy[from: @prefaceQ, to: comQ];        RETURN[TRUE, commandlength]};      END;    name.length ¬ 0;    String.AppendString[to: name, from: systemName];    systemName.length ¬ 0;    Queue.StringToQR[name, @prefaceQ];    prefaceQ ¬ Queue.Concatenate[@prefaceQ, @switchesQ];    comQ­ ¬ Queue.Concatenate[@prefaceQ, comQ];    RETURN[FALSE];    END};  ProperExtension: PROC [ext: STRING, tildaOk: BOOLEAN] RETURNS [BOOLEAN] = {    RETURN[      String.EquivalentString[ext, ".bcd"L]        OR String.EquivalentString[ext, ".archivebcd"L]        OR (tildaOk AND String.EquivalentString[ext, ".~"L])]};  CanLookup: PUBLIC PROC [name: LONG STRING] RETURNS [BOOLEAN] = {    RETURN[      LookUpUniqueFile[name, NIL]        OR LookUpUniqueFile[name, ".archivebcd"L]        OR LookUpUniqueFile[name, "*.archivebcd"L]        OR LookUpUniqueFile[name, ".bcd"L] OR LookUpUniqueFile[name, "*.bcd"L]]};  LookUpUniqueFile: PUBLIC PROCEDURE [name, ext: LONG STRING ¬ NIL]    RETURNS [found: BOOLEAN ¬ FALSE] =    BEGIN    pattern: STRING ¬ [100];    trialMatch: STRING ¬ [100];    wildcard: BOOLEAN ¬ FALSE;    i: CARDINAL;    MatchPattern: MFile.EnumerateProc =      BEGIN      IF found THEN {found ¬ FALSE; RETURN[TRUE]};  -- multiple matches      String.AppendString[trialMatch, fullName];      found ¬ TRUE;      RETURN[FALSE]      END;    String.AppendString[pattern, name];    FOR i DECREASING IN [0..pattern.length) DO      IF IsFileChar[pattern[i]] THEN {pattern.length ¬ i + 1; EXIT}; ENDLOOP;    IF ext # NIL AND ext.length # 0 THEN ExecInternal.AddExtension[pattern, ext];    FOR i IN [0..pattern.length) DO      IF pattern[i] = '* OR pattern[i] = '# THEN {wildcard ¬ TRUE; EXIT}; ENDLOOP;    IF wildcard THEN      MFile.EnumerateDirectory[        pattern, MatchPattern, filesOnly ! MFile.Error => CONTINUE]    ELSE {      f: MFile.Handle ¬ NIL;      String.AppendString[trialMatch, pattern];      f ¬ MFile.Acquire[        pattern, readOnly, MFile.dontRelease !        MFile.Error => CONTINUE];      IF f = NIL OR MFile.GetType[f] = directory THEN found ¬ FALSE      ELSE found ¬ TRUE;      IF f # NIL THEN MFile.Release[f]};    IF found THEN {name.length ¬ 0; String.AppendString[name, trialMatch]};    END;  GetExtension: PROCEDURE [name, ext: STRING] =    BEGIN    i: CARDINAL;    ext.length ¬ 0;    FOR i DECREASING IN [0..name.length) DO IF name[i] = '. THEN EXIT; ENDLOOP;    IF name[i] = '. THEN      FOR j: CARDINAL IN [i..name.length) DO        String.AppendChar[ext, name[j]]; ENDLOOP;    END;  RemoveUpArrows: PUBLIC PROCEDURE [q: ShortQ] =    BEGIN OPEN Queue;    tempQ: QHead ¬ Queue.Init[];    UNTIL IsEmpty[q] DO      c: CHARACTER ¬ GetF[q];      SELECT c FROM        136C, 255C => {IF ~IsEmpty[q] THEN [] ¬ GetF[q]; LOOP};        '' => IF ~IsEmpty[q] THEN c ¬ GetF[q];        ENDCASE;      PutR[@tempQ, c];      ENDLOOP;    q­ ¬ Concatenate[@tempQ, q];    RETURN    END;  GetPreExpandedCommand: PUBLIC PROCEDURE [    toQ, fromQ: ShortQ, commandLength: CARDINAL] =    BEGIN OPEN Queue;    THROUGH [0..MIN[Count[fromQ], commandLength]) DO      PutR[toQ, GetF[fromQ]]; ENDLOOP;    END;  StringOverFlow: PUBLIC PROCEDURE [exec: Handle, s: LONG STRING]    RETURNS [dontExpand: BOOLEAN ¬ FALSE] =    BEGIN    realLength: CARDINAL ¬ s.length;    FeedBack: Format.StringProc ¬ IF exec.userFeedback = NIL       THEN exec.output       ELSE exec.userFeedback;    FeedBack["SimpleExec: String overflow! Aborting.  String: "L];    IF s.length > 50 THEN s.length ¬ 50;    TTY.PutString[exec.w, s];    IF realLength > 50 THEN {s.length ¬ realLength; FeedBack[" . . ."L]};    Format.CR[FeedBack];    Queue.Empty[exec.remQ];    END;  GetToken: PUBLIC PROC [h: Exec.Handle] RETURNS [token, switches: LONG STRING] =    BEGIN    data: Token.StandardFilterState;    get: PROCEDURE [Token.Handle] RETURNS [c: CHARACTER] ¬ {RETURN[GetChar[h]]};    getToken: Token.Object ¬ [getChar: get, break: Ascii.NUL];    isQuote: Token.QuoteProcType ¬ {RETURN[IF c = '" THEN c ELSE Token.nonQuote]};    tokenFilter: Token.FilterProcType ¬ {      RETURN[        SELECT TRUE FROM          Token.WhiteSpace[c, data], c = Ascii.NUL => FALSE,          c = '/ => FALSE,          ENDCASE => TRUE]};    token ¬ Token.MaybeQuoted[@getToken, @data, tokenFilter, isQuote                               ! Token.UnterminatedQuote => RESUME];    switches ¬      IF getToken.break = '/ THEN Token.MaybeQuoted[        @getToken, NIL, tokenFilter, isQuote ! Token.UnterminatedQuote => RESUME]      ELSE NIL;    RETURN    END;  FreeTokenString: PUBLIC PROCEDURE [s: LONG STRING] RETURNS [LONG STRING] = {    z.FREE[@s]; RETURN[NIL]};  FlushPendingInput: PROCEDURE [h: Handle] = {    n: CARDINAL;    IF h.w = TTY.nullHandle THEN RETURN;    WHILE (n ¬ TTY.CharsAvailable[h.w]) > 0 DO       THROUGH [0..n) DO [] ¬ TTY.GetChar[h.w] ENDLOOP;      ENDLOOP};  ProcessCommandLine: PUBLIC PROCEDURE [    cmd: LONG STRING, write: Format.StringProc,    checkAbort: Exec.CheckAbortProc]    RETURNS [outcome: Exec.Outcome] =    BEGIN    Never: PROCEDURE[h: Handle] RETURNS [BOOLEAN] = {RETURN[FALSE]};    remQHead: Queue.QHead ¬ Queue.Init[];    comQHead: Queue.QHead ¬ Queue.Init[];    scratchQHead: Queue.QHead ¬ Queue.Init[];    object: Object ¬ [      comQ: @comQHead, remQ: @remQHead, scratchQ: @scratchQHead];    Queue.StringToQR[cmd, object.remQ];    object.output ¬ write;    object.checkForAbort ¬ checkAbort;    outcome ¬ ExecuteFromHandle[@object, Never, GetCommand];    END;  GetCommand: PROCEDURE [h: Handle] RETURNS [gotCommand: BOOLEAN ¬ TRUE] =    BEGIN    Output: Format.StringProc = h.output;    Queue.Empty[h.comQ];    IF Queue.IsEmpty[h.remQ] THEN RETURN[FALSE];    Queue.PutR[h.remQ, Ascii.CR];  -- ensure that command line ends    Expand.ExpandQueues[      toQ: h.comQ, fromQ: h.remQ, mask: [TRUE, TRUE, TRUE, skip, NIL] !      Expand. UnknownCommandFile => {        Output["Unknown command file "];        Output[name];        gotCommand ¬ FALSE;        CONTINUE};      MFile.Error => {        msg: STRING ¬ [100];	MFile.AppendErrorMessage[msg, code, file];        Format.Line[Output, msg];        gotCommand ¬ FALSE;        CONTINUE}];    -- remove extra CR    IF ~Queue.IsEmpty[h.remQ] THEN [] ¬ Queue.GetR[h.remQ]    ELSE IF ~Queue.IsEmpty[h.comQ] THEN [] ¬ Queue.GetR[h.comQ];    END;  ProcessOutcome: PROCEDURE [h: Handle, outcome: Exec.Outcome, Quit: PROCEDURE [LONG STRING]] RETURNS [loop: BOOLEAN ¬ FALSE] =     BEGIN    FeedBack: Format.StringProc = Exec.FeedbackProc[h];    SELECT TRUE FROM        outcome = normal => NULL;	outcome = abort => {	  Quit["Aborted..."L]; loop ¬ TRUE};	outcome = warning AND warningLevel = proceed => 	  FeedBack["Warnings..."L];	outcome = warning AND warningLevel = wait => {	  c: CHARACTER;	  Format.CR[FeedBack];	  FeedBack[	    "Warnings encountered.  Type a character to continue, q to quit."L];	  c ¬ TTY.GetChar[h.w];	  IF c = 'q OR c = 'Q THEN {Quit[""L]; loop ¬ TRUE}};	outcome = warning AND warningLevel = stop => {	  Quit["Warnings..."L]; loop ¬ TRUE};	outcome = error AND errorLevel = proceed => 	  FeedBack["Errors..."L];       	outcome = error AND errorLevel = wait => {	  c: CHARACTER;	  Format.CR[FeedBack];	  FeedBack[	    "Errors encountered.  Type a character to continue, q to quit."L];	  c ¬ TTY.GetChar[h.w];	  IF c = 'q OR c = 'Q THEN {Quit[""L]; loop ¬ TRUE}};	outcome = error AND errorLevel = stop => {	  Quit["Errors..."L]; loop ¬ TRUE};	ENDCASE => {	  Quit["Unknown outcome..."L]; loop ¬ TRUE};    END;  ExecuteFromHandle: PUBLIC PROCEDURE [    h: Handle, CheckIfDeactivated: PROCEDURE[h: Exec.Handle] RETURNS [BOOLEAN],    GetCommand: PROCEDURE [Handle] RETURNS [BOOLEAN]]     RETURNS [outcome: Exec.Outcome] =    BEGIN    cmdName: LONG STRING;    cmdProc: Exec.ExecProc;    clientData: LONG POINTER;    commandIndex: CARDINAL;    lastName: STRING = [MaxStringLength];    autoloaded: BOOLEAN ¬ FALSE;    lastLength: CARDINAL ¬ 0;    Output: Format.StringProc = h.output;    FeedBack: Format.StringProc ¬ Exec.FeedbackProc[h];    BearTrap: SIGNAL = CODE;    Quit: PROCEDURE [msg: LONG STRING] =      BEGIN      Queue.Empty[h.remQ];      FlushPendingInput[h];      autoloaded ¬ FALSE;      IF ~CheckIfDeactivated[h] THEN {        Format.CR[FeedBack];	IF String.StringLength[msg] > 0 THEN          FeedBack[msg]};      END;          DO      ENABLE {        ABORTED => EXIT;	StringBoundsFault => {	  FeedBack[" Token too large.  Aborted. . ."L];	  FlushPendingInput[h]; LOOP}};      IF CheckIfDeactivated[h] THEN EXIT;      Queue.Empty[h.comQ];      IF Queue.IsEmpty[h.remQ] THEN        IF autoloaded THEN {SIGNAL BearTrap; autoloaded ¬ FALSE};      IF autoloaded THEN {        GetPreExpandedCommand[h.comQ, h.remQ, lastLength];        lastLength ¬ 0;	autoloaded ¬ FALSE;	}      ELSE {        BEGIN	  IF ~GetCommand[h ! ABORTED => GOTO abort] THEN EXIT;«	    ABORTED => {	      IF ~CheckIfDeactivated[h] THEN {		FeedBack[" Aborted. . ."L]; FlushPendingInput[h]};	      LOOP}] THEN EXIT;»	EXITS	  abort => {	    IF ~CheckIfDeactivated[h] THEN {	      FeedBack[" Aborted. . ."L ! ABORTED => EXIT];	      FlushPendingInput[h]};	    LOOP};	END;        IF CheckForAbort[h] THEN {          IF ~CheckIfDeactivated[h] THEN {	      FeedBack[" Aborted. . ."L]; FlushPendingInput[h]}; 	  LOOP};        [autoloaded, lastLength] ¬ MustRunBcd[h.comQ, h.remQ, lastName]};      RemoveUpArrows[h.comQ];      BEGIN        subsysName: STRING = [MaxStringLength];	[cmdName, cmdProc, commandIndex, clientData] ¬           GetSubsysName[h.comQ, subsysName];        FOR i: CARDINAL IN [0..commandIndex) DO [] ¬ Queue.GetF[h.comQ]; ENDLOOP;        IF subsysName.length = 0 THEN LOOP;        IF cmdProc = NIL THEN {          Format.CR[FeedBack];          FeedBack["There is no subsystem named "];          FeedBack[subsysName];          Queue.Empty[h.remQ]; -- abort rest of command line	  FlushPendingInput[h]; -- abort rest of command line	  LOOP};      END;      Format.CR[FeedBack];      -- Twiddles[h];      outcome ¬ cmdProc[h, clientData ! ABORTED => {outcome ¬ abort; CONTINUE}];      IF ProcessOutcome[h, outcome, Quit] THEN LOOP;      IF autoloaded THEN {        tempQHead: Queue.QHead ¬ Queue.Init[];        [cmdName, cmdProc, ] ¬ Exec.LookupCommand[lastName];        IF cmdName = NIL THEN {          GetPreExpandedCommand[@tempQHead, h.remQ, lastLength];          Queue.Empty[@tempQHead];          lastLength ¬ 0;          autoloaded ¬ FALSE;          IF ~Queue.IsEmpty[h.remQ] THEN {            FeedBack["No subsystem registered with name "L];            FeedBack[lastName];            FeedBack[" continuing to next command."L]}}};      -- Twiddles[h];      ENDLOOP;    Queue.Empty[h.comQ];    Queue.Empty[h.remQ];    END;      SetErrorLevel: Exec.ExecProc =     BEGIN    token, switch: LONG STRING ¬ NIL;    wSwitch: OutcomeAction ¬ warningLevel;    eSwitch: OutcomeAction ¬ errorLevel;    Write: Format.StringProc = Exec.OutputProc[h];    Cleanup: PROCEDURE =       BEGIN      token ¬ Exec.FreeTokenString[token];      switch ¬ Exec.FreeTokenString[switch];      END;    VerifySwitch: PROCEDURE[c: CHARACTER] RETURNS[ok: BOOLEAN] =      BEGIN      SELECT c FROM        'p,	'w,	'a => ok ¬ TRUE;        ENDCASE => ok ¬ FALSE;       END;    TranslateSwitch: PROCEDURE[c: CHARACTER, oldLevel: OutcomeAction]       RETURNS[oa: OutcomeAction] =      BEGIN      SELECT c FROM        'p => oa ¬ proceed;	'w => oa ¬ wait;	'a => oa ¬ stop;	ENDCASE => oa ¬ oldLevel;      END;          BEGIN ENABLE UNWIND => Cleanup[];    FOR i: CARDINAL IN [0..2) DO      [token, switch] ¬ GetToken[h];      IF token = NIL THEN EXIT;      IF switch = NIL THEN GOTO error;      SELECT TRUE FROM         String.Compare[token, "warning"L] = 0 => {          IF VerifySwitch[switch[0]] THEN	    wSwitch ¬ TranslateSwitch[switch[0], warningLevel]	  ELSE GOTO error};        String.Compare[token, "error"L] = 0 => {          IF VerifySwitch[switch[0]] THEN	    eSwitch ¬ TranslateSwitch[switch[0], errorLevel]	  ELSE GOTO error};        ENDCASE => GOTO error;       REPEAT error => {        Write["Syntax error! "L]; Cleanup[]; RETURN[error]};      ENDLOOP;    IF eSwitch < wSwitch THEN {      Write["Illegal error level combination."L];      Cleanup[]; RETURN[error]};    warningLevel ¬ wSwitch;    errorLevel ¬ eSwitch;    END;    Cleanup[];    END;    HelpErrorLevel: Exec.ExecProc =    BEGIN    Write: Format.StringProc = Exec.OutputProc[h];    Write["SetErrorLevel allows you specify whether processing should proceed, wait, or abort following a particular outcome.  The syntax of the commandline is:    SetErrorLevel outcome/switch <outcome/switch>, where the second outcome/switch pair is optional.The outcome may be either warning or error.  The switch may be either p for proceed, w for wait or a for abort.The switches are ordered according to their severity as follows: p < w < a. The switch chosen for errors must be >= the switch for warnings, i.e. warnings/a error/p is an illegal combination.Default = warning/a error/a.Example: 	SetErrorLevel warning/p error/a indicates that the user wishes to proceed when warnings are encountered and abort if an error is encountered."L];    END;      Install: PUBLIC PROCEDURE = {};  Init: PROCEDURE =    BEGIN   -- order of STARTs is important   -- ExecsE is started by ExecImpl's call to AddCommand     START ExecInternal.ExecsB;    START ExecInternal.ExecsD;    START ExecInternal.ExecsC;    START ExecInternal.ExecsF;    ExecInternal.SetDefaults[];    ExecInternal.ProcessUserCm[];    START ExecInternal.SimpleExec;    « Used to start ExecInternal.CommandCentral here before it was      taken out of the bootfile. »    Exec.AddCommand["SetErrorLevel.~"L, SetErrorLevel, HelpErrorLevel];    END;  Init[];  END...
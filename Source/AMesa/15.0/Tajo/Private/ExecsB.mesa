-- Copyright (C) 1980, 1981, 1982, 1983  by Xerox Corporation. All rights reserved. -- ExecsB.mesa - last edited by:-- PXK    ,	20-Jul-81 15:06:13-- SXW   ,	13-Jul-81  8:25:46-- BXM  ,	22-Oct-81 16:43:39-- RXJ     ,	14-Dec-80 19:35:02-- LXR    ,	 7-Dec-83 13:59:22-- RES  ,	 1-Jun-81 21:49:29-- BTL  ,	 8-Apr-81 10:30:20-- Mark,	 4-Jun-81 16:51:20-- JGS,	 	27-Jan-83 15:02:43-- SXS   ,	 1-Mar-82 17:07:21-- RXR   	 2-Mar-83 15:33:57-- AXD    	19-Jul-83 15:22:13DIRECTORY  Ascii USING [NUL, CR, SP, TAB],  Exec USING [    AddCommand, CheckAbortProc, CheckForAbort, EnumerateCommands,    ExecProc, GetChar, Handle, MatchPattern, Object, Outcome,    OutputProc, PutChar, Start],  ExecInternal USING [CanLookup, codeLinks, Object],  Format USING [CR, Line, LongOctal, StringProc],  Heap USING [systemZone],  MFile USING [    Acquire, AppendErrorMessage, dontRelease, EnumerateDirectory, EnumerateProc,    Error, FreeSearchPath, GetSearchPath, Handle, maxNameLength, Release,    SearchPath, searchPathNotUsed],  MLoader USING [Error, Handle, Load, Start, Unload, VersionMismatch],  Profile USING [initialToolStateDefault],  Queue USING [Copy, Count, Empty, Init, QFToString, QHead],  Runtime USING [CallDebugger],  String USING [   AppendChar, AppendString, Empty, EmptyString, EquivalentString,   InvalidNumber, LowerCase, StringLength, StringToLongNumber],  System USING [defaultSwitches, Switches],  TajoOps USING [SetInitialToolStateDefault],  Token USING [    AlphaNumeric, Filtered, FilterProcType,    Handle, Object, Switches],  ToolWindow USING [State],  UserTerminal USING [BlinkDisplay];ExecsB: MONITOR  IMPORTS    Exec, ExecInternal, Format, Heap, MFile, MLoader, Profile, Queue, Runtime,    String, TajoOps, Token, UserTerminal  EXPORTS Exec, ExecInternal =  BEGIN  SP: CHARACTER = Ascii.SP;  CR: CHARACTER = Ascii.CR;  TAB: CHARACTER = Ascii.TAB;  Handle: PUBLIC TYPE = LONG POINTER TO Object;  Object: PUBLIC TYPE = ExecInternal.Object;    z: UNCOUNTED ZONE = Heap.systemZone;  defaultSwitches: System.Switches ¬ System.defaultSwitches;    localFileName: Token.FilterProcType = {    RETURN[      SELECT TRUE FROM        c = '., c = '<, c = '>, c = '\\, Token.AlphaNumeric[c, data] => TRUE,        ENDCASE => FALSE]};  wildString: CHARACTER = '*;  wildChar: CHARACTER = '#;  MatchPattern: PUBLIC PROCEDURE [string, pattern: LONG STRING]    RETURNS [matched: BOOLEAN] = {    [matched, ] ¬ MaskFilename[string, 0, pattern, 0, 0]};  EscapeMatch: PUBLIC PROCEDURE [string, pattern: LONG STRING, pos: CARDINAL]    RETURNS [correspondingingPos: CARDINAL] =    BEGIN    match: BOOLEAN;    [match, correspondingingPos] ¬ MaskFilename[string, 0, pattern, 0, pos];    IF ~match THEN correspondingingPos ¬ 0;    END;  MaskFilename: PROCEDURE [    file: LONG STRING, fileIndex: CARDINAL, mask: LONG STRING,    maskIndex: CARDINAL, posToBeFound: CARDINAL]    RETURNS [outcome: BOOLEAN, correspondingingPos: CARDINAL] =    BEGIN    -- local variables    i, j: CARDINAL;    -- process each character in mask    FOR i IN [maskIndex..mask.length) DO      IF i = posToBeFound THEN correspondingingPos ¬ fileIndex;      SELECT mask[i] FROM        wildString =>  -- matches any string of zero or more characters          BEGIN          FOR j IN [fileIndex..file.length] DO            IF MaskFilename[file, j, mask, i + 1, posToBeFound].outcome THEN              RETURN[TRUE, correspondingingPos];            ENDLOOP;          RETURN[FALSE, 0];          END;        wildChar =>  -- matches any single character          IF fileIndex = file.length THEN RETURN[FALSE, correspondingingPos]          ELSE fileIndex ¬ fileIndex + 1;        ENDCASE =>          IF fileIndex = file.length            OR String.LowerCase[file[fileIndex]] # String.LowerCase[mask[i]] THEN            RETURN[FALSE, 0]          ELSE fileIndex ¬ fileIndex + 1;      ENDLOOP;    -- filename passes mask if entire filename has been consumed    outcome ¬ fileIndex = file.length;    END;  ForceExtension: PUBLIC PROCEDURE [name, ext: LONG STRING] =    BEGIN    FOR i: CARDINAL IN [0..name.length) DO      IF name[i] = '. THEN {name.length ¬ i; EXIT}; ENDLOOP;    IF name.length # 0 THEN String.AppendString[name, ext];    END;  AddExtension: PUBLIC PROCEDURE [name, ext: LONG STRING] =    BEGIN    FOR i: CARDINAL IN [0..name.length) DO IF name[i] = '. THEN RETURN; ENDLOOP;    IF name.length # 0 THEN String.AppendString[name, ext];    END;  BadSubSys: PROCEDURE [    Write: Format.StringProc, name: LONG STRING, reason: LONG STRING] =    BEGIN    Format.CR[Write];    Write["!"L];    Write[name];    Write[": "L];    Write[reason];    Format.CR[Write];    UserTerminal.BlinkDisplay[];    END;  Load: PUBLIC PROCEDURE [    write: Format.StringProc, name: LONG STRING, codeLinks: BOOLEAN ¬ FALSE]     RETURNS [handle: MLoader.Handle] = {    ignoreVersion: BOOLEAN ¬ TRUE;    handle ¬ NIL;    -- Special kludge to support v switch    FOR i: CARDINAL IN [0..name.length-1) DO      IF name[i] = '/ THEN {        ignoreVersion ¬ SELECT name[i+1] FROM	  'v, 'V => TRUE,	  ENDCASE => FALSE;	name.length ¬ i;	EXIT};      ENDLOOP;    handle ¬ LoadInternal[      write, name, ignoreVersion, codeLinks !      ABORTED => {write[" Aborted! "L]; CONTINUE}]};  LoadInternal: PROCEDURE [    Write: Format.StringProc, name: LONG STRING,     ignoreVersion, codeLinks: BOOLEAN]     RETURNS [handle: MLoader.Handle] =    BEGIN    badVersion: BOOLEAN ¬ FALSE;    h: MFile.Handle;    h ¬ MFile.Acquire[      name, readOnly, MFile.dontRelease !      MFile.Error => {        msg: STRING ¬ [100];	MFile.AppendErrorMessage[msg, code, file];        BadSubSys[Write, name, msg];        ERROR ABORTED}];    handle ¬ MLoader.Load[      h, [codeLinks] !      ABORTED => {MFile.Release[h]; BadSubSys[Write, name, "loading ABORTED"L]};      MLoader.VersionMismatch => {        Write["!Version mismatch of "L];        Write[module];        Format.CR[Write];        badVersion ¬ TRUE;        RESUME        };      MLoader.Error => {        BadSubSys[          Write, name,          SELECT code FROM            badCode => "not /-a code"L,            invalidParameters => "not in valid bcd format"L,            missingCode => "missing code"L,            exportedTypeClash => "exported type clash"L,            lookupFailure => "look up failure"L,            gftFull => "out of space in MDS"L,            loadStateFull => "load state full"L,            ENDCASE => "unknown loader error"L];        ERROR ABORTED}];    IF badVersion AND ~ignoreVersion THEN {      Format.LongOctal[Write, handle];      Write["...not started."L];      Format.CR[Write];      handle ¬ NIL};    END;  LoadCommand: PROCEDURE [h: Handle, clientData: LONG POINTER ¬ NIL]     RETURNS [outcome: Exec.Outcome ¬ normal] =    BEGIN    s: LONG STRING ¬ NIL;    switches: LONG STRING ¬ NIL;    localSwitches, globalSwitches: System.Switches ¬ defaultSwitches;    mh: MLoader.Handle;    get: PROCEDURE [Token.Handle] RETURNS [CHARACTER] ¬ {RETURN[Exec.GetChar[h]]};    getToken: Token.Object ¬ [getChar: get, break: Ascii.NUL];    FeedBack: Format.StringProc;    Cleanup: PROC = {      z.FREE[@s]; s ¬ NIL;      z.FREE[@switches]; switches ¬ NIL};    IF h.userFeedback = NIL       THEN FeedBack ¬ Exec.OutputProc[h]      ELSE FeedBack ¬ h.userFeedback;    DO      ENABLE UNWIND => Cleanup[];      IF Exec.CheckForAbort[h] THEN ERROR ABORTED;      localSwitches ¬ globalSwitches;      s ¬ Token.Filtered[@getToken, NIL, localFileName];      IF String.StringLength[s] = 0 AND getToken.break # '/ THEN EXIT;      IF getToken.break = '/ THEN {        switches ¬ Token.Filtered[@getToken, NIL, Token.Switches];        IF String.StringLength[s] = 0 THEN {  --global switches          globalSwitches ¬ ProcessSwitches[switches, ExecInternal.codeLinks];	  Cleanup[]; LOOP}        ELSE localSwitches ¬ ProcessSwitches[switches, ExecInternal.codeLinks]};      AddExtension[s, ".bcd"L];      FeedBack["Loading "L];      FeedBack[s];      FeedBack["..."L];      mh ¬ Load[FeedBack, s, localSwitches['l] = down];      Format.LongOctal[FeedBack, mh];      Format.CR[FeedBack];      Cleanup[];      ENDLOOP;    END;  Start: PUBLIC PROCEDURE [handle: MLoader.Handle] =    BEGIN MLoader.Start[handle]; END;  StartCommand: PROCEDURE [h: Handle, clientData: LONG POINTER ¬ NIL]     RETURNS [outcome: Exec.Outcome ¬ normal] =    BEGIN OPEN Exec, ExecInternal;    s: LONG STRING ¬ NIL;    switches: LONG STRING ¬ NIL;    localSwitches, globalSwitches: System.Switches ¬ defaultSwitches;    previousState: ToolWindow.State;    get: PROCEDURE [Token.Handle] RETURNS [CHARACTER] ¬ {RETURN[Exec.GetChar[h]]};    getToken: Token.Object ¬ [getChar: get, break: Ascii.NUL];    FeedBack: Format.StringProc ¬ IF h.userFeedback = NIL       THEN Exec.OutputProc[h]      ELSE h.userFeedback;    Cleanup: PROC = {      z.FREE[@s]; s ¬ NIL;      z.FREE[@switches]; switches ¬ NIL};    DO      ENABLE UNWIND => Cleanup[];      IF Exec.CheckForAbort[h] THEN ERROR ABORTED;      localSwitches ¬ globalSwitches;      s ¬ Token.Filtered[@getToken, NIL, localFileName];      IF String.StringLength[s] = 0 AND getToken.break # '/ THEN EXIT;      IF getToken.break = '/ THEN {        switches ¬ Token.Filtered[@getToken, NIL, Token.Switches];        IF String.StringLength[s] = 0 THEN {  --global switches           globalSwitches ¬ ProcessSwitches[switches, FALSE];	  Cleanup[]; LOOP}        ELSE localSwitches ¬ ProcessSwitches[switches, FALSE]};      previousState ¬ SetDefaultState[localSwitches];      FeedBack["Starting "L];      FeedBack[s];      FeedBack["..."L];      Start[        String.StringToLongNumber[s: s, radix: 8 !	  String.InvalidNumber => {	    FeedBack["invalid number."L]; outcome ¬ error; CONTINUE};	  ABORTED => TajoOps.SetInitialToolStateDefault[previousState]]        ! ABORTED => TajoOps.SetInitialToolStateDefault[previousState];	  MLoader.Error => {	    FeedBack[string]; CONTINUE}];      TajoOps.SetInitialToolStateDefault[previousState];      Format.CR[FeedBack];      Cleanup[];      ENDLOOP;    END;  ExpandArg: PROCEDURE [switches: LONG STRING, cmdLine: LONG STRING]    RETURNS [result: LONG STRING] =    BEGIN    switchLength: CARDINAL = String.StringLength[switches];    result ¬ z.NEW[StringBody [switchLength + cmdLine.length + 3]];    IF switchLength # 0 THEN      BEGIN      IF switches[0] ~= '/ THEN String.AppendChar[result, '/];      String.AppendString[result, switches];      IF switches[switches.length - 1] ~= '; THEN String.AppendChar[result, ';];      END;    String.AppendString[to: result, from: cmdLine];    String.AppendChar[result, CR];    END;      ProcessSwitches: PROCEDURE [s: LONG STRING, lSwitchDown: BOOLEAN]    RETURNS [switches: System.Switches ¬ defaultSwitches] =    BEGIN    i: CARDINAL;    c: CHARACTER;    inverse: {on, off} ¬ on;    IF lSwitchDown THEN switches['l] ¬ down;    IF String.EmptyString[s] THEN RETURN;    FOR i IN [0..s.length) DO      SELECT c ¬ String.LowerCase[s[i]] FROM        IN ['a..'z] => {	  switches[c] ¬ IF inverse = off THEN up ELSE down;	  inverse ¬ on};        '- => inverse ¬ IF inverse = on THEN off ELSE on;        ENDCASE;      ENDLOOP;    END;  SetDefaultState: PROCEDURE [switches: System.Switches]    RETURNS [oldStateDefault: ToolWindow.State] =    BEGIN    oldStateDefault ¬ Profile.initialToolStateDefault;    IF switches['a] = down THEN TajoOps.SetInitialToolStateDefault[active];    IF switches['t] = down THEN TajoOps.SetInitialToolStateDefault[tiny];    IF switches['i] = down THEN TajoOps.SetInitialToolStateDefault[inactive];    END;  Run: PUBLIC PROCEDURE [    h: Token.Handle, write: Format.StringProc,     checkAbort: PROC RETURNS[abort: BOOLEAN],    codeLinks: BOOLEAN ¬ FALSE] = {    RunInternal[      h, write, checkAbort !      ABORTED => {write[" Aborted!"L]; CONTINUE}]};  RunInternal: PROCEDURE [    h: Token.Handle, Write: Format.StringProc,     checkAbort: PROC RETURNS[abort: BOOLEAN]] =    BEGIN    s: LONG STRING ¬ NIL;    switches: LONG STRING ¬ NIL;    localSwitches, globalSwitches: System.Switches ¬ defaultSwitches;    previousState: ToolWindow.State;    handle: MLoader.Handle;    Cleanup: PROC = {      Format.CR[Write];      z.FREE[@s]; s ¬ NIL;      z.FREE[@switches]; switches ¬ NIL};    DO      ENABLE UNWIND => Cleanup[];      IF checkAbort[] THEN ERROR ABORTED;      localSwitches ¬ globalSwitches;      s ¬ Token.Filtered[h, NIL, localFileName];      IF String.StringLength[s] = 0 AND h.break # '/ THEN EXIT;      IF h.break = '/ THEN {        switches ¬ Token.Filtered[h, NIL, Token.Switches];        IF String.StringLength[s] = 0 THEN {  --global switches           globalSwitches ¬ ProcessSwitches[switches, ExecInternal.codeLinks];	  z.FREE[@s]; s ¬ NIL;	  z.FREE[@switches]; switches ¬ NIL; LOOP}        ELSE localSwitches ¬ ProcessSwitches[switches, ExecInternal.codeLinks]};      IF ~ExecInternal.CanLookup[s] THEN {        Write["No file "L]; Write[s]; Cleanup[]; LOOP};      Write["Loading "L];      Write[s];      Write["..."L];      handle ¬ LoadInternal[        Write, s, localSwitches['v] = down,        localSwitches['l] = down !        ABORTED => IF ~checkAbort[] THEN {Cleanup[]; LOOP}];      IF handle # NIL THEN Format.LongOctal[Write, handle];      IF checkAbort[] THEN { 	IF handle # NIL THEN {	  MLoader.Unload[handle];          Write["...Aborted: unloading..."L]};	ERROR ABORTED};      IF localSwitches['d] = down THEN Runtime.CallDebugger["You called?"L];      IF handle # NIL THEN {        previousState ¬ SetDefaultState[localSwitches];        Write["...Starting..."L];        Start[          handle ! UNWIND => TajoOps.SetInitialToolStateDefault[previousState]];        TajoOps.SetInitialToolStateDefault[previousState]};      Cleanup[];      ENDLOOP;    END;  RunCommand: PROCEDURE [h: Handle, clientData: LONG POINTER ¬ NIL]    RETURNS [outcome: Exec.Outcome ¬ normal] =    BEGIN    get: PROCEDURE [Token.Handle] RETURNS [CHARACTER] ¬ {RETURN[Exec.GetChar[h]]};    check: PROCEDURE RETURNS [abort: BOOLEAN] =     {RETURN[Exec.CheckForAbort[h]]};    getToken: Token.Object ¬ [getChar: get, break: Ascii.NUL];    feedback: Format.StringProc ¬ IF h.userFeedback = NIL       THEN Exec.OutputProc[h] ELSE h.userFeedback;    IF Exec.CheckForAbort[h] THEN ERROR ABORTED;    RunInternal[@getToken, feedback, check];    END;  Query: PROCEDURE [h: Handle, clientData: LONG POINTER ¬ NIL]    RETURNS [outcome: Exec.Outcome ¬ normal]  =    BEGIN    OPEN Exec, ExecInternal;    commandLine: LONG STRING;    i: CARDINAL;    tempQ: Queue.QHead ¬ Queue.Init[];    sp: MFile.SearchPath ¬ NIL;    CleanUp: PROCEDURE = {      z.FREE[@commandLine]; Queue.Empty[@tempQ];      IF sp # NIL THEN MFile.FreeSearchPath[sp]};    pattern: STRING ¬ [MFile.maxNameLength];    lastDirSeen: STRING = [500];    first: BOOLEAN ¬ TRUE;    Write: Format.StringProc = OutputProc[h];    WriteFiles: MFile.EnumerateProc = {      fh: MFile.Handle ¬ NIL;      dirName: STRING = [500];      IF Exec.CheckForAbort[h] THEN {        PutChar[h, CR]; Format.Line[Write, "Aborted..."L]; ERROR ABORTED};      IF spIndex # MFile.searchPathNotUsed THEN {        String.AppendString[to: dirName, from: sp[spIndex]];	IF dirName[dirName.length-1] # '> THEN String.AppendChar[dirName, '>]};      String.AppendString[to: dirName, from: fullName];      FOR i: CARDINAL DECREASING IN [0..dirName.length) DO        IF dirName[i] = '> THEN {dirName.length ¬ i + 1; EXIT};	ENDLOOP;      IF String.EquivalentString[dirName, lastDirSeen] THEN PutChar[h, SP]      ELSE {        PutChar[h, CR];        Format.Line[Write, dirName];        PutChar[h, TAB];        lastDirSeen.length ¬ 0;        String.AppendString[to: lastDirSeen, from: dirName]};      Write[name];      IF type = directory AND name[name.length-1] # '> THEN Write[">"];      RETURN[FALSE]};    WriteCommands: PROCEDURE [      name: LONG STRING, proc, help, unload: Exec.ExecProc,      clientData: LONG POINTER] RETURNS [stop: BOOLEAN] = {      IF Exec.CheckForAbort[h] THEN {        Format.CR[Write]; Format.Line[Write, "Aborted..."L]; ERROR ABORTED};      IF MatchPattern[name, pattern] THEN {        IF ~first THEN PutChar[h, SP] ELSE first ¬ FALSE; Write[name]};      RETURN[FALSE]};    {ENABLE UNWIND => CleanUp[];    Queue.Copy[from: h.comQ, to: @tempQ];    i ¬ Queue.Count[@tempQ];    commandLine ¬ z.NEW[StringBody [i]];    Queue.QFToString[@tempQ, commandLine];    FOR i DECREASING IN [0..commandLine.length) DO      IF commandLine[i] = SP THEN {i ¬ i + 1; EXIT}; ENDLOOP;    FOR j: CARDINAL IN [i..commandLine.length) DO      String.AppendChar[pattern, String.LowerCase[commandLine[j]]] ENDLOOP;    IF pattern.length = 0 OR pattern[pattern.length - 1] # '* THEN      String.AppendChar[pattern, '*];    Exec.EnumerateCommands[WriteCommands];    IF ~first THEN {PutChar[h, CR]; first ¬ TRUE};    sp ¬ MFile.GetSearchPath[];    MFile.EnumerateDirectory[      pattern, WriteFiles, fileAndDirectories ! MFile.Error => CONTINUE];    CleanUp[]};    END;      RunHelp: Exec.ExecProc =     BEGIN    Exec.OutputProc[h]["Syntax: \"Run Program1.bcd Program2.bcd\".Switches: l -- use codelinks when loading	  d -- call the debugger after loading but before starting the program	  a, i or t -- 	     start the program in the active, inactive or tiny tool state."L];    Format.CR[Exec.OutputProc[h]];    END;      LoadHelp: Exec.ExecProc =     BEGIN    Exec.OutputProc[h]["Syntax: \"Load Program1.bcd Program2.bcd\".Switches: l -- use codelinks when loading."L];    Format.CR[Exec.OutputProc[h]];    END;      StartHelp: Exec.ExecProc =     BEGIN    Exec.OutputProc[h]["Syntax: \"Start <load handle>\".<load handle> is an octal number obtained by previously loading a program using the Load command.Switches: a, i or t --              start the program in the active, inactive or tiny state."L];    Format.CR[Exec.OutputProc[h]];    END;  Init: PROCEDURE =    BEGIN    --defaultSwitches['l] ¬ down;    Exec.AddCommand["Run.~"L, RunCommand, RunHelp];    Exec.AddCommand["Load.~"L, LoadCommand, LoadHelp];    Exec.AddCommand["Start.~"L, StartCommand, StartHelp];    Exec.AddCommand["?"L, Query];    END;  Init[];  END...
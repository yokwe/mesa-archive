-- Copyright (C) 1981, 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- ExpandImpl.mesa -  edited by-- PXK    ,	17-Dec-81 19:05:32-- SXW   ,	12-Jul-81 14:22:20-- JGS,		20-Aug-81 16:54:49-- LXR    ,	22-Oct-82 11:36:15-- BJD    ,	10-Jan-83 13:50:36-- AXD    ,	19-Apr-84 12:57:22DIRECTORY  Ascii USING [CR, NUL, SP],  ExecInternal USING [LookUpUniqueFile],  Expand,  Heap USING [systemZone],  MFile USING [EnumerateDirectory, EnumerateProc, Error],  MStream USING [Error, Handle, ReadOnly],  Queue,  Stream USING [Delete],  String USING [    AppendCharAndGrow, AppendStringAndGrow, CopyToNewString, Empty,    StringBoundsFault],  Token USING [GetCharProcType, MaybeQuoted, Object, UnterminatedQuote];ExpandImpl: PROGRAM  IMPORTS ExecInternal, Heap, MFile, MStream, String, Queue, Stream, Token  EXPORTS Expand =  BEGIN OPEN Expand;  ExpandQ: PUBLIC TYPE = Queue.ShortQ;  CR: CHARACTER = Ascii.CR;  NoChar: CHARACTER = 377C;  UnknownCommandFile: PUBLIC SIGNAL [LONG STRING] RETURNS [LONG STRING] = CODE;    z: UNCOUNTED ZONE = Heap.systemZone;  IsItemChar: PROCEDURE [c: CHARACTER] RETURNS [BOOLEAN] = {    RETURN[SELECT c FROM '/ => TRUE, ENDCASE => IsCommandChar[c]]};  IsCommandChar: PROCEDURE [c: CHARACTER] RETURNS [BOOLEAN] = {    RETURN[      SELECT c FROM        '~, '?, '*, '#, '+, '-, '., '!, '$, '<, '>, IN ['a..'z], IN ['A..'Z], IN          ['0..'9] => TRUE,        ENDCASE => FALSE]};  ExpandToTokens: PUBLIC PROCEDURE [    cmdLine: LONG STRING, proc: PROCEDURE [LONG STRING] RETURNS [BOOLEAN],    isAborted: AbortProcType, mask: Mask] =    BEGIN  -- does not disturb storage for cmdLine    i: CARDINAL ¬ 0;    arg: LONG STRING ¬ NIL;    temp: LONG STRING ¬ cmdLine;  -- so we still have a handle on the original string    GetChar: Token.GetCharProcType =      BEGIN      IF i >= temp.length THEN RETURN[Ascii.NUL];      c ¬ temp[i];      i ¬ i + 1;      END;    source: Token.Object ¬ [GetChar, Ascii.NUL];    temp ¬ ExpandString[temp, isAborted, mask];    WHILE i < temp.length DO      ENABLE UNWIND => {z.FREE[@arg]; z.FREE[@temp]};      z.FREE[@arg];      arg ¬ Token.MaybeQuoted[@source, NIL ! Token.UnterminatedQuote => RESUME];      IF arg = NIL OR proc[arg] THEN EXIT;      ENDLOOP;    z.FREE[@arg];    z.FREE[@temp];    END;  ExpandString: PUBLIC PROCEDURE [    cmdLine: LONG STRING, isAborted: AbortProcType, mask: Mask]    RETURNS [e: LONG STRING] =    BEGIN OPEN Queue;    toQ, fromQ: QHead ¬ Init[];    StringToQR[cmdLine, @fromQ];    WHILE ~IsEmpty[@fromQ] DO      ExpandQueues[@toQ, @fromQ, TRUE, isAborted, mask] ENDLOOP;    e ¬ z.NEW[StringBody[Count[@toQ]]];    QFToString[@toQ, e];    END;  ExpandQueues: PUBLIC PROCEDURE [    toQ, fromQ: ExpandQ, all: BOOLEAN ¬ FALSE, isAborted: AbortProcType,    mask: Mask] =    BEGIN OPEN Queue;    c, commentChar: CHARACTER ¬ Ascii.SP;    hasStar, inFileName, inComment: BOOLEAN ¬ FALSE;    IF IsEmpty[fromQ] THEN RETURN;    c ¬ GetF[fromQ];    DO      IF ~inComment AND hasStar AND mask.star AND ~IsItemChar[c] THEN {        ExpandStar[toQ, mask.localDirectory, isAborted]; hasStar ¬ FALSE};      SELECT c FROM        CR, '; => {	  IF inComment THEN inComment ¬ FALSE;          IF inFileName THEN {PutF[fromQ, c]; PutF[fromQ, '@]}          ELSE            IF all THEN PutR[toQ, c]            ELSE {              PutR[toQ, CR];              UNTIL IsEmpty[fromQ] DO                nc: CHARACTER ¬ GetF[fromQ];                IF nc # CR OR nc # '; THEN {PutF[fromQ, nc]; EXIT};                ENDLOOP;              RETURN}};        '' =>	    SELECT mask.quote FROM	      FALSE => IF ~inComment THEN PutR[toQ, c];              TRUE => IF ~IsEmpty[fromQ] THEN {	        c ¬ GetF[fromQ]; IF ~inComment THEN PutR[toQ, c]};	      ENDCASE;        136C, 255C => -- arrows          SELECT mask.upArrow FROM            skip => {              IF ~inComment THEN PutR[toQ, c];              IF ~IsEmpty[fromQ] THEN {	        c ¬ GetF[fromQ]; IF ~inComment THEN PutR[toQ, c]}};            remove => IF ~IsEmpty[fromQ] THEN c ¬ GetF[fromQ];            ENDCASE => IF ~inComment THEN PutR[toQ, c];        '/, '- => {          oldC: CHARACTER = c;	  SELECT TRUE FROM	    IsEmpty[fromQ] => IF ~inComment THEN PutR[toQ, oldC]; -- no more chars, so not comment	    (c ¬ GetF[fromQ]) # oldC => { -- not successive comment chars 	      IF ~inComment THEN PutR[toQ, oldC];  	      LOOP};	    commentChar # oldC AND inComment => NULL; -- successive comment chars, but not matching opening comment             ENDCASE =>  -- comment chars	      IF inFileName THEN {	        PutF[fromQ, c]; PutF[fromQ, c]; PutF[fromQ, '@]}	      ELSE {	       inComment ¬ ~inComment; commentChar ¬ oldC; 	       inFileName ¬ FALSE}};        '@ =>  IF ~inComment THEN {            IF (inFileName ¬ ~inFileName) OR ~mask.atSign THEN PutR[toQ, '@]            ELSE {              expQ: QHead ¬ Init[];              SubstFile[toQ, @expQ, mask.localDirectory];              fromQ­ ¬ Concatenate[@expQ, fromQ]}};        '*, '# => IF ~inComment THEN {hasStar ¬ TRUE; PutR[toQ, c]};        NoChar => EXIT;        Ascii.SP => IF ~inComment THEN {          IF inFileName THEN {PutF[fromQ, c]; PutF[fromQ, '@]} 	  ELSE PutR[toQ, c]};        ENDCASE => IF ~inComment THEN PutR[toQ, c];      IF IsEmpty[fromQ] THEN {IF inFileName THEN c ¬ '@ ELSE c ¬ NoChar}      ELSE c ¬ GetF[fromQ];      IF isAborted # NIL AND isAborted[] THEN ERROR ABORTED;      ENDLOOP;    RETURN    END;  ExpandStar: PROC [    toQ: Queue.ShortQ, localDir: LONG STRING, isAborted: AbortProcType] =    BEGIN OPEN Queue;    fnQ, swQ: QHead ¬ Init[];    pattern: STRING = [300];    fullDirName: LONG STRING;    AddItem: MFile.EnumerateProc =      BEGIN      StringToQR[fullName, toQ];      Copy[from: @swQ, to: toQ];      PutR[toQ, ' ];      IF isAborted # NIL AND isAborted[] THEN ERROR ABORTED;      RETURN[FALSE]      END;    {ENABLE UNWIND => z.FREE[@fullDirName];    XferQWhile[GetR, PutR, toQ, PutF, @swQ, IsItemChar];    XferQWhile[GetF, PutF, @swQ, PutR, @fnQ, IsCommandChar];    QFToString[@fnQ, pattern ! String.StringBoundsFault =>     CONTINUE];    IF String.Empty[localDir] THEN fullDirName ¬ String.CopyToNewString[pattern, z]    ELSE {      IF localDir[0]#'< THEN {        fullDirName ¬ String.CopyToNewString["<>"L, z];	String.AppendStringAndGrow[@fullDirName, localDir, z]}      ELSE fullDirName ¬ String.CopyToNewString[localDir, z];      IF fullDirName[fullDirName.length-1]#'> THEN        String.AppendCharAndGrow[@fullDirName, '>, z];      String.AppendStringAndGrow[@fullDirName, pattern, z];    };    MFile.EnumerateDirectory[      fullDirName, AddItem, fileAndDirectories !      ABORTED, MFile.Error => Queue.Empty[@swQ]];    Queue.Empty[@swQ];    z.FREE[@fullDirName]    }    END;      XferQWhile: PROCEDURE [    sourceGet: PROCEDURE [Queue.Q] RETURNS [CHARACTER],    sourcePutBack: PROCEDURE [Queue.Q, UNSPECIFIED], sourceQ: Queue.ShortQ,    destPut: PROCEDURE [Queue.Q, UNSPECIFIED], destQ: Queue.ShortQ,    test: PROCEDURE [CHARACTER] RETURNS [BOOLEAN]] =    BEGIN    c: CHARACTER;    UNTIL Queue.IsEmpty[sourceQ] DO      IF test[c ¬ sourceGet[sourceQ]] THEN destPut[destQ, c]      ELSE {sourcePutBack[sourceQ, c]; EXIT};      ENDLOOP;    RETURN    END;  SubstFile: PROCEDURE [toQ, expQ: Queue.ShortQ, localDirectory: LONG STRING] =    BEGIN OPEN Queue;    stream: MStream.Handle ¬ NIL;    c: CHARACTER;    tempQ: QHead ¬ Init[];    name: STRING ¬ [100];    WHILE (c ¬ GetR[toQ]) # '@ DO PutF[@tempQ, c] ENDLOOP;    IF ~String.Empty[localDirectory] THEN {      IF localDirectory[localDirectory.length-1] # '> THEN PutF[@tempQ, '>];      FOR i: CARDINAL DECREASING IN [0..localDirectory.length) DO         PutF[@tempQ, localDirectory[i]] ENDLOOP    };    QFToString[      @tempQ, name !      String.StringBoundsFault => {        --Write[CR];        --WriteF["File name too long! (unbalanced @'s?)         --Partial name:  *1"L, name];        ERROR ABORTED}];    IF ExecInternal.LookUpUniqueFile[name]      OR ExecInternal.LookUpUniqueFile[name, ".cm"]      OR ExecInternal.LookUpUniqueFile[name, "*.cm"L] THEN      stream ¬ MStream.ReadOnly[name, [] ! MStream.Error => CONTINUE];    IF stream # NIL THEN {Queue.StreamToQR[stream, @tempQ]; Stream.Delete[stream]}    ELSE {      ENABLE UNWIND => expQ­ ¬ Concatenate[@tempQ, expQ];      str: LONG STRING ¬ SIGNAL UnknownCommandFile[name];      StringToQR[str, @tempQ];      z.FREE[@str]};    expQ­ ¬ Concatenate[@tempQ, expQ];    END;      END...
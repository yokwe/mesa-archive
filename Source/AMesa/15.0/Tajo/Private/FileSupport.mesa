-- File: FileSupport.mesa - last edit:-- Riggle.PA            8-Aug-86 16:06:54-- Copyright (C) 1981, 1982, 1983, 1984 , 1986, 1986 by Xerox Corporation. All rights reserved. -- file: FileSupport.mesa  last edited by-- SXW   	12-Jul-81 11:16:29-- BXM  		12-Nov-81 17:22:35-- PXK  PXK    	Dec 11, 1980 4:46 PM-- Mark		Oct 11, 1980 10:28 PM-- LXR    	21-Oct-82 15:50:19-- JGS		 3-Sep-81 19:01:01-- RXJ     	 6-Dec-82 20:14:21-- RXR   	19-Apr-83 13:21:27-- BJD    	10-Oct-84 10:56:54DIRECTORY  Expand USING [ExpandToTokens, UnknownCommandFile],  FileToolOps USING [Cmd, Finished, FTPCommand, ListOptionsArray],  FileName USING [    Error, ResetVFN, UnpackFilename, VirtualFilename, VirtualFilenameObject],  FileTransfer USING [    Close, CodeToString, Copy, Delete, Enumerate, Error, FileInfo,     GetProcs, GetServerType, ListProc, MessageProc, Rename,    ServerType, SetSecondaryCredentials, Severity],  Format USING [Date, Decimal, LongNumber, StringProc],  Heap USING [systemZone],  MFile USING [AppendErrorMessage, Error],  Process USING [GetPriority, Priority, priorityNormal, SetPriority],  String USING [    AppendChar, AppendCharAndGrow, AppendString, CopyToNewString,     Empty, EquivalentString, MakeString, StringBoundsFault],  Time USING [Packed];FileSupport: MONITOR  IMPORTS     Expand, FileName, FileToolOps, FileTransfer, Format,    Heap, MFile, Process, String  EXPORTS FileToolOps =  BEGIN  -- global types and data  FileTry: TYPE = {none, found, aborted};  FileTryProc: TYPE = PROCEDURE [LONG STRING] RETURNS [FileTry];  z: UNCOUNTED ZONE = Heap.systemZone;  fieldSize: CARDINAL = 110;  CarriageReturn: LONG STRING = ""L;  -- common procedures  Close: INTERNAL PROCEDURE [parms: FileToolOps.Cmd] = {    FileTransfer.Close[parms.connection]};  Delete: INTERNAL PROCEDURE [state: FileToolOps.Cmd, remote: BOOLEAN] =    BEGIN    post: FileTransfer.MessageProc;    data: LONG POINTER;    expandStar, willHaveLocalDir: BOOLEAN;    vfn: FileName.VirtualFilenameObject ¬ [NIL, NIL, NIL, NIL];    DeleteSome: INTERNAL PROCEDURE [name: LONG STRING] RETURNS [f: FileTry] = {      SetVFN[state, name, @vfn, willHaveLocalDir, remote];      f ¬ none;      IF remote AND String.Empty[vfn.host] THEN {        post[data, fatal, "No host specified."L, CarriageReturn]; f ¬ aborted}      ELSE        FileTransfer.Delete[          state.connection, @vfn, state.veto !          FileTransfer.Error => {	    SELECT code FROM illegalLogin => f ¬ aborted; skipFile => RESUME;	      ENDCASE;	    CONTINUE}];      RETURN};    [data, post, , ] ¬ FileTransfer.GetProcs[state.connection];    post[      data, terse, IF remote THEN "Remote"L ELSE "Local"L, " delete of "L,      state.sourceName, CarriageReturn];    IF remote THEN SetContext[state];    expandStar ¬ ~remote OR ~state.quoted;    willHaveLocalDir ¬ HasWildCard[state.sourceName] AND    			 expandStar AND ~String.Empty[state.localdir];    ParseFiles[      state, DeleteSome, post, data, expandStar !          UNWIND => FreeMyVFN[@vfn]];    FreeMyVFN[@vfn];    END;  Rename: INTERNAL PROCEDURE [state: FileToolOps.Cmd, remote: BOOLEAN] =    BEGIN    newVFN: FileName.VirtualFilenameObject ¬ [NIL, NIL, NIL, NIL];    post: FileTransfer.MessageProc;    data: LONG POINTER;    vfn: FileName.VirtualFilenameObject ¬ [NIL, NIL, NIL, NIL];    RenameOne: INTERNAL PROCEDURE [name: LONG STRING] RETURNS [f: FileTry] = {      SetVFN[state, name, @vfn, remote];      f ¬ none;      IF remote AND String.Empty[vfn.host] THEN {        post[data, fatal, "No host specified."L, CarriageReturn]; f ¬ aborted}      ELSE        FileTransfer.Rename[          state.connection, @vfn, @newVFN !          FileTransfer.Error => {IF code = illegalLogin THEN f ¬ aborted; CONTINUE}];      RETURN};    [data, post, , ] ¬ FileTransfer.GetProcs[state.connection];    post[      data, terse, IF remote THEN "Remote"L ELSE "Local"L, " rename of "L,      state.sourceName, CarriageReturn];    IF String.Empty[state.destName] THEN {      post[data, fatal, "No destination given!"L, CarriageReturn]; RETURN};    IF remote THEN SetContext[state];    SetVFN[state, state.destName, @newVFN, remote];    ParseFiles[      state, RenameOne, post, data, ~remote OR ~state.quoted !      UNWIND => {FreeMyVFN[@newVFN]; FreeMyVFN[@vfn]}];    FreeMyVFN[@vfn];    FreeMyVFN[@newVFN];    END;  List: INTERNAL PROCEDURE [state: FileToolOps.Cmd, remote: BOOLEAN] =    BEGIN    fileTry: FileTry;    files: CARDINAL ¬ 0;    currentDirectory: LONG STRING ¬ NIL;    post: FileTransfer.MessageProc;    data: LONG POINTER;    expandStar, willHaveLocalDir, allDescendants: BOOLEAN ¬ FALSE;    vfn: FileName.VirtualFilenameObject ¬ [NIL, NIL, NIL, NIL];    ListOne: INTERNAL FileTransfer.ListProc = {      IF FileTransfer.GetServerType[conn, NIL] = ns THEN         RETURN[NSListOne[conn, clientData, file, post, info]]      ELSE        RETURN[IfsLocalListOne[conn, clientData, file, post, info]]};    NSListOne: INTERNAL FileTransfer.ListProc = {      name: STRING = [fieldSize];      source: FileTransfer.FileInfo;      IF state.veto # NIL         AND state.veto[conn, data, post, info, FALSE].confirm # do THEN {          fileTry ¬ aborted; RETURN[abort]};      fileTry ¬ found;      source ¬ info[conn].source;      IF (source.type = directory) AND allDescendants THEN NULL -- do nothing      ELSE {	  IF ~String.EquivalentString[currentDirectory, source.directory] THEN	    BEGIN	    PutNameInfo[	      name: source.directory, info: NIL, isDirectory: TRUE,	      options: state.options, post: post, data: data, serverType: ns];	    z.FREE[@currentDirectory];	    currentDirectory ¬ String.CopyToNewString[source.directory, z];	    END;	  String.AppendString[name, source.body];	  IF ~String.Empty[source.version] THEN {	    String.AppendChar[name, '!];	    String.AppendString[name, source.version]};          PutNameInfo[	    name: name, info: source, isDirectory: FALSE,	    options: state.options, post: post, data: data, serverType: ns];          files ¬ files + 1};      RETURN[do]};    IfsLocalListOne: INTERNAL FileTransfer.ListProc = {      name: STRING = [fieldSize];      fName: FileName.VirtualFilenameObject ¬ [NIL, NIL, NIL, NIL];      source: FileTransfer.FileInfo;      IF state.veto # NIL         AND state.veto[conn, data, post, info, FALSE].confirm # do THEN {          fileTry ¬ aborted; RETURN[abort]};      fileTry ¬ found;      source ¬ info[conn ! MFile.Error => IF code = conflictingAccess THEN {        source ¬ NIL; CONTINUE}].source;      FileName.UnpackFilename[file, @fName];      IF ~String.EquivalentString[currentDirectory, fName.directory] THEN        BEGIN        PutNameInfo[fName.directory, NIL, TRUE, state.options, post, data];        z.FREE[@currentDirectory];        currentDirectory ¬ String.CopyToNewString[fName.directory, z];        END;      String.AppendString[name, fName.name];      IF ~String.Empty[fName.version] THEN {        String.AppendChar[name, '!];        String.AppendString[name, fName.version]};      SELECT TRUE FROM        source = NIL => 	  post[data, terse, name, " can't access."L, CarriageReturn];        ~source.oldFile =>          post[data, terse, name, " not found."L, CarriageReturn];        ENDCASE => {          PutNameInfo[name, source, FALSE, state.options, post, data];          files ¬ files + 1};      FreeMyVFN[@fName];      RETURN[do]};    ListSome: INTERNAL PROCEDURE [name: LONG STRING] RETURNS [FileTry] =      BEGIN      fileTry ¬ none;      SetVFN[state, name, @vfn, willHaveLocalDir, remote];      allDescendants ¬ HasWildCard[vfn.directory];      IF remote AND String.Empty[vfn.host] THEN {        post[data, fatal, "No host specified."L, CarriageReturn];        fileTry ¬ aborted}      ELSE        FileTransfer.Enumerate[          state.connection, @vfn, ListOne !          FileTransfer.Error => {            IF code = illegalLogin THEN fileTry ¬ aborted; CONTINUE}];      IF fileTry = found THEN        PutNameInfo[NIL, NIL, TRUE, state.options, post, data];      RETURN[fileTry]      END;    [data, post, , ] ¬ FileTransfer.GetProcs[state.connection];    post[      data, terse, IF remote THEN "Remote"L ELSE "Local"L, " list of "L,      state.sourceName, CarriageReturn];    IF remote THEN SetContext[state];    IF String.Empty[state.sourceName] THEN      [] ¬ ListSome[        NIL ! UNWIND => {z.FREE[@currentDirectory]; FreeMyVFN[@vfn]}]    ELSE {      expandStar ¬ ~state.quoted;      willHaveLocalDir ¬ HasWildCard[state.sourceName]      			AND expandStar AND ~String.Empty[state.localdir];      ParseFiles[        state, ListSome, post, data, expandStar !        UNWIND => {z.FREE[@currentDirectory]; FreeMyVFN[@vfn]}]    };    FreeMyVFN[@vfn];    IF currentDirectory#NIL THEN z.FREE[@currentDirectory];    IF fileTry = aborted THEN RETURN;    SELECT files FROM      > 1 => {        P: Format.StringProc = {          post[	   data, terse, " Total of "L, s, " files"L, CarriageReturn]};        Format.Decimal[P, files]};      ENDCASE;    END;  -- procedures on remote files  ListFiles: INTERNAL PROCEDURE [state: FileToolOps.Cmd] = {List[state, TRUE]};  RemoteRename: INTERNAL PROCEDURE [state: FileToolOps.Cmd] = {    Rename[state, TRUE]};  DeleteFiles: INTERNAL PROCEDURE [state: FileToolOps.Cmd] = {    Delete[state, TRUE]};  RetrieveFiles: INTERNAL PROCEDURE [state: FileToolOps.Cmd] =    BEGIN    localVFN: FileName.VirtualFilenameObject ¬ [NIL, NIL, NIL, NIL];    vfn: FileName.VirtualFilenameObject ¬ [NIL, NIL, NIL, NIL];    post: FileTransfer.MessageProc;    expandStar, willHaveLocalDir: BOOLEAN;    data: LONG POINTER;    GetSome: INTERNAL PROCEDURE [pathname: LONG STRING]      RETURNS [fileTry: FileTry] =      BEGIN      fileTry ¬ found;      SetVFN[state, pathname, @vfn, willHaveLocalDir, TRUE];      IF String.Empty[vfn.host] THEN {        post[data, fatal, "No host specified."L, CarriageReturn];        RETURN[aborted]};      FileTransfer.Copy[        sourceConn: state.connection, sourceFile: @vfn, destFile: @localVFN,        veto: state.veto, showDates: state.showDates !        FileTransfer.Error => {          IF code = illegalLogin THEN fileTry ¬ aborted ELSE fileTry ¬ none; CONTINUE}];      END;    [data, post, , ] ¬ FileTransfer.GetProcs[state.connection];    SetContext[state];    post[data, terse, "Retrieve of "L, state.sourceName, CarriageReturn];    SetVFN[state, state.destName, @localVFN, FALSE, FALSE];    expandStar ¬ ~state.quoted;    willHaveLocalDir ¬ HasWildCard[state.sourceName] AND    		  expandStar AND ~String.Empty[state.localdir];    ParseFiles[      state, GetSome, post, data, expandStar !      UNWIND => {FreeMyVFN[@vfn]; FreeMyVFN[@localVFN]}];    FreeMyVFN[@vfn];    FreeMyVFN[@localVFN];    END;  StoreFiles: INTERNAL PROCEDURE [state: FileToolOps.Cmd] =    BEGIN    remoteVFN: FileName.VirtualFilenameObject ¬ [NIL, NIL, NIL, NIL];    vfn: FileName.VirtualFilenameObject ¬ [NIL, NIL, NIL, NIL];    post: FileTransfer.MessageProc;    willHaveLocalDir: BOOLEAN;    data: LONG POINTER;    StoreOne: INTERNAL PROCEDURE [file: LONG STRING] RETURNS [fileTry: FileTry] =      BEGIN      fileTry ¬ found;      SetVFN[state, file, @vfn, willHaveLocalDir, FALSE];      FileTransfer.Copy[        sourceConn: NIL, sourceFile: @vfn, destFile: @remoteVFN,        destConn: state.connection, veto: state.veto, showDates: state.showDates !        FileTransfer.Error => {          IF code = illegalLogin THEN fileTry ¬ aborted ELSE fileTry ¬ none; CONTINUE}];      z.FREE[@remoteVFN.version];       END;    [data, post, , ] ¬ FileTransfer.GetProcs[state.connection];    post[data, terse, "Store of "L, state.sourceName, CarriageReturn];    SetContext[state];    SetVFN[state, state.destName, @remoteVFN, FALSE, TRUE];    IF String.Empty[remoteVFN.host] THEN {      post[data, fatal, "No host specified."L, CarriageReturn];      FreeMyVFN[@vfn];      RETURN};   -- In the case of Store, expansion is always done in Expand, regardless of quoted.    willHaveLocalDir ¬ HasWildCard[state.sourceName] AND    			~String.Empty[state.localdir];    ParseFiles[          state, StoreOne, post, data, TRUE !      UNWIND => {FreeMyVFN[@vfn]; FreeMyVFN[@remoteVFN]}];    FreeMyVFN[@vfn];    FreeMyVFN[@remoteVFN];    END;  -- procedures on local files  DeleteLocal: INTERNAL PROCEDURE [state: FileToolOps.Cmd] = {    Delete[state, FALSE]};  RenameLocal: INTERNAL PROCEDURE [state: FileToolOps.Cmd] = {    Rename[state, FALSE]};  ListLocal: INTERNAL PROCEDURE [state: FileToolOps.Cmd] = {List[state, FALSE]};  CopyLocal: INTERNAL PROCEDURE [state: FileToolOps.Cmd] =    BEGIN    destVFN: FileName.VirtualFilenameObject ¬ [NIL, NIL, NIL, NIL];    sourceVFN: FileName.VirtualFilenameObject ¬ [NIL, NIL, NIL, NIL];    post: FileTransfer.MessageProc;    willHaveLocalDir: BOOLEAN;    data: LONG POINTER;    CopyOne: INTERNAL PROCEDURE [file: LONG STRING] RETURNS [fileTry: FileTry] = {      fileTry ¬ found;      SetVFN[state, file, @sourceVFN, willHaveLocalDir, FALSE];      FileTransfer.Copy[        sourceConn: state.connection, sourceFile: @sourceVFN, destFile: @destVFN,        veto: state.veto, showDates: state.showDates !        FileTransfer.Error => {          IF code = illegalLogin THEN fileTry ¬ aborted ELSE fileTry ¬ none; CONTINUE}]};    [data, post, , ] ¬ FileTransfer.GetProcs[state.connection];    post[data, terse, "Copy of "L, state.sourceName, " to "L, state.destName];    post[data, terse, CarriageReturn];    SetContext[state];    SetVFN[state, state.destName, @destVFN, FALSE, FALSE];   -- In the case of Store, expansion is always done in Expand, regardless of quoted.    willHaveLocalDir ¬ HasWildCard[state.sourceName]     		  AND ~String.Empty[state.localdir];    ParseFiles[      state, CopyOne, post, data, TRUE !      UNWIND => {FreeMyVFN[@sourceVFN]; FreeMyVFN[@destVFN]}];    FreeMyVFN[@sourceVFN];    FreeMyVFN[@destVFN];    END;  -- utility routines  SetContext: PROCEDURE [state: FileToolOps.Cmd] =    BEGIN    FileTransfer.SetSecondaryCredentials[      state.connection, state.connectName, state.connectPassword];    END;  FreeMyVFN: PROCEDURE [vfn: FileName.VirtualFilename] = INLINE    BEGIN FileName.ResetVFN[vfn, TRUE, TRUE, TRUE, TRUE]; END;      SetVFN: PROCEDURE [    state: FileToolOps.Cmd, name: LONG STRING, vfn: FileName.VirtualFilename,    expandedWithDir: BOOLEAN, remote: BOOLEAN ¬ TRUE] =  -- Create a vfn from the fields of the FileTool; expandedWithDir is TRUE if any *'s were expanded with localdir.     BEGIN ENABLE {      UNWIND => FreeMyVFN[vfn];      FileName.Error => {        data: LONG POINTER;	post: FileTransfer.MessageProc;        [data, post, , ] ¬ FileTransfer.GetProcs[state.connection];        post[data, fatal, name, " is an illegal file name"L, CarriageReturn];	ERROR FileName.Error}};    FreeMyVFN[vfn];    IF remote THEN {      vfn.host ¬ String.CopyToNewString[state.host, z];      vfn.directory ¬ String.CopyToNewString[state.directory, z];      IF expandedWithDir THEN {        -- name will contain localdir = "<vol>dir"        fileName: LONG STRING ¬ [fieldSize];	StripLocalDirectory[state.localdir, name, fileName];	FileName.UnpackFilename[fileName, vfn ]}      ELSE FileName.UnpackFilename[name, vfn]}    ELSE { -- local      IF ~String.Empty[name] AND name[0] = '< THEN -- volume specified;	FileName.UnpackFilename[name, vfn]              -- ignore local dir      ELSE        BEGIN        IF ~String.Empty[state.localdir] THEN {          vfn.directory ¬ String.MakeString[z: z, maxlength: state.localdir.length+2];          IF state.localdir[0] # '< THEN String.AppendString[vfn.directory, "<>"L];          String.AppendString[vfn.directory, state.localdir]};        FileName.UnpackFilename[name, vfn]	END;      IF ~String.Empty[name] AND name[name.length-1] = '> THEN        String.AppendCharAndGrow[@vfn.directory, '>, z]    }    END;      StripLocalDirectory: PROCEDURE [    localdir: LONG STRING, pathname: LONG STRING, stripped: LONG STRING] =    BEGIN    length: CARDINAL;    IF String.Empty[localdir] THEN RETURN;    length ¬ IF localdir[0]#'<       THEN localdir.length+2 -- "<>localdir"      ELSE localdir.length;    IF localdir[localdir.length-1] = '> THEN length ¬ length-1;    FOR i: CARDINAL IN [length+1..pathname.length) DO      String.AppendChar[stripped, pathname[i] !         String.StringBoundsFault => EXIT] ENDLOOP;    END;   ParseFiles: PROCEDURE [    state: FileToolOps.Cmd, proc: FileTryProc, post: FileTransfer.MessageProc,    data: LONG POINTER, expandStar: BOOLEAN] =    BEGIN    tokens: LONG STRING = state.sourceName;    P: PROCEDURE [token: LONG STRING] RETURNS [BOOLEAN] =      BEGIN      IF String.Empty[token] THEN RETURN[TRUE];      RETURN[proc[token] = aborted];      END;    -- If any expansion is done with the localdir, the complete pathname is returned;    Expand.ExpandToTokens[      cmdLine: tokens, proc: P,       mask: [star: expandStar, atSign: TRUE, upArrow: remove,             quote: TRUE, localDirectory: state.localdir] !        Expand.UnknownCommandFile => {          post[data, fatal, "Can't find command file "L, name, CarriageReturn];          CONTINUE}];    END;  HasWildCard: PUBLIC PROC [name: LONG STRING] RETURNS [BOOLEAN] = {    IF String.Empty[name] THEN      RETURN[FALSE];    FOR i: CARDINAL IN [0..name.length) DO      IF name[i] = '* THEN RETURN[TRUE]; ENDLOOP;    RETURN[FALSE]};      PutNameInfo: PROCEDURE [    name: LONG STRING, info: FileTransfer.FileInfo, isDirectory: BOOLEAN,    options: FileToolOps.ListOptionsArray, post: FileTransfer.MessageProc,    data: LONG POINTER, level: FileTransfer.Severity ¬ terse,    serverType: FileTransfer.ServerType ¬ null] = {    OPEN FileToolOps;    sepC: CHARACTER = IF serverType = ns THEN '/ ELSE '>;    sepS: LONG STRING = IF serverType = ns THEN "/"L ELSE ">"L;    noOptions: ListOptionsArray = ALL[FALSE];    WriteDate: Format.StringProc = {post[data, level, " ", s]};    IF isDirectory THEN {      IF options = noOptions THEN post[data, level, CarriageReturn];      IF ~String.Empty[name] THEN {        hasIt: BOOLEAN ¬ FALSE;        FOR i: CARDINAL IN [0..name.length) DO          IF name[i] = sepC THEN {hasIt ¬ TRUE; EXIT};	  ENDLOOP;        post[data, level, name, IF ~hasIt THEN sepS ELSE " ", CarriageReturn]}}    ELSE {      post[data, level, " "L, IF options # noOptions THEN " "L ELSE NIL, name];      IF options # noOptions THEN {        Space: STRING = "                         "L;  -- max of 25 blanks        PrintNumber: Format.StringProc = {post[data, level, s]};        Space.length ¬ 25 - MIN[24, name.length];        post[data, level, Space];        IF options[type] THEN          post[            data, level,            SELECT info.type FROM              text => "text    "L,              binary => "binary  "L,	      directory => "directory "L,              unknown, null => "unknown "L,              ENDCASE => ERROR];        IF options[bytes] THEN          Format.LongNumber[            PrintNumber, info.size, [            base: 10, zerofill: FALSE, unsigned: TRUE, columns: 8]];        IF options[create] THEN Format.Date[WriteDate, info.create, full];        IF options[write] THEN Format.Date[WriteDate, info.write, full];        IF options[read] THEN Format.Date[WriteDate, info.read, full];        IF options[author] AND ~String.Empty[info.author] THEN          post[data, level, " "L, info.author];        post[data, level, CarriageReturn]}}};  WriteDate: PROCEDURE [    date: Time.Packed, post: FileTransfer.MessageProc, data: LONG POINTER,    level: FileTransfer.Severity ¬ terse] =    BEGIN    P: Format.StringProc = {post[data, level, "["L, s, "]"L]};    Format.Date[P, date, full];    END;  -- background loop and process stuff  GiveCommand: PUBLIC ENTRY PROCEDURE [    command: FileToolOps.FTPCommand, parms: FileToolOps.Cmd] =    BEGIN    ENABLE UNWIND => NULL;    priority: Process.Priority = Process.GetPriority[];    post: FileTransfer.MessageProc;    data: LONG POINTER;    [data, post, , ] ¬ FileTransfer.GetProcs[parms.connection];    BEGIN ENABLE {      ABORTED => {post[data, fatal, "Aborted"L, CarriageReturn]; CONTINUE};      FileName.Error => CONTINUE;  -- error message printed in SetVFN      FileTransfer.Error => {        s: STRING = [50];        FileTransfer.CodeToString[code, s];        post[data, fatal, s, CarriageReturn];        CONTINUE};      MFile.Error => {        msg: LONG STRING = [200];	MFile.AppendErrorMessage[msg, code, file];        post[data, fatal, msg, CarriageReturn];	CONTINUE}};    IF priority > Process.priorityNormal THEN      Process.SetPriority[Process.priorityNormal];    SELECT command FROM      close => Close[parms];      copy => CopyLocal[parms];      localDelete => DeleteLocal[parms];      localList => ListLocal[parms];      localRename => RenameLocal[parms];      remoteRename => RemoteRename[parms];      remoteList => ListFiles[parms];      remoteDelete => DeleteFiles[parms];      retrieve => RetrieveFiles[parms];      store => StoreFiles[parms];      null => NULL      ENDCASE => ERROR;    END;  -- ENABLE    FileToolOps.Finished[parms];    END;  -- main program  END.  
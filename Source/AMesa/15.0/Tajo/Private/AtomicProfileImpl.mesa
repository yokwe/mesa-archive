-- AtomicProfileImpl.mesa  -- HAL  	10-Nov-83 12:12:36  Install Ayers fix to KillItems-- DON	 	83-Dec-09  6:32 pm  Accomodate changes in Atom & XString-- JGS 		11-Jun-84 14:52:19  update to 2.0b defs-- DSC   	 2-Jul-85 16:30:28DIRECTORY  Atom USING [ATOM],  AtomicProfile,  Event USING [tajoDefaults],  EventTypesExtra,  Heap USING [Create],  String USING [CopyToNewString],  Supervisor USING [ClientsImpls, Event, NotifyDirectSubsystems];AtomicProfileImpl: MONITOR  IMPORTS Event, Heap, String, Supervisor EXPORTS AtomicProfile =  BEGIN  zone: UNCOUNTED ZONE ¬ Heap.Create[initial: 2];  -- part of tajoDefault events.  event: Supervisor.Event ¬ EventTypesExtra.atomicProfileChange;  -- Add more as you wish. Consider a plain pointer  ItemTypes: TYPE = {string, int, boolean};  -- Demon types.  FetchStringProc: TYPE = AtomicProfile.FetchStringProc;  FetchIntegerProc: TYPE = AtomicProfile.FetchIntegerProc;  FetchBooleanProc: TYPE = AtomicProfile.FetchBooleanProc;  -- Set and Get errors.    SetError: PUBLIC ERROR = CODE;  GetError: PUBLIC ERROR = CODE;    -- For Items without values, but with demons.  ItemState: TYPE = AtomicProfile.ItemState;  -- basic object  Item: TYPE = RECORD [    next: ItemHandle ¬ NIL,    atom: Atom.ATOM ¬ NIL,    state: ItemState ¬ invalid,    body: SELECT type: ItemTypes FROM      string => [        val: LONG STRING ¬ NIL,        immutable: BOOLEAN ¬ FALSE,        pleaseFree: BOOLEAN ¬ FALSE,        clientCount: CARDINAL ¬ 0,        fetchProc: FetchStringProc ¬ NIL],      int => [int: LONG INTEGER ¬ 0, fetchProc: FetchIntegerProc ¬ NIL],      boolean => [boolean: BOOLEAN ¬ FALSE, fetchProc: FetchBooleanProc ¬ NIL],      ENDCASE];  ItemHandle: TYPE = LONG POINTER TO Item;  -- Global linked list of objects. Change to SymTab or RefTab later.  thread: LONG POINTER TO Item ¬ NIL;  -- Returns ItemHandle for Item if found, NIL if not.  ScanForItem: INTERNAL PROCEDURE [atom: Atom.ATOM] RETURNS [ItemHandle] = {    FOR i: ItemHandle ¬ thread, i.next UNTIL i = NIL DO      IF i.atom = atom THEN RETURN[i]; ENDLOOP;    RETURN[NIL]};  -- delete items that match the atom.  KillItems: INTERNAL PROCEDURE [atom: Atom.ATOM] = {    i: ItemHandle;    IF thread = NIL THEN RETURN;    WHILE thread # NIL AND thread.atom = atom DO      i ¬ thread; thread ¬ thread.next; DeleteItem[i]; ENDLOOP;    IF thread # NIL THEN      BEGIN      i ¬ thread;      UNTIL i.next = NIL DO        IF i.next.atom = atom THEN {          j: ItemHandle ¬ i.next; i.next ¬ i.next.next; DeleteItem[j]}        ELSE i ¬ i.next;        ENDLOOP;      END;    RETURN};  -- Free the item. Special case for strings.  -- Free the string if no one reers to it and is not immutable.  DeleteItem: INTERNAL PROCEDURE [i: ItemHandle] = {    WITH it: i SELECT FROM      string =>        IF it.clientCount = 0 AND ~it.immutable THEN zone.FREE[@it.val]        ELSE it.pleaseFree ¬ TRUE;      ENDCASE;    zone.FREE[@i]};  -- sets the value of atom to be string, or arrange for value to be retrieved via the fetchDemon.  SetString: PUBLIC PROCEDURE [    atom: Atom.ATOM, string: LONG STRING, immutable: BOOLEAN ¬ FALSE,    fetchDemon: FetchStringProc ¬ NIL] = {    i: ItemHandle ¬ ScanForItemEntry[atom];    SELECT TRUE FROM      string # NIL AND fetchDemon # NIL => -- both info given -- {        SELECT TRUE FROM          i # NIL => -- old entry -- {            i.state ¬ valid;            StuffString[atom, string, immutable];            SetStrProc[atom, fetchDemon]};          i = NIL => -- new entry -- {SetStringEntry[atom, string, immutable]};          ENDCASE};      string = NIL AND fetchDemon # NIL -- late binding since val is not given. --        => {        IF i = NIL THEN -- first time around? -- {          si: LONG POINTER TO string Item;          si ¬ zone.NEW[            string Item ¬ [            next: thread, atom: atom, body: string[val:, immutable: immutable]]];          si.val ¬ NIL;          thread ¬ si;          i ¬ si};        i.state ¬ invalid;        SetStrProc[atom, fetchDemon]};      string # NIL AND fetchDemon = NIL -- set it now -- => {        SetStringEntry[atom, string, immutable]};      string = NIL AND fetchDemon = NIL -- bad -- => {ERROR SetError};      -- Should never fall through.      ENDCASE => ERROR;    Notify[event, @atom];    };  -- An extra ENTRY PROCEDURE...  ScanForItemEntry: PRIVATE ENTRY PROCEDURE [atom: Atom.ATOM]    RETURNS [ItemHandle] = {RETURN[ScanForItem[atom]]; };  -- Sets the procedure.  SetStrProc: PRIVATE ENTRY PROCEDURE [atom: Atom.ATOM, proc: FetchStringProc] = {    i: ItemHandle ¬ ScanForItem[atom];    IF i # NIL THEN      WITH it: i SELECT FROM string => {it.fetchProc ¬ proc}; ENDCASE;    };  -- Sets the string.  StuffString: PRIVATE ENTRY PROCEDURE [    atom: Atom.ATOM, string: LONG STRING, immutable: BOOLEAN ¬ FALSE] = {    i: ItemHandle ¬ ScanForItem[atom];    IF i # NIL THEN      WITH it: i SELECT FROM        string => {          IF it.clientCount = 0 AND ~it.immutable THEN -- rid the string --            zone.FREE[@it.val]          ELSE it.pleaseFree ¬ TRUE;          it.val ¬            IF immutable THEN string ELSE String.CopyToNewString[string, zone]};        ENDCASE;    };  -- Free and set.  SetStringEntry: PRIVATE ENTRY PROCEDURE [    atom: Atom.ATOM, string: LONG STRING, immutable: BOOLEAN ¬ FALSE,    old: BOOLEAN ¬ FALSE] = {    ENABLE UNWIND => NULL;    i: LONG POINTER TO string Item;    KillItems[atom];    i ¬ zone.NEW[      string Item ¬ [      next: thread, atom: atom, body: string[val:, immutable: immutable]]];    i.val ¬ IF immutable THEN string ELSE String.CopyToNewString[string, zone];    thread ¬ i;    RETURN};  --   GetString: PUBLIC ENTRY PROCEDURE [atom: Atom.ATOM] RETURNS [LONG STRING] = {    ENABLE UNWIND => NULL;    i: ItemHandle ¬ ScanForItem[atom];    str: LONG STRING ¬ NIL;    stat: ItemState ¬ valid;    immut: BOOLEAN ¬ FALSE;    IF i # NIL THEN      WITH it: i SELECT FROM        string => {          SELECT TRUE FROM            it.state = invalid AND it.fetchProc # NIL => {              -- Get my copy              [str, stat] ¬ it.fetchProc[atom];              -- Do the same as with SetStringEntry..What do I do with the old string value?              IF it.clientCount = 0 AND ~it.immutable THEN zone.FREE[@it.val];              it.state ¬ stat;              it.val ¬ String.CopyToNewString[str, zone];              RETURN[it.val]};            it.state = invalid AND it.fetchProc = NIL => ERROR GetError;            it.state = valid AND it.fetchProc # NIL => {              it.clientCount ¬ it.clientCount + 1; RETURN[it.val]};            it.state = valid AND it.fetchProc = NIL => {              it.clientCount ¬ it.clientCount + 1; RETURN[it.val]};            ENDCASE};        ENDCASE;    RETURN[NIL]};  DoneWithString: PUBLIC ENTRY PROCEDURE [string: LONG STRING] = {    ENABLE UNWIND => NULL;    FOR i: ItemHandle ¬ thread, i.next UNTIL i = NIL DO      WITH it: i SELECT FROM        string =>          BEGIN          IF string = it.val THEN            BEGIN            it.clientCount ¬ it.clientCount - 1;            IF it.clientCount = 0 AND it.pleaseFree THEN DeleteItem[i];            RETURN;            END;          END;        ENDCASE;      ENDLOOP;    RETURN};  EnumerateString: PUBLIC ENTRY PROCEDURE [    atom: Atom.ATOM, proc: PROCEDURE [LONG STRING]] = {    ENABLE UNWIND => NULL;    i: ItemHandle ¬ ScanForItem[atom];    IF i # NIL THEN WITH it: i SELECT FROM string => proc[it.val]; ENDCASE;    RETURN};  SetLONGINTEGER: PUBLIC PROCEDURE [    atom: Atom.ATOM, int: LONG INTEGER, initialState: ItemState ¬ valid,    fetchDemon: FetchIntegerProc ¬ NIL] = {    IF initialState = invalid AND fetchDemon = NIL THEN ERROR SetError;    SetLONGINTEGEREntry[atom, int, initialState, fetchDemon];    Notify[event, @atom];    RETURN};  SetLONGINTEGEREntry: PRIVATE ENTRY PROCEDURE [    atom: Atom.ATOM, int: LONG INTEGER, initialState: ItemState,    fetchDemon: FetchIntegerProc] = {    ENABLE UNWIND => NULL;    i: LONG POINTER TO int Item ¬ zone.NEW[int Item];    KillItems[atom];    i^ ¬ [      next: thread, atom: atom, state: initialState,      body: int[int: int, fetchProc: fetchDemon]];    thread ¬ i;    RETURN};  GetLONGINTEGER: PUBLIC ENTRY PROCEDURE [atom: Atom.ATOM]    RETURNS [LONG INTEGER] = {    ENABLE UNWIND => NULL;    i: ItemHandle ¬ ScanForItem[atom];    IF i # NIL THEN      WITH it: i SELECT FROM        int => {          SELECT TRUE FROM            -- Have invalid data, and can call a proc.            it.state = invalid AND it.fetchProc # NIL => {              -- Get my copy              [it.int, it.state] ¬ it.fetchProc[atom]; RETURN[it.int]};            -- Have invalid data, and cannot call a proc.            it.state = invalid AND it.fetchProc = NIL => ERROR GetError;            -- Have valid data, and can call a proc.            it.state = valid AND it.fetchProc # NIL => {RETURN[it.int]};            -- Have valid data, and cannot call a proc.            it.state = valid AND it.fetchProc = NIL => {RETURN[it.int]};            ENDCASE};        ENDCASE;    RETURN[0]};  SetBOOLEAN: PUBLIC PROCEDURE [    atom: Atom.ATOM, boolean: BOOLEAN, initialState: ItemState ¬ valid,    fetchDemon: FetchBooleanProc ¬ NIL] = {    IF initialState = invalid AND fetchDemon = NIL THEN ERROR SetError;    SetBOOLEANEntry[atom, boolean, initialState, fetchDemon];    Notify[event, @atom];    RETURN};  SetBOOLEANEntry: PRIVATE ENTRY PROCEDURE [    atom: Atom.ATOM, boolean: BOOLEAN, initialState: ItemState,    fetchDemon: FetchBooleanProc] = {    ENABLE UNWIND => NULL;    i: LONG POINTER TO boolean Item ¬ zone.NEW[boolean Item];    KillItems[atom];    i^ ¬ [      next: thread, atom: atom, state: initialState,      body: boolean[boolean: boolean, fetchProc: fetchDemon]];    thread ¬ i;    RETURN};  GetBOOLEAN: PUBLIC ENTRY PROCEDURE [atom: Atom.ATOM] RETURNS [BOOLEAN] = {    ENABLE UNWIND => NULL;    i: ItemHandle ¬ ScanForItem[atom];    IF i # NIL THEN      WITH it: i SELECT FROM        boolean => {          SELECT TRUE FROM            it.state = invalid AND it.fetchProc # NIL => {              -- Get my copy              [it.boolean, it.state] ¬ it.fetchProc[atom]; RETURN[it.boolean]};            -- Have invalid data, and cannot call a proc.            it.state = invalid AND it.fetchProc = NIL => ERROR GetError;            -- Have valid data, and can call a proc.            it.state = valid AND it.fetchProc # NIL => {RETURN[it.boolean]};            -- Have valid data, and cannot call a proc.            it.state = valid AND it.fetchProc = NIL => {RETURN[it.boolean]};            ENDCASE};        ENDCASE;    RETURN[FALSE]};  Notify: PROCEDURE [event: Supervisor.Event, eventData: LONG POINTER] = {    Supervisor.NotifyDirectSubsystems[      event, eventData, clients, Event.tajoDefaults];    };  END.    Change log14-Feb-85 12:29:50	DSC  	Ported to Tajo and added Demons to Item. (Use: FullUserName caches) 6-Mar-85 11:02:26	DSC  	Add demons to INT and BOOLS too. 2-Jul-85 16:31:03	DSC  	Fix bug in GetString to COPY new string rather than assign it.
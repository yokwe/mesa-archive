-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- File: DictionaryTool.mesa - last edit by:-- JGS on	19-Jan-83 15:47:39DIRECTORY  CmFile USING [FreeString, UserDotCmLine],  Dictionary,  Exec USING [AddCommand, ExecProc, RemoveCommand],  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, CommandItem,    ItemHandle, ModifyEditable, newLine, ProcType, StringItem],  Heap USING [systemZone],  MFile USING [maxNameLength],  MsgSW USING [Clear],  MStream USING [Error, ReadOnly, WriteOnly],  Put USING [Decimal, Text],  Selection USING [Convert],  Stream USING [Delete, Handle],  String USING [    AppendExtensionIfNeeded, AppendString, CopyToNewString, EquivalentString,    Length],  ToolWindow USING [Activate, Deactivate, GetState, MakeSize, TransitionProcType],  Tool USING [Create, Destroy, MakeSWsProc, MakeDefaultSWs],  UserTerminal USING [BlinkDisplay],  Window USING [Handle],  WindowFont USING [FontHeight];DictionaryTool: PROGRAM  IMPORTS    CmFile, Exec, FormSW, Dictionary, Heap, MsgSW, MStream, Put,    Selection, Stream, String, Tool, ToolWindow, UserTerminal, WindowFont  EXPORTS Dictionary = {  Handle: TYPE = Dictionary.Handle;  toolWindow: Window.Handle ¬ NIL;  data: Data ¬ NIL;  dictionary: LONG STRING ¬ NIL;  Data: TYPE = LONG POINTER TO DataObject;  DataObject: TYPE = RECORD [    formSW, msgSW, logSW: Window.Handle ¬ NIL,    key, def: LONG STRING ¬ NIL,    changed: BOOLEAN ¬ FALSE];  --  EXPORT to Dictionary  defaultDictionary: PUBLIC Handle ¬ NIL;  InvokeTool: PUBLIC PROC =    BEGIN    SELECT ToolWindow.GetState[toolWindow] FROM      inactive => ToolWindow.Activate[toolWindow];      tiny => ToolWindow.MakeSize[toolWindow, normal];      ENDCASE => {[] ¬ ToolWindow.Deactivate[toolWindow]; RETURN};    FormSW.ModifyEditable[      sw: data.formSW, index: FormIndex.def.ORD, position: 0,      length: String.Length[data.def], new: Selection.Convert[string]];    END;  FormIndex: TYPE = {record, lookup, list, load, store, dictionary, key, def};  --Record!  LookUp!  List!  Load!  Store!  Dictionary: Edit.dict  --Abbreviation:  --Expansion:  MakeForm: FormSW.ClientItemsProcType =    BEGIN OPEN FormSW;    array: LONG POINTER TO ARRAY FormIndex OF ItemHandle ¬      LOOPHOLE[BASE[items ¬ AllocateItemDescriptor[FormIndex.LAST.ORD.SUCC]]];    array­ ¬ [      record: CommandItem[tag: "Record"L, place: newLine, proc: CommandProc],      lookup: CommandItem[tag: "LookUp"L, proc: CommandProc],      list: CommandItem[tag: "List"L, proc: CommandProc],      load: CommandItem[tag: "Load"L, proc: CommandProc],      store: CommandItem[tag: "Store"L, proc: CommandProc],      dictionary: StringItem[        tag: "Dictionary"L, string: @dictionary, inHeap: FALSE],      key: StringItem[        tag: "Abbreviation"L, place: newLine, string: @data.key, inHeap: TRUE],      def: StringItem[        tag: "Expansion"L, place: newLine, string: @data.def, inHeap: TRUE]];    RETURN[items, TRUE]    END;  CommandProc: FormSW.ProcType = {    OPEN data;    ENABLE Dictionary.Error => {Post[type]; GOTO Blink};    Report: PROC [n: CARDINAL, msg: STRING] = {      IF n = 0 THEN Put.Text[logSW, "No"L] ELSE Put.Decimal[logSW, n];      Put.Text[logSW, " pair"L];      IF n # 1 THEN Put.Text[logSW, "s"L];      Put.Text[logSW, msg]};    MsgSW.Clear[msgSW];    SELECT index FROM      FormIndex.load.ORD => {	nInitial, nFinal: CARDINAL ¬ 0;        CountInitial: PROC [key, def: LONG STRING] RETURNS [BOOLEAN] = {	  nInitial ¬ nInitial + 1; RETURN[FALSE]};        CountFinal: PROC [key, def: LONG STRING] RETURNS [BOOLEAN] = {	  nFinal ¬ nFinal + 1; RETURN[FALSE]};        h: Dictionary.Handle = defaultDictionary;	IF String.Length[dictionary] = 0 THEN	  Put.Text[msgSW, "No dictionary specified"L]	ELSE {	  stream: Stream.Handle = GetDictionaryStream[load];	  IF stream # NIL THEN {	    h.Enumerate[CountInitial];	    h.Load[stream ! UNWIND => stream.Delete[]];	    stream.Delete[];	    h.Enumerate[CountFinal];	    IF nFinal # nInitial THEN data.changed ¬ TRUE;	    Report[nFinal - nInitial, " added to dictionary\n"L]}}};      FormIndex.store.ORD => {        h: Dictionary.Handle = defaultDictionary;	nFinal: CARDINAL ¬ 0;        CountFinal: PROC [key, def: LONG STRING] RETURNS [BOOLEAN] = {	  nFinal ¬ nFinal + 1; RETURN[FALSE]};	IF String.Length[dictionary] = 0 THEN	  Put.Text[msgSW, "No dictionary specified"L]	ELSE {	  stream: Stream.Handle = GetDictionaryStream[store];	  IF stream # NIL THEN {	    h.Store[stream ! UNWIND => stream.Delete[]];	    stream.Delete[];	    h.Enumerate[CountFinal];	    data.changed ¬ FALSE;	    Report[nFinal, " stored\n"L]}}};      FormIndex.record.ORD => {        h: Dictionary.Handle = defaultDictionary;	h.Define[key: key, def: def];	data.changed ¬ TRUE;	Put.Text[h: logSW, s: key];	Put.Text[h: logSW, s: ":\t"""L];	Put.Text[h: logSW, s: def];	Put.Text[h: logSW, s: """\n"L]};      FormIndex.lookup.ORD => {        h: Dictionary.Handle = defaultDictionary;	def: LONG STRING = h.LookUp[key: key];	FormSW.ModifyEditable[          sw: formSW, index: FormIndex.def.ORD, position: 0,          length: String.Length[def],	  new: String.CopyToNewString[def, Heap.systemZone]]};      FormIndex.list.ORD => {        h: Dictionary.Handle = defaultDictionary;	nEntries: CARDINAL ¬ 0;	ListOne: PROC [key, def: LONG STRING] RETURNS [BOOLEAN] = {	  Put.Text[h: logSW, s: key];	  Put.Text[h: logSW, s: ":\t"""L];	  Put.Text[h: logSW, s: def];	  Put.Text[h: logSW, s: """\n"L];	  nEntries ¬ nEntries + 1;	  RETURN[FALSE]};	h.Enumerate[ListOne];	Report[nEntries, " in dictionary\n"L]};      ENDCASE;    RETURN;    EXITS Blink => UserTerminal.BlinkDisplay[]};  GetDictionaryStream: PROC [    access: {load, store}] RETURNS [stream: Stream.Handle] = {    OPEN data;    dict: LONG STRING = dictionary;    IF String.Length[dict] = 0 THEN RETURN[NIL]    ELSE {      FOR i: CARDINAL DECREASING IN [0..dict.length) DO        IF dict[i] = '. THEN EXIT;        REPEAT        FINISHED  =>          FormSW.ModifyEditable[            sw: formSW, index: FormIndex.dictionary.ORD, length: 0,	    position: dict.length, new: ".dict"L]; -- may change dictionary        ENDLOOP;    {ENABLE MStream.Error => {        Put.Text[msgSW, "Problems acquiring file "L];        Put.Text[msgSW, dictionary];        CONTINUE};    stream ¬ NIL;    IF access = load THEN stream ¬ MStream.ReadOnly[dictionary, []]    ELSE stream ¬ MStream.WriteOnly[dictionary, [], text]};    RETURN[stream]}};  Post: PROC [type: Dictionary.ErrorType] = {    sw: Window.Handle = IF data = NIL THEN NIL ELSE data.msgSW;    Put.Text[sw, "\n!Warning: "L];    Put.Text[      sw,      SELECT type FROM        dictionaryFull => "dictionaryFull"L,        fileFormatProblem => "fileFormatProblem"L,        fileNameProblem => "fileNameProblem"L,        invalidParameters => "invalidParameters"L,        keyTooLong => "keyTooLong"L,        notFound => "notFound"L,        ENDCASE => "UNKNOWN!"L]};  DoTransition: ToolWindow.TransitionProcType = {    SELECT TRUE FROM      old = inactive =>        IF data = NIL THEN {          data ¬ Heap.systemZone.NEW[DataObject ¬ []];	  FindDefaultDictionary[]};      new = inactive => {        IF data.changed THEN {	  autoStore: LONG STRING ¬	    CmFile.UserDotCmLine["DictionaryTool"L, "StoreOnDeactivate"L];	  IF autoStore # NIL THEN {	    IF String.EquivalentString[autoStore, "TRUE"L] THEN {	      stream: Stream.Handle = GetDictionaryStream[store];	      IF stream # NIL THEN {	        defaultDictionary.Store[stream !	          UNWIND => stream.Delete[]; Dictionary.Error => CONTINUE];	        stream.Delete[]};	    [] ¬ CmFile.FreeString[autoStore]}}};	IF dictionary # NIL THEN Heap.systemZone.FREE[@dictionary];	IF data # NIL THEN Heap.systemZone.FREE[@data]};      ENDCASE};  MakeSWs: Tool.MakeSWsProc = {    [msgSW: data.msgSW, formSW: data.formSW, logSW: data.logSW] ¬      Tool.MakeDefaultSWs[window: window, messageLines: 1, formProc: MakeForm,        formHeight: 4*WindowFont.FontHeight[], logName: "DictionaryTool.log"L]};  ExecProc: Exec.ExecProc = {ToolWindow.Activate[toolWindow]};  Die: Exec.ExecProc = {    IF toolWindow # NIL THEN Tool.Destroy[toolWindow];    [] ¬ Exec.RemoveCommand[h, "DictionaryTool.~"L]};  FindDefaultDictionary: PROC = {    s: LONG STRING;    IF dictionary # NIL THEN RETURN;    s ¬ CmFile.UserDotCmLine["DictionaryTool"L, "Dictionary"L];    dictionary ¬ Heap.systemZone.NEW[StringBody[MFile.maxNameLength]];    String.AppendString[      to: dictionary, from: IF s = NIL THEN "Default.dict"L ELSE s];    IF s # NIL THEN [] ¬ CmFile.FreeString[s];    [] ¬ String.AppendExtensionIfNeeded[      to: @dictionary, extension: ".dict"L, z: Heap.systemZone]};  Init: PROC = {    toolWindow ¬ Tool.Create[      makeSWsProc: MakeSWs, name: "Dictionary Tool"L,      clientTransition: DoTransition, cmSection: "DictionaryTool"L];    Exec.AddCommand[name: "DictionaryTool.~"L, proc: ExecProc, unload: Die];    FindDefaultDictionary[];    defaultDictionary ¬      Dictionary.Open[dictionary ! Dictionary.Error => {Post[type]; CONTINUE}]};  --  Mainline code  Init[];  }.  -- of DictionaryTool
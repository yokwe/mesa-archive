-- Copyright (C) 1981, 1982  by Xerox Corporation. All rights reserved. -- File: StringLookUpsA.mesa - last edit:-- AXD     on : 22-Sep-82 11:28:03 -- SXW    on : 12-Jul-81 14:54:43 -- 22-May-81 18:34:04 by Mark-- Routines to perform STRING lookup in a table or a generated set.DIRECTORY  Heap: TYPE USING [systemZone],  String USING [EmptyString, Length, UpperCase],  StringLookUp USING [ambiguous, emptyKey, GeneratorProcType, noMatch, TableDesc];StringLookUpsA: PROGRAM IMPORTS Heap, String EXPORTS StringLookUp =  BEGIN  InTable: PUBLIC PROCEDURE [    key: LONG STRING, table: StringLookUp.TableDesc, caseFold: BOOLEAN ¬ TRUE,    noAbbreviation: BOOLEAN ¬ FALSE] RETURNS [index: CARDINAL] =    -- If table has duplicate entries, only the first one's index might be returned    BEGIN    keyLength: CARDINAL;    IF String.EmptyString[key] THEN {index ¬ StringLookUp.emptyKey; GOTO Return};    index ¬ StringLookUp.noMatch;    keyLength ¬ key.length;    FOR i: CARDINAL IN [0..LENGTH[table]) DO      entry: LONG STRING = table[i];      lengthsAreSame: BOOLEAN;      SELECT String.Length[entry] FROM        < keyLength => LOOP;  -- empty entry takes this arm --        keyLength => lengthsAreSame ¬ TRUE;        ENDCASE => IF noAbbreviation THEN LOOP ELSE lengthsAreSame ¬ FALSE;      BEGIN      SELECT InitialInternal[key, entry, keyLength, caseFold] FROM        < keyLength => NULL;        keyLength =>          BEGIN          IF lengthsAreSame THEN {index ¬ i; EXIT};          index ¬            (IF index = StringLookUp.noMatch THEN i ELSE StringLookUp.ambiguous);          END;        ENDCASE;      END;      ENDLOOP;    EXITS Return => NULL;    END;  UsingGenerator: PUBLIC PROCEDURE [    key: LONG STRING, generator: StringLookUp.GeneratorProcType,    caseFold: BOOLEAN ¬ TRUE, noAbbreviation: BOOLEAN ¬ FALSE,    bufferBytes: CARDINAL ¬ 500] RETURNS [index: CARDINAL] =    BEGIN    buffer: LONG STRING ¬ Heap.systemZone.NEW[StringBody [bufferBytes]];    index ¬ UsingGeneratorWithBuffer[      key, generator, caseFold, noAbbreviation, buffer !      UNWIND => Heap.systemZone.FREE[@buffer]];    Heap.systemZone.FREE[@buffer];    END;  UsingGeneratorWithBuffer: PUBLIC PROCEDURE [    key: LONG STRING, generator: StringLookUp.GeneratorProcType,    caseFold: BOOLEAN ¬ TRUE, noAbbreviation: BOOLEAN ¬ FALSE,    buffer: LONG STRING] RETURNS [index: CARDINAL] =    -- Input restrictions: buffer # NIL    BEGIN    keyLength: CARDINAL;    IF String.EmptyString[key] THEN {index ¬ StringLookUp.emptyKey; GOTO Return};    index ¬ StringLookUp.noMatch;    keyLength ¬ key.length;    FOR i: CARDINAL ¬ 0, i + 1 DO      lengthsAreSame: BOOLEAN;      buffer.length ¬ 0;      generator[buffer];      SELECT String.Length[buffer] FROM        0 => GOTO Return;        < keyLength => LOOP;        keyLength => lengthsAreSame ¬ TRUE;        ENDCASE => IF noAbbreviation THEN LOOP ELSE lengthsAreSame ¬ FALSE;      BEGIN      SELECT InitialInternal[key, buffer, keyLength, caseFold] FROM        < keyLength => NULL;        keyLength =>          BEGIN          IF lengthsAreSame THEN {index ¬ i; EXIT};          index ¬            (IF index = StringLookUp.noMatch THEN i ELSE StringLookUp.ambiguous);          END;        ENDCASE;      END;      ENDLOOP;    EXITS Return => NULL;    END;  Initial: PUBLIC PROCEDURE [key, entry: LONG STRING, caseFold: BOOLEAN ¬ TRUE]    RETURNS [matchLength: CARDINAL] =    BEGIN    maxLength: CARDINAL =      (IF key = NIL OR entry = NIL THEN 0 ELSE MIN[key.length, entry.length]);    matchLength ¬      IF maxLength = 0 THEN 0      ELSE InitialInternal[key, entry, maxLength, caseFold];    END;  InitialInternal: PUBLIC PROCEDURE [    key, entry: LONG STRING, maxLength: CARDINAL, caseFold: BOOLEAN ¬ TRUE]    RETURNS [matchLength: CARDINAL] =    -- Input restrictions: key # NIL AND entry # NIL AND maxLength > 0    --   AND key.length >= maxLength AND entry.length >= maxLength    BEGIN    matchLength ¬ 0;    IF caseFold THEN      DO        IF String.UpperCase[key[matchLength]] # String.UpperCase[          entry[matchLength]] THEN EXIT;        IF (matchLength ¬ matchLength + 1) = maxLength THEN EXIT;        ENDLOOP    ELSE      DO        IF key[matchLength] # entry[matchLength] THEN EXIT;        IF (matchLength ¬ matchLength + 1) = maxLength THEN EXIT;        ENDLOOP;    END;  IsPrefix: PUBLIC PROCEDURE [    maybePrefix, string: LONG STRING, caseFold: BOOLEAN ¬ TRUE]    RETURNS [yes: BOOLEAN] =    BEGIN    matchLength: CARDINAL = Initial[maybePrefix, string, caseFold];    yes ¬ (matchLength = String.Length[maybePrefix]);    END;  END.
-- Copyright (C) 1981, 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- File: FileInterface.mesa  last edit on:-- BJD    	18-Jun-84 14:55:13-- BXM   	15-Oct-81 21:20:01-- PXK    	22-Oct-82 18:55:26-- LXR     	21-Oct-82 15:58:00-- Mark 	4-Jun-81 16:52:02-- JGS  	2-Sep-81 10:37:23-- RXR     	 4-Oct-82  9:44:29-- RXJ     	19-Dec-83 13:23:52-- CXH   	24-Feb-83 14:48:16-- JCS   	12-Jun-85 16:45:23DIRECTORY  Auth USING [IdentityHandle],  Ascii USING [SP],  CmFile USING [Close, Error, FindSection, Handle, NextItem, UserDotCmOpen],  Display USING [Bitmap, Handle, Invert, White],  Event USING [aboutToSwap, primaryCredentials],  EventTypes USING [    aboutToAbortSession, aboutToBoot, aboutToBootPhysicalVolume,    aboutToResume, primaryCredentials],  ExecUtilities USING [filetoolWindow],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType, CommandItem,    Display, Enumerated, EnumeratedItem, FilterProcType, FindItem, ItemHandle,    LineHeight, MenuProcType, newLine, ProcType, sameLine,    SetTagPlaces, StringEditProc, StringItem],  FileToolOps USING [    Cmd, CmdObject, FTPCommand, GiveCommand, ListOptions, ListOptionsArray],  FileTransfer USING [    CheckAbortProc, ClientProc, Close, Confirmation, Create, DesiredProperties, Destroy,    Error, FileInfo, MessageProc, SetDefaultServerType,    SetPrimaryCredentials, SetDesiredProperties, SetProcs, ValidProperties, VetoProc],  Heap USING [systemZone],  HeraldWindow USING [AppendMessage],  Profile USING [defaultFileServerProtocol, FileServerProtocol, GetID, GetUser],  Process USING [Abort, Detach],  Put USING [CR, Line, LongString],  Runtime USING [GetBcdTime],  String USING [    AppendString, AppendSubString, CopyToNewString, SubString, SubStringDescriptor],  StringLookUp USING [InTable, noMatch],  Supervisor USING [    AddDependency, AgentProcedure, CreateSubsystem, EnumerationAborted,    SubsystemHandle],  System USING [SecondsSinceEpoch],  Time USING [Append, Packed, Unpack],  Token USING [FreeTokenString],  Tool USING [    Create, Destroy, MakeFileSW, MakeFormSW, MakeMsgSW, MakeSWsProc, UnusedLogName],  ToolDriver USING [Address, NoteSWs, RemoveSWs],  ToolWindow USING [DisplayProcType, GetState, TransitionProcType],  UserInput USING [AttentionProcType, CreatePeriodicNotify, PeriodicProcType, SetAttention],  Version USING [Append],  Window USING [    Box, Dims, GetBox, GetDisplayProc, GetParent, Handle, rootWindow, SetDisplayProc],  WindowFont USING [CharWidth, FontHeight];FileInterface: MONITOR  IMPORTS    CmFile, Display, Event, ExecUtilities, FormSW, FileToolOps, FileTransfer, Heap,     HeraldWindow, Runtime, Process, Profile, Put, String, StringLookUp, Supervisor,    System, Time, Token, Tool, ToolDriver, ToolWindow, UserInput,    Version, Window, WindowFont  EXPORTS FileToolOps =  BEGIN  -- public and global data  -- everything is in global frame since a bound config always  -- has at least 1 page global frame    z: UNCOUNTED ZONE = Heap.systemZone;  FilterType: TYPE = {verify, time, none};  Indicator: TYPE = {off, left, right};  Functions: TYPE = {commands, confirms, empty};  ToolState: TYPE = {active, tiny, inactive};  waiting: FileTransfer.Confirmation = firstPrivate;  Data: TYPE = POINTER TO DataObject;  DataObject: TYPE = RECORD [    paramSW, commandSW, msgSW, log: Window.Handle ¬ NIL,    function, newFunction: Functions ¬ commands,    indicator: Indicator ¬ off,    cmd: FileToolOps.CmdObject ¬ [],    process: PROCESS ¬ NIL,    aborted: BOOLEAN ¬ FALSE,    confirmState: FileTransfer.Confirmation ¬ waiting,    toolState: ToolState ¬ inactive,    newOptions: FileToolOps.ListOptionsArray ¬ ALL[FALSE]];  timeLess, timeEqual, timeGreater, always, verify: BOOLEAN ¬ FALSE;  quoted: BOOLEAN ¬ TRUE;  protocol: Profile.FileServerProtocol ¬    Profile.defaultFileServerProtocol;  protocolChoices: ARRAY [0..2) OF FormSW.Enumerated ¬ [    ["NS", Profile.FileServerProtocol[ns]],    ["Pup", Profile.FileServerProtocol[pup]]];  toolWindow: Window.Handle ¬ NIL;  optionWindow: Window.Handle ¬ NIL;  formDisplay: ToolWindow.DisplayProcType ¬ NIL;  data: DataObject ¬ [];  bcdTime: Time.Packed = Runtime.GetBcdTime[];  indicatorBox: Window.Box = [[10, 10], [16, 16]];  busy: BOOLEAN ¬ FALSE;  finished, haveConfirm: CONDITION;  agent: Supervisor.SubsystemHandle = Supervisor.CreateSubsystem[UpdateDefaults];      TimeFilter: ENTRY FileTransfer.VetoProc =    BEGIN    ENABLE UNWIND => NULL;    tFilter: BOOLEAN = timeLess OR timeEqual OR timeGreater;    source, target: FileTransfer.FileInfo;    sourceCreateAdjusted, targetCreateAdjusted: LONG CARDINAL;    c: FileTransfer.Confirmation ¬ do;    IF data.aborted OR (data.toolState = inactive) THEN      RETURN[abort, tFilter];    IF tFilter THEN {      [source, target] ¬ info[conn];      sourceCreateAdjusted ¬ System.SecondsSinceEpoch[source.create];      targetCreateAdjusted ¬ System.SecondsSinceEpoch[target.create];      IF ~target.oldFile OR target.readProtect THEN        c ¬ (IF always THEN do ELSE skip)      ELSE        c ¬          SELECT TRUE FROM            sourceCreateAdjusted < targetCreateAdjusted =>              IF timeLess THEN do ELSE skip,            sourceCreateAdjusted = targetCreateAdjusted =>              IF timeEqual THEN do ELSE skip,            sourceCreateAdjusted > targetCreateAdjusted =>              IF timeGreater THEN do ELSE skip,            ENDCASE => do};    IF c = do AND verify THEN      c ¬ IF data.toolState = tiny THEN abort ELSE GetConfirm[];    RETURN[c, tFilter];    END;  VerifyFilter: ENTRY FileTransfer.VetoProc =    BEGIN    ENABLE UNWIND => NULL;    c: FileTransfer.Confirmation =      SELECT TRUE FROM        data.aborted => abort,        data.toolState # active => abort,        verify => GetConfirm[],        ENDCASE => do;    RETURN[c, showingDates]    END;  GetConfirm: INTERNAL PROCEDURE RETURNS [c: FileTransfer.Confirmation] =    BEGIN    ENABLE UNWIND => NULL;    ChangeCommandSubwindow[confirms];    WHILE data.confirmState = waiting AND data.toolState = active DO      WAIT haveConfirm ENDLOOP;    c ¬ data.confirmState;    data.confirmState ¬ waiting;    IF data.toolState # active THEN c ¬ abort;    END;  -- parameter indices  ncommands: CARDINAL = stopIndex + 1;  Commands: TYPE = [retIndex..remDelIndex];  Confirms: TYPE = [confirmIndex..stopIndex];  retIndex: CARDINAL = 0;  locListIndex: CARDINAL = retIndex + 1;  copyIndex: CARDINAL = locListIndex + 1;  locDelIndex: CARDINAL = copyIndex + 1;  listOptIndex: CARDINAL = locDelIndex + 1;  storeIndex: CARDINAL = listOptIndex + 1;  remListIndex: CARDINAL = storeIndex + 1;  closeIndex: CARDINAL = remListIndex + 1;  remDelIndex: CARDINAL = closeIndex + 1;  confirmIndex: CARDINAL = LAST[Commands] + 1;  denyIndex: CARDINAL = confirmIndex + 1;  stopIndex: CARDINAL = denyIndex + 1;  hostIndex: CARDINAL = 0;  directoryIndex: CARDINAL = hostIndex + 1;  sourceIndex: CARDINAL = directoryIndex + 1;  destIndex: CARDINAL = sourceIndex + 1;  localDirIndex: CARDINAL = destIndex + 1;  timeLessIndex: CARDINAL = localDirIndex + 1;  timeEqualIndex: CARDINAL = timeLessIndex + 1;  timeGreaterIndex: CARDINAL = timeEqualIndex + 1;  protocolIndex: CARDINAL = timeGreaterIndex + 1;  connIndex: CARDINAL = protocolIndex + 1;  connPwdIndex: CARDINAL = connIndex + 1;  alwaysIndex: CARDINAL = connPwdIndex + 1;  verifyIndex: CARDINAL = alwaysIndex + 1;  quoteIndex: CARDINAL = verifyIndex + 1;  nparams: CARDINAL = quoteIndex + 1; -- this must be last...  -- Parameter support procedures  DoFunction: FormSW.ProcType =    BEGIN    SELECT index FROM      locListIndex => Command[localList, none];      locDelIndex => Command[localDelete, verify];      storeIndex => Command[store, time];      copyIndex => Command[copy, time];      remListIndex => Command[remoteList, none];      remDelIndex => Command[remoteDelete, verify];      retIndex => Command[retrieve, time];      closeIndex => Command[close, verify];      confirmIndex => Confirm[do];      denyIndex => Confirm[skip];      stopIndex => Confirm[abort];      ENDCASE;    END;  ShowOptions: FormSW.ProcType =    BEGIN OPEN WindowFont;    box: Window.Box = Window.GetBox[toolWindow];    IF optionWindow = NIL THEN      optionWindow ¬ Tool.Create[        name: "List Options"L, makeSWsProc: OptionSW, initialState: active,        initialBox: [        [box.place.x + 30, box.place.y + 100], [        45*CharWidth['0], 5*FontHeight[]]]]    ELSE MonitoredPostComment[NIL, terse, "Option window already exists."L];    END;  DoOptions: FormSW.ProcType = {    IF index = 3 THEN data.cmd.options ¬ data.newOptions;    Tool.Destroy[optionWindow];    optionWindow ¬ NIL};  OptionSW: Tool.MakeSWsProc = {    [] ¬ Tool.MakeFormSW[window: window, formProc: MakeOptions]};  -- setup and take down routines  MakeOptions: FormSW.ClientItemsProcType =    BEGIN OPEN FormSW;    noptions: CARDINAL = 8;    tabs: ARRAY [0..4) OF CARDINAL ¬ [0, 10, 20, 30];    items ¬ AllocateItemDescriptor[noptions];    items[0] ¬ BooleanItem[      tag: "Type"L, switch: @data.newOptions[type], place: newLine];    items[1] ¬ BooleanItem[tag: "Bytes"L, switch: @data.newOptions[bytes]];    items[2] ¬ BooleanItem[tag: "Author"L, switch: @data.newOptions[author]];    items[3] ¬ CommandItem[tag: "Apply"L, proc: DoOptions];    items[4] ¬ BooleanItem[      tag: "Create"L, switch: @data.newOptions[create], place: newLine];    items[5] ¬ BooleanItem[tag: "Write"L, switch: @data.newOptions[write]];    items[6] ¬ BooleanItem[tag: "Read"L, switch: @data.newOptions[read]];    items[7] ¬ CommandItem[tag: "Abort"L, proc: DoOptions];    SetTagPlaces[items, DESCRIPTOR[tabs], FALSE];    data.newOptions ¬ data.cmd.options;    RETURN[items, TRUE]    END;  MakeParams: FormSW.ClientItemsProcType =    BEGIN OPEN FormSW;    tabs: ARRAY [0..7) OF CARDINAL ¬ [0, 28, 52, 56, 60, 68, 75];    items ¬ AllocateItemDescriptor[nparams];    items[hostIndex] ¬ StringItem[      tag: "Host"L, string: @data.cmd.host, inHeap: TRUE, place: newLine];    items[directoryIndex] ¬ StringItem[      tag: "Directory"L, string: @data.cmd.directory, inHeap: TRUE];    items[sourceIndex] ¬ StringItem[      tag: "Source"L, string: @data.cmd.sourceName, inHeap: TRUE, place: newLine];    items[destIndex] ¬ StringItem[      tag: "Dest'n"L, string: @data.cmd.destName, inHeap: TRUE, place: newLine];    items[localDirIndex] ¬ StringItem[      tag: "LocalDir"L, string: @data.cmd.localdir, inHeap: TRUE];    items[timeLessIndex] ¬ BooleanItem[tag: " < "L, switch: @timeLess];    items[timeEqualIndex] ¬ BooleanItem[tag: " = "L, switch: @timeEqual];    items[timeGreaterIndex] ¬ BooleanItem[tag: " > "L, switch: @timeGreater];    items[protocolIndex] ¬ EnumeratedItem[      invisible: SetProtocol[],      feedback: all, tag: " "L, value: @protocol,      choices: DESCRIPTOR[protocolChoices], copyChoices: FALSE];    items[connIndex] ¬ StringItem[      tag: "Connect"L, string: @data.cmd.connectName, inHeap: TRUE,      place: newLine];    items[connPwdIndex] ¬ StringItem[      tag: "Password"L, string: @data.cmd.connectPassword, inHeap: TRUE,      feedback: password];    items[alwaysIndex] ¬ BooleanItem[tag: "Always"L, switch: @always];    items[verifyIndex] ¬ BooleanItem[      tag: "Verify"L, switch: @verify,      place: [x: verifyIndex - connIndex + 1, y: sameLine]];    items[quoteIndex] ¬ BooleanItem[      tag: "'*"L, switch: @quoted,      place: [x: quoteIndex - connIndex + 1, y: sameLine]];    SetTagPlaces[items, DESCRIPTOR[tabs], FALSE];    RETURN[items, TRUE]    END;  SetProtocol: PROC RETURNS [makeInvisible: BOOLEAN ¬ FALSE] =    BEGIN    nsLoaded, pupLoaded: BOOLEAN ¬ TRUE;    Other: PROC [p: Profile.FileServerProtocol] RETURNS [Profile.FileServerProtocol] = {      RETURN [IF p=ns THEN pup ELSE ns]};    FileTransfer.SetDefaultServerType[NIL, ns !       FileTransfer.Error => {nsLoaded ¬ FALSE; CONTINUE}];    FileTransfer.SetDefaultServerType[NIL, ifs !       FileTransfer.Error => {pupLoaded ¬ FALSE; CONTINUE}];    IF pupLoaded AND nsLoaded THEN RETURN[FALSE];    IF ~pupLoaded AND ~nsLoaded THEN RETURN[TRUE];    IF (Profile.defaultFileServerProtocol = ns AND pupLoaded) OR      (Profile.defaultFileServerProtocol = pup AND nsLoaded) THEN       protocol ¬ Other[protocol];    RETURN[TRUE]    END;    MakeCommands: FormSW.ClientItemsProcType =    BEGIN OPEN FormSW;    tabs: ARRAY [0..5) OF CARDINAL ¬ [0, 13, 29, 39, 58];    items ¬ AllocateItemDescriptor[ncommands];    items[retIndex] ¬ CommandItem[      tag: "Retrieve"L, proc: DoFunction, place: newLine];    items[locListIndex] ¬ CommandItem[tag: "Local-List"L, proc: DoFunction];    items[copyIndex] ¬ CommandItem[tag: "Copy"L, proc: DoFunction];    items[locDelIndex] ¬ CommandItem[tag: "Local-Delete"L, proc: DoFunction];    items[listOptIndex] ¬ CommandItem[tag: "List-Options"L, proc: ShowOptions];    items[storeIndex] ¬ CommandItem[      tag: "Store"L, proc: DoFunction, place: newLine];    items[remListIndex] ¬ CommandItem[tag: "Remote-List"L, proc: DoFunction];    items[closeIndex] ¬ CommandItem[tag: "Close"L, proc: DoFunction];    items[remDelIndex] ¬ CommandItem[tag: "Remote-Delete"L, proc: DoFunction];    items[confirmIndex] ¬ CommandItem[      tag: "Confirm"L, proc: DoFunction, place: [0, LineHeight[]/2]];    items[denyIndex] ¬ CommandItem[tag: "Deny"L, proc: DoFunction];    items[stopIndex] ¬ CommandItem[tag: "Stop"L, proc: DoFunction];    SetTagPlaces[items, DESCRIPTOR[tabs], FALSE];    FOR i: CARDINAL IN Confirms DO items[i].flags.invisible ¬ TRUE ENDLOOP;    RETURN[items, TRUE]    END;  -- Display routines  MonitoredPostComment: ENTRY FileTransfer.MessageProc =    BEGIN    ENABLE UNWIND => NULL;    PostComment[clientData, level, s1, s2, s3, s4];    END;  PostComment: FileTransfer.MessageProc =    BEGIN    IF data.toolState = inactive THEN RETURN;    IF level > terse THEN Post[data.msgSW, s1, s2, s3, s4];    Post[data.log, s1, s2, s3, s4];    END;  Post: PROCEDURE [w: Window.Handle, s1, s2, s3, s4: LONG STRING] =    BEGIN    IF s1 # NIL THEN Put.LongString[w, s1];    IF s2 # NIL THEN Put.LongString[w, s2];    IF s3 # NIL THEN Put.LongString[w, s3];    IF s4 # NIL THEN Put.LongString[w, s4];    END;  CheckForAbort: FileTransfer.CheckAbortProc = {    RETURN[data.aborted]};  DisplayEmpty: ENTRY ToolWindow.DisplayProcType = {    ENABLE UNWIND => NULL;    IF data.toolState = inactive THEN RETURN;    Display.White[window, [[0,0], window.GetBox[].dims]];    DisplayIndicator[window]};  DisplayIndicator: INTERNAL ToolWindow.DisplayProcType = {    pattern: ARRAY [0..1] OF ARRAY [0..8) OF WORD;    left: WORD = 177400B;    right: WORD = 000377B;    SELECT data.indicator FROM      left => {        pattern ¬ [ALL[left], ALL[right]];        Display.Bitmap[	  window: window, box: indicatorBox, address: [word: @pattern, bit: 0],	  bitmapBitWidth: 16]};      right => {        pattern ¬ [ALL[right], ALL[left]];        Display.Bitmap[	  window: window, box: indicatorBox, address: [word: @pattern, bit: 0],	  bitmapBitWidth: 16]};      ENDCASE};  InvertIndicator: ENTRY FileTransfer.ClientProc =    BEGIN    ENABLE UNWIND => NULL;    IF data.toolState # active THEN RETURN;    SELECT data.indicator FROM      left => data.indicator ¬ right;      off, right => data.indicator ¬ left;      ENDCASE;    Display.Invert[data.commandSW, indicatorBox];    END;  PostCommands: ENTRY PROCEDURE = {    ENABLE UNWIND => NULL; IF ~busy THEN ChangeCommandSubwindow[commands]};  ChangeCommandSubwindow: INTERNAL PROCEDURE [function: Functions] =    BEGIN    data.newFunction ¬ function;    [] ¬ UserInput.CreatePeriodicNotify[ChangeSW, data.commandSW, 0];    END;  ChangeSW: ENTRY UserInput.PeriodicProcType =    BEGIN OPEN FormSW;    ENABLE UNWIND => NULL;    IF data.toolState # active THEN RETURN;    IF data.newFunction # data.function THEN      BEGIN      i: CARDINAL;      IF data.function = empty THEN         [] ¬ Window.SetDisplayProc[data.commandSW, formDisplay];      SELECT data.newFunction FROM        commands =>          BEGIN          FOR i IN Commands DO            FindItem[data.commandSW, i].flags.invisible ¬ FALSE ENDLOOP;          FOR i IN Confirms DO            FindItem[data.commandSW, i].flags.invisible ¬ TRUE ENDLOOP;          END;        confirms =>          BEGIN          FOR i IN Commands DO            FindItem[data.commandSW, i].flags.invisible ¬ TRUE ENDLOOP;          FOR i IN Confirms DO            FindItem[data.commandSW, i].flags.invisible ¬ FALSE ENDLOOP;          END;        ENDCASE;      data.function ¬ data.newFunction;      data.indicator ¬ off;      FormSW.Display[data.commandSW];      END;    END;  ClearCommandSubwindow: INTERNAL PROCEDURE =    BEGIN    item: FormSW.ItemHandle;    FOR i: CARDINAL ¬ 0, i + 1 UNTIL (item ¬ FormSW.FindItem[data.commandSW, i]) =      NIL DO item.flags.invisible ¬ TRUE ENDLOOP;    FormSW.Display[data.commandSW];    data.indicator ¬ left;    data.function ¬ empty;    formDisplay ¬ Window.GetDisplayProc[data.commandSW];    [] ¬ Window.SetDisplayProc[data.commandSW, DisplayEmpty];    DisplayIndicator[data.commandSW];    END;  SetVeto: PROC [type: FilterType] = {    SELECT type FROM      time => {        data.cmd.veto ¬ TimeFilter;        data.cmd.showDates ¬ timeLess OR timeEqual OR timeGreater};      verify => {data.cmd.veto ¬ VerifyFilter; data.cmd.showDates ¬ FALSE};      none => {data.cmd.veto ¬ NIL; data.cmd.showDates ¬ FALSE};      ENDCASE};  CopyCmd: PROC [from: FileToolOps.Cmd]    RETURNS [to: FileToolOps.Cmd, ok: BOOLEAN ¬ TRUE] = {    to ¬ z.NEW[FileToolOps.CmdObject];    to.host ¬ String.CopyToNewString[from.host, z];    to.directory ¬ String.CopyToNewString[from.directory, z];    to.localdir ¬ String.CopyToNewString[from.localdir, z];    to.sourceName ¬ String.CopyToNewString[from.sourceName, z];    to.destName ¬ String.CopyToNewString[from.destName, z];    to.connectName ¬ String.CopyToNewString[from.connectName, z];    to.connectPassword ¬ String.CopyToNewString[from.connectPassword, z];    to.connection ¬ from.connection;    to.veto ¬ from.veto;    to.showDates ¬ from.showDates;    to.quoted ¬ quoted;    to.options ¬ from.options;    SetOptions[from];      FileTransfer.SetDefaultServerType[  -- raises skipOperation if code ~loaded      to.connection, IF protocol = ns THEN ns ELSE ifs !      FileTransfer.Error => IF code=skipOperation THEN CONTINUE]    };  map: PACKED ARRAY FileToolOps.ListOptions OF FileTransfer.ValidProperties = [      type: type, bytes: size, author: author,      create: create, write: write, read: read];        defaultProps: FileTransfer.DesiredProperties = [    host: TRUE, directory: TRUE, body: TRUE, version: TRUE,        create: FALSE, write: FALSE, read: FALSE,    author: FALSE, size: FALSE, type: FALSE,    oldFile: FALSE, readProtect: FALSE];     SetOptions: PROC [cmd: FileToolOps.Cmd] =    BEGIN    props: FileTransfer.DesiredProperties ¬ defaultProps;    FOR i: FileToolOps.ListOptions IN FileToolOps.ListOptions DO      props[map[i]] ¬ cmd.options[i]      ENDLOOP;    props[type] ¬ TRUE;  -- I depend on this internally, until I put in isDirectory;    props[create] ¬ TRUE; --depend on this for retrieves    FileTransfer.SetDesiredProperties[cmd.connection, props]    END;      FreeCmd: PROC [cmd: FileToolOps.Cmd] = {    z.FREE[@cmd.host];    z.FREE[@cmd.directory];    z.FREE[@cmd.localdir];    z.FREE[@cmd.sourceName];    z.FREE[@cmd.destName];    z.FREE[@cmd.connectName];    z.FREE[@cmd.connectPassword];    z.FREE[@cmd]};  Command: ENTRY PROCEDURE [command: FileToolOps.FTPCommand, veto: FilterType] =    BEGIN    ENABLE UNWIND => NULL;    copiedCmd: FileToolOps.Cmd;    ok: BOOLEAN;    IF busy THEN {Put.Line[data.msgSW, "FileTool already busy!"L]; RETURN};    busy ¬ TRUE;    Put.CR[data.msgSW];    ClearCommandSubwindow[];    SetVeto[veto];    [copiedCmd, ok] ¬ CopyCmd[@data.cmd];    IF ~ok THEN command ¬ null;    Process.Detach[data.process ¬ FORK FileToolOps.GiveCommand[command, copiedCmd]];    END;  AttentionProc: ENTRY UserInput.AttentionProcType = {    IF data.process # NIL THEN {      p: PROCESS ¬ data.process;      data.process ¬ NIL;      Process.Abort[p];      data.aborted ¬ TRUE}};  Confirm: ENTRY PROCEDURE [c: FileTransfer.Confirmation] =    BEGIN    ENABLE UNWIND => NULL;    IF data.toolState # active THEN {data.confirmState ¬ abort; RETURN};    ClearCommandSubwindow[];    SELECT c FROM      do, skip, abort => data.confirmState ¬ c;      ENDCASE => data.confirmState ¬ abort;    NOTIFY haveConfirm;    END;  Finished: PUBLIC ENTRY PROCEDURE [parms: FileToolOps.Cmd] =    BEGIN    ENABLE UNWIND => NULL;    FreeCmd[parms];    busy ¬ FALSE;    NOTIFY finished;    data.aborted ¬ FALSE;    data.process ¬ NIL;    SELECT data.toolState FROM      active => ChangeCommandSubwindow[commands];      tiny => FileTransfer.Close[data.cmd.connection];      inactive => {        FileTransfer.Destroy[data.cmd.connection]; data.cmd.connection ¬ NIL};      ENDCASE;    END;  -- Destroy and Cleanup routines  UpdateDefaults: ENTRY Supervisor.AgentProcedure =    BEGIN    ENABLE UNWIND => NULL;    SELECT event FROM      EventTypes.aboutToBoot, EventTypes.aboutToAbortSession,      EventTypes.aboutToResume, EventTypes.aboutToBootPhysicalVolume =>        IF busy THEN {          PostComment[NIL, terse, "\nFileTool busy: aborting swap."L];          HeraldWindow.AppendMessage["FileTool busy: aborting swap."L];          ERROR Supervisor.EnumerationAborted}        ELSE          IF data.cmd.connection # NIL THEN            FileTransfer.Close[data.cmd.connection];      EventTypes.primaryCredentials =>        SELECT ToolWindow.GetState[toolWindow] FROM          active, tiny => {            SetUser: PROCEDURE [name, password: LONG STRING] = {	      FileTransfer.SetPrimaryCredentials[	        conn: data.cmd.connection, user: name, password: password]};            SetID: PROCEDURE [id: Auth.IdentityHandle] = {              FileTransfer.SetPrimaryCredentials[	        conn: data.cmd.connection, id: id]};	    Profile.GetUser[proc: SetUser];	    Profile.GetID[proc: SetID]};	  ENDCASE;       ENDCASE;    END;  MakeSWs: ENTRY Tool.MakeSWsProc =    BEGIN OPEN Tool;    fileName: STRING = [50];    addresses: ARRAY [0..4) OF ToolDriver.Address;    Tool.UnusedLogName[unused: fileName, root: "FileTool.log"L];    data.msgSW ¬ MakeMsgSW[window: window, lines: 1];    data.paramSW ¬ MakeFormSW[window: window, formProc: MakeParams];    data.commandSW ¬ MakeFormSW[window: window, formProc: MakeCommands];    data.log ¬ MakeFileSW[window: window, name: fileName];    FOR w: Window.Handle ¬ data.msgSW, w.GetParent[] UNTIL w = toolWindow DO      UserInput.SetAttention[w, AttentionProc];      ENDLOOP;    UserInput.SetAttention[data.paramSW, AttentionProc];    UserInput.SetAttention[data.commandSW, AttentionProc];    UserInput.SetAttention[data.log, AttentionProc];    data.toolState ¬ active;    data.cmd.connection ¬ FileTransfer.Create[];    FileTransfer.SetProcs[      data.cmd.connection, NIL, PostComment, , InvertIndicator, CheckForAbort];    addresses ¬ [      [name: "MsgSW"L, sw: data.msgSW], [name: "ParamSW"L, sw: data.paramSW], [      name: "CmdSW"L, sw: data.commandSW], [name: "LogSW"L, sw: data.log]];    ToolDriver.NoteSWs[tool: "FileTool"L, subwindows: DESCRIPTOR[addresses]];    END;  Transit: ToolWindow.TransitionProcType =    BEGIN    MonitoredState: ENTRY PROC [t: ToolState] RETURNS [BOOLEAN] = {      ENABLE UNWIND => NULL; data.toolState ¬ t; RETURN[busy]};    IF old = inactive THEN {      SetUserCmOptions[]     };    SELECT new FROM      active => IF old = tiny THEN {[] ¬ MonitoredState[active]; PostCommands[]};      tiny =>        IF old = active AND ~MonitoredState[tiny] THEN          FileTransfer.Close[data.cmd.connection];      inactive => {        IF ~MonitoredState[inactive] THEN {          FileTransfer.Destroy[data.cmd.connection]; data.cmd.connection ¬ NIL};        ToolDriver.RemoveSWs[tool: "FileTool"L];        IF optionWindow # NIL THEN {          Tool.Destroy[optionWindow]; optionWindow ¬ NIL}};      ENDCASE;    END;  SetUserCmOptions: PROCEDURE =    BEGIN    FullNames: TYPE = MACHINE DEPENDENT {      setOption, unsetOption, noMatch(StringLookUp.noMatch)};    Names: TYPE = FullNames[setOption..unsetOption];    namesTable: ARRAY Names OF LONG STRING ¬      [setOption: "SetOptions"L, unsetOption: "UnsetOptions"L];    FullBool: TYPE = MACHINE DEPENDENT{false, true, noMatch(StringLookUp.noMatch)};    Bool: TYPE = FullBool[false..true];    boolTable: ARRAY Bool OF LONG STRING ¬ [false: "FALSE"L, true: "TRUE"];        cmFile: CmFile.Handle ¬ CmFile.UserDotCmOpen[    ! CmFile.Error => IF code = fileNotFound THEN GOTO return];    name, value: LONG STRING;    IF CmFile.FindSection[cmFile, "FileTool"L] THEN       BEGIN      [name, value] ¬ CmFile.NextItem[cmFile];      WHILE name # NIL DO        -- SELECT InNamesTable[name, namesTableDesc] FROM --	iName: FullNames = LOOPHOLE[	  StringLookUp.InTable[	    key: name,	    table: DESCRIPTOR[BASE[namesTable], LENGTH[namesTable]]]];	SELECT iName FROM	  setOption => OptionsFromValue[value, TRUE];	--  unsetOption => OptionsFromValue[value, FALSE];	  ENDCASE => NULL;	name ¬ Token.FreeTokenString[name];	value ¬ Token.FreeTokenString[value];	[name, value] ¬ CmFile.NextItem[cmFile];	ENDLOOP;      END;    cmFile ¬ CmFile.Close[cmFile];    EXITS      return => NULL    END; -- of SetUserCmOptions      NextItem: PROCEDURE [ss: String.SubString] RETURNS [item: LONG STRING] =    BEGIN    SkipSpaces[ss];    ss.length ¬ 0;    UNTIL ss.offset + ss.length >= ss.base.length OR     ss.base[ss.offset + ss.length] = Ascii.SP DO      ss.length ¬ ss.length + 1;      ENDLOOP;    IF ss.length = 0 THEN RETURN[NIL];    item ¬ z.NEW[StringBody[ss.length]];    String.AppendSubString[item, ss];    ss.offset ¬ ss.offset + ss.length;    END;    SkipSpaces: PROCEDURE [ss: String.SubString] =    BEGIN    WHILE ss.offset < ss.base.length AND ss.base[ss.offset] = Ascii.SP DO      ss.offset ¬ ss.offset + 1;      ENDLOOP;    END; -- of SkipSpaces  OptionsFromValue: PROCEDURE [value: LONG STRING, bool: BOOLEAN] =    BEGIN    FullOptions: TYPE = MACHINE DEPENDENT {always, author, bytes, create, equal,      greater, less, quoted, read, type, verify, write,      noMatch(StringLookUp.noMatch)};    Options: TYPE = FullOptions[always..write];    optionsTable: ARRAY Options OF LONG STRING ¬      [always: "Always"L, author: "Author"L, bytes: "Bytes"L, create: "Create"L,       equal: "Equal"L, greater: "Greater"L, less: "Less"L, quoted: "QuotedStar"L,       read: "Read"L, type: "Type"L, verify: "Verify"L, write: "Write"L];    valueSSDesc: String.SubStringDescriptor ¬ [value, 0, 0];    valueSS: String.SubString ¬ @valueSSDesc;     nextItem: LONG STRING ¬ NextItem[valueSS];    always ¬ verify ¬ timeLess ¬ timeEqual ¬ timeGreater ¬ FALSE;    FOR opt: FileToolOps.ListOptions IN FileToolOps.ListOptions DO      data.cmd.options[opt] ¬ FALSE      ENDLOOP;           WHILE nextItem # NIL DO      iOpt: FullOptions ¬ LOOPHOLE[StringLookUp.InTable[        key: nextItem,        table: DESCRIPTOR[BASE[optionsTable], LENGTH[optionsTable]]]];      SELECT iOpt FROM        always => always ¬ bool;        author => data.cmd.options[author] ¬ bool;        bytes => data.cmd.options[bytes] ¬ bool;        create => data.cmd.options[create] ¬ bool;        equal => timeEqual ¬ bool;        greater => timeGreater ¬ bool;        less => timeLess ¬ bool;        quoted => quoted ¬ bool;        read => data.cmd.options[read] ¬ bool;        type => data.cmd.options[type] ¬ bool;        verify => verify ¬ bool;        write => data.cmd.options[write] ¬ bool;	ENDCASE => NULL;      z.FREE[@nextItem];      nextItem ¬ NextItem[valueSS];      ENDLOOP;    END; -- of OptionsFromValue       Init: PROCEDURE =    BEGIN    name: STRING ¬ [50];    dims: Window.Dims = [500, 300];    rDims: Window.Dims = Window.GetBox[Window.rootWindow].dims;    String.AppendString[name, "File Tool "L];    Version.Append[name];    String.AppendString[name, " of "L];    Time.Append[name, Time.Unpack[bcdTime]];    toolWindow ¬ Tool.Create[      name: name, makeSWsProc: MakeSWs, clientTransition: Transit,      initialBox: [[rDims.w - dims.w, rDims.h - dims.h], [dims.w, dims.h]],      cmSection: "FileTool"L];    UserInput.SetAttention[toolWindow, AttentionProc];    Supervisor.AddDependency[client: agent, implementor: Event.aboutToSwap];    Supervisor.AddDependency[client: agent, implementor: Event.primaryCredentials];    IF ExecUtilities.filetoolWindow = NIL THEN      ExecUtilities.filetoolWindow ¬ toolWindow;    END;  -- MAINLINE CODE  Init[];  END.  -- of FileTool Interface      
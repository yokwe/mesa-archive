-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- TIPTableBuilder.mesa; Last Edited by-- PXK    ,	22-Nov-82 11:25:29-- Paxton,	May 6, 1982 1:58 pm-- JGS, 	 8-Nov-82 13:46:34-- CXH   ,	28-Feb-83 15:00:09-- AXD    ,	 6-Nov-82 16:44:58-- DWR    	25-Jan-85 11:03:36DIRECTORY  Ascii USING [BS, CR, FF, LF, SP, TAB],  Atom USING [ATOM, MakeAtom],  Format USING [LongOctal, StringProc],  GPM USING [Close, Error, GetChar, GetIndex, Handle, Open],  Heap USING [Create, Delete, systemZone],  Keys USING [KeyName],  MFile USING [AddProperty, GetTimes, maxNameLength, SetProperty],  MStream USING [Error, GetFile, Handle, ReadOnly, WriteOnly],  Profile USING [debugging],  RefTab USING [Create, Fetch, Ref, Store],  Stream USING [PutString, Delete],  String USING [AppendChar, AppendString, Empty, Replace, StringBoundsFault],  System USING [SecondsSinceEpoch, switches],  TIP USING [InvalidTable, TableError],  TIPTable USING [    bytesForDate, Choice, ChoiceList, DefaultTable, EqualTables,     globalZone, KeyOption, KeyState, KeyStateList, KeyStateObject,     ReadCompiledTable, Results, ResultsObject,    Table, TableObject, Term, TermObject, TIPCSourceDate, WriteTable],  Token USING [    AlphaNumeric, Decimal, Filtered, FilterState, FreeTokenString,    Handle, Object, Skip, SyntaxError, WhiteSpace];TIPTableBuilder: MONITOR  IMPORTS    Atom, Format, GPM, Heap, MFile, MStream, Profile, RefTab, Stream, String,    System, TIP, TIPTable, Token  EXPORTS TIP, TIPTable =  BEGIN  -- Global Types    Results: TYPE = TIPTable.Results;  ResultsObject: TYPE = TIPTable.ResultsObject;  Table: TYPE = TIPTable.Table;  FastTable: TYPE = LONG POINTER TO fast TableObject;  TableObject: PUBLIC TYPE = TIPTable.TableObject;  Term: TYPE = TIPTable.Term;  TermObject: TYPE = TIPTable.TermObject;    AList: TYPE = LONG POINTER TO DPCell ¬ NIL;  DPCell: TYPE = RECORD [first: LONG STRING, rest: AList];  Symbol: TYPE = {    OptionSym, Small, Fast, FastMouse, SlowMouse, PrintKeys, DefaultKeys, Opaque,    Select, Trigger, Enable, From, Endcase, End, While, And, Up, Down, Mouse,    After, Before, RightArrow, Comma, Semicolon, LeftCurly, RightCurly, Greater,    Dot, Char, Coords, KeyIdent, Ident, Number, String, Time, VertBar, Enter, Exit,    Keys, Illegal};      RefTabItemHandle: TYPE = LONG POINTER TO RefTabItem;  RefTabItem: TYPE = RECORD [    SELECT type: * FROM      Key => [keyName: Keys.KeyName],      ReservedWord => [sy: Symbol],      ENDCASE];        -- Global Variables  filename: LONG STRING;  errlogfh: MStream.Handle;  fastOption: BOOLEAN;  fastMouseOption: BOOLEAN;  keyOption: TIPTable.KeyOption;  --keyNames: PUBLIC LONG POINTER TO ARRAY Keys.KeyName OF LONG STRING ¬  --  TIPTable.globalZone.NEW[ARRAY Keys.KeyName OF LONG STRING];  printKeyTable, defaultKeyTable: FastTable ¬ NIL;  -- global scanner variables:    tObject: Token.Object ¬ [getChar: GetChar];  th: Token.Handle ¬ @tObject;  nextCh: CHARACTER;  lookAheadCh: CHARACTER;  lookedAhead, backUp: BOOLEAN;     table: RefTab.Ref ¬ RefTab.Create[zone: TIPTable.globalZone];    thereAreErrors: BOOLEAN;  errcnt: CARDINAL;    symbol: Symbol;  reservedWord: BOOLEAN;  atom: Atom.ATOM;  number: CARDINAL;  string: LONG STRING ¬ TIPTable.globalZone.NEW[StringBody [100]];  keyName: Keys.KeyName;  symPos: LONG INTEGER ¬ 0;  fh: GPM.Handle;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- The Scanner  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    GetChar: PROCEDURE [h: Token.Handle] RETURNS [c: CHARACTER ¬ nextCh] = {    SELECT TRUE FROM      backUp => {backUp ¬ FALSE; c ¬ h.break};      lookedAhead => {lookedAhead ¬ FALSE; nextCh ¬ lookAheadCh};      ENDCASE => nextCh ¬ fh.GetChar[];    IF nextCh = '- THEN {      IF (lookAheadCh ¬ fh.GetChar[]) # '- THEN lookedAhead ¬ TRUE      ELSE {  -- scan over comment        DO  -- go to CR or double dash          SELECT fh.GetChar[] FROM            Ascii.CR => EXIT;            '- => SELECT fh.GetChar[] FROM '-, Ascii.CR => EXIT; ENDCASE;            ENDCASE;          ENDLOOP;        nextCh ¬ Ascii.SP}}};    GetString: PROCEDURE [s: LONG STRING] =    BEGIN    s.length ¬ 0;    WHILE nextCh # '" DO       IF nextCh = '\\ THEN { -- convert a \n spec. to a single character        SELECT nextCh ¬ fh.GetChar[] FROM          'n, 'N, 'r, 'R => nextCh ¬ Ascii.CR;          't, 'T => nextCh ¬ Ascii.TAB;          'b, 'B => nextCh ¬ Ascii.BS;          'f, 'F => nextCh ¬ Ascii.FF;          'l, 'L => nextCh ¬ Ascii.LF;           '\\, '',  '" => NULL;          IN ['0..'3] => {            d: CARDINAL ¬ nextCh - '0;            IF (nextCh ¬ fh.GetChar[]) ~IN ['0..'7] THEN  Error[26];            d ¬ d*8 + nextCh - '0;            IF (nextCh ¬ fh.GetChar[]) ~IN ['0..'7] THEN  Error[26];            d ¬ d*8 + nextCh - '0;            nextCh ¬ LOOPHOLE[d]};          ENDCASE =>  Error[26]};      String.AppendChar[s: s, c: nextCh ! String.StringBoundsFault => EXIT];      nextCh ¬ fh.GetChar[];      ENDLOOP;    nextCh ¬ fh.GetChar[]; -- flush the closing quote    END;      InitScanner: PROCEDURE = {    backUp ¬ lookedAhead ¬ FALSE;    [] ¬ GetChar[th];    Scanner[]};    Lookup: PROCEDURE [s: LONG STRING] = {    WhosBeenPuttingThingsInMyRefTab: ERROR = CODE;    found: BOOLEAN;    tih: RefTabItemHandle;    atom ¬ Atom.MakeAtom[s];    [found, tih] ¬ table.Fetch[atom];    IF found THEN WITH t: tih SELECT FROM      Key => {keyName ¬ t.keyName; symbol ¬ KeyIdent};      ReservedWord => {symbol ¬ t.sy; reservedWord ¬ TRUE};      ENDCASE => ERROR WhosBeenPuttingThingsInMyRefTab    ELSE symbol ¬ Ident};      Scanner: PROC =    BEGIN    th.Skip[NIL, Token.WhiteSpace];    backUp ¬ TRUE;    symPos ¬ fh.GetIndex[] - 1;    reservedWord ¬ FALSE;    SELECT th.break FROM      IN ['0..'9] => {        number ¬ th.Decimal[! Token.SyntaxError => REJECT];	backUp ¬ TRUE;        symbol ¬ Number};      IN ['a..'z], IN ['A..'Z] => {        tempString : LONG STRING ¬ th.Filtered[NIL, Token.AlphaNumeric, none];	backUp ¬ TRUE;        Lookup[tempString]; -- sets symbol, atom, etc.	tempString ¬ Token.FreeTokenString[tempString]};      = '" => {GetString[string]; backUp ¬ FALSE; symbol ¬ String};      ENDCASE => {        symbol ¬ SELECT th.break FROM          '; => Semicolon,          ', => Comma,          '> => Greater,          '. => Dot,          '| => VertBar,          '= => IF nextCh = '> THEN RightArrow ELSE Illegal,          '{ => LeftCurly,          '} => RightCurly,          ENDCASE => Illegal;	backUp ¬ FALSE;	IF symbol = RightArrow THEN [] ¬ GetChar[th]};    END;      MakeTable: PROC =    BEGIN--    dummy: Keys.KeyName = D1;  diagnostics Hard Key. no transitions        symbolNames: ARRAY Symbol OF LONG STRING = [      "OPTIONS"L, "Small"L, "Fast"L, "FastMouse"L, "SlowMouse"L, "PrintKeys"L,      "DefaultKeys"L, "Opaque"L, "SELECT"L, "TRIGGER"L, "ENABLE"L, "FROM"L,      "ENDCASE"L, "END"L, "WHILE"L, "AND"L, "Up"L, "Down"L, "MOUSE"L, "AFTER"L,      "BEFORE"L, --RightArrow-- NIL, --Comma-- NIL, --Semicolon-- NIL,      --LeftCurly-- NIL, --RightCurly-- NIL, --Greater-- NIL, --Dot-- NIL, "CHAR"L,      "COORDS"L, --KeyIdent-- NIL, --Ident-- NIL, --Number-- NIL, --String-- NIL,      "TIME"L, --VertBar-- NIL, "ENTER"L, "EXIT"L, "KEYS"L, --Illegal-- NIL];                  keyNames: ARRAY Keys.KeyName OF LONG STRING = [      "null"L, "Bullet"L, "SuperSub"L, "Case"L, "Strikeout"L, "KeypadTwo"L, "KeypadThree"L,       "SingleQuote"L, "KeypadAdd"L, "KeypadSubtract"L, "KeypadMultiply"L, "KeypadDivide"L,       "KeypadClear"L, "Point"L, "Adjust"L, "Menu"L, "Five"L, "Four"L, "Six"L, "E"L, "Seven"L,       "D"L, "U"L, "V"L, "Zero"L, "K"L, "Dash"L, "P"L, "Slash"L, "BackSlash"L, "PASTE"L, "BS"L,       "Three"L, "Two"L, "W"L, "Q"L, "S"L, "A"L, "Nine"L, "I"L, "X"L, "O"L, "L"L, "Comma"L,       "Quote"L, "RightBracket"L, "STUFF"L, "COMMAND"L, "One"L, "COMPLETE"L, "TAB"L,       "F"L, "CONTROL"L, "C"L, "J"L, "B"L, "Z"L, "LeftShift"L, "Period"L, "SemiColon"L,       "Return"L, "Arrow"L, "DELETE"L, "NEXT"L, "R"L, "T"L, "G"L, "Y"L, "H"L, "Eight"L, "N"L,       "M"L, "LOCK"L, "Space"L, "LeftBracket"L, "Equal"L, "RightShift"L, "USERABORT"L,       "MOVE"L, "UNDO"L, "DOIT"L, "KeypadSeven"L, "KeypadEight"L, "KeypadNine"L,       "KeypadFour"L, "KeypadFive"L, "English"L, "KeypadSix"L, "Katakana"L, "COPY"L, "FIND"L,       "AGAIN"L, "HELP"L, "EXPAND"L, "KeypadOne"L, "DiagnosticBitTwo"L, "DiagnosticBitOne"L,       "MENU"L, "KeypadZero"L, "SCROLLBAR"L, "JFIRST"L, "JSELECT"L, "RESERVED"L,       "CLIENT1"L, "CLIENT2"L, "KeypadPeriod"L, "KeypadComma"L, "LeftShiftAlt"L,       "DoubleQuote"L, "ATTENTION"L, "Hiragana"L, "RightShiftAlt"L];    MakeItem: PROCEDURE [s: LONG STRING, sy: RefTabItem] = INLINE {      [] ¬ table.Store[Atom.MakeAtom[s], TIPTable.globalZone.NEW[RefTabItem ¬ sy]]};          FOR k: Keys.KeyName IN Keys.KeyName DO      MakeItem[keyNames[k], [Key[keyName: k]]];      ENDLOOP;    FOR sy: Symbol IN Symbol DO      IF symbolNames[sy] # NIL THEN        MakeItem[symbolNames[sy], [ReservedWord[sy: sy]]];      ENDLOOP;    END;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- The Parser  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  Concatenate: PROC [list1, list2: Term] RETURNS [Term] =    BEGIN    l: Term ¬ list1;    IF list1 = NIL THEN RETURN[list2];    FOR l ¬ list1, l.rest UNTIL l.rest = NIL DO ENDLOOP;    l.rest ¬ list2;    RETURN[list1];    END;  CreateFile: PROCEDURE [name: LONG STRING, contents: LONG STRING] = {    sH: MStream.Handle = MStream.WriteOnly[name, [], text !      MStream.Error => GOTO failed];    sH.PutString[contents];    sH.Delete[];    EXITS failed => {}};    BuildTable: PUBLIC PROC [    file: LONG STRING, opaque: BOOLEAN, z: UNCOUNTED ZONE, contents: LONG STRING]    RETURNS [table: Table ¬ NIL] =    BEGIN    option: TIPTable.KeyOption;    sourceDate: LONG CARDINAL;    stream: MStream.Handle;    compName: LONG STRING = [MFile.maxNameLength];        tryCreate: BOOLEAN ¬ ~String.Empty[contents];        String.AppendString[compName, file];    String.AppendString[compName, "C"L];    IF System.switches['I] = down THEN      IF tryCreate THEN {tryCreate ¬ FALSE; CreateFile[file, contents]};    [table, option, sourceDate] ¬ ParseTable[file, z ! TIP.InvalidTable =>      IF tryCreate THEN {        tryCreate ¬ FALSE;	IF type = badSyntax THEN SIGNAL TIP.InvalidTable[type, message];	CreateFile[file, contents];	RETRY}      ELSE {SIGNAL TIP.InvalidTable[type, message]; GOTO failed}];    IF table = NIL THEN RETURN;  -- we lost!    table.opaque ¬ opaque;    stream ¬ MStream.WriteOnly[compName, [], text];    MStream.GetFile[stream].AddProperty[      TIPTable.TIPCSourceDate, TIPTable.bytesForDate];    MStream.GetFile[stream].SetProperty[      TIPTable.TIPCSourceDate,      [LOOPHOLE[LONG[@sourceDate]], 0, TIPTable.bytesForDate]];    TIPTable.WriteTable[table, option, stream];    stream.Delete[];    IF Profile.debugging THEN {      tempZ: UNCOUNTED ZONE = Heap.Create[initial: 64, increment: 8];      newTable: Table;      newKeyOption: TIPTable.KeyOption;      TableDoesntVerify: ERROR = CODE;      stream ¬ MStream.ReadOnly[compName, []];      [newTable, newKeyOption] ¬ TIPTable.ReadCompiledTable[stream, tempZ];      stream.Delete[];      IF newKeyOption # option THEN ERROR TableDoesntVerify;      TIPTable.EqualTables[table, newTable];      Heap.Delete[tempZ]};    EXITS      failed => RETURN[NIL];    END;  -- of BuildTable  ParseTable: ENTRY PROC [file: LONG STRING, z: UNCOUNTED ZONE] RETURNS [      table: Table ¬ NIL, option: TIPTable.KeyOption, sourceDate: LONG CARDINAL] =    BEGIN    -- TIPTable ::= Options TriggerStmt .    -- Options ::= empty | "OPTIONS" OptionList ;        -- Satterthwaite suggested all this crap about the GOTO.    ENABLE      UNWIND => {        IF fh # NIL THEN {fh.Close[]; fh ¬ NIL};        IF thereAreErrors AND errlogfh # NIL AND errlogfh.delete # NIL THEN {	  errlogfh.delete[errlogfh]; errlogfh ¬ NIL};        };    errMsg: LONG STRING ¬ NIL;    BEGIN  -- fake begin to get around bug where double catch phrase fails    ENABLE      BEGIN      GPM.Error => {        String.Replace[@errMsg, errorMsg, Heap.systemZone]; GOTO MacroCleanup};      TIPError => GOTO Cleanup;      END;    statement: TIPTable.Choice;    sH: MStream.Handle;    filename ¬ file;    fh ¬ NIL;    sH ¬ MStream.ReadOnly[file, [] !      MStream.Error => ERROR TIP.InvalidTable[fileNotFound, filename]];    sourceDate ¬ System.SecondsSinceEpoch[MStream.GetFile[sH].GetTimes[].create];    fh ¬ GPM.Open[sH];    thereAreErrors ¬ FALSE;    fastOption ¬ FALSE;    fastMouseOption ¬ FALSE;    keyOption ¬ none;    InitScanner[];    IF symbol = OptionSym THEN OptionList[];    option ¬ keyOption;    IF symbol = Select THEN      BEGIN      Scanner[];      IF symbol = Trigger THEN {Scanner[]; statement ¬ TriggerStmt[z]}      ELSE Error[5];  -- skip      IF symbol # Dot THEN Error[3];      END    ELSE Error[1];    fh.Close[];    fh ¬ NIL;    IF ~thereAreErrors THEN table ¬ GenerateTable[statement, z];    IF thereAreErrors THEN ErrorFinish[];  -- finish the error log and raise signal    EXITS      Cleanup => {ErrorFinish[]};      MacroCleanup => {        IF ~thereAreErrors THEN OpenErrorLog[];	errcnt ¬ errcnt + 1;	errlogfh.PutString["Error from macro package"L];        errlogfh.PutString[errMsg];        errlogfh.PutString[" at "L];        Format.LongOctal[proc: StringProc, n: symPos];        errlogfh.PutString[""L];        Heap.systemZone.FREE[@errMsg];        ErrorFinish[]};    END;  -- fake block (see above)    END;  -- ParseTable  ErrorFinish: PROC = {    errlogfh.delete[errlogfh];    errlogfh ¬ NIL;    ERROR TIP.InvalidTable[badSyntax, filename]};  GenerateTable: PROC [series: TIPTable.Choice, z: UNCOUNTED ZONE]    RETURNS [table: Table] =    BEGIN    table ¬ IF fastOption THEN z.NEW[fast TableObject] ELSE z.NEW[small TableObject];    WITH table SELECT FROM      fast =>        FOR choice: TIPTable.Choice ¬ series, choice.rest UNTIL choice = NIL DO          term: Term ¬ choice.first;          WITH term SELECT FROM            keyTrigger =>              IF keyState.state = up THEN {                ignoreUp ¬ FALSE;                IF keyUp[keyState.key] # NIL THEN DoubleDef[keyState.key];                keyUp[keyState.key] ¬ term.rest}              ELSE {                ignoreDown ¬ FALSE;                IF keyDown[keyState.key] # NIL THEN DoubleDef[keyState.key];                keyDown[keyState.key] ¬ term.rest};            mouseTrigger => {              ignoreMove ¬ FALSE;              IF mouse # NIL THEN Error[25];              mouse ¬ term.rest};            enterTrigger => {              ignoreMove ¬ FALSE;              IF enter # NIL THEN Error[25];              enter ¬ term.rest};            exitTrigger => {              ignoreMove ¬ FALSE;              IF exit # NIL THEN Error[25];              exit ¬ term.rest};            timeTrigger => Error[];  -- to be detected earlier !!!            ENDCASE;          ENDLOOP;      small =>        BEGIN        FOR choice: TIPTable.Choice ¬ series, choice.rest UNTIL choice = NIL DO          term: Term ¬ choice.first;          WITH term SELECT FROM            keyTrigger =>              IF keyState.state = up THEN ignoreUp ¬ FALSE ELSE ignoreDown ¬ FALSE;            mouseTrigger, enterTrigger, exitTrigger => ignoreMove ¬ FALSE;            timeTrigger => Error[];  -- to be detected earlier !!!            ENDCASE;          ENDLOOP;        all ¬ series;        END;      ENDCASE;    IF keyOption # none THEN {      table.link ¬ TIPTable.DefaultTable[keyOption = printKeys]; table.opaque ¬ FALSE};    IF fastMouseOption THEN table.mouseActions ¬ all;    END;  -- GenerateTable  OptionList: PROC =    BEGIN    -- OptionList ::= Option | Option , OptionList    -- Option ::= SmallOrFast | PrintOrDefaultKeys | FastOrSlowMouse    -- SmallOrFast ::= "Small" | "Fast"    -- PrintOrDefaultKeys ::= "PrintKeys" | "DefaultKeys"    -- FastOrSlowMouse ::= "FastMouse" | "SlowMouse"    Scanner[];    DO  -- until see Semicolon      SELECT symbol FROM        Fast => fastOption ¬ TRUE;        Small => fastOption ¬ FALSE;        DefaultKeys => keyOption ¬ defaultKeys;        PrintKeys => keyOption ¬ printKeys;        FastMouse => fastMouseOption ¬ TRUE;        SlowMouse => fastMouseOption ¬ FALSE;        ENDCASE => Error[18];      Scanner[];      SELECT symbol FROM Semicolon => EXIT; Comma => NULL; ENDCASE => Error[19];      Scanner[];      ENDLOOP;    Scanner[];    END;  -- OptionList  CheckForUniqueSymbol: PROC [symbols: AList] =    BEGIN    -- maintain the list symbols used to label the branches of the current statement    FOR list: AList ¬ symbols, list.rest UNTIL list = NIL DO      IF list.first = atom THEN GOTO notUnique;      REPEAT        notUnique => Error[17];        FINISHED => symbols ¬ ConsAList[atom, symbols];  -- !!!      ENDLOOP;    END;  TriggerStmt: PROC [z: UNCOUNTED ZONE] RETURNS [TIPTable.Choice] =    BEGIN    -- TriggerStmt ::= SELECT TRIGGER FROM TriggerChoiceSeries    IF symbol = From THEN Scanner[] ELSE Error[6];  -- skip until choice-begin    RETURN[TriggerChoiceSeries[z]];    END;  -- TriggerStmt  EnableStmt: PROC [z: UNCOUNTED ZONE] RETURNS [TIPTable.Choice] =    BEGIN    -- EnableStmt ::= SELECT ENABLE FROM EnableChoiceSeries    IF symbol = From THEN Scanner[] ELSE Error[20]; -- skip until (enable)choice-begin    RETURN[EnableChoiceSeries[z]];    END;  -- EnableStmt  TriggerChoiceSeries: PROC [z: UNCOUNTED ZONE] RETURNS [TIPTable.Choice] =    BEGIN    -- TriggerChoiceSeries ::= TriggerChoice ; TriggerChoiceSeries    --			     | TriggerChoice ENDCASE FinalChoice    --			     | ENDCASE FinalChoice    term: Term;    IF symbol = Endcase THEN {Scanner[]; RETURN[FinalChoice[z]]};    term ¬ TriggerChoice[z];    IF symbol = Semicolon THEN {      Scanner[]; RETURN[ConsChoice[term, TriggerChoiceSeries[z], z]]};    IF symbol = Endcase THEN {      Scanner[]; RETURN[ConsChoice[term, FinalChoice[z], z]]}; -- may be NIL!?    Error[2]; ERROR; -- prove to the compiler that Error[2] can't return    END;  -- TriggerChoiceSeries  EnableChoiceSeries: PROC [z: UNCOUNTED ZONE] RETURNS [TIPTable.Choice] =    BEGIN    -- EnableChoiceSeries ::= EnableChoice ; EnableChoiceSeries    --                      | EnableChoice ENDCASE FinalChoice    --                      | ENDCASE FinalChoice    term: Term;    IF symbol = Endcase THEN {Scanner[]; RETURN[FinalChoice[z]]};    term ¬ EnableChoice[z];    IF symbol = Semicolon THEN {      Scanner[]; RETURN[ConsChoice[term, EnableChoiceSeries[z], z]]};    IF symbol = Endcase THEN {      Scanner[]; RETURN[ConsChoice[term, FinalChoice[z], z]]};  -- may be NIL!?    Error[2];  ERROR; -- prove to the compiler that Error[2] can't return    END;  -- EnableChoiceSeries  TriggerChoice: PROC [z: UNCOUNTED ZONE] RETURNS [triggerChoice: Term] = {    -- TriggerChoice ::= TriggerTerm Expression    term: Term = TriggerTerm[z]; RETURN[Concatenate[term, Expression[z]]]};  EnableChoice: PROC [z: UNCOUNTED ZONE] RETURNS [Term] = {    -- EnableChoice ::= EnableTerm Expression    enable: Term = EnableTerm[z]; RETURN[Concatenate[enable, Expression[z]]]};  TriggerTerm: PROC [z: UNCOUNTED ZONE] RETURNS [triggerTerm: Term] =    BEGIN    -- TriggerTerm ::= Key TimeOut | MOUSE TimeOut | ENTER TimeOut | EXIT TimeOut    SELECT symbol FROM      KeyIdent => {triggerTerm ¬ NewTerm[[variants: keyTrigger[keyState: Key[]]], z]};      Mouse => {triggerTerm ¬ NewTerm[[variants: mouseTrigger[]], z]; Scanner[]};      Enter => {triggerTerm ¬ NewTerm[[variants: enterTrigger[]], z]; Scanner[]};      Exit => {triggerTerm ¬ NewTerm[[variants: exitTrigger[]], z]; Scanner[]};      ENDCASE => Error[8];  -- skip    IF symbol = Before OR symbol = After THEN      triggerTerm ¬ ConsTerm[TimeOut[], triggerTerm, z];    END;  -- TriggerTerm  EnableTerm: PROC [z: UNCOUNTED ZONE] RETURNS [enableTerm: Term] =    BEGIN    -- EnableTerm ::= KeyEnableList | PredicateIdent    IF symbol = KeyIdent THEN RETURN[KeyEnableList[z]];    IF symbol = Ident THEN {      enableTerm ¬ NewTerm[[variants: predEnable[predicate: atom]], z];      Scanner[]; RETURN};    Error[21];    END;  -- EnableTerm  KeyEnableList: PROC [z: UNCOUNTED ZONE] RETURNS [Term] =    BEGIN      -- KeyEnableList ::= Key | Key "|" KeyEnableList    first: TIPTable.KeyState ¬ Key[];    rest: Term;    KeyEnableListReturnedSomethingBogus: ERROR = CODE;    IF symbol # VertBar THEN      RETURN[NewTerm[[variants: keyEnable[keyState: first]], z]];    Scanner[];    IF symbol # KeyIdent THEN Error[21];    rest ¬ KeyEnableList[z];    WITH r: rest SELECT FROM      keyEnable =>        BEGIN	keyTerm: keyEnableList TermObject;	keyTerm.list ¬ ConsKeyState[first, ListKeyState[r.keyState, z], z];	RETURN[NewTerm[keyTerm, z]];	END;      keyEnableList =>        BEGIN        keyTerm: keyEnableList TermObject =	  [variants: keyEnableList[list: ConsKeyState[first, r.list, z]]];        RETURN[NewTerm[keyTerm, z]];        END;      ENDCASE => ERROR KeyEnableListReturnedSomethingBogus;    END; -- KeyEnableList  Key: PROC RETURNS [TIPTable.KeyState] =    BEGIN    -- KeyIdent UP | KeyIdent DOWN    name: Keys.KeyName ¬ keyName;    Scanner[];    SELECT symbol FROM      Up => {Scanner[]; RETURN[[name, up]]};      Down => {Scanner[]; RETURN[[name, down]]};      ENDCASE => {        Error[12]; ERROR};  -- prove to the compiler that Error[12] can't return    END;  -- Key  TimeOut: PROC RETURNS [timeoutExpr: timeTrigger TermObject] =    BEGIN    -- TimeOut ::= empty | BEFORE Number | AFTER Number    timeoutExpr.flavor ¬ IF symbol = Before THEN lt ELSE gt;    Scanner[];    IF symbol = Number THEN {timeoutExpr.mSecs ¬ number; Scanner[]}    ELSE Error[10];  -- skip    END;  -- TimeOut  Expression: PROC [z: UNCOUNTED ZONE] RETURNS [Term] =    BEGIN    -- Expression ::= AND TriggerChoice | WHILE EnableChoice    --		    | => Statement    SELECT symbol FROM      And => {Scanner[]; RETURN[TriggerChoice[z]]};      While => {Scanner[]; RETURN[EnableChoice[z]]};      RightArrow => {Scanner[]; RETURN[Statement[z]]};      ENDCASE => {        Error[22]; ERROR};  -- prove to the compiler that Error[22] can't return    END;  -- Expression  ParseResults: PROC [z: UNCOUNTED ZONE]    RETURNS [resultList: Results, resultChoice: Term] =    BEGIN    -- Results ::= ResultItem | ResultItem , Results | ResultItem Expression | { ResultItem* }        appendWhere: LONG POINTER TO Term;    IF symbol = LeftCurly THEN {      Scanner[]; [resultList, resultChoice] ¬ ResultItems[z]; RETURN};    [resultList, resultChoice] ¬ ResultItem[z];    appendWhere ¬ IF resultChoice = NIL THEN @resultChoice ELSE @resultChoice.rest;    SELECT symbol FROM      Comma => {Scanner[]; [resultList.rest, appendWhere­] ¬ ParseResults[z]};      And, While, RightArrow => appendWhere­ ¬ Expression[z];      ENDCASE => appendWhere­ ¬ NewTerm[[variants: result[list: NIL]]];    END;  -- ParseResults  Store: PROC [resultList: Results, tree: Term] =    BEGIN    -- find all leaves l:[result TermObject] of the tree,    -- append the list found there to a copy of resultList, and     -- store the resulting list as l.list    -- l.list ¬ Append[to: Copy[resultList], from: l.list];    FOR choice: Term ¬ tree, choice.rest UNTIL choice = NIL DO      WITH x: choice SELECT FROM        nested =>          FOR nestedChoice: TIPTable.Choice ¬ x.statement, nestedChoice.rest	  UNTIL nestedChoice = NIL DO Store[resultList, nestedChoice.first]; ENDLOOP;        result =>          IF x.list = NIL THEN x.list ¬ resultList	  ELSE {Error[24]; x.list ¬ resultList};  -- !!!        ENDCASE;      ENDLOOP;    END;  -- Store  ResultItems: PROC [z: UNCOUNTED ZONE]    RETURNS [resultList: Results, resultChoice: Term] =    BEGIN    -- ResultItems ::= ResultItem } | ResultItem ResultItems        appendWhere: LONG POINTER TO Term;    [resultList, resultChoice] ¬ ResultItem[z];    appendWhere ¬ IF resultChoice = NIL THEN @resultChoice ELSE @resultChoice.rest;    SELECT symbol FROM      RightCurly => {Scanner[]; appendWhere­ ¬ NewTerm[[variants: result[list: NIL]]]};      ENDCASE => [resultList.rest, appendWhere­] ¬ ResultItems[z];    END;  ResultItem: PROCEDURE [z: UNCOUNTED ZONE]    RETURNS [resultItem: Results, resultExpr: Term ¬ NIL] =    BEGIN    -- ResultItem ::= COORDS | CHAR | KEYS | TIME | String | Number | ResultIdent    SELECT symbol FROM      Char => {        r: LONG POINTER TO char ResultsObject = z.NEW[char ResultsObject];        resultItem ¬ r;        resultExpr ¬ z.NEW[char TermObject ¬ [variants: char[ch: r]]]};      Coords => {        r: LONG POINTER TO coords ResultsObject = z.NEW[coords ResultsObject];        resultItem ¬ r;        resultExpr ¬ z.NEW[coords TermObject ¬ [variants: coords[xy: r]]]};      Keys => {        r: LONG POINTER TO keys ResultsObject = z.NEW[keys ResultsObject];        resultItem ¬ r;        resultExpr ¬ z.NEW[keys TermObject ¬ [variants: keys[keys: r]]]};      Time => {        r: LONG POINTER TO time ResultsObject = z.NEW[time ResultsObject];        resultItem ¬ r;        resultExpr ¬ z.NEW[time TermObject ¬ [variants: time[t: r]]]};      KeyIdent,  -- result names might be key names      Ident => resultItem ¬ z.NEW[ResultsObject ¬ [v: atom[a: atom]]];      Number =>        resultItem ¬ z.NEW[ResultsObject ¬ [v: int[i: number]]];      String => {        resultString: LONG STRING ¬ z.NEW[StringBody [string.length]];        String.AppendString[resultString, string];        resultItem ¬ z.NEW[ResultsObject ¬ [v: string[s: resultString]]]};      ENDCASE =>        IF reservedWord THEN          resultItem ¬ z.NEW[ResultsObject ¬ [v: atom[a: atom]]]        ELSE Error[9];  -- skip    Scanner[];    END;  -- ResultItem  FinalChoice: PROC [z: UNCOUNTED ZONE] RETURNS [TIPTable.Choice] = {    -- FinalChoice ::= empty | => Statement    IF symbol = RightArrow THEN {Scanner[]; RETURN[ListChoice[Statement[z], z]]}    ELSE RETURN[NIL]};  Statement: PROC [z: UNCOUNTED ZONE] RETURNS [stmt: Term] =    BEGIN    -- Statement ::= TriggerStmt | EnableStmt | Results    IF symbol = Select THEN      BEGIN      Scanner[];      SELECT symbol FROM        Trigger => {	  Scanner[];	  RETURN[NewTerm[[variants: nested[statement: TriggerStmt[z]]], z]]};	Enable => {	  Scanner[];	  RETURN[NewTerm[[variants: nested[statement: EnableStmt[z]]], z]]};	ENDCASE => Error[13];      END    ELSE {      userResults: Results;      [userResults, stmt] ¬ ParseResults[z];      Store[userResults, stmt]};    END;  -- Statement  -- note that all parameters share the same variable for notification  -- users must copy parameter if they want to save value after returning from notify  OpenErrorLog: PROC = {    thereAreErrors ¬ TRUE;    errcnt ¬ 0;    errlogfh ¬ MStream.WriteOnly["tip.errors", [], text];    errlogfh.PutString[filename];    errlogfh.PutString[" TIP TABLE error log."L]};  DoubleDef: PROC [key: Keys.KeyName] =    BEGIN    IF ~thereAreErrors THEN OpenErrorLog[];    errcnt ¬ errcnt + 1;    --Stream.PutString[errlogfh, keyNames[key]];    errlogfh.PutString[" entry must not occur more than once in table."L];    END;  TIPError: ERROR = CODE;  StringProc: Format.StringProc = {errlogfh.PutString[s]};  Error: PUBLIC PROC [nr: CARDINAL ¬ 0] = {    IF ~thereAreErrors THEN OpenErrorLog[];    errcnt ¬ errcnt + 1;    errlogfh.PutString[      SELECT nr FROM        0 => "Error"L,        1 => "OPTIONS or CASE expected"L,        2 => "ENDCASE or ; expected"L,        3 => "'.' expected"L,        4 => "Ident expected"L,        5 => "TRIGGER expected"L,        6 => "OF expected"L,        7 => "': expected"L,        8 => "KeyIdent, MOUSE, ENTER or EXIT expected"L,        9 => "error in Action"L,        10 => "Number expected"L,        11 => "'> expected"L,        12 => "Up or Down expected"L,        13 => "TRIGGER or ENABLED expected"L,        14 => "illegal option"L,        15 => "enable procedures as CONDITION only"L,        16 => "mouse motion as TRIGGER only"L,        17 => "label used twice"L,        18 => "; expected"L,        19 => ", expected"L,        20 => "BY expected"L,        21 => "Key or Ident expected"L,        22 => "AND, WHILE, =>, or : expected"L,        23 => "CASE expected"L,        24 => "sorry, results only at leaves implemented"L,        25 => "MOUSE/ENTER/EXIT entries must not occur more than once in table."L,        26 => "Illegal character following \\ in string"L,        ENDCASE => "UNKNOWN!"L];    errlogfh.PutString[" at "L];    Format.LongOctal[proc: StringProc, n: symPos];    errlogfh.PutString[""L];    -- There are procedures that depend on the fact that Error cannot return    ERROR TIPError};  Reverse: PUBLIC PROCEDURE [list: Results, z: UNCOUNTED ZONE ¬ TIPTable.globalZone]    RETURNS [val: Results] = {    val ¬ NIL;    UNTIL list = NIL DO      val ¬ z.NEW[ResultsObject ¬ [v: list.v, rest: val]]; list ¬ list.rest; ENDLOOP;    RETURN[val]};  ConsAList: PROCEDURE [    x: Atom.ATOM, y: AList, z: UNCOUNTED ZONE ¬ TIPTable.globalZone]    RETURNS [AList] = INLINE {    RETURN[z.NEW[DPCell ¬ [first: x, rest: y]]]};  -- TIPChoiceCons  NewTerm: PROCEDURE [x: TermObject, z: UNCOUNTED ZONE ¬ TIPTable.globalZone]    RETURNS [Term] = INLINE {RETURN[z.NEW[TermObject ¬ x]]};  ConsTerm: PROCEDURE [    x: TermObject, y: Term, z: UNCOUNTED ZONE ¬ TIPTable.globalZone]    RETURNS [Term] = INLINE {x.rest ¬ y; RETURN[NewTerm[x]]};  -- TIPChoiceSeriesCons  ConsChoice: PROCEDURE [    x: Term, y: TIPTable.Choice, z: UNCOUNTED ZONE ¬ TIPTable.globalZone]    RETURNS [TIPTable.Choice] = INLINE {    RETURN[z.NEW[TIPTable.ChoiceList ¬ [first: x, rest: y]]]};  ListChoice: PROCEDURE [x: Term, z: UNCOUNTED ZONE ¬ TIPTable.globalZone]    RETURNS [TIPTable.Choice] = INLINE {RETURN[ConsChoice[x, NIL, z]]};  ConsKeyState: PROCEDURE [    x: TIPTable.KeyState, y: TIPTable.KeyStateList,    z: UNCOUNTED ZONE ¬ TIPTable.globalZone]    RETURNS [TIPTable.KeyStateList] = INLINE {    RETURN[z.NEW[TIPTable.KeyStateObject ¬ [keyState: x, rest: y]]]};  ListKeyState: PROCEDURE [    x: TIPTable.KeyState, z: UNCOUNTED ZONE ¬ TIPTable.globalZone]    RETURNS [TIPTable.KeyStateList] = INLINE {RETURN[ConsKeyState[x, NIL, z]]};    -- Mainline Code    MakeTable[];  END.LOGDWR    	25-Jan-85 11:03:09  Made the keynames look more Dove like
-- Copyright (C) 1980, 1981, 1982  by Xerox Corporation. All rights reserved. -- Queues.mesa-- last edited by:-- SXW   ; 12-Jul-81 14:46:19-- RXJ     ;  8-Dec-80 11:37:04-- LXR    ;  6-May-82 16:39:12DIRECTORY  Heap USING [Create],  String USING [AppendChar],  Stream USING [EndOfStream, Handle, GetByte, PutByte],  Queue USING [];Queues: PROGRAM IMPORTS Heap, String, Stream EXPORTS Queue =PUBLIC  BEGIN  BYTE: PRIVATE TYPE = [0..255];  z: PRIVATE UNCOUNTED ZONE = Heap.Create[initial: 10];  Q: TYPE = LONG POINTER TO QHead;  QHead: TYPE = RECORD [front, rear: LONG POINTER TO QElement];  NullQHead: QHead = [NIL, NIL];  QElement: PRIVATE TYPE = RECORD [    flink, rlink: LONG POINTER TO QElement ¬ NIL,    front, rear: CARDINAL ¬ 0,    data: PACKED SEQUENCE maxLen: CARDINAL OF BYTE];  pQE: PRIVATE TYPE = LONG POINTER TO QElement;  defaultElementSize: PRIVATE CARDINAL = 20;  EmptyQ: SIGNAL [q: Q] = CODE;  Init: PROCEDURE RETURNS [QHead] = {RETURN[NullQHead]};  IsEmpty: PROCEDURE [q: Q] RETURNS [BOOLEAN] = {    RETURN[q = NIL OR q.front = NIL]};  Empty: PROCEDURE [q: Q] =    BEGIN    UNTIL IsEmpty[q] DO      qf: pQE ¬ q.front;      nqf: pQE = qf.flink;      z.FREE[@qf];      IF nqf = NIL THEN q.rear ¬ NIL ELSE nqf.rlink ¬ NIL;      q.front ¬ nqf;      ENDLOOP;    RETURN    END;  GetF: PROCEDURE [q: Q] RETURNS [i: UNSPECIFIED [0..255]] =    BEGIN    qf: pQE;    qff: CARDINAL;    IF q = NIL OR q.front = NIL THEN {SIGNAL EmptyQ[q]; RETURN[0]};    qf ¬ q.front;    i ¬ qf[qff ¬ qf.front];    IF qf.front = qf.rear THEN      BEGIN  -- element empty      nf: pQE = qf.flink;      IF nf = NIL THEN q.rear ¬ NIL ELSE nf.rlink ¬ NIL;      z.FREE[@qf];      q.front ¬ nf;      END    ELSE      BEGIN qff ¬ IF qff = qf.maxLen - 1 THEN 0 ELSE qff + 1; qf.front ¬ qff; END;    RETURN    END;  GetR: PROCEDURE [q: Q] RETURNS [i: UNSPECIFIED [0..255]] =    BEGIN    qr: pQE;    qrr: CARDINAL;    IF q = NIL OR q.rear = NIL THEN {SIGNAL EmptyQ[q]; RETURN[0]};    qr ¬ q.rear;    i ¬ qr[qrr ¬ qr.rear];    IF qr.rear = qr.front THEN      BEGIN  -- element empty      nr: pQE = qr.rlink;      IF nr = NIL THEN q.front ¬ NIL ELSE nr.flink ¬ NIL;      z.FREE[@qr];      q.rear ¬ nr;      END    ELSE      BEGIN qrr ¬ IF qrr = 0 THEN qr.maxLen - 1 ELSE qrr - 1; qr.rear ¬ qrr; END;    RETURN    END;  FullElement: PROCEDURE [qe: pQE] RETURNS [BOOLEAN] = {    OPEN qe;    RETURN[      (IF rear < front THEN maxLen + rear - front ELSE rear - front) =        maxLen - 1]};  PutF: PROCEDURE [q: Q, i: UNSPECIFIED [0..255]] =    BEGIN    qf: pQE;    qff: CARDINAL;    IF q = NIL THEN RETURN;    qf ¬ q.front;    IF qf = NIL OR FullElement[qf] THEN      BEGIN      nf: pQE ¬ z.NEW[QElement [defaultElementSize]];      nf.flink ¬ qf;      IF qf = NIL THEN q.rear ¬ nf ELSE qf.rlink ¬ nf;      q.front ¬ qf ¬ nf;      qff ¬ 0;      END    ELSE qff ¬ IF qf.front = 0 THEN qf.maxLen - 1 ELSE qf.front - 1;    qf[qff] ¬ i;    qf.front ¬ qff;    RETURN    END;  PutR: PROCEDURE [q: Q, i: UNSPECIFIED [0..255]] =    BEGIN    qr: pQE;    qrr: CARDINAL;    IF q = NIL THEN RETURN;    qr ¬ q.rear;    IF qr = NIL OR FullElement[qr] THEN      BEGIN      nr: pQE ¬ z.NEW[QElement [defaultElementSize]];      nr.rlink ¬ qr;      IF qr = NIL THEN q.front ¬ nr ELSE qr.flink ¬ nr;      q.rear ¬ qr ¬ nr;      qrr ¬ 0;      END    ELSE qrr ¬ IF qr.rear = qr.maxLen - 1 THEN 0 ELSE qr.rear + 1;    qr[qrr] ¬ i;    qr.rear ¬ qrr;    RETURN    END;  Count: PROCEDURE [q: Q] RETURNS [elements: CARDINAL ¬ 0] =    BEGIN    IF q = NIL THEN RETURN;    FOR qp: pQE ¬ q.front, qp.flink UNTIL qp = NIL DO      elements ¬        elements +          (IF qp.front > qp.rear THEN qp.maxLen - qp.front + qp.rear + 1           ELSE qp.rear - qp.front + 1);      ENDLOOP;    RETURN    END;  Concatenate: PROCEDURE [q1, q2: Q] RETURNS [result: QHead] =    BEGIN    x1: QHead ¬ q1­;    x2: QHead ¬ q2­;    q1­ ¬ q2­ ¬ NullQHead;    IF x1.front = NIL THEN result ¬ x2    ELSE      IF x2.front = NIL THEN result ¬ x1      ELSE        BEGIN        result ¬ [front: x1.front, rear: x2.rear];        x1.rear.flink ¬ x2.front;        x2.front.rlink ¬ x1.rear;        END;    END;  Copy: PROCEDURE [from, to: Q] =    BEGIN    q: QHead ¬ NullQHead;    UNTIL IsEmpty[from] DO      c: BYTE ¬ GetF[from]; PutR[to, c]; PutR[@q, c]; ENDLOOP;    from­ ¬ q;    RETURN    END;  QFToString: PROCEDURE [q: Q, s: LONG STRING] =    BEGIN    IF s = NIL THEN RETURN;    UNTIL IsEmpty[q] DO String.AppendChar[s, GetF[q]] ENDLOOP;    END;  QFToStream: PROCEDURE [q: Q, s: Stream.Handle] =    BEGIN UNTIL IsEmpty[q] DO Stream.PutByte[s, GetF[q]] ENDLOOP; END;  StringToQR: PROCEDURE [s: LONG STRING, q: Q] =    BEGIN    IF s = NIL THEN RETURN;    FOR i: CARDINAL IN [0..s.length) DO PutR[q, s[i]] ENDLOOP;    END;  StreamToQR: PROCEDURE [s: Stream.Handle, q: Q] =    BEGIN DO PutR[q, Stream.GetByte[s ! Stream.EndOfStream => EXIT]] ENDLOOP; END;  END...
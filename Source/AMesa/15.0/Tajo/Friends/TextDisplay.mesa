-- Copyright (C) 1981, 1982  by Xerox Corporation. All rights reserved. -- File: TextDisplay.mesa - last edited:-- PXK    ,	 8-Sep-82 16:02:33-- SXW   ,	 9-Jul-81 17:42:20-- Mark,	Jul 7, 1980 9:10 PM-- JGS,		31-Aug-81 16:33:34-- AXD    ,	11-Nov-82 14:56:03DIRECTORY  Environment USING [Block],  String USING [SubString],  TextData USING [    Insertion, InsertionMode, MarkingAction, Selection, SelectionEntity,    SelectionMode, SelectionType],  TextSink USING [Handle],  TextSource USING [EditAction, Handle, Position],  Window USING [Box, Handle, Place];TextDisplay: DEFINITIONS =  BEGIN  -- Text Display Data and TYPE Definitions  Position: TYPE = TextSource.Position;  specialPlaceX: INTEGER = LAST[INTEGER];  noPlace: Window.Place = [specialPlaceX, LAST[INTEGER]];  invisiblePlace: Window.Place = [specialPlaceX, LAST[INTEGER] - 1];  lastPossibleChar: CARDINAL = 1999;  -- a very long line  Handle: TYPE = LONG POINTER TO Object;  Object: TYPE = RECORD [    source: TextSource.Handle,    sink: TextSink.Handle,    lineTable: LineTable,    options: Options,    allBetsAreOff: BOOLEAN,    ownStorage: BOOLEAN,    wh: Window.Handle,    box: Window.Box];  LineDescriptor: TYPE = RECORD [    pos: Position,    width: NATURAL];  -- raster width of displayed line  LineTable: TYPE = LONG POINTER TO LineTableObject;  LineTableObject: TYPE = RECORD [    firstPosition: Position,    lastPositionPlusOne: Position,  -- position of char that wouldn't fit or eof    crIsLast: BOOLEAN,    length: NATURAL,    array: SEQUENCE nEntries: CARDINAL OF LineDescriptor];  RightBreakMode: TYPE = {none, text, word};  BottomAction: TYPE = MACHINE DEPENDENT{none(0), scroll(1), signal(2)};  -- BottomAction = signal will SIGNAL on both under and overflow  Options: TYPE = RECORD [    rightBreak: RightBreakMode, bottomAction: BottomAction, margin: [0..16)];  Place: TYPE = RECORD [line: CARDINAL, position: CARDINAL];  -- Text Selection Data and TYPE Definitions  Insertion: TYPE = TextData.Insertion;  InsertionMode: TYPE = TextData.InsertionMode;  MarkingAction: TYPE = TextData.MarkingAction;  Selection: TYPE = TextData.Selection;  SelectionEntity: TYPE = TextData.SelectionEntity;  SelectionMode: TYPE = TextData.SelectionMode;  SelectionType: TYPE = TextData.SelectionType;  -- Signals  RequestNewBoxHeight: SIGNAL [p: Handle, delta: INTEGER] RETURNS [CARDINAL];  -- Text Display Routines  Adjust: PROCEDURE [p: Handle, box: Window.Box, select: Selection];  Bold: PROCEDURE [p: Handle, left, right: Position, select: Selection];  Create: PROCEDURE [    wh: Window.Handle, source: TextSource.Handle, sink: TextSink.Handle,    storage: Handle ¬ NIL] RETURNS [p: Handle];  Destroy: PROCEDURE [p: Handle] RETURNS [Handle];  Display: PROCEDURE [    p: Handle, select: Selection, alterW, alterH: BOOLEAN ¬ FALSE];  Redisplay: PROCEDURE [p: Handle, boxToFill: Window.Box, select: Selection]    RETURNS [boxFilled: Window.Box];  TakeBottomAction: PROCEDURE [    p: Handle, wasVisible: BOOLEAN, select: Selection, insert: Insertion];  Update: PROCEDURE [    p: Handle, from, to: Position, select: Selection, clear: BOOLEAN ¬ TRUE,    charsDeleted: BOOLEAN ¬ TRUE];  UpdateRange: PROCEDURE [    p: Handle, from, to: Position, delta: LONG INTEGER, select: Selection,    insert: Insertion, clear: BOOLEAN ¬ TRUE, charsDeleted: BOOLEAN ¬ TRUE];  UpdateToEnd: PROCEDURE [    p: Handle, from: Position, select: Selection, insert: Insertion,    clear: BOOLEAN ¬ TRUE, charsDeleted: BOOLEAN ¬ TRUE];  -- Text Selection/Insertion Routines  SelectNotifyProcType: TYPE = PROCEDURE [p: Handle, old, new: Selection];  DeleteText: PROCEDURE [    p: Handle, pos: Position, count: LONG CARDINAL, select: Selection,    insert: Insertion, keepTrash: BOOLEAN ¬ FALSE]    RETURNS [done: BOOLEAN, firstBad: Position];  DoEditAction: PROCEDURE [    p: Handle, select: Selection, insert: Insertion,    action: TextSource.EditAction]    RETURNS [from, to: Position, delta: LONG INTEGER];  InsertBlock: PROCEDURE [    p: Handle, block: Environment.Block, select: Selection, insert: Insertion]    RETURNS [firstBad: Position];  InsertCharacter: PROCEDURE [    p: Handle, char: CHARACTER, select: Selection, insert: Insertion]    RETURNS [firstBad: Position];  InsertSubString: PROCEDURE [    p: Handle, ss: String.SubString, select: Selection, insert: Insertion]    RETURNS [firstBad: Position];  MarkInsertion: PROCEDURE [p: Handle, insert: Insertion, action: MarkingAction];  MarkSelection: PROCEDURE [p: Handle, select: Selection, action: MarkingAction];  MoveInsertion: PROCEDURE [    p: Handle, swPlace: Window.Place, insert: Insertion, minPos: Position ¬ 0];  ReplaceBlock: PROCEDURE [    p: Handle, block: Environment.Block, pos: Position, count: LONG CARDINAL,    select: Selection, insert: Insertion, keepTrash: BOOLEAN ¬ FALSE]    RETURNS [done: BOOLEAN, firstBad: Position];  UpdateSelection: PROCEDURE [p: Handle, old, new: Selection];  -- Positioning and LineTable Routines  BackupNLines: PROCEDURE [p: Handle, lines: CARDINAL, select: Selection];  GetEOF: PROCEDURE [p: Handle] RETURNS [Position];  GetPosition: PROCEDURE [p: Handle, line: CARDINAL] RETURNS [Position];  LastDisplayedLine: PROCEDURE [p: Handle] RETURNS [CARDINAL];  LastLine: PROCEDURE [lt: LineTable] RETURNS [CARDINAL];  MoveLines: PROCEDURE [p: Handle, from, to: CARDINAL];  NewLineTable: PROCEDURE [old: LineTable, lines: CARDINAL, copy: BOOLEAN]    RETURNS [new: LineTable];  PositionIsVisible: PROCEDURE [p: Handle, position: Position] RETURNS [BOOLEAN];  SetEOF: PROCEDURE [p: Handle, eof: Position, select: Selection];  SetPosition: PROCEDURE [p: Handle, position: Position, select: Selection];  TextLines: PROCEDURE [p: Handle] RETURNS [CARDINAL];  UpdateLineTable: PROCEDURE [p: Handle, position: Position, delta: LONG INTEGER];  -- Utilities  AlterBoxHeight: PROCEDURE [p: Handle, newH: INTEGER, select: Selection];  AlterBoxY: PROCEDURE [p: Handle, newY: INTEGER];  ExtendPositionInterval: PROCEDURE [    p: Handle, left, right: Position, entity: SelectionEntity]    RETURNS [Position, Position];  LineFromY: PROCEDURE [p: Handle, y: INTEGER] RETURNS [CARDINAL];  PositionFromWindowPlace: PROCEDURE [    p: Handle, place: Window.Place, halfCharResolve: BOOLEAN ¬ FALSE]    RETURNS [position: Position, positionPlace: Window.Place];  WindowPlaceFromPosition: PROCEDURE [    p: Handle, position: Position, endOfLine, visibleOnly: BOOLEAN]    RETURNS [place: Window.Place];  -- Utilities (used between modules)  BoxPortion: TYPE = {topBottom, wholeBox};  DisplayAction: TYPE = {paint, replaceAndClear, measure};  CheckBoxHeight: PROCEDURE [p: Handle, select: Selection];  CharsInLine: PROCEDURE [p: Handle, line: CARDINAL] RETURNS [CARDINAL];  CharsToRead: PROCEDURE [position: Position, select: Selection]    RETURNS [inSelection: BOOLEAN, n: CARDINAL];  DisplayOneLine: PROCEDURE [    p: Handle, textPlace: TextDisplay.Place, select: Selection,    action: DisplayAction] RETURNS [position: Position, crOnEnd: BOOLEAN];  DrawGrayBox: PROCEDURE [    p: Handle, leftPlace, rightPlace: Window.Place, what: BoxPortion ¬ wholeBox];  GetEndPlaces: PROCEDURE [p: Handle, line, left, right: CARDINAL]    RETURNS [leftPlace, rightPlace: Window.Place];  LinesInBox: PROCEDURE [p: Handle, box: Window.Box] RETURNS [CARDINAL];  LineStartPlace: PROCEDURE [p: Handle, line: CARDINAL]    RETURNS [place: Window.Place];  MarkLineInterval: PROCEDURE [    p: Handle, line, left, right: CARDINAL, mode: SelectionMode];  MarkPlaceInterval: PROCEDURE [    p: Handle, leftPlace, rightPlace: Window.Place, mode: SelectionMode,    offset: INTEGER];  MarkPositionInterval: PROCEDURE [    p: Handle, left, right: Position, mode: SelectionMode];  PlaceFromPosition: PROCEDURE [p: Handle, position: Position, endOfLine: BOOLEAN]    RETURNS [place: Place];  PositionFromPlace: PROCEDURE [p: Handle, place: Place]    RETURNS [position: Position];  SelectionInterval: PROCEDURE [    p: Handle, line: CARDINAL, leftPlace, rightPlace: TextDisplay.Place]    RETURNS [left, right: CARDINAL];  z: UNCOUNTED ZONE;    END.
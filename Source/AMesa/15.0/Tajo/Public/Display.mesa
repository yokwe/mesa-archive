-- Display.mesa - last edited by -- BXM  	15-Oct-82 12:25:14-- AXD    	30-Sep-82 19:27:39-- PXK    	15-Oct-82 11:08:48  -- Copyright (C) Versatec, A Xerox Company 1982. All rights reserved.DIRECTORY  BitBlt USING [BitAddress, BitBltFlags, DstFunc],  Environment USING [Block],  Window USING [Box, BoxHandle, Handle, nullBox, Place],  WindowFont USING [Handle];  Display: DEFINITIONS =   BEGIN  Handle: TYPE = Window.Handle;    BitAddress: TYPE = BitBlt.BitAddress;  BitBltFlags: TYPE = BitBlt.BitBltFlags;  DstFunc: TYPE = BitBlt.DstFunc;    paintGrayFlags, bitFlags: BitBltFlags = [    direction: forward, disjoint: TRUE, disjointItems: TRUE, gray: TRUE,    srcFunc: null, dstFunc: or, reserved: 0];  replaceGrayFlags, boxFlags: BitBltFlags = [    direction: forward, disjoint: TRUE, disjointItems: TRUE, gray: TRUE,    srcFunc: null, dstFunc: null, reserved: 0];      xorGrayFlags, xorBoxFlags: BitBltFlags = [    direction: forward, disjoint: TRUE, disjointItems: TRUE, gray: TRUE,    srcFunc: null, dstFunc: xor, reserved: 0];      replaceFlags: BitBltFlags = [    direction: forward, disjoint: TRUE, disjointItems: TRUE, gray: FALSE,    srcFunc: null, dstFunc: null, reserved: 0];      textFlags, paintFlags: BitBltFlags = [    direction: forward, disjoint: TRUE, disjointItems: FALSE, gray: FALSE,    srcFunc: null, dstFunc: or, reserved: 0];    xorFlags: BitBltFlags = [    direction: forward, disjoint: TRUE, disjointItems: FALSE, gray: FALSE,    srcFunc: null, dstFunc: xor, reserved: 0];    -- utililies   BitAddressFromPlace: PROC [   base: BitAddress, x, y: NATURAL, raster: CARDINAL]   RETURNS [BitAddress];      -- arcs  Arc: PROC [    window: Handle, place: Window.Place, radius: INTEGER,     startSector, stopSector: CARDINAL, start, stop: Window.Place,     bounds: Window.BoxHandle ¬ NIL];      -- bitmaps  Bitmap: PROC [    window: Handle, box: Window.Box, address: BitAddress,     bitmapBitWidth: CARDINAL, flags: BitBltFlags ¬ paintFlags];    -- box.dims.w <= bitmapBitWidth if NOT flags.gray    -- boxes  White: PROCEDURE [window: Handle, box: Window.Box];  Black: PROCEDURE [window: Handle, box: Window.Box];  Invert: PROCEDURE [window: Handle, box: Window.Box];      -- grays  Brick: TYPE = LONG DESCRIPTOR FOR ARRAY OF CARDINAL;  fiftyPercent: Brick = NIL;    Gray: PROC [    window: Handle, box: Window.Box, gray: Brick ¬ fiftyPercent,    dstFunc: DstFunc ¬ null];      -- circles  Circle: PROC [    window: Handle, place: Window.Place, radius: INTEGER,     bounds: Window.BoxHandle ¬ NIL];    -- conics  Conic: PROC [    window: Handle, a, b, c, d, e, errorTerm: LONG INTEGER,     start, stop, errorRef: Window.Place,     sharpCornered, unboundedStart, unboundedStop: BOOLEAN,    bounds: Window.BoxHandle ¬ NIL];    -- ellipses  Ellipse: PROC [    window: Handle, center: Window.Place, xRadius, yRadius: INTEGER,     bounds: Window.BoxHandle ¬ NIL];    -- lines  Line: PROC [    window: Handle, start, stop: Window.Place, bounds: Window.BoxHandle ¬ NIL];    -- points  Point: PROC [window: Handle, point: Window.Place];        -- text  BreakReason: TYPE = {normal, margin, stop};  infinity: INTEGER = LAST[INTEGER];    Block: PROC [    window: Handle, block: Environment.Block, lineLength: INTEGER ¬ infinity,     place: Window.Place, font: WindowFont.Handle ¬ NIL,    flags: BitBltFlags ¬ textFlags, bounds: Window.BoxHandle ¬ NIL]    RETURNS [newPlace: Window.Place, positions: CARDINAL, why: BreakReason];      MeasureBlock: PROC [    window: Handle, block: Environment.Block, lineLength: INTEGER ¬ infinity,    place: Window.Place, font: WindowFont.Handle ¬ NIL]    RETURNS [newPlace: Window.Place, positions: CARDINAL, why: BreakReason];      ResolveBlock: PROC [    window: Handle, block: Environment.Block,    offsets: LONG POINTER TO ARRAY CARDINAL [0..0) OF CARDINAL,    font: WindowFont.Handle ¬ NIL]    RETURNS [positions: CARDINAL, why: BreakReason];      Character: PROC [    window: Handle, char: CHARACTER, place: Window.Place,    font: WindowFont.Handle ¬ NIL, flags: BitBltFlags ¬ textFlags,    bounds: Window.BoxHandle ¬ NIL]    RETURNS [Window.Place];    Text: PROC [    window: Handle, string: LONG STRING, place: Window.Place,    font: WindowFont.Handle ¬ NIL, lineLength: INTEGER ¬ infinity,     flags: BitBltFlags ¬ textFlags, bounds: Window.BoxHandle ¬ NIL]    RETURNS [newPlace: Window.Place];      TextInline: PROC [    window: Handle, string: LONG STRING, place: Window.Place,     font: WindowFont.Handle ¬ NIL, lineLength: INTEGER ¬ infinity,    flags: BitBltFlags ¬ textFlags, bounds: Window.BoxHandle ¬ NIL]    RETURNS [Window.Place] = INLINE {    RETURN[Block[      window, [LOOPHOLE[@string.text], 0, string.length], lineLength, place, font,      flags, bounds].newPlace]};      -- scrolling  Shift: PROC [window: Handle, box: Window.Box, newPlace: Window.Place];  -- This procedure does a bitblt-style move of part of the window  -- content.  It does not trigger a repaint if part of the source is  -- unavailable, but only sets things invalid.  It is the clients  -- responsibility to call ValidateWindows later.  -- Does not invalidate area that the bits came from.  -- Fast painting of brush type things  TrajectoryProc: TYPE = PROC [Handle] RETURNS [Window.Box, INTEGER];  Trajectory: PUBLIC PROC [    window: Handle, box: Window.Box ¬ Window.nullBox, proc: TrajectoryProc,    source: LONG POINTER ¬ NIL, bpl: CARDINAL ¬ 16, height: CARDINAL ¬ 16,    flags: BitBltFlags ¬ bitFlags, missesChildren: BOOLEAN ¬ FALSE,    brick: Brick ¬ NIL];  END.
-- File: Window.mesa - last edit by,-- PXK    ,	30-Sep-82 18:26:50  -- Ayers	March 27, 1980  5:48 PM  -- SXW   	May 27, 1980 5:55 PM  -- Mark		Jul 2, 1980 3:51 PM  -- JGS		14-Aug-81  8:33:54  -- BXM  	27-Sep-82 19:19:28-- AXD    	 1-Jul-83 15:52:59-- Copyright (C) Xerox Corporation 1982, 1983. All rights reserved.DIRECTORY  UserTerminal USING [Coordinate];Window: DEFINITIONS =  BEGIN  Place: TYPE = UserTerminal.Coordinate;  Dims: TYPE = RECORD [w, h: INTEGER];  -- CARDINALs create compiler complaints  Box: TYPE = RECORD [place: Place, dims: Dims];  BoxHandle: TYPE = LONG POINTER TO Box;  nullBox: Box = [[0, 0], [0, 0]];  Clarity: TYPE = {isClear, isDirty};  Gravity: TYPE = {nil, nw, n, ne, e, se, s, sw, w, c, xxx};  EnumerateInvalidBoxes: PROC [window: Handle, proc: PROC [Handle, Box]];    FreeBadPhosphorList: PROC [window: Handle];    InvalidateBox: PROC [window: Handle, box: Box, clarity: Clarity ¬ isDirty];  -- Sets the box to 'invalid' in the window manager's data structure.  -- Does not clear the box unless clarity = isDirty.  Does not trigger a repaint.  Validate: PROC [window: Handle];  -- Fixes up any invalid area in the window via repaint call(s).  ValidateTree: PROC [window: Handle ¬ rootWindow];  -- Fixes up any invalid area in the window subtree via repaint call(s).  rootWindow: READONLY Handle;  -- the root window is the screen background  Root: PROC RETURNS [Handle] = INLINE {RETURN[rootWindow]};  GetBox: PROC [Handle] RETURNS [Box];  GetParent: PROC [Handle] RETURNS [Handle];  GetSibling: PROC [Handle] RETURNS [Handle];  GetChild: PROC [Handle] RETURNS [Handle];  GetDisplayProc: PROC [Handle] RETURNS [PROC[Handle]];  GetClearingRequired: PROC [Handle] RETURNS [BOOLEAN];    IsDescendantOfRoot: PROC [Handle] RETURNS [BOOLEAN];  IsBitmapUnderVariant: PROC [Handle] RETURNS [BOOLEAN];  IsCookieVariant: PROC [Handle] RETURNS [BOOLEAN];    -- following 3 procedures may only be called if the window is not in the tree  SetParent: PROC [window, newParent: Handle] RETURNS [oldParent: Handle];  SetSibling: PROC [window, newSibling: Handle] RETURNS [oldSibling: Handle];  SetChild: PROC [window, newChild: Handle] RETURNS [oldChild: Handle];  SetDisplayProc: PROC [Handle, PROC[Handle]] RETURNS [PROC[Handle]];  SetClearingRequired: PROC [window: Handle, required: BOOLEAN]    RETURNS [old: BOOLEAN];    BitmapPlace: PROC [window: Handle, place: Place ¬ [0,0]] RETURNS [Place];    ObscuredBySibling: PROC [Handle] RETURNS [BOOLEAN];    Handle: TYPE = LONG POINTER TO Object;  Object: TYPE [19];  MinusLandCookieCutter: TYPE [2];  MinusLandBitmapUnder: TYPE [6];  IntersectBoxes: PROCEDURE [b1, b2: Box] RETURNS [box: Box];  IsPlaceInBox: PROCEDURE [place: Place, box: Box] RETURNS [BOOLEAN];    InitializeWindow: PROC [    window: Handle, display: PROC[Handle], box: Box,     parent: Handle ¬ rootWindow, sibling, child: Handle ¬ NIL,     clearingRequired: BOOLEAN ¬ TRUE, under, cookieCutter: BOOLEAN ¬ FALSE];  -- These parameters describe the following properties of the window:  -- box: to define the window's location and size  -- place: the windows place on the display  -- parent: to indicate where in the tree structure it belongs  -- sibling: to indicate the brother that this one is ahead of (NIL if on bottom)  -- child: to supply the subwindow tree, which must contain at least a root  -- display: the repaint procedure  -- under: to indicate the presence of "Minus Land" bitmapUnder info  -- cookieCutter: to indicate the presence of "Minus Land" cookie info  -- The root window must be defined before this procedure is called.        InsertIntoTree: PROC [window: Handle];  -- Adds the user supplied Window.Object to the chain of windows  -- The caller must have initialized the window object.  RemoveFromTree: PROC [Handle];  -- Removes the window from the window chain.  Any subtree 'below'  -- the window is still there.  EnumerateTree: PROC [root: Handle, proc: PROC [window: Handle]];  -- calls proc for each element in tree.  no order guarantee  WordsForBitmapUnder: PROC [window: Handle] RETURNS [CARDINAL];  UnderChangedProc: TYPE = PROC [Handle, Box];  MouseTransformerProc: TYPE = PROC [Handle, Place] RETURNS [Handle, Place];  GetBitmapUnder: PROC [window: Handle] RETURNS [LONG POINTER];  SetBitmapUnder: PROC [    window: Handle, pointer: LONG POINTER ¬ NIL,    underChanged: UnderChangedProc ¬ NIL,    mouseTransformer: MouseTransformerProc ¬ NIL] RETURNS [LONG POINTER];  -- Allows the user to specify a "bitmap under" for the window.  This causes  -- the NWP to  remember bits painted "under" this window in the user's  -- supplied memory.  It  allows for fast window undefinition.  Passing NIL  -- in undoes a previous call.  The allocation of an appropriate amount of  -- space is the caller's responsibility.  While the "bitmap under" is in  -- effect, the window's size cannot be changed.  [The "bitmap under" is  -- normally set at definition time.]  SlideIconically: PROC [window: Handle, newPlace: Place];  -- Changes the window's position and fixes up the display  -- Tries to act like a continuous move; assumes that calling  -- the displayProc is relatively cheap.  Float: PROC [    window, temp: Handle,    proc: PROC [window: Handle] RETURNS [place: Place, done: BOOLEAN]];  -- Changes the window's position and fixes up the display  -- Tries to act like a continuous move; cleverly utilizes temp.  Stack: PROC [window: Handle, newSibling: Handle, newParent: Handle ¬ NIL];  -- Changes the window's ontopness (relative to its siblings):  that is  -- rearranges the sibling chain the window's in.  And fixes up the display.  Slide: PROC [window: Handle, newPlace: Place];  -- Changes the window's position within its parent and fixes up the display.  -- Used for scrolling.  SlideAndStack: PROC [    window: Handle, newPlace: Place, newSibling: Handle, newParent: Handle ¬ NIL];  SlideAndSize: PROC [window: Handle, newBox: Box, gravity: Gravity ¬ nw];  SlideAndSizeAndStack: PROC [    window: Handle, newBox: Box, newSibling: Handle, newParent: Handle ¬ NIL,    gravity: Gravity ¬ nw];  BitmapPlaceToWindowAndPlace: PROC [bitmapPlace: Place]    RETURNS [window: Handle, place: Place];  BoxesAreDisjoint: PROC [a, b: Box] RETURNS [BOOLEAN];  TrimBoxStickouts: PROC [window: Handle, box: Box] RETURNS [Box];  -- if the box sticks out of the window, or, effectively, any  -- of its ancestor windows, adjusts the box to exclude the 'stickout'  -- errors  ErrorCode: TYPE = {    illegalBitmap, illegalFloat, windowNotChildOfParent, whosSlidingRoot,    noSuchSibling, noUnderVariant, windowInTree, sizingWithBitmapUnder,    illegalStack};  Error: ERROR [code: ErrorCode];    END.
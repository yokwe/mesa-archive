-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. -- File: MFileImplE.mesa - last edited by-- LXR    ,	12-Jan-84 14:17:48DIRECTORY  MFile USING [    Access],  MFileOps USING [    FHandle, fHandleLock, fHandles, heap, PleaseReleaseRemoteFO, ReleaseObject,    UnmapLeader],  NotifyOps USING [Notification, WHandle, WNotification],  RFile USING [Handle],  SpecialMFile USING [],  String USING [AppendString, EquivalentString];MFileImplE: MONITOR LOCKS MFileOps.fHandleLock -- locks the fhandles list  IMPORTS    MFileOps, String  EXPORTS MFileOps, NotifyOps =  BEGIN  BearTrap: ERROR = CODE;  FHandle: TYPE = MFileOps.FHandle;  notifyCondition: CONDITION;  notifyList: PUBLIC FHandle ¬ NIL;  writeableList: NotifyOps.WHandle ¬ NIL;  ImplementationError: ERROR [what: LONG STRING] = CODE;  GetNextNotification: PUBLIC ENTRY PROCEDURE RETURNS [f: NotifyOps.Notification] = {    ENABLE UNWIND => NULL;    WHILE notifyList = NIL AND writeableList = NIL DO      WAIT notifyCondition ENDLOOP;    IF notifyList # NIL THEN {      f ¬ [normal[notifyList]];      notifyList.refCount ¬ notifyList.refCount + 1;      notifyList.copy ¬ notifyList.notifyAccess;      notifyList.notifyAccess ¬ ALL[FALSE]}    ELSE      IF writeableList # NIL THEN {        f ¬ [writeable[writeableList]]; writeableList ¬ writeableList.next}};  AddToNotificationList: PUBLIC ENTRY PROCEDURE [    fo: FHandle, access: MFile.Access] = {      AddToNotificationListInternal[fo, access ! UNWIND => NULL]};      AddToNotificationListInternal: PUBLIC INTERNAL PROCEDURE [    fo: FHandle, access: MFile.Access] = {    prev: FHandle ¬ NIL;    IF access = null THEN BearTrap;    fo.notifyAccess[access] ¬ TRUE;    FOR f: FHandle ¬ notifyList, f.notifyList UNTIL f = NIL DO      IF f = fo THEN RETURN; prev ¬ f; ENDLOOP;    fo.notifyList ¬ NIL;    IF prev = NIL THEN notifyList ¬ fo ELSE prev.notifyList ¬ fo;    NOTIFY notifyCondition};  AddToWriteableList: PUBLIC INTERNAL PROCEDURE [name: LONG STRING] = {    s: LONG STRING;    w: NotifyOps.WHandle;    FOR f: NotifyOps.WHandle ¬ writeableList, f.next UNTIL f = NIL DO      IF String.EquivalentString[name, f.name] THEN RETURN; ENDLOOP;    s ¬ MFileOps.heap.NEW[StringBody [name.length]];    w ¬ MFileOps.heap.NEW[NotifyOps.WNotification ¬ [next: writeableList, name: s]];    writeableList ¬ w;    String.AppendString[from: name, to: writeableList.name];    NOTIFY notifyCondition};  ReleaseRemoteFile: PUBLIC PROCEDURE [h: RFile.Handle] RETURNS [released: BOOLEAN ¬ FALSE] =     BEGIN    fo: FHandle ¬ FindRemoteFO[h]; -- adds to refCount to hold on to fo     IF fo = NIL THEN RETURN[FALSE]; -- no such object?????    released ¬ MFileOps.PleaseReleaseRemoteFO[fo];    IF released THEN FreeRemoteFO[fo] -- caller must Release h    ELSE  MFileOps.ReleaseObject[fo, null, FALSE]; -- decrement fo refCount    END;  FindRemoteFO: ENTRY PROCEDURE [h: RFile.Handle] RETURNS [FHandle] =     BEGIN    FOR fo: MFileOps.FHandle ¬ MFileOps.fHandles, fo.next UNTIL fo = NIL DO      WITH a:fo.location SELECT FROM         local => LOOP;        remote => IF a.h = h THEN {fo.refCount ¬ fo.refCount + 1; RETURN[fo]};        ENDCASE;      ENDLOOP;    RETURN[NIL];    END;  FreeRemoteFO: ENTRY PROCEDURE [fo: FHandle] =     BEGIN    --assert fo.refCount = 1, which was set by ReleaseRemoteFile    IF fo.refCount # 1 THEN ERROR ImplementationError["Remote file object not free"L];    MFileOps.UnmapLeader[fo.lp];    IF MFileOps.fHandles = fo THEN MFileOps.fHandles ¬ fo.next    ELSE {      prev: FHandle ¬ MFileOps.fHandles;      FOR t: FHandle ¬ prev.next, t.next UNTIL t = NIL DO        IF t = fo THEN {prev.next ¬ t.next; EXIT};        prev ¬ t;        REPEAT FINISHED => ERROR ImplementationError["Handle not in freeList"L];        ENDLOOP};    MFileOps.heap.FREE[@fo];    END;  END.
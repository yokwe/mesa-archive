-- Copyright (C) 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- File: MDirectory.mesa - edited by-- LXR    ,	13-May-83 13:44:22-- PXK    ,	 5-Feb-82 18:48:04-- KAM  ,	22-Jul-84 18:09:54DIRECTORY  BTree USING [Tree, Value],  MFile USING [EnumerationType, EnumRec, EnumerateState, SearchPath],  MFileOps USING [DirInfo, LeaderPage, RootFile],  File USING [File, ID, nullFile, nullID],  Volume USING [ID];MDirectory: DEFINITIONS =  BEGIN  -- Types  LeaderPage: TYPE = MFileOps.LeaderPage;  EnumerateState: TYPE = MFile.EnumerateState;  EnumRec: TYPE = MFile.EnumRec;  DirInfo: TYPE = MFileOps.DirInfo;    MValueRec: TYPE = MACHINE DEPENDENT RECORD [    fID: File.ID ¬ File.nullID, dirInfo: DirInfo ¬ []];  MValue: TYPE = LONG POINTER TO MValueRec;  nullMValueRec: MValueRec = [    fID: File.nullID,    dirInfo: DirInfo[    type: unknown, deleteProtect: FALSE, readProtect: FALSE,    writeProtect: FALSE]];  nullMValue: MValue;  nullValue: BTree.Value;  -- Type conversion  MValueToValue: PROCEDURE [v: MValue] RETURNS [BTree.Value] = INLINE {    RETURN[DESCRIPTOR[v, SIZE[MValueRec], CARDINAL]]};  ValueToMValue: PROCEDURE [v: BTree.Value] RETURNS [MValue] = INLINE {    RETURN[LOOPHOLE[BASE[v]]]};  -- Search Path Procedures  DirSetSearchPath: PROCEDURE [MFile.SearchPath]    RETURNS [succeeded: BOOLEAN ¬ TRUE];  DirGetSearchPath: PROCEDURE RETURNS [MFile.SearchPath];  DirFreeSearchPath: PROCEDURE [MFile.SearchPath];  -- Errors  ActivityDuringWorldSwap: ERROR;  NoRootDir: SIGNAL;  DirError: SIGNAL [type: ErrorCode];  CantFindPath: SIGNAL [name: LONG STRING];  ErrorCode: TYPE = {    directoryNotEmpty, directoryFull, deletingDirectoryOnSearchPath,    fileAlreadyExists, fileIsSD, fileNotFound, fileNotSD, invalidFileName,    invalidPathName, invalidSearchPath, noRoomOnVolume, invalidVolume,    readOnlyDirectory, volumeNotOpen, noRootDirectory, protectedDirectory,     crossingVolumes, unknown};  -- Directory Procedures  -- fileName may be completely qualified or may be evaluated in the current search path  -- oldName, and newName must contain no directory information  -- newDirectory will be evaluated in the current search path if necessary  DirCreateDirectory: PROCEDURE [path: LONG STRING] RETURNS [dir: File.File];  DirDelete: PROCEDURE [file: File.File, lp: LeaderPage];  GetNext: PROCEDURE [    filter, name: LONG STRING, which: MFile.EnumerationType,    lastState: EnumerateState, stopNow: BOOLEAN ¬ FALSE]    RETURNS [      state: EnumerateState, file: File.File, dirInfo: DirInfo,      fullName: LONG STRING, spIndex: CARDINAL];  IsValid: PROCEDURE [file: File.ID, state: EnumerateState] RETURNS [ok: BOOLEAN];  Insert: PROCEDURE [    fileName: LONG STRING, initialSize: LONG CARDINAL, dirInfo: DirInfo]    RETURNS [id: File.ID, dir: File.File];  LookUp: PROCEDURE [fileName: LONG STRING, skipProtectedDirs: BOOLEAN]    RETURNS [      file: File.ID, dir: File.File, dirInfo: DirInfo, protectedDir: BOOLEAN];  DirRename: PROCEDURE [    oldName, newName: LONG STRING, file: File.ID, dir: File.File]    RETURNS [newDir: File.File ¬ File.nullFile];  Swap: PROCEDURE [name1, name2: LONG STRING, file1, file2: File.ID, dir1, dir2: File.File];  SetID: PROCEDURE [name: LONG STRING, newFile: File.ID, dir: File.File];  -- protection bits  DirGetInfo: PROCEDURE [dir: File.File, name: LONG STRING]    RETURNS [dirInfo: DirInfo];  DirSetDeleteProtect: PROCEDURE [    dir: File.File, name: LONG STRING, deleteProtected: BOOLEAN];  DirSetWriteProtect: PROCEDURE [    dir: File.File, name: LONG STRING, writeProtected: BOOLEAN];  DirSetReadProtect: PROCEDURE [    dir: File.File, name: LONG STRING, readProtected: BOOLEAN];  DirSetDirProtect: PROCEDURE [    dir: File.File, name: LONG STRING, dirProtected: BOOLEAN];  SetDirInfo: PROCEDURE [dir: File.File, name: LONG STRING, dirInfo: DirInfo];  -- for the scavenger  CreateSubDir: PROCEDURE [    dir: BTree.Tree, name: LONG STRING, dirID: File.File]    RETURNS [newDir: File.ID ¬ File.nullID];  LookupRootDir: PROCEDURE [volume: Volume.ID, name: LONG STRING ¬ NIL]    RETURNS [rootDir: File.File ¬ File.nullFile];  GetValue: PROCEDURE [dir: BTree.Tree, name: LONG STRING] RETURNS [MValueRec];  InsertInTree: PROCEDURE [dir: BTree.Tree, name: LONG STRING, file: File.ID]    RETURNS [succeeded: BOOLEAN];  MakeEmptyDir: PROCEDURE [file: File.File];  SetDirInfoInTree: PROCEDURE [    dir: BTree.Tree, name: LONG STRING, dirInfo: DirInfo];  -- btree cache  GetTree: PROCEDURE [dir: File.File] RETURNS [tree: BTree.Tree];  FreeTree: PROCEDURE [tree: BTree.Tree];  IsProtected: PROCEDURE [dir: File.File] RETURNS [BOOLEAN];  MapCacheEntry: PROCEDURE [tree: BTree.Tree];  UpdateDirCache: PROCEDURE [dir: File.File, protect: BOOLEAN];    -- root file stuff  -- AccessRootFile and NeedsMScavenging lock MDirectory.lock    MarkChanging, MarkChanged: PROCEDURE [volume: Volume.ID];    AccessRootFile: PROCEDURE [    volume: Volume.ID, proc: PROC [root: MFileOps.RootFile]];    -- Can be raised by MarkChanging, MarkChanged or AccessRootFile  NoRootFile: SIGNAL;    NeedsMScavenging: PROCEDURE [volume: Volume.ID] RETURNS [scavenge: BOOLEAN];  -- search path info  SearchPathFileObject: TYPE = RECORD [    directories: SEQUENCE length: CARDINAL OF File.File];  SearchPathFile: TYPE = LONG POINTER TO SearchPathFileObject;  SearchPathBTreeObject: TYPE = RECORD [    directories: SEQUENCE length: CARDINAL OF BTree.Tree];  SearchPathBTree: TYPE = LONG POINTER TO SearchPathBTreeObject;  searchPathNames: MFile.SearchPath;  searchPathFile: SearchPathFile;  searchPathBTree: SearchPathBTree;  FindFirstWriteable: PROCEDURE RETURNS [dir: File.File];    -- utilities  lock: MONITORLOCK;  directoryZone: READONLY UNCOUNTED ZONE;  extraCacheSlots: CARDINAL = 3;  CopyStr: PROCEDURE [s: LONG STRING] RETURNS [LONG STRING];  CreateNewSubdirectory: PROCEDURE [    dir: File.File, name: LONG STRING]    RETURNS [newDir: File.File];  EvalInDir: PROCEDURE [dir: File.File, proc: PROCEDURE [bTree: BTree.Tree]];  InternalCreateSubDir: PROCEDURE [    dir: BTree.Tree, name: LONG STRING, dirID: File.File]    RETURNS [newDir: File.File];  InternalLookupRootDir: PROCEDURE [volume: Volume.ID, name: LONG STRING ¬ NIL]    RETURNS [rootDir: File.File];  IsFilename: PROCEDURE [LONG STRING] RETURNS [BOOLEAN];  LegalName: PROCEDURE [LONG STRING];  LookUpDirectory: PROCEDURE [path: LONG STRING, createIfMissing: BOOLEAN]    RETURNS [dir: File.File];  SearchDirTree: PROCEDURE [    name: LONG STRING, startDir: File.File, createIfMissing: BOOLEAN]    RETURNS [dir: File.File];  SetMinCacheSize: PROCEDURE [CARDINAL];  SplitName: PROCEDURE [path: LONG STRING] RETURNS [name, pathName: LONG STRING];  ValidateFile: PROCEDURE [file: File.File] RETURNS [ok: BOOLEAN];  StartMDirectoryImplA: PROCEDURE;  StartMDirectoryImplB: PROCEDURE;  END.. of MDirectory
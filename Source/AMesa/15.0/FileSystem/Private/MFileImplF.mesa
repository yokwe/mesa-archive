-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- File: MFileImplF.mesa - last edited by-- LXR    ,	27-Dec-83 11:11:12DIRECTORY  MFile USING [    Access, Error, Filter, maxNameLength, ReleaseData],  MFileOps USING [    FHandle, GetName, Handle, heap, IncrRefCount, LeaderPage, Object,     ReleaseObject],  NotifyOps USING [    AccessStatus, AddToNotificationList, Compatibility,    GetProtectionStatus, LockedGetReleaseData, SetTimesGivenAccess],  String USING [EquivalentString],  Volume USING [GetStatus, Status, systemID];MFileImplF: MONITOR LOCKS fo.chainLock USING fo: MFileOps.FHandle   IMPORTS MFile, MFileOps, NotifyOps, String, Volume  EXPORTS MFile, MFileOps, NotifyOps =  BEGIN  ImplementationError: ERROR [what: LONG STRING] = CODE;  Handle: TYPE = MFileOps.Handle;  Object: PUBLIC TYPE = MFileOps.Object;  FHandle: TYPE = MFileOps.FHandle;  EnumerateFreeList: PUBLIC ENTRY PROCEDURE [       fo: FHandle, proc: PROCEDURE [Handle] RETURNS [BOOLEAN]]    RETURNS [file: Handle] =    BEGIN    FOR file ¬ fo.freeList, file.next UNTIL file = NIL DO      IF proc[file] THEN EXIT;      ENDLOOP;    END;   AddHandle: PUBLIC ENTRY PROCEDURE [    fo: FHandle, access: MFile.Access, release: MFile.ReleaseData,    protectedSP: BOOLEAN ¬ FALSE, checkAccess: BOOLEAN ¬ TRUE,     ignoreConflict: Handle ¬ NIL]    RETURNS [status: NotifyOps.AccessStatus ¬ good, file: Handle ¬ NIL] = {    ENABLE UNWIND => NULL;    IF checkAccess THEN {      status ¬ CheckNewAccess[fo, ignoreConflict, access];      IF status # good THEN RETURN[status, NIL]};    file ¬ MFileOps.heap.NEW[      MFileOps.Object ¬ [      fo: fo, next: fo.freeList, release: release, access: access,      protectedSP: protectedSP,      length:      IF access = readOnly THEN fo.readLengthForLog ELSE fo.lp.fp.length]];    fo.freeList ¬ file;    MFileOps.IncrRefCount[fo];    IF access = log THEN file.fo.readLengthForLog ¬ 0};        CheckNewAccess: INTERNAL PROCEDURE [    fo: FHandle, ignore: Handle, access: MFile.Access]    RETURNS [status: NotifyOps.AccessStatus] = {    lp: MFileOps.LeaderPage = fo.lp;    status ¬ NotifyOps.GetProtectionStatus[fo, access];    IF status # good THEN RETURN[status];    WITH fo.location SELECT FROM      local => IF f.volumeID # Volume.systemID AND                  Volume.GetStatus[f.volumeID] # openReadWrite THEN                   status ¬ SELECT access FROM                      anchor, readOnly, null => good,                      readWrite, writeOnly, log, delete, rename => conflicting,                      ENDCASE => conflicting;      ENDCASE;    IF status # good THEN RETURN[status];    RETURN[CheckHandles[fo, ignore, access]]};		  ConflictingAccess: PUBLIC PROCEDURE [somebodyHas, thisGuyWants: MFile.Access]    RETURNS [NotifyOps.Compatibility] = {    Access: TYPE = MFile.Access;    compatibility: ARRAY Access OF PACKED ARRAY Access OF NotifyOps.Compatibility = [      anchor: [      anchor: ok, readOnly: ok, readWrite: ok, writeOnly: ok, log: ok,      delete: nope, rename: nope, null: nope],      readOnly: [      anchor: ok, readOnly: ok, readWrite: nope, writeOnly: nope, log: nope,      delete: nope, rename: nope, null: nope],      readWrite: [      anchor: ok, readOnly: nope, readWrite: nope, writeOnly: nope, log: nope,      delete: nope, rename: nope, null: nope],      writeOnly: [      anchor: ok, readOnly: nope, readWrite: nope, writeOnly: nope, log: nope,      delete: nope, rename: nope, null: nope],      log: [      anchor: ok, readOnly: pokeOnce, readWrite: nope, writeOnly: nope, log: nope,      delete: nope, rename: nope, null: nope],      delete: [      anchor: nope, readOnly: nope, readWrite: nope, writeOnly: nope, log: nope,      delete: nope, rename: nope, null: nope],      rename: [      anchor: nope, readOnly: nope, readWrite: nope, writeOnly: nope, log: nope,      delete: nope, rename: nope, null: nope],      null: [      anchor: ok, readOnly: ok, readWrite: ok, writeOnly: ok, log: ok, delete: ok,      rename: ok, null: nope]];    RETURN[compatibility[somebodyHas][thisGuyWants]]};       Conflicts: PUBLIC ENTRY PROCEDURE [    fo: FHandle, filter: MFile.Filter, ignore: Handle]    RETURNS [BOOLEAN] = {    ENABLE UNWIND => NULL;    FOR f: Handle ¬ fo.freeList, f.next UNTIL f = NIL DO      IF f = ignore THEN LOOP;      IF ConflictingAccess[f.access, filter.access] = nope THEN RETURN[TRUE];      ENDLOOP;    RETURN[FALSE]};  LockedSetAccess: PUBLIC ENTRY PROCEDURE [fo: FHandle, file: Handle, access: MFile.Access] = {    ENABLE UNWIND => NULL;    oldAccess: MFile.Access = file.access;    name: STRING = [MFile.maxNameLength];    tempFile: Handle ¬ NIL;    status: NotifyOps.AccessStatus;    status ¬ CheckNewAccess[fo, file, access];    DO      SELECT status FROM        retry => LOOP;        protected => RETURN WITH ERROR MFile.Error[file, protectionFault];        conflicting => RETURN WITH ERROR MFile.Error[file, conflictingAccess];        ENDCASE => EXIT;      ENDLOOP;    IF file.access = log THEN fo.readLengthForLog ¬ fo.lp.fp.length;    IF access = readOnly THEN file.length ¬ file.fo.readLengthForLog;    file.access ¬ access;    WITH file.fo.location SELECT FROM      local => IF f.volumeID = Volume.systemID OR                  Volume.GetStatus[f.volumeID] = openReadWrite THEN                    NotifyOps.SetTimesGivenAccess[file.fo, file.fo.lp, access];     ENDCASE;    NotifyOps.AddToNotificationList[fo, oldAccess];    };         TakeHandleOffList: PUBLIC ENTRY PROCEDURE [    fo: FHandle, file: Handle, doNotification: BOOLEAN] = {    ENABLE UNWIND => NULL; TakeHandleOffListInternal[fo, file, doNotification]};  TakeHandleOffListInternal: INTERNAL PROCEDURE [    fo: FHandle, file: Handle, doNotification: BOOLEAN ¬ TRUE] = {    access: MFile.Access = file.access;    IF fo.freeList = file THEN fo.freeList ¬ file.next    ELSE {      prev: Handle ¬ fo.freeList;      FOR t: Handle ¬ prev.next, t.next UNTIL t = NIL DO        IF t = file THEN {prev.next ¬ t.next; EXIT};        prev ¬ t;        REPEAT FINISHED => ERROR ImplementationError["Handle not in freeList"L];        ENDLOOP};    BROADCAST fo.condition;    SELECT access FROM       log => IF ~fo.fileIsDeleted THEN fo.readLengthForLog ¬ fo.lp.fp.length;      ENDCASE;    file.password ¬ 0;    MFileOps.heap.FREE[@file];    MFileOps.ReleaseObject[fo, access, doNotification]};   WaitForRelease: INTERNAL PROCEDURE [    file: Handle, fo: FHandle, name: LONG STRING]    RETURNS [why: NotifyOps.AccessStatus] = {    currentName: LONG STRING ¬ [MFile.maxNameLength];    DO      WAIT fo.condition;      IF ~VolumeOpen[fo] OR fo.fileIsDeleted THEN RETURN[retry];      MFileOps.GetName[fo.lp, currentName];      IF ~String.EquivalentString[name, currentName] THEN {        MFileOps.heap.FREE[@name]; why ¬ retry; RETURN};      FOR f: Handle ¬ fo.freeList, f.next UNTIL f = NIL DO        IF f = file THEN EXIT;        REPEAT FINISHED => {MFileOps.heap.FREE[@name]; why ¬ good; RETURN};        ENDLOOP;      ENDLOOP};	  CheckHandles: INTERNAL PROCEDURE [    fo: FHandle, ignore: Handle, access: MFile.Access]     RETURNS [status: NotifyOps.AccessStatus] =    BEGIN    release: MFile.ReleaseData;    DO      FOR f: Handle ¬ fo.freeList, f.next UNTIL f = NIL DO        release ¬ NotifyOps.LockedGetReleaseData[f];	IF f = ignore THEN LOOP;        SELECT ConflictingAccess[f.access, access] FROM          pokeOnce =>            IF release.proc # NIL THEN              SELECT release.proc[f, release.clientInstanceData] FROM                goAhead => TakeHandleOffListInternal[fo, f];                ENDCASE;          nope =>            IF release.proc = NIL THEN RETURN[conflicting]            ELSE              SELECT release.proc[f, release.clientInstanceData] FROM                later => {                  name: LONG STRING ¬ MFileOps.heap.NEW[StringBody [MFile.maxNameLength]];                  MFileOps.GetName[fo.lp, name];                  IF WaitForRelease[f, fo, name] = good THEN GO TO oneMoreTime                  ELSE RETURN[retry]};                goAhead => TakeHandleOffListInternal[fo, f];                allowRename => IF access # rename THEN RETURN[conflicting];                no => RETURN[conflicting];                ENDCASE;          ENDCASE;        REPEAT oneMoreTime => NULL; FINISHED => GOTO allDone;        ENDLOOP;      REPEAT allDone => NULL;      ENDLOOP;    RETURN[good];    END;    PleaseReleaseRemoteFO: PUBLIC ENTRY PROCEDURE [fo: FHandle] RETURNS [released: BOOLEAN] =    BEGIN    RETURN[CheckHandles[fo, NIL, delete] = good];       -- delete access forces all handles off    END;    VolumeOpen: PROCEDURE [fo: FHandle] RETURNS [BOOLEAN] =    BEGIN    WITH fo.location SELECT FROM      local => {        IF f.volumeID = Volume.systemID THEN RETURN[TRUE];        SELECT Volume.GetStatus[f.volumeID] FROM	  openReadWrite, openRead  => RETURN[TRUE];	  ENDCASE => RETURN[FALSE]};      ENDCASE => RETURN[TRUE];    END;      END.
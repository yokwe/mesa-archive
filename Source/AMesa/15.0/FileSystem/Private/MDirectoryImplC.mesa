-- Copyright (C) 1981, 1982, 1983, 1984, 1988  by Xerox Corporation. All rights reserved. -- File: MDirectoryImplC.mesa - last edit -- PXK    ,	10-Feb-82 13:09:43-- LXR    ,	 5-Dec-83  9:51:20-- RXJ     ,	26-Nov-81 11:34:23-- DWE    ,	 4-Aug-83 15:24:58-- KAM  ,	27-Jul-84 16:34:26-- RLC          25-Feb-88 13:33:53-- RSV           4-Mar-88 10:15:45   DIRECTORY  BTree USING [    Delete, Find, Insert, maxNameLength, ReadOnly, SwapValue,    Tree, Value, VolumeNotOpen],  Environment USING [PageCount, wordsPerPage],  Event USING [],  File USING [    Create, Delete, File, GetAttributes, ID, MakePermanent, nullFile, nullID,    Type, Unknown],  Heap USING [Create],  MDirectory USING [    CantFindPath, CopyStr, directoryZone, DirError, DirInfo, ErrorCode,    extraCacheSlots, FreeTree, GetTree, InternalCreateSubDir,    IsFilename,     LegalName, MapCacheEntry, MValue, MValueRec, MValueToValue, NoRootDir,    nullMValueRec, SearchDirTree, searchPathBTree, SearchPathBTreeObject,    SearchPathFileObject, searchPathFile, searchPathNames, SetMinCacheSize,    SplitName, StartMDirectoryImplA, StartMDirectoryImplB,    UpdateDirCache],  MFile USING [maxNameLength, SearchPath, SearchPathObject, Type],  MesaDEFileTypes USING [tRootDirectory],  MesaDEFileTypesExtra USING [tRootFile],  MFileOps USING [    InitLeader, InvalidLeader, LeaderPage, leaderPages, MapLeader,    RootFile, RootFileObject, UnmapLeader],  MScavenge USING [NeedsMScavenging, Scavenge, StartingScavenge],  MUsage USING [mFileDirectory],  Space USING [Access, Allocate, MapAt, UnmapAt, ForceOut, GetMapUnitAttributes],  SpecialBTree USING [GetSpecialInfo, MakeFromCapa, Unmapped],  String USING [AppendChar, AppendString, EmptyString],  Supervisor USING [CreateSubsystem, SubsystemHandle],  System USING [switches],  Volume USING [    GetAttributes, GetLabelString, ID, InsertRootFile, InsufficientSpace,    LookUpRootFile, maxNameLength, NotOpen, ReadOnly, RemoveRootFile,    RootDirectoryError, systemID];MDirectoryImplC: MONITOR LOCKS lock  IMPORTS    BTree, File, Heap, MDirectory, MFileOps, MScavenge,    Space, SpecialBTree, String, Supervisor, System, Volume  EXPORTS Event, MDirectory, MFile =  BEGIN  ASSERT: BOOLEAN [TRUE..TRUE] = (MFile.maxNameLength = BTree.maxNameLength);  debugging: BOOLEAN ¬ FALSE;  directoryZone: PUBLIC UNCOUNTED ZONE;  Tree: TYPE = BTree.Tree;  fileSystem: PUBLIC Supervisor.SubsystemHandle;    -- Types  ProtectBit: TYPE = {read, write, delete, dir};    -- Search Path Procedures  lock: PUBLIC MONITORLOCK;  noSearchPath: CARDINAL = LAST[CARDINAL];  initSearchPath: MFile.SearchPath ¬ NIL;    DirSetSearchPath: PUBLIC ENTRY PROCEDURE [sp: MFile.SearchPath]    RETURNS [succeeded: BOOLEAN ¬ TRUE] =    BEGIN OPEN MDirectory;    ENABLE {      SpecialBTree.Unmapped => {MDirectory.MapCacheEntry[tree]; RESUME };      BTree.ReadOnly => ERROR MDirectory.DirError[readOnlyDirectory];      BTree.VolumeNotOpen => ERROR MDirectory.DirError[volumeNotOpen];      UNWIND => NULL};    i: CARDINAL;    IF sp = NIL THEN MDirectory.DirError[invalidSearchPath];    FOR i IN [0..sp.length) DO      IF String.EmptyString[sp[i]] OR sp[i][0] # '< THEN       MDirectory.DirError[invalidSearchPath];       ENDLOOP;    IF searchPathNames # NIL THEN FreeSP[searchPathNames.length + 1];    searchPathNames ¬ directoryZone.NEW[MFile.SearchPathObject[sp.length]];    searchPathFile ¬ directoryZone.NEW[      MDirectory.SearchPathFileObject[sp.length]];    searchPathBTree ¬ directoryZone.NEW[      MDirectory.SearchPathBTreeObject[sp.length]];    searchPathNames.length ¬ sp.length;    FOR i IN [0..sp.length) DO      ENABLE UNWIND => FreeSP[i];      s: LONG STRING;      searchPathFile[i] ¬ SearchDirTree[        sp[i], File.nullFile, FALSE !        CantFindPath => MDirectory.DirError[fileNotFound]];      searchPathBTree[i] ¬ GetTree[searchPathFile[i]];      searchPathNames[i] ¬ CopyStr[sp[i]        ! UNWIND => FreeTree[searchPathBTree[i]]];      s ¬ searchPathNames[i];      IF s[s.length - 1] = '> THEN        FOR j: CARDINAL IN [0..s.length - 1) DO          IF s[j] = '> THEN {s.length ¬ s.length - 1; EXIT}; ENDLOOP;      ENDLOOP;    SetMinCacheSize[sp.length + extraCacheSlots];    END;  DirGetSearchPath: PUBLIC ENTRY PROCEDURE RETURNS [sp: MFile.SearchPath] =    BEGIN OPEN MDirectory;    ENABLE {      SpecialBTree.Unmapped => {MDirectory.MapCacheEntry[tree]; RESUME };      BTree.ReadOnly => ERROR MDirectory.DirError[readOnlyDirectory];      BTree.VolumeNotOpen => ERROR MDirectory.DirError[volumeNotOpen];      UNWIND => NULL};    IF searchPathNames = NIL THEN RETURN[NIL];    sp ¬ directoryZone.NEW[MFile.SearchPathObject[searchPathNames.length]];    FOR i: CARDINAL IN [0..searchPathNames.length) DO      sp[i] ¬ CopyStr[searchPathNames[i]];      ENDLOOP;    sp.length ¬ searchPathNames.length;    END;  DirFreeSearchPath: PUBLIC ENTRY PROCEDURE [sp: MFile.SearchPath] =    BEGIN OPEN MDirectory;    ENABLE {      SpecialBTree.Unmapped => {MDirectory.MapCacheEntry[tree]; RESUME };      BTree.ReadOnly => ERROR MDirectory.DirError[readOnlyDirectory];      BTree.VolumeNotOpen => ERROR MDirectory.DirError[volumeNotOpen];      UNWIND => NULL};    FOR i: CARDINAL IN [0..sp.length) DO directoryZone.FREE[@sp[i]]; ENDLOOP;    directoryZone.FREE[@sp];    END;  SetID: PUBLIC ENTRY PROCEDURE [    name: LONG STRING, newFile: File.ID, dir: File.File] =    BEGIN OPEN MDirectory;    ENABLE {      SpecialBTree.Unmapped => {MDirectory.MapCacheEntry[tree]; RESUME };      BTree.ReadOnly => ERROR MDirectory.DirError[readOnlyDirectory];      BTree.VolumeNotOpen => ERROR MDirectory.DirError[volumeNotOpen];      UNWIND => NULL};    rec: MDirectory.MValueRec;    value: BTree.Value = MDirectory.MValueToValue[@rec];    tree: Tree;    fileName, pathName: LONG STRING ¬ NIL;    LegalName[name];    [fileName, pathName] ¬ MDirectory.SplitName[name];    BEGIN    ENABLE UNWIND => MDirectory.directoryZone.FREE[@fileName];    MDirectory.directoryZone.FREE[@pathName];    tree ¬ GetTree[dir];    BEGIN    ENABLE UNWIND => FreeTree[tree];    IF ~BTree.Find[tree, fileName, value] THEN MDirectory.DirError[fileNotFound];    rec.fID ¬ newFile;    [] ¬ BTree.SwapValue[      tree: tree, name: fileName, newValue: value, oldValue: NIL];    END;    FreeTree[tree];    END;    MDirectory.directoryZone.FREE[@fileName];    END;  DirGetInfo: PUBLIC ENTRY PROCEDURE [dir: File.File, name: LONG STRING]    RETURNS [dirInfo: MDirectory.DirInfo] =    BEGIN OPEN MDirectory;    ENABLE {      SpecialBTree.Unmapped => {MDirectory.MapCacheEntry[tree]; RESUME };      BTree.ReadOnly => ERROR MDirectory.DirError[readOnlyDirectory];      BTree.VolumeNotOpen => ERROR MDirectory.DirError[volumeNotOpen];      UNWIND => NULL};    rec: MDirectory.MValueRec;    value: BTree.Value = MDirectory.MValueToValue[@rec];    tree: Tree;    LegalName[name];    tree ¬ GetTree[dir];    BEGIN    ENABLE UNWIND => FreeTree[tree];    IF ~BTree.Find[tree, name, value] THEN MDirectory.DirError[fileNotFound];    dirInfo ¬ rec.dirInfo;    END;    FreeTree[tree];    END;  DirSetDeleteProtect: PUBLIC ENTRY PROCEDURE [    dir: File.File, name: LONG STRING, deleteProtected: BOOLEAN] = {    ENABLE {      SpecialBTree.Unmapped => {MDirectory.MapCacheEntry[tree]; RESUME };      BTree.ReadOnly => ERROR MDirectory.DirError[readOnlyDirectory];      BTree.VolumeNotOpen => ERROR MDirectory.DirError[volumeNotOpen];      UNWIND => NULL};    MDirectory.LegalName[name];    SetProtectBit[dir, name, delete, deleteProtected]};  DirSetWriteProtect: PUBLIC ENTRY PROCEDURE [    dir: File.File, name: LONG STRING, writeProtected: BOOLEAN] = {    ENABLE {      SpecialBTree.Unmapped => {MDirectory.MapCacheEntry[tree]; RESUME };      BTree.ReadOnly => ERROR MDirectory.DirError[readOnlyDirectory];      BTree.VolumeNotOpen => ERROR MDirectory.DirError[volumeNotOpen];      UNWIND => NULL};    MDirectory.LegalName[name];    SetProtectBit[dir, name, write, writeProtected]};  DirSetReadProtect: PUBLIC ENTRY PROCEDURE [    dir: File.File, name: LONG STRING, readProtected: BOOLEAN] = {    ENABLE {      SpecialBTree.Unmapped => {MDirectory.MapCacheEntry[tree]; RESUME };      BTree.ReadOnly => ERROR MDirectory.DirError[readOnlyDirectory];      BTree.VolumeNotOpen => ERROR MDirectory.DirError[volumeNotOpen];      UNWIND => NULL};    MDirectory.LegalName[name];    SetProtectBit[dir, name, read, readProtected]};  DirSetDirProtect: PUBLIC ENTRY PROCEDURE [    dir: File.File, name: LONG STRING, dirProtected: BOOLEAN] = {    ENABLE {      SpecialBTree.Unmapped => {MDirectory.MapCacheEntry[tree]; RESUME };      BTree.ReadOnly => ERROR MDirectory.DirError[readOnlyDirectory];      BTree.VolumeNotOpen => ERROR MDirectory.DirError[volumeNotOpen];      UNWIND => NULL};    MDirectory.LegalName[name];    SetProtectBit[dir, name, dir, dirProtected]};  SetDirInfo: PUBLIC ENTRY PROCEDURE [    dir: File.File, name: LONG STRING, dirInfo: MDirectory.DirInfo] =    BEGIN OPEN MDirectory;    ENABLE {      SpecialBTree.Unmapped => {MDirectory.MapCacheEntry[tree]; RESUME };      BTree.ReadOnly => ERROR MDirectory.DirError[readOnlyDirectory];      BTree.VolumeNotOpen => ERROR MDirectory.DirError[volumeNotOpen];      UNWIND => NULL};    rec: MDirectory.MValueRec;    value: BTree.Value = MDirectory.MValueToValue[@rec];    tree: Tree;    oldType: MFile.Type;    LegalName[name];    tree ¬ GetTree[dir];    BEGIN    ENABLE UNWIND => FreeTree[tree];    IF ~BTree.Find[tree, name, value] THEN MDirectory.DirError[fileNotFound];    oldType ¬ rec.dirInfo.type;    rec.dirInfo ¬ dirInfo;    IF dirInfo.type = null THEN rec.dirInfo.type ¬ oldType;    [] ¬ BTree.SwapValue[      tree: tree, name: name, newValue: value, oldValue: NIL];    END;    FreeTree[tree];    END;  -- root file procedures    NoRootFile: PUBLIC SIGNAL = CODE;    sizeRootFile: Environment.PageCount = (    SIZE[MFileOps.RootFileObject] + Environment.wordsPerPage - 1)      / Environment.wordsPerPage;    sysVolRootFile: MFileOps.RootFile ¬ NIL;  scratchRootFile: MFileOps.RootFile ¬ NIL;  -- for all non-system volumes  -- The MDirectory.lock invariant includes "scratchRootFile = NIL"     AccessRootFile: PUBLIC ENTRY PROCEDURE [    volume: Volume.ID, proc: PROC [root: MFileOps.RootFile]] = {    ENABLE UNWIND => NULL;    root: MFileOps.RootFile ¬ GetRootFileInternal[volume];    proc[root];    ForceConsistent[root]};    CreateRootFile: PROCEDURE [root: MFileOps.RootFile, volume: Volume.ID] = {    rootFile: File.File;    IF NOT ScavengeForward[volume, root].success THEN {      SIGNAL NoRootFile;      rootFile ¬ File.Create[        volume, sizeRootFile, MesaDEFileTypesExtra.tRootFile !	Volume.ReadOnly => ERROR MDirectory.DirError[readOnlyDirectory];	Volume.InsufficientSpace => ERROR MDirectory.DirError[noRoomOnVolume]];      Volume.InsertRootFile[MesaDEFileTypesExtra.tRootFile, rootFile];      [] ¬ Space.MapAt[        at: [root, sizeRootFile], window: [rootFile, 0, sizeRootFile]];      root­ ¬ [0, File.nullID];      File.MakePermanent[rootFile]}};  ForceConsistent: PROCEDURE [root: MFileOps.RootFile] = {    IF root = sysVolRootFile THEN Space.ForceOut[[root, sizeRootFile]]    ELSE [] ¬ Space.UnmapAt[root]};      GetRootFileInternal: PROCEDURE [volume: Volume.ID]    RETURNS [root: MFileOps.RootFile] = {    RETURN[      IF volume = Volume.systemID AND Mapped[sysVolRootFile]      THEN sysVolRootFile ELSE MapRootFileInternal[volume]]};    MapSysvolRootFile: ENTRY PROCEDURE = {    ENABLE UNWIND => NULL;    [] ¬ MapRootFileInternal[Volume.systemID ! NoRootFile => CONTINUE]};    Mapped: PROCEDURE [p: LONG POINTER] RETURNS [mapped: BOOLEAN] = INLINE {    RETURN[Space.GetMapUnitAttributes[sysVolRootFile].window.count > 0]};    MapRootFileInternal: PROCEDURE [volume: Volume.ID]    RETURNS [root: MFileOps.RootFile]= {    noRootFile: BOOLEAN ¬ FALSE;    rootFile: File.File;    access: Space.Access = IF Volume.GetAttributes[volume].readOnly      THEN readOnly ELSE readWrite;    root ¬ IF volume = Volume.systemID THEN sysVolRootFile ELSE scratchRootFile;    rootFile ¬ Volume.LookUpRootFile[MesaDEFileTypesExtra.tRootFile, volume      ! Volume.RootDirectoryError => IF type = rootFileUnknown THEN {        noRootFile ¬ TRUE; CONTINUE}];    IF NOT noRootFile THEN [] ¬ Space.MapAt[      at: [root, sizeRootFile], window: [rootFile, 0, sizeRootFile],      access: access ! File.Unknown => {        Volume.RemoveRootFile[MesaDEFileTypesExtra.tRootFile, volume];	  -- remove tRootFile from table ar#12374	  -- tRootFile is guaranteed to be in the table, because noRootFile must 	  -- be FALSE to even have made the Space.MapAt call.	noRootFile ¬ TRUE;        CONTINUE}];    IF noRootFile THEN CreateRootFile[root, volume]};    MarkChanging: PUBLIC PROCEDURE [volume: Volume.ID] = {    root: MFileOps.RootFile ¬ GetRootFileInternal[volume];    root.changing ¬ SUCC[root.changing];    ForceConsistent[root]};    MarkChanged: PUBLIC PROCEDURE [volume: Volume.ID] = {    root: MFileOps.RootFile ¬ GetRootFileInternal[volume];    root.changing ¬ PRED[root.changing];    ForceConsistent[root]};  NeedsMScavenging: PUBLIC ENTRY PROCEDURE [volume: Volume.ID]    RETURNS [scavenge: BOOLEAN] = {    ENABLE UNWIND => NULL;    scavenge ¬ MScavenge.NeedsMScavenging[volume];         IF NOT scavenge THEN {      root: MFileOps.RootFile ¬ GetRootFileInternal[        volume ! NoRootFile => GOTO Uninitialized];      scavenge ¬ root.changing # 0;      ForceConsistent[root]};    EXITS Uninitialized => RETURN[FALSE]};    -- These two procedures are for maintaining Klamath compatability. They can  -- be removed once we're two releases from Klamath    MaintainKlamathFormat: PROCEDURE [volume: Volume.ID, rootDir: File.File] = {    oldRootDir: File.File ¬ File.nullFile;    oldRootDir ¬ Volume.LookUpRootFile[MesaDEFileTypes.tRootDirectory, volume      ! Volume.RootDirectoryError => IF type = rootFileUnknown THEN CONTINUE];    IF rootDir # oldRootDir THEN {      IF oldRootDir # File.nullFile THEN -- scavenge? --         Volume.RemoveRootFile[MesaDEFileTypes.tRootDirectory, volume];      Volume.InsertRootFile[MesaDEFileTypes.tRootDirectory, rootDir]}};    ScavengeForward: PROCEDURE [    volume: Volume.ID, root: MFileOps.RootFile] RETURNS [success: BOOLEAN] = {    rootDirectory, rootFile: File.File;    rootDirectory ¬ Volume.LookUpRootFile[MesaDEFileTypes.tRootDirectory, volume      ! Volume.RootDirectoryError => GOTO Failed];    rootFile ¬ File.Create[      volume, sizeRootFile, MesaDEFileTypesExtra.tRootFile      ! Volume.ReadOnly => GOTO Failed];    Volume.InsertRootFile[MesaDEFileTypesExtra.tRootFile, rootFile];    [] ¬ Space.MapAt[      at: [root, sizeRootFile], window: [rootFile, 0, sizeRootFile]];    root­ ¬ [0, rootDirectory.fileID];    File.MakePermanent[rootFile];    RETURN[TRUE];    EXITS Failed => RETURN[FALSE]};  -- PUBLIC ENTRY procedures for Scavenger  CreateSubDir: PUBLIC ENTRY PROCEDURE [    dir: BTree.Tree, name: LONG STRING, dirID: File.File]    RETURNS [newDir: File.ID ¬ File.nullID] = {    ENABLE {      SpecialBTree.Unmapped => {MDirectory.MapCacheEntry[tree]; RESUME };      BTree.ReadOnly => ERROR MDirectory.DirError[readOnlyDirectory];      BTree.VolumeNotOpen => ERROR MDirectory.DirError[volumeNotOpen];      UNWIND => NULL};    RETURN[MDirectory.InternalCreateSubDir[dir, name, dirID].fileID]};  GetValue: PUBLIC ENTRY PROCEDURE [dir: Tree, name: LONG STRING]    RETURNS [rec: MDirectory.MValueRec] =    BEGIN    ENABLE {      SpecialBTree.Unmapped => {MDirectory.MapCacheEntry[tree]; RESUME };      BTree.ReadOnly => ERROR MDirectory.DirError[readOnlyDirectory];      BTree.VolumeNotOpen => ERROR MDirectory.DirError[volumeNotOpen];      UNWIND => NULL};    value: BTree.Value = MDirectory.MValueToValue[@rec];    ok: BOOLEAN;    IF ~MDirectory.IsFilename[name] THEN RETURN[MDirectory.nullMValueRec];    ok ¬ BTree.Find[dir, name, value];    RETURN[IF ~ok THEN MDirectory.nullMValueRec ELSE rec];    END;  InsertInTree: PUBLIC ENTRY PROCEDURE [    dir: Tree, name: LONG STRING, file: File.ID] RETURNS [succeeded: BOOLEAN] =    BEGIN    ENABLE {      SpecialBTree.Unmapped => {MDirectory.MapCacheEntry[tree]; RESUME };      BTree.ReadOnly => ERROR MDirectory.DirError[readOnlyDirectory];      BTree.VolumeNotOpen => ERROR MDirectory.DirError[volumeNotOpen];      UNWIND => NULL};    rec: MDirectory.MValueRec;    vol: Volume.ID = SpecialBTree.GetSpecialInfo[tree: dir].cap.volumeID;    value: BTree.Value = MDirectory.MValueToValue[@rec];    IF ~MDirectory.IsFilename[name] THEN RETURN[FALSE];    succeeded ¬ BTree.Find[dir, name, value];    IF succeeded THEN RETURN[rec.fID = file];    rec ¬ [file, [type: text]]; -- changes value    MarkChanging[vol];    [succeeded, ] ¬ BTree.Insert[tree: dir, name: name, value: value];    MarkChanged[vol];    END;  LookupRootDir: PUBLIC ENTRY PROCEDURE [    volume: Volume.ID, name: LONG STRING ¬ NIL] RETURNS [rootDir: File.File] = {    ENABLE {      SpecialBTree.Unmapped => {MDirectory.MapCacheEntry[tree]; RESUME };      BTree.ReadOnly => ERROR MDirectory.DirError[readOnlyDirectory];      BTree.VolumeNotOpen => ERROR MDirectory.DirError[volumeNotOpen];      UNWIND => NULL};    RETURN[InternalLookupRootDir[volume, name]]};  InternalLookupRootDir: PUBLIC PROCEDURE [    volume: Volume.ID, name: LONG STRING ¬ NIL]    RETURNS [rootDir: File.File ¬ File.nullFile] = {    noRoot: BOOLEAN ¬ FALSE;    root: MFileOps.RootFile;    root ¬ GetRootFileInternal[      volume ! NoRootFile => {noRoot ¬ TRUE; CONTINUE};      Volume.NotOpen => ERROR MDirectory.DirError[volumeNotOpen]];    IF NOT noRoot THEN [] ¬ File.GetAttributes[      [root.rootDirectory, volume] ! File.Unknown => {      ForceConsistent[root]; noRoot ¬ TRUE; CONTINUE}];    IF noRoot THEN {      IF volume # Volume.systemID THEN SIGNAL MDirectory.NoRootDir;  -- RESUMEable      root ¬ GetRootFileInternal[volume ! NoRootFile => RESUME];      root.rootDirectory ¬ CreateRootDir[volume].fileID};    rootDir ¬ [fileID: root.rootDirectory, volumeID: volume];    IF noRoot THEN MaintainKlamathFormat[volume, rootDir];    ForceConsistent[root];        IF name # NIL THEN Volume.GetLabelString[volume, name]};  MakeEmptyDir: PUBLIC ENTRY PROCEDURE [file: File.File] =    BEGIN    ENABLE {      SpecialBTree.Unmapped => {MDirectory.MapCacheEntry[tree]; RESUME };      BTree.ReadOnly => ERROR MDirectory.DirError[readOnlyDirectory];      BTree.VolumeNotOpen => ERROR MDirectory.DirError[volumeNotOpen];      UNWIND => NULL};    BTree.Delete[      SpecialBTree.MakeFromCapa[      cap: file, lpSize: MFileOps.leaderPages,       usage: MUsage.mFileDirectory,      valueSize: SIZE[MDirectory.MValueRec], reset: TRUE]];    END;  SetDirInfoInTree: PUBLIC ENTRY PROCEDURE [    dir: BTree.Tree, name: LONG STRING, dirInfo: MDirectory.DirInfo] =    BEGIN    ENABLE {      SpecialBTree.Unmapped => {MDirectory.MapCacheEntry[tree]; RESUME };      BTree.ReadOnly => ERROR MDirectory.DirError[readOnlyDirectory];      BTree.VolumeNotOpen => ERROR MDirectory.DirError[volumeNotOpen];     UNWIND => NULL};    rec: MDirectory.MValueRec;    value: BTree.Value = MDirectory.MValueToValue[@rec];    oldType: MFile.Type;    IF ~MDirectory.IsFilename[name] THEN RETURN;    IF ~BTree.Find[dir, name, value] THEN MDirectory.DirError[fileNotFound];    oldType ¬ rec.dirInfo.type;    rec.dirInfo ¬ dirInfo;    IF dirInfo.type = null THEN rec.dirInfo.type ¬ oldType;    [] ¬ BTree.SwapValue[tree: dir, name: name, newValue: value, oldValue: NIL];    END;  -- Utilities  CreateRootDir: PROCEDURE [volume: Volume.ID]    RETURNS [rootDir: File.File ¬ File.nullFile] =    BEGIN    rootDirName: STRING ¬ [Volume.maxNameLength];    lp: MFileOps.LeaderPage;    Volume.GetLabelString[volume, rootDirName];    rootDir ¬ File.Create[      volume: volume, initialSize: 5, type: MesaDEFileTypes.tRootDirectory !      Volume.InsufficientSpace => MDirectory.DirError[noRoomOnVolume]];    {    ENABLE UNWIND => {File.Delete[rootDir]; rootDir ¬ File.nullFile};    BTree.Delete[SpecialBTree.MakeFromCapa[      cap: rootDir,      usage: MUsage.mFileDirectory,      lpSize: MFileOps.leaderPages,      valueSize: SIZE[MDirectory.MValueRec],      reset: TRUE]];  -- initialize BTree    lp ¬ MFileOps.MapLeader[rootDir ! MFileOps.InvalidLeader => RESUME]; -- can be safely mapped for write because not yet in directory structure    MFileOps.InitLeader[lp, rootDir.fileID, directory, rootDirName, 0];    lp.fp.dirInfo.writeProtect ¬ TRUE;    MFileOps.UnmapLeader[lp];    Volume.InsertRootFile[      type: MesaDEFileTypes.tRootDirectory, file: rootDir !      Volume.NotOpen => ERROR MDirectory.DirError[volumeNotOpen];      Volume.RootDirectoryError => IF type = duplicateRootFile THEN {        Volume.RemoveRootFile[MesaDEFileTypes.tRootDirectory, volume];	RETRY}]};  -- enter RootDir in RootFile    File.MakePermanent[rootDir];    END;  FreeSP: PROCEDURE [count: CARDINAL] =    BEGIN    IF count > 0 THEN      FOR i: CARDINAL IN [0..count - 1) DO        MDirectory.FreeTree[MDirectory.searchPathBTree[i]];        directoryZone.FREE[@MDirectory.searchPathNames[i]];        ENDLOOP;    directoryZone.FREE[@MDirectory.searchPathNames];    directoryZone.FREE[@MDirectory.searchPathFile];    directoryZone.FREE[@MDirectory.searchPathBTree];    END;  GetVolumeName: PROCEDURE [volume: Volume.ID] RETURNS [name: LONG STRING] =    BEGIN    volumeLabel: STRING ¬ [Volume.maxNameLength];    Volume.GetLabelString[volume, volumeLabel];    name ¬ directoryZone.NEW[StringBody [volumeLabel.length + 2]];    String.AppendChar[name, '<];    String.AppendString[name, volumeLabel];    String.AppendChar[name, '>];    END;  SetProtectBit: PROCEDURE [    dir: File.File, name: LONG STRING, which: ProtectBit, sense: BOOLEAN] =    BEGIN    rec: MDirectory.MValueRec;    value: BTree.Value = MDirectory.MValueToValue[@rec];    tree: Tree;    tree ¬ MDirectory.GetTree[dir];    BEGIN    ENABLE UNWIND => MDirectory.FreeTree[tree];    IF ~BTree.Find[tree, name, value] THEN MDirectory.DirError[fileNotFound];    SELECT which FROM      read => rec.dirInfo.readProtect ¬ sense;      write => rec.dirInfo.writeProtect ¬ sense;      delete => rec.dirInfo.deleteProtect ¬ sense;      dir => rec.dirInfo.dirProtect ¬ sense;      ENDCASE;    [ ] ¬ BTree.SwapValue[tree: tree, name: name, newValue: value, oldValue: NIL];    IF which = dir THEN       MDirectory.UpdateDirCache[[rec.fID, [dir.volumeID]], sense];    END;    MDirectory.FreeTree[tree];    END;  Init: PROCEDURE = {    fileSystem ¬ Supervisor.CreateSubsystem[];    directoryZone ¬ Heap.Create[initial: 3, swapUnitSize: 4, increment: 4];    sysVolRootFile ¬ Space.Allocate[count: sizeRootFile].pointer;    scratchRootFile ¬ Space.Allocate[count: sizeRootFile].pointer;    MapSysvolRootFile[];        -- The next two starts must occur after directoryZone is created    MDirectory.StartMDirectoryImplA[];    MDirectory.StartMDirectoryImplB[];        IF NeedsMScavenging[Volume.systemID] OR System.switches['V] = down THEN {      IF Mapped[sysVolRootFile] THEN [] ¬ Space.UnmapAt[sysVolRootFile];      SIGNAL MScavenge.StartingScavenge;      MScavenge.Scavenge[repair: TRUE, verbose: FALSE, volume: Volume.systemID]};          [] ¬ LookupRootDir[Volume.systemID ! MDirectory.NoRootDir => RESUME ];    initSearchPath ¬ directoryZone.NEW[MFile .SearchPathObject[1]];    initSearchPath.length ¬ 1;    initSearchPath[0] ¬ GetVolumeName[Volume.systemID];    [] ¬ DirSetSearchPath[initSearchPath]};  InitializeFileSystem: PUBLIC PROCEDURE = {};  -- cause start trap  -- main program  Init[];  END.. of MDirectoryImplC     9-Jan-87 11:22:10 - rlc - Add MScavenge.NeedsMScavenging, Scavenger.GetLog goes away25-Feb-88 13:33:53 - RLC - AR 12374 add Volume.RemoveRootFile to MapRootFileInternal 4-Mar-88 10:15:45 - RSV - Actually made above edit to Labelless version.
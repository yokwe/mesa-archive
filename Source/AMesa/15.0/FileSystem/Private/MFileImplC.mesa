-- Copyright (C) 1981, 1982, 1983  by Xerox Corporation. All rights reserved. -- File: MFileImplC.mesa - last edited by-- PXK    ,	 2-Mar-82 10:06:55-- LXR    ,	 5-Dec-83 13:18:33-- SXS   ,	25-Nov-81 14:58:14-- JGS,		24-Nov-81 10:13:04-- RXJ     ,	17-Jan-83  9:07:21DIRECTORY  ByteBlt USING [ByteBlt],  Environment USING [Block, Byte, bytesPerPage],  File USING [File, ID, MakePermanent, nullID],  MDirectory USING [    DirSetDeleteProtect, DirSetDirProtect, DirSetReadProtect, DirSetWriteProtect],  MFile USING [    Access, dontCare, Error, Handle, maxNameLength, NameForError, Object, Property,    PropertyErrorCode, Type],  MFileOps USING [    FHandle, ForceOutLeader, GetName, Handle, LeaderPage, leaderPages,     LeaderProperty, MapLeader, maxNameLength, Object,    SetMinimumFileDataPages, ValidateHandle, VolumeOpenForWrite, UnmapLeader],  NotifyOps USING [    AccessStatus, AddToNotificationList, NameInCache, NameOverflow,    PutNameInCache],  RFile USING [    GetFullName, Handle, ReadLeaderPage, SetLength, UnlockLeader,    WriteLeaderPage],  Space USING [MakeReadOnly, MakeWritable],  SpecialFile USING [MakeTemporary],  System USING [gmtEpoch],  Time USING [Current, Packed],  Volume USING [ID, GetStatus, nullID, systemID];MFileImplC: MONITOR LOCKS fo.leaderPageLock USING fo: MFileOps.FHandle  IMPORTS     ByteBlt, File, MDirectory, MFile, MFileOps, NotifyOps, RFile,     Space, SpecialFile, Time, Volume  EXPORTS MFile, MFileOps, NotifyOps =  BEGIN  supportReadDate: BOOLEAN ¬ TRUE;  readMask:  Mask = [read: TRUE];  Handle: TYPE = MFileOps.Handle;  Object: PUBLIC TYPE = MFileOps.Object;  FHandle: TYPE = MFileOps.FHandle;  LeaderPage: TYPE = MFileOps.LeaderPage;  PropertyError: PUBLIC ERROR [code: MFile.PropertyErrorCode] = CODE;  AskPilotToMakeTemp: PUBLIC ENTRY PROCEDURE [fo: FHandle, file: File.File] =    BEGIN ENABLE UNWIND => NULL;    Space.MakeReadOnly[[fo.lp, MFileOps.leaderPages]];    SpecialFile.MakeTemporary[file];    Space.MakeWritable[[fo.lp, MFileOps.leaderPages]];    fo.lp.fp.dir ¬ File.nullID;    fo.lp.fp.name.length ¬ 0; -- temporary files have no names    MFileOps.ForceOutLeader[fo.lp];    END;      AskPilotToMakePermanent: PUBLIC ENTRY PROCEDURE [fo: FHandle, file: File.File] =    BEGIN ENABLE UNWIND => NULL;    Space.MakeReadOnly[[fo.lp, MFileOps.leaderPages]];    File.MakePermanent[file];    Space.MakeWritable[[fo.lp, MFileOps.leaderPages]];    END;      -- leader page properties  GetFullName: PUBLIC PROCEDURE [file: Handle, name: LONG STRING] = {    IF name = NIL OR name.maxlength = 0 THEN RETURN;    MFileOps.ValidateHandle[file];    name.length ¬ 0;    IF file.fo.tempFile THEN RETURN;  -- no name    WITH file.fo.location SELECT FROM      remote => {RFile.GetFullName[h, name]; RETURN};      local => {        IF FillInFullName[f, file.fo.lp, name !          NotifyOps.NameOverflow => GOTO noMore] AND name.length < name.maxlength          THEN {name[name.length] ¬ '>; name.length ¬ name.length + 1}        EXITS noMore => PropertyError[insufficientSpaceForProperty]};      ENDCASE};  GetDirectoryName: PUBLIC PROCEDURE [file: Handle, name: LONG STRING] = {    MFileOps.ValidateHandle[file];    GetFullName[file, name];    IF file.fo.tempFile THEN RETURN;    FOR i: CARDINAL DECREASING IN [0..name.length) DO      IF name[i] = '> THEN {name.length ¬ i + 1; EXIT}; ENDLOOP};  FillInFullName: PROCEDURE [    capa: File.File, lp: LeaderPage, name: LONG STRING]    RETURNS [atRoot: BOOLEAN] = {    temp: STRING = [MFileOps.maxNameLength + 2];    chars: CARDINAL;    IF lp.fp.dir = capa.fileID THEN {atRoot ¬ TRUE; name[0] ¬ '<; name.length ¬ 1}    ELSE {      dirCapa: File.File = [lp.fp.dir, capa.volumeID];      atRoot ¬ FALSE;      IF ~NotifyOps.NameInCache[dirCapa, name] THEN {        dirLP: LeaderPage = MFileOps.MapLeader[dirCapa, TRUE];        [] ¬ FillInFullName[          dirCapa, dirLP, name ! UNWIND => MFileOps.UnmapLeader[dirLP]];        MFileOps.UnmapLeader[dirLP];        IF name.length = name.maxlength THEN ERROR NotifyOps.NameOverflow;        name[name.length] ¬ '>;        name.length ¬ name.length + 1;        NotifyOps.PutNameInCache[dirCapa, name]}};    chars ¬ ByteBlt.ByteBlt[      from: [@lp.fp.name.bytes, 0, lp.fp.name.length],      to: [LOOPHOLE[@name.text], name.length, name.maxlength]];    name.length ¬ name.length + chars;    IF chars # lp.fp.name.length THEN ERROR NotifyOps.NameOverflow};  GetProperties: PUBLIC PROCEDURE [file: Handle, name: LONG STRING ¬ NIL]    RETURNS [      create, write, read: Time.Packed, length: LONG CARDINAL, type: MFile.Type,      deleteProtected, writeProtected, readProtected: BOOLEAN] = {    MFileOps.ValidateHandle[file];    IF name # NIL THEN MFileOps.GetName[file.fo.lp, name];    [create, write, read, length, type, deleteProtected, writeProtected,      readProtected] ¬ InternalGetProperties[file.fo, file]};  InternalGetProperties: ENTRY PROCEDURE [fo: FHandle, file: Handle]    RETURNS [      create, write, read: Time.Packed, length: LONG CARDINAL, type: MFile.Type,      deleteProtected, writeProtected, readProtected: BOOLEAN] = {    ENABLE UNWIND => NULL;    lp: LeaderPage;    lp ¬ file.fo.lp;    WITH file.fo.location SELECT FROM      remote => {RFile.ReadLeaderPage[h, lp]; RFile.UnlockLeader[h]};      ENDCASE;    create ¬ lp.fp.create;    write ¬ lp.fp.write;    IF supportReadDate THEN read ¬ lp.fp.read ELSE read ¬ System.gmtEpoch;    length ¬ InternalGetLength[fo, file];    type ¬ lp.fp.dirInfo.type;    deleteProtected ¬ lp.fp.dirInfo.deleteProtect;    writeProtected ¬ IF type = directory THEN lp.fp.dirInfo.dirProtect       ELSE lp.fp.dirInfo.writeProtect;    readProtected ¬ lp.fp.dirInfo.readProtect};  -- GetCreateDate is an accelerator for the DF file stuff  GetCreateDate: PUBLIC PROCEDURE [file: Handle] RETURNS [create: Time.Packed] =    BEGIN    DoIt: ENTRY PROCEDURE [fo: FHandle] = {      ENABLE UNWIND => NULL;      WITH file.fo.location SELECT FROM        remote => {RFile.ReadLeaderPage[h, fo.lp]; RFile.UnlockLeader[h]};      ENDCASE;      create ¬ fo.lp.fp.create};    MFileOps.ValidateHandle[file];    DoIt[file.fo];    END;  GetTimes: PUBLIC PROCEDURE [file: Handle]    RETURNS [create, write, read: Time.Packed] = {    MFileOps.ValidateHandle[file];    [create: create, write: write, read: read] ¬ InternalGetProperties[      file.fo, file]};  LockedGetName: PUBLIC ENTRY PROCEDURE [      fo: FHandle, name: LONG STRING] = {      ENABLE UNWIND => NULL; MFileOps.GetName[fo.lp, name]};  GetType: PUBLIC PROCEDURE [file: Handle] RETURNS [type: MFile.Type] = {    MFileOps.ValidateHandle[file];    type ¬ InternalGetProperties[file.fo, file].type};  GetLength: PUBLIC PROCEDURE [file: Handle] RETURNS [length: LONG CARDINAL] = {    MFileOps.ValidateHandle[file]; length ¬ EntryGetLength[file.fo, file]};  EntryGetLength: PROCEDURE [fo: FHandle, file: Handle]    RETURNS [length: LONG CARDINAL] = INLINE {    RETURN[InternalGetLength[fo, file]]};  InternalGetLength: PROCEDURE [fo: FHandle, file: Handle]    RETURNS [length: LONG CARDINAL] = {    IF file.access = readOnly THEN length ¬ file.length    ELSE {      WITH file.fo.location SELECT FROM        remote => {RFile.ReadLeaderPage[h, file.fo.lp]; RFile.UnlockLeader[h]};        ENDCASE;      length ¬ file.fo.lp.fp.length}};  GetProtection: PUBLIC PROCEDURE [file: Handle]    RETURNS [deleteProtected, writeProtected, readProtected: BOOLEAN] = {    name: STRING = [MFile.maxNameLength];    MFileOps.ValidateHandle[file];    [deleteProtected: deleteProtected, writeProtected: writeProtected,      readProtected: readProtected] ¬ InternalGetProperties[file.fo, file]};  Mask: TYPE = RECORD [    create, write, read, length, type, dProt, rProt, wProt, dirProt: BOOLEAN ¬ FALSE];  InternalSetProperties: ENTRY PROCEDURE [    fo: FHandle, file: Handle, mask: Mask,    create, write, read: Time.Packed ¬ System.gmtEpoch, length: LONG CARDINAL ¬ 0,    type: MFile.Type ¬ unknown,    deleteProtected, writeProtected, readProtected: BOOLEAN ¬ FALSE] = {    ENABLE UNWIND => NULL;    lp: LeaderPage = fo.lp;    remote: BOOLEAN ¬ FALSE;    volume: Volume.ID ¬ Volume.nullID;    dirProtected: BOOLEAN = writeProtected;     InDirectoryStructure: PROCEDURE RETURNS [BOOLEAN] = INLINE       {RETURN[WITH file.fo.location SELECT FROM        remote => FALSE,        local => ~fo.tempFile AND  lp.fp.dir # f.fileID,        ENDCASE => FALSE]};   IF mask = readMask AND ~supportReadDate THEN RETURN;    WITH file.fo.location SELECT FROM      remote => {        IF mask.length THEN RFile.SetLength[h, length];        RFile.ReadLeaderPage[h, lp];        remote ¬ TRUE};      local => {               IF f.volumeID # Volume.systemID THEN                  SELECT Volume.GetStatus[f.volumeID] FROM		    openReadWrite  => NULL;		    openRead  => ERROR MFile.Error[file, volumeReadOnly];		    ENDCASE => ERROR MFile.Error[file, volumeNotOpen];	       volume ¬ f.volumeID};      ENDCASE;    IF lp.fp.dirInfo.type = directory THEN {  -- don't let client mess with directories      type ¬ directory; writeProtected ¬ TRUE; mask.dirProt ¬ mask.wProt}    ELSE IF type = directory THEN       RETURN WITH ERROR MFile.Error[file, other] ;    IF mask.length AND ~remote THEN InternalSetLength[file, lp, length];    IF mask.create THEN lp.fp.create ¬ create;    IF mask.write THEN lp.fp.write ¬ write;    IF mask.read AND supportReadDate THEN lp.fp.read ¬ read;    IF mask.type THEN lp.fp.dirInfo.type ¬ type;    IF mask.dProt OR mask.rProt OR mask.wProt THEN {      nameCopy: LONG STRING = [MFileOps.maxNameLength];      nameCopy.length ¬ ByteBlt.ByteBlt[        from: [@lp.fp.name.bytes, 0, lp.fp.name.length],        to: [LOOPHOLE[@nameCopy.text], 0, nameCopy.maxlength]];      IF mask.dProt THEN {        IF InDirectoryStructure[] THEN          MDirectory.DirSetDeleteProtect[[lp.fp.dir, volume], nameCopy, deleteProtected];        lp.fp.dirInfo.deleteProtect ¬ deleteProtected};      IF mask.rProt THEN {        IF InDirectoryStructure[] THEN          MDirectory.DirSetReadProtect[[lp.fp.dir, volume], nameCopy, readProtected];        lp.fp.dirInfo.readProtect ¬ readProtected};      IF mask.wProt THEN {        IF InDirectoryStructure[] THEN          MDirectory.DirSetWriteProtect[[lp.fp.dir, volume], nameCopy, writeProtected];        lp.fp.dirInfo.writeProtect ¬ writeProtected};       IF mask.dirProt THEN {        IF InDirectoryStructure[] THEN          MDirectory.DirSetDirProtect[[lp.fp.dir, volume], nameCopy, dirProtected];        lp.fp.dirInfo.dirProtect ¬ dirProtected}};    WITH file.fo.location SELECT FROM      remote => RFile.WriteLeaderPage[h, lp];      local => MFileOps.ForceOutLeader[lp];      ENDCASE}; SetName: PUBLIC ENTRY PROCEDURE [fo: FHandle, name: LONG STRING] = {    ENABLE {MFile.NameForError => RESUME [name]; UNWIND => NULL};     lp: MFileOps.LeaderPage = fo.lp;    WITH fo.location SELECT FROM       local => IF f.volumeID # Volume.systemID THEN                  SELECT Volume.GetStatus[f.volumeID] FROM		   openReadWrite => NULL;		   openRead => MFile.Error[NIL, volumeReadOnly]; 		   ENDCASE => ERROR MFile.Error[NIL, volumeNotOpen];       ENDCASE;    IF name = NIL THEN {      lp.fp.name.length ¬ 0; MFileOps.ForceOutLeader[lp]; RETURN};    IF name.length > MFileOps.maxNameLength THEN      ERROR MFile.Error[NIL, illegalName];    lp.fp.name.length ¬ ByteBlt.ByteBlt[      to: [@lp.fp.name.bytes, 0, MFileOps.maxNameLength],      from: [LOOPHOLE[@name.text], 0, name.length]];    MFileOps.ForceOutLeader[lp]}; SetDir: PUBLIC ENTRY PROCEDURE [fo: FHandle, dir: File.ID] = {    ENABLE UNWIND => NULL; fo.lp.fp.dir ¬ dir}; SetTimes: PUBLIC PROCEDURE [    file: Handle, create, read, write: Time.Packed ¬ System.gmtEpoch] = {    MFileOps.ValidateHandle[file];    IF ~supportReadDate AND create = System.gmtEpoch AND write = System.gmtEpoch THEN RETURN;    InternalSetProperties[      fo: file.fo, file: file, create: create, read: read, write: write,      mask: [      create: create # System.gmtEpoch, write: write # System.gmtEpoch,      read: read # System.gmtEpoch]]};  SetProperties: PUBLIC PROCEDURE [    file: Handle, create, write, read: Time.Packed ¬ System.gmtEpoch,    length: LONG CARDINAL, type: MFile.Type,    deleteProtected, writeProtected, readProtected: BOOLEAN ¬ FALSE] = {    MFileOps.ValidateHandle[file];    InternalSetProperties[      fo: file.fo, file: file, type: type, length: length, create: create,      read: read, write: write, deleteProtected: deleteProtected,      writeProtected: writeProtected, readProtected: readProtected,      mask: [      type: TRUE, dProt: TRUE, wProt: TRUE, rProt: TRUE,      length: length # MFile.dontCare, create: create # System.gmtEpoch,      write: write # System.gmtEpoch, read: read # System.gmtEpoch]]};  SetType: PUBLIC PROCEDURE [file: Handle, type: MFile.Type] = {    MFileOps.ValidateHandle[file];    InternalSetProperties[      fo: file.fo, file: file, type: type, mask: [type: TRUE]]};  InternalSetLength: PROCEDURE [  -- assumes leader page locked    file: Handle, lp: LeaderPage, length: LONG CARDINAL] = {    oldLengthChanged: BOOLEAN = file.fo.lengthChanged;    oldLength: LONG CARDINAL = file.length;    oldReadLengthForLog: LONG CARDINAL = file.fo.readLengthForLog;    bpp: CARDINAL = Environment.bytesPerPage;    SELECT file.access FROM      readWrite, writeOnly, log => NULL;      ENDCASE => ERROR MFile.Error[file, insufficientAccess];    IF file.fo.fileIsDeleted THEN RETURN;  -- if so, how did we get here?    file.fo.lengthChanged ¬ TRUE;    file.length ¬ lp.fp.length ¬ length;    IF file.access # log THEN file.fo.readLengthForLog ¬ length;    MFileOps.SetMinimumFileDataPages[      file, (length + (bpp - 1))/bpp !      UNWIND => {        file.fo.lengthChanged ¬ oldLengthChanged;        file.length ¬ lp.fp.length ¬ oldLength;        IF file.access # log THEN          file.fo.readLengthForLog ¬ oldReadLengthForLog}]};  SetLength: PUBLIC PROCEDURE [file: Handle, length: LONG CARDINAL] = {    MFileOps.ValidateHandle[file];    InternalSetProperties[      fo: file.fo, file: file, length: length, mask: [length: TRUE]]};  SetDeleteProtect: PUBLIC PROCEDURE [file: Handle, deleteProtected: BOOLEAN] = {    MFileOps.ValidateHandle[file];    InternalSetProperties[      fo: file.fo, file: file, deleteProtected: deleteProtected,      mask: [dProt: TRUE]]};  SetWriteProtect: PUBLIC PROCEDURE [file: Handle, writeProtected: BOOLEAN] = {    MFileOps.ValidateHandle[file];    InternalSetProperties[      fo: file.fo, file: file, writeProtected: writeProtected,      mask: [wProt: TRUE]]};  SetReadProtect: PUBLIC PROCEDURE [file: Handle, readProtected: BOOLEAN] = {    MFileOps.ValidateHandle[file];    InternalSetProperties[      fo: file.fo, file: file, readProtected: readProtected,      mask: [rProt: TRUE]]};  SetProtection: PUBLIC PROCEDURE [    file: Handle,    deleteProtected, writeProtected, readProtected: BOOLEAN ¬ FALSE] = {    MFileOps.ValidateHandle[file];    InternalSetProperties[      fo: file.fo, file: file, readProtected: readProtected,      writeProtected: writeProtected, deleteProtected: deleteProtected,      mask: [dProt: TRUE, wProt: TRUE, rProt: TRUE]]};  PropSize: PROC [maxLength: CARDINAL] RETURNS [words: CARDINAL] = {    words ¬ (maxLength + 1)/2 + SIZE[MFileOps.LeaderProperty]};  FirstPropAddress: PROC [lp: LeaderPage]    RETURNS [LONG POINTER TO MFileOps.LeaderProperty] = {    RETURN[@lp.props[0] + (lp.fp.name.maxlength + 1)/2]};  -- skip over name bytes  AddProperty: PUBLIC PROCEDURE [    file: Handle, property: MFile.Property, maxLength: CARDINAL] = {    MFileOps.ValidateHandle[file];    IF ~MFileOps.VolumeOpenForWrite[file.fo] THEN       ERROR MFile.Error[file, volumeNotOpen];    LockedAddProperty[file.fo, file, property, maxLength]};  LockedAddProperty: ENTRY PROCEDURE [    fo: FHandle, file: Handle, property: MFile.Property, maxLength: CARDINAL] = {    ENABLE UNWIND => NULL;    WITH file.fo.location SELECT FROM      remote => RFile.ReadLeaderPage[h, file.fo.lp];      ENDCASE;    RealAddProperty[      file.fo.lp, property, maxLength !      UNWIND =>        WITH file.fo.location SELECT FROM          remote => RFile.UnlockLeader[h];          ENDCASE];    WITH file.fo.location SELECT FROM      remote => RFile.WriteLeaderPage[h, file.fo.lp];      ENDCASE};  RealAddProperty: INTERNAL PROCEDURE [    lp: LeaderPage, property: MFile.Property, maxLength: CARDINAL] = {    propSize: CARDINAL;    prop: LONG POINTER TO MFileOps.LeaderProperty;    propSize ¬ PropSize[maxLength];    prop ¬ FirstPropAddress[lp];    THROUGH [0..lp.fp.extraProps) DO      IF prop.property = property THEN {        m: CARDINAL = prop.value.maxlength;        IF m # maxLength THEN ERROR PropertyError[wrongSize];        RETURN};      prop ¬ prop + PropSize[prop.value.maxlength];      ENDLOOP;    IF lp.fp.freeWords < propSize THEN ERROR PropertyError[noRoomInPropertyList];    lp.fp.freeWords ¬ lp.fp.freeWords - propSize;    prop.property ¬ property;    prop.value.length ¬ 0;    prop.value.maxlength ¬ maxLength;    lp.fp.extraProps ¬ lp.fp.extraProps + 1;    MFileOps.ForceOutLeader[lp]};  CopyProperties: PUBLIC PROCEDURE [from, to: Handle] = {    MFileOps.ValidateHandle[from];    MFileOps.ValidateHandle[to];    IF ~MFileOps.VolumeOpenForWrite[to.fo] THEN       ERROR MFile.Error[to, volumeNotOpen];    SELECT TRUE FROM  -- impose ordering on locks to avoid deadlock between 2 copies      from.fo = to.fo => RETURN;      LOOPHOLE[from.fo, LONG CARDINAL] < LOOPHOLE[to.fo, LONG CARDINAL] =>        LockFrom[from.fo, from, to];      ENDCASE => LockTo[to.fo, from, to]};  LockFrom: ENTRY PROCEDURE [fo: FHandle, from, to: Handle] = {    ENABLE UNWIND => NULL;    WITH from.fo.location SELECT FROM      remote => RFile.ReadLeaderPage[h, from.fo.lp];      ENDCASE;    LockedCopyProperties[      to.fo, from, to !      UNWIND =>        WITH from.fo.location SELECT FROM          remote => RFile.UnlockLeader[h];          ENDCASE];    WITH from.fo.location SELECT FROM      remote => RFile.WriteLeaderPage[h, from.fo.lp];      ENDCASE};  LockTo: ENTRY PROCEDURE [fo: FHandle, from, to: Handle] = {    ENABLE UNWIND => NULL;    WITH to.fo.location SELECT FROM      remote => RFile.ReadLeaderPage[h, to.fo.lp];      ENDCASE;    LockedCopyProperties[      from.fo, from, to !      UNWIND =>        WITH to.fo.location SELECT FROM remote => RFile.UnlockLeader[h]; ENDCASE];    WITH to.fo.location SELECT FROM      remote => RFile.WriteLeaderPage[h, to.fo.lp];      ENDCASE};  LockedCopyProperties: ENTRY PROCEDURE [fo: FHandle, from, to: Handle] = {    ENABLE UNWIND => NULL;    lp: LeaderPage;    prop: LONG POINTER TO MFileOps.LeaderProperty;    lp ¬ from.fo.lp;    prop ¬ FirstPropAddress[lp];    THROUGH [0..lp.fp.extraProps) DO      ENABLE { PropertyError => CONTINUE};      RealAddProperty[to.fo.lp, prop.property, prop.value.maxlength];      RealSetProperty[        to.fo.lp, prop.property, [@prop.value.bytes, 0, prop.value.length]];      prop ¬ prop + PropSize[prop.value.maxlength];      ENDLOOP};  GetProperty: PUBLIC PROCEDURE [    file: Handle, property: MFile.Property, block: Environment.Block]    RETURNS [length: CARDINAL] = {    MFileOps.ValidateHandle[file];    IF ~MFileOps.VolumeOpenForWrite[file.fo] THEN RETURN;    RETURN[LockedGetProperty[file.fo, file, property, block]]};  LockedGetProperty: ENTRY PROCEDURE [    fo: FHandle, file: Handle, property: MFile.Property, block: Environment.Block]    RETURNS [length: CARDINAL] = {    ENABLE UNWIND => NULL;    prop: LONG POINTER TO MFileOps.LeaderProperty;    lp: LeaderPage = file.fo.lp;    WITH file.fo.location SELECT FROM      remote => {RFile.ReadLeaderPage[h, lp]; RFile.UnlockLeader[h]};      ENDCASE;    prop ¬ FirstPropAddress[lp];    THROUGH [0..lp.fp.extraProps) DO      IF prop.property = property THEN {        RETURN[          ByteBlt.ByteBlt[            from: [@prop.value.bytes, 0, prop.value.length], to: block]]};      prop ¬ prop + PropSize[prop.value.maxlength];      ENDLOOP;    ERROR PropertyError[noSuchProperty]};  RemoveProperties: PUBLIC PROCEDURE [file: Handle] = {    MFileOps.ValidateHandle[file];    IF ~MFileOps.VolumeOpenForWrite[file.fo] THEN       ERROR MFile.Error[file, volumeNotOpen];    LockedRemoveProperties[file.fo, file]};  LockedRemoveProperties: ENTRY PROCEDURE [fo: FHandle, file: Handle] = {    ENABLE UNWIND => NULL;    lp: LeaderPage = file.fo.lp;    WITH file.fo.location SELECT FROM      remote => RFile.ReadLeaderPage[h, lp];      ENDCASE;    lp.fp.extraProps ¬ 0;    WITH file.fo.location SELECT FROM      remote => RFile.WriteLeaderPage[h, lp];      local => MFileOps.ForceOutLeader[lp];      ENDCASE};  RemoveProperty: PUBLIC PROCEDURE [file: Handle, property: MFile.Property] = {    MFileOps.ValidateHandle[file];    IF ~MFileOps.VolumeOpenForWrite[file.fo] THEN       ERROR MFile.Error[file, volumeNotOpen];    LockedRemoveProperty[file.fo, file, property]};  LockedRemoveProperty: ENTRY PROCEDURE [    fo: FHandle, file: Handle, property: MFile.Property] = {    ENABLE UNWIND => NULL;    prop: LONG POINTER TO MFileOps.LeaderProperty;    newPlace, oldPlace: LONG POINTER TO WORD;    lp: LeaderPage = file.fo.lp;    WITH file.fo.location SELECT FROM      remote => RFile.ReadLeaderPage[h, lp];      ENDCASE;    {    ENABLE      UNWIND =>        WITH file.fo.location SELECT FROM          remote => RFile.UnlockLeader[h];          ENDCASE;    prop ¬ FirstPropAddress[lp];    newPlace ¬ oldPlace ¬ LOOPHOLE[prop];    THROUGH [0..lp.fp.extraProps) DO      IF prop.property # property THEN        newPlace ¬ newPlace + PropSize[prop.value.maxlength];      prop ¬ prop + PropSize[prop.value.maxlength];      oldPlace ¬ oldPlace + PropSize[prop.value.maxlength];      IF newPlace # oldPlace THEN        FOR i: CARDINAL IN [0..PropSize[prop.value.maxlength]) DO          (newPlace + i)­ ¬ (oldPlace + i)­; ENDLOOP;      ENDLOOP};    WITH file.fo.location SELECT FROM      remote => RFile.WriteLeaderPage[h, lp];      local => MFileOps.ForceOutLeader[lp];      ENDCASE};  SetProperty: PUBLIC PROCEDURE [    file: Handle, property: MFile.Property, block: Environment.Block] = {    MFileOps.ValidateHandle[file];    IF ~MFileOps.VolumeOpenForWrite[file.fo] THEN       ERROR MFile.Error[file, volumeNotOpen];    LockedSetProperty[file.fo, file, property, block]};  LockedSetProperty: ENTRY PROCEDURE [    fo: FHandle, file: Handle, property: MFile.Property,    block: Environment.Block] = {    ENABLE UNWIND => NULL;    WITH file.fo.location SELECT FROM      remote => RFile.ReadLeaderPage[h, file.fo.lp];      ENDCASE;    RealSetProperty[      file.fo.lp, property, block !      UNWIND =>        WITH file.fo.location SELECT FROM          remote => RFile.UnlockLeader[h];          ENDCASE];    WITH file.fo.location SELECT FROM      remote => RFile.WriteLeaderPage[h, file.fo.lp];      ENDCASE};  RealSetProperty: INTERNAL PROCEDURE [    lp: LeaderPage, property: MFile.Property, block: Environment.Block] = {    propLength: CARDINAL;    prop: LONG POINTER TO MFileOps.LeaderProperty;    propLength ¬ block.stopIndexPlusOne - block.startIndex;    prop ¬ FirstPropAddress[lp];    THROUGH [0..lp.fp.extraProps) DO      IF prop.property = property THEN {        IF prop.value.maxlength < propLength THEN ERROR PropertyError[wrongSize];        prop.value.length ¬ ByteBlt.ByteBlt[          to: [@prop.value.bytes, 0, propLength], from: block];        MFileOps.ForceOutLeader[lp];	RETURN};      prop ¬ prop + PropSize[prop.value.maxlength];      ENDLOOP;    ERROR PropertyError[noSuchProperty]};  GetProtectionStatus: PUBLIC ENTRY PROCEDURE [    fo: MFileOps.FHandle, access: MFile.Access] RETURNS [NotifyOps.AccessStatus] =    {    ENABLE UNWIND => NULL;    RETURN[      IF      SELECT access FROM        readOnly => ~fo.lp.fp.dirInfo.readProtect,        readWrite => ~fo.lp.fp.dirInfo.readProtect          AND ~fo.lp.fp.dirInfo.writeProtect,        writeOnly, log => ~fo.lp.fp.dirInfo.writeProtect,        delete, rename => ~fo.lp.fp.dirInfo.deleteProtect,        ENDCASE => TRUE THEN good ELSE protected]};  SetTimesGivenAccess: PUBLIC ENTRY PROCEDURE [    fo: MFileOps.FHandle, lp: LeaderPage, access: MFile.Access] = {    ENABLE UNWIND => NULL;    now: Time.Packed = Time.Current[];    IF access = readOnly AND       ~(supportReadDate AND MFileOps.VolumeOpenForWrite[fo]) THEN RETURN;     SELECT access FROM      readOnly => lp.fp.read ¬ now;      log, readWrite =>{        IF supportReadDate THEN lp.fp.read ¬ now; 	lp.fp.write ¬ lp.fp.create ¬ now};      writeOnly => {        lp.fp.write ¬ lp.fp.create ¬ now; 	IF supportReadDate THEN lp.fp.read ¬ System.gmtEpoch};      ENDCASE;    MFileOps.ForceOutLeader[lp]};  SetReadLengthForLog: PUBLIC PROCEDURE [file: Handle, length: LONG CARDINAL] =     -- the store of the double word value really should be done in a monitor    -- but SetReadLengthForLog is often called out of a PleaseReleaseProc which    -- has the chain locked. it is protected by the lp lock    BEGIN    DoIt: ENTRY PROCEDURE [fo: FHandle] = {fo.readLengthForLog ¬ length};    MFileOps.ValidateHandle[file]; DoIt[file.fo];    NotifyOps.AddToNotificationList[file.fo, readWrite] -- inform anyone waiting to read this file    END;  GetReadLengthForLog: PUBLIC PROCEDURE [file: Handle] RETURNS [length: LONG CARDINAL] = {    DoIt: ENTRY PROCEDURE [fo: FHandle] = {length ¬ fo.readLengthForLog};    MFileOps.ValidateHandle[file]; DoIt[file.fo]};  END.    
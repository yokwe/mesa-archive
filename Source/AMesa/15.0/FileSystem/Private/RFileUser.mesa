-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved. -- File: RFileUser.mesa - last edited:-- RXJ     ,	 29-Nov-83 17:46:36-- LXR    ,	 18-May-83 16:51:39-- BJD    ,	  1-May-84 14:18:07-- JCS  ,	 21-Sep-84 13:31:38DIRECTORY  AddressTranslation USING [    Error, PrintError, StringToNetworkAddress],  Courier USING [    Arguments, Call, Create, Delete, Description, Error, ErrorCode, Handle,    RemoteErrorSignalled, SystemElement, VersionMismatch],  Environment USING [bytesPerPage, wordsPerPage],  Event USING [primaryCredentials, tajoDefaults],  EventTypes USING [primaryCredentials],  File USING [nullID, PageCount, PageNumber],  Format USING [StringProc],  Heap USING [Create],  MConvertLP USING [    ConvertToNewFormat, ConvertToOldFormat, InOldFormat, OldFileID],  MFile USING [Access, Error, ErrorCode, NameForError, ReleaseChoice],  MFileOps USING [LeaderPage, ReleaseRemoteFile],  NetworkStream USING [ConnectionSuspended],  Process USING [Abort, Detach, EnableAborts, SecondsToTicks],  Profile USING [GetUser, String],  Put USING [Char, Text],  RFile USING [],  RFileOps,  Stream USING [GetBlock, Handle, PutBlock, SetSST],  String USING [AppendChar, AppendString, CopyToNewString, EquivalentString, FreeString],  Supervisor USING [    AddDependency, AgentProcedure, CreateSubsystem, SubsystemHandle];RFileUser: MONITOR LOCKS conn USING conn: Connection  IMPORTS    AddressTranslation, Courier, Event, Heap, MConvertLP, MFile, MFileOps,    NetworkStream, Process, Profile, Put, RFileOps, Stream, String, Supervisor  EXPORTS RFile, RFileOps =  BEGIN    -- Courier Defs  programNumber: CARDINAL = RFileOps.programNumber;  versionNumber: CARDINAL = RFileOps.versionNumber;    acquireTimeout: CARDINAL = 40;  callTimeout: CARDINAL = 90;    -- Constants  wpp: CARDINAL = Environment.wordsPerPage;  bpp: CARDINAL = Environment.bytesPerPage;    chunkSize: CARDINAL ¬ 10;  -- max size of data Courier calls    z: UNCOUNTED ZONE = Heap.Create[initial: 2];    RFObject: TYPE = RFileOps.RFObject;    RFHandle: TYPE = RFileOps.RFHandle;      Object: PUBLIC TYPE = RECORD [    handle: RFObject,    conn: Connection,    link: Handle ¬ NIL,    fid: MConvertLP.OldFileID ¬ ALL[0]];    Handle: TYPE = LONG POINTER TO Object;    objectList: Handle ¬ NIL;    AddObject: ENTRY PROCEDURE [conn: Connection, h: Handle] RETURNS [Handle] =    BEGIN    h.link ¬ objectList;    objectList ¬ h;    RETURN[h]    END;    RemoveObject: ENTRY PROCEDURE [conn: Connection, h: Handle] =    BEGIN    IF objectList = h THEN {objectList ¬ h.link; RETURN};    FOR this: Handle ¬ objectList, this.link UNTIL this = NIL DO      IF this.link = h THEN {this.link ¬ h.link; EXIT};      ENDLOOP;    END;    ConnectionObject: TYPE = MONITORED RECORD [    cH: Courier.Handle ¬ NULL,    refcount: CARDINAL ¬ 1,    link: Connection ¬ NIL,    name: LONG STRING ¬ NIL,    process: PROCESS ¬ NIL];    Connection: TYPE = LONG POINTER TO ConnectionObject;    connList: ConnectionObject;  -- also used as global monitor lock    FindConnection: ENTRY PROCEDURE [conn: Connection, host: STRING]    RETURNS [newConn: Connection] =    BEGIN ENABLE UNWIND => NULL;    addr: Courier.SystemElement;    cH: Courier.Handle;    FOR c: Connection ¬ conn.link, c.link UNTIL c = NIL DO      IF String.EquivalentString[c.name, host] THEN  {        IF c.process # NIL THEN {Process.Abort[c.process]; c.process ¬ NIL};	c.refcount ¬ c.refcount + 1; 	RETURN[c]};      ENDLOOP;    addr ¬ AddressTranslation.StringToNetworkAddress[host !      AddressTranslation.Error => {        sProc: Format.StringProc = {Put.Text[s:s]};         name: STRING = "<-Some.Communication.Error->"L;	Put.Text[s: "\nRFile: "L];        AddressTranslation.PrintError[error: errorRecord, proc: sProc];         ERROR MFile.Error[NIL, addressTranslationError 	  ! MFile.NameForError => RESUME[name]]}].addr;    «FOR c: Connection ¬ conn.link, c.link UNTIL c = NIL DO      IF c.cH.remote.host = addr.host AND c.cH.remote.net = addr.net THEN  {        IF c.process # NIL THEN {Process.Abort[c.process]; c.process ¬ NIL};        c.refcount ¬ c.refcount + 1; 	RETURN[c]};      ENDLOOP;»    cH ¬ Courier.Create[      remote: addr,      programNumber: programNumber,      versionNumber: versionNumber,      zone: z,      classOfService: transactional !        Courier.Error => CourierError[errorCode];        Courier.VersionMismatch => GOTO failed];    newConn ¬ z.NEW[ConnectionObject ¬ [      cH: cH, name: String.CopyToNewString[host, z],       link: conn.link]];    conn.link ¬ newConn;    EXITS failed => RETURN[NIL]    END;    ReleaseConnection: ENTRY PROCEDURE [conn: Connection, oldConn: Connection] =    BEGIN ENABLE UNWIND => NULL;    IF (oldConn.refcount ¬ oldConn.refcount - 1) # 0 THEN RETURN;    IF oldConn.process = NIL THEN      Process.Detach[oldConn.process ¬ FORK DeleteConnection[conn, oldConn]];    END;    fiveMinutes: CONDITION ¬ [timeout: Process.SecondsToTicks[5*60]];  DeleteConnection: ENTRY PROCEDURE [conn: Connection, oldConn: Connection] =    BEGIN ENABLE UNWIND => NULL;    WAIT fiveMinutes[!ABORTED => GOTO exit];    IF oldConn.refcount # 0 THEN RETURN;    FOR c: Connection ¬ conn, c.link UNTIL c.link = NIL DO      IF c.link = oldConn THEN {c.link ¬ oldConn.link; EXIT};      ENDLOOP;    Courier.Delete[oldConn.cH ! Courier.Error => CONTINUE];    z.FREE[@oldConn.name];    z.FREE[@oldConn];    EXITS exit => NULL;    END;    -- utilities  ParseName: PROCEDURE [name: LONG STRING, localName: STRING, host: LONG STRING, localHost: STRING] =    BEGIN    active: STRING;    IF host # NIL THEN String.AppendString[localHost, host];    FOR i: CARDINAL IN [0..name.length) DO      SELECT name[i] FROM        '[, '{ => {active ¬ localHost; active.length ¬ 0};	'], '} => {active ¬ localName; active.length ¬ 0};	ENDCASE => String.AppendChar[active, name[i]];      ENDLOOP;    END;    Propagate: PROCEDURE [errorNumber: CARDINAL, arguments: Courier.Arguments] =    BEGIN    args: RFileOps.ErrorArgs;    name: STRING = "<-remote-file->"L;    SELECT errorNumber FROM      RFileOps.errorMFileError => {        arguments[[@args, RFileOps.DescribeErrorArgs]];        ERROR MFile.Error[NIL, args.errorCode !	  MFile.NameForError => RESUME[name]]};      ENDCASE => ERROR;    END;  ErrorOther: PROCEDURE [code: MFile.ErrorCode] =    BEGIN    name: STRING = "<-Some.Communication.Error->"L;    Put.Text[s: "\nRFile: "L];    Put.Text[s: SELECT code FROM      connectionSuspended => "NetworkStream.ConnectionSuspended"L,      courierError => "Courier.VersionMismatch"L,      ENDCASE => "?"];    ERROR MFile.Error[NIL, code ! MFile.NameForError => RESUME[name]];    END;  CourierError: PROCEDURE [code: Courier.ErrorCode] =    BEGIN    name: STRING = "<-Courier.Error->"L;    Put.Text[s: "\nRFile: Courier.Error["L];    Put.Text[s: SELECT code FROM      transmissionMediumHardwareProblem => "transmissionMediumHardwareProblem"L,      transmissionMediumUnavailable => "transmissionMediumUnavailable"L,      transmissionMediumNotReady => "transmissionMediumNotReady"L,      noAnswerOrBusy => "noAnswerOrBusy"L,      noRouteToSystemElement => "noRouteToSystemElement"L,      transportTimeout => "transportTimeout"L,      remoteSystemElementNotResponding => "remoteSystemElementNotResponding"L,      noCourierAtRemoteSite => "noCourierAtRemoteSite"L,      tooManyConnections => "tooManyConnections"L,      invalidMessage => "invalidMessage"L,      noSuchProcedureNumber => "noSuchProcedureNumber"L,      returnTimedOut => "returnTimedOut"L,      callerAborted => "callerAborted"L,      unknownErrorInRemoteProcedure => "unknownErrorInRemoteProcedure"L,      streamNotYours => "streamNotYours"L,      truncatedTransfer => "truncatedTransfer"L,      parameterInconsistency => "parameterInconsistency"L,      invalidArguments => "invalidArguments"L,      noSuchProgramNumber => "noSuchProgramNumber"L,      protocolMismatch => "protocolMismatch"L,      duplicateProgramExport => "duplicateProgramExport"L,      noSuchProgramExport => "noSuchProgramExport"L,      invalidHandle => "invalidHandle"L,      noError => "noError"L,      ENDCASE => "?"L];    Put.Char[char: ']];    ERROR MFile.Error[NIL, courierError ! MFile.NameForError => RESUME[name]];    END;  -- the RFile interface  Acquire: PUBLIC PROCEDURE[    name: LONG STRING, access: MFile.Access ¬ readOnly, host: LONG STRING]    RETURNS [Handle] =    BEGIN    conn: Connection;    localHost: STRING = [50];    localName: STRING = [100];    handle: RFObject;    ParseName[name, localName, host, localHost];    conn ¬ FindConnection[@connList, localHost];    IF conn = NIL THEN ErrorOther[courierError];    CallAcquire[conn, [«localName» name, access, userName], @handle !      UNWIND => ReleaseConnection[@connList, conn]];    RETURN[AddObject[@connList, z.NEW[Object ¬ [handle, conn]]]]    END;    CallAcquire: ENTRY PROCEDURE [    conn: Connection, args: RFileOps.AcquireArgs, handle: RFHandle]  =    BEGIN ENABLE UNWIND => NULL;    [] ¬ Courier.Call[      cH: conn.cH,      timeoutInSeconds: acquireTimeout,      procedureNumber: RFileOps.procAcquire,      arguments: [@args, RFileOps.DescribeAcquireArgs],      results: [handle, RFileOps.DescribeHandle] !        Courier.Error => CourierError[errorCode];        Courier.VersionMismatch => ErrorOther[courierError];        Courier.RemoteErrorSignalled => Propagate[errorNumber, arguments]];    END;    Release: PUBLIC PROCEDURE[file: Handle] =    BEGIN    CallRelease[file.conn, @file.handle ! UNWIND => {      ReleaseConnection[@connList, file.conn];      RemoveObject[@connList, file];      z.FREE[@file]}];    ReleaseConnection[@connList, file.conn];    RemoveObject[@connList, file];    z.FREE[@file];    END;    CallRelease: ENTRY PROCEDURE [conn: Connection, handle: RFHandle]  =    BEGIN ENABLE UNWIND => NULL;    [] ¬ Courier.Call[      cH: conn.cH,      timeoutInSeconds: callTimeout,      procedureNumber: RFileOps.procRelease,      arguments: [handle, RFileOps.DescribeHandle] !        Courier.Error => CourierError[errorCode];        Courier.RemoteErrorSignalled => Propagate[errorNumber, arguments]];    END;    ReadLeaderPage: PUBLIC PROCEDURE [    h: Handle, lp: MFileOps.LeaderPage] =    BEGIN    CallReadLeaderPage[h.conn, @h.handle, lp];    IF MConvertLP.InOldFormat[lp] THEN      h.fid ¬ MConvertLP.ConvertToNewFormat[lp, File.nullID];    END;    CallReadLeaderPage: ENTRY PROCEDURE [    conn: Connection, handle: RFHandle,    lp: MFileOps.LeaderPage]  =    BEGIN ENABLE UNWIND => NULL;    StreamProc: PROCEDURE [cH: Courier.Handle] = {      UNTIL cH.sH.GetBlock[[LOOPHOLE[lp], 0, bpp]].why = normal DO NULL ENDLOOP};    [] ¬ Courier.Call[      cH: conn.cH,      timeoutInSeconds: callTimeout,      procedureNumber: RFileOps.procReadLeaderPage,      arguments: [handle, RFileOps.DescribeHandle],      streamCheckoutProc: StreamProc !        Courier.Error => CourierError[errorCode];        Courier.RemoteErrorSignalled => Propagate[errorNumber, arguments];	NetworkStream.ConnectionSuspended => ErrorOther[connectionSuspended]];    END;    WriteLeaderPage: PUBLIC PROCEDURE [    h: Handle, lp: MFileOps.LeaderPage] =    BEGIN    mustConvert: BOOLEAN = h.fid # ALL[0];    IF mustConvert THEN [] ¬ MConvertLP.ConvertToOldFormat[lp, h.fid];    CallWriteLeaderPage[h.conn, @h.handle, lp];    IF mustConvert THEN [] ¬ MConvertLP.ConvertToNewFormat[lp, File.nullID];    END;    CallWriteLeaderPage: ENTRY PROCEDURE [conn: Connection, handle: RFHandle, lp: MFileOps.LeaderPage]  =    BEGIN ENABLE UNWIND => NULL;    StreamProc: PROCEDURE [cH: Courier.Handle] = {      cH.sH.SetSST[RFileOps.dataSST];      cH.sH.PutBlock[[LOOPHOLE[lp], 0, bpp], TRUE]};    [] ¬ Courier.Call[      cH: conn.cH,      timeoutInSeconds: callTimeout,      procedureNumber: RFileOps.procWriteLeaderPage,      arguments: [handle, RFileOps.DescribeHandle],      streamCheckoutProc: StreamProc !        Courier.Error => CourierError[errorCode];        Courier.RemoteErrorSignalled => Propagate[errorNumber, arguments];	NetworkStream.ConnectionSuspended => ErrorOther[connectionSuspended]];    END;    ReadDataPages: PUBLIC PROCEDURE [    h: Handle, p: LONG POINTER, base: File.PageNumber, count: CARDINAL] =    BEGIN    IF count # 0 THEN DO      chunk: CARDINAL = MIN[count, chunkSize];      CallReadDataPages[h.conn, [h.handle, base, chunk], p !        Courier.RemoteErrorSignalled => Propagate[errorNumber, arguments]];      IF (count ¬ count - chunk) = 0 THEN EXIT;      base ¬ base + chunk;      p ¬ p + (chunk*wpp);      ENDLOOP;    END;    CallReadDataPages: ENTRY PROCEDURE [    conn: Connection, args: RFileOps.DataArgs, p: LONG POINTER]  =    BEGIN ENABLE UNWIND => NULL;    StreamProc: PROCEDURE [cH: Courier.Handle] = {      UNTIL cH.sH.GetBlock[[p, 0, args.count*bpp]].why = normal DO NULL ENDLOOP};    [] ¬ Courier.Call[      cH: conn.cH,      timeoutInSeconds: callTimeout,      procedureNumber: RFileOps.procReadDataPages,      arguments: [@args, RFileOps.DescribeDataArgs],      streamCheckoutProc: StreamProc !        Courier.Error => CourierError[errorCode];        Courier.RemoteErrorSignalled => Propagate[errorNumber, arguments];	NetworkStream.ConnectionSuspended => ErrorOther[connectionSuspended]];    END;    WriteDataPages: PUBLIC PROCEDURE [    h: Handle, p: LONG POINTER, base: File.PageNumber, count: CARDINAL] =    BEGIN    IF count # 0 THEN DO      chunk: CARDINAL = MIN[count, chunkSize];      CallWriteDataPages[h.conn, [h.handle, base, chunk], p !        Courier.RemoteErrorSignalled => Propagate[errorNumber, arguments]];      IF (count ¬ count - chunk) = 0 THEN EXIT;      base ¬ base + chunk;      p ¬ p + (chunk*wpp);      ENDLOOP;    END;    CallWriteDataPages: ENTRY PROCEDURE [    conn: Connection, args: RFileOps.DataArgs, p: LONG POINTER]  =    BEGIN ENABLE UNWIND => NULL;    StreamProc: PROCEDURE [cH: Courier.Handle] = {      cH.sH.SetSST[RFileOps.dataSST];      cH.sH.PutBlock[[p, 0, args.count*bpp], TRUE]};    [] ¬ Courier.Call[      cH: conn.cH,      timeoutInSeconds: callTimeout,      procedureNumber: RFileOps.procWriteDataPages,      arguments: [@args, RFileOps.DescribeDataArgs],      streamCheckoutProc: StreamProc !        Courier.Error => CourierError[errorCode];        Courier.RemoteErrorSignalled => Propagate[errorNumber, arguments];	NetworkStream.ConnectionSuspended => ErrorOther[connectionSuspended]];    END;    GetFullName: PUBLIC PROCEDURE [h: Handle, name: LONG STRING] =    BEGIN    remoteName: LONG STRING ¬ CallGetFullName[h.conn, @h.handle];    String.AppendChar[name, '[];    String.AppendString[name, h.conn.name];    String.AppendChar[name, ']];    String.AppendString[name, remoteName];    z.FREE[@remoteName];    END;    CallGetFullName: ENTRY PROCEDURE [    conn: Connection, handle: RFHandle] RETURNS [s: LONG STRING]  =    BEGIN ENABLE UNWIND => NULL;    [] ¬ Courier.Call[      cH: conn.cH,      timeoutInSeconds: callTimeout,      procedureNumber: RFileOps.procGetFullName,      arguments: [handle, RFileOps.DescribeHandle],      results: [@s, RFileOps.DescribeString] !        Courier.Error => CourierError[errorCode];        Courier.RemoteErrorSignalled => Propagate[errorNumber, arguments]];    END;    SwapNames: PUBLIC PROCEDURE[file1, file2: Handle] =    BEGIN    bogusRename: STRING = "<-Attempted.Rename.across.machines->"L;    IF file1.conn # file2.conn THEN ERROR MFile.Error[NIL, illegalName !      MFile.NameForError => RESUME[bogusRename]];    CallSwapNames[file1.conn, [file1.handle, file2.handle]];    END;    CallSwapNames: ENTRY PROCEDURE [    conn: Connection, args: RFileOps.SwapNamesArgs]  =    BEGIN ENABLE UNWIND => NULL;    [] ¬ Courier.Call[      cH: conn.cH,      timeoutInSeconds: callTimeout,      procedureNumber: RFileOps.procSwapNames,      arguments: [@args, RFileOps.DescribeSwapNamesArgs] !        Courier.Error => CourierError[errorCode];        Courier.RemoteErrorSignalled => Propagate[errorNumber, arguments]];    END;    Delete: PUBLIC PROCEDURE[file: Handle] =    BEGIN    CallDelete[file.conn, @file.handle];    ReleaseConnection[@connList, file.conn];    RemoveObject[@connList, file];    z.FREE[@file];    END;    CallDelete: ENTRY PROCEDURE [    conn: Connection, handle: RFHandle]  =    BEGIN ENABLE UNWIND => NULL;    [] ¬ Courier.Call[      cH: conn.cH,      timeoutInSeconds: callTimeout,      procedureNumber: RFileOps.procDelete,      arguments: [handle, RFileOps.DescribeHandle] !        Courier.Error => CourierError[errorCode];        Courier.RemoteErrorSignalled => Propagate[errorNumber, arguments]];    END;    Rename: PUBLIC PROCEDURE[file: Handle, newName: LONG STRING] =    BEGIN    CallRename[file.conn, [file.handle, newName]];    END;    CallRename: ENTRY PROCEDURE [    conn: Connection, args: RFileOps.RenameArgs]  =    BEGIN ENABLE UNWIND => NULL;    [] ¬ Courier.Call[      cH: conn.cH,      timeoutInSeconds: callTimeout,      procedureNumber: RFileOps.procRename,      arguments: [@args, RFileOps.DescribeRenameArgs] !        Courier.Error => CourierError[errorCode];        Courier.RemoteErrorSignalled => Propagate[errorNumber, arguments]];    END;    SetAccess: PUBLIC PROCEDURE[file: Handle, newAccess: MFile.Access] =    BEGIN    CallSetAccess[file.conn, [file.handle, newAccess], @file.handle];    END;    CallSetAccess: ENTRY PROCEDURE [    conn: Connection, args: RFileOps.SetAccessArgs, res: RFHandle] =    BEGIN ENABLE UNWIND => NULL;    [] ¬ Courier.Call[      cH: conn.cH,      timeoutInSeconds: callTimeout,      procedureNumber: RFileOps.procSetAccess,      arguments: [@args, RFileOps.DescribeSetAccessArgs],      results: [res, RFileOps.DescribeHandle] !        Courier.Error => CourierError[errorCode];        Courier.RemoteErrorSignalled => Propagate[errorNumber, arguments]];    END;    SetLength: PUBLIC PROCEDURE[file: Handle, newLength: LONG CARDINAL] =    BEGIN    CallSetLength[file.conn, [file.handle, newLength]];    END;    CallSetLength: ENTRY PROCEDURE [conn: Connection, args: RFileOps.SetLengthArgs] =    BEGIN ENABLE UNWIND => NULL;    [] ¬ Courier.Call[      cH: conn.cH,      timeoutInSeconds: callTimeout,      procedureNumber: RFileOps.procSetLength,      arguments: [@args, RFileOps.DescribeSetLengthArgs] !        Courier.Error => CourierError[errorCode];        Courier.RemoteErrorSignalled => Propagate[errorNumber, arguments]];    END;    UnlockLeader: PUBLIC PROCEDURE[file: Handle] =    BEGIN    CallUnlockLeader[file.conn, @file.handle];    END;    CallUnlockLeader: ENTRY PROCEDURE [conn: Connection, handle: RFHandle] =    BEGIN ENABLE UNWIND => NULL;    [] ¬ Courier.Call[      cH: conn.cH,      timeoutInSeconds: callTimeout,      procedureNumber: RFileOps.procUnlockLeader,      arguments: [handle, RFileOps.DescribeHandle] !        Courier.Error => CourierError[errorCode];        Courier.RemoteErrorSignalled => Propagate[errorNumber, arguments]];    END;  SetMinimumFileDataPages: PUBLIC PROCEDURE[file: Handle, pages: File.PageCount] =    BEGIN    CallSetMinimumFileDataPages[file.conn, [file.handle, pages]];    END;    CallSetMinimumFileDataPages: ENTRY PROCEDURE [    conn: Connection, args: RFileOps.SetMinimumFileDataPagesArgs] =    BEGIN ENABLE UNWIND => NULL;    [] ¬ Courier.Call[      cH: conn.cH,      timeoutInSeconds: callTimeout,      procedureNumber: RFileOps.procSetMinimumFileDataPages,      arguments: [@args, RFileOps.DescribeSetMinimumFileDataPagesArgs] !        Courier.Error => CourierError[errorCode];        Courier.RemoteErrorSignalled => Propagate[errorNumber, arguments]];    END;    -- PleaseRelease stuff, called from server    TryForRelease: ENTRY PROCEDURE [conn: Connection, rfH: RFHandle]    RETURNS [Handle, BOOLEAN] =    BEGIN    FOR h: Handle ¬ objectList, h.link UNTIL h = NIL DO      IF h.handle = rfH­ THEN RETURN[h, MFileOps.ReleaseRemoteFile[h]];      ENDLOOP;    RETURN[NIL, FALSE]    END;    CanYouRelease: PUBLIC PROCEDURE [handle: RFHandle]    RETURNS [choice: MFile.ReleaseChoice ¬ no] =    BEGIN    file: Handle;    released: BOOLEAN;    [file, released] ¬ TryForRelease[@connList, handle];    IF released THEN {      ReleaseConnection[@connList, file.conn];      RemoveObject[@connList, file];      z.FREE[@file];      choice ¬ goAhead};    END;    -- Credentials stuff  -- we'll have to decide if we ever want real authentication --  credentials: NSName.Credentials ¬ NSName.nullCredentials;--  verifier: NSName.Verifier ¬ NSName.nullVerifier;  userName: LONG STRING ¬ NIL;    agent: Supervisor.SubsystemHandle = Supervisor.CreateSubsystem[AgentProc];  AgentProc: Supervisor.AgentProcedure = {    SELECT event FROM      --EventTypes.primaryCredentials, EventTypes.domain, EventTypes.organization => GetCredentials[];      EventTypes.primaryCredentials => GetUserName[];      ENDCASE};  <<  CopyToNS: PROCEDURE [s: Profile.String] RETURNS [ns: NSName.String] =    BEGIN    Bytes: TYPE = RECORD[PACKED SEQUENCE COMPUTED CARDINAL OF [0..377B]];    IF s = NIL THEN RETURN[[bytes: NIL, length: 0, maxlength:0]];    ns ¬ [bytes: LOOPHOLE[z.NEW[Bytes[s.length]]],      length: s.length, maxlength: s.length];    FOR i: CARDINAL IN [0..s.length) DO      ns.bytes[i] ¬ s[i].ORD;      ENDLOOP;    END;  ConvertToNS: PROCEDURE [s: Profile.String] RETURNS [ns: NSName.String] =    BEGIN    IF s = NIL THEN RETURN[[bytes: NIL, length: 0, maxlength:0]];    RETURN[[bytes: LOOPHOLE[@s.text], length: s.length, maxlength: s.maxlength]];    END;    CopyFromNS: PROCEDURE [ns: NSName.String] RETURNS [s: LONG STRING] =    BEGIN    s ¬ z.NEW[StringBody[ns.length]];    s.length ¬ ns.length;    FOR i: CARDINAL IN [0..ns.length) DO      s[i] ¬ VAL[ns.bytes[i]];      ENDLOOP;    END;    GetCredentials: PROCEDURE =    BEGIN    simple: NSName.SimpleCredentials;    GetUser: PROCEDURE [name, password: Profile.String] = {      simple.local ¬ CopyToNS[name];      verifier ¬ NSName.EncodeSimpleVerifier[        NSName.HashPassword[ConvertToNS[password]]]};    GetDomain: PROCEDURE [domain: Profile.String] = {      simple.domain ¬ CopyToNS[domain]};    GetOrg: PROCEDURE [org: Profile.String] = {      simple.org ¬ CopyToNS[org]};    NSName.FreeCredentials[z, credentials];    Profile.GetUser[GetUser, none];    Profile.GetDefaultDomain[GetDomain];    Profile.GetDefaultOrganization[GetOrg];    credentials ¬ NSName.EncodeSimpleCredentials[z, simple];    z.FREE[@simple.local.bytes];    z.FREE[@simple.domain.bytes];    z.FREE[@simple.org.bytes];    END;    >>    GetUserName: PROCEDURE =    BEGIN    GetUser: PROCEDURE [name, password: Profile.String] = {      userName ¬ String.CopyToNewString[name, z]};    IF userName # NIL THEN String.FreeString[z, userName];    Profile.GetUser[GetUser, none];    END;    -- Initialization    Supervisor.AddDependency[    client: agent, implementor: Event.primaryCredentials];  Supervisor.AddDependency[    client: agent, implementor: Event.tajoDefaults];  Process.EnableAborts[@fiveMinutes];  GetUserName[];    END...
-- Copyright (C) 1982, 1983, 1987  by Xerox Corporation. All rights reserved. -- File; [Igor]<Emerson>FileSystem>Private>MScavengeImplB.mesa - last edit by-- PXK    ,	21-Jan-82 16:23:14-- LXR    ,	28-Dec-83 10:09:34-- DWE    	28-Jul-83 12:09:46-- RLC		 9-Jan-87 11:24:21-- RSV           3-Feb-87 22:21:52DIRECTORY  Environment USING [wordsPerPage, PageCount],  File USING [    File, GetAttributes, ID, MissingPages,     nullFile, nullID, PageNumber, Type, Unknown],  FileTypes USING [tUntypedFile],  MesaDEFileTypes USING [Directory, MesaDEFileType],  MFileOps USING [    GetName, InvalidLeader, LeaderPage, MapLeader, maxNameLength,    UnmapLeader],  MScavenge USING [Error],  MScavengeOps USING [Handle],  MUsage USING [mFileScavenge],  Runtime USING [CallDebugger],  Scavenger USING [ClearLog, FileEntry, GetLog, Header, MakeFileList],  Space USING [    CopyOut, GetMapUnitAttributes, Interval, LongPointerFromPage, Map, MapAt,    PageFromLongPointer, PageNumber, Unmap, UnmapAt, Window],    String USING [AppendLongNumber, AppendNumber, AppendOctal, AppendString],  Volume USING [GetAttributes, ID, nullID, systemID, Unknown];MScavengeImplB: PROGRAM  IMPORTS    File, MFileOps, MScavenge, Runtime, Scavenger, Space, String, Volume  EXPORTS MScavenge, MScavengeOps =  BEGIN  -- Global "Constants"  spaceHSize: CARDINAL = 1;  pilotLogSpaceSize: CARDINAL = 1;  -- Exported procedures  -- ClosePilotLogFile:  Delete the pilotLogFile space.  ClosePilotLogFile: PUBLIC PROC [pilotLogSpace: Space.Interval] =    BEGIN     pilotLogSpace.pointer ¬ Space.Unmap[pilotLogSpace.pointer];     END;  -- ClosePilotLogFile  -- GetWords:  Get the next count words from the Pilot scavenger log.  -- also used on the FileList produced by Scavenger.MakeFileList in  -- MScavengeImplA$ClearDirectories  GetWords: PUBLIC PROC [    toPointer, bufferPointer: LONG POINTER TO UNSPECIFIED,    currentWord, count: CARDINAL, pilotLogSpace: Space.Interval]    RETURNS [nextWord: CARDINAL] =    BEGIN    pilotLogWindow: Space.Window;    THROUGH [0..count) DO      IF currentWord >= (Environment.wordsPerPage*pilotLogSpaceSize) THEN {        pilotLogWindow ¬ Space.GetMapUnitAttributes[pilotLogSpace.pointer].window;        pilotLogWindow.base ¬ pilotLogWindow.base + pilotLogSpaceSize;        currentWord ¬ 0;        pilotLogSpace ¬ Space.UnmapAt[pilotLogSpace.pointer];        pilotLogSpace ¬ Space.MapAt[at: pilotLogSpace, window: pilotLogWindow,	  access: readOnly, usage: MUsage.mFileScavenge];        };      toPointer­ ¬ (bufferPointer + currentWord)­;      toPointer ¬ toPointer + 1;      currentWord ¬ currentWord + 1;      ENDLOOP;    nextWord ¬ currentWord;    END;  -- GetWords  -- HandleProblems:  Scan the Pilot Scavenger log for Problem entries, report  -- any found, and repair the damaged files if in repair mode.  -- There is now only one problem dataLost  HandleProblems: PUBLIC PROC [context: MScavengeOps.Handle] =    BEGIN    file: File.File;    fileEntryCopy: Scavenger.FileEntry;    fileEntry: POINTER TO Scavenger.FileEntry ¬ @fileEntryCopy;    nextWord: CARDINAL ¬ SIZE[Scavenger.Header];    numberOfLogEntries: LONG CARDINAL;    pilotLogPointer: LONG POINTER TO UNSPECIFIED;    pilotLogSpace: Space.Interval;    pageCopy: File.PageNumber;    page: POINTER TO File.PageNumber ¬ @pageCopy;    repairProblems: BOOLEAN;    spaceH: Space.Interval ¬ Space.Map[window: [file: File.nullFile, base: NULL, count: spaceHSize], usage: MUsage.mFileScavenge];    spacePage: Space.PageNumber;    type: File.Type;    incompleteLog: BOOLEAN;    spacePage ¬ Space.PageFromLongPointer[spaceH.pointer];    [pilotLogPointer, pilotLogSpace] ¬ OpenPilotLogFile[context];    [numberOfLogEntries, incompleteLog] ¬ CheckHeader[context, pilotLogPointer];    FOR counter: LONG CARDINAL ¬ 1, counter + 1 WHILE counter <= numberOfLogEntries DO      nextWord ¬ GetWords[        fileEntry, pilotLogPointer, nextWord, SIZE[Scavenger.FileEntry],        pilotLogSpace];      IF fileEntry.numberOfProblems # 0 THEN {        [file, type, repairProblems] ¬ LogInfo[context, fileEntry];        THROUGH [0..fileEntry.numberOfProblems) DO          nextWord ¬ GetWords[            page,  -- takes pointer to PageNumber	    pilotLogPointer, nextWord, 	    SIZE[File.PageNumber],            pilotLogSpace];          ProcessProblem[            context, fileEntry, pageCopy, --pass the real PageNumber	    type, spaceH, spacePage, repairProblems];          ENDLOOP};      ENDLOOP;    ClosePilotLogFile[pilotLogSpace];    --Do a Scavenger.ClearLog since this is the REAL Scavenger log and we're done with it    Scavenger.ClearLog[context.pilotLogFile];    spaceH.pointer ¬ Space.Unmap[spaceH.pointer];    IF incompleteLog THEN      Runtime.CallDebugger[        "Incomplete Pilot Scavenger log. Please reinvoke the Pilot scavenger and reboot."L];    END;  -- HandleProblems  -- LogFileCapability:  Log a File.File in the form:  -- "FID[aaaaaaB, bbbbbbB, ccccccB, ddddddB, eeeeeeB, ffffffB, ggggggB]"  LogFileCapability: PUBLIC PROC [context: MScavengeOps.Handle, file: File.File] =    BEGIN    fileCapString: STRING ¬      "FID[aaaaaaB, bbbbbbB, ccccccB, ddddddB, eeeeeeB, ffffffB, ggggggB]"L;    RepFID: TYPE = RECORD [ARRAY [0..sizeFID) OF CARDINAL];    rep: RepFID ¬ LOOPHOLE[file, RepFID];    sizeFID: CARDINAL = SIZE[File.File];    fileCapString.length ¬ 4;    FOR i: CARDINAL IN [0..sizeFID) DO      String.AppendOctal[fileCapString, rep[i]];      IF i ~= sizeFID - 1 THEN String.AppendString[fileCapString, ", "L];      ENDLOOP;    context.logProc[fileCapString];    END;  -- LogFileCapability      NeedsMScavenging: PUBLIC PROC [volume: Volume.ID]    RETURNS [scavenge: BOOLEAN] = {    scavengeLogHeader: LONG POINTER TO Scavenger.Header ¬ NIL;    scavengeLogSpace: Space.Interval;    scavengeLog: File.File ¬ Scavenger.GetLog[volume];    IF scavengeLog # File.nullFile THEN{      scavengeLogSpace ¬ Space.Map[	window: [scavengeLog, 0, pilotLogSpaceSize],	access: readOnly, usage: MUsage.mFileScavenge];      scavengeLogHeader ¬ LOOPHOLE[scavengeLogSpace.pointer];      -- IF scavengeLogHeader.logEntries # 0 then we must MScavenge      scavenge ¬ scavengeLogHeader.logEntries # 0}    ELSE      -- Scavenger.GetLog should always return a file. If not assume no scavenge is necessary.       scavenge ¬ FALSE};   -- OpenPilotLogFile:  Map the Pilot scavenger log into a space and return  -- a pointer to the header information.  OpenPilotLogFile: PUBLIC PROC [context: MScavengeOps.Handle]    RETURNS [      bufferPointer: LONG POINTER TO UNSPECIFIED, pilotLogSpace: Space.Interval] =    BEGIN    IF context.volume = Volume.nullID THEN context.volume ¬ Volume.systemID;    context.pilotLogFile ¬ File.nullFile;    context.pilotLogFile ¬ Scavenger.GetLog[      context.volume ! Volume.Unknown => CONTINUE];    IF context.pilotLogFile # File.nullFile THEN{      pilotLogSpace ¬ Space.Map[	window: [context.pilotLogFile, 0, pilotLogSpaceSize],	access: readOnly, usage: MUsage.mFileScavenge];      bufferPointer ¬ pilotLogSpace.pointer}    ELSE -- no Scavenger log       [bufferPointer, pilotLogSpace] ¬ MakeFileListIntoPilotLogFile[context];          END;  -- OpenPilotLogFile  MakeFileListIntoPilotLogFile: PUBLIC PROC [context: MScavengeOps.Handle]    RETURNS [      bufferPointer: LONG POINTER TO UNSPECIFIED, pilotLogSpace: Space.Interval] =    BEGIN    context.pilotLogFile ¬ Scavenger.MakeFileList[      context.volume, context.volume ! Volume.Unknown => CONTINUE];    IF context.pilotLogFile = File.nullFile THEN      ERROR MScavenge.Error[internalFailure];    -- for now, really should get Pilot to enumerate the IDs on this volume    pilotLogSpace ¬ Space.Map[      window: [context.pilotLogFile, 0, pilotLogSpaceSize],      access: readOnly, usage: MUsage.mFileScavenge];    bufferPointer ¬ pilotLogSpace.pointer;    END;  -- MakeFileListIntoPilotLogFile  -- Internal Procs  -- CheckHeader:  Check the entries in the Pilot Scavenger log header, and  -- return the number of files.  CheckHeader: PROC [    context: MScavengeOps.Handle, bufferPointer: LONG POINTER TO UNSPECIFIED]    RETURNS [numberOfLogEntries: LONG CARDINAL, incompleteLog: BOOLEAN] =    BEGIN    header: LONG POINTER TO Scavenger.Header ¬ LOOPHOLE[bufferPointer];    IF header.volume # context.volume THEN ERROR MScavenge.Error[internalFailure];    IF context.repair AND NOT header.repaired THEN      context.logProc[        "**Warning:  Pilot file system not repaired; continuing..."L];    IF header.incomplete THEN      context.logProc[        "**Warning:  Incomplete Pilot Scavenger log; continuing..."L];    RETURN[header.logEntries, header.incomplete];    END;  -- CheckHeader   -- LogFileCapAndNumber:  Log file capability and number of problems for a  -- file with problems:  -- "FID[aaaaaaB,bbbbbbB,ccccccB,ddddddB,eeeeeeB,fffffB, ggggggB] has n problems."  LogFileCapAndNumber: PROC [    context: MScavengeOps.Handle, file: File.File, numberOfProblems: CARDINAL] =    BEGIN    hasN: STRING ¬ " has XXXXX"L;    LogFileCapability[context, file];    IF numberOfProblems = 1 THEN context.logProc[" has 1 problem."L]    ELSE {      hasN.length ¬ 5;      String.AppendNumber[hasN, numberOfProblems, 10];      context.logProc[hasN];      context.logProc[" problems."L]};    END;  -- LogFileCapAndNumber  -- LogInfo:  Log appropriate information for a file with a problem.  LogInfo: PROC [    context: MScavengeOps.Handle, fileEntry: LONG POINTER TO Scavenger.FileEntry]    RETURNS [file: File.File, type: File.Type, repairProblems: BOOLEAN] =    BEGIN    name: STRING ¬ [MFileOps.maxNameLength];    repairProblems ¬ TRUE;    file ¬ [fileEntry.file, context.volume];    type ¬ FileTypes.tUntypedFile;    LogFileCapAndNumber[context, file, fileEntry.numberOfProblems];    context.logProc["File name:  "L];    name.length ¬ 0;    IF fileEntry.file # File.nullID THEN {      [type: type] ¬ File.GetAttributes[        file !        File.Unknown, Volume.Unknown => {          context.logProc[            "(Unknown:  File.Unknown; this file's problems cannot be repaired.)"L];          repairProblems ¬ FALSE;          CONTINUE}];      IF repairProblems THEN {        IF type NOT IN MesaDEFileTypes.MesaDEFileType THEN {          context.logProc[            "(None:  foreign file type; this file's problems will not be repaired.)"L];          repairProblems ¬ FALSE}        ELSE {          lp: MFileOps.LeaderPage ¬ NIL;          lp ¬ MFileOps.MapLeader[            file !            MFileOps.InvalidLeader, File.MissingPages => {              context.logProc["(Unknown:  leader page error.)"L]; CONTINUE}];          IF lp # NIL THEN {            MFileOps.GetName[lp, name]; MFileOps.UnmapLeader[lp]}}}}    ELSE context.logProc["(Unknown:  File.nullID)"L];    IF name.length # 0 THEN context.logProc[name];    context.logProc[""L];    END;  -- LogInfo  -- LogProblem:  Log appropriate information for a single Problem.  LogProblem: PROC [    context: MScavengeOps.Handle, page: File.PageNumber] =    BEGIN        dataLostString: STRING ¬ "  Lost data for page [aaaaaaaaaa]...   "L;        dataLostString.length ¬ 22;  -- truncate to just before "aaaaaaaaaa"    String.AppendLongNumber[dataLostString, page, 10];    String.AppendString[to: dataLostString, from: "]..."L];    context.logProc[dataLostString];    END;  -- LogProblem << -- MissingPages:  Take care of one missing Problem entry from the Pilot  -- Scavenger log.  MissingPages: PROC [    context: MScavengeOps.Handle, fileEntry: LONG POINTER TO Scavenger.FileEntry,    problem: LONG POINTER TO Scavenger.Problem, type: File.Type,    spacePage: Space.PageNumber, repairProblems: BOOLEAN] =    BEGIN    fudge: CARDINAL = 10;  -- fudge factor => avoid Volume.InsufficientSpace    spacePtr: LONG POINTER TO UNSPECIFIED;    succeeded: BOOLEAN;    WITH problem­ SELECT FROM      missing => {        IF context.repair AND repairProblems THEN {          IF ((count + fudge) > Volume.GetAttributes[context.volume].freePageCount)            OR (count >= unfillableHoleSize) THEN {            context.logProc[              "**NOT** replaced (too few free pages or too many missing pages)."L];            RETURN};          spacePtr ¬ Space.LongPointerFromPage[spacePage];          FOR i: LONG CARDINAL ¬ 0, i + 1 WHILE i < Environment.wordsPerPage DO            (spacePtr + i)­ ¬ 0; ENDLOOP;          FOR i: LONG CARDINAL ¬ 0, i + 1 WHILE i < count DO            succeeded ¬ FALSE;            THROUGH [0..retryCount) DO              IF RewritePage[                [fileEntry.file, context.volume], first + i, spacePage, context]                THEN {succeeded ¬ TRUE; EXIT};              ENDLOOP;            IF ~succeeded THEN {              context.logProc["could not be rewritten on page "L];              Format.LongDecimal[context.logProc, i];              succeeded ¬ ~Scavenger.ReplaceBadPage[                [fileEntry.file, context.volume], first + i, spacePage !                Scavenger.Error, File.Unknown, File.Error, Volume.InsufficientSpace                  => CONTINUE];              IF succeeded THEN context.logProc["; successfully replaced. "L]              ELSE {context.logProc["; could ***NOT*** be replaced. "L]; RETURN}};            ENDLOOP;          context.logProc["replaced."L]}        ELSE {          context.logProc[""L];          IF type IN MesaDEFileTypes.Directory THEN            ERROR MScavenge.Error[fatalBTreeErrorInCheckMode]}};      ENDCASE => ERROR;    END;  -- MissingPages>>  -- DataLostPage:  Take care of one missing Problem entry from the Pilot  -- Scavenger log. cobbed from old MissingPages. just writes a blank page to   -- fill the page for which the data was lost.  DataLostPage: PROC [    context: MScavengeOps.Handle, fileEntry: LONG POINTER TO Scavenger.FileEntry,    page: File.PageNumber,  type: File.Type,    spacePage: Space.PageNumber, repairProblems: BOOLEAN] =    BEGIN    fudge: CARDINAL = 10;  -- fudge factor => avoid Volume.InsufficientSpace    spacePtr: LONG POINTER TO UNSPECIFIED;    --succeeded: BOOLEAN;    dataLostSpace: Space.Interval;    written: Environment.PageCount;    IF context.repair AND repairProblems THEN {      IF ((fudge) > Volume.GetAttributes[context.volume].freePageCount) THEN {	context.logProc[	  "**NOT** replaced (too few free pages)."L];	RETURN};      spacePtr ¬ Space.LongPointerFromPage[spacePage];      --fill page with zeroes      FOR i: LONG CARDINAL ¬ 0, i + 1 WHILE i < Environment.wordsPerPage DO	(spacePtr + i)­ ¬ 0; ENDLOOP;      --write zeroed page	      dataLostSpace ¬ Space.Map[	window: [[fileEntry.file, context.volume], page, 1],	usage: MUsage.mFileScavenge];      written ¬ Space.CopyOut[        spacePtr,[[fileEntry.file, context.volume], page, 1]];      dataLostSpace.pointer ¬ Space.Unmap[dataLostSpace.pointer];	       context.logProc["replaced."L]}    ELSE {      context.logProc[""L];      IF type IN MesaDEFileTypes.Directory THEN	ERROR MScavenge.Error[fatalBTreeErrorInCheckMode]};    END;  -- DataLostPage  -- ProcessProblem:  Take care of one Problem entry from the Pilot Scavenger log.  ProcessProblem: PROC [    context: MScavengeOps.Handle, fileEntry: LONG POINTER TO Scavenger.FileEntry,    page: File.PageNumber, type: File.Type, spaceH: Space.Interval,    spacePage: Space.PageNumber, repairProblems: BOOLEAN] =    BEGIN    LogProblem[context, page];    DataLostPage[      context, fileEntry, page, type, spacePage, repairProblems];    END;  -- ProcessProblem       END. of MScavengeImplB-- RLC		 2-Sep-86 14:30:51  Mostly shot. Only remaining problem is dataLost-- 9-Jan-87 10:19:02 - rlc - delete all commented stuff-- 9-Jan-87 11:24:21 - rlc - add NeedsMScavenging EXPORTED to MScavenge
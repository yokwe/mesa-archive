-- File: MFile.mesa  Edited by--   PXK    ,	11-Dec-81 21:08:12--   LXR    ,	15-Oct-82 10:23:22--   RXJ     ,	 1-Jul-83 16:04:23-- Copyright (C) Xerox Corporation 1982. All rights reserved.DIRECTORY  Environment USING [Block],  System USING [gmtEpoch],  Time USING [Packed],  Volume USING [ID, nullID];MFile: DEFINITIONS =  BEGIN  Handle: TYPE = LONG POINTER TO Object;  Object: TYPE;  Type: TYPE = MACHINE DEPENDENT {unknown(0), text, binary, directory, null(255)};    ByteCount: TYPE =  LONG CARDINAL;  InitialLength: TYPE =  ByteCount;  dontCare: InitialLength = LAST[InitialLength];  maxNameLength: CARDINAL = 100;    searchPathNotUsed: CARDINAL = LAST[CARDINAL];  Access: TYPE = MACHINE DEPENDENT {    anchor(0), readOnly, readWrite, writeOnly, log, delete, rename, null};  ReleaseChoice: TYPE = {later, no, goAhead, allowRename};  PleaseReleaseProc: TYPE = PROCEDURE [    file: MFile.Handle, instanceData: LONG POINTER]    RETURNS [ReleaseChoice];  ReleaseData: TYPE = RECORD [    proc: PleaseReleaseProc ¬ NIL,    clientInstanceData: LONG POINTER ¬ NIL];      ErrorCode: TYPE = MACHINE DEPENDENT {    noSuchFile(0), conflictingAccess, insufficientAccess,     directoryFull, directoryNotEmpty,    illegalName, noSuchDirectory, noRootDirectory,       nullAccess, protectionFault, directoryOnSearchPath, illegalSearchPath,    volumeNotOpen, volumeReadOnly, noRoomOnVolume, noSuchVolume, crossingVolumes,    fileAlreadyExists, fileIsRemote, fileIsDirectory, invalidHandle,     courierError, addressTranslationError, connectionSuspended,    other(255)};  Error: ERROR [file: MFile.Handle, code: ErrorCode];  NameForError: SIGNAL RETURNS [errorName: LONG STRING];  AppendErrorMessage: PROCEDURE [msg: LONG STRING, code: ErrorCode, file: Handle];   -- getting and releasing files    dontRelease: ReleaseData = [];  Acquire: PROCEDURE [    name: LONG STRING, access: Access, release: ReleaseData,      mightWrite: BOOLEAN ¬ FALSE, initialLength: InitialLength ¬ dontCare,     type: Type ¬ unknown]    RETURNS [Handle];  AcquireTemp: PROCEDURE [    type: Type, initialLength: InitialLength ¬ dontCare,    volume: Volume.ID ¬ Volume.nullID] RETURNS [Handle];  Log: PROCEDURE [    name: LONG STRING, release: ReleaseData,     initialLength: InitialLength ¬ dontCare]     RETURNS [Handle];  ReadOnly: PROCEDURE [name: LONG STRING, release: ReleaseData,     mightWrite: BOOLEAN ¬ FALSE]     RETURNS [Handle];  ReadWrite: PROCEDURE [    name: LONG STRING, release: ReleaseData, type: Type,     initialLength: InitialLength ¬ dontCare]     RETURNS [Handle];  WriteOnly: PROCEDURE [    name: LONG STRING, release: ReleaseData, type: Type,     initialLength: InitialLength ¬ dontCare]     RETURNS [Handle];  DeleteWhenReleased: PROCEDURE [file: Handle];  Delete: PROCEDURE [file: Handle];  Release: PROCEDURE [file: Handle];    CopyFileHandle: PROCEDURE [    file: Handle, release: ReleaseData, access: Access ¬ null]    RETURNS [Handle];  SameFile: PROCEDURE [file1, file2: Handle] RETURNS [BOOLEAN];  GetAccess: PROCEDURE [file: Handle] RETURNS [access: Access];  GetReleaseData: PROCEDURE [file: Handle] RETURNS [release: ReleaseData];  SetAccess: PROCEDURE [file: Handle, access: Access];  SetReleaseData: PROCEDURE [file: Handle, release: ReleaseData];  -- directory manipulation    EnumerationType: TYPE = {filesOnly, directoriesOnly, fileAndDirectories};  EnumerateProc: TYPE = PROCEDURE [    name, fullName: LONG STRING, fileProc: FileAcquireProc, type: Type,    spIndex: CARDINAL]    RETURNS [done: BOOLEAN ¬ FALSE];  FileAcquireProc: TYPE = PROCEDURE [access: Access, release: ReleaseData]    RETURNS [Handle];  SearchPath: TYPE = LONG POINTER TO SearchPathObject;  SearchPathObject: TYPE = RECORD [    length: CARDINAL,    directories: SEQUENCE l:CARDINAL OF LONG STRING];  EnumerateState: TYPE = LONG POINTER TO EnumRec;  EnumRec: TYPE;      Copy: PROCEDURE [file: Handle, newName: LONG STRING];  CreateDirectory: PROCEDURE [dir: LONG STRING];  EnumerateDirectory: PROCEDURE [name: LONG STRING, proc: EnumerateProc, which: EnumerationType];  FreeSearchPath: PROCEDURE [SearchPath];  GetNextHandleForReading: PROCEDURE [      filter, name: LONG STRING, release: ReleaseData, lastState: EnumerateState, stopNow: BOOLEAN ¬ FALSE]       RETURNS [file: Handle, state: EnumerateState];  -- make sure that you call in with stopNow = TRUE to release resources if quitting enumeration early  GetSearchPath: PROCEDURE RETURNS [SearchPath];  Rename: PROCEDURE [file: Handle, newName: LONG STRING];  SetSearchPath: PROCEDURE [SearchPath] RETURNS [succeeded: BOOLEAN ¬ TRUE];  SwapNames: PROCEDURE [f1, f2: Handle];    ValidFilename: PROCEDURE [name: LONG STRING] RETURNS [ok: BOOLEAN];  CompleteFilename: PROCEDURE [name, addedPart: LONG STRING]    RETURNS [exactMatch: BOOLEAN, matches: CARDINAL];  ComputeFileType: PROCEDURE [file: Handle] RETURNS [type: Type];      -- change notification   Filter: TYPE = RECORD [    name: LONG STRING ¬ NIL,    type: Type ¬ null,    access: Access];      NotifyProc: TYPE = PROCEDURE [    name: LONG STRING, file: Handle, clientInstanceData: LONG POINTER]     RETURNS [removeNotifyProc: BOOLEAN ¬ FALSE];    AddNotifyProc: PROCEDURE [    proc: NotifyProc, filter: Filter, clientInstanceData: LONG POINTER];  RemoveNotifyProc: PROCEDURE [    proc: NotifyProc, filter: Filter, clientInstanceData: LONG POINTER];  -- file properties    Property: TYPE = RECORD[property: CARDINAL];  PropertyError: ERROR [code: PropertyErrorCode];  PropertyErrorCode: TYPE = {noSuchProperty, noRoomInPropertyList, insufficientSpaceForProperty, wrongSize};    GetVolume: PROCEDURE [file: Handle] RETURNS [Volume.ID];  GetDirectoryName: PROCEDURE [file: Handle, name: LONG STRING];  GetFullName: PROCEDURE [file: Handle, name: LONG STRING];  GetProperties: PROCEDURE [file: Handle, name: LONG STRING ¬ NIL]    RETURNS [      create, write, read: Time.Packed,      length: ByteCount, type: Type,       deleteProtected, writeProtected, readProtected: BOOLEAN];  GetCreateDate: PROCEDURE [file: Handle] RETURNS [create: Time.Packed];  GetTimes: PROCEDURE [file: Handle] RETURNS [create, write, read: Time.Packed];  GetType: PROCEDURE [file: Handle] RETURNS [type: Type];  GetLength: PROCEDURE [file: Handle] RETURNS [ByteCount];  GetProtection: PROCEDURE [file: Handle]     RETURNS [deleteProtected, writeProtected, readProtected: BOOLEAN];  SetProperties: PROCEDURE [      file: Handle, create, write, read: Time.Packed ¬ System.gmtEpoch,      length: ByteCount, type: Type,       deleteProtected, writeProtected, readProtected: BOOLEAN ¬ FALSE];  SetTimes: PROCEDURE [file: Handle, create, read, write: Time.Packed ¬ System.gmtEpoch];  SetType: PROCEDURE [file: Handle, type: Type];  SetLength: PROCEDURE [file: Handle, length: ByteCount];  SetDeleteProtect: PROCEDURE [file: Handle, deleteProtected: BOOLEAN];  SetWriteProtect: PROCEDURE [file: Handle, writeProtected: BOOLEAN];  SetReadProtect: PROCEDURE [file: Handle, readProtected: BOOLEAN];  SetProtection: PROCEDURE [    file: Handle, deleteProtected, writeProtected, readProtected: BOOLEAN ¬ FALSE];    AddProperty: PROCEDURE [file: Handle, property: Property, maxLength: CARDINAL];  CopyProperties: PROCEDURE [from, to: Handle];  GetProperty: PROCEDURE [file: Handle, property: Property, block: Environment.Block]    RETURNS [length: CARDINAL];  RemoveProperty: PROCEDURE [file: Handle, property: Property];  RemoveProperties: PROCEDURE [file: Handle];  SetProperty: PROCEDURE [file: Handle, property: Property, block: Environment.Block];  InitializeFileSystem: PROCEDURE;    END. of MFile  
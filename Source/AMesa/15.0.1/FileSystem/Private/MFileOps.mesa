-- Copyright (C) 1981, 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- File: MFileOps.mesa - edited by-- LXR    ,	 5-Dec-83 13:16:44-- PXK    ,	11-Dec-81 21:52:52-- RXJ     ,	14-Jul-82 15:22:38-- BTL  ,	25-Aug-82 11:59:47-- KAM  ,	13-Jul-84 10:48:22DIRECTORY  BTree USING [maxNameLength],  Environment USING [Byte, bytesPerPage],  File USING [File, ID, nullFile, PageCount],  MFile USING [    Access, Handle, InitialLength, Property, ReleaseData, Type],  RFile USING [Handle],  Space USING [Interval],  Time USING [Packed],  Volume USING [ID];MFileOps: DEFINITIONS =  BEGIN    -- the following items should be used only by MFileImplE  fHandleLock: MONITORLOCK;  fHandles: FHandle;    NotifyAccess: TYPE = ARRAY MFile.Access OF BOOLEAN;    Location: TYPE = {local, remote};  filePassword: CARDINAL = 031281;  Handle: TYPE = LONG POINTER TO Object;  Object: TYPE = RECORD [    access: MFile.Access ¬ null,    protectedSP: BOOLEAN ¬ FALSE,    fo: FHandle,    password: CARDINAL ¬ filePassword,    next: Handle ¬ NIL, -- list of Objects sharing same FileObject,    length: LONG CARDINAL ¬ 0,    release: MFile.ReleaseData ¬ []];      FHandle: TYPE = LONG POINTER TO FileObject;  FileObject: TYPE = RECORD [    tempFile: BOOLEAN ¬ FALSE,    lengthChanged: BOOLEAN ¬ FALSE,    fileIsDeleted: BOOLEAN ¬ FALSE,    notifyAccess, copy: NotifyAccess ¬ ALL[FALSE],    next: FHandle ¬ NIL,      -- list of all FileObjects    notifyList: FHandle ¬ NIL, -- list of FileObjects that have been released    freeList: Handle ¬ NIL,   -- list of Objects sharing this FileObject    refCount: CARDINAL ¬ 1,    lp: LeaderPage ¬ NIL,    chainLock: MONITORLOCK ¬ [],    leaderPageLock: MONITORLOCK ¬ [],    condition: CONDITION,    minimumFileDataPages: File.PageCount ¬ 0,    readLengthForLog: LONG CARDINAL ¬ 0,    location: FileLoc];        FileLocHandle: TYPE = LONG POINTER TO FileLoc;  FileLoc: TYPE = RECORD [    SELECT type: Location FROM      local => [f: File.File ¬ File.nullFile],      remote => [h: RFile.Handle],      ENDCASE];  leaderVersionID: CARDINAL = 07043;  validityCheckValue: CARDINAL = 026165B;  leaderPages: CARDINAL = 1;  maxNameLength: CARDINAL = BTree.maxNameLength;  LeaderProperty: TYPE = RECORD [    property: MFile.Property,    value: LeaderPropertyValue];  LeaderPropertyValue: TYPE = RECORD [    length, maxlength: Environment.Byte,    bytes: PACKED ARRAY [0..0) OF Environment.Byte];      LeaderPage: TYPE = LONG POINTER TO LeaderPageObject;  LeaderPageObject: TYPE = MACHINE DEPENDENT RECORD [     fp: FixedProperties,     props: ARRAY [0..0) OF LeaderProperty];  fixedPropertiesSize: CARDINAL = SIZE[FixedProperties];  FixedProperties: TYPE = MACHINE DEPENDENT RECORD [    versionID: CARDINAL,    dir: File.ID,    dirInfo: DirInfo ¬ [],    create, write, read: Time.Packed,    length: LONG CARDINAL,    freeWords: Environment.Byte,    extraProps: Environment.Byte ¬ 0,    validityCheck: WORD ¬ validityCheckValue,    name: LeaderPropertyValue];     DirInfo: TYPE = MACHINE DEPENDENT RECORD [    type: MFile.Type ¬ null,    deleteProtect, readProtect, writeProtect, dirProtect: BOOLEAN ¬ FALSE,    spare1: BOOLEAN ¬ FALSE,    pad: [0..7B] ¬ 0];    RootFile: TYPE = LONG POINTER TO RootFileObject;  RootFileObject: TYPE = MACHINE DEPENDENT RECORD [    changing: CARDINAL,    rootDirectory: File.ID];  InvalidLeader: SIGNAL;  CopyString: PROCEDURE [s: LONG STRING] RETURNS [ns: LONG STRING];  FreeString: PROCEDURE [s: LONG STRING];  GetCapa: PROCEDURE [file: MFile.Handle] RETURNS [File.File];  GetFilePart: PROCEDURE [from, to: LONG STRING];  GetName: PROCEDURE [lp: LeaderPage, name: LONG STRING];  SetMinimumFileDataPages: PROCEDURE [file: MFile.Handle, pages: File.PageCount];  SetName: PROCEDURE [fo: FHandle, name: LONG STRING];  SetDir: PROCEDURE [fo: FHandle, dir: File.ID];  GetReadLengthForLog: PROCEDURE [file: MFile.Handle] RETURNS [length: LONG CARDINAL];  SetReadLengthForLog: PROCEDURE [file: MFile.Handle, length: LONG CARDINAL];  InitLeader: PROCEDURE [lp: LeaderPage, dirID: File.ID, type: MFile.Type, name: LONG STRING, initialSizeHint: MFile.InitialLength];  MapLeader: PROCEDURE [file: File.File, readOnly: BOOLEAN ¬ FALSE]     RETURNS [lp: LeaderPage];  UnmapLeader: PROCEDURE [lp: LeaderPage];  ForceOutLeader: PUBLIC PROCEDURE [lp: LeaderPage];    ValidateHandle: PROCEDURE [file: MFile.Handle];  NoteCaller: PROCEDURE [p: PROGRAM] RETURNS [LONG POINTER];  Match: PROCEDURE [    file: LONG STRING, fileIndex: CARDINAL, mask: LONG STRING,     maskIndex: CARDINAL, posToBeFound: CARDINAL]    RETURNS [outcome: BOOLEAN, correspondingingPos: CARDINAL];  -- returns FHandle last given to proc if proc stops enumeration (returns TRUE)   EnumerateFHandles: PROCEDURE [       proc: PROCEDURE [MFileOps.FHandle] RETURNS [BOOLEAN]]    RETURNS [MFileOps.FHandle];   -- returns Handle last given to proc if proc stops enumeration (returns TRUE)   EnumerateFreeList: PROCEDURE [       fo: MFileOps.FHandle, proc: PROCEDURE [MFileOps.Handle] RETURNS [BOOLEAN]]    RETURNS [MFileOps.Handle];   -- reorg    AskPilotToMakeTemp: PROCEDURE [fo: FHandle, file: File.File];  AskPilotToMakePermanent: PROCEDURE [fo: FHandle, file: File.File];    Compatibility: TYPE = {ok, pokeOnce, nope};  GetLeader: PROCEDURE RETURNS [space: Space.Interval, lp: LeaderPage];  GetObject: PROCEDURE [name: LONG STRING, access: MFile.Access,    initialLength: MFile.InitialLength, type: MFile.Type, mightWrite: BOOLEAN]     RETURNS [fo: FHandle, protectedSP: BOOLEAN];  heap: UNCOUNTED ZONE;  IncrementCeiling: PROCEDURE [pages: File.PageCount] RETURNS [File.PageCount] =     INLINE {RETURN[pages + MFileOps.leaderPages]};  IncrRefCount: PROCEDURE [fo: FHandle];    IsFileDeleted: PROCEDURE [fo: FHandle] RETURNS [BOOLEAN];   LockedGetName: PROCEDURE [fo: FHandle, name: LONG STRING];   LockedRename: PROCEDURE [file: Handle, newName: LONG STRING];   LockedSwapNames: PROCEDURE [f1, f2: Handle, volume: Volume.ID];   MakeTemp: PROCEDURE [file: Handle];    PageForBytes: PROCEDURE [bytes: LONG CARDINAL] RETURNS [File.PageCount] = INLINE    {RETURN[(bytes + Environment.bytesPerPage - 1)/Environment.bytesPerPage]};  PleaseReleaseRemoteFO: PROCEDURE [fo: FHandle] RETURNS [released: BOOLEAN];    ReleaseFO: PROCEDURE [fo: FHandle];  ReleaseObject: PROCEDURE [fo: FHandle, access: MFile.Access, doNotification: BOOLEAN];      ReleaseRemoteFile: PROCEDURE [h: RFile.Handle] RETURNS [released: BOOLEAN ¬ FALSE];      RemoteFile: PROCEDURE [file: MFile.Handle] RETURNS [BOOLEAN] = INLINE {    WITH LOOPHOLE[file, Handle].fo.location SELECT FROM      remote => RETURN[TRUE];      ENDCASE => RETURN[FALSE]};  RemoteHandle: PROCEDURE [file: MFile.Handle] RETURNS [RFile.Handle] = INLINE {    WITH LOOPHOLE[file, Handle].fo.location SELECT FROM      remote => RETURN[h];      ENDCASE => RETURN[NIL]};  RenameTemp: PROCEDURE [file: Handle, name: LONG STRING];  SetFileDataSize: PROCEDURE [id: File.File, dataPages: File.PageCount];  VolumeOpenForWrite: PROCEDURE [fo: FHandle] RETURNS [BOOLEAN];  END.
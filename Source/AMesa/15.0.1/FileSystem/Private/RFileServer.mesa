-- File: RFileServer.mesa - last edit:-- bjd                 10-Nov-87 16:32:41-- RKJ     	       29-Nov-83 17:51:29-- Copyright (C) 1983, 1984 , 1987, 1987, 1987 by Xerox Corporation. All rights reserved. DIRECTORY  Auth,  Courier,  Environment USING [bytesPerPage, wordsPerPage],  Exec USING [AddCommand, ExecProc, FreeTokenString, GetToken, OutputProc, RemoveCommand],  File USING [GetSize, PageNumber],  Format USING [Date, NetworkAddress, StringProc],  Heap USING [Create],  Inline USING [HighHalf, LowHalf],  MFile USING [    Access, Acquire, CopyFileHandle, Delete, Error, GetAccess, GetFullName,    GetLength, maxNameLength, PleaseReleaseProc, Release, ReleaseChoice,    Rename, SetAccess, SetLength, SwapNames],  MFileOps USING [    ForceOutLeader, GetCapa, Handle, Object, SetMinimumFileDataPages],  MSegment USING [    Address, Create, Delete, GetFile, GetFileBase, Handle, Pages, PleaseReleaseProc, Reset],  NSName,  NSString,  Process USING [priorityForeground, SetPriority],  ProcessOperations USING [Enter, Exit],  RFile,  RFileOps,  Stream USING [GetBlock, Handle, PutBlock, SetSST],  String USING [CopyToNewString, AppendChar, Copy],  StringLookUp USING [InTable, noMatch],   System USING [GetGreenwichMeanTime, GreenwichMeanTime, gmtEpoch];RFileServer: MONITOR  IMPORTS    Auth, Courier, Exec, File, Format, Heap, Inline, MFile, MFileOps, MSegment, NSString,    Process, ProcessOperations, RFileOps, Stream, String, StringLookUp, System  EXPORTS MFile, RFileOps =  BEGIN    -- Courier Defs  programNumber: CARDINAL = RFileOps.programNumber;  versionNumber: CARDINAL = RFileOps.versionNumber;    callTimeout: CARDINAL = 40;    -- Constants  maxSegmentPages: CARDINAL = 40;  swapUnitSize: CARDINAL = 5;    bpp: CARDINAL = Environment.bytesPerPage;    -- Global data  sessionID: System.GreenwichMeanTime = System.GetGreenwichMeanTime[];    z: UNCOUNTED ZONE = Heap.Create[initial: 3];    -- MFile  Object: PUBLIC TYPE = MFileOps.Object;    -- RFileOps  RFObject: PUBLIC TYPE = RECORD [    id: LONG CARDINAL,    data: LONG POINTER TO RFData];    RFHandle: TYPE = LONG POINTER TO RFObject;    RFData: TYPE = RECORD [    file: MFileOps.Handle ¬ NIL,    segment: MSegment.Handle ¬ NIL,    link: RFDataHandle ¬ NIL,    owningMachine: Courier.SystemElement,    owner: LONG STRING ¬ NIL,    time: System.GreenwichMeanTime ¬ System.GetGreenwichMeanTime[]];    RFDataHandle: TYPE = LONG POINTER TO RFData;    list: LONG POINTER TO RFData ¬ NIL;    AddToList: ENTRY PROCEDURE [p: RFDataHandle] =    BEGIN    p.link ¬ list;    list ¬ p;    END;    RemoveFromList: ENTRY PROCEDURE [p: RFDataHandle] =    BEGIN    IF list = p THEN {list ¬ p.link; RETURN};    FOR this: RFDataHandle ¬ list, this.link UNTIL this = NIL DO      IF this.link = p THEN {this.link ¬ p.link; EXIT};      ENDLOOP;    END;    Dispatcher: Courier.Dispatcher =    BEGIN ENABLE {      MFile.Error => {        args: RFileOps.ErrorArgs;        args.handle ¬ NIL;        args.errorCode ¬ code;        Courier.SignalRemoteError[          RFileOps.errorMFileError, [@args, RFileOps.DescribeErrorArgs] !	  Courier.Error => CONTINUE]};      Courier.Error => CONTINUE};    Process.SetPriority[Process.priorityForeground];    IF state = releaseOnly AND procedureNumber # RFileOps.procPleaseRelease THEN      ERROR Courier.NoSuchProcedureNumber;    SELECT procedureNumber FROM      RFileOps.procAcquire => -- provide backward compatibility        IF cH.versionNumber = versionNumber - 2 THEN 	 DoOldAcquire[arguments, results, cH]        ELSE DoAcquire[arguments, results, cH];      RFileOps.procRelease => DoRelease[arguments, results];      RFileOps.procReadLeaderPage => DoReadLeaderPage[arguments, results, cH];      RFileOps.procWriteLeaderPage => DoWriteLeaderPage[arguments, results, cH];      RFileOps.procReadDataPages => DoReadDataPages[arguments, results, cH];      RFileOps.procWriteDataPages => DoWriteDataPages[arguments, results, cH];      RFileOps.procGetFullName => DoGetFullName[arguments, results];      RFileOps.procSwapNames => DoSwapNames[arguments, results];      RFileOps.procDelete => DoDelete[arguments, results];      RFileOps.procRename => DoRename[arguments, results];      RFileOps.procSetAccess => DoSetAccess[arguments, results];      RFileOps.procSetLength => DoSetLength[arguments, results];      RFileOps.procUnlockLeader => DoUnlockLeader[arguments, results];      RFileOps.procSetMinimumFileDataPages =>        DoSetMinimumFileDataPages[arguments, results];      RFileOps.procPleaseRelease => DoPleaseRelease[arguments, results];      ENDCASE => ERROR Courier.NoSuchProcedureNumber;    END;    DoAcquire: PROCEDURE[    arguments: Courier.Arguments, results: Courier.Results, cH: Courier.Handle] =    BEGIN    access: MFile.Access;    args: RFileOps.AcquireArgs;    rfH: RFObject ¬ [sessionID, NIL];    arguments[[@args, RFileOps.DescribeAcquireArgs]];    access ¬ SELECT args.access FROM      log, writeOnly => readWrite      ENDCASE => args.access;    IF state = readOnly THEN SELECT access FROM      readOnly => NULL;      readWrite, rename, delete => ERROR MFile.Error[NIL, conflictingAccess];      ENDCASE;    rfH.data ¬ z.NEW[RFData ¬ [owningMachine: cH.remote]];    AcquirePathname[cH, args.fileName, access, @rfH];    rfH.data.owner ¬ String.CopyToNewString[args.userName, z];    rfH.data.segment ¬ CreateSegment[@rfH, access, args.access = writeOnly];    Courier.Free[      [@args, RFileOps.DescribeAcquireArgs], z];    AddToList[rfH.data];    [] ¬ results[[@rfH, RFileOps.DescribeHandle]];    END;    DoOldAcquire: PROCEDURE[    arguments: Courier.Arguments, results: Courier.Results, cH: Courier.Handle] =    BEGIN    access: MFile.Access;    args: RFileOps.OldAcquireArgs;    rfH: RFObject ¬ [sessionID, NIL];    cred: NSName.NameRecord;    arguments[[@args, RFileOps.DescribeOldAcquireArgs]];    access ¬ SELECT args.access FROM      log, writeOnly => readWrite      ENDCASE => args.access;    IF state = readOnly THEN SELECT access FROM      readOnly => NULL;      readWrite, rename, delete => ERROR MFile.Error[NIL, conflictingAccess];      ENDCASE;    cred ¬ DecodeSimpleCredentials[args.credentials !      NSNameError => CONTINUE];    rfH.data ¬ z.NEW[RFData ¬ [owningMachine: cH.remote]];    AcquirePathname[cH, args.fileName, access, @rfH];    rfH.data.owner ¬ CopyFromNS[cred.local];    rfH.data.segment ¬ CreateSegment[@rfH, access, args.access = writeOnly];    Courier.Free[      [@args, RFileOps.DescribeOldAcquireArgs], z];    AddToList[rfH.data];    [] ¬ results[[@rfH, RFileOps.DescribeHandle]];    END;      AcquirePathname: PROCEDURE [cH: Courier.Handle,    fileName: LONG STRING, access: MFile.Access, rfH: RFHandle] = {    tempName: STRING = [200];    IF cH.versionNumber = versionNumber THEN CopyString[tempName, fileName]    ELSE OldCopyString[tempName, fileName];    rfH.data.file ¬ MFile.Acquire[tempName, access,      [CallPleaseRelease, rfH.data] ! UNWIND => z.FREE[@rfH.data]];    };      CopyString: PROC [to, from: LONG STRING] = { -- throw away service name    add: BOOLEAN ¬ TRUE;    to.length ¬ 0;    FOR i: CARDINAL IN [0..from.length) DO      SELECT from[i] FROM        '[ => add ¬ FALSE;	'] => add ¬ TRUE;        ENDCASE => IF add THEN String.AppendChar[to, from[i]];      ENDLOOP;    };      OldCopyString: PROC [to, from: LONG STRING] = {    String.Copy[to, from];    };       NSNameError: ERROR = CODE;   DecodeSimpleCredentials: PUBLIC PROCEDURE [credentials: Auth.Credentials]      RETURNS [simpleCredentials: NSName.NameRecord] =      BEGIN      position: CARDINAL ¬ 0;  -- current position within dataBytes      dataBytes: LONG DESCRIPTOR FOR ARRAY OF UNSPECIFIED ¬ credentials.value;      ExtractString: PROCEDURE         RETURNS [s: NSName.String ¬ NSString.nullString] =         BEGIN         IF position >= LENGTH[dataBytes] THEN ERROR NSNameError;         s.length ¬ s.maxlength ¬ dataBytes[position];         IF s.length # 0 THEN s.bytes ¬ @dataBytes[position + 1];         position ¬ position + (s.length + 1)/2 + 1;         IF NOT NSString.WellFormed[s] THEN ERROR NSNameError         END;      IF Auth.GetFlavor[credentials] # simple THEN ERROR NSNameError;      IF BASE[dataBytes] = NIL AND LENGTH[dataBytes] = 0 THEN         -- for nullCredentials case:         RETURN [[NSString.nullString, NSString.nullString, NSString.nullString]];      simpleCredentials.org ¬ ExtractString[];      simpleCredentials.domain ¬ ExtractString[];      simpleCredentials.local ¬ ExtractString[];      IF position # LENGTH[dataBytes] THEN ERROR NSNameError      END;  CopyFromNS: PROCEDURE [ns: NSName.String] RETURNS [s: LONG STRING] =    BEGIN    s ¬ z.NEW[StringBody[ns.length]];    s.length ¬ ns.length;    FOR i: CARDINAL IN [0..ns.length) DO      s[i] ¬ VAL[ns.bytes[i]];      ENDLOOP;    END;    DoRelease: PROCEDURE[arguments: Courier.Arguments, results: Courier.Results] =    BEGIN    rfH: RFObject;    arguments[[@rfH, RFileOps.DescribeHandle]];    IF rfH.id # sessionID THEN MFile.Error[NIL, other];    IF rfH.data.segment # NIL THEN MSegment.Delete[rfH.data.segment]    ELSE MFile.Release[rfH.data.file];    RemoveFromList[rfH.data];    z.FREE[@rfH.data.owner];    z.FREE[@rfH.data];    [] ¬ results[];    END;    DoReadLeaderPage: PROCEDURE[arguments: Courier.Arguments, results: Courier.Results, cH: Courier.Handle] =    BEGIN    rfH: RFObject;    arguments[[@rfH, RFileOps.DescribeHandle]];    IF rfH.id # sessionID THEN MFile.Error[NIL, other];    UNTIL ProcessOperations.Enter[@rfH.data.file.fo.leaderPageLock] DO NULL ENDLOOP;    cH.sH.SetSST[RFileOps.dataSST];    cH.sH.PutBlock[[LOOPHOLE[rfH.data.file.fo.lp], 0, bpp], TRUE];    [] ¬ results[];    END;    DoWriteLeaderPage: PROCEDURE[arguments: Courier.Arguments, results: Courier.Results, cH: Courier.Handle] =    BEGIN    rfH: RFObject;    arguments[[@rfH, RFileOps.DescribeHandle]];    IF rfH.id # sessionID THEN MFile.Error[NIL, other];    UNTIL cH.sH.GetBlock[[LOOPHOLE[rfH.data.file.fo.lp], 0, bpp]].why = normal DO NULL ENDLOOP;    MFileOps.ForceOutLeader[rfH.data.file.fo.lp];    [] ¬ results[];    ProcessOperations.Exit[@rfH.data.file.fo.leaderPageLock];    END;    DoReadDataPages: PROCEDURE[arguments: Courier.Arguments, results: Courier.Results, cH: Courier.Handle] =    BEGIN    args: RFileOps.DataArgs;    rfH: RFHandle;    p: LONG POINTER;    arguments[[@args, RFileOps.DescribeDataArgs]];    rfH ¬ @args.handle;    IF rfH.id # sessionID THEN MFile.Error[NIL, other];    p ¬ CheckSegmentBounds[rfH.data.segment, args.base, args.count];     cH.sH.SetSST[RFileOps.dataSST];    cH.sH.PutBlock[[p, 0, args.count*bpp], TRUE];    [] ¬ results[];    END;    DoWriteDataPages: PROCEDURE[arguments: Courier.Arguments, results: Courier.Results, cH: Courier.Handle] =    BEGIN    args: RFileOps.DataArgs;    rfH: RFHandle;    p: LONG POINTER;    arguments[[@args, RFileOps.DescribeDataArgs]];    rfH ¬ @args.handle;    IF rfH.id # sessionID THEN MFile.Error[NIL, other];    IF MFile.GetAccess[rfH.data.file] # readWrite THEN      ERROR MFile.Error[NIL, insufficientAccess];    p ¬ CheckSegmentBounds[rfH.data.segment, args.base, args.count];    UNTIL cH.sH.GetBlock[[p, 0, args.count*bpp]].why = normal DO NULL ENDLOOP;    [] ¬ results[];    END;    DoGetFullName: PROCEDURE[arguments: Courier.Arguments, results: Courier.Results] =    BEGIN    name: LONG STRING ¬ [100];    rfH: RFObject;    arguments[[@rfH, RFileOps.DescribeHandle]];    IF rfH.id # sessionID THEN MFile.Error[NIL, other];    MFile.GetFullName[rfH.data.file, name];    [] ¬ results[[@name, RFileOps.DescribeString]];    END;    DoSwapNames: PROCEDURE[arguments: Courier.Arguments, results: Courier.Results] =    BEGIN    args: RFileOps.SwapNamesArgs;    rfH1, rfH2: RFHandle;    arguments[[@args, RFileOps.DescribeSwapNamesArgs]];    rfH1 ¬ @args.h1;    rfH2 ¬ @args.h2;    IF rfH1.id # sessionID OR rfH2.id # sessionID THEN MFile.Error[NIL, other];    MFile.SwapNames[rfH1.data.file, rfH2.data.file];    [] ¬ results[];    END;    DoDelete: PROCEDURE[arguments: Courier.Arguments, results: Courier.Results] =    BEGIN    rfH: RFObject;    arguments[[@rfH, RFileOps.DescribeHandle]];    IF rfH.id # sessionID THEN MFile.Error[NIL, other];    MFile.Delete[rfH.data.file];    RemoveFromList[rfH.data];    z.FREE[@rfH.data.owner];    z.FREE[@rfH.data];    [] ¬ results[];    END;    DoRename: PROCEDURE[arguments: Courier.Arguments, results: Courier.Results] =    BEGIN    args: RFileOps.RenameArgs;    rfH: RFHandle;    arguments[[@args, RFileOps.DescribeRenameArgs]];    rfH ¬ @args.handle;    IF rfH.id # sessionID THEN MFile.Error[NIL, other];    MFile.Rename[rfH.data.file, args.newName];    Courier.Free[      [@args, RFileOps.DescribeRenameArgs], z];    [] ¬ results[];    END;    DoSetAccess: PROCEDURE[arguments: Courier.Arguments, results: Courier.Results] =    BEGIN    args: RFileOps.SetAccessArgs;    rfH: RFHandle;    oldAccess: MFile.Access;    access: MFile.Access;    arguments[[@args, RFileOps.DescribeSetAccessArgs]];    rfH ¬ @args.handle;    IF rfH.id # sessionID THEN MFile.Error[NIL, other];    oldAccess ¬ MFile.GetAccess[rfH.data.file];    IF args.newAccess # oldAccess THEN {      IF rfH.data.segment # NIL THEN {        rfH.data.file ¬ MFile.CopyFileHandle[rfH.data.file, []];	MSegment.Delete[rfH.data.segment];	rfH.data.segment ¬ NIL};      access ¬ SELECT args.newAccess FROM        log, writeOnly => readWrite        ENDCASE => args.newAccess;      IF state = readOnly THEN SELECT access FROM        readOnly => NULL;        readWrite, rename, delete => ERROR MFile.Error[NIL, conflictingAccess];        ENDCASE;      MFile.SetAccess[rfH.data.file, access];      rfH.data.segment ¬ CreateSegment[rfH, access, args.newAccess = writeOnly]};    [] ¬ results[[rfH, RFileOps.DescribeHandle]];    END;    DoSetLength: PROCEDURE[arguments: Courier.Arguments, results: Courier.Results] =    BEGIN    args: RFileOps.SetLengthArgs;    rfH: RFHandle;    arguments[[@args, RFileOps.DescribeSetLengthArgs]];    rfH ¬ @args.handle;    IF rfH.id # sessionID THEN MFile.Error[NIL, other];    MFile.SetLength[rfH.data.file, args.newLength];    IF rfH.data.segment # NIL THEN MSegment.Reset[      segment: rfH.data.segment, pages: maxSegmentPages,      swapInfo: [uniform[swapUnitSize]]]    ELSE      rfH.data.segment ¬ CreateSegment[rfH, MFile.GetAccess[rfH.data.file], FALSE];    [] ¬ results[];    END;    DoUnlockLeader: PROCEDURE[arguments: Courier.Arguments, results: Courier.Results] =    BEGIN    rfH: RFObject;    arguments[[@rfH, RFileOps.DescribeHandle]];    IF rfH.id # sessionID THEN MFile.Error[NIL, other];    ProcessOperations.Exit[@rfH.data.file.fo.leaderPageLock];    [] ¬ results[];    END;    DoSetMinimumFileDataPages: PROCEDURE[arguments: Courier.Arguments, results: Courier.Results] =    BEGIN    args: RFileOps.SetMinimumFileDataPagesArgs;    rfH: RFHandle;    arguments[[@args, RFileOps.DescribeSetMinimumFileDataPagesArgs]];    rfH ¬ @args.handle;    IF rfH.id # sessionID THEN MFile.Error[NIL, other];    MFileOps.SetMinimumFileDataPages[rfH.data.file, args.pages];    IF rfH.data.segment # NIL THEN MSegment.Reset[      segment: rfH.data.segment, pages: maxSegmentPages,      swapInfo: [uniform[swapUnitSize]]]    ELSE      rfH.data.segment ¬ CreateSegment[rfH, MFile.GetAccess[rfH.data.file], FALSE];    [] ¬ results[];    END;    -- both ends of the PleaseRelease are in the server!    DoPleaseRelease: PROCEDURE[arguments: Courier.Arguments, results: Courier.Results] =    BEGIN    rfH: RFObject;    choice: MFile.ReleaseChoice ¬ no;    arguments[[@rfH, RFileOps.DescribeHandle]];    --sessionID is his, not ours!    --IF rfH.id # sessionID THEN MFile.Error[NIL, other];    choice ¬ RFileOps.CanYouRelease[@rfH];    [] ¬ results[[@choice, DescribeChoice]];    END;    CallPleaseRelease: MFile.PleaseReleaseProc =    BEGIN    rfH: RFObject;    cH: Courier.Handle;    choice: MFile.ReleaseChoice ¬ no;    rfH ¬ [sessionID, instanceData];    cH ¬ Courier.Create[      remote: rfH.data.owningMachine,      programNumber: programNumber,      versionNumber: versionNumber,      zone: z,      classOfService: transactional !        Courier.Error, Courier.VersionMismatch => GOTO failed];    [] ¬ Courier.Call[      cH: cH,      timeoutInSeconds: callTimeout,      procedureNumber: RFileOps.procPleaseRelease,      arguments: [@rfH, RFileOps.DescribeHandle],      results: [@choice, DescribeChoice] !        Courier.Error, Courier.VersionMismatch, Courier.RemoteErrorSignalled =>	  GOTO failed];    Courier.Delete[cH ! Courier.Error => CONTINUE];    IF choice = goAhead THEN {      RemoveFromList[rfH.data];      z.FREE[@rfH.data.owner];      z.FREE[@rfH.data]};    RETURN[choice];    EXITS failed => RETURN[no];    END;    SegmentRelease: MSegment.PleaseReleaseProc =    BEGIN    RETURN[CallPleaseRelease[NIL, instanceData]];    END;    -- Utilities    DescribeChoice: Courier.Description =    BEGIN    [] ¬ notes.noteSize[SIZE[MFile.ReleaseChoice]];    END;      CreateSegment: PROCEDURE [    rfH: RFHandle, access: MFile.Access, zapReadDate: BOOLEAN]    RETURNS [MSegment.Handle] =    BEGIN    IF zapReadDate THEN rfH.data.file.fo.lp.fp.read ¬ System.gmtEpoch;    IF access IN [readOnly..readWrite] THEN {      segmentPages: CARDINAL ¬ PagesForBytes[MFile.GetLength[rfH.data.file]];      IF segmentPages = 0 THEN        IF access = readWrite THEN MFileOps.SetMinimumFileDataPages[rfH.data.file, 1]	ELSE RETURN[NIL];      IF segmentPages > maxSegmentPages OR access = readWrite THEN        segmentPages ¬ maxSegmentPages;      RETURN[MSegment.Create[rfH.data.file, [SegmentRelease, rfH.data], 0, segmentPages, [uniform[swapUnitSize]]]]}    ELSE RETURN[NIL];    END;    CheckSegmentBounds: PROCEDURE [segment: MSegment.Handle, base: File.PageNumber, count: CARDINAL] RETURNS [p: LONG POINTER] =    BEGIN    segBase: File.PageNumber;    segCount: CARDINAL;    IF segment = NIL THEN ERROR MFile.Error[NIL, insufficientAccess];    segBase ¬ MSegment.GetFileBase[segment];    segCount ¬ Inline.LowHalf[MSegment.Pages[segment]];    IF segBase > base OR segBase+segCount < base+count THEN      BEGIN      file: MFileOps.Handle = MSegment.GetFile[segment];      filePages: File.PageNumber = File.GetSize[MFileOps.GetCapa[file]];      IF filePages-segCount <= base THEN segBase ¬ filePages-segCount      ELSE segBase ¬ base;      MSegment.Reset[        segment: segment, fileBase: segBase, pages: maxSegmentPages,	swapInfo: [uniform[swapUnitSize]]];      END;    p ¬ MSegment.Address[segment] + (base-segBase)*Environment.wordsPerPage;     END;    PagesForBytes: PROCEDURE [bytes: LONG CARDINAL] RETURNS [CARDINAL] =    BEGIN    IF Inline.HighHalf[bytes] > bpp THEN RETURN[LAST[CARDINAL]];    RETURN[Inline.LowHalf[(bytes+bpp-1)/bpp]];    END;    State: TYPE = {disconnected, releaseOnly, readOnly, readWrite};  state: State ¬ disconnected;    TurnOn: PUBLIC ENTRY PROCEDURE [newState: State] =    BEGIN    IF state = disconnected THEN      Courier.ExportRemoteProgram[        programNumber: programNumber,        versionRange: [versionNumber-2, versionNumber],        dispatcher: Dispatcher,        zone: z,        serviceName: "RFile"L,        classOfService: transactional];    state ¬ newState;    END;      TurnOff: PUBLIC ENTRY PROCEDURE =    BEGIN    IF state # disconnected THEN {      Courier.UnexportRemoteProgram[        programNumber: programNumber,        versionRange: [versionNumber-2, versionNumber]];      state ¬ disconnected};    END;          ShowHandles: ENTRY PROCEDURE[write: Format.StringProc] =    BEGIN    IF list = NIL THEN write["No remote files.\n"L]    ELSE FOR h: RFDataHandle ¬ list, h.link UNTIL h = NIL DO      name: STRING = [MFile.maxNameLength];      MFile.GetFullName[h.file, name];      write[name];      write[", "L];      IF h.owner # NIL THEN {write[h.owner]; write[", "L]};      Format.NetworkAddress[write, h.owningMachine, octal];      write[", "L];      Format.Date[write, h.time, dateTime];      write["\n"L];      ENDLOOP;    END;          SetServer: Exec.ExecProc =    BEGIN    MyCommands: TYPE = MACHINE DEPENDENT {      on(0), releaseOnly, readOnly, off, showHandles,      noMatch(StringLookUp.noMatch)};    DefinedOptions: TYPE = MyCommands[on..showHandles];    commandTable: ARRAY DefinedOptions OF LONG STRING ¬ [      on: "on"L, releaseOnly: "releaseOnly"L,  readOnly: "readOnly"L,      off: "off"L, showHandles: "showHandles"L];    index: MyCommands;    Write: Format.StringProc = Exec.OutputProc[h];    command, switches: LONG STRING ¬ NIL;    [command, switches] ¬ Exec.GetToken[h];    index ¬ LOOPHOLE[      StringLookUp.InTable[	key: command,	table: DESCRIPTOR[BASE[commandTable], LENGTH[commandTable]]]];    [] ¬ Exec.FreeTokenString[command];    [] ¬ Exec.FreeTokenString[switches];    SELECT index FROM      on => TurnOn[readWrite];      releaseOnly => TurnOn[releaseOnly];      readOnly => TurnOn[readOnly];      off => TurnOff[];      showHandles => ShowHandles[Write];      ENDCASE;    Write["Server is "L];    Write[SELECT state FROM      disconnected => "disconnected"L,      releaseOnly => commandTable[releaseOnly],      readOnly => commandTable[readOnly],      readWrite => "readWrite"L,      ENDCASE => "confused"L];    END;    UnloadServer: Exec.ExecProc =    BEGIN    Exec.RemoveCommand[h, "RFileServer.~"L];    TurnOff[];    END;    HelpServer: Exec.ExecProc =    BEGIN    Exec.OutputProc[h]["RFileServer commands are:  on           turn server on (read/write)  off          disconnect server  releaseOnly  turn server on to answer PleaseRelease requests only  readOnly     turn server on read only  showHandles  enumerate files currently held by remote machines"L];    END;    Init: PROCEDURE = {    TurnOn[releaseOnly];    Exec.AddCommand[name: "RFileServer.~"L, proc: SetServer, unload: UnloadServer, help: HelpServer]};    Init[];  END...
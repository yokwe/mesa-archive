-- Copyright (C) 1981, 1983 , 1986, 1987 by Xerox Corporation. All rights reserved. -- File: MLoaderImpl.mesa - last edit by-- PXK    	 9-Oct-81 11:57:58-- LXR    	 7-Nov-83 11:55:40-- JGS on	27-Jan-83 13:29:23-- DWE    	28-Jul-83 15:24:11-- AXD    	28-Oct-83 12:24:21-- Riggle.PA    12-Aug-86 16:00:42-- NFS		 4-Nov-87 11:03:11DIRECTORY  File: TYPE USING [File, nullFile],  FrameExtras,  Heap: TYPE USING [Create, Error],  LoadState, LoadStateFormat,  MFile: TYPE USING [    GetAccess, Handle, Release, PleaseReleaseProc, SetReleaseData],  MFileOps: TYPE USING [Handle],  MLoader: TYPE USING [ErrorCode, Options],  Runtime: TYPE USING [    ConfigError, InvalidGlobalFrame, IsBound, LoadConfig,    UnNewConfig, VersionMismatch],  Space: TYPE USING [InsufficientSpace],  SpecialRuntimeExtras,  Volume: TYPE USING [ReadOnly];MLoaderImpl: MONITOR IMPORTS FrameExtras, Heap, LoadState, MFile, Runtime, Space, SpecialRuntimeExtras, Volume   EXPORTS MLoader SHARES File =  BEGIN    -- Problem with unloading:  When loading a config with no control list,  -- Runtime.LoadConfig returns NIL.  Therefore, the MLoader object for the  -- config will have NIL for the program field.  So the procedures Unload  -- and HandleFromProgram won't work properly for such configs (NFS).    loaderPassword: CARDINAL = 03082;  Handle: TYPE = LONG POINTER TO Object;  Object: PUBLIC TYPE = RECORD [    password: CARDINAL ¬ loaderPassword,    file: MFile.Handle,    options: Options,    started: BOOLEAN,    next: Handle,    program: PROGRAM ¬ TRASH];  Options: TYPE = MLoader.Options;    Error: PUBLIC ERROR [code: MLoader.ErrorCode, string: LONG STRING] = CODE;  VersionMismatch: PUBLIC SIGNAL [module: LONG STRING] = CODE;    heap: UNCOUNTED ZONE = Heap.Create[initial: 1];  handles: Handle ¬ NIL;  -- procedures  Load: PUBLIC PROC [file: MFile.Handle, options: Options]    RETURNS [h: Handle ¬ NIL] = {    program: PROGRAM;    id: File.File;    AddHandle: ENTRY PROCEDURE =       BEGIN      h ¬ heap.NEW[Object ¬ [        options: options, file: file, started: FALSE, next: handles,        program: program]];      handles ¬ h;      END;    IF MFile.GetAccess[file] # readOnly THEN      ERROR Error[insufficientAccess, "Wrong access for file being loaded."L];    id ¬ WITH LOOPHOLE[file, MFileOps.Handle].fo.location SELECT FROM      local => f,      ENDCASE => File.nullFile;    program ¬ Runtime.LoadConfig[      file: id, offset: 1, codeLinks: options.codeLinks      ! Runtime.VersionMismatch => {SIGNAL VersionMismatch[module]; RESUME};	Runtime.ConfigError => ERROR Error[SELECT type FROM	  badCode => badCode,	  invalidConfig => invalidParameters,	  missingCode => missingCode,	  exportedTypeClash => exportedTypeClash,	  unknown => other,	  ENDCASE => other, NIL];	Volume.ReadOnly => IF options.codeLinks THEN {	  options.codeLinks ¬ FALSE; RETRY};	Space.InsufficientSpace => ERROR Error[gftFull, NIL];	Heap.Error => IF type = insufficientSpace THEN ERROR Error[gftFull, NIL]];    AddHandle[];    MFile.SetReleaseData[file, [MyRelease, h]]};       MyRelease: MFile.PleaseReleaseProc = {RETURN[allowRename]};      Run: PUBLIC PROC [file: MFile.Handle, options: Options] RETURNS [h: Handle] = {    h ¬ Load[file, options]; Start[h]};      Start: PUBLIC PROC [h: Handle] = {    IF h.password # loaderPassword THEN ERROR Error[other, "Invalid handle"L];    IF h.started THEN ERROR Error[alreadyStarted, "Already started"L];    IF Runtime.IsBound[LOOPHOLE[h.program]] THEN       START h.program [ ! Runtime.InvalidGlobalFrame =>         ERROR Error[other, "Invalid global frame"L]];    h.started ¬ TRUE};    RemoveHandle: ENTRY PROC [h: Handle] =     BEGIN    handle: Handle ¬ handles;    prev: Handle ¬ NIL;    DO      IF handle = NIL THEN EXIT; -- not in list, error condition?      IF handle = h THEN {        IF prev = NIL THEN handles ¬ h.next ELSE prev.next ¬ h.next;        EXIT};      prev ¬ handle;      handle ¬ handle.next;      ENDLOOP    END;  Unload: PUBLIC PROC [h: Handle] = {    IF h.password # loaderPassword THEN ERROR Error[other, "Invalid handle"L];    -- Can't unload if h.program = NIL (config with no control list)    IF h.program # NIL AND Runtime.IsBound[LOOPHOLE[h.program]] THEN      Runtime.UnNewConfig[LOOPHOLE[h.program]];    MFile.Release[h.file];    RemoveHandle[h];    heap.FREE[@h]};    HandleFromProgram: PUBLIC ENTRY PROC [prog: PROGRAM] RETURNS [h: Handle] = {    progIndex: LoadStateFormat.Index;    [] ¬ LoadState.LockBcdInfo[];    progIndex ¬ LoadState.GetModuleInfo[      FrameExtras.LongGFToGFTHandle[SpecialRuntimeExtras.GlobalFrameFromProgram[prog]]].index;    FOR h ¬ handles, h.next UNTIL h = NIL DO      -- h.program = NIL if it's a config with no control list.      -- Won't be able to find handle in this case.      IF h.program = NIL THEN LOOP;      IF LoadState.GetModuleInfo[         FrameExtras.LongGFToGFTHandle[SpecialRuntimeExtras.GlobalFrameFromProgram[h.program]]].index = progIndex        THEN EXIT;      ENDLOOP;    LoadState.UnlockBcdInfo[]};  END.
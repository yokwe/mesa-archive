-- File: BTreeImplA.mesa - last edit: -- KAM                 17-Apr-85 11:09:01-- PXK                 1-Oct-81 14:26:46-- LGR                 1-Nov-83 15:30:44-- WDE                 28-Jul-83 15:12:38-- Copyright (C) 1981, 1983, 1985 by Xerox Corporation. All rights reserved. DIRECTORY  BTree USING [maxNameLength, Tree, TreeObject, Value, ValueSize],  BTreeInternal USING [    bTreePage, Cache, emptySize, EntryHandle, EntryName, EntryPointer,    EntryPointerPointer, EntrySize, EntryValue, FirstEntry, FirstFreeEntry,    firstPagePointer, InternalValidateBTree, MapInternal, maxTreeSize,    NextEntry, nilPagePointer,    Overhead, PagePointerFromEntryHandle, PageHandle, PagePointer, PCache,    SnapShot, treeIncrement, TreeObject, ValuePointer],  ByteBlt USING [ByteBlt],  Environment USING [PageCount, wordsPerPage],  File USING [File, nullFile, SetSize],  Heap USING [Create],  Inline USING [BITAND, LongCOPY],  Space USING [ForceOut, Map, SetAccess, Unmap],  SpecialBTree USING [Unmapped],  String USING [LowerCase],  Volume USING [GetStatus, InsufficientSpace, systemID, ID];BTreeImplA: MONITOR LOCKS tree USING tree: Tree  IMPORTS    BTreeInternal, ByteBlt, File, Heap, Inline, SpecialBTree, String, Space,    Volume  EXPORTS BTree, BTreeInternal =  BEGIN  TreeObject: PUBLIC TYPE = BTreeInternal.TreeObject;  Tree: TYPE = LONG POINTER TO TreeObject;  bTreePage: CARDINAL = BTreeInternal.bTreePage;  maxTreeSize: CARDINAL = BTreeInternal.maxTreeSize;  -- (disk pages)  treeIncrement: CARDINAL = BTreeInternal.treeIncrement;  -- (b-tree pages)  emptySize: CARDINAL = BTreeInternal.emptySize;  -- the size of an empty page  PCache: TYPE = BTreeInternal.PCache;  PageHandle: TYPE = BTreeInternal.PageHandle;  PagePointer: TYPE = BTreeInternal.PagePointer;  nilPagePointer: PagePointer = BTreeInternal.nilPagePointer;  EntryHandle: TYPE = BTreeInternal.EntryHandle;  heap: PUBLIC UNCOUNTED ZONE = Heap.Create[initial: 2];  debug: PUBLIC BOOLEAN ¬ FALSE;  --  check B-Trees for validity after touching  CompareResult: TYPE = {equal, less, greater};    -- public procedures and signals  -- BTreeInternal  CheckVolumeAccess: PUBLIC INTERNAL PROCEDURE [tree: Tree] =    BEGIN    IF tree.cap = File.nullFile THEN RETURN;    IF tree.cap.volumeID # Volume.systemID THEN      SELECT Volume.GetStatus[tree.cap.volumeID] FROM        openReadWrite => NULL;        openRead => ERROR ReadOnly[tree];        ENDCASE => ERROR VolumeNotOpen[tree.cap.volumeID];    IF tree.spaceReadOnly THEN {      Space.SetAccess[tree.space, readWrite]; tree.spaceReadOnly ¬ FALSE};    END;  -- BTree    Find: PUBLIC ENTRY PROCEDURE [tree: Tree, name: LONG STRING, value: BTree.Value]    RETURNS [ok: BOOLEAN] =    -- Given a file name, return the value    BEGIN    ENABLE UNWIND => NULL;    vp: BTreeInternal.ValuePointer;    IF tree.base = NIL THEN {      SIGNAL SpecialBTree.Unmapped[tree]; BTreeInternal.MapInternal[tree]};    [ok: ok, value: vp] ¬ InternalFind[tree, name];    IF ~ok OR value = NIL THEN RETURN;    IF CopyValue[value, vp, tree.valueSize] THEN ERROR ValueTooSmall[tree];    END;  -- BTree    GetNext: PUBLIC ENTRY PROCEDURE [    tree: Tree, name, nextName: LONG STRING, value: BTree.Value,    mask: LONG STRING] =    -- Stateless enumerator of B-Tree    BEGIN    ENABLE UNWIND => NULL;    pE: EntryHandle;    pP: PagePointer;    pC: PCache;    ok: BOOLEAN;    MaskFilename: PROCEDURE [      file: LONG STRING, fileIndex: CARDINAL, maskIndex: CARDINAL]      RETURNS [outcome: BOOLEAN] =      BEGIN      -- local variables      i, j: CARDINAL;      IF (mask = NIL) OR (mask.length = 0) THEN RETURN[TRUE];      -- process each character in mask      FOR i IN [maskIndex..mask.length) DO        SELECT mask[i] FROM          '* =>  -- matches any string of zero or more characters            BEGIN            FOR j IN [fileIndex..file.length] DO              IF MaskFilename[file, j, i + 1] THEN RETURN[TRUE]; ENDLOOP;            RETURN[FALSE];            END;          '# =>  -- matches any single character            IF fileIndex = file.length THEN RETURN[FALSE]            ELSE fileIndex ¬ fileIndex + 1;          ENDCASE =>            IF fileIndex = file.length              OR String.LowerCase[file[fileIndex]] # String.LowerCase[mask[i]]              THEN RETURN[FALSE]            ELSE fileIndex ¬ fileIndex + 1;        ENDLOOP;      -- filename passes mask if entire filename has been consumed      outcome ¬ fileIndex = file.length;      END;    IF tree.base = NIL THEN {      SIGNAL SpecialBTree.Unmapped[tree]; BTreeInternal.MapInternal[tree]};    IF tree.base[tree.top].size = emptySize THEN {nextName.length ¬ 0; RETURN};    pC ¬ GetGNCache[tree];    IF name.length = 0 THEN      --  we're asking for the first value      BEGIN      pE ¬ BTreeInternal.FirstEntry[@tree.base[tree.top]];      pP ¬ tree.top;      WHILE BTreeInternal.EntryPointer[tree, pE] # nilPagePointer DO        pP ¬ BTreeInternal.EntryPointer[tree, pE];        pE ¬ BTreeInternal.FirstEntry[@tree.base[pP]]        ENDLOOP      END    ELSE      --  see if we're asking for the value after the last one given      IF StringCompare[name, @pC.lastName] = equal THEN        [pE, pP] ¬ GetNextEntry[tree, pC.lastpE]      ELSE        --  if not, look up the old value        BEGIN        [ent: pE, page: pP, ok: ok] ¬ InternalFind[tree, name];        --  if we got a value, use the next...        --  otherwise, InternalFind has given us a pointer to the next entry        IF ok THEN [pE, pP] ¬ GetNextEntry[tree, pE]        END;    --  there are no more values in this tree if pE is NIL    IF pE = NIL THEN {FlushGNCache[tree]; nextName.length ¬ 0; RETURN};    -- keep following the tree until we get a value that matches    WHILE ~MaskFilename[BTreeInternal.EntryName[tree, pE], 0, 0] DO      [pE, pP] ¬ GetNextEntry[tree, pE];      --  there are no more values in this tree if pE is NIL      IF pE = NIL THEN {FlushGNCache[tree]; nextName.length ¬ 0; RETURN};      ENDLOOP;    --  we got a value - save the vitals in the cache    MoveLongString[nextName, BTreeInternal.EntryName[tree, pE]];    MoveLongString[@pC.lastName, BTreeInternal.EntryName[tree, pE]];    pC.lastpE ¬ pE;    pC.lastpP ¬ pP;    IF value = NIL THEN RETURN;    IF CopyValue[value, BTreeInternal.EntryValue[tree, pE], tree.valueSize] THEN      ERROR ValueTooSmall[tree];    END;  -- BTree    Insert: PUBLIC ENTRY PROCEDURE [    tree: Tree, name: LONG STRING, value: BTree.Value]    RETURNS [ok, noRoom: BOOLEAN] =    -- insert a name/value pair into the B-Tree    BEGIN    ENABLE UNWIND => NULL;    found: BOOLEAN;    page: PagePointer;    IF tree.base = NIL THEN {      SIGNAL SpecialBTree.Unmapped[tree]; BTreeInternal.MapInternal[tree]};    CheckVolumeAccess[tree];    [ok: found, page: page] ¬ InternalFind[tree, name];    IF found THEN RETURN[FALSE, FALSE];    IF debug THEN BTreeInternal.SnapShot[tree];    [ok, noRoom] ¬ InsertInNode[tree, page, name, BASE[value], nilPagePointer];    IF tree.autoForceOut THEN Space.ForceOut[tree.space];    FlushGNCache[tree];    IF debug THEN BTreeInternal.InternalValidateBTree[tree];    IF tree.valueSize < LENGTH[value] THEN ERROR ValueTooSmall[tree];    RETURN;    END;  -- SpecialBTree    ReadOnly: PUBLIC ERROR [tree: Tree] = CODE;  -- BTree    SwapValue: PUBLIC ENTRY PROCEDURE [    tree: Tree, name: LONG STRING, oldValue, newValue: BTree.Value]    RETURNS [ok: BOOLEAN] =    --  Swap the values associated with an entry    BEGIN    ENABLE UNWIND => NULL;    entry: EntryHandle;    vp: BTreeInternal.ValuePointer;    IF tree.base = NIL THEN {      SIGNAL SpecialBTree.Unmapped[tree]; BTreeInternal.MapInternal[tree]};    CheckVolumeAccess[tree];    [ok: ok, value: vp, ent: entry] ¬ InternalFind[tree, name];    IF ~ok THEN RETURN[FALSE];    IF oldValue # NIL THEN ok ¬ ~CopyValue[oldValue, vp, tree.valueSize];    Copy[from: BASE[newValue], to: vp, size: tree.valueSize];    IF tree.autoForceOut THEN Space.ForceOut[tree.space];    IF ~ok OR tree.valueSize > LENGTH[newValue] THEN ERROR ValueTooSmall[tree];    RETURN[TRUE];    END;  -- BTree    ValueTooSmall: PUBLIC ERROR [tree: Tree] = CODE;    -- SpecialBTree  VolumeNotOpen: PUBLIC ERROR [volume: Volume.ID] = CODE;  -- private procedures and signals  Copy: INTERNAL PROCEDURE [from, to: LONG POINTER, size: CARDINAL] = {    [] ¬ ByteBlt.ByteBlt[      from: [from, 0, size*2], to: [to, 0, size*2], overLap: move]};  -- BTreeInternal  CopyValue: PUBLIC INTERNAL PROCEDURE [    to: BTree.Value, from: BTreeInternal.ValuePointer, size: BTree.ValueSize]    RETURNS [targetTooSmall: BOOLEAN] =    BEGIN    Copy[from, BASE[to], MIN[size, LENGTH[to]]];    RETURN[size > LENGTH[to]];    END;  ExpandBTree: INTERNAL PROCEDURE [tree: Tree] RETURNS [p: PagePointer] =    --  Expand the BTree    BEGIN    newTreeSize: Environment.PageCount = tree.size + treeIncrement*bTreePage;    treeCap: File.File ¬ tree.cap;    pPage: PageHandle;--  IF newTreeSize > maxTreeSize THEN RETURN[nilPagePointer];    tree.space.pointer ¬ Space.Unmap[tree.space.pointer];    -- Expand the file    File.SetSize[      treeCap, newTreeSize + tree.lpSize !      Volume.InsufficientSpace => GOTO NoRoom];    tree.space ¬ Space.Map[      window: [treeCap, tree.lpSize, newTreeSize],      usage: tree.usage,      swapUnits: [uniform[bTreePage]]];    tree.base ¬ tree.space.pointer;    -- Initialize the newly added pages to FREE    p ¬ BTreeInternal.firstPagePointer + Environment.wordsPerPage*tree.size;    pPage ¬ @tree.base[p];    THROUGH [0..treeIncrement) DO      pPage.free ¬ TRUE;      pPage ¬ pPage + bTreePage*Environment.wordsPerPage      ENDLOOP;    tree.size ¬ newTreeSize;    RETURN[p]    EXITS NoRoom => {      tree.space ¬ Space.Map[        window: [tree.cap, tree.lpSize, tree.size],	usage: tree.usage,	swapUnits: [uniform[bTreePage]]];        RETURN[nilPagePointer]};    END;  -- BTreeInternal  FlushGNCache: PUBLIC INTERNAL PROCEDURE [tree: Tree] =    -- clear this tree's cached state information    {IF tree.pCache # NIL THEN heap.FREE[@tree.pCache]};  GetGNCache: INTERNAL PROCEDURE [tree: Tree] RETURNS [PCache] =    --  Allocate a place to keep state information on this tree    BEGIN    IF tree.pCache = NIL THEN tree.pCache ¬ heap.NEW[BTreeInternal.Cache ¬ []];    RETURN[tree.pCache]    END;  GetNextEntry: INTERNAL PROCEDURE [tree: Tree, pE: EntryHandle]    RETURNS [nextpE: EntryHandle, nextpP: PagePointer] =    -- given a pointer to a b-tree entry, get the successor b-tree entry    BEGIN    pP: PagePointer ¬ BTreeInternal.PagePointerFromEntryHandle[tree, pE];    IF BTreeInternal.EntryPointer[tree, pE] = nilPagePointer THEN      BEGIN      nextpE ¬ BTreeInternal.NextEntry[tree, pE];      IF nextpE # BTreeInternal.FirstFreeEntry[@tree.base[pP]] THEN        RETURN[nextpE, pP]      ELSE        BEGIN        WHILE pP # tree.top DO          nextpP ¬ tree.base[pP].parent;          IF pP # tree.base[nextpP].lastPointer THEN EXIT;          pP ¬ nextpP;          REPEAT FINISHED => RETURN[NIL, nilPagePointer];          ENDLOOP;        FOR pE ¬ BTreeInternal.FirstEntry[@tree.base[nextpP]],          BTreeInternal.NextEntry[tree, pE] UNTIL BTreeInternal.EntryPointer[          tree, pE] = pP DO ENDLOOP;        END;      RETURN[pE, nextpP]      END    ELSE      BEGIN      nextpP ¬ Successor[tree, pE].pg;      nextpE ¬ BTreeInternal.FirstEntry[@tree.base[nextpP]];      END;    END;  -- BTreeInternal  InsertInNode: PUBLIC INTERNAL PROCEDURE [    tree: Tree, p: PagePointer, n: LONG STRING, c: BTreeInternal.ValuePointer,    after: PagePointer] RETURNS [ok, noRoom: BOOLEAN, ent: EntryHandle] =    -- inserts the file name/value pair into this node.  The field "after"     -- points to the node that follows this entry in the B-Tree    BEGIN    dPage: PageHandle;    newEntrySize: CARDINAL;    pE, insertpE: EntryHandle;    loopSize: CARDINAL;    dPage ¬ @tree.base[p];    newEntrySize ¬ BTreeInternal.Overhead[tree] + SIZE[StringBody [n.length]];    IF dPage.size + newEntrySize > bTreePage*Environment.wordsPerPage THEN {      -- this node is full... split into two half-full nodes      [ok, noRoom, ent] ¬ SplitNode[tree, p, n, c, after]; RETURN};    IF dPage.size = emptySize THEN {      -- this is the first insert in this page      pE ¬ BTreeInternal.FirstEntry[dPage];      BTreeInternal.EntryName[tree, pE]­ ¬ [        length: 0, maxlength: n.length, text:];      MoveLongString[BTreeInternal.EntryName[tree, pE], n];      Copy[from: c, to: BTreeInternal.EntryValue[tree, pE], size: tree.valueSize];      BTreeInternal.EntryPointerPointer[tree, pE]­ ¬ nilPagePointer;      dPage.lastPointer ¬ after;      dPage.size ¬ dPage.size + newEntrySize;      RETURN[TRUE, FALSE, pE]};    --  change parent pointer in "after" node    IF after # nilPagePointer THEN tree.base[after].parent ¬ p;    -- move the other entries over and stick ours in    pE ¬ BTreeInternal.FirstEntry[dPage];    loopSize ¬ emptySize;    WHILE loopSize < dPage.size DO      IF StringCompare[n, BTreeInternal.EntryName[tree, pE]] = less THEN {        insertpE ¬ pE + newEntrySize;        Copy[from: pE, to: insertpE, size: dPage.size - loopSize];        BTreeInternal.EntryName[tree, pE]­ ¬ [          length: 0, maxlength: n.length, text:];        MoveLongString[BTreeInternal.EntryName[tree, pE], n];        Copy[          from: c, to: BTreeInternal.EntryValue[tree, pE], size: tree.valueSize];        BTreeInternal.EntryPointerPointer[tree, pE]­ ¬ BTreeInternal.EntryPointer[          tree, insertpE];        BTreeInternal.EntryPointerPointer[tree, insertpE]­ ¬ after;        dPage.size ¬ dPage.size + newEntrySize;        EXIT};      loopSize ¬ loopSize + BTreeInternal.EntrySize[tree, pE];      pE ¬ BTreeInternal.NextEntry[tree, pE];      REPEAT        FINISHED => {          BTreeInternal.EntryName[tree, pE]­ ¬ [            length: 0, maxlength: n.length, text:];          MoveLongString[BTreeInternal.EntryName[tree, pE], n];          Copy[            from: c, to: BTreeInternal.EntryValue[tree, pE],            size: tree.valueSize];          BTreeInternal.EntryPointerPointer[tree, pE]­ ¬ dPage.lastPointer;          dPage.lastPointer ¬ after;          dPage.size ¬ dPage.size + newEntrySize}      ENDLOOP;    RETURN[TRUE, FALSE, pE];    END;  -- BTreeInternal  InternalFind: PUBLIC INTERNAL PROCEDURE [tree: Tree, name: LONG STRING]    RETURNS [      ok: BOOLEAN, value: BTreeInternal.ValuePointer, page: PagePointer,      ent: EntryHandle] =    -- Given a file name, return the value and pointer to entry    -- If the file name is not found, return a pointer to the next entry     -- if ok is FALSE, page points to the page in which the insert should    -- take place (which may not be the one containing ent)    BEGIN    InternalFindLocal: INTERNAL PROCEDURE [      base: PageHandle, offset: PagePointer, name: LONG STRING]      RETURNS [        ok: BOOLEAN, value: BTreeInternal.ValuePointer, page: PagePointer,        ent: EntryHandle] =      BEGIN      dPage: PageHandle;      pE: EntryHandle;      loopSize: CARDINAL ¬ emptySize;      IF offset = nilPagePointer THEN RETURN[FALSE, NIL, nilPagePointer, NIL];      dPage ¬ @base[offset];      pE ¬ BTreeInternal.FirstEntry[dPage];      WHILE loopSize < dPage.size DO        SELECT StringCompare[name, BTreeInternal.EntryName[tree, pE]] FROM          less =>            IF BTreeInternal.EntryPointer[tree, pE] = nilPagePointer THEN              RETURN[FALSE, NIL, offset, pE]            ELSE {              [ok, value, page, ent] ¬ InternalFindLocal[                base, BTreeInternal.EntryPointer[tree, pE], name];              RETURN[ok, value, page, IF ent = NIL THEN pE ELSE ent]};          equal => RETURN[TRUE, BTreeInternal.EntryValue[tree, pE], offset, pE];          ENDCASE;        loopSize ¬ loopSize + BTreeInternal.EntrySize[tree, pE];        pE ¬ BTreeInternal.NextEntry[tree, pE];        ENDLOOP;      IF dPage.lastPointer = nilPagePointer THEN RETURN[FALSE, NIL, offset, NIL]      ELSE RETURN InternalFindLocal[base, dPage.lastPointer, name];      END;    RETURN InternalFindLocal[tree.base, tree.top, name];    END;  -- BTreeInternal  LastEntry: PUBLIC INTERNAL PROCEDURE [tree: Tree, d: PageHandle]    RETURNS [p: EntryHandle] =    -- return pointer to last filled entry of this page    BEGIN    l: CARDINAL ¬ emptySize;    p ¬ BTreeInternal.FirstEntry[d];    WHILE l < d.size DO      l ¬        l + BTreeInternal.Overhead[tree] + SIZE[          StringBody [BTreeInternal.EntryName[tree, p].length]];      IF l = d.size THEN EXIT;      p ¬ BTreeInternal.NextEntry[tree, p];      ENDLOOP;    RETURN    END;  -- BTreeInternal  MoveLongString: PUBLIC INTERNAL PROCEDURE [to, from: LONG STRING] =    BEGIN    to.length ¬ MIN[from.length, to.maxlength];    Inline.LongCOPY[to: to + 2, from: from + 2, nwords: (to.length + 1)/2];    RETURN    END;  NewPage: INTERNAL PROCEDURE [tree: Tree] RETURNS [p: PagePointer] =    BEGIN    p ¬ BTreeInternal.firstPagePointer;    THROUGH [0..tree.size/bTreePage) DO      IF tree.base[p].free THEN EXIT;      p ¬ p + bTreePage*Environment.wordsPerPage;      REPEAT        FINISHED => {p ¬ ExpandBTree[tree]; IF p = nilPagePointer THEN RETURN};      ENDLOOP;    tree.base[p].size ¬ emptySize;    tree.base[p].free ¬ FALSE;    tree.base[p].lastPointer ¬ tree.base[p].parent ¬ nilPagePointer;    tree.base[p].sizeValue ¬ tree.valueSize;    RETURN    END;  SplitNode: INTERNAL PROCEDURE [    tree: Tree, p: PagePointer, n: LONG STRING, c: BTreeInternal.ValuePointer,    after: PagePointer] RETURNS [ok, noRoom: BOOLEAN, ent: EntryHandle] =    -- split this node into two and insert the mid-entry into the parent node    BEGIN    dPage: PageHandle;    newPage: PagePointer;    pNewPage: PageHandle;    newPop: PagePointer;    pNewPop: PageHandle;    pE, pMid: EntryHandle;    midSize: CARDINAL;    middleName: STRING ¬ [BTree.maxNameLength];    middleValue: ARRAY [0..LAST[BTree.ValueSize]] OF CARDINAL;    loopSize: CARDINAL ¬ emptySize;    newPage ¬ NewPage[tree];    dPage ¬ @tree.base[p];    IF newPage = nilPagePointer THEN RETURN[FALSE, TRUE, NIL];    IF dPage.parent = nilPagePointer THEN {      -- the New[] might invalidate dPage, so recalculate       newPop ¬ NewPage[tree];      IF newPop = nilPagePointer THEN RETURN[FALSE, TRUE, NIL];      pNewPop ¬ @tree.base[newPop];      dPage ¬ @tree.base[p]};    -- fill the new page    pNewPage ¬ @tree.base[newPage];    pE ¬ BTreeInternal.FirstEntry[dPage];    WHILE loopSize + BTreeInternal.EntrySize[tree, pE] < dPage.size/2 DO      loopSize ¬ loopSize + BTreeInternal.EntrySize[tree, pE];      pE ¬ BTreeInternal.NextEntry[tree, pE];      ENDLOOP;    pMid ¬ pE;    midSize ¬ loopSize;    MoveLongString[middleName, BTreeInternal.EntryName[tree, pMid]];    Copy[      from: BTreeInternal.EntryValue[tree, pMid], to: @middleValue,      size: tree.valueSize];    loopSize ¬ loopSize + BTreeInternal.EntrySize[tree, pE];    pE ¬ BTreeInternal.NextEntry[tree, pE];    -- move the rest of the page into the new page    Copy[from: pE, to: @pNewPage.entries, size: dPage.size - loopSize];    -- clean up the two pages    pNewPage.size ¬ dPage.size - loopSize + emptySize;    dPage.size ¬ midSize;    pNewPage.lastPointer ¬ dPage.lastPointer;    dPage.lastPointer ¬ BTreeInternal.EntryPointer[tree, pMid];    pNewPage.parent ¬ dPage.parent;    IF pNewPage.lastPointer # nilPagePointer THEN {      --  change parent pointers in children of new node      tree.base[pNewPage.lastPointer].parent ¬ newPage;      pE ¬ BTreeInternal.FirstEntry[pNewPage];      WHILE pE # BTreeInternal.FirstFreeEntry[pNewPage] DO        tree.base[BTreeInternal.EntryPointer[tree, pE]].parent ¬ newPage;        pE ¬ BTreeInternal.NextEntry[tree, pE]        ENDLOOP};    -- now the insert will work    IF StringCompare[n, middleName] = less THEN      [ent: ent] ¬ InsertInNode[tree, p, n, c, after]    ELSE [ent: ent] ¬ InsertInNode[tree, newPage, n, c, after];    IF dPage.parent = nilPagePointer THEN {      -- the tree has grown out the top      tree.top ¬ tree.base.top ¬ newPop;      dPage.parent ¬ pNewPage.parent ¬ newPop;      pE ¬ BTreeInternal.FirstEntry[pNewPop];      BTreeInternal.EntryName[tree, pE]­ ¬ [        length: 0, maxlength: middleName.length, text:];      MoveLongString[BTreeInternal.EntryName[tree, pE], middleName];      Copy[        from: @middleValue, to: BTreeInternal.EntryValue[tree, pE],        size: tree.valueSize];      BTreeInternal.EntryPointerPointer[tree, pE]­ ¬ p;      pNewPop.lastPointer ¬ newPage;      pNewPop.size ¬        emptySize + BTreeInternal.Overhead[tree] + SIZE[          StringBody [middleName.length]];      RETURN[TRUE, FALSE, ent]};    [ok: ok, noRoom: noRoom] ¬ InsertInNode[      tree, dPage.parent, middleName, LOOPHOLE[LONG[@middleValue]], newPage];    RETURN[ok, noRoom, ent]    END;  StringCompare: INTERNAL PROCEDURE [a, b: LONG STRING]    RETURNS [relation: CompareResult] = {    l: CARDINAL;    ca, cb: CHARACTER;    CharAnd: PROCEDURE [CHARACTER, WORD] RETURNS [CHARACTER] = Inline.BITAND;    l ¬ MIN[a.length, b.length];    FOR i: CARDINAL IN [0..l) DO      ca ¬ a[i];      cb ¬ b[i];      IF ca IN ['a..'z] THEN ca ¬ CharAnd[ca, 137B];  -- ignore case shifts      IF cb IN ['a..'z] THEN cb ¬ CharAnd[cb, 137B];      IF ca < cb THEN RETURN[less];      IF ca > cb THEN RETURN[greater];      ENDLOOP;    RETURN[      SELECT a.length FROM        < b.length => less,        = b.length => equal,        ENDCASE => greater]};  -- BTreeInternal  Successor: PUBLIC INTERNAL PROCEDURE [tree: Tree, pE: EntryHandle]    RETURNS [pg, after: PagePointer] =    -- Finds the successor to a given entry.  Also returns the after    -- pointer given entry    BEGIN    IntSucc: INTERNAL PROCEDURE [p1: PagePointer] RETURNS [p0: PagePointer] =      BEGIN      ipE: EntryHandle ¬ BTreeInternal.FirstEntry[@tree.base[p1]];      nextP: PagePointer ¬ BTreeInternal.EntryPointer[tree, ipE];      IF nextP = nilPagePointer THEN RETURN[p1]      ELSE {p0 ¬ IntSucc[nextP]; RETURN};      END;    p: PagePointer ¬ BTreeInternal.PagePointerFromEntryHandle[tree, pE];    testpE: EntryHandle ¬ BTreeInternal.FirstFreeEntry[@tree.base[p]];    testpE ¬ BTreeInternal.FirstFreeEntry[@tree.base[p]];    pE ¬ BTreeInternal.NextEntry[tree, pE];    after ¬      IF testpE = pE THEN tree.base[p].lastPointer      ELSE BTreeInternal.EntryPointer[tree, pE];    pg ¬ IntSucc[after];    RETURN;    END;  END.           LOG      Time: 8-Jun-81 11:53:00 AM By: Keith	Action: Created from DirectoryTreesImpl      Time: 22-Sep-81 17:20:41 By: Keith	Action: BTreeGetNext now returns the entry that would follow name, even if name is not in    the b-tree.  Changed the get next cache from an array to a linked list, so it will never run out of room.      Time:  1-Oct-81 12:20:46 By: Karlton	Action: MONITORizing it and making Validation public, now has own heap.      Time:  5-Oct-81 16:11:09 By: Keith	Action: Added PROCs SwapValue and SnapShot, attached cache entry to a b-tree descriptor,    added parameters reset and lpSize to Make.      Time:  January 27, 1982  5:45 PM By: Keith	Action: Made less greedy in creating spaces for BTrees.      Time:  11-Mar-82  8:55:08 By: Keith	Action: Added Map and Unmap plus support.   Time:  20-Sep-82 16:26:42 By: Keith	Action: Split from BTreeImpl. Added variable value size.   Time:  13-May-83 11:50:08 By: Keith	Action: Added ReadOnly plus support.   Time:  27-Jul-83 10:17:16 By: elliott Action: added usage parmeter.   Time:   4-Apr-85 14:59:52 By: KAM Action: Changed so PagePointers are derived from EntryHandles when needed (via new procedure PagePointerFromEntryHandle).      
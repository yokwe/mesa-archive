-- File: MScavengeImplA.mesa - last edit:-- Riggle.PA           16-Jan-87 18:50:37-- Copyright (C) 1982, 1983, 1984 , 1987 by Xerox Corporation. All rights reserved. -- File; MScavengeImplA.mesa - last edit by-- PXK    ,	10-Feb-82 13:02:00-- LXR    ,	27-Dec-83 16:53:12-- DWE    ,	 4-Aug-83 15:07:44-- KAM  ,	22-Jul-84 19:10:57-- RLC		30-Jan-87 10:53:12DIRECTORY  BTree USING [Delete, Find, GetNext, maxNameLength, Tree, Value],  ByteBlt USING [ByteBlt],  Environment USING [bytesPerPage, bytesPerWord, wordsPerPage],  File USING [    File, GetAttributes, GetSize, ID, nullFile, nullID, Type,    Unknown],  Format USING [Char, CR, Date, Line, LongNumber, StringProc],  Heap USING [Create, Delete],  Inline USING [LongCOPY],  MDirectory USING [    AccessRootFile, CreateSubDir, DirError, GetValue, InsertInTree,    IsFilename, LookupRootDir, MakeEmptyDir, MValue, MValueRec, MValueToValue,    NoRootDir, NoRootFile, nullMValueRec, SetDirInfoInTree],  MesaDEFileTypes USING [Directory, MesaDEFileType, tCascadeNub, tRootDirectory],  MesaDEFileTypesExtra USING [tRootFile],  MFile USING [    AcquireTemp, Error, Handle, maxNameLength, NameForError, PleaseReleaseProc,    Type],  MFileOps USING [    GetCapa, GetName, InitLeader, InvalidLeader, LeaderPage, leaderPages,    MapLeader, maxNameLength, RootFile, UnmapLeader],  MScavenge USING [ErrorCode],  MScavengeOps USING [    ClosePilotLogFile, GetWords, Handle, HandleProblems, LogFileCapability,    MakeFileListIntoPilotLogFile, ScavengeObject],  MStream USING [    Copy, Create, Error, GetFile, Handle, PleaseReleaseProc, WriteOnly],  MUsage USING [mFileScavenge],  Scavenger USING [FileEntry, Header],  Space USING [Allocate, Interval, MapAt, nullInterval, Unmap],  SpecialBTree USING [AutoForceOut, MakeFromCapa],  Stream USING [Delete, PutBlock, SetPosition],  String USING [AppendDecimal, AppendString, EquivalentString],  System USING [GetGreenwichMeanTime, gmtEpoch],  Time USING [Current],  Volume USING [    ID, GetLabelString, InsertRootFile, LookUpRootFile, maxNameLength, nullID,    RemoveRootFile, RootDirectoryError, Unknown];MScavengeImplA: MONITOR  IMPORTS    BTree, ByteBlt, File, Format, Heap, Inline, MDirectory, MFile,    MFileOps, MScavengeOps, MStream, Space, SpecialBTree,    Stream, String, System, Time, Volume   EXPORTS MScavenge =  BEGIN  StartingScavenge: PUBLIC SIGNAL = CODE;  --Types  DirectoryStatus: TYPE = {    ok, nonexistent, notDirectoryType, notInPilotScavengerLog};  -- Global Variables (initialized by procedure Initialize)  dontFree: MFile.PleaseReleaseProc = {RETURN[no]};  dontFreeStream: MStream.PleaseReleaseProc = {RETURN[no]};  z: UNCOUNTED ZONE;  scavengerLog: MStream.Handle ¬ NIL;  rootDirCap: File.File;  -- RootDir file capability  rootFileCap: File.File; -- root file capability  uniqueAnonName: LONG STRING ¬ [MFileOps.maxNameLength];  dirCacheEntries: CARDINAL;  dirCacheIncrement: CARDINAL = 50;  DirCacheEntry: TYPE = RECORD [    id: File.ID ¬ File.nullID, reachable: BOOLEAN ¬ FALSE];  DirCache: TYPE = RECORD [entry: SEQUENCE length: CARDINAL OF DirCacheEntry];  dirCache: LONG POINTER TO DirCache;  fileCacheEntries: CARDINAL;  fileCacheMappedEntries: CARDINAL;  FileCacheEntry: TYPE = RECORD [    id: File.ID ¬ File.nullID, reachable: BOOLEAN ¬ FALSE];  fileCacheIncrement: CARDINAL =    (fcPageIncrement*Environment.wordsPerPage)/SIZE[FileCacheEntry];  fcPageIncrement: CARDINAL = 8;  nFileCachePages: CARDINAL;  fileCacheSpace: Space.Interval ¬ Space.nullInterval;  FileCacheIndex: TYPE = CARDINAL [0..LAST[CARDINAL]/SIZE[FileCacheEntry]);  FileCache: TYPE = ARRAY FileCacheIndex OF FileCacheEntry;  fileCache: LONG POINTER TO FileCache;  anonEntries: CARDINAL;  anonIncrement: CARDINAL = 30;  AnonCacheEntry: TYPE = RECORD [id, anon: File.ID ¬ File.nullID];  AnonCache: TYPE = RECORD [entry: SEQUENCE length: CARDINAL OF AnonCacheEntry];  anonCache: LONG POINTER TO AnonCache;    -- Errors  Error: PUBLIC ERROR [error: MScavenge.ErrorCode] = CODE;  -- Utility Procedures  CapaForID: PROCEDURE [context: MScavengeOps.Handle, id: File.ID]    RETURNS [capa: File.File] = {capa ¬ [id, context.volume]};  MoveString: PROCEDURE [from, to: LONG STRING] = {    to.length ¬ 0; String.AppendString[from: from, to: to]};  -- Public procedure  -- Scavenge:  rebuild (or examine IF ~context.repair) the directory  -- structure on context.volume.  Scavenge: PUBLIC ENTRY PROCEDURE [    logProc: Format.StringProc, repair: BOOLEAN, verbose: BOOLEAN,    volume: Volume.ID ¬ Volume.nullID] =    BEGIN    ENABLE UNWIND => {FinalizeFileCache[]; FlushDirTreeCache[]};    LocalLog: Format.StringProc = {      Stream.PutBlock[scavengerLog, [LOOPHOLE[@s.text], 0, s.length]];      IF logProc # NIL THEN logProc[s]};    contextObject: MScavengeOps.ScavengeObject ¬ [      logProc: LocalLog, pilotLogFile: File.nullFile, repair: repair,      verbose: verbose, volume: volume];    context: MScavengeOps.Handle = @contextObject;    permStream: MStream.Handle;    logName: STRING = [      Volume.maxNameLength + 16 -- length of "<>MScavenger.log" -- ];    scavengerLog ¬ Initialize[volume];    ScavengerLogName[logName, volume];    HeaderProc[LocalLog, logName];    MScavengeOps.HandleProblems[context];    context.logProc["\nDirectory Scavenger pass one:  Empty directories.\n"L];    ClearDirectories[context];    ValidateRootDir[context];    context.logProc[      "\nDirectory Scavenger pass two:  Insert files back into directories.\n"L];    InsertFiles[context];    context.logProc[      "\nDirectory Scavenger pass three:  Guarantee that all files are reachable from the root.\n"L];    IF context.repair THEN WalkTree[context];  -- else can't check    FlushDirTreeCache[];  -- this must be done before the real log is created    Heap.Delete[z];    FinalizeFileCache[];    permStream ¬ MStream.WriteOnly[logName, [], text];    Stream.SetPosition[scavengerLog, 0];    [] ¬ MStream.Copy[      to: permStream, from: scavengerLog, bytes: LAST[LONG CARDINAL]];    Stream.Delete[scavengerLog];    Stream.Delete[permStream];    IF context.repair THEN {      ResetChangeCounter[context]};   END;  -- Scavenge  HeaderProc: PROCEDURE [write: Format.StringProc, volume: LONG STRING] =    BEGIN    write["MScavenge to "L];    write[volume];    write[" at "];    Format.Date[write, System.GetGreenwichMeanTime[], full];    Format.CR[write];    Format.CR[write];    END;  ScavengerLogName: PROCEDURE [name: LONG STRING, volume: Volume.ID] =    BEGIN    scavengeName: STRING = ">MScavenger.log"L;    Volume.GetLabelString[volume, name];    [] ¬ ByteBlt.ByteBlt[      from: [LOOPHOLE[@name.text], 0, name.length],      to: [LOOPHOLE[@name.text], 1, name.length + 1], overLap: move];    name[0] ¬ '<;    name.length ¬ name.length + 1;    String.AppendString[to: name, from: scavengeName];    END;  --========================================================    -- Internal procedures  --========================================================    -- GetAnonDir:  Return the anonymous directory for ID.   GetAnonDir: INTERNAL PROC [context: MScavengeOps.Handle, bad: File.ID]    RETURNS [dir: File.ID] = {    tree: BTree.Tree;    FOR i: CARDINAL IN [0..anonEntries) DO      IF bad = anonCache[i].id THEN RETURN[anonCache[i].anon]; ENDLOOP;    -- Create a new anonymous subdirectory in root directory.     uniqueAnonName.length ¬ ("AnonDir"L).length;    String.AppendDecimal[uniqueAnonName, anonEntries];    GenerateUniqueName[context, rootDirCap.fileID, uniqueAnonName, TRUE];    tree ¬ MapDirectory[context, rootDirCap.fileID];    dir ¬ MDirectory.CreateSubDir[      tree, uniqueAnonName, rootDirCap !      MDirectory.DirError => {UnmapDirectory[tree]; ERROR Error[internalFailure]}];    UnmapDirectory[tree];    AddToDirectoryList[context, dir];    AddToAnonDirList[context, dir, bad]};  AddToAnonDirList: INTERNAL PROC [    context: MScavengeOps.Handle, dir, bad: File.ID] = {    IF anonEntries = anonCache.length THEN      BEGIN      new: LONG POINTER TO AnonCache ¬ z.NEW[        AnonCache [anonEntries + anonIncrement]];      Inline.LongCOPY[        from: @anonCache[0], to: @new[0],        nwords: anonEntries*SIZE[AnonCacheEntry]];      z.FREE[@anonCache];      anonCache ¬ new;      END;    anonCache[anonEntries].anon ¬ dir;    anonCache[anonEntries].id ¬ bad;    anonEntries ¬ anonEntries + 1;    };  -- GenerateNameInDirectory:  Generate a unique name for the specified directory  -- if the name is empty, a name must be generated; if the parent is not a valid  -- directory, a directory must be generated.  GenerateNameInDirectory: INTERNAL PROC [    context: MScavengeOps.Handle, name: LONG STRING, dir: File.ID,    isDir: BOOLEAN ¬ FALSE] RETURNS [newDir: File.ID] =    BEGIN    needName: BOOLEAN = (name.length = 0);    needDir: BOOLEAN = ~IsDirectory[context, dir];    newDir ¬ IF needDir THEN GetAnonDir[context, dir] ELSE dir;    IF needName THEN GenerateUniqueName[context, newDir, name, isDir]    ELSE  -- check to see if the given name is really unique in the directory      BEGIN      tree: BTree.Tree ¬ NIL;      conflict: BOOLEAN;      tree ¬ MapDirectory[context, newDir];      conflict ¬ BTree.Find[tree, name, NIL ! UNWIND => UnmapDirectory[tree]];      UnmapDirectory[tree];      IF conflict THEN GenerateUniqueName[context, newDir, name, isDir];      END;    END;  -- GenerateNameInDirectory  -- GenerateUniqueName:  Generate a unique name for the specified directory  GenerateUniqueName: INTERNAL PROC [    context: MScavengeOps.Handle, dir: File.ID, name: LONG STRING,    isDir: BOOLEAN ¬ FALSE] =    BEGIN    rootFileName: STRING = "AnonFile"L;    rootFileNameLength: CARDINAL = rootFileName.length;    rootDirName: STRING = "AnonDir"L;    rootDirNameLength: CARDINAL = rootDirName.length;    rootNameNumber: CARDINAL ¬ 1;    tree: BTree.Tree ¬ NIL;    oldName: BOOLEAN = (name.length # 0);    IF oldName THEN {      context.logProc["Name conflict: "L];      context.logProc[name];      context.logProc[" renamed to "]};    MoveString[to: name, from: IF isDir THEN rootDirName ELSE rootFileName];    tree ¬ MapDirectory[context, dir];    WHILE BTree.Find[tree, name, NIL] DO      name.length ¬ IF isDir THEN rootDirNameLength ELSE rootFileNameLength;      String.AppendDecimal[name, rootNameNumber];      rootNameNumber ¬ rootNameNumber + 1;      ENDLOOP;    UnmapDirectory[tree];    IF oldName THEN {context.logProc[name]; context.logProc["\n"L]};    END;  -- GenerateUniqueName  -- Initialize:  Reset all the global variables that change during the scavenge.  Initialize: INTERNAL PROC [volume: Volume.ID] RETURNS [log: MStream.Handle] =    BEGIN    file: MFile.Handle;    z ¬ Heap.Create[50];    rootDirCap ¬ rootFileCap ¬ File.nullFile;    uniqueAnonName.length ¬ 0;    String.AppendString[to: uniqueAnonName, from: "AnonDir"L];    dirCacheEntries ¬ 0;    dirCache ¬ z.NEW[DirCache [dirCacheIncrement]];    InitializeFileCache[];    anonCache ¬ z.NEW[AnonCache [anonIncrement]];    anonEntries ¬ 0;    file ¬ MFile.AcquireTemp[      type: text, initialLength: 3500 ! MFile.Error => Error[internalFailure]];    log ¬ MStream.Create[      file, [dontFreeStream, NIL] ! MStream.Error => Error[internalFailure]];   END;  -- Initialize  -- ClearDirectories:  Find all files in the Pilot ScavengerLog of type MesaDEFileTypes.Directory, reset their contents and enter them in the directory cache. Add non-directory files to the file cache, except for the root file and the cascade nub. Directories will be rebuilt from the information in leader pages. This is possible because all files have leader pages.    -- New Verifier. File enumeration no longer in scavenger log. Must call Scavenger.MakeFileList instead. Use MScavengeOps.MakeFileListIntoPilotLogFile.    ClearDirectories: INTERNAL PROC [context: MScavengeOps.Handle] =    BEGIN    header: LONG POINTER TO Scavenger.Header ¬ NIL;    numberOfFiles: LONG CARDINAL;    nextWord: CARDINAL ¬ SIZE[Scavenger.Header];    fileEntryCopy: Scavenger.FileEntry;    fileEntry: POINTER TO Scavenger.FileEntry ¬ @fileEntryCopy;    file: File.File;    bufferPointer: LONG POINTER TO UNSPECIFIED;    pilotLogSpace: Space.Interval;    pilotLogSpaceSize: CARDINAL ¬ 1;    type: File.Type;    temporary: BOOLEAN;    [bufferPointer: bufferPointer, pilotLogSpace: pilotLogSpace] ¬      MScavengeOps.MakeFileListIntoPilotLogFile[context];    header ¬ LOOPHOLE[bufferPointer];     -- for the list from MakeFileList header.logEntries tells how many       numberOfFiles ¬ header.logEntries;    -- save number of files in a safe place (won't get unmapped if    -- pilotLogSpace WindowOrigin is changed).    header ¬ NIL;  -- get rid of dangling pointer in case pilotLogSpace WindowOrigin is changed.    -- For each file in Pilot Scavenger log..    FOR counter: LONG CARDINAL ¬ 1, counter + 1 WHILE counter <= numberOfFiles DO      nextWord ¬ MScavengeOps.GetWords[        fileEntry, bufferPointer, nextWord, SIZE[Scavenger.FileEntry],        pilotLogSpace];      file ¬ CapaForID[context, fileEntry.file];      IF scavengerLog # NIL AND fileEntry.file = MFileOps.GetCapa[	MStream.GetFile[scavengerLog]].fileID        THEN LOOP;  -- dont include the scavenger log among files to be scavenged      [type, temporary] ¬ File.GetAttributes[        file: file ! File.Unknown, Volume.Unknown => LOOP];      IF temporary OR ~(type IN MesaDEFileTypes.MesaDEFileType)        OR type = MesaDEFileTypes.tCascadeNub THEN LOOP;      IF type = MesaDEFileTypesExtra.tRootFile THEN {        SELECT rootFileCap FROM	  File.nullFile => rootFileCap ¬ file	  ENDCASE => {	    MScavengeOps.LogFileCapability[context, file];	    context.logProc[" is a duplicate root file: ignored.\n"L]};	  LOOP};      IF File.GetSize[file] = 0 THEN {        MScavengeOps.LogFileCapability[context, file];        context.logProc[" is zero-length but should have a leader page."L];        LOOP};      IF ~(type IN MesaDEFileTypes.Directory) THEN        AddToFileList[context, file.fileID]      ELSE {  -- file is a directory; empty it and add its tree to the dirCache        IF type = MesaDEFileTypes.tRootDirectory THEN 	  SELECT rootDirCap FROM	     File.nullFile => rootDirCap ¬ file	  ENDCASE => {	    MScavengeOps.LogFileCapability[context, file];	    context.logProc[" is a duplicate root directory that will be treated as a subdirectory.\n"L]};	IF context.repair THEN          MDirectory.MakeEmptyDir[[file.fileID, context.volume]];        AddToDirectoryList[context, file.fileID]};      ENDLOOP;    MScavengeOps.ClosePilotLogFile[pilotLogSpace];    END;  -- ClearDirectories  -- InsertFiles:  Enumerate all the files in the Pilot ScavengerLog and try  -- to insert those of the right type into the parent directory indicated in  -- the leader page.  Those with invalid parent directory file capabilities  -- will be inserted into anonymous directories.  (Put each group of files   -- with the same missing parent in a separate "AnonDirNN" directory, where   -- NN is a number. Files with bad leader pages go into "AnonDir".)  InsertFiles: INTERNAL PROC [context: MScavengeOps.Handle] =    BEGIN    loop: BOOLEAN;    tree: BTree.Tree ¬ NIL;    file: File.File;    name: STRING ¬ [MFileOps.maxNameLength];    parent: File.ID;    parentStatus: DirectoryStatus;    rec: MDirectory.MValueRec;    value: MDirectory.MValue = @rec;    FOR counter: CARDINAL IN [0..dirCacheEntries) DO      file ¬ CapaForID[context, dirCache[counter].id];      [loop, parent, rec] ¬ GetInfo[context, file, name, directory];      IF loop OR (parent = file.fileID AND file = rootDirCap) THEN LOOP;      -- don't insert root dir into self; none root dir should have been handles in GetInfo      [parentStatus, tree] ¬ ValidateDirectory[context, parent];      CheckLeaderInfoandInsert[        context, parentStatus, value, directory, file, parent, name, tree];      IF tree # NIL THEN UnmapDirectory[tree];      ENDLOOP;  --each file in directory cache --    FOR counter: CARDINAL IN [0..fileCacheEntries) DO      file ¬ CapaForID[context, fileCache[counter].id];      [loop, parent, rec] ¬ GetInfo[context, file, name, unknown];      IF loop THEN LOOP;      IF parent = file.fileID THEN        IF file = rootDirCap THEN LOOP  -- don't insert root dir into self        ELSE {          context.logProc[name];          context.logProc[            " is its own parent directory, will be inserted in anonymous directory\n"L];          IF ~context.repair THEN LOOP;          parent ¬ GenerateNameInDirectory[            name: name, dir: File.nullID, context: context, isDir: FALSE]};      [parentStatus, tree] ¬ ValidateDirectory[context, parent];      CheckLeaderInfoandInsert[        context, parentStatus, value, unknown, file, parent, name, tree];      IF tree # NIL THEN UnmapDirectory[tree];      ENDLOOP;  --each file in file cache --    END;  -- InsertFiles--  -- WalkTree: Check that all files are reachable from the root directory. If they are not, add them to an anonymous directory.  WalkTree: INTERNAL PROC [context: MScavengeOps.Handle] =    BEGIN    FOR i: CARDINAL IN [0..dirCacheEntries) DO      IF dirCache[i].id = rootDirCap.fileID THEN {MarkTree[context, i]; EXIT};      ENDLOOP;    FOR i: CARDINAL IN [0..dirCacheEntries) DO      IF ~dirCache[i].reachable THEN {        InsertOrphan[context, dirCache[i].id]; MarkTree[context, i]};      ENDLOOP;    FOR i: CARDINAL IN [0..fileCacheEntries) DO      IF ~fileCache[i].reachable THEN InsertOrphan[context, fileCache[i].id];      ENDLOOP;    END;  -- WalkTree    -- ResetChangeCounter: Resets the change count in the MFileSystem root file  ResetChangeCounter: INTERNAL PROC [context: MScavengeOps.Handle] =     BEGIN    DoReset: PROCEDURE [root: MFileOps.RootFile] = {root.changing ¬ 0};    MDirectory.AccessRootFile[context.volume, DoReset !      MDirectory.NoRootFile => Error[internalFailure]];    END;  -- InsertInAnonymousDirectory:  Insert an orphan file into the  -- Anonymous directory AnonDirNN (change file name in  -- the event of a name conflict).  InsertInAnonymousDirectory: INTERNAL PROC [    context: MScavengeOps.Handle, name: LONG STRING, file, parent: File.ID,    isDir: BOOLEAN] RETURNS [tree: BTree.Tree] =    BEGIN    lp: MFileOps.LeaderPage;    newParent: File.ID;    IF ~context.repair THEN RETURN;    newParent ¬ GenerateNameInDirectory[context, name, parent, isDir];    IF newParent = File.nullID THEN GOTO noRoomExit;    tree ¬ MapDirectory[context, newParent];    IF ~MDirectory.InsertInTree[tree, name, file] THEN {      filePresent: BOOLEAN =        (MDirectory.GetValue[tree, name] # MDirectory.nullMValueRec);      UnmapDirectory[tree];      tree ¬ NIL;      IF filePresent THEN ERROR Error[internalFailure] ELSE GOTO noRoomExit};    lp ¬ MFileOps.MapLeader[CapaForID[context, file]];    lp.fp.dir ¬ newParent;    SetName[lp, name];    MFileOps.UnmapLeader[lp];    context.logProc[name];    context.logProc[" inserted in one of the AnonDir subdirectories.\n"L];    EXITS      noRoomExit =>        context.logProc[          "No room to create AnonDir or no room in AnonDir; continuing...\n"L];    END;  -- InsertInAnonymousDirectory  treeCache: BTree.Tree ¬ NIL;  treeDirCache: File.ID ¬ File.nullID;  useCount: CARDINAL ¬ 0;  dirTreeCacheSize: CARDINAL = 10;  dirTreeCache: ARRAY [0..dirTreeCacheSize) OF DirTreeCacheEntry ¬ ALL[[]];  DirTreeCacheEntry: TYPE = RECORD [    id: File.ID ¬ File.nullID, tree: BTree.Tree ¬ NIL, refCount: CARDINAL ¬ 0];  Promote: PROCEDURE [i: CARDINAL] = {    temp: DirTreeCacheEntry = dirTreeCache[i];    bytesToMove: CARDINAL = i*SIZE[DirTreeCacheEntry]*Environment.bytesPerWord;    [] ¬ ByteBlt.ByteBlt[      to: [LOOPHOLE[@dirTreeCache[1]], 0, bytesToMove],      from: [LOOPHOLE[@dirTreeCache[0]], 0, bytesToMove], overLap: move];    dirTreeCache[0] ¬ temp};  TreeInCache: PROCEDURE [id: File.ID] RETURNS [tree: BTree.Tree] = {    FOR i: CARDINAL IN [0..dirTreeCacheSize) DO      IF dirTreeCache[i].tree = NIL THEN RETURN[NIL];      IF dirTreeCache[i].id = id THEN {        IF i > 0 THEN Promote[i];        dirTreeCache[0].refCount ¬ dirTreeCache[0].refCount + 1;        RETURN[dirTreeCache[0].tree]};      ENDLOOP;    RETURN[NIL]};  FlushDirTreeCache: PROC = {    FOR i: CARDINAL IN [0..dirTreeCacheSize) DO      IF dirTreeCache[i].tree = NIL THEN EXIT;      BTree.Delete[dirTreeCache[i].tree];      dirTreeCache[i] ¬ [];      ENDLOOP};  PutTreeInCache: PROCEDURE [id: File.ID, tree: BTree.Tree] = {    IF dirTreeCache[dirTreeCacheSize - 1].tree # NIL THEN {      FOR i: CARDINAL DECREASING IN [0..dirTreeCacheSize) DO        IF dirTreeCache[i].refCount = 0 THEN {          BTree.Delete[dirTreeCache[i].tree]; dirTreeCache[i] ¬ []; EXIT};        REPEAT FINISHED => ERROR Error[internalFailure];        ENDLOOP};    FOR i: CARDINAL IN [0..dirTreeCacheSize) DO      IF dirTreeCache[i].tree = NIL THEN {        dirTreeCache[i] ¬ [id: id, tree: tree, refCount: 1];        IF i > 0 THEN Promote[i];        RETURN};      ENDLOOP};  MapDirectory: INTERNAL PROC [context: MScavengeOps.Handle, dir: File.ID]    RETURNS [tree: BTree.Tree] = {    IF ~IsDirectory[context, dir] THEN RETURN[NIL];    IF (tree ¬ TreeInCache[dir]) = NIL THEN {      tree ¬ SpecialBTree.MakeFromCapa[        cap: CapaForID[context, dir],	usage: MUsage.mFileScavenge,	lpSize: MFileOps.leaderPages,        valueSize: SIZE[MDirectory.MValueRec]];      PutTreeInCache[dir, tree];      SpecialBTree.AutoForceOut[tree, FALSE]}};  -- MapDirectory  UnmapDirectory: INTERNAL PROC [tree: BTree.Tree] = {    FOR i: CARDINAL IN [0..dirTreeCacheSize) DO      IF dirTreeCache[i].tree = tree THEN {        dirTreeCache[i].refCount ¬ dirTreeCache[i].refCount - 1; RETURN};      ENDLOOP;    ERROR Error[internalFailure]};  -- UnmapDirectory  IsDirectory: INTERNAL PROC [context: MScavengeOps.Handle, dir: File.ID]    RETURNS [BOOLEAN] = {    IF dir = File.nullID THEN RETURN[FALSE];    FOR i: CARDINAL IN [0..dirCacheEntries) DO      SELECT TRUE FROM dirCache[i].id = dir => RETURN[TRUE]; ENDCASE; ENDLOOP;    RETURN[FALSE]};  -- IsDirectory  AddToDirectoryList: INTERNAL PROC [context: MScavengeOps.Handle, dir: File.ID] =    {    i: CARDINAL;    new: LONG POINTER TO DirCache;    FOR i IN [0..dirCacheEntries) DO IF dirCache[i].id = dir THEN RETURN; ENDLOOP;    IF dirCacheEntries = dirCache.length THEN {      new ¬ z.NEW[DirCache [dirCache.length + dirCacheIncrement]];      Inline.LongCOPY[        from: @dirCache[0], to: @new[0],        nwords: dirCacheEntries*SIZE[DirCacheEntry]];      z.FREE[@dirCache];      dirCache ¬ new};    dirCache[dirCacheEntries] ¬ [id: dir];    dirCacheEntries ¬ dirCacheEntries + 1};  -- AddToDirectoryList  AddToFileList: INTERNAL PROC [context: MScavengeOps.Handle, file: File.ID] = {    OPEN Space;    i: CARDINAL;    FOR i IN [0..fileCacheEntries) DO      IF fileCache[i].id = file THEN RETURN; ENDLOOP;    IF fileCacheEntries = fileCacheMappedEntries THEN {      space: Interval = [        fileCache + nFileCachePages*Environment.wordsPerPage, fcPageIncrement];      [] ¬ MapAt[        at: space,        window: [file: File.nullFile, base: NULL, count: fcPageIncrement],        usage: MUsage.mFileScavenge,	class: data];      nFileCachePages ¬ nFileCachePages + fcPageIncrement;      fileCacheMappedEntries ¬ fileCacheMappedEntries + fileCacheIncrement};    fileCache[fileCacheEntries] ¬ [id: file];    fileCacheEntries ¬ fileCacheEntries + 1};  -- AddToDirectoryList  InitializeFileCache: PROC = {    fileCacheSpace ¬ Space.Allocate[count: 256];    fileCache ¬ fileCacheSpace.pointer;    fileCacheEntries ¬ 0;    nFileCachePages ¬ fcPageIncrement;    [] ¬ Space.MapAt[      at: fileCacheSpace,      window: [file: File.nullFile, base: NULL, count: fcPageIncrement],      usage: MUsage.mFileScavenge,      class: data];    fileCacheMappedEntries ¬ fileCacheIncrement};  FinalizeFileCache: PROC = {    IF fileCacheSpace = Space.nullInterval THEN RETURN;    fileCacheSpace.pointer ¬ Space.Unmap[fileCacheSpace.pointer];    fileCacheSpace ¬ Space.nullInterval};  -- ValidateDirectory:  Check that the directory is in the dirCache,  -- since this implies that it is a valid  directory from the Pilot   --  scavenger log.   ValidateDirectory: INTERNAL PROC [context: MScavengeOps.Handle, parent: File.ID]    RETURNS [dirStatus: DirectoryStatus, tree: BTree.Tree ¬ NIL] =    BEGIN    type: File.Type;    dirStatus ¬ ok;    IF parent = File.nullID THEN RETURN[nonexistent, NIL];    tree ¬ MapDirectory[context, parent !        File.Unknown, Volume.Unknown => {dirStatus ¬ nonexistent; GOTO done}];    IF tree = NIL THEN {      [type: type] ¬ File.GetAttributes[        [parent, context.volume] !        File.Unknown, Volume.Unknown => {dirStatus ¬ nonexistent; GOTO done}];      IF type ~IN MesaDEFileTypes.Directory THEN dirStatus ¬ notDirectoryType      ELSE dirStatus ¬ notInPilotScavengerLog}    EXITS done => NULL;    END;  -- ValidateDirectory  -- ValidateRootDir:  Check for a valid root directory file capability in  -- the logical volume root page, and create a new root directory file  -- if necessary.   ValidateRootDir: INTERNAL PROC [context: MScavengeOps.Handle] =    BEGIN    ValidateRootFile: INTERNAL PROCEDURE = {      currentRootFile: File.File ¬ File.nullFile;      currentRootFile ¬ Volume.LookUpRootFile[        MesaDEFileTypesExtra.tRootFile, context.volume        ! Volume.RootDirectoryError => ERROR Error[internalFailure]];      IF currentRootFile # rootFileCap THEN {        IF rootFileCap = File.nullFile THEN context.logProc[	  "No valid root file found, so one will be created.\n"L]	ELSE {	  MScavengeOps.LogFileCapability[context, rootFileCap];	  context.logProc[" is an orphaned root file and was replaced\n"L]}}};    rootTree: BTree.Tree;    rootDirStatus: DirectoryStatus;    rootName: STRING ¬ [MFileOps.maxNameLength];    IF rootDirCap = File.nullFile THEN  {      context.logProc["No valid root directory found, so one will be created.\n"L];      IF ~context.repair THEN RETURN;      Volume.RemoveRootFile[	  type: MesaDEFileTypes.tRootDirectory, volume: context.volume !	  Volume.RootDirectoryError => CONTINUE]; -- just in case there is an obsolete value in the root file      rootDirCap ¬ MDirectory.LookupRootDir[context.volume, rootName !        MDirectory.NoRootDir => RESUME; 	Volume.Unknown => ERROR Error[volumeUnknown]];      AddToDirectoryList[context, rootDirCap.fileID]}    ELSE  {      current: File.File ¬ File.nullFile;      current ¬ MDirectory.LookupRootDir[context.volume, rootName !        MDirectory.NoRootDir => CONTINUE; 	Volume.Unknown => ERROR Error[volumeUnknown]];       IF current # rootDirCap AND context.repair THEN { 	Volume.RemoveRootFile[	  type: MesaDEFileTypes.tRootDirectory, volume: context.volume !	  Volume.RootDirectoryError => CONTINUE];	Volume.InsertRootFile[	  type: MesaDEFileTypes.tRootDirectory, file: rootDirCap]}};    ValidateRootFile[];    [rootDirStatus, rootTree] ¬ ValidateDirectory[context, rootDirCap.fileID];    IF rootTree # NIL THEN UnmapDirectory[rootTree];    SELECT rootDirStatus FROM      ok, notInPilotScavengerLog => {        badLP: BOOLEAN ¬ FALSE;        lp: MFileOps.LeaderPage;        lp ¬ MFileOps.MapLeader[          rootDirCap ! MFileOps.InvalidLeader => {	    badLP ¬ TRUE; IF context.repair THEN RESUME ELSE CONTINUE}];        IF ~badLP THEN {  -- check it          tempName: STRING = [MFile.maxNameLength];          MFileOps.GetName[lp, tempName];          IF ~String.EquivalentString[tempName, rootName]            OR lp.fp.dirInfo.type # directory OR lp.fp.dir # rootDirCap.fileID THEN            badLP ¬ TRUE};        IF badLP THEN {          context.logProc["Root directory's leader page is invalid.\n"L];          IF context.repair THEN {            MFileOps.InitLeader[lp, rootDirCap.fileID, directory, rootName, 0];            context.logProc["Root directory's leader page repaired.\n"L]}};        MFileOps.UnmapLeader[lp]};      ENDCASE => ERROR Error[internalFailure];    END;  -- ValidateRootDir  BadLength: PROC [length: LONG CARDINAL, file: File.File] RETURNS [BOOLEAN] =    INLINE    BEGIN    filesizeInBytes: LONG CARDINAL =      (File.GetSize[file] - MFileOps.leaderPages)*Environment.bytesPerPage;    RETURN[(length > filesizeInBytes)];    END;  WarnLength: PROC [length: LONG CARDINAL, file: File.File] RETURNS [BOOLEAN] =    INLINE    BEGIN    filesizeInBytes: LONG CARDINAL =      (File.GetSize[file] - MFileOps.leaderPages)*Environment.bytesPerPage;    RETURN[      (filesizeInBytes > Environment.bytesPerPage)        AND (length < filesizeInBytes - Environment.bytesPerPage)];    END;  GetInfo: INTERNAL PROC [    context: MScavengeOps.Handle, file: File.File, name: STRING, type: MFile.Type]    RETURNS [loop: BOOLEAN, parent: File.ID, value: MDirectory.MValueRec] = {    badLP: BOOLEAN ¬ FALSE;    lp: MFileOps.LeaderPage;    loop ¬ FALSE;    lp ¬ MFileOps.MapLeader[      file ! MFileOps.InvalidLeader => {badLP ¬ TRUE; RESUME }];    IF badLP THEN {      context.logProc["File with bad leader page found.\n"L];      IF ~context.repair THEN {loop ¬ TRUE; RETURN};      name.length ¬ 0;  -- don't have valid name      parent ¬ GenerateNameInDirectory[        name: name, dir: File.nullID, context: context, isDir: type = directory];      value.fID ¬ file.fileID;      value.dirInfo.type ¬ type;      MFileOps.InitLeader[        lp: lp, dirID: parent, type: type, name: name,        initialSizeHint:        IF type = directory THEN 0        ELSE (File.GetSize[file] - MFileOps.leaderPages)*Environment.bytesPerPage];      context.logProc["File renamed to "L];      context.logProc[name];      context.logProc[" and leader page reset.\n"L];      RETURN};    -- good leader page; get info and check validity    IF lp.fp.dirInfo.type = type      OR (lp.fp.dirInfo.type # directory AND type = unknown) THEN {      IF context.verbose THEN {        context.logProc[name]; context.logProc[" okay.\n"L]};      type ¬ lp.fp.dirInfo.type}    ELSE {      context.logProc[name];      SELECT TRUE FROM        lp.fp.dirInfo.type = directory => {  -- type of file is directory          context.logProc[            " is not of directory type but is listed as a subdirectory"L];          IF context.repair THEN {            lp.fp.dirInfo.type ¬ unknown;            context.logProc["; now listed as an ordinary file.\n"L]}          ELSE context.logProc["\n"L]};        type = directory => {          context.logProc[            " is of directory type but is not listed as a subdirectory"L];          IF context.repair THEN {            lp.fp.dirInfo.type ¬ directory;            context.logProc["; now listed as a directory.\n"L]}          ELSE context.logProc["\n"L];          };        ENDCASE => {  -- type is known file type and does not match lp.fp.dirInfo.type          context.logProc[            " does not have file type consistent with its leader page\n"L];          IF context.repair THEN {            lp.fp.dirInfo.type ¬ type;            context.logProc[" is being set to file type "L];            context.logProc[              SELECT type FROM                text => "text"L,                binary => "binary"L,                ENDCASE => "undefined type"L];            context.logProc["\n"L]}}};    IF lp.fp.name.length > BTree.maxNameLength THEN {      context.logProc["File name "];      FOR i: CARDINAL IN [0..lp.fp.name.length) DO        Format.Char[context.logProc, LOOPHOLE[lp.fp.name.bytes[i]]]; ENDLOOP;      Format.Line[context.logProc, "  is too long; it will be truncated"];      IF context.repair THEN lp.fp.name.length ¬ BTree.maxNameLength};    MFileOps.GetName[lp, name];    parent ¬ lp.fp.dir;    value ¬ [file.fileID, lp.fp.dirInfo];    IF parent = File.nullID OR (parent = file.fileID AND file # rootDirCap) THEN {  -- check dir validity      context.logProc[name];      IF parent = File.nullID THEN        context.logProc[          " has a null parent directory, will be inserted in anonymous directory\n"L]      ELSE        context.logProc[          " is its own parent directory, will be inserted in anonymous directory\n"L];      IF context.repair THEN {        parent ¬ GenerateNameInDirectory[          name: name, dir: File.nullID, context: context, isDir: type = directory];        lp.fp.dir ¬ parent};      };    IF ~MDirectory.IsFilename[name] THEN {      Format.Char[context.logProc, '"];      context.logProc[name];      Format.Char[context.logProc, '"];      context.logProc[" is an illegal name; will be changed"L];      IF context.repair THEN {        name.length ¬ 0;        parent ¬ GenerateNameInDirectory[          name: name, dir: parent, context: context, isDir: type = directory];        SetName[lp, name];        context.logProc[" to "L];        context.logProc[name];        Format.CR[context.logProc]}};    IF (type # directory AND WarnLength[length: lp.fp.length, file: file]) THEN {      context.logProc[name];      context.logProc[" has an inconsistent length: logical length "L];      Format.LongNumber[context.logProc, lp.fp.length, []];      context.logProc[" and physical length "L];      Format.LongNumber[        context.logProc,        IF type = directory THEN 0        ELSE (File.GetSize[file] - MFileOps.leaderPages)*Environment.bytesPerPage,        []];      context.logProc["; it will NOT be changed.\n"L]}    ELSE      IF (type = directory AND lp.fp.length # 0)        OR (type # directory AND BadLength[length: lp.fp.length, file: file]) THEN        {        context.logProc[name];        context.logProc[" has an inconsistent length; it will be changed"L];        IF context.repair THEN {          context.logProc[" from "L];          Format.LongNumber[context.logProc, lp.fp.length, []];          lp.fp.length ¬            IF type = directory THEN 0            ELSE              (File.GetSize[file] - MFileOps.leaderPages)*Environment.bytesPerPage;          context.logProc[" to "L];          Format.LongNumber[context.logProc, lp.fp.length, []];          Format.CR[context.logProc]}};    IF lp.fp.create = System.gmtEpoch THEN {      Format.Line[        context.logProc,        "Uninitialized create date; will be set to current time."];      IF context.repair THEN lp.fp.create ¬ Time.Current[]};    IF lp.fp.create > Time.Current[] THEN {      Format.Line[        context.logProc, "Bad create date; will be set to current time."];      IF context.repair THEN lp.fp.create ¬ Time.Current[]};    IF lp.fp.read > Time.Current[] THEN {      Format.Line[context.logProc, "Bad read date; will be set to current time."];      IF context.repair THEN lp.fp.read ¬ Time.Current[]};    IF lp.fp.write > Time.Current[] THEN {      Format.Line[context.logProc, "Bad write date; will be set to current time."];      IF context.repair THEN lp.fp.write ¬ Time.Current[]};    MFileOps.UnmapLeader[lp]};  -- lp declaration  CheckLeaderInfoandInsert: INTERNAL PROC [    context: MScavengeOps.Handle, parentStatus: DirectoryStatus,    value: MDirectory.MValue, type: MFile.Type, file: File.File, parent: File.ID,    name: STRING, tree: BTree.Tree] =    BEGIN    SELECT parentStatus FROM      ok =>        BEGIN  --parentStatus=ok--        IF ~context.repair THEN RETURN;        IF ~MDirectory.InsertInTree[tree, name, file.fileID] THEN {          context.logProc[name];          context.logProc[" couldn't be reinserted"L];          IF tree # NIL THEN UnmapDirectory[tree];          tree ¬ InsertInAnonymousDirectory[            context, name, file.fileID, parent, type = directory]};        MDirectory.SetDirInfoInTree[tree, name, value.dirInfo];        END;  --parentStatus=ok--      nonexistent, notDirectoryType, notInPilotScavengerLog =>        BEGIN  --parentStatus = nonexistent or notDirectoryType or notInPilotScavengerLog--        context.logProc[name];        context.logProc[" has an invalid parent directory file capability.\n"L];        IF ~context.repair THEN RETURN;        IF tree # NIL THEN UnmapDirectory[tree];        tree ¬ InsertInAnonymousDirectory[          context, name, file.fileID, parent, type = directory];        MDirectory.SetDirInfoInTree[tree, name, value.dirInfo];        END;  --parentStatus = nonexistent or notDirectoryType or notInPilotScavengerLog--      ENDCASE => ERROR Error[internalFailure];    END;  InsertOrphan: INTERNAL PROC [context: MScavengeOps.Handle, file: File.ID] = {    lp: MFileOps.LeaderPage;    name: STRING ¬ [MFileOps.maxNameLength];    tree: BTree.Tree;    type: MFile.Type;    lp ¬ MFileOps.MapLeader[CapaForID[context, file]];    MFileOps.GetName[lp, name];    type ¬ lp.fp.dirInfo.type;    MFileOps.UnmapLeader[lp];    tree ¬ InsertInAnonymousDirectory[      context, name, file, File.nullID, type = directory];    IF tree # NIL THEN UnmapDirectory[tree]};  MarkTree: INTERNAL PROC [context: MScavengeOps.Handle, i: CARDINAL] =    BEGIN    tree: BTree.Tree;    rec: MDirectory.MValueRec;    value: BTree.Value = MDirectory.MValueToValue[@rec];    name: STRING ¬ [MFileOps.maxNameLength];    next: STRING ¬ [MFileOps.maxNameLength];    dirCache[i].reachable ¬ TRUE;    tree ¬ MapDirectory[context, dirCache[i].id];    DO      BTree.GetNext[tree, name, next, value];      IF next.length = 0 THEN EXIT;      MoveString[to: name, from: next];      SELECT rec.dirInfo.type FROM        directory =>          FOR j: CARDINAL IN [0..dirCacheEntries) DO            IF dirCache[j].id = rec.fID THEN {              IF ~dirCache[j].reachable THEN {                dirCache[j].reachable ¬ TRUE; MarkTree[context, j]};              EXIT};            ENDLOOP;        ENDCASE =>          FOR j: CARDINAL IN [0..fileCacheEntries) DO            IF fileCache[j].id = rec.fID THEN {              fileCache[j].reachable ¬ TRUE; EXIT};            ENDLOOP;      ENDLOOP;    UnmapDirectory[tree];    END;  SetName: PROCEDURE [lp: MFileOps.LeaderPage, name: LONG STRING] = {    IF name = NIL THEN {lp.fp.name.length ¬ 0; RETURN};    IF name.length > MFileOps.maxNameLength THEN      ERROR MFile.Error[NIL, illegalName ! MFile.NameForError => RESUME [name]];    lp.fp.name.length ¬ ByteBlt.ByteBlt[      to: [@lp.fp.name.bytes, 0, MFileOps.maxNameLength],      from: [LOOPHOLE[@name.text], 0, name.length]]};  END.  of MScavengeImplA.mesa  -- RLC		 2-Sep-86 12:03:59  Make way for labelless disks. Use SpecialFile.MakeFileLIst since Scavenger log no longer does enumeration. Need to Clean up VolumeConversion MConvertLP stuff Scavenger IF Shot-- 8-Jan-87 15:45:13 - rlc - MConvertLP shot since VolumeConversion is no longer-- 8-Jan-87 15:48:21 - rlc - VolumeConversion buys it. also conversionLog and conversionFile-- 9-Jan-87  9:26:33 - rlc - Scavenger buys it-- 9-Jan-87 10:24:24 - rlc - Garbage buys it.-- 16-Jan-87 18:50:35 - Riggle - MDS changes-- 30-Jan-87 10:53:12 - SpecialFile.MakeFileList goes away, replaced by Scavenger.MakeFileList so change Header and FileEntry. Add CR (\n) to output line in GenerateUniqueName.
-- Copyright (C) 1981, 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- MSegmentImpl.mesa  Edited by-- PXK    ,	11-Nov-81 13:54:32-- LXR    ,	 9-Jan-84 12:20:54-- SXS   ,	22-Oct-81  9:21:50-- JGS, 	15-Jul-82 17:03:28-- RXJ     , 	15-Nov-83 15:23:15-- DWE    , 	26-Jul-83 17:56:38DIRECTORY  Environment USING [bytesPerPage, PageCount, PageNumber],  File USING [    Error, File, GetSize, nullFile, PageCount, PageNumber],  Heap USING [CreateUniform],  MFile USING [    Access, Error, GetAccess, GetLength, Handle,     PleaseReleaseProc, Release, ReleaseChoice, ReleaseData,     SameFile, SetReleaseData, SetTimes],  MFileOps USING [    GetCapa, leaderPages, NoteCaller, RemoteFile, RemoteHandle],  MSegment USING [    defaultPages, defaultSwapUnitOption, dontChangeFileBase, dontChangeFile,    dontChangePages, dontChangeReleaseData, dontChangeUsage,    ErrorCode, PleaseReleaseProc, ReleaseData, SwapUnitOption],  MSegmentOps USING [Handle, msegmentPassword, Object],  RFile USING [ReadDataPages, WriteDataPages],  Runtime USING [GetCaller],  Space USING [    Activate, CopyIn, CopyOut, Deactivate, Error,    ForceOut, GetMapUnitAttributes,    InsufficientSpace, Interval, Kill, LongPointerFromPage,     MakeReadOnly, MakeWritable, Map, MapAt,    nullInterval, PageFromLongPointer, PagesFromWords,     unknownUsage, Unmap, UnmapAt, Usage, wordsPerPage],  SpecialMSegment USING [],  System USING [GetGreenwichMeanTime],  Time USING [Packed],  VM USING [MakeResident, MakeSwappable],  Volume USING [InsufficientSpace, ReadOnly];MSegmentImpl: MONITOR LOCKS segment USING segment: Handle  IMPORTS File, Heap, MFile, MFileOps,     RFile, Runtime, Space, System, VM, Volume   EXPORTS MSegment, MSegmentOps, SpecialMSegment =  BEGIN-- types  ReleaseData: TYPE = MSegment.ReleaseData;  PageCount: TYPE = Environment.PageCount;  PageNumber: TYPE = Environment.PageNumber;  defaultPages: PageCount = MSegment.defaultPages;    Handle: TYPE = MSegmentOps.Handle;  Object: PUBLIC TYPE = MSegmentOps.Object;        -- globals  z: UNCOUNTED ZONE ¬ Heap.CreateUniform[initial: 1, objectSize: SIZE[Object]];  segments: Handle ¬ z.NEW[Object ¬     [space: Space.nullInterval, file: NIL, fileBase: 0, releaseData: [NIL, NIL],      refCount: 0, next: NIL]];  Error: PUBLIC ERROR [segment: Handle, code: MSegment.ErrorCode] = CODE;  ImplementationError: SIGNAL [segment: Handle, reason: LONG STRING ¬ NIL] = CODE;-- public procedures  Activate: PUBLIC PROCEDURE [segment: Handle] =    BEGIN    ValidateHandle[segment];    Space.Activate[segment.space ! Space.Error => Error[segment, noSuchSegment]];    END;  Address: PUBLIC PROCEDURE [segment: Handle] RETURNS [LONG POINTER] =    BEGIN    ValidateHandle[segment];    RETURN[segment.space.pointer];     END;      AddresstoSegment: PUBLIC PROCEDURE [pointer: LONG POINTER] RETURNS [h: Handle] =    BEGIN ENABLE Space.Error => ERROR Error[NIL, noSuchSegment];    h ¬ SegmentFromAddress[pointer, segments];    IF h = NIL THEN ERROR Error[NIL, noSuchSegment];    END;      Base: PUBLIC PROCEDURE [segment: Handle] RETURNS [PageNumber] =    BEGIN    RETURN[Space.PageFromLongPointer[Address[segment]]];    END;      BasetoSegment: PUBLIC PROCEDURE [page: PageNumber] RETURNS [h: Handle] =    BEGIN    h ¬ AddresstoSegment[Space.LongPointerFromPage[page]];     END;      CopyIn: PUBLIC PROCEDURE [    segment: Handle, file: MFile.Handle, fileBase: File.PageNumber,     count: PageCount] =    BEGIN ENABLE Volume.ReadOnly => ERROR Error[segment, illegalAccess];    ValidateHandle[segment];    IF count = 0 THEN Error[segment, zeroLength];    IF MFileOps.RemoteFile[file] THEN      RFile.ReadDataPages[        h: MFileOps.RemoteHandle[file], p: segment.space.pointer,        base: fileBase,	count: PagesToTransfer[file: file, fileBase: fileBase, count: count]]    ELSE      [] ¬ Space.CopyIn[        pointer: segment.space.pointer,         window: [          file: MFileOps.GetCapa[file], base: fileBase + MFileOps.leaderPages,	  count: count] !        Space.Error => IF type = invalidWindow THEN           ERROR Error[segment, baseOutOfRange] 	  ELSE ERROR Error[segment, noSuchSegment]];    END;      CopyOut: PUBLIC PROCEDURE [    segment: Handle, file: MFile.Handle, fileBase: File.PageNumber,     count: PageCount] =    BEGIN ENABLE Volume.ReadOnly => ERROR Error[segment, illegalAccess];    ValidateHandle[segment];    IF count = 0 THEN Error[segment, zeroLength];    IF MFileOps.RemoteFile[file] THEN      RFile.WriteDataPages[        h: MFileOps.RemoteHandle[file], p: segment.space.pointer,        base: fileBase,	count: PagesToTransfer[file: file, fileBase: fileBase, count: count]]    ELSE      [] ¬ Space.CopyOut[        pointer: segment.space.pointer,         window: [          file: MFileOps.GetCapa[file], base: fileBase + MFileOps.leaderPages,	  count: count] !        Space.Error => IF type = invalidWindow THEN           ERROR Error[segment, baseOutOfRange] 	  ELSE ERROR Error[segment, noSuchSegment]];    END;      CopySegment: PUBLIC ENTRY PROCEDURE [segment: Handle] RETURNS [newSegment: Handle] =    BEGIN ENABLE UNWIND => NULL;    ValidateHandle[segment];    segment.refCount ¬ segment.refCount + 1;    RETURN[segment];    END;      Create: PUBLIC PROCEDURE [    file: MFile.Handle ¬ NIL, release: ReleaseData, fileBase: File.PageNumber ¬ 0,    pages: PageCount ¬ defaultPages,    swapInfo: MSegment.SwapUnitOption ¬ MSegment.defaultSwapUnitOption,    usage: Space.Usage ¬ Space.unknownUsage]    RETURNS [segment: Handle] =    BEGIN ENABLE {Space.Error => Error[NIL, other];                   Volume.ReadOnly => ERROR Error[NIL, illegalAccess]};    IF file # NIL THEN     SELECT MFile.GetAccess[file ! MFile.Error => Error[NIL, invalidFile]] FROM      readOnly, readWrite => NULL;      ENDCASE => Error[NIL, illegalAccess];    IF pages = 0 THEN ERROR Error[NIL, zeroLength];    IF pages = defaultPages THEN SELECT TRUE FROM      file = NIL => ERROR Error[NIL, dataSegmentNeedsPages];      ENDCASE => pages ¬ Space.PagesFromWords[MFile.GetLength[file]];    IF release.proc = NIL THEN      release.clientInstanceData ¬ MFileOps.NoteCaller[Runtime.GetCaller[]];    segment ¬ z.NEW[Object ¬        [space: Space.nullInterval, file: NIL, fileBase: 0,         releaseData: [NIL, NIL], refCount: 0, next: NIL]];    BEGIN ENABLE UNWIND => z.FREE[@segment];    segment.refCount ¬ 1;    SetSegmentSpace[segment, file, release, fileBase, pages, swapInfo, usage !       Space.InsufficientSpace => ERROR Error [NIL, insufficientVM]];    AddToSegments[segment, segments];    END; -- ENABLE    END;      Deactivate: PUBLIC PROCEDURE [segment: Handle] =    BEGIN    ValidateHandle[segment];    Space.Deactivate[segment.space];    END;  Delete: PUBLIC PROCEDURE [segment: Handle] =    BEGIN    copy: MFile.Handle ¬ NIL;    copyRefCount: CARDINAL;    CheckRelease: ENTRY PROCEDURE [segment: Handle] = {      ENABLE UNWIND => NULL;      segment.refCount ¬ segment.refCount - 1;      copyRefCount ¬ segment.refCount;      IF copyRefCount = 0 THEN {        RemoveFromSegments[segment, segments];        copy ¬ segment.file;	segment.file ¬ NIL}};    ValidateHandle[segment];    CheckRelease[segment];     IF copyRefCount = 0 THEN {DeleteSpace[segment, copy]; z.FREE[@segment]};    IF copy # NIL THEN MFile.Release[copy];     END;      EquivalentSegments: PUBLIC PROC [seg1, seg2: Handle] RETURNS [BOOLEAN] = {    SELECT TRUE FROM      seg1 = NIL => RETURN[seg2 = NIL];      seg2 = NIL => RETURN[FALSE];      ENDCASE;    ValidateHandle[seg1];    ValidateHandle[seg2];    SELECT TRUE FROM      seg1.fileBase # seg2.fileBase => RETURN[FALSE];      Pages[seg1] # Pages[seg2] => RETURN[FALSE];      ENDCASE;    RETURN[MFile.SameFile[seg1.file, seg2.file]]};     ForceOut: PUBLIC PROCEDURE [segment: Handle] =    BEGIN ENABLE Volume.ReadOnly => ERROR Error[segment, illegalAccess];    space: Space.Interval;    file: MFile.Handle;    ValidateHandle[segment];    space ¬ segment.space;    file ¬ segment.file;    WriteRemotePagesMaybe[segment, segment.file];    Space.ForceOut[segment.space ! Space.Error => Error[segment, noSuchSegment]];    END;      GetFile: PUBLIC PROCEDURE [segment: Handle] RETURNS [MFile.Handle] =    BEGIN    ValidateHandle[segment];    RETURN[segment.file];    END;      GetFileBase: PUBLIC PROCEDURE [segment: Handle] RETURNS [File.PageNumber] =    BEGIN    ValidateHandle[segment];    RETURN[segment.fileBase];    END;      GetFilePages: PUBLIC PROCEDURE [segment: Handle] RETURNS [File.PageCount] =    BEGIN    file: MFile.Handle;    ValidateHandle[segment];    IF MFileOps.RemoteFile[file ¬ segment.file] THEN {      bytesPerPage: CARDINAL = Environment.bytesPerPage;      RETURN[Space.PagesFromWords[MFile.GetLength[file]]]}    ELSE RETURN[File.GetSize[MFileOps.GetCapa[file]] - MFileOps.leaderPages];    END;  GetReleaseData: PUBLIC ENTRY PROCEDURE [segment: Handle]     RETURNS [MSegment.ReleaseData] =    BEGIN    ValidateHandle[segment];    RETURN[segment.releaseData];    END;      Kill: PUBLIC PROCEDURE [segment: Handle] =    BEGIN     ValidateHandle[segment];    IF segment.refCount = 1 THEN Space.Kill[segment.space ! Space.Error => Error[segment, noSuchSegment]];    END;      MakeReadOnly: PUBLIC PROCEDURE [segment: Handle] =    BEGIN    ValidateHandle[segment];    ForceOut[segment];    Space.MakeReadOnly[segment.space ! Space.Error => Error[segment, other]];    END;      MakeResident: PUBLIC PROCEDURE [segment: Handle] =    BEGIN    ValidateHandle[segment];    VM.MakeResident[      [Space.PageFromLongPointer[segment.space.pointer], segment.space.count],      wait];    END;    MakeSwappable: PUBLIC PROCEDURE [segment: Handle] =    BEGIN    ValidateHandle[segment];    VM.MakeSwappable[      [Space.PageFromLongPointer[segment.space.pointer], segment.space.count]];    END;  MakeWritable: PUBLIC PROCEDURE [segment: Handle] =    BEGIN ENABLE Volume.ReadOnly => ERROR Error[segment, illegalAccess];    file: MFile.Handle;    ValidateHandle[segment];    IF (file ¬ segment.file) # NIL THEN {      IF MFile.GetAccess[file] = readOnly THEN ERROR Error[segment, illegalAccess];      IF MFileOps.RemoteFile[file] THEN Error[segment, other]};    Space.MakeWritable[segment.space !      Space.Error => Error[segment, other];      File.Error => Error[segment, illegalAccess]];    END;      Pages: PUBLIC PROCEDURE [segment: Handle] RETURNS [PageCount] =    BEGIN    ValidateHandle[segment];    RETURN[segment.space.count];    END;      Reset: PUBLIC PROCEDURE [    segment: Handle, file: MFile.Handle ¬ MSegment.dontChangeFile,     release: MSegment.ReleaseData ¬ MSegment.dontChangeReleaseData,     fileBase: File.PageNumber ¬ MSegment.dontChangeFileBase,     pages: Environment.PageCount ¬ MSegment.dontChangePages,    swapInfo: MSegment.SwapUnitOption ¬ MSegment.defaultSwapUnitOption,    usage: Space.Usage ¬ MSegment.dontChangeUsage] =    BEGIN  ENABLE {Space.Error => Error[segment, noSuchSegment];                   Volume.ReadOnly => ERROR Error[segment, illegalAccess]};    copy: MFile.Handle ¬ NIL;     FirstPart: ENTRY PROCEDURE [segment: Handle]       RETURNS [releaseIt: BOOLEAN ¬ FALSE] =      BEGIN ENABLE UNWIND => NULL;      IF file = MSegment.dontChangeFile THEN file ¬ segment.file;      SELECT TRUE FROM        release = MSegment.dontChangeReleaseData => release ¬ segment.releaseData;        release.proc = NIL =>          release.clientInstanceData ¬ MFileOps.NoteCaller[Runtime.GetCaller[]];        ENDCASE;      IF fileBase = MSegment.dontChangeFileBase THEN fileBase ¬ segment.fileBase;      IF pages = MSegment.dontChangePages THEN pages ¬ Pages[segment];      IF segment.refCount > 1 THEN Error[segment, sharedSegment];      WriteRemotePagesMaybe[segment, segment.file];      IF segment.space.count < pages THEN         segment.space.pointer ¬ Space.Unmap[segment.space.pointer]      ELSE segment.space.pointer ¬ Space.UnmapAt[segment.space.pointer].pointer;       IF segment.file # file AND segment.file # NIL THEN {        copy ¬ segment.file;        segment.file ¬ NIL;	releaseIt ¬ TRUE};      IF usage = MSegment.dontChangeUsage THEN        usage ¬ Space.GetMapUnitAttributes[segment.space.pointer].usage;      SetSegmentSpace[segment, file, release, fileBase, pages, swapInfo, usage];      END;   ValidateHandle[segment];   IF FirstPart[segment] AND copy # NIL THEN MFile.Release[copy];    END;  SetReleaseData: PUBLIC ENTRY PROCEDURE [segment: Handle, release: ReleaseData] =    {ValidateHandle[segment];    IF release.proc = NIL THEN      release.clientInstanceData ¬ MFileOps.NoteCaller[Runtime.GetCaller[]];    segment.releaseData ¬ release};-- utility procedures  AddToSegments:  ENTRY PROCEDURE [seg: Handle, segment: Handle] =    BEGIN ENABLE UNWIND => NULL; -- assert that segment == segments and that segments is now locked    seg.next ¬ segments.next;    segments.next ¬ seg;    END;      DeleteSpace:  PROCEDURE [segment: Handle, file: MFile.Handle] =    BEGIN    WriteRemotePagesMaybe[segment, file];    segment.space.pointer ¬ Space.Unmap[segment.space.pointer ! Space.Error => Error[segment, noSuchSegment]];    END;      ReleaseFile: MFile.PleaseReleaseProc = {    segment: Handle;    c: MFile.ReleaseChoice;    [c, segment] ¬ RealReleaseFile[file, instanceData];    IF c = goAhead THEN {DeleteSpace[segment, segment.file]; z.FREE[@segment]};    RETURN[c]};  PagesToTransfer: PUBLIC PROCEDURE [    file: MFile.Handle, fileBase: File.PageNumber,     count: LONG CARDINAL] RETURNS [CARDINAL] =    BEGIN    fileLength: File.PageCount = Space.PagesFromWords[MFile.GetLength[file]];    RETURN[CARDINAL[MIN[count, fileLength-fileBase]]];    END;      RealReleaseFile: ENTRY PROCEDURE [file: MFile.Handle, segment: Handle] RETURNS [c: MFile.ReleaseChoice, s: Handle] =    BEGIN ENABLE UNWIND => NULL;    IF segment.releaseData.proc = NIL THEN RETURN[no, segment];    IF segment.file = NIL THEN RETURN[later, segment];    c ¬ segment.releaseData.proc[          segment, segment.releaseData.clientInstanceData];    IF c # goAhead THEN RETURN[c, segment];    RemoveFromSegments[segment, segments];    RETURN[goAhead, segment];    END;      SegmentFromAddress: ENTRY PROCEDURE [address: LONG POINTER, segment: Handle] RETURNS [h: Handle ¬ NIL] =    BEGIN ENABLE UNWIND => NULL; -- assert that segment == segments and that segments is now locked    temp: Handle ¬ segments.next;    LP: PROCEDURE [a:LONG POINTER] RETURNS [LONG ORDERED POINTER] =       INLINE{RETURN[LOOPHOLE[a]]};    WHILE temp # NIL DO       IF LP[temp.space.pointer] <=LP[address] AND        LP[address] < LP[temp.space.pointer] + temp.space.count * Space.wordsPerPage 	THEN RETURN[temp];      temp ¬ temp.next;      ENDLOOP;    END;      RemoveFromSegments:  ENTRY PROCEDURE [seg: Handle, segment: Handle] =    BEGIN ENABLE UNWIND => NULL; -- assert that segment == segments and that segments is now locked    temp: Handle ¬ segments;    p: Handle ¬ segments.next;    WHILE p # NIL DO      IF p = seg THEN {temp.next ¬ p.next; RETURN};      temp ¬ p;       p ¬ p.next;      ENDLOOP;    END;      SetSegmentSpace: PROCEDURE [    segment: Handle, file: MFile.Handle, release: ReleaseData,     base: File.PageNumber, pages: PageCount,    swapInfo: MSegment.SwapUnitOption, usage: Space.Usage] =    BEGIN    now: Time.Packed;    remoteFile: BOOLEAN;    segment.file ¬ file;    segment.releaseData ¬ release;    segment.fileBase ¬ base;    IF file # NIL THEN {      MFile.SetReleaseData[file, [ReleaseFile, segment] !        MFile.Error => Error[segment, invalidFile]];      remoteFile ¬ MFileOps.RemoteFile[file]}    ELSE remoteFile ¬ FALSE;    IF segment.space.pointer = NIL THEN      segment.space ¬ Space.Map[        window:          IF file = NIL OR remoteFile THEN [	    file: File.nullFile, base: NULL, count: pages]           ELSE [	    file: MFileOps.GetCapa[file], base: base + MFileOps.leaderPages,	     count: pages],        class: IF file = NIL OR remoteFile THEN data ELSE file,       access: IF file = NIL OR remoteFile THEN readWrite               ELSE SELECT MFile.GetAccess[file] FROM 	              readOnly => readOnly, ENDCASE => readWrite,       usage: usage,       swapUnits: swapInfo	  ! Space.Error =>	      IF type = invalidWindow THEN ERROR Error[segment, baseOutOfRange];	    Volume.InsufficientSpace => ERROR Error[segment, noRoomOnVolume]]     ELSE [] ¬ Space.MapAt[       at: segment.space,        window:          IF file = NIL OR remoteFile THEN [	    file: File.nullFile, base: NULL, count: pages]           ELSE [	    file: MFileOps.GetCapa[file], base: base + MFileOps.leaderPages, count: pages],        class: IF file = NIL OR remoteFile THEN data ELSE file,       access: IF file = NIL OR remoteFile THEN readWrite               ELSE SELECT MFile.GetAccess[file] FROM 	              readOnly => readOnly, ENDCASE => readWrite,       usage: usage,       swapUnits: swapInfo	  ! Space.Error =>	      IF type = invalidWindow THEN ERROR Error[segment, baseOutOfRange];	    Volume.InsufficientSpace => ERROR Error[segment, noRoomOnVolume]];    IF file # NIL THEN {      now ¬ System.GetGreenwichMeanTime[];      SELECT MFile.GetAccess[file] FROM        readOnly => MFile.SetTimes[file: file, read: now	  ! MFile.Error => IF code = volumeReadOnly THEN CONTINUE];        readWrite => MFile.SetTimes[file: file, read: now, write: now];         ENDCASE};    IF remoteFile THEN {      count: CARDINAL = PagesToTransfer[	file: file, fileBase: base, count: pages];      RFile.ReadDataPages[        h: MFileOps.RemoteHandle[file], p: segment.space.pointer,        base: base, count: count]};    END;      ValidateHandle: PROCEDURE [h: Handle] = INLINE    BEGIN    IF h = NIL OR h.password # MSegmentOps.msegmentPassword THEN ERROR Error[h, noSuchSegment];    END;      WriteRemotePagesMaybe: PROCEDURE [segment: Handle, file: MFile.Handle] =    BEGIN    space: Space.Interval = segment.space;    count: CARDINAL;    IF file = NIL OR ~MFileOps.RemoteFile[file] OR MFile.GetAccess[file] = readOnly THEN RETURN;    count ¬  PagesToTransfer[      file: file, fileBase: segment.fileBase,      count: space.count];    RFile.WriteDataPages[      h: MFileOps.RemoteHandle[file], p: space.pointer,      base: segment.fileBase, count: count];    END;       -- procedures moved from Storage     GetPages: PUBLIC PROCEDURE [npages: CARDINAL] RETURNS [base: LONG POINTER] =    BEGIN     RETURN [      Space.Map[        window: [File.nullFile, 0, npages],	class: data, life: dead,	swapUnits: IF npages > 7 THEN [uniform[4]] ELSE [unitary[]]].pointer];    END;      GetWords: PUBLIC PROCEDURE [nwords: CARDINAL] RETURNS [base: LONG POINTER] = {    RETURN[GetPages[CARDINAL[Space.PagesFromWords[nwords]]]]};    FreePages, FreeWords: PUBLIC PROCEDURE [base: LONG POINTER] =    BEGIN    IF base # NIL THEN [] ¬ Space.Unmap[base];    END;          END.  
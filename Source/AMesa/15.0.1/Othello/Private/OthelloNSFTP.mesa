-- File: OthelloNSFTP.mesa - last edit:-- bjd                 23-Aug-85 16:18:16--   lgr	13-Feb-84 15:31:26--   rkj	24-Feb-84 18:36:31-- Copyright (C) 1984, 1985 by Xerox Corporation. All rights reserved.DIRECTORY  AddressTranslation USING [Error, PrintError, StringToNetworkAddress],  Auth USING [FreeIdentity, IdentityHandle, MakeIdentity],  CH USING [MakeRhs],  Courier USING [ErrorCode, Error],  NSErrorMsg USING [PostCourierError, PostNSFileError],  Heap USING [systemZone],  Format USING [StringProc],  NSDataStream USING [Abort, Aborted, Handle, SourceStream],  NSFile USING [    AttributesProc, AttributesRecord, Close, Error, ErrorRecord, Find, GetAttributes,    Handle, List, Logoff, LogonDirect, maxStringLength, nullHandle, nullSession, Open,    Retrieve, Scope, Selections, ServiceRecord, Session, String, Time],  NSName USING [    AppendNameToString, Error, FreeNameFields, maxDomainLength, maxFullNameLength,    maxOrgLength, Name, NameFieldsFromString, NameRecord, String],  OthelloDefs USING [    AbortingCommand, CheckUserAbort, CommandProcessor, GetName,    IndexTooLarge, MyNameIs, RegisterCommandProc, SetCommandString,    SetCursor, WriteChar, WriteLine, WriteString],  OthelloFetch USING [    Destination, directory, Handle, GrabBitsFromStream, Object, Register, Select,    StartFeedback, userName, userPassword],  Profile USING [GetDefaultDomain, GetDefaultOrganization],  Runtime USING [GlobalFrame],  Stream USING [Delete, Handle],  String USING [    AppendChar, AppendCharAndGrow, AppendNumber, AppendString, AppendStringAndGrow,    CopyToNewString, Empty, Length, StringBoundsFault, SubString, SubStringDescriptor],  Time USING [Append, Unpack];OthelloNSFTP: PROGRAM  IMPORTS    AddressTranslation, Auth, CH, Courier, NSErrorMsg, Heap,    NSDataStream, NSFile,    NSName, OthelloDefs, OthelloFetch, Profile, Runtime, Stream, String, Time =  BEGIN    host: LONG STRING ¬ NIL;    nsFileSession: NSFile.Session ¬ NSFile.nullSession;  z: UNCOUNTED ZONE = Heap.systemZone;    --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- String/Credentials Commands  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~--  I don't believe we need this proc anymore; It no longer make sense to allow network addresses; must get to Auth server anyway;  Qualify: PROC [token: LONG STRING] RETURNS [newToken: LONG STRING] = {    octalAddress: BOOLEAN ¬ TRUE; -- only '0..'7 and '# allowed    chChar: CHARACTER = ':;    defaultDomain, defaultOrganization: LONG STRING ¬ NIL;    GetDomain: PROC[domain: LONG STRING] =      {IF domain # NIL THEN        String.AppendStringAndGrow[@defaultDomain, domain, z]};    GetOrg: PROC[org: LONG STRING] =      {IF org # NIL THEN        String.AppendStringAndGrow[@defaultOrganization, org, z]};    IF String.Length[token] = 0 THEN RETURN[NIL];    FOR i: CARDINAL IN [0..token.length) DO       SELECT token[i] FROM	 chChar => {RETURN[String.CopyToNewString[token, z]]}; -- already qualified	 IN['0..'7], '# => NULL;	 ENDCASE => octalAddress ¬ FALSE;       ENDLOOP;    newToken ¬ String.CopyToNewString[token, z];    IF octalAddress THEN RETURN;    Profile.GetDefaultDomain[GetDomain];    Profile.GetDefaultOrganization[GetOrg];    IF String.Length[defaultDomain] > 0 OR       String.Length[defaultOrganization] > 0 THEN {	  String.AppendCharAndGrow[@newToken, chChar, z];	  String.AppendStringAndGrow[@newToken, defaultDomain, z];	  String.AppendCharAndGrow[@newToken, chChar, z];	  String.AppendStringAndGrow[@newToken, defaultOrganization, z]};    z.FREE[@defaultDomain];    z.FREE[@defaultOrganization]};  DoIndirect: PROC [cmFile: LONG STRING] RETURNS [mine: BOOLEAN] =    BEGIN    fileName: LONG STRING ¬ NIL;    ParseCmFileName: PROC = {      hostEnd: CARDINAL;      IF cmFile.length = 0 THEN RETURN;      FOR i: CARDINAL IN [0..cmFile.length) DO        c: CHARACTER = cmFile[i];        SELECT c FROM          '[ => LOOP; '] => {hostEnd ¬ i; EXIT};          ENDCASE => String.AppendCharAndGrow[@host, c, z];        REPEAT FINISHED => {z.FREE[@host]; RETURN}	ENDLOOP;      -- hostEnd points at ']       FOR i: CARDINAL IN (hostEnd..cmFile.length) DO        IF cmFile[i] = '< AND OthelloFetch.directory#NIL THEN	  OthelloFetch.directory.length ¬ 0;        String.AppendCharAndGrow[@fileName, cmFile[i], z];	IF cmFile[i] = '> THEN {	  String.AppendStringAndGrow[	    @OthelloFetch.directory, fileName, z];	  fileName.length ¬ 0};	ENDLOOP};    s:         LONG STRING ¬ NIL;    GetString: PROC [c: LONG STRING] = {s ¬ String.CopyToNewString[c, z]};    IF cmFile[0] # '[ THEN RETURN [FALSE];    z.FREE[@host];    z.FREE[@OthelloFetch.directory];    ParseCmFileName[];    OthelloFetch.Select[@fetcher]; Open[];    Retrieve[fileName, [string[GetString]]      ! UNWIND => {z.FREE[@s]; z.FREE[@fileName]}];    OthelloDefs.WriteLine["done"L];    OthelloDefs.SetCommandString[s];    z.FREE[@fileName];    RETURN[TRUE]    END;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- MISC Stuff/Commands  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  userOpened: BOOLEAN ¬ FALSE;  OpenCmd: PROC = {    OthelloDefs.MyNameIs[      myNameIs: "Open Connection"L,      myHelpIs: "Open connection to file service"L];    OthelloFetch.Select[@fetcher];    OthelloDefs.GetName["Open connection to "L, @host];    Open[]; userOpened ¬ TRUE};  ReOpen: PROC RETURNS [BOOLEAN] = {    IF userOpened=FALSE THEN RETURN[FALSE];    Open[]; RETURN[TRUE]};      RemoteList: PROC [fileName: LONG STRING] = {    IF ~ConnectionOpen[] AND ~ReOpen[] THEN      OthelloDefs.AbortingCommand["Please open a connection"L];    ListFiles[IF String.Length[fileName] = 0 THEN "*"L ELSE fileName]};  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Central commands  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  commandProcessor: OthelloDefs.CommandProcessor ¬ [FtpCommands];  FtpCommands: PROC [index: CARDINAL] = {    SELECT index FROM      0 => OpenCmd[];     ENDCASE => OthelloDefs.IndexTooLarge};  fetcher: OthelloFetch.Object ¬ [    Retrieve: Retrieve,    DoIndirect: DoIndirect,    List: RemoteList,    Close: Close];  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- file retrieval Stuff/Commands  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  ConnectionOpen: PROC RETURNS [BOOLEAN] = {    RETURN[nsFileSession # NSFile.nullSession]};      -- all callers close the connection first  Open: PROC = {    clientDefaultsRecord: NSName.NameRecord;    defaultCHOrg: LONG STRING = [NSName.maxOrgLength];    defaultCHDomain: LONG STRING = [NSName.maxDomainLength];    serviceName: LONG STRING ¬ [NSName.maxFullNameLength];    serviceRec: NSFile.ServiceRecord ¬ [];    nameRecord: NSName.NameRecord ¬ [];    id: Auth.IdentityHandle ¬ NIL;    user: LONG STRING ¬ NIL;        GetDomain: PROC[domain: LONG STRING] = {      String.AppendString[defaultCHDomain, domain !	String.StringBoundsFault => RESUME[NIL]]};    GetOrg: PROC[org: LONG STRING] = {      String.AppendString[defaultCHOrg, org !	String.StringBoundsFault => RESUME[NIL]]};    AppendNameToString: PROCEDURE [s: LONG STRING, name: NSName.Name] = {      newS: NSName.String ¬ NSName.AppendNameToString[s: S[s], name: name];      s.length ¬ newS.length};    Cleanup: PROCEDURE = {      z.FREE[@user]; Auth.FreeIdentity[@id, z];      NSName.FreeNameFields[z, @serviceRec.name];      NSName.FreeNameFields[z, @nameRecord]};    IF nsFileSession # NSFile.nullSession THEN RETURN;    Profile.GetDefaultDomain[GetDomain];    Profile.GetDefaultOrganization[GetOrg];    clientDefaultsRecord ¬ [domain: S[defaultCHDomain], org: S[defaultCHOrg]];    NSName.NameFieldsFromString[      z: z, s: S[host], destination: @serviceRec.name,      clientDefaults: @clientDefaultsRecord !        NSName.Error => OthelloDefs.AbortingCommand["Illegal host name"L]];    AppendNameToString[serviceName, @serviceRec.name];    NSName.NameFieldsFromString[      z: z, s: S[OthelloFetch.userName], destination: @nameRecord,      clientDefaults: @clientDefaultsRecord !        UNWIND => NSName.FreeNameFields[z, @serviceRec.name];        NSName.Error => OthelloDefs.AbortingCommand["Illegal login name"L]];    id ¬ MakeIdentity[name: @nameRecord, password: OthelloFetch.userPassword];    {ENABLE UNWIND => Cleanup[];    serviceRec.systemElement ¬ AddressTranslation.StringToNetworkAddress[      s: serviceName, id: id !      AddressTranslation.Error => {        msg: LONG STRING ¬ [100];	appendErrorMsg: Format.StringProc = {	  String.AppendString[msg, s ! String.StringBoundsFault => RESUME[NIL]]};	AddressTranslation.PrintError[error: errorRecord, proc: appendErrorMsg];        OthelloDefs.AbortingCommand[msg]}].addr;    nsFileSession ¬ NSFile.LogonDirect[      identity: id, service: @serviceRec	! NSFile.Error => NSError[error];	  Courier.Error => CourierError[errorCode]];     Cleanup[]}};       MakeIdentity: PROC [name: NSName.Name, password: LONG STRING]    RETURNS [ident: Auth.IdentityHandle] = {    ident ¬ Auth.MakeIdentity[      myName: name, password: S[password],      z: z, style: simple, dontCheck: TRUE]};    Close: PROC = {    IF ~ConnectionOpen[] THEN RETURN;    NSFile.Logoff[nsFileSession       ! NSFile.Error => NSError[error];	Courier.Error => CourierError[errorCode];	OthelloDefs.AbortingCommand => {	  OthelloDefs.WriteString[reason];	  OthelloDefs.WriteLine[reasonOne];	  CONTINUE}];    nsFileSession ¬ NSFile.nullSession;    OthelloDefs.WriteLine["connection closed"L]};    -- could mess with directories.  -- who cares  ListFiles: PROC [pattern: LONG STRING]= {    scope: NSFile.Scope ¬ [];    selections: NSFile.Selections ¬ [];    fh: NSFile.Handle;    dir: LONG STRING ¬ NIL;    wildCardInFileName: BOOLEAN ¬ FALSE;    name: LONG STRING ¬ NIL;    ss: String.SubStringDescriptor ¬ [base: NIL, offset: 0, length: 0];    ListOne: NSFile.AttributesProc = {      version: LONG STRING ¬ [20];      time: LONG STRING ¬ [20];      Time.Append[time, Time.Unpack[attributes.createdOn]];      String.AppendChar[version, '!];      String.AppendNumber[version, attributes.version];    <<  FOR i: CARDINAL IN [0..attributes.pathname.length) DO        OthelloDefs.WriteChar[VAL[attributes.pathname.bytes[i]]];        ENDLOOP;>>      OthelloDefs.WriteString[dir];      FOR i: CARDINAL IN [0..attributes.name.length) DO        OthelloDefs.WriteChar[VAL[attributes.name.bytes[i]]];        ENDLOOP;      OthelloDefs.WriteString[version];      THROUGH [dir.length + attributes.name.length + version.length..80-time.length)       DO OthelloDefs.WriteChar[' ] ENDLOOP;      OthelloDefs.WriteLine[time];      --OthelloDefs.WriteChar[' ];      --OthelloDefs.WriteLine[info.author];      --OthelloDefs.WriteChar[' ];      --OthelloDefs.WriteLongNumber[info.size];      --OthelloDefs.WriteLine[" bytes]"L];      OthelloDefs.CheckUserAbort[];      RETURN};    dir ¬ z.NEW[StringBody[60]];    IF pattern[0] # '< AND String.Length[OthelloFetch.directory] # 0 THEN {      String.AppendStringAndGrow[@dir, OthelloFetch.directory, z];       IF dir[dir.length - 1] # '> THEN         String.AppendCharAndGrow[@dir, '>, z]};    String.AppendStringAndGrow[@dir, pattern, z];    ss.base ¬ dir;    FOR i: CARDINAL DECREASING IN [0..dir.length) DO      SELECT dir[i] FROM        '* => wildCardInFileName ¬ TRUE;        '> => {ss.length ¬ i + 1; EXIT};	ENDCASE;      ENDLOOP;    name ¬ z.NEW[StringBody[dir.length - ss.length]];    FOR i: CARDINAL IN [ss.length .. dir.length) DO      String.AppendChar[name, dir[i]];      ENDLOOP;    dir.length ¬ ss.length;    IF HasWildCard[dir] THEN {      z.FREE[@dir];       z.FREE[@name];      OthelloDefs.AbortingCommand["No wild cards in directories."L]};    fh ¬ GetFileFromSS[ss];    IF fh = NSFile.nullHandle THEN {      z.FREE[@name]; z.FREE[@dir]; RETURN};    scope.filter ¬ IF wildCardInFileName THEN       [matches[[name [S[name]]]]]    ELSE [equal[[name [S[name]]]]];    selections.interpreted[name] ¬ TRUE;    selections.interpreted[version] ¬ TRUE;    selections.interpreted[createdOn] ¬ TRUE;    selections.interpreted[pathname] ¬ TRUE; -- not yet implemented    NSFile.List[      directory: fh, proc: ListOne, selections: selections, scope: scope,       session: nsFileSession  	! NSFile.Error => NSError[error];	  Courier.Error => CourierError[errorCode];          UNWIND => {z.FREE[@name]; z.FREE[@dir]}];    z.FREE[@dir];    z.FREE[@name];    };  Retrieve: PROC [    fileName: LONG STRING, destination: OthelloFetch.Destination] = {    size: LONG CARDINAL;    name: LONG STRING ¬ NIL;    fH: NSFile.Handle ¬ NSFile.nullHandle;    Sink: PROC [source: NSDataStream.SourceStream] =      BEGIN ENABLE {	NSDataStream.Aborted => {Stream.Delete[source]; CONTINUE};	UNWIND => Stream.Delete[source]};      OthelloFetch.GrabBitsFromStream[source, size, destination, name !          OthelloFetch.StartFeedback => {            OthelloDefs.WriteString["Fetching..."L];            OthelloDefs.SetCursor[ftp];            RESUME};	  UNWIND => {	    OthelloDefs.SetCursor[pointer];	    NSDataStream.Abort[source ! NSDataStream.Aborted => CONTINUE]}];      Stream.Delete[source ! NSDataStream.Aborted => CONTINUE]      END;    [fH, size, name] ¬ GetFile[fileName];    NSFile.Retrieve[fH, [proc [Sink]], nsFileSession       ! UNWIND =>           {NSFile.Close[              fH, nsFileSession ! NSFile.Error, Courier.Error => CONTINUE];	   z.FREE[@name]}];    NSFile.Close[fH, nsFileSession       ! NSFile.Error, Courier.Error => CONTINUE;      UNWIND => z.FREE[@name]];    z.FREE[@name];    OthelloDefs.SetCursor[pointer]};      GetFile: PROC [fileName: LONG STRING] RETURNS [fh: NSFile.Handle, size: LONG CARDINAL, name: LONG STRING] =     BEGIN    time: LONG STRING ¬ [20];    attributes: NSFile.AttributesRecord;    ss: String.SubStringDescriptor ¬ [base: NIL, offset: 0, length: 0];    name ¬ z.NEW[StringBody[60]];    String.AppendChar[name, '[];    String.AppendStringAndGrow[@name, host, z];    String.AppendCharAndGrow[@name, '], z];    ss.offset ¬ name.length;    IF fileName[0] # '< AND ~String.Empty[OthelloFetch.directory] THEN {      String.AppendStringAndGrow[@name, OthelloFetch.directory, z];       IF name[name.length - 1] # '> THEN         String.AppendCharAndGrow[@name, '>, z]};    String.AppendStringAndGrow[@name, fileName, z];    ss.base ¬ name;    ss.length ¬ name.length - ss.offset;    fh ¬ GetFileFromSS[ss];    NSFile.GetAttributes[      fh, [[createdOn: TRUE, sizeInPages: TRUE]],      @attributes, nsFileSession      	! NSFile.Error => NSError[error];	  Courier.Error => CourierError[errorCode]];    String.AppendStringAndGrow[@name, " ("L, z];    Time.Append[time, Time.Unpack[attributes.createdOn]];    String.AppendStringAndGrow[@name, time, z];    String.AppendCharAndGrow[@name, '), z];    size ¬ attributes.sizeInPages;    END;   GetFileFromSS: PROCEDURE [ss: String.SubStringDescriptor] RETURNS [fh: NSFile.Handle ¬ NSFile.nullHandle] = {   ENABLE {NSFile.Error => NSError[error];	  Courier.Error => CourierError[errorCode]};    tempName: STRING = [NSFile.maxStringLength];    parent: NSFile.Handle ¬ NSFile.Open[attributes: NIL, session: nsFileSession];    DO      GetRoot[@ss, tempName];      fh ¬ NSFile.Find[        directory: parent,	scope: [	  direction: backward, filter: [equal[[name[S[tempName]]]]]],	controls: [timeout: 4], session: nsFileSession !           UNWIND => NSFile.Close[parent, nsFileSession !	    NSFile.Error, Courier.Error => CONTINUE]];      NSFile.Close[parent, nsFileSession];      IF ss.length = 0 THEN EXIT;      parent ¬ fh      ENDLOOP;    };      GetRoot: PROC [fileName: String.SubString, root: LONG STRING] = {    OPEN fileName;    StripChar: PROC = INLINE {offset ¬ offset + 1;  length ¬ length - 1};    N: CARDINAL ¬ offset + length;    quote: CHARACTER = '';    i: CARDINAL ¬ offset;    root.length ¬ 0;    WHILE i < N DO      SELECT base[i] FROM        quote =>  {	  i ¬ i+1; StripChar[]; IF i = N THEN EXIT;	  String.AppendChar[root, base[i]]};        '>, '/ =>  EXIT;        '< =>  root.length ¬ 0;        ENDCASE => String.AppendChar[root, base[i]];      i ¬ i+1;      StripChar[];      ENDLOOP;    IF fileName.length = 0 THEN RETURN;    StripChar[]};      S: PROCEDURE [s: LONG STRING] RETURNS [NSFile.String] = {    IF s = NIL THEN RETURN[[bytes: NIL, length: 0, maxlength: 0]];    RETURN[[bytes: LOOPHOLE[@s.text], length: s.length, maxlength: s.maxlength]]};      HasWildCard: PROC [s: LONG STRING] RETURNS [BOOLEAN] = {    IF s#NIL THEN FOR i: CARDINAL IN [0..s.length) DO       IF s[i] = '* THEN RETURN[TRUE] ENDLOOP;    RETURN[FALSE]};  NSError: PROC [error: NSFile.ErrorRecord] =    BEGIN    post: Format.StringProc = {OthelloDefs.WriteString[s]};    NSErrorMsg.PostNSFileError[error, post];    OthelloDefs.AbortingCommand[NIL];    END;  CourierError: PROC [error: Courier.ErrorCode] =    BEGIN    post: Format.StringProc = {OthelloDefs.WriteString[s]};    NSErrorMsg.PostCourierError[error, post];    OthelloDefs.AbortingCommand[NIL];    END;      StartCH: PROCEDURE = {    frame: PROGRAM ¬ Runtime.GlobalFrame[LOOPHOLE[CH.MakeRhs]];    START frame};  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- initialization  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  OthelloDefs.RegisterCommandProc[@commandProcessor];  OthelloFetch.Register[@fetcher];  StartCH[];  END.....  
-- Copyright (C) 1981, 1982, 1983, 1985, 1986, 1987  by Xerox Corporation. All rights reserved. -- OthelloDeviceImplD0DLion.Mesa-- Contains Othello commands and operations that are specific to disks--   connected to D0s/DLion/(everybody but Dorado)--	SCG       17-Jul-81 16:43:40--	LXD       10-Mar-82 16:17:10--	FXH        7-Jan-82 17:40:00--	RXJ        8-Nov-83  9:24:59--	CJS        6-Feb-85 17:53:15--	CAJ        3-Jul-86  9:45:36--	CAJ        8-Jul-87  8:29:31-- There is a separate version at least for dorados but not for daybreaks.DIRECTORY  Device USING [PilotDisk],  Environment USING [wordsPerPage],  FormatPilotDisk USING [    BadPage, CantInstallUCodeOnThisDevice, DiskInfo, Format,    InstallBootMicrocode, MicrocodeInstallFailure, noRetries, NotAPilotDisk,    RetryLimit, retryLimit, Scan],  OthelloDefs USING [    AbortingCommand, CheckUserAbort, CommandProcessor, Confirm,    FetchInitialMicrocode, GetDriveFromUser, GetDriveType, GetLvTypeFromUser,    GetName, IndexTooLarge, MyNameIs, NewLine, ReadNumber, ReadShortNumber,    RegisterCommandProc, Wizard, WriteChar, WriteFixedWidthNumber, WriteLine,    WriteLongNumber, WriteString, Yes],  OthelloOps USING [GetDriveSize],  PhysicalVolume USING [    AssertNotAPilotVolume, AssertPilotVolume, CreatePhysicalVolume, Error,    FinishWithNonPilotVolume, GetAttributes, GetNext, GetNextBadPage,    GetNextLogicalVolume, Handle, ID, MarkPageBad, maxNameLength,    maxSubvolumesOnPhysicalVolume, NeedsScavenging, nullBadPage, nullID,    Offline, PageNumber],  String USING [EquivalentStrings],  Volume USING [    Create, GetAttributes, ID, minPagesPerVolume, nullID, PageCount, Type];OthelloDeviceImplD0DLion: PROGRAM  IMPORTS    FormatPilotDisk, OthelloDefs, OthelloOps, PhysicalVolume, String, Volume =  BEGIN OPEN OthelloDefs, OthelloOps;  commandProcessor: CommandProcessor ¬ [DiskCommands];  DiskCommands: PROC [index: CARDINAL] = {    SELECT index FROM      0 => CheckDrive[];      1 => CreateVolume[];      2 => Format[];      3 => FetchInitialMicrocode[];      ENDCASE => IndexTooLarge};      badTableSize:		CARDINAL = 5 + CARDINAL[(physicalVolumeOverhead - 1)] *    (Environment.wordsPerPage / SIZE[PhysicalVolume.PageNumber]);    -- above should be same as PhysicalVolumeFormat.maxNumberBadPages + extra  logicalVolumeOverhead: CARDINAL = 1;    -- above should be same as LogicalVolumeFormat.rootPageSize  minLogicalVolumeSize:	CARDINAL = CARDINAL[Volume.minPagesPerVolume];  maxNameLength:	CARDINAL = PhysicalVolume.maxNameLength;  physicalVolumeOverhead: CARDINAL = 5;    -- above should be same as PhysicalVolumeFormat.rootPageSize  CheckDrive: PROC =    BEGIN    badSpots:         CARDINAL;    badSpotArray:     ARRAY [0..badTableSize) OF PhysicalVolume.PageNumber;    couldDo:          BOOLEAN;    h:                PhysicalVolume.Handle;    p:                PhysicalVolume.ID ¬ PhysicalVolume.nullID;    wasOnLine:        BOOLEAN ¬ FALSE;    badTableOverflow: BOOLEAN;    MyNameIs[      myNameIs: "Check Drive"L, myHelpIs: "Scan drive for unreadable pages"L];    [couldDo, badSpots, h] ¬ FormatCheckDrive[@badSpotArray, check];    IF ~couldDo THEN AbortingCommand["Command can't be done for this device."L]    ELSE IF badSpots = 0 THEN {WriteLine["No bad pages found."L]; RETURN}    ELSE IF ~Wizard[] OR ~Yes["\rShall I record these pages in the bad table? "L]      THEN RETURN;    -- See if was on line/put on line    DO      p ¬ PhysicalVolume.GetNext[p];      IF p = PhysicalVolume.nullID THEN {        p ¬ PhysicalVolume.AssertPilotVolume[h]; EXIT}      ELSE IF h = PhysicalVolume.GetAttributes[p].instance THEN {        wasOnLine ¬ TRUE; EXIT};      ENDLOOP;    badTableOverflow ¬ FillBadTable[@badSpotArray, badSpots, p];    IF ~wasOnLine THEN PhysicalVolume.Offline[p];    IF badTableOverflow THEN AbortingCommand["Too many bad spots."L]    ELSE WriteLine["Consider scavenging some volumes."L];    END;  Format: PROC =    BEGIN    badSpots:         CARDINAL;    badSpotArray:     ARRAY [0..badTableSize) OF PhysicalVolume.PageNumber;    couldDo:          BOOLEAN;    h:                PhysicalVolume.Handle;    p:                PhysicalVolume.ID;    badTableOverflow: BOOLEAN;    IF ~Wizard[] THEN RETURN;    MyNameIs[myNameIs: "Format"L, myHelpIs: "Format a disk drive"L];    [couldDo, badSpots, h] ¬ FormatCheckDrive[@badSpotArray, format];    IF ~couldDo THEN AbortingCommand["Command can't be done for this device."L];    FOR i: CARDINAL IN [0..MIN[badSpots, LENGTH[badSpotArray]]) DO      IF badSpotArray[i] = 0 THEN {WriteLine["Physical page zero bad"L]; RETURN}      ENDLOOP;    WriteLine["\rCreating Pilot volume named ""Empty"" to hold bad spot table"L];    p ¬ PhysicalVolume.CreatePhysicalVolume[h, "Empty"L];    badTableOverflow ¬ FillBadTable[@badSpotArray, badSpots, p];    PhysicalVolume.Offline[p];    IF badTableOverflow THEN AbortingCommand["Too many bad spots."L];    END;  lvTable: ARRAY [0..10) OF RECORD [    size: Volume.PageCount,    type: Volume.Type,    name: LONG STRING] ¬ ALL[[0, normal, NIL]];  newPvName:  LONG STRING ¬ NIL;  CreateVolume: PROC  =     BEGIN    h:              PhysicalVolume.Handle;    badTable:       ARRAY [0..badTableSize) OF PhysicalVolume.PageNumber;    bad:            CARDINAL ¬ 0;    broughtOnLine:  BOOLEAN ¬ FALSE;    driveSize:      LONG CARDINAL;    nSubVols:       CARDINAL;    lvID:           Volume.ID;    lvsize:         Volume.PageCount;    pvID:           PhysicalVolume.ID ¬ PhysicalVolume.nullID;    PagesRippedOff: PROC RETURNS [p: LONG CARDINAL] = INLINE {      --we don't really lose physicalVolumeOverhead      p ¬ MinPilotPage[h]; IF p # 0 THEN p ¬ p - physicalVolumeOverhead};    volumeFound:    BOOLEAN ¬ TRUE;    MyNameIs[      myNameIs: "Create Physical Volume"L,      myHelpIs: "Write new physical and logical volumes (old contents lost)"L];    h ¬ GetDriveFromUser[];    DO      pvID ¬ PhysicalVolume.GetNext[pvID];      IF pvID = PhysicalVolume.nullID THEN {        volumeFound ¬ Yes["Shall I try to find an old bad page Table? "L];        IF volumeFound THEN {          broughtOnLine ¬ TRUE;          pvID ¬ PhysicalVolume.AssertPilotVolume[h !            PhysicalVolume.Error, PhysicalVolume.NeedsScavenging => {              volumeFound ¬ broughtOnLine ¬ FALSE; CONTINUE}]};        EXIT};      IF h = PhysicalVolume.GetAttributes[pvID].instance THEN EXIT;      ENDLOOP;    IF volumeFound THEN {      OPEN PhysicalVolume;      badTable[bad] ¬ GetNextBadPage[pvID, nullBadPage];      WHILE badTable[bad] # nullBadPage DO        badTable[bad + 1] ¬ GetNextBadPage[pvID, badTable[bad]]; bad ¬ bad + 1        ENDLOOP;      volumeFound ¬ PhysicalVolume.GetNextLogicalVolume[pvID, Volume.nullID]                    # Volume.nullID};    GetName["New physical volume name: "L, @newPvName];    nSubVols ¬ ReadShortNumber[      "Number of logical volumes: "L, 1,      PhysicalVolume.maxSubvolumesOnPhysicalVolume, 3];    driveSize ¬ GetDriveSize[h] -      (physicalVolumeOverhead + nSubVols*logicalVolumeOverhead       + PagesRippedOff[]);    driveSize ¬ driveSize - ReserveLastCylinderForDiag[h];    FOR i: CARDINAL IN [0..nSubVols) DO      OPEN lvTable[i];      WriteString["Logical volume "L];      WriteLongNumber[LONG[i]];      NewLine[];      DO        duplicate: BOOLEAN ¬ FALSE;        GetName["  Name: "L, @lvTable[i].name];        FOR j: CARDINAL IN [0..i) WHILE ~duplicate DO          duplicate ¬ String.EquivalentStrings[	    lvTable[i].name, lvTable[j].name] ENDLOOP;        IF ~duplicate THEN EXIT;        WriteLine["Name is already in use; please choose another"L];        ENDLOOP;      size ¬ ReadNumber[        "  Pages: "L, minLogicalVolumeSize,        driveSize - ((nSubVols - (i + 1))*minLogicalVolumeSize),        driveSize/(nSubVols - i)];      driveSize ¬ driveSize - size;      type ¬ GetLvTypeFromUser["  Type: "L, type];      ENDLOOP;    IF broughtOnLine THEN PhysicalVolume.Offline[pvID];    Confirm[IF volumeFound THEN twice ELSE once];    PhysicalVolume.Offline[pvID ! ANY => CONTINUE];    pvID ¬ PhysicalVolume.CreatePhysicalVolume[h, newPvName];    FOR i: CARDINAL IN [0..bad) DO      PhysicalVolume.MarkPageBad[pvID, badTable[i]] ENDLOOP;    FOR i: CARDINAL IN [0..nSubVols) DO      OPEN lvTable[i];      lvID ¬ Volume.Create[pvID, size, name, type, MinPilotPage[h]];      IF (lvsize ¬ Volume.GetAttributes[lvID].volumeSize) # size THEN {        WriteString[name];        WriteString["'s size decreased (because of bad pages) to "L];        WriteLongNumber[lvsize];        NewLine[]};      ENDLOOP;    END;  FetchInitialMicrocode: PROC = {    h: PhysicalVolume.Handle;    InstallProc: PROC [getPage: PROC RETURNS [LONG POINTER]] = {      PhysicalVolume.AssertNotAPilotVolume[h];      {ENABLE UNWIND => PhysicalVolume.FinishWithNonPilotVolume[h];      FormatPilotDisk.InstallBootMicrocode[h, getPage]}; -- ENABLE      PhysicalVolume.FinishWithNonPilotVolume[h]};    MyNameIs[      myNameIs: "Initial Microcode Fetch"L,      myHelpIs: "Fetch and install initial microcode"L];    h ¬ GetDriveFromUser[];    SELECT TRUE FROM      LOOPHOLE[GetDriveType[h], CARDINAL] IN Device.PilotDisk =>        BEGIN	wasOnline: BOOLEAN = ForceOffline[h];        OthelloDefs.FetchInitialMicrocode[InstallProc        ! FormatPilotDisk.MicrocodeInstallFailure =>            SELECT m FROM              emptyFile       =>	        AbortingCommand["That remote file is empty!"L];              firstPageBad    =>	        AbortingCommand["First microcode page of this disk is bad."L];              makeBootableFailed => {	        WriteLine["MakeBootable failed."L]; RESUME};              microcodeTooBig =>	        AbortingCommand["Microcode too large."L];              ENDCASE         =>	        AbortingCommand["Unknown Install microcode error."L];          FormatPilotDisk.CantInstallUCodeOnThisDevice => GOTO no];	IF wasOnline THEN [] ¬ PhysicalVolume.AssertPilotVolume[h];        WriteLine["Done"L]        END;      ENDCASE => GOTO no;    EXITS    no => AbortingCommand["microcode can't be installed on this disk"L]};  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- support Procs  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- this code depends upon Pilot's bad spot table being smaller than ours,   -- and an error being raised when Pilot's table is full.  FillBadTable: PROC [    badSpotArray: POINTER TO ARRAY [0..badTableSize) OF PhysicalVolume.PageNumber,    badSpots: CARDINAL, p: PhysicalVolume.ID]    RETURNS [badSpotTableFull: BOOLEAN ¬ FALSE] = {    FOR i: CARDINAL IN [0..badSpots) DO      PhysicalVolume.MarkPageBad[p, badSpotArray[i]      ! PhysicalVolume.Error =>        IF error = badSpotTableFull THEN {badSpotTableFull ¬ TRUE; EXIT}]      ENDLOOP};      ForceOffline: PROC [h: PhysicalVolume.Handle]    RETURNS [wasOnline: BOOLEAN ¬ FALSE] = {    p: PhysicalVolume.ID ¬ PhysicalVolume.nullID;    DO      p ¬ PhysicalVolume.GetNext[p];      IF p = PhysicalVolume.nullID THEN EXIT;      IF h = PhysicalVolume.GetAttributes[p].instance THEN {	wasOnline ¬ TRUE; PhysicalVolume.Offline[p]; EXIT};      ENDLOOP};      FormatCheckDrive: PUBLIC PROC [    bs: POINTER TO ARRAY [0..badTableSize) OF PhysicalVolume.PageNumber,    op: {format, check}]    RETURNS [couldDo: BOOLEAN, badSpots: CARDINAL, h: PhysicalVolume.Handle] = {    -- leaves pv offline for op = format; restores previous state for op = check    cbs: ARRAY [0..badTableSize) OF CARDINAL ¬ ALL[0];    tooManyMsg: BOOLEAN ¬ FALSE;    passes:     CARDINAL ¬ 1;    NoteBad: PROC [p: PhysicalVolume.PageNumber] = {      FOR i: CARDINAL IN [0..badSpots) DO        IF bs[i] = p THEN {cbs[i] ¬ cbs[i] + 1; WriteBadSpot[p, cbs[i]]; RETURN}	ENDLOOP;      IF badSpots < LENGTH[bs­] THEN {        bs[badSpots] ¬ p; cbs[badSpots] ¬ cbs[badSpots] + 1;	badSpots ¬ badSpots + 1; WriteBadSpot[p, 1]}      ELSE {        IF ~tooManyMsg THEN {	  WriteLine["Too many bad pages"L]; tooManyMsg ¬ TRUE; column ¬ 0};	WriteBadSpot[p, 1]};      CheckUserAbort[! UNWIND => FormatSummary[]]};    FormatSummary: PROC = {      IF badSpots > 0 THEN {        column ¬ 0;        WriteLine["\rSummary of bad pages: badPage(countTimesBad)"L];        FOR i: CARDINAL IN [0..badSpots) DO	  WriteBadSpot[bs[i], cbs[i]] ENDLOOP;        NewLine[]}};    column: CARDINAL ¬ 0;    WriteBadSpot: PROC [p: PhysicalVolume.PageNumber, cnt: CARDINAL] = {      WriteFixedWidthNumber[p, 8]; WriteChar['(];      WriteFixedWidthNumber[	cnt, SELECT passes FROM IN [0..9] => 1, IN [10..99] => 2, ENDCASE => 3];      WriteChar[')];      IF (column MOD 5) = 4 THEN {column ¬ 0; NewLine[]}       ELSE column ¬ column+1};    badSpots ¬ 0;    h ¬ GetDriveFromUser[];    SELECT TRUE FROM      -- dam compiler won't coerce [CARDINAL] into CARDINAL      LOOPHOLE[GetDriveType[h], CARDINAL] IN Device.PilotDisk => {        OPEN FPD: FormatPilotDisk;        pilotStart: PhysicalVolume.PageNumber = MinPilotPage[h];        retries:    FormatPilotDisk.RetryLimit ¬ 0;	              -- number of retries on bad page        cylSize:    CARDINAL = CylinderSize[h];	IF op = format THEN {          passes  ¬ ReadShortNumber["Number of passes: "L, 1, 200, 10];          retries ¬ ReadShortNumber[            "Number of retries: "L, FPD.noRetries, FPD.retryLimit, FPD.noRetries];          Confirm[twice];	  [] ¬ ForceOffline[h];	  PhysicalVolume.AssertNotAPilotVolume[h];	  {ENABLE UNWIND => PhysicalVolume.FinishWithNonPilotVolume[h];	  FPD.Format[h, 0, GetDriveSize[h], passes, retries, FALSE, FALSE          ! FPD.BadPage => {NoteBad[p]; RESUME}]}; -- ENABLE	  PhysicalVolume.FinishWithNonPilotVolume[h]}        ELSE {  -- op=scan          wasOnline: BOOLEAN;          Confirm[once];          wasOnline ¬ ForceOffline[h];          -- scan zero'th cylinder seperatly	  FPD.Scan[h, 0, cylSize	  ! FPD.BadPage => {NoteBad[p]; RESUME}];          -- scan rest of disk possibly allowing for alto-type volume	  -- or other device dependent dreck	  FPD.Scan[h, pilotStart, GetDriveSize[h] - pilotStart          ! FPD.BadPage => {NoteBad[p]; RESUME}];	  IF wasOnline THEN [] ¬ PhysicalVolume.AssertPilotVolume[h]};        FormatSummary[];        RETURN[couldDo: TRUE, badSpots: badSpots, h: h]};      ENDCASE => RETURN[couldDo: FALSE, badSpots: badSpots, h: h]};  MinPilotPage: PROC [h: PhysicalVolume.Handle]    RETURNS [PhysicalVolume.PageNumber] = {    RETURN[FormatPilotDisk.DiskInfo[h].firstPilotPage]};  CylinderSize: PROC [h: PhysicalVolume.Handle] RETURNS [cylSize: CARDINAL] = {    RETURN[FormatPilotDisk.DiskInfo[h].pagesPerCylinder]};  ReserveLastCylinderForDiag: PROC [h: PhysicalVolume.Handle]    RETURNS [ripOff: CARDINAL] = {    ripOff ¬ CylinderSize[h !       FormatPilotDisk.NotAPilotDisk => GOTO out];    IF Wizard[] AND ~Yes["Reserve last cylinder for diagnostics? "L]      THEN ripOff ¬ 0;    EXITS out => RETURN[0]};    RegisterCommandProc[@commandProcessor];  END.....11-Jun-81 10:56:57  EXT      Created file using excerpts from VolumeInitImplA.mesa17-Jun-81 16:39:45  SCG      Action: Prompt for passes and retries for formatting disk, summary after all passes done17-Jul-81 16:44:52 SCG       Action: Change name of file and print more summary information, OthelloDevice merged into OthelloDefs11-Jun-81 10:56:57  Taft  Created file using excerpts from VolumeInitImplA.mesa26-Aug-81 18:34:22  FXH      8.0c build14-Oct-81 20:17:53  FXH      othello reorg/add trident stuff/add diag cylinder stuff13-Nov-81 16:24:41  FXH      8.0e build23-Nov-81 19:10:16  FXH      add stuff for t80, t30010-Dec-81 16:15:15  FXH      add Quantum support; fix a couple of awful bugs in install ucode 7-Jan-82 17:39:36  FXH      Change for new FormatPilotDisk.CantInstallUCodeOnThisDevice10-Mar-82 16:17:20  LXD      Formating ==> formatting 3-Jul-86  9:24:56  CAJ      Update badTableSize, minLogicalVolumeSize, physicalVolumeOverhead; add comments pointing to Pilot private interface actual values; add USING details. 8-Jul-87  8:28:52  CAJ      Format no longer explicitly formats 0th cylinder separately, and FetchInitialMicrocode no longer formats, because we now have wholeDisk disks.
-- File: HeraldWindowsB.mesa - last edit:-- Riggle.PA            8-Aug-86 16:07:51-- Copyright (C) 1981, 1982, 1983, 1984 , 1986, 1986 by Xerox Corporation. All rights reserved. -- HeraldWindowsB.mesa - last edit by-- BXM  	22-Feb-82 16:30:15-- PXK    	13-Nov-81 12:27:19-- RXR   	 4-Oct-82  9:42:53-- Lui		27-Oct-81 11:42:44-- LXR    	13-Jan-84 16:08:04-- SEH		23-Mar-82 10:28:51-- RXJ     	24-Sep-82 20:28:21-- CXH   	20-Jul-83 17:37:49-- RSF        	 1-Sep-83 15:37:47-- DWR        	16-May-85 14:50:48DIRECTORY  Ascii USING [CR],  Atom USING [ATOM, MakeAtom],  CmFile USING [    Close, Error, FindSection, Handle, NextValue, TableError, UserDotCmOpen],  Cursor USING [Object, Defined, Handle, FetchFromType, Set],  Display USING [Bitmap, Handle, Invert, paintFlags, replaceFlags, Text, White],  Event USING [aboutToSwap, primaryCredentials, swapping],  EventTypes USING [    abortSession, aboutToAbortSession, aboutToBoot, bootPhysicalVolume, newSession,    primaryCredentials, resumeDebuggee, resumeSession, swapCancelled],  Format USING [StringProc],  Heap USING [systemZone],  HeraldWindow USING [    AppendLogicalVolumeName, BootFromFile, BootFromVolumeName, ConfirmProcType,    CursorState, InvalidSwitches, ScanSwitches, SetSwitches, window],  HeraldWindowOps USING [    BootButton, EmptySelection, menuStrings, nVols, SetUpMenuandVolStrings, z],  Inline USING [BITNOT, LowHalf],  Menu USING [Free, Handle, Instantiate, Make, MCRType, Uninstantiate],  MsgSW USING [AppendString, Clear, Create],  Process USING [    Abort, Detach, EnableAborts, MsecToTicks, Priority, priorityForeground,    priorityNormal, SecondsToTicks, SetPriority, SetTimeout],  Profile USING [GetUser, place, Place],  Put USING [Line, LongString],  Runtime USING [GetBuildTime],  Scrollbar USING [Adjust],  Selection USING [Convert],  String USING [    AppendChar, AppendLongNumber, AppendNumber, AppendString, CopyToNewString,    EmptyString, Length, Replace],  StringLookUp USING [noMatch, TableDesc, InTable],  Supervisor USING [    AddDependency, AgentProcedure, CreateSubsystem, EnumerationAborted,    NotifyDirectSubsystems, RemoveDependency, SubsystemHandle],  System USING [defaultSwitches, GreenwichMeanTime, switches],  TajoOps USING [],  TextSW USING [Adjust],  Time USING [Current, Unpack, Unpacked],  TIP USING [First, NotifyProc, Rest, Results, SetNotifyProc],  Token USING [FreeTokenString, Item, WindowBox],  ToolFont USING [StringWidth],  ToolWindow USING [    AdjustProcType, Box, Create, CreateSubwindow, GetTinyName, Handle, SetTinyName,    SetTinyPlace, Show, State, TransitionProcType],  UserInput USING [    CreateIndirectStringOut, GetDefaultWindow, SetStringOut, StringProcType,    WaitForConfirmation, WaitNoButtons],  UserTerminal USING [CursorArray],  Volume USING [    GetAttributes, GetLabelString, GetNext, ID, maxNameLength, NeedsScavenging,    nullID, PageCount, systemID],  Window USING [    Box, GetBox, Handle, InvalidateBox, Object, Place, rootWindow, SlideAndSize],  WindowFont USING [defaultFont, FontHeight, Handle];HeraldWindowsB: MONITOR  IMPORTS    Atom, CmFile, Cursor, Display, Event, Heap, HeraldWindow, HeraldWindowOps,    Inline, Menu, MsgSW, Process, Profile, Put, Runtime, Scrollbar, Selection,    String, StringLookUp, Supervisor, System, TextSW, Time, TIP, Token, ToolFont,    ToolWindow, UserInput, Volume, Window, WindowFont  EXPORTS HeraldWindow, HeraldWindowOps, TajoOps =  BEGIN  pointUp, adjustUp, enter, exit: Atom.ATOM;  maxCursors: CARDINAL = 5;  cursorGap: CARDINAL = 4;  cursorWidth: CARDINAL = 16;  indent: CARDINAL = 32;  cursorFudge: CARDINAL = 6;  line1Fudge: CARDINAL = 1;  line2Fudge: CARDINAL = 2;  Slot: TYPE = LONG POINTER TO SlotObject;  SlotObject: PUBLIC TYPE = RECORD [    negative: BOOLEAN ¬ FALSE,    position: NAT,    link: Slot,    cursorArray: UserTerminal.CursorArray ¬ NULL];  OffOn: TYPE = {off, on};  HeraldObject: TYPE = RECORD [    msgSw: Window.Handle,    sw: Window.Handle,    pagesX: CARDINAL,    timeX: CARDINAL,    menu: Menu.Handle,    displayedTime: System.GreenwichMeanTime ¬ NULL,    displayedUnp: Time.Unpacked ¬ NULL,    x: RECORD [day, month, hour, minute, second, end: CARDINAL] ¬ NULL,    msgCnt: CARDINAL ¬ 2,    msgTime: CARDINAL ¬ 0,    currentVolume: Volume.ID ¬ Volume.systemID,    currentPriority: Process.Priority ¬ Process.priorityNormal];  displayedPages: PUBLIC LONG CARDINAL;  newPriority: Process.Priority ¬ Process.priorityNormal;  newVolume: Volume.ID ¬ Volume.systemID;  fileEntry: CARDINAL = 0;  bootButtonEntry: CARDINAL = 1;  setSwitchesEntry: CARDINAL = 2;  resetSwitchesEntry: CARDINAL = 3;  upPriorityEntry: CARDINAL = 4;  resetPriorityEntry: CARDINAL = 5;  specialEntries: PUBLIC CARDINAL ¬ 6;  -- Number of extra entries in menu (e.g., for files, etc.)    AuthOutcome: TYPE = MACHINE DEPENDENT {invalidName(0), invalidPassword(1), authServiceUnavailable(2), authProblem(3), spare(4), (LAST[CARDINAL])}; -- This must be defined in AtomicProfile in Mesa 13.0.  A code of this type is passed on to the HeraldWindow who posts appropriate errors when authentication fails.  okay: AuthOutcome = LAST[AuthOutcome];  agent: Supervisor.SubsystemHandle = Supervisor.CreateSubsystem[Notify];  data: LONG POINTER TO HeraldObject ¬ NIL;  cv: CONDITION;  options: RECORD [    timeOK: BOOLEAN, stopPainting: BOOLEAN ¬ FALSE, painterState: OffOn ¬ off];  slotHead: Slot ¬ NIL;  versionMsg: LONG STRING;  user: LONG STRING ¬ NIL;--  loggedIn: BOOLEAN ¬ FALSE;  loginState: AuthOutcome ¬ invalidPassword;  defaultTinyName1: LONG STRING ¬ NIL;  defaultTinyName2: LONG STRING ¬ NIL;  isTiny, ticking: BOOLEAN ¬ FALSE;  realTIP: TIP.NotifyProc ¬ NIL;  activeStick, suspendPainter: BOOLEAN ¬ FALSE;  aSecond, stoppedTicking: CONDITION;  mouseClicks: CARDINAL ¬ 0;  stick: BOOLEAN ¬ FALSE;  -- if TRUE, keep Tick process active  pSec: LONG POINTER TO CONDITION = @aSecond;  ticker: PROCESS;  s1: LONG STRING ¬ [Volume.maxNameLength];  s2: LONG STRING ¬ [9];  window: PUBLIC Window.Handle ¬ NIL;  realStringProc: UserInput.StringProcType;  NoteIndirectTypeOut: UserInput.StringProcType = {    IF data = NIL THEN RETURN;    FOR i: CARDINAL IN [0..String.Length[string]) DO      IF string[i] = Ascii.CR THEN data.msgCnt ¬ data.msgCnt + 1; ENDLOOP;    realStringProc[window, string]};  AppendBrokenMessage: PUBLIC ENTRY PROCEDURE [    msg1, msg2, msg3: LONG STRING ¬ NIL, newLine, clearOld: BOOLEAN ¬ TRUE] = {    ENABLE UNWIND => NULL;    IF ~SetupMessage[newLine, clearOld] THEN RETURN;    MsgSW.AppendString[data.msgSw, msg1];    MsgSW.AppendString[data.msgSw, msg2];    MsgSW.AppendString[data.msgSw, msg3]};  AppendMessage: PUBLIC ENTRY PROCEDURE [    msg: LONG STRING ¬ NIL, newLine, clearOld: BOOLEAN ¬ TRUE] = {    ENABLE UNWIND => NULL;    IF SetupMessage[newLine, clearOld] THEN MsgSW.AppendString[data.msgSw, msg]};  AppendVersion: PROC = {    IF data = NIL THEN RETURN;    data.msgCnt ¬ 0;    data.msgTime ¬ 0;    MsgSW.AppendString[data.msgSw, versionMsg];    MsgSW.AppendString[data.msgSw, "\n     User: {"L];    MsgSW.AppendString[data.msgSw, user];    MsgSW.AppendString[data.msgSw, "}"L];    MsgSW.AppendString[data.msgSw,       SELECT loginState FROM	invalidName => " ! Invalid Name"L,	invalidPassword => " ! Invalid Password"L,	authServiceUnavailable => " ! Authentication Service Unavailable"L,	authProblem => " ! Authentication Problem"L,	spare => " ! ???"L,      ENDCASE => ""L];  };  GetUser: PROC [name, password: LONG STRING] = {  -- race danger here... oh?  why?    String.Replace[to: @user, from: name, z: Heap.systemZone];  };  SetupMessage: PROC [newLine, clearOld: BOOLEAN] RETURNS [ok: BOOLEAN] = {    SELECT TRUE FROM      data = NIL => RETURN[FALSE];      clearOld => {data.msgCnt ¬ 2; MsgSW.Clear[data.msgSw]};      newLine => {        data.msgCnt ¬ data.msgCnt + 1; MsgSW.AppendString[data.msgSw, "      "L]};      ENDCASE;    RETURN[TRUE]};  FreeCursorSlot: PUBLIC ENTRY PROC [slot: Slot] RETURNS [nil: Slot] = {    ENABLE UNWIND => NULL;    next, prev: Slot;    nil ¬ prev ¬ NIL;    IF data = NIL OR slot = NIL THEN RETURN;    FOR p: Slot ¬ slotHead, next UNTIL p = NIL DO      next ¬ p.link;      IF p = slot THEN {        IF prev = NIL THEN slotHead ¬ next ELSE prev.link ¬ next;        slot.cursorArray ¬ ALL[0];        PaintCursor[slot];        Heap.systemZone.FREE[@slot];        RETURN};      prev ¬ p;      ENDLOOP};  GetCursorSlot: PUBLIC ENTRY PROCEDURE RETURNS [slot: Slot] = {    ENABLE UNWIND => NULL;    SlotMap: TYPE = PACKED ARRAY [0..maxCursors) OF BOOLEAN;    map: SlotMap ¬ ALL[FALSE];    slot ¬ NIL;    IF data = NIL THEN RETURN;    FOR slot: Slot ¬ slotHead, slot.link UNTIL slot = NIL DO      map[slot.position] ¬ TRUE ENDLOOP;    FOR i: NAT IN [0..maxCursors) DO      IF map[i] THEN LOOP;      slot ¬ Heap.systemZone.NEW[SlotObject ¬ [position: i, link: slotHead]];      slotHead ¬ slot;      EXIT;      ENDLOOP};  SetCursor: PUBLIC ENTRY PROC [slot: Slot, cursor: Cursor.Defined] = {    ENABLE UNWIND => NULL;    object: Cursor.Object;    IF slot = NIL THEN RETURN;    Cursor.FetchFromType[cursor: @object, type: cursor];    slot.cursorArray ¬ object.array;    PaintCursor[slot]};  StoreCursor: PUBLIC ENTRY PROC [    slot: Slot, cursor: LONG POINTER TO UserTerminal.CursorArray] = {    ENABLE UNWIND => NULL;    IF slot = NIL THEN RETURN;    slot.cursorArray ¬ cursor­;    PaintCursor[slot]};  SetCursorState: PUBLIC ENTRY PROC [slot: Slot, state: HeraldWindow.CursorState] =    {    ENABLE UNWIND => NULL;    IF slot = NIL THEN RETURN;    SELECT state FROM      invert => InvertCursor[slot];      positive => IF slot.negative THEN InvertCursor[slot];      negative => IF ~slot.negative THEN InvertCursor[slot];      ENDCASE};  InvertCursor: INTERNAL PROCEDURE [slot: Slot] = {    FOR i: CARDINAL IN [0..16) DO      slot.cursorArray[i] ¬ Inline.BITNOT[slot.cursorArray[i]]; ENDLOOP;    slot.negative ¬ ~slot.negative;    PaintCursor[slot]};  SetSystemName: PUBLIC ENTRY PROC [name: LONG STRING] RETURNS [CARDINAL] = {    ENABLE UNWIND => NULL;    herald: STRING ¬ [50];    bcdTime: Time.Unpacked = Time.Unpack[Runtime.GetBuildTime[]];    build: LONG CARDINAL = Runtime.GetBuildTime[];    now: LONG CARDINAL = Time.Current[];    FiveYears: LONG CARDINAL = LONG[3600] * 24 * 365 * 5;    options ¬ [timeOK: now IN (build..build + FiveYears]];    String.AppendString[herald, "\n     "L];    String.AppendString[herald, name];    String.AppendString[herald, " of "L];    AppendMonth[herald, bcdTime.month];    String.AppendChar[herald, ' ];    String.AppendNumber[herald, bcdTime.day, 10];    String.AppendString[herald, ", "L];    String.AppendNumber[herald, bcdTime.year, 10];    versionMsg ¬ Heap.systemZone.NEW[StringBody [herald.length]];    String.AppendString[versionMsg, herald];    RETURN[WindowHeight[]]};  Adjust: PUBLIC ToolWindow.AdjustProcType = {    scrollbar: Window.Handle ¬ NIL;    leftBox, scrollbarBox: Window.Box;    screenWidth: CARDINAL = box.dims.w;    h: CARDINAL = box.dims.h;    preferredW: CARDINAL = SwWidth[];    w: CARDINAL =      IF screenWidth > preferredW THEN screenWidth - preferredW      ELSE screenWidth / 2;    [leftBox, scrollbar, scrollbarBox, , ] ¬ Scrollbar.Adjust[      data.msgSw, [place: [0, 0], dims: [w: w, h: h]]];    TextSW.Adjust[data.msgSw, leftBox, when];    Window.SlideAndSize[      window: data.sw,      newBox: [place: [x: w, y: 0], dims: [w: screenWidth - w, h: h]],      gravity: ne];    Window.InvalidateBox[      window: data.sw,      box: [place: [x: w, y: 0], dims: [w: screenWidth - w, h: h]]];    data.msgSw.SlideAndSize[newBox: leftBox, gravity: nw];    scrollbar.SlideAndSize[newBox: scrollbarBox, gravity: nw]};  HeraldSWTIP: TIP.NotifyProc = {    AdvanceVolume: ENTRY PROCEDURE = INLINE {      newVolume ¬ data.currentVolume;      DO        newVolume ¬ Volume.GetNext[newVolume, [TRUE, TRUE, TRUE, TRUE]];        IF newVolume = Volume.nullID THEN LOOP ELSE EXIT;        ENDLOOP;      BROADCAST cv};    ResetVolume: ENTRY PROCEDURE = INLINE {      IF activeStick THEN RETURN; newVolume ¬ Volume.systemID; BROADCAST cv};    ToggleActiveStick: ENTRY PROCEDURE = INLINE {activeStick ¬ NOT activeStick};    realTIP[window, results];    FOR input: TIP.Results ¬ results, input.Rest[] UNTIL input = NIL DO      WITH z: input.First[] SELECT FROM        coords => IF NotInVolumeBox[z.place] THEN RETURN;        atom =>          SELECT z.a FROM            exit => ResetVolume[];            pointUp => AdvanceVolume[];            adjustUp => ToggleActiveStick[];            ENDCASE;        ENDCASE;      ENDLOOP;    };  HeraldTIP: TIP.NotifyProc = {    goodPlace: BOOLEAN ¬ TRUE;    wasTiny: BOOLEAN = isTiny;    ToggleStick: ENTRY PROCEDURE = INLINE {stick ¬ NOT stick};    IncrMouse: ENTRY PROCEDURE = INLINE {      mouseClicks ¬ mouseClicks + 1; NOTIFY aSecond};    realTIP[window, results];    IF ~wasTiny OR ~isTiny THEN RETURN;    FOR input: TIP.Results ¬ results, input.Rest[] UNTIL input = NIL DO      WITH z: input.First[] SELECT FROM        coords => IF InAcceleratorStripe[z.place] THEN goodPlace ¬ FALSE;        atom =>          SELECT z.a FROM            enter => TickOn[];            exit => TickOff[];            pointUp => IF goodPlace THEN IncrMouse[];            adjustUp => IF goodPlace THEN ToggleStick[];            ENDCASE;        ENDCASE;      ENDLOOP};  TickOff: ENTRY PROCEDURE = INLINE {TickOffInternal[]};  TickOffInternal: INTERNAL PROCEDURE = INLINE {    IF stick THEN RETURN;    IF ticking THEN Process.Abort[ticker] ELSE BROADCAST stoppedTicking};  TickOn: ENTRY PROCEDURE = {    IF ~stick THEN {      WHILE ticking DO WAIT stoppedTicking ENDLOOP;      Heap.systemZone.FREE[@defaultTinyName1];      Heap.systemZone.FREE[@defaultTinyName2];      [defaultTinyName1, defaultTinyName2] ¬ ToolWindow.GetTinyName[window];      mouseClicks ¬ 0;      ticking ¬ TRUE;      ticker ¬ FORK Tick[];      Process.Detach[ticker]}};  InAcceleratorStripe: PROCEDURE [place: Window.Place] RETURNS [BOOLEAN] = INLINE {    RETURN[place.y < WindowFont.FontHeight[] - 2]};  NotInVolumeBox: PROCEDURE [place: Window.Place] RETURNS [BOOLEAN] = {    font: WindowFont.Handle = WindowFont.defaultFont;    fontHeight: CARDINAL = WindowFont.FontHeight[font];    RETURN[      place.x < INTEGER[data.timeX]        OR place.y < INTEGER[fontHeight + line2Fudge]]};  GetFree: INTERNAL PROCEDURE [v: Volume.ID, s: LONG STRING] = {    String.AppendLongNumber[s, Volume.GetAttributes[v].freePageCount]};  Tick: ENTRY PROCEDURE =    BEGIN    time: Time.Unpacked;    lastMouseClicks: CARDINAL ¬ 0;    currentVolume: Volume.ID ¬ Volume.nullID;    AppendUnit: PROC [s: LONG STRING, n: CARDINAL] = {      String.AppendChar[s, '0 + n / 10]; String.AppendChar[s, '0 + n MOD 10]};    Process.SetPriority[Process.priorityNormal];    DO      ENABLE ABORTED => EXIT;      IF mouseClicks # lastMouseClicks THEN        BEGIN        lastMouseClicks ¬ mouseClicks;        currentVolume ¬ Volume.GetNext[currentVolume, [TRUE, TRUE, TRUE, TRUE]];        END;      IF currentVolume = Volume.nullID THEN        BEGIN        Process.SetTimeout[condition: pSec, ticks: Process.SecondsToTicks[1]];        s1.length ¬ s2.length ¬ 0;        time ¬ Time.Unpack[Time.Current[]];        AppendUnit[s1, time.hour];        String.AppendChar[s1, ':];        AppendUnit[s1, time.minute];        String.AppendChar[s1, ':];        AppendUnit[s1, time.second];        AppendUnit[s2, time.month + 1];        String.AppendChar[s2, '/];        AppendUnit[s2, time.day];        String.AppendChar[s2, '/];        AppendUnit[s2, time.year - 1900];        ToolWindow.SetTinyName[window, s2, s1];        END      ELSE        BEGIN        Process.SetTimeout[condition: pSec, ticks: Process.SecondsToTicks[10]];        s2.length ¬ s1.length ¬ 0;        Volume.GetLabelString[          currentVolume, s1 !          Volume.NeedsScavenging => {String.AppendChar[s1, '?]; CONTINUE}];        GetFree[          currentVolume, s2 !          Volume.NeedsScavenging => {            String.AppendString[to: s2, from: "scavenge!"L]; CONTINUE}];        ToolWindow.SetTinyName[window, s1, s2];        END;      WAIT aSecond;      ENDLOOP;    ToolWindow.SetTinyName[window, defaultTinyName1, defaultTinyName2];    ticking ¬ FALSE;    BROADCAST stoppedTicking;    END;  Transition: PUBLIC ENTRY ToolWindow.TransitionProcType =    BEGIN    ENABLE UNWIND => NULL;    isTiny ¬ new = tiny;    SELECT old FROM      inactive => {        screenWidth: CARDINAL = Window.GetBox[Window.rootWindow].dims.w;        swX: CARDINAL = screenWidth - SwWidth[];        h: CARDINAL = WindowHeight[];        data ¬ Heap.systemZone.NEW[          HeraldObject ¬ [          msgSw: ToolWindow.CreateSubwindow[          parent: HeraldWindow.window,          box: [place: [x: 0, y: 0], dims: [w: swX, h: h]]],          sw: ToolWindow.CreateSubwindow[          parent: HeraldWindow.window, display: Paint,          box: [place: [x: swX, y: 0], dims: [w: screenWidth - swX, h: h]]],          timeX: screenWidth, pagesX: screenWidth, menu: MakeMenu[]]];        MsgSW.Create[          sw: data.msgSw, lines: 4,          options: [          access: append, menu: FALSE, split: FALSE, wrap: TRUE, scrollbar: TRUE,          flushTop: TRUE, flushBottom: TRUE]];        realStringProc ¬ UserInput.SetStringOut[          window: data.msgSw, proc: NoteIndirectTypeOut];        UserInput.CreateIndirectStringOut[          from: UserInput.GetDefaultWindow[], to: data.msgSw];        Menu.Instantiate[data.menu, HeraldWindow.window];        Supervisor.AddDependency[client: agent, implementor: Event.swapping];        };      active => SetPainter[off];      tiny => {stick ¬ FALSE; TickOffInternal[]; WAIT stoppedTicking};      ENDCASE;    SELECT new FROM      active => {[] ¬ TIP.SetNotifyProc[data.sw, HeraldSWTIP]; SetPainter[on]};      inactive => {        activeStick ¬ FALSE;        Supervisor.RemoveDependency[client: agent, implementor: Event.swapping];        FreeMenu[data.menu];        Heap.systemZone.FREE[@data]};      ENDCASE;    END;  SetupVolumeName: PROC RETURNS [width: CARDINAL] = {    font: WindowFont.Handle = WindowFont.defaultFont;    prefixLength: CARDINAL = ("Volume: "L).length;    s: STRING = [50];  --[Volume.maxNameLength + prefixLength + 1];      volumeID: Volume.ID ¬ Volume.nullID;    String.AppendString[s, "Volume: "L];    UNTIL (volumeID ¬ Volume.GetNext[volumeID, ALL[TRUE]]) = Volume.nullID DO      volumeLabel: STRING ¬ [Volume.maxNameLength];      Volume.GetLabelString[        volumeID, volumeLabel ! Volume.NeedsScavenging => LOOP];      IF volumeLabel.length > s.length - prefixLength THEN {        s.length ¬ prefixLength; String.AppendString[to: s, from: volumeLabel]};      ENDLOOP;    String.AppendString[s, "* "L];    RETURN[      ToolFont.StringWidth[" 000000 pages"L, font] + ToolFont.StringWidth[        s, font]]};  SwWidth: PROC RETURNS [w: CARDINAL] = {    pageW: CARDINAL = SetupVolumeName[];    dateW: CARDINAL = ToolFont.StringWidth[      "Wednesday Jan 31, 1956 10:10:10"L, WindowFont.defaultFont];    cursorW: CARDINAL = (cursorGap + cursorWidth) * maxCursors;    w ¬ 2 * indent + cursorW + MAX[pageW, dateW]};  WindowHeight: PROC RETURNS [CARDINAL] = {    fontHeight: CARDINAL = WindowFont.FontHeight[WindowFont.defaultFont];    RETURN[5 * fontHeight / 2]};  Paint: PROC [sw: Window.Handle] = {    -- Format of Herald window's banner line is:    --	MsgSW		Cursors		 date - time    --  MsgSW		Cursors   	 logicalVolumeName  freePages    font: WindowFont.Handle = WindowFont.defaultFont;    fontHeight: CARDINAL = WindowFont.FontHeight[font];    timeW: CARDINAL = SetupVolumeName[] + indent;    maxWidth: CARDINAL = Window.GetBox[sw].dims.w;    data.currentVolume ¬ Volume.systemID;    newVolume ¬ Volume.systemID;    data.timeX ¬ IF maxWidth > timeW THEN maxWidth - timeW ELSE 0;    IF data.msgCnt >= 2 THEN AppendVersion[];    Display.White[sw, [[0, 0], Window.GetBox[sw].dims]];    FOR slot: Slot ¬ slotHead, slot.link UNTIL slot = NIL DO      PaintCursor[slot] ENDLOOP;    IF options.timeOK THEN PaintTime[Time.Current[], TRUE, font, fontHeight]    ELSE      [] ¬ Display.Text[        window: sw, string: "Time not set! Create no files!"L,        place: [data.timeX, line1Fudge], font: font, flags: Display.replaceFlags];    PaintVolumeInfo[]};  Bold: PROC [x, y: CARDINAL, s: STRING, font: WindowFont.Handle]    RETURNS [newX: CARDINAL] = {    [] ¬ Display.Text[      window: data.sw, string: s, place: [x: x, y: y], font: font,      flags: Display.paintFlags];    newX ¬ Display.Text[      window: data.sw, string: s, place: [x: x + 1, y: y], font: font,      flags: Display.paintFlags].x};  PaintVolumeInfo: PROCEDURE = {    font: WindowFont.Handle = WindowFont.defaultFont;    fontHeight: CARDINAL = WindowFont.FontHeight[font];    y: CARDINAL = fontHeight + line2Fudge;    volumeName: STRING = [50];  -- Volume.maxNameLength + ("Volume: "L).length    String.AppendString[volumeName, "Volume: "L];    HeraldWindow.AppendLogicalVolumeName[volumeName, data.currentVolume];    IF data.currentVolume # Volume.systemID THEN String.AppendChar[volumeName, '*];    String.AppendChar[volumeName, ' ];    Display.White[      data.sw, [      [x: data.timeX, y: y], [      w: Window.GetBox[data.sw].dims.w - data.timeX,      h: Window.GetBox[data.sw].dims.h - y]]];    data.pagesX ¬ Bold[x: data.timeX, y: y, s: volumeName, font: font];    displayedPages ¬ Volume.GetAttributes[      data.currentVolume !      Volume.NeedsScavenging => {        PaintScavengeMsg[font, fontHeight]; GOTO return}].freePageCount;    PaintPages[displayedPages, font, fontHeight]    EXITS return => NULL};  PaintCursor: PROC [slot: Slot] = {    IF data = NIL OR slot = NIL THEN RETURN;    Display.Bitmap[      window: data.sw,      box: [      place: [      x: indent + slot.position * (cursorGap + cursorWidth), y: cursorFudge],      dims: [w: cursorWidth, h: 16]],      address: [word: @slot.cursorArray[0], bit: 0], bitmapBitWidth: cursorWidth,      flags: Display.replaceFlags]};  PaintScavengeMsg: PROC [font: WindowFont.Handle, fontHeight: CARDINAL] = {    x: CARDINAL ¬ Display.Text[      window: data.sw, string: "scavenge!"L,      place: [x: data.pagesX, y: fontHeight + line2Fudge], font: font,      flags: Display.replaceFlags].x;    Display.White[      data.sw, [      place: [x: x, y: fontHeight + line2Fudge],      dims: [w: Window.GetBox[data.sw].dims.w - x, h: fontHeight]]];    };  PaintPages: PROC [    pages: Volume.PageCount, font: WindowFont.Handle, fontHeight: CARDINAL] = {    s: STRING ¬ [30];    x: CARDINAL;    String.AppendLongNumber[s, pages, 10];    String.AppendString[s, " pages"L];    x ¬ Display.Text[      window: data.sw, string: s,      place: [x: data.pagesX, y: fontHeight + line2Fudge], font: font,      flags: Display.replaceFlags].x;    Display.White[      data.sw, [      place: [x: x, y: fontHeight + line2Fudge],      dims: [w: Window.GetBox[data.sw].dims.w - x, h: fontHeight]]];    displayedPages ¬ pages};  PaintTime: PROC [    time: System.GreenwichMeanTime, all: BOOLEAN, font: WindowFont.Handle,    fontHeight: CARDINAL] = {    unp: Time.Unpacked ¬ Time.Unpack[time];    x: CARDINAL ¬ data.timeX;    s: STRING ¬ [30];    AppendDec2: PROCEDURE [n: CARDINAL] = {      String.AppendChar[s, '0 + n / 10]; String.AppendChar[s, '0 + n MOD 10]};    IF all OR data.displayedUnp.weekday # unp.weekday THEN {      AppendWeekday[s, unp.weekday];      String.AppendChar[s, ' ];      data.x.month ¬ ToolFont.StringWidth[s, font] + x;      all ¬ TRUE}    ELSE x ¬ data.x.month;    IF all OR data.displayedUnp.month # unp.month THEN {      AppendMonth[s, unp.month];      String.AppendChar[s, ' ];      data.x.day ¬ ToolFont.StringWidth[s, font] + x;      all ¬ TRUE}    ELSE x ¬ data.x.day;    IF all OR data.displayedUnp.day # unp.day THEN {      String.AppendNumber[s, unp.day, 10];      String.AppendString[s, " - "];      data.x.hour ¬ ToolFont.StringWidth[s, font] + x;      all ¬ TRUE}    ELSE x ¬ data.x.hour;    IF all OR data.displayedUnp.hour # unp.hour THEN {      AppendDec2[unp.hour];      String.AppendChar[s, ':];      data.x.minute ¬ ToolFont.StringWidth[s, font] + x;      all ¬ TRUE}    ELSE x ¬ data.x.minute;    IF all OR data.displayedUnp.minute # unp.minute THEN {      AppendDec2[unp.minute];      String.AppendChar[s, ':];      data.x.second ¬ ToolFont.StringWidth[s, font] + x;      all ¬ TRUE}    ELSE x ¬ data.x.second;    AppendDec2[unp.second];    x ¬ Display.Text[      window: data.sw, string: s, place: [x: x, y: line1Fudge], font: font,      flags: Display.replaceFlags].x;    IF x < data.x.end THEN      Display.White[        data.sw, [        place: [x: x, y: line1Fudge], dims: [w: data.x.end - x, h: fontHeight]]];    data.x.end ¬ x;    data.displayedTime ¬ time;    data.displayedUnp ¬ unp};  AppendMonth: PROC [s: STRING, month: CARDINAL] = {    months: STRING = "JanFebMarAprMayJunJulAugSepOctNovDec"L;    FOR i: CARDINAL IN [month * 3..(month + 1) * 3) DO      String.AppendChar[s, months[i]]; ENDLOOP};  AppendWeekday: PROC [s: STRING, day: CARDINAL] = {    weekdays: ARRAY [0..7) OF STRING = [      "Monday"L, "Tuesday"L, "Wednesday"L, "Thursday"L, "Friday"L, "Saturday"L,      "Sunday"L];    String.AppendString[s, weekdays[day]]};  Notify: ENTRY Supervisor.AgentProcedure = {    ENABLE UNWIND => NULL;    SELECT event FROM      EventTypes.abortSession, EventTypes.bootPhysicalVolume,        EventTypes.resumeDebuggee =>	   IF options.painterState = on AND ~options.stopPainting THEN 	     {suspendPainter ¬ TRUE; SetPainter[off]};      EventTypes.newSession, EventTypes.resumeSession =>         IF suspendPainter THEN {suspendPainter ¬ FALSE; SetPainter[on]};      EventTypes.primaryCredentials => {        loginState ¬ Inline.LowHalf[eventData];--@@@Sleaze Ball until 13.0	Profile.GetUser[GetUser]; AppendVersion[]};      ENDCASE};  SetPainter: INTERNAL PROCEDURE [state: OffOn] = {    SELECT state FROM      options.painterState => NULL;      off => {        options.stopPainting ¬ TRUE;        NOTIFY cv;        WHILE options.painterState = on DO WAIT cv; ENDLOOP};      on => {options.stopPainting ¬ FALSE; Process.Detach[FORK Painter[]]};      ENDCASE};  Painter: ENTRY PROC = {    ENABLE { UNWIND => NULL; ABORTED => CONTINUE};    Process.SetPriority[Process.priorityNormal];    options.painterState ¬ on;    PainterInternal[];    options.painterState ¬ off};  PainterInternal: INTERNAL PROCEDURE = {    font: WindowFont.Handle = WindowFont.defaultFont;    fontHeight: CARDINAL = WindowFont.FontHeight[font];    findPages: CARDINAL ¬ 11;    now: System.GreenwichMeanTime;    pages: Volume.PageCount ¬ displayedPages;    Process.SetTimeout[@cv, Process.MsecToTicks[250]];    DO      WAIT cv;      IF options.stopPainting THEN EXIT;      IF data.currentPriority # newPriority THEN        Process.SetPriority[data.currentPriority ¬ newPriority];      now ¬ Time.Current[];      IF now = data.displayedTime AND newVolume = data.currentVolume THEN LOOP;      IF now # data.displayedTime THEN        IF options.timeOK THEN PaintTime[now, FALSE, font, fontHeight]        ELSE          Display.Invert[            data.sw, [            place: [x: data.timeX, y: line1Fudge],            dims: [w: Window.GetBox[data.sw].dims.w - data.timeX, h: fontHeight]]];      IF newVolume # data.currentVolume THEN {        data.currentVolume ¬ newVolume; findPages ¬ 0; PaintVolumeInfo[]}      ELSE        IF (findPages ¬ findPages + 1) = 12 THEN {          findPages ¬ 0;          displayedPages ¬ Volume.GetAttributes[            data.currentVolume !            Volume.NeedsScavenging => {              PaintScavengeMsg[font, fontHeight]; LOOP}].freePageCount};      IF pages # displayedPages THEN {        pages ¬ displayedPages; PaintPages[pages, font, fontHeight]};      IF data.msgCnt >= 2 THEN data.msgTime ¬ data.msgTime + 1;      IF data.msgTime >= 30 THEN AppendVersion[];      ENDLOOP};  DefaultConfirm: PUBLIC HeraldWindow.ConfirmProcType =    -- Requests confirmation, then notifies the world that we are booting    BEGIN    Cursor.Set[mouseRed];    IF (okay ¬ UserInput.WaitForConfirmation[].okay) THEN      okay ¬ AlwaysConfirm[post, cleanup]    ELSE {Cursor.Set[textPointer]; UserInput.WaitNoButtons[]};    END;  ThisVolumeConfirm: HeraldWindow.ConfirmProcType =    -- Requests confirmation and then boots    BEGIN    Cursor.Set[mouseRed];    IF (okay ¬ UserInput.WaitForConfirmation[].okay) THEN      BEGIN      okay ¬ TRUE;      Cursor.Set[hourGlass];      IF cleanup THEN {        Supervisor.NotifyDirectSubsystems[          event: EventTypes.aboutToBoot, which: clients,          subsystem: Event.aboutToSwap !          Supervisor.EnumerationAborted => GOTO no]};      END    ELSE {Cursor.Set[textPointer]; UserInput.WaitNoButtons[]};    EXITS      no => {        okay ¬ FALSE;        Supervisor.NotifyDirectSubsystems[          event: EventTypes.swapCancelled, which: clients,          subsystem: Event.swapping]}    END;  AlwaysConfirm: PUBLIC HeraldWindow.ConfirmProcType =    -- Notifies the world that we are booting    BEGIN    okay ¬ TRUE;    Cursor.Set[hourGlass];    IF Profile.place = copilot THEN {      IF cleanup THEN        Supervisor.NotifyDirectSubsystems[          event: EventTypes.aboutToAbortSession, which: clients,          subsystem: Event.aboutToSwap ! Supervisor.EnumerationAborted => GOTO no]}    ELSE      IF cleanup THEN        Supervisor.NotifyDirectSubsystems[          event: EventTypes.aboutToBoot, which: clients,          subsystem: Event.aboutToSwap ! Supervisor.EnumerationAborted => GOTO no];    EXITS      no => {        okay ¬ FALSE;        Supervisor.NotifyDirectSubsystems[          event: EventTypes.swapCancelled, which: clients,          subsystem: Event.swapping]}    END;  DefaultPost: PUBLIC Format.StringProc = {IF s # NIL THEN Put.LongString[NIL, s]};  DoIt: Menu.MCRType =  -- This procedure executes the menu commands.    BEGIN    currentSel: LONG STRING ¬ Selection.Convert[string];    BEGIN    ENABLE      BEGIN      HeraldWindowOps.EmptySelection => GOTO Msg;      UNWIND => HeraldWindowOps.z.FREE[@currentSel];      END;    SELECT index FROM      0 =>        HeraldWindow.BootFromVolumeName[          name: HeraldWindowOps.menuStrings[index],          confirmProc: ThisVolumeConfirm];      IN [1..HeraldWindowOps.nVols) =>        HeraldWindow.BootFromVolumeName[HeraldWindowOps.menuStrings[index]];      (HeraldWindowOps.nVols + fileEntry) =>        IF String.EmptyString[currentSel] THEN GOTO Msg        ELSE HeraldWindow.BootFromFile[currentSel];      (HeraldWindowOps.nVols + bootButtonEntry) =>        IF DefaultConfirm[DefaultPost] THEN HeraldWindowOps.BootButton[];      (HeraldWindowOps.nVols + setSwitchesEntry) =>        IF String.EmptyString[currentSel] THEN GOTO Msg        ELSE          HeraldWindow.SetSwitches[            HeraldWindow.ScanSwitches[            currentSel ! HeraldWindow.InvalidSwitches => GOTO BadSwitches]];      (HeraldWindowOps.nVols + resetSwitchesEntry) =>        HeraldWindow.SetSwitches[System.defaultSwitches];      (HeraldWindowOps.nVols + upPriorityEntry) =>        newPriority ¬ Process.priorityForeground;      (HeraldWindowOps.nVols + resetPriorityEntry) =>        newPriority ¬ Process.priorityNormal;      ENDCASE => Put.Line[NIL, "Menu item not supported"L];    HeraldWindowOps.z.FREE[@currentSel];    EXITS      Msg => Put.Line[NIL, "Make a selection first!"L];      BadSwitches => Put.Line[NIL, "Invalid boot switches"L];    END;    END;  FreeMenu: PUBLIC PROC [menu: Menu.Handle] = {    Menu.Uninstantiate[menu, HeraldWindow.window];    Menu.Free[menu: menu, freeStrings: TRUE];    --don't free these: they may be used by HeraldWindowsA;    --HeraldWindowOps.z.FREE[@volumeIDs];    --menuStrings ¬ NIL;    --volumeIDs ¬ NIL    };  MakeMenu: PUBLIC PROCEDURE RETURNS [menu: Menu.Handle] =    -- This makes the menu, add the extra entries to the menu.    BEGIN OPEN HeraldWindowOps;    menuStrings[HeraldWindowOps.nVols + fileEntry] ¬ "File Name:"L;    menuStrings[HeraldWindowOps.nVols + bootButtonEntry] ¬ "Boot Button"L;    menuStrings[HeraldWindowOps.nVols + setSwitchesEntry] ¬ "Set Switches:"L;    menuStrings[HeraldWindowOps.nVols + resetSwitchesEntry] ¬ "Reset Switches"L;    menuStrings[HeraldWindowOps.nVols + upPriorityEntry] ¬ "Set Priority Up"L;    menuStrings[HeraldWindowOps.nVols + resetPriorityEntry] ¬ "Reset Priority"L;    menu ¬ Menu.Make[      name: "Boot from:"L, strings: DESCRIPTOR[HeraldWindowOps.menuStrings­],      mcrProc: DoIt, copyStrings: TRUE, permanent: FALSE];    END;  -- Define Windows, Subwindows and data  -- This procedure lifted from ToolsA.mesa  UserCmValues: PROCEDURE [    id: LONG STRING, box: Window.Box, place: Window.Place, state: ToolWindow.State]    RETURNS [Window.Box, Window.Place, ToolWindow.State] = {    Option: TYPE = MACHINE DEPENDENT{      windowBox(0), tinyPlace(1), initialState(2), noMatch(StringLookUp.noMatch)};    DefinedOption: TYPE = Option [windowBox..initialState];    optionTable: ARRAY DefinedOption OF LONG STRING ¬ [      windowBox: "WindowBox"L, tinyPlace: "TinyPlace"L,      initialState: "InitialState"L];    userCm: CmFile.Handle;    i: Option;    CheckType: PROCEDURE [h: CmFile.Handle, table: StringLookUp.TableDesc]      RETURNS [index: CARDINAL] = CmFile.NextValue;    MyNextValue: PROCEDURE [      h: CmFile.Handle,      table: LONG DESCRIPTOR FOR ARRAY DefinedOption OF LONG STRING]      RETURNS [index: Option] = LOOPHOLE[CheckType];    userCm ¬ CmFile.UserDotCmOpen[ ! CmFile.Error => GOTO NoUserDotCm];    IF CmFile.FindSection[userCm, id] THEN      BEGIN      DO        SELECT        (i ¬ MyNextValue[          userCm, DESCRIPTOR[optionTable] ! CmFile.TableError => RESUME ]) FROM          noMatch => EXIT;          windowBox => box ¬ Token.WindowBox[userCm];          tinyPlace => place ¬ Token.WindowBox[userCm].place;          initialState => state ¬ GetState[userCm, state];          ENDCASE;        ENDLOOP;      END;    [] ¬ CmFile.Close[userCm];    RETURN[box, place, state];    EXITS NoUserDotCm => RETURN[box, place, state];    };  -- This procedure lifted from ToolsA.mesa  GetState: PROCEDURE [h: CmFile.Handle, state: ToolWindow.State]    RETURNS [ToolWindow.State] = {    labels: ARRAY [0..3) OF LONG STRING ¬ ["tiny"L, "active"L, "inactive"L];    temp: LONG STRING ¬ Token.Item[h];    IF String.Length[temp] > 0 THEN {      SELECT StringLookUp.InTable[temp, DESCRIPTOR[labels]] FROM        0 => state ¬ tiny;        1 => state ¬ active;        2 => state ¬ inactive;        ENDCASE};    temp ¬ Token.FreeTokenString[temp];    RETURN[state]};  StartHerald: PUBLIC PROCEDURE [systemName: LONG STRING, tinyName: LONG STRING] =    BEGIN    name: STRING = "Herald"L;    swHeight: CARDINAL = SetSystemName[systemName];  -- starts HeraldWindowsB    screenWidth: CARDINAL = Window.GetBox[Window.rootWindow].dims.w;    initialBox: Window.Box ¬ [      place: [x: 0, y: 0], dims: [w: screenWidth, h: swHeight]];    tinyPlace: Window.Place ¬ [-1, -1];    initialState: ToolWindow.State ¬ active;    IF System.switches['N] = up THEN      [initialBox, tinyPlace, initialState] ¬ UserCmValues[        "HeraldWindow"L, initialBox, tinyPlace, initialState];    HeraldWindowOps.SetUpMenuandVolStrings[];  -- starts HeraldWindowsA    pointUp ¬ Atom.MakeAtom["PointUp"L];    adjustUp ¬ Atom.MakeAtom["AdjustUp"L];    enter ¬ Atom.MakeAtom["Enter"L];    exit ¬ Atom.MakeAtom["Exit"L];    Process.EnableAborts[pSec];    Profile.GetUser[GetUser];    Supervisor.AddDependency[client: agent, implementor: Event.primaryCredentials];    defaultTinyName1 ¬ String.CopyToNewString[s: tinyName, z: Heap.systemZone];    defaultTinyName2 ¬ String.CopyToNewString[s: name, z: Heap.systemZone];    isTiny ¬ initialState = tiny;    window ¬ ToolWindow.Create[      name: name, adjust: Adjust, transition: Transition, box: initialBox,      initialState: initialState, named: FALSE];    realTIP ¬ TIP.SetNotifyProc[window, HeraldTIP];    IF tinyPlace # [-1, -1] THEN      ToolWindow.SetTinyPlace[window: window, place: tinyPlace];    ToolWindow.SetTinyName[window, tinyName, name];    IF initialState # inactive THEN      Transition[window: window, new: initialState, old: inactive];    ToolWindow.Show[window];    END;  END.    
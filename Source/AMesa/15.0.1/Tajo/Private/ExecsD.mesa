-- File: ExecsD.mesa - last edit:-- Riggle.PA            8-Aug-86 16:13:21-- Copyright (C) 1981, 1982 , 1986 by Xerox Corporation. All rights reserved. -- File: ExecsD.mesa - last edited by:-- PXK    :	20-Jul-81 15:08:51-- SXW   :	13-Jul-81  8:47:01-- LXR    :	 5-Nov-82 16:00:33-- Mark:	 5-Jun-81 15:11:32-- JGS:		19-Aug-81  8:33:09-- SXS   :	15-Oct-81 14:57:52-- RXR   :	24-Sep-82 17:26:31-- MEW		31-Jul-85 11:52:45DIRECTORY  CmFile USING [    Close, Error, FindSection, Handle, NextValue, TableError, UserDotCmOpen],  ExecInternal USING [],  Heap USING [systemZone],  SpecialExec USING [],  String USING [    AppendChar, EmptyString, EquivalentString, InvalidNumber,     Replace, StringBoundsFault, StringLength, StringToOctal],  StringLookUp USING [noMatch, TableDesc],  System USING [defaultSwitches, Switches, switches, UpDown],  Token USING [Boolean, Handle, Item],  Volume USING [    ID, GetLabelString, GetNext, GetType, maxNameLength, nullID, systemID, Type,    TypeSet];ExecsD: MONITOR  IMPORTS    CmFile, Heap, System, String, Token, Volume  EXPORTS ExecInternal, SpecialExec =  BEGIN  bootSwitches: PUBLIC System.Switches ¬ System.defaultSwitches;  clientVolume: PUBLIC Volume.ID ¬ Volume.nullID;  volumeLabel: PUBLIC LONG STRING ¬ NIL;  runSwitches: PUBLIC LONG STRING ¬ NIL;  codeLinks: PUBLIC BOOLEAN ¬ TRUE;  loaderRunning: PUBLIC BOOLEAN ¬ FALSE;  useBackground: PUBLIC BOOLEAN ¬ FALSE;  compilerSwitches: PUBLIC LONG STRING ¬ NIL;  binderSwitches: PUBLIC LONG STRING ¬ NIL;    z: UNCOUNTED ZONE = Heap.systemZone;  Do: PUBLIC ENTRY PROCEDURE [proc: PROCEDURE] = {ENABLE UNWIND => NULL; proc[]};  ProcessUserCm: PUBLIC ENTRY PROCEDURE =    BEGIN    ENABLE UNWIND => NULL;    IF System.switches['n] = up THEN      ProcessUserCmInternal[        ! CmFile.TableError => { --name is invalid option-- RESUME }];    END;  ProcessUserCmInternal: INTERNAL PROCEDURE =    BEGIN OPEN CmFile;    Option: TYPE = MACHINE DEPENDENT{      binderSwitches(0), compilerSwitches, clientSwitches, clientVolume,      codeLinks, useBackground, noMatch(StringLookUp.noMatch)};    DefinedOption: TYPE = Option [binderSwitches..useBackground];    StringOption: TYPE = Option [binderSwitches..compilerSwitches];    optionTable: ARRAY DefinedOption OF LONG STRING ¬ [      binderSwitches: "BinderSwitches"L, clientSwitches: "ClientSwitches"L,      clientVolume: "ClientVolume"L, codeLinks: "CodeLinks"L,      compilerSwitches: "CompilerSwitches"L, useBackground: "UseBackground"L];    strings: ARRAY StringOption OF LONG POINTER TO LONG STRING ¬ [      binderSwitches: @binderSwitches, compilerSwitches: @compilerSwitches];    userCm: CmFile.Handle;    i: Option;    CheckType: PROCEDURE [h: CmFile.Handle, table: StringLookUp.TableDesc]      RETURNS [index: CARDINAL] = CmFile.NextValue;    MyNextOption: PROCEDURE [      h: CmFile.Handle,      table: LONG DESCRIPTOR FOR ARRAY DefinedOption OF LONG STRING]      RETURNS [index: Option] = LOOPHOLE[CheckType];    userCm ¬ CmFile.UserDotCmOpen[ ! CmFile.Error => GOTO NoUserDotCm];    IF CmFile.FindSection[userCm, "Executive"L] THEN      BEGIN      DO        SELECT (i ¬ MyNextOption[userCm, DESCRIPTOR[optionTable]]) FROM          noMatch => EXIT;          codeLinks => codeLinks ¬ Token.Boolean[userCm];          useBackground => useBackground ¬ Token.Boolean[userCm];          IN StringOption => ReplaceAndFreeToken[strings[i], Token.Item[userCm]];          clientVolume => {            string: LONG STRING;            IF ~String.EmptyString[string ¬ Token.Item[userCm]] THEN              BEGIN              ReplaceAndFreeToken[@volumeLabel, string];              clientVolume ¬ MapClientVolumeNameToID[volumeLabel];              END};          clientSwitches => {            string: LONG STRING;            IF ~String.EmptyString[string ¬ Token.Item[userCm]] THEN              BEGIN              bootSwitches ¬ InternalProcessBootSwitchList[string];              ReplaceAndFreeToken[@runSwitches, string];              END};          ENDCASE;        ENDLOOP;      END;    [] ¬ CmFile.Close[userCm];    EXITS NoUserDotCm => NULL;    END;  ReplaceAndFreeToken: PROCEDURE [    pString: LONG POINTER TO LONG STRING, token: LONG STRING] = INLINE {    String.Replace[pString, token, z]; z.FREE[@token]; };  ProcessBootSwitchList: PUBLIC ENTRY PROCEDURE [switches: LONG STRING]    RETURNS [System.Switches] = {    ENABLE UNWIND => NULL; RETURN[InternalProcessBootSwitchList[switches]]};  InternalProcessBootSwitchList: INTERNAL PROCEDURE [s: LONG STRING]    RETURNS [switches: System.Switches] =    BEGIN OPEN String;    c: CHARACTER;    nChars: CARDINAL ¬ String.StringLength[s];    state: {code, chars} ¬ chars;    i: CARDINAL ¬ 0;    code: STRING ¬ [6];    switches ¬ ALL[up];    DO      IF i >= nChars THEN EXIT;      SELECT (c ¬ s[i]) FROM        '" =>          SELECT state FROM            code => {              IF code.length # 0 THEN                switches[StringToOctal[code ! InvalidNumber => CONTINUE]] ¬ down;              state ¬ chars};            ENDCASE => {code.length ¬ 0; state ¬ code};	'\\ => 	  SELECT state FROM	    code => AppendChar[code, c ! StringBoundsFault => CONTINUE];            ENDCASE => {	      i ¬ i + 1;  -- skip the \ --	      IF i + 2 < nChars THEN {		THROUGH [0..3) DO		  AppendChar[code, s[i] ! StringBoundsFault => CONTINUE];		  i ¬ i + 1;		ENDLOOP;		switches[StringToOctal[code ! InvalidNumber => CONTINUE]] ¬ down}}        ENDCASE =>          SELECT state FROM            code => AppendChar[code, c ! StringBoundsFault => CONTINUE];            ENDCASE => switches[c] ¬ down;      i ¬ i + 1;      ENDLOOP;    END;  MapClientVolumeNameToID: PUBLIC PROCEDURE [name: LONG STRING]    RETURNS [volumeID: Volume.ID] =    BEGIN    volumeID ¬ Volume.nullID;    UNTIL (volumeID ¬ Volume.GetNext[volumeID, ALL[TRUE]]) = Volume.nullID DO      volumeLabel: LONG STRING ¬ [Volume.maxNameLength];      Volume.GetLabelString[volumeID, volumeLabel];      IF String.EquivalentString[volumeLabel, name] THEN EXIT;      ENDLOOP;    END;  SetDefaults: PUBLIC ENTRY PROCEDURE =    BEGIN    ENABLE UNWIND => NULL;    systemVolumeType: Volume.Type = Volume.GetType[Volume.systemID];    IF systemVolumeType = FIRST[Volume.Type] THEN clientVolume ¬ Volume.nullID    ELSE      BEGIN OPEN Volume;      clients: TypeSet ¬ [];      clients[PRED[systemVolumeType]] ¬ TRUE;      IF (clientVolume ¬ GetNext[nullID, clients]) ~= nullID THEN        BEGIN        vol: STRING ¬ [maxNameLength];        GetLabelString[clientVolume, vol];        String.Replace[@volumeLabel, vol, z];        END;      END;    END;  END.
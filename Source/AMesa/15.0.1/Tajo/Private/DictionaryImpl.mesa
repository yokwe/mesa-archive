-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- File: DictionaryImpl.mesa - last edit by: -- JGS on	 7-Jan-83 14:48:31-- AXD    	 4-Feb-83 18:31:18-- Abbreviation expansion.DIRECTORY  Dictionary: TYPE USING [ErrorType],  Heap: TYPE USING [Create, Delete],  MStream: TYPE USING [Error, ReadOnly],  Stream: TYPE USING [    Delete, EndOfStream, GetChar, Handle, PutChar, PutString, SendNow],  String: TYPE USING [    AppendCharAndGrow, Compare, CopyToNewString, Empty, EquivalentSubString,    SubStringDescriptor];DictionaryImpl: MONITOR LOCKS h.lock USING h: Handle  IMPORTS Heap, MStream, Stream, String  EXPORTS Dictionary =   BEGIN    OPEN Dictionary;    Handle: TYPE = LONG POINTER TO Object;  Object: PUBLIC TYPE = RECORD [    password: CARDINAL ¬ objectPassword,    lock: MONITORLOCK,    z: UNCOUNTED ZONE,    nEntries: CARDINAL ¬ 0,    keys, definitions: Strings ¬ NIL];  Strings: TYPE = LONG POINTER TO StringSequence;  StringSequence: TYPE = RECORD [    array: SEQUENCE length: NAT OF LONG STRING];      objectPassword: CARDINAL = 121314B;  filePassword: CARDINAL = 151213B;    Error: PUBLIC ERROR [type: ErrorType] = CODE;  -- Definition and Lookup:  Create: PUBLIC PROC [stream: Stream.Handle] RETURNS [Handle] = {    h: Handle;    z: UNCOUNTED ZONE ¬ Heap.Create[initial: 4];    h ¬ z.NEW[Object ¬ [z: z]];    Load[h, stream ! Error => CONTINUE; UNWIND => Heap.Delete[z]];    RETURN[h]};      Open: PUBLIC PROC [name: LONG STRING] RETURNS [h: Handle] = {    stream: Stream.Handle ¬ NIL;    stream ¬ MStream.ReadOnly[name, [] ! MStream.Error => CONTINUE];    h ¬ Create[stream];    IF stream # NIL THEN stream.Delete[]};      Delete: PUBLIC PROC [h: Handle] = {    IF h = NIL OR h.password # objectPassword THEN ERROR Error[invalidDictionary];    Heap.Delete[h.z]};      Define: PUBLIC ENTRY PROC [h: Handle, key, def: LONG STRING] = {    ENABLE UNWIND => NULL;    IF String.Empty[key] THEN ERROR Error[invalidParameters];    DefineInternal[h, key, def, FALSE]};  DefineInternal: PROC [    h: Handle, key, def: LONG STRING, uniquePrefix: BOOLEAN] = {    z: UNCOUNTED ZONE = h.z;    index: NAT ¬ GetKey[h, key, TRUE, uniquePrefix];    z.FREE[@h.definitions[index]];    IF String.Empty[def] THEN {      z.FREE[@h.keys[index]];      z.FREE[@h.definitions[index]];      FOR i: NAT IN (index..h.nEntries) DO        h.keys[i-1] ¬ h.keys[i];	h.definitions[i-1] ¬ h.definitions[i];	ENDLOOP;      h.nEntries ¬ h.nEntries - 1}    ELSE       h.definitions[index] ¬ String.CopyToNewString[s: def, z: z]};  Enumerate: PUBLIC ENTRY PROC [    h: Handle, proc: PROC [key, def: LONG STRING] RETURNS [BOOLEAN]] = {    ENABLE UNWIND => NULL;    FOR i: NAT IN [0..h.nEntries) DO      IF proc[key: h.keys[i], def: h.definitions[i]] THEN EXIT;      ENDLOOP};  Info: PUBLIC ENTRY PROC [h: Handle] RETURNS [CARDINAL] = {RETURN[h.nEntries]};  LookUp: PUBLIC ENTRY PROC [    h: Handle, key: LONG STRING] RETURNS [LONG STRING] = {    ENABLE UNWIND => NULL;    index: NAT;    IF String.Empty[key] THEN ERROR Error[invalidParameters];    index ¬ GetKey[h, key, FALSE, TRUE];    IF index = NAT.LAST THEN RETURN[NIL] ELSE RETURN[h.definitions[index]]};  Load: PUBLIC ENTRY PROC [h: Handle, stream: Stream.Handle] = {    ENABLE UNWIND => NULL;    z: UNCOUNTED ZONE = h.z;    key: LONG STRING;    def: LONG STRING;    c, endChar: CHARACTER;    IF stream = NIL THEN RETURN;    key ¬ z.NEW[StringBody[20]];    def ¬ z.NEW[StringBody[100]];    DO      ENABLE {        UNWIND => {z.FREE[@key]; z.FREE[@def]};	Stream.EndOfStream => GOTO badFile};      key.length ¬ def.length ¬ 0;      UNTIL (c ¬ stream.GetChar[! Stream.EndOfStream => GOTO done]) = ': DO        String.AppendCharAndGrow[to: @key, c: c, z: z];	ENDLOOP;      IF stream.GetChar[] # '\t THEN GOTO badFile;      c ¬ stream.GetChar[];      IF c = '" THEN {endChar ¬ '"; c ¬ stream.GetChar[]} ELSE endChar ¬ '\n;      DO        String.AppendCharAndGrow[to: @def, c: c, z: z];	IF (c ¬ stream.GetChar[]) = endChar THEN {	  IF endChar = '" THEN [] ¬ stream.GetChar[]; EXIT};	ENDLOOP;      DefineInternal[h, key, def, FALSE];      REPEAT done => NULL; badFile => ERROR Error[fileFormatProblem];      ENDLOOP;    z.FREE[@key];    z.FREE[@def]};    Save: PUBLIC ENTRY PROC [h: Handle] = {};      Store: PUBLIC ENTRY PROC [h: Handle, stream: Stream.Handle] = {    ENABLE UNWIND => NULL;    FOR i: NAT IN [0..h.nEntries) DO      stream.PutString[h.keys[i]];      stream.PutChar[':];      stream.PutChar['\t];      stream.PutChar['"];      stream.PutString[h.definitions[i]];      stream.PutChar['"];      stream.PutChar['\n];      ENDLOOP;    stream.SendNow[]};      GetKey: PROC [    h: Handle, key: LONG STRING, addNew, uniquePrefix: BOOLEAN] RETURNS [NAT] = {    keys: Strings ¬ h.keys;    definitions: Strings;    u, l, i: NAT;    IF (keys = NIL OR h.nEntries = keys.length) AND addNew THEN ExpandArrays[h];    keys ¬ h.keys;    definitions ¬ h.definitions;    l ¬ 1;    u ¬ h.nEntries;    DO      IF u < l THEN EXIT;      i ¬ (l + u)/2;      SELECT String.Compare[keys[i-1], key] FROM	< 0 => l ¬ i + 1;	> 0 => u ¬ i - 1;	ENDCASE => RETURN[i-1];      ENDLOOP;    IF uniquePrefix AND UniquePrefix[h, u, key] THEN RETURN[u];    IF ~addNew THEN RETURN[NAT.LAST];    FOR i DECREASING IN [u..h.nEntries) DO      keys[i+1] ¬ keys[i]; definitions[i+1] ¬ definitions[i];      ENDLOOP;    h.nEntries ¬ h.nEntries + 1;    keys[u] ¬ String.CopyToNewString[s: key, z: h.z];    definitions[u] ¬ NIL;    RETURN[u]};    UniquePrefix: PROC [    h: Handle, index: NAT, key: LONG STRING] RETURNS [BOOLEAN] = {    OPEN String;    keySS: SubStringDescriptor ¬ [base: key, offset: 0, length: key.length];    defSS: SubStringDescriptor;    def: LONG STRING;    nPrefixes: NAT ¬ 0;    WHILE index < h.nEntries AND nPrefixes <= 1 DO      def ¬ h.keys[index];      defSS ¬ [base: def, offset: 0, length: MIN[keySS.length, def.length]];      IF EquivalentSubString[@keySS, @defSS] THEN nPrefixes ¬ nPrefixes + 1      ELSE EXIT;      index ¬ index + 1;      ENDLOOP;    RETURN[nPrefixes = 1]};    ExpandArrays: PROC [h: Handle] = {    z: UNCOUNTED ZONE = h.z;    keys: Strings ¬ h.keys;    definitions: Strings ¬ h.definitions;    i: NAT;    newKeys: Strings ¬ z.NEW[StringSequence[h.nEntries+10]];    newDefs: Strings ¬ z.NEW[StringSequence[newKeys.length]];    FOR i IN [0..h.nEntries) DO      newKeys[i] ¬ keys[i]; newDefs[i] ¬ definitions[i]; ENDLOOP;    FOR i IN [h.nEntries..newKeys.length) DO      newKeys[i] ¬ newDefs[i] ¬ NIL; ENDLOOP;    z.FREE[@keys];    z.FREE[@definitions];    h.keys ¬ newKeys;    h.definitions ¬ newDefs};    END.  -- of DictionaryImpl    
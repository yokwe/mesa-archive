-- Copyright (C) 1981, 1982  by Xerox Corporation. All rights reserved. -- File: ProfileTool.mesa - Last modified by:-- SXE  	Jul 15, 1980 9:27 AM-- Mark		Nov 13, 1979 12:25 PM-- PXK    	13-Nov-81 11:19:22-- BXM  	13-Nov-81 15:29:57-- LXR    	18-Nov-82 15:55:28-- RXR   	 1-Oct-82 12:22:37-- RXJ     	29-Dec-82 22:14:17-- BJD    	26-Oct-84 14:27:25-- DSC  	14-Mar-85 10:06:27    DIRECTORY  Ascii USING [SP],  Event USING [primaryCredentials, tajoDefaults],  EventTypes USING [TajoDefaultEvents, CredentialEvents],  ExecUtilities USING [profileToolWindow],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType,    CommandItem, Display, DisplayItem, FilterProcType, FindItem, ItemHandle,     line0, line1, line2, ProcType, SetModifyNotificationProc, StringEditProc,     StringItem, ToggleFlag, ToggleVisibility],  Heap USING [systemZone],  Profile USING [    debugging, GetDefaultDomain, GetDefaultOrganization,     GetDefaultRegistry, GetLibrarian, GetLibrarianNames,    GetUser, SetDebugging, SetDefaultDomain, SetDefaultOrganization,    SetDefaultRegistry, SetLibrarian, SetUser],  String USING [CopyToNewString, EquivalentString, Replace],  Supervisor USING [    AddDependency, AgentProcedure, CreateSubsystem, RemoveDependency,    SubsystemHandle],  Tool USING [Create, MakeFormSW, MakeSWsProc],  ToolDriver USING [Address, NoteSWs, RemoveSWs],  ToolWindow USING [TransitionProcType],  Window USING [Handle],  WindowFont USING [CharWidth];      ProfileTool: PROGRAM   IMPORTS     Event, ExecUtilities, FormSW, Heap, Profile, String,     Supervisor, Tool, ToolDriver, WindowFont =  BEGIN    z: UNCOUNTED ZONE = Heap.systemZone;  ProfileItem: TYPE = {    apply, user, password, registry, abort, domain, organization, debug, librarian,     prefix, suffix}; -- if the positions of apply  and abort change, you must edit ToggleCommands    dirty: PACKED ARRAY ProfileItem OF BOOLEAN ¬ ALL[FALSE];     HideCommands: PROCEDURE [sw: Window.Handle] = INLINE {     FOR i: CARDINAL IN [ORD[ProfileItem.apply]..ORD[ProfileItem.suffix]] DO       IF dirty[VAL[i]] THEN FormSW.ToggleFlag[sw, i, modified];       dirty[VAL[i]] ¬ FALSE;       ENDLOOP;      FormSW.ToggleVisibility[sw, ORD[ProfileItem.abort]];     FormSW.ToggleVisibility[sw, ORD[ProfileItem.apply]];     commandsShowing ¬ FALSE};   ProfileFields: TYPE = RECORD [    userName: LONG STRING ¬ NIL,    userPassword: LONG STRING ¬ NIL,    domain: LONG STRING ¬ NIL,    organization: LONG STRING ¬ NIL,    registry: LONG STRING ¬ NIL,    librarianName: LONG STRING ¬ NIL,    librarianNamePrefix: LONG STRING ¬ NIL,    librarianNameSuffix: LONG STRING ¬ NIL];      ProfileData: TYPE = RECORD [    formSW: Window.Handle ¬ NIL,    debugging: BOOLEAN ¬ NULL,    strings: ARRAY ProfileItem OF LONG STRING ¬ ALL[NIL],    busy: BOOLEAN ¬ FALSE];    agent: Supervisor.SubsystemHandle = Supervisor.CreateSubsystem[Notify];  window: Window.Handle ¬ NIL;  data: LONG POINTER TO ProfileData ¬ NIL;    profileInfo: ProfileFields ¬ [];  GetUser: PROCEDURE [name, password: LONG STRING] = {    profileInfo.userName ¬ String.CopyToNewString[name, z];    profileInfo.userPassword ¬ String.CopyToNewString[password, z]};  GetDefaultDomain: PROCEDURE[domain: LONG STRING] = {    profileInfo.domain ¬ String.CopyToNewString[domain, z]};  GetDefaultOrganization: PROCEDURE[organization: LONG STRING] = {    profileInfo.organization ¬ String.CopyToNewString[organization, z]};  GetDefaultRegistry: PROCEDURE[registry: LONG STRING] = {    profileInfo.registry ¬ String.CopyToNewString[registry, z]};  GetLibrarian: PROCEDURE [librarian: LONG STRING] = {    profileInfo.librarianName ¬ String.CopyToNewString[librarian, z]};  GetLibrarianNames: PROCEDURE [prefix, suffix: LONG STRING] = {    profileInfo.librarianNamePrefix ¬ String.CopyToNewString[prefix, z];    profileInfo.librarianNameSuffix ¬ String.CopyToNewString[suffix, z]};  GetProfileInfo: PROCEDURE = {    Profile.GetUser[GetUser];    Profile.GetDefaultDomain[GetDefaultDomain];    Profile.GetDefaultOrganization[GetDefaultOrganization];    Profile.GetDefaultRegistry[GetDefaultRegistry];    Profile.GetLibrarianNames[GetLibrarianNames];    Profile.GetLibrarian[GetLibrarian]};  FreeProfileInfo: PROCEDURE = {    z.FREE[@profileInfo.userName]; profileInfo.userName ¬ NIL;     z.FREE[@profileInfo.userPassword]; profileInfo.userPassword ¬ NIL;    z.FREE[@profileInfo.domain]; profileInfo.domain ¬ NIL;         z.FREE[@profileInfo.organization]; profileInfo.organization ¬ NIL;         z.FREE[@profileInfo.registry]; profileInfo.registry ¬ NIL;    z.FREE[@profileInfo.librarianName]; profileInfo.librarianName ¬ NIL;    z.FREE[@profileInfo.librarianNamePrefix];     profileInfo.librarianNamePrefix ¬ NIL;    z.FREE[@profileInfo.librarianNameSuffix];     profileInfo.librarianNameSuffix ¬ NIL};    DataChanged: FormSW.ProcType = {    dirty[VAL[index]] ¬ TRUE;    IF ~commandsShowing THEN {      FormSW.FindItem[sw, ORD[ProfileItem.abort]].flags.invisible ¬ FALSE;      FormSW.FindItem[sw, ORD[ProfileItem.apply]].flags.invisible ¬ FALSE;      FormSW.Display[sw]};    commandsShowing ¬ TRUE};      commandsShowing: BOOLEAN ¬ FALSE;   -- since everything is done in the Notifier, no monitor is needed to protect this boolean    Abort: FormSW.ProcType = {    ResetData[display: TRUE]; HideCommands[sw]};    Apply: FormSW.ProcType = {    ENABLE  UNWIND => FreeProfileInfo[];    IF data = NIL THEN RETURN;    data.busy ¬ TRUE;    GetProfileInfo[];    IF ~Equal[profileInfo.userName, user] OR      ~Equal[profileInfo.userPassword, password] THEN UpdatePrimary[];    IF data.debugging # Profile.debugging THEN      Profile.SetDebugging[data.debugging];    IF ~Equal[profileInfo.domain, domain] THEN {       Profile.SetDefaultDomain[data.strings[domain]];      UpdatePrimary[]};    IF ~Equal[profileInfo.organization, organization] THEN {       Profile.SetDefaultOrganization[data.strings[organization]];      UpdatePrimary[]};    IF ~Equal[profileInfo.registry, registry] THEN       Profile.SetDefaultRegistry[data.strings[registry]];    IF ~Equal[profileInfo.librarianName, librarian] OR      ~Equal[profileInfo.librarianNamePrefix, prefix] OR      ~Equal[profileInfo.librarianNameSuffix, suffix] THEN UpdateLibrarian[];    FreeProfileInfo[];    HideCommands[sw];    data.busy ¬ FALSE};    UpdatePrimary: PROC = {    Profile.SetUser[data.strings[user], data.strings[password]]};        UpdateLibrarian: PROC = {    Profile.SetLibrarian[      data.strings[librarian], data.strings[prefix], data.strings[suffix]]};        ResetData: PROC [display: BOOLEAN] =     BEGIN    ENABLE UNWIND => FreeProfileInfo[];    IF data = NIL OR data.busy THEN RETURN;    GetProfileInfo[];    Update[profileInfo.userName, user, display];    Update[profileInfo.userPassword, password, display];    Update[profileInfo.registry, registry, display];    Update[profileInfo.domain, domain, display];    Update[profileInfo.organization, organization, display];    Update[profileInfo.librarianName, librarian, display];    Update[profileInfo.librarianNamePrefix, prefix, display];    Update[profileInfo.librarianNameSuffix, suffix, display];    IF data.debugging # Profile.debugging THEN {      data.debugging ¬ Profile.debugging;      IF display THEN FormSW.DisplayItem[        data.formSW, ORD[ProfileItem.debug]]};    FreeProfileInfo[];    END;    Equal: PROC [s: LONG STRING, index: ProfileItem] RETURNS [BOOLEAN] = {    RETURN[String.EquivalentString[data.strings[index], s]]};        Update: PROC [profile: LONG STRING, index: ProfileItem, display: BOOLEAN] = {    IF Equal[profile, index] THEN RETURN;    String.Replace[@data.strings[index], profile, z];    IF display THEN FormSW.DisplayItem[data.formSW, ORD[index]]};   -- call proc only when I get the events I am interested in. Else I may  -- get into a monitor lock.  Notify: Supervisor.AgentProcedure = {     IF (event IN EventTypes.TajoDefaultEvents) OR (event IN EventTypes.CredentialEvents) THEN     ResetData[display: TRUE]       };      Transition: ToolWindow.TransitionProcType = {    IF new # inactive OR data = NIL THEN RETURN;    Heap.systemZone.FREE[@data];    Supervisor.RemoveDependency[      client: agent, implementor: Event.primaryCredentials];    Supervisor.RemoveDependency[client: agent, implementor: Event.tajoDefaults];    ToolDriver.RemoveSWs["ProfileTool"L];};      MakeForm: FormSW.ClientItemsProcType =    BEGIN OPEN FormSW;    sp: CARDINAL = WindowFont.CharWidth[Ascii.SP];    nItems: CARDINAL = ORD[ProfileItem.LAST] + 1;    handle: LONG POINTER TO ARRAY ProfileItem OF FormSW.ItemHandle;    items ¬ AllocateItemDescriptor[nItems]; freeDesc ¬ TRUE;    handle ¬ LOOPHOLE[BASE[items]];    handle­ ¬ [       apply: CommandItem[tag: "Apply"L, place: [1*sp, line0], proc: Apply,       invisible: TRUE],     user: StringItem[        tag: "User"L, place: [10*sp,line0], string: @data.strings[user], 	inHeap: TRUE],      password: StringItem[        tag: "Password"L, place: [30*sp,line0], string: @data.strings[password],      	feedback: password, inHeap: TRUE],      registry: StringItem[        tag: "Registry"L, place: [60*sp,line0], string: @data.strings[registry],	inHeap: TRUE],      abort: CommandItem[tag: "Abort"L, place: [1*sp, line1], proc: Abort,        invisible: TRUE],      domain: StringItem[        tag: "Domain"L, place: [10*sp,line1], 	string: @data.strings[domain], inHeap: TRUE],      organization: StringItem[        tag: "Organization"L, place: [30*sp,line1], 	string: @data.strings[organization], inHeap: TRUE],      debug: BooleanItem[        tag: "Debugging"L, place: [60*sp, line1], switch: @data.debugging],      librarian: StringItem[        tag: "Librarian"L, place: [10*sp,line2], string: @data.strings[librarian], 	inHeap: TRUE],      prefix: StringItem[        tag: "Prefix"L, place: [30*sp,line2], string: @data.strings[prefix],      	inHeap: TRUE],      suffix: StringItem[        tag: "Suffix"L, place: [60*sp,line2], string: @data.strings[suffix],	inHeap: TRUE]];    END;      MakeSWs: Tool.MakeSWsProc = {    addresses: ARRAY [0..1) OF ToolDriver.Address;    data ¬ Heap.systemZone.NEW[ProfileData];    ResetData[display: FALSE];    Supervisor.AddDependency[client:agent, implementor:Event.primaryCredentials];    Supervisor.AddDependency[client:agent, implementor:Event.tajoDefaults];    data.formSW ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    FormSW.SetModifyNotificationProc[data.formSW, DataChanged];    addresses ¬ [["formSW"L, data.formSW]];    ToolDriver.NoteSWs["ProfileTool"L, DESCRIPTOR[addresses]];};  Init: PROCEDURE = {    window ¬ Tool.Create[      makeSWsProc: MakeSWs, name: "Profile Tool"L, clientTransition: Transition,      initialBox: [[0,32], [500, 70]],      cmSection: "ProfileTool"L];     IF ExecUtilities.profileToolWindow = NIL THEN       ExecUtilities.profileToolWindow ¬ window};    -- Mainline code    Init[];    END.Change log14-Mar-85 10:06:39	DSC  	Changed Notify to screen out AtomicProfile changes by limiting it to the right class. Without it, there will be a monitor lock with atomic profile (called within ProfilesA) generating tajoDefaults which in turn triggers a ProfileTool which in turn calls ProfilesA.   
-- File: CascadeNub.mesa - last edit:-- Riggle.PA            8-Aug-86 16:10:17-- Copyright (C) 1982, 1983, 1984 , 1986 by Xerox Corporation. All rights reserved. -- File: CascadeNub.mesa - last edited by-- RXR   :          23-May-83 12:06:07-- LXR    	    29-Dec-83 12:13:00-- JGS on	     3-Dec-82 15:25:41-- RXJ     	    21-Feb-83 19:51:57-- BGY     	    17-Aug-83 14:07:25-- AXD    	    21-Dec-83 15:07:06-- BJD    	    28-Aug-84 10:19:28-- DWR    	    21-Aug-85 12:12:48DIRECTORY  Ascii USING [NUL],  Environment USING [Block, bytesPerWord],  ExecInternal USING [codeLinks],  File USING [File, Error, ID, nullFile, Unknown],  FileStream USING [Create, InvalidHandle, InvalidOperation],  Heap USING [systemZone],  HeraldWindow USING [AppendBrokenMessage],  MesaDEFileTypes USING [tCascadeNub],  MFile USING [    Acquire, Copy, dontRelease, Error, GetProperties, GetTimes, Handle,    InitializeFileSystem, maxNameLength, Release],  MLoader USING [Error, Handle, Load, Start, VersionMismatch],  MScavenge USING [StartingScavenge],  PilotClient USING [],  ProcessorFace USING [SetMP],  Profile USING [GetDefaultDomain, initialToolStateDefault],  Runtime USING [CallDebugger, IsBound],  SpecialFile USING [MakeTemporary],  SpecialMFile USING [AcquireID, GetCapaWithAccess],  SpecialVolume USING [OpenVolume],  Stream USING [Handle, GetBlock, GetChar],  String,  TajoOps,  Time USING [Packed],  Token USING [FreeTokenString, GetCharProcType, Handle, Item, Object],  ToolWindow USING [State],  Volume USING [    Close, GetLabelString, ID, LookUpRootFile, maxNameLength, NotOpen,    nullID, RemoveRootFile, RootDirectoryError, systemID, Unknown];CascadeNub: PROGRAM  IMPORTS    ExecInternal, File, FileStream, Heap, HeraldWindow, MFile, MLoader,     MScavenge, ProcessorFace, Profile, Runtime, SpecialFile,     SpecialMFile, SpecialVolume, Stream, String,     TajoOps, Token, Volume  EXPORTS PilotClient, TajoOps =  BEGIN  -- this is referenced by some init code below (call to GetToolDefault)  inTestbed: BOOLEAN =    ~Runtime.IsBound[LOOPHOLE[TajoOps.SetInitialToolStateDefault]];  ErrorCode: TYPE = {notOnRemote, cantCopy, notOnLocal};  GetCharProc: TYPE = PROCEDURE RETURNS [c: CHARACTER, stop: BOOLEAN];  When: TYPE = {before, after};  CopyMode: TYPE = {always, notSame, never};  LoadOptions: TYPE = RECORD[    copy: CopyMode ¬ notSame,    toolState: ToolWindow.State ¬ GetToolDefault[],    load, start: BOOLEAN ¬ TRUE,    codeLinks: BOOLEAN ¬ inTestbed OR ExecInternal.codeLinks,    debug, readFilename, ignoreVersionMM: BOOLEAN ¬ FALSE];      SwitchType: TYPE = {local, global};    z: UNCOUNTED ZONE = Heap.systemZone;  commandVolumeName: LONG STRING = [Volume.maxNameLength];  commandVolumeID: Volume.ID ¬ Volume.nullID;  myVolumeName: LONG STRING = [Volume.maxNameLength];  myVolumeID: Volume.ID ¬ Volume.systemID;  commandVolumeOpen: BOOLEAN ¬ FALSE;  options, globalOptions: LoadOptions;        oldState: ToolWindow.State;  CantFindFile: SIGNAL = CODE;  CantCopyFile: SIGNAL = CODE;  NoCommandVolume: ERROR = CODE;  ChangeITDS: PROCEDURE [when: When] =    BEGIN    oldState ¬ GetToolDefault[];    SetToolDefault[IF when = before THEN options.toolState ELSE oldState];    END;    GetToolDefault: PROCEDURE RETURNS [ToolWindow.State] =    BEGIN    RETURN[      IF inTestbed OR ~Runtime.IsBound[LOOPHOLE[Profile.GetDefaultDomain]] THEN inactive       ELSE Profile.initialToolStateDefault];    END;    SetToolDefault: PROCEDURE [state: ToolWindow.State] =    {IF ~inTestbed THEN TajoOps.SetInitialToolStateDefault[state]     ELSE IF Runtime.IsBound[LOOPHOLE[TajoOps.SetInitialToolStateDefault]] THEN     TajoOps.SetInitialToolStateDefault[inactive]};    AppendVolumeAndID: PROCEDURE [s: LONG STRING, file: File.File] =    BEGIN    idRep: RECORD [a,b: CARDINAL] = LOOPHOLE[file.fileID];    volumeLabel: STRING ¬ [Volume.maxNameLength];    Volume.GetLabelString[file.volumeID, volumeLabel];    String.AppendChar[s, '<];    String.AppendString[s, volumeLabel];    String.AppendChar[s, '>];    String.AppendChar[s, '[];    String.AppendOctal[s, idRep.a];    String.AppendString[s, ", "L];    String.AppendOctal[s, idRep.b];    String.AppendChar[s, ']];    END;      GetNameAndDisplayMessage: PROC[    fh: MFile.Handle, myFile: File.File, msg: LONG STRING,    showLocally: BOOLEAN ¬ FALSE, showRemote: BOOLEAN ¬ TRUE] = {    firstPart: LONG STRING ¬ z.NEW[StringBody [MFile.maxNameLength+100]];    doRelease: BOOLEAN ¬ FALSE;        {ENABLE UNWIND => z.FREE[@firstPart];    IF fh = NIL THEN {      fh ¬ SpecialMFile.AcquireID[        myFile, readOnly, MFile.dontRelease   !       MFile.Error => CONTINUE];       doRelease ¬ TRUE};    IF fh = NIL THEN AppendVolumeAndID[s: firstPart, file: myFile]     ELSE [] ¬ MFile.GetProperties[fh, firstPart ! MFile.Error =>        {AppendVolumeAndID[s: firstPart, file: myFile]; CONTINUE}];    IF showLocally AND ~inTestbed AND        Runtime.IsBound[LOOPHOLE[HeraldWindow.AppendBrokenMessage]] THEN        HeraldWindow.AppendBrokenMessage[msg1: firstPart, msg2: msg,         newLine: TRUE, clearOld: FALSE];    IF showRemote THEN NubMessage[tail: msg, prelude: firstPart]};    z.FREE[@firstPart];    IF fh # NIL AND doRelease THEN MFile.Release[fh]};  MyGetStream: PROCEDURE RETURNS [sh: Stream.Handle] =     BEGIN    {ENABLE       File.Unknown, File.Error, Volume.Unknown, Volume.NotOpen,      Volume.RootDirectoryError, FileStream.InvalidHandle,      FileStream.InvalidOperation => GOTO done;    file: File.File ¬ File.nullFile;    file ¬ Volume.LookUpRootFile[      MesaDEFileTypes.tCascadeNub, myVolumeID];    SpecialFile.MakeTemporary[file       ! File.Unknown, Volume.Unknown, Volume.NotOpen => CONTINUE];    Volume.RemoveRootFile[MesaDEFileTypes.tCascadeNub, myVolumeID];    IF file # File.nullFile THEN sh ¬ FileStream.Create[file]    ELSE sh ¬ NIL};    EXITS done => sh ¬ NIL;    END;          LoadBcds: PROCEDURE =    BEGIN    sh: Stream.Handle ¬ NIL;    index: LONG CARDINAL ¬ Environment.bytesPerWord*SIZE[Volume.ID];    tokenObject: Token.Object;    Cleanup: PROCEDURE = {      CloseCommandVolume[];      IF sh # NIL THEN sh.delete[sh]};    nextChar: PROCEDURE[h: Token.Handle] RETURNS [c: CHARACTER] = {      DO        c ¬ Stream.GetChar[sh]; index ¬ index + 1; 	IF c = '( THEN  options.readFilename ¬ TRUE        ELSE {	  IF c = ') THEN c ¬ Ascii.NUL; --') signifies end of file	  EXIT};	ENDLOOP};    sh ¬ MyGetStream[];    IF sh # NIL THEN {  -- booted from CommandCentral       ENABLE UNWIND => Cleanup[];      LocateCommandVolume[sh];      OpenCommandVolume[];      tokenObject ¬ [getChar: nextChar];      ProcessArg[tokenObject];      Cleanup[]};     END;      FindSlash: PROCEDURE[switches: LONG STRING] RETURNS[pos: CARDINAL] = {    i: CARDINAL ¬ 0;    FOR i IN [0..switches.length) DO      IF switches[i] = '/ THEN RETURN[i]; ENDLOOP;    RETURN[switches.length]};      ProcessSwitches: PROCEDURE[      token: LONG STRING, whichSwitch: SwitchType] = {    sense: BOOLEAN ¬ TRUE;    FOR index: CARDINAL IN [0..token.length) DO      char: CHARACTER ¬ token[index];      IF char IN ['A..'Z] THEN char ¬ char + ('a - 'A);      SELECT char FROM        '/ => NULL;        '-, '~ => {sense ¬ ~sense; LOOP};        'a => IF ~inTestbed THEN options.toolState ¬ active;        'c => options.copy ¬ IF sense THEN always ELSE never;        'd => options.debug ¬ sense;        'e => options.load ¬ sense; -- e => "executable"	'i => options.toolState ¬ inactive;        'l => options.codeLinks ¬ sense;        's => options.start ¬ sense;	't => IF ~inTestbed THEN options.toolState ¬ tiny;	'v => options.ignoreVersionMM ¬ sense;         ENDCASE =>           BEGIN	   msg: STRING ¬ [1];	   String.AppendChar[msg, char];	   NubMessage["is an illegal switch"L, msg];	   END;      sense ¬ TRUE;      ENDLOOP;    IF whichSwitch = global THEN globalOptions ¬ options};  SeparateLocalSwitches: PROC[token: LONG STRING] = {    switches: LONG STRING ¬ NIL;     slashPos: CARDINAL ¬ FindSlash[token];    IF slashPos = token.length THEN RETURN; -- no switches    switches ¬ z.NEW[StringBody [token.length - slashPos]];    FOR i: CARDINAL IN [slashPos..token.length) DO      String.AppendChar[switches, token[i]         ! UNWIND => z.FREE[@switches]];       ENDLOOP;    ProcessSwitches[switches, local ! UNWIND => z.FREE[@switches]];    z.FREE[@switches];    token.length ¬ slashPos};	    GetLoadee: PROC[tokenObject: Token.Object]     RETURNS [found: BOOLEAN, file: File.File] =    BEGIN    gotIt: BOOLEAN ¬ FALSE;    loadee: LONG STRING ¬ NIL;    fh: MFile.Handle ¬ NIL;    Seven: TYPE =  RECORD [a, b, c, d, e, f, g: UNSPECIFIED];    fileInfo: POINTER TO Seven = @LOOPHOLE[file, Seven];        {ENABLE UNWIND => {[] ¬ Token.FreeTokenString[loadee]};    options ¬ globalOptions;  -- re-intitialize local switches    DO      loadee ¬ Token.Item[@tokenObject];      IF (loadee = NIL) OR (loadee.length = 0) THEN RETURN[FALSE, File.nullFile];      IF loadee[0] = '/ THEN {        ProcessSwitches[loadee, global];         loadee ¬ Token.FreeTokenString[loadee]}      ELSE { --Get file ID and volume ID         gotIt ¬ TRUE;        IF options.readFilename THEN {          SeparateLocalSwitches[loadee];          [] ¬ String.AppendExtensionIfNeeded[@loadee, ".bcd"L, z];          fh ¬ MFile.Acquire[loadee, anchor, MFile.dontRelease !            MFile.Error => Cough["cannot be opened."L, loadee]];	  loadee ¬ Token.FreeTokenString[loadee];          file ¬ SpecialMFile.GetCapaWithAccess[fh]}	ELSE {	  fileInfo.a ¬ String.StringToOctal[loadee];	  loadee ¬ Token.FreeTokenString[loadee];	  loadee ¬ Token.Item[@tokenObject];	  fileInfo.b ¬ String.StringToOctal[loadee];	  loadee ¬ Token.FreeTokenString[loadee];	  loadee ¬ Token.Item[@tokenObject];	  fileInfo.c ¬ String.StringToOctal[loadee];	  loadee ¬ Token.FreeTokenString[loadee];	  loadee ¬ Token.Item[@tokenObject];	  fileInfo.d ¬ String.StringToOctal[loadee];	  loadee ¬ Token.FreeTokenString[loadee];	  loadee ¬ Token.Item[@tokenObject];	  fileInfo.e ¬ String.StringToOctal[loadee];	  loadee ¬ Token.FreeTokenString[loadee];	  loadee ¬ Token.Item[@tokenObject];	  fileInfo.f ¬ String.StringToOctal[loadee];	  loadee ¬ Token.FreeTokenString[loadee];	  loadee ¬ Token.Item[@tokenObject];          SeparateLocalSwitches[loadee];	  fileInfo.g ¬ String.StringToOctal[loadee];	  loadee ¬ Token.FreeTokenString[loadee]}};      IF gotIt THEN EXIT;      ENDLOOP};    RETURN[TRUE, file];    END;      ProcessArg: PROCEDURE [tokenObject: Token.Object] =    BEGIN    fh: MFile.Handle ¬ NIL;    file: File.File ¬ File.nullFile;    more: BOOLEAN;         {ENABLE UNWIND =>         IF fh # NIL THEN MFile.Release[fh];    DO       fh ¬ NIL;      options.readFilename ¬ FALSE;      [more,file] ¬ GetLoadee[tokenObject];      IF ~more THEN EXIT;            IF options.copy # never AND ~options.readFilename THEN	fh ¬ CopyFile[file, options.copy=always ! 	  CantFindFile => {	    GetNameAndDisplayMessage[	      NIL, file, 	      "not on remote volume. Proceeding will skip this file. "L]; 	    LOOP};	  CantCopyFile => {	    GetNameAndDisplayMessage[	      NIL, file, 	      "cannot be copied. Proceeding will skip this file. "L]; 	    LOOP}]      ELSE fh ¬ GetFileFromLocalVolume[file !         CantFindFile => {	    GetNameAndDisplayMessage[	      NIL, file, 	      "can't be found on local volume. Proceeding will skip this file. "L]; 	    LOOP}];      IF options.load THEN	BEGIN	prog: MLoader.Handle;	misMatched: BOOLEAN ¬ FALSE;		prog ¬ MLoader.Load[fh, [options.codeLinks] ! 	  MLoader.Error => {	    GetNameAndDisplayMessage[fh, file, 	      SELECT code FROM	        badCode => "either isn't a BCD or was compiled /A."L,	        invalidParameters => "is not a valid, current-version bcd"L,	        missingCode => "wasn't bound with code copying."L,	        exportedTypeClash => "has an exported type clash."L,	        gftFull => "can't be loaded because the MDS is full."L,	        loadStateFull => "can't be loaded because the loadstate is full."L,	        ENDCASE => "can't be loaded for some unknown reason."L];	    MFile.Release[fh];	    LOOP};          MLoader.VersionMismatch  => {	    text: STRING = "has an interface version mismatch in interface "L;	    msg: LONG STRING;	    IF options.ignoreVersionMM THEN RESUME;	    msg ¬ z.NEW[StringBody [module.length + text.length]];	    String.AppendString[to: msg, from: text];	    String.AppendString[to: msg, from: module];	    misMatched ¬ TRUE;            GetNameAndDisplayMessage[	      fh, file, msg ! UNWIND => z.FREE[@msg]];            z.FREE[@msg];	    RESUME}];	GetNameAndDisplayMessage[	  fh: fh, myFile: file, msg: " loaded."L, showLocally: TRUE,	  showRemote: options.debug];	IF (options.start) AND (prog # NIL) AND	   (~misMatched OR options.ignoreVersionMM) THEN	  BEGIN	  ChangeITDS[before];	  MLoader.Start[prog];	  GetNameAndDisplayMessage[	    fh: fh, myFile: file, msg: " started."L, showLocally: TRUE,	    showRemote: FALSE];	  ChangeITDS[after];	  END;	END	ELSE IF fh # NIL THEN MFile.Release[fh]; --if not loading don't need fh     ENDLOOP};    END;    LocateCommandVolume : PROCEDURE [sh: Stream.Handle] = -- INLINE --    BEGIN    block: Environment.Block ¬ [      LOOPHOLE[@commandVolumeID], 0,        Environment.bytesPerWord*SIZE[Volume.ID]];    howMany: CARDINAL;    [howMany, ,] ¬ Stream.GetBlock[sh, block];    IF howMany = 0 THEN ERROR NoCommandVolume;    commandVolumeName.length ¬ 0;    Volume.GetLabelString[commandVolumeID, commandVolumeName];    END;  OpenCommandVolume: PROCEDURE =    BEGIN    IF ~commandVolumeOpen THEN      BEGIN      SpecialVolume.OpenVolume[volume: commandVolumeID, access: read];      commandVolumeOpen ¬ TRUE;      END;    END;  CloseCommandVolume: PROCEDURE =    BEGIN    IF commandVolumeOpen THEN {      Volume.Close[commandVolumeID]; commandVolumeOpen ¬ FALSE};    END;  MakeFileName: PROCEDURE [commandVolumeName: STRING, name: LONG STRING] RETURNS       [fileName: LONG STRING] =    BEGIN    fnLength: CARDINAL =       String.StringLength[commandVolumeName]+String.StringLength[name] + 6;    fileName ¬ z.NEW[StringBody [fnLength]];  --leave room for possible ".bcd" and <>    String.AppendChar[fileName, '<];    String.AppendString[fileName, commandVolumeName];    String.AppendChar[fileName, '>];    String.AppendString[fileName, name];    [] ¬ String.AppendExtensionIfNeeded[@fileName, ".bcd"L, z];    END;  CopyFile: PROCEDURE [file: File.File, forcedCopy: BOOLEAN]      RETURNS [fileHandle: MFile.Handle] =     BEGIN    remote, local: MFile.Handle ¬ NIL;    name: LONG STRING ¬ z.NEW[StringBody [MFile.maxNameLength]];    oldCreate, newCreate: Time.Packed;    Cleanup: PROCEDURE = {      IF remote # NIL THEN MFile.Release[remote];       IF local # NIL THEN MFile.Release[local];       z.FREE[@name]};        BEGIN ENABLE UNWIND => Cleanup[];    OpenCommandVolume[];    remote ¬ SpecialMFile.AcquireID[      file, readOnly, MFile.dontRelease  !       MFile.Error => SIGNAL CantFindFile];     [create: newCreate] ¬ MFile.GetProperties[remote, name       ! MFile.Error => SIGNAL CantFindFile];    [] ¬ String.AppendExtensionIfNeeded[@name, ".bcd"L, z]; -- Get local name         IF ~forcedCopy THEN {      -- See if we can use the local copy (okay if it's same as the remote one)      local ¬ MFile.Acquire[name, readOnly, MFile.dontRelease !        MFile.Error => GOTO notThere];  -- Can't get local file handle      [create: oldCreate] ¬ MFile.GetTimes[local];      IF  oldCreate # newCreate THEN {MFile.Release[local]; local ¬ NIL}       ELSE {        z.FREE[@name];        MFile.Release[remote];        RETURN[local]} -- use local copy      EXITS notThere => NULL};          MFile.Copy[remote, name ! MFile.Error => SIGNAL CantCopyFile];    local ¬ MFile.Acquire[name, readOnly, MFile.dontRelease !        MFile.Error => SIGNAL CantFindFile]    END;    z.FREE[@name];    MFile.Release[remote];      RETURN[local];    END;  GetFileFromLocalVolume: PROCEDURE [file: File.File]       RETURNS[fh: MFile.Handle ¬ NIL] = INLINE    BEGIN    fh ¬ SpecialMFile.AcquireID[      file, readOnly, MFile.dontRelease        ! MFile.Error => SIGNAL CantFindFile];    END;  NubMessage: PROCEDURE [tail: LONG STRING, prelude: LONG STRING ¬ NIL] =    BEGIN    msg: LONG STRING ¬      z.NEW[StringBody [String.StringLength[tail] +       String.StringLength[prelude]+15]];    String.AppendStringAndGrow[@msg, "Nub: "L, z];     IF prelude # NIL THEN {      String.AppendChar[msg, '"];      String.AppendString[to: msg, from: prelude];      String.AppendString[to: msg, from: """ "L]};    String.AppendString[to: msg, from: tail];     Runtime.CallDebugger[msg];    z.FREE[@msg];    END;  Cough: PROCEDURE [complaint: LONG STRING, prelude: LONG STRING ¬ NIL] =    BEGIN    NubMessage[complaint, prelude];    DO NubMessage["The last error was fatal. Client cannot be resumed."L]; ENDLOOP;    END;  -- Mainline code --  Run: PUBLIC PROCEDURE = {}; -- start trap in the TestBed    RunCascadeNub: PUBLIC PROCEDURE = {};  -- start trap in the boot file    Volume.GetLabelString[myVolumeID, myVolumeName];  IF inTestbed THEN  {     ENABLE MScavenge.StartingScavenge => {        -- start trap of FileSystem may raise this signal        ProcessorFace.SetMP[9950]; RESUME};      MFile.InitializeFileSystem[];      ProcessorFace.SetMP[990]};   LoadBcds[!      CantFindFile =>        IF inTestbed THEN Cough["Cant find command file. "L] ELSE CONTINUE;     NoCommandVolume => CONTINUE];  END.
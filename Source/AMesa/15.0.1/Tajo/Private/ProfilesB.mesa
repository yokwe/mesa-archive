-- Copyright (C) 1981, 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- File: ProfilesB.mesa - last edited by:-- PXK    ,	25-Jan-83 21:44:33-- SXW   ,	12-Jul-81 14:16:53-- BXM  ,	12-Nov-81 17:37:29-- Mark,	23-Jun-81 17:52:03-- JGS,		18-Aug-81 15:01:28-- LXR    ,	 1-Nov-83 14:16:18-- SXS   ,	17-Mar-82 15:20:41-- RXR   ,	 2-Mar-82 10:50:09-- RXJ     ,	23-Mar-82 17:20:19-- AXD    ,	19-Jul-83 19:10:34-- CXH   ,	24-Feb-83 11:46:11-- BGY     ,	15-Apr-83 14:23:31-- BJD    ,	 8-Nov-84 11:36:21-- DWR    	19-Feb-85 13:57:36DIRECTORY  CmFile USING [    Close, Error, FindSection, Handle, NextValue, TableError, UserDotCmOpen],  Event USING [aboutToSwap, swapping],  EventTypes USING [    abortSession, aboutToAbortSession, aboutToBoot, aboutToBootPhysicalVolume,     aboutToResume, bootPhysicalVolumeCancelled,    newSession, resumeDebuggee, resumeSession, swapCancelled],  Exec USING [CheckAbortProc, ProcessCommandLine],  ExecInternal USING [StringToSearchPath],  Format USING [CR, StringProc],  FileWindow: TYPE USING [Create, LoadWindow],  Heap: TYPE USING [systemZone],  HeraldWindow USING [AppendBrokenMessage, AppendMessage],  Menu USING [SetFont],  MFile USING [Error, Handle, ReadOnly, Release],  MStream USING [Error, Log],  Profile USING [    SetBalanceBeamChoice, SetDebugging, SetDefaultDomain, SetDefaultOrganization,    SetDefaultRegistry, SetFileServerProtocol, SetLibrarian, SetUser,    SetSwapCtrlAndCommand],  ProfileExtra USING [SetPositionBalanceBeamChoice, SetSetPositionBalanceBeamChoice, SetCaretShape, CaretShapes],  Runtime USING [IsBound],  Stream USING [Delete, Handle, PutBlock],  String USING [    AppendChar, AppendString, AppendStringAndGrow, CopyToNewString,     EmptyString, EquivalentString, Length],  StringLookUp USING [noMatch, TableDesc],  Supervisor USING [    AddDependency, AgentProcedure, CreateSubsystem, EnumerationAborted,    SubsystemHandle],  System USING [MicrosecondsToPulses, switches],  TIP USING [clickTimeout],  TajoMisc USING [StartClient],  TajoOps USING [SetInitialToolStateDefault],  TextSource USING [Error],  Token USING [    Boolean, FileName, Filtered, FilterProcType, FreeStringHandle,    FreeTokenString, Handle, Item, Line, LongDecimal, StandardFilterState,    StringToHandle, WindowBox],  ToolFont USING [Create],  ToolWindow USING [SetTinyPlace, WindowForSubwindow],  UserTerminal USING [SetBackground],  WindowFont USING [Error, Handle, SetDefault],  Window USING [Box, Handle, Place];ProfilesB: MONITOR  IMPORTS    CmFile, Event, Exec, ExecInternal, FileWindow, Format, Heap, HeraldWindow,    Menu, MFile, MStream, Profile, ProfileExtra, Runtime, String, Stream,     System, Supervisor, TextSource, TajoMisc, TajoOps, TIP, Token,    ToolFont, ToolWindow, UserTerminal, WindowFont  EXPORTS Event, TajoOps =  BEGIN  Handle: TYPE = LONG POINTER TO Object;  Object: PUBLIC TYPE = RECORD [process: LONG STRING, next: Handle];  list: Handle ¬ NIL;  init: LONG STRING ¬ NIL;  StartingProcess: PUBLIC ENTRY PROCEDURE [id: LONG STRING] RETURNS [Handle] = {    WHILE swapping DO WAIT swapDone ENDLOOP;    list ¬ Heap.systemZone.NEW[Object ¬ [NIL, list]];    list.process ¬ String.CopyToNewString[id, Heap.systemZone];    RETURN[list]};  DoneWithProcess: PUBLIC ENTRY PROCEDURE [h: Handle] = {    IF list = h THEN list ¬ list.next    ELSE FOR p: Handle ¬ list, p.next UNTIL p.next = NIL DO      IF h = p.next THEN {p.next ¬ h.next; EXIT};      REPEAT      FINISHED => RETURN;      ENDLOOP;    Heap.systemZone.FREE[@h.process];    Heap.systemZone.FREE[@h]};  swapDone: CONDITION;  swapping: BOOLEAN ¬ FALSE;  aboutToSwapAgent: Supervisor.SubsystemHandle = Supervisor.CreateSubsystem[    AboutToSwap];  swappingAgent: Supervisor.SubsystemHandle = Supervisor.CreateSubsystem[Swapping];  AboutToSwap: ENTRY Supervisor.AgentProcedure =    BEGIN    ENABLE UNWIND => NULL;    SELECT event FROM      EventTypes.aboutToAbortSession, EventTypes.aboutToResume,      EventTypes.aboutToBoot, EventTypes.aboutToBootPhysicalVolume => {        IF list # NIL THEN {          HeraldWindow.AppendMessage[	    msg: "Aborting swap: the following processes are busy: "L,	    newLine: TRUE,	    clearOld: TRUE];          FOR h: Handle ¬ list, h.next UNTIL h = NIL DO            HeraldWindow.AppendBrokenMessage[    	      msg1: h.process, msg2: " "L, newLine: FALSE, clearOld: FALSE];	    ENDLOOP;          HeraldWindow.AppendBrokenMessage[              msg1:"\n"L, newLine: FALSE, clearOld: FALSE];         ERROR Supervisor.EnumerationAborted};        swapping ¬ TRUE};      ENDCASE;      END;  Swapping: ENTRY Supervisor.AgentProcedure =    BEGIN    ENABLE UNWIND => NULL;    SELECT event FROM      EventTypes.newSession, EventTypes.resumeSession,       EventTypes.swapCancelled, EventTypes.bootPhysicalVolumeCancelled => {        swapping ¬ FALSE; BROADCAST swapDone};      EventTypes.abortSession, EventTypes.resumeDebuggee => swapping ¬ TRUE;      ENDCASE;    END;       ProcessUserCm: PUBLIC PROCEDURE =    BEGIN    init ¬ ProcessUserCmInternal[];  -- let CmFile.TableError go to control module    TajoOps.SetInitialToolStateDefault[inactive];    IF Runtime.IsBound[LOOPHOLE[TajoMisc.StartClient]]      THEN TajoMisc.StartClient[];    END;  ProcessInitialCommandLine: PUBLIC PROCEDURE [] =     BEGIN    stream: Stream.Handle ¬ NIL;    CheckAbort: Exec.CheckAbortProc = {RETURN[FALSE]};    WriteToLog: Format.StringProc = {      IF stream # NIL THEN        Stream.PutBlock[stream, [LOOPHOLE[@s.text], 0, s.length]]};    IF System.switches['N] = up THEN {      stream ¬ MStream.Log["Initial.Log"L, [] ! MStream.Error => CONTINUE];      [] ¬ Exec.ProcessCommandLine[        cmd: init, write: WriteToLog, checkAbort: CheckAbort];      IF stream # NIL THEN Stream.Delete[stream]};    TajoOps.SetInitialToolStateDefault[active];    Heap.systemZone.FREE[@init];    END;  CheckType: PROCEDURE [h: CmFile.Handle, table: StringLookUp.TableDesc]    RETURNS [index: CARDINAL] = CmFile.NextValue;  ProcessSystemSection: PROCEDURE [userCm: CmFile.Handle]    RETURNS [initialize: LONG STRING ¬ NIL] =    BEGIN    Option: TYPE = MACHINE DEPENDENT{      debug(0), screen, swapCtlAndCmd, font, menuFont, registry, userName,      clickTimeout, balanceBeam, fileWindow, background, domain, organization,      setPositionBalanceBeam, caretShape, initialize, searchPath, fsProtocol, noMatch(StringLookUp.noMatch)};    DefinedOption: TYPE = Option [debug..fsProtocol];    StringOption: TYPE = Option [font..searchPath];    LineOption: TYPE = StringOption [background..searchPath];    optionTable: ARRAY DefinedOption OF LONG STRING ¬ [      debug: "Debug"L, screen: "Screen"L, font: "Font"L,      initialize: "InitialCommand"L, menuFont: "MenuFont"L, registry: "Registry"L,      userName: "User"L, background: "Background",      domain: "Domain"L, organization: "Organization"L,      swapCtlAndCmd: "SwapControlAndCommand"L,      searchPath: "SearchPath"L, fsProtocol: "FileServerProtocol"L,      balanceBeam: "BalanceBeam"L, clickTimeout: "ClickTimeout"L,      setPositionBalanceBeam: "SetPositionBalanceBeam"L,      caretShape: "CaretShape"L,      fileWindow: "FileWindow"L];    strings: ARRAY StringOption OF LONG STRING ¬ ALL[NIL];    debug, swapCtl: BOOLEAN ¬ FALSE;    i: Option;    MyNextValue: PROCEDURE [      h: CmFile.Handle,      table: LONG DESCRIPTOR FOR ARRAY DefinedOption OF LONG STRING]      RETURNS [index: Option] = LOOPHOLE[CheckType];    DO ENABLE CmFile.TableError => RESUME;      SELECT (i ¬ MyNextValue[userCm, DESCRIPTOR[optionTable]]) FROM        noMatch => EXIT;        screen =>          BEGIN	  string: LONG STRING;          IF String.EquivalentString[string ¬ Token.Item[userCm], "Black"L] THEN            [] ¬ UserTerminal.SetBackground[black];          Heap.systemZone.FREE[@string];	  END;        balanceBeam =>          BEGIN          string: LONG STRING ¬ Token.Item[userCm];	  Profile.SetBalanceBeamChoice[	    SELECT TRUE FROM	      String.EquivalentString[string, "Never"L] => never,	      String.EquivalentString[string, "NotForCharacter"L] =>	        notForCharacter,	      ENDCASE => always];          Heap.systemZone.FREE[@string];          END;        setPositionBalanceBeam =>          BEGIN          string: LONG STRING ¬ Token.Item[userCm];	  ProfileExtra.SetSetPositionBalanceBeamChoice[	    SELECT TRUE FROM	      String.EquivalentString[string, "Top"L] => top,	      String.EquivalentString[string, "Middle"L] => middle,	      ENDCASE => topBottom];          Heap.systemZone.FREE[@string];          END;	caretShape =>	  BEGIN	  string: LONG STRING ¬ Token.Item[userCm];	  ProfileExtra.SetCaretShape[	    SELECT TRUE FROM	      String.EquivalentString[string, "IBeam"L] => iBeam,	      String.EquivalentString[string, "Triangle"L] => triangle,	      ENDCASE => triangle];          Heap.systemZone.FREE[@string];          END;        clickTimeout =>          BEGIN          milli: LONG INTEGER = Token.LongDecimal[userCm, FALSE];          IF milli > 0 THEN	    TIP.clickTimeout ¬ System.MicrosecondsToPulses[milli*1000];	  END;        fsProtocol =>          BEGIN	  string: LONG STRING;          IF String.EquivalentString[string ¬ Token.Item[userCm], "NS"L] THEN            [] ¬ Profile.SetFileServerProtocol[ns];          Heap.systemZone.FREE[@string];          END;        fileWindow =>          BEGIN	  sw, tool: Window.Handle;	  data: Token.StandardFilterState;	  string: LONG STRING ¬ Token.Filtered[userCm, NIL, Token.Line];          token: Token.Handle = Token.StringToHandle[string, 0];	  box: Window.Box ¬ Token.WindowBox[token];	  tinyPlace: Window.Place ¬ Token.WindowBox[token].place;	  file: LONG STRING ¬ Token.Filtered[token, @data, Token.FileName];	  tiny: BOOLEAN ¬ FALSE;          IF token.break = '/ THEN { -- maybe tiny	    char: CHARACTER = token.getChar[token];	    IF char = 't OR char = 'T THEN tiny ¬ TRUE};	  [] ¬ Token.FreeStringHandle[token];	  [] ¬ Token.FreeTokenString[string];	  IF box.dims.w < 60 THEN box.dims.w ¬ 512;	  IF box.dims.h < 30 THEN box.dims.h ¬ 400;	  sw ¬ FileWindow.Create[	    box: box, initialState: IF tiny THEN tiny ELSE active];	  IF file # NIL THEN FileWindow.LoadWindow[fileName: file, sw: sw !	    TextSource.Error => CONTINUE];	  [] ¬ Token.FreeTokenString[file];	  tool ¬ ToolWindow.WindowForSubwindow[sw];	  IF tinyPlace # [0, 0] THEN ToolWindow.SetTinyPlace[tool, tinyPlace];	  END;        swapCtlAndCmd => swapCtl ¬ Token.Boolean[userCm, FALSE];        debug => debug ¬ Token.Boolean[userCm, FALSE];        IN LineOption =>          BEGIN          Heap.systemZone.FREE[@strings[i]];          strings[i] ¬ Token.Filtered[userCm, NIL, Token.Line];          END;        IN StringOption =>  -- must be after LineOption          BEGIN          Heap.systemZone.FREE[@strings[i]];          strings[i] ¬ Token.Item[userCm];          END;        ENDCASE;      ENDLOOP;    initialize ¬ strings[initialize];    strings[initialize] ¬ NIL;    IF strings[background] # NIL THEN {      String.AppendStringAndGrow[        to: @initialize, from: "; Run.~ "L, z: Heap.systemZone];      String.AppendStringAndGrow[        to: @initialize, from: strings[background], z: Heap.systemZone]};    Profile.SetDefaultDomain[strings[domain]];    Profile.SetDefaultOrganization[strings[organization]];    Profile.SetDefaultRegistry[strings[registry]];    Profile.SetUser[strings[userName], ""L];    Profile.SetSwapCtrlAndCommand[swapCtl];    Profile.SetDebugging[debug];    LoadFonts[strings[font], strings[menuFont]];    SetSearchPath[strings[searchPath]];    FOR i IN StringOption DO Heap.systemZone.FREE[@strings[i]]; ENDLOOP;    END;  LoadFonts: PROCEDURE [name, menuName: LONG STRING] = {    file: MFile.Handle ¬ NIL;    font: WindowFont.Handle ¬ NIL;    IF name # NIL THEN {      file ¬ MFile.ReadOnly[name, [] ! MFile.Error => GOTO cantDoIt];      font ¬ ToolFont.Create[        file !        WindowFont.Error => {MFile.Release[file]; file ¬ NIL; GOTO cantDoIt}];      WindowFont.SetDefault[font];      EXITS cantDoIt => NULL};    IF menuName # NIL THEN {      file ¬ MFile.ReadOnly[menuName, [] ! MFile.Error => GOTO cantDoIt];      font ¬ ToolFont.Create[        file !        WindowFont.Error => {MFile.Release[file]; file ¬ NIL; GOTO cantDoIt}];      Menu.SetFont[font];      EXITS cantDoIt => NULL}    ELSE IF font # NIL THEN Menu.SetFont[font]};  SetSearchPath: PROCEDURE [cmdLine: LONG STRING] = {    Write: Format.StringProc = {HeraldWindow.AppendMessage[s]};    IF ~String.EmptyString[cmdLine] THEN {      Format.CR[Write];      [] ¬ ExecInternal.StringToSearchPath[cmdLine, Write]}};  ProcessLibrarianSection: PROCEDURE [userCm: CmFile.Handle] =    BEGIN    Option: TYPE = MACHINE DEPENDENT{      namePrefix(0), nameSuffix, server, noMatch(StringLookUp.noMatch)};    DefinedOption: TYPE = Option [namePrefix..server];    optionTable: ARRAY DefinedOption OF LONG STRING ¬ [      namePrefix: "NamePrefix"L, nameSuffix: "NameSuffix"L, server: "Server"L];    i: Option;    sawNameSuffix: BOOLEAN ¬ FALSE;    MyNextValue: PROCEDURE [      h: CmFile.Handle,      table: LONG DESCRIPTOR FOR ARRAY DefinedOption OF LONG STRING]      RETURNS [index: Option] = LOOPHOLE[CheckType];    DO ENABLE CmFile.TableError => RESUME;        i ¬ MyNextValue[        userCm, DESCRIPTOR[optionTable] ! CmFile.TableError => RESUME ];      SELECT i FROM        noMatch => EXIT;        namePrefix => {          string: LONG STRING ¬ Token.Filtered[userCm, NIL, Token.Line];          Profile.SetLibrarian[prefix: string];          Heap.systemZone.FREE[@string]};        nameSuffix => {          string: LONG STRING ¬ Token.Item[userCm];          IF String.Length[string] > 0 THEN {            suffix: LONG STRING ¬ Heap.systemZone.NEW[	      StringBody[string.length + 1]];            sawNameSuffix ¬ TRUE;            IF string[0] # '. THEN String.AppendChar[suffix, '.];            String.AppendString[suffix, string];            Profile.SetLibrarian[suffix: suffix];            Heap.systemZone.FREE[@suffix]};          Heap.systemZone.FREE[@string]};        server => {          string: LONG STRING ¬ Token.Item[userCm];          IF String.Length[string] > 0 THEN            Profile.SetLibrarian[name: string];          Heap.systemZone.FREE[@string]};        ENDCASE;      ENDLOOP;    END;  ProcessUserCmInternal: PUBLIC PROCEDURE    RETURNS [initialize: LONG STRING ¬ NIL] =    BEGIN    userCm: CmFile.Handle;    IF System.switches['N] = down THEN RETURN[NIL];    BEGIN    userCm ¬ CmFile.UserDotCmOpen[ ! CmFile.Error => GOTO NoUserDotCm];    IF CmFile.FindSection[userCm, "System"L] THEN      initialize ¬ ProcessSystemSection[userCm];    IF CmFile.FindSection[userCm, "Librarian"L] THEN      ProcessLibrarianSection[userCm];    [] ¬ CmFile.Close[userCm];    EXITS NoUserDotCm => NULL;    END;    END;  Init: PROCEDURE =    BEGIN    Supervisor.AddDependency[      client: aboutToSwapAgent, implementor: Event.aboutToSwap];    Supervisor.AddDependency[client: swappingAgent, implementor: Event.swapping];    END;	  Init[];    END.  -- of ProfilesBLOGDWR    	10-Jan-85 14:52:08  added setPositionBalanceBeamDWR    	18-Feb-85 14:24:20  added caretShape & fixed a bug in DoneWithProcess
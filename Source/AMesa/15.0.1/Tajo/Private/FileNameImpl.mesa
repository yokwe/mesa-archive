-- Copyright (C) 1981, 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- File: FileNameImpl.mesa - Last edit by  -- BXM   on:  22-Oct-81 16:07:57  -- SEH	23-Mar-82 16:58:19  -- BJD    	20-Apr-84 15:28:38  -- LXR    	18-Oct-82 15:19:17  -- BTL  	10-Jan-83 11:56:07  -- RXJ     	14-Jan-83  8:59:58DIRECTORY  FileName USING [VirtualFilenameObject, VFN],  Heap USING [systemZone],  MFile USING [    AddProperty, GetProperty, Handle, PropertyError, RemoveProperty, SetProperty],  MFileProperty USING [RemoteName],  String USING [    AppendCharAndGrow, AppendString, AppendStringAndGrow, Empty, ExpandString,    MakeString, FreeString, Replace, UpperCase];FileNameImpl: PROGRAM    IMPORTS Heap, MFile, String    EXPORTS FileName =  BEGIN  z: UNCOUNTED ZONE = Heap.systemZone;  maxDir: CARDINAL = 100;  maxRemoteNameLength: CARDINAL = 150;   InLeftHostSeparators: PROCEDURE[ch:CHARACTER] RETURNS[BOOLEAN] = INLINE {    RETURN[ch = '[ OR ch ='(]};  InRightHostSeparators: PROCEDURE[ch:CHARACTER] RETURNS[BOOLEAN] = INLINE {    RETURN[ch = '] OR ch =')]};  InLeftDirectorySeparators: PROCEDURE[ch:CHARACTER] RETURNS[BOOLEAN] = INLINE {    RETURN[ch = '< OR ch ='/]};  InRightDirectorySeparators: PROCEDURE[ch:CHARACTER] RETURNS[BOOLEAN] = INLINE {    RETURN[ch = '> OR ch ='/]};  InVersionSeparators: PROCEDURE[ch:CHARACTER] RETURNS[BOOLEAN] = INLINE {    RETURN[ch = '! OR ch =';]};  IsFinalVersionSeparator: PROCEDURE[s: LONG STRING, pos: CARDINAL]    RETURNS[BOOLEAN] = {    IF ~InVersionSeparators[s[pos]] THEN RETURN[FALSE];    FOR i: CARDINAL IN [pos+1..s.length) DO      IF InVersionSeparators[s[i]] THEN RETURN[FALSE];      ENDLOOP;    RETURN[TRUE]};    Error: PUBLIC SIGNAL = CODE;  -- illegal file name  AllocVFN: PUBLIC PROC [file: LONG STRING] RETURNS [vfn: FileName.VFN] = {    IF String.Empty[file] THEN RETURN[NIL];    vfn ¬ z.NEW[FileName.VirtualFilenameObject ¬ [      NIL, NIL, NIL, NIL]];    UnpackFilename[file, vfn]};  FreeVFN: PUBLIC PROC [vfn: FileName.VFN] = {    ResetVFN[vfn, TRUE, TRUE, TRUE, TRUE]; z.FREE[@vfn]};  PackFilename: PUBLIC PROC [vfn: FileName.VFN, h, d, n, v: BOOLEAN ¬ FALSE]    RETURNS [s: LONG STRING] =    BEGIN    IF vfn = NIL THEN RETURN[NIL];    s ¬ String.MakeString[z, 60];    IF h AND ~String.Empty[vfn.host] THEN      BEGIN      String.AppendCharAndGrow[@s, '[, z];      String.AppendStringAndGrow[@s, vfn.host, z, 20];      String.AppendCharAndGrow[@s, '], z];      END;    IF d AND ~String.Empty[vfn.directory] THEN      BEGIN      String.AppendStringAndGrow[@s, vfn.directory, z, 20];      IF ~InRightDirectorySeparators[vfn.directory[vfn.directory.length - 1]] THEN        String.AppendCharAndGrow[@s, '>, z];      END;    IF n AND ~String.Empty[vfn.name] THEN      String.AppendStringAndGrow[@s, vfn.name, z, 20];    IF v AND ~String.Empty[vfn.version] THEN {      String.AppendCharAndGrow[        @s, IF Maxc[vfn.host] THEN '; ELSE '!, z];      String.AppendStringAndGrow[@s, vfn.version, z, 20]}    ELSE  -- leave room for client to add version      IF s.maxlength - 6 < s.length THEN String.ExpandString[@s, 6, z];    RETURN[s]    END;      UnpackFilename: PUBLIC PROCEDURE [s: LONG STRING, vfn: FileName.VFN] =    BEGIN OPEN String;    temp: LONG STRING ¬ MakeString[z, maxDir];    { ENABLE UNWIND => FreeString[z, temp];    i: CARDINAL ¬ 0;    firstTime: BOOLEAN ¬ TRUE;    ReplaceHost: PROC = {      IF temp.length # 0 THEN {Replace[@vfn.host, temp, z]; temp.length ¬ 0}};        IF vfn = NIL OR Empty[s] THEN GOTO return;    IF InLeftHostSeparators[s[0]] THEN {  -- host      i ¬ 1;      UNTIL InRightHostSeparators[s[i]] DO       AppendCharAndGrow[@temp, s[i], z];       IF (i ¬ i+1) >= s.length OR InLeftHostSeparators[s[i]] THEN         ERROR Error;      ENDLOOP;   i ¬ i+1;      ReplaceHost[]    };    DO  -- directory      UNTIL i = s.length DO        IF IsFinalVersionSeparator[s, i] THEN EXIT;         AppendCharAndGrow[@temp, s[i], z];	IF InRightDirectorySeparators[s[i]] THEN EXIT;	i ¬ i+1;      ENDLOOP;      IF i = s.length OR IsFinalVersionSeparator[s, i] THEN EXIT;      IF firstTime THEN {         IF ~Empty[vfn.directory] THEN	  IF InLeftDirectorySeparators[temp[0]] THEN  vfn.directory.length ¬ 0	  ELSE IF 	    ~InRightDirectorySeparators[vfn.directory[vfn.directory.length-1]]	  THEN	    AppendCharAndGrow[@vfn.directory, '>, z];        firstTime ¬ FALSE       };      AppendStringAndGrow[@vfn.directory, temp, z];      temp.length ¬ 0;      IF i = s.length-1 THEN GOTO return; -- no name      i ¬ i+1;    ENDLOOP;    IF vfn.name # NIL THEN vfn.name.length ¬ 0;    AppendStringAndGrow[@vfn.name, temp, z];  -- name    IF i = s.length THEN GOTO return    ELSE {  -- version      IF vfn.version # NIL THEN vfn.version.length ¬ 0;      FOR j: CARDINAL IN [i+1..s.length) DO        AppendCharAndGrow[@vfn.version, s[j], z];      ENDLOOP;    };    GOTO return;    EXITS     return => {       FreeString[z, temp];        IF vfn.directory # NIL AND	 InRightDirectorySeparators[vfn.directory[vfn.directory.length-1]]       THEN vfn.directory.length ¬ vfn.directory.length-1}}      END;  NormalizeVFN: PUBLIC PROC [vfn: FileName.VFN] = {    s: LONG STRING ¬ PackFilename[vfn];    UnpackFilename[s, vfn];    String.FreeString[z, s]};  ResetVFN: PUBLIC PROC [vfn: FileName.VFN, h, d, n, v: BOOLEAN ¬ FALSE] = {    IF vfn = NIL THEN RETURN;    IF h THEN {String.FreeString[z, vfn.host]; vfn.host ¬ NIL};    IF d THEN {String.FreeString[z, vfn.directory]; vfn.directory ¬ NIL};    IF n THEN {String.FreeString[z, vfn.name]; vfn.name ¬  NIL};    IF v THEN {String.FreeString[z, vfn.version]; vfn.version ¬ NIL}};  Maxc: PUBLIC PROC [host: LONG STRING] RETURNS [BOOLEAN] = {    maxc: STRING = "MAXC"L;    IF String.Empty[host] THEN RETURN[FALSE];    FOR i: CARDINAL IN [0..MIN[maxc.length, host.length]) DO      IF String.UpperCase[host[i]] # maxc[i] THEN RETURN[FALSE]; ENDLOOP;    RETURN[TRUE]};  FreeFilename: PUBLIC PROCEDURE [s: LONG STRING] = {Heap.systemZone.FREE[@s]};  SetRemoteName: PUBLIC PROCEDURE [file: MFile.Handle, remoteName: LONG STRING] =    BEGIN     -- remotename should be of the form [host]<directory>name!vers    IF String.Empty[remoteName] OR remoteName.length > maxRemoteNameLength THEN       ERROR Error;    DO      BEGIN      MFile.AddProperty[        file: file, property: MFileProperty.RemoteName,        maxLength: maxRemoteNameLength !          MFile.PropertyError => SELECT code FROM	    noRoomInPropertyList, insufficientSpaceForProperty => GOTO ForgetIt;	    wrongSize => GOTO Remove; -- must UNWIND before Remove	    ENDCASE => REJECT];      EXITS Remove => {        MFile.RemoveProperty[file, MFileProperty.RemoteName]; LOOP};      END;      EXIT      ENDLOOP;    MFile.SetProperty[      file: file, property: MFileProperty.RemoteName,      block: [        blockPointer: LOOPHOLE[@remoteName.text],	startIndex: 0, stopIndexPlusOne: remoteName.length]];    EXITS ForgetIt=> NULL;    END;      GetRemoteName: PUBLIC PROCEDURE [file: MFile.Handle, remoteName: LONG STRING] =    BEGIN    temp: LONG STRING ¬ [maxRemoteNameLength];    rnLength: CARDINAL;    IF remoteName = NIL THEN ERROR Error;    rnLength ¬ MFile.GetProperty[      file: file, property: MFileProperty.RemoteName,      block: [        blockPointer: LOOPHOLE[@temp.text],	startIndex: 0, stopIndexPlusOne: maxRemoteNameLength]      ! MFile.PropertyError =>          SELECT code FROM	    noSuchProperty => GOTO NoSuchProp;	    ENDCASE => REJECT];    IF rnLength > remoteName.maxlength THEN ERROR Error; -- remote name won't fit    remoteName.length ¬ 0;  temp.length ¬ rnLength;    String.AppendString[remoteName, temp];    EXITS NoSuchProp => remoteName.length ¬ 0;    END;  END.
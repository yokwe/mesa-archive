-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- File: TokensB.mesa - last edited by:-- HGM:		30-Oct-82 18:18:51-- LXR    :	 1-Nov-82 11:42:54DIRECTORY  Format USING [NetFormat],  Heap USING [systemZone],  System USING [    HostNumber, NetworkAddress, NetworkNumber, SocketNumber,    nullHostNumber, nullNetworkAddress, nullNetworkNumber, nullSocketNumber],  Token USING [Filtered, FilterProcType, Handle, SyntaxError],  Unformat USING [Error, HostNumber, NetworkAddress, NetworkNumber, SocketNumber];TokensB: PROGRAM IMPORTS Heap, Token, Unformat EXPORTS Token =  BEGIN  Handle: TYPE = Token.Handle;  NetFormat: TYPE = Format.NetFormat;  HostNumber: PUBLIC PROCEDURE [    h: Handle, format: NetFormat ¬ octal, signalOnError: BOOLEAN ¬ TRUE]    RETURNS [host: System.HostNumber] =    BEGIN    s: LONG STRING ¬ Token.Filtered[h, NIL, NetFilter];    IF s = NIL THEN      BEGIN      IF signalOnError THEN SIGNAL Token.SyntaxError[s];      RETURN[System.nullHostNumber];      END;    host ¬ Unformat.HostNumber[s, format !       Unformat.Error =>         BEGIN         IF signalOnError THEN SIGNAL Token.SyntaxError[s];	 host ¬ System.nullHostNumber;	 CONTINUE;	 END;      UNWIND => Heap.systemZone.FREE[@s]];    Heap.systemZone.FREE[@s];    END;     NetworkAddress: PUBLIC PROCEDURE [    h: Handle, format: NetFormat ¬ octal, signalOnError: BOOLEAN ¬ TRUE]    RETURNS [address: System.NetworkAddress] =    BEGIN    s: LONG STRING ¬ Token.Filtered[h, NIL, NetFilter];    IF s = NIL THEN      BEGIN      IF signalOnError THEN SIGNAL Token.SyntaxError[s];      RETURN[System.nullNetworkAddress];      END;    address ¬ Unformat.NetworkAddress[s, format !       Unformat.Error =>         BEGIN         IF signalOnError THEN SIGNAL Token.SyntaxError[s];	 address ¬ System.nullNetworkAddress;	 CONTINUE;	 END;      UNWIND => Heap.systemZone.FREE[@s]];    Heap.systemZone.FREE[@s];    END;      NetworkNumber: PUBLIC PROCEDURE [     h: Handle, format: NetFormat ¬ octal, signalOnError: BOOLEAN ¬ TRUE]     RETURNS [networkNumber: System.NetworkNumber] =    BEGIN    s: LONG STRING ¬ Token.Filtered[h, NIL, NetFilter];    IF s = NIL THEN      BEGIN      IF signalOnError THEN SIGNAL Token.SyntaxError[s];      RETURN[System.nullNetworkNumber];      END;    networkNumber ¬ Unformat.NetworkNumber[s, format !       Unformat.Error =>         BEGIN         IF signalOnError THEN SIGNAL Token.SyntaxError[s];	 networkNumber ¬ System.nullNetworkNumber;	 CONTINUE;	 END;      UNWIND => Heap.systemZone.FREE[@s]];    Heap.systemZone.FREE[@s];    END;       SocketNumber: PUBLIC PROCEDURE [     h: Handle, format: NetFormat ¬ octal, signalOnError: BOOLEAN ¬ TRUE]     RETURNS [socketNumber: System.SocketNumber] =    BEGIN    s: LONG STRING ¬ Token.Filtered[h, NIL, NetFilter];    IF s = NIL THEN      BEGIN      IF signalOnError THEN SIGNAL Token.SyntaxError[s];      RETURN[System.nullSocketNumber];      END;    socketNumber ¬ Unformat.SocketNumber[s, format !       Unformat.Error =>         BEGIN         IF signalOnError THEN SIGNAL Token.SyntaxError[s];	 socketNumber ¬ System.nullSocketNumber;	 CONTINUE;	 END;      UNWIND => Heap.systemZone.FREE[@s]];    Heap.systemZone.FREE[@s];    END;  NetFilter: PUBLIC Token.FilterProcType =    BEGIN    RETURN[      SELECT c FROM        IN ['0..'9], IN['A..'F], IN['a..'f], 'H, 'h, '-, '*, '#, '. => TRUE,        ENDCASE => FALSE];    END;      END...
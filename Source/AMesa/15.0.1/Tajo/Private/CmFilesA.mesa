-- Copyright (C) 1981, 1982, 1984  by Xerox Corporation. All rights reserved. -- File: CmFilesA.mesa - last edit:-- SXW   ,	10-Jul-81 17:46:35-- BXM  ,	16-Jul-81 16:28:10-- JGS,		 2-Sep-81  9:47:44-- Tom,		Aug 28, 1979 6:01 PM-- Mark,	15-Jul-81 11:02:48-- PXK    ,	 8-Jan-82 18:20:19-- RXR   ,	13-Oct-81 16:02:24-- SXS   ,	14-Oct-81 10:09:17-- LXR    ,	 4-Jan-84 10:55:39-- AXD    ,	21-Sep-82 16:17:38-- CXH   ,	16-Dec-82 17:30:57DIRECTORY  Ascii USING [CR, NUL, SP, TAB],  CmFile USING [ErrorCode, Handle],  Event: TYPE USING [fileSystem],  EventTypes: TYPE USING [newSearchPath],  Heap: TYPE USING [Create, Flush, systemZone],  MFile USING     [dontRelease, Error, GetProperties, Handle, maxNameLength, ReadOnly, Release],  MStream USING [Create, Error, GetFile, Handle, PleaseReleaseProc, ReadOnly],  Stream USING [EndOfStream, GetChar, GetPosition, Handle, SetPosition],  String USING [    AppendChar, AppendString, Compare, CopyToNewString, EquivalentString,    EquivalentSubString, StringBoundsFault, SubStringDescriptor],  StringLookUp USING [InTable, noMatch, TableDesc],  Supervisor USING [    AddDependency, AgentProcedure, CreateSubsystem, SubsystemHandle],  System USING [switches],  Token USING [    Filtered, FilterProcType, GetCharProcType, Handle, Line,     nonQuote, Object, QuoteProcType, WhiteSpace],  Volume USING [GetLabelString, systemID];CmFilesA: MONITOR  IMPORTS    Event, Heap, MFile, MStream, Stream, String, StringLookUp,     Supervisor, System, Token, Volume  EXPORTS CmFile =  BEGIN  -- Global Data  lineSize: CARDINAL = 250;  noSection: LONG CARDINAL = LAST[LONG CARDINAL];  agent: Supervisor.SubsystemHandle ¬ Supervisor.CreateSubsystem[FileSystemEvent];  sectionHints: HintHandle ¬ NIL;  userCm: MStream.Handle ¬ NIL;  readingCount: CARDINAL ¬ 0;  resetStream: BOOLEAN ¬ FALSE;    z: UNCOUNTED ZONE = Heap.Create[initial: 2, increment: 1];  HintHandle: TYPE = LONG POINTER TO HintObject;  HintObject: TYPE = RECORD [    name: LONG STRING ¬ NIL,    position: LONG CARDINAL ¬ 0,    next: HintHandle ¬ NIL];  Handle: TYPE = LONG POINTER TO Object;  Object: TYPE = MACHINE DEPENDENT RECORD [    tokenData: Token.Object,    sh: Stream.Handle,    specificIndex: LONG CARDINAL ¬ noSection];  AbsToRep: PROCEDURE [h: CmFile.Handle] RETURNS [Handle] = {RETURN[LOOPHOLE[h]]};  RepToAbs: PROCEDURE [h: Handle] RETURNS [CmFile.Handle] = {    RETURN[@h.tokenData]};  Validate: PROCEDURE [h: CmFile.Handle] RETURNS [repH: Handle] =    BEGIN    repH ¬ AbsToRep[h];    IF repH.tokenData.getChar # GetChar THEN ERROR Error[invalidHandle];    END;  -- Syntax of a Cm file is:  --   CmFile ::= Section | CmFile Section  --   Section ::= SectionName SectionBody  --   SectionName ::= beginSectionName NameBody endSectionName  --     NameBody ::= NameBody ~endSectionName | ~endSectionName  --   SectionBody ::= SectionBody SectionLine | SectionLine |  --     SectionLine ::= Name nameBreak MiscLine | MiscLine  --     Name ::= Name ~nameBreak | ~nameBreak  --   MiscLines ::= MiscLines MiscLine | MiscLine |  -- Any line that begins with two commentChar's is ignored, as is any  --   SectionLine that is only a MiscLine.   beginSectionName: CHARACTER = '[;  commentChar: CHARACTER = '-;  endSectionName: CHARACTER = '];  nameBreak: CHARACTER = ':;  separateSectionName: CHARACTER = ':;  -- SIGNALs  Error: PUBLIC SIGNAL [code: CmFile.ErrorCode] = CODE;  TableError: PUBLIC SIGNAL [h: CmFile.Handle, name: LONG STRING] = CODE;  -- Simple Interface Procedures  FreeString: PUBLIC PROCEDURE [s: LONG STRING] RETURNS [nil: LONG STRING ¬ NIL] =    {Heap.systemZone.FREE[@s]};  Close: PUBLIC PROCEDURE [h: CmFile.Handle] RETURNS [nil: CmFile.Handle] = {    repH: Handle ¬ Validate[h];    repH.sh.delete[repH.sh];    repH.tokenData.getChar ¬ NIL;  -- make sure deallocated object will not look valid    Heap.systemZone.FREE[@h];    RETURN[h]};  Line: PUBLIC PROCEDURE [fileName, title, name: LONG STRING]    RETURNS [s: LONG STRING] =    -- This is not as quick as it could be, but minimizes code.    -- Note that NextItem will automatically go from generic to specific section.    BEGIN    h: CmFile.Handle;    s ¬ NIL;    h ¬ Open[fileName ! Error => GOTO NoFile];    IF FindSection[h, title] THEN      DO        tag, value: LONG STRING;        [tag, value] ¬ NextItem[h ! UNWIND => h ¬ Close[h]];        IF tag = NIL THEN EXIT;        IF String.EquivalentString[name, tag] THEN {          temp: LONG STRING ¬ s; s ¬ value; value ¬ temp};        Heap.systemZone.FREE[@tag];        Heap.systemZone.FREE[@value];        ENDLOOP;    h ¬ Close[h];    EXITS NoFile => NULL;    END;  Open: PUBLIC PROCEDURE [fileName: LONG STRING] RETURNS [h: CmFile.Handle] =    BEGIN    repH: Handle;    BEGIN    fh: MFile.Handle;    sh: Stream.Handle;    IF System.switches['N] = down AND        String.EquivalentString[fileName, "User.cm"L] THEN GOTO Lose;    fh ¬ MFile.ReadOnly[      fileName, MFile.dontRelease ! MFile.Error => GOTO Lose];    sh ¬ MStream.Create[fh, []       ! MStream.Error => {MFile.Release[fh]; GOTO Lose}];    repH ¬ Heap.systemZone.NEW[      Object ¬ [tokenData: [getChar: GetChar, break: ---- ], sh: sh]];    EXITS Lose => {SIGNAL Error[fileNotFound]; RETURN[NIL]};    END;    h ¬ RepToAbs[repH];    END;  ReadLineOrToken: PUBLIC PROCEDURE [    h: Token.Handle, buffer: LONG STRING, terminator: CHARACTER] =    -- Output assertion: h.break is one of terminator, Ascii.CR, or Ascii.NUL    BEGIN    buffer.length ¬ 0;    -- Skip over leading white space    WHILE      SELECT (h.break ¬ h.getChar[h]) FROM        Ascii.SP, Ascii.TAB => TRUE,        ENDCASE => FALSE DO ENDLOOP;    -- Now pick up token (or the line)    DO      SELECT h.break FROM        terminator, Ascii.CR, Ascii.NUL => EXIT;        ENDCASE;      String.AppendChar[        buffer, h.break ! String.StringBoundsFault => GOTO TooMany];      h.break ¬ h.getChar[h];      ENDLOOP;    EXITS TooMany => NULL;    END;  TitleMatch: PUBLIC PROCEDURE [buffer, title: LONG STRING] RETURNS [BOOLEAN] =    BEGIN    llSubString, titleSubString: String.SubStringDescriptor;    IF buffer.length < title.length + 2 OR buffer[0] # beginSectionName      OR buffer[title.length + 1] # endSectionName THEN RETURN[FALSE];    llSubString ¬ [buffer, 1, title.length];    titleSubString ¬ [title, 0, title.length];    RETURN[String.EquivalentSubString[@llSubString, @titleSubString]];    END;  -- More efficient ones   FindSection: PUBLIC PROCEDURE [h: CmFile.Handle, title: LONG STRING]    RETURNS [opened: BOOLEAN] =    BEGIN    localLine: STRING ¬ [lineSize];    repH: Handle = Validate[h];    genericIndex: LONG CARDINAL ¬ noSection;    qualifiedTitle: LONG STRING;    Volume.GetLabelString[Volume.systemID, localLine];    String.AppendChar[localLine, separateSectionName];    String.AppendString[localLine, title];    qualifiedTitle ¬ String.CopyToNewString[localLine, Heap.systemZone];    -- First try to locate both generic and specific sections    IF IsUserDotCm[repH] THEN {      str: LONG STRING;      doneOne: BOOLEAN ¬ FALSE;      temp: HintHandle;      SELECT String.Compare[qualifiedTitle, title] FROM        -1 => str ¬ qualifiedTitle;	1 => str ¬ title;	ENDCASE;      CheckHints[];      FOR l: HintHandle ¬ sectionHints, temp UNTIL l = NIL DO        SELECT String.Compare[str, l.name] FROM	  0 => {	    IF str = title THEN genericIndex ¬ l.position	    ELSE repH.specificIndex ¬ l.position;	    IF doneOne THEN EXIT;	    temp ¬ l.next};	  1 => {temp ¬ l.next; LOOP};	  ENDCASE => temp ¬ l; -- didn't find first title, so advance to second title	IF doneOne THEN EXIT;	doneOne ¬ TRUE;	IF str = qualifiedTitle THEN str ¬ title ELSE str ¬ qualifiedTitle;	ENDLOOP;      DoneReading[]}    ELSE {     Stream.SetPosition[repH.sh, 0];     DO      ENABLE UNWIND => Heap.systemZone.FREE[@qualifiedTitle];      ReadLine[h, localLine];      IF h.break = Ascii.NUL THEN EXIT;      IF localLine.length # 0 AND localLine[0] = beginSectionName THEN        BEGIN        IF TitleMatch[localLine, qualifiedTitle] THEN          BEGIN          repH.specificIndex ¬ Stream.GetPosition[repH.sh];          IF genericIndex # noSection THEN EXIT;          END;        IF TitleMatch[localLine, title] THEN          BEGIN          genericIndex ¬ Stream.GetPosition[repH.sh];          IF repH.specificIndex # noSection THEN EXIT;          END;        END;      ENDLOOP};    Heap.systemZone.FREE[@qualifiedTitle];    -- Process generic section, then specific section    IF opened ¬ (genericIndex # noSection) THEN      Stream.SetPosition[repH.sh, genericIndex]    ELSE opened ¬ ~TrySpecific[h];    END;  TrySpecific: PROCEDURE [h: CmFile.Handle] RETURNS [alreadyDone: BOOLEAN] =    BEGIN    repH: Handle = Validate[h];    IF ~(alreadyDone ¬ (repH.specificIndex = noSection)) THEN {      Stream.SetPosition[repH.sh, repH.specificIndex];      repH.specificIndex ¬ noSection};    END;  NextItem: PUBLIC PROCEDURE [h: CmFile.Handle]    RETURNS [name, value: LONG STRING] =    BEGIN    localLine: STRING ¬ [lineSize];    DO      ReadName[h, localLine];      IF h.break = nameBreak THEN EXIT;      IF TrySpecific[h] THEN RETURN[NIL, NIL];      ENDLOOP;    name ¬ String.CopyToNewString[localLine, Heap.systemZone];    value ¬ Token.Filtered[h: h, data: NIL, filter: Token.Line,       skip: whiteSpace, temporary: FALSE];    FOR i: CARDINAL DECREASING IN [0..value.length) DO      IF ~Token.WhiteSpace[value[i], NIL] THEN {value.length ¬ i+1; EXIT};      ENDLOOP;    END;  FindItem: PUBLIC PROCEDURE [h: CmFile.Handle, title, name: LONG STRING] RETURNS [found: BOOLEAN] =    BEGIN    localLine: STRING ¬ [lineSize];    IF ~FindSection[h, title] THEN RETURN[FALSE];    DO      GobbleRestOfLine[h]; -- consume any parts of preceding line left over by client      ReadName[h, localLine];      IF h.break = nameBreak THEN        SELECT TRUE FROM	  String.EquivalentString[name, localLine] => RETURN[TRUE];	  ENDCASE => LOOP;      IF TrySpecific[h] THEN RETURN[FALSE];      ENDLOOP;    END;  NextValue: PUBLIC PROCEDURE [h: CmFile.Handle, table: StringLookUp.TableDesc]    RETURNS [index: CARDINAL] =    BEGIN    localLine: STRING ¬ [lineSize];    DO      GobbleRestOfLine[h];  -- consume any parts of preceding line left over by client      ReadName[h, localLine];      IF h.break # nameBreak THEN        IF TrySpecific[h] THEN RETURN[StringLookUp.noMatch]        ELSE {h.break ¬ Ascii.CR; LOOP};      index ¬ StringLookUp.InTable[localLine, table, TRUE, TRUE].index;      IF index < LENGTH[table] THEN EXIT;      SIGNAL TableError[h, localLine];      ENDLOOP;    END;  -- Use "User.cm" as fileName in above  UserDotCmOpen: PUBLIC PROCEDURE RETURNS [h: CmFile.Handle] =    BEGIN h ¬ Open["User.cm"L]; END;  UserDotCmLine: PUBLIC PROCEDURE [title, name: LONG STRING]    RETURNS [s: LONG STRING] =    BEGIN s ¬ Line[fileName: "User.cm"L, title: title, name: name]; END;  -- Private Procedures  GetChar: PRIVATE Token.GetCharProcType =    BEGIN    repH: Handle = AbsToRep[h];    c ¬ Stream.GetChar[repH.sh ! Stream.EndOfStream => {c ¬ Ascii.NUL; CONTINUE}]    END;  GobbleRestOfLine: PRIVATE PROCEDURE [h: CmFile.Handle] =    BEGIN    WHILE SELECT h.break FROM Ascii.CR, Ascii.NUL => FALSE, ENDCASE => TRUE DO      h.break ¬ h.getChar[h]; ENDLOOP;    END;  IsCommentLine: PRIVATE PROCEDURE [s: LONG STRING] RETURNS [BOOLEAN] =    BEGIN RETURN[s.length > 1 AND s[0] = commentChar AND s[1] = commentChar]; END;  IsUserDotCm: PRIVATE PROCEDURE [repH: Handle] RETURNS [BOOLEAN] =    BEGIN    name: LONG STRING ¬ [MFile.maxNameLength];    [] ¬ MFile.GetProperties[MStream.GetFile[repH.sh], name];    RETURN[String.EquivalentString[name, "User.cm"L]];    END;  ReadLine: PRIVATE PROCEDURE [h: CmFile.Handle, buffer: LONG STRING] =    -- Suppresses comment lines    BEGIN    DO      ReadLineOrToken[h, buffer, Ascii.CR];      IF h.break # Ascii.CR OR ~IsCommentLine[buffer] THEN EXIT;      ENDLOOP;    END;  ReadName: PRIVATE PROCEDURE [h: CmFile.Handle, buffer: LONG STRING] =    -- Suppresses comment lines and any line that is neither a SectionName    --  nor a SectionLine     -- Output assertion: h.break = Ascii.NUL OR h.break = nameBreak OR    --   h.getChar is positioned just after Ascii.CR    BEGIN    DO      ReadLineOrToken[h, buffer, nameBreak];      IF h.break = Ascii.NUL THEN EXIT;      IF buffer.length # 0 AND ~IsCommentLine[buffer] THEN        IF buffer[0] = beginSectionName THEN {          GobbleRestOfLine[h]; h.break ¬ Ascii.NUL; EXIT}        ELSE IF h.break = nameBreak THEN EXIT;      GobbleRestOfLine[h];      ENDLOOP;    END;  CmFileQuote: Token.QuoteProcType =    BEGIN RETURN[SELECT c FROM '" => c, ENDCASE => Token.nonQuote]; END;  CheckHints: ENTRY PROCEDURE =    BEGIN     localLine: STRING ¬ [lineSize];    list, l: HintHandle ¬ NIL;    position: LONG CARDINAL;    name: LONG STRING ¬ NIL;    index: CARDINAL ¬ 0;    tokenHandle: Token.Object ¬ [getChar, Ascii.NUL];    getChar: Token.GetCharProcType = {    c ¬ Stream.GetChar[userCm ! Stream.EndOfStream => {c ¬ Ascii.NUL; CONTINUE}]};        IF sectionHints # NIL THEN {readingCount ¬ readingCount + 1; RETURN};    userCm ¬ MStream.ReadOnly["User.cm"L, [myRelease, NIL] ! MStream.Error => CONTINUE];    IF userCm = NIL THEN {SIGNAL Error[fileNotFound]; RETURN};    DO      ReadLine[@tokenHandle, localLine];      IF tokenHandle.break = Ascii.NUL THEN EXIT;      IF localLine.length = 0 OR localLine[0] # beginSectionName THEN LOOP;      position ¬ Stream.GetPosition[userCm];      FOR index IN [1..localLine.length) DO        IF localLine[index] = endSectionName THEN EXIT;        REPEAT FINISHED => LOOP;	ENDLOOP;      name ¬ z.NEW[StringBody[index - 1]];      FOR i: CARDINAL  IN [1..index) DO name[i - 1] ¬ localLine[i] ENDLOOP;      name.length ¬ index - 1;      IF list = NIL THEN list ¬ z.NEW[HintObject ¬ [name, position, list]]      ELSE SELECT String.Compare[name, list.name] FROM        -1 => list  ¬ z.NEW[HintObject ¬ [name, position, list]];        0 => z.FREE[@name];        ENDCASE => {          FOR l ¬ list, l.next UNTIL l.next = NIL DO             SELECT String.Compare[name, l.next.name] FROM              -1 => EXIT;              0 => {z.FREE[@name]; EXIT};              ENDCASE;	    ENDLOOP;	  IF name # NIL THEN 	    l.next  ¬ z.NEW[HintObject ¬ [name, position, l.next]]};       ENDLOOP;    sectionHints ¬ list;    readingCount ¬ readingCount + 1;    END;  DoneReading: ENTRY PROCEDURE =     BEGIN    readingCount ¬ readingCount - 1;    IF readingCount = 0 AND resetStream THEN      {FreeList[TRUE]; resetStream ¬ FALSE}    END;  myRelease: ENTRY MStream.PleaseReleaseProc =    BEGIN    IF readingCount > 0 THEN RETURN[no];    FreeList[FALSE];    RETURN[goAhead]    END;  FileSystemEvent: ENTRY Supervisor.AgentProcedure =    BEGIN    IF event # EventTypes.newSearchPath THEN RETURN;     IF readingCount > 0 THEN resetStream ¬ TRUE    ELSE FreeList[TRUE];     END;       FreeList: INTERNAL PROCEDURE [freeStream: BOOLEAN] =     BEGIN    Heap.Flush[z];    sectionHints ¬ NIL;    IF freeStream AND userCm # NIL THEN userCm.delete[userCm];    userCm ¬ NIL;    END;    -- main body   Supervisor.AddDependency[client: agent, implementor: Event.fileSystem];END.  -- of CmFilesA
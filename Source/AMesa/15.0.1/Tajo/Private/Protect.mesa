-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- Protect.mesa, last edit by:-- CXH   ,	13-Jan-83 14:51:30DIRECTORY  Exec USING [    AddCommand, ExecProc, GetToken, Handle, OutputProc],  Format USING [StringProc],  Heap USING [systemZone],  MFile USING [    Acquire, AppendErrorMessage, Error, GetProtection, Handle, Release,     SetProtection];Protect: MONITOR  IMPORTS    Exec, Heap, MFile =  BEGIN  ----------------------------------------------------------------  -- Global variables  ----------------------------------------------------------------  z: UNCOUNTED ZONE = Heap.systemZone;    ----------------------------------------------------------------  -- Exec stuff  ----------------------------------------------------------------    ProtectCommand: Exec.ExecProc =    BEGIN    write: Format.StringProc = h.OutputProc[];    token, switches: LONG STRING ¬ NIL;    readProtect, writeProtect, deleteProtect: BOOLEAN;    file: MFile.Handle ¬ NIL;    -- IF h.EndOfCommandLine[] THEN {MakeTool[]; RETURN};    DO ENABLE UNWIND => {z.FREE[@token]; z.FREE[@switches]};      z.FREE[@token];      z.FREE[@switches];      [token, switches] ¬ h.GetToken[];      IF token = NIL AND switches = NIL THEN EXIT;      IF token = NIL THEN LOOP;      file ¬ MFile.Acquire[        name: token, access: anchor, release: [] !           MFile.Error => {            msg: STRING = [100];            MFile.AppendErrorMessage[msg, code, file];            write[msg];            LOOP}];      [deleteProtect, writeProtect, readProtect] ¬ file.GetProtection[ !        UNWIND => {file.Release[]; LOOP}];      IF switches # NIL THEN {        not: BOOLEAN ¬ FALSE;        FOR i: CARDINAL IN [0..switches.length) DO          SELECT switches[i] FROM	    '~, '- => not ¬ ~not;	    'R, 'r => {readProtect ¬ ~not; not ¬ FALSE};	    'W, 'w => {writeProtect ¬ ~not; not ¬ FALSE};	    'D, 'd => {deleteProtect ¬ ~not; not ¬ FALSE};	    ENDCASE => not ¬ FALSE;          ENDLOOP;        file.SetProtection[deleteProtect, writeProtect, readProtect !          UNWIND => CONTINUE]};      file.Release[];      IF deleteProtect OR writeProtect OR readProtect THEN {        write[token];        IF deleteProtect THEN write[" deleteProtected"L];        IF writeProtect THEN write[" writeProtected"L];        IF readProtect THEN write[" readProtected"L];        write[""L]};      ENDLOOP;    END;      Help: Exec.ExecProc =    BEGIN    h.OutputProc[]["This command changes the protection of files.Protect.~ {FileName[\"/\"[\"~\" | \"-\"] ( \"R\" | \"W\" | \"D\" ) ]}	R	Set readProtected (Can't be read)	~R	Clear readProtected	W	Set writeProtected (Can't be written)	~W	Clear writeProtected	D	Set deleteProtected (Can't be Deleted)	~D	Clear deleteProtected"L];    END;      ----------------------------------------------------------------  -- Mainline code  ----------------------------------------------------------------      Exec.AddCommand["Protect.~", ProtectCommand, Help];  END.
-- File: ControlUtilsA.mesa - last edit:-- Riggle.PA            8-Aug-86 16:09:09-- Copyright (C) 1981, 1982, 1983, 1984 , 1986 by Xerox Corporation. All rights reserved. -- File: ControlUtilsA.mesa - last edit:-- SXW   	13-Jul-81  7:29:20-- Mark		15-Jul-81 16:51:05-- BXM  	13-Nov-81 15:36:47-- PXK    	24-Feb-83 13:35:29-- RXR   	9-Oct-81 17:15:03-- SXS   	17-Mar-82 17:02:12-- LXR    	17-Oct-83 11:19:58-- AXD    	 8-Jun-84 17:54:31-- CXH   	24-Feb-83 11:43:36-- BJD    	27-Sep-84 10:47:33-- AOF		19-Oct-84 11:00:50-- KAM     	21-Oct-84 14:53:37-- DWR     	21-Aug-85 12:45:56DIRECTORY  CH USING [Buffer, FreeRhs, MakeRhs],  ConvertData USING [ConvertDataFiles],  Cursor USING [Object, Set, Store],  Event USING [],  EventTypes USING [    aboutToBootPhysicalVolume, bootPhysicalVolume, bootPhysicalVolumeCancelled,     powerOff],  Exec USING [Load, Run, Start],  ExecInternal USING [SimpleExec],  FileWindow USING [CreateMCR],  Format USING [StringProc],  Heap USING [Create, <<Expand,>> systemZone],  Menu USING [Handle, Instantiate, Make, MCRType, SetFont],  MFile USING [InitializeFileSystem],  MLoader USING [Handle],  MScavenge USING [StartingScavenge],  PilotClient USING [],  PilotMP USING [cTimeNotAvailable],  ProcessorFace USING [mp, SetMP],  Put USING [LongString],  Runtime USING [    CallDebugger, GetBuildTime, GetTableBase, GlobalFrame, IsBound],  Selection USING [Convert],  SetTime USING [Set],  SpecialMFile: TYPE USING [RegisterWithSupervisor],  SpecialSpace USING [MakeGlobalFrameResident, MakeProcedureResident],  SpecialWindow: TYPE USING [DefineRoot],  String USING [EquivalentSubString, SubStringDescriptor],  Supervisor USING [    CreateSubsystem, EnumerationAborted, NotifyDirectSubsystems, SubsystemHandle],  System USING [    GetGreenwichMeanTime, GetLocalTimeParameters, LocalTimeParametersUnknown,    PowerOff],  TajoFont USING [],  TajoMisc USING [],  TajoOps USING [    ProcessUserActions, ProcessUserCm, ProcessInitialCommandLine,    RunCascadeNub, SetInitialToolStateDefault,    StartStimulusLevel, WindowObject],  TemporaryBooting USING [BootButton],  TIP USING [CreateClient, globalTable, SetTable],  Token USING [    FileName, Filtered, FreeStringHandle, FreeTokenString, Handle,    StandardFilterState, StringToHandle],  ToolDriver USING [NoteSWsProcType, RemoveSWsProcType],  ToolWindow USING [    Activate, EnumerateInactiveWindows, EnumerateProcType, GetName],  UserInput USING [    GetDefaultWindow, UserAbort, WaitForConfirmation, WaitNoButtons],  UserTerminal USING [    GetState, hasBorder, screenHeight, screenWidth, SetBorder, SetState, State],  Window USING [Box, Handle, InitializeWindow, Place],  WindowFont USING [Initialize, Object, SetDefault];ControlUtilsA: PROGRAM  IMPORTS    CH, ConvertData, Cursor, Exec, ExecInternal, FileWindow, Heap, Menu, MFile, MScavenge,    ProcessorFace, Put, Runtime, Selection, SetTime, SpecialMFile,    SpecialSpace, SpecialWindow, String, Supervisor, System, TajoFont, TajoOps,    TemporaryBooting, TIP, Token, ToolWindow, UserInput,    UserTerminal, Window, WindowFont  EXPORTS Event, TajoMisc, TajoOps, ToolDriver =  BEGIN  zone: PUBLIC UNCOUNTED ZONE ¬ Heap.Create[    initial: 1, maxSize: 10, swapUnitSize: 1];  swapping, aboutToSwap, tajoDefaults, primaryCredentials, fileWindow,  toolWindow, powerOff, displayState, spare1, spare2, spare3, spare4, spare5:    PUBLIC Supervisor.SubsystemHandle;  lastLoaded: MLoader.Handle ¬ NIL;  tmMenu: Menu.Handle ¬ NIL;  font: WindowFont.Object;  scavengeCursor: Cursor.Object ¬ [    [last, 8, 8], [    076074B, 143146B, 140140B, 076140B, 003140B, 143146B, 076074B, 000000B,     000000B, 034303B, 076303B, 143146B, 143146B, 177074B, 143030B, 143030B]];  StartPhase1: PUBLIC PROCEDURE [short, long: CARDINAL ¬ 0] =    BEGIN  -- won't expand mds guy for tajo or copilot    savedMP: CARDINAL ¬ LAST[CARDINAL];    IF UserTerminal.hasBorder THEN UserTerminal.SetBorder[210B, 42B];    -- IF long # 0 THEN Heap.Expand[Heap.systemZone, long];    SetTimeIfNecessary[];  -- Make sure clock is okay BEFORE creating files    CreateSupervisorSubsystemHandles[];    Window.InitializeWindow[      @theRoot.window, NIL,      [[0, 0], [UserTerminal.screenWidth, UserTerminal.screenHeight]]];    InitRoot[];    -- Lock down code that should not swap to avoid losing user actions    SpecialSpace.MakeProcedureResident[TajoOps.ProcessUserActions];    SpecialSpace.MakeGlobalFrameResident[      Runtime.GlobalFrame[LOOPHOLE[TajoOps.ProcessUserActions]]];    TajoOps.StartStimulusLevel[];    -- Turn display on and set up windows    [] ¬ SetState[on];    Cursor.Set[hourGlass];    font.address ¬ Runtime.GetTableBase[Runtime.GlobalFrame[TajoFont]];    WindowFont.Initialize[@font];    WindowFont.SetDefault[@font];    {    ENABLE      MScavenge.StartingScavenge => {        -- start trap of FileSystem may raise this signal	cursorCopy: Cursor.Object ¬ scavengeCursor;        savedMP ¬ ProcessorFace.mp;        ProcessorFace.SetMP[9950];        Cursor.Store[@cursorCopy];        RESUME        };    MFile.InitializeFileSystem[];    SpecialMFile.RegisterWithSupervisor[]};  -- this must be done separately so that the testbed can run without Tajo's supervisor handles    IF savedMP # LAST[CARDINAL] THEN ProcessorFace.SetMP[savedMP];    TIP.CreateClient[window: @theRoot.window]; -- make sure it is started before using TIP.globalTable    [] ¬ TIP.SetTable[window: @theRoot.window, table: TIP.globalTable[root]];    Menu.SetFont[@font];    Cursor.Set[hourGlass];    ConvertData.ConvertDataFiles[]; -- assimilate pilot files left by installer into MFile system    TajoOps.SetInitialToolStateDefault[inactive];    TajoOps.ProcessUserCm[];    END;  StartPhase2: PUBLIC PROCEDURE =    BEGIN    StartCH[];    TajoOps.ProcessInitialCommandLine[];    TajoOps.RunCascadeNub[];    StartToolManager[];    TajoOps.SetInitialToolStateDefault[active];    END;  StartCH: PROCEDURE = INLINE -- need to start CH because of existing CH bug;    BEGIN    IF Runtime.IsBound[LOOPHOLE[CH.MakeRhs]] THEN      BEGIN      rhs: CH.Buffer ¬ CH.MakeRhs[1, Heap.systemZone];      CH.FreeRhs[rhs, Heap.systemZone];      END;    END;  CreateSupervisorSubsystemHandles: PROCEDURE =    BEGIN    swapping ¬ Supervisor.CreateSubsystem[];    aboutToSwap ¬ Supervisor.CreateSubsystem[];    tajoDefaults ¬ Supervisor.CreateSubsystem[];    primaryCredentials ¬ Supervisor.CreateSubsystem[];    fileWindow ¬ Supervisor.CreateSubsystem[];    toolWindow ¬ Supervisor.CreateSubsystem[];    powerOff ¬ Supervisor.CreateSubsystem[];    displayState ¬ Supervisor.CreateSubsystem[];    spare1 ¬ Supervisor.CreateSubsystem[];    spare2 ¬ Supervisor.CreateSubsystem[];    spare3 ¬ Supervisor.CreateSubsystem[];    spare4 ¬ Supervisor.CreateSubsystem[];    spare5 ¬ Supervisor.CreateSubsystem[];    END;  -- Window support  theRoot: TajoOps.WindowObject ¬ [window: NULL];  InitRoot: PUBLIC PROCEDURE = {    SpecialWindow.DefineRoot[@theRoot.window, , FALSE]};  SetState: PUBLIC PROCEDURE [new: UserTerminal.State]    RETURNS [old: UserTerminal.State] = {    officeTalk: ARRAY [0..4) OF CARDINAL ¬ [104210B, 104210B, 021042B, 021042B];    old ¬ UserTerminal.GetState[];    IF old = new THEN RETURN;    IF new = disconnected THEN      SpecialWindow.DefineRoot[@theRoot.window, officeTalk, FALSE];    IF old = disconnected THEN {      [] ¬ UserTerminal.SetState[off];      SpecialWindow.DefineRoot[@theRoot.window, officeTalk, TRUE]};    [] ¬ UserTerminal.SetState[new]};  -- ToolDriver support  toolDriverRunning: PUBLIC BOOLEAN ¬ FALSE;    noteSWs: ToolDriver.NoteSWsProcType ¬ NopNoteSWs;  removeSWs: ToolDriver.RemoveSWsProcType ¬ NopRemoveSWs;  NopNoteSWs: ToolDriver.NoteSWsProcType = BEGIN END;  NopRemoveSWs: ToolDriver.RemoveSWsProcType = BEGIN END;  SetToolDriverRunning: PUBLIC PROCEDURE [sense: BOOLEAN] = {    toolDriverRunning ¬ sense};    NoteSWs: PUBLIC ToolDriver.NoteSWsProcType =    BEGIN noteSWs[tool, subwindows]; END;  RemoveSWs: PUBLIC ToolDriver.RemoveSWsProcType = BEGIN removeSWs[tool]; END;  SetSWsProcs: PUBLIC PROCEDURE [    noteSWsProc: ToolDriver.NoteSWsProcType,    removeSWsProc: ToolDriver.RemoveSWsProcType] =    BEGIN noteSWs ¬ noteSWsProc; removeSWs ¬ removeSWsProc; END;  SetTimeIfNecessary: PROCEDURE =    BEGIN    savedMP: CARDINAL = ProcessorFace.mp;    build: LONG CARDINAL = Runtime.GetBuildTime[];    FiveYears: LONG CARDINAL = LONG[3600]*24*365*5;    now: LONG CARDINAL = System.GetGreenwichMeanTime[];    BEGIN  -- to keep savedMP in scope    [] ¬ System.GetLocalTimeParameters[      ! System.LocalTimeParametersUnknown => GOTO mustSet];    IF ~(now IN (build..build + FiveYears]) THEN {      [] ¬ SetTime.Set[]; ProcessorFace.SetMP[savedMP]};    EXITS      mustSet =>        BEGIN        UNTIL SetTime.Set[] DO	  ProcessorFace.SetMP[PilotMP.cTimeNotAvailable] ENDLOOP;        ProcessorFace.SetMP[savedMP];        END;    END;    END;  -- Former TajoExec code  MenuIndex: TYPE = {    fileWindow, run, load, start, newExec, quit, powerOff, coPilot};  Quit: PUBLIC PROCEDURE [powerOff: BOOLEAN ¬ FALSE] =    BEGIN    IF powerOff THEN TurnOff[]    ELSE      BEGIN      result: {allOk, notifyClients, notifyBoth} ¬ allOk;      Supervisor.NotifyDirectSubsystems[        event: EventTypes.aboutToBootPhysicalVolume, 	which: clients, subsystem: aboutToSwap !        Supervisor.EnumerationAborted => {result ¬ notifyClients; CONTINUE}];      Supervisor.NotifyDirectSubsystems[        event: EventTypes.aboutToBootPhysicalVolume, 	which: implementors, subsystem: aboutToSwap        ! Supervisor.EnumerationAborted => {	  result ¬ notifyBoth; CONTINUE}];      IF result = allOk THEN         BEGIN        Supervisor.NotifyDirectSubsystems[          event: EventTypes.bootPhysicalVolume, 	  which: clients, subsystem: swapping !          Supervisor.EnumerationAborted => CONTINUE];        Supervisor.NotifyDirectSubsystems[          event: EventTypes.bootPhysicalVolume, 	  which: implementors, subsystem: swapping          ! Supervisor.EnumerationAborted => CONTINUE];	TemporaryBooting.BootButton[];	END      ELSE {        IF result = notifyBoth THEN          Supervisor.NotifyDirectSubsystems[            event: EventTypes.bootPhysicalVolumeCancelled,             which: implementors, subsystem: swapping];        Supervisor.NotifyDirectSubsystems[          event: EventTypes.bootPhysicalVolumeCancelled,           which: clients, subsystem: swapping]};      END;    END;  TurnOff: PROC = {    Supervisor.NotifyDirectSubsystems[      event: EventTypes.powerOff, which: clients, subsystem: powerOff];    Supervisor.NotifyDirectSubsystems[      event: EventTypes.powerOff, which: implementors, subsystem: powerOff];    System.PowerOff[]};  MenuMCR: Menu.MCRType =    BEGIN    mIndex: MenuIndex = LOOPHOLE[index];    SELECT mIndex FROM      load, run, start =>        BEGIN        CheckAbort: PROC RETURNS [abort: BOOLEAN] = {          RETURN[UserInput.UserAbort[window]]};        WriteText: Format.StringProc = {Put.LongString[NIL, s]};        h: Token.Handle ¬ SelectionAsToken[];        IF h # NIL THEN          BEGIN          SELECT mIndex FROM            load =>              BEGIN	      data: Token.StandardFilterState;              name: LONG STRING ¬ Token.Filtered[                h, @data, Token.FileName, whiteSpace];              IF name # NIL THEN                BEGIN                codelinks: BOOLEAN ¬ FALSE;                IF h.break = '/ THEN                  DO                    SELECT (h.break ¬ h.getChar[h]) FROM                      'l, 'L => codelinks ¬ TRUE;                      IN ['a..'z], IN ['A..'Z] => NULL;                      ENDCASE => EXIT;                    ENDLOOP;                lastLoaded ¬ Exec.Load[WriteText, name, codelinks];                name ¬ Token.FreeTokenString[name];                END;              END;            run => Exec.Run[h, WriteText, CheckAbort];            start =>              IF lastLoaded = NIL THEN WriteText["Nothing loaded!"L]              ELSE Exec.Start[lastLoaded];            ENDCASE => WriteText["Sorry: unimplemented operation."L];          h ¬ Token.FreeStringHandle[h]          END;        END;      coPilot, powerOff, quit =>        BEGIN        Cursor.Set[mouseRed];        IF UserInput.WaitForConfirmation[].okay THEN          SELECT mIndex FROM            coPilot => Runtime.CallDebugger["You called?"L];            powerOff, quit => Quit[mIndex = powerOff];            ENDCASE;        Cursor.Set[textPointer];        UserInput.WaitNoButtons[];        END;      fileWindow => [] ¬ FileWindow.CreateMCR[window];      newExec => {        prog: PROGRAM;	execName: LONG STRING = "Executive"L;	exec: String.SubStringDescriptor ¬ [execName, 0, execName.length];	w: Window.Handle ¬ NIL;	FindExec: ToolWindow.EnumerateProcType = {	  name: LONG STRING ¬ ToolWindow.GetName[window];	  thisName: String.SubStringDescriptor ¬ [name, 0, execName.length];	  IF ~(name.length < execName.length) AND	     String.EquivalentSubString[@exec, @thisName] THEN {	      w ¬ window; done ¬ TRUE}	  ELSE done ¬ FALSE;	  Heap.systemZone.FREE[@name]};	ToolWindow.EnumerateInactiveWindows[FindExec];	IF w # NIL THEN ToolWindow.Activate[w]        ELSE {prog ¬ NEW ExecInternal.SimpleExec; START prog}};      ENDCASE;    END;  SelectionAsToken: PUBLIC PROCEDURE RETURNS [h: Token.Handle] =    BEGIN    s: LONG STRING ¬ Selection.Convert[string];    h ¬ IF s = NIL THEN NIL ELSE Token.StringToHandle[s];    END;  StartToolManager: PUBLIC PROCEDURE =    BEGIN    dw: Window.Handle = UserInput.GetDefaultWindow[];    strings: ARRAY MenuIndex OF LONG STRING ¬ [      run: "Run"L, load: "Load"L, start: "Start"L, quit: "Quit"L,      powerOff: "Power Off"L, coPilot: "CallDebug"L, fileWindow: "FileWindow"L,      newExec: "New Exec"L];    tmMenu ¬ Menu.Make[      name: "Exec Ops"L, strings: DESCRIPTOR[LONG[@strings], LENGTH[strings]],      mcrProc: MenuMCR, copyStrings: TRUE, permanent: TRUE];    Menu.Instantiate[tmMenu, dw];    END;  END.  -- of ControlUtilsA
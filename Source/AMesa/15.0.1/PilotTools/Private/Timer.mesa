-- Copyright (C) 1983, 1985, 1986, 1987  by Xerox Corporation. All rights reserved. -- Timer.mesa edited by: CJS  16-Feb-87 15:17:34DIRECTORY  Ascii USING [SP],  BackingStore USING [Data, Run, TransferProc],  Command USING [Action, Entry, InstallTopLevel, Loop, QuitLevel, Scan],  Environment USING [PageCount, PageFromLongPointer, wordsPerPage],  Exec USING [OutputProc],  File USING [Create, Delete, File, ID, nullFile, PageCount, PageNumber],  FileBasicsPerf USING [BeginOperationSequence, EndOperationSequence],  FileTypes USING [FileType],  Format USING [LongNumber, Number, NumberFormat, StringProc],  PilotCommand USING [defaultWindow, StorageCatch],  Space USING [    Allocate, Deactivate, Deallocate, InsufficientSpace, Interval,    MapAt, PageCount, PageFromLongPointer, ScratchMap, Unmap, UnmapAt, Window],  SpacePerf USING [nCreatedDataFiles],  SpecialFile USING [GetBackingStoreRun],  SpecialSpace USING [    MakeEntryVectorResident, MakeEntryVectorSwappable,    MakeGlobalFrameResident, MakeGlobalFrameSwappable, MakeProcedureResident,    MakeProcedureSwappable, SpecialError],  System USING [GetClockPulses, Pulses, PulsesToMicroseconds],  TTY USING [    Handle, GetLongNumber, GetNumber, PutChar, PutCR, PutLongNumber, PutNumber,    PutString],  VM USING [Map, Unmap],  Volume USING [ID, InsufficientSpace, systemID];Timer: PROGRAM  IMPORTS    Command, Environment, Exec, File, FileBasicsPerf, Format, PilotCommand, Space,    SpacePerf, SpecialFile, SpecialSpace, System, TTY, VM, Volume =  BEGIN    entries: ARRAY [0..20)  OF Command.Entry ¬ [    ["Commands", RunInLoop],  -- Must be first    ["File Ops Varying Sizes", FileCreateDeleteVarying],    ["File Ops Uniform Size", FileCreateDeleteUniform],    ["Map To Data Space", MapToDataSpace],    ["Map To File", MapToFile],    ["Page Fault Timing", PageFault],    ["Set Data Space Size", ChangeDataSpaceSize],    ["Set Data Space Mappings", ChangeDataSpaceMappings],    ["Set File Size", ChangeFileSize],    ["Set File Create/Delete", ChangeFileCreateDeletes],    ["Set File Mappings", ChangeFileMappings],    ["Set Page Fault Faults Per Pass", ChangePageFaultsEachPass],    ["Set Page Fault Mode", ChangePageFaultMode],    ["Set Page Fault Passes", ChangePageFaultPasses],    ["Set Space Allocate/Deallocate Spaces", ChangeSpaceAllocatesDeletes],    ["Set Space Uniform Allocate/Deallocate Space Size",      ChangeSpaceAllocateSize],     ["Set Stall ForceOuts", SetStallForceOuts],    ["Space Allocation Uniform Sizes", SpaceAllocationUniform],    ["Space Allocation Varying Sizes", SpaceAllocationVarying],    ["quit", Command.QuitLevel]];  -- Must be last  -- Parameters for commands.  -- Settable from debugger and from commands    fileSize: File.PageCount ¬ 30;    numberFileCreateDeletes: CARDINAL ¬ 100;    numberSpaceAllocatesDeletes: CARDINAL ¬ 100;    numberFileMappings: CARDINAL ¬ 100;    numberPageFaultPasses: CARDINAL ¬ 200;    numberFaultsEachPass: CARDINAL ¬ 5;    pageFaultMode: {disk, noDisk} ¬ disk;    numberDataSpaceMappings: CARDINAL ¬ 50;    sizeDataSpace: CARDINAL ¬ 5;    stallForceOuts: BOOLEAN ¬ FALSE;    spaceAllocateUniformSize: Space.PageCount ¬ 25;    h: TTY.Handle ¬ PilotCommand.defaultWindow;  RunInLoop: Command.Action =    {Command.Loop[h, DESCRIPTOR[@entries[1], LENGTH[entries]-1],      PilotCommand.StorageCatch, "Timer "L]};  ChangeFileSize: Command.Action =    BEGIN    TTY.PutString[h, " - New File Size: "L];    fileSize ¬ TTY.GetLongNumber[h, fileSize, 10];    END;  ChangeFileCreateDeletes: Command.Action =    BEGIN    TTY.PutString[h, " - New # File Create/Deletes: "L];    numberFileCreateDeletes ¬ TTY.GetNumber[h, numberFileCreateDeletes, 10];    END;  ChangeSpaceAllocatesDeletes: Command.Action =    BEGIN    TTY.PutString[h, " - New # Space Allocate/Deallocates: "L];    numberSpaceAllocatesDeletes ¬      TTY.GetNumber[h, numberSpaceAllocatesDeletes, 10];    END;  ChangeFileMappings: Command.Action =    BEGIN    TTY.PutString[h, " - New # File mappings: "L];    numberFileMappings ¬ TTY.GetNumber[h, numberFileMappings, 10];    END;  ChangePageFaultPasses: Command.Action =    BEGIN    TTY.PutString[h, " - New # page fault passes: "L];    numberPageFaultPasses ¬ TTY.GetNumber[h, numberPageFaultPasses, 10];    END;  ChangePageFaultsEachPass: Command.Action =    BEGIN    TTY.PutString[h, " - New # page faults/pass: "L];    numberFaultsEachPass ¬ TTY.GetNumber[h, numberFaultsEachPass, 10];    END;  ChangePageFaultMode: Command.Action =    BEGIN    TTY.PutString[h, " Mode is now "L];    SELECT pageFaultMode FROM      disk => {pageFaultMode ¬ noDisk; TTY.PutString[h, "noDisk"L]};      noDisk => {pageFaultMode ¬ disk; TTY.PutString[h, "disk"L]};      ENDCASE =>        {pageFaultMode ¬ disk; TTY.PutString[h, "unknown - setting to disk"L]};    END;  ChangeDataSpaceMappings: Command.Action =    BEGIN    TTY.PutString[h, " - New # data space maps: "L];    numberDataSpaceMappings ¬ TTY.GetNumber[h, numberDataSpaceMappings, 10];    END;  ChangeDataSpaceSize: Command.Action =    BEGIN    TTY.PutString[h, " - New size of data space maps: "L];    sizeDataSpace ¬ TTY.GetNumber[h, sizeDataSpace, 10];    END;    ChangeSpaceAllocateSize: Command.Action =    BEGIN    TTY.PutString[h, " - New space size for uniform space allocates: "L];    spaceAllocateUniformSize ¬ TTY.GetLongNumber[h, spaceAllocateUniformSize, 10];    END;  FileCreateDeleteVarying: Command.Action =    BEGIN    format: Format.NumberFormat ¬ [];    volume: Volume.ID = Volume.systemID;    start, total: System.Pulses ¬ [0];    fileListPages: Environment.PageCount ¬      (numberFileCreateDeletes*SIZE[File.ID])/Environment.wordsPerPage+1;    fileList: LONG POINTER TO ARRAY OF File.ID ¬       Space.Allocate[fileListPages].pointer;    VM.Map[  -- Resident Map      interval: [Space.PageFromLongPointer[fileList], fileListPages],      transferProc: NIL, backingStoreRuns: NIL, swapUnits: [unitary[]],      life: dead, swappability: resident];    TTY.PutCR[h];    TTY.PutString[h, "  Testing with "L];    TTY.PutNumber[h, numberFileCreateDeletes, format];    TTY.PutString[h, " files of increasing size."L];    TTY.PutCR[h];    TTY.PutString[h, "    forceouts are "L];    TTY.PutString[h, IF stallForceOuts THEN "off"L ELSE "on"L];    IF stallForceOuts THEN FileBasicsPerf.BeginOperationSequence[volume];    BEGIN ENABLE      ANY =>        BEGIN	IF stallForceOuts THEN FileBasicsPerf.EndOperationSequence[volume];	REJECT	END;    FOR i: CARDINAL IN [0..numberFileCreateDeletes) DO      start ¬ System.GetClockPulses[];      fileList[i] ¬        File.Create[volume, i+1, FileTypes.FileType[20000] !	  Volume.InsufficientSpace =>	    BEGIN	    FOR j: CARDINAL IN [0..i) DO	      File.Delete[[fileList[j], volume]]	      ENDLOOP;	    REJECT;	    END].fileID;      total ¬ [total+(System.GetClockPulses[] - start)];      ENDLOOP;    TTY.PutCR[h];    TTY.PutString[      h, "   Average File Create time (microseconds): "L];    TTY.PutLongNumber[      h, System.PulsesToMicroseconds[total]/numberFileCreateDeletes, format];    start ¬ System.GetClockPulses[];    FOR i: CARDINAL IN [0..numberFileCreateDeletes) DO      File.Delete[[fileList[i], volume]];      ENDLOOP;    total ¬ [System.GetClockPulses[] - start];    END;    IF stallForceOuts THEN FileBasicsPerf.EndOperationSequence[volume];    TTY.PutCR[h];    TTY.PutString[h, "   Average Delete time (microseconds): "L];    TTY.PutLongNumber[      h, System.PulsesToMicroseconds[total]/numberFileCreateDeletes, format];    [] ¬ VM.Unmap[Space.PageFromLongPointer[fileList]];    Space.Deallocate[[fileList, fileListPages]];    END;  FileCreateDeleteUniform: Command.Action =    BEGIN    format: Format.NumberFormat ¬ [];    volume: Volume.ID ¬ Volume.systemID;    start, total: System.Pulses ¬ [0];    fileListPages: Environment.PageCount ¬      (numberFileCreateDeletes*SIZE[File.ID])/Environment.wordsPerPage+1;    fileList: LONG POINTER TO ARRAY OF File.ID ¬       Space.Allocate[fileListPages].pointer;    VM.Map[  -- Resident Map      interval: [Space.PageFromLongPointer[fileList], fileListPages],      transferProc: NIL, backingStoreRuns: NIL, swapUnits: [unitary[]],      life: dead, swappability: resident];    TTY.PutCR[h];    TTY.PutString[h, "  Testing with "L];    TTY.PutNumber[h, numberFileCreateDeletes, format];    TTY.PutString[h, " files, all of size "L];    TTY.PutLongNumber[h, fileSize, format];    TTY.PutCR[h];    TTY.PutString[h, "    forceouts are "L];    TTY.PutString[h, IF stallForceOuts THEN "off"L ELSE "on"L];    IF stallForceOuts THEN FileBasicsPerf.BeginOperationSequence[volume];    BEGIN ENABLE      ANY =>        BEGIN	IF stallForceOuts THEN FileBasicsPerf.EndOperationSequence[volume];	REJECT	END;    FOR i: CARDINAL IN [0..numberFileCreateDeletes) DO      start ¬ System.GetClockPulses[];      fileList[i] ¬        File.Create[volume, fileSize, FileTypes.FileType[20000] !	  Volume.InsufficientSpace =>	    BEGIN	    FOR j: CARDINAL IN [0..i) DO	      File.Delete[[fileList[j], volume]]	      ENDLOOP;	    REJECT;	    END].fileID;      total ¬ [total+(System.GetClockPulses[] - start)];      ENDLOOP;    TTY.PutCR[h];    TTY.PutString[      h, "   Average File Create time (microseconds): "L];    TTY.PutLongNumber[      h, System.PulsesToMicroseconds[total]/numberFileCreateDeletes, format];    start ¬ System.GetClockPulses[];    FOR i: CARDINAL IN [0..numberFileCreateDeletes) DO      File.Delete[[fileList[i], volume]];      ENDLOOP;    IF stallForceOuts THEN FileBasicsPerf.EndOperationSequence[volume];    END;    total ¬ [System.GetClockPulses[] - start];    TTY.PutCR[h];    TTY.PutString[h, "   Average Delete time (microseconds): "L];    TTY.PutLongNumber[      h, System.PulsesToMicroseconds[total]/numberFileCreateDeletes, format];    [] ¬ VM.Unmap[Space.PageFromLongPointer[fileList]];    Space.Deallocate[[fileList, fileListPages]];    END;     SpaceAllocationUniform: Command.Action =    BEGIN    format: Format.NumberFormat ¬ [];    start, total: System.Pulses ¬ [0];    spaceArrayPages: Environment.PageCount ¬       (numberSpaceAllocatesDeletes*SIZE[Space.Interval])       /Environment.wordsPerPage+1;    spaceArray: LONG POINTER TO ARRAY OF Space.Interval ¬       Space.Allocate[spaceArrayPages].pointer;    VM.Map[  -- Resident Map      interval: [Space.PageFromLongPointer[spaceArray], spaceArrayPages],      transferProc: NIL, backingStoreRuns: NIL, swapUnits: [unitary[]],      life: dead, swappability: resident];    TTY.PutCR[h];    TTY.PutString[h, "   Testing with "L];    TTY.PutNumber[h, numberSpaceAllocatesDeletes, format];    TTY.PutString[h, " spaces, each of size "L];    TTY.PutLongNumber[h, spaceAllocateUniformSize, format];    start ¬ System.GetClockPulses[];    FOR i: CARDINAL IN [0..numberSpaceAllocatesDeletes) DO      spaceArray[i] ¬ Space.Allocate[count: spaceAllocateUniformSize !        Space.InsufficientSpace =>	  BEGIN	  FOR j: CARDINAL IN [0..i) DO	    [] ¬ Space.Deallocate[spaceArray[j]];	    ENDLOOP;	  REJECT;	  END];      ENDLOOP;    total ¬ [System.GetClockPulses[] - start];    TTY.PutCR[h];    TTY.PutString[h, "   Average Allocate time (microseconds): "L];    TTY.PutLongNumber[      h, System.PulsesToMicroseconds[total]/numberSpaceAllocatesDeletes, format];    start ¬ System.GetClockPulses[];    FOR i: CARDINAL IN [0..numberSpaceAllocatesDeletes) DO      [] ¬ Space.Deallocate[spaceArray[i]];      ENDLOOP;    total ¬ [System.GetClockPulses[] - start];    TTY.PutCR[h];    TTY.PutString[h, "   Average Deallocate time (microseconds): "L];    TTY.PutLongNumber[      h, System.PulsesToMicroseconds[total]/numberSpaceAllocatesDeletes, format];    [] ¬ VM.Unmap[Space.PageFromLongPointer[spaceArray]];    Space.Deallocate[[spaceArray, spaceArrayPages]];    END;   SpaceAllocationVarying: Command.Action =    BEGIN    format: Format.NumberFormat ¬ [];    start, total: System.Pulses ¬ [0];    spaceArrayPages: Environment.PageCount ¬       (numberSpaceAllocatesDeletes*SIZE[Space.Interval])       /Environment.wordsPerPage+1;    spaceArray: LONG POINTER TO ARRAY OF Space.Interval ¬       Space.Allocate[spaceArrayPages].pointer;    VM.Map[  -- Resident Map      interval: [Space.PageFromLongPointer[spaceArray], spaceArrayPages],      transferProc: NIL, backingStoreRuns: NIL, swapUnits: [unitary[]],      life: dead, swappability: resident];    TTY.PutCR[h];    TTY.PutString[h, "   Testing with "L];    TTY.PutNumber[h, numberSpaceAllocatesDeletes, format];    TTY.PutString[h, " spaces."L];    start ¬ System.GetClockPulses[];    FOR i: CARDINAL IN [0..numberSpaceAllocatesDeletes) DO      spaceArray[i] ¬ Space.Allocate[count: i+1 !        Space.InsufficientSpace =>	  BEGIN	  FOR j: CARDINAL IN [0..i) DO	    [] ¬ Space.Deallocate[spaceArray[j]];	    ENDLOOP;	  REJECT;	  END];      ENDLOOP;    total ¬ [System.GetClockPulses[] - start];    TTY.PutCR[h];    TTY.PutString[h, "   Average Allocate time (microseconds): "L];    TTY.PutLongNumber[      h, System.PulsesToMicroseconds[total]/numberSpaceAllocatesDeletes, format];    start ¬ System.GetClockPulses[];    FOR i: CARDINAL IN [0..numberSpaceAllocatesDeletes) DO      [] ¬ Space.Deallocate[spaceArray[i]];      ENDLOOP;    total ¬ [System.GetClockPulses[] - start];    TTY.PutCR[h];    TTY.PutString[h, "   Average Deallocate time (microseconds): "L];    TTY.PutLongNumber[      h, System.PulsesToMicroseconds[total]/numberSpaceAllocatesDeletes, format];    [] ¬ VM.Unmap[Space.PageFromLongPointer[spaceArray]];    Space.Deallocate[[spaceArray, spaceArrayPages]];    END;  MapToFile: Command.Action =    BEGIN    format: Format.NumberFormat ¬ [];    startMap, startUnmap, totalMap, totalUnmap: System.Pulses ¬ [0];    file: File.File ¬ File.Create[      volume: Volume.systemID, initialSize: fileSize,      type: FileTypes.FileType[20000]];    space: Space.Interval ¬ Space.Allocate[count: fileSize];    TTY.PutCR[h];    BEGIN -- Now print out the map of the file    currentPage: File.PageNumber;        TTY.PutCR[h];    TTY.PutString[h, "  File    Run    Backing Store Data"L];TTY.PutCR[h];    TTY.PutString[h, "  Page   Size"L];TTY.PutCR[h];    currentPage ¬ 1;    WHILE currentPage < fileSize DO      run: BackingStore.Run ¬        SpecialFile.GetBackingStoreRun[	  file, currentPage, FileTypes.FileType[20000]].run;      TTY.PutLongNumber[h, currentPage, [columns: 6]];      TTY.PutLongNumber[h, run.count, [columns: 7]];      TTY.PutString[h, "    "L];      FOR i: CARDINAL IN [0.. SIZE[BackingStore.Data]) DO        TTY.PutNumber[h, run.data.data[i], [base: 8, columns: 6]];	ENDLOOP;      TTY.PutCR[h];      currentPage ¬ currentPage+run.count      ENDLOOP;    END; -- Now print out the map of the file    TTY.PutString[h, "   Testing with "L];    TTY.PutNumber[h, numberFileMappings, format];    TTY.PutString[h, " maps"L];    FOR i: CARDINAL IN [0..numberFileMappings) DO      startMap ¬ System.GetClockPulses[];      [] ¬ Space.MapAt[at: space, window: [file, 0, fileSize]];      totalMap ¬ [totalMap +        System.Pulses[(startUnmap ¬ System.GetClockPulses[]) - startMap]];      [] ¬ Space.UnmapAt[space.pointer, wait];      totalUnmap ¬ [totalUnmap +        System.Pulses[System.GetClockPulses[] - startUnmap]];      ENDLOOP;    TTY.PutCR[h];    TTY.PutString[h, "   Average MapAt time (microseconds): "L];    TTY.PutLongNumber[      h, System.PulsesToMicroseconds[totalMap]/numberFileMappings, format];    TTY.PutCR[h];    TTY.PutString[h, "   Average UnmapAt time (microseconds): "L];    TTY.PutLongNumber[      h, System.PulsesToMicroseconds[totalUnmap]/numberFileMappings, format];    Space.Deallocate[space];    File.Delete[file];    END;  MapToDataSpace: Command.Action =    BEGIN    PrintMinAndMax: PROCEDURE =      BEGIN      TTY.PutCR[h];      TTY.PutString[h, "     Minimum time (microseconds): "L];      TTY.PutLongNumber[h, System.PulsesToMicroseconds[minTime], format];      TTY.PutCR[h];      TTY.PutString[h, "     Maximum time (microseconds): "L];      TTY.PutLongNumber[h, System.PulsesToMicroseconds[maxTime], format];      END;    emptyWindow: Space.Window ¬ [File.nullFile, 0, sizeDataSpace];    format: Format.NumberFormat ¬ [];    start, total: System.Pulses ¬ [0];    minTime: System.Pulses ¬ [LAST[LONG CARDINAL]];    maxTime: System.Pulses ¬ [0];    createdDataSpaces: CARDINAL ¬ SpacePerf.nCreatedDataFiles;    spaceArrayPages: Environment.PageCount ¬       (numberSpaceAllocatesDeletes*SIZE[Space.Interval])       /Environment.wordsPerPage+1;    spaceArray: LONG POINTER TO ARRAY OF Space.Interval ¬       Space.Allocate[spaceArrayPages].pointer;    VM.Map[  -- Resident Map      interval: [Space.PageFromLongPointer[spaceArray], spaceArrayPages],      transferProc: NIL, backingStoreRuns: NIL, swapUnits: [unitary[]],      life: dead, swappability: resident];    TTY.PutCR[h];    TTY.PutString[h, "   Testing with "L];    TTY.PutNumber[h, numberDataSpaceMappings, format];    TTY.PutString[h, " spaces, each of size "L];    TTY.PutNumber[h, sizeDataSpace, format];    FOR i: CARDINAL IN [0..numberDataSpaceMappings) DO      spaceArray[i] ¬ Space.Allocate[sizeDataSpace];      ENDLOOP;    FOR i: CARDINAL IN [0..numberDataSpaceMappings) DO      thisTime: System.Pulses;      start ¬ System.GetClockPulses[];      [] ¬ Space.MapAt[at: spaceArray[i], window: emptyWindow];      thisTime ¬ [System.GetClockPulses[]-start];      total ¬ [total+thisTime];      minTime ¬ [MIN[minTime, thisTime]];      maxTime ¬ [MAX[maxTime, thisTime]];      ENDLOOP;    createdDataSpaces ¬ SpacePerf.nCreatedDataFiles - createdDataSpaces;    IF createdDataSpaces > 0 THEN      BEGIN      TTY.PutCR[h]; TTY.PutString[h, "  "L];      TTY.PutNumber[h, createdDataSpaces, format];      TTY.PutString[h, " data spaces required allocating a new file."L]      END;    TTY.PutCR[h];    TTY.PutString[h, "   Average data space MapAt time (microseconds): "L];    TTY.PutLongNumber[      h, System.PulsesToMicroseconds[total]/numberDataSpaceMappings, format];    PrintMinAndMax[];    minTime ¬ [LAST[LONG CARDINAL]];    maxTime ¬ [0];    total ¬ [0];    FOR i: CARDINAL IN [0..numberDataSpaceMappings) DO      thisTime: System.Pulses;      start ¬ System.GetClockPulses[];      [] ¬ Space.UnmapAt[spaceArray[i].pointer];      thisTime ¬ [System.GetClockPulses[]-start];      total ¬ [total+thisTime];      minTime ¬ [MIN[minTime, thisTime]];      maxTime ¬ [MAX[maxTime, thisTime]];      ENDLOOP;    TTY.PutCR[h];    TTY.PutString[h, "   Average data space UnmapAt time (microseconds): "L];    TTY.PutLongNumber[      h, System.PulsesToMicroseconds[total]/numberDataSpaceMappings, format];    PrintMinAndMax[];    FOR i: CARDINAL IN [0..numberDataSpaceMappings) DO      Space.Deallocate[spaceArray[i]];      ENDLOOP;    [] ¬ VM.Unmap[Space.PageFromLongPointer[spaceArray]];    Space.Deallocate[[spaceArray, spaceArrayPages]];    END;      PageFault: Command.Action =    BEGIN    MyBackingStore: BackingStore.TransferProc =      BEGIN      RETURN[[done[]]];      END;    procWasPinned: BOOLEAN;    gfWasPinned: BOOLEAN;    evWasPinned: BOOLEAN;    format: Format.NumberFormat ¬ [];    increment: CARDINAL ¬ 17;    maxTime, start, thisTime, totalTime: System.Pulses ¬ [0];    minTime: System.Pulses ¬ [LAST[LONG CARDINAL]];    p: LONG POINTER;    passes: CARDINAL ¬ 200;    throwaway: UNSPECIFIED;    TTY.PutCR[h];    TTY.PutString[h, "   Testing for "L];    TTY.PutNumber[h, numberPageFaultPasses * numberFaultsEachPass, format];    TTY.PutString[h, " faults  using "L];    SELECT pageFaultMode FROM      disk =>        BEGIN	TTY.PutString[h, " disk."L];	p ¬ Space.ScratchMap[count: 1];	END;      noDisk =>        BEGIN	run: ARRAY[0..1) OF BackingStore.Run ¬ TRASH;	TTY.PutString[h, " noDisk."L];	procWasPinned ¬ gfWasPinned ¬ evWasPinned ¬ FALSE;	SpecialSpace.MakeGlobalFrameResident[Timer !	  SpecialSpace.SpecialError => {gfWasPinned ¬ TRUE; CONTINUE}];	SpecialSpace.MakeProcedureResident[LOOPHOLE[MyBackingStore] !	  SpecialSpace.SpecialError => {procWasPinned ¬ TRUE; CONTINUE}];	SpecialSpace.MakeEntryVectorResident[LOOPHOLE[MyBackingStore] !	  SpecialSpace.SpecialError => {evWasPinned ¬ TRUE; CONTINUE}];	p ¬ Space.Allocate[1].pointer;	VM.Map[	  interval: [Environment.PageFromLongPointer[p], 1],	  transferProc: MyBackingStore,	  backingStoreRuns: DESCRIPTOR[run]];	END;      ENDCASE => {TTY.PutString[h, " BAD pageFaultMode - ABORTED"L]; RETURN};    -- Each pass forces a page fault, waiting a varying amount of disk rotation    -- between deactivate and read.    FOR i: CARDINAL IN [0..numberPageFaultPasses) DO      THROUGH [0..numberFaultsEachPass) DO  -- try each wait several times        k: LONG CARDINAL ¬ 0;        p­ ¬ i; -- dirty it to force I/O        Space.Deactivate[[p, 1]];        IF pageFaultMode = disk THEN	  THROUGH [0..i * increment) DO k ¬ k + 1 ENDLOOP;        start ¬ System.GetClockPulses[];        throwaway ¬ p­;        thisTime ¬ [System.GetClockPulses[] - start];        minTime ¬ [MIN[thisTime, minTime]];        maxTime ¬ [MAX[thisTime, maxTime]];	totalTime ¬ [totalTime+thisTime];        ENDLOOP;      ENDLOOP;    SELECT pageFaultMode FROM      disk =>p ¬ Space.Unmap[pointer: p, returnWait: return];      noDisk =>        BEGIN	IF ~ gfWasPinned THEN	  SpecialSpace.MakeGlobalFrameSwappable[Timer !	    SpecialSpace.SpecialError => CONTINUE];	IF ~ procWasPinned THEN	  SpecialSpace.MakeProcedureSwappable[LOOPHOLE[MyBackingStore] !	    SpecialSpace.SpecialError => CONTINUE];	IF ~ evWasPinned THEN	  SpecialSpace.MakeEntryVectorSwappable[LOOPHOLE[MyBackingStore] !	    SpecialSpace.SpecialError => CONTINUE];	VM.Unmap[Environment.PageFromLongPointer[p]];	Space.Deallocate[[p, 1]];	END;      ENDCASE;    TTY.PutCR[h];    TTY.PutString[h, "   Minimum page fault time (microseconds): "L];    TTY.PutLongNumber[h, System.PulsesToMicroseconds[minTime], format];    TTY.PutCR[h];    TTY.PutString[h, "   Maximum page fault time (microseconds): "L];    TTY.PutLongNumber[h, System.PulsesToMicroseconds[maxTime], format];    TTY.PutCR[h];    TTY.PutString[h, "   Average page fault time (microseconds): "L];    TTY.PutLongNumber[      h,      System.PulsesToMicroseconds[totalTime]/	(numberPageFaultPasses*numberFaultsEachPass), format];    TTY.PutCR[h];    END;    SetStallForceOuts: Command.Action =    BEGIN    stallForceOuts ¬ ~stallForceOuts;    TTY.PutString[h, " is now "L];    TTY.PutString[h, IF stallForceOuts THEN "TRUE"L ELSE "FALSE"L];    END;  TimerCmd: Command.Action =    BEGIN    TTY.PutChar[h, Ascii.SP];    Command.Scan[h, DESCRIPTOR[@entries[0], LENGTH[entries]-1],      PilotCommand.StorageCatch];    END;        Command.InstallTopLevel[h, ["Timer", TimerCmd]];  END.  LOG6-Mar-83 14:59:25	JP  Created file.13-Sep-83 14:34:53	CAJ  Added PageFault, fixed warnings, command list array descriptors.11-Nov-83 16:41:08	AWL  Implemented MapToDataSpace.  Parameterized all op'ns through globals.  Cleaned up output.29-Jan-85 14:37:09	AWL  Add noDisk mode to page fault timing test.10-Oct-86 12:18:43      RSV  Changed to initials.  Changed MapToDataSpace to reset minTime, maxTime, and total after first part of test.16-Feb-87 15:17:55	CJS	Add GetBackingStoreRuns in MapToFile.
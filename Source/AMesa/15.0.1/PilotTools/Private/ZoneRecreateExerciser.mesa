-- Copyright (C) 1983, 1985  by Xerox Corporation. All rights reserved. -- ZoneRecreateExerciser.mesa-- Last edit by RSV,  1-Nov-85 14:48:42-- For testing Zone.Recreate.  Works as follows:-- Create two zones of random size, one on which to operate and one as a control for checking the other.  Then, in each zone:-- Allocate one node and make it the root node-- Fill the zone with random-sized nodes chained together with relative pointers.  Put a random number somewhere in each node.  Node creation continues until zone is full-- Unmap the test zone-- WITHOUT deleting the zone's original space, create a new space.  This ensures that the new space will be at a different place in VM.-- Map the new space to the zone-- Trace through both the restored zone and its parallel, checking pointers and random vaules for consistency.DIRECTORY  Command USING [Action, Entry, InstallTopLevel, WriteError],  Environment USING [PageCount, wordsPerPage],  File USING [Create, Delete, File, nullFile, Type],  Heap USING [systemZone],  PilotCommand USING [defaultWindow],  RandomDefs USING [GeneratorState, Random, Randomize],  Runtime USING [CallDebugger],  Space USING [Deallocate, Interval, Map, Unmap, UnmapAt],  System USING [IsUtilityPilot],  TTY USING [    Handle, PutChar, PutCR, PutDecimal, PutLine, PutLongOctal, PutOctal,    PutString, UserAbort],  Volume USING [GetNext, GetStatus, ID, nullID, systemID],  Zone USING [    Alignment, Base, Create, Handle, MakeNode, minimumNodeSize, nil,    Recreate, SetRootNode, Status];ZoneRecreateExerciser: PROGRAM  IMPORTS    Command, File, Heap, PilotCommand, RandomDefs, Runtime, Space, TTY, Volume,    System, Zone =  BEGIN  ZoneDesc: TYPE = RECORD [    handle: Zone.Handle,    base: Zone.Base,    space: Space.Interval,    file: File.File,    root: Zone.Base RELATIVE POINTER,  -- ptr to root node    size: CARDINAL,    pages: Environment.PageCount];  -- zone size does not have to be an integral number of pages  NodePtr: TYPE = Zone.Base RELATIVE POINTER TO Node;  Node: TYPE = RECORD [seal: CARDINAL, next: Zone.Base RELATIVE POINTER];  testZone, controlZone: ZoneDesc;  pGen: LONG POINTER TO RandomDefs.GeneratorState;    volumeID: Volume.ID ¬ Volume.nullID;    minNodeSize: CARDINAL = Zone.minimumNodeSize - 1; -- 1 = ZoneImpl.nodeOverhead --  maxNodeSize: CARDINAL = 100;  minAlign: CARDINAL = LOOPHOLE[FIRST[Zone.Alignment]];  maxAlign: CARDINAL = LOOPHOLE[LAST[Zone.Alignment]];  firsta16Alignment: CARDINAL = 32;  -- first position for a16 alignment  -- this value may not work if size of headers increases.  minZoneSize: CARDINAL = firsta16Alignment + minNodeSize + 4;    -- 4 = (ZoneImpl.freeNodeSize + ZoneImpl.usedNodeSize) --  maxZoneSize: CARDINAL = 5000;  maxOffset: CARDINAL = 500;  cmdEntry: Command.Entry = [command: "exercise zone recreate", action: Run];  tty: TTY.Handle;  CreateZones: PROCEDURE =    -- Starting from scratch, make test and control zones    BEGIN    --baseOffset: CARDINAL;++ always zero for now    bogusFileType: File.Type ¬ [20000];    status: Zone.Status;    TTY.PutString[tty, "Creating zone, "L];    testZone.size ¬ controlZone.size ¬ Random[minZoneSize, maxZoneSize];    testZone.pages ¬ controlZone.pages ¬ PagesForWords[testZone.size];    controlZone.space ¬ Space.Map[[File.nullFile, 0, testZone.pages]];    testZone.file ¬ File.Create[      volumeID, testZone.pages, bogusFileType];    testZone.space ¬ Space.Map[[testZone.file, 0, testZone.pages]];    --baseOffset ¬    --Random[0, MIN[testZone.size-minZoneSize-minNodeSize, maxOffset]];    testZone.base ¬ testZone.space.pointer -- - baseOffset-- ;    controlZone.base ¬ controlZone.space.pointer -- - baseOffset-- ;    [testZone.handle, status] ¬ Zone.Create[      storage: testZone.space.pointer, length: testZone.size, zoneBase: testZone.base];    IF status # okay THEN Runtime.CallDebugger["Zone creation error"L];    [controlZone.handle, status] ¬ Zone.Create[      storage: controlZone.space.pointer, length: controlZone.size,      zoneBase: controlZone.base];    IF status # okay THEN Runtime.CallDebugger["Zone creation error"L];    TTY.PutString[tty, "base = "L];    TTY.PutLongOctal[tty, testZone.base];    TTY.PutString[tty, ", size = "L];    TTY.PutOctal[tty, testZone.size];    TTY.PutCR[tty];    END;  FillZones: PROCEDURE =    -- make root nodes for both zones, then fill with allocated nodes    BEGIN    nodeSize, nodeCount: CARDINAL;    alignment: Zone.Alignment;    testStatus, controlStatus: Zone.Status;    p: Zone.Base RELATIVE POINTER;    curTestNode, curControlNode, newTestNode, newControlNode: NodePtr;    TTY.PutString[tty, "Filling zone - "L];    nodeSize ¬ Random[minNodeSize, maxNodeSize];    alignment ¬ LOOPHOLE[Random[minAlign, maxAlign]];    [p, testStatus] ¬ Zone.MakeNode[testZone.handle, nodeSize, alignment];      WHILE (testStatus = noRoomInZone) DO        nodeSize ¬ Random[minNodeSize, maxNodeSize];	[p, testStatus] ¬ Zone.MakeNode[testZone.handle, nodeSize, alignment];	ENDLOOP;      IF testStatus # okay THEN        Runtime.CallDebugger["Unexpected status from MakeNode"L];    testZone.root ¬ curTestNode ¬ LOOPHOLE[p];    [p, controlStatus] ¬ Zone.MakeNode[controlZone.handle, nodeSize, alignment];    IF controlStatus # okay THEN      Runtime.CallDebugger["Unexpected status from MakeNode"L];    controlZone.root ¬ curControlNode ¬ LOOPHOLE[p];    testZone.base[curTestNode].next ¬ Zone.nil;    testZone.base[curTestNode].seal ¬ Random[0, LAST[CARDINAL]];    controlZone.base[curControlNode].next ¬ Zone.nil;    controlZone.base[curControlNode].seal ¬ testZone.base[curTestNode].seal;    Zone.SetRootNode[testZone.handle, testZone.root];    Zone.SetRootNode[controlZone.handle, controlZone.root];    nodeCount ¬ 1;    DO  -- until zones are full      nodeSize ¬ Random[minNodeSize, maxNodeSize];      alignment ¬ LOOPHOLE[Random[minAlign, maxAlign]];      [p, testStatus] ¬ Zone.MakeNode[testZone.handle, nodeSize, alignment];      SELECT testStatus FROM        okay => newTestNode ¬ LOOPHOLE[p];        noRoomInZone =>          BEGIN          [p, controlStatus] ¬ Zone.MakeNode[            controlZone.handle, nodeSize, alignment];          IF controlStatus # noRoomInZone THEN            Runtime.CallDebugger["Test zone filled up before control zone"L];          EXIT;          END;        ENDCASE => Runtime.CallDebugger["Unexpected status from MakeNode"L];      [p, controlStatus] ¬ Zone.MakeNode[controlZone.handle, nodeSize, alignment];      IF controlStatus # okay THEN        Runtime.CallDebugger["Unexpected status from MakeNode"L];      newControlNode ¬ LOOPHOLE[p];      testZone.base[curTestNode].next ¬ newTestNode;      curTestNode ¬ newTestNode;      testZone.base[curTestNode].next ¬ Zone.nil;      testZone.base[curTestNode].seal ¬ Random[0, LAST[CARDINAL]];      controlZone.base[curControlNode].next ¬ newControlNode;      curControlNode ¬ newControlNode;      controlZone.base[curControlNode].next ¬ Zone.nil;      controlZone.base[curControlNode].seal ¬ testZone.base[curTestNode].seal;      nodeCount ¬ nodeCount + 1;      ENDLOOP;    TTY.PutDecimal[tty, nodeCount];    TTY.PutLine[tty, " nodes"L];    END;  RelocateTestZone: PROCEDURE =    -- Unmap test zone, then map it to a different place and recreate it    BEGIN    --baseOffset: CARDINAL =    --Random[0, MIN[testZone.size-minZoneSize-minNodeSize, maxOffset]];    oldTestSpace: Space.Interval ¬ testZone.space;    TTY.PutString[tty, "Recreating zone, new base = "L];    [] ¬ Space.UnmapAt[oldTestSpace.pointer];    testZone.space ¬ Space.Map[[testZone.file, 0, testZone.pages]];    testZone.base ¬ testZone.space.pointer -- - baseOffset-- ;    [testZone.handle, testZone.root] ¬ Zone.Recreate[testZone.space.pointer, testZone.base];    Space.Deallocate[oldTestSpace];    TTY.PutLongOctal[tty, testZone.base];    TTY.PutCR[tty];    END;  CheckZones: PROCEDURE =    -- check that contents of test zone and control zone are identical    BEGIN    testNode: NodePtr ¬ testZone.root;    controlNode: NodePtr ¬ controlZone.root;    TTY.PutString[tty, "Checking consistency of recreated zone..."L];    DO      IF testZone.base[testNode].seal # controlZone.base[controlNode].seal THEN        Runtime.CallDebugger["Bad seal"L];      IF testZone.base[testNode].next # controlZone.base[controlNode].next THEN        Runtime.CallDebugger["Bad next ptr"L];      IF testZone.base[testNode].next = Zone.nil THEN EXIT;      testNode ¬ testZone.base[testNode].next;      controlNode ¬ controlZone.base[controlNode].next;      ENDLOOP;    TTY.PutLine[tty, "done"L];    END;  UnmapZones: PROCEDURE =    BEGIN    TTY.PutString[tty, "Deleting zones..."L];    [testZone.space.pointer] ¬ Space.Unmap[testZone.space.pointer];    File.Delete[testZone.file];    [controlZone.space.pointer] ¬ Space.Unmap[controlZone.space.pointer];    TTY.PutLine[tty, "done"L];    END;  PagesForWords: PROCEDURE [n: CARDINAL] RETURNS [Environment.PageCount] = {    RETURN[(n + Environment.wordsPerPage - 1)/Environment.wordsPerPage]};  Random: PROCEDURE [lowerBound, upperBound: CARDINAL] RETURNS [CARDINAL] =    BEGIN    biasedUpperBound: CARDINAL = upperBound - lowerBound;    n: CARDINAL = RandomDefs.Random[pGen, biasedUpperBound];    RETURN[n + lowerBound];    END;  Run: Command.Action =    BEGIN    tty ¬ h;    IF System.IsUtilityPilot[] THEN {      WHILE (volumeID ¬ Volume.GetNext[volumeID]) # Volume.nullID DO        IF Volume.GetStatus[volumeID] # openReadWrite THEN LOOP        ELSE EXIT;      ENDLOOP;      IF volumeID = Volume.nullID THEN {        Command.WriteError[tty, "No accessible volumes"L];        RETURN;};}    ELSE       volumeID ¬ Volume.systemID;    TTY.PutCR[tty];    TTY.PutLine[tty, "Type STOP key to stop"L];    pGen ¬ RandomDefs.Randomize[0];    UNTIL TTY.UserAbort[tty] DO      CreateZones[];      FillZones[];      RelocateTestZone[];      CheckZones[];      UnmapZones[];      ENDLOOP;    Heap.systemZone.FREE[@pGen];    END;  -- Mainline code  Command.InstallTopLevel[PilotCommand.defaultWindow, cmdEntry];      END..LOGTime: January 12, 1981  10:28 AM	By: RXG   	Created fileTime: February 9, 1981  6:15 PM	By: SXY     ZoneInternal is not imported anymoreTime: 8-Sep-81 17:06:20  	By: SXY         pGen is LONGifiedTime: 20-Jan-82 14:28:35	By: CAJ         New abort instruction stringTime: 25-Jan-83 15:48:25	By: RXJ         Storage => Heap.Time: 28-Jan-83 15:58:56	By: EKN   	Update to KlamathTime:  2-Jun-83 16:33:26	By: EKN   	bug fix: Create file with bogus file type instead of tAnonymous. (unmap deletes tAnonymous files).  Make minZoneSize bigger.Time: 26-Aug-85 13:53:02        By: RSV         bug fix: changed minNodeSize and minZoneSize.  Added firsta16Alignment.  Fixes infinite loop on a16 alignment and small zone size.Time:  1-Nov-85 14:48:58        By: RSV         fix crash with UtilityPilot by adding in choosing the first open volume if it is UtilityPilot.  (AR 8361)    
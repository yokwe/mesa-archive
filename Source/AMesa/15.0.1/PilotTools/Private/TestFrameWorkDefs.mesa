-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- TestFrameworkDefs.mesa       2-Mar-83 18:25:25 by LXD      --	Standard framework for implementing random-number-driven, model-based system tests.  Adapted from the Juniper ATest approach.DIRECTORY  File USING [File, Type],  FileTypes USING [TestFileType],  Stream USING [Handle],  Zone USING [BlockSize, Status];TestFrameworkDefs: DEFINITIONS =  BEGIN  testFileType: File.Type = [FileTypes.TestFileType[873]];  -- (an arbitrary number)  -- - - - - - - - Stable Storage Control: - - - - - - -  InitializeStableStorage: PROCEDURE [    backingFileName: LONG STRING, zonePages: CARDINAL, forceColdStart: BOOLEAN ¬ FALSE]    RETURNS [coldStart: BOOLEAN];  -- Sets up the stable storage zone.  If there is no file named backingFileName or if forceColdStart is TRUE, this routine creates a backing file and a new zone of size zonePages, and returns coldStart=TRUE.  Otherwise, it assumes that the file contains an old zone, restores and checks that zone, grows the backingFile and zone as necessary so that it contains at least zonePages, and returns coldStart=FALSE.  -- After initializing the zone, this routine calls each registered ColdStartProc or RestartProc (see below), depending on coldStart, and passes them the base for the zone.  SaveState: PROCEDURE[];  -- SaveState waits until all other processes are idle (that is, they have called AllowSaveState or SaveState), then calls each registered SaveStateProc, and then saves the current state of the stable storage on the disk.   WaitForAllProcessesIdle: PROCEDURE [thenDo: ThenDo];  ThenDo: TYPE = PROCEDURE[];  -- Waits until all processes which may be changing the state are idle, then calls thenDo, then returns, allowing the idle processes to continue with their normal tasks.  AllowSaveState: PROCEDURE[];  -- Called to signify that the stable storage may be saved now if anyone has so requested.  In other words, the caller is not now changing the state.  Must be called "fairly often" by every process which may alter the state (in a crash-recovery-interesting way).  FinalFinish: PROCEDURE[];  -- FinalFinish calls each registered FinalFinishProc (which should release its space in the stable storage zone or at least stop using it), then deletes the zone and its backing file.  Note that FinalFinish calls the various FinalFinishProcs in REVERSE order of registration.  This is because startup usually happens bottom-up, and cleanup top-down.  -- - - - - - - - Stable Storage Allocation: - - - - - - -  -- The stable storage facilities deals in relative pointers, which is the only thing that can be expected to remain stable over system restarts.  The "base" may vary over system boots, which will affect all absolute pointers.  Base: TYPE = LONG BASE POINTER TO UNSPECIFIED;  -- the type of the base pointer for the stable storage zone.  RelPtr: TYPE = Base RELATIVE POINTER;  RelString: TYPE = Base RELATIVE POINTER TO StringBody;  nil: READONLY RelPtr;  -- Use this in place of NIL!  BlockSize: TYPE = Zone.BlockSize;  -- [0..77777B]  -- Node and NewString allocate a node/string from the zone.  Node: PROCEDURE [nwords: CARDINAL] RETURNS [p: RelPtr];  NewString: PROCEDURE [nchars: CARDINAL] RETURNS [s: RelString];  -- ("String" would conflict with name of String interface.)  -- Free(Nil) and FreeString(Nil) deallocate a node/string from the zone.  Free: PROCEDURE [p: RelPtr];  FreeString: PROCEDURE [s: RelString];  FreeNodeNil: PROCEDURE [p: RelPtr] RETURNS [relNil: RelPtr] = INLINE {    Free[p]; RETURN[nil]};  FreeStringNil: PROCEDURE [s: RelString] RETURNS [relNil: RelString] = INLINE {    Free[s]; RETURN[nil]};  CopyString: PROCEDURE [s: LONG STRING, longer: CARDINAL ¬ 0]    RETURNS [newS: RelString];  -- CopyString allocates a new string, copying the contents of an existing string.  newS.maxlength ¬ s.length + longer.  SplitNode: PROCEDURE [p: RelPtr, n: BlockSize];  -- SplitNode deallocates part of a node, keeping the first "n" words.  -- The next 4 procs convert between pointers of various types.  The client should normally do absolute ¬ relative conversions manually, since it is easy and is more type-safe that way.  PtrFromRel: PROCEDURE [rel: RelPtr] RETURNS [ptr: LONG POINTER];  RelFromPtr: PROCEDURE [ptr: LONG POINTER] RETURNS [rel: RelPtr];  RelFromString: PROCEDURE [str: LONG STRING] RETURNS [rel: RelPtr] = INLINE {    RETURN[RelFromPtr[str]]};  StringFromRel: PROCEDURE [rel: RelString] RETURNS [str: LONG STRING];  -- Public Errors  Error: ERROR [type: ErrorType, p: RelPtr];  ErrorType: TYPE = Zone .Status[noRoomInZone..nodeLoop];  -- - - - - - - - Starting / Restarting / Stopping Subsidiary Modules: - - - - - - -  Register: PROCEDURE [pStartStop: LONG POINTER TO StartStop ¬ NIL];  -- During initialization, each module with global data that it wants to keep in stable storage should call Register (typically from the module's mainline code).  This registers some module-specific procedures for handling cold starts, restarts, etc.  StartStop may not be deallocated until FinalFinish returns.  (It is typically allocated in the module's globalFrame.)  StartStop: TYPE = RECORD [    moduleName: LONG STRING,    coldStart: ColdStartProc ¬ NIL,    restart: RestartProc ¬ NIL,    saveState: SaveStateProc ¬ NIL,    finalFinish: FinalFinishProc ¬ NIL,    next: Reserved ¬ nullReserved];  -- reserved for use by code implementing Register.  Reserved: TYPE [2];  nullReserved: Reserved = LOOPHOLE[LONG[0]];  ColdStartProc: TYPE = PROCEDURE [zoneBase: Base]    RETURNS [registerThisNode: RelPtr];  -- The ColdStartProc is called by Initialize when there is no previous stable storage.   allocates and returns one node that the module would like to register for future restarts (nil is ok).  The ColdStartProcs are called in the same order as they were Registered.  RestartProc: TYPE = PROCEDURE [zoneBase: Base, registeredNode: RelPtr];  -- The RestartProc is called by Initialize instead of ColdStartProc on a reboot following a crash.  It is given the new zone base plus the node this module registered on cold start.  The RestartProcs are called in the same order as they were Registered (which had better be the same order that they were Registered the first time!).  SaveStateProc: TYPE = PROCEDURE[];  -- The SaveStateProc is called by SaveState.  SaveStateProc must assure that its stable data is in the stable storage zone.  The SaveStateProcs are called in the same order as they were Registered.  FinalFinishProc: TYPE = PROCEDURE[];  -- The FinalFinshProc must release the module's areas in the stable storage zone or at least stop using them.  Note that the FinalFinishProcs are called in REVERSE of the order in which they were Registered.  -- - - - - - - - - - Verbosity-controlled Write Formatted Operations: - - - - - - - - -  -- These operations are copies of the Cedar WF facilities, except that each operation has an additional first argument indicating the verbosity of the message.  If a message has verbosity <= currentVerbosity, the message will be printed.  If not, it will be discarded.  See the Cedar WF documentation for more info.  Verbosity: TYPE = CARDINAL [0..9];  -- 0 is most terse.  VWF0: PROCEDURE [Verbosity, LONG STRING];  VWF1: PROCEDURE [Verbosity, LONG STRING, LONG POINTER];  VWF2: PROCEDURE [Verbosity, LONG STRING, LONG POINTER, LONG POINTER];  VWF3: PROCEDURE [Verbosity, LONG STRING, LONG POINTER, LONG POINTER, LONG POINTER];  VWF4: PROCEDURE [    Verbosity, LONG STRING, LONG POINTER, LONG POINTER, LONG POINTER, LONG POINTER];  VWFC: PROCEDURE [Verbosity, CHARACTER];  VWFCR: PROCEDURE [Verbosity];  VWFN: PROCEDURE [Verbosity, LONG STRING, DESCRIPTOR FOR ARRAY OF LONG POINTER];  -- - - - - - - - - - Count operations: - - - - - - - - -  Tick: PROCEDURE[];  CurrentTick: PROCEDURE RETURNS [currentTick: CARDINAL];  -- - - - - - - - - - Parameter initialization: - - - - - - - - -  ParameterVal: TYPE = RECORD [    val: SELECT tag: * FROM      str => [str: LONG STRING],      cv => [cv: LONG POINTER TO CARDINAL],      bv => [bv: LONG POINTER TO BOOLEAN],      ENDCASE];  RegisterParameter: PROCEDURE [key: LONG STRING, val: ParameterVal];  -- Must be called from main body of subsidiary modules.  Parameter values are set before coldstart or restart procs are called.  CloseParameterItemRegistration: PROCEDURE[];  ProcessParameterFile: PROCEDURE [sH: Stream.Handle];  DisplayParameterValues: PROCEDURE[];  DeallocateParameterState: PROCEDURE[];  -- - - - - - - - - - Control variables: - - - - - - - - -  -- NOTE: the values of these variables is not valid until all StartProcs or RestartProcs have run!  currentVerbosity: Verbosity;  -- - - - - - - - - - Reproducible hash: - - - - - - - - -  ExpandString: PROCEDURE [seed: CARDINAL, s: LONG STRING];  DisplayString: PROCEDURE [seed: CARDINAL, maxlength: CARDINAL];  PrivateGenerator: PROCEDURE [seed: CARDINAL, wantsRandoms: WantsRandoms];  -- Calls wantsRandoms, passing it generator.  Returns when it returns.  WantsRandoms: TYPE = PROCEDURE [nextRandom: NextRandom];  NextRandom: TYPE = PROCEDURE RETURNS [randomValue: CARDINAL];  -- - - - - - - - - - Random Numbers: - - - - - - - - -  Random: PROCEDURE RETURNS [randomValue: CARDINAL];  OneOf: PROCEDURE [n: CARDINAL] RETURNS [BOOLEAN] = INLINE {    RETURN[RandomRange[n] = 0]};  RandomRange: PROCEDURE [n: CARDINAL] RETURNS [randomInRange: CARDINAL] = INLINE    {RETURN[IF n = 0 THEN 0 ELSE (Random[] MOD n)]};  RandomCase: PROCEDURE [LONG DESCRIPTOR FOR ARRAY OF CARDINAL]    RETURNS [randomCase: CARDINAL];  -- - - - - - - - - - Real Transactions: - - - - - - - - -  RealTransaction: TYPE [2];  Transactionid: TYPE [16];  nullRealTransaction: READONLY RealTransaction;  BeginRealTransaction: PROCEDURE RETURNS [rTrans: RealTransaction];  ObtainTransactionIdentifier: PROCEDURE [    rTrans: RealTransaction, mTrans: ModelTransHandle]    RETURNS [transID: Transactionid];  CreateFileWithinTransaction: PROCEDURE [rTrans: RealTransaction, andDo: AndDo];  AndDo: TYPE = PROCEDURE [fileCreated: File.File];  -- andDo should remember the capability of the created file in some stable place.  Then, CreateFileWithinTransaction can finalize the file creation (e.g. File.MakePermanent).  ReleaseTransactionIdentifier: PROCEDURE [transID: Transactionid];  EndRealTransaction: PROCEDURE [rTrans: RealTransaction];  AbortRealTransaction: PROCEDURE [rTrans: RealTransaction];  DidTransactionCommit: PROCEDURE [transID: Transactionid]    RETURNS [committed: BOOLEAN];  -- - - - - - - - - - Model Operations: - - - - - - - - -  ModelTransHandle: TYPE [2];  nullModelTransHandle: READONLY ModelTransHandle;  BeginModelTrans: PROCEDURE [rTrans: RealTransaction]    RETURNS [mTrans: ModelTransHandle];  -- (called after real transaction has started.  mTrans must be valid over crashes.)  RandomModelAct: PROCEDURE [mTrans: ModelTransHandle];  Circumstance: TYPE = {normal, followingCrash};  EndModelTrans: PROCEDURE [mTrans: ModelTransHandle, circumstance: Circumstance];  -- (called after real transaction has completed.)  AbortModelTrans: PROCEDURE [    mTrans: ModelTransHandle, circumstance: Circumstance];  -- (called after real transaction has aborted.)  EnumerateTrans: PROCEDURE [    eachTrans: PROCEDURE [mt: ModelTransHandle, id: Transactionid]];  -- (called after crash recovery to learn identity of unresolved transactions.)  END.LOGSeptember 24, 1980  11:08 AM   jei   Created file.September 26, 1980  3:01 PM   WDK       Added stable storage stuff.September 28, 1980  1:13 PM   jei   Add EnumerateTrans; other minor changes.October 1, 1980  5:09 PM   WDK       Added testFileType, CreateFileWithinTransaction, circumstance to [End/Abort]ModelTrans.October 23, 1980  3:45 PM   WDK       RandomRange[0] now legal.  Deleted maxNumberOfTrans.  Renamed String to be NewString. Added Verbosity stuff.8-Sep-81 14:29:46   WDK       LONGified.  Converted VWF to use CWF interface types. 2-Mar-83 10:54:08  LXD         Conversion to Klamath.  File.Capability becomes File.File. 
-- Copyright (C) 1988  by Xerox Corporation. All rights reserved. -- LFBeaterImpl.mesa	Last edited by: CAJ  on: 12-Jul-88 10:59:46DIRECTORY  BeaterProcs USING [countRegistered, Select, Shutdown],  Exec USING [AddCommand, ExecProc, OutputProc, RemoveCommand],  Format USING [NumberFormat],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType,    CommandItem, DisplayItem, Enumerated, EnumeratedItem, line0, line1, line2,    line3, line4, line5, line6, line7, LongNumberItem, LongNumberNotifyProcType,    NotifyProcType, NumberItem, NumberNotifyProcType, ProcType, TagOnlyItem],  LFBeaterInternal USING [    BlockerChoice, ChangeBlockerDistribution, distributionDefaults,    InitializeChoices, RegisterByFrameWeights, RegisterOther, Unwinder],  MsgSW USING [Clear, Post],  PrincOps USING [FrameSizeIndex],  Process USING [    Detach, DisableAborts, InitializeCondition, Pause, Priority,    priorityBackground, priorityForeground, priorityNormal, Seconds,    SecondsToTicks, SetPriority, Yield],  ProcessPriorities USING [priorityIOLow, priorityPageFaultLow],  Put USING [Char, CR, LongNumber, LongString, Number],  RandomDefs USING [GeneratorState, InitializeRandom, Random],  ResMemPerf USING [    allFrameFaults, currentLargeFramePages, currentLargeFrames,    currentSmallFramePages, largeFrameFaults],  Time USING [AppendCurrent],  Tool USING [    Create, Destroy, MakeFileSW, MakeFormSW, MakeMsgSW, MakeSWsProc,    UnusedLogName],  ToolWindow USING [Activate, State, TransitionProcType],  UserTerminal USING [BlinkDisplay],  Window USING [Handle];LFBeaterImpl: MONITOR  IMPORTS    BeaterProcs, Exec, FormSW, LFBeaterInternal, MsgSW, Process,    Put, RandomDefs, ResMemPerf, Time, Tool, ToolWindow, UserTerminal  EXPORTS LFBeaterInternal =  BEGIN  FormItems: TYPE = {processes, priority, addPfLow, addIOLow, fsiWeights,    randomSeed, depthMin, depthMax, blockerWeights, waitTimeout, waitNotify,    notify, broadcast, pause, yield, forkDetach, forkJoin, forkAbort, start,    stop, stats, help};  FsiWeights: TYPE = {default, file, random};  Priorities: TYPE = MACHINE DEPENDENT {    background(0), normal(1), foreground(2), random(3)};  State: TYPE = {running, stopped, stopping};  -- Tool (window) stuff  wh: Window.Handle ¬ NIL;  msgSW: Window.Handle ¬ NIL;  formSW: Window.Handle ¬ NIL;  fileSW: Window.Handle ¬ NIL;  -- These variables are (currently) only changed under the protection of  -- the notifier as part of the tools mechanism.  addIOLow: BOOLEAN ¬ FALSE;  addPfLow: BOOLEAN ¬ FALSE;  depthMax: CARDINAL ¬ 5;  depthMin: CARDINAL ¬ 1;  fsiWeights: FsiWeights ¬ default;  priority: Priorities ¬ random;  processes: CARDINAL ¬ 50;  randomSeed: LONG UNSPECIFIED ¬ 2097151;  blockerChoices: ARRAY LFBeaterInternal.BlockerChoice OF CARDINAL;    -- The default matches Pilot.bootmesa initial frame allocation  -- except for fsi=0, which has some lopped off for LFBeater overhead.--  defaultFsiWeightsArray: ARRAY PrincOps.FrameSizeIndex OF CARDINAL =--    [16, 26, 15, 16, 16, 12, 8, 8, 5, 5, 7, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1,--     1, 1, 1, 1, 1, 1, 1, 1, 1];-- Temporary reduction:  defaultFsiWeightsArray: ARRAY PrincOps.FrameSizeIndex OF CARDINAL =    [16, 26, 15, 16, 16, 12, 8, 8, 5, 5, 7, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1,     1, 1, 0, 0, 0, 0, 0, 0, 0];  fsiWeightsArray: ARRAY PrincOps.FrameSizeIndex OF CARDINAL ¬    defaultFsiWeightsArray;  -- These variables are protected by the monitor.  Any fiddling with them  -- should be done in ENTRY procedures.  state: State ¬ stopped;  forkedProcesses: CARDINAL ¬ 0;  random: RandomDefs.GeneratorState ¬ TRASH;  pauseTicks: CARDINAL ¬ 5;  processStopped: CONDITION;  statsInterval: CONDITION;  -- printed output stuff  dotSecs: CARDINAL ¬ 30;  -- can change it via debugger  numberFormat: Format.NumberFormat = [    base: 10, zerofill: FALSE, unsigned: TRUE, columns: 10];  numberFormatLeftJust: Format.NumberFormat = [    base: 10, zerofill: FALSE, unsigned: TRUE, columns: 0];  BeaterProcess: PROCEDURE [myPriority: Process.Priority] =    BEGIN    BEGIN ENABLE ABORTED => GO TO Return;    Stopped: ENTRY PROCEDURE RETURNS [BOOLEAN] = {RETURN [state ~= running]};    thousands: CARDINAL ¬ 0;  -- may wrap around, no problem    singles: CARDINAL ¬ 0;    Process.SetPriority[myPriority];    UNTIL Stopped[] DO      depth: CARDINAL;      IF myPriority > Process.priorityNormal THEN Process.Pause[pauseTicks];        -- Give lower priority guys a break      Process.Yield[]; -- for politeness!      depth ¬ RandomNumber[depthMax];      WHILE depth < depthMin DO depth ¬ RandomNumber[depthMax] ENDLOOP;      BeaterProcs.Select[RandomNumber[BeaterProcs.countRegistered]][@depth        ! LFBeaterInternal.Unwinder => CONTINUE];      -- temp, to see how often it goes by here:      singles ¬ singles + 1;      IF singles = 1000	THEN {thousands ¬ thousands + 1; singles ¬ 0;	      Put.Number[fileSW, thousands, numberFormatLeftJust];	      Put.Char[fileSW, ' ]}        ELSE IF singles MOD 500 = 0 THEN Put.Char[fileSW, '.];      ENDLOOP;    GO TO Return;    END    EXITS    Return =>      BEGIN      Dying: ENTRY PROCEDURE =        BEGIN	forkedProcesses ¬ forkedProcesses-1;	NOTIFY processStopped;	END;      Dying[];      END;    END;  -- BeaterProcess  ChangeBooleanItem: FormSW.NotifyProcType =    BEGIN    IF ~CheckStopped[] THEN      BEGIN      SELECT index FROM        FormItems.addPfLow.ORD => addPfLow ¬ ~addPfLow;        FormItems.addIOLow.ORD => addIOLow ¬ ~addIOLow;	ENDCASE;      FormSW.DisplayItem[formSW, index];      END;    END;  ChangeChoice: FormSW.NumberNotifyProcType =    -- [sw: Window.Handle, item: FormSW.ItemHandle, index: CARDINAL,    --  oldValue: UNSPECIFIED]    BEGIN    who: LFBeaterInternal.BlockerChoice ¬ SELECT index FROM      FormItems.waitTimeout.ORD => waitTimeout,      FormItems.waitNotify.ORD => waitNotify,      FormItems.notify.ORD => notify,      FormItems.broadcast.ORD => broadcast,      FormItems.pause.ORD => pause,      FormItems.yield.ORD => yield,      FormItems.forkDetach.ORD => forkDetach,      FormItems.forkJoin.ORD => forkJoin,      FormItems.forkAbort.ORD => forkAbort,      ENDCASE --FormItems.forkAbort.ORD-- => forkAbort;    LFBeaterInternal.ChangeBlockerDistribution[      who: who, toWhat: blockerChoices[who]];    END;  ChangeFsiWeights: FormSW.NumberNotifyProcType =    BEGIN    NotImplemented[];    -- Later, OnlyWhenStopped[];    fsiWeights ¬ default;    FormSW.DisplayItem[formSW, FormItems.fsiWeights.ORD];    END;  ChangeLongNumberItem: FormSW.LongNumberNotifyProcType =    BEGIN    IF ~CheckStopped[] THEN      BEGIN      SELECT index FROM        FormItems.randomSeed.ORD => randomSeed ¬ oldValue;	ENDCASE;      FormSW.DisplayItem[formSW, index];      END;    END;  ChangeNumberItem: FormSW.NumberNotifyProcType =    BEGIN    IF ~CheckStopped[] THEN      BEGIN      SELECT index FROM        FormItems.processes.ORD => processes ¬ oldValue;        FormItems.priority.ORD => priority ¬ oldValue;        FormItems.depthMin.ORD => depthMin ¬ oldValue;        FormItems.depthMax.ORD => depthMax ¬ oldValue;	ENDCASE;      FormSW.DisplayItem[formSW, index];      END;    END;  CheckStopped: PROCEDURE RETURNS [BOOLEAN] =    BEGIN    IF state = stopped THEN RETURN[TRUE];    MsgSW.Post[msgSW, "Changeable only when stopped."L];    UserTerminal.BlinkDisplay[];    RETURN[FALSE];    END;  ClientTransition: ENTRY ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      old = inactive => NULL;      new = inactive => NULL;      ENDCASE;    END;  -- ClientTransition  ExecProc: Exec.ExecProc =    BEGIN    ToolWindow.Activate[wh];    END;  Help: Exec.ExecProc =    BEGIN    h.OutputProc[]["This tool attempts to beat the stuffing out of the local frame and process mechanisms."L];    END;  HelpCmd: FormSW.ProcType =    BEGIN    Put.LongString[fileSW, "This tool beats on the local frame allocation and process mechanisms.  Each process chooses a random call stack depth and calls the first proc.  There is a set of procedures to pick from, randomly, which represent all of the fsi values plus one which just raises a signal.  Each of these procs blocks, then randomly picks another.  On return or signal unwind, it verifies the integrity of its local frame.  The behavior of the tool can be altered quite a bit by adjusting the number of processes, the call stack depth, and the blocker mix."L];    Put.CR[fileSW];    END;  Init: PROCEDURE =    BEGIN    Exec.AddCommand["LFBeater.~"L, ExecProc, Help, Unload];    blockerChoices ¬ LFBeaterInternal.distributionDefaults;    LFBeaterInternal.InitializeChoices[@blockerChoices];    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default,      clientTransition: ClientTransition, name: "LFBeater"L,      cmSection: "LFBeater"L];    LFBeaterInternal.RegisterByFrameWeights[DESCRIPTOR[fsiWeightsArray]];    LFBeaterInternal.RegisterOther[];    Process.InitializeCondition[@statsInterval, Process.SecondsToTicks[dotSecs]];    Process.DisableAborts[@statsInterval];    END;  -- Init  MakeForm: FormSW.ClientItemsProcType =    BEGIN    nItems: CARDINAL = FormItems.LAST.ORD + 1;    priorityArray: ARRAY[0..4) OF FormSW.Enumerated ¬ [      ["background"L, Priorities[background]],      ["normal"L, Priorities[normal]],      ["foreground"L, Priorities[foreground]],      ["random"L, Priorities[random]]];    fsiWeightsArray: ARRAY[0..3) OF FormSW.Enumerated ¬ [      ["default"L, FsiWeights[default]],      ["LFBeater.weights"L, FsiWeights[file]],      ["random"L, FsiWeights[random]]];    items ¬ FormSW.AllocateItemDescriptor[nItems];    items[FormItems.processes.ORD] ¬ FormSW.NumberItem[      tag: "# Processes"L, place: [6, FormSW.line0], signed: FALSE,       value: @processes, proc: ChangeNumberItem];    items[FormItems.priority.ORD] ¬ FormSW.EnumeratedItem[      tag: "Priority"L, place: [150, FormSW.line0],      choices: DESCRIPTOR[priorityArray], value: @priority,      proc: ChangeNumberItem];    items[FormItems.addPfLow.ORD] ¬ FormSW.BooleanItem[      tag: "+pageFaultLow"L, place: [330, FormSW.line0], switch: @addPfLow,      proc: ChangeBooleanItem];    items[FormItems.addIOLow.ORD] ¬ FormSW.BooleanItem[      tag: "+IOLow"L, place: [430, FormSW.line0], switch: @addIOLow,      proc: ChangeBooleanItem];    items[FormItems.fsiWeights.ORD] ¬ FormSW.EnumeratedItem[      tag: "Fsi weights"L, place: [6, FormSW.line1], feedback: all,      choices: DESCRIPTOR[fsiWeightsArray], value: @fsiWeights,      proc: ChangeFsiWeights];    items[FormItems.randomSeed.ORD] ¬ FormSW.LongNumberItem[      tag: "Random Seed"L, place: [333, FormSW.line1], signed: FALSE,      notNegative: TRUE, value: @randomSeed, proc: ChangeLongNumberItem];    items[FormItems.depthMin.ORD] ¬ FormSW.NumberItem[      tag: "Call stack depth min "L, place: [6, FormSW.line2], signed: FALSE,      notNegative: TRUE, value: @depthMin, proc: ChangeNumberItem];    items[FormItems.depthMax.ORD] ¬ FormSW.NumberItem[      tag: "depth max "L, place: [210, FormSW.line2], signed: FALSE,      notNegative: TRUE, value: @depthMax, proc: ChangeNumberItem];    items[FormItems.blockerWeights.ORD] ¬ FormSW.TagOnlyItem[      tag: "Blocker weights distribution:"L, place: [6, FormSW.line3]];    items[FormItems.waitTimeout.ORD] ¬ FormSW.NumberItem[      tag: "waitForTimeout "L, place: [22, FormSW.line4], signed: FALSE,      value: @blockerChoices[waitTimeout], proc: ChangeChoice];    items[FormItems.waitNotify.ORD] ¬ FormSW.NumberItem[      tag: "waitForNotify "L, place: [188, FormSW.line4], signed: FALSE,      value: @blockerChoices[waitNotify], proc: ChangeChoice];    items[FormItems.notify.ORD] ¬ FormSW.NumberItem[      tag: "notify "L, place: [348, FormSW.line4], signed: FALSE,      value: @blockerChoices[notify], proc: ChangeChoice];    items[FormItems.broadcast.ORD] ¬ FormSW.NumberItem[      tag: "broadcast "L, place: [22, FormSW.line5], signed: FALSE,      value: @blockerChoices[broadcast], proc: ChangeChoice];    items[FormItems.pause.ORD] ¬ FormSW.NumberItem[      tag: "pause "L, place: [188, FormSW.line5], signed: FALSE,      value: @blockerChoices[pause], proc: ChangeChoice];    items[FormItems.yield.ORD] ¬ FormSW.NumberItem[      tag: "yield "L, place: [348, FormSW.line5], signed: FALSE,      value: @blockerChoices[yield], proc: ChangeChoice];    items[FormItems.forkDetach.ORD] ¬ FormSW.NumberItem[      tag: "fork/detach "L, place: [22, FormSW.line6], signed: FALSE,      value: @blockerChoices[forkDetach], proc: ChangeChoice];    items[FormItems.forkJoin.ORD] ¬ FormSW.NumberItem[      tag: "fork/join "L, place: [188, FormSW.line6], signed: FALSE,      value: @blockerChoices[forkJoin], proc: ChangeChoice];    items[FormItems.forkAbort.ORD] ¬ FormSW.NumberItem[      tag: "fork/abort "L, place: [348, FormSW.line6], signed: FALSE,      value: @blockerChoices[forkAbort], proc: ChangeChoice];    items[FormItems.start.ORD] ¬ FormSW.CommandItem[      tag: "Start"L, place: [6, FormSW.line7], proc: Start];    items[FormItems.stop.ORD] ¬ FormSW.CommandItem[      tag: "Stop"L, place: [95, FormSW.line7], proc: Stop];    items[FormItems.stats.ORD] ¬ FormSW.CommandItem[      tag: "Stats"L, place: [175, FormSW.line7], proc: Stats];    items[FormItems.help.ORD] ¬ FormSW.CommandItem[      tag: "Help"L, place: [260, FormSW.line7], proc: HelpCmd];    RETURN[items: items, freeDesc: TRUE];    END;  -- MakeForm  MakeSWs: Tool.MakeSWsProc =    BEGIN    logName: LONG STRING ¬ [23];    Tool.UnusedLogName[unused: logName, root: "LFBeater.log"L];    msgSW ¬ Tool.MakeMsgSW[window: window];    formSW ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    END;  -- MakeSWs  NotImplemented: PROCEDURE =    BEGIN    MsgSW.Post[msgSW, "Not implemented."L];    UserTerminal.BlinkDisplay[];    END;  RandomNumber: PUBLIC ENTRY PROCEDURE [max: CARDINAL] RETURNS [CARDINAL] =    {RETURN [RandomDefs.Random[@random, max]]};--  RandomNumberLong: INTERNAL PROCEDURE [max: LONG CARDINAL]--    RETURNS [LONG CARDINAL] =--    {RETURN[LOOPHOLE[Environment.Long[num[--      lowbits: RandomDefs.Random[@random, Inline.LowHalf[max]],--      highbits: RandomDefs.Random[@random, Inline.HighHalf[max]]]]]]};  RandomPriority: INTERNAL PROCEDURE [] RETURNS [prority: Process.Priority] =    BEGIN    RETURN [      SELECT RandomDefs.Random[@random, 100] FROM        < 15 => Process.priorityBackground,        < 70 => Process.priorityNormal,        < 100 => Process.priorityForeground,        ENDCASE => Process.priorityBackground -- should never get here      ];    END;  -- RandomPriority  Start: ENTRY FormSW.ProcType =    BEGIN    ENABLE UNWIND => NULL;    MsgSW.Clear[msgSW];    SELECT state FROM      running =>        BEGIN	MsgSW.Post[msgSW, "AlreadyRunning!"L];	UserTerminal.BlinkDisplay[];	RETURN;	END;      stopping => WHILE forkedProcesses > 0 DO WAIT processStopped ENDLOOP;      stopped =>        BEGIN	time: LONG STRING ¬ [64];	IF depthMin > depthMax THEN	  BEGIN	  MsgSW.Post[msgSW, "Call stack min > max!"L];	  UserTerminal.BlinkDisplay[];	  RETURN;	  END;	random.seed ¬ randomSeed;	RandomDefs.InitializeRandom[@random];	Put.LongString[fileSW, "Starting with "L];        Put.Number[fileSW, processes, numberFormatLeftJust];        Put.LongString[fileSW, " processes, random seed of "L];	Put.LongNumber[fileSW, randomSeed, numberFormatLeftJust];        Put.LongString[fileSW, ", call stack range in ["L];        Put.Number[fileSW, depthMin, numberFormatLeftJust];        Put.LongString[fileSW, ".."L];        Put.Number[fileSW, depthMax, numberFormatLeftJust];	Put.LongString[fileSW, "], at "L];	Time.AppendCurrent[time];	Put.LongString[fileSW, time];        Put.CR[fileSW];	state ¬ running;	IF addPfLow THEN	  {Process.Detach[	     FORK BeaterProcess[ProcessPriorities.priorityPageFaultLow]];	     forkedProcesses ¬ forkedProcesses+1};	IF addIOLow THEN	  {Process.Detach[FORK BeaterProcess[ProcessPriorities.priorityIOLow]];	   forkedProcesses ¬ forkedProcesses+1};        IF processes > forkedProcesses THEN	  THROUGH [0..(processes-forkedProcesses)) DO            Process.Detach[FORK BeaterProcess[	      SELECT priority FROM                background => Process.priorityBackground,	        normal => Process.priorityNormal,	        foreground => Process.priorityForeground,	        random => RandomPriority[],	        ENDCASE => Process.priorityBackground]];            forkedProcesses ¬ forkedProcesses+1;            ENDLOOP;	forkedProcesses ¬ forkedProcesses+1;	Process.Detach[FORK StatsReporter[]];	END;      ENDCASE =>        BEGIN	MsgSW.Post[msgSW, "Unexpected Endcase!"L];	UserTerminal.BlinkDisplay[];	RETURN;	END;    END;  -- Start  Stats:  FormSW.ProcType =    BEGIN    time: LONG STRING ¬ [64];    MsgSW.Clear[msgSW];    Put.CR[fileSW];    Put.LongString[fileSW, "Stats at "L];    Time.AppendCurrent[time];    Put.LongString[fileSW, time];    Put.CR[fileSW];    Put.LongString[fileSW, "  allFrameFaults = "L];      Put.Number[fileSW, ResMemPerf.allFrameFaults, numberFormat];      Put.CR[fileSW];    Put.LongString[fileSW, "  largeFrameFaults = "L];      Put.Number[fileSW, ResMemPerf.largeFrameFaults, numberFormat];      Put.CR[fileSW];    Put.LongString[fileSW, "  currentSmallFramePages = "L];      Put.Number[fileSW, ResMemPerf.currentSmallFramePages, numberFormat];      Put.CR[fileSW];    Put.LongString[fileSW, "  currentLargeFramePages = "L];      Put.Number[fileSW, ResMemPerf.currentLargeFramePages, numberFormat];      Put.CR[fileSW];    Put.LongString[fileSW, "  currentLargeFrames = "L];      Put.Number[fileSW, ResMemPerf.currentLargeFrames, numberFormat];      Put.CR[fileSW];    END;  -- Stats  StatsReporter: PROCEDURE =    BEGIN    Stopped: ENTRY PROCEDURE RETURNS [BOOLEAN] =      BEGIN      WAIT statsInterval;      RETURN [state ~= running];      END;    KillingOurselves: ENTRY PROCEDURE =      BEGIN      forkedProcesses ¬ forkedProcesses-1;      NOTIFY processStopped;      END;    ticks: CARDINAL ¬ 0;    Process.SetPriority[Process.priorityForeground];    WHILE ~Stopped[] DO    ticks ¬ ticks + 1;    IF ticks = 30 THEN      {Put.Char[fileSW, '!]; ticks ¬ 0};      ENDLOOP;    KillingOurselves[];    END;  -- StatsReporter  Stop: ENTRY FormSW.ProcType =    BEGIN    ENABLE UNWIND => NULL;    MsgSW.Clear[msgSW];    IF state ~= running THEN      BEGIN      MsgSW.Post[msgSW, "Not running!"L];      UserTerminal.BlinkDisplay[];      RETURN;      END;    Put.LongString[fileSW, "Stopping all processes..."L];    state ¬ stopped;    BROADCAST statsInterval;  -- knock stats out of WAIT in case it's long    WHILE forkedProcesses > 0 DO WAIT processStopped ENDLOOP;    Put.LongString[fileSW, "stopped."L];    Put.CR[fileSW];    END;  -- Stop  Unload: Exec.ExecProc =    BEGIN    IF state ~= stopped THEN {      Exec.OutputProc[h]["Need to Stop tool first.\n"L];      RETURN[error] };    BeaterProcs.Shutdown[];    IF wh # NIL THEN Tool.Destroy[wh];    wh ¬ NIL;    Exec.RemoveCommand[h, "LFBeater.~"L];    END;  -- Unload  -- Mainline code  Init[];  -- this gets string out of global frame  END...LOG12-Jul-88 10:59:32	CAJ	Created file.
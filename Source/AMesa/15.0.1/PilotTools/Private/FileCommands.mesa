-- Copyright (C) 1983, 1985, 1986, 1987  by Xerox Corporation. All rights reserved. -- FileCommands.mesa last edited by: CJS    on:  4-Feb-87 15:38:05)-- Note:  Terminator and PutLongNumber exist also in PhysicalVolumeCommandsDIRECTORY  Ascii USING [CR, SP],  Command USING [    Aborted, Action, Catch, Confirm, Entry, InstallTopLevel, Loop,     QuitLevel, Scan, WriteBoolean, WriteError, WriteLongDecimal],  Environment USING [bytesPerPage, bytesPerWord, PageCount, wordsPerPage],  File,  FileTypes USING [tUnassigned],  MFile USING [Acquire, Error, Handle, maxNameLength, Release],  PhysicalVolume,  PilotCommand USING [currentPhysicalVolumeID,defaultWindow,     GetGetNextTypeSetCur,  GetVIDCur, ReadUniversalID, SetVIDCur,    StringToUID, UIDToString, WriteUniversalID],  Runtime USING [IsBound],  Scavenger USING [Error, ErrorType, FileEntry, GetLog, Header, «Problem,»    Verifier],  Space,  SpecialMFile USING [GetCapaWithAccess],  String USING [AppendChar, AppendLongNumber, AppendString, EquivalentStrings,     InvalidNumber, StringBoundsFault, StringToLongNumber, StringToNumber],  System USING [UniversalID],  TTY USING [    CharStatus, GetChar, GetID, GetLongNumber, GetNumber, GetString, Handle,    LineOverflow, NewLine, PutChar, PutCR, PutDecimal, PutLine, PutLongDecimal,    PutLongNumber, PutLongOctal, PutOctal, PutString, UserAbort],  Time USING [Append, Unpack],   Volume;FileCommands: PROGRAM  IMPORTS Command, File, MFile, PhysicalVolume, PilotCommand,    Runtime, Scavenger, Space, SpecialMFile, String, TTY, Time, Volume  EXPORTS PilotCommand  SHARES File =  BEGIN   entriesFile: ARRAY [0..13) OF Command.Entry ¬ [    ["commands", LoopCmd],  -- must be first    ["attributes", AttributesCmd],    ["create", CreateCmd],    ["current", CurrentCmd],    ["delete", DeleteCmd],    ["make permanent", MakePermanentCmd],    ["octal type contents", OctalTypeCmd],    ["set current from file", SetCurrentCmd],    ["set current from name", SetCurrentFromFilenameCmd],    ["set size", SetSizeCmd],    ["size", SizeCmd],    ["type contents", TypeCmd],    ["quit", Command.QuitLevel]];  -- must be last  entriesVolume: ARRAY [0..18) OF Command.Entry ¬ [    ["commands", VolumeLoopCmd],  -- must be first    ["close", VolumeCloseCmd],    ["current", VolumeCurrentCmd],    ["free space", VolumeFreeSpaceCmd],    ["Forcefully Set Logical Volume ID", VolumeForceSetLogicalVolumeCmd],    ["label string", VolumeLabelStringCmd],    ["next", VolumeNextCmd],    ["open", VolumeOpenCmd],    ["create logical volume", VolumeCreateCmd],    ["erase logical volume", VolumeEraseCmd],    ["Set current logical volume", VolumeSetCurrentLogicalVolumeCmd],    --["root", VolumeRootCmd],--    ["scavenge current volume", VolumeScavengeVolumeCmd],    ["set current",VolumeSetCurrentCmd],    --["set root", VolumeSetRootCmd],--    ["set type set for next", VolumeSetCurrentGetNextTypeSetCmd],    ["system", VolumeSystemCmd],    ["type set for next", VolumeGetCurrentGetNextTypeSetCmd],    ["type scavenger log", VolumeTypeScavengerLogCmd],    ["quit", Command.QuitLevel]];  -- must be last      stringSize: CARDINAL = MAX[    Volume.maxNameLength,  -- for volume names    PhysicalVolume.maxNameLength,  -- for physical volume names    1 + (SIZE[System.UniversalID] - 1)*8 + 6 + 1];  -- to hold one  currentLogicalVolumeName: LONG STRING ¬ [stringSize];  currentLogicalVolumeType: Volume.Type ¬ normal;  currentMinimumStartingPage: PhysicalVolume.PageNumber ¬ 0;  currentVolumeSize: Volume.PageCount ¬ 0;  defaultCount: Environment.PageCount ¬ LAST[Environment.PageCount];  file: File.File ¬ File.nullFile;  fbCur: CARDINAL ¬ 0;  ftCur: File.Type ¬ FileTypes.tUnassigned;  tty: TTY.Handle = PilotCommand.defaultWindow;  vidCur: Volume.ID ¬ Volume.systemID;  getNextTypeSetCur: Volume.TypeSet ¬ Volume.onlyEnumerateCurrentType;  AttributesCmd: Command.Action =    BEGIN    type: File.Type;    temporary: BOOLEAN;    [type, temporary] ¬ File.GetAttributes[file];    TTY.PutChar[h, Ascii.CR];    TTY.PutString[h, " type: "L];    TTY.PutDecimal[h, type];    TTY.PutString[h, ", temporary: "L];    Command.WriteBoolean[h, temporary];    END;  CreateCmd: Command.Action =    BEGIN    initialSize: LONG CARDINAL;    TTY.PutString[h, " initial size: "L];    initialSize ¬ TTY.GetLongNumber[h: h, default: 1, radix: 10];    ReadFTCur[h];    file ¬ File.Create[vidCur, initialSize, ftCur];    TTY.PutString[h, " is "L];    WriteFileIDs[h, file]    END;  CurrentCmd: Command.Action =    BEGIN TTY.PutString[h, " is "L]; WriteFileIDs[h, file] END;  DeleteCmd: Command.Action = BEGIN Command.Confirm[h]; File.Delete[file] END;  FileCmd: Command.Action =    BEGIN    TTY.PutChar[h, Ascii.SP];    Command.Scan[h, DESCRIPTOR[BASE[entriesFile], LENGTH[entriesFile] - 1], StorageCatch]    END;  LoopCmd: Command.Action =    BEGIN    Command.Loop[      h, DESCRIPTOR[@entriesFile[1], LENGTH[entriesFile] - 1], StorageCatch,      "file "L]    END;  OctalTypeCmd: Command.Action = BEGIN OctalTypeFile[h, file] END;  SetCurrentCmd: Command.Action =    BEGIN TTY.PutString[h, " to "L]; ReadFIDCur[h] END;  MakePermanentCmd: Command.Action = BEGIN File.MakePermanent[file]; END;  SetCurrentFromFilenameCmd: Command.Action =    BEGIN    tempFile: File.File;    s: STRING = [MFile.maxNameLength];    success: BOOLEAN;    TTY.PutString[h, ": "L];    [tempFile, success] ¬ FileFromFilename[s];    IF success THEN      BEGIN      file ¬ tempFile;      TTY.PutString[h, " = "L];      WriteFileIDs[h, file]      END    END;  SetSizeCmd: Command.Action =    BEGIN    count: LONG CARDINAL;    TTY.PutString[h, " to: "L];    count ¬ TTY.GetLongNumber[h: h, default: 1, radix: 10];    File.SetSize[file, count]    END;  SizeCmd: Command.Action =    BEGIN    size: File.PageCount ¬ File.GetSize[file];    TTY.PutString[h, " is "L];    Command.WriteLongDecimal[h, size];    TTY.PutString[h, " pages"L]    END;  TypeCmd: Command.Action = BEGIN TTY.PutChar[h, Ascii.CR]; TypeFile[h, file] END;  VolumeCloseCmd: Command.Action = BEGIN Command.Confirm[h]; Volume.Close[vidCur] END;  VolumeCmd: Command.Action =    BEGIN    TTY.PutChar[h, Ascii.SP];    Command.Scan[      h, DESCRIPTOR[BASE[entriesVolume], LENGTH[entriesVolume] - 1], StorageCatch]    END;  VolumeCurrentCmd: Command.Action = {TTY.PutString[h, " is "L]; WriteVolumeID[h, vidCur]};    VolumeForceSetLogicalVolumeCmd: Command.Action =    BEGIN    TTY.PutString[h, "ID: "L];    TTY.GetString[h, currentLogicalVolumeName, Terminator];    PilotCommand.SetVIDCur[      LOOPHOLE[PilotCommand.StringToUID[currentLogicalVolumeName].id]];    END;  VolumeFreeSpaceCmd: Command.Action =    BEGIN    countTotal, countFree: Volume.PageCount;    [volumeSize: countTotal, freePageCount: countFree] ¬ Volume.GetAttributes[      vidCur];    TTY.PutString[h, " is "L];    Command.WriteLongDecimal[h, countFree];    TTY.PutString[h, " pages out of "L];    Command.WriteLongDecimal[h, countTotal];    TTY.PutString[h, " pages total"L]    END;  VolumeGetCurrentGetNextTypeSetCmd: Command.Action =    BEGIN    IF ~TTY.NewLine[h] THEN TTY.PutChar[h, Ascii.CR];    TTY.PutString[h, "  is normal: "L];    TTY.PutString[h, IF getNextTypeSetCur[normal] THEN "Yes"L ELSE "No"L];    TTY.PutString[h, "  debugger: "L];    TTY.PutString[h, IF getNextTypeSetCur[debugger] THEN "Yes"L ELSE "No"L];    TTY.PutString[h, "  debuggerDebugger: "L];    TTY.PutString[      h, IF getNextTypeSetCur[debuggerDebugger] THEN "Yes"L ELSE "No"L];    END;    VolumeLabelStringCmd: Command.Action =    BEGIN    s: STRING = [Volume.maxNameLength];    Volume.GetLabelString[vidCur, s];    TTY.PutString[h, " is "L];    TTY.PutString[h, s]    END;  VolumeLoopCmd: Command.Action =    BEGIN    Command.Loop[      h, DESCRIPTOR[@entriesVolume[1], LENGTH[entriesVolume] - 1], StorageCatch,      "volume "L]    END;  VolumeNextCmd: Command.Action =    BEGIN    vidCur ¬ Volume.GetNext[vidCur, getNextTypeSetCur];    TTY.PutString[h, " is "L];    WriteVolumeID[h, vidCur]    END;  VolumeOpenCmd: Command.Action =    BEGIN    Command.Confirm[h];  -- is this necessary?    Volume.Open[vidCur]    END;      VolumeSetCurrentLogicalVolumeCmd: Command.Action =    BEGIN [] ¬ GetLogicalVolumeID[h]; END;       VolumeScavengeVolumeCmd: Command.Action =    BEGIN    repair: STRING ¬ [15];    TTY.PutString[h, "Do you want to do a checkOnly, safeRepair, or riskyRepair?"L];    TTY.PutCR[h];    TTY.GetString[h, repair, Terminator];        --SELECT TRUE FROM       --String.EquivalentStrings[repair, "checkOnly"L] =>        --file ¬ Scavenger.Scavenge[vidCur, vidCur, checkOnly, FALSE];      --String.EquivalentStrings[repair, "safeRepair"L] =>        --file ¬ Scavenger.Scavenge[vidCur, vidCur, safeRepair, FALSE];      --String.EquivalentStrings[repair, "riskyRepair"L] =>        --file ¬ Scavenger.Scavenge[vidCur, vidCur, riskyRepair, FALSE];      --ENDCASE =>        --TTY.PutString[h, "Try again...The type of repair you requested was not found "L];    file ¬ Scavenger.Verifier[vidCur, FALSE];    END;       VolumeCreateCmd: Command.Action =    BEGIN    [] ¬ GetNewLogicalVolumeName[h];    [] ¬ GetVolumeType[h];    [] ¬ GetVolumeSize[h];    [] ¬ GetStartingPageNumberForLogicalVolume[h];    PilotCommand.SetVIDCur[      Volume.Create[      PilotCommand.currentPhysicalVolumeID, currentVolumeSize, currentLogicalVolumeName,      currentLogicalVolumeType, currentMinimumStartingPage]];    currentMinimumStartingPage ¬ currentMinimumStartingPage + currentVolumeSize;    WriteVolumeID[h, PilotCommand.GetVIDCur[]];    END;      VolumeEraseCmd: Command.Action =    BEGIN     Command.Confirm[h];    Volume.Erase[PilotCommand.GetVIDCur[]];    END;   VolumeSetCurrentCmd: Command.Action = {TTY.PutString[h, " to "L]; ReadVIDCur[h]};  VolumeSetCurrentGetNextTypeSetCmd: Command.Action =    BEGIN    YesOrNo: PROCEDURE [s: STRING] RETURNS [BOOLEAN] =      BEGIN      TTY.PutString[h, s];      TTY.PutChar[h, '?];      TTY.PutChar[h, ' ];      DO  -- until get a Y/N response        c: CHARACTER;        TTY.PutChar[h, c ¬ TTY.GetChar[h]];        IF c = 'Y OR c = 'y THEN RETURN[TRUE];        IF c = 'N OR c = 'n THEN RETURN[FALSE];        TTY.PutChar[h, '?];        ENDLOOP;      END;    TTY.PutChar[h, Ascii.CR];    getNextTypeSetCur[normal] ¬ YesOrNo["Normal volumes"L];    getNextTypeSetCur[debugger] ¬ YesOrNo[" Debugger volumes"L];    getNextTypeSetCur[debuggerDebugger] ¬ YesOrNo[" DebuggerDebugger volumes"L];    END;  VolumeSystemCmd: Command.Action = {    TTY.PutString[h, " is "L]; WriteVolumeID[h, vidCur ¬ Volume.SystemID[]]};    --  Type Scavenger Log .. added 10/6/81 by rhodes  VolumeTypeScavengerLogCmd: Command.Action =     BEGIN    logFile: File.File = Scavenger.GetLog[vidCur];    si: Space.Interval;    sp: LONG POINTER;    numberOfFiles: LONG CARDINAL;        IF logFile = File.nullFile THEN {      TTY.PutString[h, "No log file"L];      TTY.PutCR[h];      RETURN };          si ¬ Space.Map[Space.Window[file: logFile, base: 0, count: defaultCount]];    sp ¬ si.pointer;    numberOfFiles ¬ PrintHeader[h, si.pointer];    sp ¬ sp + SIZE[Scavenger.Header];    THROUGH [0..CARDINAL[numberOfFiles]) DO      numberOfProblems: CARDINAL = PrintFileEntry[h, sp];      sp ¬ sp + SIZE[Scavenger.FileEntry];      THROUGH [0..numberOfProblems) DO        PrintPage[h,sp];	sp ¬ sp + SIZE[File.PageNumber];	ENDLOOP;	      ENDLOOP;    si.pointer ¬ Space.Unmap[si.pointer];    END;           PrintHeader: PROC [h: TTY.Handle, hp: LONG POINTER TO Scavenger.Header]    RETURNS [numberOfFiles: LONG CARDINAL] = {    s: STRING = [20];         TTY.PutCR[h];      TTY.PutLine[h, "..Scavenger Log.."L];      TTY.PutString[h, "Seal: "L];      TTY.PutDecimal[h, hp.seal]; TTY.PutCR[h];      TTY.PutString[h, "Version: "L];      TTY.PutDecimal[h, hp.version]; TTY.PutCR[h];      TTY.PutString[h, "Volume Scavenged: "L];      PilotCommand.WriteUniversalID[h, hp.volume]; TTY.PutCR[h];           Time.Append[s, Time.Unpack[hp.date]];      TTY.PutString[h, "Date Log Created: "L];       TTY.PutString[h, s]; TTY.PutCR[h];      TTY.PutString[h, "RepairMode: "L];      SELECT hp.repairMode FROM        checkOnly => TTY.PutString[h,"checkOnly"L];	safeRepair => TTY.PutString[h,"safeRepair"L];	riskyRepair => TTY.PutString[h,"riskyRepair"L];	ENDCASE => TTY.PutString[h, "Problem: the repair mode is unknown"L];      TTY.PutCR[h];      IF hp.incomplete THEN TTY.PutString[h, "Log File is Incomplete.."L]                       ELSE TTY.PutString[h, "Log File is Complete.."L];      IF hp.repaired THEN TTY.PutLine[h, "Volume was repaired"L]                     ELSE TTY.PutLine[h, "Volume was not changed"L];      TTY.PutString[h, "Volume contains the following "L];      TTY.PutLongDecimal[h, hp.numberOfFiles];      TTY.PutLine[h, " files:"L];      RETURN[hp.numberOfFiles]      };     	   PrintFileEntry: PROC [h: TTY.Handle, fep: LONG POINTER TO Scavenger.FileEntry]    RETURNS [numberOfProblems: CARDINAL] = {       IF fep.numberOfProblems > 0 THEN TTY.PutCR[h];       WriteID[h, fep.file];  TTY.PutCR[h];       TTY.PutString[h, "sortKey: "L];       TTY.PutLongDecimal[h, fep.sortKey];  TTY.PutCR[h];       RETURN[fep.numberOfProblems]};        PrintPage: PROC [h: TTY.Handle, pp: LONG POINTER TO File.PageNumber] = {   page: File.PageNumber ¬ pp­;   TTY.PutString[h, "..Page "L];   TTY.PutLongDecimal[h, page];   TTY.PutString[h, " lost its data"L];      «WITH pp SELECT  FROM     dataLost => {       TTY.PutString[h, "..Page "L];       TTY.PutLongDecimal[h, page];       TTY.PutString[h, " lost its data"L]};     unreadable => {       TTY.PutString[h, "..Page(s) "L];       TTY.PutLongDecimal[h, first];       IF count > 0        THEN {TTY.PutString[h, " through "L];              TTY.PutLongDecimal[h, count + first]};       TTY.PutLine[h, " cannot be read"L]};                     missing => {       TTY.PutString[h, "..Page(s) "L];       TTY.PutLongDecimal[h, first];       IF count > 0        THEN {TTY.PutString[h, " through "L];              TTY.PutLongDecimal[h, count + first]};       TTY.PutLine[h, " are missing"L]};                     duplicate =>       TTY.PutLine[h,"..This file is a duplicate"L];     orphan =>       TTY.PutLine[h,"..This file is an orphan (label cannot be read)."L];     ENDCASE => ERROR» };         FileFromFilename: PROCEDURE [s: STRING]      RETURNS [tempFile: File.File, success: BOOLEAN] =    BEGIN    tempFile ¬ File.nullFile;    IF ~(success ¬ Runtime.IsBound[LOOPHOLE[MFile.Acquire]]) THEN      TTY.PutString[tty, " no directory system"L]    ELSE      BEGIN      handle: MFile.Handle;      TTY.GetID[tty, s        ! TTY.LineOverflow =>          {TTY.PutString[tty, " too long, try again: "L]; RETRY}];      handle ¬ MFile.Acquire[name: s, access: anchor, release: [NIL,NIL]        ! MFile.Error =>          {TTY.PutString[tty, SELECT code FROM	    noSuchFile => " no such file"L,	    illegalName => " illegal name"L,	    ENDCASE =>" can't access"L]; success ¬ FALSE; CONTINUE}];      IF success THEN        BEGIN	-- Note:  SpecialMFile.GetCapaWithAccess was changed on local disk	-- to return File.File instead of File.Capability        tempFile ¬ SpecialMFile.GetCapaWithAccess[handle];        MFile.Release[handle];        END      END    END;  GetFileCur: PUBLIC PROCEDURE RETURNS [File.File] = {RETURN[file]};  GetFBCur: PUBLIC PROCEDURE RETURNS [CARDINAL] = {RETURN[fbCur]};  GetFTCur: PUBLIC PROCEDURE RETURNS [File.Type] = {RETURN[ftCur]};  GetGetNextTypeSetCur: PUBLIC PROCEDURE RETURNS [Volume.TypeSet] = {    RETURN[getNextTypeSetCur]};  GetVIDCur: PUBLIC PROCEDURE RETURNS [Volume.ID] = {RETURN[vidCur]};  OctalTypeFile: PROCEDURE [h: TTY.Handle, tempFile: File.File] =    BEGIN    fs: File.PageCount;    ss: Space.PageCount;    si: Space.Interval;    il, ic, r: CARDINAL;    i, q: LONG INTEGER;    sp: LONG POINTER TO ARRAY [0..0) OF UNSPECIFIED;    wordsPerLine: CARDINAL = 8;    shortss: CARDINAL;    fs ¬ File.GetSize[file];    ss ¬ SizeForSpace[fs];    IF ss ~= 0 THEN      BEGIN      ss ¬ MIN[ss, LAST[CARDINAL]/Environment.bytesPerPage];      si ¬ Space.Allocate[        ss, Space.virtualMemory, Space.defaultBase !        Space.InsufficientSpace => BEGIN ss ¬ available; RETRY END];      sp ¬ si.pointer;      q ¬ fs/ss;      r ¬ CARDINAL[fs MOD ss];      IF r ~= 0 THEN q ¬ q + 1;      FOR i IN [0..q) DO        ENABLE UNWIND =>  Space.Deallocate[si];        [] ¬ Space.MapAt[si, Space.Window[tempFile, i*ss, defaultCount]];	shortss ¬ CARDINAL[ss];        FOR il IN [0..(IF r = 0 THEN shortss ELSE r)*256/wordsPerLine) DO          IF TTY.UserAbort[tty] THEN {	    [] ¬ Space.UnmapAt[si.pointer];	    ERROR Command.Aborted;};          TTY.PutChar[tty, Ascii.CR];          IF i > LAST[CARDINAL] THEN            BEGIN TTY.PutString[tty, "too much more to print..."L]; EXIT END          ELSE TTY.PutOctal[tty, CARDINAL[i]*shortss*256 + il*wordsPerLine];          TTY.PutChar[tty, ':];          FOR ic IN [0..7] DO             TTY.PutChar[tty, ' ]; TTY.PutOctal[tty, sp[il*wordsPerLine + ic]]	  ENDLOOP;	  ENDLOOP;        [] ¬ Space.UnmapAt[si.pointer]        ENDLOOP;      Space.Deallocate[si]      END    END;      RepID: TYPE = RECORD [ARRAY [0..2) OF CARDINAL];      ReadFileID: PROCEDURE [h: TTY.Handle, default: File.ID]    RETURNS [File.ID] =    BEGIN OPEN rep: LOOPHOLE[default, RepID];        GetValidIDNum: PROC [      default: UNSPECIFIED, terminators: STRING, ignoreLeadingBrac: BOOLEAN]      RETURNS[UNSPECIFIED] =      BEGIN      c: CHARACTER ¬ TTY.GetChar[h];      s: STRING = [20];      WHILE c=Ascii.SP DO TTY.PutChar[h, Ascii.SP]; c ¬ TTY.GetChar[h] ENDLOOP;      IF ignoreLeadingBrac AND c = '[ THEN {        c ¬ TTY.GetChar[h]; WHILE c=Ascii.SP DO TTY.PutChar[h, Ascii.SP]; c ¬ TTY.GetChar[h] ENDLOOP};      WHILE c IN ['0..'8) DO        TTY.PutChar[h, c];        String.AppendChar[s, c  ! String.StringBoundsFault => GOTO invalidNumber];        c ¬ TTY.GetChar[h];              ENDLOOP;                  IF s.length = 0 THEN {        IF ~(c=Ascii.CR OR c=terminators[0] OR c=terminators[1]) THEN GOTO invalidNumber;	TTY.PutOctal[h, default]; RETURN[default]}      ELSE {        IF c = 'B OR c = 'b THEN {TTY.PutChar[h, c]; c ¬ TTY.GetChar[h]};        IF ~(c=Ascii.CR OR c=terminators[0] OR c=terminators[1]) THEN GOTO invalidNumber;        RETURN[String.StringToNumber[s, 8]]};      EXITS      invalidNumber => ERROR String.InvalidNumber      END;               TTY.PutChar[h, '[];    rep[0] ¬ GetValidIDNum[default: rep[0], terminators: ", "L, ignoreLeadingBrac: TRUE];     TTY.PutChar[h, ',];    rep[1] ¬ GetValidIDNum[default: rep[1], terminators: " ]"L, ignoreLeadingBrac: FALSE];    TTY.PutChar[h, ']];    RETURN[LOOPHOLE[rep]]    END;    ReadFBCur: PUBLIC PROCEDURE [h: TTY.Handle] =    BEGIN    TTY.PutString[h, " base:"L];    SetFBCur[INTEGER[TTY.GetNumber[h: h, default: fbCur, radix: 10]]]    END;    ReadFIDCur: PUBLIC PROCEDURE [h: TTY.Handle] =    BEGIN    fID: File.ID;    vID: Volume.ID;    TTY.PutString[h, "FID"L];    fID ¬ ReadFileID[h: h, default: fID];      TTY.PutString[h, "VID"L];    vID ¬ Volume.ID[PilotCommand.ReadUniversalID[h: h, default: vID]];    SetFileCur[LOOPHOLE[File.File[fID, vID]]]       END;  ReadFTCur: PUBLIC PROCEDURE [h: TTY.Handle] =    BEGIN    TTY.PutString[h, " type: "L];    ftCur ¬ TTY.GetNumber[h: h, default: ftCur, radix: 10]    END;  ReadVIDCur: PUBLIC PROCEDURE [h: TTY.Handle] =    BEGIN    TTY.PutString[h, "VID"L];    PilotCommand.SetVIDCur[Volume.ID[PilotCommand.ReadUniversalID[h: h, default: vidCur]]]    END;  SetFileCur: PUBLIC PROCEDURE [tempFile: File.File] = BEGIN file ¬ tempFile; fbCur ¬ 0 END;  SetFBCur: PUBLIC PROCEDURE [fb: CARDINAL] = BEGIN fbCur ¬ fb END;  SetFTCur: PUBLIC PROCEDURE [ft: File.Type] = BEGIN ftCur ¬ ft END;  SetGetNextTypeSetCur: PUBLIC PROCEDURE [mode: Volume.TypeSet] = {    getNextTypeSetCur ¬ mode};  SetVIDCur: PUBLIC PROCEDURE [vid: Volume.ID] = BEGIN vidCur ¬ vid END;  SizeForSpace: PROCEDURE [fileSize: File.PageCount] RETURNS [Space.PageCount] =    BEGIN    RETURN[fileSize]    END;  TypeFile: PROCEDURE [h: TTY.Handle, tempFile: File.File] =    BEGIN    fs: File.PageCount;    ss: Space.PageCount;    shortss: CARDINAL;    si: Space.Interval;    ic, r: CARDINAL;    i, q: LONG INTEGER;    sp:  LONG POINTER TO PACKED ARRAY [0..0) OF CHARACTER;    fs ¬ File.GetSize[tempFile];    ss ¬ SizeForSpace[fs];    IF ss ~= 0 THEN      BEGIN      ss ¬ MIN[ss, LAST[CARDINAL]/Environment.bytesPerPage];      shortss ¬ CARDINAL[ss];      si ¬ Space.Allocate[        ss, Space.MDS[], Space.defaultBase !        Space.InsufficientSpace => BEGIN ss ¬ available; RETRY END];      sp ¬ si.pointer;      q ¬ fs/ss;      r ¬ CARDINAL[fs MOD ss];      IF r ~= 0 THEN q ¬ q + 1;      FOR i IN [0..q) DO        ENABLE UNWIND => Space.Deallocate[si];        IF TTY.UserAbort[tty] THEN ERROR Command.Aborted;        [] ¬ Space.MapAt[si, Space.Window[file, i*ss, defaultCount]];        FOR ic IN [0..(IF r = 0 THEN shortss ELSE r) * Environment.bytesPerWord * Environment.wordsPerPage) DO          TTY.PutChar[tty, sp[ic]];          IF ic MOD 128 = 0 AND TTY.UserAbort[tty] THEN {	    [] ¬ Space.UnmapAt[si.pointer];	    ERROR Command.Aborted;};          ENDLOOP;        [] ¬ Space.UnmapAt[si.pointer];        ENDLOOP;      Space.Deallocate[si]      END    END;  StorageCatch: PUBLIC Command.Catch =    BEGIN    ENABLE      BEGIN      PhysicalVolume.NeedsScavenging => {        Command.WriteError[tty, "PhysicalVolume.CanNotScavenge"]; CONTINUE};      PhysicalVolume.Error => {                errors: ARRAY PhysicalVolume.ErrorType OF STRING = [	  "badDisk "L, "badSpotTableFull"L, "containsOpenVolumes"L,	  "diskReadError"L, "hardwareError"L, "hasPilotVolume"L,	  "alreadyAsserted"L, "insufficientSpace"L, "invalidHandle"L,	  "nameRequired"L, "notReady"L, "noSuchDrive"L, "noSuchLogicalVolume"L,	  "physicalVolumeUnknown"L, "writeProtected"L, "wrongFormat"L,	  "needsConversion"L];        Command.WriteError[h, "PhysicalVolume.Error["L];        TTY.PutString[tty, errors[error]];        TTY.PutChar[h, ']];        CONTINUE;        };      Volume.Error => {                volErrors: ARRAY Volume.ErrorType OF STRING = [	  "nameRequired"L, "pageCountTooSmallForVolume"L,	  "subvolumeHasTooManyBadPages"L ,"tooManySubvolumes"L];        Command.WriteError[h, "Volume.Error["L];        TTY.PutString[tty, volErrors[error]];        TTY.PutChar[h, ']];        CONTINUE;        };	      Volume.InsufficientSpace => {        Command.WriteError[h, "Volume.InsufficientSpace.. "L];	TTY.PutLongDecimal[h, LOOPHOLE[currentFreeSpace]];	TTY.PutLine[h, " pages are available"L]; CONTINUE};      Volume.Unknown --[volume]-- => {        Command.WriteError[h, "Volume.Unknown["L];        WriteVolumeID[h, volume];        TTY.PutChar[h, ']];        CONTINUE        };      Volume.NeedsScavenging => {        Command.WriteError[h, "Volume.NeedsScavenging"L]; CONTINUE};      Volume.NotOnline => {        Command.WriteError[h, "Volume.NotOnline"L]; CONTINUE};      Volume.NotOpen => {        Command.WriteError[h, "Volume.NotOpen"L]; CONTINUE};      Volume.ReadOnly => {        Command.WriteError[h, "Volume.ReadOnly"L]; CONTINUE};      Volume.RootDirectoryError => {        Command.WriteError[h, "Volume.RootDirectoryError"L]; CONTINUE};	      Scavenger.Error =>         BEGIN	errors: ARRAY Scavenger.ErrorType OF STRING = [	  bucketPageLost: "bucketPageLost"L, cannotWriteLog: "cannotWriteLog"L,	  copyETFETLost: "copyETFETLost"L, 	  overflowIsLost: "overflowIsLost"L,	  overflowPageIsLost: "overflowPageIsLost"L,	  primaryETFETLost: "primaryETFETLost"L, volumeOpen: "volumeOpen"L, 	  diskHardwareError: "diskHardwareError"L,	  diskNotReady:      "diskNotReady"L,	  eTableFilesHeaderLost: "eTableFilesHeaderLost"L,	  eTFETLost: "eTFETLost"L, eTFLogLost: "eTFLogLost"L,	  needsRiskyRepair: "needsRiskyRepair"L,	  needsConversion: "needsConversion"L];	Command.WriteError[h, "Scavenger.Error["L];        TTY.PutString[tty, errors[error]];        TTY.PutChar[h, ']];        CONTINUE        END;	      File.Error --[type]-- =>                BEGIN	errors: ARRAY File.ErrorType OF STRING = [                                "invalidParameters"L, "reservedType"L];	Command.WriteError[h, "File.Error["L];        TTY.PutString[tty, errors[type]];        TTY.PutChar[h, ']];        CONTINUE        END;      File.MissingPages =>        BEGIN	Command.WriteError[h, "File.MissingPages["L];	WriteFileIDs[h, file]; 	TTY.PutString[h, "firstMissing: "L];	TTY.PutLongNumber[h, firstMissing, [8, FALSE, TRUE, 5]];	TTY.PutString[h, "countMissing: "L];	TTY.PutLongNumber[, countMissing, [8, FALSE, TRUE, 5]];	TTY.PutChar[h, ']];	END;      File.Unknown --[file]-- =>        BEGIN        Command.WriteError[h, "File.Unknown["L];        WriteFileIDs[h, file];        TTY.PutChar[h, ']];        CONTINUE        END;      Space.Error --[type]-- =>        BEGIN        Command.WriteError[h, "Space.Error["L];        TTY.PutString[          h,          SELECT type FROM            alreadyAllocated => "alreadyAllocated"L,	    alreadyDeallocated => "alreadyDeallocated"L,	    incompleteSwapUnits => "incompleteSwapUnits"L,            invalidParameters => "invalidParameters"L,	    invalidProcedure => "invalidProcedure"L,	    invalidSwapUnitSize => "invalidSwapUnitSize"L,            invalidWindow => "invalidWindow"L,	    notAllocated => "notAllocated"L,	    notMapped => "notMapped"L,            noWindow => "noWindow"L,	    pointerPastEndOfMemory => "pointerPastEndOfMemory"L,	    readOnly => "readOnly"L,	    stillMapped => "stillMapped"L,            ENDCASE => "??"L];        TTY.PutChar[h, ']];        CONTINUE        END;      Space.InsufficientSpace --[available]-- =>        BEGIN        Command.WriteError[h, "Space.InsufficientSpace[available: "L];        TTY.PutLongOctal[h, available];        TTY.PutChar[h, ']];        CONTINUE        END;      Space.IOError =>        BEGIN	Command.WriteError[h, "Space.WriteError[page: "L];	TTY.PutLongNumber[h, page, [8, FALSE, TRUE, 5]];	TTY.PutChar[h, ']];	END;	      String.StringBoundsFault =>        BEGIN	Command.WriteError[h,"String.StringBoundsFault"L];	TTY.PutCR[h];	CONTINUE;	END;      String.InvalidNumber =>        BEGIN        Command.WriteError[h,"String.InvalidNumber"L];        TTY.PutCR[h];	CONTINUE;	END;      ABORTED =>        BEGIN	Command.WriteError[h,"ABORTED"L];        TTY.PutCR[h];	CONTINUE;	END;      END;    action[h]    END;      GetLogicalVolumeID: PROCEDURE [h: TTY.Handle] RETURNS [id: Volume.ID] =    BEGIN    valid: BOOLEAN;    TTY.PutString[h, " logical volume ID: "L];    PilotCommand.UIDToString[      LOOPHOLE[PilotCommand.GetVIDCur[]], currentLogicalVolumeName];    DO  -- until we get one that we like      TTY.GetString[h, currentLogicalVolumeName, Terminator];      [valid, id] ¬ ValidLVName[currentLogicalVolumeName];      IF valid THEN {PilotCommand.SetVIDCur[id]; RETURN; };      [valid, id] ¬ ValidLVIDName[currentLogicalVolumeName];      IF valid THEN {PilotCommand.SetVIDCur[id]; RETURN; };      TTY.PutChar[h, '?];      ENDLOOP;    END;      GetNewLogicalVolumeName: PROCEDURE [h: TTY.Handle] RETURNS [LONG STRING] =    BEGIN    TTY.PutString[h, " logical volume name: "L];    TTY.GetString[h, currentLogicalVolumeName, Terminator];    RETURN[currentLogicalVolumeName];    END;    GetStartingPageNumberForLogicalVolume: PROCEDURE [h: TTY.Handle]    RETURNS [page: PhysicalVolume.PageNumber] =    BEGIN    RETURN[      currentMinimumStartingPage ¬ GetLongNumber[        h, " minimum starting page number: "L, currentMinimumStartingPage, 0,          10]];    END;    GetVolumeSize: PROCEDURE [h: TTY.Handle] RETURNS [size: Volume.PageCount] =    BEGIN    RETURN[      currentVolumeSize ¬ GetLongNumber[        h, " volume size: "L, currentVolumeSize, 0, 10]];    END;    GetVolumeType: PROCEDURE [h: TTY.Handle] RETURNS [type: Volume.Type] =    BEGIN    typeName: STRING ¬ [stringSize];    TTY.PutString[h, " volume type: "L];    String.AppendString[      typeName,      SELECT currentLogicalVolumeType FROM        = normal => "normal"L,        = debugger => "debugger"L,        = debuggerDebugger => "debuggerDebugger"L        ENDCASE => ERROR];    DO  -- Until we get one that we like      TTY.GetString[h, typeName, Terminator];      IF String.EquivalentStrings[typeName, "normal"L] THEN        RETURN[currentLogicalVolumeType ¬ normal]      ELSE        IF String.EquivalentStrings[typeName, "debugger"L] THEN          RETURN[currentLogicalVolumeType ¬ debugger]        ELSE          IF String.EquivalentStrings[typeName, "debuggerDebugger"L] THEN            RETURN[currentLogicalVolumeType ¬ debuggerDebugger];      TTY.PutChar[h, '?];      ENDLOOP;    END;        GetLongNumber: PROCEDURE [    h: TTY.Handle, prompt: STRING, default: LONG UNSPECIFIED,    nullValue: LONG UNSPECIFIED, radix: CARDINAL]    RETURNS [num: LONG UNSPECIFIED] =    BEGIN    numberString: STRING ¬ [stringSize];    IF default = nullValue THEN String.AppendString[numberString, "Null"L]    ELSE String.AppendLongNumber[numberString, default, 10];    TTY.PutString[h, prompt];    DO  -- until we get one that we like      TTY.GetString[h, numberString, Terminator];      IF String.EquivalentStrings[numberString, "Null"L]        OR String.EquivalentStrings[numberString, "Nil"L] THEN RETURN[nullValue];      RETURN[        String.StringToLongNumber[          numberString, 10 ! String.InvalidNumber => {TTY.PutChar[h, '?]; LOOP}]];      ENDLOOP;    END;      PutLogicalVolumeID: PROCEDURE [h: TTY.Handle, id: Volume.ID] =    BEGIN    s: STRING ¬ [stringSize];    PilotCommand.UIDToString[id, s];     TTY.PutString[h, s];    END;        Terminator: PROCEDURE[c: CHARACTER] RETURNS [status: TTY.CharStatus] =    BEGIN    IF c = Ascii.SP OR c = Ascii.CR THEN RETURN [stop] ELSE RETURN [ok];    END;      ValidLVIDName: PROCEDURE [s: LONG STRING] RETURNS [valid: BOOLEAN, id: Volume.ID] =    BEGIN    usersID: System.UniversalID;    getNextTypeSet: Volume.TypeSet = PilotCommand.GetGetNextTypeSetCur[];    IF String.EquivalentStrings[s, "Nil"L] OR String.EquivalentStrings[s, "Null"L]      THEN RETURN[TRUE, Volume.nullID];    [valid, usersID] ¬ PilotCommand.StringToUID[s];    IF ~valid THEN RETURN;    valid ¬ TRUE;    id ¬ Volume.nullID;    WHILE (id ¬ Volume.GetNext[id, getNextTypeSet]) ~= Volume.nullID DO      IF id = usersID THEN RETURN; ENDLOOP;    valid ¬ FALSE;    END;  ValidLVName: PROCEDURE [s: LONG STRING] RETURNS [valid: BOOLEAN, id: Volume.ID] =    BEGIN    label: STRING ¬ [stringSize];    getNextTypeSet: Volume.TypeSet = PilotCommand.GetGetNextTypeSetCur[];    valid ¬ TRUE;    id ¬ Volume.nullID;    WHILE (id ¬ Volume.GetNext[id, getNextTypeSet]) ~= Volume.nullID DO      Volume.GetLabelString[id, label];      IF String.EquivalentStrings[s, label] THEN RETURN;      ENDLOOP;    valid ¬ FALSE;    END;  WriteFileIDs: PUBLIC PROCEDURE [h: TTY.Handle, file: File.File] =    BEGIN     WriteID[h, file.fileID];    TTY.PutString[h, "VID"];    PilotCommand.WriteUniversalID[h, file.volumeID];    SetFileCur[file];    END;      WriteID: PROCEDURE[h: TTY.Handle, fID: File.ID] =    BEGIN    id: ARRAY [0..2) OF WORD ¬ LOOPHOLE[fID];    TTY.PutString[h, "FID"];    TTY.PutChar[h, '[];    TTY.PutOctal[h, id[0]];    TTY.PutChar[h, ',];    TTY.PutOctal[h, id[1]];    TTY.PutChar[h, ']];    END;  WriteVolumeID: PUBLIC PROCEDURE [h: TTY.Handle, volume: Volume.ID] =    BEGIN TTY.PutString[h, "VID"L]; PilotCommand.WriteUniversalID[h, volume] END;  Command.InstallTopLevel[tty, ["file", FileCmd]];  Command.InstallTopLevel[tty, ["volume", VolumeCmd]];  END.LOGTime: August 14, 1980  9:34 PM   By: SXY      Action: IODefs and Command are replaced by TTY and TTYCommand respectively.Time: August 28, 1980  3:00 PM   By: SXY      Action: PBKInputDefs is replaced by UserInput.Time: September 9, 1980  10:47 AM   By: SXY      Action: TTYCommand is replaced by new Command.Time: September 12, 1980  10:50 AM  By: SXY     Action: UserInput is removed and used UserAbort defined in TTY.Time: October 3, 1980  2:19 PM  By: AWL        Action: Added TypeSet args to Volume.GetNext + command/procs to get/set the type set.Time: 8-Sep-81 11:36:27  By: SXY     Action: VolumeRootCmd & VolumeSetRootCmd are commented out.Time: 15-Oct-81 15:25:53 By: Rhodes  Action: Added ScavengeVolume and TypeScavengeLog commands.Time: 25-Nov-81 16:18:32 By: CAJ   Action: Added command 'set current from filename'; PhysicalVolume.CanNotScavenge renamed to NeedsScavenging.Time: 25-Jan-82 17:32:06 By: CAJ   Action: Renamed 'set current' to 'set current from capability'.Time:  6-Jan-83 17:49:26 By: EKN    Action:  Updated to Klamath - Added procedures to test Volume.Create, Volume.Erase.  Deleted File Capabilites and  Space Handles.  Added procedure ReadFileID (modified SystemCommands.ReadUniversalID) and WriteID. Updated VolumeScavengeVolumeCmd to accomodate for repair types.  Time:  7-Jan-83 16:37:29 By: EKN    Action:  Moved the following from PhysicalVolumeCommands: VolumeForceSetLogicalVolumeCmd, VolumeSetCurrentLogicalVolumeCmd, VolumeGetNextLogicalVolume, GetLogicalVolumeID,  PutLogicalVolumeID,ValidLVIDName, ValidLVNameTime: 24-Feb-83  9:42:27 By: EKN     Action: Changed "set current from filename" to "set current from name."  (The command processor was having trouble distinguishing between commands that are a prefix of another).  Substituted instances of Inline.LowHalf with appropiate Types.  Took fileBytes variable out of TypeFile procedure.Time: 11-Mar-83 14:17:20 By: EKN     Action: Removed fileBytes variable from OctalTypeFile and changed "i" in FOR loop to be "il". (must have been changed accidently before) Time:	15-Mar-83 11:21:13	By: JXP   Action:	Add the MakePermanent Command.Time:	12-Apr-83 16:13:29	By: JXP   Action:	Make compatible with new TTY interface.  Time:   30-Jun-83 16:58:23	By: EKN   Action: Move GetNextLogicalVolumeCmd to PhysicalVolumeCommandsTime:   17-Aug-83 14:14:20	By: JXP   Action: Convert to 11.0bTime:    6-Nov-85 18:06:59      By: RSVAction: Changed CARDINALs in CreateCmd and SetSizeCmd to be LONG CARDINALs and changed TTY.GetNumber to TTY.GetLongNumber accordingly (AR 1911).  Put in line to Unmap memory when hitting stop key in OctalTypeFile and TypeFile (AR 4502)Time:    2-Sep-86 15:13:16      By: RSVAction: Changed Scavenger error types and problems list.Time:   22-Sep-86 15:34:37      By: RSVAction: Converted to latest Scavenger interface which doesn't include Scavenger.Problem. 4-Feb-87 15:36:52   CJSAllocated most STRINGs from Local frame since StorageCatch infrequently used.
-- Copyright (C) 1984, 1985  by Xerox Corporation. All rights reserved. -- FloppyEditDataSW.mesa	last edited by: CAJ 	13-May-85 15:48:53-- This module implements the default data display subwindow for the floppy disk editor.DIRECTORY  Ascii USING [CR],  FloppyEditInternal USING [    data, heap, maxSectorWords, Msg, SectorWords, swapWindowKey],  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, CommandItem, DisplayItem,    Enumerated, EnumeratedItem, EnumeratedNotifyProcType, line0, line1, line2,    line3, NumberItem, ProcType, TagOnlyItem, StringItem],  Inline USING [HighByte, LowByte],  MsgSW USING [Clear],  String USING [    AppendChar, AppendNumber, AppendOctal, AppendString, FreeString, MakeString],  Window USING [Handle],  WindowSwap USING [CurrentViewHandle, EstablishViewsWindow];FloppyEditDataSW: PROGRAM  IMPORTS FloppyEditInternal, FormSW, Inline, MsgSW, String, WindowSwap  EXPORTS FloppyEditInternal =  BEGIN  --//////////////////  -- Local TYPEs, constants, and variables  DisplayOptions: TYPE = {    octal, octalByte, octalSwapped, decimal, hex, ascii};  FormItems: TYPE = {    changeItem, bufferIndex, value, displayOption, dataTag, sectorData};  -- line formatting constants  addrChars: CARDINAL = 5;  maxCharsPerWord: CARDINAL = 6;  spaceChars: CARDINAL = 2;  wordsPerLine: CARDINAL = 8;  defaultDisplayOption: DisplayOptions = octal;  defaultRadix: CARDINAL = 8;  bufferIndex: CARDINAL ¬ 0;  displayOption: DisplayOptions ¬ defaultDisplayOption;  displayString: LONG STRING ¬ NIL;  newValue: WORD ¬ 0;  radix: CARDINAL ¬ defaultRadix;  --//////////////////  -- Procedures  ChangeDisplayOption: FormSW.EnumeratedNotifyProcType =    BEGIN    MsgSW.Clear[FloppyEditInternal.data.msgSW];    SELECT displayOption FROM      octal => radix ¬ 8;      hex => radix ¬ 16;      decimal => radix ¬ 10;      ascii => NULL;      ENDCASE =>        BEGIN        FloppyEditInternal.Msg["Option not implemented."L, TRUE];        displayOption ¬ oldValue;        FormSW.DisplayItem[          WindowSwap.CurrentViewHandle[FloppyEditInternal.swapWindowKey],          FormItems.displayOption.ORD];        END;    IF (displayOption ~= DisplayOptions[oldValue]) AND (displayString.length > 0)      THEN      BEGIN      FillDataSW[];      FormSW.DisplayItem[        WindowSwap.CurrentViewHandle[FloppyEditInternal.swapWindowKey],        FormItems.sectorData.ORD];      END;    END;  ChangeItem: FormSW.ProcType =    BEGIN    MsgSW.Clear[FloppyEditInternal.data.msgSW];    IF FloppyEditInternal.data.writesDisallowed THEN      FloppyEditInternal.Msg["Writes disallowed!"L, TRUE]    ELSE      BEGIN      FloppyEditInternal.data.sectorBuffer[bufferIndex] ¬ newValue;      FillDataSW[];      FormSW.DisplayItem[        WindowSwap.CurrentViewHandle[FloppyEditInternal.swapWindowKey],        FormItems.sectorData.ORD];      END;    END;  CleanupDataSW: PROCEDURE =    -- Make data buffer match display.    -- No action needed here since display is read only and data buffer is    -- modified as items are changed.    {};  DestroyDataSW: PROCEDURE =    -- Clean up for view going away for good    BEGIN    String.FreeString[z: FloppyEditInternal.heap, s: displayString];    displayString ¬ NIL;    END;  FillDataSW: PROCEDURE =    -- Make display match data buffer.    BEGIN    -- Check line formatting constants (global) if changing line print formats.    i: CARDINAL ¬ 0;    nLines: CARDINAL =      (FloppyEditInternal.SectorWords[] + wordsPerLine - 1) / wordsPerLine;    s: STRING ¬ [6];    spaces: STRING ¬ "  "L;    -- The following two checks ensure that formatting here follows assumptions    -- made elsewhere about print format based on global constants.  If this    -- check fails, adjust to match.    -- ASSERT:--    sCheck: BOOLEAN [TRUE..TRUE] = (s.length = maxCharsPerWord);    spacesCheck: BOOLEAN [TRUE..TRUE] = (spaces.length = spaceChars);    FormatWord: PROCEDURE [word: WORD] =      BEGIN      -- Change (number) word to string, right justify, and fill leading blanks      fill: CARDINAL;      s.length ¬ 0;      SELECT displayOption FROM        octal, hex, decimal =>          BEGIN          String.AppendNumber[s, word, radix];          fill ¬ s.maxlength - s.length;          FOR i: CARDINAL IN [1..s.length] DO            s[s.maxlength - i] ¬ s[s.length - i]; ENDLOOP;          FOR i: CARDINAL IN [0..fill) DO s[i] ¬ ' ; ENDLOOP;          s.length ¬ s.maxlength;          END;        ascii =>          BEGIN          s[0] ¬ s[1] ¬ ' ;          s[2] ¬ LOOPHOLE[Inline.HighByte[word], CHAR];          s[3] ¬ LOOPHOLE[Inline.LowByte[word], CHAR];          s.length ¬ 4;          END;        ENDCASE => {s ¬ " @"L; s.length ¬ 2};      END;  -- FormatWord    -- May be coming up from tiny.    IF displayString = NIL THEN displayString ¬ MakeDisplayBuffer[];    -- Turn whole data buffer into one long string    displayString.length ¬ 0;    THROUGH [0..nLines) DO      -- Quick and dirty line id      IF i < 100B THEN String.AppendChar[displayString, ' ];      IF i < 10B THEN String.AppendChar[displayString, ' ];      String.AppendOctal[displayString, i];      String.AppendChar[displayString, '/];      THROUGH [0..wordsPerLine) DO        String.AppendString[displayString, spaces];        FormatWord[FloppyEditInternal.data.sectorBuffer[i]];        String.AppendString[displayString, s];        i ¬ i + 1;        ENDLOOP;      String.AppendChar[displayString, Ascii.CR];      ENDLOOP;    END;  InitializeViewSwappingWindow: PUBLIC PROCEDURE =    BEGIN    -- Register this subwindow as the default view for the data subwindow    menuWindows: ARRAY [0..3) OF Window.Handle;    menuWindows[0] ¬ FloppyEditInternal.data.msgSW;    menuWindows[1] ¬ FloppyEditInternal.data.ioSW;    menuWindows[2] ¬ FloppyEditInternal.data.contextSW;    FloppyEditInternal.swapWindowKey ¬ WindowSwap.EstablishViewsWindow[      menuName: "Data views"L, viewH: FloppyEditInternal.data.dataSW,  -- sw created at tool create time      viewName: "Data"L, viewFromDataProc: FillDataSW,      dataFromViewProc: CleanupDataSW,      destroyViewProc: DestroyDataSW,      otherWindows: DESCRIPTOR[BASE[menuWindows], 3]];    END;  MakeDataSW: PUBLIC FormSW.ClientItemsProcType =    BEGIN    nItems: CARDINAL = FormItems.LAST.ORD + 1;    displayOptions: ARRAY [0..6) OF FormSW.Enumerated ¬ [      ["octal"L, DisplayOptions[octal]], [      "octalByte"L, DisplayOptions[octalByte]], [      "octalSwapped"L, DisplayOptions[octalSwapped]], [      "decimal"L, DisplayOptions[decimal]], ["hex"L, DisplayOptions[hex]], [      "ascii"L, DisplayOptions[ascii]]];    displayString ¬ MakeDisplayBuffer[];    items ¬ FormSW.AllocateItemDescriptor[nItems];    items[FormItems.changeItem.ORD] ¬ FormSW.CommandItem[      tag: "ChangeItem"L, place: [0, FormSW.line0], proc: ChangeItem      --, z: FloppyEditInternal.heap-- ];    items[FormItems.bufferIndex.ORD] ¬ FormSW.NumberItem[      tag: "index "L, place: [120, FormSW.line0], signed: FALSE,      notNegative: TRUE, default: 0, value: @bufferIndex      --, z: FloppyEditInternal.heap-- ];    items[FormItems.value.ORD] ¬ FormSW.NumberItem[      tag: "value "L, place: [240, FormSW.line0], signed: FALSE,      notNegative: TRUE, default: 0, value: @newValue      --, z: FloppyEditInternal.heap-- ];    items[FormItems.displayOption.ORD] ¬ FormSW.EnumeratedItem[      tag: "Data display option"L, place: [0, FormSW.line1], feedback: all,      proc: ChangeDisplayOption, choices: DESCRIPTOR[displayOptions],      value: @displayOption --, z: FloppyEditInternal.heap-- ];    items[FormItems.dataTag.ORD] ¬ FormSW.TagOnlyItem[      tag: "Data"L, place: [0, FormSW.line2], readOnly: TRUE      --, z: FloppyEditInternal.heap-- ];    items[FormItems.sectorData.ORD] ¬ FormSW.StringItem[      tag: NIL, place: [0, FormSW.line3], readOnly: TRUE, inHeap: FALSE,      string: @displayString --, z: FloppyEditInternal.heap-- ];    RETURN[items, TRUE];    END;  -- MakeDataSW  MakeDisplayBuffer: PROCEDURE RETURNS [LONG STRING] =    BEGIN    lineChars: CARDINAL =      addrChars + wordsPerLine * (maxCharsPerWord + spaceChars) + 1;    maxLines: CARDINAL =      (FloppyEditInternal.maxSectorWords + wordsPerLine - 1) / wordsPerLine;    RETURN[String.MakeString[      z: FloppyEditInternal.heap, maxlength: lineChars * maxLines]];    END;  -- MakeDisplayBuffer  END.LOG25-Sep-84 16:45:27   CAJ	Created file.13-May-85 15:21:10   CAJ	Added DestroyDataSW proc, string buffer becomes locally managed, use default heap in MakeForm.
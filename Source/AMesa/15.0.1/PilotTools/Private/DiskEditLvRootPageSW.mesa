-- Copyright (C) 1984, 1986, 1987, 1988  by Xerox Corporation. All rights reserved. -- DiskEditLVRootPageSW.mesa     7-Mar-88  9:32:22 by CAJ 				 DIRECTORY  Boot USING [BootFileType, DiskFileID, VolumeType],  DiskEditInternal USING [    dataPtr, dataWindowKey, ReplaceFIDString, ReplaceUIDString, ValidateFID,    ValidateUID],  File USING [ID, nullID, Type],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType, CommandItem,    DisplayItem, Enumerated, EnumeratedItem, EnumeratedNotifyProcType,    FilterProcType, FindItem, ItemHandle, LabelItem, LongNumberItem, MenuProcType,    newLine, nextLine, nextPlace, NumberItem, NumberNotifyProcType, ProcType,    StringEditProc, StringItem, ToggleVisibility],  Heap USING [systemZone],  Inline USING [BITAND],  LogicalVolumeFormat USING [    currentVersion, Descriptor, LockState, maxLogicalVolumeLabelLength,    lvRootSeal],  PilotDisk USING [FileID, FilePageNumber, nullFileID],  PilotFileTypes USING [    PilotRootFileType, tBeingMoved, tBeingReplicated, tFreePage, tScavengerLog,    tTempFileList, tTransactionStateFile, tVMBackingFile, tVolumeAllocationMap,    tVolumeFileMap],  String USING [FreeString, Replace],  System USING [UniversalID],  UserTerminal USING [BlinkDisplay],  Volume USING [Type],  Window USING [Handle],  WindowSwap USING [CurrentViewHandle, RegisterView];DiskEditLVRootPageSW: PROGRAM  IMPORTS DiskEditInternal, FormSW, Heap, Inline, String, UserTerminal,    WindowSwap  SHARES Boot, File =  BEGIN  FormItems: TYPE = {    begin, title, seal, version, id, labelLength, labelString, type, size,    bootFile, bootfileID, bootfileFirstPage, daTag, daCyl, daHead, daSector,    pad, pad1, changing, freePageCount, vamStart, lowerBound, primaryETable,    copyETable, statusPrimary, statusCopy, rootDir, rootFile, rootFileID,    scavengerLogID, lastID, lastTimeOpened, numberOfFiles, numberOfBadPages,    lock, owner, lockState, lockCount, lockNull, fillIndex, fillValue, next,    back, checksum};  sw: Window.Handle ¬ NIL;  enumeratedLockState: ARRAY [0..4) OF FormSW.Enumerated = [    [string: "unlocked"L, value: LogicalVolumeFormat.LockState[unlocked]],    [string: "write"L, value: LogicalVolumeFormat.LockState[write]],    [string: "read"L, value: LogicalVolumeFormat.LockState[read]],    [string: "spare"L, value: LogicalVolumeFormat.LockState[spare]]];  enumeratedLVBootFiles: ARRAY [0..6) OF FormSW.Enumerated = [    [string: "hardMicrocode"L, value: Boot.BootFileType[hardMicrocode]], [    string: "softMicrocode"L, value: Boot.BootFileType[softMicrocode]], [    string: "germ"L, value: Boot.BootFileType[germ]], [    string: "pilot"L, value: Boot.BootFileType[pilot]], [    string: "debugger"L, value: Boot.BootFileType[debugger]], [    string: "debuggee"L, value: Boot.BootFileType[debuggee]]];  enumeratedLVTypeArray: ARRAY [0..4) OF FormSW.Enumerated = [    [string: "normal"L, value: Volume.Type[normal]], [    string: "debugger"L, value: Volume.Type[debugger]], [    string: "debuggerDebugger"L, value: Volume.Type[debuggerDebugger]], [    string: "nonPilot"L, value: Volume.Type[nonPilot]]];    cardinalGmtEpoch: LONG CARDINAL = 2114294400;   HeadOrSector: TYPE = [0..255];  lvRootPage: RECORD [    -- fields herein which are passed to FormSW must be word-aligned.    IDString: LONG STRING ¬ NIL,    labelString: LONG STRING ¬ NIL,    type: Boot.VolumeType ¬ normal,    alignA: CARDINAL ¬ 0,    volumeRootDirectoryIDString: LONG STRING ¬ NIL,    currentFillIndex: CARDINAL ¬ 0,    currentFillValue: WORD ¬ 0,    currentRootFileType: File.Type ¬ PilotFileTypes.tFreePage,    currentRootFileIDString: LONG STRING ¬ NIL,    currentRootFileID: File.ID ¬ File.nullID,    changing: BOOLEAN ¬ FALSE,    statusPrimaryETableFile: CARDINAL ¬ 0,    statusCopyETableFile: CARDINAL ¬ 0,    scavengerIDString: LONG STRING ¬ NIL,    alignB: CARDINAL ¬ 0,    currentBootFileType: Boot.BootFileType ¬ pilot,    currentBootFileFileIDString: LONG STRING ¬ NIL,    currentBootFileDiskFileID: PilotDisk.FileID ¬ PilotDisk.nullFileID,    currentBootFileFirstPage: PilotDisk.FilePageNumber ¬ 0,    currentBootFileCyl: WORD ¬ 0,    currentBootFileHead: HeadOrSector ¬ 0,    alignC: CARDINAL ¬ 0,    currentBootFileSector: HeadOrSector ¬ 0,    labelLength: CARDINAL ¬ 0,    pad1: CARDINAL ¬ 0,    lockOwnerIDString: LONG STRING ¬ NIL,    lockState: LogicalVolumeFormat.LockState,    lockCount: CARDINAL ¬ 0,    lockNull: CARDINAL ¬ 0];      lv: LONG POINTER TO LogicalVolumeFormat.Descriptor =    LOOPHOLE[DiskEditInternal.dataPtr];  CleanupLvRootPageSW: PROCEDURE =    BEGIN    -- The only things that are copied here are things that occupy less than a    -- full  word in the actual root page.  Other things are set directly by    -- the form sw.    lv.type ¬ lvRootPage.type;    lv.changing ¬ lvRootPage.changing;    lv.statusPrimaryETableFile ¬ lvRootPage.statusPrimaryETableFile;    lv.statusCopyETableFile ¬ lvRootPage.statusCopyETableFile;    lv.bootingInfo[lvRootPage.currentBootFileType] ¬      [fID: lvRootPage.currentBootFileDiskFileID,       firstPage: lvRootPage.currentBootFileFirstPage,       da: [cylinder: lvRootPage.currentBootFileCyl,         head: lvRootPage.currentBootFileHead,         sector: lvRootPage.currentBootFileSector]];    lv.rootFileID[lvRootPage.currentRootFileType] ¬ lvRootPage.currentRootFileID;    SELECT lvRootPage.lockState FROM      unlocked =>lv.lock.lock ¬  unlocked [null: lvRootPage.lockNull];      write => lv.lock.lock ¬ write [null: lvRootPage.lockNull];      read =>        lv.lock.lock ¬ read [	  count: lvRootPage.lockCount, null: lvRootPage.lockNull];      ENDCASE => NULL;    END;  CopyLabel: FormSW.FilterProcType =    BEGIN    FormSW.StringEditProc[sw, item, insert, string];    FOR i: CARDINAL IN      [0..MIN[         LogicalVolumeFormat.maxLogicalVolumeLabelLength,         lvRootPage.labelString.length]) DO      lv.label[i] ¬ lvRootPage.labelString[i]; ENDLOOP;    END;  DestroyLvRootPageSW: PROCEDURE =    BEGIN    String.FreeString[z: Heap.systemZone, s: lvRootPage.IDString];    lvRootPage.IDString ¬ NIL;    String.FreeString[z: Heap.systemZone, s: lvRootPage.labelString];    lvRootPage.labelString ¬ NIL;    String.FreeString[      z: Heap.systemZone, s: lvRootPage.volumeRootDirectoryIDString];    lvRootPage.volumeRootDirectoryIDString ¬ NIL;    String.FreeString[z: Heap.systemZone, s: lvRootPage.currentRootFileIDString];    lvRootPage.currentRootFileIDString ¬ NIL;    String.FreeString[z: Heap.systemZone, s: lvRootPage.scavengerIDString];    lvRootPage.scavengerIDString ¬ NIL;    String.FreeString[      z: Heap.systemZone, s: lvRootPage.currentBootFileFileIDString];    lvRootPage.currentBootFileFileIDString ¬ NIL;    String.FreeString[z: Heap.systemZone, s: lvRootPage.lockOwnerIDString];    lvRootPage.lockOwnerIDString ¬ NIL;    sw ¬ NIL;    END;  -- DestroyLvRootPageSW  FillBackCommand: FormSW.ProcType =    BEGIN    IF lvRootPage.currentFillIndex IN [0..LENGTH[lv.fill]) THEN      lv.fill[lvRootPage.currentFillIndex] ¬ lvRootPage.currentFillValue;    lvRootPage.currentFillIndex ¬      IF lvRootPage.currentFillIndex = 0 THEN LENGTH[lv.fill] - 1      ELSE lvRootPage.currentFillIndex - 1;    lvRootPage.currentFillValue ¬ lv.fill[lvRootPage.currentFillIndex];    FormSW.DisplayItem[sw, FormItems.fillIndex.ORD];    FormSW.DisplayItem[sw, FormItems.fillValue.ORD];    END;  FillLvRootPageSW: PROCEDURE =    BEGIN    volumeLabel: STRING ¬ [LogicalVolumeFormat.maxLogicalVolumeLabelLength];    IF sw = NIL THEN      sw ¬ WindowSwap.CurrentViewHandle[DiskEditInternal.dataWindowKey];    DiskEditInternal.ReplaceUIDString[@lvRootPage.IDString, lv.vID];    volumeLabel.length ¬ 0;    FOR i: CARDINAL IN      [0..MIN[LogicalVolumeFormat.maxLogicalVolumeLabelLength, lv.labelLength]) DO      volumeLabel[i] ¬ lv.label[i];      volumeLabel.length ¬ volumeLabel.length + 1      ENDLOOP;    String.Replace[@lvRootPage.labelString, volumeLabel, Heap.systemZone];    lvRootPage.labelLength ¬ lv.labelLength;    lvRootPage.type ¬ lv.type;    lvRootPage.changing ¬ lv.changing;    lvRootPage.statusPrimaryETableFile ¬ lv.statusPrimaryETableFile;    lvRootPage.statusCopyETableFile ¬ lv.statusCopyETableFile;    DiskEditInternal.ReplaceFIDString[      @lvRootPage.volumeRootDirectoryIDString, lv.volumeRootDirectory];    lvRootPage.currentFillValue ¬ lv.fill[lvRootPage.currentFillIndex];    lvRootPage.currentBootFileDiskFileID ¬      lv.bootingInfo[lvRootPage.currentBootFileType].fID;    lvRootPage.currentBootFileFirstPage ¬       lv.bootingInfo[lvRootPage.currentBootFileType].firstPage;    lvRootPage.currentBootFileCyl ¬       lv.bootingInfo[lvRootPage.currentBootFileType].da.cylinder;    lvRootPage.currentBootFileHead ¬       lv.bootingInfo[lvRootPage.currentBootFileType].da.head;    lvRootPage.currentBootFileSector ¬       lv.bootingInfo[lvRootPage.currentBootFileType].da.sector;    DiskEditInternal.ReplaceUIDString[      @lvRootPage.currentBootFileFileIDString,      LOOPHOLE[lvRootPage.currentBootFileDiskFileID]];    lvRootPage.currentRootFileID ¬ lv.rootFileID[lvRootPage.currentRootFileType];    DiskEditInternal.ReplaceFIDString[      @lvRootPage.currentRootFileIDString, lvRootPage.currentRootFileID];    DiskEditInternal.ReplaceUIDString[      @lvRootPage.scavengerIDString, lv.scavengerLogVolume];    DiskEditInternal.ReplaceUIDString[      @lvRootPage.lockOwnerIDString, LOOPHOLE[lv.lock.owner]];    lvRootPage.lockState ¬ lv.lock.stateTag;    SetLockState[lvRootPage.lockState];    FormSW.FindItem[sw, FormItems.lockCount.ORD].flags.invisible ¬      (lvRootPage.lockState ~= read);    END;  FillNextCommand: FormSW.ProcType =    BEGIN    IF lvRootPage.currentFillIndex IN [0..LENGTH[lv.fill]) THEN      lv.fill[lvRootPage.currentFillIndex] ¬ lvRootPage.currentFillValue;    lvRootPage.currentFillIndex ¬      (lvRootPage.currentFillIndex + 1) MOD LENGTH[lv.fill];    lvRootPage.currentFillValue ¬ lv.fill[lvRootPage.currentFillIndex];    FormSW.DisplayItem[sw, FormItems.fillIndex.ORD];    FormSW.DisplayItem[sw, FormItems.fillValue.ORD];    END;  MakeLvRootPageSW: FormSW.ClientItemsProcType =    BEGIN    nItems: CARDINAL = 44;    items ¬ FormSW.AllocateItemDescriptor[nItems];    items[FormItems.begin.ORD] ¬ FormSW.LabelItem[      tag: NIL, invisible: TRUE, place: FormSW.newLine];    items[FormItems.title.ORD] ¬ FormSW.LabelItem[      tag: "Logical volume root page"L, place: FormSW.newLine];    items[FormItems.seal.ORD] ¬ FormSW.NumberItem[      tag: "Seal"L, signed: FALSE, notNegative: TRUE, radix: octal,      default: LogicalVolumeFormat.lvRootSeal, value: @lv.seal,      place: FormSW.nextPlace];    items[FormItems.version.ORD] ¬ FormSW.NumberItem[      tag: "Version"L, signed: FALSE, notNegative: TRUE, radix: octal,      default: LogicalVolumeFormat.currentVersion, value: @lv.version,      place: FormSW.nextPlace];    items[FormItems.id.ORD] ¬ FormSW.StringItem[      tag: "ID"L, inHeap: FALSE, string: @lvRootPage.IDString,      filterProc: ValidateLVID, place: FormSW.newLine];    items[FormItems.labelLength.ORD] ¬ FormSW.NumberItem[      tag: "Label length"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, value: @lv.labelLength, place: FormSW.newLine];    items[FormItems.labelString.ORD] ¬ FormSW.StringItem[      tag: "Label"L, inHeap: FALSE, string: @lvRootPage.labelString,      filterProc: CopyLabel, place: FormSW.nextPlace];    BEGIN    localLVTypeArray: ARRAY [0..LENGTH[enumeratedLVTypeArray]) OF      FormSW.Enumerated ¬ enumeratedLVTypeArray;    items[FormItems.type.ORD] ¬ FormSW.EnumeratedItem[      tag: "Type"L, feedback: one, copyChoices: TRUE, value: @lvRootPage.type,      choices: DESCRIPTOR[localLVTypeArray], place: FormSW.newLine];    END;    items[FormItems.size.ORD] ¬ FormSW.LongNumberItem[      tag: "Size"L, signed: FALSE, notNegative: TRUE, radix: decimal, default: 0,      value: @lv.volumeSize, place: FormSW.nextPlace];    BEGIN    localLVBootFiles: ARRAY [0..LENGTH[enumeratedLVBootFiles]) OF      FormSW.Enumerated ¬ enumeratedLVBootFiles;    items[FormItems.bootFile.ORD] ¬ FormSW.EnumeratedItem[      tag: "Boot file for type"L, feedback: one, copyChoices: TRUE,      value: @lvRootPage.currentBootFileType, proc: NoticeNewBootFileType,      choices: DESCRIPTOR[localLVBootFiles], place: FormSW.newLine];    items[FormItems.bootfileID.ORD] ¬ FormSW.StringItem[      tag: "ID"L, inHeap: FALSE, string: @lvRootPage.currentBootFileFileIDString,      filterProc: ValidateBootFileID, place: FormSW.nextPlace];    items[FormItems.bootfileFirstPage.ORD] ¬ FormSW.LongNumberItem[      tag: "   First page"L, notNegative: TRUE, signed: FALSE, default: 0,      radix: decimal, value: @lvRootPage.currentBootFileFirstPage,      place: FormSW.newLine];    items[FormItems.daTag.ORD] ¬ FormSW.LabelItem[      tag: "Disk address"L, place: FormSW.nextPlace];    items[FormItems.daCyl.ORD] ¬ FormSW.NumberItem[      tag: "a"L, notNegative: TRUE, signed: FALSE, default: 0, radix: octal,      value: @lvRootPage.currentBootFileCyl, place: FormSW.nextPlace];    items[FormItems.daHead.ORD] ¬ FormSW.NumberItem[      tag: "b"L, notNegative: TRUE, signed: FALSE, default: 0, radix: octal,      value: @lvRootPage.currentBootFileHead, place: FormSW.nextPlace];    items[FormItems.daSector.ORD] ¬ FormSW.NumberItem[      tag: "c"L, notNegative: TRUE, signed: FALSE, default: 0, radix: octal,      value: @lvRootPage.currentBootFileSector, place: FormSW.nextPlace];    END;    items[FormItems.pad.ORD] ¬ FormSW.NumberItem[      tag: "Pad"L, signed: FALSE, notNegative: TRUE,      radix: octal, default: 0, value: @lv.pad, place: FormSW.newLine];    items[FormItems.pad1.ORD] ¬ FormSW.NumberItem[      tag: "Pad1"L, signed: FALSE, notNegative: TRUE,      radix: octal, default: 0, value: @lvRootPage.pad1,      proc: ValidatePad1, place: FormSW.nextPlace];    items[FormItems.changing.ORD] ¬ FormSW.BooleanItem[      tag: "Changing"L, switch: @lvRootPage.changing, place: FormSW.nextPlace];    items[FormItems.freePageCount.ORD] ¬ FormSW.LongNumberItem[      tag: "Free page count"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, value: @lv.freePageCount, place: FormSW.newLine];    items[FormItems.vamStart.ORD] ¬ FormSW.LongNumberItem[      tag: "VAM start"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, value: @lv.vamStart, place: FormSW.nextPlace];    items[FormItems.lowerBound.ORD] ¬ FormSW.LongNumberItem[      tag: "Lower bound"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, value: @lv.lowerBound, place: FormSW.nextPlace];    items[FormItems.primaryETable.ORD] ¬ FormSW.LongNumberItem[      tag: "Primary ETable start"L, signed: FALSE, notNegative: TRUE,      radix: decimal, default: 0, value: @lv.primaryETableStartPage,      place: FormSW.newLine];    items[FormItems.copyETable.ORD] ¬ FormSW.LongNumberItem[      tag: "Copy ETable start"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, value: @lv.copyETableStartPage, place: FormSW.nextPlace];    items[FormItems.statusPrimary.ORD] ¬ FormSW.NumberItem[      tag: "StatusPrimaryETableFile"L, signed: FALSE, notNegative: TRUE,      radix: octal, default: 0, value: @lvRootPage.statusPrimaryETableFile,      proc: ValidatePrimaryStatus, place: FormSW.newLine];    items[FormItems.statusCopy.ORD] ¬ FormSW.NumberItem[      tag: "StatusCopyETableFile"L, signed: FALSE, notNegative: TRUE,      radix: octal, default: 0, value: @lvRootPage.statusCopyETableFile,      proc: ValidateCopyStatus, place: FormSW.nextPlace];    items[FormItems.rootDir.ORD] ¬ FormSW.StringItem[      tag: "Client volumeRootDirectory"L, inHeap: FALSE,      string: @lvRootPage.volumeRootDirectoryIDString,      filterProc: ValidateRootDirectoryID, place: FormSW.newLine];    BEGIN    enumeratedLVRootFiles: ARRAY [0..9) OF FormSW.Enumerated ¬ [      [string: "tBeingMoved"L, value: PilotFileTypes.tBeingMoved], [      string: "tBeingReplicated"L, value: PilotFileTypes.tBeingReplicated], [      string: "tFreePage"L, value: PilotFileTypes.tFreePage], [      string: "tScavengerLog"L, value: PilotFileTypes.tScavengerLog], [      string: "tTempFileList"L, value: PilotFileTypes.tTempFileList], [      string: "tTransactionStateFile"L,      value: PilotFileTypes.tTransactionStateFile], [      string: "tVMBackingFile"L, value: PilotFileTypes.tVMBackingFile], [      string: "tVolumeAllocationMap"L,      value: PilotFileTypes.tVolumeAllocationMap], [      string: "tVolumeFileMap"L, value: PilotFileTypes.tVolumeFileMap]];    items[FormItems.rootFile.ORD] ¬ FormSW.EnumeratedItem[      tag: "Root file for type"L, feedback: one, copyChoices: TRUE,      value: @lvRootPage.currentRootFileType, proc: NoticeNewRootFileType,      choices: DESCRIPTOR[enumeratedLVRootFiles], place: FormSW.newLine];    items[FormItems.rootFileID.ORD] ¬ FormSW.StringItem[      tag: "ID"L, inHeap: FALSE, string: @lvRootPage.currentRootFileIDString,      filterProc: ValidateRootFileID, place: FormSW.nextPlace];    END;    items[FormItems.scavengerLogID.ORD] ¬ FormSW.StringItem[      tag: "ScavengerLogVolumeID"L, inHeap: FALSE,      string: @lvRootPage.scavengerIDString, filterProc: ValidateScavengerID,      place: FormSW.newLine];    items[FormItems.lastID.ORD] ¬ FormSW.LongNumberItem[      tag: "LastIDAllocated"L, signed: FALSE, notNegative: TRUE, radix: octal,      default: 0, value: @lv.lastIDAllocated, place: FormSW.newLine];    items[FormItems.lastTimeOpened.ORD] ¬ FormSW.LongNumberItem[      tag: "LastTimeOpenedForWrite"L, signed: FALSE, notNegative: TRUE,       radix: octal, default: cardinalGmtEpoch,      value: @LOOPHOLE[lv.lastTimeOpendForWrite, LONG CARDINAL],      place: FormSW.newLine];    items[FormItems.numberOfFiles.ORD] ¬ FormSW.LongNumberItem[      tag: "NumberOfFiles"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, value: @lv.numberOfFile, place: FormSW.newLine];    items[FormItems.numberOfBadPages.ORD] ¬ FormSW.LongNumberItem[      tag: "NumberOfBadPagesLastTime"L, signed: FALSE, notNegative: TRUE,      radix: decimal, default: 0, value: @lv.numberOfBadPagesLastTime,      place: FormSW.nextPlace];    BEGIN    localLockStateArray: ARRAY [0..LENGTH[enumeratedLockState]) OF      FormSW.Enumerated ¬ enumeratedLockState;    items[FormItems.lock.ORD] ¬ FormSW.LabelItem[      tag: "VolumeLock"L, place: FormSW.newLine];    items[FormItems.owner.ORD] ¬ FormSW.StringItem[      tag: "owner"L, inHeap: FALSE,      string: @lvRootPage.lockOwnerIDString, filterProc: ValidateLockOwnerID,      place: FormSW.nextPlace];    items[FormItems.lockState.ORD] ¬ FormSW.EnumeratedItem[      tag: "Lock state"L, feedback: one, copyChoices: TRUE,      value: @lvRootPage.lockState, choices: DESCRIPTOR[localLockStateArray],      proc: NoticeNewLockState, place: [15, FormSW.nextLine]];    items[FormItems.lockCount.ORD] ¬ FormSW.NumberItem[      tag: "count", signed: FALSE, notNegative: TRUE, radix: decimal, default: 0,      value: @lvRootPage.lockCount, proc: ValidateLockCount,      place: FormSW.nextPlace];    items[FormItems.lockNull.ORD] ¬ FormSW.NumberItem[      tag: "null", signed: FALSE, notNegative: TRUE, radix: decimal, default: 0,      value: @lvRootPage.lockNull, proc: ValidateLockNull,      place: FormSW.nextPlace];    END;    items[FormItems.fillIndex.ORD] ¬ FormSW.NumberItem[      tag: "Fill word index"L, signed: FALSE, notNegative: TRUE, radix: octal,      default: 0, value: @lvRootPage.currentFillIndex, proc: NoticeNewFillIndex,      place: FormSW.newLine];    items[FormItems.fillValue.ORD] ¬ FormSW.NumberItem[      tag: "Value", signed: FALSE, notNegative: TRUE, radix: decimal, default: 0,      value: @lvRootPage.currentFillValue, place: FormSW.nextPlace];    items[FormItems.next.ORD] ¬ FormSW.CommandItem[      tag: "Next", proc: FillNextCommand, place: FormSW.nextPlace];    items[FormItems.back.ORD] ¬ FormSW.CommandItem[      tag: "Back", proc: FillBackCommand, place: FormSW.nextPlace];    items[FormItems.checksum.ORD] ¬ FormSW.NumberItem[      tag: "Checksum"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, value: @lv.checksum, place: FormSW.newLine];    RETURN[items, TRUE]    END;  NoticeNewBootFileType: FormSW.EnumeratedNotifyProcType =    BEGIN    lv.bootingInfo[oldValue] ¬      [fID: lvRootPage.currentBootFileDiskFileID,       firstPage: lvRootPage.currentBootFileFirstPage,       da: [cylinder: lvRootPage.currentBootFileCyl,         head: lvRootPage.currentBootFileHead,         sector: lvRootPage.currentBootFileSector]];    DiskEditInternal.ReplaceUIDString[      @lvRootPage.currentBootFileFileIDString, LOOPHOLE[lv.bootingInfo[      lvRootPage.currentBootFileType].fID]];    lvRootPage.currentBootFileDiskFileID ¬      lv.bootingInfo[lvRootPage.currentBootFileType].fID;    lvRootPage.currentBootFileFirstPage ¬       lv.bootingInfo[lvRootPage.currentBootFileType].firstPage;    lvRootPage.currentBootFileCyl ¬       lv.bootingInfo[lvRootPage.currentBootFileType].da.cylinder;    lvRootPage.currentBootFileHead ¬       lv.bootingInfo[lvRootPage.currentBootFileType].da.head;    lvRootPage.currentBootFileSector ¬       lv.bootingInfo[lvRootPage.currentBootFileType].da.sector;    FormSW.DisplayItem[sw, FormItems.bootfileID.ORD];    FormSW.DisplayItem[sw, FormItems.bootfileFirstPage.ORD];    FormSW.DisplayItem[sw, FormItems.daCyl.ORD];    FormSW.DisplayItem[sw, FormItems.daHead.ORD];    FormSW.DisplayItem[sw, FormItems.daSector.ORD];    END;  NoticeNewFillIndex: FormSW.NumberNotifyProcType =    BEGIN    IF oldValue IN [0..LENGTH[lv.fill]) THEN      lv.fill[oldValue] ¬ lvRootPage.currentFillValue;    IF lvRootPage.currentFillIndex ~IN [0..LENGTH[lv.fill]) THEN      BEGIN UserTerminal.BlinkDisplay[]; RETURN; END;    lvRootPage.currentFillValue ¬ lv.fill[lvRootPage.currentFillIndex];    FormSW.DisplayItem[sw, FormItems.fillValue.ORD];    END;  NoticeNewLockState: FormSW.EnumeratedNotifyProcType =    BEGIN    typedOldValue: LogicalVolumeFormat.LockState ¬ LOOPHOLE[oldValue];    SELECT lvRootPage.lockState FROM      typedOldValue => RETURN;      unlocked, write, read =>        {SetLockState[lvRootPage.lockState];	 IF typedOldValue = read OR lvRootPage.lockState = read THEN	   FormSW.ToggleVisibility[sw, FormItems.lockCount.ORD]};      ENDCASE => UserTerminal.BlinkDisplay[];    END;  NoticeNewRootFileType: FormSW.EnumeratedNotifyProcType =    BEGIN    DiskEditInternal.ReplaceFIDString[      @lvRootPage.currentRootFileIDString,      lv.rootFileID[lvRootPage.currentRootFileType]];    FormSW.DisplayItem[sw, FormItems.rootFileID.ORD];    END;  SetLockState: PROCEDURE [lockState: LogicalVolumeFormat.LockState] =    BEGIN    pLockWord: LONG POINTER ¬ @lv.lock.lock;    WITH l: lv.lock SELECT FROM      unlocked, write => lvRootPage.lockNull ¬        -- gross type-system evasion to get l.null:        Inline.BITAND[pLockWord­, 037777B];      read => {lvRootPage.lockCount ¬ l.count; lvRootPage.lockNull ¬        Inline.BITAND[pLockWord­, 001777B]};      ENDCASE => NULL;    END;  ValidateRootDirectoryID: FormSW.FilterProcType =    BEGIN    valid: BOOLEAN;    id: File.ID;    FormSW.StringEditProc[sw, item, insert, string];    [valid, id] ¬      DiskEditInternal.ValidateFID[lvRootPage.volumeRootDirectoryIDString];    IF ~valid THEN UserTerminal.BlinkDisplay[]    ELSE lv.volumeRootDirectory ¬ LOOPHOLE[id];    END;    ValidateBootFileID: FormSW.FilterProcType =    BEGIN    valid: BOOLEAN;    id: System.UniversalID;    FormSW.StringEditProc[sw, item, insert, string];    [valid, id] ¬ DiskEditInternal.ValidateUID[      lvRootPage.currentBootFileFileIDString];    IF ~valid THEN UserTerminal.BlinkDisplay[]    ELSE lvRootPage.currentBootFileDiskFileID ¬ LOOPHOLE[id];    END;  ValidateLockCount: FormSW.NumberNotifyProcType =    BEGIN    IF lvRootPage.lockCount ~IN [0..16) THEN      BEGIN      UserTerminal.BlinkDisplay[];      lvRootPage.lockCount ¬ oldValue;      FormSW.DisplayItem[sw, index];      END;    END;  ValidateLockNull: FormSW.NumberNotifyProcType =    BEGIN    IF lvRootPage.lockNull ~IN        [0..(IF lvRootPage.lockState = read THEN 1024 ELSE 16384)) THEN      BEGIN      UserTerminal.BlinkDisplay[];      lvRootPage.lockNull ¬ oldValue;      FormSW.DisplayItem[sw, index];      END;    END;  ValidateLockOwnerID: FormSW.FilterProcType =    BEGIN    valid: BOOLEAN;    id: System.UniversalID;    FormSW.StringEditProc[sw, item, insert, string];    [valid, id] ¬ DiskEditInternal.ValidateUID[lvRootPage.lockOwnerIDString];    IF ~valid THEN UserTerminal.BlinkDisplay[] ELSE lv.vID ¬ LOOPHOLE[id];    END;  ValidateLVID: FormSW.FilterProcType =    BEGIN    valid: BOOLEAN;    id: System.UniversalID;    FormSW.StringEditProc[sw, item, insert, string];    [valid, id] ¬ DiskEditInternal.ValidateUID[lvRootPage.IDString];    IF ~valid THEN UserTerminal.BlinkDisplay[] ELSE lv.vID ¬ LOOPHOLE[id];    END;  ValidatePad1: FormSW.NumberNotifyProcType =    BEGIN    IF lvRootPage.pad1 ~IN [0..77777B] THEN      BEGIN      UserTerminal.BlinkDisplay[];      lvRootPage.pad1 ¬ oldValue;      FormSW.DisplayItem[sw, index];      END;    END;  ValidateRootFileID: FormSW.FilterProcType =    BEGIN    valid: BOOLEAN;    id: File.ID;    FormSW.StringEditProc[sw, item, insert, string];    [valid, id] ¬ DiskEditInternal.ValidateFID[      lvRootPage.currentRootFileIDString];    IF ~valid THEN UserTerminal.BlinkDisplay[]    ELSE lvRootPage.currentRootFileID ¬ LOOPHOLE[id];    END;      ValidateScavengerID: FormSW.FilterProcType =    BEGIN    valid: BOOLEAN;    id: System.UniversalID;    FormSW.StringEditProc[sw, item, insert, string];    [valid, id] ¬ DiskEditInternal.ValidateUID[lvRootPage.scavengerIDString];    IF ~valid THEN UserTerminal.BlinkDisplay[]    ELSE lv.scavengerLogVolume ¬ LOOPHOLE[id];    END;  ValidateCopyStatus: FormSW.NumberNotifyProcType =    BEGIN    IF lvRootPage.statusCopyETableFile ~IN [0..256) THEN      BEGIN      UserTerminal.BlinkDisplay[];      lvRootPage.statusCopyETableFile ¬ oldValue;      FormSW.DisplayItem[sw, index];      END;    END;  ValidatePrimaryStatus: FormSW.NumberNotifyProcType =    BEGIN    IF lvRootPage.statusPrimaryETableFile ~IN [0..256) THEN      BEGIN      UserTerminal.BlinkDisplay[];      lvRootPage.statusPrimaryETableFile ¬ oldValue;      FormSW.DisplayItem[sw, index];      END;    END;  -- Module initialization:  -- Register this subwindow as a view for the data subwindow  WindowSwap.RegisterView[    key: DiskEditInternal.dataWindowKey,    viewName: "LV root page"L,    makeFormSW: MakeLvRootPageSW,    viewFromDataProc: FillLvRootPageSW,    dataFromViewProc: CleanupLvRootPageSW,    destroyViewProc: DestroyLvRootPageSW];  END.LOG23-Sep-81 15:08:05   WDK       LONGified, converted to Tajo 8.  Wouldn't change lv label length.23-Sep-81 15:08:05   CAJ    LOOPHOLE'd initialization of Boot.DiskAddress in currentBootFileDiskFile.27-Apr-83 11:20:26   EKN      Update to Klamath (LogicalVolume => LogicalVolumeFormat) 1-Jul-83 11:06:26   FXY     Changed item[16].place from nextPlace to newLine since item[15] was a StringItem.30-Nov-83 11:08:43	EKN    Changed items: lv.labelLength, lv.volumeSize, lv.freePageCount, lv.lowerBound, lv.vamStart, lv.vfmStart, lv.checksum, lvRootPage.currentFillValue, lvRootPage.currentBootFileDiskFile.firstPage to display decimals instead of octals.  Also changed "softMicorcode" to "softMicrocode". 5-Sep-84 14:01:25   CAJ    Add registering window view via WindowSwap.30-Sep-86 11:26:54   CAJ    LV root page format changes for 13.0.  Change display of bootfile disk address from 2 words. 9-Jul-87  9:38:08   CAJ    Add fields numberOfFile, lock, numberOfBadPagesLastTime, pad, pad1; move things around.  Reduce volumeRootDirectory and rootFileIDs to ID size vs UID size.  Add DestroyLvRootPageSW. 7-Mar-88  9:32:16   CAJ    Form index cleanup, inHeaps's ¬ FALSE.
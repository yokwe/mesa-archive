-- Copyright (C) 1983, 1985  by Xerox Corporation. All rights reserved. -- PilotTests>MapTest.mesa   (last edited by RSV on 1-Nov-85 14:54:00)DIRECTORY  Ascii USING [CR],  Command,  Environment,  File USING [Create, Delete, File, Type],  Inline USING [LowHalf],  PageMap USING [IsMapped],  PilotCommand USING [defaultWindow],  Runtime,  Space,  System USING [IsUtilityPilot],  TTY,  Volume;MapTest: PROGRAM  IMPORTS Command, File, Inline, PageMap, PilotCommand, Space, System, TTY, Volume  SHARES PageMap  =  BEGIN  tty: TTY.Handle;  -- for tty I/O within MapTestCmd.  wordsPerPage: CARDINAL = Environment.wordsPerPage;  pilotVolume: Volume.ID ¬ Volume.nullID;  spaceVM: Space.Interval = Space.virtualMemory;  defaultCount:  Environment.PageCount = LAST[Environment.PageCount];  -- two test files of size countSpace:  fType: File.Type = [177777B];  f1: File.File;  f1Base: CARDINAL;  f1Bias: CARDINAL = 1000B;  f2: File.File;  f2Base: CARDINAL;  f2Bias: CARDINAL = 2000B;    countSpace: CARDINAL = 10;  space: Space.Interval;  -- space used for all tests.  pageSpace: Space.PageNumber;  -- starting page of space.  countSpaceMapped: CARDINAL;  swapUnits: Space.SwapUnitOption;  MapTestCmd: Command.Action --[h: TTY.Handle]--  =    BEGIN    irregSU: ARRAY [0..3) OF Space.SwapUnitSize ¬ [3, 4, 3];        tty ¬ h;  -- save in a global for all inner procedures.    Command.Confirm[tty];    IF System.IsUtilityPilot[] THEN {      WHILE (pilotVolume ¬ Volume.GetNext[pilotVolume]) # Volume.nullID DO        IF Volume.GetStatus[pilotVolume] # openReadWrite THEN LOOP        ELSE EXIT;      ENDLOOP;      IF pilotVolume = Volume.nullID THEN {        Command.WriteError[tty, "No accessible volumes"L];        RETURN;};}    ELSE       pilotVolume ¬ Volume.systemID;    TTY.PutChar[tty, Ascii.CR];    TTY.PutLine[tty, "Begin mapping tests:"];    space ¬ Space.Allocate[countSpace, Space.virtualMemory, Space.defaultBase];    pageSpace ¬ Space.PageFromLongPointer[space.pointer];    -- f1 and f2 must have same initial size, (for TestCopyOps at least).    f1 ¬ File.Create[volume: pilotVolume, initialSize: countSpace, type: fType];    FillFile[f1, f1Bias];    f2 ¬ File.Create[volume: pilotVolume, initialSize: countSpace, type: fType];    FillFile[f2, f2Bias];    TTY.PutLine[tty, "..test with irregular swap units.."];    -- irregular swap units    swapUnits ¬ [irregular[DESCRIPTOR[BASE[irregSU],3]]];    DoTests[];    TTY.PutLine[tty, "..test with uniform swap units.."];      -- uniform swap units    swapUnits ¬ [uniform[3]];    DoTests[];        TTY.PutLine[tty, "..test with unitary swap units.."];    -- unitary swap units    swapUnits ¬ [unitary[]];    DoTests[];    Space.Deallocate[space];    File.Delete[f1];    File.Delete[f2];    TTY.PutLine[tty, "Mapping tests completed."];    END;  DoTests: PROCEDURE[] =    BEGIN TestVariousSizeSwapUnits[]; TestMap[]; TestCopyOps[]; END;  TestVariousSizeSwapUnits: PROCEDURE[] =    BEGIN    c: CARDINAL ¬ 77777B;    s: Space.Interval;    size: Space.PageCount;    length: LONG INTEGER;    backing: File.File ¬ File.Create[      volume: pilotVolume, initialSize: 256, type: fType];    TTY.PutLine[tty, "Test increasing sized swap units."];    size ¬ 1;    length ¬ wordsPerPage;    FOR k: CARDINAL IN [0..8) DO  -- for spaces of increasing size..      TTY.PutLongDecimal[tty, size];      TTY.PutString[tty, ", "];      s ¬ Space.Map[Space.Window[backing, 0, size]];      FOR offset: LONG INTEGER IN [0..length) DO        (s.pointer + offset)­ ¬ c;  -- fill every word with data.        ENDLOOP;      s.pointer ¬ Space.Unmap[s.pointer];      size ¬ size*2;      length ¬ size*wordsPerPage;      ENDLOOP;    File.Delete[backing];    TTY.PutLine[tty, ""];    END;  TestMap: PROCEDURE[] =    BEGIN    TTY.PutLine[tty, "Test Space.MapAt ..."];    FOR f1Base IN [0..countSpace) DO      TTY.PutDecimal[tty, f1Base];      TTY.PutString[tty, ", "];      -- map to file at some starting base page.      [] ¬ Space.MapAt[        at:space, window:[f1, f1Base, defaultCount], swapUnits: swapUnits];       countSpaceMapped ¬ countSpace - f1Base;      FOR offset:  CARDINAL IN [0..countSpaceMapped) DO        CheckPageContents[pageSpace + offset, f1Bias + f1Base + offset]; ENDLOOP;      FOR offset: CARDINAL IN [countSpaceMapped..countSpace) DO        CheckPageVacant[pageSpace + offset]; ENDLOOP;      [] ¬ Space.UnmapAt[space.pointer];      ENDLOOP;    TTY.PutLine[tty, ""];    END;  TestCopyOps: PROCEDURE[] =    BEGIN    TTY.PutLine[tty, "Test Space.CopyIn, CopyOut ..."];    FOR f2Base IN [0..countSpace) DO      TTY.PutDecimal[tty, f2Base];      TTY.PutString[tty, ":   "];      FOR f1Base IN [f2Base..countSpace) DO        TTY.PutDecimal[tty, f1Base];        TTY.PutString[tty, ", "];                -- Test CopyIn:        FillFile[f2, f2Bias];        [] ¬ Space.MapAt[space, [f2, f2Base, defaultCount]];        [] ¬ Space.CopyIn[space.pointer, [f1, f1Base, defaultCount]];        ComputeModels[f1Base, f2Base];        FOR offset: CARDINAL IN [0..countSpace) DO          IF sModel[offset] = modelVacant THEN CheckPageVacant[pageSpace + offset]          ELSE CheckPageContents[pageSpace + offset, sModel[offset]];          ENDLOOP;        [] ¬ Space.UnmapAt[space.pointer];        [] ¬ Space.MapAt[space, [f2, 0, defaultCount]];        FOR offset: CARDINAL IN [0..countSpace) DO          CheckPageContents[pageSpace + offset, f2Model[offset]]; ENDLOOP;        [] ¬ Space.UnmapAt[space.pointer];        -- Test CopyOut:        FillFile[f2, f2Bias];        [] ¬ Space.MapAt[space, [f1, f2Base, defaultCount]];        [] ¬ Space.CopyOut[space.pointer, [f2, f1Base, defaultCount]];        ComputeModels[f2Base, f1Base];	-- must keep mapUnit >= window in Copy operation, thus funny business with bases.        [] ¬ Space.UnmapAt[space.pointer];        [] ¬ Space.MapAt[space, [f2, 0, defaultCount]];        FOR offset: CARDINAL IN [0..countSpace) DO          CheckPageContents[pageSpace + offset, f2Model[offset]]; ENDLOOP;        [] ¬ Space.UnmapAt[space.pointer];        ENDLOOP;      TTY.PutLine[tty, ""]      ENDLOOP;    END;  CheckPageVacant: PROCEDURE [page: Space.PageNumber] =    {IF PageMap.IsMapped[page] THEN Command.Break[tty, "expected vacant flags"]};  CheckPageContents: PROCEDURE [page: Space.PageNumber, value: CARDINAL] =    BEGIN    p: LONG POINTER = LOOPHOLE[page*wordsPerPage];    FOR k: CARDINAL IN [0..wordsPerPage) DO      IF (p + k)­ ~= value THEN Command.Break[tty, "expected different value"];      ENDLOOP;    END;  sModel: ARRAY [0..countSpace) OF CARDINAL;  -- model of contents of each page of space after copy.  f2Model: ARRAY [0..countSpace) OF CARDINAL;  -- model of contents of each page of file2 after copy.  modelVacant: CARDINAL = LAST[CARDINAL];  -- code for "page should be vacant".  ComputeModels: PROCEDURE [f1Base, f2Base: CARDINAL] =    -- Assumes the data in f1 (starting at f1Base) has been copied into f2    --    (starting at f2Base).    BEGIN    f1CountMapped: CARDINAL = countSpace - f1Base;    f2CountMapped: CARDINAL = countSpace - f2Base;    offset: CARDINAL;    FOR offset IN [0..f2CountMapped) DO      sModel[offset] ¬ f2Bias + f2Base + offset; ENDLOOP;    FOR offset IN [0..f1CountMapped) DO      sModel[offset] ¬ f1Bias + f1Base + offset; ENDLOOP;    FOR offset IN [f2CountMapped..countSpace) DO      sModel[offset] ¬ modelVacant; ENDLOOP;    FOR offset IN [0..countSpace) DO f2Model[offset] ¬ f2Bias + offset; ENDLOOP;    FOR offset IN [0..f2CountMapped) DO      f2Model[f2Base + offset] ¬ sModel[offset]; ENDLOOP;    END;  -- Initialization  FillFile: PROCEDURE [file: File.File, bias: CARDINAL] =    -- Initializes file with consecutive cardinals starting with bias.    BEGIN    p: LONG POINTER = space.pointer;    i: CARDINAL;    j: LONG CARDINAL;    [] ¬ Space.MapAt[space, [file, 0, defaultCount]];    FOR j IN [0..countSpace) DO      FOR i IN [0..wordsPerPage) DO         (p + j*wordsPerPage + i)­ ¬ bias + Inline.LowHalf[j];	  ENDLOOP;      ENDLOOP;    [] ¬ Space.UnmapAt[space.pointer]    END;  Command.InstallTopLevel[    PilotCommand.defaultWindow, ["test space mapping", MapTestCmd]];  END.LOGMarch 14, 1979  3:48 PM	PXM    	Created file.November 8, 1979  1:27 PM	RXG   	No longer uses Swatee for backing file - uses a temp file.August 18, 1980  4:38 PM	SXY   	IODefs and Command are replaced by TTY and TTYCommand respectively.September 8, 1980  7:40 PM	SXY   	TTYCommand is replaced by new Command.September 17, 1980  8:01 AM	WDK    	Add tests for CopyIn/Out.8-Sep-81 11:53:14	SXY   	Space.Remap related codes are commented out.18-Nov-81 15:10:18	CAJ 	PageMap.(check flags vacant) replaced by PageMap.IsMapped.11-Jan-83 16:28:45	EKN   	Updated to Klamath23-Feb-83 11:46:58	EKN   	Fix code where "warning: someVariable will be truncated to a single word" is caused by 10.0e Compiler..Changed countSpace, countSpaceMapped, f1Base, f2Base, offset to be Cardinals29-Apr-83 16:07:40	EKN     Fix NIL pointer BUG in TestVariousSizeSwapUnits17-Aug-83 14:29:20	JXP     Convert to 11.0b19-Apr-85 10:15:26	CJS     Fix TestCopyOps, mapUnit from MapAt was always smaller than window in Copy operations. Howd it ever work?  1-Nov-85 14:54:24      RSV     Fixed crashing on UtilityPilot with nullID by using first open volume for UtilityPilot version only. (related to AR 8361)
-- Copyright (C) 1984, 1985, 1986, 1988  by Xerox Corporation. All rights reserved. -- FloppyEditContextSW.mesa  last edited: 29-Feb-88 11:47:47  by: CAJ-- This module implements the subwindow dealing with Floppy context and related hardware or diskette environment parameters and commands.DIRECTORY  Device USING [Type],  DeviceTypes USING [sa800],  DeviceTypesExtras USING [anyFloppy, Floppy],  Floppy USING [Density],  FloppyChannel USING [    Attributes, Context, Density, DiskAddress, Drive, Error, Format, GetContext,    GetDeviceAttributes, GetHandle, Handle, HeadCount, Nop, nullHandle,    SectorCount, SetContext, Status],  FloppyEditInternal USING [data, GetDrive, heap, Msg],  FloppyFormat USING [    dataContext, DiskAddressToSector, nullSector, Sector, SectorToDiskAddress,    trackZeroContext],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType, CommandItem,    DisplayItem, Enumerated, EnumeratedItem, EnumeratedNotifyProcType, line0,    line1, line2, line3, line4, ProcType],  MsgSW USING [Clear],  ProcessOperations USING [],  RuntimeInternal USING [Bug],  System USING [GetGreenwichMeanTime, GreenwichMeanTime],  Window USING [Handle];FloppyEditContextSW: PROGRAM  IMPORTS    FloppyChannel, FloppyEditInternal, FloppyFormat, FormSW, MsgSW,    RuntimeInternal, System  EXPORTS FloppyEditInternal =  BEGIN  --//////////////////  -- Local TYPEs and variables  ContextData: TYPE = LONG POINTER TO ContextDataObject;  ContextDataObject: TYPE = MACHINE DEPENDENT RECORD [    -- The following are subwindow items (all on word boundaries)    writeProtect(0): BOOLEAN ¬ FALSE,    format(1): FloppyChannel.Format ¬ Troy,  -- ringer    density(2): FloppyChannel.Density ¬ double,    sectorSize(3): FloppyChannel.SectorCount ¬ 0,    diskChange(4): BOOLEAN ¬ TRUE,    sides(5): Sides ¬ two,    -- The following are not subwindow items    deviceType(6): Device.Type ¬ DeviceTypesExtras.anyFloppy,    numberOfCylinders(7): CARDINAL ¬ 0,    numberOfHeads(8): FloppyChannel.HeadCount ¬ 0,    sectorsPerTrack(9): FloppyChannel.SectorCount ¬ 0,    dataContextDensity(10): FloppyChannel.Density ¬ double,    contextInEffect(11): FloppyChannel.Context ¬ [FALSE, IBM, double, 0]];  FormItems: TYPE = {    writeProtect, format, diskChange, density, sides, sectorSize, newDisk,    setDataContext, setTrack0Context, setSpecifiedContext, getContext};  Sides: TYPE = {one, two};  contextData: ContextData ¬ NIL;  --//////////////////  -- Errors  BugType: TYPE = {contextMismatch, noHeap};  Bug: PROCEDURE [bug: BugType] = {RuntimeInternal.Bug[bug]};  --//////////////////  -- Procedures  ContextMatchesContextInEffect: PUBLIC PROCEDURE RETURNS [BOOLEAN] = {    RETURN[MakeFloppyChannelContext[] = contextData.contextInEffect]};  -- Convert cylinder/head/sector type address to disk-sequential sector number  DiskAddressToSectorNumber: PUBLIC PROCEDURE [    diskAddress: FloppyChannel.DiskAddress]    RETURNS [sector: FloppyFormat.Sector] =    BEGIN    sector ¬      IF FloppyEditInternal.data.handle = FloppyChannel.nullHandle        THEN FloppyFormat.nullSector        ELSE FloppyFormat.DiskAddressToSector[          diskAddress: diskAddress, cylinders: contextData.numberOfCylinders,          tracksPerCylinder: contextData.numberOfHeads,          sectorsPerTrack: contextData.sectorsPerTrack];    END;  -- DiskAddressToSectorNumber  EstablishNewDisk: PROCEDURE RETURNS [ok: BOOLEAN] =    -- This procedure is called at tool activation time and on NewDisk to    -- establish the context and attributes for the current diskette.    -- There may be no diskette present, or the drive may have changed since    -- the last valid diskette.  The return value indicates whether it was able    -- to get drive attributes and set context.    BEGIN    attrib: FloppyChannel.Attributes;    c: FloppyChannel.Context;    h: FloppyChannel.Handle;    oneMinute: System.GreenwichMeanTime = [60];    status: FloppyChannel.Status;    timeout: System.GreenwichMeanTime ¬      [System.GetGreenwichMeanTime[] + oneMinute];       -- retry period for diskChange/invalidHandle to resolve    WHILE System.GetGreenwichMeanTime[] < timeout DO      h ¬ GetHandle[        ! FloppyChannel.Error => IF type = invalidDrive THEN GOTO notOK];      status ¬ FloppyChannel.Nop[h        ! FloppyChannel.Error => IF type = invalidHandle THEN LOOP];      SELECT status FROM        notReady => GOTO notOK;	diskChange => LOOP;	ENDCASE => EXIT;      REPEAT      FINISHED => GOTO notOK;      ENDLOOP;    -- Got a handle    ok ¬ TRUE;    FloppyEditInternal.data.handle ¬ h;    -- Attributes are constant per drive, but the drive may have changed.    attrib ¬ FloppyChannel.GetDeviceAttributes[h];    contextData.diskChange ¬ attrib.diskChange;    contextData.sides ¬ IF attrib.twoSided THEN two ELSE one;    contextData.deviceType ¬ attrib.deviceType;    contextData.numberOfCylinders ¬ attrib.numberOfCylinders;    contextData.numberOfHeads ¬ attrib.numberOfHeads;    contextData.sectorsPerTrack ¬ attrib.maxSectorsPerTrack;    -- Set initial context to data context. We have to do some guessing to get    -- writeProtect and density right, e.g., corresponding to diskette. Context    -- cannot be set successfully with the wrong values. After initialization    -- we just believe the values in contextData, assuming they are the ones we    -- set or that the user reset them on purpose.    FOR i: Floppy.Density DECREASING IN [single..double] DO      c ¬ FloppyFormat.dataContext[i];      IF FloppyChannel.SetContext[FloppyEditInternal.data.handle, c]        THEN EXIT;      c.protect ¬ ~c.protect;      IF FloppyChannel.SetContext[FloppyEditInternal.data.handle, c]        THEN EXIT;      REPEAT      FINISHED => GOTO notOK;      ENDLOOP;    contextData.writeProtect ¬ c.protect;    contextData.format ¬ c.format;    contextData.density ¬ c.density;    contextData.sectorSize ¬ c.sectorLength;    contextData.dataContextDensity ¬ c.density;    contextData.contextInEffect ¬ c;    EXITS notOK => ok ¬ FALSE;    END;  -- EstablishNewDisk  GetContext: FormSW.ProcType =    BEGIN    c: FloppyChannel.Context;    MsgSW.Clear[FloppyEditInternal.data.msgSW];    IF contextData.format = Troy THEN GOTO noContext;    c ¬ FloppyChannel.GetContext[      FloppyEditInternal.data.handle !      FloppyChannel.Error =>        IF type = invalidHandle THEN GOTO invalidHandle ELSE REJECT];    ShowContext[c, sw];    IF ~ContextMatchesContextInEffect[] THEN Bug[contextMismatch];    EXITS      invalidHandle =>        BEGIN        FloppyEditInternal.Msg["Invalid handle"L, TRUE];        InvalidateHandle[];        END;      noContext => FloppyEditInternal.Msg["No context has been set."L, TRUE];    END;  -- GetContext  GetHandle: PROCEDURE RETURNS [FloppyChannel.Handle] = {    RETURN[FloppyChannel.GetHandle[FloppyEditInternal.GetDrive[]]]};  InitContext: PUBLIC PROCEDURE =    -- This procedure is called at tool activation time.    -- If it is unable to get drive attributes and set context, it sets    -- the tool state to indicate no valid disk is present.    -- If no context is set at initialization time (e.g., because there is no    -- diskette ready), the user must explicitly set the context later.    BEGIN    IF FloppyEditInternal.data = NIL THEN Bug[noHeap];    FloppyEditInternal.data.contextData ¬ contextData ¬      FloppyEditInternal.heap.NEW[ContextDataObject ¬ []];    -- Stash contextData pointer in tool data so it can be freed on deactivate.    IF ~EstablishNewDisk[          ! FloppyChannel.Error =>	    IF type = invalidHandle THEN GOTO noAccess ELSE REJECT]      THEN GOTO noAccess;    -- If the device type is outside the floppy range but the initialization    -- completed normally, it is probably a floppy tape.  It's not going to let    -- you have it as a default at startup time, but if you bug NewDisk it will    -- post a warning and allow access.  It can't post a warning message here    -- because the tool isn't up yet.    IF contextData.deviceType ~= DeviceTypes.sa800 AND      LOOPHOLE[contextData.deviceType, CARDINAL] ~IN DeviceTypesExtras.Floppy        THEN GOTO noAccess;    EXITS noAccess => InvalidateHandleNoDisplay[];    END;  -- InitContext  InvalidateHandle: PUBLIC PROCEDURE =    BEGIN    InvalidateHandleNoDisplay[];    FormSW.DisplayItem[      FloppyEditInternal.data.contextSW, FormItems.diskChange.ORD];    END;  -- InvalidateHandle  InvalidateHandleNoDisplay: PROCEDURE = INLINE    BEGIN    -- For use when subwindow isn't there    FloppyEditInternal.data.handle ¬ FloppyChannel.nullHandle;    contextData.diskChange ¬ TRUE;    END;  MakeContextSW: PUBLIC FormSW.ClientItemsProcType =    BEGIN OPEN FSW: FormSW;    nItems: CARDINAL = FormItems.LAST.ORD + 1;    format: ARRAY [0..2) OF FSW.Enumerated ¬ [      ["IBM"L, FloppyChannel.Format[IBM]], ["Troy"L, FloppyChannel.Format[Troy]]];    density: ARRAY [0..2) OF FSW.Enumerated ¬ [      ["single(FM)"L, FloppyChannel.Density[single]], [      "double(MFM)"L, FloppyChannel.Density[double]]];    sides: ARRAY [0..2) OF FSW.Enumerated ¬ [      ["single-sided"L, Sides[one]], ["double-sided"L, Sides[two]]];    sectorSize: ARRAY [0..4) OF FSW.Enumerated ¬ [      ["64"L, 64], ["128"L, 128], ["256"L, 256], ["512"L, 512]];    items ¬ FSW.AllocateItemDescriptor[nItems];    items[FormItems.writeProtect.ORD] _ FSW.BooleanItem[      tag: "WriteProtect"L, place: [3, FSW.line0], readOnly: FALSE,      switch: @contextData.writeProtect];    items[FormItems.format.ORD] _ FSW.EnumeratedItem[      tag: "Format"L, place: [116, FSW.line0], readOnly: FALSE, feedback: one,      proc: SetFormat, choices: DESCRIPTOR[format], value: @contextData.format];    items[FormItems.diskChange.ORD] _ FSW.BooleanItem[      tag: "DiskChange"L, place: [303, FSW.line0], readOnly: TRUE,      switch: @contextData.diskChange];    items[FormItems.density.ORD] _ FSW.EnumeratedItem[      tag: "Density"L, place: [3, FSW.line1], readOnly: FALSE, feedback: all,      choices: DESCRIPTOR[density], value: @contextData.density];    items[FormItems.sides.ORD] _ FSW.EnumeratedItem[      tag: "Sides"L, place: [303, FSW.line1], readOnly: TRUE, feedback: one,      choices: DESCRIPTOR[sides], value: @contextData.sides];    items[FormItems.sectorSize.ORD] _ FSW.EnumeratedItem[      tag: "Sector size (words)"L, place: [3, FSW.line2], readOnly: FALSE,      feedback: all, choices: DESCRIPTOR[sectorSize],      value: @contextData.sectorSize];    items[FormItems.newDisk.ORD] _ FSW.CommandItem[      tag: "NewDisk"L, place: [3, FSW.line3], proc: NewDiskCommand];    items[FormItems.setDataContext.ORD] _ FSW.CommandItem[      tag: "SetDataContext"L, place: [3, FSW.line4], proc: SetDataContext];    items[FormItems.setTrack0Context.ORD] _ FSW.CommandItem[      tag: "SetTrack0Context"L, place: [115, FSW.line4],      proc: SetTrack0Context];    items[FormItems.setSpecifiedContext.ORD] _ FSW.CommandItem[      tag: "SetSpecifiedContext"L, place: [246, FSW.line4],      proc: SetSpecifiedContext];    items[FormItems.getContext.ORD] _ FSW.CommandItem[      tag: "GetContext"L, place: [399, FSW.line4], proc: GetContext];    RETURN[items: items, freeDesc: TRUE];    END;  MakeFloppyChannelContext: PROCEDURE RETURNS [c: FloppyChannel.Context] = {    RETURN[      [protect: contextData.writeProtect, format: contextData.format,        density: contextData.density, sectorLength: contextData.sectorSize]]};  NewDiskCommand: FormSW.ProcType =    BEGIN    MsgSW.Clear[FloppyEditInternal.data.msgSW];    IF (contextData.diskChange ¬ ~EstablishNewDisk[].ok) THEN      BEGIN      FloppyEditInternal.Msg["Can't access device."L, TRUE];      InvalidateHandle[];      END;    IF contextData.deviceType ~= DeviceTypes.sa800 AND      LOOPHOLE[contextData.deviceType, CARDINAL] ~IN DeviceTypesExtras.Floppy        THEN FloppyEditInternal.Msg[          "Warning: device type not in floppy range."L, FALSE];    FormSW.DisplayItem[      FloppyEditInternal.data.contextSW, FormItems.diskChange.ORD];    END;  -- Convert disk-sequential sector number to cylinder/head/sector type address  SectorNumberToDiskAddress: PUBLIC PROCEDURE [sector: FloppyFormat.Sector]    RETURNS [diskAddress: FloppyChannel.DiskAddress] = {    diskAddress ¬ IF FloppyEditInternal.data.handle = FloppyChannel.nullHandle      THEN [cylinder: 0, head: 0, sector: 0]  -- not a real address      ELSE FloppyFormat.SectorToDiskAddress[        sector: sector, cylinders: contextData.numberOfCylinders,        tracksPerCylinder: contextData.numberOfHeads,        sectorsPerTrack: contextData.sectorsPerTrack]};  SectorWords: PUBLIC PROCEDURE RETURNS [FloppyChannel.SectorCount] = {    RETURN[contextData.sectorSize]};  SetContext: PROCEDURE [c: FloppyChannel.Context] RETURNS [ok: BOOLEAN] =    BEGIN    -- Do common guts of context change.    MsgSW.Clear[FloppyEditInternal.data.msgSW];    ok ¬ FloppyChannel.SetContext[      handle: FloppyEditInternal.data.handle, context: c      ! FloppyChannel.Error =>        IF type = invalidHandle THEN GOTO invalidHandle ELSE REJECT];    IF ok THEN      BEGIN      contextData.sectorsPerTrack ¬ FloppyChannel.GetDeviceAttributes[	FloppyEditInternal.data.handle].maxSectorsPerTrack;      contextData.contextInEffect ¬ c;      END    ELSE      BEGIN      status: FloppyChannel.Status ¬ FloppyChannel.Nop[        FloppyEditInternal.data.handle];      FloppyEditInternal.Msg[        string: SELECT status FROM          notReady => "Not ready."L,          writeFault => "Diskette is write protected."L          ENDCASE => "Can't set that context."L, blink: TRUE];      END;    EXITS      invalidHandle => {        FloppyEditInternal.Msg["Invalid handle"L, TRUE]; InvalidateHandle[]};    END;  SetDataContext: FormSW.ProcType =    BEGIN    -- Set the context defined for data (non-track-0) in FloppyFormat.    density: Floppy.Density =     IF contextData.dataContextDensity = double THEN double ELSE single;    IF SetContext[FloppyFormat.dataContext[density]] THEN      ShowContext[FloppyFormat.dataContext[density], sw];    END;  -- SetDataContext  SetSpecifiedContext: FormSW.ProcType =    BEGIN    -- Set the context shown by the individual context items in the subwindow.    c: FloppyChannel.Context ¬ MakeFloppyChannelContext[];    IF SetContext[c] THEN ShowContext[c, sw];    END;  -- SetSpecifiedContext  SetTrack0Context: FormSW.ProcType =    BEGIN    -- Set the context defined for track 0 in FloppyFormat.    IF SetContext[FloppyFormat.trackZeroContext] THEN      ShowContext[FloppyFormat.trackZeroContext, sw];    END;  -- SetTrack0Context  SetFormat: FormSW.EnumeratedNotifyProcType =    BEGIN    IF contextData.format = Troy THEN      BEGIN      FloppyEditInternal.Msg["Troy format is not supported."L, FALSE];      contextData.format ¬ IBM;      FormSW.DisplayItem[sw, FormItems.format.ORD];      END;    END;  -- SetFormat  ShowContext: PROCEDURE [c: FloppyChannel.Context, sw: Window.Handle] =    BEGIN    -- Transfer given context to indiv. display items and redisplay.    contextData.writeProtect ¬ c.protect;    contextData.format ¬ c.format;    contextData.density ¬ c.density;    contextData.sectorSize ¬ c.sectorLength;    FormSW.DisplayItem[sw, FormItems.format.ORD];    FormSW.DisplayItem[sw, FormItems.writeProtect.ORD];    FormSW.DisplayItem[sw, FormItems.density.ORD];    FormSW.DisplayItem[sw, FormItems.sectorSize.ORD];    END;  -- Ensure disk address is valid for disk which is currently active  ValidateDiskAddress: PUBLIC PROCEDURE [addr: FloppyChannel.DiskAddress]    RETURNS [BOOLEAN] = {    RETURN[      addr.cylinder IN [0..contextData.numberOfCylinders)        AND addr.head IN [0..contextData.numberOfHeads)        AND addr.sector IN [1..contextData.sectorsPerTrack]]};  -- Ensure sector specified is valid for currently active disk  ValidateSectorNumber: PUBLIC PROCEDURE [sector: FloppyFormat.Sector]    RETURNS [BOOLEAN] = {    RETURN[      (sector ~= FloppyFormat.nullSector)        AND          (sector IN            [0..contextData.numberOfCylinders * contextData.numberOfHeads *                  contextData.sectorsPerTrack])]};  END...LOG25-Sep-84 15:47:15   CAJ	Created file. 1-Feb-85 14:24:55   CAJ	Converted to 12.0 FloppyChannel, changed commands. 7-May-85 13:22:17   CAJ	Use default heap in MakeForm.24-Apr-86  9:16:25   CAJ	Set attributes properly if first disk appears after initialization; don't assume single drive.29-Feb-88  8:27:36   CAJ	Reinitialize context for each NewDisk in case drive changed.  Return null values to address conversions if handle is invalid since context is also invalid then.  Special case non-floppy device type.
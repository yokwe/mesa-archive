-- Copyright (C) 1983, 1985  by Xerox Corporation. All rights reserved. -- StorageExerciser.mesa   10-Feb-87 18:09:41 by CJS   -- Client-level program for testing Pilot virtual memory and file storage facilities.DIRECTORY  Ascii USING [CR, SP],  Command USING [    Action, Break, Confirm, Entry, InstallTopLevel, Loop, NullCatch, QuitLevel,    RunTopLevel, Scan, SetVariable, UnwindCmd, VariableDescriptor, WriteError],  Environment USING [PageCount, Word, wordsPerPage],  File USING [Create, Delete, File, nullFile, PageCount, PageNumber, Type],  Heap USING [Handle, systemZone],  Inline USING [HighHalf, LDIVMOD, LowByte, LowHalf],  PilotCommand USING [defaultWindow, GetGetNextTypeSetCur],  Process,  Runtime USING [CallDebugger, GetBcdTime, IsBound],  Space USING [    Deactivate, defaultSwapUnitOption, GetMapUnitAttributes,    Interval, Map, MDS, nullInterval, PageCount, PageFromLongPointer,    PageNumber, PageOffset, SwapUnitSize, SwapUnitOption, Unmap,     virtualMemory, Window],  System USING [IsUtilityPilot],  Time USING [AppendCurrent],  Tool USING [UnusedLogName],  TTY USING [    Create, PutDate, GetChar, Handle, OutOfInstances, PutChar, PutDecimal,    PutLine, PutNumber, PutOctal, PutString, SetBackingSize],  Volume USING [     ID, GetAttributes, GetNext, GetStatus, InsufficientSpace, NeedsScavenging,     nullID, onlyEnumerateCurrentType, TypeSet];StorageExerciser: MONITOR  IMPORTS    Command, File, Heap, Inline, PilotCommand, Process, Runtime, Space, System, Time,    Tool, TTY, Volume =  BEGIN  wordsPerPage: CARDINAL = Environment.wordsPerPage;  ttys: TTY.Handle;  -- own window  testPage: ARRAY [0..wordsPerPage) OF CARDINAL ¬ ALL[0];  TestFileType: TYPE = CARDINAL [20000..21000);  -- should be in FileTypes!  maxUnifSwapUnitSize: CARDINAL = 63;  -- current implementation restriction  RateOfSwapUnitUse: TYPE = [0..20];  rateOfSwapUnitUse: RateOfSwapUnitUse ¬ 10;  -- settable via Debugger  RateOfIrregSwapUnitUse: TYPE = [0..20];  rateOfIrregSwapUnitUse: RateOfIrregSwapUnitUse ¬ 10;  maxUnitarySpaceSize: CARDINAL ¬ 100;  swapUnitNumber: CARDINAL ¬ 100;    -- Parameters ideally settable via set command:  nSegments: CARDINAL ¬ 5;  maxSegmentSize: Space.PageCount ¬ 500;  maxMDSSegmentSize: Space.PageCount ¬ 25;  maxFileSize: CARDINAL ¬ 1000;  nSwapProcs: CARDINAL ¬ 5;  nMapProcs: CARDINAL ¬ 1;  nRecycleProcs: CARDINAL = 1;  -- won't work if more than one!  (see CreateSpaceForSegment)  nFileRecycleProcs: CARDINAL ¬ 1;  preemptionEnabled: BOOLEAN ¬ FALSE;  continuousDisplay: BOOLEAN ¬ TRUE;  delayUnit: CARDINAL ¬ 250;    -- base unit of exerciser process delays (in Msecs)  z: Heap.Handle ¬ Heap.systemZone;      FileRecycleProc: PROC =  -- root of file recycling process    BEGIN    WHILE Cycle[] DO      Delay[40*delayUnit];      IF DeleteFile[].successful THEN {        CreateFile[MRandom[nVolumes]]; NoteEvent[[fileRecycled[]]]};      AdjustPriority[];      ENDLOOP;    END;  MapProc: PROC =  -- root of mapping process    BEGIN    seg: SegmentPtr;    sn: SegmentNo;    WHILE Cycle[] DO      seg ¬ AllocateSegment[];      IF seg.window ~= defaultWindow THEN         BEGIN        [seg.si.pointer] ¬ Space.Unmap[seg.si.pointer];	seg.si ¬ Space.nullInterval;	seg.base ¬ Space.PageFromLongPointer[seg.si.pointer];	END;      ReleaseWindow[seg];      AllocateWindow[seg];      IF seg.window ~= defaultWindow THEN         BEGIN        [seg.si] ¬ Space.Map[window: seg.window, swapUnits: seg.swap];        seg.base ¬ Space.PageFromLongPointer[seg.si.pointer];      -- Check that new space doesn't overlap other segment's space      -- This doesn't work if there are more than one RecycleProc        FOR sn IN [0..nSegments) DO          OPEN otherSeg: ST[sn];          IF @otherSeg ~= seg AND otherSeg.si # Space.nullInterval THEN            BEGIN            greaterBase: Space.PageNumber = MAX[seg.base, otherSeg.base];            lesserLimit: Space.PageNumber = MIN[              seg.base + seg.size, otherSeg.base + otherSeg.size];            IF greaterBase < lesserLimit THEN              Command.Break[ttys, "overlapping spaces"];            END;          ENDLOOP;	END;      NoteEvent[[segMoved[seg]]];      ReleaseSegment[seg];      Delay[10*delayUnit];      AdjustPriority[];      ENDLOOP;    END;  SwapProc: PROC =  -- root of swapping process    BEGIN    seg: SegmentPtr;    WHILE Cycle[] DO      seg ¬ AllocateSegment[];      IF seg.window ~= defaultWindow THEN        BEGIN        FillSegment[seg];        DeactivateSegment[seg];        Delay[1*delayUnit];        CheckSegment[seg];        NoteEvent[[segSwapped[seg]]]        END;      ReleaseSegment[seg];      Delay[1*delayUnit];      AdjustPriority[];      ENDLOOP;    END;  RecycleProc: PROC =  -- root of segment recycling process    BEGIN    mapUnit: Space.Interval;    window: Space.Window;    seg: SegmentPtr;    WHILE Cycle[] DO      seg ¬ AllocateSegment[];      WITH s:seg.swap SELECT FROM        irregular => {	  sPtr: LONG POINTER TO ARRAY[0..0) OF Space.SwapUnitSize ¬ BASE[s.sizes];	  z.FREE[@sPtr] };        ENDCASE;      [mapUnit, window, , , ] ¬ Space.GetMapUnitAttributes[seg.si.pointer];      IF mapUnit # Space.nullInterval THEN	BEGIN	IF mapUnit.pointer # seg.si.pointer THEN Command.Break[ttys, "incorrect map unit pointer"];        [] ¬ Space.Unmap[seg.si.pointer];	seg.si ¬ Space.nullInterval;	END;      ReleaseWindow[seg];      CreateSpaceForSegment[seg];      NoteEvent[[segRecycled[seg]]];      ReleaseSegment[seg];      Delay[20*delayUnit];      AdjustPriority[];      ENDLOOP;    END;  --  -- Process monitor  stateProcesses: {stop, pause, run};  countProcesses, countPaused: CARDINAL;  stateChanged, stateNoticed: CONDITION;  SynchronizeWithPausers: INTERNAL PROC =    BEGIN    countPaused ¬ countPaused + 1;    BROADCAST stateNoticed;    WHILE stateProcesses = pause DO WAIT stateChanged ENDLOOP;    countPaused ¬ countPaused - 1;    END;  Cycle: ENTRY PROC RETURNS [continueRunning: BOOLEAN] =    BEGIN    SynchronizeWithPausers[];    IF stateProcesses = stop THEN      {countProcesses ¬ countProcesses - 1;      BROADCAST stateNoticed;      RETURN[continueRunning: FALSE]}    ELSE RETURN[continueRunning: TRUE];    END;  Fork: ENTRY PROC [process: PROC] =    {countProcesses ¬ countProcesses + 1; Process.Detach[FORK process[]]};  InitializeProcesses: PROC =    {stateProcesses ¬ stop; countProcesses ¬ countPaused ¬ 0};  Pause: ENTRY PROC =    BEGIN    stateProcesses ¬ pause;    BROADCAST stateChanged;    WHILE countPaused < countProcesses DO WAIT stateNoticed ENDLOOP;    END;  Run: ENTRY PROC = {stateProcesses ¬ run; BROADCAST stateChanged};  Stop: ENTRY PROC =    BEGIN    stateProcesses ¬ stop;    BROADCAST stateChanged;    WHILE countProcesses > 0 DO WAIT stateNoticed ENDLOOP;    END;  --  -- Event recording monitor  Event: TYPE = RECORD [    SELECT kind: * FROM    fileRecycled => NULL,    segMoved => [seg: SegmentPtr],    segSwapped => [seg: SegmentPtr],    segRecycled => [seg: SegmentPtr],    ENDCASE];  countFilesRecycled: CARDINAL;  countSegmentMoved, countSegmentRecycled, countSegmentSwapped: ARRAY SegmentNo OF    CARDINAL;  NoteEvent: ENTRY PROC [event: Event] =    BEGIN    segNo: SegmentNo;    WITH event SELECT FROM      fileRecycled => BEGIN countFilesRecycled ¬ countFilesRecycled + 1; END;      segMoved =>        BEGIN        segNo ¬ SegNoFromPtr[seg];        countSegmentMoved[segNo] ¬ countSegmentMoved[segNo] + 1;        END;      segSwapped =>        BEGIN        segNo ¬ SegNoFromPtr[seg];        countSegmentSwapped[segNo] ¬ countSegmentSwapped[segNo] + 1;        END;      segRecycled =>        BEGIN        segNo ¬ SegNoFromPtr[seg];        countSegmentRecycled[segNo] ¬ countSegmentRecycled[segNo] + 1;        END;      ENDCASE;    IF continuousDisplay THEN DisplayEvents[];    END;  DisplayEvents: PROC =    BEGIN    s: SegmentNo;    time: STRING ¬ [30];    TTY.PutString[ttys, "FR: "];    TTY.PutDecimal[ttys, countFilesRecycled];    TTY.PutChar[ttys, ' ];    TTY.PutString[ttys, "  SM: "];    FOR s IN [0..nSegments) DO      TTY.PutDecimal[ttys, countSegmentMoved[s]]; TTY.PutChar[ttys, ' ] ENDLOOP;    TTY.PutString[ttys, "  SS: "];    FOR s IN [0..nSegments) DO      TTY.PutDecimal[ttys, countSegmentSwapped[s]]; TTY.PutChar[ttys, ' ] ENDLOOP;    TTY.PutString[ttys, "  SR: "];    FOR s IN [0..nSegments) DO      TTY.PutDecimal[ttys, countSegmentRecycled[s]];      TTY.PutChar[ttys, ' ]      ENDLOOP;    Time.AppendCurrent[time, FALSE];    TTY.PutLine[ttys, time];    END;  InitializeEvents: PROC =    BEGIN    countFilesRecycled ¬ 0;    FOR segNo: SegmentNo IN [0..nSegments) DO      countSegmentMoved[segNo] ¬ countSegmentSwapped[segNo] ¬        countSegmentRecycled[segNo] ¬ 0      ENDLOOP;    END;  --  -- Segment monitor  SegmentPtr: TYPE = LONG POINTER TO Segment;  Segment: TYPE = RECORD [    label: CHARACTER,    state: SegmentState,    parent: Space.Interval,    size: Space.PageCount,    base: Space.PageNumber,    si: Space.Interval,    window: Space.Window,    swap: Space.SwapUnitOption];  -- =defaultWindow if none allocated (for ReleaseWindow)  defaultWindow: Space.Window = [File.nullFile, 0, LAST[Environment.PageCount]];  SegmentState: TYPE = {free, busy};  siMds: Space.Interval = Space.MDS[];  siVm: Space.Interval = Space.virtualMemory;  ST: ARRAY SegmentNo OF Segment ¬  -- Segment Table     ALL[       ['A, free, Space.nullInterval, 0, 0, Space.nullInterval, defaultWindow, Space.defaultSwapUnitOption]];  SegmentNo: TYPE = [0..maxSegments);  maxSegments: CARDINAL = 8;  available: CONDITION;  AllocateSegment: ENTRY PROC RETURNS [SegmentPtr] =    BEGIN    sn, snFirst: SegmentNo;    sn ¬ snFirst ¬ Inline.LowHalf[Random[LONG[nSegments]]];    DO      DO        OPEN ST[sn];        IF state = free THEN {state ¬ busy; RETURN[@ST[sn]]};        sn ¬ (sn + 1) MOD nSegments;        IF sn = snFirst THEN EXIT;        ENDLOOP;      WAIT available;      ENDLOOP;    END;  CheckSegment: ENTRY PROC [seg: SegmentPtr] =    BEGIN OPEN seg;    seed: CARDINAL;    ppRgWord: LONG POINTER TO ARRAY [0..wordsPerPage) OF Environment.Word;    wActual, wExpected: Environment.Word;    [] ¬ SegNoFromPtr[seg];  -- check validity    FOR pn: Space.PageNumber IN [base..base + size) DO      ppRgWord ¬ LOOPHOLE[pn*wordsPerPage];      seed ¬ ppRgWord[2];      SetSeed[seed];      FOR i: [0..wordsPerPage) IN [0..wordsPerPage) DO        wActual ¬ ppRgWord[i];        wExpected ¬          SELECT i FROM            0 => tradeMark,            1 => LOOPHOLE[PageTag[seg.label, Inline.LowByte[Inline.LowHalf[pn]]], Environment.Word],            2 => seed,            ENDCASE => RandomFromSeed[10000B];        IF wActual ~= wExpected THEN          BEGIN OPEN TTY;          Runtime.CallDebugger[            "Page damaged; proceed to display expected and actual values"L];          PutString[ttys, "page damaged at index "L];          PutOctal[ttys, i];          PutChar[ttys, Ascii.CR];          PutString[ttys, "Expected page:"L];          SetSeed[seed];	  GenerateData[seed, seg, pn];          PutChar[ttys, Ascii.CR];          PutString[ttys, "Actual page:"L];          DumpPage[ppRgWord];          IF pn # base THEN            BEGIN            PutString[ttys, "Previous page:"L];            DumpPage[ppRgWord - wordsPerPage];            END;          Command.Break[ttys, "Page damaged"];          EXIT;          END;        ENDLOOP;      ENDLOOP;    END;  GenerateData: INTERNAL PROCEDURE[    seed: CARDINAL, seg: SegmentPtr, pn: Space.PageNumber] =  BEGIN    j,k: CARDINAL;    FOR k IN [0..Environment.wordsPerPage) DO    IF k MOD 8 = 0 THEN      BEGIN        TTY.PutChar[ttys, Ascii.CR];        TTY.PutNumber[ttys, k, [8, FALSE, TRUE, 3]];        TTY.PutChar[ttys, '/];      END;     j ¬ SELECT k FROM          0 => tradeMark,          1 => LOOPHOLE[PageTag[seg.label, Inline.LowByte[Inline.LowHalf[pn]]], Environment.Word],          2 => seed,          ENDCASE => RandomFromSeed[10000B];     TTY.PutNumber[ttys, j, [8, FALSE, TRUE, 8]];     testPage[k] ¬ j;       ENDLOOP;  END;    tradeMark: CARDINAL = 112233B;  -- in word 0 of every storage exerciser page  PageTag: TYPE = RECORD [seg: CHARACTER, page: [0..    255]];  -- in word 1 of every storage exerciser page  CreateSpaceForSegment: ENTRY PROC [seg: SegmentPtr] =    BEGIN OPEN seg;    swapUnitBase: Space.PageOffset;    swapUnitSize: Space.PageCount;    [] ¬ SegNoFromPtr[seg];  -- check validity    IF si ~= Space.nullInterval THEN RETURN; -- Just use the existing space    IF Random[2] = 1 THEN       {parent ¬ siVm; size ¬ Random[maxSegmentSize] + 1}    ELSE       BEGIN       parent ¬ siMds;       size ¬ Random[MIN[maxSegmentSize, maxMDSSegmentSize]] + 1;       END;        SELECT TRUE FROM         (rateOfSwapUnitUse > 0          AND Random[LAST[RateOfSwapUnitUse]] < rateOfSwapUnitUse) =>            BEGIN  -- tile the space with uniform swap units            swapUnitSize ¬ MAX[            1, MIN[            maxUnifSwapUnitSize,            ((((1 + Random[20])*(1 + Random[20]))/20)*(1 + Random[size]))/20]];            -- cubically weighted toward small values.	    seg.swap ¬ [uniform[Inline.LowHalf[swapUnitSize]]];            END;      (rateOfIrregSwapUnitUse > 0        AND Random[LAST[RateOfIrregSwapUnitUse]] < rateOfIrregSwapUnitUse)	OR size > maxUnitarySpaceSize =>          BEGIN  -- cover whole space with random-sized subspaces	  SequenceToCoerceIntoDescriptor: TYPE = RECORD[	    seq: SEQUENCE COMPUTED CARDINAL OF Space.SwapUnitSize];	  seqPtr: LONG POINTER TO SequenceToCoerceIntoDescriptor;          i: CARDINAL ¬ 0;          swapUnitBase ¬ 0;	  seqPtr ¬ z.NEW[SequenceToCoerceIntoDescriptor[swapUnitNumber]];	  seg.swap ¬ [irregular[DESCRIPTOR[@seqPtr.seq, swapUnitNumber]]];	  WITH s:seg.swap SELECT FROM	    irregular => BEGIN              WHILE swapUnitBase < size DO              swapUnitSize ¬ 1 + Random[MIN[size - swapUnitBase, 100]];              swapUnitBase ¬ swapUnitBase + swapUnitSize;	      s.sizes[i] ¬ Inline.LowHalf[swapUnitSize];	      i ¬ i + 1;	      IF i = (swapUnitNumber - 1) AND (size - swapUnitBase > 0) THEN {	        s.sizes[i] ¬ Inline.LowHalf[size - swapUnitBase];		i ¬ i + 1; 		EXIT };               ENDLOOP;	      seg.swap ¬ [irregular[DESCRIPTOR[BASE[s.sizes],i]]];	      END;	    ENDCASE;          END;      ENDCASE =>        BEGIN  --make space unitary        seg.swap ¬ [unitary[]];        END;    END;  DeactivateSegment: PROC [seg: SegmentPtr] =    BEGIN    [] ¬ SegNoFromPtr[seg];  -- check validity    Space.Deactivate[seg.si]    END;  DumpPage: PROC [    pp: LONG POINTER TO ARRAY [0..wordsPerPage) OF Environment.Word] =    BEGIN OPEN TTY;    k: CARDINAL;    FOR k IN [0..wordsPerPage) DO      IF k MOD 8 = 0 THEN        BEGIN        PutChar[ttys, Ascii.CR];        PutNumber[ttys, k, [8, FALSE, TRUE, 3]];        PutChar[ttys, '/];        END;      PutNumber[ttys, pp[k], [8, FALSE, TRUE, 8]]      ENDLOOP;    PutChar[ttys, Ascii.CR];    END;  FillSegment: ENTRY PROC [seg: SegmentPtr] =    BEGIN OPEN seg;    seed: CARDINAL;    pn: Space.PageNumber;    ppRgWord: LONG POINTER TO ARRAY [0..wordsPerPage) OF Environment.Word;    i: [0..wordsPerPage);    [] ¬ SegNoFromPtr[seg];  -- check validity    FOR pn IN [base..base + size) DO      seed ¬ RandomSeed[];      SetSeed[seed];      ppRgWord ¬ LOOPHOLE[pn*wordsPerPage];      ppRgWord[0] ¬ tradeMark;      ppRgWord[1] ¬ LOOPHOLE[PageTag[seg.label, Inline.LowByte[Inline.LowHalf[pn]]], Environment.Word];      ppRgWord[2] ¬ seed;      FOR i IN [3..wordsPerPage) DO ppRgWord[i] ¬ RandomFromSeed[10000B]; ENDLOOP;      ENDLOOP;    END;  FinalizeSegments: PROC =    BEGIN    mapUnit: Space.Interval;    window: Space.Window;    FOR sn: SegmentNo IN [0..nSegments) DO        [mapUnit, window, , , ] ¬ Space.GetMapUnitAttributes[ST[sn].si.pointer];       IF mapUnit # Space.nullInterval THEN         BEGIN 	 IF mapUnit.pointer # ST[sn].si.pointer THEN Command.Break[ttys, "incorrect map unit pointer"];         [] ¬ Space.Unmap[ST[sn].si.pointer];	 ST[sn].si ¬ Space.nullInterval;	 END;       ST[sn].si ¬ Space.nullInterval;       ST[sn].base ¬ ST[sn].size ¬ 0;       ENDLOOP;    END;  InitializeSegments: PROC =    BEGIN    labels: LONG STRING = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";    -- tempSeg: SegmentPtr;    -- Reset all segments    FOR sn: SegmentNo IN [0..nSegments) DO      OPEN thisSeg: ST[sn];      --tempSeg ¬ @ST[sn];       thisSeg.label ¬ labels[sn];      thisSeg.state ¬ free;      thisSeg.window ¬ defaultWindow;      ENDLOOP;    -- Create a space for each segment    FOR sn: SegmentNo IN [0..nSegments) DO      CreateSpaceForSegment[@ST[sn]]  -- set size, base, sh      ENDLOOP    END;  ReleaseSegment: ENTRY PROC [seg: SegmentPtr] =    BEGIN OPEN seg;    [] ¬ SegNoFromPtr[seg];  -- check validity    IF state ~= busy THEN Command.Break[ttys, "Segment not busy"];    state ¬ free;    NOTIFY available;    END;  SegNoFromPtr: PROC [seg: SegmentPtr] RETURNS [sn: SegmentNo] =    BEGIN    r: CARDINAL;    temp: LONG CARDINAL;    -- kinda gross here.    IF LOOPHOLE[seg, LONG CARDINAL] < LOOPHOLE[@ST[0], LONG CARDINAL] THEN      Command.Break[ttys, "Invalid segment pointer"];    temp ¬ seg - @ST[0];    [sn, r] ¬ Inline.LDIVMOD[Inline.LowHalf[temp], Inline.HighHalf[temp], SIZE[Segment]];    IF r ~= 0 OR sn >= nSegments THEN      Command.Break[ttys, "Invalid segment pointer"];    RETURN[sn]    END;  --  -- Volume and file window monitor  maxVolumes: CARDINAL = 6;  filesPerVolume: CARDINAL = 4;  maxFiles: CARDINAL = maxVolumes*filesPerVolume;  VT: ARRAY [0..maxVolumes) OF RECORD [vID: Volume.ID, freeToUs: File.PageCount];  nVolumes: CARDINAL ¬ 0;  -- total number of Pilot volumes  FileNo: TYPE = [0..maxFiles);  FT: ARRAY FileNo OF FileDescription;  FileDescription: TYPE = RECORD [    state: {free, active, windingDown},    refCnt: CARDINAL,    fvID: File.File,    vol: CARDINAL,  -- [0..nVolumes)    fSize: File.PageCount];  CreateFile: ENTRY PROC [indexSuggestedVolume: CARDINAL] =    BEGIN    file: File.File;    fileNo: FileNo;    size: File.PageCount;    type: File.Type;    volume: Volume.ID;    BEGIN    ENABLE      Volume.InsufficientSpace =>        -- not enough space to create a 1 page file!  Try another volume.        BEGIN        indexSuggestedVolume ¬ (indexSuggestedVolume + 1) MOD nVolumes;        RETRY        END;    volume ¬ VT[indexSuggestedVolume].vID;    --get random size other than 0    size ¬ MAX[Random[      MIN[VT[indexSuggestedVolume].freeToUs, maxFileSize]], 1];    type ¬ File.Type[MAX[      FIRST[TestFileType] + Inline.LowHalf[Random[LAST[TestFileType]] - FIRST[TestFileType] + 1], FIRST[TestFileType]]];    file ¬ File.Create[      volume, size, type !      Volume.InsufficientSpace => IF size > 1 THEN BEGIN size ¬ size/2; RETRY END      --ELSE REJECT-- ];  -- will be handled at outer level;    END;    VT[indexSuggestedVolume].freeToUs ¬ VT[indexSuggestedVolume].freeToUs - size;    FOR fileNo IN FileNo DO      IF FT[fileNo].state = free THEN {        FT[fileNo] ¬ [active, 0, file, indexSuggestedVolume, size]; RETURN}      ENDLOOP;    Command.Break[ttys, "Too many files"]    END;  AllocateWindow: ENTRY PROC [seg: SegmentPtr] =    BEGIN    sn: SegmentNo;    f, fFirst: FileNo;    base, baseFirst, baseMax: File.PageNumber;    [] ¬ SegNoFromPtr[seg];  -- check validity    f ¬ fFirst ¬ Inline.LowHalf[Random[maxFiles]];    DO      OPEN FT[f];      IF state = active AND fSize > seg.size THEN        BEGIN        baseMax ¬ fSize - seg.size;  -- maximum possible base        base ¬ baseFirst ¬ Random[baseMax] + 1;        DO          -- Assert: baseMax>=1 AND base, baseFirst IN [1..baseMax]          FOR sn IN [0..nSegments) DO            OPEN otherSeg: ST[sn];            IF fvID = otherSeg.window.file THEN              BEGIN              greaterBase: File.PageNumber = MAX[base, otherSeg.window.base];              lesserLimit: File.PageNumber = MIN[                base + seg.size, otherSeg.window.base + otherSeg.size];              IF greaterBase < lesserLimit THEN EXIT;  -- conflict with other seg              END;            REPEAT              FINISHED =>  -- no conflict with any other seg                BEGIN                refCnt ¬ refCnt + 1;                seg.window ¬ Space.Window[fvID, base, seg.size];                RETURN;                END;            ENDLOOP;          base ¬ (base MOD baseMax) + 1;          IF base = baseFirst THEN EXIT;          ENDLOOP;        END;      f ¬ (f + 1) MOD maxFiles;      IF f = fFirst THEN RETURN;  -- couldn't find a file window anywhere      ENDLOOP;    END;  DeleteFile: ENTRY PROC RETURNS [successful: BOOLEAN] =    BEGIN    f, fFirst: FileNo;    f ¬ fFirst ¬ Inline.LowHalf[Random[maxFiles]];    DO      OPEN file: FT[f];      IF file.state = active THEN        BEGIN        file.state ¬ windingDown;        WHILE file.refCnt > 0 DO          IF stateProcesses = stop THEN GO TO GiveUp;          countPaused ¬ countPaused + 1;          BROADCAST stateNoticed;          WAIT stateChanged;          countPaused ¬ countPaused - 1;          ENDLOOP;        File.Delete[file.fvID];        VT[file.vol].freeToUs ¬ VT[file.vol].freeToUs + file.fSize;        file.state ¬ free;        RETURN[successful: TRUE]        END;      f ¬ (f + 1) MOD maxFiles;      IF f = fFirst THEN GO TO GiveUp;      REPEAT GiveUp => RETURN[successful: FALSE]      ENDLOOP;    END;  --DeleteFile--  FinalizeFiles: PROC =    BEGIN    FOR f: FileNo IN FileNo DO      IF FT[f].state ~= free THEN File.Delete[FT[f].fvID];      ENDLOOP;    END;  InitializeVolumeList: PROC =    BEGIN    volFreePages: File.PageCount;    v: Volume.ID ¬ Volume.nullID;    typeSet: Volume.TypeSet ¬       IF System.IsUtilityPilot[] THEN PilotCommand.GetGetNextTypeSetCur[]       ELSE Volume.onlyEnumerateCurrentType;    nVolumes ¬ 0;    WHILE (v ¬ Volume.GetNext[v]) ~= Volume.nullID DO      volFreePages ¬ Volume.GetAttributes[v !        Volume.NeedsScavenging => LOOP].freePageCount;      IF Volume.GetStatus[v] ~= openReadWrite THEN LOOP;      IF nVolumes >= maxVolumes THEN EXIT;  -- would overflow array.      VT[nVolumes].vID ¬ v;      VT[nVolumes].freeToUs ¬ IF volFreePages < 200 THEN 0        ELSE (volFreePages-200)*7/10;  -- (leave space for others)      nVolumes ¬ SUCC[nVolumes];      ENDLOOP;    END;  InitializeFiles: PROC =    BEGIN    FOR f: FileNo IN FileNo DO FT[f].state ¬ free; ENDLOOP;    -- Create filesPerVolume files on each volume:    FOR i: CARDINAL IN [0..nVolumes) DO      THROUGH [0..filesPerVolume) DO        CreateFile[i];        ENDLOOP;      ENDLOOP;    END;  ReleaseWindow: ENTRY PROC [seg: SegmentPtr] =    BEGIN OPEN window: seg.window;    [] ¬ SegNoFromPtr[seg];  -- check validity    IF window ~= defaultWindow THEN      BEGIN      FOR f: FileNo IN FileNo DO        OPEN FT[f];        IF state ~= free AND fvID = window.file THEN refCnt ¬ refCnt - 1        ENDLOOP;      window ¬ defaultWindow;      BROADCAST stateChanged;      END;    END;  --  -- Miscellaneous  AdjustPriority: PROC =    BEGIN    ClientPriority: ARRAY[0..3) OF Process.Priority =      [Process.priorityBackground, Process.priorityNormal,       Process.priorityForeground];           IF preemptionEnabled THEN Process.SetPriority[ClientPriority[MRandom[3]]];    END;  delayOrYield: {delay, yield} ¬ delay;  Delay: PROC [msecMax: CARDINAL] =    BEGIN    SELECT delayOrYield FROM      delay => MDelay[msecMax];      yield => Process.Yield[];      ENDCASE;    END;  MDelay: ENTRY PROC [msecMax: CARDINAL] =    BEGIN    delay: CONDITION;    IF stateProcesses = run THEN      BEGIN      Process.SetTimeout[        @delay, 1 + Inline.LowHalf[Random[Process.MsecToTicks[msecMax]]]];      WAIT delay;      END;    END;  --  -- Simple random number generator  MRandom: ENTRY PROC [limit: CARDINAL] RETURNS [CARDINAL] = {    RETURN[Inline.LowHalf[Random[limit]]]};  Random: INTERNAL PROC [limit: LONG CARDINAL] RETURNS [LONG CARDINAL] =    BEGIN    simpleSeed ¬ 24205B*simpleSeed + 33031B;    RETURN[IF limit = 0 THEN 0 ELSE simpleSeed MOD limit]    END;  simpleSeed: LONG CARDINAL ¬ 3021B;  --  -- Settable-seed random number generator  settableSeedSeed: CARDINAL ¬ 5031B;  settableSeed: CARDINAL ¬ 3021B;  RandomSeed: INTERNAL PROC RETURNS [CARDINAL] =    BEGIN    settableSeedSeed ¬ 26207B*settableSeedSeed + 35011B;    RETURN[settableSeedSeed]    END;  SetSeed: INTERNAL PROC [seed: CARDINAL] = {settableSeed ¬ seed};  RandomFromSeed: INTERNAL PROC [limit: CARDINAL] RETURNS [CARDINAL] =    BEGIN    settableSeed ¬ 24205B*settableSeed + 33031B;    RETURN[settableSeed MOD MAX[1, limit]]    END;  entries: ARRAY [0..7) OF Command.Entry ¬ [    ["commands", LoopCmd],  -- must be first    ["display", DisplayCmd],    ["pause", PauseCmd],    ["run", RunCmd],    ["set", SetCmd],    ["stop", StopCmd],    ["quit", Command.QuitLevel]];  -- must be last  DisplayCmd: Command.Action = {TTY.PutChar[h, Ascii.CR]; DisplayEvents[]};  ExerciseStorageCmd: Command.Action =    BEGIN    TTY.PutChar[h, Ascii.SP];    Command.Scan[      h, DESCRIPTOR[BASE[entries], LENGTH[entries] - 1], Command.NullCatch]    END;  LoopCmd: Command.Action =    BEGIN    Command.Loop[      h, DESCRIPTOR[@entries[1], LENGTH[entries] - 1], Command.NullCatch,      "exercise storage "];    END;  PauseCmd: Command.Action =    BEGIN    Command.Confirm[h];    SELECT stateProcesses FROM      stop => Command.WriteError[h, "No processes"L];      pause => Command.WriteError[h, "Already paused"L];      run => Pause[];      ENDCASE;    END;  PriorityCmd: Command.Action =    BEGIN    TTY.PutChar[h, Ascii.CR];    TTY.PutString[h, "Set preemption to "L];    TTY.PutString[h, IF preemptionEnabled THEN "FALSE"L ELSE "TRUE"L];    Command.Confirm[h];    preemptionEnabled ¬ IF preemptionEnabled THEN FALSE ELSE TRUE;    END;  RunCmd: Command.Action =    BEGIN    Command.Confirm[h];    IF stateProcesses = run THEN Command.WriteError[h, "Already running"L]    ELSE      BEGIN      IF stateProcesses = stop THEN        BEGIN        Pause[];	InitializeVolumeList[];	IF nVolumes = 0 THEN	   {Command.WriteError[h, "No accessible volumes"L]; RETURN};        InitializeEvents[];        InitializeSegments[];        InitializeFiles[];        THROUGH [1..nSwapProcs] DO Fork[SwapProc] ENDLOOP;        THROUGH [1..nMapProcs] DO Fork[MapProc] ENDLOOP;        THROUGH [1..nRecycleProcs] DO Fork[RecycleProc] ENDLOOP;        THROUGH [1..nFileRecycleProcs] DO Fork[FileRecycleProc] ENDLOOP;        END;      IF continuousDisplay THEN TTY.PutLine[h, "Type any character to pause."L];      Run[];      IF continuousDisplay THEN {[] ¬ TTY.GetChar[h]; Pause[]};      END;    END;  SetCmd: Command.Action =    BEGIN    variables: ARRAY [0..7) OF Command.VariableDescriptor ¬ [      ["continuous display"L, boolean[@continuousDisplay]],      ["number of segments"L, cardinal[@nSegments]],      ["maximum segment size"L, longCardinal[@maxSegmentSize]],        ["number of swap processes"L, cardinal[@nSwapProcs]],      ["number of map processes"L, cardinal[@nMapProcs]],      -- ["number of recycle processes"L, cardinal[@nRecycleProcs]],  ++ until CreateSpaceForSegment is fixed.      ["number of file recycle processes"L, cardinal[@nFileRecycleProcs]],      ["preemption"L, boolean[@preemptionEnabled]]];    Command.SetVariable[h, DESCRIPTOR[variables]];    END;  StopCmd: Command.Action =    BEGIN    Command.Confirm[h];    SELECT stateProcesses FROM      stop => Command.WriteError[h, "no processes"L];      pause, run => {Stop[]; FinalizeSegments[]; FinalizeFiles[]};      ENDCASE;    END;  RunOurTopLevel: PROC = {Command.RunTopLevel[ttys]};  BreakCmd: Command.Action = {    Command.Break[h, "Proceed to return to StorageExerciser"L]};  Init: PROC =    BEGIN    logName: STRING ¬ [40];    IF Runtime.IsBound[LOOPHOLE[Tool.UnusedLogName]] THEN      Tool.UnusedLogName[unused: logName, root: "StorageExerciser.log"L]    ELSE logName ¬ "StorageExerciser.log"L;    InitializeProcesses[];  -- run command will take care of the rest    ttys ¬ TTY.Create[logName      ! TTY.OutOfInstances => {ttys ¬ PilotCommand.defaultWindow; CONTINUE}];    TTY.SetBackingSize[h: ttys, size: 20000];    IF ttys = PilotCommand.defaultWindow THEN      Command.InstallTopLevel[ttys, ["exercise storage", ExerciseStorageCmd]]    ELSE      BEGIN      TTY.PutString[ttys, "Storage Exerciser of "L];      TTY.PutDate[ttys, Runtime.GetBcdTime[]];      TTY.PutChar[ttys, Ascii.CR];      Command.InstallTopLevel[ttys, ["break", BreakCmd]];      Command.InstallTopLevel[ttys, ["display", DisplayCmd]];      Command.InstallTopLevel[ttys, ["pause", PauseCmd]];      Command.InstallTopLevel[ttys, ["priority", PriorityCmd]];      Command.InstallTopLevel[ttys, ["run", RunCmd]];      Command.InstallTopLevel[ttys, ["set", SetCmd]];      Command.InstallTopLevel[ttys, ["stop", StopCmd]];      Command.InstallTopLevel[ttys, ["unwind", Command.UnwindCmd]];      Process.Detach[FORK RunOurTopLevel];      END;    END;  Init[];  END.LOG   (For earlier log entries, see Mesa 10.0 archive version.) 3-Mar-82 14:11:24   JXP      added the testPage array to store the random data page generated by CheckSegment17-Mar-82 10:10:29   FXH    	Added IsBound Check to Tool.UnusedLogName12-Jul-82 14:12:36   AWL      	Modified so it runs in UtilityPilot.20-Dec-82 10:47:08   EKN      Updated to Klamath:  Replaced File.Capability with File.File.  Updated usages of Space where appropiate.27-Dec-82  8:53:53   AWL      	Long/short problem (twiddle).22-Feb-83 17:34:26   EKN      Fixed a Space.Unmap[nilPointer] Bug in RecycleProc and FinalizeSegments24-Feb-83 18:15:32   EKN      Fixed CreateFile Procedure so it doesn't create files of size. Fixed bug in MapProc.25-Feb-83 14:57:42   LXD         Fixed RecycleProc and FinalizeSegments:  it was wrong to Deallocate Space since Unmap does it.25-Feb-83 15:33:26   LXD         Fixed MapProc so it doesn't check for overlapping spaces when they aren't mapped.28-Feb-83 10:16:07   EKN      Fixed CreateFile so it doesn't assign outOfRange fileTypes. 5-May-83 13:46:35   WDK        DeleteFile got stuck on windowReleased (no timeout). Now waits on stateChanged.17-Aug-83 14:53:53   JXP      Convert to 11.0b. 1-Nov-85 16:08:17   RSV   Fixed spelling of accessible. 6-Nov-85 10:42:55   RSV   Fixed hardwire of date to call Runtime.GetBcdTime. (AR 4713)10-Feb-87 18:09:55   CJS	SegmentPtr is LONG, LONGify a STRING. Make SegNoFromPtr: worse.
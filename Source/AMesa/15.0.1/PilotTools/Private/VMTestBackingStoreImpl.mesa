-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- VMTestBackingStoreImpl.mesa     25-Apr-83 16:19:01 by CAJ -- Virtual memory test program.-- VMTestBackingStore handles the test program's backing store and access to-- the contents of VM pages.DIRECTORY  BackingStore USING [Data, Operation, Result, Run, TransferProc],  Environment USING [PageCount, PageNumber, wordsPerPage],  Inline USING [BITAND],  Process USING [Detach, SecondsToTicks, SetTimeout],  Space USING [LongPointerFromPage, Map, PageCount, PageFromLongPointer,    ScratchMap, Unmap],  String USING [AppendLongDecimal],  TryDefs USING [Ck],  VM USING [BackingStoreRuns, Interval, MakeResident],  VMTestBackingStore,  VMTestDatabase USING [ArrayDescriptor, Attributes, ClearActivating,    ClearCopyingIn, ClearCopyingOut, ClearDeactivating, ClearForcingOut,    GetAlternateRun, GetMapUnit, GetPageAttributes, GetPageSeed, GetRunIndex,    Lock, MarkAlive, MarkClean, MarkDirty, SetSeed, UndefinedPageContents,    Unlock, VMToUserPage, ZeroPageContents],  VMTestSpace USING [GetSpace, ReturnSpace];VMTestBackingStoreImpl: MONITOR  IMPORTS Inline, Process, Space, String, TryDefs, VM, VMTestDatabase, VMTestSpace  EXPORTS VMTestBackingStore =  BEGIN  ------------  -- GLOBAL types, constants, variables:  Data: TYPE = MACHINE DEPENDENT RECORD [    source(0): VMTestBackingStore.BackingSource,      -- who supplied this backing store, e.g., map, copyIn, copyOut    firstPage(1): Environment.PageNumber,      -- page number of the first page in this run    length(3): Environment.PageCount,      -- how many pages in the run    check(5): LONG CARDINAL];      -- for detection of smash, some function of other record elements      -- (currently the sum of firstPage and length)  -- This checks the correct simulation of the "opaque type" BackingStore.Data.  dataSizeCorrect: PRIVATE BOOLEAN [TRUE..TRUE] =    (SIZE[Data] = SIZE[BackingStore.Data]);  ErrorCode: TYPE = {backingDataSmashed, invalidBackingSource, missingCopyFlags,    nonTestRequest, pageSmashed, readDeadPage, readDirtyPage, requestNotSwapUnit,    requestOverflowsRun, terminating, transferUnmappedPage, writeActivatingPage,    writeCleanPage, writeReadonlyPage};  ErrorEntry: TYPE = RECORD[    code: ErrorCode,    page: Environment.PageNumber];  PageHeader: TYPE = RECORD[    vmPage: Environment.PageNumber,    seed: CARDINAL];  PageContents: TYPE = RECORD[    header: PageHeader,    content: ARRAY [0..Environment.wordsPerPage - SIZE[PageHeader]) OF WORD];  backingStoreOn: BOOLEAN ¬ FALSE;  -- There is currently no way to change this except with debugger  testWarnings: BOOLEAN ¬ TRUE;  bufferPages: Space.PageCount = 1;  checkFailed: CONDITION;  entrySize: CARDINAL = SIZE[ErrorEntry];  firstEntry, lastEntry, putHere, takeHere: LONG POINTER TO ErrorEntry ¬ NIL;  maxEntries: CARDINAL = CARDINAL[Environment.wordsPerPage*bufferPages]/entrySize;  okToContinue: CONDITION;  stringFromErrorCode: ARRAY ErrorCode OF LONG STRING;  tryAgain: CONDITION;  waiting: CARDINAL ¬ 0;  ------------  -- PUBLIC procedures  -- BSTransfer is called by Pilot VM machinery for any transfer between  -- VMTest's virtual memory and its backing store.  Actually, however, there  -- is no backing storage for test VM.  The function of this procedure is to  -- fool Pilot into thinking that transfers occur and to model such transfers  -- on the test program database.  Page contents are generated from the page's  -- seed when appropriate.  -- VMTestBackingStore.--  BSTransfer: PUBLIC BackingStore.TransferProc =    -- PROCEDURE [transData: LONG POINTER TO READONLY BackingStore.TransferData]    -- RETURNS [result: BackingStore.Result]    BEGIN OPEN t: transData;    -- consider exported counters on various things for metering    -- consider allowing operations to take varying amounts of time    attr: VMTestDatabase.Attributes;    backingSource: VMTestBackingStore.BackingSource;    completedCount: Environment.PageCount ¬ 0;    currentPage: Environment.PageNumber ¬ 0;    databaseRun: BackingStore.Run;    firstPage: Environment.PageNumber ¬ t.pageData + t.offsetFromData;    pageBuffer: Environment.PageNumber ¬ t.pageBuffer;    -- Here we must simulate I/O to runs of pages, assuming transfer occurs    -- on the entire run from lowest to highest address, stopping if an error    -- occurs.  No action may occur on pages after the one in error.    VMTestDatabase.Lock[[firstPage, t.countBuffer]];    SELECT backingSource ¬ GetBackingSource [t.data] FROM      copyIn, copyOut =>        databaseRun ¬ (VMTestDatabase.GetAlternateRun[firstPage])­;      map => databaseRun ¬ VMTestDatabase.GetMapUnit[t.pageData].backingStoreRuns[        VMTestDatabase.GetRunIndex[firstPage]];      ENDCASE => Check[[invalidBackingSource, firstPage], FALSE];        -- Check things which apply to whole request    Check[[requestOverflowsRun, firstPage],      t.countBuffer + t.offsetFromData <= databaseRun.count];    CheckWarning[[nonTestRequest, firstPage],      CheckOwner[[firstPage, t.countBuffer]]];    Check[[backingDataSmashed, firstPage],      VerifyBackingData[t.pageData, t.data, databaseRun]];    IF backingSource = map THEN      {IF t.operation = write THEN         CheckWarning[[writeCleanPage, firstPage],           CheckFirstAndLastPageDirty[[firstPage, t.countBuffer]]]}    ELSE -- copyIn, copyOut --      Check[[missingCopyFlags, firstPage],        CheckCopyFlags[[firstPage, t.countBuffer], backingSource]];     -- Do page by page simulation, checking each page as we go.  New state    -- is not set until all pages have been processed.    -- page here is the normal VM location, not system-relocated    FOR currentPage IN [firstPage..firstPage + t.countBuffer) DO      attr ¬ VMTestDatabase.GetPageAttributes[currentPage];      Check[[transferUnmappedPage, currentPage], attr.mapped];      IF t.operation = write THEN        BEGIN	Check[[writeActivatingPage, currentPage], ~attr.activating];        SELECT backingSource FROM	  copyOut => NULL;	  map =>	    BEGIN	    Check[[writeCleanPage, currentPage], ~attr.clean];	    Check[[writeReadonlyPage, currentPage], ~attr.readonly];	    END;	  ENDCASE => Check[[invalidBackingSource, firstPage], FALSE];        END      ELSE -- read        BEGIN        SELECT backingSource FROM	  copyIn => VMTestDatabase.SetSeed[[currentPage, 1]];	  map =>	    {Check[[readDirtyPage, currentPage], attr.clean];             Check[[readDeadPage, currentPage], attr.alive]};	  ENDCASE => Check[[invalidBackingSource, firstPage], FALSE];	GeneratePageContents[pageBuffer, currentPage];        END;      Check[[pageSmashed, currentPage],        VerifyPageContents[pageBuffer, currentPage]];      IF TimeForIOError[] THEN        {result ¬ [error[currentPage]];	 completedCount ¬ currentPage - firstPage + 1; EXIT};      pageBuffer ¬ pageBuffer + 1;      REPEAT      FINISHED => {result ¬ [done[]]; completedCount ¬ t.countBuffer};      ENDLOOP;    -- Here all pages to be transferred have been checked.    -- Update database for whole (actually completed) interval all at once.    IF t.operation = write THEN      BEGIN      IF backingSource = map THEN        {VMTestDatabase.MarkClean[[firstPage, completedCount]];        VMTestDatabase.MarkAlive[[firstPage, completedCount]];         VMTestDatabase.ClearDeactivating[[firstPage, completedCount]];         VMTestDatabase.ClearForcingOut[[firstPage, completedCount]]}      ELSE -- copyOut --        VMTestDatabase.ClearCopyingOut[[firstPage, completedCount]];      END    ELSE -- read      BEGIN      IF backingSource = map        THEN	  {VMTestDatabase.ClearActivating[[firstPage, completedCount]];	   VMTestDatabase.MarkClean[[firstPage, completedCount]]}	ELSE -- copyIn --	  {VMTestDatabase.ClearCopyingIn[[firstPage, completedCount]];	   VMTestDatabase.MarkDirty[[firstPage, completedCount]]};      END;    VMTestDatabase.Unlock[[firstPage, t.countBuffer]];    END;  -- Fill in the contents of the BackingStore.Run.data(s) for the given map unit.  InitializeBackingData: PUBLIC PROCEDURE [    backingData: VM.BackingStoreRuns, page: Environment.PageNumber,    source: VMTestBackingStore.BackingSource] =    -- See the type definition of Data for a description of what we are putting    -- in the data record.    -- Also note that backingData[i].count is set in MakeBackingData when the    -- backing data structure is created.    BEGIN    startOfRun: Environment.PageNumber ¬ page;    FOR i: CARDINAL IN [0..LENGTH[backingData]) DO      backingData[i].data ¬ BSDataFromVMData[[        source: source,	firstPage: startOfRun,	length: backingData[i].count,	check: startOfRun ¬ startOfRun + backingData[i].count]];      ENDLOOP;    END;        -- Construct the data structure used by (and known only to) the backing store  MakeBackingData: PUBLIC PROCEDURE [runSizes: VMTestDatabase.ArrayDescriptor]    RETURNS [backingData: VM.BackingStoreRuns] =    BEGIN    IF runSizes = NIL THEN RETURN[NIL];    backingData ¬ DESCRIPTOR[      VMTestSpace.GetSpace[LENGTH[runSizes] * SIZE[BackingStore.Run], resident],      LENGTH[runSizes]];    FOR i: CARDINAL IN [0..LENGTH[runSizes]) DO      backingData[i] ¬ [runSizes[i], [ALL[0]]]; ENDLOOP;    END;  -- Return the space used by the backing store's run data  ReturnBackingData: PUBLIC PROCEDURE [backingData: VM.BackingStoreRuns] =    {IF backingData ~= NIL THEN VMTestSpace.ReturnSpace[BASE[backingData]]};  -- Cleans up the backing store at the end of a test session.  Shutdown: PUBLIC ENTRY PROCEDURE =    BEGIN    backingStoreOn ¬ FALSE;    NOTIFY checkFailed;    -- more?    END;  -- Touch simulates reading or writing on each page in interval.  -- The integrety of the random seed generated contents is preserved.   Touch: PUBLIC PROCEDURE [    interval: VM.Interval, operation: BackingStore.Operation] =    BEGIN    page: Environment.PageNumber;    FOR page IN [interval.page..interval.page + interval.count) DO      dummy: WORD;      p: LONG POINTER TO PageContents ¬ Space.LongPointerFromPage[page];      IF operation = read THEN dummy ¬ p.content[0]      ELSE  -- write        -- change page seed, force dirty	BEGIN	ReplacePageContents[page];	dummy ¬ p.content[0]; p.content[0] ¬ dummy;	VMTestDatabase.MarkDirty[[page, 1]];	END;      Check[[pageSmashed, page], VerifyPageContents[page, page]];      ENDLOOP;    END;  ------------  -- PRIVATE Error Handling  AwaitError: ENTRY PROCEDURE RETURNS [problem: ErrorEntry] =    BEGIN    WHILE BufferEmpty[] DO      WAIT checkFailed;      IF ~backingStoreOn THEN EXIT;      ENDLOOP;    problem ¬      IF ~backingStoreOn AND BufferEmpty[] THEN [terminating, 0] ELSE GetEntry[];    END;  BackingStoreErrorHandler: PROCEDURE =    BEGIN    error: ErrorEntry;    errorBuffer: LONG POINTER;    pageString: STRING = [20];    -- The error buffer and all its handling is not necessary if we use the    -- okToContinue mechanism to keep state around until error is reported.    -- Note that this scheme doesn't preserve global state in the event of    -- simultaneous calls on BSTransfer.  Needs reconsideration.    errorBuffer ¬ Space.ScratchMap[bufferPages];    VM.MakeResident[[Space.PageFromLongPointer[errorBuffer], bufferPages], wait];    firstEntry ¬ putHere ¬ takeHere ¬ errorBuffer;    lastEntry ¬ firstEntry + entrySize * (maxEntries - 1);    waiting ¬ 0;    DO  -- for life of test run      error ¬ AwaitError[];      IF error.code = terminating THEN EXIT;      String.AppendLongDecimal[        pageString, VMTestDatabase.VMToUserPage[error.page]];      TryDefs.Ck[stringFromErrorCode[error.code], pageString, FALSE];      DoneWithError[];      ENDLOOP;    errorBuffer ¬ Space.Unmap[errorBuffer];    END;  BufferEmpty: PROCEDURE RETURNS [BOOLEAN] = INLINE    {RETURN[waiting = 0]};  BufferFull: PROCEDURE RETURNS [BOOLEAN] = INLINE    -- This hokey counter is simpler than keeping track of wraparound.    {RETURN[waiting = maxEntries]};  -- This somewhat odd handling of errors is to avoid page faults in the backing  -- store proc, to avoid monitorizing it, and to use the same error reporting  -- mechanism as outside the backing store proc.  Check: ENTRY PROCEDURE [problem: ErrorEntry, testOK:  BOOLEAN] =    BEGIN    IF ~testOK THEN      BEGIN      WHILE BufferFull[] DO WAIT tryAgain ENDLOOP;      PutEntry[problem];      NOTIFY checkFailed;      -- This wait is to keep backing store process state around until the      -- error reaches the debugger in the error handling process.      WAIT okToContinue;      END;    END;  CheckWarning: PROCEDURE [problem: ErrorEntry, testOK:  BOOLEAN] =    -- This does the test only if the testWarnings flag is on.    {IF testWarnings THEN Check[problem, testOK]};  DoneWithError: ENTRY PROCEDURE =    {NOTIFY okToContinue};  GetEntry: INTERNAL PROCEDURE RETURNS [entry: ErrorEntry] = INLINE    BEGIN    entry ¬ takeHere­;    waiting ¬ waiting - 1;    takeHere ¬      IF takeHere = lastEntry THEN firstEntry ELSE takeHere + entrySize;    END;  PutEntry: INTERNAL PROCEDURE [entry: ErrorEntry] = INLINE    BEGIN    putHere­ ¬ entry;    waiting ¬ waiting + 1;    putHere ¬      IF putHere = lastEntry THEN firstEntry ELSE putHere + entrySize;    END;  TimeForIOError: PROCEDURE RETURNS [BOOLEAN] =    -- Does this need to return a type of IO error?    BEGIN    -- fake I/O errors on some random probability    --  (set prob. = 100% to do an error handling test)    -- Use script-settable probability    -- Consider allowing page-by-page probability in order to, e.g., force    -- errors on any assess to a certain page.    -- IO errors are not currently simulated    RETURN[FALSE];    END;  ------------  -- PRIVATE Backing Data Contents    BSDataFromVMData: PROCEDURE [vmData: Data] RETURNS [BackingStore.Data] =    INLINE {RETURN[LOOPHOLE[vmData]]};  GetBackingSource: PROCEDURE [data: BackingStore.Data]    RETURNS [source: VMTestBackingStore.BackingSource] = INLINE    {RETURN[VMDataFromBSData[data].source]};  -- Verify that the backing store data from the I/O request matches the  -- one in the database and that its contents are correct.  VerifyBackingData: PROCEDURE [page: Environment.PageNumber,    requestData: BackingStore.Data, databaseRun: BackingStore.Run]    RETURNS [BOOLEAN] =    BEGIN    reqData: Data ¬ VMDataFromBSData[requestData];    RETURN[      (reqData = VMDataFromBSData[databaseRun.data]) AND      (reqData.firstPage = page) AND      (reqData.length <= databaseRun.count) AND      (reqData.check = reqData.firstPage + reqData.length)];    END;  VMDataFromBSData: PROCEDURE [data: BackingStore.Data] RETURNS [Data] =    INLINE {RETURN[LOOPHOLE[data]]};  ------------  -- PRIVATE Page Contents    -- Using the random number seed for the given VM page, generate a page of  -- random data.  The parameter pageBuffer is the actual, possibly relocated,  -- location of the data; pageData is the official location.  GeneratePageContents: PROCEDURE [pageBuffer, pageData: Environment.PageNumber] =    -- This procedure must be called from one which has already locked the page    -- (attributes.transferring).    BEGIN    p: LONG POINTER TO PageContents ¬ Space.LongPointerFromPage[pageBuffer];    rand: CARDINAL ¬ VMTestDatabase.GetPageSeed[pageData];    p.header ¬ [vmPage: pageData, seed: rand];    FOR i: CARDINAL IN [0..Environment.wordsPerPage - SIZE[PageHeader]) DO      p.content[i] ¬ (rand ¬ Random[rand]) ENDLOOP;    END;  -- Cretinous random number generator, adapted form PilotTests.StorageExerciser.  -- This generates the next random number in the series for which seed is  -- the predecessor.  It provides the illusion of private generators since  -- each user maintains its own seed.  Random: PUBLIC PROCEDURE [seed: CARDINAL] RETURNS [CARDINAL] =    {RETURN[24205B*seed + 33031B]};  -- Change the data in a VM page to simulate writing: change the random seed  -- and rewrite the data in memory.  ReplacePageContents: PROCEDURE [page: Environment.PageNumber] =    -- This procedure must be called from one which has already locked the page    -- (attributes.transferring).    BEGIN    VMTestDatabase.SetSeed[[page, 1]];    GeneratePageContents[page, page];    END;  -- Verify that the data contents of the given VM page match a page of data  -- generated by the page's random number seed.  The parameter pageBuffer is  -- the actual, possibly relocated, location of the data; pageData is the  -- official location.  VerifyPageContents: PROCEDURE [pageBuffer, pageData: Environment.PageNumber]    RETURNS [BOOLEAN] =    -- This procedure must be called from one which has already locked the page    -- (attributes.transferring).    -- Note that a page with undefined page contents always verifies.    BEGIN    IF ~VMTestDatabase.UndefinedPageContents[pageData] THEN      BEGIN      p: LONG POINTER TO PageContents ¬ Space.LongPointerFromPage[pageBuffer];      rand: CARDINAL ¬ VMTestDatabase.GetPageSeed[pageData];      zeroOption: BOOLEAN = VMTestDatabase.ZeroPageContents[pageData];      IF p.header ~= [vmPage: pageData, seed: rand] THEN GOTO verifyFailed;      FOR i: CARDINAL IN [0..Environment.wordsPerPage - SIZE[PageHeader]) DO        IF p.content[i] ~= (IF zeroOption THEN 0 ELSE (rand ¬ Random[rand]))	  THEN GOTO verifyFailed;        ENDLOOP;      END;    RETURN[TRUE];    EXITS verifyFailed => RETURN[FALSE];    END;  ------------  -- PRIVATE Misc.    CheckCopyFlags: PROCEDURE [    interval: VM.Interval, source: VMTestBackingStore.BackingSource]    RETURNS [BOOLEAN] =    BEGIN    copyInMask: VMTestDatabase.Attributes =      [inUse: FALSE, transferring: FALSE, mapped: FALSE,      clean: FALSE, alive: FALSE, readonly: FALSE, swappable: FALSE,      startOfSwapUnit: FALSE, endOfSwapUnit: FALSE, activating: FALSE,      copyingIn: TRUE, copyingOut: FALSE, deactivating: FALSE, forcingOut: FALSE];    copyOutMask: VMTestDatabase.Attributes =      [inUse: FALSE, transferring: FALSE, mapped: FALSE,      clean: FALSE, alive: FALSE, readonly: FALSE, swappable: FALSE,      startOfSwapUnit: FALSE, endOfSwapUnit: FALSE, activating: FALSE,      copyingIn: FALSE, copyingOut: TRUE, deactivating: FALSE, forcingOut: FALSE];     mask: VMTestDatabase.Attributes =      IF source = copyIn THEN copyInMask ELSE copyOutMask;    page: Environment.PageNumber;    FOR page IN [interval.page..interval.page + interval.count) DO      -- Gross      IF ~Inline.BITAND[VMTestDatabase.GetPageAttributes[page].attributes, mask]        THEN RETURN[FALSE] ENDLOOP;    RETURN[TRUE];    END;  CheckFirstAndLastPageDirty: PROCEDURE [interval: VM.Interval]     RETURNS [BOOLEAN] =     BEGIN     -- The first and last pages of a write request interval must be dirty.     -- There may be clean pages embedded within the interval if Pilot finds     -- it convenient to include them.          -- Consider optional check for clean pages in here, especially for     -- clean + readOnly.          RETURN[       ~VMTestDatabase.GetPageAttributes[interval.page].clean AND       ~VMTestDatabase.GetPageAttributes[interval.page+interval.count-1].clean];     END;  -- Ensure at least one page of request interval is owned by a test operation.  CheckOwner: PROCEDURE [interval: VM.Interval] RETURNS [BOOLEAN] =    BEGIN    page: Environment.PageNumber;    FOR page IN [interval.page..interval.page + interval.count) DO      IF VMTestDatabase.GetPageAttributes[page].inUse THEN RETURN[TRUE];      ENDLOOP;    RETURN[FALSE];    END;  CheckSwapUnitBoundaries: PROCEDURE [interval: VM.Interval] RETURNS [BOOLEAN] =    BEGIN OPEN interval;    -- The first page of the interval must begin a swap unit and the last    -- page must end one.  There may be more than one swap unit in the interval.    RETURN[      VMTestDatabase.GetPageAttributes[page].startOfSwapUnit AND      VMTestDatabase.GetPageAttributes[page + count - 1].endOfSwapUnit];    END;  ------------  -- Initialization    -- The following strings are substituted into the following template:  --   "Check of (string) {of (another string)} failed".  -- Thus the mismatch between error code, which identifies the error, and  -- string contents, which identify the test.  stringFromErrorCode ¬ [    backingDataSmashed: "backingData integrity",    invalidBackingSource: "backingSource key",    missingCopyFlags: "copy attribute on all request pages",    nonTestRequest: "request origin",    pageSmashed: "page contents integrity",    readDeadPage: "attempt to read dead page",    readDirtyPage: "attempt to read dirty page",    requestNotSwapUnit: "request swap unit boundaries",    requestOverflowsRun: "request contained in run",    terminating: NIL,  -- never printed    transferUnmappedPage: "attempt to transfer unmapped page",    writeActivatingPage: "attempt to write page being activated",    writeCleanPage: "attempt to write clean page",    writeReadonlyPage: "attempt to write readonly page"];  backingStoreOn ¬ TRUE;  Process.SetTimeout[@checkFailed, Process.SecondsToTicks[60]];  -- arbitrary  Process.Detach[FORK BackingStoreErrorHandler];  END.LOG23-Aug-82 16:29:52   CAJ    Created file.    
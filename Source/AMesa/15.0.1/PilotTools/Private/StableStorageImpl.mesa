-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- StableStorageImpl.mesa	       3-Mar-83 10:48:42 by LXD      -- A stable-storage relative-pointer zone-based allocator.  Items are allocated in a zone backed by a named backing file.  Upon system restarts, the backing file is used to recover the previous contents of the zone, and the client may continue where he left off.DIRECTORY  Environment USING [wordsPerPage],  Inline USING [LowHalf], -- MFile USING [Acquire, Delete, Error, Handle, ReadWrite, SetAccess], -- MSegment USING [Address, CopyIn, CopyOut, Create, Handle, Kill, Pages], -- Runtime USING [CallDebugger],  Space USING [ScratchMap, Unmap],  TestFrameworkDefs USING [    Base, BlockSize, ErrorType, RelPtr, RelString, StartStop,    WaitForAllProcessesIdle],  Zone USING [    Create, FreeNode, Handle, MakeNode, nil, --Recreate,-- SetChecking, SplitNode, Status];StableStorageImpl: MONITOR  IMPORTS Inline, --MFile, MSegment, Runtime, -- Space, TestFrameworkDefs, Zone  EXPORTS TestFrameworkDefs =  BEGIN OPEN TestFrameworkDefs;  ---- ---- ---- ---- ---- ---- ---- ---- ----  ----  -- Exported types, "constants", and variables.  Reserved: PUBLIC TYPE = PStartStop;  base: PUBLIC Base ¬ NIL;  -- Reset by Initialize.  nil: PUBLIC RelPtr ¬ Zone.nil;  -- Use this in place of NIL!  ---- ---- ---- ---- ---- ---- ---- ---- ----  ----  -- Global types, constants, and variables.  PStartStop: TYPE = LONG POINTER TO StartStop;  Status: TYPE = Zone.Status;  maxRegisteredNodes: CARDINAL = 20;  stableDataFixedPages: CARDINAL =  -- number of pages in backing file (does not count zone pages).    (SIZE[StableData] + Environment.wordsPerPage - 1)/Environment.wordsPerPage;  stableDataSeal: CARDINAL = 27183;  -- to detect garbage backing files.  nilNext: Reserved = NIL;  StableData: TYPE = RECORD [  -- layout of stuff in the backing file and space.    seal: CARDINAL ¬ stableDataSeal,    zone: Zone.Handle,    registeredNodes: ARRAY [0..maxRegisteredNodes) OF RelPtr,    storageForZone: ARRAY [0..0) OF UNSPECIFIED];  stableData: LONG POINTER TO StableData ¬ NIL;  -- backingFile: MFile.Handle;  -- stableSegment: MSegment.Handle;  zone: Zone.Handle;  -- startStopList is the header for our list of registered start &  --    stop procedures for the various modules.  Only the "next" field matters.  startStopList: StartStop ¬ [NIL, NIL, NIL, NIL, NIL, nilNext];  pLastStartStop: PStartStop ¬ @startStopList;  -- points to last entry in startStopList.  registrationClosed: BOOLEAN ¬ FALSE;  ---- ---- ---- ---- ---- ---- ---- ---- ----  ----  -- Public (re)startup control procedures.  -- CALLING SEQUENCE.  Do NOT deviate from this sequence:  --   All so-inclined modules call TestFrameworkDefs.Register[...].  --   TestFrameworkDefs.Initialize[...]; (which calls coldStartProcs or restartProcs)  --   ...  --   Any number of calls to TestFrameworkDefs.SaveState[], and StableStorageImpl utility procedures.  --   ...  --   TestFrameworkDefs.FinalFinish[];  -- On startup, each module with global data that it wants to keep in the  -- restorable zone should call Register.  This registers some  -- module-specific procedures for handling cold starts, restarts, etc.  The  -- 'StartStop' must be allocated and initialized by the caller (e.g., in  -- its global frame), and must remain allocated until FinalFinish returns.  Register: PUBLIC ENTRY PROCEDURE [pStartStop: PStartStop] =    BEGIN    IF registrationClosed THEN ERROR;    IF pStartStop ~= NIL THEN      BEGIN      pStartStop.next ¬ nilNext;      pLastStartStop.next ¬ pStartStop;      pLastStartStop ¬ pStartStop;      END;    END;  AssureRegistrationClosed: PUBLIC ENTRY PROCEDURE[] =    -- guarantees that start/restart/finish procs are not changing.    {IF ~registrationClosed THEN ERROR};  -- InitializeStableStorage sets up the zone managed by StableStorageImpl.  If  -- 'forceColdStart' is TRUE or if there is no file named 'backingFileName',  -- Initialize creates a brand new zone (of size 'zonePages') and a backing  -- file, and returns coldStart=TRUE.  Otherwise, it assumes that the file  -- contains a zone, restores and checks that zone, and returns coldStart=FALSE.   -- (Potentially, Initialize could grow the zone & backing file on restart.)  -- After initializing the zone, Initialize calls each of the registered  -- ColdStartProcs or RestartProcs, depending on 'coldStart'.  InitializeStableStorage: PUBLIC --EXTERNAL-- PROCEDURE [    backingFileName: LONG STRING, zonePages: CARDINAL, forceColdStart: BOOLEAN]    RETURNS [coldStart: BOOLEAN] =    BEGIN    client: CARDINAL;    coldStart ¬ InitializeStableStorageEntry[      backingFileName, zonePages, forceColdStart];    -- The following code assumes that, during a restart, the startStops are    -- registered in the same order that they were registered at coldStart!      client ¬ 0;    FOR startStop: PStartStop ¬ startStopList.next, startStop.next      UNTIL startStop = NIL DO      IF client >= maxRegisteredNodes THEN ERROR;      IF coldStart THEN {        IF startStop.coldStart ~= NIL THEN          stableData.registeredNodes[client] ¬ startStop.coldStart[base]}      ELSE {        IF startStop.restart ~= NIL THEN          startStop.restart[base, stableData.registeredNodes[client]]};      client ¬ SUCC[client];      ENDLOOP;    END;  InitializeStableStorageEntry: PUBLIC ENTRY PROCEDURE [    backingFileName: LONG STRING, zonePages: CARDINAL, forceColdStart: BOOLEAN]    RETURNS [coldStart: BOOLEAN] =    BEGIN    status: Status;    registrationClosed ¬ (IF registrationClosed THEN ERROR ELSE TRUE);    stableData ¬ Space.ScratchMap[stableDataFixedPages + zonePages];   -- stableSegment ¬ MSegment.Create[file: backingFile, release: [NIL,NIL], fileBase: 0, pages: stableDataFixedPages + zonePages, swapInfo: [body: uniform[20]]];   -- stableData ¬ MSegment.Address[stableSegment];    base ¬ @stableData.storageForZone;    coldStart ¬ FALSE;  -- assume..    -- scope of NoOldBackingFile --    BEGIN    GO TO ColdStart;  --  backingFile ¬ MFile.Acquire[backingFileName, anchor, [NIL,NIL] ! MFile.Error => GOTO ColdStart];  -- IF forceColdStart THEN GO TO ColdStart;  --  MSegment.CopyIn[stableSegment, backingFile, 0, stableDataFixedPages + zonePages];  --  IF stableData.seal ~= stableDataSeal THEN {   --   Runtime.CallDebugger[    --    "Garbage stable storage backing file.  (P)roceed to reinitialize it."L];   --   GO TO ColdStart};  -- [zH: stableData.zone, rootNode: , s: status] ¬ Zone.Recreate[base, base]; --  CkStatus[status]; --  IF Zone.SetChecking[stableData.zone, TRUE] ~= okay THEN {  --    Runtime.CallDebugger[    --    "Garbage zone in stable storage.  (P)roceed to reinitialize it."L];   --   GO TO ColdStart};    EXITS      ColdStart =>        BEGIN        coldStart ¬ TRUE;        -- MFile.SetAccess[backingFile, delete];	-- MFile.Delete[backingFile ! MFile.Error => IF code = noSuchFile THEN CONTINUE ELSE REJECT];       -- backingFile ¬ MFile.ReadWrite[ backingFileName, [NIL,NIL], unknown, stableDataFixedPages + zonePages];        [zH: stableData.zone, s: status] ¬ Zone.Create[          base, zonePages*Environment.wordsPerPage, base, , --checking:-- TRUE];        CkStatus[status];        CkStatus[Zone.SetChecking[stableData.zone, TRUE]];        stableData.seal ¬ stableDataSeal;        WriteStateOut[];  -- snapshot the initial contents of the zone.        END;    END;    zone ¬ stableData.zone;  -- put in a convenient place for everybody.    END;  -- SaveState gives each module a chance to copy current data into the zone  -- (by calling the registered SaveStateProcs), and then saves the current  -- state of the zone on the disk.  SaveState: PUBLIC --EXTERNAL-- PROCEDURE[] =    BEGIN    CopyDataThenWrite: --EXTERNAL-- PROCEDURE[] =      -- This is not an entry procedure because:      --   (a) WaitForAllProcessesIdle guarantees that there will only be:      --      one process at a time that calls CopyDataThenWrite, and:      --   (b) having this be a non-entry allows the saveState procs to:      --      allocate nodes, etc.      BEGIN      AssureRegistrationClosed[];  -- guarantees that start/restart/finish procs are not changing.      FOR startStop: PStartStop ¬ startStopList.next, startStop.next UNTIL        startStop = nilNext DO        IF startStop.saveState ~= NIL THEN startStop.saveState[]; ENDLOOP;      WriteStateOut[];      END;    TestFrameworkDefs.WaitForAllProcessesIdle[thenDo: CopyDataThenWrite];    END;  WriteStateOut: PROCEDURE[] =    INLINE {  --  MSegment.CopyOut[stableSegment, backingFile, 0, MSegment.Pages[stableSegment]];    };  -- Call FinalFinish to terminate the program run completely.  FinalFinish  -- gives each module a chance to finish (by calling the registered  -- FinalFinishProcs), then deletes the zone and it's backing file.   -- Note that FinalFinish calls the various FinalFinishProcs in REVERSE order  -- of registration.  This is because startup usually happens bottom-up, and  -- cleanup top-down.  FinalFinish: PUBLIC --EXTERNAL-- PROCEDURE =    BEGIN    FinishRest: --EXTERNAL-- PROCEDURE [pStartStop: PStartStop] =      BEGIN      IF pStartStop ~= nilNext THEN        BEGIN        FinishRest[pStartStop.next];        IF pStartStop.finalFinish ~= NIL THEN pStartStop.finalFinish[];        END;      END;    AssureRegistrationClosed[];  -- guarantees that start/restart/finish procs are not changing.    FinishRest[startStopList.next];  -- Finish all modules in reverse order.    stableData ¬ Space.Unmap[stableData];    -- MSegment.Kill[stableSegment];    -- MFile.SetAccess[backingFile, delete];    -- MFile.Delete[backingFile];    base ¬ stableData ¬ NIL;    pLastStartStop ¬ @startStopList;    startStopList.next ¬ nilNext;    END;  ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  -- Public utility procedures.  PtrFromRel: PUBLIC PROCEDURE [rel: RelPtr] RETURNS [ptr: LONG POINTER] = {    RETURN[IF rel = nil THEN NIL ELSE @base[rel]]};  RelFromPtr: PUBLIC PROCEDURE [ptr: LONG POINTER] RETURNS [rel: RelPtr] = {    RETURN[      IF ptr = NIL THEN nil      ELSE LOOPHOLE[Inline.LowHalf[        LOOPHOLE[ptr, LONG CARDINAL] - LOOPHOLE[base, LONG CARDINAL]], RelPtr]]};  StringFromRel: PUBLIC PROCEDURE [rel: RelString] RETURNS [str: LONG STRING] =    LOOPHOLE[PtrFromRel];  -- GetChecking returns the state of zone checking (see SetChecking).  -- GetChecking: ENTRY PROCEDURE RETURNS [BOOLEAN] = {  -- RETURN[Zone.GetAttributes[zone].checking]};  -- CheckZone is defined inline in TestFrameworkDefs.  -- SetChecking turns on/off detailed consistency checking in the zone.  -- SetChecking: ENTRY PROCEDURE [checking: BOOLEAN] = {  -- CkStatus[Zone.SetChecking[zone, checking]]; RETURN};  ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  -- Public Node procedures.  -- Node and String allocate a node/string from the zone.  Node: PUBLIC ENTRY PROCEDURE [nwords: CARDINAL] RETURNS [p: RelPtr] =    BEGIN    status: Status;    IF nwords ~IN BlockSize THEN ERROR Error[zoneTooSmall, nil];    [node: p, s: status] ¬ Zone.MakeNode[zone, nwords];    CkStatus[status, p];    RETURN;    END;  NewString: PUBLIC PROCEDURE [nchars: CARDINAL] RETURNS [s: RelString] =    BEGIN    s ¬ Node[(nchars + 1)/2 + 2];    base[s] ¬ StringBody[length: 0, maxlength: nchars, text:];    RETURN;    END;  -- Free(Nil) and FreeString(Nil) deallocate a node/string from the zone.  Free: PUBLIC ENTRY PROCEDURE [p: RelPtr] = {    IF p ~= nil THEN CkStatus[Zone.FreeNode[zone, PtrFromRel1[p]], p]; RETURN};  FreeString: PUBLIC PROCEDURE [s: RelString] = {Free[s]; RETURN};  -- CopyString allocates a new string, copying the contents of an existing  -- string.  newS.maxlength ¬ s.length + longer.  CopyString: PUBLIC PROCEDURE [s: LONG STRING, longer: CARDINAL ¬ 0]    RETURNS [newS: RelString] =    BEGIN    length: CARDINAL = (IF s = NIL THEN 0 ELSE s.length);    newS ¬ NewString[length + longer];    FOR i: CARDINAL IN [0..length) DO base[newS].text[i] ¬ s[i]; ENDLOOP;    base[newS].length ¬ length;    RETURN;    END;  -- SplitNode deallocates part of a node, keeping the first "n" words.  SplitNode: PUBLIC ENTRY PROCEDURE [p: RelPtr, n: BlockSize] = {    IF p ~= nil THEN CkStatus[Zone.SplitNode[zone, PtrFromRel1[p], n], p];    RETURN};  ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  -- Public Errors  Error: PUBLIC ERROR [type: ErrorType, p: RelPtr] = CODE;  ---- ---- ---- ---- ---- ---- ---- ---- ---- ----  -- Private procedures  -- CkStatus checks the "Status" flag returned by a Zone proc.  CkStatus: --EXTERNAL-- PROCEDURE [s: Status, p: RelPtr ¬ nil] =    -- (This is an external procedure since it references no monitor data)    {IF s = okay THEN RETURN ELSE ERROR Error[s, p]; };  -- PtrFromRel1 converts a relative pointer to an absolute one, ASSUMING that  -- the pointer is not "nil".  PtrFromRel1: PROCEDURE [rel: RelPtr] RETURNS [ptr: LONG POINTER] = INLINE {    RETURN[@base[rel]]};  END.LOGSeptember 24, 1980  1:10 PM   Morrison   Created file.October 26, 1980  7:51 PM   WDK       Implemented restarts. 8-Sep-81 15:09:04   WDK       LONGified. 1-Dec-81 17:06:57   CAJ    Converted from Directory to new file system, Space to MSegment; use Zone.Recreate to reestablish zone at restart.  1-Mar-83 13:47:21  LXD        Eliminated references to MFile and MSegment. Used Space instead where needed.
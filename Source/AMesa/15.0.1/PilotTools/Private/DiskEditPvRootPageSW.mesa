-- Copyright (C) 1984, 1986, 1988  by Xerox Corporation. All rights reserved. -- File: DiskEditPvRootPageSW.mesa   7-Mar-88  9:28:54 by CAJ  DIRECTORY  Boot USING [BootFileType, DiskAddress],  DiskEditInternal USING [dataPtr, dataWindowKey, ReplaceUIDString, ValidateUID],  File USING [PageNumber],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType, CommandItem,    DisplayItem, Enumerated, EnumeratedItem, EnumeratedNotifyProcType,    FilterProcType, ItemHandle, LabelItem, LongNumberItem, MenuProcType, newLine,    nextPlace, NumberItem, NumberNotifyProcType, ProcType, StringEditProc,    StringItem],  Heap USING [systemZone],  PhysicalVolumeFormat USING [    currentVersion, Descriptor, maxSubVols, PageNumber, physicalVolumeLabelLength,    seal, Seal, SubVolumeDesc],  String USING [AppendChar, FreeString, MakeString, Replace],  System USING [LocalTimeParameters, UniversalID, WestEast],  SystemInternal,  -- implied import  UserTerminal USING [BlinkDisplay],  Volume USING [nullID],  WindowSwap USING [RegisterView];DiskEditPVRootPageSW: PROGRAM  IMPORTS DiskEditInternal, FormSW, Heap, String, UserTerminal, WindowSwap  SHARES Boot =  BEGIN  FormItems: TYPE = {    begin, title, id, seal, version, labelLength, labelString, badPageCount,    maxBadPages, dataLostPageCount, maxDataLostPages, subvolumeCount,    onlineCount, subvolumeMarker, currentSubvolume, currentSubvolumeLVID,    currentSubvolumeSize, currentSubvolumeNPages, currentSubvolumeLVPage,    currentSubvolumePVPage, bootfile, bootfileID, boofileFirstPage, daTag,    daCyl, daHead, daSector, localTime, valid, direction, zone, zoneMin,    beginDST, endDST, fill1, fillIndex, fillValue, next, back};  validatePhysicalVolumeRootPage: BOOLEAN [TRUE..TRUE] =    PhysicalVolumeFormat.currentVersion = 7;  HeadOrSector: TYPE = [0..255];  LtpZone: TYPE = [0..12];  LtpZoneMinutes: TYPE = [0..59];  LtpBeginDST: TYPE = [0..366];  LtpEndDST: TYPE = [0..366];    pvRootPage: RECORD [    -- The fields in here which are passed to a FormSW must be word-aligned.    IDString: LONG STRING ¬ NIL,    labelString: LONG STRING ¬ NIL,    subVolumeMarkerIDString: LONG STRING ¬ NIL,    currentBootingInfoType: Boot.BootFileType[hardMicrocode..pilot] ¬      hardMicrocode,    currentSubvolumeIndex: CARDINAL ¬ 0,    currentSubvolumeIDString: LONG STRING ¬ NIL,    currentBootingInfoFileIDString: LONG STRING ¬ NIL,    currentSubvolume: PhysicalVolumeFormat.SubVolumeDesc ¬      [Volume.nullID, 0, 0, 0, 0],    currentBootingInfoFirstPage: File.PageNumber ¬ 0,    currentBootingInfoCyl: WORD ¬ 0,    currentBootingInfoHead: HeadOrSector ¬ 0,    alignFillerA: WORD,    currentBootingInfoSector: HeadOrSector ¬ 0,    alignFillerB: WORD,    ltpsValid: BOOLEAN ¬ FALSE,    alignFillerC: WORD,    ltpDirection: System.WestEast ¬ west,    ltpZone: CARDINAL ¬ 0,    ltpZoneMinutes: CARDINAL ¬ 0,    ltpBeginDST: CARDINAL ¬ 0,    ltpEndDST: CARDINAL ¬ 0,    currentFillIndex: CARDINAL ¬ 0,    currentFillValue: CARDINAL ¬ 0 ];      pv: LONG POINTER TO PhysicalVolumeFormat.Descriptor =    LOOPHOLE[DiskEditInternal.dataPtr];      CleanupPvRootPageSW: PROCEDURE =    BEGIN    pv.subVolumes[pvRootPage.currentSubvolumeIndex] ¬ pvRootPage.currentSubvolume;    pv.bootingInfo[pvRootPage.currentBootingInfoType].firstPage ¬      pvRootPage.currentBootingInfoFirstPage;    pv.bootingInfo[pvRootPage.currentBootingInfoType].da ¬      Boot.DiskAddress[cylinder: pvRootPage.currentBootingInfoCyl,        head: pvRootPage.currentBootingInfoHead,        sector: pvRootPage.currentBootingInfoSector];    pv.localTimeParametersValid ¬ pvRootPage.ltpsValid;    pv.localTimeParameters.direction ¬ pvRootPage.ltpDirection;    pv.localTimeParameters.zone ¬ pvRootPage.ltpZone;    pv.localTimeParameters.zoneMinutes ¬ pvRootPage.ltpZoneMinutes;    pv.localTimeParameters.beginDST ¬ pvRootPage.ltpBeginDST;    pv.localTimeParameters.endDST ¬ pvRootPage.ltpEndDST;    IF pvRootPage.currentFillIndex IN [0..LENGTH[pv.fill1]) THEN      pv.fill1[pvRootPage.currentFillIndex] ¬ pvRootPage.currentFillValue;    END;  CopyLabel: FormSW.FilterProcType =    BEGIN    FormSW.StringEditProc[sw, item, insert, string];    FOR i: CARDINAL IN      [0..MIN[         PhysicalVolumeFormat.physicalVolumeLabelLength,         pvRootPage.IDString.length]) DO      pv.label[i] ¬ pvRootPage.labelString[i]; ENDLOOP;    END;  DestroyPvRootPageSW: PROCEDURE =    BEGIN    -- Clean up resources for view going away for good.    String.FreeString[z: Heap.systemZone, s: pvRootPage.IDString];    pvRootPage.IDString ¬ NIL;    String.FreeString[z: Heap.systemZone, s: pvRootPage.labelString];    pvRootPage.labelString ¬ NIL;    String.FreeString[z: Heap.systemZone, s: pvRootPage.subVolumeMarkerIDString];    pvRootPage.subVolumeMarkerIDString ¬ NIL;    String.FreeString[z: Heap.systemZone, s: pvRootPage.currentSubvolumeIDString];    pvRootPage.currentSubvolumeIDString ¬ NIL;    String.FreeString[      z: Heap.systemZone, s: pvRootPage.currentBootingInfoFileIDString];    pvRootPage.currentBootingInfoFileIDString ¬ NIL;    END;  FillPvRootPageSW: PROCEDURE =    BEGIN    labelLength: CARDINAL =      MIN[PhysicalVolumeFormat.physicalVolumeLabelLength, pv.labelLength];    DiskEditInternal.ReplaceUIDString[@pvRootPage.IDString, pv.pvID];    String.Replace[@pvRootPage.labelString, NIL, Heap.systemZone];    pvRootPage.labelString ¬ String.MakeString[Heap.systemZone, labelLength];    FOR i: CARDINAL IN [0..labelLength) DO      String.AppendChar[pvRootPage.labelString, pv.label[i]]; ENDLOOP;    DiskEditInternal.ReplaceUIDString[      @pvRootPage.subVolumeMarkerIDString, pv.subVolumeMarkerID];    pvRootPage.currentSubvolume ¬ pv.subVolumes[pvRootPage.currentSubvolumeIndex];    DiskEditInternal.ReplaceUIDString[      @pvRootPage.currentSubvolumeIDString, pv.subVolumes[      pvRootPage.currentSubvolumeIndex].lvID];    DiskEditInternal.ReplaceUIDString[      @pvRootPage.currentBootingInfoFileIDString, LOOPHOLE[pv.bootingInfo[      pvRootPage.currentBootingInfoType].fID]];    pvRootPage.currentBootingInfoFirstPage ¬ pv.bootingInfo[      pvRootPage.currentBootingInfoType].firstPage;    pvRootPage.currentBootingInfoCyl ¬      pv.bootingInfo[pvRootPage.currentBootingInfoType].da.cylinder;    pvRootPage.currentBootingInfoHead ¬      pv.bootingInfo[pvRootPage.currentBootingInfoType].da.head;    pvRootPage.currentBootingInfoSector ¬       pv.bootingInfo[pvRootPage.currentBootingInfoType].da.sector;    pvRootPage.ltpsValid ¬ pv.localTimeParametersValid;    pvRootPage.ltpDirection ¬ pv.localTimeParameters.direction;    pvRootPage.ltpZone ¬ pv.localTimeParameters.zone;    pvRootPage.ltpZoneMinutes ¬ pv.localTimeParameters.zoneMinutes;    pvRootPage.ltpBeginDST ¬ pv.localTimeParameters.beginDST;    pvRootPage.ltpEndDST ¬ pv.localTimeParameters.endDST;    pvRootPage.currentFillValue ¬ pv.fill1[pvRootPage.currentFillIndex];    END;  MakePvRootPageSW: FormSW.ClientItemsProcType =    BEGIN    nItems: CARDINAL = 39;    items ¬ FormSW.AllocateItemDescriptor[nItems];    items[FormItems.begin.ORD] ¬ FormSW.LabelItem[      tag: NIL, invisible: TRUE, place: FormSW.newLine];    items[FormItems.title.ORD] ¬ FormSW.LabelItem[      tag: "Physical volume root page"L, place: FormSW.newLine];    items[FormItems.id.ORD] ¬ FormSW.StringItem[      tag: "ID"L, inHeap: FALSE, string: @pvRootPage.IDString,      filterProc: ValidatePVID, place: FormSW.newLine];    items[FormItems.seal.ORD] ¬ FormSW.NumberItem[      tag: "Seal"L, signed: FALSE, notNegative: TRUE, radix: octal,      default: PhysicalVolumeFormat.seal, value: @pv.seal, place: FormSW.newLine];    items[FormItems.version.ORD] ¬ FormSW.NumberItem[      tag: "Version"L, signed: FALSE, notNegative: TRUE, radix: octal,      default: PhysicalVolumeFormat.currentVersion, value: @pv.version,      place: FormSW.nextPlace];    items[FormItems.labelLength.ORD] ¬ FormSW.NumberItem[      tag: "Label length"L, notNegative: TRUE, signed: FALSE, radix: decimal,      default: 0, value: @pv.labelLength, place: FormSW.newLine];    items[FormItems.labelString.ORD] ¬ FormSW.StringItem[      tag: "Label"L, inHeap: FALSE, string: @pvRootPage.labelString,      filterProc: CopyLabel, place: FormSW.nextPlace];    items[FormItems.badPageCount.ORD] ¬ FormSW.LongNumberItem[      tag: "Bad page count"L, notNegative: TRUE, signed: FALSE, radix: decimal,      default: 0, value: @pv.badPageCount, place: FormSW.newLine];    items[FormItems.maxBadPages.ORD] ¬ FormSW.LongNumberItem[      tag: "Max bad pages"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, value: @pv.maxBadPages, place: FormSW.nextPlace];    items[FormItems.dataLostPageCount.ORD] ¬ FormSW.LongNumberItem[      tag: "DataLost page count"L, notNegative: TRUE, signed: FALSE,      radix: decimal, default: 0, value: @pv.dataLostPageCount,      place: FormSW.newLine];    items[FormItems.maxDataLostPages.ORD] ¬ FormSW.LongNumberItem[      tag: "Max dataLost pages"L, signed: FALSE, notNegative: TRUE,      radix: decimal, default: 0, value: @pv.maxDataLostPages,      place: FormSW.nextPlace];    items[FormItems.subvolumeCount.ORD] ¬ FormSW.NumberItem[      tag: "Subvolume Count"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, value: @pv.subVolumeCount, place: FormSW.newLine];    items[FormItems.onlineCount.ORD] ¬ FormSW.NumberItem[      tag: "Online count"L, notNegative: TRUE, signed: FALSE, radix: decimal,      default: 0, value: @pv.onLineCount, place: FormSW.nextPlace];    items[FormItems.subvolumeMarker.ORD] ¬ FormSW.StringItem[      tag: "Subvolume Marker ID"L, inHeap: FALSE, filterProc: ValidateSVMarkerID,      string: @pvRootPage.subVolumeMarkerIDString, place: FormSW.newLine];    items[FormItems.currentSubvolume.ORD] ¬ FormSW.NumberItem[      tag: "Current Subvolume"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, proc: NoticeNewSubvolumeIndex,      value: @pvRootPage.currentSubvolumeIndex, place: FormSW.newLine];    items[FormItems.currentSubvolumeLVID.ORD] ¬ FormSW.StringItem[      tag: "ID"L, inHeap: FALSE, string: @pvRootPage.currentSubvolumeIDString,      filterProc: ValidateSVID, place: FormSW.nextPlace];    items[FormItems.currentSubvolumeSize.ORD] ¬ FormSW.LongNumberItem[      tag: "   Logical volume size"L, signed: FALSE, notNegative: TRUE,      radix: decimal, default: 0, value: @pvRootPage.currentSubvolume.lvSize,      place: FormSW.newLine];    items[FormItems.currentSubvolumeNPages.ORD] ¬ FormSW.LongNumberItem[      tag: "Subvolume size"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, value: @pvRootPage.currentSubvolume.nPages,      place: FormSW.nextPlace];    items[FormItems.currentSubvolumeLVPage.ORD] ¬ FormSW.LongNumberItem[      tag: "   LV page #"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, value: @pvRootPage.currentSubvolume.lvPage,      place: FormSW.newLine];    items[FormItems.currentSubvolumePVPage.ORD] ¬ FormSW.LongNumberItem[      tag: "PV page #"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, value: @pvRootPage.currentSubvolume.pvPage,      place: FormSW.nextPlace];    BEGIN    enumeratedPVBootFiles: ARRAY [0..4) OF FormSW.Enumerated ¬ [      [string: "hardMicrocode"L, value: Boot.BootFileType[hardMicrocode]], [      string: "softMicrocode"L, value: Boot.BootFileType[softMicrocode]], [      string: "germ"L, value: Boot.BootFileType[germ]], [      string: "pilot"L, value: Boot.BootFileType[pilot]]];    items[FormItems.bootfile.ORD] ¬ FormSW.EnumeratedItem[      tag: "Boot file for type"L, feedback: one, copyChoices: TRUE,      value: @pvRootPage.currentBootingInfoType, proc: NoticeNewBootFileType,      choices: DESCRIPTOR[enumeratedPVBootFiles], place: FormSW.newLine];    items[FormItems.bootfileID.ORD] ¬ FormSW.StringItem[      tag: "ID"L, inHeap: FALSE,      string: @pvRootPage.currentBootingInfoFileIDString,      filterProc: ValidateBootFileID, place: FormSW.nextPlace];    items[FormItems.boofileFirstPage.ORD] ¬ FormSW.LongNumberItem[      tag: "   First page"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, value: @pvRootPage.currentBootingInfoFirstPage,      place: FormSW.newLine];    items[FormItems.daTag.ORD] ¬ FormSW.LabelItem[      tag: "BootDiskAddress", place: FormSW.nextPlace];    items[FormItems.daCyl.ORD] ¬ FormSW.NumberItem[      tag: "a"L, signed: FALSE, notNegative: TRUE, radix: octal, default: 0,      value: @pvRootPage.currentBootingInfoCyl, place: FormSW.nextPlace];    items[FormItems.daHead.ORD] ¬ FormSW.NumberItem[      tag: "b"L, signed: FALSE, notNegative: TRUE, radix: octal, default: 0,      value: @pvRootPage.currentBootingInfoHead, place: FormSW.nextPlace];    items[FormItems.daSector.ORD] ¬ FormSW.NumberItem[      tag: "c"L, signed: FALSE, notNegative: TRUE, radix: octal, default: 0,      value: @pvRootPage.currentBootingInfoSector, place: FormSW.nextPlace];    END;    BEGIN    enumeratedDirections: ARRAY [0..2) OF FormSW.Enumerated ¬ [      [string: "east"L, value: System.WestEast[east]], [      string: "west"L, value: System.WestEast[west]]];    items[FormItems.localTime.ORD] ¬ FormSW.LabelItem[      tag: "Local time parameters"L, place: FormSW.newLine];    items[FormItems.valid.ORD] ¬ FormSW.BooleanItem[      tag: "valid"L, switch: @pvRootPage.ltpsValid, place: FormSW.nextPlace];    items[FormItems.direction.ORD] ¬ FormSW.EnumeratedItem[      tag: "   Direction"L, feedback: all, copyChoices: TRUE,      value: @pvRootPage.ltpDirection, choices: DESCRIPTOR[enumeratedDirections],      place: FormSW.newLine];    items[FormItems.zone.ORD] ¬ FormSW.NumberItem[      tag: "Zone"L, signed: FALSE, notNegative: TRUE, radix: decimal, default: 0,      value: @pvRootPage.ltpZone, proc: ValidateLtpZone, place: FormSW.nextPlace];    items[FormItems.zoneMin.ORD] ¬ FormSW.NumberItem[      tag: "Zone minutes"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, value: @pvRootPage.ltpZoneMinutes, proc: ValidateLtpZoneMinutes,      place: FormSW.nextPlace];    items[FormItems.beginDST.ORD] ¬ FormSW.NumberItem[      tag: "   Begin DST"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, value: @pvRootPage.ltpBeginDST, proc: ValidateLtpBeginDST,      place: FormSW.newLine];    items[FormItems.endDST.ORD] ¬ FormSW.NumberItem[      tag: "End DST"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, value: @pvRootPage.ltpEndDST, proc: ValidateLtpEndDST,      place: FormSW.nextPlace];    END;    items[FormItems.fill1.ORD] ¬ FormSW.LabelItem[      tag: "Fill1"L, place: FormSW.newLine];    items[FormItems.fillIndex.ORD] ¬ FormSW.NumberItem[      tag: "Index"L, signed: FALSE, notNegative: TRUE, radix: decimal, default: 0,      value: @pvRootPage.currentFillIndex, proc: NoticeNewFillIndex,      place: FormSW.newLine];    items[FormItems.fillValue.ORD] ¬ FormSW.NumberItem[      tag: "Value", signed: FALSE, notNegative: TRUE, radix: decimal, default: 0,      value: @pvRootPage.currentFillValue, place: FormSW.nextPlace];    items[FormItems.next.ORD] ¬ FormSW.CommandItem[      tag: "Next", proc: FillNextCommand, place: FormSW.nextPlace];    items[FormItems.back.ORD] ¬ FormSW.CommandItem[      tag: "Back", proc: FillBackCommand, place: FormSW.nextPlace];    RETURN[items, TRUE]    END;  FillBackCommand: FormSW.ProcType =    BEGIN    IF pvRootPage.currentFillValue IN [0..LENGTH[pv.fill1]) THEN      pv.fill1[pvRootPage.currentFillValue] ¬ pvRootPage.currentFillValue;    pvRootPage.currentFillIndex ¬      IF pvRootPage.currentFillIndex = 0 THEN LENGTH[pv.fill1] - 1      ELSE pvRootPage.currentFillIndex - 1;    pvRootPage.currentFillValue ¬ pv.fill1[pvRootPage.currentFillIndex];    FormSW.DisplayItem[sw, FormItems.fillIndex.ORD];    FormSW.DisplayItem[sw, FormItems.fillValue.ORD];    END;  FillNextCommand: FormSW.ProcType =    BEGIN    IF pvRootPage.currentFillValue IN [0..LENGTH[pv.fill1]) THEN      pv.fill1[pvRootPage.currentFillValue] ¬ pvRootPage.currentFillValue;    pvRootPage.currentFillIndex ¬      (pvRootPage.currentFillIndex + 1) MOD LENGTH[pv.fill1];    pvRootPage.currentFillValue ¬ pv.fill1[pvRootPage.currentFillIndex];    FormSW.DisplayItem[sw, FormItems.fillIndex.ORD];    FormSW.DisplayItem[sw, FormItems.fillValue.ORD];    END;  NoticeNewBootFileType: FormSW.EnumeratedNotifyProcType =    BEGIN    pv.bootingInfo[oldValue].firstPage ¬ pvRootPage.currentBootingInfoFirstPage;    pv.bootingInfo[oldValue].da ¬      Boot.DiskAddress[cylinder: pvRootPage.currentBootingInfoCyl,        head: pvRootPage.currentBootingInfoHead,        sector: pvRootPage.currentBootingInfoSector];    DiskEditInternal.ReplaceUIDString[      @pvRootPage.currentBootingInfoFileIDString, LOOPHOLE[pv.bootingInfo[      pvRootPage.currentBootingInfoType].fID]];    pvRootPage.currentBootingInfoFirstPage ¬ pv.bootingInfo[      pvRootPage.currentBootingInfoType].firstPage;    pvRootPage.currentBootingInfoCyl ¬      pv.bootingInfo[pvRootPage.currentBootingInfoType].da.cylinder;    pvRootPage.currentBootingInfoHead ¬      pv.bootingInfo[pvRootPage.currentBootingInfoType].da.head;    pvRootPage.currentBootingInfoSector ¬       pv.bootingInfo[pvRootPage.currentBootingInfoType].da.sector;    FormSW.DisplayItem[sw, FormItems.bootfileID.ORD];    FormSW.DisplayItem[sw, FormItems.boofileFirstPage.ORD];    FormSW.DisplayItem[sw, FormItems.daCyl.ORD];    FormSW.DisplayItem[sw, FormItems.daHead.ORD];    FormSW.DisplayItem[sw, FormItems.daSector.ORD];    END;  NoticeNewFillIndex: FormSW.NumberNotifyProcType =    BEGIN    IF oldValue IN [0..LENGTH[pv.fill1]) THEN      pv.fill1[oldValue] ¬ pvRootPage.currentFillValue;    IF pvRootPage.currentFillIndex ~IN [0..LENGTH[pv.fill1]) THEN {      UserTerminal.BlinkDisplay[]; RETURN};    pvRootPage.currentFillValue ¬ pv.fill1[pvRootPage.currentFillIndex];    FormSW.DisplayItem[sw, FormItems.fillValue.ORD];    END;  NoticeNewSubvolumeIndex: FormSW.NumberNotifyProcType =    BEGIN    IF oldValue IN [0..PhysicalVolumeFormat.maxSubVols) THEN      pv.subVolumes[oldValue] ¬ pvRootPage.currentSubvolume;    IF pvRootPage.currentSubvolumeIndex ~IN [0..PhysicalVolumeFormat.maxSubVols)      THEN {UserTerminal.BlinkDisplay[]; RETURN};    pvRootPage.currentSubvolume ¬ pv.subVolumes[pvRootPage.currentSubvolumeIndex];    DiskEditInternal.ReplaceUIDString[      @pvRootPage.currentSubvolumeIDString, pvRootPage.currentSubvolume.lvID];    FormSW.DisplayItem[sw, FormItems.currentSubvolumeLVID.ORD];    FormSW.DisplayItem[sw, FormItems.currentSubvolumeSize.ORD];    FormSW.DisplayItem[sw, FormItems.currentSubvolumeLVPage.ORD];    FormSW.DisplayItem[sw, FormItems.currentSubvolumePVPage.ORD];    FormSW.DisplayItem[sw, FormItems.currentSubvolumeNPages.ORD];    END;  ValidateBootFileID: FormSW.FilterProcType =    BEGIN    valid: BOOLEAN;    id: System.UniversalID;    FormSW.StringEditProc[sw, item, insert, string];    [valid, id] ¬ DiskEditInternal.ValidateUID[      pvRootPage.currentBootingInfoFileIDString];    IF ~valid THEN UserTerminal.BlinkDisplay[]    ELSE pv.bootingInfo[pvRootPage.currentBootingInfoType].fID ¬ LOOPHOLE[id];    END;  ValidateLtpBeginDST: FormSW.NumberNotifyProcType =    BEGIN    IF pvRootPage.ltpBeginDST ~IN [FIRST[LtpBeginDST]..LAST[LtpBeginDST]] THEN      UserTerminal.BlinkDisplay[]    ELSE pv.localTimeParameters.beginDST ¬ pvRootPage.ltpBeginDST;    END;  ValidateLtpEndDST: FormSW.NumberNotifyProcType =    BEGIN    IF pvRootPage.ltpEndDST ~IN [FIRST[LtpBeginDST]..LAST[LtpEndDST]] THEN      UserTerminal.BlinkDisplay[]    ELSE pv.localTimeParameters.endDST ¬ pvRootPage.ltpEndDST;    END;  ValidateLtpZone: FormSW.NumberNotifyProcType =    BEGIN    IF pvRootPage.ltpZone ~IN [FIRST[LtpZone]..LAST[LtpZone]] THEN      UserTerminal.BlinkDisplay[]    ELSE pv.localTimeParameters.zone ¬ pvRootPage.ltpZone;    END;  ValidateLtpZoneMinutes: FormSW.NumberNotifyProcType =    BEGIN    IF pvRootPage.ltpZoneMinutes ~IN [FIRST[LtpZoneMinutes]..LAST[LtpZoneMinutes]]      THEN UserTerminal.BlinkDisplay[]    ELSE pv.localTimeParameters.zoneMinutes ¬ pvRootPage.ltpZoneMinutes;    END;  ValidatePVID: FormSW.FilterProcType =    BEGIN    valid: BOOLEAN;    id: System.UniversalID;    FormSW.StringEditProc[sw, item, insert, string];    [valid, id] ¬ DiskEditInternal.ValidateUID[pvRootPage.IDString];    IF ~valid THEN UserTerminal.BlinkDisplay[] ELSE pv.pvID ¬ LOOPHOLE[id];    END;  ValidateSVID: FormSW.FilterProcType =    BEGIN    valid: BOOLEAN;    id: System.UniversalID;    FormSW.StringEditProc[sw, item, insert, string];    [valid, id] ¬ DiskEditInternal.ValidateUID[      pvRootPage.currentSubvolumeIDString];    IF ~valid THEN UserTerminal.BlinkDisplay[]    ELSE pvRootPage.currentSubvolume.lvID ¬ LOOPHOLE[id];    END;  ValidateSVMarkerID: FormSW.FilterProcType =    BEGIN    valid: BOOLEAN;    id: System.UniversalID;    FormSW.StringEditProc[sw, item, insert, string];    [valid, id] ¬ DiskEditInternal.ValidateUID[      pvRootPage.currentSubvolumeIDString];    IF ~valid THEN UserTerminal.BlinkDisplay[]    ELSE pv.subVolumeMarkerID ¬ LOOPHOLE[id];    END;  -- Module initialization:  -- Register this subwindow as an alternate view for the data subwindow  WindowSwap.RegisterView[    key: DiskEditInternal.dataWindowKey,    viewName: "PV root page"L,    makeFormSW: MakePvRootPageSW,    viewFromDataProc: FillPvRootPageSW,    dataFromViewProc: CleanupPvRootPageSW,    destroyViewProc: DestroyPvRootPageSW];  END.LOG10-Sep-81 11:58:51   WDK       Converted to Pilot 8, Tajo 8.18-Nov-81 14:54:08   CAJ    LOOPHOLE'd init of currentBootingInfoDiskAddress pending upgrade to exported type.13-May-82  9:34:34   AWL         Copy all appropriate stuff in Cleanup and Fill routines..25-Apr-83 18:00:27   EKN      Update To Klamath (LOOPHOLE PilotDisk.FileID to System.UniversalID for DiskEditInternal.ReplaceUIDString). Replace Storage interface with String.29-Nov-83 17:34:30	EKN      Changed items:  pv.maxBadPages, pv.onLineCount, pv.badPageCount, pv.subVolumeCount, pv.labelLength, pvRootPage.currentSubvolumeIndex, pvRootPage.currentSubvolume.lvSize, pvRootPage.currentSubvolume.nPages,pvRootPage.currentSubvolume.lvPage, pvRootPage.currentSubvolume.pvPage, pvRootPage.currentBootingInfoFirstPage, pvRootPage.ltpZone, pvRootPage.ltpZoneMinutes, pvRootPage.ltpBeginDST, pvRootPage.ltpEndDST, pvRootPage.currentFillIndex, pvRootPage.currentFillValue to display decimal instead of octal.   16-Jan-84 11:43:57   KEK       Fill failed to copy ltpsValid. 5-Sep-84 14:03:41   CAJ    Added registering window view via WindowSwap, fix Fill proc's get label string.30-Sep-86 11:23:23   CAJ    PhysicalVolumeFormat.currentVersion = 6 ¬ 7.  Add DataLost table values.  Change display of bootfile disk address from 2 words. 7-Mar-88  9:28:31   CAJ    Add DestroyPvRootPageSW. Make inHeap's FALSE.  Cleanup form indexing.
-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- CPUUsageTomP.mesa (last edited by JJG 2-May-83 15:04:54)DIRECTORY  Process USING [Detach, GetPriority, Priority, SetPriority, Yield],  SpecialSpace USING [MakeProcedureResident],  System USING [GetClockPulses, MicrosecondsToPulses, Pulses, PulsesToMicroseconds],  TomP;    CPUUsageTomP:   PROGRAM  IMPORTS  Process, SpecialSpace, System, TomP =  BEGIN      cyclesPerSecond, pulsesPerSecond: LONG CARDINAL ¬ 0;  -- set by Calibrate  startCycles, cycles: LONG CARDINAL ¬ 0;  startPulses: LONG CARDINAL;  usage: LONG CARDINAL ¬ 0;    updateSerialNumber:CARDINAL ¬ 0; stopped:BOOLEAN ¬ TRUE;    Calibrate: PROCEDURE =     BEGIN    cyclesToSample: CARDINAL = 10000;  -- about a second on a DLion    priorityPrev: Process.Priority ¬ Process.GetPriority[];    first, last: System.Pulses;    nanoSecPerCycle: LONG CARDINAL;    Process.SetPriority[LAST[Process.Priority]];    first ¬ System.GetClockPulses[];    THROUGH [0..cyclesToSample)       DO      cycles ¬ SUCC[cycles];      Process.Yield[];      ENDLOOP;    -- This seems slow if an extra timeout scan happens, packet arrives or ...    -- Unfortunately, that causes confusion when idle > 100%    last ¬ System.GetClockPulses[];    cycles ¬ cycles - cyclesToSample;    Process.SetPriority[priorityPrev];    nanoSecPerCycle ¬      System.PulsesToMicroseconds[[LONG[1000]*(last-first)]]/cyclesToSample;    cyclesPerSecond ¬ 1000000000/nanoSecPerCycle;    pulsesPerSecond ¬ System.MicrosecondsToPulses[1000000];    END;      Idler: PROCEDURE =     BEGIN    count:CARDINAL ¬ 0;    localSerialNumber:CARDINAL ¬ updateSerialNumber;        WHILE count<5      DO      THROUGH [0..10000)         DO        cycles ¬ SUCC[cycles];        Process.Yield[];	ENDLOOP; 	      IF localSerialNumber=updateSerialNumber      THEN count ¬ count+1      ELSE {localSerialNumber ¬ updateSerialNumber; count ¬ 0};      ENDLOOP;          stopped ¬ TRUE;    END;   InitializeMonitor: PROCEDURE =    BEGIN    priorityPrev: Process.Priority;    priorityPrev ¬ Process.GetPriority[];    Process.SetPriority[0];    Process.Detach[FORK Idler[]];    Process.SetPriority[priorityPrev];    END;      Update: TomP.UpdateVariablesProcType =    BEGIN    idle:CARDINAL;    cyclesSinceLastUpdate:LONG CARDINAL;    PulsesSinceLastUpdate:LONG CARDINAL;        IF stopped    THEN      BEGIN      priorityPrev: Process.Priority;      stopped ¬ FALSE;      priorityPrev ¬ Process.GetPriority[];      Process.SetPriority[0];      Process.Detach[FORK Idler[]];      Process.SetPriority[priorityPrev];      startPulses ¬ System.GetClockPulses[];       startCycles ¬ cycles;      END;          PulsesSinceLastUpdate ¬ System.GetClockPulses[] - startPulses;    cyclesSinceLastUpdate ¬ cycles - startCycles;    updateSerialNumber ¬ SUCC[updateSerialNumber];        IF PulsesSinceLastUpdate=0 OR cyclesSinceLastUpdate=0    THEN {usage ¬ 100; RETURN};        THROUGH [0..10)      DO      cyclesThisTry: LONG CARDINAL =          cyclesSinceLastUpdate * pulsesPerSecond/PulsesSinceLastUpdate;      idle ¬ CARDINAL[cyclesThisTry * 100/cyclesPerSecond];      IF idle > 100      THEN   -- Calibration screwed up	 {cyclesPerSecond ¬ cyclesPerSecond + 1;  LOOP}      ELSE EXIT;      REPEAT FINISHED => idle ¬ 100;      ENDLOOP;          usage ¬ (100 - idle);    startCycles ¬ startCycles + cyclesSinceLastUpdate;    startPulses ¬ startPulses + PulsesSinceLastUpdate;    END;               GetVariable: TomP.GetVariableProcType =    BEGIN    SELECT index FROM      0 => RETURN [["busy", @usage, FALSE]];      ENDCASE => RETURN [["invalid index", NIL]]    END;    Calibrate[];  SpecialSpace.MakeProcedureResident[Idler];    [] ¬ TomP.Register[name:"CPUUsage", nVariables:1,                      getVariableProc:GetVariable, updateVariablesProc:Update]		       END.	
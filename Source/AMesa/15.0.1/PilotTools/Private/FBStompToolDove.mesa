-- Copyright (C) 1985, 1987, 1988  by Xerox Corporation. All rights reserved. -- FBStompToolDove.mesa - (last edited by RSV     29-Feb-88  9:59:38)-- Tool for making bootable floppy disks on Dove.DIRECTORY  Boot USING [DiskFileID],  Device USING [Type],  DeviceTypesExtras USING [anyFloppy, sa850],  DeviceTypesExtras3 USING [sa475],  Environment USING [    bytesPerPage, PageCount, wordsPerPage],  Event USING [DoneWithProcess, Handle, StartingProcess, toolWindow],  EventTypes USING [deactivate],  File USING [File, GetSize, ID, nullID, PageCount, Unknown],  FileTypes USING [tUntypedFile],  Floppy USING [    BootFilePointer, Close, CopyFromPilotFile, CreateFile,    CreateInitialMicrocodeFile, DeleteFile, Error, ErrorType, FileHandle, Format,    GetAttributes, GetBootFiles, GetFileAttributes, nullBootFilePointer,    nullFileID, Open, PageNumber, Read, SetBootFiles, VolumeHandle, Write],  FloppyExtras3 USING [GetBootFilesAlternateUCode, SetBootFilesAlternateUCode],  FloppyChannel USING [    Attributes, DiskAddress, Drive, GetDeviceAttributes, GetHandle, GetNextDrive,    nullDrive],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType, CommandItem,    Display, FindItem, ItemHandle, line0, line1, line2, line3, newLine,    NumberItem, ProcType, StringItem, WordBoolean],  Heap USING [systemZone],  MFile USING [Acquire, Error, Handle, Release],  Process USING [Detach],  Put USING [Text],  Runtime USING [GetBcdTime],  Space USING [Interval, Map, ScratchMap, Unmap],  SpecialFloppy USING [    CreateFileAtAddress, Error, GetDiskAddress, GetFileAtDiskAddress],  SpecialMFile USING [GetCapaWithAccess, LeaderPages],  String USING [AppendString, CopyToNewString],  Supervisor USING [AddDependency, AgentProcedure, CreateSubsystem,    EnumerationAborted, RemoveDependency, SubsystemHandle],  Time USING [Append, Unpack],  Tool USING [    Create, MakeFileSW, MakeFormSW, MakeMsgSW, MakeSWsProc, UnusedLogName],  ToolWindow USING [TransitionProcType],  UserInput USING [CreatePeriodicNotify, PeriodicProcType],  UserTerminal USING [BlinkDisplay],  Version USING [Append],  Window USING [Handle];FBStompToolDove: MONITOR  IMPORTS    Event, Floppy, FloppyChannel, FloppyExtras3, File, FormSW, Heap, MFile,    Process, Put, Runtime, Space, SpecialFloppy, SpecialMFile, String,    Supervisor, Time, Tool, UserInput, UserTerminal, Version =  BEGIN  -- Types  StringName: TYPE = {floppyName, initUCode, boot, germ, diagUCodeDaybreak,    diagUCodeDaisy, pilotUCode};  FileName: TYPE = StringName [initUCode..pilotUCode];  wdsPerPage: CARDINAL = Environment.wordsPerPage;  bytesPerPage: CARDINAL = Environment.bytesPerPage;  DiagnosticDataRec: TYPE = MACHINE DEPENDENT RECORD [    data(0): CARDINAL ¬ 455,    sector(1): CARDINAL,    cylinder(2): CARDINAL,    head(3): CARDINAL,    a(4): ARRAY [4..32) OF CARDINAL ¬ ALL[000000B],    b(32): ARRAY [32..64) OF CARDINAL ¬ ALL[177777B],    c(64): ARRAY [64..96) OF CARDINAL ¬ ALL[052525B],    d(96): ARRAY [96..128) OF CARDINAL ¬ ALL[125252B],    e(128): ARRAY [128..160) OF CARDINAL ¬ ALL[031463B],    f(160): ARRAY [160..192) OF CARDINAL ¬ ALL[146314B],    g(192): ARRAY [192..224) OF CARDINAL ¬ ALL[000401B],    h(224): ARRAY [224..256) OF CARDINAL ¬ ALL[177376B]];  -- (Booting) Root page:  -- On a bootable floppy, information about the files needed for booting,  -- (microcode, germ, and bootfile), is kept in the booting root page.  -- This page and its format are known to the microcode and this tool only.  -- The content corresponds to Boot.PVBootFiles in the PV root pages for  -- rigid disks, with the exception that Floppy adds alternateMicrocode  -- and doesn't use any of the Boot.mesa-defined types after pilot.  -- Note that the floppy file system also has something called a root page  -- which has different content, location, and purpose from this one.  Both  -- exist on a bootable floppy.  The file system root page has its own  -- array for the booting files, but the entries are sector numbers.  It can  -- then get the remaining information through its file system structures.  -- This tool is the (only) apparent link between the microcode's and the  -- floppy file system's records of the booting files.  FloppyBootFileType: TYPE = MACHINE DEPENDENT    {hardMicrocode, softMicrocode, germ, pilot, alternateMicrocode};    -- This type must be ordered exactly like    -- Boot.BootFileType[hardMicrocode..pilot] so that the RootPageStructure    -- ordering corresponds exactly to a Boot.PVBootFiles.  This floppy version    -- of things extends Boot.BootFileType and Boot.PVBootFiles to include    -- alternateMicrocode.    -- Note that the ordering differs from both from installation order    -- (see FileName) and from floppy file system root page ordering.  RootPageStructure: TYPE = ARRAY FloppyBootFileType OF Floppy.BootFilePointer;  FloppyPVBootFiles: TYPE = ARRAY FloppyBootFileType OF Boot.DiskFileID;    -- format known to the initial microcode.  bootingInfoOffset: CARDINAL = 0;  rootPageAddress: FloppyChannel.DiskAddress = [cylinder: 4, head: 0, sector: 1];  -- Global variables, allocated dynamically so we don't use up resources  -- when deactivated.  GlobalHandle: TYPE = LONG POINTER TO Global;  Global: TYPE = RECORD [    msgSW: Window.Handle ¬ NIL,    fileSW: Window.Handle ¬ NIL,    formSW: Window.Handle ¬ NIL,    commandSW: Window.Handle ¬ NIL,    driveIndex: CARDINAL ¬ 0,    numberOfCylinders: CARDINAL ¬ 0,    deviceType: Device.Type ¬ DeviceTypesExtras.anyFloppy,    strings: ARRAY StringName OF LONG STRING ¬ ALL[NIL],    formatFloppy: FormSW.WordBoolean ¬ [f1[FALSE]],    reserveLastCylinder: FormSW.WordBoolean ¬ [f1[FALSE]],    makeBoot: FormSW.WordBoolean ¬ [f1[FALSE]],    busy: BOOLEAN ¬ FALSE];  drivesIndex: CARDINAL = 0;  formattingIndex: CARDINAL = drivesIndex + 1;  initUCodeIndex: CARDINAL = formattingIndex + 1;  diagUCodeDaybreakIndex: CARDINAL = initUCodeIndex + 1;  pilotUCodeIndex: CARDINAL = diagUCodeDaybreakIndex + 1;  diagUCodeDaisyIndex: CARDINAL = pilotUCodeIndex + 1;  bootIndex: CARDINAL = diagUCodeDaisyIndex + 1;  -- The following two lines MUST correspond  germIndex: CARDINAL = bootIndex + 1;  nItems: CARDINAL = germIndex + 1;  nCommands: CARDINAL = startIndex + 1;  formatIndex: CARDINAL = 0;  reserveLastCylinderIndex: CARDINAL = formatIndex + 1;  makeBootIndex: CARDINAL = reserveLastCylinderIndex + 1;  startIndex: CARDINAL = makeBootIndex + 1;    agent: Supervisor.SubsystemHandle = Supervisor.CreateSubsystem[CheckDeactivate];  -- Variable declarations  g: GlobalHandle ¬ NIL;  wh: Window.Handle;  -- Tool's window  z: UNCOUNTED ZONE ¬ Heap.systemZone;  NoFile: ERROR [s: LONG STRING] = CODE;  Error: ERROR [s1: LONG STRING, s2: LONG STRING ¬ NIL] = CODE;  --*********************************************************************  --  -- formatting a floppy  --  --*********************************************************************  Format: PROCEDURE =    BEGIN    Write[both, "\nFormatting... "L];    IF g.strings[floppyName] = NIL OR g.strings[floppyName].length = 0 THEN      Error["Please pick a name for this floppy"L];    Floppy.Format[      drive: g.driveIndex,      maxNumberOfFileListEntries: IF g.numberOfCylinders >= 77 THEN 30 ELSE 10,      labelString: g.strings[floppyName], density: double];    Write[both, "done"L];    END;  --*********************************************************************  --  -- reserve last cylinder for diagnostics  --  --*********************************************************************  -- on side 0, use 1 (seal), 2-12 (write test), 13 deleted sector test,   --                14 (end marker), 15 (system or begin marker page)  -- on side 1, use 1 (seal), 2 (write), 3 (end marker)  ReserveLastCylinderForDiagnostics: PROCEDURE =    BEGIN    twoSided: BOOLEAN;    Write[both, "\nReserving last cylinder for diagnostics... "L];    twoSided ¬ ReserveLastCylinderOnOneSide[head: 0, size: 8];    IF twoSided THEN [] ¬ ReserveLastCylinderOnOneSide[head: 1, size: 7];    Write[both, "done"L];    END;  ReserveLastCylinderOnOneSide: PROCEDURE [head: CARDINAL, size: CARDINAL]    RETURNS [twoSided: BOOLEAN] =    BEGIN    buffer: DiagnosticDataRec;    cylinder: CARDINAL ¬ g.numberOfCylinders - 1;    file: Floppy.FileHandle;    sector: CARDINAL = 1;    vol: Floppy.VolumeHandle;    pageNumber: Floppy.PageNumber;    buffer ¬ DiagnosticDataRec[      data: SELECT g.deviceType FROM	DeviceTypesExtras3.sa475 => 475,	DeviceTypesExtras.sa850 => 850,  -- shouldn't get this one	ENDCASE --DeviceTypesExtras.sa455-- => 455,      sector: sector, cylinder: cylinder, head: head];    vol ¬ Floppy.Open[g.driveIndex];    BEGIN    ENABLE UNWIND => Floppy.Close[vol ! Floppy.Error => CONTINUE];    IF Floppy.GetAttributes[vol, NIL].density # double THEN      Error["Diagnostic floppies must be double density"L];    twoSided ¬ (Floppy.GetAttributes[vol, NIL].sides = two);    [file, pageNumber] ¬ SpecialFloppy.GetFileAtDiskAddress[      vol, [cylinder: cylinder, head: head, sector: sector]];    IF file.file # Floppy.nullFileID THEN      BEGIN      IF pageNumber # 0 OR Floppy.GetFileAttributes[file].size # size        OR Floppy.GetFileAttributes[file].type # FileTypes.tUntypedFile THEN        Error["Another file occupies required space"L];      Floppy.Read[file: file, first: 0, count: 1, vm: @buffer];      IF buffer #        DiagnosticDataRec[sector: sector, cylinder: cylinder, head: head]          THEN Error["Another file occupies required space"L];      END    ELSE      BEGIN      -- create the file      file ¬ SpecialFloppy.CreateFileAtAddress[        vol, size, FileTypes.tUntypedFile, [        cylinder: cylinder, head: head, sector: sector]];      Floppy.Write[file: file, first: 0, count: 1, vm: @buffer];      END;    END;    Floppy.Close[vol];    END;  --*********************************************************************  --  -- install the various files for a bootable floppy  --  --*********************************************************************  MakeBootableFloppy: PROCEDURE =    BEGIN    rootPageFile: Floppy.FileHandle;    vol: Floppy.VolumeHandle;    gotIt: BOOLEAN ¬ TRUE;    Write[both, "\nMaking bootable floppy... "L];    vol ¬ Floppy.Open[g.driveIndex];    rootPageFile ¬ SpecialFloppy.CreateFileAtAddress[      vol, 1, FileTypes.tUntypedFile, rootPageAddress !      SpecialFloppy.Error => {gotIt ¬ FALSE; CONTINUE}];    IF ~gotIt THEN      BEGIN      rootPageFile ¬        SpecialFloppy.GetFileAtDiskAddress[vol, rootPageAddress].file;      IF rootPageFile.file = Floppy.nullFileID THEN GO TO noSpace      ELSE        BEGIN        size: LONG CARDINAL ¬ Floppy.GetFileAttributes[rootPageFile].size;        IF size ~= 1 THEN          BEGIN          Floppy.DeleteFile[rootPageFile];          rootPageFile ¬ SpecialFloppy.CreateFileAtAddress[            vol, 1, FileTypes.tUntypedFile, rootPageAddress !            SpecialFloppy.Error => GO TO noSpace];          END;        END;      END;        FOR s: FileName IN FileName DO      InstallFile[s, vol        ! UNWIND => Floppy.Close[vol ! Floppy.Error => CONTINUE]];       ENDLOOP;    WriteBootingInfo[vol, rootPageFile];    Floppy.Close[vol];    Write[both, "done"L];    EXITS      noSpace => {Write[both, "\nfloppy requires reformatting"L]; RETURN};    END;  InstallFile: PROCEDURE [which: FileName, vol: Floppy.VolumeHandle] =    BEGIN    PageOfZeros: TYPE = ARRAY [0..Environment.wordsPerPage] OF WORD ¬ ALL[0];    pageOfZeros: LONG POINTER TO PageOfZeros ¬ z.NEW[PageOfZeros];    filename: LONG STRING = g.strings[which];    file: File.File;    flopFile: Floppy.FileHandle;    leaderSize: File.PageCount;    fileSize: File.PageCount;    flopBFP: Floppy.BootFilePointer;    IF filename = NIL OR filename.length = 0 THEN RETURN;    Write[fileOnly, "\n  installing "L, filename, "... "L];    [file, leaderSize, fileSize] ¬ GetPilotFSDope[filename];    flopBFP ¬ GetFloppyFSDope[which, vol];    flopFile ¬ [volume: vol, file: flopBFP.file];    IF flopFile.file # Floppy.nullFileID      AND (Floppy.GetFileAttributes[flopFile].size # fileSize      OR which = initUCode)        THEN {        Write[fileOnly, "(deleting existing file)... "L];        Floppy.DeleteFile[flopFile];        SetFloppyFSDope[which, vol, Floppy.nullBootFilePointer];        flopFile ¬ [volume: vol, file: Floppy.nullFileID]};    IF flopFile.file = Floppy.nullFileID THEN {      Write[fileOnly, "(creating file)... "L];      flopFile ¬        IF which = initUCode THEN Floppy.CreateInitialMicrocodeFile[          vol, fileSize, FileTypes.tUntypedFile, 0]        ELSE Floppy.CreateFile[vol, fileSize, FileTypes.tUntypedFile];	IF which # initUCode THEN 	  SetFloppyFSDope[which, vol, [flopFile.file, 0]]};    Floppy.Write[file: flopFile, first: 0, count: 1, vm: pageOfZeros];    Floppy.CopyFromPilotFile[      floppyFile: flopFile, pilotFile: file, firstFloppyPage: 1,      firstPilotPage: leaderSize+1];    Floppy.CopyFromPilotFile[      floppyFile: flopFile, pilotFile: file, firstFloppyPage: 0,      firstPilotPage: leaderSize, count: 1];    z.FREE[@pageOfZeros];    END;  WriteBootingInfo: PROCEDURE [vol: Floppy.VolumeHandle, fH: Floppy.FileHandle] =    BEGIN    sIPtr: LONG POINTER = Space.ScratchMap[count: 1];    bf: LONG POINTER TO FloppyPVBootFiles ¬ sIPtr + bootingInfoOffset;    flopFile: Floppy.FileHandle;    floppyBootFiles: RootPageStructure;    flopFile.volume ¬ vol;    [pilotMicrocode: floppyBootFiles[softMicrocode],      diagnosticMicrocode: floppyBootFiles[hardMicrocode],      germ: floppyBootFiles[germ],      pilotBootFile: floppyBootFiles[pilot]] ¬ Floppy.GetBootFiles[vol];    floppyBootFiles[alternateMicrocode] ¬      FloppyExtras3.GetBootFilesAlternateUCode[vol];    FOR index: FloppyBootFileType IN FloppyBootFileType DO      flopFile.file ¬ floppyBootFiles[index].file;      bf[index].fID ¬ [volumeRelative[File.nullID]];      bf[index].firstPage ¬ Floppy.GetFileAttributes[flopFile         !  Floppy.Error => {	  bf[index].firstPage ¬ 0;	  CONTINUE}].size;      bf[index].da ¬ LOOPHOLE[SpecialFloppy.GetDiskAddress[        flopFile, floppyBootFiles[index].page]];      ENDLOOP;    Floppy.Write[fH, 0, 1, sIPtr];    [] ¬ Space.Unmap[sIPtr];    END;  GetPilotFSDope: PROCEDURE [s: LONG STRING]    RETURNS [file: File.File, leaderSize, fileSize: File.PageCount] = {    fH: MFile.Handle;    fH ¬ MFile.Acquire[s, readOnly, [] ! MFile.Error => NoFile[s]];    file ¬ SpecialMFile.GetCapaWithAccess[fH];    leaderSize ¬ SpecialMFile.LeaderPages[];    fileSize ¬      File.GetSize[file ! File.Unknown => {MFile.Release[fH]; NoFile[s]}] -        leaderSize;    MFile.Release[fH]};  GetFloppyFSDope: PROCEDURE [which: FileName, vol: Floppy.VolumeHandle]    RETURNS [Floppy.BootFilePointer] =    BEGIN    IF which = diagUCodeDaisy THEN      RETURN[FloppyExtras3.GetBootFilesAlternateUCode[vol]]    ELSE BEGIN    info: ARRAY FileName OF Floppy.BootFilePointer;    [initialMicrocode: info[initUCode], pilotMicrocode: info[pilotUCode],      diagnosticMicrocode: info[diagUCodeDaybreak], germ: info[germ],      pilotBootFile: info[boot]] ¬ Floppy.GetBootFiles[vol];    RETURN[info[which]];    END;    END;  SetFloppyFSDope: PROCEDURE [which: FileName, vol: Floppy.VolumeHandle,    bfPointer: Floppy.BootFilePointer] =    BEGIN    IF which = diagUCodeDaisy THEN FloppyExtras3.SetBootFilesAlternateUCode[      volume: vol, alternateUCode: bfPointer]    ELSE BEGIN    info: ARRAY FileName OF Floppy.BootFilePointer;    [initialMicrocode: info[initUCode], pilotMicrocode: info[pilotUCode],      diagnosticMicrocode: info[diagUCodeDaybreak], germ: info[germ],      pilotBootFile: info[boot]] ¬ Floppy.GetBootFiles[vol];    info[which] ¬ bfPointer;    Floppy.SetBootFiles[      volume: vol, pilotMicrocode: info[pilotUCode],      diagnosticMicrocode: info[diagUCodeDaybreak], germ: info[germ],      pilotBootFile: info[boot]];    END;    END;    --*********************************************************************  --  -- tool support  --  --*********************************************************************  -- Initialization  Init: PROCEDURE =    BEGIN    name: LONG STRING ¬ String.CopyToNewString[      s: "MakeDoveBootFloppyTool "L, z: z, longer: 100];    Version.Append[name];    String.AppendString[to: name, from: " of "L];    Time.Append[name, Time.Unpack[Runtime.GetBcdTime[]]];    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default,      clientTransition: ClientTransition, name: name, tinyName1: "MakeDove"L,      tinyName2: "BootFloppy"L, cmSection: "MakeDoveBootFloppyTool"L];    z.FREE[@name];    END;      CheckDeactivate: Supervisor.AgentProcedure     --[event: Supervisor.Event, eventData: LONG POINTER TO UNSPECIFIED,    -- instanceData: LONG POINTER TO UNSPECIFIED]-- =    BEGIN    IF event = EventTypes.deactivate AND      wh # NIL AND wh = eventData      AND g.busy THEN {      UserTerminal.BlinkDisplay[];      Write[msgOnly, "\nMakeDoveBootFloppyTool busy: aborting deactivation... "L];      ERROR Supervisor.EnumerationAborted};    END;  MakeSWs: Tool.MakeSWsProc --[window: Tool.WindowHandle]--  =    BEGIN    logName: STRING = [50];    Tool.UnusedLogName[unused: logName, root: "MakeDoveBootFloppyTool.log"L];    g.msgSW ¬ Tool.MakeMsgSW[window: window];    g.formSW ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    g.commandSW ¬ Tool.MakeFormSW[window: window, formProc: MakeCommandSW];    g.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    Supervisor.AddDependency[client: agent, implementor: Event.toolWindow];    END;  MakeForm: FormSW.ClientItemsProcType    --RETURNS [items: FormSW.ItemDescriptor, freeDesc: BOOLEAN]--  =    BEGIN OPEN FormSW;    items ¬ AllocateItemDescriptor[nItems];    items[drivesIndex] ¬ NumberItem[      tag: "Drive"L, place: [0, line0], signed: FALSE, notNegative: TRUE,      radix: decimal, value: @g.driveIndex];    items[formattingIndex] ¬ StringItem[      tag: "Floppy Name"L, place: [225, line0], string: @g.strings[floppyName],      inHeap: TRUE];    items[initUCodeIndex] ¬ StringItem[      tag: "Initial uCode"L, place: [0, line1], string: @g.strings[initUCode],      inHeap: TRUE];    items[diagUCodeDaybreakIndex] ¬ StringItem[      tag: "Daybreak Diagnostic uCode"L, place: [225, line1],      string: @g.strings[diagUCodeDaybreak],      inHeap: TRUE];    items[pilotUCodeIndex] ¬ StringItem[      tag: "Pilot uCode"L, place: [0, line2], string: @g.strings[pilotUCode],      inHeap: TRUE];    items[diagUCodeDaisyIndex] ¬ StringItem[      tag: "Daisy Diagnostic uCode"L, place: [225, line2],      string: @g.strings[diagUCodeDaisy],      inHeap: TRUE];    items[bootIndex] ¬ StringItem[      tag: "Boot File"L, place: [0, line3], string: @g.strings[boot],      inHeap: TRUE];    items[germIndex] ¬ StringItem[      tag: "Germ File"L, place: [225, line3], string: @g.strings[germ],      inHeap: TRUE];    RETURN[items: items, freeDesc: TRUE];    END;  MakeCommandSW: FormSW.ClientItemsProcType    --RETURNS [items: FormSW.ItemDescriptor, freeDesc: BOOLEAN]--  =    BEGIN OPEN FormSW;    -- Create SW for commands.    items ¬ AllocateItemDescriptor[nCommands];    items[formatIndex] ¬ BooleanItem[      tag: "Format Floppy"L, place: newLine, switch: @g.formatFloppy.b,      drawBox: TRUE];    items[reserveLastCylinderIndex] ¬ BooleanItem[      tag: "Reserve Last Cylinder For Diagnostics"L,      switch: @g.reserveLastCylinder.b, drawBox: TRUE];    items[makeBootIndex] ¬ BooleanItem[      tag: "Install Boot Files"L, switch: @g.makeBoot.b, drawBox: TRUE];    items[startIndex] ¬ CommandItem[tag: "Start"L, proc: DoCommand];    RETURN[items: items, freeDesc: TRUE];    END;      DoCommand: FormSW.ProcType    --[sw: Window.Handle, item: FormSW.ItemHandle, index: CARDINAL]--  =    {Process.Detach[FORK DoCommandInternal[sw, item, index]]};      DoCommandInternal: ENTRY PROCEDURE [    sw: Window.Handle, item: FormSW.ItemHandle, index: CARDINAL] =    BEGIN    floppyErrors: ARRAY Floppy.ErrorType OF STRING = [      "badDisk"L, "badSectors"L, "endOfFile"L, "fileListFull"L, "fileNotFound"L,      "hardwareError"L, "incompatibleSizes"L, "invalidFormat"L,      "invalidPageNumber"L, "invalidVolumeHandle"L, "insufficientSpace"L,      "needsScavenging"L, "noSuchDrive"L, "notReady"L, "onlyOneSide"L,      "onlySingleDensity"L, "initialMicrocodeSpaceNotAvailable"L,      "stringTooShort"L, "volumeNotOpen"L, "writeInhibited"L, "zeroSizeFile"L,      "file list length too short"L, "floppy image invalid"L,      "floppy space too small"L];          handle: Event.Handle ¬ Event.StartingProcess["MakeDoveBootFloppyTool"L];    BEGIN -- Extra BEGIN/END so handle can be referred to in EXITS clause    g.busy ¬ TRUE;    SetCommandSW[executing];    IF g.formatFloppy.b THEN      Format[        !        Floppy.Error => {          Write[both, "\nFloppy.Error="L, floppyErrors[error]]; GOTO Skip};        Error => {Write[both, s1, s2]; GOTO Skip}];    IF g.reserveLastCylinder.b THEN      ReserveLastCylinderForDiagnostics[        !        Floppy.Error => {          Write[both, "\nFloppy.Error="L, floppyErrors[error]]; GOTO Skip};        Error => {Write[both, s1, s2]; GOTO Skip}];    IF g.makeBoot.b THEN      MakeBootableFloppy[        !        Floppy.Error => {          Write[both, "\nFloppy.Error="L, floppyErrors[error]]; GOTO Skip};        Error => {Write[both, s1, s2]; GOTO Skip};        NoFile => {Write[both, s, " not found"L]; GOTO Skip}];    SetCommandSW[waiting];    g.busy ¬ FALSE;    Event.DoneWithProcess[handle];    EXITS Skip => {      UserTerminal.BlinkDisplay[];       SetCommandSW[waiting];      g.busy ¬ FALSE;       Event.DoneWithProcess[handle]}    END;    END;  SetCommandSW: PROCEDURE [newState: {executing, waiting}] =    BEGIN    item: FormSW.ItemHandle;    SELECT newState FROM      executing => {        FOR i: CARDINAL ¬ 0, i + 1 UNTIL (item ¬ FormSW.FindItem[g.commandSW, i]) =          NIL DO item.flags.invisible ¬ TRUE ENDLOOP;        FormSW.Display[g.commandSW]};      waiting => {        FOR i: CARDINAL ¬ 0, i + 1 UNTIL (item ¬ FormSW.FindItem[g.commandSW, i]) =          NIL DO item.flags.invisible ¬ FALSE ENDLOOP;        [] ¬ UserInput.CreatePeriodicNotify[          proc: FormSWDisplay, window: g.commandSW, rate: 0]};      ENDCASE;    END;  FormSWDisplay: UserInput.PeriodicProcType = {FormSW.Display[window]};  ClientTransition: ToolWindow.TransitionProcType    --[window: ToolWindow.Handle, old, new: ToolWindow.State]--  =    BEGIN    SELECT TRUE FROM      old = inactive =>        IF g = NIL THEN {          drive: FloppyChannel.Drive ¬ FloppyChannel.nullDrive;          g ¬ z.NEW[Global ¬ []];          g.strings[initUCode] ¬	    String.CopyToNewString["FloppyInitialDove.db"L, z];          g.strings[germ] ¬	    String.CopyToNewString["DiskDove.germ"L, z];          g.strings[pilotUCode] ¬	    String.CopyToNewString["MesaDoveCnfigOnly.db"L, z];          g.strings[boot] ¬	    String.CopyToNewString["OthelloDove.boot"L, z];          g.strings[diagUCodeDaybreak] ¬	    String.CopyToNewString["Moonrise.db"L, z];          «g.strings[diagUCodeDaisy] ¬	    String.CopyToNewString["MoonDaisy.db"L, z];»          UNTIL (drive ¬ FloppyChannel.GetNextDrive[drive]) =	      FloppyChannel.nullDrive DO            IF drive = g.driveIndex THEN	      {attrib: FloppyChannel.Attributes ¬	        FloppyChannel.GetDeviceAttributes[		  FloppyChannel.GetHandle[drive]];	       g.numberOfCylinders ¬ attrib.numberOfCylinders;	       g.deviceType ¬ attrib.deviceType;	       EXIT}            ENDLOOP};      new = inactive => {        Supervisor.RemoveDependency[client: agent, implementor: Event.toolWindow];        IF g # NIL THEN {          FOR i: StringName IN StringName DO z.FREE[@g.strings[i]]; ENDLOOP;          z.FREE[@g]}};      ENDCASE    END;  Write: PROCEDURE [which: {fileOnly, msgOnly, both}, s1, s2, s3: LONG STRING ¬ NIL] =    BEGIN    Do: PROCEDURE [sw: Window.Handle, s: LONG STRING] = INLINE {      IF s # NIL THEN Put.Text[sw, s]};    IF which # msgOnly THEN {      Do[g.fileSW, s1]; Do[g.fileSW, s2]; Do[g.fileSW, s3]};    IF (which = both) OR (which = msgOnly) THEN {      Do[g.msgSW, s1]; Do[g.msgSW, s2]; Do[g.msgSW, s3]};    END;  Init[];  END.  LOG-- JoM and ET	30-Jul-85 10:05:50	Created file from FBStompTool.-- CJS	 2-Oct-85 20:47:17 Adjusted size of reserve in ReserveLastCylinderForDiagnostics.-- RSV  23-Dec-85 12:12:47 Changed "Floppy.GetFileAttributes[flopFile].size < fileSize ..." to "Floppy.GetFileAttributes[flopFile].size # fileSize ..." in procedure InstallFile (AR 8556).  Changed parameter of Floppy.Open in ReserveLastCylinderOnOneSide from 0 to g.driveIndex.  Moved writing "Making bootable floppy" message before trying to open the drive.  Changed zeroing entry for files in sector nine page to just zeroing first page of the file being installed.  Finally, made tool run in background.-- CAJ	12-Feb-87  8:39:22	Added capability of dealing with two kinds of diagnostic microcode.  Added explanation of relationship between booting root page, file system root page, and microcode depencencies on them. Added support for 1.2M floppies.  Reduced format arg maxFiles for non-1.2M case.  Use device code-related constant in diag data.  Changed default filenames to more commonly used ones.-- RSV  29-Feb-88  9:59:38      Defaults should no longer include MoonDaisy.db.
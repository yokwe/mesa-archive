-- Copyright (C) 1984, 1985, 1986, 1987, 1988  by Xerox Corporation. All rights reserved. -- DiskEditMarkerPageSW.mesa    7-Mar-88  9:30:39 by CAJ  DIRECTORY  Boot USING [BootFileType],  DiskEditInternal USING [dataPtr, dataWindowKey, ReplaceUIDString, ValidateUID],  Heap USING [systemZone],  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, CommandItem,    DisplayItem, Enumerated, EnumeratedItem, EnumeratedNotifyProcType,    FilterProcType, ItemHandle, LabelItem, LongNumberItem, newLine, nextLine,    nextPlace, NumberItem, NumberNotifyProcType, ProcType, StringEditProc,    StringItem],  LogicalVolumeFormat USING [    LSMCurrentVersion, LSMSeal, maxLogicalVolumeLabelLength],  PhysicalVolumeFormat USING [SubVolumeFill1, SubVolumeMarkerPage],  PilotDisk USING [FileID, FilePageNumber, nullFileID],  String USING [FreeString, Replace],  System USING [UniversalID],  UserTerminal USING [BlinkDisplay],  Volume USING [PageNumber, Type],  WindowSwap USING [RegisterView];DiskEditMarkerPageSW: PROGRAM  IMPORTS DiskEditInternal, FormSW, Heap, String, UserTerminal, WindowSwap  SHARES Boot =  BEGIN  FormItems: TYPE = {    begin, title, logicalTitle, seal, version, labelLength, labelString, type,    bootfile, bootfileID, bootfileFirstPage, daTag, daCyl, daHead, daSector,    rootfile, rootfileID, primaryETable, copyETable, statusPrimary, statusCopy,    fill1, index, value, next, back};  MarkerPageLogical: TYPE = MACHINE DEPENDENT RECORD [      labelString(0): LONG STRING ¬ NIL,      labelLength(2): CARDINAL ¬ 0,      type(3:0..15): Volume.Type ¬ normal,      rootDirectoryIDString(4): LONG STRING ¬ NIL,      pad(6:0..15): [0..256) ¬ 0,      currentBootingInfoFileType(7:0..15): Boot.BootFileType ¬ pilot,      currentBootingInfoFileIDString(8): LONG STRING ¬ NIL,      currentBootingInfoFileID(10): PilotDisk.FileID ¬ PilotDisk.nullFileID,      currentBootingInfoFirstPage(15): PilotDisk.FilePageNumber ¬ 0,      currentBootingInfoCyl(17): WORD ¬ 0,      currentBootingInfoHead(18:0..15): [0..256) ¬ 0,      currentBootingInfoSector(19:0..15): [0..256) ¬ 0,      primaryETableStart(20): Volume.PageNumber ¬ 0,      copyETableStart(22): Volume.PageNumber ¬ 0,      statusPrimaryETable(24:0..15): [0..256) ¬ 0,      statusCopyETable(25:0..15): [0..256) ¬ 0      ];  markerPage: RECORD [    logical: MarkerPageLogical,    fill1Index: CARDINAL ¬ FIRST[PhysicalVolumeFormat.SubVolumeFill1],    fill1CurrentValue: WORD ¬ 0];  mp: LONG POINTER TO PhysicalVolumeFormat.SubVolumeMarkerPage =    LOOPHOLE[DiskEditInternal.dataPtr];  CleanupMarkerPageSW: PROCEDURE =    BEGIN    mp.logical.type ¬ markerPage.logical.type;    mp.logical.labelLength ¬ markerPage.logical.labelLength;    mp.logical.bootingInfo[markerPage.logical.currentBootingInfoFileType] ¬      [fID: markerPage.logical.currentBootingInfoFileID,       firstPage: markerPage.logical.currentBootingInfoFirstPage,       da: [cylinder: markerPage.logical.currentBootingInfoCyl,         head: markerPage.logical.currentBootingInfoHead,	 sector: markerPage.logical.currentBootingInfoSector]];    mp.logical.pad ¬ markerPage.logical.pad;    mp.logical.primaryETableStartPage ¬ markerPage.logical.primaryETableStart;    mp.logical.copyETableStartPage ¬ markerPage.logical.copyETableStart;    mp.logical.statusPrimaryETableFile ¬ markerPage.logical.statusPrimaryETable;    mp.logical.statusCopyETableFile ¬ markerPage.logical.statusCopyETable;    END;  CopyLVLabel: FormSW.FilterProcType =    BEGIN    FormSW.StringEditProc[sw, item, insert, string];    FOR i: CARDINAL IN      [0..MIN[         LogicalVolumeFormat.maxLogicalVolumeLabelLength,         markerPage.logical.labelString.length]) DO      mp.logical.label[i] ¬ markerPage.logical.labelString[i]; ENDLOOP;    END;  DestroyMarkerPageSW: PROCEDURE =    BEGIN    -- Clean up resources for view going away for good.    String.FreeString[z: Heap.systemZone, s: markerPage.logical.labelString];    markerPage.logical.labelString ¬ NIL;    String.FreeString[      z: Heap.systemZone, s: markerPage.logical.rootDirectoryIDString];    markerPage.logical.rootDirectoryIDString ¬ NIL;    String.FreeString[      z: Heap.systemZone, s: markerPage.logical.currentBootingInfoFileIDString];    markerPage.logical.currentBootingInfoFileIDString ¬ NIL;    END;  Fill1BackCommand: FormSW.ProcType =    BEGIN    mp.fill1[markerPage.fill1Index] ¬ markerPage.fill1CurrentValue;    markerPage.fill1Index ¬      IF markerPage.fill1Index = FIRST[PhysicalVolumeFormat.SubVolumeFill1]        THEN LAST[PhysicalVolumeFormat.SubVolumeFill1]        ELSE markerPage.fill1Index - 1;    markerPage.fill1CurrentValue ¬ mp.fill1[markerPage.fill1Index];    FormSW.DisplayItem[sw, FormItems.index.ORD];    FormSW.DisplayItem[sw, FormItems.value.ORD];    END;  Fill1NextCommand: FormSW.ProcType =    BEGIN    mp.fill1[markerPage.fill1Index] ¬ markerPage.fill1CurrentValue;    markerPage.fill1Index ¬      IF markerPage.fill1Index = LAST[PhysicalVolumeFormat.SubVolumeFill1]        THEN FIRST[PhysicalVolumeFormat.SubVolumeFill1]        ELSE markerPage.fill1Index + 1;    markerPage.fill1CurrentValue ¬ mp.fill1[markerPage.fill1Index];    FormSW.DisplayItem[sw, FormItems.index.ORD];    FormSW.DisplayItem[sw, FormItems.value.ORD];    END;  FillMarkerPageSW: PROCEDURE =    BEGIN    longFileID: volumeRelative PilotDisk.FileID;    ReplaceLabelString[      @markerPage.logical.labelString, DESCRIPTOR[      @mp.logical.label, MIN[LogicalVolumeFormat.maxLogicalVolumeLabelLength,        mp.logical.labelLength]]];    markerPage.logical.labelLength ¬ mp.logical.labelLength;    markerPage.logical.type ¬ mp.logical.type;    longFileID.fileID ¬ mp.logical.volumeRootDirectory;    DiskEditInternal.ReplaceUIDString[      @markerPage.logical.rootDirectoryIDString,      LOOPHOLE[longFileID, System.UniversalID]];    markerPage.logical.pad ¬ mp.logical.pad;    DiskEditInternal.ReplaceUIDString[      @markerPage.logical.currentBootingInfoFileIDString,      LOOPHOLE[mp.logical.bootingInfo[        markerPage.logical.currentBootingInfoFileType].fID, System.UniversalID]];    markerPage.logical.currentBootingInfoFileID ¬      mp.logical.bootingInfo[markerPage.logical.currentBootingInfoFileType].fID;    markerPage.logical.currentBootingInfoFirstPage ¬ mp.logical.bootingInfo[      markerPage.logical.currentBootingInfoFileType].firstPage;    markerPage.logical.currentBootingInfoCyl ¬ mp.logical.bootingInfo[      markerPage.logical.currentBootingInfoFileType].da.cylinder;    markerPage.logical.currentBootingInfoHead ¬ mp.logical.bootingInfo[      markerPage.logical.currentBootingInfoFileType].da.head;    markerPage.logical.currentBootingInfoSector ¬ mp.logical.bootingInfo[      markerPage.logical.currentBootingInfoFileType].da.sector;    markerPage.logical.primaryETableStart ¬ mp.logical.primaryETableStartPage;    markerPage.logical.copyETableStart ¬ mp.logical.copyETableStartPage;    markerPage.logical.statusPrimaryETable ¬ mp.logical.statusPrimaryETableFile;    markerPage.logical.statusCopyETable ¬ mp.logical.statusCopyETableFile;    markerPage.fill1CurrentValue ¬ mp.fill1[markerPage.fill1Index];    END;  MakeMarkerPageSW: FormSW.ClientItemsProcType =    BEGIN    fill1: BOOLEAN = (LAST[PhysicalVolumeFormat.SubVolumeFill1] -      FIRST[PhysicalVolumeFormat.SubVolumeFill1]) ~= 0;    nItems: CARDINAL ¬ 21 + (IF fill1 THEN 5 ELSE 0);    items ¬ FormSW.AllocateItemDescriptor[nItems];    items[FormItems.begin.ORD] ¬ FormSW.LabelItem[      tag: NIL, invisible: TRUE, place: FormSW.newLine];    items[FormItems.title.ORD] ¬ FormSW.LabelItem[      tag: "Marker Page"L, place: FormSW.newLine];    items[FormItems.logicalTitle.ORD] ¬ FormSW.LabelItem[      tag: "Logical Subvolume Marker"L, place: FormSW.newLine];    items[FormItems.seal.ORD] ¬ FormSW.NumberItem[      tag: "Seal"L, signed: FALSE, notNegative: TRUE, radix: octal,      default: LogicalVolumeFormat.LSMSeal, value: @mp.logical.seal,      place: [15, FormSW.nextLine]];    items[FormItems.version.ORD] ¬ FormSW.NumberItem[      tag: "Version"L, signed: FALSE, notNegative: TRUE, radix: octal,      default: LogicalVolumeFormat.LSMCurrentVersion, value: @mp.logical.version,      place: FormSW.nextPlace];    items[FormItems.labelLength.ORD] ¬ FormSW.NumberItem[      tag: "Label length"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, value: @markerPage.logical.labelLength,      proc: ValidateLVLabelLength, place: [15, FormSW.nextLine]];    items[FormItems.labelString.ORD] ¬ FormSW.StringItem[      tag: "Label"L, inHeap: FALSE, string: @markerPage.logical.labelString,      filterProc: CopyLVLabel, place: FormSW.nextPlace];    BEGIN    enumeratedLVTypeArray: ARRAY [0..4) OF FormSW.Enumerated ¬ [      [string: "normal"L, value: Volume.Type[normal]], [      string: "debugger"L, value: Volume.Type[debugger]], [      string: "debuggerDebugger"L, value: Volume.Type[debuggerDebugger]], [      string: "nonPilot"L, value: Volume.Type[nonPilot]]];    items[FormItems.type.ORD] ¬ FormSW.EnumeratedItem[      tag: "Type"L, feedback: one, copyChoices: TRUE,      value: @markerPage.logical.type, choices: DESCRIPTOR[enumeratedLVTypeArray],      place: [15, FormSW.nextLine]];    END;    BEGIN    enumeratedLVBootFiles: ARRAY [0..6) OF FormSW.Enumerated ¬ [      [string: "hardMicrocode"L, value: Boot.BootFileType[hardMicrocode]], [      string: "softMicrocode"L, value: Boot.BootFileType[softMicrocode]], [      string: "germ"L, value: Boot.BootFileType[germ]], [      string: "pilot"L, value: Boot.BootFileType[pilot]], [      string: "debugger"L, value: Boot.BootFileType[debugger]], [      string: "debuggee"L, value: Boot.BootFileType[debuggee]]];    items[FormItems.bootfile.ORD] ¬ FormSW.EnumeratedItem[      tag: "Boot file for type"L, feedback: one, copyChoices: TRUE,      value: @markerPage.logical.currentBootingInfoFileType,      proc: NoticeNewLVBootFileType, choices: DESCRIPTOR[enumeratedLVBootFiles],      place: [15, FormSW.nextLine]];    items[FormItems.bootfileID.ORD] ¬ FormSW.StringItem[      tag: "ID"L, inHeap: FALSE,      string: @markerPage.logical.currentBootingInfoFileIDString,      filterProc: ValidateLVBootFileID, place: FormSW.nextPlace];    items[FormItems.bootfileFirstPage.ORD] ¬ FormSW.LongNumberItem[      tag: "First page"L, notNegative: TRUE, signed: FALSE, default: 0,      radix: decimal,      value: @markerPage.logical.currentBootingInfoFirstPage,      place: [26, FormSW.nextLine]];    items[FormItems.daTag.ORD] ¬ FormSW.LabelItem[      tag: "Disk address"L, place: [26, FormSW.nextLine]];    items[FormItems.daCyl.ORD] ¬ FormSW.NumberItem[      tag: "a"L, notNegative: TRUE, signed: FALSE, default: 0, radix: octal,      value: @markerPage.logical.currentBootingInfoCyl, place: FormSW.nextPlace];    items[FormItems.daHead.ORD] ¬ FormSW.NumberItem[      tag: "b"L, notNegative: TRUE, signed: FALSE, default: 0, radix: octal,      value: @markerPage.logical.currentBootingInfoHead, place: FormSW.nextPlace];    items[FormItems.daSector.ORD] ¬ FormSW.NumberItem[      tag: "c"L, notNegative: TRUE, signed: FALSE, default: 0, radix: octal,      value: @markerPage.logical.currentBootingInfoSector,      place: FormSW.nextPlace];    END;    items[FormItems.rootfile.ORD] ¬ FormSW.LabelItem[      tag: "Client root file"L, place: [15, FormSW.nextLine]];    items[FormItems.rootfileID.ORD] ¬ FormSW.StringItem[      tag: "ID"L, inHeap: FALSE,      string: @markerPage.logical.rootDirectoryIDString,      filterProc: ValidateVolumeRootDirectoryID, place: FormSW.nextPlace];    items[FormItems.primaryETable.ORD] ¬ FormSW.LongNumberItem[      tag: "Primary ETable start"L, signed: FALSE, notNegative: TRUE,      radix: decimal, default: 0, value: @markerPage.logical.primaryETableStart,      place: [15, FormSW.nextLine]];    items[FormItems.copyETable.ORD] ¬ FormSW.LongNumberItem[      tag: "Copy ETable start"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, value: @markerPage.logical.copyETableStart,      place: FormSW.nextPlace];    items[FormItems.statusPrimary.ORD] ¬ FormSW.NumberItem[      tag: "StatusPrimaryETableFile"L, signed: FALSE, notNegative: TRUE,      radix: octal, default: 0, value: @markerPage.logical.statusPrimaryETable,      proc: ValidatePrimaryStatus, place: [15, FormSW.nextLine]];    items[FormItems.statusCopy.ORD] ¬ FormSW.NumberItem[      tag: "StatusCopyETableFile"L, signed: FALSE, notNegative: TRUE,      radix: octal, default: 0, value: @markerPage.logical.statusCopyETable,      proc: ValidateCopyStatus, place: FormSW.nextPlace];    IF fill1 THEN      BEGIN      items[FormItems.fill1.ORD] ¬ FormSW.LabelItem[        tag: "MarkerPage Fill1"L, place: FormSW.newLine];      items[FormItems.index.ORD] ¬ FormSW.NumberItem[        tag: "Index"L, signed: FALSE, notNegative: TRUE, radix: decimal,        default: FIRST[PhysicalVolumeFormat.SubVolumeFill1],        proc: NoticeFill1Index,        value: @markerPage.fill1Index, place: FormSW.nextPlace];      items[FormItems.value.ORD] ¬ FormSW.NumberItem[        tag: "Value"L, signed: FALSE, notNegative: TRUE, radix: decimal,        default: 0,        value: @markerPage.fill1CurrentValue, place: FormSW.nextPlace];      items[FormItems.next.ORD] ¬ FormSW.CommandItem[        tag: "Next"L, proc: Fill1NextCommand, place: FormSW.nextPlace];      items[FormItems.back.ORD] ¬ FormSW.CommandItem[        tag: "Back"L, proc: Fill1BackCommand, place: FormSW.nextPlace];      END;    RETURN[items, TRUE]    END;  NoticeFill1Index: FormSW.NumberNotifyProcType =    BEGIN    IF markerPage.fill1Index ~IN [FIRST[PhysicalVolumeFormat.SubVolumeFill1]        ..LAST[PhysicalVolumeFormat.SubVolumeFill1]] THEN      BEGIN UserTerminal.BlinkDisplay[]; RETURN; END;    mp.fill1[oldValue] ¬ markerPage.fill1CurrentValue;    markerPage.fill1CurrentValue ¬ mp.fill1[markerPage.fill1Index];    FormSW.DisplayItem[sw, FormItems.value.ORD];    END;  NoticeNewLVBootFileType: FormSW.EnumeratedNotifyProcType =    BEGIN    mp.logical.bootingInfo[oldValue] ¬      [fID: markerPage.logical.currentBootingInfoFileID,       firstPage: markerPage.logical.currentBootingInfoFirstPage,       da: [cylinder: markerPage.logical.currentBootingInfoCyl,         head: markerPage.logical.currentBootingInfoHead,	 sector: markerPage.logical.currentBootingInfoSector]];    DiskEditInternal.ReplaceUIDString[      @markerPage.logical.currentBootingInfoFileIDString,        LOOPHOLE[mp.logical.bootingInfo[        markerPage.logical.currentBootingInfoFileType].fID, System.UniversalID]];    markerPage.logical.currentBootingInfoFileID ¬      mp.logical.bootingInfo[markerPage.logical.currentBootingInfoFileType].fID;    markerPage.logical.currentBootingInfoFirstPage ¬ mp.logical.bootingInfo[      markerPage.logical.currentBootingInfoFileType].firstPage;    markerPage.logical.currentBootingInfoCyl ¬ mp.logical.bootingInfo[      markerPage.logical.currentBootingInfoFileType].da.cylinder;    markerPage.logical.currentBootingInfoHead ¬ mp.logical.bootingInfo[      markerPage.logical.currentBootingInfoFileType].da.head;    markerPage.logical.currentBootingInfoSector ¬ mp.logical.bootingInfo[      markerPage.logical.currentBootingInfoFileType].da.sector;    FormSW.DisplayItem[sw, FormItems.bootfileID.ORD];    FormSW.DisplayItem[sw, FormItems.bootfileFirstPage.ORD];    FormSW.DisplayItem[sw, FormItems.daCyl.ORD];    FormSW.DisplayItem[sw, FormItems.daHead.ORD];    FormSW.DisplayItem[sw, FormItems.daSector.ORD];    END;  ReplaceLabelString: PROCEDURE [    label: LONG POINTER TO LONG STRING,    s: LONG DESCRIPTOR FOR PACKED ARRAY OF CHARACTER] =    BEGIN    volumeLabel: STRING ¬ [LogicalVolumeFormat.maxLogicalVolumeLabelLength];    volumeLabel.length ¬ 0;    FOR i: CARDINAL IN        [0..MIN[LogicalVolumeFormat.maxLogicalVolumeLabelLength,  LENGTH[s]]) DO      volumeLabel[i] ¬ s[i];      volumeLabel.length ¬ volumeLabel.length + 1;      ENDLOOP;    String.Replace[label, volumeLabel, Heap.systemZone];    END;  ValidateCopyStatus: FormSW.NumberNotifyProcType =    BEGIN    IF markerPage.logical.statusCopyETable ~IN [0..256) THEN      BEGIN      UserTerminal.BlinkDisplay[];      markerPage.logical.statusCopyETable ¬ oldValue;      FormSW.DisplayItem[sw, index];      END;    END;  ValidateVolumeRootDirectoryID: FormSW.FilterProcType =    BEGIN    valid: BOOLEAN;    id: System.UniversalID;    FormSW.StringEditProc[sw, item, insert, string];    [valid, id] ¬ DiskEditInternal.ValidateUID[      markerPage.logical.rootDirectoryIDString];    IF ~valid THEN UserTerminal.BlinkDisplay[]    ELSE {      arrayID: ARRAY [0..5) OF WORD ¬ LOOPHOLE[id];      fileID: ARRAY [0..2) OF WORD ¬ [arrayID[0], arrayID[1]];      mp.logical.volumeRootDirectory ¬ LOOPHOLE[fileID] };    END;  ValidateLVBootFileID: FormSW.FilterProcType =    BEGIN    valid: BOOLEAN;    id: System.UniversalID;    FormSW.StringEditProc[sw, item, insert, string];    [valid, id] ¬ DiskEditInternal.ValidateUID[      markerPage.logical.currentBootingInfoFileIDString];    IF ~valid THEN UserTerminal.BlinkDisplay[]    ELSE markerPage.logical.currentBootingInfoFileID ¬ LOOPHOLE[id];    END;  ValidateLVLabelLength: FormSW.NumberNotifyProcType =    BEGIN    IF markerPage.logical.labelLength ~IN [0..64) THEN      UserTerminal.BlinkDisplay[];    END;  ValidatePrimaryStatus: FormSW.NumberNotifyProcType =    BEGIN    IF markerPage.logical.statusPrimaryETable ~IN [0..256) THEN      BEGIN      UserTerminal.BlinkDisplay[];      markerPage.logical.statusPrimaryETable ¬ oldValue;      FormSW.DisplayItem[sw, index];      END;    END;  -- Module initialization:  -- Register this subwindow as an alternate view for the data subwindow  WindowSwap.RegisterView[    key: DiskEditInternal.dataWindowKey,    viewName: "Marker page"L,    makeFormSW: MakeMarkerPageSW,    viewFromDataProc: FillMarkerPageSW,    dataFromViewProc: CleanupMarkerPageSW,    destroyViewProc: DestroyMarkerPageSW];  END.LOG17-Sep-81 11:01:01   WDK       Converted to new MarkerPage format and CommonSoftware 8.0.18-Nov-81 14:15:58   CAJ    LOOPHOLE'd Boot.DiskAddress pending upgrade to proper exported type.27-Apr-83 14:15:06   EKN        Update to Klamath29-Nov-83 17:02:09	EKN   	Changed items: markerPage.logical.labelLength, markerPage.logical.currentBootingInfoDiskFileID.firstPage, markerPage.physical.labelLength, mp.physical.maxBadPages, markerPage.physical.fill, markerPage.physical.svNumber, mp.physical.descriptor.lvSize, mp.physical.descriptor.nPages, mp.physical.descriptor.lvPage, mp.physical.descriptor.pvPage, markerPage.physical.currentBootingInfoDiskFileID.firstPage, mp.checksum, markerPage.fill1Index, markerPage.fill1CurrentValue, markerPage.fill2Index, markerPage.fill2CurrentValue  to display as decimals instead of octals. 5-Sep-84 14:02:31   CAJ    Add registering window view via WindowSwap.20-Nov-85 15:41:14   RSV    Fixed printing label string in ReplaceLabelString (AR 5599)30-Sep-86 13:51:48   CAJ    Modify for changes in Logical and Physical SubvolumeMarker format for 13.0.  Display Bootfile disk addresses as 3 values instead of 2.  Set uninitialized indices for PV bootfiles. 2-Jul-87 20:25:14   CAJ    Rip out PV submarkers. 7-Mar-88  9:30:32   CAJ    Add DestroyMarkerPageSW, form index cleanup, inHeap's ¬ FALSE.
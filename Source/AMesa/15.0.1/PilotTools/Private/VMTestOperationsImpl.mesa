-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- VMTestOperationsImpl.mesa      25-Apr-83 17:38:46 by CAJ -- Virtual memory test program.-- Each operation in VMTest invokes parallel operations on both Pilot's-- VM management and VMTest's own model of VM.  In addition, VMTest's own-- BackingStore sits under (Pilot) VM to check transfer requests.  Each-- operation involves the following steps:--   + generate expected results--   + do the Pilot version of the operation--   + update the model VM--   + check the model against Pilot.-- These operation routines are called from the test script.DIRECTORY  BackingStore USING [Operation, Run, TransferProc],  Environment USING [PageCount, PageNumber],  SigsetDefs USING [Aqsigset, Sig, Sigset],  Space USING [Access, Class, defaultSwapUnitOption, Life, SwapUnitOption,    unknownUsage, Usage],  String USING [AppendChar, AppendLongDecimal, AppendString],  TryDefs USING [TryP],  VM USING [    Activate, BackingStoreRuns, CopyIn, CopyOut, Deactivate, ForceOut,    GetMapUnitAttributes, GetSwapUnitAttributes, Interval, Kill,    MakeReadOnly, MakeResident, MakeSwappable, MakeWritable, Map,    nullBackingStoreRuns, nullInterval, Relocate, ReturnWait, SupplyBackingStore,    Swappability, Unmap, Wait],  VMTestApplyToModel USING [    Activate, Deactivate, CopyIn, CopyOut, ForceOut, Kill, MakeReadOnly,    MakeResident, MakeSwappable, MakeWritable, Relocate, Unmap],  VMTestBackingStore USING [BSTransfer, InitializeBackingData, MakeBackingData,    ReturnBackingData, Touch],  VMTestCheck USING [    Activate, CopyIn, CopyOut, Deactivate, ForceOut, GetMapUnitAttributes,    GetSwapUnitAttributes, Kill, MakeReadonly, MakeResident, MakeSwappable,    MakeWritable, Map, Relocate, SupplyBackingStore, Unmap],  VMTestDatabase USING [    CheckAndAcquireInterval, ClearActivating, ClearCopyingIn,    ClearCopyingOut, ClearDeactivating, ClearForcingOut, CreateMapUnit,    DestroyMapUnit, GetMapUnit,  GetPageAttributes, MapUnit, MarkActivating,    MarkCopyingIn, MarkCopyingOut, MarkDeactivating, MarkForcingOut,    ReleaseInterval, SetAlternateRun, UserToVMPage, VerifyMapState, VMInterval],  VMTestExpectations USING [    Activate, CopyIn, CopyOut, Deactivate, ForceOut, GetMapUnitAttributes,    GetSwapUnitAttributes, Kill, MakeReadOnly, MakeResident, MakeSwappable,    MakeWritable, Map, Relocate, SupplyBackingStore, Unmap],  VMTestOperations,  VMTestSpace USING [GetSpace, ReturnSpace];VMTestOperationsImpl: PROGRAM  IMPORTS String, TryDefs, VM, VMTestApplyToModel,    VMTestBackingStore, VMTestCheck, VMTestDatabase, VMTestExpectations,    VMTestSpace  EXPORTS VMTestOperations =  BEGIN  ------------  -- PUBLIC SIGNALs and ERRORs:  CannotTouch: PUBLIC SIGNAL = CODE;  CannotWrite: PUBLIC SIGNAL = CODE;  ------------  -- GLOBAL types, constants, variables:  StandardArray: TYPE = ARRAY [0..0) OF WORD;  MapUnitAttributes: TYPE = RECORD [    mapUnit: VM.Interval,    transferProc: BackingStore.TransferProc,    backingStoreRuns: VM.BackingStoreRuns,    usage: Space.Usage,    class: Space.Class,    swapUnits: Space.SwapUnitOption];  ------------  -- PUBLIC procedures - VM Operations:  Activate: PUBLIC PROCEDURE [interval: VM.Interval, returnWait: VM.ReturnWait] =    BEGIN    actual: SigsetDefs.Sig;    aqsigset: SigsetDefs.Aqsigset;    expect: SigsetDefs.Sigset = @aqsigset;    intervalID: STRING = [40];    vmInterval: VM.Interval = VMTestDatabase.VMInterval[interval];    PilotActivate: PROCEDURE = {VM.Activate[vmInterval, returnWait]};    VMTestDatabase.CheckAndAcquireInterval[vmInterval];    VMTestDatabase.MarkActivating[vmInterval];    VMTestExpectations.Activate[vmInterval, expect];    StringFromInterval[intervalID, vmInterval];    actual ¬ TryDefs.TryP[PilotActivate, expect, "Activate"L, intervalID];    IF actual = none THEN      BEGIN      IF returnWait = return THEN VM.Wait[vmInterval];      VMTestApplyToModel.Activate[vmInterval];      VMTestCheck.Activate[vmInterval];      END    ELSE VMTestDatabase.ClearActivating[vmInterval];    VMTestDatabase.ReleaseInterval[vmInterval];    END;  CopyIn: PUBLIC PROCEDURE [    interval: VM.Interval, runLength: Environment.PageCount,    returnWait: VM.ReturnWait] =    BEGIN    actual: SigsetDefs.Sig;    aqsigset: SigsetDefs.Aqsigset;    expect: SigsetDefs.Sigset = @aqsigset;    intervalID: STRING = [40];    run: VM.BackingStoreRuns;    testTransferProc: BackingStore.TransferProc = VMTestBackingStore.BSTransfer;    vmInterval: VM.Interval = VMTestDatabase.VMInterval[interval];    PilotCopyIn: PROCEDURE = {      VM.CopyIn[vmInterval, testTransferProc, run[0], returnWait]};    VMTestDatabase.CheckAndAcquireInterval[vmInterval];    VMTestDatabase.MarkCopyingIn[vmInterval];    run ¬ VMTestBackingStore.MakeBackingData[DESCRIPTOR[@runLength, 1]];    VMTestBackingStore.InitializeBackingData[run, vmInterval.page, copyIn];    VMTestDatabase.SetAlternateRun[vmInterval, @run[0]];    VMTestExpectations.CopyIn[vmInterval, run[0], expect];    StringFromInterval[intervalID, vmInterval];    actual ¬ TryDefs.TryP[PilotCopyIn, expect, "CopyIn"L, intervalID];    IF actual = none THEN      BEGIN      IF returnWait = return THEN VM.Wait[vmInterval];      -- Someday we will do something more sophisticated than wait.      -- Handling true asynchrony is a hard problem.      VMTestApplyToModel.CopyIn[vmInterval, run[0]];      VMTestCheck.CopyIn[vmInterval, run[0]];      END    ELSE VMTestDatabase.ClearCopyingIn[vmInterval];    VMTestDatabase.SetAlternateRun[vmInterval, NIL];    VMTestBackingStore.ReturnBackingData[run];    VMTestDatabase.ReleaseInterval[vmInterval];    END;  CopyOut: PUBLIC PROCEDURE [    interval: VM.Interval, runLength: Environment.PageCount,    returnWait: VM.ReturnWait] =    BEGIN    actual: SigsetDefs.Sig;    aqsigset: SigsetDefs.Aqsigset;    expect: SigsetDefs.Sigset = @aqsigset;    intervalID: STRING = [40];    run: VM.BackingStoreRuns;    testTransferProc: BackingStore.TransferProc = VMTestBackingStore.BSTransfer;    vmInterval: VM.Interval = VMTestDatabase.VMInterval[interval];    PilotCopyOut: PROCEDURE = {      VM.CopyOut[vmInterval, testTransferProc, run[0], returnWait]};    VMTestDatabase.CheckAndAcquireInterval[vmInterval];    VMTestDatabase.MarkCopyingOut[vmInterval];    run ¬ VMTestBackingStore.MakeBackingData[DESCRIPTOR[@runLength, 1]];    VMTestBackingStore.InitializeBackingData[run, vmInterval.page, copyOut];    VMTestDatabase.SetAlternateRun[vmInterval, @run[0]];    VMTestExpectations.CopyOut[vmInterval, run[0], expect];    StringFromInterval[intervalID, vmInterval];    actual ¬ TryDefs.TryP[PilotCopyOut, expect, "CopyOut"L, intervalID];    IF actual = none THEN      BEGIN      IF returnWait = return THEN  VM.Wait[vmInterval];      -- Someday we will do something more sophisticated than wait.      -- Handling true asynchrony is a hard problem.      VMTestApplyToModel.CopyOut[vmInterval, run[0]];      VMTestCheck.CopyOut[vmInterval, run[0]];      END    ELSE VMTestDatabase.ClearCopyingOut[vmInterval];    VMTestDatabase.SetAlternateRun[vmInterval, NIL];    VMTestBackingStore.ReturnBackingData[run];    VMTestDatabase.ReleaseInterval[vmInterval];    END;  Deactivate: PUBLIC PROCEDURE [    interval: VM.Interval, returnWait: VM.ReturnWait] =    BEGIN    actual: SigsetDefs.Sig;    aqsigset: SigsetDefs.Aqsigset;    expect: SigsetDefs.Sigset = @aqsigset;    intervalID: STRING = [40];    vmInterval: VM.Interval = VMTestDatabase.VMInterval[interval];    PilotDeactivate: PROCEDURE = {VM.Deactivate[vmInterval, returnWait]};    VMTestDatabase.CheckAndAcquireInterval[vmInterval];    VMTestDatabase.MarkDeactivating[vmInterval];    VMTestExpectations.Deactivate[vmInterval, expect];    StringFromInterval[intervalID, vmInterval];    actual ¬ TryDefs.TryP[PilotDeactivate, expect, "Deactivate"L, intervalID];    IF actual = none THEN      BEGIN      IF returnWait = return THEN VM.Wait[vmInterval];      VMTestApplyToModel.Deactivate[vmInterval];      VMTestCheck.Deactivate[vmInterval];      END    ELSE VMTestDatabase.ClearDeactivating[vmInterval];    VMTestDatabase.ReleaseInterval[vmInterval];    END;  ForceOut: PUBLIC PROCEDURE [interval: VM.Interval, returnWait: VM.ReturnWait] =    BEGIN    actual: SigsetDefs.Sig;    aqsigset: SigsetDefs.Aqsigset;    expect: SigsetDefs.Sigset = @aqsigset;    intervalID: STRING = [40];    vmInterval: VM.Interval = VMTestDatabase.VMInterval[interval];    PilotForceOut: PROCEDURE = {VM.ForceOut[vmInterval, returnWait]};    VMTestDatabase.CheckAndAcquireInterval[vmInterval];    VMTestDatabase.MarkForcingOut[vmInterval];    VMTestExpectations.ForceOut[vmInterval, expect];    StringFromInterval[intervalID, vmInterval];    actual ¬ TryDefs.TryP[PilotForceOut, expect, "ForceOut"L, intervalID];    IF actual = none THEN      BEGIN      IF returnWait = return THEN VM.Wait[vmInterval];      VMTestApplyToModel.ForceOut[vmInterval];      VMTestCheck.ForceOut[vmInterval];      END    ELSE VMTestDatabase.ClearForcingOut[vmInterval];    VMTestDatabase.ReleaseInterval[vmInterval];    END;  GetMapUnitAttributes: PUBLIC PROCEDURE [page: Environment.PageNumber] =    BEGIN    actual: SigsetDefs.Sig;    aqsigset: SigsetDefs.Aqsigset;    expect: SigsetDefs.Sigset = @aqsigset;    intervalID: STRING = [40];    runsCount: CARDINAL;    vmPage: Environment.PageNumber;    -- result map unit attributes:    -- these have to be initialized to make compiler happy    mapUnit: VM.Interval ¬ VM.nullInterval;    transferProc: BackingStore.TransferProc ¬ NIL;    backingStoreRunsResult: VM.BackingStoreRuns ¬ VM.nullBackingStoreRuns;    usage: Space.Usage ¬ Space.unknownUsage;    class: Space.Class ¬ unknown;    swapUnits: Space.SwapUnitOption ¬ Space.defaultSwapUnitOption;    PilotGetMapUnitAttributes: PROCEDURE =      {[mapUnit, transferProc, backingStoreRunsResult, usage, class, swapUnits] ¬          VM.GetMapUnitAttributes[	    page: vmPage, backingStoreRunsStorage: backingStoreRunsResult]};    vmPage ¬ VMTestDatabase.UserToVMPage[page];    VMTestDatabase.CheckAndAcquireInterval[[vmPage, 1]];    IF VMTestDatabase.GetMapUnit[vmPage] = NIL THEN      {runsCount ¬ 0; backingStoreRunsResult ¬ NIL}    ELSE      {runsCount ¬ LENGTH[VMTestDatabase.GetMapUnit[vmPage].backingStoreRuns];      backingStoreRunsResult ¬ DESCRIPTOR[        VMTestSpace.GetSpace[runsCount * SIZE[BackingStore.Run], resident],        runsCount]};    VMTestExpectations.GetMapUnitAttributes[      vmPage, backingStoreRunsResult, expect];    StringFromInterval[intervalID, [vmPage, 1]];    actual  ¬ TryDefs.TryP[PilotGetMapUnitAttributes, expect,      "GetMapUnitAttributes"L, intervalID];    VMTestCheck.GetMapUnitAttributes[page: vmPage, mapUnit: mapUnit,      backed: transferProc ~= NIL, backingStoreRuns: backingStoreRunsResult,      usage: usage, class: class, swapUnits: swapUnits];    VMTestSpace.ReturnSpace[BASE[backingStoreRunsResult]];    VMTestDatabase.ReleaseInterval[[vmPage, 1]];    END;  GetSwapUnitAttributes: PUBLIC PROCEDURE [page: Environment.PageNumber] =    BEGIN    actual: SigsetDefs.Sig;    aqsigset: SigsetDefs.Aqsigset;    expect: SigsetDefs.Sigset = @aqsigset;    intervalID: STRING = [40];    vmPage: Environment.PageNumber = VMTestDatabase.UserToVMPage[page];    -- returned swap unit attributes    -- these have to be initialized to make compiler happy    swapUnit: VM.Interval ¬ VM.nullInterval;    access: Space.Access ¬ readOnly;  -- illegal attribute combination    life: Space.Life ¬ dead;    swappability: VM.Swappability ¬ resident;    PilotGetSwapUnitAttributes: PROCEDURE =      {[swapUnit, access, life, swappability] ¬ VM.GetSwapUnitAttributes[vmPage]};    VMTestDatabase.CheckAndAcquireInterval[[vmPage, 1]];    VMTestExpectations.GetSwapUnitAttributes[vmPage, expect];    StringFromInterval[intervalID, [vmPage, 1]];    actual ¬ TryDefs.TryP[PilotGetSwapUnitAttributes, expect,      "GetSwapUnitAttributes"L, intervalID];    VMTestCheck.GetSwapUnitAttributes[      page: vmPage, swapUnit: swapUnit, access: access, life: life,      swappability: swappability];    VMTestDatabase.ReleaseInterval[[vmPage, 1]];    END;  Kill: PUBLIC PROCEDURE [interval: VM.Interval] =    BEGIN    actual: SigsetDefs.Sig;    aqsigset: SigsetDefs.Aqsigset;    expect: SigsetDefs.Sigset = @aqsigset;    intervalID: STRING = [40];    vmInterval: VM.Interval = VMTestDatabase.VMInterval[interval];    PilotKill: PROCEDURE = {VM.Kill[vmInterval]};    VMTestDatabase.CheckAndAcquireInterval[vmInterval];    VMTestExpectations.Kill[vmInterval, expect];    StringFromInterval[intervalID, vmInterval];    actual ¬ TryDefs.TryP[PilotKill, expect, "Kill"L, intervalID];    -- No errors possible from kill, so apply and check regardless of actual.    VMTestApplyToModel.Kill[vmInterval];    VMTestCheck.Kill[vmInterval];    VMTestDatabase.ReleaseInterval[vmInterval];    END;  MakeReadOnly: PUBLIC PROCEDURE [interval: VM.Interval] =    BEGIN    actual: SigsetDefs.Sig;    aqsigset: SigsetDefs.Aqsigset;    expect: SigsetDefs.Sigset = @aqsigset;    intervalID: STRING = [40];    realInterval: VM.Interval;    vmInterval: VM.Interval = VMTestDatabase.VMInterval[interval];    PilotMakeReadOnly: PROCEDURE = {VM.MakeReadOnly[vmInterval]};    VMTestDatabase.CheckAndAcquireInterval[vmInterval];    realInterval ¬ VMTestExpectations.MakeReadOnly[vmInterval, expect];    StringFromInterval[intervalID, vmInterval];    actual ¬ TryDefs.TryP[PilotMakeReadOnly, expect, "MakeReadOnly"L, intervalID];    IF actual = none THEN      VMTestApplyToModel.MakeReadOnly[realInterval];    VMTestCheck.MakeReadonly[realInterval];    VMTestDatabase.ReleaseInterval[realInterval];    END;  MakeResident: PUBLIC PROCEDURE [    interval: VM.Interval, returnWait: VM.ReturnWait] =    BEGIN    actual: SigsetDefs.Sig;    aqsigset: SigsetDefs.Aqsigset;    expect: SigsetDefs.Sigset = @aqsigset;    intervalID: STRING = [40];    realInterval: VM.Interval;    vmInterval: VM.Interval = VMTestDatabase.VMInterval[interval];    PilotMakeResident: PROCEDURE = {      VM.MakeResident[vmInterval, returnWait]};    VMTestDatabase.CheckAndAcquireInterval[vmInterval];    realInterval ¬ VMTestExpectations.MakeResident[vmInterval, expect];    StringFromInterval[intervalID, vmInterval];    actual ¬ TryDefs.TryP[PilotMakeResident, expect, "MakeResident"L, intervalID];    IF actual = none THEN      VMTestApplyToModel.MakeResident[realInterval];    VMTestCheck.MakeResident[realInterval];    VMTestDatabase.ReleaseInterval[realInterval];    END;  MakeSwappable: PUBLIC PROCEDURE [interval: VM.Interval] =    BEGIN    actual: SigsetDefs.Sig;    aqsigset: SigsetDefs.Aqsigset;    expect: SigsetDefs.Sigset = @aqsigset;    intervalID: STRING = [40];    realInterval: VM.Interval;    vmInterval: VM.Interval = VMTestDatabase.VMInterval[interval];    PilotMakeSwappable: PROCEDURE = {VM.MakeSwappable[vmInterval]};    VMTestDatabase.CheckAndAcquireInterval[vmInterval];    realInterval ¬ VMTestExpectations.MakeSwappable[vmInterval, expect];    StringFromInterval[intervalID, vmInterval];    actual ¬ TryDefs.TryP[PilotMakeSwappable, expect, "MakeSwappable"L,      intervalID];    IF actual = none THEN      VMTestApplyToModel.MakeSwappable[realInterval];    VMTestCheck.MakeSwappable[realInterval];    VMTestDatabase.ReleaseInterval[realInterval];    END;  MakeWritable: PUBLIC PROCEDURE [interval: VM.Interval] =    BEGIN    actual: SigsetDefs.Sig;    aqsigset: SigsetDefs.Aqsigset;    expect: SigsetDefs.Sigset = @aqsigset;    intervalID: STRING = [40];    realInterval: VM.Interval;    vmInterval: VM.Interval = VMTestDatabase.VMInterval[interval];     PilotMakeWritable: PROCEDURE = {VM.MakeWritable[vmInterval]};    VMTestDatabase.CheckAndAcquireInterval[vmInterval];    realInterval ¬ VMTestExpectations.MakeWritable[vmInterval, expect];    StringFromInterval[intervalID, vmInterval];    actual ¬ TryDefs.TryP[PilotMakeWritable, expect, "MakeWritable"L, intervalID];    IF actual = none THEN      VMTestApplyToModel.MakeWritable[realInterval];    VMTestCheck.MakeWritable[realInterval];    VMTestDatabase.ReleaseInterval[realInterval];    END;  Map: PUBLIC PROCEDURE [    id: LONG STRING, interval: VM.Interval, backed: BOOLEAN,    runs: VM.BackingStoreRuns, usage: Space.Usage, class: Space.Class,    access: Space.Access, swapUnits: Space.SwapUnitOption,    life: Space.Life, swappability: VM.Swappability] =    BEGIN    actual: SigsetDefs.Sig;    aqsigset: SigsetDefs.Aqsigset;    mappedInDatabase: BOOLEAN;    mapUnit: VMTestDatabase.MapUnit ¬ NIL;    expect: SigsetDefs.Sigset = @aqsigset;    testProc: BackingStore.TransferProc =      IF backed THEN VMTestBackingStore.BSTransfer ELSE NIL;    vmInterval: VM.Interval = VMTestDatabase.VMInterval[interval];    PilotMap: PROCEDURE = {VM.Map[      vmInterval, testProc, runs, usage, class, access, swapUnits,      life, swappability]};    BEGIN --ENABLE UNWIND => VMTestDatabase.DestroyMapUnit[mapUnit];    VMTestDatabase.CheckAndAcquireInterval[vmInterval];    mapUnit ¬ VMTestDatabase.CreateMapUnit[id, vmInterval, backed, runs, usage,      class, access, swapUnits, life, swappability];    mappedInDatabase ¬ VMTestExpectations.Map[mapUnit, expect];    actual ¬ TryDefs.TryP[PilotMap, expect, "Map"L, id];    IF actual ~= none THEN      VMTestDatabase.DestroyMapUnit[mapUnit, mappedInDatabase];    IF actual ~= nonRecoverable THEN VMTestCheck.Map[vmInterval];    VMTestDatabase.ReleaseInterval[vmInterval];    END;    END;  Relocate: PUBLIC PROCEDURE [    from: Environment.PageNumber, to: Environment.PageNumber] =    BEGIN    MapUnitAttributes: TYPE = RECORD [      mapUnit: VM.Interval,      backingStore: BackingStore.TransferProc,      backingStoreRuns: VM.BackingStoreRuns,      usage: Space.Usage,      class: Space.Class,      swapUnits: Space.SwapUnitOption];    actual: SigsetDefs.Sig;    aqsigset: SigsetDefs.Aqsigset;    expect: SigsetDefs.Sigset = @aqsigset;    --fromAttributes: MapUnitAttributes;    fromVMPage: Environment.PageNumber = VMTestDatabase.UserToVMPage[from];    intervalID: STRING = [40];    toVMPage: Environment.PageNumber = VMTestDatabase.UserToVMPage[to];    PilotRelocate: PROCEDURE = {VM.Relocate[fromVMPage, toVMPage]};    -- ** This code is untried, unchecked, ...    -- watch for overlap of these two    -- VMTestDatabase.CheckAndAcquireInterval[[toVMPage, 1]];    -- VMTestDatabase.CheckAndAcquireInterval[[fromVMPage, 1]];    [--real(to?/from?)interval--] ¬      VMTestExpectations.Relocate[fromVMPage, toVMPage, expect];    StringFromInterval[intervalID, [fromVMPage, 1]];  -- ?? proper count?    actual ¬ TryDefs.TryP[PilotRelocate, expect, "Relocate"L, intervalID];    IF actual = none THEN      BEGIN      -- fromAttributes ¬ VM.GetMapUnitAttributes[fromVMPage, ?];      VMTestApplyToModel.Relocate[fromVMPage, toVMPage];      -- check GetMapUnitAttributes[toVMPage] = fromAttributes      END;    VMTestApplyToModel.Relocate[fromVMPage, toVMPage];    VMTestCheck.Relocate[fromVMPage, toVMPage];    END;  SupplyBackingStore: PUBLIC PROCEDURE [    page: Environment.PageNumber, backed: BOOLEAN,    backingStoreRuns: VM.BackingStoreRuns] =    BEGIN    actual: SigsetDefs.Sig;    aqsigset: SigsetDefs.Aqsigset;    expect: SigsetDefs.Sigset = @aqsigset;    intervalID: STRING = [40];    testProc: BackingStore.TransferProc =      IF backed THEN VMTestBackingStore.BSTransfer ELSE NIL;    realInterval: VM.Interval;    vmPage: Environment.PageNumber = VMTestDatabase.UserToVMPage[page];    PilotSupplyBackingStore: PROCEDURE = {      VM.SupplyBackingStore[page: vmPage, transferProc: testProc,        backingStoreRuns: backingStoreRuns--, swapUnits: (temp defaulted)--]};    -- ** This code is uncheck, untried, ...    -- VMTestDatabase.CheckAndAcquireInterval[[vmPage, ?]];    -- (script caller calls MakeBackingData)    realInterval ¬ VMTestExpectations.SupplyBackingStore[      page, testProc ~= NIL, backingStoreRuns, expect];    StringFromInterval[intervalID, [vmPage, 1]];  -- ?? proper interval?    actual ¬ TryDefs.TryP[      PilotSupplyBackingStore, expect, "SupplyBackingStore"L, intervalID];    VMTestCheck.SupplyBackingStore[page, backed, backingStoreRuns];    -- VMTestDatabase.ReleaseInterval[realInterval];    END;  Unmap: PUBLIC PROCEDURE [page: Environment.PageNumber] =    BEGIN    actual: SigsetDefs.Sig;    aqsigset: SigsetDefs.Aqsigset;    expect: SigsetDefs.Sigset = @aqsigset;    mapUnit: VMTestDatabase.MapUnit;    realInterval: VM.Interval;    vmPage: Environment.PageNumber = VMTestDatabase.UserToVMPage[page];    PilotUnmap: PROCEDURE = {VM.Unmap[vmPage]};    VMTestDatabase.CheckAndAcquireInterval[[vmPage, 1]];    mapUnit ¬ VMTestDatabase.GetMapUnit[vmPage];    realInterval ¬ VMTestExpectations.Unmap[[vmPage, 1], expect];    actual ¬ TryDefs.TryP[      PilotUnmap, expect, "Unmap"L, IF mapUnit ~= NIL THEN mapUnit.id ELSE NIL];    -- Are there any outcomes  besides (none) in which unmap should really occur?    IF actual = none THEN VMTestApplyToModel.Unmap[realInterval.page];    VMTestCheck.Unmap[mapUnit];    VMTestDatabase.DestroyMapUnit[mapUnit, TRUE];    VMTestDatabase.ReleaseInterval[realInterval];    END;  ------------  -- PUBLIC procedures - Other operations:  -- **** This needs some statement about why Touch is different from other  -- operations and why it doesn't follow the expectations/try/apply/check  -- model.  -- Touch causes a read or write on the specified page(s)  -- May raise CannotTouch if any page in interval is not mapped.  -- May raise CannotWrite if any page in interval is readOnly.  Touch: PUBLIC PROCEDURE [    interval: VM.Interval, operation: BackingStore.Operation] =    BEGIN    vmInterval: VM.Interval = VMTestDatabase.VMInterval[interval];    BEGIN ENABLE UNWIND => VMTestDatabase.ReleaseInterval[vmInterval];    VMTestDatabase.CheckAndAcquireInterval[vmInterval];    IF NOT VMTestDatabase.VerifyMapState[interval: vmInterval, expect: mapped]      THEN SIGNAL CannotTouch;    IF operation = write THEN      IF NOT Writable[vmInterval] THEN SIGNAL CannotWrite;    VMTestBackingStore.Touch[vmInterval, operation];    VMTestDatabase.ReleaseInterval[vmInterval];    END;    END;  ------------  -- PRIVATE procedures:  StringFromInterval: PROCEDURE[s: LONG STRING, interval: VM.Interval] =    BEGIN    s.length ¬ 0;    String.AppendString[s, "[page: "L];    String.AppendLongDecimal[s, interval.page];    String.AppendString[s, ", count: "L];    String.AppendLongDecimal[s, interval.count];    String.AppendChar[s, ']];    END;  -- Returns TRUE if all pages in interval are readWrite or if interval is null.  Writable: PROCEDURE[interval: VM.Interval] RETURNS [BOOLEAN] =    BEGIN    page: Environment.PageNumber;    FOR page IN [interval.page..interval.page + interval.count) DO      IF VMTestDatabase.GetPageAttributes[page].readonly THEN RETURN[FALSE];      ENDLOOP;    RETURN[TRUE];    END;  ------------  -- Main line code  -- None.  END.LOG18-Aug-82 14:52:18   CAJ    Created file.
-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- VMTestSpaceImpl.mesa     25-Apr-83 16:48:04 by CAJ -- Virtual memory test program.-- VMTestSpaceImpl contains assorted utilities not in the specific domain-- of any one module.DIRECTORY  Environment USING [Base, PageCount, wordsPerPage],  Heap USING [Create, Delete],  Inline USING [LowHalf],  ResidentHeap USING [first64K, FreeNode, MakeNode],  Space USING [Error, PageFromLongPointer, PagesFromWords, ScratchMap, Unmap],  VM USING [MakeResident, Swappability],  VMTestSpace,  Zone USING [Status];VMTestSpaceImpl: PROGRAM  IMPORTS Heap, Inline, ResidentHeap, Space, VM  EXPORTS VMTestSpace =  BEGIN  ------------  -- PUBLIC variables:  heap: PUBLIC UNCOUNTED ZONE ¬ NIL;  ------------  -- PRIVATE types, constants, variables:  Error: ERROR [ErrorType] = CODE;  ErrorType: TYPE = {cantAllocateFromResidentHeap, cantReturnHeap,    cantReturnSpace, unrecognizedSpaceType};  heapUsers: CARDINAL ¬ 0;  SpaceType: TYPE = {space, residentHeap, swappableHeap};  ------------  -- PUBLIC procedures:  -- All knowledge about where we get our data space allocations is embedded  -- (only) in the following routines.  -- Shutdown is to be called at the end of the test program run  Shutdown: PUBLIC PROCEDURE =    BEGIN    IF heapUsers = 0 THEN Heap.Delete[z: heap, checkEmpty: TRUE]      ELSE Error[cantReturnHeap];    END;  GetSpace: PUBLIC PROCEDURE [words: LONG CARDINAL, swappability: VM.Swappability]    RETURNS [pointer: LONG POINTER] =    BEGIN ENABLE UNWIND => NULL;    -- An extra word is allocated at the beginning of each space in order to    -- keep information about the type of space allocated.    -- If the space to be allocated is size 0, the NIL pointer is returned.    -- GetSpace does not catch SIGNALs relating to requests for more space than    -- is available from Pilot.  Callers who want very large spaces are expected    -- to, and will probably want to, handle that situation themselves.  Otherwise    -- it is probably a programming error and the debugger is the place to be.    code: SpaceType;    header: LONG POINTER TO SpaceType;    threshold: LONG CARDINAL = Environment.wordsPerPage/2;    assertion: PRIVATE BOOLEAN [TRUE..TRUE] = (threshold <= LAST[CARDINAL]);    Allocate: PROCEDURE [words: CARDINAL] RETURNS [LONG POINTER] =      INLINE BEGIN      -- This runaround is required to get a variable length hunk out of the heap.      hunk: TYPE = RECORD [s: SEQUENCE COMPUTED CARDINAL OF WORD];      RETURN[heap.NEW[hunk[words]]];      END;    IF words = 0 THEN RETURN [NIL];    words ¬ words + 1;  -- for space type code    IF words >= threshold THEN  -- big: use Spaces      BEGIN      pages: Environment.PageCount ¬ Space.PagesFromWords[words];      header ¬ Space.ScratchMap[pages];      IF swappability = resident THEN        VM.MakeResident[[Space.PageFromLongPointer[header], pages], wait];      code ¬ space;      END    ELSE  -- small: use Heaps      BEGIN      IF swappability = swappable THEN        {header ¬ Allocate[CARDINAL[words]]; code ¬ swappableHeap}      ELSE -- resident        BEGIN	base: Environment.Base ¬ ResidentHeap.first64K;        node: Environment.Base RELATIVE POINTER;        status: Zone.Status;        [node, status] ¬ ResidentHeap.MakeNode[CARDINAL[words]];        IF status ~= okay THEN Error[cantAllocateFromResidentHeap];        header ¬ @base[node];	code ¬ residentHeap;	END;      END;    header­ ¬ code;    pointer ¬ header + 1;    END;  GetHeap: PUBLIC PROCEDURE RETURNS [UNCOUNTED ZONE] =    {heapUsers ¬ heapUsers + 1; RETURN[heap]};  GiveBackHeap: PUBLIC PROCEDURE  [heap: UNCOUNTED ZONE]    RETURNS [UNCOUNTED ZONE] =    BEGIN    IF heapUsers = 0 THEN Error[cantReturnHeap]    ELSE heapUsers ¬ heapUsers - 1;    RETURN[NIL]    END;  ReturnSpace: PUBLIC PROCEDURE [pointer: LONG POINTER] =    BEGIN    -- Calling ReturnSpace with NIL pointer is a no-op.    header: LONG POINTER TO SpaceType;    IF pointer = NIL THEN RETURN;    header ¬ pointer - 1;    SELECT header­ FROM      space => [] ¬ Space.Unmap[header ! Space.Error => Error[cantReturnSpace]];      residentHeap =>        BEGIN        base: Environment.Base ¬ ResidentHeap.first64K;        node: Environment.Base RELATIVE POINTER ¬ Inline.LowHalf[header - base];        IF ResidentHeap.FreeNode[node] ~= okay THEN Error[cantReturnHeap];        END;      swappableHeap => heap.FREE[@header];      ENDCASE => Error[unrecognizedSpaceType];    END;  ------------  -- PUBLIC SIGNALs and ERRORs: none  ------------  -- Initialization:  Initialize: PROCEDURE =    BEGIN    heapUsers ¬ 0;    heap ¬ Heap.Create[initial: 4, increment: 1]; -- arbitrary initial value    END;  Initialize[];  END.LOG 2-Sep-82 13:45:12   CAJ    Created file.  
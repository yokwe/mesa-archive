-- Copyright (C) 1983, 1987  by Xerox Corporation. All rights reserved. -- HeapTest.mesa edited by: CJS   4-Feb-87 17:22:17DIRECTORY  Ascii USING [SP],  Command USING [Action, Entry, InstallTopLevel, Loop, QuitLevel, Scan],  Environment USING [PageCount],  Format USING [NumberFormat],  Heap USING [Create, Delete, Expand, Flush, GetAttributes],  PilotCommand USING [defaultWindow, StorageCatch],  Space USING [ SwapUnitSize],  TTY USING [    Handle, GetLongNumber, PutChar, PutCR, PutNumber,    PutString];HeapTest: PROGRAM  IMPORTS    Command, Heap, PilotCommand, TTY =  BEGIN    entries: ARRAY [0..10)  OF Command.Entry ¬ [    ["Commands", RunInLoop],  -- Must be first    ["create", CreateHeap],    ["delete", DeleteHeap],    ["toggle ownerChecking", ToggleOwner],    ["attributes", HeapAttrib],    ["expand", ExpandHeap],    ["flush", FlushHeap],    ["make node", MakeNode],    ["free node", FreeNode],    ["quit", Command.QuitLevel]];  -- Must be last  -- Parameters for commands.  -- Settable from debugger and from commands    z: UNCOUNTED ZONE ¬ NIL;    hSize: Environment.PageCount;  checkOwner: BOOLEAN ¬ FALSE;    Object: TYPE = RECORD [    node: LONG POINTER ¬ NIL,    value: CARDINAL ¬ 34];      emptyObject: LONG POINTER TO Object;    h: TTY.Handle ¬ PilotCommand.defaultWindow;  RunInLoop: Command.Action =    {Command.Loop[h, DESCRIPTOR[@entries[1], LENGTH[entries]-1],      PilotCommand.StorageCatch, "Heap "L]};  CreateHeap: Command.Action =    BEGIN    IF z # NIL THEN TTY.PutString[h, " - already have a Heap!"L]    ELSE {      TTY.PutString[h, " - initial page count: "L];      hSize ¬ TTY.GetLongNumber[h, hSize, 10];      z ¬ Heap.Create[initial: hSize, ownerChecking: checkOwner];};    END;  DeleteHeap: Command.Action =    BEGIN    Heap.Delete[z];    z ¬ NIL;    END;  ToggleOwner: Command.Action =    BEGIN    TTY.PutString[h, " - owner checking is "L];    IF (checkOwner ¬ NOT checkOwner) THEN TTY.PutString[h, "ON."L]    ELSE TTY.PutString[h, "OFF."L];    END;  HeapAttrib: Command.Action =    BEGIN    hPages: LONG CARDINAL;    sUSize: Space.SwapUnitSize;    OwnChk: BOOLEAN;    format: Format.NumberFormat ¬ [];    [hPages,,,sUSize,OwnChk] ¬ Heap.GetAttributes[z];    TTY.PutCR[h];    TTY.PutString[h, " Heap attributes: "L];    TTY.PutString[h, "PageCount = "L];    TTY.PutNumber[h, CARDINAL[hPages], format];    TTY.PutString[h, "Swap unit size = "L];    TTY.PutNumber[h, sUSize, format];    TTY.PutCR[h];    IF OwnChk THEN TTY.PutString[h, "ON."L] ELSE TTY.PutString[h, "OFF."L];    END;  ExpandHeap: Command.Action =    BEGIN    grow: Environment.PageCount;    TTY.PutString[h, " - by how many pages: "L];    grow ¬ TTY.GetLongNumber[h, hSize, 10];    Heap.Expand[z, grow];    END;  FlushHeap: Command.Action =    BEGIN    Heap.Flush[z];    END;  MakeNode: Command.Action =    BEGIN    emptyObject ¬ z.NEW[Object ¬ [node: NIL, value: 4]];    END;  FreeNode: Command.Action =    BEGIN    z.FREE[@emptyObject];    END;    HeapCmd: Command.Action =    BEGIN    TTY.PutChar[h, Ascii.SP];    Command.Scan[h, DESCRIPTOR[@entries[0], LENGTH[entries]-1],      PilotCommand.StorageCatch];    END;        Command.InstallTopLevel[h, ["Heap", HeapCmd]];  END.  LOG21-Feb-85 16:08:05   CJS  Created file. 4-Feb-87 17:20:32   CJS  hPages is LONG CARD.
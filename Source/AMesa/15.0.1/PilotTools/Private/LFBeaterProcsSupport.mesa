-- Copyright (C) 1988  by Xerox Corporation. All rights reserved. -- LFBeaterProcsSupport.mesa	CAJ	15-Jun-88  7:40:33DIRECTORY  BcdDefs,  BcdOps USING [BcdBase, MTHandle, NameString],  BcdOpsExtras USING [gfiOrigin, MthFromGfi, NameStringFromBcd, nullGFIndex],  Inline USING [BITAND],  LFBeaterInternal,  LoadState USING [LockBcdInfo, LPBcdInfoTable, LPModuleInfoTable, UnlockBcdInfo],  LoadStateFormat USING [BcdInfo, Handle, ModuleInfo],  PrincOpsExtras2 USING [GFT, GFTHandle, LongGlobalFrameHandle],  ResidentMemoryImpl,  String USING [EqualSubString, SubStringDescriptor];LFBeaterProcsSupport: MONITOR  IMPORTS BcdOpsExtras, Inline, LoadState, String  EXPORTS LFBeaterInternal  SHARES ResidentMemoryImpl =  BEGIN  -- This catburgling access is readonly, you better believe it.  resMemImpl: LONG POINTER TO FRAME [ResidentMemoryImpl];  AtLeastThisManyLeftToAlloc: PUBLIC ENTRY PROCEDURE [n: CARDINAL]    RETURNS [BOOLEAN] =    BEGIN    -- Determine whether there are still at least n pages that could be    -- allocated for a frame.  It is supposed to keep us from getting too    -- close to "Out of VM for resident memory".  However, it provides only    -- a hint.  There remains a window containing unknown activity between    -- the request for this hint and the actual call of a procedure requiring    -- a frame of the projected size.    -- This is the chartreuse framethrower.    -- This code is stolen, modified, from ResidentMemoryImpl in the place where    -- it determines whether there are enough contiguous pages left to allocate.    start, pageInRun: resMemImpl.AllocIndexForMDS;    lData: LONG POINTER TO resMemImpl.LocationData = @resMemImpl.locations[mds];    FOR start ¬ 0, pageInRun + 1      WHILE start + n < resMemImpl.countMaxForMDS DO  -- (leave 1 spare)      -- Look for good starting page:      FOR pageInRun IN [start..start + n) DO  	-- look for n contiguous pages..	IF lData.mdsAllocationMap[pageInRun] = busy THEN EXIT;        REPEAT          FINISHED =>  -- found n contiguous free pages.	    RETURN[TRUE];        ENDLOOP;      REPEAT  -- (not enough contiguous pages beginning at start, try later)        FINISHED =>  -- didn't find n contiguous free pages.	  RETURN[FALSE];      ENDLOOP;    END;  -- AtLeastThisManyLeftToAlloc  GFFromName: PROCEDURE [name: LONG STRING]    RETURNS [gf: PrincOpsExtras2.LongGlobalFrameHandle] =    BEGIN    bcdInfo: LoadState.LPBcdInfoTable;  -- the table    loadstate: LoadStateFormat.Handle;    nameSS: String.SubStringDescriptor ¬ [name, 0, name.length];    CheckBcd: PROCEDURE [bcdInfo: LoadStateFormat.BcdInfo, index: CARDINAL]      RETURNS [stop: BOOLEAN] =      BEGIN      bcd: BcdOps.BcdBase;      ssb: BcdOps.NameString;      moduleInfoTable: LoadState.LPModuleInfoTable;      moduleSS: String.SubStringDescriptor;      CheckModule: PROCEDURE [modInfo: LoadStateFormat.ModuleInfo]        RETURNS [stop: BOOLEAN] =	BEGIN        MapCgfiToMth: PROC [cgfi: NATURAL] RETURNS [mth: BcdOps.MTHandle] =          {mth ¬ IF bcd = NIL THEN NIL            ELSE IF cgfi IN [BcdOpsExtras.gfiOrigin..bcd.firstdummy)              THEN BcdOpsExtras.MthFromGfi[bcd, cgfi] ELSE NIL};	IF modInfo.cgfi = 0 THEN RETURN[stop: FALSE];	moduleSS.length ¬	  ssb.size[moduleSS.offset ¬ MapCgfiToMth[modInfo.cgfi].name];	RETURN[stop: String.EqualSubString[@nameSS, @moduleSS]];	END;  -- CheckModule      GFFromModuleInfo: PROCEDURE [modInfo: LoadStateFormat.ModuleInfo]        RETURNS [gf: PrincOpsExtras2.LongGlobalFrameHandle] =	BEGIN        gfi: PrincOpsExtras2.GFTHandle ¬ Inline.BITAND[modInfo.gfi, 177774B];        gf ¬ LOOPHOLE[PrincOpsExtras2.GFT[gfi].globalFrame];	END;  -- GFFromModuleInfo      -- Main CheckBcd      ValidateLoadstate[];      bcd ¬ bcdInfo.base;      ssb ¬ BcdOpsExtras.NameStringFromBcd[bcd];      moduleSS.base ¬ @ssb.string;      moduleInfoTable ¬ @loadstate[loadstate.moduleInfo];      -- enumerate modules in config:      FOR i: CARDINAL --DECREASING --IN [0..loadstate.nModules) DO        mod: LoadStateFormat.ModuleInfo = moduleInfoTable[i];        IF mod.index = index AND mod.cgfi # BcdOpsExtras.nullGFIndex          AND CheckModule[mod] THEN	    {gf ¬ GFFromModuleInfo[mod]; RETURN[stop: TRUE]};        ENDLOOP;      RETURN[stop: FALSE];      END;  -- CheckBcd    ValidateLoadstate: PROCEDURE =      BEGIN      -- Loadstate is guaranteed to be valid only between Lock and Unlock.      [loadstate, bcdInfo] ¬ LoadState.LockBcdInfo[];      LoadState.UnlockBcdInfo[];      END;    -- Main GFFromName    ValidateLoadstate[];    -- enumerate bcds:    FOR config: CARDINAL --DECREASING --IN [0..loadstate.nBcds) DO      -- The normal case is to enumerate backwards for something recently loaded.      IF CheckBcd[bcdInfo[config], config] THEN EXIT;      ENDLOOP;    END;  -- GFFromName  Init: PROCEDURE =    BEGIN    resMemImpl ¬ LOOPHOLE[GFFromName["ResidentMemoryImpl"L]];    END;  -- Module initialization  Init[];  END.LOG15-Jun-88  7:40:27	CAJ	Created file.
-- Copyright (C) 1988  by Xerox Corporation. All rights reserved. -- LFBeaterBlocker.mesa	CAJ	15-Jul-88 11:18:14DIRECTORY  CPSwapDefs USING [ProcessState],  Frame USING [MyLocalFrame],  LFBeaterInternal USING [BlockerChoice, RandomNumber],  Process USING [    Abort, Detach, EnableAborts, InitializeCondition, Pause, TooManyProcesses,    Yield],  ProcessOperations USING [HandleFromProcess, IndexFromProcess],  PSB USING [PDA, PsbHandle],  Runtime USING [GetCaller],  RuntimeInternal USING [WorryCallDebugger],  System USING [GetGreenwichMeanTime, GreenwichMeanTime];LFBeaterBlocker: MONITOR  IMPORTS Frame, LFBeaterInternal, Process, ProcessOperations, Runtime,    RuntimeInternal, System  EXPORTS LFBeaterInternal =  BEGIN  -- Variables:  choices: ARRAY LFBeaterInternal.BlockerChoice OF CARDINAL;  distributionTotal: CARDINAL;  go: CONDITION;  godot: CONDITION;  godotTimeoutTicks: CARDINAL ¬ 2;  goTimeoutTicks: CARDINAL ¬ 1000;  -- This guy is currently zeroed only on module initialization.  processOverflows: LONG CARDINAL ¬ 0;  -- Inlines:  CookieMaker: PROCEDURE RETURNS [WORD] =    -- Generate a unique value (assumes procedure issuing cookie stays around    -- until cookie checking time).    INLINE {RETURN[LOOPHOLE[Frame.MyLocalFrame[]]]};  ProcState: PROCEDURE [psbh: PSB.PsbHandle] RETURNS [CPSwapDefs.ProcessState] =    INLINE {    -- for access to ProcessState field.    RETURN[LOOPHOLE[PSB.PDA[psbh].flags.available, CPSwapDefs.ProcessState]]};  -- Procedures:  Block: PUBLIC PROCEDURE =    BEGIN    -- Suspend the caller's process somehow, then resume.  This is to force    -- good citizenship on essentially cpu bound processes and allow some    -- priority mixing.    -- Ways to block a process:    -- preempted:    --      *head of priority queue    --      *state vector required    --   I/O wait (chance when susp for I/O and on done interrupt)    --   condition variable timeout (wait with no notify?)    -- faulted:    --      *end of priority queue    --      *state vector required    --   (page fault - run SwapBeater or the like in parallel)    --   (frame fault - we have plenty of those)    --   (write fault - we don't want to crash)    -- voluntary release:    --      *end of priority queue    --      *no state vector required    --   wait for notify    --   Process.Pause  (holds monitor)    --   Process.Yield    --   notify    --   exit monitor    --   wait for monitor    --   fork or join    cookie: WORD ¬ CookieMaker[];    num: CARDINAL;    SELECT num ¬ LFBeaterInternal.RandomNumber[distributionTotal] FROM      < choices[waitTimeout] => [] ¬ WaitForTimeout[cookie];      < choices[waitNotify] => [] ¬ WaitForPermission[cookie];      < choices[notify] => [] ¬ DoANotify[cookie];      < choices[broadcast] => [] ¬ DoABroadcast[cookie];      < choices[forkAbort] => ForkAndAbort[num];      < choices[forkDetach] => ForkAndDetach[num];      < choices[forkJoin] => ForkAndJoin[num];      < choices[pause] => [] ¬ VariablePause[cookie];      < choices[yield] => [] ¬ DoAYield[cookie];      ENDCASE => [] ¬ DoAYield[cookie];    END;  -- Block  ChangeBlockerDistribution: PUBLIC PROCEDURE [    who: LFBeaterInternal.BlockerChoice, toWhat: CARDINAL] =    -- Change the share of the distribution assigned to this blocker choice.    BEGIN    -- The choice array keeps each element as a position in the total, i.e.,    -- the total of all the elements so far plus the distribution amount for    -- this particular item.  To change one, it is necessary to propagate the    -- amount of change through the rest of the elements.    change: INTEGER;    oldSingleItem: CARDINAL ¬ choices[who] - choices[PRED[who]];    change ¬ toWhat - oldSingleItem;    choices[who] ¬ toWhat +      (IF who = FIRST[LFBeaterInternal.BlockerChoice] THEN 0        ELSE choices[PRED[who]]);    FOR i: LFBeaterInternal.BlockerChoice IN        [SUCC[who]..LAST[LFBeaterInternal.BlockerChoice]] DO      choices[i] ¬ choices[i] + change;      ENDLOOP;    distributionTotal ¬ choices[LAST[LFBeaterInternal.BlockerChoice]];    END;  ContinuousWhatever: PROCEDURE [cookie: WORD, num: CARDINAL]    RETURNS [passBack: WORD] =    -- This does an option continuously until aborted (necessary because    -- the little cretin processes generated from this module do not    -- necessarily last long enough for the parent to get to abort in a    -- heavily process-loaded environment).    BEGIN ENABLE ABORTED => GOTO aborted;    proc: PROCEDURE [cookie: WORD] RETURNS [passBack: WORD];    passBack ¬ cookie;    proc ¬ (SELECT num MOD 3 FROM      0 => WaitForPermission,      1 => WaitForTimeout,      ENDCASE => VariablePause);    DO [] ¬ proc[cookie]; Process.Yield[]; ENDLOOP;      -- If you wanted to check cookie passing just on procedure call/return,      -- you could check this cookie pass.    EXITS aborted => NULL;    END;  DoABroadcast: ENTRY PROCEDURE [cookie: WORD] RETURNS [passBack: WORD] =    BEGIN    passBack ¬ cookie;    BROADCAST go;    END;  DoANotify: ENTRY PROCEDURE [cookie: WORD] RETURNS [passBack: WORD] =    BEGIN    passBack ¬ cookie;    NOTIFY go;    END;  DoAYield: PROCEDURE [cookie: WORD] RETURNS [passBack: WORD] =    BEGIN    passBack ¬ cookie;    Process.Yield[];    END;  FakeProc1: PROCEDURE [cookie: WORD] RETURNS [passBack: WORD] =    -- Actual contents of this are arbitrary.    -- This one references an external monitor.    BEGIN    x: CARDINAL ¬ LFBeaterInternal.RandomNumber[0FFFH];    passBack ¬ cookie;    END;  FakeProc2: PROCEDURE [cookie: WORD] RETURNS [passBack: WORD] =    -- Actual contents of this are arbitrary.    BEGIN    x: System.GreenwichMeanTime ¬ System.GetGreenwichMeanTime[];    passBack ¬ cookie;    END;  FakeProc3: PROCEDURE [cookie: WORD] RETURNS [passBack: WORD] =    -- Actual contents of this are arbitrary.    BEGIN    FOR i: CARDINAL IN [0..100) DO ENDLOOP;    passBack ¬ cookie;    END;  FakeProc4: PROCEDURE [cookie: WORD] RETURNS [passBack: WORD] =    -- Actual contents of this are arbitrary.    BEGIN    x: PROGRAM ¬ Runtime.GetCaller[];    passBack ¬ cookie;    END;  ForkAndAbort: PROCEDURE [num: CARDINAL] =    BEGIN ENABLE Process.TooManyProcesses => GOTO skipIt;    cookie: WORD ¬ CookieMaker[];    forkee: PROCESS RETURNS [WORD] ¬ FORK ContinuousWhatever[cookie, num];    IF num > 50 THEN Process.Detach[LOOPHOLE[forkee]];    -- forkee has to be LOOPHOLEd to Detach because of the return value    Process.Abort[forkee];    IF num <= 50 THEN      BEGIN      returnedCookie: WORD;      -- (Same situation as ForkAndJoin, q.v..)      IF ProcState[ProcessOperations.HandleFromProcess[LOOPHOLE[forkee]]].state	IN [frameTaken..dead] THEN          RuntimeInternal.WorryCallDebugger["suspicious child state"L];          -- child should be either in normal running state or ready to join.      returnedCookie ¬ JOIN forkee;      IF returnedCookie ~= cookie THEN        RuntimeInternal.WorryCallDebugger["suspicious join"L];	-- likewise same situation as ForkAndJoin, q.v.      END;    EXITS skipIt => processOverflows ¬ processOverflows + 1;    END;  ForkAndDetach: PROCEDURE [num: CARDINAL] =    BEGIN ENABLE Process.TooManyProcesses => GOTO skipIt;    proc: PROCEDURE [cookie: WORD] RETURNS [passBack: WORD];    proc ¬ (SELECT num MOD 10 FROM      0 => FakeProc1,      1 => FakeProc2,      2 => FakeProc3,      3 => FakeProc4,      4 => DoANotify,      5 => DoABroadcast,      6 => WaitForPermission,      7 => WaitForTimeout,      8 => VariablePause,      ENDCASE => DoAYield);    Process.Detach[LOOPHOLE[FORK proc[CookieMaker[]]]];    EXITS skipIt => processOverflows ¬ processOverflows + 1;    END;  ForkAndJoin: PROCEDURE [num: CARDINAL] =    BEGIN ENABLE Process.TooManyProcesses => GOTO skipIt;    cookie: WORD ¬ CookieMaker[];    forkee: PROCESS RETURNS [WORD];    proc: PROCEDURE [cookie: WORD] RETURNS [passBack: WORD];    returnedCookie: WORD;    proc ¬ (SELECT num MOD 10 FROM      0 => FakeProc1,      1 => FakeProc2,      2 => FakeProc3,      3 => FakeProc4,      4 => DoANotify,      5 => DoABroadcast,      6 => WaitForPermission,      7 => WaitForTimeout,      8 => VariablePause,      ENDCASE => DoAYield);    forkee ¬ FORK proc[cookie];    -- Here we assume system policy to let the child process run first before    -- the parent gets to run again.  By the time we get to here, the child    -- will have finished forking and at least started to run.    IF ProcState[ProcessOperations.HandleFromProcess[LOOPHOLE[forkee]]].state      IN [frameTaken..dead] THEN        RuntimeInternal.WorryCallDebugger["suspicious child state"L];        -- A good child should be either in normal running state or ready to join.    returnedCookie ¬ JOIN forkee;    IF returnedCookie ~= cookie THEN      RuntimeInternal.WorryCallDebugger["suspicious join"L];      -- If the cookie stored by this joinee does not match the one we      -- sent him, then either we just joined somebody other that the one      -- we forked, or something ate the cookie.    EXITS skipIt => processOverflows ¬ processOverflows + 1;    END;  VariablePause: PROCEDURE [cookie: WORD] RETURNS [passBack: WORD] =    BEGIN ENABLE UNWIND => NULL;    passBack ¬ cookie;    Process.Pause[LFBeaterInternal.RandomNumber[9] + 1]; -- 1..10 ticks    END;  WaitForPermission: ENTRY PROCEDURE [cookie: WORD] RETURNS [passBack: WORD] =    -- This guy waits until somebody does a notify or broadcast to him.    -- If nobody does within the timeout, he just times out.  Among other    -- things, that ensures completion if the tool is stopped.    BEGIN ENABLE UNWIND => NULL;    passBack ¬ cookie;    WAIT go;    END;  WaitForTimeout: ENTRY PROCEDURE [cookie: WORD] RETURNS [passBack: WORD] =    -- This guy waits on a CV which is never notified, so it always times out.    BEGIN ENABLE UNWIND => NULL;    passBack ¬ cookie;    WAIT godot;    END;  Init: PROCEDURE =    BEGIN    Process.InitializeCondition[@go, goTimeoutTicks];    Process.EnableAborts[@go];    Process.InitializeCondition[@godot, godotTimeoutTicks];    Process.EnableAborts[@godot];    END;  InitializeChoices: PUBLIC PROCEDURE [    a: LONG POINTER TO ARRAY LFBeaterInternal.BlockerChoice OF CARDINAL] =    -- Set up the blocker distribution with the initial values.    BEGIN    choices[FIRST[LFBeaterInternal.BlockerChoice]] ¬      a[FIRST[LFBeaterInternal.BlockerChoice]];    FOR i: LFBeaterInternal.BlockerChoice IN      [SUCC[FIRST[LFBeaterInternal.BlockerChoice]]..	LAST[LFBeaterInternal.BlockerChoice]] DO      choices[i] ¬ choices[PRED[i]] + a[i];      ENDLOOP;    distributionTotal ¬ choices[LAST[LFBeaterInternal.BlockerChoice]];    END;  -- Module initialization  Init[];  END.LOG15-Jul-88 11:18:09	CAJ	Created file.
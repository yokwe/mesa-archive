-- Copyright (C) 1988  by Xerox Corporation. All rights reserved. -- GuerillaBitImpl.mesa	 1-Jun-88 11:15:28	CAJ-- This little sweetheart smashes random bits in memory until the debugger or something else stops it by violent means.DIRECTORY  Environment USING [Long, LongPointerFromPage, PageCount, PageNumber],  Inline USING [BITAND, BITXOR, HighHalf, LowHalf],  PageMap USING [flagsReadOnly, flagsVacant, GetState, State],  PrincOpsExtras2 USING [ControlLink, GFT, GFTHandle],  Process USING [Detach, Pause, Seconds, SecondsToTicks, Ticks],  ProcessorFace USING [GetNextAvailableVM],  RandomDefs USING [GeneratorState, InitializeRandom, Random],  VM USING [Interval, Kill],  VMDataImpl,  VMDataInternal USING [pRunFirst, Run];GuerillaBitImpl: PROGRAM  IMPORTS Environment, Inline, PageMap, Process, ProcessorFace, RandomDefs, VM  SHARES PageMap, VMDataImpl =  BEGIN  -- Set these from the debugger for different parameters  aborted: BOOLEAN ¬ FALSE;		-- stop the show  doItAnyway: BOOLEAN ¬ FALSE;		-- try write even if fault expected  lastPageToTry: Environment.PageNumber ¬ 0;  -- 0 => use lastVMPage  reallyWrite: BOOLEAN ¬ FALSE;		-- really do the bit resetting  secondsToPause: Process.Seconds ¬ 60; -- how long to wait between smashes  initialSeed: LONG UNSPECIFIED ¬ 2097151;  lastVMPage: Environment.PageNumber;  random: RandomDefs.GeneratorState ¬ TRASH;  ticks: Process.Ticks;  vmDataImpl: LONG POINTER TO FRAME [VMDataImpl];  addrFault: LONG CARDINAL;  bogusMemory: LONG CARDINAL;  pageFault: LONG CARDINAL;  smashes: LONG CARDINAL;  writeFault: LONG CARDINAL;  Init: PROCEDURE =    BEGIN    ticks ¬ Process.SecondsToTicks[secondsToPause];    addrFault ¬ 0;    bogusMemory ¬ 0;    pageFault ¬ 0;    smashes ¬ 0;    writeFault ¬ 0;    random.seed ¬ initialSeed;    RandomDefs.InitializeRandom[@random];    -- Find size of VM on this processor    BEGIN    page: Environment.PageNumber;    count: Environment.PageCount;    countVM: Environment.PageCount;    FOR countVM ¬ FIRST[Environment.PageNumber], page + count DO      [page, count] ¬ ProcessorFace.GetNextAvailableVM[countVM];      IF count = 0 THEN EXIT;      ENDLOOP;    lastVMPage ¬ countVM - 1;    END;  -- find VM size    -- Use real VM size unless another value was set.    IF lastPageToTry = 0 THEN lastPageToTry ¬ lastVMPage;    -- Get (catburglar, readonly) access to location of Pilot's run table.    BEGIN    gfi: PrincOpsExtras2.GFTHandle ¬      Inline.BITAND[        LOOPHOLE[VM.Kill, longProc PrincOpsExtras2.ControlLink].gfi, 177774B];    vmDataImpl ¬ LOOPHOLE[PrincOpsExtras2.GFT[gfi].globalFrame];    END;    Process.Detach[FORK Smasher[]];    END;  -- Init  Mapped: PROCEDURE [page: Environment.PageNumber] RETURNS [BOOLEAN] = --INLINE--    BEGIN    -- Looks through Pilot's run table to see if page is mapped.    -- This slimy piece of code recasts the run table in terms of only the    -- interval we want to look at, for simplicity of reference.  Since we    -- don't have any kind of lock on the table (not to mention permission    -- to look at it), the faster we can streak through it, the smaller the    -- chance it will change out from under us.    nEntries: CARDINAL ¬ CARDINAL[      (@vmDataImpl.runBase[vmDataImpl.pRunMaxInRealMem] -        @vmDataImpl.runBase[VMDataInternal.pRunFirst])/SIZE[VMDataInternal.Run]];    run: LONG POINTER TO VM.Interval ¬      LOOPHOLE[@vmDataImpl.runBase[VMDataInternal.pRunFirst]];    THROUGH [0..nEntries) DO      IF page < run.page THEN EXIT;      IF page IN [run.page..run.page + run.count) THEN RETURN[TRUE];      run ¬ run + SIZE[VMDataInternal.Run];      ENDLOOP;    RETURN[FALSE];    END;  RandomNumber: PROCEDURE [max: CARDINAL] RETURNS [CARDINAL] =    {RETURN [RandomDefs.Random[@random, max]]};  RandomNumberLong: PROCEDURE [max: LONG CARDINAL]    RETURNS [LONG CARDINAL] =    {RETURN[LOOPHOLE[Environment.Long[num[      lowbits: RandomDefs.Random[@random, Inline.LowHalf[max]],      highbits: RandomDefs.Random[@random, Inline.HighHalf[max]]]]]]};  Smasher: PROCEDURE =    BEGIN    addr: LONG POINTER;    bit: CARDINAL;    page: Environment.PageNumber;    safe: BOOLEAN;    state: PageMap.State;    WHILE NOT aborted DO      -- choose an address      page ¬ RandomNumberLong[lastPageToTry];      bit ¬ RandomNumber[15];      addr ¬ Environment.LongPointerFromPage[page] + RandomNumber[255];      -- could keep log of what bits we target      state ¬ PageMap.GetState[page].state;      safe ¬ FALSE;      SELECT TRUE FROM        page > lastVMPage => bogusMemory ¬ bogusMemory + 1;        state.flags = PageMap.flagsVacant =>	  BEGIN	  IF Mapped[page] THEN pageFault ¬ pageFault + 1	    ELSE addrFault ¬ addrFault + 1;	  END;        Inline.BITAND[state.flags, PageMap.flagsReadOnly] =>	  writeFault ¬ writeFault + 1;	ENDCASE => {smashes ¬ smashes + 1; safe ¬ TRUE};      -- smash a bit      IF reallyWrite AND (safe OR doItAnyway) THEN        addr­ ¬ Inline.BITXOR[addr­, bit];      Process.Pause[ticks];      ENDLOOP;    END;  -- Smasher  Init[];  END....  LOG 1-Jun-88 10:46:42   CAJ   Created file.
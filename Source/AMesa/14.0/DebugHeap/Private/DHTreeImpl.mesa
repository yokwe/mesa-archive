-- Copyright (C) 1981, 1982  by Xerox Corporation. All rights reserved. -- DHTreeImpl.mesa--  edited by SXS    (15-Sep-81 17:03:50)DIRECTORY  DHTree;DHTreeImpl: PROGRAM EXPORTS DHTree SHARES DHTree =  BEGIN OPEN DHTree;  Insert: PUBLIC PROCEDURE [handle: Handle, tree: Tree, value: Value] RETURNS [Tree] =    BEGIN    -- Return a tree with value in it    IF tree = treeNil THEN RETURN[CreateNode[handle, value]]    ELSE      SELECT handle.compareProc[tree.value, value] FROM        equal => NULL;        less => tree.right ¬ Insert[handle, tree.right, value];        greater => tree.left ¬ Insert[handle, tree.left, value];        ENDCASE;    RETURN[tree];    END;  CreateNode: PROCEDURE [handle: Handle, value: Value] RETURNS [tree: Tree] =    BEGIN    -- allocate a tree node; assign its value    tree ¬ handle.z.NEW[Aqtree];    tree.value ¬ handle.copyProc[value, handle.z];    tree.left ¬ tree.right ¬ treeNil;    END;  Destroy: PUBLIC PROCEDURE [handle: Handle, tree: Tree] =    BEGIN    IF tree = treeNil THEN RETURN;    IF tree.left # treeNil THEN Destroy[handle, tree.left];    IF tree.right # treeNil THEN Destroy[handle, tree.right];    handle.freeValueProc[tree.value, handle.z];    handle.z.FREE[@tree];    END;  FreeValueNOOP: PUBLIC FreeValueProc = {};  -- does nothing;  Traverse: PUBLIC PROCEDURE [handle: Handle, tree: Tree, proc: PROCEDURE [tree: Tree]] =    BEGIN    IF tree = treeNil THEN RETURN;    IF tree.left # treeNil THEN Traverse[handle, tree.left, proc];    proc[tree];    IF tree.right # treeNil THEN Traverse[handle, tree.right, proc];    END;  Search: PUBLIC PROCEDURE [handle: Handle, tree: Tree, value: Value] RETURNS [Tree] =    BEGIN    IF tree = treeNil THEN RETURN[treeNil];    RETURN[SELECT handle.compareProc[tree.value, value] FROM        equal => tree,        less => Search[handle, tree.right, value],        ENDCASE => Search[handle, tree.left, value]];    END;  END.
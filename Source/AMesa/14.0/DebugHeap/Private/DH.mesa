-- Copyright (C) 1982  by Xerox Corporation. All rights reserved. -- File: DH.mesa - last edit: -- JGS on  8-Dec-82 12:58:47DIRECTORY  DebugUsefulDefs USING [GFHandle],  FormSW USING [EnumeratedNotifyProcType, LongNumberNotifyProcType],  HeapInternal: TYPE USING [    Block, BlockObject, Data, Handle, LargeNode, LargeNodeHeader,    Node, NodeObject, ZoneHandle, ZoneObject],  Menu USING [MCRType],  Window USING [Handle],  ZoneInternal USING [NodeHeader, SegmentHeader, ZoneHeader, ZonePointer];DH: DEFINITIONS = {  OtherAddress: TYPE = LONG ORDERED POINTER;  -- Address valid only in debuggee  NodeAddress: TYPE = OtherAddress;  -- Address of client node in debuggee  ChunkAddress: TYPE = OtherAddress;  -- Address of Chunk in debuggee  SegmentHandle: TYPE = LONG ORDERED POINTER TO ZoneInternal.SegmentHeader;  NodeHandle: TYPE = LONG ORDERED POINTER TO ZoneInternal.NodeHeader;    noFilter: Filter = NIL;  Filter: TYPE = LONG POINTER TO FilterObject;  FilterObject: TYPE = RECORD [    size: CARDINAL ¬ 0,  -- 0 means ignore size    swapStatus: SwapStatus ¬ inOrOut,    clientWords: CARDINAL ¬ 0,    mask: Words ¬ NIL,  -- NIL mask is ignored    values: Values ¬ NIL];  SwapStatus: TYPE = {inOrOut, in, out};  Words: TYPE = LONG POINTER TO WordSeq;  Values: TYPE = LONG POINTER TO ValueSeq;  WordSeq: TYPE = RECORD [    SEQUENCE COMPUTED --clientWords-- CARDINAL OF UNSPECIFIED];  ValueSeq: TYPE = RECORD [SEQUENCE maxlength: CARDINAL OF Words];  -- Procedure Parameter Types  NodeEnumProc: TYPE = PROC [node: NodeAddress, size: CARDINAL, inUse: BOOLEAN]    RETURNS [BOOLEAN];  ChunkEnumProc: TYPE = PROC [chunk: ChunkAddress, size: CARDINAL]    RETURNS [BOOLEAN];  Handle: TYPE = HeapInternal.Handle;  ZoneHandle: TYPE = HeapInternal.ZoneHandle;  LargeNode: TYPE = HeapInternal.LargeNode;  Block: TYPE = HeapInternal.Block;  Node: TYPE = HeapInternal.Node;  ZonePointer: TYPE = ZoneInternal.ZonePointer;  -- Enumeration Procedures  CallNodeEnumProc: PROC [    largeNodes: LargeNode ¬ NIL, proc: NodeEnumProc, n: NodeAddress];  EnumerateNodes: PROC [    heap: Handle, proc: NodeEnumProc, filter: Filter ¬ noFilter]    RETURNS [BOOLEAN];  EnumerateLargeNodes: PROC [    largeNode: LargeNode, proc: NodeEnumProc, filter: Filter ¬ noFilter]    RETURNS [BOOLEAN];  EnumerateChunks: PROC [heap: Handle, proc: ChunkEnumProc]    RETURNS [BOOLEAN];  VirtualHandle: PROC [handle: Handle] RETURNS [Handle];  VirtualZoneHandle: PROC [zone: ZoneHandle] RETURNS [ZoneHandle];  VirtualLargeNode: PROC [largeNode: LargeNode] RETURNS [LargeNode];  VirtualBlock: PROC [block: Block] RETURNS [Block];  VirtualNode: PROC [node: Node] RETURNS [Node];  VirtualZonePointer: PROC [zone: ZonePointer] RETURNS [ZonePointer];  VirtualSegmentHandle: PROC [segment: SegmentHandle] RETURNS [SegmentHandle];  VirtualNodeHandle: PROC [node: NodeHandle] RETURNS [NodeHandle];  -- Utilities  CheckGFH: PROCEDURE [gf: DebugUsefulDefs.GFHandle] RETURNS [BOOLEAN];  Read: PROC [LONG POINTER] RETURNS [UNSPECIFIED];  -- heap reading and setup  SetupPointers: PROC [address: POINTER];  SetupHeapImpl: PROC [heapGFH: DebugUsefulDefs.GFHandle];  SetupHeap: PROC [address: LONG POINTER] RETURNS [h: Handle];  SetupHeapMDS:  PROC [address: POINTER] RETURNS [h: Handle];  InvalidZone, InvalidHeap: ERROR;  SuspiciousZone: SIGNAL;  -- Might be bad.  Resume if you want to examine anyway.  heapData: ToolData;  Mode: TYPE = {systemMDS, system, zone, heap, heapMDS};  ToolData: TYPE = LONG POINTER TO HeapData;  HeapData: TYPE = RECORD [    logSW: Window.Handle ¬ NIL,    formSW: Window.Handle ¬ NIL,    fspFreeCount, savedFreeCount: INTEGER ¬ 0,    fspUsedCount, savedUsedCount: INTEGER ¬ 0,    zone: UNCOUNTED ZONE ¬ TRASH,    dataSpace: ARRAY [0..SIZE[HeapInternal.Data]) OF CARDINAL ¬ ALL[0],    zoneObject: HeapInternal.ZoneObject ¬ TRASH,    largeNodeHeader: HeapInternal.LargeNodeHeader ¬ TRASH,    blockObject: HeapInternal.BlockObject ¬ TRASH,    nodeObject: HeapInternal.NodeObject ¬ TRASH,    zoneHeader: ARRAY [0..SIZE[ZoneInternal.ZoneHeader]) OF CARDINAL ¬ ALL[0],    segmentHeader: ZoneInternal.SegmentHeader ¬ TRASH,    nodeHeader: ZoneInternal.NodeHeader ¬ TRASH,    nodeChain: NodeData ¬ NIL,    savedNodeChain: NodeData ¬ NIL,    swapStatus: SwapStatus ¬ inOrOut,    clientWords: CARDINAL ¬ 0,    mask: CARDINAL ¬ 0,    clientValue: LONG STRING ¬ NIL,    address: LONG UNSPECIFIED ¬ 0,    zoneAddress: LONG UNSPECIFIED ¬ 0,    largeNodes: LargeNode ¬ NIL,    currentHeap: Handle ¬ NIL,    mode: Mode ¬ system,  -- align on word boundary    currentZone: ZonePointer ¬ NIL,    deltas: BOOLEAN ¬ FALSE,  -- align on word boundary    heapImpl: DebugUsefulDefs.GFHandle ¬ NIL,    systemZone: UNCOUNTED ZONE ¬ NIL,    validate: BOOLEAN ¬ TRUE,  -- align on word boundary    systemMDS: MDSZone ¬ NIL,    commaState: CommaState ¬ notGoing,    lookup: BOOLEAN ¬ TRUE,    warnedHim: BOOLEAN ¬ FALSE,    toolIsBusy: BOOLEAN ¬ FALSE];  NodeData: TYPE = LONG POINTER TO NodeDataObject;  NodeDataObject: TYPE = MACHINE DEPENDENT RECORD [    link: NodeData,    size, count: CARDINAL,    array: LONG POINTER TO NodeSequence];  NodeSequence: TYPE = RECORD [SEQUENCE length: NAT OF LONG POINTER];    CommaState: TYPE = {notGoing, sameLine, newLine};   InitDHHeaps: PROC [data: DH.ToolData];  FinishDHHeaps: PROC;    InitDHCommands: PROC [data: DH.ToolData];  FinishDHCommands: PROC;    InitDHUser: PROC [data: DH.ToolData];  FinishDHUser: PROC;    MCR: Menu.MCRType;    HeapAddressAltered: FormSW.LongNumberNotifyProcType;  HeapModeAltered: FormSW.EnumeratedNotifyProcType;    MenuCmd: TYPE = { -- keep in order of user's frequency of use    nodes, segments, nodesOfSize, ascii, octal, client, nodeOwners, ownerTotals,    freeNodes, setGfh, save, clear};  FormIndex: TYPE = {    heap, address, swapped, validate, delta, cWords, cValue, mask};  }.  
-- Copyright (C) 1980, 1981, 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- File: DHHeaps.mesa - last edit: -- SXW   ,	 9-Feb-81 12:12:10-- Mark,	11-Mar-81  0:57:34-- BXM  ,	17-Dec-80 11:48:48-- JGS on	13-Dec-82 12:16:17-- PXK    ,	20-Nov-81 19:16:03-- DWE    ,	20-May-83 13:29:41-- BJD    ,	23-Aug-83 16:17:56-- RSF      ,	 4-Jun-84 11:51:16DIRECTORY  DH,  DebugUsefulDefs USING [    Frame, GFHandle, InvalidAddress, InvalidFrame, Lengthen, LongREAD, LongCopyREAD, MultipleFrames, Name, NotFound, Started],  DebugUsefulDefsExtras2 USING [GetPageState],  Inline USING [BITAND],  HeapInternal USING [    Block, BlockObject, currentSeal, Data, Handle, LargeNode, LargeNodeHeader,    MDSZoneObject, Node,    NodeObject, UncountedZoneObject, UniformHandle, ZoneHandle, ZoneObject],  HeapImpl: FROM "UnpackedHeapImpl" USING [systemZone, systemMDSZone],  Space USING [PageFromLongPointer],  String USING [EqualString],  UserInput USING [UserAbort],  Zone USING [BlockSize, Handle, nullSegment],  ZoneInternal USING [    NodeHeader, OrderedBase, SegmentHeader, SegmentPointer, ZoneHeader,    ZonePointer, zoneSeal, zoneVersion];DHHeaps: PROGRAM  IMPORTS    DebugUsefulDefs, DebugUsefulDefsExtras2, Inline, Space, String, UserInput  EXPORTS DH SHARES HeapImpl =  BEGIN OPEN DH, HeapInternal, ZoneInternal;  InvalidZone: PUBLIC ERROR = CODE;  InvalidHeap: PUBLIC ERROR = CODE;  SuspiciousZone: PUBLIC SIGNAL = CODE;  MyInvalidAddress: PUBLIC ERROR [address: LONG POINTER] = CODE;  --  global constant declarations  UsedNodeSize: Zone.BlockSize = SIZE[inuse ZoneInternal.NodeHeader];  stuff: DH.ToolData ¬ NIL;  z: UNCOUNTED ZONE ¬ NIL;  InitDHHeaps: PUBLIC PROC [data: DH.ToolData] = {stuff ¬ data; z ¬ data.zone};  FinishDHHeaps: PUBLIC PROC = {stuff ¬ NIL; z ¬ NIL};      VirtualHandle: PUBLIC PROC [handle: Handle] RETURNS [vh: Handle] = {    Copy[from: handle, to: @stuff.dataSpace, count: SIZE[Data]];    vh ¬ LOOPHOLE[@stuff.dataSpace];    IF vh.seal # HeapInternal.currentSeal THEN ERROR InvalidHeap;    RETURN[vh]};      VirtualZoneHandle: PUBLIC PROC [zone: ZoneHandle] RETURNS [ZoneHandle] = {    Copy[from: zone, to: @stuff.zoneObject, count: SIZE[ZoneObject]];    RETURN[LOOPHOLE[@stuff.zoneObject]]};      VirtualLargeNode: PUBLIC PROC [largeNode: LargeNode] RETURNS [LargeNode] = {    Copy[      from: largeNode, to: @stuff.largeNodeHeader,      count: SIZE[LargeNodeHeader]];    RETURN[LOOPHOLE[@stuff.largeNodeHeader]]};      VirtualBlock: PUBLIC PROC [block: Block] RETURNS [Block] = {    Copy[from: block, to: @stuff.blockObject, count: SIZE[BlockObject]];    RETURN[LOOPHOLE[@stuff.blockObject]]};      VirtualNode: PUBLIC PROC [node: Node] RETURNS [Node] = {    Copy[from: node, to: @stuff.nodeObject, count: SIZE[NodeObject]];    RETURN[LOOPHOLE[@stuff.nodeObject]]};      VirtualZonePointer: PUBLIC PROC [    zone: ZonePointer] RETURNS [vz: ZonePointer] = {    Copy[from: zone, to: @stuff.zoneHeader, count: SIZE[ZoneHeader]];    vz ¬ LOOPHOLE[@stuff.zoneHeader];    IF vz.seal # ZoneInternal.zoneSeal      OR vz.version # ZoneInternal.zoneVersion THEN ERROR InvalidZone;    RETURN[vz]};      VirtualSegmentHandle: PUBLIC PROC [    segment: SegmentHandle] RETURNS [SegmentHandle] = {    Copy[from: segment, to: @stuff.segmentHeader, count: SIZE[SegmentHeader]];    RETURN[LOOPHOLE[@stuff.segmentHeader]]};      VirtualNodeHandle: PUBLIC PROC [node: NodeHandle] RETURNS [NodeHandle] = {    Copy[from: node, to: @stuff.nodeHeader, count: SIZE[inuse NodeHeader]];    RETURN[LOOPHOLE[@stuff.nodeHeader]]};      --  Setup routines  SetupHeap: PUBLIC PROC [address: LONG POINTER] RETURNS [h: Handle] =    BEGIN OPEN HeapInternal;    uzo: UncountedZoneObject;    Copy[to: @uzo, from: address, count: SIZE[UncountedZoneObject] !      DebugUsefulDefs.InvalidAddress => GOTO returnNil];    h ¬ VirtualHandle[uzo.data !      DebugUsefulDefs.InvalidAddress => GOTO returnNil];    RETURN[IF h.seal = currentSeal THEN uzo.data ELSE NIL];    EXITS returnNil => RETURN[NIL];    END;  SetupHeapMDS: PUBLIC PROC [address: POINTER] RETURNS [h: Handle] =    BEGIN OPEN HeapInternal, DebugUsefulDefs;    mzo: MDSZoneObject;    Copy[to: @mzo, from: Lengthen[address], count: SIZE[MDSZoneObject] !      InvalidAddress => GOTO returnNil];    h ¬ VirtualHandle[Lengthen[mzo.data] !      InvalidAddress => GOTO returnNil];    RETURN[      IF h.seal = currentSeal THEN Lengthen[mzo.data] ELSE NIL];    EXITS returnNil => RETURN[NIL];    END;  --  routines to process the Heap  EnumerateNodes: PUBLIC PROCEDURE [    heap: Handle, proc: NodeEnumProc, filter: Filter ¬ noFilter]    RETURNS[BOOLEAN] = {    vHeap: Handle ¬ VirtualHandle[heap];    WITH h: vHeap SELECT FROM      uniform => RETURN[EnumerateUniformHeap[@h, proc, filter]];      normal => {        zone: ZoneHandle ¬ h.zones;	UNTIL zone = NIL DO	  vZoneHandle: ZoneHandle = VirtualZoneHandle[zone];	  IF EnumerateNodesInZone[vZoneHandle.zH, proc, filter] THEN RETURN[TRUE];	  zone ¬ vZoneHandle.next;	  ENDLOOP;	RETURN[EnumerateLargeNodes[h.largeNodes, proc, filter]]};      mds => {        IF EnumerateNodesInZone[h.zH, proc, filter] THEN RETURN[TRUE];        RETURN[EnumerateLargeNodes[h.largeNodes, proc, filter]]};      ENDCASE;    RETURN[FALSE]};  FreeSeq: TYPE = LONG POINTER TO FreeSeqObject;  FreeSeqObject: TYPE = RECORD [SEQUENCE length: CARDINAL OF Node];  EnumerateUniformHeap: PROC [    vUniformHandle: UniformHandle, proc: NodeEnumProc, filter: Filter]    RETURNS[BOOLEAN] = {    nFree: CARDINAL;    size: CARDINAL;    node: Node;    block, vBlock: Block;    freeSeq: FreeSeq;    nFree ¬ 0;    FOR node ¬ vUniformHandle.free, VirtualNode[node].next UNTIL node = NIL DO      nFree ¬ nFree + 1; ENDLOOP;    node ¬ vUniformHandle.free;    freeSeq ¬ z.NEW[FreeSeqObject[nFree]];    FOR i: CARDINAL IN [0..nFree) DO      freeSeq[i] ¬ node; node ¬ VirtualNode[node].next; ENDLOOP;    Sort[freeSeq];    size ¬ AllocatedObjectSize[vUniformHandle];    FOR block ¬ vUniformHandle.blocks, vBlock.next UNTIL block = NIL DO      ENABLE UNWIND => IF freeSeq # NIL THEN z.FREE[@freeSeq];      lastNode: Node;      vBlock ¬ VirtualBlock[block];      node ¬ LOOPHOLE[block, Node] + SIZE[BlockObject];      lastNode ¬ node + vBlock.length - size;      FOR node ¬ node, node + size WHILE node < lastNode DO        IF UseThisNode[node, size, filter] AND	  proc[node, size, ~InSeq[node, freeSeq]]	  THEN {z.FREE[@freeSeq]; RETURN[TRUE]};	ENDLOOP;      ENDLOOP;    z.FREE[@freeSeq];    RETURN[FALSE]};	  AllocatedObjectSize: PROC [h: UniformHandle] RETURNS [objectSize: CARDINAL] = {    objectSize ¬ h.objectSize;    IF h.ownerChecking THEN objectSize ¬ objectSize + SIZE[PROGRAM];    objectSize ¬ MAX[SIZE[Node], objectSize]};  Sort: PROC [seq: FreeSeq] = {    i: CARDINAL;    SiftUp: PROC [low, high: CARDINAL] = {      k, son: CARDINAL;      k ¬ low;      DO        IF k*2 > high THEN EXIT;        IF k*2+1 > high OR seq[k*2+1-1] < seq[k*2-1] THEN son ¬ k*2        ELSE son ¬ k*2+1;        IF seq[son-1] < seq[k-1] THEN EXIT;	Exchange[son-1, k-1];        k ¬ son;        ENDLOOP};    Exchange: PROC [a, b: CARDINAL] = {      temp: Node ¬ seq[a];      seq[a] ¬ seq[b];  seq[b] ¬ temp};    FOR i DECREASING IN [1..seq.length/2] DO SiftUp[i, seq.length] ENDLOOP;    FOR i DECREASING IN [1..seq.length) DO      Exchange[0, i];  SiftUp[1, i] ENDLOOP};    InSeq: PROC [node: Node, seq: FreeSeq] RETURNS [BOOLEAN] = {    i, l, u: CARDINAL;    l ¬ 1;    u ¬ seq.length;    DO      IF u < l THEN RETURN[FALSE];      i ¬ (l + u)/2;      SELECT seq[i-1] FROM	< node => l ¬ i + 1;	> node => u ¬ i - 1;	ENDCASE => RETURN[TRUE];      ENDLOOP};            EnumerateLargeNodes: PUBLIC PROCEDURE [    largeNode: LargeNode, proc: NodeEnumProc, filter: Filter]    RETURNS [BOOLEAN] = {    node: NodeHandle;    vLN: LargeNode;    length: CARDINAL;    UNTIL largeNode = NIL DO      vLN ¬ VirtualLargeNode[largeNode];      length ¬ vLN.nodeHeader.length;      node ¬ LOOPHOLE[@largeNode.node];      IF UseThisNode[node, length-1, filter] AND proc[node, length-1, TRUE] THEN        RETURN[TRUE];      largeNode ¬ vLN.next;      ENDLOOP;    RETURN[FALSE]};  UseThisNode: PROCEDURE [    n: NodeAddress, length: CARDINAL, filter: Filter]    RETURNS [BOOLEAN] =    BEGIN OPEN filter;    IF filter = noFilter THEN RETURN[TRUE];    IF size # 0 AND size # length THEN RETURN[FALSE];    IF swapStatus # inOrOut AND (swapStatus = in) # In[n] THEN RETURN[FALSE];    IF clientWords = 0 THEN RETURN[TRUE];    IF values = NIL OR values.maxlength = 0 THEN RETURN[TRUE];    {    words: Words;    match: BOOLEAN ¬ FALSE;    words ¬ z.NEW[WordSeq[clientWords]];    Copy[to: words, from: n, count: clientWords];    FOR j: CARDINAL IN [0..values.maxlength) UNTIL match DO      match ¬ TRUE;      FOR i: CARDINAL IN [0..clientWords) WHILE match DO        IF mask = NIL AND words[i] # values[j][i] THEN match ¬ FALSE        ELSE          IF Inline.BITAND[mask[i], words[i]] # values[j][i] THEN match ¬ FALSE;        ENDLOOP;      ENDLOOP;    z.FREE[@words];    RETURN[match]};    END;  EnumerateNodesInSegment: PROC [    node, maxNode: NodeHandle, proc: NodeEnumProc, filter: Filter]    RETURNS [BOOLEAN] = {    vNode: NodeHandle ¬ VirtualNodeHandle[node];    nodeLength: CARDINAL;    DO      IF UserInput.UserAbort[NIL] THEN ERROR ABORTED;      IF (nodeLength ¬ vNode.length) = UsedNodeSize THEN EXIT;      IF UseThisNode[node+1, nodeLength-1, filter]        AND proc[node+1, nodeLength-1, vNode.state = inuse] THEN RETURN[TRUE];      IF nodeLength = 0 OR maxNode < (node ¬ node + nodeLength) THEN EXIT;      vNode ¬ VirtualNodeHandle[node];      ENDLOOP;    RETURN[FALSE]};  EnumerateNodesInZone: PROC [    zH: Zone.Handle, proc: NodeEnumProc, filter: Filter]    RETURNS [BOOLEAN] = {    z: ZoneInternal.ZonePointer ¬ LOOPHOLE[zH];    vZonePointer: ZonePointer = VirtualZonePointer[z];    base: OrderedBase ¬ vZonePointer.zoneBase;    segment: SegmentPointer;    node: NodeHandle ¬ LOOPHOLE[z+SIZE[ZoneHeader]];    IF EnumerateNodesInSegment[      node, node+vZonePointer.length, proc, filter] THEN RETURN[TRUE];    segment ¬ vZonePointer.nextSegment;    UNTIL segment = LOOPHOLE[Zone.nullSegment, ZoneInternal.SegmentPointer] DO      segH: SegmentHandle = LOOPHOLE[@base[segment]];      vSegH: SegmentHandle = VirtualSegmentHandle[segH];      node ¬ LOOPHOLE[segH+SIZE[SegmentHeader]];      IF EnumerateNodesInSegment[        node, node+vSegH.length, proc, filter] THEN RETURN[TRUE];      segment ¬ vSegH.nextSegment;      ENDLOOP;    RETURN[FALSE]};  EnumerateChunks: PUBLIC PROCEDURE [heap: Handle, proc: ChunkEnumProc]    RETURNS [BOOLEAN] = {    vHeap: Handle ¬ VirtualHandle[heap];    WITH h: vHeap SELECT FROM      uniform => {        block: Block ¬ h.blocks;	UNTIL block = NIL DO	  vBlock: Block = VirtualBlock[block];	  IF proc[block, vBlock.length] THEN RETURN[TRUE];	  block ¬ vBlock.next;	  ENDLOOP};      normal => {        zone: ZoneHandle ¬ h.zones;	UNTIL zone = NIL DO	  vZoneHandle: ZoneHandle = VirtualZoneHandle[zone];	  IF proc[zone, vZoneHandle.length] THEN RETURN[TRUE];	  zone ¬ vZoneHandle.next;	  ENDLOOP};      mds => RETURN[EnumerateSegmentsInZone[h.zH, proc]];      ENDCASE => ERROR InvalidHeap;    RETURN[FALSE]};  EnumerateSegmentsInZone: PROC [zH: Zone.Handle, proc: ChunkEnumProc]    RETURNS [BOOLEAN] = {    z: ZoneInternal.ZonePointer ¬ LOOPHOLE[zH];    vZonePointer: ZonePointer = VirtualZonePointer[z];    base: OrderedBase ¬ vZonePointer.zoneBase;    segment: SegmentPointer;    IF proc[z, vZonePointer.length] THEN RETURN[TRUE];    segment ¬ vZonePointer.nextSegment;    UNTIL segment = LOOPHOLE[Zone.nullSegment, ZoneInternal.SegmentPointer] DO      segH: SegmentHandle = LOOPHOLE[@base[segment]];      vSegH: SegmentHandle = VirtualSegmentHandle[segH];      IF proc[segH, vSegH.length] THEN RETURN[TRUE];      segment ¬ vSegH.nextSegment;      ENDLOOP;    RETURN[FALSE]};  Copy: PUBLIC PROCEDURE [to, from: LONG POINTER, count: CARDINAL] =    BEGIN    DebugUsefulDefs.LongCopyREAD[to: to, from: from, nwords: count]    END;  Read: PUBLIC PROCEDURE [from: LONG POINTER] RETURNS [UNSPECIFIED] =    BEGIN    RETURN[DebugUsefulDefs.LongREAD[from]]    END;  In: PROC [loc: LONG POINTER] RETURNS [BOOLEAN] = INLINE {    RETURN[DebugUsefulDefsExtras2.GetPageState[Space.PageFromLongPointer[loc]].swapState = in]};  CheckAddress: PUBLIC PROC [p: LONG UNSPECIFIED] = {};  CheckGFH: PUBLIC PROC [gf: DebugUsefulDefs.GFHandle] RETURNS [ok: BOOLEAN] =    BEGIN    mod: STRING ¬ [40];    ok ¬ TRUE;    DebugUsefulDefs.Name[mod, gf       ! DebugUsefulDefs.InvalidFrame => {ok ¬ FALSE; CONTINUE}];    IF ok AND String.EqualString[mod, "HeapImpl"L]      THEN ok ¬ DebugUsefulDefs.Started[gf];    END;      SetupHeapImpl: PUBLIC PROCEDURE [heapGFH: DebugUsefulDefs.GFHandle] = {    heapImplModule: POINTER TO FRAME[HeapImpl];    IF heapGFH # NIL THEN stuff.heapImpl ¬ heapGFH    ELSE       stuff.heapImpl ¬ DebugUsefulDefs.Frame["HeapImpl"L !        DebugUsefulDefs.NotFound => {stuff.heapImpl ¬ NIL; CONTINUE};        DebugUsefulDefs.MultipleFrames => {stuff.heapImpl ¬ list[0]; CONTINUE}];    IF stuff.heapImpl = NIL THEN ERROR InvalidHeap;    heapImplModule ¬ LOOPHOLE[stuff.heapImpl];    Copy[      to: @stuff.systemZone,      from: @heapImplModule.systemZone,      count: SIZE[UNCOUNTED ZONE]];    Copy[      to: @stuff.systemMDS,      from: @heapImplModule.systemMDSZone,      count: SIZE[MDSZone]];    RETURN}; END...
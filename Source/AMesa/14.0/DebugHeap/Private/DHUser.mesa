-- File: DHUser.mesa - last edit: -- Karlton,	20-Nov-81 19:54:21-- Smokey,	 9-Feb-81 12:12:10-- Mark,	11-Mar-81  0:57:34-- Bruce,	17-Dec-80 11:48:48-- JGS on	 9-Dec-82 11:11:13-- Saaranzin	25-Jul-84 18:32:01DIRECTORY  DH,  Event USING [aboutToSwap, swapping],  EventTypes USING [newSession],  Exec USING [AddCommand, ExecProc, RemoveCommand],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType, DisplayItem,     Enumerated, EnumeratedItem, ItemHandle, line0, line1, line2,     LongNumberItem, EnumeratedNotifyProcType, LongNumberNotifyProcType,    NumberItem, StringItem],  Heap USING [Create, Delete],  Menu USING [Handle, Instantiate, Make, MCRType],  Put USING [LongOctal, Text],  Runtime USING [GetBcdTime],  String USING [AppendString],  Supervisor USING [    AddDependency, AgentProcedure, CreateSubsystem, DeleteSubsystem,    EnumerationAborted, RemoveDependency, SubsystemHandle],  Time USING [Append, Unpack],  Tool USING [    Create, Destroy, MakeFileSW, MakeFormSW, MakeSWsProc, UnusedLogName],  ToolDriver USING [Address, NoteSWs, RemoveSWs],  ToolFont USING [StringWidth],  ToolWindow USING [Activate, TransitionProcType],  UserTerminal USING [BlinkDisplay],  Window USING [Handle];DHUser: PROGRAM  IMPORTS    DH, Event, Exec, FormSW, Heap, Menu, Put, Runtime, String, Supervisor,    Time, Tool, ToolDriver, ToolFont, ToolWindow, UserTerminal  EXPORTS DH =  BEGIN OPEN DH;  --  TYPES and stuff  itemsPerLine: CARDINAL = 8;  TwoChars: TYPE = RECORD [lh: CHARACTER, rh: CHARACTER];   --  global variable declarations  agent, swapAgent: Supervisor.SubsystemHandle;  toolWindow: Window.Handle;  heapData: PUBLIC DH.ToolData ¬ NIL;  z: UNCOUNTED ZONE;  --  global constant declarations  --  Menu and Form routines  BadAddress: PROCEDURE [address: LONG POINTER] =    BEGIN OPEN heapData;    Put.Text[logSW, "*** InvalidAddress = "L];    Put.LongOctal[logSW, address];    Put.Text[logSW, " ***\n"L];    END;  --  Initialization And Transition stuff  DoTransition: ToolWindow.TransitionProcType = {    SELECT TRUE FROM      old = inactive =>        IF heapData = NIL THEN {          z ¬ Heap.Create[initial: 4];          heapData ¬ z.NEW[DH.HeapData ¬ []];          heapData.zone ¬ z;	  agent ¬ Supervisor.CreateSubsystem[agent: Notify];	  agent.AddDependency[implementor: Event.swapping];	  swapAgent ¬ Supervisor.CreateSubsystem[agent: WatchForSwap];	  swapAgent.AddDependency[implementor: Event.aboutToSwap];	  DH.InitDHHeaps[heapData];	  DH.InitDHCommands[heapData]};      new = inactive =>        IF heapData # NIL THEN {          Heap.Delete[z];          ToolDriver.RemoveSWs["DebugHeap"L];          z ¬ NIL;	  heapData ¬ NIL;	  agent.RemoveDependency[implementor: Event.swapping];	  agent.DeleteSubsystem[];	  swapAgent.RemoveDependency[implementor: Event.aboutToSwap];	  swapAgent.DeleteSubsystem[];          DH.FinishDHHeaps[];	  DH.FinishDHCommands[]};      ENDCASE};  MakeForm: FormSW.ClientItemsProcType =    BEGIN OPEN DH, heapData, FormSW;    nItems: CARDINAL = 9;    e0: ARRAY [0..4) OF Enumerated ¬ [      ["systemMDS"L, Mode[systemMDS]], ["system"L, Mode[system]], [      "heap"L, Mode[heap]], ["heapMDS"L, Mode[heapMDS]]];    e1: ARRAY [0..3) OF Enumerated ¬ [      ["inOrOut"L, SwapStatus[inOrOut]], ["in"L, SwapStatus[in]], [      "out"L, SwapStatus[out]]];    items ¬ AllocateItemDescriptor[FormIndex.LAST.ORD+1];    items[FormIndex.heap.ORD] ¬ EnumeratedItem[      tag: "heap"L, place: [0, line0], feedback: one, proc: HeapModeAltered,      value: @mode, choices: DESCRIPTOR[e0]];    items[FormIndex.address.ORD] ¬ LongNumberItem[      tag: "address"L, place: [-5, line0], proc: HeapAddressAltered,      radix: octal, signed: FALSE, notNegative: TRUE, value: @address];    swapStatus ¬ inOrOut;    items[FormIndex.swapped.ORD] ¬ EnumeratedItem[      tag: "swapped"L, place: [0, line1], feedback: one, value: @swapStatus,      choices: DESCRIPTOR[e1]];    items[FormIndex.validate.ORD] ¬ BooleanItem[      tag: "ValidateNodes"L, place: [-5, line1], switch: @validate];    items[FormIndex.delta.ORD] ¬ BooleanItem[tag: "Delta's"L, place: [-5, line1], switch: @deltas];    items[FormIndex.cWords.ORD] ¬ NumberItem[      tag: "clientWords"L, place: [0, line2], radix: octal, signed: FALSE,      notNegative: TRUE, value: @clientWords];    clientValue ¬ NIL;    items[FormIndex.cValue.ORD] ¬ StringItem[      tag: "clientValue"L, place: [-5, line2], inHeap: TRUE,      boxWidth: ToolFont.StringWidth["123456B 123456B 123456B "L],      string: @clientValue];    items[FormIndex.mask.ORD] ¬ NumberItem[      tag: "mask"L, place: [-5, line2], radix: octal, signed: FALSE,      notNegative: TRUE, value: @mask];    mask ¬ 177774B;    RETURN[items, TRUE];    END;  MakeMenu: PROCEDURE RETURNS [menu: Menu.Handle] =    BEGIN    keys: ARRAY MenuCmd OF LONG STRING ¬ [      ascii: "AsciiContents"L, clear: "ClearState"L, client: "ClientWords"L,      nodeOwners: "Nodes+Totals"L, nodes: "ShowNodes"L,      nodesOfSize: "NodesOfSize"L, octal: "OctalContents"L,      ownerTotals: "Totals"L, save: "SaveState"L, segments: "ShowSegments"L,      setGfh: "Set Heap GFH"L, freeNodes: "FreeNodes"L];    menu ¬ Menu.Make[      name: "HeapOps"L,      strings: LOOPHOLE[DESCRIPTOR[keys], DESCRIPTOR FOR ARRAY OF LONG STRING],      mcrProc: MCR, copyStrings: TRUE, permanent: FALSE];    END;  MakeSWs: Tool.MakeSWsProc =    BEGIN OPEN heapData;    logName: STRING ¬ [40];    addresses: ARRAY [0..2) OF ToolDriver.Address ¬ [      ["formSW"L, formSW], ["logSW"L, logSW]];    formSW ¬ Tool.MakeFormSW[window, MakeForm];    Tool.UnusedLogName[unused: logName, root: "DebugHeap.log"L];    logSW ¬ Tool.MakeFileSW[window, logName];    Menu.Instantiate[MakeMenu[], window];    ToolDriver.NoteSWs["DebugHeap"L, DESCRIPTOR[addresses]];    SetupPointers[NIL];    END;  Notify: Supervisor.AgentProcedure =    BEGIN    IF event = EventTypes.newSession AND heapData # NIL THEN {      heapData.lookup ¬ TRUE;      heapData.currentHeap ¬ NIL;      FormSW.DisplayItem[heapData.formSW, 0]};    END;  WatchForSwap: Supervisor.AgentProcedure =    BEGIN    IF heapData.toolIsBusy THEN {      Put.Text[NIL, "\nDebugHeap busy!"L];      UserTerminal.BlinkDisplay[];      ERROR Supervisor.EnumerationAborted};    END;  DebugHeapCommand: Exec.ExecProc = {ToolWindow.Activate[toolWindow]};  Die: Exec.ExecProc = {    IF toolWindow # NIL THEN Tool.Destroy[toolWindow];    [] ¬ Exec.RemoveCommand[h, "DebugHeap.~"L]};  --  Mainline code  Init: PROC =    BEGIN    s: STRING = [40];    String.AppendString[s, "Debug Heap of "L];    Time.Append[s, Time.Unpack[Runtime.GetBcdTime[]]];    toolWindow ¬ Tool.Create[      makeSWsProc: MakeSWs, name: s, clientTransition: DoTransition,      initialState: default, movableBoundaries: TRUE,      cmSection: "DebugHeap"L];    Exec.AddCommand[name: "DebugHeap.~"L, proc: DebugHeapCommand, unload: Die];    END;  Init[];  END...
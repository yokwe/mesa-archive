-- file Pass1F.mesa rewritten by PGS,  9-Jan-87 16:53-- file Pass1F.mesa rewritten by PGS, 12-Apr-85 16:15-- Copyright (C) 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- file Pass1F.mesa rewritten by PGS,  4-Oct-84 17:55-- file Pass1F.mesa rewritten by PGS, 14-Jun-84 20:22-- last modified by--		Karlton,		 2-Mar-82 23:56:28--		Lewis,			21-Jan-82 19:17:05--		Sweet,			 7-Nov-83 13:06:12--		Rhonda,			 5-Oct-82 14:23:29--		Wagner,			12-Apr-85 15:52:55DIRECTORY  Style USING [    AppendToken, catchDepth, InsertToken, InsertString, ItemHandle, ItemNotString,    LineBreak, MaxItem, NextItem, nullItem, PreviousItem, PrintItems, StringToken,    Token],  P1,  ParseTable USING [ActionEntry, ProdDataRef, TSymbol, tokenID],  Symbols USING [HTNull];Pass1T: PROGRAM IMPORTS Style EXPORTS Style, P1 =  BEGIN  -- parse tree building  -- local data base (supplied by parser)<<  ItemSeq: TYPE = RECORD [SEQUENCE length: NAT OF Style.ItemHandle];  ItemStack: TYPE = LONG POINTER TO ItemSeq; >>    ItemStack: TYPE = LONG DESCRIPTOR FOR ARRAY OF Style.ItemHandle;  v: ItemStack;  l: ItemStack;  q: P1.ActionStack;  prodData: ParseTable.ProdDataRef;  procBlock: BOOLEAN ¬ FALSE;  procedureDecl: BOOLEAN ¬ FALSE;  nil: Style.ItemHandle = Style.nullItem;  BC: Style.Token = [begin[breakType: consistent]];  BC0: Style.Token = [begin[breakType: consistent, offset: 0]];  BI: Style.Token = [begin[breakType: inconsistent]];  BI0: Style.Token = [begin[breakType: inconsistent, offset: 0]];  E: Style.Token = [end[]];  SP: Style.Token = [break[blankSpace: 1]];  ISP: Style.Token = [break[blankSpace: 1, inconsistent: TRUE]];  Break: Style.Token = [break[blankSpace: 0]];  BP: Style.Token = [beforeProc[]];  AP: Style.Token = [afterProc[]];  -- initialization/termination  AssignDescriptors: PUBLIC PROC [      qd: P1.ActionStack, vd: P1.ValueStack, ld: P1.LinkStack,      pp: ParseTable.ProdDataRef] = {    q ¬ qd; v ¬ LOOPHOLE[DESCRIPTOR[vd­]];    l ¬ LOOPHOLE[DESCRIPTOR[ld­]]; prodData ¬ pp};  -- enable formatting  CanFormat: PUBLIC PROCEDURE RETURNS [BOOLEAN] = {RETURN[TRUE]};  Bold: PROCEDURE [item: Style.ItemHandle] = {    Style.StringToken[item].look ¬ bold};  Small: PROCEDURE [item: Style.ItemHandle] = {    Style.StringToken[item].look ¬ small};  SmallBold: PROCEDURE [item: Style.ItemHandle] = {    Style.StringToken[item].look ¬ smallbold};  -- error recovery  TokenValue: PUBLIC PROCEDURE [s: ParseTable.TSymbol] RETURNS [UNSPECIFIED] =    BEGIN OPEN ParseTable;    RETURN[SELECT s FROM tokenID => Symbols.HTNull, ENDCASE => 0]    END;  -- the interpretation rules  ProcessQueue: PUBLIC PROCEDURE [qI, top: CARDINAL] =    BEGIN OPEN Style;    vTop: ItemHandle;    rule: [0..377B];    FOR i: CARDINAL IN [0..qI) DO      top ¬ top - q[i].tag.pLength + 1;      vTop ¬ v[top];      rule ¬ prodData[q[i].transition].rule;      SELECT rule FROM        -- basic tree building       0  =>  -- TYPE: ParseTable          -- TABLE: MesaTab      EXPORTS: SELF          -- GOAL:  goal          --TERMINALS:	  	      --  id  num  lnum  flnum  string  lstring  char atom	      --  ,  ;  :  ..  =>  _	      --  =  #  <  >  <=  >=  ~	      --  +  -  *  /  ^  .  @  !  '|	      --  RECORD  POINTER  VAR	      --  ARRAY  SEQUENCE  DESCRIPTOR	      --  PROCEDURE  PROC  PORT  SIGNAL  ERROR  PROCESS	      --  PROGRAM  MONITOR  DEFINITIONS  ZONE  RELATIVE  LONG	      --  TYPE  FRAME  TO  ORDERED  UNCOUNTED	      --  BASE  OF  PACKED  RETURNS RESIDENT	      --  MONITORED  OVERLAID  COMPUTED  MACHINE  DEPENDENT	      --  DIRECTORY  IMPORTS  EXPORTS  SHARES  LOCKS  USING	      --  PUBLIC  PRIVATE	      --  ENTRY  INTERNAL  INLINE  READONLY  CODE	      --  ABS  ALL  AND  APPLY  MAX  MIN  MOD	      --  NOT  OR  ORD  PRED  LENGTH  NEW  START  SUCC  VAL	      --  FORK  JOIN  LOOPHOLE  NARROW  ISTYPE   SIZE	      --  FIRST  LAST  NIL  TRASH  NULL  IF  THEN  ELSE	      --  WITH  FROM  FOR  DECREASING  IN	      --  THROUGH  UNTIL  WHILE  REPEAT  FINISHED	      --  RETURN  EXIT  LOOP  GOTO  GO	      --  FREE  WAIT  RESTART  NOTIFY  BROADCAST  STOP	      --  RESUME  REJECT  CONTINUE  RETRY  TRANSFER  STATE	      --  OPEN  ENABLE  ANY  EXITS	      --  )  ]  }  END  ENDLOOP  ENDCASE	      --  (  [  {  BEGIN  DO  SELECT	  	    --ALIASES:	      --  id       tokenID	      --  num      tokenNUM	      --  lnum     tokenLNUM	      --  flnum    tokenFLNUM	      --  string   tokenSTR	      --  lstring  tokenLSTR	      --  char     tokenCHAR	      --  atom     tokenATOM	      --  -        tokenMINUS	      --  .        tokenDOT	      --  ..       tokenDOTS	      --  =        tokenEQUAL	      --  =>       tokenARROW	      --  <        tokenLESS	      --  <=       tokenLE	      --  >        tokenGREATER	      --  >=       tokenGE	      --  #        tokenNE	      --  .        InitialSymbol	      	                --PRODUCTIONS:          -- goal	::= . unit .           -- goal	::= . unit ..           BEGIN AppendToken[l[top + 2], [eof[]]]; PrintItems[l[top + 2]]; END;        IN [1..25] => vTop ¬ PQ1[rule, top, vTop];        IN [26..50] => vTop ¬ PQ26[rule, top, vTop];        IN [51..75] => vTop ¬ PQ51[rule, top, vTop];        IN [76..100] => vTop ¬ PQ76[rule, top, vTop];        IN [101..126] => vTop ¬ PQ101[rule, top, vTop];        IN [127..151] => vTop ¬ PQ127[rule, top, vTop];        IN [152..176] => vTop ¬ PQ152[rule, top, vTop];        IN [177..201] => vTop ¬ PQ177[rule, top, vTop];        IN [202..251] => vTop ¬ PQ202[rule, top, vTop];        ENDCASE => vTop ¬ PQ252[rule, top, vTop];      v[top] ¬ vTop;      ENDLOOP;    END;  PQ1: PROCEDURE [rule: [0..377B], top: CARDINAL, vTop: Style.ItemHandle]    RETURNS [Style.ItemHandle] =    BEGIN OPEN Style;    SELECT rule FROM     1  =>  -- unit	::= dire module         NULL;	     2  =>    -- typecons	::= interval               -- typeid		::= typeid'              -- typecons	::= typeappl               -- element	::= id ( exp )               -- element	::= ( exp )              -- typelist	::= typecons              -- typelist	::= typeid              -- pointertype	::= pointerprefix              -- statement	::= block               -- binditem	::= exp              -- casetest	::= optrelation               -- casetest	::= exp               -- catchlist	::= catchhead              -- includelist	::= includeitem              -- modulelist	::= moduleitem              -- pairlist	::= pairitem              -- elementlist	::= element              -- variantlist	::= variantitem              -- bindlist	::= binditem              -- statementlist'	::= statement               -- declist	::= declaration               -- casestmtlist'	::= casestmtitem              -- exitlist'	::= exititem              -- orderlist	::= optexp               -- keylist	::= keyitem               -- caseexplist'	::= caseexpitem              -- idlist		::= idlist'              -- explist	::= orderlist              -- explist	::= keylist              -- typeexp	::= typeid               -- typeexp	::= typecons               -- defaultopt	::= exp               -- tagtype	::= typeexp               -- indextype	::= typeexp               -- arglist	::= fieldlist               -- initvalue	::= exp               -- statementlist	::= statementlist'               -- casestmtlist	::= casestmtlist'               -- caseexplist	::= caseexplist'               -- exitlist	::= exitlist'              -- optexp		::= exp               -- exp		::= disjunct               -- disjunct	::=C conjunct               -- conjunct	::=C negation               -- negation	::=C relation               -- relation	::=C sum               -- range		::= interval               -- range		::= typeid               -- sum		::=C product               -- product	::=C factor               -- factor		::=C primary               -- primary	::=C lhs               -- desclist	::= exp         NULL;	     3  =>  -- dire	::= directory includelist semicolon        BEGIN        AppendToken[l[top + 2], LineBreak];        AppendToken[l[top + 2], E];        vTop ¬ l[top + 2];        PrintItems[vTop];        END;     4  =>  -- directory	::= DIRECTORY         BEGIN        Small[vTop ¬ l[top]];        InsertToken[vTop, LineBreak];        InsertToken[vTop, BC];        AppendToken[vTop, LineBreak];        END;     5  =>  -- includeitem	::= idcolon FROM string using            -- includeitem	::= idcolon TYPE id using        BEGIN        Small[l[top + 1]];        AppendToken[l[top + 1], SP];        AppendToken[vTop ¬ MaxItem[l[top + 2], v[top + 3]], E];        END;     6  =>  -- idcolon	::= id :         {InsertToken[l[top], BI]; AppendToken[vTop ¬ l[top + 1], SP]};     7  =>  -- includeitem	::= idcolon TYPE using        {        Small[l[top + 1]];        AppendToken[vTop ¬ MaxItem[l[top + 1], v[top + 2]], E]};     8  =>  -- includeitem	::= id using        {        InsertToken[l[top], BI];        AppendToken[vTop ¬ MaxItem[l[top], v[top + 1]], E]};     9  =>  -- using	::= USING [ ]        BEGIN        Small[l[top]];        InsertToken[l[top], SP];        AppendToken[l[top], SP];        vTop ¬ l[top + 2];        END;    10  =>  -- module	::= moduleidlist classhead block             -- module	::= moduleidlist defhead defbody         BEGIN AppendToken[vTop ¬ v[top + 2], E]; PrintItems[vTop]; END;     11  =>  -- moduleidlist	::= identlist         FOR item: ItemHandle ¬ l[top], NextItem[item] UNTIL item = vTop DO          Bold[item ! Style.ItemNotString => CONTINUE] ENDLOOP;     12  =>  -- classhead	::= resident PROGRAM arguments interface = public         BEGIN        Small[l[top + 1]];        AppendToken[l[top + 1], SP];        InsertToken[l[top + 4], SP];        vTop ¬ MaxItem[l[top + 4], v[top + 5]];	IF vTop = v[top + 5] THEN InsertToken[vTop, SP];        AppendToken[vTop, LineBreak];        END;     13  =>  -- classhead	::= resident MONITOR arguments locks interface = public         BEGIN        Small[l[top + 1]];        AppendToken[l[top + 1], SP];        InsertToken[l[top + 5], SP];        vTop ¬ MaxItem[l[top + 5], v[top + 6]];	IF vTop = v[top + 6] THEN InsertToken[vTop, SP];        AppendToken[vTop, LineBreak];        END;     14  =>  -- resident	::= RESIDENT         {Small[l[top]]; AppendToken[l[top], SP]; vTop ¬ l[top]};     15  =>  -- resident	::=         vTop ¬ nil;     16  =>  -- defhead	::= definitions locks imports shares = public         BEGIN        AppendToken[l[top], SP];        InsertToken[l[top + 4], SP];        vTop ¬ MaxItem[l[top + 4], v[top + 5]];	IF vTop = v[top + 5] THEN InsertToken[vTop, SP];        AppendToken[vTop, LineBreak];        END;     17  =>  -- definitions	::= DEFINITIONS         Small[vTop ¬ l[top]];     18  =>  -- defbody	::= begin open declist END              -- defbody	::= brace open declist }         BEGIN        AppendToken[vTop ¬ l[top + 3], Break];        IF StringToken[vTop].length > 1 THEN {InsertToken[vTop, SP]; Small[vTop]};        AppendToken[vTop, E];        PrintItems[vTop];        END;     19  =>  -- defbody	::= begin open declist semicolon END              -- defbody	::= brace open declist semicolon }         BEGIN        AppendToken[vTop ¬ l[top + 4], Break];        IF StringToken[vTop].length > 1 THEN {InsertToken[vTop, SP]; Small[vTop]};        AppendToken[vTop, E];        PrintItems[vTop];        END;     20  =>  -- begin	::= BEGIN             -- brace	::= {        BEGIN        IF StringToken[vTop ¬ l[top]].length > 1 THEN {          InsertToken[vTop, BC0]; AppendToken[vTop, SP]; Small[vTop]}        ELSE {AppendToken[vTop, Break]; AppendToken[vTop, BC0]; };        END;     21  =>  -- locks	::= LOCKS primary        BEGIN Small[l[top]]; AppendToken[l[top], SP]; vTop ¬ v[top + 1]; END;     22  =>  -- locks	::= LOCKS primary USING id : typeexp        BEGIN        Small[l[top]];        Small[l[top + 2]];        AppendToken[l[top], SP];        InsertToken[l[top + 2], SP];        AppendToken[l[top + 2], SP];        AppendToken[l[top + 4], SP];        vTop ¬ v[top + 5];        END;     23  =>  -- moduleitem	::= id         vTop ¬ l[top];     24  =>  -- moduleitem	::= idcolon id         AppendToken[vTop ¬ l[top + 1], E];     25  =>  -- declaration	::= declfront initialization         AppendToken[vTop ¬ MaxItem[vTop, v[top + 1]], E];      ENDCASE => ERROR;    RETURN[vTop];    END;  PQ26: PROCEDURE [rule: [0..377B], top: CARDINAL, vTop: Style.ItemHandle]    RETURNS [Style.ItemHandle] =    BEGIN OPEN Style;    SELECT rule FROM     26  =>  -- declfront	::= identlist public readonly entry typeexp         BEGIN        IF procedureDecl THEN          BEGIN          FOR item: ItemHandle ¬ l[top], NextItem[item] UNTIL item = vTop DO            Bold[item ! Style.ItemNotString => CONTINUE] ENDLOOP;          procedureDecl ¬ FALSE;          InsertToken[l[top], BP];          END;        vTop ¬ v[top + 4];        END;     27  =>  -- declaration	::= identlist public TYPE = public typeexp default         BEGIN        Small[l[top + 2]];        AppendToken[l[top + 2], SP];        AppendToken[l[top + 3], SP];        vTop ¬ MaxItem[v[top + 5], v[top + 6]];        AppendToken[vTop, E];        END;     28  =>  -- declaration	::= identlist public TYPE optargs         BEGIN        Small[l[top + 2]];        vTop ¬ MaxItem[l[top + 2], v[top + 3]];        IF vTop # l[top + 2] THEN AppendToken[l[top + 2], SP];        AppendToken[vTop, E];        END;     29  =>  -- public	::= PUBLIC             -- public	::= PRIVATE             -- entry	::= ENTRY             -- entry	::= INTERNAL        {Small[vTop ¬ l[top]]; AppendToken[vTop, SP]};     30  =>  --  procaccess	::=             -- public	::=              -- entry	::=         vTop ¬ nil;     31  =>  -- idlist'	::= id         vTop ¬ l[top];     32  =>  -- identlist'	::= id :         AppendToken[vTop ¬ l[top + 1], SP];     33  =>  -- identlist'	::= id position :         AppendToken[vTop ¬ l[top + 2], SP];     34  =>  -- idlist'	::= id , idlist'              -- identlist'	::= id , identlist'         {AppendToken[l[top + 1], SP]; vTop ¬ v[top + 2]};     35  =>  -- identlist'	::= id position , identlist'         {AppendToken[l[top + 2], SP]; vTop ¬ v[top + 3]};     36  =>  -- position	::= ( exp optbits )         {InsertToken[l[top], BI]; AppendToken[vTop ¬ l[top + 3], E]};     37  =>  -- optbits	::= : bounds         vTop ¬ v[top + 1];     38  =>  -- interval	::= [ bounds ]              -- interval	::= [ bounds )              -- interval	::= ( bounds ]              -- interval	::= ( bounds )         {InsertToken[l[top], BI]; AppendToken[vTop ¬ l[top + 2], E]};     39  =>  -- typeexp	::= id              -- range	::= id        vTop ¬ l[top];     40  =>  -- typeid'	::= id . id              -- typeid'	::= typeid' . id        {vTop ¬ l[top + 2]};     41  =>  -- typeid	::= id id         {AppendToken[l[top], SP]; vTop ¬ l[top + 1]};     42  =>  -- typeid		::= id typeid              -- typecons	::= id interval              -- range		::= id interval             -- typecons	::= typeid interval              -- range		::= typeid interval        {AppendToken[l[top], SP]; vTop ¬ v[top + 1]};     43  =>  -- typeappl	::= id length              -- typeappl	::= typeid length              -- typeappl	::= typeappl length         {AppendToken[l[top], SP]; vTop ¬ v[top + 1]};     44  =>  -- typeappl	::= typeappl . id         vTop ¬ v[top + 2];     45  =>  -- typecons	::= VAR typeexp         {Small[l[top]]; AppendToken[l[top], SP]; vTop ¬ v[top + 1]};     46  =>  -- typecons	::= dependent { elementlist }        BEGIN        AppendToken[l[top + 1], BI0];        AppendToken[l[top + 1], Break];        AppendToken[vTop ¬ l[top + 3], E];        END;     47  =>  -- ident	::= id position :        AppendToken[vTop ¬ l[top + 2], SP];     48  =>  -- typecons	::= dependent monitored RECORD reclist        BEGIN        Small[l[top + 2]];        InsertToken[l[top + 2], SP];        AppendToken[l[top + 2], SP];        vTop ¬ v[top + 3];        END;     49  =>  -- typecons	::= ordered base pointertype        BEGIN        IF vTop # nil THEN NULL        ELSE          IF v[top + 1] # nil THEN l[top] ¬ l[top + 1] ELSE l[top] ¬ l[top + 2];        vTop ¬ v[top + 2];        END;     50  =>  -- typecons	::= packed ARRAY indextype OF typeexp        BEGIN        Small[l[top + 1]];        AppendToken[l[top + 1], SP];        Small[l[top + 3]];        InsertToken[l[top + 3], SP];        AppendToken[l[top + 3], SP];        vTop ¬ v[top + 4];        END;      ENDCASE => ERROR;    RETURN[vTop];    END;  PQ51: PROCEDURE [rule: [0..377B], top: CARDINAL, vTop: Style.ItemHandle]    RETURNS [Style.ItemHandle] =    BEGIN OPEN Style;    SELECT rule FROM     51  =>  -- typecons	::= DESCRIPTOR FOR readonly typeexp        BEGIN        Small[l[top]];        Small[l[top + 1]];        AppendToken[l[top], SP];        AppendToken[l[top + 1], SP];        vTop ¬ v[top + 3];        END;     52  =>  -- typecons	::= transfermode arguments        vTop ¬ MaxItem[vTop, v[top + 1]];     53  =>  -- typecons	::= id RELATIVE typeexp             -- typecons	::= typeid RELATIVE typeexp        BEGIN        Small[l[top + 1]];        InsertToken[l[top + 1], SP];        AppendToken[l[top + 1], SP];        vTop ¬ v[top + 2];        END;     54  =>  -- typecons	::= UNCOUNTED ZONE        {Small[l[top]]; InsertToken[vTop ¬ l[top + 1], SP]; Small[vTop]};     55  =>  -- typecons	::= LONG typeexp        BEGIN Small[l[top]]; AppendToken[l[top], SP]; vTop ¬ v[top + 1]; END;     56  =>  -- typecons	::= FRAME [ id ]        BEGIN Small[l[top]]; vTop ¬ l[top + 3]; END;     57  =>  -- monitored	::= MONITORED        Small[vTop ¬ l[top]];     58  =>  -- dependent	::= MACHINE DEPENDENT        {Small[l[top]]; AppendToken[l[top], SP]; Small[vTop ¬ l[top + 1]]};     59  =>  -- dependent	::=        vTop ¬ nil;     60  =>  -- reclist	::= [ ]        vTop ¬ l[top + 1];     61  =>  -- reclist	::= NULL        Small[vTop ¬ l[top]];     62  =>  -- reclist	::= [ pairlist ]             -- reclist	::= [ typelist ]             -- reclist	::= [ variantpart ]             -- reclist	::= [ variantpair ]        BEGIN        AppendToken[l[top], BC0];        AppendToken[l[top], Break];        AppendToken[vTop ¬ l[top + 2], E];        END;     63  =>  -- reclist	::= [ pairlist , variantpair ]        BEGIN        AppendToken[l[top], BC0];        AppendToken[l[top], Break];        AppendToken[l[top + 2], SP];        AppendToken[vTop ¬ l[top + 4], E];        END;     64  =>  -- pairitem	::= identlist public typeexp default             -- variantpair	::= identlist public variantpart default        BEGIN vTop ¬ MaxItem[v[top + 2], v[top + 3]]; AppendToken[vTop, E]; END;     65  =>  -- defaultopt	::=        vTop ¬ nil;     66  =>  -- defaultopt	::= NULL             -- defaultopt	::= TRASH             -- optexp		::= NULL             -- optexp		::= TRASH             -- initvalue	::= NULL             -- initvalue	::= TRASH             -- initvalue	::= CODE        Small[vTop ¬ l[top]];     67  =>  -- defaultopt	::= exp '| NULL             -- defaultopt	::= exp '| TRASH        BEGIN        InsertToken[l[top + 1], SP];        AppendToken[l[top + 1], SP];        Small[vTop ¬ l[top + 2]];        END;     68  =>  -- variantpart	::= SELECT vcasehead FROM variantlist ENDCASE        BEGIN        Small[l[top]];        Small[l[top + 2]];        Small[vTop ¬ l[top + 4]];        InsertToken[l[top], BI];        AppendToken[l[top], SP];        InsertToken[l[top + 2], SP];        AppendToken[l[top + 2], BC0];        AppendToken[l[top + 2], SP];        AppendToken[l[top + 2], E];        InsertToken[vTop, SP];        AppendToken[vTop, E];        END;     69  =>  -- variantpart	::= SELECT vcasehead FROM variantlist , ENDCASE        BEGIN        Small[l[top]];        Small[l[top + 2]];        Small[vTop ¬ l[top + 5]];        InsertToken[l[top], BI];        AppendToken[l[top], SP];        InsertToken[l[top + 2], SP];        AppendToken[l[top + 2], BC0];        AppendToken[l[top + 2], SP];        AppendToken[l[top + 2], E];        InsertToken[vTop, SP];        AppendToken[vTop, E];        END;     70  =>  -- variantpart	::= packed SEQUENCE vcasehead OF typeexp        BEGIN        InsertToken[MaxItem[vTop, l[top + 1]], BI];        Small[l[top + 1]];        AppendToken[l[top + 1], SP];        InsertToken[l[top + 3], SP];        Small[l[top + 3]];        AppendToken[l[top + 3], SP];        AppendToken[vTop ¬ v[top + 4], E];        END;     71  =>  -- vcasehead	::= ident public tagtype        vTop ¬ v[top + 2];     72  =>  -- vcasehead	::= COMPUTED tagtype             -- vcasehead	::= OVERLAID tagtype        {Small[l[top]]; AppendToken[l[top], SP]; vTop ¬ v[top + 1]};     73  =>  -- tagtype	::= *             -- typelist	::= id        vTop ¬ l[top];     74  =>  -- variantitem	::= idlist => reclist        BEGIN        InsertToken[l[top], BI];        InsertToken[l[top + 1], SP];        AppendToken[l[top + 1], SP];        vTop ¬ v[top + 2];        AppendToken[vTop, E];        END;     75  =>  -- typelist	::= id _ defaultopt        BEGIN        InsertToken[l[top + 1], SP];        AppendToken[l[top + 1], SP];        vTop ¬ v[top + 2];        END;      ENDCASE => ERROR;    RETURN[vTop];    END;  PQ76: PROCEDURE [rule: [0..377B], top: CARDINAL, vTop: Style.ItemHandle]    RETURNS [Style.ItemHandle] =    BEGIN OPEN Style;    SELECT rule FROM     76  =>  -- typelist	::= typecons , typelist             -- typelist	::= typeid , typelist             -- typelist	::= id , typelist        {AppendToken[l[top + 1], SP]; vTop ¬ v[top + 2]};     77  =>  -- typelist	::= id _ defaultopt , typelist        BEGIN        InsertToken[l[top + 1], SP];        AppendToken[l[top + 1], SP];	AppendToken[l[top + 3], SP];        vTop ¬ v[top + 4];        END;     78  =>  -- pointertype	::= pointerprefix TO readonly typeexp        BEGIN        Small[l[top + 1]];        InsertToken[l[top + 1], SP];        AppendToken[l[top + 1], SP];        IF v[top + 2] # nil THEN AppendToken[v[top + 2], SP];        vTop ¬ v[top + 3];        END;     79  =>  -- transfermode	::= PROCEDURE             -- transfermode	::= PROC             -- transfermode	::= SIGNAL             -- transfermode	::= ERROR             -- transfermode	::= PORT             -- transfermode	::= PROGRAM        {Small[vTop ¬ l[top]]; procedureDecl ¬ TRUE};     80  =>  -- transfermode	::= PROCESS        Small[vTop ¬ l[top]];     81  =>  -- initialization	::=        vTop ¬ nil;     82  =>  -- initvalue	::= procaccess inline block        {vTop ¬ v[top + 2]; procBlock ¬ TRUE};     83  =>  -- initvalue	::= MACHINE CODE begin codelist END             -- initvalue	::= MACHINE CODE brace codelist }        BEGIN        Small[l[top]];        AppendToken[l[top], SP];        Small[l[top + 1]];        AppendToken[l[top + 1], SP];        IF StringToken[vTop ¬ l[top + 4]].length > 1 THEN {          InsertToken[vTop, SP]; Small[vTop]};        AppendToken[vTop, E];        procBlock ¬ TRUE;        END;     84  =>  -- codelist	::= orderlist        IF vTop # nil THEN {InsertToken[l[top], BC]; AppendToken[vTop, E]};     85  =>  -- codelist	::= codelist semicolon orderlist        BEGIN        InsertToken[l[top + 2], BC];        AppendToken[vTop ¬ MaxItem[v[top + 1], v[top + 2]], E];        END;     86  =>  -- statement	::= lhs        {InsertToken[l[top], BI]; AppendToken[vTop, E]};     87  =>  -- statement	::= lhs _ exp         BEGIN        InsertToken[l[top], BI];        InsertToken[l[top + 1], SP];        AppendToken[l[top + 1], SP];        vTop ¬ v[top + 2];        AppendToken[vTop, E];        END;     88  =>  -- statement	::= [ explist ] _ exp         BEGIN        InsertToken[l[top], BI];        InsertToken[l[top], BI];        AppendToken[l[top + 2], E];        InsertToken[l[top + 3], SP];        AppendToken[l[top + 3], SP];        AppendToken[vTop ¬ v[top + 4], E];        END;     89  =>  -- statement	::= if exp then statement elsepart         BEGIN        IF v[top + 4] = nil THEN          BEGIN AppendToken[v[top + 3], E]; vTop ¬ v[top + 3]; END        ELSE vTop ¬ v[top + 4];        AppendToken[vTop, E];        END;     90  =>  -- if	::= IF         BEGIN        Small[l[top]];        InsertToken[l[top], BC0];        InsertToken[l[top], BI];        AppendToken[l[top], SP];        vTop ¬ l[top];        END;     91  =>  -- then	::= THEN         BEGIN        Small[l[top]];        InsertToken[l[top], SP];        AppendToken[l[top], SP];        vTop ¬ l[top];        END;     92  =>  -- statement	::= casehead casestmtlist endcase otherpart        {        AppendToken[vTop ¬ MaxItem[v[top + 2], v[top + 3]], E];        AppendToken[vTop, E]};     93  =>  -- endcase	::= ENDCASE         {Small[vTop ¬ l[top]]; InsertToken[vTop, SP]; InsertToken[vTop, BI]};     94  =>  -- statement	::= dofront scope doexit ENDLOOP         BEGIN        Small[vTop ¬ l[top + 3]];        InsertToken[vTop, SP];        AppendToken[vTop, E];        AppendToken[vTop, E];        END;     95  =>  -- dofront	::= forclause dotest DO         BEGIN        Small[l[top + 2]];        SELECT TRUE FROM          vTop = nil AND v[top + 1] = nil => l[top] ¬ l[top + 2];          vTop = nil AND v[top + 1] # nil =>            BEGIN l[top] ¬ l[top + 1]; InsertToken[l[top + 2], SP]; END;          vTop # nil AND v[top + 1] = nil =>            BEGIN InsertToken[l[top + 2], SP]; END;          vTop # nil AND v[top + 1] # nil =>            BEGIN InsertToken[l[top + 1], SP]; InsertToken[l[top + 2], SP]; END;          ENDCASE;        InsertToken[l[top], BI];        AppendToken[l[top + 2], BC0];        AppendToken[l[top + 2], SP];        vTop ¬ l[top + 2];        END;     96  =>  -- statement	::= EXIT              -- statement	::= LOOP         Small[vTop ¬ l[top]];     97  =>  -- statement	::= GOTO id         BEGIN        Small[l[top]];        InsertToken[l[top], BI];        AppendToken[l[top], SP];        vTop ¬ l[top + 1];        AppendToken[vTop, E];        END;     98  =>  -- statement	::= GO TO id         BEGIN        Small[l[top]];        Small[l[top + 1]];        InsertToken[l[top], BI];        AppendToken[l[top], SP];        AppendToken[l[top + 1], SP];        vTop ¬ l[top + 2];        AppendToken[vTop, E];        END;     99  =>  -- statement	::= RETURN optargs        BEGIN        Small[l[top]];        InsertToken[l[top], BI];        vTop ¬ MaxItem[l[top], v[top + 1]];        AppendToken[vTop, E];        END;    100  =>  -- statement	::= transfer lhs        {        InsertToken[l[top], BI];        AppendToken[vTop, SP];        AppendToken[vTop ¬ v[top + 1], E]};          ENDCASE => ERROR;    RETURN[vTop];    END;  PQ101: PROCEDURE [rule: [0..377B], top: CARDINAL, vTop: Style.ItemHandle]    RETURNS [Style.ItemHandle] =    BEGIN OPEN Style;    SELECT rule FROM     101  =>  -- statement	::= free [ exp optcatch ]        {InsertToken[l[top], BI]; AppendToken[vTop ¬ l[top + 4], E]};     102  =>  -- statement	::= WAIT lhs        BEGIN        Small[l[top]];        InsertToken[l[top], BI];        AppendToken[l[top], SP];        AppendToken[vTop ¬ v[top + 1], E];        END;     103  =>  -- statement	::= ERROR              -- statement	::= STOP              -- statement	::= NULL              -- statement	::= REJECT              -- statement	::= CONTINUE              -- statement	::= RETRY        Small[vTop ¬ l[top]];     104  =>  -- statement	::= RESUME optargs        BEGIN        Small[l[top]];        InsertToken[l[top], BI];        AppendToken[l[top], SP];        AppendToken[vTop ¬ MaxItem[l[top], v[top + 1]], E];        END;     105  =>  -- statement	::= lhs _ STATE        BEGIN        InsertToken[l[top], BI];        InsertToken[l[top + 1], SP];        AppendToken[l[top + 1], SP];        Small[l[top + 2]];        AppendToken[vTop ¬ l[top + 2], E];        END;     106  =>  -- statement	::= STATE _ lhs        BEGIN 	Small[l[top]];        InsertToken[l[top], BI];        InsertToken[l[top + 1], SP];        AppendToken[l[top + 1], SP];        Small[vTop ¬ l[top + 2]];        AppendToken[vTop, E];        END;     107  =>  -- block	::= begin scope exit END              -- block	::= brace scope exit }        BEGIN        AppendToken[vTop ¬ l[top + 3], E];        IF StringToken[vTop].length > 1 THEN {InsertToken[vTop, SP]; Small[vTop]};        PrintItems[vTop];        END;     108  =>  -- scope	::= open enables declist semicolon statementlist        vTop ¬ MaxItem[vTop, v[top + 1], v[top + 2], v[top + 3], v[top+4]];     109  =>  -- scope	::= open enables statementlist        vTop ¬ MaxItem[vTop, v[top + 1], v[top + 2]];     110  =>  -- binditem	::= id : exp        BEGIN        InsertToken[l[top], BI];        AppendToken[l[top + 1], SP];        AppendToken[vTop ¬ v[top + 2], E];        END;     111  =>  -- exit	::= exits exitlist        AppendToken[vTop ¬ IF v[top + 1] = nil THEN vTop ELSE v[top + 1], E];     112  =>  -- exits		::= EXITS               -- repeat	::= REPEAT        BEGIN        Small[vTop ¬ l[top]];        InsertToken[vTop, SP];        InsertToken[vTop, BC];        AppendToken[vTop, SP];        END;     113  =>  -- casestmtitem	::= caselabel chooses statement              -- catchcase	::= lhslist chooses statement        {AppendToken[vTop ¬ v[top + 2], E]; PrintItems[vTop]};     114  =>  -- caseexpitem	::= caselabel chooses exp        AppendToken[vTop ¬ v[top + 2], E];     115  =>  -- forclause	::= FOR controlid _ exp , exp         BEGIN        Small[l[top]];        AppendToken[l[top], SP];        InsertToken[l[top + 2], SP];        AppendToken[l[top + 2], SP];        AppendToken[l[top + 4], SP];        vTop ¬ v[top + 5];        END;     116  =>  -- forclause	::= FOR controlid direction IN range         BEGIN        Small[l[top]];        Small[l[top + 3]];        AppendToken[l[top], SP];        InsertToken[l[top + 3], SP];        AppendToken[l[top + 3], SP];        vTop ¬ v[top + 4];        END;     117  =>  -- controlid	::= ident typeexp         vTop ¬ v[top + 1];     118  =>  -- forclause	::= THROUGH range        {Small[l[top]]; AppendToken[l[top], SP]; vTop ¬ v[top + 1]};     119  =>  -- direction	::= DECREASING         {Small[vTop ¬ l[top]]; InsertToken[vTop, SP]};     120  =>  -- direction	::=          vTop ¬ nil;     121  =>  -- dotest	::= UNTIL exp         {Small[l[top]]; AppendToken[l[top], SP]; vTop ¬ v[top + 1]};     122  =>  -- doexit	::=        vTop ¬ nil;     123  =>  -- doexit	::= repeat exitlist        AppendToken[vTop ¬ IF v[top + 1] = nil THEN vTop ELSE v[top + 1], E];     124  =>  -- doexit	::= repeat exitlist finished chooses statement        BEGIN        AppendToken[vTop ¬ v[top + 4], E];        AppendToken[vTop, E];        AppendToken[vTop, SP];        PrintItems[vTop];        END;     125  =>  -- doexit	::= repeat exitlist finished chooses statement semicolon        BEGIN        AppendToken[vTop ¬ l[top + 5], E];        AppendToken[vTop, E];        AppendToken[vTop, SP];        PrintItems[vTop];        END;     126  =>  -- finished	::= FINISHED        {Small[vTop ¬ l[top]]; InsertToken[vTop, SP]; InsertToken[vTop, BI]};     ENDCASE => ERROR;    RETURN[vTop];    END;  PQ127: PROCEDURE [rule: [0..377B], top: CARDINAL, vTop: Style.ItemHandle]    RETURNS [Style.ItemHandle] =    BEGIN OPEN Style;    SELECT rule FROM     127  =>  -- chooses	::= =>        {InsertToken[vTop ¬ l[top], SP]; AppendToken[vTop, SP]};     128  =>  -- exititem	::= exitfront chooses statement        {AppendToken[vTop ¬ v[top + 2], E]; PrintItems[vTop]};     129  =>  -- exitfront	::= idlist        {InsertToken[vTop, SP]; InsertToken[vTop, BI]};     130  =>  -- enables	::= enable catchcase semicolon              -- enables	::= enable catchany semicolon        {AppendToken[vTop ¬ l[top + 2], SP]; AppendToken[vTop, E]};     131  =>  -- enables	::= enable begin catchlist END semicolon              -- enables	::= enable brace catchlist } semicolon        BEGIN        IF StringToken[l[top + 3]].length > 1 THEN {          InsertToken[l[top + 3], SP]; Small[l[top + 3]]};        AppendToken[l[top + 3], E];        AppendToken[l[top + 3], E];        AppendToken[vTop ¬ l[top + 4], SP];        END;     132  =>  -- enable	::= ENABLE        {Small[vTop ¬ l[top]]; InsertToken[vTop, BI]; AppendToken[vTop, SP]};     133  =>  -- catchlist	::= catchhead catchcase        vTop ¬ v[top + 1];     134  =>  -- transfer	::= SIGNAL              -- transfer	::= ERROR              -- transfer	::= START              -- transfer	::= RESTART              -- transfer	::= JOIN              -- transfer	::= NOTIFY              -- transfer	::= BROADCAST        Small[vTop ¬ l[top]];     135  =>  -- transfer	::= RETURN WITH ERROR        BEGIN        Small[l[top]];        Small[l[top + 1]];        Small[vTop ¬ l[top + 2]];        AppendToken[l[top], SP];        AppendToken[l[top + 1], SP];        END;     136  =>  -- transfer	::= TRANSFER WITH              -- transfer	::= RETURN WITH        {Small[l[top]]; AppendToken[l[top], SP]; Small[vTop ¬ l[top + 1]]};     137  =>  -- keyitem	::= id : optexp        BEGIN        IF v[top + 2] = nil THEN vTop ¬ l[top + 1]        ELSE          BEGIN          InsertToken[l[top], BI0];          AppendToken[l[top + 1], SP];          AppendToken[vTop ¬ v[top + 2], E];          END;        END;     138  =>  -- exp	::= transferop lhs         {AppendToken[l[top], SP]; vTop ¬ v[top + 1]};     139  =>  -- exp	::= IF exp THEN exp ELSE exp         BEGIN        Small[l[top]];        Small[l[top + 2]];        Small[l[top + 4]];        InsertToken[l[top], BI0];        AppendToken[l[top], SP];        InsertToken[l[top + 2], SP];        AppendToken[l[top + 2], SP];        InsertToken[l[top + 4], SP];        InsertToken[l[top + 4], BI];        AppendToken[l[top + 4], SP];        vTop ¬ v[top + 5];        AppendToken[vTop, E];        AppendToken[vTop, E];        END;     140  =>  -- exp	::= casehead caseexplist ENDCASE => exp         BEGIN        Small[l[top + 2]];        InsertToken[l[top + 2], SP];        InsertToken[l[top + 2], BI];        InsertToken[l[top + 3], SP];        AppendToken[l[top + 3], SP];        AppendToken[vTop ¬ v[top + 4], E];        AppendToken[vTop, E];        END;     141  =>  -- exp	::= lhs _ exp         {        InsertToken[l[top + 1], SP];        AppendToken[l[top + 1], SP];        vTop ¬ v[top + 2]};     142  =>  -- exp	::= [ explist ] _ exp         BEGIN        InsertToken[l[top + 3], SP];        AppendToken[l[top + 3], SP];        vTop ¬ v[top + 4];        END;     143  =>  -- exp	::= ERROR         Small[vTop ¬ l[top]];     144  =>  -- disjunct	::= disjunct OR conjunct         BEGIN        Small[l[top + 1]];        InsertToken[l[top + 1], SP];        InsertToken[l[top + 1], BI];        AppendToken[l[top + 1], SP];        AppendToken[vTop ¬ v[top + 2], E];        END;     145  =>  -- conjunct	::= conjunct AND negation         BEGIN        Small[l[top + 1]];        InsertToken[l[top + 1], SP];        InsertToken[l[top + 1], BI];        AppendToken[l[top + 1], SP];        AppendToken[vTop ¬ v[top + 2], E];        END;     146  =>  -- negation	::= not relation               -- relation	::= sum optrelation         vTop ¬ v[top + 1];     147  =>  -- optrelation	::= not relationtail         {InsertToken[l[top], SP]; vTop ¬ v[top + 1]};     148  =>  -- optrelation	::= relationtail         InsertToken[l[top], SP];     149  =>  -- sum		::= sum addop product               -- product	::= product multop factor         {InsertToken[l[top], BI];	 InsertToken[v[top + 1], SP];	 AppendToken[v[top + 1], SP];	 AppendToken[vTop ¬ v[top + 2], E]};     150  =>  -- relationtail	::= IN range         {Small[l[top]]; AppendToken[l[top], SP]; vTop ¬ v[top + 1]};     151  =>  -- relop	::= =               -- relop	::= #               -- relop	::= <               -- relop	::= <=               -- relop	::= >               -- relop	::= >=         AppendToken[vTop ¬ l[top], SP];      ENDCASE => ERROR;    RETURN[vTop];    END;  PQ152: PROCEDURE [rule: [0..377B], top: CARDINAL, vTop: Style.ItemHandle]    RETURNS [Style.ItemHandle] =    BEGIN OPEN Style;    SELECT rule FROM     152  =>  -- addop	::= +               -- addop	::= -         vTop ¬ l[top];     153  =>  -- multop	::= *               -- multop	::= /         vTop ¬ l[top];     154  =>  -- multop	::= MOD         {Small[vTop ¬ l[top]]; InsertToken[vTop, SP]; AppendToken[vTop, SP]};     155  =>  -- factor	::= addop primary         vTop ¬ v[top + 1];     156  =>  -- primary	::= num               -- primary	::= lnum               -- primary	::= flnum               -- primary	::= string               -- primary	::= atom               -- primary	::= lstring         vTop ¬ l[top];     157  =>  -- lhs	::= char         vTop ¬ l[top];     158  =>  -- primary	::= NIL         Small[vTop ¬ l[top]];     159  =>  -- primary	::= [ explist ]        BEGIN        AppendToken[l[top], BI0];        AppendToken[l[top], Break];        AppendToken[vTop ¬ l[top + 2], E];        END;     160  =>  -- primary	::= prefixop [ orderlist ]              -- primary	::= typeop [ typeexp ]        BEGIN        AppendToken[l[top + 1], Break];        InsertToken[l[top + 2], BI0];        InsertToken[vTop ¬ l[top + 3], E];        END;     161  =>  -- primary	::= new [ typeexp initialization optcatch ]        BEGIN        AppendToken[l[top + 1], Break];        InsertToken[l[top + 2], BI0];        AppendToken[vTop ¬ l[top + 5], E];        END;     162  =>  -- primary	::= SIZE [ typeexp ]              -- primary	::= DESCRIPTOR [ desclist ]              -- primary	::= VAL [ orderlist ]              -- primary	::= ALL [ orderlist ]        BEGIN        Small[l[top]];        AppendToken[l[top + 1], Break];        InsertToken[l[top + 2], BI];        InsertToken[l[top + 3], E];        vTop ¬ l[top + 3];        END;     163  =>  -- primary	::= SIZE [ typeexp , exp ]              -- primary	::= ISTYPE [ exp , typeexp ]        BEGIN        Small[l[top]];        AppendToken[l[top + 1], Break];        InsertToken[l[top + 2], BI];        AppendToken[l[top + 3], SP];        AppendToken[v[top + 4], E];        vTop ¬ l[top + 5];        END;     164  =>  -- primary	::= @ lhs        vTop ¬ v[top + 1];     165  =>  -- lhs 		::= id               -- element	::= id              -- controlid	::= id         vTop ¬ l[top];     166  =>  -- ident		::= id :         AppendToken[vTop ¬ l[top + 1], SP];     167  =>  -- lhs	::= LOOPHOLE [ exp opttype ]        {<<SmallBold[l[top]];>> vTop ¬ l[top + 4]};     168  =>  -- lhs	::= NARROW [ exp opttype optcatch ]        BEGIN	Small[l[top]];        AppendToken[l[top+1], BI0];        AppendToken[l[top+1], Break];        AppendToken[vTop ¬ l[top + 5], E];        END;     169  =>  -- qualifier	::= [ explist optcatch ]        BEGIN        AppendToken[l[top], BI0];        AppendToken[l[top], Break];        AppendToken[vTop ¬ l[top + 3], E];        END;     170  =>  -- qualifier	::= . id              -- qualifier	::= . prefixop              -- qualifier	::= . typeop        vTop ¬ l[top + 1];     171  =>  -- qualifier	::= . SIZE        Small[vTop ¬ l[top + 1]];     172  =>  -- qualifier	::= ^        vTop ¬ l[top];     173  =>  -- optcatch	::= bang catchlist        BEGIN        catchDepth ¬ catchDepth - 1;        InsertToken[vTop ¬ IF v[top + 1] = nil THEN vTop ELSE v[top + 1], BC];        AppendToken[vTop, E];        END;     174  =>  -- bang		::= !        {        catchDepth ¬ catchDepth + 1;        AppendToken[vTop ¬ l[top], SP];        InsertToken[vTop, SP]};     175  =>  -- transferop	::= SIGNAL              -- transferop	::= ERROR              -- transferop	::= START              -- transferop	::= JOIN              -- transferop	::= NEW               -- transferop	::= FORK        {Small[vTop ¬ l[top]]; AppendToken[vTop, SP]};     176  =>  -- prefixop	::= LONG               -- prefixop	::= ABS               -- prefixop	::= PRED               -- prefixop	::= SUCC               -- prefixop	::= ORD               -- prefixop	::= MIN               -- prefixop	::= MAX               -- prefixop	::= BASE              -- prefixop	::= LENGTH              -- typeop		::= FIRST              -- typeop		::= LAST              -- typeop		::= NIL              -- pointerprefix	::= POINTER        Small[vTop ¬ l[top]];      ENDCASE => ERROR;    RETURN[vTop];    END;  PQ177: PROCEDURE [rule: [0..377B], top: CARDINAL, vTop: Style.ItemHandle]    RETURNS [Style.ItemHandle] =    BEGIN OPEN Style;    SELECT rule FROM     177  =>  -- desclist	::= exp , exp opttype        {AppendToken[l[top + 1], SP]; vTop ¬ MaxItem[v[top + 2], v[top + 3]]};     178  =>  -- dire		::= DIRECTORY semicolon        vTop ¬ l[top + 1];     179  =>  -- fieldlist	::= [ ]        {InsertToken[l[top], SP]; vTop ¬ l[top + 1]};     180  =>  -- imports	::= IMPORTS              -- exports	::= EXPORTS        {Small[vTop ¬ l[top]]; InsertToken[vTop, SP]};     181  =>  -- statementlist	::=               -- casestmtlist	::=              -- exitlist	::=               -- catchhead	::=              -- caseexplist	::=        vTop ¬ nil;     182  =>  -- caselabel	::= casetest               -- lhslist	::= lhs              -- caselabel	::= ident typeexp         {InsertToken[l[top], SP]; InsertToken[l[top], BI]};     183  =>  -- includelist	::= includelist , includeitem        BEGIN        AppendToken[l[top + 1], SP];        PrintItems[l[top + 1]];        vTop ¬ v[top + 2];        END;     184  =>  -- modulelist	::= modulelist , moduleitem              -- pairlist	::= pairlist , pairitem              -- elementlist	::= elementlist , element              -- variantlist	::= variantlist , variantitem              -- bindlist	::= bindlist , binditem              -- caselabel	::= caselabel , casetest               -- lhslist	::= lhslist , lhs              -- orderlist	::= orderlist , optexp               -- keylist	::= keylist , keyitem               -- caseexplist'	::= caseexplist' , caseexpitem        {AppendToken[l[top + 1], SP]; vTop ¬ MaxItem[l[top + 1], v[top + 2]]};     185  =>  -- statementlist'	::= statementlist' semicolon  statement               -- exitlist'	::= exitlist' semicolon exititem              -- casestmtlist'	::= casestmtlist' semicolon casestmtitem              -- declist	::= declist semicolon declaration        PrintItems[vTop ¬ v[top + 2]];     186  =>  -- catchhead	::= catchhead  catchcase semicolon        AppendToken[vTop ¬ l[top + 2], SP];     187  =>  -- identlist	::= identlist'        InsertToken[l[top], BI];     188  =>  -- imports	::= IMPORTS modulelist              -- exports	::= EXPORTS modulelist         BEGIN        Small[l[top]];        InsertToken[l[top], SP];        InsertToken[l[top], BI];        AppendToken[l[top], SP];        InsertToken[l[top + 1], BI0];        AppendToken[v[top + 1], E];        AppendToken[v[top + 1], E];        vTop ¬ v[top + 1];        END;     189  =>  -- open		::= OPEN bindlist semicolon        BEGIN        Small[l[top]];        InsertToken[l[top], ISP];        InsertToken[l[top], BI];        AppendToken[l[top], SP];        InsertToken[v[top + 1], BI0];        AppendToken[l[top + 2], SP];        AppendToken[l[top + 2], SP];        AppendToken[l[top + 2], E];        AppendToken[vTop ¬ l[top + 2], E];        END;     190  =>  -- fieldlist	::= [ pairlist ]              -- fieldlist	::= [ typelist ]        BEGIN        InsertToken[l[top], SP];        AppendToken[l[top], BI0];        AppendToken[l[top], Break];        AppendToken[vTop ¬ l[top + 2], E];        END;     191  =>  -- initialization	::= assign initvalue              -- initialization	::= equal initvalue              -- default	::= assign defaultopt         vTop ¬ v[top + 1];     192  =>  -- assign	::= _              -- equal		::= =        {InsertString[vTop ¬ l[top], " "L]; AppendToken[vTop, SP]};     193  =>  -- readonly	::= READONLY              -- ordered	::= ORDERED              -- base		::= BASE              -- packed	::= PACKED              -- inline	::= INLINE        {Small[vTop ¬ l[top]]; AppendToken[vTop, SP]};     194  =>  -- casehead	::= SELECT exp FROM        BEGIN        Small[l[top]];        Small[vTop ¬ l[top + 2]];        InsertToken[l[top], BC];        InsertToken[l[top], BI0];        AppendToken[l[top], SP];        InsertToken[vTop, SP];        AppendToken[vTop, SP];        AppendToken[vTop, E];        END;     195  =>  -- casehead	::= WITH binditem SELECT optexp FROM        BEGIN        Small[l[top]];        Small[l[top + 2]];        Small[vTop ¬ l[top + 4]];        InsertToken[l[top], BC];        InsertToken[l[top], BI0];        AppendToken[l[top], SP];        InsertToken[l[top + 2], SP];        AppendToken[l[top + 2], SP];        InsertToken[vTop, SP];        AppendToken[vTop, SP];        AppendToken[vTop, E];        END;     196  =>  -- packed	::=              -- readonly	::=              -- monitored	::=              -- ordered	::=              -- base		::=              -- inline	::=              -- enables	::=              -- exit		::=              -- optcatch	::=        vTop ¬ nil;     197  =>  -- using		::= USING [ idlist ]        BEGIN        Small[l[top]];        InsertToken[l[top], SP];        AppendToken[l[top], SP];        AppendToken[l[top + 1], BI0];        AppendToken[l[top + 1], Break];        AppendToken[l[top + 3], E];        vTop ¬ l[top + 3];        END;     198  =>  -- interface	::= imports exports shares        BEGIN        newVTop: ItemHandle = MaxItem[vTop, v[top + 1], v[top + 2]];        IF vTop # nil THEN          BEGIN          item: ItemHandle =            IF vTop # nil THEN l[top]            ELSE IF v[top + 1] # nil THEN l[top + 1] ELSE l[top + 2];          InsertToken[PreviousItem[item], BC0];          AppendToken[newVTop, E];          END;        vTop ¬ newVTop;        END;     199  =>  -- shares	::= SHARES idlist         BEGIN        Small[l[top]];        InsertToken[l[top], SP];        InsertToken[l[top], BI];        AppendToken[l[top], SP];        InsertToken[l[top + 1], BI0];        AppendToken[v[top + 1], E];        AppendToken[v[top + 1], E];        vTop ¬ v[top + 1];        END;     200  =>  -- length	::= [ exp ]         vTop ¬ l[top + 2];     201  =>  -- pointerprefix	::= POINTER interval               -- dotest	::= WHILE exp         {Small[l[top]]; AppendToken[l[top], SP]; vTop ¬ v[top + 1]};      ENDCASE => ERROR;    RETURN[vTop];    END;  PQ202: PROCEDURE [rule: [0..377B], top: CARDINAL, vTop: Style.ItemHandle]    RETURNS [Style.ItemHandle] =    BEGIN OPEN Style;    SELECT rule FROM     202  =>  -- arguments	::= arglist returnlist         vTop ¬ MaxItem[vTop, v[top + 1]];     203  =>  -- returnlist	::= RETURNS fieldlist         BEGIN        Small[l[top]];        InsertToken[l[top], SP];        InsertToken[l[top], BI];        vTop ¬ v[top + 1];        AppendToken[vTop, E];        END;     204  =>  -- elsepart	::= else statement         BEGIN        AppendToken[v[top + 1], E];        vTop ¬ v[top + 1];        PrintItems[vTop];        END;     205  =>  -- else		::= ELSE         BEGIN        Small[vTop ¬ l[top]];        InsertToken[vTop, SP];        InsertToken[vTop, E];        InsertToken[vTop, BI];        AppendToken[vTop, SP];        END;     206  =>  -- otherpart	::= chooses statement         PrintItems[vTop ¬ v[top + 1]];     207  =>  -- catchany	::= any chooses statement        {AppendToken[vTop ¬ v[top + 2], E]; PrintItems[vTop]};     208  =>  -- any         ::= ANY        {Small[vTop ¬ l[top]]; InsertToken[vTop, BI]};     209  =>  -- not		::= ~               -- not		::= NOT         BEGIN        IF StringToken[vTop ¬ l[top]].length > 1 THEN {          Small[vTop]; AppendToken[vTop, SP]};        END;     210  =>  -- statementlist	::= statementlist' semicolon               -- casestmtlist	::= casestmtlist' semicolon               -- exitlist	::= exitlist' semicolon              -- caseexplist	::= caseexplist' ,         AppendToken[vTop ¬ l[top + 1], SP];     211  =>  -- optargs	::= [ explist ]         BEGIN        AppendToken[l[top], BI];        AppendToken[l[top], Break];        AppendToken[vTop ¬ l[top + 2], E];        END;     212  =>  -- bounds	::= exp .. exp         {InsertToken[l[top], BI]; AppendToken[vTop ¬ v[top + 2], E]};     213  =>  -- lhs		::= ( exp )         {InsertToken[l[top], BI]; AppendToken[vTop ¬ l[top + 2], E]};     214  =>  -- lhs		::= lhs qualifier               -- relationtail	::= relop sum               -- catchlist	::= catchhead catchany         vTop ¬ v[top + 1];     215  =>  -- catchlist	::= catchhead catchany semicolon         vTop ¬ v[top + 2];     216  =>  -- new		::= lhs . NEW              -- free		::= lhs . FREE        Small[vTop ¬ l[top + 2]];     217  =>  -- opttype	::= , typeexp        {AppendToken[l[top], SP]; vTop ¬ v[top + 1]};     218  =>  -- dire		::=               -- using		::=               -- locks		::=               -- imports	::=               -- exports	::=               -- shares		::=               -- optbits	::=               -- default	::=               -- open		::=              -- arglist	::=               -- returnlist	::=               -- indextype	::=              -- elsepart	::=              -- otherpart	::=              -- forclause	::=               -- dotest		::=               -- optargs	::=               -- optexp		::=              -- opttype	::=        vTop ¬ nil;     219  =>  -- semicolon	::= ;        AppendToken[vTop ¬ l[top], SP];     220  =>  -- optargs	::= lhs        InsertToken[l[top], SP];     221  =>  -- lhs		::= APPLY [ exp , exp optcatch ]        {        Small[l[top]];        AppendToken[l[top], BC0];        AppendToken[l[top], Break];        AppendToken[l[top + 3], SP];        AppendToken[vTop ¬ l[top + 6], E]};      ENDCASE => ERROR;    RETURN[vTop];    END;  PQ252: PROCEDURE [rule: [0..377B], top: CARDINAL, vTop: Style.ItemHandle]    RETURNS [Style.ItemHandle] =    BEGIN OPEN Style;    SELECT rule FROM      255 => NULL;  -- should never happen      ENDCASE => ERROR;    RETURN[vTop]    END;  END.
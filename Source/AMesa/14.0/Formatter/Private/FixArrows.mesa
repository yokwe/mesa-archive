-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. -- File: FixArrows.mesa - last edited by-- Daniels	25-Apr-84 12:36:21DIRECTORY  CommandUtil USING [    CommandPtr, Create, Destroy, Echo, Failed, FreePairList, FreeString, GetNth,    ListLength, PairList, Parse],  Exec USING [    AddCommand, CheckForAbort, ExecProc, GetChar, Outcome, OutputProc],  Format USING [Line, StringProc],  MFile USING [AcquireTemp, CopyFileHandle, Error, Handle, Release, SwapNames],  MStream USING [    Create, EndOf, Error, GetFile, GetLength, Handle, ReadOnly, WriteOnly],  Stream USING [Delete, EndOfStream, GetChar, Handle, PutChar],  String USING [AppendString, Equivalent];FixArrows: PROGRAM  IMPORTS CommandUtil, Exec, Format, Stream, MFile, MStream, String =  BEGIN  Command: Exec.ExecProc = {    write: Format.StringProc = h.OutputProc[];    thisTry: Exec.Outcome;    inStream, outStream: Stream.Handle ¬ NIL;    GetChar: PROCEDURE RETURNS [CHARACTER] = {RETURN[h.GetChar[]]};    cmd: CommandUtil.CommandPtr = CommandUtil.Create[GetChar];    source, dest, switches: LONG STRING ¬ NIL;    results, args: CommandUtil.PairList;    CleanUp: PROCEDURE [final: BOOLEAN] = {      -- assert: dest=source OR dest is in results pairlist => no free[dest]      source ¬ CommandUtil.FreeString[source];      dest ¬ NIL;      switches ¬ CommandUtil.FreeString[switches];      results ¬ CommandUtil.FreePairList[results];      args ¬ CommandUtil.FreePairList[args];      IF inStream # NIL THEN {inStream.Delete[]; inStream ¬ NIL};      IF outStream # NIL THEN {outStream.Delete[]; outStream ¬ NIL};      IF final THEN CommandUtil.Destroy[cmd]};    DO      ENABLE UNWIND => CleanUp[TRUE];      thisTry ¬ normal;      IF h.CheckForAbort[] THEN {thisTry ¬ abort; EXIT};      [source, args, results, switches] ¬ CommandUtil.Parse[        cmd: cmd, opX: (".mesa"L).length, resultX: (".mesa"L).length,        allowNoTagParm: TRUE ! CommandUtil.Failed => GOTO badSyntax];      IF source = NIL AND switches = NIL THEN EXIT;      IF source = NIL THEN {CleanUp[FALSE]; LOOP};      AppendExtension[source, ".mesa"L];      CommandUtil.Echo[write, source, args, results, switches];      write[": "L];      SELECT CommandUtil.ListLength[results] FROM        0 => NULL;        1 => dest ¬ CommandUtil.GetNth[list: results, n: 0];        ENDCASE => {          Format.Line[write, "Bad command syntax"L]; thisTry ¬ error; EXIT};      IF dest = NIL THEN dest ¬ source;      AppendExtension[dest, ".mesa"L];      IF thisTry = normal THEN        [thisTry, inStream, outStream] ¬ GetFiles[write, source, dest];      IF thisTry = normal THEN {        inFile, tempFile: MFile.Handle;        overWrite: BOOLEAN = outStream = NIL;        IF overWrite THEN {          inFile ¬ MFile.CopyFileHandle[            MStream.GetFile[inStream], [], rename !            MFile.Error => {              Format.Line[write, "can't be replaced"L];              {inStream.Delete[]; inStream ¬ NIL};              GOTO failed}];          tempFile ¬ MFile.AcquireTemp[            type: text, initialLength: MStream.GetLength[inStream]];          outStream ¬ MStream.Create[tempFile, []];          tempFile ¬ MFile.CopyFileHandle[tempFile, [], rename]};        FixThemArrows[inStream, outStream];        {inStream.Delete[]; inStream ¬ NIL};        {outStream.Delete[]; outStream ¬ NIL};        IF overWrite THEN {          MFile.SwapNames[inFile, tempFile];	  inFile.Release[];          tempFile.Release[]};        write["converted.\n"L];        EXITS failed => thisTry ¬ error};      CleanUp[FALSE];      IF thisTry > outcome THEN outcome ¬ thisTry;      REPEAT badSyntax => outcome ¬ error;      ENDLOOP;    CleanUp[TRUE];    RETURN[outcome]};  GetFiles: PROCEDURE [write: Format.StringProc, source, dest: LONG STRING]    RETURNS [outcome: Exec.Outcome ¬ normal, in, out: Stream.Handle ¬ NIL] =    BEGIN    in ¬ MStream.ReadOnly[      source, [] !      MStream.Error => {        write["Input file not available."L]; GOTO failed}];    IF ~String.Equivalent[dest, source] THEN      out ¬ MStream.WriteOnly[        dest, [], text !        MStream.Error => {          Format.Line[write, "Output file can't be written."L];          {in.Delete[]; in ¬ NIL};          GOTO failed}];    EXITS failed => outcome ¬ error;    END;  AppendExtension: PROCEDURE [name, ext: LONG STRING] =    BEGIN    FOR i: CARDINAL DECREASING IN [0..name.length) DO      SELECT name[i] FROM        '. => EXIT;        '> => {String.AppendString[name, ext]; RETURN};	ENDCASE;      REPEAT FINISHED => String.AppendString[name, ext];      ENDLOOP;    END;  FixThemArrows: PROCEDURE [input, output: Stream.Handle] =    BEGIN    UNTIL MStream.EndOf[input] DO      c: CHARACTER ¬ input.GetChar[ ! Stream.EndOfStream => EXIT];      SELECT c FROM	137C => c ¬ '¬;	136C => c ¬ '­;	ENDCASE;      output.PutChar[c];      ENDLOOP;    END;  -- Main body  {Exec.AddCommand["FixArrows.~"L, Command]};  END.
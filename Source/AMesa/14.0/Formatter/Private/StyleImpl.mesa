-- Copyright (C) 1981, 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- File: StyleImpl.mesa Last Modified by -- Oppen,	25 Dec 1979-- Karlton,	12-Mar-82 18:53:51-- Loretta,	20-Feb-81 13:11:03-- Sweet,	15-Dec-83 16:59:59-- SHayes,	21-Apr-81 13:37:25-- Lewis,	20-Aug-81 12:06:01-- Rhonda, 	 5-Oct-82 14:37:33-- Yamamoto, 	 9-Sep-83 12:03:17-- Daniels, 	25-Apr-84 17:20:56-- Wagner,	29-Jul-85 14:44:43DIRECTORY  Ascii USING [CR, FF, SP, TAB],  BravoOut,  CLog USING [Error, ErrorString],  CmFile USING [    Close, Error, FindSection, Handle, NextValue, TableError, UserDotCmOpen],  ComData USING [sourceFile, switches],  CompilerUtil USING [AcquireStream, ReleaseStream],  Environment USING [wordsPerPage],  File,  Heap USING [Create, Delete, systemZone],  HeraldWindow USING [AppendMessage],  Inline USING [LowHalf],  Interpress82Maker,  MFile,  MLoader,   MStream USING [Create, Error, GetFile, Handle, WriteOnly],  OldPressMaker,  Press,  PressStream,  PressUtilities,  Runtime,  Space USING [Interval, Map, Unmap, Window],  Stream USING [    Delete, EndOfStream, GetChar, Handle, PutBlock, PutChar, SetPosition],  String USING [    AppendChar, AppendString, Copy, CopyToNewString, Equivalent, FreeString,    StringBoundsFault],  StringLookUp USING [noMatch],  Style USING [    Breaks, Comment, CRCount, formatterFont, headerComment, ItemHandle, LineBreak,    Look, MaxBlanks, nullItem, StringTokenHandle, Token],  Time USING [Append, Packed, Unpack],  Token USING [Decimal, Item, FreeTokenString],  Zone USING [Create, FreeNode, Handle, MakeNode, Status];  StyleImpl: PROGRAM  IMPORTS    BravoOut, CmFile, CompilerUtil, Heap, HeraldWindow, Inline, Interpress82Maker,    CLog, MFile, MLoader, MStream, OldPressMaker, PressStream,    PressUtilities, Runtime, Space, Stream, String, Style, Time, Zone,    renamedToNotConflictWithStyleDotToken: Token, data: ComData  EXPORTS Style =  BEGIN  -- Errors  LineTooLong: ERROR = CODE;  ItemStorageOverFlow: ERROR = CODE;  -- globals  Token: TYPE = Style.Token;    lineWidth: CARDINAL ¬ 82;  indentPerLevel: CARDINAL ¬ 2;  margin, space: INTEGER;  header: LONG STRING ¬ NIL;  left, right: INTEGER;  scanTokens: LONG POINTER TO ScanSequence ¬ NIL;  ScanSequence: TYPE = RECORD [    ss: SEQUENCE length: CARDINAL OF ScanToken];  ScanToken: TYPE = RECORD [    token: Token,    size: LONG INTEGER];  leftTotal, rightTotal: LONG INTEGER;  sizeInfinity: INTEGER = 77777B;  traceIn, traceOut: Stream.Handle ¬ NIL;  tracing, bravoing, pressing, landscaping, text, documenting: BOOLEAN;  convertArrows: BOOLEAN;  scanStack: LONG POINTER TO ScanStackSequence ¬ NIL;  ScanStackSequence: TYPE = RECORD [    sss: SEQUENCE length: CARDINAL OF INTEGER];  scanSize: INTEGER;  scanItems: INTEGER;  top, bottom: INTEGER;  lastLook: Style.Look;  normalFont: CARDINAL ¬ 0;  smallFont: CARDINAL ¬ 1;  portraitFont: LONG STRING ¬ NIL;  landscapeFont: LONG STRING ¬ NIL;  currentFont: LONG STRING ¬ NIL;  printStack: PrintStack ¬ NIL;    -- Utilities  Scream: PROC [s: LONG STRING, first: BOOLEAN ¬ FALSE] = {    HeraldWindow.AppendMessage[msg: s, newLine: first, clearOld: FALSE]};      MicasForPoints: PROC [m: LONG CARDINAL] RETURNS [CARDINAL] = {    RETURN[CARDINAL[(m*635+9)/18]]};      -- pretty print main line  PutString: PROCEDURE [str: Stream.Handle, s: LONG STRING] = {    str.PutBlock[block: [LOOPHOLE[@s.text], 0, s.length]]};      StyleToken: PROCEDURE [tkn: Token, pseudoLength: CARDINAL] =    BEGIN    WITH t: tkn SELECT FROM      eof =>        BEGIN        IF tracing THEN PutString[traceOut, "<<eof>>"L];        IF scanItems # 0 THEN {          CheckStack[0]; AdvanceLeft[scanTokens[left]]};        END;      begin =>        BEGIN        IF tracing THEN          BEGIN          traceOut.PutChar['{];          IF t.breakType = consistent THEN PutString[traceOut, "<c>"L];          IF t.offset = 0 THEN PutString[traceOut, "<0>"L];          END;        IF scanItems = 0 THEN          BEGIN leftTotal ¬ rightTotal ¬ 1; left ¬ right ¬ 0; END        ELSE AdvanceRight[];        scanTokens[right] ¬ [t, -rightTotal];        ScanPush[right];        END;      end =>        BEGIN        IF tracing THEN traceOut.PutChar['}];        IF scanItems = 0 THEN Print[t, 0]        ELSE          BEGIN          AdvanceRight[];          scanTokens[right] ¬ [t, -1];          ScanPush[right];          END;        END;      break =>        BEGIN        IF tracing THEN          BEGIN          IF t.blankSpace = Style.MaxBlanks THEN            BEGIN            PutString[traceOut, "<eol>"L];            traceOut.PutChar[Ascii.CR];            END          ELSE PutString[traceOut, "#"L];          END;        IF scanItems = 0 THEN          BEGIN leftTotal ¬ rightTotal ¬ 1; left ¬ right ¬ 0; END        ELSE AdvanceRight[];        CheckStack[0];        ScanPush[right];        scanTokens[right] ¬ [t, -rightTotal];        rightTotal ¬ rightTotal + t.blankSpace;        END;      string =>        BEGIN        IF tracing THEN          BEGIN          traceIn.SetPosition[t.index];          THROUGH [0..t.length) DO            traceOut.PutChar[traceIn.GetChar[]] ENDLOOP;          END;        IF scanItems = 0 THEN Print[t, pseudoLength]        ELSE          BEGIN          AdvanceRight[];          scanTokens[right] ¬ [t, pseudoLength];          rightTotal ¬ rightTotal + pseudoLength;          CheckStream[];          END;        END;      inline =>        BEGIN        IF tracing THEN          FOR i: CARDINAL IN [0..t.length) DO            traceOut.PutChar[t.string[i]] ENDLOOP;        IF scanItems = 0 THEN Print[t, t.length]        ELSE          BEGIN          AdvanceRight[];          scanTokens[right] ¬ [t, t.length];          rightTotal ¬ rightTotal + t.length;          CheckStream[];          END;        END;      ENDCASE => ERROR;    END;  CheckStream: PROCEDURE =    BEGIN    WHILE rightTotal - leftTotal > space DO      IF scanItems # 0 AND left = scanStack[bottom] THEN scanTokens[ScanPopBottom[]].size ¬ 900;      AdvanceLeft[scanTokens[left]];      IF left = right THEN EXIT;      ENDLOOP;    END;  ScanPush: PROCEDURE [x: CARDINAL] = INLINE    BEGIN    scanItems ¬ scanItems + 1;    IF (top ¬ (top + 1)) >= scanSize THEN top ¬ 0;    scanStack[top] ¬ x;    END;  ScanPop: PROCEDURE RETURNS [x: CARDINAL] = INLINE    BEGIN    scanItems ¬ scanItems - 1;    x ¬ scanStack[top];    IF (top ¬ (top - 1)) < 0 THEN top ¬ scanSize - 1;    END;  ScanTop: PROCEDURE RETURNS [CARDINAL] = INLINE {RETURN[scanStack[top]]};  ScanPopBottom: PROCEDURE RETURNS [x: CARDINAL] = INLINE    BEGIN    scanItems ¬ scanItems - 1;    x ¬ scanStack[bottom];    IF (bottom ¬ (bottom + 1)) >= scanSize THEN bottom ¬ 0;    END;  AdvanceRight: PROCEDURE = INLINE {right ¬ (right + 1) MOD scanStack.length};  AdvanceLeft: PROCEDURE [st: ScanToken] = {    DO      IF st.size < 0 THEN EXIT;      Print[st.token, Inline.LowHalf[st.size]];      WITH t: st.token SELECT FROM        break => leftTotal ¬ leftTotal + t.blankSpace;        string, inline => leftTotal ¬ leftTotal + st.size;        ENDCASE;      IF left = right THEN EXIT;      left ¬ (left + 1) MOD scanStack.length;      st ¬ scanTokens[left];      ENDLOOP};  CheckStack: PROCEDURE [k: INTEGER] =    BEGIN    x: INTEGER;    DO      IF scanItems = 0 THEN EXIT;      x ¬ ScanTop[];      SELECT scanTokens[x].token.type FROM        begin => {          IF k <= 0 THEN EXIT;	  scanTokens[ScanPop[]].size ¬ scanTokens[x].size + rightTotal;	  k ¬ k - 1};        end => {	  scanTokens[ScanPop[]].size ¬ 1;	  k ¬ k + 1};        ENDCASE => {	  scanTokens[ScanPop[]].size ¬ scanTokens[x].size + rightTotal;	  IF k <= 0 THEN EXIT};      ENDLOOP;    END;  Indent: PROCEDURE [amount: CARDINAL, betweenWords: BOOLEAN] =    BEGIN    IF amount = 0 THEN RETURN;    SetLooks[normal];    IF pressing THEN      THROUGH [0..amount) DO         pressOut.PutChar[Ascii.SP];        pressOut.PutChar[Ascii.SP]; -- Helvetica spaces are too narrow        ENDLOOP;    IF text THEN      THROUGH [0..amount) DO outStream.PutChar[Ascii.SP] ENDLOOP;    IF bravoing THEN      IF ~betweenWords AND documenting THEN        THROUGH [0..amount/indentPerLevel) DO BravoOut.Char[Ascii.TAB] ENDLOOP      ELSE THROUGH [0..amount) DO BravoOut.Char[Ascii.SP] ENDLOOP;     END;  pendingIndent: CARDINAL;  FF: inline Token = [inline[length: 1, string: [Ascii.FF, 0C, 0C, 0C, 0C]]];    OutChars: PROCEDURE [pos: LONG CARDINAL, length: CARDINAL] =    BEGIN    itemStream.SetPosition[pos];    THROUGH [0..length) DO      char: CHARACTER ¬ itemStream.GetChar[];      IF convertArrows THEN SELECT char FROM        '_ => char ¬ '¬;	'^ => char ¬ '­;	ENDCASE;      IF pressing THEN pressOut.PutChar[char];      IF bravoing THEN BravoOut.Char[char];      IF text THEN outStream.PutChar[char];      ENDLOOP;    END;  OutInlineChars: PROCEDURE [token: inline Token] =    BEGIN    FOR i: CARDINAL IN [0..token.length) DO      char: CHARACTER ¬ token.string[i];      IF pressing THEN pressOut.PutChar[char];      IF bravoing THEN BravoOut.Char[char];      IF text THEN outStream.PutChar[char];      ENDLOOP;    END;  Print: PROCEDURE [token: Token, l: INTEGER] =    BEGIN    top: PrintStackEntry;    WITH t: token SELECT FROM      begin => {        IF l > space THEN          Push[            [            space - t.offset,            IF t.breakType = consistent THEN consistent ELSE inconsistent]]        ELSE Push[[0, fits]]};      end => Pop[];      break => {        top ¬ Top[];        SELECT TRUE FROM          top.break = fits => {            space ¬ space - t.blankSpace;            IF pendingIndent # 0 THEN {              Indent[pendingIndent, FALSE]; pendingIndent ¬ 0};            Indent[t.blankSpace, TRUE]};          top.break = consistent AND ~t.inconsistent => {            space ¬ Top[].offset - t.offset; PrintNewLine[margin - space]};          ENDCASE => {            IF l > space THEN {              space ¬ Top[].offset - t.offset; PrintNewLine[margin - space]}            ELSE {              space ¬ space - t.blankSpace;              IF pendingIndent # 0 THEN {                Indent[pendingIndent, FALSE]; pendingIndent ¬ 0};              Indent[t.blankSpace, TRUE]}}};      string => {        IF pendingIndent # 0 THEN {          Indent[pendingIndent, FALSE]; pendingIndent ¬ 0};        space ¬ space - l;        SetLooks[t.look];	IF t.comment # not THEN {	  OutChars[pos: t.index, length: 2];	  t.index ¬ t.index + 2; t.length ¬ t.length - 2;	  IF pressing THEN PressStream.SetLineWrapIndent[pressOut]};        OutChars[pos: t.index, length: t.length]};      inline => {        IF pendingIndent # 0 AND t # FF THEN {          Indent[pendingIndent, FALSE]; pendingIndent ¬ 0};        space ¬ space - l;        SetLooks[normal];        OutInlineChars[t]};      ENDCASE => ERROR;    END;  PrintNewLine: PROCEDURE [amount: CARDINAL] =    BEGIN    IF pressing THEN pressOut.PutChar[Ascii.CR];    IF text THEN outStream.PutChar[Ascii.CR];    IF bravoing THEN      IF amount <= 2 THEN BravoOut.CloseParagraph[] ELSE BravoOut.CR[];     pendingIndent ¬ amount;    END;  SetLooks: PROCEDURE [look: Style.Look] =    BEGIN ENABLE PressUtilities.NoFontsDotWidths => RESUME;    IF lastLook = look THEN RETURN;    IF pressing THEN PressStream.SetFont[pressOut, ORD[look]];    IF bravoing THEN      BEGIN OPEN BravoOut;      SELECT look FROM        normal => {SetFont[normalFont]; SetItalics[off]; SetBold[off]};        italic => {SetFont[normalFont]; SetItalics[on]; SetBold[off]};        bold => {SetFont[normalFont]; SetItalics[off]; SetBold[on]};        small => {SetFont[smallFont]; SetItalics[off]; SetBold[off]};        smallbold => {SetFont[smallFont]; SetItalics[off]; SetBold[on]};        ENDCASE;      END;     lastLook ¬ look;    END;  -- print stack handling  localHeap: UNCOUNTED ZONE ¬ NIL;  PrintStack: TYPE = LONG POINTER TO PrintStackObject;  PrintStackObject: TYPE = RECORD [    index: CARDINAL ¬ 0,    items: SEQUENCE length: CARDINAL OF PrintStackEntry];  PrintStackEntry: TYPE = RECORD [offset: [0..127], break: PrintStackBreak];  PrintStackBreak: TYPE = {fits, inconsistent, consistent};  CreatePrintStack: PROCEDURE [size: CARDINAL] RETURNS [stack: PrintStack] = {    stack ¬ localHeap.NEW[PrintStackObject[size] ¬ [items: NULL]]};  ExpandPrintStack: PROCEDURE = {    newStack: PrintStack ¬ CreatePrintStack[printStack.length*2];    FOR i: CARDINAL IN [0..printStack.length) DO      newStack.items[i] ¬ printStack.items[i] ENDLOOP;    newStack.index ¬ printStack.index;    localHeap.FREE[@printStack];    printStack ¬ newStack};  Push: PROCEDURE [e: PrintStackEntry] = INLINE    BEGIN    IF printStack.index >= printStack.length THEN ExpandPrintStack[];    printStack.items[printStack.index] ¬ e;    printStack.index ¬ printStack.index + 1;    END;  Pop: PROCEDURE = INLINE {printStack.index ¬ printStack.index - 1};  Top: PROCEDURE RETURNS [PrintStackEntry] = INLINE {    RETURN[printStack.items[printStack.index - 1]]};  -- Scan Queue stuff  -- scan queue variables and TYPEs  ItemNotFound: PUBLIC ERROR = CODE;  ItemNotString: PUBLIC ERROR = CODE;    ItemHandle: PUBLIC TYPE = ItemBase RELATIVE POINTER TO ItemObject;  ItemBase: TYPE = LONG BASE POINTER;  ItemObject: TYPE = RECORD[    next: ItemHandle,    prev: ItemHandle,    token: Token];  nullItem: ItemHandle = NARROW[Style.nullItem];    itemBase: ItemBase ¬ NIL;   itemSpace: Space.Interval;   itemZone: Zone.Handle;   itemPages: CARDINAL = LAST[INTEGER] / Environment.wordsPerPage;   itemWindow: Space.Window ¬ [File.nullFile, 0, itemPages];   itemHead: ItemHandle;  itemStream: Stream.Handle ¬ NIL;  catchDepth: PUBLIC CARDINAL;  eofSeen: BOOLEAN;  outStream: Stream.Handle ¬ NIL;  endPos: LONG CARDINAL;  pressOut, pressFileStream: Stream.Handle ¬ NIL;  presser: Press.Handle ¬ NIL;  breakPending: BOOLEAN;  maxBegins: CARDINAL = 10;  Begins: TYPE = CARDINAL [0..maxBegins);  beginsPending: [0..maxBegins];  savedBegins: ARRAY Begins OF begin Token;  savedBreak: break Token;  depth: CARDINAL;  crsOut: CARDINAL;  PressState: TYPE = {closed, portrait, landscape};  pressState: PressState ¬ closed;  -- scan queue procedures  AppendToken: PUBLIC PROCEDURE [item: ItemHandle, token: Token] =    BEGIN    IF data.switches['d] THEN ValidateItem[item];    [] ¬ Insert[token, item, itemBase[item].next];    END;  DequeueItem: PROCEDURE RETURNS [item: ItemHandle] = INLINE    BEGIN    item ¬ itemBase[itemHead].next;    itemBase[itemBase[item].prev].next ¬ itemBase[item].next;    itemBase[itemBase[item].next].prev ¬ itemBase[item].prev;    IF item = itemHead THEN item ¬ nullItem;    END;  EnqueueItem: PUBLIC PROCEDURE [    index, length: CARDINAL, crCount: Style.CRCount, small: BOOLEAN,    comment: Style.Comment ¬ not] RETURNS [item: CARDINAL] =    BEGIN    avoidBoundsCheck: UNSPECIFIED;    realItem: ItemHandle;    token: Token = [string[      index: index,      crCount: crCount,      look: IF small THEN small ELSE normal,      length: length,      comment: comment]];    realItem ¬ Insert[token, itemBase[itemHead].prev, itemHead];    avoidBoundsCheck ¬ realItem;    item ¬ avoidBoundsCheck;    END;  FreeItem: PROCEDURE [item: ItemHandle] = {    [] ¬ Zone.FreeNode[itemZone, @itemBase[item]]};  GetItem: PROCEDURE RETURNS [item: ItemHandle] = {    status: Zone.Status;    [item, status] ¬ Zone.MakeNode[itemZone, SIZE[ItemObject]];    IF status # okay THEN ERROR ItemStorageOverFlow};  Insert: PROCEDURE [token: Token, prev, next: ItemHandle]    RETURNS [newItem: ItemHandle] = INLINE    BEGIN    newItem ¬ GetItem[];    itemBase[newItem] ¬ [next: next, prev: prev, token: token];    itemBase[prev].next ¬ itemBase[next].prev ¬ newItem;    END;  InsertToken: PUBLIC PROCEDURE [item: ItemHandle, token: Token] =    BEGIN    IF data.switches['d] THEN ValidateItem[item];    [] ¬ Insert[token, itemBase[item].prev, item];    END;  InsertString: PUBLIC PROCEDURE [item: ItemHandle, string: STRING] =    BEGIN    token: inline Token;    IF string.length = 0 THEN RETURN;    IF string.length > 4 THEN ERROR;    token ¬ [inline[length: string.length, string: [0C, 0C, 0C, 0C, 0C]]];    FOR i: CARDINAL IN [0..string.length) DO token.string[i] ¬ string[i] ENDLOOP;    IF data.switches['d] THEN ValidateItem[item];    [] ¬ Insert[token, itemBase[item].prev, item];    END;  ItemHandleToStreamIndex: PUBLIC PROCEDURE [reallyAnItemHandle: CARDINAL]    RETURNS [CARDINAL] = {    RETURN[Inline.LowHalf[StringToken[LOOPHOLE[reallyAnItemHandle]].index]]};  AnotherStreamOnSource: PROC RETURNS [stream: Stream.Handle] = {    os: Stream.Handle = CompilerUtil.AcquireStream[source];    fh: MFile.Handle = MFile.CopyFileHandle[MStream.GetFile[os], [], readOnly];    stream ¬ MStream.Create[fh, []];    CompilerUtil.ReleaseStream[source]};  ItemQueueInit: PUBLIC PROCEDURE =    BEGIN    fileRoot: STRING ¬ [42];    fileName: STRING ¬ [42];    i: CARDINAL;    c: CHARACTER;    IF localHeap = NIL THEN localHeap ¬ Heap.Create[20];    itemStream ¬ AnotherStreamOnSource[];    endPos ¬ 0;    FOR i IN [0..data.sourceFile.length) DO      IF (c ¬ data.sourceFile[i]) = '. THEN EXIT;      String.AppendChar[fileRoot, c];      ENDLOOP;    tracing ¬ data.switches['x];    documenting ¬ data.switches['v];    bravoing ¬ data.switches['z] OR documenting;    landscaping ¬ data.switches['k];    pressing ¬ data.switches['h] OR landscaping;    text ¬ data.switches['t] AND ~bravoing;    convertArrows ¬ data.switches['a];    fileName.length ¬ 0;    IF text OR bravoing THEN outStream ¬ CompilerUtil.AcquireStream[object];    IF pressing THEN      PressInit[        fileRoot: fileRoot,        createTime: MFile.GetTimes[MStream.GetFile[	  IF text OR bravoing THEN outStream ELSE itemStream]].create,	interpressing: data.switches['i] ! UNWIND => {	  itemStream.Delete[];	  itemStream ¬ NIL;	  IF text OR bravoing THEN {	    CompilerUtil.ReleaseStream[object]; outStream ¬ NIL}}];    IF bravoing THEN {      IF documenting THEN {normalFont ¬ 6; smallFont ¬ 7}      ELSE {normalFont ¬ 0; smallFont ¬ 1};      BravoOut.Start[outStream]};     IF tracing THEN {      fileName.length ¬ 0;      String.AppendString[fileName, fileRoot];      String.AppendString[fileName, ".trace"L];      traceOut ¬ MStream.WriteOnly[fileName, [], text];      traceIn ¬ AnotherStreamOnSource[]};    depth ¬ 0;    catchDepth ¬ 0;    eofSeen ¬ FALSE;    crsOut ¬ 1;    breakPending ¬ FALSE;    beginsPending ¬ 0;    pendingIndent ¬ 0;    space ¬ margin ¬ lineWidth;    top ¬ scanSize;    scanItems ¬ 0;    bottom ¬ 0;    scanTokens ¬ localHeap.NEW[ScanSequence[scanSize]];    scanStack ¬ localHeap.NEW[ScanStackSequence[scanSize]];    itemSpace ¬ Space.Map[window: itemWindow, swapUnits: [uniform[4]]];    itemBase ¬ itemSpace.pointer;    [itemZone, ] ¬ Zone.Create[      zoneBase: itemBase, storage: itemBase,      length: itemPages*Environment.wordsPerPage];    itemHead ¬ GetItem[];    itemBase[itemHead].next ¬ itemBase[itemHead].prev ¬ itemHead;    printStack ¬ CreatePrintStack[63];    StyleToken[[begin[offset: 0]], 0];    END;  ItemQueueReset: PUBLIC PROCEDURE [hadErrors: BOOLEAN] =    BEGIN    index: LONG CARDINAL;    finalToken: Style.StringTokenHandle;    IF ~hadErrors THEN {      finalToken ¬ StringToken[itemBase[itemHead].next];      index ¬ finalToken.index + finalToken.length;      PrintItems[nullItem];      StyleToken[[end[]], 0];      StyleToken[[eof[]], 0];      SetLooks[italic];      OutChars[pos: index, length: LAST[CARDINAL] !        Stream.EndOfStream => CONTINUE]};    IF bravoing THEN BravoOut.Done[];    IF pressing AND ~data.switches['g] THEN PressClose[];    IF text OR bravoing THEN {      CompilerUtil.ReleaseStream[object]; outStream ¬ NIL};    IF tracing THEN {      traceOut.Delete[];      traceOut ¬ NIL;      traceIn.Delete[];      traceIn ¬ NIL};    itemStream.Delete[];    itemStream ¬ NIL;    itemBase ¬ NIL;    itemSpace.pointer ¬ Space.Unmap[itemSpace.pointer];    IF printStack # NIL THEN localHeap.FREE[@printStack];    IF scanTokens # NIL THEN localHeap.FREE[@scanTokens];    IF scanStack # NIL THEN localHeap.FREE[@scanStack];    -- Heap.Delete[localHeap];  presser points into this zone.    END;  MaxItem: PUBLIC PROCEDURE [i1, i2: ItemHandle, i3, i4, i5: ItemHandle ¬ nullItem]    RETURNS [item: ItemHandle] = {    item ¬ nullItem;    IF i1 # nullItem THEN item ¬ i1;    IF i2 # nullItem THEN item ¬ i2;    IF i3 # nullItem THEN item ¬ i3;    IF i4 # nullItem THEN item ¬ i4;    IF i5 # nullItem THEN item ¬ i5};  NextItem: PUBLIC PROCEDURE [item: ItemHandle] RETURNS [ItemHandle] = {    RETURN[itemBase[item].next]};  PressClose: PROCEDURE = {    IF pressState # closed THEN {      pressOut.Delete[];      pressFileStream.Delete[];      pressState ¬ closed;      pressOut ¬ NIL;      pressFileStream ¬ NIL}};   PressFinish: PUBLIC PROCEDURE = {    PressClose[];    IF presser # NIL THEN {      presser.Delete[presser];      presser ¬ NIL;      header ¬ NIL}; -- no need to free as we're deleting the zone.    IF localHeap # NIL THEN {      Heap.Delete[localHeap];      localHeap ¬ NIL}}; PressInit: PUBLIC PROCEDURE [    fileRoot: STRING, createTime: Time.Packed, interpressing: BOOLEAN] = {    inch: CARDINAL = Press.micasPerInch;    lMargins: PressStream.Margins = [      left: inch/4, right: inch/2, top: (inch*5)/8, bottom: (inch*5)/8];    pMargins: PressStream.Margins = [      left: inch, right: (inch*3)/4, top: inch, bottom: (inch*3)/4];    pressParameters: PressStream.Parameters;    largeName, smallName: LONG STRING;    largePoints: CARDINAL;        fileName: STRING ¬ [MFile.maxNameLength];    { -- so fileName is visible at EXITS        IF localHeap = NIL THEN localHeap ¬ Heap.Create[20];    IF header = NIL THEN header ¬ localHeap.NEW[StringBody[100]];    header.length ¬ 0;    IF presser = NIL AND ~PrintReady[interpressing] THEN      TryToRun[        interpress: interpressing,        root: IF interpressing THEN "Print"L ELSE "OldPrint"L !          CannotRun => GO TO noPress];	      IF presser = NIL THEN presser ¬      IF interpressing THEN Interpress82Maker.CreatePresser[localHeap]      ELSE OldPressMaker.CreatePresser[localHeap];    String.AppendString[fileName, fileRoot];    String.AppendString[      fileName, IF interpressing THEN ".interpress"L ELSE ".press"L];        IF landscaping THEN {      pressParameters ¬ [	margins: lMargins, columns: 2, trailers: FALSE, mode: landscape];      IF (pressState # landscape) OR (Style.formatterFont # NIL AND           ~String.Equivalent[currentFont, Style.formatterFont]) THEN {	largePoints ¬ 8;	SELECT TRUE FROM	  Style.formatterFont # NIL => {	    GetFamily[Style.formatterFont];	    String.FreeString[Heap.systemZone, currentFont];	    currentFont ¬ String.CopyToNewString[	      Style.formatterFont, Heap.systemZone];	    smallName ¬ currentFont; largeName ¬ currentFont};	  landscapeFont # NIL => {	    smallName ¬ landscapeFont; largeName ¬ landscapeFont};	ENDCASE => {	  largeName ¬ IF interpressing THEN "Gacha"L ELSE "Helvetica"L;	  landscapeFont ¬ String.CopyToNewString[largeName, Heap.systemZone]};	presser.ClearAliases[presser];	presser.DefineAlias[	  h: presser,	  alias: ORD[Style.Look.normal], name: largeName, 	  size: MicasForPoints[largePoints], 	  w: medium, s: regular];	presser.DefineAlias[	  h: presser,	  alias: ORD[Style.Look.italic], name: largeName, size: MicasForPoints[largePoints], 	  w: medium, s: italic];	presser.DefineAlias[	  h: presser,	  alias: ORD[Style.Look.bold], name: largeName, size: MicasForPoints[largePoints], 	  w: bold, s: regular];	presser.DefineAlias[	  h: presser,	  alias: ORD[Style.Look.small], name: smallName, size: MicasForPoints[largePoints - 2], 	  w: medium, s: regular];	presser.DefineAlias[	  h: presser,	  alias: ORD[Style.Look.smallbold], name: smallName, 	  size: MicasForPoints[largePoints - 2], w: bold, s: regular];	IF pressOut # NIL THEN 	  PressStream.SetFont[pressOut, ORD[Style.Look.normal]]}}    ELSE {-- portraiting      pressParameters ¬ [	margins: pMargins, columns: 1, trailers: FALSE, mode: portrait];      IF (pressState # portrait) OR (Style.formatterFont # NIL AND          ~String.Equivalent[currentFont, Style.formatterFont]) THEN {	largePoints ¬ 10;	SELECT TRUE FROM	  Style.formatterFont # NIL => {	    GetFamily[Style.formatterFont];	    String.FreeString[Heap.systemZone, currentFont];	    currentFont ¬ String.CopyToNewString[	      Style.formatterFont, Heap.systemZone];	    smallName ¬ currentFont; largeName ¬ currentFont};	  portraitFont # NIL => {	    smallName ¬ portraitFont; largeName ¬ portraitFont};	ENDCASE => {	  largeName ¬ IF interpressing THEN "Gacha"L ELSE "Helvetica"L;	  portraitFont ¬ String.CopyToNewString[largeName, Heap.systemZone]};	 -- from here should be cross jumped	presser.ClearAliases[presser];	presser.DefineAlias[	  h: presser,	  alias: ORD[Style.Look.normal], name: largeName, size: MicasForPoints[largePoints], 	  w: medium, s: regular];	presser.DefineAlias[	  h: presser,	  alias: ORD[Style.Look.italic], name: largeName, size: MicasForPoints[largePoints], 	  w: medium, s: italic];	presser.DefineAlias[	  h: presser,	  alias: ORD[Style.Look.bold], name: largeName, size: MicasForPoints[largePoints], 	  w: bold, s: regular];	presser.DefineAlias[	  h: presser,	  alias: ORD[Style.Look.small], name: smallName, size: MicasForPoints[largePoints - 2], 	  w: medium, s: regular];	presser.DefineAlias[	  h: presser,	  alias: ORD[Style.Look.smallbold], name: smallName, 	  size: MicasForPoints[largePoints - 2], w: bold, s: regular];	IF pressOut # NIL THEN 	  PressStream.SetFont[pressOut, ORD[Style.Look.normal]]}};          IF pressState = closed THEN {      pressFileStream ¬ MStream.WriteOnly[fileName, [], binary !         MStream.Error => GOTO noOutput];      pressOut ¬ PressStream.Create[press: presser, output: pressFileStream!        PressUtilities.NoFontsDotWidths => GOTO noFontsWidths]}    ELSE pressOut.PutChar[13C]; -- start on new sheet    String.AppendString[header, data.sourceFile];    String.AppendString[header, "        "L];    Time.Append[header, Time.Unpack[createTime]];    IF Style.headerComment # NIL THEN {      String.AppendString[header, "    "];      FOR i: CARDINAL IN [0..Style.headerComment.length) DO  -- get as much as possible        String.AppendChar[          header, Style.headerComment[i] ! String.StringBoundsFault => EXIT];        ENDLOOP};    pressParameters.headerString ¬ header;    PressStream.SetParameters[pressOut, @pressParameters];    PressStream.SetPageNumber[pressOut, 1];    pressState ¬ IF landscaping THEN landscape ELSE portrait;    PressStream.SetFont[pressOut, Style.Look.normal.ORD !      PressUtilities.NoFontsDotWidths => GOTO noFontsWidths];    lastLook ¬ normal;    EXITS      noFontsWidths => {        CLog.ErrorString[fileName, "Fonts.widths"L];        PressFinish[];        ERROR ABORTED};      noOutput => {        CLog.ErrorString[fileName, fileName];        ERROR ABORTED};      noPress => {CLog.Error[noPress]; ERROR ABORTED}}};  PrintReady: PROCEDURE [interpress: BOOLEAN]    RETURNS [BOOLEAN] = INLINE {    RETURN[      Runtime.IsBound[        IF interpress THEN Interpress82Maker.CreatePresser        ELSE OldPressMaker.CreatePresser]]};	  CannotRun: ERROR = CODE;  RunFile: PROCEDURE [name: LONG STRING]    RETURNS [loaderHandle: MLoader.Handle ¬ NIL] =    BEGIN    ENABLE UNWIND => loaderHandle ¬ NIL;    fileHandle: MFile.Handle ¬ NIL;    fileHandle ¬ MFile.ReadOnly[name, [] ! MFile.Error => ERROR CannotRun];    Scream["Loading "L, TRUE]; Scream[name];    loaderHandle ¬ MLoader.Load[fileHandle !      MLoader.Error => {Scream[" - MLoader Error"L]; ERROR CannotRun};      MLoader.VersionMismatch => {        Scream[" - Version mismatch"L]; ERROR CannotRun}];    END;  --of RunFile      TryToRun: PROCEDURE [interpress: BOOLEAN, root: LONG STRING] =    BEGIN    fileToRun: LONG STRING ¬ [MFile.maxNameLength];    loaderHandle: MLoader.Handle ¬ NIL;    numExt: CARDINAL = 2;    extensions: ARRAY [0..numExt) OF STRING = [".archiveBcd"L, ".bcd"L];    FOR i: CARDINAL IN [0..numExt) DO      String.Copy[fileToRun, root];      String.AppendString[fileToRun, extensions[i]];      loaderHandle ¬ RunFile[        fileToRun ! CannotRun => IF i < numExt - 1 THEN CONTINUE];      IF loaderHandle # NIL THEN EXIT;      ENDLOOP;    IF PrintReady[interpress] THEN Scream[" done"L]    ELSE {      IF loaderHandle # NIL THEN {        Scream[" - Unloading"L]; MLoader.Unload[loaderHandle]};      ERROR CannotRun};    END;  --of TryToRun        PreviousItem: PUBLIC PROCEDURE [item: ItemHandle] RETURNS [ItemHandle] = {    RETURN[itemBase[item].prev]};  PrintItem: PROCEDURE [item: ItemHandle] =    BEGIN    Break: break Token = [break[blankSpace: 0]];    Inconsistent: break Token = [break[inconsistent: TRUE]];    Space: break Token = [break[]];    End: end Token = [end[]];    BI: begin Token = [begin[breakType: inconsistent]];    B0: begin Token = [begin[offset: 0, breakType: consistent]];    TwoSpaces: break Token = [break[inconsistent: TRUE, blankSpace: 2]];    IF item # nullItem THEN      BEGIN      WITH t: itemBase[item].token SELECT FROM        string => {          crs: CARDINAL ¬            IF t.crCount > 1 OR t.comment # not THEN t.crCount ELSE 0;          needInconsistent: BOOLEAN ¬ FALSE;          index: CARDINAL = Inline.LowHalf[t.index];          IF t.comment # not THEN {            t.look ¬ italic;            IF crs = 0 AND crsOut = 0 THEN needInconsistent ¬ TRUE};          IF crs = LAST[Style.CRCount] THEN {            PrintNext[Style.LineBreak]; PrintNext[FF]; PrintNext[Style.LineBreak]}          ELSE THROUGH [crsOut..crs) DO PrintNext[Style.LineBreak] ENDLOOP;          IF needInconsistent THEN            PrintNext[IF t.comment = dash THEN Inconsistent ELSE TwoSpaces];          PrintNext[t];          crsOut ¬ 0;          SELECT t.comment FROM            dash => PrintNext[Inconsistent];            crlf => {PrintNext[Style.LineBreak]; crsOut ¬ 1};            ENDCASE};        inline => {PrintNext[t]; crsOut ¬ 0};        beforeProc => NULL;        afterProc => PrintNext[Space];        begin => {          depth ¬ depth + 1;          t.offset ¬ (t.offset/2)*indentPerLevel;          PrintNext[t]};        end => {depth ¬ depth - 1; PrintNext[itemBase[item].token]};        break => {          t.offset ¬ (t.offset/2)*indentPerLevel;          PrintNext[t];          IF t.blankSpace = Style.MaxBlanks THEN crsOut ¬ crsOut + 1};        ENDCASE => PrintNext[t];      END;    END;  PrintItems: PUBLIC PROCEDURE [lastItem: ItemHandle] =    BEGIN    item: ItemHandle;    IF data.switches['d] THEN ValidateItem[lastItem];    IF catchDepth > 0 THEN RETURN;    DO      IF itemBase[itemHead].next = lastItem THEN EXIT;  -- leave in buffer --      item ¬ DequeueItem[];      IF item = nullItem THEN EXIT;      IF itemBase[item].token.type = eof THEN eofSeen ¬ TRUE;      IF ~eofSeen THEN PrintItem[item];      FreeItem[item];      ENDLOOP;    END;  PrintNext: PROCEDURE [token: Token] =    BEGIN    OutBreak: PROCEDURE = INLINE {StyleToken[savedBreak, 0]; breakPending ¬ FALSE};    OutBegins: PROCEDURE = INLINE {      FOR b: Begins IN [0..beginsPending) DO StyleToken[savedBegins[b], 0] ENDLOOP;      beginsPending ¬ 0};    WITH t: token SELECT FROM      break => {        IF breakPending THEN {          IF savedBreak.blankSpace > 1 AND t.blankSpace > 1 THEN {            OutBreak[]; breakPending ¬ TRUE; savedBreak ¬ t}          ELSE {            savedBreak.blankSpace ¬ MAX[savedBreak.blankSpace, t.blankSpace];            savedBreak.inconsistent ¬ savedBreak.inconsistent OR t.inconsistent}}        ELSE {breakPending ¬ TRUE; savedBreak ¬ t}};      begin => {        IF beginsPending >= maxBegins THEN {          StyleToken[savedBegins[0], 0];          FOR b: Begins IN [0..maxBegins-1) DO            savedBegins[b] ¬ savedBegins[b + 1]            ENDLOOP;	  beginsPending ¬ maxBegins - 1};        savedBegins[beginsPending] ¬ t;        beginsPending ¬ beginsPending + 1};      end => {        IF beginsPending > 0 THEN {IF breakPending THEN OutBreak[]; OutBegins[]};        StyleToken[t, 0]};      string => {        IF breakPending THEN OutBreak[];        IF t.comment # crlf AND beginsPending > 0 THEN OutBegins[];        StyleToken[t, IF t.comment = crlf THEN 0 ELSE t.length]};      ENDCASE => {        IF breakPending THEN OutBreak[];        IF beginsPending > 0 THEN OutBegins[];        StyleToken[t, 0]};    END;  StringToken: PUBLIC PROCEDURE [item: ItemHandle] RETURNS [token: Style.StringTokenHandle] =    BEGIN    WITH t: itemBase[item].token SELECT FROM      string => token ¬ @t;      ENDCASE => ERROR ItemNotString;    END;  ValidateItem: PROCEDURE [item: ItemHandle] =    BEGIN    check: ItemHandle;    IF item = nullItem THEN RETURN;    FOR check ¬ itemBase[itemHead].next, itemBase[check].next UNTIL check = itemHead DO      IF check = item THEN RETURN; ENDLOOP;    ERROR ItemNotFound;    END;  -- cleanup of files/streams    GetFamily: PROC [font: LONG STRING] =    BEGIN       FOR i: CARDINAL IN [0..font.length) DO        IF font[i] IN ['0..'9] THEN 	  {font.length ¬ i; RETURN}      ENDLOOP    END;    LookAtUserDotCm: PROC = {    cm: CmFile.Handle = CmFile.UserDotCmOpen[! CmFile.Error => GOTO noUserDotCm];    i: CARDINAL;    table: ARRAY [0..4) OF LONG STRING ¬ ["CharsPerLine"L, "CharsPerLevel"L, "LandscapeFont"L, "PortraitFont"L];    IF CmFile.FindSection[cm, "Formatter"L] THEN      DO        SELECT (i ¬ CmFile.NextValue[cm, DESCRIPTOR[table] ! CmFile.TableError => RESUME]) FROM          StringLookUp.noMatch => EXIT;          0 => lineWidth ¬ renamedToNotConflictWithStyleDotToken.Decimal[cm];          1 => indentPerLevel ¬ renamedToNotConflictWithStyleDotToken.Decimal[cm];	  2 => {temp: LONG STRING ¬ renamedToNotConflictWithStyleDotToken.Item[cm];	        GetFamily[temp];	        landscapeFont ¬ String.CopyToNewString[temp, Heap.systemZone];		[] ¬ renamedToNotConflictWithStyleDotToken.FreeTokenString[temp]};	  3 => {temp: LONG STRING ¬ renamedToNotConflictWithStyleDotToken.Item[cm];	        GetFamily[temp];	        portraitFont ¬ String.CopyToNewString[temp, Heap.systemZone];		[] ¬ renamedToNotConflictWithStyleDotToken.FreeTokenString[temp]};          ENDCASE;	ENDLOOP;    [] ¬ CmFile.Close[cm];    EXITS noUserDotCm => NULL};  -- mainline code    LookAtUserDotCm[];  scanSize ¬ 3*lineWidth;  END.  -- of StyleImpl
-- Copyright (C) 1981, 1983, 1984  by Xerox Corporation. All rights reserved. -- Sequencer.mesa--   Satterthwaite,	December 5, 1980  9:03 AM--   Sweet,		20-Jan-84 15:53:54--   Karlton,		January 31, 1981  9:13 PM--   Loretta,		20-Feb-81 14:56:16--   Bruce,		 1-Jun-81 15:35:28--   JGS,		28-Aug-81 11:26:32--   Lewis,		 7-Oct-81 13:52:53--   Johnsson,		13-Jun-83 20:39:37--   Wagner,		 5-Apr-85 13:56:56DIRECTORY  Alloc: TYPE USING [defaultIndexBits,    Handle, TableInfo, Chunkify, Create, Destroy, Failure, Overflow, Reset],  CompilerOps: TYPE USING [StreamId, TableHandle, Transaction],  CompilerUtil: TYPE USING [    PassIndex, P1Unit, P2Unit, P3Unit, P3Postlude, P4Unit,    P5module, EndObjectFile, PrintBodies, PrintSymbols, PrintTree,    StartObjectFile, TableId, TableOut],  ComData: TYPE USING [    compilerVersion, interface, fileMap, formatting, globalFrameSize,    linkCount, nErrors, nWarnings, objectBytes, objectFile, objectVersion,    ownSymbols, sourceFile, sourceLines, sourceVersion,     switches, table, textIndex, zone],  Copier: TYPE USING [FileInit, FileReset],  Format: TYPE USING [CR, Char, Octal, StringProc],  MFile: TYPE USING [Error],  CLog: TYPE USING [Error],  OSMiscOps: TYPE USING [GenerateUniqueId, ImageId, SignalArgs, TimeToStamp],  PrincOps: TYPE USING [ControlLink],  Stream: TYPE USING [Handle, PutBlock, SendNow],  --SymbolPack: TYPE,  SymbolOps: TYPE USING [Finalize, Create, PrefillMesaSymbols],  SymbolSegment: TYPE USING [codeType, Tables, treeType],  Tree: TYPE USING [Link],  TreeOps: TYPE USING [PopTree, TreeReset],  Volume: TYPE USING [InsufficientSpace];Sequencer: PROGRAM [      explicitSwapping: BOOLEAN,      scratchZone: UNCOUNTED ZONE,      tableSegment: ARRAY CompilerUtil.TableId [parse..debug] OF CompilerOps.TableHandle]    IMPORTS      Alloc, CompilerUtil, Copier, Format, Log: CLog, MFile,      OSMiscOps, Stream, SymbolOps, TreeOps, Volume,       --ownSymbols: SymbolPack,-- dataPtr: ComData    EXPORTS CompilerOps, CompilerUtil =   BEGIN-- overlay control  PassIndex: TYPE = CompilerUtil.PassIndex;  LoadPass, UnloadPass: PROC [pass: PassIndex] = {};  MakeSwappable: PUBLIC PROC [module: PROGRAM, pass: PassIndex] = {};  -- scratch zone management  AcquireZone: PUBLIC PROC RETURNS [UNCOUNTED ZONE] = {RETURN[scratchZone]};  -- stream management  StreamId: TYPE = CompilerOps.StreamId;    TransactionPtr: TYPE = LONG POINTER TO CompilerOps.Transaction;  streamInfo: ARRAY StreamId [source .. log] OF RECORD [    stream: Stream.Handle,    status: RECORD [count: [0..LAST[INTEGER]], open: BOOLEAN]];  getStream: PROC [StreamId] RETURNS [Stream.Handle];    AcquireStream: PUBLIC PROC [id: StreamId] RETURNS [stream: Stream.Handle] = {    IF streamInfo[id].stream = NIL      THEN streamInfo[id] ¬ [stream: getStream[id], status: [count:0, open:TRUE]];    stream ¬ streamInfo[id].stream;    IF streamInfo[id].status = [count: 0, open: FALSE] THEN      streamInfo[id].status.open ¬ TRUE;    streamInfo[id].status.count ¬ streamInfo[id].status.count + 1};  ReleaseStream: PUBLIC PROC [id: StreamId] = {    streamInfo[id].status.count ¬ streamInfo[id].status.count - 1;    IF streamInfo[id].status.count = 0      THEN {	Stream.SendNow[streamInfo[id].stream];	streamInfo[id].status.open ¬ FALSE}};  stringProcs: ARRAY StreamId [source .. log] OF Format.StringProc = [    source: SourceStringProc, object: ObjectStringProc, log: LogStringProc];  AcquireStringProc: PUBLIC PROC [    id: StreamId] RETURNS [stringProc: Format.StringProc] = {    [] ¬ AcquireStream[id];    RETURN[stringProcs[id]]};  ReleaseStringProc: PUBLIC PROC [id: StreamId] = ReleaseStream;  SourceStringProc: Format.StringProc = {    Stream.PutBlock[streamInfo[source].stream, [LOOPHOLE[@s.text], 0, s.length]]};  ObjectStringProc: Format.StringProc = {}; -- this doesn't make sense -- Stream.PutBlock[streamInfo[object].stream, [LOOPHOLE[@s.text], 0, s.length]]};  LogStringProc: Format.StringProc = {    Stream.PutBlock[streamInfo[log].stream, [LOOPHOLE[@s.text], 0, s.length]]};-- table segment management  AcquireTable: PUBLIC PROC [id: CompilerUtil.TableId] RETURNS [LONG POINTER] = {    RETURN[LOOPHOLE[tableSegment[id]]]};  ReleaseTable: PUBLIC PROC [id: CompilerUtil.TableId] = {};-- compiler sequencing  pass: CHARACTER ['0..'5];  Initialize: PROC = {    weights: ARRAY SymbolSegment.Tables OF Alloc.TableInfo ¬      [  -- relative sizes (empirical)       [Alloc.defaultIndexBits, 30, 64],	-- treeType       [Alloc.defaultIndexBits, 20, 64],	-- seType       [Alloc.defaultIndexBits, 4, 8],	-- htType       [Alloc.defaultIndexBits, 4, 12],	-- ssType       [Alloc.defaultIndexBits, 4, 8],	-- ctxType       [Alloc.defaultIndexBits, 2, 6],	-- mdType       [Alloc.defaultIndexBits, 4, 16],	-- bodyType       [Alloc.defaultIndexBits, 1, 4],	-- ltType       [Alloc.defaultIndexBits, 2, 6],	-- stType       [Alloc.defaultIndexBits, 1, 1],	-- extType       [Alloc.defaultIndexBits, 1, 1],	-- atType       [Alloc.defaultIndexBits, 2, 5],	-- constType       [Alloc.defaultIndexBits, 20, 64]];	-- codeType    formatWeights: ARRAY SymbolSegment.Tables OF Alloc.TableInfo ¬      [  -- relative sizes (empirical)       [Alloc.defaultIndexBits, 1, 1],	-- treeType       [Alloc.defaultIndexBits, 2, 2],	-- seType       [Alloc.defaultIndexBits, 2, 2],	-- htType       [Alloc.defaultIndexBits, 2, 2],	-- ssType       [Alloc.defaultIndexBits, 1, 1],	-- ctxType       [Alloc.defaultIndexBits, 1, 1],	-- mdType       [Alloc.defaultIndexBits, 1, 1],	-- bodyType       [Alloc.defaultIndexBits, 1, 1],	-- ltType       [Alloc.defaultIndexBits, 1, 1],	-- stType       [Alloc.defaultIndexBits, 1, 1],	-- extType       [Alloc.defaultIndexBits, 1, 1],	-- atType       [Alloc.defaultIndexBits, 1, 1],	-- constType       [Alloc.defaultIndexBits, 1, 1]];	-- codeType    IF dataPtr.table = NIL THEN {      IF dataPtr.formatting THEN        dataPtr.table ¬ Alloc.Create[weights: DESCRIPTOR[formatWeights]]      ELSE dataPtr.table ¬ Alloc.Create[weights: DESCRIPTOR[weights]];       Alloc.Chunkify[dataPtr.table, SymbolSegment.treeType];      Alloc.Chunkify[dataPtr.table, SymbolSegment.codeType]}    ELSE Alloc.Reset[dataPtr.table];    dataPtr.ownSymbols ¬ SymbolOps.Create[dataPtr.table, scratchZone]};  Finalize: PROC [parms: TransactionPtr] = {    parms.sourceLines ¬ dataPtr.sourceLines;    parms.nErrors ¬ dataPtr.nErrors;  parms.nWarnings ¬ dataPtr.nWarnings;    IF ~dataPtr.formatting THEN {      parms.objectBytes ¬ dataPtr.objectBytes;      parms.objectFrameSize ¬ dataPtr.globalFrameSize;        parms.linkCount ¬ dataPtr.linkCount;      CompilerUtil.EndObjectFile[dataPtr.nErrors=0]};    SymbolOps.Finalize[dataPtr.ownSymbols];    Alloc.Reset[dataPtr.table]};        FreeAllocTables: PUBLIC PROC = {    IF dataPtr.table # NIL THEN {      Alloc.Destroy[dataPtr.table]; dataPtr.table ¬ NIL}};  Debug: PROC [tree, symbols: PROC] = {tree[]; symbols[]};  Punt: PUBLIC ERROR = CODE;  CompileAction: PUBLIC PROC [parms: TransactionPtr] = {    root: Tree.Link;    msg: UNSPECIFIED;    signal: SIGNAL;    nParseErrors: CARDINAL;    parsed, aborted: BOOLEAN;    PrintTreeRoot: PROC = {CompilerUtil.PrintTree[dataPtr.table, root]};    PrintAllSymbols: PROC = {CompilerUtil.PrintSymbols[dataPtr.table, TRUE]};    PrintAllBodies: PROC = {CompilerUtil.PrintBodies[dataPtr.table]};    pass ¬ '0;    dataPtr.formatting ¬ (parms.op = format);    getStream ¬ parms.getStream;    dataPtr.fileMap ¬ parms.fileMap;    dataPtr.sourceFile ¬ parms.sourceId;    dataPtr.sourceVersion ¬ OSMiscOps.TimeToStamp[parms.sourceVersion];    dataPtr.objectFile ¬ parms.objectId;    dataPtr.objectVersion ¬ OSMiscOps.GenerateUniqueId[];    dataPtr.switches ¬ parms.switches; dataPtr.formatting ¬ (parms.op = format);    dataPtr.nErrors ¬ dataPtr.nWarnings ¬ 0;  aborted ¬ FALSE;    streamInfo[source] ¬ streamInfo[object] ¬ streamInfo[log] ¬      [stream: NIL, status: [count: 0, open: FALSE]];    Initialize[];      BEGIN      ENABLE {         Alloc.Overflow => RESUME[8];	Alloc.Failure => IF ~dataPtr.switches['d] THEN GO TO storageFull;	UNWIND => Finalize[parms];	ABORTED => REJECT;	MFile.Error => 	  IF code = noRoomOnVolume THEN REJECT 	  ELSE {signal ¬ LOOPHOLE[MFile.Error]; msg ¬ code; GO TO uncaughtSignal};	Volume.InsufficientSpace => REJECT;	ANY =>	  IF ~dataPtr.switches['d]	    THEN {	      mess: POINTER TO UNSPECIFIED;	      [signal: signal, message: mess] ¬ OSMiscOps.SignalArgs[]; 	      IF mess = NIL THEN msg ¬ NIL ELSE msg ¬ mess­;	      GO TO uncaughtSignal}	};      [] ¬ SymbolOps.PrefillMesaSymbols[dataPtr.ownSymbols];      dataPtr.textIndex ¬ 0;     -- first pass      IF parms.startPass # NIL AND ~parms.startPass[1] THEN GO TO cancel;      pass ¬ '1;      parsed ¬ CompilerUtil.P1Unit[];      nParseErrors ¬ dataPtr.nErrors;--    IF ~parsed THEN GO TO failed;      IF nParseErrors # 0 THEN GO TO failed;      IF ~dataPtr.formatting THEN {root ¬ TreeOps.PopTree[dataPtr.ownSymbols];  TreeOps.TreeReset[dataPtr.ownSymbols]};      IF parms.debugPass <= 1	THEN Debug[PrintTreeRoot, PrintAllSymbols];    IF ~dataPtr.formatting THEN {    -- second pass      IF parms.startPass # NIL AND ~parms.startPass[2] THEN GO TO cancel;      pass ¬ '2;      root ¬ CompilerUtil.P2Unit[dataPtr.ownSymbols, root];      IF parms.debugPass <= 2	THEN Debug[PrintTreeRoot, PrintAllSymbols];    -- third and fourth passes      IF parms.startPass # NIL AND ~parms.startPass[3] THEN GO TO cancel;      Copier.FileInit[h: dataPtr.ownSymbols,         self: dataPtr.objectFile, version: dataPtr.objectVersion];	BEGIN	  ENABLE Alloc.Failure => IF ~dataPtr.switches['d] THEN GO TO noSpace;	pass ¬ '3;	root ¬ CompilerUtil.P3Unit[dataPtr.ownSymbols, root];	CompilerUtil.P3Postlude[dataPtr.nErrors <= nParseErrors];	IF parms.debugPass <= 3	  THEN Debug[PrintTreeRoot, PrintAllSymbols];	IF dataPtr.nErrors > nParseErrors THEN GO TO DeleteFiles;	IF parms.startPass # NIL AND ~parms.startPass[0] THEN GO TO subCancel;	CompilerUtil.StartObjectFile[AcquireStream[object ! ABORTED =>	  {Log.Error[aborted]; GO TO DeleteFiles}], scratchZone];	IF parms.startPass # NIL AND ~parms.startPass[4] THEN GO TO subCancel;	pass ¬ '4;	CompilerUtil.P4Unit[dataPtr.ownSymbols, root];	IF parms.debugPass <= 4	  THEN Debug[PrintAllBodies, PrintAllSymbols];	GO TO DeleteFiles;	EXITS	  DeleteFiles => Copier.FileReset[dataPtr.ownSymbols];	  subCancel => {Copier.FileReset[dataPtr.ownSymbols]; GO TO cancel};	  noSpace => {Copier.FileReset[dataPtr.ownSymbols]; GO TO storageFull};	END;	IF dataPtr.nErrors # 0 THEN GO TO failed;        -- fifth pass	IF parms.startPass # NIL AND ~parms.startPass[5] THEN GO TO cancel;	IF ~dataPtr.interface	  THEN {	    ENABLE UNWIND => CompilerUtil.EndObjectFile[FALSE];	    pass ¬ '5;	    CompilerUtil.P5module[]};      -- "sixth" pass	IF parms.startPass # NIL THEN [] ¬ parms.startPass[6];  	CompilerUtil.TableOut[dataPtr.table];	IF dataPtr.nErrors # 0 THEN GO TO failed}      ELSE         FOR i: CARDINAL IN [2..6] DO	  IF parms.startPass # NIL THEN [] ¬ parms.startPass[6];	ENDLOOP;      EXITS	failed => aborted ¬ TRUE;        cancel => {	  IF pass IN ['1..'5] THEN Log.Error[aborted]	  ELSE dataPtr.nErrors ¬ 1; -- avoid printing out count of bytes, etc.	  aborted ¬ TRUE};	uncaughtSignal => {	  errorProc: Format.StringProc = AcquireStringProc[log];	  siglink: PrincOps.ControlLink ¬ LOOPHOLE[signal];	  Log.Error[compilerError];  aborted ¬ TRUE;	  errorProc["in Pass "L];  Format.Char[errorProc, pass];	  errorProc[", signal = ["L];  Format.Octal[errorProc, siglink.gf];	  errorProc[", "L]; Format.Octal[errorProc, siglink.pc];	  errorProc["], message = "L];  Format.Octal[errorProc, msg];	  Format.CR[errorProc];	  ReleaseStream[log];	  Finalize[parms];  ERROR Punt[]};	storageFull => {Log.Error[aborted]; StorageProblem["overflow"L]};      END;    Finalize[parms]};  StorageProblem: PROC [message: STRING] = {    OPEN Format;    errorProc: StringProc = AcquireStringProc[log];    dataPtr.nErrors ¬ dataPtr.nErrors+1;    CR[errorProc];    errorProc["Storage "L];  errorProc[message];    errorProc[" in Pass "L];  Char[errorProc, pass];    CR[errorProc];    ReleaseStringProc[log]};-- * * * * * *  M A I N   B O D Y   C O D E  * * * * * *  START dataPtr; 	-- initialize STRING variables, etc.  dataPtr.zone ¬ scratchZone;    --START ownSymbols;  --dataPtr.ownSymbols ¬ ownSymbols;  dataPtr.compilerVersion ¬ OSMiscOps.ImageId[];  dataPtr.table ¬ NIL;  END.
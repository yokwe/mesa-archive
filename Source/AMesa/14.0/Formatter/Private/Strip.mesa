-- Copyright (C) 1982  by Xerox Corporation. All rights reserved. -- File: Strip.mesa - last edited by-- Karlton;	25-Feb-82 10:44:40-- Rhonda	29-Sep-82 16:15:06-- Haynes,	20-Dec-82 16:27:19DIRECTORY  Ascii USING [ControlZ, CR, SP, TAB],  CommandUtil USING [    CommandPtr, Create, Destroy, Echo, Failed, FreePairList, FreeString, GetNth,    GetNthPair, ListLength, PairList, Parse],  Exec USING [    AddCommand, CheckForAbort, ExecProc, GetChar, GetTTY, Outcome, ReleaseTTY],  Format USING [StringProc],  MFile USING [AcquireTemp, CopyFileHandle, Error, Handle, Release, SwapNames],  MStream USING [    Create, EndOf, Error, GetFile, GetLength, Handle, ReadOnly, WriteOnly],  Stream USING [    Delete, EndOfStream, GetChar, GetPosition, Handle, PutChar, SetPosition],  String USING [    AppendChar, AppendString, EquivalentString, InvalidNumber, StringLength,    StringToDecimal],  TTY USING [Handle, PutChar, PutLine, PutText];Strip: PROGRAM  IMPORTS CommandUtil, Exec, Stream, MFile, MStream, String, TTY =  BEGIN  leftMarginMicas: CARDINAL = 2998;  defaultMicasPerChar: CARDINAL = 222;  tabWidth: CARDINAL = 8;  lineHeight: CARDINAL = 10;  Command: Exec.ExecProc = {    tty: TTY.Handle = Exec.GetTTY[h];    thisTry: Exec.Outcome;    inStream, outStream: Stream.Handle ¬ NIL;    micasPerChar: CARDINAL ¬ defaultMicasPerChar;    GetChar: PROCEDURE RETURNS [CHARACTER] = {RETURN[Exec.GetChar[h]]};    cmd: CommandUtil.CommandPtr = CommandUtil.Create[GetChar];    source, dest, switches: LONG STRING ¬ NIL;    results, args: CommandUtil.PairList;    EchoCommand: Format.StringProc = {IF s # NIL THEN TTY.PutText[tty, s]};    CleanUp: PROCEDURE [final: BOOLEAN] = {      -- assert: dest=source OR dest is in results pairlist => no free[dest]      source ¬ CommandUtil.FreeString[source];      dest ¬ NIL;      switches ¬ CommandUtil.FreeString[switches];      results ¬ CommandUtil.FreePairList[results];      args ¬ CommandUtil.FreePairList[args];      IF inStream # NIL THEN {inStream.Delete[]; inStream ¬ NIL};      IF outStream # NIL THEN {outStream.Delete[]; outStream ¬ NIL};      IF final THEN {CommandUtil.Destroy[cmd]; Exec.ReleaseTTY[tty]}};    DO      ENABLE UNWIND => CleanUp[TRUE];      IF Exec.CheckForAbort[h] THEN {thisTry ¬ abort; EXIT};      [source, args, results, switches] ¬ CommandUtil.Parse[        cmd: cmd, opX: (".mesa"L).length, resultX: (".mesa"L).length,        allowNoTagParm: TRUE ! CommandUtil.Failed => GOTO badSyntax];      IF source = NIL AND switches = NIL THEN EXIT;      IF source = NIL THEN {CleanUp[FALSE]; LOOP};      AppendExtension[source, ".mesa"L];      CommandUtil.Echo[EchoCommand, source, args, results, switches];      TTY.PutText[tty, ": "L];      SELECT CommandUtil.ListLength[results] FROM        0 => NULL;        1 => dest ¬ CommandUtil.GetNth[list: results, n: 0];        ENDCASE => {          TTY.PutLine[tty, "Bad command syntax"L]; thisTry ¬ error; EXIT};      IF dest = NIL THEN dest ¬ source;      AppendExtension[dest, ".mesa"L];      {t1, t2: LONG STRING;      [t1, t2] ¬ CommandUtil.GetNthPair[args, 0];      [thisTry, micasPerChar] ¬ ParseParam[tty, t1, t2]};      IF thisTry = normal THEN        [thisTry, inStream, outStream] ¬ GetFiles[tty, source, dest];      IF thisTry = normal THEN {        inFile, tempFile: MFile.Handle;        overWrite: BOOLEAN = outStream = NIL;        IF overWrite THEN {          inFile ¬ MFile.CopyFileHandle[            MStream.GetFile[inStream], [], rename !            MFile.Error => {              TTY.PutLine[tty, "can't be replaced"L];              {inStream.Delete[]; inStream ¬ NIL};              GOTO failed}];          tempFile ¬ MFile.AcquireTemp[            type: text, initialLength: MStream.GetLength[inStream]];          outStream ¬ MStream.Create[tempFile, []];          tempFile ¬ MFile.CopyFileHandle[tempFile, [], rename]};        StripIt[inStream, outStream, micasPerChar];        {inStream.Delete[]; inStream ¬ NIL};        {outStream.Delete[]; outStream ¬ NIL};        IF overWrite THEN {          MFile.SwapNames[inFile, tempFile];	  MFile.Release[inFile];          MFile.Release[tempFile]};        TTY.PutLine[tty, "stripped."L];        EXITS failed => thisTry ¬ error};      IF thisTry > outcome THEN outcome ¬ thisTry;      REPEAT badSyntax => outcome ¬ error;      ENDLOOP;    CleanUp[TRUE];    RETURN[outcome]};  GetFiles: PROCEDURE [tty: TTY.Handle, source, dest: LONG STRING]    RETURNS [outcome: Exec.Outcome ¬ normal, in, out: Stream.Handle ¬ NIL] =    BEGIN    in ¬ MStream.ReadOnly[      source, [] !      MStream.Error => {        TTY.PutLine[tty, "Input file not available."L]; GOTO failed}];    IF ~String.EquivalentString[dest, source] THEN      out ¬ MStream.WriteOnly[        dest, [], text !        MStream.Error => {          TTY.PutLine[tty, "Output file can't be written."L];          {in.Delete[]; in ¬ NIL};          GOTO failed}];    EXITS failed => outcome ¬ error;    END;  ParseParam: PROCEDURE [tty: TTY.Handle, name, value: LONG STRING]    RETURNS [Exec.Outcome, CARDINAL] =    BEGIN    micas: CARDINAL;    IF String.StringLength[name] > 0 THEN {      compareVal: STRING ¬ "MicasPerCharacter"L;      compareVal.length ¬ name.length;      IF ~String.EquivalentString[compareVal, name] THEN {        TTY.PutChar[tty, '"];        TTY.PutText[tty, name];        TTY.PutChar[tty, '"];        TTY.PutLine[tty, " is an unrecognized argument."L];        GOTO badParam}};    IF String.StringLength[value] = 0 THEN RETURN[normal, defaultMicasPerChar];    micas ¬ String.StringToDecimal[value ! String.InvalidNumber => {      TTY.PutChar[tty, '"];      TTY.PutText[tty, value];      TTY.PutChar[tty, '"];      TTY.PutLine[tty, " is an invalid number."L];      GOTO badParam}];    RETURN[normal, micas];    EXITS badParam => {RETURN[error, defaultMicasPerChar]};    END;  AppendExtension: PROCEDURE [name, ext: LONG STRING] =    BEGIN    FOR i: CARDINAL IN [0..name.length) DO      IF name[i] = '. THEN EXIT;      REPEAT FINISHED => String.AppendString[name, ext];      ENDLOOP;    END;  PutLeading: PROCEDURE [out: Stream.Handle, leading: CARDINAL] =    BEGIN    THROUGH [0..(leading + lineHeight/2)/lineHeight) DO      out.PutChar[Ascii.CR]; ENDLOOP;    RETURN    END;  PutMargin: PROCEDURE [out: MStream.Handle, micas, micasPerChar: CARDINAL] =    BEGIN    chars: CARDINAL;    micas ¬ IF leftMarginMicas > micas THEN 0 ELSE micas - leftMarginMicas;    chars ¬ (micas + micasPerChar/2)/micasPerChar;    THROUGH [0..chars/tabWidth) DO out.PutChar[Ascii.TAB]; ENDLOOP;    THROUGH [0..chars MOD tabWidth) DO out.PutChar[Ascii.SP] ENDLOOP;    RETURN    END;  PutParagraph: PROCEDURE [    in, out: Stream.Handle, info: MarginInfo, start: LONG CARDINAL,    micasPerChar: CARDINAL, unformatted: BOOLEAN ¬ FALSE] =    BEGIN OPEN info;    c: CHARACTER;    first: BOOLEAN ¬ TRUE;    PutLeading[out, paraLeading + lineLeading];    PutMargin[out, IF firstLine # 0 THEN firstLine ELSE leftMargin, micasPerChar];    in.SetPosition[start];    THROUGH [0..pChars) DO      c ¬ in.GetChar[];      out.PutChar[c];      IF c = Ascii.CR THEN        BEGIN        PutLeading[out, lineLeading];        PutMargin[out, leftMargin, micasPerChar];        END;      ENDLOOP;    IF ~unformatted THEN out.PutChar[Ascii.CR];    RETURN    END;  FindTrailer: PROCEDURE [input: Stream.Handle] RETURNS [info: MarginInfo] =    BEGIN    number: STRING ¬ [10];    c: CHARACTER;    value: CARDINAL;    mode, newmode: {leftMarg, lineLead, paraLead, firstLine, return, null};    info ¬ [0, 0, 0, 0];    mode ¬ newmode ¬ null;    DO      SELECT (c ¬ input.GetChar[]) FROM        Ascii.CR => newmode ¬ return;        '( =>          UNTIL input.GetChar[] = ') DO            REPEAT FINISHED => newmode ¬ null; ENDLOOP;        '\\=>          UNTIL input.GetChar[] = Ascii.CR DO            REPEAT FINISHED => newmode ¬ return; ENDLOOP;        'l => newmode ¬ leftMarg;        'x => newmode ¬ lineLead;        'e => newmode ¬ paraLead;        'd => newmode ¬ firstLine;        IN CHARACTER ['0..'9] => String.AppendChar[number, c];        ENDCASE => newmode ¬ null;      IF newmode # mode THEN        BEGIN        value ¬ IF number.length = 0 THEN 0 ELSE String.StringToDecimal[number];        number.length ¬ 0;        SELECT mode FROM          leftMarg => info.leftMargin ¬ value;          lineLead => info.lineLeading ¬ value;          paraLead => info.paraLeading ¬ value;          firstLine => info.firstLine ¬ value;          ENDCASE;        IF (mode ¬ newmode) = return THEN RETURN;        END;      ENDLOOP;    END;  MarginInfo: TYPE = RECORD [    leftMargin, firstLine, lineLeading, paraLeading: CARDINAL];  pChars: CARDINAL;  StripIt: PROCEDURE [input, output: Stream.Handle, micasPerChar: CARDINAL] =    BEGIN    paraStart, paraEnd: LONG CARDINAL;    info: MarginInfo;    UNTIL MStream.EndOf[input] DO      paraStart ¬ input.GetPosition[];      pChars ¬ 0;      DO        IF input.GetChar[ ! Stream.EndOfStream => GO TO eof] = Ascii.ControlZ THEN          BEGIN          info ¬ FindTrailer[input];          paraEnd ¬ input.GetPosition[];          PutParagraph[input, output, info, paraStart, micasPerChar, FALSE];          input.SetPosition[paraEnd];          EXIT;          END        ELSE pChars ¬ pChars + 1;        REPEAT          eof => {            info ¬ [0, 0, 0, 0];            PutParagraph[input, output, info, paraStart, micasPerChar, TRUE]};        ENDLOOP;      ENDLOOP;    END;  -- Main body  Init: PROCEDURE = {Exec.AddCommand["Strip.~"L, Command]};  Init[];  END...
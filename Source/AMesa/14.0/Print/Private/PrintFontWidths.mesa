-- Copyright (C) 1982  by Xerox Corporation. All rights reserved. -- PrintFontWidths.mesa, edit by RXJ     ; 29-Nov-82 11:09:04DIRECTORY  Inline USING [LongMult],  MStream USING [Error, ReadOnly],  Press USING [FontSlope, FontWeight, Mica],  PressUtilities USING [],  Stream USING [Delete, GetWord, Handle, GetBlock, SetPosition];PrintFontWidths: PROGRAM  IMPORTS Inline, MStream, Stream EXPORTS PressUtilities =  BEGIN    FontSlope: TYPE = Press.FontSlope;  FontWeight: TYPE = Press.FontWeight;  Mica: TYPE = Press.Mica;  magicNonPrintingWidth: Mica = 100000B;  Points: TYPE = CARDINAL;    NoFontsDotWidths: PUBLIC SIGNAL = CODE;  FontNotFound: PUBLIC ERROR = CODE;  FontWidthError: PUBLIC ERROR = CODE;  -- bug in us, or file in wrong format    FontName: TYPE = PACKED ARRAY [0..20) OF BYTE;  FontFace: TYPE = [0..2*3*3); -- this wasn't my idea    BYTE: TYPE = [0..377B];    -- see [Indigo]<Press>FontFormats.bravo  -- if index.size=0, then numbers need to be scaled by points*2540/72000    IX: TYPE = MACHINE DEPENDENT RECORD [type: [0..17B), length: [0..7777B]];  IXN: TYPE = MACHINE DEPENDENT RECORD [e: IX, code: WORD, name: FontName];  SDTIX: TYPE = MACHINE DEPENDENT RECORD [    e: IX,    code, face: BYTE,    bc, ec: CHARACTER,    size: Points,    rotation: INTEGER,    x1, location, x2, length: CARDINAL]; -- position in file    WidthSegment: TYPE = MACHINE DEPENDENT RECORD [    fBBox, fBBoy, fBBdx, fBBdy: WORD, xFeed, yFeed: BOOLEAN, xxx: [0..37777B]];    ComputeFontFace: PROCEDURE [w: FontWeight, s: FontSlope]    RETURNS [ff: FontFace] =    BEGIN    ff ¬ 0;    SELECT w FROM      medium => ff ¬ ff + 0;      bold => ff ¬ ff + 2;      --light => ff ¬ ff+4;      ENDCASE;    SELECT s FROM      regular => ff ¬ ff + 0;      italic => ff ¬ ff + 1;      ENDCASE;    --SELECT expansion FROM    --  regular => ff ¬ ff+0;    --  condensed => ff ¬ ff+6;    --  expanded => ff ¬ ff+12;    --  ENDCASE;        END;      GetBlock: PROCEDURE [s: Stream.Handle, p: POINTER, n: CARDINAL] RETURNS [CARDINAL] =    BEGIN    RETURN[(Stream.GetBlock[s, [LONG[p], 0, n*2]].bytesTransferred + 1)/2];    END;      FindFontWidths: PUBLIC PROCEDURE [    family: LONG STRING, size: Mica, weight: FontWeight, slope: FontSlope,    widths: LONG POINTER TO ARRAY CHARACTER OF Mica]    RETURNS [fBBox, fBBoy, fBBdx, fBBdy: Mica] =    BEGIN        ScaleThings: PROCEDURE [p: CARDINAL] RETURNS [m: Mica] =      BEGIN OPEN Inline;      m ¬ p;      IF m = magicNonPrintingWidth THEN RETURN[0];      IF index.size # 0 THEN RETURN;      -- This will overflow at about 200 points.      RETURN[(size*m)/1000];      END;          ff: FontFace = ComputeFontFace[weight, slope];    i: CARDINAL;    c: CHARACTER;    code: WORD;    nameFound, indexFound: BOOLEAN ¬ FALSE;    name: FontName;    s: Stream.Handle ¬ NIL;    e: IX;    header: IXN;    index: SDTIX;    width: WidthSegment;    s ¬ MStream.ReadOnly["Fonts.widths"L, [] ! MStream.Error => {      SIGNAL NoFontsDotWidths; ERROR FontNotFound}];    BEGIN ENABLE UNWIND => Stream.Delete[s];    -- copy over the family name into Fonts.Widths format    name ¬ ALL[0];    name[0] ¬ family.length;    FOR i IN [0..MIN[family.length, 19]) DO      SELECT family[i] FROM	IN ['A..'Z] => name[i + 1] ¬ LOOPHOLE[family[i]];	IN ['a..'z] => name[i + 1] ¬ LOOPHOLE[family[i], BYTE] - 40B;	ENDCASE;      ENDLOOP;    DO      IF GetBlock[s, @e, SIZE[IX]] = 0 THEN ERROR FontWidthError;      SELECT e.type FROM	0 => EXIT;	1 =>	  BEGIN	  IF e.length # SIZE[IXN] THEN ERROR FontWidthError;	  IF GetBlock[s, @header + 1, SIZE[IXN] - 1] = 0 THEN	    ERROR FontWidthError;	  IF EqualName[@name, @header.name] THEN	    BEGIN code ¬ header.code; nameFound ¬ TRUE; END;	  END;	4 =>	  BEGIN	  IF e.length # SIZE[SDTIX] THEN ERROR FontWidthError;	  IF GetBlock[s, @index + 1, SIZE[SDTIX] - 1] = 0 THEN	    ERROR FontWidthError;	  IF nameFound AND code = index.code AND ff = index.face AND	    index.rotation = 0 AND (index.size = 0 OR index.size = size)	    THEN BEGIN indexFound ¬ TRUE; EXIT; END;	  END;	ENDCASE => ERROR FontWidthError;      ENDLOOP;    IF ~indexFound THEN ERROR FontNotFound;    IF index.x1 # 0 OR index.x2 # 0 THEN ERROR FontWidthError;    -- position file to starting byte of our info    Stream.SetPosition[s, Inline.LongMult[index.location, 2]];    IF GetBlock[s, @width, SIZE[WidthSegment]] = 0 THEN      ERROR FontWidthError;    fBBox ¬ ScaleThings[width.fBBox];    fBBoy ¬ ScaleThings[width.fBBoy];    fBBdx ¬ ScaleThings[width.fBBdx];    fBBdy ¬ ScaleThings[width.fBBdy];    IF width.xFeed THEN      BEGIN      x: Mica = ScaleThings[Stream.GetWord[s]];      FOR c IN [index.bc..index.ec] DO widths[c] ¬ x; ENDLOOP;      END    ELSE      BEGIN      FOR c IN [index.bc..index.ec] DO widths[c] ¬ ScaleThings[Stream.GetWord[s]]; ENDLOOP;      END;    END; -- of ENABLE    Stream.Delete[s];    END;      EqualName: PROCEDURE [n1, n2: POINTER TO FontName] RETURNS [BOOLEAN] =    BEGIN    i: CARDINAL;    FOR i IN [0..20) DO IF n1[i] # n2[i] THEN RETURN[FALSE]; ENDLOOP;    RETURN[TRUE];    END;        END.
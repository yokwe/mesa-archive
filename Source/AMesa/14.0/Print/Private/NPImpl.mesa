-- File: NPImpl.mesa - last edit:-- Nannette.PA         22-Apr-85 13:38:46-- Copyright (C) 1982, 1983 , 1985 by Xerox Corporation. All rights reserved. -- NPImpl.mesa; edit by-- Newlin,	18-Aug-82 17:08:49-- RXJ     ,	19-Apr-83 18:52:27-- NSG     ,	22-Apr-85 13:37:53DIRECTORY  Environment USING [Block],  Inline USING [HighByte, HighHalf, LowByte, LowHalf],  Interpress82Maker USING [],  MSegment USING [FreeWords, GetWords],  MStream USING [WriteOnly],  Press USING [    Coordinate, Encoding, FontAlias, FontSlope, FontWeight, Handle, Interface,    Mica, Rational, StrokeEnd, WidthHandle],  PressUtilities USING [FindFontWidths, FontNotFound, FontWidthError],  Stream USING [Delete, Handle, PutBlock, PutByte, PutChar],  String USING [    AppendChar, AppendDecimal, AppendLongDecimal, AppendString,    EquivalentString, SubString],  Syntax USING [    ImagerVariable, MasterEncoding, OperatorEnumeration,    SHORTINTEGER, SmallOperatorEnumeration];NPImpl: PROGRAM  IMPORTS Inline, MSegment, MStream, PressUtilities, Stream, String, Syntax  EXPORTS Interpress82Maker  SHARES Press =  BEGIN    tracing: BOOLEAN ¬ FALSE;    Coordinate: TYPE = Press.Coordinate;  Mica: TYPE = Press.Mica;    Rational: TYPE = Press.Rational;  tenToMinusFive: Rational = [num: 1, den: 100000];    UZ: TYPE = UNCOUNTED ZONE;    Object: TYPE = RECORD [    inSheet, active: BOOLEAN ¬ FALSE,    output: Stream.Handle ¬ NIL,    zone: UZ,    fontNameSpacePrefix: LONG STRING ¬ NIL,    fontChain: AliasedFontHandle ¬ NIL,    currentFont, savedFont: AliasedFontHandle ¬ NIL];    DataHandle: TYPE = LONG POINTER TO Object;  -- Text  PutBlock: PROCEDURE [h: Press.Handle, block: Environment.Block] =    BEGIN    OutputBlock[h.data, block];    OutputOperation[h.data, Show];    END;  PutString: PROCEDURE [h: Press.Handle, text: LONG STRING] =    BEGIN    OutputBlock[h.data, [LOOPHOLE[@text.text], 0, text.length]];    OutputOperation[h.data, Show];    END;  PutSubString: PROCEDURE [h: Press.Handle, text: String.SubString] =    BEGIN    OutputBlock[h.data,      [LOOPHOLE[@text.base.text], text.offset, text.offset+text.length]];    OutputOperation[h.data, Show];    END;  CharWidth: PROCEDURE [h: Press.Handle, c: CHARACTER, alias: Press.FontAlias] RETURNS [Press.Mica] =    BEGIN    data: DataHandle = h.data;    handle: AliasedFontHandle ¬ data.currentFont;    IF handle = NIL OR handle.alias # alias THEN       BEGIN       FOR handle ¬ data.fontChain, handle.next UNTIL handle = NIL DO        IF handle.alias = alias THEN EXIT;        REPEAT FINISHED => RETURN[0];        ENDLOOP;      END;    IF handle.widths = NIL THEN GetWidths[handle];    RETURN[handle.widths[c]]    END;  -- Graphics    LineTo: PROCEDURE [h: Press.Handle, place: Coordinate] =    BEGIN    OutputInteger[h.data, place.x];    OutputInteger[h.data, place.y];    OutputOperation[h.data, LineTo];    END;    LineToX: PROCEDURE [h: Press.Handle, x: Mica] =    BEGIN    OutputInteger[h.data, x];    OutputOperation[h.data, LineToX];    END;    LineToY: PROCEDURE [h: Press.Handle, y: Mica] =    BEGIN    OutputInteger[h.data, y];    OutputOperation[h.data, LineToY];    END;    MoveTo: PROCEDURE [h: Press.Handle, place: Coordinate] =    BEGIN    OutputInteger[h.data, place.x];    OutputInteger[h.data, place.y];    OutputOperation[h.data, MoveTo];    END;    MakeOutline: PROCEDURE [h: Press.Handle, n: CARDINAL] =    BEGIN    OutputInteger[h.data, n];    OutputOperation[h.data, MakeOutline];    END;    MaskFill: PROCEDURE [h: Press.Handle] = {OutputOperation[h.data, MaskFill]};    MaskStroke: PROCEDURE [h: Press.Handle] = {OutputOperation[h.data, MaskStroke]};    MaskRectangle: PROCEDURE [h: Press.Handle, width, height: Mica, place: Coordinate] =    BEGIN    OutputInteger[h.data, place.x];    OutputInteger[h.data, place.y];    OutputInteger[h.data, width];    OutputInteger[h.data, height];    OutputOperation[h.data, MaskRectangle];    END;    SetStrokeEnd: PROCEDURE [h: Press.Handle, end: Press.StrokeEnd] =    BEGIN    OutputInteger[h.data, LOOPHOLE[end, CARDINAL]];    OutputVariableIndex[h.data, strokeEnd];    OutputOperation[h.data, ISet];    END;   SetStrokeWidth: PROCEDURE [h: Press.Handle, width: Mica] =    BEGIN    OutputInteger[h.data, width];    OutputVariableIndex[h.data, strokeWidth];    OutputOperation[h.data, ISet];    END;   StartUnderline: PROCEDURE [h: Press.Handle] =    BEGIN    OutputOperation[h.data, StartUnderline];    END;   MaskUnderline: PROCEDURE [h: Press.Handle, dy: Mica, height: Mica] =    BEGIN    OutputInteger[h.data, dy];    OutputInteger[h.data, height];    OutputOperation[h.data, MaskUnderline];    END;   -- Color  SetGray: PROCEDURE [h: Press.Handle, percentBlack: [0..100]] =    BEGIN    OutputRational[h.data, [percentBlack, 100]];    OutputOperation[h.data, SetGray];    END;    -- Position  SetXY: PROCEDURE [h: Press.Handle, c: Press.Coordinate] = {    OutputInteger[h.data, c.x]; OutputInteger[h.data, c.y]; OutputOperation[h.data, SetXY]};  SetXRel: PROCEDURE [h: Press.Handle, some: Mica] ={    OutputInteger[h.data, some]; OutputOperation[h.data, SetXRel]};  SetYRel: PROCEDURE [h: Press.Handle, some: Mica] = {    OutputInteger[h.data, some]; OutputOperation[h.data, SetYRel]};  -- Justification  SetAmplifySpace: PROCEDURE [h: Press.Handle, amplification: Rational] =    BEGIN    OutputRational[h.data, amplification];    OutputVariableIndex[h.data, amplifySpace];    OutputOperation[h.data, ISet];    END;  SetCorrectMeasure: PROCEDURE [h: Press.Handle, dx, dy: Mica] =    BEGIN    OutputInteger[h.data, dx];    OutputVariableIndex[h.data, correctMX];    OutputOperation[h.data, ISet];    OutputInteger[h.data, dy];    OutputVariableIndex[h.data, correctMY];    OutputOperation[h.data, ISet];    END;  BeginCorrectBody: PROCEDURE [h: Press.Handle] = {    OutputOperation[h.data, Correct]; OutputOperation[h.data, LBrace]};  EndCorrectBody: PROCEDURE [h: Press.Handle] = {OutputOperation[h.data, RBrace]};  -- Transformations  Rotate: PROCEDURE [h: Press.Handle, degrees: INTEGER] =    BEGIN    OutputInteger[h.data, degrees];    OutputOperation[h.data, Rotate];    END;    Scale: PROCEDURE [h: Press.Handle, s: Rational] =    BEGIN    OutputRational[h.data, s];    OutputOperation[h.data, Scale];    END;    Scale2: PROCEDURE [h: Press.Handle, x, y: Rational] =    BEGIN    OutputRational[h.data, x];    OutputRational[h.data, y];    OutputOperation[h.data, Scale2];    END;    Translate: PROCEDURE [h: Press.Handle, x, y: Mica] =    BEGIN    OutputInteger[h.data, x];    OutputInteger[h.data, y];    OutputOperation[h.data, Translate];    END;    Concat: PROCEDURE [h: Press.Handle] = {OutputOperation[h.data, Concat]};    ConcatT: PROCEDURE [h: Press.Handle] = {OutputOperation[h.data, ConcatT]};    -- Saving state  BeginSaveSimpleBody: PROCEDURE [h: Press.Handle] = {    data: DataHandle = h.data;    data.savedFont ¬ data.currentFont;    OutputOperation[data, DoSaveSimpleBody];    OutputOperation[data, LBrace]};  EndSaveSimpleBody: PROCEDURE [h: Press.Handle] = {    data: DataHandle = h.data;    OutputOperation[data, RBrace];    data.currentFont ¬ data.savedFont};  -- Global State  CreatePresser: PUBLIC PROCEDURE [z: UZ] RETURNS [h: Press.Handle] =    BEGIN    h ¬ z.NEW[Press.Interface ¬ [    	data: z.NEW[Object ¬ [zone: z]],        -- Text    	PutBlock: PutBlock,	PutString: PutString,	PutSubString: PutSubString,	CharWidth: CharWidth,        -- Graphics - all of these assume appropriate trajectories are already on the stack	LineTo: LineTo,	LineToX: LineToX,	LineToY: LineToY,	MoveTo: MoveTo,	MakeOutline: MakeOutline,	MaskFill: MaskFill,	MaskStroke: MaskStroke,	MaskRectangle: MaskRectangle,	SetStrokeEnd: SetStrokeEnd,	SetStrokeWidth: SetStrokeWidth,	StartUnderline: StartUnderline,	MaskUnderline: MaskUnderline,        -- Color	SetGray: SetGray,        -- Positioning	SetXY: SetXY,	SetXRel: SetXRel,	SetYRel: SetYRel,        -- Special Text Operations	SetAmplifySpace: SetAmplifySpace,	SetCorrectMeasure: SetCorrectMeasure,	BeginCorrectBody: BeginCorrectBody,	EndCorrectBody: EndCorrectBody,        -- Transformations	Rotate: Rotate,	Scale: Scale,	Scale2: Scale2,	Translate: Translate,	Concat: Concat,	ConcatT: ConcatT,        -- Saving state	BeginSaveSimpleBody: BeginSaveSimpleBody,	EndSaveSimpleBody: EndSaveSimpleBody,        -- Global State	Delete: Delete,    	Start: Start,	Finish: Finish,	Abort: Abort,	NewPlate: NewPlate, 	ClearAliases: ClearAliases,	DefineAlias: DefineAlias,	DescribeAlias: DescribeAlias,	SetFont: SetFont,	SetFontNameSpacePrefix: SetFontNameSpacePrefix,	zone: z,	encoding: Interpress82]];    END;    Delete: PROCEDURE [h: Press.Handle] =    BEGIN    data: DataHandle = h.data;    z: UNCOUNTED ZONE = data.zone;    IF data.active THEN Abort[h];    ClearAliases[h];    IF data.fontNameSpacePrefix # NIL THEN z.FREE[@data.fontNameSpacePrefix];    z.FREE[@h.data];    z.FREE[@h];    RETURN    END;  log: Stream.Handle;    Start: PROCEDURE [h: Press.Handle, output: Stream.Handle, name: LONG STRING ¬ NIL] =    BEGIN    data: DataHandle = h.data;    preface: STRING = "Interpress/Xerox/2.1 "L;    data.output ¬ output;    IF tracing THEN log ¬ MStream.WriteOnly["NPrint.log"L, [], text];    Stream.PutBlock[output, [LOOPHOLE[LONG[@preface.text]], 0, preface.length]];    OutputOperation[data, Begin];    OutputOperation[data, LBrace];    OutputAliasedFonts[data];    OutputOperation[data, RBrace];    data.active ¬ TRUE;    RETURN;    END;  Finish, Abort: PROCEDURE [h: Press.Handle] =    BEGIN    data: DataHandle = h.data;    IF data.active THEN{      IF data.inSheet THEN OutputOperation[data, RBrace];      OutputOperation[data, End];      IF tracing THEN Stream.Delete[log]};    data.active ¬ data.inSheet ¬ FALSE;    data.output ¬ NIL;    RETURN;    END;  NewPlate: PROCEDURE [h: Press.Handle] =    BEGIN    data: DataHandle = h.data;    IF data.inSheet THEN OutputOperation[data, RBrace];    data.currentFont ¬ NIL;    OutputOperation[data, LBrace];    OutputRational[data, tenToMinusFive]; -- client talks in micas    OutputOperation[data, Scale];    OutputOperation[data, ConcatT];    data.inSheet ¬ TRUE;    RETURN;    END;    ClearAliases: PROCEDURE [h: Press.Handle] =    BEGIN    data: DataHandle = h.data;    WHILE data.fontChain # NIL DO      going: AliasedFontHandle ¬ data.fontChain;      data.fontChain ¬ going.next;      MSegment.FreeWords[going.widths];      data.zone.FREE[@going.name];      data.zone.FREE[@going];      ENDLOOP;    data.currentFont ¬ NIL;    data.zone.FREE[@data.fontNameSpacePrefix];    RETURN;    END;      DefineAlias: PROCEDURE [    h: Press.Handle, alias: Press.FontAlias, name: LONG STRING, size: Mica,    w: Press.FontWeight ¬ medium, s: Press.FontSlope ¬ regular] =    BEGIN    data: DataHandle = h.data;    bold: STRING = "-Bold"L;    italic: STRING = "-Italic"L;    extra: CARDINAL ¬ 0;    af: AliasedFontHandle ¬ data.zone.NEW[AliasedFont];    prefix: NamePrefix ¬ xerox;    IF w = bold THEN extra ¬ extra + bold.length;    IF s = italic THEN extra ¬ extra + italic.length;    IF data.fontNameSpacePrefix # NIL THEN prefix ¬ other;    af­ ¬ [next: data.fontChain, alias: alias, size: size,      prefix: prefix, w: w, s: s];    SetString[@af.name, name, data.zone, extra];    IF w = bold THEN String.AppendString[af.name, bold];    IF s = italic THEN String.AppendString[af.name, italic];    data.fontChain ¬ af;    RETURN;    END;        DescribeAlias: PROCEDURE [h: Press.Handle, alias: Press.FontAlias]    RETURNS [fullname: LONG STRING, size: Mica, w: Press.FontWeight,    s: Press.FontSlope, widths: Press.WidthHandle] =    BEGIN    data: DataHandle = h.data;    FOR font: AliasedFontHandle ¬ data.fontChain, font.next UNTIL font = NIL DO      IF alias = font.alias THEN {        IF font.widths = NIL THEN GetWidths[font];	RETURN[font.name, font.size, font.w, font.s, font.widths]};      ENDLOOP;    RETURN[NIL, 0, medium, regular, NIL];    END;      SetFont: PROCEDURE [h: Press.Handle, fontAlias: Press.FontAlias] =    BEGIN    data: DataHandle = h.data;    IF data.currentFont # NIL AND data.currentFont.alias = fontAlias THEN RETURN;    FOR font: AliasedFontHandle ¬ data.fontChain, font.next UNTIL font = NIL DO      IF fontAlias = font.alias THEN {data.currentFont ¬ font; EXIT};      REPEAT FINISHED => RETURN;      ENDLOOP;    OutputInteger[data, fontAlias];    OutputOperation[data, SetFont];    END;      SetFontNameSpacePrefix: PROCEDURE [h: Press.Handle, ls: LONG STRING] =    BEGIN    data: DataHandle = h.data;    SetString[@data.fontNameSpacePrefix, ls, data.zone];    RETURN;    END;  -- Private stuff  GetWidths: PROCEDURE [font: AliasedFontHandle] =    BEGIN    family: STRING ¬ [40];    width: Press.Mica = (font.size*387)/635;  -- Magic;    font.widths ¬ MSegment.GetWords[SIZE[WidthArray]];    font.widths­ ¬ ALL[width];    FOR i: CARDINAL IN [0..font.name.length) DO      String.AppendChar[family, font.name[i]];      ENDLOOP;    SELECT TRUE FROM      String.EquivalentString[family, "Modern"L] => {        GetModernWidths[font.widths, font.size]; RETURN};      String.EquivalentString[family, "Logotypes-Xerox"L] => family ¬ "Logo"L;      ENDCASE;    [] ¬ PressUtilities.FindFontWidths[family, font.size, font.w, font.s, font.widths !      PressUtilities.FontWidthError,      PressUtilities.FontNotFound => CONTINUE];      END;        GetModernWidths: PROCEDURE [widths: LONG POINTER TO WidthArray, size: Mica] =    BEGIN    -- 12 point modern widths    sizeOf12: CARDINAL = (12*635+9)/18;     shortWidths: ARRAY CHARACTER OF CARDINAL = [      462B, 462B, 462B, 462B, 462B, 462B, 462B, 462B, --00x      462B, 462B, 462B, 462B, 462B, 462B, 462B, 462B, --01x      462B, 462B, 462B, 462B, 462B, 462B, 462B, 462B, --02x      462B, 462B, 462B, 462B, 462B, 462B, 462B, 462B, --03x      136B, 245B, 353B, 511B, 353B, 647B, 461B, 166B, --04x      215B, 215B, 353B, 647B, 166B, 215B, 166B, 166B, --05x      353B, 353B, 353B, 353B, 353B, 353B, 353B, 353B, --06x      353B, 353B, 245B, 245B, 647B, 647B, 647B, 323B, --07x      647B, 461B, 402B, 402B, 461B, 353B, 323B, 461B, --10x      461B, 166B, 245B, 432B, 323B, 617B, 461B, 511B, --11x      353B, 511B, 402B, 323B, 353B, 461B, 432B, 647B, --12x      432B, 432B, 353B, 215B, 166B, 215B, 647B, 647B, --13x with ­ and ¬ mods      166B, 353B, 402B, 274B, 402B, 353B, 245B, 402B, --14x      402B, 166B, 166B, 353B, 166B, 570B, 402B, 402B, --15x      402B, 402B, 245B, 245B, 245B, 402B, 323B, 540B, --16x      323B, 323B, 323B, 323B, 136B, 323B, 540B, 462B, --17x      462B, 462B, 462B, 462B, 462B, 462B, 462B, 462B, --20x      462B, 462B, 462B, 462B, 462B, 462B, 462B, 462B, --21x      462B, 462B, 462B, 462B, 462B, 462B, 462B, 462B, --22x      462B, 462B, 462B, 462B, 462B, 462B, 462B, 462B, --23x      462B, 245B, 353B, 353B, 462B, 353B, 462B, 353B, --24x      462B, 462B, 462B, 353B, 462B, 462B, 462B, 462B, --25x      215B, 647B, 462B, 462B, 647B, 462B, 323B, 166B, --26x      647B, 462B, 462B, 353B, 353B, 353B, 353B, 323B, --27x      462B, 323B, 323B, 323B, 323B, 323B, 323B, 323B, --30x      323B, 462B, 323B, 323B, 647B, 323B, 323B, 323B, --31x      462B, 462B, 462B, 462B, 462B, 462B, 462B, 462B, --32x      462B, 462B, 462B, 462B, 462B, 462B, 462B, 462B, --33x      462B, 617B, 462B, 462B, 462B, 462B, 402B, 462B, --34x      462B, 511B, 617B, 462B, 462B, 462B, 462B, 402B, --35x      462B, 570B, 462B, 462B, 462B, 166B, 353B, 462B, --36x      462B, 402B, 617B, 402B, 462B, 462B, 462B, 462B]; --37x    FOR c: CHARACTER IN CHARACTER DO      widths[c] ¬ ((shortWidths[c]*size)+sizeOf12/2)/sizeOf12;      ENDLOOP;    END;        WidthArray: TYPE = ARRAY CHARACTER OF Press.Mica;    NamePrefix: TYPE = {xerox, mesa, other};    AliasedFont: TYPE = RECORD [    widths: LONG POINTER TO WidthArray ¬ NIL,    next: AliasedFontHandle ¬ NIL,    name: LONG STRING ¬ NIL,    alias: Press.FontAlias ¬ 0,    size: Mica,    prefix: NamePrefix,    w: Press.FontWeight,    s: Press.FontSlope];  AliasedFontHandle: TYPE = LONG POINTER TO AliasedFont;    OutputAliasedFonts: PROCEDURE [data: DataHandle] =    BEGIN    FOR font: AliasedFontHandle ¬ data.fontChain, font.next UNTIL font = NIL DO      OutputFontName[data, font];      OutputOperation[data, FindFont];      OutputInteger[data, font.size];      OutputOperation[data, Scale];      OutputOperation[data, ModifyFont];      OutputInteger[data, font.alias];      OutputOperation[data, FSet];      ENDLOOP;    RETURN;    END;        OutputFontName: PROCEDURE [data: DataHandle, font: AliasedFontHandle] =    BEGIN    SELECT font.prefix FROM      xerox, other => {        OutputIdentifier[data, "Xerox"L]; OutputIdentifier[data, "XC82-0-0"L]};      mesa => {        OutputIdentifier[data, "Xerox"L]; OutputIdentifier[data, "Mesa"L]};      ENDCASE;    OutputIdentifier[data, font.name];    OutputInteger[data, 3];    OutputOperation[data, MakeVec];    RETURN;    END;        OutputWord: PROCEDURE[data: DataHandle, w: UNSPECIFIED] = {    Stream.PutByte[data.output, Inline.HighByte[w]]; Stream.PutByte[data.output, Inline.LowByte[w]]};  OutputOperation: PROCEDURE [data: DataHandle, op: Syntax.OperatorEnumeration] = {    IF tracing THEN {LogText["op["L]; LogDec[op]; LogChar[']]; LogChar[15C]};    IF op IN Syntax.SmallOperatorEnumeration THEN {      Stream.PutByte[data.output, Inline.HighByte[Syntax.MasterEncoding[body: shortOp[op: op, pad:]]]]}    ELSE OutputWord[data, Syntax.MasterEncoding[body: longOp[op: op]]]};  OutputBlock: PROCEDURE [data: DataHandle, block: Environment.Block] =    BEGIN    length: CARDINAL = block.stopIndexPlusOne-block.startIndex;    IF length > 255 THEN ERROR;    IF tracing THEN {LogChar['"]; LogBlock[block]; LogText[""" "L]};    OutputWord[data, Syntax.MasterEncoding[body: shortSequence[type: string, length: length]]];    Stream.PutBlock[data.output, block];    RETURN;    END;  OutputIdentifier: PROCEDURE [data: DataHandle, s: LONG STRING] =    BEGIN    IF s.length > 255 THEN ERROR;    IF tracing THEN {LogChar['"]; LogText[s]; LogText[""" "L]};    OutputWord[data, Syntax.MasterEncoding[body: shortSequence[type: identifier, length: s.length]]];    FOR card: CARDINAL IN [0..s.length) DO      Stream.PutChar[data.output, s[card]]; ENDLOOP;    RETURN;    END;  OutputInteger: PROCEDURE [data: DataHandle, s: LONG INTEGER] =    BEGIN    IF tracing THEN {LogLInt[s]; LogChar[' ]};    IF s IN [-4000..28767] THEN      BEGIN      OutputWord[data, Syntax.SHORTINTEGER[s]+4000];      END    ELSE      BEGIN      OutputWord[data, Syntax.MasterEncoding[body: shortSequence[type: integer, length: 4]]];      OutputWord[data, Inline.HighHalf[s]];      OutputWord[data, Inline.LowHalf[s]];      END;    RETURN;    END;    OutputVariableIndex: PROCEDURE [data: DataHandle, v: Syntax.ImagerVariable] = INLINE {    OutputInteger[data, LOOPHOLE[v, CARDINAL]]};  OutputRational: PROCEDURE [data: DataHandle, s: Rational] =    BEGIN    IF s.den = 1 THEN {OutputInteger[data, s.num]; RETURN};    IF tracing THEN {LogLInt[s.num]; LogChar['/]; LogLInt[s.den]; LogChar[' ]};    OutputWord[data, Syntax.MasterEncoding[body: shortSequence[type: rational, length: 8]]];    OutputWord[data, Inline.HighHalf[s.num]];    OutputWord[data, Inline.LowHalf[s.num]];    OutputWord[data, Inline.HighHalf[s.den]];    OutputWord[data, Inline.LowHalf[s.den]];    RETURN;    END;  -- Storage Utilities    SetString: PROCEDURE [p: LONG POINTER TO LONG STRING, s: LONG STRING, z: UZ, extra: CARDINAL ¬ 0] =    BEGIN    IF p­ # NIL THEN z.FREE[p];    IF s # NIL THEN {p­ ¬ z.NEW[StringBody[s.length+extra]]; String.AppendString[p­, s]};    RETURN    END;    -- Logging    LogText: PROCEDURE [s: LONG STRING] = {    IF ~tracing THEN RETURN;    Stream.PutBlock[log, [LOOPHOLE[@s.text], 0, s.length]]};      LogLInt: PROCEDURE [li: LONG INTEGER] = {    s: STRING = [20];    IF ~tracing THEN RETURN;    String.AppendLongDecimal[s, li];    LogText[s]};      LogDec: PROCEDURE [u: UNSPECIFIED] = {    s: STRING = [10];    IF ~tracing THEN RETURN;    String.AppendDecimal[s, u];    LogText[s]};      LogBlock: PROCEDURE [b: Environment.Block] = {    IF ~tracing THEN RETURN;    Stream.PutBlock[log, b]};      LogChar: PROCEDURE [c: CHARACTER] = {    IF ~tracing THEN RETURN;    Stream.PutChar[log, c]};      END...
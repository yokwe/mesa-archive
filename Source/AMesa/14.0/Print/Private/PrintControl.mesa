-- File: PrintControl.mesa - last edit:-- Nannette.PA         22-Apr-85 14:29:26-- Copyright (C) 1981, 1983, 1984 , 1985 by Xerox Corporation. All rights reserved. -- PrintControl.mesa; edited by-- LXR    	 3-Sep-81 14:39:53-- RXR   	11-Sep-81 15:27:30-- RXJ     	 6-Sep-83 15:12:31-- AXD    	24-Jan-84 18:44:10-- NSG          6-Jul-84 17:18:52DIRECTORY  Ascii USING [CR, NUL],  Environment USING [Block, bytesPerPage, charsPerWord],  Exec USING [    AddCommand, CheckForAbort, ExecProc, FreeTokenString, GetNameandPassword,    GetToken, Handle, OutputProc, PutChar],  FileName USING [AllocVFN, Error, FreeVFN, VirtualFilename],  FileTransfer,  Format USING [StringProc],  Heap USING [Create, Delete, systemZone],  Inline USING [LongMult],  Interpress82Maker USING [CreatePresser, CreatePrinter],  MFile USING [    Acquire, Error, GetCreateDate, Handle, Release, SetAccess],  MStream USING [Create, Error, GetLength, ReadWrite, SetLength, WriteOnly],    PressUtilities USING [NoFontsDotWidths],  Press,  PressPrint USING [Handle],  PressStream,  PressStreamExtras USING [ParametersExtras, ParametersExtrasHandle, SetParametersExtras],  PrintOps USING [SetupHardCopyOptions],  Process USING [Yield],  Runtime USING [IsBound],  Selection USING [Convert, Source],  Stream USING [    CompletionCode, Delete, GetBlock, GetPosition, Handle, PutBlock,    PutChar, SetPosition],  String USING [    AppendChar, AppendDecimal, AppendString, CopyToNewString, Empty,    EqualString, EquivalentStrings],  Time USING [Append, AppendCurrent, Current, Packed, Unpack];PrintControl: MONITOR  IMPORTS    Exec, FileName, FileTransfer, Heap, Inline, Interpress82Maker, MFile, MStream,    PressUtilities, PressStream, PressStreamExtras,    PrintOps, Process, Runtime, Selection, Stream, String, Time =  BEGIN    Mica: TYPE = Press.Mica;    z: UNCOUNTED ZONE;  execH: Exec.Handle ¬ NIL;    PutString: Format.StringProc ¬ NIL;    printerName: LONG STRING ¬ NIL;    myPress: Press.Handle ¬ NIL;  myPrint: PressPrint.Handle ¬ NIL;    NUL: CHARACTER = Ascii.NUL;  Inch: Mica = Press.micasPerInch;  charsPerWord: CARDINAL = Environment.charsPerWord;  bytesPerPage: CARDINAL = Environment.bytesPerPage;  pagesPerChunk: CARDINAL = 200; -- number of pages to trigger printing    debugging: BOOLEAN ¬ FALSE;    mapping: BOOLEAN ¬ TRUE;  pressStream: Stream.Handle ¬ NIL;  pressFileName: LONG STRING ¬ NIL;    transmitting: BOOLEAN;  copies: CARDINAL;  sides: CARDINAL;    bufferStream: Stream.Handle;  outputStream: Stream.Handle;    normalFont: CARDINAL = 0;    Abort: SIGNAL = CODE;  NoteError: SIGNAL [message: STRING] = CODE;    fontChanged, fontSpecified: BOOLEAN;    Defaults: TYPE = RECORD [    font: LONG STRING, columns: CARDINAL, margins: PressStream.Margins];    lDefault: Defaults ¬ [NIL, 2,    [top: Inch*3/4, bottom: Inch/2, left: Inch/2, right: Inch/2]];  pDefault: Defaults ¬ [NIL, 1, ALL[Inch*3/4]];      bufferFile, outputFile: LONG STRING ¬ NIL;  haveStatus: BOOLEAN;    cParameters, dParameters: PressStream.Parameters;  ccParameters: PressStreamExtras.ParametersExtras;    userName, font: LONG STRING;    fontWeight: Press.FontWeight ¬ medium;  fontSlope: Press.FontSlope ¬ regular;    busy: BOOLEAN ¬ FALSE;    PutDecimal: PROCEDURE [d: CARDINAL] = {    s: STRING = [10];    String.AppendDecimal[s, d];    PutString[s]};  PutLine: PROCEDURE [s: LONG STRING] = {PutString[s]; Exec.PutChar[execH, Ascii.CR]};  PutChar: PROCEDURE [c: CHARACTER] = {Exec.PutChar[execH, c]};  PutCR: PROCEDURE = {Exec.PutChar[execH, Ascii.CR]};    SetDebugging: PROCEDURE [d: BOOLEAN] =    BEGIN    debugging ¬ d;    PutString["Debugging "L];    PutLine[IF debugging THEN "on"L ELSE "off"L];    RETURN    END;      SetDefaultFont: PROCEDURE [f: LONG STRING, p: PressStream.ParametersHandle] =    BEGIN    IF font # NIL AND String.EquivalentStrings[f, font] THEN RETURN;    font ¬ String.CopyToNewString[f, z];    fontChanged ¬ TRUE;    RETURN    END;      SetHost: PROCEDURE [h: LONG STRING, p: PressStream.ParametersHandle] =    BEGIN    outputFile ¬ NIL;    transmitting ¬ TRUE;    IF printerName # NIL AND ~String.EquivalentStrings[h, printerName] THEN      FinishFile[];    printerName ¬ String.CopyToNewString[h, z];    haveStatus ¬ FALSE;    RETURN    END;      SetOutputFile: PROCEDURE [f: LONG STRING, p: PressStream.ParametersHandle] =    BEGIN OPEN String;    FinishFile[];    printerName ¬ NIL;    AppendChar[f, '.];    AppendString[f, "interpress"L];            outputFile ¬ String.CopyToNewString[f, z];    transmitting ¬ FALSE;    PutString["Output to "L];    PutLine[f];    RETURN    END;      SetLandscape: PROCEDURE [c: CARDINAL, p: PressStream.ParametersHandle] =    BEGIN    p.mode ¬ landscape;    IF ~fontSpecified THEN SetDefaultFont[lDefault.font, p];    p.columns ¬ c;    p.margins ¬ lDefault.margins;    RETURN    END;      SetPortrait: PROCEDURE [c: CARDINAL, p: PressStream.ParametersHandle] =    BEGIN    p.mode ¬ portrait;    IF ~fontSpecified THEN SetDefaultFont[pDefault.font, p];    p.columns ¬ c;    p.margins ¬ pDefault.margins;    END;      SetTabWidth: PROCEDURE [c: CARDINAL, p: PressStream.ParametersHandle] =    BEGIN p.tab ¬ c; END;      SetCopies: PROCEDURE [c: CARDINAL, p: PressStream.ParametersHandle] =    BEGIN copies ¬ c; END;      SetSides: PROCEDURE [s: CARDINAL, p: PressStream.ParametersHandle] =    BEGIN sides ¬ s; END;      AbortFile: PROCEDURE [s: STRING] =    BEGIN    PutLine[s];    pressStream.Delete[];    pressStream ¬ NIL;    END;    CheckStatus: PROCEDURE =    BEGIN    avail: BOOLEAN;    msg: LONG STRING;    IF haveStatus THEN RETURN;    IF printerName = NIL OR printerName.length = 0 THEN {      PutLine["No printer host specified"L]; ERROR Abort};    [avail, msg] ¬ myPrint.GetStatus[printerName ! myPrint.Trouble => {      IF ~String.Empty[message] THEN PutString[message];      ERROR Abort}];    IF ~String.Empty[msg] THEN PutString[msg];    Heap.systemZone.FREE[@msg];    haveStatus ¬ TRUE;    IF ~avail THEN ERROR Abort;    END;    PutPressType: PROCEDURE [type: Press.Encoding] =    BEGIN    PutString["Interpress"L];    END;    PutAlready: PROCEDURE [type: Press.Encoding] =    BEGIN    PutString[" already in "L]; PutPressType[type]; PutString[" format... "L];    END;    SendPressFile: PROCEDURE [    fileName: LONG STRING, vfn: FileName.VirtualFilename]    RETURNS [isPressFile: BOOLEAN ¬ FALSE] =    BEGIN    IF String.Empty[vfn.host] THEN {      fh: MFile.Handle = MFile.Acquire[fileName, anchor, []];      isPressFile ¬ myPrint.IsPressFile[fh];      IF isPressFile THEN {        PutString[fileName];        PutAlready[myPress.encoding];        IF transmitting THEN {	  s: Stream.Handle;	  MFile.SetAccess[fh, readOnly];	  s ¬ MStream.Create[fh, []];	  SendStream[s, MStream.GetLength[s], fileName, MFile.GetCreateDate[fh] !	    UNWIND => Stream.Delete[s]];	  Stream.Delete[s]}        ELSE PutString["skipped"L];        RETURN}      ELSE MFile.Release[fh]};    END;    PressThisFile: PROCEDURE [fileName: LONG STRING] =    BEGIN    conn: FileTransfer.Connection ¬ NIL;    SetCredentials: PROCEDURE [name, password: LONG STRING] = {      FileTransfer.SetPrimaryCredentials[conn, name, password]};    isPressFile: BOOLEAN ¬ FALSE;    vfn: FileName.VirtualFilename ¬ NIL;    IF transmitting THEN CheckStatus[];    IF String.EqualString[fileName, "$$$"L] THEN {PressCurrentSelection[]; RETURN};    conn ¬ FileTransfer.Create[];    FileTransfer.SetProcs[conn, NIL, Messages];      BEGIN ENABLE {        UNWIND => {FileName.FreeVFN[vfn]; FileTransfer.Destroy[conn]};	FileName.Error => {	  PutString[fileName]; PutLine[" is an invalid file name."L];	  ERROR Abort};        MFile.Error, FileTransfer.Error => {	  PutString["Can't read "L]; PutLine[fileName]; CONTINUE}};      vfn ¬ FileName.AllocVFN[fileName];      IF ~SendPressFile[fileName, vfn] THEN        BEGIN        IF fontChanged THEN InstallFont[font];          BEGIN ENABLE FileTransfer.Error => SELECT code FROM            retry => RETRY;            skipOperation => CONTINUE;            notFound => REJECT; -- caught above	    illegalLogin => {	      name: STRING = [50];	      password: STRING = [40];	      Exec.GetNameandPassword[execH, name, password];	      FileTransfer.SetPrimaryCredentials[conn, name, password];	      RETRY};	    ENDCASE;          PrintStreams[	    FileTransfer.ReadStream[conn, vfn], String.Empty[vfn.host]];	  END;        END;      END;    FileName.FreeVFN[vfn];    FileTransfer.Destroy[conn];    END;      PrintStreams: PROCEDURE [stream: Stream.Handle, localFile: BOOLEAN] =    BEGIN    header: STRING = [150];    pages: CARDINAL;    fileInfo: FileTransfer.FileInfo;    UNTIL stream = NIL DO      IF pressStream # NIL AND outputFile = NIL AND        (outputStream.GetPosition[]/bytesPerPage > pagesPerChunk) THEN FinishFile[];      fileInfo ¬ FileTransfer.GetStreamInfo[stream];      PutPressType[myPress.encoding]; PutString["ing "L];      IF fileInfo.directory # NIL THEN {        PutChar['<]; PutString[fileInfo.directory]; PutChar['>]};      PutString[fileInfo.body];      BEGIN -- check for non text files      IF fileInfo.type # text AND ~debugging THEN {        NoteError["only text files may be printed; file skipped"L];	GOTO skip};      ShowParameters[];      header.length ¬ 0;      String.AppendString[header, fileInfo.body];      String.AppendString[header, "        "L];      Time.Append[header, Time.Unpack[fileInfo.create], TRUE];      cParameters.headerString ¬ header;      IF pressStream = NIL THEN StartFile[fileInfo.body]      ELSE pressStream.PutChar[13C]; -- start on new sheet      PressStream.SetParameters[pressStream, @cParameters];      PressStreamExtras.SetParametersExtras[pressStream, @ccParameters]; -- fix this      PressStream.SetPageNumber[pressStream, 1];      PutString["... "L];      CopyStream[from: stream, to: pressStream];      pages ¬ PressStream.GetPageNumber[pressStream];      IF sides = 2 AND (pages MOD 2) = 1 THEN myPress.NewPlate[myPress];      cParameters.headerString ¬ NIL;      PutDecimal[pages];      PutString[" page"L];      IF pages # 1 THEN PutChar['s];      PutCR[];      EXITS skip => NULL;      END; -- check for non text files      IF localFile THEN {stream.Delete[]; EXIT}      ELSE stream ¬ FileTransfer.ReadNextStream[stream];      ENDLOOP;    RETURN    END;      CopyStream: PROCEDURE [from, to: Stream.Handle] =    BEGIN    bufferBytes: CARDINAL = 512;    buffer: PACKED ARRAY [0..bufferBytes] OF CHARACTER;    block: Environment.Block ¬ [LOOPHOLE[LONG[@buffer]], 0, ];    why: Stream.CompletionCode;    DO      block.stopIndexPlusOne ¬ bufferBytes;      [why: why, bytesTransferred: block.stopIndexPlusOne] ¬ from.GetBlock[block];      to.PutBlock[block, why = endOfStream];      IF why = endOfStream THEN EXIT;      IF Exec.CheckForAbort[execH] THEN ERROR Abort;      ENDLOOP;    END;      Messages: FileTransfer.MessageProc =    BEGIN    IF level <= warning AND ~debugging THEN RETURN;    IF s1 # NIL THEN PutString[s1];    IF s2 # NIL THEN PutString[s2];    IF s3 # NIL THEN PutString[s3];    IF s4 # NIL THEN PutString[s4];    END;    StartFile: PROCEDURE [name: LONG STRING] =    BEGIN    ENABLE MStream.Error => {      PutString[" Can't write on "L];      PutLine[IF outputFile = NIL THEN bufferFile ELSE outputFile];      ERROR Abort};    IF outputFile = NIL THEN {      IF bufferStream = NIL THEN	bufferStream ¬ MStream.ReadWrite[bufferFile, [], binary];      outputStream ¬ bufferStream}    ELSE outputStream ¬ IF transmitting THEN MStream.ReadWrite[outputFile, [], binary]      ELSE MStream.WriteOnly[outputFile, [], binary];    pressStream ¬ PressStream.Create[myPress, outputStream, name];    pressFileName ¬ String.CopyToNewString[name, z];    END;      FinishFile: PROCEDURE =    BEGIN    index: LONG CARDINAL;    IF pressStream = NIL THEN RETURN;    pressStream.Delete[]; pressStream ¬ NIL;    index ¬ Stream.GetPosition[outputStream];    MStream.SetLength[outputStream, index];    IF transmitting THEN {      Stream.SetPosition[outputStream, 0];      SendStream[outputStream, index, pressFileName, Time.Current[]]};    IF outputFile # NIL THEN {      Stream.Delete[outputStream]; outputStream ¬ NIL};    IF bufferStream # NIL THEN Stream.SetPosition[bufferStream, 0];    END;    SendStream: PROCEDURE [s: Stream.Handle, bytes: LONG CARDINAL,    fileName: LONG STRING, createTime: Time.Packed] =    BEGIN    aborted: BOOLEAN ¬ FALSE;    IF Exec.CheckForAbort[execH] THEN SIGNAL Abort;    PutString["sending to "L];    PutString[printerName];    PutString["... "L];    myPrint.SendPressStream[s, bytes, printerName, copies,      sides, fileName, userName, createTime !        myPrint.Trouble => SELECT code FROM	  busy => {	    Wait[IF ~String.Empty[message] THEN message ELSE "busy"L, 8]; RESUME};	  timeout => {Wait["not responding"L, 4]; RESUME};	  badFile => {            IF message # NIL THEN PutString[message]	    ELSE PutString["bad file format"L];	    PutString["..."L];            aborted ¬ TRUE;            CONTINUE};	  other => {            IF ~String.Empty[message] THEN {	      PutString[message]; PutString["..."L]};            aborted ¬ TRUE;            CONTINUE};	  ENDCASE];    PutLine[IF aborted THEN " Aborted"L ELSE " Done"L];    END;	  PressCurrentSelection: PROC =    BEGIN    source: Selection.Source;    IF pressStream # NIL AND outputFile = NIL AND (Stream.GetPosition[      outputStream] / bytesPerPage) > pagesPerChunk THEN FinishFile[];    IF (source ¬ Selection.Convert[source]) = NIL THEN {      PutString["No valid selection"L]; RETURN};    PutPressType[myPress.encoding]; PutString["ing current selection"L];    ShowParameters[];    PutString["... "L];      BEGIN      pages: CARDINAL;      header: STRING = [24];      Time.AppendCurrent[header];      IF fontChanged THEN InstallFont[font];      IF pressStream = NIL THEN StartFile["CurrentSelection"L];      cParameters.headerString ¬ header;      PressStream.SetParameters[pressStream, @cParameters];      PutDecimal[pages¬PrintSelection[source]];      IF sides = 2 AND (pages MOD 2) = 1 THEN myPress.NewPlate[myPress];      cParameters.headerString ¬ NIL;      PutString[" page"L];      IF pages # 1 THEN PutChar['s];      END;    PutCR[];    RETURN    END;      PrintSelection: PROCEDURE [source: Selection.Source] RETURNS [lastPage: CARDINAL] =    BEGIN    s: STRING ¬ [100];    DO ENABLE UNWIND => source.destroy[source];      IF Exec.CheckForAbort[execH] THEN ERROR Abort;      s.length ¬ 0;      source.proc[source.data, s];      IF s.length = 0 THEN {source.destroy[source]; EXIT};      pressStream.PutBlock[[LOOPHOLE[LONG[@s.text]], 0, s.length]];      ENDLOOP;      lastPage ¬ PressStream.GetPageNumber[pressStream];    RETURN    END;      CheckForExtension: PROCEDURE [name, ext: LONG STRING] =    BEGIN    FOR i: CARDINAL DECREASING IN [0..name.length) DO      IF name[i] = '. THEN RETURN;      ENDLOOP;    String.AppendString[name, ext];    END;    PointsToMicas: PROCEDURE [p: CARDINAL] RETURNS [Mica] = INLINE {    RETURN[(Inline.LongMult[p, 635]+9)/18]};      InstallFont: PROCEDURE [f: LONG STRING, mail: BOOLEAN ¬ FALSE] =    BEGIN    name: STRING ¬ [40];    b: BufferItem ¬ [0, f];    c: CHARACTER;    points: CARDINAL;    FinishFile[];    DO      c ¬ GetChar[@b];      IF c = NUL THEN EXIT;      IF c IN ['0..'9] THEN BEGIN Backup[@b]; EXIT END;      String.AppendChar[name, c];      ENDLOOP;    points ¬ GetNumber[@b, IF cParameters.mode = landscape THEN 6 ELSE 8];    fontWeight ¬ medium;    fontSlope ¬ regular;    UNTIL (c ¬ GetChar[@b]) = NUL DO      IF c = 'b THEN fontWeight ¬ bold      ELSE IF c = 'i THEN fontSlope ¬ italic;      ENDLOOP;    myPress.ClearAliases[myPress];    myPress.DefineAlias[myPress, normalFont, name, PointsToMicas[points], fontWeight, fontSlope];    fontChanged ¬ FALSE;    RETURN    END;      Wait: PROCEDURE [why: LONG STRING, howlong: CARDINAL] =    BEGIN    start: Time.Packed;    PutString["Server "L];    PutString[why];    PutString["... will retry"L];    start ¬ Time.Current[];    UNTIL Time.Current[] - start > howlong DO      IF Exec.CheckForAbort[execH] THEN SIGNAL Abort;      Process.Yield[];      ENDLOOP;    PutString["... "L];    END;      ShowParameters: PROCEDURE =    BEGIN    PutChar['/];    PutChar[IF cParameters.mode = landscape THEN 'l ELSE 'p];    PutDecimal[cParameters.columns];    IF ~cParameters.headers THEN PutString["~a"L];    IF ~cParameters.trailers THEN PutString["~z"L];    IF sides # 0 THEN {PutChar['s]; PutDecimal[sides]};    END;  InitGlobalParameters: PROCEDURE =    BEGIN    nsName: LONG STRING ¬ NIL;    [userName: userName,      interpressPrinter: nsName, pFont: pDefault.font, lFont: lDefault.font,      parameters: dParameters] ¬ PrintOps.SetupHardCopyOptions[z];        printerName ¬ nsName;    font ¬ IF dParameters.mode = landscape THEN lDefault.font ELSE pDefault.font;    fontSpecified ¬ FALSE;    fontChanged ¬ TRUE;    copies ¬ 1;    ccParameters.mapping ¬ FALSE;    sides ¬ 0;    bufferFile ¬ String.CopyToNewString["Print.scratch$"L, z];    outputFile ¬ NIL;    END;      SetGlobalParameters: PROCEDURE [b: Buffer] =    BEGIN    d: PressStream.ParametersHandle = @dParameters;        sense: BOOLEAN ¬ TRUE;    sc: CHARACTER;    UNTIL (sc ¬ GetChar[b]) = NUL DO      SELECT sc FROM	'c => SetCopies[GetNumber[b, 1], d];	't => SetTabWidth[GetNumber[b, 8], d];	'l => SetLandscape[GetNumber[b, 2], d];		'p => SetPortrait[GetNumber[b, 1], d];	's => SetSides[GetNumber[b, 0], d];	'd => SetDebugging[~debugging];	'a => d.headers ¬ sense;	'z => d.trailers ¬ sense;	'-, '~ => {sense ¬ FALSE; LOOP};	ENDCASE;      sense ¬ TRUE;      ENDLOOP;    cParameters ¬ dParameters;    END;      InitCurrentParameters: PROCEDURE =    BEGIN cParameters ¬ dParameters; END;      BufferItem: TYPE = RECORD [p: CARDINAL, s: LONG STRING];    Buffer: TYPE = POINTER TO BufferItem;    GetChar: PROCEDURE [b: Buffer] RETURNS [c: CHARACTER] =    BEGIN OPEN b;    c ¬ Ascii.NUL;    IF s # NIL AND p < s.length THEN      BEGIN      c ¬ s[p];      p ¬ p + 1;      IF c IN ['A..'Z] THEN c ¬ LOOPHOLE[LOOPHOLE[c, CARDINAL] + 40B];      END;    RETURN    END;      Backup: PROCEDURE [b: Buffer] = BEGIN IF b.p # 0 THEN b.p ¬ b.p - 1; END;      GetNumber: PROCEDURE [b: Buffer, default: CARDINAL] RETURNS [v: CARDINAL] =    BEGIN    c: CHARACTER;    usedefault: BOOLEAN ¬ TRUE;    v ¬ 0;    WHILE (c ¬ GetChar[b]) IN ['0..'9] DO      usedefault ¬ FALSE; v ¬ v*10 + (c - 60C); ENDLOOP;    IF c # NUL THEN Backup[b];    IF usedefault THEN RETURN[default];    END;      ProcessItem: PROCEDURE [arg, switches: LONG STRING] =    BEGIN    b: BufferItem ¬ [0, switches];    c: PressStream.ParametersHandle = @cParameters;    cc: PressStreamExtras.ParametersExtrasHandle = @ccParameters;                             sc: CHARACTER;    sense: BOOLEAN ¬ TRUE;    mail: BOOLEAN ¬ FALSE;    IF Exec.CheckForAbort[execH] THEN SIGNAL Abort;    IF arg = NIL THEN {SetGlobalParameters[@b]; RETURN};    UNTIL arg.length = 0 OR (sc ¬ GetChar[@b]) = NUL DO      SELECT sc FROM	'f => {SetDefaultFont[arg, c]; fontSpecified ¬ TRUE; arg.length ¬ 0};	'g => cc.granny ¬ TRUE;	'h => {SetHost[arg, c]; arg.length ¬ 0};	'o => {SetOutputFile[arg, c]; arg.length ¬ 0};	'c => {SetCopies[GetNumber[@b, 1], c]; SetCopies[copies, @dParameters]};	't => SetTabWidth[GetNumber[@b, 8], c];	'l => SetLandscape[GetNumber[@b, 2], c];	'm => cc.mapping ¬ TRUE;           -- from PressStreamExtras	'p => SetPortrait[GetNumber[@b, 1], c];	's => SetSides[GetNumber[@b, 0], c];	'd => SetDebugging[~debugging];	'a => c.headers ¬ sense;	'z => c.trailers ¬ sense;	'-, '~ => {sense ¬ FALSE; LOOP};	ENDCASE =>	  BEGIN	  PutString["Unknown switch = "L];	  PutChar[sc];	  PutCR[];	  END;      sense ¬ TRUE;      ENDLOOP;    IF arg.length = 0 THEN SetGlobalParameters[@b]    ELSE BEGIN PressThisFile[arg]; InitCurrentParameters[]; END;    RETURN    END;    SetBusy: ENTRY PROCEDURE RETURNS [BOOLEAN] = {    IF busy THEN RETURN[FALSE]    ELSE RETURN[busy ¬ TRUE]};    ClearBusy: ENTRY PROCEDURE = {busy ¬ FALSE};      Command: Exec.ExecProc =    BEGIN    arg: LONG STRING ¬ NIL;    switches: LONG STRING ¬ NIL;    b: BufferItem ¬ [0, switches];    Cleanup: PROCEDURE = {      myPress.Delete[myPress]; myPress ¬ NIL;      myPrint.Delete[myPrint]; myPrint ¬ NIL;      IF bufferStream # NIL THEN Stream.Delete[bufferStream];      IF outputStream # NIL AND outputStream # bufferStream THEN        Stream.Delete[outputStream];      outputStream ¬ bufferStream ¬ NIL;      font ¬ bufferFile ¬ outputFile ¬ pressFileName ¬ NIL;      execH ¬ NIL;      PutString ¬ NIL;      arg ¬ Exec.FreeTokenString[arg];      switches ¬ Exec.FreeTokenString[switches];      Heap.Delete[z]; z ¬ NIL;      ClearBusy[]};    IF ~SetBusy[] THEN {      outcome ¬ abort; Exec.OutputProc[h]["Command already running"L]; RETURN};    execH ¬ h;    PutString ¬ Exec.OutputProc[h];    haveStatus ¬ FALSE;    transmitting ¬ TRUE;    pressStream ¬ NIL;    pressFileName ¬ NIL;    bufferStream ¬ NIL;    outputStream ¬ NIL;    z ¬ Heap.Create[initial: 8];    IF Runtime.IsBound[LOOPHOLE[Interpress82Maker.CreatePrinter]] THEN {      myPress ¬ Interpress82Maker.CreatePresser[z];      myPrint ¬ Interpress82Maker.CreatePrinter[]};        BEGIN ENABLE UNWIND => Cleanup[];      InitGlobalParameters[];      SetGlobalParameters[@b];      InitCurrentParameters[];      DO        [arg, switches] ¬ Exec.GetToken[h];        IF (arg = NIL OR arg.length = 0) AND switches = NIL THEN EXIT;        ProcessItem[arg, switches !	  Abort => {outcome ¬ abort; EXIT};	  NoteError => {	    PutString[message]; outcome ¬ error; RESUME};	  PressUtilities.NoFontsDotWidths => {	    IF outcome = normal THEN {	      PutString["**No ""Fonts.widths"" file**"L]; outcome ¬ warning};	    RESUME}];        arg ¬ Exec.FreeTokenString[arg];        switches ¬ Exec.FreeTokenString[switches];        ENDLOOP;      IF outcome # abort THEN FinishFile[! Abort => {outcome ¬ abort; CONTINUE}];      END;    Cleanup[];    RETURN    END;      Init: PROCEDURE = {    IF Runtime.IsBound[LOOPHOLE[Interpress82Maker.CreatePrinter]] THEN      Exec.AddCommand["Print.~"L, Command]        };      -- Main body    Init[];    END...
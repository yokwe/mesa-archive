-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved. -- PressNSPrintImpl.mesa,  Edit:-- RXJ     	26-May-83  8:38:17-- NSG   	 4-Oct-84 13:57:56DIRECTORY  AddressTranslation USING [    Error, PrintError, StringToNetworkAddress],  Courier USING [ErrorCode],  Heap USING [systemZone],  Interpress82Maker USING [],  MFile USING [CopyFileHandle, Handle],  MSegment USING [Address, Create, Delete, Handle],  MStream USING [Copy],  NSDataStream USING [Aborted, SinkStream],  PressPrint USING [Handle, Object, TroubleCode],  Stream USING [Delete, Handle, SetPosition],  String USING [    AppendChar, AppendCharAndGrow, AppendString, AppendStringAndGrow,    CopyToNewString, StringBoundsFault],  System USING [GreenwichMeanTime],  NSPrint USING [    Error, ErrorRecord, FreePrinterStatus, GetPrinterStatus, Print, PrintAttribute, PrinterStatus, PrintOption, String, SystemElement];PressNSPrintImpl: PROGRAM  IMPORTS    AddressTranslation, Heap, MFile, MSegment, MStream, NSDataStream,    NSPrint, Stream, String  EXPORTS Interpress82Maker =  BEGIN    object: PressPrint.Object ¬ [    Trouble: Trouble,    GetStatus: GetStatus,    IsPressFile: IsPressFile,    SendPressStream: SendPressStream,    Delete: Delete];    CreatePrinter: PUBLIC PROCEDURE RETURNS [h: PressPrint.Handle] =    BEGIN    RETURN[@object];    END;    Delete: PROCEDURE [PressPrint.Handle] = {};    Trouble: SIGNAL [code: PressPrint.TroubleCode, message: LONG STRING ¬ NIL] = CODE;    IsPressFile: PROCEDURE [fh: MFile.Handle] RETURNS [isPressFile: BOOLEAN] =    BEGIN    header: STRING = "Interpress/Xerox"L;    seg: MSegment.Handle;    p: LONG POINTER TO PACKED ARRAY OF CHARACTER;    seg ¬ MSegment.Create[MFile.CopyFileHandle[fh, [], readOnly], [], 0, 1];    p ¬ MSegment.Address[seg];    FOR i: CARDINAL IN [0..header.length) DO      IF header[i] # p[i] THEN {isPressFile ¬ FALSE; EXIT};      REPEAT FINISHED => isPressFile ¬ TRUE;      ENDLOOP;    MSegment.Delete[seg];    RETURN    END;      MakeNSString: PROCEDURE [s: LONG STRING] RETURNS [NSPrint.String] = {    RETURN[IF s = NIL THEN [NIL, 0, 0]    ELSE [LOOPHOLE[@s.text], s.length, s.maxlength]]};    SendPressStream: PROCEDURE [    stream: Stream.Handle, bytes: LONG CARDINAL, host: LONG STRING,    copies: CARDINAL ¬ 1, sides: [0..2] ¬ 0,    fileName: LONG STRING ¬ NIL, userName: LONG STRING ¬ NIL,    date: System.GreenwichMeanTime] =    BEGIN    SendStream: PROCEDURE [sink: NSDataStream.SinkStream] = {      [] ¬ MStream.Copy[from: stream, to: sink, bytes: LAST[LONG CARDINAL] !        NSDataStream.Aborted => CONTINUE;	UNWIND => Stream.Delete[sink ! NSDataStream.Aborted => CONTINUE]];      Stream.Delete[sink ! NSDataStream.Aborted => CONTINUE]};    hostAddr: NSPrint.SystemElement = GetAddress[host];     attributes: ARRAY [0..3) OF NSPrint.PrintAttribute ¬ [      [printObjectName[MakeNSString[fileName]]],      [printObjectCreateDate[date]],      [senderName[MakeNSString[userName]]]];    options: ARRAY [0..4) OF NSPrint.PrintOption ¬ [      [printObjectSize[bytes]],      [recipientName[MakeNSString[userName]]],      [copyCount[copies]],      [twoSided[sides = 2]]];    [] ¬ NSPrint.Print[      [proc[SendStream]], DESCRIPTOR[attributes], DESCRIPTOR[options], hostAddr !        NSPrint.Error => SELECT why.errorType FROM          busy, tooManyClients => {SIGNAL Trouble[busy];	                           Stream.SetPosition[stream,0];				   RETRY};          spoolingDisabled => {SIGNAL Trouble[busy, "spooling disabled"L];	                              Stream.SetPosition[stream,0];	                              RETRY};	  ENDCASE => ReportNSPrintError[why]];    END;    ReportNSPrintError: PROCEDURE [e: NSPrint.ErrorRecord] =    BEGIN    z: UNCOUNTED ZONE = Heap.systemZone;    s: LONG STRING ¬ z.NEW[StringBody[100]];    AppendNSPrintError[@s, e, z];    ERROR Trouble[other, s ! UNWIND => z.FREE[@s]];    END;  AppendNSPrintError: PROCEDURE [s: LONG POINTER TO LONG STRING, e: NSPrint.ErrorRecord, z: UNCOUNTED ZONE] =    BEGIN    String.AppendStringAndGrow[s, "NSPrint.Error["L, z];    WITH e SELECT FROM      busy => String.AppendStringAndGrow[s, "busy"L, z];      insufficientSpoolSpace => String.AppendStringAndGrow[s, "insufficientSpoolSpace"L, z];      invalidPrintParameters => String.AppendStringAndGrow[s, "invalidPrintParameters"L, z];      masterTooLarge => String.AppendStringAndGrow[s, "masterTooLarge"L, z];      mediumUnavailable => String.AppendStringAndGrow[s, "mediumUnavailable"L, z];      serviceUnavailable => String.AppendStringAndGrow[s, "serviceUnavailable"L, z];      spoolingDisabled => String.AppendStringAndGrow[s, "spoolingDisabled"L, z];      spoolingQueueFull => String.AppendStringAndGrow[s, "spoolingQueueFull"L, z];      systemError => String.AppendStringAndGrow[s, "systemError"L, z];      tooManyClients => String.AppendStringAndGrow[s, "tooManyClients"L, z];      undefinedError => String.AppendStringAndGrow[s, "undefinedError"L, z];      transferError => String.AppendStringAndGrow[s, "transferError"L, z];      connectionError => String.AppendStringAndGrow[s, "connectionError"L, z];      courier => AppendCourierError[s, courier, z];      ENDCASE;    String.AppendCharAndGrow[s, '], z];    END;    AppendCourierError: PROCEDURE [s: LONG POINTER TO LONG STRING, e: Courier.ErrorCode, z: UNCOUNTED ZONE] =    BEGIN    eString: STRING = SELECT e FROM      transmissionMediumHardwareProblem => "transmissionMediumHardwareProblem"L,      transmissionMediumUnavailable => "transmissionMediumUnavailable"L,      transmissionMediumNotReady => "transmissionMediumNotReady"L,      noAnswerOrBusy => "noAnswerOrBusy"L,      noRouteToSystemElement => "noRouteToSystemElement"L,      transportTimeout => "transportTimeout"L,      remoteSystemElementNotResponding => "remoteSystemElementNotResponding"L,      noCourierAtRemoteSite => "noCourierAtRemoteSite"L,      tooManyConnections => "tooManyConnections"L,      invalidMessage => "invalidMessage"L,      noSuchProcedureNumber => "noSuchProcedureNumber"L,      returnTimedOut => "returnTimedOut"L,      callerAborted => "callerAborted"L,      unknownErrorInRemoteProcedure => "unknownErrorInRemoteProcedure"L,      streamNotYours => "streamNotYours"L,      truncatedTransfer => "truncatedTransfer"L,      parameterInconsistency => "parameterInconsistency"L,      invalidArguments => "invalidArguments"L,      noSuchProgramNumber => "noSuchProgramNumber"L,      protocolMismatch => "protocolMismatch"L,      duplicateProgramExport => "duplicateProgramExport"L,      noSuchProgramExport => "noSuchProgramExport"L,      invalidHandle => "invalidHandle"L,      noError => "noError"L,      ENDCASE => "?"L;    String.AppendStringAndGrow[s, "Courier.Error["L, z];    String.AppendStringAndGrow[s, eString, z];    String.AppendCharAndGrow[s, '], z];    END;      GetStatus: PROCEDURE [host: LONG STRING]    RETURNS [available: BOOLEAN ¬ TRUE, msg: LONG STRING] =    BEGIN    hostAddr: NSPrint.SystemElement = GetAddress[host];     status: NSPrint.PrinterStatus;    z: UNCOUNTED ZONE = Heap.systemZone;    msg ¬ String.CopyToNewString[host, z, 100];    String.AppendChar[msg, ':];    status ¬ NSPrint.GetPrinterStatus[hostAddr !      NSPrint.Error => WITH why SELECT FROM        busy, tooManyClients => {String.AppendString[msg, " busy\n"L]; GOTO available};	ENDCASE => {AppendNSPrintError[@msg, why, z]; GOTO notAvailable}];    FOR i: CARDINAL IN [0..LENGTH[status]) DO      WITH s: status[i] SELECT FROM         spooler => {	  String.AppendStringAndGrow[@msg, " Spooler "L, z];	  SELECT s.spooler FROM            available => String.AppendStringAndGrow[@msg, "available;"L, z];            busy => String.AppendStringAndGrow[@msg, "busy;"L, z];            disabled => String.AppendStringAndGrow[@msg, "disabled;"L, z];            full => String.AppendStringAndGrow[@msg, "full;"L, z];	    ENDCASE};        formatter => {	  String.AppendStringAndGrow[@msg, " Formatter "L, z];	  SELECT s.formatter FROM            available => String.AppendStringAndGrow[@msg, "available;"L, z];            busy => String.AppendStringAndGrow[@msg, "busy;"L, z];            disabled => String.AppendStringAndGrow[@msg, "disabled;"L, z];	    ENDCASE};        printer => {	  String.AppendStringAndGrow[@msg, " Printer "L, z];	  SELECT s.printer FROM            available => String.AppendStringAndGrow[@msg, "available;"L, z];            busy => String.AppendStringAndGrow[@msg, "busy;"L, z];            disabled => String.AppendStringAndGrow[@msg, "disabled;"L, z];            needsAttention => String.AppendStringAndGrow[@msg, "needs attention;"L, z];            needsKeyOperator => String.AppendStringAndGrow[@msg, "needs key operator;"L, z];	    ENDCASE};      ENDCASE;      ENDLOOP;    NSPrint.FreePrinterStatus[@status];    String.AppendCharAndGrow[@msg, '\n, z];    EXITS      notAvailable => available ¬ FALSE;      available => NULL;    END;      GetAddress: PROCEDURE [host: LONG STRING]    RETURNS [addr: NSPrint.SystemElement] =    BEGIN     addr ¬ AddressTranslation.StringToNetworkAddress[host !     AddressTranslation.Error => {        msg: STRING = [100];	appendProc: PROC [s: LONG STRING, clientData: LONG POINTER ¬ NIL] = {	  String.AppendString[msg, s ! String.StringBoundsFault => RESUME[NIL]]};	AddressTranslation.PrintError[error: errorRecord, proc: appendProc];        ERROR Trouble[other, msg]}].addr;    END;      END.
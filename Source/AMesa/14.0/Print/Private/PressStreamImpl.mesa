-- File: PressStreamImpl.mesa - last edit:-- Nannette.PA         22-Apr-85 14:24:34-- Copyright (C) 1983, 1984 , 1985 by Xerox Corporation. All rights reserved. -- PressStreamImpl.mesa; edited by:-- RXJ     	 1-Mar-83 15:02:06-- AXD    	 8-May-84 19:35:04-- NSG     	 29-Nov-84 16:04:17DIRECTORY  Ascii USING [CR, FF, NUL, SP, TAB],  Inline USING [HighByte, LowByte, LowHalf],  Press,  PressStreamExtras,  PressStream,  Stream,  String USING [AppendChar, AppendDecimal, SubStringDescriptor];PressStreamImpl: PROGRAM  IMPORTS Inline, Stream, String  EXPORTS PressStream, PressStreamExtras =  BEGIN    Mica: TYPE = Press.Mica;  micasPerInch: Mica = Press.micasPerInch;    cssChange: CHARACTER = 377C;    -- codes for Character Set Standard  dollar: CHARACTER = 244C;  oldUpArrow: CHARACTER = 136C;  newUpArrow: CHARACTER = 255C;  oldBackArrow: CHARACTER = 137C;  newBackArrow: CHARACTER = 254C;  ComputeWidthAndHeight: PROCEDURE [data: FHandle] =    BEGIN OPEN data;    paperWidth: Mica = 8*micasPerInch + micasPerInch/2;    paperHeight: Mica = 11*micasPerInch;    SELECT parms.mode FROM      portrait => {        logicalWidth ¬ paperWidth; logicalHeight ¬ paperHeight};      landscape => {        logicalWidth ¬ paperHeight; logicalHeight ¬ paperWidth};      ENDCASE => ERROR;    lineWidth ¬       (logicalWidth - parms.margins[right] - parms.margins[left] -      (parms.columns-1)*(parms.betweenColumns))/parms.columns;    lineHeight ¬ press.DescribeAlias[press, currentFont].size;    RETURN    END;      FormatObject: TYPE = RECORD [    stream: Stream.Object,    data: FormatData];    FormatData: TYPE = RECORD [    ignoring: BOOLEAN ¬ FALSE,    lastWasSP: BOOLEAN ¬ FALSE,    bol: BOOLEAN ¬ TRUE,    b: LONG STRING ¬ NULL,    charWidths: Press.WidthHandle ¬ NIL,    spaceWidth, tabWidth: Mica ¬ 0,    parms: PressStream.Parameters ¬ [],    parmsExtras: PressStreamExtras.ParametersExtras ¬ [],    press: Press.Handle,    i, lastWordEnd, pageNumber, column: CARDINAL ¬ 0,    currentFont, startLineFont: CARDINAL ¬ 0,    logicalWidth, logicalHeight, headerHeight: Mica ¬ 0,    currentHeight, lineHeight, lineWidth, lineX, curX, prevY, bWidth: Mica ¬ 0,    leading: Mica ¬ micasPerInch/72,    indentX, widthThruLastWord: Mica ¬ 0];    headerFont: CARDINAL = 0;    FHandle: TYPE = LONG POINTER TO FormatData;    ConvertHandle: PROCEDURE [sH: Stream.Handle] RETURNS [FHandle] = INLINE {    RETURN[@LOOPHOLE[sH, LONG POINTER TO FormatObject].data]};    ValidateHandle: PROCEDURE [sH: Stream.Handle] RETURNS [FHandle] = {    IF sH.put = PutBlock THEN RETURN[ConvertHandle[sH]]    ELSE ERROR Stream.InvalidOperation};    Create: PUBLIC PROCEDURE [    press: Press.Handle, output: Stream.Handle, name: LONG STRING]    RETURNS [Stream.Handle] =    BEGIN    h: LONG POINTER TO FormatObject ¬      press.zone.NEW[FormatObject ¬ [stream: Stream.defaultObject]];    h.stream.put ¬ PutBlock;    h.stream.delete ¬ Delete;    h.data.press ¬ press;    h.data.b ¬ press.zone.NEW[StringBody[500]];    press.Start[press, output, name];    SetFont[@h.stream, 0];    h.data.headerHeight ¬ h.data.lineHeight;    ComputeWidthAndHeight[@h.data];    RETURN[@h.stream]    END;        Delete: Stream.DeleteProcedure =    BEGIN    data: FHandle ¬ ConvertHandle[sH];    z: UNCOUNTED ZONE = data.press.zone;    IF ~data.bol THEN PutLine[data];    data.press.Finish[data.press];    sH.put ¬ NIL;    sH.delete ¬ NIL;    z.FREE[@data.b];    z.FREE[@sH];    END;        GetPageNumber: PUBLIC PROCEDURE [sH: Stream.Handle] RETURNS [CARDINAL] =    BEGIN    data: FHandle = ValidateHandle[sH];    RETURN[data.pageNumber];    END;        SetPageNumber: PUBLIC PROCEDURE [sH: Stream.Handle, page: CARDINAL] =    BEGIN    data: FHandle = ValidateHandle[sH];    data.pageNumber ¬ page - 1;    END;        SetLineWrapIndent: PUBLIC PROCEDURE [sH: Stream.Handle, indent: Press.Mica] =    BEGIN    data: FHandle = ValidateHandle[sH];    data.indentX ¬ IF indent = PressStream.currentPosition THEN data.curX    ELSE indent;    data.bol ¬ FALSE;    END;        SetParameters: PUBLIC PROCEDURE [    sH: Stream.Handle, parameters: PressStream.ParametersHandle] =    BEGIN    data: FHandle = ValidateHandle[sH];    forcePage: BOOLEAN =       data.parms.margins # parameters.margins OR      data.parms.betweenColumns # parameters.betweenColumns OR      data.parms.columns # parameters.columns OR      data.parms.mode # parameters.mode;    data.parms ¬ parameters­;    data.tabWidth ¬ data.spaceWidth*data.parms.tab;    IF forcePage THEN {      ComputeWidthAndHeight[data]; data.column ¬ data.parms.columns-1};    END;      SetParametersExtras: PUBLIC PROCEDURE [  -- merge this with above    sH: Stream.Handle, parameters: PressStreamExtras.ParametersExtrasHandle] =    BEGIN     data: FHandle = ValidateHandle[sH];     data.parmsExtras ¬ parameters­;    END;             PutBlock: Stream.PutProcedure =    BEGIN    data: FHandle = ConvertHandle[sH];    char: CHARACTER ¬ Ascii.NUL;    charWidth: Mica;    FOR charIndex: CARDINAL IN[block.startIndex..block.stopIndexPlusOne)DO      OPEN data;      lastWasSP ¬ char = Ascii.SP;      char ¬ block.blockPointer[charIndex] + 0C;      IF char IN [177c..240c] OR char = 377c THEN LOOP;      IF ignoring AND char # Ascii.CR AND char # Ascii.FF THEN LOOP;      charWidth ¬ charWidths[char];      SELECT char FROM	Ascii.NUL => LOOP;	Ascii.SP =>	  BEGIN	  IF bol THEN {lineX ¬ curX ¬ curX + spaceWidth; LOOP};	  IF ~lastWasSP THEN {lastWordEnd ¬ i; widthThruLastWord ¬ bWidth};	  IF curX + spaceWidth > lineWidth THEN BEGIN Overflow[data]; LOOP END;	  END;	Ascii.CR =>	  BEGIN	  widthThruLastWord ¬ bWidth;	  PutLine[data];	  lineX ¬ curX ¬ 0;	  ignoring ¬ FALSE;	  LOOP	  END;	Ascii.FF, 13C => -- vertical tab => new plate	  BEGIN	  IF (widthThruLastWord ¬ bWidth) # 0 THEN PutLine[data];	  IF char = Ascii.FF THEN NewColumn[data]	  ELSE {column ¬ parms.columns-1; prevY ¬ 0}; -- force end of page	  lineX ¬ curX ¬ 0;	  ignoring ¬ FALSE;	  LOOP	  END;	Ascii.TAB =>	  BEGIN	  curX ¬ ((curX + spaceWidth + tabWidth - 1)/tabWidth)*tabWidth;	  IF bol THEN lineX ¬ curX ELSE InsertTab[data, curX];	  LOOP;	  END;	'$ => {	  IF press.encoding = Interpress82 THEN char ¬ dollar; CheckBol[data]};       oldUpArrow => {IF (press.encoding = Interpress82 AND parmsExtras.mapping)         THEN char ¬ newUpArrow;          CheckBol[data]};       oldBackArrow =>{IF (press.encoding = Interpress82 AND parmsExtras.mapping)         THEN char ¬ newBackArrow;           CheckBol[data]};       newUpArrow => {IF (press.encoding # Interpress82 AND parmsExtras.mapping)         THEN char ¬ oldUpArrow;          CheckBol[data]};       newBackArrow => {IF (press.encoding # Interpress82 AND parmsExtras.mapping)         THEN char ¬ oldBackArrow;          CheckBol[data]}; 	  	'a,'b,'c,'d,'e,'f,'g,'h,'i,'j,'k,'l,'m,'n,'o,'p,'q,'r,'s,'t,'u,'v,'w,'x,'y,'z,	'A,'B,'C,'D,'E,'F,'G,'H,'I,'J,'K,'L,'M,'N,'O,'P,'Q,'R,'S,'T,'U,'V,'W,'X,'Y,'Z,	'1,'2,'3,'4,'5,'6,'7,'8,'9,'0,'!,'@,'#,'%,'~,'&,'*,'(,'),'-,'=,'+,'|,	'[,'],'_,'^,'{,'},'­,'¬,';,':,'','",',,'.,'/,'<,'>,'?, '\\,'¡,'¢,'£,'¥,'§,'«,'®,'¯,'°,'±,'²,'³,'´,'µ,'¶,'·,'¸,'»,'¼,'½,'¾,'¿,'Á,'Â,'Å,'Æ,'Ç,'È,'Ê,'Ë,'Í,'Î,'Ï,'Ð,'Ñ,'Ò,'Ó,'Ô,'Õ,'Ü,'Ý,'Þ,'ß,'ð,'ñ,'ò,'ó,'ô,'õ,'ö,'÷,'ø,'ù,'ú,'û,'ü,'ý,'î=>	 CheckBol[data];   	ENDCASE => CheckBol[data];      IF curX + charWidth > lineWidth THEN        IF parms.wrap THEN Overflow[data] ELSE {ignoring ¬ TRUE; LOOP};      IF i = b.maxlength THEN PutLine[data];      b[i] ¬ char;      b.length ¬ i ¬ i + 1;      bWidth ¬ bWidth + charWidth;      curX ¬ curX + charWidth;      ENDLOOP;    IF endRecord AND data.i # 0 THEN PutLine[data];    RETURN    END;  InsertTab: PROCEDURE [data: FHandle, tabStop: Mica] =    BEGIN OPEN data;    t: CARDINAL ¬ Inline.LowHalf[tabStop];    String.AppendChar[b, Ascii.TAB];    String.AppendChar[b, Inline.HighByte[t]];    String.AppendChar[b, Inline.LowByte[t]];    i ¬ b.length;    END;    SetFont: PUBLIC PROCEDURE [sH: Stream.Handle, font: CARDINAL] =    BEGIN    Cardinal: PROCEDURE [i: LONG INTEGER] RETURNS [CARDINAL] = INLINE {      RETURN[Inline.LowHalf[i]]};    data: FHandle = ValidateHandle[sH];    height: Mica;    data.currentFont ¬ font;    [size: height, widths: data.charWidths] ¬      data.press.DescribeAlias[data.press, font];    data.spaceWidth ¬ MAX[data.charWidths[Ascii.SP], 1];    data.tabWidth ¬ data.spaceWidth*data.parms.tab;    data.currentHeight ¬ height;    String.AppendChar[data.b, escapeChar];    String.AppendChar[data.b, fontChange];    String.AppendChar[data.b, font+0C];    String.AppendChar[data.b, (Cardinal[height]/256)+0C];    String.AppendChar[data.b, (Cardinal[height] MOD 256)+0C];    data.i ¬ data.b.length;    IF data.bol THEN {data.startLineFont ¬ font; data.lineHeight ¬ height}    ELSE data.lineHeight ¬ MAX[data.lineHeight, height];    END;    CheckBol: PROCEDURE [data: FHandle] = INLINE {    OPEN data;    IF bol THEN {indentX ¬ lineX ¬ curX; bol ¬ FALSE}};  escapeChar: CHARACTER = 200C;  fontChange: CHARACTER = 1C;    NewColumn: PROCEDURE [data: FHandle] =    BEGIN OPEN data;    eightPointFive: Mica = 8*micasPerInch+micasPerInch/2;    xShift: Mica;    column ¬ (column + 1) MOD parms.columns;    IF column = 0 THEN      BEGIN      press.NewPlate[press];      IF parms.mode = landscape THEN {        press.Rotate[press, 90];	press.Translate[h: press, x: eightPointFive, y: 0];	press.Concat[press];	press.ConcatT[press]};      pageNumber ¬ pageNumber + 1;      IF parms.headers THEN        HeaderTrailer[data, (logicalHeight-parms.margins[top])+headerHeight*2];      IF parms.trailers THEN        HeaderTrailer[data, parms.margins[bottom]-headerHeight*2];      xShift ¬ parms.margins[left];      END    ELSE xShift ¬ lineWidth + parms.betweenColumns;    press.Translate[h: press, x: xShift, y: 0];    press.ConcatT[press];    press.SetFont[press, startLineFont];    prevY ¬ logicalHeight - parms.margins[top] + leading;    END;      HeaderTrailer: PROCEDURE [data: FHandle, y: Mica] =    BEGIN OPEN data;    buffer: STRING = [4];    pnWidth: Mica ¬ 0;    charWidths: Press.WidthHandle;    IF parms.headerString = NIL THEN RETURN;    press.SetXY[press, [x: parms.margins[left], y: y]];    charWidths ¬ press.DescribeAlias[press, headerFont].widths;    press.SetFont[press, headerFont];    press.PutString[press, parms.headerString];    String.AppendDecimal[buffer, pageNumber];    FOR i: CARDINAL IN [0..buffer.length) DO      pnWidth ¬ pnWidth + charWidths[buffer[i]];      ENDLOOP;    press.SetXY[press, [x: logicalWidth-parms.margins[right]-pnWidth, y: y]];    press.PutString[press, buffer];    END;      PutLine: PROCEDURE [data: FHandle] =    BEGIN OPEN data;    PutLineSegments[data];    bWidth ¬ 0;    b.length ¬ i ¬ lastWordEnd ¬ 0;    lineHeight ¬ currentHeight;    bol ¬ TRUE;    END;      PutLineSegments: PROCEDURE [data: FHandle] =    BEGIN OPEN data;    ss: String.SubStringDescriptor;    ssEnd: CARDINAL;    IF prevY - lineHeight - leading < parms.margins[bottom] THEN NewColumn[data];    prevY ¬ prevY - lineHeight - leading;    IF b.length = 0 THEN RETURN;    press.SetXY[press, [x: lineX, y: prevY]];    ss.base ¬ b;    ss.offset ¬ ssEnd ¬ 0;    UNTIL ssEnd = b.length DO      SELECT b[ssEnd] FROM        Ascii.TAB =>	  BEGIN	  tabStop: CARDINAL ¬ (b[ssEnd+1]-0C)*400B + (b[ssEnd+2]-0C);	  ss.length ¬ ssEnd - ss.offset; -- leave off the TAB	  IF ss.length # 0 THEN press.PutSubString[press, @ss];	  press.SetXY[press, [x: tabStop, y: prevY]];	  ss.offset ¬ ssEnd ¬ ssEnd+3	  END;	escapeChar => SELECT b[ssEnd+1] FROM	  fontChange =>	    BEGIN	    ss.length ¬ ssEnd - ss.offset; -- leave off the escapeChar	    IF ss.length # 0 THEN press.PutSubString[press, @ss];	    press.SetFont[press, LOOPHOLE[b[ssEnd+2]]];	    ss.offset ¬ ssEnd ¬ ssEnd+5	    END;	  ENDCASE;	cssChange => ssEnd ¬ ssEnd + 2;	ENDCASE =>	  IF ssEnd-ss.offset > 253 THEN	    BEGIN	    ss.length ¬ ssEnd - ss.offset + 1;	    press.PutSubString[press, @ss];	    ss.offset ¬ ssEnd ¬ ssEnd+1;	    END	  ELSE ssEnd ¬ ssEnd + 1;      ENDLOOP;    ss.length ¬ ssEnd - ss.offset;    IF ss.length # 0 THEN press.PutSubString[press, @ss];    startLineFont ¬ currentFont;    END;      Overflow: PROCEDURE [data: FHandle] =    BEGIN OPEN data;    j: CARDINAL ¬ 0;    IF lastWordEnd = 0 OR lastWordEnd = b.length THEN PutLine[data]    ELSE      BEGIN      leftOvers: CARDINAL ¬ lastWordEnd + 1;      b.length ¬ lastWordEnd;      PutLineSegments[data];      bWidth ¬ bWidth - widthThruLastWord;      WHILE leftOvers < i AND b[leftOvers] = Ascii.SP DO        leftOvers ¬ leftOvers + 1;	bWidth ¬ bWidth - spaceWidth;	ENDLOOP;      b.length ¬ i - leftOvers;      FOR j: CARDINAL IN [0..b.length) DO	b[j] ¬ b[leftOvers + j]; ENDLOOP;      i ¬ b.length;      lastWordEnd ¬ 0;      END;    IF parmsExtras.granny THEN lineX ¬ 0     ELSE lineX ¬ MIN[indentX, lineWidth/2];        curX ¬ lineX + bWidth;    lineHeight ¬ currentHeight;    UNTIL j = b.length DO      SELECT b[j] FROM        Ascii.TAB => j ¬ j + 3;	escapeChar => SELECT b[j+1] FROM	  fontChange =>	    BEGIN	    height: CARDINAL ¬ (b[j+3]-0C)*256+(b[j+4]-0C);	    lineHeight ¬ MAX[lineHeight, height];	    j ¬ j + 5;	    END;	  ENDCASE;	ENDCASE => j ¬ j + 1;      ENDLOOP;    END;    boldBias: CARDINAL = 1;  italicBias: CARDINAL = 2;    END...
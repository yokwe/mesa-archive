-- File: LibTajoImpl.mesa - last edit:-- bjd                 28-Aug-86 15:53:13-- Copyright (C) 1985, 1986 by Xerox Corporation. All rights reserved.DIRECTORY  Auth ,  Librarian ,  LibCourier ,  LibOps ,  XLibrarian ,  XString,   String ,  System ;LibTajoImpl: PROGRAM  IMPORTS Librarian, String, XString, XLibrarian  EXPORTS Librarian  SHARES XString =  BEGIN      Handle: TYPE = Librarian.Handle;  Client: TYPE = LONG POINTER TO ClientObject;  ClientObject: PUBLIC TYPE = LibCourier.ClientObject;  Atom: TYPE = Librarian.Atom;  Atoms: TYPE = Librarian.Atoms;  PropertyList: TYPE = LONG POINTER TO PropertyListObject;  PropertyListObject: TYPE = Librarian.PropertyListObject;    CoveredProc: TYPE = PROC [client: Client, ver: Auth.Verifier]    RETURNS [reply: Auth.Verifier];  -- procedures  Open: PUBLIC PROC [    dataBase: LONG STRING, user: Auth.IdentityHandle ¬ NIL, zone: UNCOUNTED ZONE]    RETURNS [Handle] =    BEGIN ENABLE XLibrarian.Error => XLibrarianError[code];    dataBaseRB: XString.ReaderBody ¬ XS[dataBase];    RETURN[TajoLibHandle[XLibrarian.Open[@dataBaseRB, zone]]];    END;  Close: PUBLIC PROC [handle: Handle] =    BEGIN ENABLE XLibrarian.Error => XLibrarianError[code];    XLibrarian.Close[XLibHandle[handle]];    END;  NextLibject: PUBLIC PROC [    handle: Handle, current, mask: LONG STRING,     onlyIfCheckedOut: BOOLEAN, user: LONG STRING]    RETURNS [next: LONG STRING] =    BEGIN ENABLE XLibrarian.Error => XLibrarianError[code];    z: UNCOUNTED ZONE = ZoneFromHandle[handle];    currentRB: XString.ReaderBody ¬ XS[current];    maskRB: XString.ReaderBody ¬ XS[mask];    userRB: XString.ReaderBody ¬ XS[user];    nextRB: XString.ReaderBody ¬  XLibrarian.NextLibject[      XLibHandle[handle], @currentRB, @maskRB, onlyIfCheckedOut, @userRB];    next ¬ StringFromXString[@nextRB, z];    XString.FreeReaderBytes[@nextRB, z];    END;  MakeAtom: PUBLIC PROC [handle: Handle, s: LONG STRING] RETURNS [Atom] =    BEGIN ENABLE XLibrarian.Error => XLibrarianError[code];    RETURN[TajoLibAtom[XLibrarian.MakeAtom[XLibHandle[handle], s]]];    END;  GetPrintName: PUBLIC PROC [handle: Handle, tag: Atom] RETURNS [LONG STRING] =    {ENABLE XLibrarian.Error => XLibrarianError[code];    RETURN[XLibrarian.GetPrintName[XLibHandle[handle], XLibAtom[tag]]]};  Create: PUBLIC PROC [handle: Handle, libject: LONG STRING] = {    ENABLE XLibrarian.Error => XLibrarianError[code];    libjectRB: XString.ReaderBody ¬ XS[libject];    XLibrarian.Create[XLibHandle[handle], @libjectRB]};  Destroy: PUBLIC PROC [handle: Handle, libject: LONG STRING] = {    ENABLE XLibrarian.Error => XLibrarianError[code];    libjectRB: XString.ReaderBody ¬ XS[libject];    XLibrarian.Destroy[XLibHandle[handle], @libjectRB]};  CheckOut: PUBLIC PROC [handle: Handle, libject: LONG STRING] = {    ENABLE XLibrarian.Error => XLibrarianError[code];    libjectRB: XString.ReaderBody ¬ XS[libject];    XLibrarian.CheckOut[XLibHandle[handle], @libjectRB]};  CheckIn: PUBLIC PROC [handle: Handle, libject: LONG STRING] = {    ENABLE XLibrarian.Error => XLibrarianError[code];    libjectRB: XString.ReaderBody ¬ XS[libject];    XLibrarian.CheckIn[XLibHandle[handle], @libjectRB]};  Query: PUBLIC PROC [handle: Handle, libject: LONG STRING, what: Atoms]    RETURNS [pl: PropertyList, isCheckedOut: BOOLEAN] = {    ENABLE XLibrarian.Error => XLibrarianError[code];    libjectRB: XString.ReaderBody ¬ XS[libject];    xpl: XLibrarian.PropertyList;    [xpl, isCheckedOut] ¬ XLibrarian.Query[      XLibHandle[handle], @libjectRB, XLibAtoms[what]];    RETURN[TajoPList[xpl], isCheckedOut]};  QueryAndCheckOut: PUBLIC PROC [    handle: Handle, libject: LONG STRING, what: Atoms]    RETURNS [pl: PropertyList] = {    ENABLE XLibrarian.Error => XLibrarianError[code];    libjectRB: XString.ReaderBody ¬ XS[libject];    RETURN[TajoPList[XLibrarian.QueryAndCheckOut[XLibHandle[handle], @libjectRB, XLibAtoms[what]]]]};  SetProperties: PUBLIC PROC [    handle: Handle, libject: LONG STRING, pl: PropertyList] = {    ENABLE XLibrarian.Error => XLibrarianError[code];    libjectRB: XString.ReaderBody ¬ XS[libject];    XLibrarian.SetProperties[XLibHandle[handle], @libjectRB, XPList[pl]]};  SetPropertiesAndCheckIn: PUBLIC PROC [    handle: Handle, libject: LONG STRING, pl: PropertyList] = {    ENABLE XLibrarian.Error => XLibrarianError[code];    libjectRB: XString.ReaderBody ¬ XS[libject];    XLibrarian.SetPropertiesAndCheckIn[XLibHandle[handle], @libjectRB, XPList[pl]]};-- utilities    XLibrarianError: PROC [why: XLibrarian.ErrorCode] = {    code: Librarian.ErrorCode ¬      SELECT why FROM        insufficientAccess => insufficientAccess,        invalidCredentials => authenticationFailure,        insufficientAuthentication => insufficientAuthentication,        authenticationFailure => authenticationFailure,        dataBaseNotFound => noSuchDataBase,        dataBaseUnavailable => dataBaseBusy,        serviceInaccessible => communicationError,        serviceNotFound => noSuchDataBase,        serviceUnavailable => communicationError,        libjectNotFound => noSuchLibject,        libjectCheckedOut => alreadyCheckedOut,        libjectAlreadyExists => libjectAlreadyExists,        libjectNotCheckedOut => notCheckedOut,        libjectNotCheckedOutToYou => notCheckedOutToYou,        invalidHandle => invalidHandle,        nameTooLong => nameTooLong,        reservedProperty => reservedProperty,        illegalType => illegalType,        noSuchAtom => noSuchAtom,        implementationBug => implementationBug,        serviceFull, libjectInconsistent, unknown => unknownError,	ENDCASE => unknownError;    ERROR Librarian.Error[code]};  checkOutUser: XLibrarian.Atom = LOOPHOLE[13407B]; -- you must modify this value, if LibServOps$Hash fcn changes;  if this code seems too kludgy, you can coerce ALL xstrings (or make a call to the service with MakeAtom["CheckOutUser"];  yuck!)  TajoPList: PROCEDURE [xplist: XLibrarian.PropertyList]    RETURNS [plist: PropertyList] = {  -- replace the checkoutUser xstring with a string, so Librarian clients won't choke;    xp: LibOps.PropertyList = LOOPHOLE[xplist];    FOR i: NATURAL IN [0..xp.list.props.LENGTH) DO      IF xp.list.props[i].tag = checkOutUser THEN      WITH val: xp.list.props[i].value SELECT FROM	xString => { 	  str: LONG STRING ¬ StringFromXString[val.string, xp.z];	  v: string XLibrarian.Value ¬ [string [str]];	  XString.FreeReaderBytes[val.string, xp.z];	  xp.list.props[i] ¬ [checkOutUser, v];	  EXIT}; -- assume only one occurrence	ENDCASE => NULL;      ENDLOOP;    plist ¬ LOOPHOLE[xp]};  XPList: PROCEDURE [p: PropertyList] RETURNS [xp: XLibrarian.PropertyList] = INLINE {    RETURN[LOOPHOLE[p]]};      XLibHandle: PROCEDURE [h: Handle] RETURNS [xh: XLibrarian.Handle] = INLINE {    RETURN[LOOPHOLE[h]]};  TajoLibHandle: PROCEDURE [xh: XLibrarian.Handle] RETURNS [h: Handle] = INLINE {    RETURN[LOOPHOLE[xh]]};      XLibAtom: PROCEDURE [a: Atom] RETURNS [xa: XLibrarian.Atom] = INLINE {    RETURN[LOOPHOLE[a]]};  TajoLibAtom: PROCEDURE [xa: XLibrarian.Atom] RETURNS [a: Atom] = INLINE {    RETURN[LOOPHOLE[xa]]};  XLibAtoms: PROCEDURE [a: Atoms] RETURNS [xa: XLibrarian.Atoms] = INLINE {    RETURN[LOOPHOLE[a]]};      StringFromXString: PROCEDURE [r: XString.Reader, z: UNCOUNTED ZONE]    RETURNS [s: LONG STRING] = {    sd: String.SubStringDescriptor;    IF r=NIL OR r.bytes=NIL THEN RETURN[NIL];    sd ¬ SubStringFromXString[r];    s ¬ z.NEW[StringBody [sd.length]];    String.AppendSubString[to: s, from: @sd]};      SubStringFromXString: PROCEDURE [r: XString.Reader]    RETURNS [sd: String.SubStringDescriptor] = {    chSetShift: BOOLEAN ¬ r.bytes[0]=377B;    sd ¬ [      base: LOOPHOLE[LOOPHOLE[r.bytes, LONG CARDINAL] - (IF chSetShift THEN 1 ELSE 2), LONG POINTER TO StringBody],      offset: r.offset,      length: r.limit - r.offset];     IF chSetShift THEN sd.length ¬ sd.length-2;  };    XS: PROCEDURE [s: LONG STRING] RETURNS [XString.ReaderBody] = {    IF s=NIL THEN RETURN[XString.nullReaderBody]    ELSE RETURN[XString.FromSTRING[s, TRUE]]};  ZoneFromHandle: PROCEDURE [handle: Handle]    RETURNS [z: UNCOUNTED ZONE] = {    WITH h: handle SELECT FROM      client =>  RETURN[LOOPHOLE[h.client, Client].zone];      ENDCASE => ERROR Librarian.Error[invalidHandle]};  END.  
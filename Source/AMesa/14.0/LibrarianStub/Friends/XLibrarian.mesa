-- File: XLibrarian.mesa - last edit:-- bjd                 14-Jul-86 18:08:03-- PLK                  3-Apr-84  8:21:58-- Copyright (C) 1984, 1986 by Xerox Corporation. All rights reserved.DIRECTORY  System USING [GreenwichMeanTime],  XString USING [Reader, ReaderBody];  XLibrarian: DEFINITIONS =  BEGIN  --   --   --   --   --   --   --   --  -- TYPES & CONSTANTS :  --   --   --   --   --   --   --   --    Client: TYPE = LONG POINTER TO ClientObject;  ClientObject: TYPE;  Service: TYPE = LONG POINTER TO ServiceObject;  ServiceObject: TYPE;  Handle: TYPE = RECORD [    SELECT type: * FROM      client => [client: Client],      service => [service: Service]      ENDCASE];  nullHandle: Handle = [client[NIL]];<<  The fact that these 'Handle's are variant records should be ignored by the clients. It happened this way because of some subtle technical things having to do with trying to EXPORT the exact same interface on both the client and service side of the Courier worlds.  Just treat them as ordinary 3 word opaque objects.>>    Atom: TYPE[1];  nullAtomRep: CARDINAL = 0;  nullAtom: Atom = LOOPHOLE[nullAtomRep];<<  An 'Atom' is used as the unique name (tag) for a property.  'Atom's are obtained by calling 'MakeAtom'.  It is important to note that an 'Atom' is only valid within a single data base.  The same print name might have a different 'Atom' value in a different data base.  There are two reserved 'Atom's.   "CheckOutUser" is the tag of a 'PropertyType.string' containing the 3 part name of the last person to change some libject.  This has a non-null value even if the libject is currently checked in.  "ChangeTime" is the tag of a 'PropertyType.time' containing the date and time of the last change made to some libject.  It is set on any 'CheckIn', 'CheckOut' or 'SetProperty' call.   The reason that 'Atom's exist at all is just because it is considerably more efficient to do one word compares instead of String.Equivalent when manipulating property lists on either the client side or in the service side.  It also gets away from the need to pass the string back and forth on the wire. >>  Atoms: TYPE = LONG DESCRIPTOR FOR ARRAY OF Atom;  -- 'Atoms' are what is passed in a 'Query' call  PropertyType: TYPE = MACHINE DEPENDENT {  -- order is important for Courier!!    null(0), time, client, string, strings, integer, xString, xStrings,    spare8(8), spare9(9)};  Property: TYPE = MACHINE DEPENDENT RECORD [    tag(0): Atom,    value(1): Value];  Value: TYPE = MACHINE DEPENDENT RECORD [    body(0): SELECT type(0): PropertyType FROM      null => NULL,      time => [time(1): System.GreenwichMeanTime],      client => [record(1): Record],      string => [string(1): LONG STRING],      strings => [strings(1): Strings],      integer => [integer(1): LONG INTEGER],      xString => [string(1): XString.Reader],      xStrings => [strings(1): XStrings],      spare8, spare9 => NULL,    ENDCASE];  Record: TYPE = LONG DESCRIPTOR FOR ARRAY OF WORD;  -- current maximum length is 1500. See 'LibCourier' for the truth  XStrings: TYPE = LONG DESCRIPTOR FOR ARRAY OF XString.Reader;  Strings: TYPE = LONG DESCRIPTOR FOR ARRAY OF LONG STRING;  -- current maximum length is 250. See 'LibCourier' for the truth  PropertyList: TYPE = LONG POINTER TO PropertyListObject;  -- maximum number of properties on any one list is currently 160.  -- Check the private interface 'LibOps' for the truth.  PropertyListObject: TYPE;    nullProperty: Property = [nullAtom, [null[]]];    --   --   --   --   --   --   --   --  -- PROCEDURES :  --   --   --   --   --   --   --   --    Open: PROC [    dataBase: XString.Reader, zone: UNCOUNTED ZONE] RETURNS [handle: Handle];  -- The zone is used to do all the Courier allocation and deallocation.  In addition, any Query against the handle will return PropertyLists that have been allocated from it.  Close: PROC [Handle];  NextLibject: PROCEDURE [    handle: Handle, current: XString.Reader, mask: XString.Reader ¬ NIL,    onlyIfCheckedOut: BOOLEAN ¬ FALSE, user: XString.Reader ¬ NIL]    RETURNS [next: XString.ReaderBody];<<  This gives the client a way of enumerating all the libjects in a given data base.  To start, current should be a NIL string. If 'mask' is non-nil, then only libjects that pass a wild card equivalency filter will be returned to the client.  This uses the standard syntax where a '#' will match any one character and a '*' will match any string of characters, including the empty string.   If the 'onlyIfCheckedOut' boolean is TRUE, then only those libjects that are checked out will be returned.  The 'user' parameter is only useful if 'onlyIfCheckedOut' is TRUE.  In this case only those libjects that are checked out to some specific user will be returned.  'user' must be the 3 part name including the colon separators.  It is the clients responsibility to free 'next' back to the same zonethat was passed into the Open call.>>  MakeAtom: PROCEDURE [handle: Handle, s: LONG STRING] RETURNS [Atom];  -- 'MakeAtom' does the obvious thing.  GetPrintName: PROCEDURE [handle: Handle, tag: Atom] RETURNS [LONG STRING];  -- It is the clients responsibility to free the string returned by 'GetPrintName'.  It is allocated from the same zone that was passed in to create the 'Handle'.  -- Remote PropertyList Procedures<<  The term libject is sometimes confused.  The best way to think about it is that each libject is a name property list residing within some data base.  Each of the properties on that list is tagged with the name.  Having a libject checked out merely means that the user has exclusive rights to change that remote property list.  (You can't change if you don't have the libject checked out.  At most one user can have any libject checked out at at time.  This has nothing to do with what files are checked out.  There has been some confusion over this issue for some time.  Basically it is up to the application to decide what it means to have anything other than a libject checked out.  Access, for instance, decided to map having the libject checked out as the same thing as having current ownership of some file as specified in some of the properties of that libject.  This is not to say that this is a bad thing to do.  It is just important to realize that this is not the only way to design how an application is going to use the librarian.>>  Create: PROC [handle: Handle, libject: XString.Reader];  -- 'Create' creates a libject of name 'libject' in the data base.  The libject is automatically considered checked out after 'Create' succeeds.  It is expected that the client is going to immediately put on some application specific properties (and then probably check it in).  Destroy: PROC [handle: Handle, libject: XString.Reader];   -- 'Destroy' removes 'libject' from it data base.  Query: PROC [handle: Handle, libject: XString.Reader, what: Atoms]    RETURNS [pl: PropertyList, isCheckedOut: BOOLEAN];<<  The property list returned only has values filled in for the 'Atom's that are in 'what'. If 'what' is of length zero, then all the properties associated with that libject are returned.  If some tag in 'what' is not in 'libject', then the associated property in 'pl' will have a type of 'null'.  'pl' is now owned by the client and must be destroyed explicitly to prevent storage from being lost.  If all you want to know is if 'libject' is checked out, then pass in 'what' containing something like MakeAtom[handle, "ChangeTime"L] >>  CheckOut: PROC [handle: Handle, libject: XString.Reader];  -- 'CheckOut' checks out 'libject'. What this means is that the user represented by the 'user' of the 'Open' call can change any of the properties in the data base. No properties may be changed without first checking out the libject.  CheckIn: PROC [handle: Handle, libject: XString.Reader];  -- 'CheckIn' unlocks 'libject'.  SetProperties: PROC [handle: Handle, libject: XString.Reader, pl: PropertyList];  -- 'SetProperties' only changes those properties of 'libject' that are also in 'pl'. If necessary new properties are added to 'libject'. If some property of 'pl' is of type 'null', then that property is removed from 'libject'.  'pl' is still owned by the client and must be destroyed by him.  QueryAndCheckOut: PROC [    handle: Handle, libject: XString.Reader, what: Atoms]    RETURNS [pl: PropertyList];  -- 'QueryAndCheckOut' does the obvious thing.  SetPropertiesAndCheckIn: PROC [    handle: Handle, libject: XString.Reader, pl: PropertyList];  -- 'SetPropertiesAndCheckIn' does the obvious thing.    -- Local PropertyList Procedures  <<  These are the procedures that are used to manipulate the property lists.  Either those that are going to be used in calls to 'SetProperties' or those lists returned by 'Query' calls.>>  CreatePropertyList: PROC [z: UNCOUNTED ZONE] RETURNS [pl: PropertyList];  -- 'CreatePropertyList' does the obvious thing.  CopyPropertyList: PROC [from: PropertyList] RETURNS [to: PropertyList];  -- 'CopyPropertyList' is only here for completeness. I have no idea what client needs it.  DestroyPropertyList: PROC [pl: PropertyList];  -- 'DestroyPropertyList' does the obvious thing.  RemoveAllProperties: PROC [pl: PropertyList];  -- 'RemoveAllProperties' removes all the properties from a property list.<<  There is even a way to find out all the properties in a list.  This is especially useful if you don't know what 'Atom's are there because you have just done a 'Query' with an empty 'Atoms' ARRAY.>>  PropertyEnumerator: TYPE = PROC [prop: Property]    RETURNS [done: BOOLEAN ¬ FALSE];  EnumerateProperties: PROC [pl: PropertyList, proc: PropertyEnumerator];    AddProperty: PROC [plist: PropertyList, prop: Property];  -- Assumes property value is already copied from correct zone (if it is a property type that needs additional storage).  This procedure will not be called by most clients.  They typically will use one of the AddXXXProperty procedures below.  Any old value (i.e. property with the same tag) is returned to the zone from which the property list was created.   GetProperty: PROC [plist: PropertyList, tag: Atom]    RETURNS [prop: Property];  -- returns [nullAtom, null[]] if tag not found  RemoveProperty: PROC [plist: PropertyList, tag: Atom];<<  The following procedures return discriminated values to the client.  No copying of the data is done, so the client must not free any of the values returned.  The values are only valid until a change (AddXXXProperty or RemoveProperty) is made to the property list.  For instance, if a 'string' property was obtained, the next AddProperty that changes that value will cause the string to be returned to its zone.>>  GetTimeProperty: PROC [plist: PropertyList, tag: Atom]    RETURNS [System.GreenwichMeanTime];  GetRecordProperty: PROC [plist: PropertyList, tag: Atom]    RETURNS [Record];  GetXStringProperty: PROC [plist: PropertyList, tag: Atom]    RETURNS [XString.Reader];  GetXStringsProperty: PROC [plist: PropertyList, tag: Atom]    RETURNS [XStrings];  GetStringProperty: PROC [plist: PropertyList, tag: Atom]    RETURNS [LONG STRING];  GetStringsProperty: PROC [plist: PropertyList, tag: Atom]    RETURNS [Strings];  GetIntegerProperty: PROC [plist: PropertyList, tag: Atom]    RETURNS [LONG INTEGER];<<  The following procedures add properties of some specific type to a property list.  If the property already exists (i.e. there is a property on the list with the same tag) the new property replaces the old one even if the types are not the same.  For 'PropertyType's of 'client', 'string' and 'strings', the parameters are copied into the zone associated with the property list (either the one from CreatePropertyList or from a call on 'Query' which uses the zone passed into the 'Handle' creation).  For example, it is legal to pass some constant string into 'AddStringProperty'.>>  AddTimeProperty: PROC [    plist: PropertyList, tag: Atom, time: System.GreenwichMeanTime];  AddRecordProperty: PROC [    plist: PropertyList, tag: Atom,    record: Record];  AddXStringProperty: PROC [    plist: PropertyList, tag: Atom, string: XString.Reader];  AddXStringsProperty: PROC [    plist: PropertyList, tag: Atom,    strings: XStrings];  AddStringProperty: PROC [    plist: PropertyList, tag: Atom, string: LONG STRING];  AddStringsProperty: PROC [    plist: PropertyList, tag: Atom,    strings: Strings];  AddIntegerProperty: PROC [    plist: PropertyList, tag: Atom, integer: LONG INTEGER];  --   --   --   --   --   --   --   --  -- SIGNALS & ERRORS :  --   --   --   --   --   --   --   --<<  Only two errors are ever raised by calls into the Librarian.  The generic 'Error' handles most of the cases by encoding the specific fault into the 'code' parameter.  The client should UNWIND the call into the Librarian if a signal is raised before calling in again, i.e., don't make another Librarian call while in the catch phrase.  'WrongPropertyType' is only raised by the GetXXXXProperty procedures when the property asked for from some property list does not have a type that matches what was asked for (or isn't there).  This indicates that multiple applications are using the same data base and have not come to some understanding about what information they want to share.>>  Error: ERROR [code: ErrorCode];  ErrorCode: TYPE = MACHINE DEPENDENT {    insufficientAccess(0), -- user doesn't have access or problem determining access    invalidCredentials, -- user identity cannot be authenticated    insufficientAuthentication, -- user identity needs to be stronger    authenticationFailure, -- authentication has failed somewhere    dataBaseNotFound, -- data base doesn't exist on the service    dataBaseUnavailable, -- data base is unavailable to perform that operation    serviceFull, -- not enough room on the service    serviceInaccessible, -- service location can't be determined, e.g. CH is down    serviceNotFound, -- service cannot be found    serviceUnavailable, -- service found, but it's not cooperating    libjectInconsistent, -- libject appears damaged or inconsistent    libjectNotFound, -- libject doesn't exist in the data base    libjectCheckedOut, -- libject is already checked out    libjectAlreadyExists, -- a libject of that name already exists    libjectNotCheckedOut, -- can't check in libject; it's not checked out     libjectNotCheckedOutToYou, -- can't check in libject; it's not checked out to you    invalidHandle, -- handle is trashed or has timed out    nameTooLong, reservedProperty, illegalType, noSuchAtom,    implementationBug, -- a librarian implementation bug has been uncovered    unknown, (LAST[CARDINAL])};   StringForErrorCode: PROC [code: ErrorCode, s: LONG STRING];  -- This appends the appropriate error message onto 's'.  Only as much as will fit into 's' is actually appended.  The client is protected from seeing the String.StringBoundsFault, but no indication that the error message has been truncated is given.  Most of the error messages are merely an expansion of 'code' with all the words capitalized and spaces in between each word.  WrongPropertyType: ERROR;  END.
-- Copyright (C) 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- File: HistCommands.mesa   last edited by-- AXD    ,	18-Aug-83 14:09:46-- JGS    ,	20-Jan-82 11:09:30-- PXK    ,	Jun 23, 1980 3:17 PM-- DXG    ,	22-May-84 18:02:05-- RES  ,	 6-Jan-84 16:01:04DIRECTORY  Inline: TYPE USING [DBITSHIFT, LongCOPY],  MsgSW: TYPE USING [Post],  PerfCommonOps: TYPE USING [logSW, msgSW, WriteLongNumber],  PerfOps: TYPE USING [    GetBase, GetBuckets, GetHistBase, GetHistLeg, GetHistNode, GetLegTable,    GetNodeTable, GetPCR, GetScale, histClass, histType, PutMessage],  PerfPrivate: TYPE USING [    HistBase, HistIndex, Histogram, HistType, LegTable, MaxLegs, MaxNodes,    NodeTable, NullHist, NullNode, Number, PCR],  Put: TYPE USING [CR, Decimal, Line, Text],  String: TYPE USING [AppendChar, AppendDecimal],  UserInput: TYPE USING [UserAbort];HistCommands: PROGRAM  IMPORTS Inline, PerfOps, UserInput, String, Put, MsgSW, PerfCommonOps  EXPORTS PerfOps =PUBLIC  BEGIN OPEN PerfCommonOps, PerfOps, PerfPrivate;  AddHistogram: PUBLIC PROC = {    hIndex: HistIndex;    hist: LONG POINTER TO Histogram;    index: CARDINAL;    size, scale, limit: CARDINAL;    type: HistType = PerfOps.histType;    histBase: HistBase;    nodeTab: NodeTable = GetNodeTable[read];    legTab: LegTable = GetLegTable[read];    pCR: PCR = GetPCR[read];    SELECT type FROM      node => {	index ¬ GetHistNode[];	IF index ~IN [0..pCR.nextNode) THEN GOTO invalidNode;	IF (hIndex ¬ nodeTab[index].hist) # NullHist THEN {	  PutHistError[alreadyOne]; DeleteHist[hIndex]}};      leg => {	index ¬ GetHistLeg[];	IF index ~IN [0..pCR.nextLeg) THEN GOTO invalidLeg;	IF (hIndex ¬ legTab[index].hist) # NullHist THEN {	  PutHistError[alreadyOne]; DeleteHist[hIndex]}};      ENDCASE => ERROR;    limit ¬ FindAvailableSpace[pCR.histFree];    IF histClass = log THEN limit ¬ MIN[32, limit];    size ¬ CheckBuckets[limit ! Confused => GOTO return];    scale ¬ CheckScale[type ! Confused => GOTO return];    hIndex ¬ GrabHistogramSlot[size];    Put.Text[logSW, "Added Histogram for "L];    IF histType = node THEN {      [] ¬ GetNodeTable[write];      nodeTab[index].hist ¬ hIndex;      Put.Text[logSW, "Node "L]}    ELSE {      [] ¬ GetLegTable[write];      legTab[index].hist ¬ hIndex;      Put.Text[logSW, "Leg "L]};    Put.Decimal[logSW, index+1];    Put.CR[logSW];    histBase ¬ GetHistBase[write];    hist ¬ @histBase[hIndex];    Zero[hist, Histogram.SIZE + size];    hist.scale ¬ scale;    hist.type ¬ type;    hist.class ¬ histClass;    hist.nBuckets ¬ size;    hist.base ¬ GetBase[];    EXITS      return => NULL;      invalidNode => PutHistError[invalidNode];      invalidLeg => PutHistError[invalidLeg]};  Zero: PROC [p: LONG POINTER, l: CARDINAL] = {    IF l # 0 THEN {p­ ¬ 0; Inline.LongCOPY[from: p, to: p + 1, nwords: l - 1]}};  ValidateIndex: PROC [type: HistType, index: CARDINAL, pCR: PCR]    RETURNS [hIndex: HistIndex] = {    SELECT type FROM      node => {	nodeTab: NodeTable = GetNodeTable[read];	IF index NOT IN [0..pCR.nextNode) THEN SIGNAL Invalid;	IF (hIndex ¬ nodeTab[index].hist) = NullHist THEN SIGNAL Confused};      leg => {	legTab: LegTable = GetLegTable[read];	IF index NOT IN [0..pCR.nextLeg) THEN SIGNAL Invalid;	IF (hIndex ¬ legTab[index].hist) = NullHist THEN SIGNAL Confused};      ENDCASE};  Confused: SIGNAL = CODE;  Invalid: SIGNAL = CODE;  DeleteHistogram: PROC = {    type: HistType = histType;    nodeTab: NodeTable = GetNodeTable[read];    legTab: LegTable = GetLegTable[read];    pCR: PCR = GetPCR[read];    index: CARDINAL = IF type = node THEN GetHistNode[] ELSE GetHistLeg[];    hIndex: HistIndex;    hIndex ¬ ValidateIndex[      type, index, pCR !      Invalid => IF type = node THEN GOTO invalidNode ELSE GOTO invalidLeg;      Confused => GOTO return];    Put.Text[logSW, "Deleted Histogram for "L];    SELECT type FROM      node => {	[] ¬ GetNodeTable[write];	DeleteHist[hIndex];	nodeTab[index].hist ¬ NullHist;	Put.Text[logSW, "Node "L]};      leg => {	[] ¬ GetLegTable[write];	DeleteHist[hIndex];	legTab[index].hist ¬ NullHist;	Put.Text[logSW, "Leg "L]};      ENDCASE;    Put.Decimal[logSW, index+1];    Put.CR[logSW];    EXITS      invalidNode => PutHistError[invalidNode];      invalidLeg => PutHistError[invalidLeg];      return => PutHistError[none]};  DeleteHist: PROC [hIndex: HistIndex] = {    histBase: HistBase = GetHistBase[read];    nodeTab: NodeTable = GetNodeTable[read];    legTab: LegTable = GetLegTable[read];    pCR: PCR = GetPCR[write];    count: CARDINAL;    from, to: HistIndex;    to ¬ hIndex;    from ¬ hIndex + Histogram.SIZE + histBase[hIndex].nBuckets;    UNTIL from = pCR.histFree DO      FOR i: CARDINAL IN [0..MaxNodes) DO	IF nodeTab[i].hist = from THEN {	  [] ¬ GetNodeTable[write]; nodeTab[i].hist ¬ to};	ENDLOOP;      FOR i: CARDINAL IN [0..MaxLegs) DO	IF legTab[i].hist = from THEN {	  [] ¬ GetLegTable[write]; legTab[i].hist ¬ to};	ENDLOOP;      [] ¬ GetHistBase[write];      count ¬ Histogram.SIZE + histBase[from].nBuckets;      Inline.LongCOPY[from: @histBase[from], to: @histBase[to], nwords: count];      from ¬ from + count;      to ¬ to + Histogram.SIZE + histBase[to].nBuckets;      ENDLOOP;    pCR.histFree ¬ to};  PrintHistogram: PROC = {    type: HistType = PerfOps.histType;    index: CARDINAL = IF type = node THEN GetHistNode[] ELSE GetHistLeg[];    nodeTab: NodeTable = GetNodeTable[read];    legTab: LegTable = GetLegTable[read];    pCR: PCR = GetPCR[read];    hIndex: HistIndex;    Put.CR[logSW];    hIndex ¬ ValidateIndex[      type, index, pCR !      Invalid => IF type = node THEN GOTO invalidNode ELSE GOTO invalidLeg;      Confused => GOTO return];    ListHist[hIndex, index, type];    EXITS      invalidNode => PutHistError[invalidNode];      invalidLeg => PutHistError[invalidLeg];      return => PutHistError[none]};  ListHist: PROC [hIndex: HistIndex, index: CARDINAL, type: HistType] = {    histBase: HistBase = GetHistBase[read];    hist: LONG POINTER TO Histogram = @histBase[hIndex];    Put.CR[logSW];    Put.Text[logSW, "Histogram for "L];    Put.Text[logSW, IF type = node THEN "Node "L ELSE "Leg "L];    Put.Decimal[logSW, index+1];    Put.CR[logSW];    Put.Text[logSW, "Number of References  "L];    WriteLongNumber[hist.count, 15];    Put.CR[logSW];    Put.Text[logSW, "Sum of Values         "L];    WriteLongNumber[hist.sum, 15];    Put.CR[logSW];    Put.Text[logSW, "Average Value         "L];    WriteLongNumber[IF hist.count = 0 THEN 0 ELSE hist.sum/hist.count, 15];    Put.CR[logSW];    Put.Text[logSW, "Scale Factor (2­n)    "L];    WriteLongNumber[hist.scale, 15];    Put.CR[logSW];    IF hist.class = linear THEN {      Put.Text[logSW, "Base                  "L];      WriteLongNumber[hist.base, 15];      Put.CR[logSW]};    Put.Line[logSW, "     Value       Count"L];    Put.Line[logSW, " -------------- -------"L];    IF hist.class = linear AND hist.base # 0 THEN {      Put.Text[logSW, "      Underflow"L];      WriteLongNumber[hist.underflow, 8];      Put.CR[logSW]};    FOR i: CARDINAL IN [0..hist.nBuckets) DO      IF UserInput.UserAbort[logSW] THEN {PutMessage[aborted]; RETURN};      WriteLongNumber[ScaleBucket[i, hist], 15];      WriteLongNumber[hist.buckets[i], 8];      Put.CR[logSW];      ENDLOOP;    Put.Text[logSW, "       Overflow"L];    WriteLongNumber[hist.overflow, 8];    Put.CR[logSW]};  ScaleBucket: PROC [bucket: CARDINAL, hist: LONG POINTER TO Histogram] RETURNS [val: LONG CARDINAL] = {    SELECT hist.class FROM      linear => val ¬ Inline.DBITSHIFT[bucket, hist.scale] + hist.base;      ENDCASE => val ¬ Inline.DBITSHIFT[1, (hist.scale + bucket)]};  LegLegal: PROC [index: CARDINAL] RETURNS [BOOLEAN] = {    legTab: LegTable = GetLegTable[read];    pCR: PCR = GetPCR[read];    RETURN[index IN [0..pCR.nextLeg) AND legTab[index].from # NullNode]};  FindAvailableSpace: PROC [free: HistIndex] RETURNS [limit: CARDINAL] = {    limit ¬ NullHist - free;    RETURN[IF limit > Histogram.SIZE THEN limit - Histogram.SIZE ELSE 0]};  GrabHistogramSlot: PROC [size: CARDINAL] RETURNS [hist: HistIndex] = {    pCR: PCR = GetPCR[write];    hist ¬ pCR.histFree;    pCR.histFree ¬ hist + size + Histogram.SIZE};  CheckScale: PROC [type: HistType] RETURNS [n: CARDINAL] = {    n ¬ GetScale[];    IF n IN [0..31] THEN RETURN;    MsgSW.Post[sw: PerfCommonOps.msgSW, string: "Scale must be (2­n) [0..31]"L];    ERROR Confused};  CheckBuckets: PROC [top: CARDINAL] RETURNS [n: CARDINAL] = {    s: STRING = [5];    n ¬ GetBuckets[];    IF n IN [1..top] THEN RETURN;    MsgSW.Post[      sw: PerfCommonOps.msgSW, string: "Number of Buckets must be [1.."L,      endOfMsg: FALSE];    String.AppendDecimal[s, NARROW[top]];    String.AppendChar[s, ']];    MsgSW.Post[PerfCommonOps.msgSW, s];    ERROR Confused};  HistError: TYPE = {invalidLeg, invalidNode, alreadyOne, none};  PutHistError: PROC [message: HistError] = {    MsgSW.Post[      PerfCommonOps.msgSW,      SELECT message FROM	invalidLeg => "!Invalid Leg"L,	invalidNode => "!Invalid Node"L,	alreadyOne => "Old Histogram deleted!"L,	none => "No Histogram exists!"L,	ENDCASE => "?"L]};  END.  	
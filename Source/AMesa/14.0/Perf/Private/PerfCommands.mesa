-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- File: PerfCommands.mesa   last edited by-- AXD    ,	 7-Dec-83 17:22:22-- JGS    ,	20-Jan-82 11:10:51-- PXK    ,	September 19, 1980  2:02 PMDIRECTORY  DebugUsefulDefsExtras: TYPE USING [BBHandle, BytePC, EnumerateBBs, FindBB,     FindBBNum, FindUserBB, GFshort],  CPSwapDefs: TYPE USING [BBHandle, UBBPointer],  DebugUsefulDefs: TYPE USING [LongCopyREAD, LongREAD],  Format: TYPE USING [NumberFormat],  PerfCommonOps: TYPE USING [    AverageTime, logSW, Number, WriteConvertedTicksToMs, WriteLongNumber,    WritePercent, WriteTime],  PerfOps: TYPE USING [    DeleteHist, GetConfigAndModuleName, GetHistBase, GetLegTable, GetNodeTable,    GetPCR, NoContext, PostError, process, PutMessage, WriteLegTableHeader,    WriteNodeTableHeader],  PerfPrivate: TYPE USING [    AllNodes, HistBase, HistIndex, Histogram, Leg, LegIndex, LegTable, MaxLegs,    MaxNodes, Node, NodeID, NodeIndex, NodeTable, NoLegSlot, NullHist, NullID,    NullNode, Number, PCR, SubLegIndex, SubNodeIndex],  PerfStructures: TYPE USING [IndexToHandle, NullPsbHandle, PsbIndex],  PrincOps: TYPE USING [BytePC, GlobalCodebase],  PrincOpsExtras2: TYPE USING [nullGFH, GFTHandle, GFT],  Put: TYPE USING [Char, CR, Decimal, Line, Number, Text],  String: TYPE USING [InvalidNumber, StringToOctal],  TextSW: TYPE USING [ForceOutput],  UserInput: TYPE USING [UserAbort];PerfCommands: PROGRAM  IMPORTS    DebugUsefulDefsExtras, DebugUsefulDefs, PerfOps, Put, UserInput,     String, TextSW, PerfCommonOps,    PerfStructures  EXPORTS PerfOps = PUBLIC  BEGIN OPEN PerfCommonOps, PerfOps, PerfPrivate;  BPDisappeared: ERROR = CODE;    plusInfinity: PRIVATE LONG CARDINAL = LAST[LONG CARDINAL];  SetProcess: PROC = {    OPEN PerfStructures;    pCR: PCR = GetPCR[write];    index: PsbIndex;    IF process = NIL OR process.length = 0 THEN {      pCR.process ¬ NullPsbHandle; Put.Line[logSW, "All processes now tracked"L]}    ELSE {      index ¬ String.StringToOctal[        process ! String.InvalidNumber => GOTO badProcess];      Put.Text[logSW, "Track process: "L];      Put.Line[logSW, process];      pCR.process ¬ IndexToHandle[index];      EXITS badProcess => PostError[badProcess]}};  ClearTables: PROC = {    pCR: PCR = GetPCR[write];    nodeTable: NodeTable = GetNodeTable[write];    legTable: LegTable = GetLegTable[write];    pCR.measuringNow ¬ FALSE;    pCR.perfTime ¬ 0;    pCR.totalTime ¬ 0;    pCR.totalBreaks ¬ 0;    pCR.process ¬ PerfStructures.NullPsbHandle;    pCR.nextLeg ¬ 0;    pCR.nextNode ¬ 0;    pCR.histFree ¬ HistIndex.FIRST;    pCR.lastID ¬ NullNode;    FOR i: CARDINAL IN SubNodeIndex DO      nodeTable[i] ¬ Node[id: NullID, hits: 0, hist: NullHist]; ENDLOOP;    FOR i: SubLegIndex IN SubLegIndex DO      legTable[i] ¬ [        start: 0, from: NullNode, to: NullNode, longest: 0,        shortest: plusInfinity, owner: NIL, hits: 0, sum: 0, lock: FALSE,        someIgnored: FALSE, hist: NullHist];      ENDLOOP;    Put.Line[logSW, "Tables initialized"L]};  ZeroCounts: PROC = {    pCR: PCR = GetPCR[write];    nodeTable: NodeTable = GetNodeTable[write];    legTable: LegTable = GetLegTable[write];    histBase: HistBase;    node: LONG POINTER TO Node;    leg: LONG POINTER TO Leg;    pCR.measuringNow ¬ FALSE;    pCR.perfTime ¬ 0;    pCR.totalTime ¬ 0;    pCR.totalBreaks ¬ 0;    pCR.lastID ¬ NullNode;    FOR i: CARDINAL IN SubNodeIndex DO      node ¬ @nodeTable[i];      node.hits ¬ 0;      IF node.hist # NullHist THEN {        histBase ¬ GetHistBase[write]; ZeroHist[@histBase[node.hist]]};      ENDLOOP;    FOR i: SubLegIndex IN SubLegIndex DO      leg ¬ @legTable[i];      leg.owner ¬ NIL;      leg.hits ¬ 0;      leg.someIgnored ¬ FALSE;      leg.longest ¬ 0;      leg.shortest ¬ plusInfinity;      leg.sum ¬ 0;      IF leg.hist # NullHist THEN {        histBase ¬ GetHistBase[write]; ZeroHist[@histBase[leg.hist]]};      ENDLOOP;    Put.Line[logSW, "Tables zeroed"L]};  ZeroHist: PROC [hist: LONG POINTER TO Histogram] = {    hist.count ¬ 0;    hist.overflow ¬ 0;    hist.underflow ¬ 0;    hist.sum ¬ 0;    FOR i: CARDINAL IN [0..hist.nBuckets) DO hist.buckets[i] ¬ 0; ENDLOOP};  DeleteLeg: PROC [index: LegIndex] = {    pCR: PCR = GetPCR[write];    legTable: LegTable = GetLegTable[write];    leg: LONG POINTER TO Leg = @legTable[index];    IF index >= pCR.nextLeg THEN {PostError[badLeg]; RETURN};    IF leg.hist # NullHist THEN DeleteHist[leg.hist];    leg­ ¬ [      start: 0, from: NullNode, to: NullNode, longest: 0, shortest: plusInfinity,      owner: NIL, hits: 0, sum: 0, lock: FALSE, hist: NullHist,      someIgnored: FALSE];    IF index = pCR.nextLeg - 1 THEN pCR.nextLeg ¬ pCR.nextLeg - 1;    Put.Text[logSW, "Leg "L];    Put.Decimal[logSW, index.SUCC]; -- index is the internal number    Put.Line[logSW, " deleted"L]};  AddLeg: PROC [from, to: NodeIndex] = {    pCR: PCR = GetPCR[write];    nodeTable: NodeTable = GetNodeTable[write];    legTable: LegTable = GetLegTable[write];    FindLegSlot: PROC RETURNS [i: LegIndex] = {      FOR i IN [0..pCR.nextLeg) DO        IF ~legTable[i].lock AND legTable[i].from = NullNode THEN RETURN[i];        ENDLOOP;      IF pCR.nextLeg < MaxLegs THEN {        i ¬ pCR.nextLeg; pCR.nextLeg ¬ pCR.nextLeg + 1; RETURN};      RETURN[NoLegSlot]};    NotInLegTab: PROC [start, end: CARDINAL] RETURNS [BOOLEAN] = {      FOR i: CARDINAL IN SubLegIndex DO        IF legTable[i].from = start AND legTable[i].to = end THEN RETURN[FALSE];        ENDLOOP;      RETURN[TRUE]};    CreateLeg: PROC [from, to: NodeIndex] = {      leg: LegIndex;      IF from IN [0..pCR.nextNode) AND to IN [0..pCR.nextNode) THEN        IF NotInLegTab[from, to] THEN {          IF (leg ¬ FindLegSlot[]) # NoLegSlot THEN {            legTable[leg] ¬ [              start: 0, from: from, to: to, longest: 0, shortest: plusInfinity,              owner: NIL, hits: 0, sum: 0, someIgnored: FALSE, lock: TRUE,              hist: NullHist];            Put.Text[logSW, "Leg from "L];            Put.Decimal[logSW, NodeIDToBpNum[nodeTable[from].id]];            Put.Text[logSW, " to "L];            Put.Decimal[logSW, NodeIDToBpNum[nodeTable[to].id]];            Put.Line[logSW, " added"L]}          ELSE PostError[noLegRoom]}        ELSE NULL      ELSE PostError[badNode]};    IF from # AllNodes THEN      IF to # AllNodes THEN CreateLeg[from, to]      ELSE FOR i: CARDINAL IN [0..pCR.nextNode) DO CreateLeg[from, i]; ENDLOOP    ELSE      IF to # AllNodes THEN        FOR i: CARDINAL IN [0..pCR.nextNode) DO CreateLeg[i, to]; ENDLOOP      ELSE        FOR i: CARDINAL IN [0..pCR.nextNode) DO          FOR j: CARDINAL IN [0..pCR.nextNode) DO CreateLeg[i, j]; ENDLOOP	  ENDLOOP};  PrintTables: PROC = {    PrintTotals[];    IF UserInput.UserAbort[logSW] THEN {      PutMessage[aborted]; Put.CR[logSW]; RETURN};    PrintNodeTable[];    PrintLegTable[]};  PrintTotals: PROC = {    s: STRING ¬ [20];    pCR: PCR ¬ GetPCR[read];    Put.CR[logSW];    PutMessage[totalTime];    WriteConvertedTicksToMs[pCR.totalTime, pCR.pulseConversion, 15];    Put.CR[logSW];    PutMessage[elapsedTime];    WriteConvertedTicksToMs[      pCR.totalTime - pCR.perfTime, pCR.pulseConversion, 15];    Put.CR[logSW];    PutMessage[totalOverhead];    WriteConvertedTicksToMs[pCR.perfTime, pCR.pulseConversion, 15];    Put.CR[logSW];    PutMessage[nBreaks];    WriteLongNumber[pCR.totalBreaks, 15];    Put.CR[logSW];    PutMessage[avgOverhead];    WriteTime[      AverageTime[pCR.perfTime, pCR.totalBreaks, pCR.pulseConversion], 15];    Put.CR[logSW];    PutMessage[percentInMont];    WritePercent[pCR.perfTime, pCR.totalTime, 15];    Put.CR[logSW];    TextSW.ForceOutput[logSW]};  NumberFormat: TYPE = Format.NumberFormat;  ID: NumberFormat = [base: 10, zerofill: FALSE, unsigned: TRUE, columns: 3];  PC: NumberFormat = [base: 8, zerofill: FALSE, unsigned: TRUE, columns: 9];  Frame: NumberFormat = [base: 8, zerofill: FALSE, unsigned: TRUE, columns: 7];  PrintNodeTable: PROC = {    OPEN String;    pCR: PCR = GetPCR[read];    nodeTable: NodeTable = GetNodeTable[read];    node: LONG POINTER TO Node;    config: STRING ¬ [40];    module: STRING ¬ [40];    IF UserInput.UserAbort[logSW] THEN {      PutMessage[aborted]; Put.CR[logSW]; RETURN};    Put.CR[logSW];    WriteNodeTableHeader[];    FOR i: SubNodeIndex IN SubNodeIndex DO      node ¬ @nodeTable[i];      IF i < pCR.nextNode OR node.hits # 0 THEN {        ENABLE BPDisappeared => {	  Put.Line[logSW, "***Breakpoint has disappeared***"L]; GOTO noBP};        IF UserInput.UserAbort[logSW] THEN {          PutMessage[aborted]; Put.CR[logSW]; EXIT};        Put.Number[logSW, NodeIDToBpNum[node.id], ID];        Put.Char[logSW, IF node.hist = NullHist THEN '  ELSE '*];        Put.Number[logSW, node.id.gfi, Frame];        Put.Number[logSW, node.id.pc, PC];        WriteNodeHits[node, 11];        Put.Char[logSW, ' ];        IF i < pCR.nextNode THEN {          module.length ¬ config.length ¬ 0;          GetConfigAndModuleName[            node.id.gfi, config, module ! NoContext => GOTO noContext];          PrintString[config, 16];          Put.Char[logSW, ' ];          PrintString[module, 24];          Put.CR[logSW]};        EXITS noContext => PostError[noContext]; noBP => NULL};      ENDLOOP;    TextSW.ForceOutput[logSW]};  PrintString: PROC [s: STRING, length: CARDINAL] = {    l: CARDINAL = MIN[length, s.length];    FOR i: CARDINAL IN [0..l) DO Put.Char[logSW, s[i]]; ENDLOOP;    FOR i: CARDINAL IN [l..length) DO Put.Char[logSW, ' ]; ENDLOOP};  WriteNodeHits: PROC [node: LONG POINTER TO Node, columns: CARDINAL] = {    WriteLongNumber[node.hits, columns]; Put.Char[logSW, ' ]};  PrintLegTable: PROC = {    OPEN String;    s: STRING = [100];    pCR: PCR = GetPCR[read];    nodeTable: NodeTable = GetNodeTable[read];    legTable: LegTable = GetLegTable[read];    leg: LONG POINTER TO Leg;    Put.CR[logSW];    IF UserInput.UserAbort[logSW] THEN {      PutMessage[aborted]; Put.CR[logSW]; RETURN};    WriteLegTableHeader[];    FOR i: SubLegIndex IN SubLegIndex DO      leg ¬ @legTable[i];      IF (i < pCR.nextLeg AND leg.from # NullNode) OR leg.hits # 0 THEN {        ENABLE          BPDisappeared => {            Put.Line[logSW, "***Breakpoint has disappeared***"L]; GOTO noBP};        IF UserInput.UserAbort[logSW] THEN {          PutMessage[aborted]; Put.CR[logSW]; EXIT};        Put.Number[logSW, i + 1, ID];        Put.Char[logSW, IF leg.hist = NullHist THEN '  ELSE '*];        Put.Char[logSW, ' ];        Put.Number[logSW, NodeIDToBpNum[nodeTable[leg.from].id], ID];        Put.Text[logSW, " ->"L];        Put.Number[logSW, NodeIDToBpNum[nodeTable[leg.to].id], ID];        WriteLegHits[leg, 13];	IF leg.hits # 0 THEN  {          WriteConvertedTicksToMs[leg.sum, pCR.pulseConversion, 13];          WriteConvertedTicksToMs[leg.longest, pCR.pulseConversion, 15];          WriteConvertedTicksToMs[leg.shortest, pCR.pulseConversion, 16];          WriteTime[AverageLegTime[leg], 15];          WritePercent[leg.sum, pCR.totalTime - pCR.perfTime, 7]};        Put.CR[logSW];	EXITS noBP => NULL};      ENDLOOP;    TextSW.ForceOutput[logSW]};  AverageLegTime: PROC [leg: LONG POINTER TO Leg] RETURNS [LONG CARDINAL] = {    RETURN AverageTime[      time: leg.sum, count: leg.hits, conversion: GetPCR[read].pulseConversion]};  WriteLegHits: PROC [leg: LONG POINTER TO Leg, columns: CARDINAL] = {    WriteLongNumber[leg.hits, columns];    Put.Text[logSW, SELECT TRUE FROM leg.someIgnored => "~ "L, ENDCASE => "  "L]};  FindID: PROC [ubb: CPSwapDefs.UBBPointer] RETURNS [NodeID] = {    IsIt: PROC [bb: DebugUsefulDefsExtras.BBHandle] RETURNS [done: BOOLEAN] = {      thisCb: PrincOps.GlobalCodebase;      gfShort: PrincOpsExtras2.GFTHandle = DebugUsefulDefsExtras.GFshort[bb.gf];      DebugUsefulDefs.LongCopyREAD[        from: @PrincOpsExtras2.GFT[gfShort].codebase, to: @thisCb,	nwords: PrincOps.GlobalCodebase.SIZE];      thisCb.out ¬ FALSE;      RETURN[bb.pc = pc AND thisCb.codebase = cb]};    pc: PrincOps.BytePC = DebugUsefulDefs.LongREAD[@ubb.pc];    cb: LONG POINTER;    bb: DebugUsefulDefsExtras.BBHandle;    DebugUsefulDefs.LongCopyREAD[      from: @ubb.codeBase, to: @cb, nwords: SIZE[LONG POINTER]];    IF (bb ¬ DebugUsefulDefsExtras.EnumerateBBs[IsIt, PrincOpsExtras2.nullGFH]) = NIL THEN RETURN[NullID]    ELSE RETURN[[gfi: DebugUsefulDefsExtras.GFshort[bb.gf], pc: [bb.pc]]]};      CollectNodes: PUBLIC PROC = {    OPEN DebugUsefulDefs;    pCR: PCR = GetPCR[read];    nodeTable: NodeTable = GetNodeTable[read];    bba: CPSwapDefs.BBHandle = pCR.breakBlocks;    Put.Text[logSW, "Collecting nodes... "L];    FOR i: CARDINAL IN [0..LongREAD[@bba.length]) DO      ubb: CPSwapDefs.UBBPointer = @bba.blocks[i];      id: NodeID = FindID[ubb];      IF id # NullID AND FindIndex[id, nodeTable, pCR] = MaxNodes THEN        IF pCR.nextNode < MaxNodes THEN {          index: CARDINAL;          [] ¬ GetPCR[write];          [] ¬ GetNodeTable[write];          index ¬ pCR.nextNode;          pCR.nextNode ¬ pCR.nextNode + 1;          nodeTable[index] ¬ [id: id, hist: NullHist, hits: 0];          Put.Decimal[logSW, NodeIDToBpNum[id]];          Put.Char[logSW, ' ]}        ELSE PutMessage[tooSmall];      ENDLOOP;    Put.Line[logSW, "done."L]};  FindIndex: PROC [id: NodeID, table: NodeTable, pCR: PCR]    RETURNS [node: NodeIndex] = {    IF id = NullID THEN RETURN[NullNode];    FOR node IN [0..pCR.nextNode) DO IF table[node].id = id THEN RETURN; ENDLOOP;    RETURN[NullNode]};  FillWithSpacesAnd0Length: PROC [s: STRING] = {    FOR i: CARDINAL IN [0..s.maxlength) DO s[i] ¬ ' ; ENDLOOP;    s.length ¬ 0};  NodeIDToBpNum: PROC [id: NodeID] RETURNS [CARDINAL] = {    bb: DebugUsefulDefsExtras.BBHandle = DebugUsefulDefsExtras.FindBB[id.gfi, id.pc];    IF bb = NIL THEN ERROR BPDisappeared;    RETURN[bb.num]};  BpNumToNodeID: PROC [num: CARDINAL] RETURNS [id: NodeID] = {    bb: DebugUsefulDefsExtras.BBHandle = DebugUsefulDefsExtras.FindBBNum[num];    cb: PrincOps.GlobalCodebase;    i: CARDINAL;    gfShort: PrincOpsExtras2.GFTHandle;    IF bb = NIL THEN RETURN[NullID];    gfShort ¬ DebugUsefulDefsExtras.GFshort[bb.gf];    DebugUsefulDefs.LongCopyREAD[      from: @PrincOpsExtras2.GFT[gfShort].codebase, to: @cb,       nwords: PrincOps.GlobalCodebase.SIZE];    cb.out ¬ FALSE;    i ¬ DebugUsefulDefsExtras.FindUserBB[cb.codebase, [bb.pc]];    IF i = CARDINAL.LAST THEN RETURN[NullID];    RETURN[[[bb.pc], DebugUsefulDefsExtras.GFshort[bb.gf]]]};  END.
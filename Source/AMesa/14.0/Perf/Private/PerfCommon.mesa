-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- File: PerfCommon.mesa   last edited by-- AXD    ,	 3-Feb-83 14:31:42-- JGS    ,	13-Jan-82 15:49:26-- PXK    ,	Jun 23, 1980 3:19 PMDIRECTORY  DebugUsefulDefsExtras: TYPE USING [BBHandle, Conditionalize, EnumerateBBs, BPFail],  Inline: TYPE USING [LongCOPY],  PerfCommonOps: TYPE USING [logSW, Number],  PrincOpsExtras2: TYPE USING [nullGFH],  Put: TYPE USING [Char, Decimal, Line, Text],  String: TYPE USING [AppendChar, AppendLongNumber];PerfCommon: PROGRAM  IMPORTS DebugUsefulDefsExtras, Inline, Put, String, PerfCommonOps EXPORTS PerfCommonOps =  PUBLIC BEGIN    OPEN PerfCommonOps;  Zero: PROC [p: LONG POINTER, l: CARDINAL] = {    IF l # 0 THEN {p­ ¬ 0; Inline.LongCOPY[from: p, to: p + 1, nwords: l - 1]}};  ConditionBreaks: PROC = {    gotThemAll: BOOLEAN ¬ TRUE;    Proc: PROC [bb: DebugUsefulDefsExtras.BBHandle] RETURNS [done: BOOLEAN] = {      Put.Decimal[logSW, bb.num];      Put.Char[logSW, ' ];      DebugUsefulDefsExtras.Conditionalize[bb, "1"L];      RETURN[FALSE]};    Put.Text[logSW, "Conditioning breaks... "L];    [] ¬ DebugUsefulDefsExtras.EnumerateBBs[Proc, PrincOpsExtras2.nullGFH      ! DebugUsefulDefsExtras.BPFail => {gotThemAll ¬ FALSE; CONTINUE}];    IF gotThemAll THEN Put.Line[logSW, " done."L]    ELSE Put.Line[logSW, " failed!"L]};  AverageTime: PROC [time, count: Number, conversion: LONG CARDINAL]    RETURNS [Number] = {    PreventOverflow: LONG CARDINAL = LAST[LONG CARDINAL]/conversion;    WHILE time > PreventOverflow DO count ¬ count/4; time ¬ time/4; ENDLOOP;    time ¬ IF count = 0 THEN 0 ELSE ((time*conversion)/100)/count;    RETURN[time]};  WriteConvertedTicksToMs: PROC [    ticks: Number, conversion: LONG CARDINAL, columns: CARDINAL ¬ 0] = {    s: STRING = [24];    PreventOverflow: LONG CARDINAL = LAST[LONG CARDINAL]/conversion;    IF ticks < PreventOverflow THEN WriteTime[(ticks*conversion)/100, columns]    ELSE {      i: CARDINAL ¬ 1;      DO        ticks ¬ ticks/10;        IF ticks < PreventOverflow THEN EXIT;        i ¬ i + 1;        ENDLOOP;      String.AppendLongNumber[s, (ticks*conversion)/100, 10];      THROUGH [0..i) DO String.AppendChar[s, '0]; ENDLOOP;      WriteTimeString[s, columns]}};  MaxPercent: LONG CARDINAL = LAST[LONG CARDINAL]/10000;  WritePercent: PROC [count, total: Number, columns: CARDINAL ¬ 0] = {    s: STRING = [20];    whole: LONG INTEGER;    l: CARDINAL;    WHILE count > MaxPercent DO count ¬ count/4; total ¬ total/4; ENDLOOP;    whole ¬ IF total = 0 THEN 0 ELSE (count*10000)/total;    String.AppendLongNumber[s, whole, 10];    IF (l ¬ s.length) = 1 THEN {s[1] ¬ s[0]; s[0] ¬ '0; l ¬ 2; };    FOR i: CARDINAL IN (l..columns - 1] DO Put.Char[logSW, ' ]; ENDLOOP;    FOR i: CARDINAL IN [0..l - 2) DO Put.Char[logSW, s[i]]; ENDLOOP;    Put.Char[logSW, '.];    FOR i: CARDINAL IN [l - 2..l) DO Put.Char[logSW, s[i]]; ENDLOOP};  WriteTime: PROC [time: Number, columns: CARDINAL ¬ 0] = {    s: STRING = [20];    String.AppendLongNumber[s, time, 10];    WriteTimeString[s, columns]};  WriteTimeString: PROC [s: LONG STRING, columns: CARDINAL ¬ 0] = {    nPuncuation: CARDINAL = MIN[(s.length - 1)/3, 3];    FOR i: CARDINAL IN (s.length + nPuncuation..columns] DO      Put.Char[logSW, ' ]; ENDLOOP;    FOR i: CARDINAL IN [0..s.length) DO      Put.Char[logSW, s[i]];      SELECT s.length - i FROM        10 => Put.Char[logSW, ',];        7 => Put.Char[logSW, '.];        4 => Put.Char[logSW, ':];        ENDCASE;      ENDLOOP};  WriteLongNumber: PROC [number: Number, columns: CARDINAL ¬ 0] = {    s: STRING = [20];    nPuncuation: CARDINAL;    String.AppendLongNumber[s, number, 10];    nPuncuation ¬ MIN[(s.length - 1)/3, 3];    FOR i: CARDINAL IN (s.length + nPuncuation..columns] DO      Put.Char[logSW, ' ]; ENDLOOP;    FOR i: CARDINAL IN [0..s.length) DO      Put.Char[logSW, s[i]];      SELECT s.length - i FROM 10, 7, 4 => Put.Char[logSW, ',]; ENDCASE;      ENDLOOP};  END.
-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- File: PerfRoutines.mesa   last edited by-- AXD    	22-Aug-83 17:36:14-- JGS    	25-Jan-82  8:49:03-- PXK    	Jun 25, 1980 2:31 AMDIRECTORY  BcdDefs: TYPE USING [Base, CTIndex, MTIndex],  BcdOps: TYPE USING [BcdBase, CTHandle, MTHandle, NameString],  AMLoadstate: TYPE USING [AcquireBcd, Error, Index, MapRealToConfig, nullIndex],  DebugUsefulDefs: TYPE USING [    LongCopyREAD, LongCopyWRITE, ShortCopyREAD,    ShortCopyWRITE, ShortREAD, ShortWRITE],  DebugUsefulDefsExtras: TYPE USING [GetLoadstate, Name, Original],  Environment: TYPE USING [wordsPerPage],  Event: TYPE USING [aboutToSwap, spare2],  EventTypes,  FormSW: TYPE USING [DisplayItem, EnumeratedNotifyProcType, NotifyProcType],  MsgSW: TYPE USING [Clear, Post],  PerfCommonOps: TYPE USING [cmdSW, ConditionBreaks, herald, logSW, msgSW],  PerfOps: TYPE USING [    AddHistogram, AddLeg, addMode, ClearTables, CmdIndex, CollectNodes,    DeleteHistogram, DeleteLeg, Error, GetDeleteLeg, GetFromNode, GetToNode,    HistCIndex, histSW, ModeIndex, modeSW, monitorOn, PerfMessage,    PrintHistogram, PrintLegTable, PrintNodeTable, PrintTables, process,    SetProcess, trackMode, ZeroCounts],  PerfPrivate: TYPE USING [    HistBase, HistSpaceSize, LegTab, LegTable, NodeTab, NodeTable, PCR,    PerfControlRecord, ReadWrite, VersionID],  PrincOpsExtras2: TYPE USING [ControlLink, NullLink, GFTHandle],  Put: TYPE USING [CR, Line, Text],  SDDefs: TYPE USING [sBreakTrap, SD, sPerfMonitor],  Space: TYPE USING [ScratchMap, Unmap],  String: TYPE USING [AppendSubString, SubStringDescriptor],  Supervisor: TYPE USING [    AddDependency, AgentProcedure, CreateSubsystem, Event, SubsystemHandle],  SwordUsefulDefs,  Time: TYPE USING [Append, Current, Unpack],  UserInput: TYPE USING [UserAbort],  Window: TYPE USING [Handle];PerfRoutines: PROGRAM  IMPORTS    AMLoadstate, DebugUsefulDefs, DebugUsefulDefsExtras, Event, FormSW, MsgSW,    PerfCommonOps, PerfOps, Put, Space, String, Supervisor, Time,    UserInput, SwordUsefulDefs  EXPORTS PerfOps   SHARES SwordUsefulDefs =   PUBLIC BEGIN  OPEN PerfCommonOps, PerfOps, PerfPrivate;  perfRecord: PerfControlRecord;  pCR: PCR = @perfRecord;  nodeTab: NodeTable;  legTab: LegTable;  histBase: HistBase;  Table: TYPE = {hist, leg, node, pcr};  haveTable, dirtyTable: PACKED ARRAY Table OF BOOLEAN ¬ [    FALSE, FALSE, FALSE, FALSE];  GetWords: PROC [nwords: CARDINAL] RETURNS [LONG POINTER] = {    RETURN Space.ScratchMap[      (nwords + Environment.wordsPerPage - 1)/Environment.wordsPerPage]};    FreeWords: PROC [p: LONG POINTER] = {[] ¬ Space.Unmap[p]};    GetHistBase: PROC [mode: ReadWrite] RETURNS [HistBase] = {    OPEN DebugUsefulDefs;    IF ~haveTable[hist] THEN {      [] ¬ GetPCR[read];      histBase ¬ GetWords[HistSpaceSize];      LongCopyREAD[to: histBase, from: pCR.histBase, nwords: HistSpaceSize];      haveTable[hist] ¬ TRUE};    IF mode = write THEN dirtyTable[hist] ¬ TRUE;    RETURN[histBase]};  GetLegTable: PROC [mode: ReadWrite] RETURNS [LegTable] = {    OPEN DebugUsefulDefs;    IF ~haveTable[leg] THEN {      [] ¬ GetPCR[read];      legTab ¬ GetWords[LegTab.SIZE];      LongCopyREAD[to: legTab, from: pCR.legTable, nwords: LegTab.SIZE];      haveTable[leg] ¬ TRUE};    IF mode = write THEN dirtyTable[leg] ¬ TRUE;    RETURN[legTab]};  GetNodeTable: PROC [mode: ReadWrite] RETURNS [NodeTable] = {    OPEN DebugUsefulDefs;    IF ~haveTable[node] THEN {      [] ¬ GetPCR[read];      nodeTab ¬ GetWords[NodeTab.SIZE];      LongCopyREAD[to: nodeTab, from: pCR.nodeTable, nwords: NodeTab.SIZE];      haveTable[node] ¬ TRUE};    IF mode = write THEN dirtyTable[node] ¬ TRUE;    RETURN[nodeTab]};  GetPCR: PROC [mode: ReadWrite] RETURNS [PCR] = {    OPEN DebugUsefulDefs;    IF ~haveTable[pcr] THEN {      perf: PCR;      ShortCopyREAD[        from: @SDDefs.SD[SDDefs.sPerfMonitor], to: @perf, nwords: PCR.SIZE];      LongCopyREAD[to: pCR, from: perf, nwords: PerfControlRecord.SIZE];      haveTable[pcr] ¬ TRUE};    IF mode = write THEN dirtyTable[pcr] ¬ TRUE;    RETURN[pCR]};  TablesExist: PROC RETURNS [BOOLEAN] = {    RETURN[DebugUsefulDefs.ShortREAD[@SDDefs.SD[SDDefs.sPerfMonitor]] # NIL]};  TablesCorrectVersion: PROC RETURNS [BOOLEAN] = {    RETURN[GetPCR[read].version = VersionID]};  PutTables: PRIVATE PROC [flush: BOOLEAN] = {    OPEN DebugUsefulDefs;    perf: PCR;    LongCopyREAD[      from: @SDDefs.SD[SDDefs.sPerfMonitor], to: @perf, nwords: PCR.SIZE];    IF flush AND haveTable[pcr] AND dirtyTable[pcr] THEN      LongCopyWRITE[to: perf, from: pCR, nwords: PerfControlRecord.SIZE];    IF haveTable[node] THEN {      IF flush AND dirtyTable[node] THEN        LongCopyWRITE[to: pCR.nodeTable, from: nodeTab, nwords: NodeTab.SIZE];      FreeWords[nodeTab]};    IF haveTable[leg] THEN {      IF flush AND dirtyTable[leg] THEN        LongCopyWRITE[to: pCR.legTable, from: legTab, nwords: LegTab.SIZE];      FreeWords[legTab]};    IF haveTable[hist] THEN {      IF flush AND dirtyTable[hist] THEN        LongCopyWRITE[to: pCR.histBase, from: histBase, nwords: HistSpaceSize];      FreeWords[histBase]};    haveTable ¬ dirtyTable ¬ [FALSE, FALSE, FALSE, FALSE]};  TurnOn: PROC = {    OPEN DebugUsefulDefs, SDDefs;    [] ¬ GetPCR[write];    ShortCopyREAD[      from: @SD[sBreakTrap], to: @pCR.saveBreakHandler,      nwords: PrincOpsExtras2.ControlLink.SIZE];    ShortWRITE[@SD[sBreakTrap], pCR.self]}; -- ok to write only one word since this is a frame link  TurnOff: PROC RETURNS [BOOLEAN] = {    OPEN DebugUsefulDefs, SDDefs;    [] ¬ GetPCR[write];    IF pCR.saveBreakHandler # PrincOpsExtras2.NullLink    AND pCR.self = ShortREAD[@SD[sBreakTrap]] THEN {      ShortCopyWRITE[        to: @SD[sBreakTrap], from: @pCR.saveBreakHandler,	nwords: PrincOpsExtras2.ControlLink.SIZE];      pCR.measuringNow ¬ FALSE;      RETURN[TRUE]};    RETURN[FALSE]};  NoContext: SIGNAL = CODE;  GetConfigAndModuleName: PROC [    frame: PrincOpsExtras2.GFTHandle, config, module: LONG STRING] = {    bcd: BcdOps.BcdBase;    c: AMLoadstate.Index ¬ AMLoadstate.nullIndex;    cgfi: NATURAL;    ssb: BcdOps.NameString;    ss: String.SubStringDescriptor;    DebugUsefulDefsExtras.Name[module, frame ! AMLoadstate.Error => SIGNAL NoContext];    frame ¬ DebugUsefulDefsExtras.Original[frame];    [cgfi: cgfi, index: c] ¬ AMLoadstate.MapRealToConfig[      DebugUsefulDefsExtras.GetLoadstate[],      LOOPHOLE[frame] ! AMLoadstate.Error => SIGNAL NoContext];    IF c # AMLoadstate.nullIndex THEN {      OPEN BcdDefs;      bcd ¬ AMLoadstate.AcquireBcd[DebugUsefulDefsExtras.GetLoadstate[], c];      ssb ¬ LOOPHOLE[bcd + bcd.ssOffset];      config.length ¬ 0;      IF bcd.nConfigs # 0 THEN {        cth: BcdOps.CTHandle =	  @LOOPHOLE[bcd + bcd.ctOffset, Base][BcdDefs.CTIndex.FIRST];        ss ¬ [base: @ssb.string, offset: cth.name, length: ssb.size[cth.name]]}      ELSE {        mth: BcdOps.MTHandle =	  @LOOPHOLE[bcd + bcd.mtOffset, Base][BcdDefs.MTIndex.FIRST];        ss ¬ [base: @ssb.string, offset: mth.name, length: ssb.size[mth.name]]};      String.AppendSubString[config, @ss]}    ELSE SIGNAL NoContext};  PostError: PROC [error: Error] = {    MsgSW.Post[      PerfCommonOps.msgSW,      SELECT error FROM        notOn => "!Please Start PerfMonitor and then try again"L,        goofUp =>          "!Goofed up PerfMonitor by use of Worry on/off during measurements"L,        syntaxError => "!Syntax Error in Input"L,        badLeg => "!Bad Leg Index Specified"L,        badChar => "!Illegal Character"L,        noLegRoom => "!No More Room in Leg Table"L,        badNode => "!Bad Node Index Specified"L,        version => "!PerfTool has Incorrect Version"L,        noContext => "!No Context"L,        badProcess => "!Invalid Process specified"L,        ENDCASE => "?"L]};  PutMessage: PROC [message: PerfMessage] = {    Put.Text[      logSW,      SELECT message FROM        totalTime => "Total Elapsed Time of Measurements =     "L,        elapsedTime => "Elapsed Time less PerfMonitor Overhead = "L,        totalOverhead => "Total Overhead of PerfMonitor Breaks =   "L,        nBreaks => "Total number of Perf Breaks handled =    "L,        avgOverhead => "Average Overhead per Perf Break =        "L,        percentInMont => "% of Total Time spent in PerfMonitor =   "L,        tooSmall => "Too many breakpoints!"L,        aborted => "... aborted"L,        ENDCASE => "?"L];    IF message = aborted OR message = tooSmall THEN Put.CR[logSW]};  WriteNodeTableHeader: PROC = {    Put.Line[      logSW,      " - - - - - - N O D E   T A B L E   C O N T E N T S - - - - - - - - - -"L];    IF UserInput.UserAbort[logSW] THEN RETURN;    Put.Line[logSW, "Node Global  Program  Number of  Config           Module"L];    IF UserInput.UserAbort[logSW] THEN RETURN;    Put.Line[logSW, " Id  Frame   Counter  References Name             Name"L];    IF UserInput.UserAbort[logSW] THEN RETURN;    Put.Line[      logSW,      "---- ------  -------  ---------- ---------------- ------------------------"L]};  WriteLegTableHeader: PROC = {    Put.Line[      logSW,      " - - - - - - - L E G    T A B L E    C O N T E N T S - - - - - - - - -"L];    IF UserInput.UserAbort[logSW] THEN RETURN;    Put.Line[      logSW,      "Leg  From  To    # of Times  Total Time     Longest Time    Shortest Time  Average Time    % of"L];    IF UserInput.UserAbort[logSW] THEN RETURN;    Put.Line[      logSW,      " Id  Node  Node  Referenced  sec.msec:usec  sec.msec:usec   sec.msec:usec  sec.msec:usec   Time"L];    IF UserInput.UserAbort[logSW] THEN RETURN;    Put.Line[      logSW,      "---  ----  ----  ----------  -------------  -------------   -------------  -------------   ----"L]};  PutHerald: PROC = {    OPEN Time;    s: STRING = [22];    Put.Line[logSW, PerfCommonOps.herald];    Append[s, Unpack[Current[]]];    s.length ¬ s.length - 3;    Put.Line[logSW, s];    Put.CR[logSW]};  SetDefaults: PROC [sw: Window.Handle, index: CARDINAL] = {    pcr: PCR = GetPCR[write];    IF sw # PerfCommonOps.cmdSW OR VAL[index] # CmdIndex.mon THEN {      monitorOn ¬ FALSE;      FormSW.DisplayItem[PerfCommonOps.cmdSW, CmdIndex.mon.ORD]};    IF sw # PerfOps.modeSW OR VAL[index] # ModeIndex.track THEN {      trackMode ¬ pcr.trackLeg ¬ all;      FormSW.DisplayItem[PerfOps.modeSW, ModeIndex.track.ORD]};    IF sw # PerfOps.modeSW OR VAL[index] # ModeIndex.add THEN {      addMode ¬ pcr.addLeg ¬ none;      FormSW.DisplayItem[PerfOps.modeSW, ModeIndex.add.ORD]};    IF sw # PerfOps.modeSW OR VAL[index] # ModeIndex.setProcess THEN {      IF process # NIL THEN process.length ¬ 0;      FormSW.DisplayItem[PerfOps.modeSW, ModeIndex.process.ORD]};    pcr.newSession ¬ FALSE;    PutHerald[]};  ParamNotify: FormSW.NotifyProcType = {    MsgSW.Clear[PerfCommonOps.msgSW];    IF ~TablesExist[] THEN GOTO noTables;    IF ~TablesCorrectVersion[] THEN GOTO badVersion;    [] ¬ GetPCR[read];    IF pCR.newSession THEN SetDefaults[sw, index];    SELECT sw FROM      PerfCommonOps.cmdSW => {        ci: CmdIndex = VAL[index];        SELECT ci FROM          mon =>            IF monitorOn THEN TurnOn[] ELSE IF ~TurnOff[] THEN PostError[goofUp];          collect => CollectNodes[];          init => ClearTables[];          zero => ZeroCounts[];          condition => PerfCommonOps.ConditionBreaks[];          printtables => PrintTables[];          printnodes => PrintNodeTable[];          printlegs => PrintLegTable[];          addleg => AddLeg[from: GetFromNode[], to: GetToNode[]];          delete => DeleteLeg[index: GetDeleteLeg[]];          ENDCASE};      PerfOps.modeSW => {        mi: ModeIndex = VAL[index];        SELECT mi FROM          setProcess => SetProcess[];          add => GetPCR[write].addLeg ¬ addMode;          track => GetPCR[write].trackLeg ¬ trackMode;          ENDCASE};      PerfOps.histSW => {        hi: HistCIndex = VAL[index];        SELECT hi FROM          addhist => AddHistogram[];          delhist => DeleteHistogram[];          printhist => PrintHistogram[];          ENDCASE};      ENDCASE;    EXITS noTables => PostError[notOn]; badVersion => PostError[version]};  ParamEnumNotify: FormSW.EnumeratedNotifyProcType = {    ParamNotify[sw, item, index]};  Cleanup: Supervisor.AgentProcedure = {    fake: LONG POINTER TO Supervisor.Event = eventData;    SELECT event FROM      EventTypes.aboutToResume => PutTables[TRUE];      EventTypes.spare2 => PutTables[fake # NIL AND fake­ = EventTypes.aboutToResume];      EventTypes.aboutToBoot,       EventTypes.aboutToAbortSession,       EventTypes.aboutToBootPhysicalVolume => PutTables[FALSE];      ENDCASE => NULL };  -- Mainline code  agent: Supervisor.SubsystemHandle = Supervisor.CreateSubsystem[Cleanup];  sameWorld: Supervisor.SubsystemHandle = Supervisor.CreateSubsystem[SameWorld];    SameWorld: Supervisor.AgentProcedure = {    IF SwordUsefulDefs.defaultWorld # SwordUsefulDefs.localWorld       AND SwordUsefulDefs.defaultWorld # NIL THEN RETURN;    Cleanup[event, eventData, instanceData]; };  --Supervisor.AddDependency[client: agent, implementor: Event.swapping];  Supervisor.AddDependency[client: agent, implementor: Event.aboutToSwap];  Supervisor.AddDependency[client: sameWorld, implementor: Event.spare2];  END.
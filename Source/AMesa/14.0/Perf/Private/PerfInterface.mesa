-- Copyright (C) 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- PerfInterface.mesa, last edited by-- AXD    	 3-Feb-83 13:59:30-- JGS    	22-Jan-82  8:35:18-- PXK    	June 25, 1980  2:05 AM-- DXG    	22-May-84 17:56:10DIRECTORY  Atom: TYPE USING [ATOM, MakeAtom],  CmFile: TYPE USING [Error, UserDotCmLine],  FormSW: TYPE USING [    AllocateItemDescriptor, ClientItemsProcType, CommandItem, Create, Enumerated,    EnumeratedItem, GetTypeIn, line0, line1, line2, line3, line4, NeededHeight,    SetCurrent, StringItem, TagOnlyItem],  Heap: TYPE USING [systemZone],  Menu: TYPE USING [Free, Handle, Instantiate, Make, MCRType, Uninstantiate],  PerfCommonOps: TYPE USING [],  PerfOps: TYPE USING [    BpNumToNodeID, CmdIndex, CmdItems, FindIndex, GetNodeTable, GetPCR,    HistCIndex, HistItems, ModeIndex, ModeItems, ParamEnumNotify, ParamNotify],  PerfPrivate: TYPE USING [    AllNodes, HistClass, HistType, LegAddClass, LegIndex, LegTrackClass,    NodeIndex, NoLegSlot, NullNode],  Runtime: TYPE USING [GetBcdTime],  Selection: TYPE USING [Action, ActOn],  String: TYPE USING [    AppendString, InvalidNumber, StringToDecimal, StringToLongNumber],  Time: TYPE USING [Append, Unpack],  TIP: TYPE USING [First, NotifyProc, Results, Rest, SetNotifyProc],  Tool: TYPE USING [    AddThisSW, Create, MakeFileSW, MakeFormSW, MakeMsgSW, MakeSWsProc, SwapSWs,    UnusedLogName],  ToolWindow: TYPE USING [CreateSubwindow, Destroy, TransitionProcType],  Version: TYPE USING [Append],  Window: TYPE USING [Box, GetBox, Handle, SlideAndSize],  WindowFont: TYPE USING [CharWidth];PerfInterface: PROGRAM  IMPORTS    Atom, CmFile, FormSW, Heap, Menu, Runtime, PerfOps, Selection, String, Time,    TIP, Tool, ToolWindow, Version, Window, WindowFont  EXPORTS PerfOps, PerfCommonOps =     PUBLIC    BEGIN OPEN PerfOps, PerfPrivate;  logSW: Window.Handle ¬ NIL;  msgSW: Window.Handle ¬ NIL;  cmdSW: Window.Handle ¬ NIL;  modeSW, histSW: Window.Handle ¬ NIL;  toolWindow: Window.Handle ¬ NIL;  loopOnNext: BOOLEAN ¬ FALSE;    ShowingWindow: TYPE = {mode, hist};  showingWindow: ShowingWindow ¬ mode;  showMenu: Menu.Handle ¬ NIL;  herald: LONG STRING ¬ [60];  Init: PROC = {    title: STRING = "Performance Tool "L;    line: LONG STRING ¬ NIL;    doit ¬ Atom.MakeAtom["DoIt"L];    findNextField ¬ Atom.MakeAtom["FindNextField"L];    replaceNextField ¬ Atom.MakeAtom["ReplaceNextField"L];    String.AppendString[herald, title];    Version.Append[herald];    String.AppendString[herald, " of "L];    Time.Append[herald, Time.Unpack[Runtime.GetBcdTime[]]];    herald.length ¬ herald.length - 3;    toolWindow ¬ Tool.Create[      name: herald, makeSWsProc: MakeSWs, clientTransition: Transition,      cmSection: "PerfTool"L];    line ¬ CmFile.UserDotCmLine[      title: "PerfTool"L, name: "LoopOnNext"L ! CmFile.Error => CONTINUE];    IF line # NIL THEN {      i: NAT;      FOR i ¬ 0, i + 1 UNTIL i >= line.length DO        SELECT line[i] FROM	  ' , '\t => LOOP;	  '\n, '\f, '\l => GOTO Out;	  ENDCASE => EXIT;	REPEAT FINISHED => GOTO Out	ENDLOOP;      SELECT line[i] FROM        'y, 'Y, 't, 'T => loopOnNext ¬ TRUE;	ENDCASE;      GOTO Out;      EXITS Out => Heap.systemZone.FREE[@line]}};  hisNotify: TIP.NotifyProc ¬ NIL;    doit, findNextField, replaceNextField: Atom.ATOM;    TIPMe: TIP.NotifyProc = {    IF results = NIL THEN RETURN;    WITH z: results.First SELECT FROM      atom => IF z.a = doit THEN {        ParamNotify[sw: cmdSW, index: CmdIndex.addleg.ORD];	results ¬ results.Rest};      coords => {        r: TIP.Results = results.Rest;	IF r # NIL THEN {	  WITH z: r.First SELECT FROM	    atom => SELECT z.a FROM	      findNextField, replaceNextField => 	        IF loopOnNext AND VAL[FormSW.GetTypeIn[cmdSW].index] = CmdIndex.to		  THEN {		    FormSW.SetCurrent[sw: cmdSW, index: CmdIndex.from.ORD];		    IF z.a = replaceNextField THEN Selection.ActOn[delete];		    results ¬ r.Rest};	      ENDCASE;	    ENDCASE}};       ENDCASE;     hisNotify[window, results]};      MakeSWs: Tool.MakeSWsProc = {    log: STRING = [50];    menuStrings: ARRAY ShowingWindow OF LONG STRING ¬ [      mode: "Mode"L, hist: "Histogram"L];    height: INTEGER;    box: Window.Box;    showMenu ¬ Menu.Make[      name: "Commands"L, mcrProc: SwapWindows,      strings: DESCRIPTOR[menuStrings.BASE, menuStrings.LENGTH]];    Tool.UnusedLogName[unused: log, root: "Perf.log"L];    showingWindow ¬ mode;    msgSW ¬ Tool.MakeMsgSW[window: window, lines: 1];    cmdSW ¬ Tool.MakeFormSW[window: window, formProc: MakeCmdForm];    hisNotify ¬ TIP.SetNotifyProc[window: cmdSW, notify: TIPMe];    modeSW ¬ ToolWindow.CreateSubwindow[parent: window];    FormSW.Create[sw: modeSW, clientItemsProc: MakeModeForm];    Tool.AddThisSW[window: window, sw: modeSW, swType: predefined];    histSW ¬ ToolWindow.CreateSubwindow[parent: NIL];    FormSW.Create[sw: histSW, clientItemsProc: MakeHistForm];    height ¬ MAX[      FormSW.NeededHeight[modeSW].min, FormSW.NeededHeight[histSW].min];    box ¬ modeSW.GetBox;    modeSW.SlideAndSize[[box.place, [box.dims.w, height]]];    box ¬ histSW.GetBox;    histSW.SlideAndSize[[box.place, [box.dims.w, height]]];    logSW ¬ Tool.MakeFileSW[window: window, name: log];    showMenu.Instantiate[window]};  monitorOn: BOOLEAN ¬ FALSE;  fromNode: LONG STRING ¬ NIL;  toNode: LONG STRING ¬ NIL;  deleteLeg: LONG STRING ¬ NIL;  process: LONG STRING ¬ NIL;  histNode: LONG STRING ¬ NIL;  histLeg: LONG STRING ¬ NIL;  buckets: LONG STRING ¬ NIL;  scale: LONG STRING ¬ NIL;  base: LONG STRING ¬ NIL;  addMode: LegAddClass ¬ none;  trackMode: LegTrackClass ¬ all;  histClass: HistClass ¬ HistClass.FIRST;  histType: HistType ¬ HistType.FIRST;  -- 0         1         2         3         4         5         6         7  -- 01234567890123456789012345678901234567890123456789012345678901234567890  --                        Common Commands  -- Monitor: {off, on}  Condition Breaks!     Collect Nodes!  -- Add Leg!  From:     To:             Delete Leg!  Leg:  -- Print Tables!       Print Legs!           Print Nodes!  -- Zero Tables!        Reinitialize Tables!  MakeCmdForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    w: NAT = WindowFont.CharWidth['0];    monitorEnumRec: ARRAY BOOLEAN OF Enumerated ¬ [      [string: "off"L, value: FALSE], [string: "on"L, value: TRUE]];    nParams: CARDINAL = CmdIndex.LAST.ORD + 1;    params: CmdItems ¬ LOOPHOLE[AllocateItemDescriptor[nParams]];    params[title] ¬ TagOnlyItem[      tag: "Common Commands"L, place: [23*w, line0], drawBox: TRUE];    params[mon] ¬ EnumeratedItem[      tag: "Monitor"L, place: [0*w, line1], feedback: all,      choices: DESCRIPTOR[monitorEnumRec.BASE, monitorEnumRec.LENGTH],      proc: ParamEnumNotify, value: @monitorOn];    params[condition] ¬ CommandItem[      tag: "Condition Breaks"L, place: [20*w, line1], proc: ParamNotify];    params[collect] ¬ CommandItem[      tag: "Collect Nodes"L, place: [42*w, line1], proc: ParamNotify];    params[addleg] ¬ CommandItem[      tag: "Add Leg"L, place: [0*w, line2], proc: ParamNotify];    params[from] ¬ StringItem[      tag: "From"L, place: [10*w, line2], string: @fromNode, inHeap: TRUE];    params[to] ¬ StringItem[      tag: "To"L, place: [20*w, line2], string: @toNode, inHeap: TRUE];    params[delete] ¬ CommandItem[      tag: "Delete Leg"L, place: [36*w, line2], proc: ParamNotify];    params[leg] ¬ StringItem[      tag: "Leg"L, place: [49*w, line2], string: @deleteLeg, inHeap: TRUE];    params[printtables] ¬ CommandItem[      tag: "Print Tables"L, place: [0*w, line3], proc: ParamNotify];    params[printnodes] ¬ CommandItem[      tag: "Print Nodes"L, place: [20*w, line3], proc: ParamNotify];    params[printlegs] ¬ CommandItem[      tag: "Print Legs"L, place: [42*w, line3], proc: ParamNotify];    params[zero] ¬ CommandItem[      tag: "Zero Tables"L, place: [0*w, line4], proc: ParamNotify];    params[init] ¬ CommandItem[      tag: "Reinitialize Tables"L, place: [20*w, line4], proc: ParamNotify];    RETURN[LOOPHOLE[params], TRUE]};  -- 0         1         2         3         4         5         6         7  -- 01234567890123456789012345678901234567890123456789012345678901234567890  --                       Histogram Commands  -- Add!    Delete!    Print!   Type: {node, leg}   Class: {linear, log}  -- Histogram Node:               Histogram Leg:  -- Buckets:           Scale:               Base:  MakeHistForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    w: NAT = WindowFont.CharWidth['0];    histClassEnumRec: ARRAY HistClass OF Enumerated ¬ [      [string: "linear"L, value: HistClass[linear]], [      string: "log"L, value: HistClass[log]]];    histTypeEnumRec: ARRAY HistType OF Enumerated ¬ [      [string: "node"L, value: HistType[node]], [      string: "leg"L, value: HistType[leg]]];    nParams: CARDINAL = HistCIndex.LAST.ORD + 1;    params: HistItems ¬ LOOPHOLE[AllocateItemDescriptor[nParams]];    params[histcommands] ¬ TagOnlyItem[      tag: "Histogram Commands"L, place: [22*w, line0], drawBox: TRUE];    params[addhist] ¬ CommandItem[      tag: "Add"L, place: [0*w, line1], proc: ParamNotify];    params[delhist] ¬ CommandItem[      tag: "Delete"L, place: [8*w, line1], proc: ParamNotify];    params[printhist] ¬ CommandItem[      tag: "Print"L, place: [19*w, line1], proc: ParamNotify];    params[histType] ¬ EnumeratedItem[      tag: "Type"L, place: [28*w, line1], feedback: all, value: @histType,      choices: DESCRIPTOR[histTypeEnumRec.BASE, histTypeEnumRec.LENGTH]];    params[histClass] ¬ EnumeratedItem[      tag: "Class"L, place: [48*w, line1], feedback: all, value: @histClass,      choices: DESCRIPTOR[histClassEnumRec.BASE, histClassEnumRec.LENGTH]];    params[histNode] ¬ StringItem[      tag: "Histogram Node"L, place: [0*w, line2], string: @histNode,      inHeap: TRUE];    params[histLeg] ¬ StringItem[      tag: "Histogram Leg"L, place: [30*w, line2], string: @histLeg,      inHeap: TRUE];    params[buckets] ¬ StringItem[      tag: "Buckets"L, place: [0*w, line3], string: @buckets, inHeap: TRUE];    params[scale] ¬ StringItem[      tag: "Scale"L, place: [19*w, line3], string: @scale, inHeap: TRUE];    params[base] ¬ StringItem[      tag: "Base"L, place: [40*w, line3], string: @base, inHeap: TRUE];    RETURN[LOOPHOLE[params], TRUE]};  -- 0         1         2         3         4         5         6         7  -- 01234567890123456789012345678901234567890123456789012345678901234567890  --                         Mode Commands  -- Add: {none, successor}        Track: {none, successor, all}  -- Set Process!        Process:  MakeModeForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    w: NAT = WindowFont.CharWidth['0];    addEnumRec: ARRAY LegAddClass OF Enumerated ¬ [      [string: "none"L, value: LegAddClass[none]], [      string: "successor"L, value: LegAddClass[successor]]];    trackEnumRec: ARRAY LegTrackClass OF Enumerated ¬ [      [string: "none"L, value: LegTrackClass[none]], [      string: "successor"L, value: LegTrackClass[successor]], [      string: "all"L, value: LegTrackClass[all]]];    nParams: CARDINAL = ORD[LAST[ModeIndex]] + 1;    params: ModeItems ¬ LOOPHOLE[AllocateItemDescriptor[nParams]];    params[mode] ¬ TagOnlyItem[      tag: "Mode Commands"L, place: [24*w, line0], drawBox: TRUE];    params[add] ¬ EnumeratedItem[      tag: "Add"L, place: [0*w, line1], feedback: all,      choices: DESCRIPTOR[addEnumRec.BASE, addEnumRec.LENGTH],      proc: ParamEnumNotify, value: @addMode];    params[track] ¬ EnumeratedItem[      tag: "Track"L, place: [30*w, line1], feedback: all, value: @trackMode,      choices: DESCRIPTOR[trackEnumRec.BASE, trackEnumRec.LENGTH],      proc: ParamEnumNotify];    params[setProcess] ¬ CommandItem[      tag: "Set Process"L, place: [0*w, line2], proc: ParamNotify];    params[process] ¬ StringItem[      tag: "Process"L, place: [20*w, line2], string: @process, inHeap: TRUE];    RETURN[LOOPHOLE[params], TRUE]};  SwapWindows: Menu.MCRType = {    ix: ShowingWindow = VAL[index];    SELECT ix FROM      mode =>        IF showingWindow # mode THEN {          [] ¬ Tool.SwapSWs[            window: toolWindow,            oldSW: (SELECT showingWindow FROM hist => histSW, ENDCASE => ERROR),            newSW: modeSW];          showingWindow ¬ mode};      hist =>        IF showingWindow # hist THEN {          [] ¬ Tool.SwapSWs[            window: toolWindow,            oldSW: (SELECT showingWindow FROM mode => modeSW, ENDCASE => ERROR),            newSW: histSW];          showingWindow ¬ hist};      ENDCASE};  Transition: ToolWindow.TransitionProcType = {    IF new = inactive THEN {      ToolWindow.Destroy[        SELECT showingWindow FROM          mode => histSW,          hist => modeSW,          ENDCASE => ERROR];      showMenu.Uninstantiate[toolWindow];      showMenu.Free;      showMenu ¬ NIL}};  GetFromNode: PROC RETURNS [node: NodeIndex] = {RETURN GetNode[fromNode]};  GetToNode: PROC RETURNS [node: NodeIndex] = {RETURN GetNode[toNode]};  GetNode: PROC [s: LONG STRING] RETURNS [node: NodeIndex] = {    OPEN String;    bpNum: CARDINAL ¬ 0;    node ¬ NullNode;    IF s = NIL THEN RETURN;    bpNum ¬ StringToDecimal[      s !      InvalidNumber => {        node ¬          IF toNode.length = 1 AND toNode[0] = '* THEN AllNodes ELSE NullNode;        CONTINUE}];    IF bpNum = 0 THEN RETURN;    node ¬ FindIndex[BpNumToNodeID[bpNum], GetNodeTable[read], GetPCR[read]]};  GetDeleteLeg: PROC RETURNS [leg: LegIndex] = {    IF deleteLeg = NIL THEN RETURN[NoLegSlot];    leg ¬      String.StringToDecimal[        deleteLeg ! String.InvalidNumber => {leg ¬ NoLegSlot; CONTINUE}] - 1};  GetHistNode: PROC RETURNS [node: NodeIndex] = {    node ¬ GetNode[histNode]; IF node = AllNodes THEN node ¬ NullNode};  GetHistLeg: PROC RETURNS [leg: LegIndex] = {    IF histLeg = NIL THEN RETURN[NoLegSlot];    leg ¬ String.StringToDecimal[      histLeg ! String.InvalidNumber => {leg ¬ NoLegSlot; CONTINUE}] - 1};  GetBuckets: PROC RETURNS [nBuckets: CARDINAL] = {    IF buckets = NIL THEN RETURN[0];    nBuckets ¬ String.StringToDecimal[      buckets ! String.InvalidNumber => {nBuckets ¬ 0; CONTINUE}]};  GetScale: PROC RETURNS [s: CARDINAL] = {    IF scale = NIL THEN RETURN[0];    s ¬ String.StringToDecimal[      scale ! String.InvalidNumber => {s ¬ 0; CONTINUE}]};  GetBase: PROC RETURNS [b: LONG CARDINAL] = {    IF base = NIL THEN RETURN[0];    b ¬ String.StringToLongNumber[      base, 10 ! String.InvalidNumber => {b ¬ 0; CONTINUE}]};  -- Mainline code  Init[];  END.
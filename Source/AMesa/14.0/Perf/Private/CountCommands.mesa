-- Copyright (C) 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- File: CountCommands.mesa, last edited by-- AXD    	22-Aug-83 17:38:15-- JGS    	20-Jan-82 11:08:08-- DXG    	 4-Jun-84 17:59:23DIRECTORY  Ascii: TYPE USING [CR, SP],  CountDefs: TYPE USING [CmdIndex, mode, module, monitorOn, process, sortClass],  CountPrivate: TYPE USING [    ControlRecord, GFRec, GroupIndex, MaxGroup, Mode, Table, TableHandle,    VersionID],  DebugUsefulDefs: TYPE USING [    LongCopyREAD, LongCopyWRITE, LongREAD, LongWRITE,    NotFound, ShortCopyREAD, ShortCopyWRITE, ShortREAD, ShortWRITE],  DebugUsefulDefsExtras: TYPE USING [Valid, Enumerate, Frame, Name, GFlong],  Environment: TYPE USING [wordsPerPage],  Event: TYPE USING [aboutToSwap, swapping, spare2],  EventTypes: TYPE USING [    abortSession, aboutToResume, newSession, spare2, spare3],  Format: TYPE USING [NumberFormat],  FormSW: TYPE USING [DisplayItem, EnumeratedNotifyProcType, NotifyProcType],  GFHash: TYPE USING [Fetch, GFTHandle, Insert, Pairs, Table],  GFHashDebug: TYPE USING [Acquire, Release],  Heap: TYPE USING [systemZone],  MsgSW: TYPE USING [Clear, Post],  MStream: TYPE USING [Error, Handle, ReadOnly],  PerfCommonOps: TYPE USING [    cmdSW, ConditionBreaks, herald, logSW, msgSW, Number, WriteConvertedTicksToMs,    WriteLongNumber, WritePercent, Zero],  PerfStructures: TYPE USING [IndexToHandle, NullPsbHandle, PsbIndex],  PrincOpsExtras2: TYPE USING [ControlLink, LongGlobalFrameHandle, GFTHandle, GlobalWord,    globalWordOffset, NullLink, nullGFH],  Put: TYPE USING [Blanks, Char, CR, Decimal, Line, Number, Text],  SDDefs: TYPE USING [sBreakTrap, SD, sXferTrapMonitor],  Selection: TYPE USING [Convert, Number],  Space: TYPE USING [ScratchMap, Unmap],  Stream: TYPE USING [Delete, EndOfStream, GetChar, Handle],  String: TYPE USING [    AppendChar, AppendOctal, AppendString, InvalidNumber, StringToNumber],  Supervisor: TYPE USING [    AddDependency, AgentProcedure, CreateSubsystem, Event, SubsystemHandle],  SwordUsefulDefs,  TextSW: TYPE USING [ForceOutput],  Time: TYPE USING [Append, Current, Unpack],  UserInput: TYPE USING [UserAbort];CountCommands: PROGRAM  IMPORTS    CountDefs, DebugUsefulDefs, DebugUsefulDefsExtras,     Event, FormSW, GFHash, GFHashDebug, Heap, MsgSW,    PerfCommonOps, Put, Selection, Space, Stream, String, TextSW,    Time, UserInput, PerfStructures, MStream, Supervisor, SwordUsefulDefs  EXPORTS CountDefs   SHARES SwordUsefulDefs =  PUBLIC  BEGIN OPEN CountDefs, CountPrivate, PerfCommonOps;  GFHandle: TYPE = PrincOpsExtras2.GFTHandle;  GFData: TYPE = LONG POINTER TO GFRec;    cr: ControlRecord;  counts, times: TableHandle;  ht: PRIVATE GFHash.Table;  counterOn: BOOLEAN ¬ FALSE;  haveTable, dirtyTable: PACKED ARRAY {counts, times, cr, ht} OF BOOLEAN ¬    [FALSE, FALSE, FALSE, FALSE];  GetWords: PRIVATE PROC [nwords: CARDINAL] RETURNS [LONG POINTER] = {    RETURN Space.ScratchMap[      (nwords + Environment.wordsPerPage - 1)/Environment.wordsPerPage]};  FreeWords: PROC [p: LONG POINTER] = {[] ¬ Space.Unmap[p]};    GetCounts: PROC [mode: {read, write}] RETURNS [TableHandle] = {    OPEN DebugUsefulDefs;    IF ~haveTable[counts] THEN {      length: CARDINAL;      [] ¬ GetCR[read];      length ¬ MAX[Table.plain[cr.limit].SIZE, Table.matrix.SIZE];      counts ¬ GetWords[length];      LongCopyREAD[to: counts, from: cr.counts, nwords: length];      haveTable[counts] ¬ TRUE};    dirtyTable[counts] ¬ dirtyTable[counts] OR mode = write;    RETURN[counts]};  GetTimes: PROC [mode: {read, write}] RETURNS [TableHandle] = {    OPEN DebugUsefulDefs;    IF ~haveTable[times] THEN {      length: CARDINAL;      [] ¬ GetCR[read];      length ¬ MAX[Table.plain[cr.limit].SIZE, Table.matrix.SIZE];      times ¬ GetWords[length];      LongCopyREAD[to: times, from: cr.times, nwords: length];      haveTable[times] ¬ TRUE};    dirtyTable[times] ¬ dirtyTable[times] OR mode = write;    RETURN[times]};  GetCR: PROC [mode: {read, write}] RETURNS [LONG POINTER TO ControlRecord] = {    OPEN DebugUsefulDefs;    IF ~haveTable[cr] THEN {      rec: LONG POINTER TO ControlRecord;      ShortCopyREAD[to: @rec, from: @SDDefs.SD[SDDefs.sXferTrapMonitor], nwords: SIZE[LONG POINTER]];      LongCopyREAD[to: @cr, from: rec, nwords: ControlRecord.SIZE];      haveTable[cr] ¬ TRUE};    dirtyTable[cr] ¬ dirtyTable[cr] OR mode = write;    RETURN[@cr]};  GetHT: PROC [mode: {read, write}] RETURNS [GFHash.Table] = {    OPEN DebugUsefulDefs;    IF ~haveTable[ht] THEN {      ht ¬ GFHashDebug.Acquire[GetCR[read].ht];      haveTable[ht] ¬ TRUE};    dirtyTable[ht] ¬ dirtyTable[ht] OR mode = write;    RETURN[ht]};  TablesExist: PROC RETURNS [BOOLEAN] = {    rec: LONG POINTER TO ControlRecord;    DebugUsefulDefs.ShortCopyREAD[to: @rec, from: @SDDefs.SD[SDDefs.sXferTrapMonitor], nwords: SIZE[LONG POINTER]];    RETURN[rec # NIL]};  TablesCorrectVersion: PROC RETURNS [BOOLEAN] = {    RETURN[GetCR[read].version = VersionID]};  PutTables: PUBLIC PROC [flush: BOOLEAN] = {    OPEN DebugUsefulDefs;    length: CARDINAL = MAX[Table.plain[cr.limit].SIZE, Table.matrix.SIZE];    IF flush AND haveTable[cr] AND dirtyTable[cr] THEN {      rec: LONG POINTER TO ControlRecord;      ShortCopyREAD[to: @rec, from: @SDDefs.SD[SDDefs.sXferTrapMonitor], nwords: SIZE[LONG POINTER]];      LongCopyWRITE[to: rec, from: @cr, nwords: ControlRecord.SIZE]};    IF haveTable[counts] THEN {      IF flush AND dirtyTable[counts] THEN	LongCopyWRITE[from: counts, to: cr.counts, nwords: length];      FreeWords[counts]};    IF haveTable[times] THEN {      IF flush AND dirtyTable[times] THEN	LongCopyWRITE[from: times, to: cr.times, nwords: length];      FreeWords[times]};    IF haveTable[ht] THEN GFHashDebug.Release[ht, flush AND dirtyTable[ht]];    haveTable ¬ dirtyTable ¬ [FALSE, FALSE, FALSE, FALSE]};  TurnOn: PROC = {    OPEN SDDefs;    DebugUsefulDefs.ShortCopyREAD[from: @SD[sBreakTrap], to: @cr.saveBreakHandler, nwords: PrincOpsExtras2.ControlLink.SIZE];    DebugUsefulDefs.ShortWRITE[@SD[sBreakTrap], cr.self]};  TurnOff: PROC RETURNS [BOOLEAN] = {    -- this procedure turns off the measurements    OPEN SDDefs;    IF cr.saveBreakHandler # PrincOpsExtras2.NullLink      AND cr.self = DebugUsefulDefs.ShortREAD[@SD[sBreakTrap]] THEN {      DebugUsefulDefs.ShortCopyWRITE[        to: @SD[sBreakTrap], from: @cr.saveBreakHandler,	nwords: PrincOpsExtras2.ControlLink.SIZE];      RETURN[TRUE]}    ELSE RETURN[FALSE]};  ZeroCounts: PROC = {    length: CARDINAL =       MAX[Table.plain[GetCR[read].limit].SIZE, Table.matrix.SIZE];    table: TableHandle ¬ GetCounts[write];    PerfCommonOps.Zero[table, length];    table ¬ GetTimes[write];    PerfCommonOps.Zero[table, length];    GetCR[write].gf ¬ NIL;    Put.CR[logSW];    Put.Line[logSW, "Tables zeroed"L];    GetCR[write].newMeasurement ¬ TRUE};  SetProcess: PROC = {    OPEN PerfStructures;    pCR: LONG POINTER TO ControlRecord = GetCR[write];    index: PsbIndex;    IF process = NIL OR process.length = 0 THEN {      pCR.process ¬ NullPsbHandle; Put.Line[logSW, "All processes now tracked"L]}    ELSE {      index ¬ String.StringToNumber[	process, 8 ! String.InvalidNumber => GOTO badProcess];      Put.Text[logSW, "Track process: "L];      Put.Line[logSW, process];      pCR.process ¬ IndexToHandle[index];      EXITS badProcess => PostError[badProcess]}};  PrintTables: PROC = {    sort: Sorting = GetSorting[];    PrintSorted[sort ! UNWIND => ReleaseSorting[sort]];    ReleaseSorting[sort]};  DisplaySorted: PROC = {    sort: Sorting;    IF mode = matrix THEN {PostError[badMode]; RETURN};    sort ¬ GetSorting[];    SortTable[      table: IF sortClass = count THEN GetCounts[read] ELSE GetTimes[read],      sorting: sort];    PrintSorted[sort ! UNWIND => ReleaseSorting[sort]];    ReleaseSorting[sort]};  DisplayModule: PROC = {    gf: GFHandle;    IF mode = matrix THEN {PostError[badMode]; RETURN};    IF module = NIL OR module.length = 0 THEN {PostError[badModule]; RETURN};    IF module[0] IN ['0..'9] THEN gf ¬ String.StringToNumber[module, 8]    ELSE gf ¬ DebugUsefulDefsExtras.Frame[module];    Put.CR[logSW];    DisplayLine[      gf, GetCount[gf], TotalCounts[plain], GetTime[gf], TotalTimes[plain]];    Put.CR[logSW];    TextSW.ForceOutput[logSW]};  PrintSorted: PROC [sort: Sorting] = {    totalCounts, totalTime: LONG CARDINAL;    [totalCounts, totalTime] ¬ PrintHeader[];    FOR i: CARDINAL IN [0..GetCR[read].lastIndex] DO      count, time: LONG CARDINAL;      IF sort[i] = PrincOpsExtras2.nullGFH THEN LOOP;      count ¬ GetCount[sort[i]];      time ¬ GetTime[sort[i]];      IF count = 0 AND time = 0 THEN LOOP;      Put.CR[logSW];      DisplayLine[sort[i], count, totalCounts, time, totalTime];      ENDLOOP;    Put.CR[logSW];    PrintTrailer[plain];    Put.CR[logSW];    TextSW.ForceOutput[logSW]};  DisplayLine: PROC [    gf: GFHandle, count, totalCounts, time, totalTime: LONG CARDINAL] = {    f: Format.NumberFormat =      [base: 8, unsigned: TRUE, zerofill: FALSE, columns: 7];    g: Format.NumberFormat =      [base: 8, unsigned: TRUE, zerofill: FALSE, columns: 3];    IF UserInput.UserAbort[logSW] THEN SIGNAL Aborted;    CheckFrame[gf ! Aborted => GOTO bailout];    Put.Number[logSW, gf, f];    Put.Text[logSW, "B "L];    WriteFrameName[gf, 24];    WriteLongNumber[count, 12];    WritePercent[count, totalCounts, 8];    WriteConvertedTicksToMs[time, GetCR[read].pulseConversion, 12];    WritePercent[time, totalTime, 7];    EXITS bailout => RETURN};  CheckFrame: PROC [frame: GFHandle] = {    s: STRING = [24];    IF frame # PrincOpsExtras2.nullGFH AND DebugUsefulDefsExtras.Valid[frame] THEN RETURN;    String.AppendString[s, "! Invalid frame "L];    String.AppendOctal[s, frame];    MsgSW.Post[sw: msgSW, string: s, endOfMsg: TRUE];    Put.Text[logSW, s];    SIGNAL Aborted};  Aborted: SIGNAL = CODE;  PrintTotals: PROC [mode: Mode]    RETURNS [totalCounts, totalTime: LONG CARDINAL] = {    Put.CR[logSW];    totalCounts ¬ TotalCounts[mode];    totalTime ¬ TotalTimes[mode];    Put.Text[logSW, "Total Xfers"L];    WriteLongNumber[totalCounts, 14];    Put.CR[logSW];    Put.Text[logSW, "Total Time "L];    WriteConvertedTicksToMs[totalTime, GetCR[read].pulseConversion, 14]};  PrintHeader: PROC RETURNS [totalCounts, totalTime: LONG CARDINAL] = {    [totalCounts: totalCounts, totalTime: totalTime] ¬ PrintTotals[plain];    Put.Text[      logSW,      "Frame    Module                      #Xfers  %Xfers        Time  %Time------- ------------------------ ----------- ------- ----------- ------"L]};  PrintTrailer: PROC [mode: Mode] = {    Put.Text[logSW, "Ignored Xfers"L];    WriteLongNumber[Ignored[GetCounts[read], mode], 14];    Put.CR[logSW];    Put.Text[logSW, "Ignored Time "L];    WriteConvertedTicksToMs[      Ignored[GetTimes[read], mode], GetCR[read].pulseConversion, 14]};  WriteFrameName: PROC [frame: GFHandle, columns: CARDINAL ¬ 0] = {    module: STRING = [40];    DebugUsefulDefsExtras.Name[gf: frame, name: module];    PrintString[module, columns]};  TotalCounts: PROC [mode: CountPrivate.Mode] RETURNS [LONG CARDINAL] = {    RETURN[Total[GetCounts[read], mode]]};  TotalTimes: PROC [mode: CountPrivate.Mode] RETURNS [LONG CARDINAL] = {    RETURN[Total[GetTimes[read], mode]]};  Total: PROC [table: TableHandle, mode: CountPrivate.Mode]    RETURNS [total: LONG CARDINAL ¬ 0] = {    IF mode = plain THEN      FOR i: CARDINAL IN [1..GetCR[read].lastIndex] DO        total ¬ total + table.plain[i]; ENDLOOP    ELSE      FOR to: CARDINAL IN [1..MaxGroup] DO	FOR from: CARDINAL IN [1..MaxGroup] DO	  total ¬ total + table.matrix[to][from]; ENDLOOP;	ENDLOOP};  Ignored: PROC [table: TableHandle, mode: CountPrivate.Mode]    RETURNS [total: LONG CARDINAL ¬ 0] = {    total ¬ 0;    IF mode = plain THEN RETURN[table.plain[0]]    ELSE {      FOR to: CARDINAL IN [0..MaxGroup] DO         total ¬ total + table.matrix[to][0]; ENDLOOP;      FOR from: CARDINAL IN [1..MaxGroup] DO         total ¬ total + table.matrix[0][from]; ENDLOOP}};  GetCount: PROC [gf: GFHandle] RETURNS [LONG CARDINAL] = {    RETURN[GetValue[gf, GetCounts[read]]]};  GetTime: PROC [gf: GFHandle] RETURNS [LONG CARDINAL] = {    RETURN[GetValue[gf, GetTimes[read]]]};  GetValue: PROC [gf: GFHandle, table: TableHandle]    RETURNS [count: LONG CARDINAL] = {    data: GFData = GetHT[read].Fetch[gf];    RETURN[table.plain[data.index]]};  SortTable: PROC [table: TableHandle, sorting: Sorting] = {    SiftUp: PROC [low, high: CARDINAL] = {      FetchVal: PROC [index: CARDINAL] RETURNS [LONG CARDINAL] = {        RETURN[table.plain[LOOPHOLE[ht.Fetch[sorting[index]], GFData].index]]};      k, son: CARDINAL;      k ¬ low;      DO        t: GFHandle;	IF k*2 > high THEN EXIT;	IF k*2 + 1 > high OR FetchVal[k*2 + 1 - 1] > FetchVal[k*2 - 1] THEN	  son ¬ k*2	ELSE son ¬ k*2 + 1;	IF FetchVal[son - 1] > FetchVal[k - 1] THEN EXIT;	t ¬ sorting[son - 1];	sorting[son - 1] ¬ sorting[k - 1];	sorting[k - 1] ¬ t;	k ¬ son;	ENDLOOP};    length: CARDINAL = GetCR[read].lastIndex.SUCC;    ht: GFHash.Table = GetHT[read];    FOR i: CARDINAL DECREASING IN [1..length/2] DO SiftUp[i, length] ENDLOOP;    FOR i: CARDINAL DECREASING IN [1..length) DO      t: GFHandle ¬ sorting[1 - 1];      sorting[1 - 1] ¬ sorting[i + 1 - 1];      sorting[i + 1 - 1] ¬ t;      SiftUp[1, i];      ENDLOOP};  GetSorting: PROC RETURNS [sorting: Sorting] = {    length: CARDINAL = GetCR[read].lastIndex.SUCC;    i: CARDINAL;    sorting ¬ GetWords[length*GFHandle.SIZE];    {AddOne: PROC [gf: GFHandle, data: LONG POINTER] RETURNS [BOOLEAN] = {      sorting[i ¬ i + 1] ¬ gf; RETURN[FALSE]};    sorting[i ¬ 0] ¬ PrincOpsExtras2.nullGFH;    [] ¬ GetHT[read].Pairs[AddOne]}};  ReleaseSorting: PROC [sorting: Sorting] = {FreeWords[sorting]};  Sorting: TYPE = LONG POINTER TO ARRAY [0..0) OF GFHandle;  PrintString: PROC [s: STRING, columns: CARDINAL] = {    Put.Text[logSW, s];    IF columns > s.length THEN Put.Blanks[logSW, columns - s.length]};  PrintMatrix: PROC = {    g: Format.NumberFormat =      [base: 10, unsigned: TRUE, zerofill: FALSE, columns: 3];    count, time, totalCounts, totalTime: LONG CARDINAL;    [totalCounts, totalTime] ¬ PrintTotals[matrix];    Put.Text[      logSW,      "\nFrom -> To          #Xfers   %Xfers           Time   %Time\n----   ---     -----------  -------    -----------  ------"L];    Put.CR[logSW];    FOR from: GroupIndex IN [1..MaxGroup] DO      FOR to: GroupIndex IN [1..MaxGroup] DO	count ¬ counts.matrix[to][from];	time ¬ times.matrix[to][from];	IF count = 0 AND time = 0 THEN LOOP;	Put.Char[logSW, Ascii.SP];	Put.Number[logSW, from, g];	Put.Text[logSW, " ->"L];	Put.Number[logSW, to, g];	WriteLongNumber[count, 16];	WritePercent[count, totalCounts, 9];	WriteConvertedTicksToMs[time, GetCR[read].pulseConversion, 15];	WritePercent[time, totalTime, 8];	Put.CR[logSW];	IF UserInput.UserAbort[logSW] THEN SIGNAL Aborted;	ENDLOOP;      ENDLOOP;    Put.CR[logSW];    PrintTrailer[matrix];    Put.CR[logSW];    TextSW.ForceOutput[logSW]};  LoadMatrix: PROC = {    ht: GFHash.Table = GetHT[write];    stream: Stream.Handle = GetFile[];    {ZeroGroup: PROC [gf: GFHandle, data: GFData] RETURNS [BOOLEAN] = {      data.group ¬ 0; RETURN[FALSE]};    [] ¬ ht.Pairs[ZeroGroup]};    IF stream = NIL THEN RETURN;    prevGroup ¬ 0;    DO      ENABLE Stream.EndOfStream => EXIT;      gf: GFHandle;      group: GroupIndex;      data: GFData;      [gf: gf, group: group] ¬ GetNextPair[	stream ! BadFile => {PostError[badFile]; EXIT}];      IF (data ¬ GetRec[ht, gf]) = NIL THEN LOOP;      data.group ¬ group;      ENDLOOP;    stream.Delete;    Put.Line[logSW, "Matrix loaded"L]};    GetRec: PRIVATE PROC [ht: GFHash.Table, gf: GFHandle] RETURNS [data: GFData] = {    IF (data ¬ ht.Fetch[gf]) = NIL THEN {      data ¬ ht.Insert[gf];      IF data # NIL THEN        data­ ¬ [	  index: GetCR[write].lastIndex ¬ GetCR[write].lastIndex.SUCC,	  group: 0]}};	     GetFile: PROC RETURNS [stream: Stream.Handle] = {    name: LONG STRING ¬ Selection.Convert[string];    stream ¬ NIL;    IF name # NIL THEN      stream ¬ MStream.ReadOnly[name, [] ! MStream.Error => CONTINUE];    IF stream = NIL THEN {      Heap.systemZone.FREE[@name]; PostError[noFile]; RETURN[NIL]};    Heap.systemZone.FREE[@name]};  BadFile: SIGNAL = CODE;  prevGroup: GroupIndex;  GetNextPair: PROC [stream: Stream.Handle]    RETURNS [gf: GFHandle, group: GroupIndex] = {    OPEN String;    c: CHARACTER;    s: STRING ¬ [60];    DO      c ¬ GetToken[stream, s];      IF c = ': AND s.length = 1 AND s[0] = 'G THEN {	c ¬ GetToken[stream, s];	gf ¬ LOOPHOLE[StringToNumber[s, 10 ! InvalidNumber => GOTO badNumber]];	SELECT c FROM	  Ascii.CR => {group ¬ prevGroup; RETURN};	  Ascii.SP => {	    c ¬ GetToken[stream, s];	    prevGroup ¬ group ¬ StringToNumber[	      s, 10 ! InvalidNumber => GOTO badNumber];	    RETURN};	  ENDCASE => SIGNAL BadFile};      ENDLOOP;    EXITS badNumber => SIGNAL BadFile};  GetToken: PROC [stream: Stream.Handle, s: STRING] RETURNS [c: CHARACTER] = {    s.length ¬ 0;    DO      SELECT c ¬ Stream.GetChar[stream] FROM	Ascii.SP, Ascii.CR => IF s.length # 0 THEN RETURN ELSE LOOP;	',, ': => RETURN;	ENDCASE => String.AppendChar[s, c];      ENDLOOP};  ShowGroups: PROC = {    ht: GFHash.Table = GetHT[read];    group: CARDINAL ¬ CARDINAL.LAST;    group ¬ Selection.Number[10 ! String.InvalidNumber => CONTINUE];    IF group NOT IN GroupIndex THEN GOTO noGood;    Put.Text[logSW, "Modules for group "L];    Put.Decimal[logSW, group];    Put.Char[logSW, ':];    Put.CR[logSW];    {NoGood: SIGNAL = CODE;    PrintThisGroup: PROC [gf: GFHandle, data: GFData] RETURNS [BOOLEAN] = {      IF group = data.group THEN {	name: STRING ¬ [40];	CheckFrame[gf ! Aborted => SIGNAL NoGood];	WriteFrameName[gf];	Put.Text[logSW, name];	Put.Char[logSW, Ascii.SP]};      IF UserInput.UserAbort[logSW] THEN SIGNAL Aborted;      RETURN[FALSE]};    [] ¬ ht.Pairs[PrintThisGroup ! NoGood => GOTO noGood]};    Put.CR[logSW];    Put.CR[logSW];    TextSW.ForceOutput[logSW];    EXITS noGood => PostError[badGroup]};  Error: TYPE = {    notOn, goofUp, version, noContext, badModule, badProcess, noFile, badFile,    badMode, badGroup};  PostError: PROC [error: Error] = {    MsgSW.Post[      sw: msgSW,      string:      SELECT error FROM	notOn => "!Please Start CountTool and then try again"L,	goofUp =>	  "!Goofed up CountTool by use of Worry on/off during measurements"L,	version => "!CountTool has Incorrect Version"L,	noContext => "!No Context"L,	badModule => "!No Module specified"L,	badProcess => "!Invalid Process specified"L,	noFile => "!Can't find input file"L,	badFile => "!Bad matrix input file"L,	badMode => "!Can't do in matrix mode"L,	badGroup => "!Bad group specified"L,	ENDCASE => "?"L]};  PutHerald: PROC = {    OPEN Time;    s: STRING = [22];    Put.Line[logSW, PerfCommonOps.herald];    Append[s, Unpack[Current[]]];    s.length ¬ s.length - 3;    Put.Line[logSW, s];    Put.CR[logSW]};  SetDefaults: PROC [index: CARDINAL] = {    pcr: LONG POINTER TO ControlRecord = GetCR[write];    MakeSureOff[index];    IF VAL[index] # CmdIndex.setProcess THEN {      IF process # NIL THEN process.length ¬ 0;      [] ¬ FormSW.DisplayItem[cmdSW, CmdIndex.processPos.ORD]};    IF VAL[index] # CmdIndex.modePos THEN {      mode ¬ plain; [] ¬ FormSW.DisplayItem[cmdSW, CmdIndex.modePos.ORD]};    pcr.newSession ¬ FALSE;    PutHerald[]};      MakeSureOff: PROC [index: CARDINAL] = {    IF VAL[index] # CmdIndex.mon THEN {      monitorOn ¬ FALSE; [] ¬ FormSW.DisplayItem[cmdSW, CmdIndex.mon.ORD]}};  EnumerateNotify: FormSW.EnumeratedNotifyProcType = {    ParamNotify[sw: sw, item: item, index: index]};  ParamNotify: FormSW.NotifyProcType = {    ci: CmdIndex = VAL[index];    MsgSW.Clear[msgSW];    IF ~TablesExist[] THEN GOTO noTables;    IF ~TablesCorrectVersion[] THEN GOTO badVersion;    IF GetCR[read].newSession THEN SetDefaults[index];    SELECT ci FROM      mon => IF monitorOn THEN TurnOn[] ELSE IF ~TurnOff[] THEN PostError[goofUp];      zero => ZeroCounts[];      condition => ConditionBreaks[];      printtables =>	IF mode = plain THEN PrintTables[	  ! Aborted => {	    Put.Line[logSW, "... aborted!"L]; 	    TextSW.ForceOutput[logSW]; 	    CONTINUE}]	ELSE PrintMatrix[ ! Aborted => {	  Put.Line[logSW, "... aborted!"L];	  TextSW.ForceOutput[logSW];	  CONTINUE}];      printsorted =>	DisplaySorted[ ! Aborted => {	  Put.Line[logSW, "... aborted!"L]; 	  TextSW.ForceOutput[logSW];	  CONTINUE}];      printmodule =>	DisplayModule[ !	  DebugUsefulDefs.NotFound => {CantFind[s]; CONTINUE};	  Aborted => {	    Put.Line[logSW, "... aborted!"L];	    TextSW.ForceOutput[logSW];	    CONTINUE}];      setProcess => SetProcess[];      modePos => GetCR[write].mode ¬ mode;      loadmatrix => LoadMatrix[];      groups =>	ShowGroups[ ! Aborted => {	  Put.Line[logSW, "... aborted!"L];	  TextSW.ForceOutput[logSW];	  CONTINUE}];      ENDCASE;    EXITS      noTables => {PostError[notOn]; MakeSureOff[index]};      badVersion => {PostError[version]; MakeSureOff[index]}};  CantFind: PROC [name: LONG STRING] = {    MsgSW.Post[sw: msgSW, string: "!Can't find "L, endOfMsg: FALSE];    MsgSW.Post[sw: msgSW, string: name]};  Cleanup: Supervisor.AgentProcedure = {    OPEN EventTypes;    fake: LONG POINTER TO Supervisor.Event = eventData;    PutTables[      event = aboutToResume OR      (event = spare2 AND fake # NIL AND fake­ = aboutToResume)];    SELECT event FROM      aboutToResume => {        MarkFrame: PROC [gf: GFHandle] RETURNS [BOOLEAN] = {          gw: PrincOpsExtras2.GlobalWord	      ¬ DebugUsefulDefs.LongREAD[DebugUsefulDefsExtras.GFlong[gf] - PrincOpsExtras2.globalWordOffset];	  --check to see if trapxfers is true first to save  	  IF gw.trapxfers THEN RETURN[FALSE];              gw.trapxfers ¬ TRUE;          DebugUsefulDefs.LongWRITE[DebugUsefulDefsExtras.GFlong[gf] - PrincOpsExtras2.globalWordOffset, gw];          RETURN[FALSE]};        [] ¬ DebugUsefulDefsExtras.Enumerate[MarkFrame]};      spare2 => {IF (fake # NIL AND fake­ = aboutToResume) THEN {        MarkFrame: PROC [gf: GFHandle] RETURNS [BOOLEAN] = {          gw: PrincOpsExtras2.GlobalWord	      ¬ DebugUsefulDefs.LongREAD[DebugUsefulDefsExtras.GFlong[gf] - PrincOpsExtras2.globalWordOffset];          gw.trapxfers ¬ TRUE;          DebugUsefulDefs.LongWRITE[DebugUsefulDefsExtras.GFlong[gf] - PrincOpsExtras2.globalWordOffset, gw];          RETURN[FALSE]};        [] ¬ DebugUsefulDefsExtras.Enumerate[MarkFrame]}};      newSession, abortSession => {	monitorOn ¬ counterOn ¬ FALSE; 	FormSW.DisplayItem[cmdSW, CmdIndex.mon.ORD]};      spare3 => IF fake # NIL THEN SELECT fake­ FROM        newSession, abortSession => {	  monitorOn ¬ counterOn ¬ FALSE; 	  FormSW.DisplayItem[cmdSW, CmdIndex.mon.ORD]};	ENDCASE;      ENDCASE};	        -- Mainline code  agent: Supervisor.SubsystemHandle = Supervisor.CreateSubsystem[Cleanup];  sameWorld: Supervisor.SubsystemHandle = Supervisor.CreateSubsystem[SameWorld];    SameWorld: Supervisor.AgentProcedure = {    IF SwordUsefulDefs.defaultWorld # SwordUsefulDefs.localWorld       AND SwordUsefulDefs.defaultWorld # NIL THEN RETURN;    Cleanup[event, eventData, instanceData]; };  Supervisor.AddDependency[client:agent, implementor: Event.aboutToSwap];  Supervisor.AddDependency[client:agent, implementor: Event.swapping];  Supervisor.AddDependency[client:sameWorld, implementor: Event.spare2];  END.
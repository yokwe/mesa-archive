-- File: CTTool.mesa - last edit:-- AOF                  9-Jan-88 15:03:00-- Copyright (C) 1984, 1985, 1987, 1988 by Xerox Corporation. All rights reserved. DIRECTORY  AddressTranslation USING [Error, StringToNetworkAddress],  Ascii USING [CR, TAB],  Courier USING [    Dispatcher, ExportRemoteProgram, UnexportRemoteProgram,    Arguments, LocalSystemElement, EnumerateExports, FreeEnumeration, Exports],  CTTx USING [    DataHandle, Data, Dispatcher, TestType, program, versionL, LoadUserDriver,    LoadServerDriver, CreateHandle, DeleteHandle, Establish, AppendTestName,    versionH],  Format USING [NetworkAddress, StringProc],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType, LabelItem,    EnumeratedNotifyProcType, CommandItem, Enumerated, EnumeratedItem,    DisplayItem, ProcType, StringItem, NumberItem, LongNumberItem, LineN,    nextLine, sameLine],  Heap USING [Create, Delete],  MFile USING [Error, Handle, ReadOnly, Release],  MLoader USING [Error, Load, Run, VersionMismatch],  NetworkStream USING [ClassOfService],  Process USING [    Abort, Detach, SetPriority, priorityBackground, priorityNormal,    Pause, MsecToTicks],  Put USING [Char, Line, Text],  Router USING [AssignAddress, FindMyHostID],  RouterInternal USING [SetNSDriverLoopback],  Runtime USING [IsBound, GetBcdTime, UnboundProcedure],  CourierInternal USING [stats, StatType],  String USING [    AppendChar, AppendLongDecimal, AppendString, AppendSubString,    SubStringDescriptor, AppendNumber],  System USING [    TimerHandle, CreateIntervalTimer, GetIntervalTime, NetworkAddress,    nullSocketNumber],  Time USING [AppendCurrent, Append, Unpack],  Tool USING [Create, MakeFileSW, MakeFormSW, MakeSWsProc, UnusedLogName],  ToolDriver USING [Address, NoteSWs, RemoveSWs],  ToolWindow USING [SetTinyName, TransitionProcType],  UserInput USING [ResetUserAbort, UserAbort],  Version USING [Append],  Window USING [Handle];CTTool: PROGRAM  IMPORTS    AddressTranslation, Courier, CTTx, FormSW, Process, Put,    String, System, Time, Tool, ToolDriver, Runtime, ToolWindow, MFile,    MLoader, Heap, Router, RouterInternal, CourierInternal, Version,    Format, UserInput  EXPORTS CTTx =  BEGIN  -- Variable declarations  ici, toi: CARDINAL;  --special indexes (iteration count & timeout)  process: PROCESS;  atBOL: BOOLEAN ¬ TRUE;  tool: PUBLIC CTTx.DataHandle ¬ NIL;  wh: Window.Handle;  -- Tool's window  icProcess: PROCESS ¬ NIL;  hyper: PUBLIC UNCOUNTED ZONE ¬ NIL;  toolZone: UNCOUNTED ZONE ¬ NIL;  Abort: FormSW.ProcType =    BEGIN    MsgOut["(Tool) aborting... "L, TRUE, FALSE];    SELECT TRUE FROM      (~tool.testRunning) => MsgOut["test not running"L, FALSE, TRUE];      (tool.abortTest) => MsgOut["abort already requested"L, FALSE, TRUE];      ENDCASE =>        BEGIN	Process.Abort[process];	MsgOut["test process aborted"L, FALSE, TRUE];	END;    END;       AppendConfigVersion: PROCEDURE [    function: {load, run}, filename: STRING] =    BEGIN    msg: STRING ¬ [100];    fHandle: MFile.Handle ¬ NIL;    BEGIN    ENABLE      BEGIN      MFile.Error =>        BEGIN	String.AppendString[to: msg, from: "...Acquisition error"L];	GOTO error;	END;      MLoader.VersionMismatch =>        BEGIN	String.AppendString[to: msg, from: "...Version mismatch..."L];	String.AppendString[to: msg, from: module];	GOTO error;	END;      MLoader.Error =>        BEGIN	String.AppendString[to: msg, from: "...Loader error..."L];	String.AppendString[to: msg, from: SELECT code FROM	  missingCode => "missing code"L, badCode => "badCode"L,	  gftFull => "gftFull"L, ENDCASE => "other error"L];	GOTO error;	END;      END;    String.AppendString[to: msg, from: SELECT function FROM      load => "Loading..."L, ENDCASE => "Running..."L];    String.AppendString[to: msg, from: filename];    fHandle ¬ MFile.ReadOnly[name: filename, release: [NIL, NIL]];    MsgOut[msg, TRUE, FALSE];    msg.length ¬ 0;    [] ¬ SELECT function FROM      run => MLoader.Run[fHandle], ENDCASE => MLoader.Load[fHandle];    MsgOut["...done"L, FALSE, TRUE];    EXITS error =>      BEGIN      MsgOut[msg, FALSE, TRUE];      IF fHandle # NIL THEN MFile.Release[fHandle];      END;    END;    END;    ClientTransition: ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      old = inactive =>        IF tool = NIL THEN	  BEGIN	  toolZone ¬ Heap.Create[initial: 10];	  tool ¬ toolZone.NEW[CTTx.Data ¬ []];	  hyper ¬ Heap.Create[initial: 20];	  END;      new = inactive =>        IF tool # NIL THEN          BEGIN	  tool.booleans[serverActive] ¬ tool.booleans[userActive] ¬ FALSE;	  Server[]; User[];          ToolDriver.RemoveSWs["CourierTool"L];	  toolZone.FREE[@tool];	  Heap.Delete[hyper, TRUE]; hyper ¬ NIL;	  Heap.Delete[toolZone]; toolZone ¬ NIL;          END;      ENDCASE;    END;    CTT1Dispatcher, CTT2Dispatcher: Courier.Dispatcher = {};    Enumerate: FormSW.ProcType =    BEGIN    line: STRING ¬ [140];    exports: LONG DESCRIPTOR FOR Courier.Exports ¬ Courier.EnumerateExports[];    FOR index: CARDINAL IN [0..LENGTH[exports]) DO      line.length ¬ 0;      String.AppendString[line, "[program: "L];      String.AppendLongDecimal[line, exports[index].programNumber];      String.AppendString[line, ", version: ["L];      String.AppendNumber[line, exports[index].versionRange.low, 10];      String.AppendString[line, ", "L];      String.AppendNumber[line, exports[index].versionRange.high, 10];      String.AppendString[line, "], export time: "L];      Time.Append[line, Time.Unpack[exports[index].exportTime]];      IF (exports[index].serviceName # NIL)        AND (exports[index].serviceName.length # 0) THEN	BEGIN	String.AppendString[line, ", service name: "L];	String.AppendString[line, exports[index].serviceName];	END;      Put.Line[tool.fileSW, line];      ENDLOOP;    Courier.FreeEnumeration[exports];    END;    Init: PROCEDURE =    BEGIN    stringProc: Format.StringProc = {String.AppendString[name, s]};    name: STRING ¬ [80];    local: System.NetworkAddress ¬ Router.AssignAddress[];    local.socket ¬ System.nullSocketNumber;    String.AppendString[name, "Courier Test Tool "L];    Version.Append[name];    String.AppendString[name, " of "L];    Time.Append[name, Time.Unpack[Runtime.GetBcdTime[]]];    String.AppendString[name, " running on "L];    Format.NetworkAddress[stringProc, local, octal];    wh ¬ Tool.Create[      initialBox: [place: [50, 40], dims: [500, 600]], makeSWsProc: MakeSWs,      initialState: default, clientTransition: ClientTransition, name: name];    name.length ¬ 0;    Version.Append[name];    ToolWindow.SetTinyName[wh, "CTT"L, name];    END;  IterationUpdate: PROC =    BEGIN    iCopy: CARDINAL ¬ 0;    dCopy: CARDINAL ¬ tool.delay;    tCopy: LONG CARDINAL ¬ tool.timeout;    FormSW.DisplayItem[tool.formSW, ici];    Process.SetPriority[Process.priorityBackground];    UNTIL tool.abortTest DO      ENABLE ABORTED => EXIT;      IF tool.iterationC # iCopy THEN        BEGIN        FormSW.DisplayItem[tool.formSW, ici];        iCopy ¬ tool.iterationC;        END;      IF tool.timeout # tCopy THEN        BEGIN        FormSW.DisplayItem[tool.formSW, toi];        tCopy ¬ tool.timeout;        END;      Process.Pause[Process.MsecToTicks[20]];      tool.abortTest ¬ UserInput.UserAbort[wh];      ENDLOOP;    UserInput.ResetUserAbort[wh];    FormSW.DisplayItem[tool.formSW, ici];    FormSW.DisplayItem[tool.formSW, toi];    END;  LoadTool: FormSW.ProcType =    BEGIN    IF tool.booleans[toolActive] AND      ~Runtime.IsBound[LOOPHOLE[Courier.ExportRemoteProgram]] THEN      BEGIN      AppendConfigVersion[load, "CourierConfig.bcd"L];       IF~Runtime.IsBound[LOOPHOLE[Courier.ExportRemoteProgram]] THEN        AppendConfigVersion[load, "UnpackedCourier.bcd"L];      IF~Runtime.IsBound[LOOPHOLE[Courier.ExportRemoteProgram]] THEN        AppendConfigVersion[load, "CommComSoft.bcd"L];      IF~Runtime.IsBound[LOOPHOLE[Courier.ExportRemoteProgram]] THEN        BEGIN	MsgOut["Can't bind to Courier...reseting tool"L, TRUE, TRUE];	tool.booleans[toolActive] ¬ FALSE;	FormSW.DisplayItem[tool.formSW, index];	END;      END;    END;  MakeForm: FormSW.ClientItemsProcType =    BEGIN OPEN FormSW;    -- This procedure creates a sample FormSW.    n: CARDINAL;    nItems: CARDINAL = 49;    e1: ARRAY [0..2) OF Enumerated ¬ [      ["bulk"L, NetworkStream.ClassOfService[bulk]],      ["transactional"L, NetworkStream.ClassOfService[transactional]]];    items ¬ AllocateItemDescriptor[nItems];    -- Create an example of command item usage    items[n ¬ 0] ¬ BooleanItem[      tag: "Tool"L, place: [10, LineN[0]], switch: @tool.booleans[toolActive],      proc: LoadTool, z: toolZone];    items[n ¬ n + 1] ¬ BooleanItem[      tag: "Server"L, place: [90, sameLine],      switch: @tool.booleans[serverActive], proc: Server, z: toolZone];    items[n ¬ n + 1] ¬ BooleanItem[      tag: "User"L, place: [180, sameLine], switch: @tool.booleans[userActive],      proc: User, z: toolZone];    items[n ¬ n + 1] ¬ StringItem[      tag: "Server address"L, place: [260, sameLine], string: @tool.address,      inHeap: TRUE, z: toolZone];    items[n ¬ n + 1] ¬ LabelItem[      place: [0, nextLine], tag: "Test Control"L, z: toolZone];    items[n ¬ n + 1] ¬ CommandItem[      tag: "Create"L, place: [10, nextLine],      proc: CTTx.CreateHandle, z: toolZone];    items[n ¬ n + 1] ¬ CommandItem[      tag: "Delete"L, place: [100, sameLine],      proc: CTTx.DeleteHandle, z: toolZone];    items[n ¬ n + 1] ¬ CommandItem[      tag: "Establish"L, place: [174, sameLine],      proc: CTTx.Establish, z: toolZone];    items[n ¬ n + 1] ¬ EnumeratedItem[      tag: "Stream class"L, place: [300, sameLine], feedback: one,      value: @tool.class, choices: DESCRIPTOR[e1], z: toolZone];    items[n ¬ n + 1] ¬ CommandItem[      tag: "Start"L, place: [10, nextLine], proc: Start, z: toolZone];    items[n ¬ n + 1] ¬ CommandItem[      tag: "Abort"L, place: [60, sameLine], proc: Abort, z: toolZone];    items[n ¬ n + 1] ¬ CommandItem[      tag: "Enumerate exports"L, place: [155, sameLine],      proc: Enumerate, z: toolZone];    items[n ¬ n + 1] ¬ CommandItem[      tag: "Local statistics"L, place: [300, sameLine],      proc: Statistics, z: toolZone];    items[ici ¬ n ¬ n + 1] ¬ NumberItem[      tag: "Iteration count"L, drawBox: TRUE, place: [10, nextLine],      value: @tool.iterationC, readOnly: TRUE, z: toolZone];    items[n ¬ n + 1] ¬ NumberItem[      tag: "Iteration limit"L, drawBox: TRUE, place: [200, sameLine],      value: @tool.iterationL, z: toolZone];    items[n ¬ n + 1] ¬ BooleanItem[      tag: "debug"L, place: [400, sameLine], switch: @tool.debug, z: toolZone];    items[n ¬ n + 1] ¬ LabelItem[place: [0, nextLine],      tag: "Parameter Routine Tests"L, z: toolZone];    items[n ¬ n + 1] ¬ BooleanItem[      tag: "null"L, place: [10, nextLine],      switch: @tool.driver[null].flag, z: toolZone];    items[n ¬ n + 1] ¬ BooleanItem[      tag: "CARDINAL"L, place: [155, sameLine],      switch: @tool.driver[cardinal].flag, z: toolZone];    items[n ¬ n + 1] ¬ BooleanItem[      tag: "LONG CARDINAL"L, place: [300, sameLine],      switch: @tool.driver[longCardinal].flag, z: toolZone];    items[n ¬ n + 1] ¬ BooleanItem[      tag: "ARRAY"L, place: [10, nextLine],      switch: @tool.driver[array].flag, z: toolZone];    items[n ¬ n + 1] ¬ BooleanItem[      tag: "Choice"L, place: [155, sameLine],      switch: @tool.driver[choice].flag, z: toolZone];    items[n ¬ n + 1] ¬ BooleanItem[      tag: "Parameters"L, place: [300, sameLine],      switch: @tool.driver[parameters].flag, z: toolZone];    items[n ¬ n + 1] ¬ BooleanItem[      tag: "Dead space"L, place: [10, nextLine],      switch: @tool.driver[deadSpace].flag, z: toolZone];    items[n ¬ n + 1] ¬ BooleanItem[      tag: "STRING"L, place: [155, sameLine],      switch: @tool.driver[longString].flag, z: toolZone];    items[n ¬ n + 1] ¬ BooleanItem[      tag: "DESCRIPTOR"L, place: [300, sameLine],      switch: @tool.driver[longDescriptor].flag, z: toolZone];    items[n ¬ n + 1] ¬ BooleanItem[      tag: "Disjoint"L, place: [10, nextLine],      switch: @tool.driver[longDisjoint].flag, z: toolZone];    items[n ¬ n + 1] ¬ BooleanItem[      tag: "Space"L, place: [155, sameLine],      switch: @tool.driver[space].flag, z: toolZone];    items[n ¬ n + 1] ¬ BooleanItem[      tag: "Block"L, place: [300, sameLine],      switch: @tool.driver[block].flag, z: toolZone];    items[n ¬ n + 1] ¬ LabelItem[place: [0, nextLine],      tag: "Error Tests"L, z: toolZone];    items[n ¬ n + 1] ¬ LabelItem[place: [0, nextLine],      tag: "Connection:"L, z: toolZone];    items[n ¬ n + 1] ¬ BooleanItem[      tag: "noRouteToSystemElement"L, place: [100, sameLine],      switch: @tool.driver[noRoute].flag, z: toolZone];    items[n ¬ n + 1] ¬ BooleanItem[      tag: "tooManyConnections"L, place: [250, sameLine],      switch: @tool.driver[tooMany].flag, z: toolZone];    items[n ¬ n + 1] ¬ LabelItem[place: [0, nextLine], tag: "Binding:"L];    items[n ¬ n + 1] ¬ BooleanItem[      tag: "noSuchProgramNumber"L, place: [100, sameLine],      switch: @tool.driver[noProg].flag, z: toolZone];    items[n ¬ n + 1] ¬ BooleanItem[      tag: "noSuchVersionNumber"L, place: [250, sameLine],      switch: @tool.driver[noVers].flag, z: toolZone];    items[n ¬ n + 1] ¬ LabelItem[place: [0, nextLine], tag: "RPC:"L];    items[n ¬ n + 1] ¬ BooleanItem[      tag: "returnTimedOut"L, place: [100, sameLine],      switch: @tool.driver[returnTMO].flag, z: toolZone];    items[n ¬ n + 1] ¬ BooleanItem[      tag: "callerAborted"L, place: [250, sameLine],      switch: @tool.driver[callerAborted].flag, z: toolZone];    items[n ¬ n + 1] ¬ BooleanItem[      tag: "paramaterInconsistency"L, place: [100, nextLine],      switch: @tool.driver[parmInconst].flag, z: toolZone];    items[n ¬ n + 1] ¬ BooleanItem[      tag: "noSuchProcedureNumber"L, place: [250, sameLine],      switch: @tool.driver[noProc].flag, z: toolZone];    items[n ¬ n + 1] ¬ BooleanItem[      tag: "invalidArguments"L, place: [100, nextLine],      switch: @tool.driver[invalidArguments].flag, z: toolZone];    items[n ¬ n + 1] ¬ BooleanItem[      tag: "unknownError"L, place: [250, sameLine],      switch: @tool.driver[unknown].flag, z: toolZone];    items[n ¬ n + 1] ¬ BooleanItem[      tag: "stackOverflow"L, place: [100, nextLine],      switch: @tool.driver[stackOverflow].flag, z: toolZone];    items[n ¬ n + 1] ¬ LabelItem[place: [0, nextLine],      tag: "Data Stream"L];    items[n ¬ n + 1] ¬ BooleanItem[      tag: "1"L, place: [80, sameLine],      switch: @tool.driver[dataStream].flag, z: toolZone];    items[n ¬ n + 1] ¬ BooleanItem[      tag: "2"L, place: [90, sameLine],      switch: @tool.driver[dataStream2].flag, z: toolZone];    items[n ¬ n + 1] ¬ NumberItem[      tag: "delay(msecs)"L, drawBox: TRUE, place: [110, sameLine],      value: @tool.delay, z: toolZone];    items[toi ¬ n ¬ n + 1] ¬ LongNumberItem[      tag: "timeout(msecs)"L, drawBox: TRUE, place: [300, sameLine],      value: @tool.timeout, z: toolZone];    tool.class ¬ bulk;    IF (n + 1) # nItems THEN ERROR;    RETURN[items: items, freeDesc: TRUE];    END;  MakeSWs: Tool.MakeSWsProc =    BEGIN    logName: STRING ¬ [40];    addresses: ARRAY [0..2) OF ToolDriver.Address;    Tool.UnusedLogName[unused: logName, root: "Courier.log"L];    tool.formSW ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    tool.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    addresses ¬ [["formSW"L, tool.formSW], ["fileSW"L, tool.fileSW]];    ToolDriver.NoteSWs["CTT"L, DESCRIPTOR[addresses]];    END;  MsgOut: PUBLIC PROC [string: LONG STRING, bol, eol: BOOLEAN ¬ TRUE] =    BEGIN    IF bol THEN      BEGIN      msg: STRING ¬ [50];      IF ~atBOL THEN String.AppendChar[msg, Ascii.CR];      Time.AppendCurrent[msg];      String.AppendChar[msg, ' ];      Put.Text[h: tool.fileSW, s: msg];      END;    IF eol THEN Put.Line[h: tool.fileSW, s: string]    ELSE Put.Text[h: tool.fileSW, s: string];    atBOL ¬ eol;    END;  Server: FormSW.ProcType =    BEGIN    IF ~tool.booleans[toolActive] THEN      BEGIN      MsgOut["(Tool) Tool not active"L];      RETURN;      END;    IF tool.booleans[serverActive] THEN      BEGIN      MsgOut[        "(Tool) Starting server...exporting test programs..."L, TRUE, FALSE];      Courier.ExportRemoteProgram[        CTTx.program, [CTTx.versionL, CTTx.versionH], CTTx.Dispatcher,	"CTT (Vers 8.0h)"L, hyper, tool.class];      Courier.ExportRemoteProgram[        CTTx.program-1, [CTTx.versionL, CTTx.versionH], CTT1Dispatcher,	"CTT1 (Vers 8.0h)"L, hyper, tool.class];      Courier.ExportRemoteProgram[        CTTx.program-2, [CTTx.versionL-1, CTTx.versionH+1], CTT2Dispatcher,	"CTT2 (Vers 8.0h)"L, hyper, tool.class];      MsgOut["loading driver array..."L, FALSE, FALSE];      CTTx.LoadServerDriver[];      END    ELSE      BEGIN      MsgOut[        "(Tool) Stopping server...unexporting test programs..."L, TRUE, FALSE];      Courier.UnexportRemoteProgram[        CTTx.program, [CTTx.versionL, CTTx.versionH]];      Courier.UnexportRemoteProgram[        CTTx.program-1, [CTTx.versionL, CTTx.versionH]];      Courier.UnexportRemoteProgram[        CTTx.program-2, [CTTx.versionL-1, CTTx.versionH+1]];      END;    MsgOut["...done"L, FALSE, TRUE];    END;  Start: FormSW.ProcType =    BEGIN    msg: STRING;    BEGIN    IF ~tool.booleans[userActive] THEN {msg ¬ "No user active"L; GOTO error};    IF tool.testRunning THEN {msg ¬ "Test already running"L; GOTO error};    tool.testRunning ¬ TRUE;    tool.abortTest ¬ FALSE;    tool.iterationC ¬ 0;    Process.Detach[process ¬ FORK TestDriver[]];    msg ¬ "Test started"L;    EXITS error => NULL;    END;    MsgOut["(Tool) "L, TRUE, FALSE];    MsgOut[msg, FALSE, TRUE];    END;    Statistics: FormSW.ProcType =    BEGIN    msg: STRING ¬ [40];    tags: ARRAY CourierInternal.StatType OF STRING = [      "stackPagesMapped"L, "stackPagesUnmapped"L,      "stackPagesGot"L, "stackPagesPut"L,      "bytesReceived"L, "bytesTransmitted"L,      "bytesFlushed"L, "callsReceived"L,      "localCallsReceived"L, "rejectsTransmitted"L,      "returnsTransmitted"L, "abortsTransmitted"L,      "callsTransmitted"L, "localCallsTransmitted"L,      "rejectsReceived"L, "returnsReceived"L,      "abortsReceived"L, "callRetry"L, "zoneAllocated"L, "zoneFreed"L,      "streamsAcquired"L, "streamsCreated"L, "streamsDeleted"L];    MsgOut["Local Courier statistics"L];    FOR index: CourierInternal.StatType IN CourierInternal.StatType DO      IF CourierInternal.stats[index] # 0 THEN        BEGIN	msg.length ¬ 1; msg[0] ¬ Ascii.TAB;	String.AppendString[msg, tags[index]];	String.AppendString[msg, ": "L];	String.AppendLongDecimal[msg, CourierInternal.stats[index]];	Put.Line[tool.fileSW, msg];	END;      ENDLOOP;     END;  --Statistics      TestDriver: PROC =    BEGIN        DisplayTime: PROC [milliseconds: LONG CARDINAL] =      BEGIN      IF milliseconds > 1000 THEN        BEGIN        time: STRING ¬ [20];        substring: String.SubStringDescriptor;        String.AppendLongDecimal[time, milliseconds];        substring ¬ [time, 0, time.length - 3];        String.AppendSubString[msg, @substring];        String.AppendChar[msg, '.];        substring ¬ [time, time.length - 3, 3];        String.AppendSubString[msg, @substring];        String.AppendString[msg, "(seconds)"L];        END      ELSE        BEGIN        String.AppendLongDecimal[msg, milliseconds];        String.AppendString[msg, "(milliseconds)"L];        END;      Put.Line[tool.fileSW, msg];      msg.length ¬ 0;      END;          test: CTTx.TestType;    msg: STRING ¬ [80];    timer: System.TimerHandle;    milliseconds, elapsed: LONG CARDINAL ¬ 0;    --clear out timer entry in test table    FOR test IN CTTx.TestType DO tool.driver[test].duration ¬ 0; ENDLOOP;    BEGIN    Process.SetPriority[Process.priorityNormal];    tool.iterationC ¬ 0;    tool.minTimeout ¬ tool.maxTimeout ¬ tool.timeout;    timer ¬ System.CreateIntervalTimer[];    IF icProcess = NIL THEN icProcess ¬ FORK IterationUpdate[];    UNTIL tool.abortTest DO      tool.iterationC ¬ tool.iterationC + 1;      FOR test IN CTTx.TestType DO	ENABLE ABORTED => IF ~tool.abortTest THEN CONTINUE;        IF tool.driver[test].flag THEN	  BEGIN	  timer ¬ System.CreateIntervalTimer[];          tool.driver[test].user[];	  elapsed ¬ System.GetIntervalTime[timer]/1000;	  --actual duration/test will be x/# of iterations	  tool.driver[test].duration ¬ tool.driver[test].duration + elapsed;	  END;        ENDLOOP;      IF tool.abortTest THEN EXIT;      IF (tool.iterationC >= tool.iterationL)        AND (tool.iterationL # 0) THEN GOTO exit;      milliseconds ¬ milliseconds + elapsed;      Process.Pause[Process.MsecToTicks[10] ! ABORTED => CONTINUE];      ENDLOOP;    MsgOut["(Tool) Test aborted"L, TRUE, TRUE];    EXITS exit => NULL;    END;    tool.testRunning ¬ tool.abortTest ¬ FALSE;    Process.Abort[icProcess]; JOIN icProcess; icProcess ¬ NIL;    MsgOut["(Tool) Test complete, elapsed time: "L, TRUE, FALSE];    DisplayTime[milliseconds];  --display total time    MsgOut["Individual test average durations"L, TRUE, TRUE];    FOR test IN CTTx.TestType DO      IF ~tool.driver[test].flag THEN LOOP;      Put.Char[tool.fileSW, Ascii.TAB];      CTTx.AppendTestName[test];      DisplayTime[tool.driver[test].duration/tool.iterationC];      ENDLOOP;    IF tool.driver[dataStream].flag OR tool.driver[dataStream2].flag THEN      BEGIN      String.AppendString[msg, "	Stream.GetBlock timings(mSecs): [min: "L];      String.AppendLongDecimal[msg, tool.minTimeout];      String.AppendString[msg, ", max: "L];      String.AppendLongDecimal[msg, tool.maxTimeout];      String.AppendChar[msg, ']];      Put.Line[tool.fileSW, msg];      msg.length ¬ 0;      END;    END;  User: FormSW.ProcType =    BEGIN    msg: STRING;    stringProc: Format.StringProc =      BEGIN      IF tool.address # NIL THEN toolZone.FREE[@tool.address];      tool.address ¬ toolZone.NEW[StringBody[s.length]];      String.AppendString[tool.address, s];      END;  --sp     IF ~tool.booleans[toolActive] THEN      BEGIN      MsgOut["(Tool) Tool not active"L];      RETURN;      END;    BEGIN    IF tool.booleans[userActive] THEN      BEGIN      ENABLE        BEGIN	Runtime.UnboundProcedure =>	  BEGIN	  msg ¬ "Clearinghouse not available...use octal addresses"L;	  GOTO exit;	  END;        AddressTranslation.Error =>	  BEGIN	  WITH e: errorRecord SELECT FROM	    badSyntax, scanError =>	      msg ¬ "Syntax error in server address"L;	    chLookupProblem, otherCHProblem =>	      msg ¬ "Name not found in Clearinghouse | other problem"L;	    ENDCASE;	  GOTO exit;	  END;	END;      MsgOut["(Tool) Starting user...checking server address..."L, TRUE, FALSE];      IF (tool.address) = NIL OR (tool.address.length = 0) THEN        BEGIN        IF ~tool.booleans[serverActive] THEN {          msg ¬ "No server available"L; GOTO exit};        tool.server ¬ Courier.LocalSystemElement[];        Format.NetworkAddress[stringProc, tool.server, octal];        FormSW.DisplayItem[tool.formSW, 3];        END      ELSE tool.server ¬ AddressTranslation.StringToNetworkAddress[	tool.address].addr;      RouterInternal.SetNSDriverLoopback[        tool.server.host = Router.FindMyHostID[]];      MsgOut["loading driver array"L, FALSE, FALSE];      CTTx.LoadUserDriver[];      END    ELSE MsgOut["(Tool) Stopping user"L, TRUE, FALSE];    MsgOut["...done"L, FALSE, TRUE];    EXITS      exit =>        BEGIN        MsgOut[msg, FALSE, FALSE];        tool.booleans[userActive] ¬ FALSE;        FormSW.DisplayItem[tool.formSW, 2];        MsgOut["...user reset"L, FALSE, TRUE];        END;    END;    END;  -- Mainline code  Init[];  END...  
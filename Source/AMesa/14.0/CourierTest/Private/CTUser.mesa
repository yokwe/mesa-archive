-- File: CTUser.mesa - last edit:-- AOF                 27-May-85 15:37:47-- Copyright (C) 1984, 1985  by Xerox Corporation. All rights reserved. DIRECTORY  Courier USING [    Handle, Create, Delete, Parameters, Call, ErrorCode, Error,    ReleaseDataStream, Free, Arguments, RemoteErrorSignalled,    LocalSystemElement, Object, VersionMismatch, VersionRange],  CTTx USING [    TestType, MsgOut, ProcessUserError, tool, program, versionL, returnTMO, null,    cardinal, longCardinal, array, longString, longDescriptor,    choice, parameters, longDisjoint, dataStream, block,    CardinalDescribe, LongCardinalDescribe, ArrayDescribe, versionH,    StringDescribe, DescriptorDescribe,    ChoiceDescribe, establish, dataStream2, ParametersDescribe, DisjointDescribe,    EstablishDescribe, VariantRecord, UserProc, AppendTestName, invalidArguments,    ProcessCourierError, space, deadSpace, SpaceDescribe,    DeadSpaceDescribe, BlockDescribe, AbortImmediately, StageNumber, UserReject,    SourceWithoutAbort, SinkWatchingForAbort, SinkWithAbort, SourceWithAbort,    StackOverflowArgs, stackOverflow, StackOverflowDescribe, hyper],  Environment USING [Byte],  Format USING [NetworkAddress, StringProc],  FormSW USING [Display, ProcType],  Inline USING [HighHalf, LowHalf],  Process USING [Abort, Detach, GetCurrent, MsecToTicks, Pause],  Stream USING [Attention, Handle],  String USING [EqualString, AppendString],  System USING [    GetClockPulses, NetworkAddress, CreateIntervalTimer, GetIntervalTime,    TimerHandle, GetGreenwichMeanTime];CTUser: PROGRAM  IMPORTS    Courier, CTTx, Format, FormSW, Inline, LS: String,    System, Process, Stream  EXPORTS CTTx =  BEGIN  Compare: ERROR = CODE;  mismatch: BOOLEAN ¬ FALSE;  handle: Courier.Handle ¬ NIL;  Bytes: TYPE = LONG POINTER TO PACKED ARRAY [0..0) OF Environment.Byte;  LoadUserDriver: PUBLIC PROC =    BEGIN    CTTx.tool.driver[null].user ¬ Null;    CTTx.tool.driver[cardinal].user ¬ Cardinal;    CTTx.tool.driver[longCardinal].user ¬ LongCardinal;    CTTx.tool.driver[array].user ¬ Array;    CTTx.tool.driver[longString].user ¬ String;    CTTx.tool.driver[longDescriptor].user ¬ Descriptor;    CTTx.tool.driver[choice].user ¬ Choice;    CTTx.tool.driver[parameters].user ¬ Parameters;    CTTx.tool.driver[longDisjoint].user ¬ Disjoint;    CTTx.tool.driver[dataStream].user ¬ DataStream;    CTTx.tool.driver[noRoute].user ¬ NoRoute;    CTTx.tool.driver[tooMany].user ¬ TooMany;    CTTx.tool.driver[noProg].user ¬ NoProg;    CTTx.tool.driver[noVers].user ¬ NoVers;    CTTx.tool.driver[returnTMO].user ¬ ReturnTMO;    CTTx.tool.driver[callerAborted].user ¬ CallerAborted;    CTTx.tool.driver[parmInconst].user ¬ ParmInconst;    CTTx.tool.driver[noProc].user ¬ NoProc;    CTTx.tool.driver[unknown].user ¬ Unknown;    CTTx.tool.driver[dataStream2].user ¬ DataStream2;    CTTx.tool.driver[space].user ¬ Space;    CTTx.tool.driver[deadSpace].user ¬ DeadSpace;    CTTx.tool.driver[block].user ¬ Block;    CTTx.tool.driver[invalidArguments].user ¬ InvalidArguments;    CTTx.tool.driver[stackOverflow].user ¬ StackOverflow;    CTTx.tool.bulkProc[1].user ¬ CTTx.SourceWithoutAbort;    CTTx.tool.bulkProc[2].user ¬ CTTx.SinkWatchingForAbort;    CTTx.tool.bulkProc[3].user ¬ CTTx.SinkWatchingForAbort;    CTTx.tool.bulkProc[4].user ¬ CTTx.SinkWithAbort;    CTTx.tool.bulkProc[5].user ¬ CTTx.SourceWithAbort;    CTTx.tool.bulkProc[6].user ¬ CTTx.SinkWatchingForAbort;    CTTx.tool.bulkProc[7].user ¬ CTTx.SourceWithoutAbort;    CTTx.tool.bulkProc[8].user ¬ CTTx.AbortImmediately;    CTTx.tool.bulkProc[9].user ¬ CTTx.AbortImmediately;    CTTx.tool.bulkProc[10].user ¬ CTTx.SinkWatchingForAbort;    CTTx.tool.bulkProc[11].user ¬ CTTx.UserReject;    END;    Catcher: PROC [proc: PROC[timeout: LONG CARDINAL], test: CTTx.TestType] =    BEGIN    uError: CARDINAL;    uArgs: Courier.Arguments;    cError: Courier.ErrorCode;    range: Courier.VersionRange;    timeout: LONG CARDINAL;  --msecs total    BEGIN    ENABLE      BEGIN      ABORTED => {cError ¬ noError};  --handled at a higher level      Courier.Error =>	{cError ¬ errorCode; IF ~CTTx.tool.debug THEN GOTO courier};      Compare => IF ~CTTx.tool.debug THEN GOTO compare;      Courier.RemoteErrorSignalled =>        {uError ¬ errorNumber; uArgs ¬ arguments;	IF ~CTTx.tool.debug THEN GOTO user};      ANY => IF ~CTTx.tool.debug THEN GOTO unknown;      END;    --Computed timeout is twice the average elapsed time for the test * 2 + 1.    --If the last elapsed time is 0, the use a default 10 seconds.    --BEWARE!  The time being mainained is accumulative and in milliseconds.    --The "procs" have the right to ignore "timeout" if it is inappropriate.    IF test IN CTTx.TestType THEN timeout ¬ CTTx.tool.driver[test].duration;    timeout ¬ IF (timeout # 0) AND (CTTx.tool.iterationC > 1) THEN      timeout/(CTTx.tool.iterationC - 1) ELSE 9500;  --msecs/call    BEGIN    ENABLE Courier.VersionMismatch => {range ¬ versionRange; GOTO version};    proc[((timeout/1000) * 2) + 1];    EXITS      version =>        BEGIN	IF mismatch THEN {mismatch ¬ FALSE; RETURN};  --forget it	mismatch ¬ TRUE;  --so we don't recurse forever	CTTx.MsgOut["(User) VersionMismatch - retrying..."L, TRUE, FALSE];	FOR version: CARDINAL DECREASING IN[CTTx.versionL..CTTx.versionH] DO	  <<	  Every time I change a test, the high version number is incremented.	  Then, as this loop decrements, the possibility to run some tests	  is lost.	  >>	  IF version = 13 THEN CTTx.tool.driver[stackOverflow].user ¬ NIL;	  IF version = 12 THEN CTTx.tool.bulkProc[11].user ¬ NIL;	  IF version = 11 THEN CTTx.tool.driver[deadSpace].flag ¬ FALSE;	  IF version = 10 THEN CTTx.tool.driver[block].flag ¬ FALSE;	  IF version = 10 THEN CTTx.tool.driver[dataStream2].flag ¬ FALSE;	  IF version = 9 THEN CTTx.tool.driver[choice].flag ¬ FALSE;	  IF version IN[range.low..range.high] THEN	    BEGIN	    Courier.Delete[handle];	    handle ¬ Courier.Create[	      remote: CTTx.tool.server,	      programNumber: CTTx.program, versionNumber: version,	      zone: CTTx.hyper, classOfService: CTTx.tool.class];	    proc[((timeout/1000) * 2) + 1];	    FormSW.Display[CTTx.tool.formSW];	    CTTx.MsgOut["succeeded"L, FALSE, TRUE];	    EXIT;	    END;	  REPEAT FINISHED => CTTx.MsgOut["failed"L, FALSE, TRUE];	  ENDLOOP;        END;    END;    EXITS      courier =>        BEGIN        CTTx.MsgOut["(User) Unexpected Courier error..."L, TRUE, FALSE];        IF test IN CTTx.TestType THEN CTTx.AppendTestName[test];        CTTx.ProcessCourierError[cError];	--if we were too quick, wait 1/2 interval so caller can compute duration	IF cError = returnTimedOut THEN Process.Pause[	  Process.MsecToTicks[Inline.LowHalf[timeout/2]]];        END;      compare =>        BEGIN        CTTx.MsgOut["(User) Data compare failure in test..."L, TRUE, FALSE];        CTTx.AppendTestName[test];        CTTx.MsgOut[" "L, FALSE, TRUE];        END;      user =>        BEGIN        CTTx.MsgOut[          "(User) Unexpected remote error...processing..."L, TRUE, FALSE];        CTTx.AppendTestName[test];        CTTx.ProcessUserError[uError, uArgs];        END;      unknown =>        BEGIN        CTTx.MsgOut["(User) Unknown error"];        CTTx.AppendTestName[test];        CTTx.MsgOut[" "L, FALSE, TRUE];        END;    END;    END;  Null: CTTx.UserProc =    BEGIN    proc: PROC [timeout: LONG CARDINAL] =      BEGIN      [] ¬ Courier.Call[        cH: handle,        procedureNumber: CTTx.null,        timeoutInSeconds: timeout];      END;    Catcher[proc, null];    END;  Cardinal: CTTx.UserProc =    BEGIN    proc: PROC [timeout: LONG CARDINAL] =      BEGIN      [] ¬ Courier.Call[        cH: handle,        procedureNumber: CTTx.cardinal,        arguments: [@ca, CTTx.CardinalDescribe],        results: [@cr, CTTx.CardinalDescribe], timeoutInSeconds: timeout];      IF ca # cr THEN ERROR Compare;      END;    cr: CARDINAL;    ca: CARDINAL ¬ Inline.LowHalf[System.GetClockPulses[]];    Catcher[proc, cardinal];    END;  LongCardinal: CTTx.UserProc =    BEGIN    proc: PROC [timeout: LONG CARDINAL] =      BEGIN      [] ¬ Courier.Call[        cH: handle,        procedureNumber: CTTx.longCardinal,        arguments: [@ca, CTTx.LongCardinalDescribe],        results: [@cr, CTTx.LongCardinalDescribe],	timeoutInSeconds: timeout];      IF ca # cr THEN ERROR Compare;      END;    cr: LONG CARDINAL;    ca: LONG CARDINAL ¬ System.GetClockPulses[];    Catcher[proc, longCardinal];    END;  Array: CTTx.UserProc =    BEGIN    proc: PROC [timeout: LONG CARDINAL] =      BEGIN      [] ¬ Courier.Call[        cH: handle,        procedureNumber: CTTx.array,        arguments: [@aa, CTTx.ArrayDescribe],        results: [@ar, CTTx.ArrayDescribe],	timeoutInSeconds: timeout];      IF aa # ar THEN ERROR Compare;      END;    A: TYPE = ARRAY [0..20) OF CARDINAL;    aa, ar: A;    FOR i: INTEGER IN [0..20) DO      aa[i] ¬ Inline.LowHalf[System.GetClockPulses[]]; ENDLOOP;    Catcher[proc, array];    END;  String: CTTx.UserProc =    BEGIN    proc: PROC [timeout: LONG CARDINAL] =      BEGIN      [] ¬ Courier.Call[        cH: handle,        procedureNumber: CTTx.longString,        arguments: [@sa, CTTx.StringDescribe],        results: [@sr, CTTx.StringDescribe],	timeoutInSeconds: timeout];      IF ~LS.EqualString[sr, sa] THEN ERROR Compare;      Courier.Free[[@sr, CTTx.StringDescribe], handle.zone];      END;    sr: LONG STRING ¬ NIL;    sa: LONG STRING ¬ "Test STRING"L;    Catcher[proc, longString];    END;  Descriptor: CTTx.UserProc =    BEGIN    proc: PROC [timeout: LONG CARDINAL] =      BEGIN      [] ¬ Courier.Call[        cH: handle,        procedureNumber: CTTx.longDescriptor,        arguments: [@da, CTTx.DescriptorDescribe],        results: [@dr, CTTx.DescriptorDescribe],	timeoutInSeconds: timeout];      IF LENGTH[da] # LENGTH[dr] THEN ERROR Compare;      FOR index: INTEGER IN [0..LENGTH[da]) DO        IF da[index] # dr[index] THEN ERROR Compare; ENDLOOP;      Courier.Free[[@dr, CTTx.DescriptorDescribe], handle.zone];      END;    D: TYPE = LONG DESCRIPTOR FOR ARRAY [0..20) OF CARDINAL;    A: TYPE = ARRAY [0..20) OF CARDINAL;    aa: A;    da: D ¬ DESCRIPTOR[aa];    dr: D ¬ DESCRIPTOR[NIL, 0];    FOR index: INTEGER IN [0..LENGTH[aa]) DO      aa[index] ¬ Inline.LowHalf[System.GetClockPulses[]]; ENDLOOP;    Catcher[proc, longDescriptor];    END;  Choice: CTTx.UserProc =    BEGIN    proc: PROC [timeout: LONG CARDINAL] =      BEGIN      [] ¬ Courier.Call[        cH: handle,        procedureNumber: CTTx.choice,        arguments: [@va, CTTx.ChoiceDescribe],        results: [@vr, CTTx.ChoiceDescribe],	timeoutInSeconds: timeout];      IF va # vr THEN ERROR Compare;      Courier.Free[[@vr, CTTx.ChoiceDescribe], handle.zone];      END;    vr: CTTx.VariantRecord;    va: medium CTTx.VariantRecord ¬ [      Inline.LowHalf[System.GetGreenwichMeanTime[]],      medium[        Inline.HighHalf[System.GetClockPulses[]],	Inline.LowHalf[System.GetClockPulses[]]]];    Catcher[proc, choice];    END;  Parameters: CTTx.UserProc =    BEGIN    proc: PROC [timeout: LONG CARDINAL] =      BEGIN      [] ¬ Courier.Call[        cH: handle,        procedureNumber: CTTx.parameters,        arguments: [@pa, CTTx.ParametersDescribe],        results: [@pr, CTTx.ParametersDescribe],	timeoutInSeconds: timeout];      IF pa # pr THEN ERROR Compare;      END;    pa: CARDINAL ¬ Inline.LowHalf[System.GetClockPulses[]];    pr: CARDINAL;    Catcher[proc, parameters];    END;  Disjoint: CTTx.UserProc =    BEGIN    proc: PROC [timeout: LONG CARDINAL] =      BEGIN      [] ¬ Courier.Call[        cH: handle,        procedureNumber: CTTx.longDisjoint,        arguments: [@da, CTTx.DisjointDescribe],        results: [@dr, CTTx.DisjointDescribe],	timeoutInSeconds: timeout];      IF da­ # dr­ THEN ERROR Compare;      Courier.Free[[@dr, CTTx.DisjointDescribe], handle.zone];      END;    pa: CARDINAL ¬ Inline.LowHalf[System.GetClockPulses[]];    dr: LONG POINTER TO CARDINAL ¬ NIL;    da: LONG POINTER TO CARDINAL ¬ @pa;    Catcher[proc, longDisjoint];    END;  DataStream: CTTx.UserProc =    BEGIN    proc: PROC [timeout: LONG CARDINAL] =      BEGIN      timer: System.TimerHandle;      elapsed: LONG CARDINAL ¬ 0;      FOR stageNumber IN CTTx.StageNumber DO        ENABLE UNWIND => Courier.ReleaseDataStream[handle];	timer ¬ System.CreateIntervalTimer[];	BEGIN	ENABLE	  Courier.RemoteErrorSignalled => {arguments[]; CONTINUE};	stream ¬ Courier.Call[	  cH: handle,	  procedureNumber: CTTx.dataStream,	  arguments: [@stageNumber, CTTx.CardinalDescribe],	  timeoutInSeconds: timeout, requestDataStream: TRUE];	CTTx.tool.bulkProc[stageNumber].user[stream !	  Stream.Attention, ABORTED => CONTINUE];	Courier.ReleaseDataStream[handle];	END;	elapsed ¬ elapsed + System.GetIntervalTime[timer];	ENDLOOP;      elapsed ¬ elapsed/LONG[(1000*LAST[CTTx.StageNumber])] + 1;      CTTx.tool.timeout ¬ elapsed;  --to be used next time      IF elapsed < CTTx.tool.minTimeout THEN CTTx.tool.minTimeout ¬  elapsed;      IF elapsed > CTTx.tool.maxTimeout THEN CTTx.tool.maxTimeout ¬ elapsed;      END;    stream: Stream.Handle;    stageNumber: CTTx.StageNumber;    Catcher[proc, dataStream];    END;  DataStream2: CTTx.UserProc =    BEGIN    proc: PROC [timeout: LONG CARDINAL] =      BEGIN      timer: System.TimerHandle;      elapsed: LONG CARDINAL ¬ 0;      timer ¬ System.CreateIntervalTimer[];      FOR stageNumber IN CTTx.StageNumber DO        IF CTTx.tool.bulkProc[stageNumber].user = NIL THEN LOOP;	[] ¬ Courier.Call[	  cH: handle,	  procedureNumber: CTTx.dataStream2,	  arguments: [@stageNumber, CTTx.CardinalDescribe],	  timeoutInSeconds: timeout, streamCheckoutProc: streamProc !	  Courier.RemoteErrorSignalled => {arguments[]; CONTINUE}];	ENDLOOP;      elapsed ¬ System.GetIntervalTime[timer];      elapsed ¬ elapsed/LONG[(1000*LAST[CTTx.StageNumber])] + 1;      CTTx.tool.timeout ¬ elapsed;  --to be used next time      IF elapsed < CTTx.tool.minTimeout THEN CTTx.tool.minTimeout ¬  elapsed;      IF elapsed > CTTx.tool.maxTimeout THEN CTTx.tool.maxTimeout ¬ elapsed;      END;    streamProc: PROC[cH: Courier.Handle] =      BEGIN      CTTx.tool.bulkProc[stageNumber].user[cH.sH !        Stream.Attention, ABORTED => CONTINUE];      END;    stageNumber: CTTx.StageNumber;    Catcher[proc, dataStream2];    END;  Space: CTTx.UserProc =    BEGIN    proc: PROC [timeout: LONG CARDINAL] =      BEGIN      S: TYPE = ARRAY [0..20) OF CARDINAL;      sa, sr: S;      seed: INTEGER = Inline.LowHalf[System.GetClockPulses[]];      FOR i: INTEGER IN [0..20) DO sa[i] ¬ seed + i; ENDLOOP;      [] ¬ Courier.Call[        cH: handle,        procedureNumber: CTTx.space,        arguments: [@sa, CTTx.SpaceDescribe],        results: [@sr, CTTx.SpaceDescribe],        timeoutInSeconds: timeout];      IF sa # sr THEN ERROR Compare;      END;    Catcher[proc, space];    END;  DeadSpace: CTTx.UserProc =    BEGIN    proc: PROC [timeout: LONG CARDINAL] =      BEGIN      S: TYPE = ARRAY [0..20) OF CARDINAL;      sa, sr: S;      seed: INTEGER = Inline.LowHalf[System.GetClockPulses[]];      FOR i: INTEGER IN[0..LENGTH[sa]) DO        sa[i] ¬ seed + i; sr[i] ¬ LAST[CARDINAL]; ENDLOOP;      [] ¬ Courier.Call[        cH: handle,        procedureNumber: CTTx.deadSpace,        arguments: [@sa, CTTx.DeadSpaceDescribe],        results: [@sr, CTTx.DeadSpaceDescribe],        timeoutInSeconds: timeout];      FOR i: INTEGER IN[0..LENGTH[sr]/2) DO         IF sr[i] # LAST[CARDINAL] THEN ERROR Compare; ENDLOOP;      FOR i: INTEGER IN[LENGTH[sr]/2..20) DO         IF sa[i] # sr[i] THEN ERROR Compare; ENDLOOP;      END;    Catcher[proc, deadSpace];    END;  Block: CTTx.UserProc =    BEGIN    proc: PROC [timeout: LONG CARDINAL] =      BEGIN      sr: LONG STRING;      sa: LONG STRING ¬ "ABCDEFGHIJKLMNOPQRSTUVWXYZ"L;      sa.length ¬ (Inline.LowHalf[System.GetClockPulses[]] MOD sa.maxlength) + 1;      [] ¬ Courier.Call[        cH: handle,        procedureNumber: CTTx.block,        arguments: [@sa, CTTx.BlockDescribe],        results: [@sr, CTTx.BlockDescribe],        timeoutInSeconds: timeout];      IF ~LS.EqualString[sr, sa] THEN ERROR Compare;      Courier.Free[[@sr, CTTx.BlockDescribe], handle.zone];      END;    Catcher[proc, block];    END;  NoRoute: CTTx.UserProc =    BEGIN    END;  Unknown: CTTx.UserProc =    BEGIN    END;  TooMany: CTTx.UserProc =    BEGIN    END;  NoProg: CTTx.UserProc =    BEGIN    OPEN h: LOOPHOLE[handle, LONG POINTER TO Courier.Object];    proc: PROC [timeout: LONG CARDINAL] =      BEGIN      [] ¬ Courier.Call[        cH: handle,        procedureNumber: CTTx.null,        timeoutInSeconds: timeout !        Courier.Error =>          IF errorCode # noSuchProgramNumber THEN            BEGIN            CTTx.MsgOut["(User) Expected 'noSuchProgramNumber', but got..."L];            REJECT;            END          ELSE GOTO exit];      CTTx.MsgOut[        "(User) Expected 'noSuchProgramNumber', but got..."L, TRUE, FALSE];      CTTx.MsgOut["no error"L, FALSE, TRUE];      EXITS exit => NULL;      END;    h.programNumber ¬ CTTx.program - 4;    Catcher[proc, noProg];    h.programNumber ¬ CTTx.program;    END;  NoVers: CTTx.UserProc =    BEGIN    OPEN h: LOOPHOLE[handle, LONG POINTER TO Courier.Object];    proc: PROC [timeout: LONG CARDINAL] =      BEGIN      [] ¬ Courier.Call[        cH: handle,        procedureNumber: CTTx.null,        timeoutInSeconds: timeout !        Courier.VersionMismatch => GOTO exit];      CTTx.MsgOut[        "(User) Expected 'VersionMismatch', but got no error"L, TRUE, FALSE];      EXITS exit => NULL;      END;    h.versionNumber ¬ CTTx.versionL - 1;    Catcher[proc, noVers];    h.versionNumber ¬ CTTx.versionL;    END;  CallerAborted: CTTx.UserProc =    BEGIN    killer: PROC = {Process.Pause[3]; Process.Abort[caller]};    scop: PROCEDURE [cH: Courier.Handle] = {Process.Detach[FORK killer[]]};    proc: PROC [timeout: LONG CARDINAL] =      BEGIN      [] ¬ Courier.Call[        cH: handle,        procedureNumber: CTTx.returnTMO,        timeoutInSeconds: timeout,	streamCheckoutProc: scop !        ABORTED => GOTO exit];      CTTx.MsgOut["(User) Expected 'ABORTED', but got..."L, TRUE, FALSE];      CTTx.MsgOut["no error"L, FALSE, TRUE];      EXITS exit => NULL;      END;    caller: PROCESS ¬ Process.GetCurrent[];  --record for killer    Catcher[proc, callerAborted];    END;  ReturnTMO: CTTx.UserProc =    BEGIN    proc: PROC [timeout: LONG CARDINAL] =      BEGIN      [] ¬ Courier.Call[        cH: handle,        procedureNumber: CTTx.returnTMO,        timeoutInSeconds: 1 !        Courier.Error =>          IF errorCode # returnTimedOut THEN            BEGIN            CTTx.MsgOut["(User) Expected 'returnTimedOut', but got..."L];            REJECT;            END          ELSE GOTO exit];      CTTx.MsgOut["(User) Expected 'returnTimedOut', but got..."L, TRUE, FALSE];      CTTx.MsgOut["no error"L, FALSE, TRUE];      EXITS exit => NULL;      END;    Catcher[proc, returnTMO];    END;  ParmInconst: CTTx.UserProc =    BEGIN    proc: PROC [timeout: LONG CARDINAL] =      BEGIN      [] ¬ Courier.Call[        cH: handle,        procedureNumber: CTTx.longCardinal,        arguments: [@ca, CTTx.LongCardinalDescribe],        results: [@cr, CTTx.CardinalDescribe], timeoutInSeconds: timeout !        Courier.Error =>          IF errorCode # parameterInconsistency THEN            BEGIN            CTTx.MsgOut[              "(User) Expected 'parameterInconsistency', but got..."L];            REJECT;            END          ELSE GOTO exit];      CTTx.MsgOut[        "(User) Expected 'parameterInconsistency', but got..."L, TRUE, FALSE];      CTTx.MsgOut["no error"L, FALSE, TRUE];      EXITS exit => NULL;      END;    cr: CARDINAL;    ca: LONG CARDINAL ¬ System.GetClockPulses[];    Catcher[proc, parmInconst];    END;  InvalidArguments: CTTx.UserProc =    BEGIN    proc: PROC [timeout: LONG CARDINAL] =      BEGIN      [] ¬ Courier.Call[        cH: handle,        procedureNumber: CTTx.invalidArguments,        timeoutInSeconds: timeout !        Courier.Error =>          IF errorCode # invalidArguments THEN            BEGIN            CTTx.MsgOut["(User) Expected 'invalidArguments', but got..."L];            REJECT;            END          ELSE GOTO exit];      CTTx.MsgOut[        "(User) Expected 'invalidArguments', but got..."L, TRUE, FALSE];      CTTx.MsgOut["no error"L, FALSE, TRUE];      EXITS exit => NULL;      END;    Catcher[proc, invalidArguments];    END;  NoProc: CTTx.UserProc =    BEGIN    proc: PROC [timeout: LONG CARDINAL] =      BEGIN      [] ¬ Courier.Call[        cH: handle,        procedureNumber: LAST[CARDINAL],        timeoutInSeconds: timeout !        Courier.Error =>          IF errorCode # noSuchProcedureNumber THEN            BEGIN            CTTx.MsgOut["(User) Expected 'noSuchProcedureNumber', but got..."L];            REJECT;            END          ELSE GOTO exit];      CTTx.MsgOut[        "(User) Expected 'noSuchProcedureNumber', but got..."L, TRUE, FALSE];      CTTx.MsgOut["no error"L, FALSE, TRUE];      EXITS exit => NULL;      END;    Catcher[proc, noProc];    END;  StackOverflow: CTTx.UserProc =    BEGIN    proc: PROC [timeout: LONG CARDINAL] =      BEGIN      sor: CTTx.StackOverflowArgs;      soa: CTTx.StackOverflowArgs ¬ DESCRIPTOR[array­];      [] ¬ Courier.Call[        cH: handle,        procedureNumber: CTTx.stackOverflow,	arguments: [@soa, CTTx.StackOverflowDescribe],	results: [@sor, CTTx.StackOverflowDescribe],        timeoutInSeconds: timeout];      IF LENGTH[soa] # LENGTH[sor] THEN ERROR Compare;      FOR i: INTEGER IN[0..LENGTH[soa]) DO        IF ~LS.EqualString[soa[i]­, sor[i]­] THEN ERROR Compare; ENDLOOP;      Courier.Free[[@sor, CTTx.StackOverflowDescribe], handle.zone];      END;    Array: TYPE = ARRAY[0..100) OF LONG POINTER TO LONG STRING;    array: LONG POINTER TO Array ¬ CTTx.hyper.NEW[Array];    string: LONG STRING ¬ "ABCDEFGHIJKLMNOPQRSTUVWXYZ"L;    FOR i: INTEGER IN[0..LENGTH[array­]) DO array[i] ¬ LONG[@string]; ENDLOOP;    Catcher[proc, stackOverflow];    handle.zone.FREE[@array];    END;  Establish: PUBLIC FormSW.ProcType =    BEGIN    stringProc: Format.StringProc = {LS.AppendString[string, s]};    proc: PROC [timeout: LONG CARDINAL] =      BEGIN      [] ¬ Courier.Call[        cH: handle,        procedureNumber: CTTx.establish,        arguments: [@ea, CTTx.EstablishDescribe],        results: [@er, CTTx.EstablishDescribe], timeoutInSeconds: timeout];      IF ea # er THEN ERROR Compare;      LS.AppendString[string, "(User) Test started with server at "L];      Format.NetworkAddress[stringProc, CTTx.tool.server, octal];      CTTx.MsgOut[string];      END;    string: STRING ¬ [80];    er: System.NetworkAddress;    ea: System.NetworkAddress ¬ Courier.LocalSystemElement[];    establish: CTTx.TestType ¬ LOOPHOLE[LOOPHOLE[LAST[CTTx.TestType], CARDINAL] + 1];    Catcher[proc, establish];    END;  CreateHandle: PUBLIC FormSW.ProcType =    BEGIN    proc: PROC [timeout: LONG CARDINAL] =      BEGIN      handle ¬ Courier.Create[        remote: CTTx.tool.server,	programNumber: CTTx.program, versionNumber: CTTx.versionH,	zone: CTTx.hyper, classOfService: CTTx.tool.class];      END;    create: CTTx.TestType ¬ LOOPHOLE[LOOPHOLE[LAST[CTTx.TestType], CARDINAL] + 2];    CTTx.MsgOut["(User) Creating object ..."L, TRUE, FALSE];    Catcher[proc, create];    CTTx.MsgOut["..done"L, FALSE, TRUE];    END;  DeleteHandle: PUBLIC FormSW.ProcType =    BEGIN    proc: PROC [timeout: LONG CARDINAL] =      BEGIN      Courier.Delete[handle];      END;    delete: CTTx.TestType ¬ LOOPHOLE[LOOPHOLE[LAST[CTTx.TestType], CARDINAL] + 3];    CTTx.MsgOut["(User) Deleting object..."L, TRUE, FALSE];    Catcher[proc, delete];    CTTx.MsgOut["..done"L, FALSE, TRUE];    handle ¬ NIL;    END;  END...  
-- File: XStreamTest.mesa - last edit:-- AOF                  4-Jun-87 12:06:40-- Create by FormSWLayoutTool on 29-Nov-85 14:40-- Copyright (C) 1985, 1986, 1987 by Xerox Corporation. All rights reserved.DIRECTORY  AddressTranslation USING [Error, NetworkAddress, StringToNetworkAddress],  Courier USING [    Arguments, Call, Create, Delete, Description, Dispatcher, Error,    ExportRemoteProgram, Free, Handle, LocalSystemElement,    NoSuchProcedureNumber, nullParameters, RemoteErrorSignalled, Results,    SignalRemoteError, UnexportRemoteProgram],  CourierOps USING [    StackBlockHandle, StackBlockPop, StackBlockPush, stackPageLength],  Environment USING [Block, bytesPerPage],  FileName USING [AllocVFN, FreeVFN, PackFilename, VFN],  Format USING [LongNumber, NetworkAddress, Number, NumberFormat, StringProc],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType, CommandItem,    Enumerated, EnumeratedItem, line0, line1, line2, ProcType, StringItem],  Heap USING [systemZone],  MFile USING [Acquire, Delete, Handle],  MStream USING [Error, ErrorCode, Handle, ReadOnly, WriteOnly],  Process USING [    Abort, CancelAbort, GetCurrent, GetPriority, MsecToTicks, Pause, Priority,     priorityNormal, SetPriority],  Put USING [CR, Text],  Stream USING [Block, CompletionCode, Handle, SubSequenceType],  String USING [CopyToNewString, Empty],  System USING [HostNumber, NetworkAddress, nullNetworkAddress],  Tool USING [Create, MakeFileSW, MakeFormSW, MakeSWsProc, UnusedLogName],  ToolDriver USING [Address, NoteSWs, RemoveSWs],  ToolWindow USING [TransitionProcType],  Window USING [Handle],  WindowFont USING [CharWidth],  XStream USING [    CancelTransfer, Create, DescribeSink, DescribeSource, Destroy,    Handle, Make, ServerCheckout, UserCheckout],  XStreamOps USING [StartProtocol, StopProtocol];XStreamTest: PROGRAM  IMPORTS    AddressTranslation, Courier, CourierOps, FileName, Format, FormSW, Heap,    MFile, MStream, Process, Put, String, Tool, ToolDriver, WindowFont,    XStream, XStreamOps = {  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = MACHINE DEPENDENT RECORD [    msgSW(0): Window.Handle ¬ NIL,    formSW(2): Window.Handle ¬ NIL,    fileSW(4): Window.Handle ¬ NIL,    mode(6): Mode ¬ proc,    test(7): Test ¬ normal,    sink(8): LONG STRING ¬ NIL,    source(10): LONG STRING ¬ NIL,    process(12): PROCESS ¬ NIL,    log(13): BOOLEAN ¬ TRUE,    count(14): CARDINAL ¬ 0];  FormItems: TYPE = {doit, abort, log, mode, test, sink, source};  Mode: TYPE = {null, stream, proc, deferred};  Test: TYPE = {normal, beginning, middle, ending, race};  Proc: TYPE = {null, produce, consume};  Error: TYPE = MStream.ErrorCode;  pause: NATURAL = 10000;  --msecs to use for pauses in 'race' test  TransferArguments: TYPE = RECORD[file: LONG STRING, bulk: XStream.Handle];  UserProcType: TYPE = PROC[    sourceAddr, sinkAddr: System.NetworkAddress,    sourceFilename, sinkFilename: LONG STRING];  version: CARDINAL = 1;  program: LONG CARDINAL = LAST[CARDINAL];  dnf: Format.NumberFormat = [10, FALSE, FALSE, 0];  hnf: Format.NumberFormat = [16, FALSE, FALSE, 0];  Outproc: Format.StringProc = {IF data.log THEN Put.Text[data.fileSW, s]};  Outserver: PROC[header: BOOLEAN, s: LONG STRING] =    BEGIN    IF header THEN      BEGIN      Outproc["Server("L];      Format.Number[Outproc, Process.GetCurrent[], hnf];      Outproc["H):	"L];      END;    Outproc[s];    END;  --Outserver  Outuser: PROC[header: BOOLEAN, s: LONG STRING] =    BEGIN    IF header THEN      BEGIN      Outproc["User("L];      Format.Number[Outproc, Process.GetCurrent[], hnf];      Outproc["H):	"L];      END;    Outproc[s];    END;  --Outuser  Outdesc: PROC[header: BOOLEAN, s: LONG STRING] =    BEGIN    IF header THEN      BEGIN      Outproc["Desc("L];      Format.Number[Outproc, Process.GetCurrent[], hnf];      Outproc["H):	"L];      END;    Outproc[s];    END;  --Outuser  ErrorString: TYPE = ARRAY Error[invalidHandle..invalidFile] OF STRING;  data: DataHandle ¬ NIL;  wh: Window.Handle ¬ NIL;  me: System.HostNumber ¬ Courier.LocalSystemElement[].host;  z: UNCOUNTED ZONE ¬ Heap.systemZone;  --to make use of FileName procs  Bug: ERROR = CODE;  Gunned: ERROR = CODE;  Address: PROC[s: LONG STRING] RETURNS[System.NetworkAddress] =    BEGIN    ENABLE AddressTranslation.Error => GOTO error;    RETURN[AddressTranslation.StringToNetworkAddress[s].addr];    EXITS error => RETURN[System.nullNetworkAddress];    END;   Copy: PROC[sink, source: Stream.Handle] =    BEGIN    --let's not be fancy for now    total: LONG CARDINAL ¬ 0;    sst: Stream.SubSequenceType;    why: Stream.CompletionCode ¬ normal;    buffer: CourierOps.StackBlockHandle ¬ CourierOps.StackBlockPush[NIL];    bufferSize: INTEGER = CourierOps.stackPageLength * Environment.bytesPerPage;    block: Stream.Block ¬ [blockPointer: LOOPHOLE[buffer],      startIndex: 0, stopIndexPlusOne: bufferSize];    BEGIN    ENABLE      BEGIN      Courier.Error => ERROR Bug;      UNWIND => {buffer.nextBlock ¬ NIL; [] ¬ CourierOps.StackBlockPop[buffer]};      END;    UNTIL why = endOfStream DO      ENABLE ABORTED => EXIT;  --guy at other end miffed 'bout somethun      IF data.test = beginning THEN ERROR ABORTED;  --bail out now      block.stopIndexPlusOne ¬ bufferSize;  --always set length      [block.stopIndexPlusOne, why, sst] ¬ source.get[        source, block, source.options];      total ¬ total + block.stopIndexPlusOne;      SELECT data.test FROM        normal => NULL;  --let it run	beginning => ERROR Gunned;  --bail out now	middle => IF total > 4096 THEN ERROR Gunned;	ending => IF why = endOfStream THEN ERROR Gunned;	ENDCASE;      sink.put[sink, block, why = endOfStream];  --close off the stream      ENDLOOP;    END;    buffer.nextBlock ¬ NIL; [] ¬ CourierOps.StackBlockPop[buffer];    END;  --Copy  DescribeAsSink: Courier.Description =    BEGIN    sink: LONG POINTER TO TransferArguments ¬      notes.noteSize[SIZE[TransferArguments]];    Outdesc[TRUE, "DescribeAsSink entered("L];    Outproc[SELECT notes.operation FROM      fetch => "fetch"L, store => "store"L, ENDCASE => "free"L];    Outproc[")\n"L];    notes.noteString[@sink.file];    notes.noteParameters[@sink.bulk, XStream.DescribeSink];    Outdesc[TRUE, "DescribeAsSink exited("L];    Outproc[SELECT notes.operation FROM      fetch => "fetch"L, store => "store"L, ENDCASE => "free"L];    Outproc[")\n"L];    END;  --DescribeAsSink  DescribeAsSource: Courier.Description =    BEGIN    source: LONG POINTER TO TransferArguments ¬      notes.noteSize[SIZE[TransferArguments]];    Outdesc[TRUE, "DescribeAsSource entered("L];    Outproc[SELECT notes.operation FROM      fetch => "fetch"L, store => "store"L, ENDCASE => "free"L];    Outproc[")\n"L];    notes.noteString[@source.file];    notes.noteParameters[@source.bulk, XStream.DescribeSource];    Outdesc[TRUE, "DescribeAsSource exited("L];    Outproc[SELECT notes.operation FROM      fetch => "fetch"L, store => "store"L, ENDCASE => "free"L];    Outproc[")\n"L];    END;  --DescribeAsSource  Dispatcher: Courier.Dispatcher =    BEGIN    SELECT procedureNumber FROM      Proc[produce].ORD => ServerProducer[cH, arguments, results];      Proc[consume].ORD => ServerConsumer[cH, arguments, results];      ENDCASE => ERROR Courier.NoSuchProcedureNumber;    END;  --Dispatcher  ServerConsumer: PROC[    cH: Courier.Handle, arguments: Courier.Arguments, results: Courier.Results] =    BEGIN    WriteOnly: PROC[h: XStream.Handle] =      BEGIN      bytes: LONG CARDINAL;      sink, source: Stream.Handle ¬ NIL;      BEGIN      Outserver[TRUE, "WriteOnly proc entered\n"L];      Outserver[TRUE, "Opening WriteOnly file("L];      Outproc[a.file]; Outproc[")\n"L];      sink ¬ MStream.WriteOnly[a.file, [,], unknown !        MStream.Error => {error ¬ code; GOTO nofile}];      source ¬ XStream.Create[h];      Copy[sink: sink, source: source !        Gunned => {error ¬ invalidFile; GOTO gunned};	ABORTED => {error ¬ invalidFile; GOTO aborted};	Courier.Error => {error ¬ fileNotAvailable; GOTO courier}];      source.delete[source];      bytes ¬ sink.getPosition[sink]; sink.delete[sink];      Outserver[TRUE, "Closed WriteOnly file(bytes: "L];      Format.LongNumber[Outproc, bytes, dnf]; Outproc[")\n"L];      EXITS        aborted =>	  BEGIN	  Outserver[TRUE, "Source stream ABORTED by remote("L];	  Outproc[a.file]; Outproc[")\n"L];	  sink.delete[sink];  --get rid of local stream	  MFile.Delete[MFile.Acquire[a.file, delete, [,]]];	  Outserver[TRUE, "Truncated file deleted\n"L];	  END;	nofile =>	  BEGIN	  Outserver[TRUE, "WriteOnly sink unavailable("L];	  Outproc[a.file]; Outproc[")\n"L];	  Outserver[TRUE, "CancelTransfer\n"L];	  XStream.CancelTransfer[a.bulk];	  END;	gunned =>	  BEGIN	  Outserver[TRUE, "WriteOnly file gunned("L];	  Outproc[a.file]; Outproc[")\n"L];	  sink.delete[sink];  --get rid of local stream	  MFile.Delete[MFile.Acquire[a.file, delete, [,]]];	  Outserver[TRUE, "Truncated file deleted\n"L];	  XStream.CancelTransfer[a.bulk];	  Outserver[TRUE, "CancelTransfer\n"L];	  END;	courier =>	  BEGIN	  Outserver[TRUE, "WriteOnly source unavailable("L];	  Outproc[a.file]; Outproc[")\n"L];	  sink.delete[sink];  --get rid of local stream	  MFile.Delete[MFile.Acquire[a.file, delete, [,]]];	  Outserver[TRUE, "Truncated file deleted\n"L];	  END;      END;      Outserver[TRUE, "WriteOnly exit\n"L];      END;  --WriteOnly    error: Error ¬ other;  --set recognizable default    a: TransferArguments ¬ [file: NIL, bulk: NIL];    Outserver[TRUE, "Consumer called("L];    Format.LongNumber[Outproc, cH, hnf]; Outproc["H­) by "L];    Format.NetworkAddress[Outproc, cH.remote, octal]; Outproc["\n"L];    arguments[[@a, DescribeAsSource]];  --first get'm, then use'm    XStream.ServerCheckout[cH, [proc[WriteOnly]] !      Courier.Error =>	BEGIN	Outserver[TRUE, "ServerConsumer source unavailable("L];	Outproc[a.file]; Outproc[")\n"L];	error ¬ fileNotAvailable;	CONTINUE;	END];    Courier.Free[[@a, DescribeAsSource], cH.zone];    IF error = other THEN      BEGIN      [] ¬ results[];  --tell'm were finished      Outserver[TRUE, "Consume exit\n"L];      END    ELSE      BEGIN      Outserver[TRUE, "Consume signalling remote error\n"L];      Courier.SignalRemoteError[Error[error].ORD];      END;    END;  --ServerConsumer  ServerProducer: PROC[    cH: Courier.Handle, arguments: Courier.Arguments, results: Courier.Results] =    BEGIN    ReadOnly: PROC[h: XStream.Handle] =      BEGIN      bytes: LONG CARDINAL;      sink, source: Stream.Handle ¬ NIL;      Outserver[TRUE, "ReadOnly proc enter\n"L];      BEGIN      Outserver[TRUE, "Opening ReadOnly file("L];      Outproc[a.file]; Outproc[")\n"L];      source ¬ MStream.ReadOnly[a.file, [,] !	MStream.Error => {error ¬ code; GOTO nofile}];      sink ¬ XStream.Create[h];  --then the remote stream      Copy[sink: sink, source: source !        Gunned => {error ¬ invalidFile; GOTO gunned};        ABORTED => {error ¬ invalidFile; GOTO aborted};	Courier.Error => {error ¬ fileNotAvailable; GOTO courier}];      sink.delete[sink];  --delete remote stream      bytes ¬ source.getPosition[source]; source.delete[source];      Outserver[TRUE, "Closed ReadOnly file(bytes:  "L];      Format.LongNumber[Outproc, bytes, dnf]; Outproc[")\n"L];      EXITS	aborted =>	  BEGIN	  source.delete[source]; sink.delete[sink];	  Outserver[TRUE, "Sink stream ABORTED by remote("L];	  Outproc[a.file]; Outproc[")\n"L];	  END;	nofile =>	  BEGIN	  Outserver[TRUE, "ReadOnly file unavailable("L];	  Outproc[a.file]; Outproc[")\n"L];	  Outserver[TRUE, "CancelTransfer\n"L];	  XStream.CancelTransfer[h];	  END;	gunned =>	  BEGIN	  source.delete[source]; sink.delete[sink];	  Outserver[TRUE, "ReadOnly file gunned("L];	  Outproc[a.file]; Outproc[")\n"L];	  Outserver[TRUE, "CancelTransfer\n"L];	  XStream.CancelTransfer[h];	  END;	courier =>	  BEGIN	  source.delete[source]; sink.delete[sink];	  Outserver[TRUE, "ReadOnly sink unavailable("L];	  Outproc[a.file]; Outproc[")\n"L];	  END;      END;      Outserver[TRUE, "ReadOnly proc exit\n"L];      END;  --ReadOnly    error: Error ¬ other;    a: TransferArguments ¬ [file: NIL, bulk: NIL];    Outserver[TRUE, "Produce called by "L];    Format.NetworkAddress[Outproc, cH.remote, octal]; Outproc["\n"L];    arguments[[@a, DescribeAsSink]];  --first get'm, then use'm    XStream.ServerCheckout[cH, [proc[ReadOnly]] !      Courier.Error =>	BEGIN	Outserver[TRUE, "ServerProducer sink unavailable("L];	Outproc[a.file]; Outproc[")\n"L];	error ¬ fileNotAvailable;	CONTINUE;	END];    Courier.Free[[@a, DescribeAsSink], cH.zone];    IF error = other THEN      BEGIN      Outserver[TRUE, "Produce exit\n"L];      [] ¬ results[];  --tell'm were finished      END    ELSE      BEGIN      Outserver[TRUE, "Produce signalling remote error\n"L];      Courier.SignalRemoteError[Error[error].ORD];      END;    END;  --ServerProducer  ThreeParty: UserProcType =    BEGIN    <<This is the 3-party proc>>    producer, consumer: PROCESS ¬ NIL;    h: XStream.Handle ¬ XStream.Make[[deferred[sinkAddr, sourceAddr]]];    Outuser[TRUE, "ThreeParty enter\n"L];    producer ¬ FORK ThreePartyProducer[[sourceFilename, h], sourceAddr];    consumer ¬ FORK ThreePartyConsumer[[sinkFilename, h], sinkAddr];    BEGIN    ENABLE ABORTED =>      {Process.Abort[producer]; Process.Abort[consumer]; RETRY};    JOIN producer; JOIN consumer;  --then get'm back    END;    Outuser[TRUE, "ThreeParty destroy request\n"L];    XStream.Destroy[h];  --then get rid of handle    Outuser[TRUE, "ThreeParty exit\n"L];    END;  --ThreeParty  ThreePartyConsumer: PROC[    a: TransferArguments, sinkAddr: System.NetworkAddress] =    BEGIN    sinkCourier: Courier.Handle ¬ Courier.Create[      sinkAddr, program, version, z, bulk];    Outuser[TRUE, "ThreePartyConsumer enter to "L];    Format.NetworkAddress[Outproc, sinkCourier.remote, octal]; Outproc["\n"L];    Outuser[TRUE, "Sink file("L]; Outproc[a.file]; Outproc[")\n"L];    IF (data.test = race) AND ((data.count MOD 2) = 0) THEN      BEGIN      Outuser[TRUE, "ThreePartyConsumer pausing "L];      Format.Number[Outproc, pause, dnf];      Outuser[FALSE, " msecs\n"L];      Process.Pause[Process.MsecToTicks[pause]];      END;    [] ¬ Courier.Call[      cH: sinkCourier, arguments: [@a, DescribeAsSource],      procedureNumber: Proc[consume].ORD,      streamCheckoutProc: XStream.UserCheckout !      Courier.RemoteErrorSignalled =>	BEGIN	arguments[Courier.nullParameters];	Outuser[TRUE, "ThreePartyConsumer remote error("L];	PrintError[errorNumber]; Outproc[")\n"L];	CONTINUE;	END];    Courier.Delete[sinkCourier];    Outuser[TRUE, "ThreePartyConsumer exit\n"L];    END;  --ThreePartyConsumer  ThreePartyProducer: PROC[    a: TransferArguments, sourceAddr: System.NetworkAddress] =    BEGIN    sourceCourier: Courier.Handle ¬ Courier.Create[      sourceAddr, program, version, z, bulk];    Outuser[TRUE, "ThreePartyProducer enter to "L];    Format.NetworkAddress[Outproc, sourceCourier.remote, octal]; Outproc["\n"L];    Outuser[TRUE, "Source file("L]; Outproc[a.file]; Outproc[")\n"L];    IF (data.test = race) AND ((data.count MOD 2) # 0) THEN      BEGIN      Outuser[TRUE, "ThreePartyProducer pausing "L];      Format.Number[Outproc, pause, dnf];      Outuser[FALSE, " msecs\n"L];      Process.Pause[Process.MsecToTicks[pause]];      END;    [] ¬ Courier.Call[      cH: sourceCourier, arguments: [@a, DescribeAsSink],      procedureNumber: Proc[produce].ORD,      streamCheckoutProc: XStream.UserCheckout !      Courier.RemoteErrorSignalled =>	BEGIN	arguments[Courier.nullParameters];	Outuser[TRUE, "ThreePartyProducer remote error("L];	PrintError[errorNumber]; Outproc[")\n"L];	CONTINUE;	END];    Courier.Delete[sourceCourier];    Outuser[TRUE, "ThreePartyProducer exit("L];    Format.LongNumber[Outproc, sourceCourier, hnf]; Outproc["H­)\n"L];    END;  --ThreePartyProducer  TwoPartyConsumer: PROC[    sourceAddr: System.NetworkAddress, file: LONG STRING, sink: XStream.Handle] =    BEGIN    a: TransferArguments ¬ [file: file, bulk: sink];    cH: Courier.Handle ¬ Courier.Create[sourceAddr, program, version, z, bulk];    Outuser[TRUE, "TwoPartyConsumer to "L];    Format.NetworkAddress[Outproc, cH.remote, octal]; Outproc["\n"L];    [] ¬ Courier.Call[      cH: cH, arguments: [@a, DescribeAsSink],      procedureNumber: Proc[produce].ORD,      streamCheckoutProc: XStream.UserCheckout !      Courier.RemoteErrorSignalled =>	BEGIN	arguments[Courier.nullParameters];	Outuser[TRUE, "TwoPartyConsumer remote error("L];	PrintError[errorNumber]; Outproc[")\n"L];	CONTINUE;	END];    Outuser[TRUE, "Consume complete\n"L];    Courier.Delete[cH];    END;  --TwoPartyConsumer  TwoPartyProducer: PROC[    sinkAddr: System.NetworkAddress, file: LONG STRING, source: XStream.Handle] =    BEGIN    a: TransferArguments ¬ [file: file, bulk: source];    cH: Courier.Handle ¬ Courier.Create[sinkAddr, program, version, z, bulk];    Outuser[TRUE, "TwoPartyProducer to "L];    Format.NetworkAddress[Outproc, cH.remote, octal]; Outproc["\n"L];    [] ¬ Courier.Call[      cH: cH, arguments: [@a, DescribeAsSource],      procedureNumber: Proc[consume].ORD,      streamCheckoutProc: XStream.UserCheckout !	Courier.RemoteErrorSignalled =>	  BEGIN	  arguments[Courier.nullParameters];	  Outuser[TRUE, "TwoPartyProducer remote error("L];	  PrintError[errorNumber]; Outproc[")\n"L];	  CONTINUE;	  END];    Outuser[TRUE, "TwoPartyProducer complete\n"L];    Courier.Delete[cH];    END;  --TwoPartyProducer  UserConsumeNull: UserProcType =    BEGIN    h: XStream.Handle ¬ NIL;    Outuser[TRUE, "Consume null enter\n"L];    TwoPartyConsumer[sourceAddr, sourceFilename, h ¬ XStream.Make[[none[]]]];    IF h # NIL THEN XStream.Destroy[h];    Outuser[TRUE, "Consume null exit\n"L];    END;  --UserConsumeNull  UserProduceNull: UserProcType =    BEGIN    h: XStream.Handle ¬ NIL;    Outuser[TRUE, "Produce null enter\n"L];    TwoPartyProducer[sinkAddr, sinkFilename, h ¬ XStream.Make[[none[]]]];    IF h # NIL THEN XStream.Destroy[h];    Outuser[TRUE, "Produce null exit\n"L];    END;  --UserProduceNull  UserConsumeStream: UserProcType =    BEGIN    error: Error;    sink: Stream.Handle;    bytes: LONG CARDINAL;    h: XStream.Handle ¬ NIL;    BEGIN    Outuser[TRUE, "Consume stream enter\n"L];    sink ¬ MStream.WriteOnly[sinkFilename, [,], unknown !      MStream.Error => {error ¬ code; GOTO nofile}];    h ¬ XStream.Make[[stream[sink]]];    TwoPartyConsumer[      sourceAddr, sourceFilename, h ! ABORTED => GOTO aborted];    bytes ¬ sink.getPosition[sink]; sink.delete[sink];    XStream.Destroy[h];    Outuser[TRUE, "Consume stream exit(bytes: "L];    Format.LongNumber[Outproc, bytes, dnf]; Outproc[")\n"L];    EXITS      aborted =>	BEGIN	sink.delete[sink]; XStream.Destroy[h];	Outuser[TRUE, "Remote CancelTransfer\n"L];	MFile.Delete[MFile.Acquire[sinkFilename, delete, [,]]];	Outuser[TRUE, "Truncated file deleted\n"L];	END;      nofile =>	BEGIN	Outuser[TRUE, "WriteOnly file unavailable("L];	Outproc[sinkFilename]; Outproc[")\n"L];	END;    END;    END;  --UserConsumeStream  UserProduceStream: UserProcType =    BEGIN    error: Error;    source: Stream.Handle;    bytes: LONG CARDINAL;    h: XStream.Handle ¬ NIL;    BEGIN    Outuser[TRUE, "Produce stream enter\n"L];    source ¬ MStream.ReadOnly[sourceFilename, [,] !      MStream.Error => {error ¬ code; GOTO nofile}];    h ¬ XStream.Make[[stream[source]]];    TwoPartyProducer[sinkAddr, sinkFilename, h ! ABORTED => GOTO aborted];    bytes ¬ source.getPosition[source]; source.delete[source];    XStream.Destroy[h];    Outuser[TRUE, "Produce stream exit(bytes: "L];    Format.LongNumber[Outproc, bytes, dnf]; Outproc[")\n"L];    EXITS      aborted =>	BEGIN	source.delete[source]; XStream.Destroy[h];	Outuser[TRUE, "Remote CancelTransfer\n"L]; 	END;      nofile =>	BEGIN	Outuser[TRUE, "ReadOnly file unavailable("L];	Outproc[sourceFilename]; Outproc[")\n"L];	END;    END;    END;  --UserProduceStream  UserConsumeProc: UserProcType =    BEGIN    WriteOnly: PROC[h: XStream.Handle] =      BEGIN      bytes: LONG CARDINAL;      source, sink: Stream.Handle ¬ NIL;      Outuser[TRUE, "WriteOnly proc enter\n"L];      BEGIN      Outuser[TRUE, "Opening WriteOnly file("L];      Outproc[sourceFilename]; Outproc[")\n"L];      sink ¬ MStream.WriteOnly[sinkFilename, [,], unknown !        MStream.Error => {error ¬ code; GOTO nofile}];      source ¬ XStream.Create[h];      Copy[sink: sink, source: source !        Gunned => {error ¬ invalidFile; GOTO gunned};        ABORTED => {error ¬ invalidFile; GOTO aborted}];      source.delete[source]; bytes ¬ sink.getPosition[sink]; sink.delete[sink];      Outuser[TRUE, "WriteOnly proc exit(bytes: "L];      Format.LongNumber[Outproc, bytes, dnf]; Outproc[")\n"L];      EXITS        aborted =>	  BEGIN	  source.delete[source]; sink.delete[sink];	  Outuser[TRUE, "Remote CancelTransfer\n"L];	  MFile.Delete[MFile.Acquire[sinkFilename, delete, [,]]];	  Outuser[TRUE, "Truncated file deleted\n"L];	  END;    	nofile =>	  BEGIN	  Outuser[TRUE, "WriteOnly file unavailable("L];	  Outproc[sourceFilename]; Outproc[")\n"L];	  XStream.CancelTransfer[h];	  Outuser[TRUE, "CancelTransfer\n"L];	  XStream.Destroy[h];	  END;    	gunned =>	  BEGIN	  Outuser[TRUE, "WriteOnly file gunned\n"L];	  XStream.CancelTransfer[h];	  Outuser[TRUE, "CancelTransfer\n"L];	  XStream.Destroy[h];	  END;      END;      END;  --WriteOnly    error: Error ¬ other;    h: XStream.Handle ¬ NIL;    Outuser[TRUE, "Consume proc\n"L];    h ¬ XStream.Make[[proc[WriteOnly]]];    TwoPartyConsumer[sourceAddr, sourceFilename, h];    XStream.Destroy[h];    IF error = other THEN Outuser[TRUE, "Consume proc complete\n\n"L]    ELSE Outuser[TRUE, "Consume proc cancelled\n\n"L];    END;  --UserConsumeProc  UserProduceProc: UserProcType =    BEGIN    ReadOnly: PROC[h: XStream.Handle] =      BEGIN      bytes: LONG CARDINAL;      sink, source: Stream.Handle ¬ NIL;      Outuser[TRUE, "ReadOnly proc enter\n"L];      BEGIN      Outuser[TRUE, "Opening ReadOnly file("L];      Outproc[sourceFilename]; Outproc[")\n"L];      source ¬ MStream.ReadOnly[sourceFilename, [,] !        MStream.Error => {error ¬ code; GOTO nofile}];      sink ¬ XStream.Create[h];  --create the stream      Copy[sink: sink, source: source !        Gunned => GOTO gunned; ABORTED => GOTO aborted];      bytes ¬ source.getPosition[source]; source.delete[source];      sink.delete[sink];      Outuser[TRUE, "ReadOnly proc exit(bytes: "L];      Format.LongNumber[Outproc, bytes, dnf]; Outproc[")\n"L];      EXITS        aborted =>	  BEGIN	  source.delete[source]; sink.delete[sink];	  Outuser[TRUE, "Remote CancelTransfer\n"L]; 	  END;	nofile =>	  BEGIN	  Outuser[TRUE, "ReadOnly file unavailable("L];	  Outproc[sourceFilename]; Outproc[")\n"L];	  XStream.CancelTransfer[h];	  Outuser[TRUE, "CancelTransfer\n"L];	  END;	gunned =>	  BEGIN	  Outuser[TRUE, "ReadOnly file gunned("L];	  Outproc[sourceFilename]; Outproc[")\n"L];	  XStream.CancelTransfer[h];	  Outuser[TRUE, "CancelTransfer\n"L];	  END;      END;      END;  --ReadOnly    error: Error;    h: XStream.Handle ¬ NIL;    Outuser[TRUE, "Produce proc enter\n"L];    h ¬ XStream.Make[[proc[ReadOnly]]];    TwoPartyProducer[sinkAddr, sinkFilename, h];    XStream.Destroy[h];    Outuser[TRUE, "Produce proc exit\n\n"L];    END;  --UserProduceProc  Doit:  FormSW.ProcType =    BEGIN    <<    Source and destinations are in FileName.VirtualFilename format.    If sourceAddr # NIL AND sinkAddr = NIL => Retrieve file to same name    IF sourceAddr = NIL AND sinkAddr # NIL => Store file to same name    IF sourceAddr # NIL AND sinkAddr # NIL => Store source to dest.    >>    process: PROCESS;    proc: UserProcType;    priority: Process.Priority;    sourceVFN, sinkVFN: FileName.VFN;    sourceAddr, sinkAddr: System.NetworkAddress;    sourceFilename, sinkFilename: LONG STRING ¬ NIL;    BEGIN    priority ¬ Process.GetPriority[];  --record current priority    Process.SetPriority[Process.priorityNormal];  --thanks Phil    IF data.process # NIL THEN      {Outuser[TRUE, "Test already running\n"L]; RETURN};    sourceVFN ¬ FileName.AllocVFN[      IF String.Empty[data.source] THEN "[ME]"L ELSE data.source];    sinkVFN ¬ FileName.AllocVFN[      IF String.Empty[data.sink] THEN "[ME]"L ELSE data.sink];    IF sourceVFN.host = NIL THEN      sourceVFN.host ¬ String.CopyToNewString["ME"L, z];  --probably a store    IF sinkVFN.host = NIL THEN      sinkVFN.host ¬ String.CopyToNewString["ME"L, z];  --probably a retrieve    IF (sourceAddr ¬ Address[sourceVFN.host]) = System.nullNetworkAddress THEN      {Outproc["Source incorrectly specified\n"L]; GOTO exit};    IF (sinkAddr ¬ Address[sinkVFN.host]) = System.nullNetworkAddress THEN      {Outproc["Destination incorrectly specified\n"L]; GOTO exit};    SELECT TRUE FROM      (sinkVFN.name = NIL) =>        IF sourceVFN.name # NIL THEN	  sinkVFN.name ¬ String.CopyToNewString[sourceVFN.name, z];      (sourceVFN.name = NIL) =>        IF sinkVFN.name # NIL THEN	  sourceVFN.name ¬ String.CopyToNewString[sinkVFN.name, z];      ENDCASE;    IF sinkVFN.name = NIL THEN      {Outproc["File name incorrectly specified\n"L]; GOTO exit};    proc ¬ SELECT TRUE FROM      (data.mode = deferred) => ThreeParty,  --force 3-party      (sourceAddr.host = me) => SELECT data.mode FROM        proc => UserProduceProc,	stream => UserProduceStream,	ENDCASE => UserProduceNull,      (sinkAddr.host = me) => SELECT data.mode FROM        proc => UserConsumeProc,	stream => UserConsumeStream,	ENDCASE => UserConsumeNull,      ENDCASE => proc ¬ ThreeParty;    sourceFilename ¬ FileName.PackFilename[vfn: sourceVFN, d: TRUE, n: TRUE];    sinkFilename ¬ FileName.PackFilename[vfn: sinkVFN, d: TRUE, n: TRUE];    data.process ¬ process ¬ Process.GetCurrent[];  --for aborting    proc[sourceAddr, sinkAddr, sourceFilename, sinkFilename];    IF data.log THEN Outproc["Done\n"L] ELSE Put.Text[data.fileSW, "."L];    IF ((data.count ¬ data.count + 1) MOD 64) = 0 THEN Put.CR[data.fileSW];    Process.CancelAbort[process];  --because this is the notifier    data.process ¬ NIL;  --so we can't do any more    EXITS exit => NULL;    END;    FileName.FreeVFN[sourceVFN]; FileName.FreeVFN[sinkVFN];    z.FREE[@sourceFilename]; z.FREE[@sinkFilename];    Process.SetPriority[priority];  --reset priority    END;  --Doit  Abort:  FormSW.ProcType =    BEGIN    IF data.process = NIL THEN      {Outuser[TRUE, "No test running\n"L]; RETURN};    Process.Abort[data.process]; data.process ¬ NIL;    Outuser[TRUE, "TEST PROCESS ABORT REQUESTED\n"L];    END;  ClientTransition: ToolWindow.TransitionProcType = {    SELECT TRUE FROM      old = inactive =>        BEGIN	IF data = NIL THEN data ¬ z.NEW[Data ¬ []];	Courier.ExportRemoteProgram[	  program, [version, version], Dispatcher, "Test XStream"L, z, bulk];	XStreamOps.StartProtocol[];  --start 3rd party program	END;      new = inactive =>        BEGIN	ToolDriver.RemoveSWs[tool: "XStream"L];        IF data # NIL THEN z.FREE[@data];	Courier.UnexportRemoteProgram[program, [version, version]];	XStreamOps.StopProtocol[];	END;      ENDCASE;    };  Init: PROCEDURE = {    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default,      clientTransition: ClientTransition, name: "XStreamTest"L,      cmSection: "XStreamTest"L]};  MakeSWs: Tool.MakeSWsProc = {    logName: LONG STRING ¬ [20];    addresses: ARRAY [0..2) OF ToolDriver.Address;    Tool.UnusedLogName[unused: logName, root: "XStreamTest.log"L];    data.formSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeForm, zone: z];    data.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    addresses ¬ [      [name: "formSW"L, sw: data.formSW], [name: "fileSW"L, sw: data.fileSW]];    ToolDriver.NoteSWs[tool: "XStream"L, subwindows: DESCRIPTOR[addresses]];    };  charWidth: CARDINAL ¬ WindowFont.CharWidth['0];  CharPos: PROC[char: CARDINAL] RETURNS [x: INTEGER] = {x ¬ charWidth * char};  MakeForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = FormItems.LAST.ORD + 1;    mode: ARRAY[0..4) OF Enumerated ¬ [      ["null"L, 0], ["stream"L, 1],      ["proc"L, 2], ["deferred"L, 3]];    test: ARRAY[0..5) OF Enumerated ¬ [      ["normal"L, 0], ["beginning"L, 1], ["middle"L, 2],      ["ending"L, 3], ["race"L, 4]];    items ¬ AllocateItemDescriptor[nItems, z];    items[FormItems.doit.ORD] ¬ CommandItem[      tag: "Doit"L, place: [CharPos[1], line0], proc: Doit, z: z];    items[FormItems.abort.ORD] ¬ CommandItem[      tag: "Abort"L, place: [CharPos[16], line0], proc: Abort, z: z];    items[FormItems.log.ORD] ¬ BooleanItem[      tag: "log"L, place: [CharPos[30], line0], switch: @data.log, z: z];    items[FormItems.mode.ORD] ¬ EnumeratedItem[      tag: "mode"L, place: [CharPos[40], line0], choices: DESCRIPTOR[mode],      value: @data.mode, z: z];    items[FormItems.test.ORD] ¬ EnumeratedItem[      tag: "errors"L, place: [CharPos[60], line0],      choices: DESCRIPTOR[test], value: @data.test, z: z];    items[FormItems.sink.ORD] ¬ StringItem[      tag: "source"L, place: [CharPos[1], line1], inHeap: TRUE,      string: @data.source, z: z];    items[FormItems.source.ORD] ¬ StringItem[      tag: "dest"L, place: [CharPos[1], line2], inHeap: TRUE,      string: @data.sink, z: z];    RETURN[items: items, freeDesc: TRUE];    };  PrintError: PROC[errorNumber: CARDINAL] =    BEGIN    error: Error = LOOPHOLE[errorNumber];    string: ErrorString = [      "invalidHandle"L, "indexOutOfRange"L, "invalidOperation"L,      "fileTooLong"L, "fileNotAvailable"L, "invalidFile"L];    IF error ~IN[invalidHandle..invalidFile] THEN Outproc["other"L]    ELSE Outproc[string[error]];    END;  --PrintError  -- Mainline code  Init[];  -- this gets string out of global frame  }...    
-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved. -- FactorialClientImpl.mesa Last Edit: AOF  6-Sep-83 14:00:46-- Client or "Stub" implementation imports description routinesDIRECTORY  Courier USING [    Call, Create, Delete, Description, Error, ErrorCode, Free, Handle,    Parameters, RemoteErrorSignalled, VersionMismatch],  Factorial USING [ErrorReason],  FactorialInternal USING [    DescribeCardinal, procNumberFactorial, programNumber, version,    FactorialErrorReason, DescribeLongCardinal, factorialError, mapto],  Heap USING [systemZone],  System USING [NetworkAddress, nullNetworkAddress];FactorialClientImpl: PROGRAM  IMPORTS Courier, Heap, FactorialInternal  EXPORTS Factorial =  BEGIN  CourierCallProc: TYPE = PROCEDURE [callHandle: Courier.Handle];  z: UNCOUNTED ZONE = Heap.systemZone;  Error: PUBLIC ERROR [reason: Factorial.ErrorReason] = CODE;  GetFactorial: PUBLIC PROCEDURE [number: CARDINAL, host: System.NetworkAddress]    RETURNS [factorial: LONG CARDINAL] =    BEGIN    remoteReason: FactorialInternal.FactorialErrorReason;    args: Courier.Parameters ¬ [@number, FactorialInternal.DescribeCardinal];    results: Courier.Parameters ¬ [      @factorial, FactorialInternal.DescribeLongCardinal];    CallProc: CourierCallProc =      BEGIN      [] ¬ Courier.Call[        callHandle, FactorialInternal.procNumberFactorial, args, results];      END;    BEGIN    ENABLE Courier.RemoteErrorSignalled =>      -- was the remote error raised the expected one?      SELECT errorNumber FROM	FactorialInternal.factorialError =>	  BEGIN	  -- yes, deserialize into the reason	  arguments[[@remoteReason, FactorialInternal.DescribeCardinal]];	  GOTO remoteError;	  END;	ENDCASE => GOTO unknownError;    CallTrappingErrors[host, CallProc];    EXITS      remoteError => ERROR Error[TranslateFactorialError[remoteReason]];      unknownError => ERROR Error[[noRetry[unknownErrorInRemoteProcedure]]];    END;  -- ENABLE    Courier.Free[results, z];  -- required if Courier allocated storage     -- to hold results    END;  -- of GetFactorial  CallTrappingErrors: PROCEDURE [    systemElement: System.NetworkAddress, callProc: CourierCallProc] =    BEGIN    <<    This routine provides a convenient place to trap signals and do     Courier connection management.    Note that connections are deleted    in the unwind.    >>    cErrorCode: Courier.ErrorCode;    callHandle: Courier.Handle ¬ NIL;    BEGIN    ENABLE    UNWIND => IF callHandle # NIL THEN Courier.Delete[callHandle];    IF systemElement = System.nullNetworkAddress THEN      ERROR Error[[clientError[invalidAddress]]];    BEGIN    ENABLE      BEGIN      Courier.Error => {cErrorCode ¬ errorCode; GOTO courierError};      Courier.VersionMismatch => GOTO versionMismatch;      END;    callHandle ¬ Courier.Create[systemElement,      FactorialInternal.programNumber, FactorialInternal.version,      z, transactional];    callProc[callHandle];    EXITS      courierError => ERROR Error[FactorialInternal.mapto[cErrorCode]];      versionMismatch => ERROR Error[[noRetry[versionMismatch]]];    END;  -- ENABLE    END;  -- ENABLE    Courier.Delete[callHandle];    END;  TranslateFactorialError: PROCEDURE [    errorReason: FactorialInternal.FactorialErrorReason]    RETURNS [Factorial.ErrorReason] =    BEGIN    <<    Translate the remote reason raised by the server to an error    reason that is part of the vanilla def.    >>    RETURN[SELECT errorReason FROM      numberTooLarge => [clientError[numberTooLarge]],      ENDCASE => [noRetry[unknownErrorInRemoteProcedure]]];    END;  END.  << log.10-Jun-83 10:14:55 - Treadwell - created file13-Jun-83 14:09:32 - Kluger - added remote error 6-Sep-83 14:15:50 - AOF - Sanitizing>>		
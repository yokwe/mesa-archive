-- File: StreamCoupleTest.mesa - last edit:-- AOF                  9-Nov-87 17:04:05-- Create by FormSWLayoutTool on  1-Nov-87 12:10-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.DIRECTORY  Environment,  Exec,  Format,  FormSW,  Heap,  Inline,  Process,  Put,  Stream,  StreamCouple,  System,  TextSource,  Time,  Tool,  ToolWindow,  UserInput,  Window,  WindowFont;StreamCoupleTest: MONITOR  IMPORTS    Exec, Format, FormSW, Heap, Inline, Process, Put, StreamCouple,    System, Time, Tool, UserInput, WindowFont = {  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = MACHINE DEPENDENT RECORD [    msgSW(0): Window.Handle ¬ NIL,    formSW(2): Window.Handle ¬ NIL,    fileSW(4): Window.Handle ¬ NIL,    sinkbuffersize(6): NATURAL ¬ 512,    sourcebuffersize(7): NATURAL ¬ 512,    verify(8): BOOLEAN ¬ FALSE,    stopped(9): BOOLEAN ¬ FALSE,    abort(10): UNSPECIFIED ¬ 0,    me(11): PROCESS ¬ NIL,    aborted(12): BOOLEAN ¬ FALSE];  FormItems: TYPE = {doit, sinkbuffersize, sourcebuffersize, abort, verify};  data: DataHandle ¬ NIL;  wh: Window.Handle ¬ NIL;  zone: UNCOUNTED ZONE ¬ Heap.Create[initial: 4];  BufferBlock: TYPE = RECORD[    PACKED SEQUENCE COMPUTED INTEGER OF Environment.Byte];  initialBox: Window.Box = [place: [x:512, y: 31], dims: [w: 512, h: 350]];  busyBit: BOOLEAN ¬ FALSE;  Busy: ENTRY PROCEDURE RETURNS [isBusy: BOOLEAN] = {    ENABLE UNWIND => NULL;    isBusy ¬ busyBit;    busyBit ¬ TRUE };  Done: ENTRY PROCEDURE = {    ENABLE UNWIND => NULL;    busyBit ¬ FALSE};  Write: Format.StringProc = {Put.Text[data.fileSW, s]};  Msg: Format.StringProc = {Put.Text[data.msgSW, s]};  Doit:  FormSW.ProcType = {    ENABLE ABORTED => {Done[]; CONTINUE};    IF Busy[] THEN {      Msg["Tool is busy.\n"L];      RETURN};    Process.Detach[FORK DoitInternal[]]};  DoitInternal: PROCEDURE = {    ENABLE ABORTED => {Done[]; CONTINUE};    timein: LONG CARDINAL;    time: LONG STRING ¬ [24];    sink, source: Stream.Handle;    gets, puts: LONG CARDINAL ¬ 0;    bytesin, bytesout: LONG CARDINAL ¬ 0;    sinkbuffer, sourcebuffer: Environment.Block;    sinker, sourcer: PROCESS RETURNS[iocount, bytes: LONG CARDINAL];    Process.SetPriority[Process.priorityBackground];    [sink, source] ¬ StreamCouple.Create[];    sinkbuffer ¬ [      LOOPHOLE[zone.NEW[BufferBlock[data.sinkbuffersize]]],      0, data.sinkbuffersize];    sourcebuffer ¬ [      LOOPHOLE[zone.NEW[BufferBlock[data.sourcebuffersize]]],      0, data.sourcebuffersize];    Write["\nTest started at "L];    time.length ¬ 0; Time.AppendCurrent[time]; Write[time];    Write["\nSink buffer size is "L];    Format.LongNumber[Write, data.sinkbuffersize, []];    Write["\nSource buffer size is "L];    Format.LongNumber[Write, data.sourcebuffersize, []];    data.stopped ¬ FALSE;  --remember to reset    data.me ¬ Process.GetCurrent[];  --so they can gun me    timein ¬ System.GetClockPulses[];  --time test started    sinker ¬ FORK Sinker[sink, sinkbuffer];    sourcer ¬ FORK Sourcer[source, sourcebuffer];    UNTIL data.stopped OR UserInput.UserAbort[wh] DO      ENABLE ABORTED => EXIT;      Process.Pause[Process.MsecToTicks[500]];      REPEAT FINISHED => data.aborted ¬ TRUE;      ENDLOOP;        [gets, bytesin] ¬ JOIN sinker;    [puts, bytesout] ¬ JOIN sourcer;    timein ¬ System.GetClockPulses[] - timein;  --elapsed pulses    timein ¬ System.PulsesToMicroseconds[[timein]];  --elapsed useconds    sink.delete[sink]; source.delete[source];    zone.FREE[@sinkbuffer.blockPointer];    zone.FREE[@sourcebuffer.blockPointer];    Write["\nTest complete at "L];    time.length ¬ 0; Time.AppendCurrent[time];Write[time];    Write[".\nDuration of test was "L];    Format.LongNumber[Write, timein / 1D6, []];  --seconds    Write["."L];    Format.LongNumber[Write, timein MOD 1D6, [10, TRUE, TRUE, 6]];    Write[" seconds.\n"L];    Write["Source process performed "L];    Format.LongNumber[Write, puts, []];    Write[" put operations sending "L];    Format.LongNumber[Write, bytesout, []];    Write[" bytes\n  at a rate of "L];    Format.LongNumber[Write, Rate[puts, timein], []];    Write[" puts per second.\n"L];    Write["Sink process performed "L];    Format.LongNumber[Write, gets, []];    Write[" get operations receiving "L];    Format.LongNumber[Write, bytesin, []];    Write[" bytes\n  at a rate of "L];    Format.LongNumber[Write, Rate[gets, timein], []];    Write[" gets per second.\n"L];    Write["Transfer rate was "L];    Format.LongNumber[Write, Rate[bytesin, timein], []];    Write[" bytes per second.\n"L];    Done[] };  Rate: PROC[bytes, time: LONG CARDINAL] RETURNS[LONG CARDINAL] =    BEGIN    --time is in microseconds    --returned value will be in bytes / second    --trying for rate ¬ bytes / time without over/under flow    UNTIL (time IN[1D8..1D9]) OR (bytes > 3FFFFFH) DO      shift: INTEGER ¬ IF time < 1D8 THEN +1 ELSE -1;      time ¬ Inline.DBITSHIFT[time, shift];      bytes ¬ Inline.DBITSHIFT[bytes, shift];      ENDLOOP;    RETURN[bytes / (time / 1D6)];    END;  --Rate  Sinker: PROC[sH: Stream.Handle, block: Environment.Block]    RETURNS[iocount, bytes: LONG CARDINAL ¬ 0] =    BEGIN    Watcher: PROC[him: PROCESS] =      {ENABLE ABORTED => CONTINUE; [] ¬ sH.waitAttention[sH]};    moved: NATURAL;    index: NATURAL[0..256) ¬ 0;    status: Stream.CompletionCode ¬ normal;    watcher: PROCESS = FORK Watcher[Process.GetCurrent[]];    WHILE status = normal DO      [moved, status, ] ¬ sH.get[sH, block, sH.options];      IF status = attention THEN LOOP;      IF data.verify THEN	FOR i: NATURAL IN[block.startIndex..moved) DO	  IF block.blockPointer[i] # (index MOD 256) THEN	    {data.stopped ¬ TRUE; Write["WHOOPS "L]; EXIT};	  index ¬ index.SUCC;	  ENDLOOP;      bytes ¬ bytes + moved; iocount ¬ iocount.SUCC;      IF data.aborted AND (data.abort = 1) THEN sH.sendAttention[sH, 1];      ENDLOOP;    data.stopped ¬ TRUE;  --we're finished now    Process.Abort[data.me];  --wake him up    Process.Abort[watcher]; JOIN watcher;    END;  --Sinker  Sourcer: PROC[sH: Stream.Handle, block: Environment.Block]    RETURNS[iocount, bytes: LONG CARDINAL ¬ 0] =    BEGIN    Watcher: PROC[him: PROCESS] =      BEGIN      ENABLE ABORTED => CONTINUE;      [] ¬ sH.waitAttention[sH];      data.stopped ¬ TRUE;      END;    index: NATURAL[0..256) ¬ 0;    watcher: PROCESS = FORK Watcher[Process.GetCurrent[]];    UNTIL iocount > 10000 DO      IF data.verify THEN	FOR i: NATURAL IN[block.startIndex..block.stopIndexPlusOne) DO	  block.blockPointer[i] ¬ index; index ¬ index.SUCC; ENDLOOP;      sH.put[sH, block, FALSE];      bytes ¬ bytes + block.stopIndexPlusOne;      iocount ¬ iocount.SUCC;      IF data.stopped THEN GOTO abort;  --he did it      IF data.aborted AND (data.abort = 0) THEN GOTO abort;      REPEAT        abort => sH.sendAttention[sH, 1];  --I'm quiting	FINISHED =>	  BEGIN	  sH.put[sH, block, TRUE];  --stop the exersize	  bytes ¬ bytes + block.stopIndexPlusOne;	  iocount ¬ iocount.SUCC;	  END;      ENDLOOP;    Process.Abort[watcher]; JOIN watcher;    END;  --Sourcer  ClientTransition: ToolWindow.TransitionProcType = {    SELECT TRUE FROM      old = inactive =>        IF data = NIL THEN data ¬ zone.NEW[Data ¬ []];      new = inactive =>        IF data # NIL THEN {	  zone.FREE[@data]};      ENDCASE;    };  Init: PROCEDURE = {    Exec.AddCommand["StreamCoupleTest.~"L, NoOp, NIL, Unload];    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default, initialBox: initialBox,      clientTransition: ClientTransition, name: "StreamCoupleTest"L,      cmSection: "StreamCoupleTest"L];    };      NoOp: Exec.ExecProc = {};    Unload: Exec.ExecProc = {    IF Busy[] THEN {      Exec.OutputProc[h]["Tool is busy. Sorry.\n"L];      RETURN[error] };    Tool.Destroy[wh];    Exec.RemoveCommand[h, "StreamCoupleTest.~"L];    Heap.Delete[zone];    Done[] };  MakeSWs: Tool.MakeSWsProc = {    logName: LONG STRING ¬ [23];    Tool.UnusedLogName[unused: logName, root: "StreamCoupleTest.log"L];    data.msgSW ¬ Tool.MakeMsgSW[window: window];    data.formSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeForm, zone: zone];    data.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    };  charWidth: CARDINAL ¬ WindowFont.CharWidth['0];  CharPos: PROC[char: CARDINAL] RETURNS [x: INTEGER] = {    x ¬ charWidth * char};  MakeForm: FormSW.ClientItemsProcType = {    nItems: CARDINAL = FormItems.LAST.ORD + 1;    abort: ARRAY[0..2) OF FormSW.Enumerated ¬ [["+"L, 0], ["-"L, 1]];    items ¬ FormSW.AllocateItemDescriptor[nItems, zone];    items[FormItems.doit.ORD] ¬ FormSW.CommandItem[      tag: "Doit"L, place: [CharPos[1], FormSW.line0], proc: Doit, z: zone];    items[FormItems.sinkbuffersize.ORD] ¬ FormSW.NumberItem[      tag: "Sink buffer size"L, place: [CharPos[8], FormSW.line0], signed: FALSE, default: 512, value: @data.sinkbuffersize, z: zone];    items[FormItems.sourcebuffersize.ORD] ¬ FormSW.NumberItem[      tag: "Source buffer size"L, place: [CharPos[35], FormSW.line0], signed: FALSE, default: 512, value: @data.sourcebuffersize, z: zone];    items[FormItems.abort.ORD] ¬ FormSW.EnumeratedItem[      tag: """"L, place: [CharPos[66], FormSW.line0], feedback: all, choices: DESCRIPTOR[abort], value: @data.abort, z: zone];    items[FormItems.verify.ORD] ¬ FormSW.BooleanItem[      tag: "verify"L, place: [CharPos[76], FormSW.line0], drawBox: TRUE, switch: @data.verify, z: zone];    RETURN[items: items, freeDesc: TRUE];    };  -- Mainline code  Init[];  -- this gets string out of global frame  }...    
-- File: CTBulk.mesa - last edit:-- AOF                 27-May-85 15:45:29-- Copyright (C) 1984, 1985  by Xerox Corporation. All rights reserved. DIRECTORY  Courier USING [Error],  CTTx USING [BulkProc, hyper],  Environment USING [Block, Byte],  Inline USING [LowByte],  Process USING [Abort, GetCurrent],  Stream USING [Handle, CompletionCode, InputOptions, SubSequenceType];CTBulk: PROGRAM  IMPORTS Courier, CTTx, Inline, Process  EXPORTS CTTx =  BEGIN  <<  Stage 01 - Transfer data from user to server.  Stage 02 - Transfer data from server to user.  Stage 03 - Server aborts in progress transfer from user.  Stage 04 - User aborts in progress transfer from server.  Stage 05 - User aborts in progress transfer from user.  Stage 06 - Server aborts in progress transfer from server.  Stage 07 - Server aborts transfer from user immediately.  Stage 08 - User aborts transfer from server immediately.  Stage 09 - User aborts transfer from user immediately.  Stage 10 - Server aborts transfer from server immediately.  Stage 11 - Server rejects (no abort, no nuthin).  >>  defaultCount: CARDINAL ¬ 20;  defaultLength: CARDINAL ¬ 534;  BulkError: PUBLIC ERROR = CODE;  Buffer: TYPE = PACKED ARRAY CARDINAL[0..534) OF Environment.Byte;  Doit: TYPE = PROC[block: Environment.Block, count: CARDINAL];  inputOptions: Stream.InputOptions = [    terminateOnEndRecord: TRUE, signalLongBlock: FALSE,    signalShortBlock: FALSE, signalSSTChange: FALSE,    signalEndOfStream: FALSE, signalAttention: TRUE,    signalTimeout: TRUE, signalEndRecord: FALSE];    Setup: PROC[doit: Doit] =    BEGIN    block: Environment.Block;    block ¬ [LOOPHOLE[CTTx.hyper.NEW[Buffer]], 0, defaultLength];    FOR i: CARDINAL IN[0..defaultLength) DO      block.blockPointer[i] ¬ Inline.LowByte[i]; ENDLOOP;    doit[block, defaultCount !      UNWIND => CTTx.hyper.FREE[@block.blockPointer]];    CTTx.hyper.FREE[@block.blockPointer];    END;  --Setup  Watcher: PROC[sH: Stream.Handle, process: PROCESS] =    BEGIN    ENABLE ABORTED => CONTINUE;    [] ¬ sH.waitAttention[sH];    Process.Abort[process];    END;  --Watcher  SourceWithoutAbort: PUBLIC CTTx.BulkProc =    BEGIN    --01 Transfer data from user to server.    --02 Transfer data from server to user.    doit: Doit =      BEGIN      watcher: PROCESS ¬ FORK Watcher[sH, Process.GetCurrent[]];      sH.setSST[sH, 1];      FOR i: CARDINAL IN[0..count) DO        ENABLE UNWIND =>	  {Process.Abort[watcher]; JOIN watcher};        block.blockPointer[0] ¬ Inline.LowByte[i];	sH.put[sH, block, FALSE];	ENDLOOP;      sH.sendNow[sH, TRUE];      Process.Abort[watcher]; JOIN watcher;      END;    Setup[doit];    END;  --SourceWithoutAbort  SinkWatchingForAbort: PUBLIC CTTx.BulkProc =    BEGIN    --01 Transfer data from user to server.    --02 Transfer data from server to user.    doit: Doit =      BEGIN      bytes: CARDINAL;      why: Stream.CompletionCode;      sst: Stream.SubSequenceType;      watcher: PROCESS ¬ FORK Watcher[sH, Process.GetCurrent[]];      FOR i: CARDINAL IN[0..LAST[CARDINAL]) DO        ENABLE UNWIND =>	  {Process.Abort[watcher]; JOIN watcher};	[bytes, why, sst] ¬ sH.get[sH, block, inputOptions];	SELECT why FROM	  (normal) => NULL;	  (endRecord) => EXIT;	  (sstChange) =>	    SELECT TRUE FROM	      (bytes # 0) => ERROR BulkError;	      (sst # 1) => ERROR BulkError;	      ENDCASE;	  ENDCASE;	ENDLOOP;      Process.Abort[watcher]; JOIN watcher;      END;    Setup[doit];    END;  --SinkWatchingForAbort  SourceWithAbort: PUBLIC CTTx.BulkProc =    BEGIN    --05 User aborts in progress transfer from user.    --Server aborts in progress transfer from server.    doit: Doit =      BEGIN      watcher: PROCESS ¬ FORK Watcher[sH, Process.GetCurrent[]];      sH.setSST[sH, 1];      FOR i: CARDINAL IN[0..count) DO        ENABLE ABORTED =>	  {Process.Abort[watcher]; JOIN watcher};        block.blockPointer[0] ¬ Inline.LowByte[i];	sH.put[sH, block, FALSE];	ENDLOOP;      sH.sendAttention[sH, 1];      Process.Abort[watcher]; JOIN watcher;      ERROR ABORTED;      END;    Setup[doit];    END;  --SourceWithAbort  SinkWithAbort: PUBLIC CTTx.BulkProc =    BEGIN    --04 User aborts in progress transfer from server.    --03 Server aborts in progress transfer from user.    doit: Doit =      BEGIN      bytes: CARDINAL;      why: Stream.CompletionCode;      sst: Stream.SubSequenceType;      watcher: PROCESS ¬ FORK Watcher[sH, Process.GetCurrent[]];      FOR i: CARDINAL IN[0..count) DO        ENABLE ABORTED =>	  {Process.Abort[watcher]; JOIN watcher};	[bytes, why, sst] ¬ sH.get[sH, block, inputOptions];	SELECT why FROM	  (endRecord) => EXIT;	  (sstChange) =>	    SELECT TRUE FROM	      (bytes # 0) => ERROR BulkError;	      (sst # 1) => ERROR BulkError;	      ENDCASE;	  ENDCASE;	REPEAT FINISHED => sH.sendAttention[sH, 1];	ENDLOOP;      Process.Abort[watcher]; JOIN watcher;      ERROR ABORTED;      END;    Setup[doit];    END;  --SinkWithAbort  AbortImmediately: PUBLIC CTTx.BulkProc =    BEGIN    --07 Server aborts transfer from user immediately.    --08 User aborts transfer from server immediately.    --09 User aborts transfer from user immediately.    --10 Server aborts transfer from server immediately.    doit: Doit =      BEGIN      sH.setSST[sH, 1];      sH.sendAttention[sH, 1];      ERROR ABORTED;      END;    Setup[doit];    END;  --AbortImmediately  ServerReject: PUBLIC CTTx.BulkProc = {ERROR ABORTED};  UserReject: PUBLIC CTTx.BulkProc =    BEGIN    SinkWatchingForAbort[sH !      Courier.Error => IF errorCode = truncatedTransfer THEN CONTINUE]    END;  --UserReject  END...   
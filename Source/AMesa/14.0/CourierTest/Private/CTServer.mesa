-- File: CTServer.mesa - last edit:-- AOF                 28-May-85 18:31:55-- Copyright (C) 1984, 1985  by Xerox Corporation. All rights reserved. DIRECTORY  Courier USING [    Parameters, Free, Arguments, Results, Error, RemoteErrorSignalled,    Description, ErrorCode, Dispatcher, NoSuchProcedureNumber, Handle,    InvalidArguments, SignalRemoteError],  CTTx USING [    TestType, MsgOut, ProcessUserError, tool, CardinalDescribe,    LongCardinalDescribe, ArrayDescribe, StringDescribe, BlockDescribe,    DescriptorDescribe, ChoiceDescribe, stackOverflow,    ParametersDescribe, DisjointDescribe, EstablishDescribe, StageNumber,    null, establish, ServerProc, AppendTestName, ProcessCourierError, xlate,    VariantRecord, SpaceDescribe, DeadSpaceDescribe, ServerReject,    SinkWatchingForAbort, SourceWithoutAbort, SourceWithAbort, AbortImmediately,    StackOverflowDescribe, StackOverflowArgs],  Environment USING [Byte],  Format USING [NetworkAddress, StringProc],  Process USING [Pause, SecondsToTicks],  Stream USING [Attention, Handle],  String USING [AppendString],  System USING [NetworkAddress];CTServer: PROGRAM  IMPORTS    Courier, CTTx, Format, Process, LS: String, Stream  EXPORTS CTTx =  BEGIN    Bytes: TYPE = LONG POINTER TO PACKED ARRAY [0..0) OF Environment.Byte;  LoadServerDriver: PUBLIC PROC =    BEGIN    CTTx.tool.driver[null].server ¬ Null;    CTTx.tool.driver[cardinal].server ¬ Cardinal;    CTTx.tool.driver[longCardinal].server ¬ LongCardinal;    CTTx.tool.driver[array].server ¬ Array;    CTTx.tool.driver[string].server ¬ String;    CTTx.tool.driver[longString].server ¬ String;    CTTx.tool.driver[descriptor].server ¬ Descriptor;    CTTx.tool.driver[longDescriptor].server ¬ Descriptor;    CTTx.tool.driver[choice].server ¬ Choice;    CTTx.tool.driver[parameters].server ¬ Parameters;    CTTx.tool.driver[disjoint].server ¬ Disjoint;    CTTx.tool.driver[longDisjoint].server ¬ Disjoint;    CTTx.tool.driver[dataStream].server ¬ DataStream;    CTTx.tool.driver[noRoute].server ¬ NIL;    CTTx.tool.driver[tooMany].server ¬ TooMany;    CTTx.tool.driver[noProg].server ¬ NIL;    CTTx.tool.driver[noVers].server ¬ NIL;    CTTx.tool.driver[returnTMO].server ¬ ReturnTMO;    CTTx.tool.driver[callerAborted].server ¬ CallerAborted;    CTTx.tool.driver[parmInconst].server ¬ NIL;    CTTx.tool.driver[noProc].server ¬ NIL;    CTTx.tool.driver[unknown].server ¬ NIL;    CTTx.tool.driver[dataStream2].server ¬ DataStream2;    CTTx.tool.driver[space].server ¬ Space;    CTTx.tool.driver[deadSpace].server ¬ DeadSpace;    CTTx.tool.driver[block].server ¬ Block;    CTTx.tool.driver[invalidArguments].server ¬ InvalidArguments;    CTTx.tool.driver[stackOverflow].server ¬ StackOverflow;    CTTx.tool.bulkProc[1].server ¬ CTTx.SinkWatchingForAbort;    CTTx.tool.bulkProc[2].server ¬ CTTx.SourceWithoutAbort;    CTTx.tool.bulkProc[3].server ¬ CTTx.SourceWithAbort;    CTTx.tool.bulkProc[4].server ¬ CTTx.SourceWithoutAbort;    CTTx.tool.bulkProc[5].server ¬ CTTx.SinkWatchingForAbort;    CTTx.tool.bulkProc[6].server ¬ CTTx.SourceWithAbort;    CTTx.tool.bulkProc[7].server ¬ CTTx.AbortImmediately;    CTTx.tool.bulkProc[8].server ¬ CTTx.AbortImmediately;    CTTx.tool.bulkProc[9].server ¬ CTTx.SinkWatchingForAbort;    CTTx.tool.bulkProc[10].server ¬ CTTx.AbortImmediately;    CTTx.tool.bulkProc[11].server ¬ CTTx.ServerReject;    END;  Dispatcher: PUBLIC Courier.Dispatcher =    BEGIN    SELECT procedureNumber FROM      IN [CTTx.null..CTTx.stackOverflow] =>        BEGIN	proc: CTTx.TestType = CTTx.xlate[procedureNumber];	IF CTTx.tool.driver[proc].server # NIL THEN	  CTTx.tool.driver[proc].server[cH, arguments, results];	END;      CTTx.establish =>        BEGIN	Establish[cH, arguments, results];	END;      ENDCASE => Courier.NoSuchProcedureNumber;    END;  Catcher: PROC [proc: PROCEDURE[], test: CTTx.TestType] =    BEGIN    string: STRING ¬ [20];    cError: Courier.ErrorCode;    rError: CARDINAL;    rArgs: Courier.Arguments;    BEGIN    ENABLE      BEGIN      Courier.Error =>        BEGIN	cError ¬ errorCode;	IF CTTx.tool.debug THEN REJECT ELSE GOTO courier;	END;      Courier.RemoteErrorSignalled =>        BEGIN	rError ¬ errorNumber; rArgs ¬ arguments;	IF CTTx.tool.debug THEN REJECT ELSE GOTO remote;	END;      Courier.InvalidArguments, UNWIND => REJECT;      ANY => IF CTTx.tool.debug THEN REJECT ELSE GOTO unknown;      END;    proc[];    EXITS      courier =>        BEGIN        CTTx.MsgOut["(Server) "L, TRUE, FALSE];        IF test IN CTTx.TestType THEN CTTx.AppendTestName[test];        CTTx.ProcessCourierError[cError];        END;      remote =>        BEGIN        CTTx.MsgOut["(Server) "L, TRUE, FALSE];        CTTx.AppendTestName[test];        CTTx.ProcessUserError[rError, rArgs];        END;      unknown =>        BEGIN        CTTx.MsgOut["(Server) Unknown error"L];        CTTx.AppendTestName[test];        CTTx.MsgOut[" "L, FALSE, TRUE];        END;    END;    END;  Null: CTTx.ServerProc =    BEGIN    proc: PROC = BEGIN arguments[]; [] ¬ results[]; END;    Catcher[proc, null];    END;  Cardinal: CTTx.ServerProc =    BEGIN    proc: PROC =      BEGIN      arguments[[@ca, CTTx.CardinalDescribe]];      [] ¬ results[[@ca, CTTx.CardinalDescribe]];      END;    ca: CARDINAL;    Catcher[proc, cardinal];    END;  LongCardinal: CTTx.ServerProc =    BEGIN    proc: PROC =      BEGIN      arguments[[@ca, CTTx.LongCardinalDescribe]];      [] ¬ results[[@ca, CTTx.LongCardinalDescribe]];      END;    ca: LONG CARDINAL;    Catcher[proc, longCardinal];    END;  Array: CTTx.ServerProc =    BEGIN    proc: PROC =      BEGIN      arguments[[@aa, CTTx.ArrayDescribe]];      [] ¬ results[[@aa, CTTx.ArrayDescribe]];      END;    aa: ARRAY [0..20) OF CARDINAL;    Catcher[proc, array];    END;  String: CTTx.ServerProc =    BEGIN    proc: PROC =      BEGIN      arguments[[@sa, CTTx.StringDescribe]];      [] ¬ results[[@sa, CTTx.StringDescribe] ! UNWIND => GOTO free];      GOTO free;      EXITS free => Courier.Free[[@sa, CTTx.StringDescribe], cH.zone];      END;    sa: LONG STRING;    Catcher[proc, longString];    END;  Descriptor: CTTx.ServerProc =    BEGIN    proc: PROC =      BEGIN      arguments[[@da, CTTx.DescriptorDescribe]];      [] ¬ results[[@da, CTTx.DescriptorDescribe] ! UNWIND => GOTO free];      GOTO free;      EXITS free => Courier.Free[[@da, CTTx.DescriptorDescribe], cH.zone];      END;    da: LONG DESCRIPTOR FOR ARRAY [0..20) OF CARDINAL;    Catcher[proc, longDescriptor];    END;  Choice: CTTx.ServerProc =    BEGIN    proc: PROC =      BEGIN      arguments[[@va, CTTx.ChoiceDescribe]];      [] ¬ results[[@va, CTTx.ChoiceDescribe] ! UNWIND => GOTO free];      GOTO free;      EXITS free => Courier.Free[[@va, CTTx.ChoiceDescribe], cH.zone];      END;    va: CTTx.VariantRecord;    Catcher[proc, choice];    END;  Parameters: CTTx.ServerProc =    BEGIN    proc: PROC =      BEGIN      arguments[[@pa, CTTx.ParametersDescribe]];      [] ¬ results[[@pa, CTTx.ParametersDescribe]];      END;    pa: CARDINAL;    Catcher[proc, parameters];    END;  Disjoint: CTTx.ServerProc =    BEGIN    proc: PROC =      BEGIN      arguments[[@da, CTTx.DisjointDescribe]];      [] ¬ results[[@da, CTTx.DisjointDescribe] ! UNWIND => GOTO free];      GOTO free;      EXITS free => Courier.Free[[@da, CTTx.DisjointDescribe], cH.zone];      END;    da: LONG POINTER TO CARDINAL;    Catcher[proc, longDisjoint];    END;  DataStream: CTTx.ServerProc =    BEGIN    proc: PROC =      BEGIN      arguments[[@stageNumber, CTTx.CardinalDescribe]];      stream ¬ results[requestDataStream: TRUE];      CTTx.tool.bulkProc[stageNumber].server[stream !        ABORTED, Stream.Attention => GOTO aborted];      EXITS        aborted => ERROR Courier.SignalRemoteError[stageNumber];      END;    stream: Stream.Handle;    stageNumber: CTTx.StageNumber;    Catcher[proc, dataStream];    END;  DataStream2: CTTx.ServerProc =    BEGIN    proc: PROC =      BEGIN      arguments[[@stageNumber, CTTx.CardinalDescribe]];      IF stageNumber ~IN CTTx.StageNumber THEN GOTO aborted;      CTTx.tool.bulkProc[stageNumber].server[cH.sH !        ABORTED, Stream.Attention => GOTO aborted];      [] ¬ results[];      EXITS        aborted => ERROR Courier.SignalRemoteError[stageNumber];      END;    stageNumber: CTTx.StageNumber;    Catcher[proc, dataStream2];    END;  Space: CTTx.ServerProc =    BEGIN    proc: PROC =      BEGIN      S: TYPE = ARRAY [0..20) OF CARDINAL;      sa: S;      arguments[[@sa, CTTx.SpaceDescribe]];      [] ¬ results[[@sa, CTTx.SpaceDescribe]];      END;    Catcher[proc, space];    END;        DeadSpace: CTTx.ServerProc =    BEGIN    proc: PROC =      BEGIN      S: TYPE = ARRAY [0..20) OF CARDINAL;      sa: S;      arguments[[@sa, CTTx.DeadSpaceDescribe]];      [] ¬ results[[@sa, CTTx.DeadSpaceDescribe]];      END;    Catcher[proc, deadSpace];    END;        Block: CTTx.ServerProc =    BEGIN    proc: PROC =      BEGIN      sa: LONG STRING;      arguments[[@sa, CTTx.BlockDescribe]];      [] ¬ results[[@sa, CTTx.BlockDescribe]];      Courier.Free[[@sa, CTTx.BlockDescribe], cH.zone];      END;    Catcher[proc, block];    END;  InvalidArguments: CTTx.ServerProc =    BEGIN    proc: PROC =      BEGIN      a: CARDINAL;      p: Courier.Description = {ERROR Courier.InvalidArguments};      arguments[[@a, p]];      [] ¬ results[];      END;    Catcher[proc, invalidArguments];    END;              CallerAborted: CTTx.ServerProc =    BEGIN    proc: PROC =      BEGIN      arguments[];      Process.Pause[Process.SecondsToTicks[10]];      [] ¬ results[        !        Courier.Error =>          IF errorCode # callerAborted THEN            BEGIN            CTTx.MsgOut["(Server) Expected callerAborted..."L];            REJECT;            END          ELSE GOTO exit];      CTTx.MsgOut["(Server) Expected callerAborted..."L, TRUE, FALSE];      CTTx.MsgOut["but got no error"L, FALSE, TRUE];      EXITS exit => NULL;      END;    Catcher[proc, callerAborted];    END;  ReturnTMO: CTTx.ServerProc =    BEGIN    proc: PROC =      BEGIN      arguments[];      Process.Pause[Process.SecondsToTicks[2]];      [] ¬ results[        !        Courier.Error =>          IF errorCode # callerAborted THEN            BEGIN            CTTx.MsgOut["(Server) Expected callerAborted..."L];            REJECT;            END          ELSE GOTO exit];      CTTx.MsgOut["(Server) Expected callerAborted..."L, TRUE, FALSE];      CTTx.MsgOut["but got no error"L, FALSE, TRUE];      EXITS exit => NULL;      END;    Catcher[proc, returnTMO];    END;  TooMany: CTTx.ServerProc =    BEGIN    proc: PROC = BEGIN arguments[]; Process.Pause[20]; [] ¬ results[]; END;    Catcher[proc, tooMany];    END;  StackOverflow: CTTx.ServerProc =    BEGIN    proc: PROC =      BEGIN      args: CTTx.StackOverflowArgs;      arguments[[@args, CTTx.StackOverflowDescribe]];      [] ¬ results[[@args, CTTx.StackOverflowDescribe]];      Courier.Free[[@args, CTTx.StackOverflowDescribe], cH.zone];      END;    Catcher[proc, stackOverflow];    END;  Establish: CTTx.ServerProc =    BEGIN    stringProc: Format.StringProc = {LS.AppendString[string, s]};    proc: PROC =      BEGIN      arguments[[@ea, CTTx.EstablishDescribe]];      LS.AppendString[string, "(Server) Courier test started with "L];      Format.NetworkAddress[stringProc, ea, octal];      CTTx.MsgOut[string];      [] ¬ results[[@ea, CTTx.EstablishDescribe]];      END;    string: STRING ¬ [80];    ea: System.NetworkAddress;    establish: CTTx.TestType = LOOPHOLE[LOOPHOLE[LAST[CTTx.TestType], CARDINAL] + 1];    Catcher[proc, establish];    END;  END...  
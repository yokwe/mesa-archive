-- Copyright (C) 1981, 1982, 1983  by Xerox Corporation. All rights reserved. -- File: SampleTool.mesa - last edit by:-- Mark,	Sep 23, 1980 5:21 PM-- SXW   ,	May 2, 1980  6:12 PM-- JGS,		21-Aug-81  9:33:29-- SEH,		22-Feb-82 20:44:08-- LXR    ,	19-Apr-82 10:45:09-- RNX   	 9-Aug-82 17:51:06-- RSF           2-Aug-83 18:17:36  update from 8.0 to compile under 10.0-- DSC           3-Oct-84 15:58:41  « This is an example of a "Tool" that runs in Tajo.  It demonstrates the use of a comprehensive set of commonly used Tajo facilities.  Specifically we present examples of the definition, creation, use and destruction of the following:   Windows and subwindows   Menus   Msg subwindows   Form subwindows   File subwindows This version of SampleTool also demonstrates a technique for allowing multiple co-existing instances of a tool.»DIRECTORY  Context USING [Create, Destroy, Find, SimpleDestroyProc, Type, UniqueType],  Cursor USING [Set],  FormSW USING [    AllocateItemDescriptor, BooleanChoices, BooleanItem, ClientItemsProcType,    CommandItem, Enumerated, EnumeratedItem, line0, line1, line2, line3, line4,    NotifyProcType, ProcType, StringItem],  Heap USING [systemZone],  Menu USING [Handle, Instantiate, Make, MCRType, Uninstantiate],  MsgSW USING [Clear],  Put USING [Line],  String USING [CopyToNewString],  Tool USING [    Create, Destroy, MakeFileSW, MakeFormSW, MakeMsgSW, MakeSWsProc, UnusedLogName],  ToolWindow USING [Box, nullBox, TransitionProcType, WindowForSubwindow],  UserInput USING [WaitForConfirmation],  Window ;SampleTool: PROGRAM  IMPORTS Context, Cursor, FormSW, Heap, Menu, MsgSW, Put, String, Tool, ToolWindow, UserInput, Window =  BEGIN  --Global data    ctInstances: CARDINAL ¬ 0;    --not monitored because it can be changed only from within the notifier process.  menu: Menu.Handle = MakeMenu[];    --This menu is shared by all instances of the tool; to save storage and overhead, it is not replicated by each instance.    -- Instance data is hung off a context on each tool window instance.  dataType: Context.Type = Context.UniqueType[];      --Find the instance data, given a window handle  GetData: PROC [w: Window.Handle] RETURNS [DataHandle] = {RETURN Context.Find [dataType, w]};    --Find the instance data, given a subwindow handle  GetDataSW: PROC [sw: Window.Handle] RETURNS [DataHandle] = {RETURN Context.Find [dataType, ToolWindow.WindowForSubwindow [sw]]};    --Structure of the instance data    DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = MACHINE DEPENDENT RECORD [    -- Message subwindow stuff    msgSW(0): Window.Handle ¬ NIL,    -- File subwindow stuff    fileSW(2): Window.Handle ¬ NIL,    -- Form subwindow stuff    -- Note: enumerateds and booleans must be word boundary    -- aligned as addresses for them must be generated    formSW(4): Window.Handle ¬ NIL,    switch1(6): BOOLEAN ¬ NULL,    switch2(7): BOOLEAN ¬ NULL,    enum1(8): Enum1 ¬ NULL,    enum2(9): Enum2 ¬ NULL,    strings(10): ARRAY StringNames OF LONG STRING ¬ ALL[NIL]];  --Other TYPEs  StringNames: TYPE = {vanilla, password, readOnly};  Enum1: TYPE = {a, b, c};  Enum2: TYPE = {x, y, z};  -- Sample Tool Menu support routines  MenuCommandRoutine: Menu.MCRType =    -- Do the tasks necessary to execute a menu command.    -- If the command will take a long time, then one might FORK a PROCESS to do it.    BEGIN    toolData: DataHandle = GetData [window];    SELECT index FROM      0 => Put.Line[toolData.msgSW, "Message posted."L];      1 => Put.Line[toolData.fileSW, "A Menu command called."L];      ENDCASE => Put.Line[toolData.fileSW, "B Menu command called."L];    END;  -- Sample Tool FormSW support routines  FormSWCommandRoutine: FormSW.ProcType =    -- Do the tasks necessary to execute a form subwindow command.    -- Again, if the command will take a long time, then one might FORK a PROCESS to do it.    BEGIN    toolData: DataHandle = GetDataSW [sw];    Put.Line[toolData.fileSW, "The Command Procedure has been called."L];    END;  NotifyClientOfBooleanAction: FormSW.NotifyProcType =    -- This procedure will be called whenever a state change    -- (user action) occurs to the boolean item of the Form subwindow.    BEGIN    toolData: DataHandle = GetDataSW [sw];    Put.Line[toolData.fileSW, "The Boolean Notify Procedure has been called."L];    END;    Another: FormSW.ProcType =     BEGIN    tempBox: ToolWindow.Box;    window: Window.Handle = ToolWindow.WindowForSubwindow [sw];    toolData: DataHandle = GetData [window];    initialBox: ToolWindow.Box ¬ Window.GetBox[window];    ok: BOOLEAN;    --Ask user for location of top left corner of new window    Put.Line [toolData.msgSW, "Click RED over desired location of new tool instance, or BLUE to cancel"L];    Cursor.Set [mouseRed];    [initialBox.place, ok] ¬ UserInput.WaitForConfirmation [];    MsgSW.Clear [toolData.msgSW];    IF NOT ok THEN {Cursor.Set [textPointer]; RETURN};    --Clip window at right and bottom edges of bitmap, so top left corner goes where the user wants it    tempBox ¬ Window.GetBox[Window.rootWindow];    initialBox.dims.w ¬ MIN [initialBox.dims.w, tempBox.dims.w - initialBox.place.x];    initialBox.dims.h ¬ MIN [initialBox.dims.h, tempBox.dims.h - initialBox.place.y];    Cursor.Set [hourGlass];    MakeTool[initialBox];    Cursor.Set [textPointer];    END;    Destroy: FormSW.ProcType =     BEGIN    IF ctInstances = 1 THEN       {Put.Line [GetDataSW [sw].msgSW, "Can't destroy the only existing instance of this tool"L];      RETURN};    Tool.Destroy [ToolWindow.WindowForSubwindow [sw]];    ctInstances ¬ ctInstances - 1;    END;    -- Tool needed routines  ClientTransition: ToolWindow.TransitionProcType =    -- This procedure is called whenever the system determines that this    -- Tool's state is undergoing a user invoked transition.    -- In this Example we demonstrate a technique that minimizes the memory    -- requirements for a Tool that is inactive.    BEGIN    toolData: DataHandle ¬ GetData [window];    SELECT TRUE FROM      old = inactive =>        IF toolData = NIL THEN Context.Create [dataType, toolData ¬ Heap.systemZone.NEW[Data ¬ []], Context.SimpleDestroyProc, window];      new = inactive =>        IF toolData # NIL THEN {	  Menu.Uninstantiate[menu: menu, window: window];	  Context.Destroy [dataType, window]};  --will free node "toolData"      ENDCASE;    END;  MakeTool: PROCEDURE [initialBox: ToolWindow.Box] =    {[] ¬ Tool.Create[      makeSWsProc: MakeSWs,      initialState: default,      clientTransition: ClientTransition,      initialBox: initialBox,      name: "Sample Tool"L,      cmSection: IF ctInstances = 0 THEN "SampleTool"L ELSE NIL,        --User.cm specifies position of first instance; user specifies additional instances with the mouse. Bypassing User.cm speeds up tool creation.      tinyName1: "Sample"L,      tinyName2: "Tool"L];    ctInstances ¬ ctInstances + 1};  MakeForm: FormSW.ClientItemsProcType =    BEGIN OPEN FormSW;    toolData: DataHandle = GetDataSW [sw];    -- This procedure creates a sample FormSW.    nItems: CARDINAL = 10;    e1: ARRAY [0..3) OF Enumerated ¬ [      ["A"L, Enum1[a]], ["B"L, Enum1[b]], ["C"L, Enum1[c]]];    e2: ARRAY [0..3) OF Enumerated ¬ [      ["X"L, Enum2[x]], ["Y"L, Enum2[y]], ["Z"L, Enum2[z]]];    items ¬ AllocateItemDescriptor[nItems];    toolData.strings[vanilla] ¬ toolData.strings[password] ¬ NIL;    toolData.strings[readOnly] ¬ String.CopyToNewString["Read Only String"L,Heap.systemZone];    -- Create an example of command item usage    items[0] ¬ CommandItem[      tag: "Command"L, place: [0, line0], proc: FormSWCommandRoutine];    -- Create three examples of string item usage    items[1] ¬ StringItem[      tag: "Vanilla"L, place: [200, line0], string: @toolData.strings[vanilla],      inHeap: TRUE];    items[2] ¬ StringItem[      tag: "Password"L, place: [0, line1], string: @toolData.strings[password],      feedback: password, inHeap: TRUE];    items[3] ¬ StringItem[      tag: "ReadOnly"L, place: [0, line2], string: @toolData.strings[readOnly],      readOnly: TRUE, inHeap: TRUE];    -- Create two examples of apparent booleans    -- The first one is actually done via an enumerated item    items[4] ¬ EnumeratedItem[      tag: "boolean(trueFalse)"L, place: [0, line3], feedback: all,      value: @toolData.switch1, copyChoices: FALSE, choices: BooleanChoices[]];    toolData.switch1 ¬ TRUE;    items[5] ¬ BooleanItem[      tag: "boolean(video)"L, place: [250, line3], switch: @toolData.switch2,      proc: NotifyClientOfBooleanAction];    toolData.switch2 ¬ TRUE;  -- Create two examples of enumerated FormSWItem usage    items[6] ¬ EnumeratedItem[      tag: "enumerated(one)"L, place: [0, line4], feedback: one,      value: @toolData.enum1, choices: DESCRIPTOR[e1]];    toolData.enum1 ¬ a;    items[7] ¬ EnumeratedItem[      tag: "enumerated(all)"L, place: [175, line4], feedback: all,      value: @toolData.enum2, choices: DESCRIPTOR[e2]];    items[8] ¬ CommandItem[      tag: "Another"L, proc: Another];    items[9] ¬ CommandItem[      tag: "Destroy"L, proc: Destroy];    toolData.enum2 ¬ y;    RETURN[items: items, freeDesc: TRUE];    END;  MakeSWs: Tool.MakeSWsProc =    BEGIN    toolData: DataHandle = GetData [window];    logName: STRING ¬ [40];    Tool.UnusedLogName[unused: logName, root: "Sample.log"L];    toolData.msgSW ¬ Tool.MakeMsgSW[window: window];    toolData.formSW ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    toolData.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    Menu.Instantiate[menu, window];    END;    MakeMenu: PROC RETURNS [menu: Menu.Handle] =     BEGIN    menuStrings: ARRAY [0..3) OF LONG STRING ¬ [      "Post message"L, "A Command"L, "B Command"L];    menu ¬ Menu.Make[      name: "Tests"L, strings: DESCRIPTOR[menuStrings],      mcrProc: MenuCommandRoutine]    END;         -- Mainline code  MakeTool[ToolWindow.nullBox];  END...  
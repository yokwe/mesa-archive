-- Copyright (C) 1981, 1982, 1983  by Xerox Corporation. All rights reserved. -- File: SampleTool.mesa - last edit by:-- Mark,	Sep 23, 1980 5:21 PM-- SXW   ,	May 2, 1980  6:12 PM-- JGS,		21-Aug-81  9:33:29-- SEH,		22-Feb-82 20:44:08-- LXR    ,	19-Apr-82 10:45:09-- AXD    ,	 3-Dec-82 17:21:54-- MXF     , 	27-Dec-82 15:59:00-- DSC  , 	 3-Oct-84 15:59:14<< This is an example of a "Tool" that runs in Tajo.  It demonstrates the use of acomprehensive set of commonly used Tajo facilities.  Specifically we present examplesof the definition, creation, use and destruction of the following:   Windows and subwindows   Menus   Msg subwindows   Form subwindows   File subwindows >>DIRECTORY  Exec USING [AddCommand, ExecProc, OutputProc, RemoveCommand],  Heap USING [systemZone],  Format USING [StringProc],  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType,    CommandItem, ItemHandle, line0, ProcType, StringItem],  Put USING [Line, Text],  Tool USING [    Create, Destroy, MakeFileSW, MakeFormSW, MakeMsgSW, MakeSWsProc, UnusedLogName],  ToolDriver USING [Address, NoteSWs, RemoveSWs],  ToolWindow USING [Activate, TransitionProcType],  Window USING [Handle];SampleTool: PROGRAM   IMPORTS Exec, FormSW, Heap, Put, Tool, ToolDriver, ToolWindow =  BEGIN  -- TYPEs  FormIndex: TYPE = {command, vanilla};    DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = MACHINE DEPENDENT RECORD [    -- Message subwindow stuff    msgSW(0): Window.Handle ¬ NIL,    -- File subwindow stuff    fileSW(2): Window.Handle ¬ NIL,    -- Form subwindow stuff    -- Note: enumerateds and booleans must be word boundary    -- aligned as addresses for them must be generated    formSW(4): Window.Handle ¬ NIL,    string(6): LONG STRING ¬ NIL];  -- Variable declarations  -- This data illustrates a technique for minimizing memory use when this Tool is inactive  toolData: DataHandle ¬ NIL;  wh: Window.Handle ¬ NIL;  -- Tool's window  heraldName: LONG STRING ¬ NIL;  inactive: BOOLEAN ¬ TRUE;  heap: UNCOUNTED ZONE ¬ Heap.systemZone;  -- Sample Tool Menu support routines    -- Sample Tool FormSW support routines    FormSWCommandRoutine: FormSW.ProcType =    BEGIN    << Do the tasks necessary to execute a form subwindow command.    Again, if the command will take a long time, then one might FORK a PROCESS to do it.>>   Put.Line[toolData.fileSW, "The Command Procedure has been called."L];   Put.Text[toolData.fileSW, "The value of vanilla string is "L];   Put.Line[toolData.fileSW, toolData.string];   END;  -- Tool needed routines    ClientTransition: ToolWindow.TransitionProcType =     << This procedure is called whenever the system determines that this    Tool's state is undergoing a user invoked transition.    In this Example we demonstrate a technique that minimizes the memory    requirements for a Tool that is inactive.>>    BEGIN     SELECT TRUE FROM       old = inactive => BEGIN          IF toolData = NIL THEN toolData ¬ heap.NEW[Data ¬ []];          inactive ¬ FALSE;          END;       new = inactive =>        BEGIN        IF toolData # NIL THEN 	  BEGIN	  heap.FREE[@toolData];	  heap.FREE[@heraldName];	  END;	ToolDriver.RemoveSWs[tool: "SampleTool"L];	inactive ¬ TRUE;	END;      ENDCASE     END;        Help: Exec.ExecProc =    BEGIN    OutputProc: Format.StringProc ¬ Exec.OutputProc[h];    h.OutputProc[][     "This command activates the SampleTool window.     The SampleTool is an example of a 'Tool' that runs in Tajo.  It demonstrates     the use of a comprehensive set of commonly used Tajo facilities.  Specifically     we present examples of the definition, creation, use and destruction of     the following:        Windows and subwindows        Menus        Msg subwindows        Form subwindows        File subwindows"L];    END;      Unload: Exec.ExecProc =    BEGIN    IF wh # NIL THEN Tool.Destroy [wh];    wh ¬ NIL;    [] ¬ Exec.RemoveCommand[h, "SampleTool.~"L];    END;      Init: PROCEDURE =   BEGIN    Exec.AddCommand["SampleTool.~"L, SampleToolCommand, Help, Unload];   END;    MakeTool: PROCEDURE RETURNS[wh: Window.Handle] =  BEGIN    RETURN[Tool.Create[      makeSWsProc: MakeSWs, initialState: default,      clientTransition: ClientTransition, name: "SampleTool"L,      cmSection: "SampleTool"L, tinyName1: "Sample"L, tinyName2: "Tool"L]]    END;    SampleToolCommand: Exec.ExecProc =   BEGIN    IF (wh # NIL) AND inactive THEN ToolWindow.Activate[wh]    ELSE wh ¬ MakeTool[];  END;   MakeForm: FormSW.ClientItemsProcType = BEGIN    OPEN FormSW;    -- This procedure creates a sample FormSW.    formItems: LONG POINTER TO ARRAY FormIndex OF FormSW.ItemHandle ¬ NIL;    -- Create an example of command item usage    items ¬ AllocateItemDescriptor[nItems: FormIndex.LAST.ORD + 1];    formItems ¬ LOOPHOLE[BASE[items]];    formItems­ ¬ [    command: CommandItem[      tag: "Command"L, place: [0, line0], proc: FormSWCommandRoutine],    -- Create three examples of string item usage    vanilla:  StringItem[      tag: "Vanilla"L, place: [200, line0], string: @toolData.string,      inHeap: TRUE]];    RETURN[items: items, freeDesc: TRUE]END;  MakeSWs: Tool.MakeSWsProc = BEGIN    logName: STRING ¬ [40];    addresses: ARRAY [0..3) OF ToolDriver.Address;    Tool.UnusedLogName[unused: logName, root: "Sample.log"L];    toolData.msgSW ¬ Tool.MakeMsgSW[window: window];    toolData.formSW ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    toolData.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];            -- do the ToolDriver stuff    addresses ¬ [      [name: "msgSW"L, sw: toolData.msgSW],      [name: "formSW"L, sw: toolData.formSW],      [name: "fileSW"L, sw: toolData.fileSW]];    ToolDriver.NoteSWs[tool: "SampleTool"L, subwindows: DESCRIPTOR[addresses]]END;  -- Mainline code  Init[];  -- this gets string out of global frame  END...  
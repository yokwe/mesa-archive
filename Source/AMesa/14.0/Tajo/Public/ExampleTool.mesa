-- Copyright (C) 1981, 1982, 1983  by Xerox Corporation. All rights reserved. -- File: ExampleTool.mesa - last edit by:-- Mark,	Sep 23, 1980 5:21 PM-- SXW   ,	May 2, 1980  6:12 PM-- JGS,		21-Aug-81  9:33:29-- SEH,		22-Feb-82 20:44:08-- LXR    ,	19-Apr-82 10:45:09-- AXD    ,	 3-Dec-82 17:21:54-- MXF     , 	27-Dec-82 15:59:00-- DSC  , 	 3-Oct-84 15:58:06<< This is an example of a "Tool" that runs in Tajo.  It demonstrates the use of acomprehensive set of commonly used Tajo facilities.  Specifically we present examplesof the definition, creation, use and destruction of the following:   Windows and subwindows   Menus   Msg subwindows   Form subwindows   File subwindows >>DIRECTORY  CmFile USING [Close, Error, FindSection, Handle, NextValue,    TableError, UserDotCmOpen],  Event USING [DoneWithProcess, Handle, StartingProcess, toolWindow],  EventTypes USING [deactivate],  Exec USING [AddCommand, ExecProc, OutputProc, RemoveCommand],  Format USING [StringProc],  FormSW USING [    AllocateItemDescriptor, BooleanChoices, BooleanItem, ClientItemsProcType,    CommandItem, Destroy, Enumerated, EnumeratedItem, ItemHandle, line0, line1,    line2, line3, line4, LongNumberItem, NotifyProcType, ProcType, StringItem],  Heap USING [Create, Delete],  Menu USING [Free, Handle, Instantiate, Make, MCRType, Uninstantiate],  Process USING [Detach, Pause, SecondsToTicks],  Put USING [Line],  Runtime USING [GetBcdTime],  Supervisor USING [    AddDependency, AgentProcedure, CreateSubsystem, EnumerationAborted,    RemoveDependency, SubsystemHandle],  String USING [AppendString, CopyToNewString],  StringLookUp USING [InTable, noMatch, TableDesc],  Time USING [Append, Unpack],  Token USING [FreeTokenString, Item],  Tool USING [    Create, Destroy, MakeFileSW, MakeFormSW, MakeMsgSW, MakeSWsProc, UnusedLogName],  ToolDriver USING [Address, NoteSWs, RemoveSWs],  ToolWindow USING [Activate, TransitionProcType],  Version USING [Append],  Window USING [Handle];ExampleTool: MONITOR   IMPORTS CmFile, Event, Exec, FormSW, Heap, Menu, Process, Put, Runtime, Supervisor, String, StringLookUp, Time, Tool, Token, ToolDriver, ToolWindow, Version =  BEGIN  -- TYPEs  FormIndex: TYPE = {    command, vanilla, password, readOnly, number, boolTF, boolVideo, enumOne, enumAll};  StringNames: TYPE = {vanilla, password, readOnly};  MenuIndex: TYPE = {postMessage, aCommand, bCommand};    DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = MACHINE DEPENDENT RECORD [    -- Message subwindow stuff    msgSW(0): Window.Handle ¬ NIL,    -- File subwindow stuff    fileSW(2): Window.Handle ¬ NIL,    -- Form subwindow stuff    -- Note: enumerateds and booleans must be word boundary    -- aligned as addresses for them must be generated    formSW(4): Window.Handle ¬ NIL,    commandIsRunning(6): BOOLEAN ¬ FALSE,    switch1(7): BOOLEAN ¬ TRUE,    switch2(8): BOOLEAN ¬ TRUE,    enum1(9): Enum1[a..c] ¬ a,    enum1Seq(10): LONG POINTER TO EnumSeq ¬ NIL,    enum2(12): Enum2[x..z] ¬ y,    enum2Seq(13): LONG POINTER TO EnumSeq ¬ NIL,    number(15): LONG CARDINAL ¬ 0,    menu(17): Menu.Handle ¬ NIL,    strings(19): ARRAY StringNames OF LONG STRING ¬ ALL[NIL]];  Enum1: TYPE = MACHINE DEPENDENT     {a(0), b, c, noMatch(StringLookUp.noMatch)};  Enum1Options: TYPE = Enum1[a..c];  Enum2: TYPE = MACHINE DEPENDENT    {x(0), y, z, noMatch(StringLookUp.noMatch)};  Enum2Options: TYPE = Enum2[x..z];  EnumSeq: TYPE = RECORD [seq: SEQUENCE n: CARDINAL OF FormSW.Enumerated];  -- Variable declarations  -- This data illustrates a technique for minimizing memory use when this Tool is inactive  toolData: DataHandle ¬ NIL;  wh: Window.Handle ¬ NIL;  -- Tool's window  heap: UNCOUNTED ZONE ¬ NIL;  heraldName: LONG STRING ¬ NIL;  inactive: BOOLEAN ¬ TRUE;  agent: Supervisor.SubsystemHandle = Supervisor.CreateSubsystem[CheckDeactivate];    CheckDeactivate: Supervisor.AgentProcedure =    BEGIN    IF event = EventTypes.deactivate AND       wh # NIL AND wh = eventData       AND toolData.commandIsRunning THEN {          Put.Line[toolData.msgSW, "The tool is still processsing a command:  aborting deactivation"L];          ERROR Supervisor.EnumerationAborted};    END;  -- Example Tool Menu support routines    MenuCommandRoutine: Menu.MCRType =    BEGIN    << Do the tasks necessary to execute a menu command.    If the command will take a long time, then one might FORK a PROCESS to do it.>>    mx: MenuIndex = VAL[index];    SELECT mx FROM      postMessage => Put.Line[toolData.msgSW, "Message posted."L];      aCommand => Put.Line[toolData.fileSW, "A Menu command called."L];      ENDCASE => Put.Line[toolData.fileSW, "B Menu command called."L]   END;  -- Example Tool FormSW support routines    CommandRoutine: ENTRY PROCEDURE =    BEGIN    handle: Event.Handle ¬ Event.StartingProcess[      "CommandRoutine in SampleTool is running"L];    toolData.commandIsRunning ¬ TRUE;    Process.Pause[Process.SecondsToTicks[10]];    Put.Line[toolData.fileSW, "The Command Procedure has been called."L];    toolData.commandIsRunning ¬ FALSE;    Event.DoneWithProcess[handle];    END;  FormSWCommandRoutine: FormSW.ProcType =    BEGIN    << Do the tasks necessary to execute a form subwindow command.    Again, if the command will take a long time, then one might FORK a PROCESS to do it.>>    Process.Detach[FORK CommandRoutine];   END;  NotifyClientOfBooleanAction: FormSW.NotifyProcType = BEGIN    << This procedure will be called whenever a state change    (user action) occurs to the boolean item of the Form subwindow.>>    Put.Line[toolData.fileSW, "The Boolean Notify Procedure has been called."L]END;  -- Tool needed routines  ProcessUserDotCM: PROCEDURE =    BEGIN    CMOption: TYPE = MACHINE DEPENDENT {     EnumOne(0), EnumAll, noMatch(StringLookUp.noMatch)};    DefinedOption: TYPE = CMOption[EnumOne..EnumAll];    cmOptionTable: ARRAY DefinedOption OF LONG STRING ¬ [      EnumOne: "EnumOne"L, EnumAll: "EnumAll"L];    cmIndex: CMOption;        CheckType: PROCEDURE[h: CmFile.Handle, table: StringLookUp.TableDesc]       RETURNS[index: CARDINAL] = CmFile.NextValue;           MyNextValue: PROCEDURE[       h: CmFile.Handle,       table: LONG DESCRIPTOR FOR ARRAY DefinedOption OF LONG STRING]       RETURNS [index: CMOption] = LOOPHOLE[CheckType];        TranslateValueToEnum1: PROCEDURE[       key: LONG STRING, table: LONG DESCRIPTOR FOR ARRAY       Enum1Options OF LONG STRING, caseFold: BOOLEAN ¬ TRUE,       noAbbreviation: BOOLEAN ¬ FALSE]       RETURNS [index: CARDINAL] = LOOPHOLE[StringLookUp.InTable];            TranslateValueToEnum2: PROCEDURE[       key: LONG STRING, table: LONG DESCRIPTOR FOR ARRAY       Enum2Options OF LONG STRING, caseFold: BOOLEAN ¬ TRUE,       noAbbreviation: BOOLEAN ¬ FALSE]       RETURNS [index: CARDINAL] = LOOPHOLE[StringLookUp.InTable];           cmFile: CmFile.Handle ¬ CmFile.UserDotCmOpen[    !CmFile.Error => IF code = fileNotFound THEN GOTO return];    IF CmFile.FindSection[cmFile, "ExampleTool"L] THEN      DO         SELECT          (cmIndex ¬ MyNextValue[h: cmFile, table: DESCRIPTOR[cmOptionTable]	    ! CmFile.TableError => RESUME]) FROM	    noMatch => EXIT;	    EnumOne => BEGIN	      enum1Table: ARRAY Enum1Options OF LONG STRING ¬ [                  a: "a"L, b: "b"L, c: "c"L];              e1Index: Enum1Options;	      value: LONG STRING = Token.Item[cmFile];	      SELECT e1Index ¬ VAL[TranslateValueToEnum1[	         value, DESCRIPTOR[enum1Table], FALSE, TRUE]] FROM		 noMatch => NULL;	      ENDCASE => toolData.enum1 ¬ e1Index;  	      [] ¬ Token.FreeTokenString[value];	      END;	    EnumAll => BEGIN	      enum2Table: ARRAY Enum2Options OF LONG STRING ¬ [                  x: "x"L, y: "y"L, z: "z"L];              e2Index: Enum2Options;	      value: LONG STRING = Token.Item[cmFile];	      SELECT e2Index ¬ VAL[TranslateValueToEnum2[	         value, DESCRIPTOR[enum2Table], FALSE, TRUE]] FROM		 noMatch => NULL;	      ENDCASE => toolData.enum2 ¬ e2Index;      	      [] ¬ Token.FreeTokenString[value];	      END;	 ENDCASE;       ENDLOOP;     [] ¬ CmFile.Close[cmFile];     EXITS       return => NULL;     END;  ClientTransition: ToolWindow.TransitionProcType =     << This procedure is called whenever the system determines that this    Tool's state is undergoing a user invoked transition.    In this Example we demonstrate a technique that minimizes the memory    requirements for a Tool that is inactive.>>    BEGIN     SELECT TRUE FROM       old = inactive => BEGIN          IF heap = NIL THEN InitHeap[];          IF toolData = NIL THEN toolData ¬ heap.NEW[Data ¬ []];	  ProcessUserDotCM[];          inactive ¬ FALSE;          END;       new = inactive =>        BEGIN	Supervisor.RemoveDependency[client: agent, implementor: Event.toolWindow];        IF toolData # NIL THEN 	  BEGIN	  FormSW.Destroy[toolData.formSW];	  Menu.Uninstantiate[menu: toolData.menu, window: toolData.formSW];	  Menu.Free[toolData.menu];	  heap.FREE[@toolData];	  heap.FREE[@heraldName];	  END;		IF heap # NIL THEN KillHeap[];	ToolDriver.RemoveSWs[tool: "ExampleTool"L];	inactive ¬ TRUE;	END;      ENDCASE     END;        Help: Exec.ExecProc =    BEGIN    OutputProc: Format.StringProc ¬ Exec.OutputProc[h];    h.OutputProc[][     "This command activates the ExampleTool window.     The ExampleTool is an example of a 'Tool' that runs in Tajo.  It demonstrates     the use of a comprehensive set of commonly used Tajo facilities.  Specifically     we present examples of the definition, creation, use and destruction of     the following:        Windows and subwindows        Menus        Msg subwindows        Form subwindows        File subwindows"L];    END;      Unload: Exec.ExecProc =    BEGIN    IF wh # NIL THEN Tool.Destroy [wh];    wh ¬ NIL;    [] ¬ Exec.RemoveCommand[h, "ExampleTool.~"L];    END;      InitHeap: PROCEDURE = INLINE  BEGIN    heap ¬ Heap.Create[initial: 1];  END;    KillHeap: PROCEDURE = INLINE  BEGIN    Heap.Delete[heap];    heap ¬ NIL;  END;    Init: PROCEDURE =   BEGIN    Exec.AddCommand["ExampleTool.~"L, ExampleToolCommand, Help, Unload];   END;  MakeHeraldName: PROCEDURE =   BEGIN    tempName: LONG STRING ¬ heap.NEW[StringBody [60]];    String.AppendString [tempName, "ExampleTool "L];    Version.Append[tempName];    String.AppendString[tempName, " of "L];    Time.Append[tempName, Time.Unpack[Runtime.GetBcdTime []]];    tempName.length ¬ tempName.length - 3; -- gun the seconds    heraldName ¬ String.CopyToNewString[tempName, heap];    heap.FREE[@tempName];  END;    MakeTool: PROCEDURE RETURNS[wh: Window.Handle] =  BEGIN    RETURN[Tool.Create[      makeSWsProc: MakeSWs, initialState: default,      clientTransition: ClientTransition, name: heraldName,      cmSection: "ExampleTool"L, tinyName1: "Example"L, tinyName2: "Tool"L]]    END;    ExampleToolCommand: Exec.ExecProc =   BEGIN    IF heap = NIL THEN InitHeap[];    IF heraldName = NIL THEN MakeHeraldName[];    IF (wh # NIL) AND inactive THEN ToolWindow.Activate[wh]    ELSE wh ¬ MakeTool[];  END;   MakeForm: FormSW.ClientItemsProcType = BEGIN    OPEN FormSW;    -- This procedure creates a sample FormSW.    formItems: LONG POINTER TO ARRAY FormIndex OF FormSW.ItemHandle ¬ NIL;    toolData.enum1Seq ¬ heap.NEW[EnumSeq[3]];    toolData.enum2Seq ¬ heap.NEW[EnumSeq[3]];     -- strings NOT in local frame!!    toolData.enum1Seq[0] ¬ ["A"L, Enum1.a];    toolData.enum1Seq[1] ¬ ["B"L, Enum1.b];    toolData.enum1Seq[2] ¬ ["C"L, Enum1.c];    toolData.enum2Seq[0] ¬ ["X"L, Enum2.x];    toolData.enum2Seq[1] ¬ ["Y"L, Enum2.y];    toolData.enum2Seq[2] ¬ ["Z"L, Enum2.z];    toolData.strings[vanilla] ¬ toolData.strings[password] ¬ NIL;    toolData.strings[readOnly] ¬ String.CopyToNewString[      "Read Only String"L, heap];    -- Create an example of command item usage    items ¬ AllocateItemDescriptor[nItems: FormIndex.LAST.ORD + 1, z: heap];    formItems ¬ LOOPHOLE[BASE[items]];    formItems­ ¬ [    command: CommandItem[      tag: "Command"L, place: [0, line0], z: heap, proc: FormSWCommandRoutine],    -- Create three examples of string item usage    vanilla:  StringItem[      tag: "Vanilla"L, place: [200, line0], z: heap, string: @toolData.strings[vanilla],      inHeap: TRUE],    password: StringItem[      tag: "Password"L, place: [0, line1], z: heap,       string: @toolData.strings[password],      feedback: password, inHeap: TRUE],    readOnly: StringItem[      tag: "ReadOnly"L, place: [0, line2], z: heap,       string: @toolData.strings[readOnly],      readOnly: TRUE, inHeap: TRUE],    number: LongNumberItem[      tag: "Cardinal"L, place: [200, line2], z: heap, value: @toolData.number,       notNegative: TRUE, signed: FALSE],    -- Create two examples of apparent booleans    -- The first one is actually done via an enumerated item    boolTF: EnumeratedItem[      tag: "boolean(trueFalse)"L, place: [0, line3], z: heap, feedback: all,      value: @toolData.switch1, copyChoices: FALSE, choices: BooleanChoices[]],    boolVideo: BooleanItem[      tag: "boolean(video)"L, place: [250, line3], z: heap, switch: @toolData.switch2,      proc: NotifyClientOfBooleanAction],    enumOne: EnumeratedItem[      tag: "enumerated(one)"L, place: [0, line4], z: heap, feedback: one,      value: @toolData.enum1, copyChoices: TRUE,      choices: DESCRIPTOR[toolData.enum1Seq­]],    enumAll: EnumeratedItem[      tag: "enumerated(all)"L, place: [175, line4], z: heap, feedback: all,      value: @toolData.enum2, copyChoices: TRUE,      choices: DESCRIPTOR[toolData.enum2Seq­]]];    heap.FREE[@toolData.enum1Seq];    heap.FREE[@toolData.enum2Seq];    RETURN[items: items, freeDesc: TRUE]END;  MakeSWs: Tool.MakeSWsProc = BEGIN    logName: STRING ¬ [40];    addresses: ARRAY [0..3) OF ToolDriver.Address;    menuStrings: ARRAY MenuIndex OF LONG STRING ¬ [      postMessage: "Post message"L, aCommand: "A Command"L,      bCommand: "B Command"L];    toolData.menu ¬ Menu.Make[      name: "Tests"L, strings: DESCRIPTOR[menuStrings.BASE, menuStrings.LENGTH],      mcrProc: MenuCommandRoutine];    Tool.UnusedLogName[unused: logName, root: "Example.log"L];    toolData.msgSW ¬ Tool.MakeMsgSW[window: window];    toolData.formSW ¬ Tool.MakeFormSW[window: window, formProc: MakeForm, zone: heap];    toolData.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    Menu.Instantiate[toolData.menu, toolData.formSW];    Supervisor.AddDependency[client: agent, implementor: Event.toolWindow];            -- do the ToolDriver stuff    addresses ¬ [      [name: "msgSW"L, sw: toolData.msgSW],      [name: "formSW"L, sw: toolData.formSW],      [name: "fileSW"L, sw: toolData.fileSW]];    ToolDriver.NoteSWs[tool: "ExampleTool"L, subwindows: DESCRIPTOR[addresses]]END;  -- Mainline code  Init[];  -- this gets string out of global frame  END...  
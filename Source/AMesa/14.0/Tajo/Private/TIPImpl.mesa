-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- TIPImpl.mesa - Edited:-- PXK     	28-Nov-82 15:09:26-- AXD     	 7-Jul-83 14:38:43-- JGS on 	18-Nov-82 17:05:18-- RXJ      	19-Jan-83 20:50:46DIRECTORY  Context: TYPE USING [Create, Destroy, Find, Type, UniqueType],  Runtime: TYPE USING [GetTableBase],  System: TYPE USING [MicrosecondsToPulses, Pulses, switches],  TIP: TYPE USING [CreateTable, GlobalTable, InvalidTable, NotifyProc],  TIPOps: TYPE USING [    ChordTableNotify, ClearTargetWindowOnMatch, Client, ClientObject, CSRptr,    StdTable, TajoTIP],  TIPTable: TYPE USING [Results, ResultsObject, Table, TableObject],  UserInputOps: TYPE USING [z],  UserTerminal: TYPE USING [Beep, BlinkDisplay],  Window: TYPE USING [Handle];TIPImpl: MONITOR  IMPORTS Context, Runtime, System, TIP, TIPOps, UserInputOps, UserTerminal  EXPORTS TIP, TIPOps =  BEGIN    z: UNCOUNTED ZONE = UserInputOps.z;  mouseTIP: PUBLIC Table;  clickTimeout: PUBLIC System.Pulses ¬ System.MicrosecondsToPulses[600000];    Results: TYPE = TIPTable.Results;  ResultsList: PUBLIC TYPE = TIPTable.ResultsObject;  Table: TYPE = TIPTable.Table;  TableObject: PUBLIC TYPE = TIPTable.TableObject;    NotifyProc: TYPE = TIP.NotifyProc;  tipContext: PUBLIC Context.Type ¬ Context.UniqueType[];  Client: TYPE = TIPOps.Client;  -- TIPClient Create, Destroy, IsIt  CreateClient: PUBLIC ENTRY PROC [    window: Window.Handle, table: Table, notify: NotifyProc] = {    self: Client ¬ Context.Find[tipContext, window];    IF self # NIL THEN {      IF notify # NIL THEN self.notify ¬ notify;      IF table # NIL THEN self.table ¬ table}    ELSE {      self ¬ z.NEW[TIPOps.ClientObject ¬ [notify: notify, table: table]];      Context.Create[        type: tipContext, data: self, proc: DestroyTIPContext,        window: window]}};  DestroyTIPContext: PROC [user: Client, window: Window.Handle] = {    TIPOps.ClearTargetWindowOnMatch[window];    z.FREE[@user]};  DestroyClient: PUBLIC ENTRY PROC [window: Window.Handle] = {    Context.Destroy[tipContext, window]};  IsIt: PUBLIC ENTRY PROC [window: Window.Handle] RETURNS [BOOLEAN] = {    RETURN[Context.Find[tipContext, window] # NIL]};  GetTable: PUBLIC ENTRY PROC [window: Window.Handle] RETURNS [Table] = {    self: Client = Context.Find[tipContext, window];    RETURN[IF self = NIL THEN NIL ELSE self.table]};  GetNotifyProc: PUBLIC ENTRY PROC [window: Window.Handle] RETURNS [NotifyProc] = {    self: Client = Context.Find[tipContext, window];    RETURN[IF self = NIL THEN NIL ELSE self.notify]};  SetTable: PUBLIC ENTRY PROC [window: Window.Handle, table: Table]    RETURNS [oldTable: Table] = {    self: Client = Context.Find[tipContext, window];    IF self = NIL THEN oldTable ¬ NIL    ELSE {oldTable ¬ self.table; self.table ¬ table}};  SetNotifyProc: PUBLIC ENTRY PROC [window: Window.Handle, notify: NotifyProc]    RETURNS [oldNotify: NotifyProc] = {    self: Client = Context.Find[tipContext, window];    IF self = NIL THEN oldNotify ¬ NIL    ELSE {oldNotify ¬ self.notify; self.notify ¬ notify}};  GetNotifyProcFromTable: PUBLIC ENTRY PROC [table: Table] RETURNS [NotifyProc] = {    RETURN[IF table = NIL THEN NIL ELSE table.notifyProc]};  SetNotifyProcForTable: PUBLIC ENTRY PROC [table: Table, notify: NotifyProc]    RETURNS [oldNotify: NotifyProc] = {    IF table = NIL THEN oldNotify ¬ NIL    ELSE {oldNotify ¬ table.notifyProc; table.notifyProc ¬ notify}};  PushLocal: PUBLIC ENTRY PROC [push, onto: Table, opaque: BOOLEAN ¬ FALSE] = {    WHILE push.link # NIL DO push ¬ push.link ENDLOOP;    push.link ¬ onto;    push.opaque ¬ opaque};  PushGlobal: PUBLIC ENTRY PROC [    push: Table, onto: TIP.GlobalTable, opaque: BOOLEAN ¬ FALSE] = {    oldLink: Table = globalTable[onto].link;    globalTable[onto].link ¬ push;    WHILE push.link # NIL DO push ¬ push.link ENDLOOP;    push.link ¬ oldLink;    push.opaque ¬ opaque};  NextTable: PUBLIC ENTRY PROC [table: Table] RETURNS [Table] = {    RETURN[IF table = NIL THEN NIL ELSE table.link]};  globalTable: PUBLIC ARRAY TIP.GlobalTable OF Table;    MakePlaceHolder: PROC RETURNS [t: Table]= {    t ¬ z.NEW[placeholder TableObject ¬ [      opaque: FALSE, variants: placeholder[]]]};      MakeStdTable: PROC [x: TIPOps.CSRptr, st: TIPOps.StdTable]    RETURNS [table: Table ¬ NIL] = {    table ¬ TIP.CreateTable[      file: @x[x.name[st]], z: z, contents: @x[x.contents[st]] !      TIP.InvalidTable => IF type = badSyntax THEN {        UserTerminal.BlinkDisplay[];	UserTerminal.Beep[];	RESUME}]};  MakeFormTables: PROC [x: TIPOps.CSRptr] = {    table: Table ¬ MakeStdTable[x, FormSW];    IF table # NIL THEN PushGlobal[table, formSW]};  MakeRootTables: PROC [x: TIPOps.CSRptr] = {    table: Table ¬ (mouseTIP ¬ MakeStdTable[x, Mouse]);    IF table # NIL THEN {      PushGlobal[table, root, TRUE]; table ¬ NIL};    table ¬ MakeStdTable[x, Chords];    IF table # NIL THEN {      table.notifyProc ¬ TIPOps.ChordTableNotify;      PushGlobal[table, root];      table ¬ NIL};    table ¬ MakeStdTable[x, Tajo];    IF table # NIL THEN PushGlobal[table, root]};  MakeTextTables: PROC [x: TIPOps.CSRptr] = {    table: Table ¬ MakeStdTable[x, TextSW];    IF table # NIL THEN {      PushGlobal[table, textSW]; table ¬ NIL};    table ¬ MakeStdTable[x, TTYSW];    IF table # NIL THEN PushGlobal[table, ttySW]};  Init: PROC = {    x: TIPOps.CSRptr = Runtime.GetTableBase[TIPOps.TajoTIP];    FOR t: TIP.GlobalTable IN TIP.GlobalTable DO      globalTable[t] ¬ MakePlaceHolder[] ENDLOOP;    globalTable[formSW].link ¬ globalTable[textSW].link ¬ globalTable[root];    globalTable[fileWindow].link ¬ globalTable[textSW];    globalTable[ttySW].link ¬ globalTable[textSW];    globalTable[executive].link ¬ globalTable[ttySW];    IF System.switches['O] = down THEN RETURN;    MakeRootTables[x];    MakeTextTables[x];    MakeFormTables[x]};    -- main line code    Init[];  END.
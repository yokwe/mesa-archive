-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- TIPTableWriter.mesa; Last Edited by:-- CXH   	17-Nov-82 16:03:18-- PXK    	30-Jan-83 16:19:14DIRECTORY  Atom USING [GetPName],  Keys USING [KeyName],  Stream USING [Block, Handle, PutBlock, PutChar],  MStream USING [Handle, Log],  TIPTable USING [    Choice, KeyOption, KeyStateList, Results, Table, Term,    TermObject, version];TIPTableWriter: PROGRAM  IMPORTS Stream, MStream, Atom  EXPORTS TIPTable =  BEGIN  debug: BOOLEAN ¬ FALSE; -- BUG IF TRUE!!! fix before ¬ TRUE..  debugStream: MStream.Handle;  WriteTable: PUBLIC PROC [    table: TIPTable.Table, keyOption: TIPTable.KeyOption, s: Stream.Handle] = {        Char: PROC [c: CHARACTER] = {      Stream.PutChar[s, c]; IF debug THEN Stream.PutChar[debugStream, c]};          String: PROC [str: LONG STRING] = {      PutString[s, str]; IF debug THEN PutString[debugStream, str]};          Text: PROC [txt: LONG STRING] = {      IF txt.length > 255 THEN ERROR; Char[LOOPHOLE[txt.length]]; String[txt]};          Flag: PROC [flag: BOOLEAN] = {Char[IF flag THEN 'T ELSE 'F]};        Key: PROC [k: Keys.KeyName] = {Char[LOOPHOLE[k]]};        Int: PROC [x: LONG INTEGER] = {      Bytes: TYPE = MACHINE DEPENDENT RECORD [        byte0(0:0..7), byte1(0:8..15), byte2(1:0..7), byte3(1:8..15): [0..255] ¬          0];      b: Bytes ¬ LOOPHOLE[x];      Char[LOOPHOLE[b.byte0]];      Char[LOOPHOLE[b.byte1]];      Char[LOOPHOLE[b.byte2]];      Char[LOOPHOLE[b.byte3]]};          ChoiceItem: PROC [k: Keys.KeyName, c: TIPTable.Term] = {      IF c = NIL THEN RETURN; Char['(]; Key[k]; Choice[c]; Char[')]};          ChoiceSeries: PROC [cs: TIPTable.Choice] = {      Char['(];      FOR x: TIPTable.Choice ¬ cs, x.rest UNTIL x = NIL DO        Choice[x.first]; ENDLOOP;      Char[')]};          Choice: PROC [c: TIPTable.Term] = {      Char['(];      FOR x: TIPTable.Term ¬ c, x.rest UNTIL x = NIL DO Term[x]; ENDLOOP;      Char[')]};          Term: PROC [t: TIPTable.Term] = {      WITH x: t SELECT FROM        keyTrigger => {          Char['1];          Key[x.keyState.key];          Char[            SELECT x.keyState.state FROM up => 'U, down => 'D, ENDCASE => ERROR]};	            mouseTrigger => Char['2];	        enterTrigger => Char['a];	        exitTrigger => Char['b];	        timeTrigger => {          Char['3];          Char[SELECT x.flavor FROM gt => 'G, lt => 'L, ENDCASE => ERROR];          Char[LOOPHOLE[x.mSecs/256]];          Char[LOOPHOLE[x.mSecs MOD 256]]};	          keyEnable => {          Char['4];          Key[x.keyState.key];          Char[	    SELECT x.keyState.state FROM up => 'U, down => 'D, ENDCASE => ERROR]};	            keyEnableList => {          Char['c];          Char['(];	  FOR k: TIPTable.KeyStateList ¬ x.list, k.rest UNTIL k = NIL DO	    Char['4];	    Key[k.keyState.key];	    Char[SELECT k.keyState.state FROM	      up => 'U, down => 'D, ENDCASE => ERROR];	    ENDLOOP;          Char[')]};	            predEnable => {Char['5]; Text[LOOPHOLE[Atom.GetPName[x.predicate]]]};	        char => Char['6];	        coords => Char['7];	        nested => {Char['8]; ChoiceSeries[x.statement]};	        result => {Char['9]; Results[x.list]};		time => Char['0];		keys => Char['k];	        ENDCASE => ERROR;      };          Results: PROC [c: TIPTable.Results] = {      Char['(];      FOR x: TIPTable.Results ¬ c, x.rest UNTIL x = NIL DO Result[x]; ENDLOOP;      Char[')]};          Result: PROC [r: TIPTable.Results] = {      SELECT TRUE FROM        ENDCASE =>          WITH x: r SELECT FROM            atom => {Char['1]; Text[LOOPHOLE[Atom.GetPName[x.a]]]};	    char => Char['2];            int => {Char['3]; Int[x.i]};            string => {Char['4]; Text[x.s]};	    coords => Char['5];	    time => Char['6];	    keys => Char['7];            ENDCASE => ERROR};    IF debug THEN debugStream ¬ MStream.Log["TIPTableWriterDebugLog"L, []];    String["TIPTABLE"];    Char[TIPTable.version];    Flag[table.opaque];    Char[IF table.mouseActions = all THEN 'A ELSE 'M];    Char[      SELECT keyOption FROM        none => 'N,        printKeys => 'P,        defaultKeys => 'D,        ENDCASE => ERROR];    Flag[table.ignoreUp];    Flag[table.ignoreDown];    Flag[table.ignoreMove];    WITH x: table SELECT FROM      small => {Char['S]; ChoiceSeries[x.all]};      fast => {        Char['F];        Choice[x.mouse];        Char['U];        Char['(];        FOR k: Keys.KeyName IN Keys.KeyName DO          ChoiceItem[k, x.keyUp[k]]; ENDLOOP;        Char[')];        Char['D];        Char['(];        FOR k: Keys.KeyName IN Keys.KeyName DO          ChoiceItem[k, x.keyDown[k]]; ENDLOOP;        Char[')];        Choice[x.time];	Choice[x.enter];	Choice[x.exit]};      ENDCASE => ERROR;    };  PutString: PROCEDURE [s: Stream.Handle, ls: LONG STRING] = INLINE {    Stream.PutBlock[      s, Stream.Block[      blockPointer: LOOPHOLE[@ls.text], startIndex: 0,      stopIndexPlusOne: ls.length]]};  END.
-- Copyright (C) 1981, 1982  by Xerox Corporation. All rights reserved. -- File: TextSinks.mesa - last edited:-- PXK    ,	23-Oct-81 19:21:16-- SXW   ,	21-Jul-81 12:19:29-- JGS&PK,	19-Aug-81 14:30:57-- AXD    ,	21-Oct-82 19:07:50-- SXS   ,	 8-Oct-82 20:34:16DIRECTORY  Ascii USING [CR, SP, TAB],  AsciiSink USING [],  BitBlt: TYPE USING [BitBltFlags, SrcFunc],  Display: TYPE USING [Black, Block, BreakReason, Character, MeasureBlock, White],  Environment USING [Block],  TextDisplay USING [z],  TextSink USING [    Action, ActionResult, BreakReason, ErrorCode, Handle, MeasureCharProc,    Procedures, ProceduresObject, TextBlock],  Window USING [Box, Handle, Place],  WindowFont USING [Handle, CharWidth, defaultFont, FontHeight];TextSinks: PROGRAM IMPORTS Display, TextDisplay, WindowFont EXPORTS AsciiSink =  BEGIN  -- Definitions  AsciiSink: TYPE = LONG POINTER TO AsciiSinkObject;  AsciiSinkObject: TYPE = RECORD [    procs: TextSink.Procedures,    font: WindowFont.Handle,    fontHeight: CARDINAL,    tabStop: CARDINAL];  asciiProcs: TextSink.ProceduresObject ¬ [    actOn: ActOn, display: DisplayBlock, fontInfo: FontInfo, measure: MeasureBlock,    measureChar: CharWidth, positions: PositionsInBlock, resolve: ResolveBlock];  -- Procedures  Error: PUBLIC ERROR [code: TextSink.ErrorCode] = CODE;  AbsToRep: PROCEDURE [TextSink.Handle] RETURNS [AsciiSink] = MACHINE CODE    BEGIN END;  RepToAbs: PROCEDURE [AsciiSink] RETURNS [TextSink.Handle] = MACHINE CODE    BEGIN END;  CharWidth: TextSink.MeasureCharProc = {    s: AsciiSink = CheckSink[sink];    SELECT char FROM      Ascii.TAB => RETURN TabWidth[s.tabStop, xOffset];      Ascii.CR => RETURN WindowFont.CharWidth[Ascii.SP, s.font];      ENDCASE => RETURN WindowFont.CharWidth[char, s.font]};      Create: PUBLIC PROCEDURE [font: WindowFont.Handle] RETURNS [TextSink.Handle] =    BEGIN    sink: AsciiSink ¬ TextDisplay.z.NEW[      AsciiSinkObject ¬ [      procs: @asciiProcs, font: font, fontHeight: WindowFont.FontHeight[font],      tabStop: WindowFont.CharWidth[Ascii.SP, font]*8]];    RETURN[@sink.procs];    END;  Info: PUBLIC PROCEDURE [sink: TextSink.Handle]    RETURNS [font: WindowFont.Handle] = {    RETURN[IF sink­ # @asciiProcs THEN NIL ELSE AbsToRep[sink].font]};  IsIt: PUBLIC PROCEDURE [sink: TextSink.Handle] RETURNS [BOOLEAN] = {    RETURN[sink­ = @asciiProcs]};  ActOn: PROCEDURE [sink: TextSink.Handle, action: TextSink.Action]    RETURNS [TextSink.ActionResult] =    BEGIN    SELECT action FROM      destroy => TextDisplay.z.FREE[@sink];      sleep, wakeup => NULL;      ENDCASE => ERROR Error[invalidParameters];    RETURN[ok];    END;  DisplayBlock: PUBLIC PROCEDURE [    sink: TextSink.Handle, block: TextSink.TextBlock, lineLength, offset: INTEGER,    window: Window.Handle, place: Window.Place, flags: BitBlt.BitBltFlags]    RETURNS [      newPlace: Window.Place, positions: CARDINAL ¬ 0,      why: TextSink.BreakReason] = {    s: AsciiSink = CheckSink[sink];    chars: LONG POINTER TO PACKED ARRAY OF CHARACTER =      LOOPHOLE[block.blockPointer];    rightX: INTEGER = place.x + lineLength;    height: CARDINAL = sink.fontInfo[sink].lineHeight;    originalStartIndex: CARDINAL = block.startIndex;    breakReason: Display.BreakReason;    newPlace ¬ place;    DO      charsConsumed: CARDINAL;      lineLength ¬ rightX - newPlace.x;      [newPlace: newPlace, positions: charsConsumed, why: breakReason] ¬        Display.Block[        window: window, block: block­, lineLength: lineLength, place: newPlace,        font: s.font, flags: flags];      block.startIndex ¬ block.startIndex + charsConsumed;      SELECT breakReason FROM        normal => {why ¬ consumed; EXIT};        margin => {          IF chars[block.startIndex] = Ascii.SP THEN {            box: Window.Box = [newPlace, [rightX - newPlace.x, s.fontHeight]];            IF flags.srcFunc = complement THEN Display.Black[window, box]            ELSE Display.White[window, box];            block.startIndex ¬ SUCC[block.startIndex];            newPlace.x ¬ rightX};          why ¬ margin;          EXIT};        stop => {          breakChar: CHARACTER = chars[block.startIndex];          nextX: INTEGER = ComputeNextCharX[breakChar, newPlace.x, offset, s];          SELECT breakChar FROM            Ascii.CR, Ascii.TAB => {              box: Window.Box ¬ [newPlace, [nextX - newPlace.x, s.fontHeight]];              IF nextX > rightX THEN box.dims.w ¬ rightX - newPlace.x;              IF flags.srcFunc = complement THEN Display.Black[window, box]              ELSE Display.White[window, box];              block.startIndex ¬ SUCC[block.startIndex];              newPlace.x ¬ MIN[nextX, rightX];              IF breakChar = Ascii.CR THEN {why ¬ eol; EXIT};              IF nextX > rightX THEN {why ¬ margin; EXIT}};            ENDCASE => {              IF nextX > rightX THEN {why ¬ margin; EXIT};              newPlace ¬ Display.Character[                window: window, char: breakChar, place: newPlace, font: s.font,                flags: flags];              block.startIndex ¬ block.startIndex + 1}};        ENDCASE => ERROR Error[other];      ENDLOOP;    RETURN[newPlace, block.startIndex - originalStartIndex, why]};  FontInfo: PROCEDURE [sink: TextSink.Handle]    RETURNS [lineHeight, minWidth, maxWidth: CARDINAL] =    BEGIN    s: AsciiSink = CheckSink[sink];    font: WindowFont.Handle =      IF s.font = NIL THEN WindowFont.defaultFont ELSE s.font;    RETURN[font.height, 0, font.maxWidth];    END;  MeasureBlock: PROC [    sink: TextSink.Handle, block: TextSink.TextBlock, lineLength, offset: INTEGER,    place: Window.Place]    RETURNS [      newPlace: Window.Place, positions: CARDINAL ¬ 0,      why: TextSink.BreakReason] = {    s: AsciiSink = CheckSink[sink];    chars: LONG POINTER TO PACKED ARRAY OF CHARACTER =      LOOPHOLE[block.blockPointer];    rightX: INTEGER = place.x + lineLength;    savedStartIndex: CARDINAL = block.startIndex;    newPlace ¬ place;    DO      charsConsumed: CARDINAL;      breakReason: Display.BreakReason;      lineLength ¬ rightX - newPlace.x;      [newPlace, charsConsumed, breakReason] ¬ Display.MeasureBlock[        NIL, block­, lineLength, newPlace, s.font];      block.startIndex ¬ block.startIndex + charsConsumed;      SELECT breakReason FROM        normal => {why ¬ consumed; EXIT};        margin => {          IF chars[block.startIndex] = Ascii.SP THEN {            block.startIndex ¬ SUCC[block.startIndex]; newPlace.x ¬ rightX};          why ¬ margin;          EXIT};        stop => {          breakChar: CHARACTER = chars[block.startIndex];          nextX: INTEGER = ComputeNextCharX[breakChar, newPlace.x, offset, s];          SELECT breakChar FROM            Ascii.CR, Ascii.TAB => {              block.startIndex ¬ SUCC[block.startIndex];              newPlace.x ¬ MIN[nextX, rightX];              SELECT TRUE FROM                breakChar = Ascii.CR => {why ¬ eol; EXIT};                nextX > rightX => {why ¬ margin; EXIT};                ENDCASE};            ENDCASE => {              IF nextX > rightX THEN {why ¬ margin; EXIT};              newPlace.x ¬ nextX;              block.startIndex ¬ SUCC[block.startIndex]}};        ENDCASE => ERROR Error[other];      ENDLOOP;    RETURN[newPlace, block.startIndex - savedStartIndex, why]};  PositionsInBlock: PUBLIC PROCEDURE [    sink: TextSink.Handle, block: TextSink.TextBlock] RETURNS [CARDINAL] = {    s: AsciiSink = CheckSink[sink];    RETURN[block.stopIndexPlusOne - block.startIndex]};  ResolveBlock: PUBLIC PROCEDURE [    sink: TextSink.Handle, block: TextSink.TextBlock,    startX, xToFind, offset: INTEGER, halfCharResolve: BOOLEAN ¬ TRUE]    RETURNS [newX: INTEGER, positions: CARDINAL, why: TextSink.BreakReason] =    BEGIN    s: AsciiSink = CheckSink[sink];    x: INTEGER ¬ startX;    charWidth: INTEGER;    char: CHARACTER;    array: LONG POINTER TO PACKED ARRAY OF CHARACTER =      LOOPHOLE[block.blockPointer];    positions ¬ 0;    FOR i: CARDINAL IN [block.startIndex..block.stopIndexPlusOne) DO      char ¬ array[i];      SELECT char FROM        Ascii.CR => {why ¬ eol; EXIT};        Ascii.TAB => charWidth ¬ TabWidth[s.tabStop, x - offset];        ENDCASE => charWidth ¬ WindowFont.CharWidth[char, s.font];      IF x + (IF halfCharResolve THEN charWidth/2 ELSE charWidth) >= xToFind THEN        {why ¬ margin; EXIT};      x ¬ x + charWidth;      positions ¬ positions + 1;      REPEAT FINISHED => why ¬ consumed;      ENDLOOP;    newX ¬ x;    block.startIndex ¬ block.startIndex + positions;    RETURN[newX, positions, why];    END;  CheckSink: PROCEDURE [sink: TextSink.Handle] RETURNS [s: AsciiSink] = {    IF sink­ # @asciiProcs THEN ERROR Error[invalidSink]; s ¬ AbsToRep[sink]};  ComputeNextCharX: PROCEDURE [char: CHARACTER, x, offset: INTEGER, s: AsciiSink]    RETURNS [INTEGER] = {    width: INTEGER =      SELECT char FROM        Ascii.TAB => TabWidth[s.tabStop, x - offset],        Ascii.CR => WindowFont.CharWidth[Ascii.SP, s.font],        ENDCASE => WindowFont.CharWidth[char, s.font];    RETURN[x + width]};  TabWidth: PROCEDURE [tabStop: CARDINAL, x: INTEGER] RETURNS [width: CARDINAL] =    {    RETURN[      IF (width ¬ tabStop - x MOD tabStop) < tabStop/8 THEN width + tabStop      ELSE width]};  END. -- of TextSinks.mesa
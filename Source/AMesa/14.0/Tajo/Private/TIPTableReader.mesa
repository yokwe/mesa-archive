-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- TIPTableReader.mesa; Last Edited by:-- CXH   ,	28-Feb-83 15:04:53-- PXK    ,	28-Feb-83 15:44:37-- JGS on	12-Nov-82 14:28:44-- AXD    	24-Feb-83 14:53:28-- RXJ     	18-Jan-83 16:56:36-- DWR    	 6-Feb-85 17:16:51DIRECTORY  Atom: TYPE USING [ATOM, MakeAtom],  Heap: TYPE USING [Create],  Keys: TYPE USING [KeyName],  LevelVKeys: TYPE USING [KeyName],  MFile: TYPE USING [    Acquire, CreateDirectory, Error, GetProperty, GetTimes, Handle,    maxNameLength, PropertyError, Release],  MStream: TYPE USING [Create, Error, Handle],  Runtime: TYPE USING [CallDebugger],  Stream: TYPE USING [Delete, GetBlock, GetChar],  String: TYPE USING [AppendChar, AppendString, EqualString, StringBoundsFault],  System: TYPE USING [SecondsSinceEpoch, switches],  TIP: TYPE USING [TableError],  TIPTable: TYPE USING [    BadTable, BuildTable, bytesForDate, Choice, ChoiceList, globalZone, KeyOption,    KeyState, KeyStateList, KeyStateObject, MouseActions, Results, ResultsObject,     SourceDate, Table, TableObject, Term, TermObject, TIPCSourceDate, version];TIPTableReader: MONITOR  IMPORTS Atom, TIPTable, Heap, MFile, MStream, Runtime, Stream, String, System  EXPORTS TIP, TIPTable =    BEGIN  Results: TYPE = TIPTable.Results;  ResultsObject: TYPE = TIPTable.ResultsObject;  Term: TYPE = TIPTable.Term;  TermObject: TYPE = TIPTable.TermObject;  Table: TYPE = TIPTable.Table;  TableObject: PUBLIC TYPE = TIPTable.TableObject;    createdDir: BOOLEAN ¬ FALSE; -- nano-optimization    -- Monitored Data  timeFixup: LONG POINTER TO time TermObject ¬ NIL;  keysFixup: LONG POINTER TO keys TermObject ¬ NIL;  charFixup: LONG POINTER TO char TermObject ¬ NIL;  coordsFixup: LONG POINTER TO coords TermObject ¬ NIL;    globalZone: PUBLIC UNCOUNTED ZONE ¬ Heap.Create[initial: 3, increment: 1];  BadTable: PUBLIC ERROR = CODE;  InvalidTable: PUBLIC SIGNAL [type: TIP.TableError, message: LONG STRING] = CODE;  CreateTable: PUBLIC PROC [    file: LONG STRING ¬ NIL, opaque: BOOLEAN ¬ FALSE, z: UNCOUNTED ZONE ¬ NIL,    contents: LONG STRING ¬ NIL]    RETURNS [table: Table] = {        SimpleName: PROC [s: LONG STRING] RETURNS [BOOLEAN] = INLINE {      FOR i: CARDINAL DECREASING IN [0..s.length) DO	IF s[i] = '> OR s[i] = '] THEN RETURN[FALSE];	REPEAT FINISHED => RETURN[TRUE];	ENDLOOP};    tipDirectory: STRING = "<>TIP>"L;    tipDirectoryLength: CARDINAL = 6;  --tipDirectory.length fushligener compiler can't figure it out.    starMode: BOOLEAN = System.switches['O] = down;    fullName: STRING ¬ [MFile.maxNameLength+tipDirectoryLength];    compC, fileC: MFile.Handle ¬ NIL;        GetCompiledTable: PROC [fileName: LONG STRING]      RETURNS [table: Table ¬ NIL] = {      compName: STRING = [MFile.maxNameLength+tipDirectoryLength+1];      stream: MStream.Handle;      option: TIPTable.KeyOption;      sourceDate: TIPTable.SourceDate ¬ 0;      IF ~createdDir AND ~starMode THEN {        MFile.CreateDirectory[tipDirectory ! MFile.Error => {	  Runtime.CallDebugger["TIPTableReader: Error creating TIP directory!"L];	  RETRY}];	createdDir ¬ TRUE};      String.AppendString[compName, fullName        ! String.StringBoundsFault => GOTO failed];      String.AppendChar[compName, 'C ! String.StringBoundsFault => GOTO failed];      IF ~starMode THEN        fileC ¬ MFile.Acquire[name: fullName, access: anchor, release: [] !          MFile.Error => {fileC ¬ NIL; GOTO failed}];      compC ¬ MFile.Acquire[name: compName, access: readOnly, release: [] !        MFile.Error => GOTO failed];      IF ~starMode THEN {        IF TIPTable.bytesForDate # compC.GetProperty[          TIPTable.TIPCSourceDate,	  [LOOPHOLE[LONG[@sourceDate]], 0, TIPTable.bytesForDate] !	    MFile.PropertyError => GOTO failed] THEN GOTO failed;        IF System.SecondsSinceEpoch[fileC.GetTimes[].create] # sourceDate THEN          GOTO failed;        MFile.Release[fileC]};      stream ¬ MStream.Create[compC, [] ! MStream.Error => GOTO failed];      [table, option] ¬ ReadCompiledTable[        stream, z ! TIPTable.BadTable => CONTINUE];      stream.Delete[];      IF table # NIL THEN {        IF option # none THEN {          table.link ¬ DefaultTable[option = printKeys]; table.opaque ¬ FALSE};        RETURN};    EXITS      failed => {        IF fileC # NIL THEN MFile.Release[fileC];	IF compC # NIL THEN MFile.Release[compC]}}; -- GetCompiledTable        IF file = NIL THEN ERROR InvalidTable[fileNotFound, "Don't give me NIL!"L];    IF z = NIL THEN z ¬ globalZone;    IF ~starMode AND SimpleName[file] THEN      String.AppendString[fullName, tipDirectory];    String.AppendString[fullName, file ! String.StringBoundsFault => GOTO failed];    IF System.switches['I] = up OR starMode THEN      table ¬ GetCompiledTable[file];    IF table # NIL THEN table.opaque ¬ opaque    ELSE IF starMode THEN Runtime.CallDebugger["Bogus Tip Table"L]    ELSE table ¬ TIPTable.BuildTable[fullName, opaque, z, contents];    EXITS      failed => {}};  ReadCompiledTable: PUBLIC ENTRY PROC [    s: MStream.Handle, z: UNCOUNTED ZONE ¬ NIL]    RETURNS [table: Table, keyOption: TIPTable.KeyOption ¬ none] = {    ENABLE UNWIND => NULL;    -- scratch text for atoms and such    zone: UNCOUNTED ZONE = IF z = NIL THEN TIPTable.globalZone ELSE z;    text: LONG STRING ¬ zone.NEW[StringBody [32]];    mouseActions: TIPTable.MouseActions;    opaque, up, down, move: BOOLEAN;    where: LONG INTEGER ¬ 0;  -- for debugging    Text: PROC [len: CARDINAL] = {      IF len > 255 THEN ERROR BadTable;      IF len > text.maxlength THEN {        zone.FREE[@text]; text ¬ zone.NEW[StringBody [len]]};      IF        (text.length ¬ Stream.GetBlock[          s, [LOOPHOLE[@text.text], 0, len]].bytesTransferred) # len THEN        ERROR BadTable;      where ¬ where + len};          Char: PROC RETURNS [CHARACTER] =  {      where ¬ where + 1; RETURN[Stream.GetChar[s]]};          Key: PROC RETURNS [Keys.KeyName] =  {RETURN[LOOPHOLE[Char[]]]};        GetAtom: PROC RETURNS [Atom.ATOM] = {      Text[LOOPHOLE[Char[], CARDINAL]]; RETURN[Atom.MakeAtom[text]]};          Flag: PROC RETURNS [BOOLEAN] = {      RETURN[        SELECT Char[] FROM 'F => FALSE, 'T => TRUE, ENDCASE => ERROR BadTable]};	    Int: PROC RETURNS [LONG INTEGER] = {      Bytes: TYPE = MACHINE DEPENDENT RECORD [        byte0(0:0..7), byte1(0:8..15), byte2(1:0..7), byte3(1:8..15): [0..255] ¬          0];      b: Bytes;      b.byte0 ¬ LOOPHOLE[Char[]];      b.byte1 ¬ LOOPHOLE[Char[]];      b.byte2 ¬ LOOPHOLE[Char[]];      b.byte3 ¬ LOOPHOLE[Char[]];      RETURN[LOOPHOLE[b]]};          StoreFlags: PROC = {      table.opaque ¬ opaque;      table.mouseActions ¬ mouseActions;      table.ignoreUp ¬ up;      table.ignoreDown ¬ down;      table.ignoreMove ¬ move};          ChoiceItem: PROC RETURNS [key: Keys.KeyName, choice: TIPTable.Term] = {      SELECT Char[] FROM        ') => RETURN[BS, NIL];        '( => NULL;        ENDCASE => ERROR BadTable;      key ¬ Key[];      choice ¬ Choice[];      IF Char[] # ') THEN ERROR BadTable};          Choice: PROC [skipPar: BOOLEAN ¬ FALSE]      RETURNS [choice: TIPTable.Term ¬ NIL] = {      last: TIPTable.Term ¬ NIL;      char: CHARACTER;      IF ~skipPar AND Char[] # '( THEN ERROR BadTable;      WHILE (char ¬ Char[]) # ') DO        term: TIPTable.Term ¬ Term[char];        IF last = NIL THEN choice ¬ last ¬ term ELSE last ¬ last.rest ¬ term;        ENDLOOP};	    ChoiceSeries: PROC RETURNS [series: TIPTable.Choice ¬ NIL] = {      last: TIPTable.Choice ¬ NIL;      IF Char[] # '( THEN ERROR BadTable;      WHILE Char[] # ') DO        term: TIPTable.Term = Choice[TRUE];        choice: TIPTable.Choice =	  zone.NEW[TIPTable.ChoiceList ¬ [first: term, rest: NIL]];	IF last = NIL THEN series ¬ choice ELSE last.rest ¬ choice;         last ¬ choice;	ENDLOOP};	   GetKeyState: PROC RETURNS [keyState: TIPTable.KeyState] = {      keyState.key ¬ Key[];      keyState.state ¬        SELECT Char[] FROM 'U => up, 'D => down, ENDCASE => ERROR BadTable};	    Term: PROC [char: CHARACTER] RETURNS [TIPTable.Term] = {      SELECT char FROM        '1 =>   -- keytrigger          RETURN[zone.NEW[keyTrigger TermObject ¬ 	    [variants: keyTrigger[GetKeyState[]]]]];	          '2 =>   -- mousetrigger          RETURN[zone.NEW[mouseTrigger TermObject ¬ [variants: mouseTrigger[]]]];	          'a =>   -- entertrigger          RETURN[zone.NEW[enterTrigger TermObject ¬ [variants: enterTrigger[]]]];	          'b =>   -- exittrigger          RETURN[zone.NEW[exitTrigger TermObject ¬ [variants: exitTrigger[]]]];	          '3 => {  -- timetrigger          timeTerm: timeTrigger TermObject ¬ [	    variants: timeTrigger[flavor:, mSecs:]];          msecs: CARDINAL;          timeTerm.flavor ¬            SELECT Char[] FROM 'G => gt, 'L => lt, ENDCASE => ERROR BadTable;          msecs ¬ LOOPHOLE[Char[], CARDINAL]*256;          msecs ¬ msecs + LOOPHOLE[Char[], CARDINAL];          timeTerm.mSecs ¬ msecs;          RETURN[zone.NEW[timeTrigger TermObject ¬ timeTerm]]};	          '4 =>   -- keyenable          RETURN[zone.NEW[keyEnable TermObject ¬ 	    [variants: keyEnable[keyState: GetKeyState[]]]]];	          'c => {  -- keyenable	  keyTerm: keyEnableList TermObject ¬ [	    variants: keyEnableList[list: NIL]];          keyStateList, tail: TIPTable.KeyStateList ¬ NIL;	  IF Char[] # '( THEN ERROR BadTable;	  DO	    SELECT Char[] FROM	      ') => EXIT;	      '4 => {	        keyStateList: TIPTable.KeyStateList = zone.NEW[		  TIPTable.KeyStateObject ¬ [keyState: GetKeyState[]]];		IF tail = NIL THEN keyTerm.list ¬ keyStateList		ELSE tail.rest ¬ keyStateList;		tail ¬ keyStateList};	      ENDCASE => ERROR BadTable;	    ENDLOOP;          RETURN[zone.NEW[keyEnableList TermObject ¬ keyTerm]]};	          '5 =>   -- predenable          RETURN[zone.NEW[predEnable TermObject ¬ 	    [variants: predEnable[predicate: GetAtom[]]]]];	          '6 => {  -- char          term: TIPTable.Term = zone.NEW[char TermObject ¬	    [variants: char[ch: NIL]]];	  IF charFixup # NIL THEN ERROR BadTable	  ELSE charFixup ¬ LOOPHOLE[term];          RETURN[term]};	          '7 => {  -- coords          term: TIPTable.Term = zone.NEW[coords TermObject ¬ 	    [variants: coords[xy: NIL]]];	  IF coordsFixup # NIL THEN ERROR BadTable	  ELSE coordsFixup ¬ LOOPHOLE[term];          RETURN[term]};	          '8 =>   -- choiceseries          RETURN[zone.NEW[nested TermObject ¬	    [variants: nested[statement: ChoiceSeries[]]]]];	          '9 =>   -- results          RETURN[zone.NEW[result TermObject ¬	    [variants: result[list: ParseResults[]]]]];	          '0 => {  -- time          term: TIPTable.Term = zone.NEW[time TermObject ¬	    [variants: time[t: NIL]]];	  IF timeFixup # NIL THEN ERROR BadTable	  ELSE timeFixup ¬ LOOPHOLE[term];          RETURN[term]};	          'k => {  -- keys          term: TIPTable.Term = zone.NEW[keys TermObject ¬	    [variants: keys[keys: NIL]]];	  IF keysFixup # NIL THEN ERROR BadTable	  ELSE keysFixup ¬ LOOPHOLE[term];          RETURN[term]};	          ENDCASE => ERROR BadTable};	    ParseResults: PROC RETURNS [results: TIPTable.Results ¬ NIL] = {      last: TIPTable.Results ¬ NIL;      char: CHARACTER;      IF Char[] # '( THEN ERROR BadTable;      WHILE (char ¬ Char[]) # ') DO        result: TIPTable.Results ¬ Result[char];        IF last = NIL THEN results ¬ result ELSE last.rest ¬ result;        last ¬ result;	ENDLOOP};	    Result: PROC [char: CHARACTER] RETURNS [TIPTable.Results] = {      SELECT char FROM        '1 => RETURN[zone.NEW[atom ResultsObject ¬ [v: atom[a: GetAtom[]]]]];        '2 => {	  r: LONG POINTER TO char ResultsObject = zone.NEW[	    char ResultsObject ¬ [v: char[]]];	  IF charFixup = NIL THEN ERROR BadTable;	  charFixup.ch ¬ r;	  charFixup ¬ NIL;	  RETURN[r]};        '3 => RETURN[zone.NEW[int ResultsObject ¬ [v: int[i:Int[]]]]];        '4 => {          txt: LONG STRING;          Text[LOOPHOLE[Char[], NAT]];          txt ¬ zone.NEW[StringBody [text.length]];          String.AppendString[txt, text];          RETURN[zone.NEW[string ResultsObject ¬ [v: string[s:txt]]]]};        '5 => {	  r: LONG POINTER TO coords ResultsObject = zone.NEW[	    coords ResultsObject ¬ [v: coords[]]];	  IF coordsFixup = NIL THEN ERROR BadTable;	  coordsFixup.xy ¬ r;	  coordsFixup ¬ NIL;	  RETURN[r]};        '6 => {	  r: LONG POINTER TO time ResultsObject = zone.NEW[	    time ResultsObject ¬ [v: time[]]];	  IF timeFixup = NIL THEN ERROR BadTable;	  timeFixup.t ¬ r;	  timeFixup ¬ NIL;	  RETURN[r]};        '7 => {	  r: LONG POINTER TO keys ResultsObject = zone.NEW[	    keys ResultsObject ¬ [v: keys[]]];	  IF keysFixup = NIL THEN ERROR BadTable;	  keysFixup.keys ¬ r;	  keysFixup ¬ NIL;	  RETURN[r]};        ENDCASE => ERROR BadTable};    Text[8];    IF ~String.EqualString["TIPTABLE"L, text] THEN ERROR BadTable;    IF Char[] # TIPTable.version THEN ERROR BadTable;    opaque ¬ Flag[];    mouseActions ¬ IF Char[] = 'A THEN all ELSE mostRecent;    keyOption ¬      SELECT Char[] FROM        'N => none,        'P => printKeys,        'D => defaultKeys,        ENDCASE => ERROR BadTable;    up ¬ Flag[];    down ¬ Flag[];    move ¬ Flag[];    SELECT Char[] FROM      'S => {  -- small table        small: LONG POINTER TO small TIPTable.TableObject ¬ zone.NEW[	  small TIPTable.TableObject];        table ¬ small;        StoreFlags;        small.all ¬ ChoiceSeries[]};      'F => {  -- fast table        fast: LONG POINTER TO fast TIPTable.TableObject ¬ zone.NEW[	  fast TIPTable.TableObject];        key: Keys.KeyName;        choice: TIPTable.Term ¬ NIL;        table ¬ fast;        StoreFlags;        fast.mouse ¬ Choice[];        IF Char[] # 'U THEN ERROR BadTable;        IF Char[] # '( THEN ERROR BadTable;        DO          [key, choice] ¬ ChoiceItem[];          IF choice = NIL THEN EXIT;          fast.keyUp[key] ¬ choice;          ENDLOOP;        IF Char[] # 'D THEN ERROR BadTable;        IF Char[] # '( THEN ERROR BadTable;        DO          [key, choice] ¬ ChoiceItem[];          IF choice = NIL THEN EXIT;          fast.keyDown[key] ¬ choice;          ENDLOOP;        fast.time ¬ Choice[];	fast.enter ¬ Choice[];	fast.exit ¬ Choice[]};      ENDCASE => ERROR BadTable;   zone.FREE[@text]};     EqualTables: PUBLIC PROC [t1, t2: Table] = {    IF t1.opaque # t2.opaque THEN ERROR BadTable;    IF t1.mouseActions # t2.mouseActions THEN ERROR BadTable;    IF t1.ignoreUp # t2.ignoreUp THEN ERROR BadTable;    IF t1.ignoreDown # t2.ignoreDown THEN ERROR BadTable;    IF t1.ignoreMove # t2.ignoreMove THEN ERROR BadTable;    WITH x: t1 SELECT FROM      small =>        WITH y: t2 SELECT FROM          small => EqualChoiceSeries[x.all, y.all];          fast => ERROR BadTable;          ENDCASE => ERROR BadTable;      fast =>        WITH y: t2 SELECT FROM          fast => {            EqualChoices[x.mouse, y.mouse];            FOR key: Keys.KeyName IN Keys.KeyName DO              EqualChoices[x.keyDown[key], y.keyDown[key]]; ENDLOOP;            FOR key: Keys.KeyName IN Keys.KeyName DO              EqualChoices[x.keyUp[key], y.keyUp[key]]; ENDLOOP;            EqualChoices[x.time, y.time];            EqualChoices[x.enter, y.enter];            EqualChoices[x.exit, y.exit]};          small => ERROR BadTable;          ENDCASE => ERROR BadTable;      ENDCASE => ERROR BadTable};  EqualChoiceSeries: PROC [c1, c2: TIPTable.Choice] = {    DO  -- check each choice on list      SELECT TRUE FROM        c1 = NIL AND c2 = NIL => RETURN;        c1 = NIL => ERROR BadTable;        c2 = NIL => ERROR BadTable;        ENDCASE;      EqualChoices[c1.first, c2.first];      c1 ¬ c1.rest;      c2 ¬ c2.rest;      ENDLOOP};  EqualChoices: PROC [c1, c2: TIPTable.Term] = {    DO  -- check each term on list      SELECT TRUE FROM        c1 = NIL AND c2 = NIL => RETURN;        c1 = NIL => ERROR BadTable;        c2 = NIL => ERROR BadTable;        ENDCASE;      IF c1.flavor # c2.flavor THEN ERROR BadTable;      WITH x: c1 SELECT FROM        keyTrigger =>          WITH y: c2 SELECT FROM            keyTrigger => IF x.keyState.key # y.keyState.key	      OR x.keyState.state # y.keyState.state THEN ERROR BadTable;            ENDCASE;	            timeTrigger =>          WITH y: c2 SELECT FROM            timeTrigger => IF x.flavor # y.flavor OR x.mSecs # y.mSecs THEN	      ERROR BadTable;            ENDCASE;	            keyEnable =>          WITH y: c2 SELECT FROM            keyEnable => IF x.keyState.key # y.keyState.key	      OR x.keyState.state # y.keyState.state THEN ERROR BadTable;            ENDCASE;	            keyEnableList =>          WITH y: c2 SELECT FROM            keyEnableList => {	      ky: TIPTable.KeyStateList ¬ y.list;	      FOR kx: TIPTable.KeyStateList ¬ x.list, kx.rest UNTIL kx = NIL DO	        IF ky = NIL OR kx.keyState.key # ky.keyState.key 		  OR kx.keyState.state # ky.keyState.state THEN ERROR BadTable;		ky ¬ ky.rest;		REPEAT FINISHED => IF ky # NIL THEN ERROR BadTable;		ENDLOOP};            ENDCASE;	            predEnable =>          WITH y: c2 SELECT FROM            predEnable => IF x.predicate # y.predicate THEN ERROR BadTable;            ENDCASE;	            nested =>          WITH y: c2 SELECT FROM            nested => EqualChoiceSeries[x.statement, y.statement];            ENDCASE;	            result =>          WITH y: c2 SELECT FROM            result => EqualResults[x.list, y.list];            ENDCASE;	            mouseTrigger, enterTrigger, exitTrigger, char, coords, keys, time => NULL;		ENDCASE => ERROR BadTable;      c1 ¬ c1.rest;      c2 ¬ c2.rest;      ENDLOOP};  EqualResults: PUBLIC PROC [c1, c2: TIPTable.Results] = {    DO  -- check each term on list      SELECT TRUE FROM        c1 = NIL => IF c2 = NIL THEN RETURN ELSE ERROR BadTable;        c2 = NIL => ERROR BadTable;        c1.type # c2.type => ERROR BadTable;	ENDCASE =>          WITH x: c1 SELECT FROM            atom =>              WITH y: c2 SELECT FROM                atom => IF x.a # y.a THEN ERROR BadTable;                ENDCASE;		            int =>              WITH y: c2 SELECT FROM                int => IF x.i # y.i THEN ERROR BadTable;                ENDCASE;		            string =>              WITH y: c2 SELECT FROM                string => IF ~String.EqualString[x.s, y.s] THEN ERROR BadTable;                ENDCASE;            keys, char, time, coords => {};		            ENDCASE => ERROR BadTable;	          c1 ¬ c1.rest;      c2 ¬ c2.rest;      ENDLOOP};  -- printKeyTable, defaultKeyTable: Table ¬ NIL;  DefaultTable: PUBLIC PROC [printKeys: BOOLEAN] RETURNS [table: Table] = {    CharTerm: TYPE = LONG POINTER TO char TermObject;    ResultTerm: TYPE = LONG POINTER TO result TermObject;    EnableTerm: TYPE = LONG POINTER TO keyEnable TermObject;    CharResults: TYPE = LONG POINTER TO char ResultsObject;          charRes: CharResults = globalZone.NEW[char ResultsObject ¬ [v: char[]]];    resTerm: ResultTerm = globalZone.NEW[result TermObject ¬ [      variants: result[list: charRes]]];    charTerm: CharTerm = globalZone.NEW[char TermObject ¬ [      rest: resTerm, variants: char[ch: charRes]]];    enableTerm: EnableTerm = globalZone.NEW[keyEnable TermObject ¬ [      rest: charTerm, variants: keyEnable[keyState: [CONTROL, up]]]];        IF printKeys THEN {      -- IF printKeyTable # NIL THEN RETURN[printKeyTable];          table <<¬ printKeyTable>> ¬ globalZone.NEW[fast TIPTable.TableObject];      table.ignoreDown ¬ FALSE;          WITH pkt: table SELECT FROM        fast => 	  FOR key: Keys.KeyName IN Keys.KeyName DO  -- includes CR, TAB and Space!            pkt.keyDown[key] ¬               SELECT LOOPHOLE[key, LevelVKeys.KeyName] FROM -- until 13.0                Bullet,                IN [KeypadTwo..KeypadDivide],                IN [Five..Font],                IN [Three..RightBracket],                One,                IN [ParaTab..F],                IN [C..Z],                IN [Period..OpenQuote],                IN [R..M],                IN [Space..Equal],		IN [KeypadSeven..KeypadFive],		KeypadSix,		KeypadOne,		KeypadZero,		KeypadPeriod,		KeypadComma,		DoubleQuote => enableTerm,              ENDCASE => NIL;            ENDLOOP;         ENDCASE;      RETURN[table]};          -- IF defaultKeyTable # NIL THEN RETURN[defaultKeyTable];        table <<¬ defaultKeyTable>> ¬ globalZone.NEW[fast TIPTable.TableObject];    table.ignoreDown ¬ FALSE;          WITH dkt: table SELECT FROM      fast => 	FOR key: Keys.KeyName IN Keys.KeyName DO  -- includes CR and Space!           dkt.keyDown[key] ¬              SELECT LOOPHOLE[key, LevelVKeys.KeyName] FROM  -- until 13.0               E,               IN [D..V],               K, P,               IN [W..A],               IN [I..L],               F,               IN [C..Z],               IN [R..H],               IN [N..M] => charTerm,                     Bullet,               IN [KeypadTwo..KeypadDivide],               IN [Five..Six],               Seven,               Zero,               Dash,               IN [Slash..BS],               IN [Three..Two],               IN [Nine..Nine],               IN [Comma..RightBracket],               One,	       IN [Tab..ParaTab],               IN [Period..OpenQuote],               IN [Eight..Eight],               Delete,               IN [Space..Equal],               IN [KeypadSeven..KeypadFive],               KeypadSix,               KeypadOne,               KeypadZero,               KeypadPeriod,               KeypadComma,               DoubleQuote => enableTerm,                     ENDCASE => NIL;                   ENDLOOP;         ENDCASE;    RETURN[table]};  -- DefaultTable      END. LOGDWR    	 6-Feb-85 17:16:46  Patched code for Dove keyboard.  We need a clean up for Mesa 13.0   
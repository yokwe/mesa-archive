-- File: SymbioteImpl.mesa - last edit:-- Riggle.PA           29-Aug-86 11:38:05-- Copyright (C) 1981, 1982 , 1986 by Xerox Corporation. All rights reserved. -- File: SymbioteImpl.mesa - last edit by: -- Mark:	31-May-81 20:13:44-- SXS   :	 7-Oct-82 12:39:57-- PXK    :	11-Nov-82 14:43:16-- JGS:		 7-Aug-81 14:43:58-- BGY     :	21-Dec-82 15:02:19-- A package to allow symbiotic sws to be attached to host sws.DIRECTORY  Context USING [Create, Destroy, Find, Type, UniqueType],  Heap USING [systemZone],  Symbiote USING [ErrorCode],  Tool USING [AddThisSW, DeleteThisSW, IsIt, RegisterSWType, SWType],  ToolWindow USING [Destroy, Handle, Type, WindowForSubwindow],  Window USING [GetParent, Handle, IsDescendantOfRoot];  SymbioteImpl: PROGRAM  IMPORTS Context, Heap, Tool, ToolWindow, Window  EXPORTS Symbiote =  BEGIN  -- TYPEs  SymbioteHandle: TYPE = LONG POINTER TO SymbioteObject;  -- goes on symbiote sw  SymbioteObject: TYPE = RECORD [    link: SymbioteHandle,  -- all symbiotes in same window are linked    host: HostHandle,    symbioteContextType: Context.Type,    symbSW,    toolW: Window.Handle,    beingDestroyed: BOOLEAN -- !KLUDGE! this value is used after this node is freed, so let's put it at the end where it might be safer.  ];      HostHandle: TYPE = LONG POINTER TO HostObject;  -- goes on host sw  HostObject: TYPE = RECORD [    symbiote: SymbioteHandle,    hostSW: Window.Handle];  HostSymbList: TYPE = LONG POINTER TO HostSymbListObject;  -- goes on host w  HostSymbListObject: TYPE = RECORD [list: SymbioteHandle ¬ NIL];    -- Global variables  Error: PUBLIC ERROR [Symbiote.ErrorCode] = CODE;  z: UNCOUNTED ZONE = Heap.systemZone;    hostWindowContext: Context.Type = Context.UniqueType[];  symbioteContext: Context.Type ¬ Context.UniqueType[];  symbDefaultType: Tool.SWType = Tool.RegisterSWType[];-- Procedural interface  AttachSymbioteSW: PUBLIC PROCEDURE [    hostSW, symbioteSW: Window.Handle,    symbioteContextType: Context.Type, symbioteSWType: Tool.SWType ¬ predefined] =    BEGIN    w: Window.Handle;    hostHandle: HostHandle;    symb: SymbioteHandle;    hostSymbList: HostSymbList;    IF symbioteSW = NIL OR hostSW = NIL OR ToolWindow.Type[hostSW] # sub THEN      ERROR Error[invalidParameters];    IF ~Tool.IsIt[w ¬ ToolWindow.WindowForSubwindow[hostSW]] THEN       ERROR Error[invalidParameters];    IF Context.Find[symbioteContextType, hostSW] # NIL THEN ERROR Error[alreadyExists];    hostHandle ¬ z.NEW[HostObject];    symb ¬ z.NEW[      SymbioteObject ¬ [        beingDestroyed: FALSE,	link: NIL,	host: hostHandle,	symbioteContextType: symbioteContextType,	symbSW: symbioteSW,	toolW: w]];    hostHandle­ ¬ [symb, hostSW];    Context.Create[symbioteContextType, hostHandle, DestroyHostSW, hostSW];    IF (hostSymbList ¬ Context.Find[hostWindowContext, w]) = NIL THEN      BEGIN      hostSymbList ¬ z.NEW[HostSymbListObject ¬ []];      Context.Create[hostWindowContext, hostSymbList, DestroyHostW, w];      END;    symb.link ¬ hostSymbList.list;    hostSymbList.list ¬ symb;    Context.Create[symbioteContext, symb, DestroySymbiote, symbioteSW];    SymbioteAddEnlinkSW[w, hostSW, symb, symbioteSWType];     END;      DetachSymbioteSW: PUBLIC PROCEDURE [symbioteSW: Window.Handle] =    BEGIN    symb: SymbioteHandle;    IF symbioteSW = NIL THEN ERROR Error[invalidParameters];    IF (symb ¬ Context.Find[symbioteContext, symbioteSW]) = NIL THEN Error[doesNotExist];    Tool.DeleteThisSW[symb.symbSW]; -- order important, since next line causes ToolWindow.Destroy    Context.Destroy[symb.symbioteContextType, symb.host.hostSW];    END;      HostForSymbiote: PUBLIC PROCEDURE [symbioteSW: Window.Handle]    RETURNS [hostSW: Window.Handle] =    BEGIN    symb: SymbioteHandle;    hostSW ¬ IF (symb ¬ Context.Find[symbioteContext, symbioteSW]) # NIL AND symb.host # NIL      THEN symb.host.hostSW ELSE NIL;    END;      SymbioteForHost: PUBLIC PROCEDURE [hostSW: Window.Handle, symbioteContextType: Context.Type]    RETURNS [symbioteSW: Window.Handle] =    BEGIN    h: HostHandle;    symbioteSW ¬ IF (h ¬ Context.Find[symbioteContextType, hostSW]) = NIL THEN NIL    ELSE h.symbiote.symbSW;    END;    -- Context/sw destruction management routines  DestroyHostW: PROCEDURE [hostlist: HostSymbList, w: Window.Handle] =     {z.FREE[@hostlist]};      DestroyHostSW: PROCEDURE [host: HostHandle, w: Window.Handle] =    BEGIN    -- ToolWindow.Destroy on a sw that is in a window in the process of being destroyed    --   may chase bad pointers through deallocated older siblings so we check    -- the window tree for this case explicitly.    IF ~host.symbiote.beingDestroyed AND w.GetParent[] # NIL AND w.GetParent[].IsDescendantOfRoot[] THEN      ToolWindow.Destroy[host.symbiote.symbSW];--    host.symbiote.host ¬ NIL;  ++ snap his link since target is vanishing    z.FREE[@host];    END;      DestroySymbiote: PROCEDURE [symb: SymbioteHandle, w: Window.Handle] =    BEGIN    -- It is assumed that the host context will be removed by the caller.    -- Destruction of the host window or sw, or a call to DetachSymbiote do this.    hostW: Window.Handle ¬ symb.toolW;    symb.beingDestroyed ¬ TRUE;    IF hostW # NIL THEN      BEGIN      head: HostSymbList = Context.Find[hostWindowContext, hostW];      SELECT TRUE FROM	head = NIL => NULL;	head.list # symb =>	  FOR temp: SymbioteHandle ¬ head.list, temp.link UNTIL temp = NIL DO	    IF temp.link = symb THEN {temp.link ¬ symb.link; EXIT};	    ENDLOOP;	ENDCASE =>	  BEGIN	  head.list ¬ head.list.link;	  IF head.list = NIL THEN	    BEGIN  -- last symbiote	    Context.Destroy[hostWindowContext, hostW];  -- order matters!	    END	  END;      END;    z.FREE[@symb];    END;    -- Utilities  SymbioteAddEnlinkSW: PROCEDURE [    window, sw: Window.Handle, symb: SymbioteHandle, type: Tool.SWType] =    BEGIN -- Enlinks symbs    head: HostSymbList = Context.Find[hostWindowContext, window];    IF head = NIL THEN RETURN;  -- oops, something is mashed!    Tool.AddThisSW[window, symb.symbSW, type, sw];    END;        -- Mainline code  END.  -- of SymbiotesA    
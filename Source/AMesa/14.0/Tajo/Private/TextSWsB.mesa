-- Copyright (C) 1981, 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- File: TextSWsB.mesa - last edited: -- PXK    :	28-Nov-82 19:43:38-- SXW   :	21-Jul-81 22:49:34-- JGS:	 	 8-Sep-81 11:00:11-- Mark:	 4-Feb-81 20:35:59-- BXM  :	 5-Sep-81 15:54:46-- SEH:	 	16-Jul-82 10:49:58-- BGY     :	16-Dec-82 11:18:17-- AXD    	 3-Nov-83 18:22:22-- DWR    	 17-Oct-84 12:46:42  changed scrollVertical & added SetPositionWithOverRideDIRECTORY  Context: TYPE USING [Create, Destroy, Find, Type, UniqueType],  Cursor: TYPE USING [Set, Type],  Environment: TYPE USING [Block],  Heap: TYPE USING [systemZone],  Inline: TYPE USING [HighHalf, LowHalf],  Profile: TYPE USING [balanceBeamChoice],  ProfileExtra USING [SetPositionBalanceBeamChoice],  Scrollbar: TYPE USING [ScrollbarProcType, ScrollProcType],  Selection: TYPE USING [    Action, Convert, Set, SetInsertion, Source, SourceObject, Target],  String: TYPE USING [AppendChar, MakeString],  TEdit: TYPE USING [notSet, place, state, time],  TextData: TYPE USING [    InsertionObject, MarkingAction, Position, Selection, SelectionObject],  TextDisplay: TYPE USING [    BackupNLines, ExtendPositionInterval, GetEOF, GetPosition, Handle,     LastDisplayedLine, MarkingAction, MarkInsertion, MarkSelection, MoveLines, noPlace,     Position, PositionFromWindowPlace, PositionIsVisible, Selection, SetEOF,     SetPosition, TextLines, Update, UpdateSelection],  TextDisplayExtra USING [SetPositionWithOverRide],  TextSource: TYPE USING [Handle, nullPosition, Position, ReadText],  TextSW: TYPE USING [defaultOptions, Options],  TextSWExtra: TYPE USING [],  TextSWExtraExtra: TYPE,  TextSWOps: TYPE USING [    InOp, InsertSource, InsertSourceObject, InternalDeleteText, InternalValidate,    lastTime, lock, MarkOtherSelections, PToUse, RealActOnCaret, SelectionClass,    SetSecondaryInternal, textSWContext, TSWContext, TSWSource, TSWSourceObject],  TIP: TYPE USING [clickTimeout, GetNotifyProc, GetPlace, mouseTIP, NewManager],  ToolWindow: TYPE USING [Handle, WindowForSubwindow],  UserInput: TYPE USING [SetInputFocus],  UserTerminal: TYPE USING [BlinkDisplay],  Window: TYPE USING [Handle, Place];  TextSWsB: MONITOR LOCKS TextSWOps.lock  IMPORTS    Context, Cursor, Heap, Inline, Profile, Selection, String, TEdit, TextDisplay, TextDisplayExtra,    TextSource, TextSWOps, TIP, ToolWindow, UserInput, UserTerminal  EXPORTS TEdit, TextSW, TextSWExtra, TextSWExtraExtra, TextSWOps =  BEGIN OPEN TextSWOps;  z: UNCOUNTED ZONE = Heap.systemZone;    LocalFind: PROC [sw: Window.Handle] RETURNS [tsw: TSWContext] = {    IF (tsw ¬ Context.Find[textSWContext, sw]) = NIL THEN      UserTerminal.BlinkDisplay[]};  -- Select and Extend Routines NormalizedPosition: PROC [p: TextDisplay.Handle, place: Window.Place]    RETURNS [pos: TextSource.Position] = {    pos ¬ p.PositionFromWindowPlace[place, FALSE].position;    IF pos > 0 AND pos = p.source.getLength[p.source] THEN pos ¬ pos - 1};  MarkSelectionInternal: PROC [tsw: TSWContext, sel: TextData.Selection] = {    sel.marked ¬ FALSE;    FOR i: CARDINAL IN [1..tsw.splits.length) DO      tsw.splits[i].MarkSelection[sel, mark];      sel.marked ¬ FALSE;      ENDLOOP;    tsw.splits[0].MarkSelection[sel, mark];    TextSWOps.InternalValidate[tsw.sw]};    UpdateSelectionInternal: PROC [tsw: TSWContext, old, new: TextData.Selection] = {    new.marked ¬ FALSE;    FOR i: CARDINAL IN [1..tsw.splits.length) DO      old2: TextData.SelectionObject ¬ old­;      new2: TextData.SelectionObject ¬ new­;      tsw.splits[i].UpdateSelection[@old2, @new2];      ENDLOOP;    tsw.splits[0].UpdateSelection[old, new];    TextSWOps.InternalValidate[tsw.sw]};    selContext: Context.Type = Context.UniqueType[];  MySimpleDestroy: PROC [object: LONG POINTER, w: Window.Handle] = {    z.FREE[@object]};    SelRec: TYPE = RECORD [    object: TextData.SelectionObject,    p: TextDisplay.Handle,    lastPos: TextSource.Position,    insertToSel: BOOLEAN,    class: SelectionClass];    multiClicking: BOOLEAN ¬ TRUE;  CancelMultiClick: PUBLIC PROC = {multiClicking ¬ FALSE};    WithinClickTimeout: PROC RETURNS [BOOLEAN] = {    RETURN[multiClicking AND TEdit.time - lastTime < TIP.clickTimeout]};    StartSelection: PUBLIC PROC [tsw: TSWContext, class: SelectionClass] = {    sel: LONG POINTER TO SelRec;    StartSelectionLocked: ENTRY PROC = {      ENABLE UNWIND => NULL;      pToUse: TextDisplay.Handle = PToUse[tsw, TEdit.place.y, FALSE];      position: TextSource.Position = NormalizedPosition[pToUse, TEdit.place];      left, right: TextSource.Position;      IF TEdit.state.selEntity = TEdit.notSet AND class = primary         AND TEdit.state.selMode = tsw.selection.mode         AND WithinClickTimeout[] AND position >= tsw.selection.left         AND position < tsw.selection.right THEN {	  TEdit.state.selEntity ¬ SELECT tsw.selection.entity FROM	    text => word,	    word => line,	    line => document,	    ENDCASE => text;	  IF TEdit.state.selEntity # text THEN	    [left, right] ¬ pToUse.ExtendPositionInterval[	      tsw.selection.left, tsw.selection.right, TEdit.state.selEntity]	  ELSE	    [left, right] ¬ pToUse.ExtendPositionInterval[	      position, position, text]}      ELSE {        IF TEdit.state.selEntity = TEdit.notSet THEN TEdit.state.selEntity ¬ text;        [left, right] ¬ pToUse.ExtendPositionInterval[          position, position, TEdit.state.selEntity]};      sel ¬ z.NEW[SelRec ¬ [        object: [	  left: left, right: right, entity: TEdit.state.selEntity, 	  mode: TEdit.state.selMode, marked: FALSE],         p: pToUse, lastPos: position, insertToSel: TEdit.state.insertToSel,        class: class]];      Context.Create[selContext, sel, MySimpleDestroy, tsw.sw];      TEdit.state.inSel ¬ sel;      TIP.NewManager[tsw.sw, TIP.mouseTIP, TIP.GetNotifyProc[tsw.sw]];      IF class = primary THEN         UpdateSelectionInternal[tsw, @tsw.selection, @sel.object]      ELSE MarkSelectionInternal[tsw, @sel.object]};    StartSelectionLocked;    IF sel.insertToSel THEN InsertionToSelection[tsw, TEdit.place, @sel.object]};      TrackSelectionLocked: ENTRY PROC [    tsw: TSWContext, sel: LONG POINTER TO SelRec] = INLINE {    ENABLE UNWIND => NULL;    TrackSelectionInternal[tsw, sel]};    TrackSelection: PUBLIC PROC [tsw: TSWContext] = {    sel: LONG POINTER TO SelRec = Context.Find[selContext, tsw.sw];    IF sel # NIL THEN {      TrackSelectionLocked[tsw, sel];      IF sel.insertToSel THEN        InsertionToSelection[tsw, TEdit.place, @sel.object]}};    TrackSelectionInternal: INTERNAL PROC [    tsw: TSWContext, sel: LONG POINTER TO SelRec] = {    newPos: TextSource.Position;    oldSel: TextData.SelectionObject;    IF sel = NIL THEN {TEdit.state.inSel ¬ none; RETURN};    newPos ¬ NormalizedPosition[sel.p, TEdit.place];    IF newPos = sel.lastPos       OR newPos IN [sel.object.left..sel.object.right) THEN RETURN;    oldSel ¬ sel.object;    [sel.object.left, sel.object.right] ¬ sel.p.ExtendPositionInterval[      newPos, newPos, oldSel.entity];    UpdateSelectionInternal[tsw, @oldSel, @sel.object];    sel.lastPos ¬ newPos};    FinishSelection: PUBLIC PROC [tsw: TSWContext] = {    sel: LONG POINTER TO SelRec = Context.Find[selContext, tsw.sw];    FinishSelectionLocked: ENTRY PROC = {      ENABLE UNWIND => NULL;      TrackSelectionInternal[tsw, sel]; -- just in case we moved      IF sel.class = primary THEN tsw.selection ¬ sel.object      ELSE SetSecondaryInternal[        tsw, z.NEW[TextData.SelectionObject ¬ sel.object]];      TEdit.state.inSel ¬ none};    IF sel = NIL THEN {TEdit.state.inSel ¬ none; RETURN};    FinishSelectionLocked;    lastTime ¬ TEdit.time;    multiClicking ¬ TRUE;    IF sel.insertToSel THEN InsertionToSelection[tsw, TEdit.place, @sel.object];    TIP.NewManager[NIL, NIL];    Context.Destroy[selContext, tsw.sw]};    RubberBase: TYPE = {left, right};      ExtRec: TYPE = RECORD [    object: TextData.SelectionObject,    p: TextDisplay.Handle,    lastPos: TextSource.Position,    insertToSel: BOOLEAN,    rubberBase: RubberBase];    extContext: Context.Type = Context.UniqueType[];    GetEndpointsForExtend: PROC [    p: TextDisplay.Handle, select: TextData.Selection, pos: TextSource.Position,    base: RubberBase] RETURNS [left, right: TextSource.Position] = {    cLeft, cRight: TextSource.Position;    [cLeft, cRight] ¬ p.ExtendPositionInterval[pos, pos, select.entity];    left ¬ IF base = left THEN select.left ELSE cLeft;    right ¬ IF base = right THEN select.right ELSE cRight};    StartExtend: PUBLIC PROC [tsw: TSWContext] = {    sel: LONG POINTER TO ExtRec;    StartExtendLocked: ENTRY PROC = {      ENABLE UNWIND => NULL;      pToUse: TextDisplay.Handle = PToUse[tsw, TEdit.place.y, FALSE];      position: TextSource.Position = NormalizedPosition[pToUse, TEdit.place];      diffL: LONG INTEGER = position - tsw.selection.left;      diffR: LONG INTEGER = position - tsw.selection.right;      base: RubberBase = IF ABS[diffL] < ABS[diffR] THEN right ELSE left;      left, right: TextSource.Position;      IF TEdit.state.selEntity = TEdit.notSet THEN        IF position = tsw.selection.left	  OR position = tsw.selection.right - 1 THEN	    TEdit.state.selEntity ¬ tsw.selection.entity ¬ text	ELSE TEdit.state.selEntity ¬ tsw.selection.entity      ELSE tsw.selection.entity ¬ TEdit.state.selEntity;      [left, right] ¬ GetEndpointsForExtend[        pToUse, @tsw.selection, position, base];      sel ¬ z.NEW[ExtRec ¬ [        object: [	  left: left, right: right, entity: TEdit.state.selEntity, 	  mode: TEdit.state.selMode, marked: FALSE],         p: pToUse, lastPos: position, insertToSel: TEdit.state.insertToSel,        rubberBase: base]];      Context.Create[extContext, sel, MySimpleDestroy, tsw.sw];      TEdit.state.inSel ¬ ext;      TIP.NewManager[tsw.sw, TIP.mouseTIP, TIP.GetNotifyProc[tsw.sw]];      UpdateSelectionInternal[tsw, @tsw.selection, @sel.object]};    StartExtendLocked;    IF sel.insertToSel THEN InsertionToSelection[tsw, TEdit.place, @sel.object]};    TrackExtendLocked: ENTRY PROC [    tsw: TSWContext, sel: LONG POINTER TO ExtRec] = INLINE {    ENABLE UNWIND => NULL;    TrackExtendInternal[tsw, sel]};    TrackExtend: PUBLIC PROC [tsw: TSWContext] = {    sel: LONG POINTER TO ExtRec = Context.Find[extContext, tsw.sw];    IF sel # NIL THEN {      TrackExtendLocked[tsw, sel];      IF sel.insertToSel THEN        InsertionToSelection[tsw, TEdit.place, @sel.object]}};  TrackExtendInternal: INTERNAL PROC [    tsw: TSWContext, sel: LONG POINTER TO ExtRec] = {    newPos: TextSource.Position;    oldSel: TextData.SelectionObject;    IF sel = NIL THEN {TEdit.state.inSel ¬ none; RETURN};    IF (newPos ¬ NormalizedPosition[sel.p, TEdit.place]) = sel.lastPos       THEN RETURN;    oldSel ¬ sel.object;    SELECT TRUE FROM      sel.rubberBase = left AND newPos < tsw.selection.left => {        sel.object ¬ tsw.selection; sel.rubberBase ¬ right};      sel.rubberBase = right AND newPos >= tsw.selection.right => {        sel.object ¬ tsw.selection; sel.rubberBase ¬ left};      ENDCASE;    [sel.object.left, sel.object.right] ¬ GetEndpointsForExtend[      sel.p, @sel.object, newPos, sel.rubberBase];    UpdateSelectionInternal[tsw, @oldSel, @sel.object];    sel.lastPos ¬ newPos};      FinishExtend: PUBLIC PROC [tsw: TSWContext] = {    sel: LONG POINTER TO ExtRec = Context.Find[extContext, tsw.sw];    FinishExtendLocked: ENTRY PROC = {      ENABLE UNWIND => NULL;      TrackExtendInternal[tsw, sel]; -- just in case we moved      tsw.selection ¬ sel.object;      TEdit.state.inSel ¬ none};    IF sel = NIL THEN {TEdit.state.inSel ¬ none; RETURN};    FinishExtendLocked;    lastTime ¬ TEdit.time;    multiClicking ¬ TRUE;    IF sel.insertToSel THEN InsertionToSelection[tsw, TEdit.place, @sel.object];    TIP.NewManager[NIL, NIL];    Context.Destroy[extContext, tsw.sw]};  BecomeInputFocus: PUBLIC PROC [sw: Window.Handle] = {    tsw: TSWContext = LocalFind[sw];    IF tsw # NIL THEN TakeInputFocus[tsw]};      TakeInputFocus: PUBLIC PROC [tsw: TSWContext] = {    takes: BOOLEAN = tsw.options.access # read;    UserInput.SetInputFocus[tsw.sw, LoseInputFocus, takes];    IF takes THEN {Cursor.Set[textPointer]}};  LoseInputFocus: PROC [sw: Window.Handle, nil: LONG POINTER] = {    Cursor.Set[groundedText]};  -- Position Procedures  DisplayHandleFromPlace: PUBLIC ENTRY PROC [    sw: Window.Handle, place: Window.Place] RETURNS [display: TextDisplay.Handle] = {    ENABLE UNWIND => NULL;    tsw: TSWContext = LocalFind[sw];    RETURN[IF tsw = NIL THEN NIL ELSE PToUse[tsw, place.y, FALSE]]};  GetEOF: PUBLIC ENTRY PROC [sw: Window.Handle]    RETURNS [eof: TextSource.Position] = {    ENABLE UNWIND => NULL;    tsw: TSWContext = LocalFind[sw];    eof ¬      IF tsw # NIL THEN TextDisplay.GetEOF[tsw.splits[0]]      ELSE TextSource.nullPosition};  GetPosition: PUBLIC ENTRY PROC [sw: Window.Handle, line: CARDINAL]    RETURNS [position: TextSource.Position] = {    ENABLE UNWIND => NULL;    tsw: TSWContext = LocalFind[sw];    position ¬      IF tsw # NIL THEN TextDisplay.GetPosition[tsw.splits[0], line]      ELSE TextSource.nullPosition};  PositionFromPlace: PUBLIC ENTRY PROC [    sw: Window.Handle, place: Window.Place]    RETURNS [position: TextSource.Position] = {    ENABLE UNWIND => NULL;    tsw: TSWContext = LocalFind[sw];    pToUse: TextDisplay.Handle;    IF tsw = NIL THEN RETURN[TextSource.nullPosition];    pToUse ¬ PToUse[tsw, place.y, FALSE];    RETURN[TextDisplay.PositionFromWindowPlace[pToUse, place].position]};  PositionIsVisible: PUBLIC ENTRY PROC [    sw: Window.Handle, position: TextSource.Position] RETURNS [BOOLEAN] = {    ENABLE UNWIND => NULL;    tsw: TSWContext = LocalFind[sw];    i: CARDINAL;    IF tsw # NIL THEN      FOR i IN [0..tsw.splits.length) DO        IF TextDisplay.PositionIsVisible[tsw.splits[i], position] THEN          RETURN[TRUE];        ENDLOOP;    RETURN[FALSE]};  SetEOF: PUBLIC ENTRY PROC [sw: Window.Handle, eof: TextSource.Position] = {    ENABLE UNWIND => NULL;    tsw: TSWContext = LocalFind[sw];    IF tsw # NIL THEN {      i: CARDINAL;      RealActOnCaret[tsw, clear];      IF tsw.insertion.position > eof THEN {        ModifyInsertionState[tsw: tsw, op: change, pos: eof];        tsw.insertion.place ¬ TextDisplay.noPlace};      FOR i IN [0..tsw.splits.length) DO        TextDisplay.SetEOF[tsw.splits[i], eof, @tsw.selection]; ENDLOOP}};  SetPosition: PUBLIC ENTRY PROC [    sw: Window.Handle, position: TextSource.Position] = {    ENABLE UNWIND => NULL;    tsw: TSWContext = LocalFind[sw];    IF tsw # NIL THEN {      RealActOnCaret[tsw, clear];      TextDisplay.SetPosition[tsw.splits[0], position, @tsw.selection];      IF tsw.otherSels # NIL THEN        FOR i: CARDINAL IN [0..tsw.splits.length) DO          MarkOtherSelections[tsw.splits[i], tsw.otherSels]; ENDLOOP}};  SetPositionWithOverRide: PUBLIC ENTRY PROC [    sw: Window.Handle, position: TextSource.Position, overRide: ProfileExtra.SetPositionBalanceBeamChoice] = {    ENABLE UNWIND => NULL;    tsw: TSWContext = LocalFind[sw];    IF tsw # NIL THEN {      RealActOnCaret[tsw, clear];      TextDisplayExtra.SetPositionWithOverRide[tsw.splits[0], position, @tsw.selection, overRide];      IF tsw.otherSels # NIL THEN        FOR i: CARDINAL IN [0..tsw.splits.length) DO          MarkOtherSelections[tsw.splits[i], tsw.otherSels]; ENDLOOP}};  ModifyInsertionState: PUBLIC PROC [    tsw: TSWContext, op: InOp, pos: TextSource.Position] = {    SELECT op FROM      append => {        IF tsw.setOnNext THEN {          Selection.SetInsertion[            pointer: tsw, conversion: ConvertInsertion, clear: ClearInsertion];          -- order important: ClearInsertion vs. setOnNext          tsw.setOnNext ¬ FALSE;          tsw.startPos ¬ pos;          tsw.endPos ¬ TextSource.nullPosition};        tsw.curPos ¬ pos;	tsw.insertion.position ¬ pos};      change => {        tsw.setOnNext ¬ TRUE;        IF tsw.endPos = TextSource.nullPosition THEN          tsw.endPos ¬ tsw.curPos;        tsw.curPos ¬ pos;	tsw.insertion.position ¬ pos};      clear => {        Selection.SetInsertion[          pointer: NIL, conversion: ConvertInsertion, clear: ClearInsertion]}      ENDCASE => {        IF tsw.insertion.position = pos THEN RETURN;  -- no change        ModifyInsertionState[tsw,          (IF tsw.insertion.position = pos - 1 THEN append ELSE change),          pos]}};  ClearInsertion: PROC [data: TSWContext] = {    IF data # NIL THEN data.startPos ¬ data.endPos ¬ TextSource.nullPosition};  ConvertInsertion: ENTRY PROC [data: TSWContext, target: Selection.Target]    RETURNS [ptr: LONG POINTER] = {    ENABLE UNWIND => NULL;    end: TextSource.Position;    IF data = NIL THEN RETURN[NIL];    IF LocalFind[data.sw] # data THEN RETURN[NIL]; -- The window went away. A Bug!    end ¬      IF data.endPos = TextSource.nullPosition THEN data.insertion.position      ELSE data.endPos;    SELECT target FROM      length => {        p: LONG POINTER TO LONG CARDINAL ¬ z.NEW[LONG CARDINAL ¬ 	  end - data.startPos];        RETURN[p]};      source => {        iSource: InsertSource = z.NEW[InsertSourceObject ¬ [	  tsw: data, left: data.startPos, right: end]];        s: Selection.Source = z.NEW[Selection.SourceObject ¬ [          data: iSource, proc: ReadInsertSource, destroy: DestroySource]];        RETURN[s]};      string => {        str: LONG STRING;        l: CARDINAL ¬ Inline.LowHalf[end - data.startPos];        IF l < 200 THEN {          p: TextDisplay.Handle ¬ data.splits[0];          block: Environment.Block;          start, next: TextSource.Position;          str ¬ String.MakeString[z, l];          start ¬ data.startPos;          DO            [block, next] ¬ p.source.ReadText[start, l, none];            IF block.startIndex # block.stopIndexPlusOne THEN              AppendBlock[str, block];            IF next >= end OR next = p.source.getLength[p.source] THEN EXIT;            l ¬ l - Inline.LowHalf[next - start];            start ¬ next;            ENDLOOP;          RETURN[str]}        ELSE RETURN[NIL]};      subwindow => ptr ¬ data.sw;      window => ptr ¬ ToolWindow.WindowForSubwindow[data.sw];      ENDCASE => ptr ¬ NIL;    RETURN[ptr]};  -- Selection Procedures  ActOnSelection: PUBLIC ENTRY PROC [    data: TSWContext, action: Selection.Action] = {    ENABLE UNWIND => NULL;    IF action = clearIfHasInsert THEN      IF data.selection.marked        AND data.insertion.position IN [data.selection.left..data.selection.right]        THEN action ¬ clear      ELSE RETURN;    IF action = delete THEN {      IF data.options.access = edit THEN        InternalDeleteText[          data, data.selection.left, data.selection.right - data.selection.left]      ELSE UserTerminal.BlinkDisplay[]}    ELSE {      i: CARDINAL;      select2: TextData.SelectionObject;      markAction: TextData.MarkingAction =        SELECT action FROM clear, unmark => clear, ENDCASE => mark;      IF data.splits # NIL THEN {        FOR i IN [1..data.splits.length) DO          select2 ¬ data.selection;          TextDisplay.MarkSelection[data.splits[i], @select2, markAction];          ENDLOOP;        TextDisplay.MarkSelection[data.splits[0], @data.selection, markAction]};      IF action = clear THEN 	data.selection.left ¬ data.selection.right ¬ data.insertion.position;      IF markAction = mark THEN        InsertionAtSelection[data, data.selection.right]}};  ConvertSelection: PUBLIC ENTRY PROC [    data: TSWContext, target: Selection.Target] RETURNS [ptr: LONG POINTER] = {    OPEN Selection;    ENABLE UNWIND => NULL;    SELECT target FROM      position => RETURN[z.NEW[LONG CARDINAL ¬         IF data.selection.marked THEN data.selection.left	ELSE data.insertion.position]];      length => RETURN[        z.NEW[LONG CARDINAL ¬ data.selection.right - data.selection.left]];      source =>         IF data.selection.marked THEN {	  sSource: TSWSource = z.NEW[TSWSourceObject ¬ [            tsw: data, left: data.selection.left, right: @data.selection.right,            insert: data.insertion.position,            crossedInsert: data.insertion.position <= data.selection.left]];          s: Source = z.NEW[SourceObject ¬ [	    data: sSource, proc: ReadSource, destroy: DestroySource]];          RETURN[s]}	ELSE RETURN[NIL];      string =>         IF data.selection.marked THEN {          str: LONG STRING;          l: CARDINAL ¬ CARDINAL[data.selection.right - data.selection.left];          IF l < 200 THEN {            p: TextDisplay.Handle = data.splits[0];            block: Environment.Block;            start, next: TextSource.Position;            str ¬ String.MakeString[z, l];            start ¬ data.selection.left;            DO              [block, next] ¬ p.source.ReadText[start, l, none];              IF block.startIndex # block.stopIndexPlusOne THEN                AppendBlock[str, block];              IF next >= data.selection.right OR	        next = p.source.getLength[p.source] THEN EXIT;              l ¬ l - CARDINAL[next - start];              start ¬ next;              ENDLOOP;            RETURN[str]}          ELSE RETURN[NIL]}	ELSE RETURN[NIL];      subwindow => ptr ¬ data.sw;      window => ptr ¬ ToolWindow.WindowForSubwindow[data.sw];      ENDCASE => ptr ¬ NIL;    RETURN[ptr]};  GetSelection: PUBLIC ENTRY PROC [sw: Window.Handle]    RETURNS [left, right: TextSource.Position] = {    ENABLE UNWIND => NULL;    tsw: TSWContext = LocalFind[sw];    IF tsw # NIL THEN RETURN[tsw.selection.left, tsw.selection.right]    ELSE RETURN[TextSource.nullPosition, TextSource.nullPosition]};  SetSelection: PUBLIC PROC [    sw: Window.Handle, left, right: TextSource.Position] = {    tsw: TSWContext = LocalFind[sw];    IF tsw # NIL THEN {      swWithSelection: Window.Handle = Selection.Convert[subwindow];      LockedSetSelection: ENTRY PROC = {        ENABLE UNWIND => NULL;        i: CARDINAL;        old: TextData.SelectionObject ¬ tsw.selection;        tsw.selection.left ¬ left;        tsw.selection.right ¬ right;        IF swWithSelection = sw THEN {          new2, old2: TextData.SelectionObject;          FOR i IN [1..tsw.splits.length) DO            old2 ¬ old;            new2 ¬ tsw.selection;            TextDisplay.UpdateSelection[tsw.splits[i], @old2, @new2];            ENDLOOP;          TextDisplay.UpdateSelection[tsw.splits[0], @old, @tsw.selection]}        ELSE {          select2: TextData.SelectionObject;          FOR i IN [1..tsw.splits.length) DO            select2 ¬ tsw.selection;            TextDisplay.MarkSelection[tsw.splits[i], @select2, mark];            ENDLOOP;          TextDisplay.MarkSelection[tsw.splits[0], @tsw.selection, mark]};        InsertionAtSelection[tsw, right];        TextSWOps.InternalValidate[sw]};	      IF swWithSelection # sw THEN        Selection.Set[tsw, ConvertSelection, ActOnSelection];      LockedSetSelection[]}};  InsertionToSelection: PROC [    tsw: TSWContext, place: Window.Place, sel: TextData.Selection] = {    pToUse: TextDisplay.Handle = PToUse[tsw, place.y, TRUE];    IF pToUse = NIL THEN RETURN;    SELECT tsw.options.access FROM      edit, read => {	position: TextSource.Position;	SELECT TRUE FROM	  Profile.balanceBeamChoice = never => position ¬ sel.right;          Profile.balanceBeamChoice = notForCharacter            AND (sel.right - sel.left = 1) => position ¬ sel.right;          ENDCASE => {            position ¬ TextDisplay.PositionFromWindowPlace[              p: pToUse, place: place, halfCharResolve: TRUE].position;            position ¬              IF (position - sel.left) < (sel.right - position) THEN sel.left              ELSE sel.right};        InsertionAtSelection[tsw, position];        tsw.insertion.marked ¬ FALSE;        IF tsw.options.access = edit THEN {          tsw.insertion.mode ¬ triangle;          TextSWOps.RealActOnCaret[tsw, mark]};	TakeInputFocus[tsw]};      ENDCASE => TakeInputFocus[tsw]};	    InsertionAtSelection: PUBLIC PROC [tsw: TSWContext, pos: TextSource.Position] = {    -- You'd better be in the monitor    SELECT tsw.options.access FROM      edit => {        TextSWOps.RealActOnCaret[tsw, clear];        ModifyInsertionState[tsw, change, pos];        tsw.insertion.place ¬ TextDisplay.noPlace};      read => {        ModifyInsertionState[tsw, change, pos];        tsw.insertion.place ¬ TextDisplay.noPlace};      ENDCASE};  -- Information Procedures  GetInsertion: PUBLIC ENTRY PROC [sw: Window.Handle]    RETURNS [TextSource.Position] = {    ENABLE UNWIND => NULL;    tsw: TSWContext = LocalFind[sw];    RETURN[      IF tsw = NIL THEN TextSource.nullPosition      ELSE tsw.insertion.position]};  SetInsertion: PUBLIC PROC [sw: Window.Handle, position: TextSource.Position] = {    tsw: TSWContext = LocalFind[sw];    IF tsw # NIL THEN {      EntrySetInsertion: ENTRY PROC = {        ENABLE UNWIND => NULL;        insert2: TextData.InsertionObject;        FOR i: CARDINAL IN [1..tsw.splits.length) DO          insert2 ¬ tsw.insertion;          TextDisplay.MarkInsertion[tsw.splits[i], @insert2, clear];          ENDLOOP;        ModifyInsertionState[tsw: tsw, op: change, pos: position];        tsw.insertion.place ¬ TextDisplay.noPlace;        FOR i: CARDINAL IN [1..tsw.splits.length) DO          insert2 ¬ tsw.insertion;          TextDisplay.MarkInsertion[tsw.splits[i], @insert2, mark];          ENDLOOP;        TextDisplay.MarkInsertion[tsw.splits[0], @tsw.insertion, mark];        TextSWOps.InternalValidate[sw]};      EntrySetInsertion[]}};  GetOptions: PUBLIC PROC [sw: Window.Handle] RETURNS [TextSW.Options] = {    tsw: TSWContext = LocalFind[sw];    RETURN[IF tsw # NIL THEN tsw.options ELSE TextSW.defaultOptions]};  -- Scrollbar Procedures  ScrollVertical: PUBLIC ENTRY Scrollbar.ScrollProcType = {    ENABLE UNWIND => NULL;    tsw: TSWContext = LocalFind[window];    IF tsw # NIL AND tsw.scroller # NIL THEN {      p: TextDisplay.Handle = tsw.scroller;      line: CARDINAL ¬ TextDisplay.TextLines[p]*percent/100;      RealActOnCaret[tsw, clear];      SELECT direction FROM        forward => {          line ¬ MIN[line, TextDisplay.LastDisplayedLine[p]];	  IF TextDisplay.TextLines[p] > 1 THEN { -- you never could scroll forward in a one line window anyway, so this doesn't change anything! (DWR)	    p.MoveLines[line, 0];	    p.Update[              IF p.lineTable.lastPositionPlusOne = 0 THEN 0              ELSE p.lineTable.lastPositionPlusOne - 1, p.source.getLength[              p.source], @tsw.selection, FALSE];	  };	};        backward => TextDisplay.BackupNLines[p, line + 1, @tsw.selection];        ENDCASE =>          TextDisplayExtra.SetPositionWithOverRide[            p, IF percent < 5 THEN 0 ELSE TextDisplay.GetEOF[p]*percent/100,            @tsw.selection, top];  -- overRide is top for thumbing      tsw.insertion.place ¬ TextDisplay.noPlace;      IF tsw.otherSels # NIL THEN        FOR i: CARDINAL IN [0..tsw.splits.length) DO          MarkOtherSelections[tsw.splits[i], tsw.otherSels]; ENDLOOP;      InternalValidate[window]}};  VerticalScrollbar: PUBLIC ENTRY Scrollbar.ScrollbarProcType = {    ENABLE UNWIND => NULL;    tsw: TSWContext = LocalFind[window];    box ¬ [[0, 0], [0, 0]];    IF tsw # NIL THEN {      y: INTEGER = TIP.GetPlace[window].y;      p: TextDisplay.Handle = (tsw.scroller ¬ PToUse[tsw, y, FALSE]);      lastLine: CARDINAL = TextDisplay.LastDisplayedLine[p];      eof: TextSource.Position;      box ¬ [[0, p.box.place.y], p.box.dims];      eof ¬ TextDisplay.GetEOF[p];      IF eof # 0 THEN {        pos0: TextSource.Position = TextDisplay.GetPosition[p, 0];        posEnd: TextSource.Position = TextDisplay.GetPosition[p, lastLine];        BearTrap: SIGNAL = CODE;        offset ¬ Inline.LowHalf[pos0*100/eof];        portion ¬ Inline.LowHalf[(posEnd - pos0)*100/eof];        RETURN[box, offset, portion]}};    RETURN[box, 0, 0]};  -- Selection Source Procedures  ReadInsertSource: PROC [data: InsertSource, string: LONG STRING] = {    charsToRead: CARDINAL;    psa: TextDisplay.Handle = data.tsw.splits[0];    left, next, right: TextSource.Position;    gap: LONG CARDINAL;    block: Environment.Block;    string.length ¬ 0;    left ¬ data.left;    right ¬ data.right;    WHILE left < right DO      IF (charsToRead ¬ string.maxlength - string.length) = 0 THEN EXIT;      IF Inline.HighHalf[(gap ¬ right - left)] = 0 THEN        charsToRead ¬ MIN[charsToRead, Inline.LowHalf[gap]];      [block, next] ¬ psa.source.ReadText[left, charsToRead, none];      left ¬ next;      IF block.startIndex = block.stopIndexPlusOne THEN EXIT      ELSE AppendBlock[string, block];      ENDLOOP;    data.left ¬ left};  ReadSource: PROC [data: TSWSource, string: LONG STRING] = {    << Complex code because it handles case where selection is stuffed at insert     point inside original selection!  First go from left to old insert exactly.    Then adjust left by amount that insert changes between calls.  Context's     selection.right is automatically  kept correct by insertion routine, so we    just keep a pointer to it.    >>    p: TextDisplay.Handle = data.tsw.splits[0];    charsToRead: CARDINAL;    left, next, right: TextSource.Position;    gap: LONG CARDINAL;    block: Environment.Block;    string.length ¬ 0;    IF data.crossedInsert THEN {      left ¬ data.left + (data.tsw.insertion.position - data.insert);      right ¬ data.right­}    ELSE {left ¬ data.left; right ¬ MIN[data.right­, data.insert]};    WHILE left < right DO      IF (charsToRead ¬ string.maxlength - string.length) = 0 THEN EXIT;      IF Inline.HighHalf[(gap ¬ right - left)] = 0 THEN        charsToRead ¬ MIN[charsToRead, Inline.LowHalf[gap]];      [block, next] ¬ p.source.ReadText[left, charsToRead, none];      left ¬ next;      IF block.startIndex = block.stopIndexPlusOne THEN EXIT      ELSE AppendBlock[string, block];      REPEAT        FINISHED =>          IF ~data.crossedInsert THEN {            data.crossedInsert ¬ TRUE; left ¬ data.tsw.insertion.position};      ENDLOOP;    data.left ¬ left;    IF data.crossedInsert THEN data.insert ¬ data.tsw.insertion.position};  DestroySource: PROC [source: Selection.Source] = {    z.FREE[@source.data]; z.FREE[@source]};  AppendBlock: PROC [string: LONG STRING, block: Environment.Block] = {    array: LONG POINTER TO PACKED ARRAY OF CHARACTER =      LOOPHOLE[block.blockPointer];    FOR i: CARDINAL IN [block.startIndex..block.stopIndexPlusOne) DO      String.AppendChar[string, array[i]]; ENDLOOP};  END. -- of TextSWsB
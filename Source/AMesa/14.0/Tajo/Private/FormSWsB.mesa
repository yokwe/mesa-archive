-- Copyright (C) 1981, 1982, 1983  by Xerox Corporation. All rights reserved. -- File: FormSWsB.mesa - last edited:-- PXK    ,	12-Nov-82 21:07:28 -- SXW   ,	10-Jul-81 10:17:39 -- Mark, 	30-Jan-81  7:50:55 -- JGS,		24-Nov-81 11:31:09-- SEH,		14-Jul-82 16:32:47-- BGY     ,	18-Oct-83 18:33:25-- AXD    ,	 9-Nov-82 15:20:50-- Selection routines, item menus and client item utilities related to--   notify procsDIRECTORY  Caret USING [ActOn],  Context,  Cursor USING [Fetch, GetInfo, Handle, Object, Set, Store],  FormSW USING [DisplayItem, EnumeratedHandle, FreeHintsProcType, Hints,     ItemHandle, ItemObject, ItemType, NopFreeHintsProc, nullEnumeratedValue,     nullIndex, SetCurrent],  FormSWOps USING [ActivateCaret, ActOnSelection, context, ConvertSelection,     DeleteFNR, FindContext, InterpInput, ItemHandle,     ModifyInsertionState, moveCopy, PContext,     SelectionObject, TagLength],  Heap USING [FreeNode, MakeNode, systemZone],  Inline USING [LowHalf],  Menu USING [Error, Free, Handle, Instantiate, Invoke, Make, MCRType,     Uninstantiate],  Profile USING [balanceBeamChoice],  Selection USING [Set],  System USING [Pulses],  TajoOps USING [IsWindowValid],  TextData USING [Position, Selection, SelectionEntity, SelectionObject],  TextDisplay USING [ExtendPositionInterval, Handle,      MarkSelection, MoveInsertion, Object, Position,     PositionFromWindowPlace, Selection,     SelectionEntity, UpdateSelection, WindowPlaceFromPosition],  TIP USING [clickTimeout, mouseTIP, NewManager],  UserInput USING [CreatePeriodicNotify, PeriodicProcType, SetInputFocus,     StuffString],  Window USING [Box, Handle, Object, Place];      FormSWsB: MONITOR LOCKS myContext.lock USING myContext: FormSWOps.PContext  IMPORTS    Caret, Context, Cursor, FormSW, FormSWOps, Heap, Inline, Menu, Profile,    Selection, TajoOps, TextDisplay, TIP, UserInput   EXPORTS FormSW, FormSWOps =  BEGIN   -- Global Data for Mouse tracking  td: TrackDataHandle ¬ NIL;  lastTime: PUBLIC System.Pulses ¬ [0];    ModeType: TYPE    = {doSelect, doInsert, doAdjust, doMenu, tagSelect,     tagDelete, resetInsert, none};  RelTrack: TYPE  = {fromLeft, fromRight, fromCenter, none};  TrackDataHandle: TYPE = LONG POINTER TO TrackDataRec;  TrackDataRec: TYPE = RECORD [    base: TextData.SelectionObject ¬ TRASH,	-- rubber base for adjust tracking    cameFrom: RelTrack ¬ none,			-- for Adjust Tracking of text    context: FormSWOps.PContext ¬ NIL,		-- context of item selected    downIndex: CARDINAL ¬ FormSW.nullIndex,	-- index of item selected    downType: FormSW.ItemType ¬ TRASH,		-- type of item selected    freeProc: FormSW.FreeHintsProcType ¬ FormSW.NopFreeHintsProc, -- user supplied    inverted: BOOLEAN ¬ FALSE,			-- used for tracking booleans    lastEnum: CARDINAL ¬ FormSW.nullIndex,	-- used for tracking enumerated    menu: Menu.Handle ¬ NIL,			-- menu for item selected    mode: ModeType ¬ none,			-- current mouse action    oldVal: UNSPECIFIED ¬ FormSW.nullIndex,	-- for menu selection    replace: BOOLEAN ¬ TRASH,			-- ???    strings: FormSW.Hints ¬ TRASH,		-- menu filler    tagLength: CARDINAL ¬ FormSW.nullIndex,	-- length of tag selected    tagSelected: BOOLEAN ¬ FALSE];		-- TRUE if menu for item         -- FormSW PNRs and support (Selection and Menu guys)    -- These two PNRs must explicitly pass mode, so that if they were moved  --   under different mouse buttons they would still work properly.    ClearTrackData: PUBLIC PROC[myContext: FormSWOps.PContext] = {    IF myContext # td.context THEN RETURN;    td.context ¬ NIL;    td.downIndex ¬ FormSW.nullIndex;    };    InitializeGlobalState: PROC [window:Window.Handle, place:Window.Place,    thisMode: ModeType] = {    bugPos: TextDisplay.Position;    td.context ¬  FormSWOps.FindContext[window];    td.downIndex ¬ ResolveBugToItem[td.context, place];    IF td.context.dijects = NIL THEN td.downIndex¬ FormSW.nullIndex;    IF td.downIndex = FormSW.nullIndex THEN  RETURN;    td.downType ¬ td.context.items[td.downIndex].type;    td.mode ¬ thisMode;    td.inverted ¬ FALSE;    td.lastEnum  ¬ FormSW.nullIndex;    td.tagLength ¬ FormSWOps.TagLength[td.context.dijects[td.downIndex].source];    td.base ¬ td.context.selection.textSelect;    bugPos ¬       TextDisplay.PositionFromWindowPlace[      @td.context.dijects[td.downIndex], place].position;    SELECT td.mode FROM      doSelect => {	td.context.selection.textSelect.entity ¬ document;        IF bugPos < td.tagLength THEN td.mode ¬ tagSelect};      doAdjust => {        td.cameFrom ¬ none;	IF bugPos < td.tagLength THEN td.mode ¬ tagDelete	ELSE IF (td.downIndex # td.context.insertion.index) AND 	~FormSWOps.moveCopy AND Selectable[] AND 	~td.context.items[td.downIndex].flags.readOnly THEN 	  td.mode ¬ resetInsert};      ENDCASE;    };      Selectable: PROCEDURE RETURNS[BOOLEAN] = INLINE{    RETURN [      SELECT td.downType FROM        longNumber, number, string => TRUE,        ENDCASE =>  FALSE]};            -- TIP Atom Procs       DoSelect: PUBLIC PROC [    window:Window.Handle, place:Window.Place, time: System.Pulses] = {     ENABLE UNWIND => NULL;    firstTime:BOOLEAN;    firstTime ¬ (td.mode = none) OR ~((TIP.clickTimeout > time - lastTime)       AND (Selectable[]) AND (td.downIndex # FormSW.nullIndex) AND      (ResolveBugToItem[td.context, place] = td.downIndex)      AND (TextDisplay.PositionFromWindowPlace[        @td.context.dijects[td.downIndex], place].position      IN [td.context.selection.textSelect.left ..        td.context.selection.textSelect.right]));    IF firstTime THEN InitializeGlobalState[window, place, doSelect];    IF td.downIndex = FormSW.nullIndex THEN  RETURN;    TIP.NewManager[window, TIP.mouseTIP, FormSWOps.InterpInput];    StartSelect[window, place];    };      MoveInsertion: PUBLIC PROC [window:Window.Handle, place:Window.Place] = {     ENABLE UNWIND => NULL;    InitializeGlobalState[window, place, doInsert];    IF td.downIndex = FormSW.nullIndex THEN  RETURN;    TIP.NewManager[window, TIP.mouseTIP, FormSWOps.InterpInput];    StartInsert[window, place];    };      ExtendSel: PUBLIC PROC [window:Window.Handle, place:Window.Place] = {    ENABLE UNWIND => NULL;    InitializeGlobalState[window, place, doAdjust];    IF td.downIndex = FormSW.nullIndex OR td.mode = resetInsert THEN  {      td.downIndex ¬ td.context.insertion.index;      IF td.downIndex = FormSW.nullIndex THEN RETURN;      td.downType ¬ td.context.items[td.downIndex].type;      td.tagLength ¬ FormSWOps.TagLength[td.context.dijects[td.downIndex].source];      DoInsertion[td.context.insertion.textInsert.place];      RETURN};    TIP.NewManager[window, TIP.mouseTIP, FormSWOps.InterpInput];    StartSelect[window, place];    };      TrackCursor: PUBLIC PROC [window:Window.Handle, place:Window.Place] = {    IF td.downIndex = FormSW.nullIndex OR td.context = NIL       OR td.context.dijects = NIL THEN {        td.downIndex ¬ FormSW.nullIndex;	RETURN};    SELECT td.downType FROM      longNumber, number, string, tagOnly =>         IF td.mode = doInsert THEN DoInsertion[place]         ELSE DoSelection[place, TRUE];      command => InvertSelect[place];      boolean => IF ~td.context.items[td.downIndex].flags.readOnly THEN        InvertSelect[place];      enumerated => IF ~td.context.items[td.downIndex].flags.readOnly THEN         SelectEnum[place];      ENDCASE;    };        SetModified: PUBLIC PROC [    sw: Window.Handle, myContext: FormSWOps.PContext, index: CARDINAL] = {    IF ~myContext.items[index].flags.modified THEN {      myContext.items[index].flags.modified ¬ TRUE;      IF myContext.modifyNotify # NIL THEN myContext.modifyNotify[	sw, myContext.items[index], index]}};      FormSWOK: PROC [sw: Window.Handle] RETURNS[ok:BOOLEAN] ={    myContext: FormSWOps.PContext;    ok ¬ TajoOps.IsWindowValid[sw] AND       ((myContext ¬ FormSWOps.FindContext[sw]) # NIL) AND       (myContext = td.context) AND (td.downIndex # FormSW.nullIndex) AND      (myContext.dijects = td.context.dijects) AND      ~(myContext.items[td.downIndex].flags.invisible);    };      PointUp: PUBLIC PROC [    window:Window.Handle, place:Window.Place, time: System.Pulses] = {     cursor: Cursor.Object;    TIP.NewManager[NIL, NIL, NIL];    IF td.downIndex = FormSW.nullIndex THEN RETURN;    lastTime ¬ time;    WITH item: td.context.items[td.downIndex] SELECT FROM      longNumber, number, string, tagOnly => {	FinishText[window, place];	IF ~(td.mode = doSelect AND Selectable[]) THEN	  td.downIndex ¬ FormSW.nullIndex;	RETURN};      boolean  => IF td.context.items[td.downIndex].flags.readOnly THEN RETURN        ELSE {	  InvertSelect[place];	  IF ~td.inverted THEN RETURN};      command    => {        InvertSelect[place];	IF ~td.inverted THEN RETURN};      enumerated => IF td.context.items[td.downIndex].flags.readOnly THEN RETURN        ELSE {        IF td.lastEnum # FormSW.nullIndex THEN {	  SelectEnum[place];          item.value­ ¬ item.choices[td.lastEnum].value};	IF item.value­ = td.oldVal THEN RETURN};    ENDCASE => NULL;    BEGIN    ENABLE UNWIND => {      IF Cursor.GetInfo[].type = hourGlass         THEN Cursor.Store[@cursor];      WITH item: td.context.items[td.downIndex] SELECT FROM        command  => IF FormSWOK[window] THEN 	  InvertItem[td.context, td.downIndex];	ENDCASE;      };    WITH item: td.context.items[td.downIndex] SELECT FROM      boolean, command, enumerated => {        Cursor.Fetch[@cursor];        Cursor.Set[hourGlass];        WITH item: td.context.items[td.downIndex] SELECT FROM          command    => {	    item.proc[window, @item, td.downIndex];	    IF FormSWOK[window] THEN InvertItem[td.context, td.downIndex]};          boolean    => {	    item.switch­ ¬ ~item.switch­;	    SetModified[window, td.context, td.downIndex];	    item.proc[window, @item, td.downIndex]};          enumerated => {	    SetModified[window, td.context, td.downIndex];	    item.proc[window, @item, td.downIndex, td.oldVal]	    };          ENDCASE => NULL;        IF Cursor.GetInfo[].type = hourGlass THEN Cursor.Store[@cursor]};    ENDCASE => NULL;    END;    IF ~(td.mode = doSelect AND Selectable[]) THEN       td.downIndex ¬ FormSW.nullIndex;    };      AdjustUp: PUBLIC PROC [    window:Window.Handle, place:Window.Place, time: System.Pulses] = {    PointUp[window,place, time];    };    MenuUp: PUBLIC PROC [window:Window.Handle, place:Window.Place] = {    };    StartSelect: PROC [window:Window.Handle, place:Window.Place] = {   item: FormSW.ItemHandle ¬ td.context.items[td.downIndex];    WITH item: td.context.items[td.downIndex] SELECT FROM      longNumber, number, string, tagOnly => {        Selection.Set[	  td.context, FormSWOps.ConvertSelection, FormSWOps.ActOnSelection];	td.context.selection.index ¬ td.downIndex;	DoSelection[place];	};      command => InvertSelect[place];      boolean => IF td.context.items[td.downIndex].flags.readOnly THEN 	  td.context.readOnlyNotifyProc[window, 	  td.context.items[td.downIndex], td.downIndex]        ELSE InvertSelect[place];      enumerated => IF item.feedback # all THEN GOTO quit       ELSE         IF td.context.items[td.downIndex].flags.readOnly THEN           	  td.context.readOnlyNotifyProc[window, 	  td.context.items[td.downIndex], td.downIndex]        ELSE {          bugPos: TextDisplay.Position ¬ 	    TextDisplay.PositionFromWindowPlace[	    @td.context.dijects[td.downIndex], place].position;	  old: CARDINAL ¬ IndexFromEnumeratedValue[@item];	  new: CARDINAL ¬ ResolveEnumeratedItem[td.context, td.downIndex, bugPos];	  IF new = FormSW.nullIndex THEN GOTO quit;	  td.oldVal ¬ item.value­;	  MarkEnumeratedItem[td.context, td.downIndex, old, new];	  td.lastEnum ¬ new; 	  };         ENDCASE;      EXITS quit => td.downIndex ¬ FormSW.nullIndex;      };	      DoSelection: PROC [place: Window.Place, track: BOOLEAN ¬ FALSE] = {    --  Updates selection object passed in, also paints inverted selection    diject: TextDisplay.Handle ¬ @td.context.dijects[td.downIndex];    new: TextDisplay.Selection ¬ @td.context.selection.textSelect;    oldSel: TextData.SelectionObject ¬ new­;    old: TextDisplay.Selection ¬ @ oldSel;    position: TextDisplay.Position ¬       TextDisplay.PositionFromWindowPlace[diject, place].position;    SELECT td.mode FROM      doSelect, tagSelect => {        IF ~track THEN new.entity ¬ BumpEntity [old.entity];	[new.left, new.right] ¬ TextDisplay.ExtendPositionInterval[	  diject, position, position + 1, new.entity];	};      doAdjust, tagDelete => {        [new.left, new.right] ¬ NewInterval[td.base.left, td.base.right,	  position];	IF new.entity # text THEN 	  [new.left, new.right] ¬ TextDisplay.ExtendPositionInterval[	    diject, new.left, new.right, new.entity]};    ENDCASE;    TextDisplay.UpdateSelection[diject, old, new];    };          DoInsertion: PROC [place: Window.Place] = {    --  Updates insertion object passed in    SELECT td.downType FROM      longNumber, number, string, tagOnly =>        IF ~td.context.items[td.downIndex].flags.readOnly THEN {   	  Caret.ActOn[reset];          td.context.insertion.index ¬ td.downIndex;	  TextDisplay.MoveInsertion[            @td.context.dijects[td.downIndex], place, 	    @td.context.insertion.textInsert, td.tagLength];          TakeInputFocus[td.context]	  };      ENDCASE;    };      NewInterval: PROC [    left, right, new: TextDisplay.Position] RETURNS[    l,r: TextDisplay.Position] ={    SELECT TRUE FROM       new < left  => {l ¬ new;  r ¬ right; td.cameFrom ¬ fromLeft};      new > right => {l ¬ left; r ¬ new + 1; td.cameFrom ¬ fromRight};      ENDCASE     => {        IF td.cameFrom = none THEN {	  td.cameFrom ¬ IF new - left < right - new THEN fromLeft ELSE fromRight;	  IF new = left OR new = right - 1 THEN 	    td.context.selection.textSelect.entity ¬ text};	SELECT td.cameFrom FROM	  fromLeft => {l ¬ new; r ¬ right};          fromRight => {l ¬ left; r ¬ new + 1};          ENDCASE;	};    right ¬ MAX [left,right];    };          BumpEntity: PROC[    old:TextDisplay.SelectionEntity] RETURNS[new: TextDisplay.SelectionEntity] ={    -- increment entity    new ¬       SELECT old FROM        text => word,        word => line,        line => document,        document => text,      ENDCASE => text;     };      StartInsert: PROC [window:Window.Handle, place:Window.Place] = {    -- put insertion in correct place    SELECT td.downType FROM      longNumber, number, string, tagOnly =>        IF td.context.items[td.downIndex].flags.readOnly THEN          td.context.readOnlyNotifyProc[window, 	  td.context.items[td.downIndex], td.downIndex]        ELSE DoInsertion[place];      ENDCASE;    };            MagicTag: PROC [window: Window.Handle] = {    -- Mouse up over tag    WITH item: td.context.items[td.downIndex] SELECT FROM      tagOnly =>        IF item.otherItem # FormSW.nullIndex THEN 	  td.downIndex ¬ item.otherItem;      ENDCASE;    SELECT td.mode FROM      tagSelect => FormSW.SetCurrent[window, td.downIndex];      tagDelete => {        FormSW.SetCurrent[window, td.downIndex];        FormSWOps.DeleteFNR[window]};      doSelect, doAdjust => {        new: TextDisplay.Selection ¬ @td.context.selection.textSelect;        oldSel: TextData.SelectionObject ¬ new­;        old: TextDisplay.Selection ¬ @ oldSel;	new.left ¬ td.tagLength;	TextDisplay.UpdateSelection[@td.context.dijects[td.downIndex], old, new]};      ENDCASE;    };      FinishText: PROC [window: Window.Handle, place: Window.Place] = {    sts: TextDisplay.Selection ¬ @td.context.selection.textSelect;    diject: TextDisplay.Handle ¬ @td.context.dijects[td.downIndex];    position: TextDisplay.Position ¬       TextDisplay.PositionFromWindowPlace[diject, place].position;    IF td.mode = doInsert THEN FormSWOps.ActivateCaret[window, start]    ELSE {      td.base ¬ td.context.selection.textSelect;      IF ~td.context.items[td.downIndex].flags.readOnly AND         ~FormSWOps.moveCopy  THEN {        SELECT TRUE FROM          Profile.balanceBeamChoice = never => position ¬ sts.right;          Profile.balanceBeamChoice =  notForCharacter AND            (sts.right - sts.left = 1) => position ¬ sts.right;          ENDCASE => {            position ¬ TextDisplay.PositionFromWindowPlace[              diject, place, TRUE].position;            position ¬              IF (position - sts.left) < (sts.right - position) THEN sts.left               ELSE sts.right};        DoInsertion[TextDisplay.WindowPlaceFromPosition[	  diject, position, FALSE, TRUE]]};      IF td.context.selection.textSelect.left < td.tagLength THEN         MagicTag[window];      };    FormSWOps.ModifyInsertionState[td.context, change,       td.context.insertion.textInsert.position];    };    InvertSelect: PROC[place: Window.Place] = {    -- tracking of booleans and command    db: Window.Box ¬ td.context.dijects[td.downIndex].box;    margin: INTEGER ¬ td.context.dijects[td.downIndex].options.margin;    inBox: BOOLEAN ¬ (place.x - db.place.x IN [margin..db.dims.w - margin])             AND (place.y - db.place.y IN [margin..db.dims.h - margin]);           SELECT TRUE FROM      inBox AND ~td.inverted => InvertItem[td.context, td.downIndex];      ~inBox AND td.inverted => InvertItem[td.context, td.downIndex];       ENDCASE;    };      SelectEnum: PROC[place: Window.Place] = {     db: Window.Box ¬ td.context.dijects[td.downIndex].box;    margin: INTEGER = td.context.dijects[td.downIndex].options.margin;    diject: TextDisplay.Handle ¬ @td.context.dijects[td.downIndex];    position: TextDisplay.Position ¬ TextDisplay.PositionFromWindowPlace[      diject, place, TRUE].position;    inBox: BOOLEAN =           (place.x - db.place.x IN [margin..db.dims.w - margin])           AND (place.y - db.place.y IN [margin..db.dims.h - margin]);         newEnum: CARDINAL ¬      IF inBox THEN ResolveEnumeratedItem[td.context, td.downIndex, position]      ELSE td.lastEnum;    IF newEnum = FormSW.nullIndex THEN newEnum ¬ td.lastEnum;    MarkEnumeratedItem[td.context, td.downIndex, td.lastEnum, newEnum];    td.lastEnum ¬ newEnum;    };	          TakeInputFocus: PROCEDURE [myContext: FormSWOps.PContext] = {    UserInput.SetInputFocus[myContext.sw, LoseInputFocus, TRUE];    Cursor.Set[textPointer]};      LoseInputFocus: PROCEDURE [sw: Window.Handle, nil: LONG POINTER] = {    Cursor.Set[groundedText]};    -- Menu Support routines      MenuDown: PUBLIC PROC [window:Window.Handle, place: Window.Place] = {    ENABLE UNWIND => NULL;    InitializeGlobalState[window, place, doMenu];    td.tagSelected ¬ FALSE;    IF td.downIndex = FormSW.nullIndex THEN {      td.tagSelected ¬ FALSE;      Caret.ActOn[stop];  -- So cursor bits cannot get saved      Menu.Invoke[window, place];      Caret.ActOn[start];      td.context ¬ NIL;      [] ¬ UserInput.CreatePeriodicNotify[CloseMenu, window, 0];      }    ELSE {      diject: TextDisplay.Handle = @td.context.dijects[td.downIndex];      bugPlace: CARDINAL = Inline.LowHalf[        TextDisplay.PositionFromWindowPlace[diject, place].position];      td.tagSelected ¬ (bugPlace < td.tagLength);      IF td.tagSelected THEN MakeMenuForItem[window];      Caret.ActOn[stop];  -- So cursor bits cannot get saved      Menu.Invoke[window, place];      Caret.ActOn[start];      [] ¬ UserInput.CreatePeriodicNotify[CloseMenu, window, 0];      };    };              CloseMenu: UserInput.PeriodicProcType = {  -- kamikaze notify proc    BEGIN    IF NOT TajoOps.IsWindowValid[window] THEN GOTO MenuQuit;    IF td.menu # NIL THEN      BEGIN      Menu.Uninstantiate[td.menu, window ! Menu.Error => GOTO MenuQuit];      Menu.Free[td.menu, FALSE! Menu.Error => GOTO MenuQuit];      END;    IF td.tagSelected THEN {      free: FormSW.FreeHintsProcType = td.freeProc;      td.freeProc ¬ NIL;      IF free # NIL THEN free[td.strings]};    EXITS MenuQuit => NULL;    END;    td.menu ¬ NIL;    td.downIndex ¬ FormSW.nullIndex;    };      MakeMenuForItem: PROCEDURE [window:Window.Handle]  = {     IF td.downIndex = FormSW.nullIndex THEN RETURN;    WITH item: td.context.items[td.downIndex] SELECT FROM      boolean => NULL;      command => NULL;      tagOnly =>        IF item.otherItem # FormSW.nullIndex THEN          WITH other: td.context.items[item.otherItem] SELECT FROM            string => {              [td.strings, td.freeProc, td.replace] ¬	        other.menuProc[window, td.downIndex];              IF BASE[td.strings] # NIL THEN                td.menu ¬ Menu.Make[item.tag, td.strings, MenuMCR, FALSE];              };            ENDCASE;      string => {        [td.strings, td.freeProc, td.replace] ¬ 	  item.menuProc[window, td.downIndex];        IF BASE[td.strings] # NIL THEN          td.menu ¬ Menu.Make[item.tag, td.strings, MenuMCR, FALSE];          };      enumerated =>        IF BASE[item.choices] # NIL THEN {          numChoices: CARDINAL = LENGTH[item.choices];          i: CARDINAL;          td.strings ¬ DESCRIPTOR[            Heap.MakeNode[td.context.zone,             SIZE[LONG STRING]*numChoices], numChoices];          FOR i IN [0..numChoices) DO            td.strings[i] ¬ item.choices[i].string; ENDLOOP;          td.menu ¬ Menu.Make[item.tag, td.strings, MenuMCR, FALSE];          Heap.FreeNode[td.context.zone, BASE[td.strings]];           };      ENDCASE;    IF td.menu # NIL THEN Menu.Instantiate[td.menu, window];    };	    MenuMCR: Menu.MCRType = {	      IF td.context = NIL THEN RETURN;    IF td.context.items[td.downIndex].flags.readOnly THEN {      td.context.readOnlyNotifyProc[        window, td.context.items[td.downIndex], td.downIndex];      RETURN};    WITH variant: td.context.items[td.downIndex] SELECT FROM      enumerated =>{        IF IndexFromEnumeratedValue[@variant] # index THEN {          oldValue: UNSPECIFIED = variant.value­;          variant.value­ ¬ variant.choices[index].value;          FormSW.DisplayItem[window, td.downIndex];          variant.proc[window, @variant, td.downIndex, oldValue];          SetModified[window, td.context, td.downIndex];          };        };      string, tagOnly => {        s: LONG STRING ¬ menu.items[index].keyword;        IF s = NIL THEN RETURN;        FormSW.SetCurrent[window, td.downIndex];        IF td.replace THEN FormSWOps.DeleteFNR[window];        [] ¬ UserInput.StuffString[window, s];        SetModified[window, td.context, td.downIndex];        };      ENDCASE;    };                    -- Marking and Resolution    DijectSelection: PUBLIC PROCEDURE [    myContext: FormSWOps.PContext, index: CARDINAL, select: TextData.Selection]    RETURNS [TextData.Selection] =    BEGIN    IF myContext = NIL OR index = FormSW.nullIndex THEN RETURN[NIL];    WITH item: myContext.items[index] SELECT FROM      boolean =>        IF item.switch­ THEN          BEGIN OPEN mdi: myContext.dijects[index];          select­ ¬ [0, mdi.source.getLength[mdi.source], text, video, TRUE];          RETURN[select];          END        ELSE RETURN[NIL];      enumerated =>        IF item.feedback = one THEN RETURN[NIL]        ELSE          BEGIN OPEN mdi: myContext.dijects[index];          current: CARDINAL = IndexFromEnumeratedValue[@item];          i, tagLength: CARDINAL;          IF current = FormSW.nullIndex THEN RETURN[NIL];          tagLength ¬ FormSWOps.TagLength[mdi.source];          select­ ¬ [tagLength, tagLength, text, video, TRUE];          FOR i IN [0..LENGTH[item.choices]) DO            select.right ¬ select.right + item.choices[i].string.length;            IF i = current THEN EXIT;            select.left ¬ select.right ¬ select.right + 2;            ENDLOOP;          RETURN[select];          END;      longNumber, number, string =>        BEGIN OPEN s: myContext.selection;        RETURN[IF s.index = index THEN @s.textSelect ELSE NIL];        END;      ENDCASE => RETURN[NIL];    END;	  InvertItem: PUBLIC PROCEDURE [myContext: FormSWOps.PContext, index: CARDINAL] =    BEGIN    IF myContext # NIL AND index # FormSW.nullIndex THEN      BEGIN OPEN mdi: myContext.dijects[index];      dummySelect: TextData.SelectionObject ¬ [        0, mdi.source.getLength[mdi.source], text, video, FALSE];      TextDisplay.MarkSelection[@mdi, @dummySelect, mark];      td.inverted ¬ ~td.inverted;      END;    END;        MarkEnumeratedItem: PUBLIC PROCEDURE [    myContext: FormSWOps.PContext, index: CARDINAL, old, new: CARDINAL] =    BEGIN     i: CARDINAL;    IF old = new OR index = FormSW.nullIndex THEN RETURN;    WITH item: myContext.items[index] SELECT FROM      enumerated =>        BEGIN OPEN mdi: myContext.dijects[index];        tagLength: CARDINAL;        dummySelect: TextData.SelectionObject;        IF item.feedback = one THEN RETURN;        tagLength ¬ FormSWOps.TagLength[mdi.source];        dummySelect ¬ [tagLength, tagLength, text, video, FALSE];        FOR i IN [0..LENGTH[item.choices]) DO          dummySelect.right ¬ dummySelect.right + item.choices[i].string.length;          IF i = old OR i = new THEN            BEGIN            dummySelect.marked ¬ FALSE;            TextDisplay.MarkSelection[@mdi, @dummySelect, mark];            END;          dummySelect.left ¬ dummySelect.right ¬ dummySelect.right + 2;          ENDLOOP;        END;      ENDCASE;    END;	  ResolveBugToItem: PRIVATE PROCEDURE [    myContext: FormSWOps.PContext, place: Window.Place] RETURNS [CARDINAL] =    BEGIN     i: CARDINAL;    FOR i IN [0..LENGTH[myContext.items]) DO      IF myContext.items[i].flags.invisible THEN LOOP;      IF IsPlaceInBox[place, myContext.dijects[i].box] THEN RETURN[i];      ENDLOOP;    RETURN[FormSW.nullIndex];    END;        ResolveEnumeratedItem: PRIVATE PROCEDURE [    myContext: FormSWOps.PContext, index: CARDINAL, bugPos: TextDisplay.Position]    RETURNS [resolvedIndex: CARDINAL] =    -- this guy should only be called for type = "all"    BEGIN     i: CARDINAL;    IF index = FormSW.nullIndex THEN RETURN[FormSW.nullIndex];        WITH item: myContext.items[index] SELECT FROM      enumerated =>        BEGIN OPEN mdi: myContext.dijects[index];        currentPos: TextDisplay.Position;        IF item.feedback = one THEN RETURN[FormSW.nullIndex];        currentPos ¬ FormSWOps.TagLength[mdi.source];        IF bugPos < currentPos THEN RETURN[FormSW.nullIndex]        ELSE currentPos ¬ currentPos - 1;  -- left gets ","        FOR i IN [0..LENGTH[item.choices]) DO          currentPos ¬ currentPos + item.choices[i].string.length + 2;  	  -- but right gets " "          IF bugPos < currentPos THEN RETURN[i];          ENDLOOP;        RETURN[FormSW.nullIndex];        END;      ENDCASE;    END;	  -- Utilities      IsPlaceInBox: PRIVATE PROCEDURE [place: Window.Place, box: Window.Box]    RETURNS [BOOLEAN] =    BEGIN    RETURN[      (place.x >= box.place.x AND place.y >= box.place.y        AND place.x <= box.place.x + box.dims.w        AND place.y <= box.place.y + box.dims.h)]    END;	  -- Locating Interface PROCEDUREs    ContextFromItem: PUBLIC PROCEDURE [item: FormSW.ItemHandle]    RETURNS [LONG POINTER] =    BEGIN     RETURN[      IF item.flags.hasContext THEN      WITH variant: item SELECT FROM        boolean => item + SIZE[boolean FormSW.ItemObject],        command => item + SIZE[command FormSW.ItemObject],        enumerated => item + SIZE[enumerated FormSW.ItemObject],        longNumber => item + SIZE[longNumber FormSW.ItemObject],        number => item + SIZE[number FormSW.ItemObject],        string => item + SIZE[string FormSW.ItemObject],        tagOnly => item + SIZE[tagOnly FormSW.ItemObject],        ENDCASE => ERROR ELSE NIL];    END;	  IndexFromEnumeratedValue: PUBLIC PROCEDURE [eItem: FormSW.EnumeratedHandle]    RETURNS [CARDINAL] =    BEGIN    i: CARDINAL;    IF eItem.value­ # FormSW.nullEnumeratedValue THEN      FOR i IN [0..LENGTH[eItem.choices]) DO        IF eItem.choices[i].value = eItem.value­ THEN RETURN[i]; ENDLOOP;    RETURN[FormSW.nullIndex];    END;      FindItem: PUBLIC PROCEDURE [sw: Window.Handle, index: CARDINAL]    RETURNS [item: FormSW.ItemHandle] =    BEGIN    myContext: FormSWOps.PContext = FormSWOps.FindContext[sw];    RETURN[      IF myContext = NIL OR ~(index IN [0..LENGTH[myContext.items])) THEN NIL      ELSE myContext.items[index]];    END;        ResolvePlaceToItem: PUBLIC PROCEDURE [sw: Window.Handle, place: Window.Place]    RETURNS [CARDINAL] =    BEGIN    myContext: FormSWOps.PContext = FormSWOps.FindContext[sw];    RETURN[      IF myContext = NIL THEN FormSW.nullIndex      ELSE ResolveBugToItem[myContext, place]];    END;        Init: PROC = {    IF td = NIL THEN td ¬ Heap.systemZone.NEW[TrackDataRec ¬ []];    };      Init[];    END.  -- of FormSWsB.mesa                            
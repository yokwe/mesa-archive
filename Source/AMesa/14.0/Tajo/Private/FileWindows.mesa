-- File: FileWindows.mesa - last edit:-- Riggle.PA           16-Sep-86 15:16:27-- SXW   	 9-Jul-81 18:52:41-- JGS		20-Aug-81 16:48:57-- Mark		28-May-81 19:51:28-- PXK    	27-Dec-82 17:27:08-- LXR    	11-Dec-81 23:35:32-- SXS   	19-Jul-82 16:46:55-- BXM   	19-Nov-81 12:20:00-- BGY      	25-Oct-82 16:12:47-- AXD    	30-Jan-84 19:08:13-- CXH   	19-Jan-83 14:51:54-- DWR    	 2-Aug-85 12:48:27-- Copyright (C) 1986 by Xerox Corporation. All rights reserved.DIRECTORY  Atom: TYPE USING [ATOM, MakeAtom],  CmFile: TYPE USING [FreeString, UserDotCmLine],  Context: TYPE USING [Create, Destroy, Find, Type, UniqueType],  Cursor: TYPE USING [GetInfo, Info, Set],  Event: TYPE USING [fileWindow],  EventTypes: TYPE USING [createWindow, destroy, edit, load, reset, store],  FileWindow: TYPE USING [EnumerateProcType],  FileWindowOps: TYPE USING [],  FileSW: TYPE USING [    Create, Destroy, GetFile, IsEditable, IsIt, MakeEditable, PutEditableFile,    ResetEditableFile, SetFile],  Heap: TYPE USING [MakeNode, systemZone],  Menu: TYPE USING [    Create, Error, Instantiate, Handle, ItemObject, Items, MCRType,    Uninstantiate],  MFile: TYPE USING [    Access, Acquire, AddNotifyProc, CopyFileHandle, dontRelease, Error,    GetFullName, GetType, Handle, maxNameLength, NotifyProc, ReadWrite, Release,    ReleaseChoice, SetAccess, ValidFilename],  MStream: TYPE USING [    Create, Error, GetFile, Handle, PleaseReleaseProc, ReadWrite, SetLength, SetReleaseData],  PieceSource: TYPE USING [Info, IsIt, Put],  Process: TYPE USING [Detach],  Selection: TYPE USING [Convert],  SpecialUserInput: TYPE USING [backStopInputFocus],  Stream: TYPE USING [    Delete, EndOfStream, GetByte, PutBlock, PutByte, PutString, SendNow, SetPosition],  String: TYPE USING [AppendChar, AppendString,     AppendStringAndGrow, AppendSubString, CopyToNewString, EmptyString,    Equivalent, EquivalentString, FreeString, StringBoundsFault, SubStringDescriptor],  ScratchSW: TYPE USING [Create, Destroy, Info, IsIt],  Supervisor: TYPE USING [    AddDependency, AgentProcedure, CreateSubsystem, NotifyDirectSubsystems,    SubsystemHandle],  TextSource: TYPE USING [Error, Handle, Position],  TextSW: TYPE USING [    DeleteText, GetEOF, GetOptions, GetSelection, GetSource, Options,    PositionToLine, ReplaceText, SetOptions, SetPosition, SetSelection],  TextSWExtra: TYPE USING [BecomeInputFocus],  Time: TYPE USING [AppendCurrent],  TIP: TYPE USING [CreateClient, First, GetNotifyProc, globalTable, NotifyProc],  Tool: TYPE USING [AddThisSW, Create, Destroy, MakeSWsProc],  ToolWindow: TYPE USING [    AdjustProcType, CreateSubwindow, GetAdjustProc, GetName, GetState,     SetBox, SetName, SetTinyName, State,    TransitionProcType, Type, WindowForSubwindow],  UserInput: TYPE USING [WaitForConfirmation, WaitNoButtons],  UserTerminal: TYPE USING [BlinkDisplay],  Window: TYPE USING [Box, GetBox, GetParent, Handle, InvalidateBox,     rootWindow, ValidateTree];FileWindows: MONITOR  IMPORTS    Atom, CmFile, Context, Cursor, Event, FileSW, Heap, Menu, MFile, MStream, PieceSource,    Process, ScratchSW, Selection, SpecialUserInput, Stream, String, Supervisor,    TextSource, TextSW, TextSWExtra, Time, TIP, Tool, ToolWindow, UserInput,    UserTerminal, Window  EXPORTS FileWindow, FileWindowOps =  BEGIN  -- Data and Definitions  z: UNCOUNTED ZONE = Heap.systemZone;  cv: CONDITION;  oldInterpreter: TIP.NotifyProc ¬ NIL;  doit: Atom.ATOM;    MenuItems: TYPE = {    create, destroy, edit, reset, empty, load, store, time, save};  scratchItems: PACKED ARRAY MenuItems OF BOOLEAN = [    create: TRUE, destroy: TRUE, edit: FALSE, empty: TRUE, reset: FALSE,    load: TRUE, store: TRUE, time: TRUE, save: FALSE];  editItems: PACKED ARRAY MenuItems OF BOOLEAN = [    create: TRUE, destroy: FALSE, edit: FALSE, empty: TRUE, reset: TRUE,    load: FALSE, store: TRUE, time: TRUE, save: TRUE];  readItems: PACKED ARRAY MenuItems OF BOOLEAN = [    create: TRUE, destroy: TRUE, edit: TRUE, empty: TRUE, reset: FALSE,    load: TRUE, store: TRUE, time: FALSE, save: FALSE]; «  scratchItems: PACKED ARRAY MenuItems OF BOOLEAN = [    create: TRUE, destroy: TRUE, edit: FALSE, empty: FALSE, reset: TRUE,    load: TRUE, store: TRUE, time: TRUE, save: FALSE];  editItems: PACKED ARRAY MenuItems OF BOOLEAN = [    create: TRUE, destroy: FALSE, edit: FALSE, empty: FALSE, reset: TRUE,    load: FALSE, store: TRUE, time: TRUE, save: TRUE];  readItems: PACKED ARRAY MenuItems OF BOOLEAN = [    create: TRUE, destroy: TRUE, edit: TRUE, empty: TRUE, reset: FALSE,    load: TRUE, store: TRUE, time: FALSE, save: FALSE]; »  fileWindowMenuItems: ARRAY MenuItems OF Menu.ItemObject = [    create: ["Create", CreateMCR],    destroy: ["Destroy", DestroyMCR],    edit: ["Edit", EditMCR],    reset: ["Reset", ResetMCR],    empty: ["Empty", EmptyMCR],    load: ["Load", LoadMCR],    store: ["Store", StoreMCR],    time: ["Time", TimeMCR],    save: ["Save", SaveMCR]];      scratchMenu: Menu.Handle = MakeMenu[scratchItems];  readMenu: Menu.Handle = MakeMenu[readItems];  editMenu: Menu.Handle = MakeMenu[editItems];    sourceMenu: Menu.Handle ¬ NIL;--  defaultExtension: LONG STRING;  defaultOptions: TextSW.Options = [    access: read, menu: TRUE, split: TRUE, wrap: FALSE, scrollbar: TRUE,    flushTop: FALSE, flushBottom: FALSE];  agent: Supervisor.SubsystemHandle = Supervisor.CreateSubsystem[agent: Notify];  startBox: Window.Box = Window.Box[place: [x: 32, y: 0], dims: [w: 480, h: 256]];  FWHandle: TYPE = LONG POINTER TO FWObject;  FWObject: TYPE = RECORD [link: FWHandle, sw: Window.Handle];  fileWindows: FWHandle ¬ NIL;  minimumCount: CARDINAL ¬ 0;  windows: CARDINAL ¬ 0;  aFewChars: TextSource.Position = 80;  --don't overwrite ScratchSW longer than this  -- Contexts    context: Context.Type = Context.UniqueType[];  FWContext: TYPE = LONG POINTER TO FileWindowObject;  FileWindowObject: TYPE = RECORD [    sw: Window.Handle ¬ NIL, state: State ¬ quiescent];  State: TYPE = {    makingEditable, resetting, loading, storing, quiescent, editing,    editOrQuiesce};  DestroyContext: PROC [p: LONG POINTER, window: Window.Handle] = {z.FREE[@p]};  MySw: PROC [window: Window.Handle] RETURNS [Window.Handle] = {    fw: FWContext = Context.Find[context, window];    RETURN[IF fw = NIL THEN NIL ELSE fw.sw]};  -- Basic Routines   Create: PUBLIC PROC [    box: Window.Box, options: TextSW.Options ¬ defaultOptions,    initialState: ToolWindow.State ¬ active]    RETURNS [sw: Window.Handle] = {    sw ¬ Tool.Create[      name: NIL, makeSWsProc: MakeSWs, initialBox: box,      clientTransition: ClientTransition, movableBoundaries: TRUE,      initialState: SELECT initialState FROM        active => active, tiny => tiny, inactive => inactive,        ENDCASE => --EXHAUSTED-- ERROR];    sw ¬ MySw[sw];    IF initialState = active THEN TextSWExtra.BecomeInputFocus[sw]};  MakeSWs: ENTRY Tool.MakeSWsProc = {    ENABLE UNWIND => NULL;    item: FWHandle;    sw: Window.Handle ¬ ToolWindow.CreateSubwindow[parent: window];    EmptyScratchSW[window, sw];    item ¬ z.NEW[FWObject ¬ [link: fileWindows, sw: sw]];    fileWindows ¬ item;    windows ¬ windows + 1;    Context.Create[      type: context, data: z.NEW[FileWindowObject ¬ [sw: sw]],      proc: DestroyContext, window: window];    Tool.AddThisSW[window: window, sw: sw];    Supervisor.NotifyDirectSubsystems[      event: [EventTypes.createWindow], eventData: sw, which: clients,      subsystem: Event.fileWindow]};  IsIt: PUBLIC PROC [sw: Window.Handle] RETURNS [BOOLEAN] = {    RETURN[MySw[HisToolWindow[sw]] # NIL]};  ClientTransition: ToolWindow.TransitionProcType = {    null: PROC [Window.Handle] = {};    SELECT TRUE FROM      new = inactive => {        sw: Window.Handle = MySw[window];        IF sw # NIL THEN {          [] ¬ TestAndSet[sw, resetting, editOrQuiesce]; -- no blink 'cause of DestroyMCR          ToolWindow.SetTinyName[window, "Empty"L, "Window"L];          RemoveSw[sw, null]};        Context.Destroy[context, window]};      ENDCASE};  Destroy: PUBLIC PROC [sw: Window.Handle] = {    Tool.Destroy[HisToolWindow[sw]]};  -- ClientTransition will call RemoveSw  RemoveSw: ENTRY PROC [sw: Window.Handle, proc: PROC [Window.Handle]] = {    ENABLE UNWIND => NULL;    next, item, prev: FWHandle;    prev ¬ NIL;    FOR item ¬ fileWindows, next UNTIL item = NIL DO      next ¬ item.link;      IF item.sw = sw THEN {        IF prev = NIL THEN fileWindows ¬ next ELSE prev.link ¬ next;        z.FREE[@item];        windows ¬ windows - 1;        Supervisor.NotifyDirectSubsystems[          event: [EventTypes.destroy], eventData: sw, which: clients,          subsystem: Event.fileWindow];        proc[sw]}      ELSE prev ¬ item;      ENDLOOP};  MakeMenu: PROC [items: PACKED ARRAY MenuItems OF BOOLEAN]    RETURNS [Menu.Handle] = {    count: CARDINAL ¬ 0;    menuItems: Menu.Items;    FOR i: MenuItems IN MenuItems DO IF items[i] THEN count ¬ count + 1 ENDLOOP;    menuItems ¬ DESCRIPTOR[Heap.MakeNode[z, count*SIZE[Menu.ItemObject]], count];    count ¬ 0;    FOR i: MenuItems IN MenuItems DO      IF items[i] THEN {        menuItems[count] ¬ fileWindowMenuItems[i];        count ¬ count + 1};      ENDLOOP;    RETURN[Menu.Create[menuItems, "File Window"L, TRUE]]};  Enumerate: PUBLIC ENTRY PROC [proc: FileWindow.EnumerateProcType] = {    ENABLE UNWIND => NULL;    FOR item: FWHandle ¬ fileWindows, item.link UNTIL item = NIL DO      IF proc[item.sw] = stop THEN EXIT; ENDLOOP};  FileInWindow: PUBLIC PROC [sw: Window.Handle]    RETURNS [fileName: LONG STRING, s: MStream.Handle] = {    sw ¬ IF sw = NIL THEN FindWindowToUse[] ELSE MySw[HisToolWindow[sw]];    [fileName, s] ¬ (IF sw # NIL THEN FileSW.GetFile[sw] ELSE [NIL, NIL])};  LoadWindow: PUBLIC PROC [    fileName: LONG STRING, position: TextSource.Position ¬ 0,    s: MStream.Handle ¬ NIL, loadIfSame: BOOLEAN ¬ FALSE,    sw: Window.Handle ¬ NIL] = {ENABLE UNWIND => Unlock[sw];    sw ¬ WindowToUse[sw];    IF ~TestAndSet[sw, loading].ok THEN {UserTerminal.BlinkDisplay[]; RETURN};    IF ~LoadWindowInternal[fileName, position, s, loadIfSame, sw] THEN      UserTerminal.BlinkDisplay[];    Unlock[sw]};  LoadWindowInternal: PROC [    fileName: LONG STRING, position: TextSource.Position ¬ 0,    s: MStream.Handle ¬ NIL, loadIfSame: BOOLEAN ¬ FALSE, sw: Window.Handle ¬ NIL]    RETURNS [didIt: BOOLEAN ¬ TRUE] = {    currentName: LONG STRING;    sw ¬ WindowToUse[sw];    IF sw = NIL THEN RETURN[FALSE];    currentName ¬ FileSW.GetFile[sw].name;    Notify[[EventTypes.load], sw, NIL];    IF currentName = NIL OR ~NameMatch[currentName, fileName] OR loadIfSame THEN {      fullName: STRING ¬ [MFile.maxNameLength];      was: BOOLEAN = FileSW.IsIt[sw];      IF was AND FileSW.IsEditable[sw] THEN {        IF s # NIL THEN s.Delete; RETURN[FALSE]};      IF s = NIL THEN {        s ¬ NewStream[          fileName, readOnly, sw ! MFile.Error, MStream.Error => CONTINUE];        IF s = NIL THEN TextSource.Error[fileNameError]}      ELSE MStream.SetReleaseData[s, [PleaseReleaseStream, sw]];      MFile.GetFullName[file: MStream.GetFile[s], name: fullName];      IF was THEN FileSW.SetFile[sw, fullName, s, position]      ELSE {        options: TextSW.Options = TextSW.GetOptions[sw];        ScratchSW.Destroy[sw];        FileSW.Create[sw, fullName, UseFlushWrap[options], s, position];        FixupMenus[sw, FALSE]};      SetWindowName[sw, fullName];      -- attempt to fix scrollbar prob BY      HisToolWindow[sw].ValidateTree[];      Supervisor.NotifyDirectSubsystems[        event: [EventTypes.load], eventData: sw, which: clients,        subsystem: Event.fileWindow]}    ELSE {IF s # NIL THEN s.Delete; TextSW.SetPosition[sw, position]}};  CallToolAdjust: PROC [sw: Window.Handle] = {    -- Call Adjust Proc on a Subwindow's tool window.    toolWindow: Window.Handle = HisToolWindow[sw];    adjust: ToolWindow.AdjustProcType = ToolWindow.GetAdjustProc[toolWindow];    box: Window.Box = toolWindow.GetBox; -- ??    adjust[toolWindow, box, before];    adjust[toolWindow, box, after];    toolWindow.ValidateTree};      Position: PUBLIC PROC [sw: Window.Handle, position: LONG CARDINAL] = {    sw ¬ WindowToUse[sw];    IF sw # NIL THEN TextSW.PositionToLine[sw, position]};  SetSize: PUBLIC PROC [sw: Window.Handle, box: Window.Box] = {    sw ¬ WindowToUse[sw];    IF sw # NIL THEN ToolWindow.SetBox[HisToolWindow[sw], box]};  WindowForFile: PUBLIC PROC [fileName: LONG STRING]    RETURNS [w: Window.Handle ¬ NIL] = {    enum: FileWindow.EnumerateProcType = {      IF NameMatch[FileSW.GetFile[sw].name, fileName] AND ~FileSW.IsEditable[sw]        THEN {w ¬ sw; RETURN[stop]}      ELSE RETURN[continue]};    Enumerate[enum];    RETURN WindowToUse[w]};  WindowToUse: PROC [sw: Window.Handle] RETURNS [Window.Handle] = INLINE {    RETURN[IF sw # NIL THEN sw ELSE FindWindowToUse[]]};  FindWindowToUse: PROC RETURNS [Window.Handle] = {    -- find empty active, full active, empty tiny, full tiny    ea, fa, et, ft: Window.Handle ¬ NIL;    enum: FileWindow.EnumerateProcType = {      empty: BOOLEAN = ~FileSW.IsIt[sw];      SELECT TRUE FROM        empty AND TextSW.GetEOF[sw] > aFewChars => RETURN[continue];        ~empty AND FileSW.IsEditable[sw] => RETURN[continue];        ENDCASE;      SELECT ToolWindow.GetState[ToolWindow.WindowForSubwindow[sw]] FROM        active => IF empty THEN ea ¬ sw ELSE IF fa = NIL THEN fa ¬ sw;        tiny =>          IF empty THEN {IF et = NIL THEN et ¬ sw} ELSE IF ft = NIL THEN ft ¬ sw;        ENDCASE;      RETURN[IF ea = NIL THEN continue ELSE stop]};    Enumerate[enum];    RETURN[      SELECT TRUE FROM        ea # NIL => ea,        fa # NIL => fa,        et # NIL => et,        ft # NIL => ft,        ENDCASE => NIL]};  -- Routines used to augment FileWindows    ListOfExtensions: TYPE = LONG POINTER TO Extensions;  Extensions: TYPE = RECORD [    ext: LONG STRING,    link: ListOfExtensions];  extensions: ListOfExtensions ¬ NIL;  SetExtension: PUBLIC ENTRY PROC [ext: LONG STRING] = {    p: LONG POINTER TO ListOfExtensions ¬ @extensions;    FOR l: ListOfExtensions ¬ extensions, l.link UNTIL l = NIL DO      IF String.Equivalent[ext, l.ext] THEN RETURN;      p ¬ @l.link;    ENDLOOP;    p­ ¬ z.NEW[Extensions ¬ [String.CopyToNewString[ext, z], NIL]]};  SetSourceMenu: PUBLIC ENTRY PROC [menu: Menu.Handle] = {sourceMenu ¬ menu};  SetMinimumWindows: PUBLIC ENTRY PROC [keep: CARDINAL] = {minimumCount ¬ keep};  GetInfo: PUBLIC PROC    RETURNS [LONG STRING, Menu.Handle, Menu.Handle, CARDINAL] = {    RETURN[IF extensions # NIL THEN extensions.ext ELSE NIL, editMenu, sourceMenu, minimumCount]};  -- Menu Command Routines (MCRs)  CreateMCR: PUBLIC Menu.MCRType = {    box: Window.Box;    options: TextSW.Options ¬ defaultOptions;    SELECT window FROM      NIL, Window.rootWindow => {        box.place ¬ [x: 0, y: (Window.rootWindow.GetBox.dims.h*2)/3];        box.dims ¬ [h: Window.rootWindow.GetBox.dims.h - box.place.y, w: 512]};      ENDCASE => {        options.wrap ¬ TextSW.GetOptions[window].wrap;        box ¬ HisToolWindow[window].GetBox};    [] ¬ InternalGetPlaceAndCreate[box, options]};  DestroyMCR: PUBLIC Menu.MCRType = {    IF windows <= minimumCount OR ~TestAndSet[window, resetting].ok THEN {      UserTerminal.BlinkDisplay[]; RETURN};    IF ~ConfirmAndDestroy[window] THEN {      Unlock[window]; UserTerminal.BlinkDisplay[]; RETURN};    -- No unlock here, context is gone anyway    };  EditMCR: PUBLIC Menu.MCRType = {    SetEditing: ENTRY PROC [sw: Window.Handle] = {      ENABLE UNWIND => NULL;      fw: FWContext = Context.Find[context, HisToolWindow[sw]];      fw.state ¬ editing;      TextSWExtra.BecomeInputFocus[sw];      BROADCAST cv};    IF ~TestAndSet[window, makingEditable].ok THEN {      UserTerminal.BlinkDisplay[]; RETURN};    IF MakeEditable[window] THEN SetEditing[window]    ELSE {UserTerminal.BlinkDisplay[]; Unlock[window]}};  EmptyMCR: PUBLIC Menu.MCRType = {    SELECT TRUE FROM      FileSW.IsIt[window] => {        IF FileSW.IsEditable[window] THEN {	  IF NOT Confirm[window] THEN {UserTerminal.BlinkDisplay[]; RETURN};	  IF ~TestAndSet[window, resetting, editing].ok THEN RETURN}	ELSE {	  IF ~TestAndSet[window, resetting].ok THEN {	    UserTerminal.BlinkDisplay[]; RETURN}};	Notify[[EventTypes.reset], window, NIL]; -- instead of EventTypes.destroy	FileSWToScratchSW[window]};      TextSW.GetEOF[window] # 0 => {        IF NOT Confirm[window] THEN {UserTerminal.BlinkDisplay[]; RETURN};	IF ~TestAndSet[window, resetting].ok THEN RETURN;	TextSW.DeleteText[window, 0, TextSW.GetEOF[window]];	SetEmptyName[HisToolWindow[window]]};      ENDCASE;    HisToolWindow[window].ValidateTree[];    Unlock[window];    TextSWExtra.BecomeInputFocus[window]}; «  ResetMCR: PUBLIC Menu.MCRType = {    SELECT TRUE FROM      FileSW.IsIt[window] => {        IF ~FileSW.IsEditable[window] THEN RETURN;	IF NOT Confirm[window] THEN {UserTerminal.BlinkDisplay[]; RETURN};        IF ~TestAndSet[window, resetting, editing].ok THEN RETURN;        IF ~ResetEditable[window] THEN UserTerminal.BlinkDisplay[];	Unlock[window];      };      TextSW.GetEOF[window] # 0 => {        IF NOT Confirm[window] THEN {UserTerminal.BlinkDisplay[]; RETURN};	IF ~TestAndSet[window, resetting].ok THEN RETURN;	TextSW.DeleteText[window, 0, TextSW.GetEOF[window]];	SetEmptyName[HisToolWindow[window]];	HisToolWindow[window].ValidateTree[];	Unlock[window];	TextSWExtra.BecomeInputFocus[window];      };      ENDCASE;  }; »«  EmptyMCR: PUBLIC Menu.MCRType = {    IF ~FileSW.IsIt[window] THEN {UserTerminal.BlinkDisplay[]; RETURN};    IF FileSW.IsEditable[window] THEN RETURN;    IF ~TestAndSet[window, resetting].ok THEN RETURN;--    Notify[[EventTypes.destroy], window, NIL];    FileSWToScratchSW[window];    HisToolWindow[window].ValidateTree[];    Unlock[window];    TextSWExtra.BecomeInputFocus[window];  }; »  LoadMCR: PUBLIC Menu.MCRType = {    IF ~TestAndSet[window, loading].ok THEN {UserTerminal.BlinkDisplay[]; RETURN};    IF ~LoadFromSelectionInternal[window, TRUE] THEN UserTerminal.BlinkDisplay[];    Unlock[window]};  ResetMCR: PUBLIC Menu.MCRType = {    SELECT TRUE FROM      ~FileSW.IsIt[window] => {UserTerminal.BlinkDisplay[]; RETURN};      FileSW.IsEditable[window] => {        IF ~Confirm[window] THEN {UserTerminal.BlinkDisplay[]; RETURN};        IF ~TestAndSet[window, resetting, editing].ok THEN RETURN;        IF ~ResetEditable[window] THEN UserTerminal.BlinkDisplay[]};      ENDCASE => {UserTerminal.BlinkDisplay[]; RETURN};    Unlock[window]};   StoreMCR: PUBLIC Menu.MCRType = {    ok: BOOLEAN;    oldState: State;    name: LONG STRING ¬ Selection.Convert[string];    IF String.EmptyString[name] OR name.length > MFile.maxNameLength      OR NameMatch[FileSW.GetFile[window].name, name]      THEN {      String.FreeString[z, name]; UserTerminal.BlinkDisplay[]; RETURN};    [ok, oldState] ¬ TestAndSet[window, storing, editOrQuiesce];    IF ~ok THEN {      String.FreeString[z, name]; UserTerminal.BlinkDisplay[]; RETURN};    IF ~WriteFile[window, name, FALSE] THEN {      [] ¬ TestAndSet[sw: window, new: oldState, old: storing];      String.FreeString[z, name];      UserTerminal.BlinkDisplay[];      RETURN};    String.FreeString[z, name];    Unlock[window];    HisToolWindow[window].ValidateTree};  SaveMCR: PUBLIC Menu.MCRType = {    name: LONG STRING ¬ String.CopyToNewString[FileSW.GetFile[window].name, z];    problem: BOOLEAN ¬ FALSE;    IF ~FileSW.IsEditable[window] OR ~TestAndSet[window, storing, editing].ok THEN      problem ¬ TRUE;    IF ~problem AND ~WriteFile[window, name, TRUE] THEN {      [] ¬ TestAndSet[window, editing, storing];      problem ¬ TRUE};    String.FreeString[z, name];    IF problem THEN UserTerminal.BlinkDisplay[] ELSE Unlock[window]};  TimeMCR: PUBLIC Menu.MCRType = {    IF Editable[window] THEN {      time: STRING ¬ [30];      from, to: TextSource.Position;      [from, to] ¬ TextSW.GetSelection[window];      Time.AppendCurrent[time];      TextSW.ReplaceText[        window, from, to - from, [LOOPHOLE[LONG[@time.text]], 0, time.length]]}    ELSE UserTerminal.BlinkDisplay[]};  TypeInMCR: PUBLIC Menu.MCRType = {    IF Editable[window] THEN SpecialUserInput.backStopInputFocus ¬ window    ELSE UserTerminal.BlinkDisplay[]};  -- Routines used to implement MCR's  EmptyScratchSW: PROC [window, sw: Window.Handle] = {    SetEmptyName[window];    ScratchSW.Create[sw];    FixupNew[sw]};  FileSWToScratchSW: PROC [sw: Window.Handle] = {    options: TextSW.Options = TextSW.GetOptions[sw];    RemoveAllMenus[sw];    FileSW.Destroy[sw];    EmptyScratchSW[HisToolWindow[sw], sw];    TextSW.SetOptions[sw, UseFlushWrap[options, TextSW.GetOptions[sw]]];    sw.InvalidateBox[[[0, 0], sw.GetBox.dims], isDirty];    sw.ValidateTree;    Supervisor.NotifyDirectSubsystems[      -- used to be EventTypes.destroy      event: [EventTypes.reset], eventData: sw, which: clients,      subsystem: Event.fileWindow]};  GetPlaceAndCreate: PUBLIC PROC [options: TextSW.Options ¬ defaultOptions]    RETURNS [sw: Window.Handle] = {    RETURN InternalGetPlaceAndCreate[startBox, options]};  InternalGetPlaceAndCreate: PUBLIC PROC [    box: Window.Box, options: TextSW.Options ¬ defaultOptions]    RETURNS [sw: Window.Handle] = {    info: Cursor.Info;    okay: BOOLEAN;    Cursor.Set[mouseRed];    info ¬ Cursor.GetInfo[];    [box.place, okay] ¬ UserInput.WaitForConfirmation[];    box.place ¬ [x: box.place.x - info.hotX, y: box.place.y - info.hotY];    box.dims ¬ [      w: MIN[box.dims.w, Window.GetBox[Window.rootWindow].dims.w - box.place.x],      h: MIN[box.dims.h, Window.GetBox[Window.rootWindow].dims.h - box.place.y]];    sw ¬ IF okay THEN Create[box: box, options: options] ELSE NIL;    Cursor.Set[textPointer];    UserInput.WaitNoButtons[];    RETURN[sw]};  LoadFromSelection: PUBLIC PROC [sw: Window.Handle] RETURNS [done: BOOLEAN] = {    IF ~TestAndSet[sw, loading].ok THEN RETURN[FALSE];    done ¬ LoadFromSelectionInternal[sw];    Unlock[sw]};  LoadFromSelectionInternal: PROC [sw: Window.Handle, inNotifier: BOOLEAN ¬ FALSE]    RETURNS [done: BOOLEAN] = {    name: LONG STRING;    nameDotExt: LONG STRING ¬ [MFile.maxNameLength];    confirmed: BOOLEAN ¬ FALSE;    toolWindow: Window.Handle = HisToolWindow[sw];    oldName: LONG STRING ¬ ToolWindow.GetName[toolWindow];    oldLength: CARDINAL = oldName.length;    NoExtension: PROC[s: LONG STRING] RETURNS[BOOLEAN] = {      FOR i: CARDINAL DECREASING IN [0..s.length) DO         IF s[i] = '. THEN RETURN[FALSE]; REPEAT FINISHED => RETURN[TRUE] ENDLOOP };    SELECT TRUE FROM      (name ¬ Selection.Convert[string]) = NIL => RETURN [FALSE];      name.length > MFile.maxNameLength => RETURN[FALSE];      FileSW.IsIt[sw] => IF FileSW.IsEditable[sw] THEN RETURN [FALSE];      TextSW.GetEOF[sw] # 0 AND (Selection.Convert[subwindow] # sw        OR name.length # TextSW.GetEOF[sw]) AND (~inNotifier OR ~(confirmed ¬ Confirm[sw])) => RETURN [FALSE];    ENDCASE;    done ¬ LoadWindowInternal[      fileName: name, loadIfSame: TRUE, sw: sw !      TextSource.Error => {done ¬ FALSE; CONTINUE}];    IF ~done AND NoExtension[name] THEN {      String.AppendString[nameDotExt, name];      FOR l: ListOfExtensions ¬ extensions, l.link WHILE l # NIL DO        BEGIN	  String.AppendString[nameDotExt, l.ext ! String.StringBoundsFault => GOTO skip];	  done ¬ LoadWindowInternal[	    fileName: nameDotExt, loadIfSame: TRUE, sw: sw !	    TextSource.Error => GOTO skip];	  IF done THEN EXIT;	  nameDotExt.length ¬ name.length;	EXITS	  skip => nameDotExt.length ¬ name.length;	END;      ENDLOOP;    };    String.FreeString[z, name];    IF confirmed AND ~done THEN {      oldName.length ¬ oldLength;      ToolWindow.SetName[toolWindow, oldName];    };  };  MakeEditable: PUBLIC PROC [sw: Window.Handle] RETURNS [done: BOOLEAN] = {    name: LONG STRING ¬ FileSW.GetFile[sw].name;    done ¬ FALSE;    IF ~FileSW.IsEditable[sw] AND FileSW.MakeEditable[sw] THEN {      SetWindowName[sw, name, TRUE];      FixupMenus[sw, TRUE];      Supervisor.NotifyDirectSubsystems[        event: [EventTypes.edit], eventData: sw, which: clients,        subsystem: Event.fileWindow];      done ¬ TRUE}};  ResetEditable: PUBLIC PROC [sw: Window.Handle] RETURNS [done: BOOLEAN] = {    done ¬ FALSE;    IF FileSW.IsEditable[sw] AND FileSW.GetFile[sw].s # NIL THEN {      Notify[[EventTypes.reset], sw, NIL];      FileSW.ResetEditableFile[sw];      SetWindowName[sw, FileSW.GetFile[sw].name];      FixupMenus[sw, FALSE];      Supervisor.NotifyDirectSubsystems[        event: [EventTypes.reset], eventData: sw, which: clients,        subsystem: Event.fileWindow];      done ¬ TRUE}};  ResetFile: PUBLIC PROC [sw: Window.Handle] RETURNS [done: BOOLEAN] = {    done ¬ ~Editable[sw]; IF done THEN FileSWToScratchSW[sw]};  SetEmptyName: PROC [window: Window.Handle] = {    ToolWindow.SetName[window, "Empty Window"L];    ToolWindow.SetTinyName[window, "Empty"L, "Window"L]};      ConfirmAndDestroy: PUBLIC PROC [sw: Window.Handle] RETURNS [done: BOOLEAN] = {    IF FileSW.IsEditable[sw] THEN RETURN[FALSE];    Cursor.Set[mouseRed];    done ¬ UserInput.WaitForConfirmation[].okay;    Cursor.Set[textPointer];    IF done THEN Destroy[sw]};  WriteFile: PROC [sw: Window.Handle, name: LONG STRING, skipConfirm: BOOLEAN]    RETURNS [BOOLEAN] = {    << Caller assures:    FileSW.IsEditable[sw] XOR ~EquivalentString[FileSW.GetFile[sw].name, name] >>    FixName: PROC = {      ToolWindow.SetName[HisToolWindow[sw], oldName]; z.FREE[@oldName]};    fullName: STRING ¬ [MFile.maxNameLength];    oldName: LONG STRING ¬ NIL;    myFile: MFile.Handle ¬ NIL;    IF name = NIL OR ~MFile.ValidFilename[name] THEN RETURN[FALSE];    BEGIN    oldName ¬ String.CopyToNewString[      ToolWindow.GetName[HisToolWindow[sw]], z];    IF ~skipConfirm THEN {      myFile ¬ MFile.Acquire[        name, anchor, MFile.dontRelease !	MFile.Error => {myFile ¬ NIL; CONTINUE}];      IF ~PostAndGetConfirm[sw, name, myFile # NIL] THEN {        IF myFile # NIL THEN MFile.Release[myFile];	z.FREE[@oldName];	RETURN[FALSE]}};    Notify[[EventTypes.store], sw, NIL];    Cursor.Set[hourGlass];    IF FileSW.IsEditable[sw] THEN {  -- Store on different name OR Save      sh: MStream.Handle;      IF myFile # NIL THEN MFile.Release[myFile]; -- else can't get exclusive access      IF ~FileSW.PutEditableFile[sw, name] THEN GOTO fail;      MStream.SetReleaseData[sh ¬ FileSW.GetFile[sw].s, [PleaseReleaseStream, sw]];      FixupMenus[sw, FALSE];      MFile.GetFullName[file: MStream.GetFile[sh], name: fullName]}    ELSE { -- Store ScratchSW or non-editable FileSW on different name      readS: MStream.Handle ¬ NIL;      {      writeS: MStream.Handle;      oldOptions: TextSW.Options = TextSW.GetOptions[sw]; -- in case a ScratchSW      isFileSW: BOOLEAN = FileSW.IsIt[sw];      IF isFileSW THEN {        IF (readS ¬ FileSW.GetFile[sw].s) = NIL THEN GOTO problem;        MStream.SetReleaseData[stream: readS, release: []]};      {      ENABLE MFile.Error => GOTO problem;      IF myFile # NIL THEN MFile.SetAccess[myFile, readWrite]      ELSE myFile ¬ MFile.ReadWrite[name, MFile.dontRelease, text]};      -- myFile is ReadWrite so can Copy handle with read later      writeS ¬ MStream.Create[myFile, []];      MStream.SetLength[writeS, 0];      IF isFileSW THEN {        readS.SetPosition[0];        DO          Stream.PutByte[            writeS, readS.GetByte[ ! Stream.EndOfStream => EXIT]];          ENDLOOP}      ELSE {        writeS.PutBlock[ScratchSW.Info[sw].block]; ScratchSW.Destroy[sw]};      writeS.SendNow;      myFile ¬ MFile.CopyFileHandle[        MStream.GetFile[writeS], MFile.dontRelease, readOnly];      writeS.Delete;      MFile.GetFullName[file: myFile, name: fullName];      readS ¬ MStream.Create[file: myFile, release: [PleaseReleaseStream, sw]];      IF isFileSW THEN FileSW.SetFile[sw, fullName, readS, 0]      ELSE {        FileSW.Create[sw, fullName, UseFlushWrap[oldOptions], readS, 0];        FixupMenus[sw, FALSE]};      EXITS        problem => {          IF myFile # NIL THEN MFile.Release[myFile];          IF readS # NIL THEN            MStream.SetReleaseData[              stream: readS, release: [PleaseReleaseStream, sw]];	  FixName[];          RETURN[FALSE]}}};    SetWindowName[sw, fullName, FALSE];    Supervisor.NotifyDirectSubsystems[      event: [EventTypes.store], eventData: sw, which: clients,      subsystem: Event.fileWindow];    Cursor.Set[textPointer];    z.FREE[@oldName];    RETURN[TRUE];    EXITS fail => {Cursor.Set[textPointer]; FixName[]; RETURN[FALSE]}    END};  -- Private Utilities  Confirm: PROC [sw: Window.Handle] RETURNS [ok: BOOLEAN] = {    toolWindow: Window.Handle = HisToolWindow[sw];    oldName: LONG STRING ¬ ToolWindow.GetName[toolWindow];    oldLength: CARDINAL = oldName.length;    String.AppendStringAndGrow[@oldName, " [Confirm]"L, z];    ToolWindow.SetName[toolWindow, oldName];    Cursor.Set[mouseRed];    IF ~(ok ¬ UserInput.WaitForConfirmation[].okay) THEN {      oldName.length ¬ oldLength;      ToolWindow.SetName[toolWindow, oldName]};    Cursor.Set[textPointer];    String.FreeString[z, oldName]};  Editable: PROC [sw: Window.Handle] RETURNS [BOOLEAN] = {    RETURN[~FileSW.IsIt[sw] OR FileSW.IsEditable[sw]]};  FixupMenus: PROC [sw: Window.Handle, editable: BOOLEAN] = {    RemoveAllMenus[sw];    IF editable THEN editMenu.Instantiate[sw]    ELSE {      readMenu.Instantiate[sw];      IF sourceMenu # NIL THEN sourceMenu.Instantiate[sw]}};  UseFlushWrap: PROC [    old: TextSW.Options, new: TextSW.Options ¬ defaultOptions]    RETURNS [TextSW.Options] = {    new.wrap ¬ old.wrap;    new.flushTop ¬ old.flushTop;    new.flushBottom ¬ old.flushBottom;    RETURN[new]};  RemoveAllMenus: PROC [sw: Window.Handle] = {    scratchMenu.Uninstantiate[sw ! Menu.Error => CONTINUE];    readMenu.Uninstantiate[sw ! Menu.Error => CONTINUE];    IF sourceMenu # NIL THEN      sourceMenu.Uninstantiate[sw ! Menu.Error => CONTINUE];    editMenu.Uninstantiate[sw ! Menu.Error => CONTINUE]};  FixupNew: PROC [sw: Window.Handle] = {    scratchMenu.Instantiate[sw];    oldInterpreter ¬ TIP.GetNotifyProc[sw];    TIP.CreateClient[sw, TIP.globalTable[fileWindow], TIPMe]};  HisToolWindow: PROC [window: Window.Handle] RETURNS [Window.Handle] = {    RETURN[      SELECT ToolWindow.Type[window] FROM        tool => window,        clipping => window.GetParent,        sub => window.GetParent.GetParent,        ENDCASE => NIL]};  DoItFNR: PROC [window: Window.Handle] = {    -- Should work for token with caret.  Interim code follows.    length: LONG CARDINAL ¬ TextSW.GetEOF[window];    IF length IN [1..MFile.maxNameLength) THEN {      TextSW.SetSelection[window, 0, length]; LoadMCR[window, NIL, 0]}    ELSE UserTerminal.BlinkDisplay[]};  Notify: Supervisor.AgentProcedure = {    OPEN EventTypes;    sw: Window.Handle = eventData;    SELECT event FROM      destroy, load, reset, store =>        IF SpecialUserInput.backStopInputFocus = sw THEN	  SpecialUserInput.backStopInputFocus ¬ NIL;      ENDCASE};  PostAndGetConfirm: PROC [sw: Window.Handle, name: LONG STRING, old: BOOLEAN]    RETURNS [ok: BOOLEAN] = {    toolWindow: Window.Handle = HisToolWindow[sw];    oldName: LONG STRING ¬ ToolWindow.GetName[toolWindow];    wName: LONG STRING ¬ String.CopyToNewString[name, z];    String.AppendStringAndGrow[@wName, IF old THEN " (Old File)"L ELSE " (New File)"L, z];    String.AppendStringAndGrow[@wName, " [Confirm]"L, z];    ToolWindow.SetName[toolWindow, wName];    Cursor.Set[mouseRed];    IF ~(ok ¬ UserInput.WaitForConfirmation[].okay) THEN      ToolWindow.SetName[toolWindow, oldName];    Cursor.Set[textPointer];    String.FreeString[z, oldName];    String.FreeString[z, wName]};  SetWindowName: PROC [    sw: Window.Handle, name: LONG STRING, edit: BOOLEAN ¬ FALSE] = {    w: Window.Handle = ToolWindow.WindowForSubwindow[sw];    windowName: STRING = [MFile.maxNameLength];    AppendShortName[name, windowName];    ToolWindow.SetTinyName[w, windowName];    windowName.length ¬ 0;    String.AppendString[windowName, IF edit THEN "Editing: "L ELSE "File: "L];    String.AppendString[windowName, name];    ToolWindow.SetName[w, windowName]};  NameMatch: PROC [fullName, name: LONG STRING] RETURNS [same: BOOLEAN] = {    n: STRING ¬ [MFile.maxNameLength];    IF fullName = NIL THEN RETURN[FALSE];    IF String.EquivalentString[name, fullName] THEN RETURN[TRUE];    AppendShortName[fullName, n];    same ¬ String.EquivalentString[name, n]};  AppendShortName: PROC [fullName, name: LONG STRING] = {    i: CARDINAL;    FOR i DECREASING IN [0..fullName.length) DO      IF fullName[i] = '> THEN {i ¬ i + 1; EXIT};      REPEAT FINISHED => i ¬ 0;      ENDLOOP;    FOR j: CARDINAL IN [i..fullName.length) DO      String.AppendChar[name, fullName[j] ! String.StringBoundsFault => CONTINUE];      ENDLOOP};  -- FileSystem operations:  NewStream: PROC [name: LONG STRING, access: MFile.Access, sw: Window.Handle]    RETURNS [MStream.Handle] = {    file: MFile.Handle = MFile.Acquire[      name: name, access: access, release: MFile.dontRelease];    IF file.GetType = directory THEN {file.Release; RETURN[NIL]}    ELSE RETURN[MStream.Create[file: file, release: [PleaseReleaseStream, sw]]]};  TestAndSet: ENTRY PROC [sw: Window.Handle, new: State, old: State ¬ quiescent]    RETURNS [ok: BOOLEAN, oldIfOk: State] = {    ENABLE UNWIND => NULL;    fw: FWContext = Context.Find[context, HisToolWindow[sw]];    oldIfOk ¬ fw.state;    IF      (ok ¬        SELECT old FROM          fw.state => TRUE,          editOrQuiesce => fw.state = editing OR fw.state = quiescent,          ENDCASE => FALSE) THEN fw.state ¬ new};  WaitAndSet: ENTRY PROC [sw: Window.Handle, new: State] RETURNS [ok: BOOLEAN] = {    ENABLE UNWIND => NULL;    fw: FWContext = Context.Find[context, HisToolWindow[sw]];    UNTIL (ok ¬ fw.state = quiescent) DO      IF fw.state = editing THEN RETURN[FALSE]; WAIT cv; ENDLOOP;    fw.state ¬ new};  Unlock: ENTRY PROC [sw: Window.Handle] = {    ENABLE UNWIND => NULL;    fw: FWContext = Context.Find[context, HisToolWindow[sw]];    fw.state ¬ quiescent;    BROADCAST cv};  ForkedRelease: PROC [sw: Window.Handle] = {    n: STRING ¬ [MFile.maxNameLength];    AppendShortName[FileSW.GetFile[sw].name, n];    MFile.AddNotifyProc[      proc: MyNotifyProc, filter: [name: n, access: readOnly],      clientInstanceData: sw];    FileSWToScratchSW[sw];    Unlock[sw]};  PleaseReleaseStream: ENTRY PROC [    stream: MStream.Handle, instanceData: Window.Handle]    RETURNS [MFile.ReleaseChoice] = {    ENABLE UNWIND => NULL;    fw: FWContext = Context.Find[context, HisToolWindow[instanceData]];    IF FileSW.IsEditable[instanceData] THEN RETURN[no];    IF fw.state = resetting THEN RETURN[later];    IF fw.state = quiescent THEN {      fw.state ¬ resetting;      Process.Detach[FORK ForkedRelease[instanceData]];      RETURN[later]};    RETURN[no]};  MyNotifyProc: MFile.NotifyProc = {    sw: Window.Handle = clientInstanceData;    IF ~IsIt[sw] OR ~ScratchSW.IsIt[sw] OR TextSW.GetEOF[sw] > aFewChars      OR file = NIL OR ~WaitAndSet[sw, loading] THEN      RETURN[removeNotifyProc: TRUE];    [] ¬ LoadWindowInternal[      fileName: name,      s: MStream.Create[      file: MFile.CopyFileHandle[file, MFile.dontRelease, readOnly],      release: [PleaseReleaseStream, sw]], sw: sw];    Unlock[sw];    RETURN[removeNotifyProc: TRUE]};  -- Routines for Rubicon to allow emergency recovery of edits when pre-Cascade crashes  PutEditableFile: PROC [sw: Window.Handle, name: LONG STRING] = {    << Cannot use FileSW.PutEditableFile because it tries to change PNRs and you are    probably running inside of the UserInputs MONITOR! >>    source: TextSource.Handle ¬ TextSW.GetSource[sw];    IF PieceSource.IsIt[source] AND PieceSource.Info[source].original # NIL THEN      source ¬ PieceSource.Put[source, name]};  SaveAnEditableWindow: FileWindow.EnumerateProcType = {    IF FileSW.IsEditable[sw] THEN {      name: LONG STRING ¬ String.CopyToNewString[FileSW.GetFile[sw].name, z];      IF name # NIL THEN {        PutEditableFile[sw, name ! ANY => {UserTerminal.BlinkDisplay[]; CONTINUE}];        String.FreeString[z, name ! ANY => {UserTerminal.BlinkDisplay[]; CONTINUE}]}};    RETURN[continue]};  Save, SaveAllEditableWindows: PROC = {    Enumerate[SaveAnEditableWindow];  -- named files    BEGIN -- unnamed files      writeS: MStream.Handle ¬ MStream.ReadWrite["ScratchWindows.saved"L, [], text];      SaveAScratchWindow: FileWindow.EnumerateProcType = {        ENABLE ANY => {UserTerminal.BlinkDisplay[]; CONTINUE};        IF ScratchSW.IsIt[sw] THEN {	  writeS.PutString["\n===== "L];	  writeS.PutString[ToolWindow.GetName[HisToolWindow[sw]]];	  writeS.PutString[" =====\n"L];	  writeS.PutBlock[ScratchSW.Info[sw].block]}};      MStream.SetLength[writeS, 0];      Enumerate[SaveAScratchWindow];      writeS.SendNow;      writeS.Delete;    END};  TIPMe: TIP.NotifyProc = {    WITH z: results.First[] SELECT FROM      atom => SELECT z.a FROM	doit => DoItFNR[window];        ENDCASE => GOTO NotMe;      ENDCASE => GOTO NotMe;    EXITS NotMe => IF oldInterpreter # NIL THEN oldInterpreter[window, results]};      GetExtensionsFromUserCM: PROC = {    s: LONG STRING ¬ CmFile.UserDotCmLine["FileWindow"L, "Extensions"L];    IF s = NIL THEN {      SetExtension[".mesa"L];      SetExtension[".config"L];      SetExtension[".cm"L];    } ELSE {      i, j: CARDINAL ¬ 0;      ext: LONG STRING ¬ [MFile.maxNameLength];      sub: String.SubStringDescriptor;      sub.base ¬ s;      DO        IF s[i] = '. THEN {	  j ¬ i+1;	  WHILE j < s.length AND s[j] # '  AND s[j] # '\n DO j ¬ j + 1 ENDLOOP;	  sub.offset ¬ i;	  sub.length ¬ j - i;	  ext.length ¬ 0;	  String.AppendSubString[to: ext, from: @sub];	  SetExtension[ext];	  i ¬ j - 1;	};	IF (i ¬ i + 1) >= s.length THEN EXIT;      ENDLOOP;      [] ¬ CmFile.FreeString[s];    };  };  Init: PROC = {    doit ¬ Atom.MakeAtom["DoIt"L];--    defaultExtension ¬ String.CopyToNewString[".mesa"L, z];    GetExtensionsFromUserCM[];    Supervisor.AddDependency[client: agent, implementor: Event.fileWindow]};      Init[];  END.DWR    	18-Feb-85 12:11:21 Modified Save[] to save empty windowsDWR    	 1-Mar-85 13:28:16 Made LoadWindow use SetPositionWithOverRide[, , middle]DWR    	 5-Mar-85  9:38:13 Undid the previous changeDWR    	 1-Aug-85 18:03:03 Added GetExtensionsFromUserCM[] et al.DWR    	 2-Aug-85 12:42:39 Fixed a bug in it.  Had to copy strings in SetExtension[].DWR    	30-Jun-86 14:44:26 Changed Empty/Reset UI to be:Filewindow before edit---empty -> empitesreset -> no-opFilewindow after edit---empty -> no-opreset -> resets after a confirmEmpty Window---empty -> no-opreset -> empties after a confirmDWR 	18-Jul-86 11:47:37 Stopped FileSWToScratch from raising the EventTypes.destroy event.  It raises reset instead.
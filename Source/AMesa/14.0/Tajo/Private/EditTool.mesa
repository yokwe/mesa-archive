-- File: EditTool.mesa - last edit:-- Riggle.PA            8-Aug-86 16:20:04-- Copyright (C) 1986 by Xerox Corporation. All rights reserved.-- BGY      	29-Jul-83 11:13:24-- Poskanzer	16-Nov-84 11:50:08-- Hamilton.ES	15-Nov-84 20:48:23-- AXD     	26-Apr-84 16:54:33-- DWR    	 1-Apr-85 11:16:49DIRECTORY  Ascii: TYPE USING [SP, TAB],  Atom: TYPE USING [ATOM, MakeAtom],  CmFile: TYPE USING [Close, Error, FindSection, FreeString, Handle, NextItem, UserDotCmOpen],  Context: TYPE USING [Create, Data, Find, Type, UniqueType],  Cursor: TYPE USING [Fetch, Handle, Object, Set, Store, Type],  EditOps: TYPE USING [FreePat],  EditUtil: TYPE USING [    CantReplace, ConfirmType, CountInTSW, Data, DataHandle, DoFindInFSW,    DoFindInTSW, EditUtilImplA, EditUtilImplB, FindReplaceInFSW,    FindReplaceInTSW, Interpret, MContext, PHandle, PropData, ReplaceAllInFSW,    ReplaceAllInTSW, ReplaceFindInFSW, ReplaceFindInTSW, ReplaceInFSW,    ReplaceInTSW, ScopeType, ToggleForm, Update],  Environment: TYPE USING [Block],  FormSW: TYPE USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType, CommandItem,    Create, Display, Enumerated, EnumeratedItem, IsIt, ItemHandle, newLine,    NumberItem, ProcType, SetTypeIn, StringItem],  Heap: TYPE USING [systemZone],  Inline: TYPE USING [LowHalf],  Menu: TYPE USING [Handle, Instantiate, Make, MCRType, Uninstantiate],  Process: TYPE USING [Detach],  Profile: TYPE USING [debugging],  Put: TYPE USING [CR, Line],  Runtime: TYPE USING [GetBcdTime],  String: TYPE USING [AppendChar, CopyToNewString, Equivalent, InvalidNumber, Length, StringBoundsFault, StringToNumber],  Symbiote: TYPE USING [    AttachSymbioteSW, DetachSymbioteSW, Error, SymbioteForHost],  TextSource: TYPE USING [    Direction, Handle, nullPosition, Position, ReadText,    ReplaceText, ScanText],  TextSW: TYPE USING [    GetOptions, GetSelection, GetSource, InvalidRegions, IsIt, ModifySource,    Position, PositionIsVisible, SetSelection],  TextSWExtraExtra USING [SetPositionWithOverRide],  TextSWOps: TYPE USING [ModifyInsertionState, RealActOnCaret, textSWContext, TSWContext],  Time: TYPE USING [Append, Unpack],  TIP: TYPE USING [    First, mouseTIP, NewManager, NotifyProc, Rest, Results, SetNotifyProc],  Tool: TYPE USING [Create, MakeFormSW, MakeMsgSW, MakeSWsProc],  ToolWindow: TYPE USING [    Activate, CreateSubwindow, Deactivate, Destroy, GetState, Handle,    MakeSize, TransitionProcType, WindowForSubwindow],  UserInput: TYPE USING [StuffCurrentSelection, UserAbort],  UserTerminal: TYPE USING [BlinkDisplay],  Window: TYPE USING [Handle, Object, rootWindow];  EditTool: MONITOR  IMPORTS     Atom, CmFile, Context, Cursor, FormSW,     EditOps, EditUtil, Heap, Inline, Menu, Put, Profile, Process, String,     Runtime, Symbiote, TextSW, TextSWExtraExtra, TextSWOps, TextSource,     Time, Tool, ToolWindow, TIP, UserInput, Window, UserTerminal  EXPORTS EditUtil = {    DataHandle: TYPE = EditUtil.DataHandle;  Data: TYPE = EditUtil.Data;      prop: PUBLIC EditUtil.PHandle ¬ NIL;  defaultProp: EditUtil.PHandle ¬ NIL;    ScopeType: TYPE = EditUtil.ScopeType;  Interpret: TYPE = EditUtil.Interpret;  MContext: TYPE = EditUtil.MContext;    Help, DoIt, pointUp, adjustUp, Abort, Editor: Atom.ATOM;  context: Context.Type ¬ Context.UniqueType[];  zone: PUBLIC UNCOUNTED ZONE  ¬  Heap.systemZone;  nullPosition: TextSource.Position ¬ TextSource.Position.LAST;    Items: TYPE = {all, find, findRep, pattern, repFind, replace, new, iRepFind, iReplace, iNew};  PItems: TYPE = {scope, interpret, context, case, confirm, level};  UpDown: TYPE = {up, down};    editMenu: Menu.Handle ¬ NIL;  oldCursor: PUBLIC Cursor.Object;  StringNine: TYPE = ARRAY[0..9) OF LONG STRING;  EditMenuString: TYPE = LONG POINTER TO StringNine;  editMenuString: EditMenuString ¬ NIL;  blanks: LONG STRING ¬ NIL;  mouseState: EditUtil.ConfirmType;  waitForAction: BOOLEAN;  getInput: CONDITION;    ClearError: PROC = {    Put.CR[prop.msgSW];    Put.CR[prop.msgSW]};    Confirmation: PUBLIC ENTRY PROC RETURNS [state: EditUtil.ConfirmType]  = {    cursorCopy: Cursor.Object;    waitForAction ¬ TRUE;    Cursor.Fetch[@cursorCopy];    oldCursor ¬ cursorCopy;    Cursor.Set[mouseRed];    WHILE waitForAction DO WAIT getInput ENDLOOP;    Cursor.Store[@cursorCopy];    state ¬ mouseState};      MakeMenu: PROC = {    editMenuString¬ zone.NEW[StringNine ¬ [      String.CopyToNewString["All"L, zone],      String.CopyToNewString["Search"L, zone],      String.CopyToNewString["SearchReplace"L, zone],      String.CopyToNewString["ReplaceSearch"L,zone],      String.CopyToNewString["Replace"L, zone],      String.CopyToNewString["Nest"L, zone],      String.CopyToNewString["UnNest"L, zone],      String.CopyToNewString["Match"L, zone],      String.CopyToNewString["Count"L, zone]]];    editMenu ¬ Menu.Make[name: "Edit Ops"L, strings: DESCRIPTOR[editMenuString­],      mcrProc: EditMCR, copyStrings: FALSE, permanent: TRUE]};      WaitForConfirm: ENTRY TIP.NotifyProc = {    FOR input: TIP.Results ¬ results, input.Rest UNTIL input = NIL DO      WITH z: input.First SELECT FROM        atom => SELECT z.a FROM 	  adjustUp =>{	    mouseState ¬ notOk;	    GOTO finished};	  pointUp => {	    mouseState ¬ ok;	    GOTO finished};	  Abort => {	    mouseState ¬ abort;	    GOTO finished};	  ENDCASE;	ENDCASE;      ENDLOOP;    EXITS finished => {      waitForAction ¬ FALSE;      NOTIFY getInput}};    DelSymbiote: PUBLIC PROC[sw: Window.Handle] = {    td: DataHandle;    IF sw = NIL THEN GOTO bad;    IF (td ¬ Context.Find[context, sw]) = NIL THEN GOTO bad;    Symbiote.DetachSymbioteSW[sw ! Symbiote.Error => GOTO bad];    Menu.Uninstantiate[editMenu, td.sw];    EXITS bad => ErrMsg[ "No symbiote on host subwindow"L]};    EditMCR: Menu.MCRType = {    ENABLE  EditUtil.CantReplace => GOTO failed;    sym: Window.Handle ¬ NIL;    td: DataHandle ¬ NIL;    textSW: BOOLEAN ¬ TextSW.IsIt[window];    IF (sym ¬ Symbiote.SymbioteForHost[window, context]) = NIL THEN GOTO noSym;     IF (td ¬ Context.Find[context, sym]) = NIL THEN GOTO noSym;    IF ~textSW AND index >= 5 THEN GOTO wrongType;    SELECT index FROM      0 => ReplaceAll[sym];      1 => DoFind[sym];      2 => FindReplace[sym];      3 => ReplaceFind[sym];      4 => Replace[sym];      5 => DoLevel[window, up];      6 => DoLevel[window, down];      7 => DoMatch[window];      8 => EditUtil.CountInTSW[window,td];      ENDCASE;    EXITS       failed => ErrMsg["Replacement not after a search"L];      wrongType => ErrMsg["Command only works on text subwindows"L];      noSym => ErrMsg["No symbiote on window"L]};    DoLevel: PROC[sw: Window.Handle, dir: UpDown] = {    source: TextSource.Handle ¬ NIL;    start, end, oldEnd, alpha, realStart: TextSource.Position ¬ 0;    margin: CARDINAL ¬ 0;    delta, totDelta: LONG INTEGER ¬ 0;    tsw: TextSWOps.TSWContext ¬ Context.Find[TextSWOps.textSWContext, sw];    Modify: PROCEDURE [w: Window.Handle, h: TextSource.Handle, p:LONG POINTER]       RETURNS [invalidRegions: TextSW.InvalidRegions] = {      invalidRegions ¬ NIL;      WHILE start < end DO	[margin,alpha] ¬ GetMargin[source, start];	MakeBlanks[	  IF dir = up THEN margin+prop.level 	  ELSE IF margin < prop.level THEN 0 ELSE margin - prop.level];	delta ¬ source.ReplaceText[	  [LOOPHOLE[@blanks.text],0, blanks.length], start, alpha, TRUE].delta;	IF delta > 0 THEN end ¬ end + ABS[delta]	ELSE end ¬ end - ABS[delta];	totDelta ¬ totDelta + delta;	start ¬ source.ScanText[start, line, right];	ENDLOOP;      tsw.selection.left ¬ realStart;      tsw.selection.right ¬ MIN[end, source.getLength[source]]; -- fix beyond eof bug      TextSWOps.ModifyInsertionState[        tsw: tsw,	op: change,	pos: tsw.selection.right];      TextSWOps.RealActOnCaret[tsw, reset];      EditUtil.Update[sw, realStart, MAX[oldEnd, end], totDelta]};          ClearError[];    IF TextSW.GetOptions[sw].access # edit THEN GOTO bad;     source ¬ TextSW.GetSource[sw];    [start, end] ¬ TextSW.GetSelection[sw];    IF start = TextSource.nullPosition THEN GOTO badSelect;    start ¬ source.ScanText[start, line, left];    realStart ¬ start;    oldEnd ¬ end;    TextSW.ModifySource[sw, Modify, NIL];    EXITS       bad => ErrMsg["Window not editable"L];      badSelect => ErrMsg["Selection not in window"L]};    ErrMsg: PROC[s: LONG STRING] = {    UserTerminal.BlinkDisplay[];    Put.Line[prop.msgSW, s]};    MakeBlanks: PROC[length: CARDINAL] = {    ENABLE String.StringBoundsFault => {ns ¬ blanks ¬ NewString[s]; RESUME};    tabCount: CARDINAL ¬ length / 8;    spaceCount: CARDINAL ¬ length MOD 8;    i: CARDINAL ¬ 0;    blanks.length ¬ 0;    FOR i IN [0..tabCount) DO String.AppendChar[blanks, Ascii.TAB] ENDLOOP;    FOR i IN [0..spaceCount) DO String.AppendChar[blanks, Ascii.SP] ENDLOOP};      NewString: PROC[s: LONG STRING] RETURNS [ns: LONG STRING] = {    ns ¬ zone.NEW[StringBody[s.maxlength*2]];    ns.length ¬ s.length;    FOR i:CARDINAL IN [0..s.length) DO ns[i] ¬ s[i] ENDLOOP;    zone.FREE[@s]};    GetMargin: PROC[source: TextSource.Handle, start: TextSource.Position]     RETURNS [margin: CARDINAL, end: TextSource.Position] = {    block: Environment.Block;    c: CHARACTER;    i: TextSource.Position ¬ 0;    margin ¬ 0;    i ¬ start;    blanks.length ¬ 0;    DO      block ¬ source.ReadText[i,1,none].block;      c ¬ LOOPHOLE[block.blockPointer[block.startIndex], CHARACTER];      SELECT c FROM         Ascii.SP => margin ¬ margin + 1;	Ascii.TAB => margin ¬  ((margin/8) + 1) * 8;	ENDCASE => EXIT;      i ¬ i + 1;      ENDLOOP;    end ¬ i};      MatchType: TYPE = {found, notFound, aborted};      DoMatch: PROC[sw: Window.Handle] = {    AbortMe: PROCEDURE RETURNS [BOOLEAN] = {      RETURN [UserInput.UserAbort[sw]]};     match: MatchType ¬ notFound;    start, selStart, end, selEnd: TextSource.Position;    ClearError[];    [selStart, selEnd] ¬ TextSW.GetSelection[sw];    IF selStart = TextSource.nullPosition THEN GOTO badSelect;    [match, start, end] ¬ DoMatchFromSource[AbortMe, TextSW.GetSource[sw], selStart, selEnd - selStart];    SELECT match FROM      notFound => GOTO bad;      aborted => GOTO quit;    ENDCASE;    TextSW.SetSelection[sw, start, end];    IF ~TextSW.PositionIsVisible[sw, end] THEN      TextSWExtraExtra.SetPositionWithOverRide[sw, end, topBottom]    ELSE IF ~TextSW.PositionIsVisible[sw, start] THEN      TextSWExtraExtra.SetPositionWithOverRide[sw, start, top]; -- make selction pretty    EXITS       badSelect => ErrMsg["No selection in window"L];      quit => ErrMsg["Match aborted..."L];      bad => ErrMsg["Match not found"L]};    DoMatchFromSource: PROC[    abortMe: PROC RETURNS [BOOLEAN], source: TextSource.Handle,    start: TextSource.Position, selectionLength: LONG CARDINAL]     RETURNS [match: MatchType, startPos, pos: TextSource.Position]= {    count: INTEGER;    dir: TextSource.Direction;    block: Environment.Block;    token, matchToken: Tokens;        Tokens: TYPE = {  -- matching opens and closes must be in the same order      openCurly, do, select, begin, openParen, openBracket, openEuroComment,      openAngleComment, closeCurly, endloop, endcase, end, closeParen,      closeBracket, closeEuroComment, closeAngleComment, notFound};          OpenTokens: TYPE = Tokens [openCurly..openAngleComment];    CloseTokens: TYPE = Tokens [closeCurly..closeAngleComment];	    tokenStrings: ARRAY Tokens OF LONG STRING ¬ [      openCurly:	"{"L,      do:		"DO"L,      select:		"SELECT"L,      begin:		"BEGIN"L,      openParen:	"("L,      openBracket:	"["L,      openEuroComment:	"«"L,      openAngleComment:	"<<"L,      closeCurly:	"}"L,      endloop:		"ENDLOOP"L,      endcase:		"ENDCASE"L,      end:		"END"L,      closeParen:	")"L,      closeBracket:	"]"L,      closeEuroComment:	"»"L,      closeAngleComment:">>"L,      notFound: NIL];        reverseTokenStrings: ARRAY Tokens OF LONG STRING ¬ [  -- for fast backwards matching      openCurly:	"{"L,      do:		"OD"L,      select:		"TCELES"L,      begin:		"NIGEB"L,      openParen:	"("L,      openBracket:	"["L,      openEuroComment:	"«"L,      openAngleComment:	"<<"L,      closeCurly:	"}"L,      endloop:		"POOLDNE"L,      endcase:		"ESACDNE"L,      end:		"DNE"L,      closeParen:	")"L,      closeBracket:	"]"L,      closeEuroComment:	"»"L,      closeAngleComment:">>"L,      notFound: NIL];        -- instance data     SearchFailed: SIGNAL = CODE;    SearchAborted: SIGNAL = CODE;    delta: INTEGER [-1..1];    array: LONG POINTER TO PACKED ARRAY OF CHARACTER;    newIndex, position: TextSource.Position;    length, nextCharInBlock, lastPlusDelta: CARDINAL;    direction: TextSource.Direction;    tokens: LONG POINTER TO ARRAY Tokens OF LONG STRING;    abortProc: PROCEDURE RETURNS [BOOLEAN];  « read another block from the source & update instance data »      LoadBlock: PROCEDURE = {      tempIndex: TextSource.Position;      DO	tempIndex ¬ newIndex;	IF direction = left THEN {	  sizeToRead: CARDINAL ¬ IF tempIndex < 512 THEN Inline.LowHalf[tempIndex] ELSE 512;	  DO	    [block, tempIndex] ¬ source.readText[source, (newIndex - sizeToRead), sizeToRead, none];	    IF block.startIndex # block.stopIndexPlusOne AND tempIndex # newIndex THEN {«	      sizeToRead ¬ Inline.LowHalf[newIndex - tempIndex];  -- short shrift.  read the part shrifted »	      sizeToRead ¬ sizeToRead/2; -- exponential drop off better than linear as above.  sizeToRead = 1 is guaranteed to work.	      LOOP;	    };	    newIndex ¬ newIndex - sizeToRead;	    EXIT;	  ENDLOOP; 	} ELSE -- direction = right -- {	  [block, newIndex] ¬ source.readText[source, newIndex, 512, none];	};	array ¬ LOOPHOLE[block.blockPointer];	IF block.startIndex # block.stopIndexPlusOne THEN EXIT;	IF (direction = right AND newIndex = source.getLength[source]) OR (direction = left AND newIndex = 0) THEN ERROR SearchFailed;      ENDLOOP;      length ¬ block.stopIndexPlusOne - block.startIndex;      IF direction = left THEN {	nextCharInBlock ¬ block.stopIndexPlusOne-1;	lastPlusDelta ¬ block.startIndex-1;      } ELSE {	nextCharInBlock ¬ block.startIndex;	lastPlusDelta ¬ block.stopIndexPlusOne}};« return the next character, using the instance data for bookkeeping »      GetChar: PROCEDURE RETURNS [char: CHARACTER] = {       IF nextCharInBlock = lastPlusDelta THEN {	IF abortProc # NIL AND abortProc[] THEN ERROR SearchAborted;	LoadBlock[]};      char ¬ array[nextCharInBlock];      position ¬ position + delta;      nextCharInBlock ¬ nextCharInBlock + delta};    « initialize instance data for this direction & starting position »     SetUpSearch: PROCEDURE [start: TextSource.Position,      direct: TextSource.Direction,      abortMe: PROCEDURE RETURNS [BOOLEAN] ¬ NIL] = {      direction ¬ direct;      delta ¬ IF direction = left THEN -1 ELSE +1;      newIndex ¬ start;      position ¬ newIndex - delta;      length ¬ nextCharInBlock ¬ lastPlusDelta ¬ 0; -- force a LoadBlock the first time through      tokens ¬ IF direction = right THEN @tokenStrings ELSE @reverseTokenStrings;      abortProc ¬ abortMe};« search in the current direction for either of two tokens »    SearchForTwoTokens: PROCEDURE [token, matchToken: Tokens] RETURNS [tokenFound: Tokens] =    BEGIN ENABLE SearchFailed => GOTO abort;      c, oldc: CHARACTER;      t1: CHARACTER = tokens[token][0];  -- accelerators      t2: CHARACTER = tokens[matchToken][0]; -- we rely on the fortuitous fact that t1 can never = t2      DO	WHILE (c ¬ GetChar[]) # t1 AND c # t2 DO oldc ¬ c ENDLOOP;	BEGIN	  s: LONG STRING = IF c = t1 THEN tokens[token] ELSE tokens[matchToken];	  FOR i: CARDINAL IN [1..s.length) DO	    IF GetChar[] # s[i] THEN EXIT;	  REPEAT	    FINISHED => BEGIN	      IF matchToken = end AND c = t2 THEN -- Note: if matchToken is END, you must be searching forward.		SELECT GetChar[ ! SearchFailed => GOTO eof] FROM		  'L, 'C => NULL; -- wasn't an END after all		ENDCASE => RETURN [end] -- position is one beyond D	      ELSE IF token = end AND c = t1 AND (oldc = 'L OR oldc = 'C) THEN NULL -- searching backwards	      ELSE		RETURN [IF c = t1 THEN token ELSE matchToken];	    EXITS	      eof => {position ¬ position + 1; RETURN [end]}; -- E,N,D,<EOF> encountered!  Not legal MESA, but it matches!  Fudge with position a little bit	    END;	  ENDLOOP;	END;      ENDLOOP;    EXITS      abort => RETURN [notFound];    END; « relies on the fortuitous fact that the reverse token strings have no common prefixes! »    SearchBackwardsForAnyToken: PROCEDURE RETURNS [tokenFound: Tokens] =      BEGIN ENABLE SearchFailed => GOTO abort;        c: CHARACTER ¬ GetChar[];	s: LONG STRING;	DO	  WHILE (tokenFound ¬ 	    SELECT c FROM	      reverseTokenStrings[openCurly][0] => openCurly,	      reverseTokenStrings[do][0] => do,	      reverseTokenStrings[select][0] => select,	      reverseTokenStrings[begin][0] => begin,	      reverseTokenStrings[openParen][0] => openParen,	      reverseTokenStrings[openBracket][0] => openBracket,	      reverseTokenStrings[openEuroComment][0] => openEuroComment,	      reverseTokenStrings[openAngleComment][0] => openAngleComment,	      reverseTokenStrings[closeCurly][0] => closeCurly,	      reverseTokenStrings[endloop][0] => endloop,	      reverseTokenStrings[endcase][0] => endcase,	      reverseTokenStrings[end][0] => end,	      reverseTokenStrings[closeParen][0] => closeParen,	      reverseTokenStrings[closeBracket][0] => closeBracket,	      reverseTokenStrings[closeEuroComment][0] => closeEuroComment,	      reverseTokenStrings[closeAngleComment][0] => closeAngleComment,	    ENDCASE => notFound) = notFound DO	    c ¬ GetChar[];	  ENDLOOP;	  s ¬ reverseTokenStrings[tokenFound];	  FOR i: CARDINAL IN [1..s.length) DO	    IF (c ¬ GetChar[]) # s[i] THEN EXIT;	  REPEAT	      FINISHED => RETURN;	  ENDLOOP;	ENDLOOP;      EXITS	abort => RETURN [notFound];      END;      « if we can't recognize the token reading forward and first char is alpha, then scan to the begining of the word & then try again »     Tokenize: PROCEDURE RETURNS [beginingOfToken: TextSource.Position, tokenFound: Tokens] = {      longestToken: CARDINAL = 7; -- the longest tokenString      click: LONG STRING ¬ [longestToken];      doubleClick: LONG STRING ¬ [longestToken];      clickPosition: TextSource.Position = position+1; -- we're before the first char      doubleClickPosition: TextSource.Position;      FOR i: CARDINAL IN [0..longestToken) DO	String.AppendChar[click, GetChar[ ! SearchFailed => EXIT]];      ENDLOOP;      SetUpSearch[source.scanText[source, clickPosition, word, left], right]; -- back up to start of word      doubleClickPosition ¬ position+1; -- we're before the first char      FOR i: CARDINAL IN [0..longestToken) DO	String.AppendChar[doubleClick, GetChar[ ! SearchFailed => EXIT]];      ENDLOOP;    -- this works because the tokenStrings array is ordered so that prefixes go last      FOR b: LONG POINTER TO LONG STRING ¬ @click, @doubleClick DO	FOR t: Tokens IN [Tokens.FIRST..Tokens.LAST) DO	  s: LONG STRING ¬ tokenStrings[t];	  IF b.length < s.length THEN LOOP; -- we are at the end of the file	  FOR i:CARDINAL IN [0..s.length) DO	    IF b[i] # s[i] THEN EXIT;	  REPEAT	    FINISHED => RETURN [(IF b = @click THEN clickPosition ELSE doubleClickPosition), t];	  ENDLOOP;	ENDLOOP;	IF b = @doubleClick OR click[0] NOT IN ['A..'Z] THEN RETURN [TRASH, notFound];	       ENDLOOP};       -- first, find the token that is selected.    SetUpSearch[start, right];    [startPos, token] ¬ Tokenize[];    « If the selection wasn't a known token (or the selection is longer than that token), then look left until you find a known opening token whose mate we haven't seen yet and use it to match with! This gadget implements "find the closest enclosing `scope' around the current selection" »    IF token = notFound OR selectionLength > tokenStrings[token].length THEN BEGIN      ignoreNextOpener: ARRAY OpenTokens OF CARDINAL ¬ ALL[1];      SetUpSearch[start, left, abortMe];      DO	token ¬ SearchBackwardsForAnyToken[ ! SearchAborted => GOTO abort];	IF token = notFound THEN RETURN [match: notFound, startPos: TRASH, pos: TRASH];	IF token IN CloseTokens THEN {	  openToken: OpenTokens = VAL[ORD[token] - ORD[CloseTokens.FIRST]];	  ignoreNextOpener[openToken] ¬ ignoreNextOpener[openToken]+1;	} ELSE {	  ignoreNextOpener[token] ¬ ignoreNextOpener[token] - 1;	  IF ignoreNextOpener[token] = 0 THEN EXIT; -- he's our man!	};      ENDLOOP;      startPos ¬ position-1; -- beginning of match.  -1 ??? It makes it work.    EXITS      abort => RETURN [match: aborted, startPos: TRASH, pos: TRASH];    END;    IF token IN OpenTokens THEN {      matchToken ¬ VAL[ORD[token] + ORD[CloseTokens.FIRST]];      dir ¬ right;  -- openers match to the right;    } ELSE {      matchToken ¬ VAL[ORD[token] - ORD[CloseTokens.FIRST]];      dir ¬ left;  -- closers match to the left;    };    SetUpSearch[(IF dir = right THEN startPos + tokenStrings[token].length ELSE startPos), dir, abortMe];    « scan text for either another one of our tokens or one of our match tokens.  When we see a match token and count = 0 then we're done. »    count ¬ 1;    WHILE count # 0 DO      SELECT SearchForTwoTokens[token, matchToken ! SearchAborted => GOTO abort] FROM        token => count ¬ count+1;        matchToken => count ¬ count-1;        notFound => RETURN [match: notFound, startPos: TRASH, pos: TRASH];      ENDCASE => ERROR; -- shouldn't happen    REPEAT      abort => RETURN [match: aborted, startPos: TRASH, pos: TRASH];    ENDLOOP;    « done!  We've matched our matchToken and now all we have to do is point pos at position + token length »    pos ¬ position + delta - (IF matchToken = end THEN 1 ELSE 0); -- ends are special    IF dir = left THEN startPos ¬ startPos + tokenStrings[token].length;    match ¬ found;    IF pos < startPos THEN {      temp: TextSource.Position = startPos; -- swap 'em      startPos ¬ pos;      pos ¬ temp;    };  };      AddSymbiote: PUBLIC PROC[sw: Window.Handle] = {    c: DataHandle ¬ zone.NEW[Data ¬ [block: zone.NEW[StringBody[50]]]];    tool: Window.Handle ¬ ToolWindow.WindowForSubwindow[sw];    form: BOOLEAN ¬ FormSW.IsIt[sw];    BEGIN    IF ~TextSW.IsIt[sw] AND ~form THEN GOTO quit;    c.formSW ¬ ToolWindow.CreateSubwindow[tool];    Context.Create[context, c, DestroyContext, c.formSW];    c.sw ¬ sw; c.isFormSW ¬ form;    FormSW.Create[sw: c.formSW, clientItemsProc: MakeForm];    c.oldNotify ¬ TIP.SetNotifyProc[c.formSW, MyNotify];    Symbiote.AttachSymbioteSW[sw, c.formSW, context!      Symbiote.Error => {        SELECT code FROM	  invalidParameters => ErrMsg["Symbiote: invalidParameters"L];	  alreadyExists => ErrMsg["Symbiote: alreadyExists"L];	  doesNotExist => ErrMsg["Symbiote: doesNotExist"L];	  ENDCASE;	GOTO err}];    Menu.Instantiate[editMenu, sw];    EXITS       quit=> ErrMsg["Host subwindow not text or form"L];      err => ToolWindow.Destroy[c.formSW];    END};    FindQuiescentTool: PUBLIC PROC RETURNS [BOOLEAN] = {    ENABLE UNWIND => NULL;    IF prop.tool = NIL THEN RETURN[FALSE];    SELECT ToolWindow.GetState[prop.tool] FROM      inactive => {ToolWindow.Activate[prop.tool]; RETURN[TRUE]};      active => {[] ¬ ToolWindow.Deactivate[prop.tool]; RETURN[TRUE]};      tiny => {ToolWindow.MakeSize[prop.tool, normal];RETURN[TRUE]};      ENDCASE;    RETURN[FALSE]};    MyNotify: TIP.NotifyProc = {    FOR input: TIP.Results ¬ results, input.Rest[] UNTIL input = NIL DO      WITH z: input.First[] SELECT FROM        atom=> SELECT z.a FROM  	  Help, DoIt => EditUtil.ToggleForm[window];	  Editor => [] ¬ FindQuiescentTool[];	  ENDCASE =>{IF Profile.debugging THEN Put.Line[NIL, z.a]; GOTO notMine};	ENDCASE => GOTO notMine;      ENDLOOP;    EXITS notMine => {      c: DataHandle  ¬ Context.Find[context, window];      c.oldNotify[window,results]}};    MakeForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    td: DataHandle ¬ Context.Find[context,sw];    pItems: LONG POINTER TO ARRAY Items OF FormSW.ItemHandle;    items ¬ AllocateItemDescriptor[Items.LAST.ORD + 1];    pItems ¬ LOOPHOLE[BASE[items]];    pItems­ ¬ [      all: CommandItem[tag: "All"L, proc: ReplaceAll, place: newLine],      find: CommandItem[tag: "S"L, proc: DoFind],      findRep: CommandItem[tag: "RS"L, proc: ReplaceFind],      pattern: StringItem[tag:"¬"L, boxWidth:120, string:@td.arg, inHeap:TRUE],      repFind: CommandItem[tag: "SR"L, proc: FindReplace],      replace: CommandItem[tag: "R"L, proc: Replace],      new: StringItem[tag: "¬"L, string: @td.text, inHeap: TRUE],      iRepFind: CommandItem[tag: "SR"L, place: newLine, proc: FindReplace,        invisible: TRUE],      iReplace: CommandItem[tag: "R"L, proc: Replace, invisible: TRUE],      iNew: StringItem[tag: "¬"L, string: @td.text, inHeap: TRUE,        invisible: TRUE]];    RETURN[items: items, freeDesc: TRUE]};  DoFind: FormSW.ProcType = {    td: DataHandle ¬ Context.Find[context,sw];    ClearError[];    IF td = NIL THEN RETURN;    IF String.Length[td.arg] = 0 THEN {      FormSW.SetTypeIn[sw, Items.pattern.ORD, 0];      [] ¬ UserInput.StuffCurrentSelection[sw]};    IF td.isFormSW THEN EditUtil.DoFindInFSW[td.sw, td]    ELSE EditUtil.DoFindInTSW[td.sw, td]};      ReplaceFind: FormSW.ProcType = {    ENABLE EditUtil.CantReplace => GOTO failed;    td: DataHandle ¬ Context.Find[context,sw];    ClearError[];    IF td = NIL THEN RETURN;    IF td.isFormSW THEN        IF prop.confirmReplace THEN {        TIP.NewManager[Window.rootWindow, TIP.mouseTIP, WaitForConfirm];	Process.Detach[FORK EditUtil.ReplaceFindInFSW[td.sw, td]]}      ELSE EditUtil.ReplaceFindInFSW[td.sw, td]    ELSE        IF prop.confirmReplace THEN {        TIP.NewManager[Window.rootWindow, TIP.mouseTIP, WaitForConfirm];	Process.Detach[FORK EditUtil.ReplaceFindInTSW[td.sw, td]]}      ELSE EditUtil.ReplaceFindInTSW[td.sw, td];    EXITS failed => ErrMsg["Replacement not after a search"L]};      FindReplace: FormSW.ProcType = {    td: DataHandle ¬ Context.Find[context,sw];    ClearError[];    IF td = NIL THEN RETURN;    IF td.isFormSW THEN        IF prop.confirmReplace THEN {        TIP.NewManager[Window.rootWindow, TIP.mouseTIP, WaitForConfirm];	Process.Detach[FORK EditUtil.FindReplaceInFSW[td.sw, td]]}      ELSE EditUtil.FindReplaceInFSW[td.sw, td]    ELSE       IF prop.confirmReplace THEN {        TIP.NewManager[Window.rootWindow, TIP.mouseTIP, WaitForConfirm];	Process.Detach[FORK EditUtil.FindReplaceInTSW[td.sw, td]]}      ELSE EditUtil.FindReplaceInTSW[td.sw, td]};    Replace: FormSW.ProcType = {    ENABLE EditUtil.CantReplace => GOTO failed;    td: DataHandle ¬ Context.Find[context,sw];    ClearError[];    IF td = NIL THEN RETURN;    IF td.isFormSW THEN        IF prop.confirmReplace THEN {        TIP.NewManager[Window.rootWindow, TIP.mouseTIP, WaitForConfirm];	Process.Detach[FORK EditUtil.ReplaceInFSW[td.sw, td]]}      ELSE EditUtil.ReplaceInFSW[td.sw, td]    ELSE        IF prop.confirmReplace THEN {        TIP.NewManager[Window.rootWindow, TIP.mouseTIP, WaitForConfirm];	Process.Detach[FORK EditUtil.ReplaceInTSW[td.sw, td]]}      ELSE EditUtil.ReplaceInTSW[td.sw, td];    EXITS failed => ErrMsg["Replacement not after a search"L]};    ReplaceAll: FormSW.ProcType = {    ENABLE EditUtil.CantReplace => GOTO failed;    td: DataHandle ¬ Context.Find[context,sw];    ClearError[];    IF td = NIL THEN RETURN;    IF td.isFormSW THEN       IF prop.confirmReplace THEN {        TIP.NewManager[Window.rootWindow, TIP.mouseTIP, WaitForConfirm];	Process.Detach[FORK EditUtil.ReplaceAllInFSW[td.sw, td]]}      ELSE EditUtil.ReplaceAllInFSW[td.sw, td]    ELSE       IF prop.confirmReplace THEN {        TIP.NewManager[Window.rootWindow, TIP.mouseTIP, WaitForConfirm];	Process.Detach[FORK EditUtil.ReplaceAllInTSW[td.sw, td]]}      ELSE EditUtil.ReplaceAllInTSW[td.sw, td];    EXITS failed => ErrMsg["Replacement not after a search"L]};    DestroyContext: PROC[c: DataHandle, w: Window.Handle] = {    c.pattern ¬ EditOps.FreePat[c.pattern];    c.oldNotify ¬ TIP.SetNotifyProc[c.formSW, c.oldNotify];    IF c.block # NIL THEN zone.FREE[@c.block];    zone.FREE[@c]};    CommandType: TYPE = {getDefault, setDefault};    GetEm: FormSW.ProcType = {    prop­ ¬ defaultProp­;    FormSW.Display[prop.formSW]};    SetEm: FormSW.ProcType = {defaultProp­ ¬ prop­};    CommandForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    pItems: LONG POINTER TO ARRAY CommandType OF FormSW.ItemHandle;    items ¬ FormSW.AllocateItemDescriptor[CommandType.LAST.ORD + 1];    pItems ¬ LOOPHOLE[BASE[items]];    pItems­ ¬ [      getDefault: CommandItem[tag: "GetDefault"L, place: newLine, proc: GetEm],      setDefault: CommandItem[tag: "SetDefault"L, proc: SetEm]]};  PropForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    pItems: LONG POINTER TO ARRAY PItems OF FormSW.ItemHandle;    scopeEnum: ARRAY CARDINAL[0..2] OF FormSW.Enumerated ¬ [      ["all"L, ScopeType.entire] ,["rest"L, ScopeType.rest],      ["selection"L, ScopeType.selection]];    interpretEnum: ARRAY CARDINAL[0..1] OF FormSW.Enumerated ¬ [      ["pattern"L, Interpret.pattern] ,["literal"L, Interpret.literal]];    contextEnum: ARRAY CARDINAL[0..1] OF FormSW.Enumerated ¬ [      ["anywhere"L, MContext.anywhere] ,["words"L, MContext.words]];    items ¬ FormSW.AllocateItemDescriptor[PItems.LAST.ORD + 1];    pItems ¬ LOOPHOLE[BASE[items]];    pItems­ ¬ [      scope: EnumeratedItem[tag: "Scope"L, place: newLine, value: @prop.scope,        choices: DESCRIPTOR[scopeEnum], feedback: all],      interpret: EnumeratedItem[tag: "Interpret match as"L, place: newLine,         value: @prop.interpret, choices: DESCRIPTOR[interpretEnum], feedback:all],      context: EnumeratedItem[tag: "Context of match"L, place: newLine,         value: @prop.context, choices: DESCRIPTOR[contextEnum], feedback:all],      case: BooleanItem[tag: "Ignore Case", drawBox: TRUE, place: newLine,         switch:@prop.ignoreCase],      confirm: BooleanItem[tag: "Confirm Replace", drawBox: TRUE,        switch:@prop.confirmReplace],      level: NumberItem[tag: "Level", signed:TRUE, notNegative: TRUE,        value:@prop.level, default: 2, place: newLine]]};    PropSWs: Tool.MakeSWsProc = {    prop.msgSW ¬ Tool.MakeMsgSW[window: window, lines: 2];    prop.formSW ¬ Tool.MakeFormSW[window, PropForm];    prop.commandSW ¬ Tool.MakeFormSW[window, CommandForm];    defaultProp­ ¬ prop­};    Transition: ToolWindow.TransitionProcType = {    SELECT TRUE FROM      old = inactive =>NULL;      new = inactive => {prop.msgSW ¬ prop.formSW ¬ prop.commandSW ¬ NIL};      ENDCASE};  Init: PROC = {    userCm: CmFile.Handle ¬ NIL;    entry, value: LONG STRING ¬ NIL;    s: LONG STRING ¬ String.CopyToNewString["Editor of "L, zone, 30];    Time.Append[s, Time.Unpack[Runtime.GetBcdTime[]]];    s.length ¬ s.length - 3;  -- gun the seconds    START EditUtil.EditUtilImplA;    START EditUtil.EditUtilImplB;    Help ¬ Atom.MakeAtom["Help"L];    Editor ¬ Atom.MakeAtom["Editor"L];    DoIt ¬ Atom.MakeAtom["DoIt"L];    pointUp ¬ Atom.MakeAtom["PointUp"L];    adjustUp ¬ Atom.MakeAtom["AdjustUp"L];    Abort ¬ Atom.MakeAtom["Abort"L];        prop ¬ zone.NEW[EditUtil.PropData ¬ []];    IF (userCm ¬ CmFile.UserDotCmOpen [ ! CmFile.Error => CONTINUE]) # NIL AND CmFile.FindSection [userCm, "Editor"L] THEN       DO ENABLE UNWIND => {          entry ¬ CmFile.FreeString[entry];	  value ¬ CmFile.FreeString[value]};	[entry, value] ¬ CmFile.NextItem[userCm];	IF entry = NIL THEN EXIT;	SELECT TRUE FROM	  String.Equivalent["Scope"L, entry] =>	    prop.scope ¬ SELECT TRUE FROM	      String.Equivalent["rest"L, value] => rest,	      String.Equivalent["selection"L, value] => selection,	      ENDCASE => entire;	  String.Equivalent["Interpret"L, entry] =>	    prop.interpret ¬ IF String.Equivalent["literal"L, value] THEN literal ELSE pattern;	  String.Equivalent["Context"L, entry] =>	    prop.context ¬ IF String.Equivalent["words"L, value] THEN words ELSE anywhere;	  String.Equivalent["IgnoreCase"L, entry] =>	    prop.ignoreCase ¬ IF String.Equivalent["TRUE"L, value] THEN TRUE ELSE FALSE;	  String.Equivalent["ConfirmReplace"L, entry] =>	    prop.confirmReplace ¬ IF String.Equivalent["TRUE"L, value] THEN TRUE ELSE FALSE;	  String.Equivalent["Level"L, entry] =>	      IF value # NIL THEN prop.level ¬ String.StringToNumber[value ! String.InvalidNumber => CONTINUE];	  ENDCASE;	entry ¬ CmFile.FreeString[entry];	value ¬ CmFile.FreeString[value];        ENDLOOP;    IF userCm # NIL THEN [] ¬ CmFile.Close[userCm];    defaultProp ¬ zone.NEW[EditUtil.PropData ¬ prop­];    blanks ¬ zone.NEW[StringBody[50]];    blanks.length ¬ 0;    MakeMenu[];    prop.tool ¬ Tool.Create[      name: s, makeSWsProc: PropSWs, cmSection: "Editor"L,      tinyName1: "Editor"L, initialBox: [place:[x:768,y:30],dims:[w:256,h:163]],      clientTransition: Transition];    zone.FREE[@s];    };      Init[];    }..LOGDWR    	18-Oct-84 10:28:23 Redesigned MatchingDWR    	14-Feb-85 14:46:54 Redesigned at again, after merging in Poskanzer's & Hamilton's additions.DWR    	 1-Apr-85 11:16:26 changed LoadBlock[] a little bit.DWR	18-Jul-86 10:43:00 UnNest can leave insertion beyond EOF.  Fixed it.DWR	18-Jul-86 11:19:40 Detaching Edit symbiote should be done from symbiote window
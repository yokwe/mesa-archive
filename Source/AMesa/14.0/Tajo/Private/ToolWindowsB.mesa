-- Copyright (C) 1981, 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- File: ToolWindowsB.mesa - last edit:-- PXK    ,	12-Jan-84  9:41:28-- Mark,	22-May-81 11:59:44-- JGS,		20-Nov-81 16:50:34-- SXS   ,	 1-Oct-82 17:36:07-- BGY     ,	22-Feb-83 16:10:30-- AXD    ,	20-Jul-84 14:36:47-- CXH   ,	18-Jan-83 18:19:23-- DWR    	15-Oct-84 15:38:45DIRECTORY  Context: TYPE USING [Create, Destroy, Find, Type, UniqueType],  Event: TYPE USING [toolWindow],  EventTypes: TYPE USING [activate, createTool, deactivate],  Heap: TYPE USING [systemZone],  Menu: TYPE USING [Handle, Instantiate],  Space: TYPE USING [ScratchMap, Unmap],  SpecialWindow: TYPE USING [],  String: TYPE USING [AppendString, CopyToNewString, Empty, Length, Replace],  Supervisor: TYPE USING [EnumerationAborted, NotifyDirectSubsystems],  TajoMisc: TYPE USING [FindClippingWindow],  TajoOps: TYPE USING [    AllocateWindow, DestroyWindow, tinyDims, tinyHeight, tinyWidth],  TIP: TYPE USING [CreateClient, globalTable],  ToolWindow: TYPE USING [    AdjustProcType, Box, BoxProcType, DisplayProcType, DrawNameFrame,    EnumerateSWProcType,     Handle, LimitProcType, nullBox, OnOff, Place, Size,    StandardLimitProc, State, TransitionProcType],  ToolWindowOps: TYPE USING [    ClippingBox, DrawClippingWindow, GrowWindow,    PutOnDeactiveMenu, SetClippingBox, SplitName, Stuff,    StuffObject, TakeOffDeactiveMenu, tip, TIPMe, Zoomed, ZoomedObject],  UserTerminal: TYPE USING [screenHeight, screenWidth],  Window: TYPE USING [    Box, Dims, Error, GetBox, GetChild, GetParent, GetSibling, Gravity, Handle,    InitializeWindow, InsertIntoTree, InvalidateBox, IsDescendantOfRoot,     IsPlaceInBox, nullBox, Place, RemoveFromTree, rootWindow, SetChild,    SetParent, SetSibling, SlideAndSize, Validate, ValidateTree],  WindowFont: TYPE USING [FontHeight];ToolWindowsB: PROGRAM  IMPORTS    Context, Event, Heap, Menu, Space, String, Supervisor, TajoMisc,    TajoOps, ToolWindow, ToolWindowOps, TIP, UserTerminal, WindowFont, Window  EXPORTS SpecialWindow, ToolWindow, ToolWindowOps =  BEGIN OPEN ToolWindow, ToolWindowOps;  -- public data  tiny: PUBLIC Context.Type ¬ Context.UniqueType[];  stuff: PUBLIC Context.Type ¬ Context.UniqueType[];  zoomed: PUBLIC Context.Type ¬ Context.UniqueType[];  -- own data  tinyHeight: INTEGER = TajoOps.tinyHeight;  tinyWidth: INTEGER = TajoOps.tinyWidth;  tinyDims: Window.Dims = TajoOps.tinyDims;  defWidth: CARDINAL = 512;  defHeight: CARDINAL = 350;  nextNormal: Window.Place ¬ [x: LAST[INTEGER], y: 0];  nextTiny: Window.Place ¬ [x: LAST[INTEGER], y: 0];  nextTinyBoxOwn, nextTinyBox: BoxProcType ¬    IF UserTerminal.screenWidth > UserTerminal.screenHeight THEN    NextTinyBoxHorizontal ELSE NextTinyBoxVertical;  nextNormalBox: BoxProcType ¬ NextNormalBox;  -- Procedures  Activate: PUBLIC PROC [window: Window.Handle] = {    tool: Stuff = Context.Find[stuff, window];    SELECT tool.state FROM      active => NULL;      tiny => MakeSize[window, normal];      inactive => {        TakeOffDeactiveMenu[window, tool];        tool.state ¬ active;        IF tool.transition # NIL THEN {          AddClippingWindow[window];          tool.transition[window: window, old: inactive, new: active]};        SetClippingBox[window, window.GetChild[], tool.gravity];        Supervisor.NotifyDirectSubsystems[          event: EventTypes.activate, which: clients, subsystem: Event.toolWindow,          eventData: window];        Show[window]};      ENDCASE => --EXHAUSTED-- NULL};  AddClippingWindow: PROC [window: Window.Handle] = {    clipping: Window.Handle = TajoOps.AllocateWindow[];    clipping.InitializeWindow[      parent: window, clearingRequired: FALSE, display: DrawClippingWindow,      box: ToolWindow.nullBox];    [] ¬ window.SetChild[clipping];    TIP.CreateClient[clipping, TIP.globalTable[root]];    Menu.Instantiate[NIL, window]};  Create: PUBLIC PROC [    name: LONG STRING, adjust: AdjustProcType, transition: TransitionProcType,    box: Window.Box ¬ nullBox, limit: LimitProcType ¬ StandardLimitProc,    initialState: State ¬ active, named: BOOLEAN ¬ TRUE,    gravity: Window.Gravity ¬ nw] RETURNS [Window.Handle] = {    window: Window.Handle = TajoOps.AllocateWindow[bitmapUnder: TRUE];    tool: Stuff;    IF box = nullBox THEN box ¬ nextNormalBox[];    window.InitializeWindow[      display: DrawNameFrame, box: box, clearingRequired: FALSE, under: TRUE,       cookieCutter: FALSE];    window.SlideAndSize[limit[window, box], gravity];    tool ¬ Heap.systemZone.NEW[StuffObject ¬ [      name: String.CopyToNewString[name, Heap.systemZone], limitProc: limit,      adjustProc: adjust, transition: transition, gravity: gravity,       size: normal, -- PutUpTiny depends on this      state: initialState, named: named, implicitTinySpace: FALSE, tiny1: NIL,      tiny2: NIL, tinyBox: nextTinyBox[], clippingWindow: NIL]];    Context.Create[stuff, tool, DestroyStuff, window];    IF initialState # inactive THEN AddClippingWindow[window];    SELECT initialState FROM      tiny => window.SlideAndSize[PutUpTiny[window, tool, box], nw];      inactive => PutOnDeactiveMenu[window, tool];      ENDCASE;    SetClippingBox[window, window.GetChild[], gravity];    TIP.CreateClient[window, ToolWindowOps.tip, ToolWindowOps.TIPMe];    Supervisor.NotifyDirectSubsystems[      event: EventTypes.createTool, which: clients, subsystem: Event.toolWindow,      eventData: window];    RETURN[window]};  CreateSubwindow: PUBLIC PROC [    parent: Window.Handle, display: DisplayProcType ¬ LOOPHOLE[0],    box: Window.Box ¬ nullBox, gravity: Window.Gravity ¬ nw]    RETURNS [Window.Handle] = {    window: Window.Handle = TajoOps.AllocateWindow[];    window.InitializeWindow[box: box, display: display];    EnlinkSubwindow[parent, window, NIL];    TIP.CreateClient[window, TIP.globalTable[root]];    RETURN[window]};  Deactivate: PUBLIC PROC [window: Window.Handle]     RETURNS [aborted: BOOLEAN ¬ FALSE] = {    tool: Stuff = Context.Find[stuff, window];    IF tool.state = inactive THEN RETURN;    Supervisor.NotifyDirectSubsystems[      event: EventTypes.deactivate, which: clients, subsystem: Event.toolWindow,      eventData: window ! Supervisor.EnumerationAborted =>        GOTO aborted];    Hide[window];    IF tool.transition # NIL THEN      tool.transition[window: window, old: tool.state, new: inactive];    IF tool.state = tiny THEN window.SlideAndSize[TakeDownTiny[window, tool], nw];    tool.state ¬ inactive;    IF tool.transition # NIL THEN {      Destroy[TajoMisc.FindClippingWindow[window]]; [] ¬ window.SetChild[NIL]};    PutOnDeactiveMenu[window, tool];    EXITS aborted => RETURN[TRUE]};  Destroy: PUBLIC PROC [window: Window.Handle] = {    Hide[window]; TajoOps.DestroyWindow[window]};  DestroyStuff: PROC [tool: Stuff, window: Window.Handle] = {    TakeOffDeactiveMenu[window, tool];    Heap.systemZone.FREE[@tool.name];    Heap.systemZone.FREE[@tool.tiny1];    Heap.systemZone.FREE[@tool.tiny2];    Heap.systemZone.FREE[@tool]};  DelinkSubwindow: PUBLIC PROC [window: Window.Handle] = {    window.RemoveFromTree[];    [] ¬ window.SetParent[NIL];    Window.rootWindow.ValidateTree[]};  EnlinkSubwindow: PUBLIC PROC [parent, child, youngerSibling: Window.Handle] = {    tool: Stuff = Context.Find[stuff, parent];    clipping: Window.Handle;    IF parent = NIL THEN clipping ¬ NIL    ELSE      clipping ¬        SELECT tool.size FROM          tiny => tool.clippingWindow          ENDCASE => parent.GetChild[];    [] ¬ child.SetParent[clipping];    [] ¬ child.SetSibling[youngerSibling];    IF parent # NIL THEN {      child.InsertIntoTree[];      IF parent.IsDescendantOfRoot[] THEN parent.ValidateTree[]}};     EnumerateSWs: PUBLIC PROC [window: Window.Handle, proc: EnumerateSWProcType] = {    tool: Stuff = Context.Find[stuff, window];    clipping: Window.Handle =      SELECT tool.size FROM        tiny => tool.clippingWindow        ENDCASE => window.GetChild[];    IF clipping = NIL THEN RETURN;    FOR sw: Window.Handle ¬ clipping.GetChild[], sw.GetSibling[] UNTIL sw = NIL DO      IF proc[window, sw] THEN EXIT ENDLOOP};  GetAdjustProc: PUBLIC PROC [window: Handle] RETURNS [AdjustProcType] = {    tool: Stuff = Context.Find[stuff, window];    RETURN [IF tool # NIL THEN tool.adjustProc ELSE NIL]};  GetBox: PUBLIC PROC [window: Window.Handle] RETURNS [Box] = {    tool: Stuff = Context.Find[stuff, window];    RETURN[IF tool = NIL THEN Window.nullBox ELSE      SELECT tool.state FROM        inactive,        active => window.GetBox[],        tiny => tool.tinyBox,        ENDCASE => Window.nullBox]};  GetName: PUBLIC PROC [window: Window.Handle] RETURNS [name: LONG STRING] = {    tool: Stuff = Context.Find[stuff, window];    IF tool = NIL THEN RETURN[NIL];    name ¬ String.CopyToNewString[tool.name, Heap.systemZone]};  GetState: PUBLIC PROC [window: Window.Handle] RETURNS [state: State] = {    tool: Stuff = Context.Find[stuff, window];    RETURN[IF tool # NIL THEN tool.state ELSE inactive]};  GetTinyPlace: PUBLIC PROC [window: Window.Handle] RETURNS [place: Place] = {    tool: Stuff = Context.Find[stuff, window];    RETURN[IF tool = NIL THEN [0, 0] ELSE      SELECT tool.state FROM        tiny => window.GetBox[].place,        inactive,        active => tool.tinyBox.place,        ENDCASE => [0, 0]]};  GetGravity: PUBLIC PROC [window: Window.Handle]    RETURNS [gravity: Window.Gravity] = {    tool: Stuff = Context.Find[stuff, window];    RETURN[IF tool = NIL THEN nw ELSE tool.gravity]};  SetGravity: PUBLIC PROC [window: Window.Handle, gravity: Window.Gravity] = {    tool: Stuff = Context.Find[stuff, window];    IF tool # NIL THEN tool.gravity ¬ gravity};  Hide: PUBLIC PROC [window: Window.Handle] = {    parent: Window.Handle = window.GetParent[];    IF parent # NIL THEN {      window.RemoveFromTree[ !        Window.Error => IF code = windowNotChildOfParent THEN CONTINUE];      parent.ValidateTree[]}};  IsPlaceInWindow: PUBLIC PROC [place: Window.Place, window: Window.Handle]    RETURNS [BOOLEAN] = {    RETURN Window.IsPlaceInBox[place, [[0, 0], window.GetBox.dims]]};      << This procedure is only of use if the size of bitmap can change.  LimitAllWindowBoxes: PUBLIC PROC = {    window: Window.Handle;    box: Window.Box;    tool: Stuff;    FOR window ¬ Window.rootWindow.GetChild[], window.GetSibling[] UNTIL window =      NIL DO      tool ¬ Context.Find[stuff, window];      IF tool = NIL THEN LOOP;      IF (box ¬ tool.limitProc[window, window.GetBox]) # window.GetBox[] THEN        GrowWindow[	  window: window, box: box, stack: same, 	  gravity: tool.gravity, tool: tool, clip: NIL];      ENDLOOP};  >>  SetAdjustProc: PUBLIC PROC [window: Handle, proc: AdjustProcType]     RETURNS [old: AdjustProcType] = {    tool: Stuff = Context.Find[stuff, window];    IF tool = NIL THEN RETURN;    old ¬ tool.adjustProc;    tool.adjustProc ¬ proc};  SetBoxAllocator: PUBLIC PROC [normal, tiny: BoxProcType] = {    nextNormalBox ¬ IF normal = NIL THEN NextNormalBox ELSE normal;    nextTinyBox ¬ IF tiny = NIL THEN nextTinyBoxOwn ELSE tiny};  SetLimitProc: PUBLIC PROC [window: Window.Handle,  proc: LimitProcType]     RETURNS [old: LimitProcType] = {    tool: Stuff = Context.Find[stuff, window];    IF tool = NIL THEN RETURN;    old ¬ tool.limitProc;    tool.limitProc ¬ proc};  GetLimitProc: PUBLIC PROC [window: Window.Handle]    RETURNS [LimitProcType] = {    tool: Stuff = Context.Find[stuff, window];    RETURN [IF tool = NIL THEN NIL ELSE tool.limitProc]};  SetName: PUBLIC PROC [window: Window.Handle, name: LONG STRING] =    BEGIN    tool: Stuff = Context.Find[stuff, window];    IF tool = NIL THEN RETURN;<<   The following piece of code is to get around the problem that String.Replace   does not reuse the string body if the new string will fit.   The actual problem is that setting the name of the tool is not MONITORed   against the display.>>    IF String.Length[tool.name] > name.length THEN {	tool.name.length ¬ 0; String.AppendString[tool.name, name]}    ELSE String.Replace[to: @tool.name, from: name, z: Heap.systemZone];    IF tool.state = inactive THEN {      TakeOffDeactiveMenu[window, tool]; PutOnDeactiveMenu[window, tool]}    ELSE {      window.InvalidateBox[        [[0, 0], [window.GetBox[].dims.w, WindowFont.FontHeight[]]],        isDirty];      window.Validate[]};    END;      SetNameStripe: PUBLIC PROC [window: Window.Handle, onOff: OnOff] = {    tool: Stuff = Context.Find[stuff, window];    new: BOOLEAN = (onOff = on);    IF tool = NIL THEN RETURN;    IF tool.named # new THEN {      tool.named ¬ new;      IF tool.state = active THEN ToolWindowOps.GrowWindow[        window: window, box: window.GetBox[], stack: same, 	gravity: tool.gravity, tool: tool, clip: NIL]}};  GetNameStripe: PUBLIC PROC [window: Window.Handle] RETURNS [OnOff] = {    tool: Stuff = Context.Find[stuff, window];    RETURN [IF tool = NIL OR ~tool.named THEN off ELSE on]};  SetTinyName: PUBLIC PROC [    window: Window.Handle, name, name2: LONG STRING ¬ NIL,    implicitSpace: BOOLEAN ¬ TRUE] = {    tool: Stuff = Context.Find[stuff, window];    IF tool = NIL THEN RETURN;    Heap.systemZone.FREE[@tool.tiny1];    Heap.systemZone.FREE[@tool.tiny2];    IF String.Empty[name2] THEN      [tool.tiny1, tool.tiny2] ¬ SplitName[name, FALSE]    ELSE {      tool.tiny1 ¬ String.CopyToNewString[name, Heap.systemZone];      tool.tiny2 ¬ String.CopyToNewString[name2, Heap.systemZone]};    IF tool.size = tiny THEN {      window.InvalidateBox[[[0, 0], tinyDims]]; window.Validate[]}};  SetTransitionProc: PUBLIC PROC [    window: Window.Handle, proc: TransitionProcType]    RETURNS [oldProc: TransitionProcType] = {    tool: Stuff = Context.Find[stuff, window];    IF tool = NIL THEN RETURN[proc];    oldProc ¬ tool.transition;    tool.transition ¬ proc};  GetTransitionProc: PUBLIC PROC [window: Window.Handle]    RETURNS [TransitionProcType] = {    tool: Stuff = Context.Find[stuff, window];    RETURN [IF tool = NIL THEN NIL ELSE tool.transition]};  Show: PUBLIC PROC [window: Window.Handle] = {    tool: Stuff = Context.Find[stuff, window];    IF window.IsDescendantOfRoot[] THEN RETURN;    IF tool = NIL THEN RETURN;    IF tool.adjustProc # NIL THEN      tool.adjustProc[        window: window,        box: [        place: [0, 0],        dims: ClippingBox[        window, IF tool.size = tiny THEN tool.tinyBox ELSE window.GetBox[]].dims],        when: after];    [] ¬ window.SetParent[Window.rootWindow];    [] ¬ window.SetSibling[Window.rootWindow.GetChild[]];    window.InsertIntoTree[];    Window.rootWindow.ValidateTree[]};  WindowForSubwindow: PUBLIC PROC [sw: Window.Handle]    RETURNS [window: Window.Handle] = {    IF sw = NIL OR sw.GetParent[] = NIL THEN window ¬ NIL    ELSE window ¬ sw.GetParent[].GetParent[]};  -- Size Setting  TakeDownTiny: PROC [w: Window.Handle, tool: Stuff]    RETURNS [box: Window.Box] = {    box ¬ tool.limitProc[w, tool.tinyBox];    tool.tinyBox ¬ w.GetBox[];    tool.size ¬ normal};  TakeDownZoomed: PUBLIC PROC [w: Window.Handle, tool: Stuff]    RETURNS [box: Window.Box] = {    z: ToolWindowOps.Zoomed = Context.Find[zoomed, w];    IF z = NIL THEN RETURN[w.GetBox[]];    box ¬ tool.limitProc[w, z.box];    Context.Destroy[zoomed, w];    tool.size ¬ normal};  PutUpTiny: PROC [w: Window.Handle, tool: Stuff, obox: Window.Box]    RETURNS [box: Window.Box] = {    tool.clippingWindow ¬ w.GetChild[];    tool.size ¬ tiny;    w.GetChild.RemoveFromTree[];    box ¬ tool.limitProc[w, tool.tinyBox];    tool.tinyBox ¬ obox};  PutUpZoomed: PROC [w: Window.Handle, tool: Stuff, obox: Window.Box]    RETURNS [box: Window.Box] = {    z: Zoomed = MakeZoomedContext[w];    box ¬ tool.limitProc[w, [[0, 0], Window.rootWindow.GetBox[].dims]];    z.box ¬ obox;    tool.size ¬ zoomed};  MakeSize: PUBLIC PROC [window: Window.Handle, size: Size] = {    tool: Stuff = Context.Find[stuff, window];    box: Window.Box;    oldState: State;    oldSize: Size;    IF tool = NIL THEN RETURN;    IF tool.size = size THEN RETURN;    oldState ¬ tool.state;    IF size = tiny AND tool.transition # NIL THEN      tool.transition[window: window, old: active, new: tiny];    SELECT (oldSize ¬ tool.size) FROM      tiny => box ¬ TakeDownTiny[window, tool];      zoomed => box ¬ TakeDownZoomed[window, tool];      ENDCASE => box ¬ window.GetBox[];    SELECT size FROM      tiny => box ¬ PutUpTiny[window, tool, box];      zoomed => box ¬ PutUpZoomed[window, tool, box];      ENDCASE;    IF size = tiny THEN tool.state ¬ tiny    ELSE {      tool.state ¬ active;      IF oldState # active AND tool.transition # NIL THEN        tool.transition[window: window, old: oldState, new: active]};    GrowWindow[      window: window, box: box, stack: IF tool.size > oldSize THEN top ELSE same,      gravity: IF oldSize = tiny OR tool.size = tiny THEN xxx ELSE tool.gravity,      tool: tool,       clip: IF oldSize = tiny THEN tool.clippingWindow ELSE NIL]};  -- exported to SpecialWindow      GetPages: PUBLIC PROC [pages: CARDINAL] RETURNS [LONG POINTER] = {    RETURN[Space.ScratchMap[pages]]};  FreePages: PUBLIC PROC [ptr: LONG POINTER] = {[] ¬ Space.Unmap[ptr]};  -- private procedures      DestroyZoomed: PROC [z: Zoomed, window: Window.Handle] = {    Heap.systemZone.FREE[@z]};  MakeZoomedContext: PUBLIC PROC [window: Window.Handle]    RETURNS [z: Zoomed] = {    z ¬ Heap.systemZone.NEW[ZoomedObject];    Context.Create[zoomed, z, DestroyZoomed, window]};  NextNormalBox: BoxProcType = {    IF nextNormal.x = INTEGER.LAST THEN      nextNormal ¬ [        Window.rootWindow.GetBox.dims.w - defWidth - tinyWidth,        tinyHeight*2 + 1];    box ¬ [place: nextNormal, dims: [w: defWidth, h: defHeight]];    nextNormal.x ¬ nextNormal.x - 15;    nextNormal.y ¬ nextNormal.y + 15};  NextTinyBoxVertical: BoxProcType = {    IF nextTiny.x = INTEGER.LAST THEN      nextTiny ¬ [Window.rootWindow.GetBox.dims.w - tinyWidth, tinyHeight];    box ¬ [place: nextTiny, dims: tinyDims];    nextTiny.y ¬ nextTiny.y + tinyHeight;    IF nextTiny.y + tinyHeight > Window.rootWindow.GetBox.dims.h THEN {      nextTiny.y ¬ tinyHeight; nextTiny.x ¬ nextTiny.x - tinyWidth}};  NextTinyBoxHorizontal: BoxProcType = {    IF nextTiny.x = INTEGER.LAST THEN      nextTiny ¬ [0, Window.rootWindow.GetBox.dims.h - tinyHeight];    box ¬ [place: nextTiny, dims: tinyDims];    nextTiny.x ¬ nextTiny.x + tinyWidth;    IF nextTiny.x + tinyWidth > Window.rootWindow.GetBox.dims.w THEN {      nextTiny.x ¬ 0; nextTiny.y ¬ nextTiny.y - tinyHeight}};  END.  
-- Copyright (C) 1981, 1982  by Xerox Corporation. All rights reserved. -- File: MsgSWsA.mesa; last modified:-- PXK    	28-Jan-82 11:10:08-- Mark,	May 6, 1980 11:25 PM-- SXW   	 9-Jul-81 23:49:13-- JGS		 3-Sep-81 18:11:02-- BGY     	 22-Sep-82 17:04:58-- AXD    	 12-Nov-82 11:52:14-- DWR    	24-Apr-85 10:28:40DIRECTORY  Ascii USING [CR],  Context USING [Create, Destroy, Find, SimpleDestroyProc, Type, UniqueType],  Heap USING [systemZone],  MsgSW USING [defaultOptions, ErrorCode, Severity],  String USING [EmptyString, FreeString, Length, SubString],  StringSW USING [Create, Destroy, GetString],  TextSource USING [Position],  TextSW USING [    BlinkingCaret, DeleteText, ForceOutput, GetEOF, InsertChar, InsertString, Options, PositionIsVisible],  TextSWExtraExtra USING [SetPositionWithOverRide],  ToolWindow USING [GetInactiveName, WindowForSubwindow],  UserInput USING [    GetDefaultWindow, NopStringProc, SetStringIn, SetStringOut, StringOut,    StringProcType],  Window USING [Handle];MsgSWsA: MONITOR  IMPORTS Context, Heap, String, StringSW, TextSW, TextSWExtraExtra, ToolWindow, UserInput  EXPORTS MsgSW =  BEGIN  -- Global Data  context: Context.Type ¬ Context.UniqueType[];  Object: TYPE = RECORD [    clearIt: BOOLEAN,    severity: MsgSW.Severity,    lines: CARDINAL,    minLines: CARDINAL];  Handle: TYPE = LONG POINTER TO Object;    z: UNCOUNTED ZONE = Heap.systemZone;  -- Errors  Error: PUBLIC SIGNAL [code: MsgSW.ErrorCode] = CODE;  -- Exported Procedures  AppendString: PUBLIC ENTRY UserInput.StringProcType =    BEGIN    ENABLE UNWIND => NULL;    InternalPost[      sw: window, string: string, severity: info, prefix: FALSE, logSW: NIL,      addCR: FALSE];    END;  ContextType: PUBLIC PROCEDURE RETURNS [Context.Type] =    BEGIN RETURN[context]; END;  Clear: PUBLIC ENTRY PROCEDURE [sw: Window.Handle] =    BEGIN    ENABLE UNWIND => NULL;    mch: Handle ¬ LocalFind[sw];    ReallyClear[mch, sw];    END;  Create: PUBLIC ENTRY PROCEDURE [    sw: Window.Handle, lines: CARDINAL ¬ 1,    options: TextSW.Options ¬ MsgSW.defaultOptions] =    BEGIN    ENABLE UNWIND => NULL;    mch: Handle;    IF sw = NIL THEN RETURN[];    mch ¬ z.NEW[Object];    mch­ ¬ [clearIt: FALSE, severity: info, lines: 0, minLines: lines];    IF options.access # append THEN SIGNAL Error[appendOnly];    StringSW.Create[sw: sw, s: NIL, options: options];    Context.Create[context, mch, Context.SimpleDestroyProc, sw];    [] ¬ UserInput.SetStringIn[window: sw, proc: UserInput.NopStringProc];    [] ¬ UserInput.SetStringOut[window: sw, proc: AppendString];    -- UserInput.SetKeyPNR[sw, keyboard, UserInput.NopKeyPNR];    TextSW.BlinkingCaret[sw, off];    END;  Destroy: PUBLIC ENTRY PROCEDURE [sw: Window.Handle] =    BEGIN    ENABLE UNWIND => NULL;    mch: Handle ¬ LocalFind[sw];    StringSW.Destroy[sw];    Context.Destroy[context, sw];    END;  GetSeverity: PUBLIC ENTRY PROCEDURE [sw: Window.Handle]    RETURNS [severity: MsgSW.Severity] =    BEGIN    ENABLE UNWIND => NULL;    mch: Handle ¬ LocalFind[sw];    RETURN[mch.severity];    END;  IsIt: PUBLIC ENTRY PROCEDURE [sw: Window.Handle] RETURNS [yes: BOOLEAN] =    BEGIN    ENABLE UNWIND => NULL;    mch: Handle ¬ Context.Find[context, sw];    RETURN[IF mch = NIL THEN FALSE ELSE TRUE];    END;  LastLine: PUBLIC ENTRY PROCEDURE [sw: Window.Handle, ss: String.SubString] =    BEGIN    ENABLE UNWIND => NULL;    mch: Handle ¬ LocalFind[sw];    s: LONG STRING;    TextSW.ForceOutput[sw];    s ¬ StringSW.GetString[sw]­;    ss­ ¬ [base: s, offset: 0, length: String.Length[s]];    FOR i: CARDINAL DECREASING IN [0..ss.length) DO      IF s[i] = Ascii.CR THEN {        ss.offset ¬ i + 1; ss.length ¬ ss.length - ss.offset; EXIT};      ENDLOOP;    END;  Post: PUBLIC ENTRY PROCEDURE [    sw: Window.Handle, string: LONG STRING, severity: MsgSW.Severity ¬ info,    prefix: BOOLEAN ¬ TRUE, endOfMsg: BOOLEAN ¬ TRUE] =    BEGIN    ENABLE UNWIND => NULL;    InternalPost[      sw: sw, string: string, severity: severity, prefix: prefix, logSW: NIL,      addCR: endOfMsg];    END;  PostAndLog: PUBLIC ENTRY PROCEDURE [    sw: Window.Handle, string: LONG STRING, severity: MsgSW.Severity ¬ info,    prefix: BOOLEAN ¬ TRUE, endOfMsg: BOOLEAN ¬ TRUE,    logSW: Window.Handle ¬ NIL] =    BEGIN    ENABLE UNWIND => NULL;    InternalPost[      sw: sw, string: string, severity: severity, prefix: prefix,      logSW: IF logSW = NIL THEN UserInput.GetDefaultWindow[] ELSE logSW,      addCR: endOfMsg];    END;  SetSeverity: PUBLIC ENTRY PROCEDURE [    sw: Window.Handle, severity: MsgSW.Severity] =    BEGIN    ENABLE UNWIND => NULL;    mch: Handle ¬ LocalFind[sw];    mch.severity ¬ severity;    END;  -- Private Procedures  InternalPost: INTERNAL PROCEDURE [    sw: Window.Handle, string: LONG STRING, severity: MsgSW.Severity,    prefix: BOOLEAN, logSW: Window.Handle, addCR: BOOLEAN] =    BEGIN    mch: Handle ¬ LocalFind[sw];    cleared, prefixDone, subedOne: BOOLEAN ¬ FALSE;    warningStr: LONG STRING = "Warning: "L;    fatalStr: LONG STRING = "Fatal Error: "L;    «    ScrollUpOneLine: PROCEDURE RETURNS [BOOLEAN] = {      line1: TextSource.Position;      eof: TextSource.Position = TextSW.GetEOF[sw];      GetPosition: PROC RETURNS [p: TextSource.Position] = {        p ¬ TextSW.GetPosition[sw, 1];	RETURN [(IF p = TextSource.nullPosition THEN eof ELSE p)]};      line1 ¬ GetPosition[];      IF line1 IN (0..eof] THEN {	IF mch.lines < mch.minLines - 1 THEN { -- save mch.minLines in the backing store	  mch.lines ¬ mch.lines + 1;	  TextSWExtraExtra.SetPositionWithOverRide[sw, line1, top];  	} ELSE {	  TextSW.DeleteText[sw, 0, line1, FALSE];	  TextSW.ForceOutput[sw]}};      RETURN [line1 # GetPosition[]]}; -- true if something changed »	    IF String.EmptyString[string] THEN RETURN[];    IF mch.clearIt THEN      BEGIN      TextSW.InsertChar[sw, Ascii.CR];      mch.clearIt ¬ FALSE;      cleared ¬ TRUE;      RemoveExcessLines[mch, sw]; -- clean house on newlines.      END;    IF string[string.length - 1] = Ascii.CR THEN      BEGIN string.length ¬ string.length - 1; subedOne ¬ mch.clearIt ¬ TRUE; END    ELSE mch.clearIt ¬ addCR;    IF prefix AND severity # info THEN      BEGIN      IF cleared OR String.EmptyString[StringSW.GetString[sw]­] THEN        TextSW.InsertString[sw, (IF severity = warning THEN warningStr ELSE fatalStr)];      prefixDone ¬ TRUE;      END;    IF ~String.EmptyString[string] THEN TextSW.InsertString[sw, string];«    TextSW.ForceOutput[sw]; »«    WHILE ~TextSW.PositionIsVisible[sw, TextSW.GetEOF[sw]] AND ScrollUpOneLine[]      DO ENDLOOP; -- since one-line windows don't scroll! »«    IF cleared THEN RemoveExcessLines[mch, sw, TextSW.GetPosition[sw, 0]];  -- in case our window is bigger than one line»    IF ~TextSW.PositionIsVisible[sw, TextSW.GetEOF[sw]] THEN      TextSWExtraExtra.SetPositionWithOverRide[sw, TextSW.GetEOF[sw], top];    IF logSW # NIL THEN      BEGIN      IF prefixDone THEN        BEGIN        IF logSW = UserInput.GetDefaultWindow[] THEN  -- add Tool name          BEGIN          toolName: LONG STRING ¬ ToolWindow.GetInactiveName[            ToolWindow.WindowForSubwindow[sw]];          UserInput.StringOut[logSW, toolName];          String.FreeString[z, toolName];          UserInput.StringOut[logSW, " - "L];          END;        UserInput.StringOut[          logSW,          SELECT severity FROM            warning => warningStr,            fatal => fatalStr,            ENDCASE => NIL];        END;      UserInput.StringOut[logSW, string];      IF mch.clearIt THEN {        crStr: STRING ¬ [2];        crStr[0] ¬ Ascii.CR;        crStr.length ¬ 1;        UserInput.StringOut[logSW, crStr]};      END;    mch.severity ¬ severity;    IF subedOne THEN string.length ¬ string.length + 1;    END; «  InternalPost: INTERNAL PROCEDURE [    sw: Window.Handle, string: LONG STRING, severity: MsgSW.Severity,    prefix: BOOLEAN, logSW: Window.Handle, addCR: BOOLEAN] =    BEGIN    i: CARDINAL;    mch: Handle ¬ LocalFind[sw];    cleared, prefixDone, subedOne: BOOLEAN ¬ FALSE;    subStr: String.SubStringDescriptor;    warningStr: LONG STRING = "Warning: "L;    fatalStr: LONG STRING = "Fatal Error: "L;    toolName: LONG STRING;    IF String.EmptyString[string] THEN RETURN[];    IF mch.clearIt THEN      BEGIN      MakeOutputVisible[sw, mch]; -- so that the window will scroll while we print      TextSW.InsertChar[sw: sw, char: Ascii.CR];      mch.clearIt ¬ FALSE;      cleared ¬ TRUE;      END;    IF string[string.length - 1] = Ascii.CR THEN      BEGIN string.length ¬ string.length - 1; subedOne ¬ mch.clearIt ¬ TRUE; END    ELSE mch.clearIt ¬ addCR;    FOR i IN [0..string.length) DO      IF string[i] = Ascii.CR THEN mch.lines ¬ mch.lines + 1; ENDLOOP;    IF mch.clearIt THEN mch.lines ¬ mch.lines + 1;    subStr ¬ [base: string, offset: 0, length: string.length];    IF prefix AND severity # info THEN      BEGIN      TextSW.ForceOutput[sw];      IF cleared OR String.EmptyString[StringSW.GetString[sw]­] THEN        TextSW.InsertString[          sw: sw,          s:          SELECT severity FROM            warning => warningStr,            fatal => fatalStr,            ENDCASE => NIL];      prefixDone ¬ TRUE;      END;    TextSW.InsertSubString[sw: sw, ss: @subStr];    IF logSW # NIL THEN      BEGIN      IF prefixDone THEN        BEGIN        IF logSW = UserInput.GetDefaultWindow[] THEN  -- add Tool name          BEGIN          toolName ¬ ToolWindow.GetInactiveName[            ToolWindow.WindowForSubwindow[sw]];          UserInput.StringOut[logSW, toolName];          String.FreeString[z, toolName];          UserInput.StringOut[logSW, " - "L];          END;        UserInput.StringOut[          logSW,          SELECT severity FROM            warning => warningStr,            fatal => fatalStr,            ENDCASE => NIL];        END;      UserInput.StringOut[logSW, string];      IF mch.clearIt THEN {        crStr: STRING ¬ [2];        crStr[0] ¬ Ascii.CR;        crStr.length ¬ 1;        UserInput.StringOut[logSW, crStr]};      END;    IF subedOne THEN string.length ¬ string.length + 1;    mch.severity ¬ severity;    RemoveExcessLines[mch, sw];    END; »  LocalFind: PROCEDURE [sw: Window.Handle] RETURNS [mch: Handle] =    BEGIN    mch ¬ Context.Find[context, sw];    IF mch = NIL THEN Error[notAMsgSW];    END;«  MakeOutputVisible: PROCEDURE [sw: Window.Handle, mch: Handle] =    BEGIN  -- Position last line to 0 if not visible    pos: TextSource.Position ¬ TextSW.GetEOF[sw];    IF ~TextSW.PositionIsVisible[sw, pos] THEN TextSW.SetPosition[sw, pos];--    TextSW.DeleteText[sw: sw, pos: 0, count: TextSW.GetPosition[sw, 1], keepTrash: FALSE];    END; »   ReallyClear: INTERNAL PROCEDURE [mch: Handle, sw: Window.Handle] =    BEGIN    nChars: CARDINAL;    IF mch = NIL THEN RETURN;    TextSW.ForceOutput[sw];    IF (nChars ¬ String.Length[StringSW.GetString[sw]­]) = 0 THEN RETURN;    TextSW.DeleteText[sw: sw, pos: 0, count: nChars, keepTrash: FALSE];    mch.clearIt ¬ FALSE;    mch.lines ¬ 0;    mch.severity ¬ info;    END;-- called after you have printed a CR and are printing on the new line  RemoveExcessLines: INTERNAL PROCEDURE [mch: Handle, sw: Window.Handle] =    BEGIN    length: CARDINAL = CARDINAL[TextSW.GetEOF[sw]];    charsPerLine: CARDINAL = 64;  -- very rough estimates here!    worthSaving: CARDINAL = (mch.minLines + 1) * charsPerLine;    IF length > worthSaving THEN      TextSW.DeleteText[sw: sw, pos: 0, count: (length - worthSaving), keepTrash: FALSE]; «-- doesn't work because the string source is modified by HeraldWindow and MsgSW at the same time.  Hence you can crash in this loop when s gets trashed.    crCount: CARDINAL ¬ 0;     s: LONG STRING ¬ StringSW.GetString[sw]­;    IF line0 = 0 OR line0 = TextSource.nullPosition THEN RETURN;    FOR i: LONG CARDINAL DECREASING IN [0..line0) DO      IF s[CARDINAL[i]] = Ascii.CR THEN	IF (crCount ¬ crCount + 1) >= mch.minLines THEN {	  TextSW.DeleteText[sw: sw, pos: 0, count: i + 1, keepTrash: FALSE];	  RETURN;	};    ENDLOOP;»    END;       -- Mainline code  END.LOGDWR    	23-Feb-85 13:13:47 Patched up InternalPost because it didn't work with my new bootfile.DWR    	 1-Apr-85 11:22:27 Made it faster by not calling RemoveExcessLines[] & ForceOutput so often.DWR    	15-Apr-85 11:34:38 Copied string in RemoveExcessLines[] to try and avoid a race condition that exists between processes writing to a StringSW.  Pretty gross.  I've only lowered the odds a little.DWR    	18-Apr-85 18:08:39 redesigned RemoveExcessLines[] not to look at the string at all!DWR    	23-Apr-85 18:31:20 added PositionIsVisible check to InternalPost
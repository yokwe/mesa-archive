-- Copyright (C) 1981, 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- File: TextSWsD.mesa - last edited by: -- SXW   	 9-Jul-81 17:53:04-- Mark		24-Jul-81 16:31:14-- JGS		21-Aug-81  9:34:55-- PXK    	 4-Oct-82 10:47:21-- SXS   	23-Sep-82  9:30:15-- BGY     	16-Dec-82 11:16:17-- AXD    	 9-Dec-83 14:25:55-- DWR    	15-Feb-85 15:40:22DIRECTORY  Ascii: TYPE USING [CR],  ByteBlt: TYPE USING [ByteBlt],  Caret: TYPE USING [Action, ActOn, Set],  Context: TYPE USING [Type, Find, UniqueType],  Display: TYPE USING [White],  Environment: TYPE USING [Block],  Heap: TYPE USING [Create, systemZone],  MFile: TYPE USING [Error],  Process: TYPE USING [    Detach, GetPriority, MsecToTicks, Priority, priorityForeground, SetPriority,    SetTimeout],  Selection: TYPE USING [Convert],  String: TYPE USING [SubString],  TextData: TYPE USING [    Insertion, InsertionObject, MarkingAction, SelectionObject],  TextDisplay: TYPE USING [    BackupNLines, Adjust, DeleteText, DoEditAction, Handle, InsertBlock,    MarkInsertion, MarkSelection, noPlace, Position, PositionIsVisible, Redisplay,    TakeBottomAction, Update, UpdateLineTable, UpdateRange, UpdateToEnd],  TextSink: TYPE USING [FontInfo],  TextSource: TYPE USING [EditAction, GetLength, Handle, nullPosition, Position],  TextSW: TYPE USING [InvalidRegions, OnOff],  TextSWOps: TYPE USING [    DeleteSplit, InternalValidate, margin, MarkSplitBoundary,    ModifyInsertionState, NewSplitsObject, OtherSelections, TSWContext],  ToolWindow: TYPE USING [AdjustProcType, DisplayProcType, Type],  UserInput: TYPE USING [CaretProcType, StartStop, StringProcType],  UserTerminal: TYPE USING [BlinkDisplay],  Window: TYPE USING [    Box, EnumerateInvalidBoxes, GetChild, GetBox, Handle, InvalidateBox, Place,    SetDisplayProc, Validate];TextSWsD: MONITOR LOCKS lock  IMPORTS    ByteBlt, Caret, Context, Display, Heap, MFile, Process, Selection,    TextDisplay, TextSink, TextSource, TextSWOps, ToolWindow, UserTerminal,    Window  EXPORTS TextSW, TextSWOps =  BEGIN OPEN TextSWOps;  nullPosition: TextSource.Position = TextSource.nullPosition;  -- PUBLIC Variables  DoesNotExist: PUBLIC SIGNAL = CODE;  textSWContext: PUBLIC Context.Type ¬ Context.UniqueType[];  lock: PUBLIC MONITORLOCK;  nextTime: CONDITION;  OutputChain: TYPE = LONG POINTER TO OutputObject;  OutputObject: TYPE = RECORD [link: OutputChain, tsw: TSWContext];  bufferSize: CARDINAL = 80;  outputList: OutputChain ¬ NIL;--  waitOne: BOOLEAN ¬ FALSE;  z: UNCOUNTED ZONE = Heap.Create[1];  SetOutput: INTERNAL PROC [tsw: TSWContext] = INLINE {    IF tsw.output = NIL THEN tsw.output ¬ z.NEW[StringBody [bufferSize]];    EnqueueOutputRequest[tsw]};  LocalFind: PROC [sw: Window.Handle] RETURNS [tsw: TSWContext] = {    IF (tsw ¬ Context.Find[textSWContext, sw]) = NIL THEN      UserTerminal.BlinkDisplay[]};  -- Cursor and Caret Procedures  ActOnCaret: PUBLIC ENTRY PROC [data: TSWContext, action: Caret.Action] = {    ENABLE UNWIND => NULL; RealActOnCaret[data, action]};  ActivateCaret: PUBLIC UserInput.CaretProcType = {    tsw: TSWContext ¬ Context.Find[textSWContext, window];    IF tsw # NIL THEN SetupCaret[tsw, startStop]};  BlinkingCaret: PUBLIC ENTRY PROC [sw: Window.Handle, state: TextSW.OnOff] = {    ENABLE UNWIND => NULL;    tsw: TSWContext ¬ LocalFind[sw];    IF tsw # NIL THEN {      IF state = off THEN {        InternalForceOutput[tsw]; RealActOnCaret[tsw, clear]};      tsw.caret ¬ state}};  RealActOnCaret: PUBLIC PROC [tsw: TSWContext, action: Caret.Action] = {    i: CARDINAL;    insert2: TextData.InsertionObject;    markAction: TextData.MarkingAction =      SELECT action FROM        reset, clear => clear,        mark => mark,        invert => invert,        ENDCASE => clear;«    IF waitOne AND markAction # clear THEN {waitOne ¬ FALSE; RETURN}    ELSE waitOne ¬ TRUE;  »    IF tsw.caret = on THEN {      FOR i IN [1..tsw.splits.length) DO        insert2 ¬ tsw.insertion;        insert2.place ¬ TextDisplay.noPlace;        tsw.splits[i].MarkInsertion[@insert2, markAction];        ENDLOOP;      tsw.splits[0].MarkInsertion[@tsw.insertion, markAction];      IF action = reset THEN tsw.insertion.place ¬ TextDisplay.noPlace}};  SetupCaret: PROC [tsw: TSWContext, startStop: UserInput.StartStop] = {    IF tsw.options.access # read THEN      IF startStop = start THEN Caret.Set[tsw, ActOnCaret]      ELSE Caret.ActOn[reset]};  -- Input/Output Procedures  DeleteText: PUBLIC ENTRY PROC [    sw: Window.Handle, pos: TextSource.Position, count: LONG CARDINAL,    keepTrash: BOOLEAN ¬ TRUE] = {    ENABLE UNWIND => NULL;    tsw: TSWContext ¬ LocalFind[sw];    IF tsw # NIL THEN InternalDeleteText[tsw, pos, count, keepTrash]};  InternalDeleteText: PUBLIC PROC [    tsw: TSWContext, pos: TextSource.Position, count: LONG CARDINAL,    keepTrash: BOOLEAN ¬ TRUE] = {    firstBad, oldEOF: TextSource.Position;    done: BOOLEAN;    p: TextDisplay.Handle = tsw.splits[0];    InternalForceOutput[tsw];    RealActOnCaret[tsw, clear];    oldEOF ¬ p.source.GetLength;    [done, firstBad] ¬ p.DeleteText[      pos, count, @tsw.selection, @tsw.insertion, keepTrash];    IF ~done THEN RETURN;    IF tsw.splits.length > 1 THEN {      lastBad: TextSource.Position = MIN[pos + count - 1, p.source.GetLength];      delta: LONG INTEGER = p.source.GetLength - oldEOF;      IF delta # 0 THEN FixupSplits[tsw, firstBad, lastBad, delta]}};  DoEditAction: PUBLIC ENTRY PROC [    sw: Window.Handle, action: TextSource.EditAction]    RETURNS [delta: LONG INTEGER] = {    ENABLE UNWIND => NULL;    tsw: TSWContext ¬ LocalFind[sw];    firstBad, lastBad: TextSource.Position;    IF tsw = NIL THEN RETURN;    IF tsw.options.access = read THEN {UserTerminal.BlinkDisplay[]; RETURN};    RealActOnCaret[tsw, clear];    InternalForceOutput[tsw];    [firstBad, lastBad, delta] ¬ tsw.splits[0].DoEditAction[      @tsw.selection, @tsw.insertion, action];    IF delta # 0 THEN FixupSplits[tsw, firstBad, lastBad, delta]};  FixupSplits: PROC [    tsw: TSWContext, firstBad, lastBad: TextSource.Position,    delta: LONG INTEGER, firstSplit: CARDINAL ¬ 1] = {    p: TextDisplay.Handle ¬ tsw.splits[0];    backup: BOOLEAN;    lastBad ¬ MIN[lastBad, p.source.GetLength];    FOR i: CARDINAL IN [firstSplit..tsw.splits.length) DO      --tsw.splits[i].FixupDisplay[firstBad, lastBad, delta];      p ¬ tsw.splits[i];      -- delta is negative.  (firstBad - delta) is the old source position to delete to       backup ¬ firstBad < p.lineTable[0].pos AND CARDINAL[firstBad - delta] > p.lineTable[0].pos;      p.UpdateLineTable[firstBad, delta];      -- add some new stuff from TextDisplaysD.DeleteText to try and cure splits problems      p.Update[firstBad, lastBad, @tsw.selection, TRUE, TRUE];      IF backup AND p.lineTable[0].pos # 0 THEN BEGIN        left: TextDisplay.Position ¬ p.source.scanText[p.source, firstBad, line, left];	IF left # p.lineTable[0].pos THEN BEGIN	  p.lineTable[0].pos ¬ left; p.Update[left, firstBad, @tsw.selection, TRUE];	END;      END;«      IF backup THEN p.BackupNLines[1, @tsw.selection]      ELSE p.Update[firstBad, lastBad, @tsw.selection, TRUE];  » -- old stuff    ENDLOOP};  ForceOutput: PUBLIC ENTRY PROC [sw: Window.Handle] = {    ENABLE UNWIND => NULL;    tsw: TSWContext ¬ LocalFind[sw];    IF tsw # NIL THEN InternalForceOutput[tsw]};  InternalForceOutput: PUBLIC PROC [tsw: TSWContext] = {    IF tsw.output # NIL THEN {      OutputString[tsw, tsw.output]; z.FREE[@tsw.output]}};  InsertChar: PUBLIC ENTRY PROC [    sw: Window.Handle, char: CHARACTER, pos: TextSource.Position] = {    ENABLE UNWIND => NULL;    tsw: TSWContext = LocalFind[sw];    IF tsw = NIL THEN RETURN;    IF (tsw.output # NIL AND tsw.output.length = tsw.output.maxlength)      OR (pos # nullPosition AND pos # tsw.insertion.position) THEN {      OutputString[tsw, tsw.output]; tsw.output.length ¬ 0};    IF pos # nullPosition THEN      TextSWOps.ModifyInsertionState[tsw: tsw, op: unknown, pos: pos];    SetOutput[tsw];    tsw.output[tsw.output.length] ¬ char;    tsw.output.length ¬ tsw.output.length + 1;    IF char = Ascii.CR THEN {      OutputString[tsw, tsw.output]; tsw.output.length ¬ 0}};  InsertString: PUBLIC PROC [    sw: Window.Handle, s: LONG STRING, pos: TextSource.Position] = {    IF s = NIL THEN RETURN;    InsertBlock[sw, [LOOPHOLE[@s.text], 0, s.length], pos]};  InsertSubString: PUBLIC ENTRY PROC [    sw: Window.Handle, ss: String.SubString, pos: TextSource.Position] = {    ENABLE UNWIND => NULL;    tsw: TSWContext ¬ LocalFind[sw];    IF tsw # NIL AND ss # NIL AND ss.base # NIL THEN      InsertBlockInternal[        sw, [LOOPHOLE[@ss.base.text], ss.offset, ss.length], pos, tsw]};  InsertBlock: PUBLIC ENTRY PROC [    sw: Window.Handle, block: Environment.Block, pos: TextSource.Position] = {    ENABLE UNWIND => NULL;    tsw: TSWContext ¬ LocalFind[sw];    IF tsw # NIL AND block.blockPointer # NIL THEN      InsertBlockInternal[sw, block, pos, tsw]};  InsertBlockInternal: PUBLIC INTERNAL PROC [    sw: Window.Handle, block: Environment.Block, pos: TextSource.Position,    tsw: TSWContext] = {    length: CARDINAL ¬ block.stopIndexPlusOne - block.startIndex;    IF length > bufferSize      OR (length # 0 AND block.blockPointer[block.stopIndexPlusOne - 1] = 15B) -- check for CR      OR (pos # nullPosition AND pos # tsw.insertion.position) THEN {      IF tsw.output # NIL THEN {        OutputString[tsw, tsw.output]; tsw.output.length ¬ 0};      IF pos # nullPosition THEN        TextSWOps.ModifyInsertionState[tsw: tsw, op: unknown, pos: pos];      OutputBlock[tsw, block]}    ELSE {      IF tsw.output # NIL        AND length + tsw.output.length > tsw.output.maxlength THEN {        OutputString[tsw, tsw.output]; tsw.output.length ¬ 0};      SetOutput[tsw];      tsw.output.length ¬        tsw.output.length + ByteBlt.ByteBlt[          from: block,          to: [          LOOPHOLE[@tsw.output.text], tsw.output.length,          tsw.output.maxlength], overLap: move]}};  ReplaceText, ReplaceBlock: PUBLIC ENTRY PROC [    sw: Window.Handle, pos: TextSource.Position, count: LONG CARDINAL,    block: Environment.Block, keepTrash: BOOLEAN] = {    ENABLE UNWIND => NULL;    tsw: TSWContext = LocalFind[sw];    IF tsw = NIL THEN RETURN;    InternalDeleteText[tsw, pos, count, keepTrash];    IF block.blockPointer # NIL THEN      InsertBlockInternal[sw, block, pos, tsw];    InternalForceOutput[tsw]};  TypeIn: PUBLIC ENTRY UserInput.StringProcType = {    ENABLE UNWIND => NULL;    tsw: TSWContext;    IF string = NIL THEN RETURN;    tsw ¬ LocalFind[window];    IF tsw = NIL THEN RETURN;    ModifyInsertionState[tsw, append, tsw.insertion.position];    -- no change, just insure that we are managing insertion    InsertBlockInternal[      window, [LOOPHOLE[@string.text], 0, string.length], nullPosition, tsw];    InternalForceOutput[tsw];    ModifyInsertionState[tsw, append, tsw.insertion.position]};  TypeOut: PUBLIC UserInput.StringProcType = {    InsertString[window, string, nullPosition]};  ChangeCase: PUBLIC PROC [window: Window.Handle, upper: BOOLEAN] = {    tsw: TSWContext = LocalFind[window];    cs: LONG STRING;    IF tsw = NIL OR window # Selection.Convert[subwindow]      OR (cs ¬ Selection.Convert[string]) = NIL       OR tsw.options.access # edit THEN GOTO Blink;    FOR i: CARDINAL IN [0..cs.length) DO      SELECT cs[i] FROM        IN ['A..'Z] => IF NOT upper THEN cs[i] ¬ cs[i] - 'A + 'a;        IN ['a..'z] => IF upper THEN cs[i] ¬ cs[i] - 'a + 'A;        ENDCASE;      ENDLOOP;    ReplaceText[      sw: window, pos: tsw.selection.left, count: cs.length,       block: [LOOPHOLE[@cs.text], 0, cs.length], keepTrash: TRUE      ! UNWIND => Heap.systemZone.FREE[@cs]];    Heap.systemZone.FREE[@cs];    EXITS Blink => UserTerminal.BlinkDisplay[]};      ModifySource: PUBLIC ENTRY PROC [    sw: Window.Handle,     proc: PROC [Window.Handle, TextSource.Handle, LONG POINTER]      RETURNS [invalidRegions: TextSW.InvalidRegions],     data: LONG POINTER] = {    ENABLE UNWIND => NULL;    invalid: TextSW.InvalidRegions;    tsw: TSWContext = LocalFind[sw];    IF tsw = NIL THEN RETURN;    RealActOnCaret[tsw, clear];	-- turn off caret before modifying screen    IF (invalid ¬ proc[sw, tsw.splits[0].source, data]) # NIL      AND invalid.length # 0 THEN {      from: TextSource.Position ¬ TextSource.nullPosition;      to: TextSource.Position ¬ 0;      delta: LONG INTEGER ¬ 0;      FOR i: CARDINAL IN [0..invalid.length) DO	from ¬ MIN[from, invalid[i].from];	to ¬ MAX[to, invalid[i].to];	delta ¬ delta + invalid[i].delta;	ENDLOOP;      FixupSplits[tsw, from, to, delta, 0]}};  -- Adjust and Display Procedures  Adjust: PUBLIC ENTRY ToolWindow.AdjustProcType = {    ENABLE UNWIND => NULL;    tsw: TSWContext;    window ¬      SELECT ToolWindow.Type[window] FROM        tool => Window.GetChild[Window.GetChild[window]],        clipping => Window.GetChild[window],        sub, other => window,        ENDCASE => ERROR;    tsw ¬ LocalFind[window];    IF tsw # NIL THEN {      p: TextDisplay.Handle ¬ tsw.splits[0];      wrap: BOOLEAN = p.options.rightBreak # none;      deltaH: INTEGER = box.dims.h - tsw.oldDims.h;      deltaW: INTEGER = box.dims.w - tsw.oldDims.w;      topMargin, bottomMargin: CARDINAL;      IF deltaH = 0 AND deltaW = 0 THEN RETURN;      topMargin ¬ IF tsw.options.flushTop THEN 0 ELSE margin;      bottomMargin ¬ IF tsw.options.flushBottom THEN 0 ELSE margin;      IF when = before THEN {        IF deltaW # 0 AND wrap THEN          window.InvalidateBox[[[0, 0], window.GetBox.dims]];        RETURN};      IF deltaW > 0 THEN        window.InvalidateBox[          [[p.box.place.x + p.box.dims.w, 0], [margin, window.GetBox.dims.h]],          isDirty];      tsw.oldDims ¬ box.dims;      RealActOnCaret[tsw, reset];      IF tsw.splits.length = 1 THEN        p.Adjust[          [          [margin, topMargin], [          box.dims.w - margin*2, box.dims.h - (topMargin + bottomMargin)]],          @tsw.selection]      ELSE {        i: CARDINAL;        IF deltaH < 0 THEN {          n: CARDINAL ¬ tsw.splits.length;          FOR i DECREASING IN [1..tsw.splits.length) DO -- don't want to delete split 0            p ¬ tsw.splits[i];            IF p.box.place.y >              box.dims.h - INTEGER[p.sink.FontInfo.lineHeight] THEN {              [] ¬ TextSWOps.DeleteSplit[tsw, i]; n ¬ n - 1}            ELSE EXIT;            ENDLOOP;          IF tsw.splits.length # n THEN            tsw.splits ¬ TextSWOps.NewSplitsObject[tsw.splits, n, TRUE]};        IF deltaW # 0 THEN          FOR i IN [0..tsw.splits.length - 1) DO            p ¬ tsw.splits[i];            p.Adjust[              [p.box.place, [box.dims.w - margin*2, p.box.dims.h]],	      @tsw.selection];            ENDLOOP;        p ¬ tsw.splits[PRED[tsw.splits.length]];        p.Adjust[[          p.box.place, [          box.dims.w - margin*2, box.dims.h - p.box.place.y - margin*2]],          @tsw.selection]};      IF deltaW < 0 THEN  -- clear right margin        p.wh.InvalidateBox[          [[p.box.place.x + p.box.dims.w, 0], [margin, p.wh.GetBox.dims.h]]];      IF deltaH < 0 THEN  -- clear bottom margin        p.wh.InvalidateBox[          [[p.box.place.x, p.box.place.y + p.box.dims.h],	  [p.box.dims.w, margin]]]}};  DisplayProc: PUBLIC ENTRY ToolWindow.DisplayProcType = {    ENABLE UNWIND => NULL; InternalDisplayProc[window: window]};  InternalDisplayProc: PUBLIC ToolWindow.DisplayProcType = {    tsw: TSWContext = LocalFind[window];    IF tsw # NIL THEN {      DoOne: PROC [w: Window.Handle, box: Window.Box] = {        RealDisplayProc[tsw, box]};      RealActOnCaret[tsw, clear];      Display.White[tsw.sw, [[0, 0], window.GetBox.dims]]; -- must come after ActOn!      window.EnumerateInvalidBoxes[DoOne]}};  InternalValidate: PUBLIC PROC [window: Window.Handle] = {    -- only to be called from ENTRY AND INTERNAL guys    oldDisplayProc: ToolWindow.DisplayProcType = window.SetDisplayProc[      InternalDisplayProc];    window.Validate;    [] ¬ window.SetDisplayProc[oldDisplayProc]};  MarkOtherSelections: PUBLIC PROC [    p: TextDisplay.Handle, s: OtherSelections] = {    FOR i: CARDINAL IN [0..s.length) DO      s[i].marked ¬ FALSE; p.MarkSelection[s[i], mark]; ENDLOOP};  RealDisplayProc: PROC [tsw: TSWContext, box: Window.Box] = {    -- really an INTERNAL guy!    select2: TextData.SelectionObject;    FOR i: CARDINAL IN [1..tsw.splits.length) DO      select2 ¬ tsw.selection;      [] ¬ tsw.splits[i].Redisplay[box, @select2];      MarkSplitBoundary[tsw, i];      IF tsw.otherSels # NIL THEN        MarkOtherSelections[tsw.splits[i], tsw.otherSels];      ENDLOOP;    [] ¬ tsw.splits[0].Redisplay[box, @tsw.selection];    IF tsw.otherSels # NIL THEN      MarkOtherSelections[tsw.splits[0], tsw.otherSels]};  Update: PUBLIC ENTRY PROC [    sw: Window.Handle, from, to: TextSource.Position, charsDeleted: BOOLEAN] = {    ENABLE UNWIND => NULL;    tsw: TSWContext ¬ LocalFind[sw];    IF tsw # NIL THEN      FOR i: CARDINAL IN [0..tsw.splits.length) DO        tsw.splits[i].Update[          from, to, @tsw.selection, TRUE, charsDeleted];        ENDLOOP};  UpdateRange: PUBLIC ENTRY PROC [    sw: Window.Handle, from, to: TextSource.Position, delta: LONG INTEGER,    charsDeleted: BOOLEAN] = {    ENABLE UNWIND => NULL;    tsw: TSWContext ¬ LocalFind[sw];    IF tsw # NIL THEN      FOR i: CARDINAL IN [0..tsw.splits.length) DO        tsw.splits[i].UpdateRange[          from, to, delta, @tsw.selection, @tsw.insertion, TRUE,          charsDeleted];        ENDLOOP};  UpdateToEnd: PUBLIC ENTRY PROC [    sw: Window.Handle, from: TextSource.Position, charsDeleted: BOOLEAN] = {    ENABLE UNWIND => NULL;    tsw: TSWContext ¬ LocalFind[sw];    IF tsw # NIL THEN      FOR i: CARDINAL IN [0..tsw.splits.length) DO        tsw.splits[i].UpdateToEnd[          from, @tsw.selection, @tsw.insertion, TRUE, charsDeleted];        ENDLOOP};  -- Output Process and utilities  DequeueOutputRequest: PROC [tsw: TSWContext] = {    curr, prev: OutputChain;    IF outputList = NIL THEN RETURN;    curr ¬ outputList;    prev ¬ outputList;    IF curr.tsw = tsw THEN outputList ¬ curr.link    ELSE      UNTIL (curr ¬ curr.link) = NIL DO        IF curr.tsw = tsw THEN {prev.link ¬ curr.link; EXIT};        prev ¬ curr;        ENDLOOP;    IF curr # NIL THEN z.FREE[@curr]};  EnqueueOutputRequest: INTERNAL PROC [tsw: TSWContext] = {    curr: OutputChain;    curr ¬ outputList;    IF outputList # NIL THEN {      IF curr.tsw = tsw THEN RETURN;      UNTIL (curr ¬ curr.link) = NIL DO        IF curr.tsw = tsw THEN RETURN; ENDLOOP};    curr ¬ z.NEW[OutputObject ¬ [link: outputList, tsw: tsw]];    outputList ¬ curr};  OutputProcess: ENTRY PROC = {    ENABLE UNWIND => NULL;    DO      ENABLE ABORTED => LOOP;      WAIT nextTime;      IF outputList # NIL THEN        UNTIL outputList = NIL DO          tsw: TSWContext = outputList.tsw;          IF tsw.output = NIL THEN DequeueOutputRequest[tsw]          ELSE {            OutputBlock[              tsw: tsw,              block: [LOOPHOLE[@tsw.output.text], 0, tsw.output.length]];            z.FREE[@tsw.output]};          ENDLOOP;      ENDLOOP};  OutputString: PUBLIC PROC [tsw: TSWContext, s: LONG STRING] = {    IF s = NIL THEN RETURN;    OutputBlock[tsw, [LOOPHOLE[@s.text], 0, s.length]]};  OutputBlock: PROC [tsw: TSWContext, block: Environment.Block] = {    -- You better be in the monitor when you get here!!    from, to, oldInsert: TextSource.Position;    delta: LONG INTEGER;    RealActOnCaret[tsw, clear];    to ¬ oldInsert ¬ tsw.insertion.position;    {ENABLE MFile.Error => {UserTerminal.BlinkDisplay; CONTINUE};    from ¬ tsw.splits[0].InsertBlock[      block, @tsw.selection, @tsw.insertion];    delta ¬ tsw.insertion.position - oldInsert;    IF tsw.splits.length > 1 THEN {      i: CARDINAL;      p: TextDisplay.Handle;      wasVisible, backup: BOOLEAN;      to ¬ MAX[to, tsw.insertion.position];      FOR i IN [1..tsw.splits.length) DO        p ¬ tsw.splits[i];        wasVisible ¬ p.PositionIsVisible[oldInsert];        backup ¬ tsw.insertion.position < p.lineTable[0].pos;        p.UpdateLineTable[MIN[oldInsert, tsw.insertion.position], delta];        IF wasVisible THEN {          IF backup THEN p.BackupNLines[1, @tsw.selection]          ELSE {            p.Update[from, to, @tsw.selection, TRUE];            p.TakeBottomAction[              wasVisible, @tsw.selection, @tsw.insertion]}};        ENDLOOP}};    TextSWOps.InternalValidate[tsw.sw];    DequeueOutputRequest[tsw]};  -- MAIN line code  Init: PROC = {    callersPriority: Process.Priority = Process.GetPriority[];    Process.SetPriority[Process.priorityForeground];    Process.SetTimeout[@nextTime, Process.MsecToTicks[200]];    Process.Detach[FORK OutputProcess[]];    Process.SetPriority[callersPriority]};  Init[];  END. -- of TextSWsDLOGDWR    	 9-Nov-84 12:03:36  FIxed Caret tracks & splits bugsDWR    	26-Nov-84 14:39:16 Got rid of waitOne in RealActOnCaret.  I couldn't see any point in it.DWR    	15-Feb-85 15:39:53  Fixed a drag splits bug in Adjust 
-- File: FileTransfersA.mesa - last edit:-- Riggle.PA            8-Aug-86 12:49:49-- BJD    .pa          22-Feb-85 15:54:42-- BXM  	 9-Feb-82 16:18:52-- LXR    	22-Mar-82 14:23:41-- PXK    	 3-Oct-82 16:05:39-- Copyright (C) 1982, 1984 , 1985, 1986 by Xerox Corporation. All rights reserved.   DIRECTORY  Auth USING [IdentityHandle, CopyIdentity, FreeIdentity],  FileName USING [PackFilename, ResetVFN, UnpackFilename, VFN],  FileTransfer USING [    CheckAbortProc, ClientProc, Confirmation, Connection, ConnectionObject,    DesiredProperties, ErrorCode, FileInfo, FileInfoObject, FileType, ListProc,     MessageProc, ServerType, Severity, StreamType, VetoProc],  FileTransferOps USING [    CatchErrorsProc, CloseProc, Command, CommandObject, Connection,    ConnectionObject, ConnectionPassword, CredentialLevel, FTHandle, FTObject,     LocalPrimitives, maxFileName, NSPrimitives, Operation, PrimitivesHandle,     PupPrimitives, RetrieveStreamCommand, StartNS, StartPup, StreamSeal, Which, z],  FileTransferUtils USING [    AppendVFN, LocalClose, LocalCopy, LocalNextStreamInternal, Post, Validate],  Heap USING [Create, NWords, systemZone],  MFile USING [Type],  MSegment USING [Delete, Handle],  Profile USING [defaultFileServerProtocol, GetID, GetUser],  Runtime USING [ControlFault, UnboundProcedure],  Stream USING [    defaultInputOptions, DeleteProcedure, GetByteProcedure, GetPositionProcedure,    GetProcedure, GetSSTProcedure, GetTimeoutProcedure, GetWordProcedure, Handle,    InvalidOperation, PutByteProcedure, PutProcedure, PutWordProcedure,    SendAttentionProcedure, SendNowProcedure, SetPositionProcedure, SetSSTProcedure,    SetTimeoutProcedure, WaitAttentionProcedure],  String USING [    AppendChar, AppendLongDecimal, AppendString, AppendStringAndGrow,    Empty, EquivalentString, FreeString, Replace, StringBoundsFault],  System USING [PulsesToMicroseconds],  Time USING [Append, Packed, Unpack],  UserInput USING [UserAbort];  FileTransfersA: PROGRAM -- MONITOR LOCKS conn USING conn: Connection  IMPORTS    Auth, FileName, FileTransferOps, FileTransferUtils, Heap, MSegment,    Profile, Runtime, Stream, String, System, Time, UserInput  EXPORTS FileTransfer, FileTransferOps, FileTransferUtils =  BEGIN OPEN FileTransfer;  Command: TYPE = FileTransferOps.Command;  CommandObject: TYPE = FileTransferOps.CommandObject;  Connection: TYPE = FileTransferOps.Connection;  ConnectionObject: PUBLIC TYPE = FileTransferOps.ConnectionObject;    VFN: TYPE = FileName.VFN;  CR: LONG STRING = "";  Error: PUBLIC SIGNAL [conn: Connection, code: ErrorCode] = CODE;  StartUp: PUBLIC PROC = {};      -- Exported into FileTransfer    Close: PUBLIC PROC [conn: Connection] = {    c: close CommandObject ¬ [close[]]; ActOn[conn, @c, NIL]};  Enumerate: PUBLIC PROC [conn: Connection, files: VFN, proc: ListProc] = {    c: enumerate CommandObject ¬ [enumerate[files: files, proc: proc]];    ActOn[conn, @c, files]};  Copy: PUBLIC PROC [    sourceFile, destFile: VFN, sourceConn, destConn: Connection ¬ NIL,    veto: VetoProc ¬ NIL, showDates: BOOLEAN ¬ FALSE] =     BEGIN    localDest: BOOLEAN = LocalVFN[destConn, destFile];    IF LocalVFN[sourceConn, sourceFile] THEN       IF localDest THEN {        c: localToLocal CommandObject ¬ [localToLocal[          source: sourceFile, dest: destFile, veto: veto, dates: showDates]];	CheckConnection[sourceConn];	ActOn[sourceConn, @c, sourceFile]}      ELSE {        c: localToRemote CommandObject ¬ [localToRemote[          source: sourceFile, dest: destFile, veto: veto, dates: showDates]];	CheckConnection[destConn];	ActOn[destConn, @c, destFile]}    ELSE       IF localDest THEN {        c: remoteToLocal CommandObject ¬ [remoteToLocal[          source: sourceFile, dest: destFile, veto: veto,	  dates: showDates, type: remote]];	CheckConnection[sourceConn];        ActOn[sourceConn, @c, sourceFile]}      ELSE {	CheckConnection[sourceConn];	IF destConn = NIL THEN ERROR Error[destConn, illegalParameters];        RemoteCopy[	  sourceFile, destFile, sourceConn, destConn, veto, showDates]};    END;	  Delete: PUBLIC PROC [conn: Connection, file: VFN, veto: VetoProc ¬ NIL] = {    c: delete CommandObject ¬ [delete[file: file, veto: veto]];    ActOn[conn, @c, file]};	  Rename: PUBLIC PROC [conn: Connection, old, new: VFN] = {    c: rename CommandObject ¬ [rename[old: old, new: new]];     ActOn[conn, @c, old]};      ReadStream: PUBLIC PROC [      conn: Connection, files: VFN, veto: VetoProc ¬ NIL,      showDates: BOOLEAN ¬ FALSE, type: StreamType ¬ remote]    RETURNS [Stream.Handle] =  {    c: CommandObject;    SELECT type FROM      remote => c ¬ [retrieveStream[remote: files, veto: veto, dates: showDates]];      local, temporary =>         IF LocalVFN[conn, files] THEN 	  c ¬ [retrieveStream[remote: files, veto: veto, dates: showDates]]	ELSE	  c ¬ [remoteToLocal[source: files, dest: NIL, veto: veto,	  	 dates: showDates, type: type]]    ENDCASE => ERROR Error[conn, illegalParameters];    ActOn[conn, @c, files];    RETURN[conn.stream]};      GetStreamInfo: PUBLIC PROC [stream: Stream.Handle] RETURNS [info: FileInfo] = {    ft: FileTransferOps.FTHandle = ValidStream[stream].ft;    ft.conn.currentPrimitives.getStreamInfo[ft];    RETURN[ft.conn.info[source]]};  GetStreamName: PUBLIC PROC [stream: Stream.Handle] RETURNS [LONG STRING] = {    ft: FileTransferOps.FTHandle = ValidStream[stream].ft;    RETURN[ft.file]};      ReadNextStream: PUBLIC PROC [old: Stream.Handle] RETURNS [Stream.Handle] = {    ft: FileTransferOps.FTHandle ¬ ValidStream[old, readNext].ft;    ReadNextInner: PROC [c: Connection] = {      answer: Confirmation ¬ skip;      UNTIL answer = do DO	ft ¬ LOOPHOLE[c.stream];	IF ft = NIL THEN RETURN;	SELECT TRUE FROM	  ft.retrieveFile => 	    answer ¬ c.currentPrimitives.retrieveNextFile[c, ft];           c.serverType = local => 	    answer ¬ FileTransferUtils.LocalNextStreamInternal[c, ft]	  ENDCASE => answer ¬ c.currentPrimitives.retrieveNextStream[c, ft];	ENDLOOP};    Umbrella[ft, ReadNextInner !       ABORTED => {IF ft#NIL THEN old.delete[old]; old ¬ NIL}];    RETURN[LOOPHOLE[ft]]};  StoreStream: PUBLIC PROC [      conn: Connection, remote: VFN, veto: VetoProc ¬ NIL,      showDates: BOOLEAN ¬ FALSE, stream: Stream.Handle, creation: Time.Packed,      bytes: LONG CARDINAL, fileType: FileType] = {    CopyStoreStream[      conn, remote, veto, showDates, stream, creation, bytes, fileType, NIL]};      CopyStoreStream: PROC [    conn: Connection, remote: VFN, veto: VetoProc ¬ NIL,    showDates: BOOLEAN ¬ FALSE, stream: Stream.Handle, creation: Time.Packed,    bytes: LONG CARDINAL, fileType: FileType, default: LONG STRING ¬ NIL] = {    c: storeStream CommandObject ¬ [storeStream[      remote: remote, veto: veto, dates: showDates, stream: stream,      creation: creation, bytes: bytes, fileType: fileType, default: default]];    IF LocalVFN[conn, remote] THEN ERROR Error[conn, illegalParameters];    IF fileType = directory OR      (String.Empty[remote.name] AND String.Empty[default]) THEN {      FileTransferUtils.Post[conn, warning, "Can't store a directory"L, CR];      ERROR Error[conn, skipFile]}; -- as opposed to skipOperation --    ActOn[conn, @c, remote]};      HighestVersion: PUBLIC PROC [conn: Connection, remote: VFN]    RETURNS [exists: BOOLEAN] = {    Found: ListProc = {      exists ¬ TRUE;      FileName.ResetVFN[vfn: remote, d: TRUE, n: TRUE, v: TRUE];      FileName.UnpackFilename[file, remote];      RETURN[do]};    exists ¬ FALSE;    String.Replace [      @remote.version, "H"L, heap];    Enumerate[conn, remote, Found !       Error => IF code = notFound THEN CONTINUE];    IF ~exists THEN {String.FreeString[heap, remote.version]; remote.version ¬ NIL} };        	        -- Connection operations  Create: PUBLIC PROC RETURNS [c: Connection] = {    SetPrimCred: PROCEDURE [name, password: LONG STRING] ={      String.Replace[@c.primary.directory, name, heap];      String.Replace[@c.primary.password, password, heap]};    SetId: PROCEDURE [id: Auth.IdentityHandle] ={      c.id ¬ Auth.CopyIdentity[identity: id, z: FileTransferOps.z]};    c ¬ z.NEW[FileTransferOps.ConnectionObject ¬      [preferredType: IF Profile.defaultFileServerProtocol=ns THEN ns ELSE ifs,       localPrimitives: FileTransferOps.LocalPrimitives,       pupPrimitives: FileTransferOps.PupPrimitives,       nsPrimitives: FileTransferOps.NSPrimitives]];    FOR w: FileTransferOps.Which IN FileTransferOps.Which DO      c.info[w] ¬ z.NEW[FileInfoObject ¬ []];      ENDLOOP;    Profile.GetUser[proc: SetPrimCred];    Profile.GetID[proc: SetId]};  Destroy: PUBLIC PROC [conn: Connection] = {    p: LONG POINTER TO ARRAY [0..SIZE[FileTransferOps.ConnectionObject]) OF      CARDINAL = LOOPHOLE[conn];    FileTransferUtils.Validate[conn];    DestroyEntry[conn];    p­ ¬ ALL[0];    FileTransferOps.z.FREE[@conn]};  CheckConnection: PROC [c: Connection] = {    IF c = NIL THEN ERROR Error[c, illegalParameters]};    GetProcs: PUBLIC PROC [conn: Connection]    RETURNS [      clientData: LONG POINTER, messages: MessageProc,      login, noteProgress: ClientProc, checkAbort: CheckAbortProc] = {      FileTransferUtils.Validate[conn];      clientData ¬ conn.clientData;      messages ¬ conn.post;      login ¬ conn.login;      noteProgress ¬ conn.progress;      checkAbort ¬ conn.abort};        SetProcs: PUBLIC PROC [    conn: Connection, clientData: LONG POINTER, messages: MessageProc ¬ NIL,    login: ClientProc ¬ NIL, noteProgress: ClientProc ¬ NIL,    checkAbort: CheckAbortProc ¬ NIL] = {      Validate[conn];      conn.clientData ¬ clientData;      conn.post ¬ messages;      conn.login ¬ login;      conn.progress ¬ noteProgress;      conn.abort ¬ checkAbort};  GetDesiredProperties: PUBLIC PROC [conn: Connection]     RETURNS [props: FileTransfer.DesiredProperties] = {    FileTransferUtils.Validate[conn];    RETURN[conn.desiredProps]};    SetDesiredProperties: PUBLIC PROC    [conn: Connection, props: FileTransfer.DesiredProperties] = {    FileTransferUtils.Validate[conn];    conn.desiredProps ¬ props};  GetServerType: PUBLIC PROC [conn: Connection, host: LONG STRING]    RETURNS [ServerType] = {    FileTransferUtils.Validate[conn];    IF host # NIL THEN String.AppendString[host, conn.host !      String.StringBoundsFault => CONTINUE];    RETURN[conn.serverType]};        SetDefaultServerType: PUBLIC PROC [conn: Connection, type: ServerType] = {  -- doesn't require a connection if only want "is loaded" info;    error: BOOLEAN ¬ SELECT type FROM      ns => NSPrimitives = NIL,      ifs => PupPrimitives = NIL      ENDCASE => FALSE;    IF error THEN ERROR Error[conn, skipOperation];  -- "type" modules not loaded    IF conn = NIL THEN RETURN;     FileTransferUtils.Validate[conn];    conn.preferredType ¬ type};          CodeToString: PUBLIC PROC [code: FileTransfer.ErrorCode, s: LONG STRING] = {    msg: LONG STRING ¬      SELECT code FROM        illegalParameters => "Illegal parameters"L,        invalidObject => "Invalid object"L,	notAStream => "Not a stream"L,        illegalLogin => "Illegal login"L,	illegalConnect => "Illegal connect"L,        skipOperation => "Can't complete that operation"L,	skipFile => "Can't complete operation on that file"L,	cantModify => "Can't be modified"L,	directoryFull => "Directory full"L,	notFound => "Not found"L,	accessDenied => "Access denied"L,        unknown => "Unknown error"L,        ENDCASE => "???"L;    msg.length ¬ MIN[s.maxlength, msg.length];    String.AppendString[s, msg]};	  LocalHost: PROC [host: LONG STRING] RETURNS [BOOLEAN] = {    IF String.Empty[host] THEN RETURN[TRUE];    IF String.EquivalentString[host, "ME"L] THEN RETURN[TRUE];    RETURN[FALSE]};      LocalVFN: PUBLIC PROC [conn: Connection, vfn: FileName.VFN]     RETURNS [BOOLEAN] = {    IF conn = NIL THEN RETURN[TRUE];    Validate[conn];    IF vfn = NIL THEN RETURN[TRUE];     IF String.Empty[vfn.host] THEN RETURN[TRUE]    ELSE RETURN[LocalHost[vfn.host]]};  SetPrimaryCredentials: PUBLIC PROC [    conn: Connection, user, password: LONG STRING ¬ NIL,    id: Auth.IdentityHandle ¬ NIL] = {    Validate[conn];    conn.newCredentials ¬ TRUE;    IF user # NIL THEN String.Replace[@conn.primary.directory, user, heap];    IF password # NIL THEN String.Replace[@conn.primary.password, password, heap];    IF conn.id # NIL THEN      Auth.FreeIdentity[identityPtr: @conn.id, z: FileTransferOps.z];    IF id # NIL THEN conn.id ¬ Auth.CopyIdentity[identity: id, z: FileTransferOps.z]};    SetSecondaryCredentials: PUBLIC PROC [    conn: Connection, connectName, connectPassword: LONG STRING] = {    Validate[conn];    String.Replace[@conn.secondary.directory, connectName, heap];    String.Replace[@conn.secondary.password, connectPassword, heap]};    AppendVFN: PUBLIC PROC [      s: LONG STRING, vfn: VFN, remote: BOOLEAN, rename: BOOLEAN ¬ FALSE] = {    file: LONG STRING;    IF vfn = NIL THEN RETURN;    file ¬ FileName.PackFilename[      vfn: vfn, h: FALSE, d: ~remote OR rename, n: TRUE, v: remote];    IF rename AND ~String.Empty[vfn.directory] AND vfn.directory[0] # '< THEN      String.AppendChar[s, '<];    String.AppendString[s, file ! String.StringBoundsFault => RESUME[NIL]];    String.FreeString[heap, file]};  -- Skeletal stuff  ActOn: PUBLIC PROC [conn: Connection, command: Command, vfn: VFN] =    BEGIN    op: FileTransferOps.Operation = command.op;    Inner: PROC [c: Connection] = {CallPrimitive[c, command]};    Validate[conn];    SetHostAndServerType[conn, vfn, op];    ResetStreamCatchErrors[conn];    IF op = close THEN      conn.currentPrimitives.close[c: conn, printErrs: TRUE, freeObject: TRUE]    ELSE {      IF vfn = NIL THEN ERROR Error[conn, illegalParameters];      conn.currentPrimitives.catchErrors[c: conn, op: op, primitive: Inner, vfn: vfn]}    END;  CallPrimitive: PROC [c: Connection, command: FileTransferOps.Command] = {    p: LONG POINTER = command;    WITH command SELECT FROM      delete => 	c.currentPrimitives.deleteFile[c, p];      enumerate => 	c.currentPrimitives.listFile[c, p];      rename => 	c.currentPrimitives.renameFile[c, p];      localToLocal =>	FileTransferUtils.LocalCopy[c, p];      localToRemote =>	c.currentPrimitives.storeFile[c, p];      remoteToLocal =>	c.currentPrimitives.retrieveFile[c, p];      retrieveStream =>	c.currentPrimitives.retrieveStream[c, p];      storeStream =>	c.currentPrimitives.storeStream[c, p];      delver =>		c.currentPrimitives.delver[c, p];      ENDCASE => ERROR Error[c, unknown]};        SetHostAndServerType: PROC [c: Connection, vfn: VFN, op: FileTransferOps.Operation] =    BEGIN  -- Set actual serverType, and corresponding currentPrimitives; keep these two invariant;    host: LONG STRING ¬ NIL;     close: FileTransferOps.CloseProc ¬       IF c.currentPrimitives = NIL THEN        FileTransferUtils.LocalClose ELSE c.currentPrimitives.close;    oldType: FileTransfer.ServerType ¬ c.serverType;    IF vfn # NIL AND ~String.EquivalentString[c.host, vfn.host] THEN      IF String.Empty[vfn.host] THEN {        String.FreeString[heap, c.host]; c.host ¬ NIL}      ELSE String.Replace[@c.host, vfn.host, heap];    host ¬ IF op=close THEN c.lastHost ELSE c.host;    SELECT TRUE FROM      LocalHost[host] =>  c.serverType ¬ local;      NSHost[host] =>  c.serverType ¬ ns;       PupHost[host] =>  c.serverType ¬ ifs;       ENDCASE =>  c.serverType ¬ c.preferredType;    CheckForPupOrNS[c, c.serverType];    SELECT c.serverType FROM      ns => c.currentPrimitives ¬ c.nsPrimitives;      ifs => c.currentPrimitives ¬ c.pupPrimitives;      ENDCASE => {        c.currentPrimitives ¬ c.localPrimitives;        c.currentPrimitives.close ¬ close};    IF (c.serverType # oldType) AND (c.serverType # local) AND        (close # c.currentPrimitives.close) THEN 	close[c: c, printErrs: TRUE, freeObject: TRUE];    END;  Umbrella: PROC [     ft: FileTransferOps.FTHandle, proc: PROC [Connection]] = {      Validate[ft.conn];      ft.conn.currentPrimitives.streamCatchErrors[        c:ft.conn, op:ft.op, primitive:proc, fileName:ft.file]};  DestroyEntry: PROC [conn: Connection] =    BEGIN    IF conn.stp # NIL THEN {      SetDefaultServerType[conn, ifs];      conn.currentPrimitives.close[c: conn, printErrs: TRUE, freeObject: TRUE];      conn.stp ¬ NIL};    IF conn.nsData # NIL THEN {      SetDefaultServerType[conn, ns];      conn.currentPrimitives.close[c: conn, printErrs: TRUE, freeObject: TRUE];      conn.nsData ¬ NIL};    IF conn.stream # NIL THEN conn.stream.delete[conn.stream];    IF conn.buffer # NIL THEN MSegment.Delete[conn.buffer];    IF conn.host # NIL THEN String.FreeString[heap, conn.host];    IF conn.lastHost # NIL THEN String.FreeString[heap, conn.lastHost];    IF conn.primary.directory # NIL THEN      String.FreeString[heap, conn.primary.directory];    IF conn.primary.password # NIL THEN      String.FreeString[heap, conn.primary.password];    IF conn.secondary.directory # NIL THEN      String.FreeString[heap, conn.secondary.directory];    IF conn.secondary.password # NIL THEN      String.FreeString[heap, conn.secondary.password];    IF conn.id # NIL THEN       Auth.FreeIdentity[identityPtr: @conn.id, z: FileTransferOps.z];    FileTransferOps.z.FREE[@conn.info[source]];    FileTransferOps.z.FREE[@conn.info[target]];    END;  RemoteCopy: PROC [      sourceFile, destFile: VFN, sourceConn, destConn: Connection,      veto: VetoProc, showDates: BOOLEAN] = -- Copy files from one server to another; this procedure is independent of servertype.    BEGIN    destServerType: FileTransfer.ServerType ¬      IF NSHost[destFile.host] THEN ns ELSE destConn.preferredType;    in: Stream.Handle ¬ NIL;    sourceInfo: FileInfo;    myVeto: VetoProc = IF veto = NIL THEN veto ELSE CopyVeto;    qualifiedName: LONG STRING ¬ NIL;    MakeDefaultName: PROC [name: LONG STRING] =       BEGIN  -- this proc is a crock;  need to rationalize pup/ns pathnames, whether they begin with '< or not, etc.  Should probably normalize at ActOn time;            bracketPosPlusOne: CARDINAL ¬ IF sourceFile.directory[0]='< THEN 1 ELSE 0;      sourceInfo ¬ GetStreamInfo[in];      IF ~String.Empty[sourceFile.directory] THEN {        same: BOOLEAN ¬ sourceFile.directory[0]='< AND sourceInfo.directory[0]='<	  OR sourceFile.directory[0]#'< AND sourceInfo.directory[0]#'<;        FOR i: CARDINAL IN [0..sourceFile.directory.length) DO	  SELECT sourceFile.directory[i] FROM	    '*, '# => EXIT;	    '<, '>, '/ => bracketPosPlusOne ¬ i+1;	    ENDCASE;	  REPEAT  -- no wildcard in sourceFile.directory	    FINISHED => 	      bracketPosPlusOne ¬ 	        IF sourceFile.directory[sourceFile.directory.length-1] = '> THEN		  sourceFile.directory.length ELSE sourceFile.directory.length+1	  ENDLOOP;	IF ~same THEN	  IF sourceFile.directory[0] = '< THEN	    bracketPosPlusOne ¬ bracketPosPlusOne-1 	  ELSE bracketPosPlusOne ¬ bracketPosPlusOne+1;	FOR i: CARDINAL IN [bracketPosPlusOne..sourceInfo.directory.length) DO	  String.AppendChar[name, sourceInfo.directory[i]];	  ENDLOOP;	IF ~String.Empty[name] AND name[name.length-1] # '> THEN	  String.AppendChar[name, IF sourceConn.serverType = ns THEN '/ ELSE '>];       };      String.AppendString[name, sourceInfo.body];      IF destServerType = ifs THEN        FOR i: CARDINAL IN [0..name.length) DO IF name[i] = '/ THEN name[i] ¬ '>	  ENDLOOP;      END;           CopyVeto: VetoProc = {      CopyGetInfo: PROC [c: Connection] RETURNS [source, target: FileInfo] = {        destInfo: FileInfo = info[c].target;        RETURN[target: destInfo, source: sourceInfo]};      [confirm, showDates] ¬ veto[        conn, clientData, post, CopyGetInfo, showingDates]};	    IF sourceConn = NIL OR destConn = NIL THEN      ERROR Error[sourceConn, illegalParameters];    in ¬ ReadStream[      conn: sourceConn, files: sourceFile, showDates: FALSE];    qualifiedName ¬      FileTransferOps.z.NEW[StringBody[FileTransferOps.maxFileName]];    DO       ENABLE UNWIND => {        FileTransferOps.z.FREE[@qualifiedName];         IF sourceConn.stream#NIL THEN {in.delete[in]; in¬NIL}};      qualifiedName.length ¬ 0;      MakeDefaultName[qualifiedName ! String.StringBoundsFault => {        ns ¬ FileTransferOps.z.NEW[	  StringBody[s.maxlength + FileTransferOps.maxFileName]];	String.AppendStringAndGrow[@ns, s, FileTransferOps.z];	FileTransferOps.z.FREE[@s];	RESUME[qualifiedName ¬ ns]}];      CopyStoreStream[        conn: destConn, remote: destFile, veto: myVeto, showDates: showDates,        stream: in, creation: sourceInfo.create, bytes: sourceInfo.size,        fileType: sourceInfo.type, default: qualifiedName	! Error =>  -- allow client to resume at this point	  SELECT code FROM	    skipFile, accessDenied => {SIGNAL Error[conn, code]; CONTINUE};	    ENDCASE => REJECT];      in ¬ ReadNextStream[in];      IF in = NIL THEN EXIT;      String.FreeString[heap, destFile.version]; destFile.version ¬ NIL;      ENDLOOP;      FileTransferOps.z.FREE[@qualifiedName];    END; -- of RemoteCopy     ReduceCredentials: PUBLIC PROC [    c: Connection, op: FileTransferOps.Operation,    fileName: LONG STRING, origLevel: FileTransferOps.CredentialLevel] = {    SELECT c.level FROM      primary => {        verb: STRING;        SELECT op FROM          enumerate => verb ¬ "enumerate "L;          rename => verb ¬ "rename "L;          delete => verb ¬ "delete "L;          localToRemote => verb ¬ "store file on "L;          retrieveStream, readNext, get => verb ¬ "retrieve stream from "L;          storeStream => verb ¬ "store stream on "L;          ENDCASE => ERROR Error[c, unknown];        FileTransferUtils.Post[	  c, fatal, "  Insufficient access to "L, verb, fileName, CR];        IF origLevel = primary THEN ERROR Error[c, skipOperation]	ELSE ERROR Error[c, illegalConnect]};      emptyConnectPassword => c.level ¬ primary;      secondary =>        IF c.secondary.password = NIL THEN c.level ¬ primary        ELSE {c.secondary.password.length ¬ 0; c.level ¬ emptyConnectPassword};      ENDCASE => Error[c, invalidObject];    FileTransferUtils.Post[c, warning, "  Trying different credentials..."L, CR]};        -- Utilities      ResetStreamCatchErrors: PROC [c: Connection] = INLINE {    IF c.serverType = ifs THEN       c.currentPrimitives.streamCatchErrors ¬ c.currentPrimitives.catchErrors};         SetupInfo: PUBLIC PROC [      c: Connection, name: LONG STRING, vfn: VFN, v: BOOLEAN,       w: FileTransferOps.Which ¬ source] = {    c.good[w] ¬ FALSE;     c.info[w]­ ¬ [body: name];    IF vfn = NIL THEN RETURN;    FileTransferUtils.AppendVFN[name, vfn, v]};      HasWildCard: PUBLIC PROC [name: LONG STRING] RETURNS [BOOLEAN] = {    IF name=NIL THEN RETURN[FALSE];    FOR i: CARDINAL IN [0..name.length) DO      IF name[i] = '* THEN RETURN[TRUE]; ENDLOOP;    RETURN[FALSE]};      ShowDestination: PUBLIC PROC [c: Connection, vfn: VFN, name: LONG STRING] = {    FileTransferUtils.Post[c, terse, " to "L];    SELECT TRUE FROM      vfn = NIL => NULL;      String.Empty[vfn.directory] => NULL;      vfn.directory[vfn.directory.length - 1] # '> =>         FileTransferUtils.Post[c, terse, vfn.directory, ">"L];      ENDCASE => FileTransferUtils.Post[c, terse, vfn.directory];    FileTransferUtils.Post[c, terse, name]};        NSHost: PROC [host: LONG STRING] RETURNS [BOOLEAN] = {    IF String.Empty[host] THEN RETURN[FALSE];    FOR i: CARDINAL IN [0..host.length) DO      IF host[i] = ': THEN RETURN[TRUE]; ENDLOOP;    RETURN[FALSE]};  PupHost: PROC [host: LONG STRING] RETURNS [BOOLEAN] = {    IF String.Empty[host] THEN RETURN[FALSE];    FOR i: CARDINAL IN [0..host.length) DO      IF host[i] = '% THEN RETURN[TRUE]; ENDLOOP;    RETURN[FALSE]};  FileTransferToMFileType: PUBLIC PROC [tFT: FileTransfer.FileType]    RETURNS [MFile.Type] = {    RETURN [    SELECT tFT FROM      unknown   => unknown,      text => text,      binary => binary,      directory => directory,     ENDCASE => null ]};       -- stream stuff        ValidStream: PUBLIC PROC [    sh: Stream.Handle, newOp: FileTransferOps.Operation ¬ null]       RETURNS [ft: FileTransferOps.FTHandle, stream: Stream.Handle] = {    ft ¬ LOOPHOLE[sh];    IF ft # NIL AND ft.seal = FileTransferOps.StreamSeal THEN stream ¬ ft.stream    ELSE ERROR Error[NIL, notAStream];    IF newOp # null THEN ft.op ¬ newOp};      MyGetTimeout: PUBLIC Stream.GetTimeoutProcedure =    BEGIN    ERROR Stream.InvalidOperation    END;      MySetTimeout: PUBLIC Stream.SetTimeoutProcedure =    BEGIN    ERROR Stream.InvalidOperation    END;  MyGetPosition: Stream.GetPositionProcedure = {    stream: Stream.Handle = ValidStream[sH].stream;    RETURN[stream.getPosition[stream]]};      MySetPosition: Stream.SetPositionProcedure = {    stream: Stream.Handle = ValidStream[sH].stream;    stream.setPosition[stream, position]};      MyGetByte: Stream.GetByteProcedure = {    ft: FileTransferOps.FTHandle;    stream: Stream.Handle;    Inner: PROC [c: Connection] = {byte ¬ stream.getByte[stream]};    [ft: ft, stream: stream] ¬ ValidStream[sH, get];    Umbrella[ft, Inner]};      MyGetWord: Stream.GetWordProcedure = {    ft: FileTransferOps.FTHandle;    stream: Stream.Handle;    Inner: PROC [c: Connection] = {word ¬ stream.getWord[stream]};    [ft: ft, stream: stream] ¬ ValidStream[sH, get];    Umbrella[ft, Inner]};      MyGet: Stream.GetProcedure = {    ft: FileTransferOps.FTHandle;    stream: Stream.Handle;    Inner: PROC [c: Connection] = {     [bytesTransferred: bytesTransferred, why: why, sst: sst] ¬        stream.get[stream, block, options]};    [ft: ft, stream: stream] ¬ ValidStream[sH, get];    Umbrella[ft, Inner]};      MyDelete: Stream.DeleteProcedure = {    ft: FileTransferOps.FTHandle;    stream: Stream.Handle;    p: LONG POINTER TO ARRAY [0..SIZE[FileTransferOps.FTObject]) OF CARDINAL =       LOOPHOLE[sH];    [ft: ft, stream: stream] ¬ ValidStream[sH];    IF stream # NIL THEN stream.delete[stream];    IF ft.data # NIL AND ft.free # NIL THEN ft.free[ft, ft.data];    String.FreeString[heap, ft.file];    ft.conn.stream ¬ NIL;    p­ ¬ ALL[0];    FileTransferOps.z.FREE[@ft]};      MyPutByte: Stream.PutByteProcedure = {ERROR Stream.InvalidOperation};  MyPutWord: Stream.PutWordProcedure = {ERROR Stream.InvalidOperation};  MyPut: Stream.PutProcedure = {ERROR Stream.InvalidOperation};  MyGetSST: Stream.GetSSTProcedure = {ERROR Stream.InvalidOperation};  MySetSST: Stream.SetSSTProcedure = {ERROR Stream.InvalidOperation};  MySendAttention: Stream.SendAttentionProcedure = {ERROR Stream.InvalidOperation};  MyWaitAttention: Stream.WaitAttentionProcedure = {ERROR Stream.InvalidOperation};  MySendNow: Stream.SendNowProcedure = {ERROR Stream.InvalidOperation};    CreateFT: PUBLIC PROC [      c: Connection, p: FileTransferOps.RetrieveStreamCommand, file: LONG STRING]     RETURNS [ft: FileTransferOps.FTHandle] = {    ft ¬ FileTransferOps.z.NEW[FileTransferOps.FTObject ¬ [      object: [        options: Stream.defaultInputOptions,        getByte: MyGetByte, putByte: MyPutByte,        getWord: MyGetWord, putWord: MyPutWord, get: MyGet, put: MyPut,        getSST: MyGetSST, setSST: MySetSST, sendNow: MySendNow,        sendAttention: MySendAttention, waitAttention: MyWaitAttention,        delete: MyDelete, getPosition: MyGetPosition, setPosition: MySetPosition,        getTimeout: MyGetTimeout, setTimeout: MySetTimeout, clientData: NIL],       conn: c, veto: p.veto, dates: p.dates, file: file, data: NIL, free: NIL,      retrieveFile: FALSE, stream: NIL, op: ]]};               -- Connection procs  CheckAbort: PUBLIC PROC [c: Connection] = {    SELECT TRUE FROM      c.abort = NIL => IF UserInput.UserAbort[NIL] THEN ERROR ABORTED;      c.abort[c.clientData] => ERROR ABORTED;      ENDCASE};  Post: PUBLIC PROC [    c: Connection, level: Severity, s1, s2, s3, s4: LONG STRING ¬ NIL] = {    IF c.post = NIL THEN RETURN; c.post[c.clientData, level, s1, s2, s3, s4]};  ShowProgress: PUBLIC PROC [c: Connection] = {    IF c.progress # NIL THEN c.progress[c.clientData]};  Unknown: PUBLIC PROC [    c: Connection, err, proc: LONG STRING, s1, s2: LONG STRING ¬ NIL] = {    Post[c, fatal, "Unexpected "L,     IF c.serverType = ns THEN "NS"L ELSE "STP"L, " error in "L, proc];     Post[c, fatal, ": "L, err, s1, s2]};  Validate: PUBLIC PROC [c: Connection] = {    IF c = NIL OR c.password # FileTransferOps.ConnectionPassword THEN      ERROR Error[c, invalidObject]};        CheckForPupOrNS: PROC [c: Connection, type: ServerType] = {    OPEN FileTransferOps;   -- handle loading and unloading of each protocol;    SELECT  type FROM      ns => {        IF (NSPrimitives#NIL AND c.nsPrimitives=NIL) OR	 (NSPrimitives=NIL AND c.nsPrimitives#NIL)        THEN c.nsPrimitives ¬ NSPrimitives;	IF NSPrimitives = NIL THEN {	  Post[c, fatal, "NSFileTransfers not loaded!"L, CR];	  ERROR Error[c, skipOperation]}};      ifs => {         IF (PupPrimitives#NIL AND c.pupPrimitives=NIL) OR	 (PupPrimitives=NIL AND c.pupPrimitives#NIL)        THEN c.pupPrimitives ¬ PupPrimitives;        IF PupPrimitives = NIL THEN {	  Post[c, fatal, "PupFileTransfers not loaded!"L, CR];	  ERROR Error[c, skipOperation]}}      ENDCASE};  -- Feedback  ShowBytes: PUBLIC PROC [      c: Connection, bytes, time: LONG CARDINAL, verb: LONG STRING] = {    s1: STRING ¬ [16];    s2: STRING ¬ [16];    String.AppendLongDecimal[s1, bytes];    IF bytes # c.info[source].size THEN {      String.AppendLongDecimal[s2, c.info[source].size];      FileTransferUtils.Post[c, fatal, s1, " bytes "L, verb, " (file size = "L];      FileTransferUtils.Post[c, fatal, s2, " bytes!)"L]}    ELSE FileTransferUtils.Post[c, verbose, s1, " bytes"L];    WriteRate[c, bytes, time]};    WriteRate: PUBLIC PROC [c: Connection, bytes, pulses: LONG CARDINAL] = {    s: STRING ¬ [16];    t: LONG CARDINAL = System.PulsesToMicroseconds[[pulses]]/100000;    IF t = 0 THEN {Post[c, verbose, CR]; RETURN};    String.AppendLongDecimal[s, ((bytes*160)/t + 1)/2];    Post[c, verbose, " ("L, s, " bits/sec)"L]};  WriteDate: PUBLIC PROC [c: Connection, which: FileTransferOps.Which] = {    s: STRING ¬ [22];    Time.Append[      s: s, unpacked: Time.Unpack[c.info[which].create],      zone: TRUE, zoneStandard: ANSI];    Post[c, terse, "["L, s, "]"L]};  -- Initialization    z: PUBLIC UNCOUNTED ZONE ¬ Heap.Create[      initial: 2, increment: 1, swapUnitSize: 1,      largeNodeThreshold: LAST[Heap.NWords], maxSize: 20,      ownerChecking: TRUE, checking: TRUE];  -- ** DEBUGGING PURPOSES ** --  heap: UNCOUNTED ZONE = Heap.systemZone;    SetPrimitive: PUBLIC PROC [    type: ServerType, objectAddress: FileTransferOps.PrimitivesHandle] = {    SELECT type FROM     ns => NSPrimitives ¬ objectAddress;     ifs => PupPrimitives ¬ objectAddress;     local => LocalPrimitives ¬ objectAddress    ENDCASE};    PupPrimitives,   NSPrimitives,   LocalPrimitives:  PUBLIC FileTransferOps.PrimitivesHandle ¬ NIL;  FileTransferOps.StartPup[ !     Runtime.ControlFault, Runtime.UnboundProcedure => CONTINUE];  FileTransferOps.StartNS[ !     Runtime.ControlFault, Runtime.UnboundProcedure => CONTINUE];      END.
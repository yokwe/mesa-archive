-- File: ExecsC.mesa - last edit:-- Riggle.PA           24-Jul-86  9:40:22-- Copyright (C) 1981, 1982, 1983, 1984 , 1986 by Xerox Corporation. All rights reserved. -- File: ExecsC.mesa - last edited by:-- PXK    : 	4-Jan-82 18:23:06-- SXW   :	13-Jul-81  8:40:43-- BXM  :	19-Nov-81 12:49:42-- Mark:	 4-Jun-81 17:24:29-- JGS:	20-Aug-81 16:53:58-- LXR    :	17-Jan-84 11:34:36-- SXS   :	 1-Mar-82 17:14:30-- RXR   :	 9-Jun-83 14:37:06-- BTL  :	26-Feb-82 18:57:36-- RXJ     :	21-Nov-82 13:15:49-- AXD    :	24-Apr-84 12:02:31-- RSF      :	17-Aug-83 16:16:40-- BGY     :	 9-Nov-83 14:44:42-- DWR   :	 21-May-85 16:45:15DIRECTORY  Ascii USING [BS, ControlA, ControlC, ControlW, CR, DEL, ESC, NUL, SP],  Exec USING [    AddCommand, CheckForAbort, ExecProc, FreeTokenString, GetToken, GetTTY,    Handle, Object, OutputProc, PutChar, ReleaseTTY],  ExecInternal USING [    clientVolume, Do, MapClientVolumeNameToID, Object, useBackground,    volumeLabel],  ExecUtilities USING [],  File USING [File, ID, GetSize],  FileName USING [    FreeFilename, PackFilename, ResetVFN,     UnpackFilename, VirtualFilenameObject],  Heap USING [systemZone],  Format USING [CR, Date, Line, LongDecimal, Octal, StringProc],  MFile USING [    Acquire, AppendErrorMessage, Copy, CopyProperties, Delete,     DeleteWhenReleased, dontRelease,    Error, EnumerateDirectory, EnumerateProc, GetCreateDate, GetFullName,     GetProperties, GetTimes, GetType, Handle, ReadOnly, Release, Rename,     SetTimes, Type],  MStream USING [    Copy, Error, GetFile, GetLength, Handle, ReadOnly, SetLength, WriteOnly],  MVolume USING [CloseAborted],  Process USING [Detach, Yield],  Profile USING [GetDefaultDomain, GetDefaultOrganization, GetDefaultRegistry, GetUser, SetDefaultDomain, SetDefaultOrganization, SetDefaultRegistry, SetUser, String],  SpecialMFile USING [AcquireID, GetCapaWithAccess],  SpecialVolume USING [Access, OpenVolume],  Stream USING [EndOfStream, GetChar, Handle],  String USING [    AppendChar, AppendCharAndGrow, AppendString, CopyToNewString, Empty,    Equal, Equivalent, FreeString, InvalidNumber, Length, LowerCase, MakeString, Replace,    StringBoundsFault, StringToOctal],  StringLookUp USING [InTable, TableDesc],  System USING [GreenwichMeanTime],  Time USING [defaultTime, Packed],  TTY USING [GetChar, Handle, PutChar, PutString, RemoveCharacters, Rubout],  UserTerminal USING [BlinkDisplay],  Volume USING [    Close, GetStatus, GetLabelString, GetNext, GetType, ID, maxNameLength,    NeedsScavenging, NotOpen, nullID, systemID, Type];ExecsC: PROGRAM  IMPORTS    Exec, ExecInternal, File, FileName, Format, Heap, MFile, MStream,     MVolume, Process,    Profile, SpecialMFile, SpecialVolume, Stream, String, StringLookUp,    TTY, UserTerminal, Volume  EXPORTS Exec, ExecInternal, ExecUtilities  SHARES File =  BEGIN  z: UNCOUNTED ZONE = Heap.systemZone;  AbsToRep: PROC [abs: Exec.Handle]    RETURNS [rep: LONG POINTER TO ExecInternal.Object] = {rep ¬ LOOPHOLE[abs]};  Cough: PROC [    post: Format.StringProc, complaint: LONG STRING, prelude: LONG STRING ¬ NIL] =    {IF prelude # NIL THEN post[prelude]; post[complaint]; Format.CR[post]};  GetTokenDiscardSwitches: PROC [h: Exec.Handle] RETURNS [token: LONG STRING] = {    temp: LONG STRING;    [token, temp] ¬ Exec.GetToken[h];    [] ¬ Exec.FreeTokenString[temp]};  Type: Exec.ExecProc = {    name: LONG STRING ¬ NIL;    sh: Stream.Handle;    Write: Format.StringProc = Exec.OutputProc[h];    DO      ENABLE UNWIND => z.FREE[@name];      name ¬ GetTokenDiscardSwitches[h];      IF name = NIL THEN EXIT;      sh ¬ MStream.ReadOnly[name, [] ! MStream.Error => {sh ¬ NIL; CONTINUE}];      IF sh = NIL THEN {        Cough[post: Write, prelude: "File not available "L, complaint: name];        outcome ¬ warning;        z.FREE[@name];        LOOP};      Write["Contents of file "L];      Write[name];      Write["      (Length = "L];      Format.LongDecimal[Write, MStream.GetLength[sh]];      Write[" bytes)"L];      Format.CR[Write];      Format.CR[Write];      DO        Exec.PutChar[h, Stream.GetChar[sh ! Stream.EndOfStream => EXIT]];        IF Exec.CheckForAbort[h] THEN {          z.FREE[@name];          sh.delete[sh];          Format.CR[Write];          Write["Aborted..."L];          RETURN[abort]};        ENDLOOP;      z.FREE[@name];      sh.delete[sh];      Format.CR[Write];      -- ExecInternal.Twiddles[h];      Process.Yield[];      IF Exec.CheckForAbort[h] THEN {        Format.CR[Write]; Write["Aborted..."L]; RETURN[abort]};      ENDLOOP};  Delete: Exec.ExecProc = {    name: LONG STRING ¬ NIL;    Write: Format.StringProc = Exec.OutputProc[h];    fh: MFile.Handle ¬ NIL;    DO      ENABLE        UNWIND => {z.FREE[@name]; 	IF fh # NIL THEN {MFile.Release[fh]; fh ¬ NIL}};      IF fh # NIL THEN MFile.Release[fh];      z.FREE[@name];      Process.Yield[];      IF Exec.CheckForAbort[h] THEN {        Format.CR[Write]; Write["Aborted..."L]; RETURN[abort]};      name ¬ GetTokenDiscardSwitches[h];      IF name = NIL THEN EXIT;      fh ¬ MFile.Acquire[        name: name, access: delete, release: MFile.dontRelease !        MFile.Error => {	  msg: STRING ¬ [100];	  MFile.AppendErrorMessage[msg, code, file];          Cough[post: Write, complaint: msg];          LOOP}];      MFile.Delete[        fh !        MFile.Error => {          msg: STRING ¬ [100];	  MFile.AppendErrorMessage[msg, code, file];  	  Cough[post: Write, complaint: msg];          LOOP}];      Write[name];      fh ¬ NIL;      Write[" ...deleted."L];      Format.CR[Write];      ENDLOOP};  Copy: Exec.ExecProc = {    ENABLE UNWIND => NULL;    newName, oldName: LONG STRING ¬ NIL;    newStream, oldStream: Stream.Handle ¬ NIL;    length, stored: LONG CARDINAL;    created: Time.Packed ¬ Time.defaultTime;    numberOfFiles: CARDINAL ¬ 0;    Write: Format.StringProc = Exec.OutputProc[h];    Cleanup: PROC = {      z.FREE[@newName];      z.FREE[@oldName];      IF newStream # NIL THEN newStream.delete[newStream];      IF oldStream # NIL THEN oldStream.delete[oldStream]};    BEGIN ENABLE UNWIND => Cleanup[];    newName ¬ GetTokenDiscardSwitches[h];    oldName ¬ GetTokenDiscardSwitches[h];    IF ~String.Equal[oldName, "\137"L] AND ~String.Equal[oldName, "¬"L] THEN {      Write["File names not separated by ¬."L];      IF ~Confirm[h] THEN {        z.FREE[@oldName];        z.FREE[@newName];        RETURN[error]}}    ELSE {z.FREE[@oldName]; oldName ¬ GetTokenDiscardSwitches[h]};    WHILE oldName # NIL DO      numberOfFiles ¬ numberOfFiles + 1;      oldStream ¬ MStream.ReadOnly[        oldName, [] !        MStream.Error => {          Write["Can't open old file "L];          Write[oldName];          Write[". Continuing with next file...\n	  "L];          oldStream ¬ NIL;          CONTINUE}];      IF oldStream # NIL THEN {        IF numberOfFiles = 1 THEN           created ¬ MStream.GetFile[oldStream].GetTimes[].create;        length ¬ MStream.GetLength[oldStream];        IF newStream = NIL THEN {          newStream ¬ MStream.WriteOnly[            newName, [], MFile.GetType[MStream.GetFile[oldStream]] !            MStream.Error => {Write["Can't open new file"L]; CONTINUE}];          IF newStream = NIL THEN {oldStream.delete[oldStream]; RETURN[error]};          MStream.SetLength[newStream, 0]};        DO          stored ¬ MStream.Copy[to: newStream, from: oldStream, bytes: length !	    MFile.Error => {	      msg: STRING ¬ [100];	      MFile.AppendErrorMessage[msg, code, file];	      Write[msg]; GOTO error}];          IF numberOfFiles = 1 THEN	    MFile.CopyProperties[	      from: MStream.GetFile[oldStream],	      to: MStream.GetFile[newStream]];	  IF stored # length THEN length ¬ length - stored ELSE EXIT;          ENDLOOP;        Write[oldName];        Write[" copied to "L];        Write[newName];        Write["  "L];        oldStream.delete[oldStream];        oldStream ¬ NIL};      z.FREE[@oldName];      oldName ¬ GetTokenDiscardSwitches[h];      ENDLOOP;    IF newStream # NIL AND numberOfFiles = 1 AND created # Time.defaultTime THEN       MFile.SetTimes[file: MStream.GetFile[newStream], create: created];    Cleanup[];    EXITS error => {Cleanup[]; RETURN[error]};    END};  Rename: Exec.ExecProc = {    newName, oldName: LONG STRING ¬ NIL;    Write: Format.StringProc = Exec.OutputProc[h];    Cleanup: PROC = INLINE {z.FREE[@newName]; z.FREE[@oldName]};    BEGIN    ENABLE UNWIND => Cleanup[];    oldName ¬ GetTokenDiscardSwitches[h];    newName ¬ GetTokenDiscardSwitches[h];    IF String.Equal[newName, "\137"L] OR String.Equal[newName, "¬"L] THEN {      z.FREE[@newName];      newName ¬ oldName;      oldName ¬ GetTokenDiscardSwitches[h]};    IF String.Empty[oldName] OR String.Empty[newName] THEN {      Write["Empty file name!"L]; GOTO quit};    BEGIN OPEN MFile;    fh: MFile.Handle ¬ Acquire[      name: oldName, access: rename, release: dontRelease ! Error => GOTO out];    Rename[file: fh, newName: newName ! Error => {Release[fh]; GOTO out}];    Release[fh];    EXITS out => {Write["Unable to complete rename."L]; GOTO quit}    END;    Write[oldName];    Write[" renamed to "];    Write[newName];    Format.CR[Write];    Cleanup[];    EXITS quit => {Cleanup[]; RETURN[error]};    END};  Confirm: PUBLIC PROC [h: Exec.Handle] RETURNS [yes: BOOLEAN] = {    tty: TTY.Handle ¬ Exec.GetTTY[h];    TTY.PutString[tty, " Confirm[Y/N]: "L];    DO      SELECT TTY.GetChar[tty] FROM        'y, 'Y => {TTY.PutChar[tty, 'Y]; yes ¬ TRUE; EXIT};        'n, 'N => {TTY.PutChar[tty, 'N]; yes ¬ FALSE; EXIT};        Ascii.ControlC, Ascii.DEL => {Exec.ReleaseTTY[tty]; ERROR ABORTED};        ENDCASE => TTY.PutChar[tty, '?];      ENDLOOP;    TTY.PutChar[tty, Ascii.CR];    Exec.ReleaseTTY[tty]};  Registry: Exec.ExecProc = {    registry: STRING ¬ [80];    GetIt: PROC [name: Profile.String] = {      String.AppendString[to: registry, from: name]};    Profile.GetDefaultRegistry[GetIt];    GetRegistry[      h, registry ! TTY.Rubout => {outcome ¬ abort; GOTO quit};      String.StringBoundsFault => {        Exec.OutputProc[h]["String too long! "L]; outcome ¬ error; GOTO quit}];    Profile.SetDefaultRegistry[registry];    EXITS quit => NULL};  Clearinghouse: Exec.ExecProc = {    GetUserStuff: PROC [name, password: Profile.String] = {      user ¬ String.CopyToNewString[name, z];      pass ¬ String.CopyToNewString[password, z]};    GetDomain: PROC [name: Profile.String] = {      String.AppendString[to: domain, from: name]};    GetOrganization: PROC [name: Profile.String] = {      String.AppendString[to: organization, from: name]};    domain: STRING ¬ [80];    organization: STRING ¬ [40];    user: LONG STRING;    pass: LONG STRING;    Profile.GetDefaultDomain[GetDomain];    Profile.GetDefaultOrganization[GetOrganization];    Profile.GetUser[GetUserStuff, none];    GetDomainAndOrganization[      h, domain, organization ! TTY.Rubout => {outcome ¬ abort; GOTO quit};      String.StringBoundsFault => {        Exec.OutputProc[h]["String too long! "L]; outcome ¬ error; GOTO quit}];    Profile.SetDefaultDomain[domain];    Profile.SetDefaultOrganization[organization];    Process.Detach[FORK DoSet[user, pass]]; -- to force an authentication    EXITS quit => NULL};  DoSet: PROC [user, pass: LONG STRING] = {    Profile.SetUser[user, pass];    String.FreeString[z, user];    String.FreeString[z, pass];  };  GetRegistry: PROC [    h: Exec.Handle, registry: LONG STRING, prompt: LONG STRING ¬ NIL] = {    OPEN Ascii;    c: CHARACTER;    tty: TTY.Handle = Exec.GetTTY[h];    BEGIN ENABLE UNWIND => Exec.ReleaseTTY[tty];    Write: Format.StringProc = Exec.OutputProc[h];    TTY.PutString[tty, IF prompt = NIL THEN "Registry: "L ELSE prompt];    TTY.PutString[tty, registry];    c ¬ TTY.GetChar[tty];    SELECT c FROM      NUL, CR, ESC => NULL;      BS, ControlA, ControlW => GetCLString[tty, registry, c];      DEL, ControlC => ERROR ABORTED;      ENDCASE => {        TTY.RemoveCharacters[tty, registry.length];        registry.length ¬ 0;        GetCLString[tty, registry, c]};    END;    Exec.ReleaseTTY[tty]};     GetDomainAndOrganization: PROC [    h: Exec.Handle, domain, organization: LONG STRING, prompt: LONG STRING ¬ NIL] = {    OPEN Ascii;    c: CHARACTER;    tty: TTY.Handle = Exec.GetTTY[h];    BEGIN ENABLE UNWIND => Exec.ReleaseTTY[tty];    Write: Format.StringProc = Exec.OutputProc[h];    TTY.PutString[tty, IF prompt = NIL THEN "Domain: "L ELSE prompt];    TTY.PutString[tty, domain];    c ¬ TTY.GetChar[tty];    SELECT c FROM      NUL, CR, ESC => NULL;      BS, ControlA, ControlW => GetCLString[tty, domain, c];      DEL, ControlC => ERROR ABORTED;      ENDCASE => {        TTY.RemoveCharacters[tty, domain.length];        domain.length ¬ 0;        GetCLString[tty, domain, c]};    TTY.PutString[tty, "\nOrganization: "L];    TTY.PutString[tty, organization];    c ¬ TTY.GetChar[tty];    SELECT c FROM      NUL, CR, ESC => NULL;      BS, ControlA, ControlW => GetCLString[tty, organization, c];      DEL, ControlC => ERROR ABORTED;      ENDCASE => {        TTY.RemoveCharacters[tty, organization.length];        organization.length ¬ 0;        GetCLString[tty, organization, c]};    END;    Exec.ReleaseTTY[tty]};     LogIn: Exec.ExecProc = {    GetUserName: PROC [name, password: Profile.String] = {      String.AppendString[to: user, from: name]};    user: LONG STRING ¬ String.MakeString[z, 40];    password: LONG STRING ¬ String.MakeString[z, 40];    Profile.GetUser[GetUserName, none];    GetNameandPassword[      h, user, password ! TTY.Rubout => {outcome ¬ abort; GOTO quit};      String.StringBoundsFault => {        Exec.OutputProc[h]["String too long! "L]; outcome ¬ error; GOTO quit}];    Process.Detach[FORK DoSet[user, password]];    EXITS quit => NULL};  GetNameandPassword: PUBLIC PROC [    h: Exec.Handle, name, password: LONG STRING, prompt: LONG STRING ¬ NIL] = {    OPEN Ascii;    c: CHARACTER;    tty: TTY.Handle = Exec.GetTTY[h];--    noCurrentPassword: BOOLEAN ¬ FALSE;    BEGIN ENABLE UNWIND => Exec.ReleaseTTY[tty];--    CheckPassword: PROC [name, password: LONG STRING] = {--      noCurrentPassword ¬ password = NIL OR password.length = 0};    Write: Format.StringProc = Exec.OutputProc[h];    TTY.PutString[tty, IF prompt = NIL THEN "User: "L ELSE prompt];    TTY.PutString[tty, name];    c ¬ TTY.GetChar[tty];    SELECT c FROM      NUL, CR, SP, ESC => NULL;      BS, ControlA, ControlW => GetString[tty, name, c, TRUE];      DEL, ControlC => ERROR ABORTED;      ENDCASE => {        TTY.RemoveCharacters[tty, name.length];        name.length ¬ 0;        GetString[tty, name, c, TRUE]};    TTY.PutString[tty, " Password: "L];    c ¬ TTY.GetChar[tty];    SELECT c FROM      DEL, ControlC => ERROR ABORTED;    ENDCASE;    GetString[tty, password, c, FALSE];--    Profile.GetUser[CheckPassword];--    IF noCurrentPassword THEN Profile.SetUser[name: name, password: password];    END;    Exec.ReleaseTTY[tty]};  GetString: PROC [    tty: TTY.Handle, s: LONG STRING, c: CHARACTER, echoed: BOOLEAN] = {    OPEN Ascii;    DO      SELECT c FROM        NUL, CR, SP => EXIT;        BS, ControlA =>          IF s.length > 0 THEN            BEGIN TTY.RemoveCharacters[tty, 1]; s.length ¬ s.length - 1; END;        DEL, ControlC => ERROR ABORTED;        ControlW =>          BEGIN TTY.RemoveCharacters[tty, s.length]; s.length ¬ 0; END;        ENDCASE => {          IF s.length = s.maxlength THEN UserTerminal.BlinkDisplay[]          ELSE TTY.PutChar[tty, IF echoed THEN c ELSE '*];	  IF c = '' THEN {c ¬ TTY.GetChar[tty]; TTY.RemoveCharacters[tty, 1]; TTY.PutChar[tty, IF echoed THEN c ELSE '*]};          String.AppendChar[s, c]};      c ¬ TTY.GetChar[tty];      ENDLOOP};  GetCLString: PROC [    tty: TTY.Handle, s: LONG STRING, c: CHARACTER] = {    OPEN Ascii;    DO      SELECT c FROM        NUL, CR => EXIT;        BS, ControlA =>          IF s.length > 0 THEN            BEGIN TTY.RemoveCharacters[tty, 1]; s.length ¬ s.length - 1; END;        DEL, ControlC => ERROR ABORTED;        ControlW => {	  seenANonSP: BOOLEAN ¬ FALSE;	  charsToDelete: CARDINAL ¬ 0;	  FOR i:CARDINAL DECREASING IN [0..s.length) DO	    IF s[i] = SP THEN { 	      IF seenANonSP THEN {charsToDelete ¬ s.length-i-1; EXIT};	    } ELSE seenANonSP ¬ TRUE;	  ENDLOOP;	  IF charsToDelete = 0 THEN charsToDelete ¬ s.length;	  TTY.RemoveCharacters[tty, charsToDelete];	  s.length ¬ s.length-charsToDelete;	};        ENDCASE => {          IF s.length = s.maxlength THEN UserTerminal.BlinkDisplay[]          ELSE TTY.PutChar[tty, c];	  IF c = '' THEN {c ¬ TTY.GetChar[tty]; TTY.RemoveCharacters[tty, 1]; TTY.PutChar[tty, c]};          String.AppendChar[s, c]};      c ¬ TTY.GetChar[tty];      ENDLOOP};  FileStat: Exec.ExecProc = {    name: STRING ¬ [500];  -- guess at max for full name    nameParm, switches, temp1: LONG STRING ¬ NIL;    Two: TYPE = RECORD [a, b: UNSPECIFIED];    fID: File.ID;    fileID: POINTER TO Two = @LOOPHOLE[fID, Two];    fh: MFile.Handle;    type: MFile.Type;    byteLength, pageLength: LONG CARDINAL;    dp, wp, rp: BOOLEAN;    file: File.File;    aborted: BOOLEAN ¬ FALSE;    readDate, writeDate, createDate: System.GreenwichMeanTime;    Write: Format.StringProc = Exec.OutputProc[h];    GetNext: PROC RETURNS [result: UNSPECIFIED] = {      temp1 ¬ GetTokenDiscardSwitches[h];      IF temp1 = NIL THEN {        Cough[post: Write, prelude: "Invalid parameters "L, complaint: NIL];        ERROR ABORTED};      IF temp1[temp1.length - 1] = ', THEN temp1.length ¬ temp1.length - 1;      result ¬ String.StringToOctal[        temp1 !        String.InvalidNumber => {          Cough[post: Write, prelude: "Invalid number "L, complaint: temp1];          ERROR ABORTED}];      String.FreeString[z, temp1]};    GetFH: PROC RETURNS [fh: MFile.Handle] = {      volName: LONG STRING ¬ NIL;      BEGIN ENABLE UNWIND => String.FreeString[z, volName];      volumeID: Volume.ID ¬ Volume.nullID;      [volName, ] ¬ Exec.GetToken[h];      IF String.Length[volName] # 0 THEN {        IF volName[0] = '< THEN {	  FOR i: CARDINAL IN [0..volName.length-1) DO	  volName[i] ¬ volName[i + 1]; ENDLOOP;	  volName.length ¬ volName.length - 1};	IF volName[volName.length] = '> THEN volName.length ¬ volName.length-1;        UNTIL (volumeID ¬ Volume.GetNext[volumeID, ALL[TRUE]]) = Volume.nullID DO          Volume.GetLabelString[volumeID, name];          IF String.Equivalent[volName, name] THEN EXIT;          ENDLOOP};      IF volumeID = Volume.nullID AND String.Length[volName] # 0 THEN  {        Cough[post: Write, complaint: "Unknown volume name"L];	String.FreeString[z, volName];	RETURN[NIL]};      fileID.a ¬ GetNext[];      fileID.b ¬ GetNext[];      String.FreeString[z, volName];      IF volumeID = Volume.nullID THEN volumeID ¬ Volume.systemID; -- use default      fh ¬ SpecialMFile.AcquireID[        id: [fID, volumeID], access: anchor,	  release: MFile.dontRelease ! 	  MFile.Error => {          msg: STRING ¬ [100];          fh ¬ NIL;	  MFile.AppendErrorMessage[msg, code, file];          Cough[post: Write, complaint: msg];          CONTINUE}];      END};    EnumerateFiles: MFile.EnumerateProc = {      done ¬ FALSE;      fh ¬ fileProc[access: anchor, release: MFile.dontRelease];      IF fh = NIL THEN RETURN[TRUE];      IF fullName[0] # '< THEN {MFile.GetFullName[fh, name]; GetStats[name]}      ELSE GetStats[fullName];      IF Exec.CheckForAbort[h] THEN aborted ¬ done ¬ TRUE};    GetStats: PROC [fullName: LONG STRING] = {      [create: createDate, write: writeDate, read: readDate, length: byteLength,        type: type, deleteProtected: dp, writeProtected: wp, readProtected: rp] ¬        MFile.GetProperties[fh, NIL];      file ¬ SpecialMFile.GetCapaWithAccess[fh];      fID ¬ file.fileID;      pageLength ¬ File.GetSize[file];      MFile.Release[fh];      Write[fullName];      Write["   FileID:  "L];      Format.Octal[Write, fileID.a];      Write[", "L];      Format.Octal[Write, fileID.b];      Write["  "];      Format.LongDecimal[Write, byteLength];      Write[" bytes  "L];      Format.LongDecimal[Write, pageLength];      Write[" pages  "L];      Write["type: "L];      Write[        SELECT type FROM          unknown => "unknown"L,          directory => "directory"L,          text => "text"L,          binary => "binary"L,          null => "null"L,          ENDCASE => "GARBAGE!"L];      Write["  "L];      LocalWrite["deleteProtected"L, dp];      LocalWrite["writeProtected"L, wp];      LocalWrite["readProtected"L, rp];      Format.CR[Write];      IF ~rp THEN {        Write[" create: "L];        Format.Date[Write, createDate, dateTime];        Write[" write: "L];        Format.Date[Write, writeDate, dateTime];        Write[" read: "L];        Format.Date[Write, readDate, dateTime];        Format.CR[Write]};      Process.Yield[]};    going: BOOLEAN ¬ FALSE;    LocalWrite: PROC [s: LONG STRING, bool: BOOLEAN] = {      IF bool THEN {IF going THEN Write[", "L]; going ¬ TRUE; Write[s]}};    DO      ENABLE        UNWIND => {          String.FreeString[z, nameParm];          String.FreeString[z, switches];          String.FreeString[z, temp1]};      String.FreeString[z, nameParm];      String.FreeString[z, switches];      [nameParm, switches] ¬ Exec.GetToken[h];      IF nameParm = NIL AND switches = NIL THEN EXIT;      IF Inswitches[switches, 's] THEN {        fh ¬ GetFH[];        IF fh = NIL THEN LOOP;        MFile.GetFullName[fh, name];        GetStats[name]}      ELSE        MFile.EnumerateDirectory[          name: nameParm, proc: EnumerateFiles, which: fileAndDirectories !          MFile.Error => {           msg: STRING ¬ [100];           fh ¬ NIL; 	   MFile.AppendErrorMessage[msg, code, file];           Cough[post: Write, complaint: msg];           CONTINUE}];      IF Exec.CheckForAbort[h] OR aborted THEN {Format.CR[Write]; RETURN[abort]};      ENDLOOP};  Inswitches: PROC [switches: LONG STRING, c: CHARACTER]    RETURNS [on: BOOLEAN ¬ FALSE] = {    inverse: {this, next, no} ¬ no;    t: CHARACTER;    i: CARDINAL;    IF switches = NIL THEN RETURN;    FOR i IN [0..switches.length) DO      SELECT t ¬ String.LowerCase[switches[i]] FROM        IN ['a..'z] => IF t = c THEN RETURN[inverse # this];        '-, '~ => inverse ¬ next;        ENDCASE;      inverse ¬ IF inverse = next THEN this ELSE no;      ENDLOOP};  SnarfFiles: Exec.ExecProc = {    source: CARDINAL = 0;    dest: CARDINAL = 1;    commandNames: ARRAY [source..dest] OF LONG STRING ¬ ["SourceDir"L, "DestDir"L];    commandTable: StringLookUp.TableDesc = DESCRIPTOR[@commandNames, 2];    token, switches: LONG STRING ¬ NIL;    Write: Format.StringProc = Exec.OutputProc[h];    remoteFile, localFile: FileName.VirtualFilenameObject ¬ [NIL, NIL, NIL, NIL];    remoteDir, localDir, remoteName, localName: LONG STRING ¬ NIL;    openedVolume, update, newFile: BOOLEAN ¬ FALSE;    currentVolume, volume: Volume.ID ¬ Volume.nullID;    file: MFile.Handle;    CleanUp: PROC = {      z.FREE[@token];      z.FREE[@switches];      FileName.FreeFilename[remoteName];      remoteName ¬ NIL;      FileName.FreeFilename[localName];      localName ¬ NIL;      FileName.ResetVFN[@remoteFile, TRUE, TRUE, TRUE, TRUE];      FileName.ResetVFN[@localFile, TRUE, TRUE, TRUE, TRUE]};    remoteDir ¬ String.CopyToNewString["<CoPilot>"L, Heap.systemZone];  -- initialize to default    DO      ENABLE        UNWIND => {          CleanUp[];	  z.FREE[@remoteDir];          z.FREE[@localDir];          IF openedVolume THEN            Volume.Close[              currentVolume ! Volume.NeedsScavenging, Volume.NotOpen, MVolume.CloseAborted => CONTINUE]};      IF Exec.CheckForAbort[h] THEN {        outcome ¬ abort; Format.CR[Write]; Write["Aborted..."L]; EXIT};      [token, switches] ¬ Exec.GetToken[h];      IF String.Empty[switches] AND String.Empty[token] THEN EXIT;      IF Inswitches[switches, 'c] THEN {        SELECT StringLookUp.InTable[token, commandTable] FROM          source => {	    z.FREE[@token]; z.FREE[@switches];	    [token, switches] ¬ Exec.GetToken[h];	    IF ~String.Empty[token] AND token[token.length - 1] # '> THEN	      String.AppendCharAndGrow[@token, '>, Heap.systemZone];            z.FREE[@remoteDir];            remoteDir ¬ token;            token ¬ NIL;            Write["Default source directory "L];            Format.Line[Write, remoteDir]};          dest => { 	    z.FREE[@token]; z.FREE[@switches];	    [token, switches] ¬ Exec.GetToken[h];  	    IF ~String.Empty[token] AND token[token.length - 1] # '> THEN	      String.AppendCharAndGrow[@token, '>, Heap.systemZone];            z.FREE[@localDir];            localDir ¬ token;            token ¬ NIL;            Write["Default destination directory "L];            Format.Line[Write, localDir]};          ENDCASE => Write["Illegal command "L];        z.FREE[@token];        z.FREE[@switches];        LOOP};      -- token is file name      update ¬ Inswitches[switches, 'u];      FileName.UnpackFilename[remoteDir, @remoteFile];  -- set defaults      FileName.UnpackFilename[token, @remoteFile];      FileName.UnpackFilename[localDir, @localFile];  -- set defaults      IF Inswitches[switches, 's] THEN {        z.FREE[@token];        z.FREE[@switches];        [token, switches] ¬ Exec.GetToken[h];        FileName.UnpackFilename[token, @localFile]}      ELSE FileName.UnpackFilename[remoteFile.name, @localFile];      remoteName ¬ FileName.PackFilename[vfn: @remoteFile, d: TRUE, n: TRUE];      localName ¬ FileName.PackFilename[vfn: @localFile, d: TRUE, n: TRUE];      volume ¬ GetVolume[remoteName];      SELECT volume FROM        Volume.systemID => {          Write[remoteName];          Write[" is on current volume! not snarfed.\n"L];          CleanUp[];          LOOP};        Volume.nullID => {          Write[remoteName];          Write[" is on an unknown volume! not snarfed.\n"L];          CleanUp[];          LOOP};        currentVolume => NULL;        ENDCASE =>          BEGIN          IF openedVolume THEN {            Volume.Close[              currentVolume ! Volume.NeedsScavenging, Volume.NotOpen => CONTINUE;	          MVolume.CloseAborted => {Write["Volume close aborted!"L]; CONTINUE}];            openedVolume ¬ FALSE;            currentVolume ¬ Volume.nullID};          SELECT Volume.GetStatus[volume] FROM            openRead, openReadWrite => NULL;            unknown, partiallyOnLine, closedAndInconsistent => {              Write[remoteName];              Write[" is on an unknown or inconsistent volume! not snarfed.\n"L];              CleanUp[];              LOOP};            ENDCASE => {              ok: BOOLEAN ¬ TRUE;              SpecialVolume.OpenVolume[volume, read 	        ! Volume.NeedsScavenging => {ok ¬ FALSE; CONTINUE}];              IF ok THEN {openedVolume ¬ TRUE; currentVolume ¬ volume}              ELSE {                Write[remoteName];                Write[" on a volume that needs scavenging.\n"L];                currentVolume ¬ Volume.nullID;                CleanUp[];                LOOP}};          END;      Write["Snarfing "L];      Write[remoteName];      Write[" to "L];      Write[localName];       Write[" ... "L];      file ¬ MFile.ReadOnly[        remoteName, MFile.dontRelease, !        MFile.Error =>          BEGIN          msg: STRING = [100];          MFile.AppendErrorMessage[msg, code, file];          Write[msg];          LOOP;          END];      IF update THEN {        destFile: MFile.Handle  ¬ NIL;	newFile ¬ FALSE;	destFile ¬ MFile.Acquire[localName, anchor, MFile.dontRelease ! 	  MFile.Error => {	    IF code = noSuchFile THEN newFile ¬ TRUE	    ELSE {	      msg: STRING ¬ [100];	      MFile.AppendErrorMessage[msg, code, file];  	      Cough[post: Write, complaint: msg]};	    CONTINUE}];	IF destFile # NIL OR newFile THEN {	  ENABLE MFile.Error => {Write["failed."L]; CONTINUE};	  remoteCreate, localCreate: Time.Packed;	  IF ~newFile THEN {	    remoteCreate ¬ MFile.GetCreateDate[file];	    localCreate ¬ MFile.GetCreateDate[destFile];	    MFile.Release[destFile]};	  IF newFile OR remoteCreate > localCreate THEN {            MFile.Copy[file, localName ! UNWIND => MFile.Release[file]];	    Write["finished.\n"L]}	  ELSE Write["same file. Not snarfed.\n"L]}}      ELSE {        ENABLE {	  MFile.Error => {Write["failed."L]; CONTINUE};	  UNWIND => MFile.Release[file]};	MFile.Copy[file, localName];	Write["finished.\n"L]};      MFile.Release[file];      CleanUp[];      ENDLOOP;    z.FREE[@remoteDir];    z.FREE[@localDir];    IF openedVolume THEN      Volume.Close[        currentVolume ! Volume.NeedsScavenging, Volume.NotOpen, MVolume.CloseAborted => CONTINUE]};  GetVolume: PROC [name: LONG STRING] RETURNS [volume: Volume.ID] = {    volumeName: STRING = [Volume.maxNameLength];    IF String.Empty[name] OR name[0] # '< THEN RETURN[Volume.nullID];    FOR i: CARDINAL IN [1..name.length) DO      IF name[i] = '> THEN EXIT;      IF volumeName.length = Volume.maxNameLength THEN RETURN[Volume.nullID];      String.AppendChar[volumeName, name[i]];      ENDLOOP;    IF volumeName.length = 0 THEN RETURN[Volume.systemID];    RETURN[ExecInternal.MapClientVolumeNameToID[volumeName]]};  DoSetClientVolume: Exec.ExecProc = {    v: LONG STRING ¬ NIL;    v ¬ GetTokenDiscardSwitches[h];    IF v # NIL AND v.length # 0 THEN {      SetClientVolume[v ! UNWIND => z.FREE[@v]];      Exec.OutputProc[h]["Client volume for ClientRun.~ and Run! set to "L];      Format.Line[Exec.OutputProc[h], v]}    ELSE {Exec.OutputProc[h]["No volume name!"L]; outcome ¬ error};    z.FREE[@v]};  SetClientVolume: PUBLIC PROC [v: LONG STRING] = {    Set: PROC = {      String.Replace[@ExecInternal.volumeLabel, v, z];      ExecInternal.clientVolume ¬ ExecInternal.MapClientVolumeNameToID[v]};    ExecInternal.Do[Set]};  ProcessInBackground: PUBLIC Exec.ExecProc = {    Set: PROC = {ExecInternal.useBackground ¬ TRUE};    ExecInternal.Do[Set];    Format.Line[      Exec.OutputProc[h],      "Compiler and Binder will run in background from CommandCentral"L]};  ProcessInNormalPriority: PUBLIC Exec.ExecProc = {    Set: PROC = {ExecInternal.useBackground ¬ FALSE};    ExecInternal.Do[Set];    Format.Line[      Exec.OutputProc[h],      "Compiler and Binder will run in normal from CommandCentral"L]};  Zap: PUBLIC Exec.ExecProc = {    failed: BOOLEAN;    f: MFile.Handle ¬ NIL;    t: LONG STRING ¬ GetTokenDiscardSwitches[h];    Write: Format.StringProc = Exec.OutputProc[h];    WHILE t # NIL DO      f ¬ NIL;      failed ¬ FALSE;      f ¬ MFile.Acquire[t, anchor, [] ! MFile.Error => {            msg: STRING ¬ [100];	    MFile.AppendErrorMessage[msg, code, file];  	    Cough[post: Write, complaint: msg];  	    CONTINUE}];      IF f # NIL THEN        MFile.DeleteWhenReleased[          f !          MFile.Error => {            msg: STRING ¬ [100];	    MFile.AppendErrorMessage[msg, code, file];  	    Cough[post: Write, complaint: msg];	    failed ¬ TRUE;  	    CONTINUE}];      IF f # NIL AND ~failed THEN         Cough[          post: Write, complaint: t,          prelude: "Zapped file "L];      IF failed THEN MFile.Release[f];      t ¬ Exec.FreeTokenString[t];      t ¬ GetTokenDiscardSwitches[h];      ENDLOOP};  OpenVolume: Exec.ExecProc = {    volume, switches: LONG STRING ¬ NIL;    openForWrite, localOpenForWrite: BOOLEAN ¬ FALSE;    sense, ok: BOOLEAN ¬ TRUE;    Write: Format.StringProc = Exec.OutputProc[h];    DO      ENABLE        UNWIND => {          volume ¬ Exec.FreeTokenString[volume];          switches ¬ Exec.FreeTokenString[switches]};      [volume, switches] ¬ Exec.GetToken[h];      IF volume = NIL AND switches = NIL THEN EXIT;      localOpenForWrite ¬ openForWrite;      IF switches # NIL THEN        FOR i: CARDINAL IN [0..switches.length) DO          SELECT switches[i] FROM            '~, '- => sense ¬ ~sense;            'w, 'W => {localOpenForWrite ¬ sense; sense ¬ TRUE};            ENDCASE => sense ¬ TRUE;          ENDLOOP;      IF volume = NIL THEN openForWrite ¬ localOpenForWrite      ELSE {        ok ¬ InternalOpenVolume[          volume, IF localOpenForWrite THEN readWrite ELSE read];        IF ~ok THEN {outcome ¬ error; Write["Could not open volume "L]}        ELSE {          Write["Opened volume "L];          Write[volume];          Write[" for "L];          Format.Line[            Write, IF localOpenForWrite THEN "readWrite"L ELSE "read"L]}};      volume ¬ Exec.FreeTokenString[volume];      switches ¬ Exec.FreeTokenString[switches];      ENDLOOP};  CloseVolume: PUBLIC Exec.ExecProc = {    Write: Format.StringProc = Exec.OutputProc[h];    volume: LONG STRING ¬ GetTokenDiscardSwitches[h];    WHILE volume # NIL DO      IF InternalCloseVolume[        volume ! UNWIND => volume ¬ Exec.FreeTokenString[volume]] THEN        Write["Closed volume "]      ELSE Write["Could not close volume "];      Write[volume];      volume ¬ Exec.FreeTokenString[volume];      volume ¬ GetTokenDiscardSwitches[h];      ENDLOOP};  InternalOpenVolume: PROC [volume: LONG STRING, access: SpecialVolume.Access]    RETURNS [opened: BOOLEAN ¬ TRUE] = {    needToOpen: BOOLEAN ¬ FALSE;    lvID: Volume.ID ¬ ExecInternal.MapClientVolumeNameToID[volume];    newType, oldType: Volume.Type;    IF lvID = Volume.nullID THEN RETURN[FALSE];    IF lvID = Volume.systemID THEN RETURN[TRUE];    newType ¬ Volume.GetType[lvID];    oldType ¬ Volume.GetType[Volume.systemID];    SELECT Volume.GetStatus[lvID] FROM      openRead => IF access = read THEN RETURN[TRUE] ELSE needToOpen ¬ TRUE;      openReadWrite =>        IF access = readWrite THEN RETURN[TRUE] ELSE needToOpen ¬ TRUE;      unknown, partiallyOnLine, closedAndInconsistent => RETURN[FALSE];      closedAndConsistent => needToOpen ¬ TRUE;      ENDCASE => NULL;    IF needToOpen THEN {      -- first make sure the volume to open is of equal or lower type      IF newType > oldType AND access = readWrite THEN RETURN[FALSE];      Volume.Close[lvID ! Volume.NeedsScavenging, Volume.NotOpen => CONTINUE;        MVolume.CloseAborted => {opened ¬ FALSE; CONTINUE}]};    IF ~opened THEN RETURN;    SpecialVolume.OpenVolume[      lvID, access ! Volume.NeedsScavenging => {opened ¬ FALSE; CONTINUE}]};  InternalCloseVolume: PROC [volume: LONG STRING]    RETURNS [succeeded: BOOLEAN ¬ TRUE] = {    lvID: Volume.ID ¬ ExecInternal.MapClientVolumeNameToID[volume];    IF lvID = Volume.nullID OR lvID = Volume.systemID THEN RETURN[FALSE];    Volume.Close[      lvID !      Volume.NeedsScavenging, Volume.NotOpen => {succeeded ¬ FALSE; CONTINUE}]};      CopyHelp: Exec.ExecProc =  {    Exec.OutputProc[h]["Syntax: \"Copy TargetFile ¬ <list of source files>\". Copy concatenates the source files and copies the result into TargetFile.\n"L]};      CloseVolumeHelp: Exec.ExecProc = {    Exec.OutputProc[h]["Syntax: \"CloseVolume <list of volumes to close>\".\n"L]};      DeleteHelp: Exec.ExecProc = {    Exec.OutputProc[h]["Syntax: \"Delete <list of files to delete>\".\n"L]};      FilestatHelp: Exec.ExecProc = {    Exec.OutputProc[h]["Syntax: \"Filestat <list of files>\" or \"Filestat /s <Volume> <list of FileIDs>\", where <Volume> is the name of the volume the file is on, with or without leading and trailing angle brackets, and <FileID> is a pair of octal numbers separated by a comma.\n"L]};      LogInHelp: Exec.ExecProc = {    Exec.OutputProc[h]["Login sets the user name and password. Each of these values is terminated by either a space or carriage return. It will provide the current user name as the user name prompt, but will provide no prompt for the password.\n"L]};      ClearinghouseHelp: Exec.ExecProc = {    Exec.OutputProc[h]["Clearinghouse sets the default domain and organization. Each of these values is terminated by a carriage return.  Spaces are significant.  The program will provide the current default domain and organization in the prompt.\n"L]};      RegistryHelp: Exec.ExecProc = {    Exec.OutputProc[h]["Registry sets the default registry. This value is terminated by a carriage return.  Spaces are significant.  The program will provide the current default registry in the prompt.\n"L]};      OpenVolumeHelp: Exec.ExecProc = {    Exec.OutputProc[h]["Syntax: \"OpenVolume <list of volumes to open>\".Switches: w -- open volume for read-write instead of readOnly.\n"L];    Format.CR[Exec.OutputProc[h]]};      ProcessInBackgroundHelp: Exec.ExecProc = {    Exec.OutputProc[h]["This command does not take parameters and causes the compiler and binder to run at background priority when run from CommandCentral.\n"L]};      ProcessInNormalPriorityHelp: Exec.ExecProc = {    Exec.OutputProc[h]["This command does not take parameters and causes the compiler and binder to run at normal priority when run from CommandCentral.\n"L]};      RenameHelp: Exec.ExecProc = {    Exec.OutputProc[h][      "Syntax: \"Rename TargetFile ¬ SourceFile\" or \"Rename SourceFile TargetFile\"\n"L]};      SetClientVolumeHelp: Exec.ExecProc = {    Exec.OutputProc[h]["Syntax: \"SetClientVolume <Volume>\".This command sets the client volume that will be used by the Run! command in CommandCentral (and by ClientRun).\n"L]};        SnarfHelp: Exec.ExecProc = {    Exec.OutputProc[h]["Snarf copies files from the source volume onto the current volume. The default source volume is CoPilot. The user can specify the following local swithces:    	c	uses the current name as the unique abbreviation of a command name. The permissible commands are SourceDir and DestDir, which set the default values of the source directory and the destination directory, respectively. The name of the directory is the next name on the line.	s	rename this file when copying it: the target name is the next name on the line.	u	copy the file only if the source file is newer than the target file, or if the target file does not exist.Example: to copy MyFile.mesa and MyOtherFile.mesa from logical volume Tajo, renaming MyOtherFile.mesa to Temp.mesa:	Snarf SourceDir/c <Tajo> MyFile.mesa MyOtherFile.mesa/s Temp.mesa\n"L]};        TypeHelp: Exec.ExecProc = {    Exec.OutputProc[h]["Syntax: \"Type <list of files to type>\".\n"L]};        ZapHelp: Exec.ExecProc = {    Exec.OutputProc[h]["Syntax: \"Zap <list of files to zap>\".Zap deletes the listed files even though they may have accidently been locked by another program.\n"L]};        Init: PROC = {    Exec.AddCommand["Copy.~"L, Copy, CopyHelp];    Exec.AddCommand["CloseVolume.~"L, CloseVolume, CloseVolumeHelp];    Exec.AddCommand["Delete.~"L, Delete, DeleteHelp];    Exec.AddCommand["Filestat.~"L, FileStat, FilestatHelp];    Exec.AddCommand["LogIn.~"L, LogIn, LogInHelp];    Exec.AddCommand["Clearinghouse.~"L, Clearinghouse, ClearinghouseHelp];    Exec.AddCommand["Registry.~"L, Registry, RegistryHelp];    Exec.AddCommand["OpenVolume.~"L, OpenVolume, OpenVolumeHelp];    Exec.AddCommand[      "ProcessInBackground.~"L, ProcessInBackground, ProcessInBackgroundHelp];    Exec.AddCommand[      "ProcessInNormalPriority.~"L, ProcessInNormalPriority, ProcessInNormalPriorityHelp];    Exec.AddCommand["Rename.~"L, Rename, RenameHelp];    Exec.AddCommand["SetClientVolume.~"L, DoSetClientVolume, SetClientVolumeHelp];    Exec.AddCommand["Snarf.~"L, SnarfFiles, SnarfHelp];    Exec.AddCommand["Type.~"L, Type, TypeHelp];    Exec.AddCommand["Zap.~"L, Zap, ZapHelp]};  Init[];  END.    
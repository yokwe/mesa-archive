-- Copyright (C) 1981, 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- File: TextSWsA.mesa - last edited: -- SXW:	 9-Jul-81 23:05:30-- Mark:	Oct 1, 1980 4:34 PM-- JGS:		19-Aug-81  7:49:09-- SXS:	21-Sep-82 16:27:27-- PXK:	 7-Dec-83 15:32:01-- BXM:	19-Nov-81 12:22:54-- BGY:	14-Jan-83  9:29:30-- AMD	14-Dec-83 13:20:55-- DWR	 2-May-85 12:08:09-- Create, Destroy and seldom used stuff in hereDIRECTORY  AsciiSink USING [Create],  Caret USING [ResetOnMatch],  Context USING [Create, Destroy, Find],  Heap USING [systemZone],  Menu USING [Create, Handle, Instantiate, ItemObject, Error, Uninstantiate],  Scrollbar USING [Create, Destroy],  Selection USING [ClearOnMatch, SetInsertion],  TextData USING [InsertionObject, Selection, SelectionMode, SelectionObject],  TextDisplay USING [Create, Destroy, Handle, MarkSelection, noPlace],  TextSink USING [ActOn, Handle],  TextSource USING [    Action, ActOn, GetLength, Handle, nullPosition, Position],  TextSW USING [    Access, defaultOptions, DoesNotExist, FindMCR,    JumpInsertionMCR, JumpSelectionMCR, JumpTopMCR, JumpEndMCR, Options,    PositionMCR, SplitMCR, WrapMCR],  TextSWOps USING [    ActivateCaret, DisplayProc, InternalValidate,    lock, margin, MarkSplitBoundary, ModifyInsertionState, NewSplitsObject,    OtherSelections, OtherSelectionsObject, OutputString, RealActOnCaret,    ScrollVertical, Splits, TakeInputFocus, textSWContext, TIPMe, TSWContext,    TSWContextObject, TypeIn, TypeOut, VerticalScrollbar],  TIP: TYPE USING [CreateClient, globalTable],  UserInput USING [    ClearInputFocusOnMatch, CreateStringInOut, DestroyStringInOut,    GetInputFocus, NopStringProc],  UserTerminal USING [BlinkDisplay],  Window USING [Box, Dims, GetBox, Handle, Place, InvalidateBox,    SetClearingRequired, SetDisplayProc];TextSWsA: MONITOR LOCKS TextSWOps.lock  IMPORTS    AsciiSink, Caret, Context, Heap, Menu, Scrollbar, Selection, TextDisplay,    TextSink, TextSource, TextSW, TextSWOps, TIP, UserInput, UserTerminal, Window  EXPORTS TextSW, TextSWOps =  BEGIN OPEN TextSW, TextSWOps;  -- GLOBAL Data and Stuff  LocalFind: PROC [sw: Window.Handle] RETURNS [tsw: TSWContext] = {    IF (tsw ¬ Context.Find[textSWContext, sw]) = NIL THEN      UserTerminal.BlinkDisplay[]};  -- Define Menu and related data  menuItemsCount: CARDINAL = 8;  menuItems: ARRAY [0..menuItemsCount) OF Menu.ItemObject ¬ [    ["Find", FindMCR], ["Split", SplitMCR], ["Position", PositionMCR], [    "J.First", JumpTopMCR], ["J.Insert", JumpInsertionMCR], [    "J.Select", JumpSelectionMCR], ["J.Last", JumpEndMCR], ["Wrap", WrapMCR]];  menu: Menu.Handle = Menu.Create[DESCRIPTOR[menuItems], "Text Ops", TRUE];  z: UNCOUNTED ZONE = Heap.systemZone;    -- PUBLIC Procedures   Create: PUBLIC PROC [    sw: Window.Handle, source: TextSource.Handle, sink: TextSink.Handle ¬ NIL,    options: TextSW.Options ¬ defaultOptions, position: TextSource.Position ¬ 0,    allowTypeIn: BOOLEAN ¬ TRUE, resetLengthOnNewSession: BOOLEAN ¬ FALSE] = {    OPEN TextDisplay;    p: TextDisplay.Handle;    tsw: TSWContext ¬ z.NEW[TSWContextObject ¬ [      sw: sw, splits: NewSplitsObject[NIL, 1, FALSE], output: NIL, scroller: NIL,      caret: on, options: options, allowTypeIn: allowTypeIn, mySink: sink = NIL,      setOnNext: TRUE, startPos: 0, endPos: TextSource.nullPosition,      curPos: TextSource.nullPosition, selection: [0, 0, text, video, FALSE],      insertion: [      0, noPlace, IF options.access = edit THEN triangle ELSE box, FALSE],      otherSels: NIL, oldDims: sw.GetBox.dims]];    p ¬ TextDisplay.Create[      sw, source, IF sink = NIL THEN AsciiSink.Create[NIL] ELSE sink];    IF ~options.wrap THEN p.options.rightBreak ¬ none;    p.options.margin ¬ 0;    p.box ¬ SetBox[sw, options];    p.lineTable[0].pos ¬ position;    p.lineTable.lastPositionPlusOne ¬      IF position = TextSource.nullPosition THEN TextSource.nullPosition      ELSE position + 1;    IF options.access = append THEN TextSWOps.ModifyInsertionState[      tsw: tsw, op: change, pos: source.GetLength];    tsw.splits[0] ¬ p;    Context.Create[textSWContext, tsw, DestroyContext, sw];    TIP.CreateClient[sw, TIP.globalTable[textSW], TIPMe];    IF options.access = append OR options.access = edit THEN      UserInput.CreateStringInOut[        window: sw, out: TypeOut, caretProc: ActivateCaret,	in: IF (allowTypeIn AND options.access = append)	  OR options.access = edit THEN TypeIn ELSE UserInput.NopStringProc];    IF tsw.options.menu THEN menu.Instantiate[sw];    [] ¬ sw.SetDisplayProc[DisplayProc];    IF tsw.options.scrollbar THEN      Scrollbar.Create[sw, vertical, ScrollVertical, VerticalScrollbar];    [] ¬ sw.SetClearingRequired[FALSE];    sw.InvalidateBox[[[0, 0], sw.GetBox.dims]]};  Destroy: PUBLIC PROC [sw: Window.Handle] = {    Menu.Uninstantiate[menu, sw ! Menu.Error => CONTINUE];    Scrollbar.Destroy[sw, vertical];    UserInput.DestroyStringInOut[sw];    Context.Destroy[textSWContext, sw]};  DestroyContext: PUBLIC PROC [tsw: TSWContext, sw: Window.Handle] = {    IF tsw # NIL THEN {      LockedDestroyContext: ENTRY PROC = {        ENABLE UNWIND => NULL;        IF tsw.output # NIL THEN 	  OutputString[tsw, tsw.output]; -- for demon guy        DestroySplits[tsw, 0];        z.FREE[@tsw]};      UserInput.ClearInputFocusOnMatch[tsw.sw];      Caret.ResetOnMatch[tsw];      Selection.ClearOnMatch[tsw];      RealRemoveSecondary[tsw, NIL, FALSE];      Selection.SetInsertion[NIL, NIL, NIL];  -- even if I don't have it!!!      LockedDestroyContext[]}};  GetSource: PUBLIC PROC [sw: Window.Handle]     RETURNS [source: TextSource.Handle] = {    tsw: TSWContext = Context.Find[textSWContext, sw];    IF tsw # NIL AND tsw.splits # NIL AND tsw.splits[0] # NIL      THEN RETURN[tsw.splits[0].source]    ELSE RETURN[NIL]};  GetSink: PUBLIC PROC [sw: Window.Handle] RETURNS [source: TextSink.Handle] = {    tsw: TSWContext = Context.Find[textSWContext, sw];    IF tsw # NIL AND tsw.splits # NIL AND tsw.splits[0] # NIL      THEN RETURN[tsw.splits[0].sink]    ELSE RETURN[NIL]};  IsIt: PUBLIC PROC [sw: Window.Handle] RETURNS [yes: BOOLEAN] = {    RETURN[Context.Find[textSWContext, sw] # NIL]};  SetOptions: PUBLIC PROC [sw: Window.Handle, options: TextSW.Options] = {    tsw: TSWContext = LocalFind[sw];    oldAccess: TextSW.Access;    LockedSetOptions: ENTRY PROC = {      ENABLE UNWIND => NULL;      delta: INTEGER;      reDisplay: BOOLEAN ¬ FALSE;      RealActOnCaret[tsw, clear];      tsw.insertion.place ¬ TextDisplay.noPlace;      oldAccess ¬ tsw.options.access;      IF options.access # tsw.options.access THEN {        IF options.access = append OR options.access = edit THEN {          tsw.options.access ¬ options.access;          IF tsw.options.access = edit THEN tsw.insertion.mode ¬ triangle;	  UserInput.CreateStringInOut[	    window: sw, out: TypeOut, caretProc: ActivateCaret,	    in: IF (tsw.allowTypeIn AND options.access = append)	      OR options.access = edit THEN TypeIn ELSE UserInput.NopStringProc]}        ELSE          IF options.access = read THEN {            tsw.options.access ¬ options.access;	<<  UserInput.ClearInputFocusOnMatch[tsw.sw];   -- Put this outside of monitor and execute it before changing the tsw.options.access.  Cures caret tracks. >> 	     UserInput.DestroyStringInOut[sw]}};      IF options.wrap # tsw.options.wrap THEN {        FOR i: CARDINAL IN [0..tsw.splits.length) DO          tsw.splits[i].options.rightBreak ¬ IF options.wrap THEN word ELSE none;          sw.InvalidateBox[tsw.splits[i].box, isDirty];          IF ~tsw.splits[i].allBetsAreOff THEN            tsw.splits[i].allBetsAreOff ¬ reDisplay ¬ TRUE;          ENDLOOP;        tsw.options.wrap ¬ options.wrap};      IF options.flushTop # tsw.options.flushTop THEN {        delta ¬ IF tsw.options.flushTop THEN margin ELSE -margin;        tsw.splits[0].box.place.y ¬ tsw.splits[0].box.place.y + delta;        tsw.splits[0].box.dims.h ¬ tsw.splits[0].box.dims.h - delta;        sw.InvalidateBox[tsw.splits[0].box, isDirty];        IF ~tsw.splits[0].allBetsAreOff THEN          tsw.splits[0].allBetsAreOff ¬ reDisplay ¬ TRUE;        tsw.options.flushTop ¬ options.flushTop};      IF options.flushBottom # tsw.options.flushBottom THEN {        last: CARDINAL = PRED[tsw.splits.length];        delta ¬ IF tsw.options.flushBottom THEN -margin ELSE margin;        tsw.splits[last].box.dims.h ¬ tsw.splits[last].box.dims.h + delta;        sw.InvalidateBox[tsw.splits[last].box, isDirty];        IF ~tsw.splits[last].allBetsAreOff THEN          tsw.splits[last].allBetsAreOff ¬ reDisplay ¬ TRUE;        tsw.options.flushBottom ¬ options.flushBottom};      IF options.menu # tsw.options.menu THEN {        IF options.menu THEN menu.Instantiate[sw]        ELSE menu.Uninstantiate[sw ! Menu.Error => CONTINUE];        tsw.options.menu ¬ options.menu};      IF reDisplay THEN TextSWOps.InternalValidate[sw]};    IF tsw = NIL THEN RETURN;    IF options.access # tsw.options.access AND options.access = read THEN      UserInput.ClearInputFocusOnMatch[tsw.sw];    LockedSetOptions[];    IF options.access = edit OR (options.access = append AND tsw.allowTypeIn) THEN      IF UserInput.GetInputFocus[] = NIL THEN        TextSWOps.TakeInputFocus[tsw]};  SetSink: PUBLIC ENTRY PROC[sw: Window.Handle, sink: TextSink.Handle] = {    IF sw = NIL OR sink = NIL THEN RETURN;    BEGIN    tsw: TextSWOps.TSWContext ¬ Context.Find[TextSWOps.textSWContext,sw];    p: TextDisplay.Handle;    IF tsw = NIL THEN RETURN;    IF tsw.splits[0].sink = sink THEN RETURN;    tsw.mySink ¬ FALSE;    DestroySplits[tsw, 1];    tsw.splits ¬ TextSWOps.NewSplitsObject[tsw.splits, 1, TRUE];    p ¬ TextDisplay.Create[sw, tsw.splits[0].source, sink];    p.options.margin ¬ 0;    p.box ¬ SetBox[sw, tsw.options];    p.lineTable[0].pos ¬ 0;    p.allBetsAreOff ¬ TRUE;    tsw.splits[0] ¬ p;    sw.InvalidateBox[box:[place:[0,0], dims: sw.GetBox.dims]];    END};      SetSource: PUBLIC ENTRY PROC [    sw: Window.Handle, source: TextSource.Handle,    position: TextSource.Position ¬ 0, reset: BOOLEAN ¬ TRUE] = {    ENABLE UNWIND => NULL;    tsw: TSWContext = Context.Find[textSWContext, sw];    IF tsw # NIL THEN {      RealActOnCaret[tsw, clear];      IF reset THEN {        p: TextDisplay.Handle = tsw.splits[0];        IF tsw.splits.length # 1 THEN {          DestroySplits[tsw, 1];          tsw.splits ¬ NewSplitsObject[tsw.splits, 1, TRUE]};        p.box ¬ SetBox[sw, tsw.options];        p.lineTable[0].pos ¬ position;        p.allBetsAreOff ¬ TRUE;        p.source ¬ source;        TextSWOps.ModifyInsertionState[          tsw: tsw, op: change,          pos: IF tsw.options.access = append THEN source.GetLength ELSE 0];        tsw.insertion.place ¬ TextDisplay.noPlace;        tsw.insertion.marked ¬ FALSE;        tsw.selection.left ¬ tsw.selection.right ¬ 0;        tsw.selection.marked ¬ FALSE;        tsw.scroller ¬ NIL;        IF tsw.otherSels # NIL THEN {          FOR i: CARDINAL IN [0..tsw.otherSels.length) DO            z.FREE[@tsw.otherSels.array[i]]; ENDLOOP;          z.FREE[@tsw.otherSels];	  tsw.otherSels ¬ NIL};        sw.InvalidateBox[p.box, isDirty]}      ELSE         FOR i: CARDINAL IN [0..tsw.splits.length) DO 	  tsw.splits[i].source ¬ source; ENDLOOP}    ELSE ERROR DoesNotExist};  Sleep: PUBLIC PROC [sw: Window.Handle] = {ActOnSource[sw, sleep]};  Wakeup: PUBLIC PROC [sw: Window.Handle] = {ActOnSource[sw, wakeup]};  -- Secondary Selection Procedures  EnumerateSecondarySelections: PUBLIC ENTRY PROC [    sw: Window.Handle, proc: PROC [TextData.Selection] RETURNS [BOOLEAN]] = {    ENABLE UNWIND => NULL;    tsw: TSWContext = LocalFind[sw];    IF tsw = NIL OR tsw.otherSels = NIL THEN RETURN;    FOR i: CARDINAL IN [0..tsw.otherSels.length) DO      IF tsw.otherSels[i] # NIL AND proc[tsw.otherSels[i]] THEN RETURN      ENDLOOP};    RealRemoveSecondary: ENTRY PROC [    tsw: TSWContext, s: TextData.Selection, mark: BOOLEAN ¬ TRUE] = {    ENABLE UNWIND => NULL;    IF tsw.otherSels = NIL THEN RETURN;    IF s = NIL THEN { -- delete all      FOR sel: CARDINAL IN [0..tsw.otherSels.length) DO        oldMark: BOOLEAN = tsw.otherSels[sel].marked;        IF mark THEN FOR split: CARDINAL IN [0..tsw.splits.length) DO	  tsw.otherSels[sel].marked ¬ oldMark;	  tsw.splits[split].MarkSelection[tsw.otherSels[sel], clear];	  ENDLOOP;	z.FREE[@tsw.otherSels[sel]];	ENDLOOP;      z.FREE[@tsw.otherSels]}    ELSE {      oldMark: BOOLEAN = s.marked;      found: BOOLEAN ¬ FALSE;      FOR i: CARDINAL IN [0..tsw.otherSels.length - 1) DO        IF tsw.otherSels[i] = s THEN found ¬ TRUE;        IF found THEN tsw.otherSels[i] ¬ tsw.otherSels[SUCC[i]];        ENDLOOP;      IF tsw.otherSels.length = 1 THEN z.FREE[@tsw.otherSels]      ELSE tsw.otherSels ¬ NewSecondaryObject[        tsw.otherSels, PRED[tsw.otherSels.length]];      IF mark THEN FOR split: CARDINAL IN [0..tsw.splits.length) DO        s.marked ¬ oldMark;        tsw.splits[split].MarkSelection[s, clear];        ENDLOOP;      z.FREE[@s]};    IF mark THEN TextSWOps.InternalValidate[tsw.sw]};    RemoveSecondarySelection: PUBLIC PROC [    sw: Window.Handle, s: TextData.Selection] = {    tsw: TSWContext = LocalFind[sw];    IF tsw # NIL THEN RealRemoveSecondary[tsw, s]};  RemoveAllSecondarySelections: PUBLIC PROC [sw: Window.Handle] = {    RemoveSecondarySelection[sw, NIL]};    SecondarySelectionFromPosition: PUBLIC ENTRY PROC [    sw: Window.Handle, position: TextSource.Position]    RETURNS [s: TextData.Selection] = {    ENABLE UNWIND => NULL;    tsw: TSWContext = LocalFind[sw];    IF tsw # NIL THEN      FOR i: CARDINAL IN [0..tsw.otherSels.length) DO        IF position IN [tsw.otherSels[i].left..tsw.otherSels[i].right] THEN          RETURN[tsw.otherSels[i]];        ENDLOOP;    RETURN[NIL]};  SetSecondaryInternal: PUBLIC PROC [tsw: TSWContext, s: TextData.Selection] = {    tsw.otherSels ¬ NewSecondaryObject[      tsw.otherSels,       IF tsw.otherSels = NIL THEN 1 ELSE SUCC[tsw.otherSels.length]];    tsw.otherSels[PRED[tsw.otherSels.length]] ¬ s;    IF ~s.marked THEN FOR i: CARDINAL IN [0..tsw.splits.length) DO      s.marked ¬ FALSE;      tsw.splits[i].MarkSelection[s, mark];      ENDLOOP};	  SetSecondarySelection: PUBLIC ENTRY PROC [    sw: Window.Handle, left, right: TextSource.Position,    mode: TextData.SelectionMode] RETURNS [s: TextData.Selection] = {    ENABLE UNWIND => NULL;    tsw: TSWContext = LocalFind[sw];    IF tsw # NIL THEN SetSecondaryInternal[tsw, s ¬ z.NEW[      TextData.SelectionObject ¬ [        left: left, right: right, entity: text, mode: mode, marked: FALSE]]]};      NewSecondaryObject: PROC [old: OtherSelections, n: CARDINAL]    RETURNS [new: OtherSelections] = {    new ¬ z.NEW[OtherSelectionsObject [n]];    IF old # NIL THEN {      FOR i: CARDINAL IN [0..MIN[n, old.length]) DO new[i] ¬ old[i] ENDLOOP;      FOR i: CARDINAL IN [old.length..n) DO new[i] ¬ NIL ENDLOOP;      z.FREE[@old]}};  -- Utility Procedures  ActOnSource: ENTRY PROC [sw: Window.Handle, action: TextSource.Action] = {    ENABLE UNWIND => NULL;    -- not to be called with action = destroy    source: TextSource.Handle = GetSource[sw];    IF source # NIL THEN [] ¬ source.ActOn[action]};  DestroySplits: PROC [tsw: TSWContext, keep: CARDINAL] = {    sink: TextSink.Handle = tsw.splits.array[0].sink;    FOR i: CARDINAL DECREASING IN [keep..tsw.splits.length) DO      TextSWOps.MarkSplitBoundary[tsw, i, TRUE];      IF tsw.splits[i] # NIL THEN {        tsw.splits[i] ¬ tsw.splits[i].Destroy[]};      ENDLOOP;    IF keep = 0 THEN {      IF tsw.mySink THEN [] ¬ sink.ActOn[destroy];      Heap.systemZone.FREE[@tsw.splits]}};  SetBox: PROC [sw: Window.Handle, options: TextSW.Options]    RETURNS [box: Window.Box] = {    topMargin: CARDINAL = IF options.flushTop THEN 0 ELSE margin;    bottomMargin: CARDINAL = IF options.flushBottom THEN 0 ELSE margin;    swDims: Window.Dims = sw.GetBox.dims;    box ¬ [[margin, topMargin],      [swDims.w - margin*2, swDims.h - (topMargin + bottomMargin)]];    IF box.dims.w < 0 THEN box.dims.w ¬ 0;    IF box.dims.h < 0 THEN box.dims.h ¬ 0};  END. -- of TextSWsALOGRiggle 	25-Jul-84 16:18:02 Fixed caret tracksRiggle 	15-Feb-85 18:39:20 Fixed a bug in SetSinkRiggle 	 2-May-85 12:04:55 Added a feature to SetSink
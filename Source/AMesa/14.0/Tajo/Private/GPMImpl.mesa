-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- GPMImpl.Mesa, edited by-- Paxton	15-Jan-82 13:45:35-- SXS   	11-Oct-82 18:02:36-- AXD    	23-Feb-83 17:29:47-- Strachey's General Purpose Macrogenerator-- as described in Computer Journal, Oct. 1965. pp. 225-241-- written in Mesa by Bill Paxton, November 1981DIRECTORY  GPM USING [    BuiltIn, Entry, ErrorCode, Index, maxIndex, Stack],  Heap USING [Create, Delete],  MStream USING [Handle],  Stream USING [Delete, EndOfStream, GetChar, GetPosition, Handle, PutChar];GPMImpl: MONITOR IMPORTS Heap, Stream EXPORTS GPM =  BEGIN OPEN GPM;  Handle: TYPE = LONG POINTER TO Object;  Object: PUBLIC TYPE = RECORD [     stream: MStream.Handle ¬ NIL,     zone: UNCOUNTED ZONE ¬ NULL,     st: LONG POINTER TO Stack ¬ NIL,     outputChar: CHARACTER ¬ 0C,     startCall: CHARACTER ¬ '[,     endCall: CHARACTER ¬ '],     startQuote: CHARACTER ¬ '(,     endQuote: CHARACTER ¬ '),     sepArg: CHARACTER ¬ ',,     numArg: CHARACTER ¬ '~,     output: LONG STRING ¬ NIL,     outputPtr: NAT ¬ 0,     s: Index ¬ 0, -- next available cell in the stack     e: Index ¬ 0, -- chain of name-value pairs for current definitions     h: Index ¬ 0, -- index of length cell for incomplete string on top of stack       -- h=0 means destination is output stream rather than stack     p: Index ¬ 0, -- start of chain of calls entered but not yet completed     f: Index ¬ 0, -- start of chain of calls started but not yet entered     	-- i.e., have seen the & but not the matching ;     c: Index ¬ 0, -- index of next character to be scanned       -- c=0 means source is input stream rather than stack     a: CHARACTER ¬ 0C, -- temp for use by NextCh and Load     w: Index ¬ 0, -- temp for use with Find     q: NAT ¬ 0 -- level of nesting inside <'s     ];    Open: PUBLIC PROC [stream: MStream.Handle] RETURNS [self: Handle] = {    zone: UNCOUNTED ZONE = Heap.Create[initial: 22, largeNodeThreshold: SIZE[StringBody[400]]];    self ¬ zone.NEW[Object ¬ []];    self.zone ¬ zone;    self.st ¬ GetStack[self];    self.output ¬ GetText[self, 100];    self.outputChar ¬ endOfInput;    self.stream ¬ stream;    InitStack[self]};  Close: PUBLIC PROC [self: Handle] = {    IF self = NIL THEN RETURN;    IF self.stream # NIL THEN Stream.Delete[self.stream];    self.stream ¬ NIL;    self.output ¬ NIL;    self.st ¬ NIL;    Heap.Delete[self.zone]; -- frees all allocated stuff    };      GetStack: ENTRY PROC[self: Handle] RETURNS [stk: LONG POINTER TO Stack] = {    RETURN [self.zone.NEW[Stack [5000]]]};  GetText: ENTRY PROC[self: Handle, maxlength: NAT] RETURNS [txt: LONG STRING] = {    RETURN[self.zone.NEW[StringBody [maxlength]]]};  GetIndex: PUBLIC PROC [self: Handle] RETURNS [i: LONG INTEGER] = {    RETURN[Stream.GetPosition[self.stream]]};  DumpToStream: PUBLIC PROC [output: MStream.Handle, input: Handle] = {    DO      Stream.PutChar[output, GetChar[input ! Stream.EndOfStream => EXIT]]; ENDLOOP;    input.stream ¬ NIL;    Close[input]};  Error: PUBLIC ERROR [ec: ErrorCode, errorMsg: LONG STRING ¬ NIL] = CODE;  --  Internal procs  endOfInput: CHARACTER = 0C;  Load: PROC [self: Handle] =  {    OPEN self;    IF h = 0 THEN {      IF output.length = 0 AND outputChar = endOfInput THEN {        outputChar ¬ a; RETURN};      IF output.length = output.maxlength THEN {        new: LONG STRING = GetText[self, output.maxlength*2];        new.length ¬ output.length;        FOR i: NAT IN [0..output.length) DO new[i] ¬ output[i]; ENDLOOP;        self.zone.FREE[@output];	output ¬ new};      output[output.length] ¬ a;      output.length ¬ output.length + 1}    ELSE {st[s] ¬ char[a]; s ¬ s + 1}};  NextCh: PROC [self: Handle] =  {    OPEN Stream, MStream, self;    IF c = 0 THEN {      a ¬ GetChar[stream ! EndOfStream => {a ¬ endOfInput; CONTINUE}];      inputloc ¬ inputloc + 1}    ELSE {a ¬ ToChar[st[c]]; c ¬ c + 1}};  Find: PROC [self: Handle, x: Index] = {    OPEN self;    -- x is index of name    -- finds name in e chain and sets w to start of def    ptr: Index ¬ e;  -- start of definitions    w ¬ x;  -- index of name length    DO  -- search for macro name definition      match: BOOLEAN ¬ TRUE;      len: Index ¬ ToLength[st[w]];      FOR r: Index IN [0..len) DO        IF st[w + r] # st[ptr + r + 1] THEN {match ¬ FALSE; EXIT}; ENDLOOP;      IF match THEN {w ¬ ptr + 1 + len; RETURN};      ptr ¬ ToIndex[st[ptr]];  -- next entry      IF ptr = maxIndex THEN EXIT;  -- end of chain      ENDLOOP;    -- undefined    Error[MacroError, "Undefined name: "L]};  EndFn: PROC [self: Handle] = {  -- remove call and arg list; copy back result if any    y: Index;    len: Index;    IF self.f > self.p THEN {  -- encountered terminator in bad place      IF self.c = 0 THEN ERROR;  -- found terminator in input source      Error[        MacroError,        "Terminator in argument list. Probably due to a semicolon missing from the definition of ..."L]};    -- first remove any defs in arg list from e chain    -- and adjust defs in results so chain will be correct later    y ¬ self.s;    self.st[self.s] ¬ index[self.e];    len ¬ ToLength[self.st[self.p - 1]];  -- arg list stuff to be removed    WHILE ToIndex[self.st[y]] >= self.p - 1 + len DO  -- take care of defs in results      next: Index ¬ ToIndex[self.st[y]];      self.st[y] ¬ index[next - len];      y ¬ next;      ENDLOOP;    self.w ¬ ToIndex[self.st[y]];    WHILE self.w > self.p - 1 DO self.w ¬ ToIndex[self.st[self.w]]; ENDLOOP;  -- skip over defs in args    self.st[y] ¬ index[self.w];    self.e ¬ ToIndex[self.st[self.s]];    IF self.h # 0 THEN      IF self.h > self.p THEN self.h ¬ self.h - len      ELSE self.st[self.h] ¬ length[ToLength[self.st[self.h]] - len];    self.c ¬ ToIndex[self.st[self.p + 1]];    self.s ¬ self.s - len;    y ¬ self.p - 1;  -- dest for results    self.w ¬ self.p - 1 + len;  -- source of results    self.p ¬ ToIndex[self.st[self.p]];    UNTIL y = self.s DO      self.st[y] ¬ self.st[self.w]; y ¬ y + 1; self.w ¬ self.w + 1; ENDLOOP};  outputloc, inputloc: LONG INTEGER ¬ 0;  -- for debugging  GetChar: PUBLIC PROC [self: Handle] RETURNS [char: CHARACTER] = {    OPEN self;    DO  -- main loop      flag: BOOLEAN ¬ FALSE;      IF st = NIL THEN Error[EndOfStream, "Stream already closed"L];      IF outputChar # endOfInput THEN {        char ¬ outputChar;        outputChar ¬ endOfInput;        outputloc ¬ outputloc + 1;        RETURN};      IF output.length > outputPtr THEN {        char ¬ output[outputPtr];        IF (outputPtr ¬ outputPtr + 1) = output.length THEN          output.length ¬ outputPtr ¬ 0;        outputloc ¬ outputloc + 1;        RETURN};      NextCh[self];      IF a = startQuote THEN {q ¬ q + 1; flag ¬ TRUE}      ELSE        SELECT a FROM          startCall => {  -- Fn; start new function call            st[s] ¬ index[h];            st[s + 1] ¬ index[f];            st[s + 2] ¬ index[0];            st[s + 3] ¬ length[0];            h ¬ s + 3;            f ¬ s + 1;            s ¬ s + 4;            LOOP};          sepArg =>            IF h = 0 THEN NULL            ELSE {  -- NextItem; collect next arg              st[h] ¬ length[s - h - ToLength[st[h]]];              st[s] ¬ length[0];              h ¬ s;              s ¬ s + 1;              LOOP};          endCall =>            IF h = 0 THEN NULL            ELSE {  -- Apply;              oldstf1: Index ¬ ToIndex[st[f - 1]];              oldstf: Index ¬ ToIndex[st[f]];              st[h] ¬ length[s - h];              st[s] ¬ mark;              st[f - 1] ¬ length[s - f + 2];              st[f] ¬ index[p];              st[f + 1] ¬ index[c];              p ¬ f;              h ¬ oldstf1;              f ¬ oldstf;              s ¬ s + 1;              IF h # 0 THEN  -- increase count of extra stuff                st[h] ¬ length[ToLength[st[h]] + ToLength[st[p - 1]]];              Find[self, p + 2];              IF IsBuiltIn[st[w]] THEN {                SELECT ToBuiltIn[st[w]] FROM                  def => {  -- add a new definition                    IF h # 0 THEN                      st[h] ¬ length[ToLength[st[h]] - ToLength[st[p - 1]] + 6];                    st[p - 1] ¬ length[6];                    st[p + 5] ¬ index[e];                    e ¬ p + 5};                  val => {  -- get value of name                    Find[self, p + 6];                    UNTIL st[w + 1] = mark DO                      a ¬ ToChar[st[w + 1]]; w ¬ w + 1; Load[self]; ENDLOOP};                  update => {  -- change value of name                    y: Index;                    Find[self, p + 9];                    y ¬ p + 9 + ToLength[st[p + 9]];                    IF ToLength[st[y]] > ToLength[st[w]] THEN                      Error[MacroError, "UPDATE arg too long ... "L];                    FOR r: NAT IN [1..ToLength[st[y]]] DO                      st[w + r] ¬ st[y + r]; ENDLOOP};                  ENDCASE => ERROR;                EndFn[self];                LOOP};              c ¬ w + 1;              LOOP};          numArg =>            IF p = 0 THEN NULL            ELSE {  -- LoadArg;              NextCh[self];  -- read arg number              w ¬ p + 2;              IF a ~IN ['0..'9] THEN                Error[MacroError, "Bad arg number in definition ..."L];              FOR r: NAT IN [0..a - '0) DO                w ¬ w + ToLength[st[w]];                IF st[w] = mark THEN EXIT;  -- act like have null arg                ENDLOOP;              IF st[w] = mark THEN LOOP;              FOR r: NAT IN [1..ToLength[st[w]]) DO                a ¬ ToChar[st[w + r]]; Load[self]; ENDLOOP;              LOOP};          marker => {EndFn[self]; LOOP};          endOfInput =>            IF h # 0 THEN              Error[MacroError, "End of input encountered inside macro call"L]            ELSE Error[EndOfStream, "EndOfStream"L];          ENDCASE;      DO  -- subloop for copying literals        IF flag THEN flag ¬ FALSE ELSE {Load[self]; IF q = 1 THEN EXIT};        NextCh[self];        SELECT a FROM          startQuote => {q ¬ q + 1; LOOP};          endOfInput =>            Error[              MacroError, "End of input encountered inside macro quoted string"L];          endQuote => NULL;          ENDCASE => LOOP;        q ¬ q - 1;        IF q = 1 THEN EXIT;        ENDLOOP;      ENDLOOP};  ToIndex: PROC [e: Entry] RETURNS [i: Index] = INLINE {RETURN[LOOPHOLE[e]]};  --	WITH x:e SELECT FROM  --		index => RETURN [x.index];  --		ENDCASE => ERROR };  ToLength: PROC [e: Entry] RETURNS [i: Index] = INLINE {RETURN[LOOPHOLE[e]]};  --	WITH x:e SELECT FROM  --		length => RETURN [x.length];  --		ENDCASE => ERROR };  ToChar: PROC [e: Entry] RETURNS [char: CHARACTER] = INLINE {RETURN[LOOPHOLE[e]]};  --	WITH x:e SELECT FROM  --		char => RETURN [x.char];  --		ENDCASE => ERROR };  ToBuiltIn: PROC [e: Entry] RETURNS [name: BuiltIn] = INLINE {    RETURN[VAL[-e]]};  --	WITH x:e SELECT FROM  --		builtin => RETURN [x.name];  --		ENDCASE => ERROR };  index: PROC [i: Index] RETURNS [Entry] = INLINE {RETURN[[LOOPHOLE[i, INTEGER]]]};  --RETURN [[index[i]]] };  length: PROC [i: Index] RETURNS [Entry] = INLINE {    RETURN[[LOOPHOLE[i, INTEGER]]]};  --RETURN [[length[i]]] };  char: PROC [c: CHARACTER] RETURNS [Entry] = INLINE {    RETURN[[LOOPHOLE[c, INTEGER]]]};  --RETURN [[char[c]]] };  mark: Entry ¬ char[marker];  --[char[marker]];  marker: CHARACTER = 377C;  builtin: PROC [name: BuiltIn] RETURNS [Entry] = INLINE {RETURN[[-(name.ORD)]]};  --RETURN [[builtin[name]]] };  IsBuiltIn: PROC [e: Entry] RETURNS [BOOLEAN] = INLINE {RETURN[e < 0]};  InitStack: PROC [self: Handle] = {    OPEN self;    s ¬ 21;    e ¬ 12;    q ¬ 1;    a ¬ endOfInput;  st[0] ¬ index[maxIndex];  st[1] ¬ length[4];  st[2] ¬ char['D];  st[3] ¬ char['E];  st[4] ¬ char['F];  st[5] ¬ builtin[def];  st[6] ¬ index[0];  st[7] ¬ length[4];  st[8] ¬ char['V];  st[9] ¬ char['A];  st[10] ¬ char['L];  st[11] ¬ builtin[val];  st[12] ¬ index[6];  st[13] ¬ length[7];  st[14] ¬ char['U];  st[15] ¬ char['P];  st[16] ¬ char['D];  st[17] ¬ char['A];  st[18] ¬ char['T];  st[19] ¬ char['E];  st[20] ¬ builtin[update];  };  END..Item: PROC [self: Handle, x: Index] RETURNS [rope: LONG STRING] = { OPEN self;		-- return the item on the stack starting at st[x]		-- if item is not complete, stop at st[s-1] and			-- follow by "...(Incomplete)"		proc: PROC RETURNS [CHARACTER] = { k ¬ k+1; RETURN [ToChar[st[x+k]]] };		k: Index ¬ 0;		stklen: Index ¬ ToLength[st[x]];		incomplete: BOOLEAN ¬ stklen=0;		len: Index ¬ IF incomplete THEN s-x-1 ELSE stklen-1;		rope ¬ Rope.FromProc[len,proc];		IF incomplete THEN rope ¬ Rope.Concat[rope,"...(Incomplete)"L] };		AtLoc: PROC [self: Handle] RETURNS [rope: Rope.Ref] = {		s: STRING ¬ [100];		String.AppendLongDecimal[s, Stream.GetIndex[self.stream]-1];		RETURN [Rope.Concat[" at ",Rope.FromString[LOOPHOLE[LONG[s]]]]] };
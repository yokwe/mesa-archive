-- Copyright (C) 1981, 1982, 1984  by Xerox Corporation. All rights reserved. -- File: Contexts.mesa   Last modified by:-- SXW   	21-Jul-81 23:07:06-- PXK    	18-Oct-82 14:23:40-- JGS    	15-Oct-82 13:48:16-- MXS     	14-Jul-81 18:12:47-- SXS   	22-Sep-82 17:38:03-- AXD    	 5-Jan-84 18:14:20DIRECTORY  Context USING [CreateProcType, Data, DestroyProcType, ErrorCode, Type],  Heap USING [CreateUniform, systemZone],  Process USING [EnableAborts],  TajoOps USING [WindowHandle],  Window USING [Handle];Contexts: MONITOR IMPORTS Heap, Process EXPORTS Context, TajoOps =  BEGIN OPEN Context;  -- Signals and Errors  Error: PUBLIC ERROR [code: ErrorCode] = CODE;  -- Global Variables  Handle: TYPE = LONG POINTER TO ContextObject;  ContextObject: PUBLIC TYPE = RECORD [    link: Handle,    type: Type,    delete, busy: BOOLEAN ¬ FALSE,    data: Data,    destroy: DestroyProcType,    nWaiting: CARDINAL ¬ 0];  nullType: Type = first;  uniqueType: Type ¬ nullType.SUCC;  z: UNCOUNTED ZONE =  Heap.CreateUniform[    initial: 8, swapUnitSize: 2, objectSize: ContextObject.SIZE];  contextBusy: CONDITION ¬ [timeout: 0];  doneWithContext: CONDITION ¬ [timeout: 0];    WIDEN: PROC [w: Window.Handle] RETURNS [TajoOps.WindowHandle] = INLINE {    RETURN[LOOPHOLE[w]]};      -- Procedures    Acquire: PUBLIC ENTRY PROC [    type: Type, window: Window.Handle] RETURNS [Data] = {    ENABLE UNWIND => NULL;    c: Handle = FindContext[type: type, window: window];    IF c = NIL THEN RETURN[NIL];    DO      IF c.delete OR c.data = NIL THEN {BROADCAST doneWithContext; RETURN[NIL]};      IF ~c.busy THEN {c.busy ¬ TRUE; RETURN[c.data]};      c.nWaiting ¬ c.nWaiting.SUCC;      WAIT contextBusy [ ! UNWIND => {c.nWaiting ¬ c.nWaiting.PRED}];      c.nWaiting ¬ c.nWaiting.PRED;      ENDLOOP};  Create: PUBLIC ENTRY PROC [    type: Type, data: Data, proc: DestroyProcType, window: Window.Handle] = {    ENABLE UNWIND => NULL;    toolWH: TajoOps.WindowHandle = WIDEN[window];    SELECT TRUE FROM      window = NIL => RETURN WITH ERROR Error[windowIsNIL];      -- data = NIL => RETURN WITH ERROR Error[other]; ++ should this happen?      FindContext[type, window] # NIL => RETURN WITH ERROR Error[duplicateType];      ENDCASE;    toolWH.contexts ¬ z.NEW[ContextObject ¬ [      link: toolWH.contexts, type: type, data: data, destroy: proc]]};  DelinkDeleted: ENTRY PROC [toolWH: TajoOps.WindowHandle] = {    ENABLE UNWIND => NULL;    c: Handle ¬ toolWH.contexts;    prev, next: Handle;    UNTIL c = NIL DO      next ¬ c.link;      IF c.delete THEN {        waited: BOOLEAN ¬ FALSE;	IF c = toolWH.contexts THEN toolWH.contexts ¬ next        ELSE prev.link ¬ next;	UNTIL c.nWaiting = 0 DO waited ¬ TRUE; WAIT doneWithContext ENDLOOP;	SELECT c.destroy FROM	  InFindOrCreate => c.destroy ¬ DeletedWhileCreating;	  DeletedWhileCreating => NULL;	  ENDCASE => z.FREE[@c];	IF waited THEN {c ¬ toolWH.contexts; LOOP -- next may be trash by now --}}      ELSE prev ¬ c;      c ¬ next;      ENDLOOP};  Destroy: PUBLIC PROC [type: Type, window: Window.Handle] = {    toolWH: TajoOps.WindowHandle = WIDEN[window];    c: Handle = FindContextToDestroy[type, window];    IF c = NIL THEN RETURN;    c.destroy[c.data, window];    DelinkDeleted[toolWH]};  DestroyAll: PUBLIC PROC [window: Window.Handle] = {    type: Type;    IF window = NIL THEN RETURN;    WHILE (type ¬ GetNextType[WIDEN[window]]) # nullType DO      Destroy[type, window]; ENDLOOP};  Find: PUBLIC ENTRY PROC [type: Type, window: Window.Handle] RETURNS [Data] = {    ENABLE UNWIND => NULL;    c: Handle = FindContext[type, window];    RETURN[IF c = NIL OR c.delete THEN NIL ELSE c.data]};  FindContext: INTERNAL PROC [type: Type, window: Window.Handle]    RETURNS [Handle] = {    toolWH: TajoOps.WindowHandle = WIDEN[window];    IF toolWH = NIL THEN RETURN[NIL];    FOR c: Handle ¬ toolWH.contexts, c.link UNTIL c = NIL DO      IF c.type = type THEN RETURN[c]; ENDLOOP;    RETURN[NIL]};    FindContextToDestroy: ENTRY PROC [type: Type, window: Window.Handle]    RETURNS [c: Handle] = {    IF (c ¬ FindContext[type, window]) = NIL OR c.delete THEN RETURN[NIL];    c.delete ¬ TRUE;    WHILE c.busy DO      c.nWaiting ¬ c.nWaiting.SUCC;      WAIT contextBusy [ ! UNWIND => {c.nWaiting ¬ c.nWaiting.PRED}];      c.nWaiting ¬ c.nWaiting.PRED;      ENDLOOP;    BROADCAST doneWithContext};      FindOrCreate: PUBLIC PROC [    type: Type, window: Window.Handle, createProc: CreateProcType]    RETURNS [Data] = {    c: Handle ¬ TRASH;    data: Data ¬ TRASH;    proc: DestroyProcType ¬ TRASH;    MaybeCreate: ENTRY PROC [      type: Type, window: Window.Handle] RETURNS [{there, deleted, create}] = {      ENABLE UNWIND => NULL;      c ¬ FindContext[type, window];      IF c = NIL THEN {        toolWH: TajoOps.WindowHandle = WIDEN[window];	c ¬ toolWH.contexts ¬ z.NEW[ContextObject ¬ [	  link: toolWH.contexts, type: type, data: NIL, destroy: InFindOrCreate]];	RETURN[create]}      ELSE RETURN[IF c.delete THEN deleted ELSE there]};    TestStateAndClearProc: ENTRY PROC RETURNS [{ok, destroy, free}] = {      ENABLE UNWIND => NULL;      oldDestroy: DestroyProcType = c.destroy;      c.destroy ¬ NIL;      SELECT oldDestroy FROM        DeletedWhileCreating => RETURN[free];	InFindOrCreate => IF c.delete THEN RETURN[destroy] ELSE {	  c.destroy ¬ proc; c.data ¬ data; RETURN[ok]};	ENDCASE => ERROR};    SetFields: ENTRY PROC RETURNS [Data] = {      ENABLE UNWIND => NULL;      c.destroy ¬ proc;      RETURN[c.data ¬ data]};    SELECT MaybeCreate[type, window] FROM      there => RETURN[c.data];      deleted => RETURN[NIL];      -- create => rest of this procedure...      ENDCASE;    [data, proc] ¬ createProc[--window--];    SELECT TestStateAndClearProc[] FROM      ok => RETURN[data];      destroy => {proc[data, window]; RETURN[NIL]};      free => {proc[data, window]; z.FREE[@c]; RETURN[NIL]};      ENDCASE => ERROR};  DeletedWhileCreating: PROC [p: Data, window: Window.Handle] = {};  InFindOrCreate: PROC [p: Data, window: Window.Handle] = {};  GetNextType: ENTRY PROC [toolWH: TajoOps.WindowHandle] RETURNS [Type] = {    contexts: Handle = toolWH.contexts;    RETURN[IF contexts = NIL THEN nullType ELSE contexts.type]};  NopDestroyProc: PUBLIC PROC [p: Data, window: Window.Handle] = {};  Release: PUBLIC ENTRY PROC [type: Type, window: Window.Handle] = {    ENABLE UNWIND => NULL;    c: Handle = FindContext[type: type, window: window];    IF c = NIL OR ~c.busy THEN RETURN;    c.busy ¬ FALSE;    BROADCAST contextBusy};  Set: PUBLIC ENTRY PROC [type: Type, data: Data, window: Window.Handle] = {     toolWH: TajoOps.WindowHandle = WIDEN[window];    IF toolWH = NIL THEN RETURN WITH ERROR Error[windowIsNIL];    FOR c: Handle ¬ toolWH.contexts, c.link UNTIL c = NIL DO      IF c.type = type THEN {c.data ¬ data; RETURN};      ENDLOOP};  SimpleDestroyProc: PUBLIC PROC [p: Data, window: Window.Handle] = {    Heap.systemZone.FREE[@p]};  UniqueType: PUBLIC ENTRY PROC RETURNS [Type] = {    IF uniqueType = lastAllocated THEN RETURN WITH ERROR Error[tooManyTypes];    RETURN[uniqueType ¬ uniqueType.SUCC]};  Process.EnableAborts[@contextBusy];  Process.EnableAborts[@doneWithContext];  END.
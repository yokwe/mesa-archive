-- File: UserInputsA.mesa - last edit:-- Riggle.PA           11-Aug-86 14:56:33-- Copyright (C) 1981, 1982, 1983 , 1986, 1986, 1986 by Xerox Corporation. All rights reserved. -- File: UserInputsA.mesa - last edited:-- PXK    ,	23-May-83 16:22:21-- SXW   ,	Aug 20, 1980 3:44 PM-- JGS,		19-Nov-82 16:54:27-- BXM  ,	14-Nov-81 18:02:37-- Mark, 	 6-Feb-81 10:18:19-- SEH,  	18-Oct-82 10:52:36-- RXJ     ,  	25-Sep-82 12:51:28-- AXD    ,  	 7-Jul-83 14:41:16-- DWR 	15-Apr-85 12:40:09DIRECTORY  Context: TYPE USING [    Create, Error, Find, NopDestroyProc, Set, Type, UniqueType],  Keys: TYPE USING [DownUp, KeyBits, KeyName],  Inline: TYPE USING [BITSHIFT, BITXOR, LowHalf],  Profile: TYPE USING [swapCtrlAndCommand],  Process: TYPE USING [    Detach, DisableTimeout, EnableAborts, GetPriority, MsecToTicks, Milliseconds,    Priority, priorityForeground, SetPriority, SetTimeout, TooManyProcesses],  ProcessOperations: TYPE USING [Enter, Wait],  ProcessPriorities: TYPE USING [priorityIOLow, priorityPageFaultIO],  Runtime: TYPE USING [CallDebugger, Interrupt],  System: TYPE USING [GetClockPulses, Microseconds, Pulses, PulsesToMicroseconds],  TajoOps: TYPE USING [WindowHandle],  SpecialUserInput: TYPE USING [    Acceptance, ActionBody, Coords, HotSpotOffset, KeySNRType, mouseKey,    MouseSNRType, Queue, QueueSequence, QueueSequenceObject, WaitMode],  UserInput: TYPE USING [AttentionProcType],  UserInputOps: TYPE USING [KeysHandle, KeysRecord, SNRRecord, z],  UserTerminal: TYPE USING [    Coordinate, cursor, keyboard, mouse, screenHeight, screenWidth,    SetCursorPosition, SetMousePosition, WaitForScanLine],  Window: TYPE USING [    BitmapPlaceToWindowAndPlace, GetParent, Handle, Place, rootWindow];UserInputsA: MONITOR  IMPORTS    Context, Inline, Process, ProcessOperations, Profile, Runtime,    System, UserInputOps, UserTerminal, Window  EXPORTS TajoOps, SpecialUserInput, UserInput, UserInputOps =  BEGIN  Coords: TYPE = SpecialUserInput.Coords;  QueueSequence: TYPE = SpecialUserInput.QueueSequence;  QueueSequenceObject: TYPE = SpecialUserInput.QueueSequenceObject;  Queue: TYPE = SpecialUserInput.Queue;  Acceptance: TYPE = SpecialUserInput.Acceptance;  ActionBody: TYPE = SpecialUserInput.ActionBody;  MouseSNRType: TYPE = SpecialUserInput.MouseSNRType;  KeySNRType: TYPE = SpecialUserInput.KeySNRType;  WaitMode: TYPE = SpecialUserInput.WaitMode;  KeyName: TYPE = Keys.KeyName;  DownUp: TYPE = Keys.DownUp;       --  Stimulus Level Procedures  snrs: PUBLIC UserInputOps.SNRRecord;  SwapMouseSNR: PUBLIC PROC [new: MouseSNRType] RETURNS [old: MouseSNRType] = {    old ¬ snrs.mouse; snrs.mouse ¬ new; RETURN[old]};  SwapKeySNR: PUBLIC PROC [new: KeySNRType] RETURNS [old: KeySNRType] = {    old ¬ snrs.key; snrs.key ¬ new; RETURN[old]};  newState, oldState: PUBLIC UserInputOps.KeysRecord;  --  Global Variables<< used for stim lev chording  ButtonStates: TYPE = {up, down, converted};  ignoreRedUp: BOOLEAN ¬ FALSE;  buttonState: ButtonStates ¬ up;>>  ignoreUserAbortUp: BOOLEAN ¬ FALSE;  keyboard: LONG UserInputOps.KeysHandle = LOOPHOLE[UserTerminal.keyboard];  mouse: LONG POINTER TO READONLY UserTerminal.Coordinate = UserTerminal.mouse;  cursor: LONG POINTER TO READONLY UserTerminal.Coordinate = UserTerminal.cursor;  keys: LONG POINTER TO Keys.KeyBits = @newState.bit;  words: CARDINAL = 7;  mouseKey: KeyName = SpecialUserInput.mouseKey;  maxCursorX: INTEGER = UserTerminal.screenWidth - 1;  maxCursorY: INTEGER = UserTerminal.screenHeight - 1;  cursorHotX: [0..16) ¬ 0;  cursorHotY: [0..16) ¬ 0;  nextRefresh: CONDITION;  dummyLock: MONITORLOCK;  entriesWaiting: PUBLIC CONDITION;  interruptWait: CONDITION;  userAbortWait: CONDITION;  attentionContext: Context.Type = Context.UniqueType[];  userAbortPlace: UserTerminal.Coordinate;  -- User Action Buffer stuff  CursorX: TYPE = [0..7777B];  CursorY: TYPE = [0..7777B];  KeyPart1: TYPE = [0..7B];  KeyPart2: TYPE = [0..17B];  SplitKey: TYPE = MACHINE DEPENDENT RECORD [    pad: [0..777B] ¬ 0,    body: SELECT OVERLAID * FROM      real => [key: Keys.KeyName], fake => [p1: KeyPart1, p2: KeyPart2], ENDCASE];  UserActionItemObject: TYPE = MACHINE DEPENDENT RECORD [    downUp: Keys.DownUp,    x: CursorX,    p1: KeyPart1,  -- note: word boundary follows    p2: KeyPart2,    y: CursorY,    time: System.Pulses];  bufferIn, bufferOut, bufferLast: CARDINAL ¬ 0;  nEntries: CARDINAL = 256; -- must be power of two  entries: LONG POINTER TO ARRAY [0..nEntries) OF UserActionItemObject = @entryArray;  entryArray: ARRAY [0..nEntries) OF UserActionItemObject;  maxMouseEntries: PUBLIC CARDINAL ¬ 60;  nMouseEntries: CARDINAL ¬ 0;  lastKey: Keys.KeyName ¬ D1;  clientQueues: QueueSequence ¬ NIL;  nDropped: CARDINAL ¬ 0;     WH: PROC [Window.Handle] RETURNS [TajoOps.WindowHandle] = MACHINE CODE {};  --  Stimulus Level Procedures  NextRetrace: ENTRY PROC = {    ENABLE UNWIND => NULL;    transitions: PACKED ARRAY [0..16) OF BOOLEAN;    blueChanged, redChanged: BOOLEAN ¬ FALSE;    pos: Window.Place;    downUp: Keys.DownUp;    time: System.Pulses ¬ System.GetClockPulses[];    pos ¬ snrs.mouse[];    newState.bit ¬ keyboard­;    IF newState.word # oldState.word THEN {    IF Profile.swapCtrlAndCommand THEN {      downUp ¬ newState.bit[COMMAND];      newState.bit[COMMAND] ¬ newState.bit[CONTROL];      newState.bit[CONTROL] ¬ downUp};    IF newState.bit[LeftShift] # oldState.bit[LeftShift] THEN       snrs.key[        key: LeftShift,	downUp: (oldState.bit[LeftShift] ¬ newState.bit[LeftShift]),	place: pos,	time: time];    IF newState.bit[RightShift] # oldState.bit[RightShift] THEN       snrs.key[        key: RightShift,	downUp: (oldState.bit[RightShift] ¬ newState.bit[RightShift]),	place: pos,	time: time];    IF newState.bit[A12] # oldState.bit[A12] THEN       snrs.key[A12, (oldState.bit[A12] ¬ newState.bit[A12]), pos, time];    IF newState.bit[Key47] # oldState.bit[Key47] THEN       snrs.key[Key47, (oldState.bit[Key47] ¬ newState.bit[Key47]), pos, time];<< more stim lev chording junk    IF newState.bit[Adjust] # oldState.bit[Adjust] THEN blueChanged ¬ TRUE;    IF newState.bit[Point] # oldState.bit[Point] THEN redChanged ¬ TRUE;    IF blueChanged OR redChanged THEN {      SELECT buttonState FROM        up => {	  IF redChanged AND blueChanged THEN {	    buttonState ¬ converted;	    ignoreRedUp ¬ TRUE;	    snrs.key[Menu, down, pos, time]}	  ELSE {	    buttonState ¬ down;	    snrs.key[IF blueChanged THEN Adjust ELSE Point, down, pos, time]}};        down => {	  IF redChanged THEN {	    IF ignoreRedUp THEN ignoreRedUp ¬ FALSE  -- know it must be down	    ELSE snrs.key[Point, newState.bit[Point], pos, time]};	  IF blueChanged THEN snrs.key[Adjust, newState.bit[Adjust], pos, time];	  IF newState.bit[Point] = up AND newState.bit[Adjust] = up THEN	    buttonState ¬ up};        converted => {	  IF redChanged THEN {	    IF ignoreRedUp THEN ignoreRedUp ¬ FALSE  -- know it must be down	    ELSE snrs.key[Point, newState.bit[Point], pos, time]};	  IF blueChanged THEN {	    snrs.key[Menu, up, pos, time];  -- must have been down	    buttonState ¬ IF newState.bit[Point] = down THEN down ELSE up}};        ENDCASE;      oldState.bit[Point] ¬ newState.bit[Point];        oldState.bit[Adjust] ¬ newState.bit[Adjust]};  >>    FOR word: CARDINAL IN [0..words) DO      OPEN Inline;      transitions ¬ BITXOR[newState.word[word], oldState.word[word]];      FOR bit: CARDINAL IN [0..16) WHILE transitions # ALL[FALSE] DO        IF transitions[0] THEN {          key: Keys.KeyName;          key ¬ LOOPHOLE[16*word + bit];          downUp ¬ newState.bit[key];          «SELECT key FROM            T10 => key ¬ ATTENTION;            T1 => key ¬ COMPLETE;            ENDCASE;»          IF SendNotification[key, downUp, pos] THEN            snrs.key[key, downUp, pos, System.GetClockPulses[]]};        transitions ¬ BITSHIFT[transitions, 1];        ENDLOOP;      ENDLOOP};    oldState ¬ newState;    NOTIFY nextRefresh};  ProcessUserActions: PUBLIC PROC = {    oldState.bit ¬ keyboard­;    oldState.bit[LOCK] ¬ up;    DO UserTerminal.WaitForScanLine[0]; NextRetrace[]; ENDLOOP};  SendNotification: INTERNAL PROC [    key: Keys.KeyName, downUp: Keys.DownUp, pos: UserTerminal.Coordinate]    RETURNS [BOOLEAN] = {    SELECT key FROM«      ~IN Keys.KeyName [Keyset1..A12] => RETURN[FALSE]; »      > A12 => RETURN[FALSE];      USERABORT => {        IF downUp = down THEN {	  nShiftKeysUp: CARDINAL;	  IF keys[COMMAND] = down THEN {FlushInternal[]; RETURN[FALSE]};	  nShiftKeysUp ¬             LOOPHOLE[keys[LeftShift], CARDINAL] +	    LOOPHOLE[keys[RightShift], CARDINAL] +	    LOOPHOLE[keys[A12], CARDINAL] +	    LOOPHOLE[keys[Key47], CARDINAL]; -- up = 1	  IF nShiftKeysUp < 4 THEN {	    IF nShiftKeysUp = 3 THEN NOTIFY interruptWait	    ELSE Runtime.CallDebugger["*** panic interrupt ***"L];	    ignoreUserAbortUp ¬ TRUE;	    RETURN[FALSE]};	  userAbortPlace ¬ pos;	  NOTIFY userAbortWait}        ELSE IF ignoreUserAbortUp THEN RETURN[ignoreUserAbortUp ¬ FALSE]};      ENDCASE;    RETURN[TRUE]};  SetUserAbort: PUBLIC PROC [window: Window.Handle] = {    t, u: Window.Handle;    IF (t¬window.GetParent[]) # NIL THEN {      DO	IF (u¬t.GetParent[]) = NIL THEN EXIT; -- u = window.parent.parent        window ¬ t;        t ¬ u;	ENDLOOP;      IF WH[window].aborted THEN window ¬ window.GetParent[]};    WH[window].aborted ¬ TRUE};  InternalMouseSNR: PUBLIC INTERNAL SpecialUserInput.MouseSNRType = {    new: Window.Place = mouse­;    place.x ¬ MAX[0, MIN[new.x, maxCursorX]];    place.y ¬ MAX[0, MIN[new.y, maxCursorY]];    IF new # place THEN UserTerminal.SetMousePosition[place];    IF place # cursor­ THEN {      UserTerminal.SetCursorPosition[place];      InternalEnqueueAction[        key: mouseKey, downUp: up, place: place ¬ AdjustCursorPosition[place],	time: System.GetClockPulses[]]}    ELSE place ¬ AdjustCursorPosition[place]};  UserAbort: PUBLIC PROC [window: Window.Handle] RETURNS [BOOLEAN] = {    IF window = NIL THEN window ¬ Window.rootWindow;    WHILE window # NIL DO      IF WH[window].aborted THEN RETURN[TRUE];      window ¬ window.GetParent[];      ENDLOOP;    RETURN[FALSE]};  ResetUserAbort: PUBLIC PROC [window: Window.Handle] = {    WHILE window # NIL DO      WH[window].aborted ¬ FALSE; window ¬ window.GetParent[]; ENDLOOP};  GetMouseAndCursorPosition: PUBLIC ENTRY PROC    RETURNS [screenPlace: Window.Place] = {    ENABLE UNWIND => NULL;    screenPlace ¬ AdjustCursorPosition[mouse­]};  SetMouseAndCursorPosition: PUBLIC ENTRY PROC [    screenPlace: Window.Place, hotX, hotY: SpecialUserInput.HotSpotOffset] = {    ENABLE UNWIND => NULL;    screenPlace ¬ [screenPlace.x - hotX, screenPlace.y - hotY];    UserTerminal.SetMousePosition[screenPlace];    UserTerminal.SetCursorPosition[screenPlace];    cursorHotX ¬ hotX;    cursorHotY ¬ hotY};  AdjustCursorPosition: INTERNAL PROC [old: Window.Place]    RETURNS [Window.Place] = INLINE {    RETURN[[old.x + cursorHotX, old.y + cursorHotY]]};  QueueEmpty: PUBLIC ENTRY PROC [    q: Queue, waitInterval: Process.Milliseconds] RETURNS [BOOLEAN] = {    ENABLE UNWIND => NULL;    IF q.item # bufferIn THEN RETURN[FALSE];    IF waitInterval > 0 THEN Wait[waitInterval];    RETURN[q.item = bufferIn]};      GetMouseEvent: PUBLIC ENTRY PROC [q: Queue]    RETURNS [isMouse: BOOLEAN, action: ActionBody] = {    ENABLE UNWIND => NULL;    splitKey: SplitKey;    IF bufferIn = q.item THEN RETURN[FALSE, ActionBody[enter[]]];    splitKey ¬ [body: fake[p1: entries[q.item].p1, p2: entries[q.item].p2]];    IF splitKey.key = mouseKey THEN {      time: System.Pulses;      [] ¬ ReadEntry[q, @action, @time];      q.time ¬ time;      RETURN[TRUE, action]};    RETURN[FALSE, ActionBody[enter[]]]};  FlushQueue: PUBLIC ENTRY PROC = {ENABLE UNWIND => NULL; FlushInternal[]};  FlushInternal: INTERNAL PROC = {    bufferIn ¬ bufferOut ¬ bufferLast ¬ nMouseEntries ¬ 0;    FOR i: CARDINAL IN [0..clientQueues.length) DO      clientQueues.queues[i].item ¬ 0; ENDLOOP};  EnqueueEvent: PUBLIC ENTRY PROC [    key: Keys.KeyName, downUp: Keys.DownUp, place: Coords,    time: System.Pulses] = {    ENABLE UNWIND => NULL; InternalEnqueueAction[key, downUp, place, time]};  InternalEnqueueAction: PUBLIC INTERNAL SpecialUserInput.KeySNRType = {    splitKey: SplitKey ¬ [0, real[key]];    IF (bufferIn + 1) MOD nEntries = bufferOut THEN {      nDropped ¬ nDropped + 1; RETURN}; -- drop on floor    IF key = mouseKey THEN {      IF nMouseEntries > maxMouseEntries AND lastKey = mouseKey THEN {	 entries[bufferLast].x ¬ place.x;	 entries[bufferLast].y ¬ place.y;	 RETURN};      nMouseEntries ¬ nMouseEntries + 1};    entries[bufferIn] ¬ [      downUp: downUp, p1: splitKey.p1, x: place.x, p2: splitKey.p2,      y: place.y, time: time];    bufferLast ¬ bufferIn;    lastKey ¬ key;    bufferIn ¬ (bufferIn + 1) MOD nEntries;    NOTIFY entriesWaiting};  EnqueueMagicMouseEvent: PUBLIC ENTRY PROC = {    ENABLE UNWIND => NULL;    IF bufferIn = bufferOut THEN {      place: Coords ¬ snrs.mouse[];      IF bufferIn = bufferOut THEN        InternalEnqueueAction[mouseKey, down, place, System.GetClockPulses[]]}    ELSE { -- ASSERT clientQueues.queues[0].item = bufferOut;      mouseSplitKey: SplitKey = [body: real[mouseKey]];      splitKey: SplitKey;      entry: UserActionItemObject ¬ entries[bufferOut];      splitKey ¬ [body: fake[p1: entry.p1, p2: entry.p2]];      IF splitKey.key = mouseKey THEN RETURN;      bufferOut ¬ (bufferOut-1) MOD nEntries;      clientQueues.queues[0].item ¬ bufferOut;      entry.p1 ¬ mouseSplitKey.p1;      entry.p2 ¬ mouseSplitKey.p2;      entries[bufferOut] ¬ entry;      nMouseEntries ¬ nMouseEntries + 1}};  GetAction: PUBLIC ENTRY PROC [    q: Queue, waitMode: WaitMode, waitInterval: Process.Milliseconds,    acceptance: Acceptance]    RETURNS [actionBody: ActionBody] = {    ENABLE UNWIND => NULL;    timedOutActionBody: ActionBody = [contents: timedOut[]];    pulsesCurrent: System.Pulses;  -- records time at action    DO -- until action accepted      WHILE ~ReadEntry[q, @actionBody, @pulsesCurrent] DO        IF ~(WaitForEntry[q, waitMode, waitInterval, q.time] = yes) THEN          RETURN[timedOutActionBody];        ENDLOOP;      IF waitMode = timed        AND EventTimeDifference[pulsesCurrent, q.time] > waitInterval THEN        RETURN[timedOutActionBody];      WITH thisA: actionBody SELECT FROM        keyDown => {q.keys[thisA.key] ¬ down; EXIT};        keyUp => {q.keys[thisA.key] ¬ up; EXIT};        mousePosition => IF acceptance >= clicksAndMotion THEN EXIT;        ENDCASE;      IF acceptance = all THEN EXIT;      ENDLOOP;    q.time ¬ pulsesCurrent;    RETURN[actionBody]};	  ReadEntry: PROC [    q: Queue, destination: POINTER TO ActionBody,    eventPulses: POINTER TO System.Pulses] RETURNS [BOOLEAN] = {    ENABLE UNWIND => NULL;    splitKey: SplitKey;    key: Keys.KeyName;    downUp: DownUp;    IF q.item = bufferIn THEN RETURN[FALSE];    [downUp: downUp, x: q.place.x, p1: splitKey.p1, p2: splitKey.p2,      y: q.place.y, time: eventPulses­] ¬ entries[q.item];    q.item ¬ (q.item + 1) MOD nEntries;    key ¬ splitKey.key;    destination­ ¬ SELECT TRUE FROM      key = mouseKey => [contents: mousePosition[place: q.place]],      downUp = down => [contents: keyDown[key: key]],      ENDCASE => [contents: keyUp[key: key]];    RETURN[TRUE]};      waitALongTime: Process.Milliseconds = 5000;  WaitForEntry: INTERNAL PROC [    q: Queue, waitMode: WaitMode, waitInterval: Process.Milliseconds,    waitStartTime: System.Pulses]    RETURNS [moreEntries: {yes, no, waiting}] = {    ENABLE UNWIND => NULL;    waitTime: Process.Milliseconds ¬ waitInterval;    DO      IF q.item # bufferIn THEN RETURN[yes];      SELECT waitMode FROM        dontWait => RETURN[no];        forever => waitTime ¬ waitALongTime;        timed => {          dif: Process.Milliseconds = EventTimeDifference[            System.GetClockPulses[], waitStartTime];          IF dif >= waitInterval THEN RETURN[no];          waitTime ¬ waitInterval - dif};        ENDCASE;      Wait[waitTime];      ENDLOOP};	    MicToMilli: PROC [mic: System.Microseconds]    RETURNS [mil: Process.Milliseconds] = INLINE {    RETURN[      IF (mic ¬ mic/1000) > LAST[Process.Milliseconds] THEN LAST[      Process.Milliseconds] ELSE Inline.LowHalf[mic]]};	    PulsesToMilli: PROC [pulses: System.Pulses] RETURNS [Process.Milliseconds] =    INLINE {RETURN[MicToMilli[System.PulsesToMicroseconds[pulses]]]};    EventTimeDifference: PROC [t1, t2: System.Pulses]    RETURNS [Process.Milliseconds] = INLINE {    RETURN[PulsesToMilli[System.Pulses[t1 - t2]]]};    Wait: INTERNAL PROC [waitTime: Process.Milliseconds] = {    Process.SetTimeout[@entriesWaiting, Process.MsecToTicks[waitTime]];    WAIT entriesWaiting};    ConsumeTo: PUBLIC ENTRY PROC [q: Queue] = {    ENABLE UNWIND => NULL;    splitKey: SplitKey;    WHILE bufferOut # q.item DO      [p1: splitKey.p1, p2: splitKey.p2] ¬ entries[bufferOut];      IF splitKey.key = mouseKey AND nMouseEntries > 0 THEN        nMouseEntries ¬ nMouseEntries - 1;      bufferOut ¬ (bufferOut + 1) MOD nEntries;      ENDLOOP;    IF bufferIn = bufferOut THEN lastKey ¬ D1;    RETURN};  CreateQueues: PUBLIC ENTRY PROC [nQueues: CARDINAL]    RETURNS [qs: QueueSequence] = {    ENABLE UNWIND => NULL;    qs ¬ clientQueues ¬ UserInputOps.z.NEW[QueueSequenceObject[nQueues]];    FOR i: CARDINAL IN [0..nQueues) DO      qs.queues[i] ¬ [        time: System.GetClockPulses[], place: [0, 0], keys: ALL[up], item: 0];      ENDLOOP;    RETURN};        -- ­Swat processing  InitWatchers: PROC [nWatchers: CARDINAL] = {    OPEN Process;    callersPriority: Priority = GetPriority[];    SetPriority[priorityForeground];    THROUGH [0..nWatchers) DO      Detach[FORK InterruptProcess[ !TooManyProcesses => EXIT]] ENDLOOP;    SetPriority[callersPriority]};      UserAbortProcess: ENTRY PROC = {    ENABLE UNWIND => NULL;    proc: UserInput.AttentionProcType;    window: Window.Handle;    DO      WAIT userAbortWait;      window ¬ Window.BitmapPlaceToWindowAndPlace[userAbortPlace].window;      proc ¬ LOOPHOLE[Context.Find[attentionContext, window]];      IF proc # NIL THEN proc[window ! ABORTED => CONTINUE]      ELSE SetUserAbort[window];      ENDLOOP};  SetAttention: PUBLIC PROC [    window: Window.Handle, attention: UserInput.AttentionProcType] = {    Context.Create[      type: attentionContext,      data: LOOPHOLE[attention],      proc: Context.NopDestroyProc,      window: window ! Context.Error =>        IF code = duplicateType THEN GOTO justSetIt];    EXITS justSetIt =>      Context.Set[attentionContext, LOOPHOLE[attention], window]};  InterruptProcess: PUBLIC PROC = {    OPEN ProcessOperations;    DO      UNTIL Enter[@dummyLock] DO NULL ENDLOOP;      Wait[@dummyLock, @interruptWait, 0];      Runtime.Interrupt[ ! ABORTED => CONTINUE];      ENDLOOP};  StartStimulusLevel: PUBLIC ENTRY PROC = {    OPEN Process;    ENABLE UNWIND => NULL;    callersPriority: Priority = GetPriority[];    SetPriority[ProcessPriorities.priorityPageFaultIO];    Detach[FORK ProcessUserActions];    SetPriority[callersPriority];    snrs ¬ [mouse: InternalMouseSNR, key: InternalEnqueueAction]};  { -- Main body  OPEN Process;  callersPriority: Priority = GetPriority[];  Process.EnableAborts[@entriesWaiting];  DisableTimeout[@interruptWait];  DisableTimeout[@userAbortWait];  SetPriority[ProcessPriorities.priorityIOLow];  Detach[FORK UserAbortProcess[]];  SetPriority[callersPriority];  InitWatchers[2]};  END.  -- of UserInputsALOGDWR 	xxx 15-Apr-85 10:23:58 Tweaked some bits for Dove.  This Keys* stuff has GOT to be rewritten for Tajo 13.0      
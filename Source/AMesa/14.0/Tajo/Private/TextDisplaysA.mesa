-- File: TextDisplaysA.mesa - last edit:-- Riggle.PA           18-Jul-86 14:14:34-- Copyright (C) 1980, 1981, 1982, 1983, 1984 , 1986 by Xerox Corporation. All rights reserved. -- file: TextDisplaysA.mesa-- contains Create, Destroy and Alteration stuff-- Last Edited by:-- SXW   ,	 9-Jul-81 22:26:20-- Mark,	30-Jul-80 16:28:51-- JGS,		 8-Sep-81 10:59:05-- PXK    ,	 1-Sep-81 22:58:05-- SEH,		26-Feb-82 16:57:06-- AXD    ,	18-Oct-82 11:53:14-- BGY     ,	25-Feb-83 16:17:57-- DWR    	 8-Jul-85 14:21:58DIRECTORY  Display: TYPE USING [Shift, White],  Inline USING [LongCOPY],  Heap USING [Create],  ProfileExtra USING [setPositionBalanceBeamChoice, SetPositionBalanceBeamChoice],  TextDisplay: TYPE USING [    Display, DisplayOneLine, GetEOF, Handle, LastLine, LineDescriptor, LinesInBox,    LineStartPlace, LineTable, LineTableObject, Object, Place, PlaceFromPosition,    PositionIsVisible, Selection, Update],  TextDisplayExtra: TYPE,  TextSink USING [Handle],  TextSource USING [nullPosition, Handle, Position],  Window USING [Box, GetBox, Handle, Place],  WindowFont USING [CharWidth];TextDisplaysA: PROGRAM  IMPORTS Display, Inline, Heap, ProfileExtra, TextDisplay, WindowFont, Window  EXPORTS TextDisplay, TextDisplayExtra =  BEGIN OPEN TextSource;  -- copied TYPEs  LineDescriptor: TYPE = TextDisplay.LineDescriptor;  LineTable: TYPE = TextDisplay.LineTable;    -- new TYPEs  LineStartsTable: TYPE = RECORD [    array: SEQUENCE arraySize: CARDINAL OF Position  ];  LineStarts: TYPE = LONG POINTER TO LineStartsTable;  -- Definitions  z: PUBLIC UNCOUNTED ZONE;  guess: CARDINAL = 40;  -- a guess of typical linetable height  RequestNewBoxHeight: PUBLIC SIGNAL [p: TextDisplay.Handle, delta: INTEGER]    RETURNS [CARDINAL] = CODE;  -- Interface Procedures   Adjust: PUBLIC PROC [    p: TextDisplay.Handle, box: Window.Box, select: TextDisplay.Selection] =    BEGIN    IF p.box.dims.w = box.dims.w THEN AlterBoxHeight[p, box.dims.h, select]    ELSE      BEGIN      IF p.options.rightBreak # none THEN p.allBetsAreOff ¬ TRUE      ELSE AlterBoxHeight[p, box.dims.h, select];      p.box ¬ box;      END    END;  BackupNLines: PUBLIC PROC [    p: TextDisplay.Handle, lines: CARDINAL, select: TextDisplay.Selection] =    BEGIN OPEN p;    charsPerLine: CARDINAL = p.wh.GetBox.dims.w / WindowFont.CharWidth['W];    delta: CARDINAL = charsPerLine*lines;    lt: LineTable;    position: TextSource.Position;    IF p.lineTable[0].pos = 0 THEN RETURN;    position ¬ IF delta>p.lineTable[0].pos THEN 0 ELSE p.lineTable[0].pos - delta;    lt ¬ BuildLineTable[      p: p, start: position, stop: p.lineTable[0].pos,       lines: lines, useLines: TRUE];    lines ¬ MIN[lt.length, lines];    position ¬ lt[lt.length - lines].pos;    lines ¬ lt.LastLine[] + 1;    IF p.lineTable.length # 1 AND lines < p.lineTable.length THEN      BEGIN      MoveLines[p, 0, lines];      p.lineTable[0].pos ¬ position;      p.Update[position, p.lineTable[lines].pos - 1, select, FALSE];      END    ELSE      BEGIN      Display.White[wh, box];      p.lineTable[0].pos ¬ position;      p.Display[select];      END;    IF lt # NIL THEN z.FREE[@lt];    END; « A smarter BackupNLines.  Unfortunately it's far slower!  Guarantees to back up N lines, unlike the other routine which merely takes a guess.  Uses MeasureLinesBetween.  Algorithm: if at the beginning of the source, return.  Otherwise, call MeasureLinesBetween with lineTable[0].pos and the character before it.  Use the arrayLength return value to get as close to the line we want as possible.  Repeat calls to MeasureLinesBetween until we can pick out the position we want. »        ReallyBackupNLines: PUBLIC PROC [    p: TextDisplay.Handle, lines: CARDINAL, select: TextDisplay.Selection] = {    position: Position;    IF p.lineTable[0].pos = 0 THEN RETURN;    position ¬ FindNLinesBefore[p, lines, p.lineTable[0].pos];    IF p.lineTable.length # 1 AND lines < p.lineTable.length THEN      BEGIN      MoveLines[p, 0, lines];      p.lineTable[0].pos ¬ position;      p.Update[position, p.lineTable[lines].pos - 1, select, FALSE];      END    ELSE      BEGIN      Display.White[p.wh, p.box];      p.lineTable[0].pos ¬ position;      p.Display[select];      END;  };       -- Find N lines before a certain position.  Good for SetPosition when the position  -- you want to go to is farther than maxlines away.  Also helps with  -- SetPositionBalanceBeam.  This routine degenerates to StartLine if lines = 0;      FindNLinesBefore: PUBLIC PROC [p: TextDisplay.Handle, lines: CARDINAL, position: Position] RETURNS [startOfLine: Position]= {    linesToGo: CARDINAL ¬ lines;    screenLines: CARDINAL ¬ MAX[p.lineTable.length, 3]; -- less than 3 won't work below    startArray: LineStarts ¬ NIL;    length: CARDINAL;    IF p.box.dims.w = 0 THEN RETURN [0]; -- can't measure a zero width window    DO      IF position = 0 THEN {        z.FREE[@startArray];	RETURN [0]; -- at the beginning of the source      };      [startArray, length, ] ¬ MeasureLinesBetween[p, position, position - 1, screenLines, startArray];      -- screenLines will never be exceeded because we're only looking at one line max!      IF length > linesToGo THEN { -- we have your line!        startOfLine ¬ startArray[length - linesToGo - 1];        z.FREE[@startArray]; 	EXIT;      };      linesToGo ¬ linesToGo - length + 1;      position ¬ startArray[0];    ENDLOOP;  };     « Returns the number of screen lines between two TextSource.Positions.  "leftMargin" is a position somewhere on the left margin (e.g. a lineTable[x].pos value), and "findMe" is a position either before or after "leftMargin."  If the number of lines between the two positions is greater than "maxLines", then 0 is returned for "arrayLength".  "maxLines" is useful when you don't want the entire source to be measured if the number of screen lines between two points is more than one screenful, for example.  If oldArray is not NIL, then it will be re-used instead of allocating a new array for arrayOfLineStarts.  This routine is useful for BackupNLines so it can verify that the number of lines it backs up is correct.  Also, this routine helps SetPosition save as many bits on the screen as possible, and makes possible a SetPositionBalanceBeam.  An array of line starting positions is returned along with the length and also the index of findMe's line in that array.  How this array in interpreted depends upon whether findMe < leftMargin.  If it is, then arrayOfLineStarts[0] is the beginning of some line (possibly before) findMe's line, findMeIndex is the line that findMe is on, arrayOfLineStarts[arrayLength-1] = leftMargin, and the number of lines to scroll backward to see findMe is arrayLength - 1 - findMeIndex.  If findMe > leftMargin then arrayOfLineStarts[0] = leftMargin, arrayLength - 1 = findMeIndex, and the number of lines to scroll up = arrayLength - 1 (unless leftMargin = lineTable.lastPositionPlusOne; then you would scroll arrayLength lines).  It is the calling routine's responsibility to free the returned array when it is finished with it.  (P.S. Actually, if findMe < leftMargin, then leftMargin really doesn't have to be a position on the left margin; its line start position will be arrayOfLineStarts[arrayLength - 1].)  If '"wantTheArray" is FALSE, then the result "arrayOfLineStarts" is always NIL.  »  MeasureLinesBetween: PUBLIC PROC [    p: TextDisplay.Handle, leftMargin, findMe: Position, maxLines: CARDINAL ¬ 40,    oldArray: LineStarts ¬ NIL, wantTheArray: BOOLEAN ¬ TRUE]    RETURNS [arrayOfLineStarts: LineStarts ¬ NIL, arrayLength, findMeIndex: CARDINAL ¬ 0] = {    veryLongLine: CARDINAL = MAX[p.wh.GetBox.dims.w / WindowFont.CharWidth['e], 1];    oldLT: LineTable ¬ p.lineTable;    temp, start, end: Position;    IF MAX[leftMargin, findMe] - MIN[leftMargin, findMe] > veryLongLine*maxLines      OR maxLines <= 1 THEN RETURN [oldArray, 0, 0]; -- it's over the horizon    p.lineTable ¬ NewLineTable[NIL, 1, FALSE];    IF wantTheArray THEN {      IF oldArray # NIL THEN {	arrayOfLineStarts ¬ oldArray;	oldArray ¬ NIL;      } ELSE {	arrayOfLineStarts ¬ z.NEW[LineStartsTable[maxLines]];      };    };    IF findMe < leftMargin THEN { -- find a starting place behind us      p.lineTable[0].pos ¬ p.source.scanText[        source: p.source, start: findMe, type: line, direction: left];      arrayLength ¬ 1;      IF wantTheArray THEN arrayOfLineStarts[0] ¬ p.lineTable[0].pos;      DO	[temp, ] ¬ p.DisplayOneLine[[0, 0], NIL, measure];	IF temp >= findMe THEN EXIT;	p.lineTable[0].pos ¬ temp;	IF wantTheArray THEN arrayOfLineStarts[arrayLength] ¬ temp;	arrayLength ¬ arrayLength + 1;	IF wantTheArray AND arrayLength = arrayOfLineStarts.arraySize THEN { 	  newArray: LineStarts ¬ z.NEW[LineStartsTable[arrayOfLineStarts.arraySize+40]];	  FOR i: CARDINAL IN [0..arrayOfLineStarts.arraySize) DO	    newArray[i] ¬ arrayOfLineStarts[i];	  ENDLOOP;	  z.FREE[@arrayOfLineStarts];	  arrayOfLineStarts ¬ newArray;	};      ENDLOOP;      findMeIndex ¬ arrayLength - 1;      start ¬ temp;  -- start of next line      end ¬ leftMargin;    } ELSE {  -- count from leftMargin to findMe      start ¬ leftMargin;      end ¬ findMe;    };    IF start > end OR (start = end AND end = p.GetEOF[]) THEN { -- leftMargin and findMe are on the same line      z.FREE[@p.lineTable];      p.lineTable ¬ oldLT;      RETURN [arrayOfLineStarts, arrayLength, findMeIndex];    };    p.lineTable[0].pos ¬ start;    IF wantTheArray THEN arrayOfLineStarts[arrayLength] ¬ start;    arrayLength ¬ arrayLength + 1;    DO      [temp, ] ¬ p.DisplayOneLine[[0, 0], NIL, measure];      IF temp > end THEN EXIT;      p.lineTable[0].pos ¬ temp;      IF wantTheArray THEN arrayOfLineStarts[arrayLength] ¬ temp;      arrayLength ¬ arrayLength + 1;      IF (maxLines ¬ maxLines - 1) <= 1 THEN { -- not worthwhile to continue         IF arrayOfLineStarts # NIL THEN z.FREE[@arrayOfLineStarts];	z.FREE[@p.lineTable];        p.lineTable ¬ oldLT;	RETURN [oldArray, 0, 0];      };      IF temp = end THEN EXIT; -- hit it right on the nose!      IF wantTheArray AND arrayLength = arrayOfLineStarts.arraySize THEN { 	newArray: LineStarts ¬ z.NEW[LineStartsTable[arrayOfLineStarts.arraySize+40]];	FOR i: CARDINAL IN [0..arrayOfLineStarts.arraySize) DO	  newArray[i] ¬ arrayOfLineStarts[i];	ENDLOOP;	z.FREE[@arrayOfLineStarts];	arrayOfLineStarts ¬ newArray;      };    ENDLOOP;    IF findMe > leftMargin THEN -- findMeIndex not set yet       findMeIndex ¬ arrayLength - 1; -- the line that findMe is on    z.FREE[@p.lineTable];    p.lineTable ¬ oldLT;    };  Create: PUBLIC PROC [    wh: Window.Handle, source: TextSource.Handle, sink: TextSink.Handle,    storage: TextDisplay.Handle ¬ NIL] RETURNS [p: TextDisplay.Handle] =    BEGIN    ownStorage: BOOLEAN;    IF storage # NIL THEN {ownStorage ¬ FALSE; p ¬ storage}    ELSE {ownStorage ¬ TRUE; p ¬ z.NEW[TextDisplay.Object]};    p­ ¬ [      source: source, lineTable: NewLineTable[NIL, 1, FALSE],      options: [word, scroll, 4], allBetsAreOff: TRUE, wh: wh, sink: sink,      ownStorage: ownStorage, box: [[0, 0], [0, 0]]];    p.lineTable[0].pos ¬ 0;    RETURN[p];    END;  Destroy: PUBLIC PROC [p: TextDisplay.Handle] RETURNS [TextDisplay.Handle] =    BEGIN    IF p # NIL THEN {      IF p.lineTable # NIL THEN z.FREE[@p.lineTable];      IF p.ownStorage THEN z.FREE[@p]};    RETURN[NIL]    END;  SetEOF: PUBLIC PROC [    p: TextDisplay.Handle, eof: Position, select: TextDisplay.Selection] =    BEGIN OPEN p;    IF eof < p.lineTable[0].pos THEN p.lineTable[0].pos ¬ eof;    IF select # NIL THEN      BEGIN      IF select.left > eof THEN select.left ¬ eof;      IF select.right > eof THEN select.right ¬ eof;      END;    [] ¬ source.setLength[source, eof];    Display.White[wh, box];    p.Display[select]    END; « OldSetPosition: PUBLIC PROC [    p: TextDisplay.Handle, position: Position, select: TextDisplay.Selection] =    BEGIN    IF p.allBetsAreOff THEN p.lineTable[0].pos ¬ position    ELSE      BEGIN      DisplayLocal: PROC = {        IF p.lineTable.length # 1 THEN {          lineMoved: CARDINAL ¬ p.PlaceFromPosition[position, FALSE].line;          MoveLines[p, lineMoved, 0];          p.Update[            IF p.lineTable.lastPositionPlusOne = 0 THEN 0            ELSE p.lineTable.lastPositionPlusOne - 1, p.source.getLength[            p.source], select, FALSE]}        ELSE {          realLineTable: LineTable = p.lineTable;          lt: LineTable ¬ BuildLineTable[	    p: p, start: p.lineTable[0].pos, stop: position];          Display.White[p.wh, p.box];          p.lineTable ¬ lt;          realLineTable[0] ¬ lt[p.PlaceFromPosition[position, FALSE].line];          p.lineTable ¬ realLineTable;          IF lt # NIL THEN z.FREE[@lt];          p.Display[select]};        };      IF p.lineTable.LastLine[] > 0 AND p.PositionIsVisible[position] THEN        [] ¬ DisplayLocal[]      ELSE        BEGIN        temp: Position ¬ StartOfLine[p, position];	IF temp # p.lineTable[0].pos THEN          BEGIN          Display.White[p.wh, p.box];          p.lineTable[0].pos ¬ temp;          p.Display[select]          END;        WHILE ~p.PositionIsVisible[position] DO          temp ¬ p.lineTable[0].pos;          DisplayLocal[];          IF temp = p.lineTable[0].pos THEN EXIT;  -- Not visible.  Don't loop!          ENDLOOP;        END;      END;    END; »-- A smarter SetPosition.  It re-uses as many of the screen bits as possible when jumping-- to a new location.  It also understands a SetPositionBalanceBeam which allows a user to-- decide where he wants the selection displayed.  If SetPositionWithOverRide is called,-- then the specified value of setPositionBalanceBeamChoice is used instead of the one-- recorded in ProfileExtra.«algorithm: if the position is visible, don't do anything fancy.  Otherwise, if jumping backwards, find the line that we want to jump to and the number of lines that we must move the screen down.  Print!  If jumping forwards, find then number of lines we need to move. »  SetPosition: PUBLIC PROC [    p: TextDisplay.Handle, position: Position, select: TextDisplay.Selection] = {    SetPositionWithOverRide[p, position, select,      ProfileExtra.setPositionBalanceBeamChoice]};   SetPositionWithOverRide: PUBLIC PROC [    p: TextDisplay.Handle, position: Position, select: TextDisplay.Selection, overRide: ProfileExtra.SetPositionBalanceBeamChoice] =    BEGIN    IF p.allBetsAreOff THEN p.lineTable[0].pos ¬ position    ELSE      BEGIN      DisplayLocal: PROC [lineMoved: CARDINAL] = {        IF p.lineTable.length # 1 THEN {          MoveLines[p, lineMoved, 0];          p.Update[            IF p.lineTable.lastPositionPlusOne = 0 THEN 0            ELSE p.lineTable.lastPositionPlusOne - 1, p.source.getLength[            p.source], select, FALSE]}        ELSE {          realLineTable: LineTable = p.lineTable;          lt: LineTable ¬ BuildLineTable[	    p: p, start: p.lineTable[0].pos, stop: position];          Display.White[p.wh, p.box];          p.lineTable ¬ lt;          realLineTable[0] ¬ lt[p.PlaceFromPosition[position, FALSE].line];          p.lineTable ¬ realLineTable;          IF lt # NIL THEN z.FREE[@lt];          p.Display[select]};        };	      IF --p.lineTable.LastLine[] > 0 AND-- p.PositionIsVisible[position] THEN        IF overRide = middle THEN {	  lineInQuestion: CARDINAL = p.PlaceFromPosition[position, FALSE].line;	  halfScreen: CARDINAL = (p.lineTable.length-1)/2;	  IF lineInQuestion < halfScreen THEN	    ReallyBackupNLines[p, halfScreen - lineInQuestion, select]	  ELSE	    [] ¬ DisplayLocal[lineMoved: lineInQuestion - halfScreen];	} ELSE           [] ¬ DisplayLocal[lineMoved: p.PlaceFromPosition[position, FALSE].line]      ELSE        BEGIN	bruteForce: BOOLEAN ¬ FALSE; -- must we redraw the whole screen?	nLines: CARDINAL = IF overRide = middle THEN (p.lineTable.length-1)/2 ELSE 0;	startOfLine: Position ¬ TextSource.nullPosition;	-- the position is not visible.  Are we jumping forward or backwards?	IF position > p.lineTable[0].pos THEN { -- forward jump	  IF overRide = top THEN	    bruteForce ¬ TRUE -- don't attempt to save any bits	  ELSE {	    length: CARDINAL;	    [, length, ] ¬ MeasureLinesBetween[p, p.lineTable.lastPositionPlusOne, position, p.lineTable.length, , FALSE];	    IF length = 0 THEN { --more than a screenful away!	      -- brute force set position.  call findNLinesBefore...	      bruteForce ¬ TRUE;	    } ELSE {	      SELECT overRide FROM	        topBottom => [] ¬ DisplayLocal[lineMoved: length]; -- save the most bits		middle => {		  IF INTEGER[length] > (p.lineTable.length-1)/2 THEN bruteForce ¬ TRUE -- no bits can be saved		  ELSE [] ¬ DisplayLocal[lineMoved: length + (p.lineTable.length-1)/2]; -- save some		};	      ENDCASE => bruteForce ¬ TRUE; -- should never happen	    };	  };	} ELSE { -- backward jump	  length: CARDINAL;	  startOfLine ¬ FindNLinesBefore[p, nLines, position];	  [, length, ] ¬ MeasureLinesBetween[p, startOfLine, p.lineTable[0].pos, p.lineTable.length, , FALSE];	  IF length = 0 THEN bruteForce ¬ TRUE -- note: true if p.lineTable.length = 1	  ELSE {	    MoveLines[p, 0, length - 1];	    p.lineTable[0].pos ¬ startOfLine;	    p.Update[startOfLine, p.lineTable[length - 1].pos - 1, select, FALSE];	  };	};	IF bruteForce THEN {	  IF startOfLine = TextSource.nullPosition THEN	    startOfLine ¬ FindNLinesBefore[p, nLines, position];	  IF startOfLine # p.lineTable[0].pos THEN	    BEGIN	    Display.White[p.wh, p.box];	    p.lineTable[0].pos ¬ startOfLine;	    p.Display[select]	    END;	  WHILE ~p.PositionIsVisible[position] DO	    startOfLine ¬ p.lineTable[0].pos;	    DisplayLocal[lineMoved: p.PlaceFromPosition[position, FALSE].line];	    IF startOfLine = p.lineTable[0].pos THEN EXIT;  -- Not visible.  Don't loop!	    ENDLOOP;	  };        END;      END;    END;  StartOfLine: PROC [p: TextDisplay.Handle, pos: Position]     RETURNS [position: Position] = {RETURN [FindNLinesBefore[p, 0, pos]]};    -- replaced by FindNLinesBefore « StartOfLine: PROC [p: TextDisplay.Handle, pos: Position]     RETURNS [position: Position] = {    oldLT: LineTable ¬ p.lineTable;    temp: Position;    crOnEnd: BOOLEAN;    start: Position ¬ p.source.scanText[      source: p.source, start: MIN[pos + 1, p.source.getLength[p.source]],       type: line, direction: left];    position ¬ pos;    IF start >= pos THEN RETURN;    p.lineTable ¬ NewLineTable[NIL, 1, FALSE];    p.lineTable[0].pos ¬ start;    DO      [temp, crOnEnd] ¬ p.DisplayOneLine[[0, 0], NIL, measure];      IF pos <= temp THEN EXIT;      p.lineTable[0].pos ¬ temp;      ENDLOOP;    position ¬ p.lineTable[0].pos;    z.FREE[@p.lineTable];    p.lineTable ¬ oldLT;    }; »      -- Public Utilities  AlterBoxHeight: PUBLIC PROC [    p: TextDisplay.Handle, newH: INTEGER, select: TextDisplay.Selection] =    BEGIN OPEN p;    IF newH # box.dims.h THEN      BEGIN      oldH: INTEGER = box.dims.h;      newLines, oldLines: CARDINAL;      boxToClear: Window.Box;      box.dims.h ¬ newH;      oldLines ¬ p.lineTable.length;      newLines ¬ p.LinesInBox[p.box];      p.lineTable ¬ NewLineTable[p.lineTable, newLines, TRUE];      boxToClear.place ¬ [        p.box.place.x, p.LineStartPlace[        IF oldH < box.dims.h THEN oldLines ELSE newLines].y];      boxToClear.dims ¬ [p.box.dims.w, p.box.place.y + newH - boxToClear.place.y];      Display.White[wh, boxToClear];      p.Update[        IF p.lineTable.lastPositionPlusOne = 0 THEN 0        ELSE p.lineTable.lastPositionPlusOne - 1, source.getLength[source], select];      END;    END;  AlterBoxY: PUBLIC PROC [p: TextDisplay.Handle, newY: INTEGER] =    BEGIN OPEN p;    IF newY # box.place.y THEN      BEGIN      oldY: INTEGER ¬ p.box.place.y;      Display.Shift[wh, p.box, [p.box.place.x, newY]];      Display.White[        wh,        IF newY > oldY THEN [p.box.place, [p.box.dims.w, newY - oldY]]        ELSE [[p.box.place.x, newY + box.dims.h], [p.box.dims.w, oldY - newY]]];      p.box.place.y ¬ newY;      END;    END;  BuildLineTable: PROC [p: TextDisplay.Handle, start, stop: Position,     lines: CARDINAL ¬ guess, useLines: BOOLEAN ¬ FALSE, startHint: BOOLEAN ¬ TRUE]    RETURNS [lt: LineTable] =    BEGIN    -- returned line table must not contain NULL entries!    i: CARDINAL ¬ 0;    j: CARDINAL ¬ 0;    temp: Position;    lastTemp: Position;    crOnEnd: BOOLEAN;    oldLT: LineTable ¬ p.lineTable;    IF start > 0 AND startHint THEN start ¬ p.source.scanText[      source: p.source, start: start, type: line, direction: left];    lastTemp ¬ start;    p.lineTable ¬ NewLineTable[NIL, lines, FALSE];    p.lineTable[0].pos ¬ start;    DO      [temp, crOnEnd] ¬ p.DisplayOneLine[[i, 0], NIL, measure];      IF temp >= stop OR temp = lastTemp THEN EXIT;      lastTemp ¬ temp;      i ¬ i + 1;      IF (i # 1 AND i MOD guess = 0) OR (i >= lines) THEN {        IF useLines THEN {	  FOR j IN [1..lines) DO	    p.lineTable[j-1] ¬ p.lineTable[j];	    ENDLOOP;	  i ¬ i - 1;	  }	ELSE {	  p.lineTable ¬ NewLineTable[p.lineTable, i + guess, TRUE];	  lines ¬ lines + guess}};      p.lineTable[i].pos ¬ temp;      ENDLOOP;    lt ¬ IF useLines THEN p.lineTable         ELSE NewLineTable[p.lineTable, i + 1, TRUE];    lt.crIsLast ¬ crOnEnd;    lt.lastPositionPlusOne ¬ temp;    p.lineTable ¬ oldLT;    END;  CheckBoxHeight: PUBLIC PROC [    p: TextDisplay.Handle, select: TextDisplay.Selection] =    BEGIN OPEN p;    -- checks for text under/overflow and asks client to adjust    IF options.bottomAction = signal THEN      BEGIN      lastLine: CARDINAL = p.lineTable.LastLine[];      oldH: INTEGER ¬ box.dims.h;  -- whay is this not used???      delta: INTEGER ¬ 0;      fontHeight: INTEGER ¬ sink.fontInfo[sink].lineHeight;      IF lastLine + 1 < p.lineTable.length THEN        delta ¬ -((p.lineTable.length - (lastLine + 1))*fontHeight)      ELSE        IF p.lineTable.lastPositionPlusOne # source.getLength[source]          OR            (p.lineTable.crIsLast              AND p.lineTable.lastPositionPlusOne # p.lineTable[lastLine].pos) THEN          BEGIN  -- overflow          lt: LineTable ¬ BuildLineTable[            p: p, start: p.lineTable.lastPositionPlusOne, 	    stop: source.getLength[source], startHint: FALSE];          	  Diff: PROC RETURNS [diff: CARDINAL] = {	    RETURN [	      SELECT TRUE FROM	        p.lineTable[lastLine + 1].pos # TextSource.nullPosition => 0,		ENDCASE => lt.length];};	    	  delta ¬ 	    (Diff[] + (IF p.lineTable.crIsLast THEN 1 ELSE 0))*fontHeight;          z.FREE[@lt];          END;      IF delta # 0 THEN        AlterBoxHeight[p, SIGNAL RequestNewBoxHeight[p, delta], select];      END;    END;  FindLineBreak: PUBLIC PROC [p: TextDisplay.Handle, position: Position]    RETURNS [Position] =    BEGIN OPEN p;    IF position = 0 THEN RETURN[0];    IF p.PositionIsVisible[position] THEN      BEGIN      textPlace: TextDisplay.Place ¬ p.PlaceFromPosition[position, FALSE];      RETURN[p.lineTable[textPlace.line].pos];      END    ELSE RETURN[source.scanText[source, position - 1, line, right]];    END;  MoveLines: PUBLIC PROC [p: TextDisplay.Handle, from, to: CARDINAL] =    BEGIN OPEN p;    i, firstClearLine, linesToMove, linesToClear: CARDINAL;    delta: INTEGER = IF to > from THEN to - from ELSE -(from - to);    boxToMove: Window.Box;    newPlace: Window.Place;    fontHeight: INTEGER;    IF from = to OR p.lineTable.length = 1 THEN RETURN;    linesToMove ¬ p.lineTable.length - (IF to > from THEN to ELSE from);    fontHeight ¬ p.sink.fontInfo[p.sink].lineHeight;    boxToMove ¬ [p.LineStartPlace[from], [box.dims.w, linesToMove*fontHeight]];    newPlace ¬ p.LineStartPlace[to];    IF delta > 0 THEN  -- moving down      BEGIN      IF p.lineTable[from + linesToMove].pos # TextSource.nullPosition THEN        p.lineTable.lastPositionPlusOne ¬ p.lineTable[from + linesToMove].pos;      FOR i DECREASING IN [from..from + linesToMove) DO        p.lineTable[i + delta] ¬ p.lineTable[i]; ENDLOOP;      firstClearLine ¬ from;      linesToClear ¬ delta;      END    ELSE  -- moving up      BEGIN      FOR i IN [from..from + linesToMove) DO        p.lineTable[i + delta] ¬ p.lineTable[i]; ENDLOOP;      firstClearLine ¬ to + linesToMove;      linesToClear ¬ -delta;      END;    Display.Shift[wh, boxToMove, newPlace];    Display.White[      wh, [      p.LineStartPlace[firstClearLine], [box.dims.w, fontHeight*linesToClear]]];    FOR i IN [firstClearLine..firstClearLine + linesToClear) DO      p.lineTable[i].pos ¬ TextSource.nullPosition; ENDLOOP;    END;  NewLineTable: PUBLIC PROC [old: LineTable, lines: CARDINAL, copy: BOOLEAN]    RETURNS [new: LineTable] =    BEGIN    i: CARDINAL;    new ¬ z.NEW[      TextDisplay .LineTableObject[lines + 2] ¬ [      firstPosition: 0, lastPositionPlusOne: 0, crIsLast: FALSE, length: lines,      array:]];    new[0] ¬ [pos: TextSource.nullPosition, width: 0];    Inline.LongCOPY[      from: @new[0], to: @new[1], nwords: (lines + 1)*SIZE[LineDescriptor]];    IF old # NIL AND copy THEN {      FOR i IN [0..MIN[lines, old.length]) DO new[i] ¬ old[i] ENDLOOP;      IF new.length < old.length AND       old[new.length].pos # TextSource.nullPosition THEN        new.lastPositionPlusOne ¬ old[new.length].pos      ELSE {        new.lastPositionPlusOne ¬ old.lastPositionPlusOne;        new.crIsLast ¬ old.crIsLast};      };    IF old # NIL THEN z.FREE[@old];    END;  z ¬ Heap.Create[        initial: 16, increment: 8, threshold: 3, largeNodeThreshold: 256, 	ownerChecking: FALSE, checking: FALSE];  END. -- of TextDisplaysA.mesaLOGDWR 	 7-Nov-84 14:44:49  wrote MeasureLinesBetween, etc.DWR 	 9-May-85 11:04:41  added MAX[w/charwidth['e], 1] to keep small windows from failingDWR 	 8-Jul-85 14:04:04  patched FindNLinesBefore to keep small windows from failing
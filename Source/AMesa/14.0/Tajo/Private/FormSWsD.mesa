-- Copyright (C) 1981, 1982, 1983  by Xerox Corporation. All rights reserved. -- File: [igor]<Emerson>Tajo>Private>FormSWsD.mesa - last edited:-- SXW    on 10-Jul-81 11:09:22-- Mark on 28-Feb-81 15:06:55-- JGS on 17-Aug-81 12:18:19-- SEH on 14-Jan-82 10:51:03-- BGY      on  18-Nov-83 14:16:43DIRECTORY  Context USING [Find],  Display USING [White],  FormSW USING [Error, ItemDescriptor, ItemHandle, line0, nextLine,     nullIndex, Radix, sameLine, Type, Wakeup],  FormSWOps USING [ClearCachedInfo, context, ConvertProcType,     DeleteCurrentSelection, dijectMargin, DijectSelection, FindContext,     fontHeight, ForceValidSelection, InOp, InvertItem, ItemDescriptor,     LockContextProcType, ModifyProcType, moveCopy,     OverUnderflowSlide, PContext, PositionInBody, RealActOnCaret,     ReplaceSelection, SelectionObject, SelectionPointer, StuffString, TagLength],  Heap USING [systemZone],  Inline USING [LowHalf],  Selection USING [ActOn, ActOnProcType, Action, Clear, Convert,     ConvertInsertion, ConvertProcType, ConvertTrashBin,     DestroyProc, maxStringLength, Set, SetInsertion, Source,     SourceObject, SourceProc, Target],  String USING [AppendChar, AppendDecimal, AppendLongDecimal,     AppendLongNumber, AppendNumber,      AppendStringAndGrow, MakeString],  TextData USING [Position, Selection, SelectionObject],  TextDisplay USING [Bold, Display, Handle, MarkSelection,     noPlace, RequestNewBoxHeight],  TextSource USING [AsciiAppend, Handle, nullPosition, Position],  ToolWindow USING [Box, DrawRectangle, Handle, WindowForSubwindow],  UserTerminal USING [BlinkDisplay],  Window USING [Box, Handle, Place, Validate];FormSWsD: MONITOR LOCKS myContext.lock USING myContext: FormSWOps.PContext  IMPORTS    Context, Display, Heap, Inline, FormSW, FormSWOps, Selection, String,      TextDisplay, TextSource, ToolWindow, UserTerminal, Window  EXPORTS FormSW, FormSWOps =  BEGIN  -- TYPEs  StuffSource: TYPE = LONG POINTER TO StuffSourceObject;  StuffSourceObject: TYPE = RECORD [    position: TextSource.Position,    length: LONG CARDINAL,    context: FormSWOps.PContext,    textSource: TextSource.Handle];      z:UNCOUNTED ZONE ¬ Heap.systemZone;    -- PROCEDUREs implementing the interface  GetSelection: PUBLIC PROCEDURE [sw: Window.Handle]    RETURNS [index, first, last: CARDINAL] =    BEGIN    myContext: FormSWOps.PContext = FormSWOps.FindContext[sw];    tagLength: CARDINAL;    LockedGetSelection: ENTRY FormSWOps.LockContextProcType =       BEGIN OPEN ms: myContext.selection;      index ¬ ms.index;      IF index = FormSW.nullIndex THEN RETURN;      tagLength ¬ FormSWOps.TagLength[myContext.dijects[index].source];      first ¬ Inline.LowHalf[ms.textSelect.left - tagLength];      last ¬ Inline.LowHalf[ms.textSelect.right - tagLength];      END;    IF myContext = NIL THEN {index ¬ FormSW.nullIndex; first ¬ last ¬ 0}    ELSE LockedGetSelection[myContext];    END;  GetTypeIn: PUBLIC PROCEDURE [sw: Window.Handle]    RETURNS [index, position: CARDINAL] =    BEGIN    myContext: FormSWOps.PContext = FormSWOps.FindContext[sw];    IF myContext = NIL THEN {index ¬ FormSW.nullIndex; position ¬ 0}    ELSE      BEGIN      index ¬ myContext.insertion.index;      position ¬ Inline.LowHalf[myContext.insertion.textInsert.position];      END;    END;  LineHeight: PUBLIC PROCEDURE [sw: Window.Handle ¬ NIL] RETURNS [CARDINAL] =    -- All lines have height at least (fontHeight+2*dijectMargin) in order    -- to allow the current selection to be indicated without problems.    BEGIN RETURN[FormSWOps.fontHeight + 2*FormSWOps.dijectMargin]; END;  MinHeight: PUBLIC PROCEDURE [items: FormSW.ItemDescriptor, type: FormSW.Type]    RETURNS [min: CARDINAL] =    BEGIN    first, last: CARDINAL;    [first, last] ¬ VisibleEndpoints[items];    min ¬      IF first = FormSW.nullIndex THEN 0      ELSE FastMinHeight[items, type, first, last];    END;  NeededHeight: PUBLIC PROCEDURE [sw: Window.Handle]    RETURNS [min, current: CARDINAL] =    BEGIN    myContext: FormSWOps.PContext = FormSWOps.FindContext[sw];    -- Consider the impact on ScrollVertical before changing this routine!    LockedNeededHeight: ENTRY FormSWOps.LockContextProcType =       BEGIN       ENABLE UNWIND => NULL;      i, lastVisible, firstVisible: CARDINAL;      [firstVisible, lastVisible] ¬ VisibleEndpoints[myContext.items];      IF firstVisible = FormSW.nullIndex THEN RETURN;  -- No visible items?  Caller must be joking!      min ¬ FastMinHeight[myContext.items, myContext.options.type,         firstVisible, lastVisible];      -- Compute current      IF myContext.dijects # NIL THEN        BEGIN        lastY: INTEGER = myContext.dijects[lastVisible].box.place.y;        maxH: INTEGER ¬ 0;        FOR i DECREASING IN [firstVisible..lastVisible] DO          IF myContext.items[i].flags.invisible THEN LOOP;          IF myContext.dijects[i].box.place.y < lastY THEN EXIT;          maxH ¬ MAX[maxH, myContext.dijects[i].box.dims.h];          ENDLOOP;        current ¬ lastY + maxH - myContext.dijects[firstVisible].box.place.y;        END;      current ¬ MAX[min, current];  -- dijects = NIL or never displayed      END;    min ¬ current ¬ 0;    IF myContext # NIL THEN LockedNeededHeight[myContext];    END;  SetCurrent: PUBLIC PROCEDURE [sw: Window.Handle, index: CARDINAL] =    BEGIN    myContext: FormSWOps.PContext = FormSWOps.FindContext[sw];    IF myContext # NIL THEN      BEGIN      selectLeft: CARDINAL;      IF myContext.dijects = NIL THEN FormSW.Wakeup[sw];      selectLeft ¬        IF index = FormSW.nullIndex THEN CARDINAL.LAST        ELSE FormSWOps.TagLength[myContext.dijects[index].source];      IF ~FormSWOps.moveCopy AND ~myContext.items[index].flags.readOnly THEN         SetTypeIn[sw, index, CARDINAL.LAST];      SetSelection[sw, index, selectLeft, CARDINAL.LAST];      END;    END;  SetSelection: PUBLIC PROCEDURE [    sw: Window.Handle, index, first, last: CARDINAL] =    BEGIN    myContext: FormSWOps.PContext = FormSWOps.FindContext[sw];    markSelection: BOOLEAN ¬ FALSE;    LockedSetSelection: ENTRY FormSWOps.LockContextProcType =       BEGIN      ENABLE UNWIND => NULL;      IF index # FormSW.nullIndex THEN        BEGIN        WITH item: myContext.items[index] SELECT FROM          longNumber, number, string =>            BEGIN OPEN di: myContext.dijects[index];            myContext.selection ¬ [              index: index, textSelect: [first, last, text, video, FALSE]];            FormSWOps.ForceValidSelection[              @myContext.selection, Inline.LowHalf[              di.source.getLength[di.source]]];            Selection.Set[myContext, ConvertSelection, ActOnSelection];            markSelection ¬ TRUE;            RETURN;            END;          ENDCASE;        END;      myContext.selection.index ¬ FormSW.nullIndex      END;    Selection.Clear[];    IF myContext # NIL THEN      BEGIN      IF myContext.dijects = NIL THEN FormSW.Wakeup[sw];      LockedSetSelection[myContext];      IF markSelection THEN Selection.ActOn[mark];      END;    END;  SetTypeIn: PUBLIC PROCEDURE [sw: Window.Handle, index, position: CARDINAL] =    BEGIN    myContext: FormSWOps.PContext;    LockedSetTypeIn: ENTRY FormSWOps.LockContextProcType =       BEGIN      ENABLE UNWIND => NULL;      FormSWOps.RealActOnCaret[myContext, clear];      IF index # FormSW.nullIndex THEN        BEGIN         IF myContext.items[index].flags.readOnly THEN          myContext.readOnlyNotifyProc[sw, myContext.items[index], index]        ELSE          WITH item: myContext.items[index] SELECT FROM            longNumber, number, string =>              BEGIN              pos: CARDINAL = FormSWOps.PositionInBody[                position, myContext.dijects[index].source];              myContext.insertion ¬ 	        [index, [pos, TextDisplay.noPlace, triangle, FALSE]];              ModifyInsertionState[	        myContext, change, pos];              RETURN;              END;            ENDCASE;        END;      myContext.insertion.index ¬ FormSW.nullIndex      END;    IF (myContext ¬ FormSWOps.FindContext[sw]) # NIL THEN      BEGIN      IF myContext.dijects = NIL THEN FormSW.Wakeup[sw];      LockedSetTypeIn[myContext];      END;    END;  -- Current Selection routines  ActOnSelection: PUBLIC Selection.ActOnProcType =    BEGIN    myContext: FormSWOps.PContext = data;        GetLockActOnSelection: ENTRY FormSWOps.LockContextProcType = {      UnlockedActOnSelection[myContext, action]};    IF myContext # NIL THEN      BEGIN OPEN s: myContext.selection;      IF myContext.dijects = NIL THEN FormSW.Wakeup[myContext.sw];      SELECT action FROM        delete => FormSWOps.DeleteCurrentSelection[myContext.sw];        ENDCASE => GetLockActOnSelection[myContext];      END;    END;  UnlockedActOnSelection: PUBLIC PROC[    myContext: FormSWOps.PContext, action: Selection.Action] =    BEGIN OPEN s: myContext.selection;    ENABLE UNWIND => NULL;    IF s.index # FormSW.nullIndex THEN      BEGIN      h: TextDisplay.Handle = LOOPHOLE[@myContext.dijects[s.index]];      IF action = clearIfHasInsert THEN {	OPEN mi: myContext.insertion;	select: TextData.Selection;	IF s.index = mi.index	  AND (select ¬ FormSWOps.SelectionPointer[@s, s.index]) # NIL	  AND mi.textInsert.position IN [select.left..select.right] THEN	  action ¬ clear	ELSE RETURN};      SELECT action FROM	clear =>	  BEGIN	  TextDisplay.MarkSelection[h, @s.textSelect, clear];	  s.index ¬ FormSW.nullIndex;	  END;	mark => TextDisplay.MarkSelection[h, @s.textSelect, mark];	unmark => TextDisplay.MarkSelection[h, @s.textSelect, clear];	ENDCASE;      END;    END;  DeleteOrReplace: PROC [window: Window.Handle, setTypeIn: BOOLEAN] = {    myContext: FormSWOps.PContext;    IF Selection.Convert[subwindow] # window THEN  --not in my window      Selection.ActOn[delete]    ELSE {      myContext ¬ Context.Find[FormSWOps.context, window];      IF myContext = NIL THEN GOTO Blink;      IF myContext.dijects = NIL THEN FormSW.Wakeup[myContext.sw];      FormSWOps.DeleteCurrentSelection[window];      IF setTypeIn THEN        SetTypeIn[          myContext.sw, myContext.selection.index, Inline.LowHalf[          myContext.selection.textSelect.left]]};    EXITS Blink => UserTerminal.BlinkDisplay[]};  DeleteFNR: PUBLIC PROC [window: Window.Handle] = {    DeleteOrReplace[window, FALSE]};  ReplaceFNR: PUBLIC PROC [window: Window.Handle] = {    DeleteOrReplace[window, TRUE]};  ConvertSelection: PUBLIC Selection.ConvertProcType = {    myContext: FormSWOps.PContext = data;    RETURN[ConvertStuff[      myContext, target, myContext.selection.textSelect.left,      myContext.selection.textSelect.right, myContext.selection.index]];    };      ModifyInsertionState: PUBLIC PROC [    context: FormSWOps.PContext, op: FormSWOps.InOp, pos:TextSource.Position] ={    SELECT op FROM      append => {        IF context.setOnNext THEN {	  Selection.SetInsertion[	    pointer: context, conversion: ConvertInsertion, 	    clear: ClearInsertion];	  context.setOnNext ¬ FALSE;	  context.curIndex ¬ context.insertion.index;	  context.startPos ¬ pos;	  context.endPos ¬ TextSource.nullPosition};        context.curPos ¬ pos};      change => {        context.setOnNext ¬ TRUE;        IF context.endPos = TextSource.nullPosition THEN          context.endPos ¬ context.curPos;        context.curPos ¬ pos};      clear => Selection.SetInsertion[        pointer: NIL, conversion: ConvertInsertion, clear: ClearInsertion];      ENDCASE => {        IF context.insertion.textInsert.position = pos THEN RETURN;	ModifyInsertionState[context,	  (IF pos >= context.startPos THEN 	  append ELSE change), pos]};    };      ConvertInsertion: PUBLIC Selection.ConvertProcType = {    myContext: FormSWOps.PContext = data;    RETURN[ConvertStuff[      myContext, target, myContext.startPos,myContext.endPos,       myContext.curIndex]];    };      ClearInsertion: PROC [context: FormSWOps.PContext] = {    IF context # NIL THEN {      context.startPos ¬ TextSource.nullPosition;      context.endPos ¬ TextSource.nullPosition;      };    };  ConvertStuff: PROC [myContext:FormSWOps.PContext, target:Selection.Target,    left,right: TextSource.Position, index:CARDINAL]     RETURNS [LONG POINTER] =    BEGIN    p: LONG POINTER ¬ NIL;    LockedConvertStuff: ENTRY FormSWOps.LockContextProcType =       BEGIN       ENABLE UNWIND => NULL;      SELECT target FROM        window => p ¬ ToolWindow.WindowForSubwindow[myContext.sw];        subwindow => p ¬ myContext.sw;        length =>          BEGIN           dummy: LONG POINTER TO LONG CARDINAL ¬ z.NEW[            LONG CARDINAL];          dummy­ ¬            IF index = FormSW.nullIndex THEN 0            ELSE right - left;          p ¬ dummy;          END;        source =>          BEGIN           IF index # FormSW.nullIndex THEN            SELECT myContext.items[index].type FROM              longNumber, number, string =>                IF right > left THEN                  BEGIN                  dummy: StuffSource ¬ z.NEW[                    StuffSourceObject];                  source: Selection.Source ¬ 		    z.NEW[Selection.SourceObject];                  dummy­ ¬ [                    position: left, length: right - left, context: myContext,                    textSource: 		      myContext.dijects[index].source];                  source­ ¬ [dummy, ContinueConversion, DestroyStuffSource];                  p ¬ source;                  END;              ENDCASE;          END;        string =>          BEGIN           IF index # FormSW.nullIndex THEN            SELECT myContext.items[index].type FROM              longNumber, number, string =>                BEGIN                 stringLength: INTEGER ¬ Inline.LowHalf[right - left];                IF stringLength IN (0..Selection.maxStringLength] THEN                  BEGIN                  string: LONG STRING ¬ String.MakeString[		    z, stringLength];                  TextSource.AsciiAppend[                    myContext.dijects[index].source, 		    string,left, CARDINAL[stringLength]];                  p ¬ string;                  END;                END;              ENDCASE;          END;        ENDCASE;      END;    IF left # FormSW.nullIndex AND right # FormSW.nullIndex AND      myContext # NIL THEN      BEGIN      IF myContext.dijects = NIL THEN FormSW.Wakeup[myContext.sw];      LockedConvertStuff[myContext];      END;    RETURN[p];    END;  ContinueConversion: Selection.SourceProc =    -- Guarantees to give caller as many characters as it requested    --   (unless source terminates early)    BEGIN    mySource: StuffSource = data;    LockedContinueConversion: ENTRY FormSWOps.LockContextProcType =       BEGIN       ENABLE UNWIND => NULL;      charsToRead: CARDINAL ¬          MIN[string.maxlength, Inline.LowHalf[mySource.length]];      string.length ¬ 0;      IF charsToRead > 0 THEN        BEGIN        TextSource.AsciiAppend[          mySource.textSource, string, mySource.position, charsToRead];        mySource.position ¬ mySource.position + string.length;        mySource.length ¬ mySource.length - string.length;        END;      END;    IF mySource # NIL THEN LockedContinueConversion[mySource.context];    END;  DestroyStuffSource: Selection.DestroyProc =    BEGIN    myData : StuffSource;    IF source = NIL THEN RETURN;    myData ¬ source.data;    IF myData # NIL THEN {      z.FREE[@myData]};    z.FREE[@source];    END;            -- Miscellaneous utilities  BitY: PUBLIC PROCEDURE [y: INTEGER] RETURNS [INTEGER] =    BEGIN    RETURN[      SELECT y FROM  -- order of arms is vital        >= 0 => y,        <= FormSW.line0 => (FormSW.line0 - y)*LineHeight[],        ENDCASE => ERROR FormSW.Error[other]];    END;  FastMinHeight: PROCEDURE [    items: FormSW.ItemDescriptor, type: FormSW.Type, first, last: CARDINAL]    RETURNS [min: CARDINAL] =    -- Do not call with first or last = FormSW.nullIndex!    BEGIN    lineHeight: CARDINAL = LineHeight[];    IF type = fixed THEN      BEGIN      firstY: INTEGER = PositiveY[        FormSW.sameLine, items[first].place.y, lineHeight];      min ¬ 0;      FOR i: CARDINAL IN [first..last] DO        IF items[i].flags.invisible THEN LOOP;        SELECT items[i].place.y FROM          FormSW.sameLine => NULL;          FormSW.nextLine => min ¬ min + lineHeight;          ENDCASE => min ¬ BitY[items[i].place.y] - firstY + lineHeight;        ENDLOOP;      END    ELSE min ¬ LENGTH[items]*lineHeight;    END;  PositiveY: PUBLIC PROCEDURE [previous, current: INTEGER, lineHeight: CARDINAL]    RETURNS [newY: INTEGER] =    -- previous must be non-negative unless current is FormSW.nextLine.    BEGIN    RETURN[      SELECT current FROM        FormSW.sameLine => previous,        FormSW.nextLine => IF previous < 0 THEN 0 ELSE previous + lineHeight,        <= FormSW.line0 => (FormSW.line0 - current)*lineHeight,        >= 0 => current,        ENDCASE => ERROR FormSW.Error[other]];    END;  VisibleEndpoints: PUBLIC PROCEDURE [items: FormSW.ItemDescriptor]    RETURNS [first, last: CARDINAL] =    BEGIN    first ¬ last ¬ FormSW.nullIndex;    FOR i: CARDINAL IN [0..LENGTH[items]) DO      IF items[i].flags.invisible THEN LOOP;      IF first = FormSW.nullIndex THEN first ¬ i;      last ¬ i;      ENDLOOP;    END;  -- Single item display  DisplayItem: PUBLIC PROCEDURE [sw: Window.Handle, index: CARDINAL] =    BEGIN     LockedDisplayItem: ENTRY FormSWOps.LockContextProcType =       BEGIN OPEN mdi: myContext.dijects[index];      ENABLE UNWIND => NULL;      select: TextData.Selection;      dummySelect: TextData.SelectionObject;      itemLength: CARDINAL;      IF myContext.dijects = NIL OR index > LENGTH[myContext.items]        OR myContext.items[index].flags.invisible THEN RETURN;      FormSWOps.RealActOnCaret[myContext, clear];      Display.White[sw, mdi.box];      FormSWOps.ClearCachedInfo[mdi.source];      WITH item: myContext.items[index] SELECT FROM        longNumber =>          ReplaceLongNumberString[            item.string, item.signed, item.notNegative, 	    item.radix, item.value­ - item.bias];        number =>          ReplaceNumberString[	    item.string, item.signed, item.notNegative,	    item.radix, item.value­ - item.bias];        ENDCASE;      -- Get a valid selection for this item      WITH item: myContext.items[index] SELECT FROM        boolean  => select ¬ NIL;        ENDCASE  =>	  select ¬ FormSWOps.DijectSelection[myContext, index, @dummySelect];      itemLength ¬ Inline.LowHalf[mdi.source.getLength[mdi.source]];      IF select # NIL AND index = myContext.selection.index THEN        FormSWOps.ForceValidSelection[@myContext.selection, itemLength];      -- Client may have changed backing value causing box change      TextDisplay.Display[        LOOPHOLE[@mdi], select, FALSE, FALSE !        TextDisplay.RequestNewBoxHeight =>          RESUME [NewBoxHeightRequested[myContext, index, delta]]];      IF myContext.options.boldTags THEN        TextDisplay.Bold[          LOOPHOLE[@mdi], 0, FormSWOps.TagLength[mdi.source, TRUE], select];      IF myContext.items[index].flags.drawBox THEN        ToolWindow.DrawRectangle[sw, mdi.box, 1];      -- Fix up possible insertion      WITH item: myContext.items[index] SELECT FROM        boolean => IF item.switch­ THEN FormSWOps.InvertItem[myContext, index];        ENDCASE;      IF myContext.insertion.index = index THEN        BEGIN OPEN mit: myContext.insertion.textInsert;        mit.position ¬ itemLength;        mit.place ¬ TextDisplay.noPlace;        END;      END;    IF sw # NIL THEN      BEGIN      myContext: FormSWOps.PContext = FormSWOps.FindContext[sw];      IF myContext # NIL THEN LockedDisplayItem[myContext];      Window.Validate[sw];      END;    END;  NewBoxHeightRequested: PUBLIC PROCEDURE [    myContext: FormSWOps.PContext, index: CARDINAL, delta: INTEGER]    RETURNS [INTEGER] =    BEGIN    FormSWOps.OverUnderflowSlide[myContext, index, delta];    RETURN[CARDINAL[myContext.dijects[index].box.dims.h + delta]];    END;  ReplaceLongNumberString: PUBLIC PROCEDURE [    s: LONG STRING, signed: BOOLEAN, notNegative: BOOLEAN,    radix: FormSW.Radix, value: LONG UNSPECIFIED] = {    card: LONG CARDINAL ¬ value;    int:  LONG INTEGER ¬ value;    s.length ¬ 0;    IF radix = octal THEN {      String.AppendLongNumber[s, value, 8];      String.AppendChar[s, 'B]}    ELSE       IF ~signed THEN String.AppendLongNumber[s, card, 10]      ELSE {        IF notNegative THEN int ¬ IF int < 0 THEN LAST[LONG INTEGER] ELSE int;	String.AppendLongDecimal[s, int]};    };  ReplaceNumberString: PUBLIC PROCEDURE [    s: LONG STRING, signed: BOOLEAN, notNegative: BOOLEAN,    radix: FormSW.Radix, value: UNSPECIFIED] = {    card: CARDINAL ¬ value;    int:  INTEGER ¬ value;    s.length ¬ 0;    IF radix = octal THEN {      String.AppendNumber[s, value, 8];      String.AppendChar[s, 'B]}    ELSE       IF ~signed THEN String.AppendNumber[s, card, 10]      ELSE {        IF notNegative THEN int ¬ IF int < 0 THEN INTEGER.LAST ELSE int;	String.AppendDecimal[s, int]};    };    Again: PUBLIC PROC [window: Window.Handle] = {ConvertSwap[window,    Selection.ConvertInsertion, FormSWOps.ReplaceSelection, FALSE]};  Copy: PUBLIC PROC [window: Window.Handle] = {ConvertSwap[window,    Selection.Convert, FormSWOps.StuffString, FALSE]};  Move: PUBLIC PROC [window: Window.Handle] = {ConvertSwap[window,    Selection.ConvertTrashBin, FormSWOps.StuffString, FALSE]};  Undo: PUBLIC PROC [window: Window.Handle] = {ConvertSwap[window,    Selection.ConvertTrashBin, FormSWOps.ReplaceSelection, TRUE]};        ConvertSwap: PUBLIC PROCEDURE [    window: Window.Handle, Convert: FormSWOps.ConvertProcType,    Modify: FormSWOps.ModifyProcType, keepTrash: BOOLEAN ¬ FALSE] =    BEGIN    trashSource: Selection.Source;    trash: LONG STRING;    IF window # Selection.Convert[subwindow] THEN {      UserTerminal.BlinkDisplay[]; RETURN};    IF (trashSource ¬ Convert[source]) = NIL THEN GOTO noStuff;    trash ¬ AccumulateSource[trashSource];    IF trash = NIL THEN GOTO noStuff;    IF trash.length > 2000 THEN UserTerminal.BlinkDisplay[]    ELSE      Modify[window, trash, keepTrash ! UNWIND => z.FREE[@trash]];    z.FREE[@trash];    EXITS noStuff => Modify[window, NIL, keepTrash];    END;    AccumulateSource: PROCEDURE [source: Selection.Source]    RETURNS [string: LONG STRING] =    BEGIN    -- Invalidates source    temp: STRING ¬ [100];    string ¬ NIL;    DO      source.proc[source.data, temp];      IF temp.length = 0 THEN EXIT;      String.AppendStringAndGrow[@string, temp, z];      IF string.length > 2000 THEN EXIT;      ENDLOOP;    source.destroy[source];    END;  END.  -- of FormSWsD.mesa
-- File: TextSourcesB.mesa - last edit:-- Riggle.PA           21-Jul-86 11:35:50-- Copyright (C) 1986 by Xerox Corporation. All rights reserved.-- PXK    ,	10-Dec-81 16:27:32-- SXW   ,	21-Jul-81 23:43:30-- JGS,		21-Aug-81 16:33:36-- Mark,	12-Mar-81 22:23:45-- BXM  ,	16-Jul-81 16:54:13-- SXS   ,	 8-Oct-82 11:57:41-- BGY     ,	20-Sep-82 17:04:17-- AXD    ,	 8-Oct-82 16:57:42-- DWR    	  1-Apr-85 11:17:27-- String stuff in hereDIRECTORY  Ascii USING [CR],  Environment USING [Block],  Heap: TYPE USING [systemZone],  Inline USING [HighHalf, LowHalf],  Selection USING [maxStringLength, SetTrashBin, Source, SourceObject, Target],  String USING [    AppendChar, AppendSubString, CopyToNewString, EmptyString, ExpandString,    FreeString, Length, MakeString, SubString, SubStringDescriptor, StringBoundsFault],  StringSource: TYPE,  TextSource USING [    Action, ActOnProc, AsciiTestClass, cannotExpand, Class, Direction,    DoEditActionProc, EditAction, Error, Handle, Position, Procedures,    ProceduresObject, ScanType],  TextSourceExtra: TYPE,  UserInput USING [UserAbort];TextSourcesB: PROGRAM  IMPORTS Heap, Inline, Selection, String, TextSource, UserInput  EXPORTS StringSource, TextSource, TextSourceExtra =  BEGIN OPEN TextSource;  -- String Sources  SS: TYPE = LONG POINTER TO SSObject;  SSObject: TYPE = RECORD [    procs: Procedures,    ps: LONG POINTER TO LONG STRING,    expandable: BOOLEAN,    ss: String.SubStringDescriptor];  stringProcs: ProceduresObject ¬ [    actOn: ActOnString, doEditAction: AsciiDoEditAction,    getLength: GetStringLength, readText: ReadStringText,    replaceText: ReplaceStringText, scanText: AsciiScanText,    setLength: SetStringLength];  ActOnString: PUBLIC ActOnProc =    BEGIN OPEN LOOPHOLE[source, SS];    IF source = NIL THEN RETURN;    SELECT action FROM      destroy =>        BEGIN        IF ps # NIL AND ps­ # NIL THEN          IF expandable THEN Heap.systemZone.FREE[ps] ELSE ps.length ¬ 0;        Heap.systemZone.FREE[@source];        END;      sleep, truncate => ShrinkString[ps, expandable];      wakeup => NULL;      ENDCASE => ERROR;    END;  ShrinkString: PROCEDURE [ps: LONG POINTER TO LONG STRING, expandable: BOOLEAN] =    BEGIN    IF ps # NIL AND ps­ # NIL AND expandable AND ps.maxlength > 50      AND ps.length*2 < ps.maxlength THEN      BEGIN  -- replace the string with a smaller one      temp: LONG STRING ¬ String.CopyToNewString[ps­, Heap.systemZone];      Heap.systemZone.FREE[ps];      ps­ ¬ temp;      END;    END;  Create: PUBLIC PROCEDURE [ps: LONG POINTER TO LONG STRING, expandable: BOOLEAN]    RETURNS [source: Handle] =    BEGIN    p: SS;    IF ps = NIL THEN ERROR TextSource.Error[invalidParameters];    p ¬ Heap.systemZone.NEW[      SSObject ¬ [      procs: @stringProcs, ps: ps, expandable: expandable,      ss: [base: ps­, offset: 0, length: 0]]];    RETURN[LOOPHOLE[p, Handle]];    END;  GetStringLength: PROCEDURE [source: Handle] RETURNS [Position] =    BEGIN OPEN LOOPHOLE[source, SS]; RETURN[String.Length[ps­]]; END;  ReadStringText: PROCEDURE [    source: Handle, position: Position, maxLength: CARDINAL, class: Class]    RETURNS [block: Environment.Block, next: Position] =    BEGIN OPEN LOOPHOLE[source, SS];    strLength: CARDINAL = String.Length[ps­];    i: CARDINAL = MIN[Inline.LowHalf[position], strLength];    charsToRead: CARDINAL = MIN[maxLength, strLength];    IF Inline.HighHalf[position] # 0 OR position >= strLength THEN      RETURN[[NIL, 0, 0], position];    block ¬ [LOOPHOLE[@ps­.text], i, MIN[i + charsToRead, strLength]];    IF class # none THEN      BEGIN      THROUGH [block.startIndex..block.stopIndexPlusOne) DO        IF AsciiTestClass[ps[i], class] THEN          BEGIN block.stopIndexPlusOne ¬ i + 1; EXIT; END;        ENDLOOP;      END;    RETURN[block, block.stopIndexPlusOne];    END;  ReplaceStringText: PROCEDURE [    source: Handle, block: Environment.Block, from, to: Position,    deleteToTrashbin: BOOLEAN] RETURNS [new: Position, delta: LONG INTEGER] =    BEGIN OPEN LOOPHOLE[source, SS];    s: LONG STRING;    pos: CARDINAL ¬ Inline.LowHalf[from];    inserted: CARDINAL ¬ block.stopIndexPlusOne - block.startIndex;    deleted: CARDINAL = Inline.LowHalf[to - from];    temp: String.SubStringDescriptor;    IF Inline.HighHalf[from] # 0 OR pos > GetStringLength[source] THEN ERROR;  -- should we allow this?    IF deleted # 0 THEN {      temp ¬ [base: ps­, offset: pos, length: deleted];      s ¬ AsciiDeleteSubString[@temp, deleteToTrashbin];      IF deleteToTrashbin THEN        Selection.SetTrashBin[s, ConvertTrash, ClearTrash]};    IF inserted # 0 THEN      AsciiInsertBlock[        ps, pos, block, IF expandable THEN 0 ELSE cannotExpand !        String.StringBoundsFault => {inserted ¬ 0; CONTINUE}];    delta ¬ INTEGER[inserted - deleted];    ShrinkString[ps, expandable];    RETURN[pos + inserted, delta];    END;  SetStringLength: PROCEDURE [source: Handle, position: Position]    RETURNS [Position] =    BEGIN OPEN LOOPHOLE[source, SS];    IF ps­ = NIL THEN RETURN[0];    IF position > ps­.maxlength THEN ERROR TextSource.Error[accessError];    ps­.length ¬ Inline.LowHalf[position];    RETURN[ps­.length];    END;  IsIt: PUBLIC PROCEDURE [source: Handle] RETURNS [BOOLEAN] = {    RETURN[source # NIL AND source­ = @stringProcs]};  Info: PUBLIC PROCEDURE [source: Handle]    RETURNS [ps: LONG POINTER TO LONG STRING, expandable: BOOLEAN] =    BEGIN OPEN p: LOOPHOLE[source, SS];    IF p.procs = @stringProcs THEN RETURN[p.ps, p.expandable]    ELSE RETURN[NIL, FALSE];    END;  -- TrashBin routines  Trash: TYPE = LONG POINTER TO TrashObject;  TrashObject: TYPE = RECORD [trash: LONG STRING, offset: CARDINAL];  ConvertTrash: PROCEDURE [data: LONG STRING, target: Selection.Target]    RETURNS [LONG POINTER] =    BEGIN OPEN Selection;    SELECT target FROM      length =>        BEGIN        p: LONG POINTER TO LONG CARDINAL ¬ Heap.systemZone.NEW[          LONG CARDINAL ¬ String.Length[data]];        RETURN[p];        END;      string =>        IF String.Length[data] > maxStringLength THEN RETURN[NIL]        ELSE RETURN String.CopyToNewString[data, Heap.systemZone];      source =>        BEGIN        d: Trash ¬ Heap.systemZone.NEW[TrashObject ¬ [trash: data, offset: 0]];        s: Source ¬ Heap.systemZone.NEW[          SourceObject ¬ [data: d, proc: ReadSource, destroy: DestroySource]];        RETURN[s];        END;      ENDCASE => RETURN[NIL];    END;  ClearTrash: PROCEDURE [data: LONG STRING] = {Heap.systemZone.FREE[@data]};  DestroySource: PROCEDURE [source: Selection.Source] =    BEGIN Heap.systemZone.FREE[@source.data]; Heap.systemZone.FREE[@source]; END;  ReadSource: PROCEDURE [data: Trash, string: LONG STRING] =    BEGIN OPEN data;    ss: String.SubStringDescriptor;    trashLength: CARDINAL = String.Length[trash];    string.length ¬ 0;    IF trashLength > offset THEN      BEGIN      ss ¬ [        base: trash, offset: offset,        length: MIN[string.maxlength, trashLength - offset]];      String.AppendSubString[string, @ss];      offset ¬ offset + string.length;      END;    END;  -- STRING editing routines (SHOULD USE BYTEBLT WHEN IT IS AVAILABLE)  AsciiInsertBlock: PUBLIC PROCEDURE [    string: LONG POINTER TO LONG STRING, position: CARDINAL,    toAdd: Environment.Block, extra: CARDINAL] =    BEGIN    added: CARDINAL = toAdd.stopIndexPlusOne - toAdd.startIndex;    array: LONG POINTER TO PACKED ARRAY OF CHARACTER =      LOOPHOLE[toAdd.blockPointer];    i: CARDINAL;    IF toAdd.blockPointer = NIL OR added = 0 THEN RETURN;    SELECT TRUE FROM      string­ = NIL =>        IF extra # cannotExpand THEN          string­ ¬ Heap.systemZone.NEW[StringBody [added + extra]]        ELSE string­ ¬ SIGNAL String.StringBoundsFault[string­];      string.length + added > string.maxlength =>        IF extra # cannotExpand THEN          String.ExpandString[string, added + extra, Heap.systemZone]        ELSE string­ ¬ SIGNAL String.StringBoundsFault[string­];      ENDCASE;    FOR i DECREASING IN [position..string.length) DO      string[i + added] ¬ string[i]; ENDLOOP;    FOR i IN [0..added) DO      string[i + position] ¬ array[i + toAdd.startIndex]; ENDLOOP;    string.length ¬ string.length + added;    END;  InsertString: PUBLIC PROC [    string: LONG POINTER TO LONG STRING, position: CARDINAL,    toAdd: String.SubString, extra: CARDINAL] = {    AsciiInsertBlock[      string, position,       [LOOPHOLE[@toAdd.base.text], toAdd.offset, toAdd.offset + toAdd.length],      extra]};      AsciiDeleteSubString, DeleteSubString: PUBLIC PROCEDURE [    ss: String.SubString, keepTrash: BOOLEAN] RETURNS [trash: LONG STRING] =    BEGIN    i: CARDINAL;    IF String.EmptyString[ss.base] OR ss.length = 0 THEN RETURN[NIL];    IF keepTrash THEN {      trash ¬ Heap.systemZone.NEW[StringBody [ss.length]];      String.AppendSubString[trash, ss]}    ELSE trash ¬ NIL;    ss.base.length ¬ ss.base.length - ss.length;    FOR i IN [ss.offset..ss.base.length) DO      ss.base[i] ¬ ss.base[i + ss.length] ENDLOOP;    END;  -- Entity and Text scanning routines  AsciiScanText: PUBLIC PROCEDURE [    source: Handle, start: Position, type: ScanType, direction: Direction]    RETURNS [position: Position] =    BEGIN    position ¬      IF direction = left THEN ScanLeft[source, start, type]      ELSE ScanRight[source, start, type];    END;  ScanLeft: PROCEDURE [source: Handle, start: Position, type: ScanType]    RETURNS [left: Position] =    BEGIN    i, delta: CARDINAL;    right: Position ¬ start;    match: BOOLEAN;    block: Environment.Block;    array: LONG POINTER TO PACKED ARRAY OF CHARACTER;--    kludge: CARDINAL = IF type = word OR type = line THEN 0 ELSE 1;    [block, ] ¬ source.readText[source, right, 1, none];    IF block.startIndex = block.stopIndexPlusOne THEN RETURN[start];    array ¬ LOOPHOLE[block.blockPointer];    IF type = word THEN match ¬ ~AsciiTestClass[array[block.startIndex], alpha];    DO      IF start = 0 THEN RETURN[0];      delta ¬ IF start < 50 THEN Inline.LowHalf[start] ELSE 50;      left ¬ start - delta;      DO        [block, right] ¬ source.readText[source, left, delta«+kludge», none];        array ¬ LOOPHOLE[block.blockPointer];        SELECT right FROM          start, source.getLength[source] => EXIT;          > start => {right ¬ start; EXIT};          ENDCASE;        delta ¬ delta - Inline.LowHalf[right - left];        left ¬ right;        ENDLOOP;      right ¬ left + (block.stopIndexPlusOne - block.startIndex)« - kludge»;      FOR i DECREASING IN [block.startIndex..block.stopIndexPlusOne) DO        char: CHARACTER = array[i];        SELECT type FROM          alpha => IF AsciiTestClass[char, alpha] THEN GOTO NoMoreBack;          invisible => IF AsciiTestClass[char, space] THEN GOTO NoMoreBack;          line => IF AsciiTestClass[char, eol] THEN GOTO NoMoreBack;          nonAlpha => IF ~AsciiTestClass[char, alpha] THEN GOTO NoMoreBack;          word =>            IF char = Ascii.CR OR match = AsciiTestClass[char, alpha] THEN              GOTO NoMoreBack;          leftMark => IF char = '« THEN GOTO NoMoreBack;          rightMark => IF char = '» THEN GOTO NoMoreBack;          ENDCASE => IF char = Ascii.CR THEN GOTO NoMoreBack;        right ¬ right - 1;        ENDLOOP;      start ¬ left;      REPEAT NoMoreBack => left ¬ right;      ENDLOOP;    END;  ScanRight: PROCEDURE [source: Handle, start: Position, type: ScanType]    RETURNS [right: Position] =    BEGIN    i: CARDINAL;    class: Class ¬ SELECT type FROM word => alpha, ENDCASE => eol;    match: BOOLEAN ¬ TRUE;    block: Environment.Block;    array: LONG POINTER TO PACKED ARRAY OF CHARACTER;    IF start >= (right ¬ source.getLength[source]) THEN RETURN;    [block, ] ¬ source.readText[source, start, 1, none];    IF block.startIndex = block.stopIndexPlusOne THEN RETURN[start];    array ¬ LOOPHOLE[block.blockPointer];    IF class = alpha THEN match ¬ ~AsciiTestClass[array[block.startIndex], alpha];    DO      right ¬ start;      [block, start] ¬ source.readText[source, right, 50, eol];      array ¬ LOOPHOLE[block.blockPointer];      IF block.startIndex = block.stopIndexPlusOne AND start = right THEN        IF start = source.getLength[source] THEN GOTO NoMoreForward ELSE ERROR;  -- for now      FOR i IN [block.startIndex..block.stopIndexPlusOne) DO        char: CHARACTER = array[i];        SELECT type FROM          alpha => IF AsciiTestClass[char, alpha] THEN GOTO NoMoreForward;          invisible => {            IF char = Ascii.CR THEN GOTO OneMoreForward;            IF AsciiTestClass[char, space] THEN GOTO NoMoreForward};          line => IF AsciiTestClass[char, eol] THEN GOTO OneMoreForward;          nonAlpha => IF ~AsciiTestClass[char, alpha] THEN GOTO NoMoreForward;          word => {            IF char = Ascii.CR AND match THEN GOTO OneMoreForward;            IF char = Ascii.CR OR match = AsciiTestClass[char, alpha] THEN              GOTO NoMoreForward};          leftMark => IF char = '« THEN GOTO NoMoreForward;          rightMark => IF char = '» THEN GOTO NoMoreForward;          ENDCASE => IF char = Ascii.CR THEN GOTO NoMoreForward;        right ¬ right + 1;        ENDLOOP;      REPEAT OneMoreForward => right ¬ right + 1; NoMoreForward => NULL;      ENDLOOP;    END;  SearchFailed: PUBLIC ERROR = CODE;  AsciiTextSearch: PUBLIC PROCEDURE [    source: Handle, string: LONG STRING, start: Position ¬ 0,    stop: Position ¬ LAST[LONG CARDINAL], ignoreCase: BOOLEAN ¬ FALSE]    RETURNS [lineStart, left: Position] = {    [lineStart, left] ¬ AsciiTextSearchExtra[source, string, start, stop, ignoreCase, right]};    «    -- searches for s using the Knuth, Morris, Pratt algorithm.    -- returns index of the start of the line containing s.    BEGIN    j: INTEGER;  -- pattern index    char, firstC: CHARACTER;    l: INTEGER = string.length;    offset: CARDINAL ¬ 0;    ff: FF;  -- failure function    oldIndex, newIndex: Position;    block: Environment.Block;    array: LONG POINTER TO PACKED ARRAY OF CHARACTER;    length: CARDINAL;    LoadBlock: PROCEDURE = INLINE      BEGIN      tempIndex: Position;      oldIndex ¬ newIndex;      DO        tempIndex ¬ newIndex;        [block, newIndex] ¬ source.readText[source, tempIndex, 200, none];        array ¬ LOOPHOLE[block.blockPointer];        IF block.startIndex # block.stopIndexPlusOne THEN EXIT;        IF newIndex = source.getLength[source] THEN ERROR SearchFailed;        ENDLOOP;      length ¬ block.stopIndexPlusOne - block.startIndex;      END;    GetChar: PROCEDURE = INLINE      BEGIN      IF block.startIndex = block.stopIndexPlusOne THEN        BEGIN        IF oldIndex > stop OR UserInput.UserAbort[NIL] THEN ERROR SearchFailed;        IF newIndex # oldIndex + length THEN          BEGIN  -- last read was short shrift          j ¬ 0;  -- discard any current partial match            offset ¬ offset + Inline.LowHalf[newIndex - oldIndex] - length;          END;        LoadBlock[];        END;      char ¬ array[block.startIndex];      IF ignoreCase THEN char ¬ ToLower[char];      block.startIndex ¬ block.startIndex + 1;      offset ¬ offset + 1;      END;    IF l = 0 THEN ERROR SearchFailed;  -- empty pattern    IF ignoreCase THEN FOR j IN [0..l) DO string[j] ¬ ToLower[string[j]]; ENDLOOP;    length ¬ block.startIndex ¬ block.stopIndexPlusOne ¬ 0;  -- force LoadBlock    lineStart ¬ oldIndex ¬ newIndex ¬ start;    ff ¬ MakeFailureFunction[string];    j ¬ 0;    firstC ¬ string[0];    BEGIN    ENABLE UNWIND => Heap.systemZone.FREE[@ff];    DO  -- Invariant: char = string[j-1]      GetChar[];      IF char = Ascii.CR THEN        BEGIN        IF (lineStart ¬ lineStart + offset) > stop THEN ERROR SearchFailed;        offset ¬ 0;        END;      -- next loop is in place of:       --   WHILE j >= 0 AND char # string[j] DO j ¬ ff[j] ENDLOOP;      DO        IF j = 0 THEN {IF char = firstC THEN EXIT; GOTO outerLoop};  -- common case        IF j > 0 AND char # string[j] THEN j ¬ ff[j] ELSE EXIT;        REPEAT outerLoop => LOOP;        ENDLOOP;      IF (j ¬ j + 1) >= l THEN EXIT;      ENDLOOP;    END;    Heap.systemZone.FREE[@ff];    IF (left ¬ lineStart + offset - l) > stop THEN ERROR SearchFailed;    RETURN    END; »  AsciiTextSearchExtra: PUBLIC PROCEDURE [    source: Handle, string: LONG STRING, start: Position ¬ 0,    stop: Position ¬ LAST[LONG CARDINAL], ignoreCase: BOOLEAN ¬ FALSE, direction: Direction ¬ right]    RETURNS [lineStart, left: Position] =    -- searches for s using the Knuth, Morris, Pratt algorithm.    -- returns index of the start of the line containing s.    -- searches from start-1 to stop if going backwards, start to stop if forwards.    « offset is the current character position in the file »    BEGIN    j: INTEGER;  -- pattern index    char, firstC: CHARACTER;    l: INTEGER = string.length;    offset: Position ¬ start;    ff: FF;  -- failure function    oldIndex, newIndex: Position;    block: Environment.Block;    array: LONG POINTER TO PACKED ARRAY OF CHARACTER;    length, nextCharInBlock, lastPlusDelta: CARDINAL;    delta: INTEGER ¬ IF direction = left THEN -1 ELSE +1;        LoadBlock: PROCEDURE = INLINE      BEGIN      tempIndex: Position;      oldIndex ¬ newIndex;      DO        tempIndex ¬ newIndex;        IF direction = left THEN {	  sizeToRead: CARDINAL ¬ IF tempIndex < 512 THEN Inline.LowHalf[tempIndex] ELSE 512;	  DO	    [block, tempIndex] ¬ source.readText[source, (newIndex - sizeToRead), sizeToRead, none];	    IF block.startIndex # block.stopIndexPlusOne AND tempIndex # newIndex THEN {«	      sizeToRead ¬ Inline.LowHalf[newIndex - tempIndex];  -- short shrift.  read the part shrifted »	      sizeToRead ¬ sizeToRead/2; -- exponential drop off better than linear as above.  sizeToRead = 1 is guaranteed to work.	      LOOP;	    };	    newIndex ¬ newIndex - sizeToRead;	    EXIT;	  ENDLOOP; 	} ELSE {          [block, newIndex] ¬ source.readText[source, tempIndex, 512, none];	};        array ¬ LOOPHOLE[block.blockPointer];        IF block.startIndex # block.stopIndexPlusOne THEN EXIT;        IF (direction = right AND newIndex = source.getLength[source]) OR (direction = left AND newIndex = 0) THEN ERROR SearchFailed;      ENDLOOP;      length ¬ block.stopIndexPlusOne - block.startIndex;      IF direction = left THEN {        nextCharInBlock ¬ block.stopIndexPlusOne-1;	lastPlusDelta ¬ block.startIndex-1;      } ELSE {        nextCharInBlock ¬ block.startIndex;	lastPlusDelta ¬ block.stopIndexPlusOne;      };    END;          GetChar: PROCEDURE = INLINE      BEGIN            ExhaustedSearch: PROCEDURE RETURNS [BOOLEAN]= INLINE {        RETURN [IF direction = left THEN oldIndex < stop ELSE oldIndex > stop]};	      IF nextCharInBlock = lastPlusDelta THEN        BEGIN        IF ExhaustedSearch[] OR UserInput.UserAbort[NIL] THEN ERROR SearchFailed;        LoadBlock[];        END;      char ¬ array[nextCharInBlock];      nextCharInBlock ¬ nextCharInBlock + delta;      offset ¬ offset + delta;      IF ignoreCase THEN char ¬ ToLower[char];      END;          ReverseString: PROCEDURE [s: LONG STRING]      RETURNS [copy: LONG STRING] = BEGIN      end: CARDINAL = s.length - 1;      copy ¬ String.MakeString[Heap.systemZone, s.length];      copy.length ¬ s.length;      FOR i: CARDINAL IN [0..end] DO        copy[i] ¬ s[end - i];      ENDLOOP;    END;          IF l = 0 THEN ERROR SearchFailed;  -- empty pattern    IF ignoreCase THEN FOR j IN [0..l) DO string[j] ¬ ToLower[string[j]]; ENDLOOP;    IF direction = left THEN string ¬ ReverseString[string]; -- funky, huh?    length ¬ nextCharInBlock ¬ lastPlusDelta ¬ 0;  -- force LoadBlock    lineStart ¬ oldIndex ¬ newIndex ¬ start;    ff ¬ MakeFailureFunction[string];    j ¬ 0;    firstC ¬ string[0];    BEGIN    ENABLE UNWIND => Heap.systemZone.FREE[@ff];    DO  -- Invariant: char = string[j-1]      GetChar[];      -- next loop is in place of:       --   WHILE j >= 0 AND char # string[j] DO j ¬ ff[j] ENDLOOP;      DO        IF j = 0 THEN {IF char = firstC THEN EXIT; GOTO outerLoop};  -- common case        IF j > 0 AND char # string[j] THEN j ¬ ff[j] ELSE EXIT;        REPEAT outerLoop => LOOP;        ENDLOOP;      IF (j ¬ j + 1) >= l THEN EXIT;      ENDLOOP;    END;    Heap.systemZone.FREE[@ff];    IF direction = left THEN String.FreeString[Heap.systemZone, string];     IF (direction = left AND (left ¬ offset) < stop) OR     (direction = right AND (left ¬ offset - l) > stop) THEN ERROR SearchFailed;    lineStart ¬ ScanLeft[source, left, line]; -- get the beginning of the line our match is on    RETURN    END;  FF: TYPE = LONG POINTER TO FFSeq;  -- failure function  FFSeq: TYPE = RECORD [SEQUENCE COMPUTED CARDINAL OF INTEGER];  MakeFailureFunction: PROCEDURE [pat: LONG STRING] RETURNS [f: FF] =    BEGIN    -- f[i] tells how far to slide pat when we find a mismatch at pat[i].    -- f[i] = -1 means slide pat all the way over past the current char.    -- compute f by sliding pat to the right against itself.    i, j: INTEGER;    l: INTEGER = pat.length;    f ¬ Heap.systemZone.NEW[FFSeq [l]];    j ¬ 0;    i ¬ f[0] ¬ -1;    WHILE j < l - 1 DO      WHILE i >= 0 AND pat[j] # pat[i] DO i ¬ f[i] ENDLOOP;      i ¬ i + 1;      j ¬ j + 1;      f[j] ¬ IF pat[j] = pat[i] THEN f[i] ELSE i;      ENDLOOP;    RETURN    END;  ToLower: PROCEDURE [ch: CHARACTER] RETURNS [CHARACTER] = INLINE {  -- test order significant.  No it isn't!    IF ch <= 'Z AND ch >= 'A THEN ch ¬ ch + ('a - 'A); RETURN[ch]};  -- Misc. utilities  AsciiAppend: PUBLIC PROCEDURE [    source: Handle, string: LONG STRING, start: TextSource.Position,    n: CARDINAL] =    BEGIN    block: Environment.Block;    array: LONG POINTER TO PACKED ARRAY OF CHARACTER;    WHILE n > 0 DO      [block, start] ¬ source.readText[source, start, n, none];      array ¬ LOOPHOLE[block.blockPointer];      IF block.startIndex = block.stopIndexPlusOne        AND start >= source.getLength[source] THEN EXIT;      FOR i: CARDINAL IN [block.startIndex..block.stopIndexPlusOne) DO        String.AppendChar[string, array[i]]; ENDLOOP;      n ¬ n - (block.stopIndexPlusOne - block.startIndex);      ENDLOOP;    END;  AsciiDoEditAction: PUBLIC DoEditActionProc =    BEGIN    block: Environment.Block;    newEditPos: Position ¬ editPos;    Backup: PROCEDURE [to, from: Position] =      BEGIN      longDelta: LONG INTEGER;      originalTo: Position = to;      IF editPos >= source.getLength[source] THEN        BEGIN to ¬ source.setLength[source, to]; longDelta ¬ -(from - to); END      ELSE        [to, longDelta] ¬ source.replaceText[          source, [NIL, 0, 0], to, from, TRUE]; -- put it in the trash bin      delta ¬ longDelta + delta;      END;    delta ¬ 0;    SELECT action FROM      backWord =>        WHILE newEditPos > 0 DO          array: LONG POINTER TO PACKED ARRAY OF CHARACTER;          [block, ] ¬ source.readText[source, newEditPos - 1, 1, none];          array ¬ LOOPHOLE[block.blockPointer];          IF TextSource.AsciiTestClass[array[block.startIndex], alpha] THEN {            Backup[ScanLeft[source, newEditPos - 1, word], newEditPos]; EXIT};          Backup[newEditPos - 1, newEditPos];  -- source may refuse to do delete          IF newEditPos = LOOPHOLE[editPos + delta, Position] THEN EXIT          ELSE newEditPos ¬ editPos + delta;          ENDLOOP;      backSpace => IF editPos > 0 THEN Backup[editPos - 1, editPos];      ENDCASE => NULL;  -- Throw away    END;  END. -- of TextSourcesBLOGDWR    	20-Feb-85 12:39:44 AsciiTextSearchExtraDWR    	 1-Apr-85 11:17:09 Tried to make LoadBlock[] fasterDWR	18-Jul-86 10:28:45 ReverseString used to modify the strin itself.  Now it works on a copy.
-- Copyright (C) 1981, 1983  by Xerox Corporation. All rights reserved. -- File: TextDisplaysE.mesa - last edit:-- PXK    	22-Oct-81 13:38:08-- SXW   	21-Jul-81 22:21:03-- Mark		 6-Feb-81  9:53:18-- JGS		20-Aug-81 13:10:55-- AXD    	 4-Nov-83 12:21:00-- DWR    	23-Feb-85 13:33:17-- contains TextDisplay-wide utilitiesDIRECTORY  Ascii USING [SP],  AsciiSink USING [Info],  Display: TYPE USING [Bitmap, Gray, Invert, White, xorFlags],  Environment: TYPE USING [Block],  ProfileExtra USING [caretShape],  TextDisplay: TYPE USING [    BoxPortion, invisiblePlace, Handle, lastPossibleChar, LineTable, Insertion,    MarkingAction, noPlace, Place, Position, Selection, SelectionMode],  TextSink: TYPE USING [BreakReason, FontInfo, Handle, Measure],  TextSource: TYPE USING [    Class, GetLength, Handle, nullPosition, Position, ReadText],  Window: TYPE USING [Box, Handle, Place],  WindowExtra: TYPE USING [SetUseBadPhosphor],  WindowFont USING [CharWidth];TextDisplaysE: PROGRAM  IMPORTS AsciiSink, Display, ProfileExtra, TextSink, TextSource, WindowExtra, WindowFont  EXPORTS TextDisplay =  BEGIN  Position: TYPE = TextSource.Position;  nullPosition: Position = TextSource.nullPosition;  invisiblePlace: Window.Place = TextDisplay.invisiblePlace;  lastPossibleChar: CARDINAL = TextDisplay.lastPossibleChar;  -- GLOBAL Data and Stuff  selectionBoxWidth: CARDINAL = 1;  selectionBoxMargin: CARDINAL = 1;  -- Utilities  CharsInLine: PUBLIC PROC [p: TextDisplay.Handle, line: CARDINAL]    RETURNS [CARDINAL] = {    lineTable: TextDisplay.LineTable = p.lineTable;    RETURN[      CARDINAL[        (IF line + 1 = lineTable.length OR lineTable[line + 1].pos = nullPosition         THEN lineTable.lastPositionPlusOne ELSE lineTable[line + 1].pos) -          lineTable[line].pos]]};  CharsToRead: PUBLIC PROC [position: Position, select: TextDisplay.Selection]    RETURNS [inSelection: BOOLEAN, n: CARDINAL] = {    IF select = NIL OR ~select.marked OR position > select.right THEN      RETURN[FALSE, lastPossibleChar];    SELECT TRUE FROM      ~select.marked, position >= select.right => RETURN[FALSE, lastPossibleChar];      position < select.left => {        temp: Position = select.left - position;        RETURN[          FALSE,	  IF temp > CARDINAL.LAST THEN lastPossibleChar ELSE CARDINAL[temp]]};      position < select.right => {        temp: Position = select.right - position;        RETURN[          TRUE,	  IF temp > CARDINAL.LAST THEN lastPossibleChar ELSE CARDINAL[temp]]};      ENDCASE => ERROR};    DrawGrayBox: PUBLIC PROC [    p: TextDisplay.Handle, leftPlace, rightPlace: Window.Place,    what: TextDisplay.BoxPortion ¬ wholeBox] = {    fontHeight: INTEGER = p.sink.FontInfo.lineHeight;    wh: Window.Handle = p.wh;    leftPlace.x ¬ leftPlace.x - selectionBoxWidth;    rightPlace.x ¬ rightPlace.x - selectionBoxWidth;    Display.Gray[      wh, [      leftPlace, [      selectionBoxWidth,      fontHeight - (IF leftPlace.x = 0 THEN 0 ELSE selectionBoxWidth)]]];    IF what = wholeBox THEN {      Display.Gray[        wh, [        [leftPlace.x + selectionBoxWidth, leftPlace.y - selectionBoxWidth], [        rightPlace.x - leftPlace.x, selectionBoxWidth]]];  -- top      Display.Gray[        wh, [        [        leftPlace.x + selectionBoxWidth,        leftPlace.y + fontHeight - selectionBoxWidth], [        rightPlace.x - leftPlace.x, selectionBoxWidth]]];  -- bottom      Display.Gray[        wh, [rightPlace, [selectionBoxWidth, fontHeight - selectionBoxWidth]]]}};  GetEndPlaces: PUBLIC PROC [p: TextDisplay.Handle, line, left, right: CARDINAL]    RETURNS [leftPlace, rightPlace: Window.Place] = {    width: CARDINAL = p.box.dims.w;    positionsToRead, positions: CARDINAL;    block: Environment.Block;    why: TextSink.BreakReason;    sink: TextSink.Handle = p.sink;    source: TextSource.Handle = p.source;    lineTable: TextDisplay.LineTable = p.lineTable;    newPos, oldPos: Position ¬ lineTable[line].pos;    leftPlace ¬ LineStartPlaceInDisplayBox[p, line];    positionsToRead ¬ left;    -- coordinates are box relative, not window relative    WHILE positionsToRead # 0 DO  -- first find left      [block, newPos] ¬ source.ReadText[oldPos, positionsToRead, eol];      [newPlace: leftPlace, positions: positions, why: why] ¬ sink.Measure[        block: @block, lineLength: width - leftPlace.x, offset: 0,        place: leftPlace];      IF why = margin THEN {leftPlace.x ¬ width; EXIT};      IF newPos = lineTable[line].pos + left        OR (newPos = oldPos AND newPos = source.GetLength) THEN EXIT;      positionsToRead ¬ positionsToRead - positions;      oldPos ¬ newPos;      ENDLOOP;    rightPlace ¬ leftPlace;    positionsToRead ¬ right - left;    oldPos ¬ newPos;    WHILE positionsToRead # 0 DO  -- now right      [block, newPos] ¬ source.ReadText[oldPos, positionsToRead, eol];      [newPlace: rightPlace, positions: positions, why: why] ¬ sink.Measure[        block: @block, lineLength: width - rightPlace.x, offset: 0,        place: rightPlace];      IF why = margin THEN {rightPlace.x ¬ width; EXIT};      IF newPos = lineTable[line].pos + right        OR (newPos = oldPos AND newPos = source.GetLength) THEN EXIT;      positionsToRead ¬ positionsToRead - positions;      oldPos ¬ newPos;      ENDLOOP;    rightPlace.x ¬ MIN[rightPlace.x, width];    RETURN[      leftPlace: ConvertToWindowRelative[p, leftPlace],      rightPlace: ConvertToWindowRelative[p, rightPlace]]};  GetEOF: PUBLIC PROC [p: TextDisplay.Handle] RETURNS [TextDisplay.Position] = {    RETURN[p.source.GetLength]};  GetPosition: PUBLIC PROC [p: TextDisplay.Handle, line: CARDINAL]    RETURNS [Position] = {RETURN[p.lineTable[line].pos]};  LastDisplayedLine: PUBLIC PROC [p: TextDisplay.Handle] RETURNS [CARDINAL] = {    RETURN[LastLine[p.lineTable]]};  LastLine: PUBLIC PROC [lt: TextDisplay.LineTable] RETURNS [CARDINAL] = {    FOR i: CARDINAL DECREASING IN [0..lt.length) DO      IF lt[i].pos # nullPosition THEN RETURN[i]; ENDLOOP;    RETURN[0]};  LineFromY: PUBLIC PROC [    p: TextDisplay.Handle, y: INTEGER] RETURNS [CARDINAL] = {    RETURN[      MIN[        (IF y - p.box.place.y > p.options.margin THEN         (y - p.box.place.y - p.options.margin)/p.sink.FontInfo.lineHeight         ELSE 0), p.lineTable.length - 1]]};  LinesInBox: PUBLIC PROC [p: TextDisplay.Handle, box: Window.Box]    RETURNS [CARDINAL] = {    fudge: CARDINAL = p.options.margin*2;    h: CARDINAL = MAX[0, box.dims.h];    RETURN[      IF h > fudge THEN MAX[1, (h - fudge)/p.sink.FontInfo.lineHeight]      ELSE 1]};  LineStartPlaceInDisplayBox: PROC [p: TextDisplay.Handle, line: CARDINAL]    RETURNS [place: Window.Place] = {    RETURN[[      p.options.margin,      p.options.margin + (p.sink.FontInfo.lineHeight*line)]]};  LineStartPlace: PUBLIC PROC [p: TextDisplay.Handle, line: CARDINAL]    RETURNS [place: Window.Place] = {    RETURN[ConvertToWindowRelative[p, LineStartPlaceInDisplayBox[p, line]]]};  ConvertToWindowRelative: PROC [p: TextDisplay.Handle, place: Window.Place]    RETURNS [Window.Place] = INLINE {    RETURN[[x: p.box.place.x + place.x, y: p.box.place.y + place.y]]};  MarkInsertion: PUBLIC PROC [    p: TextDisplay.Handle, insert: TextDisplay.Insertion,    action: TextDisplay.MarkingAction] = {    IF action = invert OR (action = clear AND insert.marked)      OR (action = mark AND ~insert.marked) THEN {      placeToMark: Window.Place;      IF insert.place = TextDisplay.noPlace THEN        insert.place ¬ WindowPlaceFromPosition[          p: p, position: insert.position, endOfLine: FALSE, visibleOnly: TRUE];      IF insert.place # invisiblePlace THEN {        oldUBP: BOOLEAN = WindowExtra.SetUseBadPhosphor[p.wh, FALSE];        IF insert.mode = triangle THEN {	  IF ProfileExtra.caretShape = triangle THEN {	    caret: ARRAY [0..4) OF CARDINAL ¬ [14000B, 36000B, 77000B, 177400B];	    placeToMark ¬ [	      insert.place.x - 3, insert.place.y + p.sink.FontInfo.lineHeight - 2];	    Display.Bitmap[	      window: p.wh, box: [placeToMark, [8, 4]], 	      address: [word: @caret, bit: 0], bitmapBitWidth: 16,	      flags: Display.xorFlags];	  } ELSE {	    bar: ARRAY [0..1) OF CARDINAL ¬ [177777B];	    bottomCaret: ARRAY [0..4) OF CARDINAL ¬ [010000B, 034000B, 076000B, 177000B];	    topCaret: ARRAY [0..4) OF CARDINAL ¬ [177000B, 076000B, 034000B, 010000B];	    height: CARDINAL ¬ p.sink.FontInfo.lineHeight - 2;	    placeToMark ¬ [insert.place.x, insert.place.y+1];	    Display.Gray[	      window: p.wh, box: [placeToMark, [1, height]], 	      gray: DESCRIPTOR[bar], dstFunc: xor];	    placeToMark ¬ [insert.place.x - 3, insert.place.y - 3];	    Display.Bitmap[	      window: p.wh, box: [placeToMark, [8, 4]], 	      address: [word: @topCaret, bit: 0], bitmapBitWidth: 16,	      flags: Display.xorFlags];	    placeToMark ¬ [insert.place.x - 3, insert.place.y + height+1];	    Display.Bitmap[	      window: p.wh, box: [placeToMark, [8, 4]], 	      address: [word: @bottomCaret, bit: 0], bitmapBitWidth: 16,	      flags: Display.xorFlags];	  };	} ELSE {	  height: CARDINAL = p.sink.FontInfo.lineHeight;	  block: ARRAY [0..2) OF CARDINAL ¬ [125252B, 052525B]; -- 50% gray	  IF ProfileExtra.caretShape = iBeam THEN	    Display.Gray[window: p.wh, box: [insert.place, [height/2, height]], gray: DESCRIPTOR[block], dstFunc: xor]   	  ELSE	    Display.Invert[p.wh, [insert.place, [WindowFont.CharWidth[Ascii.SP, AsciiSink.Info[p.sink]], height]]]; 	};	[] ¬ WindowExtra.SetUseBadPhosphor[p.wh, oldUBP]};      insert.marked ¬ ~insert.marked}};  MarkPlaceInterval: PUBLIC PROC [    p: TextDisplay.Handle, leftPlace, rightPlace: Window.Place,    mode: TextDisplay.SelectionMode, offset: INTEGER] = {    box: Window.Box ¬ [      leftPlace, [rightPlace.x - leftPlace.x, p.sink.FontInfo.lineHeight]];    SELECT mode FROM      clearText => Display.White[p.wh, box];      video => Display.Invert[p.wh, box];      underline => {        box.place.y ¬ leftPlace.y + (p.sink.FontInfo.lineHeight - 2)/2;  -- kludge for drawthrough        box.dims.h ¬ 2;        Display.Gray[p.wh, box]}; -- 50% gray      grayBox => {        gray: ARRAY [0..4) OF WORD ¬ [104210B, 0B, 21042B, 0B];        Display.Gray[p.wh, box, DESCRIPTOR[gray]]};      ENDCASE => ERROR};  PlaceFromPosition: PUBLIC PROC [    p: TextDisplay.Handle, position: Position, endOfLine: BOOLEAN]    RETURNS [place: TextDisplay.Place] = {    lineTable: TextDisplay.LineTable = p.lineTable;    lastOK: CARDINAL ¬ 0;    IF lineTable.length # 1 THEN {      position ¬ MAX[        lineTable[0].pos, MIN[position, lineTable.lastPositionPlusOne]];      FOR i: CARDINAL IN [0..lineTable.length) DO        SELECT lineTable[i].pos FROM          nullPosition => NULL;          > position => EXIT;          = position => {IF ~endOfLine THEN lastOK ¬ i; EXIT};          ENDCASE => lastOK ¬ i;        ENDLOOP;      FOR i: CARDINAL DECREASING IN (0..lastOK] DO        IF lineTable[i - 1].pos = lineTable[i].pos THEN lastOK ¬ lastOK - 1        ELSE EXIT;        ENDLOOP};    RETURN[[lastOK, CARDINAL[position - lineTable[lastOK].pos]]]};  PositionFromPlace: PUBLIC PROC [p: TextDisplay.Handle, place: TextDisplay.Place]    RETURNS [position: Position] = {    IF place.line >= p.lineTable.length THEN RETURN[TextSource.nullPosition]    ELSE RETURN[p.lineTable[place.line].pos + place.position]};      PositionIsVisible: PUBLIC PROC [p: TextDisplay.Handle, position: Position]    RETURNS [BOOLEAN] = {    lineTable: TextDisplay.LineTable = p.lineTable;    RETURN[      (position >= lineTable[0].pos        AND          (position < lineTable.lastPositionPlusOne            OR lineTable[lineTable.length - 1].pos >= position            OR              (position = lineTable.lastPositionPlusOne                AND ~lineTable.crIsLast)))]};  TextLines: PUBLIC PROC [p: TextDisplay.Handle] RETURNS [CARDINAL] = {    RETURN[p.lineTable.length]};  WindowPlaceFromPosition: PUBLIC PROC [    p: TextDisplay.Handle, position: Position, endOfLine, visibleOnly: BOOLEAN]    RETURNS [place: Window.Place] = {    width: CARDINAL = p.box.dims.w;    block: Environment.Block;    positionsToRead, positions: CARDINAL;    next: Position;    linePlace: TextDisplay.Place = PlaceFromPosition[p, position, endOfLine];    sink: TextSink.Handle = p.sink;    source: TextSource.Handle = p.source;    lineTable: TextDisplay.LineTable = p.lineTable;    IF visibleOnly AND ~PositionIsVisible[p, position] THEN      RETURN[invisiblePlace];    place ¬ LineStartPlaceInDisplayBox[p, linePlace.line];    position ¬ lineTable[linePlace.line].pos;    positionsToRead ¬ linePlace.position;    DO      [block, next] ¬ source.ReadText[position, positionsToRead, eol];      [place, positions, ] ¬ sink.Measure[        block: @block, lineLength: width - place.x, offset: 0, place: place];      IF positions = positionsToRead OR position = source.GetLength THEN        EXIT;      IF visibleOnly AND place.x > INTEGER[width] THEN RETURN[invisiblePlace];      position ¬ next;      positionsToRead ¬ positionsToRead - positions;      ENDLOOP;    RETURN[ConvertToWindowRelative[p, place]]};  END.LOGDWR    	26-Nov-84 16:23:25  Made the caret for TTY windows the width of a space, instead of 4 bits alwaysDWR    	27-Nov-84  9:55:13 Experimented with different caretsDWR    	28-Nov-84 11:52:05 Experimented with some more caretsDWR    	30-Nov-84 15:57:05 Experimented with more caretsDWR    	18-Feb-85 10:13:29 Made it user choosable
-- Copyright (C) 1981, 1982, 1983  by Xerox Corporation. All rights reserved. -- File: TextDisplaysD.mesa - last edited:-- PXK    ,	27-Oct-81  9:26:49-- SXW   ,	 9-Jul-81 22:52:20-- JGS,		20-Aug-81 16:24:33-- Mark,	 2-Mar-81  8:54:04-- SEH,  	16-Dec-81 16:08:00-- AXD    ,  	17-Nov-82 14:38:37-- BGY     ,  	24-Feb-83 18:49:53-- DWR    	28-Feb-85 10:40:13-- contains Display, Scrolling and most used stuffDIRECTORY  BitBlt: TYPE USING [BitBltFlags, DstFunc, SrcFunc],  Display: TYPE USING [textFlags, White],  Environment USING [Block],  Inline USING [LowHalf],  String USING [SubString],  TextDisplay USING [    CharsToRead, CheckBoxHeight, Display, DisplayAction, Handle,     Insertion, LastLine, LineStartPlace,    LineTable, MarkPlaceInterval, MoveLines, noPlace, Place, PlaceFromPosition,    PositionIsVisible, Selection],  TextDisplayExtra USING [SetPositionWithOverRide],  TextSink USING [BreakReason, Display, Handle, Measure, Positions],  TextSource USING [EditAction, Handle, nullPosition, Position],  Window USING [Box, Handle, Place];TextDisplaysD: PROGRAM  IMPORTS Display, Inline, TextDisplay, TextDisplayExtra, TextSink EXPORTS TextDisplay =  BEGIN  -- Definitions  Position: TYPE = TextSource.Position;  nullPosition: Position = TextSource.nullPosition;  noPlace: Window.Place = TextDisplay.noPlace;  longLine: INTEGER = 2000;  -- Interface Procedures  DisplayOneLine: PUBLIC PROCEDURE [    p: TextDisplay.Handle, textPlace: TextDisplay.Place,    select: TextDisplay.Selection, action: TextDisplay.DisplayAction]    RETURNS [position: Position, crOnEnd: BOOLEAN] =    BEGIN    -- assumes line table entry is valid    rightX: CARDINAL;    width: INTEGER;    block: Environment.Block;    place: Window.Place;    inSelect: BOOLEAN;    next: Position ¬ position;    charsToRead, positions: CARDINAL;    break: TextSink.BreakReason;    sink: TextSink.Handle = p.sink;    source: TextSource.Handle = p.source;    crOnEnd ¬ FALSE;    position ¬ p.lineTable[textPlace.line].pos;    place ¬ p.LineStartPlace[textPlace.line];    rightX ¬ p.box.place.x + p.box.dims.w - p.options.margin;    IF place.y + INTEGER[sink.fontInfo[sink].lineHeight] <= p.box.place.y      OR place.y >= p.box.place.y + p.box.dims.h THEN action ¬ measure;    IF textPlace.position # 0 THEN {      positionsToSkip: INTEGER ¬ textPlace.position;      DO        [inSelect, charsToRead] ¬ TextDisplay.CharsToRead[position, select];        [block, next] ¬ source.readText[          source, position, MIN[charsToRead, positionsToSkip], none];        [place, positions, break] ¬ sink.Measure[          block: @block, lineLength: longLine, offset: p.box.place.x,          place: place];        IF break = eol THEN RETURN[position + positions, TRUE];        IF (positionsToSkip ¬ positionsToSkip - positions) <= 0          OR position >= source.getLength[source] THEN {          position ¬ position + positions; EXIT};        position ¬ next;        ENDLOOP};    [inSelect, charsToRead] ¬ TextDisplay.CharsToRead[position, select];    [block, next] ¬ source.readText[      source, position, MIN[charsToRead, 200], none];    IF sink.Positions[@block] > 0 THEN      BEGIN      breakReason: TextSink.BreakReason;      nDisplayed: CARDINAL;      DO        IF (width ¬ rightX - place.x) > 0 THEN          BEGIN          IF action = measure THEN            [place, nDisplayed, breakReason] ¬ sink.Measure[              block: @block, lineLength: width, offset: p.box.place.x,              place: place]          ELSE            BEGIN            startPlace: Window.Place ¬ place;            flags: BitBlt.BitBltFlags ¬ Display.textFlags;            IF action # paint OR inSelect THEN flags.dstFunc ¬ null;            IF select # NIL AND inSelect AND select.mode = video THEN              flags.srcFunc ¬ complement;            [place, nDisplayed, breakReason] ¬ sink.Display[              block: @block, lineLength: width, offset: p.box.place.x,              window: p.wh, place: startPlace, flags: flags];            IF select # NIL AND inSelect AND select.mode # video THEN              p.MarkPlaceInterval[startPlace, place, select.mode, 0];            END;          END        ELSE BEGIN nDisplayed ¬ 0; breakReason ¬ margin; END;        -- You can get here by hitting a break and going around the loop without        -- having displayed something        position ¬ position + nDisplayed;        SELECT breakReason FROM          eol => GOTO SeenCR;          consumed => IF position = source.getLength[source] THEN EXIT;          margin =>            SELECT p.options.rightBreak FROM              none => {                position ¬ source.scanText[source, position, line, right];                GOTO SeenCR};              text => EXIT;              word => {  -- back up to previous white space (even mutiple blocks!)                rightPos: LONG CARDINAL = position;                temp: LONG CARDINAL;                length: CARDINAL ¬ 0;                position ¬ source.scanText[source, position, invisible, left];                IF position <= p.lineTable[textPlace.line].pos THEN {                  position ¬ rightPos; EXIT};                -- hack for now! assumes block contains all chars to be checked                temp ¬ position;                DO                  [block, temp] ¬ source.readText[                    source, temp, Inline.LowHalf[rightPos - temp], none];                  length ¬                    length + sink.Measure[                      block: @block, lineLength: LAST[INTEGER],                      offset: p.box.place.x, place: [0, 0]].newPlace.x;                  IF temp = rightPos THEN EXIT;                  ENDLOOP;                place.x ¬ place.x - length;                IF action # measure THEN                  Display.White[                    p.wh, [place, [length, sink.fontInfo[sink].lineHeight]]];                EXIT};              ENDCASE => ERROR;          ENDCASE => ERROR;        IF sink.Positions[@block] = 0 THEN          IF position < source.getLength[source] THEN {            [inSelect, charsToRead] ¬ TextDisplay.CharsToRead[position, select];            [block, next] ¬ source.readText[              source, position, MIN[charsToRead, 200], none]}          ELSE EXIT;        REPEAT SeenCR => crOnEnd ¬ TRUE;        ENDLOOP;      END;    IF action = replaceAndClear THEN  -- clear end of line      Display.White[        p.wh, [        place, [        p.box.place.x + p.box.dims.w - place.x - p.options.margin, sink.fontInfo[        sink].lineHeight]]];    RETURN[position, crOnEnd]    END;  DoEditAction: PUBLIC PROCEDURE [    p: TextDisplay.Handle, select: TextDisplay.Selection,    insert: TextDisplay.Insertion, action: TextSource.EditAction]    RETURNS [from, to: Position, delta: LONG INTEGER] = {    backup: BOOLEAN;    lastLine: CARDINAL ¬ p.lineTable.LastLine[];    delta ¬ p.source.doEditAction[p.source, action, insert.position];    from ¬ insert.position + delta;    to ¬ insert.position;    backup ¬ from < p.lineTable[0].pos AND to > p.lineTable[0].pos;    UpdateLineTable[LOOPHOLE[p], from, delta];    FixSelection[p.source, select, from, delta];    IF backup THEN {      from ¬ p.source.scanText[p.source, from, line, left];      p.lineTable[0].pos ¬ from};    Update[p, from, to, select, TRUE];    insert.place ¬ noPlace;    insert.position ¬ insert.position + delta;    IF p.options.bottomAction = signal AND      lastLine # p.lineTable.LastLine[] THEN p.CheckBoxHeight[select];    };  DeleteText: PUBLIC PROCEDURE [    p: TextDisplay.Handle, pos: Position, count: LONG CARDINAL,    select: TextDisplay.Selection, insert: TextDisplay.Insertion,    keepTrash: BOOLEAN ¬ FALSE] RETURNS [done: BOOLEAN, firstBad: Position] =    BEGIN    realPos: Position;    realN: LONG CARDINAL;    delta: LONG INTEGER;    backup: BOOLEAN;    source: TextSource.Handle = p.source;    [realPos, delta] ¬ source.replaceText[      source, [NIL, 0, 0], pos, pos + count, keepTrash];    realN ¬ -delta;    firstBad ¬ IF realPos = 0 THEN 0 ELSE realPos - 1;    IF realN = 0 THEN RETURN[FALSE, firstBad];    -- Fix up insert.position    IF realPos < insert.position THEN      insert.position ¬        (IF insert.position - realPos < realN THEN realPos         ELSE insert.position - realN);    backup ¬ realPos < p.lineTable[0].pos      AND realPos + realN > p.lineTable[0].pos;    UpdateLineTable[p, realPos, delta];    FixSelection[source, select, realPos, delta];    insert.place ¬ noPlace;    Update[p, firstBad, realPos, select, TRUE, TRUE];    IF backup AND p.lineTable[0].pos # 0 THEN      BEGIN      left: Position ¬ source.scanText[source, pos, line, left];      IF left # p.lineTable[0].pos THEN        BEGIN p.lineTable[0].pos ¬ left; Update[p, left, pos, select, TRUE]; END;      END;    -- Always call TakeBottomAction instead if it ever gets smart about deletion    IF p.options.bottomAction = signal THEN p.CheckBoxHeight[select];    RETURN[TRUE, firstBad];    END;  InsertCharacter: PUBLIC PROCEDURE [    p: TextDisplay.Handle, char: CHARACTER, select: TextDisplay.Selection,    insert: TextDisplay.Insertion] RETURNS [firstBad: Position] =    BEGIN    chars: PACKED ARRAY [0..2) OF CHARACTER;    block: Environment.Block ¬ [      blockPointer: LOOPHOLE[LONG[@chars]], startIndex: 0, stopIndexPlusOne: 1];    chars[0] ¬ char;    RETURN[InsertBlock[p, block, select, insert]];    END;  InsertSubString: PUBLIC PROCEDURE [    p: TextDisplay.Handle, ss: String.SubString, select: TextDisplay.Selection,    insert: TextDisplay.Insertion] RETURNS [firstBad: Position] =    BEGIN    block: Environment.Block ¬ [      blockPointer: LOOPHOLE[@ss.base.text], startIndex: ss.offset,      stopIndexPlusOne: ss.offset + ss.length];    RETURN[InsertBlock[p, block, select, insert]];    END;  InsertBlock: PUBLIC PROCEDURE [    p: TextDisplay.Handle, block: Environment.Block,    select: TextDisplay.Selection, insert: TextDisplay.Insertion]    RETURNS [firstBad: Position] =    BEGIN    delta: LONG INTEGER;    source: TextSource.Handle = p.source;    wasVisible: BOOLEAN = p.PositionIsVisible[insert.position];    firstBad ¬ insert.position;    IF block.blockPointer = NIL OR p.sink.Positions[@block] = 0 THEN RETURN;    [insert.position, delta] ¬ source.replaceText[      source, block, insert.position, insert.position];    IF delta # 0 THEN UpdateLineTable[p, firstBad, delta];    FixSelection[source, select, firstBad, delta];    Update[      p: p, from: firstBad, to: insert.position, select: select,      clear: insert.position # source.getLength[source], charsDeleted: FALSE];    insert.place ¬ noPlace;    TakeBottomAction[p, wasVisible, select, insert];    END;  ReplaceBlock: PUBLIC PROCEDURE [    p: TextDisplay.Handle, block: Environment.Block, pos: Position,    count: LONG CARDINAL, select: TextDisplay.Selection,    insert: TextDisplay.Insertion, keepTrash: BOOLEAN ¬ FALSE]    RETURNS [done: BOOLEAN, firstBad: Position] =    BEGIN    endPos: Position;    realN: LONG CARDINAL;    backup: BOOLEAN;    delta: LONG INTEGER;    source: TextSource.Handle = p.source;    wasVisible: BOOLEAN = p.PositionIsVisible[insert.position];    [endPos, delta] ¬ source.replaceText[      source, block, pos, pos + count, keepTrash];    firstBad ¬ pos;    realN ¬ endPos - firstBad;    insert.position ¬ endPos;     backup ¬  (firstBad < p.lineTable[0].pos)      AND (firstBad + realN > p.lineTable[0].pos);    IF delta # 0 THEN UpdateLineTable[p, firstBad, delta];    FixSelection[source, select, firstBad, delta];    insert.place ¬ noPlace;    Update[      p: p, from: firstBad, to: insert.position, select: select,      clear: insert.position # source.getLength[source], charsDeleted: count # 0];    IF backup AND p.lineTable[0].pos # 0 THEN      BEGIN      left: Position ¬ source.scanText[source, pos, line, left];      IF left # p.lineTable[0].pos THEN        BEGIN p.lineTable[0].pos ¬ left; Update[p, left, pos, select, TRUE]; END;      END;    TakeBottomAction[p, wasVisible, select, insert];    RETURN[TRUE, firstBad];    END;  TakeBottomAction: PUBLIC PROCEDURE [    p: TextDisplay.Handle, wasVisible: BOOLEAN, select: TextDisplay.Selection,    insert: TextDisplay.Insertion] =    BEGIN    SELECT p.options.bottomAction FROM      signal => p.CheckBoxHeight[select];      scroll =>        IF wasVisible THEN          BEGIN          currentTop: Position;	  IF p.lineTable.length = 1 AND ~p.PositionIsVisible[insert.position] THEN {	    Display.White[p.wh, p.box];	    p.allBetsAreOff ¬ TRUE;	    p.lineTable.firstPosition ¬ p.lineTable.lastPositionPlusOne;	    p.lineTable.crIsLast ¬ FALSE;	    p.lineTable.array[0] ¬ [pos: p.lineTable.lastPositionPlusOne, width: 0];	    p.lineTable.array[1] ¬ [pos: TextSource.nullPosition, width: 0];	    p.Display[select];	  } ELSE { 	    UNTIL p.PositionIsVisible[insert.position] DO	      currentTop ¬ p.lineTable[0].pos;	      TextDisplayExtra.SetPositionWithOverRide[p, p.lineTable[1].pos, select, top];	      IF currentTop = p.lineTable[0].pos THEN EXIT;  -- Set failed	      ENDLOOP;	    };          END;      ENDCASE;    END;  Update: PUBLIC PROCEDURE [    p: TextDisplay.Handle, from, to: Position, select: TextDisplay.Selection,    clear: BOOLEAN ¬ TRUE, charsDeleted: BOOLEAN ¬ TRUE] =    -- to be called after an insertion or deletion    -- will display lines until lineTable is valid    BEGIN    i, j, eofLine: CARDINAL;    textPlace: TextDisplay.Place;    position: Position ¬ from;    eofVisible, eofOnNewLine: BOOLEAN ¬ FALSE;    clearTheRest: BOOLEAN ¬ clear;    crOnEnd, checkCR: BOOLEAN ¬ FALSE;    lineTable: TextDisplay.LineTable = p.lineTable;    source: TextSource.Handle = p.source;    IF from < lineTable[0].pos AND to < lineTable[0].pos THEN RETURN;    textPlace ¬ p.PlaceFromPosition[from, charsDeleted];    i ¬ textPlace.line;    DO      IF eofVisible THEN        BEGIN        lineTable[i].pos ¬          IF i = 0 THEN source.getLength[source] ELSE nullPosition;        IF clearTheRest THEN          BEGIN          place: Window.Place = p.LineStartPlace[i];          Display.White[            p.wh, [            place, [            p.box.dims.w - p.options.margin,            p.box.place.y + p.box.dims.h - place.y]]];          clearTheRest ¬ FALSE;          END;        END      ELSE        BEGIN        IF textPlace.position = 0 THEN          BEGIN          IF lineTable[i].pos # nullPosition THEN  -- possible bits to save            BEGIN            clearLine: BOOLEAN ¬ TRUE;            FOR j DECREASING IN (i..lineTable.length) DO              IF position = lineTable[j].pos THEN                BEGIN                p.MoveLines[j, i];                position ¬ lineTable.lastPositionPlusOne;                IF lineTable.lastPositionPlusOne = source.getLength[source] THEN                  BEGIN checkCR ¬ TRUE; GOTO quit; END;                i ¬ textPlace.line ¬ lineTable.length - (j - i);                clearLine ¬ FALSE;                EXIT;                END;              ENDLOOP;            IF position < lineTable[i].pos THEN  -- maybe bits to save              BEGIN              MeasureLine: PROCEDURE RETURNS [pos: Position] =                BEGIN                temp: Position ¬ lineTable[i].pos;                lineTable[i].pos ¬ position;                pos ¬ DisplayOneLine[p, textPlace, select, measure].position;                lineTable[i].pos ¬ temp;                END;              IF i + 2 < lineTable.length AND crOnEnd                AND MeasureLine[] <= lineTable[i].pos THEN                BEGIN                IF lineTable[lineTable.length - 1].pos # nullPosition THEN                  BEGIN                  lineTable.lastPositionPlusOne ¬ lineTable[                    lineTable.length - 1].pos;                  checkCR ¬ TRUE                  END;                p.MoveLines[i, i + 1];                END;              END;            IF clearLine THEN              Display.White[                p.wh, [                p.LineStartPlace[i], [                p.box.dims.w - p.options.margin, p.sink.fontInfo[                p.sink].lineHeight]]];            END;          lineTable[i].pos ¬ position;          END;        [position, crOnEnd] ¬ DisplayOneLine[          p, textPlace, select, IF clear THEN replaceAndClear ELSE paint];        IF position = source.getLength[source] THEN          BEGIN          IF crOnEnd THEN eofOnNewLine ¬ TRUE;          eofVisible ¬ TRUE;          eofLine ¬ i + 1;          END;        textPlace ¬ [textPlace.line + 1, 0];        IF position > to AND textPlace.line + 1 < lineTable.length          AND lineTable[textPlace.line].pos = position          AND lineTable[textPlace.line + 1].pos # position THEN GOTO quit;        END;      i ¬ i + 1;      IF i >= lineTable.length THEN GOTO done;      REPEAT        quit => NULL;        done =>          BEGIN          lineTable.crIsLast ¬ crOnEnd;          lineTable.lastPositionPlusOne ¬ position;          IF eofVisible AND eofOnNewLine THEN lineTable[eofLine].pos ¬ position;          END;      ENDLOOP;    IF checkCR THEN      BEGIN      IF lineTable.lastPositionPlusOne = 0 THEN lineTable.crIsLast ¬ FALSE      ELSE        BEGIN        pos, crPos: Position;        pos ¬ lineTable.lastPositionPlusOne - 1;        crPos ¬ source.scanText[source, pos, line, right];        lineTable.crIsLast ¬ crPos = pos;        END;      END;    END;  UpdateLineTable: PUBLIC PROCEDURE [    p: TextDisplay.Handle, position: Position, delta: LONG INTEGER] =    BEGIN    -- position is first bad position (where you deleted or inserted the text)    i: CARDINAL;    lastGoodEntry, pos: Position;    lineTable: TextDisplay.LineTable = p.lineTable;    newLength: Position = p.source.getLength[p.source];    line: CARDINAL ¬ p.PlaceFromPosition[position, FALSE].line;    IF delta < 0 THEN lastGoodEntry ¬ lineTable[line].pos;    line ¬ IF position < lineTable[0].pos THEN 0 ELSE line + 1;    FOR i IN [line..lineTable.length) DO      IF lineTable[i].pos = nullPosition THEN EXIT;      pos ¬ IF delta < 0 AND ABS[delta] > lineTable[i].pos THEN 0         ELSE lineTable[i].pos + delta;      lineTable[i].pos ¬        SELECT TRUE FROM          pos > newLength => nullPosition,          delta < 0 AND position IN (pos..lineTable[i].pos) => lastGoodEntry,          ENDCASE => pos;      ENDLOOP;    IF position <= lineTable.lastPositionPlusOne THEN      lineTable.lastPositionPlusOne ¬ MAX[        position, lineTable.lastPositionPlusOne + delta];    IF lineTable[0].pos = nullPosition THEN      BEGIN      lineTable[0].pos ¬ newLength;      lineTable.lastPositionPlusOne ¬ newLength;      END;    FOR i DECREASING IN (0..lineTable.length) DO      IF lineTable[i].pos = lineTable[i - 1].pos        OR (delta < 0 AND lineTable[i].pos = newLength) THEN        lineTable[i].pos ¬ nullPosition;      ENDLOOP;    END;  -- Private Utilities  FixSelection: PROCEDURE [    source: TextSource.Handle, select: TextDisplay.Selection, pos: Position,    delta: LONG INTEGER] =    -- Handles tricky cases of large deletions that intersect the selection    --   on the left only.  Also extends "point" selection at insert properly.    -- pos is always left side of edited region before the edit (i.e. first bad).    BEGIN    sourceLength: LONG CARDINAL = source.getLength[source];    newPos: Position;    IF select = NIL THEN RETURN;    SELECT delta FROM      < 0 => {newPos ¬ pos; pos ¬ pos - delta};      > 0 => newPos ¬ pos + delta;      ENDCASE => newPos ¬ pos;    SELECT pos FROM      IN (select.left..select.right] =>        BEGIN        select.right ¬ select.right + delta;        IF select.left > newPos THEN select.left ¬ newPos;        END;      < select.left =>        BEGIN        select.right ¬ select.right + delta;        select.left ¬ select.left + delta;        END;      = select.left =>        IF select.left = select.right THEN select.right ¬ newPos        ELSE          BEGIN          select.right ¬ select.right + delta;          select.left ¬ select.left + delta;          END;      ENDCASE => IF select.right > newPos THEN select.right ¬ newPos;    -- Make sure new selection is valid    IF select.right > sourceLength THEN select.right ¬ sourceLength;    IF select.left > select.right THEN select.left ¬ select.right;    END;  END. -- of TextDisplaysD.mesaLOGDWR    	28-Feb-85 10:40:08 Made TakeBottomAction use SetPositionWithOverRide + made one line windows scroll
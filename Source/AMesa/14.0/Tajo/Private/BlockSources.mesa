-- Copyright (C) 1981, 1982  by Xerox Corporation. All rights reserved. -- File: BlockSources.mesa - last edited:-- SXW   , 	23-Jun-81  8:08:51-- PXK    , 	21-Jan-81 15:56:49-- JGS, 	19-Aug-81 13:52:09-- SEH,  	9-Dec-81 16:50:34-- BGY     , 	20-Sep-82 16:02:36 -- AXD    , 	22-Sep-82 12:19:41 DIRECTORY  BlockSource USING [Block, Handle],  Environment USING [Byte],  Heap: TYPE USING [systemZone],  Inline USING [LowHalf],  TextSource USING [    Action, ActOnProc, AsciiScanText, Class, DoEditActionProc,    Error, GetLengthProc, Handle, Position, Procedures, ProceduresObject,    ReadTextProc, ReplaceTextProc, SetLengthProc, AsciiTestClass];BlockSources: PROGRAM IMPORTS Heap, Inline, TextSource EXPORTS BlockSource =  BEGIN  -- Block Sources  BS: TYPE = LONG POINTER TO BlockSourceObject;  BlockSourceObject: TYPE = RECORD [    procs: TextSource.Procedures ¬ @blockProcs, block: BlockSource.Block];  blockProcs: TextSource.ProceduresObject ¬ [    actOn: ActOnBlock, doEditAction: BlockEditAction, getLength: GetBlockLength,    readText: ReadBlockText, replaceText: ReplaceBlockText,    scanText: TextSource.AsciiScanText, setLength: SetBlockLength];  SourceToBlockSource: PROCEDURE [h: TextSource.Handle] RETURNS [b: BS] = {    b ¬ LOOPHOLE[h]; IF b.procs # @blockProcs THEN ERROR TextSource.Error[other]};  ActOnBlock: TextSource.ActOnProc = {    IF source = NIL THEN RETURN;    [] ¬ SourceToBlockSource[source];    SELECT action FROM      destroy => Heap.systemZone.FREE[@source];      sleep, truncate, wakeup => NULL;      ENDCASE => ERROR;    RETURN};  BlockEditAction: TextSource.DoEditActionProc = {RETURN[0]};  Create: PUBLIC PROCEDURE [block: BlockSource.Block]    RETURNS [source: BlockSource.Handle] = {    bs: BS ¬ Heap.systemZone.NEW[BlockSourceObject ¬ [block: block]];    RETURN[@bs.procs]};  GetBlockLength: TextSource.GetLengthProc = {    bs: BS = SourceToBlockSource[source];    RETURN[bs.block.stopIndexPlusOne - bs.block.startIndex]};  ReadBlockText: TextSource.ReadTextProc = {    bs: BS = SourceToBlockSource[source];    offset: CARDINAL ¬ Inline.LowHalf[position] + bs.block.startIndex;    lastIndex: CARDINAL ¬ MIN[offset, bs.block.stopIndexPlusOne];    charsToCheck: CARDINAL ¬ MIN[      maxLength, bs.block.stopIndexPlusOne - lastIndex];    IF charsToCheck = 0 THEN RETURN[[bs.block.blockPointer, 0, 0], position];    block ¬ [bs.block.blockPointer, offset, offset + charsToCheck];    IF class # none THEN      FOR i: CARDINAL IN [block.startIndex..block.stopIndexPlusOne) DO        chars: LONG POINTER TO PACKED ARRAY [0..0) OF CHARACTER =          LOOPHOLE[block.blockPointer];        IF TextSource.AsciiTestClass[chars[i], class] THEN {          block.stopIndexPlusOne ¬ i + 1; EXIT};        ENDLOOP;    RETURN[block, position + block.stopIndexPlusOne - offset]};  ReplaceBlockText: TextSource.ReplaceTextProc = {RETURN[from, 0]};  SetBlockLength: TextSource.SetLengthProc = {    bs: BS = SourceToBlockSource[source];    RETURN[bs.block.stopIndexPlusOne - bs.block.startIndex]};  Info: PUBLIC PROCEDURE [source: BlockSource.Handle]    RETURNS [block: BlockSource.Block] = {    bs: BS = SourceToBlockSource[source]; RETURN[bs.block]};  IsIt: PUBLIC PROCEDURE [source: BlockSource.Handle] RETURNS [BOOLEAN] = {    RETURN[source­ = @blockProcs]};  Set: PUBLIC PROCEDURE [source: BlockSource.Handle, block: BlockSource.Block] = {    bs: BS = SourceToBlockSource[source]; bs.block ¬ block};  END. -- of BlockSources
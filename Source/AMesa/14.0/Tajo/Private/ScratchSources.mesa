-- Copyright (C) 1981, 1982, 1983  by Xerox Corporation. All rights reserved. -- File: ScratchSources.mesa - last edited:-- SXW   ,	23-Jun-81  8:08:51-- PXK    ,	25-Feb-82 16:23:48-- JGS,		11-Feb-83 16:35:41-- SEH,		 9-Dec-81 17:06:20-- AXD    ,	22-Sep-82 17:09:53-- DWR    	19-Feb-85 11:39:08DIRECTORY  BitBlt USING [AlignedBBTable, BITBLT, BBptr, BBTableSpace],  ByteBlt USING [ByteBlt],  Environment USING [bitsPerByte, Block, bytesPerPage, nullBlock],  Heap: TYPE USING [systemZone],  Inline USING [LongCOPY, LowHalf],  MSegment: TYPE USING [FreePages, GetPages],  MStream USING [Handle, ReadWrite, SetLength],  ScratchSource USING [],  Selection,  Stream USING [Delete, PutBlock, PutString, SendNow],  String USING [AppendSubString, CopyToNewString, Length, SubStringDescriptor],  TextSource USING [    Access, Action, ActOnProc, AsciiDoEditAction, AsciiScanText, Class,    DoEditActionProc, Error, GetLengthProc, Handle, Position, Procedures,    ProceduresObject, ReadTextProc, ReplaceTextProc, SetLengthProc,    AsciiTestClass],  UserTerminal USING [BlinkDisplay];ScratchSources: MONITOR  IMPORTS BitBlt, ByteBlt, Heap, Inline, MSegment, MStream, Selection, Stream, String, TextSource, UserTerminal  EXPORTS ScratchSource =  BEGIN  -- Block Sources  SS: TYPE = LONG POINTER TO ScratchSourceObject;  ScratchSourceObject: TYPE = RECORD [    procs: TextSource.Procedures ¬ @scratchProcs,    block: Environment.Block,    expandable: BOOLEAN,    access: TextSource.Access,    extraRoom: CARDINAL];  -- monitored data  scratchSources: SSList ¬ NIL;  SSElement: TYPE = RECORD [    ss: SS ¬ NIL,    next: SSList ¬ NIL];  SSList: TYPE = LONG POINTER TO SSElement;  scratchProcs: TextSource.ProceduresObject ¬ [    actOn: ActOn, doEditAction: TextSource.AsciiDoEditAction,    getLength: GetLength, readText: ReadText, replaceText: ReplaceText,    scanText: TextSource.AsciiScanText, setLength: SetLength];  Create: PUBLIC PROCEDURE [    block: Environment.Block ¬ Environment.nullBlock, extraRoom: CARDINAL ¬ 0,    access: TextSource.Access ¬ edit, expandable: BOOLEAN ¬ TRUE]    RETURNS [source: TextSource.Handle] = {    ss: SS ¬ Heap.systemZone.NEW[ScratchSourceObject];    IF block = Environment.nullBlock THEN {      block ¬ [        blockPointer: MSegment.GetPages[1], startIndex: 0, stopIndexPlusOne: 0];      extraRoom ¬ Environment.bytesPerPage};    ss­ ¬ [      block: block, expandable: expandable, access: access, extraRoom: extraRoom];    SourceCreated[ss];    RETURN[@ss.procs]};  Info: PUBLIC PROCEDURE [source: TextSource.Handle]    RETURNS [      block: Environment.Block, extraRoom: CARDINAL, access: TextSource.Access,      expandable: BOOLEAN] = {    ss: SS = ValidateScratchSource[source];    RETURN[ss.block, ss.extraRoom, ss.access, ss.expandable]};  IsIt: PUBLIC PROCEDURE [source: TextSource.Handle] RETURNS [BOOLEAN] = {    IF source = NIL THEN RETURN[FALSE]; RETURN[source­ = @scratchProcs]};  ValidateScratchSource: PROCEDURE [h: TextSource.Handle] RETURNS [s: SS] = {    s ¬ LOOPHOLE[h];    IF s.procs # @scratchProcs THEN ERROR TextSource.Error[other]};  ActOn: TextSource.ActOnProc = {    ss: SS;    IF source = NIL THEN RETURN;    ss ¬ ValidateScratchSource[source];    SELECT action FROM      destroy => {        SourceDestroyed[ss];        IF ss.expandable THEN MSegment.FreePages[ss.block.blockPointer];        Heap.systemZone.FREE[@source]};      sleep, truncate, wakeup => NULL;      ENDCASE => ERROR;    RETURN};  GetLength: TextSource.GetLengthProc = {    ss: SS = LOOPHOLE[source];    RETURN[ss.block.stopIndexPlusOne - ss.block.startIndex]};  ReadText: TextSource.ReadTextProc = {    ss: SS = LOOPHOLE[source];    offset: CARDINAL ¬ Inline.LowHalf[position] + ss.block.startIndex;    lastIndex: CARDINAL ¬ MIN[offset, ss.block.stopIndexPlusOne];    charsToCheck: CARDINAL ¬ MIN[      maxLength, ss.block.stopIndexPlusOne - lastIndex];    IF charsToCheck = 0 THEN RETURN[[ss.block.blockPointer, 0, 0], position];    block ¬ [ss.block.blockPointer, offset, offset + charsToCheck];    IF class # none THEN {      chars: LONG POINTER TO PACKED ARRAY OF CHARACTER =        LOOPHOLE[block.blockPointer];      FOR i: CARDINAL IN [block.startIndex..block.stopIndexPlusOne) DO        IF TextSource.AsciiTestClass[chars[i], class] THEN {          block.stopIndexPlusOne ¬ i + 1; EXIT};        ENDLOOP};    RETURN[block, position + block.stopIndexPlusOne - block.startIndex]};  SetLength: TextSource.SetLengthProc = {    ss: SS = LOOPHOLE[source];    length: CARDINAL = ss.block.stopIndexPlusOne - ss.block.startIndex;    IF ss.access = read OR position > length THEN RETURN[length];    ss.block.stopIndexPlusOne ¬ ss.block.startIndex + Inline.LowHalf[position];    RETURN[position]};  ReplaceText: TextSource.ReplaceTextProc =    BEGIN    ss: SS = LOOPHOLE[source];    pos: CARDINAL ¬ Inline.LowHalf[from];    inserted: CARDINAL ¬ block.stopIndexPlusOne - block.startIndex;    deleted: CARDINAL = Inline.LowHalf[to - from];    change: INTEGER ¬ inserted - deleted;    IF ss.access = read      OR        (ss.access = append          AND pos # ss.block.stopIndexPlusOne - ss.block.startIndex) THEN      ERROR TextSource.Error[accessError];    IF deleted # 0 AND deleteToTrashbin THEN      Selection.SetTrashBin[        GetTrash[[ss.block.blockPointer, pos, pos + deleted]], ConvertTrash,        ClearTrash];    IF change > 0 AND CARDINAL[change] > ss.extraRoom THEN {      oldPages: CARDINAL = PagesForBytes[        ss.block.stopIndexPlusOne - ss.block.startIndex + ss.extraRoom];      increment: CARDINAL = MAX[PagesForBytes[CARDINAL[change]], 2];      newPages: CARDINAL = MIN[oldPages + increment, 127];      IF ~ss.expandable OR newPages = oldPages THEN {        inserted ¬ ss.extraRoom + deleted; change ¬ inserted - deleted}      ELSE {        newBase: LONG POINTER = MSegment.GetPages[newPages];        Inline.LongCOPY[          from: ss.block.blockPointer, to: newBase,          nwords: (ss.block.stopIndexPlusOne - ss.block.startIndex + 1)/2];        MSegment.FreePages[ss.block.blockPointer];        ss.block.blockPointer ¬ newBase;        ss.extraRoom ¬          ss.extraRoom + (newPages - oldPages)*Environment.bytesPerPage;        IF CARDINAL[change] > ss.extraRoom THEN {          inserted ¬ ss.extraRoom + deleted; change ¬ inserted - deleted}}};    IF change # 0 THEN {      Move[        block: [ss.block.blockPointer, pos + deleted, ss.block.stopIndexPlusOne],        delta: change];      ss.block.stopIndexPlusOne ¬ ss.block.stopIndexPlusOne + change};    IF inserted > 0 THEN      [] ¬ ByteBlt.ByteBlt[        from: block, to: [ss.block.blockPointer, pos, pos + inserted]];    ss.extraRoom ¬ ss.extraRoom - change;    RETURN[pos + inserted, change];    END;  PagesForBytes: PROCEDURE [bytes: CARDINAL] RETURNS [CARDINAL] = INLINE {    RETURN[(bytes + Environment.bytesPerPage - 1)/Environment.bytesPerPage]};  Move: PROCEDURE [block: Environment.Block, delta: INTEGER] =    BEGIN    bba: BitBlt.BBTableSpace;    bbt: BitBlt.BBptr = BitBlt.AlignedBBTable[@bba];    bytesPerLine, bitsPerLine: CARDINAL;    lines, tail: CARDINAL;    nBytes: CARDINAL = ABS[delta];    dest: CARDINAL = block.startIndex + delta;    bytesToMove: CARDINAL = block.stopIndexPlusOne - block.startIndex;    SELECT bytesToMove FROM      0 => RETURN;      <= nBytes => {        [] ¬ ByteBlt.ByteBlt[          from: block, to: [block.blockPointer, dest, dest + nBytes]];        RETURN};      ENDCASE;    bytesPerLine ¬      SELECT nBytes FROM        < 2 => 1,        < 4 => 2,        < 8 => 4,        < 16 => 8,        < 32 => 16,        ENDCASE => 32;    bitsPerLine ¬ bytesPerLine*Environment.bitsPerByte;    lines ¬ bytesToMove/bytesPerLine;    IF delta < 0 THEN {      bbt­ ¬ [        dst: [        word: block.blockPointer + dest/2,        bit: (dest MOD 2)*Environment.bitsPerByte], dstBpl: bitsPerLine,        src: [        word: block.blockPointer + block.startIndex/2,        bit: block.startIndex MOD 2*Environment.bitsPerByte],        srcDesc: [srcBpl[bitsPerLine]], width: bitsPerLine, height: lines,        flags: [        direction: forward, disjoint: FALSE, disjointItems: FALSE, gray: FALSE,        srcFunc: null, dstFunc: null]]}    ELSE {      bbt­ ¬ [        dst: [        word: block.blockPointer + (bytesToMove + dest - bytesPerLine)/2,        bit: ((bytesToMove + dest - bytesPerLine) MOD 2)*Environment.bitsPerByte],        dstBpl: -INTEGER[bitsPerLine],        src: [        word:        block.blockPointer + (bytesToMove + block.startIndex - bytesPerLine)/2,        bit:        (bytesToMove + block.startIndex - bytesPerLine) MOD          2*Environment.bitsPerByte], srcDesc: [srcBpl[-INTEGER[bitsPerLine]]],        width: bitsPerLine, height: lines,        flags: [        direction: backward, disjoint: FALSE, disjointItems: FALSE, gray: FALSE,        srcFunc: null, dstFunc: null]]};    IF lines # 0 THEN BitBlt.BITBLT[bbt];    IF (tail ¬ bytesToMove MOD bytesPerLine) # 0 THEN {      IF delta < 0 THEN {        bbt.dst.word ¬ bbt.dst.word + lines*bytesPerLine/2;        bbt.src.word ¬ bbt.src.word + lines*bytesPerLine/2}      ELSE {        bbt.dst.word ¬ bbt.dst.word - ((lines - 1)*bytesPerLine + tail)/2;        bbt.src.word ¬ bbt.src.word - ((lines - 1)*bytesPerLine + tail)/2;        IF tail MOD 2 # 0 THEN {          IF bbt.dst.bit # 0 THEN bbt.dst.bit ¬ 0          ELSE {            bbt.dst.bit ¬ Environment.bitsPerByte;            bbt.dst.word ¬ bbt.dst.word - 1};          IF bbt.src.bit # 0 THEN bbt.src.bit ¬ 0          ELSE {            bbt.src.bit ¬ Environment.bitsPerByte;            bbt.src.word ¬ bbt.src.word - 1}}};      bbt.width ¬ Environment.bitsPerByte*tail;      bbt.height ¬ 1;      BitBlt.BITBLT[bbt]};    END;  -- TrashBin routines  Trash: TYPE = LONG POINTER TO TrashObject;  TrashObject: TYPE = RECORD [trash: LONG STRING, offset: CARDINAL];  GetTrash: PROCEDURE [block: Environment.Block] RETURNS [t: Trash] =    BEGIN    nChars: CARDINAL = block.stopIndexPlusOne - block.startIndex;    s: LONG STRING ¬ Heap.systemZone.NEW[StringBody [nChars]];    t ¬ Heap.systemZone.NEW[TrashObject ¬ [s, 0]];    [] ¬ ByteBlt.ByteBlt[from: block, to: [LOOPHOLE[@s.text], 0, nChars]];    s.length ¬ nChars;    END;  ConvertTrash: PROCEDURE [data: Trash, target: Selection.Target]    RETURNS [LONG POINTER] =    BEGIN OPEN Selection;    SELECT target FROM      length =>        BEGIN        p: LONG POINTER TO LONG CARDINAL ¬ Heap.systemZone.NEW[          LONG CARDINAL ¬ String.Length[data.trash]];        RETURN[p];        END;      string =>        IF String.Length[data.trash] > maxStringLength THEN RETURN[NIL]        ELSE RETURN[String.CopyToNewString[data.trash, Heap.systemZone]];      source =>        BEGIN        s: Source ¬ Heap.systemZone.NEW[          SourceObject ¬ [data: data, proc: ReadSource, destroy: DestroySource]];        RETURN[s];        END;      ENDCASE => RETURN[NIL];    END;  ClearTrash: PROCEDURE [data: Trash] =    BEGIN Heap.systemZone.FREE[@data.trash]; Heap.systemZone.FREE[@data] END;  DestroySource: PROCEDURE [source: Selection.Source] =    BEGIN Heap.systemZone.FREE[@source]; END;  ReadSource: PROCEDURE [data: Trash, string: LONG STRING] =    BEGIN OPEN data;    ss: String.SubStringDescriptor;    trashLength: CARDINAL = String.Length[trash];    string.length ¬ 0;    IF trashLength > offset THEN      BEGIN      ss ¬ [        base: trash, offset: offset,        length: MIN[string.maxlength, trashLength - offset]];      String.AppendSubString[string, @ss];      offset ¬ offset + string.length;      END;    END;      SourceCreated: ENTRY PROCEDURE [ss: SS] = {    scratchSources ¬ Heap.systemZone.NEW[SSElement ¬ [ss: ss, next: scratchSources]]};      SourceDestroyed: ENTRY PROCEDURE [ss: SS] = {    next, item, prev: SSList;    prev ¬ NIL;    FOR item ¬ scratchSources, next UNTIL item = NIL DO      next ¬ item.next;      IF item.ss = ss THEN {        IF prev = NIL THEN scratchSources ¬ next ELSE prev.next ¬ next;        Heap.systemZone.FREE[@item]}      ELSE prev ¬ item;    ENDLOOP};        Save: ENTRY PROCEDURE = { -- save all ScratchSources to a file    writeS: MStream.Handle ¬ MStream.ReadWrite["ScratchSources.saved"L, [], text];    MStream.SetLength[writeS, 0];    FOR sl: SSList ¬ scratchSources, sl.next UNTIL sl = NIL DO BEGIN       ENABLE ANY => {UserTerminal.BlinkDisplay[]; CONTINUE};	writeS.PutString["\n=====  Scratch Source =====\n"L];	writeS.PutBlock[sl.ss.block];      END;    ENDLOOP;    writeS.SendNow;    writeS.Delete};  END. -- of ScratchSourcesDWR    	19-Feb-85 11:28:56  Added SourceCreated, SourceDestroyed, & Save
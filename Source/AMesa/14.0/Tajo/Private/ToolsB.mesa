-- Copyright (C) 1981, 1982, 1983  by Xerox Corporation. All rights reserved. -- File: ToolsB.mesa - last edited by:-- SXW   	11-Jul-81 11:50:07-- PXK    	11-Nov-82 14:57:30-- Mark		26-May-81 11:23:43-- SXE  	Oct 3, 1980 10:25 AM-- JGS    	19-Aug-81  8:00:15-- SXS   	21-Sep-82 14:34:52-- BXM  	19-Nov-81 10:42:08-- BGY     	27-Dec-82 14:22:35-- CXH   	14-Nov-82 21:15:27-- AXD    	17-Feb-83 17:01:36DIRECTORY  Context: TYPE USING [Find],  Display: TYPE USING [Black, White],  FileSW: TYPE USING [    Access, Create, defaultOptions, Enumerate, EnumerateProcType, IsIt, Options],  FormSW: TYPE USING [    ClientItemsProcType, Create, FreeAllItems, IsIt, NeededHeight, Options],  Heap: TYPE USING [systemZone],  Menu: TYPE USING [    Destroy, Enumerate, EnumerateFor, Error, Handle, Uninstantiate],  MsgSW: TYPE USING [Create, IsIt],  Scrollbar: TYPE USING [Adjust, WindowNowDelinked],  String: TYPE USING [AppendDecimal, AppendString, EmptyString, EquivalentString],  StringSW: TYPE USING [Create, defaultOptions, IsIt],  TajoMisc: TYPE USING [FindClippingWindow],  TextSink: TYPE USING [Handle],  TextSource: TYPE USING [Handle, Position],  TextSW: TYPE USING [Access, Create, IsIt, Options],  TIP: TYPE USING [CreateClient, mouseTIP],  Tool: TYPE USING [DefaultHeight, Error, SWProc, SWType],  ToolOps: TYPE USING [    AdjustProc, bdryFudge, bdryHeight, bdryLineWidth, bdryMargin, BoxSequence,     BSHandle, context, ContextHandle, fileSW, formSW, InitMonitorData,     msgSW, nextSWType, SleepProc, stringSW, SWBox, SWSequence, SWRecord,    textSW, TIPMe, ttySW, WakeupProc],  ToolWindow: TYPE USING [    AdjustProcType, Box, CreateSubwindow, DelinkSubwindow, DrawRectangle,    EnlinkSubwindow, Handle, nullBox, State, TransitionProcType,    WindowForSubwindow, When],  TTYSW: TYPE USING [Create, IsIt],  Window: TYPE USING [    Box, Dims, GetBox, GetParent, Handle, InvalidateBox,    Place, SetDisplayProc, SlideAndSize, ValidateTree],  WindowFont: TYPE USING [FontHeight];ToolsB: PROGRAM  IMPORTS    Context, Display, FileSW, FormSW, Heap,      Menu, MsgSW, Scrollbar, String, StringSW,    TajoMisc, TextSW, TIP, Tool, ToolOps, ToolWindow,     TTYSW, Window, WindowFont  EXPORTS Tool, ToolOps = BEGIN  defaultH: CARDINAL = Tool.DefaultHeight;    z: UNCOUNTED ZONE = Heap.systemZone;    -- Tool Public Interface Procedures  MakeDefaultSWs: PUBLIC PROC [    window: Window.Handle, messageLines: CARDINAL,    formProc: FormSW.ClientItemsProcType, formHeight: CARDINAL,    logName: LONG STRING]    RETURNS [msgSW, formSW, logSW: Window.Handle] = {    msgSW ¬ MakeMsgSW[window: window, lines: messageLines];    formSW ¬ MakeFormSW[window: window, formProc: formProc, h: formHeight];    logSW ¬ MakeFileSW[window: window, name: logName]};  NopSleepProc: PUBLIC Tool.SWProc = {NULL};  NopWakeupProc: PUBLIC Tool.SWProc = {NULL};  SimpleAdjustProc: PUBLIC ToolWindow.AdjustProcType = {NULL};  -- Transition related procedures  FreeFormSWItems: PROC [tch: ToolOps.ContextHandle] = {    FOR i: CARDINAL IN [0..tch.sws.length) DO      IF tch.sws[i].type = ToolOps.formSW THEN FormSW.FreeAllItems[tch.sws[i].sw];      ENDLOOP};  Transition: PUBLIC PROC [    window: Window.Handle, old, new: ToolWindow.State] = {    << Call clientTransition proc before do anything.  If a client    is not satisfied with this ordering then he could substitute    his own ToolWindow.TransitionProcType at Tool.Create which    calls this one. >>    tch: ToolOps.ContextHandle = LocalFind[window];    IF new = old THEN RETURN;    IF new = inactive THEN FreeFormSWItems[tch];    << Do here before call client cause he might have a transition proc that    frees the object holding the strings that a formSW might be pointing to >>    IF tch.clientTransition # NIL THEN      tch.clientTransition[window: window, old: old, new: new];    SELECT TRUE FROM      old = inactive => {        tch.runningMakeSWsProc ¬ TRUE;        tch.makeSWsProc[window];        tch.runningMakeSWsProc ¬ FALSE;        SetMovableBoundary[window];        IF new = tiny THEN PutToSleepSWs[tch];        << can happen at start up time.  Inefficient but no        one prepared for inactive -> tiny. >>};      old = tiny AND new = active => {WakeUpSWs[tch]; SetMovableBoundary[window]};      old = active AND new = tiny => PutToSleepSWs[tch];      new = inactive => {        RemoveMenus[window, all];        z.FREE[@tch.sws];        tch.sws ¬ z.NEW[ToolOps.SWSequence[0]];        z.FREE[@tch.boxes];        tch.boxes ¬ z.NEW[ToolOps.BoxSequence[0]]};      ENDCASE};  PutToSleepSWs: PROC [tch: ToolOps.ContextHandle] = {    FOR i: CARDINAL IN [0..tch.sws.length) DO      ToolOps.SleepProc[tch.sws[i].type][tch.sws[i].sw]; ENDLOOP};  RemoveMenus: PUBLIC PROC [window: Window.Handle, which: Menu.EnumerateFor] = {    menuToDestroy: Menu.Handle;    CalledProc: PROC [window: Window.Handle, menu: Menu.Handle]      RETURNS [stop: BOOLEAN] = {menuToDestroy ¬ menu; RETURN[TRUE]};    DO      menuToDestroy ¬ NIL;      Menu.Enumerate[window: window, which: which, proc: CalledProc];      IF menuToDestroy = NIL THEN EXIT      ELSE {        menuToDestroy.Uninstantiate[window];        menuToDestroy.Destroy[ ! Menu.Error =>	  IF code = isPermanent OR code = isInstantiated THEN CONTINUE]};      ENDLOOP};  SetMovableBoundary: PROC [window: Window.Handle] = {    tch: ToolOps.ContextHandle = LocalFind[window];    clipWindow: Window.Handle = TajoMisc.FindClippingWindow[window];    IF tch.sws.length < 2 OR ~tch.moveBdry THEN RETURN;    [] ¬ clipWindow.SetDisplayProc[MoveBoundaryDisplayProc];    TIP.CreateClient[clipWindow, TIP.mouseTIP, ToolOps.TIPMe]};  WakeUpSWs: PROC [tch: ToolOps.ContextHandle] = {    FOR i: CARDINAL IN [0..tch.sws.length) DO      ToolOps.WakeupProc[tch.sws[i].type][tch.sws[i].sw] ENDLOOP};  -- SW Add/Delete procedures  DeleteThisSW: PUBLIC PROC [sw: Window.Handle] = {    window, clip: Window.Handle ¬ NIL;    tch: ToolOps.ContextHandle;    tempSWs: LONG POINTER TO ToolOps.SWSequence;    tempBoxes: ToolOps.BSHandle;    i, j, deleteMe, oldNumSWs, newNumSWs, startFix: INTEGER;    IF sw = NIL THEN RETURN;    tch ¬ LocalFind[window ¬ ToolWindow.WindowForSubwindow[sw]];    IF tch = NIL THEN Tool.Error[notATool];    oldNumSWs ¬ tch.sws.length;    newNumSWs ¬ oldNumSWs - 1;    deleteMe ¬ oldNumSWs;    IF oldNumSWs = 1 THEN RETURN;  -- I won't delete last SW.    tempSWs ¬ z.NEW[ToolOps.SWSequence[newNumSWs]];    tempBoxes ¬ z.NEW[ToolOps.BoxSequence[newNumSWs]];    {    ENABLE UNWIND => {z.FREE[@tempSWs]; z.FREE[@tempBoxes]};    {    i ¬ j ¬ 0;    WHILE j < oldNumSWs DO      IF tch.sws[j].sw = sw THEN {deleteMe ¬ j; j ¬ j + 1};      IF i = newNumSWs THEN EXIT;      tempSWs[i] ¬ tch.sws[j];      tempBoxes[i] ¬ tch.boxes[j];      i ¬ i + 1;      j ¬ j + 1;      ENDLOOP;    IF deleteMe = oldNumSWs THEN GOTO undo; -- NOT FOUND    clip ¬ TajoMisc.FindClippingWindow[sw];    ToolWindow.DelinkSubwindow[sw];    Scrollbar.WindowNowDelinked[sw];    z.FREE[@tch.sws]; 	 tch.sws ¬ tempSWs;    z.FREE[@tch.boxes];	 tch.boxes ¬ tempBoxes;    startFix ¬ IF deleteMe > 0 THEN deleteMe - 1 ELSE deleteMe;    InternalAdjustProc[window,[[0,0],clip.GetBox[].dims],before, startFix];    InternalAdjustProc[window,[[0,0],clip.GetBox[].dims],after, startFix];    FOR i IN [startFix..newNumSWs) DO       tch.sws[i].sw.InvalidateBox[[[0,0], tch.sws[i].sw.GetBox[].dims]];      ENDLOOP;    SetMovableBoundary[window];    window.ValidateTree[]};        EXITS undo => {z.FREE[@tempSWs]; z.FREE[@tempBoxes]}}};  AddThisSW: PUBLIC PROC [    window: Window.Handle, sw: Window.Handle, swType: Tool.SWType ¬ predefined,    nextSW: Window.Handle ¬ NIL, h: INTEGER ¬ defaultH] = {    OPEN Tool, ToolOps;    i, j, addMe, numSWs, startFix: CARDINAL;    tch: ToolOps.ContextHandle;    tempSWs: LONG POINTER TO ToolOps.SWSequence;    tempBoxes:  ToolOps.BSHandle;    clip: Window.Handle ¬ NIL;    IF window = NIL THEN Tool.Error[invalidWindow];    IF sw = NIL THEN RETURN;    clip ¬ TajoMisc.FindClippingWindow[window];    tch ¬ LocalFind[window];    IF swType = predefined THEN swType ¬ FindType[sw];    IF swType >= ToolOps.nextSWType THEN Tool.Error[unknownSWType];    addMe ¬ numSWs ¬ tch.sws.length;    tempSWs ¬ z.NEW[ToolOps.SWSequence[ numSWs + 1]];    tempBoxes ¬ z.NEW[ToolOps.BoxSequence[ numSWs + 1]];    j ¬ 0;    FOR i IN [0..numSWs) DO      IF tch.sws[i].sw = nextSW THEN {addMe ¬ j; j ¬ j + 1};      tempSWs[j] ¬ tch.sws[i];      tempBoxes[j] ¬ tch.boxes[i];      j ¬ j + 1;      ENDLOOP;    tempSWs[addMe] ¬ [sw: sw, type: swType];    IF sw.GetParent[] = NIL THEN       ToolWindow.EnlinkSubwindow[window, sw, nextSW];    SELECT TRUE FROM      ~tch.runningMakeSWsProc => {        IF h = defaultH THEN h ¬ IF sw.GetBox[].dims.h = defaultH	  THEN UseSWHeight[sw, swType, tch.moveBdry]          ELSE sw.GetBox[].dims.h + Bdry[tch.moveBdry, swType];        tempBoxes[addMe].h ¬ h;	IF addMe = numSWs AND addMe > 0 THEN {	  << Try to ensure that I'm visible by stealing space from preceding sw >>	  precedingMinHeight: INTEGER = UseSWHeight[	    tch.sws[addMe - 1].sw, tch.sws[addMe - 1].type, tch.moveBdry];	  IF precedingMinHeight < tempBoxes[addMe - 1].h THEN	    tempBoxes[addMe - 1].h ¬ precedingMinHeight}};      h # defaultH =>        tempBoxes[addMe].h ¬ h + Bdry[tch.moveBdry, swType];      sw.GetBox[].dims.h = defaultH =>        tempBoxes[addMe].h ¬ UseSWHeight[sw, swType, tch.moveBdry];      ENDCASE => { -- h is defaulted but has valid box size	tempBoxes[addMe].h ¬ sw.GetBox.dims.h + Bdry[tch.moveBdry, swType]};    z.FREE[@tch.sws];      tch.sws ¬ tempSWs;    z.FREE[@tch.boxes];    tch.boxes ¬ tempBoxes;    startFix ¬ IF addMe > 0 THEN addMe - 1 ELSE addMe;    IF ~tch.runningMakeSWsProc THEN {      InternalAdjustProc[window, [[0,0], clip.GetBox.dims], before, startFix];      InternalAdjustProc[window, [[0,0], clip.GetBox.dims], after, startFix];      IF addMe < numSWs THEN {        bad: Window.Box = [[0, 0], tch.sws[addMe].sw.GetBox.dims];        tch.sws[addMe + 1].sw.InvalidateBox[bad]}};    SetMovableBoundary[window];    IF ~tch.runningMakeSWsProc THEN window.ValidateTree};  -- Make...SW Routines  MakeFileSW: PUBLIC PROC [    window: Window.Handle, name: LONG STRING, access: FileSW.Access ¬ append,    h: INTEGER ¬ defaultH, allowTypeIn: BOOLEAN ¬ TRUE,     resetLengthOnNewSession: BOOLEAN ¬ FALSE,     resetLengthOnActivate: BOOLEAN ¬ FALSE]    RETURNS [sw: Window.Handle] = {    -- WHAT AM I SUPPOSED TO DO WITH resetLengthOnActivate???    options: FileSW.Options ¬ FileSW.defaultOptions;    boxToUse: Window.Box ¬ ToolWindow.nullBox;    boxToUse.dims.h ¬ h;    options.access ¬ access;    IF window = NIL THEN Tool.Error[invalidWindow];    FileSW.Create[      sw: sw ¬ ToolWindow.CreateSubwindow[parent: window, box: boxToUse],      name: name, options: options, allowTypeIn: allowTypeIn,      resetLengthOnNewSession: resetLengthOnNewSession];    AddThisSW[window: window, sw: sw, swType: ToolOps.fileSW]};  MakeFormSW: PUBLIC PROC [    window: Window.Handle, formProc: FormSW.ClientItemsProcType,    options: FormSW.Options ¬ [], h: INTEGER ¬ defaultH,    zone: UNCOUNTED ZONE ¬ Heap.systemZone]    RETURNS [sw: Window.Handle] ={    boxToUse: Window.Box ¬ ToolWindow.nullBox;    boxToUse.dims.h ¬ h;    IF formProc = NIL THEN RETURN[NIL];    IF window = NIL THEN Tool.Error[invalidWindow];    IF zone = NIL THEN zone ¬ Heap.systemZone; -- till interfaces can be changed    FormSW.Create[      sw: sw ¬ ToolWindow.CreateSubwindow[parent: window, box: boxToUse],      clientItemsProc: formProc, options: options, initialState: active,      zone:zone];    AddThisSW[window: window, sw: sw, swType: ToolOps.formSW]};  MakeMsgSW: PUBLIC PROC [    window: Window.Handle, lines: CARDINAL ¬ 1, h: INTEGER ¬ defaultH]    RETURNS [sw: Window.Handle] = {    boxToUse: Window.Box ¬ ToolWindow.nullBox;    fontHeight: INTEGER = WindowFont.FontHeight[];    boxToUse.dims.h ¬      IF h = defaultH THEN fontHeight*lines + ToolOps.bdryMargin*2 ELSE h;    IF lines = 0 THEN RETURN[NIL];    IF window = NIL THEN Tool.Error[invalidWindow];    MsgSW.Create[      sw: sw ¬ ToolWindow.CreateSubwindow[parent: window, box: boxToUse],      lines: lines];    AddThisSW[window: window, sw: sw, swType: ToolOps.msgSW]};  MakeStringSW: PUBLIC PROC [    window: Window.Handle, s: LONG POINTER TO LONG STRING, access: TextSW.Access,    h: INTEGER, expandable: BOOLEAN]    RETURNS [sw: Window.Handle] = {    options: TextSW.Options ¬ StringSW.defaultOptions;    boxToUse: Window.Box ¬ ToolWindow.nullBox;    boxToUse.dims.h ¬ h;    options.access ¬ access;    IF s = NIL THEN RETURN[NIL];    IF window = NIL THEN Tool.Error[invalidWindow];    StringSW.Create[      sw: sw ¬ ToolWindow.CreateSubwindow[parent: window, box: boxToUse],      s: s, options: options, expandable: expandable];    AddThisSW[window: window, sw: sw, swType: ToolOps.stringSW]};  MakeTextSW: PUBLIC PROC [    window: Window.Handle, source: TextSource.Handle, sink: TextSink.Handle,    options: TextSW.Options, position: TextSource.Position, allowTypeIn: BOOLEAN]    RETURNS [sw: Window.Handle] = {    boxToUse: Window.Box ¬ ToolWindow.nullBox;    IF window = NIL THEN Tool.Error[invalidWindow];    TextSW.Create[      sw: sw ¬ ToolWindow.CreateSubwindow[parent: window, box: boxToUse],      source: source, sink: sink, options: options, position: position,      allowTypeIn: allowTypeIn];    AddThisSW[window: window, sw: sw, swType: ToolOps.textSW]};  MakeClientSW: PUBLIC PROC [    window: Window.Handle,    clientProc: PROC [sw: Window.Handle, clientData: LONG POINTER],    clientData: LONG POINTER, swType: Tool.SWType, h: INTEGER]     RETURNS [sw: Window.Handle] = {    boxToUse: Window.Box ¬ ToolWindow.nullBox;    boxToUse.dims.h ¬ h;    IF window = NIL THEN Tool.Error[invalidWindow];    clientProc[      sw ¬ ToolWindow.CreateSubwindow[parent: window, box: boxToUse], clientData];    AddThisSW[window: window, sw: sw, swType: swType]};        MakeTTYSW: PUBLIC PROC [    window: Window.Handle, name: LONG STRING, h: INTEGER,    resetLengthOnNewSession: BOOLEAN] RETURNS [sw: Window.Handle] = {    boxToUse: Window.Box ¬ ToolWindow.nullBox;    boxToUse.dims.h ¬ h;    IF name = NIL THEN RETURN[NIL];    IF window = NIL THEN Tool.Error[invalidWindow];    TTYSW.Create[      sw: sw ¬ ToolWindow.CreateSubwindow[parent: window, box: boxToUse],      backupFile: name, newFile: TRUE,      resetLengthOnNewSession: resetLengthOnNewSession];    AddThisSW[window: window, sw: sw, swType: ToolOps.ttySW]};  -- Other public procs  ComputeSWs: PROC [tch: ToolOps.ContextHandle, box: Window.Box] = {    -- Calculates heights for the subwindows    last: CARDINAL = tch.boxes.length - 1;    tch.w ¬ box.dims.w;    ComputeYs[tch.boxes];    tch.boxes[last].h ¬ box.dims.h - tch.boxes[last].y}; -- fix last SW height    AdjustScrollBar: PROC [vW, hW: Window.Handle, vB, hB: Window.Box]= {    IF hW # NIL THEN hW.SlideAndSize[hB, nw];    IF vW # NIL THEN vW.SlideAndSize[vB, nw]};    DefaultAdjustProc: PUBLIC ToolWindow.AdjustProcType = {    InternalAdjustProc[window, box, when, 0]};      InternalAdjustProc: PROC [    window: Window.Handle, box: Window.Box, when: ToolWindow.When,     start: CARDINAL ¬ 0] = {    tch: ToolOps.ContextHandle = LocalFind[window];    i: CARDINAL;    vWindow, hWindow: Window.Handle ¬ NIL;    bigger: BOOLEAN = tch.oldH < box.dims.h;    tBox, vBox, hBox: Window.Box;    clip: Window.Handle = TajoMisc.FindClippingWindow[window];    invalidWidth: INTEGER = ToolOps.bdryHeight + ToolOps.bdryFudge;    invalid: Window.Box = [      place: [tch.w - invalidWidth,0],      dims: [invalidWidth, IF when = before THEN tch.oldH ELSE box.dims.h]];        ComputeBox: PROC [i: CARDINAL] RETURNS [box: Window.Box] = {      box ¬ [place: [0, tch.boxes[i].y], dims: [tch.w, tch.boxes[i].h]];      [box, vWindow, vBox, hWindow, hBox] ¬ Scrollbar.Adjust[tch.sws[i].sw, box]};        CallAdjust: PROC [box: Window.Box, j: CARDINAL] =  {      swr: ToolOps.SWRecord = tch.sws[j];      ToolOps.AdjustProc[swr.type][swr.sw, box, when]};	        IF clip = NIL THEN RETURN;    clip.InvalidateBox[invalid];    IF tch.sws.length = 0 THEN RETURN;    ComputeSWs[tch, box];    SELECT when FROM      before => {	IF bigger THEN  	  FOR i IN [start..tch.sws.length) DO	    CallAdjust[ComputeBox[i], i];	    ENDLOOP	ELSE	  FOR i DECREASING IN [start..tch.sws.length) DO	    tBox ¬ ComputeBox[i];	    CallAdjust[tBox, i];	    AdjustScrollBar[vWindow, hWindow,vBox, hBox];	    tch.sws[i].sw.SlideAndSize[tBox, nw];	    ENDLOOP};      after => {	IF bigger THEN	  FOR i IN [start..tch.sws.length) DO	    tBox ¬ ComputeBox[i];	    tch.sws[i].sw.SlideAndSize[tBox, nw];	    AdjustScrollBar[vWindow, hWindow,vBox, hBox];	    CallAdjust[tBox, i];	    ENDLOOP	ELSE	  FOR i DECREASING IN [start..tch.sws.length) DO	    tBox ¬ ComputeBox[i];	    AdjustScrollBar[vWindow, hWindow,vBox, hBox];	    tch.sws[i].sw.SlideAndSize[tBox, nw];	    CallAdjust[tBox, i];	    ENDLOOP;	tch.oldH ¬ box.dims.h};      ENDCASE};    FindType: PUBLIC PROC [sw: Window.Handle] RETURNS [swType: Tool.SWType] = {    SELECT TRUE FROM      FileSW.IsIt[sw] => swType ¬ ToolOps.fileSW;      FormSW.IsIt[sw] => swType ¬ ToolOps.formSW;      MsgSW.IsIt[sw] => swType ¬ ToolOps.msgSW;      TTYSW.IsIt[sw] => swType ¬ ToolOps.ttySW;      StringSW.IsIt[sw] => swType ¬ ToolOps.stringSW;      TextSW.IsIt[sw] => swType ¬ ToolOps.textSW;      ENDCASE => Tool.Error[unknownSWType]};  MoveBoundaryDisplayProc: PUBLIC PROC [window: Window.Handle] = {    OPEN ToolOps;    toolwindow: Window.Handle = window.GetParent;    tch: ToolOps.ContextHandle = LocalFind[toolwindow];    Display.White[window, [[0, 0], window.GetBox.dims]];    FOR i: CARDINAL IN [0..tch.sws.length - 1) DO      bdryBarWidth: CARDINAL = tch.w - (bdryHeight + bdryFudge);      h: INTEGER = tch.boxes[i].h;      y: INTEGER = tch.boxes[i].y;        ToolWindow.DrawRectangle[          window, [[x: bdryBarWidth, y: y+h], [w: bdryHeight, h: bdryHeight]], 1];        Display.Black[window,	  [[x: 0, y: y + h + bdryMargin - bdryLineWidth/2],	    [w: bdryBarWidth, h: bdryLineWidth]]];      ENDLOOP};  UnusedLogName: PUBLIC PROC [unused, root: LONG STRING] = {    same: BOOLEAN ¬ FALSE;    saveLen: CARDINAL;    number: INTEGER ¬ 0;    Used: FileSW.EnumerateProcType = {      RETURN[same ¬ String.EquivalentString[unused, name]]};    IF String.EmptyString[root] OR unused = NIL      OR unused.maxlength < root.length + 3 THEN      ERROR Tool.Error[invalidParameters];    unused.length ¬ 0;    String.AppendString[to: unused, from: root];    saveLen ¬ unused.length;    DO      FileSW.Enumerate[proc: Used];      IF ~same THEN EXIT;      unused.length ¬ saveLen;      String.AppendDecimal[s: unused, n: number ¬ number + 1];      ENDLOOP};  -- local procs  ComputeYs: PROC [boxes: ToolOps.BSHandle] = {    -- Assume that all heights are correct    boxes[0].y ¬ 0;    FOR i: CARDINAL IN [1..boxes.length) DO      boxes[i].y ¬ boxes[i - 1].y + boxes[i - 1].h + ToolOps.bdryHeight;      ENDLOOP};      Bdry: PROC [moveBdry: BOOLEAN, type: Tool.SWType] RETURNS [CARDINAL] = INLINE {    RETURN[      IF moveBdry AND type IN [ToolOps.fileSW..ToolOps.textSW] THEN      2*ToolOps.bdryMargin ELSE 0]};  InvalidateBoundaryBelow: PROC [clip: Window.Handle, box: Window.Box] = {    clip.InvalidateBox[[      [x: box.place.x, y: box.place.y + box.dims.h],      [w: box.dims.w, h: ToolOps.bdryHeight]], isDirty]};  LocalFind: PROC [window: Window.Handle] RETURNS [tch: ToolOps.ContextHandle] = {    tch ¬ Context.Find[ToolOps.context, window];    IF tch = NIL THEN Tool.Error[notATool]};  UseSWHeight: PROC [sw: Window.Handle, type: Tool.SWType, addBrdy: BOOLEAN]    RETURNS [INTEGER] = { -- minimum height for different subwindows    fontHeight: INTEGER = WindowFont.FontHeight[];    RETURN[      SELECT type FROM	ToolOps.formSW => FormSW.NeededHeight[sw].min, 	-- boundary height not subtracted by Flush	ToolOps.fileSW, ToolOps.ttySW => 4*fontHeight + Bdry[addBrdy, type],	ToolOps.msgSW, ToolOps.stringSW => fontHeight + Bdry[addBrdy, type],        ENDCASE => 2*fontHeight + Bdry[addBrdy, type]]};  -- Mainline code  ToolOps.InitMonitorData[];  END.  
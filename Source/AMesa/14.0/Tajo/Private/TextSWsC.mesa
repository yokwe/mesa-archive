-- File: TextSWsC.mesa - last edit:-- Riggle.PA           16-Sep-86 12:45:06-- Copyright (C) 1981, 1982, 1983, 1984 , 1986, 1986, 1986, 1986, 1986 by Xerox Corporation. All rights reserved. -- file: TextSWsC.mesa-- Wisk Window stuff in here-- Last Edited by: -- SXW   	 9-Jul-81 22:47:45-- JGS		28-Aug-81 15:12:49-- SXS   	18-Mar-82 15:44:54-- BGY     	30-Sep-82 21:01:41-- AXD    	25-Jan-83 23:34:16-- DWR    	21-Nov-84 13:19:47DIRECTORY  Ascii USING [SP, TAB],  Context USING [Create, Destroy, Find, Type, UniqueType],  Cursor USING [Fetch, Object, Set, Store],  Display USING [Brick, Gray, Invert, White],  Environment: TYPE USING [Block],  Keys USING [KeyName],  Heap USING [systemZone],  Inline USING [DIVMOD],  Menu USING [MCRType],  ProfileExtra USING [setPositionBalanceBeamChoice],  Selection USING [Convert, LongNumber, Source],  String USING [AppendString, FreeString, InvalidNumber, Length, MakeString],  TEdit: TYPE USING [CancelMultiClick, place, state],  TextData USING [InsertionObject, SelectionObject],  TextDisplay USING [    AlterBoxHeight, AlterBoxY, Create, Destroy, ExtendPositionInterval, Handle,    LineFromY, noPlace, Position, PositionIsVisible,    SetPosition],  TextDisplayExtra USING [SetPositionWithOverRide],  TextSink: TYPE USING [FontInfo],  TextSource USING [    Handle, nullPosition, Position, ReadText, ScanText, SearchFailed],  TextSourceExtra USING [AsciiTextSearchExtra],  TextSW USING [GetOptions, Options, SetOptions, SetSelection, SplitInfoProcType],  TextSWOps,  TextSWOpsExtra USING [],  TIP: TYPE,  ToolWindow USING [DrawRectangle],  UserInput USING [WaitForConfirmation, WaitNoButtons],  UserTerminal USING [BlinkDisplay],  Window USING [    BitmapPlaceToWindowAndPlace, Box, GetBox, Handle, InvalidateBox,    Place, Validate];TextSWsC: MONITOR LOCKS TextSWOps.lock  IMPORTS    Context, Cursor, Display, Selection, Heap, Inline, ProfileExtra, String, TEdit,    TextDisplay, TextDisplayExtra, TextSink, TextSource, TextSourceExtra,    TextSW, TextSWOps, TIP,    ToolWindow, UserInput, UserTerminal, Window  EXPORTS TextSW, TextSWOps, TextSWOpsExtra =  BEGIN OPEN TextSWOps;  fudge: INTEGER = 13;  z: UNCOUNTED ZONE = Heap.systemZone;    VetoProcType: TYPE = PROC [tsw: TextSWOps.TSWContext, p: TextDisplay.Handle]    RETURNS [pos: TextDisplay.Position, veto: BOOLEAN];  -- Split Window Procedures  DeleteSplit: PUBLIC PROC [tsw: TSWContext, where: CARDINAL]    RETURNS [deleted: TextDisplay.Handle] = {    IF where >= tsw.splits.length THEN ERROR;    deleted ¬ TextDisplay.Destroy[tsw.splits[where]];    FOR i: CARDINAL IN [where..tsw.splits.length-1) DO      tsw.splits[i] ¬ tsw.splits[SUCC[i]]; ENDLOOP;    tsw.splits ¬ NewSplitsObject[tsw.splits, PRED[tsw.splits.length], TRUE]};  EnumerateSplits: PUBLIC PROC [    sw: Window.Handle, proc: TextSW.SplitInfoProcType] = {    tsw: TSWContext = Context.Find[textSWContext, sw];    IF tsw # NIL AND tsw.options.split THEN      FOR i: CARDINAL IN [0..tsw.splits.length) DO        OPEN lt: tsw.splits[i].lineTable;        IF proc[	  first: lt.firstPosition, last: lt.lastPositionPlusOne - 1,	  nLines: lt.length] THEN EXIT;	ENDLOOP};      FindSplitBoundary: PROC [tsw: TSWContext, y: INTEGER]    RETURNS [split: CARDINAL] = {    -- splits are numbered [1..n]    FOR i: CARDINAL IN [0..tsw.splits.length) DO      IF tsw.splits[i].box.place.y >= y THEN RETURN[i]; ENDLOOP;    RETURN[tsw.splits.length]};  InsertSplit: PUBLIC PROC [    splits: Splits, p: TextDisplay.Handle, where: CARDINAL] = {    IF where >= splits.length THEN ERROR;    IF where # splits.length - 1 THEN      FOR i: CARDINAL DECREASING IN [0..splits.length - 1) DO        splits[SUCC[i]] ¬ splits[i]; IF i = where THEN EXIT; ENDLOOP;    splits[where] ¬ p};  MarkSplitBoundary: PUBLIC PROC [    tsw: TSWContext, split: CARDINAL, clear: BOOLEAN ¬ FALSE] = {    IF split > 0 THEN {      width: INTEGER = tsw.sw.GetBox.dims.w;      p: TextDisplay.Handle = tsw.splits[split - 1];      place: Window.Place = [0, p.box.place.y + p.box.dims.h];      Display.White[tsw.sw, [place, [width, boundarySize]]];      IF ~clear THEN {        gray: ARRAY [0..1) OF CARDINAL ¬ [174370B];	Display.Gray[          window: tsw.sw, box: [[place.x, place.y + boundarySize/2],	  [width - fudge, 1]], gray: DESCRIPTOR[gray]];        ToolWindow.DrawRectangle[          tsw.sw, [[width - fudge, place.y], [boundarySize, boundarySize]], 1]}}};    -- Moving splits  moveSplitContext: Context.Type = Context.UniqueType[];  MoveSplitRec: TYPE = RECORD [    split: CARDINAL ¬ 0,    lastY, maxY, minY: INTEGER ¬ 0];    DestroyMSC: PROC [msc: LONG POINTER TO MoveSplitRec, sw: Window.Handle] = {    z.FREE[@msc]};      StartMoveSplit: PUBLIC ENTRY PROC [tsw: TSWContext] = {    ENABLE UNWIND => NULL;    topP, bottomP: TextDisplay.Handle;    msc: LONG POINTER TO MoveSplitRec;    IF tsw = NIL THEN RETURN;    TEdit.state.inSel ¬ none;    Context.Create[      moveSplitContext, msc ¬ z.NEW[MoveSplitRec ¬ []], DestroyMSC, tsw.sw];    msc.split ¬ FindSplitBoundary[tsw, TEdit.place.y];    IF msc.split = tsw.splits.length THEN msc.split ¬ PRED[msc.split];    IF msc.split = 0 OR      TEdit.place.x - (tsw.sw.GetBox.dims.w - fudge) NOT IN [0..boundarySize]      THEN {Context.Destroy[moveSplitContext, tsw.sw]; RETURN};    TIP.NewManager[tsw.sw, TIP.mouseTIP, TIP.GetNotifyProc[tsw.sw]];    RealActOnCaret[tsw, clear];    tsw.insertion.place ¬ TextDisplay.noPlace;    topP ¬ tsw.splits[PRED[msc.split]];    bottomP ¬ tsw.splits[msc.split];    msc.lastY ¬ MAX[msc.minY ¬ topP.box.place.y,       MIN[TEdit.place.y, msc.maxY ¬ bottomP.box.place.y + bottomP.box.dims.h]];    MarkSplitBoundary[tsw, msc.split, TRUE];    Display.Invert[tsw.sw, [[0, msc.lastY], [tsw.sw.GetBox.dims.w, 1]]]};    MoveSplitBoundary: PUBLIC ENTRY PROC [tsw: TSWContext] = {    ENABLE UNWIND => NULL;    width: INTEGER = tsw.sw.GetBox.dims.w;    msc: LONG POINTER TO MoveSplitRec = Context.Find[moveSplitContext, tsw.sw];    newY: INTEGER;    IF msc = NIL THEN RETURN;    newY ¬ MAX[msc.minY, MIN[TEdit.place.y, msc.maxY]];    IF newY # msc.lastY THEN {      Display.Invert[tsw.sw, [[0, msc.lastY], [width, 1]]];      Display.Invert[tsw.sw, [[0, newY], [width, 1]]];      msc.lastY ¬ newY}};      FinishMoveSplit: PUBLIC ENTRY PROC [tsw: TSWContext] = {    ENABLE UNWIND => NULL;    msc: LONG POINTER TO MoveSplitRec = Context.Find[moveSplitContext, tsw.sw];    topP, bottomP: TextDisplay.Handle;    newY, deltaH: INTEGER;    delete: BOOLEAN;    IF msc = NIL THEN RETURN;    Display.Invert[tsw.sw, [[0, msc.lastY], [tsw.sw.GetBox.dims.w, 1]]];    topP ¬ tsw.splits[PRED[msc.split]];    bottomP ¬ tsw.splits[msc.split];    newY ¬ MAX[topP.box.place.y,      MIN[TEdit.place.y, bottomP.box.place.y + bottomP.box.dims.h]];    delete ¬ newY = topP.box.place.y      OR newY = bottomP.box.place.y + bottomP.box.dims.h;    deltaH ¬ (bottomP.box.place.y - halfBoundarySize) - newY;    IF deltaH > 0 THEN { -- bottom getting bigger      IF delete THEN {        [] ¬ DeleteSplit[tsw, PRED[msc.split]]; deltaH ¬ deltaH + halfBoundarySize}      ELSE TextDisplay.AlterBoxHeight[        topP, topP.box.dims.h - deltaH, @tsw.selection];      TextDisplay.AlterBoxY[bottomP, bottomP.box.place.y - deltaH];      TextDisplay.AlterBoxHeight[        bottomP, bottomP.box.dims.h + deltaH, @tsw.selection]}    ELSE {      IF delete THEN {        [] ¬ DeleteSplit[tsw, msc.split]; deltaH ¬ deltaH - halfBoundarySize}      ELSE {        TextDisplay.AlterBoxHeight[          bottomP, bottomP.box.dims.h + deltaH, @tsw.selection];        TextDisplay.AlterBoxY[bottomP, bottomP.box.place.y - deltaH]};      TextDisplay.AlterBoxHeight[        topP, topP.box.dims.h - deltaH, @tsw.selection]};    IF ~delete THEN MarkSplitBoundary[tsw, msc.split, FALSE];    Context.Destroy[moveSplitContext, tsw.sw];    InternalValidate[tsw.sw];    TIP.NewManager[NIL, NIL]};  NewSplitsObject: PUBLIC PROC [old: Splits, n: CARDINAL, copy: BOOLEAN]    RETURNS [new: Splits] = {    new ¬ Heap.systemZone.NEW[SplitsObject [n]];    FOR i: CARDINAL IN [0..n) DO      new[i] ¬ IF copy AND i < old.length THEN old[i] ELSE NIL;      ENDLOOP;    IF old # NIL THEN Heap.systemZone.FREE[@old]};  PToUse: PUBLIC PROC [tsw: TSWContext, y: INTEGER, nilOK: BOOLEAN]    RETURNS [TextDisplay.Handle] = {    boxY: INTEGER;    delta: INTEGER = IF nilOK THEN 0 ELSE boundarySize;    IF y <= tsw.splits[0].box.place.y THEN       RETURN[IF nilOK THEN NIL ELSE tsw.splits[0]];    IF y >=      tsw.splits[PRED[tsw.splits.length]].box.place.y + tsw.splits[        PRED[tsw.splits.length]].box.dims.h THEN      RETURN[IF nilOK THEN NIL ELSE tsw.splits[PRED[tsw.splits.length]]];    FOR i: CARDINAL IN [0..tsw.splits.length) DO      boxY ¬ tsw.splits[i].box.place.y;      IF y >= boxY AND y <= boxY + tsw.splits[i].box.dims.h + delta        THEN RETURN[tsw.splits[i]];      ENDLOOP;    IF ~nilOK THEN ERROR;    RETURN[NIL]};  Split: PUBLIC ENTRY PROC [tsw: TSWContext, y: INTEGER] = {    ENABLE UNWIND => NULL;    pToSplit: TextDisplay.Handle = PToUse[tsw, y, FALSE];    topPos: TextDisplay.Position ¬ pToSplit.lineTable[      TextDisplay.LineFromY[pToSplit, y]].pos;    minH, alterH, newH: INTEGER;    minH ¬ pToSplit.sink.FontInfo.lineHeight + boundarySize;    alterH ¬ (y - pToSplit.box.place.y) - halfBoundarySize;    newH ¬ (pToSplit.box.place.y + pToSplit.box.dims.h - y) - halfBoundarySize;    IF newH >= minH AND alterH >= minH THEN {      where: CARDINAL = FindSplitBoundary[tsw, y];      newP: TextDisplay.Handle;      RealActOnCaret[tsw, clear];      tsw.splits ¬ NewSplitsObject[tsw.splits, SUCC[tsw.splits.length], TRUE];      TextDisplay.AlterBoxHeight[pToSplit, alterH, @tsw.selection];      newP ¬ TextDisplay.Create[tsw.sw, pToSplit.source, pToSplit.sink];      newP.options ¬ pToSplit.options;      newP.options.margin ¬ 0;      newP.box ¬ [        [pToSplit.box.place.x, y + halfBoundarySize], [pToSplit.box.dims.w, newH]];      newP.lineTable.array[0].pos ¬        IF topPos # TextSource.nullPosition THEN topPos        ELSE pToSplit.lineTable.lastPositionPlusOne;      InsertSplit[tsw.splits, newP, where];      MarkSplitBoundary[tsw, where, FALSE];      Window.InvalidateBox[tsw.sw, newP.box, isDirty];      tsw.insertion.place ¬ TextDisplay.noPlace}};  SplitView: PUBLIC PROC [sw: Window.Handle, key: Keys.KeyName, y: INTEGER] = {    tsw: TSWContext = Context.Find[textSWContext, sw];    IF tsw # NIL AND tsw.options.split THEN {      TEdit.place ¬ [TIP.GetPlace[sw].x, y];      Split[tsw, y];      sw.Validate;      StartMoveSplit[tsw]}};  -- MCR's and etc.    SetPlaceForMCR: PROC [window: Window.Handle] = INLINE {    TEdit.place ¬ TIP.GetPlace[window]};      FindMCR: PUBLIC Menu.MCRType = {    tsw: TSWContext = Context.Find[textSWContext, window];    TEdit.CancelMultiClick;    SetPlaceForMCR[window];    IF tsw = NIL THEN UserTerminal.BlinkDisplay[]    ELSE SearchForSelection[tsw, TIP.GetPlace[window], FALSE]};    SearchForSelection: PUBLIC PROC [    tsw: TSWContext, place: Window.Place, backward: BOOLEAN] = {    str: LONG STRING ¬ Selection.Convert[string];    swWithSelection: Window.Handle = Selection.Convert[subwindow];    foundIt: BOOLEAN ¬ FALSE;    left: TextDisplay.Position;    LockedSearch: ENTRY PROC = BEGIN      ENABLE UNWIND => NULL;      p: TextDisplay.Handle = PToUse[tsw, place.y, FALSE];      position: TextDisplay.Position ¬ IF tsw.sw # swWithSelection        OR ~TextDisplay.PositionIsVisible[p, tsw.selection.right] THEN	  IF backward THEN p.lineTable.lastPositionPlusOne ELSE p.lineTable[0].pos	ELSE	  IF backward THEN tsw.selection.left ELSE tsw.selection.right;      [ ---- , left] ¬ TextSourceExtra.AsciiTextSearchExtra[        p.source, str, position, IF backward THEN 0 ELSE p.source.getLength[p.source], , IF backward THEN left ELSE right !	TextSource.SearchFailed => GOTO noGood];      foundIt ¬ TRUE;      IF ~TextDisplay.PositionIsVisible[p, left] THEN {	RealActOnCaret[tsw, clear];	TextDisplay.SetPosition[p, left, @tsw.selection];	tsw.insertion.place ¬ TextDisplay.noPlace;      };    EXITS noGood => NULL    END;    -- wouldn't it be nice if we had a routine that took two sources and searched for [pos..end) from    -- one source in the other?    IF str = NIL THEN { -- string longer than 200 chars      length: LONG POINTER TO LONG CARDINAL;      length ¬ Selection.Convert[length];      IF length # NIL AND length­ IN (0..LAST[CARDINAL]) THEN {        buf: LONG STRING ¬ [200];        source: Selection.Source ¬ Selection.Convert[source];	IF source # NIL THEN {	  str ¬ String.MakeString[z, CARDINAL[length­]];	  DO	    source.proc[source.data, buf];	    IF String.Length[buf] = 0 THEN EXIT;	    String.AppendString[from: buf, to: str];	  ENDLOOP;	  source.destroy[source];	};      };    };    IF String.Length[str] # 0 THEN LockedSearch[];    IF foundIt THEN TextSW.SetSelection[tsw.sw, left, left + str.length]    ELSE UserTerminal.BlinkDisplay[];    String.FreeString[z, str]};  JumpTopMCR: PUBLIC Menu.MCRType = {    Veto: VetoProcType = {pos ¬ 0; veto ¬ 0 = p.source.getLength[p.source]};    TEdit.CancelMultiClick;    SetPlaceForMCR[window];    IF ~EntryCallSetPosition[window, Veto] THEN UserTerminal.BlinkDisplay[]};  JumpEndMCR: PUBLIC Menu.MCRType = { -- force SetPosition to use middle mode    Veto: VetoProcType = {      pos ¬ p.source.getLength[p.source]; veto ¬ pos = 0; pos ¬ pos - 1};    TEdit.CancelMultiClick;    SetPlaceForMCR[window];    IF ~EntryCallSetPosition[window, Veto, TRUE] THEN UserTerminal.BlinkDisplay[]};  JumpInsertionMCR: PUBLIC Menu.MCRType = {    Veto: VetoProcType = {pos ¬ tsw.insertion.position; veto ¬ FALSE};    TEdit.CancelMultiClick;    SetPlaceForMCR[window];    IF ~EntryCallSetPosition[window, Veto] THEN UserTerminal.BlinkDisplay[]};  JumpSelectionMCR: PUBLIC Menu.MCRType = {    swWithSelection: Window.Handle = Selection.Convert[subwindow];    Veto: VetoProcType = {pos ¬ tsw.selection.left; veto ¬ FALSE};    TEdit.CancelMultiClick;    SetPlaceForMCR[window];    IF swWithSelection # window OR ~EntryCallSetPosition[window, Veto] THEN      UserTerminal.BlinkDisplay[]};  PositionMCR: PUBLIC Menu.MCRType = {    sw: Window.Handle;    position: TextDisplay.Position;    Veto: VetoProcType = {      sw ¬ tsw.sw;      pos ¬ position;      veto ¬ pos >= p.source.getLength[p.source]};    TEdit.CancelMultiClick;    position ¬ Selection.LongNumber[ ! String.InvalidNumber => GOTO noGood];    SetPlaceForMCR[window];    IF ~EntryCallSetPosition[window, Veto] THEN GOTO noGood;    TextSW.SetSelection[sw, position, position + 1]    EXITS noGood => UserTerminal.BlinkDisplay[]};  SplitMCR: PUBLIC Menu.MCRType = {    tsw: TSWContext = Context.Find[textSWContext, window];    TEdit.CancelMultiClick;    IF tsw # NIL AND tsw.options.split THEN {      okay: BOOLEAN;      cursor: Cursor.Object;      place: Window.Place;      Cursor.Fetch[@cursor];      Cursor.Set[mouseRed];      [place, okay] ¬ UserInput.WaitForConfirmation[];      IF okay THEN {        Cursor.Set[bullseye];        place ¬ Window.BitmapPlaceToWindowAndPlace[place].place;        SplitView[window, Point, place.y]};      Cursor.Store[@cursor];      UserInput.WaitNoButtons[]}    ELSE UserTerminal.BlinkDisplay[]};  WrapMCR: PUBLIC Menu.MCRType = {    tsw: TSWContext = Context.Find[textSWContext, window];    TEdit.CancelMultiClick;    IF tsw # NIL THEN {      options: TextSW.Options ¬ TextSW.GetOptions[window];      options.wrap ¬ ~options.wrap;      TextSW.SetOptions[window, options]}};  -- Position  PositionToLine: PUBLIC PROC [    sw: Window.Handle, position: TextDisplay.Position] = {    tsw: TSWContext = Context.Find[textSWContext, sw];    IF tsw # NIL THEN      RealPositionToLine[tsw, tsw.splits[0], position]};  RealPositionToLine: PROC [    tsw: TSWContext, p: TextDisplay.Handle, position: TextDisplay.Position] = {    RealActOnCaret[tsw, clear];    [position, ] ¬ TextDisplay.ExtendPositionInterval[p, position, position, line];    TextDisplay.SetPosition[p, position, @tsw.selection];    tsw.insertion.place ¬ TextDisplay.noPlace};  EntryCallSetPosition: ENTRY PROC [window: Window.Handle, vetoProc: VetoProcType, middle: BOOLEAN ¬ FALSE]    RETURNS [BOOLEAN] = {    ENABLE UNWIND => NULL;    tsw: TSWContext = Context.Find[textSWContext, window];    position: TextDisplay.Position;    veto: BOOLEAN;    IF tsw = NIL THEN RETURN[FALSE]    ELSE {      p: TextDisplay.Handle = PToUse[tsw, TEdit.place.y, FALSE];      [position, veto] ¬ vetoProc[tsw, p];      IF veto THEN RETURN[FALSE]      ELSE {        RealActOnCaret[tsw, clear];        TextDisplayExtra.SetPositionWithOverRide[p, position, @tsw.selection,	   IF middle THEN middle ELSE	     SELECT ProfileExtra.setPositionBalanceBeamChoice FROM	       topBottom => top,	       top => top,	     ENDCASE => middle];        tsw.insertion.place ¬ TextDisplay.noPlace;        RETURN[TRUE]}}};    -- Random Utilities    AppendWhiteSpace: PUBLIC PROC [s: LONG STRING, count: CARDINAL] = {    oldLength: CARDINAL = s.length;    countDiv8, countMod8: CARDINAL;    [countDiv8, countMod8] ¬ Inline.DIVMOD[count, 8];    IF (s.length ¬ oldLength + countMod8 + countDiv8) > s.maxlength THEN {      countDiv8 ¬ s.maxlength-oldLength-countMod8; s.length ¬ s.maxlength};    FOR j: CARDINAL IN [oldLength..oldLength+countDiv8) DO s[j] ¬ '\t ENDLOOP;    FOR j: CARDINAL IN [oldLength+countDiv8..s.length) DO s[j] ¬ '  ENDLOOP};      BlankCount: PUBLIC PROC [    tsw: TextSWOps.TSWContext, p: TextDisplay.Handle,     insert, pos: TextSource.Position] RETURNS [count: CARDINAL] = {    RETURN [NewBlankCount[p.source, insert, pos]]};    «    line: CARDINAL ¬ p.PlaceFromPosition[pos, FALSE].line;    count ¬ 0;    IF line < p.lineTable.length THEN {      lookingForCR: BOOLEAN;      Block: Environment.Block;      ss: POINTER TO RECORD [        base: LONG POINTER TO PACKED ARRAY CARDINAL OF CHARACTER,        offset, end: CARDINAL] = LOOPHOLE[@Block];      newPos: TextSource.Position;      -- Find the preceding CR (unless on first line)      DO	pos ¬ p.lineTable[line].pos;	IF lookingForCR ¬ (pos > 0) THEN pos ¬ pos - 1;	[Block, newPos] ¬ p.source.ReadText[pos, 50, none];	IF ss.end - ss.offset = 0 THEN RETURN;	IF lookingForCR THEN	  IF ss.base[ss.offset] = '\n THEN {	    pos ¬ pos + 1; ss.offset ¬ ss.offset + 1}	  ELSE IF line = 0 THEN RETURN ELSE {line ¬ line - 1; LOOP};	EXIT;	ENDLOOP;      -- Now count the whitespace (possibly stopping short at insert)      DO        SELECT insert FROM	  TextSource.nullPosition => NULL;	  < pos => NULL;	  pos => GOTO NonWhiteSpaceSeen;	  < pos + (ss.end - ss.offset) => 	    ss.end ¬ Inline.LowHalf[insert-pos] + ss.offset;	  ENDCASE;	FOR i: CARDINAL IN [ss.offset..ss.end) DO	  -- this needs to use the tab stops in the sink!	  SELECT ss.base[i] FROM	    '\t => count ¬ count + 8 - (count MOD 8);	    '  => count ¬ count + 1;	    ENDCASE => GOTO NonWhiteSpaceSeen;	  ENDLOOP;	[Block, newPos] ¬ p.source.ReadText[(pos ¬ newPos), 50, none];      	IF (ss.end - ss.offset) = 0 THEN GOTO NonWhiteSpaceSeen;	ENDLOOP;      EXITS NonWhiteSpaceSeen => NULL}};  --gag-- »  -- Extended versions of BlankCount[]    « Finds the start of a line before pos using TextSources.ScanText[] and returns the number of virtual spaces on that line. »    NewBlankCount: PUBLIC PROC [source: TextSource.Handle, insert, pos: TextSource.Position] RETURNS [count: CARDINAL] = {    left: TextSource.Position ¬ source.ScanText[pos, line, left];    RETURN [VirtualSpaces[source, left, insert]]  };  « appends the white space found at the source position firstCharOnLine onto the string whiteSpace.  Spaces are converted to TABs if possible.  The string whiteSpace better be big enough. If no white space (Ascii.SPs or Ascii.TABs) begins the line, then whiteSpace.length will be unchanged. »  SnarfWhiteSpace: PUBLIC PROC [source: TextSource.Handle, whiteSpace: LONG STRING, firstCharOnLine: TextSource.Position, insert: TextSource.Position ¬ TextSource.nullPosition] = BEGIN    AppendWhiteSpace[whiteSpace, VirtualSpaces[source, firstCharOnLine, insert]];  END;    « Counts the number of spaces that begin the line.  TABs are considered to be (8 - column MOD 8) spaces, where column is the character position that the TAB occurs at.  If you want to count blanks for autoIndent, and If you happen to be hitting a carriage return in the middle of a line of blanks, then you will want to stop counting virtual spaces at the insertion position.  If you want this feature, specify an insert position when you call the procedure.  »        VirtualSpaces: PUBLIC PROC [source: TextSource.Handle, firstCharOnLine: TextSource.Position, insert: TextSource.Position ¬ TextSource.nullPosition] RETURNS [count: CARDINAL ¬ 0] = BEGIN    block: Environment.Block;    array: LONG POINTER TO PACKED ARRAY OF CHARACTER;    currentPosition: TextSource.Position ¬ firstCharOnLine;    DO      [block, firstCharOnLine] ¬ source.ReadText[firstCharOnLine, 10, none];      IF block.startIndex = block.stopIndexPlusOne THEN GOTO done; -- at eof       array ¬ LOOPHOLE[block.blockPointer];      FOR i: CARDINAL IN [block.startIndex..block.stopIndexPlusOne) DO        IF currentPosition = insert THEN GOTO done;        SELECT array[i] FROM	  Ascii.SP => count ¬ count + 1;	  Ascii.TAB => count ¬ count + 8 - (count MOD 8);	ENDCASE => GOTO done;	currentPosition ¬ currentPosition + 1;      ENDLOOP;    ENDLOOP;  EXITS    done => NULL;  END;    END. -- of TextSWsC.mesaLOGDWR    	18-Oct-84 10:12:23  changed SearchForSelection & JumpEndDWR    	16-Nov-84 11:40:54  added SnarfWhiteSpace, e&.DWR    	20-Nov-84 17:23:59  Fixed the last bug in VirtualSpaces[]DWR    	21-Nov-84 13:19:21  Fixed the last bug in SnarfWhiteSpace[]
-- Copyright (C) 1981, 1982  by Xerox Corporation. All rights reserved. -- File: MenusA.mesa - last edit by:-- PXK    	 5-Nov-82 10:48:05-- SXW   	10-Jul-81 13:54:55-- SXE  	Aug 22, 1980 9:16 AM-- Mark		22-May-81 11:12:06-- SEH		 1-Oct-82 17:39:36DIRECTORY  Context USING [Create, Destroy, Find, Type, UniqueType],  Heap USING [systemZone],  Menu USING [ErrorCode, Handle, ItemObject, Items, MCRType, Object],  MenuOps USING [    FindRing, fontHeight, Instance, InstanceObject, menuContext, MenusB, mFont,    nameHeight, nilItemIndex, pm, Ring, RingObject, windowManagerMenu],  String USING [CopyToNewString],  TajoMisc USING [FindClippingWindow, GetWindowManagerMenu],  Window USING [GetParent, Handle, rootWindow],  WindowFont USING [defaultFont, FontHeight, Handle];MenusA: MONITOR LOCKS lock  IMPORTS Context, Heap, MenuOps, String, TajoMisc, Window, WindowFont  EXPORTS Menu, MenuOps =  BEGIN OPEN MenuOps;  lock: PUBLIC MONITORLOCK;  cv: PUBLIC CONDITION;  -- Errors  Error: PUBLIC ERROR [code: Menu.ErrorCode] = CODE;  -- Init/Finalize Procedures  Create: PUBLIC PROCEDURE [    items: Menu.Items, name: LONG STRING, permanent: BOOLEAN ¬ FALSE]    RETURNS [menu: Menu.Handle] =    BEGIN    ownName: LONG STRING = String.CopyToNewString[name, Heap.systemZone];    menu ¬ Heap.systemZone.NEW[Menu.Object];    menu­ ¬ [nInstances: 0, name: ownName, items: items, permanent: permanent];    RETURN[menu]    END;  Destroy: PUBLIC PROCEDURE [menu: Menu.Handle] =    BEGIN    IF menu.nInstances # 0 THEN ERROR Error[isInstantiated];    IF menu.permanent THEN ERROR Error[isPermanent];    Heap.systemZone.FREE[@menu.name];    Heap.systemZone.FREE[@menu];    END;  DestroyMenuContext: PROCEDURE [ring: Ring, window: Window.Handle] =    BEGIN    -- not ENTRY since either Unistantiate or Notifier (indirectly) is calling    inst, next: Instance;    inst ¬ ring.first;    DO      inst.menu.nInstances ¬ inst.menu.nInstances - 1;      next ¬ inst.link;      Heap.systemZone.FREE[@inst];      IF (inst ¬ next) = ring.first THEN EXIT;      ENDLOOP;    Heap.systemZone.FREE[@ring];    RETURN    END;  Instantiate: PUBLIC ENTRY PROCEDURE [menu: Menu.Handle, window: Window.Handle] =    BEGIN    ENABLE UNWIND => NULL;    WHILE MenuOps.pm # NIL DO WAIT cv ENDLOOP;    {    clipping: Window.Handle = TajoMisc.FindClippingWindow[window];    ring: Ring ¬ FindRing[clipping];    last, new: Instance;    onlyMenu: BOOLEAN ¬ FALSE;    IF ring = NIL THEN      BEGIN      ring ¬ Heap.systemZone.NEW[RingObject];      ring­ ¬ [NIL, nilItemIndex];      Context.Create[menuContext, ring, DestroyMenuContext, clipping];      END;    IF (new ¬ ring.first) = NIL THEN      IF window # Window.rootWindow THEN        BEGIN  -- make the Window Manger instance        ring.first ¬ new ¬ Heap.systemZone.NEW[InstanceObject];        ring.lastIndex ¬ nilItemIndex;        new­ ¬ [link: new, menu: windowManagerMenu, window: clipping];  -- instantiated with whole window        new.menu.nInstances ¬ new.menu.nInstances + 1;        END      ELSE onlyMenu ¬ TRUE;    IF menu = NIL THEN RETURN;  -- just Window Manager    IF ~onlyMenu THEN      DO  -- make sure not already instantiated        IF new.menu = menu AND new.window = window THEN          ERROR Error[alreadyInstantiated];        last ¬ new;        IF (new ¬ new.link) = ring.first THEN EXIT;        ENDLOOP;    new ¬ Heap.systemZone.NEW[InstanceObject];    IF onlyMenu THEN      BEGIN new­ ¬ [link: new, menu: menu, window: window]; ring.first ¬ new; END    ELSE      BEGIN      new­ ¬ [link: ring.first, menu: menu, window: window];      ring.first ¬ last.link ¬ new;      END;    ring.lastIndex ¬ nilItemIndex;    menu.nInstances ¬ menu.nInstances + 1;    };    END;  FreeItem: PUBLIC PROCEDURE [item: Menu.ItemObject] = {    Heap.systemZone.FREE[@item.keyword]};  MakeItem: PUBLIC PROCEDURE [keyword: LONG STRING, mcrProc: Menu.MCRType]    RETURNS [Menu.ItemObject] =    BEGIN RETURN[[String.CopyToNewString[keyword, Heap.systemZone], mcrProc]] END;  Make: PUBLIC PROCEDURE [    name: LONG STRING, strings: LONG DESCRIPTOR FOR ARRAY OF LONG STRING,    mcrProc: Menu.MCRType, copyStrings: BOOLEAN ¬ TRUE, permanent: BOOLEAN ¬ FALSE]    RETURNS [Menu.Handle] =    BEGIN    items: CARDINAL = LENGTH[strings];    array: Menu.Items = DESCRIPTOR[      MakeNode[Heap.systemZone, SIZE[Menu.ItemObject]*items], items];    i: CARDINAL;    FOR i IN [0..items) DO      IF copyStrings THEN array[i] ¬ MakeItem[strings[i], mcrProc]      ELSE array[i] ¬ [strings[i], mcrProc];      ENDLOOP;    RETURN[Create[array, name, permanent]]    END;  Free: PUBLIC PROCEDURE [menu: Menu.Handle, freeStrings: BOOLEAN ¬ TRUE] =    BEGIN    i: CARDINAL;    IF menu = NIL THEN RETURN;    IF freeStrings THEN      FOR i IN [0..LENGTH[menu.items]) DO FreeItem[menu.items[i]] ENDLOOP;    {p: LONG POINTER ¬ BASE[menu.items]; Heap.systemZone.FREE[@p]};    Destroy[menu];    END;  Uninstantiate: PUBLIC ENTRY PROCEDURE [    menu: Menu.Handle, window: Window.Handle] =    BEGIN    ENABLE UNWIND => NULL;    WHILE MenuOps.pm # NIL DO WAIT cv ENDLOOP;    {    inst, first, prev: Instance;    clipping: Window.Handle = TajoMisc.FindClippingWindow[window];    ring: Ring = Context.Find[menuContext, clipping];    IF ring = NIL THEN ERROR Error[contextNotAvailable];    first ¬ ring.first;    IF first = NIL THEN ERROR Error[notInstantiated];    FOR prev ¬ first, inst DO      inst ¬ prev.link;      IF inst.menu = menu        AND (window = inst.window OR window = clipping OR window = clipping.GetParent[])        THEN EXIT;      IF inst = first THEN ERROR Error[notInstantiated];      ENDLOOP;    IF prev = inst THEN Context.Destroy[menuContext, clipping]    ELSE      BEGIN      IF first = inst THEN {ring.first ¬ inst.link; ring.lastIndex ¬ nilItemIndex};      prev.link ¬ inst.link;      Heap.systemZone.FREE[@inst];      menu.nInstances ¬ menu.nInstances - 1;      END;    };    END;  -- Font changing  GetFont: PUBLIC PROCEDURE RETURNS [font: WindowFont.Handle] = {RETURN[mFont]};  SetFont: PUBLIC PROCEDURE [font: WindowFont.Handle] =    BEGIN    mFont ¬ font;    fontHeight ¬ WindowFont.FontHeight[mFont];    nameHeight ¬ fontHeight + 1;    END;  MakeNode: PROCEDURE [z: UNCOUNTED ZONE, n: CARDINAL] RETURNS [LONG POINTER] =    BEGIN    T: TYPE = RECORD [SEQUENCE COMPUTED CARDINAL OF CARDINAL];    RETURN [z.NEW[T[n]]]    END;  -- MainlineCode  START MenusB;  menuContext ¬ Context.UniqueType[];  windowManagerMenu ¬ TajoMisc.GetWindowManagerMenu[];  END.
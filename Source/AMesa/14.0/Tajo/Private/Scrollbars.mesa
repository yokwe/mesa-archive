-- Copyright (C) 1981, 1982, 1984  by Xerox Corporation. All rights reserved. -- File: [Igor]<Emerson>Tajo>Private>Scrollbars.mesa - last edit by:-- PXK    	17-Jan-84 17:09:43-- SXW   	 9-Jul-81 18:24:28-- JGS		 8-Nov-82 13:39:29-- Mark		 1-Feb-81  4:58:41-- SEH		22-Sep-82 18:19:04-- AXD    	16-Dec-82 16:58:51-- DWR    	 9-Nov-84 16:29:16  added one line to ScrollSomeDIRECTORY  Atom USING [ATOM, MakeAtom],  Context USING [Create, Destroy, Find, Type, UniqueType],  Cursor USING [Defined, FetchFromType, Object, Set, Store, Type],  Display USING [Gray, White],  Heap USING [systemZone],  Inline USING [LongDiv, LongMult],  Keys USING [KeyBits, KeyName],  Scrollbar USING [    Direction, ErrorCode, Percent, ScrollbarProcType, ScrollProcType, Type],  ScrollbarOps USING [Client, ClientObject, Scroll, ScrollObject, Posted],  TIP USING [    CreateClient, CreateTable, First, InvalidTable, NotifyProc,    Rest, Results, SetNotifyProc, Table],  ToolWindow USING [    CreateSubwindow, DelinkSubwindow, Destroy, DisplayProcType,    EnlinkSubwindow, WindowForSubwindow],  UserTerminal USING [BlinkDisplay],  Window USING [    Box, Dims, GetBox, Handle, InvalidateBox, Place, SetDisplayProc, Validate];Scrollbars: MONITOR  IMPORTS    Atom, Context, Cursor, Display, Heap, Inline, TIP, ToolWindow, UserTerminal, Window  EXPORTS Scrollbar, ScrollbarOps =  BEGIN  -- SIGNALS and ERRORS  Error: PUBLIC ERROR [code: Scrollbar.ErrorCode] = CODE;  -- Globals and stuff    Box: TYPE = Window.Box;  KeyArray: TYPE = LONG POINTER TO Keys.KeyBits;  ScrollProc: TYPE = Scrollbar.ScrollProcType;  BarProc: TYPE = Scrollbar.ScrollbarProcType;  Direction: TYPE = Scrollbar.Direction;  Type: TYPE = Scrollbar.Type;  Client: TYPE = ScrollbarOps.Client;  Scroll: TYPE = ScrollbarOps.Scroll;   clientsType: Context.Type ¬ Context.UniqueType[];  scrollbarsType: Context.Type ¬ Context.UniqueType[];  width: CARDINAL = 9;  screenMax: INTEGER = 2000;    Button: TYPE = Keys.KeyName [Point..Menu];    -- posted scrollbar (only one at a time)    posted: PUBLIC ScrollbarOps.Posted ¬ [];    -- Procedures  Create: PUBLIC PROCEDURE [    window: Window.Handle, type: Type,    scroll: ScrollProc, scrollbar: BarProc, notify: ScrollProc] = {    client: Client ¬ Context.Find[clientsType, window];    scroller: Scroll;    scrollWindow: Window.Handle;    scrollBox: Window.Box ¬ window.GetBox[];    IF client = NIL THEN {      client ¬ Heap.systemZone.NEW[ScrollbarOps.ClientObject ¬ [window: window]];      Context.Create[clientsType, client, DestroyClient, window]};    IF client.scroll[type] # NIL THEN ERROR Error[alreadyExists];    SELECT type FROM      vertical => {        scrollBox.place.x ¬ scrollBox.place.x - width;	scrollBox.dims.w ¬ width};      horizontal => {        scrollBox.place.y ¬ scrollBox.place.y + scrollBox.dims.h;	scrollBox.dims.h ¬ width};      ENDCASE;    scrollWindow ¬ ToolWindow.CreateSubwindow[      parent: NIL, display: DisplayScrollWindow, box: scrollBox];    scroller ¬ Heap.systemZone.NEW[ScrollbarOps.ScrollObject ¬ [      type: type, client: client, window: scrollWindow,      barProc: scrollbar, scrollProc: scroll, notifyProc: notify]];    client.scroll[type] ¬ scroller;    Context.Create[scrollbarsType, scroller, DestroyScroll, scrollWindow];    ToolWindow.EnlinkSubwindow[      parent: ToolWindow.WindowForSubwindow[window],      youngerSibling: window,      child: scrollWindow];    TIP.CreateClient[scrollWindow, scrollTip, ScrollTIPNotify]};  Destroy: PUBLIC PROCEDURE [window: Window.Handle, type: Type] = {    client: Client = Context.Find[clientsType, window];    scrollWindow: Window.Handle;    MakeNotAScrollbarWindow: ENTRY PROC RETURNS [scrollW: Window.Handle] = {      ENABLE UNWIND => NULL;      scroll: Scroll;      IF client = NIL THEN RETURN[NIL];      IF (scroll ¬ client.scroll[type]) = NIL THEN RETURN[NIL];      scroll.client ¬ NIL;  -- break the back link if breaking the forward link      client.scroll[type] ¬ NIL;      IF client.scroll[vertical] = NIL AND client.scroll[horizontal] = NIL THEN        Context.Destroy[clientsType, window];      IF (scrollW ¬ scroll.window) # NIL THEN {	[] ¬ TIP.SetNotifyProc[scrollW, NIL];	[] ¬ scrollW.SetDisplayProc[NIL];	IF posted.scroll = scroll THEN posted ¬ []}};    IF (scrollWindow ¬ MakeNotAScrollbarWindow[]) # NIL THEN       ToolWindow.Destroy[scrollWindow]};  HasScrollbar: PUBLIC PROCEDURE [window: Window.Handle, type: Type]    RETURNS [BOOLEAN] = {    client: Client = Context.Find[clientsType, window];    RETURN[client # NIL AND client.scroll[type] # NIL]};  GetNotifier: PUBLIC PROCEDURE [window: Window.Handle, type: Type]    RETURNS [ScrollProc] = {    client: Client = Context.Find[clientsType, window];    IF client = NIL THEN ERROR Error[doesNotExist];    RETURN[client.scroll[type].notifyProc]};  SetNotifier: PUBLIC PROCEDURE [    window: Window.Handle, type: Type, notify: ScrollProc]    RETURNS [ScrollProc] = {    oldNotify: ScrollProc;    client: Client = Context.Find[clientsType, window];    IF client = NIL THEN ERROR Error[doesNotExist];    oldNotify ¬ client.scroll[type].notifyProc;    client.scroll[type].notifyProc ¬ notify;    RETURN[oldNotify]};  WindowNowDelinked: PUBLIC PROCEDURE [window: Window.Handle] = {    client: Client = Context.Find[clientsType, window];    IF client = NIL THEN RETURN;    IF client.scroll[vertical] # NIL THEN       ToolWindow.DelinkSubwindow[client.scroll[vertical].window];    IF client.scroll[horizontal] # NIL THEN       ToolWindow.DelinkSubwindow[client.scroll[horizontal].window]};    WindowNowEnlinked: PUBLIC PROCEDURE [window: Window.Handle] = {    client: Client = Context.Find[clientsType, window];    IF client = NIL THEN RETURN;    IF client.scroll[vertical] # NIL THEN       ToolWindow.EnlinkSubwindow[        parent: ToolWindow.WindowForSubwindow[window],	child: client.scroll[vertical].window,	youngerSibling: window];    IF client.scroll[horizontal] # NIL THEN       ToolWindow.EnlinkSubwindow[        parent: ToolWindow.WindowForSubwindow[window],	child: client.scroll[horizontal].window,	youngerSibling: window]};    Adjust: PUBLIC PROCEDURE [window: Window.Handle, box: Box] RETURNS [    clientBox: Box,    verticalWindow: Window.Handle, verticalBox: Box,    horizontalWindow: Window.Handle, horizontalBox: Box] = {    client: Client = Context.Find[clientsType, window];    clientBox ¬ box;    IF client = NIL THEN RETURN[clientBox, NIL, TRASH, NIL, TRASH];    IF client.scroll[vertical] # NIL THEN {      verticalWindow ¬ client.scroll[vertical].window;      clientBox.place.x ¬ clientBox.place.x + width;      clientBox.dims.w ¬ clientBox.dims.w - width}    ELSE verticalWindow ¬ NIL;    IF client.scroll[horizontal] # NIL THEN {      horizontalWindow ¬ client.scroll[horizontal].window;      clientBox.dims.h ¬ clientBox.dims.h - width}    ELSE horizontalWindow ¬ NIL;    IF verticalWindow # NIL THEN      verticalBox ¬ [box.place, [width, clientBox.dims.h]];     IF horizontalWindow # NIL THEN       horizontalBox ¬ [	place: [clientBox.place.x, clientBox.place.y + clientBox.dims.h],	dims: [clientBox.dims.w, width]]};  -- context destruction routines  DestroyClient: PROCEDURE [client: Client, window: Window.Handle] ={    IF client.scroll[vertical] # NIL THEN client.scroll[vertical].client ¬ NIL;    IF client.scroll[horizontal] # NIL THEN      client.scroll[horizontal].client ¬ NIL;    Heap.systemZone.FREE[@client]};  DestroyScroll: PROCEDURE [scroll: Scroll, scrollWindow: Window.Handle] ={    IF scroll.client # NIL THEN scroll.client.scroll[scroll.type] ¬ NIL;    Heap.systemZone.FREE[@scroll]};    -- Scrollbar Notification and Display routines  DisplayScrollWindow: ENTRY ToolWindow.DisplayProcType = {    ENABLE UNWIND => NULL;    twentyFivePercent: ARRAY [0..2) OF CARDINAL ¬ [104210B, 021042B];    seventyFivePercent: ARRAY [0..2) OF CARDINAL ¬ [156735B, 073567B];    type: Scrollbar.Type;    lineBox: Box;    isPosted: BOOLEAN = posted.scroll # NIL AND posted.scroll.window = window;    IF isPosted THEN type ¬ posted.type    ELSE {      scroll: Scroll = Context.Find[scrollbarsType, window];      IF scroll = NIL THEN RETURN;      type ¬ scroll.type};    lineBox ¬ SELECT type FROM      vertical =>   [[width - 1, 0], [1, screenMax]],      horizontal => [[0, 0], [screenMax, 1]],      ENDCASE => --EXHAUSTED-- ERROR;    Display.Gray[window, lineBox, DESCRIPTOR[twentyFivePercent]];    IF isPosted THEN {      Display.Gray[window, posted.grayBox, DESCRIPTOR[twentyFivePercent]];      Display.Gray[window, posted.darkBox, DESCRIPTOR[seventyFivePercent]]}};  Enter: PUBLIC ENTRY PROCEDURE [window: Window.Handle, keys: KeyArray] = {    ENABLE UNWIND => NULL;    posted.scroll ¬ Context.Find[scrollbarsType, window];    IF posted.scroll = NIL THEN RETURN;    posted.type ¬ posted.scroll.type;    SetBoxes[];    SetCursorAndDirection[keys];    Window.InvalidateBox[window, posted.grayBox]};  SetCursorAndDirection: PROCEDURE [keys: KeyArray] = {    dirs: ARRAY Button OF Direction = [      Point: forward, Menu: relative, Adjust: backward];    FOR key: Keys.KeyName IN Button WHILE keys # NIL DO      IF keys[key] = down THEN {        CursorSet[posted.dir ¬ dirs[key], posted.type]; EXIT};      REPEAT FINISHED => Cursor.Set[        IF posted.type = vertical THEN scrollUpDown ELSE scrollLeftRight];      ENDLOOP};   Exit: ENTRY PROCEDURE [window: Window.Handle] = {    ENABLE UNWIND => NULL;    Window.InvalidateBox[window, posted.grayBox, isDirty];    posted ¬ []};	  PercentOf: PROC [v: INTEGER, p: Scrollbar.Percent] RETURNS [INTEGER] = {    RETURN[Inline.LongDiv[Inline.LongMult[v, p] + 50, 100]]};  Percentage: PROC [part, full: INTEGER] RETURNS [Scrollbar.Percent] = {    RETURN[      SELECT TRUE FROM        full <= 0 => 0,	part <= 0 => 0,	part >= full => 100,	ENDCASE => Inline.LongDiv[Inline.LongMult[part, 100], full]]};  ScrollSome: ENTRY PROCEDURE [    window: Window.Handle, dir: Direction, place: Window.Place,    type: Type, keys: KeyArray] = {    ENABLE UNWIND => NULL;    distance: INTEGER ¬      IF type = vertical THEN place.y - posted.grayBox.place.y      ELSE place.x - posted.grayBox.place.x;    size: INTEGER =      IF type = vertical THEN posted.grayBox.dims.h ELSE posted.grayBox.dims.w;    percent: Scrollbar.Percent = Percentage[distance, size];    IF posted.scroll = NIL THEN RETURN;    posted.scroll.scrollProc[posted.scroll.client.window, dir, percent];    IF posted.scroll.notifyProc # NIL THEN      posted.scroll.notifyProc[posted.scroll.client.window, dir, percent];    Display.White[posted.scroll.window, posted.grayBox];    -- Invalidate before SetBoxes in case we have changed splits' scrollbars since posting.    Window.InvalidateBox[posted.scroll.window, posted.grayBox];    SetBoxes[];    Window.InvalidateBox[posted.scroll.window, posted.grayBox];    SetCursorAndDirection[keys]};      --  Utility Procedures  DarkRange: PROCEDURE [offset, portion, length: INTEGER]    RETURNS [start, end: INTEGER] = {    start ¬ PercentOf[length, offset];    end ¬ PercentOf[length, portion];    IF end < MIN[5, length] THEN end ¬ MIN[5, length];    IF start + end > length THEN start ¬ MAX[length - end, 0]};  SetBoxes: INTERNAL PROCEDURE = {    offset, portion: CARDINAL;    start, end: INTEGER;    clientBox: Box;    [clientBox, offset, portion] ¬      posted.scroll.barProc[posted.scroll.client.window];    -- protect self from bogus clients    IF offset ~IN[0..100] THEN offset ¬ 0;    IF portion ~IN[0..100] THEN portion ¬ 100 - offset;    SELECT posted.type FROM      vertical => {        posted.grayBox ¬ [          place: [0, clientBox.place.y], dims: [width, clientBox.dims.h]];        [start, end] ¬ DarkRange[offset, portion, posted.grayBox.dims.h];        posted.darkBox ¬ [          [x: 0, y: posted.grayBox.place.y + start], [w: width, h: end]]};       horizontal => {        posted.grayBox ¬ [          place: [clientBox.place.x, 0], dims: [clientBox.dims.w, width]];        [start, end] ¬ DarkRange[offset, portion, posted.grayBox.dims.w];        posted.darkBox ¬ [          [x: posted.grayBox.place.x + start, y: 0], [w: end, h: width]]};       ENDCASE};      ScrollTIPNotify: PUBLIC TIP.NotifyProc =    BEGIN    place: Window.Place;    keys: KeyArray ¬ NIL;    FOR input: TIP.Results ¬ results, input.Rest[] UNTIL input = NIL DO      WITH z: input.First[] SELECT FROM          keys => keys ¬ z.keys;          coords => place ¬ z.place;	  atom => SELECT z.a FROM	    enter => {Enter[window, keys]; Window.Validate[window]};	    exit => {Exit[window]; Window.Validate[window]};	    dirForward => CursorSet[posted.dir ¬ forward, posted.type];	    dirThumb => CursorSet[posted.dir ¬ relative, posted.type];	    dirBackward => CursorSet[posted.dir ¬ backward, posted.type];	    scroll => {	      ScrollSome[window, posted.dir, place, posted.type, keys];	      Window.Validate[window]};	    maybeScroll =>	      IF posted.dir = forward THEN {	        ScrollSome[window, posted.dir, place, posted.type, keys];	        Window.Validate[window]};	    ENDCASE;	  ENDCASE;	ENDLOOP;    END;    CursorSet: PUBLIC ENTRY PROC [dir: Direction, type: Type] = {    ENABLE UNWIND => NULL;    NewCursor: TYPE = RECORD [defined: Cursor.Defined, newHotSpot: BOOLEAN];    cursor: Cursor.Object;    cursors: ARRAY Type OF ARRAY Direction OF NewCursor = [      vertical: [        forward:  [scrollUp, TRUE],	relative: [pointLeft, FALSE],	backward: [scrollDown, TRUE] ],      horizontal: [        forward:  [scrollLeft, TRUE],	relative: [pointDown, FALSE],	backward: [scrollRight, TRUE] ]];    Cursor.FetchFromType[@cursor, cursors[type][dir].defined];    IF cursors[type][dir].newHotSpot THEN cursor.info ¬ [last, 7, 7];    Cursor.Store[@cursor]};    dirThumb, dirForward, dirBackward, scroll, maybeScroll, enter, exit: Atom.ATOM;  scrollTip: PUBLIC TIP.Table ¬ NIL;    InitTip: PROCEDURE = {    tipContents: STRING ¬"-- Scrollbar.TIP, created by System-- Version of 15-Dec-82 16:28:13[DEF,ChordTime,(200)][DEF,Chord,(SELECT TRIGGER FROM  ~1 Down BEFORE [ChordTime] => { COORDS ~2 };  ENDCASE => { COORDS ~3 })]SELECT TRIGGER FROM    MOUSE => COORDS, Track;    Adjust Up => COORDS, Scroll;  Point Up => COORDS, MaybeScroll;    Menu Up => COORDS, Scroll;  MENU Up => COORDS, Scroll;    Adjust Down => [Chord,Point,SetDirectionThumb,SetDirectionBackward];  Point Down => [Chord,Adjust,SetDirectionThumb,SetDirectionForward];  Menu Down  => COORDS, SetDirectionThumb;  MENU Down  => COORDS, SetDirectionThumb;  ENTER => SELECT ENABLE FROM    Point Down => SELECT ENABLE FROM      Adjust Down => Enter, SetDirectionThumb;      ENDCASE => Enter, SetDirectionForward;    MENU Down | Menu Down => Enter, SetDirectionThumb;    Adjust Down => Enter, SetDirectionBackward;    ENDCASE => Enter;        EXIT => Exit;    ENDCASE..."L;    firstTime: BOOLEAN ¬ TRUE;    scroll ¬ Atom.MakeAtom["Scroll"L];    maybeScroll ¬ Atom.MakeAtom["MaybeScroll"L];    dirThumb ¬ Atom.MakeAtom["SetDirectionThumb"L];    dirBackward ¬ Atom.MakeAtom["SetDirectionBackward"L];    dirForward ¬ Atom.MakeAtom["SetDirectionForward"L];    enter ¬ Atom.MakeAtom["Enter"L];    exit ¬ Atom.MakeAtom["Exit"L];    scrollTip ¬ TIP.CreateTable[file: "Scrollbar.TIP"L, contents: tipContents !      TIP.InvalidTable => IF type = badSyntax THEN {        UserTerminal.BlinkDisplay[];	IF firstTime THEN {firstTime ¬ FALSE; RESUME}}]};  -- main line code    InitTip[];         END.  -- of Scrollbars
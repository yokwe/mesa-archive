-- File: StartIncludedBcds.mesa - last edit:-- Riggle.PA           12-Aug-86 16:41:05-- Copyright (C) 1982, 1983 , 1986, 1986, 1986, 1986 by Xerox Corporation. All rights reserved. -- StartIncludedBcds.mesa  --   JGS	 2-Dec-82 12:31:50    --   RXJ     	13-Sep-83 20:12:32    DIRECTORY  BcdDefs USING [Base, BCD, CTIndex, CTNull, MTIndex, MTRecord],  FrameExtras USING [GFTHandleToLongGF, GlobalOverhead],  LoadState USING [GFFromBcdInfo, LockBcdInfo, LPBcdInfoTable, UnlockBcdInfo],  LoadStateFormat USING [Handle, Index],  Runtime USING [StartFault],  PrincOpsExtras2 USING [GlobalFrameBase, LongGlobalFrameHandle],  TajoMisc USING [];StartIncludedBcds: PROGRAM    IMPORTS FrameExtras, LoadState, Runtime EXPORTS TajoMisc = {  bcdPtr: TYPE = LONG BASE POINTER TO BcdDefs.BCD;  GFIFromMti: PROCEDURE [mti: BcdDefs.MTIndex] RETURNS [CARDINAL] = INLINE {    RETURN[LOOPHOLE[mti, CARDINAL]/BcdDefs.MTRecord.SIZE + 1]};  FindConfigGF: PROC [    index: LoadStateFormat.Index, bcd: bcdPtr, cti: BcdDefs.CTIndex]    RETURNS [gf: PrincOpsExtras2.LongGlobalFrameHandle] = {    ctb: BcdDefs.Base ¬ LOOPHOLE[bcd + bcd.ctOffset];    FOR i: CARDINAL IN [0..ctb[cti].nControls) DO      WITH c: ctb[cti].controls[i] SELECT FROM	module => RETURN[	  FrameExtras.GFTHandleToLongGF[LoadState.GFFromBcdInfo[bcdIndex: index, cgfi: GFIFromMti[c.mti]]]];	ENDCASE;      ENDLOOP;    FOR i: CARDINAL IN [0..ctb[cti].nControls) DO      WITH c: ctb[cti].controls[i] SELECT FROM	config =>	  IF (gf ¬ FindConfigGF[index, bcd, c.cti]) # NIL THEN RETURN;	ENDCASE;      ENDLOOP;    RETURN[NIL]};      FindControlGF: PROCEDURE [bcd: bcdPtr, index: LoadStateFormat.Index]    RETURNS [PrincOpsExtras2.LongGlobalFrameHandle] = {    ctb: BcdDefs.Base ¬ LOOPHOLE[bcd + bcd.ctOffset];    cti: BcdDefs.CTIndex ¬ FIRST[BcdDefs.CTIndex];    parent: BcdDefs.CTIndex;    IF bcd.nConfigs = 0 THEN RETURN[      FrameExtras.GFTHandleToLongGF[LoadState.GFFromBcdInfo[bcdIndex: index, cgfi: 1]]];    parent ¬ ctb[cti].config;    UNTIL parent = BcdDefs.CTNull DO      cti ¬ parent; parent ¬ ctb[cti].config; ENDLOOP;    RETURN[FindConfigGF[index, bcd, cti]]};      StartClient: PUBLIC PROC = {    gf: PrincOpsExtras2.LongGlobalFrameHandle;    loadState: LoadStateFormat.Handle;    bcdInfo: LoadState.LPBcdInfoTable;    FOR index: LoadStateFormat.Index ¬ 1, index.SUCC DO      gw: PrincOpsExtras2.GlobalFrameBase;      [loadState: loadState, bcdInfo: bcdInfo] ¬ LoadState.LockBcdInfo[];      IF index >= loadState.nBcds THEN {LoadState.UnlockBcdInfo[]; EXIT};      gf ¬ FindControlGF[bcdInfo[index].base, index !        UNWIND => LoadState.UnlockBcdInfo[]];      LoadState.UnlockBcdInfo[];      IF gf = NIL THEN LOOP;      gw ¬ FrameExtras.GlobalOverhead[gf];      IF ~gw.extra.started THEN        START LOOPHOLE[gf, PROGRAM][! Runtime.StartFault => CONTINUE];      ENDLOOP};        }.
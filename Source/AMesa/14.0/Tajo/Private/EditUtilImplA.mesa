-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved. -- EditUtilImplA.mesa-- last edit--  BGY     	21-Nov-83  9:26:17--  DWR    	14-Feb-85 15:04:23DIRECTORY  Ascii: TYPE USING [CR, TAB],  Context: TYPE USING [Find],  EditOps: TYPE USING [    AbortProc, AbortSearch, MakePat, Match, MatchList, nullPosition],  EditUtil: TYPE USING [    Confirmation, ConfirmType, DataHandle, prop, ScopeType, zone],  Environment: TYPE USING [Block, LongNumber],  Format: TYPE USING [StringProc],  FormSW: TYPE USING [    FindItem, GetSelection, GetTypeIn, ItemHandle, ModifyEditable, nullIndex,    SetSelection, SetTypeIn],  Inline: TYPE USING [LongNumber, LowHalf],  Process: TYPE USING [Detach],  Profile: TYPE USING [debugging],  Put: TYPE USING [CR, Line, LongNumber, Number, Text],  Selection: TYPE USING [ActOn, Convert],  String: TYPE USING [AppendChar, AppendString, Length, StringBoundsFault],  StringSource: TYPE USING [Create],  TextData: TYPE USING [InsertionObject, Position, Selection, SelectionObject],  TextDisplay: TYPE USING [    Handle, LineTable, MarkInsertion, MarkSelection, Position, Selection,    SetPosition, Update],  TextSource: TYPE USING [    Access, GetLength, Handle, nullPosition, Position, ReplaceText],  TextSW: TYPE USING [    Access, GetInsertion, GetOptions, GetPosition, GetSelection, GetSource,    InvalidRegions, ModifySource, Position, PositionIsVisible, ReplaceText,    SetInsertion, SetPosition, SetSelection],  TextSWOps: TYPE USING [lock, RealActOnCaret, textSWContext, TSWContext],  TIP: TYPE USING [NewManager],  UserInput: TYPE USING [UserAbort],  UserTerminal: TYPE USING [BlinkDisplay],  Window: TYPE USING [Handle];EditUtilImplA: MONITOR LOCKS TextSWOps.lock  IMPORTS     Context, FormSW, EditOps, EditUtil, Inline, Process, Profile, Put,     String, StringSource, Selection, TextSource, TextSW, TextSWOps,     TextDisplay, TIP, UserInput, UserTerminal  EXPORTS EditUtil = {    Aborted: SIGNAL = CODE;  BadNum: SIGNAL [newI: CARDINAL] = CODE;  BadPattern: SIGNAL [pos: CARDINAL] = CODE;  CantReplace: PUBLIC SIGNAL = CODE;   ErrMsg: PROC [s: LONG STRING] = {UserTerminal.BlinkDisplay[]; Writeln[s]};    Writeln: Format.StringProc = {    Process.Detach[FORK Put.Line[EditUtil.prop.msgSW, s]]};      BadMatchProc: PROC = {Process.Detach[FORK BadMatch[]]};  BadMatchMsg: PROC ¬ BadMatchProc;  BadPatMsg: PROC [pos: CARDINAL] = {Process.Detach[FORK BadPat[pos]]};    BadPat: PROC [pos: CARDINAL] = {    ENABLE UNWIND => NULL;    Put.Text[EditUtil.prop.msgSW, "Bad match at position "L];    Put.Number[EditUtil.prop.msgSW, pos, []];    Put.CR[EditUtil.prop.msgSW];    UserTerminal.BlinkDisplay[]};      BadMatch: PROC = {    ENABLE UNWIND => NULL;    Put.Text[EditUtil.prop.msgSW,      IF EditUtil.prop.interpret = pattern THEN "Pattern"L ELSE "Literal"L];    Put.Text[EditUtil.prop.msgSW, " that matches "L];    Put.Text[EditUtil.prop.msgSW,      IF EditUtil.prop.context = anywhere THEN "anywhere"L ELSE "a word"L];    Put.Line[EditUtil.prop.msgSW, " not found"L];    UserTerminal.BlinkDisplay[]};    DoFindInTSW: PUBLIC PROC [sw: Window.Handle, td: EditUtil.DataHandle] = {    start, end, startPos: TextSource.Position ¬ 0;    source: TextSource.Handle ¬ NIL;    tsw: TextSWOps.TSWContext ¬ Context.Find[TextSWOps.textSWContext, sw];    match: BOOLEAN ¬ FALSE;     Abort: EditOps.AbortProc = {RETURN[UserInput.UserAbort[sw]]};    SetPosition: ENTRY PROC [sw: Window.Handle, start: TextSource.Position] = {      i, j: CARDINAL ¬ 0;      FOR i IN [0..tsw.splits.length) DO        IF tsw.splits[i].lineTable[0].pos <= startPos AND 	  tsw.splits[i].lineTable.lastPositionPlusOne > startPos THEN {	  j ¬ i; EXIT};	ENDLOOP;      TextSWOps.RealActOnCaret[tsw, clear]; -- clear that sucker!      tsw.splits[j].SetPosition[start, @tsw.selection]};    source ¬ TextSW.GetSource[sw];    startPos ¬ GetEndTSWPositions[sw, source, rest].start;    [match, start, end] ¬ FindInSource[td, source, startPos, Abort];    IF ~match THEN BadMatchMsg[]    ELSE {      IF ~TextSW.PositionIsVisible[sw, start] THEN         SetPosition[sw, start];      TextSW.SetSelection[sw, start, end];      IF TextSW.GetOptions[sw].access = edit THEN TextSW.SetInsertion[sw, end]}};      DoFindInFSW: PUBLIC PROC [sw: Window.Handle, td: EditUtil.DataHandle] = {    FindInFSWInt[sw ,td, TRUE]};      FindInFSWInt: PROC [    sw: Window.Handle, td: EditUtil.DataHandle, first: BOOLEAN ¬ TRUE] = {    start, end: TextSource.Position ¬ 0;    source: TextSource.Handle ¬ NIL;    match: BOOLEAN ¬ FALSE;     i,pos,len: CARDINAL ¬ 0;    item: FormSW.ItemHandle ¬ NIL;    Abort: EditOps.AbortProc = {RETURN[UserInput.UserAbort[sw]]};    [i, pos, ] ¬ GetEndFSWPositions[sw, rest];    item ¬ FormSW.FindItem[sw,i];    WHILE item # NIL DO      WITH v: item­ SELECT FROM        string => IF v.string # NIL AND v.string­ # NIL AND	  ~item.flags.readOnly THEN {	  len ¬ v.string.length;	  source ¬ StringSource.Create[v.string, FALSE];	  [match, start, end] ¬ FindInSource[td, source, LONG[pos], Abort,first];	  source.actOn[source, destroy];	  v.string.length ¬ len;	  IF match THEN EXIT};	ENDCASE;      i ¬ i + 1;      pos ¬ 0;      item ¬ FormSW.FindItem[sw,i];      ENDLOOP;    IF ~match THEN BadMatchMsg[]    ELSE {      FormSW.SetSelection[        sw,i, Inline.LowHalf[start+item.tag.length+2], 	Inline.LowHalf[end + item.tag.length+2]];      FormSW.SetTypeIn[sw, i, Inline.LowHalf[end + item.tag.length+2]]}};      ReplaceAllInFSW: PUBLIC PROC [sw: Window.Handle, td: EditUtil.DataHandle] = {    -- this whole proc is a croc claims it author    BEGIN ENABLE UNWIND => BadMatchMsg ¬ BadMatch;    letsQuit: BOOLEAN ¬ FALSE;    NullProc: PROC = {letsQuit ¬ TRUE};    first: BOOLEAN ¬ TRUE;    delta: INTEGER ¬ 0;    index, start, end, tIndex, tStart, tEnd, lIndex: CARDINAL ¬ 0;    item: FormSW.ItemHandle ¬ NIL;    BadMatchMsg ¬ NullProc;    [index,start,end] ¬ GetEndFSWPositions[sw, EditUtil.prop.scope];    IF index = FormSW.nullIndex THEN GOTO badSelect;    item ¬ FormSW.FindItem[sw, index];    lIndex ¬ index;    IF start > 0 THEN start ¬ start+item.tag.length+2;    FormSW.SetTypeIn[sw, index, start];    DO      FindInFSWInt[sw, td, first];      IF letsQuit THEN {IF first THEN BadMatch[]; EXIT};      first ¬ FALSE;      [tIndex, tStart, tEnd] ¬ FormSW.GetSelection[sw];      IF (tEnd > end) OR         (EditUtil.prop.scope = selection AND tIndex # lIndex) THEN EXIT;      delta ¬ ReplaceInFSWInt[sw, td! Aborted => GOTO aborted];      [tIndex, tStart, tEnd] ¬ FormSW.GetSelection[sw];      IF end # FormSW.nullIndex THEN {        IF delta < 0 THEN end ¬ end - ABS[delta]        ELSE end ¬ end + ABS[delta]};      IF tEnd >= end OR UserInput.UserAbort[sw] THEN EXIT;      IF lIndex # tIndex THEN {item¬FormSW.FindItem[sw,tIndex];lIndex ¬ tIndex};      FormSW.SetTypeIn[sw, tIndex, tEnd+item.tag.length+2];      ENDLOOP;    EXITS badSelect => Put.Line[EditUtil.prop.msgSW, "No text selected."L];      aborted => NULL;    END;    BadMatchMsg ¬ BadMatch;    IF EditUtil.prop.confirmReplace THEN TIP.NewManager[NIL,NIL,NIL]};    ReplaceAllInTSW: PUBLIC PROC [sw: Window.Handle, td: EditUtil.DataHandle] = {    start, end, startPos, endPos, last: TextSource.Position ¬ 0;    match: BOOLEAN ¬ FALSE;    first: BOOLEAN ¬ TRUE;    scope: EditUtil.ScopeType;    Abort: EditOps.AbortProc = {RETURN[UserInput.UserAbort[sw]]};    delta, totDelta: LONG INTEGER ¬ 0;    source: TextSource.Handle ¬ NIL;    tsw: TextSWOps.TSWContext ¬ Context.Find[TextSWOps.textSWContext, sw];    confirm: BOOLEAN ¬ EditUtil.prop.confirmReplace;    count: CARDINAL ¬ 0;    insert: TextData.InsertionObject ¬ TRASH;    select: TextData.SelectionObject ¬ TRASH;    fixSelection: BOOLEAN ¬ sw = Selection.Convert[subwindow];    InternalReplace: PROC [      w: Window.Handle, src: TextSource.Handle,nil: LONG POINTER]       RETURNS [invalid: TextSW.InvalidRegions] = {      firstStart: TextSource.Position;      invalid ¬ NIL;      DO        [match, start, last] ¬ FindInSource[td, source, startPos, Abort, first];        IF last # 0 THEN end ¬ last;        IF ~match THEN {IF first THEN BadMatchMsg[]; EXIT}        ELSE {          IF (start > endPos) OR (end.PRED > endPos) THEN EXIT;	  IF first THEN firstStart ¬ start;	  first ¬ FALSE;	  delta ¬ DoOneTSWReplace[sw, source, td, start, end, confirm, FALSE!	    BadPattern => GOTO badPattern;	    Aborted => EXIT];	  IF delta < 0 THEN {	    endPos ¬ endPos - ABS[delta]; 	    startPos ¬ end - ABS[delta]}	  ELSE {endPos ¬ endPos + delta; startPos ¬ end + delta};	  totDelta ¬ totDelta + delta;	  count ¬ count + 1;	  IF startPos >= endPos THEN EXIT};        IF UserInput.UserAbort[sw] THEN EXIT;        ENDLOOP;      IF scope = selection THEN {	tsw.selection.right ¬ IF totDelta < 0 THEN	  tsw.selection.right - ABS[totDelta]	ELSE tsw.selection.right + ABS[totDelta];	IF tsw.selection.right < tsw.selection.left THEN 	  tsw.selection.right ¬ tsw.selection.left};      IF ~confirm AND ~first THEN {        Update[sw, firstStart, end, totDelta]};      EXITS badPattern => NULL};          BEGIN    IF TextSW.GetOptions[sw].access # edit THEN GOTO cantEdit;    source ¬ TextSW.GetSource[sw];    scope ¬ EditUtil.prop.scope;    [startPos, endPos] ¬ GetEndTSWPositions[sw, source, scope];    IF confirm THEN [] ¬ InternalReplace[NIL,NIL,NIL]    ELSE {      insert ¬ tsw.insertion;      select ¬ tsw.selection;      FOR i: CARDINAL IN [0..tsw.splits.length) DO	IF i = 0 THEN {	  tsw.splits[i].MarkInsertion[@tsw.insertion, clear];	  IF fixSelection THEN 	    tsw.splits[i].MarkSelection[@tsw.selection, clear]}	ELSE {	  tsw.splits[i].MarkInsertion[@insert, clear];	  IF fixSelection THEN 	    tsw.splits[i].MarkSelection[@select, clear]};	ENDLOOP;      TextSW.ModifySource[sw, InternalReplace, NIL];      IF count > 0  THEN {        TextSW.SetInsertion[sw, startPos];        TextSW.SetSelection[sw, startPos, startPos];	Put.Number[EditUtil.prop.msgSW, count, []];	Put.Line[EditUtil.prop.msgSW, " found"L]}};    EXITS       cantEdit => ErrMsg["Window not editable"G];    END;    IF EditUtil.prop.confirmReplace THEN TIP.NewManager[NIL,NIL,NIL]};    CountInTSW: PUBLIC PROC [sw: Window.Handle, td: EditUtil.DataHandle] = {    start, end, startPos, endPos: TextSource.Position ¬ 0;    match: BOOLEAN ¬ FALSE;    first: BOOLEAN ¬ TRUE;    delta, totDelta: LONG INTEGER ¬ 0;    Abort: EditOps.AbortProc = {RETURN[UserInput.UserAbort[sw]]};    source: TextSource.Handle ¬ NIL;    count: CARDINAL ¬ 0;    source ¬ TextSW.GetSource[sw];    [startPos, endPos] ¬ GetEndTSWPositions[      sw, source, EditUtil.prop.scope];    DO      [match, start, end] ¬ FindInSource[td, source, startPos, Abort, first];      IF ~match THEN {IF first THEN BadMatchMsg[]; EXIT}      ELSE {	first ¬ FALSE;	count ¬ count + 1;	startPos ¬ end;	IF startPos >= endPos THEN EXIT};      IF UserInput.UserAbort[sw] THEN EXIT;      ENDLOOP;    IF count > 0  THEN {      Put.Number[EditUtil.prop.msgSW, count, []];      Put.Line[EditUtil.prop.msgSW, " found"L]}};    FindReplaceInFSW: PUBLIC PROC [sw: Window.Handle, td: EditUtil.DataHandle] = {    BEGIN ENABLE Aborted => GOTO aborted;    start, end: TextSource.Position ¬ 0;    match: BOOLEAN ¬ FALSE;    source: TextSource.Handle ¬ NIL;    Abort: EditOps.AbortProc = {RETURN[UserInput.UserAbort[sw]]};    i,pos,len: CARDINAL ¬ 0;    item: FormSW.ItemHandle ¬ NIL;    [i,pos] ¬ FormSW.GetTypeIn[sw];    IF i = FormSW.nullIndex THEN {i ¬ 0; pos ¬ 0};    item ¬ FormSW.FindItem[sw,i];    IF pos > 0 THEN pos ¬ pos - item.tag.length - 2;    WHILE item # NIL DO      WITH v: item­ SELECT FROM        string => IF v.string # NIL AND v.string­ # NIL AND	  ~item.flags.readOnly THEN {	  len ¬ v.string.length;	  source ¬ StringSource.Create[v.string, FALSE];	  [match, start, end] ¬ FindInSource[td, source, pos, Abort];	  IF match THEN EXIT;	  source.actOn[source, destroy];	  v.string.length ¬ len};	ENDCASE;      pos ¬ 0;      i ¬ i + 1;      item ¬ FormSW.FindItem[sw,i];      ENDLOOP;    IF ~match THEN BadMatchMsg[]    ELSE {      [] ¬ DoOneFSWReplace[        sw, item, source, td, start, end, i, EditUtil.prop.confirmReplace];      WITH v: item­ SELECT FROM string => len ¬ v.string.length; ENDCASE;      source.actOn[source, destroy];      WITH v: item­ SELECT FROM string => v.string.length ¬ len; ENDCASE};    EXITS aborted => NULL;    END;    IF EditUtil.prop.confirmReplace THEN TIP.NewManager[NIL,NIL,NIL]};      FindReplaceInTSW: PUBLIC PROC [sw: Window.Handle, td: EditUtil.DataHandle] = {    BEGIN    start, end, startPos: TextSource.Position ¬ 0;    match: BOOLEAN ¬ FALSE;    Abort: EditOps.AbortProc = {RETURN[UserInput.UserAbort[sw]]};    source: TextSource.Handle ¬ NIL;    IF TextSW.GetOptions[sw].access # edit THEN GOTO cantEdit;    source ¬ TextSW.GetSource[sw];    startPos ¬ GetEndTSWPositions[sw, source, rest].start;    [match, start, end] ¬ FindInSource[td, source, startPos, Abort];    IF ~match THEN BadMatchMsg[]    ELSE {      [] ¬ DoOneTSWReplace[        sw, source, td, start, end, EditUtil.prop.confirmReplace,TRUE!        BadPattern => GOTO badPattern;	Aborted => GOTO aborted]};    EXITS      cantEdit => ErrMsg["Window not editable"G];      badPattern => NULL;      aborted => NULL;    END;    IF EditUtil.prop.confirmReplace THEN TIP.NewManager[NIL,NIL,NIL]};      ReplaceFindInTSW: PUBLIC PROC [sw: Window.Handle, td: EditUtil.DataHandle] = {    ReplaceInTSW[sw, td];    DoFindInTSW[sw, td]};    ReplaceFindInFSW: PUBLIC PROC [sw: Window.Handle, td: EditUtil.DataHandle] = {    ReplaceInFSW[sw, td];    DoFindInFSW [sw, td]};      ReplaceInTSW: PUBLIC PROC [sw: Window.Handle, td: EditUtil.DataHandle] = {    BEGIN    start, end: TextSource.Position;    source: TextSource.Handle;    IF TextSW.GetOptions[sw].access # edit THEN GOTO cantEdit;    source ¬ TextSW.GetSource[sw];    [start, end] ¬ TextSW.GetSelection[sw];    IF start = TextSource.nullPosition OR (HasPartial[td] AND       ~FindWasLast[start, end-1, td.pattern])       OR start = end THEN SIGNAL CantReplace;    [] ¬ DoOneTSWReplace[      sw, source, td, start, end, EditUtil.prop.confirmReplace, TRUE!        BadPattern => GOTO badPattern;	Aborted => GOTO aborted];    EXITS       badPattern => NULL;      aborted => NULL;      cantEdit => ErrMsg["Window not editable"G];    END;    IF EditUtil.prop.confirmReplace THEN TIP.NewManager[NIL,NIL,NIL]};    ReplaceInFSW: PUBLIC PROC [sw: Window.Handle, td: EditUtil.DataHandle] = {    [] ¬ ReplaceInFSWInt[sw, td!      Aborted => CONTINUE];    IF EditUtil.prop.confirmReplace THEN TIP.NewManager[NIL,NIL,NIL]};      ReplaceInFSWInt: PUBLIC PROC [sw: Window.Handle, td: EditUtil.DataHandle]     RETURNS [delta: INTEGER] = {    start, end: TextSource.Position ¬ 0;    source: TextSource.Handle;    i,pos,len, startPos, endPos: CARDINAL ¬ 0;    item: FormSW.ItemHandle ¬ NIL;    source ¬ TextSW.GetSource[sw];    [i, startPos, endPos] ¬ FormSW.GetSelection[sw];    start ¬ startPos; end ¬ endPos;    IF i = FormSW.nullIndex OR startPos = endPos OR (HasPartial[td] AND       ~FindWasLast[start, end-1, td.pattern]) THEN       SIGNAL CantReplace;    item ¬ FormSW.FindItem[sw,i];    WITH v: item­ SELECT FROM      string =>        IF v.string # NIL AND v.string­ # NIL AND	  ~item.flags.readOnly THEN {	  len ¬ v.string.length;	  source ¬ StringSource.Create[v.string, FALSE];	  delta ¬ DoOneFSWReplace[	    sw, item, source, td, start, end, i, EditUtil.prop.confirmReplace!	      BadPattern => GOTO badPattern;	      Aborted =>{	        Put.Line[EditUtil.prop.msgSW,"Replace aborted"L]; REJECT}];	  WITH v: item­ SELECT FROM string => len ¬ v.string.length; ENDCASE;	  source.actOn[source, destroy];	  WITH v: item­ SELECT FROM string => v.string.length ¬ len; ENDCASE}	ELSE SIGNAL CantReplace;      ENDCASE => GOTO cantEdit;    EXITS       badPattern => NULL;      cantEdit => ErrMsg["Window not editable"G]};    DoOneFSWReplace: PROC [sw: Window.Handle, item: FormSW.ItemHandle,    source: TextSource.Handle, td: EditUtil.DataHandle,      start, end: TextSource.Position, index: CARDINAL,     confirm: BOOLEAN ¬ TRUE] RETURNS [delta: INTEGER] = {    IF confirm THEN {      go: EditUtil.ConfirmType;      FormSW.SetSelection[sw, index, Inline.LowHalf[item.tag.length+2+start],         Inline.LowHalf[item.tag.length+2+end]];      FormSW.SetTypeIn[        sw, index, Inline.LowHalf[item.tag.length+2+end]];      go ¬ EditUtil.Confirmation[];      SELECT go FROM        ok => NULL;	notOk => RETURN;	abort => SIGNAL Aborted;	ENDCASE};    BuildReplaceBlock[td, source !      BadPattern => {BadPatMsg[pos]; GOTO badPattern};      GetEndPoint => {RESUME[start,end]}];    Selection.ActOn[clear];    FormSW.ModifyEditable[      sw, index, Inline.LowHalf[start], Inline.LowHalf[end-start],      td.block, TRUE];    delta ¬ Inline.LowHalf[end-start] - td.block.length;    FormSW.SetSelection[sw, index, Inline.LowHalf[item.tag.length+2+start],       Inline.LowHalf[item.tag.length+2+start+td.block.length]];    EXITS       badPattern => NULL};      GetEndPoint: SIGNAL RETURNS[startPoint, endPoint: TextSource.Position] = CODE;    DoOneTSWReplace: PROC [sw: Window.Handle, source: TextSource.Handle,    td: EditUtil.DataHandle,  start, end: TextSource.Position,     confirm, updateDisplay: BOOLEAN ¬ TRUE]     RETURNS [delta: LONG INTEGER ¬ 0] = {      IF confirm THEN {        go: EditUtil.ConfirmType;	IF ~TextSW.PositionIsVisible[sw, start] THEN	  TextSW.SetPosition[sw, start];	TextSW.SetSelection[sw, start, end];	TextSW.SetInsertion[sw, end];	go ¬ EditUtil.Confirmation[];	SELECT go FROM	  ok => NULL;	  notOk => RETURN;	  abort => SIGNAL Aborted;	  ENDCASE};      BuildReplaceBlock[td, source !        BadPattern => {BadPatMsg[pos]; REJECT};	GetEndPoint => {RESUME[start,end]}];      IF updateDisplay OR confirm THEN {        TextSW.ReplaceText[          sw, start, end-start, 	  [LOOPHOLE[@td.block.text],0, td.block.length], TRUE];        IF ~TextSW.PositionIsVisible[sw, start] THEN           TextSW.SetPosition[sw, start];        TextSW.SetSelection[sw, start, start+td.block.length];        TextSW.SetInsertion[sw, start+td.block.length]}      ELSE [] ¬ source.ReplaceText[[LOOPHOLE[@td.block.text],0, td.block.length],        start, end, TRUE];    delta ¬ td.block.length - (end - start)};    Update: PUBLIC PROC [    sw: Window.Handle, first,last: TextSource.Position,    delta: LONG INTEGER] = {    tsw: TextSWOps.TSWContext ¬ Context.Find[TextSWOps.textSWContext, sw];    lt: TextDisplay.LineTable;    realLast: TextSource.Position ¬ MAX[last, first+ABS[delta]];    FOR i: CARDINAL IN [0..tsw.splits.length) DO      lt ¬ tsw.splits[i].lineTable;      FOR j: CARDINAL IN [1..lt.length) DO        IF lt[j].pos # TextSource.nullPosition THEN	  IF lt[j].pos >= first AND lt[j].pos <= realLast THEN 	    lt[j].pos ¬ TextSource.nullPosition	  ELSE IF lt[j].pos > last THEN {	    IF delta > 0 THEN lt[j].pos ¬ lt[j].pos + ABS[delta]	    ELSE lt[j].pos ¬ lt[j].pos - ABS[delta]};        ENDLOOP;      -- FixSelection[tsw.splits[i].source, @tsw.selection, first, delta];      IF realLast <= lt[0].pos THEN        IF delta > 0 THEN {	  lt.lastPositionPlusOne ¬ lt.lastPositionPlusOne + ABS[delta];	  lt[0].pos ¬ lt[0].pos + ABS[delta]}	ELSE {	  lt.lastPositionPlusOne ¬ lt.lastPositionPlusOne - ABS[delta];	  lt[0].pos ¬ lt[0].pos - ABS[delta]}      ELSE IF first <= lt.lastPositionPlusOne THEN        IF delta > 0 THEN 	  lt.lastPositionPlusOne ¬ lt.lastPositionPlusOne + ABS[delta]	ELSE 	  lt.lastPositionPlusOne ¬ lt.lastPositionPlusOne - ABS[delta];      tsw.splits[i].Update[first, last,@tsw.selection, TRUE];    ENDLOOP};      FindInSource: PROC [    td: EditUtil.DataHandle, source: TextSource.Handle,     startPos: TextSource.Position, Abort: EditOps.AbortProc,    makeNewPattern: BOOLEAN ¬ TRUE]     RETURNS[match: BOOLEAN ¬ FALSE, start,end: TextSource.Position] = {    ENABLE EditOps.AbortSearch => GOTO aborted;    endPos: TextSource.Position;    ok: BOOLEAN ¬ ~makeNewPattern;    IF String.Length[td.arg] = 0 THEN RETURN;    IF makeNewPattern THEN      [ok, td.pattern] ¬ EditOps.MakePat[td.arg, 0, td.pattern,         EditUtil.prop.interpret = literal];    endPos ¬ source.getLength[source];    IF ok THEN    [match, start, end] ¬ EditOps.Match[      source, td.pattern, startPos,endPos, Abort, EditUtil.prop.ignoreCase,      EditUtil.prop.context = words];    IF Profile.debugging THEN PrintPositions[td.pattern];    EXITS aborted => Writeln["Search aborted"G]};      BuildReplaceBlock: PROC [    td: EditUtil.DataHandle, source: TextSource.Handle] =  {    ENABLE String.StringBoundsFault => {      ns ¬ EditUtil.zone.NEW[StringBody[2*s.maxlength]];      ns.length ¬ s.length;      FOR i: CARDINAL IN [0..s.length) DO ns[i] ¬ s[i]; ENDLOOP;      td.block ¬ ns;      EditUtil.zone.FREE[@s];      RESUME};    i, j: CARDINAL ¬ 0;    td.block.length ¬ 0;    IF td.text = NIL THEN RETURN;    WHILE i < td.text.length DO     IF td.text[i] = '@ THEN [i,j] ¬ GetPartial[i,j,td, source]     ELSE IF td.text[i] = '\\ THEN [i,j] ¬ GetEscape[i,j,td]     ELSE String.AppendChar[td.block, td.text[i]];     i ¬ i + 1;     ENDLOOP};    GetEscape: PROC [    I,J: CARDINAL, td: EditUtil.DataHandle] RETURNS[i,j:CARDINAL] = {    i ¬  I; j ¬ J;    i ¬ i + 1;    SELECT td.text[i] FROM      't, 'T => String.AppendChar[td.block, Ascii.TAB];      'n, 'N => String.AppendChar[td.block, Ascii.CR];      IN ['0..'9] => {        IF (i+2 < td.text.length) AND (td.text[i+1] IN ['0..'9]) AND 	(td.text[i+2] IN ['0..'9]) THEN {	  k,l: CARDINAL ¬ 0;	  FOR l IN [0..3) DO	    k ¬ k*8 + (td.text[i+l] - '0) ENDLOOP;	  String.AppendChar[td.block, LOOPHOLE[(k MOD 256), CHARACTER]];	  i ¬ i + 2}	ELSE String.AppendChar[td.block, td.text[i]]};      ENDCASE => String.AppendChar[td.block, td.text[i]]};       GetPartial: PROC [    I, J: CARDINAL, td: EditUtil.DataHandle, source: TextSource.Handle]     RETURNS [i,j: CARDINAL] = {    b: Environment.Block;    c: CHARACTER;    oldI,k: CARDINAL;    i ¬ I; j ¬ J;    i ¬ i + 1; IF i >= td.text.length THEN       {String.AppendChar[td.block, '@]; GOTO nope};    oldI ¬ i;    [i,j] ¬ GetNum[td.text, i!      BadNum => {	i ¬ newI;	SELECT td.text[i] FROM	  '& => {	    start,end: TextSource.Position;	    [start,end] ¬ SIGNAL GetEndPoint[];	    FOR x: TextSource.Position IN [start..end) DO	      b ¬ source.readText[source, x, 1, none].block;	      c ¬ LOOPHOLE[b.blockPointer[b.startIndex],CHARACTER];	      String.AppendChar[td.block, c];	      ENDLOOP};	  ENDCASE => String.AppendChar[td.block, '@];	GOTO nope}];    k ¬ GetIndex[td.pattern, j! BadNum => SIGNAL BadPattern[oldI]];    WITH p: td.pattern[k] SELECT FROM      literal => String.AppendString[td.block, p.lit];      ccl, nccl, closure, any => {	FOR l: TextSource.Position IN [p.startPos..p.endPos] DO	  b ¬ source.readText[source, l, 1, none].block;	  c ¬ LOOPHOLE[b.blockPointer[b.startIndex],CHARACTER];	  String.AppendChar[td.block, c];	  ENDLOOP};      ENDCASE;    EXITS nope => NULL};  GetNum: PROC [s: LONG STRING, ind: CARDINAL]    RETURNS [i,j: CARDINAL] = {    j ¬ 0; i ¬ ind;    WHILE s[i] # '@ AND i < s.length DO      IF ~(s[i] >= '0 AND s[i] <= '9) THEN SIGNAL BadNum[i];      j ¬ 10*j + (s[i] - '0);      i ¬ i + 1;      ENDLOOP;    IF s[i] # '@ OR i = ind OR j = 0 THEN SIGNAL BadNum[i];    j ¬ j - 1};      GetIndex: PROC [pat: EditOps.MatchList, i: CARDINAL] RETURNS [j: CARDINAL] ={    j ¬ 0;    DO      IF pat[j].startPos # TextSource.nullPosition THEN {        IF i = 0 THEN EXIT;	i ¬ i-1; 	};      j ¬ j+1;      IF j >= pat.length THEN SIGNAL BadNum[i];      ENDLOOP};      PrintNum: PROC [n: LONG CARDINAL] = {    IF n = TextSource.nullPosition THEN Put.Text[NIL, "null"L]    ELSE Put.LongNumber[NIL, n, []];    Put.Text[NIL, "	"L]};    PrintPositions: PROC [pat: EditOps.MatchList] = {    Process.Detach[FORK RealPrintPositions[pat]]};      RealPrintPositions: PROC [pat: EditOps.MatchList] = {    ENABLE UNWIND => NULL;    Put.CR[NIL];    FOR i: CARDINAL IN [0..pat.length) DO      WITH p: pat[i] SELECT FROM        bol => Put.Text[NIL, "bol	"L];        literal => Put.Text[NIL, "lit	"L];        closure => Put.Text[NIL, "clo	"L];        ccl => Put.Text[NIL, "ccl	"L];        nccl => Put.Text[NIL, "nccl	"L];        any => Put.Text[NIL, "any	"L];	ENDCASE;      PrintNum[pat[i].startPos];      PrintNum[pat[i].endPos];      Put.CR[NIL];      ENDLOOP};    GetEndTSWPositions: PROC [sw: Window.Handle, source: TextSource.Handle,    scope: EditUtil.ScopeType]     RETURNS [start, end: TextSource.Position] = {    SELECT scope FROM      entire => {        start ¬ 0; end ¬ source.GetLength[];	IF end > 0 THEN end ¬ end-1};      selection => {[start,end] ¬ TextSW.GetSelection[sw]};      rest => {        top: TextSource.Position;	selectWindow: Window.Handle ¬ Selection.Convert[subwindow];        access: TextSW.Access ¬ TextSW.GetOptions[sw].access;	start ¬ IF access = edit THEN TextSW.GetInsertion[sw]	  ELSE TextSW.GetSelection[sw].right;	top ¬ TextSW.GetPosition[sw, 0];	IF sw # selectWindow OR start = TextSource.nullPosition OR	~TextSW.PositionIsVisible[sw, start] THEN start ¬ top;	end ¬ source.GetLength[];	IF end > 0 THEN end ¬ end-1};      ENDCASE};      GetEndFSWPositions: PROC [sw: Window.Handle, scope: EditUtil.ScopeType]     RETURNS [index, start, end: CARDINAL] = {    SELECT scope FROM      entire => {start ¬ index ¬ 0; end ¬ FormSW.nullIndex};      selection => {[index, start,end] ¬ FormSW.GetSelection[sw]};      rest => {        [index, start] ¬ FormSW.GetTypeIn[sw];	end ¬ FormSW.nullIndex;	IF index = FormSW.nullIndex OR sw # Selection.Convert[subwindow] THEN	  {index ¬ 0; start ¬ 0}	ELSE IF start > 0 THEN {	  item: FormSW.ItemHandle ¬ FormSW.FindItem[sw, index];	  start ¬ start - item.tag.length - 2}};      ENDCASE};      HasPartial: PROC [td: EditUtil.DataHandle] RETURNS [yes: BOOLEAN] = {    yes ¬ FALSE;    IF String.Length[td.text] = 0 THEN RETURN;    FOR i: CARDINAL IN [0..td.text.length) DO       IF td.text[i] = '@ AND i+1 < td.text.length AND       td.text[i+1] IN ['0..'9] THEN  RETURN[TRUE];      ENDLOOP};    FindWasLast: PROC [start, end: TextSource.Position, pat: EditOps.MatchList]     RETURNS [yes: BOOLEAN] ={    i: CARDINAL;    IF pat = NIL THEN RETURN[FALSE];    i ¬ IF pat.length = 0 THEN 0 ELSE pat.length -1;    WHILE i>0 AND pat[i].endPos = TextSource.nullPosition DO i ¬ i - 1 ENDLOOP;    yes ¬ start = pat[0].startPos AND end = pat[i].endPos};      FixSelection: PUBLIC PROCEDURE [    source: TextSource.Handle, select: TextDisplay.Selection,     pos: TextSource.Position, delta: LONG INTEGER] = {    -- Handles tricky cases of large deletions that intersect the selection    --   on the left only.  Also extends "point" selection at insert properly.    -- pos is always left side of edited region before the edit (i.e. first bad).    sourceLength: LONG CARDINAL = source.getLength[source];    newPos: TextSource.Position ¬ TextSource.nullPosition;    IF select = NIL THEN RETURN;    SELECT delta FROM      < 0 => {newPos ¬ pos; pos ¬ pos - delta};      > 0 => newPos ¬ pos + delta;      ENDCASE => newPos ¬ pos;    SELECT pos FROM      IN (select.left..select.right) => {        select.right ¬ select.right + delta;        IF select.left > newPos THEN select.left ¬ newPos};      < select.left => {        select.right ¬ select.right + delta;        select.left ¬ select.left + delta};      = select.left =>        IF select.left = select.right THEN select.right ¬ newPos        ELSE {          select.right ¬ select.right + delta;          select.left ¬ select.left + delta};  -- is this right?      ENDCASE => IF select.right > newPos THEN select.right ¬ newPos;    -- Make sure new selection is valid    IF select.right > sourceLength THEN select.right ¬ sourceLength;    IF select.left > select.right THEN select.left ¬ select.right};      }.
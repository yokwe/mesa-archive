-- Copyright (C) 1981, 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- File: FormSWsI.mesa - last edit:-- SXW   	12-Jul-81 11:20:22 -- Mark		24-Jul-81 12:17:49 -- BXM  	4-Sep-81 17:37:20-- JGS		18-Aug-81 13:58:58-- SEH		5-Mar-82 18:01:19-- BGY     	18-Nov-83 14:07:47-- PXK    	12-Nov-82 20:58:07-- AXD    	17-Apr-84 18:36:49-- String Typein and Edit routinesDIRECTORY  Context,  Dictionary USING [defaultDictionary, LookUp],  Environment USING [Block],  Heap USING [systemZone],  Inline USING [LowHalf],  FormSW USING [    EnumeratedNotifyProcType, Error, FilterProcType, FreeHintsProcType,    ItemHandle, ItemObject, LongNumberNotifyProcType, MenuProcType,    NotifyProcType, nullIndex, NumberNotifyProcType, ReadOnlyProcType, SetCurrent,    StringHandle, Wakeup],  FormSWOps USING [    context, DeleteFNR, FindContext, fontHeight, InsertionObject,    InternalScrollVertical, LockContextProcType, ModifyInsertionState,    ModifyProcType, NewBoxHeightRequested, PContext,    PSelection, RealActOnCaret, SetModified, SelectionPointer, TagLength,    UnlockedActOnSelection],  Selection USING [ConvertTrashBin],  String USING [EmptyString, FreeString, InvalidNumber,     StringToLongNumber, StringToNumber],  TextSource USING [EditAction, Handle, Position],  TextData USING [Insertion, InsertionObject, Selection],  TextDisplay USING [    DeleteText, DoEditAction, Handle, InsertBlock, InsertCharacter, noPlace,    Object, ReplaceBlock, RequestNewBoxHeight,      specialPlaceX, Update, WindowPlaceFromPosition],  ToolWindow USING [DrawRectangle],  UserInput USING [StringProcType, StuffCharacter],  UserTerminal USING [BlinkDisplay],  Window USING [Box, GetBox, Handle, Validate];FormSWsI: MONITOR LOCKS myContext.lock USING myContext: FormSWOps.PContext  IMPORTS    Context, Dictionary, Inline, FormSW, FormSWOps, Heap, Selection,     String, TextDisplay, ToolWindow, UserInput, UserTerminal, Window  EXPORTS FormSW, FormSWOps =  BEGIN  -- Global Data and STUFF  EditItemArgs: TYPE = POINTER TO EditItemArgsObject;  EditItemArgsObject: TYPE = RECORD [    myContext: FormSWOps.PContext,    item: FormSW.ItemHandle,    diject: TextDisplay.Handle,    index: CARDINAL,  -- item index    position, length: CARDINAL,  -- to cut    string: LONG STRING,  -- to paste    keepTrash: BOOLEAN,    insert: TextData.Insertion,    select: TextData.Selection];  Object: PUBLIC TYPE = TextDisplay.Object;  MyBS: CHARACTER = 210C;  MyBW: CHARACTER = 230C;  z: UNCOUNTED ZONE = Heap.systemZone;  -- PROCEDUREs implementing the interface  InHeapFreeHintsProc: PUBLIC FormSW.FreeHintsProcType =    BEGIN    i: CARDINAL;    IF BASE[hints] # NIL THEN      FOR i IN [0..LENGTH[hints]) DO String.FreeString[z, hints[i]]; ENDLOOP;    END;  IgnoreReadOnlyProc: PUBLIC FormSW.ReadOnlyProcType =    BEGIN UserTerminal.BlinkDisplay[]; END;  NopEnumeratedNotifyProc: PUBLIC FormSW.EnumeratedNotifyProcType = BEGIN END;  NopFreeHintsProc: PUBLIC FormSW.FreeHintsProcType = BEGIN END;  NopLongNumberNotifyProc: PUBLIC FormSW.LongNumberNotifyProcType = BEGIN END;  NopNotifyProc: PUBLIC FormSW.NotifyProcType = BEGIN END;  NopNumberNotifyProc: PUBLIC FormSW.NumberNotifyProcType = BEGIN END;  NopReadOnlyProc: PUBLIC FormSW.ReadOnlyProcType = BEGIN END;  SkipToNext: PUBLIC PROCEDURE [sw: Window.Handle] =    BEGIN RealSkipToNext[FormSWOps.FindContext[sw], TRUE]; END;  BackSpaceFNR: PUBLIC PROC [window: Window.Handle] = {    [] ¬ UserInput.StuffCharacter[window, MyBS]};  BackWordFNR: PUBLIC PROC [window: Window.Handle] = {    [] ¬ UserInput.StuffCharacter[window, MyBW]};  NextDeleteFNR: PUBLIC PROC [window: Window.Handle] = {    SkipToNext[window]};  NextFNR: PUBLIC PROC [window: Window.Handle] = {    RealSkipToNext[FormSWOps.FindContext[window], FALSE]};  StringEditProc: PUBLIC FormSW.FilterProcType =    BEGIN    myContext: FormSWOps.PContext = FormSWOps.FindContext[sw];    IF myContext = NIL OR item = NIL THEN UserTerminal.BlinkDisplay[]    ELSE      BEGIN      -- Client position is biased by tag length      index: CARDINAL = IndexFromHandle[myContext, item];      tagLength: CARDINAL = GetTagLength[myContext, index];      RealModifyEditable[myContext, index, insert + tagLength, 0, string, FALSE];      END;    END;  VanillaMenuProc: PUBLIC FormSW.MenuProcType =    BEGIN RETURN[DESCRIPTOR[NIL, 0], NopFreeHintsProc, FALSE]; END;  -- TypeIn routine and support  DeleteCurrentSelection: PUBLIC PROCEDURE [sw: Window.Handle] =    BEGIN    myContext: FormSWOps.PContext = FormSWOps.FindContext[sw];    IF myContext # NIL THEN      BEGIN OPEN ms: myContext.selection;      left: CARDINAL = Inline.LowHalf[ms.textSelect.left];      right: CARDINAL = Inline.LowHalf[ms.textSelect.right];      IF ms.index # FormSW.nullIndex AND right > left THEN        RealModifyEditable[          myContext, ms.index, left, right - left, NIL,          WITH item: myContext.items[ms.index] SELECT FROM            string => IF item.feedback = password THEN FALSE ELSE TRUE,            ENDCASE => TRUE];      END;    END;  ModifyEditable: PUBLIC PROCEDURE [    sw: Window.Handle, index, position, length: CARDINAL, new: LONG STRING ¬ NIL,    keepTrash: BOOLEAN ¬ FALSE] =    BEGIN    myContext: FormSWOps.PContext = FormSWOps.FindContext[sw];    IF myContext # NIL THEN      BEGIN      -- Client position is biased by tag length      tagLength: CARDINAL = GetTagLength[myContext, index];      RealModifyEditable[        myContext, index, position + tagLength, length, new, keepTrash];      END;    END;  PositionInBody: PUBLIC PROCEDURE [pos: CARDINAL, source: TextSource.Handle]    RETURNS [posInBody: CARDINAL] =    BEGIN    itemLength: CARDINAL = Inline.LowHalf[source.getLength[source]];    posInBody ¬ MIN[MAX[pos, FormSWOps.TagLength[source]], itemLength];    -- Assert: posInBody IN [p.tagLength..p.length]    END;  RealModifyEditable: PROCEDURE [    myContext: FormSWOps.PContext, index: CARDINAL, position, length: CARDINAL,    new: LONG STRING, keepTrash: BOOLEAN] =    -- Assumes myContext is not NIL and not locked!    BEGIN    validate: BOOLEAN;    offset: INTEGER;    oldVal: UNSPECIFIED;    longOldVal: LONG UNSPECIFIED;    LockedRealModifyEditable: ENTRY FormSWOps.LockContextProcType =       BEGIN      ENABLE UNWIND => NULL;      WITH item: myContext.items[index] SELECT FROM        longNumber, number, string =>          BEGIN	  insertObject: TextData.InsertionObject;          args: EditItemArgsObject ¬ [            myContext: myContext, item: @item, diject: @myContext.dijects[index],            index: index, position: position, length: length, string: new,            keepTrash: keepTrash, insert: NIL,            select: FormSWOps.SelectionPointer[@myContext.selection, index]];          IF myContext.insertion.index = index THEN {	    IF length=0 THEN	      myContext.insertion.textInsert.position ¬ PositionInBody[	        position, args.diject.source];	    args.insert ¬ @myContext.insertion.textInsert}          ELSE            BEGIN            -- position IN [p.tagLength..p.length] MUST hold or            --   FormSWInsertText will confuse TextDisplay.InsertSubstring!            insertObject ¬ [              PositionInBody[position, args.diject.source], TextDisplay.noPlace,              triangle, FALSE];            args.insert ¬ @insertObject;            END;          [validate, offset] ¬ EditItem[@args];          FormSWOps.ModifyInsertionState[myContext, unknown,	    myContext.insertion.textInsert.position];	  END;        ENDCASE => ERROR FormSW.Error[other];      END;    IF index >= LENGTH[myContext.items] THEN GOTO Blink;    WITH item: myContext.items[index] SELECT FROM      longNumber => {        longOldVal ¬ item.value­; LockedRealModifyEditable[myContext]};      number => {oldVal ¬ item.value­; LockedRealModifyEditable[myContext]};      string => LockedRealModifyEditable[myContext];      tagOnly =>        BEGIN        RealModifyEditable[          myContext, item.otherItem, position, length, new, keepTrash];        RETURN;        END;      ENDCASE => GOTO Blink;    IF validate THEN Window.Validate[myContext.sw];    IF offset # 0 AND myContext.options.autoScroll THEN      FormSWOps.InternalScrollVertical[myContext, forward, offset];    WITH item: myContext.items[index] SELECT FROM      longNumber =>        IF longOldVal # item.value­ THEN {          item.proc[myContext.sw, @item, index, longOldVal];	  FormSWOps.SetModified[myContext.sw, myContext, index]};      number =>        IF oldVal # item.value­ THEN {          item.proc[myContext.sw, @item, index, oldVal];	  FormSWOps.SetModified[myContext.sw, myContext, index]};      ENDCASE => FormSWOps.SetModified[myContext.sw, myContext, index];    EXITS Blink => UserTerminal.BlinkDisplay[];    END;  ForceValidSelection: PUBLIC PROCEDURE [    s: FormSWOps.PSelection, length: CARDINAL] =    BEGIN OPEN s.textSelect;    IF right > length THEN right ¬ length;    IF left > right THEN left ¬ right;    END;  RealSkipToNext: PROCEDURE [myContext: FormSWOps.PContext, delete: BOOLEAN] =    BEGIN    LockedRealSkipToNext: ENTRY PROCEDURE [myContext: FormSWOps.PContext]      RETURNS [next: CARDINAL] =       BEGIN      first, i, numItems: CARDINAL;      item: FormSW.ItemHandle;      numItems ¬ LENGTH[myContext.items];      first ¬        IF myContext.insertion.index = FormSW.nullIndex THEN 0        ELSE myContext.insertion.index + 1;      FOR i IN [first..first + numItems) DO        next ¬ i MOD numItems;        item ¬ myContext.items[next];        IF item.flags.readOnly OR item.flags.invisible THEN LOOP;        SELECT item.type FROM longNumber, number, string => EXIT ENDCASE;        REPEAT FINISHED => {UserTerminal.BlinkDisplay[]; next ¬ FormSW.nullIndex};        ENDLOOP;      END;    IF myContext = NIL THEN UserTerminal.BlinkDisplay[]    ELSE      BEGIN      nextItem: CARDINAL ¬ LockedRealSkipToNext[myContext];      IF nextItem # FormSW.nullIndex THEN        BEGIN        FormSW.SetCurrent[myContext.sw, nextItem];        IF delete THEN FormSWOps.DeleteFNR[myContext.sw];        END;      END;    END;  GetTagLength: PROCEDURE [myContext: FormSWOps.PContext, index: CARDINAL]    RETURNS [tagLength: CARDINAL] =    BEGIN    sw: Window.Handle;    DoWakeup: ENTRY PROC [myContext: FormSWOps.PContext] RETURNS [wake: BOOLEAN] =       {IF (wake ¬ myContext.dijects = NIL) THEN sw ¬ myContext.sw};    LockedGetTagLength: ENTRY PROC [myContext: FormSWOps.PContext] =  {      tagLength ¬ FormSWOps.TagLength[        myContext.dijects[index].source ! UNWIND => NULL]};    IF DoWakeup[myContext] THEN FormSW.Wakeup[sw];    LockedGetTagLength[myContext];    END;  FindIndex: PUBLIC PROCEDURE [sw: Window.Handle, item: FormSW.ItemHandle]    RETURNS [CARDINAL] =    BEGIN    myContext: FormSWOps.PContext = FormSWOps.FindContext[sw];    RETURN[      IF myContext = NIL THEN FormSW.nullIndex      ELSE IndexFromHandle[myContext, item]];    END;  IndexFromHandle: PUBLIC PROCEDURE [    myContext: FormSWOps.PContext, item: FormSW.ItemHandle] RETURNS [CARDINAL] =    BEGIN    i: CARDINAL;    FOR i IN [0..LENGTH[myContext.items]) DO      IF myContext.items[i] = item THEN RETURN[i]; ENDLOOP;    RETURN[FormSW.nullIndex];    END;  TypeInProc: PUBLIC UserInput.StringProcType =    BEGIN    myContext: FormSWOps.PContext = FormSWOps.FindContext[window];    index: CARDINAL;    typeInPos: CARDINAL;    LockedInitTypeInProc: ENTRY FormSWOps.LockContextProcType =       BEGIN      index ¬ myContext.insertion.index;      typeInPos ¬ Inline.LowHalf[myContext.insertion.textInsert.position];      END;    IF myContext = NIL OR String.EmptyString[string] THEN GOTO Blink;    IF myContext.dijects = NIL THEN FormSW.Wakeup[window];    FormSWOps.ModifyInsertionState[myContext, append,       myContext.insertion.textInsert.position];    LockedInitTypeInProc[myContext];    IF index >= LENGTH[myContext.items] THEN GOTO Blink;    WITH item: myContext.items[index] SELECT FROM      longNumber, number, tagOnly =>        RealModifyEditable[myContext, index, typeInPos, 0, string, FALSE];      string =>        BEGIN        tagLength: CARDINAL = FormSWOps.TagLength[          myContext.dijects[index].source];        item.filterProc[window, @item, typeInPos - tagLength, string];        END;      ENDCASE => GOTO Blink;    FormSWOps.ModifyInsertionState[myContext, append,       myContext.insertion.textInsert.position];    EXITS Blink => UserTerminal.BlinkDisplay[];    END;  -- PROCEDUREs that actually perform the edit  CheckNumberValue: PROCEDURE [item: FormSW.ItemHandle] =    BEGIN    WITH variant: item SELECT FROM      longNumber =>        IF variant.string.length = 0 THEN variant.value­ ¬ variant.default;      number =>        IF variant.string.length = 0 THEN variant.value­ ¬ variant.default;      ENDCASE => ERROR FormSW.Error[other];    END;  EditItem: PROCEDURE [args: EditItemArgs]    RETURNS [validate: BOOLEAN, offset: INTEGER] = {    -- Input assertions on args (caller must guarantee):    --   index IN [0..LENGTH[items])    --   ~(item.type = string AND length > 0 and ~EmptyString[string])    --   insert # NIL    validate ¬ FALSE;    offset ¬ 0;    IF args.item.flags.readOnly THEN {      args.myContext.readOnlyNotifyProc[args.myContext.sw, args.item, args.index];      RETURN;      };    FormSWOps.RealActOnCaret[args.myContext, clear];    WITH variant: args.item SELECT FROM      longNumber, number => {        IF args.length # 0 THEN NumberDelete[args];	IF ~String.EmptyString[args.string] THEN  NumberInsert[ args.myContext,	  args.item, args.diject, args.string, args.insert, args.select];	};      string => [validate, offset] ¬ StringEdit[args];      ENDCASE;    };  NumberDelete: PROCEDURE [args: EditItemArgs] =    -- args fields not used: index, new    BEGIN OPEN args;    [] ¬ TextDisplay.DeleteText[      diject, position, length, select, insert, keepTrash !      TextDisplay.RequestNewBoxHeight =>  -- should not happen        RESUME [diject.box.dims.h]];    IF UpdateNumberValue[item] THEN      BEGIN      s: LONG STRING ¬ Selection.ConvertTrashBin[string];      IF s = NIL THEN ERROR FormSW.Error[other];      UserTerminal.BlinkDisplay[];      NumberInsert[myContext, item, diject, s, insert, select];      String.FreeString[z, s];      END;    CheckNumberValue[item];    END;  NumberInsert: PROCEDURE [    context: FormSWOps.PContext, item: FormSW.ItemHandle,     diject: TextDisplay.Handle, string: LONG STRING,    insert: TextData.Insertion, select: TextData.Selection] =    BEGIN    i: CARDINAL ¬ 0;    badChar: BOOLEAN ¬ FALSE;    editAction: TextSource.EditAction;    char: CHARACTER ¬ string[i];    DO      BEGIN      ENABLE TextDisplay.RequestNewBoxHeight => RESUME [diject.box.dims.h];  -- should not happen      editAction ¬ backLine;  -- other than none      SELECT char FROM        MyBS => [] ¬ TextDisplay.DoEditAction[diject, select, insert, backSpace];        MyBW => [] ¬ TextDisplay.DoEditAction[diject, select, insert, backWord];        ENDCASE => {          editAction ¬ none;          [] ¬ TextDisplay.InsertCharacter[diject, char, select, insert];	  WITH variant: item SELECT FROM	    longNumber => 	      badChar ¬ IF (~variant.signed OR variant.notNegative) 	      AND char = '- THEN TRUE ELSE badChar;	    number =>	      badChar ¬ IF (~variant.signed OR variant.notNegative) 	      AND char = '- THEN TRUE ELSE badChar;	    ENDCASE};      END;      badChar ¬ badChar OR InitialCheck[item,char] OR UpdateNumberValue[item];      IF badChar AND editAction = none THEN {        UserTerminal.BlinkDisplay[]; char ¬ MyBS}      ELSE {IF (i ¬ i + 1) = string.length THEN EXIT; char ¬ string[i]};      ENDLOOP;    CheckNumberValue[item];    END;  InitialCheck: PROC [item: FormSW.ItemHandle, char: CHARACTER]   RETURNS [bad:BOOLEAN ¬ FALSE] = {    -- IF char is '- and (is item is a cardinal or nonnegative) return bad ¬ true    WITH variant: item SELECT FROM      longNumber =>         bad ¬ ((~variant.signed OR variant.notNegative) AND char = '-) OR 	((variant.radix = octal) AND (char IN ['8..'9]));      number =>        bad ¬ ((~variant.signed OR variant.notNegative) AND char = '-) OR 	((variant.radix = octal) AND (char IN ['8..'9]));      ENDCASE;    };      StringEdit: PROCEDURE [args: EditItemArgs]    RETURNS [validate: BOOLEAN, offset: INTEGER] =    -- If both a Delete and an Insert are done, funny things may happen.    BEGIN OPEN args;    maxH: INTEGER = Window.GetBox[myContext.sw].dims.h - FormSWOps.fontHeight;    oldInsertY: INTEGER ¬ insert.place.y;    saveDelta: INTEGER ¬ 0;    insertWasVisible: BOOLEAN ¬ (oldInsertY IN    [0..Window.GetBox[myContext.sw].dims.h));    sItem: FormSW.StringHandle =      WITH variant: item SELECT FROM        string => @variant,        ENDCASE => ERROR FormSW.Error[other];    validate ¬ TRUE;    offset ¬ 0;    BEGIN    ENABLE      TextDisplay.RequestNewBoxHeight =>        BEGIN         newH: INTEGER;	newH ¬ FormSWOps.NewBoxHeightRequested[myContext, index, delta];        saveDelta ¬ saveDelta + delta;        RESUME [newH]        END;    cut: BOOLEAN ¬ length > 0;    paste: BOOLEAN ¬ ~String.EmptyString[string];    SELECT TRUE FROM       cut AND paste => {	[] ¬ TextDisplay.ReplaceBlock[        p: diject, block: [LOOPHOLE[@string.text], 0, string.length],	pos: position, count: length, select: select, insert: insert,	keepTrash: keepTrash];	IF select # NIL THEN {	  select.left ¬ position;	  select.right ¬ position + string.length};	TextDisplay.Update[p: diject, from: position, to: position + length,	  select: select, clear: TRUE, charsDeleted: TRUE];	};      cut AND ~paste =>[] ¬ TextDisplay.DeleteText[        diject, position, length, select, insert, keepTrash];      ~cut AND paste => {        IF string.length = 1 THEN          SELECT string[0] FROM            MyBS =>              [] ¬ TextDisplay.DoEditAction[diject, select, insert, backSpace];            MyBW => [] ¬ TextDisplay.DoEditAction[	      diject, select, insert, backWord];            ENDCASE =>               [] ¬ TextDisplay.InsertBlock[                p: diject, block: [LOOPHOLE[@string.text], 0, string.length],                select: select, insert: insert]        ELSE           [] ¬ TextDisplay.InsertBlock[            p: diject, block: [LOOPHOLE[@string.text], 0, string.length],            select: select, insert: insert];        };      ENDCASE;    END;  -- of ENABLE    -- insert.place will have been forced to noPlace by InsertString    insert.place ¬ TextDisplay.WindowPlaceFromPosition[      diject, insert.position, FALSE, FALSE];    IF saveDelta = 0 THEN      BEGIN       IF insertWasVisible AND insert.place.x # TextDisplay.specialPlaceX        AND oldInsertY # insert.place.y AND ~(insert.place.y IN [0..maxH]) THEN        offset ¬ insert.place.y - oldInsertY;      END    ELSE      BEGIN      IF insertWasVisible THEN        -- Deletion can cause box underflow without moving insert up        --   because of word mode breaking.        BEGIN         IF insert.place.x = TextDisplay.specialPlaceX          OR (saveDelta < 0 AND insert.place.y < 0)          OR (saveDelta > 0 AND insert.place.y > maxH) THEN offset ¬ saveDelta;        END;      IF sItem.flags.drawBox THEN        ToolWindow.DrawRectangle[myContext.sw, diject.box, 1];      END;    END;  UpdateNumberValue: PROCEDURE [item: FormSW.ItemHandle]    RETURNS [badString: BOOLEAN] =    BEGIN     badString ¬ FALSE;    WITH variant: item SELECT FROM      longNumber =>         variant.value­ ¬ variant.bias + String.StringToLongNumber[          variant.string, IF variant.radix = octal THEN 8 ELSE  10 !          String.InvalidNumber =>            BEGIN badString ¬ (variant.string.length # 0); CONTINUE; END];      number =>        variant.value­ ¬ variant.bias + String.StringToNumber[          variant.string, IF variant.radix = octal THEN 8 ELSE 10 !          String.InvalidNumber =>            BEGIN badString ¬ (variant.string.length # 0); CONTINUE; END];      ENDCASE => ERROR FormSW.Error[other];    END;  Expand: PUBLIC PROC[window: Window.Handle] ={    myContext: FormSWOps.PContext = FormSWOps.FindContext[window];    block: Environment.Block;    new:LONG STRING;    start,end, next: TextSource.Position;    source:TextSource.Handle;    i, j: CARDINAL;    MAXKEY: CARDINAL = 30;    key: LONG STRING ¬ [MAXKEY];    IF myContext = NIL OR myContext.insertion.index = FormSW.nullIndex THEN       GOTO nope;    source ¬ myContext.dijects[myContext.insertion.index].source;    start ¬ myContext.insertion.textInsert.position;    end ¬ source.scanText[source, start - 1, word, left];    IF (start = end) OR ( start - end  > MAXKEY )  THEN GOTO nope;    new ¬ NIL;    [block, next] ¬ source.readText[source, end,       Inline.LowHalf[start - end], none];    IF block.stopIndexPlusOne = block.startIndex THEN GOTO nope;    key.length  ¬ block.stopIndexPlusOne - block.startIndex;    j ¬ 0;    FOR i IN [block.startIndex..block.stopIndexPlusOne) DO      key.text[j] ¬ LOOPHOLE[block.blockPointer[i], CHARACTER];      j ¬ j + 1;      ENDLOOP;    new ¬ Dictionary.LookUp[Dictionary.defaultDictionary, key];    IF new = NIL THEN GOTO nope;    FormSWOps.UnlockedActOnSelection[myContext, clear];    FormSWOps.RealActOnCaret[myContext, clear];    FormSWOps.ModifyInsertionState[myContext, change, start];    FormSWOps.ModifyInsertionState[myContext, append, start];    RealModifyEditable[myContext, myContext.insertion.index, Inline.LowHalf[end],       Inline.LowHalf[start - end], new, FALSE];    FormSWOps.ModifyInsertionState[myContext, append, start + new.length];    FormSWOps.ModifyInsertionState[myContext, change, start + new.length];    myContext.selection.textSelect.left ¬ myContext.selection.textSelect.right ¬       myContext.insertion.textInsert.position;    EXITS nope => UserTerminal.BlinkDisplay[];    };  ReplaceSelection: PUBLIC FormSWOps.ModifyProcType = {    myContext: FormSWOps.PContext = FormSWOps.FindContext[window];    start,end: TextSource.Position;    IF myContext = NIL OR myContext.selection.index = FormSW.nullIndex THEN {      UserTerminal.BlinkDisplay[];      RETURN};    start  ¬ myContext.selection.textSelect.left;    end    ¬ myContext.selection.textSelect.right;    FormSWOps.ModifyInsertionState[myContext, change, start];    FormSWOps.ModifyInsertionState[myContext, append, start];    RealModifyEditable[myContext, myContext.selection.index,       Inline.LowHalf[start], Inline.LowHalf[end - start], new, keepTrash];    IF new # NIL THEN {      FormSWOps.ModifyInsertionState[myContext, append, start + new.length];      FormSWOps.ModifyInsertionState[myContext, change, start + new.length]};    };  StuffString: PUBLIC FormSWOps.ModifyProcType = {    myContext: FormSWOps.PContext = FormSWOps.FindContext[window];    start: TextSource.Position;    IF myContext = NIL OR myContext.insertion.index = FormSW.nullIndex THEN {      UserTerminal.BlinkDisplay[];      RETURN};    start  ¬ myContext.insertion.textInsert.position;    FormSWOps.ModifyInsertionState[myContext, append, start - 1];    RealModifyEditable[myContext, myContext.selection.index,       Inline.LowHalf[start], 0, new, keepTrash];    IF new # NIL THEN {      FormSWOps.ModifyInsertionState[myContext, append, start + new.length];      FormSWOps.ModifyInsertionState[myContext, change, start + new.length]};    };            -- Main Line code  END. -- of FormSWsI.mesa
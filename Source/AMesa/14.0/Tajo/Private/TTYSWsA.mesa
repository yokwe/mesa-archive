-- Copyright (C) 1981, 1982, 1983  by Xerox Corporation. All rights reserved. -- File: TTYSWsA.mesa   last edit by:-- SXW   ,	10-Jul-81 18:34:49-- PXK    ,	22-Oct-82 17:59:53-- JGS,		24-Nov-81 17:56:02-- SXS   ,	21-Oct-82 12:20:33-- LXR    ,	11-Oct-82 13:32:00-- RXR   ,	28-Oct-81 16:58:09-- BGY     ,	 1-Feb-83 18:24:01-- CXH   ,	27-Oct-82 16:35:58-- AXD    	26-Jan-83 20:13:59DIRECTORY  ByteBlt: TYPE USING [ByteBlt],  Context: TYPE USING [Create, Destroy, Find, NopDestroyProc, Type, UniqueType],  Environment: TYPE USING [Block],  Event: TYPE USING [toolWindow],  EventTypes: TYPE USING [activate, deactivate],  FileSW: TYPE USING [Create, Destroy, GetFile, SetTypescriptSize],  Heap: TYPE USING [systemZone],  Inline: TYPE USING [LowHalf],  Process: TYPE USING [EnableAborts],  Scrollbar: TYPE USING [Adjust],  Stream: TYPE USING [    Block, defaultInputOptions, defaultObject, GetProcedure, Handle,    InputOptions, Object, PutProcedure, SendAttentionProcedure,    SetSSTProcedure, SubSequenceType, WaitAttentionProcedure],  String: TYPE USING [CopyToNewString, EmptyString, FreeString],  Supervisor: TYPE USING [    AddDependency, AgentProcedure, CreateSubsystem, SubsystemHandle],  TextSW: TYPE USING [    Adjust, DoEditAction, InsertBlock, Options,     SetEOF, SetPosition, Sleep, Wakeup],  TIP: TYPE USING [globalTable, SetTable],  ToolWindow: TYPE,  TTY: TYPE USING [    BackingStream, CharsAvailable, CharStatus, Create, Destroy, EchoClass,    GetChar, GetDecimal, GetEcho, GetEditedString, GetID, GetLine, GetLongDecimal,    GetLongNumber, GetLongOctal, GetNumber, GetOctal, GetPassword, GetString,    Handle, LineOverflow, NewLine, nullHandle, PopAlternateInputStreams,    PushAlternateInputStream, PutBackChar, PutChar, PutString, RemoveCharacter,    Rubout, SetEcho],  TTYConstants: TYPE USING [    aborted, blinkDisplay, normal, notAborted, removeChars, setBackingSize],  TTYSW: TYPE USING [defaultOptions, ErrorCode],  TTYSWOps: TYPE USING [],  UserInput: TYPE USING [    ClearInputFocusOnMatch, CreatePeriodicNotify, PeriodicProcType,    ResetUserAbort, SetStringIn, SetUserAbort, StringProcType,    UserAbort],  UserTerminal: TYPE USING [BlinkDisplay],  Window: TYPE USING [Box, Handle, SlideAndSize];  TTYSWsA: MONITOR  IMPORTS    ByteBlt, Context, Event, FileSW, Heap, Inline, Process,    Scrollbar, Stream, String, Supervisor, TIP, TextSW, ToolWindow,    TTY, UserInput, UserTerminal, Window  EXPORTS TTYSW, TTYSWOps =  BEGIN OPEN TTYSW;  ttyType: Context.Type ¬ Context.UniqueType[];  z: UNCOUNTED ZONE = Heap.systemZone;  LineOverflow: PUBLIC SIGNAL [s: LONG STRING] RETURNS [ns: LONG STRING] = CODE;  Rubout: PUBLIC SIGNAL = CODE;  ttyPassword: CARDINAL = 1436B;    ContextObject: TYPE = RECORD [    logFileName: LONG STRING ¬ NIL,     tty: TTY.Handle,    stream: Stream.Handle];  ContextHandle: TYPE = LONG POINTER TO ContextObject;  Chars: TYPE = LONG POINTER TO CharsObject;  CharsObject: TYPE = RECORD [    first, lastPlusOne: CARDINAL ¬ 0, length: CARDINAL,    chars: PACKED SEQUENCE COMPUTED CARDINAL OF CHARACTER ¬ NULL];  myHandle: TYPE = LONG POINTER TO StreamObject;  StreamObject: TYPE = RECORD [    stream: Stream.Object,    haveChar: CONDITION,    chars: Chars ¬ NIL,    password: CARDINAL ¬ ttyPassword,    sw: Window.Handle ¬ NIL,    weCreatedTool: BOOLEAN ¬ FALSE,    gone: BOOLEAN ¬ FALSE,    aborting: BOOLEAN ¬ FALSE,    inputBlock: LONG POINTER TO Environment.Block ¬ NIL,    bytesTransferred: CARDINAL ¬ 0,    mode: Stream.SubSequenceType ¬ TTYConstants.normal,    modeVal: LONG CARDINAL ¬ 0];  Error: PUBLIC SIGNAL [code: TTYSW.ErrorCode] = CODE;    -- Starting & stopping routines   Create: PUBLIC PROC [    sw: Window.Handle, backupFile: LONG STRING, s: Stream.Handle ¬ NIL,    newFile: BOOLEAN ¬ TRUE, options: TextSW.Options ¬ TTYSW.defaultOptions,    resetLengthOnNewSession: BOOLEAN ¬ FALSE] = {      CreateInternal[        sw, backupFile, s, newFile, options, resetLengthOnNewSession]};    CreateInternal: PROC [    sw: Window.Handle, backupFile: LONG STRING, s: Stream.Handle ¬ NIL,    newFile: BOOLEAN ¬ TRUE, options: TextSW.Options ¬ TTYSW.defaultOptions,    resetLengthOnNewSession: BOOLEAN ¬ FALSE, tty: TTY.Handle ¬ TTY.nullHandle] = {    h: myHandle;    context: ContextHandle = Heap.systemZone.NEW[      ContextObject ¬ [      logFileName: String.CopyToNewString[backupFile, Heap.systemZone],      tty: tty, stream: NIL]];    FileSW.Create[      sw: sw, name: context.logFileName, options: options,      s: s, resetLengthOnNewSession: resetLengthOnNewSession];    context.stream ¬ CreateStream[sw];    h ¬ ConvertHandle[context.stream];    h.weCreatedTool ¬ context.tty # TTY.nullHandle;    IF ~h.weCreatedTool THEN      context.tty ¬ TTY.Create[        name: backupFile, backingStream: FileSW.GetFile[sw].s, 	ttyImpl: context.stream];    IF newFile THEN {TextSW.SetEOF[sw, 0]; TextSW.SetPosition[sw, 0]};    Context.Create[ttyType, context, DestroyTTYContext, sw];    [] ¬ UserInput.SetStringIn[sw, StringInput];    [] ¬ TIP.SetTable[window: sw, table: TIP.globalTable[ttySW]];    };    Destroy: PUBLIC PROC [sw: Window.Handle] = {    Context.Destroy[ttyType, sw];    FileSW.Destroy[sw]};  DestroyFromBackgroundProcess: PUBLIC PROC [sw: Window.Handle] = {    tty: ContextHandle = Context.Find[ttyType, sw];    IF tty = NIL THEN Error[notATTYSW];    [] ¬ UserInput.CreatePeriodicNotify[ReallyDestroyFromBackground, sw, 0]};     ReallyDestroyFromBackground: UserInput.PeriodicProcType = {    tty: ContextHandle = Context.Find[ttyType, window];    Context.Destroy[ttyType, window];    FileSW.Destroy[window]};    -- Stuff for dealing with default TTY instances    watchDefaultWindows: Supervisor.SubsystemHandle = Supervisor.CreateSubsystem[    agent: FakeTransition];  defaultType: Context.Type = Context.UniqueType[];    CreateTTYInstance: PUBLIC PROC [    name: LONG STRING, backingStream: Stream.Handle, tty: TTY.Handle]    RETURNS [ttyImpl: Stream.Handle, backing: Stream.Handle] = {    window: Window.Handle = ToolWindow.Create[      name: name, adjust: Adjust, transition: NIL];    sw: Window.Handle = ToolWindow.CreateSubwindow[parent: window];    context: ContextHandle;    CreateInternal[sw: sw, backupFile: name, s: backingStream, tty: tty];    Context.Create[      type: defaultType, data: sw, proc: Context.NopDestroyProc, window: window];    ToolWindow.Show[window];    context ¬ Context.Find[ttyType, sw];    RETURN[ttyImpl: context.stream, backing: FileSW.GetFile[sw].s]};  Adjust: ToolWindow.AdjustProcType = {    sw: Window.Handle = Context.Find[defaultType, window];    scrollBar: Window.Handle;    scrollBox: Window.Box;    IF sw = NIL THEN RETURN;    [box, scrollBar, scrollBox, , ] ¬ Scrollbar.Adjust[sw, box];    IF when = before THEN TextSW.Adjust[sw, box, when]    ELSE {      IF scrollBar # NIL THEN scrollBar.SlideAndSize[        newBox: scrollBox, gravity: nw];      sw.SlideAndSize[newBox: box, gravity: nw];      TextSW.Adjust[sw, box, when]}};    FakeTransition: Supervisor.AgentProcedure = {    sw: Window.Handle = Context.Find[defaultType, eventData];    IF sw = NIL THEN RETURN;    SELECT event FROM      EventTypes.deactivate => {        UserInput.ClearInputFocusOnMatch[sw];	TextSW.Sleep[sw]};      EventTypes.activate => TextSW.Wakeup[sw];      ENDCASE};      -- Input control routines  SetBackingSize: PUBLIC PROC [sw: Window.Handle, size: LONG CARDINAL] = {    FileSW.SetTypescriptSize[sw, size]};      GetTTYHandle: PUBLIC PROC [sw: Window.Handle] RETURNS [TTY.Handle] = {    tty: ContextHandle = Context.Find[ttyType, sw];    RETURN[IF tty = NIL THEN TTY.nullHandle ELSE tty.tty]};   IsIt: PUBLIC PROC [sw: Window.Handle] RETURNS [yes: BOOLEAN] = {    RETURN[Context.Find[ttyType, sw] # NIL]};   EndOf: PUBLIC PROC [sw: Window.Handle] RETURNS [yes: BOOLEAN] = {    RETURN[CharsAvailable[sw] = 0]};  StringInput: PUBLIC ENTRY UserInput.StringProcType = {    ENABLE UNWIND => NULL;    stream: Stream.Handle = GetStream[window];    h: myHandle = ConvertHandle[stream];    start: CARDINAL ¬ 0;    need: CARDINAL;    IF String.EmptyString[string] THEN RETURN;    IF h.inputBlock # NIL THEN { -- input process already waiting      bytes: CARDINAL = ByteBlt.ByteBlt[        from: [LOOPHOLE[@string.text], 0, string.length], to: h.inputBlock­];      h.bytesTransferred ¬ h.bytesTransferred + bytes;      h.inputBlock.startIndex ¬ h.inputBlock.startIndex + bytes;      NOTIFY h.haveChar;      IF bytes = string.length THEN RETURN;      start ¬ bytes};    need ¬ string.length - start;    IF h.chars = NIL THEN h.chars ¬ NewCharBuffer[need + 10]    ELSE IF h.chars.lastPlusOne + need > h.chars.length THEN {      temp: Chars = NewCharBuffer[        h.chars.lastPlusOne - h.chars.first + need + 10];      -- temp.first ¬ 0; done by NEW      temp.lastPlusOne ¬ ByteBlt.ByteBlt[        from: [         blockPointer: LOOPHOLE[@h.chars.chars],	 startIndex: h.chars.first, stopIndexPlusOne: h.chars.lastPlusOne],        to: [          blockPointer: LOOPHOLE[@temp.chars],	  startIndex: temp.first, stopIndexPlusOne: temp.length]];      z.FREE[@h.chars];      h.chars ¬ temp};    IF ByteBlt.ByteBlt[      from: [LOOPHOLE[@string.text], start, string.length],      to: [        blockPointer: LOOPHOLE[@h.chars.chars],        startIndex: h.chars.lastPlusOne,        stopIndexPlusOne: h.chars.length]] # need THEN ERROR;    h.chars.lastPlusOne ¬ h.chars.lastPlusOne + need};  -- Output routines  AppendString: PUBLIC UserInput.StringProcType = {    ttyCtx: ContextHandle = Context.Find[ttyType, window];    IF ttyCtx = NIL OR ttyCtx.tty = TTY.nullHandle THEN Error[notATTYSW];    ttyCtx.tty.PutString[string]};  AppendChar: PUBLIC PROC [sw: Window.Handle, char: CHARACTER] = {    ttyCtx: ContextHandle = Context.Find[ttyType, sw];    IF ttyCtx = NIL OR ttyCtx.tty = TTY.nullHandle THEN Error[notATTYSW];    ttyCtx.tty.PutChar[char]};  -- Private routines  NewCharBuffer: PROC [size: CARDINAL] RETURNS [Chars] = {    RETURN[z.NEW[CharsObject[size] ¬ [length: size]]]};  DestroyTTYContext: PUBLIC PROC [    ttyCtx: ContextHandle, sw: Window.Handle] = {    tty: TTY.Handle = ttyCtx.tty;    String.FreeString[z, ttyCtx.logFileName];    IF tty # TTY.nullHandle THEN tty.Destroy; -- will delete ttyCtx.stream    z.FREE[@ttyCtx]};  CreateStream: PUBLIC PROC [sw: Window.Handle] RETURNS [Stream.Handle] = {    options: Stream.InputOptions ¬ Stream.defaultInputOptions;    h: myHandle ¬ z.NEW[      StreamObject ¬ [      stream: Stream.defaultObject, chars: NIL, password: ttyPassword, sw: sw,      inputBlock: NIL, bytesTransferred: 0]];    Process.EnableAborts[@h.haveChar];    h.stream.get ¬ GetBlock;    h.stream.put ¬ PutBlock;    h.stream.delete ¬ Delete;    h.stream.waitAttention ¬ WaitAttention;    h.stream.sendAttention ¬ SendAttention;    h.stream.setSST ¬ SetSST;    RETURN[@h.stream]};  GetBlock: ENTRY Stream.GetProcedure = {    ENABLE UNWIND => NULL;    h: myHandle ¬ CheckHandle[ConvertHandle[sH]];    sst ¬ 0;    why ¬ normal;    IF h.chars # NIL THEN {      bytesTransferred ¬ ByteBlt.ByteBlt[        from: [          blockPointer: LOOPHOLE[@h.chars.chars],	  startIndex: h.chars.first,          stopIndexPlusOne: h.chars.lastPlusOne],        to: block];      h.chars.first ¬ h.chars.first + bytesTransferred;      IF h.chars.first = h.chars.lastPlusOne THEN z.FREE[@h.chars];      RETURN};    h.bytesTransferred ¬ 0;    h.inputBlock ¬ @block;    WHILE h.bytesTransferred = 0 DO WAIT h.haveChar; ENDLOOP;    bytesTransferred ¬ h.bytesTransferred;    h.inputBlock ¬ NIL};  PutBlock: ENTRY Stream.PutProcedure = {    ENABLE UNWIND => NULL;    h: myHandle = CheckHandle[ConvertHandle[sH]];    SELECT h.mode FROM      TTYConstants.normal => TextSW.InsertBlock[h.sw, block];      TTYConstants.setBackingSize, TTYConstants.removeChars => {	FOR i: CARDINAL IN [block.startIndex..block.stopIndexPlusOne) DO	  h.modeVal ¬ h.modeVal*256 + block.blockPointer[i];	  ENDLOOP};      ENDCASE};  Delete: ENTRY PROC [stream: Stream.Handle] = {    ENABLE UNWIND => NULL;    h: myHandle ¬ CheckHandle[h: ConvertHandle[stream], abortOk: TRUE];    IF h.chars # NIL THEN z.FREE[@h.chars];    IF h.weCreatedTool THEN {      window: Window.Handle = ToolWindow.WindowForSubwindow[h.sw];      ttyCtx: ContextHandle = Context.Find[ttyType, h.sw];      IF ttyCtx # NIL THEN ttyCtx.tty ¬ TTY.nullHandle;      -- ... so that destroying the tool window won't call Delete again      Context.Destroy[defaultType, window];      [] ¬ UserInput.CreatePeriodicNotify[	proc: RealDelete, window: window, rate: 0]};     z.FREE[@h]};  RealDelete: UserInput.PeriodicProcType = {    IF window # NIL THEN ToolWindow.Destroy[window]};      WaitAttention: ENTRY Stream.WaitAttentionProcedure = {    ENABLE UNWIND => NULL;    RETURN[IF UserInput.UserAbort[CheckHandle[ConvertHandle[sH]].sw] THEN       TTYConstants.aborted ELSE TTYConstants.notAborted]};  SendAttention: ENTRY Stream.SendAttentionProcedure = {    ENABLE UNWIND => NULL;    SELECT byte FROM      TTYConstants.aborted =>         UserInput.SetUserAbort[CheckHandle[ConvertHandle[sH]].sw];      TTYConstants.notAborted =>         UserInput.ResetUserAbort[CheckHandle[ConvertHandle[sH]].sw];      ENDCASE};  SetSST: ENTRY Stream.SetSSTProcedure = {    ENABLE UNWIND => NULL;    h: myHandle = CheckHandle[ConvertHandle[sH]];    SELECT h.mode FROM      TTYConstants.removeChars =>         FOR i: CARDINAL IN [0..Inline.LowHalf[h.modeVal]) DO          [] ¬ TextSW.DoEditAction[h.sw, backSpace]; ENDLOOP;      TTYConstants.setBackingSize => FileSW.SetTypescriptSize[h.sw, h.modeVal];      TTYConstants.blinkDisplay => UserTerminal.BlinkDisplay[];      ENDCASE;    h.mode ¬ sst;    h.modeVal ¬ 0};  CheckHandle: INTERNAL PROC [h: myHandle, abortOk: BOOLEAN ¬ FALSE]     RETURNS [myHandle] = {    ENABLE UNWIND => NULL;    SELECT TRUE FROM      h = NIL => Error[notATTYSW];       ~abortOk AND h.aborting => {        h.gone ¬ TRUE; NOTIFY h.haveChar; ERROR ABORTED};      h.password = ttyPassword => NULL;      ENDCASE => Error[notATTYSW];    RETURN[h]};      ConvertHandle: PROC [stream: Stream.Handle] RETURNS [myHandle] = INLINE {    RETURN[LOOPHOLE[stream, myHandle]]};  GetStream: PROC [sw: Window.Handle] RETURNS [stream: Stream.Handle] = INLINE {    tty: ContextHandle = Context.Find[ttyType, sw];    stream ¬ tty.stream};  -- these routines just call TTY to do the work  CharsAvailable: PUBLIC PROC [sw: Window.Handle]    RETURNS [number: CARDINAL] = {    RETURN GetTTYHandle[sw].CharsAvailable[]};  GetChar: PUBLIC PROC [sw: Window.Handle] RETURNS [c: CHARACTER] = {    RETURN GetTTYHandle[sw].GetChar[]};  GetEditedString: PUBLIC PROC [    sw: Window.Handle, s: LONG STRING,    t: PROC [CHARACTER] RETURNS [TTY.CharStatus]] RETURNS [CHARACTER] = {    ENABLE {      TTY.LineOverflow => {RESUME[SIGNAL LineOverflow[s]]};      TTY.Rubout => {SIGNAL Rubout; RESUME}};    RETURN GetTTYHandle[sw].GetEditedString[s, t]};  GetID: PUBLIC PROC [sw: Window.Handle, s: LONG STRING] = {    ENABLE {      TTY.LineOverflow => {RESUME[SIGNAL LineOverflow[s]]};      TTY.Rubout => {SIGNAL Rubout; RESUME}};    GetTTYHandle[sw].GetID[s]};  GetLine: PUBLIC PROC [sw: Window.Handle, s: LONG STRING] = {    ENABLE {      TTY.LineOverflow => {RESUME[SIGNAL LineOverflow[s]]};      TTY.Rubout => {SIGNAL Rubout; RESUME}};    GetTTYHandle[sw].GetLine[s]};  GetPassword: PUBLIC PROC [sw: Window.Handle, s: LONG STRING] = {     ENABLE {      TTY.LineOverflow => {RESUME[SIGNAL LineOverflow[s]]};      TTY.Rubout => {SIGNAL Rubout; RESUME}};    GetTTYHandle[sw].GetPassword[s]};  GetString: PUBLIC PROC [    sw: Window.Handle, s: LONG STRING,    t: PROC [CHARACTER] RETURNS [TTY.CharStatus]] = {     ENABLE {      TTY.LineOverflow => {RESUME[SIGNAL LineOverflow[s]]};      TTY.Rubout => {SIGNAL Rubout; RESUME}};    GetTTYHandle[sw].GetString[s, t]};  RemoveCharacter, RemoveCharacters: PUBLIC PROC [    sw: Window.Handle, n: CARDINAL ¬ 1] = {    GetTTYHandle[sw].RemoveCharacter[n]};  NewLine: PUBLIC PROC [sw: Window.Handle] RETURNS [BOOLEAN] = {    RETURN GetTTYHandle[sw].NewLine[]};  PutBackChar: PUBLIC PROC [sw: Window.Handle, char: CHARACTER] = {    GetTTYHandle[sw].PutBackChar[char]};  GetEcho: PUBLIC PROC [sw: Window.Handle] RETURNS [old: TTY.EchoClass] = {    RETURN GetTTYHandle[sw].GetEcho[]};  SetEcho: PUBLIC PROC [sw: Window.Handle, new: TTY.EchoClass]    RETURNS [old: TTY.EchoClass] = {    RETURN GetTTYHandle[sw].SetEcho[new]};  PopAlternateInputStreams: PUBLIC PROC [    sw: Window.Handle, howMany: CARDINAL ¬ 1] = {    GetTTYHandle[sw].PopAlternateInputStreams[howMany]};  PushAlternateInputStream, PushAlternateInputStreams: PUBLIC PROC [    sw: Window.Handle, stream: Stream.Handle] = {    GetTTYHandle[sw].PushAlternateInputStream[stream]};  BackingStream: PUBLIC PROC [sw: Window.Handle] RETURNS [Stream.Handle] = {    RETURN GetTTYHandle[sw].BackingStream[]};  GetDecimal: PUBLIC PROC [sw: Window.Handle] RETURNS [INTEGER] = {    RETURN GetTTYHandle[sw].GetDecimal[]};  GetNumber: PUBLIC PROC [    sw: Window.Handle, default: UNSPECIFIED, radix: CARDINAL,    showDefault: BOOLEAN ¬ TRUE] RETURNS [UNSPECIFIED] = {    RETURN GetTTYHandle[sw].GetNumber[default, radix, showDefault]};  GetOctal: PUBLIC PROC [sw: Window.Handle] RETURNS [UNSPECIFIED] = {    RETURN GetTTYHandle[sw].GetOctal[]};  GetLongDecimal: PUBLIC PROC [sw: Window.Handle] RETURNS [LONG INTEGER] = {    RETURN GetTTYHandle[sw].GetLongDecimal[]};  GetLongNumber: PUBLIC PROC [    sw: Window.Handle, default: LONG UNSPECIFIED, radix: CARDINAL,    showDefault: BOOLEAN ¬ TRUE] RETURNS [LONG UNSPECIFIED] = {    RETURN GetTTYHandle[sw].GetLongNumber[default, radix, showDefault]};  GetLongOctal: PUBLIC PROC [sw: Window.Handle] RETURNS [LONG UNSPECIFIED] = {    RETURN GetTTYHandle[sw].GetLongOctal[]};  -- silliness to get Expand to go though the tty input      {Supervisor.AddDependency[    client: watchDefaultWindows, implementor: Event.toolWindow]};    END. -- of TTYSWsA.mesa
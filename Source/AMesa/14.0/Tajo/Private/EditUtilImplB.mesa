-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved. -- EditUtilImplB.mesa-- LastEdit: --  BGY     	21-Nov-83  9:26:25--  AXD    	26-Apr-84 16:49:09DIRECTORY  Context: TYPE USING [Find],  EditUtil: TYPE USING [],  FormSW: TYPE USING [    Display, FindItem, GetSelection, GetTypeIn, ItemHandle, NeededHeight,    SetSelection, SetTypeIn],  Scrollbar: TYPE USING [Adjust],  Selection: TYPE USING [Convert, ConvertInsertion],  TajoMisc: TYPE USING [FindClippingWindow],  TextSWOps: TYPE USING [lock],  ToolOps: TYPE USING [AdjustProc, bdryHeight, context, ContextHandle],  ToolWindow: TYPE USING [AdjustProcType, Handle, WindowForSubwindow],  Window: TYPE USING [    Box, GetBox, GetParent, Handle, InvalidateBox, SlideAndSize, ValidateTree];EditUtilImplB: MONITOR LOCKS TextSWOps.lock  IMPORTS     Context, FormSW, Scrollbar, Selection, TajoMisc,     TextSWOps, ToolOps, ToolWindow, Window  EXPORTS EditUtil = {    Items: TYPE = {    all, find, findRep, pattern, repFind, replace, new, iRepFind, iReplace, iNew};  ToggleForm: PUBLIC PROC[sw: Window.Handle] = {    bigger: BOOLEAN ¬ ~FormSW.FindItem[sw, Items.repFind.ORD].flags.invisible;    fixSelection, fixInsertion: BOOLEAN ¬ FALSE;    item: FormSW.ItemHandle;    inIndex,selIndex, selStart, selEnd, inPos: CARDINAL ¬ 0;    FOR j: Items IN [repFind..iNew] DO      item ¬ FormSW.FindItem[sw, j.ORD];      item.flags.invisible ¬ ~item.flags.invisible;      ENDLOOP;    item ¬ FormSW.FindItem[sw, Items.pattern.ORD];    WITH i: item SELECT FROM      string => i.boxWidth ¬ IF bigger THEN 0 ELSE 120; ENDCASE;    IF Selection.Convert[subwindow] = sw THEN {      [selIndex, selStart, selEnd] ¬ FormSW.GetSelection[sw];      IF bigger THEN {        IF selIndex = Items.new.ORD THEN {	  selIndex ¬ Items.iNew.ORD;	  fixSelection ¬ TRUE;	  selStart ¬ selStart + 3; selEnd ¬ selEnd + 3;	  }	}      ELSE IF selIndex = Items.iNew.ORD THEN {        selIndex ¬ Items.new.ORD;	fixSelection ¬ TRUE;	selStart ¬ selStart + 3; selEnd ¬ selEnd + 3;	};      };    IF Selection.ConvertInsertion[subwindow] = sw THEN {      [inIndex, inPos] ¬ FormSW.GetTypeIn[sw];      IF bigger THEN {        IF inIndex = Items.new.ORD THEN {	  inIndex ¬ Items.iNew.ORD;	  fixInsertion ¬ TRUE}	}      ELSE IF inIndex = Items.iNew.ORD THEN {        inIndex ¬ Items.new.ORD;	fixInsertion ¬ TRUE};      };    IF fixSelection THEN FormSW.SetSelection[sw, selIndex, selStart, selEnd];    IF fixInsertion THEN FormSW.SetTypeIn[sw, inIndex, inPos];    FormSW.Display[sw];    AdjustBoxSize[sw, bigger];    };        AdjustBoxSize: PROC [sw: Window.Handle, bigger: BOOLEAN]= {    clip: Window.Handle ¬ TajoMisc.FindClippingWindow[sw];    tool: Window.Handle ¬ ToolWindow.WindowForSubwindow[sw];    tch: ToolOps.ContextHandle ¬ Context.Find[ToolOps.context,tool];    i: CARDINAL ¬ GetSWIndex[sw,tch];    topsw: Window.Handle ¬ sw;    botsw: Window.Handle ¬ tch.sws[i+1].sw;    newHeight: CARDINAL ¬ FormSW.NeededHeight[sw].min;    newTop: Window.Box ¬ topsw.GetBox[];    newBot: Window.Box ¬ botsw.GetBox[];    delta: CARDINAL;    IF newHeight <= ABS[newTop.dims.h] AND bigger THEN RETURN;    IF bigger THEN {        delta ¬ newHeight - newTop.dims.h;	newTop ¬ [[x:0, y: newTop.place.y], [w: tch.w, h: newHeight]];        newBot ¬ [	  [x:0, y: newBot.place.y + delta], 	  [w: tch.w, h: newBot.dims.h - delta]];	AdjustSubwindow[botsw, ToolOps.AdjustProc[tch.sws[i+1].type], newBot];	AdjustSubwindow[topsw, ToolOps.AdjustProc[tch.sws[i].type], newTop]}      ELSE {        delta ¬ newTop.dims.h - newHeight;        newTop ¬ [[0,newTop.place.y], [w: tch.w, h: newHeight]];        newBot ¬ [	  [x:0, y: newBot.place.y - delta],	  [w: tch.w, h: newBot.dims.h + delta]];	AdjustSubwindow[topsw, ToolOps.AdjustProc[tch.sws[i].type], newTop];	AdjustSubwindow[botsw, ToolOps.AdjustProc[tch.sws[i+1].type], newBot]};      tch.boxes[i] ¬ [h: newTop.dims.h, y: newTop.place.y];      tch.boxes[i + 1] ¬ [h: newBot.dims.h, y: newBot.place.y];    clip.InvalidateBox[[         place: [x: 0, y: tch.boxes[i + 1].y - ToolOps.bdryHeight],	dims: [h: ToolOps.bdryHeight, w: tch.w]], isDirty];    clip.GetParent.ValidateTree[];    };    GetSWIndex: PROC[sw: Window.Handle, tch: ToolOps.ContextHandle]     RETURNS[i: CARDINAL] = {    FOR i IN [0..tch.sws.length) DO      IF sw = tch.sws[i].sw THEN EXIT      ENDLOOP;};      AdjustSubwindow: PROC [    sw: Window.Handle, adjust: ToolWindow.AdjustProcType, box: Window.Box] = {    -- not optimal, but this is only used on invisible windows    hBox, vBox: Window.Box;    hScroll, vScroll: Window.Handle;    [box, vScroll, vBox, hScroll, hBox] ¬ Scrollbar.Adjust[sw, box];    IF hScroll # NIL THEN hScroll.SlideAndSize[hBox, nw];    IF vScroll # NIL THEN vScroll.SlideAndSize[vBox, nw];    adjust[sw, box, before];    sw.SlideAndSize[box, nw];    adjust[sw, box, after]};  }...
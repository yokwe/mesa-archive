-- Copyright (C) 1981, 1982  by Xerox Corporation. All rights reserved. -- File: TextDisplaysB.mesa - last edited by:-- PXK    ,	16-Nov-82 10:51:14-- SXW   ,	 9-Jul-81 22:37:08-- Mark,	Oct 13, 1980 12:38 PM-- JGS,		19-Aug-81  7:29:48-- AXD    ,	11-Nov-82 15:07:18-- Contains selection stuffDIRECTORY  Environment USING [Block],  Inline USING [LowHalf],  TextData USING [    Insertion, MarkingAction, Selection, SelectionEntity, SelectionMode],  TextDisplay USING [    CharsInLine, GetEndPlaces, Handle, LastLine, LineStartPlace, LineTable,    MarkInsertion, MarkPlaceInterval, noPlace, Place, PlaceFromPosition],  TextSink USING [BreakReason, FontInfo, Handle, Resolve],  TextSource USING [GetLength, Handle, Position, ReadText, ScanText, ScanType],  Window USING [Box, Handle, InvalidateBox, Place];TextDisplaysB: PROGRAM  IMPORTS Inline, TextDisplay, TextSink, TextSource, Window  EXPORTS TextDisplay =  BEGIN OPEN TextData, TD: TextDisplay, TextSource;  -- Some local defs  NilSelectionIsInvalid: ERROR = CODE;  NilInsertionIsInvalid: ERROR = CODE;  noPlace: Window.Place = TextDisplay.noPlace;  -- Interface routines  MarkSelection: PUBLIC PROC [    p: TextDisplay.Handle, select: Selection, action: MarkingAction] = {    IF select # NIL      AND        (action = invert OR (action = clear AND select.marked)          OR (action = mark AND ~select.marked)) THEN {      clear: BOOLEAN =        ~(select.mode = video           OR ~select.marked AND (action = invert OR action = mark));      MyMarkPositionInterval[p, select.left, select.right, select.mode, clear];      select.marked ¬ ~select.marked}};  MoveInsertion: PUBLIC PROC [    p: TextDisplay.Handle, swPlace: Window.Place, insert: Insertion,    minPos: Position ¬ 0] = {    position: Position;    place: Window.Place;    IF insert = NIL THEN ERROR NilInsertionIsInvalid;    [position, place] ¬ PositionFromWindowPlace[p, swPlace, TRUE];    p.MarkInsertion[insert, clear];    insert.position ¬ MAX[minPos, position];    insert.place ¬ IF insert.position = position THEN place ELSE noPlace};  UpdateSelection: PUBLIC PROC [p: TextDisplay.Handle, old, new: Selection] = {    -- assumes MarkingAction = mark    leftPosition, rightPosition: Position;    IF old = NIL OR new = NIL THEN ERROR NilSelectionIsInvalid;    SELECT TRUE FROM      ~old.marked => MarkPositionInterval[p, new.left, new.right, new.mode];      new.mode # old.mode OR old.left > new.right OR new.left > old.right => {        MarkPositionInterval[p, old.left, old.right, old.mode];        MarkPositionInterval[p, new.left, new.right, new.mode]};      ENDCASE => {        IF new.left # old.left THEN {          IF new.left < old.left THEN {	    leftPosition ¬ new.left; rightPosition ¬ old.left}          ELSE {leftPosition ¬ old.left; rightPosition ¬ new.left};          MarkPositionInterval[p, leftPosition, rightPosition, new.mode]};        IF new.right # old.right THEN {          IF new.right > old.right THEN {	    leftPosition ¬ old.right; rightPosition ¬ new.right}          ELSE {leftPosition ¬ new.right; rightPosition ¬ old.right};          MarkPositionInterval[p, leftPosition, rightPosition, new.mode]}};    new.marked ¬ TRUE;    old.marked ¬ FALSE};  -- Public Utility routines  ExtendPositionInterval: PUBLIC PROC [    p: TextDisplay.Handle, left, right: Position, entity: SelectionEntity]    RETURNS [Position, Position] = {    type: TextSource.ScanType;    source: TextSource.Handle = p.source;    SELECT entity FROM      text => RETURN[left, MIN[left + 1, source.GetLength]];      word => type ¬ word;      line => type ¬ line;      document => RETURN[0, source.GetLength];      ENDCASE;    left ¬ source.ScanText[left, type, left];    right ¬ source.ScanText[      MAX[left, IF right > 0 THEN right - 1 ELSE 0], type, right];    RETURN[left, right]};  MarkLineInterval: PUBLIC PROC [    p: TextDisplay.Handle, line, left, right: CARDINAL, mode: SelectionMode] = {    MyMarkLineInterval[p, line, left, right, mode, FALSE]};  MyMarkLineInterval: PROC [    p: TextDisplay.Handle, line, left, right: CARDINAL, mode: SelectionMode,    clear: BOOLEAN] = {    leftPlace, rightPlace: Window.Place;    [leftPlace, rightPlace] ¬ p.GetEndPlaces[line, left, right];    IF clear THEN      p.wh.InvalidateBox[[        leftPlace, [        rightPlace.x - leftPlace.x, p.sink.FontInfo.lineHeight]]]    ELSE p.MarkPlaceInterval[leftPlace, rightPlace, mode, 0]};  MarkPositionInterval: PUBLIC PROC [    p: TextDisplay.Handle, left, right: Position, mode: SelectionMode] = {    MyMarkPositionInterval[p, left, right, mode, FALSE]};  MyMarkPositionInterval: PROC [    p: TextDisplay.Handle, left, right: Position, mode: SelectionMode,    clear: BOOLEAN] = {    i, l, r: CARDINAL;    leftPlace, rightPlace: TextDisplay.Place;    lineTable: TextDisplay.LineTable = p.lineTable;    IF (left < lineTable[0].pos AND right < lineTable[0].pos)      OR        (left > lineTable.lastPositionPlusOne          AND right > lineTable.lastPositionPlusOne) THEN RETURN;    leftPlace ¬ p.PlaceFromPosition[left, TRUE];    rightPlace ¬ p.PlaceFromPosition[right, TRUE];    FOR i IN [leftPlace.line..rightPlace.line] DO      [l, r] ¬ SelectionInterval[p, i, leftPlace, rightPlace];      MyMarkLineInterval[p, i, l, r, mode, clear];      ENDLOOP};  PositionFromWindowPlace: PUBLIC PROC [    p: TextDisplay.Handle, place: Window.Place, halfCharResolve: BOOLEAN ¬ FALSE]    RETURNS [position: Position, positionPlace: Window.Place] = {    positionsLeftInLine, line, positions: CARDINAL;    maxPosOnLine: Position;    boxY: INTEGER;    block: Environment.Block;    temp: Position;    breakReason: TextSink.BreakReason;    sink: TextSink.Handle = p.sink;    source: TextSource.Handle = p.source;    place ¬ ClipPlaceToBox[p.box, place];    boxY ¬ place.y - p.box.place.y;    line ¬      IF boxY >= p.options.margin THEN MIN[      TextDisplay.LastLine[p.lineTable],      (boxY - p.options.margin)/p.sink.fontInfo[p.sink].lineHeight] ELSE 0;    positionPlace ¬ p.LineStartPlace[line];    position ¬ p.lineTable[line].pos;    positionsLeftInLine ¬ p.CharsInLine[line];    maxPosOnLine ¬ p.lineTable[line].pos + positionsLeftInLine;    DO      [block, temp] ¬ source.ReadText[position, positionsLeftInLine, eol];      positionsLeftInLine ¬ positionsLeftInLine - Inline.LowHalf[temp - position];      [positionPlace.x, positions, breakReason] ¬ sink.Resolve[        block: @block, startX: positionPlace.x, xToFind: place.x,        offset: p.box.place.x, halfCharResolve: halfCharResolve];      SELECT breakReason FROM        eol, margin => {position ¬ position + positions; EXIT};        consumed => {          position ¬ position + positions;          IF positionsLeftInLine = 0 OR position = source.getLength[source] THEN            EXIT};        ENDCASE;      ENDLOOP};  SelectionInterval: PUBLIC PROC [    p: TextDisplay.Handle, line: CARDINAL,    leftPlace, rightPlace: TextDisplay.Place] RETURNS [left, right: CARDINAL] = {    SELECT TRUE FROM      (line < leftPlace.line OR line > rightPlace.line) => RETURN[0, 0];      (line = leftPlace.line AND line = rightPlace.line) =>        RETURN[leftPlace.position, rightPlace.position];      (line = leftPlace.line) => RETURN[leftPlace.position, p.CharsInLine[line]];      (line = rightPlace.line) => RETURN[0, rightPlace.position];      ENDCASE => RETURN[0, p.CharsInLine[line]]};  -- Private Utility routines  ClipPlaceToBox: PROC [box: Window.Box, place: Window.Place]    RETURNS [boxPlace: Window.Place] = {    boxPlace.x ¬ MAX[box.place.x, MIN[place.x, box.place.x + box.dims.w]];    boxPlace.y ¬ MAX[box.place.y, MIN[place.y, box.place.y + box.dims.h]]};  END. -- of TextDisplaysB
-- File: TEditImpl.mesa - last edit:-- Riggle.PA           18-Jul-86 13:08:48-- Copyright (C) 1982, 1983, 1984 , 1986, 1986 by Xerox Corporation. All rights reserved. -- AXD    	26-Apr-84 16:20:31-- JGS on	19-Nov-82 18:10:51-- BGY     	 9-Dec-83 14:25:38-- DWR    	 5-Mar-85 14:35:31DIRECTORY  Ascii: TYPE USING [BS, CR],  Atom: TYPE USING [ATOM, MakeAtom],  Context: TYPE USING [Find],  Dictionary USING [defaultDictionary, InvokeTool, LookUp],  EditUtil: TYPE USING [FindQuiescentTool, FixSelection, Update],  Environment: TYPE USING [Block, Byte],  Heap: TYPE USING [Create, systemZone],  Menu: TYPE USING [Invoke],  RefTab: TYPE USING [Create, Delete, Fetch, Ref, Store],  Selection: TYPE USING [    ActOn, Clear, Convert, ConvertInsertion, ConvertTrashBin, Set, SetTrashBin,    Source, Target],  String: TYPE USING [AppendChar, AppendStringAndGrow],  TEdit: TYPE USING [    CancelMultiClick, CommandProc, DontDoIt, notSet, place, StateRec],  TextData: TYPE USING [InsertionObject, SelectionObject],  TextDisplay: TYPE USING [Handle, MarkInsertion, MarkSelection, MoveInsertion, noPlace],  TextSource: TYPE USING [    AsciiTextSearch, Error, Handle, nullPosition, Position,     ReadText, ReplaceText, ScanText, SearchFailed],  TextSW: TYPE USING [    DoEditAction, GetInsertion, GetOptions, GetSource, InvalidList,    InvalidRegions, JumpEndMCR, JumpInsertionMCR, JumpSelectionMCR, JumpTopMCR,    ModifySource, Position, ReplaceText, SetInsertion, SetSelection],  TextSWOps: TYPE USING [    ActOnSelection, AppendWhiteSpace, ChangeCase, ConvertSelection,    FinishExtend, FinishMoveSplit, FinishSelection, InternalDeleteText,    InternalForceOutput, InsertBlockInternal, lock, ModifyInsertionState,    MoveSplitBoundary, PToUse, RealActOnCaret, SearchForSelection,    SelectionClass, StartExtend, StartMoveSplit, StartSelection,    TakeInputFocus, textSWContext, TrackExtend, TrackSelection, TSWContext],    TextSWOpsExtra USING [SnarfWhiteSpace, VirtualSpaces],  UserInput: TYPE USING [StuffCurrentSelection, StuffString, StuffTrashBin],  UserTerminal: TYPE USING [BlinkDisplay],  Window: TYPE USING [Handle];  TEditImpl: MONITOR LOCKS TextSWOps.lock  IMPORTS     Atom, Context, Dictionary, EditUtil, Heap, Menu, RefTab, Selection, String, TEdit,    TextDisplay, TextSource, TextSW, TextSWOps, TextSWOpsExtra, UserInput, UserTerminal  EXPORTS TEdit =    PUBLIC BEGIN    OPEN TEdit, TextSWOps;    state: LONG POINTER TO StateRec ¬ @myState;  myState: PRIVATE StateRec ¬ [];    LocalFind: PRIVATE PROC [sw: Window.Handle] RETURNS [context: TSWContext] = {    IF (context ¬ Context.Find[textSWContext, sw]) = NIL THEN {      UserTerminal.BlinkDisplay[];      ERROR TEdit.DontDoIt}};    TextToBlockPointer: PROC [LONG POINTER TO PACKED ARRAY [0..0) OF CHARACTER]    RETURNS [LONG POINTER TO PACKED ARRAY [0..0) OF Environment.Byte] =     MACHINE CODE BEGIN END;       AdjustUp: CommandProc = {    tsw: TSWContext = LocalFind[window];    IF state.inSel = ext THEN FinishExtend[tsw]};        Again: CommandProc = {    RETURN SelectConvertSwap[window, Selection.ConvertInsertion]};      «  AutoIndentLineBreak: ENTRY CommandProc = {    ENABLE UNWIND => NULL;    -- If insertion not visible, nothing happens!!!  ** Yeah, what a crock! [DWR]    tsw: TSWContext = LocalFind[window];    insertPos: TextSource.Position = tsw.insertion.position;    pToUse: TextDisplay.Handle;    TEdit.CancelMultiClick;    IF tsw.options.access = edit OR tsw.options.access = append THEN {      FOR i: CARDINAL IN [0..tsw.splits.length) DO        IF TextDisplay.PositionIsVisible[tsw.splits[i], insertPos] THEN {	  pToUse ¬ tsw.splits[i]; EXIT};        REPEAT FINISHED => RETURN;        ENDLOOP;      IF insertPos # TextSource.nullPosition THEN {        crTemp: STRING ¬ [50];        count: CARDINAL ¬ 0;        crTemp.length ¬ 1;        crTemp[0] ¬ '\n;        count ¬ BlankCount[tsw, pToUse, insertPos, insertPos];        IF count > 0 THEN AppendWhiteSpace[crTemp, count];	ModifyInsertionState[tsw: tsw, op: append, pos: insertPos];        InsertBlockInternal[	  window, [TextToBlockPointer[@crTemp.text], 0, crTemp.length],	  insertPos, tsw];	InternalForceOutput[tsw];	ModifyInsertionState[tsw, append, tsw.insertion.position]}}}; »	  -- The new AutoIndentLineBreak doesn't depend on PositionIsVisible  AutoIndentLineBreak: ENTRY CommandProc = {    ENABLE UNWIND => NULL;    tsw: TSWContext = LocalFind[window];    TEdit.CancelMultiClick;    IF tsw.options.access = edit OR tsw.options.access = append THEN {      indent: LONG STRING ¬ [50];      insertPos: TextSource.Position = tsw.insertion.position;      source: TextSource.Handle = tsw.splits[0].source;      left: TextSource.Position ¬ source.ScanText[(IF insertPos = 0 THEN 0 ELSE insertPos-1), line, left]; -- ScanLeft doesn't work correctly if we're at eof.      -- neither does it work if insertPos-1 is a CR.      IF insertPos # 0 THEN BEGIN        b: Environment.Block = source.ReadText[insertPos-1, 1, none].block;	IF b.blockPointer[b.startIndex] = LOOPHOLE[Ascii.CR] THEN left ¬ insertPos;      END;      String.AppendChar[indent, Ascii.CR]; -- we do the CR ourselves      TextSWOpsExtra.SnarfWhiteSpace[source, indent, left, insertPos];      ModifyInsertionState[tsw: tsw, op: append, pos: insertPos];      InsertBlockInternal[window, [TextToBlockPointer[@indent.text], 0, indent.length], insertPos, tsw];      InternalForceOutput[tsw];      ModifyInsertionState[tsw, append, tsw.insertion.position];    } ELSE UserTerminal.BlinkDisplay[];  };     UnIndentLineBreak: ENTRY CommandProc = {    ENABLE UNWIND => NULL;    tsw: TSWContext = LocalFind[window];    TEdit.CancelMultiClick;    IF tsw.options.access = edit OR tsw.options.access = append THEN {      insertPos: TextSource.Position = tsw.insertion.position;      source: TextSource.Handle = tsw.splits[0].source;      left: TextSource.Position ¬ source.ScanText[(IF insertPos = 0 THEN 0 ELSE insertPos - 1), line, left];      « The insertion position is always one beyond the last char in the source (and ScanLeft doesn't work correctly in that case), hence we back up one if the source is not empty. »      indentLevel: CARDINAL;      previousLevel: CARDINAL ¬ 0;      BEGIN	IF left = 0 THEN GOTO printIt; -- we're on the first line.  Do a straight CR	indentLevel ¬ TextSWOpsExtra.VirtualSpaces[source, left, insertPos];	IF indentLevel = 0 THEN GOTO printIt; -- accelerator for straight CRs.	DO	  left ¬ source.ScanText[left - 1, line, left];  -- INVARIANT: left # 0	  previousLevel ¬ TextSWOpsExtra.VirtualSpaces[source, left];	  IF previousLevel < indentLevel THEN GOTO printIt;	  IF left = 0 THEN {previousLevel ¬ 0; GOTO printIt}; -- first indent level in file.  Do a straight CR	ENDLOOP;      EXITS	printIt => { -- print what we've got!	  indent: LONG STRING ¬ [50];	  String.AppendChar[indent, Ascii.CR]; -- we do the CR ourselves	  TextSWOps.AppendWhiteSpace[indent, previousLevel];	  ModifyInsertionState[tsw: tsw, op: append, pos: insertPos];	  InsertBlockInternal[window, [TextToBlockPointer[@indent.text], 0, indent.length], insertPos, tsw];	  InternalForceOutput[tsw];	  ModifyInsertionState[tsw, append, tsw.insertion.position];	};      END;    } ELSE UserTerminal.BlinkDisplay[];  };      BackSpaceTAB: CommandProc = {    pos: TextSource.Position;    TEdit.CancelMultiClick;    IF PeekAtSource[      TextSW.GetSource[window], pos ¬ TextSW.GetInsertion[window] - 1] = '\t      THEN {      sevenSpaces: STRING ¬ "       "L;      TextSW.ReplaceText[        sw: window, pos: pos, count: 1,	block: [TextToBlockPointer[@sevenSpaces.text], 0, sevenSpaces.length]	! TextSource.Error => {	  UserTerminal.BlinkDisplay[]; ERROR TEdit.DontDoIt}]}     ELSE [] ¬ TextSW.DoEditAction[window, backSpace]};  Blink: CommandProc = {UserTerminal.BlinkDisplay[]};  BracketSelection: PROC [    sw: Window.Handle, leftChar, rightChar: CHARACTER] = {    << !! It would be nice to have this put stuff in the TrashBin so that UNDO    would work for the bracket commands !! >>    tsw: TSWContext = LocalFind[sw];    invalid: TextSW.InvalidRegions ¬ NIL;    left, right: TextSource.Position;    delta: LONG INTEGER;    MuckWithSource: PROC [      sw: Window.Handle, source: TextSource.Handle, data: LONG POINTER]      RETURNS [invalidRegions: TextSW.InvalidRegions] = {      Hack: PACKED ARRAY [0..2) OF Environment.Byte ¬ [        leftChar.ORD, rightChar.ORD];      [left: left, right: right] ¬ tsw.selection;      delta ¬ source.ReplaceText[[Hack.BASE, 0, 1], left, left].delta;      delta ¬ delta + source.ReplaceText[        [Hack.BASE, 1, 2], right + delta, right + delta].delta;      invalid ¬ invalidRegions ¬ Heap.systemZone.NEW[        TextSW.InvalidList [1] ¬ [length: 1, seq: TRASH]];      invalid[0] ¬ [from: left, to: right + delta, delta: delta]};    TEdit.CancelMultiClick;    IF Selection.Convert[subwindow] #      sw OR TextSW.GetOptions[sw].access # edit THEN {      UserTerminal.BlinkDisplay; RETURN};    TextSW.ModifySource[sw, MuckWithSource, NIL];    IF invalid # NIL THEN {      Heap.systemZone.FREE[@invalid];      TextSW.SetSelection[sw, left, right + delta];      TextSW.SetInsertion[sw, right + delta];      ModifyInsertionState[tsw: tsw, op: clear, pos: TRASH]}};  ClearText: CommandProc = {state.selMode ¬ clearText};  CopyDown: CommandProc = {Selection.Clear[]};  CopyUp, Stuff: CommandProc = {    tsw: TSWContext = LocalFind[window];    TEdit.CancelMultiClick;    SELECT tsw.options.access FROM      edit => IF ~SelectStuff[window, tsw, Selection.Convert] THEN        UserTerminal.BlinkDisplay[];      append => IF ~UserInput.StuffCurrentSelection[window] THEN         UserTerminal.BlinkDisplay[];      ENDCASE => UserTerminal.BlinkDisplay[]};  Define: CommandProc = {TEdit.CancelMultiClick; Dictionary.InvokeTool[]};    Delete: CommandProc = {DeleteText[window: window, setInsertion: FALSE]};  DeletePreviousCharacter: CommandProc = {    TEdit.CancelMultiClick;    [] ¬ TextSW.DoEditAction[window, backSpace]};  DeletePreviousWord: CommandProc = {    TEdit.CancelMultiClick;    [] ¬ TextSW.DoEditAction[window, backWord]};  DeleteText: ENTRY PROC [window: Window.Handle, setInsertion: BOOLEAN] = {    ENABLE UNWIND => NULL;    data: TSWContext = Context.Find[textSWContext, window];    TEdit.CancelMultiClick;    IF data # NIL AND data.options.access = edit THEN {      InternalDeleteText[        data, data.selection.left, data.selection.right - data.selection.left];      IF setInsertion THEN {        data.insertion.place ¬ TextDisplay.noPlace;        ModifyInsertionState[tsw: data, op: clear, pos: TRASH]}}    ELSE UserTerminal.BlinkDisplay[]};	  Document: CommandProc = {state.selEntity ¬ document};  DoPrimary: CommandProc = {DoSel[window, primary]};    DoSecondary: CommandProc = {DoSel[window, secondary]};    DoSel: --almost ENTRY-- PROC [window: Window.Handle, class: SelectionClass] = {    tsw: TSWContext = LocalFind[window];    IF tsw.splits.length # 1 AND PToUse[tsw, TEdit.place.y, TRUE] = NIL THEN      StartMoveSplit[tsw]    ELSE {      IF class = primary AND Selection.Convert[subwindow] # tsw.sw THEN        Selection.Set[tsw, ConvertSelection, ActOnSelection];      StartSelection[tsw, class]}};  Element: CommandProc = {state.selEntity ¬ element};  <<Enter: CommandProc = {    tsw: TSWContext = LocalFind[window];    tsw.scroller ¬ NIL;    Cursor.Set[      IF UserInput.FocusTakesInput[] THEN textPointer ELSE groundedText]};>>  Expand: CommandProc = {    tsw: TSWContext = LocalFind[window];    block, newBlock: Environment.Block;    new: LONG STRING;    start,end, next: TextSource.Position;    source:TextSource.Handle;    i, j: CARDINAL;    fieldLeft, fieldRight: CARDINAL ¬ 0;    selectField: BOOLEAN ¬ FALSE;    MAXKEY: CARDINAL = 30;    key: LONG STRING ¬ [MAXKEY];    AlmostLockedExpand: ENTRY PROC RETURNS [ok: BOOLEAN] = {      ENABLE UNWIND => NULL;      TextSWOps.InternalForceOutput[tsw];      ok ¬ TRUE;      source ¬ TextSW.GetSource[window];      start ¬ tsw.insertion.position;      end ¬ source.scanText[source, start - 1, word, left];      IF (start = end) OR ( start - end  > MAXKEY ) THEN GOTO nope;      new ¬ NIL;      [block, next] ¬ source.readText[        source, end, CARDINAL[start - end], none];      IF block.stopIndexPlusOne = block.startIndex THEN GOTO nope;      key.length  ¬ block.stopIndexPlusOne - block.startIndex;      j ¬ 0;      FOR i IN [block.startIndex..block.stopIndexPlusOne) DO        key.text[j] ¬ LOOPHOLE[block.blockPointer[i], CHARACTER];        j ¬ j + 1;        ENDLOOP;      new ¬ Dictionary.LookUp[Dictionary.defaultDictionary, key];      IF new = NIL THEN GOTO nope;      FOR fieldLeft IN [0..new.length) DO        IF new[fieldLeft] = 253C THEN {	  FOR i: CARDINAL IN [fieldLeft..new.length) DO	    IF new[i] = 273C THEN {fieldRight ¬ i; EXIT};	    ENDLOOP;	  EXIT}	ENDLOOP;      selectField ¬ fieldRight > fieldLeft;      newBlock.startIndex ¬ 0; newBlock.stopIndexPlusOne ¬ new.length;      newBlock.blockPointer ¬ LOOPHOLE[@new.text];      IF tsw.options.access = edit THEN {        RealActOnCaret[tsw, clear];		-- make sure the caret is off        ModifyInsertionState[tsw, change, end];        ModifyInsertionState[tsw, append, end];    << TextSW.ReplaceText[window, end, start - end, newBlock]; -- can't call an entry, so.. >>          InternalDeleteText[tsw, end, start - end];		-- its contents	  InsertBlockInternal[window, newBlock, end, tsw];	  InternalForceOutput[tsw];        ModifyInsertionState[tsw, append, end + new.length];        ModifyInsertionState[tsw, change, end + new.length];};      EXITS nope => ok ¬ FALSE};    TEdit.CancelMultiClick;    IF tsw = NIL THEN GOTO nope;    IF ~AlmostLockedExpand[] THEN GOTO nope;    SELECT tsw.options.access FROM      edit => {   <<   TextSW.ReplaceText[window, end, start - end, newBlock];  -- put this above in entry to try and cure caret tracks        ModifyInsertionState[tsw, append, end + new.length];        ModifyInsertionState[tsw, change, end + new.length];  >>        IF selectField THEN {          TextSW.SetSelection[window, end + fieldLeft, end + fieldRight + 1];          TextSW.SetInsertion[window, end + fieldRight + 1]}};      append => {	backword: LONG STRING  ¬ [MAXKEY];	FOR ind: CARDINAL IN [0..key.length) DO 	  backword[ind] ¬ Ascii.BS; ENDLOOP;	backword.length ¬ key.length;	[] ¬ UserInput.StuffString[window, backword];        [] ¬ UserInput.StuffString[window, new];	};      ENDCASE => RETURN;    EXITS nope => UserTerminal.BlinkDisplay[]};      ExtendPrimary: CommandProc = {    tsw: TSWContext = LocalFind[window];    IF Selection.Convert[subwindow] # tsw.sw THEN TakeInputFocus[tsw]    ELSE StartExtend[tsw]};    FindField: PROC [window: Window.Handle, deleteIt: BOOLEAN] = {    << this version is just a hack. It should really use the scanning functions    of the source to find the left and right marks. Of course, it must be    careful of the distinction between finding the character at the end, and    not finding it at all. >>    left, right: TextSource.Position;    source: TextSource.Handle = TextSW.GetSource[window];    GetLeftRight: ENTRY PROC [position: TextSource.Position] RETURNS [BOOLEAN] = {      ENABLE {TextSource.SearchFailed => GOTO failure; UNWIND => NULL};      tsw: TSWContext = LocalFind[window];      IF tsw = NIL OR source = NIL THEN RETURN[FALSE];      IF position = TextSource.nullPosition THEN position ¬ 0;      left ¬ TextSource.AsciiTextSearch[source, "\253"L, position].left;      right ¬ TextSource.AsciiTextSearch[source, "\273"L, left].left + 1;      RETURN[TRUE]      EXITS failure => RETURN[FALSE]};    TEdit.CancelMultiClick;    IF GetLeftRight[TextSW.GetInsertion[window]] THEN {      TextSW.SetSelection[window, left, right];      IF TextSW.GetOptions[window].access = edit THEN        TextSW.SetInsertion[window, right];      IF deleteIt THEN Selection.ActOn[delete]}    ELSE UserTerminal.BlinkDisplay[]};        FindNextField: CommandProc = {FindField[window, FALSE]};  GetEditor: TEdit.CommandProc = {[] ¬ EditUtil.FindQuiescentTool[]};    GrayBox: CommandProc = {state.selMode ¬ grayBox};  JFirst: CommandProc = {TextSW.JumpTopMCR[window]};  JInsert: CommandProc = {TextSW.JumpInsertionMCR[window]};  JLast: CommandProc = {TextSW.JumpEndMCR[window]};  JSelect: CommandProc = {TextSW.JumpSelectionMCR[window]};  InsertAngleBrackets: CommandProc = {BracketSelection[window, '<, '>]};  InsertCurlyBrackets: CommandProc = {BracketSelection[window, '{, '}]};  InsertDoubleQuotes: CommandProc = {BracketSelection[window, '\", '\"]};  InsertFieldBrackets: CommandProc = {BracketSelection[window, 253C, 273C]};  InsertParens: CommandProc = {BracketSelection[window, '(, ')]};  InsertSingleQuotes: CommandProc = {BracketSelection[window, '\', '\']};  InsertSquareBrackets: CommandProc = {BracketSelection[window, '[, ']]};  InsertToSel: CommandProc = {state.insertToSel ¬ TRUE};  InvokeMenu: CommandProc = {    TEdit.CancelMultiClick; Menu.Invoke[window, TEdit.place]};  Line: CommandProc = {state.selEntity ¬ line};    MakeLowerCase: CommandProc = {    TEdit.CancelMultiClick; ChangeCase[window, FALSE]};    MakeUpperCase: CommandProc = {    TEdit.CancelMultiClick; ChangeCase[window, TRUE]};  MoveDown: CommandProc = {    Selection.Clear[]; Selection.SetTrashBin[NIL, NIL, NIL]};  MoveInsertion: CommandProc = {    tsw: TSWContext = LocalFind[window];    TEdit.CancelMultiClick;    SELECT tsw.options.access FROM      edit => {        LockedProc: ENTRY PROC = {	  ENABLE UNWIND => NULL;          RealActOnCaret[tsw, clear];	  TextDisplay.MoveInsertion[	    PToUse[tsw, place.y, FALSE], place, @tsw.insertion];	  ModifyInsertionState[tsw, change, tsw.insertion.position]};	LockedProc;	TakeInputFocus[tsw]};      append => TakeInputFocus[tsw];      ENDCASE => UserTerminal.BlinkDisplay[]};  MoveUp: CommandProc = {    TEdit.CancelMultiClick;    Selection.ActOn[delete];    IF ~UserInput.StuffTrashBin[window] THEN UserTerminal.BlinkDisplay[]};  Noop: CommandProc = {};  Paragraph: CommandProc = {state.selEntity ¬ paragraph};  Paste: CommandProc = {    tsw: TSWContext = LocalFind[window];    TEdit.CancelMultiClick;    SELECT tsw.options.access FROM      edit => IF ~SelectStuff[window, tsw, Selection.ConvertTrashBin] THEN        UserTerminal.BlinkDisplay[];      append => IF ~UserInput.StuffTrashBin[window] THEN         UserTerminal.BlinkDisplay[];      ENDCASE => UserTerminal.BlinkDisplay[]};    PeekAtSource: ENTRY PROC [source: TextSource.Handle, pos: TextSource.Position]    RETURNS [c: CHARACTER ¬ 0C] = {    ENABLE UNWIND => NULL;    IF pos # TextSource.nullPosition AND source # NIL THEN {      block: Environment.Block ¬ source.ReadText[pos, 1, none].block;      ss: POINTER TO RECORD [        base: LONG POINTER TO PACKED ARRAY CARDINAL OF CHARACTER,        offset, end: CARDINAL] = LOOPHOLE[@block];      IF (ss.end - ss.offset) # 0 THEN c ¬ ss.base[ss.offset]}};  PointUp: CommandProc = {    tsw: TSWContext = LocalFind[window];    SELECT state.inSel FROM      none => FinishMoveSplit[tsw];      sel => FinishSelection[tsw];      ENDCASE};        Replace: CommandProc = {DeleteText[window: window, setInsertion: TRUE]};  ReplaceNextField: CommandProc = {FindField[window, TRUE]};  SearchBackwards: CommandProc = {    TEdit.CancelMultiClick;    SearchForSelection[LocalFind[window], TEdit.place, TRUE]};  SearchForwards: CommandProc = {    TEdit.CancelMultiClick;    SearchForSelection[LocalFind[window], TEdit.place, FALSE]};  SelectConvertSwap: PROC [    window: Window.Handle,    Convert: PROC [Selection.Target] RETURNS [LONG POINTER]]    RETURNS [BOOLEAN] = {    AccumulateSource: PROCEDURE [source: Selection.Source]      RETURNS [string: LONG STRING] = {      -- Invalidates source      temp: STRING = [100];      string ¬ NIL;      DO        source.proc[source.data, temp];        IF temp.length = 0 THEN EXIT;        String.AppendStringAndGrow[@string, temp, Heap.systemZone];        IF string.length > 2000 THEN EXIT;        ENDLOOP;      source.destroy[source]}; -- AccumulateSource    tsw: TSWContext = LocalFind[window];    trashSource: Selection.Source;    trash: LONG STRING;    TEdit.CancelMultiClick;    IF tsw.sw # Selection.Convert[subwindow] OR tsw.options.access # edit      THEN GOTO dont;    IF (trashSource ¬ Convert[source]) = NIL THEN GOTO noStuff;    trash ¬ AccumulateSource[trashSource];    IF trash = NIL THEN GOTO noStuff;    IF trash.length > 2000 THEN {Heap.systemZone.FREE[@trash]; GOTO dont}    ELSE {      ModifyInsertionState[tsw, change, tsw.selection.left];      ModifyInsertionState[tsw, append, tsw.selection.left];      TextSW.ReplaceText[        sw: tsw.sw, pos: tsw.selection.left,        count: tsw.selection.right - tsw.selection.left,         block: [TextToBlockPointer[@trash.text], 0, trash.length]];      ModifyInsertionState[tsw, append, tsw.selection.left + trash.length];      ModifyInsertionState[tsw, change, tsw.selection.left + trash.length]};    Heap.systemZone.FREE[@trash];    RETURN[TRUE];    EXITS       noStuff => RETURN Replace[window];      dont => {UserTerminal.BlinkDisplay[]; ERROR TEdit.DontDoIt}};  SelectStuff: PROC [    window: Window.Handle, tsw: TSWContext,    Convert: PROC [Selection.Target] RETURNS [LONG POINTER]]    RETURNS [ok: BOOLEAN] = {    source: Selection.Source ¬ NIL;    start: TextSource.Position ¬ 0;    delta: LONG INTEGER ¬ 0;    dest: TextSource.Handle ¬ tsw.splits[0].source;    fixSelection: BOOLEAN ¬ tsw.sw = Selection.Convert[subwindow];    tempBuffer, string: LONG STRING ¬ NIL;    insert: TextData.InsertionObject ¬ TRASH;    select: TextData.SelectionObject ¬ TRASH;    InsertBlock: ENTRY PROC [b: Environment.Block] = {      [ , ] ¬ dest.replaceText[        dest, b, tsw.insertion.position, tsw.insertion.position, FALSE]};    BEGIN ENABLE UNWIND => IF tempBuffer # NIL THEN       Heap.systemZone.FREE[@tempBuffer];    IF tsw.options.access # edit THEN GOTO dont;    IF (string ¬ Convert[string]) # NIL THEN {      ok ¬ UserInput.StuffString[window, string];      Heap.systemZone.FREE[@string];      RETURN[ok]};    IF (source ¬ Convert[source]) = NIL OR dest = NIL THEN GOTO noStuff;    insert ¬ tsw.insertion;    select ¬ tsw.selection;    FOR i: CARDINAL IN [0..tsw.splits.length) DO      IF i = 0 THEN {	tsw.splits[i].MarkInsertion[@tsw.insertion, clear];	IF fixSelection THEN 	  tsw.splits[i].MarkSelection[@tsw.selection, clear]}      ELSE {	tsw.splits[i].MarkInsertion[@insert, clear];	IF fixSelection THEN 	  tsw.splits[i].MarkSelection[@select, clear]};      ENDLOOP;    TextSWOps.ModifyInsertionState[tsw, change, tsw.insertion.position];    TextSWOps.ModifyInsertionState[tsw, append, tsw.insertion.position];    start ¬ tsw.insertion.position;    tempBuffer ¬ Heap.systemZone.NEW[StringBody[200]];    DO      source.proc[source.data, tempBuffer];      IF tempBuffer.length = 0 THEN EXIT;      InsertBlock[[LOOPHOLE[@tempBuffer.text], 0, tempBuffer.length]];      IF fixSelection THEN EditUtil.FixSelection[        dest, @tsw.selection, tsw.insertion.position, tempBuffer.length];      tsw.insertion.position  ¬ tsw.insertion.position + tempBuffer.length;      delta ¬ delta + tempBuffer.length;      ENDLOOP;    TextSWOps.ModifyInsertionState[tsw, append, tsw.insertion.position];    TextSWOps.ModifyInsertionState[tsw, change, tsw.insertion.position];    tsw.insertion.place ¬ TextDisplay.noPlace;    EditUtil.Update[tsw.sw, start, tsw.insertion.position, delta];    Heap.systemZone.FREE[@tempBuffer];    RETURN[TRUE];    EXITS       noStuff => RETURN --Replace[window]-- [FALSE]; -- fixe COPY deletes bug      dont => {UserTerminal.BlinkDisplay[]; ERROR TEdit.DontDoIt};    END};  SetInitialState: PROC = {    state.insertToSel ¬ FALSE; state.selEntity ¬ notSet; state.selMode ¬ video};  Splat: CommandProc = {state.selMode ¬ splat};  StrikeOut: CommandProc = {state.selMode ¬ strikeOut};  Text: CommandProc = {state.selEntity ¬ text};  TrackCursor: CommandProc = {    tsw: TSWContext = LocalFind[window];    SELECT state.inSel FROM      none => MoveSplitBoundary[tsw];      sel => TrackSelection[tsw];      ext => TrackExtend[tsw];      ENDCASE};  Underline: CommandProc = {state.selMode ¬ underline};    Undo: CommandProc = {    RETURN SelectConvertSwap[window, Selection.ConvertTrashBin]};    Video: CommandProc = {state.selMode ¬ video};    Word: CommandProc = {state.selEntity ¬ word};    -- Command registration  commandTable: PRIVATE RefTab.Ref = RefTab.Create[zone: Heap.Create[initial: 2]];    AlreadyDefined: SIGNAL [name: LONG STRING] = CODE; -- raised by Register  Register: PROC [string: LONG STRING, proc: TEdit.CommandProc] = {    IF ~RefTab.Store[      x: commandTable, key: Atom.MakeAtom[string], val: LOOPHOLE[proc]]      THEN SIGNAL AlreadyDefined[string]};  CommandProcFromAtom: PROC [atom: Atom.ATOM]    RETURNS [proc: TEdit.CommandProc] = {    RETURN[LOOPHOLE[RefTab.Fetch[x: commandTable, key: atom].val]]};        CommandProcFromString: PROC [string: LONG STRING]    RETURNS [proc: TEdit.CommandProc] = {    RETURN CommandProcFromAtom[Atom.MakeAtom[string]]};        UnRegister: PROC [name: LONG STRING] = {    [] ¬ RefTab.Delete[commandTable, Atom.MakeAtom[name]]};    IsRegistered: PROC [name: LONG STRING] RETURNS [BOOLEAN] = {    RETURN[RefTab.Fetch[commandTable, name].found]};    -- Initialization  RegisterCommandAtoms: PROC = {    Register["Abort"L, Noop];    Register["AdjustDown"L, Noop];    Register["AdjustMotion"L, TrackCursor];    Register["AdjustUp"L, AdjustUp];    Register["Again"L, Again];    Register["AutoIndentLineBreak"L, AutoIndentLineBreak];    Register["BackSpace"L, DeletePreviousCharacter];    Register["BackSpaceTAB"L, BackSpaceTAB];    Register["BackWord"L, DeletePreviousWord];    Register["Blink"L, Blink];    Register["ClearText"L, ClearText];    Register["Command"L, Noop];    Register["Complete"L, Blink];    Register["Control"L, Noop];    Register["CopyDown"L, CopyDown];    Register["CopyUp"L, CopyUp];    Register["DefineAbbreviation"L, Define];    Register["Delete"L, Delete];    Register["DeleteNextCharacter"L, Noop];    Register["DeleteNextWord"L, Noop];    Register["DeletePreviousCharacter"L, DeletePreviousCharacter];    Register["DeletePreviousWord"L, DeletePreviousWord];    Register["Document"L, Document];    Register["DoPrimary"L, DoPrimary];    Register["DoSecondary"L, DoSecondary];    Register["Editor"L, GetEditor];    Register["Element"L, Element];    Register["Enter"L, Noop];    Register["Exit"L, Noop];    Register["ExtendPrimary"L, ExtendPrimary];    Register["ExpandAbbreviation"L, Expand];    Register["FindNextField"L, FindNextField];    Register["GrayBox"L, GrayBox];    Register["InsertAngleBrackets"L, InsertAngleBrackets];    Register["InsertCurlyBrackets"L, InsertCurlyBrackets];    Register["InsertDoubleQuotes"L, InsertDoubleQuotes];    Register["InsertFieldBrackets"L, InsertFieldBrackets];    Register["InsertParens"L, InsertParens];    Register["InsertSingleQuotes"L, InsertSingleQuotes];    Register["InsertSquareBrackets"L, InsertSquareBrackets];    Register["InsertToSel"L, InsertToSel];    Register["JFirst"L, JFirst];    Register["JInsert"L, JInsert];    Register["JLast"L, JLast];    Register["JSelect"L, JSelect];    Register["Line"L, Line];    Register["MakeLowerCase"L, MakeLowerCase];    Register["MakeUpperCase"L, MakeUpperCase];    Register["Menu"L, InvokeMenu];    Register["MenuDown"L, Noop];    Register["MenuMotion"L, TrackCursor];    Register["MoveDown"L, MoveDown];    Register["MoveInsertion"L, MoveInsertion];    Register["MoveUp"L, MoveUp];    Register["Noop"L, Noop];    Register["Paragraph"L, Paragraph];    Register["Paste"L, Paste];    Register["PointDown"L, Noop];    Register["PointMotion"L, TrackCursor];    Register["PointUp"L, PointUp];    Register["Replace"L, Replace];    Register["ReplaceNextField"L, ReplaceNextField];    Register["SearchBackwards"L, SearchBackwards];    Register["SearchForwards"L, SearchForwards];    Register["Shift"L, Noop];    Register["Splat"L, Splat];    Register["StrikeOut"L, StrikeOut];    Register["Stuff"L, Stuff];    Register["Text"L, Text];    Register["Underline"L, Underline];    Register["Undo"L, Undo];    Register["UnIndentLineBreak"L, UnIndentLineBreak];    Register["Video"L, Video];    Register["Word"L, Word]};      -- Main body    RegisterCommandAtoms[];    END.  TED.Register["Again"L, "L, Again];  TED.Register["BackSpace"L, BackSpace];  TED.Register["BackWord"L, BackWord];  TED.Register["Client1"L, Client1];  TED.Register["Client2"L, Client2];  TED.Register["Complete"L, Complete];  TED.Register["Copy"L, Copy];  TED.Register["Define"L, Define];  TED.Register["Delete"L, Delete];  TED.Register["DoIt"L, DoIt];  TED.Register["Expand"L, Expand];  TED.Register["FindNext"L, FindNext];  TED.Register["FindPrev"L, FindPrev];  TED.Register["FindNextDef"L, FindNextDef];  TED.Register["FindPrevDef"L, FindPrevDef];  TED.Register["Help"L, Help];  TED.Register["JFirst"L, JFirst];  TED.Register["JInsert"L, JInsert];  TED.Register["JLast"L, JLast];  TED.Register["JSelect"L, JSelect];  TED.Register["Move"L, Move];  TED.Register["Next"L, Next];  TED.Register["DeleteNextChar"L, DeleteNextChar];  TED.Register["DeleteNextWord"L, DeleteNextWord];  TED.Register["GoToPreviousWord"L, GoToPreviousWord];  TED.Register["GoToNextWord"L, GoToNextWord];  TED.Register["GoToPreviousChar"L, GoToPreviousChar];  TED.Register["GoToNextChar"L, GoToNextChar];  TED.Register["NextDelete"L, NextDelete];  TED.Register["Properties"L, Properties];  TED.Register["Paste"L, Paste];  TED.Register["Replace"L, Replace];  TED.Register["Stuff"L, Stuff];  TED.Register["Undo"L, Undo];  TED.Register["Reserved"L, Reserved];LOGDWR    	16-Nov-84 11:51:19  added UnindentLineBreakDWR    	21-Nov-84 17:30:50  reworked some of UnindentLineBreak & AutoindentLineBreakDWR    	 5-Mar-85 14:09:13 17:30:50  fixed an AutoIndent bug.DWR	18-Jul-86 13:08:36 Fixed COPY deletes text bug
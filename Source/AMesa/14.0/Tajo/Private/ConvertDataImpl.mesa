-- File: ConvertDataImpl.mesa - last edit:-- Riggle.PA           18-Jul-86 17:07:13-- Breisacher.ES        5-Mar-85 14:17:14-- Last modified by: Curbow   On:  4-Mar-85 14:32:07-- DWR 	20-Aug-85 14:56:11-- Copyright (C) 1985, 1986 by Xerox Corporation. All rights reserved.DIRECTORY  Ascii USING [NUL],  AccessFloppy USING [Attributes, leaderLength],--  BTree USING [Tree],  ConvertData USING [],  Environment USING [bytesPerPage, bytesPerWord],  File USING [Delete, Error, File, nullFile, Type, Unknown],  FileStream USING [Create, InvalidHandle, InvalidOperation],  Heap USING [systemZone],  MFile USING[Acquire, Handle, Delete, dontRelease, Error, SetProperties, Type],--  MFileOps USING [InitLeader, leaderPages, LeaderPage, UnmapLeader],  MStream USING [Handle, Copy, Create, SetLength],--  MDirectory USING [GetTree, FreeTree, InsertInTree, LookupRootDir],  NSAssignedTypes USING [tDirectory, tText, tUnspecified],  NSFile USING [Type],  SCSAssignedTypes USING [tPrometheusState],  Space USING [Map, Unmap],  SpecialFile USING [MakeTemporary],  Stream USING [GetChar, Handle],  String USING [CopyToNewString, Empty, StringToOctal],  System USING [GreenwichMeanTime],  Token USING [FreeTokenString, Handle, Item, Object],  Volume USING [ID, LookUpRootFile, NotOpen, RemoveRootFile, RootDirectoryError, systemID, Unknown];ConvertDataImpl: PROGRAM  IMPORTS    File, FileStream, Heap, --MDirectory,-- MFile, --MFileOps, --MStream, SpecialFile, Space,    Stream, String, Token, Volume  EXPORTS ConvertData =  BEGIN  CantFindFile: SIGNAL = CODE;  CantCopyFile: SIGNAL = CODE;  ConvertDataFiles: PUBLIC PROCEDURE =    BEGIN    volume: Volume.ID = Volume.systemID;    sh: Stream.Handle ¬ NIL;    index: LONG CARDINAL ¬ Environment.bytesPerWord * SIZE[Volume.ID];    tokenObject: Token.Object;    Cleanup: PROCEDURE = {IF sh # NIL THEN sh.delete[sh]};    BEGIN    ENABLE UNWIND => Cleanup[];    nextChar: PROCEDURE [h: Token.Handle] RETURNS [c: CHARACTER] = {      DO        c ¬ Stream.GetChar[sh];        index ¬ index + 1;        IF c = '( THEN LOOP;  << At beginning of File.File >>        IF c = ') THEN c ¬ Ascii.NUL;  << ') signifies end of file >>        EXIT;        ENDLOOP};    -- Get a Stream on the directory file which describes the files which were installed on this machine.	    sh ¬ GetDirectoryStream[volume];    IF sh = NIL THEN RETURN;    tokenObject ¬ [getChar: nextChar];    ProcessCommandFile[tokenObject, volume]    END;    Cleanup[];    END;  -- of ConvertDataFiles  GetDirectoryStream: PROCEDURE [volume: Volume.ID] RETURNS [sh: Stream.Handle] =    BEGIN    {    ENABLE      File.Unknown, File.Error, Volume.Unknown, Volume.NotOpen,        Volume.RootDirectoryError, FileStream.InvalidHandle,        FileStream.InvalidOperation => GOTO done;    file: File.File ¬ File.nullFile;    file ¬ Volume.LookUpRootFile[SCSAssignedTypes.tPrometheusState, volume];    Volume.RemoveRootFile[SCSAssignedTypes.tPrometheusState, volume];    SpecialFile.MakeTemporary[file];    sh ¬ FileStream.Create[file]};    EXITS done => sh ¬ NIL;    END;  -- of GetDirectoryStream  GetDataFile: PROC [tokenObject: Token.Object]    RETURNS [result: LoadeeResult, file: File.File ¬ File.nullFile] =    BEGIN    loadee: LONG STRING;    Rep: TYPE = ARRAY [0..File.File.SIZE) OF UNSPECIFIED;    fileInfo: POINTER TO Rep = @LOOPHOLE[file, Rep];    BEGIN    ENABLE UNWIND => {[] ¬ Token.FreeTokenString[loadee]};    loadee ¬ Token.Item[@tokenObject];    SELECT TRUE FROM      String.Empty[loadee] => {result ¬ done; RETURN};      ENDCASE => {        -- Convert the number in the file into a File.File        FOR i: CARDINAL IN [0..File.File.SIZE) DO          fileInfo[i] ¬ CARDINAL[String.StringToOctal[loadee]];          [] ¬ Token.FreeTokenString[loadee];          IF i # File.File.SIZE - 1 THEN loadee ¬ Token.Item[@tokenObject];          ENDLOOP};    result ¬ file;    END;  -- of GetDataFile    RETURN    END;  LoadeeResult: TYPE = {file, done};  ProcessCommandFile: PROCEDURE [    tokenObject: Token.Object, volume: Volume.ID] =    BEGIN    file: File.File;    result: LoadeeResult;    DO      ENABLE UNWIND => {NULL};      -- Using information in the Directory, get a File.File to the next file.      [result, file] ¬ GetDataFile[tokenObject];      SELECT result FROM        done => EXIT;        ENDCASE => {          CopyFile[            file, volume ! CantFindFile => {LOOP};            CantCopyFile => {LOOP}]};      ENDLOOP;    END;  -- of ProcessCommandFile  CopyFile: PROCEDURE [file: File.File, volume: Volume.ID] =    BEGIN    name: LONG STRING;    sizeInBytes: LONG CARDINAL;    type: MFile.Type;    fh: MFile.Handle ¬ NIL;    remoteCreate: System.GreenwichMeanTime;«    success: BOOLEAN;    lp: MFileOps.LeaderPage;    rootDir: File.File;    bTree: BTree.Tree;»    -- Determine the important attributes of the new file.    [remoteCreate, name, sizeInBytes, type] ¬ GetFileProperties[file];    -- Determine if the named file already exists.    -- If so, then delete it before continuing.    fh ¬ MFile.Acquire[name: name, access: delete, release: MFile.dontRelease !      MFile.Error => IF code = noSuchFile THEN CONTINUE ELSE SIGNAL CantCopyFile];    IF fh # NIL THEN {      MFile.Delete[fh];    };    « commented out until the installer allows File types of MFileType    -- smash leader page of pilot file to make it look like an MFile    lp ¬ MapLeader[file];    rootDir ¬ MDirectory.LookupRootDir[volume];    MFileOps.InitLeader[lp, rootDir.fileID, type, name, sizeInBytes];    lp.fp.create ¬ remoteCreate;    MFileOps.UnmapLeader[lp];    bTree ¬ MDirectory.GetTree[rootDir];    success ¬ MDirectory.InsertInTree[bTree, name, file.fileID];    MDirectory.FreeTree[bTree];    IF ~success THEN SIGNAL CantCopyFile;»    BEGIN -- replace this with above      f: MFile.Handle;      sink: MStream.Handle;       source: Stream.Handle ¬ FileStream.Create[file];      source.setPosition[source, Environment.bytesPerPage];      f ¬ MFile.Acquire[name, readWrite, MFile.dontRelease, TRUE, sizeInBytes, type];      MFile.SetProperties[f, remoteCreate, remoteCreate, remoteCreate, sizeInBytes, type];      sink ¬ MStream.Create[f, []];      [] ¬ MStream.Copy[from: source, to: sink, bytes: sizeInBytes];      MStream.SetLength[sink, sizeInBytes];      source.delete[source];      sink.delete[sink];      File.Delete[file];    END;    END;  -- of CopyFile    «  MapLeader: PROCEDURE [file: File.File]    RETURNS [lp: MFileOps.LeaderPage] = {    lp ¬ Space.Map[      window: [file, 0, MFileOps.leaderPages],      access: readWrite].pointer;    }; »  GetFileProperties: PROCEDURE [file: File.File]    RETURNS [create: System.GreenwichMeanTime, name: LONG STRING,    sizeInBytes: LONG CARDINAL, type: MFile.Type] =    BEGIN    lp: AccessFloppy.Attributes = Space.Map[      window: [file, 0, AccessFloppy.leaderLength], access: readOnly !      File.Unknown => ERROR CantFindFile].mapUnit.pointer;    nsType: NSFile.Type = lp.type;    create ¬ lp.createDate;    sizeInBytes ¬ lp.totalSizeInBytes;  << number of bytes of data >>    name ¬ String.CopyToNewString[z: Heap.systemZone, s: LOOPHOLE[@lp.length]];    type ¬ SELECT nsType FROM      NSAssignedTypes.tUnspecified => binary,      NSAssignedTypes.tText => text,      NSAssignedTypes.tDirectory => directory,      ENDCASE => unknown;    [] ¬ Space.Unmap[lp];    END;    END.LOG [Time - Person - Action]28-Feb-85  9:50:05 - Curbow - Created13-Aug-85 17:21:46 - Riggle - Converted to MFiling
-- File: FormSWsF.mesa - last edit:-- Riggle.PA            8-Aug-86 16:14:07-- Copyright (C) 1981, 1983 , 1986 by Xerox Corporation. All rights reserved. -- File: FormSWsF.mesa - last edit:-- SXW    on: 10-Jul-81 11:14:56-- Mark on: 24-Jul-81 14:32:16-- JGS on: 19-Aug-81 14:15:30-- SEH on:  9-Dec-81 16:56:36-- BGY     	 7-Jan-83 13:25:17DIRECTORY  Environment USING [Block],  FormSW USING [    EnumeratedHandle, IndexFromEnumeratedValue, ItemHandle, nullEnumeratedValue,    nullIndex],  FormSWOps,  Heap USING [systemZone],  Inline USING [LowHalf],  Selection USING [DestroyProc, SetTrashBin, Source, SourceObject, Target],  String USING [AppendChar, AppendString, EmptyString, ExpandString,    FreeString, Length, StringBoundsFault, SubStringDescriptor],  TextSource USING [    AsciiDeleteSubString, AsciiDoEditAction, AsciiInsertBlock, AsciiScanText,    AsciiTestClass, ActOnProc, cannotExpand, Class, DoEditActionProc,    GetLengthProc, Handle, Position, Procedures, ProceduresObject, ReadTextProc,    SetLengthProc],  UserTerminal USING [BlinkDisplay];FormSWsF: PROGRAM  IMPORTS Heap, Inline, FormSW, Selection, String, TextSource, UserTerminal  EXPORTS FormSWOps =  BEGIN  -- Data and Definitions  FormSWSource: TYPE = LONG POINTER TO FormSWSourceObject;  FormSWSourceObject: TYPE = MACHINE DEPENDENT RECORD [    procs: TextSource.Procedures,    item: FormSW.ItemHandle,    tagLength, length: CARDINAL,    context: FormSWOps.PContext];  fillInLength: CARDINAL = LAST[CARDINAL];  SelectionSource: TYPE = LONG POINTER TO SelectionSourceObject;  SelectionSourceObject: TYPE = RECORD [    position: TextSource.Position,    length: LONG CARDINAL,    context: FormSWOps.PContext,    textSource: TextSource.Handle];    myProcs: TextSource.ProceduresObject ¬ [    actOn: ActOnSource, doEditAction: TextSource.AsciiDoEditAction,    getLength: FormSWGetLength, readText: FormSWReadText,    replaceText: FormSWReplaceText, scanText: TextSource.AsciiScanText,    setLength: FormSWSetLength];  IBSOwn: TYPE = RECORD [    SELECT OVERLAID * FROM    f1 => [enum: CARDINAL -- Next choice -- ],    f2 => [offset: CARDINAL -- Next character -- ],    ENDCASE];  ItemBufferStatus: TYPE = {start, didTag, didBody, done};  ItemBufferState: TYPE = LONG POINTER TO ItemBufferStateObject;  ItemBufferStateObject: TYPE = RECORD [status: ItemBufferStatus, own: IBSOwn];  z: UNCOUNTED ZONE ¬ Heap.systemZone;    -- FormSW Source routines  AbstractToRepr: PROCEDURE [source: TextSource.Handle] RETURNS [FormSWSource] =    {RETURN[LOOPHOLE[source, FormSWSource]]};  ReprToAbstract: PROCEDURE [p: FormSWSource] RETURNS [TextSource.Handle] =     {RETURN[LOOPHOLE[p, TextSource.Handle]]};  ClearCachedInfo: PUBLIC PROCEDURE [p: FormSWSource] =    BEGIN p.tagLength ¬ p.length ¬ fillInLength; END;  ChangeItem: PUBLIC PROCEDURE [p: FormSWSource, item: FormSW.ItemHandle] =    BEGIN p.item ¬ item; ClearCachedInfo[p]; END;  CreateSource: PUBLIC PROCEDURE [    item: FormSW.ItemHandle, context: FormSWOps.PContext]    RETURNS [source: TextSource.Handle] =    BEGIN    p: FormSWSource ¬ context.zone.NEW[FormSWSourceObject];    p­ ¬ [      procs: @myProcs, item: item, tagLength: fillInLength, length: fillInLength,      context: context];    RETURN[ReprToAbstract[p]];    END;  ActOnSource: TextSource.ActOnProc =    BEGIN    p: FormSWSource = AbstractToRepr[source];    myContext: FormSWOps.PContext ¬ p.context;    SELECT action FROM       destroy => {myContext.zone.FREE[@source]; source ¬ NIL};       ENDCASE;     END;  FormSWReadText: TextSource.ReadTextProc =    BEGIN    p: FormSWSource = AbstractToRepr[source];    startPos: CARDINAL = Inline.LowHalf[position];    itemBufferState: ItemBufferStateObject ¬ [status: start, own: NULL];    charsToRead, totalLength: CARDINAL;    -- Move over to beyond the startPos    totalLength ¬ 0;    WHILE totalLength <= startPos DO      block ¬ FillBuffer[p, @itemBufferState, startPos];      IF block.startIndex = block.stopIndexPlusOne THEN        SELECT itemBufferState.status FROM          didBody, done =>            BEGIN            -- Now try to catch the case of client changing backing store,            --   which may invalidate the cached length (causing an infinite            --   loop in caller)            p.length ¬ totalLength;            RETURN[block, startPos];            END;          ENDCASE;      totalLength ¬ totalLength + (block.stopIndexPlusOne - block.startIndex);      ENDLOOP;    block.startIndex ¬      IF startPos < p.tagLength THEN startPos ELSE startPos - p.tagLength;    block.stopIndexPlusOne ¬ MIN[      block.stopIndexPlusOne, block.startIndex + maxLength];    -- Now scan buffer    IF class # none THEN      BEGIN      charsToRead ¬ MIN[maxLength, block.stopIndexPlusOne - block.startIndex];      IF charsToRead > 0 THEN        BEGIN        blockPos: CARDINAL ¬ block.startIndex;        array: LONG POINTER TO PACKED ARRAY OF CHARACTER =          LOOPHOLE[block.blockPointer];        WHILE charsToRead > 0 DO          IF TextSource.AsciiTestClass[array[blockPos], class] THEN {            blockPos ¬ blockPos + 1; EXIT};          blockPos ¬ blockPos + 1;          charsToRead ¬ charsToRead - 1;          ENDLOOP;        block.stopIndexPlusOne ¬ blockPos;        END      ELSE block.stopIndexPlusOne ¬ block.startIndex;      END;    RETURN[block, startPos + (block.stopIndexPlusOne - block.startIndex)];    END;  FormSWGetLength: TextSource.GetLengthProc =    BEGIN    p: FormSWSource = AbstractToRepr[source];    oldPos: TextSource.Position ¬ 0;    newPos: TextSource.Position;    IF p.length = fillInLength THEN      DO        [ ---- , newPos] ¬ FormSWReadText[source, oldPos, 200, none];        IF newPos = oldPos THEN BEGIN p.length ¬ Inline.LowHalf[newPos]; EXIT; END        ELSE oldPos ¬ newPos;        ENDLOOP    ELSE newPos ¬ p.length;    RETURN[newPos];    END;  FormSWSetLength: TextSource.SetLengthProc =    BEGIN    p: FormSWSource = AbstractToRepr[source];    SELECT p.item.type FROM      longNumber, number, string =>        -- p.length is displayed characters length. It can not be used        --   for editing purposes!        BEGIN        s: LONG STRING ¬          (WITH variant: p.item SELECT FROM             longNumber => variant.string,             number => variant.string,             string => variant.string­,             ENDCASE => ERROR);        [] ¬ TagLength[source];        SELECT (p.length ¬ Inline.LowHalf[position]) FROM          < p.tagLength => p.length ¬ p.tagLength;          >= p.tagLength + String.Length[s] => ERROR;  -- should we allow this?          ENDCASE;        IF s # NIL THEN s.length ¬ p.length - p.tagLength;        END;      ENDCASE => ERROR;  -- should we allow this?    RETURN[p.length];    END;  FormSWReplaceText: PROCEDURE [    source: TextSource.Handle, block: Environment.Block,    from, to: TextSource.Position, deleteToTrashbin: BOOLEAN ¬ TRUE]    RETURNS [new: TextSource.Position, delta: LONG INTEGER] =    BEGIN    blockSize: CARDINAL = block.stopIndexPlusOne - block.startIndex;    delta ¬ 0;    IF to # from THEN {      nDeleted: LONG CARDINAL;      [new, nDeleted] ¬ DeleteText[source, from, to - from, deleteToTrashbin];      delta ¬ -nDeleted};    IF blockSize # 0 THEN {      new ¬ InsertText[source, block, from]; delta ¬ delta + blockSize};    END;  InsertText: PROCEDURE [    source: TextSource.Handle, block: Environment.Block,    position: TextSource.Position] RETURNS [TextSource.Position] =    BEGIN    p: FormSWSource = AbstractToRepr[source];    z: UNCOUNTED ZONE = p.context.zone;    pos: CARDINAL ¬ Inline.LowHalf[position];    added: CARDINAL = block.stopIndexPlusOne - block.startIndex;    delta: CARDINAL ¬ 0;    SELECT p.item.type FROM      longNumber, number, string =>        -- If feedback stops being one-to-one, this code will need to be rewritten        --   because p.length is display length, NOT source length!BEGIN        BEGIN        ptrS: LONG POINTER TO LONG STRING ¬          (WITH variant: p.item SELECT FROM             longNumber => @variant.string,             number => @variant.string,             string => variant.string,             ENDCASE => ERROR);        inHeap: BOOLEAN ¬          (WITH variant: p.item SELECT FROM             string => variant.inHeap,             ENDCASE => TRUE);        delta ¬ Inline.LowHalf[FormSWGetLength[source]];        -- Force pos to be valid (i.e. in the client string)        pos ¬ MIN[          MAX[pos, p.tagLength], p.tagLength + String.Length[ptrS­]];        IF ptrS­ = NIL THEN {	  IF inHeap THEN String.ExpandString[ptrS, added, z];}	ELSE IF ptrS.length + added > ptrS.maxlength THEN {	  IF inHeap THEN String.ExpandString[ptrS, added + ptrS.maxlength/2, z]	  ELSE {UserTerminal.BlinkDisplay[]; RETURN[position + delta]}};	TextSource.AsciiInsertBlock[          ptrS, pos - p.tagLength, block,          TextSource.cannotExpand !          String.StringBoundsFault => {UserTerminal.BlinkDisplay[]; CONTINUE}];        p.length ¬ p.tagLength + String.Length[ptrS­];        delta ¬ p.length - delta;        END;      ENDCASE => ERROR;  -- should we allow this?    RETURN[position + delta];    END;  DeleteText: PROCEDURE [    source: TextSource.Handle, position: TextSource.Position, n: LONG CARDINAL,    trash: BOOLEAN] RETURNS [realPos: TextSource.Position, realN: LONG CARDINAL] =    BEGIN    cutString: LONG STRING;    p: FormSWSource = AbstractToRepr[source];    pos: CARDINAL ¬ Inline.LowHalf[position];    initialLength: CARDINAL;    SELECT p.item.type FROM      longNumber, number, string =>        -- If feedback stops being one-to-one, this code will need to be rewritten        --   because p.length is display length, NOT source length!        BEGIN        s: LONG STRING ¬          (WITH variant: p.item SELECT FROM             longNumber => variant.string,             number => variant.string,             string => variant.string­,             ENDCASE => ERROR);        sLength: CARDINAL = String.Length[s];        initialLength ¬ p.length;        IF sLength > 0 THEN          BEGIN          temp: String.SubStringDescriptor;          [] ¬ FormSWGetLength[source];          SELECT pos FROM            <= p.tagLength =>              BEGIN              IF n > p.tagLength - pos THEN n ¬ n + pos - p.tagLength ELSE n ¬ 0;              pos ¬ p.tagLength;              END;            < p.tagLength + sLength => NULL;            ENDCASE => ERROR;  -- should we allow this?          temp.base ¬ s;          temp.offset ¬ pos - p.tagLength;          temp.length ¬ MIN[Inline.LowHalf[n], sLength - temp.offset];          cutString ¬ TextSource.AsciiDeleteSubString[@temp, trash];          IF trash THEN  -- modifies s            Selection.SetTrashBin[cutString, ConvertTrash, ClearTrash];            p.length ¬ p.tagLength + s.length;          END;        END;      ENDCASE => ERROR;  -- should we allow this?    RETURN[pos, initialLength - p.length];    END;  TagLength: PUBLIC PROCEDURE [    source: TextSource.Handle, noTrailer: BOOLEAN ¬ FALSE] RETURNS [CARDINAL] =    BEGIN    p: FormSWSource = AbstractToRepr[source];    IF p.tagLength = fillInLength THEN [] ¬ FormSWGetLength[source];    RETURN[      IF ~noTrailer THEN p.tagLength ELSE p.tagLength - TrailerLength[p.item]];    END;  -- TrashBin routines  Trash: TYPE = LONG POINTER TO TrashObject;  TrashObject: TYPE = RECORD [sourceString: LONG STRING, charsRead: CARDINAL];  ConvertTrash: PROCEDURE [data: LONG STRING, target: Selection.Target]    RETURNS [LONG POINTER] =    BEGIN     SELECT target FROM      length =>        BEGIN        p: LONG POINTER TO LONG CARDINAL ¬ z.NEW[LONG CARDINAL];        p­ ¬ data.length;        RETURN[p];        END;      source =>        BEGIN        d: Trash ¬ z.NEW[TrashObject];        s: Selection.Source ¬ z.NEW[Selection.SourceObject];        d­ ¬ [sourceString: data, charsRead: 0];        s­ ¬ Selection.SourceObject[          data: d, proc: ReadTrash, destroy: DestroySelectionSource];        RETURN[s];        END;      ENDCASE => RETURN[NIL];    END;  ClearTrash: PROCEDURE [data: LONG STRING] = BEGIN String.FreeString[z, data] END;  ReadTrash: PROCEDURE [data: Trash, string: LONG STRING] =    BEGIN    i, temp: CARDINAL;    IF string = NIL THEN RETURN;    string.length ¬ 0;    temp ¬ String.Length[data.sourceString];    temp ¬      IF temp > data.charsRead THEN MIN[string.maxlength, temp - data.charsRead]      ELSE 0;    FOR i IN [0..temp) DO      string[i] ¬ data.sourceString[i + data.charsRead]; ENDLOOP;    string.length ¬ temp;    data.charsRead ¬ data.charsRead + temp;    END;  DestroySelectionSource: Selection.DestroyProc =    BEGIN    z.FREE[@source.data];    z.FREE[@source];    END;    -- Utilities  AppendEnumeratedBody: PROCEDURE [    item: FormSW.EnumeratedHandle, buf: LONG POINTER TO LONG STRING,    itemInfo: ItemBufferState] =    BEGIN OPEN itemInfo;    nextEnum: CARDINAL = own.enum;    atEnd: BOOLEAN ¬ TRUE;    IF BASE[item.choices] # NIL AND LENGTH[item.choices] # 0 THEN      SELECT item.feedback FROM        all =>          BEGIN          choiceSep: STRING = ", "L;          atEnd ¬ FALSE;          FOR j: CARDINAL IN [nextEnum..LENGTH[item.choices]) DO            IF buf.maxlength <              buf.length + item.choices[j].string.length + choiceSep.length THEN              EXIT;            String.AppendString[buf­, item.choices[j].string];            String.AppendString[buf­, choiceSep];            own.enum ¬ j + 1;            REPEAT              FINISHED =>  -- Assertion: buf.length > 1 here                BEGIN                buf.length ¬ buf.length - choiceSep.length;  -- Flush last sep.                atEnd ¬ TRUE;                END;            ENDLOOP;          END;        one =>          BEGIN          current: CARDINAL = FormSW.IndexFromEnumeratedValue[item];          IF current # FormSW.nullIndex THEN            String.AppendString[buf­, item.choices[current].string]          ELSE            IF item.value­ # FormSW.nullEnumeratedValue THEN              String.AppendString[buf­, "?!@$%&*?"L];          END;        ENDCASE;    IF atEnd THEN BEGIN String.AppendString[buf­, "}"L]; status ¬ didBody; END;    END;  AppendItemTag: PROCEDURE [item: FormSW.ItemHandle, s: LONG STRING]    RETURNS [CARDINAL] =    BEGIN    IF ~String.EmptyString[item.tag] THEN      BEGIN      tagTrailer: LONG STRING;      String.AppendString[s, item.tag];      tagTrailer ¬        (WITH variant: item SELECT FROM           command => "!"L,           enumerated => ": {"L,           longNumber, number => "= "L,           string => ": "L,           ENDCASE => NIL);      IF tagTrailer # NIL THEN String.AppendString[s, tagTrailer];      END;    RETURN[s.length];    END;  TrailerLength: PROCEDURE [item: FormSW.ItemHandle] RETURNS [CARDINAL] =    BEGIN    RETURN[      WITH variant: item SELECT FROM        command => 1,        enumerated => 3,        longNumber, number => 2,        string => 2,        ENDCASE => 0];    END;  AppendNumberBody: PROCEDURE [p: FormSWSource] RETURNS [s: LONG STRING] =    BEGIN    SELECT p.item.type FROM      longNumber, number =>        BEGIN        s ¬          (WITH variant: p.item SELECT FROM             longNumber => variant.string,             number => variant.string,             ENDCASE => ERROR);        END;      ENDCASE => ERROR;    RETURN[s];    END;  AppendStringBody: PROCEDURE [p: FormSWSource, itemInfo: ItemBufferState]    RETURNS [s: LONG STRING] =    BEGIN    WITH variant: p.item SELECT FROM      string =>        BEGIN        s ¬ p.context.buffer;        itemInfo.status ¬ didBody;        IF ~String.EmptyString[variant.string­] THEN          BEGIN          SELECT variant.feedback FROM            normal => s ¬ variant.string­;            password =>              BEGIN              numStars: CARDINAL = MIN[                p.context.buffer.maxlength,                variant.string.length - itemInfo.own.offset];              THROUGH [0..numStars) DO String.AppendChar[s, '*]; ENDLOOP;              IF itemInfo.own.offset < variant.string.length THEN                BEGIN                itemInfo.own.offset ¬ itemInfo.own.offset + numStars;                itemInfo.status ¬ didTag;  -- oops, not done after all                END;              END;            ENDCASE => ERROR;          END;        END;      ENDCASE => ERROR;    END;  FillBuffer: PROCEDURE [    p: FormSWSource, itemInfo: ItemBufferState, startPos: CARDINAL]    RETURNS [block: Environment.Block] =    BEGIN    p.context.buffer.length ¬ 0;    SELECT itemInfo.status FROM      start =>        BEGIN        SELECT p.tagLength FROM          fillInLength => p.tagLength ¬ AppendItemTag[p.item, p.context.buffer];          < startPos => block.stopIndexPlusOne ¬ p.tagLength;          ENDCASE => p.tagLength ¬ AppendItemTag[p.item, p.context.buffer];        itemInfo.status ¬ didTag;        WITH variant: p.item SELECT FROM          enumerated => itemInfo.own.enum ¬ 0;          longNumber, number => NULL;          string => itemInfo.own.offset ¬ 0;          ENDCASE => itemInfo.status ¬ didBody;        block ¬ [          blockPointer: LOOPHOLE[@p.context.buffer.text], startIndex: 0,          stopIndexPlusOne: p.tagLength];        END;      didTag =>        BEGIN        string: LONG STRING ¬ p.context.buffer;        WITH variant: p.item SELECT FROM          enumerated =>            AppendEnumeratedBody[@variant, @p.context.buffer, itemInfo];  -- sets status          longNumber, number =>            BEGIN string ¬ AppendNumberBody[p]; itemInfo.status ¬ didBody; END;          string => string ¬ AppendStringBody[p, itemInfo];  -- sets status          ENDCASE;        block ¬ [          blockPointer: LOOPHOLE[@string.text], startIndex: 0,          stopIndexPlusOne: string.length];        END;      didBody, done =>        BEGIN        itemInfo.status ¬ done;        block ¬ [          blockPointer: LOOPHOLE[@p.context.buffer], startIndex: 0,          stopIndexPlusOne: 0];        END;      ENDCASE;    END;  -- MAINLINE CODE  END. -- of FormSWsF
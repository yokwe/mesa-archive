-- Copyright (C) 1981, 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- File: ToolWindowsA.mesa - last edit by:-- PXK    	 7-Dec-83 13:38:07-- Mark		22-May-81 11:59:10-- SXS   	 1-Oct-82 17:34:42-- AXD    	 8-Jun-84 14:13:51-- BGY     	18-Feb-83 11:52:50DIRECTORY  Ascii: TYPE USING [SP],  Context: TYPE USING [DestroyAll, Find, Type],  Display: TYPE USING [Black, Gray, Handle, infinity, Text, White, xorFlags],  Heap: TYPE USING [systemZone],  MSegment: TYPE USING [GetPages],  String: TYPE USING [    AppendChar, AppendString, CopyToNewString, EmptyString, EquivalentSubString,    Length, SubStringDescriptor],  TajoMisc: TYPE USING [],  TajoOps: TYPE USING [    tinyDims, tinyHeight, tinyWidth, WindowHandle, WindowObject],  ToolFont: TYPE USING [StringWidth],  ToolWindow: TYPE USING [DisplayProcType, WindowType],  ToolWindowOps: TYPE USING [InvertThird, stuff, Stuff],  Window: TYPE USING [    Box, Dims, EnumerateInvalidBoxes, GetBox, GetChild, GetParent, GetSibling,    Gravity, Handle, MinusLandBitmapUnder, MinusLandCookieCutter, Place,    rootWindow, SetChild, SetParent, SetSibling, SlideAndSize],  WindowFont: TYPE USING [CharWidth, FontHeight];ToolWindowsA: MONITOR  IMPORTS    Context, Display, Heap, MSegment, String, ToolFont, ToolWindowOps, Window,    WindowFont  EXPORTS TajoMisc, TajoOps, ToolWindow, ToolWindowOps =  BEGIN OPEN ToolWindowOps;  -- Procedures exported to ToolWindow  DrawNameFrame: PUBLIC ToolWindow.DisplayProcType = {    tool: Stuff ¬ Context.Find[stuff, window];    windowbox: Window.Box = window.GetBox;    IF tool = NIL THEN {      Display.Gray[window: window, box: [[0, 0], window.GetBox.dims], gray: NIL];      RETURN};    IF tool.size = tiny THEN DrawTinyWindow[window, tool]    ELSE {      needText: BOOLEAN ¬ FALSE;      proc: PROC [w: Window.Handle, b: Window.Box] = {        IF ~needText AND b.place.y < WindowFont.FontHeight[] THEN	  needText ¬ TRUE};      window.EnumerateInvalidBoxes[proc];      Display.Black[        window, [        [0, IF needText THEN 0 ELSE WindowFont.FontHeight[]], windowbox.dims]];      IF needText THEN        [] ¬ Display.Text[          window: window, string: tool.name, place: [2, 0],          flags: Display.xorFlags, lineLength: Display.infinity]};    IF tool.lastThird # nope THEN InvertThird[      window, tool.lastThird, WindowFont.FontHeight[] - 2, windowbox.dims.w/3,      tool]};  DrawRectangle: PUBLIC PROC [    window: Window.Handle, box: Window.Box, width: CARDINAL ¬ 1] = {    Display.Black[window, [box.place, [box.dims.w, width]]];    Display.Black[window, [box.place, [width, box.dims.h]]];    Display.Black[      window, [      [box.place.x, box.place.y + box.dims.h - width], [box.dims.w, width]]];    Display.Black[      window, [      [box.place.x + box.dims.w - width, box.place.y], [width, box.dims.h]]]};  GetTinyName: PUBLIC PROC [window: Window.Handle]    RETURNS [name, name2: LONG STRING ¬ NIL] = {    tool: Stuff = ForceTinyName[window];    IF tool = NIL THEN RETURN;    IF tool.tiny1 # NIL THEN      name ¬ String.CopyToNewString[tool.tiny1, Heap.systemZone];    IF tool.tiny2 # NIL THEN      name2 ¬ String.CopyToNewString[tool.tiny2, Heap.systemZone]};  GetInactiveName: PUBLIC PROC [window: Window.Handle]    RETURNS [name: LONG STRING] = {    tool: Stuff = ForceTinyName[window];    IF tool = NIL THEN RETURN[NIL];    name ¬ String.CopyToNewString[      tool.tiny1, Heap.systemZone, String.Length[tool.tiny2] + 1];    IF tool.implicitTinySpace THEN String.AppendChar[name, ' ];    IF tool.tiny2 # NIL THEN String.AppendString[name, tool.tiny2]};  ForceTinyName: PROC [window: Window.Handle] RETURNS [tool: Stuff] = {    tool ¬ Context.Find[stuff, window];    IF tool # NIL THEN {IF tool.tiny1 = NIL THEN MakeTinyName[window, tool]}};  MakeTinyName: PROC [window: Window.Handle, tool: Stuff] = {    IF tool = NIL THEN RETURN;    IF tool.tiny1 = NIL THEN      [tool.tiny1, tool.tiny2, tool.implicitTinySpace] ¬ SplitName[        tool.name, TRUE]};  DrawTinyWindow: PROC [window: Window.Handle, tool: Stuff] = {    height: CARDINAL = WindowFont.FontHeight[];    DrawRectangle[window, [[0, 0], TajoOps.tinyDims]];    Display.White[      window: window,      box: [[1, 1], [TajoOps.tinyWidth - 2, TajoOps.tinyHeight - 2]]];    IF tool.tiny1 = NIL THEN MakeTinyName[window, tool];    SELECT TRUE FROM      String.EmptyString[tool.tiny1] => NULL;      String.EmptyString[tool.tiny2] =>        [] ¬ Display.Text[          window: window, string: tool.tiny1,          place: [          x: (TajoOps.tinyWidth - ToolFont.StringWidth[tool.tiny1])/2,          y: (TajoOps.tinyHeight - height)/2], lineLength: Display.infinity]      ENDCASE => {        space: CARDINAL = (TajoOps.tinyHeight - 2*height)/3;        [] ¬ Display.Text[          window: window, string: tool.tiny1,          place: [(TajoOps.tinyWidth - ToolFont.StringWidth[tool.tiny1])/2, space],          lineLength: Display.infinity];        [] ¬ Display.Text[          window: window, string: tool.tiny2,          place: [          x: (TajoOps.tinyWidth - ToolFont.StringWidth[tool.tiny2])/2,          y: 2*space + height], lineLength: Display.infinity]}};  -- exprted to TajoOps  pagesForWindowSpaceIncrement: CARDINAL = 2;  freeWindowWords: CARDINAL ¬ 0;  freeWindowBlock: LONG POINTER ¬ NIL;  freeWindows: ARRAY BOOLEAN OF ARRAY BOOLEAN OF TajoOps.WindowHandle ¬ [    [NIL, NIL], [NIL, NIL]];  GetBlock: INTERNAL PROC [bitmapUnder, cookie: BOOLEAN]    RETURNS [wh: TajoOps.WindowHandle] = {    delta: INTEGER =      (IF bitmapUnder THEN Window.MinusLandBitmapUnder.SIZE ELSE 0) +        (IF cookie THEN Window.MinusLandCookieCutter.SIZE ELSE 0);    size: CARDINAL = TajoOps.WindowObject.SIZE + delta;    IF freeWindowWords < size THEN {      freeWindowBlock ¬ MSegment.GetPages[pagesForWindowSpaceIncrement];      freeWindowWords ¬ pagesForWindowSpaceIncrement*256};    wh ¬ freeWindowBlock + delta;    freeWindowBlock ¬ freeWindowBlock + size;    freeWindowWords ¬ freeWindowWords - size;    RETURN[wh]};  AllocateWindow: PUBLIC ENTRY PROC [bitmapUnder, cookie: BOOLEAN ¬ FALSE]    RETURNS [window: Window.Handle] = {    wh: TajoOps.WindowHandle;    IF freeWindows[bitmapUnder][cookie] = NIL THEN      wh ¬ GetBlock[bitmapUnder, cookie]    ELSE {      wh ¬ freeWindows[bitmapUnder][cookie];      freeWindows[bitmapUnder][cookie] ¬ LOOPHOLE[(@wh.window).SetSibling[NIL]]};    wh­ ¬ [      window: NULL,      cookieVariant: cookie, underVariant: bitmapUnder, allocated: TRUE];    RETURN[@wh.window]};  DeallocateWindow: PUBLIC ENTRY PROC [window: Window.Handle] = {    tw: TajoOps.WindowHandle = LOOPHOLE[window, TajoOps.WindowHandle];    tw.allocated ¬ FALSE;    [] ¬ window.SetParent[NIL];    [] ¬ window.SetChild[NIL];    [] ¬ window.SetSibling[      @freeWindows[tw.underVariant][tw.cookieVariant].window];    freeWindows[tw.underVariant][tw.cookieVariant] ¬ tw};  DestroyWindow: PUBLIC PROC [window: Window.Handle] = {    child, sibling: Window.Handle;    child ¬ window.GetChild;    UNTIL child = NIL DO      sibling ¬ child.GetSibling[];      DestroyWindow[child];      child ¬ sibling;      ENDLOOP;    Context.DestroyAll[window];    DeallocateWindow[window]};  IsWindowValid: PUBLIC PROC [window: Window.Handle] RETURNS [BOOLEAN] = {    RETURN[LOOPHOLE[window, TajoOps.WindowHandle].allocated]};  -- exprted to ToolWindowOps  ClippingBox: PUBLIC PROC [window: Window.Handle, newBox: Window.Box]    RETURNS [Window.Box] = {    tool: Stuff = Context.Find[stuff, window];    height: INTEGER;    IF tool = NIL THEN RETURN[[[0, 0], [0, 0]]];    height ¬ IF tool.named THEN WindowFont.FontHeight[] ELSE 1;    RETURN[[[1, height], [newBox.dims.w - 2, newBox.dims.h - (height + 1)]]]};  DrawClippingWindow: PUBLIC ToolWindow.DisplayProcType = {    Display.Black[window, [[0, 0], window.GetBox.dims]]};  FindClippingWindow: PUBLIC PROC [window: Window.Handle]    RETURNS [Window.Handle] = {    IF window = NIL THEN RETURN[NIL];    IF window = Window.rootWindow THEN RETURN[window];    FOR w: Window.Handle ¬ window, w.GetParent UNTIL w = NIL DO      tool: Stuff = Context.Find[stuff, w];      IF tool # NIL THEN {        clip: Window.Handle ¬ w.GetChild[];	IF clip = NIL THEN clip ¬ tool.clippingWindow;	RETURN[clip]};      REPEAT FINISHED => RETURN[NIL];      ENDLOOP};  GetClippedDims: PUBLIC PROC [window: Window.Handle] RETURNS [Window.Dims] = {    tool: Stuff = Context.Find[stuff, window];    RETURN[ClippingBox[window, GetNormalBox[window]].dims]};  GetNormalBox: PUBLIC PROC [window: Window.Handle] RETURNS [Window.Box] = {    tool: Stuff = Context.Find[stuff, window];    IF tool = NIL THEN RETURN[[[0, 0], [0, 0]]];    SELECT tool.state FROM      tiny => RETURN[tool.tinyBox];      active, inactive => RETURN[window.GetBox];      ENDCASE => ERROR};  SetClippingBox: PUBLIC PROC [    window, clip: Window.Handle, gravity: Window.Gravity] = {    IF clip # NIL AND window # NIL THEN       clip.SlideAndSize[ClippingBox[window, window.GetBox[]], gravity]};  SetTinyPlace: PUBLIC PROC [window: Window.Handle, place: Window.Place] = {    tool: Stuff = Context.Find[stuff, window];    IF tool = NIL THEN RETURN;    SELECT tool.state FROM      active, inactive => tool.tinyBox.place ¬ place;      tiny => window.SlideAndSize[        tool.limitProc[window, [place, window.GetBox.dims]], nw];      ENDCASE};  StripMesa: PROC [name: LONG STRING] RETURNS [BOOLEAN] = {    IF name = NIL OR ToolFont.StringWidth[name] < TajoOps.tinyWidth - 2 THEN      RETURN[FALSE]    ELSE {      newName: String.SubStringDescriptor ¬ [        base: name, offset: name.length - 5, length: 5];      mesa: String.SubStringDescriptor ¬ [base: ".mesa", offset: 0, length: 5];      RETURN[String.EquivalentSubString[@newName, @mesa]]}};  SplitName: PUBLIC PROC [name: LONG STRING, parseLongName: BOOLEAN]    RETURNS [left, right: LONG STRING, implicitTinySpace: BOOLEAN] = {    i, middle, end: CARDINAL;    IF parseLongName THEN {      [left, right] ¬ ParseName[name]; implicitTinySpace ¬ right # NIL}    ELSE {      implicitTinySpace ¬ FALSE;      left ¬ String.CopyToNewString[name, Heap.systemZone];      right ¬ NIL};    IF StripMesa[right] THEN right.length ¬ right.length - 5;    IF StripMesa[left] THEN left.length ¬ left.length - 5;    IF right ~= NIL OR ToolFont.StringWidth[left] < TajoOps.tinyWidth - 2 THEN      RETURN[left, right, implicitTinySpace];    end ¬ left.length;    middle ¬ (end + 1)/2;    IF ToolFont.StringWidth[left] > ((TajoOps.tinyWidth*2) - 4) THEN {      -- add '...' --      leftWidth, rightWidth, rightEnd, leftEnd, rightSize: CARDINAL ¬ 0;      dotWidth: CARDINAL = ToolFont.StringWidth["..."];      roomInBox: CARDINAL = (TajoOps.tinyWidth - 2) - dotWidth;      FOR i DECREASING IN [middle..left.length) DO        IF (rightWidth + WindowFont.CharWidth[left[i]]) < roomInBox THEN          rightWidth ¬ rightWidth + WindowFont.CharWidth[left[i]]        ELSE {rightEnd ¬ i + 1; EXIT}        ENDLOOP;      rightSize ¬ 3 + (left.length - rightEnd);      right ¬ Heap.systemZone.NEW[StringBody [rightSize]];      FOR i IN [0..3) DO String.AppendChar[right, '.] ENDLOOP;      FOR i IN [rightEnd..left.length) DO        String.AppendChar[right, left[i]] ENDLOOP;      FOR i IN [0..middle) DO        IF (leftWidth + WindowFont.CharWidth[left[i]]) < roomInBox THEN          leftWidth ¬ leftWidth + WindowFont.CharWidth[left[i]]        ELSE {leftEnd ¬ i; EXIT}        ENDLOOP;      left.length ¬ leftEnd + 3;      FOR i IN [leftEnd..leftEnd + 3) DO left[i] ¬ '. ENDLOOP;      RETURN}    ELSE {  -- split in half --      right ¬ Heap.systemZone.NEW[StringBody [end - middle]];      FOR i IN [middle..end) DO String.AppendChar[right, left[i]] ENDLOOP;      left.length ¬ middle};    RETURN};  ParseName: PROC [name: LONG STRING] RETURNS [left, right: LONG STRING] = {    i, middle, end, spacePos, length: CARDINAL;    spacePos ¬ 0;    length ¬ 0;    FOR i IN [0..name.length) DO      char: CHARACTER = name[i];      length ¬ length + WindowFont.CharWidth[char];      SELECT char FROM        Ascii.SP => IF spacePos = 0 THEN spacePos ¬ i ELSE {end ¬ i; EXIT};        '., '$, '!, '-, '+, IN ['A..'Z], IN ['a..'z], IN ['0..'9] => NULL;        ENDCASE => {end ¬ i; EXIT};      REPEAT FINISHED => end ¬ name.length;      ENDLOOP;    IF spacePos = 0 THEN {      left ¬ String.CopyToNewString[name, Heap.systemZone];      left.length ¬ end;      RETURN[left: left, right: NIL]};    middle ¬ spacePos;    left ¬ Heap.systemZone.NEW[StringBody [middle]];    left.length ¬ middle;    FOR i IN [0..middle) DO left[i] ¬ name[i] ENDLOOP;    middle ¬ middle + 1;    right ¬ Heap.systemZone.NEW[StringBody [end - middle]];    right.length ¬ end - middle;    FOR i IN [0..end - middle) DO right[i] ¬ name[i + middle] ENDLOOP;    RETURN};  Type: PUBLIC PROC [window: Window.Handle] RETURNS [ToolWindow.WindowType] = {    SELECT window FROM      NIL => RETURN[other];      Window.rootWindow => RETURN[root];      ENDCASE;    IF Context.Find[stuff, window] # NIL THEN RETURN[tool];    SELECT (window ¬ window.GetParent[]) FROM       Window.rootWindow => RETURN[other];	-- first level non-tool window      NIL => RETURN[other];			-- not in tree      ENDCASE;    SELECT (window ¬ window.GetParent[]) FROM      Window.rootWindow => RETURN[clipping];	-- 2nd level window      NIL => RETURN[other];			-- first level wierd window      ENDCASE;    SELECT window.GetParent[] FROM      Window.rootWindow => RETURN[sub];		-- 3rd level window      ENDCASE => RETURN[other]};		-- something else  END.
-- File: FileTransfersF.mesa - last edit:-- Riggle.PA            8-Aug-86 12:50:35-- Copyright (C) 1982, 1984 , 1986 by Xerox Corporation. All rights reserved. -- File: FileTransfersF.mesa - last edit by:  -- BJD    	19-Jun-84 16:31:17  -- BXM  	12-Feb-82 11:28:52  -- LXR    	13-Oct-82 10:04:23DIRECTORY  Environment USING [bytesPerPage],  FileName USING [VFN],  FileTransfer USING [    Confirmation, Error, FileInfo, FileType, MessageProc, VetoProc],  FileTransferOps USING [    CopyCommand, Connection, ConnectionObject, DeleteCommand,     FTHandle, ListCommand, maxFileName, Operation, PrimitivesObject,    RenameCommand, RetrieveStreamCommand, Which, z],  FileTransferUtils USING [    AppendVFN, CheckAbort, CreateFT, FileTransferToMFileType,    HasWildCard, Post, SetPrimitive, SetupInfo, ShowProgress, WriteDate],  Heap USING [systemZone],  MFile USING [    Access, Acquire, AppendErrorMessage, Copy, CopyFileHandle, Delete,    EnumerateDirectory, EnumerateProc, EnumerateState, Error, FreeSearchPath,    GetProperties, GetNextHandleForReading, GetSearchPath, Handle, Release, Rename,    SearchPath, searchPathNotUsed, SetAccess, SetType, Type],  MSegment USING [Address, Create, Kill],  MStream USING [Copy, Create, Error, Handle],  Stream USING [    Block, CompletionCode, defaultInputOptions, EndOfStream, Handle,     SubSequenceType],  String USING [    AppendChar, AppendString, CopyToNewString, FreeString, MakeString,    StringBoundsFault],  Time USING [Packed];FileTransfersF: PROGRAM  IMPORTS    FileTransfer, FileTransferOps, FileTransferUtils, Heap, MFile, MSegment, MStream,    Stream, String  EXPORTS FileTransfer, FileTransferUtils =  BEGIN OPEN FileTransfer;  Connection: TYPE = FileTransferOps.Connection;  ConnectionObject: PUBLIC TYPE = FileTransferOps.ConnectionObject;  Which: TYPE = FileTransferOps.Which;  VFN: TYPE = FileName.VFN;  heap: UNCOUNTED ZONE = Heap.systemZone;   CR: LONG STRING = "";  LocalCopy: PUBLIC PROC [c: Connection, p: FileTransferOps.CopyCommand] = {    old: STRING ¬ [FileTransferOps.maxFileName];    new: STRING ¬ [FileTransferOps.maxFileName];    oldFile, newFile: MFile.Handle ¬ NIL;    answer: Confirmation ¬ do;    oldTarget: BOOLEAN;    Release: PROC = {Cleanup[oldFile]; Cleanup[newFile]};    GetInfo: PROC [c: Connection] RETURNS [source, target: FileInfo] = {      GetLocalInfo[c, oldFile, source]; GetLocalInfo[c, newFile, target];      RETURN[source: c.info[source], target: c.info[target]]};    FileTransferUtils.SetupInfo[c, old, p.source, FALSE, source];    FileTransferUtils.SetupInfo[c, new, p.dest, FALSE, target];    CheckParameters[c: c, old: old, new: new];    FileTransferUtils.CheckAbort[c];    oldFile ¬ OpenLocalFile[c, old, source, FALSE];    IF oldFile = NIL THEN {      FileTransferUtils.Post[        c, fatal, old, " doesn't exist."L, CR]; ERROR Error[c, skipOperation]};    BEGIN ENABLE     { UNWIND => Release[];       MFile.Error => IF code = noRoomOnVolume THEN {	FileTransferUtils.Post[c, fatal, "No room on volume."L, CR];	ERROR Error[c, skipOperation]}       };     FileTransferUtils.Post[c, terse, old ! UNWIND => Release[]];    newFile ¬ OpenLocalFile[c, new, target, TRUE];     oldTarget ¬ c.info[target].oldFile;    c.good[target] ¬ ~oldTarget OR c.info[target].readProtect;    IF p.dates THEN {      GetLocalInfo[c, oldFile, source];      GetLocalInfo[c, newFile, target];      FileTransferUtils.WriteDate[c, source]};    FileTransferUtils.Post[c, terse, " to "L, new];    IF oldTarget THEN {      FileTransferUtils.Post[c, verbose, " [Old File]"L];       IF p.dates THEN {        IF c.info[target].readProtect THEN 	  FileTransferUtils.Post[c, verbose, "[?]"L]	ELSE FileTransferUtils.WriteDate[c, target]}}    ELSE FileTransferUtils.Post[c, verbose, " [New File]"L];    IF p.veto # NIL THEN       [answer, p.dates] ¬ p.veto[c, c.clientData, c.post, GetInfo, p.dates];    END;    Cleanup[newFile]; newFile ¬ NIL;    SELECT answer FROM      do => {        BEGIN ENABLE UNWIND => Release[];	GetLocalInfo[c, oldFile, source];	MFile.Copy[oldFile, new];	END;        Cleanup[oldFile];	FileTransferUtils.Post[c, verbose, " copied"L, CR]};      skip => {Cleanup[oldFile]; FileTransferUtils.Post[c, terse, " XXX"L, CR]};      abort => {Cleanup[oldFile]; ERROR ABORTED};      ENDCASE => ERROR Error[c, unknown]};  CheckParameters: PROC [c: Connection, old, new: STRING] = {    SELECT TRUE FROM      old.length = 0 => {        FileTransferUtils.Post[c, fatal, "Source of copy not specified."L, CR];        ERROR Error[c, skipOperation]};      new.length = 0 => {        FileTransferUtils.Post[c, fatal, "Destination of copy not specified."L, CR];        ERROR Error[c, skipOperation]};      ENDCASE};    LocalDelete: PUBLIC PROC [    c: Connection, p: FileTransferOps.DeleteCommand] = {    name: STRING = [FileTransferOps.maxFileName];    answer: Confirmation ¬ do;    file: MFile.Handle ¬ NIL;    GetInfo: PROC [conn: Connection] RETURNS [source, target: FileInfo] = {      GetInfoInternal[conn, @file, source, TRUE];      RETURN[source: conn.info[source], target: NIL]};    FileTransferUtils.SetupInfo[c, name, p.file, FALSE];    BEGIN ENABLE UNWIND => Cleanup[file];    FileTransferUtils.Post[c, terse, name, " ... "L];    IF p.veto # NIL THEN       answer ¬ p.veto[c, c.clientData, c.post, GetInfo, FALSE].confirm;    END;    SELECT answer FROM      skip => {Cleanup[file]; FileTransferUtils.Post[c, terse, "  XXX"L, CR]};      abort => {Cleanup[file]; ERROR ABORTED};      do => {        BEGIN ENABLE UNWIND => Cleanup[file];        IF file = NIL THEN file ¬ OpenFileInternal[c, delete, TRUE];	MFile.Delete[file]; 	END;        FileTransferUtils.Post[c, terse, "  deleted."L, CR]};      ENDCASE => ERROR Error[c, unknown]};        LocalList: PUBLIC PROC [    c: Connection, p: FileTransferOps.ListCommand] =    BEGIN    found: BOOLEAN ¬ FALSE;    sp: MFile.SearchPath ¬ NIL;    name: STRING = [FileTransferOps.maxFileName];    CleanUp: PROCEDURE = INLINE {      IF sp # NIL THEN MFile.FreeSearchPath[sp]};    ListLocalOne: MFile.EnumerateProc = {      fileName: STRING = [FileTransferOps.maxFileName];      answer: Confirmation;      GetInfo: PROC [c: Connection] RETURNS [source, target: FileInfo] = {        file: MFile.Handle = fileProc[anchor, []];        c.info[source].body ¬ name; c.good[source] ¬ FALSE;        GetLocalInfo[c, file, source ! UNWIND => MFile.Release[file]];	MFile.Release[file];	RETURN[source: c.info[source], target: NIL]};      found ¬ TRUE;      IF spIndex # MFile.searchPathNotUsed THEN {         ENABLE String.StringBoundsFault => RESUME[NIL];        String.AppendString[to: fileName, from: sp.directories[spIndex]];	IF fileName[fileName.length-1] # '> THEN String.AppendChar[fileName, '>]};      String.AppendString[to: fileName, from: fullName];      answer ¬ p.proc[c, c.clientData, fileName, c.post, GetInfo];      FileTransferUtils.CheckAbort[c];      RETURN[IF answer = do THEN FALSE ELSE TRUE]};          { ENABLE UNWIND => CleanUp[];    FileTransferUtils.SetupInfo[c, name, p.files, FALSE];     sp ¬ MFile.GetSearchPath[];    MFile.EnumerateDirectory[name, ListLocalOne, fileAndDirectories];    IF ~found THEN {      FileTransferUtils.Post[        c, warning, name, " not found"L, CR];	ERROR Error[c, notFound]};    CleanUp[]    }    END;        LocalRename: PUBLIC PROC [c: Connection, p: FileTransferOps.RenameCommand] = {    old: STRING ¬ [FileTransferOps.maxFileName];    new: STRING ¬ [FileTransferOps.maxFileName];    file: MFile.Handle;    FileTransferUtils.AppendVFN[s: old, vfn: p.old, remote: FALSE, rename: TRUE];    FileTransferUtils.AppendVFN[new, p.new, FALSE, TRUE];    file ¬ MFile.Acquire[old, rename, []];    MFile.Rename[file, new];    MFile.Release[file]};   LocalRec: TYPE = RECORD [    fh: MFile.Handle ¬ NIL,     state: MFile.EnumerateState ¬ NIL,     filter: LONG STRING,    oneFile: BOOLEAN ¬ FALSE];  LocalHandle: TYPE = LONG POINTER TO LocalRec;    FreeLocalRec: PROC [ft: FileTransferOps.FTHandle, lp: LONG POINTER] = {    lr: LocalHandle = LOOPHOLE[ft.data];    FreeEnumeration[ft];    String.FreeString[heap, lr.filter];    FileTransferOps.z.FREE[@lp]};      LocalRetrieveStream: PUBLIC PROC [      c: Connection, p: FileTransferOps.RetrieveStreamCommand] = {    name: STRING = [FileTransferOps.maxFileName];    msg: STRING ¬ [20];    error: BOOLEAN ¬ FALSE;    lr: LocalHandle = FileTransferOps.z.NEW[LocalRec];    ft: FileTransferOps.FTHandle;    FileTransferUtils.SetupInfo[c, name, p.remote, FALSE];    lr.filter ¬ String.CopyToNewString[name, heap];    ft ¬ FileTransferUtils.CreateFT[      c, p, String.MakeString[heap, FileTransferOps.maxFileName]];    c.info[source].body ¬ ft.file;    ft.op ¬ retrieveStream;    ft.free ¬ FreeLocalRec; ft.data ¬ lr;    [file: lr.fh, state: lr.state] ¬ MFile.GetNextHandleForReading[      filter: lr.filter, name: ft.file, release: [], lastState: NIL      ! MFile.Error => {        SELECT code FROM          illegalName =>  String.AppendString[msg," is illegal"L];	  volumeNotOpen => {	    FOR i: CARDINAL IN [0..name.length) DO	      IF name[i] = '> THEN { name.length ¬ i+1; EXIT }	      ENDLOOP;	    String.AppendString[msg," volume not open"L]};	  ENDCASE;	error ¬ TRUE; CONTINUE}];    IF lr.fh = NIL THEN {      sh: Stream.Handle = LOOPHOLE[ft];      IF error THEN FileTransferUtils.Post[c, fatal, name, msg, CR]      ELSE FileTransferUtils.Post[        c, fatal, name, " is not found or can't be acquired"L, CR];      sh.delete[sh];       ERROR Error[c, skipOperation]};    IF NOT (FileTransferUtils.HasWildCard[p.remote.directory]       OR FileTransferUtils.HasWildCard[p.remote.name]) THEN lr.oneFile ¬ TRUE;    UNTIL LocalNextStreamInternal[c, ft] = do DO      ft ¬ LOOPHOLE[c.stream];      IF ft = NIL THEN RETURN;      ENDLOOP};  LocalNextStreamInternal: PUBLIC PROC [      c: Connection, ft: FileTransferOps.FTHandle]       RETURNS [answer: Confirmation] = {    lr: LocalHandle = LOOPHOLE[ft.data];    first: BOOLEAN = c.stream = NIL;    GetInfo: PROC [c: Connection] RETURNS [source, target: FileInfo] = {      GetInfoInternal[c, @lr.fh, source, FALSE];      RETURN[source: c.info[source], target: NIL]};          IF first THEN c.stream ¬ LOOPHOLE[ft]    ELSE {      IF ft.stream # NIL THEN {        ft.stream.delete[ft.stream]; ft.stream ¬ NIL};      IF lr.oneFile THEN {       FreeEnumeration[ft]; lr.state ¬ NIL}      ELSE         [file: lr.fh, state: lr.state] ¬ MFile.GetNextHandleForReading[          filter: lr.filter, name: ft.file, release: [], lastState: lr.state]};    IF lr.state = NIL THEN {      sh: Stream.Handle = LOOPHOLE[ft];      sh.delete[sh];       RETURN[skip]};    BEGIN ENABLE UNWIND => {      FreeEnumeration[ft]; Cleanup[lr.fh]};     FileTransferUtils.Post[c, terse, ft.file];    FileTransferUtils.CheckAbort[c];    c.good ¬ ALL[FALSE];    IF ft.dates THEN {      GetInfoInternal[c, @lr.fh, source, FALSE];      FileTransferUtils.WriteDate[c, source]};    IF ft.veto # NIL THEN       [answer, ft.dates] ¬ ft.veto[c, c.clientData, c.post, GetInfo, ft.dates]    ELSE answer ¬ do;    FileTransferUtils.CheckAbort[c];    IF answer = do THEN {      FileTransferUtils.Post[c, terse, "..."L];      ft.stream ¬ MStream.Create[lr.fh, []];      ft.object.options ¬ ft.stream.options;      RETURN};    Cleanup[lr.fh];     SELECT answer FROM      skip => FileTransferUtils.Post[c, terse, "  XXX"L, CR];      abort => ERROR ABORTED;      ENDCASE => ERROR Error[c, unknown]    END};  LocalCatchErrors: PROC [    c: Connection, op: FileTransferOps.Operation, primitive: PROC[Connection],    fileName: LONG STRING ¬ NIL, vfn: VFN ¬ NIL] =    BEGIN ENABLE MFile.Error => {      msg: LONG STRING ¬ [100];      MFile.AppendErrorMessage[msg, code, file];      FileTransferUtils.Post[c, fatal, msg];      ERROR Error[c, skipOperation]};    FileTransferUtils.CheckAbort[c];    primitive[c];    END;      LocalClose: PUBLIC PROC [c: Connection, printErrs, freeObject: BOOLEAN ¬ FALSE] =    BEGIN    END;      LocalGetStreamInfo: PUBLIC PROC [ft: FileTransferOps.FTHandle] = {    GetInfoInternal[ft.conn, @LOOPHOLE[ft.data, LocalHandle].fh, source, FALSE -- FALSE because we already have our hands on the file with the appropriate access--]};  Cleanup: PROC [file: MFile.Handle] = {IF file # NIL THEN MFile.Release[file]};  FreeEnumeration: PROC [ft: FileTransferOps.FTHandle] = {    lr: LocalHandle ¬ ft.data;    IF lr.state # NIL THEN {      [] ¬ MFile.GetNextHandleForReading[        filter: lr.filter, name: ft.file, release: [], lastState: lr.state, 	stopNow: TRUE 	! MFile.Error => SELECT code FROM            noSuchFile, illegalName => CONTINUE;	    ENDCASE];       lr.state ¬ NIL}};  OpenFileInternal: PROC [c: Connection, access: MFile.Access, mightWrite: BOOLEAN]     RETURNS [file: MFile.Handle] = {    filename: LONG STRING = c.info[source].body;    file ¬ OpenLocalFile[c, filename, source, mightWrite, access]; -- this use of mightWrite is interpreted by OpenLocalFile as "setReadProtect" which may cause funny problems...    IF file # NIL THEN RETURN;    FileTransferUtils.Post[c, fatal, filename, " not found."L, CR];    ERROR Error[c, notFound]};  ChangeAccess: PUBLIC PROC [    c: Connection, file: MFile.Handle, name: LONG STRING, access: MFile.Access] = {    MFile.SetAccess[file, access ! MFile.Error =>      SELECT code FROM	conflictingAccess, protectionFault => AccessFailure[c, name, access];	ENDCASE]};  AccessFailure: PROC [      c: Connection, name: LONG STRING, err: {access, badName, protect}] = {    FileTransferUtils.Post[c, warning, name,      SELECT err FROM       access => " can't be acquired with correct access."L,       badName => " is an illegal name."L,       protect => " is read protected."L,      ENDCASE => NIL, CR];    ERROR Error[c, cantModify]};  OpenLocalFile: PUBLIC PROC [    c: Connection, name: LONG STRING, w: Which, setReadProtect: BOOLEAN,    access: MFile.Access ¬ readOnly]     RETURNS [file: MFile.Handle] = {    file ¬ NIL;    c.info[w].readProtect ¬ FALSE;    file ¬ MFile.Acquire[      name: name, access: access, release: [], mightWrite: setReadProtect       ! MFile.Error =>      SELECT code FROM	noSuchFile => CONTINUE;	illegalName =>  AccessFailure[c, name, badName];	conflictingAccess => AccessFailure[c, name, access];	protectionFault => 	  IF setReadProtect THEN {	    c.info[w].readProtect ¬ TRUE; 	    c.good[w] ¬ TRUE;	    access ¬ anchor;	    RETRY}	  ELSE AccessFailure[c, name, protect];	ENDCASE => {	  msg: LONG STRING ¬ [100];	  MFile.AppendErrorMessage[msg, code, file];	  FileTransferUtils.Post[c, fatal, msg, CR];	  ERROR Error[c, skipOperation]}];    c.info[w].oldFile ¬ file # NIL};  GetInfoInternal: PROC [      c: Connection, finger: LONG POINTER TO MFile.Handle, which: Which,      mightWrite: BOOLEAN] = {    IF c.good[which] THEN RETURN;    IF finger­ = NIL THEN finger­ ¬ OpenFileInternal[c, anchor, mightWrite];    GetLocalInfo[c, finger­, which]};  GetLocalInfo: PUBLIC PROC [c: Connection, file: MFile.Handle, which: Which] = {    info: FileInfo = c.info[which];    type: MFile.Type;    IF c.good[which] THEN RETURN;    [create: info.create, read: info.read, write: info.write,      length: info.size, type: type] ¬ MFile.GetProperties[file];    SELECT type FROM      directory, binary => info.type ¬ binary;       text => info.type ¬ text;       unknown => info.type ¬ GetType[c, file];      ENDCASE => { -- with the new char set, GetType no longer works;	FileTransferUtils.Post[	  c, fatal, CR, info.body, "'s type property was not set."L, CR];        ERROR Error[c, skipOperation]};    c.good[which] ¬ TRUE};  GetType: PROC [c: Connection, file: MFile.Handle] RETURNS [type: FileType] = {    copy: MFile.Handle;    s: MStream.Handle;    copy ¬ MFile.CopyFileHandle[file, [], readOnly ! MFile.Error =>      SELECT code FROM         conflictingAccess, protectionFault => {copy ¬ NIL; CONTINUE};	ENDCASE];    IF copy = NIL THEN RETURN[unknown];    s ¬ MStream.Create[copy, []];    DO      IF s.getByte[s ! Stream.EndOfStream => {type ¬ text; EXIT}] > 177B THEN {        type ¬ binary; EXIT};      ENDLOOP;    MFile.SetType[file, FileTransferUtils.FileTransferToMFileType[type]];    s.delete[s]};  bufferPages: CARDINAL = 4;  bufferBytes: CARDINAL = bufferPages*Environment.bytesPerPage;    DoDisk: PUBLIC PROC [c: Connection, from, to: Stream.Handle]       RETURNS [bytes: LONG CARDINAL] = {    inverted: BOOLEAN ¬ FALSE;    bytes ¬ 0;    DO      copied: LONG CARDINAL = MStream.Copy[from: from, to: to, bytes: bufferBytes        ! MStream.Error => IF code = invalidHandle THEN GOTO bothRemote];      bytes ¬ copied + bytes;      FileTransferUtils.ShowProgress[c];      inverted ¬ ~inverted;      FileTransferUtils.CheckAbort[c];      IF copied # bufferBytes THEN EXIT;      ENDLOOP;    IF inverted THEN FileTransferUtils.ShowProgress[c];    EXITS      bothRemote => bytes ¬ DoRemote[c, from, to]};  DoRemote: PUBLIC PROC [c: Connection, from, to: Stream.Handle]       RETURNS [bytes: LONG CARDINAL] = {    inverted: BOOLEAN ¬ FALSE;    buffer: LONG POINTER = AssertBuffer[c];    bytes ¬ 0;    DO      bytesTransferred: CARDINAL;      why: Stream.CompletionCode;      savedSST: Stream.SubSequenceType;      block: Stream.Block ¬ [buffer, 0, bufferBytes];      [bytesTransferred, why, savedSST] ¬ from.get[        from, block, Stream.defaultInputOptions !        Stream.EndOfStream => {          why ¬ endOfStream; bytesTransferred ¬ nextIndex; CONTINUE}];      block.stopIndexPlusOne ¬ bytesTransferred;      bytes ¬ bytes + bytesTransferred;      FileTransferUtils.ShowProgress[c];      inverted ¬ ~inverted;      FileTransferUtils.CheckAbort[c];      to.put[to, block, FALSE];      IF why = endOfStream THEN EXIT;      ENDLOOP;    MSegment.Kill[c.buffer];    IF inverted THEN FileTransferUtils.ShowProgress[c]};        AssertBuffer: PROC [c: Connection] RETURNS [LONG POINTER] = {    IF c.buffer = NIL THEN      c.buffer ¬ MSegment.Create[file: NIL, release: [], pages: bufferPages];    RETURN[MSegment.Address[c.buffer]]};      LocalObject: FileTransferOps.PrimitivesObject ¬ [    catchErrors: 	LocalCatchErrors,    streamCatchErrors:	LocalCatchErrors,    deleteFile: 		LocalDelete,    listFile: 		LocalList,    renameFile: 	LocalRename,    retrieveStream: 	LocalRetrieveStream,    retrieveNextStream:	LocalNextStreamInternal,    close:		LocalClose,    getStreamInfo:	LocalGetStreamInfo ];       FileTransferUtils.SetPrimitive[local, @LocalObject];       END.
-- Copyright (C) 1981, 1982, 1984  by Xerox Corporation. All rights reserved. -- File: FileSWsA.mesa - last edited: -- JGS on	22-Nov-82 10:58:08-- PXK    	23-Nov-82 13:56:48-- RXR   	 9-Oct-81 10:03:45-- SXS   	21-Sep-82 14:49:18-- BGY     	30-Sep-82 17:17:27-- AXD    	31-Jan-84 13:32:39-- Create and Destroy stuff in hereDIRECTORY  Context: TYPE USING [Create, Data, Destroy, Find, Type, UniqueType],  DiskSource: TYPE USING [Create, Info, SetMaxDiskLength],  Event: TYPE USING [aboutToSwap, powerOff, swapping],  EventTypes: TYPE USING [    abortSession, aboutToBootPhysicalVolume, newSession, resumeDebuggee,    resumeSession, VetoEvents],  FileSW: TYPE USING [    defaultOptions, EnumerateProcType, Error, ErrorCode, Options],  Heap: TYPE USING [systemZone],  Menu: TYPE USING [MCRType],  MFile: TYPE USING [Error],  Put: TYPE USING [CR, LongString, Text],  PieceSource: TYPE USING [Create, Info, IsIt, Reset, Put],  Selection: TYPE USING [Clear, Convert, SetInsertion],  Stream: TYPE USING [Handle],  Supervisor: TYPE USING [    AddDependency, AgentProcedure, CreateSubsystem, EnumerationAborted,    SubsystemHandle],  TextSW: TYPE USING [    Access, BlinkingCaret, Create, Destroy, GetOptions, Options,    SetEOF, SetOptions, SetSource],  TextSource: TYPE USING [Error, Handle, Position],  UserTerminal: TYPE USING [BlinkDisplay],  Window: TYPE USING [Handle, Validate];FileSWsA: MONITOR  IMPORTS    Context, DiskSource, Event, FileSW, Heap, PieceSource, MFile, Put, Selection,    Supervisor, TextSW, TextSource, UserTerminal, Window  EXPORTS FileSW =  BEGIN OPEN FileSW, TextSource;  -- GLOBAL Data and Stuff  context: Context.Type = Context.UniqueType[];  ContextObject: TYPE = RECORD [    allowTypeIn, resetLengthOnNewSession: BOOLEAN, source: TextSource.Handle];  ContextHandle: TYPE = LONG POINTER TO ContextObject;  agent: Supervisor.SubsystemHandle = Supervisor.CreateSubsystem[CheckEvent];  FSWItem: TYPE = LONG POINTER TO FSWItemObject;  FSWItemObject: TYPE = RECORD [link: FSWItem, sw: Window.Handle];  fswList: FSWItem ¬ NIL;  z: UNCOUNTED ZONE = Heap.systemZone;  Error: PUBLIC SIGNAL [code: FileSW.ErrorCode] = CODE;  -- Create/Destroy/Load Procedures   Create: PUBLIC PROC [    sw: Window.Handle, name: LONG STRING,    options: FileSW.Options ¬ defaultOptions, s: Stream.Handle ¬ NIL,    position: TextSource.Position ¬ 0, allowTypeIn: BOOLEAN ¬ TRUE,    resetLengthOnNewSession: BOOLEAN ¬ FALSE] = {    LockedLink: ENTRY PROC = {      ENABLE UNWIND => NULL;      fswItem: FSWItem = z.NEW[FSWItemObject ¬ [link: fswList, sw: sw]];      fswList ¬ fswItem};    data: ContextHandle;    source: TextSource.Handle;    IF IsIt[sw] THEN ERROR Error[isAFileSW];    source ¬ DiskSource.Create[      name, IF options.access = edit THEN read ELSE options.access, s];    IF options.access = edit THEN source ¬ PieceSource.Create[source, NIL];    TextSW.Create[sw, source, NIL, options, position, allowTypeIn];    data ¬ z.NEW[      ContextObject ¬ [      allowTypeIn: allowTypeIn, resetLengthOnNewSession: resetLengthOnNewSession,      source: source]];    Context.Create[type: context, data: data, proc: DestroyContext, window: sw];    LockedLink[];    Window.Validate[sw]};  Destroy: PUBLIC PROC [sw: Window.Handle] = {    Context.Destroy[type: context, window: sw]};  DestroyContext: ENTRY PROC [data: ContextHandle, sw: Window.Handle] = {    ENABLE UNWIND => NULL;    curr: FSWItem ¬ fswList;    prev: FSWItem ¬ fswList;    IF data = NIL THEN ERROR Error[notAFileSW];    IF fswList = NIL THEN ERROR;    IF curr.sw = sw THEN fswList ¬ curr.link    ELSE      UNTIL (curr ¬ curr.link) = NIL DO        IF curr.sw = sw THEN {prev.link ¬ curr.link; EXIT}; prev ¬ curr; ENDLOOP;    z.FREE[@curr];    TextSW.Destroy[sw]; -- Make sure that TextSW goes away before source    IF data.source # NIL THEN [] ¬ data.source.actOn[data.source, destroy];    z.FREE[@data]};  GetSource: PROC [sw: Window.Handle] RETURNS [TextSource.Handle] = {    h: ContextHandle = Context.Find[context, sw];    RETURN[IF h = NIL THEN NIL ELSE h.source]};    Enumerate: PUBLIC ENTRY PROC [proc: EnumerateProcType] =    BEGIN    ENABLE UNWIND => NULL;    this: FSWItem;    name: LONG STRING;    access: TextSW.Access;    FOR this ¬ fswList, this.link UNTIL this = NIL DO      source: TextSource.Handle ¬ GetSource[this.sw];      IF PieceSource.IsIt[source] THEN source ¬ PieceSource.Info[source].original;      name ¬ DiskSource.Info[source].name;      access ¬ TextSW.GetOptions[this.sw].access;      IF proc[this.sw, name, access] THEN EXIT;      ENDLOOP;    END;  GetFile: PUBLIC PROC [sw: Window.Handle]    RETURNS [name: LONG STRING, s: Stream.Handle] =    BEGIN    source: TextSource.Handle ¬ GetSource[sw];    IF PieceSource.IsIt[source] THEN source ¬ PieceSource.Info[source].original;    [name, s] ¬ DiskSource.Info[source];    END;  IsIt: PUBLIC PROC [sw: Window.Handle] RETURNS [yes: BOOLEAN] =    BEGIN RETURN[Context.Find[context, sw] # NIL]; END;  LoadMCR: PUBLIC Menu.MCRType =    BEGIN OPEN Selection;    str: LONG STRING;    blink: BOOLEAN ¬ FALSE;    IF ~IsIt[window] OR (str ¬ Convert[string]) = NIL THEN      UserTerminal.BlinkDisplay[]    ELSE      SetFile[        window, str, NIL !        TextSource.Error => BEGIN UserTerminal.BlinkDisplay[]; CONTINUE; END];    END;  SetFile: PUBLIC PROC [    sw: Window.Handle, name: LONG STRING, s: Stream.Handle ¬ NIL,    position: TextSource.Position ¬ 0] =    BEGIN    h: ContextHandle = Context.Find[context, sw];    IF h # NIL THEN {      source, oldSource: TextSource.Handle;      access: TextSW.Access = TextSW.GetOptions[sw].access;      source ¬ DiskSource.Create[name, access, s];      oldSource ¬ h.source;      Selection.SetInsertion[NIL, NIL, NIL];  -- even if I don't have it!!!      TextSW.SetSource[sw, source, position];      h.source ¬ source;      [] ¬ oldSource.actOn[oldSource, destroy];      Window.Validate[sw]}    ELSE ERROR FileSW.Error[notAFileSW];    END;  SetTypescriptSize: PUBLIC PROC [sw: Window.Handle, size: LONG CARDINAL] =    BEGIN    h: ContextHandle = Context.Find[context, sw];    IF h # NIL THEN      IF TextSW.GetOptions[sw].access = append THEN        DiskSource.SetMaxDiskLength[h.source, size]      ELSE ERROR FileSW.Error[accessDenied]    ELSE ERROR FileSW.Error[notAFileSW];    END;  -- Editable FileSW Procedures  IsEditable: PUBLIC PROC [sw: Window.Handle] RETURNS [yes: BOOLEAN] =    BEGIN RETURN[PieceSource.IsIt[GetSource[sw]]]; END;  MakeEditable: PUBLIC PROC [sw: Window.Handle] RETURNS [ok: BOOLEAN] =    BEGIN    source: TextSource.Handle ¬ GetSource[sw];    IF PieceSource.IsIt[source] OR DiskSource.Info[source].s = NIL THEN  -- Really need TextSource.GetState      RETURN[FALSE];    source ¬ PieceSource.Create[source, NIL ! TextSource.Error => GOTO noGood];    LocalSetSource[sw, source, edit];    RETURN[TRUE];    EXITS noGood => {UserTerminal.BlinkDisplay[]; RETURN[FALSE]};    END;  PutEditableFile: PUBLIC PROC [sw: Window.Handle, name: LONG STRING]    RETURNS [ok: BOOLEAN ¬ TRUE] =    BEGIN    source: TextSource.Handle ¬ GetSource[sw];    IF ~ValidPieceSource[source] THEN GOTO noGood;    TextSW.BlinkingCaret[sw, off];    source ¬ PieceSource.Put[      source, name ! MFile.Error => {TextSW.BlinkingCaret[sw, on]; GOTO noGood}];    LocalSetSource[sw, source, read];    EXITS noGood => {UserTerminal.BlinkDisplay[]; RETURN[FALSE]};    END;  ResetEditableFile: PUBLIC PROC [sw: Window.Handle] =    BEGIN    source: TextSource.Handle ¬ GetSource[sw];    IF ValidPieceSource[source] THEN {      TextSW.BlinkingCaret[sw, off];      source ¬ PieceSource.Reset[source];      LocalSetSource[sw, source, read, TRUE]}    ELSE UserTerminal.BlinkDisplay[];    END;  ValidPieceSource: PROC [source: TextSource.Handle] RETURNS [ok: BOOLEAN] =    {    RETURN[      PieceSource.IsIt[source] AND (PieceSource.Info[source].original # NIL)]};  LocalSetSource: PROC [    sw: Window.Handle, source: TextSource.Handle, access: TextSW.Access,    reset: BOOLEAN ¬ FALSE] =    BEGIN    h: ContextHandle = Context.Find[context, sw];    options: TextSW.Options;    TextSW.SetSource[sw: sw, source: source, reset: reset];    h.source ¬ source;    options ¬ TextSW.GetOptions[sw];    options.access ¬ access;    TextSW.SetOptions[sw, options];    Window.Validate[sw];    TextSW.BlinkingCaret[sw, IF access = read THEN off ELSE on];    END;  -- Event Notification   CheckEvent: Supervisor.AgentProcedure =    BEGIN    this: FSWItem;    source: TextSource.Handle;    FOR this ¬ fswList, this.link UNTIL this = NIL DO      source ¬ GetSource[this.sw];      SELECT event FROM        EventTypes.aboutToBootPhysicalVolume => {          [] ¬ source.actOn[source, truncate]; [] ¬ source.actOn[source, sleep]};        IN EventTypes.VetoEvents =>          IF ValidPieceSource[source] THEN {            Put.Text[NIL, "Please terminate editing of "L];            Put.LongString[              NIL, DiskSource.Info[PieceSource.Info[source].original].name];            Put.CR[NIL];            UserTerminal.BlinkDisplay[];            ERROR Supervisor.EnumerationAborted};        EventTypes.newSession => {          cH: ContextHandle = Context.Find[context, this.sw];          IF cH # NIL AND cH.resetLengthOnNewSession THEN {            options: TextSW.Options = TextSW.GetOptions[this.sw];            [] ¬ source.actOn[source, wakeup];            TextSW.SetSource[this.sw, source, 0];            IF Selection.Convert[subwindow] = this.sw THEN Selection.Clear[];            IF options.access = append THEN TextSW.SetEOF[this.sw, 0]}};        EventTypes.resumeSession => Wakeup[this.sw, source];        EventTypes.resumeDebuggee, EventTypes.abortSession => {          [] ¬ source.actOn[source, mark]; [] ¬ source.actOn[source, sleep]};        ENDCASE;      ENDLOOP;    END;  Wakeup: PROC [sw: Window.Handle, source: TextSource.Handle] =    BEGIN    options: TextSW.Options = TextSW.GetOptions[sw];    source.actOn[source, wakeup];    END;  Init: PROC =    BEGIN    Supervisor.AddDependency[client: agent, implementor: Event.aboutToSwap];    Supervisor.AddDependency[client: agent, implementor: Event.swapping];    Supervisor.AddDependency[client: agent, implementor: Event.powerOff];    END;  -- MainLine code  Init[];  END. -- of FileSWsA
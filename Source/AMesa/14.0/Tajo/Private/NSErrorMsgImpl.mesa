-- File: NSErrorMsgImpl.mesa - last edit:-- bjd                 10-Jun-85 10:59:23-- Copyright (C) 1985 by Xerox Corporation. All rights reserved.DIRECTORY  Auth USING [AuthenticationProblem, CallProblem, WhichArg],  CH USING [ReturnCode],  Courier USING [ErrorCode],  NSErrorMsg USING [],  NSErrorMsgStrings,  ErrorTab,  Format USING [DecimalFormat, Number, StringProc, SubString],  NSFile USING [AccessProblem, ArgumentProblem, AuthenticationProblem, ClearinghouseProblem, ConnectionProblem, ErrorRecord, HandleProblem, InsertionProblem, ServiceProblem, SessionProblem, SpaceProblem, TransferProblem, UndefinedProblem],  Runtime USING [GetTableBase, GlobalFrame],  String;    NSErrorMsgImpl: PROGRAM  IMPORTS NSErrorMsgStrings, Format, Runtime EXPORTS NSErrorMsg =  BEGIN    et: ErrorTab.CSRptr = Runtime.GetTableBase[    Runtime.GlobalFrame[NSErrorMsgStrings]];    PostCourierError: PUBLIC PROCEDURE [    errorCode: Courier.ErrorCode, post: Format.StringProc, data: LONG STRING ¬ NIL] =    BEGIN    ss: String.SubStringDescriptor ¬ [      base: @et[et.stringOffset],      offset: et.CourierError[errorCode].offset,      length: et.CourierError[errorCode].length];    post["Courier Error: "L, data];    Format.SubString[proc: post, ss: @ss, clientData: data];      END;  PostNSFileError: PUBLIC PROCEDURE [    error: NSFile.ErrorRecord, post: Format.StringProc, data: LONG STRING ¬ NIL] =    BEGIN OPEN NSFile;    Access: PROC [problem: AccessProblem] = {      ss: String.SubStringDescriptor ¬ [	base: @et[et.stringOffset],	offset: et.NSFileAccessError[problem].offset,	length: et.NSFileAccessError[problem].length];      post["Access Problem: "L, data];      Format.SubString[proc: post, ss: @ss, clientData: data]};    Argument: PROC [problem: ArgumentProblem] = {      ss: String.SubStringDescriptor ¬ [	base: @et[et.stringOffset],	offset: et.NSFileArgumentError[problem].offset,	length: et.NSFileArgumentError[problem].length];      post["Argument Problem: "L, data];      Format.SubString[proc: post, ss: @ss, clientData: data]};    Authentication: PROC [problem: AuthenticationProblem] = {      ss: String.SubStringDescriptor ¬ [	base: @et[et.stringOffset],	offset: et.NSFileAuthenticationError[problem].offset,	length: et.NSFileAuthenticationError[problem].length];      post["Authentication Problem: "L, data];      Format.SubString[proc: post, ss: @ss, clientData: data]};    Clearinghouse: PROC [problem: ClearinghouseProblem] = {      ss: String.SubStringDescriptor ¬ [	base: @et[et.stringOffset],	offset: et.NSFileClearinghouseError[problem].offset,	length: et.NSFileClearinghouseError[problem].length];      post["Clearinghouse Problem: "L, data];      Format.SubString[proc: post, ss: @ss, clientData: data]};    Connection: PROC [problem: ConnectionProblem] = {      ss: String.SubStringDescriptor ¬ [	base: @et[et.stringOffset],	offset: et.NSFileConnectionError[problem].offset,	length: et.NSFileConnectionError[problem].length];      post["Connection Problem: "L, data];      IF problem > returnTimedOut THEN         post["other protocol violation during call", data]      ELSE Format.SubString[proc: post, ss: @ss, clientData: data]};    Handle: PROC [problem: HandleProblem] = {      ss: String.SubStringDescriptor ¬ [	base: @et[et.stringOffset],	offset: et.NSFileHandleError[problem].offset,	length: et.NSFileHandleError[problem].length];      post["Handle Problem: "L, data];      Format.SubString[proc: post, ss: @ss, clientData: data]};    Insertion: PROC [problem: InsertionProblem] = {      ss: String.SubStringDescriptor ¬ [	base: @et[et.stringOffset],	offset: et.NSFileInsertionError[problem].offset,	length: et.NSFileInsertionError[problem].length];      post["Insertion Problem: "L, data];      Format.SubString[proc: post, ss: @ss, clientData: data]};    Service: PROC [problem: ServiceProblem] = {      ss: String.SubStringDescriptor ¬ [	base: @et[et.stringOffset],	offset: et.NSFileServiceError[problem].offset,	length: et.NSFileServiceError[problem].length];      post["Service Problem: "L, data];      Format.SubString[proc: post, ss: @ss, clientData: data]};    Session: PROC [problem: SessionProblem] = {      ss: String.SubStringDescriptor ¬ [	base: @et[et.stringOffset],	offset: et.NSFileSessionError[problem].offset,	length: et.NSFileSessionError[problem].length];      post["Session Problem: "L, data];      Format.SubString[proc: post, ss: @ss, clientData: data]};    Space: PROC [problem: SpaceProblem] = {      ss: String.SubStringDescriptor ¬ [	base: @et[et.stringOffset],	offset: et.NSFileSpaceError[problem].offset,	length: et.NSFileSpaceError[problem].length];      post["Space Problem: "L, data];      Format.SubString[proc: post, ss: @ss, clientData: data]};    Transfer: PROC [problem: TransferProblem] = {      ss: String.SubStringDescriptor ¬ [	base: @et[et.stringOffset],	offset: et.NSFileTransferError[problem].offset,	length: et.NSFileTransferError[problem].length];      post["Transfer Problem: "L, data];      Format.SubString[proc: post, ss: @ss, clientData: data]};    Undefined: PROC [problem: UndefinedProblem] = {      post["Undefined Problem: "L, data];      post ["???("L, data];      Format.Number [post, problem, Format.DecimalFormat, data];      post [")]"L, data]};    WITH error SELECT FROM 	 access => Access[problem];	 attributeType, attributeValue => Argument[problem];	 clearingHouse => Clearinghouse[problem];	 controlType, controlValue => Argument[problem];	 scopeType, scopeValue => Argument[problem];	 authentication => Authentication[problem];	 connection => Connection[problem];	 handle => Handle[problem];	 insertion => Insertion[problem];	 range => Argument[problem];         service => Service[problem];	 session => Session[problem];	 space => Space[problem];	 transfer => Transfer[problem];	 undefined => Undefined[problem];	 ENDCASE => post["Unknown NSFile error"L, data];     END;  PostCHReturnCode: PUBLIC PROC [    rc: CH.ReturnCode, post: Format.StringProc, data: LONG POINTER ¬ NIL] =    BEGIN    SELECT rc.code FROM      done => post ["[done, "L, data];      notAllowed => post ["[notAllowed, "L, data];      rejectedTooBusy => post ["[rejectedTooBusy, "L, data];      allDown => post ["[allDown, "L, data];      LOOPHOLE [4] => post ["[operationRejectedUseCourier, "L, data];      badProtocol => post ["[badProtocol, "L, data];      illegalPropertyID => post ["[illegalPropertyID, "L, data];      illegalOrgName => post ["[illegalOrgName, "L, data];      illegalDomainName => post ["[illegalDomainName, "L, data];      illegalLocalName => post ["[illegalLocalName, "L, data];      noSuchOrg => post ["[noSuchOrg, "L, data];      noSuchDomain => post ["[noSuchDomain, "L, data];      noSuchLocal => post ["[noSuchLocal, "L, data];      propertyIDNotFound => post ["[propertyIDNotFound, "L, data];      wrongPropertyType => post ["[wrongPropertyType, "L, data];      noChange => post ["[noChange, "L, data];      outOfDate => post ["[outOfDate, "L, data];      overflowOfName => post ["[overflowOfName, "L, data];      overflowOfDataBase => post ["[overflowOfDataBase, "L, data];      LOOPHOLE [50] => post ["[wrongServer, "L, data];      LOOPHOLE [60] => post ["[identifierRejected, "L, data];      LOOPHOLE [61] => post ["[verifierInvalid, "L, data];      LOOPHOLE [62] => post ["[verifierExpired, "L, data];      LOOPHOLE [63] => post ["[verifierReused, "L, data];      LOOPHOLE [64] => post ["[credentialsExpired, "L, data];      credentialsTooWeak => post ["[credentialsTooWeak, "L, data];      wasUpNowDown => post ["[wasUpNowDown, "L, data];      ENDCASE => {post ["[???("L, data];        Format.Number [post, rc.code, Format.DecimalFormat];	post ["), "L, data];	};    SELECT rc.which FROM      first => post ["first]"L, data];      second => post ["second]"L, data];      ENDCASE => {post ["???("L, data];        Format.Number [post, rc.which, Format.DecimalFormat, data];	post [")]"L, data];	};    END; -- of PostCHReturnCode  PostAuthCallProblem: PUBLIC PROCEDURE [    reason: Auth.CallProblem, whichArg: Auth.WhichArg,    post: Format.StringProc, data: LONG POINTER ¬ NIL] =    BEGIN    SELECT reason FROM      tooBusy => post ["[tooBusy, "L, data];      cannotReachAS=> post ["[cannotReachAS, "L, data];      keysUnavailable => post ["[keysUnavailable, "L, data];      strongKeyDoesNotExist => post ["[strongKeyDoesNotExist, "L, data];      simpleKeyDoesNotExist => post ["[simpleKeyDoesNotExist, "L, data];      badKey => post ["[badKey, "L, data];      accessRightsInsufficient => post ["[accessRightsInsufficient, "L, data];      strongKeyAlreadyRegistered => post ["[strongKeyAlreadyRegistered, "L, data];      simpleKeyAlreadyRegistered => post ["[simpleKeyAlreadyRegistered, "L, data];      domainForNewKeyUnavailable => post ["[domainForNewKeyUnavailable, "L, data];      domainForNewKeyUnknown => post ["[domainForNewKeyUnknown, "L, data];      badNameForNewKey => post ["[badNameForNewKey, "L, data];      databaseFull => post ["[databaseFull, "L, data];      other => post ["[other, "L, data];      ENDCASE => {post ["[???("L, data];        Format.Number [post, reason, Format.DecimalFormat];	post ["), "L, data];	};    SELECT whichArg FROM      notApplicable => post ["]"L, data];      initiator => post ["initiator]"L, data];      recipient => post ["recipient]"L, data];      ENDCASE => {post ["???("L, data];        Format.Number [post, whichArg, Format.DecimalFormat, data];	post [")]"L, data];	};    END;  PostAuthenticationError: PUBLIC PROCEDURE [    reason: Auth.AuthenticationProblem,     post: Format.StringProc, data: LONG POINTER ¬ NIL] =    BEGIN    SELECT reason FROM      credentialsInvalid => post ["[credentialsInvalid, "L, data];      verifierInvalid=> post ["[verifierInvalid, "L, data];      verifierExpired => post ["[verifierExpired, "L, data];      verifierReused => post ["[verifierReused, "L, data];      credentialsExpired => post ["[credentialsExpired, "L, data];      inappropriateCredentials => post ["[inappropriateCredentials, "L, data];      ENDCASE => {post ["[???("L, data];        Format.Number [post, reason, Format.DecimalFormat];	post ["), "L, data];	};    post ["]"L, data];    END;       END.  
-- Copyright (C) 1981, 1982  by Xerox Corporation. All rights reserved. -- File: TextSourcesA.mesa - last edited by:-- SXW   	9-Jul-81 17:21:02-- Mark		Mar 16, 1981 4:10 PM-- PXK    	 3-Dec-81 22:45:11-- JGS		20-Oct-81 17:13:33-- SXS   	 6-Apr-82 18:30:37-- BGY     	20-Sep-82 16:46:07-- AXD    	22-Sep-82 14:52:07DIRECTORY  Ascii USING [CR, SP, TAB],  DiskSource USING [],  Environment USING [Block, bytesPerWord],  Heap: TYPE USING [systemZone],  Inline USING [HighHalf, LowHalf],  MFile USING [    Access, Acquire, CopyFileHandle, Delete, dontRelease, Error, GetType, Handle,    Rename, SetAccess, SetType],  MStream USING [Create, Error, GetFile, GetLength, SetLength, SetLogReadLength],  Stream USING [    Delete, EndOfStream, GetBlock, Handle, PutBlock, PutChar, SendNow,    SetPosition],  String: TYPE USING [CopyToNewString, Replace],  TextSource USING [    Access, Action, AsciiDoEditAction, AsciiScanText, Class, Error, ErrorCode,    Handle, Position, Procedures, ProceduresObject, State];TextSourcesA: PROGRAM  IMPORTS Heap, Inline, MFile, MStream, Stream, String, TextSource  EXPORTS DiskSource, TextSource =  BEGIN OPEN TextSource;  -- The funny SIGNALs it deals with should be understood by Trinity, and the variable removed.  -- Disk Source data and stuff  Error: PUBLIC SIGNAL [code: TextSource.ErrorCode] = CODE;  DiskSource: TYPE = LONG POINTER TO DiskSourceObject;  DiskSourceObject: TYPE = MACHINE DEPENDENT RECORD [    procs: Procedures ¬ @diskProcs,    name: LONG STRING,    stream: Stream.Handle,    blockPointer: LONG POINTER TO PACKED ARRAY CARDINAL [0..0) OF CHARACTER ¬ NIL,    blockLength: CARDINAL ¬ 0,    eof: Position,    state: State ¬ awake,    access: Access,    ring: BOOLEAN ¬ FALSE,    gapFiller: CARDINAL [0..3777B] ¬ 0,    maxLength: LONG CARDINAL ¬ LAST[LONG CARDINAL]];  diskProcs: ProceduresObject ¬ [    actOn: ActOnDisk, doEditAction: TextSource.AsciiDoEditAction,    getLength: GetDiskLength, readText: ReadDiskText,    replaceText: ReplaceDiskText, scanText: TextSource.AsciiScanText,    setLength: SetDiskLength];  RealPosition: PROCEDURE [p: DiskSource, pos: Position] RETURNS [Position] =    INLINE BEGIN RETURN[IF p.ring THEN pos MOD p.maxLength ELSE pos]; END;  -- Disk Source Create/Info  Create: PUBLIC PROCEDURE [    name: LONG STRING, access: Access, s: Stream.Handle ¬ NIL]    RETURNS [source: Handle] =    BEGIN    AllocWords: PROC [nWords: CARDINAL] RETURNS [LONG POINTER] = INLINE {      Words: TYPE = RECORD [SEQUENCE COMPUTED CARDINAL OF WORD];      RETURN[Heap.systemZone.NEW[Words [nWords]]]};    p: DiskSource;    IF s = NIL THEN      s ¬ NewStream[        name, GetFileAccess[access] ! MFile.Error => ERROR Error[fileNameError]];    p ¬ Heap.systemZone.NEW[      DiskSourceObject ¬ [      name: String.CopyToNewString[name, Heap.systemZone], stream: s,      blockPointer: AllocWords[100], blockLength: Environment.bytesPerWord*100,      eof: MStream.GetLength[s], access: access]];    RETURN[LOOPHOLE[p, Handle]];    END;  IsIt: PUBLIC PROCEDURE [source: Handle] RETURNS [BOOLEAN] = {    RETURN[source # NIL AND source­ = @diskProcs]};  Info: PUBLIC PROCEDURE [source: Handle]    RETURNS [name: LONG STRING, s: Stream.Handle, access: Access] =    BEGIN OPEN ds: LOOPHOLE[source, DiskSource];    IF source # NIL AND ds.procs = @diskProcs THEN      RETURN[ds.name, ds.stream, ds.access]    ELSE RETURN[NIL, NIL, read];    END;  GetFileAccess: PROCEDURE [access: Access] RETURNS [fileAccess: MFile.Access] =    BEGIN OPEN MFile;    RETURN[      fileAccess ¬        SELECT access FROM read => readOnly, append => log, ENDCASE => ERROR];    END;  Rename: PUBLIC PROCEDURE [source: Handle, newName: LONG STRING, access: Access]    RETURNS [Handle] =    BEGIN OPEN ds: LOOPHOLE[source, DiskSource];    fromH, toH: MFile.Handle;    fromH ¬ MStream.GetFile[ds.stream];    MFile.SetAccess[      fromH, rename ! MFile.Error => ERROR TextSource.Error[accessError]];    toH ¬ MFile.Acquire[      name: newName, access: delete, release: MFile.dontRelease !      MFile.Error => IF code = noSuchFile THEN {toH ¬ NIL; CONTINUE}];    IF toH # NIL THEN MFile.Delete[toH];    MFile.Rename[fromH, newName];    MFile.SetAccess[file: fromH, access: GetFileAccess[access]];    IF ds.access # access THEN {      newAccess: MFile.Access = GetFileAccess[access];      fromH ¬ MFile.CopyFileHandle[        file: fromH, release: MFile.dontRelease, access: newAccess];      Stream.Delete[ds.stream];      ds.stream ¬ MStream.Create[file: fromH, release: []];      ds.access ¬ access};    String.Replace[@ds.name, newName, Heap.systemZone];    RETURN[source];    END;  SetMaxDiskLength: PUBLIC PROCEDURE [source: Handle, maxLength: LONG CARDINAL] =    BEGIN OPEN p: LOOPHOLE[source, DiskSource];    IF p.access = append THEN      BEGIN      p.ring ¬ (maxLength # LAST[LONG CARDINAL]);      p.maxLength ¬ maxLength;      END;    END;  -- Disk Source Interface routines   ActOnDisk: PROCEDURE [source: Handle, action: Action] =    BEGIN OPEN ds: LOOPHOLE[source, DiskSource];    SELECT action FROM      destroy =>        BEGIN        Heap.systemZone.FREE[@ds.name];        Heap.systemZone.FREE[@ds.blockPointer];        TruncateDisk[@ds];        Stream.Delete[ds.stream];        Heap.systemZone.FREE[@source];        END;      mark => MarkDisk[@ds];      sleep => SleepDisk[@ds];      truncate => TruncateDisk[@ds];      wakeup => WakeupDisk[@ds];      ENDCASE => ERROR;    END;  GetDiskLength: PROCEDURE [source: Handle] RETURNS [Position] =    BEGIN RETURN[LOOPHOLE[source, DiskSource].eof]; END;  ReadDiskText: PROCEDURE [    source: Handle, position: Position, maxLength: CARDINAL, class: Class]    RETURNS [block: Environment.Block, next: Position] =    BEGIN OPEN p: LOOPHOLE[source, DiskSource];    maxSizeWillAllocate: CARDINAL = 512*2 - 4;  -- temporary fix    realEof, realPos: Position;    byteOffset, charsToRead: CARDINAL;    charsToEnd: LONG CARDINAL;    block ¬ [LOOPHOLE[p.blockPointer], 0, 0];    next ¬ position;    IF p.eof <= position THEN charsToEnd ¬ 0    ELSE      BEGIN      IF p.ring THEN        BEGIN        realPos ¬ RealPosition[@p, position];        SELECT p.eof FROM          <= p.maxLength => realEof ¬ p.eof;  -- have not yet wrapped around          ENDCASE =>  -- use (p.eof MOD) iff it's IN (realPos..p.maxlength]            IF (realEof ¬ RealPosition[@p, p.eof]) <= realPos THEN              realEof ¬ p.maxLength;        END      ELSE {realPos ¬ position; realEof ¬ p.eof};      charsToEnd ¬ realEof - realPos;      END;    IF p.state = asleep THEN WakeupDisk[@p];    byteOffset ¬ Inline.LowHalf[realPos] MOD 2;    charsToRead ¬ MIN[      maxSizeWillAllocate,      IF Inline.HighHalf[charsToEnd] = 0 THEN MIN[      maxLength, Inline.LowHalf[charsToEnd]] ELSE maxLength];    -- We align p.string and p.stream so GetBlock is faster.    IF charsToRead > 0 THEN      BEGIN      Stream.SetPosition[p.stream, realPos - byteOffset];      --   realPos = 0 => byteOffset = 0 and thus there can be no underflow      block ¬ ReadTextLoop[@p, byteOffset, charsToRead, p.stream, class];      next ¬ position + (block.stopIndexPlusOne - block.startIndex);      END;    RETURN[block, next];    END;  ReadTextLoop: PROCEDURE [    p: DiskSource, offset, charsToRead: CARDINAL, stream: Stream.Handle,    class: Class] RETURNS [block: Environment.Block] =    -- caller should guarantee that charsToRead IN (0.."reasonable value around 512"]    BEGIN    streamExhausted: BOOLEAN ¬ FALSE;    blockSize: CARDINAL ¬ MIN[p.blockLength, charsToRead + offset];    bytesTransferred: CARDINAL ¬ 0;    block ¬ [LOOPHOLE[p.blockPointer], offset, blockSize];    bytesTransferred ¬ Stream.GetBlock[      stream, [block.blockPointer, 0, blockSize] !      Stream.EndOfStream => {streamExhausted ¬ TRUE; RESUME }].bytesTransferred;    block.stopIndexPlusOne ¬ bytesTransferred;    IF class # none THEN      BEGIN      FOR i: CARDINAL IN [block.startIndex..block.stopIndexPlusOne) DO        IF InlineTestNotNoneClass[LOOPHOLE[block.blockPointer[i]], class] THEN {          block.stopIndexPlusOne ¬ i + 1; GOTO Quit};        ENDLOOP;      END;    EXITS Quit => NULL;    END;  ReplaceDiskText: PROCEDURE [    source: Handle, block: Environment.Block, from, to: Position,    deleteToTrashbin: BOOLEAN] RETURNS [new: Position, delta: LONG INTEGER] =    -- DO NOT DO RAW OPEN SOURCE BECAUSE OF SCOPE ss PROBLEM    BEGIN OPEN p: LOOPHOLE[source, DiskSource];    leftToGo: LONG CARDINAL;    blockLength, blockOffset, min: CARDINAL;    realPosition: Position = RealPosition[@p, from];    IF p.state = asleep THEN WakeupDisk[@p];    IF to = p.eof THEN p.eof ¬ from ELSE ERROR Error[accessError];    Stream.SetPosition[p.stream, realPosition];    leftToGo ¬ p.maxLength - realPosition;    blockLength ¬ block.stopIndexPlusOne - block.startIndex;  -- do not consume block    blockOffset ¬ block.startIndex;    WHILE blockLength > 0 DO      IF leftToGo = 0 THEN        BEGIN Stream.SetPosition[p.stream, 0]; leftToGo ¬ p.maxLength; END;      min ¬        IF leftToGo < blockLength THEN Inline.LowHalf[leftToGo] ELSE blockLength;      Stream.PutBlock[        p.stream, [block.blockPointer, blockOffset, blockOffset + min], FALSE];      blockLength ¬ blockLength - min;      blockOffset ¬ blockOffset + min;      leftToGo ¬ leftToGo - min;      ENDLOOP;    p.eof ¬ p.eof + block.stopIndexPlusOne - block.startIndex;    RETURN[p.eof, block.stopIndexPlusOne - block.startIndex + (to - from)];    END;  SetDiskLength: PUBLIC PROCEDURE [source: Handle, position: Position]    RETURNS [Position] =    BEGIN    ds: DiskSource = LOOPHOLE[source, DiskSource];    SELECT TRUE FROM      ds.access = append AND position < ds.eof => {        [] ¬ MStream.SetLogReadLength[ds.stream, position];        ds.stream.setPosition[ds.stream, position]};      ds.access # read => MStream.SetLength[ds.stream, position];      ENDCASE => ERROR TextSource.Error[accessError];    RETURN[ds.eof ¬ position];    END;  -- Text Character Class routines  InlineTestNotNoneClass: PROCEDURE [char: CHARACTER, class: Class]    RETURNS [BOOLEAN] = INLINE    BEGIN    RETURN[      SELECT char FROM        'a, 'b, 'c, 'd, 'e, 'f, 'g, 'h, 'i, 'j, 'k, 'l, 'm, 'n, 'o, 'p, 'q, 'r,          's, 't, 'u, 'v, 'w, 'x, 'y, 'z, 'A, 'B, 'C, 'D, 'E, 'F, 'G, 'H, 'I, 'J,          'K, 'L, 'M, 'N, 'O, 'P, 'Q, 'R, 'S, 'T, 'U, 'V, 'W, 'X, 'Y, 'Z, '0, '1,          '2, '3, '4, '5, '6, '7, '8, '9 => class = alpha,        Ascii.TAB, Ascii.SP => class = space,        Ascii.CR => class = eol OR class = space,        ENDCASE => class = other]    END;  AsciiTestClass: PUBLIC PROCEDURE [char: CHARACTER, class: Class]    RETURNS [BOOLEAN] =    BEGIN    RETURN[IF class = none THEN FALSE ELSE InlineTestNotNoneClass[char, class]]    END;  -- Stream Open/Close/Cleanup Routines  MarkDisk: PROCEDURE [source: DiskSource] =    BEGIN OPEN source;    IF FALSE AND access = append THEN      BEGIN      modEof: Position = RealPosition[source, eof];      Stream.SetPosition[stream, modEof];      Stream.PutChar[stream, Ascii.CR];      THROUGH [0..10) DO Stream.PutChar[stream, '~]; ENDLOOP;      Stream.PutChar[stream, Ascii.CR];      END;    END;  SleepDisk: PROCEDURE [source: DiskSource] =    BEGIN    IF source.state = awake THEN {      IF source.access = append THEN        Stream.SendNow[source.stream ! MStream.Error => CONTINUE];      source.state ¬ asleep}    END;  TruncateDisk: PROCEDURE [source: DiskSource] =    BEGIN    IF source.access = append OR source.access = read THEN RETURN;    -- modEof: Position = RealPosition[source, eof];    -- Cases to consider:    --   eof = modEof = 12K, maxLength = INFINITY, oldSize = 80K    --   eof = modEof = 12K, maxLength = 20K, oldSize = 80K    --   eof = 32K, modEof = 12K, maxLength = 20K, oldSize = 80K    IF source.eof < source.maxLength THEN      MStream.SetLength[source.stream, source.eof]    ELSE {MarkDisk[source]; MStream.SetLength[source.stream, source.maxLength]};    END;  WakeupDisk: PROC [source: DiskSource] = {source.state ¬ awake; };  NewStream: PROC [name: LONG STRING, access: MFile.Access]    RETURNS [Stream.Handle] = INLINE {    file: MFile.Handle = MFile.Acquire[name, access, MFile.dontRelease];    IF MFile.GetType[file] = unknown THEN MFile.SetType[file, text];    RETURN[MStream.Create[file: file, release: []]]};  END. -- of TextSourcesA
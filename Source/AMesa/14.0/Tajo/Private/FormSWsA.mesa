-- Copyright (C) 1980, 1981, 1982, 1983  by Xerox Corporation. All rights reserved. -- File: FormSWsA.mesa - last edited:-- SXW   	10-Jul-81 11:28:25-- Mark		11-Dec-80 14:40:43-- JGS		 2-Sep-81  8:17:36-- BXM  	19-Nov-81 12:21:58-- SXS   	14-Jan-82 11:04:39-- BGY     	18-Oct-83 18:32:26-- PXK    	12-Nov-82 20:53:38-- CXH   	14-Nov-82 21:07:03-- AXD    	 4-Nov-83 13:10:37-- creation, destruction, and wholesale redisplay routinesDIRECTORY  AsciiSink: TYPE USING [Create],  Caret: TYPE USING [ResetOnMatch],  Context: TYPE USING [Create, Destroy, Type, UniqueType],  Display: TYPE USING [White],  Environment: TYPE USING [Block],  FormSW: TYPE USING [    AllocateItemDescriptor, ClientItemsProcType, defaultBoxWidth,    EnumeratedDescriptor, EnumeratedHandle, ErrorCode, Flag,    IndexFromEnumeratedValue, ItemDescriptor, ItemHandle,     ItemErrorCode,LineHeight, newLine, nextLine, nextPlace, nullIndex, Options,    ProcType, ReadOnlyProcType, sameLine, Type],  FormSWOps: TYPE USING [    AdjustItemPlaces, ActivateCaret, ClearTrackData,    ClearCachedInfo, CreateSource, dijectMargin, DijectSelection,    DisplayProc, FindContext, FixX, InterpInput, ItemHandle,     InvertItem, LockContextProcType, PContext,    PContextObject, PositiveY, RealActOnCaret,     ReplaceLongNumberString, ReplaceNumberString, TagLength,    TypeInProc, ScrollVertical, VerticalScrollbar],  Heap: TYPE USING [systemZone],  Scrollbar: TYPE USING [Create, Destroy],  Selection: TYPE USING [ClearOnMatch, SetInsertion],  String: TYPE USING [FreeString, MakeString, SubString, SubStringDescriptor,    WordsForString],  TextData: TYPE USING [Selection, SelectionObject],  TextDisplay: TYPE USING [    Bold, Create, Destroy, Display, Handle, MarkSelection,     noPlace, Object, RequestNewBoxHeight],  TextSink: TYPE USING [ActOn, Measure],  TextSource: TYPE USING [ActOn, Position, ReadText],  TIP: TYPE USING [CreateClient, globalTable, SetNotifyProc, SetTable],  ToolFont: TYPE USING [StringWidth],  ToolWindow: TYPE USING [AdjustProcType, DrawRectangle, State],  UserInput: TYPE USING [CreateStringInOut, DestroyStringInOut],  Window: TYPE USING [    Box, GetBox, Handle, InvalidateBox, Place,     SetClearingRequired, SetDisplayProc, Validate],  WindowFont: TYPE USING [CharWidth, FontHeight];FormSWsA: MONITOR LOCKS myContext.lock USING myContext: FormSWOps.PContext  IMPORTS    AsciiSink, Caret, Context, DisplayDefs: Display, FormSW, FormSWOps, Heap,    Scrollbar, Selection, String, TextDisplay, TextSink, TextSource,    TIP, ToolFont, ToolWindow, UserInput, Window, WindowFont  EXPORTS FormSW, FormSWOps =  BEGIN  context: PUBLIC Context.Type ¬ Context.UniqueType[];  fontHeight: PUBLIC INTEGER ¬ WindowFont.FontHeight[];  -- Global Data and STUFF  Error: PUBLIC SIGNAL [code: FormSW.ErrorCode] = CODE;  ItemError: PUBLIC SIGNAL [code: FormSW.ItemErrorCode, index: CARDINAL] = CODE;  -- Procedures Implementing the FormSW Interface  Adjust: PUBLIC ToolWindow.AdjustProcType = {    myContext: FormSWOps.PContext = FormSWOps.FindContext[window];    LockedAdjust: ENTRY FormSWOps.LockContextProcType = {      ENABLE UNWIND => NULL;      widthChanged: BOOLEAN = (myContext.width # box.dims.w);      FormSWOps.RealActOnCaret[myContext, clear];      IF myContext.insertion.index # FormSW.nullIndex THEN        myContext.insertion.textInsert.place ¬ TextDisplay.noPlace;      IF widthChanged THEN {        myContext.validState ¬ FALSE;        window.InvalidateBox[[[0,0], window.GetBox.dims]]}};    IF myContext # NIL THEN {      IF when = before THEN myContext.width ¬ window.GetBox.dims.w      ELSE LockedAdjust[myContext]}};  Create: PUBLIC PROC [    sw: Window.Handle, clientItemsProc: FormSW.ClientItemsProcType,    readOnlyNotifyProc: FormSW.ReadOnlyProcType, options: FormSW.Options,    initialState: ToolWindow.State, zone: UNCOUNTED ZONE] = {    myContext: FormSWOps.PContext;    items: FormSW.ItemDescriptor;    flushItemDesc: BOOLEAN;    IF sw = NIL THEN RETURN;    IF zone = NIL THEN zone ¬ Heap.systemZone; -- till interface can be changed    IF FormSWOps.FindContext[sw] # NIL THEN SIGNAL Error[alreadyAFormSW];    [items, flushItemDesc] ¬ clientItemsProc[sw];    IF items.BASE = NIL OR items.LENGTH = 0 THEN RETURN;    ValidateItems[sw, options.type, items];    -- Allocate and initialize context    myContext ¬ zone.NEW[FormSWOps.PContextObject];    myContext.sw ¬ sw;    myContext.originPlace ¬ [0, 0];    myContext.readOnlyNotifyProc ¬ readOnlyNotifyProc;    myContext.clientItems ¬ clientItemsProc;    myContext.options ¬ options;    myContext.swState ¬ tiny;    myContext.modifyNotify ¬ NIL;    myContext.buffer ¬ String.MakeString[zone, 100];    myContext.selection ¬ [FormSW.nullIndex, [0, 0, text, video, FALSE]];    myContext.insertion ¬ [      FormSW.nullIndex, [0, TextDisplay.noPlace, triangle, FALSE]];    myContext.dijects ¬ NIL;    myContext.zone ¬ zone;    CopyClientItems[myContext, items];    IF flushItemDesc THEN FreeNode[myContext.zone, items.BASE];    Context.Create[context, myContext, DestroyContext, sw];    -- Set up display bits stuff    [] ¬ sw.SetDisplayProc[FormSWOps.DisplayProc];    [] ¬ sw.SetClearingRequired[FALSE];    IF initialState = active THEN Wakeup[sw];  -- context must exist    IF myContext.options.scrollVertical THEN      Scrollbar.Create[	sw, vertical, FormSWOps.ScrollVertical, FormSWOps.VerticalScrollbar];    UserInput.CreateStringInOut[      sw, FormSWOps.TypeInProc, FormSWOps.TypeInProc, FormSWOps.ActivateCaret];    TIP.CreateClient[window: sw, table: TIP.globalTable[formSW],      notify: FormSWOps.InterpInput]};  Destroy: PUBLIC PROC [sw: Window.Handle] = {    myContext: FormSWOps.PContext = FormSWOps.FindContext[sw];    IF myContext = NIL THEN ERROR Error[notAFormSW];    -- Return to default PNRs state    UserInput.DestroyStringInOut[sw];    [] ¬ TIP.SetNotifyProc[sw, NIL];    [] ¬ TIP.SetTable[sw, TIP.globalTable[root]];    DestroyScrollbars[myContext];    Context.Destroy[context, sw]};  Display: PUBLIC PROC [sw: Window.Handle, yOffset: CARDINAL ¬ 0] = {    << All items are painted, even if they do not lie within the subwindow    boundaries.  Thus, all diject boxes are correct when this routine finishes,    except for string items which may have incorrect dims.    The originPlace is not added into lastX because it could be negative, which    would change lastX's interpretation. >>    myContext: FormSWOps.PContext;    LockedDisplay: ENTRY FormSWOps.LockContextProcType = {      ENABLE UNWIND => NULL;      lastVisibleItem: CARDINAL ¬ FormSW.nullIndex;      maxHSameLine, lastX: INTEGER;      FormSWOps.RealActOnCaret[myContext, clear];      DisplayDefs.White[sw, [[0, 0], sw.GetBox.dims]];      myContext.insertion.textInsert.place ¬ TextDisplay.noPlace;      myContext.originPlace.y ¬ -yOffset;      IF myContext.dijects # NIL THEN {        InitDijectBoxes[myContext];        FOR i: CARDINAL IN [0..myContext.items.LENGTH) DO          IF myContext.items[i].flags.invisible THEN LOOP;          [lastX, maxHSameLine] ¬ DisplayNextItem[            myContext, i, lastVisibleItem, lastX, maxHSameLine];          lastVisibleItem ¬ i;          ENDLOOP};      myContext.validState ¬ TRUE};    IF (myContext ¬ FormSWOps.FindContext[sw]) = NIL THEN      DisplayDefs.White[sw, [[0, 0], sw.GetBox.dims]]    ELSE LockedDisplay[myContext]};  IsIt: PUBLIC PROC [sw: Window.Handle] RETURNS [yes: BOOLEAN] = {    RETURN[FormSWOps.FindContext[sw] # NIL]};  SetOptions: PUBLIC PROC [sw: Window.Handle, options: FormSW.Options] = {      myContext: FormSWOps.PContext = FormSWOps.FindContext[sw];    LockedChangeOptions: ENTRY FormSWOps.LockContextProcType = {      myContext.options ¬ options};    IF myContext # NIL THEN {      Sleep[sw];      IF myContext.options.scrollVertical AND ~options.scrollVertical THEN        DestroyScrollbars[myContext];      IF ~myContext.options.scrollVertical AND options.scrollVertical THEN        Scrollbar.Create[          sw, vertical, FormSWOps.ScrollVertical, FormSWOps.VerticalScrollbar];      LockedChangeOptions[myContext];      sw.InvalidateBox[[[0, 0], sw.GetBox.dims]];      Wakeup[sw];      sw.Validate}};  SetModifyNotificationProc: PUBLIC PROC [    sw: Window.Handle, proc: FormSW.ProcType] = {    myContext: FormSWOps.PContext = FormSWOps.FindContext[sw];    IF myContext # NIL THEN myContext.modifyNotify ¬ proc};  SetTagPlaces: PUBLIC PROC [    items: FormSW.ItemDescriptor, tabStops: LONG DESCRIPTOR FOR ARRAY OF CARDINAL,    bitTabs: BOOLEAN] = {    spaceSize: CARDINAL = IF bitTabs THEN 1 ELSE WindowFont.CharWidth['0];    lastTab: CARDINAL ¬ 0;    FOR i: CARDINAL IN [0..items.LENGTH) DO      IF items[i].flags.invisible THEN LOOP;      SELECT items[i].place FROM        FormSW.newLine => lastTab ¬ 0;        FormSW.nextPlace => lastTab ¬ lastTab + 1;        ENDCASE =>          IF items[i].place.x < 0 THEN LOOP ELSE lastTab ¬ items[i].place.x;      items[i].place.x ¬ tabStops[lastTab]*spaceSize;      ENDLOOP};  Sleep: PUBLIC PROC [sw: Window.Handle] = {    myContext: FormSWOps.PContext;    IF (myContext ¬ FormSWOps.FindContext[sw]) # NIL THEN {RealSleep[myContext]}};  ToggleFlag: PUBLIC PROC [    sw: Window.Handle, index: CARDINAL, flag: FormSW.Flag] = {    myContext: FormSWOps.PContext;    IF (myContext ¬ FormSWOps.FindContext[sw]) = NIL      OR index >= myContext.items.LENGTH THEN RETURN;    SELECT flag FROM      clientOwnsItem, drawBox, hasContext => NULL;      readOnly => {        OPEN miif: myContext.items[index].flags; miif.readOnly ¬ ~miif.readOnly};      modified => {        OPEN miif: myContext.items[index].flags; miif.modified ¬ ~miif.modified};      invisible => {        OPEN	  miif: myContext.items[index].flags,          mdib: myContext.dijects[index].box;	IF myContext.swState = tiny THEN {	  miif.invisible ¬ ~miif.invisible;	  RETURN};        IF (miif.invisible ¬ ~miif.invisible) THEN {          lineHeight: INTEGER = FormSW.LineHeight[sw];          IF myContext.selection.index = index THEN {            myContext.selection.index ¬ FormSW.nullIndex;            myContext.selection.textSelect.marked ¬ FALSE};          IF myContext.insertion.index = index THEN {            FormSWOps.RealActOnCaret[myContext, clear];            myContext.insertion.index ¬ FormSW.nullIndex};          IF mdib.dims.h = lineHeight THEN {            next: FormSW.ItemHandle;            nextOnSameLine: BOOLEAN;            [next: next, nextOnSameLine: nextOnSameLine] ¬ FindNextVisible[              myContext, index, mdib.place.y];            IF ~nextOnSameLine OR next.place.x >= 0 THEN {              DisplayDefs.White[sw, mdib]; GOTO SkipFullDisplay}}};        Display[sw, myContext.originPlace.y];        EXITS SkipFullDisplay => NULL};      ENDCASE};  ToggleVisibility: PUBLIC PROC [sw: Window.Handle, index: CARDINAL] = {    ToggleFlag[sw, index, invisible]};  Wakeup: PUBLIC PROC [sw: Window.Handle] = {    -- Recreates all state related ONLY to the displayed bits.    myContext: FormSWOps.PContext;    -- may be non-identity change of representation in the future    LockedWakeup: ENTRY FormSWOps.LockContextProcType = {      ENABLE UNWIND => NULL;      wordsForDijects: CARDINAL = myContext.items.LENGTH*TextDisplay.Object.SIZE;      ssBaseLength: CARDINAL = 100;      block: LONG POINTER;      ss: String.SubString;      ssBase: LONG STRING;      myContext.swState ¬ active;      IF myContext.dijects # NIL THEN RETURN;      -- Space is allocated for every item's diject, even invisible ones!      block ¬ MakeNode[        myContext.zone, wordsForDijects + String.SubStringDescriptor.SIZE +          String.WordsForString[ssBaseLength]];      myContext.dijects ¬ block;      ss ¬ block + wordsForDijects;      ssBase ¬ block + wordsForDijects + String.SubStringDescriptor.SIZE;      ssBase­ ¬ StringBody[length: 0, maxlength: ssBaseLength, text:];      ss­ ¬ [base: ssBase, offset: 0, length: 0];      FOR i: CARDINAL IN [0..myContext.items.LENGTH) DO        item: FormSWOps.ItemHandle = myContext.items[i];  -- change representation        [] ¬ TextDisplay.Create[          wh: sw, source: FormSWOps.CreateSource[item, myContext],          sink: AsciiSink.Create[NIL], storage: @myContext.dijects[i]];        -- note box is uninitialized         myContext.dijects[i].options ¬ [          rightBreak: word, bottomAction: signal, margin: FormSWOps.dijectMargin];        ENDLOOP;      myContext.validState ¬ FALSE};    IF (myContext ¬ FormSWOps.FindContext[sw]) = NIL THEN RETURN;    LockedWakeup[myContext]};  -- Utilities  CheckItemOrder: PUBLIC PROC [items: FormSW.ItemDescriptor] = {    -- Should not be called if Type # fixed    lookingForVisibleItem: BOOLEAN ¬ TRUE;    lastPlace: Window.Place;    FOR i: CARDINAL IN [0..items.LENGTH) DO      IF items[i].flags.invisible THEN LOOP;      IF lookingForVisibleItem THEN {        lookingForVisibleItem ¬ FALSE;        lastPlace ¬ items[i].place;        IF lastPlace.x < 0 OR lastPlace.y = FormSW.sameLine THEN          ERROR ItemError[illegalCoordinate, i]}      ELSE {        -- newPlace is not what the place will be after a Display, but        --   relative orderings will be correct.        newPlace: Window.Place ¬ [          x: FormSWOps.FixX[lastPlace.x, 0, items[i].place.x],          y: FormSWOps.PositiveY[          lastPlace.y, items[i].place.y, FormSW.LineHeight[]]];        SELECT newPlace.y - lastPlace.y FROM          < 0 => ERROR ItemError[illegalCoordinate, i];          = 0 =>            IF newPlace.x < lastPlace.x THEN              ERROR ItemError[illegalCoordinate, i];          ENDCASE;        lastPlace ¬ newPlace};      ENDLOOP};  CopyClientItems: PUBLIC PROC [    myContext: FormSWOps.PContext, items: FormSW.ItemDescriptor] = {    itemsLength: CARDINAL = items.LENGTH;    myContext.items ¬ FormSW.AllocateItemDescriptor[itemsLength, myContext.zone];    FOR i: CARDINAL IN [0..itemsLength) DO myContext.items[i] ¬ items[i] ENDLOOP};  DestroyContext: PROC [myContext: FormSWOps.PContext, sw: Window.Handle] = {    z: UNCOUNTED ZONE  ¬ myContext.zone;    IF myContext = NIL THEN RETURN;    FormSWOps.ClearTrackData[myContext];    Selection.ClearOnMatch[myContext];    Selection.SetInsertion[NIL, NIL, NIL];  -- even if I don't have it !!!    RealSleep[myContext];    String.FreeString[z, myContext.buffer];    FreeNode[z, myContext.items.BASE];    z.FREE[@myContext]};  DetermineBoxWidth: PROC [    myContext: FormSWOps.PContext, i: CARDINAL, width: CARDINAL]    RETURNS [boxWidth: CARDINAL] = {    minW: INTEGER = WindowFont.CharWidth['W]*4;    maxW: INTEGER = 10000;    dijectI: TextDisplay.Handle = @myContext.dijects[i];    IF width # FormSW.defaultBoxWidth THEN      boxWidth ¬ TagBitLength[dijectI] + width    ELSE {      rightEdge: INTEGER ¬ myContext.sw.GetBox.dims.w - myContext.originPlace.x;      FOR j: CARDINAL IN (i..myContext.items.LENGTH) DO        IF myContext.dijects[j].box.place.y # dijectI.box.place.y THEN EXIT;        IF ~myContext.items[j].flags.invisible THEN {          rightEdge ¬ myContext.dijects[j].box.place.x; EXIT};        ENDLOOP;      boxWidth ¬        (IF rightEdge > dijectI.box.place.x THEN rightEdge - dijectI.box.place.x         ELSE 0)};    IF boxWidth < CARDINAL[minW] THEN boxWidth ¬ maxW};  DisplayNextItem: PROC [    myContext: FormSWOps.PContext, i, lastVisibleItem: CARDINAL,    lastX, maxHSameLine: INTEGER] RETURNS [thisX, newMaxH: INTEGER] = {    -- Do not call if the diject has already been displayed without    --   subtracting the originPlace.    -- The relative offsets specified by the client's items are    --   preserved between the diject boxes.    -- InitDijectBoxes allows item order testing to be ignored.    OPEN mdib: myContext.dijects[i].box;    maxW: INTEGER = 10000;    lastW: INTEGER;    alterH, alterW: BOOLEAN;    select: TextData.Selection ¬ NIL;    dummySelect: TextData.SelectionObject;    FormSWOps.ClearCachedInfo[myContext.dijects[i].source];    IF lastVisibleItem = FormSW.nullIndex THEN {      lastX ¬ 0; maxHSameLine ¬ FormSW.LineHeight[]}    ELSE {      lastW ¬ myContext.dijects[lastVisibleItem].box.dims.w;      IF myContext.dijects[lastVisibleItem].box.place.y < mdib.place.y THEN        maxHSameLine ¬ FormSW.LineHeight[]};    mdib.place.x ¬ thisX ¬ FormSWOps.FixX[lastX, lastW, mdib.place.x];    newMaxH ¬ maxHSameLine;    WITH item: myContext.items[i] SELECT FROM      longNumber => {        FormSWOps.ReplaceLongNumberString[          item.string, item.signed, item.notNegative,	  item.radix, item.value­ -item.bias];        alterH ¬ TRUE;        alterW ¬ FALSE;        mdib.dims.w ¬ DetermineBoxWidth[myContext, i, item.boxWidth]};      number => {        FormSWOps.ReplaceNumberString[	  item.string, item.signed, item.notNegative,	  item.radix, item.value­ - item.bias];        alterH ¬ TRUE;        alterW ¬ FALSE;        mdib.dims.w ¬ DetermineBoxWidth[myContext, i, item.boxWidth]};      string => {        mdib.dims.w ¬ DetermineBoxWidth[myContext, i, item.boxWidth];        -- Temporarily, we will paint (or measure) everything the first time.        -- alterH ¬ (mdib.place.y IN [-fontHeight..sw.box.dims.h]);        IF mdib.place.y < myContext.sw.GetBox.dims.h THEN          mdib.dims.h ¬ myContext.sw.GetBox.dims.h - mdib.place.y;        alterH ¬ TRUE;        -- End temporary (we hope) code        alterW ¬ FALSE};      ENDCASE => {mdib.dims.w ¬ maxW; alterH ¬ alterW ¬ TRUE};    -- Adjustment of x to screen must be after DetermineBoxWidth call    mdib.place.x ¬ mdib.place.x + myContext.originPlace.x;    -- string items outside the subwindow may try to overflow    IF ~alterH THEN myContext.dijects[i].options.bottomAction ¬ none;    WITH item: myContext.items[i] SELECT FROM      boolean => select ¬ NIL;      ENDCASE => select ¬ FormSWOps.DijectSelection[myContext, i, @dummySelect];    TextDisplay.Display[      @myContext.dijects[i], select, alterW, alterH !      TextDisplay.RequestNewBoxHeight =>  -- should not happen        RESUME [mdib.dims.h]];    IF myContext.options.boldTags THEN      TextDisplay.Bold[        @myContext.dijects[i], 0, FormSWOps.TagLength[	myContext.dijects[i].source,TRUE], select];    IF select # NIL THEN       TextDisplay.MarkSelection[@myContext.dijects[i], select, mark];    IF ~alterH THEN myContext.dijects[i].options.bottomAction ¬ signal;    -- Ignore shrinking h (should not be possible)    IF maxHSameLine < mdib.dims.h THEN {      newMaxH ¬ mdib.dims.h;      FormSWOps.AdjustItemPlaces[myContext, i, newMaxH - maxHSameLine]};    WITH item: myContext.items[i] SELECT FROM      boolean => IF item.switch­ THEN FormSWOps.InvertItem[myContext, i];      enumerated =>        IF item.feedback = one THEN {          next: FormSW.ItemHandle;          nextOnSameLine: BOOLEAN;          [next: next, nextOnSameLine: nextOnSameLine] ¬ FindNextVisible[            myContext, i, mdib.place.y];          mdib.dims.w ¬ FixupEnumOneWidth[            @item, mdib.place.x - myContext.originPlace.x, 	    myContext.sw.GetBox.place.x + myContext.sw.GetBox.dims.w,            next, nextOnSameLine, mdib.dims.w]};      ENDCASE;    IF myContext.items[i].flags.drawBox THEN       ToolWindow.DrawRectangle[myContext.sw, mdib, 1]};  FindNextVisible: PROC [myContext: FormSWOps.PContext, i: CARDINAL, iY: INTEGER]    RETURNS [      next: FormSW.ItemHandle ¬ NIL, nextI: CARDINAL, nextY: INTEGER,      nextOnSameLine: BOOLEAN] = {    FOR nextI ¬ i + 1, nextI + 1 WHILE nextI < myContext.items.LENGTH DO      IF ~myContext.items[nextI].flags.invisible THEN {        next ¬ myContext.items[nextI];        nextY ¬ myContext.dijects[nextI].box.place.y;        EXIT};      ENDLOOP;    nextOnSameLine ¬ (next # NIL) AND (nextY = iY)};  FixupEnumOneWidth: PROC [    enum: FormSW.EnumeratedHandle, enumX, rightX: INTEGER,    next: FormSW.ItemHandle, nextOnSameLine: BOOLEAN, width: INTEGER]    RETURNS [newW: INTEGER] = {    currentIndex: CARDINAL = FormSW.IndexFromEnumeratedValue[enum];    limitingX: INTEGER = IF nextOnSameLine THEN next.place.x ELSE rightX;    IF currentIndex # FormSW.nullIndex THEN      width ¬ width - ToolFont.StringWidth[enum.choices[currentIndex].string];    newW ¬ width + MaxChoiceWidth[enum.choices];    IF limitingX >= 0 THEN newW ¬ MAX[newW, MIN[limitingX, rightX] - enumX]};  InitDijectBoxes: PUBLIC PROC [myContext: FormSWOps.PContext] = {    -- Assumes CheckItemOrder[] for fixed items.    -- The diject boxes will be set up for items one line high. The x's    --   are not forced positive because the w's may change after the    --   item is displayed.  For the same reason, the w's are not set.    --   This also means that originPlace.x is NOT added into the x.    --   Note that if the h's change, the y's must be changed.    lineHeight: CARDINAL = FormSW.LineHeight[];    clientPlace: Window.Place;    formerY, newY: INTEGER;    IF myContext = NIL THEN RETURN;    formerY ¬ FormSW.nextLine;    FOR i: CARDINAL IN [0..myContext.items.LENGTH) DO      IF myContext.items[i].flags.invisible THEN LOOP;      clientPlace ¬        (IF myContext.options.type = relative THEN FormSW.newLine         ELSE clientPlace ¬ myContext.items[i].place);      newY ¬ FormSWOps.PositiveY[formerY, clientPlace.y, lineHeight];      myContext.dijects[i].box ¬ [        [x: clientPlace.x, y: newY + myContext.originPlace.y], 	[w: 0, h: lineHeight]];      formerY ¬ newY;      ENDLOOP};  MaxChoiceWidth: PROC [choices: FormSW.EnumeratedDescriptor]    RETURNS [width: CARDINAL ¬ 0] = {    FOR i: CARDINAL IN [0..choices.LENGTH) DO      width ¬ MAX[width, ToolFont.StringWidth[choices[i].string]]; ENDLOOP};  RealSleep: PROC [myContext: FormSWOps.PContext] = {    -- Tosses away all state related ONLY to the displayed bits.    -- Do not call with myContext = NIL!    LockedSleep: ENTRY FormSWOps.LockContextProcType = {      ENABLE UNWIND => NULL;      IF myContext.swState # active THEN RETURN;      FOR i: CARDINAL IN [0..myContext.items.LENGTH) DO        [] ¬ myContext.dijects[i].source.ActOn[destroy];        [] ¬ myContext.dijects[i].sink.ActOn[destroy];        [] ¬ TextDisplay.Destroy[@myContext.dijects[i]];        ENDLOOP;      myContext.zone.FREE[@myContext.dijects];      myContext.dijects ¬ NIL;      myContext.selection.textSelect.marked ¬ FALSE;      myContext.swState ¬ tiny};    Caret.ResetOnMatch[myContext];    LockedSleep[myContext]};  DestroyScrollbars: ENTRY FormSWOps.LockContextProcType = {    -- Do not call with myContext = NIL!    ENABLE UNWIND => NULL;    IF myContext.options.scrollVertical THEN      Scrollbar.Destroy[myContext.sw, vertical]};  TagBitLength: PUBLIC PROC [diject: TextDisplay.Handle] RETURNS [x: CARDINAL] = {    block: Environment.Block;    tagLength: CARDINAL = FormSWOps.TagLength[diject.source];    block ¬ diject.source.ReadText[0, tagLength, none].block;    x ¬ diject.sink.Measure[@block, 1000, 0, [0, 0]].newPlace.x;    RETURN[x]};  ValidateItems: PROC [    sw: Window.Handle, swType: FormSW.Type, items: FormSW.ItemDescriptor] = {    -- Scan pass for defaultBoxWidth, client backing store, item order,    --   and tagOnly validity before allocation    IF swType = fixed THEN CheckItemOrder[items];    FOR i: CARDINAL IN [0..items.LENGTH) DO      WITH item: items[i] SELECT FROM        boolean => IF item.switch = NIL THEN ERROR ItemError[nilBackingStore, i];        enumerated =>          IF item.value = NIL THEN ERROR ItemError[nilBackingStore, i];        longNumber =>          IF item.value = NIL THEN ERROR ItemError[nilBackingStore, i];        number => IF item.value = NIL THEN ERROR ItemError[nilBackingStore, i];        string => {          IF swType = fixed AND item.boxWidth = FormSW.defaultBoxWidth            AND i + 1 < items.LENGTH AND items[i + 1].place.x < 0            AND ~items[i + 1].flags.invisible THEN            ERROR ItemError[illegalCoordinate, i + 1];          IF item.string = NIL THEN ERROR ItemError[nilBackingStore, i]};        tagOnly => {          IF item.otherItem # FormSW.nullIndex            AND items[item.otherItem].type # string THEN            ERROR ItemError[notStringOtherItem, i];          item.sw ¬ sw};  -- don't assume it was setup        ENDCASE;      ENDLOOP};  MakeNode: PROC [z: UNCOUNTED ZONE, n: CARDINAL] RETURNS [LONG POINTER] = {    T: TYPE = RECORD[SEQUENCE COMPUTED CARDINAL OF UNSPECIFIED];    p: LONG POINTER TO T = z.NEW[T[n]];    RETURN[p]};  FreeNode: PROC [z: UNCOUNTED ZONE, lp: LONG POINTER] = {z.FREE[@lp]};  END.
-- Copyright (C) 1981, 1982, 1983  by Xerox Corporation. All rights reserved. -- File: ToolsA.mesa - last edited by:-- SXW    	11-Jul-81 12:07:52-- JGS 		19-Aug-81  7:59:25-- SXE   	Oct 3, 1980 11:56 AM-- Mark 	26-May-81 11:17:49-- SXS    	 9-Feb-82 13:54:15-- LXR     	 9-Nov-82 16:20:57-- BGY      	20-Dec-82 13:06:41-- PXK     	23-Nov-82 17:49:33-- AXD     	 8-Mar-83 16:03:52DIRECTORY  Atom: TYPE USING [ATOM, MakeAtom],  CmFile: TYPE USING [    Close, Error, FindSection, Handle, NextValue, TableError,    UserDotCmOpen],  Context: TYPE USING [Create, Find, Type, UniqueType],  Display: TYPE USING [Invert, White],  Event: TYPE USING [toolWindow],  EventTypes: TYPE USING [activate],  FormSW: TYPE USING [Adjust, FreeAllItems, Sleep, Wakeup],  Heap: TYPE USING[systemZone],  Inline: TYPE USING [LongCOPY],  Profile: TYPE USING [initialToolStateDefault],  Scrollbar: TYPE USING [Adjust, WindowNowDelinked, WindowNowEnlinked],  String: TYPE USING [CopyToNewString, EmptyString, FreeString, Length],  StringLookUp: TYPE USING [noMatch, TableDesc, InTable],  Supervisor: TYPE USING [NotifyDirectSubsystems],  System: TYPE USING [switches],  TajoMisc: TYPE USING [FindClippingWindow],  TextSW: TYPE USING [Adjust, Sleep, Wakeup],  TIP: TYPE USING [First, mouseTIP, NewManager, NotifyProc, Results, Rest],  Token: TYPE USING [Item, WindowBox],  Tool: TYPE USING [    ErrorCode, MakeSWsProc, NopSleepProc, NopWakeupProc,     SimpleAdjustProc, State,    SWProc, SWType, Transition],  ToolOps: TYPE USING [    bdryFudge, bdryHeight, bdryLineWidth, bdryMargin, BoxSequence, ContextHandle,    ContextObject, DefaultAdjustProc, FindType, fileSW, firstFree, formSW, msgSW,    RemoveMenus, stringSW, SWBox, swMargin, SWRecord, SWSequence, textSW, ttySW,    undefined],  ToolWindow: TYPE USING [    AdjustProcType, Box, Create, Deactivate, DelinkSubwindow, Destroy,    EnlinkSubwindow, Handle, SetTinyName, SetTinyPlace, Show, State,    TransitionProcType, Type, When],  UserTerminal: TYPE USING [BlinkDisplay],  Window: TYPE USING [Box, GetBox, GetParent, GetSibling, Handle, InvalidateBox,     Place, SlideAndSize, ValidateTree],  WindowFont: TYPE USING [FontHeight];ToolsA: MONITOR  IMPORTS    Atom, CmFile, Context, Display, Event, FormSW, Heap, Inline, Profile,     Scrollbar, String, StringLookUp, Supervisor, System, TajoMisc, TextSW,    TIP, Token, Tool, ToolOps, ToolWindow, UserTerminal,    Window, WindowFont  EXPORTS Tool, ToolOps =  BEGIN OPEN Tool;  ToolsContext: TYPE = ToolOps.ContextHandle;    -- Global Data  initialized: BOOLEAN ¬ FALSE;  minSWHeight: INTEGER ¬ WindowFont.FontHeight[] + ToolOps.swMargin;  bdryHeight: CARDINAL = ToolOps.bdryHeight;  bdryFudge: CARDINAL = ToolOps.bdryFudge;  bdryMargin: CARDINAL = ToolOps.bdryMargin;    pointDown, pointUp, track: Atom.ATOM;  z:  UNCOUNTED ZONE = Heap.systemZone;    moveSplits: LONG POINTER TO MoveSplits ¬ NIL;  TopBottom: TYPE = {top, bottom};  Range: TYPE = RECORD [top, bottom: INTEGER];  MoveSplits: TYPE = RECORD [   neverMoved: BOOLEAN ¬ TRUE,   i: CARDINAL,   originalY, originalBound, lastY, lastRelativeY: INTEGER,   lastSW: Window.Handle,   limit: ARRAY TopBottom OF INTEGER,   clip: Window.Handle,   range: ARRAY TopBottom OF Range];    SWProcsSequence: TYPE = RECORD [SEQUENCE lastPlusOne: Tool.SWType OF SWProcs];  SWProcs: TYPE = RECORD [    adjust: ToolWindow.AdjustProcType, sleep: Tool.SWProc, wakeup: Tool.SWProc];  swProcsArray: LONG POINTER TO SWProcsSequence ¬ NIL;  -- Interface readonly variables  context: PUBLIC Context.Type ¬ Context.UniqueType[];  nextSWType: PUBLIC Tool.SWType ¬ ToolOps.firstFree;    -- Error  Error: PUBLIC SIGNAL [code: Tool.ErrorCode] = CODE;  -- Tool Public Interface Procedures  Create: PUBLIC PROC [    name: LONG STRING, makeSWsProc: Tool.MakeSWsProc, initialState: Tool.State,    clientTransition: ToolWindow.TransitionProcType, movableBoundaries: BOOLEAN,    initialBox: Window.Box, cmSection, tinyName1, tinyName2: LONG STRING,    named: BOOLEAN]    RETURNS [window: Window.Handle] = {    tch: ToolsContext;    tinyPlace: Window.Place ¬ [-1, -1];    firstState: ToolWindow.State ¬      SELECT initialState FROM        inactive => inactive,        tiny => tiny,        active => active,        ENDCASE => Profile.initialToolStateDefault;    IF ~String.EmptyString[cmSection] AND System.switches['N] = up THEN      [initialBox, tinyPlace, firstState] ¬ UserCmValues[        cmSection, initialBox, tinyPlace, firstState];    window ¬ ToolWindow.Create[      name: name, adjust: ToolOps.DefaultAdjustProc, transition: Tool.Transition,      box: initialBox, limit:, initialState: firstState, named: named];    IF tinyPlace # [-1, -1] THEN      ToolWindow.SetTinyPlace[window: window, place: tinyPlace];    IF tinyName1 # NIL THEN      ToolWindow.SetTinyName[window: window, name: tinyName1, name2: tinyName2];    initialBox ¬ window.GetBox[];    tch ¬ z.NEW[ToolOps.ContextObject ¬ ToolOps.ContextObject[      name: String.CopyToNewString[name, z],       cmSection: String.CopyToNewString[cmSection, z],      makeSWsProc: makeSWsProc, clientTransition: clientTransition,      sws: z.NEW[ToolOps.SWSequence[0]],       boxes: z.NEW[ToolOps.BoxSequence[0]], w: initialBox.dims.w,      oldH: initialBox.dims.h, moveBdry: movableBoundaries,      runningMakeSWsProc: FALSE, named: named]];    Context.Create[context, tch, DestroyContext, window];    IF firstState # inactive THEN {      Tool.Transition[window: window, old: inactive, new: firstState];      -- This is because we don't go through ToolWindow.Activate      -- !! SHOULD GO AWAY !!      Supervisor.NotifyDirectSubsystems[        event: EventTypes.activate, which: clients, subsystem: Event.toolWindow,        eventData: window];      ToolWindow.Show[window]}};  IsIt: PUBLIC PROC [window: Window.Handle] RETURNS [BOOLEAN] = {    RETURN[Context.Find[context, window] # NIL]};  Info: PUBLIC PROC [window: Window.Handle]    RETURNS [      name, cmSection: LONG STRING, makeSWsProc: MakeSWsProc,      clientTransition: ToolWindow.TransitionProcType,      movableBoundaries: BOOLEAN] = {    tch: ToolsContext ¬ Context.Find[context, window];    IF tch # NIL THEN      RETURN[        name: tch.name, cmSection: tch.cmSection,          clientTransition: tch.clientTransition, makeSWsProc: tch.makeSWsProc,          movableBoundaries: tch.moveBdry]    ELSE RETURN[NIL, NIL, NIL, NIL, FALSE]};  Destroy: PUBLIC PROC [window: Window.Handle] = {    tch: ToolsContext ¬ Context.Find[context, window];    toolWindow: Window.Handle;    IF tch # NIL THEN {      [] ¬ ToolWindow.Deactivate[window]; ToolWindow.Destroy[window]; RETURN};    IF ToolWindow.Type[window] = sub      AND (tch ¬ Context.Find[        context, toolWindow ¬ window.GetParent.GetParent]) # NIL      THEN -- why isn't this stuff monitored? (AMD)      FOR i: CARDINAL IN [0..tch.sws.length) DO        IF window = tch.sws[i].sw THEN {	  clip: Window.Handle = TajoMisc.FindClippingWindow[window];	  hTot: INTEGER ¬ 0;	  oldSws: LONG POINTER TO ToolOps.SWSequence;	  oldBoxes: LONG POINTER TO ToolOps.BoxSequence;	  box: Window.Box;	  IF tch.sws[i].type = ToolOps.formSW THEN            FormSW.FreeAllItems[tch.sws[i].sw];          ToolOps.RemoveMenus[tch.sws[i].sw, inSW];          oldSws ¬ tch.sws;	  oldBoxes ¬ tch.boxes;	  tch.sws ¬ z.NEW[ToolOps.SWSequence[oldSws.length - 1]];	  tch.boxes ¬ z.NEW[ToolOps.BoxSequence[oldBoxes.length - 1]];	  IF i # 0 THEN Inline.LongCOPY[	   from: @oldSws[0], to: @tch.sws[0], nwords: i*ToolOps.SWRecord.SIZE];	  IF i # tch.sws.length THEN Inline.LongCOPY[	     from: @oldSws[i + 1], to: @tch.sws[i],	     nwords: (tch.sws.length - i)*ToolOps.SWRecord.SIZE];	  IF i # 0 THEN Inline.LongCOPY[	     from: @oldBoxes[0], to: @tch.boxes[0], nwords: i*ToolOps.SWBox.SIZE];	  IF i # tch.boxes.length THEN Inline.LongCOPY[	     from: @oldBoxes[i + 1], to: @tch.boxes[i],	     nwords: (tch.boxes.length - i)*ToolOps.SWBox.SIZE];          ToolWindow.Destroy[window];          FOR j: CARDINAL IN [0..tch.sws.length) DO            hTot ¬ hTot + tch.boxes[j].h;	    IF j < i THEN LOOP;	    tch.boxes[j].y ¬ tch.boxes[j - 1].y + tch.boxes[j - 1].h + bdryHeight;	    ENDLOOP;	  tch.boxes[tch.sws.length - 1].h ¬ (box ¬ clip.GetBox).dims.h - hTot;	  ToolOps.DefaultAdjustProc[toolWindow, box, before];	  ToolOps.DefaultAdjustProc[toolWindow, box, after];	  z.FREE[@oldSws];	  z.FREE[@oldBoxes];          RETURN};        ENDLOOP;    SIGNAL Error[invalidWindow]};  AdjustProc: PUBLIC ENTRY PROC [type: Tool.SWType]    RETURNS [ToolWindow.AdjustProcType] = {    ENABLE UNWIND => NULL;    RETURN[swProcsArray[type].adjust]};      SleepProc: PUBLIC ENTRY PROC [type: Tool.SWType] RETURNS [Tool.SWProc] = {    ENABLE UNWIND => NULL;    RETURN[swProcsArray[type].sleep]};  WakeupProc: PUBLIC ENTRY PROC [type: Tool.SWType] RETURNS [Tool.SWProc] = {    ENABLE UNWIND => NULL;    RETURN[swProcsArray[type].wakeup]};    TIPMe: PUBLIC TIP.NotifyProc = {    place: Window.Place;    tch: ToolsContext = Context.Find[context, window.GetParent];    IF tch = NIL THEN RETURN;    FOR input: TIP.Results ¬ results, input.Rest UNTIL input = NIL DO      WITH z: input.First SELECT FROM          coords => place ¬ z.place;	  atom => SELECT z.a FROM	    track => Track[tch, place];	    pointUp => PutSplitsDown[tch]; 	    pointDown => StartMoveSplit[window, place, tch];	    ENDCASE;	  ENDCASE;	ENDLOOP};    DetermineMovableBoundary: PROC [y: INTEGER, tch: ToolsContext]    RETURNS [CARDINAL] = {    FOR i: CARDINAL IN [0..tch.sws.length - 1) DO      IF y < tch.boxes[i + 1].y THEN RETURN[i];      ENDLOOP;    ERROR};  -- how did we get into this fix?  InRange: PROC [i: INTEGER, r: Range] RETURNS [BOOLEAN] = INLINE {    RETURN[i >= r.top AND i < r.bottom]};  InvertBdryLine: PROC [sw: Window.Handle, yOffset, width: INTEGER] = {    Display.Invert[      sw, [[x:0, y: yOffset],[w: width, h: ToolOps.bdryLineWidth]]]};      StartMoveSplit: PROC [    clip: Window.Handle, place: Window.Place, tch: ToolsContext] = {    i: CARDINAL;    ms: MoveSplits;    IF tch.sws.length < 2 THEN RETURN;    IF ~InRange[      place.x, [tch.w - (bdryHeight + bdryFudge), tch.w - bdryFudge]] THEN {        UserTerminal.BlinkDisplay[]; RETURN};    i ¬ DetermineMovableBoundary[place.y, tch];    ms ¬ [      i: i,      limit: [        top: tch.boxes[i].y + bdryMargin + minSWHeight,        bottom: tch.boxes[i+1].y + tch.boxes[i + 1].h -	  (bdryMargin + minSWHeight)],      clip: clip,      range: [        top: [tch.boxes[i].y, tch.boxes[i].y + tch.boxes[i].h],	bottom: [tch.boxes[i + 1].y, tch.boxes[i + 1].y + tch.boxes[i + 1].h]],      originalY: place.y,      lastY: place.y,      lastRelativeY: place.y, -- must be relative to clipping window      lastSW: clip,      originalBound:        tch.boxes[i + 1].y + tch.boxes[i + 1].h + (bdryHeight + 1)/2];    Display.White[clip, [[0, ms.range[top].bottom], [tch.w, bdryHeight]]];    InvertBdryLine[ms.lastSW, ms.lastRelativeY, tch.w];    IF ms.limit[top] > ms.limit[bottom] THEN ms.limit[bottom] ¬ ms.limit[top];    TIP.NewManager[clip, TIP.mouseTIP, TIPMe];    IF moveSplits # NIL THEN z.FREE[@moveSplits];    moveSplits ¬ z.NEW[MoveSplits ¬ ms]};  Track: PROC [tch: ToolsContext, place: Window.Place] = {    OPEN ms: moveSplits;    IF moveSplits = NIL THEN RETURN;    SELECT place.y FROM      < ms.limit[top] => place.y ¬ ms.limit[top];      > ms.limit[bottom] => place.y ¬ ms.limit[bottom];      ENDCASE;    IF place.y = ms.lastY THEN RETURN;    ms.neverMoved ¬ FALSE;    ms.lastY ¬ place.y;    InvertBdryLine[ms.lastSW, ms.lastRelativeY, tch.w];    SELECT TRUE FROM      InRange[place.y, ms.range[top]] => {        ms.lastSW ¬ tch.sws[ms.i].sw;	ms.lastRelativeY ¬ place.y - ms.range[top].top};      InRange[place.y, ms.range[bottom]] => {        ms.lastSW ¬ tch.sws[ms.i+1].sw;	ms.lastRelativeY ¬ place.y - ms.range[bottom].top};        ENDCASE => {ms.lastSW ¬ ms.clip; ms.lastRelativeY ¬ place.y};    InvertBdryLine[ms.lastSW, ms.lastRelativeY, tch.w]};  PutSplitsDown: PROC [tch: ToolsContext] = {    OPEN ms: moveSplits;    IF moveSplits = NIL THEN RETURN;    InvertBdryLine[ms.lastSW, ms.lastRelativeY, tch.w];    IF ~ms.neverMoved AND ms.lastY # ms.originalY THEN {      newTop, newBot: Window.Box;      topsw: Window.Handle ¬ tch.sws[ms.i].sw;      botsw: Window.Handle ¬ tch.sws[ms.i + 1].sw;      [newTop: newTop, newBot: newBot] ¬ SetNewBoxes[        difY: ms.lastY - ms.originalY, topIndex: ms.i, tch: tch,	oldTop: ms.range[top], oldBot: ms.range[bottom]];      -- This gets hor. scrollbars wrong      IF ms.lastY > ms.originalY THEN {        AdjustSubwindow[botsw, AdjustProc[tch.sws[ms.i+1].type], newBot];	AdjustSubwindow[topsw, AdjustProc[tch.sws[ms.i].type], newTop]}      ELSE {        AdjustSubwindow[topsw, AdjustProc[tch.sws[ms.i].type], newTop];	AdjustSubwindow[botsw, AdjustProc[tch.sws[ms.i + 1].type], newBot]};      tch.boxes[ms.i] ¬ [h: newTop.dims.h, y: newTop.place.y];      tch.boxes[ms.i + 1] ¬ [h: newBot.dims.h, y: newBot.place.y]};    ms.clip.InvalidateBox[[         place: [x: 0, y: tch.boxes[ms.i + 1].y - bdryHeight],	dims: [h: bdryHeight, w: tch.w]],      isDirty];    ms.clip.GetParent.ValidateTree[];    z.FREE[@moveSplits];    TIP.NewManager[NIL, NIL, NIL]};  RegisterSWType: PUBLIC ENTRY PROC [    adjust: ToolWindow.AdjustProcType ¬ Tool.SimpleAdjustProc,    sleep: Tool.SWProc ¬ Tool.NopSleepProc,    wakeup: Tool.SWProc ¬ Tool.NopWakeupProc]    RETURNS [uniqueSWType: Tool.SWType] = {    ENABLE UNWIND => NULL;    newArray, oldArray: LONG POINTER TO SWProcsSequence;    uniqueSWType ¬ nextSWType;    nextSWType ¬ nextSWType.SUCC;    oldArray ¬ swProcsArray;    newArray ¬ z.NEW[SWProcsSequence[nextSWType.ORD]];    Inline.LongCOPY[      from: @oldArray[Tool.SWType.FIRST], to: @newArray[Tool.SWType.FIRST],      nwords: SWProcs.SIZE*(nextSWType.ORD - 1)];    newArray[uniqueSWType] ¬ [adjust: adjust, sleep: sleep, wakeup: wakeup];    swProcsArray ¬ newArray;    z.FREE[@oldArray]};  SetNewBoxes: PROC [    difY: INTEGER, topIndex: CARDINAL, oldTop, oldBot: Range, tch: ToolsContext]    RETURNS [newTop, newBot: Window.Box] = {    newTop ¬ [      place: [0, oldTop.top],      dims: [tch.w, oldTop.bottom - oldTop.top + difY]];    newBot ¬ [      place: [0, oldBot.top + difY],      dims: [tch.w, oldBot.bottom - oldBot.top - difY]]};  AdjustSubwindow: PROC [    sw: Window.Handle, adjust: ToolWindow.AdjustProcType, box: Window.Box] = {    -- not optimal, but this is only used on invisible windows    hBox, vBox: Window.Box;    hScroll, vScroll: Window.Handle;    [box, vScroll, vBox, hScroll, hBox] ¬ Scrollbar.Adjust[sw, box];    IF hScroll # NIL THEN hScroll.SlideAndSize[hBox, nw];    IF vScroll # NIL THEN vScroll.SlideAndSize[vBox, nw];    adjust[sw, box, before];    sw.SlideAndSize[box, nw];    adjust[sw, box, after]};    SwapSWs: PUBLIC PROC [window, oldSW, newSW: Window.Handle, newType: Tool.SWType]    RETURNS [oldType: Tool.SWType] = {    tch: ToolsContext ¬ Context.Find[context, window];    youngSib: Window.Handle;    i: CARDINAL;    IF tch = NIL THEN Error[notATool];    IF newType = predefined THEN newType ¬ ToolOps.FindType[newSW];    IF newType >= nextSWType THEN Error[unknownSWType];    oldType ¬ ToolOps.undefined;    FOR i IN [0..tch.sws.length) DO      IF tch.sws[i].sw = oldSW THEN {        oldType ¬ tch.sws[i].type;        AdjustSubwindow[	  newSW, AdjustProc[newType],	  [[0, tch.boxes[i].y], [tch.w, tch.boxes[i].h]]];        tch.sws[i] ¬ ToolOps.SWRecord[sw: newSW, type: newType];	youngSib ¬ Window.GetSibling[oldSW];        ToolWindow.DelinkSubwindow[child: oldSW];	Scrollbar.WindowNowDelinked[oldSW];        ToolWindow.EnlinkSubwindow[          parent: window, child: newSW, youngerSibling: youngSib];	Scrollbar.WindowNowEnlinked[newSW];        EXIT};      REPEAT FINISHED => Error[swNotFound];      ENDLOOP};  UserCmValues: PROC [    id: LONG STRING, box: Window.Box, place: Window.Place,    state: ToolWindow.State]    RETURNS [Window.Box, Window.Place, ToolWindow.State] = {    Option: TYPE = MACHINE DEPENDENT{      windowBox(0), tinyPlace(1), initialState(2), noMatch(StringLookUp.noMatch)};    DefinedOption: TYPE = Option [windowBox..initialState];    optionTable: ARRAY DefinedOption OF LONG STRING ¬ [      windowBox: "WindowBox"L, tinyPlace: "TinyPlace"L,      initialState: "InitialState"L];    userCm: CmFile.Handle;    i: Option;    CheckType: PROC [h: CmFile.Handle, table: StringLookUp.TableDesc]      RETURNS [index: CARDINAL] = CmFile.NextValue;    MyNextValue: PROC [      h: CmFile.Handle,      table: LONG DESCRIPTOR FOR ARRAY DefinedOption OF LONG STRING]      RETURNS [index: Option] = LOOPHOLE[CheckType];    userCm ¬ CmFile.UserDotCmOpen[ ! CmFile.Error => GOTO NoUserDotCm];    IF CmFile.FindSection[userCm, id] THEN      BEGIN      DO        SELECT        (i ¬ MyNextValue[          userCm, DESCRIPTOR[optionTable] ! CmFile.TableError => RESUME ]) FROM          noMatch => EXIT;          windowBox => box ¬ Token.WindowBox[userCm];          tinyPlace => place ¬ Token.WindowBox[userCm].place;          initialState => state ¬ GetState[userCm, state];          ENDCASE;        ENDLOOP;      END;    [] ¬ CmFile.Close[userCm];    RETURN[box, place, state];    EXITS NoUserDotCm => RETURN[box, place, state]};  GetState: PUBLIC PROC [h: CmFile.Handle, state: ToolWindow.State]    RETURNS [ToolWindow.State] = {    labels: ARRAY [0..3) OF LONG STRING ¬ ["tiny"L, "active"L, "inactive"L];    temp: LONG STRING ¬ Token.Item[h];    IF String.Length[temp] > 0 THEN {      SELECT StringLookUp.InTable[temp, DESCRIPTOR[labels]] FROM        0 => state ¬ tiny;        1 => state ¬ active;        2 => state ¬ inactive;        ENDCASE};    String.FreeString[z, temp];    RETURN[state]};  -- Utility Procedures  DestroyContext: PROC [tch: ToolsContext, window: Window.Handle] = {    z.FREE[@tch.sws];    z.FREE[@tch.boxes];    z.FREE[@tch.name];    z.FREE[@tch.cmSection];    z.FREE[@tch]};  InitMonitorData: PUBLIC PROC = {    OPEN ToolOps;    IF initialized THEN RETURN;    swProcsArray ¬ z.NEW[SWProcsSequence[nextSWType.ORD]];    swProcsArray[vanilla] ¬ SWProcs[      Tool.SimpleAdjustProc, Tool.NopSleepProc, Tool.NopWakeupProc];    swProcsArray[ttySW] ¬ swProcsArray[msgSW] ¬ SWProcs[      TextSW.Adjust, TextSW.Sleep, TextSW.Wakeup];    swProcsArray[textSW] ¬ swProcsArray[fileSW] ¬ swProcsArray[stringSW] ¬      swProcsArray[ttySW];    swProcsArray[formSW] ¬ [FormSW.Adjust, FormSW.Sleep, FormSW.Wakeup];    pointDown ¬ Atom.MakeAtom["PointDown"L];    pointUp ¬ Atom.MakeAtom["PointUp"L];    track ¬ Atom.MakeAtom["PointMotion"L];    initialized ¬ TRUE};    -- Mainline code  InitMonitorData[];  END.  
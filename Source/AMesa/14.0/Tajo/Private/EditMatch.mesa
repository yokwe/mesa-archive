-- File: EditMatch.mesa - last edit:-- BGY     		29-Jul-83 00:00:00-- Hamilton.ES	15-Nov-84 18:22:20-- DWR    	14-Feb-85 15:06:30-- Copyright (C) 1984 by Xerox Corporation. All rights reserved.DIRECTORY  EditOps USING [AbortProc, CharClass, CharClassObject, ClosureType, MatchList, MatchListObject, MatchType, nullPosition],  Environment USING [Block],  Heap USING [systemZone],  Inline USING [LowHalf],  String USING [AppendChar, AppendStringAndGrow, StringBoundsFault],  TextSource USING [AsciiTextSearch, Handle, Position, SearchFailed];EditMatch: PROGRAM   IMPORTS Heap, Inline, String, TextSource EXPORTS EditOps =   BEGIN  MAXSTR : CARDINAL = 100;  CLOSIZE: CARDINAL = 1;  ESCAPE:  CHARACTER = '\\;  DASH:    CHARACTER = '-;  CLOSURE: CHARACTER = '*;  NOALPHA: CHARACTER = '|;  BOL:     CHARACTER = '%;  ANYC:    CHARACTER = '#;  CCL:     CHARACTER = '[;  TAB:     CHARACTER = '\011;  CCLEND:  CHARACTER = '];  NEGATE:  CHARACTER = '~;  NCCL:    CHARACTER = '!;  NEWLINE: CHARACTER = '\015;  NullVal: CARDINAL ¬ CARDINAL.LAST;  z: UNCOUNTED ZONE ¬ Heap.systemZone;    abortCounter: CARDINAL ¬ 0;  -- counter for abort check  Abort: EditOps.AbortProc;    nullPosition: TextSource.Position = TextSource.Position.LAST;    AbortSearch: PUBLIC SIGNAL = CODE;  BadPattern: SIGNAL[pat: EditOps.MatchList, n: CARDINAL]     RETURNS[null: CARDINAL ¬ CARDINAL.LAST];      FoundLiteral: SIGNAL[beginPos: TextSource.Position];    BlockPtr: TYPE = POINTER TO Block;  Block: TYPE = RECORD[    block: Environment.Block,    start: TextSource.Position,    valid: BOOLEAN];      Match: PUBLIC PROC[source: TextSource.Handle, pat: EditOps.MatchList,    startPos,lastPlusOne: TextSource.Position, abort: EditOps.AbortProc,    ignoreCase: BOOLEAN ¬ FALSE,    matchWord: BOOLEAN ¬ FALSE]     RETURNS [match: BOOLEAN, start,end: TextSource.Position] ={    pos: TextSource.Position ¬ 0;    i  : TextSource.Position ¬ startPos;    b: Block ¬ [      block: source.readText[source, 0, 200, none].block,      start: 0, valid: TRUE];    Abort ¬ abort;    match ¬ FALSE;    start ¬ end ¬ nullPosition;    BEGIN ENABLE TextSource.SearchFailed => GOTO failed;    WHILE i < lastPlusOne AND pos = 0 DO      pos ¬ AMatch[source, @b, i, lastPlusOne, pat, 0, ignoreCase!        FoundLiteral => {	  i ¬ beginPos;	  RESUME}];      IF pos # 0 THEN {        IF matchWord THEN {	  before: TextSource.Position ¬ 0;	  after:  TextSource.Position ¬ pos;	  atStart, atEnd: BOOLEAN ¬ FALSE;	  IF i = 0 THEN atStart ¬ TRUE ELSE before ¬ i - 1;	  IF pos >= lastPlusOne THEN atEnd ¬ TRUE;	  IF (~atStart AND IsAlphaNum[GetChar[source,@b,before]]) OR	    (~atEnd AND IsAlphaNum[GetChar[source,@b,after]]) THEN pos ¬ 0;	  };	start ¬ i};      i ¬ i + 1;      ENDLOOP;    end ¬ pos;    match ¬ pos > 0;    EXITS failed => NULL;    END;    };    AMatch: PUBLIC PROC[ -- look for match of pat[j]... at lin[offset]...    source: TextSource.Handle, b: BlockPtr,     offset, length: TextSource.Position,     pat: EditOps.MatchList, j: CARDINAL, ignoreCase: BOOLEAN ¬ FALSE]     RETURNS [pos: TextSource.Position] = {    i,k, oldI: TextSource.Position ¬ 0;    done: BOOLEAN ¬ FALSE;    type: EditOps.ClosureType;    WHILE ~done AND j < pat.length DO      WITH p: pat[j] SELECT FROM        closure => {	  type ¬ p.type;	  j ¬ j + 1;  -- step over CLOSURE	  i ¬ offset;	  SELECT type FROM	    long => {	      WHILE ~done AND i < length DO		IF ~OMatch[source, b, @i, pat, j, length, ignoreCase] THEN 		  done ¬ TRUE;		ENDLOOP;	      done ¬ FALSE;	      WHILE ~done AND i >= offset DO		k ¬ AMatch[source, b, i, length, pat, j + 1, ignoreCase];		IF k > 0 THEN {		  done ¬ TRUE; 		  pat[j-1].startPos ¬ offset;		  pat[j-1].endPos ¬ i-1}		ELSE IF i = 0 THEN EXIT ELSE i ¬ i - 1;		ENDLOOP;	      offset ¬ k;	      done ¬ TRUE};	    short => {	      WHILE ~done AND i < length DO	        k ¬ AMatch[source, b, i, length, pat, j + 1, ignoreCase];		IF k > 0 THEN {		  done ¬ TRUE; 		  pat[j-1].startPos ¬ offset;		  pat[j-1].endPos ¬ i-1};		IF ~OMatch[source, b, @i, pat, j, length, ignoreCase] THEN EXIT		ENDLOOP;	      offset ¬ k;	      done ¬ TRUE;	      };	    ENDCASE;	  };	ENDCASE => {	  oldI ¬ offset;	  IF ~OMatch[source, b, @offset, pat, j, length, ignoreCase!	    FoundLiteral => {	      oldI ¬ beginPos;	      REJECT}] THEN {	    offset ¬ 0;	    done ¬ TRUE;	    }	  ELSE {	    pat[j].startPos ¬ oldI;	    pat[j].endPos ¬ offset-1;	    j ¬ j + 1};	  };      ENDLOOP;    pos ¬ offset;    };  -- end of AMatch    GetChar: PROC[source: TextSource.Handle, b: BlockPtr,    i: TextSource.Position]    RETURNS [c: CHARACTER] = INLINE {    endPlusOne: TextSource.Position;    IF ~b.valid THEN {      b­ ¬ [block: source.readText[source, i, 200, none].block,        start: i, valid: TRUE];      };    endPlusOne ¬ b.start + b.block.stopIndexPlusOne      - b.block.startIndex;    SELECT i FROM      < b.start => {        b.block ¬ source.readText[source, i, 5, none].block;	b.start ¬ i;	c ¬ LOOPHOLE[b.block.blockPointer[b.block.startIndex], CHARACTER]};      >= endPlusOne => {        b.block ¬ source.readText[source, i, 200, none].block;	b.start ¬ i;	c ¬ LOOPHOLE[b.block.blockPointer[b.block.startIndex], CHARACTER]};      ENDCASE  => c ¬        LOOPHOLE[b.block.blockPointer[         b.block.startIndex + Inline.LowHalf[(i-b.start)]], CHARACTER];      };  OMatch: PROC[source: TextSource.Handle, b: BlockPtr,    i: LONG POINTER TO TextSource.Position,    pat: EditOps.MatchList, j: CARDINAL, length: TextSource.Position,    ignoreCase: BOOLEAN ¬ FALSE]     RETURNS [match: BOOLEAN] = {    c: CHARACTER;    advance: CARDINAL ¬ NullVal;    IF i­ >= length THEN RETURN[FALSE];    c ¬ GetChar[source, b, i­];    abortCounter ¬ abortCounter + 1;    IF abortCounter MOD 1024 = 0 THEN IF Abort[] THEN SIGNAL AbortSearch;    WITH p: pat[j] SELECT FROM      any     => advance ¬ 1;      ccl     => IF Locate[c, p.cc] THEN advance ¬ 1;      nccl    => IF ~Locate[c, p.cc] THEN advance ¬ 1;      literal => {        IF j = 0 THEN { --first part of pattern is Plain Text	  lineStart, left: TextSource.Position;	  [lineStart, left] ¬ TextSource.AsciiTextSearch[	    source, p.lit, i­, length-1, ignoreCase];	  SIGNAL FoundLiteral[left];	  b.valid ¬ FALSE;  -- invalidate the source block	  i­ ¬ left + p.lit.length}        ELSE FOR k: CARDINAL IN [0..p.lit.length) DO	  IF ignoreCase THEN {	    IF p.lit[k] # Upper[c] AND  p.lit[k] # Lower[c] THEN RETURN[FALSE]}	  ELSE IF c # p.lit[k] THEN RETURN[FALSE];	  i­ ¬ i­ + 1;	  IF i­ >= length THEN 	    IF k = p.lit.length-1 THEN EXIT ELSE RETURN[FALSE];	  c ¬ GetChar[source, b, i­];	  abortCounter ¬ abortCounter + 1;	  IF abortCounter MOD 1000 = 0 THEN IF Abort[] THEN 	    SIGNAL AbortSearch;	  ENDLOOP;	advance ¬ 0;	};      bol     => IF i­ = 0 THEN advance ¬ 0        ELSE {	  l: TextSource.Position ¬ i­ -1;	  c ¬ GetChar[source, b, l];	  abortCounter ¬ abortCounter + 1;	  IF abortCounter MOD 1000 = 0 THEN IF Abort[] THEN 	    SIGNAL AbortSearch;	  IF c = NEWLINE THEN advance ¬ 0;	  };      ENDCASE => [] ¬ SIGNAL BadPattern[pat,j];    IF advance # NullVal THEN {      i­ ¬ i­ + advance;      match ¬ TRUE}    ELSE match ¬ FALSE;      };    Upper: PROC[c: CHARACTER] RETURNS [u: CHARACTER] = INLINE {    u ¬ IF c IN ['a..'z] THEN 'A + (c-'a) ELSE c};    Lower: PROC[c: CHARACTER] RETURNS [l: CHARACTER] = INLINE{    l ¬ IF c IN ['A..'Z] THEN 'a + (c-'A) ELSE c};    Locate: PROC[c: CHARACTER, cc: EditOps.CharClass]     RETURNS [found: BOOLEAN] = {    i,j: CARDINAL ¬ 0;    found ¬ FALSE;    FOR i IN [0..cc.length) DO      IF c >= cc[i].lower AND c <= cc[i].upper THEN RETURN[TRUE];      ENDLOOP;    FOR j IN [0..cc.random.length) DO      IF cc.random[j] = c THEN RETURN[TRUE];      ENDLOOP;    };        FreePat: PUBLIC PROC[pat: EditOps.MatchList]    RETURNS [nil: EditOps.MatchList]  = {    nil ¬ pat;    IF nil = NIL THEN RETURN;    FOR i: CARDINAL IN [0..nil.length) DO      WITH p: nil[i] SELECT FROM        literal => IF p.lit # NIL THEN z.FREE[@p.lit];	ccl, nccl => {	  IF p.cc.random # NIL THEN z.FREE[@p.cc.random];	  z.FREE[@p.cc];	  };	ENDCASE;      ENDLOOP;    z.FREE[@nil];    };    MakeMatchObject: PROC[length: CARDINAL]RETURNS[pat: EditOps.MatchList ¬ NIL]={    pat ¬ z.NEW[EditOps.MatchListObject[length]];    FOR i: CARDINAL IN [0..length) DO      pat[i] ¬ [class: literal[lit: NIL]];      pat[i].startPos ¬ pat[i].endPos ¬ EditOps.nullPosition ENDLOOP;    };    MakePat: PUBLIC PROC[    arg: LONG STRING, start: CARDINAL, oldPat: EditOps.MatchList ¬ NIL,    treatAsLiteral: BOOLEAN ¬ FALSE]     RETURNS[ok: BOOLEAN, pat: EditOps.MatchList] = {    i,j: CARDINAL;    c: CHARACTER;    done: BOOLEAN;    GrowPattern: PROC = {      oldPat ¬ pat;      pat ¬ MakeMatchObject[2*oldPat.maxlength];      pat.length ¬ oldPat.maxlength;      FOR m: CARDINAL IN [0..oldPat.maxlength) DO        pat[m] ¬ oldPat[m];	ENDLOOP;      z.FREE[@oldPat];      };        AddType: PROC[type: EditOps.MatchType] = {      IF j >= pat.maxlength THEN GrowPattern[];      WITH p: pat[j] SELECT FROM        nccl,ccl => IF p.cc # NIL THEN {	  IF p.cc.random # NIL THEN z.FREE[@p.cc.random];	  z.FREE[@p.cc]};	literal => IF p.lit # NIL THEN z.FREE[@p.lit];	ENDCASE;      pat[j] ¬ SELECT type FROM        ccl => [class: ccl[]],        nccl => [class: nccl[]],	literal => [class: literal[]], 	any => [class: any[]], 	bol => [class: bol[]], 	ENDCASE => [class: closure[]];       j ¬ j + 1};      GetCCL: PROC RETURNS [BOOLEAN] = {      i ¬ i + 1;      IF arg[i] = NEGATE THEN {        AddType[nccl];        i ¬ i + 1}      ELSE AddType[ccl];      WITH p: pat[j-1] SELECT FROM        nccl, ccl => {	  IF p.cc = NIL THEN p.cc ¬ z.NEW[EditOps.CharClassObject[20]];	  i ¬ DoDash[CCLEND, arg, i, p.cc]};	ENDCASE;      RETURN[arg[i] = CCLEND];      };        j ¬ 0; i ¬ start; done ¬ FALSE;    pat ¬ oldPat;    IF pat = NIL THEN pat ¬ MakeMatchObject[20];    pat.length ¬ 0;    IF treatAsLiteral THEN {      AddType[literal];      WITH p: pat[0] SELECT FROM        literal => {String.AppendStringAndGrow[@p.lit, arg, z, 20]};	ENDCASE;      ok ¬ TRUE; pat.length ¬ 1;      RETURN};    WHILE ~done AND  i < arg.length DO      c ¬ arg[i];      SELECT TRUE FROM        c = ANYC => AddType[any];        c = BOL => IF i = start THEN AddType[bol];	c = CCL => done ¬ ~GetCCL[];	c = CLOSURE AND  i>start => {	  WITH p: pat[j-1] SELECT FROM	    bol, closure => done ¬ TRUE;	    ENDCASE => {	      IF j >= pat.maxlength THEN GrowPattern[];	      pat[j] ¬ pat[j-1];	      IF i+1 < arg.length AND arg[i+1] = CLOSURE THEN {	        pat[j-1] ¬ [class: closure[type:long]];		i ¬ i + 1}	      ELSE pat[j-1] ¬ [class: closure[type:short]];	      j ¬ j+1;	      };	  };	ENDCASE => {	  AddType[literal];	  i ¬ GetLiteral[pat, j-1, arg, i]};      IF ~done THEN i ¬ i + 1;      ENDLOOP;    IF done OR i < arg.length THEN ok ¬ FALSE    ELSE {ok ¬ TRUE; pat.length ¬ j};    };      GetLiteral: PROC[pat: EditOps.MatchList, p: CARDINAL, arg: LONG STRING,    j: CARDINAL] RETURNS [i: CARDINAL] = {    c: CHARACTER;    start: CARDINAL ¬ j;    i ¬ j;    WITH q: pat[p] SELECT FROM      literal => {        ENABLE String.StringBoundsFault => {          ns ¬ z.NEW[StringBody[2*s.length]];          ns.length ¬ s.length;          FOR z: CARDINAL IN [0..s.length) DO ns[z] ¬ s[z];ENDLOOP;          z.FREE[@s];	  q.lit ¬ ns;          RESUME};        IF q.lit = NIL THEN q.lit ¬ z.NEW[StringBody[50]];	q.lit.length ¬ 0;	WHILE i < arg.length DO 	  SELECT arg[i] FROM	    ANYC, BOL, CCL, CLOSURE => IF i # start THEN {i ¬ i - 1; EXIT}	      ELSE String.AppendChar[q.lit, arg[i]];	    ENDCASE => {	      lastI: CARDINAL ¬ i-1;	      [c,i] ¬ Esc[arg, i];	      IF i+1 = arg.length OR q.lit.length = 0 OR arg[i+1] # CLOSURE THEN	        String.AppendChar[q.lit, c]	      ELSE {i ¬ lastI; EXIT}};	  i ¬ i + 1;	  ENDLOOP;	};      ENDCASE;    };    Esc: PROC[s: LONG STRING, j: CARDINAL]     RETURNS [c: CHARACTER, i: CARDINAL] = {    i ¬ j;    IF s[i] # ESCAPE THEN c ¬ s[i]    ELSE IF i+1 >= s.length THEN c ¬ ESCAPE    ELSE {      i ¬ i + 1;      SELECT s[i] FROM        'n, 'N => c ¬ NEWLINE;	't, 'T => c ¬ TAB;	IN ['0..'9] => {	  IF (i+2 < s.length) AND (s[i+1] IN ['0..'9]) AND 	  (s[i+2] IN ['0..'9]) THEN {	    k,l: CARDINAL ¬ 0;	    FOR l IN [0..3) DO	      k ¬ k*8 + (s[i+l] - '0) ENDLOOP;	    c ¬ LOOPHOLE[(k MOD 256), CHARACTER];	    i ¬ i + 2}	  ELSE c ¬ s[i];	  };	ENDCASE => c ¬ s[i]      };    };      DoDash: PROC[delim: CHARACTER, src: LONG STRING,    I: CARDINAL, dest: EditOps.CharClass]    RETURNS [i: CARDINAL]= {    ENABLE String.StringBoundsFault => {      ns ¬ z.NEW[StringBody[2*s.maxlength]];      ns.length ¬ s.length;      FOR z: CARDINAL IN [0..s.length) DO ns[z] ¬ s[z]; ENDLOOP;      z.FREE[@s];      dest.random ¬ ns;      RESUME};    k: CHARACTER;    i ¬ I;    IF dest.random = NIL THEN dest.random ¬ z.NEW[StringBody[20]];    dest.random.length ¬ 0;    WHILE src[i] # delim AND i < src.length DO      SELECT TRUE FROM        src[i] = ESCAPE => {	  [k,i] ¬ Esc[src, i];	  String.AppendChar[dest.random, k]};	src[i] # DASH => String.AppendChar[dest.random, src[i]];	src[i-1] = CCL OR i+1 >= src.length =>	  String.AppendChar[dest.random, DASH];	IsAlphaNum[src[i-1]] AND IsAlphaNum[src[i+1]] 	  AND src[i-1] <= src[i+1] => {	  dest.subclass[dest.length] ¬ [src[i-1], src[i+1]];	  dest.length ¬ dest.length+1;	  dest.random.length ¬ dest.random.length-1;	  i ¬ i + 1};	ENDCASE => String.AppendChar[dest.random, DASH];      i ¬ i + 1;      ENDLOOP;    };    IsAlphaNum: PUBLIC PROC[c: CHARACTER] RETURNS [yes: BOOLEAN] ={    yes ¬ SELECT c FROM      IN ['a..'z], IN ['A..'Z], IN ['0..'9] => TRUE,      ENDCASE => FALSE};    END... --of Edit
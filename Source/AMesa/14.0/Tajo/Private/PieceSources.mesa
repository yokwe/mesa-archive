-- Copyright (C) 1979, 1980, 1981, 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- File: PieceSources.mesa - last edit:-- SXW   	21-Jul-81 22:23:41-- JGS		 3-Sep-81 17:18:12-- Mark		17-Dec-80 22:19:37-- SXS   	20-Sep-82 16:19:54-- AXD    	31-Jan-84 18:52:07-- CXH   	 2-Feb-83 19:00:33-- converted from Cattell's 30-Nov-79 10:19 version DIRECTORY  ByteBlt USING [ByteBlt],  DiskSource USING [Create, Info],  Environment USING [Block],  Heap: TYPE USING [CreateUniform, systemZone],  Inline USING [HighHalf, LowHalf],  MFile USING [    CopyFileHandle, dontRelease, Error, GetFullName, GetProperties, Handle,    maxNameLength, Release, SetAccess, SetTimes, SwapNames, WriteOnly],  MStream USING [Create, GetFile, Handle, SetLength],  PieceSource USING [],  Runtime USING [CallDebugger],  Selection USING [maxStringLength, SetTrashBin, Source, SourceObject, Target],  Stream USING [SendNow],  String USING [    AppendChar, AppendStringAndGrow, CopyToNewString, EquivalentString,    EquivalentSubString, MakeString, Replace, SubStringDescriptor,    StringBoundsFault],  StringSource USING [Create],  TextSource USING [    Action, AsciiDoEditAction, AsciiScanText, Class, Error, Handle,    Position, Procedures, ProceduresObject, ReadText],  Time USING [Packed];PieceSources: PROGRAM  IMPORTS    ByteBlt, DiskSource, Heap, Inline, MFile, MStream, Runtime, Selection, String,    Stream, StringSource, TextSource  EXPORTS PieceSource =  BEGIN OPEN TextSource;  -- Definitions and TYPES  PieceSource: TYPE = LONG POINTER TO PieceSourceObject;  PieceSourceObject: TYPE = RECORD [    procs: TextSource.Procedures,    sources: ARRAY {original, scratch} OF TextSource.Handle ¬ [NIL, NIL],    pieceOfMind: PieceSourceState ¬ birdInEgg,    pieceTable: PieceList ¬ NIL,    currentPiece: LONG POINTER TO Piece ¬ NIL,    byteOfCurrentPiece: Position ¬ 0,    vStartOfCurrentPiece: Position ¬ 0,    lastInScratch: LONG POINTER TO Piece ¬ NIL,    vLength: Position ¬ 0,    badMessage: LONG STRING ¬ NIL,    isBad: BOOLEAN ¬ FALSE];  PieceSourceState: TYPE = {birdInHand, birdInBush, birdInEgg};  PieceList: TYPE = LONG POINTER TO Piece;  Piece: TYPE = RECORD [    source: TextSource.Handle,    position: Position,  -- position of first byte of piece in file    length: LONG CARDINAL,  -- how many bytes in this piece    next: LONG POINTER TO Piece];  -- Piece Source data and stuff  trashOwner: PieceSource ¬ NIL;  pieceProcs: ProceduresObject ¬ [    actOn: ActOnPiece, doEditAction: TextSource.AsciiDoEditAction,    getLength: GetPieceLength, readText: ReadPieceText,    replaceText: ReplacePieceText, scanText: TextSource.AsciiScanText,    setLength: SetPieceLength];  z: UNCOUNTED ZONE = Heap.systemZone;  pieceZone: UNCOUNTED ZONE = Heap.CreateUniform[    initial: 2, increment: 2, objectSize: SIZE[Piece]];  -- Private SIGNALs  CannotCleanupStream: SIGNAL = CODE;  -- Piece Source Public Routines  Create: PUBLIC PROC [original, scratch: TextSource.Handle]    RETURNS [source: Handle] = {    ps: PieceSource ¬ z.NEW[PieceSourceObject ¬ [      procs: @pieceProcs, sources: [original, scratch],      pieceOfMind: IF scratch = NIL THEN birdInEgg ELSE birdInBush,      vLength: original.getLength[original]]];    ps.pieceTable ¬ FreshPieceTable[ps];    ps.currentPiece ¬ ps.pieceTable;    SetUpScratch[ps];    RETURN[LOOPHOLE[ps, Handle]]};  Info: PUBLIC PROC [source: Handle] RETURNS [original, scratch: Handle] = {    OPEN ps: LOOPHOLE[source, PieceSource];    IF ~ps.isBad AND ps.procs = @pieceProcs THEN      RETURN[ps.sources[original], ps.sources[scratch]]    ELSE RETURN[NIL, NIL]};  IsIt: PUBLIC PROC [source: Handle] RETURNS [yes: BOOLEAN] = {    RETURN[source # NIL AND LOOPHOLE[source, PieceSource].procs = @pieceProcs]};  Put: PUBLIC PROC [source: TextSource.Handle, name: LONG STRING]    RETURNS [TextSource.Handle] = {    OPEN ps: LOOPHOLE[source, PieceSource];    CleanUp: PROC = {      z.FREE[@originalName];      z.FREE[@tempName];      IF source # NIL THEN DestroyPieceObject[@ps]};    originalName, tempName: LONG STRING ¬ NIL;    newSource: TextSource.Handle;    end: Position;    overWrite: BOOLEAN;    of, nf: MFile.Handle;    BEGIN ENABLE UNWIND => {z.FREE[@originalName]; z.FREE[@tempName]};    IF ps.isBad THEN RETURN[source];    tempName ¬ String.CopyToNewString[name, z, 1];    FullName[      @originalName, MStream.GetFile[DiskSource.Info[ps.sources[original]].s]];    overWrite ¬      (name = NIL OR originalName = NIL OR NameMatch[originalName, name]);    IF overWrite THEN {      fullName: LONG STRING ¬ [MFile.maxNameLength];      IF ps.pieceOfMind = birdInEgg THEN {        -- Just close up shop if he hasn't done any puts (into scratch)        newSource ¬ ps.sources[original];        ps.sources[original] ¬ NIL;        CleanUp[];        RETURN[newSource]};      of ¬ MStream.GetFile[DiskSource.Info[ps.sources[original]].s];      {-- we don't really want to change the create date      create: Time.Packed = MFile.GetProperties[of].create;      MFile.SetAccess[of, rename];  -- Just to make sure we can get it      MFile.SetAccess[of, readWrite];      MFile.SetTimes[file: of, create: create]};      of ¬ MFile.CopyFileHandle[        file: of, release: MFile.dontRelease, access: readWrite];      MFile.GetFullName[file: of, name: fullName];      String.AppendChar[fullName, '$];      String.Replace[@tempName, fullName, z]};    nf ¬ MFile.WriteOnly[      name: tempName, release: MFile.dontRelease, type: text,      initialLength: source.getLength[source] !      MFile.Error => IF overWrite THEN MFile.Release[of]];    IF ~overWrite THEN FullName[@tempName, nf]    ELSE {--kludge--      -- to prevent dying horribly later if someone delete protects tempName      MFile.SetAccess[nf, rename];      MFile.SetAccess[nf, writeOnly]}--kludge--;    -- WE ARE COMMITTED TO COMPLETE THE PUT NOW!    {ENABLE UNWIND =>      Runtime.CallDebugger["PieceSources: UNWIND in critical region"L];    ns: MStream.Handle = MStream.Create[file: nf, release: []];    MStream.SetLength[ns, 0];  -- avoids accessError in replaceText    newSource ¬ DiskSource.Create[tempName, append, ns]};    end ¬ 0;    FOR pl: PieceList ¬ ps.pieceTable, pl.next UNTIL pl = NIL DO      charsLeft: LONG CARDINAL ¬ pl.length;      start, next: Position;      start ¬ pl.position;      WHILE charsLeft > 0 DO        block: Environment.Block;        [block, next] ¬ pl.source.readText[          pl.source, start,          IF Inline.HighHalf[charsLeft] = 0 THEN Inline.LowHalf[charsLeft]          ELSE LAST[CARDINAL], none];        end ¬ newSource.replaceText[newSource, block, end, end, FALSE].new;        charsLeft ¬ charsLeft + start - next;        start ¬ next;        ENDLOOP;      ENDLOOP;    {    s: MStream.Handle = DiskSource.Info[newSource].s;    Stream.SendNow[s];  -- update length in handle    nf ¬ MFile.CopyFileHandle[MStream.GetFile[s], MFile.dontRelease, writeOnly]};    newSource.actOn[newSource, destroy];    IF overWrite THEN      BEGIN      [] ¬ source.actOn[source, destroy];      source ¬ NIL;  -- For CleanUp      -- could lose access here if outstanding anchor      MFile.SetAccess[nf, rename];      MFile.SetAccess[of, rename];      MFile.SwapNames[nf, of !        MFile.Error =>	  Runtime.CallDebugger["PieceSources: MFile.Error in critical region"L]];      MFile.Release[of];      END;    MFile.SetAccess[nf, readOnly];    newSource ¬ DiskSource.Create[      IF overWrite THEN originalName ELSE tempName, read,      MStream.Create[file: nf, release: []]];    CleanUp[];    RETURN[newSource];    END};  Reset: PUBLIC PROC [source: TextSource.Handle]    RETURNS [original: TextSource.Handle] = {    -- Erases all changes to the file, returns it to its original state    -- destroying the scratch source, and destroying the state info.    OPEN ps: LOOPHOLE[source, PieceSource];    IF ps.isBad THEN RETURN[source];  -- If PieceSource is bad this procedure is a NOP!    original ¬ ps.sources[original];    ps.sources[original] ¬ NIL;    DestroyPieceObject[@ps];    RETURN[original]};  -- PieceSource Procedural Interface routines  ActOnPiece: PROC [source: TextSource.Handle, action: Action] = {    OPEN ps: LOOPHOLE[source, PieceSource];    original: TextSource.Handle ¬ ps.sources[original];    scratch: TextSource.Handle ¬ ps.sources[scratch];    SELECT action FROM      destroy => DestroyPieceObject[@ps];      mark => NULL;      sleep =>        BEGIN        IF original # NIL THEN [] ¬ original.actOn[original, sleep];        IF scratch # NIL THEN [] ¬ scratch.actOn[scratch, sleep];        END;      truncate => NULL;      wakeup =>        BEGIN        IF original # NIL THEN original.actOn[original, wakeup];        IF scratch # NIL THEN original.actOn[scratch, wakeup];        END;      ENDCASE => ERROR};  GetPieceLength: PROC [source: Handle] RETURNS [position: Position] =    BEGIN RETURN[LOOPHOLE[source, PieceSource].vLength]; END;  ReplacePieceText: PROC [    source: Handle, block: Environment.Block, from, to: Position,    deleteToTrashbin: BOOLEAN] RETURNS [new: Position, delta: LONG INTEGER] = {    OPEN ps: LOOPHOLE[source, PieceSource];    cp, pl: PieceList;    next, start: Position;    n: LONG CARDINAL ¬ to - from;    IF ps.isBad THEN RETURN[from, 0];    SetPosition[@ps, from];    delta ¬ 0;    IF n # 0 THEN {      pieces: PieceList ¬ Delete[@ps, n];      IF deleteToTrashbin THEN {        Selection.SetTrashBin[pieces, ConvertTrash, ClearTrash]; trashOwner ¬ @ps}      ELSE FreePieceList[pieces];      ps.vLength ¬ ps.vLength - n};    IF block.startIndex # block.stopIndexPlusOne THEN {      IF ps.pieceOfMind # birdInHand THEN {        IF ps.pieceOfMind = birdInEgg THEN SetUpScratch[@ps];        -- Last SetPosition call has set byteOfCurrentPiece, but        -- now we have to break up currentPiece into 3 pieces:        -- (1) old currentPiece, truncated at byteOfCurrentPiece        -- (2) new currentPiece with the new characters so far        -- (3) remainder of old currentPiece        BreakCurrentPieceAtPosition[@ps];  -- (1) and (3) created        pl ¬ pieceZone.NEW[Piece ¬ [          source: ps.sources[scratch],          position: ps.sources[scratch].getLength[ps.sources[scratch]],	  length: 0, next: ps.currentPiece.next]];  -- and pl is (2)        ps.currentPiece.next ¬ pl;        ps.currentPiece ¬ ps.lastInScratch ¬ pl;        ps.vStartOfCurrentPiece ¬ from;        ps.byteOfCurrentPiece ¬ 0};      cp ¬ ps.currentPiece;      start ¬ cp.position + ps.byteOfCurrentPiece;      next ¬ cp.source.replaceText[cp.source, block, start, start, FALSE].new;      delta ¬ next - start;      ps.byteOfCurrentPiece ¬ cp.length ¬ cp.length + delta;      ps.vLength ¬ ps.vLength + delta;      ps.pieceOfMind ¬ birdInHand}    ELSE {delta ¬ 0};    RETURN[from + delta, delta - n]};  ReadPieceText: PROC [    source: Handle, position: Position, maxLength: CARDINAL, class: Class]    RETURNS [block: Environment.Block, next: Position] = {    OPEN ps: LOOPHOLE[source, PieceSource];    p: LONG POINTER TO Piece;    offset, leftInPiece: LONG CARDINAL;    start: Position;    [p, offset] ¬ PieceAndOffsetForPosition[@ps, position];    start ¬ p.position + offset;    IF Inline.HighHalf[leftInPiece ¬ p.length - offset] = 0 THEN      maxLength ¬ MIN[maxLength, Inline.LowHalf[leftInPiece]];    [block, next] ¬ p.source.readText[p.source, start, maxLength, class];    RETURN[block, position + (next - start)]};  SetPieceLength: PROC [source: Handle, position: Position]    RETURNS [Position] = {    OPEN ps: LOOPHOLE[source, PieceSource];    IF ps.isBad OR ps.vLength < position THEN RETURN[position];  -- can't lengthen this way    IF ps.vLength # position THEN {      SetPosition[@ps, position];      FreePieceList[Delete[@ps, ps.vLength - position]];      ps.vLength ¬ position};    RETURN[ps.vLength]};  -- PieceTable Routines  Delete: PROC [ps: PieceSource, size: LONG CARDINAL]    RETURNS [piecesOnFloor: PieceList] = {    -- Deletes a block of bytes of the given size starting at the    -- current index for the given stream.  This involves deleting    -- some number of pieces starting at CurrentPiece    -- (just truncating the first part of the last one), leaving them    -- in PiecesOnFloor.    OPEN ps;    pl, leftOver: PieceList;    sum, adj: LONG CARDINAL ¬ 0;    IF size = 0 THEN RETURN[NIL];    IF pieceOfMind = birdInEgg THEN SetUpScratch[ps];    BreakCurrentPieceAtPosition[ps];    pl ¬ currentPiece.next;    IF pl = NIL THEN ERROR Error[accessError];    WHILE (sum ¬ sum + pl.length) < size DO      IF (pl ¬ pl.next) = NIL THEN ERROR Error[accessError]; ENDLOOP;    adj ¬ size - (sum - pl.length);  -- = #chars to delete from last piece    IF adj = pl.length THEN leftOver ¬ pl.next    ELSE  -- remaining chars go in a new piece      leftOver ¬ pieceZone.NEW[        Piece ¬ [pl.source, pl.position + adj, pl.length - adj, pl.next]];    pl.next ¬ NIL;    pl.length ¬ adj;  -- deleted halfpiece    piecesOnFloor ¬ currentPiece.next;    currentPiece.next ¬ leftOver;    pieceOfMind ¬ birdInBush};  DestroyPieceObject: PROC [ps: PieceSource, freeObject: BOOLEAN ¬ TRUE] = {    original: TextSource.Handle ¬ ps.sources[original];    scratch: TextSource.Handle ¬ ps.sources[scratch];    IF ps = trashOwner THEN Selection.SetTrashBin[NIL, NIL, NIL];    IF original # NIL THEN [] ¬ original.actOn[original, destroy];    IF scratch # NIL THEN [] ¬ scratch.actOn[scratch, destroy];    IF ps.pieceTable # NIL THEN FreePieceList[ps.pieceTable];    IF ps.badMessage # NIL THEN z.FREE[@ps.badMessage];    IF freeObject THEN z.FREE[@ps] ELSE ps­ ¬ [procs: ps.procs]};  PieceAndOffsetForPosition: PROC [ps: PieceSource, position: Position]    RETURNS [p: LONG POINTER TO Piece, offset: LONG CARDINAL] = {    vStart: Position;    IF ps.isBad THEN RETURN[ps.pieceTable, MIN[position, ps.vLength]];    [p, vStart] ¬ PieceForPosition[ps, position];    IF position >= vStart THEN offset ¬ position - vStart ELSE ERROR;    IF p.length = offset AND position # ps.vLength THEN {      WHILE (p ¬ p.next) # NIL AND p.length = 0 DO ENDLOOP;      IF p = NIL THEN ERROR Error[accessError] ELSE offset ¬ 0}};  PieceForPosition: PROC [ps: PieceSource, pos: Position]    RETURNS [p: LONG POINTER TO Piece, vPos: Position] = {    -- Goes through Piecetable sequentially till sum of piece lengths    -- exceeds given index, then sets up CurrentPiece and related info.    -- Checks for exceptional cases when new index is within current    -- piece or when only one piece, for better performance.    p ¬ ps.currentPiece;    vPos ¬ ps.vStartOfCurrentPiece;    IF ps.pieceOfMind = birdInEgg THEN vPos ¬ pos    ELSE  -- ps.pieceOfMind= birdInBush or birdInHand      IF  -- Outside of current piece?        pos > ps.vStartOfCurrentPiece + ps.currentPiece.length        OR pos <= ps.vStartOfCurrentPiece AND ps.vStartOfCurrentPiece # 0 THEN {        -- scan from front, can do better later!        p ¬ ps.pieceTable;        vPos ¬ 0;        UNTIL vPos + p.length >= pos DO          vPos ¬ vPos + p.length;          IF (p ¬ p.next) = NIL THEN ERROR Error[accessError];          ENDLOOP}};  SetPosition: PROC [ps: PieceSource, pos: Position] = {    IF ps.pieceOfMind = birdInEgg THEN ps.byteOfCurrentPiece ¬ pos    ELSE { -- ps.pieceOfMind= birdInBush or birdInHand      [ps.currentPiece, ps.vStartOfCurrentPiece] ¬ PieceForPosition[ps, pos];      ps.byteOfCurrentPiece ¬ pos - ps.vStartOfCurrentPiece;      IF ps.currentPiece = ps.lastInScratch        AND ps.currentPiece.length = ps.byteOfCurrentPiece THEN        ps.pieceOfMind ¬ birdInHand      ELSE ps.pieceOfMind ¬ birdInBush}};  -- Utilities  BreakCurrentPieceAtPosition: PROC [ps: PieceSource] = {    -- Puts virtual stream index at end of CurrentPiece, by breaking    -- it in two if necessary    p1: PieceList;    cp: PieceList = ps.currentPiece;    IF ps.byteOfCurrentPiece = cp.length THEN RETURN;    p1 ¬ pieceZone.NEW[Piece ¬ cp­];    p1.position ¬ cp.position + ps.byteOfCurrentPiece;    p1.length ¬ cp.length - ps.byteOfCurrentPiece;    cp.length ¬ ps.byteOfCurrentPiece;    cp.next ¬ p1;    IF ps.lastInScratch = cp THEN { -- no longer ends right      ps.lastInScratch ¬ NIL; ps.pieceOfMind ¬ birdInBush}};  FreePieceList: PUBLIC PROC [pl: PieceList] = {    next: PieceList;    UNTIL pl = NIL DO next ¬ pl.next; pieceZone.FREE[@pl]; pl ¬ next; ENDLOOP};  FreshPieceTable: PROC [ps: PieceSource] RETURNS [PieceList] = {    RETURN[pieceZone.NEW[Piece ¬ [      source: ps.sources[original], position: 0,      length: ps.sources[original].getLength[ps.sources[original]], next: NIL]]]};  PieceListLength: PROC [pl: PieceList] RETURNS [chars: LONG CARDINAL] = {    temp: PieceList;    chars ¬ 0;    FOR temp ¬ pl, temp.next UNTIL temp = NIL DO      chars ¬ chars + temp.length ENDLOOP;    RETURN[chars]};  SetUpScratch: PROC [ps: PieceSource] = {    -- creates scratch source when pieceOfMind becomes # birdInEgg    originalName: LONG STRING = DiskSource.Info[ps.sources[original]].name;    IF ps.sources[scratch] # NIL THEN RETURN;    IF originalName = NIL THEN      ps.sources[scratch] ¬ StringSource.Create[NIL, TRUE]    ELSE {      scratchname: LONG STRING ¬ NIL;      String.AppendStringAndGrow[@scratchname, originalName, z, 2];      String.AppendStringAndGrow[@scratchname, "$$"L, z];      ps.sources[scratch] ¬ DiskSource.Create[        scratchname, append ! UNWIND => z.FREE[@scratchname]];      z.FREE[@scratchname]};    ps.pieceOfMind ¬ birdInBush};  -- TrashBin routines  Trash: TYPE = LONG POINTER TO TrashObject;  TrashObject: TYPE = RECORD [piece: PieceList, charsReadInPiece: LONG CARDINAL];  ConvertTrash: PROC [data: PieceList, target: Selection.Target]    RETURNS [LONG POINTER] = {    OPEN Selection;    SELECT target FROM      length => RETURN[z.NEW[LONG CARDINAL ¬ PieceListLength[data]]];      string => {        check: BOOLEAN [TRUE..(maxStringLength <= CARDINAL.LAST)] = TRUE;        length: LONG CARDINAL = PieceListLength[data];	str: LONG STRING ¬ NIL;	IF length > maxStringLength THEN RETURN[NIL]	ELSE {	  ENABLE UNWIND => z.FREE[@str];	  l: CARDINAL = CARDINAL[length];	  str ¬ String.MakeString[z, l];	  FOR p: PieceList ¬ data, p.next UNTIL p = NIL DO	    next: TextSource.Position ¬ p.position;	    UNTIL next >= p.position + p.length DO	      block: Environment.Block;	      [block, next] ¬ p.source.ReadText[	        position: next,		maxLength: MIN[str.maxlength - str.length, CARDINAL[p.length]],		class: none];	      IF block.startIndex >= block.stopIndexPlusOne THEN EXIT;	      FOR i: CARDINAL IN [block.startIndex..block.stopIndexPlusOne) DO	        String.AppendChar[str, VAL[block.blockPointer[i]]		  ! String.StringBoundsFault => GOTO stringFull]		ENDLOOP;	      ENDLOOP;	    REPEAT stringFull => NULL;	    ENDLOOP;	  RETURN[str]}};      source => {        d: Trash ¬ z.NEW[	  TrashObject ¬ [piece: data, charsReadInPiece: 0]];        s: Source ¬ z.NEW[	  SourceObject ¬ SourceObject[	    data: d, proc: ReadTrash, destroy: DestroySource]];        RETURN[s]};      ENDCASE => RETURN[NIL]};  ClearTrash: PROC [data: PieceList] = {FreePieceList[data]; trashOwner ¬ NIL};  ReadTrash: PROC [data: Trash, string: LONG STRING] = {    OPEN data;    block: Environment.Block;    start, next: Position;    charsToRead: CARDINAL;    charsLeftInPiece: LONG CARDINAL;    source: TextSource.Handle;    GetNextPieceIfNeeded: PROC [load: BOOLEAN] RETURNS [noMore: BOOLEAN] = {      DO        IF load THEN {piece ¬ piece.next; charsReadInPiece ¬ 0} ELSE load ¬ TRUE;        IF piece = NIL THEN RETURN[TRUE];        IF piece.length # 0 THEN EXIT;        ENDLOOP;      source ¬ piece.source;      charsLeftInPiece ¬ piece.length - charsReadInPiece;      RETURN[FALSE]};    string.length ¬ 0;    IF GetNextPieceIfNeeded[FALSE] THEN RETURN;    DO      IF charsReadInPiece = piece.length THEN        IF GetNextPieceIfNeeded[TRUE] THEN RETURN;      charsToRead ¬ Inline.LowHalf[        MIN[string.maxlength - string.length, charsLeftInPiece]];      IF charsToRead = 0 THEN EXIT;      start ¬ piece.position + charsReadInPiece;      [block, next] ¬ source.readText[source, start, charsToRead, none];      string.length ¬        string.length + ByteBlt.ByteBlt[          from: block,          to: [LOOPHOLE[@string.text], string.length, string.maxlength]];      charsReadInPiece ¬ charsReadInPiece + (next - start);      charsLeftInPiece ¬ charsLeftInPiece - (next - start);      ENDLOOP};  DestroySource: PROC [source: Selection.Source] = {    z.FREE[@source.data]; z.FREE[@source]};  FullName: PROC [name: LONG POINTER TO LONG STRING, file: MFile.Handle] = {    fullName: STRING ¬ [MFile.maxNameLength];    MFile.GetFullName[file: file, name: fullName];    String.Replace[name, fullName, z]};      NameMatch: PROC [fullName, name: LONG STRING] RETURNS [same: BOOLEAN] = {    nss: String.SubStringDescriptor ¬ [      base: name, offset: 0, length: name.length];    fss: String.SubStringDescriptor;    i: CARDINAL;    IF String.EquivalentString[name, fullName] THEN RETURN [TRUE];    FOR i DECREASING IN [0..fullName.length) DO      IF fullName[i] = '> THEN {i ¬ i + 1; EXIT};      REPEAT FINISHED => i ¬ 0;      ENDLOOP;    fss ¬ [base: fullName, offset: i, length: fullName.length-i];    same ¬ String.EquivalentSubString[@nss, @fss]};      END.
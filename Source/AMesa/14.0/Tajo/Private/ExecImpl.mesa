-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved. -- ExecImpl.mesa;--   LXR    ,	 20-Dec-83 11:35:21--   RXJ     ,	 20-Dec-83  9:31:44--   RXR   ,	 11-Feb-83 17:16:00--   CXH   ,	 24-Feb-83 14:36:31--   AXD    ,	 19-Apr-84 12:54:19--   DWR   ,	  3-Oct-84 17:33:09  repair for overzealous FixArrowing--   KAM     	  9-Oct-84 21:35:13DIRECTORY  Ascii USING [BS, ControlC, ControlW, ControlX, CR, DEL, ESC, LF, NUL, TAB],  CmFile USING [Error, FreeString, Line],  Event USING [aboutToSwap, swapping],  EventTypes USING [    abortSession, aboutToAbortSession, aboutToBoot, aboutToBootPhysicalVolume,     aboutToResume, bootPhysicalVolumeCancelled, newSession, resumeDebuggee,     resumeSession, swapCancelled],  Exec USING [    AddCommand, CheckAbortProc, CheckForAbort, ExecProc, FreeTokenString, GetChar,    GetToken, Handle, LookupCommand, Object, OutputProc],  ExecInternal USING [    ExecuteFromHandle, ExpandESC, IsAlphaNumeric, IsCommandChar, IsFileChar,    IsntAlphaNumeric, Object, Twiddles, Write, XferQWhile],  Expand USING [ExpandQ, ExpandQueues, UnknownCommandFile],  Format USING [CR, Line, StringProc],  Heap USING [systemZone],  HeraldWindow USING [AppendMessage],  MFile USING [AppendErrorMessage, Error, Object],  PhysicalVolume USING [    GetAttributes, GetContainingPhysicalVolume, Handle, maxNameLength],  Process USING [    GetPriority, Priority, priorityBackground, priorityForeground, priorityNormal,    SetPriority],  Queue USING [    Concatenate, Copy, Count, Empty, EmptyQ, GetF, GetR, Init, IsEmpty,    PutF, PutR, Q, QFToString, QHead, ShortQ, StringToQR],  Runtime USING [GetBcdTime],  String USING [    AppendString, CopyToNewString, StringLength],  Supervisor USING [    AddDependency, AgentProcedure, CreateSubsystem, EnumerationAborted,    SubsystemHandle],  Time USING [Append, Unpack],  TTY USING [    BlinkDisplay, CharStatus, GetChar, GetEditedString, Handle, LineOverflow,    PutChar, PutCR, PutString, RemoveCharacter, ResetUserAbort],  UserTerminal USING [BlinkDisplay],  Version USING [Append],  Volume USING [GetLabelString, maxNameLength, systemID],  VersionExtras USING [AppendCopyright],  Window USING [Handle, Object];ExecImpl: MONITOR  IMPORTS    CmFile, Event, Exec, ExecInternal, Expand, Format, Heap, HeraldWindow, MFile,    PhysicalVolume, Process, Queue, Runtime, String, Supervisor, Time, TTY,    UserTerminal, Version, VersionExtras, Volume  EXPORTS Exec, ExecInternal, Expand =  BEGIN  AbortCommand: ERROR = CODE;  averageStringSize: CARDINAL = 60;  extra:  CARDINAL = 100;  CR: CHARACTER = Ascii.CR;  CondSP: CHARACTER = 200C;  Q: TYPE = Queue.Q;  ShortQ: TYPE = Queue.ShortQ;  ExpandQ: PUBLIC TYPE = Queue.ShortQ;  z: UNCOUNTED ZONE = Heap.systemZone;  execCount: CARDINAL ¬ 0;  addExec: ENTRY PROCEDURE = {    execCount ¬ execCount + 1; subsystemRunning ¬ subsystemRunning + 1};  removeExec: ENTRY PROCEDURE = {    execCount ¬ execCount - 1; subsystemRunning ¬ subsystemRunning - 1};  swapDone: CONDITION;  subsystemRunning: CARDINAL ¬ 0;  swapping: BOOLEAN ¬ FALSE;  aboutToSwapAgent: Supervisor.SubsystemHandle = Supervisor.CreateSubsystem[    AboutToSwap];  swappingAgent: Supervisor.SubsystemHandle = Supervisor.CreateSubsystem[    Swapping];  StartSubsystem: ENTRY PROCEDURE = {    IF swapping THEN WAIT swapDone; subsystemRunning ¬ subsystemRunning + 1};  StopSubsystem: ENTRY PROCEDURE = {subsystemRunning ¬ subsystemRunning - 1};  WaitForSwap: ENTRY PROCEDURE = {IF swapping THEN WAIT swapDone};  AboutToSwap: ENTRY Supervisor.AgentProcedure =    BEGIN    ENABLE UNWIND => NULL;    SELECT event FROM      EventTypes.aboutToAbortSession, EventTypes.aboutToResume,      EventTypes.aboutToBoot, EventTypes.aboutToBootPhysicalVolume => {        IF subsystemRunning # 0 THEN {          HeraldWindow.AppendMessage["Executive busy: aborting swap."L];          ERROR Supervisor.EnumerationAborted};        swapping ¬ TRUE};      ENDCASE;    END;  Swapping: ENTRY Supervisor.AgentProcedure =    BEGIN    ENABLE UNWIND => NULL;    SELECT event FROM      EventTypes.newSession, EventTypes.resumeSession,       EventTypes.swapCancelled, EventTypes.bootPhysicalVolumeCancelled => {        swapping ¬ FALSE; BROADCAST swapDone};      EventTypes.abortSession, EventTypes.resumeDebuggee => swapping ¬ TRUE;      ENDCASE;    END;  Handle: PUBLIC TYPE = LONG POINTER TO Object;  Object: PUBLIC TYPE = ExecInternal.Object;  PrintGreeting: PROCEDURE [exec: Handle] =    BEGIN    s: STRING ¬ [100];    write: Format.StringProc = exec.output;    logVol: STRING = [Volume.maxNameLength];    physVol: STRING = [PhysicalVolume.maxNameLength];    VersionExtras.AppendCopyright[s];    Format.Line[write, s];    s.length ¬ 0;    String.AppendString[s, "Executive "L];    Version.Append[s];    String.AppendString[s, " of "L];    Time.Append[s, Time.Unpack[Runtime.GetBcdTime[]]];    write[s];    Volume.GetLabelString[Volume.systemID, logVol];    [] ¬ PhysicalVolume.GetAttributes[      PhysicalVolume.GetContainingPhysicalVolume[Volume.systemID], physVol];    write[" on ["L];    write[physVol];    write["]<"L];    write[logVol];    Format.Line[write, ">"L];    END;  GNC: PROCEDURE [q: ShortQ, exec: Handle] RETURNS [c: CHARACTER] =    BEGIN    IF ~Queue.IsEmpty[q] THEN RETURN[Queue.GetF[q]];    c ¬ TTY.GetChar[exec.w];    TTY.ResetUserAbort[exec.w];    RETURN[c];    END;  DeleteWord: PROCEDURE [exec: Handle, comQ: Queue.ShortQ] =    BEGIN OPEN Queue;    trashQ: QHead ¬ Init[];    ExecInternal.XferQWhile[      GetR, PutR, comQ, PutR, @trashQ, ExecInternal.IsntAlphaNumeric];     ExecInternal.XferQWhile[      GetR, PutR, comQ, PutR, @trashQ, ExecInternal.IsAlphaNumeric];    TTY.RemoveCharacter[exec.w, Count[@trashQ]];    Empty[@trashQ];    END;       MapQ: PROCEDURE [    q: ShortQ, p: PROCEDURE [TTY.Handle, CHARACTER], w: TTY.Handle] =    BEGIN    tQ: Queue.QHead ¬ Queue.Init[];    c: CHARACTER;     DO      c ¬ Queue.GetF[q ! Queue.EmptyQ => EXIT];       Queue.PutR[@tQ, c]; p[w, c];       ENDLOOP;    q­ ¬ tQ;    RETURN    END;  ReType: PROCEDURE [q: ShortQ, exec: Handle] = {    TTY.PutCR[exec.w]; MapQ[q, ExecInternal.Write, exec.w]};  Noop: PROCEDURE [TTY.Handle, UNSPECIFIED] = {};  CreateExec: PUBLIC PROCEDURE [    tty: TTY.Handle, CheckIfDeactivated: Exec.CheckAbortProc ¬ NIL,    NoteNewLine: PROCEDURE ¬ NIL] =    BEGIN    commandLineTrashed: BOOLEAN ¬ FALSE;    querying: BOOLEAN ¬ FALSE;    Output: Format.StringProc = BEGIN TTY.PutString[tty, s]; END;        FlushPendingInput: PROCEDURE [h: Handle] RETURNS [c: CHARACTER] =      BEGIN      TTY.ResetUserAbort[exec.w];      commandLineTrashed ¬ TRUE;      c ¬ Exec.GetChar[h];      WHILE c # Ascii.NUL DO c ¬ Exec.GetChar[h]; ENDLOOP;      Queue.Empty[h.remQ];      Queue.Empty[h.comQ];      c ¬ Ascii.DEL;  --will force processing of command line to stop      END;    ReadEditedChars: PROCEDURE [h: Handle, fromQ: ShortQ, prompt: STRING] =      BEGIN OPEN Queue;      toQ: ShortQ = h.comQ;      cmd: LONG STRING ¬ NIL;      breakCh: CHARACTER;      w: PROCEDURE [TTY.Handle, UNSPECIFIED] ¬        IF prompt = NIL THEN Noop ELSE ExecInternal.Write;      Prompt: PROCEDURE = INLINE {        w[h.w, prompt]; IF NoteNewLine # NIL THEN NoteNewLine[]};      commandLineTrashed ¬ FALSE;      Prompt[];      breakCh ¬ GNString[fromQ, toQ, h];      DO        BEGIN        SELECT breakCh FROM          CR => {            PutR[toQ, breakCh];            RETURN};          Ascii.NUL, Ascii.LF => NULL;          Ascii.BS => {	    [] ¬ GetR[toQ ! EmptyQ => GOTO none];	    TTY.RemoveCharacter[h.w];	    EXITS none => NULL};          Ascii.ControlW => DeleteWord[h, toQ];          136C, '', 255C => { -- uparrows or quotes	    TTY.PutChar[h.w, breakCh];	    PutR[toQ, breakCh];	    breakCh ¬ GNC[fromQ, h];	    TTY.PutChar[h.w, breakCh];	    PutR[toQ, breakCh]};          Ascii.ControlX => {            q: QHead ¬ toQ­;            toQ­ ¬ Init[];            PutR[@q, CR];            Expand.ExpandQueues[              toQ, @q, TRUE !              Expand.UnknownCommandFile =>                RESUME [GetCommandFileFromUser[h, name]];              MFile.Error => {	        msg: STRING ¬ [100];	        MFile.AppendErrorMessage[msg, code, file];		w[h.w, msg]; w[h.w, CR];		Empty[@q];		GOTO startOver};	      UNWIND => Empty[@q]];            [] ¬ GetR[toQ];  -- remove CR            w[h.w, CR];            ReType[toQ, h]};          Ascii.ControlC => {w[h.w, breakCh]; ERROR AbortCommand};          Ascii.DEL => {            Empty[toQ];            IF ~commandLineTrashed THEN w[h.w, " XXX"L];            IF ~querying THEN {w[h.w, CR]; Prompt[]};            commandLineTrashed ¬ querying ¬ FALSE};          Ascii.ESC => {            remQ: QHead ¬ Init[];            tempQ: QHead ¬ Init[];	    -- remove and save last token            ExecInternal.XferQWhile[              GetR, PutR, toQ, PutF, @tempQ, ExecInternal.IsFileChar];	    Copy[from: @tempQ, to: toQ]; -- put last token back            IF ExecInternal.ExpandESC[@tempQ, @remQ] # 1 THEN	      TTY.BlinkDisplay[h.w];            --PutR[@remQ, CondSP];            Empty[@tempQ];            -- remQ now contains second part of command            fromQ­ ¬ Concatenate[fromQ, @remQ]};          Ascii.TAB, '? => {            OPEN Queue;            cmdProc: Exec.ExecProc;            copyQ: QHead ¬ Init[];            myQ: QHead ¬ toQ­;	    toQ­ ¬ Init[];            [, cmdProc, ] ¬ Exec.LookupCommand["?"L];            w[h.w, '?];            Queue.Copy[to: @copyQ, from: @myQ];            ExecInternal.XferQWhile[              GetR, PutR, @myQ, PutF, toQ, ExecInternal.IsCommandChar];            Queue.Empty[@myQ];            Queue.PutF[toQ, ' ];            Queue.PutF[toQ, '?];            ExecInternal.Twiddles[h];            [] ¬ cmdProc[ -- N.B. toQ = h.comQ              h !              ABORTED => {                -- set commandLineTrashed so next call to GNString to                 -- will flush pending input.                -- this is for the case when '? is in an aborted stuff                commandLineTrashed ¬ TRUE; querying ¬ TRUE; CONTINUE}];            ExecInternal.Twiddles[h];            Queue.Empty[toQ];            IF breakCh = '? THEN {toQ­ ¬ copyQ; copyQ ¬ Init[]}	    ELSE Queue.Empty[@copyQ];            Prompt[];            MapQ[toQ, w, h.w]};          <<CondSP => {            breakCh ¬ GNC[fromQ, h];            IF ExecInternal.IsFileChar[breakCh] AND breakCh # '$ THEN {              w[h.w, Ascii.SP]; PutR[toQ, Ascii.SP]};            PutF[fromQ, breakCh];	    LOOP}; this code dose not work; feature withdrawn>>          ENDCASE => NULL;        breakCh ¬ GNString[fromQ, toQ, h];	EXITS startOver => {	  Empty[toQ];	  Prompt[];	  breakCh ¬ GNString[fromQ, toQ, h]};	END;        ENDLOOP;      END;    GNString: PROCEDURE [q, toQ: ShortQ, exec: Handle]      RETURNS [lastRead: CHARACTER ¬ Ascii.NUL] =      BEGIN      Filter: PROCEDURE [c: CHARACTER] RETURNS [status: TTY.CharStatus] =        BEGIN        IF Exec.CheckForAbort[exec] THEN lastRead ¬ FlushPendingInput[exec];        SELECT c FROM          CR, Ascii.NUL, Ascii.LF, Ascii.BS, Ascii.ControlW, Ascii.ControlX,            Ascii.ControlC, Ascii.DEL, Ascii.ESC, Ascii.TAB, '?, 136C, 255C, ''<<, CondSP>> =>            status ¬ stop;          ENDCASE => status ¬ ok;        END;      GNStringFromQueue: PROCEDURE =        BEGIN	c: CHARACTER;	tempQ: Queue.QHead ¬ Queue.Init[];        DO          c ¬ Queue.GetF[q ! Queue.EmptyQ => RESUME];          IF Filter[c] = stop OR c = '; THEN {            MapQ[@tempQ, ExecInternal.Write, exec.w];	    toQ­ ¬ Queue.Concatenate[toQ, @tempQ];	    lastRead ¬ c; RETURN};	  Queue.PutR[@tempQ, c];          ENDLOOP;        END;      GNStringFromWindow: PROCEDURE =        BEGIN        commandLine: LONG STRING ¬ z.NEW[StringBody [averageStringSize]];        lastRead ¬ TTY.GetEditedString[          h: exec.w, s: commandLine, t: Filter !          TTY.LineOverflow => {            ns ¬ String.CopyToNewString[s, z, extra];            commandLine ¬ ns;            z.FREE[@s];            RESUME [ns]};	  UNWIND => z.FREE[@commandLine]];	Queue.StringToQR[commandLine, toQ];	z.FREE[@commandLine];        END;      IF commandLineTrashed THEN RETURN[FlushPendingInput[exec]];      IF Queue.IsEmpty[q] THEN GNStringFromWindow[]         ELSE {GNStringFromQueue[]; IF lastRead = '; THEN lastRead ¬ CR};      IF Exec.CheckForAbort[exec] THEN lastRead ¬ FlushPendingInput[exec];      TTY.ResetUserAbort[exec.w];      END;    GetCommandFileFromUser: PROCEDURE [h: Handle, name: LONG STRING]      RETURNS [result: LONG STRING] =      BEGIN OPEN Queue;      Output: Format.StringProc = h.output;      fakeQ: QHead ¬ Init[];      tempQ: QHead ¬ Init[];      comQ: ShortQ;      Queue.Empty[@fakeQ];      Format.CR[Output];      Output["File name """L];      Output[name];      Output[""" unknown. Type what it would contain."L];      Format.CR[Output];      comQ ¬ h.comQ; h.comQ ¬ @tempQ;      ReadEditedChars[h, @fakeQ, ">>"L ! UNWIND => {        Queue.Empty[@tempQ]; h.comQ ¬ comQ}];      h.comQ ¬ comQ;      [] ¬ GetR[@tempQ]; -- remove CR      result ¬ z.NEW[StringBody [Count[@tempQ]]];      QFToString[@tempQ, result];      END;    GetCommand: PROCEDURE [h: Handle] RETURNS [gotCommand: BOOLEAN ¬ TRUE] =      BEGIN OPEN Queue;      Output: Format.StringProc = h.output;      StopSubsystem[];  -- we aren't running while collecting characters      DO        ENABLE UNWIND => StartSubsystem[];        WaitForSwap[];        Empty[h.comQ];        Format.CR[Output];        ReadEditedChars[          h, h.remQ, ">"L ! AbortCommand => {Empty[h.remQ]; LOOP}];        h.remQ­ ¬ Concatenate[h.comQ, h.remQ];        WaitForSwap[];        Expand.ExpandQueues[          toQ: h.comQ, fromQ: h.remQ, mask: [TRUE, TRUE, TRUE, skip, NIL] !          Expand.UnknownCommandFile =>            RESUME [              GetCommandFileFromUser[                h, name ! AbortCommand => {Empty[h.remQ]; LOOP}]];          MFile.Error => {	    msg: STRING ¬ [100];	    MFile.AppendErrorMessage[msg, code, file];            Format.Line[Output, msg];            Empty[h.remQ];            LOOP}];        EXIT        ENDLOOP;      StartSubsystem[];  -- returns to caller, who will run the subsystem      END;    remQHead: Queue.QHead ¬ Queue.Init[];    comQHead: Queue.QHead ¬ Queue.Init[];    exec: ExecInternal.Object ¬ [      comQ: @comQHead, remQ: @remQHead, output: Output];    h: Handle ¬ @exec;    exec.w ¬ tty;    exec.checkForAbort ¬ NIL;  -- results in call to Exec.CheckForAbort    addExec[];    SetPriorityInternal[];    PrintGreeting[@exec];    [] ¬ ExecInternal.ExecuteFromHandle[      h, CheckIfDeactivated, GetCommand ! ABORTED => CONTINUE;      UNWIND => {removeExec[]; Queue.Empty[exec.remQ]; Queue.Empty[exec.comQ]}];    removeExec[];    Queue.Empty[exec.remQ];    Queue.Empty[exec.comQ];    END;  SetPriorityInternal: PROCEDURE [priority: LONG STRING ¬ NIL] =    BEGIN    value: LONG STRING ¬ NIL;    currentPriority: Process.Priority ¬ Process.GetPriority[];    Error: PROCEDURE [msg: LONG STRING] = {      UserTerminal.BlinkDisplay[]; HeraldWindow.AppendMessage[msg]};    BEGIN    ENABLE UNWIND => value ¬ CmFile.FreeString[value];    IF priority = NIL THEN {  -- didn't come from commandline, look in user.cm      value ¬ CmFile.Line[        "User.cm", "Executive"L, "Priority"L !        CmFile.Error => {          Error["Unable to process User.cm to get Executive priority. "L];          value ¬ NIL;          CONTINUE}];      priority ¬ value};    IF priority # NIL THEN      SELECT TRUE FROM        String.StringLength[priority] # 1 => Error["Unknown priority. "L];        priority[0] = '1 =>          IF currentPriority # Process.priorityBackground THEN            Process.SetPriority[Process.priorityBackground];        priority[0] = '2 =>          IF currentPriority # Process.priorityNormal THEN            Process.SetPriority[Process.priorityNormal];        priority[0] = '3 =>          IF currentPriority # Process.priorityForeground THEN            Process.SetPriority[Process.priorityForeground];        ENDCASE => Error["Unknown priority for Executive."L]    ELSE Process.SetPriority[Process.priorityNormal];    <<priority = NIL => SetPriorityInternal was called       when the Executive was created and there was no User.cm entry        for Priority >>    value ¬ CmFile.FreeString[value];    END;    END;  SetPriority: Exec.ExecProc =    BEGIN    Write: Format.StringProc = Exec.OutputProc[h];    token, switches: LONG STRING ¬ NIL;    Cleanup: PROCEDURE =      BEGIN      token ¬ Exec.FreeTokenString[token];      switches ¬ Exec.FreeTokenString[switches];      END;    BEGIN    ENABLE UNWIND => Cleanup[];    [token, switches] ¬ Exec.GetToken[h];    IF String.StringLength[token] # 1      OR (token[0] # '1 AND token[0] # '2 AND token[0] # '3) THEN {      UserTerminal.BlinkDisplay[]; Write["Bad priority! "L]}    ELSE SetPriorityInternal[token];    Cleanup[];    END;    END;  HelpSetPriority: Exec.ExecProc =    BEGIN    Write: Format.StringProc = Exec.OutputProc[h];    Write[      "The SetPriority command allows you to change the process priority of the Executive.Syntax for the command line is:    SetPriority <1, 2 or 3> where 1 is background priority, 2 is normal priority and 3 is foreground priority. "L];    END;  Init: PROCEDURE =    BEGIN    Supervisor.AddDependency[      client: aboutToSwapAgent, implementor: Event.aboutToSwap];    Supervisor.AddDependency[client: swappingAgent, implementor: Event.swapping];    Exec.AddCommand[      name: "SetPriority.~"L, proc: SetPriority, help: HelpSetPriority];    END;  Init[]  END...
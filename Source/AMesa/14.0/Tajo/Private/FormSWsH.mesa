-- Copyright (C) 1981, 1982  by Xerox Corporation. All rights reserved. -- file: FormSWsH.mesa - last edited:-- SXW    on May 9, 1980 1:32 PM-- Mark on Aug 8, 1980 3:55 PM-- SEH on 15-Dec-81 14:56:36-- BGY      on  2-Nov-82 13:31:40DIRECTORY  Context,  Inline USING [LongDiv, LongMult],  FormSW USING [line0, NeededHeight],  FormSWOps USING [    AdjustAllItemPlaces, BitY, context, dijectMargin, FindContext, fontHeight,    LockContextProcType, PContext, RealActOnCaret, SlideYBand],  Scrollbar USING [    Direction, Percent, ScrollbarProcType, ScrollProcType, Type],  TextDisplay USING [noPlace],  Window USING [Box, GetBox, Handle, Place, Validate];FormSWsH: MONITOR LOCKS myContext.lock USING myContext: FormSWOps.PContext  IMPORTS Context, Inline, FormSW, FormSWOps, Window  EXPORTS FormSWOps  =  BEGIN  -- Global Data and STUFF  --FNRs  JFirstFNR: PUBLIC PROC [window: Window.Handle] = {    ScrollVertical[window, relative, 0]};  JLastFNR: PUBLIC PROC [window: Window.Handle] = {    ScrollVertical[window, relative, 99]};  -- Scrolling  VerticalScrollbar: PUBLIC Scrollbar.ScrollbarProcType =    BEGIN    [box, offset, portion] ¬ HorizontalVerticalScrollbar[window, vertical];    END;  HorizontalVerticalScrollbar: PROCEDURE [sw: Window.Handle, type: Scrollbar.Type]    RETURNS [box: Window.Box, offset, portion: Scrollbar.Percent] =    BEGIN    myContext: FormSWOps.PContext = FormSWOps.FindContext[sw];    LockedHVScrollbar: ENTRY FormSWOps.LockContextProcType =       BEGIN       ENABLE UNWIND => NULL;      origin: INTEGER =        (IF type = horizontal THEN myContext.originPlace.x 	 ELSE myContext.originPlace.y);      swDim: INTEGER =        (IF type = horizontal THEN Window.GetBox[sw].dims.w 	ELSE Window.GetBox[sw].dims.h);      maxPoint: INTEGER ¬ 0;      thisPoint: INTEGER;      i: CARDINAL;      FOR i DECREASING IN [0..LENGTH[myContext.items]) DO        IF myContext.items[i].flags.invisible THEN LOOP;        thisPoint ¬          (IF type = horizontal THEN           myContext.dijects[i].box.place.x + myContext.dijects[i].box.dims.w           ELSE myContext.dijects[i].box.place.y + 	     myContext.dijects[i].box.dims.h);        IF thisPoint > maxPoint THEN maxPoint ¬ thisPoint;        ENDLOOP;      IF origin <= 0 THEN        BEGIN        maxPointMinusOrigin: INTEGER = maxPoint - origin;        IF maxPointMinusOrigin # 0 THEN          BEGIN          offset ¬ MIN[	    100, Inline.LongDiv[	      Inline.LongMult[-origin, 100], maxPointMinusOrigin]];          portion ¬ MIN[	    100, Inline.LongDiv[	      Inline.LongMult[swDim, 100], maxPointMinusOrigin]];          END;        END;      END;    box ¬ [[0, 0], Window.GetBox[sw].dims];    offset ¬ 0;    portion ¬ 100;    IF myContext # NIL THEN LockedHVScrollbar[myContext];    END;  InternalScrollVertical: PUBLIC PROCEDURE [    myContext: FormSWOps.PContext, direction: Scrollbar.Direction,    offset: INTEGER] =    BEGIN     -- The thing to remember here is that for each parameter item, the    -- start place has been adjusted by the old originPlace.  Since the    -- scrollbar uses an absolute reference frame, these relative start places    -- must be converted to absolute ones (hence itemY).    LockedScrollVertical: ENTRY FormSWOps.LockContextProcType =       BEGIN       ENABLE UNWIND => NULL;      oldPlaceY: INTEGER ¬ myContext.originPlace.y;      i: CARDINAL;      roundedY, itemY: INTEGER;      smallestDiff: CARDINAL ¬ LAST[CARDINAL];      FormSWOps.RealActOnCaret[myContext, clear];      SELECT direction FROM        forward => myContext.originPlace.y ¬ myContext.originPlace.y - offset;        backward => myContext.originPlace.y ¬ myContext.originPlace.y + offset;        relative => myContext.originPlace.y ¬ -offset;        ENDCASE => ERROR;      roundedY ¬ myContext.originPlace.y ¬ MIN[0, myContext.originPlace.y];      FOR i IN [0..LENGTH[myContext.items]) DO  -- Find the closest item        IF myContext.items[i].flags.invisible THEN LOOP;        itemY ¬ myContext.dijects[i].box.place.y - oldPlaceY;        WITH item: myContext.items[i] SELECT FROM          string =>            IF item.string­ # NIL THEN              BEGIN              startY: INTEGER = myContext.dijects[i].box.place.y;              relativeY: INTEGER = oldPlaceY - myContext.originPlace.y;              IF startY <= relativeY                AND relativeY <= startY + myContext.dijects[i].box.dims.h THEN                BEGIN  -- Scroll to closest line inside string                bitY: INTEGER = relativeY + FormSWOps.dijectMargin - startY;                line: INTEGER = bitY/FormSWOps.fontHeight;                roundedY ¬ -(itemY + bitY - (bitY MOD FormSWOps.fontHeight));                IF line > 0 THEN roundedY ¬ roundedY - FormSWOps.dijectMargin;                EXIT;                END;              END;          ENDCASE;        IF ABS[myContext.originPlace.y + itemY] < smallestDiff THEN          BEGIN smallestDiff ¬ ABS[myContext.originPlace.y + itemY]; 	  roundedY ¬ -itemY; 	  END;        ENDLOOP;      myContext.originPlace.y ¬        IF -roundedY <= FormSWOps.BitY[FormSW.line0] THEN 0        ELSE roundedY + FormSWOps.dijectMargin;      IF myContext.originPlace.y # oldPlaceY THEN        BEGIN        delta: INTEGER ¬ myContext.originPlace.y - oldPlaceY;        FormSWOps.AdjustAllItemPlaces[myContext, 0, delta];        myContext.insertion.textInsert.place ¬ TextDisplay.noPlace;        FormSWOps.SlideYBand[myContext, 0, delta];        END;      END;    IF myContext # NIL THEN      BEGIN LockedScrollVertical[myContext]; Window.Validate[myContext.sw]; END;    END;  ScrollVertical: PUBLIC Scrollbar.ScrollProcType =    BEGIN     offset: INTEGER ¬ Inline.LongDiv[      Inline.LongMult[      (IF direction = relative THEN FormSW.NeededHeight[window].current       ELSE Window.GetBox[window].dims.h), percent], 100];    myContext: FormSWOps.PContext = FormSWOps.FindContext[window];    InternalScrollVertical[myContext, direction, offset];    END;  -- Main Line code  END.  -- of FormSWsH.mesa    HorizontalScrollbar: PUBLIC Scrollbar.ScrollbarProcType =    BEGIN    [box, offset, portion] ¬ HorizontalVerticalScrollbar[window, horizontal];    END;      ScrollHorizontal: PUBLIC Scrollbar.ScrollProcType =    BEGIN     offset: INTEGER = Inline.LongDiv[Inline.LongMult[Window.GetBox[window].dims.w,     percent], 100];    myContext: FormSWOps.PContext = FormSWOps.FindContext[window];    repaint: BOOLEAN;            LockedScrollHorizontal: ENTRY FormSWOps.LockContextProcType = 	BEGIN 	oldPlaceX: INTEGER ¬ myContext.originPlace.x;	SELECT direction FROM	  forward => myContext.originPlace.x ¬ myContext.originPlace.x - offset;	  backward => myContext.originPlace.x ¬ myContext.originPlace.x + offset;	  relative => myContext.originPlace.x ¬ -offset;	  ENDCASE => ERROR;	myContext.originPlace.x ¬ MIN[0, myContext.originPlace.x];	repaint ¬ (oldPlaceX # myContext.originPlace.x);	END;	    IF myContext # NIL THEN      BEGIN      LockedScrollHorizontal[myContext];      IF repaint THEN	FormSW.Display[window];      END;    END;    
-- Copyright (C) 1981, 1982, 1983  by Xerox Corporation. All rights reserved. -- file: FormSWsC.mesa - last edited:-- SXW   	10-Jul-81  0:22:56 -- JGS		18-Aug-81 13:55:04 -- Mark		May 12, 1980 2:20 PM -- BGY     	 6-Dec-82 16:52:06 -- AXD    	 4-Nov-83 14:23:27 -- DisplayProc and item adjustment utilitiesDIRECTORY  Context,  Display USING [Shift, White],  FormSW USING [Display],  FormSWOps USING [    DijectSelection, FindContext, InvertItem, LockContextProcType,     PContext, RealActOnCaret, TagLength],  TextData USING [Selection, SelectionObject],  TextDisplay USING [Bold, Redisplay],  ToolWindow USING [DisplayProcType, DrawRectangle],  Window USING [Box, GetBox, Handle, InvalidateBox];FormSWsC: MONITOR LOCKS myContext.lock USING myContext: FormSWOps.PContext  IMPORTS Context, Display, FormSW, FormSWOps, TextDisplay, ToolWindow, Window  EXPORTS FormSWOps =  BEGIN  -- Subwindow display proc and support  DisplayProc: PUBLIC ToolWindow.DisplayProcType = {     myContext: FormSWOps.PContext = FormSWOps.FindContext[window];    DoAnInvalidBox: PROC [wh: Window.Handle, box: Window.Box] = {      LockedDisplayProc: ENTRY FormSWOps.LockContextProcType = {         ENABLE UNWIND => NULL;	FormSWOps.RealActOnCaret[myContext, clear];	Display.White[wh, box];        FOR i: CARDINAL IN [0..myContext.items.LENGTH) DO 	  OPEN di: myContext.dijects[i];          IF myContext.items[i].flags.invisible THEN LOOP;          IF di.box.place.y > myContext.sw.GetBox.dims.h THEN EXIT;          IF di.box.place.y + di.box.dims.h >= 0 THEN {            boxToFill: Window.Box = IntersectBoxes[box, di.box];            IF boxToFill.dims.w > 0 AND boxToFill.dims.h > 0 THEN {               dummySelect: TextData.SelectionObject;              select: TextData.Selection;              WITH item: myContext.items[i] SELECT FROM	        boolean  => select ¬ NIL;		ENDCASE  =>		  select ¬ FormSWOps.DijectSelection[myContext, i, @dummySelect];              [] ¬ TextDisplay.Redisplay[LOOPHOLE[@di], boxToFill, select];              IF myContext.items[i].flags.drawBox THEN                ToolWindow.DrawRectangle[myContext.sw, di.box, 1];              IF myContext.options.boldTags THEN                TextDisplay.Bold[                  LOOPHOLE[@di], 0, FormSWOps.TagLength[di.source, TRUE], select];              WITH item: myContext.items[i] SELECT FROM	        boolean => IF item.switch­ THEN FormSWOps.InvertItem[myContext,i];		ENDCASE}};          ENDLOOP};      LockedDisplayProc[myContext]};    IF myContext = NIL OR ~myContext.validState THEN FormSW.Display[window]    ELSE DoAnInvalidBox[window, [[0,0], window.GetBox.dims]]};  IntersectBoxes: PUBLIC PROC [one, two: Window.Box]    RETURNS [intersection: Window.Box] = {    intersection.place ¬ [      x: MAX[one.place.x, two.place.x], y: MAX[one.place.y, two.place.y]];    intersection.dims ¬ [      w: MIN[one.place.x + one.dims.w, two.place.x + two.dims.w],      h: MIN[one.place.y + one.dims.h, two.place.y + two.dims.h]];    intersection.dims ¬ [      w: IF intersection.place.x < intersection.dims.w THEN        intersection.dims.w - intersection.place.x ELSE 0,      h: IF intersection.place.y < intersection.dims.h THEN        intersection.dims.h - intersection.place.y ELSE 0]};  -- Utilities  AdjustAllItemPlaces: PUBLIC PROC [    myContext: FormSWOps.PContext, x, y: INTEGER] = {    FOR i: CARDINAL IN [0..myContext.items.LENGTH) DO      OPEN mdib: myContext.dijects[i].box;      IF myContext.items[i].flags.invisible THEN LOOP;      mdib.place ¬ [x: mdib.place.x + x, y: mdib.place.y + y];      ENDLOOP};  AdjustItemPlaces: PUBLIC PROC [    myContext: FormSWOps.PContext, index: CARDINAL, fixup: INTEGER] = {    AdjustSucceedingItemPlaces[      myContext, FirstLargerYItem[myContext, index], fixup]};  AdjustSucceedingItemPlaces: PUBLIC PROC [    myContext: FormSWOps.PContext, firstBigger: CARDINAL, fixup: INTEGER] = {     FOR i: CARDINAL IN [firstBigger..LENGTH[myContext.items]) DO      IF myContext.items[i].flags.invisible THEN LOOP;      myContext.dijects[i].box.place.y ¬ myContext.dijects[i].box.place.y + fixup;      ENDLOOP};  FirstLargerYItem: PROC [myContext: FormSWOps.PContext, index: CARDINAL]    RETURNS [firstBigger: CARDINAL] = {    -- Returns LENGTH[myContext.items] iff there are no items with a    -- larger place.y than index.    firstBigger ¬ myContext.items.LENGTH;    FOR i: CARDINAL IN (index..myContext.items.LENGTH) DO      IF myContext.items[i].flags.invisible THEN LOOP;      IF myContext.dijects[i].box.place.y >       myContext.dijects[index].box.place.y THEN RETURN[i];      ENDLOOP};  OverUnderflowSlide: PUBLIC PROC [    myContext: FormSWOps.PContext, index: CARDINAL, fixup: INTEGER] = {     firstBigger, tallest: CARDINAL;    bottomY, itemBottomY, newH: INTEGER;    -- Look for items with bigger y.    firstBigger ¬ FirstLargerYItem[myContext, index];    IF firstBigger = myContext.items.LENGTH THEN RETURN;    -- Work to do.  First find tallest item on this line.  Note that taller    -- is before fixup for overflow, after for underflow.    newH ¬      IF fixup > 0 THEN myContext.dijects[index].box.dims.h      ELSE myContext.dijects[index].box.dims.h + fixup;    tallest ¬ TallestItemOnSameLine[      myContext, index, LENGTH[myContext.items], newH,       myContext.dijects[index].box.place.y];    -- If overflow and there is a taller item, then there is nothing to do.    -- For underflow, only close up to the base of the taller item.    IF fixup < 0 THEN {      IF tallest = index THEN newH ¬ myContext.dijects[tallest].box.dims.h      ELSE {        IF myContext.dijects[tallest].box.dims.h >=	  myContext.dijects[index].box.dims.h THEN RETURN;        newH ¬ myContext.dijects[tallest].box.dims.h - fixup}}    ELSE IF tallest # index THEN RETURN;    bottomY ¬ myContext.dijects[index].box.place.y + newH + fixup;    itemBottomY ¬ myContext.dijects[index].box.place.y +     myContext.dijects[index].box.dims.h;    -- Only move bits if bigger y items are actually on the display!    IF myContext.dijects[firstBigger].box.place.y <=      myContext.sw.GetBox.dims.h THEN {        SlideYBand[myContext, itemBottomY, bottomY]}    ELSE      myContext.sw.InvalidateBox[        [[0, bottomY], [myContext.sw.GetBox.dims.w, 	  myContext.sw.GetBox.dims.h - bottomY]], isDirty];    AdjustSucceedingItemPlaces[myContext, firstBigger, bottomY - itemBottomY]};  SlideYBand: PUBLIC PROC [    myContext: FormSWOps.PContext, oldY, newY: INTEGER] = {    -- Slides bits in the formSW from oldY to newY.    -- The window package clips the source to sw.box, and so does this    --   procedure.  Take this out if it will not cause extra repaints.    bandX: INTEGER = 0;    bandW: INTEGER = myContext.sw.GetBox.dims.w;    h: INTEGER = myContext.sw.GetBox.dims.h;    box, invalidBox: Window.Box;    delta: INTEGER;    -- Clip oldY and adjust newY accordingly    delta ¬ newY - oldY;    IF oldY < 0 THEN oldY ¬ 0 ELSE IF oldY > h THEN oldY ¬ h;    newY ¬ oldY + delta;    delta ¬ ABS[delta];    -- Setup box to transfer and the invalidBox that results    box ¬ [[bandX, oldY], [bandW, h - oldY]];    invalidBox.place.x ¬ bandX;    invalidBox.dims ¬ [w: bandW, h: delta];    IF newY > oldY THEN {      excess: INTEGER = newY - h;      box.dims.h ¬ box.dims.h - delta;      invalidBox.place.y ¬ box.place.y;      IF excess > 0 THEN { -- a little optimization        box.place.y ¬ box.place.y - excess;        box.dims.h ¬ box.dims.h + excess;        newY ¬ h}}    ELSE {      invalidBox.place.y ¬ h - invalidBox.dims.h;      IF newY < 0 THEN { -- a little optimization        box.place.y ¬ delta;        box.dims.h ¬ h - box.place.y;        newY ¬ 0}};    Display.Shift[myContext.sw, box, [x: bandX, y: newY]];    myContext.sw.InvalidateBox[invalidBox, isDirty]};  TallestItemOnSameLine: PUBLIC PROC [    myContext: FormSWOps.PContext, index, firstBad: CARDINAL,    indexH, indexY: INTEGER] RETURNS [tallest: CARDINAL] = {    -- tallest is the item that is on the same line as index and has the    --   largest h, where indexH is used for the h of index, not the    --   diject[index] h.  tallest may be index.    maxH: INTEGER ¬ indexH;    tallest ¬ index;    FOR i: CARDINAL DECREASING IN [0..index) DO      IF myContext.items[i].flags.invisible THEN LOOP;      IF myContext.dijects[i].box.place.y < indexY THEN EXIT      ELSE        IF myContext.dijects[i].box.dims.h > maxH THEN {	  maxH ¬ myContext.dijects[i].box.dims.h; tallest ¬ i};      ENDLOOP;    FOR i: CARDINAL IN (index..firstBad) DO      IF myContext.items[i].flags.invisible THEN LOOP;      IF myContext.dijects[i].box.place.y > indexY THEN EXIT      ELSE        IF myContext.dijects[i].box.dims.h > maxH THEN {          maxH ¬ myContext.dijects[i].box.dims.h; tallest ¬ i};      ENDLOOP};  END.
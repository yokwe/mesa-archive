-- Copyright (C) 1981, 1982, 1984  by Xerox Corporation. All rights reserved. -- File: UserInputsB.mesa - last edited:-- PXK    	15-Nov-82 16:54:59-- SXW   	10-Jul-81 18:04:04-- Mark	Oct 8, 1980 2:12 PM-- JGS		18-Nov-82 13:11:29-- SEH		18-Oct-82 11:21:40-- BGY     	20-Sep-82 15:51:30-- CXH   	24-Oct-82 16:22:31-- AXD    	19-Apr-84 15:19:28-- DWR    	 7-Feb-85 10:30:23DIRECTORY  Context USING [Create, Destroy, Find, Type, UniqueType],  Cursor USING [Set],  Heap USING [Create, systemZone],  Inline USING [BITAND],  Keys USING [DownUp, KeyBits, KeyName],  LevelVKeys USING [DownUp, KeyBits, KeyName],  Process USING [MsecToTicks, Pause, Ticks],  Selection USING [Action, ActOn, Convert, ConvertTrashBin, Source, Target],  String USING [EmptyString],  SpecialUserInput USING [],  TajoOps USING [],  TajoMisc USING [],  UserInput USING [CaretProcType, Error, StringProcType, UserAbort],  UserInputOps USING [    DirectTypeIn, IndirectTypeIn, TypeInHandle, TypeInObject],  Window;UserInputsB: MONITOR  IMPORTS    Context, Cursor, Heap, Inline, Process, Selection,    String, UserInput, Window  EXPORTS SpecialUserInput, TajoMisc, UserInput, UserInputOps =  BEGIN   --  Implementation specific TYPEs  DownUp: TYPE = Keys.DownUp;  KeyName: TYPE = Keys.KeyName;  StringProcType: TYPE = UserInput.StringProcType;  CaretProcType: TYPE = UserInput.CaretProcType;  TypeInHandle: TYPE = UserInputOps.TypeInHandle;  DirectTypeIn: TYPE = UserInputOps.DirectTypeIn;  IndirectTypeIn: TYPE = UserInputOps.IndirectTypeIn;    KeysDescriptionTable: TYPE = ARRAY LevelVKeys.KeyName OF KeyDescription;  KeyDescription: TYPE = RECORD [    shiftCode, normalCode: KeyCode ¬ noSuchCharacter];  KeyCode: TYPE = CHARACTER;  noSuchCharacter: CHARACTER = CHARACTER.LAST;  --  Global Variables  z: PUBLIC UNCOUNTED ZONE ¬ Heap.Create[initial: 4];  typein: PUBLIC Context.Type ¬ Context.UniqueType[];  caretRate: PUBLIC Process.Ticks ¬ Process.MsecToTicks[333]; -- not 500  rootWindow: Window.Handle = Window.rootWindow;  indirectTypeInChain: PUBLIC UserInputOps.IndirectTypeIn ¬ NIL;  Shifted: TYPE = {yes, no, dontCare};  keysDescriptionTable: KeysDescriptionTable = [    [],  -- null    [normalCode: 254C, shiftCode: 255C],  -- Bullet    [],  -- SuperSub    [],  -- Case    [],  -- Strikeout    [normalCode: '2, shiftCode: '2],  -- KeypadTwo    [normalCode: '3, shiftCode: '3],  -- KeypadThree    [normalCode: 047C, shiftCode: 140C],  -- SingleQuote    [normalCode: '+, shiftCode: '+],  -- KeypadAdd    [normalCode: '-, shiftCode: '-],  -- KeypadSubtract    [normalCode: '´, shiftCode: '´],  -- KeypadMultiply    [normalCode: '¸, shiftCode: '¸],  -- KeypadDivide    [],  -- KeypadClear    [],  -- Point    [],  -- Adjust    [],  -- Menu    [normalCode: '5, shiftCode: '%],  -- Five    [normalCode: '4, shiftCode: '$],  -- Four    [normalCode: '6, shiftCode: '~],  --Six    [normalCode: 'e, shiftCode: 'E], -- E    [normalCode: '7, shiftCode: '&],  -- Seven    [normalCode: 'd, shiftCode: 'D],  -- D    [normalCode: 'u, shiftCode: 'U],  -- U    [normalCode: 'v, shiftCode: 'V],  -- V    [normalCode: '0, shiftCode: ')],  -- Zero    [normalCode: 'k, shiftCode: 'K],  -- K    [normalCode: '-, shiftCode: 137C],  -- Dash &  underbar    [normalCode: 'p, shiftCode: 'P],  -- P    [normalCode: '/, shiftCode: '?],  -- Slash    [normalCode: '\\, shiftCode: '|],  -- Font    [],  -- Same    [],  -- BS    [normalCode: '3, shiftCode: '#],  -- Three    [normalCode: '2, shiftCode: '@],  -- Two    [normalCode: 'w, shiftCode: 'W],  -- W    [normalCode: 'q, shiftCode: 'Q],  -- Q    [normalCode: 's, shiftCode: 'S],  -- S    [normalCode: 'a, shiftCode: 'A],  -- A    [normalCode: '9, shiftCode: '(],  -- Nine    [normalCode: 'i, shiftCode: 'I],  -- I    [normalCode: 'x, shiftCode: 'X],  -- X    [normalCode: 'o, shiftCode: 'O],  -- O    [normalCode: 'l, shiftCode: 'L],  -- L    [normalCode: ',, shiftCode: '<],  -- Comma    [normalCode: '', shiftCode: '"],  -- Quote    [normalCode: '], shiftCode: '}],  -- RightBracket    [],  -- Open    [],  -- Special    [normalCode: '1, shiftCode: '!],  -- One    [],  -- Tab    [normalCode: 11C, shiftCode: 11C],  -- ParaTab    [normalCode: 'f, shiftCode: 'F],  -- F    [],  -- Props    [normalCode: 'c, shiftCode: 'C],  -- C    [normalCode: 'j, shiftCode: 'J],  -- J    [normalCode: 'b, shiftCode: 'B],  -- B    [normalCode: 'z, shiftCode: 'Z],  -- Z    [],  -- LeftShift    [normalCode: '., shiftCode: '>],  -- Period    [normalCode: ';, shiftCode: ':],  -- SemiColon    [normalCode: 15C, shiftCode: 15C],  -- NewPara (Return)    [normalCode: 254C, shiftCode: 255C],  -- OpenQuote (left-arrow, up-arrow)    [],  -- Delete    [],  -- Next    [normalCode: 'r, shiftCode: 'R],  -- R    [normalCode: 't, shiftCode: 'T],  -- T    [normalCode: 'g, shiftCode: 'G],  -- G    [normalCode: 'y, shiftCode: 'Y],  -- Y    [normalCode: 'h, shiftCode: 'H],  -- H    [normalCode: '8, shiftCode: '*],  -- Eight    [normalCode: 'n, shiftCode: 'N],  -- N    [normalCode: 'm, shiftCode: 'M],  -- M    [],  -- Lock    [normalCode: ' , shiftCode: ' ],  -- Space    [normalCode: '[, shiftCode: '{],  -- LeftBracket    [normalCode: '=, shiftCode: '+],  -- Equal    [],  -- RightShift    [],  -- Stop    [],  -- Move    [],  -- Undo    [],  -- Margins    [normalCode: '7, shiftCode: '7],  -- KeypadSeven    [normalCode: '8, shiftCode: '8],  -- KeypadEight    [normalCode: '9, shiftCode: '9],  -- KeypadNine    [normalCode: '4, shiftCode: '4],  -- KeypadFour    [normalCode: '5, shiftCode: '5],  -- KeypadFive    [],  -- English    [normalCode: '6, shiftCode: '6],  -- KeypadSix    [],  -- Katakana    [],  -- Copy    [],  -- Find    [],  -- Again    [],  -- Help    [],  -- Expand    [normalCode: '1, shiftCode: '1],  -- KeypadOne    [],  -- DiagnosticBitTwo    [],  -- DiagnosticBitOne    [],  -- Center    [normalCode: '0, shiftCode: '0],  -- KeypadZero    [],  -- Bold    [],  -- Italic    [],  -- Underline    [],  -- Superscript    [],  -- Subscript    [],  -- Smaller    [normalCode: '., shiftCode: '.],  -- KeypadPeriod    [normalCode: ',, shiftCode: ',],  -- KeypadComma    [],  -- LeftShiftAlt    [normalCode: '", shiftCode: 136C],  -- DoubleQuote & circumflex    [],  -- Defaults    [],  -- Hiragana    []  -- RightShiftAlt  ];  --  "The NOTIFIER" (not really)  backStopInputFocus: PUBLIC Window.Handle ¬ NIL;  inputFocus: Window.Handle ¬ NIL;  focusNotify: PROC [Window.Handle, LONG POINTER] ¬ NIL;  focusNotifyData: LONG POINTER ¬ NIL;  focusTakesInput: BOOLEAN ¬ FALSE;    ClearInputFocusOnMatch: PUBLIC ENTRY PROC [w: Window.Handle] = {    ENABLE UNWIND => NULL;    IF inputFocus = w THEN      InternalSetInputFocus[w: NIL, notify: NIL, takesInput: FALSE, data: NIL]};    FocusTakesInput: PUBLIC ENTRY PROC RETURNS [BOOLEAN] = {    RETURN [focusTakesInput]};  GetInputFocus: PUBLIC ENTRY PROC RETURNS [Window.Handle] = {    RETURN [InputFocus[]]};  InputFocus: INTERNAL PROC RETURNS [Window.Handle] = INLINE {    RETURN [IF inputFocus # NIL THEN inputFocus ELSE backStopInputFocus]};  InternalSetInputFocus: INTERNAL PROC [    w: Window.Handle, notify: PROC [Window.Handle, LONG POINTER],    takesInput: BOOLEAN, data: LONG POINTER] =  {    target: Window.Handle;    typeIn: DirectTypeIn;    [target, typeIn] ¬ FindDirectTypeIn[InputFocus[]];    IF w # inputFocus THEN {      IF typeIn # NIL AND focusTakesInput THEN typeIn.caret[target, stop];      IF focusNotify # NIL THEN focusNotify[inputFocus, focusNotifyData !        UNWIND => AllDoneWithTypeIn[typeIn]];      inputFocus ¬ w;      AllDoneWithTypeIn[typeIn];      [target, typeIn] ¬ FindDirectTypeIn[InputFocus[]]};    focusNotify ¬ notify;    focusTakesInput ¬ takesInput;    focusNotifyData ¬ data;    Cursor.Set[IF focusTakesInput THEN textPointer ELSE groundedText];    IF typeIn # NIL AND focusTakesInput THEN typeIn.caret[target, start];    AllDoneWithTypeIn[typeIn]};    SetInputFocus: PUBLIC ENTRY PROC [    w: Window.Handle, notify: PROC [Window.Handle, LONG POINTER],    takesInput: BOOLEAN, data: LONG POINTER ¬ NIL] = {    ENABLE UNWIND => NULL;    InternalSetInputFocus[w, notify, takesInput, data]};    --  PNR routines  NopCaretProc: PUBLIC UserInput.CaretProcType = {};  NopStringProc: PUBLIC UserInput.StringProcType = {};  GetDefaultWindow: PUBLIC PROC RETURNS [Window.Handle] = {    RETURN[rootWindow]};  WaitMilliSecs: PUBLIC PROC [msec: CARDINAL] = {    Process.Pause[Process.MsecToTicks[msec]]};  WaitSecs: PUBLIC PROC [secs: CARDINAL] = {    THROUGH [0..secs) DO      IF UserInput.UserAbort[rootWindow] THEN EXIT; WaitMilliSecs[1000] ENDLOOP};  --  Translate routines  CharForKey: PUBLIC PROC [key: KeyName, keys: LONG POINTER TO Keys.KeyBits]    RETURNS [char: CHARACTER] =  {    -- loopholes nescessary until we recompile defs in Mesa 13.0    kb: LONG POINTER TO LevelVKeys.KeyBits = LOOPHOLE[keys];    entry: KeyDescription = keysDescriptionTable[LOOPHOLE[key, LevelVKeys.KeyName]];    char ¬      IF kb[LeftShift] = down OR kb[RightShift] = down      OR kb[LeftShiftAlt] = down OR kb[RightShiftAlt] = down      OR (kb[Lock] = down AND entry.normalCode IN ['a..'z])      THEN entry.shiftCode -- LOCK only works on letters      ELSE entry.normalCode;    IF kb[Props] = down AND char # noSuchCharacter THEN char ¬ Inline.BITAND[char, 37B];    RETURN[char]};  --  TypeIn Stuff  FindDirectTypeIn: PUBLIC PROC [window: Window.Handle]    RETURNS [Window.Handle, DirectTypeIn] = {    typeIn: UserInputOps.TypeInHandle ¬ Context.Find[typein, window];    nw: Window.Handle ¬ window;    DO      IF typeIn = NIL THEN RETURN[NIL, NIL];      WITH t: typeIn SELECT FROM        direct => {t.useCount ¬ t.useCount + 1; RETURN[nw, @t]};        indirect => {nw ¬ t.inWindow; typeIn ¬ t.inTo};  -- order important!!        ENDCASE;      ENDLOOP};  FindDirectTypeOut: PROC [window: Window.Handle]    RETURNS [Window.Handle, DirectTypeIn] = {    typeIn: UserInputOps.TypeInHandle ¬ Context.Find[typein, window];    nw: Window.Handle ¬ window;    DO      IF typeIn = NIL THEN RETURN[NIL, NIL];      WITH t: typeIn SELECT FROM        direct => {t.useCount ¬ t.useCount + 1; RETURN[nw, @t]};        indirect => {nw ¬ t.outWindow; typeIn ¬ t.outTo}; -- order important!!        ENDCASE;      ENDLOOP};  AllDoneWithTypeIn: PROC [typeIn: DirectTypeIn] = {    IF typeIn = NIL THEN RETURN;    IF (typeIn.useCount ¬ typeIn.useCount - 1) = 0 AND typeIn.freePlease THEN {      z.FREE[@typeIn.string]; z.FREE[@typeIn]}};  ConvertProc: TYPE = PROC [Selection.Target] RETURNS [LONG POINTER];  StuffSomething: PROC [window: Window.Handle, Convert: ConvertProc]    RETURNS [didSome: BOOLEAN] = {    source: Selection.Source;    string: LONG STRING;    typeIn: DirectTypeIn;    [window, typeIn] ¬ FindDirectTypeIn[window];    IF typeIn = NIL OR typeIn.freePlease THEN RETURN[FALSE]; -- avoid converting string    string ¬ Convert[string];    IF string # NIL THEN {      typeIn.in[        window, string !        UNWIND => {Heap.systemZone.FREE[@string]; AllDoneWithTypeIn[typeIn]}];      Heap.systemZone.FREE[@string];  -- this string came from systemZone      didSome ¬ TRUE}    ELSE {      source ¬ Convert[source];      IF source # NIL THEN {        string: LONG STRING ¬ z.NEW[StringBody[500]];        DO          ENABLE            UNWIND => {AllDoneWithTypeIn[typeIn]; z.FREE[@string]};          source.proc[source.data, string];          IF string.length = 0 THEN EXIT;          typeIn.in[window, string];          IF typeIn.freePlease THEN EXIT;          ENDLOOP;        z.FREE[@string];        source.destroy[source];        didSome ¬ TRUE}      ELSE didSome ¬ FALSE};    IF didSome AND window = Selection.Convert[subwindow] THEN      Selection.ActOn[clearIfHasInsert];    AllDoneWithTypeIn[typeIn];    RETURN[didSome]};  StuffCharacter: PUBLIC PROC [window: Window.Handle, char: CHARACTER]    RETURNS [BOOLEAN] = {    s: STRING ¬ [2];    s[0] ¬ char;    s.length ¬ 1;    RETURN StuffString[window, s]};  StuffCurrentSelection: PUBLIC PROC [window: Window.Handle]    RETURNS [BOOLEAN] = {RETURN StuffSomething[window, Selection.Convert]};  StuffString: PUBLIC PROC [window: Window.Handle, string: LONG STRING]    RETURNS [BOOLEAN] = {    typeIn: DirectTypeIn;    [window, typeIn] ¬ FindDirectTypeIn[window];    IF typeIn = NIL THEN RETURN[FALSE];    typeIn.in[      string: string, window: window ! UNWIND => AllDoneWithTypeIn[typeIn]];    IF string # NIL AND window = Selection.Convert[subwindow] THEN      Selection.ActOn[clearIfHasInsert];    AllDoneWithTypeIn[typeIn];    RETURN[TRUE]};  StuffTrashBin: PUBLIC PROC [window: Window.Handle] RETURNS [BOOLEAN] = {    RETURN StuffSomething[window, Selection.ConvertTrashBin]};  StringOut: PUBLIC PROC [window: Window.Handle, string: LONG STRING] = {    typeIn: DirectTypeIn;    [window, typeIn] ¬ FindDirectTypeOut[window];    IF typeIn = NIL THEN RETURN;    typeIn.out[string: string, window: window];    AllDoneWithTypeIn[typeIn]};  TypeInFlush: PROC [typeInWindow: Window.Handle, typeIn: DirectTypeIn] = {    IF typeIn.freePlease THEN RETURN;    IF ~String.EmptyString[typeIn.string] THEN {      << Following obscure code is for the debugger's Interpret Call         Flow of control in that case is:           1) Call debugger, which calls client world.           2) Client may trap to debugger, which starts 2nd Notifier           3) User types and we come back to here.  Note no RETURN or UNWIND!         Thus we re-use typeIn.string during our 2nd instantiation. >>      temp: LONG STRING ¬ typeIn.string;      typeIn.string ¬ NIL;      typeIn.in[        string: temp, window: typeInWindow !        UNWIND => {z.FREE[@temp]; AllDoneWithTypeIn[typeIn]}];      IF typeIn.string = NIL THEN typeIn.string ¬ temp      ELSE z.FREE[@temp];  -- 2nd Notifier allocated another string      typeIn.string.length ¬ 0;      IF typeInWindow = Selection.Convert[subwindow] THEN        Selection.ActOn[clearIfHasInsert]}};  --  Create/Destroy TypeIn Stuff  CreateStringInOut: PUBLIC PROC [    window: Window.Handle, in, out: StringProcType, caretProc: CaretProcType] = {    typeIn: DirectTypeIn ¬ Context.Find[typein, window];    IF typeIn # NIL THEN ERROR UserInput.Error[windowAlreadyHasStringInOut];    typeIn ¬ z.NEW[direct UserInputOps.TypeInObject ¬ [      direct[in: in, out: out, caret: caretProc]]];    Context.Create[typein, typeIn, DestroyTypeInContext, window]};  CreateIndirectStringSomething: PROC [    from, to: Window.Handle, setIn, setOut: BOOLEAN] = {    typeIn: IndirectTypeIn ¬ Context.Find[typein, from];    IF typeIn = NIL THEN {      typeIn ¬ z.NEW[indirect UserInputOps.TypeInObject ¬ [        indirect[link: indirectTypeInChain]]];      indirectTypeInChain ¬ typeIn;      Context.Create[typein, typeIn, DestroyTypeInContext, from]};    IF setIn THEN {      IF to = NIL THEN {typeIn.inTo ¬ NIL; typeIn.inWindow ¬ NIL}      ELSE {        IF typeIn.inTo # NIL THEN ERROR UserInput.Error[windowAlreadyHasStringInOut];        typeIn.inTo ¬ Context.Find[typein, to];        typeIn.inWindow ¬ to}};    IF setOut THEN {      IF to = NIL THEN {typeIn.outTo ¬ NIL; typeIn.outWindow ¬ NIL}      ELSE {        IF typeIn.outTo # NIL THEN ERROR UserInput.Error[windowAlreadyHasStringInOut];        typeIn.outTo ¬ Context.Find[typein, to];        typeIn.outWindow ¬ to}};    IF typeIn.outWindow = NIL AND typeIn.inWindow = NIL THEN      Context.Destroy[typein, from]};  CreateIndirectStringInOut: PUBLIC PROC [from, to: Window.Handle] = {    CreateIndirectStringSomething[from, to, TRUE, TRUE]};  CreateIndirectStringOut: PUBLIC PROC [from, to: Window.Handle] = {    CreateIndirectStringSomething[from, to, FALSE, TRUE]};  CreateIndirectStringIn: PUBLIC PROC [from, to: Window.Handle] = {    CreateIndirectStringSomething[from, to, TRUE, FALSE]};  DestroyStringInOut, DestroyIndirectStringInOut: PUBLIC PROC [    window: Window.Handle] = {Context.Destroy[typein, window]};  DestroyIndirectStringIn: PUBLIC PROC [from: Window.Handle] = {    CreateIndirectStringSomething[from, NIL, TRUE, FALSE]};  DestroyIndirectStringOut: PUBLIC PROC [from: Window.Handle] = {    CreateIndirectStringSomething[from, NIL, FALSE, TRUE]};  DestroyTypeInContext: PROC [typeIn: TypeInHandle, window: Window.Handle] = {    i, temp: IndirectTypeIn;    prev: LONG POINTER TO IndirectTypeIn;    WITH t: typeIn SELECT FROM      direct => {        IF t.useCount = 0 THEN z.FREE[@t.string];        temp ¬ NIL};      indirect => temp ¬ @t;      ENDCASE;    prev ¬ @indirectTypeInChain;    FOR i ¬ indirectTypeInChain, i.link UNTIL i = NIL DO      IF i = temp THEN prev­ ¬ i.link;      IF i.inWindow = window THEN {i.inTo ¬ NIL; i.inWindow ¬ NIL};      IF i.outWindow = window THEN {i.outTo ¬ NIL; i.outWindow ¬ NIL};      prev ¬ @i.link;      ENDLOOP;    WITH t: typeIn SELECT FROM      direct =>        IF t.useCount = 0 THEN z.FREE[@typeIn] ELSE t.freePlease ¬ TRUE;      indirect => z.FREE[@typeIn];      ENDCASE};  HasIndirectTypeIn: PROC [from, to: Window.Handle] RETURNS [BOOLEAN] = {    typeIn: IndirectTypeIn ¬ Context.Find[typein, from];    RETURN[typeIn # NIL AND typeIn.inWindow = to]};  SetStringInOut: PROC [    window: Window.Handle, proc: StringProcType, inout: {in, out}]    RETURNS [old: StringProcType] = {    typeIn: DirectTypeIn = Context.Find[typein, window];    IF typeIn = NIL THEN ERROR UserInput.Error[noStringInOutForWindow];    IF inout = in THEN {old ¬ typeIn.in; typeIn.in ¬ proc}    ELSE {old ¬ typeIn.out; typeIn.out ¬ proc}};  SetStringIn: PUBLIC PROC [window: Window.Handle, proc: StringProcType]    RETURNS [old: StringProcType] = {    RETURN SetStringInOut[window, proc, in]};  SetStringOut: PUBLIC PROC [window: Window.Handle, proc: StringProcType]    RETURNS [old: StringProcType] = {    RETURN SetStringInOut[window, proc, out]};  END. -- of UserInputsBLOGDWR    	26-Nov-84 14:41:58  sped up the caretRate from 1 Hz to 1.5 Hz.DWR    	 6-Feb-85 12:56:17  Modifications for Dove Keyboard
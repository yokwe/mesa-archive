-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- File: SearchPathImpl.mesa - last edit: -- RXR   :	 20-Dec-82 18:09:18-- BTL  :	 20-Dec-82 18:07:21-- CXH   :	 28-Dec-82 10:51:24-- AXD    :	 20-Jul-83 17:52:26-- LXR    :	  7-Dec-83 12:11:50-- Note: if there is an error setting the search path, we might re-set to the old oneDIRECTORY  Ascii USING [NUL],  Exec USING [    AddCommand, ExecProc, FreeTokenString, GetChar, GetToken, Handle, Object,    Outcome, OutputProc],  ExecInternal USING [],  Format USING [CR, StringProc],  Heap USING [systemZone],  MFile USING [    Acquire, AppendErrorMessage, CreateDirectory, Error, ErrorCode, FreeSearchPath,    GetFullName, GetSearchPath, Handle, Object, Release, SearchPath,    SearchPathObject, SetSearchPath],  SearchPathDefs USING [],  String USING [AppendStringAndGrow, CopyToNewString, Empty],  Token USING [    FileName, Filtered, FilterProcType, FreeStringHandle,     FreeTokenString, GetCharProcType, Handle, Line, Object, StringToHandle];    SearchPathImpl: MONITOR  IMPORTS Exec, Format, Heap, MFile, String, Token    EXPORTS ExecInternal, SearchPathDefs =  BEGIN    -- globals and constants  z: UNCOUNTED ZONE = Heap.systemZone;    FullName: PROCEDURE [dir: LONG STRING, fullDirName: LONG STRING] =      BEGIN      handle: MFile.Handle ¬        MFile.Acquire[dir, anchor, [NIL, NIL]]; -- ! MFile.Error => REJECT      handle.GetFullName[fullDirName ! UNWIND => handle.Release[]];      handle.Release[];      END;        WriteMFileError: PROCEDURE[    code: MFile.ErrorCode, file: MFile.Handle, Write: Format.StringProc] = {    msg: LONG STRING = [100];    Format.CR[Write]; MFile.AppendErrorMessage[msg, code, file]; Write[msg]};      CreateDir: PUBLIC PROCEDURE[name: LONG STRING, Write: Format.StringProc]     RETURNS [outcome: Exec.Outcome ¬ normal] =     BEGIN ENABLE MFile.Error => {WriteMFileError[code, file, Write]; CONTINUE};    IF name # NIL THEN {      MFile.CreateDirectory[name];      Format.CR[Write]; Write[" Created directory. "L]; Write[name]};    END;      FreeSearchPath: PROCEDURE [sp: MFile.SearchPath]     RETURNS [MFile.SearchPath ¬ NIL] =    BEGIN    FOR i: CARDINAL IN [0..sp.length) DO      Heap.systemZone.FREE[@sp[i]];      ENDLOOP;    Heap.systemZone.FREE[@sp];    END; -- of FreeSearchPath  ConvertStringToSearchPath: PROCEDURE [    cmdLine: LONG STRING, Write: Format.StringProc]    RETURNS [sp: MFile.SearchPath ¬ NIL] =    BEGIN    SearchPathHandle: TYPE = LONG POINTER TO SearchPathElement;    SearchPathElement: TYPE = RECORD [      next: SearchPathHandle ¬ NIL,      dir: LONG STRING];    s: SearchPathHandle ¬ NIL;    th: Token.Handle;    i: CARDINAL ¬ 0;    token: LONG STRING;    tokenData: ARRAY [0..2) OF CARDINAL;    IF cmdLine = NIL THEN {      Write["Cannot set to empty search path.\N"]; RETURN};    th ¬ Token.StringToHandle[cmdLine];    BEGIN ENABLE UNWIND => {th ¬ th.FreeStringHandle[]};    WHILE      (token ¬ th.Filtered[LOOPHOLE[LONG[@tokenData]], Token.FileName]) # NIL DO      fullDirName: LONG STRING = [200];      FullName[token, fullDirName !        MFile.Error => {WriteMFileError[code, file, Write]; GOTO error}];      token ¬ Token.FreeTokenString[token];      s ¬ z.NEW[SearchPathElement ¬ [        next: s, dir: String.CopyToNewString[fullDirName, z]]];      i ¬ i + 1;      REPEAT        error => {	  token ¬ Token.FreeTokenString[token];	  th ¬ th.FreeStringHandle[];	  UNTIL s = NIL DO	    temp: SearchPathHandle ¬ s;	    s ¬ s.next;	    z.FREE[@temp];	    ENDLOOP;	  RETURN};      ENDLOOP;          IF i = 0 THEN {      Write["Cannot set to empty search path.\N"];       th ¬ th.FreeStringHandle[]; RETURN};    sp ¬ z.NEW[MFile.SearchPathObject[i]];    sp.length ¬ i;    FOR c: CARDINAL IN (0..i] DO      temp: SearchPathHandle ¬ s;      sp[i - c] ¬ s.dir;      s ¬ s.next;      z.FREE[@temp];      ENDLOOP;    th ¬ th.FreeStringHandle[]    END;    END;      StringToSearchPath: PUBLIC PROCEDURE [    cmdLine: LONG STRING, Write: Format.StringProc]    RETURNS [outcome: Exec.Outcome ¬ error] =    BEGIN    sp: MFile.SearchPath ¬ ConvertStringToSearchPath[cmdLine, Write];        BEGIN ENABLE UNWIND => {sp ¬ FreeSearchPath[sp]};    IF sp # NIL THEN {      IF MFile.SetSearchPath[sp !        MFile.Error => {WriteMFileError[code, file, Write]; CONTINUE}] THEN	  outcome ¬ normal;      Write[" Search path set to "L]; WriteCurrentSearchPath[Write];      sp ¬ FreeSearchPath[sp]};    END; -- catch phrase scope    END;       CWD: PUBLIC PROCEDURE [dir: LONG STRING, Write: Format.StringProc]     RETURNS [outcome: Exec.Outcome ¬ normal] =      BEGIN      currentSearchPath: MFile.SearchPath ¬ MFile.GetSearchPath[];      oldWorkDir: LONG STRING;      myStorage: BOOLEAN = currentSearchPath = NIL;      fullDirName: LONG STRING = [200];            BEGIN      ENABLE UNWIND => {IF myStorage THEN z.FREE[@currentSearchPath]        ELSE MFile.FreeSearchPath[currentSearchPath]};      FullName[dir, fullDirName !        MFile.Error => {WriteMFileError[code, file, Write]; GOTO error}];      IF myStorage THEN         currentSearchPath ¬ Heap.systemZone.NEW[MFile.SearchPathObject[1]];       oldWorkDir ¬ currentSearchPath[0];      currentSearchPath[0] ¬ fullDirName;      [] ¬ MFile.SetSearchPath[currentSearchPath];      currentSearchPath[0] ¬ oldWorkDir;      IF myStorage THEN z.FREE[@currentSearchPath]      ELSE MFile.FreeSearchPath[currentSearchPath];      END; -- scope of catch phrase      EXITS error => RETURN[error];      END;         Push: PUBLIC PROCEDURE [dir: LONG STRING, Write: Format.StringProc]      RETURNS [Exec.Outcome ¬ normal] =     BEGIN     fullDirName: LONG STRING = [200];     osp: MFile.SearchPath ¬ MFile.GetSearchPath[];     nsp: MFile.SearchPath ¬ z.NEW[MFile.SearchPathObject [osp.length+1]];          BEGIN ENABLE UNWIND => {z.FREE[@nsp]; MFile.FreeSearchPath[osp]};     FullName[dir, fullDirName !        MFile.Error => {WriteMFileError[code, file, Write]; GOTO error}];     nsp.length ¬ osp.length+1;     FOR i: CARDINAL IN [1..nsp.length) DO nsp[i] ¬ osp[i-1] ENDLOOP;     nsp[0] ¬ fullDirName;     [] ¬ MFile.SetSearchPath[nsp];     Write[" Search path set to "L]; WriteCurrentSearchPath[Write];     z.FREE[@nsp];     MFile.FreeSearchPath[osp];     END;     EXITS error => RETURN[error];     END;        Pop: PUBLIC PROCEDURE [Write: Format.StringProc]      RETURNS [outcome: Exec.Outcome ¬ normal] =     BEGIN     currentSearchPath: MFile.SearchPath ¬ MFile.GetSearchPath[];     poppedDir: LONG STRING ¬ currentSearchPath[0];     IF currentSearchPath.length = 1 THEN {       Write["The last element in the search path cannot be popped."L];       MFile.FreeSearchPath[currentSearchPath];       RETURN[error]};     FOR i: CARDINAL IN [0..currentSearchPath.length-1) DO       currentSearchPath[i] ¬ currentSearchPath[i+1];       ENDLOOP;     currentSearchPath.length ¬ currentSearchPath.length-1;     [] ¬ MFile.SetSearchPath[currentSearchPath !       MFile.Error => {         WriteMFileError[code, file, Write]; outcome ¬ error; CONTINUE}];     Write[" Search path set to "L]; WriteCurrentSearchPath[Write];     currentSearchPath[currentSearchPath.length] ¬ poppedDir;     currentSearchPath.length ¬ currentSearchPath.length+1;     MFile.FreeSearchPath[currentSearchPath];     END;     CmdLineToSearchPath: Exec.ExecProc = {    cmdLine: LONG STRING ¬ NIL;    get: PROCEDURE [Token.Handle] RETURNS [CHARACTER] = {RETURN[h.GetChar[]]};    t: Token.Object ¬ [getChar: get, break: Ascii.NUL];    cmdLine ¬ Token.Filtered[@t, NULL, Token.Line];    outcome ¬ StringToSearchPath[      cmdLine, h.OutputProc[] ! UNWIND => z.FREE[@cmdLine]];    Format.CR[h.OutputProc[]];    cmdLine ¬ Token.FreeTokenString[cmdLine]};      WriteCurrentSearchPath: PROCEDURE [Write: Format.StringProc] =    BEGIN    sp: MFile.SearchPath ¬ MFile.GetSearchPath[];    msg: LONG STRING ¬ z.NEW[StringBody[200]]; -- newed so it can expand    BEGIN    ENABLE UNWIND => {MFile.FreeSearchPath[sp]; z.FREE[@msg]};    FOR i: CARDINAL IN [0..sp.length) DO      IF ~String.Empty[msg] THEN        String.AppendStringAndGrow[from: "  "L, to: @msg, z: z];      String.AppendStringAndGrow[from: sp[i], to: @msg, z: z];      ENDLOOP;    Write[msg];    z.FREE[@msg];    MFile.FreeSearchPath[sp];    END;    END;    Cwd: Exec.ExecProc =    BEGIN    dir: LONG STRING;    switches: LONG STRING;    [dir, switches] ¬ h.GetToken[];    IF dir = NIL THEN {[] ¬ CWDHelp[h]; RETURN [error]};    outcome ¬ CWD[dir, h.OutputProc[]];    [] ¬ Exec.FreeTokenString[dir];    [] ¬ Exec.FreeTokenString[switches];    IF outcome = normal THEN {      h.OutputProc[]["Search path set to "L];      WriteCurrentSearchPath[h.OutputProc[]]};    END;	  GetCurrent: Exec.ExecProc = {WriteCurrentSearchPath[h.OutputProc[]]};      CreateWD: Exec.ExecProc =     BEGIN    dir: LONG STRING;    switches: LONG STRING;    [dir, switches] ¬ h.GetToken[];    {ENABLE UNWIND => {      dir ¬ Exec.FreeTokenString[dir];       switches ¬ Exec.FreeTokenString[switches]};    IF dir = NIL THEN {      [] ¬ CreateDirHelp[h]; [] ¬ Exec.FreeTokenString[switches]; RETURN [error]};    outcome ¬ CreateDir[dir, h.OutputProc[]];    Format.CR[h.OutputProc[]];    dir ¬ Exec.FreeTokenString[dir];    switches ¬ Exec.FreeTokenString[switches]}; -- end ENABLE    RETURN [normal];    END;    	      PopWD: Exec.ExecProc = {    [outcome] ¬ Pop[h.OutputProc[]]; Format.CR[h.OutputProc[]]};  PushWD: Exec.ExecProc =      BEGIN      dir: LONG STRING;      switches: LONG STRING;      [dir, switches] ¬ h.GetToken[];      {ENABLE UNWIND => {        dir ¬ Exec.FreeTokenString[dir]; 	switches ¬ Exec.FreeTokenString[switches]};      IF dir = NIL THEN {        [] ¬ PushHelp[h]; [] ¬ Exec.FreeTokenString[switches]; RETURN [error]};      outcome ¬ Push[dir, h.OutputProc[]];      Format.CR[h.OutputProc[]];      dir ¬ Exec.FreeTokenString[dir];      switches ¬ Exec.FreeTokenString[switches]}; -- end ENABLE      RETURN [normal];      END;        CreateDirHelp: Exec.ExecProc =    {h.OutputProc[]["Syntax: \"CreateDir.~ <directory name>\".CreateDir creates the directory named <directory name>. No error is reported if the directory already exists.\N"L]};        ShowSearchPathHelp: Exec.ExecProc =    {h.OutputProc[]["\"ShowSearchPath.~\" expects no arguments and will display the current search path.\N"L]};        CWDHelp: Exec.ExecProc =    {h.OutputProc[]["Syntax: \"CWD.~ <directory name>\".CWD.~ replaces the first element of the search path by <directory name>\N"L]};        PopHelp: Exec.ExecProc =    {h.OutputProc[]["\"PopWorkingDirectory.~\" does not expect any arguments. It pops the working directory off the current search path.\N"L]};      PushHelp: Exec.ExecProc =    {h.OutputProc[]["Syntax: \"PushWorkingDirectory.~ <directory name>\".PushWorkingDirectory adds <directory name> to the front of the search path.\N"L]};        SetSearchPathHelp: Exec.ExecProc =    {h.OutputProc[]["Syntax: \"SetSearchPath.~ <search path>\".SetSearchPath sets the current search path to the value <search path>.\N"L]};        Initialize: PROCEDURE =    BEGIN    Exec.AddCommand["CreateDir.~"L, CreateWD, CreateDirHelp];    Exec.AddCommand["ShowSearchPath.~"L, GetCurrent, ShowSearchPathHelp];    Exec.AddCommand["CWD.~"L, Cwd, CWDHelp];    Exec.AddCommand["PopWorkingDirectory.~"L, PopWD, PopHelp];    Exec.AddCommand["PushWorkingDirectory.~"L, PushWD, PushHelp];    Exec.AddCommand["SetSearchPath.~"L, CmdLineToSearchPath, SetSearchPathHelp];    END;                  -- Mainline code        Initialize[];      END.    
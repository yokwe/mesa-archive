-- File: ToolWindowsC.mesa - last edit:-- Riggle.PA            8-Aug-86 16:22:12-- Copyright (C) 1981, 1982, 1983 , 1986 by Xerox Corporation. All rights reserved. -- File: ToolWindowsC.mesa - last modified:-- PXK    	25-Feb-83 19:24:08-- JGS		19-Nov-82  8:39:35-- PK & RKJ	May 19, 1980 11:40 PM; playing with StandardLimitProc-- Mark		27-May-81 22:47:46-- XXR   	 2-Dec-81 10:23:23-- SEH		 1-Oct-82 17:35:40-- BGY     	22-Feb-83 16:08:24-- AXD    	 7-Nov-83 14:47:46 DIRECTORY  Atom USING [ATOM, MakeAtom],  Context USING [Find, Type],  Cursor USING [    Defined, Fetch, FetchFromType, GetInfo, Handle, MoveIntoWindow, Object, Set,    Store, Type, UniqueType],  Display USING [Handle, Invert],  Heap USING [systemZone],  Inline USING [BITOR],  SpecialUserInput USING [EnqueueMagicMouseEvent],  Menu USING [    Create, Destroy, Handle, Instantiate, Invoke, ItemObject, MCRType,    Uninstantiate],  MSegment USING [GetPages],  TajoMisc USING [],  TajoOps USING [AllocateWindow, DeallocateWindow, tinyHeight, tinyWidth],  TIP USING [    CreateTable, First, globalTable, InvalidTable, NewManager,    NotifyProc, PushLocal, Rest, Results, Table],  ToolWindow USING [    Activate, Box, EnumerateProcType, Deactivate,     GetInactiveName, Handle, LimitProcType, MakeSize],  ToolWindowOps USING [    ClippingBox, SetClippingBox, Stack, stuff, Stuff, TakeDownZoomed,    Thirds, tinyUnderPages],  UserTerminal USING [BlinkDisplay, Coordinate, screenHeight, screenWidth],  Window USING [    BitmapPlace, Box, Dims, Float, GetBox, GetChild, GetParent, GetSibling,    Gravity, Handle, InitializeWindow, InsertIntoTree, InvalidateBox, Object,     ObscuredBySibling, Place, rootWindow, SetBitmapUnder, Slide,    SlideAndSizeAndStack, Stack, ValidateTree],  WindowFont USING [FontHeight];ToolWindowsC: MONITOR  IMPORTS    Atom, Context, Cursor, Display, Heap, Inline, Menu, MSegment,    SpecialUserInput, TajoOps, ToolWindow, ToolWindowOps, TIP, UserTerminal,    Window, WindowFont  EXPORTS TajoMisc, ToolWindow, ToolWindowOps =  BEGIN OPEN ToolWindowOps;  -- Signals and Errors  -- Globals Variables  oldCursor: Cursor.Object;  putBackCursorType: Cursor.Type ¬ questionMark;  myCursorType: Cursor.Type = Cursor.UniqueType[];  TopBottomGoal: TYPE = {switch, top, bottom};  CornerSide: TYPE = {    upperSide, lowerSide, leftSide, rightSide, upperLeft, upperRight, lowerLeft,    lowerRight};  MoveGrow: TYPE = {move, grow, drag};  fuzz: INTEGER = 2;  InactiveWindows: TYPE = RECORD [    count: CARDINAL,    menu: Menu.Handle,    windows: LONG POINTER TO WindowSequence,    items: LONG POINTER TO ItemSequence];  WindowSequence: TYPE = RECORD [    windows: SEQUENCE length: CARDINAL OF Window.Handle];  ItemSequence: TYPE = RECORD [    items: SEQUENCE length: CARDINAL OF Menu.ItemObject];  inactiveLengthIncrement: CARDINAL = 5;  inactive: InactiveWindows;  windowBU1: LONG POINTER = MSegment.GetPages[tinyUnderPages];  windowBU2: LONG POINTER = MSegment.GetPages[tinyUnderPages];  backDoor: BOOLEAN ¬ FALSE;  adjustIsDown: BOOLEAN ¬ FALSE;  Button: TYPE = {point, adjust};  -- command, control, shift: Atom.ATOM;  track, menuDown, pointUp, adjustUp, adjustDown, enter, exit: Atom.ATOM;  tip: PUBLIC TIP.Table ¬ NIL;  floatProcess: PROCESS;  floatCondition: CONDITION;  floatPlace: UserTerminal.Coordinate;  keepOnFloating: BOOLEAN ¬ FALSE;  floatRunning: BOOLEAN ¬ FALSE;    TIPMe: PUBLIC TIP.NotifyProc = {    place: Window.Place;    tool: Stuff = Context.Find[stuff, window];    IF tool = NIL THEN RETURN;    FOR input: TIP.Results ¬ results, input.Rest[] UNTIL input = NIL DO      WITH z: input.First[] SELECT FROM          coords => place ¬ z.place;	  atom => SELECT z.a FROM	    enter => EnterNameFrame[window, place, tool]; 	    exit => ExitNameFrame[window, place, tool]; 	    track =>	      IF backDoor THEN Track[window, place, tool]	      ELSE Invert[window, place, tool]; 	    pointUp => 	      IF backDoor THEN {	        IF tool.size = tiny THEN LOOP;		IF adjustIsDown THEN AdvanceCornerSide[window, place]		ELSE DoMoveGrow[window, place, tool]}	      ELSE DoSimpleFunction[window, point, tool];	    adjustUp => {	       adjustIsDown ¬ FALSE;	       IF backDoor THEN {	         IF tool.size = tiny THEN StopFloat[window, place]		 ELSE DoMoveGrow[window, place, tool]}	       ELSE IF tool.lastThird = second THEN	         DoSimpleFunction[window, adjust, tool]}; 	    adjustDown => {	      CheckFloat: PROC [cs: CornerSide] = {	        IF tool.size = tiny THEN StartFloat[window, place, tool]		ELSE EnterBackDoor[window, cs, place, move, tool]};              adjustIsDown ¬ TRUE;	      SELECT tool.lastThird FROM		first => IF ~backDoor THEN CheckFloat[upperLeft];		third => IF ~backDoor THEN CheckFloat[upperRight];		second => NULL;		ENDCASE};	    menuDown =>	      IF ~backDoor THEN { -- drop rest of results	        Menu.Invoke[window, place]; RETURN};	    ENDCASE;  -- ignore MenuUp	  ENDCASE;	ENDLOOP};    InitTip: PROC = {    tipContents: STRING ¬"-- ToolWindow.TIP, created by System-- Version of  6-Nov-82 16:56:30SELECT TRIGGER FROM    MOUSE => COORDS, Track;    ENTER => COORDS, Enter;    EXIT => COORDS, Exit;    ENDCASE..."L;    firstTime: BOOLEAN ¬ TRUE;    track ¬ Atom.MakeAtom["Track"L];    menuDown ¬ Atom.MakeAtom["MenuDown"L];    pointUp ¬ Atom.MakeAtom["PointUp"L];    adjustUp ¬ Atom.MakeAtom["AdjustUp"L];    adjustDown ¬ Atom.MakeAtom["AdjustDown"L];    enter ¬ Atom.MakeAtom["Enter"L];    exit ¬ Atom.MakeAtom["Exit"L];    tip ¬ TIP.CreateTable[file: "ToolWindow.TIP"L, contents: tipContents !      TIP.InvalidTable => IF type = badSyntax THEN {        UserTerminal.BlinkDisplay[];	IF firstTime THEN {firstTime ¬ FALSE; RESUME}}];    IF tip # NIL THEN TIP.PushLocal[onto: TIP.globalTable[root], push: tip]};       EnumerateInactiveWindows: PUBLIC PROC [proc: ToolWindow.EnumerateProcType] = {    i: CARDINAL ¬ 0;    FOR i IN [0..inactive.count) DO      IF proc[inactive.windows[i]] THEN EXIT;      ENDLOOP};      GetWindowManagerMenu: PUBLIC PROC RETURNS [Menu.Handle] = {    RETURN[windowManagerMenu]};    wmItems: ARRAY [0..8) OF Menu.ItemObject ¬ [    ["Move", MoveGrowMCR], ["Grow", MoveGrowMCR], ["Drag", MoveGrowMCR], [    "Size", OtherMCR], ["Top", OtherMCR], ["Bottom", OtherMCR], ["Zoom", OtherMCR],    ["Deactivate", OtherMCR]];  windowManagerMenu: Menu.Handle ¬ Menu.Create[    items: DESCRIPTOR[wmItems], name: "Window Mgr"L, permanent: TRUE];  -- Window Manager Menu Command Routines (MCRs)  DoGrow: PROC [    window: Window.Handle, place: Window.Place, corner: CornerSide,    tool: Stuff] = {    box: Window.Box;    oldBox: Window.Box = window.GetBox;    IF tool.size = tiny THEN RETURN;    BEGIN OPEN oldBox.place, oldBox.dims;    box ¬ tool.limitProc[      window,      SELECT corner FROM        upperSide => [[x, y + place.y], [w, h - place.y]],        lowerSide => [[x, y], [w, place.y + 1]],        leftSide => [[x + place.x, y], [w - place.x, h]],        rightSide => [[x, y], [place.x + 1, h]],        upperLeft => [[x + place.x, y + place.y], [w - place.x, h - place.y]],        lowerLeft => [[x + place.x, y], [w - place.x, place.y + 1]],        upperRight => [[x, y + place.y], [place.x + 1, h - place.y]],        lowerRight => [[x, y], [place.x + 1, place.y + 1]],        ENDCASE => [[0, 0], oldBox.dims]];    IF ABS[box.place.x - x] > fuzz OR ABS[box.place.y - y] > fuzz      OR ABS[box.dims.h - h] > fuzz OR ABS[box.dims.w - w] > fuzz THEN {      IF tool.size = zoomed THEN [] ¬ TakeDownZoomed[window, tool];      GrowWindow[        window: window, box: box, stack: same,         gravity: tool.gravity, tool: tool, clip: NIL]};    END};  DoMove: PROC [    window: Window.Handle, place: Window.Place, corner: CornerSide,    tool: Stuff] = {    dims: Window.Dims ¬ window.GetBox.dims;    IF tool.size # tiny THEN { -- all the work is already done      dims: Window.Dims = window.GetBox.dims;      oldPlace: Window.Place = window.GetBox.place;      IF corner = upperRight OR corner = lowerRight THEN        place.x ¬ (place.x + 1) - dims.w;      IF corner = lowerLeft OR corner = lowerRight THEN        place.y ¬ (place.y + 1) - dims.h;      place ¬ tool.limitProc[        window, [        [oldPlace.x + place.x, oldPlace.y + place.y], window.GetBox.dims]].place;      IF ABS[place.x - oldPlace.x] > fuzz OR ABS[place.y - oldPlace.y] > fuzz THEN        window.Slide[place]};    window.ValidateTree;    Window.rootWindow.ValidateTree};  DoSize: PROC [window: Window.Handle, tool: Stuff] = {    ToolWindow.MakeSize[window, IF tool.size = tiny THEN normal ELSE tiny];    Window.rootWindow.ValidateTree};  DoTopBottom: PROC [    window: Window.Handle, tool: Stuff, goal: TopBottomGoal] = {    SELECT goal FROM      top =>        IF window.GetParent.GetChild # window THEN          window.Stack[window.GetParent.GetChild];      bottom => IF window.GetSibling # NIL THEN window.Stack[NIL];      ENDCASE =>        window.Stack[          IF window.ObscuredBySibling[] --not on top-- THEN          window.GetParent.GetChild ELSE NIL];    Window.rootWindow.ValidateTree};  DoZoomUnzoom: PROC [window: Window.Handle, tool: Stuff] = {    ToolWindow.MakeSize[window, IF tool.size = zoomed THEN normal ELSE zoomed]};  GrowWindow: PUBLIC PROC [    window: Window.Handle, box: Window.Box, stack: Stack, gravity: Window.Gravity,    tool: Stuff, clip: Window.Handle ¬ NIL] = {    clippingWindow: Window.Handle ¬ IF clip = NIL THEN window.GetChild ELSE clip;    IF tool.size # tiny AND tool.adjustProc # NIL AND clip = NIL THEN      tool.adjustProc[window, [[0, 0], ClippingBox[window, box].dims], before];    IF tool.gravity # nw THEN window.InvalidateBox[      box: [[0, 0], [box.dims.w, WindowFont.FontHeight[]]]];    window.SlideAndSizeAndStack[      newBox: box,      newSibling:      SELECT stack FROM        top =>          IF window.GetParent.GetChild = window THEN window.GetSibling          ELSE window.GetParent.GetChild,        bottom => NIL,        ENDCASE => window.GetSibling,  -- stack = same      gravity: gravity];    SetClippingBox[window, clippingWindow, gravity];    IF tool.size # tiny AND tool.adjustProc # NIL THEN      tool.adjustProc[window, [[0, 0], clippingWindow.GetBox.dims], after];    IF clip # NIL THEN clip.InsertIntoTree[];    window.ValidateTree;    Window.rootWindow.ValidateTree};  MoveGrowMCR: Menu.MCRType = {    ENABLE UNWIND => NULL;    corner: CornerSide;    doing: MoveGrow;    tool: Stuff;    cursorCopy: Cursor.Object;    [window, tool] ¬ ToolWindowAndStuff[window];    IF tool = NIL THEN RETURN;    IF tool.size = tiny THEN RETURN;    Cursor.Fetch[@cursorCopy];    oldCursor ¬ cursorCopy;    SELECT index FROM      0 => {doing ¬ move; corner ¬ upperLeft};      1 => {doing ¬ grow; corner ¬ upperLeft};      2 => {doing ¬ drag; corner ¬ lowerSide};      ENDCASE => ERROR;    EnterBackDoor[window, corner, window.BitmapPlace[], doing, tool]};  OtherMCR: Menu.MCRType = {    tool: Stuff;    [window, tool] ¬ ToolWindowAndStuff[window];    IF tool = NIL THEN RETURN;    SELECT index FROM      3 => DoSize[window, tool];      4 => DoTopBottom[window, tool, top];      5 => DoTopBottom[window, tool, bottom];      6 => DoZoomUnzoom[window, tool];      7 => [] ¬ ToolWindow.Deactivate[window];      ENDCASE => ERROR};  StandardLimitProc: PUBLIC ToolWindow.LimitProcType = {    Limit: PROC [oldStart, oldSize, newStart, newSize, max, min: INTEGER]      RETURNS [start, size: INTEGER] = {      size ¬ MAX[newSize, min];      start ¬ MIN[newStart, max - min];      IF oldStart = newStart THEN {        IF oldSize = newSize THEN NULL        ELSE IF newStart + newSize > max THEN size ¬ max - newStart}      ELSE {        IF oldSize = newSize THEN {          IF newStart < 0 THEN start ¬ 0          ELSE IF newStart + newSize > max THEN start ¬ max - newSize}        ELSE IF newStart < 0 THEN {start ¬ 0; size ¬ oldStart + oldSize}};      IF size > max THEN {start ¬ start - (size - max); size ¬ max};      IF start + size > max THEN start ¬ max - size;      IF start < 0 THEN start ¬ 0};    [box.place.x, box.dims.w] ¬ Limit[      window.GetBox.place.x, window.GetBox.dims.w, box.place.x, box.dims.w,      Window.rootWindow.GetBox.dims.w, TajoOps.tinyWidth];    [box.place.y, box.dims.h] ¬ Limit[      window.GetBox.place.y, window.GetBox.dims.h, box.place.y, box.dims.h,      Window.rootWindow.GetBox.dims.h, TajoOps.tinyHeight];    RETURN[box]};  SetBox: PUBLIC PROC [window: Window.Handle, box: Window.Box] = {    tool: Stuff;    [window, tool] ¬ ToolWindowAndStuff[window];    IF tool = NIL THEN RETURN;    SELECT tool.size FROM      tiny => tool.tinyBox ¬ tool.limitProc[window, box];      ENDCASE => {        IF window.GetBox = box THEN RETURN;        IF tool.size = zoomed THEN [] ¬ TakeDownZoomed[window, tool];        GrowWindow[	  window: window, box: box, stack: same, 	  gravity: tool.gravity, tool: tool, clip: NIL]}};  -- NameFrame TIP Notification Routines  Invert: PROC [window: Window.Handle, place: Window.Place, tool: Stuff] = {    height: INTEGER = WindowFont.FontHeight[] - 2;    piece: INTEGER = window.GetBox.dims.w/3;    newThird: Thirds =      IF place.y > height THEN menu      ELSE        SELECT place.x FROM          IN [0..piece] => first,          IN (piece..2*piece] => second,          IN (2*piece..window.GetBox.dims.w) => third,          ENDCASE => nope;    IF newThird # tool.lastThird THEN {      InvertThird[window, tool.lastThird, height, piece, tool];      InvertThird[window, newThird, height, piece, tool];      tool.lastThird ¬ newThird}};  InvertThird: PUBLIC PROC [    window: Window.Handle, t: Thirds, height, piece: INTEGER, tool: Stuff] = {    box: Window.Box ¬ [[x:, y: 1], [w:, h: height]];    SELECT t FROM      first => {box.place.x ¬ 1; box.dims.w ¬ piece};      second => {box.place.x ¬ piece + 1; box.dims.w ¬ piece};      third => {        box.place.x ¬ 2*piece + 1;        box.dims.w ¬ window.GetBox.dims.w - 2*piece - 2};      ENDCASE => RETURN;    Display.Invert[window: window, box: box]};  EnterNameFrame: PROC [    window: Window.Handle, place: Window.Place, tool: Stuff] = {    ENABLE UNWIND => NULL;    IF place.y <= WindowFont.FontHeight[] + 2 OR tool.size = tiny THEN      CursorSet[bullseye];    Invert[window, place, tool]};  ExitNameFrame: PROC [    window: Window.Handle, place: Window.Place, tool: Stuff] = {    ENABLE UNWIND => NULL; ClearInvert[window, tool]; CursorPutBack[]};      ClearInvert: PROC [window: Window.Handle, tool: Stuff] = {    Invert[window, [-1, 0], tool]};  -- turn it all black      CursorSet: PROC [type: Cursor.Defined] = {    putBackCursorType ¬ Cursor.GetInfo[].type; Cursor.Set[type]};  CursorPutBack: PROC = {    IF putBackCursorType ~IN Cursor.Defined THEN putBackCursorType ¬ questionMark;    Cursor.Set[putBackCursorType]};  DoSimpleFunction: PROC [window: Window.Handle, button: Button, tool: Stuff] = {    saveThird: Thirds = tool.lastThird;    ClearInvert[window, tool]; -- changes tool.lastThird    SELECT TRUE FROM      button = adjust => DoSize[window, tool];      saveThird = second => DoZoomUnzoom[window, tool];  -- button = point      saveThird = first, saveThird = third => DoTopBottom[window, tool, switch];      ENDCASE;    SpecialUserInput.EnqueueMagicMouseEvent[]};  DoMoveGrow: PROC [    window: Window.Handle, place: Window.Place, tool: Stuff] = {    IF currentlyDoing = move THEN      DoMove[window, place, currentCornerSide, tool]    ELSE DoGrow[window, place, currentCornerSide, tool];    ExitBackDoor[window, place]};  StartFloat: ENTRY PROC [    window: Window.Handle, place: Window.Place, tool: Stuff] = {    EnterBackDoor[window, upperLeft, place, move, tool];    keepOnFloating ¬ TRUE;    floatPlace ¬ place;    floatRunning ¬ TRUE;    floatProcess ¬ FORK DoFloat[window, tool]};      StopFloat: ENTRY PROC [    window: Window.Handle, place: Window.Place] = {    keepOnFloating ¬ FALSE;    NOTIFY floatCondition;    WHILE floatRunning DO WAIT floatCondition ENDLOOP;    JOIN floatProcess;    ExitBackDoor[window, place]};      EnterBackDoor: PROC [    window: Window.Handle, cornerSide: CornerSide, place: Window.Place,    doing: MoveGrow, tool: Stuff] = {    cursorCopy: Cursor.Object;    ClearInvert[window, tool];    Cursor.Fetch[@cursorCopy];    oldCursor ¬ cursorCopy;    TIP.NewManager[window, tip, TIPMe];    backDoor ¬ TRUE;    wasDrag ¬ FALSE;    currentlyDoing ¬ doing;    currentCornerSide ¬ cornerSide;    MakeCursor[window, cornerSide, place]};      ExitBackDoor: PROC [window: Window.Handle, place: Window.Place] = {    cursorCopy: Cursor.Object ¬ oldCursor;    TIP.NewManager[NIL, NIL, NIL];    backDoor ¬ FALSE;    Cursor.Store[@cursorCopy]};      -- Local Procedures  ComputeCorner: PROC [    window: Window.Handle, old: CornerSide, pos: Window.Place, wasDrag: BOOLEAN]    RETURNS [CornerSide] = {    OPEN UserTerminal;    dims: Window.Dims = window.GetBox.dims;    screen: Window.Place = window.BitmapPlace[pos];    margin: INTEGER = 16;  -- > 15 makes sure it works for full bitmap    upper: BOOLEAN = pos.y <= 0 OR screen.y < margin;    lower: BOOLEAN = pos.y >= dims.h OR screen.y >= screenHeight - margin;    left: BOOLEAN = pos.x <= 0 OR screen.x < margin;    right: BOOLEAN = pos.x >= dims.w OR screen.x >= screenWidth - margin;    lastUpper: BOOLEAN = old = upperRight OR old = upperLeft;    lastLower: BOOLEAN = old = lowerRight OR old = lowerLeft;    lastLeft: BOOLEAN = old = upperLeft OR old = lowerLeft;    lastRight: BOOLEAN = old = upperRight OR old = lowerRight;    RETURN[      SELECT TRUE FROM        (upper AND left) => upperLeft,        (lower AND left) => lowerLeft,        (upper AND right) => upperRight,        (lower AND right) => lowerRight,        (upper AND lastLower) => IF lastLeft THEN upperLeft ELSE upperRight,        (lower AND lastUpper) => IF lastLeft THEN lowerLeft ELSE lowerRight,        (left AND lastRight) => IF lastUpper THEN upperLeft ELSE lowerLeft,        (right AND lastLeft) => IF lastUpper THEN upperRight ELSE lowerRight,        ENDCASE => IF wasDrag THEN old ¬ ComputeMoveCorner[window, pos] ELSE old]};  ComputeMoveCorner: PROC [window: Window.Handle, pos: Window.Place]    RETURNS [CornerSide] = {    OPEN UserTerminal;    dims: Window.Dims = window.GetBox.dims;    screen: Window.Place = window.BitmapPlace[pos];    margin: INTEGER = 16;  -- > 15 makes sure it works for full bitmap    upper: BOOLEAN = pos.y <= dims.h/2 OR screen.y < margin;    lower: BOOLEAN = pos.y > dims.h/2 OR screen.y >= screenHeight - margin;    left: BOOLEAN = pos.x <= dims.w/2 OR screen.x < margin;    right: BOOLEAN = pos.x > dims.w/2 OR screen.x >= screenWidth - margin;    RETURN[      SELECT TRUE FROM        (upper AND left) => upperLeft,        (lower AND left) => lowerLeft,        (upper AND right) => upperRight,        (lower AND right) => lowerRight,        ENDCASE => ERROR]};  ComputeSide: PROC [    window: Window.Handle, old: CornerSide, pos: Window.Place]    RETURNS [CornerSide] = {    OPEN UserTerminal;    dims: Window.Dims = window.GetBox.dims;    screen: Window.Place = window.BitmapPlace[pos];    margin: INTEGER = 16;  -- > 15 makes sure it works for full bitmap    upper: BOOLEAN = pos.y <= 0 OR screen.y < margin;    lower: BOOLEAN = pos.y >= dims.h OR screen.y >= screenHeight - margin;    left: BOOLEAN = pos.x <= 0 OR screen.x < margin;    right: BOOLEAN = pos.x >= dims.w OR screen.x >= screenWidth - margin;    RETURN[      SELECT TRUE FROM        upper => upperSide,        lower => lowerSide,        left => leftSide,        right => rightSide,        (old = upperRight) => IF right THEN rightSide ELSE upperSide,        (old = lowerRight) => IF right THEN rightSide ELSE lowerSide,        (old = upperLeft) => IF left THEN leftSide ELSE upperSide,        (old = lowerLeft) => IF left THEN leftSide ELSE lowerSide,        ENDCASE => old]};  MakeCursor: PROC [    window: Window.Handle, cs: CornerSide, place: Window.Place] = {    m: Cursor.Object = [      info: [type: myCursorType, hotX: 7, hotY: 7],      array: [        000000B, 000000B, 000000B, 014030B, 016070B, 017170B, 017770B, 015730B,        014630B, 014030B, 014030B, 014030B, 014030B, 000000B, 000000B, 000000B]];    g: Cursor.Object = [      info: [type: myCursorType, hotX: 7, hotY: 7],      array: [        000000B, 000000B, 000000B, 003740B, 007760B, 006060B, 014000B, 014370B,        014370B, 014030B, 006060B, 007760B, 003740B, 000000B, 000000B, 000000B]];    cursor: Cursor.Object;    SELECT currentlyDoing FROM      move => {	cursor ¬ m; currentCornerSide ¬ ComputeCorner[window, cs, place, wasDrag]};      grow => {	cursor ¬ g; currentCornerSide ¬ ComputeCorner[window, cs, place, wasDrag]};      drag => {	currentCornerSide ¬ ComputeSide[window, cs, place];	Cursor.FetchFromType[@cursor, SELECT currentCornerSide FROM          upperSide => pointUp,          lowerSide => pointDown,          leftSide => pointLeft,          rightSide => pointRight,          ENDCASE => ERROR]};      ENDCASE;    StoreCornerSideCursor[@cursor, currentCornerSide];    wasDrag ¬ FALSE};      wasDrag: BOOLEAN ¬ FALSE;  currentlyDoing: MoveGrow;  currentCornerSide: CornerSide;  DoFloat: PROC [window: Window.Handle, tool: Stuff] = {    NewPlace: ENTRY PROC [window: Window.Handle]      RETURNS [Window.Place, BOOLEAN] = {      IF keepOnFloating THEN WAIT floatCondition;      RETURN[        tool.limitProc[window, [floatPlace, window.GetBox.dims]].place,        ~keepOnFloating]};    temp: Window.Handle;    CursorSet[blank];    Cursor.MoveIntoWindow[window, [0, 0]];    temp ¬ TajoOps.AllocateWindow[bitmapUnder: TRUE];    temp.InitializeWindow[display: NIL, box: window.GetBox[], under: TRUE];    [] ¬ window.SetBitmapUnder[windowBU1];    [] ¬ temp.SetBitmapUnder[windowBU2];    window.Float[temp, NewPlace];    [] ¬ temp.SetBitmapUnder[NIL];    [] ¬ window.SetBitmapUnder[NIL];    TajoOps.DeallocateWindow[temp];    CursorPutBack[];    floatRunning ¬ FALSE;    {Notify: ENTRY PROC = INLINE {NOTIFY floatCondition}; Notify[]}};  Track: ENTRY PROC [window: Window.Handle, place: Window.Place, tool: Stuff] = {    IF tool.size = tiny THEN {      floatPlace ¬ window.BitmapPlace[place]; NOTIFY floatCondition}    ELSE MakeCursor[window, currentCornerSide, place]};  AdvanceCornerSide: PROC [window: Window.Handle, place: Window.Place] = {    currentlyDoing ¬ SELECT currentlyDoing FROM      move => grow, grow => drag, drag => move, ENDCASE => ERROR;    IF currentlyDoing = move THEN wasDrag ¬ TRUE;    MakeCursor[window, currentCornerSide, place]};  ToolWindowAndStuff: PROC [window: Window.Handle]    RETURNS [tw: Window.Handle, tool: Stuff] = {    FOR tw ¬ window, tw.GetParent UNTIL tw.GetParent = Window.rootWindow DO      ENDLOOP;    tool ¬ Context.Find[stuff, tw]};  -- Cursor stuff  AddCursorCorner: PROC [cursorHandle: Cursor.Handle, cornerSide: CornerSide] = {    OPEN Inline;    i: CARDINAL [0..15];    SELECT cornerSide FROM      upperLeft => {        cursorHandle.info.hotX ¬ cursorHandle.info.hotY ¬ 0;        cursorHandle.array[0] ¬ 177777B;        cursorHandle.array[1] ¬ 177777B;        FOR i IN [2..16) DO          cursorHandle.array[i] ¬ BITOR[cursorHandle.array[i], 140000B]; ENDLOOP};      upperRight => {        cursorHandle.info.hotX ¬ 15;        cursorHandle.info.hotY ¬ 0;        cursorHandle.array[0] ¬ 177777B;        cursorHandle.array[1] ¬ 177777B;        FOR i IN [2..16) DO          cursorHandle.array[i] ¬ BITOR[cursorHandle.array[i], 000003B]; ENDLOOP};      lowerLeft => {        cursorHandle.info.hotX ¬ 0;        cursorHandle.info.hotY ¬ 15;        cursorHandle.array[14] ¬ 177777B;        cursorHandle.array[15] ¬ 177777B;        FOR i IN [0..14) DO          cursorHandle.array[i] ¬ BITOR[cursorHandle.array[i], 140000B]; ENDLOOP};      lowerRight => {        cursorHandle.info.hotX ¬ cursorHandle.info.hotY ¬ 15;        cursorHandle.array[14] ¬ 177777B;        cursorHandle.array[15] ¬ 177777B;        FOR i IN [0..14) DO          cursorHandle.array[i] ¬ BITOR[cursorHandle.array[i], 000003B]; ENDLOOP};      upperSide => {        cursorHandle.array[0] ¬ 177777B;        cursorHandle.array[1] ¬ 177777B};      lowerSide => {        cursorHandle.array[14] ¬ 177777B;        cursorHandle.array[15] ¬ 177777B};      leftSide => {        FOR i IN [0..16) DO          cursorHandle.array[i] ¬ BITOR[cursorHandle.array[i], 140000B]; ENDLOOP};      rightSide => {        FOR i IN [0..16) DO          cursorHandle.array[i] ¬ BITOR[cursorHandle.array[i], 000003B]; ENDLOOP};      ENDCASE};  StoreCornerSideCursor: PROC [    cursorHandle: Cursor.Handle, cornerSide: CornerSide] = {    temp: Cursor.Object ¬ cursorHandle­;    AddCursorCorner[@temp, cornerSide];    Cursor.Store[@temp]};  -- Active/Inactive Menu procedures  ActivateMCR: Menu.MCRType = {ToolWindow.Activate[inactive.windows[index]]};  TakeDownInactiveMenu: INTERNAL PROC = {    IF inactive.count > 0 THEN {      Menu.Uninstantiate[inactive.menu, Window.rootWindow];      Menu.Destroy[inactive.menu]};    inactive.menu ¬ NIL};  PutUpInactiveMenu: INTERNAL PROC = {    IF inactive.count > 0 THEN {      inactive.menu ¬ Menu.Create[        DESCRIPTOR[@inactive.items[0], inactive.count], "Inactive"L];      Menu.Instantiate[inactive.menu, Window.rootWindow]}};  PutOnDeactiveMenu: PUBLIC ENTRY PROC [window: Window.Handle, tool: Stuff] = {    ENABLE UNWIND => NULL;    i: CARDINAL;    TakeDownInactiveMenu[];    IF inactive.count = inactive.windows.length THEN {      heap: UNCOUNTED ZONE = Heap.systemZone;      newLength: CARDINAL = inactive.windows.length + inactiveLengthIncrement;      newWs: LONG POINTER TO WindowSequence = heap.NEW[WindowSequence [newLength]];      newItems: LONG POINTER TO ItemSequence = heap.NEW[ItemSequence [newLength]];      FOR i IN [0..inactive.count) DO        newItems[i] ¬ inactive.items[i]; newWs[i] ¬ inactive.windows[i]; ENDLOOP;      heap.FREE[@inactive.items];      heap.FREE[@inactive.windows];      inactive.items ¬ newItems;      inactive.windows ¬ newWs};    inactive.windows[inactive.count] ¬ window;    inactive.items[inactive.count] ¬ [      ToolWindow.GetInactiveName[window], ActivateMCR];    inactive.count ¬ inactive.count + 1;    PutUpInactiveMenu[]};  TakeOffDeactiveMenu: PUBLIC ENTRY PROC [window: Window.Handle, tool: Stuff] = {    ENABLE UNWIND => NULL;    which, i: CARDINAL;    FOR i IN [0..inactive.count) DO      IF inactive.windows[i] = window THEN {which ¬ i; EXIT};      REPEAT FINISHED => RETURN      ENDLOOP;    TakeDownInactiveMenu[];    Heap.systemZone.FREE[@inactive.items[which].keyword];    inactive.count ¬ inactive.count - 1;    FOR i IN [which..inactive.count) DO      inactive.items[i] ¬ inactive.items[i + 1];      inactive.windows[i] ¬ inactive.windows[i + 1];      ENDLOOP;    PutUpInactiveMenu[]};  -- Mainline Code  InitTip[];  inactive ¬ [    count: 0, menu: NIL,    windows: Heap.systemZone.NEW[WindowSequence [inactiveLengthIncrement]],    items: Heap.systemZone.NEW[ItemSequence [inactiveLengthIncrement]]];  END.
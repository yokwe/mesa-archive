-- Copyright (C) 1981, 1982  by Xerox Corporation. All rights reserved. -- file: TextDisplaysC.mesa - last edited by:-- PXK    ,	22-Oct-81 13:28:44-- SXW   ,	 9-Jul-81 22:38:07-- Mark,	 2-Mar-81  8:54:53-- JGS,		19-Aug-81  7:31:51-- AXD    ,	29-Sep-82 20:12:18-- contains Top level and incremental display updating stuffDIRECTORY  BitBlt USING [BitBltFlags, DstFunc, SrcFunc],  Display USING [textFlags],  Environment USING [Block],  TextDisplay USING [    CharsInLine, CharsToRead, CheckBoxHeight, Handle, LastLine, LineFromY,    LinesInBox, LineStartPlace, LineTable, MarkPlaceInterval, NewLineTable,    PlaceFromPosition, PositionIsVisible, Selection, Update,    WindowPlaceFromPosition],  TextSink USING [BreakReason, Display, Handle, Measure, Positions, Resolve],  TextSource USING [Class, Handle, nullPosition, Position],  Window USING [Box, GetBox, Handle, Place];TextDisplaysC: PROGRAM IMPORTS TextDisplay, TextSink, Window EXPORTS TextDisplay =  BEGIN OPEN Disp: Display, TextDisplay, TextSource;  -- Definitions  charFudge: CARDINAL = 20B;  -- Interface Procedures  Bold: PUBLIC PROCEDURE [    p: TextDisplay.Handle, left, right: Position, select: TextDisplay.Selection] =    BEGIN    line: CARDINAL = p.PlaceFromPosition[left, FALSE].line;    leftPlace: Window.Place = p.WindowPlaceFromPosition[left, TRUE, FALSE];    rightPlace: Window.Place = p.WindowPlaceFromPosition[right, TRUE, FALSE];    IF leftPlace.y # rightPlace.y THEN RETURN;  -- ignore for now    DisplayPartialLine[p, line, leftPlace.x, rightPlace.x + 1, select, TRUE];    END;  Display: PUBLIC PROCEDURE [    p: TextDisplay.Handle, select: TextDisplay.Selection,    alterW, alterH: BOOLEAN ¬ FALSE] =    BEGIN    sink: TextSink.Handle = p.sink;    source: TextSource.Handle = p.source;    lines: CARDINAL;    -- guarantees redisplay of the entire contents     topPosition: Position ¬ MIN[p.lineTable[0].pos, source.getLength[source]];    lines ¬      IF alterH THEN      IF p.box.place.y IN [-sink.fontInfo[sink].lineHeight..p.wh.GetBox.dims.h]      THEN p.LinesInBox[p.wh.GetBox] ELSE 1 ELSE p.LinesInBox[p.box];    p.lineTable ¬ TextDisplay.NewLineTable[p.lineTable, lines, FALSE];    p.lineTable[0].pos ¬ topPosition;    p.Update[p.lineTable[0].pos, source.getLength[source], select, FALSE];    lines ¬ TextDisplay.LastLine[p.lineTable] + 1;    IF alterH THEN      BEGIN      UNTIL p.PositionIsVisible[source.getLength[source]] DO        lines ¬ lines + 100;        p.box.dims.h ¬ sink.fontInfo[sink].lineHeight*lines;        p.lineTable ¬ TextDisplay.NewLineTable[p.lineTable, lines, TRUE];        p.Update[          p.lineTable.lastPositionPlusOne, source.getLength[source], select,          FALSE];        ENDLOOP;      lines ¬ TextDisplay.LastLine[p.lineTable] + 1;      IF lines # p.lineTable.length THEN        p.lineTable ¬ TextDisplay.NewLineTable[p.lineTable, lines, TRUE];      p.box.dims.h ¬        p.lineTable.length*sink.fontInfo[sink].lineHeight + 2*p.options.margin;      END;    IF alterW AND p.lineTable.length = 1 THEN      BEGIN      place: Window.Place = p.WindowPlaceFromPosition[        p.lineTable.lastPositionPlusOne, TRUE, FALSE];      p.box.dims.w ¬ place.x + p.options.margin - p.box.place.x;      END;    p.allBetsAreOff ¬ FALSE;    IF ~alterH AND p.options.bottomAction = signal THEN p.CheckBoxHeight[select];    END;  Redisplay: PUBLIC PROCEDURE [    p: TextDisplay.Handle, boxToFill: Window.Box, select: TextDisplay.Selection]    RETURNS [boxFilled: Window.Box] =    BEGIN    -- to be called by item potent display procedure    -- Paints text and marks that portion of the selection that is    -- contained in the passed boxToFill    j, top, bottom: CARDINAL;    leftX: INTEGER = MAX[boxToFill.place.x, p.box.place.x];    rightX: INTEGER = MIN[      p.box.place.x + p.box.dims.w,        boxToFill.place.x + boxToFill.dims.w + charFudge];    IF p.allBetsAreOff OR p.source.getLength[p.source] < p.lineTable[0].pos THEN      BEGIN Display[p, select]; boxFilled ¬ p.box; END    ELSE      IF leftX < rightX THEN        BEGIN        top ¬ p.LineFromY[boxToFill.place.y];        bottom ¬ p.LineFromY[boxToFill.place.y + boxToFill.dims.h];        FOR j IN [top..bottom] DO          IF p.lineTable[j].pos = nullPosition THEN EXIT;          DisplayPartialLine[p, j, leftX, rightX, select];          ENDLOOP;        boxFilled ¬ boxToFill;  -- can do better later!        END;    END;  -- Utility routines  DisplayPartialLine: PROCEDURE [    p: TextDisplay.Handle, line: CARDINAL, leftX, rightX: INTEGER,    s: TextDisplay.Selection, bold: BOOLEAN ¬ FALSE] =    BEGIN    -- assumes line table entry is valid    -- NOTE: readText is allowed to both read more and less than asked for.     -- Funny checks on ss.length are to ensure that exact # of chars    -- in this line displayed.    positionsToRead, nMeasured: CARDINAL;    positionsInLine: CARDINAL ¬ p.CharsInLine[line];    width: INTEGER;    block: Environment.Block;    place: Window.Place;    inSelect: BOOLEAN;    break: TextSink.BreakReason;    source: TextSource.Handle = p.source;    sink: TextSink.Handle = p.sink;    ReadSomeTextInLine: PROCEDURE =      BEGIN      [inSelect, positionsToRead] ¬ TextDisplay.CharsToRead[position, s];      positionsToRead ¬ MIN[positionsInLine, positionsToRead];      [block, next] ¬ source.readText[source, position, positionsToRead, none];      positionsInLine ¬        positionsInLine - (block.stopIndexPlusOne - block.startIndex);      END;    position: Position ¬ p.lineTable[line].pos;    next: Position;    place ¬ p.LineStartPlace[line];    IF bold THEN place.x ¬ place.x + 1;    DO      ReadSomeTextInLine[];      [place.x, nMeasured, break] ¬ sink.Resolve[        block: @block, startX: place.x, xToFind: leftX, offset: p.box.place.x,        halfCharResolve: FALSE];      position ¬ position + nMeasured;      SELECT break FROM        consumed =>          IF positionsInLine = 0 OR position = source.getLength[source] THEN EXIT          ELSE position ¬ next;        eol => {          [newPlace: place, positions: nMeasured, why: break] ¬ sink.Measure[            block: @block, lineLength: rightX - place.x, offset: p.box.place.x,            place: place];          position ¬ position + nMeasured;          EXIT};        margin => EXIT;        ENDCASE => ERROR;      ENDLOOP;    IF sink.Positions[@block] # 0 THEN      DO        IF (width ¬ rightX - place.x) > 0 THEN          BEGIN          nDisplayed: CARDINAL;          startPlace: Window.Place ¬ place;          flags: BitBlt.BitBltFlags ¬ Disp.textFlags;          IF inSelect THEN flags.dstFunc ¬ null;          IF s # NIL AND inSelect AND s.mode = video THEN            flags.srcFunc ¬ complement;          [place, nDisplayed, break] ¬ sink.Display[            block: @block, lineLength: width, offset: p.box.place.x, window: p.wh,            place: startPlace, flags: flags];          position ¬ position + nDisplayed;          IF s # NIL AND inSelect THEN            SELECT TRUE FROM              s.mode # video => p.MarkPlaceInterval[startPlace, place, s.mode, 0];              break = margin =>                p.MarkPlaceInterval[place, [x: rightX, y: place.y], video, 0];              ENDCASE;          END;        IF place.x + charFudge >= rightX THEN EXIT;        SELECT break FROM          consumed =>            IF positionsInLine = 0 OR position >= source.getLength[source] THEN              EXIT;          eol => EXIT;          margin => EXIT;          ENDCASE => ERROR;        position ¬ next;        ReadSomeTextInLine[];        ENDLOOP;    END;  END. -- of TextDisplayC.mesa
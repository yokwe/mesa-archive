-- File: TIPMatchImpl.mesa - last edit:-- Riggle.PA           24-Jul-86 11:04:44-- McGregor,	May 17, 1982 1:03 pm-- PLK    ,	25-Feb-83 16:28:36-- CEH   ,	 1-Dec-82 11:12:23-- JGS,		15-Nov-82 17:10:43-- AMD    ,	11-Feb-83 16:59:01-- DWR    	18-Sep-85 15:16:44-- Copyright (C) 1982, 1983 , 1986, 1986, 1986, 1986, 1986, 1986 by Xerox Corporation. All rights reserved. DIRECTORY  Context: TYPE USING [Find],  Cursor: TYPE USING [Set],  Keys: TYPE USING [DownUp, KeyBits, KeyName],  LevelVKeys: TYPE USING [KeyBits, KeyName],  Menu: TYPE USING [Invoke],  Process: TYPE USING [    Detach, EnableAborts, GetCurrent, MsecToTicks, priorityForeground, SetPriority, SetTimeout, Ticks],  ProcessPriorities: TYPE USING [priorityClientHigh],  Put: TYPE USING [Line],  SpecialTIP: TYPE USING [],  SpecialUserInput: TYPE USING [    Acceptance, ActionBody, ActionKind, ConsumeTo, Copy, Coords, CreateQueues,    EnqueueMagicMouseEvent, FlushQueue, GetAction, GetMouseEvent, Queue,    QueueEmpty, QueueSequence],  System: TYPE USING [Pulses],  TajoOps: TYPE USING [],  TIP: TYPE USING [    NotifyProc, Results, ResultElement, ResultsList, Table, TableObject],  TIPOps: TYPE USING [Client, ClientObject, tipContext],  TIPTable: TYPE USING [    Choice, KeyStateList, Results, ResultsObject, Table, TableObject, Term],  UserInputOps: TYPE USING [    CharForKey, PeriodicNotifyEntry, PeriodicNotifyHandle, z],  UserInput: TYPE USING [    ErrorCode, FocusTakesInput, GetInputFocus, noSuchCharacter,    nullPeriodicNotify, PeriodicProcType, ResetUserAbort],  Window: TYPE USING [BitmapPlace, BitmapPlaceToWindowAndPlace, Handle, Place],  UserTerminal: TYPE USING [BlinkDisplay, Coordinate, keyboard];TIPMatchImpl: MONITOR  IMPORTS    Context, Cursor, Menu, Process, Put, SpecialUserInput, TIPOps,    UserInput, UserInputOps, UserTerminal, Window  EXPORTS SpecialTIP, TajoOps, TIP, TIPOps, UserInput, UserInputOps =  BEGIN  zone: UNCOUNTED ZONE = UserInputOps.z;    DownUp: TYPE = Keys.DownUp;  KeyName: TYPE = Keys.KeyName;  QueueSequence: TYPE = SpecialUserInput.QueueSequence;  stackSize: CARDINAL = 10;  queues: QueueSequence ¬ SpecialUserInput.CreateQueues[stackSize];  Results: TYPE = TIPTable.Results;  ResultsList: PUBLIC TYPE = TIPTable.ResultsObject;  Table: TYPE = TIPTable.Table;  TableObject: PUBLIC TYPE = TIPTable.TableObject;  cursorW, focusW: Window.Handle ¬ NIL;  cursorPos: UserTerminal.Coordinate ¬ [0, 0];  actionToWindow: PUBLIC PACKED ARRAY Keys.KeyName OF BOOLEAN ¬ ALL[FALSE];    Manager: TYPE = RECORD [    window: Window.Handle ¬ NIL,    client: TIPOps.ClientObject ¬ [table: NIL, notify: NIL]];  manager: Manager ¬ [];      PeriodicProcType: TYPE = UserInput.PeriodicProcType;  nullPeriodicNotify: PeriodicNotifyHandle = UserInput.nullPeriodicNotify;  PeriodicNotifyHandle: PUBLIC TYPE = UserInputOps.PeriodicNotifyHandle;  PeriodicNotifyPointer: TYPE = LONG POINTER TO UserInputOps.PeriodicNotifyEntry;  pns: LONG POINTER TO PeriodicNotifySequence ¬ zone.NEW[    PeriodicNotifySequence [5]];  PeriodicNotifySequence: TYPE = RECORD [    front, free: PeriodicNotifyHandle,    items: SEQUENCE length: CARDINAL OF UserInputOps.PeriodicNotifyEntry];  periodicNotifyReady: BOOLEAN ¬ FALSE;  periodicCondition: CONDITION;    notifiersRunning: CARDINAL ¬ 0;  lastNotifierStarted: PROCESS ¬ NIL;  -- Results processing  First: PUBLIC ENTRY PROC [results: Results] RETURNS [TIP.ResultElement] = {    RETURN[WITH r: results SELECT FROM      atom => TIP.ResultElement[atom[a: r.a]],      int => TIP.ResultElement[int[i: r.i]],      string => TIP.ResultElement[string[s: r.s]],      time => TIP.ResultElement[time[time: r.t]],      coords => TIP.ResultElement[coords[place: r.xy]],      keys => TIP.ResultElement[keys[keys: r.keys]],      char => TIP.ResultElement[char[c: r.c]],      ENDCASE => ERROR]};        Rest: PUBLIC ENTRY PROC [results: Results] RETURNS [Results] = {    RETURN[results.rest]};        lastPlace: SpecialUserInput.Coords;    GetPlace: PUBLIC ENTRY PROC [window: Window.Handle] RETURNS [Window.Place] = {    place: Window.Place = window.BitmapPlace[];    RETURN[[x: lastPlace.x - place.x, y: lastPlace.y - place.y]]};        Notifier: PUBLIC PROC [resetOnRestart: BOOLEAN ¬ TRUE] = {--    focusW ¬ NIL; ++ so that focusClient gets reset if input focus didn't change.  It should anyway    MuscleIn[]; -- start a new Notifier    NewManager[NIL, NIL, NIL]; -- clear out clogged sinuses    DO      ENABLE {        ABORTED => LOOP;	ReturnToNotifier => {Put.Line[NIL, string]; LOOP};      };      IF MyTimeIsUp[] THEN RETURN; -- other notifies want to run      MatchProcess[Process.GetCurrent[]];    ENDLOOP;  };      Error: PUBLIC ERROR [code: UserInput.ErrorCode] = CODE;  ReturnToNotifier: PUBLIC ERROR [string: LONG STRING] = CODE;    MuscleIn: ENTRY PROC = INLINE {    lastNotifierStarted ¬ Process.GetCurrent[];    notifiersRunning ¬ notifiersRunning + 1;  };    MyTimeIsUp: ENTRY PROC RETURNS [BOOLEAN] = INLINE {    IF Process.GetCurrent[] # lastNotifierStarted THEN {      notifiersRunning ¬ notifiersRunning - 1;      RETURN [TRUE];    };    RETURN [FALSE];  };  DoKamikazeNotifies: PUBLIC PROC [cursor: Window.Place] = {    proc: PeriodicProcType;    window: Window.Handle;    DO      [proc, window] ¬ GetNextPeriodicCall[TRUE];      IF proc # NIL THEN proc[window, WindowPlace[window, cursor]] ELSE EXIT;      ENDLOOP};   WindowPlace: PROC [window: Window.Handle, bm: Window.Place]    RETURNS [place: Window.Place] = {    place ¬ window.BitmapPlace[];    place.x ¬ bm.x - place.x;    place.y ¬ bm.y - place.y};      DoNextPeriodicCall: PUBLIC PROC [cursor: Window.Place] = {    proc: PeriodicProcType;    window: Window.Handle;    [proc, window] ¬ GetNextPeriodicCall[FALSE];    IF proc # NIL THEN proc[window, WindowPlace[window, cursor]]};      CreatePeriodicNotify: PUBLIC ENTRY PROC [    proc: PeriodicProcType, window: Window.Handle, rate: Process.Ticks]    RETURNS [p: PeriodicNotifyHandle] = {    IF pns.free = nullPeriodicNotify THEN {      newPns: LONG POINTER TO PeriodicNotifySequence = zone.NEW[        PeriodicNotifySequence [pns.length + 5]];      newPns.front ¬ pns.front;      newPns.free ¬ pns.length;      FOR i: PeriodicNotifyHandle IN [0..pns.length) DO        newPns[i] ¬ pns[i] ENDLOOP;      FOR i: PeriodicNotifyHandle IN [pns.length..newPns.length - 1) DO        newPns[i].link ¬ i + 1 ENDLOOP;      newPns[newPns.length - 1].link ¬ nullPeriodicNotify;      zone.FREE[@pns];      pns ¬ newPns};    p ¬ pns.free;    pns.free ¬ pns[pns.free].link;    pns[p] ¬ [link:, wait:, proc: proc, window: window, rate: rate];    InsertPeriodicNotifyHandle[p];    IF rate = 0 THEN p ¬ nullPeriodicNotify};      InsertPeriodicNotifyHandle: INTERNAL PROC [p: PeriodicNotifyHandle] = {    prev: PeriodicNotifyHandle ¬ nullPeriodicNotify;    pns[p].wait ¬ pns[p].rate;    FOR next: PeriodicNotifyHandle ¬ pns.front, pns[next].link UNTIL next =      nullPeriodicNotify OR pns[next].wait > pns[p].wait      OR (pns[p].rate = 0 AND pns[next].wait > 0) DO      pns[p].wait ¬ pns[p].wait - pns[next].wait; prev ¬ next; ENDLOOP;    IF prev = nullPeriodicNotify THEN {pns[p].link ¬ pns.front; pns.front ¬ p}    ELSE {pns[p].link ¬ pns[prev].link; pns[prev].link ¬ p};    IF pns[p].link # nullPeriodicNotify THEN      pns[pns[p].link].wait ¬ pns[pns[p].link].wait - pns[p].wait;    NOTIFY periodicCondition};      CancelPeriodicNotify: PUBLIC ENTRY PROC [p: PeriodicNotifyHandle]    RETURNS [nil: PeriodicNotifyHandle] = {    prev: PeriodicNotifyHandle ¬ nullPeriodicNotify;    IF p = nullPeriodicNotify THEN RETURN[nullPeriodicNotify];    FOR next: PeriodicNotifyHandle ¬ pns.front, pns[next].link UNTIL next =      nullPeriodicNotify DO      IF next = p THEN {        IF prev = nullPeriodicNotify THEN pns.front ¬ pns[p].link        ELSE pns[prev].link ¬ pns[p].link;        pns[p].link ¬ pns.free;        pns.free ¬ p;        RETURN[nullPeriodicNotify]};      prev ¬ next;      ENDLOOP;    ERROR Error[noSuchPeriodicNotifier]};      GetNextPeriodicCall: ENTRY PROC [zeroRateOnly: BOOLEAN]    RETURNS [proc: PeriodicProcType, window: Window.Handle] = {    p: PeriodicNotifyHandle;    IF ~periodicNotifyReady THEN RETURN[NIL, NIL];    IF (p ¬ pns.front) = nullPeriodicNotify THEN {      periodicNotifyReady ¬ FALSE; RETURN[NIL, NIL]};    IF zeroRateOnly AND pns[p].rate # 0 THEN RETURN[NIL, NIL];    window ¬ pns[p].window;    proc ¬ pns[p].proc;    pns.front ¬ pns[p].link;    IF pns[p].rate > 0 THEN {      periodicNotifyReady ¬ FALSE; InsertPeriodicNotifyHandle[p]}    ELSE {pns[p].link ¬ pns.free; pns.free ¬ p}};      PeriodicNotifyWait: ENTRY PROC = {    longWait: Process.Ticks = 77777B;    lastPeriodicWait: Process.Ticks ¬ 0;    -- helps avoid swapping to do the Process.SetTimeout    DO      WHILE pns.front = nullPeriodicNotify OR periodicNotifyReady DO        IF lastPeriodicWait # longWait THEN          Process.SetTimeout[@periodicCondition, lastPeriodicWait ¬ longWait];        WAIT periodicCondition;        ENDLOOP;      IF pns[pns.front].wait > 0 THEN {        IF lastPeriodicWait # pns[pns.front].wait THEN          Process.SetTimeout[            @periodicCondition, lastPeriodicWait ¬ pns[pns.front].wait];        WAIT periodicCondition};      periodicNotifyReady ¬ TRUE;      ENDLOOP};	  NewManager: PUBLIC PROC [    window: Window.Handle, table: Table, notify: TIP.NotifyProc] = {    manager.window ¬ window;    manager.client.table ¬ table;    manager.client.notify ¬ notify;    IF table = NIL THEN SpecialUserInput.EnqueueMagicMouseEvent[]};  <<SpecialTIP.>>GetManager: PUBLIC PROC RETURNS [    window: Window.Handle, table: Table, notify: TIP.NotifyProc] = {    RETURN[manager.window, manager.client.table, manager.client.notify]};      FlushUserInput: PUBLIC PROC = {SpecialUserInput.FlushQueue[]};  EatAnAction: PROC = {    [] ¬ SpecialUserInput.GetAction[      q: @queues[0], waitMode: forever, acceptance: clicks];    SpecialUserInput.ConsumeTo[@queues[0]]};      WaitForConfirmation: PUBLIC PROC RETURNS [place: Window.Place, okay: BOOLEAN] = {    k: LONG POINTER TO Keys.KeyBits = @queues[0].keys;    okay ¬ TRUE;    WaitNoButtons[];    DO      IF k[Adjust] = down OR k[Menu] = down OR k[Point] = down THEN EXIT;      EatAnAction[];      ENDLOOP;    place ¬ queues[0].place;    DO      IF k[Adjust] = down OR k[Menu] = down THEN okay ¬ FALSE;      IF k[Point] = up AND k[Menu] = up AND k[Adjust] = up THEN EXIT;      EatAnAction[];      ENDLOOP;    RETURN[IF okay THEN place ELSE [0, 0], okay]};        WaitNoButtons: PUBLIC PROC = {    k: LONG POINTER TO Keys.KeyBits = @queues[0].keys;    NewManager[NIL, NIL, NIL];    DO      IF k[Point] = up AND k[Menu] = up AND k[Adjust] = up THEN EXIT;      EatAnAction[];      ENDLOOP};  CheckNewCursorW: PROC [client: POINTER TO TIPOps.Client] = {    cw: Window.Handle = Window.BitmapPlaceToWindowAndPlace[cursorPos].window;    IF client­ = NIL AND cursorW # NIL THEN      client­ ¬ Context.Find[TIPOps.tipContext, cursorW];    IF cw # cursorW THEN {      IF cursorW # NIL THEN        [] ¬ MatchAndNotify[cursorW, client­, queues, [exit[]]];      client­ ¬ Context.Find[TIPOps.tipContext, cw];      IF client­ = NIL THEN cursorW ¬ NIL      ELSE {        cursorW ¬ cw;        Cursor.Set[	  IF UserInput.FocusTakesInput[] THEN textPointer ELSE groundedText];        [] ¬ MatchAndNotify[cursorW, client­, queues, [enter[]]]}}};  MatchProcess: PROC [process: PROCESS] = {    ENABLE UNWIND => {focusW ¬ NIL};    action: SpecialUserInput.ActionBody;    window: Window.Handle ¬ NIL;    focusClient, cursorClient, client: TIPOps.Client ¬ NIL;    Process.SetPriority[Process.priorityForeground];        DO -- FOREVER...(well, almost)      IF manager.client.table = NIL THEN {        CheckNewCursorW[@cursorClient]; DoKamikazeNotifies[queues[0].place]};      IF SpecialUserInput.QueueEmpty[          @queues[0],	  IF periodicNotifyReady	    AND manager.client.table = NIL THEN 0 ELSE 30] THEN {        IF manager.client.table = NIL THEN DoNextPeriodicCall[queues[0].place];        LOOP};      action ¬ SpecialUserInput.GetAction[ -- get a top-level action trigger        q: @queues[0], waitMode: forever, acceptance: clicksAndMotion];      IF manager.client.table # NIL THEN {        window ¬ manager.window; client ¬ @manager.client}      ELSE WITH a: action SELECT FROM        mousePosition => {	  DoNextPeriodicCall[cursorPos ¬ a.place];	  CheckNewCursorW[@cursorClient];	  window ¬ cursorW;	  client ¬ cursorClient};        keyUp, keyDown => {	  IF actionToWindow[a.key] THEN {	    CheckNewCursorW[@cursorClient];	    window ¬ cursorW;	    client ¬ cursorClient}	  ELSE {	    w: Window.Handle = UserInput.GetInputFocus[];	    IF w # focusW ---- OR focusClient = NIL ---- THEN { -- added for TajoDonner	      focusW ¬ w;	      focusClient ¬ Context.Find[TIPOps.tipContext, focusW]};	    window ¬ focusW;	    client ¬ IF focusW = NIL THEN NIL ELSE focusClient}};        ENDCASE => -- not quite EXHAUSTED-- client ¬ NIL;	      IF client = NIL AND action.kind = keyDown THEN        WITH a: action SELECT FROM	  keyDown => IF NOT (	    a.key = CONTROL OR a.key = COMMAND OR a.key = LeftShift	    OR a.key = RightShift) THEN UserTerminal.BlinkDisplay[];	  ENDCASE;      [] ¬ MatchAndNotify[window, client, queues, action, TRUE];      IF process # lastNotifierStarted THEN RETURN; -- doesn't need to be monitored.  It's only a hint    ENDLOOP;  };  MatchAndNotify: PROC [    window: Window.Handle, client: TIPOps.Client, queues: QueueSequence,    action: SpecialUserInput.ActionBody, consume: BOOLEAN ¬ FALSE]    RETURNS [BOOLEAN] = {    results: Results;    notify: TIP.NotifyProc;    table: Table;    [results, table] ¬ MatchEvent[window, client, queues, action];    IF consume THEN SpecialUserInput.ConsumeTo[@queues[0]];    IF results = NIL THEN RETURN[FALSE];    notify ¬ IF table.notifyProc # NIL THEN table.notifyProc ELSE client.notify;    IF notify # NIL THEN {      lastPlace ¬ queues[0].place; -- not affected by ConsumeTo      IF consume THEN WITH a: action SELECT FROM        keyDown => 	  SELECT a.key FROM	     USERABORT, LeftShift, RightShift => NULL;	     ENDCASE => UserInput.ResetUserAbort[window];	ENDCASE;      notify[window, results]};    RETURN[TRUE]};  << The top level parser goes through the list of TIP Tables, picks up the  relevant ones (the ones not to be ignored), and parses the appropriate entry. >>  MatchEvent: PROC [    window: Window.Handle, client: TIPOps.Client, queues: QueueSequence,    action: SpecialUserInput.ActionBody] RETURNS [Results, Table] = {    Choice: TYPE = TIPTable.Choice;    Term: TYPE = TIPTable.Term;    table: Table;    q: SpecialUserInput.Queue; -- everybody works on (copy of some stack element)    qAction: SpecialUserInput.ActionBody; -- another global    firstAccess: BOOLEAN;    advanced: BOOLEAN;    << tells whether the queue on top of the stack has been changed at all    used to eliminate unnecessary copying of stack elements >>    stackPointer: CARDINAL;    ClearQueueStack: PROC = INLINE {stackPointer ¬ 0};    PushQueue: PROC = INLINE {      stackPointer ¬ stackPointer + 1;      SpecialUserInput.Copy[@queues[stackPointer], q];      q ¬ @queues[stackPointer];      advanced ¬ FALSE};    PopQueue: PROC = INLINE {      stackPointer ¬ stackPointer - 1; q ¬ @queues[stackPointer]};    ResetTopQueue: PROC = INLINE { -- this resets the top of stack for next try      IF stackPointer = 0 OR q # @queues[stackPointer] THEN ERROR; -- bear trap      IF advanced THEN {        SpecialUserInput.Copy[q, @queues[stackPointer - 1]];        advanced ¬ FALSE}};    << Unless a second access to the q actions, MatchEvent deals with 0 element    on the stack. The "global" q always points at the top element on the stack    to alleviate the need to do the array dereference. If a match is ever found    (and the queue has been advanced) then the top is copied back down into the    0 element. If no match is found then, the 0 element is just left alone.     All this stack of queues is done to allow MatchChoice to be reentrant and not    change the global state if no match is made. >>       GetNext: PROC [acceptance: SpecialUserInput.Acceptance ¬ clicks] = {      IF firstAccess THEN {        firstAccess ¬ FALSE;        q ¬ @queues[0]; -- the implicit parameter        qAction ¬ action} -- the parameter of MatchEvent      ELSE {        IF stackPointer = 0 THEN PushQueue[];        qAction ¬ SpecialUserInput.GetAction[          q: q, waitMode: forever, acceptance: acceptance];        advanced ¬ TRUE}};    MatchChoice: PROC [term: Term] RETURNS [Results] = {      FOR term ¬ term, term.rest UNTIL term = NIL DO        WITH t: term SELECT FROM	          keyTrigger => {            GetNext[clicks];            WITH ca: qAction SELECT FROM              keyDown =>	        IF t.keyState.key # ca.key OR t.keyState.state # down THEN		  RETURN[NIL];              keyUp =>	        IF t.keyState.key # ca.key OR t.keyState.state # up THEN		  RETURN[NIL];              ENDCASE => RETURN[NIL]}; -- suprise action from Queue          mouseTrigger => {            GetNext[clicksAndMotion];            IF qAction.kind # mousePosition THEN RETURN[NIL];	    IF stackPointer = 0 AND -- top level event	      table.mouseActions = mostRecent THEN DO	        temp: SpecialUserInput.ActionBody;		mouse: BOOLEAN;		[mouse, temp] ¬ SpecialUserInput.GetMouseEvent[q];		IF ~mouse THEN EXIT;		qAction ¬ temp;		WITH a: qAction SELECT FROM		  mousePosition => cursorPos ¬ a.place;		  ENDCASE;		ENDLOOP};          enterTrigger => IF qAction.kind # enter THEN RETURN[NIL];          exitTrigger => IF qAction.kind # exit THEN RETURN[NIL];          timeTrigger => {            IF firstAccess THEN ERROR; -- time events can't be first            -- copy local creek for checking time since no "putback"            PushQueue[];            qAction ¬ SpecialUserInput.GetAction[              q: q, waitMode: timed, waitInterval: t.mSecs, acceptance: clicks];            PopQueue[];	    WITH ca: qAction SELECT FROM              timedOut => IF t.flavor = lt THEN RETURN[NIL];              ENDCASE => IF t.flavor = gt THEN RETURN[NIL]};          keyEnable =>	    IF t.keyState.state # q.keys[t.keyState.key] THEN RETURN[NIL];          keyEnableList =>	    FOR k: TIPTable.KeyStateList ¬ t.list, k.rest UNTIL k = NIL DO	      IF k.keyState.state = q.keys[k.keyState.key] THEN EXIT;	      REPEAT FINISHED => RETURN[NIL];	      ENDLOOP;          char => t.ch.c ¬ AsciiAction[q, qAction];          time => t.t.t ¬ q.time;          coords => {	    wPlace: Window.Place = window.BitmapPlace[];	    t.xy.xy ¬ [q.place.x - wPlace.x, q.place.y - wPlace.y]};           keys => t.keys.keys ¬ @q.keys;           nested => {	    PushQueue[];            FOR choices: Choice ¬ t.statement, choices.rest UNTIL choices = NIL DO              result: Results = MatchChoice[choices.first];              IF result # NIL THEN RETURN[result];              ResetTopQueue[];              ENDLOOP;            PopQueue[];            RETURN[NIL]};          result => {            IF stackPointer # 0 THEN SpecialUserInput.Copy[@queues[0], q];            RETURN[t.list]};          ENDCASE => RETURN[NIL];        ENDLOOP;      RETURN[NIL]};  -- MatchChoice    kind: SpecialUserInput.ActionKind ¬ action.kind;    IF client = NIL THEN RETURN[NIL, NIL];    FOR table ¬ client.table,      IF table.opaque THEN NIL ELSE table.link UNTIL table = NIL DO      SELECT kind FROM  -- for efficiency        mousePosition => IF table.ignoreMove THEN LOOP;        keyDown => IF table.ignoreDown THEN LOOP;        keyUp => IF table.ignoreUp THEN LOOP;        ENDCASE;      firstAccess ¬ TRUE;      ClearQueueStack[];      WITH t: table SELECT FROM        fast => {          result: Results;	  GetNext[];          WITH action: qAction SELECT FROM            mousePosition => {	      IF table.mouseActions = mostRecent THEN DO	        temp: SpecialUserInput.ActionBody;	        mouse: BOOLEAN;		[mouse, temp] ¬ SpecialUserInput.GetMouseEvent[q];		IF ~mouse THEN EXIT;		qAction ¬ temp;		WITH a: qAction SELECT FROM		  mousePosition => cursorPos ¬ a.place;		  ENDCASE;		ENDLOOP;	      result ¬ MatchChoice[t.mouse]};            keyUp => result ¬ MatchChoice[t.keyUp[action.key]];            keyDown => result ¬ MatchChoice[t.keyDown[action.key]];	    enter => result ¬ MatchChoice[t.enter];	    exit => result ¬ MatchChoice[t.exit];            ENDCASE;          IF result # NIL THEN RETURN[result, table]};        small => {	  FOR choices: Choice ¬ t.all, choices.rest UNTIL choices = NIL DO            result: Results = MatchChoice[choices.first];            IF result # NIL THEN RETURN[result, table];            firstAccess ¬ TRUE;            ClearQueueStack[];            ENDLOOP};        ENDCASE;      ENDLOOP;    RETURN[NIL, NIL]};  ChordTableNotify: PUBLIC PROC [window: Window.Handle, results: Results] = {    << This procedure cheats. >>    WITH cr: results SELECT FROM      coords => Menu.Invoke[window, cr.xy];      ENDCASE => UserTerminal.BlinkDisplay[]};    AsciiAction: PROC [    q: SpecialUserInput.Queue, action: SpecialUserInput.ActionBody]    RETURNS [c: CHARACTER] = {    WITH a: action SELECT FROM      keyDown, keyUp => RETURN[UserInputOps.CharForKey[a.key, @q.keys]];      ENDCASE => -- why are they asking for a char?	RETURN[UserInput.noSuchCharacter]};    ClearTargetWindowOnMatch: PUBLIC PROC [window: Window.Handle] = {    IF cursorW = window THEN cursorW ¬ NIL;    IF focusW = window THEN focusW ¬ NIL};      NewNotifierWatcher: PROC = {    timer: CONDITION;    Sleep: ENTRY PROC = {      WAIT timer;    };    Props: LevelVKeys.KeyName = LevelVKeys.KeyName.Props;    Stop: LevelVKeys.KeyName = LevelVKeys.KeyName.Stop;    keyboard: LONG POINTER TO LevelVKeys.KeyBits =      LOOPHOLE[UserTerminal.keyboard];    latched, go: BOOLEAN ¬ FALSE;    Process.SetTimeout[@timer, Process.MsecToTicks[100]];    Process.EnableAborts[@timer];    Process.SetPriority[ProcessPriorities.priorityClientHigh];    DO -- forever      Sleep[];      go ¬ keyboard[Props] = down AND keyboard[Stop] = down;      IF latched THEN latched ¬ go;      IF go AND ~latched THEN {        Process.Detach[FORK Notifier[FALSE]];	latched ¬ TRUE;      };    ENDLOOP;  };  actionToWindow[Point] ¬ TRUE;  actionToWindow[Menu] ¬ TRUE;  actionToWindow[Adjust] ¬ TRUE;  actionToWindow[MENU] ¬ TRUE;  actionToWindow[FIND] ¬ TRUE;  actionToWindow[JFIRST] ¬ TRUE;  actionToWindow[USERABORT] ¬ TRUE;  pns ¬ zone.NEW[PeriodicNotifySequence [5]];  pns.free ¬ 0;  pns.front ¬ nullPeriodicNotify;  FOR i: PeriodicNotifyHandle IN [0..pns.length - 1) DO    pns[i].link ¬ i + 1 ENDLOOP;  pns[pns.length - 1].link ¬ nullPeriodicNotify;  Process.Detach[FORK PeriodicNotifyWait[]];  Process.Detach[FORK NewNotifierWatcher[]];    END.
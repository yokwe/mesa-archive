-- File: MenusB.mesa - last edit:-- Riggle.PA           12-Aug-86 10:27:54-- Copyright (C) 1981, 1982, 1983 , 1986, 1986 by Xerox Corporation. All rights reserved. -- File: [Igor]<Emerson>Tajo>Private>MenusB.mesa - last edited by:-- PXK      	 6-Jan-83 10:47:32-- SXW     	10-Jul-81 14:02:22-- JGS  	19-Nov-82  8:34:06-- Mark  	22-May-81 11:13:23-- SEH  	 1-Oct-82 17:34:12-- AXD      	20-Dec-82 17:59:44DIRECTORY  Atom USING [ATOM, MakeAtom],  Context USING [Find, Type],  Cursor USING [Fetch, GetInfo, Handle, MoveIntoWindow, Object, Set, Store, Type],  Display USING [    Black, Handle, infinity, Invert, paintFlags, Text, White, xorFlags],  Heap USING [systemZone],  Menu USING [    EnumerateFor, EnumerateProcType, Error, Handle, Items, MCRType],  MenuOps USING [    cv, horMargin, Instance, lock, maxBitmapUnderPages, MenuStack,    MenuStackObject, nameFrameOffset, nilItemIndex, PostedMenu,    PostedMenuObject, Ring, verMargin],  MSegment USING [Address, Create, Handle, Kill, PagesForWords],  SpecialUserInput USING [EnqueueMagicMouseEvent],  SpecialTIP USING [GetManager],  String USING [EquivalentString],  TajoMisc USING [FindClippingWindow],  TajoOps USING [AllocateWindow, DeallocateWindow],  TIP USING [    CreateTable, First, InvalidTable, NewManager, NotifyProc, Rest, Results,    Table],  ToolFont USING [StringWidth],  ToolWindow USING [DisplayProcType],  UserTerminal USING [BlinkDisplay, Coordinate],  Window USING [    BitmapPlace, BitmapPlaceToWindowAndPlace, Box, Dims, GetBox, GetChild,    GetParent, Handle, InitializeWindow, InsertIntoTree, IsPlaceInBox, Object,    Place, RemoveFromTree, rootWindow, SetBitmapUnder, ValidateTree,    WordsForBitmapUnder],  WindowFont USING [Handle];MenusB: MONITOR LOCKS MenuOps.lock  IMPORTS    Atom, Context, Cursor, Display, Heap, SpecialUserInput, Menu, MenuOps,    MSegment, String, SpecialTIP, TIP, TajoMisc, TajoOps, ToolFont,    UserTerminal, Window  EXPORTS Menu, MenuOps =    BEGIN OPEN MenuOps;  -- variables  menuContext: PUBLIC Context.Type;  mFont: PUBLIC WindowFont.Handle;  fontHeight: PUBLIC INTEGER;  nameHeight: PUBLIC INTEGER;  windowManagerMenu: PUBLIC Menu.Handle;  bitmapBuffer: LONG POINTER ¬ NIL;  buffer: MSegment.Handle ¬ NIL;  pm: PUBLIC PostedMenu ¬ NIL;  menuPlace: Window.Place;  initialBMPlace: UserTerminal.Coordinate;  initialWindowPlace: Window.Place;  savedCursor: Cursor.Object;  clientWindow: Window.Handle;  ignorePointUp: BOOLEAN ¬ FALSE;  -- Menu Utility routines  ComputeWidestKeyword: PROC [items: Menu.Items] RETURNS [maxLength: INTEGER] = {    index: CARDINAL;    maxLength ¬ 0;    FOR index IN [0..items.LENGTH) DO      maxLength ¬ MAX[        maxLength, ToolFont.StringWidth[items[index].keyword, mFont]];      ENDLOOP;    RETURN[maxLength]};  DisplayString: PROC [    window: Window.Handle, string: LONG STRING, place: Window.Place,    bbop: {paint, erase} ¬ paint, width: INTEGER ¬ Display.infinity] = {    [] ¬ Display.Text[      window: window, string: string, place: place, font: mFont,      lineLength: width,      flags: IF bbop = paint THEN Display.paintFlags ELSE Display.xorFlags]};  Enumerate: PUBLIC ENTRY PROC [    window: Window.Handle, which: Menu.EnumerateFor,    proc: Menu.EnumerateProcType] = {    ENABLE UNWIND => NULL;    [] ¬ RealEnumerate[window, TajoMisc.FindClippingWindow[window], which, proc]};  RealEnumerate: PROC [    window, clipping: Window.Handle, which: Menu.EnumerateFor,    proc: Menu.EnumerateProcType] RETURNS [ring: Ring] = {    inst: Instance;    ring ¬ Context.Find[menuContext, clipping];    IF ring = NIL OR ring.first = NIL THEN RETURN;    FOR inst ¬ ring.first, inst.link DO      SELECT which FROM        all => IF proc[window, inst.menu] THEN EXIT;        inSW => IF inst.window = window THEN IF proc[window, inst.menu] THEN EXIT;        availableInSW =>          IF AvailableInSW[inst: inst, clipping: clipping, sw: window] THEN            IF proc[window, inst.menu] THEN EXIT;        ENDCASE;      IF inst.link = ring.first THEN EXIT;      ENDLOOP};  AvailableInSW: PROC [inst: Instance, clipping, sw: Window.Handle]    RETURNS [BOOLEAN] = {    RETURN[      (inst.window = clipping.GetParent OR inst.window = clipping        OR inst.window = sw)]};  FindRing: PUBLIC PROC [window: Window.Handle] RETURNS [ring: Ring] = {    RETURN[Context.Find[menuContext, TajoMisc.FindClippingWindow[window]]]};  MCRForKeyword: PUBLIC PROC [sw: Window.Handle, menuName, keyword: LONG STRING]    RETURNS [mcr: Menu.MCRType, menu: Menu.Handle, index: CARDINAL] = {    thisMenu: Menu.Handle ¬ NIL;    found: BOOLEAN ¬ FALSE;    CheckNext: Menu.EnumerateProcType = {      IF String.EquivalentString[menu.name, menuName] THEN {        thisMenu ¬ menu;        FOR index IN [0..thisMenu.items.LENGTH) DO          IF String.EquivalentString[thisMenu.items[index].keyword, keyword] THEN	    RETURN[found ¬ TRUE];          ENDLOOP};      RETURN[FALSE]};    Enumerate[sw, availableInSW, CheckNext];    IF ~found THEN ERROR Menu.Error[notInstantiated];    menu ¬ thisMenu;    mcr ¬ menu.items[index].mcrProc};  PagesForBitmapUnder: PROC [window: Window.Handle] RETURNS [CARDINAL] =    INLINE {    RETURN[MSegment.PagesForWords[Window.WordsForBitmapUnder[window]]]};  -- Menu Display  CreatePostedMenu: ENTRY PROC [    sw: Window.Handle, place: Window.Place, firstTime: BOOLEAN] = {    ENABLE UNWIND => NULL;    nMenus: CARDINAL ¬ 0;    clipping: Window.Handle = TajoMisc.FindClippingWindow[sw];    Count: Menu.EnumerateProcType = {nMenus ¬ nMenus + 1; RETURN[FALSE]};    ring: Ring ¬ RealEnumerate[sw, clipping, availableInSW, Count];    IF nMenus > 0 THEN {      pm ¬ Heap.systemZone.NEW[PostedMenuObject];      PostMenu[clipping, ring.first, sw, place, ring, firstTime, nMenus];      TIP.NewManager[pm.menuWindow, menuTip, MenuTIPNotify]}};  DestroyPostedMenu: ENTRY PROC [keepManager: BOOLEAN] = {    ENABLE UNWIND => NULL;    IF pm # NIL THEN {      IF ~keepManager THEN TIP.NewManager[NIL, NIL, NIL];      IF pm.restoreCursorPos THEN        Cursor.MoveIntoWindow[          pm.menuWindow, [pm.cursorPos.x - pm.xdif, pm.cursorPos.y - pm.ydif]];      pm.menuWindow.RemoveFromTree;      IF Window.SetBitmapUnder[pm.menuWindow, NIL] # NIL AND buffer # NIL THEN        MSegment.Kill[buffer];      TajoOps.DeallocateWindow[pm.menuWindow];      Heap.systemZone.FREE[@pm.menuStack];      Heap.systemZone.FREE[@pm];      NOTIFY MenuOps.cv;      Window.ValidateTree[]}};  DrawMenuNameFrame: PROC [    wh: Window.Handle, box: Window.Box, name: LONG STRING, funnyBox: BOOLEAN] = {    funnyHeight: INTEGER ¬ box.dims.h;    funnyX: INTEGER ¬ box.place.x + box.dims.w - nameFrameOffset;    IF funnyBox THEN {      funnyHeight ¬ nameHeight;      Display.White[wh, [[funnyX, box.place.y], [nameFrameOffset, box.dims.h]]]};    Display.White[wh, [box.place, [box.dims.w, funnyHeight]]];    IF name # NIL THEN DisplayString[      wh, name, [box.place.x + 2, box.place.y + 1]];    Display.Black[wh, [box.place, [box.dims.w, 1]]];    Display.Black[wh, [box.place, [1, funnyHeight]]];    Display.Black[      wh, [[box.place.x + box.dims.w - 1, box.place.y], [1, box.dims.h]]];    IF funnyBox THEN      Display.Black[        wh, [[funnyX, box.place.y + box.dims.h - 1], [nameFrameOffset, 1]]]    ELSE      Display.Black[        wh, [[box.place.x, box.place.y + box.dims.h - 1], [box.dims.w, 1]]]};  MenuDisplay: ToolWindow.DisplayProcType = {    place: Window.Place;    -- draw all of "top" one first, even though more code    place ¬ [0, pm.menuY - nameHeight];    Display.Black[pm.menuWindow, [place, [pm.menuWidth, nameHeight]]];    DisplayString[pm.menuWindow, pm.menu.name, [place.x + 2, place.y + 1], erase];    DrawMenuNameFrame[      pm.menuWindow, [[0, pm.menuY], [pm.menuWidth, pm.menuHeight]], NIL, FALSE];    place ¬ [horMargin, pm.menuY + verMargin];    FOR i: CARDINAL IN [0..pm.nItems) DO      DisplayString[        pm.menuWindow, pm.menu.items[i].keyword, place,	paint, pm.menuWidth - 2];      place.y ¬ place.y + fontHeight;      ENDLOOP;    -- now draw the ones "in back"    FOR i: CARDINAL IN [1..pm.menuStack.n) DO      DrawMenuNameFrame[        pm.menuWindow, [        [i*nameFrameOffset, pm.menuY - (nameHeight*(i + 1))], [        pm.menuWidth, pm.menuHeight + fontHeight]], pm.menuStack[i].menu.name,        TRUE];      ENDLOOP;    pm.curIndex ¬ nilItemIndex;    pm.curMenuIndex ¬ 0};  MenuLimitProc: PROC [window: Window.Handle, box: Window.Box]    RETURNS [Window.Box] = {    rd: Window.Dims = Window.rootWindow.GetBox[].dims;    newX: INTEGER = MAX[0, MIN[box.place.x, rd.w - box.dims.w]];    newY: INTEGER = MAX[0, MIN[box.place.y, rd.h - box.dims.h]];    box.place ¬ [newX, newY];    RETURN[box]};  PostMenu: PROC [    clipping: Window.Handle, top: Instance, sw: Window.Handle,    swPlace: Window.Place, ring: Ring, firstTime: BOOLEAN, nMenus: CARDINAL] = {    inst: Instance;    bitmapPlace, cursor: Window.Place;    widestKeyword: INTEGER;    i: CARDINAL ¬ 0;    pm.menuStack ¬ Heap.systemZone.NEW[MenuStackObject[nMenus]];    FOR inst ¬ top, inst.link DO      IF AvailableInSW[inst: inst, clipping: clipping, sw: sw] THEN {	pm.menuStack[i] ¬ inst; i ¬ i + 1};      IF i = pm.menuStack.n THEN EXIT;      ENDLOOP;    inst ¬ pm.menuStack[0];    pm.menu ¬ inst.menu;    pm.ring ¬ ring;    pm.nItems ¬ pm.menu.items.LENGTH;    widestKeyword ¬ ComputeWidestKeyword[pm.menu.items];    pm.menuY ¬ pm.menuStack.n*nameHeight;    pm.menuHeight ¬ pm.nItems*fontHeight + 2;    pm.menuWidth ¬      MAX[widestKeyword + (2*horMargin),        ToolFont.StringWidth[pm.menu.name, mFont]] + 2;    pm.cursorPos ¬ [      pm.menuWidth + 2,      pm.menuY +        (IF ring.lastIndex = nilItemIndex THEN 0         ELSE ring.lastIndex*fontHeight + fontHeight/2)];    IF firstTime THEN{      bitmapPlace ¬ sw.BitmapPlace;      bitmapPlace ¬ [        (cursor.x ¬ bitmapPlace.x + swPlace.x) - pm.cursorPos.x,        (cursor.y ¬ bitmapPlace.y + swPlace.y) - pm.cursorPos.y]}    ELSE bitmapPlace ¬ menuPlace;    pm.menuWindow ¬ TajoOps.AllocateWindow[bitmapUnder: TRUE];    pm.menuWindow.InitializeWindow[      display: MenuDisplay,      box: MenuLimitProc[pm.menuWindow, [        bitmapPlace,	[pm.menuWidth + (pm.menuStack.n - 1)*nameFrameOffset,	  pm.menuY + pm.menuHeight]]],      parent: Window.rootWindow, sibling: Window.rootWindow.GetChild,      under: TRUE, clearingRequired: FALSE];    menuPlace ¬ pm.menuWindow.GetBox.place;    IF (i ¬ PagesForBitmapUnder[pm.menuWindow]) <= maxBitmapUnderPages THEN {      IF bitmapBuffer = NIL THEN {        buffer ¬ MSegment.Create[	  pages: maxBitmapUnderPages, release: [], swapInfo: [uniform[size: 3]]];        bitmapBuffer ¬ MSegment.Address[buffer]};      [] ¬ pm.menuWindow.SetBitmapUnder[bitmapBuffer]};    pm.menuWindow.InsertIntoTree;    pm.menuWindow.ValidateTree;    IF firstTime AND bitmapPlace # pm.menuWindow.GetBox[].place      AND Window.BitmapPlaceToWindowAndPlace[cursor].window = pm.menuWindow THEN {      pm.xdif ¬ pm.menuWindow.GetBox.place.x - bitmapPlace.x;      pm.ydif ¬ pm.menuWindow.GetBox.place.y - bitmapPlace.y;      Cursor.MoveIntoWindow[pm.menuWindow, pm.cursorPos];      pm.restoreCursorPos ¬ TRUE}    ELSE {pm.restoreCursorPos ¬ FALSE; pm.xdif ¬ pm.ydif ¬ 0}};  TryInvert: PROC [index: CARDINAL] = {    itemBox: Window.Box = [      [x: 1, y: pm.menuY + verMargin + index*fontHeight], [      w: pm.menuWidth - 2, h: fontHeight]];    IF NOT index IN [0..pm.nItems) THEN RETURN;    Display.Invert[pm.menuWindow, itemBox]};  -- Menu Control  InvokeMCR: PROC [place: Window.Place, putItUpAgain: BOOLEAN] = {    menuWindow: Window.Handle;    IF pm = NIL THEN RETURN;    menuWindow ¬ pm.menuWindow;    IF pm.curIndex # nilItemIndex THEN { -- something to do      tempCursor: Cursor.Object;      savedMcr: Menu.MCRType = pm.menu.items[pm.curIndex].mcrProc;      savedMenu: Menu.Handle = pm.menu;      savedIndex: CARDINAL = pm.curIndex;      savedWindow: Window.Handle = pm.menuStack[0].window;      Cursor.Fetch[@tempCursor];      Cursor.Set[hourGlass];      pm.ring.lastIndex ¬ pm.curIndex;      DestroyPostedMenu[putItUpAgain];      savedMcr[        savedWindow, savedMenu, savedIndex !        UNWIND =>          IF Cursor.GetInfo[].type = hourGlass THEN Cursor.Store[@tempCursor]];      IF Cursor.GetInfo[].type = hourGlass THEN Cursor.Store[@tempCursor]}    ELSE IF pm.curMenuIndex # 0 THEN {      pm.ring.first ¬ pm.menuStack[pm.curMenuIndex];      pm.ring.lastIndex ¬ nilItemIndex;      DestroyPostedMenu[putItUpAgain]};    IF putItUpAgain AND pm = NIL AND           SpecialTIP.GetManager[].notify = MenuTIPNotify THEN {      newWindow: Window.Handle ¬        Window.BitmapPlaceToWindowAndPlace[initialBMPlace].window;      SpecialUserInput.EnqueueMagicMouseEvent[];      IF newWindow = NIL THEN newWindow ¬ Window.rootWindow;      IF newWindow = clientWindow THEN        CreatePostedMenu[clientWindow, initialWindowPlace, FALSE]      ELSE TIP.NewManager[NIL, NIL, NIL]}};  Track: PROC [place: Window.Place] = {    mI: CARDINAL;    index: CARDINAL;    temp: INTEGER;    tempMenu, newMenu: MenuStack;    MenuNameBox: PROC [m: CARDINAL] RETURNS [Window.Box] = {      RETURN[[        place: [m*nameFrameOffset + 1, pm.menuY - (nameHeight*(m + 1))],	dims: [pm.menuWidth - 2, nameHeight]]]};    IF pm = NIL THEN RETURN;    IF pm.restoreCursorPos AND ABS[place.x - (pm.cursorPos.x - pm.xdif)] <= 2      AND ABS[place.y - (pm.cursorPos.y - pm.ydif)] <= 2 THEN      place ¬ [pm.cursorPos.x, pm.cursorPos.y];    IF pm.restoreCursorPos      AND (ABS[place.x - pm.cursorPos.x] > 2 OR ABS[place.y - pm.cursorPos.y] > 2)      THEN pm.restoreCursorPos ¬ FALSE;    IF (temp ¬ (place.y - pm.menuY - verMargin)/fontHeight) >= 0 THEN index ¬ temp    ELSE index ¬ nilItemIndex;    IF ~(Window.IsPlaceInBox[          place, [[0, pm.menuY], [pm.menuWidth, pm.menuHeight]]]         AND index IN [0..pm.nItems)) THEN index ¬ nilItemIndex;    IF index # pm.curIndex THEN {      TryInvert[pm.curIndex]; TryInvert[index]; pm.curIndex ¬ index};    tempMenu ¬ newMenu ¬ pm.menuStack;    mI ¬ pm.menuStack.n - 1 - (place.y/nameHeight);    IF ~(mI IN [0..pm.menuStack.n) AND      Window.IsPlaceInBox[place, MenuNameBox[mI]]) THEN mI ¬ 0;    IF (pm.curMenuIndex # mI) THEN { -- do something      box: Window.Box ¬ MenuNameBox[mI];      box.dims.h ¬ fontHeight;      box.place.y ¬ box.place.y + 1;      Display.Invert[pm.menuWindow, box];  -- blacken new one      box ¬ MenuNameBox[pm.curMenuIndex];      box.dims.h ¬ fontHeight;      box.place.y ¬ box.place.y + 1;      Display.Invert[pm.menuWindow, box];  -- whiten the old one      pm.curMenuIndex ¬ mI}};  Invoke: PUBLIC PROC [window: Window.Handle, place: Window.Place] = {    cursorCopy: Cursor.Object;    IF menuTip = NIL THEN RETURN;    clientWindow ¬ window;    initialBMPlace ¬ clientWindow.BitmapPlace[place];    CreatePostedMenu[window, place, TRUE];    IF pm = NIL THEN {UserTerminal.BlinkDisplay[]; RETURN};    initialWindowPlace ¬ [place.x + pm.xdif, place.y + pm.ydif];    Cursor.Fetch[@cursorCopy];    savedCursor ¬ cursorCopy;    Cursor.Set[menu];    ignorePointUp ¬ TRUE};    MenuTIPNotify: TIP.NotifyProc = {    place: Window.Place;    FOR input: TIP.Results ¬ results, input.Rest UNTIL input = NIL DO      WITH z: input.First SELECT FROM          coords => place ¬ z.place;	  atom => SELECT z.a FROM	    track => Track[place];	    enablePoint => ignorePointUp ¬ FALSE;	    invoke => IF ~ignorePointUp THEN InvokeMCR[place, TRUE];	    finish => {	      InvokeMCR[place, FALSE];	      DestroyPostedMenu[FALSE];	      IF Cursor.GetInfo[].type = menu THEN {	        cursorCopy: Cursor.Object ¬ savedCursor;	        Cursor.Store[@cursorCopy];	      };	    };	    ENDCASE => UserTerminal.BlinkDisplay[];	  ENDCASE => UserTerminal.BlinkDisplay[];	ENDLOOP};    track, finish, invoke, enablePoint: Atom.ATOM;  menuTip: TIP.Table ¬ NIL;    InitTip: PROC = {    tipContents: STRING ="-- Menu.TIP, created by System-- Version of  6-Nov-82 16:58:29-- Top level trigger selectSELECT TRIGGER FROM    MOUSE WHILE Point Down => COORDS, Track;  MOUSE WHILE Adjust Down => COORDS, Track;  MOUSE WHILE MENU Down => COORDS, Track;  MOUSE WHILE Menu Down => COORDS, Track;    MENU Up => COORDS, Finish;    Menu Up => COORDS, Finish;    Adjust Up => COORDS, Finish;    Point Down => EnablePointInvoke;  Point Up => COORDS, Invoke;    ENDCASE..."L;    firstTime: BOOLEAN ¬ TRUE;    track ¬ Atom.MakeAtom["Track"L];    finish ¬ Atom.MakeAtom["Finish"L];    invoke ¬ Atom.MakeAtom["Invoke"L];    enablePoint ¬ Atom.MakeAtom["EnablePointInvoke"L];    menuTip ¬ TIP.CreateTable[file: "Menu.TIP"L, contents: tipContents !      TIP.InvalidTable => IF type = badSyntax THEN {        UserTerminal.BlinkDisplay[];	IF firstTime THEN {firstTime ¬ FALSE; RESUME}}]};       -- MainlineCode    InitTip[];    END.
-- Copyright (C) 1981, 1982, 1983  by Xerox Corporation. All rights reserved. -- File: FormSWsG.mesa - last edited:-- SXW   : 10-Jul-81 11:59:06-- Mark: Oct 2, 1980 2:21 PM-- SXE  : Aug 13, 1980 10:07 AM-- RXR   : 17-Mar-82 18:52:42-- BGY     : 18-Nov-83 12:08:16 DIRECTORY  Context,  FormSW USING [    BooleanHandle, CommandHandle, defaultBoxWidth, EnumeratedFeedback,    EnumeratedHandle, Enumerated, EnumeratedDescriptor, EnumeratedNotifyProcType,    ItemDescriptor, ItemHandle, ItemObject, LabelHandle, LongNumberHandle,    LongNumberNotifyProcType, MenuProcType, nextPlace, NopEnumeratedNotifyProc,    NopLongNumberNotifyProc, NopNotifyProc, NopNumberNotifyProc, NotifyProcType,    nullIndex, nullItems, NumberHandle, NumberNotifyProcType, ProcType, Radix,    Sleep, StringEditProc, FilterProcType, StringFeedback, StringHandle,    TagOnlyHandle, VanillaMenuProc],  FormSWOps USING [FindContext, ItemDescriptor, PContext],  Heap USING [systemZone],  String USING [    CopyToNewString, FreeString, MakeString],  Window USING [Handle, Place];FormSWsG: PROGRAM IMPORTS Context, FormSW, FormSWOps, Heap, String EXPORTS FormSW =  BEGIN   -- Deallocation  zone: UNCOUNTED ZONE = Heap.systemZone;    FreeAllItems: PUBLIC PROCEDURE [sw: Window.Handle] =    BEGIN    myContext: FormSWOps.PContext = FormSWOps.FindContext[sw];    IF myContext = NIL THEN RETURN;    FormSW.Sleep[sw];  -- so no-one gets upset when items vanish    FOR i: CARDINAL IN [0..LENGTH[myContext.items]) DO      [] ¬ FreeItem[myContext.items[i],myContext.zone]; ENDLOOP;    FreeNode[myContext.zone, BASE[myContext.items]];    myContext.items ¬ FormSW.nullItems;    END;      FreeNodeNil:PROC [lp: LONG POINTER,z: UNCOUNTED ZONE] RETURNS [LONG POINTER] ={    z.FREE [@lp];    RETURN[NIL];    };      FreeItem: PUBLIC PROCEDURE [    item: FormSW.ItemHandle,    z: UNCOUNTED ZONE ¬ NIL] RETURNS [FormSW.ItemHandle] =    BEGIN     IF z = NIL THEN z ¬ zone;    IF ~item.flags.clientOwnsItem THEN String.FreeString[z, item.tag];    WITH variant: item SELECT FROM      enumerated =>        BEGIN        IF variant.copyChoices THEN          BEGIN          j: CARDINAL;          FOR j IN [0..LENGTH[variant.choices]) DO            String.FreeString[z, variant.choices[j].string] ENDLOOP;          FreeNode[z, BASE[variant.choices]];          END;        END;      longNumber => z.FREE[@variant.string];      number => z.FREE[@variant.string];      string =>        IF variant.inHeap THEN z.FREE[variant.string];      ENDCASE;    RETURN[IF item.flags.clientOwnsItem THEN item ELSE FreeNodeNil[item,z]];    END;  -- Allocation  AllocateItemDescriptor: PUBLIC PROCEDURE [nItems: CARDINAL,     z: UNCOUNTED ZONE ¬ NIL]    RETURNS [FormSW.ItemDescriptor] =    BEGIN    nodeSize: CARDINAL = nItems*SIZE[FormSW.ItemHandle];    IF z = NIL THEN z ¬ zone;    RETURN[DESCRIPTOR[MakeNode[z, nodeSize], nItems]];    END;  BooleanItem: PUBLIC PROCEDURE [    tag: LONG STRING ¬ NIL,    readOnly, invisible, drawBox, hasContext: BOOLEAN ¬ FALSE,    place: Window.Place ¬ FormSW.nextPlace,     proc: FormSW.NotifyProcType ¬ FormSW.NopNotifyProc,    switch: LONG POINTER TO BOOLEAN,    z: UNCOUNTED ZONE ¬ NIL] RETURNS [item: FormSW.BooleanHandle] =    BEGIN    nodeSize: CARDINAL = SIZE[boolean FormSW.ItemObject] +     (IF hasContext THEN SIZE[Context.Data] ELSE 0);    IF z = NIL THEN z ¬ zone;    item ¬ MakeNode[z, nodeSize];    item­ ¬ FormSW.ItemObject[      tag: String.CopyToNewString[tag, z], place: place,      flags: [      readOnly: readOnly, invisible: invisible, drawBox: drawBox,      hasContext: hasContext, clientOwnsItem: FALSE],      body: boolean[switch: switch, proc: proc]];    END;  CommandItem: PUBLIC PROCEDURE [    tag: LONG STRING ¬ NIL,    readOnly, invisible, drawBox, hasContext: BOOLEAN ¬ FALSE,    place: Window.Place ¬ FormSW.nextPlace,     proc: FormSW.ProcType,    z: UNCOUNTED ZONE ¬ NIL]    RETURNS [item: FormSW.CommandHandle] =    BEGIN    nodeSize: CARDINAL = SIZE[command FormSW.ItemObject] +      (IF hasContext THEN SIZE[Context.Data] ELSE 0);    IF z = NIL THEN z ¬ zone;    item ¬ MakeNode[z, nodeSize];    item­ ¬ FormSW.ItemObject[      tag: String.CopyToNewString[tag, z], place: place,      flags: [      readOnly: readOnly, invisible: invisible, drawBox: drawBox,      hasContext: hasContext, clientOwnsItem: FALSE], body: command[proc: proc]];    END;  EnumeratedItem: PUBLIC PROCEDURE [    tag: LONG STRING ¬ NIL,    readOnly, invisible, drawBox, hasContext: BOOLEAN ¬ FALSE,    place: Window.Place ¬ FormSW.nextPlace,     feedback: FormSW.EnumeratedFeedback ¬ one,    proc: FormSW.EnumeratedNotifyProcType ¬ FormSW.NopEnumeratedNotifyProc,    copyChoices: BOOLEAN ¬ TRUE, choices: FormSW.EnumeratedDescriptor,    value: LONG POINTER TO UNSPECIFIED,    z: UNCOUNTED ZONE ¬ NIL] RETURNS [item: FormSW.EnumeratedHandle] =    BEGIN    nodeSize: CARDINAL =      SIZE[enumerated FormSW.ItemObject] +       (IF hasContext THEN SIZE[Context.Data] ELSE 0);    myChoices: FormSW.EnumeratedDescriptor;    IF z = NIL THEN z ¬ zone;    IF copyChoices THEN      BEGIN      numChoices: CARDINAL = LENGTH[choices];      i: CARDINAL;      myChoices ¬ DESCRIPTOR[        MakeNode[z, numChoices*SIZE[FormSW.Enumerated]], numChoices];      FOR i IN [0..numChoices) DO        myChoices[i] ¬ [          string: String.CopyToNewString[choices[i].string, z], value: choices[i].value];        ENDLOOP;      END    ELSE myChoices ¬ choices;    item ¬ MakeNode[z, nodeSize];    item­ ¬ FormSW.ItemObject[      tag: String.CopyToNewString[tag, z], place: place,      flags: [      readOnly: readOnly, invisible: invisible, drawBox: drawBox,      hasContext: hasContext, clientOwnsItem: FALSE],      body: enumerated[      feedback: feedback, copyChoices: copyChoices, value: value, proc: proc,      choices: myChoices]];    END;  LongNumberItem: PUBLIC PROCEDURE [    tag: LONG STRING ¬ NIL,    readOnly, invisible, drawBox, hasContext: BOOLEAN ¬ FALSE,    place: Window.Place ¬ FormSW.nextPlace, signed: BOOLEAN ¬ TRUE,    notNegative: BOOLEAN ¬ FALSE, radix: FormSW.Radix ¬ decimal,    boxWidth: CARDINAL [0..256) ¬ 64,    proc: FormSW.LongNumberNotifyProcType ¬ FormSW.NopLongNumberNotifyProc,    default: LONG UNSPECIFIED ¬ LAST[LONG INTEGER],    value: LONG POINTER TO LONG UNSPECIFIED,    bias: INTEGER ¬ 0,     z: UNCOUNTED ZONE ¬ NIL] RETURNS     [item: FormSW.LongNumberHandle] =    BEGIN    nodeSize: CARDINAL =      SIZE[longNumber FormSW.ItemObject] +        (IF hasContext THEN SIZE[Context.Data] ELSE 0);    IF z = NIL THEN z ¬ zone;    item ¬ MakeNode[z, nodeSize];    item­ ¬ FormSW.ItemObject[      tag: String.CopyToNewString[tag, z], place: place,      flags: [      readOnly: readOnly, invisible: invisible, drawBox: drawBox,      hasContext: hasContext, clientOwnsItem: FALSE],      body: longNumber[      signed: signed, notNegative: notNegative, radix: radix, boxWidth: boxWidth,      proc: proc, default: default, value: value,       string: String.MakeString[z, 20], bias: bias]];    END;  NumberItem: PUBLIC PROCEDURE [    tag: LONG STRING ¬ NIL,    readOnly, invisible, drawBox, hasContext: BOOLEAN ¬ FALSE,    place: Window.Place ¬ FormSW.nextPlace, signed: BOOLEAN ¬ TRUE,    notNegative: BOOLEAN ¬ FALSE, radix: FormSW.Radix ¬ decimal,    boxWidth: CARDINAL [0..128) ¬ 64,    proc: FormSW.NumberNotifyProcType ¬ FormSW.NopNumberNotifyProc,    default: UNSPECIFIED ¬ LAST[INTEGER], value: LONG POINTER TO UNSPECIFIED,    bias: INTEGER ¬ 0,     z: UNCOUNTED ZONE ¬ NIL]    RETURNS [item: FormSW.NumberHandle] =    BEGIN    nodeSize: CARDINAL = SIZE[number FormSW.ItemObject] +      (IF hasContext THEN SIZE[Context.Data] ELSE 0);    IF z = NIL THEN z ¬ zone;    item ¬ MakeNode[z, nodeSize];    item­ ¬ FormSW.ItemObject[      tag: String.CopyToNewString[tag, z], place: place,      flags: [      readOnly: readOnly, invisible: invisible, drawBox: drawBox,      hasContext: hasContext, clientOwnsItem: FALSE],      body: number[      signed: signed, notNegative: notNegative, radix: radix, boxWidth: boxWidth,      proc: proc, default: default, value: value,       string: String.MakeString[z, 10], bias: bias]];    END;  StringItem: PUBLIC PROCEDURE [    tag: LONG STRING ¬ NIL,    readOnly, invisible, drawBox, hasContext, inHeap: BOOLEAN ¬ FALSE,    place: Window.Place ¬ FormSW.nextPlace, feedback: FormSW.StringFeedback ¬    normal,boxWidth: CARDINAL ¬ FormSW.defaultBoxWidth,    filterProc: FormSW.FilterProcType ¬ FormSW.StringEditProc,    menuProc: FormSW.MenuProcType ¬ FormSW.VanillaMenuProc,     string: LONG POINTER TO LONG STRING,    z: UNCOUNTED ZONE ¬ NIL]    RETURNS [item: FormSW.StringHandle] =    BEGIN    nodeSize: CARDINAL = SIZE[string FormSW.ItemObject] +      (IF hasContext THEN SIZE[Context.Data] ELSE 0);    IF z = NIL THEN z ¬ zone;    item ¬ MakeNode[z, nodeSize];    item­ ¬ FormSW.ItemObject[      tag: String.CopyToNewString[tag, z], place: place,      flags: [      readOnly: readOnly, invisible: invisible, drawBox: drawBox,      hasContext: hasContext, clientOwnsItem: FALSE],      body: string[      feedback: feedback, inHeap: inHeap, boxWidth: boxWidth,      filterProc: filterProc, menuProc: menuProc, string: string]];    END;  TagOnlyItem: PUBLIC PROCEDURE [    tag: LONG STRING ¬ NIL,    readOnly, invisible, drawBox, hasContext: BOOLEAN ¬ FALSE,    place: Window.Place ¬ FormSW.nextPlace, otherItem: CARDINAL ¬ FormSW.nullIndex,    z: UNCOUNTED ZONE ¬ NIL]    RETURNS [item: FormSW.TagOnlyHandle] =    BEGIN    nodeSize: CARDINAL = SIZE[tagOnly FormSW.ItemObject] +      (IF hasContext THEN SIZE[Context.Data] ELSE 0);    IF z = NIL THEN z ¬ zone;    item ¬ MakeNode[z, nodeSize];    item­ ¬ FormSW.ItemObject[      tag: String.CopyToNewString[tag, z], place: place,      flags: [      readOnly: readOnly, invisible: invisible, drawBox: drawBox,      hasContext: hasContext, clientOwnsItem: FALSE],      body: tagOnly[      otherItem: otherItem, sw: NIL -- will be set by FormSW.Create -- ]];    END;  LabelItem: PUBLIC PROCEDURE [    tag: LONG STRING ¬ NIL,    readOnly, invisible, drawBox, hasContext: BOOLEAN ¬ FALSE,    place: Window.Place ¬ FormSW.nextPlace,    z: UNCOUNTED ZONE ¬ NIL] RETURNS [item: FormSW.LabelHandle] =    BEGIN    RETURN[      TagOnlyItem[        tag: tag, readOnly: readOnly, invisible: invisible, drawBox: drawBox,        hasContext: hasContext, place: place, otherItem: FormSW.nullIndex,	z:z]];    END;  -- Miscellaneous  -- The STRINGs and ARRAY must be in the global frame to avoid dangling  --   pointers being handed out by BooleanChoices.  choices: ARRAY [0..2) OF FormSW.Enumerated ¬ [["TRUE", TRUE], ["FALSE", FALSE]];  BooleanChoices: PUBLIC PROCEDURE RETURNS [FormSW.EnumeratedDescriptor] =    BEGIN RETURN[DESCRIPTOR[choices]]; END;  MakeNode: PROCEDURE [z: UNCOUNTED ZONE, n: CARDINAL] RETURNS [LONG POINTER] = {    T: TYPE = RECORD[SEQUENCE COMPUTED CARDINAL OF UNSPECIFIED];    p: LONG POINTER TO T = z.NEW[T[n]];    RETURN[p]};  FreeNode: PROCEDURE [z: UNCOUNTED ZONE, lp: LONG POINTER] = {    z.FREE [@lp]};  END.  -- of FormSWsG
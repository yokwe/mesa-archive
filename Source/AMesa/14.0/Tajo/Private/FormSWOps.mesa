-- Copyright (C) 1981, 1982, 1983  by Xerox Corporation. All rights reserved. -- File: FormSWOps.mesa - last edited:-- SXW   ,	10-Jul-81 10:09:08-- Mark,	Oct 6, 1980 5:53 PM-- JGS,		20-Aug-81 16:30:45-- SEH,		15-Dec-81 14:32:43-- LXR    ,	 8-Dec-81 19:24:12-- BGY     ,	18-Nov-83 12:25:36-- PXK    ,	12-Nov-82 20:56:25DIRECTORY  Caret USING [Action, MarkProcType],  Context USING [Find, Type],  FormSW USING [    ClientItemsProcType, ItemHandle, ItemObject, nullIndex, Options, ProcType,    Radix, ReadOnlyProcType],  Scrollbar USING [Direction, ScrollProcType, ScrollbarProcType],  Selection USING [Action, ActOnProcType, ConvertProcType, Target],  System,  TextData USING [Insertion, InsertionObject, Selection, SelectionObject],  TextDisplay USING [Object],  TextSource USING [Handle, nullPosition, Position],  TIP USING [NotifyProc],  ToolWindow USING [DisplayProcType, State],  UserInput USING [CaretProcType, StringProcType],  Window USING [Box, Handle, Place];FormSWOps: DEFINITIONS IMPORTS Context =  BEGIN  -- Misc. Constants  nullSelectWidth: INTEGER = 5;  tagSpacer: INTEGER = 10;  -- dijectMargin is used for aesthetic reasons to offset the dijects  -- a little.  dijectMargin: INTEGER = 2;  xInfinity: INTEGER = 9999;  -- Indicates items too large to handle  context: READONLY Context.Type;  fontHeight: READONLY INTEGER;  clearingInMonitor: BOOLEAN;  moveCopy: BOOLEAN;    -- Implementation version of item  ItemDescriptor: TYPE = LONG DESCRIPTOR FOR ARRAY OF ItemHandle;  ItemHandle: TYPE = LONG POINTER TO ItemObject;  ItemObject: TYPE = FormSW.ItemObject;  -- for now  -- PRIVATE implemetation specific stuff  -- PContext, not Context, else the included module Context is lost  PContext: TYPE = LONG POINTER TO PContextObject;  PContextObject: TYPE = RECORD [    lock: MONITORLOCK,    sw: Window.Handle,    originPlace: Window.Place,    width: INTEGER,    readOnlyNotifyProc: FormSW.ReadOnlyProcType,    modifyNotify: FormSW.ProcType ¬ NIL,    clientItems: FormSW.ClientItemsProcType,    validState: BOOLEAN,    setOnNext: BOOLEAN ¬ TRUE,    startPos: TextSource.Position ¬ 0,    endPos: TextSource.Position ¬ TextSource.nullPosition,    curPos: TextSource.Position ¬ 0,    curIndex: CARDINAL,    swState: ToolWindow.State,    options: FormSW.Options,    insertion: InsertionObject,    selection: SelectionObject,    buffer: LONG STRING,    items: ItemDescriptor,    dijects: LONG POINTER TO ARRAY [0..0) OF TextDisplay.Object,    zone: UNCOUNTED ZONE];  FindContext: PROCEDURE [sw: Window.Handle] RETURNS [PContext] = INLINE    BEGIN RETURN[Context.Find[context, sw]]; END;  LockContextProcType: TYPE = PROCEDURE [myContext: PContext];  -- Selection and Insertion stuff  PInsertion: TYPE = LONG POINTER TO InsertionObject;  InsertionObject: TYPE = RECORD [    index: CARDINAL, textInsert: TextData.InsertionObject];  InOp: TYPE = {append, change, clear, unknown};    PSelection: TYPE = LONG POINTER TO SelectionObject;  SelectionObject: TYPE = RECORD [    index: CARDINAL, textSelect: TextData.SelectionObject];      lastTime: System.Pulses;  InsertionPointer: PROCEDURE [insertion: PInsertion, index: CARDINAL]    RETURNS [TextData.Insertion] = INLINE    BEGIN    RETURN[      IF index # FormSW.nullIndex AND index = insertion.index THEN      @insertion.textInsert ELSE NIL];    END;  SelectionPointer: PROCEDURE [selection: PSelection, index: CARDINAL]    RETURNS [TextData.Selection] = INLINE    BEGIN    RETURN[      IF index # FormSW.nullIndex AND index = selection.index THEN      @selection.textSelect ELSE NIL];    END;  -- Almost PUBLIC PROCEDUREs  -- Selection Routines (FormSWsB)  ResolvePlaceToItem: PROCEDURE [sw: Window.Handle, place: Window.Place]    RETURNS [CARDINAL];  -- Private implemetation specific PROCEDUREs    -- TIP Mouse Stuff (FormSWsB) Select/Adjust    ActOnSelection: Selection.ActOnProcType;  Again:         PROC [window: Window.Handle];  AdjustUp:      PROC [    window: Window.Handle, place: Window.Place, time: System.Pulses];  Copy: 	 PROC [window: Window.Handle];  DeleteFNR:     PROC [window: Window.Handle];  DijectSelection: PROC [    PContext, CARDINAL, TextData.Selection] RETURNS [TextData.Selection];  DoSelect:      PROC [    window: Window.Handle, place: Window.Place, time: System.Pulses];  ExtendSel:     PROC [window: Window.Handle, place: Window.Place];  InvertItem:    PROC [PContext, CARDINAL];  MarkEnumeratedItem: PROC [PContext, CARDINAL, CARDINAL, CARDINAL];  MenuDown:      PROC [window: Window.Handle, place: Window.Place];  MenuUp:        PROC [window: Window.Handle, place: Window.Place];  MoveInsertion: PROC [window: Window.Handle, place: Window.Place];  Move: 	 PROC [window: Window.Handle];  PointUp:       PROC [    window: Window.Handle, place: Window.Place, time: System.Pulses];  ReplaceFNR:    PROC [window: Window.Handle];  TrackCursor:   PROC [window: Window.Handle, place: Window.Place];  Undo:          PROC [window: Window.Handle];    ClearTrackData: PROC[myContext: PContext];    -- Utilities (FormSWsC)  AdjustAllItemPlaces: PROCEDURE [PContext, INTEGER, INTEGER];  AdjustItemPlaces: PROCEDURE [PContext, CARDINAL, INTEGER];  AdjustSucceedingItemPlaces: PROCEDURE [PContext, CARDINAL, INTEGER];  DisplayProc: ToolWindow.DisplayProcType;  OverUnderflowSlide: PROCEDURE [PContext, CARDINAL, INTEGER];  SlideYBand: PROCEDURE [myContext: PContext, oldY, newY: INTEGER];  SetModified: PROCEDURE [sw: Window.Handle, myContext: PContext, index: CARDINAL];  -- Misc. place utilities and (Long)NumberHandle support (FormSWsD)  BitY: PROCEDURE [INTEGER] RETURNS [INTEGER];  ConvertProcType: TYPE = PROCEDURE [Selection.Target] RETURNS [LONG POINTER];  ConvertSwap:  PROCEDURE [window: Window.Handle, Convert: ConvertProcType,    Modify: ModifyProcType, keepTrash: BOOLEAN ¬ FALSE];  DeltaY: PROCEDURE [previous, current: INTEGER] RETURNS [INTEGER];  FixPlace: PROCEDURE [previous: Window.Box, current: Window.Place]    RETURNS [Window.Place];  FixX: PROCEDURE [previousX, previousW, current: INTEGER] RETURNS [INTEGER] =    INLINE    -- previous must be non-negative    {RETURN[IF current < 0 THEN previousX + previousW - current ELSE current]};  NewBoxHeightRequested: PROCEDURE [    myContext: PContext, index: CARDINAL, delta: INTEGER] RETURNS [INTEGER];  PositiveY: PROCEDURE [previous, current: INTEGER, lineHeight: CARDINAL]    RETURNS [INTEGER];  ReplaceLongNumberString: PROCEDURE [    s: LONG STRING, signed: BOOLEAN, notNegative: BOOLEAN,     radix: FormSW.Radix, value: LONG UNSPECIFIED];  ReplaceNumberString: PROCEDURE [    s: LONG STRING, signed: BOOLEAN, notNegative: BOOLEAN,     radix: FormSW.Radix, value: UNSPECIFIED];  UnlockedActOnSelection: PROC[myContext: PContext, action: Selection.Action];    ConvertInsertion: Selection.ConvertProcType;  ConvertSelection: Selection.ConvertProcType;  ModifyInsertionState: PROC [    context: FormSWOps.PContext, op: InOp, pos:TextSource.Position];      -- Caret, Cursor, and context monitoring support (FormSWsE)  ActOnCaret: Caret.MarkProcType;  ActivateCaret: UserInput.CaretProcType;  RealActOnCaret: PROCEDURE [PContext, Caret.Action];  -- TextSources (FormSWsF)  ClearCachedInfo: PROCEDURE [LONG POINTER];  ChangeItem: PROCEDURE [LONG POINTER, ItemHandle];  CreateSource: PROCEDURE [item: ItemHandle, context: PContext]    RETURNS [source: TextSource.Handle];  TagLength: PROCEDURE [source: TextSource.Handle, noTrailer: BOOLEAN ¬ FALSE]    RETURNS [CARDINAL];  -- Scrollbars (FormSWsH)  HorizontalScrollbar: Scrollbar.ScrollbarProcType;  InternalScrollVertical: PROCEDURE [PContext, Scrollbar.Direction, INTEGER];  ScrollHorizontal: Scrollbar.ScrollProcType;  ScrollVertical: Scrollbar.ScrollProcType;  VerticalScrollbar: Scrollbar.ScrollbarProcType;  -- TypeIn and String Editing (FormSWsI)  ModifyProcType: TYPE = PROC [window: Window.Handle, new: LONG STRING,     keepTrash: BOOLEAN ¬ FALSE];  DeleteCurrentSelection: PROCEDURE [Window.Handle];  Expand: PROC [window: Window.Handle];  ForceValidSelection: PROCEDURE [PSelection, CARDINAL];  PositionInBody: PROCEDURE [CARDINAL, TextSource.Handle] RETURNS [CARDINAL];  StuffString: ModifyProcType;  ReplaceSelection: ModifyProcType;  TypeInProc: UserInput.StringProcType;    BackSpaceFNR, BackWordFNR, FindFNR, JFirstFNR, JLastFNR, JSelectFNR,     JInsertFNR, NextDeleteFNR, NextFNR: PROC [window: Window.Handle];      -- (FormSWsJ) TIP Tables  InterpInput: TIP.NotifyProc;    CopyDownFNR, CopyUpFNR, MoveDownFNR, MoveUpFNR, PasteFNR, StuffFNR,   UNDOprocFNR: PROC [window: Window.Handle];  END. -- FormSWOps.mesa 
-- File: MenuSymbiote.mesa - last edit:-- Riggle.PA           14-Aug-86 14:53:49-- Copyright (C) 1981, 1982, 1983, 1984 , 1986, 1986, 1986, 1986 by Xerox Corporation. All rights reserved. -- File: MenuSymbiote.mesa - last edit by: -- Mark		31-May-81 20:13:44-- PXK    	31-Jan-83 16:26:12-- SXS   	7-Oct-82 12:50:38 -- JGS		14-Jan-83 10:25:35 -- BGY     	22-Dec-82 13:58:55 -- AXD    	 3-Nov-83 17:15:44 -- DWR    	22-Jan-85 18:10:27 -- Editable-menus.DIRECTORY  Ascii USING [CR, NUL, SP, TAB],  AsciiSink USING [Create],  Atom: TYPE USING [ATOM, MakeAtom],  CmFile USING [    Close, Error, FindSection, Handle, NextValue, TableError, UserDotCmOpen],  Context USING [Create, Find, Type, UniqueType],  Cursor USING [Set],  EditUtil USING [AddSymbiote, DelSymbiote],  Event USING [fileWindow],  EventTypes USING [createWindow],  FileWindow USING [Enumerate, EnumerateProcType, IsIt],  Heap USING [systemZone],  Menu USING [Enumerate, EnumerateProcType, Handle, Instantiate, Make, MCRType],  MFile USING [Acquire, Error, Handle, Release],  Put USING [LongString],  String USING [    AppendString, CopyToNewString, EmptyString, EquivalentSubStrings,    Length, SubString, SubStringDescriptor, UpperCase],  StringSW USING [Create, Destroy, GetString],  StringLookUp,  Supervisor USING [AddDependency, AgentProcedure, CreateSubsystem],  Symbiote USING [AttachSymbioteSW, DetachSymbioteSW, Error, HostForSymbiote],  TextData USING [Selection],  TextSink USING [ActOnProc, FontInfo, Handle],  TextSW USING [    EnumerateSecondarySelections, RemoveAllSecondarySelections, SetPosition, SetSink],  TIP USING [    CreateTable, First, globalTable, InvalidTable, Rest,    PushLocal, NotifyProc, Results, SetNotifyProc, SetTable, Table],  Token USING [FileName, Filtered, FreeTokenString, Handle, Item, Line, StandardFilterState],  Tool USING [Info],  ToolFont USING [Create],  ToolWindow USING [CreateSubwindow, Destroy, GetState, Type, WindowForSubwindow],  UserInput USING [GetDefaultWindow, ReturnToNotifier, WaitForConfirmation],  UserTerminal USING [BlinkDisplay],  Window USING [BitmapPlaceToWindowAndPlace, Box, GetBox, Handle, Place],  WindowFont USING [FontHeight, Handle];MenuSymbiote: MONITOR  IMPORTS    AsciiSink, Atom, CmFile, Context, Cursor, EditUtil, Event, FileWindow, Heap,    Menu, MFile, Put, String, StringLookUp, StringSW, Supervisor,    Symbiote, TIP, TextSink, TextSW, Token,    Tool, ToolFont, ToolWindow, UserInput, UserTerminal, Window, WindowFont  EXPORTS Symbiote =  BEGIN  z: UNCOUNTED ZONE = Heap.systemZone;    WhenAttach: TYPE = {always, initial, never};  whenAttach: WhenAttach ¬ never;  addMenuOption, addEditOption: BOOLEAN ¬ FALSE;  context: Context.Type;  menuContext: Context.Type;  Stuff: TYPE = LONG POINTER TO MSRec;  MSRec: TYPE = RECORD [    notify: PROC [stuff: Stuff, w: Window.Handle], oldNotify: TIP.NotifyProc];  defaultMenu: LONG STRING ¬ NIL;  tip: TIP.Table;  pointUp: Atom.ATOM;    menuLinesWhole, menuLinesDivisor: CARDINAL ¬ 1;  menuLinesFractional: CARDINAL ¬ 0;  menuSink: TextSink.Handle ¬ NIL;  fontHeight: NATURAL;    OptionsConsumed: ERROR = CODE;  MenuIndex: TYPE = {addMenu, detachMenu, addEdit, detachEdit, usercm};    -- Setup/Takedown Stuff  RemoveMenu: PROC [symbSW: Window.Handle] = {    IF symbSW = NIL THEN RETURN;    IF Context.Find[menuContext, symbSW] = NIL THEN GOTO nope;    StringSW.Destroy[symbSW];    Symbiote.DetachSymbioteSW[symbSW ! Symbiote.Error => GOTO nope];    EXITS nope => UserTerminal.BlinkDisplay[]};  SetUpASourceWindow: FileWindow.EnumerateProcType = {<<  go ahead and do this now since we no longer put a menu on the string sw    IF ToolWindow.GetState[ToolWindow.WindowForSubwindow[sw]] = tiny THEN      RETURN[continue];  >>    IF addMenuOption THEN AddMenuSymbioteSW[sw];    IF addEditOption THEN EditUtil.AddSymbiote[sw];    RETURN[continue]};  AddMenuSymbioteSW: PUBLIC PROC [host: Window.Handle] = {    symbSW: Window.Handle;    box: Window.Box;    menu: LONG STRING ¬ NIL;    oldNotifyProc: TIP.NotifyProc;    IF host = NIL THEN RETURN;    box ¬ host.GetBox[];    symbSW ¬ ToolWindow.CreateSubwindow[      parent: ToolWindow.WindowForSubwindow[host],      box: [box.place, [w: box.dims.w, h: MenuLinesToBits[IF menuSink # NIL THEN menuSink.FontInfo.lineHeight ELSE WindowFont.FontHeight[]]]]];    StringSW.Create[      sw: symbSW,      options: [        access: edit, menu: FALSE, split: FALSE, wrap: TRUE, scrollbar: TRUE,        flushTop: FALSE, flushBottom: FALSE]];    IF menuSink # NIL THEN TextSW.SetSink[symbSW, menuSink];    Symbiote.AttachSymbioteSW[host, symbSW, menuContext !      Symbiote.Error => {        UserTerminal.BlinkDisplay[];	ToolWindow.Destroy[symbSW];        GOTO noGood}];    IF ~FileWindow.IsIt[host] THEN menu ¬ ScanMenu[host];    IF menu # defaultMenu THEN {  -- neither NIL      Put.LongString[symbSW, IF menu # NIL THEN menu ELSE defaultMenu];      TextSW.SetPosition[symbSW, 0]};    IF menu # NIL THEN Heap.systemZone.FREE[@menu];    oldNotifyProc ¬ TIP.SetNotifyProc[symbSW, TIPMe];    [] ¬ TIP.SetTable[symbSW, tip];    Context.Create[      type: menuContext,      data: Heap.systemZone.NEW[MSRec ¬ [notify: NIL, oldNotify: oldNotifyProc]],      proc: NotifyMenuContext,      window: symbSW];    EXITS noGood => NULL};  NotifyMenuContext: ENTRY PROC [stuff: Stuff, w: Window.Handle] = {    IF stuff.notify # NIL THEN stuff.notify[stuff, w];    Heap.systemZone.FREE[@stuff]};    TargetSubwindow: PROC RETURNS [sw: Window.Handle] = {    place: Window.Place;    okay: BOOLEAN;    Cursor.Set[mouseRed];    [place, okay] ¬ UserInput.WaitForConfirmation[];    sw ¬ IF okay THEN Window.BitmapPlaceToWindowAndPlace[place].window ELSE NIL;    Cursor.Set[textPointer]};  -- Init, MCR, Notify  SymbioteMCR: Menu.MCRType = {    IF index = MenuIndex.usercm.ORD THEN {      IF defaultMenu # NIL THEN Heap.systemZone.FREE[@defaultMenu];      defaultMenu ¬ ScanMenu[NIL, "FileWindow"L];      IF whenAttach # never THEN SetUpAllSourceWindows[]}    ELSE {      sw: Window.Handle = TargetSubwindow[];      SELECT TRUE FROM  -- order important        sw = NIL => NULL;        ToolWindow.Type[sw] # sub          OR ToolWindow.GetState[ToolWindow.WindowForSubwindow[sw]] = tiny =>          UserTerminal.BlinkDisplay[];        index = MenuIndex.detachMenu.ORD => RemoveMenu[sw];        index = MenuIndex.addMenu.ORD => AddMenuSymbioteSW[sw];        index = MenuIndex.detachEdit.ORD => EditUtil.DelSymbiote[sw];        index = MenuIndex.addEdit.ORD => EditUtil.AddSymbiote[sw];        ENDCASE =>	  ERROR UserInput.ReturnToNotifier["Bad menu index in SymbioteMCR"L]}};  SymbioteNotify: Supervisor.AgentProcedure = {    sw: Window.Handle = eventData;    SELECT event FROM      EventTypes.createWindow =>        IF whenAttach = always THEN [] ¬ SetUpASourceWindow[sw];      -- FileSWToStringSW looks like: destroy, --      ENDCASE};  -- Editable-menus sws.  Match: PROC [ss: String.SubString, name, keyword: LONG STRING]    RETURNS [yes: BOOLEAN ¬ FALSE] = {    firstChar: CHARACTER = String.UpperCase[ss.base[ss.offset]];    firstPossible: CARDINAL ¬ 0;    i: CARDINAL;    temp, ssCopy: String.SubStringDescriptor;    IF keyword.length < ss.length THEN RETURN;    DO      FOR i IN [firstPossible..keyword.length - ss.length] DO        IF String.UpperCase[keyword[i]] = firstChar THEN {	  -- possible partial match          IF i > ss.offset THEN RETURN;  -- base short left          IF ss.offset - i + keyword.length > ss.base.length THEN RETURN;  -- short right          temp ¬ [base: keyword, offset: i, length: keyword.length - i];          IF temp.length > ss.length THEN temp.length ¬ ss.length;          IF String.EquivalentSubStrings[ss, @temp] THEN {	    -- (partial?) match, 4 possible cases            -- keyword = ABC: ss.base = 1) A(B), 2) B, 3) (B)C, 4) ABC            -- backup ss (known safe) and try for full match            ssCopy ¬ [              base: ss.base, offset: ss.offset - i, length: keyword.length];            temp ¬ [base: keyword, offset: 0, length: keyword.length];            IF String.EquivalentSubStrings[@ssCopy, @temp] THEN {              yes ¬ TRUE;  -- unless menu qualification screws us              IF ssCopy.offset > 0 THEN {                offset: CARDINAL ¬ ssCopy.offset - 1;                IF ss.base[offset] = '$ THEN {		  -- qualified, so is it this menu?                  IF offset < name.length THEN RETURN;  -- short left                  ssCopy ¬ [                    base: ss.base, offset: offset - name.length,                    length: name.length];                  temp ¬ [base: name, offset: 0, length: name.length];                  RETURN[String.EquivalentSubStrings[@ssCopy, @temp]]}};              RETURN}};          firstPossible ¬ i + 1;          EXIT};        REPEAT FINISHED => RETURN;        ENDLOOP;      ENDLOOP};  ScanMenu: PROC [sw: Window.Handle, section: LONG STRING ¬ NIL]    RETURNS [sMenu: LONG STRING ¬ NIL] = {    h: CmFile.Handle;    name, value: LONG STRING ¬ NIL;    id: LONG STRING =      IF String.Length[section] > 0 THEN section      ELSE Tool.Info[ToolWindow.WindowForSubwindow[sw]].cmSection;    IF String.EmptyString[id] THEN RETURN;    h ¬ CmFile.UserDotCmOpen[ ! CmFile.Error => GOTO notFound];    IF CmFile.FindSection[h, id] THEN {      Option: TYPE = MACHINE DEPENDENT{        menu(0), setUp, menuSymbioteFont, menuSymbioteLines,	noMatch(StringLookUp.noMatch)};      DefinedOption: TYPE = Option [menu..menuSymbioteLines];      options: ARRAY DefinedOption OF LONG STRING ¬ [        menu: "Menu"L, setUp: "SetUp"L, menuSymbioteFont: "MenuSymbioteFont"L,	menuSymbioteLines: "MenuSymbioteLines"L];      CheckType: PROC [h: CmFile.Handle, table: StringLookUp.TableDesc]        RETURNS [index: CARDINAL] = CmFile.NextValue;      MyNextValue: PROC [        h: CmFile.Handle,        table: LONG DESCRIPTOR FOR ARRAY DefinedOption OF LONG STRING]        RETURNS [index: Option] = LOOPHOLE[CheckType];      DO        SELECT MyNextValue[h, DESCRIPTOR[options] ! CmFile.TableError => RESUME ]        FROM          noMatch => EXIT;          menu => sMenu ¬ GetTrimmedMenu[h];          setUp => IF sw = NIL THEN ScanSetUp[h ! OptionsConsumed => CONTINUE];	  menuSymbioteFont => {	    state: Token.StandardFilterState;	    name: LONG STRING ¬ Token.Filtered[h, @state, Token.FileName, whiteSpace, FALSE]; -- font name	    IF name # NIL THEN {	      handle: MFile.Handle ¬ NIL;	      font: WindowFont.Handle ¬ NIL;	      BEGIN ENABLE MFile.Error => GOTO quit;	        handle ¬ MFile.Acquire[name: name, access: readOnly, release: [NIL, NIL]];		IF handle = NIL THEN GOTO quit;		font ¬ ToolFont.Create[handle];		IF font = NIL THEN GOTO quit;		menuSink ¬ AsciiSink.Create[font];		[] ¬ menuSink.actOn[menuSink, wakeup];		menuSink.actOn ¬ OurActOn;		fontHeight ¬ font.FontHeight[];	      EXITS quit => menuSink ¬ NIL;	      END;	      z.FREE[@name];	      IF handle # NIL THEN MFile.Release[handle];	    };	  };	  menuSymbioteLines => [menuLinesWhole, menuLinesFractional, menuLinesDivisor] ¬ GetReal[h];          ENDCASE;        ENDLOOP};    h ¬ CmFile.Close[h];    EXITS notFound => NULL};      OurActOn: TextSink.ActOnProc = {RETURN[ok]};       « Read a real number.  Syntax = {CARDINAL | NULL} {. CARDINAL | . | NULL} »    GetReal: PROCEDURE [h: Token.Handle] RETURNS [wholePart, fractionalPart: CARDINAL ¬ 0, divisor: CARDINAL ¬ 1] = {    c: CHARACTER;    fraction: BOOLEAN ¬ FALSE;    WHILE (c ¬ h.getChar[h]) = Ascii.SP OR c = Ascii.TAB DO ENDLOOP;    DO      SELECT c FROM	IN ['0..'9] => IF ~fraction THEN	    wholePart ¬ wholePart*10 + ORD[c]-ORD['0]	  ELSE {	    fractionalPart ¬ fractionalPart*10 + ORD[c]-ORD['0];	    divisor ¬ divisor*10;	  };	'. => fraction ¬ TRUE;      ENDCASE => EXIT;      c ¬ h.getChar[h];    ENDLOOP;  };    MenuLinesToBits: PROCEDURE [fontHeight: NATURAL] RETURNS [NATURAL] = {    RETURN [fontHeight*menuLinesFractional/menuLinesDivisor + menuLinesWhole*fontHeight]};  ScanSetUp: PROC [h: CmFile.Handle] = {    -- Input line expected to be of form:    -- SetUp: Initial|Always|Never Menu|NoMenu Edit|NoEdit    index: Options;    Options: TYPE = {always, initial, menu, never, noMenu, edit, noEdit};    options: ARRAY Options OF LONG STRING ¬ [      always: "Always"L, initial: "Initial"L, menu: "Menu"L, never: "Never"L,      noMenu: "NoMenu"L, edit: "Edit"L, noEdit: "NoEdit"L];    DO      index ¬ LOOPHOLE[NextOption[h, LOOPHOLE[LONG[DESCRIPTOR[options]]]]];      SELECT LOOPHOLE[index, Options] FROM        always => whenAttach ¬ always;        initial => whenAttach ¬ initial;        never => whenAttach ¬ never;        menu => addMenuOption ¬ TRUE;        noMenu => addMenuOption ¬ FALSE;        edit => addEditOption ¬ TRUE;        noEdit => addEditOption ¬ FALSE;        ENDCASE;      ENDLOOP};         NextOption: PROC [h: Token.Handle, table: StringLookUp.TableDesc]    RETURNS [index: CARDINAL ¬ StringLookUp.noMatch] = {    SELECT h.break FROM      Ascii.CR, Ascii.NUL => ERROR OptionsConsumed;      ENDCASE => {        token: LONG STRING ¬ Token.Item[h];        IF token = NIL THEN ERROR OptionsConsumed;        index ¬ LOOPHOLE[StringLookUp.InTable[token, table]];	[] ¬ Token.FreeTokenString[token]}};    GetTrimmedMenu: PROC [h: CmFile.Handle] RETURNS [new: LONG STRING] = {    ls: LONG STRING;    ls ¬ Token.Filtered[h, NIL, Token.Line];    new ¬ String.CopyToNewString[ls, Heap.systemZone];    [] ¬ Token.FreeTokenString[ls]};  SetUpAllSourceWindows: PROC = {FileWindow.Enumerate[SetUpASourceWindow]};    TryForMCR: PROC [symb, host: Window.Handle, st: Stuff] = {    haveOne: BOOLEAN ¬ FALSE;    ss: String.SubStringDescriptor;    HaveSecondary: PROC [data: TextData.Selection]      RETURNS [done: BOOLEAN ¬ TRUE] = {      haveOne ¬ TRUE;      ss.offset ¬ CARDINAL[data.left];      ss.length ¬ CARDINAL[data.right - data.left]};    ss.base ¬ StringSW.GetString[symb]­;    IF ss.base # NIL THEN {      TextSW.EnumerateSecondarySelections[symb, HaveSecondary];      IF haveOne THEN {        goneAway: BOOLEAN ¬ FALSE;	GoneAway: PROC [stuff: Stuff, w: Window.Handle] = {	  IF stuff = st THEN goneAway ¬ TRUE};	SetGoneAway: ENTRY PROC = INLINE {st.notify ¬ GoneAway};	ClearGoneAway: ENTRY PROC = INLINE {st.notify ¬ NIL};	SetGoneAway[];        CallMenuRoutine[host, @ss];	IF NOT goneAway THEN {	  ClearGoneAway[];	  TextSW.RemoveAllSecondarySelections[symb]}}}};  CallMenuRoutine: PROC [hostSW: Window.Handle, ss: String.SubString] = {    theMenu: Menu.Handle ¬ NIL;    index: CARDINAL;    mcr: Menu.MCRType ¬ NIL;    CheckMenu: Menu.EnumerateProcType = {      FOR i: CARDINAL IN [0..LENGTH[menu.items]) DO        IF Match[ss, menu.name, menu.items[i].keyword] THEN {          theMenu ¬ menu; index ¬ i; mcr ¬ menu.items[i].mcrProc; RETURN[TRUE]};        REPEAT FINISHED => RETURN[FALSE];	ENDLOOP};    Menu.Enumerate[hostSW, availableInSW, CheckMenu];    IF mcr # NIL THEN mcr[hostSW, theMenu, index]};  TIPMe: TIP.NotifyProc = {    stuff: Stuff = Context.Find[menuContext, window];    hisProc: TIP.NotifyProc;    IF stuff = NIL OR (hisProc ¬ stuff.oldNotify) = NIL THEN RETURN;    hisProc[window, results];    FOR input: TIP.Results ¬ results, input.Rest[] UNTIL input = NIL DO      WITH z: input.First[] SELECT FROM        atom => SELECT z.a FROM	  pointUp => TryForMCR[window, Symbiote.HostForSymbiote[window], stuff];          ENDCASE;        ENDCASE;      ENDLOOP};  -- main line code    {firstTime: BOOLEAN ¬ TRUE;  tipContents: LONG STRING ="-- MenuSymbiote.TIP; Created by SystemSELECT TRIGGER FROM  Point Down WHILE CONTROL Up => TIME, COORDS, Video, Word, DoSecondary;  ENDCASE..."L;  menuName: LONG STRING ¬ [40];  attach: ARRAY MenuIndex OF LONG STRING ¬ [    addMenu: "Attach Menu"L, detachMenu: "Detach Menu"L,    addEdit: "Attach Edit"L, detachEdit: "Detach Edit"L, usercm: "User.cm"L];  menu: Menu.Handle;  String.AppendString[to: menuName, from: "Symbiote"L];  menu ¬ Menu.Make[    menuName, LOOPHOLE[LONG[DESCRIPTOR[attach]]], SymbioteMCR, TRUE, TRUE];  Menu.Instantiate[menu, UserInput.GetDefaultWindow[]];  context ¬ Context.UniqueType[];  menuContext ¬ Context.UniqueType[];  Supervisor.AddDependency[    client: Supervisor.CreateSubsystem[agent: SymbioteNotify, instanceData:],    implementor: Event.fileWindow];  defaultMenu ¬ ScanMenu[NIL, "FileWindow"L];  tip ¬ TIP.CreateTable[file: "MenuSymbiote.TIP"L, contents: tipContents !    TIP.InvalidTable =>       IF type = badSyntax THEN {	UserTerminal.BlinkDisplay[];	IF firstTime THEN {firstTime ¬ FALSE; RESUME}}];  IF tip # NIL THEN      TIP.PushLocal[push: tip, onto: TIP.globalTable[textSW]];  pointUp ¬ Atom.MakeAtom["PointUp"L]};  END.LOGDWR    	26-Oct-84 16:21:22  Added user.cm entry for MenuSymbioteFont & #linesDWR    	26-Nov-84 15:21:02 Fixed bug in sameDWR    	22-Jan-85 18:10:22 Fixed bug in "menuSymbioteFont =>" code
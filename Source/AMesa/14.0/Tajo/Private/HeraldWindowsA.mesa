-- Copyright (C) 1981, 1982, 1983  by Xerox Corporation. All rights reserved. -- HeraldWindowsA.mesa - last edit by-- PXK    ,	26-Oct-81 10:07:52-- SXW   ,	12-Jul-81 16:51:02-- RXJ     ,	31-Dec-81  9:58:52-- JGS    ,	21-Aug-81  9:32:12-- FXH    ,	May 24, 1980  4:16 PM-- SXE  ,	October 11, 1980  2:48 PM-- BXM  ,	22-Feb-82 12:45:42-- PXM    ,	August 23, 1980  3:00 PM-- HXL  ,	September 30, 1980  10:03 AM-- Mark,	13-Jul-81 18:47:31-- RXR   ,	19-Apr-83 13:21:00-- LXR    ,	 9-Dec-83 11:30:41-- CXH   ,	20-Jul-83 17:41:27-- AXD    ,	20-Jul-83 17:49:26-- RSF      	 1-Sep-83 15:38:32-- DWR    	13-Nov-84 16:17:26DIRECTORY  Ascii USING [BS, CR, FF, LF, NUL, TAB],  File USING [File, Unknown],  Format USING [StringProc],  Heap USING [systemZone],  HeraldWindow USING [ConfirmProcType, DefaultConfirm, DefaultPost],  HeraldWindowOps USING [MenuRecord, MenuSequence, specialEntries],  MFile USING [AppendErrorMessage, Error, Handle, ReadOnly, Release],  SpecialMFile USING [GetCapaWithAccess, LeaderPages],  PhysicalVolume USING [GetAttributes, GetContainingPhysicalVolume, Handle, ID],  Profile USING [place],  String USING [    AppendChar, AppendExtensionIfNeeded, AppendNumber, AppendString,    Copy, CopyToNewString, EmptyString, EquivalentStrings,    StringBoundsFault, StringLength, StringToOctal],  System USING [defaultSwitches, Switches],  TajoOps USING [OutloadProcType],  TemporaryBooting USING [    BootButton, BootFromFile, BootFromPhysicalVolume, BootFromVolume,     GetFileLocation, GetVolumeLocation, InvalidParameters, MakeBootable],  Volume USING [    GetLabelString, GetNext, ID, maxNameLength, NeedsScavenging, NotOpen, nullID,     systemID, TypeSet, Unknown];HeraldWindowsA: MONITOR  IMPORTS    File, Heap, HeraldWindow, HeraldWindowOps, MFile, SpecialMFile,    PhysicalVolume, Profile, String, TemporaryBooting, Volume  EXPORTS HeraldWindow, HeraldWindowOps, TajoOps =  BEGIN  --Globals shared by HeraldWindowsA and HeraldWindowsB  -- Booter defs  VolumeIDsSeq: TYPE = RECORD [SEQUENCE COMPUTED CARDINAL OF Volume.ID];  VolumeSeqHandle: TYPE = LONG POINTER TO VolumeIDsSeq;  z: PUBLIC UNCOUNTED ZONE ¬ Heap.systemZone;  switches: PUBLIC System.Switches ¬ System.defaultSwitches;  switchDelimiter: CHARACTER = '/;  menuStrings: PUBLIC HeraldWindowOps.MenuSequence ¬ NIL;  nVols: PUBLIC CARDINAL ¬ 0;  -- Number of volumes online  volumeIDs: VolumeSeqHandle;  outLoadProc: TajoOps.OutloadProcType ¬ NIL;  SetOutloadProc: PUBLIC PROCEDURE [proc: TajoOps.OutloadProcType] = {    outLoadProc ¬ proc};  EmptySelection: PUBLIC SIGNAL = CODE;  InvalidSwitches: PUBLIC SIGNAL = CODE;  -- Booter procedures (listed alphabetically)  AppendLogicalVolumeName: PUBLIC PROCEDURE [    s: LONG STRING, id: Volume.ID ¬ Volume.systemID] =    BEGIN    volumeName: STRING = [Volume.maxNameLength];    Volume.GetLabelString[id, volumeName ! Volume.NeedsScavenging => {String.AppendChar[s, '?]; GOTO return}];    String.AppendString[s, volumeName];    EXITS      return => NULL    END;  AppendPhysicalVolumeName: PUBLIC PROCEDURE [s: LONG STRING] =    BEGIN    id: PhysicalVolume.ID = PhysicalVolume.GetContainingPhysicalVolume[      Volume.systemID];    label: STRING ¬ [40];    [] ¬ PhysicalVolume.GetAttributes[id, label];    String.AppendString[s, label];    END;  AppendSwitches: PUBLIC ENTRY PROCEDURE [s: LONG STRING] =    BEGIN ENABLE UNWIND => NULL; AppendSwitchesInternal[s, switches]; END;  AppendSwitchesInternal: PROCEDURE [s: LONG STRING, switches: System.Switches] =    BEGIN    FOR c: CHARACTER IN CHARACTER DO      IF switches[c] = down THEN {        SELECT TRUE FROM	  c = '\\ => String.AppendString[s, "\\"L];	  PrintableSwitchChar[c] => String.AppendChar[s, c]          ENDCASE => {            String.AppendChar[s, '\\];            String.AppendNumber[s, c, 8]}};      ENDLOOP;    END;  PrintableSwitchChar: PROCEDURE [c: CHARACTER] RETURNS [BOOLEAN] = {    SELECT c FROM      IN ['a..'z], IN ['A..'Z], IN ['0..'9], ',, '., '/, '<, '>, '?, ';, '', '¬,        ':, '", '­, '[, '], '{, '}, '!, '@, '#, '$, '%, '~, '&, '*, '(, '), '-, '=,        '+, '| => RETURN[TRUE];      ENDCASE => RETURN[FALSE]};  BootFromFile: PUBLIC PROCEDURE [    name: LONG STRING, bootSwitches: System.Switches ¬ switches,    postProc: Format.StringProc ¬ HeraldWindow.DefaultPost,    confirmProc: HeraldWindow.ConfirmProcType ¬ HeraldWindow.DefaultConfirm] = {    -- Always scans name for switches; if found, they are used instead of bootSwitches.    switches: STRING ¬ [36];    defaultExt: STRING = ".boot"L;    s: LONG STRING;    hasExt: BOOLEAN;    fh: MFile.Handle ¬ NIL;    file: File.File;    offset: CARDINAL = SpecialMFile.LeaderPages[];    IF String.EmptyString[name] THEN RETURN;    BEGIN    ENABLE UNWIND => z.FREE[@s];    s ¬ z.NEW[StringBody[String.StringLength[name]]];    hasExt ¬ BreakApartName[name, s, switches];    IF ~hasExt THEN [] ¬ String.AppendExtensionIfNeeded[@s, defaultExt, z];    fh ¬ MFile.ReadOnly[      s, [] !      MFile.Error =>        IF code = noSuchFile AND ~hasExt THEN {          s.length ¬ s.length - defaultExt.length; hasExt ¬ TRUE; RETRY}	ELSE {	  msg: LONG STRING ¬ [100];	  MFile.AppendErrorMessage[msg, code, file];	  postProc[msg, NIL];	  CONTINUE}];    IF fh = NIL THEN GOTO notFound;    IF switches.length # 0 THEN       bootSwitches ¬ ScanSwitches[switches ! InvalidSwitches => CONTINUE];    postProc["Boot from file: "L, NIL];    postProc[s, NIL];    PostSwitches[postProc, bootSwitches];    file ¬ SpecialMFile.GetCapaWithAccess[fh];    MFile.Release[fh ! MFile.Error => CONTINUE];    IF confirmProc # NIL AND ~confirmProc[postProc] THEN RETURN;     TemporaryBooting.MakeBootable[      file, offset !      TemporaryBooting.InvalidParameters => GOTO cantBoot];   IF Profile.place = copilot AND outLoadProc # NIL THEN 	    outLoadProc[	      TemporaryBooting.GetFileLocation[file, offset	        ! TemporaryBooting.InvalidParameters => GOTO cantBoot; 	          Volume.Unknown, File.Unknown => GOTO notFound], 	      bootSwitches] -- won't return, but CoPilot WILL raise an ERROR that we don't want to catch (usually DebugOps.Debug)    ELSE TemporaryBooting.BootFromFile[        file, offset, bootSwitches !        TemporaryBooting.InvalidParameters => GOTO cantBoot]    EXITS      cantBoot => {postProc[s, NIL]; postProc[" is not a boot file."L, NIL ]};      notFound => {postProc[s, NIL]; postProc[" not found."L, NIL]};    END;    z.FREE[@s]};  BootButton: PUBLIC PROCEDURE [] =    BEGIN    IF Profile.place = copilot AND outLoadProc # NIL THEN       outLoadProc[[bootButton[]], System.defaultSwitches]    ELSE TemporaryBooting.BootButton[];    END;  BootFromVolumeID: PUBLIC PROCEDURE [    id: Volume.ID, bootSwitches: System.Switches ¬ switches,    postProc: Format.StringProc ¬ HeraldWindow.DefaultPost,    confirmProc: HeraldWindow.ConfirmProcType ¬ HeraldWindow.DefaultConfirm] =    BEGIN    IF confirmProc # NIL AND ~confirmProc[postProc] THEN RETURN;     IF Profile.place = copilot AND id # Volume.systemID       AND outLoadProc # NIL THEN 	    outLoadProc[	      TemporaryBooting.GetVolumeLocation[id	        ! TemporaryBooting.InvalidParameters, 	          Volume.Unknown, Volume.NotOpen => CONTINUE], 	      bootSwitches]; -- won't return, but CoPilot WILL raise an ERROR that we don't want to catch (usually DebugOps.Debug)    TemporaryBooting.BootFromVolume[id, bootSwitches];    END;  BootFromVolumeName: PUBLIC PROCEDURE [    name: LONG STRING, bootSwitches: System.Switches ¬ switches,    postProc: Format.StringProc ¬ HeraldWindow.DefaultPost,    confirmProc: HeraldWindow.ConfirmProcType ¬ HeraldWindow.DefaultConfirm] =    -- Always scans name for switches; if found, they are used instead of bootSwitches.    -- Boots logical volume name and pushes boot button if any problem    -- String storage is callers    BEGIN    volume: LONG STRING ¬ z.NEW[StringBody[100]];    BootFromVolumeNameInternal[      name, volume, bootSwitches, postProc, confirmProc !      EmptySelection =>        TemporaryBooting.BootFromPhysicalVolume[volume: Volume.systemID];      UNWIND => z.FREE[@volume]];    z.FREE[@volume];    END;  BootFromVolumeNameInternal: PROCEDURE [    name: LONG STRING, volume: LONG STRING,    bootSwitches: System.Switches ¬ switches,    postProc: Format.StringProc ¬ HeraldWindow.DefaultPost,    confirmProc: HeraldWindow.ConfirmProcType ¬ HeraldWindow.DefaultConfirm] =    BEGIN    index: CARDINAL;    switches: STRING ¬ [36];    IF String.EmptyString[name] THEN ERROR EmptySelection;    [] ¬ BreakApartName[name, volume, switches];    IF switches.length # 0 THEN       bootSwitches ¬ ScanSwitches[switches ! InvalidSwitches => CONTINUE];    FOR index IN [0..menuStrings.length) DO      IF String.EquivalentStrings[volume, menuStrings[index]] THEN EXIT;      REPEAT FINISHED => ERROR EmptySelection;      ENDLOOP;    postProc["Boot from Logical volume: "L, NIL];    postProc[volume, NIL];    PostSwitches[postProc, bootSwitches];    postProc[NIL, NIL];    BootFromVolumeID[volumeIDs[index], bootSwitches, postProc, confirmProc];    END;  BreakApartName: PROCEDURE [name: LONG STRING, before, after: LONG STRING]    RETURNS [beforeHasDot: BOOLEAN] =    BEGIN    temp: LONG STRING ¬ before;    beforeHasDot ¬ FALSE;    FOR i: CARDINAL IN [0..String.StringLength[name]) DO      SELECT name[i] FROM        '. =>          IF temp = before THEN {            beforeHasDot ¬ TRUE; String.AppendChar[temp, name[i]]};        switchDelimiter => IF temp = before THEN temp ¬ after ELSE EXIT;        ENDCASE => String.AppendChar[temp, name[i]];      ENDLOOP;    END;  PostSwitches: PROCEDURE [    postProc: Format.StringProc, switches: System.Switches] =    BEGIN    switchString: STRING = [100];    -- this constant must be reviewed when System.Switches changes    String.AppendChar[switchString, switchDelimiter];    AppendSwitchesInternal[      switchString, switches ! String.StringBoundsFault => CONTINUE];    IF switchString.length > 1 THEN postProc[switchString, NIL];    END;  ScanSwitches: PUBLIC PROCEDURE [    s: LONG STRING, defaultSwitches: System.Switches ¬ System.defaultSwitches]    RETURNS [switches: System.Switches] = {    c: CHARACTER;    index: CARDINAL ¬ 0;    sense: BOOLEAN ¬ TRUE;    Get: PROC RETURNS [c: CHARACTER] = {      IF index = s.length THEN c ¬ Ascii.NUL      ELSE {c ¬ s[index]; index ¬ index + 1}};    switches ¬ defaultSwitches;    UNTIL (c ¬ Get[]) = Ascii.NUL DO      SELECT c FROM        '\\ => 	  SELECT (c ¬ Get[]) FROM	    IN ['0..'3] => {	      OctDig: TYPE = CHARACTER['0..'7];	      esc: STRING ¬ [3];	      esc.length ¬ 3;	      esc[0] ¬ c;	      IF (esc[1] ¬ Get[]) IN OctDig AND (esc[2] ¬ Get[]) IN OctDig THEN	        switches[String.StringToOctal[esc]] ¬ IF sense THEN down ELSE up	      ELSE SIGNAL InvalidSwitches};	    'n, 'N, 'r, 'R => switches[Ascii.CR] ¬ IF sense THEN down ELSE up;	    't, 'T => switches[Ascii.TAB] ¬ IF sense THEN down ELSE up;	    'b, 'B => switches[Ascii.BS] ¬ IF sense THEN down ELSE up;	    'f, 'F => switches[Ascii.FF] ¬ IF sense THEN down ELSE up;	    'l, 'L => switches[Ascii.LF] ¬ IF sense THEN down ELSE up;	    '', '", '\\, '-, '~ => switches[c] ¬ IF sense THEN down ELSE up;	    ENDCASE => ERROR InvalidSwitches;        '-, '~ => {sense ¬ ~sense; LOOP};	ENDCASE => switches[c] ¬ IF sense THEN down ELSE up;      sense ¬ TRUE;      ENDLOOP};        SetSwitches: PUBLIC ENTRY PROCEDURE [new: System.Switches] =    BEGIN switches ¬ new; END;  SetUpMenuandVolStrings: PUBLIC PROCEDURE =    BEGIN    i, entries: CARDINAL;    s: STRING ¬ [80];    v: Volume.ID;    all: Volume.TypeSet = [normal: TRUE, debugger: TRUE, debuggerDebugger: TRUE];    IF menuStrings # NIL AND volumeIDs # NIL THEN RETURN;    -- First, count the logical volumes.    nVols ¬ 0;    FOR v ¬ Volume.GetNext[Volume.nullID, all], Volume.GetNext[v, all] UNTIL v =      Volume.nullID DO nVols ¬ nVols + 1; ENDLOOP;    entries ¬ nVols + HeraldWindowOps.specialEntries;  -- allocate menu space for entire menu    -- Now, build up the volume tables.    menuStrings ¬ z.NEW[HeraldWindowOps.MenuRecord [entries]];    volumeIDs ¬ z.NEW[VolumeIDsSeq [nVols]];    volumeIDs[0] ¬ v ¬ Volume.systemID;    Volume.GetLabelString[v, s ! Volume.NeedsScavenging => {String.Copy[s, "?"L]; CONTINUE}];    menuStrings[0] ¬ String.CopyToNewString[s, z];    i ¬ 1;    FOR v ¬ Volume.GetNext[Volume.nullID, all], Volume.GetNext[v, all] UNTIL v =      Volume.nullID DO      IF v = Volume.systemID THEN LOOP;      volumeIDs[i] ¬ v;      Volume.GetLabelString[v, s ! Volume.NeedsScavenging => {String.Copy[s, "?"L]; CONTINUE}];      menuStrings[i] ¬ String.CopyToNewString[s, z];      i ¬ i + 1;      ENDLOOP;    END;  END.
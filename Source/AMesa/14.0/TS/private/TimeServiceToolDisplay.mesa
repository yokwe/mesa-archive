-- File: TimeServiceToolDisplay.mesa - last edit:-- kam         16-Dec-85 11:39:12-- Copyright (C) 1985 by Xerox Corporation. All rights reserved.DIRECTORY  Format USING [NetworkAddress, StringProc],  Heap USING [Create],  Overlap USING [IntervalSet],  String USING [    AppendChar, AppendDecimal, AppendLongDecimal, AppendLongNumber, AppendString,    FreeString, MakeString],  System USING [NetworkAddress, NetworkNumber],  Time USING [Append, Unpack],  TimeServiceToolOps USING [    CalculateRelativeRate, IntersectTag, ServerInfo, SurveyorInfo];TimeServiceToolDisplay: PROGRAM  IMPORTS Format, Heap, String, Time, TimeServiceToolOps  EXPORTS TimeServiceToolOps =  BEGIN  defaultMaximumRate: LONG INTEGER = 1000000 / 86400;  -- in microseconds/second  zone: PUBLIC UNCOUNTED ZONE = Heap.Create[initial: 10];  AddDP: PUBLIC PROCEDURE [s: LONG STRING, d: CARDINAL] =    BEGIN    i: CARDINAL;    hasMinus: BOOLEAN ¬ s[0] = '-;    IF hasMinus THEN {      FOR i IN [1..s.length) DO s[i - 1] ¬ s[i] ENDLOOP;      s.length ¬ s.length - 1};    IF s.length < d THEN      BEGIN      FOR i DECREASING IN [0..d] DO        s[i] ¬          SELECT TRUE FROM            i = 0 => '.,            s.length + i <= d => '0,            ENDCASE => s[s.length + i - d - 1];        ENDLOOP;      s.length ¬ d + 1;      END    ELSE      BEGIN      FOR i DECREASING IN (s.length - d..s.length] DO s[i] ¬ s[i - 1] ENDLOOP;      s[s.length - d] ¬ '.;      s.length ¬ s.length + 1;      END;    IF hasMinus THEN      BEGIN      s.length ¬ s.length + 1;      FOR i DECREASING IN [1..s.length) DO s[i] ¬ s[i - 1] ENDLOOP;      s[0] ¬ '-;      END;    END;  AppendNetworkAddress: PUBLIC PROCEDURE [    x: LONG STRING, n: System.NetworkAddress] =    BEGIN    Append: Format.StringProc = {String.AppendString[x, s]};    Format.NetworkAddress[Append, n, octal];    END;  AppendNetworkNumber: PUBLIC PROCEDURE [    s: LONG STRING, n: System.NetworkNumber] = {    String.AppendLongNumber[s, Swap[LOOPHOLE[n]], 8]};  DisplaySequence: PUBLIC PROCEDURE [    set: Overlap.IntervalSet, Out: Format.StringProc] =    BEGIN    NetworkAddress: Format.StringProc = {      x: CARDINAL ¬ StripSocket[s]; Out[s]; s.length ¬ s.length + x};    who: TimeServiceToolOps.IntersectTag;    Out["{"L];    FOR i: CARDINAL IN [0.. set.size) DO      who ¬ set[i].user;      Format.NetworkAddress[NetworkAddress, who.who, octal];      IF i < set.size - 1 THEN Out[" "L];      ENDLOOP;    Out["}"L];    END;      DisplayServerInfo: PUBLIC PROCEDURE [    info: TimeServiceToolOps.SurveyorInfo, server: TimeServiceToolOps.ServerInfo,    out: Format.StringProc] =    BEGIN    work: LONG STRING ¬ [64];    display: LONG STRING ¬ String.MakeString[zone, 256];    low, high: LONG INTEGER;    work.length ¬ display.length ¬ 0;    [low, high] ¬ TimeServiceToolOps.CalculateRelativeRate[server];    AppendNetworkAddress[work, server.who];    [] ¬ StripSocket[work];    String.AppendString[display, work];    work.length ¬ 0;    IF server.timeAvailable THEN      BEGIN      IF ~server.errorAccurate THEN        String.AppendString[display, " inaccurate"L];      String.AppendString[display, " +/- "L];      String.AppendLongDecimal[work, server.error];      AddDP[work, 3];      String.AppendString[display, work];      work.length ¬ 0;      String.AppendString[display, " + "L];      String.AppendLongDecimal[work, server.delay];      AddDP[work, 3];      String.AppendString[display, work];      work.length ¬ 0;      String.AppendString[display, " off "L];      String.AppendLongDecimal[display, server.offset];      IF server.hasVersion THEN        BEGIN        String.AppendString[display, " version "L];        String.AppendLongDecimal[display, server.version];        END;      IF high # LAST[LONG INTEGER] THEN        BEGIN        String.AppendString[display, " rate "L];        String.AppendLongDecimal[work, (high + low) / 2];        AddDP[work, 6];        String.AppendString[display, work];        work.length ¬ 0;        String.AppendString[display, " +/- "L];        String.AppendLongDecimal[work, (high - low) / 2];        AddDP[work, 6];        String.AppendString[display, work];        work.length ¬ 0;        END;      END    ELSE String.AppendString[display, " has not replied to time req "L];    String.AppendString[display, " reset "L];    Time.Append[display, Time.Unpack[server.resetOn]];    String.AppendString[display, " by "L];    String.AppendLongDecimal[display, server.resetBy];    String.AppendString[display, " from "L];    work.length ¬ 0;    AppendNetworkAddress[work, server.resetUsing];    [] ¬ StripSocket[work];    String.AppendString[display, work];    IF server.resetting THEN String.AppendString[display, " (resetting) "L];    IF NOT server.active THEN String.AppendString[display, " (stopped) "L];    String.AppendString[display, " "L];    String.AppendLongDecimal[display, server.numberRequests];    String.AppendString[display, " req "L];    IF info.gen # server.gen THEN       BEGIN      String.AppendChar[display, '(];      String.AppendDecimal[display, info.gen - server.gen];      String.AppendString[display, " survey"L];      IF info.gen - server.gen > 1 THEN String.AppendChar[display, 's];      String.AppendString[display, " old)"L];      END;    out[display];    String.FreeString[zone, display];    END;  StripSocket: PUBLIC PROCEDURE [s: LONG STRING] RETURNS [strip: CARDINAL] =    BEGIN    strip ¬ 0;    FOR i: CARDINAL DECREASING IN [0..s.length) UNTIL s[i] = '. DO      s.length ¬ PRED[s.length]; strip ¬ SUCC[strip] ENDLOOP;    RETURN[strip];    END;  Swap: PUBLIC PROCEDURE [x: LONG UNSPECIFIED] RETURNS [y: LONG UNSPECIFIED] =    BEGIN    TwoWords: TYPE = MACHINE DEPENDENT RECORD [one, two: WORD];    x2: TwoWords ¬ LOOPHOLE[x];    y2: TwoWords ¬ [x2.two, x2.one];    RETURN[LOOPHOLE[y2]];    END;  END...
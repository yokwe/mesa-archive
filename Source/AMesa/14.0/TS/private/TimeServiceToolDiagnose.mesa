-- File: TimeServiceToolDiagnose.mesa - last edit:-- kam         16-Dec-85 11:40:57-- Copyright (C) 1985 by Xerox Corporation. All rights reserved.DIRECTORY  Format USING [Char, CR, Decimal, NetworkAddress, StringProc],  Overlap USING [    BadInterval, BadMaxErr, ConstructCorrectInterval, IncorrectSubset, Interval,    IntervalRecord, IntervalSet, IntervalSetSequence, zone],  Process USING [Pause, SecondsToTicks, Ticks],  QuickSort USING [CompareProc, Sort, SwapProc],  String USING [AppendLongDecimal],  System USING [NetworkAddress, NetworkNumber],  TimeServiceToolOps USING [    AbortProc, AccessProc, AddDP, AppendNetworkNumber, CalculateRelativeRate,    DisplaySequence, DisplayServerInfo, EnumerateServerInfo, EnumerateSurveyors,    FindNetsWithTimeServers, GetParameters, InsertEntryInRing, IntersectTag,    IntersectTagRecord, IntersectType, StripSocket, SurveyorInfo,    SurveyorInfoRecord, zone];TimeServiceToolDiagnose: PROGRAM  IMPORTS Format, Overlap, Process, QuickSort, String, TimeServiceToolOps  EXPORTS TimeServiceToolOps =  BEGIN  z: UNCOUNTED ZONE = TimeServiceToolOps.zone;  CheckIntervals: PROCEDURE [    out: Format.StringProc, type: TimeServiceToolOps.IntersectType]    RETURNS [problems: BOOLEAN] =    BEGIN    NetworkAddress: Format.StringProc = {      x: CARDINAL ¬ TimeServiceToolOps.StripSocket[s];      out[s]; s.length ¬ s.length + x};    dp: CARDINAL = (IF type = time THEN 3 ELSE 6);    maxErr: CARDINAL ¬ 0;    correctInterval: Overlap.IntervalRecord;    aType: ARRAY TimeServiceToolOps.IntersectType OF STRING = [      " an error"L, " a rate"L];    set: Overlap.IntervalSet ¬ ConstructSequence[type];    correct, incorrect: Overlap.IntervalSet;    problems ¬ FALSE;    IF set = NIL THEN {      out["No server defines"L]; OutCR[out, aType[type]]; RETURN};    Format.Decimal[out, set.size];    out[" servers with"L];    out[aType[type]];    OutCR[out, " were found"L];    correctInterval ¬ Overlap.ConstructCorrectInterval[      set, maxErr ! Overlap.BadMaxErr => {maxErr ¬ smallest; RETRY};        Overlap.BadInterval =>	  BEGIN	  out[" The interval besed on server "L];	  Format.NetworkAddress[	    NetworkAddress, LOOPHOLE[	      set[who], TimeServiceToolOps.IntersectTag].who, octal];	  OutCR[out, " was incorrectly calculated!"L];	  problems ¬ TRUE;	  RESUME;	  END];    IF maxErr = 0 THEN      BEGIN      out["All of the "L];      out[IF type = time THEN "times"L ELSE "rates"L];      out[" agree on the interval"L];      END    ELSE      BEGIN      problems ¬ TRUE;      out["At least "L];      Format.Decimal[out, maxErr];      out[" servers must have an incorrect "L];      out[IF type = time THEN "time"L ELSE "rate"L];      out[", with the rest agreeing on the interval "L];      END;    DisplayInterval[@correctInterval, out, dp];    maxErr ¬      (IF maxErr = 0 THEN (set.size * 5 / 100) ELSE maxErr + (set.size / 100)) +        2;    correctInterval ¬ Overlap.ConstructCorrectInterval[set, maxErr];    [correct, incorrect] ¬ Overlap.IncorrectSubset[set, maxErr];    out["Assuming no more than "L];    Format.Decimal[out, maxErr];    out[" faults, the service agrees on the interval "L];    DisplayInterval[@correctInterval, out, dp];    out["The following servers might have the incorrect "L];    OutCR[out, IF type = time THEN "time:"L ELSE "rate:"L];    TimeServiceToolOps.DisplaySequence[incorrect, out];    Format.CR[out];    problems ¬ DisplayIntervalsNotContainingZero[incorrect, out] OR problems;    DisplayBestIntervals[correct, out, type];    Overlap.zone.FREE[@correct];    Overlap.zone.FREE[@incorrect];    FreeSequence[set];    END;  CheckTimes: PROCEDURE [out: Format.StringProc] RETURNS [problems: BOOLEAN] = {    RETURN CheckIntervals[out, time]};  CheckRates: PROCEDURE [out: Format.StringProc] RETURNS [problems: BOOLEAN] = {    RETURN CheckIntervals[out, rate]};  ConstructSequence: PROCEDURE [type: TimeServiceToolOps.IntersectType]    RETURNS [set: Overlap.IntervalSet] =    BEGIN    defaultMaximumRate: LONG INTEGER = 1000000 / 86400;  -- in microsec/sec    count: CARDINAL ¬ 0;    Value: TYPE = RECORD [int: Overlap.Interval, next: LONG POINTER TO Value];    FreeVal: PROCEDURE [val: LONG POINTER TO LONG POINTER TO Value] = {      z.FREE[@val^^.int.user]; z.FREE[@val^^.int]; z.FREE[val]};    val, next: LONG POINTER TO Value ¬ NIL;    Access: TimeServiceToolOps.AccessProc =      BEGIN      AddToList: PROCEDURE [new: LONG POINTER TO Value]        RETURNS [added: BOOLEAN] =        BEGIN        IF val = NIL THEN {val ¬ new; RETURN[TRUE]};        FOR v: LONG POINTER TO Value ¬ val, v.next DO          IF LOOPHOLE[v.int.user, TimeServiceToolOps.IntersectTag].who.host =            server.who.host THEN {	      FreeVal[@new]; RETURN[FALSE]};          IF v.next = NIL THEN {v.next ¬ new; RETURN[TRUE]};          ENDLOOP;        END;      SELECT type FROM        time =>          IF server.timeAvailable AND server.errorAccurate THEN            IF AddToList[              z.NEW[              Value ¬ [              int: z.NEW[              Overlap.IntervalRecord ¬ [              start: server.offset * 1000 - server.error,              stop: server.offset * 1000 + server.error + server.delay,              user: z.NEW[              TimeServiceToolOps.IntersectTagRecord ¬ [server.who]]]],              next: NIL]]] THEN count ¬ SUCC[count];        rate =>          BEGIN          low, high: LONG INTEGER;          IF server.timeAvailable AND server.errorAccurate THEN            BEGIN            [low, high] ¬ TimeServiceToolOps.CalculateRelativeRate[server];            IF high # LAST[LONG INTEGER] THEN              IF AddToList[                z.NEW[                Value ¬ [                int: z.NEW[                Overlap.IntervalRecord ¬ [                start: low,                stop: high,                user: z.NEW[                TimeServiceToolOps.IntersectTagRecord ¬ [server.who]]]],                next: NIL]]] THEN count ¬ SUCC[count];            END;          END;        ENDCASE;      END;    FOR survey: TimeServiceToolOps.SurveyorInfo ¬      TimeServiceToolOps.EnumerateSurveyors[NIL],      TimeServiceToolOps.EnumerateSurveyors[survey] UNTIL survey = NIL DO      TimeServiceToolOps.EnumerateServerInfo[survey, Access, 0]; ENDLOOP;    IF count = 0 THEN RETURN[NIL];    set ¬ z.NEW[Overlap .IntervalSetSequence[count]];    FOR i: CARDINAL IN [0..count) DO      set[i] ¬ val.int; next ¬ val.next; z.FREE[@val]; val ¬ next ENDLOOP;    END;  Diagnose: PUBLIC PROCEDURE [    hops, timeCheck, rateCheck: CARDINAL, out: Format.StringProc,    Abort: TimeServiceToolOps.AbortProc] RETURNS [problems: BOOLEAN] =    BEGIN    rateCheck ¬ IF rateCheck > timeCheck THEN rateCheck - timeCheck ELSE 0;    StartSurveyors[hops, out];    IF WaitForNPolls[out, timeCheck, Abort] THEN {out["...aborted"L]; RETURN};    problems ¬ CheckTimes[out];    IF WaitForNPolls[out, rateCheck, Abort] THEN {out["...aborted"L]; RETURN};    problems ¬ CheckRates[out] OR problems;    UninitializedServers[out];    END;  DisplayBestIntervals: PROCEDURE [    set: Overlap.IntervalSet, out: Format.StringProc,    type: TimeServiceToolOps.IntersectType] =    BEGIN    NetworkAddress: Format.StringProc = {      x: CARDINAL ¬ TimeServiceToolOps.StripSocket[s];      out[s]; s.length ¬ s.length + x};    first: BOOLEAN ¬ TRUE;    who: TimeServiceToolOps.IntersectTag;    SortSequence[set];    out["The following servers have the best "L];    OutCR[out, IF type = time THEN "times:"L ELSE "rates:"L];    Format.Char[out, '{];    FOR i: CARDINAL IN [0..MIN[set.size, 5]) DO      IF i > 0 THEN Format.Char[out, ' ];      who ¬ set[i].user;      Format.NetworkAddress[NetworkAddress, who.who, octal];      ENDLOOP;    Format.Char[out, '}];    Format.CR[out]    END;  DisplayInterval: PROCEDURE [    int: Overlap.Interval, out: Format.StringProc, dp: CARDINAL] =    BEGIN    work: LONG STRING ¬ [32];    out[" ["L];    work.length ¬ 0;    String.AppendLongDecimal[work, int.start];    TimeServiceToolOps.AddDP[work, dp];    out[work];    out[", "L];    work.length ¬ 0;    String.AppendLongDecimal[work, int.stop];    TimeServiceToolOps.AddDP[work, dp];    out[work];    OutCR[out, "]"L];    END;      DisplayIntervalsNotContainingZero: PROCEDURE [    set: Overlap.IntervalSet, out: Format.StringProc]    RETURNS [problems: BOOLEAN] =    BEGIN    first: BOOLEAN ¬ TRUE;    who: TimeServiceToolOps.IntersectTag;    FOR i: CARDINAL IN [0..set.size) DO      IF set[i].start <= 0 AND set[i].stop >= 0 THEN LOOP;      IF first THEN         BEGIN	out["Of these servers, the following are wrong given the local"L];	OutCR[out," clock is perfect"L];	first ¬ FALSE;	END;      who ¬ set[i].user;      DisplayServerInfo[who.who, out];      ENDLOOP;    IF first THEN OutCR[      out, "If the local clock is perfect, none of these servers are wrong"];    RETURN[NOT first];    END;  DisplayServerInfo: PROCEDURE [    who: System.NetworkAddress, out: Format.StringProc] =    BEGIN    found: BOOLEAN ¬ FALSE;    survey: TimeServiceToolOps.SurveyorInfo;    NetworkAddress: Format.StringProc = {      x: CARDINAL ¬ TimeServiceToolOps.StripSocket[s];      out[s]; s.length ¬ s.length + x};    Access: TimeServiceToolOps.AccessProc =      BEGIN      IF server.who.host = who.host THEN        BEGIN	TimeServiceToolOps.DisplayServerInfo[survey, server, out];	Format.CR[out];	found ¬ TRUE;	END;      END;    FOR survey ¬ TimeServiceToolOps.EnumerateSurveyors[NIL],      TimeServiceToolOps.EnumerateSurveyors[survey] UNTIL survey = NIL DO      IF survey.net = who.net THEN {	TimeServiceToolOps.EnumerateServerInfo[survey, Access, 0]; EXIT};      ENDLOOP;    IF NOT found THEN      BEGIN      Format.NetworkAddress[NetworkAddress, who, octal];      OutCR[out, ": no information?!!?"];      END;    END;      FreeSequence: PROCEDURE [set: Overlap.IntervalSet] =    BEGIN    IF set = NIL THEN RETURN;    FOR i: CARDINAL IN [0..set.size) DO      z.FREE[@set[i].user]; z.FREE[@set[i]] ENDLOOP;    z.FREE[@set];    END;  OutCR: PROCEDURE [out: Format.StringProc, s: LONG STRING] = {    out[s]; Format.CR[out]};  SortSequence: PROCEDURE [set: Overlap.IntervalSet] =    BEGIN    Compare: QuickSort.CompareProc =      BEGIN      x: LONG INTEGER = Value[set[one]];      y: LONG INTEGER = Value[set[two]];      RETURN[SELECT x FROM = y => same, > y => bigger, ENDCASE => smaller];      END;    Swap: QuickSort.SwapProc =      BEGIN      interval: Overlap.Interval ¬ set[one];      set[one] ¬ set[two];      set[two] ¬ interval;      END;    Value: PROCEDURE [int: Overlap.Interval] RETURNS [LONG INTEGER] = INLINE {      RETURN[int.stop - int.start]};    QuickSort.Sort[0, set.size - 1, Compare, Swap, set];    END;  StartSurveyors: PROCEDURE [hops: CARDINAL, out: Format.StringProc] =    BEGIN    s: LONG STRING ¬ [32];    StartThisNet: PROCEDURE [n: System.NetworkNumber] =      BEGIN      info: TimeServiceToolOps.SurveyorInfo ¬ z.NEW[        TimeServiceToolOps.SurveyorInfoRecord ¬ [n, 0, NIL]];      IF NOT TimeServiceToolOps.InsertEntryInRing[info] THEN z.FREE[@info]      ELSE        BEGIN        out["Survey of net "L];        s.length ¬ 0;        TimeServiceToolOps.AppendNetworkNumber[s, n];        out[s];        OutCR[out, " started"L];        END;      END;    TimeServiceToolOps.FindNetsWithTimeServers[hops, StartThisNet];    END;  UninitializedServers: PROCEDURE [out: Format.StringProc] =    BEGIN    NetworkAddress: Format.StringProc = {      x: CARDINAL ¬ TimeServiceToolOps.StripSocket[s];      out[s]; s.length ¬ s.length + x};    found: BOOLEAN ¬ FALSE;    survey: TimeServiceToolOps.SurveyorInfo;    Access: TimeServiceToolOps.AccessProc =      BEGIN      IF NOT server.errorAccurate THEN        BEGIN	IF NOT found THEN	  BEGIN	  found ¬ TRUE;	  OutCR[out, "The following servers have inaccurate errors:"L];	  END;	TimeServiceToolOps.DisplayServerInfo[survey, server, out];	Format.CR[out];	END;      END;    FOR survey ¬ TimeServiceToolOps.EnumerateSurveyors[NIL],      TimeServiceToolOps.EnumerateSurveyors[survey] UNTIL survey = NIL DO      TimeServiceToolOps.EnumerateServerInfo[survey, Access, 0]; ENDLOOP;    IF NOT found THEN OutCR[out, "No servers have inaccurate errors"L];    END;  WaitForNPolls: PUBLIC PROCEDURE [    out: Format.StringProc, when: CARDINAL,    Abort: PROCEDURE RETURNS [abort: BOOLEAN]] RETURNS [aborted: BOOLEAN] =    BEGIN    DisplayTimes: PROCEDURE =      BEGIN      SELECT this FROM        0 => OutCR[out, "Not all nets have been surveyed"L];        1 => OutCR[out, "All nets have been surveyed once"L];        ENDCASE => {          out["All nets have been surveyed "L];          Format.Decimal[out, this];          OutCR[out, " times"L]};      END;    twoSeconds: Process.Ticks = Process.SecondsToTicks[2];    last: CARDINAL ¬ TimeServiceToolOps.GetParameters[].minimumTimesSurveyed;    this, first: CARDINAL ¬ last;    DisplayTimes[];    WHILE (this ¬ TimeServiceToolOps.GetParameters[].minimumTimesSurveyed) <      first + when DO      IF Abort[] THEN RETURN[TRUE];      IF this # last THEN {DisplayTimes[]; last ¬ this};      Process.Pause[twoSeconds];      ENDLOOP;    RETURN[FALSE];    END;  END...
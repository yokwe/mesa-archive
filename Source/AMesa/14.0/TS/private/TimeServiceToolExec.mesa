-- File: TimeServiceToolExec.mesa - last edit:-- kam         16-Dec-85 11:39:47-- Copyright (C) 1985 by Xerox Corporation. All rights reserved.DIRECTORY  AddressTranslation USING [Error, StringToNetworkAddress],  Ascii USING [CR, SP],  Exec USING [    AddCommand, CheckForAbort, EndOfCommandLine, ExecProc, FreeTokenString,    GetToken, Handle, OutputProc, PutChar],  Format USING [    CR, Date, Decimal, LongDecimal, LongNumber, LongOctal, NetworkAddress,    StringProc],  Overlap USING [Interval, IntervalRecord, IntervalSet, IntervalSetSequence],  Process USING [SecondsToTicks, SetTimeout, Ticks],  Runtime USING [IsBound],  SpecialSystem USING [SetBackTooFar],  String USING [InvalidNumber, LowerCase, StringToDecimal, StringToLongNumber],  StringLookUp USING [ambiguous, InTable, noMatch, TableDesc],  System USING [    GreenwichMeanTime, NetworkAddress, NetworkNumber, nullNetworkAddress],  TimeServerClock USING [AdjustClock, Invalid, Read],  TimeServerFormat USING [TSPacket],  TimeServerOps USING [Start, Status, Stop],  TimeServiceToolOps USING [    AbortProc, AccessProc, AppendNetworkNumber, CalculateRelativeRate,    DeleteSurveyors, Diagnose, DisplayServerInfo, EnumerateServerInfo,    EnumerateSurveyors, FindNetsWithTimeServers, GetParameters,    InsertEntryInRing, Intersect, IntersectTag, IntersectTagRecord,    IntersectType, Monitor, SendCommand, ServerInfo, SetParameters, StripSocket,    SurveyActive, SurveyorInfo, SurveyorInfoRecord, WaitForNPolls, zone];TimeServiceToolExec: MONITOR  IMPORTS    AddressTranslation, Exec, Format, Process, Runtime, SpecialSystem,    TimeServerClock, TimeServerOps, TimeServiceToolOps, String, StringLookUp =  BEGIN  z: UNCOUNTED ZONE = TimeServiceToolOps.zone;  << These next procedures provide the serialization of the Quit command. When  Quit is entered, all earlier commands will run to termination, but all later  commands will not be executed until the Quit finishes. >>  commandsActive: CARDINAL ¬ 0;  quitPending: BOOLEAN ¬ FALSE;  commandFinished, quitFinished: CONDITION;  Abort: ERROR = CODE;  trim: CARDINAL ¬ 0;  LockCommand: ENTRY PROCEDURE [h: Exec.Handle] =    BEGIN    ENABLE UNWIND => NULL;    WHILE quitPending DO      IF Exec.CheckForAbort[h] THEN ERROR Abort; WAIT quitFinished; ENDLOOP;    commandsActive ¬ SUCC[commandsActive];    END;  LockQuit: ENTRY PROCEDURE [h: Exec.Handle]    RETURNS [alreadyQuitPending: BOOLEAN] =    BEGIN    ENABLE UNWIND => quitPending ¬ FALSE;    IF quitPending THEN RETURN[TRUE];    quitPending ¬ TRUE;    WHILE commandsActive > 0 DO      IF Exec.CheckForAbort[h] THEN ERROR Abort; WAIT commandFinished; ENDLOOP;    RETURN[FALSE];    END;  UnlockCommand: ENTRY PROCEDURE =    BEGIN    ENABLE UNWIND => NULL;    commandsActive ¬ PRED[commandsActive];    NOTIFY commandFinished;    END;  UnlockQuit: ENTRY PROCEDURE = {    ENABLE UNWIND => NULL; quitPending ¬ FALSE; BROADCAST quitFinished};  << The following are the nonmonitored procedures of this module >>  DoThisNetworkProc: TYPE = PROCEDURE [    net: System.NetworkNumber, text: LONG STRING];  DoThisServerProc: TYPE = PROCEDURE [    who: System.NetworkAddress, text: LONG STRING];      MyServerState: TYPE = {started, stopped, nonexistant};  TokenWithSwitches: SIGNAL [token, switches: LONG STRING] = CODE;  BaseCommand: Exec.ExecProc =    BEGIN    out: Format.StringProc = Exec.OutputProc[h];    OutCR: Format.StringProc = {out[s]; Exec.PutChar[h, Ascii.CR]};    token, switches: LONG STRING;    numberCommands: CARDINAL = 19;    index: CARDINAL;    commandTable: ARRAY [0..numberCommands) OF LONG STRING ¬ [      "BestServer"L, "Clock"L, "Consistency"L, "Consonance"L, "Diagnose"L,      "EnumerateNetwork"L, "FindServers"L, "Help"L, "Information"L, "Me"L,      "Monitor"L, "Pause"L, "Reset"L, "ServerInfo"L, "SetParameters"L,      "Start"L, "Stop"L, "SurveyNetwork"L, "Quit"L];    commandProcs: ARRAY [0..numberCommands) OF Exec.ExecProc ¬ [      BestServer, Clock, Consistency, Consonance, Diagnose, EnumerateNetwork,      FindServers, Help, Information, Me, Monitor, Pause, Reset, ServerInfo,      SetParameters, Start, Stop, SurveyNetwork, Quit];    commands: StringLookUp.TableDesc = DESCRIPTOR[commandTable];    [token, switches] ¬ Exec.GetToken[h];    switches ¬ Exec.FreeTokenString[switches];    IF token = NIL THEN      BEGIN      out["The possible commands are "L];      FOR index IN [0..numberCommands) DO        out[commandTable[index]]; out["  "L] ENDLOOP;      RETURN;      END;    index ¬ StringLookUp.InTable[key: token, table: commands];    token ¬ Exec.FreeTokenString[token];    BEGIN    ENABLE      BEGIN      TokenWithSwitches =>        BEGIN        out["The parameter "L];        out[token];        Exec.PutChar[h, '/];        out[switches];        OutCR[" will be ignored"L];        RESUME        END;      Abort => {out[" ...aborted"L]; CONTINUE};      END;    SELECT index FROM      IN [0..numberCommands) =>        BEGIN        locked: BOOLEAN ¬ FALSE;        IF commandProcs[index] = Quit THEN          BEGIN          ENABLE UNWIND => IF locked THEN UnlockQuit[];          IF LockQuit[h] THEN RETURN;          locked ¬ TRUE;          outcome ¬ Quit[h, clientData];          UnlockQuit[];          END        ELSE          BEGIN          ENABLE UNWIND => IF locked THEN UnlockCommand[];          LockCommand[h];          locked ¬ TRUE;          outcome ¬ commandProcs[index][h, clientData];          UnlockCommand[];          END;        RETURN[outcome];        END;      StringLookUp.ambiguous => out["Ambiguous command"L];      StringLookUp.noMatch => out["Unknown command"L];      ENDCASE => out["Unknown error in parsing of command"L];    END;    RETURN;    END;  BestServer: Exec.ExecProc =    BEGIN    out: Format.StringProc = Exec.OutputProc[h];    OutCR: Format.StringProc = {out[s]; Exec.PutChar[h, Ascii.CR]};    NetworkAddress: Format.StringProc = {      x: CARDINAL ¬ TimeServiceToolOps.StripSocket[s];      out[s]; s.length ¬ s.length + x};    SurveyInfo: TYPE = LONG POINTER TO SurveyInfoRecord;    SurveyInfoRecord: TYPE = RECORD [      who: System.NetworkAddress ¬ System.nullNetworkAddress,      error: LONG CARDINAL ¬ 0,      offset: LONG INTEGER ¬ 0,      hasVersion: BOOLEAN ¬ FALSE,      version: LONG CARDINAL ¬ 0,      next: SurveyInfo ¬ NIL];    surveyInfo: SurveyInfo ¬ NIL;    best: SurveyInfoRecord ¬ [];    diff: LONG CARDINAL ¬ 0;    DeleteList: PROCEDURE =      BEGIN      freeMe: SurveyInfo;      FOR freeMe ¬ surveyInfo, surveyInfo UNTIL surveyInfo = NIL DO        surveyInfo ¬ surveyInfo.next; z.FREE[@freeMe] ENDLOOP;      END;    BEGIN    ENABLE UNWIND => DeleteList[];    DoOne: DoThisNetworkProc =      BEGIN      Access: TimeServiceToolOps.AccessProc =	BEGIN	IF NOT server.timeAvailable OR NOT server.errorAccurate THEN RETURN;	IF surveyInfo.who = System.nullNetworkAddress	  OR server.error < surveyInfo.error THEN	  BEGIN	  surveyInfo.who ¬ server.who;	  surveyInfo.error ¬ server.error;	  surveyInfo.offset ¬ server.offset;	  surveyInfo.hasVersion ¬ server.hasVersion;	  surveyInfo.version ¬ server.version;	  END;	END;      FOR survey: TimeServiceToolOps.SurveyorInfo ¬        TimeServiceToolOps.EnumerateSurveyors[NIL],        TimeServiceToolOps.EnumerateSurveyors[survey] UNTIL survey = NIL DO        IF survey.net = net THEN	  BEGIN	  surveyInfo ¬ z.NEW[SurveyInfoRecord ¬ [next: surveyInfo]];          TimeServiceToolOps.EnumerateServerInfo[survey, Access, trim];	  EXIT	  END;        REPEAT FINISHED => {out[text]; OutCR[" is not being surveyed"L]};        ENDLOOP;      END;    Minimum: PROCEDURE RETURNS [best: SurveyInfoRecord] =      BEGIN      best ¬ [];      FOR p: SurveyInfo ¬ surveyInfo, p.next UNTIL p = NIL DO	IF p.who # System.nullNetworkAddress	  AND (best.who = System.nullNetworkAddress	  OR p.error < best.error) THEN best ¬ p^ ENDLOOP;      END;          IF ParseNetworkNumberString[h, DoOne !      TokenWithSwitches => IF String.LowerCase[switches[0]] = 'd THEN	BEGIN	failed: BOOLEAN ¬ FALSE;	diff ¬ String.StringToLongNumber[	  token ! String.InvalidNumber => {failed ¬ TRUE; CONTINUE}]*1000;	IF failed THEN {out[token]; OutCR[" is not a number"L]}	ELSE IF diff > 0 THEN	  BEGIN	  out["Will list nets whose best servers differ from the best by "L];	  out[token];	  OutCR[" seconds"L];	  END;	RESUME	END] = 0 THEN {      out["No valid network was specified..."L]; GOTO CleanUp};    best ¬ Minimum[];    IF surveyInfo = NIL OR best.who = System.nullNetworkAddress THEN {      out["No server with an error was found..."L]; GOTO CleanUp};    out["The server with the smallest error is "L];    Format.NetworkAddress[NetworkAddress, best.who, octal];    out[" offset "L];    Format.LongDecimal[out, best.offset];    out[" error "L];    Format.LongDecimal[out, best.error];    IF best.hasVersion THEN {      out[" version "L]; Format.LongDecimal[out, best.version]};    IF diff # 0 THEN      BEGIN      first: BOOLEAN ¬ TRUE;      Format.CR[out];      FOR p: SurveyInfo ¬ surveyInfo, p.next UNTIL p = NIL DO	IF p.who # System.nullNetworkAddress AND p.error >= diff + best.error          THEN	  BEGIN	  IF first THEN {first ¬ FALSE; out["{"L]} ELSE out[" "L];	  Format.NetworkAddress[NetworkAddress, p.who, octal];	  END;	ENDLOOP;      out[IF first THEN "{}"L ELSE "}"L];       END;    DeleteList[];    EXITS CleanUp => DeleteList[];    END;    END;  Clock: Exec.ExecProc =    BEGIN    out: Format.StringProc = h.OutputProc[];    OutCR: Format.StringProc = {out[s]; h.PutChar[Ascii.CR]};    error, version: LONG CARDINAL;    accurate: BOOLEAN;    time: System.GreenwichMeanTime;    IF MyServerInfo[] = nonexistant THEN {      out["Please start a time server and reissue this command"L]; RETURN};    IF NOT h.EndOfCommandLine[] THEN      BEGIN      newVersion, failed: BOOLEAN ¬ FALSE;      token, switches: LONG STRING;      delta: LONG INTEGER;      [token, switches] ¬ h.GetToken[];      newVersion ¬ switches # NIL AND (switches[0] = 'n OR switches[0] = 'N);      switches ¬ Exec.FreeTokenString[switches];      delta ¬ String.StringToDecimal[        token ! String.InvalidNumber => {failed ¬ TRUE; CONTINUE}];      token ¬ Exec.FreeTokenString[token];      IF failed THEN {        out["the first parameter is not a number"L]; RETURN[error]};      IF h.EndOfCommandLine[] THEN        error ¬ TimeServerClock.Read[          ! TimeServerClock.Invalid => CONTINUE].error      ELSE        BEGIN        [token, switches] ¬ h.GetToken[];        switches ¬ Exec.FreeTokenString[switches];        error ¬ String.StringToLongNumber[          token ! String.InvalidNumber => {failed ¬ TRUE; CONTINUE}];        token ¬ Exec.FreeTokenString[token];        IF failed THEN {          out["the second parameter is not a number"L]; RETURN[error]};        END;      TimeServerClock.AdjustClock[        delta, error, newVersion !        SpecialSystem.SetBackTooFar => {failed ¬ TRUE; CONTINUE}];      IF failed THEN {out["attempt to set clock back too far"L]; RETURN[error]};      END;    [time, error, accurate, version] ¬ TimeServerClock.Read[      ! TimeServerClock.Invalid => CONTINUE];    Format.Date[out, time, dateTime];    out[" +/- "L];    IF NOT accurate THEN out["inaccurate "L];    Format.LongNumber[out, error, []];    out[" version "L];    Format.LongNumber[out, version, []];    END;  Consistency: Exec.ExecProc =    BEGIN    maxErr: CARDINAL ¬ 0;    out: Format.StringProc = Exec.OutputProc[h];    set: Overlap.IntervalSet ¬ ConstructSequence[      h, time !      TokenWithSwitches =>        BEGIN        IF switches[0] = 'm OR switches[0] = 'M THEN          maxErr ¬ String.StringToDecimal[            token !            String.InvalidNumber => {              out[token];              out[" is not a number!"L];              Exec.PutChar[h, Ascii.CR]}];        RESUME        END];    [] ¬ TimeServiceToolOps.Intersect[set, time, maxErr, out];    FreeSequence[set];    END;  Consonance: Exec.ExecProc =    BEGIN    maxErr: CARDINAL ¬ 0;    out: Format.StringProc = Exec.OutputProc[h];    set: Overlap.IntervalSet ¬ ConstructSequence[      h, rate !      TokenWithSwitches =>        BEGIN        IF switches[0] = 'm OR switches[0] = 'M THEN          maxErr ¬ String.StringToDecimal[            token !            String.InvalidNumber => {              out[token];              out[" is not a number!"L];              Exec.PutChar[h, Ascii.CR]}];        RESUME        END];    [] ¬ TimeServiceToolOps.Intersect[set, rate, maxErr, out];    FreeSequence[set];    END;  ConstructSequence: PROCEDURE [    h: Exec.Handle, type: TimeServiceToolOps.IntersectType]    RETURNS [set: Overlap.IntervalSet] =    BEGIN    out: Format.StringProc = Exec.OutputProc[h];    OutCR: Format.StringProc = {out[s]; Exec.PutChar[h, Ascii.CR]};    defaultMaximumRate: LONG INTEGER = 1000000 / 86400;  -- in microsec/sec    count: CARDINAL ¬ 0;    Value: TYPE = RECORD [int: Overlap.Interval, next: LONG POINTER TO Value];    val, next: LONG POINTER TO Value ¬ NIL;    FreeVal: PROCEDURE [val: LONG POINTER TO LONG POINTER TO Value] = {      z.FREE[@val^^.int.user]; z.FREE[@val^^.int]; z.FREE[val]};    BEGIN    ENABLE      UNWIND =>        UNTIL val = NIL DO next ¬ val.next; FreeVal[@val]; val ¬ next ENDLOOP;    Access: TimeServiceToolOps.AccessProc =      BEGIN      AddToList: PROCEDURE [new: LONG POINTER TO Value]        RETURNS [added: BOOLEAN] =        BEGIN        IF val = NIL THEN {val ¬ new; RETURN[TRUE]};        FOR v: LONG POINTER TO Value ¬ val, v.next DO          IF LOOPHOLE[v.int.user, TimeServiceToolOps.IntersectTag].who.host =            server.who.host THEN {FreeVal[@new]; RETURN[FALSE]};          IF v.next = NIL THEN {v.next ¬ new; RETURN[TRUE]};          ENDLOOP;        END;      IF Exec.CheckForAbort[h] THEN ERROR Abort;      SELECT type FROM        time =>          IF server.timeAvailable AND server.errorAccurate THEN            IF AddToList[              z.NEW[              Value ¬ [              int: z.NEW[              Overlap.IntervalRecord ¬ [              start: server.offset * 1000 - server.error,              stop: server.offset * 1000 + server.error + server.delay,              user: z.NEW[              TimeServiceToolOps.IntersectTagRecord ¬ [server.who]]]],              next: NIL]]] THEN count ¬ SUCC[count];        rate =>          BEGIN          low, high: LONG INTEGER;          IF server.timeAvailable AND server.errorAccurate THEN            BEGIN            [low, high] ¬ TimeServiceToolOps.CalculateRelativeRate[server];            IF high # LAST[LONG INTEGER] THEN              IF AddToList[                z.NEW[                Value ¬ [                int: z.NEW[                Overlap.IntervalRecord ¬ [                start: low,                stop: high,                user: z.NEW[                TimeServiceToolOps.IntersectTagRecord ¬ [server.who]]]],                next: NIL]]] THEN count ¬ SUCC[count];            END;          END;        ENDCASE;      END;    DoOne: DoThisNetworkProc =      BEGIN      FOR survey: TimeServiceToolOps.SurveyorInfo ¬        TimeServiceToolOps.EnumerateSurveyors[NIL],        TimeServiceToolOps.EnumerateSurveyors[survey] UNTIL survey = NIL DO        IF survey.net = net THEN {          TimeServiceToolOps.EnumerateServerInfo[survey, Access, trim]; EXIT}        REPEAT FINISHED => {out[text]; OutCR[" is not being surveyed"L]};        ENDLOOP;      END;    IF ParseNetworkNumberString[h, DoOne] = 0 THEN {      out["No valid network was specified..."L]; RETURN[NIL]};    IF count = 0 THEN {out["No server defines an interval..."L]; RETURN[NIL]};    set ¬ z.NEW[Overlap .IntervalSetSequence[count]];    FOR i: CARDINAL IN [0..count) DO      set[i] ¬ val.int; next ¬ val.next; z.FREE[@val]; val ¬ next ENDLOOP;    END;    END;  Diagnose: Exec.ExecProc =    BEGIN    token, switches: LONG STRING;    hops: CARDINAL ¬ 15;    timeCheck: CARDINAL ¬ 3;    rateCheck: CARDINAL ¬ 6;    value: CARDINAL;    failed: BOOLEAN;    Abort: TimeServiceToolOps.AbortProc = {RETURN Exec.CheckForAbort[h]};    UNTIL Exec.EndOfCommandLine[h] DO      [token, switches] ¬ Exec.GetToken[h];      failed ¬ FALSE;      value ¬ String.StringToDecimal[        token ! String.InvalidNumber => {failed ¬ TRUE; CONTINUE}];      IF NOT failed AND switches # NIL THEN        SELECT switches[0] FROM          'h, 'H => hops ¬ value;          't, 'T => timeCheck ¬ value;          'r, 'R => rateCheck ¬ value;          ENDCASE;      token ¬ Exec.FreeTokenString[token];      switches ¬ Exec.FreeTokenString[switches];      ENDLOOP;    [] ¬ TimeServiceToolOps.Diagnose[      hops, timeCheck, rateCheck, Exec.OutputProc[h], Abort];    END;  EnumerateNetwork: Exec.ExecProc =    BEGIN    out: Format.StringProc = Exec.OutputProc[h];    OutCR: Format.StringProc = {out[s]; Exec.PutChar[h, Ascii.CR]};    DoOne: DoThisNetworkProc =      BEGIN      survey: TimeServiceToolOps.SurveyorInfo;      Access: TimeServiceToolOps.AccessProc =        BEGIN        IF Exec.CheckForAbort[h] THEN ERROR Abort;        TimeServiceToolOps.DisplayServerInfo[survey, server, OutCR];        END;      FOR survey ¬ TimeServiceToolOps.EnumerateSurveyors[NIL],        TimeServiceToolOps.EnumerateSurveyors[survey] UNTIL survey = NIL DO        IF survey.net = net THEN {          TimeServiceToolOps.EnumerateServerInfo[survey, Access, trim]; EXIT}        REPEAT FINISHED => {out[text]; OutCR[" is not being surveyed"L]};        ENDLOOP;      END;    IF ParseNetworkNumberString[h, DoOne] = 0 THEN      out["No valid network was specified..."L];    END;  FreeSequence: PROCEDURE [set: Overlap.IntervalSet] =    BEGIN    IF set = NIL THEN RETURN;    FOR i: CARDINAL IN [0..set.size) DO      z.FREE[@set[i].user]; z.FREE[@set[i]] ENDLOOP;    z.FREE[@set];    END;  FindServers: Exec.ExecProc =    BEGIN    out: Format.StringProc = Exec.OutputProc[h];    work: LONG STRING ¬ [32];    GotOne: PROCEDURE [n: System.NetworkNumber] =      BEGIN      work.length ¬ 0;      TimeServiceToolOps.AppendNetworkNumber[work, n];      out[work];      Exec.PutChar[h, Ascii.SP];      END;    TimeServiceToolOps.FindNetsWithTimeServers[15, GotOne];    END;  Help: Exec.ExecProc =    BEGIN    out: Format.StringProc = Exec.OutputProc[h];    P: Format.StringProc = {out[s]; Exec.PutChar[h, Ascii.CR]};    P["BestServer <nets> finds the server in nets with the smallest error"L];    P["Clock offset error sets the local clock and error to the specified "L];    P["   values. If offset has the N switch, the version number is"L];    P["   incremented"L];    P["Consistency [number/m] <nets> checks the nets for consistency"L];    P["   number is the maximum number of incorrect servers (defaults to 0)"L];    P["Consonance [number/m] <nets> checks the nets for consonance"L];    P["   number is the maximum number of inaccurate servers (defaults to 0)"L];    P["Diagnose [hops/h] [timeCheck/t] [rateCheck/r] attempts to isolate the"L];    P["   faulty servers up to hops away (defaults to 15). timeCheck and"L];    P["   rateCheck are the number of surveys which must take place before"L];    P["   the corresponding information is checked (defaults to 3 and 6,"L];    P["   respectively)"L];    P["EnumerateNetwork <nets> lists the servers in these nets"L];    P["FindServers lists nets with time servers"L];    P["Help types this information"L];    P["Information lists various information about the survey"L];    P["Me {start, stop} starts or stops the local time server"L];    P["Monitor [time/t] [number/n] periodically diagnoses the time service"L];    P["   using the currently active surveyors. time is the number of minutes"L];    P["   between diagnoses (default 60) and number is the number of"L];    P["   diagnoses by which the results will always be mailed (default 6)."L];     P["   Requires To:, Cc: and Troubles: r-names in the TS section of User.cm"L];    P["Pause [n] waits for n more surveys to complete (default one)"L];    P["Reset address <addresses> resets the servers in the address list"L];    P["   from the first server"L];    P["ServerInfo <addresses> lists collected information about the servers"L];    P["SetParameters [processes/p] [delay/d] [trim/t] sets:"L];    P["  - the number of possible concurrent surveys to processes"L];    P["  - the minimum delay between surveys of a network to delay seconds"L];    P["  - the number of surveys for which after a server does not respond"L];    P["    its value is ignored to trim (trim = 0 means never ignore)"L];    P["Start <addresses> starts the servers"L];    P["Stop <addresses> stops the servers"L];    P["SurveyNetwork <nets> starts surveying the specified networks"L];    P["Quit stops all surveying"L];    END;  Information: Exec.ExecProc =    BEGIN    out: Format.StringProc = Exec.OutputProc[h];    OutCR: Format.StringProc = {out[s]; Exec.PutChar[h, Ascii.CR]};    StripB: Format.StringProc =      BEGIN      IF s[s.length - 1] = 'B THEN {        s.length ¬ PRED[s.length]; out[s]; s.length ¬ SUCC[s.length]}	ELSE out[s];      END;    gotOne: BOOLEAN ¬ FALSE;    maxSurveyors, delay, count: CARDINAL;    [maxSurveyors, delay, count] ¬ TimeServiceToolOps.GetParameters[];    out["The maximum number of processes is "L];    Format.Decimal[OutCR, maxSurveyors];    out["The minimum delay between surveys of a network is "L];    Format.Decimal[out, delay];    OutCR[" seconds"L];    IF trim = 0 THEN OutCR["All collected values will be used"L]    ELSE      BEGIN      out["Only values from servers which have responded in the last "L];      IF trim = 1 THEN out["survey"L]      ELSE {Format.Decimal[out, trim]; out[" surveys"L]};      OutCR[" will be used"L];      END;    OutCR[      SELECT MyServerInfo[] FROM	nonexistant => "There is no local server"L,	started => "The local server is active"L,	ENDCASE => "The local server is stopped"L];    FOR survey: TimeServiceToolOps.SurveyorInfo ¬      TimeServiceToolOps.EnumerateSurveyors[NIL],      TimeServiceToolOps.EnumerateSurveyors[survey] UNTIL survey = NIL DO      IF NOT gotOne THEN {        out["The following nets are being surveyed: "L]; gotOne ¬ TRUE};      Format.LongOctal[StripB, Swap[LOOPHOLE[survey.net]]];      IF TimeServiceToolOps.SurveyActive[survey] THEN Exec.PutChar[h, '~];      Exec.PutChar[h, Ascii.SP];      ENDLOOP;    IF gotOne THEN      BEGIN      Exec.PutChar[h, Ascii.CR];      SELECT count FROM        0 => out["Not all nets have been surveyed"L];        1 => out["All nets have been surveyed at least once"L];        ENDCASE =>          BEGIN          out["All nets have been surveyed at least "L];          Format.Decimal[out, count];          out[" times"L];          END;      END    ELSE out["No nets are being surveyed"L];    END;  Init: PROCEDURE =    BEGIN    second: Process.Ticks = Process.SecondsToTicks[1];    Exec.AddCommand["TS.~"L, BaseCommand, Help];    Process.SetTimeout[@quitFinished, second];    Process.SetTimeout[@commandFinished, second];    END;  Me: Exec.ExecProc =    BEGIN    out: Format.StringProc = Exec.OutputProc[h];    OutCR: Format.StringProc = {out[s]; h.PutChar[Ascii.CR]};    tokenTable: ARRAY [0..2) OF LONG STRING ¬ ["start"L, "stop"L];    index: CARDINAL;    token, switches: LONG STRING;    [token, switches] ¬ Exec.GetToken[h];    switches ¬ Exec.FreeTokenString[switches];    IF token # NIL THEN      BEGIN      index ¬ StringLookUp.InTable[key: token, table: DESCRIPTOR[tokenTable]];      token ¬ Exec.FreeTokenString[token];      IF MyServerInfo[] = nonexistant THEN OutCR[        "Please start a time server and reissue this command"L]      ELSE        SELECT index FROM	  0 => TimeServerOps.Start[];	  1 => TimeServerOps.Stop[];	  StringLookUp.ambiguous => OutCR["The parameter is ambiguous"L];	  StringLookUp.noMatch => OutCR["The parameter must be start or stop"L];	  ENDCASE => OutCR["Unknown error"L];      END;    out[      SELECT MyServerInfo[] FROM	nonexistant => "There is no local server"L,	started => "The local server is active"L,	ENDCASE => "The local server is stopped"L];    END;  Monitor: Exec.ExecProc =    BEGIN    token, switches: LONG STRING;    time: CARDINAL ¬ 60;    number: CARDINAL ¬ 6;    value: CARDINAL;    failed: BOOLEAN;    Abort: TimeServiceToolOps.AbortProc = {RETURN Exec.CheckForAbort[h]};    Out: Format.StringProc = Exec.OutputProc[h];    UNTIL Exec.EndOfCommandLine[h] DO      [token, switches] ¬ Exec.GetToken[h];      failed ¬ FALSE;      value ¬ String.StringToDecimal[        token ! String.InvalidNumber => {failed ¬ TRUE; CONTINUE}];      IF NOT failed AND switches # NIL THEN        SELECT switches[0] FROM          't, 'T => time ¬ value;          'n, 'N => number ¬ value;          ENDCASE;      token ¬ Exec.FreeTokenString[token];      switches ¬ Exec.FreeTokenString[switches];      ENDLOOP;    TimeServiceToolOps.Monitor[time, number, Out, Abort];    END;  MyServerInfo: PROCEDURE RETURNS [state: MyServerState] =    BEGIN    stats: statisticResponse TimeServerFormat.TSPacket;    IF NOT Runtime.IsBound[LOOPHOLE[TimeServerOps.Start]]      THEN RETURN[nonexistant];    stats ¬ TimeServerOps.Status[];    RETURN[IF stats.active THEN started ELSE stopped];    END;    ParseNetworkAddressString: PROCEDURE [h: Exec.Handle, doOne: DoThisServerProc]    RETURNS [numberServers: CARDINAL] =    BEGIN    token, switches: LONG STRING;    server: System.NetworkAddress;    failed, dotted: BOOLEAN;    out: Format.StringProc = Exec.OutputProc[h];    OutCR: Format.StringProc = {out[s]; Exec.PutChar[h, Ascii.CR]};    DotToPoundSign: PROCEDURE [name: LONG STRING] =      BEGIN      FOR i: CARDINAL IN [0..name.length) DO        IF name[i] = '. THEN name[i] ¬ '# ENDLOOP;      END;    numberServers ¬ 0;    UNTIL Exec.EndOfCommandLine[h] DO      IF Exec.CheckForAbort[h] THEN ERROR Abort;      [token, switches] ¬ Exec.GetToken[h];      IF switches # NIL THEN        BEGIN        ENABLE          UNWIND =>            BEGIN            IF token # NIL THEN token ¬ Exec.FreeTokenString[token];            IF switches # NIL THEN switches ¬ Exec.FreeTokenString[switches];            END;        SIGNAL TokenWithSwitches[token, switches];        switches ¬ Exec.FreeTokenString[switches];        token ¬ Exec.FreeTokenString[token];        LOOP;        END;      failed ¬ dotted ¬ FALSE;      server ¬ AddressTranslation.StringToNetworkAddress[        token !        AddressTranslation.Error =>          BEGIN          IF dotted THEN {failed ¬ TRUE; CONTINUE}          ELSE {DotToPoundSign[token]; dotted ¬ TRUE; RETRY};          END].addr;      IF failed THEN {out[token]; OutCR[" is not a valid address!"L]}      ELSE {numberServers ¬ SUCC[numberServers]; doOne[server, token]};      token ¬ Exec.FreeTokenString[token];      ENDLOOP;    RETURN[numberServers];    END;  ParseNetworkNumberString: PROCEDURE [h: Exec.Handle, doOne: DoThisNetworkProc]    RETURNS [numberNets: CARDINAL] =    BEGIN    token, switches: LONG STRING;    net: System.NetworkNumber;    failed, twiddleStripped: BOOLEAN;    out: Format.StringProc = Exec.OutputProc[h];    OutCR: Format.StringProc = {out[s]; Exec.PutChar[h, Ascii.CR]};    numberNets ¬ 0;    UNTIL Exec.EndOfCommandLine[h] DO      IF Exec.CheckForAbort[h] THEN ERROR Abort;      [token, switches] ¬ Exec.GetToken[h];      IF switches # NIL THEN        BEGIN        ENABLE          UNWIND =>            BEGIN            IF token # NIL THEN token ¬ Exec.FreeTokenString[token];            IF switches # NIL THEN switches ¬ Exec.FreeTokenString[switches];            END;        SIGNAL TokenWithSwitches[token, switches];        switches ¬ Exec.FreeTokenString[switches];        token ¬ Exec.FreeTokenString[token];        LOOP;        END;      failed ¬ FALSE;      IF token[token.length - 1] = '~ THEN {        twiddleStripped ¬ TRUE; token.length ¬ PRED[token.length]};      net ¬ LOOPHOLE[Swap[        String.StringToLongNumber[        token, 8 ! String.InvalidNumber => {failed ¬ TRUE; CONTINUE}]]];      IF failed THEN {out[token]; OutCR[" is not a valid network!"L]}      ELSE {numberNets ¬ SUCC[numberNets]; doOne[net, token]};      IF twiddleStripped THEN token.length ¬ SUCC[token.length];      token ¬ Exec.FreeTokenString[token];      ENDLOOP;    RETURN[numberNets];    END;    Pause: Exec.ExecProc =    BEGIN    out: Format.StringProc = Exec.OutputProc[h];    OutCR: Format.StringProc = {out[s]; Exec.PutChar[h, Ascii.CR]};    abort: PROCEDURE RETURNS [abort: BOOLEAN] = {RETURN Exec.CheckForAbort[h]};    number: CARDINAL ¬ 1;    IF NOT Exec.EndOfCommandLine[h] THEN      BEGIN      token, switches: LONG STRING;      [token, switches] ¬ Exec.GetToken[h];      switches ¬ Exec.FreeTokenString[switches];      IF token # NIL THEN        BEGIN	failed: BOOLEAN ¬ FALSE;	number ¬ String.StringToDecimal[	  token ! String.InvalidNumber => {failed ¬ TRUE; CONTINUE}];	IF failed THEN {out[token]; OutCR[" is not a number - will use one"L]};	token ¬ Exec.FreeTokenString[token];	END      ELSE OutCR["No value specified - will use one"L];      END;    RETURN[      IF TimeServiceToolOps.WaitForNPolls[out, number, abort] THEN abort      ELSE normal];    END;  Reset: Exec.ExecProc =    BEGIN    out: Format.StringProc = Exec.OutputProc[h];    OutCR: Format.StringProc = {out[s]; Exec.PutChar[h, Ascii.CR]};    agent: System.NetworkAddress;    haveAgent: BOOLEAN ¬ FALSE;    DoOne: DoThisServerProc =      BEGIN      IF NOT haveAgent THEN        BEGIN        haveAgent ¬ TRUE;        agent ¬ who;        out["The time source is "L];        OutCR[text];        END      ELSE        BEGIN        out[text];        OutCR[          IF TimeServiceToolOps.SendCommand[who, agent, reset] THEN          " accepted reset request"L ELSE " did not respond to reset request"L];        END;      END;    SELECT ParseNetworkAddressString[h, DoOne] FROM      0 => out["No valid server was specified..."L];      1 => out["No valid server to reset was specified..."L];      ENDCASE;    END;  ServerInfo: Exec.ExecProc =    BEGIN    out: Format.StringProc = Exec.OutputProc[h];    OutCR: Format.StringProc = {out[s]; Exec.PutChar[h, Ascii.CR]};    DoOne: DoThisServerProc =      BEGIN      survey: TimeServiceToolOps.SurveyorInfo;      gotIt: BOOLEAN;      Access: TimeServiceToolOps.AccessProc =        BEGIN        IF server.who.host = who.host THEN          BEGIN          gotIt ¬ TRUE;          TimeServiceToolOps.DisplayServerInfo[survey, server, OutCR];          END;        END;      FOR survey ¬ TimeServiceToolOps.EnumerateSurveyors[NIL],        TimeServiceToolOps.EnumerateSurveyors[survey] UNTIL survey = NIL DO        IF survey.net = who.net THEN          BEGIN          gotIt ¬ FALSE;          TimeServiceToolOps.EnumerateServerInfo[survey, Access, trim];          IF NOT gotIt THEN {out["I have no information on "L]; OutCR[text]};          EXIT;          END;        REPEAT FINISHED => {out[text]; OutCR["'s net is not being surveyed"L]};        ENDLOOP;      END;    IF ParseNetworkAddressString[h, DoOne] = 0 THEN      out["No valid server was specified..."L];    END;  SetParameters: Exec.ExecProc =    BEGIN    token, switches: LONG STRING;    value: CARDINAL;    failed: BOOLEAN;    UNTIL Exec.EndOfCommandLine[h] DO      [token, switches] ¬ Exec.GetToken[h];      failed ¬ FALSE;      value ¬ String.StringToDecimal[        token ! String.InvalidNumber => {failed ¬ TRUE; CONTINUE}];      IF NOT failed AND switches # NIL THEN        SELECT switches[0] FROM          'd, 'D => TimeServiceToolOps.SetParameters[delay: value];          'p, 'P => TimeServiceToolOps.SetParameters[maxSurveyors: value];          't, 'T => trim ¬ value;          ENDCASE;      token ¬ Exec.FreeTokenString[token];      switches ¬ Exec.FreeTokenString[switches];      ENDLOOP;    END;  Start: Exec.ExecProc =    BEGIN    out: Format.StringProc = Exec.OutputProc[h];    OutCR: Format.StringProc = {out[s]; Exec.PutChar[h, Ascii.CR]};    DoOne: DoThisServerProc =      BEGIN      null: System.NetworkAddress = System.nullNetworkAddress;      out[text];      OutCR[        IF TimeServiceToolOps.SendCommand[who, null, start] THEN " started"L        ELSE " did not respond to start request"L];      END;    IF ParseNetworkAddressString[h, DoOne] = 0 THEN      out["No valid server was specified..."L];    END;  Stop: Exec.ExecProc =    BEGIN    out: Format.StringProc = Exec.OutputProc[h];    OutCR: Format.StringProc = {out[s]; Exec.PutChar[h, Ascii.CR]};    DoOne: DoThisServerProc =      BEGIN      null: System.NetworkAddress = System.nullNetworkAddress;      out[text];      OutCR[        IF TimeServiceToolOps.SendCommand[who, null, stop] THEN " stopped"L        ELSE " did not respond to stop request"L];      END;    IF ParseNetworkAddressString[h, DoOne] = 0 THEN      out["No valid server was specified..."L];    END;  SurveyNetwork: Exec.ExecProc =    BEGIN    out: Format.StringProc = Exec.OutputProc[h];    OutCR: Format.StringProc = {out[s]; Exec.PutChar[h, Ascii.CR]};    info: TimeServiceToolOps.SurveyorInfo;    DoOne: DoThisNetworkProc =      BEGIN      info ¬ z.NEW[TimeServiceToolOps.SurveyorInfoRecord ¬ [net, 0, NIL]];      IF NOT TimeServiceToolOps.InsertEntryInRing[info] THEN {        out[text]; OutCR[" is already being surveyed!"L]; z.FREE[@info]};      END;    IF ParseNetworkNumberString[h, DoOne] = 0 THEN      out["No valid network was specified..."L];    END;  Swap: PROCEDURE [x: LONG UNSPECIFIED] RETURNS [y: LONG UNSPECIFIED] =    BEGIN    TwoWords: TYPE = MACHINE DEPENDENT RECORD [one, two: WORD];    x2: TwoWords ¬ LOOPHOLE[x];    y2: TwoWords ¬ [x2.two, x2.one];    RETURN[LOOPHOLE[y2]];    END;  Quit: Exec.ExecProc = {TimeServiceToolOps.DeleteSurveyors[]};  Init[];  END...
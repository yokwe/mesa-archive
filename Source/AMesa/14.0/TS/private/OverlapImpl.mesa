-- File: OverlapImpl.mesa - last edit:-- kam         16-Dec-85 11:38:52-- Copyright (C) 1985 by Xerox Corporation. All rights reserved.DIRECTORY  Heap USING [Create],  Overlap USING [Interval, IntervalRecord, IntervalSet, IntervalSetSequence],  QuickSort USING [CompareProc, Sort, SwapProc];OverlapImpl: PROGRAM IMPORTS Heap, QuickSort EXPORTS Overlap =  BEGIN    End: TYPE = {leading, trailing};  SortedSet: TYPE = LONG POINTER TO SortedSetRecord;  SortedSetElement: TYPE = RECORD [    end: End, interval: Overlap.Interval, index: CARDINAL];  SortedSetRecord: TYPE = RECORD [    set: SEQUENCE size: CARDINAL OF SortedSetElement];    zone: PUBLIC UNCOUNTED ZONE ¬ Heap.Create[8];    BadInterval: PUBLIC SIGNAL [who: CARDINAL] = CODE;  BadMaxErr: PUBLIC ERROR [smallest: CARDINAL] = CODE;  BadSet: PUBLIC ERROR = CODE;    ConstructCorrectInterval: PUBLIC PROCEDURE [    set: Overlap.IntervalSet, maxErr: CARDINAL]    RETURNS [correct: Overlap.IntervalRecord] =    BEGIN    sortedSet: SortedSet;    maxWeight, currentWeight: CARDINAL ¬ 0;    Edge: PROCEDURE [i: CARDINAL] RETURNS [edge: LONG INTEGER] = {      RETURN[        IF sortedSet[i].end = leading	THEN sortedSet[i].interval.start ELSE sortedSet[i].interval.stop]};    IF maxErr >= set.size THEN RETURN[      [FIRST[LONG INTEGER], LAST[LONG INTEGER], NIL]];    correct ¬ [LAST[LONG INTEGER], FIRST[LONG INTEGER], NIL];    PreProcess[set];    sortedSet ¬ Sort[set];    BEGIN ENABLE UNWIND => zone.FREE[@sortedSet];      FOR i: CARDINAL IN [1.. sortedSet.size) DO        -- the weighted interval goes from sortedSet[i-1] to sortedSet[i]	start: LONG INTEGER ¬ Edge[i - 1];	stop: LONG INTEGER ¬ Edge[i];	currentWeight ¬ currentWeight + (	  IF sortedSet[i - 1].end = leading THEN 1 ELSE -1);	maxWeight ¬ MAX[currentWeight, maxWeight];	IF currentWeight >= set.size - maxErr THEN	  BEGIN	  correct.start ¬ MIN[start, correct.start];	  correct.stop ¬ MAX[stop, correct.stop];	  END;        ENDLOOP;      IF set.size - maxWeight > maxErr        THEN ERROR BadMaxErr[set.size - maxWeight];      zone.FREE[@sortedSet];      END;    END;    IncorrectSubset: PUBLIC PROCEDURE [set: Overlap.IntervalSet, maxErr: CARDINAL]    RETURNS [correct, incorrect: Overlap.IntervalSet] =    BEGIN    sortedSet: SortedSet;    IntersectSet: TYPE = LONG POINTER TO IntersectSetSequence;    IntersectSetSequence: TYPE = RECORD [      set: SEQUENCE size: CARDINAL OF CARDINAL];    iSet: IntersectSet;    Element: TYPE = RECORD [      who: Overlap.Interval, index: CARDINAL, next: LONG POINTER TO Element];    list: LONG POINTER TO Element ¬ NIL;    lengthList: CARDINAL ¬ 1;    maxLengthList, totalSets: CARDINAL ¬ 0;        InIntersection: PROCEDURE [i: CARDINAL] RETURNS [BOOLEAN]  = INLINE {      RETURN[iSet[i] = totalSets]};          SetIntersect: PROCEDURE =      BEGIN      totalSets ¬ SUCC[totalSets];      FOR i: LONG POINTER TO Element ¬ list, i.next UNTIL i = NIL DO        iSet[i.index] ¬ SUCC[iSet[i.index]] ENDLOOP;      END;         IF maxErr >= set.size THEN RETURN[NIL, NIL];    PreProcess[set];    sortedSet ¬ Sort[set];    BEGIN ENABLE UNWIND => zone.FREE[@sortedSet];      iSet ¬ zone.NEW[IntersectSetSequence[set.size]];      FOR i: CARDINAL IN [0.. iSet.size) DO iSet[i] ¬ 0 ENDLOOP;      list ¬ zone.NEW[        Element ¬ [sortedSet[0].interval, sortedSet[0].index, list]];      FOR i: CARDINAL IN [1.. sortedSet.size) DO	IF lengthList >= set.size - maxErr THEN SetIntersect[];	IF lengthList > maxLengthList THEN maxLengthList ¬ lengthList;	SELECT sortedSet[i].end FROM	  leading =>	    BEGIN	    list ¬ zone.NEW[	      Element ¬ [sortedSet[i].interval, sortedSet[i].index, list]];	    lengthList ¬ SUCC[lengthList];	    END;	  trailing =>	    BEGIN	    j: LONG POINTER TO Element ¬ list;	    k: LONG POINTER TO Element;	    IF j.who = sortedSet[i].interval THEN {list ¬ j.next; zone.FREE[@j]}	    ELSE {	      UNTIL j.next.who = sortedSet[i].interval DO j ¬ j.next ENDLOOP;	      k ¬ j.next; j.next ¬ j.next.next; zone.FREE[@k]};	    lengthList ¬ PRED[lengthList];	    END;	  ENDCASE;	ENDLOOP;      IF set.size - maxLengthList > maxErr	THEN ERROR BadMaxErr[set.size - maxLengthList];      lengthList ¬ 0;      FOR i: CARDINAL IN [0.. set.size) DO	IF NOT InIntersection[i] THEN lengthList ¬ SUCC[lengthList] ENDLOOP;      incorrect ¬ zone.NEW[Overlap.IntervalSetSequence[lengthList]];      correct ¬ zone.NEW[Overlap.IntervalSetSequence[set.size - lengthList]];      lengthList ¬ 0;      FOR i: CARDINAL IN [0.. set.size) DO	IF InIntersection[i] THEN correct[i - lengthList] ¬ set[i]	ELSE {incorrect[lengthList] ¬ set[i]; lengthList ¬ SUCC[lengthList]};	ENDLOOP;      zone.FREE[@sortedSet];      END;    END;    PreProcess: PROCEDURE [set: Overlap.IntervalSet] =    BEGIN    swap: LONG INTEGER;    IF set.size = 0 THEN ERROR BadSet;    FOR i: CARDINAL IN [0.. set.size) DO      SELECT set[i].stop FROM        = set[i].start => {SIGNAL BadInterval[i]; set[i].stop ¬ set[i].stop + 1};	< set[i].start => 	  BEGIN	  SIGNAL BadInterval[i];	  swap ¬ set[i].stop;	  set[i].stop ¬ set[i].start;	  set[i].start ¬ swap;	  END;	ENDCASE;      ENDLOOP;    END;    Sort: PROCEDURE [set: Overlap.IntervalSet] RETURNS [sorted: SortedSet] =    BEGIN    i: CARDINAL;    Compare: QuickSort.CompareProc =      BEGIN      v1: LONG INTEGER = Value[sorted[one]];      v2: LONG INTEGER = Value[sorted[two]];      RETURN[        SELECT v1 FROM	> v2 => bigger,	< v2 => smaller,	ENDCASE =>	  IF sorted[one].end = trailing AND sorted[two].end = leading	  THEN same ELSE bigger];      END;    Swap: QuickSort.SwapProc =      BEGIN      element: SortedSetElement ¬ sorted[one];      sorted[one] ¬ sorted[two];      sorted[two] ¬ element;      END;    Value: PROCEDURE [e: SortedSetElement] RETURNS [LONG INTEGER] = {      RETURN[IF e.end = leading THEN e.interval.start ELSE e.interval.stop]};    sorted ¬ zone.NEW[SortedSetRecord[2*set.size]];    i ¬ 0;    FOR end: End IN End DO      FOR j: CARDINAL IN [0.. set.size) DO        sorted[i] ¬ [end, set[j], j]; i ¬ SUCC[i]; ENDLOOP;      ENDLOOP;    QuickSort.Sort[0, sorted.size - 1, Compare, Swap, sorted];    END;    END...
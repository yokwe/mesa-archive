-- File: FileTransfersNSA.mesa - last edit:-- Riggle.PA            8-Aug-86 12:05:05-- bjd                 10-Jun-85 11:10:30-- Copyright (C) 1984, 1985, 1986 by Xerox Corporation. All rights reserved. DIRECTORY  AddressTranslation USING [    Error, ErrorRecord, PrintError, StringToNetworkAddress],  Auth USING [IdentityHandle, MakeIdentity],  Courier USING [Error, ErrorCode],  NSErrorMsg USING [PostCourierError, PostNSFileError],  FileName USING [VFN],  FileTransfer USING [    Connection, ConnectionObject, Error, FileType],  FileTransferNSOps USING [    cacheSize, DeleteKeepVersions, DirectoryCacheObject, NSData, NSDataObject,     NSDataHandle, NSDeleteFile, NSGetStreamInfo, NSListFile,    NSRenameFile, NSRetrieveFile, NSStoreFile, NSRetrieveStream,    NSRetrieveNextStream, NSStoreStream],  FileTransferOps USING [    Connection, ConnectionObject, maxDir, maxName, Operation, PrimitivesObject, z],  FileTransferUtils USING [CheckAbort, Post, SetPrimitive],  Format USING [StringProc],  Heap USING [systemZone],  NSAssignedTypes USING [tDirectory, tText, tUnspecified],  NSDataStream USING [Aborted],  NSFile USING [Error, ErrorRecord, Logoff, LogonDirect, nullHandle, nullSession, nullString, Probe, Service, ServiceRecord, Session, Type],  NSName USING [AppendNameToString, Error, FreeNameFields, maxDomainLength, maxFullNameLength, maxLocalLength, maxOrgLength, Name, NameFieldsFromString, NameRecord, separator, String],  NSString USING [FreeString, String, StringFromMesaString],  Process USING [Detach, Pause, SecondsToTicks, Yield],  Profile USING [GetDefaultDomain, GetDefaultOrganization, Qualify],  String USING [AppendString, Equivalent, Replace, StringBoundsFault];    FileTransfersNSA: PROGRAM  IMPORTS    AddressTranslation, Auth, Courier, NSErrorMsg, FileTransfer, FileTransferNSOps,    FileTransferOps, FileTransferUtils, Heap,     NSDataStream, NSName, NSFile, NSString, Process, Profile, String      EXPORTS FileTransfer, FileTransferOps, FileTransferNSOps =  BEGIN OPEN FileTransfer, FileTransferNSOps;  Connection: TYPE = FileTransferOps.Connection;  ConnectionObject: PUBLIC TYPE = FileTransferOps.ConnectionObject;  NSDataHandle: TYPE = FileTransferNSOps.NSDataHandle;  NSDataObject: PUBLIC TYPE = FileTransferNSOps.NSDataObject;  VFN: TYPE = FileName.VFN;  SecondsBetweenRetries: CARDINAL = 30;  CR: LONG STRING = "";  heap: UNCOUNTED ZONE = Heap.systemZone;    Result: TYPE = {    win, closeAndRetry, protocolProblem, reject, loop,    retry, skipOperation, notFound, illegalLogin, accessDenied, directoryFull};      S: PROC [mS: LONG STRING] RETURNS [NSString.String] = INLINE     { RETURN[NSString.StringFromMesaString[mS]] };    NSCatchErrors: PUBLIC PROC [    c: Connection, op: FileTransferOps.Operation, primitive: PROC[Connection],    fileName: LONG STRING ¬ NIL, vfn: VFN ¬ NIL] =    BEGIN    protocolErrors: CARDINAL ¬ 0;    DO      howWent: Result ¬ win;      FileTransferUtils.CheckAbort[c];      NSOpen[c];      primitive[c !        NSDataStream.Aborted => {	  FileTransferUtils.Post[c, fatal, " Stream Aborted."L, CR];	  ERROR Error[c, retry]};        NSFile.Error => {	  howWent ¬ NSError[c, error, op, vfn.name];	  CONTINUE};	Courier.Error => {	  howWent ¬ CourierError[c, errorCode, op];	  CONTINUE}];      SELECT howWent FROM        win =>  EXIT;	retry => ERROR Error[c, retry];	skipOperation => ERROR Error[c, skipOperation];	notFound => ERROR Error[c, notFound];	illegalLogin =>           IF c.login # NIL THEN {c.login[c.clientData];  LOOP}	  ELSE ERROR Error[c, illegalLogin];	accessDenied => ERROR Error[c, accessDenied];	directoryFull => ERROR Error[c, directoryFull];        closeAndRetry => {CloseConnection[c]; DeleteStream[c]};	loop => LOOP;	ENDCASE => ERROR Error[c, unknown];      ENDLOOP    END; -- of NSCatchErrors  NSStreamCatchErrors: PROC [    c: Connection, op: FileTransferOps.Operation, primitive: PROC[Connection],    fileName: LONG STRING ¬ NIL, vfn: VFN ¬ NIL] =    BEGIN    howWent: Result ¬ win;    FileTransferUtils.CheckAbort[c];    primitive[c !      NSDataStream.Aborted => {	 FileTransferUtils.Post[c, fatal, "Stream Aborted."L, CR];	 ERROR Error[c, retry]};      Courier.Error => {         howWent ¬ CourierError[c, errorCode, op];         IF howWent = retry THEN ERROR Error[c, retry]	 ELSE ERROR Error[c, skipOperation]};       NSFile.Error => {         howWent ¬ NSError[c, error, op];	 ERROR Error[c, 	 SELECT howWent FROM	   retry => retry,	   skipOperation => skipOperation,	   notFound => notFound,	   illegalLogin => illegalLogin,	   accessDenied => accessDenied,	   directoryFull => directoryFull	   ENDCASE => unknown]}      ];    END;      AddressTranslationError: PROCEDURE [    c: Connection, errorRecord: AddressTranslation.ErrorRecord]    RETURNS [result: Result ¬ skipOperation] =    BEGIN    msg: LONG STRING ¬ [50];    appendProc: Format.StringProc = {String.AppendString[msg, s !       String.StringBoundsFault => RESUME[NIL]]};    WITH errorRecord SELECT FROM       chLookupProblem =>         result ¬ SELECT rc.code FROM	   rejectedTooBusy, allDown, wasUpNowDown => closeAndRetry	   ENDCASE => skipOperation;       otherCHProblem =>         result ¬ SELECT reason FROM	   invalidName, invalidPassword => illegalLogin	   ENDCASE => skipOperation;       ENDCASE;    AddressTranslation.PrintError[error: errorRecord, proc: appendProc];    FileTransferUtils.Post[c, fatal, msg, CR];    END;      NSError: PROCEDURE [    c: Connection, error: NSFile.ErrorRecord,    op: FileTransferOps.Operation ¬ null, name: LONG STRING ¬ NIL]    RETURNS [result: Result ¬ skipOperation] =    BEGIN    msg: LONG STRING ¬ [100];    appendNSErrorMsg: Format.StringProc = {      String.AppendString[msg, s! String.StringBoundsFault => RESUME[NIL]]};    WITH error SELECT FROM      access =>	SELECT problem FROM	fileNotFound => {	  FileTransferUtils.Post[c, warning, name, " not found on "L, c.host, CR];	  RETURN[notFound]};	accessRightsInsufficient, accessRightsIndeterminate => result ¬ accessDenied;	ENDCASE;      authentication => 	SELECT problem FROM	credentialsInvalid, simpleKeyDoesNotExist, strongKeyDoesNotExist => 	  result ¬ illegalLogin;	ENDCASE;      space =>        IF problem = allocationExceeded OR problem = mediumFull       THEN result ¬ directoryFull      ENDCASE;    NSErrorMsg.PostNSFileError[error, appendNSErrorMsg];    FileTransferUtils.Post[c, fatal, msg, CR];    RETURN[result]     END;      CourierError: PROC [    c: Connection, errorCode: Courier.ErrorCode, op: FileTransferOps.Operation ¬ null]    RETURNS [Result] =    BEGIN    post: Format.StringProc = {FileTransferUtils.Post[c, fatal, s]};    NSErrorMsg.PostCourierError[errorCode, post];  post[CR];    SELECT errorCode FROM      noRouteToSystemElement, transportTimeout, remoteSystemElementNotResponding,      noCourierAtRemoteSite, tooManyConnections =>  --communication errors        RETURN[	  SELECT op FROM	    get, readNext, storeStream => retry,	    ENDCASE => closeAndRetry];      ENDCASE => -- other Courier errors	RETURN[skipOperation]          END;    NSOpen: PROCEDURE [c: Connection] =    BEGIN    serviceRec: NSFile.ServiceRecord;    serviceName: LONG STRING ¬ [NSName.maxFullNameLength];    defaultOrg: LONG STRING ¬ [NSName.maxOrgLength];    defaultDomain: LONG STRING ¬ [NSName.maxDomainLength];    defaultCHNameRec: NSName.NameRecord ¬ [      org: S[defaultOrg], domain: S[defaultDomain]];        appendOrg: PROCEDURE [organization: LONG STRING] = {      String.AppendString[defaultOrg, organization];      defaultCHNameRec.org.length ¬ defaultOrg.length};    appendDomain: PROCEDURE [domain: LONG STRING] = {      String.AppendString[defaultDomain, domain];      defaultCHNameRec.domain.length ¬ defaultDomain.length};    AppendNameToString: PROCEDURE [s: LONG STRING, name: NSName.Name] = {      newS: NSName.String ¬ NSName.AppendNameToString[s: S[s], name: name];      s.length ¬ newS.length};    FreeName: PROCEDURE = {      NSName.FreeNameFields[FileTransferOps.z, @serviceRec.name]};    IF c.serverType = local THEN RETURN;    IF c.host[c.host.length-1] = NSName.separator THEN      c.host.length ¬ c.host.length-1;    IF c.nsData = NIL THEN  c.nsData ¬ AllocateNSObject[];    CheckAndSetCredentials[c];    Profile.GetDefaultDomain[appendDomain];    Profile.GetDefaultOrganization[appendOrg];    NSName.NameFieldsFromString[      z: FileTransferOps.z, s: S[c.host],      destination: @serviceRec.name, clientDefaults: @defaultCHNameRec !        NSName.Error => {	  FileTransferUtils.Post[	    c, fatal, "Illegal host name, domain, or organization\n"L];	  ERROR Error[c, skipOperation]}];    AppendNameToString[serviceName, @serviceRec.name];    IF NSIsOpen[c] THEN {      IF String.Equivalent[c.lastHost, serviceName] AND ~c.newCredentials      THEN {FreeName[]; RETURN};      DeleteStream[c];      CloseConnection[c: c, printErrs: TRUE]};    FileTransferUtils.Post[      c, terse, "Opening (NS) connection to "L, serviceName, " ... "L];    OpenConnection[c: c, service: @serviceRec, fullName: serviceName !      UNWIND => FreeName[]];    FileTransferUtils.Post[c, terse, "Done."L, CR];    String.Replace[@c.lastHost, serviceName, heap];    FreeName[];    SetNSOpen[c, TRUE];    c.newCredentials ¬ FALSE;    END;          OpenConnection: PROCEDURE [    c: Connection, service: NSFile.Service, fullName: LONG STRING] =    BEGIN    found: BOOLEAN ¬ FALSE;    nsData: NSDataHandle = NSData[c];    DO       howWent: Result ¬ win;      BEGIN ENABLE {        AddressTranslation.Error => { 	  howWent ¬ AddressTranslationError[c, errorRecord]; 	  SELECT howWent FROM	    skipOperation => ERROR Error[c, skipOperation];	    illegalLogin =>  	      IF c.login # NIL THEN {	        c.login[c.clientData];		CheckAndSetCredentials[c];	        LOOP}	      ELSE ERROR Error[c, illegalLogin];	    ENDCASE => CONTINUE};  	NSFile.Error => {	  howWent ¬ NSError[c, error]; 	  SELECT howWent FROM	    skipOperation => ERROR Error[c, skipOperation];	    illegalLogin =>  	      IF c.login # NIL THEN {	        c.login[c.clientData];		CheckAndSetCredentials[c];	        LOOP}	      ELSE ERROR Error[c, illegalLogin];	    ENDCASE => ERROR Error[c, skipOperation]};	Courier.Error => {	  howWent ¬ CourierError[c, errorCode];	  SELECT howWent FROM	    skipOperation => ERROR Error[c, skipOperation];	    ENDCASE => CONTINUE}};    -- defaulting systemElement forces NSFile to lookup the service in CH;    -- But, NSFilingRemoteConfig doesn't have this capability;      [addr: service.systemElement] ¬        AddressTranslation.StringToNetworkAddress[s: fullName, id: c.id];      FileTransferUtils.CheckAbort[c];      nsData.session ¬ NSFile.LogonDirect[identity: c.id, service: service];    --nsData.rootRef ¬ NSFile.MakeReference[    --  fileID: NSFile.nullID, service: service];      EXIT;      END; -- end enable; continue to wait loop;      THROUGH [0..SecondsBetweenRetries) DO -- Wait some no. of secs before retry;        FileTransferUtils.CheckAbort[c];       -- checking for abort every sec.        Process.Pause[Process.SecondsToTicks[1]];	ENDLOOP;      ENDLOOP;    END;      CloseConnection: PROCEDURE [c: Connection, printErrs: BOOLEAN ¬ FALSE] =    BEGIN  -- Fork a process to Logoff, and just continue on without letting any errors through.          yields: CARDINAL ¬ 0;    open: BOOLEAN ¬ FALSE;    IF printErrs THEN {      host: STRING ¬ [NSName.maxLocalLength];      JustHost[c.lastHost, host];      FileTransferUtils.Post[       c, verbose, "Closing connection to "L, host, " ... "L]    };    Process.Detach[FORK EndSession[session: NSData[c].session]];    FlushDirectoryCache[dH: NSData[c]]; -- invalidate    IF printErrs THEN FileTransferUtils.Post[c, verbose, "Done."L, CR];    SetNSOpen[c, FALSE]    END;    NSClose: PUBLIC PROC [c: Connection, printErrs, freeObject: BOOLEAN ¬ FALSE] =    BEGIN    IF c.nsData = NIL OR NSData[c].session = NSFile.nullSession THEN RETURN;    DeleteStream[c];    IF NSIsOpen[c] THEN CloseConnection[c, printErrs];    NSData[c].session ¬ NSFile.nullSession;    IF freeObject THEN c.nsData ¬ DeallocateNSObject[dH: NSData[c]];    END;  DeleteStream: PROCEDURE [c: Connection] ={   IF c.stream # NIL THEN { c.stream.delete[c.stream]; c.stream ¬ NIL }};  EndSession: PROCEDURE [session: NSFile.Session] =    BEGIN    yields: CARDINAL ¬ 0;    DO      NSFile.Logoff[session !        NSFile.Error =>	  WITH error SELECT FROM	    service =>	      SELECT problem FROM	        sessionInUse =>		  IF yields < 3 THEN {  -- let straggling processes die first		    Process.Yield[]; yields ¬ yields + 1; LOOP}		  ELSE CONTINUE		ENDCASE => CONTINUE	     ENDCASE => CONTINUE;	 Courier.Error => CONTINUE];      EXIT    ENDLOOP    END;      CheckAndSetCredentials: PROC [c: Connection] = {    IF c.id = NIL THEN {      qualifiedName: LONG STRING ¬ [FileTransferOps.maxName];      Profile.Qualify[c.primary.directory, qualifiedName, clearinghouse !	String.StringBoundsFault => RESUME[NIL]];      c.id ¬ MakeIdentity[c, qualifiedName, c.primary.password];      c.newCredentials ¬ TRUE}};  MakeIdentity: PROC [c: Connection, user, password: LONG STRING]    RETURNS [ident: Auth.IdentityHandle] = {    name: NSName.NameRecord ¬ [];    NSName.NameFieldsFromString[      z: FileTransferOps.z,      s: S[user], destination: @name !	  NSName.Error => {	    FileTransferUtils.Post[c, fatal, "Invalid name\n"];	    ERROR Error[c, skipOperation]}];    ident ¬ Auth.MakeIdentity[      myName: @name, password: S[password],      z: FileTransferOps.z, style: simple, dontCheck: TRUE];    NSName.FreeNameFields[z: FileTransferOps.z, name: @name]};      -- Supporting Stuff      MesaFileType: PUBLIC PROC [tNS: NSFile.Type] RETURNS [FileType] = {    OPEN NSAssignedTypes;    RETURN [    SELECT tNS FROM      tUnspecified => binary,      tText => text,      tDirectory => directory,     ENDCASE => unknown ]};       NSFileType: PUBLIC PROC [tM: FileType] RETURNS [NSFile.Type] = {    OPEN NSAssignedTypes;    RETURN [    SELECT tM FROM      unknown => tUnspecified,      text => tText,      binary => tUnspecified,      directory => tDirectory,     ENDCASE => tUnspecified ]};      AllocateNSObject: PROC RETURNS [data: FileTransferNSOps.NSDataHandle] = {    OPEN FileTransferOps;    data ¬  FileTransferOps.z.NEW[FileTransferNSOps.NSDataObject ¬ []];    data.directory ¬ FileTransferOps.z.NEW[StringBody[maxDir]];    data.body ¬ FileTransferOps.z.NEW[StringBody[maxName]];    data.author ¬ FileTransferOps.z.NEW[StringBody[maxName]];    data.version ¬ FileTransferOps.z.NEW[StringBody[10]];    data.directoryCache ¬ FileTransferOps.z.NEW[      FileTransferNSOps.DirectoryCacheObject[FileTransferNSOps.cacheSize] ¬         [elements: TRASH]];    FOR i: NATURAL IN [0..FileTransferNSOps.cacheSize) DO      data.directoryCache[i] ¬ [handle: NSFile.nullHandle, pathname: NSFile.nullString];      ENDLOOP};    DeallocateNSObject: PROC [dH: FileTransferNSOps.NSDataHandle]    RETURNS [FileTransferNSOps.NSDataHandle]= {    IF dH # NIL THEN {      FileTransferOps.z.FREE[@(dH.directory)];      FileTransferOps.z.FREE[@(dH.body)];      FileTransferOps.z.FREE[@(dH.author)];      FileTransferOps.z.FREE[@(dH.version)];      IF dH.pathname # NIL THEN FileTransferOps.z.FREE[@(dH.pathname)];      FileTransferOps.z.FREE[@dH.directoryCache];      FileTransferOps.z.FREE[@dH]};     RETURN[NIL]};      FlushDirectoryCache: PROC [dH: FileTransferNSOps.NSDataHandle] = {    i: NATURAL ¬ dH.directoryCache.index;    DO      IF dH.directoryCache[i].handle = NSFile.nullHandle THEN EXIT;      NSString.FreeString[FileTransferOps.z, dH.directoryCache[i].pathname];      dH.directoryCache[i] ¬ [	handle: NSFile.nullHandle, pathname: NSFile.nullString];      i ¬ (i+1) MOD cacheSize;      ENDLOOP;    dH.directoryCache.rootHandle ¬ NSFile.nullHandle};      SetNSOpen: PROC [c: Connection, b: BOOLEAN] = {    NSData[c].openHint ¬ b};      NSIsOpen: PROC [c: Connection] RETURNS [BOOLEAN] = {    IF NSData[c].openHint THEN      [] ¬ NSFile.Probe[NSData[c].session !       NSFile.Error =>	 BEGIN	 WITH error SELECT FROM	   session => 	     IF problem = sessionInvalid 	     THEN NSData[c].openHint ¬ FALSE ELSE NSData[c].openHint ¬ TRUE;            ENDCASE => NSData[c].openHint ¬ TRUE;	 CONTINUE	 END;       Courier.Error => {NSData[c].openHint ¬ TRUE; CONTINUE}];    IF ~NSData[c].openHint THEN FlushDirectoryCache[dH: NSData[c]];     -- session timed out, so invalidate cache    RETURN[NSData[c].openHint]};      JustHost: PROC[fullName, host: LONG STRING] = {    FOR i: CARDINAL IN [0..fullName.length) DO      IF fullName[i] = NSName.separator THEN EXIT;      host[i] ¬ fullName[i]; host.length ¬ i+1    ENDLOOP};  -- Initialization    NSObject: FileTransferOps.PrimitivesObject ¬ [    catchErrors: NSCatchErrors,    streamCatchErrors: NSStreamCatchErrors,    deleteFile: FileTransferNSOps.NSDeleteFile,    listFile: FileTransferNSOps.NSListFile,    renameFile: FileTransferNSOps.NSRenameFile,    retrieveFile: FileTransferNSOps.NSRetrieveFile,    storeFile: FileTransferNSOps.NSStoreFile,    retrieveStream: FileTransferNSOps.NSRetrieveStream,    retrieveNextStream:	FileTransferNSOps.NSRetrieveNextStream,    storeStream: FileTransferNSOps.NSStoreStream,    -- open: NSOpen,  ** not needed ???    close: NSClose,    getStreamInfo: FileTransferNSOps.NSGetStreamInfo,    delver: FileTransferNSOps.DeleteKeepVersions ];      StartNS: PUBLIC PROCEDURE =     BEGIN    END;      FileTransferUtils.SetPrimitive[ns, @NSObject];    END.
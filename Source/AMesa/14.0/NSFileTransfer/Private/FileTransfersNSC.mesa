-- File: FileTransfersNSC.mesa - last edit:-- Riggle.PA            8-Aug-86 12:25:32-- bjd                  5-Aug-85 16:22:59-- RKJ     	30-Nov-82  9:00:36-- Copyright (C) 1982, 1983, 1984, 1985, 1986 by Xerox Corporation. All rights reserved.DIRECTORY  Courier USING [Error, ErrorCode],  FileName USING [    ResetVFN, SetRemoteName, UnpackFilename, VFN, VirtualFilenameObject],  FileTransfer USING [    Confirmation, Connection, ConnectionObject, Error, ErrorCode, FileInfo],  FileTransferNSOps,  FileTransferOps USING [    CommandObject, Connection, ConnectionObject, FTHandle, maxFileName, maxName,    RetrieveCommand, RetrieveStreamCommand, StoreCommand, StoreStreamCommand, z],  FileTransferUtils USING [    ChangeAccess, CheckAbort, CreateFT, DoDisk, FileTransferToMFileType,    GetLocalInfo, HasWildCard, OpenLocalFile, Post, SetupInfo, ShowBytes,    ShowDestination, WriteDate],  Heap USING [systemZone],  MFile USING [    Acquire, AcquireTemp, AppendErrorMessage, CopyFileHandle, Delete, Error,    Handle, Release, SetProperties, SetReadProtect, SetTimes],  MStream USING [Create, GetFile, Handle],  NSAssignedTypes USING [tDirectory],  NSDataStream USING [Abort, Aborted, Handle, Sink, SinkStream, SourceStream],  NSFile USING [Attribute, Attributes, AttributesProc, AttributesRecord, Close, CopyAttributes, Create, Error, ErrorRecord, FreeAttributes, GetAttributes, Handle, List, Lock, nullHandle, Open, Retrieve, Scope, Selections, Store, String],  NSString USING [AppendToMesaString, String, StringFromMesaString],  Process USING [CancelAbort, Detach, DisableTimeout, GetCurrent],  Stream USING [Delete, DeleteProcedure, Handle],  String USING [AppendChar, AppendCharAndGrow, AppendNumber, AppendString, AppendStringAndGrow, Empty, MakeString, Replace, StringBoundsFault, SubString, SubStringDescriptor],  System USING [GetClockPulses];FileTransfersNSC: MONITOR LOCKS rData USING rData: RetrieveData  IMPORTS    Courier, FileName, FileTransfer, FileTransferNSOps, FileTransferOps,    FileTransferUtils, Heap, MFile, MStream, NSDataStream, NSFile, NSString,    Process, Stream, String, System  EXPORTS FileTransfer, FileTransferNSOps =  BEGIN OPEN FileTransfer, FileTransferNSOps;  CommandObject: TYPE = FileTransferOps.CommandObject;  Connection: TYPE = FileTransferOps.Connection;  ConnectionObject: PUBLIC TYPE = FileTransferOps.ConnectionObject;  VFN: TYPE = FileName.VFN;  CR: LONG STRING = "";  heap: UNCOUNTED ZONE = Heap.systemZone;  done: Confirmation = LOOPHOLE[5];  NSGetStreamInfo: PUBLIC PROC [ft: FileTransferOps.FTHandle] = {    FileTransferNSOps.GetRemoteInfo[ft.conn, source, RData[ft].attributes]};  NSRetrieveStream: PUBLIC PROC [    c: Connection, p: FileTransferOps.RetrieveStreamCommand] =    BEGIN    ft: FileTransferOps.FTHandle ¬ NIL;    stream: Stream.Handle ¬ NIL;    IF String.Empty[p.remote.directory] THEN {      FileTransferUtils.Post[c, fatal, "Illegal directory\n"L];      ERROR Error[c, skipOperation]};    IF c.stream # NIL THEN {c.stream.delete[c.stream]; c.stream ¬ NIL};    FileTransferUtils.CheckAbort[c];    ft ¬ FileTransferUtils.CreateFT[      c, p, String.MakeString[heap, FileTransferOps.maxFileName]];    stream ¬ LOOPHOLE[ft];    ft.op ¬ retrieveStream;    ft.free ¬ FreeRetrieveObject;    ft.data ¬ FileTransferOps.z.NEW[RetrieveObject ¬ []];    DisableTimeouts[RData[ft]];    Process.Detach[FORK EnumerateAndRetrieve[c, ft, p.remote]];    WaitOnStreamAvailable[RData[ft]];    IF RData[ft].errorEncountered THEN {      ENABLE UNWIND => stream.delete[stream];      WITH RData[ft].error SELECT FROM        ns => ERROR NSFile.Error[error];        courier => ERROR Courier.Error[errorCode];        fileTransfer => ERROR FileTransfer.Error[c, code];        aborted => RaiseABORTED[]  -- abort case of the veto proc        ENDCASE};    END;  EnumerateAndRetrieve: PROC [    c: Connection, ft: FileTransferOps.FTHandle, remoteVFN: VFN] =    BEGIN    answer: Confirmation;    localError: ErrorRecord;    localAttributes: NSFile.Attributes ¬ NIL;    file: NSFile.Handle ¬ NSFile.nullHandle;    found: BOOLEAN ¬ FALSE;    GetInfo: PROC [conn: Connection] RETURNS [source, target: FileInfo] = {      FileTransferNSOps.GetRemoteInfo[conn, source, localAttributes];      RETURN[source: conn.info[source], target: NIL]};    retrieveProc: FileTransferNSOps.MyAttributesProc =      BEGIN      ENABLE        UNWIND => {          CloseNSFile[c, @file];          IF RData[ft].attributes # NIL THEN {            NSFile.FreeAttributes[localAttributes]; RData[ft].attributes ¬ NIL}};      found ¬ TRUE;      RData[ft].attributes ¬ localAttributes ¬ NSFile.CopyAttributes[attributes];      -- Will be needed by NSRetrieveFile;       String.Replace[@(ft.file), pathname, heap];      FileTransferUtils.Post[c, terse, ft.file];      c.good ¬ ALL[FALSE];      IF ft.dates THEN {        FileTransferNSOps.GetRemoteInfo[c, source, localAttributes];        FileTransferUtils.WriteDate[c, source]};      IF ft.veto # NIL THEN        [answer, ft.dates] ¬ ft.veto[c, c.clientData, c.post, GetInfo, ft.dates]      ELSE answer ¬ do;      SELECT answer FROM        do => {          file ¬ NSData[c].directoryCache.fileHandle;          ft.stream ¬ NSRetrieveEntry[c, RData[ft], file];          ft.object.options ¬ ft.stream.options;          c.stream ¬ LOOPHOLE[ft]};  -- file closed after stream deleted (CallRetrieve)        skip => {          FileTransferUtils.Post[c, terse, " XXX\n"L]; RETURN[continue: TRUE]};        abort => RaiseABORTED[];        ENDCASE;      SetAnswer[RData[ft], answer];      NotifyStreamAvailable[RData[ft]];  -- Stream ready; come and get it.      WaitOnGetNext[RData[ft]];  -- Keep enumeration open;      -- Wait until next stream needed.      IF RData[ft].errorEncountered THEN        WITH RData[ft].error SELECT FROM          ns => ERROR NSFile.Error[error];          courier => ERROR Courier.Error[errorCode];          fileTransfer => ERROR FileTransfer.Error[c, code];          ENDCASE;      CloseNSFile[c, @file];      RETURN[RData[ft].continue];      END;  -- of retrieveProc    {  -- Errors caught from either NSRetrieveEntry or retrieveProc    FileTransferNSOps.OpenCatalogAndEnumerate[      c, retrieveProc, remoteVFN, retrieveStream !      NSFile.Error => {localError ¬ [ns[error]]; GOTO setError};      Courier.Error => {localError ¬ [courier[errorCode]]; GOTO setError};      FileTransfer.Error => {localError ¬ [fileTransfer[c, code]]; GOTO setError};      ABORTED => {localError ¬ [aborted[]]; GOTO setError}];    IF ~found AND ~RData[ft].errorEncountered THEN      SetError[RData[ft], [ns[error: [access[fileNotFound]]]]];    SetAnswer[RData[ft], done];  -- Send ReadNextInner around again;    NotifyStreamAvailable[RData[ft]];  -- Final stream returned is NIL.    NotifyOkayToDelete[RData[ft]];    EXITS      setError => {        SetError[RData[ft], localError];        SetAnswer[RData[ft], done];        NotifyStreamAvailable[RData[ft]];        NotifyOkayToDelete[RData[ft]]}}    END;  -- of EnumerateAndRetrieve  NSRetrieveEntry: ENTRY PROC [    c: Connection, rData: RetrieveData, fH: NSFile.Handle]    RETURNS [Stream.Handle] =    -- Retrieve is accomplished by forking a process (CallRetrieve) which calls NSFile.Retrieve with a procedure (Sink) that remains allocated until the client deletes the stream (or the next stream is requested).    BEGIN    ENABLE UNWIND => NULL;    Process.Detach[FORK CallRetrieve[c, fH, rData]];    WaitOnStreamAlmost[rData];    IF rData.errorEncountered THEN      WITH rData.error SELECT FROM        ns => ERROR NSFile.Error[error];        courier => ERROR Courier.Error[errorCode];        fileTransfer => ERROR FileTransfer.Error[c, code];        ENDCASE;    RETURN[rData.sH]    END;  CallRetrieve: ENTRY PROC [    c: Connection, fH: NSFile.Handle, rData: RetrieveData] =    BEGIN    ENABLE UNWIND => NULL;    DeleteSource: Stream.DeleteProcedure =      -- If client deletes the stream, the enumeration is aborted; If NSRetrieveNextStream deletes the stream, it continues.  Wakes up enumeration to get next stream and then waits for EnumerateAndRetrieve process to go away.      BEGIN      clientDeleted: BOOLEAN ¬ FALSE;      DeleteEntry: ENTRY PROC [rData: RetrieveData] = {        ENABLE UNWIND => NULL;        IF rData.clientDeleted THEN {rData.continue ¬ FALSE; clientDeleted ¬ TRUE}        ELSE rData.clientDeleted ¬ TRUE;        NotifyDelete[rData]};      DeleteEntry[rData];      IF clientDeleted THEN WaitOnOkayToDelete[rData]  -- wait until ft object is no longer needed, i.e. processes cleaned up and gone away.      ELSE WaitOnStreamAvailable[rData];      END;    Sink: INTERNAL PROC [source: NSDataStream.SourceStream] =      BEGIN      ENABLE { NSDataStream.Aborted => CONTINUE; UNWIND => Stream.Delete[source]};      oldDelete: Stream.DeleteProcedure ¬ source.delete;      source.delete ¬ DeleteSource;      rData.sH ¬ source;      NotifyStreamAlmost[rData];      WaitOnDel[rData];      source.delete ¬ oldDelete;      Stream.Delete[source ! NSDataStream.Aborted => CONTINUE];      END;    {    NSFile.Retrieve[      fH, [proc[Sink]], NSData[c].session !      NSFile.Error =>        IF error = [transfer[problem: aborted]] THEN CONTINUE  -- Deleted before done;        ELSE {rData.error ¬ [ns[error]]; GOTO handleError};      Courier.Error => {rData.error ¬ [courier[errorCode]]; GOTO handleError}];    NotifyGetNext[rData];    EXITS      handleError => {        rData.errorEncountered ¬ TRUE;        NotifyStreamAlmost[rData];  -- Depending on the state of        NotifyGetNext[rData]}  -- EnumerateAndRetrieve;    }    END;  -- of CallRetrieve  NSRetrieveNextStream: PUBLIC PROC [    c: Connection, ft: FileTransferOps.FTHandle ¬ NIL] RETURNS [Confirmation] =    --  Wake up the Sink proc waiting on delete, which bumps the enumeration another time through. The Confirmation returned is the result from the client's veto proc (set in retrieveProc).     BEGIN    stream: Stream.Handle = LOOPHOLE[ft];    SetClientDeleted: ENTRY PROC [rData: RetrieveData, b: BOOLEAN] = {      rData.clientDeleted ¬ b};    IF RData[ft].attributes # NIL THEN {      NSFile.FreeAttributes[RData[ft].attributes]; RData[ft].attributes ¬ NIL};    IF NOT RData[ft].errorEncountered THEN      BEGIN      SetClientDeleted[RData[ft], FALSE];      IF ft.stream # NIL THEN Stream.Delete[ft.stream];  -- A call to DeleteSource;      IF RData[ft].answer = done THEN {        -- Enumeration has completed; last source was deleted, so set ft.stream ¬ NIL;        ft.stream ¬ NIL; stream.delete[stream]; RETURN[done]}      END;    IF RData[ft].errorEncountered THEN  -- could have encountered while waiting;      BEGIN      ENABLE UNWIND => {ft.stream ¬ NIL; stream.delete[stream]};      SetClientDeleted[RData[ft], TRUE];  -- Really delete the stream;      Stream.Delete[ft.stream];  -- A call to DeleteSource;      WITH RData[ft].error SELECT FROM        ns => ERROR NSFile.Error[error];        courier => ERROR Courier.Error[errorCode];        fileTransfer => ERROR FileTransfer.Error[c, code];        aborted => RaiseABORTED[]  -- abort case of the veto proc        ENDCASE      END;    RETURN[RData[ft].answer]    END;  -- of NSRetrieveNextStream  -- -- -- -- -- -- -- --  -- --  -- Monitor stuff  ErrorRecord: TYPE = RECORD [    SELECT type: * FROM    ns => [error: NSFile.ErrorRecord],    courier => [errorCode: Courier.ErrorCode],    fileTransfer => [conn: FileTransfer.Connection, code: FileTransfer.ErrorCode],    aborted => NULL    ENDCASE];  RetrieveData: TYPE = LONG POINTER TO RetrieveObject;  RetrieveObject: TYPE = MONITORED RECORD [    sH: Stream.Handle ¬ NIL,    errorEncountered: BOOLEAN ¬ FALSE,  -- NSFile or Courier error encountered?    error: ErrorRecord ¬ NULL,  -- The error itself;    continue: BOOLEAN ¬ TRUE,  -- Continue the enumeration?    clientDeleted: BOOLEAN ¬ TRUE,  -- Client called Delete in mid enumeration?    answer: Confirmation ¬ do,  -- Returned by NSRetrieveNextStream;    attributes: NSFile.Attributes ¬ NIL,    streamAvailable, streamAlmostAvailable, deleted, getNextStream, okayToDelete:      CONDITION,    streamAvail, streamAlmost, del, getNext, okay: BOOLEAN ¬ FALSE];  SetAnswer: ENTRY PROC [rData: RetrieveData, answer: Confirmation] = {    rData.answer ¬ answer};  SetError: ENTRY PROC [rData: RetrieveData, error: ErrorRecord] = {    rData.error ¬ error; rData.errorEncountered ¬ TRUE};  NotifyOkayToDelete: ENTRY PROC [rData: RetrieveData] = {    rData.okay ¬ TRUE; NOTIFY rData.okayToDelete};  WaitOnOkayToDelete: ENTRY PROC [rData: RetrieveData] =    BEGIN    ENABLE UNWIND => NULL;    WHILE ~rData.okay DO WAIT rData.okayToDelete ENDLOOP;    rData.okay ¬ FALSE    END;  NotifyStreamAvailable: ENTRY PROC [rData: RetrieveData] = {    rData.streamAvail ¬ TRUE; NOTIFY rData.streamAvailable};  WaitOnStreamAvailable: ENTRY PROC [rData: RetrieveData] =    BEGIN    ENABLE UNWIND => NULL;    WHILE ~rData.errorEncountered AND ~rData.streamAvail DO      WAIT rData.streamAvailable ENDLOOP;    rData.streamAvail ¬ FALSE    END;  NotifyStreamAlmost: INTERNAL PROC [rData: RetrieveData] = {    rData.streamAlmost ¬ TRUE; NOTIFY rData.streamAlmostAvailable};  WaitOnStreamAlmost: INTERNAL PROC [rData: RetrieveData] =    BEGIN    WHILE ~rData.errorEncountered AND ~rData.streamAlmost DO      WAIT rData.streamAlmostAvailable ENDLOOP;    rData.streamAlmost ¬ FALSE    END;  NotifyGetNext: INTERNAL PROC [rData: RetrieveData] = {    rData.getNext ¬ TRUE; NOTIFY rData.getNextStream};  WaitOnGetNext: ENTRY PROC [rData: RetrieveData] =    BEGIN    ENABLE UNWIND => NULL;    WHILE ~rData.errorEncountered AND ~rData.getNext DO      WAIT rData.getNextStream ENDLOOP;    rData.getNext ¬ FALSE    END;  NotifyDelete: INTERNAL PROC [rData: RetrieveData] = {    rData.del ¬ TRUE; NOTIFY rData.deleted};  WaitOnDel: INTERNAL PROC [rData: RetrieveData] =    BEGIN    WHILE ~rData.errorEncountered AND ~rData.del DO WAIT rData.deleted ENDLOOP;    rData.del ¬ FALSE    END;  -- Do I really need these?  DisableTimeouts: PROC [rData: RetrieveData] =    BEGIN    Process.DisableTimeout[@(rData.getNextStream)];    Process.DisableTimeout[@(rData.deleted)];    Process.DisableTimeout[@(rData.okayToDelete)];    END;  CleanupStream: PROC [ft: FileTransferOps.FTHandle] = {    IF ft = NIL OR ft.stream = NIL THEN RETURN;    Stream.Delete[ft.stream ! NSDataStream.Aborted => CONTINUE];    ft.stream ¬ NIL};  NSRetrieveFile: PUBLIC PROC [c: Connection, p: FileTransferOps.RetrieveCommand] =    BEGIN    localStream: Stream.Handle ¬ NIL;    localFile: LONG STRING ¬ NIL;    rsCommand: retrieveStream CommandObject ¬ [      retrieveStream[remote: p.source, veto: NIL, dates: p.dates]];    anyErrors: BOOLEAN ¬ FALSE;    file: MFile.Handle ¬ NIL;    ft: FileTransferOps.FTHandle ¬ NIL;    answer: Confirmation ¬ do;    {    ENABLE {      UNWIND => IF localFile # NIL THEN FileTransferOps.z.FREE[@localFile];      MFile.Error => {        msg: STRING ¬ [100];        MFile.AppendErrorMessage[msg, code, file];        FileTransferUtils.Post[c, fatal, msg, CR];        IF code = noRoomOnVolume THEN ERROR Error[c, directoryFull]        ELSE ERROR Error[c, skipOperation]}};    GetBothInfos: PROC [conn: Connection] RETURNS [source, target: FileInfo] = {      FileTransferNSOps.GetRemoteInfo[conn, source, RData[ft].attributes];      FileTransferUtils.GetLocalInfo[conn, file, target];      RETURN[source: conn.info[source], target: conn.info[target]]};    GetSourceInfo: PROC [conn: Connection] RETURNS [source, target: FileInfo] = {      RETURN[source: conn.info[source], target: NIL]};    SetUpLocalFile: PROC RETURNS [answer: Confirmation ¬ do] =      BEGIN      SELECT p.type FROM        local, remote =>          BEGIN          ENABLE UNWIND => {CleanupMFile[file]; file ¬ NIL};          name: LONG STRING ¬ [FileTransferOps.maxName];          NSString.AppendToMesaString[name, RData[ft].attributes.name];          localFile ¬ MakeDefaultName[real: p.dest, default: name, remote: FALSE];          file ¬ FileTransferUtils.OpenLocalFile[c, localFile, target, TRUE];          c.good[target] ¬ ~c.info[target].oldFile;          FileTransferUtils.Post[c, terse, " to "L, localFile];          IF file # NIL THEN {            FileTransferUtils.Post[c, verbose, " [Old File]"L];            IF p.dates THEN {              IF c.info[target].readProtect THEN                FileTransferUtils.Post[c, verbose, "[?]"L]              ELSE {                FileTransferUtils.GetLocalInfo[c, file, target];                FileTransferUtils.WriteDate[c, target]}}}          ELSE FileTransferUtils.Post[c, verbose, " [New File]"L];          IF p.veto # NIL THEN            [answer, ft.dates] ¬ p.veto[              c, c.clientData, c.post, GetBothInfos, ft.dates];          IF answer = do THEN {            FileTransferUtils.GetLocalInfo[c, file, target];            FileTransferNSOps.GetRemoteInfo[c, source, RData[ft].attributes];            IF file = NIL THEN {              IF c.info[source].type = directory THEN {                FileTransferUtils.Post[                  c, fatal, " Not allowed to retrieve a directory.\n"L];                ERROR Error[c, cantModify]};              file ¬ MFile.Acquire[                name: localFile, access: writeOnly, release: [],                initialLength: c.info[source].size,                type: FileTransferUtils.FileTransferToMFileType[                c.info[source].type]]}            ELSE FileTransferUtils.ChangeAccess[c, file, localFile, writeOnly]};          END;        temporary => {          FileTransferNSOps.GetRemoteInfo[c, source, RData[ft].attributes];          IF p.veto # NIL THEN            [answer, ft.dates] ¬ p.veto[              c, c.clientData, c.post, GetSourceInfo, ft.dates];          c.info[target].oldFile ¬ FALSE;          c.good[target] ¬ TRUE;          IF c.info[source].type = directory THEN {            FileTransferUtils.Post[              c, fatal, " Not allowed to retrieve a directory.\n"L];            ERROR Error[c, cantModify]};          file ¬ MFile.AcquireTemp[            FileTransferUtils.FileTransferToMFileType[c.info[source].type], c.info[            source].size]};        ENDCASE => ERROR Error[c, unknown];      END;  -- of SetUpLocalFile    FileTransferUtils.CheckAbort[c];    NSRetrieveStream[c, @rsCommand ! UNWIND => DeleteStream[c.stream]];    ft ¬ LOOPHOLE[c.stream];    WHILE answer # done DO      ENABLE UNWIND => DeleteStream[c.stream];      FileTransferUtils.CheckAbort[c];      answer ¬ SetUpLocalFile[ !        Error =>          IF code = cantModify THEN {answer ¬ skip; anyErrors ¬ TRUE; CONTINUE}];      SELECT answer FROM        do =>          BEGIN          bytes, time: LONG CARDINAL;	  truncate: BOOLEAN ¬ FALSE;          remoteFilename: STRING ¬ [150];          localStream ¬ MStream.Create[file, [] ! UNWIND => CleanupMFile[file]];          MFile.SetReadProtect[file, TRUE];          FileTransferUtils.Post[c, verbose, "..."L];          time ¬ System.GetClockPulses[];          bytes ¬ FileTransferUtils.DoDisk[            c, ft.stream, localStream !            NSDataStream.Aborted => {              CleanupPartialFile[c, localStream, localFile];              FileTransferUtils.Post[c, warning, "Stream Aborted\n"L];              GOTO aborted};  -- Filing Bug: Unwind the stream.get, before deleting;            UNWIND =>  -- initiated from ABORTED raised from within DoDisk;              CleanupPartialFile[c, localStream, localFile]];          -- Question: Should I include NSFile.Error catch here?          -- What if server crashes during Stream.gets?          -- Answer: No, NSDataStream.Aborted will be raised in this case, and           -- NSFile.Error will also be raised from within NSFile.Retrieve.          time ¬ System.GetClockPulses[] - time;          MFile.SetProperties[            file: file, create: c.info[source].create, length: bytes,            type: FileTransferUtils.FileTransferToMFileType[c.info[source].type],            readProtected: FALSE];          String.AppendChar[remoteFilename, '[];          String.AppendString[remoteFilename, c.host];          String.AppendChar[remoteFilename, ']];          String.AppendString[remoteFilename, ft.file !	    String.StringBoundsFault => {truncate ¬ TRUE; RESUME[NIL]}];	  IF truncate THEN remoteFilename[remoteFilename.length-1] ¬ '*;          FileName.SetRemoteName[file, remoteFilename];          FileTransferUtils.ShowBytes[            c: c, bytes: bytes, time: time, verb: "retrieved"L];          FileTransferUtils.Post[c, terse, CR];          IF p.type # remote AND localStream # NIL THEN            localStream.setPosition[localStream, 0];          DeleteStream[localStream];          EXITS            aborted => {              SetErrorEncountered: ENTRY PROC [rData: RetrieveData, b: BOOLEAN] = {                rData.errorEncountered ¬ b};              SetErrorEncountered[RData[ft], TRUE]};          -- ft will be cleaned up by NSRetrieveNextStream;            END;        skip => {CleanupMFile[file]; FileTransferUtils.Post[c, terse, " XXX\n"L]};        abort => {CleanupMFile[file]; RaiseABORTED[]};        ENDCASE;      IF localFile # NIL THEN FileTransferOps.z.FREE[@localFile];      [answer] ¬ NSRetrieveNextStream[c, ft];      ENDLOOP;    IF anyErrors THEN ERROR Error[c, cantModify]}    END;  -- of NSRetrieveFile  NSStoreFile: PUBLIC PROC [c: Connection, p: FileTransferOps.StoreCommand] =    BEGIN    localFile: STRING ¬ [FileTransferOps.maxFileName];    file: MFile.Handle ¬ NIL;    localStream: Stream.Handle ¬ NIL;    FileTransferUtils.SetupInfo[c, localFile, p.source, FALSE];    FileTransferUtils.CheckAbort[c];    file ¬ FileTransferUtils.OpenLocalFile[      c: c, name: localFile, w: source, setReadProtect: FALSE, access: readOnly];    IF file = NIL THEN {      FileTransferUtils.Post[c, fatal, localFile, " doesn't exist.\n"L];      ERROR FileTransfer.Error[c, notFound]};    BEGIN    ENABLE UNWIND => DeleteStream[localStream];    command: storeStream CommandObject;    FileTransferUtils.Post[c, terse, localFile];    FileTransferUtils.GetLocalInfo[c, file, source];    localStream ¬ MStream.Create[file, []];    command ¬ [      storeStream[      remote: p.dest, veto: p.veto, dates: p.dates, stream: localStream,      creation: c.info[source].create, bytes: c.info[source].size,      fileType: c.info[source].type, default: p.source.name]];    NSStoreStream[c, @command];    DeleteStream[localStream];    END;    END;  -- of NSStoreFile  NSStoreStream: PUBLIC PROC [    c: Connection, p: FileTransferOps.StoreStreamCommand] =    BEGIN    remoteFile: LONG STRING ¬ NIL;    answer: Confirmation ¬ do;    GetInfo: PROC [c: Connection] RETURNS [source, target: FileInfo] = {      ListRemoteInfo[c, remoteFile];      RETURN[target: c.info[target], source: c.info[source]]};    IF String.Empty[p.remote.directory] THEN {      FileTransferUtils.Post[c, fatal, "Illegal directory\n"L];      ERROR Error[c, skipOperation]};    FileTransferUtils.CheckAbort[c];    c.info[source]­ ¬ [create: p.creation, size: p.bytes, type: p.fileType];    c.good ¬ [source: TRUE, target: FALSE];    {    ENABLE UNWIND => FileTransferOps.z.FREE[@remoteFile];    remoteFile ¬ MakeDefaultName[real: p.remote, default: p.default];    IF p.dates THEN {      ListRemoteInfo[c, remoteFile]; FileTransferUtils.WriteDate[c, source]};    FileTransferUtils.ShowDestination[c, NIL, remoteFile];    IF p.dates AND c.info[target].oldFile THEN      FileTransferUtils.WriteDate[c, target];    IF p.veto # NIL THEN      answer ¬ p.veto[c, c.clientData, c.post, GetInfo, p.dates].confirm;    SELECT answer FROM      do => {        version: CARDINAL;        bytes, time: LONG CARDINAL;        IF c.good[target] THEN          FileTransferUtils.Post[            c, verbose,            IF c.info[target].oldFile THEN " [New Version]"L ELSE " [New File]"L];        FileTransferUtils.Post[c, verbose, "..."L];        [bytes, time, version] ¬ OpenRemoteAndStore[c, remoteFile, p];        SetVFNVersion[p.remote, version];        FileTransferUtils.Post[c, verbose, "!"L, p.remote.version, ", "L];        FileTransferUtils.ShowBytes[          c: c, bytes: bytes, time: time, verb: "stored"L];        FileTransferUtils.Post[c, terse, CR]};      skip => FileTransferUtils.Post[c, terse, " XXX\n"L];      abort => RaiseABORTED[];      ENDCASE;    FileTransferOps.z.FREE[@remoteFile];    };    END;  -- of NSStoreStream  OpenRemoteAndStore: PROC [    c: Connection, remoteName: LONG STRING, p: FileTransferOps.StoreStreamCommand]    RETURNS [bytes, time: LONG CARDINAL, version: CARDINAL] =    BEGIN    leadingSlash: BOOLEAN ¬ remoteName[0] = '/;    subString: String.SubStringDescriptor ¬ [      base: remoteName, offset: IF leadingSlash THEN 1 ELSE 0,      length: IF leadingSlash THEN remoteName.length-1 ELSE remoteName.length];    fileName: String.SubString ¬ @subString;    root: LONG STRING ¬ [FileTransferOps.maxName];    dh, fh: NSFile.Handle ¬ NSFile.nullHandle;    CleanupFiles: PROC = {CloseNSFile[c, @dh]; CloseNSFile[c, @fh]};    SourceProc: PROC [sink: NSDataStream.SinkStream] =      BEGIN      BEGIN      ENABLE { UNWIND => Stream.Delete[sink]; NSDataStream.Aborted => CONTINUE};      [bytes] ¬ FileTransferUtils.DoDisk[        c: c, from: p.stream, to: sink ! UNWIND => NSDataStream.Abort[sink]]      END;      Stream.Delete[sink ! NSDataStream.Aborted => CONTINUE]      END;    {    ENABLE UNWIND => CleanupFiles[];    a: ARRAY [0..4) OF NSFile.Attribute;    exists: BOOLEAN;    -- dh ¬ OpenRoot[c]; ** leave null; see what happens    [fh, exists] ¬ OpenExisting[c, @dh, fileName, root, none];    IF exists THEN CloseNSFile[c, @fh]    ELSE  { -- need to create directories which don't exist; Filing should do this;      IF fh = NSFile.nullHandle THEN { -- not allowed to create a file drawer        FileTransferUtils.Post[c, fatal, "No such directory: "L, root, "\n"L];	ERROR FileTransfer.Error[c, notFound]};        dh ¬ OpenNonExisting[c, @fh, fileName, root]};    a ¬ [      [name[S[root]]], [sizeInBytes[p.bytes]], [createdOn[p.creation]], [      type[FileTransferNSOps.NSFileType[p.fileType]]]];    time ¬ System.GetClockPulses[];    fh ¬ NSFile.Store[      directory: dh, source: [proc[SourceProc]], attributes: DESCRIPTOR[a],      session: NSData[c].session];    time ¬ System.GetClockPulses[] - time;    version ¬ GetVersion[c, fh];    CleanupFiles[]}    END;  -- of OpenRemoteAndStore   GetVersion: PROC [c: Connection, fH: NSFile.Handle] RETURNS [version: CARDINAL] =    {    attrRec: NSFile.AttributesRecord;    selects: NSFile.Selections;    selects.interpreted[version] ¬ TRUE;    NSFile.GetAttributes[      file: fH, selections: selects, attributes: @attrRec,      session: NSData[c].session];    version ¬ attrRec.version};  GetHighestVersion: PROC [c: Connection, dH: NSFile.Handle, name: LONG STRING]    RETURNS [version: CARDINAL] = {    -- Not needed any more with Filing's versions implemented;    select: NSFile.Selections;    scope: NSFile.Scope ¬ [direction: backward, filter: [equal[[name[S[name]]]]]];    proc: NSFile.AttributesProc = {version ¬ attributes.version; continue ¬ FALSE};    select.interpreted[version] ¬ TRUE;    NSFile.List[      directory: dH, proc: proc, selections: select, scope: scope,      session: NSData[c].session]};  SetVFNVersion: PROC [vfn: VFN, v: CARDINAL] =    BEGIN    vString: STRING ¬ [10];    String.AppendNumber[vString, v ! String.StringBoundsFault => RESUME [NIL]];    String.Replace[@vfn.version, vString, heap];    END;  -- Utility stuff  RaiseABORTED: PROC = {    Process.CancelAbort[Process.GetCurrent[]];    ERROR ABORTED};  FreeRetrieveObject: PROC [ft: FileTransferOps.FTHandle, rData: RetrieveData] = {    IF rData.attributes # NIL THEN NSFile.FreeAttributes[rData.attributes];    FileTransferOps.z.FREE[@rData]};  EmptySubString: PROC [s: String.SubString] RETURNS [BOOLEAN] = INLINE {    RETURN[s.length = 0]};  -- OpenExisting, OpenNonExisting, GetRoot, etc. are needed until Filing provides a StoreByName that creates any directories which don't already exist.    GetRoot: PROC [fileName: String.SubString, root: LONG STRING] = {    OPEN fileName;    StripChar: PROC = INLINE {offset ¬ offset + 1;  length ¬ length - 1};    N: CARDINAL ¬ offset + length;    quote: CHARACTER = '';    i: CARDINAL ¬ offset;    root.length ¬ 0;    WHILE i < N DO      SELECT base[i] FROM        quote =>  {	  i ¬ i+1; StripChar[]; IF i = N THEN EXIT;	  String.AppendChar[root, base[i]]};        '>, '/ =>  EXIT;        '< =>  root.length ¬ 0;        ENDCASE => String.AppendChar[root, base[i]];      i ¬ i+1;      StripChar[];      ENDLOOP;    IF EmptySubString[fileName] THEN RETURN;    StripChar[]};  OpenExisting: PUBLIC PROC [    c: Connection, dhPtr: POINTER TO NSFile.Handle, fileName: String.SubString,    root: LONG STRING, lock: NSFile.Lock ¬ none]    RETURNS [fh: NSFile.Handle, exists: BOOLEAN ¬ TRUE] =    -- If file exists, return handle to the file and set dhPtr to its parent; If not found, return handle to last existing directory, and close parent.    BEGIN    a: ARRAY [0..1) OF NSFile.Attribute;    fh ¬ dhPtr­;    WHILE ~EmptySubString[fileName] DO      GetRoot[fileName, root];      a ¬ [[name[S[root]]]];      fh ¬ NSFile.Open[        directory: dhPtr­, attributes: DESCRIPTOR[a], controls: [lock: lock],        session: NSData[c].session !        NSFile.Error =>          WITH error SELECT FROM            access =>              IF problem = fileNotFound THEN {                fh ¬ dhPtr­; dhPtr­ ¬ NSFile.nullHandle; exists ¬ FALSE; EXIT}              ELSE REJECT            ENDCASE];      IF EmptySubString[fileName] THEN RETURN[fh, exists];      CloseNSFile[c, dhPtr];      dhPtr­ ¬ fh      ENDLOOP    END;  OpenNonExisting: PUBLIC PROC [    c: Connection, dhPtr: POINTER TO NSFile.Handle, fileName: String.SubString,    root: LONG STRING] RETURNS [fh: NSFile.Handle] =    -- Create directories appearing in fileName acquiring an exclusive lock on the file returned; upon exit, only returned handle remains open. This is the only place directories are created.    BEGIN    a: ARRAY [0..3) OF NSFile.Attribute;    IF EmptySubString[fileName] THEN RETURN[fh ¬ dhPtr­];    WHILE TRUE DO      a ¬ [        [name[S[root]]], [isDirectory[TRUE]], [type[NSAssignedTypes.tDirectory]]];      fh ¬ NSFile.Create[        directory: dhPtr­, attributes: DESCRIPTOR[a], controls: [lock: exclusive],        session: NSData[c].session];      NSFile.Close[dhPtr­, NSData[c].session];      dhPtr­ ¬ fh;      GetRoot[fileName, root];      IF EmptySubString[fileName] THEN EXIT;      ENDLOOP;    dhPtr­ ¬ NSFile.nullHandle    END;  RData: PUBLIC PROC [ft: FileTransferOps.FTHandle] RETURNS [RetrieveData] = INLINE    {RETURN[LOOPHOLE[ft.data, RetrieveData]]};  ListRemoteInfo: PUBLIC PROC [c: Connection, packed: LONG STRING] =    -- Get info about the highest version (or particular version if specified) of the target file. This procedure is only called from StoreFile.    BEGIN    found: BOOLEAN ¬ FALSE;    v: LONG STRING ¬ "H"L;    vfn: FileName.VirtualFilenameObject ¬ [NIL, NIL, NIL, v];    ListOne: MyAttributesProc = {      FileTransferNSOps.ConvertNSInfo[c, attributes, c.info[target]];      found ¬ TRUE;      RETURN[continue: FALSE]};    IF c.good[target] THEN RETURN;    FileName.UnpackFilename[packed, @vfn];    FileTransferNSOps.OpenCatalogAndEnumerate[      c, ListOne, @vfn, enumerate ! NSFile.Error => CONTINUE];    FileName.ResetVFN[@vfn, TRUE, TRUE, TRUE, FALSE];    IF ~found THEN c.info[target]­ ¬ [oldFile: FALSE];    c.good[target] ¬ TRUE    END;  CleanupMFile: PROC [file: MFile.Handle] = {    IF file # NIL THEN MFile.Release[file]};  CleanupPartialFile: PROC [    c: Connection, stream: MStream.Handle, fileName: LONG STRING] =    BEGIN    file: MFile.Handle ¬ MStream.GetFile[stream];    IF c.info[target].oldFile THEN      BEGIN      IF ~c.info[target].readProtect THEN {        MFile.SetTimes[file: file, create: c.info[target].create];        MFile.SetReadProtect[file, FALSE];        DeleteStream[stream]};      END    ELSE      BEGIN      file ¬ MFile.CopyFileHandle[file, []];      DeleteStream[stream];      FileTransferUtils.ChangeAccess[        c, file, fileName, delete ! UNWIND => CleanupMFile[file]];      MFile.Delete[file];      END;    END;  DeleteStream: PROC [sH: Stream.Handle] = {IF sH # NIL THEN sH.delete[sH]};  CloseNSFile: PROC [c: Connection, fH: POINTER TO NSFile.Handle] = {    IF fH­ # NSFile.nullHandle THEN {      NSFile.Close[        fH­, NSData[c].session ! NSFile.Error, Courier.Error => CONTINUE];      fH­ ¬ NSFile.nullHandle}};  MakeDefaultName: PROC [default: LONG STRING, real: VFN, remote: BOOLEAN ¬ TRUE]    RETURNS [file: LONG STRING] = {    file ¬ PackPathname[vfn: real, remote: remote];    IF (String.Empty[real.name] AND ~FileTransferUtils.HasWildCard[default]) THEN      String.AppendString[file, default]};  PackPathname: PUBLIC PROC [vfn: FileName.VFN, remote: BOOLEAN]    RETURNS [s: LONG STRING] =    BEGIN OPEN FileTransferOps;    sep: CHAR ¬ IF remote THEN '/ ELSE '>;    s ¬ String.MakeString[z, maxFileName];    IF ~String.Empty[vfn.directory] THEN      BEGIN      String.AppendStringAndGrow[@s, vfn.directory, z, maxFileName];      IF remote THEN SetRemoteSeparator[s];      IF vfn.directory[vfn.directory.length - 1] # sep THEN        String.AppendCharAndGrow[@s, sep, z];      END;    IF ~String.Empty[vfn.name] THEN      String.AppendStringAndGrow[@s, vfn.name, z, maxFileName];    RETURN[s]    END;  SetRemoteSeparator: PROC [dir: LONG STRING] = {    FOR i: CARDINAL IN [0..dir.length) DO      SELECT dir[i] FROM '<, '> => dir[i] ¬ '/; ENDCASE ENDLOOP};  S: PROC [mS: LONG STRING] RETURNS [NSString.String] = INLINE {    RETURN[NSString.StringFromMesaString[mS]]};  END.
-- File: FileTransfersNSB.mesa - last edit:-- bjd                 22-Feb-88 20:31:49-- Riggle.PA            8-Aug-86 12:23:48-- Copyright (C) 1984, 1985, 1986, 1987, 1988 by Xerox Corporation. All rights reserved. DIRECTORY  Courier USING [Error],  FileName USING [NormalizeVFN, VFN],  FileTransfer USING [    Confirmation, Connection, ConnectionObject, Error, FileInfo, ListProc,    ValidProperties],  FileTransferNSOps USING [   cacheSize, DirectoryCache, MesaFileType, MyAttributesProc, NSData, NSDataHandle, NSDataObject],  FileTransferOps USING [    CommandObject, Connection, ConnectionObject, DeleteCommand, DelVerCommand, ListCommand, maxFileName, NSDataObject, Operation, RenameCommand, Which, z],  FileTransferUtils USING [ActOn, AppendVFN, CheckAbort, Post],  NSFile USING [    allDescendants, Attribute, Attributes, AttributesProc, AttributesRecord, AttributeType, ChangeAttributes, Close, CopyAttributes, defaultOrdering, Delete, Error, Filter, FreeAttributes, GetAttributes, Handle, highestVersion, List, lowestVersion, nullFilter, nullHandle, Open, OpenByName, Scope, Selections, String],  NSFileName USING [Character, nameVersionPairSeparator, versionSeparator],  NSString USING [    AppendToMesaString, Character, Characters, CompareStrings, CopyString, EquivalentStrings, ExpandString, FreeCharacters, FreeString, LowerCase, String, StringFromMesaString],  String USING [    AppendChar, AppendNumber, AppendString, Empty, Equivalent, FreeString, InvalidNumber, Replace, StringBoundsFault, StringToNumber];FileTransfersNSB: PROGRAM  IMPORTS    Courier, FileName, FileTransfer, FileTransferOps, FileTransferNSOps,    FileTransferUtils, NSFile, NSString, String  EXPORTS FileTransfer, FileTransferNSOps =  BEGIN OPEN FileTransfer, FileTransferNSOps;    --   --   --   --   --   --   --   --  -- TYPES & CONSTANTS :  --   --   --   --   --   --   --   --    Connection: TYPE = FileTransferOps.Connection;  ConnectionObject: PUBLIC TYPE = FileTransferOps.ConnectionObject;  NSDataHandle: TYPE = FileTransferNSOps.NSDataHandle;  NSDataObject: PUBLIC TYPE = FileTransferNSOps.NSDataObject;  VFN: TYPE = FileName.VFN;  maxFileName: CARDINAL = FileTransferOps.maxFileName;    -- these go in to FileName in some form  wildChar: CHAR = '*;  wildString: LONG STRING = "*";  oldLeftSeparator: CHAR = '<;  oldRightSeparator: CHAR = '>;  newSeparator: CHAR = '/;  oldLowestVersion: CHAR = 'L;  newLowestVersion: CHAR = '-;  oldHighestVersion: CHAR = 'H;  newhighestVersion: CHAR = '+;  versionSeparator: NSString.Character = NSFileName.versionSeparator;    nameVersionPairSeparator: NSString.Character =    NSFileName.nameVersionPairSeparator;    CR: LONG STRING = "";    MyAttributesProc: TYPE = FileTransferNSOps.MyAttributesProc;  --   --   --   --   --   --   --   --  -- PUBLIC PROCEDURES :  --   --   --   --   --   --   --   --    NSDeleteFile: PUBLIC PROC [c: Connection, p: FileTransferOps.DeleteCommand] =    BEGIN    found: BOOLEAN ¬ FALSE;    deleteProc: MyAttributesProc =      BEGIN      confirm: Confirmation ¬ do;      GetInfo: PROC [conn: Connection]        RETURNS [source, target: FileTransfer.FileInfo] = {        GetRemoteInfo[conn, source, attributes];        RETURN[source: conn.info[source], target: NIL]};      found ¬ TRUE;      c.good[source] ¬ FALSE;      FileTransferUtils.Post[c, terse, pathname, " ... "L];      FileTransferUtils.CheckAbort[c];      IF p.veto # NIL THEN        confirm ¬ p.veto[c, c.clientData, c.post, GetInfo, FALSE].confirm;      SELECT confirm FROM        do => {	  id: ARRAY [0..1) OF NSFile.Attribute ¬ [ [fileID[attributes.fileID]] ];	  fh: NSFile.Handle ¬ NSFile.Open[	    attributes: DESCRIPTOR[id], session: NSData[c].session];	  IF attributes.isDirectory AND NumberOfChildren[c, fh] # 0 THEN {	    ENABLE UNWIND => CloseNSFile[c, @fh];	    FileTransferUtils.Post[	      c, fatal, " cannot be deleted because directory is not empty\n"L];	    SIGNAL Error[c, skipFile];	    NSFile.Close[fh, NSData[c].session];	    RETURN[TRUE]};	  NSFile.Delete[fh, NSData[c].session !	    UNWIND => CloseNSFile[c, @fh]];	  FileTransferUtils.Post[c, terse, "deleted.\n"L];	  continue ¬ TRUE};	skip => {	  FileTransferUtils.Post[c, terse, "  XXX\n"L];	  continue ¬ TRUE};	abort=> {	  FileTransferUtils.Post[c, terse, "  XXX\n"L];	  continue ¬ FALSE};	ENDCASE;       END;    FileTransferUtils.CheckAbort[c];    IF String.Empty[p.file.name] THEN ERROR NSFile.Error[[access[fileNotFound]]];    OpenCatalogAndEnumerate[c, deleteProc, p.file, delete];    IF ~found THEN ERROR NSFile.Error[[access[fileNotFound]]]    END;      NSListFile: PUBLIC PROC [c: Connection, p: FileTransferOps.ListCommand] = {    found: BOOLEAN ¬ FALSE;    enumProc: MyAttributesProc =      BEGIN      GetInfo: PROC [conn: Connection]        RETURNS [source, target: FileTransfer.FileInfo] = {        GetRemoteInfo[conn, source, attributes];        RETURN[source: conn.info[source], target: NIL]};      found ¬ TRUE;      c.good[source] ¬ FALSE;      continue ¬ p.proc[c, c.clientData, pathname, c.post, GetInfo]=do;      FileTransferUtils.CheckAbort[c];      END;    FileTransferUtils.CheckAbort[c];    OpenCatalogAndEnumerate[c, enumProc, p.files, enumerate];    IF ~found THEN ERROR NSFile.Error[[access[fileNotFound]]]};  OpenCatalogAndEnumerate: PUBLIC PROC [    c: FileTransferOps.Connection, procedure: MyAttributesProc,    vfn: VFN, cmdType: FileTransferOps.Operation] =    BEGIN    rootDirectory, dirH: NSFile.Handle ¬ NSFile.nullHandle;    previous: NSFile.Attributes ¬ NIL;    allVersions, aborted, match, oneName, oneVersion: BOOLEAN ¬ FALSE;    scope: NSFile.Scope ¬ [];    filterList: ARRAY [0..2) OF NSFile.Filter;    nameFilter, versionFilter, filter: NSFile.Filter;    versionAttribute: NSFile.Attribute;    vNumber, count: CARDINAL;    tempDir: LONG STRING ¬ NIL;    ePattern: NSString.Characters ¬ NIL;    CleanUp: PROCEDURE = {      CloseDirectory[c, dirH];      IF previous # NIL THEN {NSFile.FreeAttributes[previous]; previous ¬ NIL};      IF ePattern # NIL THEN {        NSString.FreeCharacters[FileTransferOps.z, ePattern]; ePattern ¬ NIL}};    enumerateProc: NSFile.AttributesProc =      BEGIN      IF cmdType#enumerate AND attributes.isDirectory AND -- ignore directories         scope.depth=NSFile.allDescendants THEN RETURN[continue: TRUE];      IF match AND scope.depth = NSFile.allDescendants THEN {       -- until Filing allows wildcard filters with allDescendants depth;	eString: NSString.Characters ¬ NSString.ExpandString[	  FileTransferOps.z, attributes.name];	IF Match[eString, 0, ePattern, 0] THEN {	  ENABLE UNWIND => NSString.FreeCharacters[FileTransferOps.z, eString];	  IF vNumber IN (NSFile.lowestVersion..NSFile.highestVersion) THEN {	    IF vNumber = attributes.version THEN {	      ReplacePathName[c, attributes];	      continue ¬ procedure[	        attributes: attributes, clientData: clientData,	        pathname: NSData[c].pathname]}}	ELSE {	  IF cmdType = retrieveStream OR cmdType = remoteToLocal THEN 	    OpenAndGetAttributes[c, attributes];	  ReplacePathName[c, attributes];	  continue ¬ procedure[	    attributes: attributes, clientData: clientData,	    pathname: NSData[c].pathname]}};	  NSString.FreeCharacters[FileTransferOps.z, eString]}	ELSE {	IF cmdType = retrieveStream OR cmdType = remoteToLocal THEN 	  OpenAndGetAttributes[c, attributes];	ReplacePathName[c, attributes];	continue ¬ procedure[	  attributes: attributes, clientData: clientData,	  pathname: NSData[c].pathname];	NSData[c].directoryCache.fileHandle ¬ NSFile.nullHandle};      END;        IF String.Empty[vfn.directory] THEN -- if we want to enumerate the root      dirH ¬ OpenRoot[c]    ELSE {     ENABLE UNWIND =>        IF tempDir#NIL THEN String.FreeString[z: FileTransferOps.z, s: tempDir];     tempDir ¬ CopyAndNormalizeDirectory[       dir: vfn.directory, z: FileTransferOps.z];     scope.depth ¬ ScanDirectoryForDepth[c, tempDir];     IF String.Empty[tempDir] THEN dirH ¬ OpenRoot[c]     ELSE       dirH ¬ OpenDirectory[c: c, dirPathname: S[tempDir]];     String.FreeString[z: FileTransferOps.z, s: tempDir]    };   -- Note:  Version in the VFN overrides the cmdType sent in if a version exists;    [vNumber, allVersions, oneVersion] ¬ VersionToNumber[c, vfn.version, cmdType];    versionAttribute ¬ [version [vNumber]];    [nameFilter, match, oneName] ¬ NameFilter[name: vfn.name, depth: scope.depth];    IF match THEN       ePattern ¬ NSString.ExpandString[FileTransferOps.z, S[vfn.name]];    versionFilter ¬ [equal[versionAttribute]];    filterList ¬ [ nameFilter, versionFilter ];    filter ¬ SELECT TRUE FROM      allVersions => nameFilter,      vNumber=NSFile.lowestVersion OR vNumber=NSFile.highestVersion =>        nameFilter,  -- until Filing allows !H and !L as filters;      ENDCASE => [and [DESCRIPTOR[filterList]] ];    count ¬       IF oneName AND oneVersion AND scope.depth#NSFile.allDescendants      THEN 1 ELSE LAST[CARDINAL];    scope ¬       IF cmdType=delver THEN [	filter: filter, depth: scope.depth,	count: count, direction: backward,	ordering: NSFile.defaultOrdering]      ELSE [filter: filter, depth: scope.depth, count: count, direction: forward];          { ENABLE UNWIND => CleanUp[];    ListLowestVersions: NSFile.AttributesProc = {      IF previous = NIL OR 	NOT NSString.EquivalentStrings[previous.name, attributes.name] THEN {	continue ¬ enumerateProc[attributes: attributes, clientData: NIL];	IF previous # NIL THEN NSFile.FreeAttributes[previous];	previous ¬ NSFile.CopyAttributes[attributes]}};    ListHighestVersions: NSFile.AttributesProc = {      IF previous # NIL THEN { -- Skip 1st time through if = NIL;	IF NOT NSString.EquivalentStrings[previous.name, attributes.name] THEN 	  continue ¬ enumerateProc[attributes: previous, clientData: NIL];	aborted ¬ ~continue;	NSFile.FreeAttributes[previous];	previous ¬ NSFile.CopyAttributes[attributes]	}      ELSE  previous ¬ NSFile.CopyAttributes[attributes]};    NSFile.List[      directory: dirH, selections: DesiredSelections[c, cmdType],      session: NSData[c].session, scope: scope,      proc: SELECT TRUE FROM        allVersions => enumerateProc,	vNumber = NSFile.lowestVersion => ListLowestVersions,	vNumber = NSFile.highestVersion => ListHighestVersions,	ENDCASE => enumerateProc  -- specified version --];    IF previous # NIL THEN       IF vNumber = NSFile.highestVersion AND ~aborted THEN        [] ¬ enumerateProc[attributes: previous, clientData: NIL]; -- last file    };    CleanUp[];    END; -- of OpenCatalogAndEnumerate      ScanDirectoryForDepth: PROC [c: Connection, directory: LONG STRING]    RETURNS [depth: CARDINAL] =    BEGIN -- assuming normalized directory (no leading or trailing separator), this procedure okays directories of the form dir1>dir2>...>dirN>*, N>=0, and sets the directory to be dir1>dir2>...>dirN;    none: CARDINAL = LAST[CARDINAL];    lastSep, wildPos: CARDINAL ¬ none;    LocateWildCardAndSeparator: PROC [directory: LONG STRING]      RETURNS [ok: BOOLEAN ¬ TRUE] = {      FOR i: CARDINAL DECREASING IN [0..directory.length) DO	SELECT directory[i] FROM	  wildChar => {	    IF i#0 AND directory[i-1]='' THEN LOOP; -- ignore quoted special chars;	    IF wildPos = none THEN wildPos ¬ i	    ELSE RETURN[ok: FALSE]}; 	  oldLeftSeparator, oldRightSeparator, newSeparator  => {	    IF i#0 AND directory[i-1]='' THEN LOOP;	    IF lastSep = none THEN lastSep ¬ i;	    directory[i] ¬ newSeparator};	  ENDCASE;	ENDLOOP};        IF ~LocateWildCardAndSeparator[directory].ok THEN GOTO illegalDirectory;    SELECT TRUE FROM      wildPos = none =>         RETURN[depth: 1]; -- no wildcards;      lastSep = none =>   -- must be dir = "*"        IF directory.length > 1 THEN GOTO illegalDirectory        ELSE {        depth ¬ NSFile.allDescendants; directory.length ¬ 0};      (lastSep+1 = wildPos) AND wildPos = directory.length-1 =>        {depth ¬ NSFile.allDescendants;        directory.length ¬ IF lastSep = none THEN 0 ELSE lastSep};      ENDCASE => GOTO illegalDirectory;    EXITS      illegalDirectory => {        FileTransferUtils.Post[c, fatal, "Illegal directory\n"L];	ERROR Error[c, skipOperation]};    END;        NumberOfChildren: PROC [c: Connection, directory: NSFile.Handle]    RETURNS [n: CARDINAL] =    BEGIN    selects: NSFile.Selections ¬ [];    attRec: NSFile.AttributesRecord;    selects.interpreted[numberOfChildren] ¬ TRUE;    NSFile.GetAttributes[      file: directory, selections: selects,      attributes: @attRec, session: NSData[c].session];    RETURN[attRec.numberOfChildren];    END;    NSRenameFile: PUBLIC PROC [c: Connection, p: FileTransferOps.RenameCommand] = {    remote: BOOLEAN = c.serverType # local;    found: BOOLEAN ¬ FALSE;      old: STRING ¬ [FileTransferOps.maxFileName];      new: STRING ¬ [FileTransferOps.maxFileName];    existProc: MyAttributesProc = {      found ¬ TRUE; continue ¬ FALSE};    renameProc: MyAttributesProc =      BEGIN      fh: NSFile.Handle;      id: ARRAY [0..1) OF NSFile.Attribute ¬ [ [fileID[attributes.fileID]] ];      a: ARRAY [0..2) OF NSFile.Attribute ¬ [        [name[S[p.new.name]]],	IF String.Empty[p.new.version] THEN [version[1]]	ELSE  [version [VersionToNumber[c, p.new.version, rename].vNumber]] ];      found ¬ TRUE;      FileTransferUtils.Post[c, terse, old, " renamed to "L];      fh ¬ NSFile.Open[	attributes: DESCRIPTOR[id], session: NSData[c].session];      NSFile.ChangeAttributes[fh, DESCRIPTOR[a], NSData[c].session];      FileTransferUtils.Post[c, terse, new, ".\n"L];      CloseNSFile[c, @fh];      continue ¬ FALSE      END;    FileTransferUtils.AppendVFN[old, p.old, remote, TRUE];    FileTransferUtils.AppendVFN[new, p.new, remote, TRUE];    IF ~String.Empty[p.new.host] AND ~String.Empty[p.old.host]      AND ~String.Equivalent[p.new.host, c.host] THEN {      FileTransferUtils.Post[c, terse, "No renaming across hosts."L];      ERROR Error[c, illegalParameters]};    IF remote THEN {      FileName.NormalizeVFN[p.old];      FileName.NormalizeVFN[p.new];      IF String.Empty[p.old.version] THEN {        FileTransferUtils.Post[c, terse, "Must specify version to be renamed."L];        ERROR Error[c, illegalParameters]};      IF ~String.Equivalent[p.old.directory, p.new.directory] THEN {        FileTransferUtils.Post[c, terse, "No renaming across directories."L];        ERROR Error[c, illegalParameters]};      OpenCatalogAndEnumerate[c, existProc, p.new, enumerate];      IF found THEN {        FileTransferUtils.Post[c, terse, p.new.name, " already exists."L];	ERROR Error[c, skipOperation]};      found ¬  FALSE;      OpenCatalogAndEnumerate[c, renameProc, p.old, rename];      IF ~found THEN ERROR NSFile.Error[[access[fileNotFound]]]}    ELSE ERROR;    };    DelVer: PUBLIC PROC [    conn: Connection, files: FileName.VFN,  keep: CARDINAL, proc: ListProc ¬ NIL] =    BEGIN    c: delver FileTransferOps.CommandObject ¬ [      delver[files: files, keep: keep, proc: proc]];    FileTransferUtils.ActOn[conn, @c, files];    END;       DeleteKeepVersions: PUBLIC PROC [    c: Connection, p: FileTransferOps.DelVerCommand] =    BEGIN    found: BOOLEAN ¬ FALSE;    cnt: CARDINAL ¬ 0;    previous: NSFile.Attributes ¬ NIL;    fh: NSFile.Handle ¬ NSFile.nullHandle;    directory: LONG STRING ¬[100];        delVerProc: MyAttributesProc =      BEGIN      confirm: Confirmation ¬ do;      GetInfo: PROC [conn: Connection]        RETURNS [source, target: FileTransfer.FileInfo] = {        GetRemoteInfo[conn, source, attributes];        RETURN[source: conn.info[source], target: NIL]};      found ¬ TRUE;      IF previous = NIL OR  -- name change        NOT NSString.EquivalentStrings[previous.name, attributes.name] THEN {         cnt ¬ 0;            IF previous # NIL THEN NSFile.FreeAttributes[previous];        previous ¬ NSFile.CopyAttributes[attributes]};	      FileTransferUtils.CheckAbort[c];      IF ~String.Equivalent[directory, NSData[c].directory] THEN {         FileTransferUtils.Post[c, terse, NSData[c].directory, CR];         directory.length ¬ 0;         String.AppendString[directory, NSData[c].directory]};      IF cnt >= p.keep THEN {  -- delete, possibly	FileTransferUtils.Post[c, terse, "  "L, pathname, " ... "L];        IF p.proc # NIL THEN	  confirm ¬ p.proc[c, c.clientData, pathname, c.post, GetInfo];        SELECT confirm FROM          do => { ENABLE UNWIND => CloseNSFile[c, @fh];	    id: ARRAY [0..1) OF NSFile.Attribute ¬ [ [fileID[attributes.fileID]] ];	    fh: NSFile.Handle ¬ NSFile.Open[	      attributes: DESCRIPTOR[id], session: NSData[c].session];	    NSFile.Delete[fh, NSData[c].session];	    FileTransferUtils.Post[c, terse, "deleted.\n"L];	    continue ¬ TRUE};	  skip => {	    FileTransferUtils.Post[c, terse, "  XXX\n"L];	    continue ¬ TRUE};	  abort=> {	    FileTransferUtils.Post[c, terse, "  XXX\n"L];	    continue ¬ FALSE};	  ENDCASE}       ELSE	cnt ¬ cnt+1;      END; -- of delVerProc          IF p.keep # LAST[CARDINAL] THEN        OpenCatalogAndEnumerate[c, delVerProc, p.files, delver]     ELSE       FileTransferUtils.Post[c, fatal, "  Bug\n"L];     IF ~found THEN ERROR NSFile.Error[[access[fileNotFound]]]     END;	        --   --   --   --   --   --   --   --  -- UTILITIES :  --   --   --   --   --   --   --   --    CloseNSFile: PROC [c: Connection, fH: POINTER TO NSFile.Handle] = {    IF fH­ # NSFile.nullHandle THEN {      NSFile.Close[fH­, NSData[c].session !         Courier.Error, NSFile.Error => CONTINUE ];      fH­ ¬ NSFile.nullHandle}};      HasWildCard: PROC [name: LONG STRING] RETURNS [BOOLEAN] = {    IF String.Empty[name] THEN RETURN[FALSE];    FOR i: CARDINAL IN [0..name.length) DO      IF name[i] = '* OR  name[i] = '# THEN RETURN[TRUE]; ENDLOOP;    RETURN[FALSE]};      Match: PROCEDURE [    string: NSString.Characters, stringIndex: CARDINAL, mask: NSString.Characters,    maskIndex: CARDINAL] RETURNS [outcome: BOOLEAN] =    BEGIN OPEN NSString;    wildString: Character = LOOPHOLE[052C];    wildChar: Character = LOOPHOLE[043C];    -- local variables    i, j: CARDINAL;    -- process each character in mask    FOR i IN [maskIndex..LENGTH[mask]) DO      SELECT mask[i] FROM        wildString =>          BEGIN  -- matches any string of zero or more characters          FOR j IN [stringIndex..LENGTH[string]] DO            IF Match[string, j, mask, i + 1].outcome THEN RETURN[TRUE]; ENDLOOP;          RETURN[FALSE];          END;        wildChar =>  -- matches any single character          IF stringIndex = LENGTH[string] THEN RETURN[FALSE]          ELSE stringIndex ¬ stringIndex + 1;        ENDCASE => {  -- temp chars          IF stringIndex = LENGTH[string] OR NSString.LowerCase[string[stringIndex]] # NSString.LowerCase[mask[i]] THEN            RETURN[FALSE]          ELSE stringIndex ¬ stringIndex + 1};      ENDLOOP;    -- string passes mask if entire string has been consumed    outcome ¬ stringIndex = LENGTH[string];    END;  NameFilter: PROC [name: LONG STRING, depth: CARDINAL]    RETURNS [      filter: NSFile.Filter ¬ NSFile.nullFilter, match: BOOLEAN ¬ FALSE,      oneName: BOOLEAN ¬ FALSE] =    BEGIN    nameAttribute: NSFile.Attribute ¬ [name [S[name]]];    SELECT TRUE FROM       String.Empty[name], String.Equivalent[name, wildString] =>        filter ¬ NSFile.nullFilter;      ENDCASE =>  -- until Filing allows any filters with allDescendants        IF depth = NSFile.allDescendants THEN {	  filter ¬ NSFile.nullFilter; match ¬ TRUE}	ELSE IF HasWildCard[name] THEN	  filter ¬ [matches[nameAttribute]]	ELSE {	    filter ¬ [equal[nameAttribute]];  oneName ¬ TRUE}    END;  VersionToNumber: PUBLIC PROC [    c: Connection, version: LONG STRING, cmdType: FileTransferOps.Operation]    RETURNS [      vNumber: CARDINAL ¬ NSFile.lowestVersion, all: BOOLEAN ¬ FALSE,      oneVersion: BOOLEAN ¬ FALSE] = {    SELECT TRUE FROM     String.Empty[version] =>        SELECT cmdType FROM         enumerate, delver => all ¬ TRUE;	 delete => NULL;	 retrieveStream => vNumber ¬ NSFile.highestVersion         ENDCASE => ERROR Error[c, unknown];      String.Equivalent[version, "*"L] => all ¬ TRUE;     String.Equivalent[version, "H"L] OR String.Equivalent[version, "+"L] =>       vNumber ¬ NSFile.highestVersion;     String.Equivalent[version, "L"L] OR String.Equivalent[version, "-"L] =>       vNumber ¬ NSFile.lowestVersion;     ENDCASE => {       oneVersion ¬ TRUE;        vNumber ¬ String.StringToNumber[version !         String.InvalidNumber => {	   FileTransferUtils.Post[c, fatal, "Invalid version\n"L];	   ERROR Error[c, skipOperation]}]}};      GetRemoteInfo:  PUBLIC PROC [    conn: FileTransferOps.Connection, which: FileTransferOps.Which,    attributes: NSFile.Attributes] = {    IF conn.good[which] THEN RETURN;    ConvertNSInfo[conn, attributes, conn.info[which]];    conn.info[which].host ¬ conn.lastHost;    conn.good[which] ¬ TRUE};  ConvertNSInfo: PUBLIC PROC [    c: FileTransferOps.Connection,    attributes: NSFile.Attributes, info: FileTransfer.FileInfo] = {    nsData: FileTransferNSOps.NSDataHandle = NSData[c];    IF attributes = NIL THEN {info­ ¬ [oldFile: FALSE]; RETURN};    nsData.body.length ¬ 0;    nsData.author.length ¬ 0;    nsData.version.length ¬ 0;    IF c.desiredProps[body] THEN       NSString.AppendToMesaString[        nsData.body, attributes.name ! String.StringBoundsFault => RESUME[NIL]];    IF c.desiredProps[directory] THEN SetDirectory[c];    IF c.desiredProps[version] THEN       String.AppendNumber[nsData.version, attributes.version !	String.StringBoundsFault => RESUME[NIL]];    IF c.desiredProps[author] THEN       NSString.AppendToMesaString[nsData.author, attributes.createdBy !	String.StringBoundsFault => RESUME[NIL]];    info­ ¬ [      body: nsData.body, author: nsData.author,      version: nsData.version, directory: nsData.directory,      create: attributes.createdOn, read: attributes.readOn,      write: attributes.modifiedOn, size: attributes.sizeInBytes,      type: FileTransferNSOps.MesaFileType[attributes.type]     ];    };       map: ARRAY FileTransfer.ValidProperties OF NSFile.AttributeType = [     -- these 4 are dummies; no corresponding NS type; name is always TRUE;     host: name, directory: name, oldFile: name, readProtect: name,          body: name, version: version, author: createdBy,     create: createdOn, read: readOn, write: modifiedOn,      size: sizeInBytes, type: type];      DesiredSelections: PROC [c: Connection, op: FileTransferOps.Operation]    RETURNS [selections: NSFile.Selections ¬ []] = {    FOR i: FileTransfer.ValidProperties IN [body..readProtect] DO      selections.interpreted[map[i]] ¬ c.desiredProps[i]      ENDLOOP;    selections.interpreted[type] ¬ TRUE;  -- I depend on these internally;    selections.interpreted[fileID] ¬ TRUE;    selections.interpreted[name] ¬ TRUE;    selections.interpreted[pathname] ¬ TRUE;    selections.interpreted[isDirectory] ¬ TRUE;    -- in the case of Retrieve    IF op=remoteToLocal OR op=retrieveStream THEN {      selections.interpreted[pathname] ¬ FALSE;      selections.interpreted[sizeInBytes] ¬ FALSE};  <<was TRUE fjh>>    };    ReplacePathName: PROC [    c: Connection, attributes: NSFile.Attributes] =    BEGIN OPEN attributes;    nsData: FileTransferNSOps.NSDataHandle ¬ NSData[c];    origLen: CARDINAL = pathname.length;    SELECT TRUE FROM      nsData.pathname = NIL => 	nsData.pathname ¬ FileTransferOps.z.NEW[	  StringBody [pathname.length + maxFileName]];      pathname.length >= nsData.pathname.length => {	FileTransferOps.z.FREE[@nsData.pathname];	nsData.pathname ¬ FileTransferOps.z.NEW[	  StringBody [pathname.length + maxFileName]]};      ENDCASE =>  nsData.pathname.length ¬ 0;    FOR j: CARDINAL DECREASING IN [0..pathname.length) DO       pathname.length ¬ j;      IF pathname.bytes[j] = versionSeparator.code THEN EXIT;      ENDLOOP;    nsData.dirLength ¬ AppendPathExceptVersions[nsData.pathname, pathname];    IF isDirectory THEN String.AppendChar[      nsData.pathname, 0C+nameVersionPairSeparator.code]    ELSE -- append version    FOR j: CARDINAL IN [pathname.length..origLen) DO      nsData.pathname[nsData.pathname.length] ¬ 0C + pathname.bytes[j];      nsData.pathname.length ¬ nsData.pathname.length+1;      ENDLOOP;    pathname.length ¬ origLen;     END;      AppendPathExceptVersions: PROCEDURE [    name: LONG STRING, path: NSString.String] RETURNS [dirLength: CARDINAL] = {    append: BOOLEAN ¬ TRUE;    -- name.length = 0;    dirLength ¬ 0;    FOR pi: CARDINAL IN [0..path.length) DO      IF append THEN        append ¬ path.bytes[pi] # versionSeparator.code      ELSE         IF path.bytes[pi] = nameVersionPairSeparator.code THEN {	  append ¬ TRUE; dirLength ¬ name.length};      IF append THEN {        name[name.length] ¬ 0C + path.bytes[pi];	name.length ¬ name.length+1};      ENDLOOP};      SetDirectory: PROCEDURE [c: Connection] =    BEGIN    data: FileTransferNSOps.NSDataHandle ¬ NSData[c];    String.Replace[to: @data.directory, from: data.pathname, z: FileTransferOps.z];    data.directory.length ¬ data.dirLength;    END;  CopyAndNormalizeDirectory: PROCEDURE [dir: LONG STRING, z: UNCOUNTED ZONE]    RETURNS [newDir: LONG STRING] =    BEGIN    b: CARDINAL =      IF dir[0] = newSeparator OR dir[0] = oldLeftSeparator THEN 1 ELSE 0;    e: CARDINAL =       IF dir[dir.length-1] = newSeparator THEN dir.length-1 ELSE dir.length;    newDir ¬ z.NEW[StringBody[dir.length]];    FOR i: CARDINAL IN [b..e) DO      newDir[newDir.length] ¬ dir[i]; newDir.length ¬ newDir.length+1      ENDLOOP;    END;  S: PROC [mS: LONG STRING] RETURNS [NSString.String] = INLINE     {RETURN[NSString.StringFromMesaString[mS]]};  OpenDirectory: PROCEDURE [c: Connection, dirPathname: NSString.String]    RETURNS [handle: NSFile.Handle] =    BEGIN  -- search for directory in circular cache;    OPEN FileTransferNSOps, cache: NSData[c].directoryCache;    i: NATURAL ¬ cache.index;    DO  -- repeat      IF cache[i].handle = NSFile.nullHandle THEN {	handle ¬ NSFile.OpenByName[	  directory: NSFile.nullHandle, path: dirPathname, session: NSData[c].session];        EXIT};      IF NSString.CompareStrings[        dirPathname, cache[i].pathname] = equal THEN	RETURN[cache[i].handle];      i ¬ (i+1) MOD cacheSize;      IF i=cache.index THEN {  -- until i=index	handle ¬ NSFile.OpenByName[ -- don't move index if dir not found	  directory: NSFile.nullHandle, path: dirPathname, session: NSData[c].session];        cache.index ¬ i ¬ (i-1+cacheSize) MOD cacheSize;        NSFile.Close[cache[i].handle, NSData[c].session];	NSString.FreeString[FileTransferOps.z, cache[i].pathname];	EXIT}      ENDLOOP;    cache[i] ¬ [      handle: handle, pathname: NSString.CopyString[FileTransferOps.z, dirPathname]];    END;    CloseDirectory: PROCEDURE [c: Connection, handle: NSFile.Handle] =    BEGIN    -- noop for now --    END;  OpenRoot: PUBLIC PROC [c: Connection] RETURNS [rootDirectory: NSFile.Handle] = {    IF NSData[c].directoryCache.rootHandle = NSFile.nullHandle THEN      NSData[c].directoryCache.rootHandle ¬ NSFile.Open[        attributes: NIL, session: NSData[c].session];    RETURN[NSData[c].directoryCache.rootHandle]};  OpenAndGetAttributes: PROC [    c: FileTransferOps.Connection, attributes: NSFile.Attributes] =    BEGIN -- avoid going off to the file twice for sizeInBytes & pathname for retrieves;    id: ARRAY [0..1) OF NSFile.Attribute ¬ [[fileID[attributes.fileID]]];    myAttributes: NSFile.AttributesRecord;     NSData[c].directoryCache.fileHandle ¬ NSFile.Open[      attributes: DESCRIPTOR[id], session: NSData[c].session];    NSFile.GetAttributes[      file: NSData[c].directoryCache.fileHandle, selections: [        interpreted:[pathname: TRUE, sizeInBytes: TRUE]],      attributes: @myAttributes, session: NSData[c].session];    attributes.sizeInBytes ¬ myAttributes.sizeInBytes;    --assumed that pathname was not requested already!    attributes.pathname ¬ myAttributes.pathname;    END;  -- of OpenAndGetAttributes   END.
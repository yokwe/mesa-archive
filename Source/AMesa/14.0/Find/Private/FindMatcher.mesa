-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. -- FindMatcher.mesa-- Woods        83-Oct-10  4:09 pm-- Saaranzin	13-Jan-84  9:50:43-- Gleason	19-Nov-84 15:03:23DIRECTORY  BitBlt USING [    AlignedBBTable, BBptr, BBTable, BBTableAlignment, BBTableSpace, BITBLT],  Environment USING [bitsPerWord, Block, charsPerWord],  FindOps,  Format USING [Block, LongNumber, StringProc],  Heap USING [MakeNode, NWords, systemZone],  Inline USING [LongCOPY],  Stream USING [CompletionCode, GetBlock, Handle],  String USING [AppendChar, MakeString];FindMatcher: PROGRAM  IMPORTS BitBlt, FindOps, Format, Heap, Inline, Stream, String  EXPORTS FindOps = BEGIN OPEN FindOps;<< One of two pattern-matching algorithms is used.  If there is only one key, and it contains no repetition-type wildcards, and the sets of characters permitted in different positions do not partially overlap, and it's more than two characters long, then the Boyer-Moore sublinear search is used.  Otherwise, a tight-loop linear search is performed using a finite state automaton.In either case, the keys are first parsed and equivalence classes are computed for the characters in the character set.  (This either reduces the size of the rtansition tables for the automata, or handles case-ignoring and related stuff for Boyer-Moore.)  If Boyer-Moore cannot be used, the keys are next converted into a transition table for a non-deterministic finite-state automaton (NDFSA).  The achievable unions of states are computed and are made the states of a deterministic FSA (DFSA); a hash table is used to expedite determining equality between two DFSA states.  The transition table for this DFSA is what drives the inner loop. >>-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ------ Constants-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----z: UNCOUNTED ZONE = Heap.systemZone;maxNode: Heap.NWords = Heap.NWords.LAST;-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ------ Top-level parsing control-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----ChooseMatcher: PUBLIC PROC [    keys: KeyPointer, ignore: SetPointer, alphabetSize: CARDINAL]    RETURNS [SearchProc, FreeProc, LONG POINTER] = {  -- determine whether can use Boyer-Moore, and if so create mapped pattern key  wild: BOOL ¬ keys.link # NIL OR keys.length > overlap OR keys.length < 3;  mappedKey: LONG STRING ¬    IF wild THEN NIL ELSE String.MakeString[z, keys.length];  FOR ch: CHAR IN [FIRST[CHAR]..FIRST[CHAR]+alphabetSize) UNTIL wild DO    wild ¬ ignore[ch];    ENDLOOP;  FOR c: CARDINAL IN [0..keys.length) UNTIL wild DO    multiple: BOOLEAN ¬ FALSE;    wild ¬ keys.key[c].repeat;    FOR ch: CHAR IN [FIRST[CHAR]..FIRST[CHAR]+alphabetSize) UNTIL wild DO      IF keys.key[c].chars[ch] THEN        IF multiple THEN wild ¬ TRUE	ELSE {multiple ¬ TRUE; String.AppendChar[mappedKey, ch]};      ENDLOOP;    ENDLOOP;  IF ~wild THEN -- yes, can use Boyer-Moore (with char equivalence classes)    RETURN      [BoyerMooreSearch, FreeBM, MakeFailureFunctions[mappedKey, alphabetSize]]  ELSE {    ndfsa: NDFSA ¬ BuildNDFSA[keys, alphabetSize];    dfsa: TransitionTable;    z.FREE[@mappedKey];    FOR ch: CHAR IN [FIRST[CHAR]..FIRST[CHAR]+alphabetSize) DO      IF ignore[ch] THEN {	vector: DFSAstate = @ndfsa[ndfsa.transitions[ch].loop];	FOR bit: CARDINAL IN [0..ndfsa.states) DO vector[bit] ¬ TRUE ENDLOOP};      ENDLOOP;    IF (dfsa ¬ BuildDFSA[29, alphabetSize, ndfsa]) = NIL AND      (dfsa ¬ BuildDFSA[127, alphabetSize, ndfsa]) = NIL THEN      dfsa ¬ BuildDFSA[PrimeNotExceeding[MIN[	(maxNode - SIZE[TTData]) / (alphabetSize * SIZE[StatePointer]),	(maxNode - SIZE[HTData]) / (SIZE[HashEntry] + SIZE[BOOL, ndfsa.states]),	131*131-1]], alphabetSize, ndfsa];    z.FREE[@ndfsa];    IF dfsa = NIL THEN ERROR ParseError["Key(s) too complex"L];    RETURN [WildcardSearch, NIL, dfsa]}};-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ------ Boyer-Moore parsing: construct tables of offsets for when match fails-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----BMhandle: TYPE = LONG POINTER TO BMdata;BMdata: TYPE = RECORD [  pattern: LONG STRING,  delta1: LONG POINTER TO Delta1,  delta2: LONG POINTER TO Delta2];Delta1: TYPE = RECORD [SEQUENCE COMPUTED CHAR OF CARDINAL];Delta2: TYPE = RECORD [SEQUENCE COMPUTED CARDINAL OF CARDINAL];  MakeFailureFunctions: PROCEDURE [key: LONG STRING, alph: CARDINAL]    RETURNS [BMhandle] = {  -- See Knuth, Morris, Pratt, "Fast Pattern...", SIAM J. Comp, June 1977  -- 1/12/84:RSS Above algorithm (dd') fails for patterns in which all characters are identical.  Changed implementation to calculate dd instead of dd' in p342 algorithm.  c: CARDINAL;  length: CARDINAL = key.length;  t: CARDINAL ¬ length;  delta1: LONG POINTER TO Delta1 = z.NEW[Delta1[alph]];  delta2: LONG POINTER TO Delta2 = z.NEW[Delta2[length]];  aux: LONG POINTER TO Delta2 ¬ z.NEW[Delta2[length]];    FOR c IN [0..alph) DO delta1[c+FIRST[CHAR]] ¬ length+1 ENDLOOP;  FOR c IN [0..length) DO    delta2[c] ¬ length + (delta1[key[c]] ¬ length - c);    ENDLOOP;  FOR c DECREASING IN [0..length) DO    aux[c] ¬ t;    WHILE t < length AND key[c] # key[t] DO      t ¬ aux[t];      ENDLOOP;    t ¬ t - 1;    delta2[t] ¬ MIN[delta2[t], length - (c-1)];        ENDLOOP;  z.FREE[@aux];  FOR c IN [0..t] DO delta2[c] ¬ MIN[delta2[c], length+1+t-c] ENDLOOP;  RETURN [z.NEW[BMdata ¬ [pattern: key, delta1: delta1, delta2: delta2]]]};FreeBM: FreeProc = {  bm: BMhandle = data;  z.FREE[@bm.pattern];  z.FREE[@bm.delta1];  z.FREE[@bm.delta2]};-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ------ Wildcard parsing: construct NDFSA transition information-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----NDFSA: TYPE = LONG BASE POINTER TO NDFSAdata;NDFSAdata: TYPE = RECORD [  states: CARDINAL,  initial, winner, loopAfterLoop, spare1, spare2: BitVector,  transitions: ARRAY CHAR [0C..0C) OF RECORD [advance, loop: BitVector],  vectors: PACKED ARRAY [0..0) OF BOOLEAN];BitVector: TYPE =   NDFSA RELATIVE POINTER TO PACKED ARRAY [0..0) OF BOOLEAN;<< Meanings of the vectors in a NDFSAdata record:	initial = union of NDFSA states representing beginnings of keys, i.e.,		the non-deterministic initial state	winner = union of NDFSA states in which we've reached the end of a key	advance[c] = NDFSA states x reachable from state x-1 via input char "c"	loop[c] = NDFSA states in which c* occurs, i.e., "c" leaves NDFSA in the		same state (if two * constructs are concatenated, the state in which		the first occurs is considered to imply the next higher state, which		is then the state in which the second * loops, as is indicated by		turning on the bit for the higher state in loopAfterLoop; this is		necessary to keep "xa*b*x" from matching "xbax")	spare# = workspaces for construction of temporary vectors >><< Order of business is:(1) Count how many states the NDFSA has, to wit:  1 for each non-repeating key character, 1 for each repeater that follows a repeater (i.e., loopAfterLoop states), and 1 per key for the initial states.(2) Allocate data block with bit vectors of number-of-states bits each.(3) Compute relative pointers.(4) Compute the bit vectors. >>BuildNDFSA: PROC [keys: KeyPointer, sizeAlph: CARDINAL]    RETURNS [ndfsa: NDFSA] = {  state: CARDINAL ¬ 0;  size: LONG CARDINAL;  bvSize, nVects: CARDINAL;  bbTable: BitBlt.BBTableSpace;  bbPtr: BitBlt.BBptr = BitBlt.AlignedBBTable[@bbTable];  FOR key: KeyPointer ¬ keys, key.link UNTIL key = NIL DO    FOR c: CARDINAL IN [0..key.length) DO      -- note that we know key[0] does not repeat (see ParseKey)      IF ~key.key[c].repeat OR key.key[c-1].repeat THEN state ¬ state + 1;      ENDLOOP;    state ¬ state + 1;    ENDLOOP;  bvSize ¬ SIZE[BOOLEAN, state];  nVects ¬ 5 + 2*sizeAlph;  size ¬ SIZE[CARDINAL] + LONG[bvSize + SIZE[BitVector]] * nVects;  IF size > maxNode THEN ERROR ParseError["Key(s) far too complex"L];  ndfsa ¬ Heap.MakeNode[z, CARDINAL[size]];  ndfsa.states ¬ state;  ndfsa.initial ¬ LOOPHOLE[SIZE[NDFSAdata] + 2*sizeAlph*SIZE[BitVector]];  ndfsa.winner ¬ ndfsa.initial + bvSize;  ndfsa.loopAfterLoop ¬ ndfsa.winner + bvSize;  ndfsa.spare1 ¬ ndfsa.loopAfterLoop + bvSize;  ndfsa.spare2 ¬ ndfsa.spare1 + bvSize;  FOR c: CARDINAL IN [0..sizeAlph) DO    ndfsa.transitions[FIRST[CHAR]+c] ¬      [ndfsa.spare2+bvSize*(c*2+1), ndfsa.spare2+bvSize*(c*2+2)];    ENDLOOP;  LOOPHOLE[@ndfsa[ndfsa.initial], LONG POINTER TO CARDINAL]­ ¬ 0;  Inline.LongCOPY[    from: @ndfsa[ndfsa.initial], to: @ndfsa[ndfsa.initial+1],    nwords: bvSize*nVects-1];  state ¬ 0;  bbPtr­ ¬ [ -- for transposing keychar.chars[i] into ndfsa[transitions[i].xxx][yyy]    dst: [word: NIL, bit: 0],    dstBpl: bvSize*2 * Environment.bitsPerWord,    src: [word: NIL, bit: 0],    srcDesc: [srcBpl [1]],    width: 1,    height: sizeAlph,    flags: copy];  FOR key: KeyPointer ¬ keys, key.link UNTIL key = NIL DO    ndfsa[ndfsa.initial][state] ¬ TRUE;    FOR c: CARDINAL IN [0..key.length) DO      keychar: LONG POINTER TO KeyChar = @key.key[c];      IF ~keychar.repeat THEN {        state ¬ state + 1;	bbPtr.dst ¬ [	  word: @ndfsa[ndfsa.transitions[FIRST[CHAR]].advance]	    + (state / Environment.bitsPerWord),	  bit: state MOD Environment.bitsPerWord]}      ELSE {        IF key.key[c-1].repeat THEN	  ndfsa[ndfsa.loopAfterLoop][state ¬ state + 1] ¬ TRUE;	bbPtr.dst ¬ [	  word: @ndfsa[ndfsa.transitions[FIRST[CHAR]].loop]	    + (state / Environment.bitsPerWord),	  bit: state MOD Environment.bitsPerWord]};      bbPtr.src.word ¬ @keychar.chars;      Blit[bbPtr];      ENDLOOP;    ndfsa[ndfsa.winner][state] ¬ TRUE;    state ¬ state + 1;    ENDLOOP};-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ------ Wildcard parsing: construct DFSA transition table-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----DFSAstate: TYPE = LONG POINTER TO PACKED ARRAY [0..0) OF BOOLEAN;DFSAwords: TYPE = LONG POINTER TO ARRAY [0..0) OF CARDINAL;TransitionTable: TYPE = LONG BASE POINTER TO TTData;TTData: TYPE = RECORD [  initial: StatePointer,  rows: ARRAY [0..0) OF StatePointer ¬ NULL]; -- each row is actually a State arrayState: TYPE = ARRAY CHAR [0C..0C) OF StatePointer;StatePointer: TYPE = TransitionTable RELATIVE POINTER TO State;win: StatePointer = LOOPHOLE[0];HashTable: TYPE = LONG BASE POINTER TO HTData;HTData: TYPE = RECORD [  tableSize, unionSize, entrySize: CARDINAL,  entries: ARRAY [0..0) OF HashEntry ¬ NULL];HashEntry: TYPE = RECORD [  used: BOOLEAN,  queueLink: NATURAL,  fastHash: CARDINAL,  union: PACKED ARRAY [0..0) OF BOOLEAN ¬ NULL];HashPointer: TYPE = HashTable RELATIVE POINTER TO HashEntry;queueNil: NATURAL = LAST[NATURAL];HashIndex: PROC [h: HashTable, n: CARDINAL]    RETURNS [LONG POINTER TO HashEntry] = INLINE {  RETURN [@h[LOOPHOLE[h.entrySize*n + SIZE[HTData], HashPointer]]]};BuildDFSA: PROC [size, sizeAlph: CARDINAL, ndfsa: NDFSA]    RETURNS [tt: TransitionTable] = {  dfsaStateSize: CARDINAL = SIZE[BOOLEAN, ndfsa.states];  hashEntrySize: CARDINAL = SIZE[HashEntry] + dfsaStateSize;  stateRowSize: CARDINAL = sizeAlph * SIZE[StatePointer];  hash: HashTable;  qHead, qTail: NATURAL;  full: CARDINAL = size - size/10; -- beyond this, hashing is likely to bog down  used: CARDINAL ¬ 1;  bbOp: TYPE = {entryShiftTo1, advanceAnd1, entryTo2, loopAnd2,    or2into1, initialOr1, copy1to2, winnerAnd2};  bbTables: RECORD [    base: BitBlt.BBTable,    rest: ARRAY bbOp OF ARRAY [0..BitBlt.BBTableAlignment) OF UNSPECIFIED];  bbPtrs: ARRAY bbOp OF BitBlt.BBptr;  sparePtr: DFSAstate = @ndfsa[ndfsa.spare1];  winPtr: DFSAwords = LOOPHOLE[@ndfsa[ndfsa.spare2]];  IF size < 20 THEN RETURN [NIL];  hash ¬ Heap.MakeNode[z, size*hashEntrySize + SIZE[HTData]];  hash­ ¬ [tableSize: size, unionSize: dfsaStateSize, entrySize: hashEntrySize];  FOR c: CARDINAL IN [0..size) DO HashIndex[hash, c].used ¬ FALSE ENDLOOP;  qHead ¬ qTail ¬ FindHash[hash, @ndfsa[ndfsa.initial]].index;  tt ¬ Heap.MakeNode[z, size*stateRowSize + SIZE[TTData]];  tt­ ¬ [initial: LOOPHOLE[qHead*stateRowSize + SIZE[TTData]]];  tt.rows[0] ¬ win;  Inline.LongCOPY[    to: @tt.rows[1], from: @tt.rows[0],    nwords: size*stateRowSize - SIZE[StatePointer]];  -- prepare all the bitblt tables  bbPtrs[entryShiftTo1] ¬ BitBlt.AlignedBBTable[LOOPHOLE[@bbTables]];  bbPtrs[entryShiftTo1]­ ¬ [    dst: [word: sparePtr, bit: 0],    dstBpl: dfsaStateSize * Environment.bitsPerWord,    src: [word: NIL, bit: 0],    srcDesc: [srcBpl [dfsaStateSize * Environment.bitsPerWord]],    width: dfsaStateSize * Environment.bitsPerWord,    height: 1,    flags: copy];  FOR op: bbOp IN (bbOp.FIRST..bbOp.LAST] DO    bbPtrs[op] ¬ bbPtrs[bbOp.FIRST] + op.ORD * BitBlt.BBTableAlignment;    bbPtrs[op]­ ¬ bbPtrs[bbOp.FIRST]­;    ENDLOOP;  bbPtrs[entryShiftTo1].dst.bit ¬ 1;  bbPtrs[entryShiftTo1].width ¬ dfsaStateSize * Environment.bitsPerWord - 1;  bbPtrs[advanceAnd1].flags ¬ bbPtrs[loopAnd2].flags ¬    bbPtrs[winnerAnd2].flags ¬ and;  bbPtrs[entryTo2].dst.word ¬ bbPtrs[loopAnd2].dst.word ¬     bbPtrs[or2into1].src.word ¬ bbPtrs[copy1to2].dst.word ¬    bbPtrs[winnerAnd2].dst.word ¬ winPtr;  bbPtrs[or2into1].flags ¬ bbPtrs[initialOr1].flags ¬ or;  bbPtrs[initialOr1].src.word ¬ @ndfsa[ndfsa.initial];  bbPtrs[copy1to2].src.word ¬ sparePtr;  bbPtrs[winnerAnd2].src.word ¬ @ndfsa[ndfsa.winner];    WHILE qHead # queueNil DO    ttRow: LONG POINTER TO State =      @tt[LOOPHOLE[qHead*stateRowSize+SIZE[TTData], StatePointer]];    qEntry: LONG POINTER TO HashEntry = HashIndex[hash, qHead];    bbPtrs[entryShiftTo1].src.word ¬ bbPtrs[entryTo2].src.word ¬ @qEntry.union;    FOR ch: CHAR IN [FIRST[CHAR]..FIRST[CHAR]+sizeAlph) DO      slot: NATURAL;      new: BOOLEAN ¬ TRUE;      -- compute effect of ch when in state qEntry.union; result includes NDFSA state x if (1) advance[ch][x] and union includes state x-1, (2) loop[ch][x] and union includes state x, or (3) x is part of the NDFSA initial state      bbPtrs[advanceAnd1].src.word ¬ @ndfsa[ndfsa.transitions[ch].advance];      bbPtrs[loopAnd2].src.word ¬ @ndfsa[ndfsa.transitions[ch].loop];      IF bitbltImplemented THEN {	BitBlt.BITBLT[bbPtrs[entryShiftTo1]];	BitBlt.BITBLT[bbPtrs[advanceAnd1]];	BitBlt.BITBLT[bbPtrs[entryTo2]];	BitBlt.BITBLT[bbPtrs[loopAnd2]];	BitBlt.BITBLT[bbPtrs[or2into1]];	BitBlt.BITBLT[bbPtrs[initialOr1]];	-- see if resulting DFSA state contains any NDFSA winner states; such states don't go into the DFSA table	BitBlt.BITBLT[bbPtrs[copy1to2]];	BitBlt.BITBLT[bbPtrs[winnerAnd2]]}      ELSE -- so much for being quick about it; might as well pay loop overhead        FOR op: bbOp IN bbOp DO Blit[bbPtrs[op]] ENDLOOP;      FOR c: CARDINAL IN [0..dfsaStateSize) WHILE new DO        new ¬ winPtr[c] = 0;	ENDLOOP;      IF ~new THEN LOOP;      [new, slot] ¬ FindHash[hash, sparePtr];      IF new THEN {	IF (used ¬ used+1) = full THEN {z.FREE[@hash]; z.FREE[@tt]; RETURN};        qTail ¬ HashIndex[hash, qTail].queueLink ¬ slot};      ttRow[ch] ¬ LOOPHOLE[slot*stateRowSize + SIZE[TTData]];      ENDLOOP;    qHead ¬ qEntry.queueLink;    ENDLOOP;  z.FREE[@hash]};FindHash: PROC [h: HashTable, union: DFSAstate]    RETURNS [new: BOOLEAN ¬ FALSE, index: NATURAL] = {  fastHash: CARDINAL ¬ 0;  entry: LONG POINTER TO HashEntry;  words: DFSAwords = LOOPHOLE[union];  unionSize: CARDINAL = h.unionSize;  FOR c: CARDINAL IN [0..unionSize) DO    fastHash ¬ fastHash + words[c];    ENDLOOP;  index ¬ fastHash MOD h.tableSize;  WHILE (entry ¬ HashIndex[h, index]).used DO    IF fastHash = entry.fastHash THEN {      compare: DFSAwords = LOOPHOLE[@entry.union];      FOR c: CARDINAL IN [0..unionSize) DO        IF compare[c] # words[c] THEN EXIT;	REPEAT FINISHED => RETURN;	ENDLOOP};    index ¬ (index + (fastHash MOD 15) + 3) MOD h.tableSize;    ENDLOOP;  entry­ ¬ [used: TRUE, queueLink: queueNil, fastHash: fastHash];  Inline.LongCOPY[to: @entry.union, from: union, nwords: unionSize];  new ¬ TRUE};PrimeNotExceeding: PROC [n: CARDINAL] RETURNS [maxPrime: CARDINAL] = {  p: ARRAY [0..30) OF CARDINAL = [    3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79,    83, 89, 97, 101, 103, 107, 109, 113, 127];  FOR maxPrime ¬ n + (n MOD 2) - 1, maxPrime - 2 UNTIL maxPrime < 128 DO    FOR c: CARDINAL IN [0..30) DO      IF maxPrime MOD p[c] = 0 THEN EXIT;      REPEAT FINISHED => RETURN;      ENDLOOP;    ENDLOOP;  FOR c: CARDINAL DECREASING IN [0..30) DO    IF p[c] <= maxPrime THEN RETURN [p[c]];    ENDLOOP;  RETURN [2]};-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ------ File search-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----BoyerMooreSearch: SearchProc = {  bm: BMhandle = data;  delta1: LONG POINTER TO Delta1 = bm.delta1;  delta2: LONG POINTER TO Delta2 = bm.delta2;  pattern: LONG STRING = bm.pattern;  length: CARDINAL = pattern.length;  block: Environment.Block ¬ [LOOPHOLE[buffer], 0, bufferSize-overlap];  index: CARDINAL ¬ length;  why: Stream.CompletionCode ¬ normal;  bytes: LONG CARDINAL ¬ 0;  winning: CARDINAL ¬ 0; -- if # 0, we're in the middle of printing a match, and are willing to scan this many more chars looking for end of line  map: MapArray = mapping­;  DO    UNTIL index <= block.startIndex DO -- get enough characters to look at      got: CARDINAL;      IF why = endOfStream OR abort OR (abort ¬ checkAbort[]) THEN        {IF winning # 0 THEN results["\n"L]; RETURN};      IF block.startIndex = block.stopIndexPlusOne THEN {	Inline.LongCOPY[	  to: buffer,	  from: buffer + (block.stopIndexPlusOne-overlap)	    / Environment.charsPerWord,	  nwords: overlap/Environment.charsPerWord];	index ¬ index - (block.stopIndexPlusOne-overlap);	block.startIndex ¬ overlap;	block.stopIndexPlusOne ¬ bufferSize};      [bytesTransferred: got, why: why] ¬ stream.GetBlock[block];      block.startIndex ¬ block.startIndex + got;      bytes ¬ bytes + got;      IF winning # 0 THEN        [index, winning]	 ¬ ReportMatch[results, block, index, winning, terseOutput];      ENDLOOP;    FOR keyIndex: CARDINAL DECREASING IN [0..length) DO      IF map[buffer[index ¬ index-1]] # pattern[keyIndex] THEN {        index ¬ index + MAX[delta1[map[buffer[index]]], delta2[keyIndex]];	EXIT};      REPEAT FINISHED => { -- found a match        matches ¬ matches + 1;	[index, winning] ¬ ReportMatch[	  results, block, index+length-1, 0, terseOutput, bytes+index+length-1-block.startIndex];	index ¬ (IF abort ¬ checkAbort[] THEN block.startIndex ELSE index) + 2};      ENDLOOP;    ENDLOOP};  WildcardSearch: SearchProc = {  dfsa: TransitionTable = data;  state: StatePointer ¬ dfsa.initial;  block: Environment.Block ¬ [LOOPHOLE[buffer], 0, bufferSize-overlap];  bytes: LONG CARDINAL ¬ 0;  winning: CARDINAL ¬ 0; -- if # 0, we're in the middle of printing a match, and are willing to scan this many more chars looking for end of line  map: MapArray = mapping­;  WHILE ~abort DO    got, index: CARDINAL;    why: Stream.CompletionCode;    [bytesTransferred: got, why: why] ¬ stream.GetBlock[block];    index ¬ block.startIndex - 1;    block.startIndex ¬ block.startIndex + got;    bytes ¬ bytes + got;    IF winning # 0 THEN      [index, winning]        ¬ ReportMatch[results, block, index+1, winning, terseOutput];    WHILE (index ¬ index + 1) < block.startIndex DO      IF (state ¬ dfsa[state][map[buffer[index]]]) = win THEN {	matches ¬ matches + 1;	[index, winning] ¬ ReportMatch[	  results, block, index, 0, terseOutput, bytes+index-block.startIndex];	IF abort OR (abort ¬ checkAbort[]) THEN EXIT;	state ¬ dfsa.initial};      ENDLOOP;    IF why = endOfStream THEN EXIT;    IF block.startIndex = block.stopIndexPlusOne THEN {      abort ¬ abort OR checkAbort[];      Inline.LongCOPY[	to: buffer,	from: buffer + (block.stopIndexPlusOne-overlap)	  / Environment.charsPerWord,	nwords: overlap/Environment.charsPerWord];      block.startIndex ¬ overlap;      block.stopIndexPlusOne ¬ bufferSize};    ENDLOOP;  IF winning # 0 THEN results["\n"L]};ReportMatch: PROC [    report: Format.StringProc, block: Environment.Block,    at, limit: CARDINAL, terse: BOOLEAN,     total: LONG CARDINAL ¬ 0]    RETURNS [lastUsed, waitingForCR: CARDINAL] = {  extend: CARDINAL = IF limit = 0 THEN overlap ELSE limit;  backTo: CARDINAL = MAX[at, extend] - extend;  forwardTo: CARDINAL = MIN[at+extend, block.startIndex];  IF terse THEN {    report["    *** FOUND ***"L];    report["\n"L]; SIGNAL Finished};  IF limit = 0 THEN { -- initial match as opposed to later search for closing CR    Format.LongNumber[report, total, [columns: 5]];    report[": "L];    FOR cr: CARDINAL DECREASING IN [backTo..at) DO      IF block.blockPointer[cr] = ('\n-0C) THEN {	Format.Block[report, [block.blockPointer, cr+1, at]];	EXIT};      REPEAT FINISHED => {	IF total > extend THEN report["..."L];	Format.Block[report, [block.blockPointer, backTo, at]]};      ENDLOOP};  FOR cr: CARDINAL IN [at..forwardTo) DO    IF block.blockPointer[cr] = ('\n-0C) THEN {      Format.Block[report, [block.blockPointer, at, cr+1]];      RETURN [cr, 0]};    ENDLOOP;  Format.Block[report, [block.blockPointer, at, forwardTo]];  IF (waitingForCR ¬ at+extend - forwardTo) = 0 THEN report["...\n"L];  lastUsed ¬ forwardTo - 1;  };END.
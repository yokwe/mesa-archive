-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- FindOps.mesa, last edit by Woods  83-Oct-10  5:16 pm-- Gleason	19-Nov-84 15:04:24DIRECTORY  BitBlt USING [BBptr, BITBLT, BitBltFlags],  Environment USING [bitsPerWord, charsPerPage],  Format USING [StringProc],  Stream USING [Handle];FindOps: DEFINITIONS IMPORTS BitBlt = BEGIN-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ------ BitBlt operations-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----or: BitBlt.BitBltFlags = [disjoint: TRUE, dstFunc: or, srcFunc: null];and: BitBlt.BitBltFlags = [disjoint: TRUE, dstFunc: and, srcFunc: null];andc: BitBlt.BitBltFlags = [disjoint: TRUE, dstFunc: and, srcFunc: complement];xor: BitBlt.BitBltFlags = [disjoint: TRUE, dstFunc: xor, srcFunc: null];invert: BitBlt.BitBltFlags = [disjoint: TRUE, dstFunc: null, srcFunc: complement];copy: BitBlt.BitBltFlags = [disjoint: TRUE, dstFunc: null, srcFunc: null];bitbltImplemented: BOOLEAN;Blit: PROC [bbPtr: BitBlt.BBptr] = INLINE {  IF bitbltImplemented THEN BitBlt.BITBLT[bbPtr]  ELSE IF bbPtr.dst.bit = 0 AND bbPtr.src.bit = 0 AND    bbPtr.width MOD Environment.bitsPerWord = 0 AND    bbPtr.dstBpl MOD Environment.bitsPerWord = 0 AND    bbPtr.srcDesc.srcBpl MOD Environment.bitsPerWord = 0 THEN QuickBlit[bbPtr]  ELSE SlowBlit[bbPtr]};QuickBlit: PROC [bbPtr: BitBlt.BBptr];SlowBlit: PROC [bbPtr: BitBlt.BBptr];-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ------ Data structures & constants-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----SetOfChars: TYPE = PACKED ARRAY CHAR OF BOOLEAN;SetPointer: TYPE = LONG POINTER TO SetOfChars;KeyChar: TYPE = RECORD [  repeat: BOOLEAN,  chars: SetOfChars];Key: TYPE = RECORD [  length: CARDINAL,  link: KeyPointer,  key: SEQUENCE maxlength: CARDINAL OF KeyChar];KeyPointer: TYPE = LONG POINTER TO Key;MapArray: TYPE = ARRAY CHAR OF CHAR;Buffer: TYPE = PACKED ARRAY [0..bufferSize) OF CHAR;bufferPages: CARDINAL = 40;bufferSize: CARDINAL = Environment.charsPerPage * bufferPages + overlap;overlap: CARDINAL = 150; -- keep this many chars from previous buffer so we can try to back up to beginning of line when we find a match-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ------ Procedure types-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----SearchProc: TYPE = PROC [  stream: Stream.Handle,  data: LONG POINTER,  mapping: LONG POINTER TO MapArray,  buffer: LONG POINTER TO Buffer,  results: Format.StringProc,  terseOutput: BOOLEAN ¬ FALSE,  checkAbort: PROC RETURNS [BOOLEAN]]  RETURNS [abort: BOOLEAN ¬ FALSE, matches: LONG CARDINAL ¬ 0];FreeProc: TYPE = PROC [data: LONG POINTER];-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ------ Procedures & signals-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----ChooseMatcher: PROC [  keys: KeyPointer, ignore: SetPointer, alphabetSize: CARDINAL]  RETURNS [SearchProc, FreeProc, LONG POINTER];Finished: SIGNAL;ParseError: ERROR [s: STRING, swch: BOOLEAN ¬ FALSE];END.
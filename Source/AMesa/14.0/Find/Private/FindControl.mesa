-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved. -- FindControl.mesa, last edit by:-- Woods	83-Oct-11 11:17 am-- Davirro	14-Nov-83 16:45:17-- Saaranzin	16-Jan-84 18:19:56-- Gainey       13-Jul-84 14:37:25-- Gleason	19-Nov-84 15:03:49DIRECTORY  BitBlt USING [    AlignedBBTable, BBptr, BBTable, BBTableSpace, BitAddress, BITBLT],  Environment USING [bitsPerWord],  Exec USING [    AddCommand, CheckForAbort, ExecProc, FreeTokenString,    GetNameandPassword, GetToken, Handle, OutputProc],  FileName USING [AllocVFN, Error, FreeVFN, UnpackFilename, VFN],  FileTransfer USING [    ClientProc, Close, Connection, Create, Destroy, Error,    GetStreamName, MessageProc, ReadNextStream, ReadStream,    SetPrimaryCredentials, SetProcs],  FindOps,  Format USING [LongDecimal, StringProc],  Heap USING [Error, systemZone],  Inline USING [BITAND, BITNOT, BITOR, BITXOR],  MSegment USING [FreeWords, GetWords],  MStream USING [Error, Handle, WriteOnly],  Stream USING [Delete, Handle, PutString],  String USING [    AppendCharAndGrow, AppendStringAndGrow, CopyToNewString, Empty,    Length, Replace],  Token USING [UnterminatedQuote];FindControl: PROGRAM  IMPORTS BitBlt, Exec, FileName, FileTransfer, FindOps, Format, Heap, Inline, MSegment, MStream, Stream, String, Token  EXPORTS FindOps = BEGIN OPEN FindOps;-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ------ Exec command instance data-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----Instance: TYPE = POINTER TO InstanceData;InstanceData: TYPE = RECORD [  exec: Exec.Handle,  results: Format.StringProc,  conn: FileTransfer.Connection ¬ NIL,  token, switch, output, defaultHost, defaultDirectory: LONG STRING ¬ NIL,  outStream: MStream.Handle ¬ NIL,  buffer: LONG POINTER TO Buffer ¬ NIL,  matches, files: LONG CARDINAL ¬ 0,  -- result of first stage of parsing:  keys: KeyPointer ¬ NIL,  ignore: SetOfChars ¬ ALL[FALSE],  -- result of second stage of parsing:  alphabetSize: CARDINAL ¬ TRASH,  mapping: LONG POINTER TO MapArray ¬ NIL,  -- result of last stages of parsing (performed in module FindMatcher):  search: SearchProc ¬ NULL,  free: FreeProc ¬ NIL,  searchData: LONG POINTER ¬ NIL,  terseOutput: BOOLEAN ¬ FALSE];-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ------ Global data-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----Finished: PUBLIC SIGNAL = CODE;ParseError: PUBLIC ERROR [s: STRING, swch: BOOLEAN ¬ FALSE] = CODE;z: UNCOUNTED ZONE = Heap.systemZone;commandLine: LONG STRING ¬ NIL;-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ------ Exec command-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----Finder: Exec.ExecProc = {  say: Format.StringProc = h.OutputProc[];  data: InstanceData ¬ [exec: h, results: h.OutputProc[]];    StreamOut: Format.StringProc = {data.outStream.PutString[s]};    Cleanup: PROC = {    IF data.output # NIL THEN {      IF data.files = 0 THEN data.results["No"L]      ELSE Format.LongDecimal[data.results, data.files];      data.results[IF data.files = 1 THEN " file searched"L ELSE " files searched"L];      data.results[IF outcome = abort THEN "; command aborted\n"L ELSE "\n"L];      IF data.matches = 0 THEN data.results["No"L]      ELSE Format.LongDecimal[data.results, data.matches];      data.results[IF data.matches = 1 THEN " match found\n"L ELSE " matches found\n"L]}    ELSE say["\n"L];    IF data.files = 0 THEN say["No"L]    ELSE Format.LongDecimal[say, data.files];    say[IF data.files = 1 THEN " file searched"L ELSE " files searched"L];    say[IF outcome = abort THEN "; command aborted\n"L ELSE "\n"L];    IF data.matches = 0 THEN say["No"L]    ELSE Format.LongDecimal[say, data.matches];    say[IF data.matches = 1 THEN " match found\n"L ELSE " matches found\n"L];      data.token ¬ Exec.FreeTokenString[data.token];    data.switch ¬ Exec.FreeTokenString[data.switch];    IF data.outStream # NIL THEN {data.outStream.Delete[]; data.outStream ¬ NIL};    IF data.conn # NIL THEN      {data.conn.Close[]; data.conn.Destroy[]; data.conn ¬ NIL};    FreeKeys[];    IF data.buffer # NIL THEN      {MSegment.FreeWords[data.buffer]; data.buffer ¬ NIL};    z.FREE[@data.output];    z.FREE[@data.defaultHost];    z.FREE[@data.defaultDirectory];    IF data.searchData # NIL AND data.free # NIL THEN data.free[data.searchData];    z.FREE[@data.searchData];    z.FREE[@data.mapping];    z.FREE[@commandLine]};  FreeKeys: PROC = {    WHILE data.keys # NIL DO      link: KeyPointer = data.keys.link;      z.FREE[@data.keys];      data.keys ¬ link;      ENDLOOP};  Bitch: PROC [s: STRING, swch, file, warn: BOOLEAN ¬ FALSE] = {    say[IF warn THEN "Warning: "L ELSE "Error: "L];    say[s];    IF swch THEN say[data.switch];    IF file THEN say[data.output];    say["\n"L]};  BEGIN ENABLE {    ParseError => {Bitch[s: s, swch: swch]; GOTO Error};    Heap.Error => {IF type = otherError THEN say[      "Token too large - perhaps an unquoted *!"L]; GOTO Error};     UNWIND => Cleanup[]};  Scanner[@data]; -- leaves first file name in data.token  IF data.keys = NIL THEN {Cleanup[]; RETURN Helper[h]};  Equivalence[@data];  [data.search, data.free, data.searchData] ¬ ChooseMatcher[    data.keys, @data.ignore, data.alphabetSize];  FreeKeys[];  IF data.output # NIL THEN {    data.outStream ¬ MStream.WriteOnly[data.output, [], text      ! MStream.Error => CONTINUE];    IF data.outStream = NIL THEN {      Bitch[s: "Cannot acquire file "L, file: TRUE];      GOTO Error};    data.results ¬ StreamOut;    data.results[commandLine]; data.results["...\n"L]};    data.conn ¬ FileTransfer.Create[];  data.conn.SetProcs[clientData: @data, messages: PutMessages, login: LoginUser];  data.buffer ¬ MSegment.GetWords[SIZE[Buffer]];  outcome ¬ normal;  DO    IF ~String.Empty[data.switch] THEN SELECT data.switch[0] FROM      'h, 'H => String.Replace[to: @data.defaultHost, from: data.token, z: z];      'd, 'D => String.Replace[to: @data.defaultDirectory, from: data.token, z: z];      ENDCASE => ParseError["Bogus switch: /"L, TRUE]    ELSE IF String.Empty[data.token] THEN EXIT    ELSE IF h.CheckForAbort[] OR SearchFile[@data      ! FileTransfer.Error => {say[SELECT code FROM          retry => "...connection timed out!\n",	  notFound => "...file not found!\n",	  ENDCASE => "...unknown FileTransfer problem!\n"L];	  GOTO Error};	FileName.Error => {say["...Bad file name syntax!\n"L];	  GOTO Error}]      THEN {outcome ¬ abort; EXIT};    data.switch ¬ Exec.FreeTokenString[data.switch];    data.token ¬ Exec.FreeTokenString[data.token];    [data.token, data.switch] ¬ h.GetToken[];    ENDLOOP;  Cleanup[];  EXITS Error => {Cleanup[]; outcome ¬ error}  END};Helper: Exec.ExecProc = {  h.OutputProc[]["Command format:	Find.~ pattern1/switch ... patternN/switch file1/switch ... fileM/switchThe following switches apply only to patterns (case of switches is ignored):	/C	specifies a key in which case of letters is ignored	/~C	specifies a key in which case is significant (the default)	/I	specifies a set of characters to be ignored throughout the input files	/O	specifies that this pattern is actually the name of an output fileAfter the first key, a string lacking any of the above switches is assumed to be the first file name.  Therefore, if there is more than one key, all but the first must have either /C or /~C.  The following switches apply only to file names:	/H	specifies a default host for subsequent file names	/D	specifies a default directoryIf the accompanying string is empty, no default is applied to subsequent file names.	/T	terse outputWithin a pattern, the following mappings apply.  All but the last also apply within the /I option string.	[xyz]		any of the characters x, y, and z (or X or Y or Z, if /c)	#		any single character	|		any white space character (CR, LF, tab, space, formfeed)	~x		any character except x (x can be [xyz] or | or whatever)	=x		the character x (used to quote these special chars; can also			be used to quote a letter to enforce case in a /c pattern)	\\n, \\t, etc.	CR, tab, etc., as introduced in Mesa 10.0	x*		any number (including zero) of repetitions of x (x can			be [xyz] or ~| or whatever)Note that # and * must be preceded by apostrophes to get them past the Executive; likewise, if you want white-space or slashes in a pattern or a file name, you'll have to put the whole pattern inside double-quotes.  E.g., to search for \"any number of #-signs and spaces enclosed in brackets\", you'd have to say:  Find.~ \"=[[ ='#]'*]\""L]};-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ------ First stage of parsing: scanner-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----SetOfCharsBBptr: PROC [sp: POINTER TO BitBlt.BBTableSpace]    RETURNS [bbPtr: BitBlt.BBptr] = {  bbPtr ¬ BitBlt.AlignedBBTable[sp];  bbPtr­ ¬ [    dst: [word: NIL, bit: 0],    dstBpl: SIZE[SetOfChars] * Environment.bitsPerWord,    src: [word: NIL, bit: 0],    srcDesc: [srcBpl [SIZE[SetOfChars] * Environment.bitsPerWord]],    width: SIZE[SetOfChars] * Environment.bitsPerWord,    height: 1]};Scanner: PROC [inst: Instance] = {  bbTable: BitBlt.BBTableSpace;  bbPtr: BitBlt.BBptr = SetOfCharsBBptr[@bbTable];  NoteIgnore: PROC [chars: SetPointer, repeat: BOOLEAN] = {    IF repeat THEN ERROR ParseError["Unquoted * not allowed in /I text"L];    bbPtr.src.word ¬ chars;    Blit[bbPtr]};  bbPtr.dst.word ¬ @inst.ignore;  bbPtr.flags ¬ or;  String.AppendStringAndGrow[@commandLine, "Find"L, z, 40];  DO    [inst.token, inst.switch] ¬ inst.exec.GetToken[      ! Token.UnterminatedQuote => ERROR ParseError["Mismatched quotes"L]];    String.AppendCharAndGrow[@commandLine, ' , z];    IF inst.token # NIL THEN      String.AppendStringAndGrow[@commandLine, inst.token, z, 40];    IF ~String.Empty[inst.switch] THEN {      String.AppendCharAndGrow[@commandLine, '/, z];       String.AppendStringAndGrow[@commandLine, inst.switch, z, 40];      SELECT inst.switch[0] FROM      't, 'T => {inst.terseOutput ¬ TRUE;         inst.keys ¬ ParseKey[inst.token, inst.keys, FALSE]};      'o, 'O => String.Replace[@inst.output, inst.token, z];      'i, 'I =>        IF ~String.Empty[inst.token] THEN          ParseString[inst.token, NoteIgnore, FALSE];      '~, '- =>        IF inst.switch.length > 1 AND	    (SELECT inst.switch[1] FROM 'c, 'C => TRUE, ENDCASE => FALSE)	  THEN inst.keys ¬ ParseKey[inst.token, inst.keys, FALSE]	  ELSE ERROR ParseError["Bogus switch: /"L, TRUE];      'c, 'C => inst.keys ¬ ParseKey[inst.token, inst.keys, TRUE];      ENDCASE => EXIT}    ELSE IF String.Empty[inst.token] OR inst.keys # NIL THEN EXIT    ELSE inst.keys ¬ ParseKey[inst.token, inst.keys, FALSE];    inst.token ¬ Exec.FreeTokenString[inst.token];    inst.switch ¬ Exec.FreeTokenString[inst.switch];    ENDLOOP;  bbPtr.src.word ¬ @inst.ignore;  bbPtr.flags ¬ andc;  FOR key: KeyPointer ¬ inst.keys, key.link UNTIL key = NIL DO    FOR c: CARDINAL IN [0..key.length) DO -- remove /I chars from all keys      bbPtr.dst.word ¬ @key.key[c].chars;      Blit[bbPtr];      ENDLOOP;    ENDLOOP};ParseKey: PROC [s: LONG STRING, rest: KeyPointer, ignoreCase: BOOLEAN]    RETURNS [KeyPointer] = {  new: KeyPointer ¬ z.NEW[Key[String.Length[s]] ¬ [length: 0,    link: rest, key:]];    CollectKey: PROC [chars: SetPointer, repeat: BOOLEAN] = {    new[new.length] ¬ [repeat, chars­];    new.length ¬ new.length + 1};      ParseString[s, CollectKey, ignoreCase ! UNWIND => z.FREE[@new]];  IF new[0].repeat OR new[new.length-1].repeat THEN {    z.FREE[@new];    ERROR ParseError["It makes no sense to begin or end a key with a wildcard"L]};  RETURN [new]};ParseString: PROC [s: LONG STRING, CallBack: PROC [SetPointer, BOOLEAN],    ignoreCase: BOOLEAN] = {  pos: CARDINAL ¬ 0;  bbTable: BitBlt.BBTableSpace;  bbPtr: BitBlt.BBptr = SetOfCharsBBptr[@bbTable];    Lop: PROC RETURNS [ch: CHAR] = INLINE {ch ¬ s[pos]; pos ¬ pos + 1};    ParseOne: --recursive-- PROC RETURNS [set: SetOfChars ¬ ALL[FALSE]] = {    ch: CHAR = Lop[];    SELECT ch FROM      '= => -- quoting; just grab next char (if any)	IF pos < s.length THEN set[Lop[]] ¬ TRUE	ELSE ERROR ParseError["Can't end key with ="L];      '\\ => -- shorthand for tricky chars	IF pos < s.length THEN set[SELECT Lop[] FROM	  'n, 'N, 'r, 'R => '\n,	  't, 'T => '\t,	  'b, 'B => '\b,	  'f, 'F => '\f,	  'l, 'L => '\l,	  ENDCASE => s[pos-1]] ¬ TRUE	ELSE ERROR ParseError["Can't end key with \\"L];      '[ => { -- collect set of chars until close-bracket	WHILE pos < s.length AND s[pos] # '] DO	  inner: SetOfChars ¬ ParseOne[];	  bbPtr.dst.word ¬ @set;	  bbPtr.src.word ¬ @inner;	  bbPtr.flags ¬ or;	  Blit[bbPtr];	  ENDLOOP;	IF pos >= s.length THEN ERROR ParseError["Missing closing bracket"L];	IF set = ALL[FALSE] THEN ERROR ParseError[	  "Empty string between brackets can never match anything"L];	[] ¬ Lop[]};      '~ => -- negate whatever charset follows        IF pos < s.length THEN {	  negate: SetOfChars ¬ ParseOne[];	  bbPtr.dst.word ¬ @set;	  bbPtr.src.word ¬ @negate;	  bbPtr.flags ¬ invert;	  Blit[bbPtr];	  IF set = ALL[FALSE] THEN	    ERROR ParseError["~# can never match anything"L]}	ELSE ERROR ParseError["Can't end key with ~"L];      '# => set ¬ ALL[TRUE];      '| => set['\n] ¬ set['\l] ¬ set['\f] ¬ set['\t] ¬ set[40C] ¬ TRUE;      ENDCASE => set[ch] ¬ TRUE;    IF ignoreCase THEN SELECT ch FROM      IN ['a..'z] => set[ch-('a-'A)] ¬ TRUE;      IN ['A..'Z] => set[ch+('a-'A)] ¬ TRUE;      ENDCASE};  IF String.Empty[s] THEN ERROR ParseError["Null key not permitted"L];  IF s[0] = '* THEN ERROR ParseError["Key cannot start with unquoted *"L];  WHILE pos < s.length DO    set: SetOfChars ¬ ParseOne[];    repeat: CHAR ¬ 0C;    WHILE pos < s.length AND s[pos] = '* DO repeat ¬ Lop[] ENDLOOP;    CallBack[@set, repeat = '*];    ENDLOOP};-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ------ Second stage of parsing: equiv classes of chars, for smaller transition tables-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----Equivalence: PROC [inst: Instance] = {  mapTo: CHAR ¬ FIRST[CHAR];  maxUnmapped: CHAR ¬ LAST[CHAR];  unmapped: SetOfChars ¬ ALL[TRUE];  bbTable: BitBlt.BBTableSpace;  bbPtr: BitBlt.BBptr = SetOfCharsBBptr[@bbTable];  inst.mapping ¬ z.NEW[MapArray];  FOR map: CHAR IN CHAR DO    class: SetOfChars;    IF ~unmapped[map] THEN LOOP;    bbPtr.dst.word ¬ @class;    bbPtr.src.word ¬ @unmapped;    bbPtr.flags ¬ copy;    Blit[bbPtr];    bbPtr.src.word ¬ @inst.ignore;    bbPtr.flags ¬ IF inst.ignore[map] THEN and ELSE andc;    Blit[bbPtr];    FOR key: KeyPointer ¬ inst.keys, key.link UNTIL key = NIL DO      FOR c: CARDINAL IN [0..key.length) DO        keyset: SetPointer = @key.key[c].chars;	bbPtr.src.word ¬ keyset;	bbPtr.flags ¬ IF keyset[map] THEN and ELSE andc;	Blit[bbPtr];	ENDLOOP;      ENDLOOP;    FOR ch: CHAR IN [map..maxUnmapped] DO      IF class[ch] THEN inst.mapping[ch] ¬ mapTo      ELSE IF unmapped[ch] THEN maxUnmapped ¬ ch      ENDLOOP;    bbPtr.src.word ¬ @class;    bbPtr.flags ¬ xor;    bbPtr.dst.word ¬ @unmapped;    Blit[bbPtr];    class[mapTo] ¬ ~class[mapTo];    FOR key: KeyPointer ¬ inst.keys, key.link UNTIL key = NIL DO      FOR c: CARDINAL IN [0..key.length) DO        keyset: SetPointer = @key.key[c].chars;	IF keyset[map] THEN {bbPtr.dst.word ¬ keyset; Blit[bbPtr]};	ENDLOOP;      ENDLOOP;    IF inst.ignore[map] THEN {bbPtr.dst.word ¬ @inst.ignore; Blit[bbPtr]};    mapTo ¬ mapTo.SUCC;    ENDLOOP;  inst.alphabetSize ¬ mapTo - FIRST[CHAR]};-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ------ FileTransfer feedback-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----PutMessages: FileTransfer.MessageProc = {  IF level = fatal THEN {    out: Format.StringProc =      LOOPHOLE[clientData, LONG Instance].exec.OutputProc[];    out["*** File error: "L];    IF s1 # NIL THEN out[s1];    IF s2 # NIL THEN out[s2];    IF s3 # NIL THEN out[s3];    IF s4 # NIL THEN out[s4]}};LoginUser: FileTransfer.ClientProc = {  inst: LONG Instance = clientData;  user: STRING = [40];  password: STRING = [40];  inst.exec.GetNameandPassword[user, password];  inst.conn.SetPrimaryCredentials[user: user, password: password]};-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ------ File search-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----SearchFile: PROC [inst: Instance] RETURNS [abort: BOOLEAN ¬ FALSE] = {  vfn: FileName.VFN = FileName.AllocVFN["[]"L];  stream: Stream.Handle ¬ NIL;  matches: LONG CARDINAL ¬ 0;    CheckAbort: PROC RETURNS [BOOLEAN] = {    RETURN inst.exec.CheckForAbort[]};  vfn.host ¬ String.CopyToNewString[inst.defaultHost, z];  vfn.directory ¬ String.CopyToNewString[inst.defaultDirectory, z];  FileName.UnpackFilename[inst.token, vfn];  stream ¬ inst.conn.ReadStream[vfn !    FileTransfer.Error => IF code = skipOperation THEN CONTINUE;    UNWIND => vfn.FreeVFN[]];  WHILE stream # NIL AND ~abort DO    ENABLE UNWIND => {vfn.FreeVFN[]; stream.Delete[]};    stream.options.signalEndOfStream ¬ FALSE;    inst.files ¬ inst.files + 1;    inst.results["*** "L];    inst.results[FileTransfer.GetStreamName[stream]];    IF ~inst.terseOutput THEN inst.results["\n"L];    [abort, matches] ¬ inst.search[      stream, inst.searchData, inst.mapping, inst.buffer,      inst.results, inst.terseOutput, CheckAbort !         Finished => { matches ¬ 1; CONTINUE};         FileTransfer.Error =>        IF code = accessDenied THEN {matches ¬ 0; CONTINUE}];    IF matches = 0 AND inst.terseOutput THEN inst.results["\n"L];    inst.matches ¬ inst.matches + matches;    IF abort OR (abort ¬ inst.exec.CheckForAbort[]) THEN      stream.Delete[]    ELSE stream ¬ FileTransfer.ReadNextStream[stream];    ENDLOOP;  vfn.FreeVFN[]};-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ------ Determine whether microcode supports BitBlt-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----bitbltImplemented: PUBLIC BOOLEAN ¬ FALSE;TestForBitBlt: PROC = {  junk1: CARDINAL ¬ 123456B;  junk2: CARDINAL ¬ 075310B;  shouldBe: CARDINAL ¬ Inline.BITXOR[junk1, junk2];    BEGIN ENABLE ANY => CONTINUE;    sp: BitBlt.BBTableSpace;    bbPtr: BitBlt.BBptr = BitBlt.AlignedBBTable[@sp];    bbPtr­ ¬ [      dst: [word: @junk1, bit: 0], dstBpl: 16,      src: [word: @junk2, bit: 0], srcDesc: [srcBpl [16]],      width: 16, height: 1, flags: xor];    BitBlt.BITBLT[bbPtr];    END;  -- I don't like catching ANY, but InstructionNotImplemented isn't public  bitbltImplemented ¬ (junk1 = shouldBe)};QuickBlit: PUBLIC PROC [bbPtr: BitBlt.BBptr] = {  -- assumes dst/src are word-aligned and width/*Bpl are multiples of bitsPerWord  arg: BitBlt.BBTable ¬ bbPtr­;  arg.width ¬ arg.width / Environment.bitsPerWord;  arg.srcDesc.srcBpl ¬ arg.srcDesc.srcBpl / Environment.bitsPerWord;  arg.dstBpl ¬ arg.dstBpl / Environment.bitsPerWord;  THROUGH [0..arg.height) DO    FOR pos: CARDINAL IN [0..arg.width) DO      src: WORD ¬ (arg.src.word+pos)­;      dst: WORD ¬ (arg.dst.word+pos)­;      IF arg.flags.srcFunc = complement THEN src ¬ Inline.BITNOT[src];      (arg.dst.word+pos)­ ¬ SELECT arg.flags.dstFunc FROM        and => Inline.BITAND[src, dst],	or => Inline.BITOR[src, dst],	xor => Inline.BITXOR[src, dst],	ENDCASE => src;      ENDLOOP;    arg.src.word ¬ arg.src.word + arg.srcDesc.srcBpl;    arg.dst.word ¬ arg.dst.word + arg.dstBpl;    ENDLOOP};SlowBlit: PUBLIC PROC [bbPtr: BitBlt.BBptr] = {  -- assumes nothing, except src is not a gray-pattern & disjoint = TRUE  arg: BitBlt.BBTable ¬ bbPtr­;  THROUGH [0..arg.height) DO    FOR pos: CARDINAL IN [0..arg.width) DO      src: BOOLEAN ¬ ReadBit[arg.src, pos];      dst: BOOLEAN ¬ ReadBit[arg.dst, pos];      IF arg.flags.srcFunc = complement THEN src ¬ ~src;      IF dst # (SELECT arg.flags.dstFunc FROM        and => src AND dst,	or => src OR dst,	xor => src # dst,	ENDCASE => src) THEN ChangeBit[arg.dst, pos];      ENDLOOP;    arg.src.word ¬ arg.src.word +      (arg.src.bit+arg.srcDesc.srcBpl) / Environment.bitsPerWord;    arg.src.bit ¬ (arg.src.bit+arg.srcDesc.srcBpl) MOD Environment.bitsPerWord;    arg.dst.word ¬ arg.dst.word + (arg.dst.bit+arg.dstBpl) / Environment.bitsPerWord;    arg.dst.bit ¬ (arg.dst.bit+arg.dstBpl) MOD Environment.bitsPerWord;    ENDLOOP};ReadBit: PROC [addr: BitBlt.BitAddress, pos: CARDINAL] RETURNS [BOOLEAN] = INLINE {  word: LONG POINTER = addr.word + (addr.bit+pos) / Environment.bitsPerWord;  bit: CARDINAL = (addr.bit+pos) MOD Environment.bitsPerWord;  RETURN[Inline.BITAND[word­, bitmasks[bit]] # 0]};ChangeBit: PROC [addr: BitBlt.BitAddress, pos: CARDINAL] = INLINE {  word: LONG POINTER = addr.word + (addr.bit+pos) / Environment.bitsPerWord;  bit: CARDINAL = (addr.bit+pos) MOD Environment.bitsPerWord;  word­ ¬ Inline.BITXOR[word­, bitmasks[bit]]};bitmasks: ARRAY [0..Environment.bitsPerWord) OF UNSPECIFIED = [  100000B, 40000B, 20000B, 10000B, 4000B, 2000B, 1000B, 400B, 200B, 100B,  40B, 20B, 10B, 4B, 2B, 1B];-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ------ Main program-- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----Exec.AddCommand["Find2.~", Finder, Helper];TestForBitBlt[];END.
-- Copyright (C) 1983, 1985  by Xerox Corporation. All rights reserved. -- BitSW.mesa, last edited by:-- AXD    ,	25-May-83 12:26:50<< Basic bitmap-backed subwindow;  client owns bitmap. >>DIRECTORY  BitBlt: TYPE USING [BitAddress, BitBltFlags, DstFunc],  Display: TYPE USING [BreakReason, Brick, fiftyPercent, infinity],  Environment: TYPE USING [Block],  Scrollbar: TYPE USING [ScrollProcType],  Tool: TYPE USING [SWType],  Window: TYPE USING [Box, BoxHandle, Handle, Place, Validate],  WindowFont: TYPE USING [Handle];BitSW: DEFINITIONS IMPORTS Display, Window =  BEGIN  Handle: TYPE = Window.Handle;    Type: PROC RETURNS [Tool.SWType];  Options: TYPE = RECORD [    vertScrollbar, horizScrollbar: BOOLEAN ¬ FALSE, magnification: INTEGER ¬ 1];  -- Basic Procedures  Create: PROC [    sw: Handle, base: BitBlt.BitAddress, bpl: CARDINAL,     frame: Window.Box, options: Options ¬ Options[]];  Destroy: PROC [Handle];    Redisplay: PROC [Handle];    IsIt: PROC [sw: Handle] RETURNS [yes: BOOLEAN];  Sleep: PROC [Handle];  Wakeup: PROC [Handle];    -- Information/Alteration routines    dontChangeBpl: CARDINAL = 0;    GetBitmap: PROC [Handle] RETURNS [base: BitBlt.BitAddress, bpl: CARDINAL];  SetBitmap: PROC [    sw: Handle, base: BitBlt.BitAddress, bpl: CARDINAL ¬ dontChangeBpl]    RETURNS [oldBase: BitBlt.BitAddress, oldBpl: CARDINAL];  GetFrame: PROC [Handle] RETURNS [Window.Box];   SetFrame: PROC [sw: Handle, new: Window.Box] RETURNS [old: Window.Box];    GetMagnification: PROC [Handle] RETURNS [INTEGER];  SetMagnification: PROC [sw: Handle, new: INTEGER]    RETURNS [old: INTEGER];  -- newMag = 0 just returns current magnification  GetOptions: PROC [Handle] RETURNS [Options];  SetOptions: PROC [sw: Handle, new: Options] RETURNS [old: Options];    -- Scrolling  ScrollVertical, ScrollHorizontal: Scrollbar.ScrollProcType;  NormalizeUpperLeft, NormalizeLowerRight: PROC [Handle];  CenterPlace: PROC [sw: Handle, place: Window.Place];    JumpTo: PROC [sw: Handle, place: Window.Place] = INLINE {    [] ¬ SetFrame[sw, [place, GetFrame[sw].dims]];    sw.Validate};      -- Point and Box Utilities  BoxFromCorners: PROC [a, b: Window.Place] RETURNS [Window.Box] = INLINE {    SwapIntegers: PRIVATE TYPE = RECORD [INTEGER, INTEGER];    IF a.x > b.x THEN [a.x, b.x] ¬ SwapIntegers[b.x, a.x];    IF a.y > b.y THEN [a.y, b.y] ¬ SwapIntegers[b.y, a.y];    RETURN[[a, LOOPHOLE[VSub[b, a]]]]};  Corner: PROC [box: Window.Box] RETURNS [Window.Place] = INLINE {    RETURN[[box.place.x + box.dims.w, box.place.y + box.dims.h]]};  InBox: PROC [p: Window.Place, box: Window.Box] RETURNS [BOOLEAN] = INLINE {    RETURN[      p.x IN [box.place.x..box.place.x + box.dims.w)        AND p.y IN [box.place.y..box.place.y + box.dims.h)]};  NormalizeBox: PROC [box: Window.Box] RETURNS [Window.Box] = INLINE {    RETURN BoxFromCorners[box.place, Corner[box]]};  SDiv: PROC [v: Window.Place, s: INTEGER] RETURNS [Window.Place] = INLINE {    RETURN[[v.x/s, v.y/s]]};  SMul: PROC [v: Window.Place, s: INTEGER] RETURNS [Window.Place] = INLINE {    RETURN[[v.x*s, v.y*s]]};  VAdd: PROC [a, b: Window.Place] RETURNS [Window.Place] = INLINE {    RETURN[[a.x + b.x, a.y + b.y]]};  VSub: PROC [a, b: Window.Place] RETURNS [Window.Place] = INLINE {    RETURN[[a.x - b.x, a.y - b.y]]};  -- BITBLT support  PlaceToBitAddress: PROC [w: Window.Handle, p: Window.Place]    RETURNS [BitBlt.BitAddress];  -- Errors  Error: ERROR [window: Window.Handle, code: ErrorCode];  ErrorCode: TYPE = {    invalidParameters, illegalPlace, notABitSW, notImplemented, unknown};    -- Painting    Color: TYPE = <<Display.Color>> {black, white, invert};    Line: PROC [    window: Handle, start, stop: Window.Place, color: Color ¬ black,    thickness: CARDINAL ¬ 1, bounds: Window.BoxHandle ¬ NIL];    CircleType: TYPE = {even, upLeft, upRight, downLeft, downRight};      Arc: PROC [    window: Handle, place: Window.Place, radius: INTEGER,     startSector, stopSector: CARDINAL, start, stop: Window.Place,     circleType: CircleType ¬ even, thickness: CARDINAL ¬ 1,    color: Color ¬ black, bounds: Window.BoxHandle ¬ NIL];    Circle: PROC [    window: Handle, place: Window.Place, radius: INTEGER,    circleType: CircleType ¬ even, thickness: CARDINAL ¬ 1,    color: Color ¬ black, bounds: Window.BoxHandle ¬ NIL];    Ellipse: PROC [    window: Handle, center: Window.Place, xRadius, yRadius: INTEGER,    thickness: CARDINAL ¬ 1, color: Color ¬ black,    bounds: Window.BoxHandle ¬ NIL];    Conic: PROC [    window: Handle, a, b, c, d, e, errorTerm: LONG INTEGER,     start, stop, origin: Window.Place, sharpCornered: BOOLEAN,    thickness: CARDINAL ¬ 1, color: Color ¬ black,    bounds: Window.BoxHandle ¬ NIL];    paintFlags: BitBlt.BitBltFlags = [    direction: forward, disjoint: TRUE, disjointItems: TRUE, gray: FALSE,    srcFunc: null, dstFunc: or];      Bitmap: PROC [    window: Handle, box: Window.Box, address: BitBlt.BitAddress, bpl: CARDINAL,    flags: BitBlt.BitBltFlags ¬ paintFlags];    White: PROC [window: Handle, box: Window.Box];  Black: PROC [window: Handle, box: Window.Box];  Invert: PROC [window: Handle, box: Window.Box];      Gray: PROC [    window: Handle, box: Window.Box, gray: Display.Brick ¬ Display.fiftyPercent,    dstFunc: BitBlt.DstFunc ¬ null];      Point: PROC [window: Handle, point: Window.Place, color: Color ¬ black];     textFlags: BitBlt.BitBltFlags = [    direction: forward, disjoint: TRUE, disjointItems: TRUE, gray: FALSE,    srcFunc: null, dstFunc: or];  Block: PROC [    window: Handle, block: Environment.Block,    lineLength: INTEGER ¬ Display.infinity,     place: Window.Place, font: WindowFont.Handle ¬ NIL,    flags: BitBlt.BitBltFlags ¬ textFlags, bounds: Window.BoxHandle ¬ NIL]    RETURNS [newPlace: Window.Place, positions: CARDINAL,      why: Display.BreakReason];      Character: PROC [    window: Handle, char: CHARACTER, place: Window.Place,    font: WindowFont.Handle ¬ NIL, flags: BitBlt.BitBltFlags ¬ textFlags,    bounds: Window.BoxHandle ¬ NIL]    RETURNS [Window.Place];    Text: PROC [    window: Handle, string: LONG STRING, place: Window.Place,    font: WindowFont.Handle ¬ NIL, lineLength: INTEGER ¬ Display.infinity,     flags: BitBlt.BitBltFlags ¬ textFlags, bounds: Window.BoxHandle ¬ NIL]    RETURNS [newPlace: Window.Place];      END.  
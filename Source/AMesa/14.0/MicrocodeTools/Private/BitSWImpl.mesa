-- Copyright (C) 1984, 1985  by Xerox Corporation. All rights reserved. -- BitSWImpl.mesa, last edited by:-- AXD    ,	20-Jan-84 13:08:42DIRECTORY  BitBlt: TYPE USING [BitAddress, BitBltFlags, DstFunc],  BitSW: TYPE USING [    CircleType, Color, dontChangeBpl, ErrorCode, GetFrame, Handle, JumpTo,    Options, SDiv, SetFrame, VSub],  Context: TYPE USING [    Create, Destroy, Find, SimpleDestroyProc, Type, UniqueType],  Display: TYPE USING [    BitAddress, BitBltFlags, Bitmap, BreakReason, Brick, replaceFlags, White],  DisplayInternal: TYPE USING [SpArc, SpecialCircle, SpecialConic],  Environment: TYPE USING [Block],  Heap: TYPE USING [systemZone],  Inline: TYPE USING [LongMult, LowHalf],  Scrollbar: TYPE USING [    Create, Destroy, Percent, ScrollbarProcType, ScrollProcType, Type],  SpecialDisplay: TYPE USING [    LineStyle, LineStyleObject, solid, SpBitmap, SpBlack, SpBlock, SpCharacter,    SpecialContext, SpecialLine, SpEllipse, SpGray, SpInvert, SpPoint, SpWhite],  Tool: TYPE USING [RegisterSWType, SWType],  Window: TYPE USING [    Box, BoxHandle, Dims, GetBox, Handle, InitializeWindow, InvalidateBox,    Object, Place, SetClearingRequired, SetDisplayProc, SlideAndSize, Validate],  WindowFont: TYPE USING [Handle],  WindowOps: TYPE USING [Object];  BitSWImpl: MONITOR LOCKS bsw USING bsw: BSWContext  IMPORTS    BitSW, Context, Display, DisplayInternal, Heap, Inline, Scrollbar,    Sp: SpecialDisplay, Tool, Window  EXPORTS BitSW =  BEGIN  Handle: TYPE = BitSW.Handle;    type: Tool.SWType = Tool.RegisterSWType[sleep: Sleep, wakeup: Wakeup];  contextType: Context.Type = Context.UniqueType[];    Error: PUBLIC ERROR [window: Window.Handle, code: BitSW.ErrorCode] = CODE;  BSWContext: TYPE = LONG POINTER TO BSWRecord;  BSWRecord: TYPE = MONITORED RECORD [    sw: Window.Handle, base: BitBlt.BitAddress,    frame: Window.Box, emptyFrame: BOOLEAN, options: BitSW.Options,    special: Sp.SpecialContext, specialWindow: Window.Object ¬ TRASH];    Box: PROC [sw: Handle] RETURNS [Window.Box] = INLINE {    RETURN[[[0, 0], sw.GetBox.dims]]};    LOP: PROC [LONG POINTER] RETURNS [LONG ORDERED POINTER] = MACHINE CODE {};    -- Basic Procedures    LocalFind: PROC [sw: Window.Handle] RETURNS [bsw: BSWContext] = INLINE {    bsw ¬ Context.Find[contextType, sw];    IF bsw = NIL THEN ERROR Error[sw, notABitSW]};      Create: PUBLIC PROC [    sw: Handle, base: BitBlt.BitAddress, bpl: CARDINAL, frame: Window.Box,    options: BitSW.Options] = {    IF bpl MOD 16 # 0 THEN ERROR Error[sw, invalidParameters];    BEGIN      bsw: BSWContext = Heap.systemZone.NEW[        BSWRecord ¬ [          sw: sw, base: base, frame: frame, options: options,	  emptyFrame: INTEGER[frame.dims.w] <= 0 OR INTEGER[frame.dims.h] <= 0,	  special: [	    bmAddress: LOP[base.word], wpl: bpl/16, bpl: bpl, alloc: NIL,	    free: NIL]]];      (@bsw.specialWindow).InitializeWindow[        display: NIL, box: [[base.bit, 0], frame.dims], parent: NIL,        clearingRequired: FALSE];      -- STARTKLUDGE      LOOPHOLE[bsw.specialWindow, WindowOps.Object].inTree ¬ TRUE;      -- ENDKLUDGE      [] ¬ sw.SetDisplayProc[Redisplay];      [] ¬ sw.SetClearingRequired[FALSE];      IF options.vertScrollbar THEN        Scrollbar.Create[sw, vertical, ScrollVertical, VerticalScrollbar];      IF options.horizScrollbar THEN        Scrollbar.Create[sw, horizontal, ScrollHorizontal, HorizontalScrollbar];      sw.InvalidateBox[Box[sw], isClear];      Context.Create[        type: contextType, data: bsw, proc: Context.SimpleDestroyProc,        window: sw];      END};      Destroy: PUBLIC PROC [sw: Handle] = {    LockedDestroy: ENTRY PROC [bsw: BSWContext] = INLINE {      ENABLE UNWIND => NULL;      -- don't need to do anything to specialWindow since it can have      -- neither an invalid list nor a bad phosphor list.      [] ¬ sw.SetDisplayProc[NIL];      [] ¬ sw.SetClearingRequired[TRUE];      sw.InvalidateBox[Box[sw], isDirty]};    LockedDestroy[LocalFind[sw]];    Context.Destroy[contextType, sw]};    Redisplay: PUBLIC PROC [sw: Handle] = {    LockedDisplay: ENTRY PROC [bsw: BSWContext] = {      ENABLE UNWIND => NULL;      dims: Window.Dims = sw.GetBox.dims;      tempD, tempP: INTEGER;      IF bsw.base.word = NIL OR bsw.emptyFrame THEN {        Display.White[sw, [[0, 0], dims]]; RETURN};      -- do it this way to avoid white flashes...      Display.Bitmap[        window: sw, box: bsw.frame, address: bsw.base,	bitmapBitWidth: bsw.special.bpl, flags: Display.replaceFlags];      IF bsw.frame.place.y > 0 THEN        Display.White[sw, [[0, 0], [dims.w, bsw.frame.place.y]]];      IF bsw.frame.place.x > 0 THEN        Display.White[sw, [[0, 0], [bsw.frame.place.x, dims.h]]];      IF (tempD ¬ dims.w - (        tempP ¬ bsw.frame.place.x + bsw.frame.dims.w)) > 0 THEN        Display.White[sw, [[tempP, 0], [tempD, dims.h]]];      IF (tempD ¬ dims.h - (        tempP ¬ bsw.frame.place.y + bsw.frame.dims.h)) > 0 THEN        Display.White[sw, [[0, tempP], [dims.w, tempD]]]};    LockedDisplay[LocalFind[sw]]};    IsIt: PUBLIC PROC [sw: Handle] RETURNS [yes: BOOLEAN] = {    RETURN [Context.Find[contextType, sw] # NIL]};  Sleep: PUBLIC PROC [Handle] = {NULL};    Type: PUBLIC PROC RETURNS [Tool.SWType] = {RETURN[type]};  Wakeup: PUBLIC PROC [Handle] = {NULL};    -- Information/Alteration routines    GetBitmap: PUBLIC PROC [sw: Handle]    RETURNS [base: BitBlt.BitAddress, bpl: CARDINAL] = {    bsw: BSWContext = LocalFind[sw];    RETURN[bsw.base, bsw.special.bpl]};      SetBitmap: PUBLIC PROC [    sw: Handle, base: BitBlt.BitAddress, bpl: CARDINAL]    RETURNS [oldBase: BitBlt.BitAddress, oldBpl: CARDINAL] = {    LockedSetBitmap: ENTRY PROC [bsw: BSWContext]      RETURNS [oldBase: BitBlt.BitAddress, oldBpl: CARDINAL] = {      ENABLE UNWIND => NULL;      oldBase ¬ bsw.base; -- figure out how to write extractor...      oldBpl ¬ bsw.special.bpl;      bsw.base ¬ base;      (@bsw.specialWindow).SlideAndSize[        [[base.bit, 0], (@bsw.specialWindow).GetBox.dims]];      bsw.special.bmAddress ¬ LOP[base.word];      IF bpl # BitSW.dontChangeBpl THEN {        bsw.special.bpl ¬ bpl;	bsw.special.wpl ¬ bpl/16};      sw.InvalidateBox[Box[sw]]};    IF bpl MOD 16 # 0 THEN ERROR Error[sw, invalidParameters]; -- dontChageBpl = 0    RETURN LockedSetBitmap[LocalFind[sw]]};  GetFrame: PUBLIC PROC [sw: Handle] RETURNS [Window.Box] = {    bsw: BSWContext = LocalFind[sw];    RETURN[bsw.frame]};    SetFrame: PUBLIC PROC [sw: Handle, new: Window.Box]    RETURNS [old: Window.Box] = {    LockedSetFrame: ENTRY PROC [bsw: BSWContext] RETURNS [old: Window.Box] = {      ENABLE UNWIND => NULL;      old ¬ bsw.frame;      bsw.frame ¬ new;      (@bsw.specialWindow).SlideAndSize[        [(@bsw.specialWindow).GetBox.place, new.dims]];      bsw.emptyFrame ¬ INTEGER[new.dims.w] <= 0 OR INTEGER[new.dims.h] <= 0};    RETURN LockedSetFrame[LocalFind[sw]]};    GetMagnification: PUBLIC PROC [sw: Handle] RETURNS [INTEGER] = {    bsw: BSWContext = LocalFind[sw];    RETURN[bsw.options.magnification]};      SetMagnification: PUBLIC PROC [sw: Handle, new: INTEGER]    RETURNS [old: INTEGER] = {ERROR Error[sw, notImplemented]};  GetOptions: PUBLIC PROC [sw: Handle] RETURNS [BitSW.Options] = {    bsw: BSWContext = LocalFind[sw];    RETURN[bsw.options]};    SetOptions: PUBLIC PROC [sw: Handle, new: BitSW.Options]    RETURNS [old: BitSW.Options] = {    LockedSetOptions: ENTRY PROC [bsw: BSWContext]       RETURNS [old: BitSW.Options] = {      ENABLE UNWIND => NULL;      old ¬ bsw.options;      IF new.magnification # BitSW.Options[].magnification THEN        ERROR Error[sw, notImplemented];      bsw.options ¬ new;      IF new.vertScrollbar # old.vertScrollbar THEN        IF old.vertScrollbar THEN Scrollbar.Destroy[sw, vertical]	ELSE Scrollbar.Create[sw, vertical, ScrollVertical, VerticalScrollbar];      IF new.horizScrollbar # old.horizScrollbar THEN        IF old.horizScrollbar THEN Scrollbar.Destroy[sw, horizontal]	ELSE Scrollbar.Create[	  sw, horizontal, ScrollHorizontal, HorizontalScrollbar]};    RETURN LockedSetOptions[LocalFind[sw]]};    -- Scrolling  FindPercent: PROC [num, den: INTEGER] RETURNS [Scrollbar.Percent] = INLINE {    RETURN[Inline.LowHalf[Inline.LongMult[100, num]/den]]};  PercentOf: PROC [val: INTEGER, percent: Scrollbar.Percent] RETURNS [INTEGER] =    INLINE {RETURN[Inline.LowHalf[Inline.LongMult[percent, val]/100]]};  HorizontalScrollbar: Scrollbar.ScrollbarProcType = {    LockedHScrollbar: ENTRY PROC [bsw: BSWContext]      RETURNS [        box: Window.Box, offset: Scrollbar.Percent,	portion: Scrollbar.Percent] = {      ENABLE UNWIND => NULL;      windowDims: Window.Dims = window.GetBox.dims;      rightEdge: INTEGER ¬ bsw.frame.place.x + bsw.frame.dims.w;      -- figure out the scrollbar box      box.dims ¬ [        IF windowDims.w > 16 THEN windowDims.w - 8        ELSE windowDims.w, MIN[16, windowDims.h]];      box.place ¬ [(windowDims.w - box.dims.w)/2, 0];      -- now figure out how much is showing      offset ¬ 0;      IF bsw.frame.place.x < 0 THEN        offset ¬ MIN[100, FindPercent[-bsw.frame.place.x, bsw.frame.dims.w]];      IF rightEdge < windowDims.w THEN portion ¬ 100 - offset      ELSE        portion ¬ FindPercent[          windowDims.w - MAX[0, bsw.frame.place.x], bsw.frame.dims.w]};    RETURN LockedHScrollbar[LocalFind[window]]};  ScrollHorizontal: PUBLIC Scrollbar.ScrollProcType = {    LockedScrollH: ENTRY PROC [bsw: BSWContext] RETURNS [BOOLEAN] = {      ENABLE UNWIND => NULL;      dims: Window.Dims = window.GetBox.dims;      newX: INTEGER ¬        SELECT direction FROM          relative => -PercentOf[bsw.frame.dims.w, percent],          forward => bsw.frame.place.x - PercentOf[dims.w, percent],          backward => bsw.frame.place.x + PercentOf[dims.w, percent],          ENDCASE => ERROR;      -- coerce newX into [-bsw.frame.dims.w, box.dims.w]      newX ¬ MIN[dims.w, MAX[-bsw.frame.dims.w, newX]];      IF newX = bsw.frame.place.x THEN RETURN[FALSE];      bsw.frame.place.x ¬ newX;      window.InvalidateBox[Box[window], isClear];      RETURN[TRUE]};    IF LockedScrollH[LocalFind[window]] THEN window.Validate};  VerticalScrollbar: Scrollbar.ScrollbarProcType = {    LockedVScrollbar: ENTRY PROC [bsw: BSWContext]      RETURNS [        box: Window.Box, offset: Scrollbar.Percent,	portion: Scrollbar.Percent] = {      ENABLE UNWIND => NULL;      windowDims: Window.Dims = window.GetBox.dims;      bottomEdge: INTEGER ¬ bsw.frame.place.y + bsw.frame.dims.h;      -- figure out the scrollbar box      box.dims ¬ [        MIN[16, windowDims.w],        IF windowDims.h > 16 THEN windowDims.h - 8        ELSE windowDims.h];      box.place ¬ [0, (windowDims.h - box.dims.h)/2];      -- now figure out how much is showing      offset ¬ 0;      IF bsw.frame.place.y < 0 THEN        offset ¬ MIN[100, FindPercent[-bsw.frame.place.y, bsw.frame.dims.h]];      IF bottomEdge < windowDims.h THEN portion ¬ 100 - offset      ELSE        portion ¬ FindPercent[          windowDims.h - MAX[0, bsw.frame.place.y], bsw.frame.dims.h]};    RETURN LockedVScrollbar[LocalFind[window]]};  ScrollVertical: PUBLIC Scrollbar.ScrollProcType = {    LockedScrollV: ENTRY PROC [bsw: BSWContext] RETURNS [BOOLEAN] = {      ENABLE UNWIND => NULL;      dims: Window.Dims = window.GetBox.dims;      newY: INTEGER ¬        SELECT direction FROM          relative => -PercentOf[bsw.frame.dims.h, percent],          forward => bsw.frame.place.y - PercentOf[dims.h, percent],          backward => bsw.frame.place.y + PercentOf[dims.h, percent],          ENDCASE => ERROR;      -- coerce newY into [-bsw.frame.dims.h, box.dims.h]      newY ¬ MIN[dims.h, MAX[-bsw.frame.dims.h, newY]];      IF newY = bsw.frame.place.y THEN RETURN[FALSE];      bsw.frame.place.y ¬ newY;      window.InvalidateBox[Box[window], isClear];      RETURN[TRUE]};    IF LockedScrollV[LocalFind[window]] THEN window.Validate};  NormalizeUpperLeft: PUBLIC PROC [sw: Handle] = {BitSW.JumpTo[sw, [0, 0]]};    NormalizeLowerRight: PUBLIC PROC [sw: Handle] = {    LockedLowerRight: ENTRY PROC [bsw: BSWContext] RETURNS [BOOLEAN] = {      OPEN BitSW;      ENABLE UNWIND => NULL;      newPlace: Window.Place = VSub[        VSub[LOOPHOLE[sw.GetBox.dims], LOOPHOLE[bsw.frame.dims]], [1, 1]];      IF newPlace = bsw.frame.place THEN RETURN[FALSE];      bsw.frame.place ¬ newPlace;      sw.InvalidateBox[Box[sw], isClear];      RETURN[TRUE]};    IF LockedLowerRight[LocalFind[sw]] THEN sw.Validate};      CenterPlace: PUBLIC PROC [sw: Handle, place: Window.Place] = {    LockedCenter: ENTRY PROC [bsw: BSWContext] RETURNS [BOOLEAN] = {      OPEN BitSW;      ENABLE UNWIND => NULL;      newOrigin: Window.Place = VSub[SDiv[LOOPHOLE[sw.GetBox.dims], 2], place];      IF newOrigin = bsw.frame.place THEN RETURN[FALSE];      bsw.frame.place ¬ newOrigin;      sw.InvalidateBox[Box[sw], isClear];      RETURN[TRUE]};    IF LockedCenter[LocalFind[sw]] THEN sw.Validate};    WindowToBitmap: PROC [sw: Window.Handle, bmp: Window.Place]    RETURNS [Window.Place] = INLINE {    OPEN BitSW; RETURN VSub[bmp, LocalFind[sw].frame.place]};  PlaceToBitAddress: PUBLIC PROC [w: Window.Handle, p: Window.Place]    RETURNS [BitBlt.BitAddress] = {ERROR Error[w, notImplemented]};  -- Graphics    DestFlags: PROC [dstFunc: BitBlt.DstFunc, gray: BOOLEAN]    RETURNS [BitBlt.BitBltFlags] = INLINE {    RETURN[[      direction: forward, disjoint: TRUE, disjointItems: TRUE,      gray: gray, srcFunc: null, dstFunc: dstFunc]]};        FlagsForColor: PROC [color: BitSW.Color] RETURNS [BitBlt.BitBltFlags] = INLINE {    -- inverse of DisplayOps.Shade    RETURN[[      direction: forward, disjoint: TRUE, disjointItems: TRUE,      gray: FALSE, srcFunc: null,      dstFunc: SELECT color FROM invert => xor, black => or, ENDCASE => null]]};        LS: PROC [ls: Sp.LineStyle, thickness: CARDINAL] RETURNS [Sp.LineStyle] =    INLINE {    ls­ ¬ [widths: Sp.solid.widths, thickness: thickness]; RETURN[ls]};      Arc: PUBLIC PROC [    window: Handle, place: Window.Place, radius: INTEGER,     startSector, stopSector: CARDINAL, start, stop: Window.Place,     circleType: BitSW.CircleType, thickness: CARDINAL,    color: BitSW.Color, bounds: Window.BoxHandle] = {    ArcLocked: ENTRY PROC [bsw: BSWContext] = {      ENABLE UNWIND => NULL;      ls: Sp.LineStyleObject ¬ TRASH;      DisplayInternal.SpArc[        @bsw.specialWindow, place, radius, startSector, stopSector, start,	stop, bounds, LS[@ls, thickness], FlagsForColor[color], @bsw.special]};    ArcLocked[LocalFind[window]]};    Bitmap: PUBLIC PROC [    window: Handle, box: Window.Box, address: BitBlt.BitAddress, bpl: CARDINAL,    flags: BitBlt.BitBltFlags] = {    BitmapLocked: ENTRY PROC [bsw: BSWContext] = INLINE {      ENABLE UNWIND => NULL;      Sp.SpBitmap[@bsw.specialWindow, box, address, bpl, flags, @bsw.special]};    BitmapLocked[LocalFind[window]]};    Black: PUBLIC PROC [window: Handle, box: Window.Box] = {    BlackLocked: ENTRY PROC [bsw: BSWContext] = INLINE {      ENABLE UNWIND => NULL; Sp.SpBlack[@bsw.specialWindow, box, @bsw.special]};    BlackLocked[LocalFind[window]]};  Block: PUBLIC PROC [    window: Handle, block: Environment.Block,    lineLength: INTEGER, place: Window.Place, font: WindowFont.Handle,    flags: BitBlt.BitBltFlags, bounds: Window.BoxHandle]    RETURNS [newPlace: Window.Place, positions: CARDINAL,      why: Display.BreakReason] = {    BlockLocked: ENTRY PROC [bsw: BSWContext] RETURNS [      newPlace: Window.Place, positions: CARDINAL, why: Display.BreakReason] =       INLINE {      ENABLE UNWIND => NULL;      RETURN Sp.SpBlock[        @bsw.specialWindow, block, lineLength, place, font, flags, bounds,        @bsw.special]};    RETURN BlockLocked[LocalFind[window]]};      Character: PUBLIC PROC [    window: Handle, char: CHARACTER, place: Window.Place,    font: WindowFont.Handle, flags: BitBlt.BitBltFlags, bounds: Window.BoxHandle]    RETURNS [Window.Place] = {    CharacterLocked: ENTRY PROC [bsw: BSWContext]      RETURNS [Window.Place] = INLINE {      ENABLE UNWIND => NULL;      RETURN Sp.SpCharacter[        @bsw.specialWindow, char, place, font, flags, bounds, @bsw.special]};    RETURN CharacterLocked[LocalFind[window]]};    Circle: PUBLIC PROC [    window: Handle, place: Window.Place, radius: INTEGER,    circleType: BitSW.CircleType, thickness: CARDINAL,    color: BitSW.Color, bounds: Window.BoxHandle] = {    CircleLocked: ENTRY PROC [bsw: BSWContext] = INLINE {      ENABLE UNWIND => NULL;      ls: Sp.LineStyleObject ¬ TRASH;      DisplayInternal.SpecialCircle[        @bsw.specialWindow, place, radius, ALL[FALSE], bounds,	LS[@ls, thickness], FlagsForColor[color], @bsw.special]};    CircleLocked[LocalFind[window]]};    Conic: PUBLIC PROC [    window: Handle, a, b, c, d, e, errorTerm: LONG INTEGER,     start, stop, origin: Window.Place, sharpCornered: BOOLEAN,    thickness: CARDINAL, color: BitSW.Color, bounds: Window.BoxHandle] = {    ConicLocked: ENTRY PROC [bsw: BSWContext] = INLINE {      ENABLE UNWIND => NULL;      ls: Sp.LineStyleObject ¬ TRASH;      DisplayInternal.SpecialConic[        @bsw.specialWindow, a, b, c, d, e, errorTerm, start, stop, origin,	sharpCornered, bounds, LS[@ls, thickness], FlagsForColor[color],	@bsw.special]};    ConicLocked[LocalFind[window]]};    Ellipse: PUBLIC PROC [    window: Handle, center: Window.Place, xRadius, yRadius: INTEGER,    thickness: CARDINAL, color: BitSW.Color, bounds: Window.BoxHandle] = {    EllipseLocked: ENTRY PROC [bsw: BSWContext] = INLINE {      ENABLE UNWIND => NULL;      ls: Sp.LineStyleObject ¬ TRASH;      Sp.SpEllipse[        @bsw.specialWindow, center, xRadius, yRadius, bounds, LS[@ls, thickness],	FlagsForColor[color], @bsw.special]};    EllipseLocked[LocalFind[window]]};    Gray: PUBLIC PROC [    window: Handle, box: Window.Box, gray: Display.Brick,    dstFunc: BitBlt.DstFunc] = {    GrayLocked: ENTRY PROC [bsw: BSWContext] = INLINE {      ENABLE UNWIND => NULL;      Sp.SpGray[        @bsw.specialWindow, box, gray, DestFlags[dstFunc, TRUE], @bsw.special]};    GrayLocked[LocalFind[window]]};      Invert: PUBLIC PROC [window: Handle, box: Window.Box] = {    InvertLocked: ENTRY PROC [bsw: BSWContext] = INLINE {      ENABLE UNWIND => NULL;      Sp.SpInvert[@bsw.specialWindow, box, @bsw.special]};    InvertLocked[LocalFind[window]]};      Line: PUBLIC PROC [    window: Handle, start, stop: Window.Place, color: BitSW.Color,    thickness: CARDINAL, bounds: Window.BoxHandle] = {    LineLocked: ENTRY PROC [bsw: BSWContext] = INLINE {      ENABLE UNWIND => NULL;      ls: Sp.LineStyleObject ¬ TRASH;      Sp.SpecialLine[        @bsw.specialWindow, start, stop, bounds, LS[@ls, thickness],	FlagsForColor[color], @bsw.special]};    LineLocked[LocalFind[window]]};    Point: PUBLIC PROC [    window: Handle, point: Window.Place, color: BitSW.Color] = {    PointLocked: ENTRY PROC [bsw: BSWContext] = INLINE {      ENABLE UNWIND => NULL;      Sp.SpPoint[@bsw.specialWindow, point, FlagsForColor[color], @bsw.special]};    PointLocked[LocalFind[window]]};  Text: PUBLIC PROC [    window: Handle, string: LONG STRING, place: Window.Place,    font: WindowFont.Handle, lineLength: INTEGER, flags: BitBlt.BitBltFlags,    bounds: Window.BoxHandle]    RETURNS [newPlace: Window.Place] = {    TextLocked: ENTRY PROC [bsw: BSWContext] RETURNS [Window.Place] = INLINE {      ENABLE UNWIND => NULL;      RETURN[        Sp.SpBlock[	  @bsw.specialWindow, [LOOPHOLE[@string.text], 0, string.length],	  lineLength, place, font, flags, bounds, @bsw.special].newPlace]};    RETURN TextLocked[LocalFind[window]]};      White: PUBLIC PROC [window: Handle, box: Window.Box] = {    WhiteLocked: ENTRY PROC [bsw: BSWContext] = INLINE {      ENABLE UNWIND => NULL;      Sp.SpWhite[@bsw.specialWindow, box, @bsw.special]};    WhiteLocked[LocalFind[window]]};     END.  
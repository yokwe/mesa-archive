-- File: MFileServerOps.mesa - last edit:-- AOF                  2-Jul-87 10:50:08-- BGY                  8-Aug-84 11:53:37-- JCS                 27-Jan-86 11:45:18-- Copyright (C) 1984, 1985, 1987 by Xerox Corporation. All rights reserved. DIRECTORY  Courier USING [Dispatcher, Handle, Parameters, Results],  Format USING [StringProc],  MFile USING [Type],  NSFile USING [Attribute, AttributeList, ID, Session],  NSFileCourier USING [    AttributeTypeList, CreateArguments, CreateResults, DeleteArguments,    FindArguments, FindResults, GetAttributesArguments, GetAttributesResults,    ListArguments, ListResults, LogonArguments, LogonResults, OpenArguments, OpenResults, RemoteErrorIndex,    RetrieveArguments, RetrieveResults, StoreArguments, StoreResults],  NSString USING [String],  System USING [GreenwichMeanTime],  Window USING [Handle];MFileServerOps: DEFINITIONS =  {  Write: Format.StringProc;  formsw: Window.Handle;  AttrSeq: TYPE = RECORD [SEQUENCE length: CARDINAL OF NSFile.Attribute];  Attrs: TYPE = LONG POINTER TO AttrSeq;  FileRec: TYPE = RECORD [    SELECT OVERLAID * FROM    pilot => [pid: LONG STRING, pad1, pad2, pad3: CARDINAL],    ns => [nid: NSFile.ID],    init => [iid: ARRAY [0..4] OF CARDINAL],    ENDCASE];  Handle: TYPE = LONG POINTER TO Object;  Object: TYPE = RECORD [    userName, name, path, fullname, rootDir: LONG STRING ¬ NIL,    sequence: Attrs ¬ NIL];  SessionPtr: TYPE = LONG POINTER TO SessionObject;  SessionObject: TYPE = RECORD [session: NSFile.Session, next: SessionPtr];  sessionList: SessionPtr;  debug, running, logActivity, storeAllowed, overWriteAllowed, deleteAllowed:    BOOLEAN;  volName, physical: PUBLIC LONG STRING;  nsVolName, nsPhysical: NSString.String;  DestroyTool: PROC;  ActivateTool: PROC;  Logon: PROC [    arg: LONG POINTER TO NSFileCourier.LogonArguments,    res: LONG POINTER TO NSFileCourier.LogonResults];  DeleteMFile: PROC [arg: LONG POINTER TO NSFileCourier.DeleteArguments];  CreateMFile: PROC [    arg: LONG POINTER TO NSFileCourier.CreateArguments,    res: LONG POINTER TO NSFileCourier.CreateResults, dir: LONG STRING];  StoreMFile: PROC [    arg: LONG POINTER TO NSFileCourier.StoreArguments,    res: LONG POINTER TO NSFileCourier.StoreResults, dir: LONG STRING,    cH: Courier.Handle];  RetrieveMFile: PROC [    arg: LONG POINTER TO NSFileCourier.RetrieveArguments,    res: LONG POINTER TO NSFileCourier.RetrieveResults, file: LONG STRING,    cH: Courier.Handle];  FindMFile: PROC [    arg: LONG POINTER TO NSFileCourier.FindArguments,    res: LONG POINTER TO NSFileCourier.FindResults];  ListMFile: PROC [    arg: LONG POINTER TO NSFileCourier.ListArguments,    res: LONG POINTER TO NSFileCourier.ListResults, dir: LONG STRING,    cH: Courier.Handle];  OpenMFile: PROC [    arg: LONG POINTER TO NSFileCourier.OpenArguments,    res: LONG POINTER TO NSFileCourier.OpenResults];          GetMFileAttributes: PROCEDURE[    arg: LONG POINTER TO NSFileCourier.GetAttributesArguments,    res: LONG POINTER TO NSFileCourier.GetAttributesResults,    results: Courier.Results,    resultParameters: Courier.Parameters,     zone: UNCOUNTED ZONE];      CopyAttributes: PUBLIC PROC [    h: MFileServerOps.Handle, selections: NSFileCourier.AttributeTypeList,    name, fullname: LONG STRING, create, read: System.GreenwichMeanTime,    type: MFile.Type, length: LONG CARDINAL]    RETURNS [attributes: NSFile.AttributeList];  ReportError: PROCEDURE [    error: NSFileCourier.RemoteErrorIndex, argumentList: LONG POINTER];  AppendString: PROC [to, from: LONG STRING, isDir: BOOLEAN ¬ FALSE];    DispatchOther: Courier.Dispatcher;  }.
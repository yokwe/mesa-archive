-- File: V4NSFileCourierImpl.mesa - last edit:-- bjd                 13-Mar-88 23:01:25-- Copyright (C) 1988 by Xerox Corporation. All rights reserved.-- Overview: Partial implementation of NSFileCourier: utility operations-- Last revised by Hanzel: 26-Apr-84 16:08:19<<  To do:>>DIRECTORY  Courier,  Environment ,  Heap,  Inline,  MemoryStream ,  Mopcodes ,  NSAssignedTypes,  -- USING many  NSFile ,  NSFileCourier ,  NSName ,  NSString ,  Stream ,  V4NSFileCourier USING [];V4NSFileCourierImpl: PROGRAM  IMPORTS    Courier, Heap, Inline, MemoryStream, NSFile, NSName, NSString,    Stream  EXPORTS V4NSFileCourier =  BEGIN OPEN NSFileCourier;  -- Exported variables  zone: PUBLIC UNCOUNTED ZONE _ Heap.systemZone;  -- CONSTANTS  bytesPerWord: CARDINAL = Environment.bytesPerWord;  ctStandardAttributeTypes: CARDINAL = 28;  -- The number of standard attribute types defined by NSAssignedTypes (neglecting 'service' type)  directoryAttributeSelections: NSFile.InterpretedSelections = [    childrenUniquelyNamed: TRUE, defaultAccessList: TRUE, numberOfChildren: TRUE,    ordering: TRUE, subtreeSizeLimit: TRUE];  ctDirectoryAttributes: CARDINAL = 5;  -- ordinality of directoryAttributeSelections  parentAttributeSelections: NSFile.InterpretedSelections = [    parentID: TRUE, position: TRUE];  ctParentAttributes: CARDINAL = 2;  -- ordinality of parentAttributeSelections  Bug: ERROR [type: BugType] = CODE;  BugType: TYPE = {parameterAttributeInconsistency};  -- Description of NSFile.Attribute  AttributeFormat: TYPE = {word, doubleWord, fiveWord, string, cHName, other};  format: ARRAY NSFile.AttributeType OF AttributeFormat = [    checksum: word, childrenUniquelyNamed: word, isDirectory: word,    isTemporary: word, version: word, numberOfChildren: word,    type: doubleWord, backedUpOn: doubleWord, createdOn: doubleWord,    filedOn: doubleWord, modifiedOn: doubleWord, readOn: doubleWord,    sizeInBytes: doubleWord, sizeInPages: doubleWord, subtreeSize: doubleWord,    subtreeSizeLimit: doubleWord,    fileID: fiveWord, parentID: fiveWord,    name: string, pathname: string,    service: other,    createdBy: cHName, filedBy: cHName, modifiedBy: cHName, readBy: cHName,    ordering: other, position: other, accessList: other, defaultAccessList: other,    extended: other];  nil: POINTER TO NSFile.AttributesRecord = NIL;  offset: ARRAY NSFile.AttributeType OF UNSPECIFIED = [    checksum: @nil.checksum, childrenUniquelyNamed: @nil.childrenUniquelyNamed,    createdBy: @nil.createdBy, createdOn: @nil.createdOn, fileID: @nil.fileID,    service: @nil.service, isDirectory: -1 --@nil.isDirectory-- , isTemporary: -1    --@nil.isTemporary-- , modifiedBy: @nil.modifiedBy,    modifiedOn: @nil.modifiedOn, name: @nil.name,    numberOfChildren: @nil.numberOfChildren, ordering: @nil.ordering,    parentID: @nil.parentID, position: @nil.position, readBy: @nil.readBy,    readOn: @nil.readOn, sizeInBytes: @nil.sizeInBytes, type: @nil.type,    version: @nil.version, accessList: @nil.accessList,    defaultAccessList: @nil.defaultAccessList, pathname: @nil.pathname,    backedUpOn: @nil.backedUpOn, filedBy: @nil.filedBy, filedOn: @nil.filedOn,    sizeInPages: @nil.sizeInPages, subtreeSize: @nil.subtreeSize,    subtreeSizeLimit: @nil.subtreeSizeLimit, extended: @nil.extended];  attributeLength: ARRAY NSFile.AttributeType OF CARDINAL = [    checksum: 1, childrenUniquelyNamed: 1, isDirectory: 1, isTemporary: 1,    version: 1, numberOfChildren: 1,    type: 2, backedUpOn: 2, createdOn: 2, filedOn: 2, modifiedOn: 2, readOn: 2,    sizeInBytes: 2, sizeInPages: 2, subtreeSize: 2, subtreeSizeLimit: 2,    fileID: 5, parentID: 5,    name: SIZE[NSString.String], pathname: SIZE[NSString.String],    service: 0,  -- should never be used    createdBy: SIZE[NSString.String], filedBy: SIZE[NSString.String],    modifiedBy: SIZE[NSString.String], readBy: SIZE[NSString.String],    ordering: SIZE[NSFile.Ordering], position: SIZE[NSFile.Words],    accessList: SIZE[NSFile.AccessList],    defaultAccessList: SIZE[NSFile.AccessList], extended: 0];  -- Useful inlines  SwapWords: PROC [LONG CARDINAL] RETURNS [LONG CARDINAL] = MACHINE CODE {    Mopcodes.zEXCH};  GetWord: PROC [notes: Courier.Notes] RETURNS [u: UNSPECIFIED] = INLINE {    notes.noteSpace[@u, 1]};  PutWord: PROC [notes: Courier.Notes, u: UNSPECIFIED] = INLINE {    notes.noteSpace[@u, 1]};  DescribeAttribute: PUBLIC Courier.Description =    BEGIN    site: LONG POINTER TO NSFile.Attribute = notes.noteSize[      SIZE[NSFile.Attribute]];    notes.noteDeadSpace[site, SIZE[NSFile.Attribute]];    SELECT notes.operation FROM      fetch => PutAttribute[notes, site];      store => GetAttribute[notes, site];      free => FreeAttribute[site, notes.zone];      ENDCASE => ERROR;    END;  -- of DescribeAttribute  DescribeAttributes: PUBLIC Courier.Description =    BEGIN    site: LONG POINTER TO NSFile.AttributeList = notes.noteSize[      SIZE[NSFile.AttributeList]];    -- no limit on the length of the list for now    notes.noteArrayDescriptor[      site: site, elementSize: SIZE[NSFile.Attribute],      upperBound: LAST[CARDINAL]];    FOR i: CARDINAL IN [0..LENGTH[site^]) DO      notes.noteParameters[@site[i], DescribeAttribute]; ENDLOOP;    END;  -- of DescribeAttributes  FreeAttributes: PUBLIC PROC [    attributes: NSFile.AttributeList, zone: UNCOUNTED ZONE] =    BEGIN    IF BASE[attributes] = NIL THEN RETURN;    FOR i: CARDINAL IN [0..LENGTH[attributes]) DO      FreeAttribute[@attributes[i], zone]; ENDLOOP;    Heap.FreeNode[zone, BASE[attributes]];    END;  -- of FreeAttributes  FreeAttribute: PROC [    attr: LONG POINTER TO NSFile.Attribute, zone: UNCOUNTED ZONE] =    BEGIN    WITH a: attr SELECT FROM      createdBy, filedBy, modifiedBy, readBy =>        NSString.FreeString[zone, a.value];      name, pathname => NSString.FreeString[zone, a.value];      position => IF BASE[a.value] # NIL THEN Heap.FreeNode[zone, BASE[a.value]];      extended => IF BASE[a.value] # NIL THEN Heap.FreeNode[zone, BASE[a.value]];      accessList, defaultAccessList => {        FOR j: CARDINAL IN [0..LENGTH[a.value.entries]) DO          NSString.FreeString[zone, a.value.entries[j].key]; ENDLOOP;        IF BASE[a.value.entries] # NIL THEN          Heap.FreeNode[zone, BASE[a.value.entries]]};      ENDCASE;    END;  -- of FreeAttribute  GetAttribute: PROC [    notes: Courier.Notes, attr: LONG POINTER TO NSFile.Attribute] =    BEGIN    valuePtr: LONG POINTER = attr + 1;    attrType: LONG CARDINAL = GetDoubleWord[notes];    length: CARDINAL _ GetWord[notes];    SELECT attrType FROM      IN [NSAssignedTypes.checksum..NSAssignedTypes.subtreeSizeLimit] =>        LOOPHOLE[attr, LONG POINTER TO NSFile.AttributeType]^ _ Inline.LowHalf[          attrType];      ENDCASE => {        attr^ _ [extended[type: attrType, value: GetWordSequence[notes, length]]];        RETURN};    IF length = 0 THEN {GetDefaultAttribute[attr]; RETURN};    SELECT format[attr.type] FROM      word => valuePtr^ _ GetWord[notes];      doubleWord =>        LOOPHOLE[valuePtr, LONG POINTER TO LONG CARDINAL]^ _ GetDoubleWord[notes];      fiveWord => GetBlock[notes, valuePtr, 5];      string =>        LOOPHOLE[valuePtr, LONG POINTER TO NSString.String]^ _ GetNSString[notes];      cHName =>        LOOPHOLE[valuePtr, LONG POINTER TO NSString.String]^ _ GetCHName[notes];      other =>        WITH a: attr SELECT FROM          ordering => GetOrdering[notes, @a.value];          position => {            realLength: CARDINAL _ GetWord[notes];            a.value _ GetWordSequence[notes, realLength]};          accessList, defaultAccessList => a.value _ GetAccessList[notes];	  service => NSFile.Error[[attributeType[illegal, service]]];          ENDCASE => ERROR Courier.Error[parameterInconsistency];      ENDCASE => ERROR Courier.Error[parameterInconsistency];    END;  -- of GetAttribute  GetDefaultAttribute: PROC [attr: LONG POINTER TO NSFile.Attribute] =    BEGIN    WITH attr SELECT FROM      childrenUniquelyNamed => value _ FALSE;      defaultAccessList => value _ [NIL, FALSE];      numberOfChildren => value _ 0;      ordering => value _ NSFile.defaultOrdering;      subtreeSizeLimit => value _ 0;      parentID => value _ NSFile.nullID;      position => value _ NIL;      ENDCASE;  --no default    END;  -- of GetDefaultAttribute  GetAccessList: PROC [notes: Courier.Notes] RETURNS [acl: NSFile.AccessList] =    BEGIN    AccessEntrySequence: TYPE = RECORD [      SEQUENCE COMPUTED CARDINAL OF NSFile.AccessEntry];    length: CARDINAL _ GetWord[notes];    IF length = 0 THEN acl.entries _ NIL    ELSE {      acl.entries _ DESCRIPTOR[        notes.zone.NEW[AccessEntrySequence [length]], length];      FOR i: CARDINAL IN [0..LENGTH[acl.entries]) DO        ptEntry: LONG POINTER TO NSFile.AccessEntry = @acl.entries[i];        ptEntry.key _ GetCHName[notes];        ptEntry.type _ LOOPHOLE[GetWord[notes]];        ptEntry.access _ LOOPHOLE[GetWord[notes]];        ENDLOOP};    acl.defaulted _ LOOPHOLE[GetWord[notes]];    END;  -- of GetAccessList  GetBlock: PROC [notes: Courier.Notes, site: LONG POINTER, size: CARDINAL] =    INLINE {notes.noteSpace[site, size]};  GetCHName: PROC [notes: Courier.Notes] RETURNS [string: NSString.String] =    BEGIN    name: NSName.NameRecord;    name.org _ GetNSString[notes];    name.domain _ GetNSString[notes];    name.local _ GetNSString[notes];    IF name = [NSString.nullString, NSString.nullString, NSString.nullString] THEN      RETURN[NSString.nullString];    string _ NSString.MakeString[      notes.zone,      name.org.length + name.domain.length + name.local.length +        (NSName.hierarchicalLevels - 1) *          (NSName.characterSetChangeOverhead + 2)];    string _ NSName.AppendNameToString[string, @name];    NSName.FreeNameFields[notes.zone, @name];    END;  -- of GetCHName  GetDoubleWord: PROC [notes: Courier.Notes] RETURNS [value: LONG CARDINAL] = {    notes.noteSpace[@value, 2]; value _ SwapWords[value]};  GetOrdering: PUBLIC PROC [    notes: Courier.Notes, site: LONG POINTER TO NSFile.Ordering] =    BEGIN OPEN o: LOOPHOLE[site, LONG POINTER TO extended NSFile.Ordering];    o.key _ GetDoubleWord[notes];    o.ascending _ GetWord[notes];    o.interpretation _ GetWord[notes];    LOOPHOLE[site, LONG POINTER TO NSFile.OrderingType]^ _      IF o.key IN [NSAssignedTypes.checksum..NSAssignedTypes.subtreeSizeLimit]      THEN key ELSE extended;    END;  -- of GetOrdering  GetNSString: PUBLIC PROC [notes: Courier.Notes]    RETURNS [string: NSString.String] =    BEGIN    ByteSequence: TYPE = RECORD [      PACKED SEQUENCE COMPUTED CARDINAL OF Environment.Byte];    string.length _ string.maxlength _ GetWord[notes];    IF string.length = 0 THEN RETURN[NSString.nullString];    string.bytes _ LOOPHOLE[notes.zone.NEW[ByteSequence [string.length]]];    GetBlock[notes, string.bytes, (string.length + 1) / 2];    END;  -- of GetNSString  GetWordSequence: PROC [notes: Courier.Notes, length: CARDINAL]    RETURNS [NSFile.Words] =    BEGIN    WordSequence: TYPE = RECORD [SEQUENCE COMPUTED CARDINAL OF UNSPECIFIED];    base: LONG POINTER TO WordSequence;    IF length = 0 THEN RETURN[NIL];    base _ notes.zone.NEW[WordSequence [length]];    GetBlock[notes, base, length];    RETURN[DESCRIPTOR[base, length]];    END;  -- of GetWordSequence  PutAttribute: PROC [    notes: Courier.Notes, attr: LONG POINTER TO NSFile.Attribute] =    BEGIN    valuePtr: LONG POINTER = attr + 1;    WITH a: attr SELECT FROM      extended => {        PutDoubleWord[notes, a.type]; PutWordSequence[notes, a.value]; RETURN};      ENDCASE => {PutWord[notes, 0]; PutWord[notes, attr.type]};    SELECT format[attr.type] FROM      word => {PutWord[notes, 1]; PutWord[notes, valuePtr^]};      doubleWord => {        PutWord[notes, 2];        PutDoubleWord[notes, LOOPHOLE[valuePtr, LONG POINTER TO LONG CARDINAL]^]};      fiveWord => {PutWord[notes, 5]; PutBlock[notes, valuePtr, 5]};      string => {        ptString: LONG POINTER TO NSString.String _ LOOPHOLE[valuePtr];        PutWord[notes, StringSize[ptString^]];        PutNSString[notes, ptString^]};      cHName =>        PutCHName[          notes, LOOPHOLE[valuePtr, LONG POINTER TO NSString.String]^, TRUE];      other =>        WITH a: attr SELECT FROM          ordering => {            PutWord[notes, SIZE[NSFileCourier.Ordering]];            PutOrdering[notes, @a.value]};          position => {  -- embedded sequence            PutWord[notes, LENGTH[a.value] + 1]; PutWordSequence[notes, a.value]};          accessList, defaultAccessList =>            PutAccessListWithLength[notes, a.value];	  service => NSFile.Error[[attributeType[illegal, service]]];          ENDCASE => ERROR Courier.Error[parameterInconsistency];      ENDCASE => ERROR Courier.Error[parameterInconsistency];    END;  -- of PutAttribute  PutAccessListWithLength: PROC [notes: Courier.Notes, acl: NSFile.AccessList] =    BEGIN    WordSequence: TYPE = RECORD [SEQUENCE COMPUTED CARDINAL OF UNSPECIFIED];    --Use MemoryStream to buffer data, since we must send length before data    bufferMaxLength: CARDINAL =      LENGTH[acl.entries] *        (NSName.maxOrgLength + NSName.maxDomainLength + NSName.maxLocalLength + 5)        + 2;    -- +5 per entry = three string lengths + "type" + "access"    -- +2 per list = length of list + "defaulted"    buffer: Environment.Block _ [      LOOPHOLE[notes.zone.NEW[WordSequence [bufferMaxLength]]], 0,      bufferMaxLength * bytesPerWord];    memStream: Stream.Handle = MemoryStream.Create[buffer];    Stream.PutWord[memStream, LENGTH[acl.entries]];    FOR i: CARDINAL IN [0..LENGTH[acl.entries]) DO      ptEntry: LONG POINTER TO NSFile.AccessEntry = @acl.entries[i];      description: Courier.Description = {        site: LONG POINTER TO NSString.String = notes.noteSize[0];        PutCHName[notes, site^, FALSE]};      Courier.SerializeParameters[[@ptEntry.key, description], memStream];      Stream.PutWord[memStream, LOOPHOLE[ptEntry.type]];      Stream.PutWord[memStream, LOOPHOLE[ptEntry.access]];      ENDLOOP;    Stream.PutWord[memStream, LOOPHOLE[acl.defaulted]];    buffer.stopIndexPlusOne _ Inline.LowHalf[Stream.GetPosition[memStream]];    Stream.Delete[memStream];    --send length of attribute, then contents of buffer    PutWord[notes, buffer.stopIndexPlusOne / 2];  --stopIndexPlusOne should never be odd    PutBlock[notes, buffer.blockPointer, buffer.stopIndexPlusOne / 2];    notes.zone.FREE[@buffer.blockPointer];    END;  -- of PutAccessListWithLength  PutBlock: PROC [notes: Courier.Notes, site: LONG POINTER, size: CARDINAL] =    INLINE {notes.noteSpace[site, size]};  PutCHName: PROC [    notes: Courier.Notes, string: NSString.String, withLength: BOOLEAN] =    BEGIN    name: NSName.NameRecord;    NSName.NameFieldsFromString[notes.zone, string, @name];    IF withLength THEN PutWord[notes, CHNameSize[@name]];    PutNSString[notes, name.org];    PutNSString[notes, name.domain];    PutNSString[notes, name.local];    NSName.FreeNameFields[notes.zone, @name];    END;  -- of PutCHName  PutDoubleWord: PROC [notes: Courier.Notes, value: LONG CARDINAL] = {    value _ SwapWords[value]; notes.noteSpace[@value, 2]};  PutOrdering: PUBLIC PROC [    notes: Courier.Notes, site: LONG POINTER TO NSFile.Ordering] =    BEGIN OPEN o: LOOPHOLE[site, LONG POINTER TO extended NSFile.Ordering];    PutDoubleWord[notes, o.key];    PutWord[notes, o.ascending];    PutWord[notes, o.interpretation];    END;  -- of PutOrdering  PutNSString: PUBLIC PROC [notes: Courier.Notes, string: NSString.String] =    BEGIN    PutWord[notes, string.length];    IF string.length MOD 2 = 1 THEN string.bytes[string.length] _ 0;    PutBlock[notes, string.bytes, (string.length + 1) / 2];    END;  -- of PutNSString   PutWordSequence: PROC [notes: Courier.Notes, words: NSFile.Words] =    BEGIN    PutWord[notes, LENGTH[words]];    notes.noteSpace[BASE[words], LENGTH[words]];    END;  -- of PutWordSequence  CHNameSize: PROC [name: NSName.Name] RETURNS [CARDINAL] =    BEGIN    RETURN[      StringSize[name.org] + StringSize[name.domain] + StringSize[name.local]];    END;  -- of CHNameSize  StringSize: PROC [string: NSString.String] RETURNS [CARDINAL] = INLINE {    RETURN[((string.length + 1) / 2) + 1]};  END.    LOG (date - person - action) - - - - SERVICES 8.0 - - - -November 15, 1983 - Hanzel - Initial conversion to Services 8.0 and Klamath Courier.December 2, 1983 - Hanzel - Never include 'service' in EncodeAttributes and EncodeSelections.December 16, 1983 - Hanzel - Clean up act w.r.t. node allocation; rely on zone within notes object throughout (eliminated zone argument to few procedures).20-Dec-83 13:52:59 - Ciccone - Removed zone parameter from GetNSString.December 28, 1983 - Hanzel - Work around fact that Courier fails to supply any zone during SerializeParameters in SerializeAttributes and PutAccessList (AR 5273).December 30, 1983 - Hanzel - Make check for service in EncodeAttributes (with non-all selections) report error instead of skipping selection.January 25, 1984 - Hanzel - Remove workarounds for lack of Courier-supplied zone (11.0f) in DescribeAttribute, PutAccessList and SerializeAttributes.February 2, 1984 - Hanzel - Report NSFile.Error[[attributeType[illegal, service]]] instead of Courier.Error[parameterInconsistency] if "service" attribute is passed in protocol attribute lists (GetAttribute and PutAttribute).April 26, 1984 - Hanzel - Work around Courier/NSDataStream deficiecy with respect to end of data in DeserializeStreamOfAttributeSequence.13-Mar-88 22:54:13 - bjd - swiped from NSFileCourierUtilityImplA for v4 backward compatibility in mfileserver. 
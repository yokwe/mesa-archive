-- File: MFileServerImplC.mesa - last edit:-- AOF                  2-Jul-87 15:09:26-- JCS                 10-Dec-85 19:17:15-- Copyright (C) 1985, 1987 by Xerox Corporation. All rights reserved. DIRECTORY  Atom USING [MakeAtom],  Courier USING [    Dispatcher, Error, InvalidArguments, NoSuchProcedureNumber, Parameters],  Inline USING [LowHalf],  MFile USING [EnumerateDirectory, EnumerateProc, Error, Type],  MFileServerDebug USING [PrintAttributes, PrintControlList],  MFileServerOps,  NSFile USING [Attribute, AttributeList, AttributeType, Type],  NSAssignedTypes USING [tDirectory, tText, tUnspecified],  NSFileCourier USING [    AttributeTypeList, ChangeAttributesArguments, ChangeAttributesResults,    ChangeControlsArguments, ChangeControlsResults,    ConnectionErrorArguments, CopyArguments, CopyResults,    DeserializeArguments, DeserializeResults, GenericArgumentRecord,    GenericResultRecord, GetControlsArguments, GetControlsResults,    GetRemoteProcedureDescriptions, MoveArguments, MoveResults,    RemoteProcedureDescriptionsHandle, RemoteProcedureIndex,    ReplaceArguments, ReplaceResults, SerializeArguments,    SerializeResults, UnifyAccessListsArguments, UnifyAccessListsResults, zone],  NSString,  Profile USING [debugging],  String USING [AppendChar, AppendString],  System USING [GreenwichMeanTime];MFileServerImplC: MONITOR  IMPORTS    Atom, Courier, Inline, MFile, MFileServerDebug, MFileServerOps,    NSFileCourier, NSString, Profile, String       EXPORTS MFileServerOps =  {  procedureDescriptions: NSFileCourier.RemoteProcedureDescriptionsHandle =    NSFileCourier.GetRemoteProcedureDescriptions[];      --error  procNotImplemented: NSFileCourier.ConnectionErrorArguments ¬ [missingProcedure];        DispatchOther: PUBLIC Courier.Dispatcher    --[cH: Courier.Handle, procedureNumber: CARDINAL,--    -- arguments: Courier.Arguments, results: Courier.Results ]--  = {    procedure: NSFileCourier.RemoteProcedureIndex;    argumentList: POINTER TO NSFileCourier.GenericArgumentRecord =      @argumentListRecord;    argumentListRecord: NSFileCourier.GenericArgumentRecord;    argumentParameters: Courier.Parameters;    resultList: POINTER TO NSFileCourier.GenericResultRecord =      @resultListRecord;    resultListRecord: NSFileCourier.GenericResultRecord;    resultParameters: Courier.Parameters;    IF procedureNumber > ORD[LAST[NSFileCourier.RemoteProcedureIndex]] THEN      ERROR Courier.NoSuchProcedureNumber;    procedure ¬ LOOPHOLE[procedureNumber];    argumentParameters ¬ [      location: argumentList,      description: procedureDescriptions^[procedure].arguments];    resultParameters ¬ [      location: resultList,      description: procedureDescriptions^[procedure].results];    arguments[argumentParameters ! Courier.Error => GOTO argumentsError];    SELECT procedure FROM    Copy => {        OPEN          arg: LOOPHOLE[argumentList, POINTER TO NSFileCourier.CopyArguments],          res: LOOPHOLE[resultList, POINTER TO NSFileCourier.CopyResults];        IF Profile.debugging THEN {          MFileServerOps.Write["Copy called:\n"L];          MFileServerDebug.PrintAttributes[arg.attributes];          MFileServerDebug.PrintControlList[arg.controls]};        MFileServerOps.ReportError[	  ConnectionError, @procNotImplemented];        };      Move => {        OPEN          arg: LOOPHOLE[argumentList, POINTER TO NSFileCourier.MoveArguments],          res: LOOPHOLE[resultList, POINTER TO NSFileCourier.MoveResults];        IF Profile.debugging THEN {          MFileServerOps.Write["Move called:\n"L];          MFileServerDebug.PrintAttributes[arg.attributes];          MFileServerOps.ReportError[	    ConnectionError, @procNotImplemented]};        };      ChangeAttributes => {        OPEN          arg: LOOPHOLE[argumentList, POINTER TO            NSFileCourier.ChangeAttributesArguments],          res: LOOPHOLE[resultList, POINTER TO            NSFileCourier.ChangeAttributesResults];        IF Profile.debugging THEN {          MFileServerOps.Write["ChangeAttributes called:\n"L];          MFileServerDebug.PrintAttributes[arg.attributes]};        MFileServerOps.ReportError[	  ConnectionError, @procNotImplemented];        };      UnifyAccessLists => {        OPEN          arg: LOOPHOLE[argumentList, POINTER TO            NSFileCourier.UnifyAccessListsArguments],          res: LOOPHOLE[resultList, POINTER TO            NSFileCourier.UnifyAccessListsResults];        IF Profile.debugging THEN          MFileServerOps.Write["UnifyAccessLists called:\n"L];        };      ChangeControls => {        OPEN          arg: LOOPHOLE[argumentList, POINTER TO            NSFileCourier.ChangeControlsArguments],          res: LOOPHOLE[resultList, POINTER TO            NSFileCourier.ChangeControlsResults];        IF Profile.debugging THEN {          MFileServerOps.Write["ChangeControls called:\n"L];          MFileServerDebug.PrintControlList[arg.controls]};        };      GetControls => {        OPEN          arg: LOOPHOLE[argumentList, POINTER TO            NSFileCourier.GetControlsArguments],          res: LOOPHOLE[resultList, POINTER TO            NSFileCourier.GetControlsResults];        IF Profile.debugging THEN          MFileServerOps.Write["GetControls called:\n"L];        MFileServerOps.ReportError[	  ConnectionError, @procNotImplemented];        };      Replace => {        OPEN          arg: LOOPHOLE[argumentList, POINTER TO            NSFileCourier.ReplaceArguments],          res: LOOPHOLE[resultList, POINTER TO NSFileCourier.ReplaceResults];        IF Profile.debugging THEN MFileServerOps.Write["Replace called:\n"L];        MFileServerOps.ReportError[	  ConnectionError, @procNotImplemented];        };      Serialize => {        OPEN          arg: LOOPHOLE[argumentList, POINTER TO            NSFileCourier.SerializeArguments],          res: LOOPHOLE[resultList, POINTER TO NSFileCourier.SerializeResults];        IF Profile.debugging THEN MFileServerOps.Write["Serialize called:\n"L];        MFileServerOps.ReportError[	  ConnectionError, @procNotImplemented];        };      Deserialize => {        OPEN          arg: LOOPHOLE[argumentList, POINTER TO            NSFileCourier.DeserializeArguments],          res: LOOPHOLE[resultList, POINTER TO            NSFileCourier.DeserializeResults];        IF Profile.debugging THEN          MFileServerOps.Write["Deserialize called:\n"L];        MFileServerOps.ReportError[	  ConnectionError, @procNotImplemented];        };      ENDCASE => ERROR Courier.NoSuchProcedureNumber;    EXITS argumentsError => ERROR Courier.InvalidArguments;    };  --DispatchNotImpl  CopyAttributes: PUBLIC PROC [    h: MFileServerOps.Handle, selections: NSFileCourier.AttributeTypeList,    name, fullname: LONG STRING, create, read: System.GreenwichMeanTime,    type: MFile.Type, length: LONG CARDINAL]    RETURNS [attributes: NSFile.AttributeList] = {    desc: LONG DESCRIPTOR FOR ARRAY OF NSFile.Attribute ¬ DESCRIPTOR[      h.sequence];    selLength: CARDINAL = selections.LENGTH;    path: LONG STRING ¬ NSFileCourier.zone.NEW[StringBody [200]];    crap: MFileServerOps.FileRec ¬ [init[[0, 0, 0, 0, 0]]];    i, j: CARDINAL ¬ 0;    pages: LONG CARDINAL ¬ (length + LONG[511]) / LONG[512];    decrement: BOOLEAN ¬ FALSE;    crap.pid ¬ Atom.MakeAtom[fullname];    String.AppendString[path, fullname];    ChangeToSlash[fullname, path];    FOR i IN [0..selLength) DO      lh: CARDINAL ¬ Inline.LowHalf[selections[i]];      attr: NSFile.AttributeType ¬ VAL[lh];      decrement ¬ FALSE;      SELECT attr FROM        fileID => h.sequence[j] ¬ [fileID[value: crap.nid]];        type => h.sequence[j] ¬ [type[value: GetType[type]]];        backedUpOn => h.sequence[j] ¬ [backedUpOn[value: create]];        createdOn => h.sequence[j] ¬ [createdOn[value: create]];        filedOn => h.sequence[j] ¬ [filedOn[value: create]];        modifiedOn => h.sequence[j] ¬ [modifiedOn[value: create]];        readOn => h.sequence[j] ¬ [readOn[value: read]];        createdBy => h.sequence[j] ¬ [	  createdBy[value: MFileServerOps.nsPhysical]];        filedBy => h.sequence[j] ¬ [filedBy[value: MFileServerOps.nsPhysical]];        modifiedBy => h.sequence[j] ¬ [	  modifiedBy[value: MFileServerOps.nsPhysical]];        readBy => h.sequence[j] ¬ [readBy[value: MFileServerOps.nsPhysical]];        name =>          h.sequence[j] ¬ [name[value: NSString.StringFromMesaString[name]]];        pathname =>          h.sequence[j] ¬ [            pathname[value: NSString.StringFromMesaString[fullname]]];        childrenUniquelyNamed => h.sequence[j] ¬ [childrenUniquelyNamed[TRUE]];        isDirectory => h.sequence[j] ¬ [isDirectory[value: type = directory]];        isTemporary => h.sequence[j] ¬ [isTemporary[FALSE]];        version => h.sequence[j] ¬ [version[value: 1]];        numberOfChildren =>          h.sequence[j] ¬ [            numberOfChildren[            value: IF type # directory THEN 0 ELSE GetChildren[fullname]]];        sizeInBytes => h.sequence[j] ¬ [sizeInBytes[value: length]];        sizeInPages => h.sequence[j] ¬ [sizeInPages[value: pages]];        ENDCASE => decrement ¬ TRUE;      j ¬ j + 1;      IF decrement THEN j ¬ j - 1;      ENDLOOP;    attributes ¬ DESCRIPTOR[desc.BASE, j];    NSFileCourier.zone.FREE[@path];    };  GetChildren: PROC [name: LONG STRING] RETURNS [children: CARDINAL ¬ 0] = {    Enum: MFile.EnumerateProc = {children ¬ children + 1};    MFile.EnumerateDirectory[      name, Enum, fileAndDirectories ! MFile.Error => CONTINUE];    };  GetType: PROC [mtype: MFile.Type] RETURNS [type: LONG CARDINAL] = {    type ¬      SELECT mtype FROM        unknown => NSAssignedTypes.tUnspecified,        text => NSAssignedTypes.tText,        binary => NSAssignedTypes.tUnspecified,        directory => NSAssignedTypes.tDirectory,        ENDCASE => NSAssignedTypes.tUnspecified;    };  ChangeToSlash: PROC [to, from: LONG STRING] = INLINE {    i: CARDINAL ¬ 0;    to.length ¬ 0;    WHILE i < from.length DO      SELECT from[i] FROM        '< =>          IF from[i + 1] = '> THEN {            String.AppendString[to, MFileServerOps.volName]; i ¬ i + 1};        '> => String.AppendString[to, "!1/"L];        ENDCASE => String.AppendChar[to, from[i]];      i ¬ i + 1;      ENDLOOP;    IF to[to.length - 1] # '/ THEN String.AppendString[to, "!1"L];    };}.
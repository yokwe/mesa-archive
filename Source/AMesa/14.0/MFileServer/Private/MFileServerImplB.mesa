-- File: MFileServerImplB.mesa - last edit:-- AOF                  4-Nov-87 17:05:52-- JCS                 27-Jan-86 12:31:59 -- Copyright (C) 1985, 1987 by Xerox Corporation. All rights reserved. DIRECTORY  Atom USING [ATOM, MakeAtom],  Courier USING [Free, Handle, Parameters, Results],  MFile USING [    Acquire, ByteCount, CreateDirectory, Delete, DeleteWhenReleased,    EnumerateDirectory, EnumerateProc, Error, GetProperties, Handle,    Release, SetTimes, Type, WriteOnly],  MFileServerDebug USING [PrintMFile, PrintMStream],  MFileServerOps USING [    AppendString, CopyAttributes, Handle, logActivity, overWriteAllowed,    ReportError, storeAllowed, Write],  MStream USING [Create, Error, GetLength, Handle, ReadOnly],  NSAssignedTypes USING [tDirectory, tText, tUnspecified],  NSFileCourier USING [    AccessErrorArguments, AttributeValueErrorArguments,    ConnectionErrorArguments, CreateArguments, CreateResults,    DeleteArguments, FindArguments, FindResults, GetAttributesArguments,    GetAttributesResults, HandleErrorArguments, InsertionErrorArguments,    RetrieveArguments, RetrieveResults, SessionErrorArguments,    SpaceErrorArguments, StoreArguments, StoreResults, UndefinedErrorArguments],  NSString USING [AppendToMesaString, String],  Profile USING [debugging],  Stream USING [Delete, Handle],  String USING [AppendChar, AppendString, Equivalent],  System USING [GetGreenwichMeanTime, GreenwichMeanTime],  XStream USING [ServerCheckout];MFileServerImplB: MONITOR  IMPORTS    Atom, Courier, MFile, MFileServerDebug, MFileServerOps,    MStream, NSString, Profile, Stream, String, System, XStream  EXPORTS MFileServerOps =    {    --errors  procNotImplemented: NSFileCourier.ConnectionErrorArguments ¬ [missingProcedure];  noMoreRoom: NSFileCourier.SpaceErrorArguments ¬ [mediumFull];  noAccess: NSFileCourier.AccessErrorArguments ¬ [accessRightsInsufficient];  handleInvalid: NSFileCourier.HandleErrorArguments ¬ [invalid];  sessionInvalid: NSFileCourier.SessionErrorArguments ¬ [sessionInvalid];  notFound: NSFileCourier.AccessErrorArguments ¬ [fileNotFound];  allocExceeded: NSFileCourier.SpaceErrorArguments ¬ [allocationExceeded];  disallowed: NSFileCourier.AttributeValueErrorArguments ¬ [disallowed, 1];  transportTimeout: NSFileCourier.ConnectionErrorArguments ¬ [transportTimeout];  otherCallProblem: NSFileCourier.ConnectionErrorArguments ¬ [otherCallProblem];  fileNotUnique: NSFileCourier.InsertionErrorArguments ¬ [fileNotUnique];  dirCannotBeCopied:NSFileCourier.AttributeValueErrorArguments ¬     [problem: disallowed, type: 17];  undefined: NSFileCourier.UndefinedErrorArguments ¬ [0];  RetrieveMFile: PUBLIC PROC [    arg: LONG POINTER TO NSFileCourier.RetrieveArguments,    res: LONG POINTER TO NSFileCourier.RetrieveResults, file: LONG STRING,    cH: Courier.Handle] = {    aborted: BOOLEAN ¬ FALSE;    mstream: Stream.Handle ¬ NIL;    bytes: MFile.ByteCount ¬ 0;    h: MFileServerOps.Handle ¬ LOOPHOLE[arg.session.token];        BEGIN    ENABLE {      ABORTED => {aborted ¬ TRUE; GOTO aborted};      MStream.Error => {        IF Profile.debugging THEN MFileServerDebug.PrintMStream[code];        IF mstream # NIL THEN {Stream.Delete[mstream]; mstream ¬ NIL};        SELECT code FROM          invalidHandle, fileTooLong, invalidFile =>            MFileServerOps.ReportError[              HandleError, @handleInvalid];          invalidOperation, fileNotAvailable =>            MFileServerOps.ReportError[AccessError, @noAccess]          ENDCASE =>            MFileServerOps.ReportError[              UndefinedError, @undefined]}};         IF MFileServerOps.logActivity THEN {     MFileServerOps.Write[h.userName];     MFileServerOps.Write[" retrieved: "L];     MFileServerOps.Write[file];     MFileServerOps.Write["\n"L]};     mstream ¬ MStream.ReadOnly[file, []];     bytes ¬ MStream.GetLength[mstream];     XStream.ServerCheckout[cH, [stream[mstream]]];     Stream.Delete[mstream]; mstream ¬ NIL;    EXITS      aborted => {        IF Profile.debugging THEN MFileServerOps.Write["Aborted...\n"L];	MFileServerOps.ReportError[UndefinedError, @undefined]};   END};  CreateMFile: PUBLIC PROC [    arg: LONG POINTER TO NSFileCourier.CreateArguments,    res: LONG POINTER TO NSFileCourier.CreateResults, dir: LONG STRING] = {    BEGIN    ENABLE {      MFile.Error => {        IF Profile.debugging THEN MFileServerDebug.PrintMFile[code];        SELECT code FROM          invalidHandle =>            MFileServerOps.ReportError[              HandleError, @handleInvalid];          illegalName, noSuchFile, volumeNotOpen, noRootDirectory =>            MFileServerOps.ReportError[AccessError, @notFound];          noRoomOnVolume, directoryFull =>            MFileServerOps.ReportError[SpaceError, @noMoreRoom];          directoryFull =>            MFileServerOps.ReportError[              SpaceError, @allocExceeded];          fileAlreadyExists =>            MFileServerOps.ReportError[              InsertionError, @fileNotUnique];          insufficientAccess, protectionFault, conflictingAccess =>            MFileServerOps.ReportError[AccessError, @noAccess];          fileIsRemote =>            MFileServerOps.ReportError[              AttributeValueError, @disallowed];          ENDCASE =>            MFileServerOps.ReportError[              UndefinedError, @undefined]}};    type: MFile.Type ¬ binary;    h: MFileServerOps.Handle ¬ LOOPHOLE[arg.session.token];    isDir: BOOLEAN ¬ FALSE;    h.path.length ¬ h.name.length ¬ h.fullname.length ¬ 0;    MFileServerOps.AppendString[h.fullname, dir, TRUE];    FOR i: CARDINAL IN [0..arg.attributes.LENGTH) DO      WITH attr: arg.attributes[i] SELECT FROM        name => NSString.AppendToMesaString[h.fullname, attr.value];        isDirectory => isDir ¬ attr.value;        type =>          type ¬            SELECT attr.value FROM              NSAssignedTypes.tText => text,              NSAssignedTypes.tUnspecified => binary,              NSAssignedTypes.tDirectory => directory,              ENDCASE => unknown;        ENDCASE;      ENDLOOP;    IF ~(isDir OR type = directory) THEN      MFileServerOps.ReportError[AccessError, @noAccess];    MFile.CreateDirectory[h.fullname];    IF Profile.debugging THEN {      MFileServerOps.Write["  Dir Created: "L];      MFileServerOps.Write[h.fullname];      MFileServerOps.Write["\n"L]};    res.file ¬ LOOPHOLE[Atom.MakeAtom[h.fullname]];    END};  StoreMFile: PUBLIC PROC [    arg: LONG POINTER TO NSFileCourier.StoreArguments,    res: LONG POINTER TO NSFileCourier.StoreResults, dir: LONG STRING,    cH: Courier.Handle] = {    create: System.GreenwichMeanTime ¬ System.GetGreenwichMeanTime[];    length: MFile.ByteCount ¬ 0;    file, mfile: MFile.Handle ¬ NIL;    fileExist: BOOLEAN ¬ TRUE;    aborted: BOOLEAN ¬ FALSE;    mstream: Stream.Handle ¬ NIL;    type: MFile.Type ¬ binary;    h: MFileServerOps.Handle ¬ LOOPHOLE[arg.session.token];    h.fullname.length ¬ 0;          IF ~String.Equivalent[dir, "<>"L] THEN      MFileServerOps.AppendString[h.fullname, dir, TRUE];    FOR i: CARDINAL IN [0..arg.attributes.LENGTH) DO      WITH attr: arg.attributes[i] SELECT FROM        name => NSString.AppendToMesaString[h.fullname, attr.value];        createdOn => create ¬ attr.value;        type =>          type ¬            SELECT attr.value FROM              NSAssignedTypes.tText => text,              NSAssignedTypes.tUnspecified => binary,              NSAssignedTypes.tDirectory => directory,              ENDCASE => unknown;        sizeInBytes => length ¬ attr.value;        ENDCASE;      ENDLOOP;                BEGIN    ENABLE {      ABORTED => {        IF mstream # NIL THEN {Stream.Delete[mstream]; mstream ¬ NIL}	ELSE MFile.DeleteWhenReleased[mfile]; aborted ¬ TRUE; GOTO aborted};      MStream.Error => {        IF Profile.debugging THEN MFileServerDebug.PrintMStream[code];        IF mstream # NIL THEN {Stream.Delete[mstream]; mstream ¬ NIL};        SELECT code FROM          invalidHandle, invalidFile, fileTooLong =>            MFileServerOps.ReportError[              HandleError, @handleInvalid];          invalidOperation, fileNotAvailable =>            MFileServerOps.ReportError[AccessError, @noAccess]          ENDCASE =>            MFileServerOps.ReportError[              UndefinedError, @undefined]};      MFile.Error => {        IF Profile.debugging THEN MFileServerDebug.PrintMFile[code];        IF mstream # NIL THEN {Stream.Delete[mstream]; mstream ¬ NIL};        SELECT code FROM          invalidHandle =>            MFileServerOps.ReportError[              HandleError, @handleInvalid];          illegalName, noSuchFile, noSuchVolume, volumeNotOpen, noRootDirectory,            noSuchDirectory =>            MFileServerOps.ReportError[AccessError, @notFound];          noRoomOnVolume =>            MFileServerOps.ReportError[SpaceError, @noMoreRoom];          directoryFull =>            MFileServerOps.ReportError[              SpaceError, @allocExceeded];          insufficientAccess, protectionFault, conflictingAccess, nullAccess =>            MFileServerOps.ReportError[AccessError, @noAccess];          addressTranslationError =>            MFileServerOps.ReportError[              AttributeValueError, @disallowed];          courierError =>            MFileServerOps.ReportError[              ConnectionError, @otherCallProblem];          connectionSuspended =>            MFileServerOps.ReportError[              ConnectionError, @transportTimeout];          ENDCASE =>            MFileServerOps.ReportError[              UndefinedError, @undefined]}};	          file ¬ MFile.Acquire[h.fullname, anchor, [] ! MFile.Error => CONTINUE];    IF file = NIL THEN fileExist ¬ FALSE    ELSE {MFile.Release[file]; fileExist ¬ TRUE};    IF (MFileServerOps.storeAllowed AND ~fileExist) OR       (MFileServerOps.storeAllowed AND fileExist AND         MFileServerOps.overWriteAllowed) THEN      mfile ¬ MFile.WriteOnly[h.fullname, [], type, length]    ELSE MFileServerOps.ReportError[AccessError, @noAccess];      IF MFileServerOps.logActivity THEN {      MFileServerOps.Write[h.userName];      MFileServerOps.Write[" stored: "L];      MFileServerOps.Write[h.fullname];      MFileServerOps.Write["\n"L]};    mstream ¬ MStream.Create[mfile, []];    XStream.ServerCheckout[cH, [stream[mstream]]];    mfile.SetTimes[create: create];    Stream.Delete[mstream]; mstream ¬ NIL;    EXITS      aborted => {        IF Profile.debugging THEN MFileServerOps.Write["Aborted...\n"L];	MFileServerOps.ReportError[UndefinedError, @undefined]};          END};  DeleteMFile: PUBLIC PROC [   arg: LONG POINTER TO NSFileCourier.DeleteArguments] = {    mfile: MFile.Handle ¬ NIL;    file: LONG STRING ¬ LOOPHOLE[arg.file];    h: MFileServerOps.Handle ¬ LOOPHOLE[arg.session.token];    BEGIN    ENABLE {      UNWIND => IF mfile # NIL THEN mfile.Release[];      MFile.Error => {        IF Profile.debugging THEN MFileServerDebug.PrintMFile[code];        SELECT code FROM          invalidHandle =>            MFileServerOps.ReportError[              HandleError, @handleInvalid];          insufficientAccess, fileIsDirectory, directoryOnSearchPath,            conflictingAccess, nullAccess, directoryNotEmpty, protectionFault =>            MFileServerOps.ReportError[AccessError, @noAccess];          noRoomOnVolume =>            MFileServerOps.ReportError[SpaceError, @noMoreRoom];          directoryFull =>            MFileServerOps.ReportError[              SpaceError, @allocExceeded];          directoryNotEmpty =>            MFileServerOps.ReportError[              AttributeValueError, @disallowed];          illegalName, noSuchFile, noSuchDirectory, noRootDirectory,            noSuchVolume, volumeNotOpen, noRootDirectory, noSuchVolume =>            MFileServerOps.ReportError[AccessError, @notFound];          addressTranslationError =>            MFileServerOps.ReportError[              AttributeValueError, @disallowed];          courierError =>            MFileServerOps.ReportError[              ConnectionError, @otherCallProblem];          connectionSuspended =>            MFileServerOps.ReportError[              ConnectionError, @transportTimeout];          ENDCASE =>            MFileServerOps.ReportError[              UndefinedError, @undefined]}};    mfile ¬ MFile.Acquire[file, delete, []];    mfile.Delete[];    IF MFileServerOps.logActivity THEN {      MFileServerOps.Write[h.userName];      MFileServerOps.Write[" deleted: "L];      MFileServerOps.Write[file];      MFileServerOps.Write["\n"L]};    END};  FindMFile: PUBLIC PROC [    arg: LONG POINTER TO NSFileCourier.FindArguments,    res: LONG POINTER TO NSFileCourier.FindResults] = {    atom: Atom.ATOM ¬ NIL;    dirName: LONG STRING ¬ LOOPHOLE[arg.directory];    h: MFileServerOps.Handle ¬ LOOPHOLE[arg.session.token];    mfile: MFile.Handle ¬ NIL;    BEGIN    ENABLE {      MFile.Error => {        IF Profile.debugging THEN MFileServerDebug.PrintMFile[code];        SELECT code FROM          invalidHandle =>            MFileServerOps.ReportError[              HandleError, @handleInvalid];          illegalName, noSuchFile, noSuchVolume, noRootDirectory,            noSuchDirectory =>            MFileServerOps.ReportError[AccessError, @notFound];          noRoomOnVolume =>            MFileServerOps.ReportError[SpaceError, @noMoreRoom];          directoryFull =>            MFileServerOps.ReportError[              SpaceError, @allocExceeded];          insufficientAccess, protectionFault, conflictingAccess, nullAccess =>            MFileServerOps.ReportError[AccessError, @noAccess];          addressTranslationError, fileIsRemote, volumeNotOpen =>            MFileServerOps.ReportError[              AttributeValueError, @disallowed];          courierError =>            MFileServerOps.ReportError[              ConnectionError, @otherCallProblem];          connectionSuspended =>            MFileServerOps.ReportError[              ConnectionError, @transportTimeout];          ENDCASE =>            MFileServerOps.ReportError[              UndefinedError, @undefined]}};    FindFile: MFile.EnumerateProc = {      mfile ¬ MFile.Acquire[fullName, anchor, []];      h.fullname ¬ fullName;      atom ¬ Atom.MakeAtom[fullName];      done ¬ TRUE};    h.path.length ¬ h.name.length ¬ h.fullname.length ¬ 0;    MFileServerOps.AppendString[h.fullname, dirName, TRUE];    FOR j: CARDINAL IN [0..arg.scope.LENGTH) DO      WITH scope: arg.scope[j] SELECT FROM        depth => MFileServerOps.AppendString[h.name, "**"L];        filter =>          WITH filter: scope.value SELECT FROM            all => MFileServerOps.AppendString[h.name, "*"L];            equal =>              WITH attr: filter.attribute SELECT FROM                name => NSString.AppendToMesaString[h.name, attr.value];                ENDCASE;            matches =>              WITH attr: filter.attribute SELECT FROM                name => NSString.AppendToMesaString[h.name, attr.value];                ENDCASE;            ENDCASE;        ENDCASE;      ENDLOOP;    IF h.name.length > 0 THEN {      ChangeSlash[h.name]; MFileServerOps.AppendString[h.fullname, h.name]};    IF arg.scope.LENGTH = 0 THEN String.AppendChar[h.name, '*];    mfile ¬ MFile.Acquire[h.fullname, anchor, [] ! MFile.Error => CONTINUE];    IF mfile = NIL THEN      MFile.EnumerateDirectory[h.fullname, FindFile, fileAndDirectories]    ELSE atom ¬ Atom.MakeAtom[h.fullname];    IF mfile = NIL THEN      MFileServerOps.ReportError[AccessError, @notFound]    ELSE MFile.Release[mfile];    res.fileHandle ¬ LOOPHOLE[atom];    END;    };      GetMFileAttributes: PUBLIC PROC [    arg: LONG POINTER TO NSFileCourier.GetAttributesArguments,    res: LONG POINTER TO NSFileCourier.GetAttributesResults,    results: Courier.Results,     resultParameters: Courier.Parameters,    zone: UNCOUNTED ZONE] =    {    CleanupResults: PROCEDURE = {Courier.Free[resultParameters, zone]};    h: MFileServerOps.Handle ¬ LOOPHOLE[arg.session.token];    file: LONG STRING ¬ LOOPHOLE[arg.file];    name: LONG STRING ¬ zone.NEW[StringBody [100]];    long: LONG STRING ¬ zone.NEW[StringBody [200]];    create, read: System.GreenwichMeanTime;    length: LONG CARDINAL ¬ 0;    type: MFile.Type;    mfile: MFile.Handle ¬ NIL;    BEGIN    ENABLE      MFile.Error => {        zone.FREE[@name];        zone.FREE[@long];        IF Profile.debugging THEN MFileServerDebug.PrintMFile[code];        SELECT code FROM          invalidHandle =>            MFileServerOps.ReportError[HandleError, @handleInvalid];          illegalName, noSuchFile, noSuchVolume, volumeNotOpen, noRootDirectory,            noSuchDirectory =>            MFileServerOps.ReportError[AccessError, @notFound];          noRoomOnVolume => 	    MFileServerOps.ReportError[SpaceError, @noMoreRoom];          directoryFull =>            MFileServerOps.ReportError[SpaceError, @allocExceeded];          insufficientAccess, protectionFault, conflictingAccess, nullAccess =>            MFileServerOps.ReportError[AccessError, @noAccess];          addressTranslationError =>            MFileServerOps.ReportError[AttributeValueError, @disallowed];          courierError =>            MFileServerOps.ReportError[ConnectionError, @otherCallProblem];          connectionSuspended =>            MFileServerOps.ReportError[ConnectionError, @transportTimeout];          ENDCASE => MFileServerOps.ReportError[UndefinedError, @undefined]};    mfile ¬ MFile.Acquire[file, anchor, []];    [create: create, read: read, length: length, type: type] ¬      mfile.GetProperties[name];    String.AppendString[long, file];    mfile.Release[];    res.attributes ¬ MFileServerOps.CopyAttributes[      h, arg.selections, name, long, create, read, type, length];    END;    [] ¬ results[resultParameters, FALSE ! UNWIND => CleanupResults[]];    zone.FREE[@name];    zone.FREE[@long];    };  --end of GetMFileAttributes  ChangeSlash: PROC [s: LONG STRING] = INLINE {    FOR i: CARDINAL IN [0..s.length) DO IF s[i] = '/ THEN s[i] ¬ '> ENDLOOP; };      }.
-- File: MFileServerImplA.mesa - created by JCS. Last edit:-- AOF                 26-Feb-88  8:08:09-- Nannette            21-Oct-86 10:30:59-- JCS                 19-May-86 10:31:17-- BGY     	        5-Dec-84 16:11:28-- Copyright (C) 1984, 1985, 1986, 1987, 1988 by Xerox Corporation. All rights reserved. DIRECTORY  Atom USING [ATOM, MakeAtom],  Auth USING [    AuthenticateAndReply, AuthenticationError, CallError, CallProblem,    ConversationHandle, FreeVerifier, GetFlavor, IdentityHandle, MakeIdentity],  CH USING [    ConversationHandle, IsMemberClosure, LookupDistinguishedName,    MakeConversationHandle, ReturnCode],  CHPIDs USING [members],  CmFile USING [    Close, Error, FindItem, FreeString, Handle, UserDotCmLine, UserDotCmOpen],  Courier USING [    Dispatcher, Error, ExportRemoteProgram, Free, Handle, InvalidArguments,    NoSuchProcedureNumber, Parameters, SignalRemoteError,    UnexportRemoteProgram],  Exec USING [    AddCommand, ExecProc, FreeTokenString, GetToken, Handle,    OutputProc, RemoveCommand],  Format USING [CR, Line, StringProc],  FormSW USING [DisplayItem],  Heap USING [Create, Delete, systemZone],  MFile USING [    Acquire, ByteCount, EnumerateDirectory, EnumerateProc, Error,    GetFullName, GetProperties, Handle, Release, Type],  MFileServerDebug USING [    PrintAttributes, PrintAttrList, PrintControlList, PrintMFile, PrintScopeList],  MFileServerOps USING [    ActivateTool, AttrSeq, CopyAttributes, CreateMFile, deleteAllowed,    DeleteMFile, DestroyTool, DispatchOther, FileRec, FindMFile, formsw,    GetMFileAttributes, Handle, logActivity, Object, overWriteAllowed,    RetrieveMFile, running, SessionObject, SessionPtr, storeAllowed,    StoreMFile, Write],  NSFile USING [    Attribute, AttributeList, AttributeType, Filter, Handle, ID, Scope,    Session, String],  NSFileCourier USING [    AccessErrorArguments, AttributeSequenceHeader,    AttributeTypeList, AttributeValueErrorArguments,    AuthenticationErrorArguments, classOfService, CloseArguments,    CloseResults, ConnectionErrorArguments, CreateArguments,    CreateResults, DeleteArguments, DeleteResults, FindArguments,    FindResults, GenericArgumentRecord, GenericResultRecord,    GetAttributesArguments, GetAttributesResults, GetRemoteErrorDescriptions,    GetRemoteProcedureDescriptions, HandleErrorArguments, ListArguments,    ListResults, LogoffArguments, LogoffResults, LogonArguments, LogonResults,    OpenArguments, OpenResults, ProbeArguments, ProbeResults, programNumber,    RemoteErrorDescriptionsHandle, RemoteErrorIndex,    RemoteProcedureDescriptionsHandle, RemoteProcedureIndex,    RetrieveArguments, RetrieveResults, Scope, ScopeList,    ScopeValueErrorArguments, SerializeAttributes,    SerializeAttributeSequenceHeader, ServiceErrorArguments,    Session, SessionErrorArguments, SpaceErrorArguments,    StoreArguments, StoreResults, UndefinedErrorArguments, versionNumber, zone],  NSName USING [    EquivalentNames, Error, FreeName, FreeNameFields, MakeName, Name,    NameFieldsFromString, NameRecord, String],  NSString USING [AppendToMesaString, nullString, String, StringFromMesaString],  PhysicalVolume USING [GetHandle, GetHints, Handle],  PilotSwitches USING [heapOwnerChecking],  Profile USING [    debugging, GetDefaultDomain, GetDefaultOrganization, GetID, Qualify],  Stream USING [Delete, Handle],  String USING [AppendChar, AppendString, CopyToNewString, Equivalent, Length],  System USING [GreenwichMeanTime, switches],  Time USING [AppendCurrent],  Token USING [    Boolean, FreeStringHandle, FreeTokenString, Handle, MaybeQuoted,    StandardFilterState, StringToHandle, UnterminatedQuote],  V4NSFileCourier USING [GetV4RemoteProcedureDescriptions],  Volume USING [GetLabelString, ID, InsufficientSpace, systemID],  XStream USING [Create, Handle, ServerCheckout];MFileServerImplA: MONITOR  IMPORTS    Atom, Auth, CH, CmFile, Courier, Exec, Format, FormSW,    Heap, MFile, MFileServerDebug, MFileServerOps, NSFileCourier,    NSName, NSString, PhysicalVolume, Profile, Stream, String, System,    Time, Token, V4NSFileCourier, Volume, XStream  EXPORTS MFileServerOps =  {    OPEN NSFileCourier;  vh: CARDINAL = 5;  --Mumble. I know, but ...  vl: CARDINAL = NSFileCourier.versionNumber;    attrArray: TYPE = ARRAY [0..0) OF NSFile.Attribute;  sessionList: PUBLIC MFileServerOps.SessionPtr ¬ NIL;    AccessList: TYPE = LONG POINTER TO AccessGroups ¬ NIL;  AccessGroups: TYPE = RECORD[    group: NSName.Name ¬ NIL,     distinguishedName: BOOLEAN ¬ FALSE,    next: AccessList];  accessList: AccessList ¬ NIL;  heap: UNCOUNTED ZONE ¬ Heap.Create[    initial: 45, largeNodeThreshold: 2048, increment: 12,    ownerChecking: System.switches[PilotSwitches.heapOwnerChecking] = down];  volName: PUBLIC LONG STRING ¬ [30];  physical: PUBLIC LONG STRING ¬ [30];  nsVolName, nsPhysical: PUBLIC NSString.String ¬ NSString.nullString;  nullRoot: Atom.ATOM ¬ Atom.MakeAtom[""L];  errorDescriptions: NSFileCourier.RemoteErrorDescriptionsHandle =    NSFileCourier.GetRemoteErrorDescriptions[];  ReportError: PUBLIC PROCEDURE [    error: NSFileCourier.RemoteErrorIndex, argumentList: LONG POINTER] = {    ERROR Courier.SignalRemoteError[      errorNumber: LOOPHOLE[error],      arguments: [      location: argumentList,      description: errorDescriptions­[error].arguments]]};  simpleID, strongID: Auth.IdentityHandle ¬ NIL;  useAccessList: BOOLEAN ¬ TRUE;  validDefaults: BOOLEAN ¬ FALSE;  running, logActivity: PUBLIC BOOLEAN ¬ TRUE;  storeAllowed, overWriteAllowed, deleteAllowed: PUBLIC BOOLEAN ¬ FALSE;    --errors  noMoreRoom: NSFileCourier.SpaceErrorArguments ¬ [mediumFull];  noAccess: NSFileCourier.AccessErrorArguments ¬ [accessRightsInsufficient];  handleInvalid: NSFileCourier.HandleErrorArguments ¬ [invalid];  sessionInvalid: NSFileCourier.SessionErrorArguments ¬ [sessionInvalid];  notFound: NSFileCourier.AccessErrorArguments ¬ [fileNotFound];  allocExceeded: NSFileCourier.SpaceErrorArguments ¬ [allocationExceeded];  disallowed: NSFileCourier.AttributeValueErrorArguments ¬ [disallowed, 1];  transportTimeout: NSFileCourier.ConnectionErrorArguments ¬ [transportTimeout];  otherCallProblem: NSFileCourier.ConnectionErrorArguments ¬ [otherCallProblem];  undefined: NSFileCourier.UndefinedErrorArguments ¬ [0];  Dispatch: Courier.Dispatcher    --[cH: Courier.Handle, procedureNumber: CARDINAL,--    -- arguments: Courier.Arguments, results: Courier.Results ]--  = {    CleanupArguments: PROCEDURE = {Courier.Free[argumentParameters, zone]};    CleanupResults: PROCEDURE = {Courier.Free[resultParameters, zone]};    zone: UNCOUNTED ZONE = cH.zone;    resultParameters: Courier.Parameters;    argumentParameters: Courier.Parameters;    procedure: NSFileCourier.RemoteProcedureIndex;    resultListRecord: NSFileCourier.GenericResultRecord;    argumentListRecord: NSFileCourier.GenericArgumentRecord ¬ ALL[0];    procedureDescriptions: NSFileCourier.RemoteProcedureDescriptionsHandle;    argumentList: LONG POINTER TO NSFileCourier.GenericArgumentRecord =      @argumentListRecord;    serviceUnavailable: NSFileCourier.ServiceErrorArguments ¬ [      serviceUnavailable];    resultList: LONG POINTER TO NSFileCourier.GenericResultRecord =      @resultListRecord;    IF MFileServerOps.running = FALSE THEN      ReportError[ServiceError, @serviceUnavailable];    IF procedureNumber > ORD[LAST[NSFileCourier.RemoteProcedureIndex]] THEN      ERROR Courier.NoSuchProcedureNumber;    procedure ¬ LOOPHOLE[procedureNumber];    procedureDescriptions ¬ SELECT cH.versionNumber FROM      4 => V4NSFileCourier.GetV4RemoteProcedureDescriptions[],      5 => NSFileCourier.GetRemoteProcedureDescriptions[],      ENDCASE => NIL;  --Courier already tested for version mismatch?    IF (procedureDescriptions = NIL)  --just a small white lie      OR (procedureDescriptions­[procedure].arguments = NIL) THEN      ERROR Courier.NoSuchProcedureNumber;  --we don't do all of them    argumentParameters ¬ [      location: argumentList,      description: procedureDescriptions­[procedure].arguments];    BEGIN    ENABLE {      Courier.InvalidArguments => REJECT;      Courier.SignalRemoteError => REJECT;      Courier.NoSuchProcedureNumber => REJECT;  -- allow Courier to propagate      Courier.Error =>        SELECT errorCode FROM          callerAborted => CONTINUE;          parameterInconsistency => GOTO argumentsError;          ENDCASE => REJECT;  -- allow Courier to propagate      UNWIND => CleanupArguments[];      Auth.AuthenticationError => {        argRecord: NSFileCourier.AuthenticationErrorArguments ¬ [reason];        ReportError[AuthenticationError, @argRecord]};      Auth.CallError =>        IF reason = badKey THEN {          argRecord: NSFileCourier.AuthenticationErrorArguments ¬ [            verifierInvalid];          ReportError[AuthenticationError, @argRecord]}        ELSE {          argRecord: NSFileCourier.ServiceErrorArguments ¬ [cannotAuthenticate];          ReportError[ServiceError, @argRecord]};      };    resultParameters ¬ [      location: resultList,      description: procedureDescriptions­[procedure].results];    arguments[argumentParameters ! Courier.Error => GOTO argumentsError];    SELECT procedure FROM      Logon => {        OPEN          arg: LOOPHOLE[argumentList,	  LONG POINTER TO NSFileCourier.LogonArguments],          res: LOOPHOLE[resultList, LONG POINTER TO NSFileCourier.LogonResults];        Logon[@arg, @res];        [] ¬ results[resultParameters, FALSE ! UNWIND => CleanupResults[]];        CleanupArguments[];        CleanupResults[];        IF res.session.verifier.LENGTH > 0 THEN          Auth.FreeVerifier[@res.session.verifier, Heap.systemZone];        RETURN;        };      Logoff => {        OPEN          arg: LOOPHOLE[argumentList,	  LONG POINTER TO NSFileCourier.LogoffArguments],          res: LOOPHOLE[resultList, LONG POINTER TO NSFileCourier.LogoffResults];        h: MFileServerOps.Handle ¬ LOOPHOLE[arg.session.token];        IF Profile.debugging THEN MFileServerOps.Write["Logoff called. \n"L];        IF ~CheckSessionList[arg.session.token, FALSE] THEN          ReportError[SessionError, @sessionInvalid];        IF MFileServerOps.logActivity THEN {	  time: LONG STRING ¬ [24];          MFileServerOps.Write[h.userName];          MFileServerOps.Write[" closed connection at "L];	  Time.AppendCurrent[time];	  MFileServerOps.Write[time];          MFileServerOps.Write["\n"L]};        ReleaseCache[h]};      Probe => {        OPEN          arg: LOOPHOLE[argumentList,	  LONG POINTER TO NSFileCourier.ProbeArguments],          res: LOOPHOLE[resultList,	  LONG POINTER TO NSFileCourier.ProbeResults];        res.probeWithin ¬ 6000;        IF Profile.debugging THEN MFileServerOps.Write["Probe called. \n"L];        IF ~CheckSessionList[arg.session.token, FALSE] THEN          ReportError[SessionError, @sessionInvalid];        };      Create => {        OPEN          arg: LOOPHOLE[argumentList,	  LONG POINTER TO NSFileCourier.CreateArguments],          res: LOOPHOLE[resultList,	  LONG POINTER TO NSFileCourier.CreateResults];        dir: LONG STRING ¬ LOOPHOLE[arg.directory];        IF Profile.debugging THEN {          MFileServerOps.Write["Create called:\n"L];          MFileServerOps.Write["  Directory: "L];          MFileServerOps.Write[dir];          MFileServerOps.Write["\n"L];          MFileServerDebug.PrintAttributes[arg.attributes];          MFileServerDebug.PrintControlList[arg.controls]};        IF ~CheckSessionList[arg.session.token, FALSE] THEN          ReportError[SessionError, @sessionInvalid];        MFileServerOps.CreateMFile[@arg, @res, dir];        };      Delete => {        OPEN          arg: LOOPHOLE[argumentList,	  LONG POINTER TO NSFileCourier.DeleteArguments],          res: LOOPHOLE[resultList,	  LONG POINTER TO NSFileCourier.DeleteResults];        file: LONG STRING ¬ LOOPHOLE[arg.file];        IF Profile.debugging THEN {          MFileServerOps.Write["Delete called.\n"L];          MFileServerOps.Write["  File: "L];          MFileServerOps.Write[file];          MFileServerOps.Write["\n"L]};        IF ~MFileServerOps.deleteAllowed THEN          ReportError[AccessError, @noAccess]        ELSE          IF ~CheckSessionList[arg.session.token, FALSE] THEN            ReportError[SessionError, @sessionInvalid]          ELSE MFileServerOps.DeleteMFile[@arg];        };      List => {        OPEN          arg: LOOPHOLE[argumentList,	  LONG POINTER TO NSFileCourier.ListArguments],          res: LOOPHOLE[resultList,	  LONG POINTER TO NSFileCourier.ListResults];        dir: LONG STRING ¬ LOOPHOLE[arg.directory];        IF Profile.debugging THEN {          MFileServerOps.Write["List called:\n"L];          MFileServerOps.Write["  Directory: "L];          MFileServerOps.Write[dir];          MFileServerOps.Write["\n"L];          MFileServerDebug.PrintAttrList[arg.selections];          MFileServerDebug.PrintScopeList[arg.scope]};        IF ~CheckSessionList[arg.session.token, FALSE] THEN          ReportError[SessionError, @sessionInvalid];        ListMFile[@arg, @res, dir, cH];        };      GetAttributes => {        OPEN          arg: LOOPHOLE[argumentList,	  LONG POINTER TO            NSFileCourier.GetAttributesArguments],          res: LOOPHOLE[resultList,	   LONG POINTER TO            NSFileCourier.GetAttributesResults];        IF Profile.debugging THEN {          MFileServerOps.Write["GetAttributes called:\n"L];          MFileServerDebug.PrintAttrList[arg.selections]};        IF ~CheckSessionList[arg.session.token, FALSE] THEN          ReportError[SessionError, @sessionInvalid];        MFileServerOps.GetMFileAttributes[	  @arg, @res, results, resultParameters, zone];        res.attributes ¬ DESCRIPTOR[NIL, 0];        CleanupArguments[];        CleanupResults[];        RETURN;        };      Open => {        OPEN          arg: LOOPHOLE[argumentList, LONG POINTER TO NSFileCourier.OpenArguments],          res: LOOPHOLE[resultList, 	  LONG POINTER TO NSFileCourier.OpenResults];        IF Profile.debugging THEN {          MFileServerOps.Write["Open called:\n"L];          MFileServerDebug.PrintAttributes[arg.attributes];          MFileServerDebug.PrintControlList[arg.controls]};        IF ~CheckSessionList[arg.session.token, FALSE] THEN          ReportError[SessionError, @sessionInvalid];        OpenMFile[@arg, @res];        };      Close => {        OPEN          arg: LOOPHOLE[argumentList, 	  LONG POINTER TO NSFileCourier.CloseArguments],          res: LOOPHOLE[resultList, 	  LONG POINTER TO NSFileCourier.CloseResults];        IF Profile.debugging THEN MFileServerOps.Write["Close called:\n"L];        };      Retrieve => {        OPEN          arg: LOOPHOLE[argumentList, 	  LONG POINTER TO            NSFileCourier.RetrieveArguments],          res: LOOPHOLE[resultList, 	  LONG POINTER TO NSFileCourier.RetrieveResults];        file: LONG STRING ¬ LOOPHOLE[arg.file];        IF Profile.debugging THEN {          MFileServerOps.Write["Retrieve called:\n"L];          MFileServerOps.Write["  File: "L];          MFileServerOps.Write[file];          MFileServerOps.Write["\n"L]};        IF ~CheckSessionList[arg.session.token, FALSE] THEN          ReportError[SessionError, @sessionInvalid];        MFileServerOps.RetrieveMFile[@arg, @res, file, cH];        };      Store => {        OPEN          arg: LOOPHOLE[argumentList, 	  LONG POINTER TO NSFileCourier.StoreArguments],          res: LOOPHOLE[resultList, 	  LONG POINTER TO NSFileCourier.StoreResults];        dir: LONG STRING ¬ LOOPHOLE[arg.directory];        IF Profile.debugging THEN {          MFileServerOps.Write["Store called:\n"L];          MFileServerOps.Write["  Directory: "L];          MFileServerOps.Write[dir];          MFileServerOps.Write["\n"L];          MFileServerDebug.PrintControlList[arg.controls];          MFileServerDebug.PrintAttributes[arg.attributes]};        IF ~CheckSessionList[arg.session.token, FALSE] THEN          ReportError[SessionError, @sessionInvalid];        MFileServerOps.StoreMFile[@arg, @res, dir, cH];        };      Find => {        OPEN          arg: LOOPHOLE[argumentList, 	  LONG POINTER TO NSFileCourier.FindArguments],          res: LOOPHOLE[resultList, 	  LONG POINTER TO NSFileCourier.FindResults];        dir: LONG STRING ¬ LOOPHOLE[arg.directory];        IF Profile.debugging THEN {          MFileServerOps.Write["Find called:\n"L];          MFileServerOps.Write["  Directory: "L];          MFileServerOps.Write[dir];          MFileServerOps.Write["\n"L];          MFileServerDebug.PrintScopeList[arg.scope]};        IF ~CheckSessionList[arg.session.token, FALSE] THEN          ReportError[SessionError, @sessionInvalid];        MFileServerOps.FindMFile[@arg, @res]};      ENDCASE =>         MFileServerOps.DispatchOther[cH, procedureNumber, arguments, results];    END;  -- of enable    [] ¬ results[resultParameters, FALSE ! UNWIND => CleanupResults[]];    CleanupArguments[];    CleanupResults[];    EXITS argumentsError => ERROR Courier.InvalidArguments;    };  --Dispatch  Logon: PUBLIC PROC [    arg: 	LONG POINTER TO NSFileCourier.LogonArguments,    res: 	LONG POINTER TO NSFileCourier.LogonResults] =    BEGIN    myId: Auth.IdentityHandle ¬ NIL;    initiator: NSName.Name ¬ NIL;    h: MFileServerOps.Handle ¬ AcquireCache[];    MyGetID: PROC [id: Auth.IdentityHandle] = {myId ¬ id};    BEGIN    ENABLE      UNWIND => {        IF initiator # NIL THEN NSName.FreeName[Heap.systemZone, initiator];        IF res.session.verifier.LENGTH > 0 THEN          Auth.FreeVerifier[@res.session.verifier, Heap.systemZone]};    res.session.verifier ¬ DESCRIPTOR[NIL, 0];    IF validDefaults THEN {      myId ¬ SELECT Auth.GetFlavor[arg.credentials] FROM        simple => simpleID,        ENDCASE => strongID}    ELSE Profile.GetID[Auth.GetFlavor[arg.credentials], MyGetID];    --Profile.GetID does not return NIL if name, password, org, domain are NIL    IF myId = NIL THEN {      validDefaults ¬ FALSE; ERROR Auth.CallError[badKey, notApplicable]};    [initiator, res.session.verifier] ¬ Auth.AuthenticateAndReply[      myId, arg.credentials, arg.verifier, Heap.systemZone !      Auth.AuthenticationError => {ReleaseCache[h]; REJECT}];    h.userName.length ¬ 0;    NSString.AppendToMesaString[h.userName, initiator.local];    String.AppendChar[h.userName, ':];    NSString.AppendToMesaString[h.userName, initiator.domain];    String.AppendChar[h.userName, ':];    NSString.AppendToMesaString[h.userName, initiator.org];    --do you really want to know who is logged on your machine.    IF Profile.debugging THEN {      MFileServerOps.Write["Logon called: "L];      MFileServerOps.Write[h.userName];      MFileServerOps.Write["\n"L]};    IF accessList # NIL AND useAccessList THEN {      temp: AccessList ¬ accessList;      IF ~IsMemberClosure[myId, temp, initiator] THEN {        MFileServerOps.Write[h.userName];         MFileServerOps.Write[" does not have access\n"L];        ReportError[AccessError, @noAccess]}};    IF initiator # NIL THEN NSName.FreeName[Heap.systemZone, initiator];    END;    IF MFileServerOps.logActivity THEN {      time: LONG STRING ¬ [24];      MFileServerOps.Write[h.userName];      MFileServerOps.Write[" opened connection at "L];      Time.AppendCurrent[time];      MFileServerOps.Write[time];      MFileServerOps.Write["\n"L]};    h.rootDir.length ¬ 0;    NSString.AppendToMesaString[h.rootDir, arg.service.local];    res.session.token ¬ LOOPHOLE[h];    AddToSessionList[res.session.token];    IF Profile.debugging THEN {      MFileServerOps.Write["  Services: "L];      MFileServerOps.Write[h.rootDir];      MFileServerOps.Write["\n"L]};    END;  ListMFile: PUBLIC PROC [    arg: LONG POINTER TO NSFileCourier.ListArguments,    res:  LONG POINTER TO NSFileCourier.ListResults, dir: LONG STRING,    cH: Courier.Handle] = {    sinkDS: Stream.Handle;    scopeobj: NSFile.Scope;    attributes: NSFile.AttributeList;    aborted, decrement, found: BOOLEAN ¬ FALSE;    h: MFileServerOps.Handle ¬ LOOPHOLE[arg.session.token];    path: LONG STRING ¬ NSFileCourier.zone.NEW[StringBody [200]];    long: LONG STRING ¬ NSFileCourier.zone.NEW[StringBody [200]];    ender: NSFileCourier.AttributeSequenceHeader ¬ [type: lastSegment, lists: 0];    header: NSFileCourier.AttributeSequenceHeader ¬ [type: nextSegment, lists: 1];    Lister: MFile.EnumerateProc = {      BEGIN      ENABLE {        MFile.Error => {          IF Profile.debugging THEN MFileServerDebug.PrintMFile[code];          SELECT code FROM            invalidHandle =>              ReportError[HandleError, @handleInvalid];            illegalName, noSuchFile =>              ReportError[AccessError, @notFound];            noRoomOnVolume =>              ReportError[SpaceError, @noMoreRoom];            directoryFull =>              ReportError[SpaceError, @allocExceeded];            insufficientAccess, protectionFault, conflictingAccess =>              ReportError[AccessError, @noAccess];            ENDCASE => ReportError[UndefinedError, @undefined]};        };      mfile: MFile.Handle ¬ fileProc[anchor, []];      create, write, read: System.GreenwichMeanTime;      length: MFile.ByteCount;      found ¬ TRUE;      long.length ¬ 0;      [create: create, write: write, read: read, length: length] ¬        mfile.GetProperties[];      mfile.GetFullName[long];      mfile.Release[];      attributes ¬ MFileServerOps.CopyAttributes[        h, arg.selections, name, long, create, read, type, length];      BEGIN      ENABLE ABORTED => {aborted ¬ TRUE; GOTO aborted};      NSFileCourier.SerializeAttributeSequenceHeader[header, sinkDS];      NSFileCourier.SerializeAttributes[attributes, sinkDS];      EXITS aborted => done ¬ TRUE;      END;      END;      };          SendAttributes: PROC[xs: XStream.Handle] = {      ENABLE UNWIND => Stream.Delete[sinkDS];      sinkDS ¬ XStream.Create[xs];      MFile.EnumerateDirectory[path, Lister, fileAndDirectories !        MFile.Error => {	illegalFileName: ScopeValueErrorArguments ¬ [illegal, filter]; 	  SELECT code FROM	    illegalName, noRootDirectory =>	      ReportError[ScopeValueError, @illegalFileName];	    fileIsRemote, volumeNotOpen =>	      ReportError[AttributeValueError,@disallowed];	    ENDCASE => ReportError[UndefinedError, @undefined]}];       SerializeAttributeSequenceHeader[ender, sinkDS];      Stream.Delete[sinkDS];      };    BEGIN    ENABLE {      ABORTED => {aborted ¬ TRUE; GOTO quit};      Volume.InsufficientSpace => {};      UNWIND => {NSFileCourier.zone.FREE[@path]; NSFileCourier.zone.FREE[@long]}};    path.length ¬ 0;    AppendString[path, dir, TRUE];    scopeobj ¬ ProcessScopeArguments[scope: arg.scope, name: @path];    IF arg.scope.LENGTH = 0 THEN String.AppendChar[path, '*];    IF Profile.debugging THEN {      MFileServerOps.Write["  File enumerated: "L];      MFileServerOps.Write[path];      MFileServerOps.Write["\n"L]};    XStream.ServerCheckout[cH, [proc[SendAttributes]]];    EXITS quit => ReportError[UndefinedError, @undefined];    END;    IF ~found THEN ReportError[AccessError, @notFound];    NSFileCourier.zone.FREE[@path];    NSFileCourier.zone.FREE[@long];    };  OpenMFile: PUBLIC PROC [    arg: 	LONG POINTER TO NSFileCourier.OpenArguments,    res: 	LONG POINTER TO NSFileCourier.OpenResults] = {    mfile: MFile.Handle ¬ NIL;    isDir, useFID, isnull: BOOLEAN ¬ FALSE;    atom: Atom.ATOM ¬ NIL;    dirName: LONG STRING ¬ LOOPHOLE[arg.directory];    id: MFileServerOps.FileRec ¬ [init[[0, 0, 0, 0, 0]]];    h: MFileServerOps.Handle ¬ LOOPHOLE[arg.session.token];    BEGIN    ENABLE {      MFile.Error => {        IF Profile.debugging THEN MFileServerDebug.PrintMFile[code];        SELECT code FROM          invalidHandle =>            ReportError[HandleError, @handleInvalid];          illegalName, noSuchFile, noSuchVolume, volumeNotOpen, noRootDirectory,            noSuchDirectory, noSuchVolume =>            ReportError[AccessError, @notFound];          noRoomOnVolume => ReportError[SpaceError, @noMoreRoom];          directoryFull =>            ReportError[SpaceError, @allocExceeded];          insufficientAccess, protectionFault, conflictingAccess, nullAccess =>            ReportError[AccessError, @noAccess];          addressTranslationError =>            ReportError[AttributeValueError, @disallowed];          courierError =>            ReportError[ConnectionError, @otherCallProblem];          connectionSuspended =>            ReportError[ConnectionError, @transportTimeout];          ENDCASE => ReportError[UndefinedError, @undefined]};      };    h.path.length ¬ h.name.length ¬ h.fullname.length ¬ 0;    FOR i: CARDINAL IN [0..arg.attributes.LENGTH) DO      WITH a: arg.attributes[i] SELECT FROM        name => NSString.AppendToMesaString[h.name, a.value];        pathname => NSString.AppendToMesaString[h.path, a.value];        fileID => {id.nid ¬ a.value; useFID ¬ TRUE};        ENDCASE;      ENDLOOP;    IF String.Length[dirName] > 0 THEN AppendString[h.fullname, dirName];    SELECT TRUE FROM      useFID => AppendString[h.fullname, id.pid];      h.path.length > 0 => {        IF h.name.length > 0 THEN {          ChangeSlash[h.path];          AppendString[h.fullname, h.path];          ChangeSlash[h.name];          AppendString[h.fullname, h.name]}        ELSE {          ChangeSlash[h.path]; AppendString[h.fullname, h.path]; isDir ¬ TRUE}};      h.name.length > 0 => {        ChangeSlash[h.name]; AppendString[h.fullname, h.name]};      arg.attributes.LENGTH > 0 AND h.name.length = 0 =>        String.AppendString[h.fullname, "<>"L]      ENDCASE => {h.fullname.length ¬ 0; isnull ¬ TRUE};    IF Profile.debugging THEN {      MFileServerOps.Write["  MFile name: "L];      MFileServerOps.Write[h.fullname];      IF isnull THEN MFileServerOps.Write["null file"L];      MFileServerOps.Write["\n"L]};    IF ~isnull THEN {      mfile ¬ MFile.Acquire[h.fullname, anchor, []]; mfile.Release[]};    atom ¬ Atom.MakeAtom[h.fullname];    res.file ¬ LOOPHOLE[atom];    END;    };  ProcessScopeArguments: PROCEDURE [    scope: NSFileCourier.ScopeList, name: LONG POINTER TO LONG STRING]    RETURNS [NSFile.Scope] = {    scopeObject: NSFile.Scope;    FOR j: CARDINAL IN [0..scope.LENGTH) DO      WITH s: scope[j] SELECT FROM        count => scopeObject.count ¬ s.value;        depth => {          scopeObject.depth ¬ s.value;          IF name­.length = 0 THEN String.AppendString[name­, "**"L]          ELSE AppendString[name­, "**"L]};        direction => scopeObject.direction ¬ s.value;        filter => ProcessFilter[s.value, name];        ordering => {};  --ProcessOrdering[s.value];        ENDCASE;      ENDLOOP;    RETURN[scopeObject]};  ProcessFilter: PROCEDURE [    filter: NSFile.Filter, name: LONG POINTER TO LONG STRING ¬ NIL] = {    WITH f: filter SELECT FROM      less, lessOrEqual, notEqual, greaterOrEqual, greater => {};      equal =>        WITH attr: f.attribute SELECT FROM          name => NSString.AppendToMesaString[name­, attr.value];          ENDCASE;      matches =>        WITH attr: f.attribute SELECT FROM          name => NSString.AppendToMesaString[name­, attr.value];          ENDCASE;      and, or => ProcessFilters[f.list, name];      not => ProcessFilter[f, name];      none => {};      all => AppendString[name­, "*"L];      ENDCASE};  ProcessFilters: PROCEDURE [    filters: LONG DESCRIPTOR FOR ARRAY CARDINAL OF NSFile.Filter,    name: LONG POINTER TO LONG STRING] = {    FOR i: CARDINAL IN [0..filters.LENGTH) DO      ProcessFilter[filters[i], name] ENDLOOP;    };  AppendString: PUBLIC PROC [to, from: LONG STRING, isDir: BOOLEAN ¬ FALSE] = {    i: CARDINAL ¬ 0;    IF from = nullRoot THEN RETURN;    IF to.length = 0 THEN {      SELECT from[0] FROM        '> => String.AppendChar[to, '<];        '< => NULL;        ENDCASE => String.AppendChar[to, '<];      String.AppendString[to, from];      IF ~Match[to] THEN String.AppendChar[to, '>];      }    ELSE {      IF to[to.length - 1] # '> THEN String.AppendChar[to, '>];      String.AppendString[to, from];      IF ~Match[to] THEN String.AppendChar[to, '>];      };    IF isDir AND to[to.length - 1] # '> THEN String.AppendChar[to, '>];    FOR i DECREASING IN [0..to.length) DO      IF to[i] = '! THEN {to.length ¬ i; EXIT}; ENDLOOP;    };  Match: PROC [s: LONG STRING] RETURNS [match: BOOLEAN ¬ FALSE] = {    count: INTEGER ¬ 0;    FOR i: CARDINAL IN [0..s.length) DO      SELECT s[i] FROM        '> => count ¬ count - 1;        '< => count ¬ count + 1;        ENDCASE;      ENDLOOP;    IF count <= 0 THEN match ¬ TRUE;    };  Cache: TYPE = LONG POINTER TO CacheObject;  CacheObject: TYPE = RECORD [    h: MFileServerOps.Object, next: Cache, cached: BOOLEAN ¬ FALSE];  cache: Cache ¬ NIL;  AcquireCache: ENTRY PROC RETURNS [h: MFileServerOps.Handle] = {    IF cache = NIL THEN RETURN[NewObject[]];    h ¬ LOOPHOLE[cache];    cache ¬ cache.next;    };  ReleaseCache: ENTRY PROC [h: MFileServerOps.Handle] = {    c: Cache ¬ LOOPHOLE[h];    IF c.cached = FALSE THEN {FreeObject[h]; RETURN};    c.next ¬ cache;    cache ¬ c;    };  AddToSessionList: ENTRY PROC [session: NSFile.Session] = {    newSessionPtr: MFileServerOps.SessionPtr ¬ heap.NEW[      MFileServerOps.SessionObject];    newSessionPtr.session ¬ session;    newSessionPtr.next ¬ sessionList;    sessionList ¬ newSessionPtr};  CheckSessionList: ENTRY PROC [session: NSFile.Session, remove: BOOLEAN]    RETURNS [BOOLEAN] = {    tempCache1: MFileServerOps.SessionPtr ¬ NIL;    tempCache2: MFileServerOps.SessionPtr ¬ sessionList;    UNTIL tempCache2 = NIL DO      IF session = tempCache2.session THEN {        IF remove = FALSE THEN RETURN[TRUE]        ELSE {          IF tempCache1 = NIL THEN sessionList ¬ tempCache2.next          ELSE tempCache1.next ¬ tempCache2.next;          heap.FREE[@tempCache2];          RETURN[TRUE]}}      ELSE {tempCache1 ¬ tempCache2; tempCache2 ¬ tempCache2.next}      ENDLOOP;    RETURN[FALSE]};  ChangeSlash: PROC [s: LONG STRING] = INLINE {    FOR i: CARDINAL IN [0..s.length) DO IF s[i] = '/ THEN s[i] ¬ '> ENDLOOP; };  NewObject: PROC RETURNS [h: MFileServerOps.Handle] = {    c: Cache ¬ heap.NEW[      CacheObject ¬ [      h: [      userName: heap.NEW[StringBody [100]], name: heap.NEW[StringBody [100]],      path: heap.NEW[StringBody [200]], fullname: heap.NEW[StringBody [200]],      rootDir: heap.NEW[StringBody [100]],      sequence: heap.NEW[MFileServerOps .AttrSeq[20]]], next: cache,      cached: FALSE]];    h ¬ LOOPHOLE[c];    };  FreeObject: PROC [h: MFileServerOps.Handle] = {    c: Cache ¬ LOOPHOLE[h];    heap.FREE[@h.userName];    heap.FREE[@h.name];    heap.FREE[@h.path];    heap.FREE[@h.fullname];    heap.FREE[@h.rootDir];    heap.FREE[@h.sequence];    heap.FREE[@c];    };      MakeNSName: PROC[string: LONG STRING]    RETURNS[nsname: NSName.Name ¬ NIL, ok: BOOLEAN ¬ FALSE] = {    nsname ¬ NSName.MakeName[heap];    NSName.NameFieldsFromString[      z: heap,  destination: nsname, s: NSString.StringFromMesaString[string]!      NSName.Error => {        GOTO nope}];    ok ¬ TRUE;    EXITS nope => NULL;    };      IsMemberClosure: PROCEDURE[    id: Auth.IdentityHandle, list: AccessList , name: NSName.Name]    RETURNS[ismember: BOOLEAN ¬ FALSE] = {    rc: CH.ReturnCode;    ch: CH.ConversationHandle ¬ [NIL, NIL];    auth: Auth.CallProblem;    ok: BOOLEAN;    [ch, ok, auth] ¬ CH.MakeConversationHandle[id, heap];    IF ~ok THEN {      MFileServerOps.Write["Authentication problem.\n"L];      RETURN[FALSE]};    WHILE list # NIL DO      IF ~list.distinguishedName THEN {        rc ¬ CH.LookupDistinguishedName[ch, list.group, list.group];	SELECT rc.code FROM	  done => NULL;	  rejectedTooBusy, allDown, wasUpNowDown => {	    MFileServerOps.Write["Clearinghouse down or busy.\n"L];	    RETURN[FALSE]};	  illegalOrgName, illegalDomainName, illegalLocalName, noSuchOrg, noSuchDomain, noSuchLocal =>	    MFileServerOps.Write["Invalid name/group specified in accessList.\n"L];	  ENDCASE => {	    MFileServerOps.Write["Other clearinghouse problem.\n"L];	    RETURN[FALSE]};	list.distinguishedName ¬ TRUE};      IF NSName.EquivalentNames[name, list.group] THEN RETURN [TRUE];      [rc, ismember] ¬ CH.IsMemberClosure[        ch, name, list.group, CHPIDs.members, NIL];      IF ismember THEN RETURN [TRUE];      list ¬ list.next;      ENDLOOP;    };  Main: Exec.ExecProc = {    [] ¬ ProcessExecCommands[h]; MFileServerOps.ActivateTool[]};  Unload: Exec.ExecProc = {    h.RemoveCommand["MFileServer.~"L];    MFileServerOps.DestroyTool[];    Courier.UnexportRemoteProgram[NSFileCourier.programNumber, [vl, vh]];    Heap.Delete[heap];    };  MFileServerHelp: Exec.ExecProc = {    Exec.OutputProc[h][      "The variables of the MFileServer are 'running', 'logActivity', 'storeAllowed', 'overwriteAllowed', and 'deleteAllowed'. These variables can be set in the user.cm or on the command line. MFileServer will accept a series of arguments of the form, variable/switch. If the variable has no switch or is an illegal switch, the value of the switch is taken from the user.cm or is defaulted. If the variable has a switch, the variable will be set to the value of the switch. All variables take the switches 'on' and 'off'. If MFileServer is invoked with no arguments, the current values are taken from the user.cm or is defaulted. Example: >MFileServer storeallowed/on deleteallowed/on overwriteallowed/on running/off"L]};  DisplayCurrentState: PROC [h: Exec.Handle] = {    string: LONG STRING ¬ [150];    list: AccessList ¬ NIL;    WriteMsg: Format.StringProc ¬ Exec.OutputProc[h];    WriteOnOrOff: PROC [on: BOOLEAN] = {      IF on THEN Format.Line[WriteMsg, "on"L]      ELSE Format.Line[WriteMsg, "off"L]};    Format.CR[WriteMsg];    Format.Line[WriteMsg, "Current State of MFileServer: "L];    WriteMsg["Running: "L];    WriteOnOrOff[MFileServerOps.running];    WriteMsg["LogActivity: "L];    WriteOnOrOff[MFileServerOps.logActivity];    WriteMsg["StoreAllowed: "L];    WriteOnOrOff[MFileServerOps.storeAllowed];    WriteMsg["OverWriteAllowed: "L];    WriteOnOrOff[MFileServerOps.overWriteAllowed];    WriteMsg["DeleteAllowed: "L];    WriteOnOrOff[MFileServerOps.deleteAllowed];    WriteMsg["AccessList: "L];    IF accessList = NIL THEN WriteMsg["*:*:*"L]    ELSE {      list ¬ accessList;      DO        string.length ¬ 0;        NSString.AppendToMesaString[string, list.group.local];	String.AppendChar[string, ':];	NSString.AppendToMesaString[string, list.group.domain];	String.AppendChar[string, ':];	NSString.AppendToMesaString[string, list.group.org];	WriteMsg[string];	list ¬ list.next;	IF list # NIL THEN WriteMsg[", "]	ELSE EXIT;	ENDLOOP;      WriteMsg["\n"L]};    IF ~useAccessList THEN WriteMsg["ignoring AccessList\n"L];    };  ProcessExecCommands: Exec.ExecProc = {    WriteMsg: Format.StringProc = Exec.OutputProc[h];    token, switches: LONG STRING ¬ NIL;    validSwitch: BOOLEAN ¬ TRUE;    on: BOOLEAN ¬ FALSE;    DO      [token, switches] ¬ Exec.GetToken[h];      SELECT TRUE FROM        token = NIL AND switches = NIL => {          token ¬ Exec.FreeTokenString[token];          switches ¬ Exec.FreeTokenString[switches];          EXIT};        token # NIL AND switches # NIL => {          validSwitch ¬ TRUE;          SELECT TRUE FROM            String.Equivalent[switches, "on"L] => on ¬ TRUE;            String.Equivalent[switches, "off"L] => on ¬ FALSE;            ENDCASE => {              WriteMsg["Unknown switch: "L];              Format.Line[WriteMsg, switches];              validSwitch ¬ FALSE};          IF validSwitch THEN            SELECT TRUE FROM              String.Equivalent[token, "storeAllowed"L] => {                MFileServerOps.storeAllowed ¬ on;                IF MFileServerOps.formsw # NIL THEN                  FormSW.DisplayItem[MFileServerOps.formsw, 2]};              String.Equivalent[token, "running"L] => {                MFileServerOps.running ¬ on;                IF MFileServerOps.formsw # NIL THEN                  FormSW.DisplayItem[MFileServerOps.formsw, 0]};              String.Equivalent[token, "logActivity"L] => {                MFileServerOps.logActivity ¬ on;                IF MFileServerOps.formsw # NIL THEN                  FormSW.DisplayItem[MFileServerOps.formsw, 1]};              String.Equivalent[token, "deleteAllowed"L] => {                MFileServerOps.deleteAllowed ¬ on;                IF MFileServerOps.formsw # NIL THEN                  FormSW.DisplayItem[MFileServerOps.formsw, 4]};              String.Equivalent[token, "overwriteAllowed"L] => {                MFileServerOps.overWriteAllowed ¬ on;                IF MFileServerOps.formsw # NIL THEN                  FormSW.DisplayItem[MFileServerOps.formsw, 3]};	      String.Equivalent[token, "useAccessList"L] =>                 useAccessList ¬ on;              ENDCASE => {                WriteMsg["Unknown command: "L]; Format.Line[WriteMsg, token]}};        ENDCASE;      ENDLOOP;    DisplayCurrentState[h];    token ¬ Exec.FreeTokenString[token];    switches ¬ Exec.FreeTokenString[switches]};      InitVars: PROCEDURE = {            Volume.GetLabelString[Volume.systemID, volName];    [] ¬ PhysicalVolume.GetHints[PhysicalVolume.GetHandle[0], physical];    nsVolName ¬ NSString.StringFromMesaString[volName];    nsPhysical ¬ NSString.StringFromMesaString[physical];    THROUGH [0..4) DO      cache ¬ heap.NEW[        CacheObject ¬ [        h: [        userName: heap.NEW[StringBody [100]], name: heap.NEW[StringBody [100]],        path: heap.NEW[StringBody [200]], fullname: heap.NEW[StringBody [200]],        rootDir: heap.NEW[StringBody [100]],        sequence: heap.NEW[MFileServerOps .AttrSeq[20]]], next: cache,        cached: TRUE]];      ENDLOOP;};  ProcessUserCm: PROCEDURE = {    letAllIn, badEntry: BOOLEAN ¬ FALSE;    userCm: CmFile.Handle ¬ NIL;    value, initialState: LONG STRING ¬ NIL;    s: Token.StandardFilterState ¬ [0,0];    endAccessList, newAccessGroup: AccessList;    userCm ¬ CmFile.UserDotCmOpen[ ! CmFile.Error => CONTINUE];    IF userCm # NIL THEN {      --user ¬ CmFile.UserDotCmLine["MFileServer"L, "User"L];      --password ¬ CmFile.UserDotCmLine["MFileServer"L, "Password"L];      IF CmFile.FindItem[userCm, "MFileServer"L, "Running"L] THEN        MFileServerOps.running ¬ Token.Boolean[userCm, FALSE];      initialState ¬ CmFile.UserDotCmLine["MFileServer"L, "InitialState"L];      IF initialState # NIL THEN {        IF String.Equivalent[initialState, "inactive"L] THEN 	  MFileServerOps.running ¬ FALSE; 	initialState ¬ CmFile.FreeString[initialState]};      IF CmFile.FindItem[userCm, "MFileServer"L, "LogActivity"L] THEN        MFileServerOps.logActivity ¬ Token.Boolean[userCm, FALSE];      IF CmFile.FindItem[userCm, "MFileServer"L, "StoreAllowed"L] THEN        MFileServerOps.storeAllowed ¬ Token.Boolean[userCm, FALSE];      IF CmFile.FindItem[userCm, "MFileServer"L, "OverWriteAllowed"L] THEN        MFileServerOps.overWriteAllowed ¬ Token.Boolean[userCm, FALSE];      IF CmFile.FindItem[userCm, "MFileServer"L, "DeleteAllowed"L] THEN        MFileServerOps.deleteAllowed ¬ Token.Boolean[userCm, FALSE];      IF CmFile.FindItem[userCm, "MFileServer"L, "UseAccessList"L] THEN        useAccessList ¬ Token.Boolean[userCm, FALSE];      IF CmFile.FindItem[userCm, "MFileServer"L, "AccessList"L] THEN {        h: Token.Handle;        groupName: LONG STRING ¬ NIL;	fullGroupName: LONG STRING ¬ [100];	value ¬ CmFile.UserDotCmLine["MFileServer"L, "AccessList"L !          CmFile.Error => CONTINUE];	h ¬ Token.StringToHandle[value];	DO	  groupName ¬ h.MaybeQuoted[@s ! Token.UnterminatedQuote => RESUME];	  IF groupName = NIL THEN EXIT;	  IF groupName[groupName.length-1] = ', THEN 	    groupName.length ¬ groupName.length - 1;	  IF String.Equivalent[groupName, "*:*:*"L] THEN {letAllIn ¬ TRUE; EXIT};	  badEntry ¬ FALSE;	  FOR i: CARDINAL IN [0..groupName.length) DO	    IF groupName[i] = '* THEN {	      MFileServerOps.Write[	        "MFileServer: invalid name/group specified in access list"L];	      badEntry ¬ TRUE;	      EXIT};	    ENDLOOP;	  IF badEntry THEN LOOP;	  fullGroupName.length ¬ 0;	  newAccessGroup ¬ heap.NEW[AccessGroups];	  Profile.Qualify[groupName, fullGroupName, clearinghouse];	  [newAccessGroup.group,] ¬ MakeNSName[fullGroupName];	  groupName ¬ Token.FreeTokenString[groupName];	  IF accessList = NIL THEN accessList ¬ newAccessGroup	  ELSE endAccessList.next ¬ newAccessGroup;	  endAccessList ¬ newAccessGroup;	  ENDLOOP;	IF letAllIn THEN {heap.FREE[@accessList]; accessList ¬ NIL};        h ¬ Token.FreeStringHandle[h]};      userCm ¬ CmFile.Close[userCm];      }};  Init: PROC = {    domain, org, user, password: LONG STRING ¬ NIL;    defaults, nameRecord: NSName.NameRecord;    GetOrg: PROC [s: LONG STRING] = {org ¬ String.CopyToNewString[s, heap]};    GetDomain: PROC [s: LONG STRING] = {      domain ¬ String.CopyToNewString[s, heap]};    InitVars[];    ProcessUserCm[];    Courier.ExportRemoteProgram[      programNumber: NSFileCourier.programNumber, versionRange: [vl, vh],      dispatcher: Dispatch, serviceName: "MFileServer"L, zone: Heap.systemZone,      classOfService: NSFileCourier.classOfService ! Courier.Error => CONTINUE];    -- Get default Identity    Profile.GetDefaultDomain[GetDomain];    Profile.GetDefaultOrganization[GetOrg];    defaults ¬ [      org: NSString.StringFromMesaString[org],      domain: NSString.StringFromMesaString[domain],      local: NSString.nullString];    IF String.Length[user] > 0 THEN      NSName.NameFieldsFromString[        z: heap, s: NSString.StringFromMesaString[user],        destination: @nameRecord, clientDefaults: @defaults];    IF (String.Length[user] > 0) AND (String.Length[password] > 0) THEN {      simpleID ¬ Auth.MakeIdentity[        @nameRecord, NSString.StringFromMesaString[password], heap, simple !        Auth.CallError => GOTO nope];      strongID ¬ Auth.MakeIdentity[        @nameRecord, NSString.StringFromMesaString[password], heap, strong !        Auth.CallError => GOTO nope];      validDefaults ¬ TRUE;      EXITS nope => NULL};    NSName.FreeNameFields[heap, @nameRecord];    IF domain # NIL THEN heap.FREE[@domain];    IF org # NIL THEN heap.FREE[@org];    --IF user # NIL THEN [] ¬ CmFile.FreeString[user];    --IF password # NIL THEN [] ¬ CmFile.FreeString[password];    Exec.AddCommand[      name: "MFileServer.~"L, proc: Main, help: MFileServerHelp,      unload: Unload];    };  Init[];  }.          LOG:Nannette            21-Oct-86 10:30:59		Replaced NSDataStream w/ XStreamAOF	             1-Jul-87 20:39:29		Rename back to MFileServerAOF	            13-Sep-87 14:41:24		Export version range [4..5]AOF	            24-Sep-87 10:18:08		(Un)Export version range [4..5]AOF	            28-Sep-87 13:24:46		Deleting xs where it's deletedAOF	            28-Oct-87 18:01:09		Print fully qualified name in log
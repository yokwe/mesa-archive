-- Copyright (C) 1984, 1985  by Xerox Corporation. All rights reserved. -- MFileServerDebugImpl.mesaDIRECTORY  Format USING [LongNumber, Number],  Inline USING [LowHalf],  MFile USING [ErrorCode],  MFileServerDebug,  MFileServerOps USING [Write],  MStream USING [ErrorCode],  NSFile USING [Attribute, AttributeList, AttributeType, Filter,     Interpretation, Ordering],  NSFileCourier USING [AttributeTypeList, ControlsList, ScopeList],  NSString USING [AppendToMesaString];  MFileServerDebugImpl: PROGRAM   IMPORTS Format, Inline, MFileServerOps, NSString  EXPORTS MFileServerDebug = PUBLIC   {    PrintScopeList: PROC[scope: NSFileCourier.ScopeList] = {    MFileServerOps.Write["  Scope: "L];    FOR i: CARDINAL IN [0..scope.LENGTH) DO      WITH a: scope[i] SELECT FROM	count => {MFileServerOps.Write["count: "L]; Number[a.value]};	depth => {MFileServerOps.Write["depth: "L]; Number[a.value]};	direction => {MFileServerOps.Write["direction: "L];	  MFileServerOps.Write[SELECT a.value FROM	    forward => "forward "L, ENDCASE => "backward"L]};	filter => {MFileServerOps.Write["filter: "L]; PrintFilter[a.value]};	ordering => {MFileServerOps.Write["ordering: "L];	  PrintOrdering[a.value]};        ENDCASE => MFileServerOps.Write["??? "L];      ENDLOOP;    MFileServerOps.Write["\n"L];    };    Number: PROC[u: UNSPECIFIED] = {    Format.Number[MFileServerOps.Write, u, []];    MFileServerOps.Write[" "L];    };    PrintOrdering: PROC[order: NSFile.Ordering] = {    WITH o: order SELECT FROM      key => {MFileServerOps.Write["key ["L];        MFileServerOps.Write["key: "L]; PrintAttrType[o.key];	MFileServerOps.Write["ascending: "L]; PrintBoolean[o.ascending];	MFileServerOps.Write["dummy1: "L]; 	  Format.Number[MFileServerOps.Write, o.dummy1, []];	MFileServerOps.Write["dummy2: "L]; 	  Format.Number[MFileServerOps.Write, o.dummy2, []];	MFileServerOps.Write["] "L];	};      extended => {MFileServerOps.Write["extended ["L];        Format.LongNumber[MFileServerOps.Write, o.key, []];	MFileServerOps.Write["ascending: "L]; PrintBoolean[o.ascending];	MFileServerOps.Write["interpretation: "L];           PrintInterpretation[o.interpretation];	MFileServerOps.Write["] "L];        };      ENDCASE;    };      PrintInterpretation: PROC[i: NSFile.Interpretation] = {    MFileServerOps.Write[SELECT i FROM      none => "none "L,      boolean => "boolean "L,      cardinal => "cardinal "L,      longCardinal => "longCardinal "L,      integer => "integer "L,      longInteger => "longInteger "L,      string => "string "L,      ENDCASE => "time "L];    };      PrintBoolean: PROC[b: BOOLEAN] = INLINE    {MFileServerOps.Write[IF b THEN "TRUE "L ELSE "FALSE "L]};    PrintFilters: PROC[    filters: LONG DESCRIPTOR FOR ARRAY CARDINAL OF NSFile.Filter] = {    FOR i: CARDINAL IN [0..filters.LENGTH) DO PrintFilter[filters[i]] ENDLOOP;    };    PrintFilter: PROC[filter: NSFile.Filter] = {    WITH f: filter SELECT FROM      less => {MFileServerOps.Write["less "L]; PrintAttribute[@f.attribute]};      lessOrEqual => {MFileServerOps.Write["lessOrEqual "L];        PrintAttribute[@f.attribute]};      equal => {MFileServerOps.Write["equal "L];         PrintAttribute[@f.attribute]};      notEqual => {MFileServerOps.Write["notEqual "L];         PrintAttribute[@f.attribute]};      greaterOrEqual => {MFileServerOps.Write["greaterOrEqual "L];         PrintAttribute[@f.attribute]};      greater => {MFileServerOps.Write["greater "L];         PrintAttribute[@f.attribute]};      matches => {MFileServerOps.Write["matches "L];         PrintAttribute[@f.attribute]};      and =>{MFileServerOps.Write["and "L]; PrintFilters[f.list]};      or =>{MFileServerOps.Write["or "L]; PrintFilters[f.list]};      not =>{MFileServerOps.Write["not "L]; PrintFilter[f.filter­]};      none => MFileServerOps.Write["none "L];      all => MFileServerOps.Write["all "L];      ENDCASE;    };    PrintControlList: PROC[control: NSFileCourier.ControlsList] = {    MFileServerOps.Write["  Controls: "L];    FOR i: CARDINAL IN [0..control.LENGTH) DO      WITH a: control[i] SELECT FROM	lock => MFileServerOps.Write["lock "L];	timeout => MFileServerOps.Write["timeout "L];	access => MFileServerOps.Write["access "L];        ENDCASE => MFileServerOps.Write["??? "L];      ENDLOOP;    MFileServerOps.Write["\n"L];    };    PrintAttrList: PROC[selections: NSFileCourier.AttributeTypeList] = {    MFileServerOps.Write["  Selections: "L];    FOR i: CARDINAL IN [0..selections.LENGTH) DO      lh: CARDINAL ¬ Inline.LowHalf[selections[i]];      attr: NSFile.AttributeType ¬ VAL[lh];      PrintAttrType[attr];      ENDLOOP;    MFileServerOps.Write["\n"L];    };    PrintAttrType: PROC[attr: NSFile.AttributeType] = {    MFileServerOps.Write[SELECT attr FROM      checksum => "checksum "L,      childrenUniquelyNamed => "childrenUniquelyNamed "L,      createdBy => "createdBy "L,      createdOn => "createdOn "L,      fileID => "fileID "L,      isDirectory => "isDirectory "L,      isTemporary => "isTemporary "L,      modifiedBy => "modifiedBy "L,      modifiedOn => "modifiedOn "L,      name => "name "L,      numberOfChildren => "numberOfChildren "L,      ordering => "ordering "L,      parentID => "parentID "L,      position => "position "L,      readBy => "readBy "L,      readOn => "readOn "L,      sizeInBytes => "sizeInBytes "L,      type => "type "L,      version => "version "L,      accessList => "accessList "L,      defaultAccessList => "defaultAccessList "L,      pathname => "pathname "L,      service => "service "L,      backedUpOn => "backedUpOn "L,      filedBy => "filedBy "L,      filedOn => "filedOn "L,      sizeInPages => "sizeInPages "L,      subtreeSize => "subtreeSize "L,      subtreeSizeLimit => "subtreeSizeLimit "L,      extended => "extended "L,      ENDCASE => "??? "L];    };	  PrintAttributes: PROC[attr: NSFile.AttributeList] = {    MFileServerOps.Write["  Attributes: "L];    FOR i: CARDINAL IN [0..attr.LENGTH) DO      PrintAttribute[@attr[i]];      ENDLOOP;    MFileServerOps.Write["\n"L];    };      PrintAttribute: PROC[attr: LONG POINTER TO NSFile.Attribute] = {    s: LONG STRING ¬ [128];    s.length ¬ 0;    WITH a: attr­ SELECT FROM      fileID => MFileServerOps.Write["fileID "L];      parentID => MFileServerOps.Write["parentID "L];      checksum => MFileServerOps.Write["checksum "L];      type => MFileServerOps.Write["type "L];      position => MFileServerOps.Write["position "L];      service => MFileServerOps.Write["service "L];      ordering => MFileServerOps.Write["ordering "L];      accessList => MFileServerOps.Write["accessList "L];      defaultAccessList => MFileServerOps.Write["defaultAccessList "L];      backedUpOn => MFileServerOps.Write["backedUpOn "L];      createdOn => MFileServerOps.Write["createdOn "L];      filedOn => MFileServerOps.Write["filedOn "L];      modifiedOn => MFileServerOps.Write["modifiedOn "L];      readOn => MFileServerOps.Write["readOn "L];      createdBy => MFileServerOps.Write["createdBy "L];      filedBy => MFileServerOps.Write["filedBy "L];      modifiedBy => MFileServerOps.Write["modifiedBy "L];      readBy => MFileServerOps.Write["readBy "L];      name => {	MFileServerOps.Write["name: "L];	NSString.AppendToMesaString[s, a.value];	MFileServerOps.Write[s]; MFileServerOps.Write[" "L]};      pathname => {	MFileServerOps.Write["pathname: "L];	NSString.AppendToMesaString[s, a.value];	MFileServerOps.Write[s]; MFileServerOps.Write[" "L]};      childrenUniquelyNamed => MFileServerOps.Write["childrenUniquelyNamed "L];      isDirectory => MFileServerOps.Write["isDirectory "L];      isTemporary => MFileServerOps.Write["isTemporary "L];      version => MFileServerOps.Write["version "L];      numberOfChildren => MFileServerOps.Write["numberOfChildren "L];      sizeInBytes => MFileServerOps.Write["sizeInBytes "L];      sizeInPages => MFileServerOps.Write["sizeInPages "L];      subtreeSize => MFileServerOps.Write["subtreeSize "L];      subtreeSizeLimit => MFileServerOps.Write["subtreeSizeLimit "L];      extended => MFileServerOps.Write["extended "L];      ENDCASE => MFileServerOps.Write["??? "L];    };    PrintMStream: PROC[code: MStream.ErrorCode] = {    MFileServerOps.Write["  MStream error: "L];    MFileServerOps.Write[SELECT code FROM      invalidHandle => "invalidHandle "L,      indexOutOfRange => "indexOutOfRange "L,      invalidOperation => "invalidOperation "L,      fileTooLong => "fileTooLong "L,      fileNotAvailable => "fileNotAvailable "L,      invalidFile => "invalidFile "L,      ENDCASE => "other "L];    MFileServerOps.Write[".\n"L];    };    PrintMFile: PROC[code: MFile.ErrorCode] = {    MFileServerOps.Write["  MFile error: "L];    MFileServerOps.Write[SELECT code FROM      noSuchFile => "noSuchFile "L,      conflictingAccess => "conflictingAccess "L,      insufficientAccess => "insufficientAccess "L,      directoryFull => "directoryFull "L,      directoryNotEmpty => "directoryNotEmpty "L,      illegalName => "illegalName "L,      noSuchDirectory => "noSuchDirectory "L,      noRootDirectory => "noRootDirectory "L,      nullAccess => "nullAccess "L,      protectionFault => "protectionFault "L,      directoryOnSearchPath => "directoryOnSearchPath "L,      illegalSearchPath => "illegalSearchPath "L,      volumeNotOpen => "volumeNotOpen "L,      volumeReadOnly => "volumeReadOnly "L,      noRoomOnVolume => "noRoomOnVolume "L,      noSuchVolume => "noSuchVolume "L,      crossingVolumes => "crossingVolumes "L,      fileAlreadyExists => "fileAlreadyExists "L,      fileIsRemote => "fileIsRemote "L,      fileIsDirectory => "fileIsDirectory "L,      invalidHandle => "invalidHandle "L,      courierError => "courierError "L,      addressTranslationError => "addressTranslationError "L,      connectionSuspended => "connectionSuspended "L,      ENDCASE => "other "L];    MFileServerOps.Write[".\n"L];    };    }.
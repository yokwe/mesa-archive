-- Copyright (C) 1984, 1985  by Xerox Corporation. All rights reserved. -- CopyStreamImpl.mesa-- BGY     	27-Aug-84 11:23:49-- JCS  	22-Jul-85 11:43:04DIRECTORY  CopyStream,  Environment USING [Byte],  Process USING [Abort, EnableAborts, SetTimeout],  Stream USING [CompletionCode, GetBlock, Handle, PutBlock],  System USING [switches];CopyStreamImpl: MONITOR   IMPORTS Process, Stream, System  EXPORTS CopyStream =  {  Handle: TYPE = LONG POINTER TO Object;  Object: PUBLIC TYPE = RECORD[    put: PROCESS ¬ NIL,    get: PROCESS RETURNS [bytesTransferred: LONG CARDINAL _ 0] ¬ NIL,    freelist, outlist: QueueHandle ¬ NIL,    zone: UNCOUNTED ZONE ¬ NIL,    aborted: BOOLEAN ¬ FALSE,    getting, putting: BOOLEAN ¬ FALSE];      Buffer: TYPE = LONG POINTER TO BufferObject;  BufferObject: TYPE = MACHINE DEPENDENT RECORD[    data(0): PACKED SEQUENCE size(0): CARDINAL OF Environment.Byte];    QueueHandle: TYPE =  LONG POINTER TO QueueObject;  QueueObject: TYPE = MACHINE DEPENDENT RECORD[    next(0): QueueHandle ¬ NIL,    length(2): CARDINAL ¬ 0,    buffer(3): Buffer,    last(5): BOOLEAN ¬ FALSE];      debug: BOOLEAN = (System.switches['D] = down);      StuffOnQueue: CONDITION;    Create: PUBLIC PROC[nBuffers, bufferSize: CARDINAL, zone: UNCOUNTED ZONE]     RETURNS [h: Handle] = {    h ¬ zone.NEW[Object ¬ [zone: zone]];    THROUGH [0..nBuffers) DO      PutToQueue[@h.freelist, zone.NEW[QueueObject ¬ [        buffer: zone.NEW[BufferObject[bufferSize]]]]];      ENDLOOP;    };      Destroy: PUBLIC PROC[h: Handle] = {    zone: UNCOUNTED ZONE ¬ h.zone;    q: QueueHandle ¬ NIL;    WHILE h.freelist # NIL DO      q ¬ GetFromQueue[@h.freelist, FALSE];      IF q = NIL THEN EXIT;      zone.FREE[@q.buffer];      zone.FREE[@q];      ENDLOOP;   zone.FREE[@h];   };    Copy: PUBLIC PROCEDURE [    h: Handle, streamSource, streamDest: Stream.Handle]    RETURNS [bytesTransferred: LONG CARDINAL _ 0] = {    h.aborted ¬ FALSE;    h.getting ¬ h.putting ¬ TRUE;    h.put ¬ FORK PutData[h, streamDest];    h.get ¬ FORK GetData[h, streamSource];    bytesTransferred ¬ JOIN h.get;    JOIN h.put;    IF h.aborted THEN {      h.aborted ¬ FALSE;      ERROR ABORTED;      };    };  GetData: PROC [h: Handle, source: Stream.Handle]    RETURNS [bytesTransferred: LONG CARDINAL _ 0] = {    buf: QueueHandle ¬ NIL;    completionCode: Stream.CompletionCode _ normal;    last: BOOLEAN;    BEGIN    DO ENABLE ANY => {	IF debug THEN REJECT 	ELSE {	  h.aborted ¬ TRUE; 	  IF h.putting THEN Process.Abort[h.put]; 	  GOTO aborted}	};      IF ~h.putting THEN GOTO aborted;      buf ¬ GetFromQueue[@h.freelist];      BEGIN ENABLE UNWIND => PutToQueue[@h.freelist, buf];      [buf.length, completionCode] ¬ source.GetBlock[        [LOOPHOLE[@buf.buffer.data + 1], 0, buf.buffer.size]];      last ¬ buf.last ¬ (completionCode = endOfStream) OR (buf.length = 0);      END;      bytesTransferred _ bytesTransferred + buf.length;      PutToQueue[@h.outlist, buf];      IF last THEN EXIT;      ENDLOOP;    EXITS aborted => {      WHILE (buf ¬ GetFromQueue[@h.outlist, FALSE]) # NIL DO	PutToQueue[@h.freelist, buf] ENDLOOP};    END;    h.getting ¬ FALSE;    };  PutData: PROC [h: Handle, sink: Stream.Handle] = {    buf: QueueHandle ¬ NIL;    last: BOOLEAN;    BEGIN      DO ENABLE ANY => {	IF debug THEN REJECT	ELSE {	  h.aborted ¬ TRUE; 	  IF h.getting THEN Process.Abort[h.get]; 	  GOTO aborted};	};      buf ¬ GetFromQueue[@h.outlist];      BEGIN ENABLE UNWIND => PutToQueue[@h.freelist, buf];      sink.PutBlock[[LOOPHOLE[@buf.buffer.data + 1], 0, buf.length]];      END;      last ¬ buf.last;      buf.last ¬ FALSE;      PutToQueue[@h.freelist, buf];      IF last THEN EXIT;      ENDLOOP;    EXITS aborted => {      WHILE (buf ¬ GetFromQueue[@h.outlist, FALSE]) # NIL DO	PutToQueue[@h.freelist, buf] ENDLOOP};    END;    h.putting ¬ FALSE;    };  PutToQueue: ENTRY PROC [q: LONG POINTER TO QueueHandle, buf: QueueHandle] = {    i: LONG POINTER TO QueueHandle _ NIL;    FOR i _ q, @i.next UNTIL i^ = NIL DO ENDLOOP;    i^ _ buf;    buf.next _ NIL;    BROADCAST StuffOnQueue;    };  GetFromQueue: ENTRY PROC [q: LONG POINTER TO QueueHandle, wait: BOOLEAN _ TRUE]    RETURNS [buf: QueueHandle] = {    ENABLE UNWIND => NULL;    IF wait THEN WHILE q^ = NIL DO WAIT StuffOnQueue; ENDLOOP;    buf _ q^;    IF buf # NIL THEN q^ _ buf.next};  --mainline code  Init: PROC = {    Process.SetTimeout[@StuffOnQueue, 1]; Process.EnableAborts[@StuffOnQueue]; };  Init[];  }.    
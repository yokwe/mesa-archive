--  NSFileCourierUtilityBImpl.mesa-- Overview: Partial implementation of NSFileCourier: description routines-- Last revised by Ciccone: 20-Dec-83 13:54:36DIRECTORY  Auth USING [DescribeCredentials, DescribeVerifier],  Courier USING [Description],  Heap USING [FreeNode],  NSDataStream,  NSFile USING [    ControlType, Error, Filter, FilterType, Handle, nullOrdering, Scope,    ScopeType],  NSFileCourier,  -- about everything  NSName USING [DescribeNameRecord],  NSString USING [FreeString, String],  XStream;NSFileCourierUtilityBImpl: PROGRAM  IMPORTS Auth, Heap, NSDataStream, NSFile, NSFileCourier,  NSName, NSString, XStream  EXPORTS NSFileCourier =  BEGIN OPEN NSFileCourier;  --Types  Filter: TYPE = NSFile.Filter;  --Encoding/Decoding of Scope  DecodeProtocolScope: PUBLIC PROCEDURE [    scopeList: ScopeList, zone: UNCOUNTED ZONE] RETURNS [scope: NSFile.Scope] =    BEGIN    scopes: ARRAY NSFile.ScopeType OF BOOLEAN _ ALL[FALSE];    FOR i: CARDINAL IN [0..LENGTH[scopeList]) DO      lptScope: LONG POINTER TO Scope = @scopeList[i];      IF scopes[lptScope.type] THEN        NSFile.Error[[scopeValue[duplicated, lptScope.type]]];      scopes[lptScope.type] _ TRUE;      WITH s: lptScope SELECT FROM        count => scope.count _ s.value;        depth => scope.depth _ s.value;        direction => scope.direction _ s.value;        filter => scope.filter _ s.value;        ordering => scope.ordering _ s.value;        ENDCASE;      ENDLOOP;    END;  -- of DecodeProtocolScope  EncodeScope: PUBLIC PROC [    scope: LONG POINTER TO NSFile.Scope, zone: UNCOUNTED ZONE]    RETURNS [scopeList: ScopeList] =    BEGIN    ScopeSequence: TYPE = RECORD [SEQUENCE COMPUTED CARDINAL OF Scope];    defaulted: ARRAY NSFile.ScopeType OF BOOLEAN = [      count: scope.count = LAST[CARDINAL], depth: scope.depth = 1,      direction: scope.direction = forward, filter: scope.filter = [all[]],      ordering: scope.ordering = NSFile.nullOrdering];    elements: CARDINAL _ 0;    FOR i: NSFile.ScopeType IN NSFile.ScopeType DO      IF NOT defaulted[i] THEN elements _ elements + 1; ENDLOOP;    IF elements = 0 THEN RETURN[NIL];    scopeList _ DESCRIPTOR[zone.NEW[ScopeSequence [elements]], elements];    elements _ 0;    FOR i: NSFile.ScopeType IN NSFile.ScopeType DO      IF defaulted[i] THEN LOOP;      SELECT i FROM        count => scopeList[elements] _ [count[scope.count]];        depth => scopeList[elements] _ [depth[scope.depth]];        direction => scopeList[elements] _ [direction[scope.direction]];        filter => scopeList[elements] _ [filter[scope.filter]];        ordering => scopeList[elements] _ [ordering[scope.ordering]];        ENDCASE;      elements _ elements + 1;      ENDLOOP;    END;  -- of EncodeScope  FreeProtocolScope: PUBLIC PROC [scopeList: ScopeList, zone: UNCOUNTED ZONE] =    BEGIN    IF BASE[scopeList] = NIL THEN RETURN;    Heap.FreeNode[zone, BASE[scopeList]];    --Attached Filters belong to client and must not be freed    END;  -- of FreeProtocolScope  --  Interface To Descriptions  GetRemoteProcedureDescriptions: PUBLIC PROCEDURE    RETURNS [procedures: RemoteProcedureDescriptionsHandle] = {    RETURN[@procedureDescriptions]};  GetRemoteErrorDescriptions: PUBLIC PROCEDURE    RETURNS [errors: RemoteErrorDescriptionsHandle] = {    RETURN[@errorDescriptions]};  procedureDescriptions: RemoteProcedureDescriptions _ [    Logon: [LogonArgumentsDescription, SessionDescription],    Logoff: [SessionDescription, NIL],    Open: [OpenArgumentsDescription, FileHandleDescription],    Close: [CloseArgumentsDescription, NIL],    Create: [CreateArgumentsDescription, FileHandleDescription],    Delete: [DeleteArgumentsDescription, NIL],    GetControls: [GetControlsArgumentsDescription, ControlsListDescription],    ChangeControls: [ChangeControlsArgumentsDescription, NIL],    GetAttributes: [GetAttributesArgumentsDescription, DescribeAttributes],    ChangeAttributes: [ChangeAttributesArgumentsDescription, NIL],    Copy: [CopyArgumentsDescription, FileHandleDescription],    Move: [MoveArgumentsDescription, NIL],    Store: [StoreArgumentsDescription, FileHandleDescription],    Retrieve: [RetrieveArgumentsDescription, NIL],    Replace: [ReplaceArgumentsDescription, NIL],    Serialize: [SerializeArgumentsDescription, NIL],    Deserialize: [DeserializeArgumentsDescription, FileHandleDescription],    Find: [FindArgumentsDescription, FileHandleDescription],    List: [ListArgumentsDescription, NIL],    Probe: [SessionDescription, ProbeResultsDescription],    UnifyAccessLists: [UnifyAccessListsArgumentsDescription, NIL]];  errorDescriptions: RemoteErrorDescriptions _ [    AttributeTypeError: [AttributeTypeErrorArgumentsDescription],    AttributeValueError: [AttributeValueErrorArgumentsDescription],    ControlTypeError: [ControlTypeErrorArgumentsDescription],    ControlValueError: [ControlValueErrorArgumentsDescription],    ScopeTypeError: [ScopeTypeErrorArgumentsDescription],    ScopeValueError: [ScopeValueErrorArgumentsDescription],    AccessError: [AccessErrorArgumentsDescription],    AuthenticationError: [AuthenticationErrorArgumentsDescription],    ConnectionError: [ConnectionErrorArgumentsDescription],    HandleError: [HandleErrorArgumentsDescription],    InsertionError: [InsertionErrorArgumentsDescription],    ServiceError: [ServiceErrorArgumentsDescription],    SessionError: [SessionErrorArgumentsDescription],    SpaceError: [SpaceErrorArgumentsDescription],    TransferError: [TransferErrorArgumentsDescription],    UndefinedError: [UndefinedErrorArgumentsDescription]];  controlVariantSizes: ARRAY [0..maxControlItems) OF CARDINAL _ [    -- lock: 0 -- SIZE[lock NSFileCourier.Control],    -- timeout: 1 -- SIZE[timeout NSFileCourier.Control],    -- access: 2 -- SIZE[access NSFileCourier.Control]];  maxControlItems: CARDINAL = 3;  -- ordinality of NSFile.ControlType  filterVariantSizes: ARRAY [0..12) OF CARDINAL _ [    -- less: 0 -- SIZE[less Filter],    -- lessOrEqual: 1 -- SIZE[lessOrEqual Filter],    -- equal: 2 -- SIZE[equal Filter],    -- notEqual: 3 -- SIZE[notEqual Filter],    -- greaterOrEqual: 4 -- SIZE[greaterOrEqual Filter],    -- greater: 5 -- SIZE[greater Filter],    -- and: 6 -- SIZE[and Filter],    -- or: 7 -- SIZE[or Filter],    -- not: 8 -- SIZE[not Filter],    -- none: 9 -- SIZE[none Filter],    -- all: 10 -- SIZE[all Filter],    -- matches: 11 -- SIZE[matches Filter]];  scopeVariantSizes: ARRAY [0..maxScopeItems) OF CARDINAL _ [    -- count: 0 -- SIZE[count Scope],    -- direction: 1 -- SIZE[direction Scope],    -- filter: 2 -- SIZE[filter Scope],    -- ordering: 3 -- SIZE[ordering Scope],    -- depth 4 -- SIZE[depth Scope]];  maxScopeItems: CARDINAL = 5;  -- ordinality of NSFile.ScopeType  -- Description Procedures  AttributeTypeListDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO AttributeTypeList = noteSize[      size: SIZE[AttributeTypeList]];    noteArrayDescriptor[      site: parameters, elementSize: SIZE[AttributeType],      upperBound: LAST[CARDINAL]];    IF BASE[parameters^] # NIL THEN      FOR element2: CARDINAL IN [0..LENGTH[parameters^]) DO        noteLongCardinal[@parameters^[element2]]; ENDLOOP;    END;  ControlDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO Control = noteSize[size: SIZE[Control]];    noteChoice[      site: parameters, size: SIZE[Control],      variant: DESCRIPTOR[controlVariantSizes]];    END;  ControlsListDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO ControlsList = noteSize[size: SIZE[ControlsList]];    noteArrayDescriptor[      site: parameters, elementSize: SIZE[Control], upperBound: maxControlItems];    IF BASE[parameters^] # NIL THEN      FOR element2: CARDINAL IN [0..LENGTH[parameters^]) DO        noteParameters[@parameters^[element2], ControlDescription]; ENDLOOP;    END;  ControlTypeListDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO ControlTypeList = noteSize[      size: SIZE[ControlTypeList]];    noteArrayDescriptor[      site: parameters, elementSize: SIZE[NSFile.ControlType],      upperBound: maxControlItems];    END;  FileHandleDescription: Courier.Description = {    [] _ notes.noteSize[SIZE[NSFile.Handle]]};  FilterDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO Filter = noteSize[size: SIZE[Filter]];    noteChoice[parameters, SIZE[Filter], DESCRIPTOR[filterVariantSizes]];    WITH variant: parameters^ SELECT FROM      less, lessOrEqual, equal, notEqual, greaterOrEqual, greater =>        noteParameters[@variant.attribute, DescribeAttribute];      matches => noteParameters[@variant.attribute, DescribeAttribute];      and, or =>        BEGIN        noteArrayDescriptor[          site: @variant.list, elementSize: SIZE[Filter],          upperBound: LAST[CARDINAL]];        IF BASE[variant.list] # NIL THEN          FOR i: CARDINAL IN [0..LENGTH[variant.list]) DO            noteParameters[@variant.list[i], FilterDescription]; ENDLOOP;        END;      not => noteDisjointData[@variant.filter, FilterDescription];      none, all => NULL;      ENDCASE;    END;  -- of FilterDescription  NSStringDescription: PUBLIC Courier.Description =    BEGIN    site: LONG POINTER TO NSString.String = notes.noteSize[SIZE[NSString.String]];    notes.noteDeadSpace[site, SIZE[NSString.String]];    SELECT notes.operation FROM      store => site^ _ GetNSString[notes];      fetch => PutNSString[notes, site^];      free => NSString.FreeString[zone, site^];      ENDCASE;    END;  -- of NSStringDescription  ScopeDescription: Courier.Description =    BEGIN OPEN notes;    parameters: LONG POINTER TO Scope = noteSize[size: SIZE[Scope]];    noteChoice[      site: parameters, size: SIZE[Scope],      variant: DESCRIPTOR[scopeVariantSizes]];    WITH s: parameters^ SELECT FROM      filter => noteParameters[@s.value, FilterDescription];      ordering =>        SELECT notes.operation FROM          fetch => PutOrdering[notes, @s.value];          store => GetOrdering[notes, @s.value];          ENDCASE;      ENDCASE;    END;  -- of ScopeDescription  ScopeListDescription: Courier.Description =    BEGIN OPEN notes;    parameters: LONG POINTER TO ScopeList = noteSize[size: SIZE[ScopeList]];    noteArrayDescriptor[      site: parameters, elementSize: SIZE[Scope], upperBound: maxScopeItems];    IF BASE[parameters^] # NIL THEN      FOR element2: CARDINAL IN [0..LENGTH[parameters^]) DO        noteParameters[@parameters^[element2], ScopeDescription]; ENDLOOP;    END;  SessionDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO NSFileCourier.Session = noteSize[      size: SIZE[NSFileCourier.Session]];    noteParameters[@parameters.verifier, Auth.DescribeVerifier];    END;  LogonArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO LogonArguments = noteSize[SIZE[LogonArguments]];    BEGIN OPEN rec: parameters;    noteParameters[@rec.service, NSName.DescribeNameRecord];    noteParameters[@rec.credentials, Auth.DescribeCredentials];    noteParameters[@parameters.verifier, Auth.DescribeVerifier];    END;  --OPEN parameters--    END;  ProbeResultsDescription: Courier.Description --[notes: Notes]--  = {    [] _ notes.noteSize[size: SIZE[ProbeResults]]};  CreateArgumentsDescription: Courier.Description =    BEGIN OPEN notes;    rec: LONG POINTER TO CreateArguments = noteSize[SIZE[CreateArguments]];    noteParameters[@rec.attributes, DescribeAttributes];    noteParameters[@rec.controls, ControlsListDescription];    noteParameters[@rec.session, SessionDescription];    END;  CopyArgumentsDescription: Courier.Description =    BEGIN OPEN notes;    rec: LONG POINTER TO CopyArguments = noteSize[SIZE[CopyArguments]];    noteParameters[@rec.attributes, DescribeAttributes];    noteParameters[@rec.controls, ControlsListDescription];    noteParameters[@rec.session, SessionDescription];    END;  MoveArgumentsDescription: Courier.Description =    BEGIN OPEN notes;    rec: LONG POINTER TO MoveArguments = noteSize[SIZE[MoveArguments]];    noteParameters[@rec.attributes, DescribeAttributes];    noteParameters[@rec.session, SessionDescription];    END;  DeleteArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO DeleteArguments = noteSize[      size: SIZE[DeleteArguments]];    noteParameters[@parameters.session, SessionDescription];    END;  ListArgumentsDescription: Courier.Description =    BEGIN OPEN notes;    rec: LONG POINTER TO ListArguments = noteSize[SIZE[ListArguments]];    noteParameters[@rec.selections, AttributeTypeListDescription];    noteParameters[@rec.scope, ScopeListDescription];    noteParameters[@rec.listing, XStream.DescribeSink];    noteDeadSpace[@rec.listing + SIZE[XStream.Handle],       SIZE[NSDataStream.Ticket] - SIZE[XStream.Handle]];    noteParameters[@rec.session, SessionDescription];    END;  GetAttributesArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO GetAttributesArguments = noteSize[      size: SIZE[GetAttributesArguments]];    noteParameters[@parameters.selections, AttributeTypeListDescription];    noteParameters[@parameters.session, SessionDescription];    END;  ChangeAttributesArgumentsDescription: Courier.Description =    BEGIN OPEN notes;    rec: LONG POINTER TO ChangeAttributesArguments = noteSize[      SIZE[ChangeAttributesArguments]];    noteParameters[@rec.attributes, DescribeAttributes];    noteParameters[@rec.session, SessionDescription];    END;  UnifyAccessListsArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO UnifyAccessListsArguments = noteSize[      size: SIZE[UnifyAccessListsArguments]];    noteParameters[@parameters.session, SessionDescription];    END;  OpenArgumentsDescription: Courier.Description =    BEGIN OPEN notes;    rec: LONG POINTER TO OpenArguments = noteSize[SIZE[OpenArguments]];    noteParameters[@rec.attributes, DescribeAttributes];    noteParameters[@rec.controls, ControlsListDescription];    noteParameters[@rec.session, SessionDescription];    END;  CloseArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO CloseArguments = noteSize[      size: SIZE[CloseArguments]];    noteParameters[@parameters.session, SessionDescription];    END;  ChangeControlsArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO ChangeControlsArguments = noteSize[      size: SIZE[ChangeControlsArguments]];    noteParameters[@parameters.controls, ControlsListDescription];    noteParameters[@parameters.session, SessionDescription];    END;  GetControlsArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO GetControlsArguments = noteSize[      size: SIZE[GetControlsArguments]];    noteParameters[@parameters.controlSelections, ControlTypeListDescription];    noteParameters[@parameters.session, SessionDescription];    END;  RetrieveArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO RetrieveArguments = noteSize[      size: SIZE[RetrieveArguments]];    noteParameters[@parameters.content, XStream.DescribeSink];    noteDeadSpace[@parameters.content + SIZE[XStream.Handle],       SIZE[NSDataStream.Ticket] - SIZE[XStream.Handle]];      noteParameters[@parameters.session, SessionDescription];    END;  ReplaceArgumentsDescription: Courier.Description =    BEGIN OPEN notes;    rec: LONG POINTER TO ReplaceArguments = noteSize[SIZE[ReplaceArguments]];    noteParameters[@rec.attributes, DescribeAttributes];    noteParameters[@rec.content, NSDataStream.DescribeTicket];    noteParameters[@rec.session, SessionDescription];    END;  SerializeArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO SerializeArguments = noteSize[      size: SIZE[SerializeArguments]];    BEGIN OPEN rec: parameters;    noteParameters[@rec.serializedFile, NSDataStream.DescribeTicket];    noteParameters[@parameters.session, SessionDescription];    END;  --OPEN parameters--    END;  StoreArgumentsDescription: Courier.Description =    BEGIN OPEN notes;    rec: LONG POINTER TO StoreArguments = noteSize[SIZE[StoreArguments]];    noteParameters[@rec.attributes, DescribeAttributes];    noteParameters[@rec.controls, ControlsListDescription];    noteParameters[@rec.content, XStream.DescribeSource];    noteDeadSpace[@rec.content + SIZE[XStream.Handle],       SIZE[NSDataStream.Ticket] - SIZE[XStream.Handle]];    noteParameters[@rec.session, SessionDescription];    END;  DeserializeArgumentsDescription: Courier.Description =    BEGIN OPEN notes;    rec: LONG POINTER TO DeserializeArguments = noteSize[      SIZE[DeserializeArguments]];    noteParameters[@rec.attributes, DescribeAttributes];    noteParameters[@rec.controls, ControlsListDescription];    noteParameters[@rec.serializedFile, NSDataStream.DescribeTicket];    noteParameters[@rec.session, SessionDescription];    END;  FindArgumentsDescription: Courier.Description =    BEGIN OPEN notes;    rec: LONG POINTER TO FindArguments = noteSize[SIZE[FindArguments]];    noteParameters[@rec.scope, ScopeListDescription];    noteParameters[@rec.controls, ControlsListDescription];    noteParameters[@rec.session, SessionDescription];    END;  AttributeTypeErrorArgumentsDescription, AttributeValueErrorArgumentsDescription:    Courier.Description  --[notes: Notes]--     =    BEGIN OPEN notes;    parameters: LONG POINTER TO AttributeTypeErrorArguments = noteSize[      size: SIZE[AttributeTypeErrorArguments]];    noteLongCardinal[@parameters.type];    END;  ControlTypeErrorArgumentsDescription, ControlValueErrorArgumentsDescription:    Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO ControlTypeErrorArguments = noteSize[      size: SIZE[ControlTypeErrorArguments]];    END;  ScopeTypeErrorArgumentsDescription, ScopeValueErrorArgumentsDescription:    Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO ScopeTypeErrorArguments = noteSize[      size: SIZE[ScopeTypeErrorArguments]];    END;  AccessErrorArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO AccessErrorArguments = noteSize[      size: SIZE[AccessErrorArguments]];    END;  AuthenticationErrorArgumentsDescription: Courier.Description  --[notes: Notes]--     =    BEGIN OPEN notes;    parameters: LONG POINTER TO AuthenticationErrorArguments = noteSize[      size: SIZE[AuthenticationErrorArguments]];    END;  ConnectionErrorArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO ConnectionErrorArguments = noteSize[      size: SIZE[ConnectionErrorArguments]];    END;  HandleErrorArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO HandleErrorArguments = noteSize[      size: SIZE[HandleErrorArguments]];    END;  InsertionErrorArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO InsertionErrorArguments = noteSize[      size: SIZE[InsertionErrorArguments]];    END;  ServiceErrorArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO ServiceErrorArguments = noteSize[      size: SIZE[ServiceErrorArguments]];    END;  SessionErrorArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO SessionErrorArguments = noteSize[      size: SIZE[SessionErrorArguments]];    END;  SpaceErrorArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO SpaceErrorArguments = noteSize[      size: SIZE[SpaceErrorArguments]];    END;  TransferErrorArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO TransferErrorArguments = noteSize[      size: SIZE[TransferErrorArguments]];    END;  UndefinedErrorArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO UndefinedErrorArguments = noteSize[      size: SIZE[UndefinedErrorArguments]];    END;  --  No Module Initialization   END.    LOG (date - person - action)- - - - SERVICES 8.0 - - - -November 16, 1983 - Hanzel - Initial conversion to Services 8.0 and Klamath Courier.December 4, 1983 - Hanzel - Correctly handle new 'depth' ScopeType in Encode/DecodeScopeList.December 5, 1983 - Hanzel - Correct use of notes.operation in ScopeDescription for proper handling of 'ordering'.20-Dec-83 13:55:01 - Ciccone - Removed zone parameter from GetNSString.
-- File: MFileServerUtilityImpl.mesa - last edit:-- bjd                 13-Mar-88 23:03:10-- AOF                 25-Feb-88 19:28:25-- Copyright (C) 1988 by Xerox Corporation. All rights reserved.-- Overview: Partial implementation of NSFileCourier for MFileServerDIRECTORY  Auth USING [DescribeCredentials, DescribeVerifier],  Courier USING [Description, Notes],  Heap USING [FreeNode],  NSDataStream USING [Ticket],  NSAssignedTypes USING [checksum, subtreeSizeLimit],  NSFile USING [    Access, AccessType, ControlType, Error, fullAccess,    Filter, FilterType, Handle, nullOrdering, Ordering, OrderingType,    Scope, ScopeType],  NSFileCourier,  -- about everything  NSName USING [DescribeNameRecord],  NSString USING [FreeString, String],  V4NSFileCourier USING [DescribeAttributes],  XStream;MFileServerUtilityImpl: PROGRAM  IMPORTS    Auth, Heap, NSFile, NSFileCourier, NSName, NSString, XStream, V4NSFileCourier  EXPORTS NSFileCourier, V4NSFileCourier =  BEGIN OPEN NSFileCourier;    fullAccessProtocol: CARDINAL = 65535;  -- taken from 10.0 NSFileCourier  --Types  Filter: TYPE = NSFile.Filter;  -- Useful inlines  GetWord: PROC [notes: Courier.Notes] RETURNS [u: UNSPECIFIED] = INLINE {    notes.noteSpace[@u, 1]};  PutWord: PROC [notes: Courier.Notes, u: UNSPECIFIED] = INLINE {    notes.noteSpace[@u, 1]};  --Encoding/Decoding of Scope  DecodeProtocolScope: PUBLIC PROCEDURE [    scopeList: ScopeList, zone: UNCOUNTED ZONE] RETURNS [scope: NSFile.Scope] =    BEGIN    scopes: ARRAY NSFile.ScopeType OF BOOLEAN ¬ ALL[FALSE];    FOR i: CARDINAL IN [0..LENGTH[scopeList]) DO      lptScope: LONG POINTER TO Scope = @scopeList[i];      IF scopes[lptScope.type] THEN        NSFile.Error[[scopeValue[duplicated, lptScope.type]]];      scopes[lptScope.type] ¬ TRUE;      WITH s: lptScope SELECT FROM        count => scope.count ¬ s.value;        depth => scope.depth ¬ s.value;        direction => scope.direction ¬ s.value;        filter => scope.filter ¬ s.value;        ordering => scope.ordering ¬ s.value;        ENDCASE;      ENDLOOP;    END;  -- of DecodeProtocolScope  EncodeScope: PUBLIC PROC [    scope: LONG POINTER TO NSFile.Scope, zone: UNCOUNTED ZONE]    RETURNS [scopeList: ScopeList] =    BEGIN    ScopeSequence: TYPE = RECORD [SEQUENCE COMPUTED CARDINAL OF Scope];    defaulted: ARRAY NSFile.ScopeType OF BOOLEAN = [      count: scope.count = LAST[CARDINAL], depth: scope.depth = 1,      direction: scope.direction = forward, filter: scope.filter = [all[]],      ordering: scope.ordering = NSFile.nullOrdering];    elements: CARDINAL ¬ 0;    FOR i: NSFile.ScopeType IN NSFile.ScopeType DO      IF NOT defaulted[i] THEN elements ¬ elements + 1; ENDLOOP;    IF elements = 0 THEN RETURN[NIL];    scopeList ¬ DESCRIPTOR[zone.NEW[ScopeSequence [elements]], elements];    elements ¬ 0;    FOR i: NSFile.ScopeType IN NSFile.ScopeType DO      IF defaulted[i] THEN LOOP;      SELECT i FROM        count => scopeList[elements] ¬ [count[scope.count]];        depth => scopeList[elements] ¬ [depth[scope.depth]];        direction => scopeList[elements] ¬ [direction[scope.direction]];        filter => scopeList[elements] ¬ [filter[scope.filter]];        ordering => scopeList[elements] ¬ [ordering[scope.ordering]];        ENDCASE;      elements ¬ elements + 1;      ENDLOOP;    END;  -- of EncodeScope  FreeProtocolScope: PUBLIC PROC [scopeList: ScopeList, zone: UNCOUNTED ZONE] =    BEGIN    IF BASE[scopeList] = NIL THEN RETURN;    Heap.FreeNode[zone, BASE[scopeList]];    --Attached Filters belong to client and must not be freed    END;  -- of FreeProtocolScope  --  Interface To Descriptions  GetRemoteProcedureDescriptions: PUBLIC PROCEDURE    RETURNS [procedures: RemoteProcedureDescriptionsHandle] = {    RETURN[@v5ProcedureDescriptions]};  GetV4RemoteProcedureDescriptions: PUBLIC <<V4NSFileCourier>> PROCEDURE    RETURNS [procedures: RemoteProcedureDescriptionsHandle] = {    RETURN[@v4ProcedureDescriptions]};  GetRemoteErrorDescriptions: PUBLIC PROCEDURE    RETURNS [errors: RemoteErrorDescriptionsHandle] = {    RETURN[@errorDescriptions]};  v4ProcedureDescriptions: RemoteProcedureDescriptions ¬ [    Logon: [LogonArgumentsDescription, SessionDescription],    Logoff: [SessionDescription, NIL],    Open: [V4OpenArgumentsDescription, FileHandleDescription],    Close: [CloseArgumentsDescription, NIL],    Create: [V4CreateArgumentsDescription, FileHandleDescription],    Delete: [DeleteArgumentsDescription, NIL],    GetControls: [GetControlsArgumentsDescription, V4ControlsListDescription],    ChangeControls: [V4ChangeControlsArgumentsDescription, NIL],    GetAttributes: [      GetAttributesArgumentsDescription, V4NSFileCourier.DescribeAttributes],    ChangeAttributes: [ChangeAttributesArgumentsDescription, NIL],    Copy: [V4CopyArgumentsDescription, FileHandleDescription],    Move: [MoveArgumentsDescription, NIL],    Store: [V4StoreArgumentsDescription, FileHandleDescription],    Retrieve: [RetrieveArgumentsDescription, NIL],    Replace: [NIL, NIL],    Serialize: [NIL, NIL],    Deserialize: [NIL, NIL],    Find: [V4FindArgumentsDescription, FileHandleDescription],    List: [V4ListArgumentsDescription, NIL],    Probe: [SessionDescription, ProbeResultsDescription],    UnifyAccessLists: [UnifyAccessListsArgumentsDescription, NIL]];  v5ProcedureDescriptions: RemoteProcedureDescriptions ¬ [    Logon: [LogonArgumentsDescription, SessionDescription],    Logoff: [SessionDescription, NIL],    Open: [V5OpenArgumentsDescription, FileHandleDescription],    Close: [CloseArgumentsDescription, NIL],    Create: [V5CreateArgumentsDescription, FileHandleDescription],    Delete: [DeleteArgumentsDescription, NIL],    GetControls: [GetControlsArgumentsDescription, V5ControlsListDescription],    ChangeControls: [V5ChangeControlsArgumentsDescription, NIL],    GetAttributes: [GetAttributesArgumentsDescription, DescribeAttributes],    ChangeAttributes: [ChangeAttributesArgumentsDescription, NIL],    Copy: [V5CopyArgumentsDescription, FileHandleDescription],    Move: [MoveArgumentsDescription, NIL],    Store: [V5StoreArgumentsDescription, FileHandleDescription],    Retrieve: [RetrieveArgumentsDescription, NIL],    Replace: [NIL, NIL],    Serialize: [NIL, NIL],    Deserialize: [NIL, NIL],    Find: [V5FindArgumentsDescription, FileHandleDescription],    List: [V5ListArgumentsDescription, NIL],    Probe: [SessionDescription, ProbeResultsDescription],    UnifyAccessLists: [UnifyAccessListsArgumentsDescription, NIL]];  errorDescriptions: RemoteErrorDescriptions ¬ [    AttributeTypeError: [AttributeTypeErrorArgumentsDescription],    AttributeValueError: [AttributeValueErrorArgumentsDescription],    ControlTypeError: [ControlTypeErrorArgumentsDescription],    ControlValueError: [ControlValueErrorArgumentsDescription],    ScopeTypeError: [ScopeTypeErrorArgumentsDescription],    ScopeValueError: [ScopeValueErrorArgumentsDescription],    AccessError: [AccessErrorArgumentsDescription],    AuthenticationError: [AuthenticationErrorArgumentsDescription],    ConnectionError: [ConnectionErrorArgumentsDescription],    HandleError: [HandleErrorArgumentsDescription],    InsertionError: [InsertionErrorArgumentsDescription],    ServiceError: [ServiceErrorArgumentsDescription],    SessionError: [SessionErrorArgumentsDescription],    SpaceError: [SpaceErrorArgumentsDescription],    TransferError: [TransferErrorArgumentsDescription],    UndefinedError: [UndefinedErrorArgumentsDescription]];  controlVariantSizes: ARRAY [0..maxControlItems) OF CARDINAL ¬ [    -- lock: 0 -- SIZE[lock NSFileCourier.Control],    -- timeout: 1 -- SIZE[timeout NSFileCourier.Control],    -- access: 2 -- SIZE[access NSFileCourier.Control]];  maxControlItems: CARDINAL = 3;  -- ordinality of NSFile.ControlType  filterVariantSizes: ARRAY [0..12) OF CARDINAL ¬ [    -- less: 0 -- SIZE[less Filter],    -- lessOrEqual: 1 -- SIZE[lessOrEqual Filter],    -- equal: 2 -- SIZE[equal Filter],    -- notEqual: 3 -- SIZE[notEqual Filter],    -- greaterOrEqual: 4 -- SIZE[greaterOrEqual Filter],    -- greater: 5 -- SIZE[greater Filter],    -- and: 6 -- SIZE[and Filter],    -- or: 7 -- SIZE[or Filter],    -- not: 8 -- SIZE[not Filter],    -- none: 9 -- SIZE[none Filter],    -- all: 10 -- SIZE[all Filter],    -- matches: 11 -- SIZE[matches Filter]];  v4ScopeVariantSizes: ARRAY [0..maxScopeItems) OF CARDINAL ¬ [    -- count: 0 -- SIZE[count Scope],    -- direction: 1 -- SIZE[direction Scope],    -- filter: 2 -- SIZE[filter Scope],    -- ordering: 3 -- SIZE[ordering Scope],    -- depth 4 -- SIZE[depth Scope]];    -- see V5ScopeDescription  v5ScopeVariantSizes: ARRAY [0..maxScopeItems) OF CARDINAL ¬ [    -- count: 0 -- SIZE[count Scope],    -- direction: 1 -- SIZE[direction Scope],    -- filter: 2 -- SIZE[filter Scope],    -- ordering: 3 -- SIZE[depth Scope],  -- following are reversed intentionally!    -- depth 4 -- SIZE[ordering Scope]];    maxScopeItems: CARDINAL = 5;  -- ordinality of NSFile.ScopeType  -- Description Procedures  AttributeTypeListDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO AttributeTypeList = noteSize[      size: SIZE[AttributeTypeList]];    noteArrayDescriptor[      site: parameters, elementSize: SIZE[AttributeType],      upperBound: LAST[CARDINAL]];    IF BASE[parameters­] # NIL THEN      FOR element2: CARDINAL IN [0..LENGTH[parameters­]) DO        noteLongCardinal[@parameters­[element2]]; ENDLOOP;    END;  V4ControlDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO Control = noteSize[size: SIZE[Control]];    noteChoice[      site: parameters, size: SIZE[Control],      variant: DESCRIPTOR[controlVariantSizes]];    END;  V5ControlDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO Control = noteSize[size: SIZE[Control]];    notes.noteDeadSpace[parameters, SIZE[Control]]; -- consume it all at start        --handle the type    SELECT notes.operation FROM      fetch => PutWord[notes, parameters.type];      store => LOOPHOLE[        parameters, LONG POINTER TO NSFile.ControlType]­ ¬ GetWord[notes];      ENDCASE;    -- ...then the value    WITH variant: parameters­ SELECT FROM      access => {        SELECT notes.operation FROM	  fetch => {	    access: NSFile.Access ¬ variant.value;            IF access = NSFile.fullAccess THEN {              PutWord[notes, 1];              PutWord[notes, fullAccessProtocol]}            ELSE {	      elements: CARDINAL ¬ 0;              FOR i: NSFile.AccessType IN NSFile.AccessType DO                IF access[i] THEN elements ¬ elements + 1; ENDLOOP;                PutWord[notes, elements];              IF elements # 0 THEN                FOR i: NSFile.AccessType IN NSFile.AccessType DO	          IF access[i] THEN PutWord[notes, ORD[i]]; ENDLOOP}	     };  -- of fetch	  store => {	    accessType: NSFile.AccessType;            accessTypeListLength: CARDINAL ¬ GetWord[notes];	    FOR i: CARDINAL IN [0..accessTypeListLength) DO	      SELECT accessType ¬ GetWord[notes] FROM	        fullAccessProtocol => 	          IF accessTypeListLength = 1 THEN		    variant.value ¬ NSFile.fullAccess		  ELSE NSFile.Error[[attributeValue[illegal, accessList]]];		ENDCASE => variant.value[accessType] ¬ TRUE;	      ENDLOOP;            }; -- of store	  ENDCASE;	};  -- of access      timeout =>        SELECT notes.operation FROM	  fetch => PutWord[notes, variant.value];	  store => variant.value ¬ GetWord[notes];	  ENDCASE;      lock =>        SELECT notes.operation FROM	  fetch => PutWord[notes, variant.value];	  store => variant.value ¬ GetWord[notes];	  ENDCASE;      ENDCASE;    END;  V4ControlsListDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO ControlsList = noteSize[size: SIZE[ControlsList]];    noteArrayDescriptor[      site: parameters, elementSize: SIZE[Control], upperBound: maxControlItems];    IF BASE[parameters­] # NIL THEN      FOR element2: CARDINAL IN [0..LENGTH[parameters­]) DO        noteParameters[@parameters­[element2], V4ControlDescription]; ENDLOOP;    END;  V5ControlsListDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO ControlsList = noteSize[size: SIZE[ControlsList]];    noteArrayDescriptor[      site: parameters, elementSize: SIZE[Control], upperBound: maxControlItems];    IF BASE[parameters­] # NIL THEN      FOR element2: CARDINAL IN [0..LENGTH[parameters­]) DO        noteParameters[@parameters­[element2], V5ControlDescription]; ENDLOOP;    END;  ControlTypeListDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO ControlTypeList = noteSize[      size: SIZE[ControlTypeList]];    noteArrayDescriptor[      site: parameters, elementSize: SIZE[NSFile.ControlType],      upperBound: maxControlItems];    END;  FileHandleDescription: Courier.Description = {    [] ¬ notes.noteSize[SIZE[NSFile.Handle]]};  FilterDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO Filter = noteSize[size: SIZE[Filter]];    noteChoice[parameters, SIZE[Filter], DESCRIPTOR[filterVariantSizes]];    WITH variant: parameters­ SELECT FROM      less, lessOrEqual, equal, notEqual, greaterOrEqual, greater =>        noteParameters[@variant.attribute, DescribeAttribute];      matches => noteParameters[@variant.attribute, DescribeAttribute];      and, or =>        BEGIN        noteArrayDescriptor[          site: @variant.list, elementSize: SIZE[Filter],          upperBound: LAST[CARDINAL]];        IF BASE[variant.list] # NIL THEN          FOR i: CARDINAL IN [0..LENGTH[variant.list]) DO            noteParameters[@variant.list[i], FilterDescription]; ENDLOOP;        END;      not => noteDisjointData[@variant.filter, FilterDescription];      none, all => NULL;      ENDCASE;    END;  -- of FilterDescription  NSStringDescription: PUBLIC Courier.Description =    BEGIN    site: LONG POINTER TO NSString.String = notes.noteSize[SIZE[NSString.String]];    notes.noteDeadSpace[site, SIZE[NSString.String]];    SELECT notes.operation FROM      store => site­ ¬ GetNSString[notes];      fetch => PutNSString[notes, site­];      free => NSString.FreeString[zone, site­];      ENDCASE;    END;  -- of NSStringDescription  -- NOTE: Here we must reverse the 'ordering' and 'depth' scope type encodings since these changed from Filing 4 to Filing 5  V4ScopeDescription: Courier.Description =    BEGIN OPEN notes;    parameters: LONG POINTER TO Scope = noteSize[size: SIZE[Scope]];    noteChoice[      site: parameters, size: SIZE[Scope],      variant: DESCRIPTOR[v4ScopeVariantSizes]];    WITH s: parameters­ SELECT FROM      filter => noteParameters[@s.value, FilterDescription];      ordering =>        SELECT notes.operation FROM          fetch => PutOrdering[notes, @s.value];          store => GetOrdering[notes, @s.value];          ENDCASE;      ENDCASE;    END;  -- of V4ScopeDescription    V5ScopeDescription: Courier.Description =    BEGIN OPEN notes;    parameters: LONG POINTER TO Scope;    scopeType: LONG POINTER TO NSFile.ScopeType;        -- the following is nested here so as not to disturb packaging    DescribeOrdering: Courier.Description = {      ordering: LONG POINTER TO extended NSFile.Ordering = notes.noteSize[        SIZE[NSFile.Ordering]];      notes.noteDeadSpace [LOOPHOLE[@ordering.type], SIZE[NSFile.OrderingType]];      notes.noteLongCardinal [@ordering.key];      -- other fields are implicitly passed because they are unnoted      IF notes.operation = store THEN {        IF ordering.key IN          [NSAssignedTypes.checksum..NSAssignedTypes.subtreeSizeLimit] THEN            LOOPHOLE[@ordering.type, LONG POINTER TO NSFile.OrderingType]­ ¬ key        ELSE LOOPHOLE[          @ordering.type, LONG POINTER TO NSFile.OrderingType]­ ¬ extended}     };        parameters ¬ noteSize[size: SIZE[Scope]];    scopeType ¬ LOOPHOLE[parameters];    SELECT scopeType­ FROM      depth => scopeType­ ¬ ordering;  -- reverse for Filing 5 compatibility      ordering => scopeType­ ¬ depth;      ENDCASE;    noteChoice[      site: parameters, size: SIZE[Scope],      variant: DESCRIPTOR[v5ScopeVariantSizes]];    SELECT scopeType­ FROM      depth => scopeType­ ¬ ordering;  -- undo reversal for proper serialization      ordering => scopeType­ ¬ depth;      ENDCASE;    WITH s: parameters­ SELECT FROM      filter => noteParameters[@s.value, FilterDescription];      ordering => noteParameters[@s.value, DescribeOrdering];      ENDCASE;    END;  -- of V5ScopeDescription  V4ScopeListDescription: Courier.Description =    BEGIN OPEN notes;    parameters: LONG POINTER TO ScopeList = noteSize[size: SIZE[ScopeList]];    noteArrayDescriptor[      site: parameters, elementSize: SIZE[Scope], upperBound: maxScopeItems];    IF BASE[parameters­] # NIL THEN      FOR element2: CARDINAL IN [0..LENGTH[parameters­]) DO        noteParameters[@parameters­[element2], V4ScopeDescription]; ENDLOOP;    END;  V5ScopeListDescription: Courier.Description =    BEGIN OPEN notes;    parameters: LONG POINTER TO ScopeList = noteSize[size: SIZE[ScopeList]];    noteArrayDescriptor[      site: parameters, elementSize: SIZE[Scope], upperBound: maxScopeItems];    IF BASE[parameters­] # NIL THEN      FOR element2: CARDINAL IN [0..LENGTH[parameters­]) DO        noteParameters[@parameters­[element2], V5ScopeDescription]; ENDLOOP;    END;  SessionDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO NSFileCourier.Session = noteSize[      size: SIZE[NSFileCourier.Session]];    noteParameters[@parameters.verifier, Auth.DescribeVerifier];    END;  LogonArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO LogonArguments = noteSize[SIZE[LogonArguments]];    BEGIN OPEN rec: parameters;    noteParameters[@rec.service, NSName.DescribeNameRecord];    noteParameters[@rec.credentials, Auth.DescribeCredentials];    noteParameters[@parameters.verifier, Auth.DescribeVerifier];    END;  --OPEN parameters--    END;  ProbeResultsDescription: Courier.Description --[notes: Notes]--  = {    [] ¬ notes.noteSize[size: SIZE[ProbeResults]]};  V4CreateArgumentsDescription: Courier.Description =    BEGIN OPEN notes;    rec: LONG POINTER TO CreateArguments = noteSize[SIZE[CreateArguments]];    noteParameters[@rec.attributes, V4NSFileCourier.DescribeAttributes];    noteParameters[@rec.controls, V4ControlsListDescription];    noteParameters[@rec.session, SessionDescription];    END;  V5CreateArgumentsDescription: Courier.Description =    BEGIN OPEN notes;    rec: LONG POINTER TO CreateArguments = noteSize[SIZE[CreateArguments]];    noteParameters[@rec.attributes, DescribeAttributes];    noteParameters[@rec.controls, V5ControlsListDescription];    noteParameters[@rec.session, SessionDescription];    END;  V4CopyArgumentsDescription: Courier.Description =    BEGIN OPEN notes;    rec: LONG POINTER TO CopyArguments = noteSize[SIZE[CopyArguments]];    noteParameters[@rec.attributes, V4NSFileCourier.DescribeAttributes];    noteParameters[@rec.controls, V4ControlsListDescription];    noteParameters[@rec.session, SessionDescription];    END;  V5CopyArgumentsDescription: Courier.Description =    BEGIN OPEN notes;    rec: LONG POINTER TO CopyArguments = noteSize[SIZE[CopyArguments]];    noteParameters[@rec.attributes, DescribeAttributes];    noteParameters[@rec.controls, V5ControlsListDescription];    noteParameters[@rec.session, SessionDescription];    END;  MoveArgumentsDescription: Courier.Description =    BEGIN OPEN notes;    rec: LONG POINTER TO MoveArguments = noteSize[SIZE[MoveArguments]];    noteParameters[@rec.attributes, DescribeAttributes];    noteParameters[@rec.session, SessionDescription];    END;  DeleteArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO DeleteArguments = noteSize[      size: SIZE[DeleteArguments]];    noteParameters[@parameters.session, SessionDescription];    END;  V4ListArgumentsDescription: Courier.Description =    BEGIN OPEN notes;    rec: LONG POINTER TO ListArguments = noteSize[SIZE[ListArguments]];    noteParameters[@rec.selections, AttributeTypeListDescription];    noteParameters[@rec.scope, V4ScopeListDescription];    noteParameters[@rec.listing, XStream.DescribeSink];    noteDeadSpace[@rec.listing + SIZE[XStream.Handle],       SIZE[NSDataStream.Ticket] - SIZE[XStream.Handle]];    noteParameters[@rec.session, SessionDescription];    END;  V5ListArgumentsDescription: Courier.Description =    BEGIN OPEN notes;    rec: LONG POINTER TO ListArguments = noteSize[SIZE[ListArguments]];    noteParameters[@rec.selections, AttributeTypeListDescription];    noteParameters[@rec.scope, V5ScopeListDescription];    noteParameters[@rec.listing, XStream.DescribeSink];    noteDeadSpace[@rec.listing + SIZE[XStream.Handle],       SIZE[NSDataStream.Ticket] - SIZE[XStream.Handle]];    noteParameters[@rec.session, SessionDescription];    END;  GetAttributesArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO GetAttributesArguments = noteSize[      size: SIZE[GetAttributesArguments]];    noteParameters[@parameters.selections, AttributeTypeListDescription];    noteParameters[@parameters.session, SessionDescription];    END;  ChangeAttributesArgumentsDescription: Courier.Description =    BEGIN OPEN notes;    rec: LONG POINTER TO ChangeAttributesArguments = noteSize[      SIZE[ChangeAttributesArguments]];    noteParameters[@rec.attributes, DescribeAttributes];    noteParameters[@rec.session, SessionDescription];    END;  UnifyAccessListsArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO UnifyAccessListsArguments = noteSize[      size: SIZE[UnifyAccessListsArguments]];    noteParameters[@parameters.session, SessionDescription];    END;  V4OpenArgumentsDescription: Courier.Description =    BEGIN OPEN notes;    rec: LONG POINTER TO OpenArguments = noteSize[SIZE[OpenArguments]];    noteParameters[@rec.attributes, V4NSFileCourier.DescribeAttributes];    noteParameters[@rec.controls, V4ControlsListDescription];    noteParameters[@rec.session, SessionDescription];    END;  V5OpenArgumentsDescription: Courier.Description =    BEGIN OPEN notes;    rec: LONG POINTER TO OpenArguments = noteSize[SIZE[OpenArguments]];    noteParameters[@rec.attributes, DescribeAttributes];    noteParameters[@rec.controls, V5ControlsListDescription];    noteParameters[@rec.session, SessionDescription];    END;  CloseArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO CloseArguments = noteSize[      size: SIZE[CloseArguments]];    noteParameters[@parameters.session, SessionDescription];    END;  V4ChangeControlsArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO ChangeControlsArguments = noteSize[      size: SIZE[ChangeControlsArguments]];    noteParameters[@parameters.controls, V4ControlsListDescription];    noteParameters[@parameters.session, SessionDescription];    END;  V5ChangeControlsArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO ChangeControlsArguments = noteSize[      size: SIZE[ChangeControlsArguments]];    noteParameters[@parameters.controls, V5ControlsListDescription];    noteParameters[@parameters.session, SessionDescription];    END;  GetControlsArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO GetControlsArguments = noteSize[      size: SIZE[GetControlsArguments]];    noteParameters[@parameters.controlSelections, ControlTypeListDescription];    noteParameters[@parameters.session, SessionDescription];    END;  RetrieveArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO RetrieveArguments = noteSize[      size: SIZE[RetrieveArguments]];    noteParameters[@parameters.content, XStream.DescribeSink];    noteDeadSpace[@parameters.content + SIZE[XStream.Handle],       SIZE[NSDataStream.Ticket] - SIZE[XStream.Handle]];      noteParameters[@parameters.session, SessionDescription];    END;  V4StoreArgumentsDescription: Courier.Description =    BEGIN OPEN notes;    rec: LONG POINTER TO StoreArguments = noteSize[SIZE[StoreArguments]];    noteParameters[@rec.attributes, V4NSFileCourier.DescribeAttributes];    noteParameters[@rec.controls, V4ControlsListDescription];    noteParameters[@rec.content, XStream.DescribeSource];    noteDeadSpace[@rec.content + SIZE[XStream.Handle],       SIZE[NSDataStream.Ticket] - SIZE[XStream.Handle]];    noteParameters[@rec.session, SessionDescription];    END;  V5StoreArgumentsDescription: Courier.Description =    BEGIN OPEN notes;    rec: LONG POINTER TO StoreArguments = noteSize[SIZE[StoreArguments]];    noteParameters[@rec.attributes, DescribeAttributes];    noteParameters[@rec.controls, V5ControlsListDescription];    noteParameters[@rec.content, XStream.DescribeSource];    noteDeadSpace[@rec.content + SIZE[XStream.Handle],       SIZE[NSDataStream.Ticket] - SIZE[XStream.Handle]];    noteParameters[@rec.session, SessionDescription];    END;  V4FindArgumentsDescription: Courier.Description =    BEGIN OPEN notes;    rec: LONG POINTER TO FindArguments = noteSize[SIZE[FindArguments]];    noteParameters[@rec.scope, V4ScopeListDescription];    noteParameters[@rec.controls, V4ControlsListDescription];    noteParameters[@rec.session, SessionDescription];    END;  V5FindArgumentsDescription: Courier.Description =    BEGIN OPEN notes;    rec: LONG POINTER TO FindArguments = noteSize[SIZE[FindArguments]];    noteParameters[@rec.scope, V5ScopeListDescription];    noteParameters[@rec.controls, V5ControlsListDescription];    noteParameters[@rec.session, SessionDescription];    END;  AttributeTypeErrorArgumentsDescription, AttributeValueErrorArgumentsDescription:    Courier.Description  --[notes: Notes]-- =    BEGIN OPEN notes;    parameters: LONG POINTER TO AttributeTypeErrorArguments = noteSize[      size: SIZE[AttributeTypeErrorArguments]];    noteLongCardinal[@parameters.type];    END;  ControlTypeErrorArgumentsDescription, ControlValueErrorArgumentsDescription:    Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO ControlTypeErrorArguments = noteSize[      size: SIZE[ControlTypeErrorArguments]];    END;  ScopeTypeErrorArgumentsDescription, ScopeValueErrorArgumentsDescription:    Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO ScopeTypeErrorArguments = noteSize[      size: SIZE[ScopeTypeErrorArguments]];    END;  AccessErrorArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO AccessErrorArguments = noteSize[      size: SIZE[AccessErrorArguments]];    END;  AuthenticationErrorArgumentsDescription: Courier.Description  --[notes: Notes]--     =    BEGIN OPEN notes;    parameters: LONG POINTER TO AuthenticationErrorArguments = noteSize[      size: SIZE[AuthenticationErrorArguments]];    END;  ConnectionErrorArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO ConnectionErrorArguments = noteSize[      size: SIZE[ConnectionErrorArguments]];    END;  HandleErrorArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO HandleErrorArguments = noteSize[      size: SIZE[HandleErrorArguments]];    END;  InsertionErrorArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO InsertionErrorArguments = noteSize[      size: SIZE[InsertionErrorArguments]];    END;  ServiceErrorArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO ServiceErrorArguments = noteSize[      size: SIZE[ServiceErrorArguments]];    END;  SessionErrorArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO SessionErrorArguments = noteSize[      size: SIZE[SessionErrorArguments]];    END;  SpaceErrorArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO SpaceErrorArguments = noteSize[      size: SIZE[SpaceErrorArguments]];    END;  TransferErrorArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO TransferErrorArguments = noteSize[      size: SIZE[TransferErrorArguments]];    END;  UndefinedErrorArgumentsDescription: Courier.Description --[notes: Notes]--  =    BEGIN OPEN notes;    parameters: LONG POINTER TO UndefinedErrorArguments = noteSize[      size: SIZE[UndefinedErrorArguments]];    END;  --  No Module Initialization   END.    LOG (date - person - action)22-Feb-88 10:32:29  AOF  Modifed NSFileCourierUtilityBImpl for XStream
-- Copyright (C) 1982, 1983, 1984, 1987 by Xerox Corporation. All rights reserved.-- AccessFloppyImpl.mesa--   CXK	16-Aug-82 17:30:15--   XXJ	 9-Nov-83 17:43:01--   DWC        21-Jun-84 10:25:35--   RSV         7-Oct-87 10:27:19DIRECTORY  AccessFloppy USING [    Attributes, AttributesRecord, currentVersion, ErrorType, leaderLength,    maxDataSize, sealValue, tFloppyLeaderPage],  Environment USING [bytesPerPage],  File USING [Type],  Floppy USING [    Close, CreateFile, DeleteFile, FileHandle, FileID, GetFileAttributes,    GetNextFile, nullFileID, nullVolumeHandle, Open, PageCount, PageNumber,    Read, Write, VolumeHandle],  FloppyExtras4 USING [GetNextFloppyDrive, nullDrive],  Heap USING [Create, Delete],  Inline USING [LongCOPY],  NSString USING [CopyString, EquivalentStrings, FreeString, String];AccessFloppyImpl: PROGRAM  IMPORTS Floppy, FloppyExtras4, Heap, Inline, NSString  EXPORTS AccessFloppy =  BEGIN  vH: Floppy.VolumeHandle ¬ Floppy.nullVolumeHandle;  -- currently accessed floppy disk; is set when a volume is open, is set to nullVolumeHandle when Close is called, and is invalid when opened is FALSE.  opened: BOOLEAN ¬ FALSE;  nullFile: Floppy.FileHandle;  -- is initialized when the volume is open.    drive: CARDINAL = FloppyExtras4.GetNextFloppyDrive[FloppyExtras4.nullDrive];  -- Volume operations  Open: PUBLIC PROCEDURE RETURNS [Floppy.VolumeHandle] =    -- Call Floppy.Open, remember VolumeHandle of active floppy disk.    BEGIN    vH ¬ Floppy.Open[drive];    nullFile ¬ [vH, Floppy.nullFileID];    opened ¬ TRUE;    RETURN[vH];    END;  -- Open.  Close: PUBLIC PROCEDURE =    -- Call before floppy disk is removed from the drive.    BEGIN    ResetCache[];    IF opened THEN {      opened ¬ FALSE; Floppy.Close[vH]; vH ¬ Floppy.nullVolumeHandle}    ELSE RETURN WITH ERROR Error[volumeNotOpen];    END;  -- Close.  -- File operations  CreateFile: PUBLIC PROCEDURE [attributes: AccessFloppy.Attributes]    RETURNS [Floppy.FileHandle] =    -- Create a file with the specified size and write information onto the leader page.    BEGIN    size: Floppy.PageCount;    fH: Floppy.FileHandle;    IF ~opened THEN RETURN WITH ERROR Error[volumeNotOpen];    IF attributes = NIL THEN RETURN WITH ERROR Error[invalidParameter];    attributes.version ¬ AccessFloppy.currentVersion;    attributes.seal ¬ AccessFloppy.sealValue;    fH ¬ nullFile;    size ¬ attributes.size + AccessFloppy.leaderLength;    fH ¬ Find[      NameFromAttributes[attributes] !      Error => IF type = fileNotFound THEN CONTINUE;      InconsistentFile => {fH ¬ file; CONTINUE}];    IF fH # nullFile THEN RETURN WITH ERROR Error[nameInUse];    fH ¬ Floppy.CreateFile[vH, size, AccessFloppy.tFloppyLeaderPage];    WriteLeaderPage[fH, attributes];    AddCacheItem[NameFromAttributes[attributes], fH];    RETURN[fH];    END;  -- CreateFile.  DeleteFile: PUBLIC PROCEDURE [name: NSString.String] =    BEGIN    file: Floppy.FileHandle;    IF ~opened THEN RETURN WITH ERROR Error[volumeNotOpen];    file ¬ Find[name];    Floppy.DeleteFile[file];    RemoveCacheItem[file];    END;  -- DeleteFile.  LookUp: PUBLIC PROCEDURE [    name: NSString.String, attributes: AccessFloppy.Attributes]    RETURNS [Floppy.FileHandle] =    BEGIN    file: Floppy.FileHandle ¬ nullFile;    IF ~opened THEN RETURN WITH ERROR Error[volumeNotOpen];    file ¬ Find[name];    IF attributes # NIL THEN GetAttributes[file, attributes];    RETURN[file];    END;  -- LookUp.  -- Attribute Operations  GetAttributes: PUBLIC PROCEDURE [    file: Floppy.FileHandle, attributes: AccessFloppy.Attributes] =    BEGIN    size: Floppy.PageCount;    type: File.Type;    [size, type] ¬ Floppy.GetFileAttributes[file];    IF ~opened THEN RETURN WITH ERROR Error[volumeNotOpen];    IF attributes = NIL THEN RETURN WITH ERROR Error[invalidParameter];    IF type # AccessFloppy.tFloppyLeaderPage THEN {      attributes.size ¬ size;      attributes.type ¬ type;      attributes.version ¬ AccessFloppy.currentVersion;      attributes.offset ¬ 0;      attributes.totalSize ¬ size;      attributes.totalSizeInBytes ¬ size * Environment.bytesPerPage;      }    ELSE ReadLeaderPage[file, attributes];    END;  -- GetAttributes.  SetAttributes: PUBLIC PROCEDURE [    file: Floppy.FileHandle, attributes: AccessFloppy.Attributes] =    BEGIN    IF ~opened THEN RETURN WITH ERROR Error[volumeNotOpen];    IF attributes = NIL THEN RETURN WITH ERROR Error[invalidParameter];    WriteLeaderPage[file, attributes];    END;  -- SetAttributes.  -- Signals and errors  Error: PUBLIC ERROR [type: AccessFloppy.ErrorType] = CODE;  InconsistentFile: PUBLIC SIGNAL [file: Floppy.FileHandle] = CODE;  InvalidVersion: PUBLIC SIGNAL [file: Floppy.FileHandle, version: CARDINAL] =    CODE;  NoRoomForClientData: PUBLIC ERROR [wordsNeeded: CARDINAL] = CODE;  -- Private procedures  NameFromAttributes: PROCEDURE [attributes: AccessFloppy.Attributes]    RETURNS [NSString.String] = INLINE {    RETURN[      [LOOPHOLE[@attributes.name], attributes.length, attributes.length]]};  ReadLeaderPage: PROC [    file: Floppy.FileHandle, attributes: AccessFloppy.Attributes] =    BEGIN    -- make the buffer for the AttributesRecord in full pages.    buffer: ARRAY      [1..AccessFloppy.maxDataSize + SIZE[AccessFloppy.AttributesRecord]] OF      WORD ¬ ALL[0];    length: CARDINAL ¬ 0;    tempLength: CARDINAL;    localAttributes: AccessFloppy.Attributes ¬ LOOPHOLE[LONG[@buffer]];    Floppy.Read[file, 0, AccessFloppy.leaderLength, localAttributes];    -- Now copy the local attributes record into the one passed in.    -- If all of the ClientData won't fit, then don't copy any of it.    tempLength ¬ attributes.maxlength;    IF localAttributes.clientDataLength > attributes.maxlength THEN      localAttributes.clientDataLength ¬ 0;    length ¬      SIZE[AccessFloppy.AttributesRecord] + localAttributes.clientDataLength;    [] ¬ Inline.LongCOPY[      to: attributes, nwords: length, from: localAttributes];    buffer[SIZE[AccessFloppy.AttributesRecord]] ¬ tempLength;  -- restore the original value of maxlength    END;  -- ReadLeaderPage.  WriteLeaderPage: PROC [    file: Floppy.FileHandle, attributes: AccessFloppy.Attributes] =    BEGIN    attributes.seal ¬ AccessFloppy.sealValue;    Floppy.Write[file, 0, AccessFloppy.leaderLength, attributes];    END;  -- WriteLeaderPage.  -- "directory" "cache"  DirItem: TYPE = RECORD [    link: DirHandle, name: NSString.String, file: Floppy.FileHandle];  DirHandle: TYPE = LONG POINTER TO DirItem;  dirList: DirHandle ¬ NIL;  dirZone: UNCOUNTED ZONE ¬ NIL;  dirComplete: BOOLEAN ¬ FALSE;  Find: PROC [name: NSString.String] RETURNS [file: Floppy.FileHandle] =    BEGIN    -- make the buffer for the AttributesRecord in full pages.    buffer: ARRAY      [1..AccessFloppy.maxDataSize + SIZE[AccessFloppy.AttributesRecord]] OF      WORD ¬ ALL[0];    localAttributes: AccessFloppy.Attributes ¬ LOOPHOLE[LONG[@buffer]];    buffer[SIZE[AccessFloppy.AttributesRecord]] ¬ AccessFloppy.maxDataSize;  -- set localAttributes.maxlength to maxDataSize.    IF dirZone = NIL THEN dirZone ¬ Heap.Create[initial: 3];    file ¬ LookupInCache[name];    SELECT TRUE FROM      file # nullFile => ReadLeaderPage[file, localAttributes];      ~dirComplete => {        IF dirList # NIL THEN file ¬ dirList.file;        FOR file ¬ Floppy.GetNextFile[file].nextFile, Floppy.GetNextFile[          file].nextFile WHILE file # nullFile DO          IF Floppy.GetFileAttributes[file].type #            AccessFloppy.tFloppyLeaderPage THEN LOOP;          ReadLeaderPage[file, localAttributes];          AddCacheItem[NameFromAttributes[localAttributes], file];          IF NSString.EquivalentStrings[            name, NameFromAttributes[localAttributes]] THEN EXIT;          REPEAT FINISHED => {dirComplete ¬ TRUE; ERROR Error[fileNotFound]};          ENDLOOP}      ENDCASE => ERROR Error[fileNotFound];    IF localAttributes.seal # AccessFloppy.sealValue THEN      SIGNAL InconsistentFile[file];    END;  -- Find.  AddCacheItem: PROCEDURE [name: NSString.String, file: Floppy.FileHandle] =    BEGIN    dh: DirHandle = dirZone.NEW[      DirItem ¬ [      link: dirList, name: NSString.CopyString[dirZone, name], file: file]];    dirList ¬ dh;    END;  LookupInCache: PROCEDURE [name: NSString.String]    RETURNS [file: Floppy.FileHandle] =    BEGIN    IF dirList = NIL THEN RETURN[nullFile];    FOR dh: DirHandle ¬ dirList, dh.link UNTIL dh = NIL DO      IF NSString.EquivalentStrings[name, dh.name] THEN RETURN[dh.file];      ENDLOOP;    RETURN[nullFile];    END;  RemoveCacheItem: PROCEDURE [file: Floppy.FileHandle] =    BEGIN    prev: DirHandle ¬ NIL;    dh: DirHandle;    FOR dh ¬ dirList, dh.link UNTIL dh = NIL DO      IF dh.file = file THEN {        IF prev = NIL THEN dirList ¬ dh.link ELSE prev.link ¬ dh.link;        NSString.FreeString[dirZone, dh.name];        dirZone.FREE[@dh];        EXIT}      ELSE prev ¬ dh;      ENDLOOP;    END;  ResetCache: PROCEDURE =    BEGIN    IF dirZone # NIL THEN Heap.Delete[dirZone];    dirZone ¬ NIL;    dirList ¬ NIL;    dirComplete ¬ FALSE;    END;  END. -- AccessFloppyImpl.     LOG [Time - Person - Action]  21-Jun-84 10:27:12 - DWC - Started with Pilot Version from [idun]<Apilot>11.0>floppy>private and then fixed a bug in ReadLeaderPage where the sequence.maxlength got smashed. AR #8996.  7-Oct-87 10:27:19 - RSV - Don't assume drive 0.
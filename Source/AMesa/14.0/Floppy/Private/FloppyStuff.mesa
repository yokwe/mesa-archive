-- Copyright (C) 1983, 1986, 1987 by Xerox Corporation. All rights reserved. -- File: FloppyStuff.mesa - last edit:-- RSV            7-Oct-87 10:24:15-- JBD           26-Feb-87  8:13:40-- DWR            7-Aug-86 12:08:32-- RXJ      	 21-Dec-83 15:43:34-- NSG     	  5-Mar-85 14:46:45DIRECTORY  AccessFloppy USING [    Attributes, AttributesRecord, Close, CreateFile, currentVersion, DeleteFile,    Error, ErrorType, GetAttributes, InconsistentFile, InvalidVersion,    leaderLength, LookUp, maxDataSize, maxNameLength, NoRoomForClientData,    Open, SetAttributes, tFloppyLeaderPage],  Ascii USING [CR, SP],  Environment USING [bytesPerPage],  Exec USING [    AddCommand, CheckForAbort, Confirm, ExecProc, FreeTokenString, GetToken,    Handle, MatchPattern, Outcome, OutputProc],  File USING [Type],  FileTypes USING [tUntypedFile],  Floppy USING [    AlreadyFormatted, Close, CopyFromPilotFile, CopyToPilotFile, Density,    Error, ErrorType, FileHandle, Format, GetAttributes, GetFileAttributes,    GetNextFile, maxCharactersInLabel, nullFileID, Open, Sides, VolumeHandle],  FloppyExtras USING [ExtrasError, Erase, NewScavenge],  FloppyExtras4 USING [GetNextFloppyDrive, nullDrive],  Format USING [    Char, Date, Decimal, Line, LongDecimal, LongNumber, Number, StringProc],  Heap USING [systemZone],  MFile USING [    Error, ErrorCode, GetProperties, Handle, ReadOnly, Release,    SetProperties, Type, WriteOnly],  NSString USING [String, StringFromMesaString],  SpecialMFile USING [GetCapaWithAccess, LeaderPages],  String USING [AppendLongDecimal, AppendString, InvalidNumber, StringToNumber],  StringLookUp USING [InTable, noMatch],   Time USING [Current],  Token USING [Decimal, FreeStringHandle, Handle, StringToHandle, SyntaxError],  Volume USING [InsufficientSpace];FloppyStuff: PROGRAM  IMPORTS    AccessFloppy, Exec, Floppy, FloppyExtras, FloppyExtras4, Format, Heap,    MFile, NSString, SpecialMFile, String, StringLookUp, Time, Token, Volume =      BEGIN    dataVersion: CARDINAL = 02222; -- version of clientData  nFiles: CARDINAL ¬ 63;  label: LONG STRING ¬ [Floppy.maxCharactersInLabel];    Abort: ERROR [s: STRING] = CODE;  SetOutcome: SIGNAL [value: Exec.Outcome] = CODE;    drive: CARDINAL = FloppyExtras4.GetNextFloppyDrive[FloppyExtras4.nullDrive];    WriteFloppyError: PROCEDURE [Write: Format.StringProc, error: Floppy.ErrorType] =    BEGIN    Write["Floppy.Error["L];    Write[SELECT error FROM      badDisk => "badDisk"L,      badSectors => "badSectors"L,      endOfFile => "endOfFile"L,      fileListFull => "fileListFull"L,      fileNotFound => "fileNotFound"L,      hardwareError => "hardwareError"L,      incompatibleSizes => "incompatibleSizes"L,      invalidFormat => "invalidFormat"L,      invalidPageNumber => "invalidPageNumber"L,      invalidVolumeHandle => "invalidVolumeHandle"L,      insufficientSpace => "insufficientSpace"L,      needsScavenging => "needsScavenging"L,      noSuchDrive => "noSuchDrive"L,      notReady => "notReady"L,      onlyOneSide => "onlyOneSide"L,      onlySingleDensity => "onlySingleDensity"L,      initialMicrocodeSpaceNotAvailable => "initialMicrocodeSpaceNotAvailable"L,      stringTooShort => "stringTooShort"L,      volumeNotOpen => "volumeNotOpen"L,      writeInhibited => "writeInhibited"L,      ENDCASE => "?"L];    Format.Char[Write, ']];    END;  WriteAccessFloppyError: PROCEDURE [Write: Format.StringProc, type: AccessFloppy.ErrorType] =    BEGIN    Write["AccessFloppy.Error["L];    Write[SELECT type FROM      attributesNotAllowed => "attributesNotAllowed"L,      fileNotFound => "fileNotFound"L,      invalidParameter => "invalidParameter"L,      nameInUse => "nameInUse"L,      volumeNotOpen => "volumeNotOpen"L,      ENDCASE => "?"L];    Format.Char[Write, ']];    END;  WritePartial: PROCEDURE [Write: Format.StringProc, attributes: AccessFloppy.Attributes]    RETURNS [chars: CARDINAL ¬ 0] =    BEGIN    CountedNumber: PROCEDURE [n: LONG CARDINAL] RETURNS [CARDINAL] = {      s: STRING = [12];      String.AppendLongDecimal[s, n];      Write[s];      RETURN[s.length]};    IF attributes.offset # 0 OR attributes.size # attributes.totalSize THEN {      chars ¬ 4;      Format.Char[Write, '[];      chars ¬ chars + CountedNumber[attributes.offset];      Write[".."L];      chars ¬ chars + CountedNumber[attributes.offset+attributes.size-1];      Format.Char[Write, ']]};    END;  ReadFiles: PROCEDURE [gSwitches: LONG STRING, h: Exec.Handle] =     BEGIN    attributes: AccessFloppy.Attributes ¬ NIL;    name, altName, switches: LONG STRING ¬ NIL;    Write: Format.StringProc = Exec.OutputProc[h];    v: Floppy.VolumeHandle;    ReadOne: EnumProc =      BEGIN      mFile: MFile.Handle;      type: MFile.Type ¬ unknown;      destName: LONG STRING = IF altName = NIL THEN name ELSE altName;      Write[name];      Write["... "L];      IF attributes.clientDataLength = 2 AND        attributes.clientData[0] = dataVersion THEN	  type ¬ attributes.clientData[1];      Write["copying to "L];      Write[destName]; [] ¬ WritePartial[Write, attributes];      Write["... "L];      mFile ¬ MFile.WriteOnly[destName, [], type, attributes.totalSizeInBytes	! MFile.Error => {	  Format.Line[Write, "can't write on destination file"L];	  SetOutcome[error];	  GOTO return}];      MFile.SetProperties[	file: mFile, type: type,	length: attributes.totalSizeInBytes,        create: attributes.createDate];      IF attributes.size # 0 THEN Floppy.CopyToPilotFile[        floppyFile: fH,        pilotFile: SpecialMFile.GetCapaWithAccess[mFile],        firstFloppyPage: AccessFloppy.leaderLength,        firstPilotPage: SpecialMFile.LeaderPages[]+attributes.offset,	count: attributes.size];      Format.Line[Write, "copied"L];      MFile.Release[mFile];      EXITS return => NULL;      END;    v ¬ AccessFloppy.Open[      !AccessFloppy.Error => ERROR Abort["Can't open floppy"L]];    DO ENABLE UNWIND => {        altName ¬ Exec.FreeTokenString[altName];        name ¬ Exec.FreeTokenString[name];        switches ¬ Exec.FreeTokenString[switches];	Heap.systemZone.FREE[@attributes];	AccessFloppy.Close[!Floppy.Error=>CONTINUE]};      fFile: Floppy.FileHandle;      failed: BOOLEAN ¬ FALSE;      IF attributes = NIL THEN attributes ¬ Heap.systemZone.NEW[        AccessFloppy.AttributesRecord[AccessFloppy.maxDataSize]];      altName ¬ Exec.FreeTokenString[altName];      name ¬ Exec.FreeTokenString[name];      switches ¬ Exec.FreeTokenString[switches];      [name, switches] ¬ Exec.GetToken[h];      IF name = NIL AND switches = NIL THEN EXIT;      IF Exec.CheckForAbort[h] THEN SetOutcome[abort];      IF WildCards[name] THEN {        EnumerateFloppyFiles[v, ReadOne, h, name]; LOOP};      IF switches # NIL AND switches.length # 0 AND switches[0] = 's THEN {        switches ¬ Exec.FreeTokenString[switches];        [altName, switches] ¬ Exec.GetToken[h]};      fFile ¬ AccessFloppy.LookUp[        NSString.StringFromMesaString[name], attributes	  ! AccessFloppy.Error =>            IF type = fileNotFound THEN {failed ¬ TRUE; CONTINUE}	    ELSE ERROR Abort["Floppy Error"L]];      IF failed THEN {        Write[name]; Format.Line[Write, " not found"L]; SetOutcome[error]; LOOP}      ELSE [] ¬ ReadOne[attributes, fFile, NameFromAttributes[attributes]];      ENDLOOP;    Heap.systemZone.FREE[@attributes];    AccessFloppy.Close[];    END;  WriteFiles: PROCEDURE [gSwitches: LONG STRING, h: Exec.Handle] =    BEGIN    attributes: AccessFloppy.Attributes ¬ NIL;    name, altName, switches: LONG STRING ¬ NIL;    fileType: File.Type ¬ FileTypes.tUntypedFile;    mFile: MFile.Handle;    Write: Format.StringProc = Exec.OutputProc[h];    IF gSwitches # NIL THEN      fileType ¬ [String.StringToNumber[gSwitches!String.InvalidNumber => CONTINUE]];    [] ¬ AccessFloppy.Open[      !AccessFloppy.Error => ERROR Abort["Can't open floppy"L]];    DO ENABLE UNWIND => {        IF altName # name THEN altName ¬ Exec.FreeTokenString[altName];        name ¬ Exec.FreeTokenString[name];        switches ¬ Exec.FreeTokenString[switches];	IF mFile # NIL THEN MFile.Release[mFile];	Heap.systemZone.FREE[@attributes];	AccessFloppy.Close[!Floppy.Error=>CONTINUE]};      fFile: Floppy.FileHandle ¬ [TRASH, Floppy.nullFileID];      mFileError: MFile.ErrorCode;      offset, length: CARDINAL;      IF Exec.CheckForAbort[h] THEN SetOutcome[abort];      IF attributes = NIL THEN attributes ¬ Heap.systemZone.NEW[        AccessFloppy.AttributesRecord[AccessFloppy.maxDataSize]];      mFile ¬ NIL;      IF altName # name THEN altName ¬ Exec.FreeTokenString[altName];      name ¬ Exec.FreeTokenString[name];      switches ¬ Exec.FreeTokenString[switches];      [name, switches] ¬ Exec.GetToken[h];      IF name = NIL AND switches = NIL THEN EXIT;      [offset, length] ¬ ParsePartial[name ! Token.SyntaxError => {	Write[name]; Format.Line[Write, " - bad name syntax"L];	SetOutcome[error]; LOOP}];      IF switches # NIL AND switches.length # 0 THEN        SELECT switches[0] FROM	  's => {	    switches ¬ Exec.FreeTokenString[switches];	    [altName, switches] ¬ Exec.GetToken[h]};	  't => {	    fileType ¬ [String.StringToNumber[name!String.InvalidNumber => CONTINUE]];	    switches ¬ Exec.FreeTokenString[switches];	    LOOP};	  ENDCASE      ELSE altName ¬ name;      Write[name];      mFile ¬ MFile.ReadOnly[name, [] ! MFile.Error => {        mFileError ¬ code; CONTINUE}];      IF mFile = NIL THEN SELECT mFileError FROM	noSuchFile => {	  Format.Line[Write, " not found"L]; SetOutcome[error]; LOOP};	conflictingAccess => {	  Format.Line[Write, " conflicting access"L]; SetOutcome[error]; LOOP};	ENDCASE => ERROR Abort[" unexpected MFile.Error"L];      MakeAttributes[mFile, altName, attributes, fileType];      attributes.offset ¬ offset;      attributes.size ¬ MIN[length, attributes.totalSize-offset];      [] ¬ WritePartial[Write, attributes];      Write["... "L];      Write["copying to "L]; Write[altName]; Write["... "L];      fFile ¬ AccessFloppy.CreateFile[attributes        ! AccessFloppy.Error => IF type = nameInUse THEN {	  fFile ¬ OverwriteFile[attributes ! SameFile => {	    Format.Line[Write,	      "floppy file already exists with same create date - skipped"L];	    MFile.Release[mFile]; mFile ¬ NIL;	    LOOP}];	  IF fFile.file = Floppy.nullFileID THEN {	    Write["deleted existing file... "L]; RETRY}	  ELSE {Write["overwriting existing file... "L]; CONTINUE}};	  Floppy.Error => SELECT error FROM	    fileListFull => ERROR Abort["too many files"L];	    insufficientSpace => ERROR Abort["floppy is full"L];	    ENDCASE];      IF attributes.size # 0 THEN Floppy.CopyFromPilotFile[	floppyFile: fFile,	pilotFile: SpecialMFile.GetCapaWithAccess[mFile],	firstFloppyPage: AccessFloppy.leaderLength,	firstPilotPage: SpecialMFile.LeaderPages[]+offset,	count: attributes.size];      Format.Line[Write, "copied"L];      MFile.Release[mFile];      mFile ¬ NIL;      ENDLOOP;    Heap.systemZone.FREE[@attributes];    AccessFloppy.Close[];    END;	  SameFile: SIGNAL = CODE;    OverwriteFile: PROCEDURE [newAttributes: AccessFloppy.Attributes]    RETURNS [fFile: Floppy.FileHandle] =    BEGIN    fileName: NSString.String = [length: newAttributes.length, maxlength: newAttributes.length, bytes: LOOPHOLE[@newAttributes.name]];    oldAttributes: AccessFloppy.Attributes ¬ Heap.systemZone.NEW[      AccessFloppy.AttributesRecord[AccessFloppy.maxDataSize]];    {ENABLE UNWIND =>Heap.systemZone.FREE[@oldAttributes];    fFile ¬ AccessFloppy.LookUp[fileName, oldAttributes];    oldAttributes.size ¬ Floppy.GetFileAttributes[fFile].size - AccessFloppy.leaderLength;    IF oldAttributes.createDate = newAttributes.createDate       AND oldAttributes.totalSizeInBytes = newAttributes.totalSizeInBytes      AND oldAttributes.offset = newAttributes.offset THEN SIGNAL SameFile;    IF newAttributes.size > oldAttributes.size OR      (oldAttributes.size - newAttributes.size) > 20 THEN { -- delete and recreate      AccessFloppy.DeleteFile[fileName];      fFile.file ¬ Floppy.nullFileID}    ELSE AccessFloppy.SetAttributes[fFile, newAttributes]}; -- end ENABLE    Heap.systemZone.FREE[@oldAttributes];    END;   	  MakeAttributes: PROCEDURE [    file: MFile.Handle, name: LONG STRING,    attributes: AccessFloppy.Attributes, type: File.Type] =    BEGIN    attributes.version ¬ AccessFloppy.currentVersion;    attributes.type ¬ type;    attributes.lastWrittenDate ¬ Time.Current[];    attributes.name ¬ ALL[0];    attributes.clientDataLength ¬ 2;    attributes.clientData[0] ¬ dataVersion;    [length: attributes.totalSizeInBytes,      create: attributes.createDate,      type: attributes.clientData[1]] ¬ MFile.GetProperties[file];    attributes.totalSize ¬ PagesFromBytes[attributes.totalSizeInBytes];    attributes.size ¬ attributes.totalSize;    attributes.length ¬ MIN[name.length, AccessFloppy.maxNameLength];    FOR i: CARDINAL IN [0..attributes.length) DO      attributes.name[i] ¬ LOOPHOLE[name[i]];      ENDLOOP    END;     ParsePartial: PROCEDURE [name: LONG STRING]    RETURNS [offset: CARDINAL ¬ 0, length: CARDINAL ¬ LAST[CARDINAL]] =    BEGIN    h: Token.Handle;    i: CARDINAL;    IF name = NIL THEN RETURN;    FOR i IN [1..name.length) DO      IF name[i] = '[ THEN EXIT;      REPEAT FINISHED => RETURN      ENDLOOP;    h ¬ Token.StringToHandle[name, i+1];    BEGIN ENABLE UNWIND => [] ¬ Token.FreeStringHandle[h];    offset ¬ Token.Decimal[h];    SELECT h.break FROM      '. => IF h.getChar[h] = '. THEN length ¬ Token.Decimal[h]-offset+1        ELSE ERROR Token.SyntaxError[NIL];      '! => length ¬ Token.Decimal[h];      '] => NULL;      ENDCASE => ERROR Token.SyntaxError[NIL];    END;    name.length ¬ i;    [] ¬ Token.FreeStringHandle[h];    END;     PagesFromBytes: PROCEDURE [bytes: LONG CARDINAL] RETURNS [LONG CARDINAL] =    BEGIN    RETURN [(bytes + Environment.bytesPerPage - 1)/ Environment.bytesPerPage];    END;    EnumProc: TYPE = PROCEDURE [    attributes: AccessFloppy.Attributes, fH: Floppy.FileHandle, name: LONG STRING]    RETURNS [stop: BOOLEAN ¬ FALSE];    EnumerateFloppyFiles: PROCEDURE [    v: Floppy.VolumeHandle, proc: EnumProc, h: Exec.Handle,    pattern: LONG STRING ¬ NIL] =    BEGIN    nullFile: Floppy.FileHandle = [volume: v, file: Floppy.nullFileID];    attributes: AccessFloppy.Attributes ¬ Heap.systemZone.NEW[      AccessFloppy.AttributesRecord[AccessFloppy.maxDataSize]];    name: LONG STRING = LOOPHOLE[@attributes.length];    FOR current: Floppy.FileHandle ¬       Floppy.GetNextFile[nullFile].nextFile,      Floppy.GetNextFile[current].nextFile      WHILE current#nullFile DO        ENABLE UNWIND => Heap.systemZone.FREE[@attributes];	IF Exec.CheckForAbort[h] THEN SetOutcome[abort];	IF Floppy.GetFileAttributes[current].type # AccessFloppy.tFloppyLeaderPage THEN LOOP;        AccessFloppy.GetAttributes[current, attributes];        IF (pattern = NIL OR Exec.MatchPattern[string: name, pattern: pattern])	  AND proc[attributes, current, name] THEN EXIT;        ENDLOOP;    Heap.systemZone.FREE[@attributes];    END;     ListFiles: PROCEDURE [gSwitches: LONG STRING, h: Exec.Handle] =    BEGIN    Item: TYPE = {length, create, write, type};    show: PACKED ARRAY Item OF BOOLEAN ¬ ALL[FALSE];    pattern: LONG STRING ¬ NIL;    Write: Format.StringProc = Exec.OutputProc[h];    v: Floppy.VolumeHandle;    ListOne: EnumProc =      BEGIN      Format.Char[Write, Ascii.CR];      Write[name];      FOR i: CARDINAL IN [name.length + WritePartial[Write, attributes]..24) DO	Format.Char[Write, Ascii.SP]; ENDLOOP;      IF show[type] THEN {        Format.Number[Write, attributes.type, [10,FALSE,TRUE,5]];	Write["  "L]};      IF show[length] THEN {        Format.LongNumber[Write, attributes.totalSizeInBytes, [10,FALSE,TRUE,9]];	Write["  "L]};      IF show[create] THEN {        Format.Date[Write, attributes.createDate, full]; Write["  "L]};      IF show[write] THEN Format.Date[Write, attributes.lastWrittenDate, full];      END;    v ¬ AccessFloppy.Open[!AccessFloppy.Error =>      ERROR Abort["Can't open floppy"L]];    IF gSwitches # NIL THEN      FOR i: CARDINAL IN[0..gSwitches.length) DO        SELECT gSwitches[i] FROM	  'v => show ¬ ALL[TRUE];	  'l => show[length] ¬ TRUE;	  'd => show[create] ¬ TRUE;	  'w => show[write] ¬ TRUE;	  't => show[type] ¬ TRUE;	  ENDCASE;	ENDLOOP;    [pattern, gSwitches] ¬ Exec.GetToken[h];    gSwitches ¬ Exec.FreeTokenString[gSwitches];    Write["name                    "L]; -- 24    IF show[type] THEN Write[" type  "L]; -- 5+2    IF show[length] THEN Write["   length  "L]; -- 9+2    IF show[create] THEN Write["        create          "L]; -- 22+2    IF show[write] THEN Write["        write"L];    EnumerateFloppyFiles[v, ListOne, h, pattern ! UNWIND => {      pattern ¬ Exec.FreeTokenString[pattern];      AccessFloppy.Close[!Floppy.Error=>CONTINUE]}];    pattern ¬ Exec.FreeTokenString[pattern];    AccessFloppy.Close[];    END;    WildCards: PROCEDURE [pattern: LONG STRING] RETURNS [BOOLEAN] = {    IF pattern # NIL THEN FOR i: CARDINAL IN[0..pattern.length) DO      SELECT pattern[i] FROM '*, '# => RETURN[TRUE]; ENDCASE;      ENDLOOP;    RETURN[FALSE]};    NameFromAttributes: PROCEDURE [attributes: AccessFloppy.Attributes] RETURNS [LONG STRING] =    INLINE {RETURN[LOOPHOLE[@attributes.length]]};    DeleteFiles: PROCEDURE [gSwitches: LONG STRING, h: Exec.Handle] =    BEGIN    name, switches: LONG STRING ¬ NIL;    Write: Format.StringProc = Exec.OutputProc[h];    v: Floppy.VolumeHandle;    DeleteOne: EnumProc =      BEGIN      Write[name];      Write["... "L];      AccessFloppy.DeleteFile[NSString.StringFromMesaString[name] !        AccessFloppy.Error => SELECT type FROM 	  fileNotFound => {Format.Line[Write, "not found"L]; GOTO error};	  ENDCASE];      Format.Line[Write, "deleted"L];      EXITS error => SetOutcome[error];      END;    v ¬ AccessFloppy.Open[      !AccessFloppy.Error => ERROR Abort["Can't open floppy"L]];    DO ENABLE UNWIND => {        name ¬ Exec.FreeTokenString[name];        switches ¬ Exec.FreeTokenString[switches];	AccessFloppy.Close[!Floppy.Error=>CONTINUE]};      name ¬ Exec.FreeTokenString[name];      [name, switches] ¬ Exec.GetToken[h];      switches ¬ Exec.FreeTokenString[switches];      IF name = NIL AND switches = NIL THEN EXIT;      IF Exec.CheckForAbort[h] THEN SetOutcome[abort];      IF WildCards[name] THEN EnumerateFloppyFiles[v, DeleteOne, h, name]      ELSE [] ¬ DeleteOne[NIL, [v, Floppy.nullFileID], name];      ENDLOOP;    AccessFloppy.Close[];    END;    FormatDisk: PROCEDURE [gSwitches: LONG STRING, h: Exec.Handle] =    BEGIN    Write: Format.StringProc = Exec.OutputProc[h];    density: Floppy.Density ¬ default;    sides: Floppy.Sides ¬ default;    arg, switches: LONG STRING ¬ NIL;    BEGIN    gotError: BOOLEAN ¬ FALSE;    v: Floppy.VolumeHandle;    v ¬ Floppy.Open[drive ! Floppy.Error => SELECT error FROM      invalidFormat => GOTO virgin;      needsScavenging => {gotError ¬ TRUE; CONTINUE};      ENDCASE];    IF ~gotError THEN {      [] ¬ Floppy.GetAttributes[v, label];      Floppy.Close[v];      Write["Floppy volume """L]; Write[label];      Write[""" already formatted"L]}    ELSE Write["Floppy probably contains valid information"L];    Write["; formatting will destroy previous contents"L];    IF ~Exec.Confirm[h] THEN ERROR Abort[NIL];    Format.Line[Write, " yes"L];    EXITS virgin => NULL;    END;    label.length ¬ 0;    String.AppendString[label, "UnnamedFloppy"L];    DO      arg ¬ Exec.FreeTokenString[arg];      switches ¬ Exec.FreeTokenString[switches];      [arg, switches] ¬ Exec.GetToken[h];      IF arg = NIL AND switches = NIL THEN EXIT;      IF switches = NIL THEN LOOP;      FOR i: CARDINAL IN [0..switches.length) DO	SELECT switches[i] FROM	  'n => {	    label.length ¬ 0;	    FOR j: CARDINAL IN [0..label.length ¬ MIN[arg.length, label.maxlength]) DO	      label[j] ¬ arg[j]; ENDLOOP};	  'f => nFiles ¬ String.StringToNumber[arg !String.InvalidNumber => CONTINUE];	  ENDCASE;	ENDLOOP;      ENDLOOP;    Write["Formatting... "L];    Floppy.Format[drive, MAX[nFiles+1, 2], label, density, sides !      Floppy.Error => IF error = badDisk THEN         ERROR Abort["Can't format this disk; may be write protected"L];      Floppy.AlreadyFormatted => RESUME];    Format.Line[Write, "...done"L];    InfoDisk[gSwitches, h];    END;  InfoDisk: PROCEDURE [gSwitches: LONG STRING, h: Exec.Handle] =    BEGIN    density: Floppy.Density;    sides: Floppy.Sides;    freeSpace, largestBlock: LONG CARDINAL;    maxFileListEntries: CARDINAL;    Write: Format.StringProc = Exec.OutputProc[h];    v: Floppy.VolumeHandle;    v ¬ AccessFloppy.Open[      !AccessFloppy.Error => ERROR Abort["Can't open floppy"L]];    [freeSpace: freeSpace, largestBlock: largestBlock, density: density, sides: sides, maxFileListEntries: maxFileListEntries] ¬ Floppy.GetAttributes[v, label];    Write["Floppy """L]; Write[label]; Write["""; "L];    Write[IF sides = one THEN "single"L ELSE "double"L]; Write[" sided; "L];    Write[IF density = single THEN "single"L ELSE "double"L]; Write[" density"L];    Format.Char[Write, Ascii.CR];    Format.LongDecimal[Write, freeSpace];    Write[" free pages; largest free block = "L];    Format.LongDecimal[Write, largestBlock];    Format.Line[Write, " pages"L];    Write["maximum number of files = "L];    Format.Decimal[Write, maxFileListEntries];    Format.Line[Write, " (includes anonymous files)"L];    AccessFloppy.Close[];    END;  DoIt: Exec.ExecProc =    BEGIN    MyCommands: TYPE = MACHINE DEPENDENT {      read(0), write, list, delete, information, format, erase, scavenge,      noMatch(StringLookUp.noMatch)};    DefinedOptions: TYPE = MyCommands[read..scavenge];    commandTable: ARRAY DefinedOptions OF LONG STRING ¬ [      read: "Read"L, write: "Write"L, list: "List"L,      delete: "Delete"L, information: "Information"L, format: "Format"L,      erase: "Erase"L, scavenge: "Scavenge"L];    index: MyCommands;    Write: Format.StringProc = Exec.OutputProc[h];    command, switches: LONG STRING ¬ NIL;    WHILE outcome = normal DO      ENABLE UNWIND => {        command ¬ Exec.FreeTokenString[command];        switches ¬ Exec.FreeTokenString[switches]};      [command, switches] ¬ Exec.GetToken[h];      IF command = NIL AND switches = NIL THEN EXIT;      BEGIN ENABLE {        Abort => {Format.Line[Write, s]; GOTO abort};	AccessFloppy.Error => {	  Write["unexpected "L];	  WriteAccessFloppyError[Write, type];	  Format.Char[Write, Ascii.CR];	  GOTO abort};	AccessFloppy.InconsistentFile => {	  Format.Line[Write, "AccessFloppy.InconsistentFile"L];	  GOTO abort};	AccessFloppy.InvalidVersion => {	  Format.Line[Write, "AccessFloppy.InvalidVersion"L];	  GOTO abort};	AccessFloppy.NoRoomForClientData => {	  Format.Line[Write, "AccessFloppy.NoRoomForClientData"L];	  GOTO abort};	Floppy.Error => {	  IF error = writeInhibited THEN	    Format.Line[Write, "Floppy is write protected"L]	  ELSE {	    Write["unexpected "L];	    WriteFloppyError[Write, error];	    Format.Char[Write, Ascii.CR]};	  GOTO abort};	SetOutcome => {	  IF outcome < value THEN outcome ¬ value;	  IF outcome = abort THEN CONTINUE ELSE RESUME};	Volume.InsufficientSpace => {	  Format.Line[Write, "Insufficient (rigid) disk space to complete that operation"L];	  GOTO abort}};      index ¬ LOOPHOLE[        StringLookUp.InTable[	  key: command,	  table: DESCRIPTOR[BASE[commandTable], LENGTH[commandTable]]]];      SELECT index FROM        erase => FloppyExtras.Erase[drive, nFiles, label ! 	  FloppyExtras.ExtrasError => {Write["Cannot Erase"L]; GOTO abort}];        read => ReadFiles[switches, h];	write => WriteFiles[switches, h];	list => ListFiles[switches, h];	delete => DeleteFiles[switches, h];	information => InfoDisk[switches, h];	format => FormatDisk[switches, h];	scavenge => [] ¬ FloppyExtras.NewScavenge[drive !	  FloppyExtras.ExtrasError => {Write["Cannot Scavenge"L]; GOTO abort}];	ENDCASE => {Write["Unknown command"L]; GOTO abort};      EXITS abort => outcome ¬ abort;      END;      command ¬ Exec.FreeTokenString[command];      switches ¬ Exec.FreeTokenString[switches];      ENDLOOP;    END;	  Help: Exec.ExecProc =    BEGIN    Write: Format.StringProc = Exec.OutputProc[h];    Write["Floppy.~ <command> <args><args>:    <fileList>: list of file names; /s on a name uses next name as destination    <wildList>: names may contain * and #<command>:  Read <fileList> | <wildList> - copies files from floppy  Write <fileList> - copies files to floppy    number/t sets File.Type for following files (default tUntypedFile)    add [firstPage..lastPage] to name for writing partial files  List/ltdwv <wildList> - shows files on floppy; switches show:    l => length, t => type, d => create date, w => write date, v => everything  Delete <wildList> - deletes files from floppy  Erase - removes contents of floppy without reformatting  Info - gives information about the floppy volume  Format - formats floppy destroying previous contents, args are:    name/n gives the volume a name (quote names with special characters)    number/f sets max number of files to number (default 64)   Scavenge - repairs floppy left in an inconsistent state "L]        END;  Exec.AddCommand["Floppy.~"L, DoIt, Help];    END.    -- log-- NSG        5-Mar-85 14:47:04   added scavenge & erase -- JBD       25-Feb-87 14:13:25   released MFile.Handle if file is overwritten -- RSV        7-Oct-87 10:24:15   Don't assume drive 0.
-- Copyright (C) 1986  by Xerox Corporation. All rights reserved. -- WVMImpl.mesaDIRECTORYAMHeap,AMLoadstate,CPSwapDefs,Event,EventTypes,File,Heap,PacketExchange,PrincOps USING [StateVector],Process,Riggle,String,Supervisor,SymbolTable,System,TTY,WorldVM,WorldVMExtras,WorldVMExtras2,WorldVMOps,WVMPrivate;WVMImpl: MONITOR  IMPORTS AMLoadstate, Event, Heap, PacketExchange, Process, String, Supervisor, WVMPrivate  EXPORTS WorldVM, WorldVMExtras, WorldVMExtras2, WorldVMOps, AMHeap, Riggle = {  zone: PUBLIC UNCOUNTED ZONE ¬ Heap.Create[initial: 128, increment: 64, largeNodeThreshold: 32765, ownerChecking: FALSE, checking: FALSE];  World: TYPE = LONG POINTER TO WorldObject;  WorldObject: PUBLIC TYPE = WVMPrivate.WorldObject;  WorldType: TYPE = WorldVM.WorldType;    universe: World ¬ NIL;  localName: LONG STRING = "LocalWorld";  noName: LONG STRING = "NoWorld";  created: CONDITION;  localWorld: World ¬ NIL;  noWorld: World ¬ NIL;  symbols: SymbolTable.Handle ¬ NIL;    BadWorld: PUBLIC ERROR = CODE;    RiggleWorldOk: PUBLIC PROC[] RETURNS[BOOLEAN] = {    FOR biff: World ¬ universe, biff.next UNTIL biff = NIL DO      WITH biff SELECT FROM        outload => IF riggle THEN RETURN[bootArea.bootSpace.pointer = NIL];	ENDCASE;      REPEAT FINISHED => RETURN[TRUE];      ENDLOOP };        RemoteWorld: PUBLIC PROC[where, switches: LONG STRING, tty: TTY.Handle ¬ TTY.nullHandle] RETURNS[world: World] = {    RETURN[GetWorld[where, switches, tty, remote]]};  OutloadWorld: PUBLIC PROC[where, switches: LONG STRING, tty: TTY.Handle ¬ TTY.nullHandle] RETURNS[world: World] = {    RETURN[GetWorld[where, switches, tty, outload]]};  LocalWorld: PUBLIC PROC[] RETURNS[world: World] = {    IF (world ¬ EntryFindLocal[]) = NIL THEN world ¬ GetWorld[localName, NIL, TTY.nullHandle, local]};      EntryFindLocal: --ENTRY-- PROC RETURNS[World] = INLINE {RETURN[localWorld]};    ClientWorld: PUBLIC PROC[where, switches: LONG STRING, clientProcs: WorldVMExtras.ClientProcs, tty: TTY.Handle ¬ TTY.nullHandle]     RETURNS[world: World] = {    EndCreation: ENTRY PROC = INLINE { BROADCAST created };    world ¬ EntryFindWorld[client, where, System.nullNetworkAddress, File.nullFile, clientProcs];    world.tty ¬ tty;    IF world.state = creating THEN { -- Do some work      ENABLE UNWIND => {world.state ¬ bad; EndCreation[]};      WVMPrivate.GetMaplog[world ! ABORTED => GOTO Aborted];      EndRun[world];      world.state ¬ created;      EndCreation[];      EXITS Aborted => {InvalidateWorld[world]; ERROR ABORTED}}};    GetWorld: PROC[where, switches: LONG STRING, tty: TTY.Handle, type: WorldType] RETURNS[world: World] = {    EndCreation: ENTRY PROC = INLINE {      BROADCAST created;      SELECT type FROM local => localWorld ¬ world; ENDCASE => NULL};    host: System.NetworkAddress;    file: File.File;    leaderPages: CARDINAL;    riggle, rs232, ignoreMaplog: BOOLEAN;    waitTime: LONG CARDINAL;    SELECT type FROM      local => NULL;      outload => [file, leaderPages, riggle, ignoreMaplog] ¬ WVMPrivate.LocateOutload[where, switches, tty];      remote => [host, waitTime, rs232] ¬ WVMPrivate.LocateRemote[where, switches, tty];      ENDCASE;     world ¬ EntryFindWorld[type, where, host, file, NIL];    world.tty ¬ tty;    IF world.state = creating THEN { -- Do some work      ENABLE UNWIND => {world.state ¬ bad; EndCreation[]};      WITH w: world SELECT FROM        outload => { 	  w.leaderPages ¬ leaderPages; 	  w.riggle ¬ riggle; 	  w.maplog.ignoreMaplog ¬ ignoreMaplog };	remote => { 	  w.waitTime ¬ waitTime; w.rs232 ¬ rs232 };	ENDCASE;      WVMPrivate.GetMaplog[world ! ABORTED => GOTO Aborted];      EndRun[world];      world.state ¬ created;      EndCreation[];      EXITS Aborted => {InvalidateWorld[world]; ERROR ABORTED}}};        EntryFindWorld: ENTRY PROC[type: WorldType, name: LONG STRING, host: System.NetworkAddress, file: File.File, clientProcs: WorldVMExtras.ClientProcs] RETURNS[new: World ¬ NIL] = {    ENABLE UNWIND => NULL;    FOR w: World ¬ universe, w.next UNTIL w = NIL DO      IF w.type = type AND  	(WITH world: w SELECT FROM	  outload => world.file = file,	  remote => world.host = host,	  client => world.clientProcs = clientProcs,	  ENDCASE => TRUE)      THEN { -- found it	WHILE w.state = creating DO WAIT created ENDLOOP;	IF w.state = bad THEN w.state ¬ creating;	RETURN[w] };      IF w.type = none THEN new ¬ w; -- free object available      ENDLOOP;    IF new = NIL THEN {      new ¬ zone.NEW[WorldObject ¬ [foo: none[]]];       new.sym ¬ symbols;      new.next ¬ universe;      universe ¬ new };    new.state ¬ creating;    SELECT type FROM      local => {        new.name ¬ localName; 	new.foo ¬ local[NIL];	localWorld ¬ new};      outload => {	new.name ¬ String.CopyToNewString[name, zone];	new.foo ¬ outload[file: file]};      remote => { 	new.name ¬ String.CopyToNewString[name, zone]; 	new.foo ¬ remote[host: host, peh: PacketExchange.nullExchangeHandle]};      client => {        new.name ¬ String.CopyToNewString[name, zone];	new.foo ¬ client[clientProcs: clientProcs]};      ENDCASE => ERROR };    BeforeHeraldBoot: PUBLIC PROC[world: World] = {    -- WVMPrivate.StopOutload[NARROW[world, WVMPrivate.OutloadWorld]];    WVMPrivate.FlushMaplog[world]; };        AfterHeraldBoot: PUBLIC PROC[world: World] = {    IF ~world.running THEN {      -- Someone did a herald boot of an existing outload world      -- and we have returned.      world.loadstateValid ¬ FALSE;      world.running ¬ TRUE;      world.incarnation ¬ world.incarnation+1;      WVMPrivate.GetMaplog[world ! UNWIND => EndRun[world]];      EndRun[world] }};  NoWorld: PUBLIC ENTRY PROC RETURNS[world: World] = {    ENABLE UNWIND => NULL;    IF noWorld = NIL THEN noWorld ¬ zone.NEW[WorldObject ¬ [name: noName, running: FALSE, foo: none[]]];    RETURN[noWorld]};  InvalidateWorld: PUBLIC ENTRY PROC[world: World] = {    ENABLE UNWIND => NULL;    IF world = NIL --OR world = localWorld-- THEN RETURN;    IF world.name # NIL AND world.name # noName AND world.name # localName    THEN {String.FreeString[zone, world.name]; world.name ¬ NIL};    WITH world SELECT FROM      local => {        WVMPrivate.StopLocal[NARROW[world, WVMPrivate.LocalWorld]];	localWorld ¬ NIL };      outload => {	WVMPrivate.StopOutload[NARROW[world, WVMPrivate.OutloadWorld]] };      remote => {        WVMPrivate.StopTeledebugging[NARROW[world, WVMPrivate.RemoteWorld]] };      client => {        WVMPrivate.StopClient[NARROW[world, WVMPrivate.ClientWorld]] };      ENDCASE;    world.esv.bootSession ¬ 0;    world.state ¬ bad;     world.foo ¬ none[]};  CurrentIncarnation: PUBLIC ENTRY PROC[world: World] RETURNS[WorldVM.Incarnation] = {    ENABLE UNWIND => NULL;    IF world = NIL THEN RETURN WITH ERROR BadWorld[];    RETURN[world.incarnation]};  WorldName: PUBLIC ENTRY PROC[world: World] RETURNS[name: LONG STRING ] = {    ENABLE UNWIND => NULL;    IF world = NIL THEN RETURN WITH ERROR BadWorld[];    RETURN[ world.name ]};    loadStateRead: CONDITION ¬ [timeout: Process.SecondsToTicks[3]];  GetLoadstate: PUBLIC ENTRY PROC[world: World] RETURNS[ AMLoadstate.Handle ] = {    ENABLE UNWIND => NULL;    IF world = NIL THEN RETURN WITH ERROR BadWorld[];    IF ~world.loadstateValid THEN {      WAIT loadStateRead;      IF ~world.loadstateValid THEN ERROR AMLoadstate.Error[other]};    RETURN[ world.loadstate ]};  ValidLoadstate: PUBLIC ENTRY PROC[world: World] = {    ENABLE UNWIND => NULL;    world.loadstateValid ¬ TRUE;    BROADCAST loadStateRead};  unlocked: CONDITION;    Lock: PUBLIC ENTRY PROC[world: World] = {    ENABLE UNWIND => NULL;    IF world = NIL THEN RETURN WITH ERROR BadWorld[];    WHILE world.running DO WAIT unlocked ENDLOOP;    world.lock ¬ world.lock+1};    Unlock: PUBLIC ENTRY PROC[world: World] = {    ENABLE UNWIND => NULL;    IF world = NIL THEN RETURN WITH ERROR BadWorld[];    world.lock ¬ world.lock-1; BROADCAST unlocked};    StartRun: PUBLIC ENTRY PROC[world: World] = {    waited: BOOLEAN ¬ FALSE;    IF world = NIL THEN RETURN WITH ERROR BadWorld[];    DO       WHILE world.lock > 0 OR world.running DO         waited ¬ TRUE; WAIT unlocked;	ENDLOOP;      IF NOT waited THEN EXIT; -- else we may need to flush again --      waited ¬ FALSE;      ENDLOOP;    world.loadstateValid ¬ FALSE;    world.running ¬ TRUE; -- gives us exclusive access to the world --    world.incarnation ¬ world.incarnation+1 };      EndRun: ENTRY PROC[world: World] = {    IF world = NIL THEN RETURN WITH ERROR BadWorld[];    world.running ¬ FALSE;     BROADCAST unlocked };      Notify: PROC[world: World, event: Supervisor.Event] = {    WITH world SELECT FROM      local =>	Supervisor.NotifyDirectSubsystems[	  event: event, 	  which: clients, 	  subsystem: Event.spare2];      outload =>        Supervisor.NotifyDirectSubsystems[	  event: event, 	  which: clients, 	  subsystem: Event.swapping];      remote =>        Supervisor.NotifyDirectSubsystems[	  event: EventTypes.spare3, 	  which: clients, 	  subsystem: Event.swapping, 	  eventData: @event];      ENDCASE };        LocalGo: PUBLIC PROC[world: World] = {    IF world.type # local THEN ERROR BadWorld[];    Notify[world, EventTypes.resumeDebuggee];    WVMPrivate.FlushMaplog[world]; };      LocalCome: PUBLIC PROC[world: World] = {    IF world.type # local THEN ERROR BadWorld[];    WVMPrivate.GetMaplog[world];    Notify[world, EventTypes.resumeSession]; };      Go: PUBLIC PROC[world: World] = {    Notify[world, EventTypes.resumeDebuggee]; -- should be in WVMOutLd but must occur before FlushMaplog    StartRun[world];    WVMPrivate.FlushMaplog[world];    BEGIN ENABLE UNWIND => EndRun[world];      WITH world SELECT FROM	local => ERROR BadWorld[];	outload => WVMPrivate.GoOutload[NARROW[world, WVMPrivate.OutloadWorld] ! ABORTED => GOTO Aborted]; 	remote => WVMPrivate.GoRemote[NARROW[world, WVMPrivate.RemoteWorld] ! ABORTED => GOTO Aborted];	none => ERROR BadWorld[];	ENDCASE => ERROR;      WVMPrivate.GetMaplog[world ! ABORTED => GOTO Aborted];      EXITS Aborted => {         -- pretend we came back ok	Notify[world, EventTypes.abortSession -- EventTypes.resumeSession? --];	InvalidateWorld[world]; 	ERROR ABORTED };      END;    EndRun[world];    Notify[world, EventTypes.resumeSession] -- should be in WVMOutLd --};    LoadstateAddress: PUBLIC PROC[world: World] RETURNS[WorldVMOps.Address] = {    RETURN [world.esv.loadState]};      GetType: PUBLIC PROC[world: World] RETURNS[WorldVM.WorldType] = {    RETURN[LOOPHOLE[world.type]]};      GetSym: PUBLIC PROC[world: World] RETURNS[SymbolTable.Handle] = {    RETURN[world.sym]};    GetMDS: PUBLIC PROC[world: World] RETURNS[CARDINAL] = {    RETURN[world.esv.mds]};      GetESV: PUBLIC PROC[world: World] RETURNS[LONG POINTER TO CPSwapDefs.ExternalStateVector] = {    RETURN[@world.esv]};    -- returns client address, may be NIL    GetSV: PUBLIC PROC[world: World] RETURNS[LONG POINTER TO dst PrincOps.StateVector] = {    RETURN[       WITH world.esv.swapData SELECT FROM         breakpoint => sv, 	return => sv, 	ENDCASE => NIL]};      SetSymbols: PUBLIC PROC[sym: SymbolTable.Handle] = {    symbols ¬ sym};      SetBreakNumber: PUBLIC PROC[world: World, number: CARDINAL] = {     world.numberOfBreaks ¬ number };  GetBreakNumber: PUBLIC PROC[world: World] RETURNS[CARDINAL] = {     RETURN[world.numberOfBreaks] };  EnumerateWorlds: PUBLIC PROC[p: WorldVMExtras.WorldProc] RETURNS[w: World] = {    FOR w ¬ universe, w.next UNTIL w = NIL DO      IF p[w] THEN RETURN;      ENDLOOP };  }..
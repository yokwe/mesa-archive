-- Copyright (C) 1986  by Xerox Corporation. All rights reserved. -- file ITUtilsHot.mesa - last edited byDIRECTORY  AMUseful,  ComData USING [typeCARDINAL, typeStringBody],  Copier USING [AugmentContext, SearchFileCtx, CopyingInline],  Environment USING [bitsPerWord],  Inline USING [LongCOPY],  LiteralOps USING [DescriptorValue, StringValue],  Literals USING [LitDescriptor, LitRecord, STNull],  Mopcodes USING [zRLFS],  IO, IP, IQ, IS, IT,   PrincOps USING [FieldDescriptor],  String USING [AppendSubString, CopyToNewString, SubString, SubStringDescriptor, WordsForString, AppendString],  SymbolOps USING [BitsForType, EnterString, SearchContext, SubStringForHash, UnderType, ToCard],  Symbols USING [    codeANY, codeCHAR, codeINT, CSEIndex, CTXIndex, CTXNull,      HTIndex, HTNull, ISEIndex, ISENull, MDIndex, MDNull, RecordSEIndex,     SEIndex, TypeClass, typeTYPE],  SymbolTable USING [Missing, Handle],  WorldVMOps;ITUtilsHot: PROGRAM  IMPORTS AMUseful, com: ComData, Copier, Inline, IO, IP, IQ, IS, LiteralOps, String, SymbolOps, SymbolTable, WorldVMOps  EXPORTS IP  SHARES Copier = {  OPEN IT;    StrangeRecord: ERROR = CODE;  WrongTypeClass: ERROR [f: Foo] = CODE;  Name: PUBLIC PROC [h: Handle, name: LONG STRING, gf: GFHandle ¬ NIL] = {    AMUseful.ModuleName[h.world, IF gf = NIL THEN IS.GetGlobal[h] ELSE gf, name      ! AMUseful.NoModule => { String.AppendString[name, "(bad module)"L]; CONTINUE }]};    GFrame: PUBLIC PROC [h: Handle, name: LONG STRING ¬ NIL] RETURNS [f: GFHandle] = {    IF name = NIL OR name.length = 0 THEN RETURN[IS.GetGlobal[h]];    RETURN[AMUseful.Frame[h.world, name      ! AMUseful.MultipleFrames => ERROR IP.MultipleFrames[list]]]};  FrameForHti: PUBLIC PROC [h: Handle, hti: HTIndex ¬ Symbols.HTNull] RETURNS [GFHandle] = {    name: STRING ¬ [MaxModuleString];    IF hti = Symbols.HTNull THEN RETURN[GFrame[h, NIL]];    HtiToString[h, hti, name];    RETURN[GFrame[h, name]]};      HtiForFrame: PUBLIC PROC [h: Handle, gf: GFHandle] RETURNS [HTIndex] = {    name: STRING ¬ [MaxModuleString];    Name[h, name, gf];    RETURN[StringToHti[h, name]]};  CopyLiteral: PUBLIC PROCEDURE [h: Handle, info: Literals.LitRecord]    RETURNS [p: LONG POINTER, length: CARDINAL] = {    WITH info SELECT FROM      word => {	lit: Literals.LitDescriptor ¬ LiteralOps.DescriptorValue[h.sym, index];	length ¬ lit.length;	p ¬ IO.Node[h, length];	Inline.LongCOPY[from: @h.ltb[lit.offset], to: p, nwords: length] };      string => {	s: LONG STRING ¬ 	  String.CopyToNewString[	    IF index = Literals.STNull THEN "(string literal)"L 	    ELSE LiteralOps.StringValue[h.sym, index],	    IO.zone];	length ¬ String.WordsForString[s.length];	p ¬ s };      ENDCASE => ERROR IO.LiteralProblem };  StringToHti: PUBLIC PROC [h: Handle, s: LONG STRING] RETURNS [HTIndex] = {    desc: String.SubStringDescriptor ¬ [base: s, offset: 0, length: s.length];    RETURN[SymbolOps.EnterString[h.sym, @desc]] };  HtiToString: PUBLIC PROC [h: Handle, hti: HTIndex, s: LONG STRING] = {    desc: String.SubStringDescriptor;    ss: String.SubString ¬ @desc;    SymbolOps.SubStringForHash[h.sym,ss,hti];    String.AppendSubString[s,ss] };  SearchCtxList: PUBLIC PROC [h: Handle, hti: HTIndex, ctx: CTXIndex] RETURNS [sei: ISEIndex] = {    IF ctx = Symbols.CTXNull THEN RETURN [Symbols.ISENull];    IF (sei ¬ SymbolOps.SearchContext[h.sym, hti, ctx]) # Symbols.ISENull THEN RETURN;    WITH h.ctxb[ctx] SELECT FROM      included =>         IF ~complete THEN {	  found: BOOLEAN ¬ TRUE;	  mdi: MDIndex ¬ Symbols.MDNull;	  gf: GFHandle ¬ IS.GFFromIContext[h];	  mdi ¬ IQ.GFrameMdi[h, gf ! IQ.InvalidFrame, SymbolTable.Missing => CONTINUE];	  IF mdi # Symbols.MDNull THEN {	    Copier.AugmentContext[h.sym, LOOPHOLE[ctx], mdi ! Copier.CopyingInline => CONTINUE];	    IF (sei ¬ SymbolOps.SearchContext[h.sym, hti, ctx]) # Symbols.ISENull THEN RETURN };	  [found, sei] ¬ Copier.SearchFileCtx[h.sym, hti, LOOPHOLE[ctx] ! Copier.CopyingInline => {found ¬ FALSE; CONTINUE}];	  IF ~found THEN sei ¬ Symbols.ISENull};      imported => sei ¬ SearchCtxList[h, hti,includeLink];      simple => NULL;      ENDCASE => sei ¬ Symbols.ISENull};  CheckClass: PUBLIC PROC [h: Handle, tc: Symbols.TypeClass, f: Foo] RETURNS [UNSPECIFIED] = {    csei: CSEIndex ¬ TypeForSe[h, f.tsei];    IF h.seb[csei].typeTag # tc THEN ERROR WrongTypeClass[f];    RETURN[csei] };  FindField: PUBLIC PROC [h: Handle, f: Foo, pad: CARDINAL, isei: ISEIndex] RETURNS [field: Foo] = {    -- fieldOfRecordParameter: BOOLEAN = f.addr.useStack AND ~f.xfer;    -- IF fieldOfRecordParameter THEN f.addr.useStack ¬ FALSE;    field ¬ Find[h, f, pad, isei];    -- IF fieldOfRecordParameter THEN f.addr.useStack ¬ TRUE;    IF field = NIL THEN RETURN;    field.there ¬ f.there;     field.xfer ¬ f.xfer;     field.indent ¬ f.indent;    field.displayFieldsOfRecordsAs ¬ f.displayFieldsOfRecordsAs;    IF ~f.there THEN FixupHeap[h, field] };  Find: PROC [h: Handle, f: Foo, pad: CARDINAL, isei: ISEIndex] RETURNS [field: Foo] = {    ba: BitAddress ¬ f.addr;    notNested: BOOLEAN = ba.offset = 0;    first: BOOLEAN = SymbolOps.ToCard[h.seb[isei].idValue] = 0;    sizeInc: CARDINAL;    IF first AND notNested THEN {sizeInc ¬ pad; ba.offset ¬ 0}    ELSE {sizeInc ¬ 0; ba.offset ¬ pad};    field ¬ IP.MakeFoo[h, isei, ba, sizeInc] };  FixupHeap: PROC [h: Handle, f: Foo] = {    words: CARDINAL ¬ f.words + (IF f.bits = 0 THEN 0 ELSE 1);    base: LONG POINTER = f.addr.base;    f.addr.base ¬ IO.Node[h, words];    Inline.LongCOPY[from: base, nwords: words, to: f.addr.base]};  Pad: PUBLIC PROC [h: Handle, f: Foo, rsei: RecordSEIndex] RETURNS [pad: CARDINAL] = {    size: CARDINAL ¬ CARDINAL[SymbolOps.BitsForType[h.sym, rsei]];    pad ¬ 0;    -- IF h.seb[rsei].machineDep THEN RETURN[0];    IF size > 0 AND size < 16 THEN {      available: CARDINAL ¬ IF f.bits # 0 THEN f.bits ELSE 16;      IF available < size THEN ERROR StrangeRecord;      pad ¬ f.addr.offset + available - size }};  VariantType: PUBLIC PROC [h: Handle, usei: UnionSEIndex] RETURNS [v: VType] = {    v ¬ IF h.seb[usei].controlled THEN controlled        ELSE IF h.seb[usei].overlaid THEN overlaid ELSE computed };  TagIsei: PUBLIC PROC [h: Handle, f: Foo, pad: CARDINAL, usei: UnionSEIndex] RETURNS [isei: ISEIndex] = {    tag: Foo;    val: CARDINAL;    ictx: CTXIndex;    tag ¬ FindField[h, f, pad, h.seb[usei].tagSei];    ictx ¬ h.seb[usei].caseCtx;    IF tag.bits + tag.addr.offset > Environment.bitsPerWord THEN ERROR StrangeRecord;    GetValue[h, tag];    val ¬ tag.addr.base­;    isei ¬ IP.SearchCtxForVal[h, val, ictx, none] };  TypeForSe: PUBLIC PROC [h: Handle, sei: SEIndex] RETURNS [type: CSEIndex] = {    symtab: SymbolTable.Handle = IO.symboltable;    DO      WITH symtab.seb[sei] SELECT FROM	id => IF idType # Symbols.typeTYPE THEN sei ¬ idType ELSE EXIT;	ENDCASE => EXIT;      ENDLOOP;    RETURN[SymbolOps.UnderType[IO.symboltable, sei]]};  RFS: PROC [LONG POINTER, PrincOps.FieldDescriptor] RETURNS [UNSPECIFIED] =    MACHINE CODE { Mopcodes.zRLFS };  ReadField: PROCEDURE [f: Foo] = {    fd: PrincOps.FieldDescriptor ¬ [offset: 0, posn: f.addr.offset, size: f.bits];    f.addr.base­ ¬ RFS[f.addr.base, fd];    f.bits ¬ 0; f.words ¬ 1 };  GetValue: PUBLIC PROCEDURE [h: Handle, f: Foo] = {    IF WorldVMOps.NilAddress[h.world, f.addr.base] THEN RETURN;    IF f.there THEN {      cnt: CARDINAL ¬ f.words + (IF f.bits = 0 THEN 0 ELSE 1);      p: LONG POINTER ¬ IO.Node[h, cnt];      WorldVMOps.CopyRead[world: h.world, from: f.addr.base, to: p, nwords: cnt];      f.addr.base ¬ p;      f.there ¬ FALSE;      f.constant ¬ FALSE};    IF f.bits # 0 THEN ReadField[f]};  DIFormat: PUBLIC PROC [h: Handle, sei: SEIndex] RETURNS [vf: ValFormat ¬ [none[]], intSub: BOOLEAN ¬ FALSE] = {    inSubrange: BOOLEAN ¬ FALSE;    csei: CSEIndex ¬ TypeForSe[h, sei];    DO      WITH h.seb[csei] SELECT FROM	basic => {	  SELECT code FROM	    Symbols.codeANY => 	      -- someday add unspec to ValFormat	      -- for now UNSPECIFIED is CARDINAL	      vf ¬ [card[]];	    Symbols.codeINT => { intSub ¬ inSubrange; vf ¬ [int[]] };	    Symbols.codeCHAR => vf ¬ [char[]];	    ENDCASE;	  RETURN };	subrange => {	  IF csei = com.typeCARDINAL THEN {vf ¬ [card[]]; RETURN};	  csei ¬ SymbolOps.UnderType[h.sym, rangeType];	  inSubrange ¬ TRUE };	enumerated => {	  intSub ¬ FALSE;	  vf ¬ [enum[LOOPHOLE[csei]]];	  RETURN };	ref => {	  vf ¬ IF SymbolOps.UnderType[h.sym, refType] = com.typeStringBody THEN [string[]] ELSE [pointer[]];	  RETURN };	relative => { 	  vf ¬ [relative[]]; 	  RETURN };	ENDCASE => RETURN;      ENDLOOP };  }.
-- File: ITInitialPack.mesa - last edit:-- Litman              21-Apr-87 19:11:03-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.DIRECTORY  CPSwapDefs USING [SignalError, StorageFaultType, SwapReason],  IO USING [Char, Decimal, Display, EOL, FreeString, Line, Numeric, Text],  IP USING [CodeBase, Error, EvalStackEmpty, GF, PC, Signal, XferCtx],  IQ USING [BPWriteError, Conditionalize, DisplayF, FindBB, InvalidFrame, PreDeclared],  IS USING [FaultAddr, Frame, LongNum, Num, ReadPsb, UserLongText, WriteError, XferFrame, XferName],  IT USING [BBHandle, BytePC, CoreSwapMessages, Foo, GFHandle, Handle, LFHandle, Process, SignalDesc],  Mopcodes USING [zBRK],  Symbols USING [ISEIndex, ISENull, RecordSENull],  SymbolTable USING [Missing, NullHandle],  WorldVMOps USING [AddressFault, BYTE, LFlong, Process, ProcessLong, Read, ReadCodeByte];ITInitialPack: PROGRAM  IMPORTS IO, IP, IQ, IS, SymbolTable, WorldVMOps  EXPORTS IO, IS = {    NewSession: PUBLIC ERROR = CODE;  Redisplay: PUBLIC PROCEDURE[h: IT.Handle] = {    IO.EOL[h];    WITH sd: h.swapData SELECT FROM      -- Generated by debugger, handled by debuggee:      callDebuggee => IO.Line[h, "*** Invalid: Call Debugee ***"L];      kill => IO.Line[h, "*** Invalid: Kill ***"L];            proceed => IO.Line[h, "*** Invalid: Proceed ***"L];      quit => IO.Line[h, "*** Invalid: Quit ***"L];      resizeBreakBlockTable => IO.Line[h, "*** Invalid: Resize Break Block Table ***"L];      resizePatchTable => IO.Line[h, "*** Invalid: Resize Patch Table ***"L];      showScreen => IO.Line[h, "*** Invalid: Show Screen ***"L];      start => IO.Line[h, "*** Invalid: Start ***"L];      debuggerSpareA => IO.Line[h, "*** Invalid: Debugger Spare A ***"L];      debuggerSpareB => IO.Line[h, "*** Invalid: Debugger Spare B ***"L];      -- Generated by debuggee, handled by debugger:      breakpoint => [] ¬ ShowBreak[h, WorldVMOps.LFlong[h.world, sd.lFrame]];      bug => SystemError[h: h, bug: sd.bugType];      callDebugger => IS.UserLongText[h, sd.message];      cleanMapLog => IO.Line[h, "*** Processing VM Map ***"L];      interrupt => CoreSwapMsg[h, interrupt];      noOp => IO.Line[h, "*** No Op ***"L];      return => IO.Line[h, "*** Return ***"L];      returnAborted => IO.Line[h, "*** Return [ABORTED] ***"L];      storageFault => AddressFault[h, sd.type, WorldVMOps.ProcessLong[sd.faultedProcess]];      uncaughtSignal => { ShowSignalError[h, sd.signalError]; PrintUCS[h] };      debuggeeSpareA => IO.Line[h, "*** Debuggee Spare A ***"L];      debuggeeSpareB => IO.Line[h, "*** Debuggee Spare B ***"L];      ENDCASE => {        IO.Line[h, "*** Unknown Swap Reason ["L];        IS.Num[h, sd.reason, [card[]]];	IO.Line[h, "] ***"L]}};	  AddressFault: PUBLIC PROCEDURE [h: IT.Handle, type: CPSwapDefs.StorageFaultType, psb: IT.Process] = {    SELECT type FROM      addressFault => IO.Text["*** Address fault"L, h];      writeProtectFault => IO.Text["*** Write Protect fault"L, h];      ENDCASE => IO.Text["*** Unknown (address) fault"L, h];    IO.Text[", PSB: "L, h]; IS.LongNum[h, psb, [card[]]];    IO.Text[", at "L, h]; IS.LongNum[h, IS.FaultAddr[h, psb], [pointer[]]];    IO.Text[", in "L, h];     BEGIN    ENABLE IQ.InvalidFrame => {      IO.Char[h, ' ]; IS.LongNum[h, f, [pointer[]]];       IS.WriteError[h, nGframe, FALSE]; CONTINUE};    IQ.DisplayF[h, IS.Frame[h, IS.ReadPsb[h, psb]]];    END;    IO.Line[h, " ***"L]};      CheckBreakpoint: PROC [h: IT.Handle, gf: IT.GFHandle, pc: IT.BytePC] RETURNS [ok: BOOLEAN] = {    RETURN[WorldVMOps.ReadCodeByte[h.world, IP.CodeBase[h, gf], pc] = Mopcodes.zBRK]};    ShowBreak: PUBLIC PROCEDURE [h: IT.Handle, lf: IT.LFHandle] RETURNS [bp: IT.BBHandle] = {    gf: IT.GFHandle ¬ IP.GF[h, lf];    pc: IT.BytePC ¬ IP.PC[h, lf];    IF ~CheckBreakpoint[h, gf, pc] THEN { IO.Text["Breakpoint"L, h]; RETURN[NIL] };    IF (bp ¬ IQ.FindBB[h, gf, pc]) = NIL THEN IQ.BPWriteError[h, notFound] ELSE WriteBreakHerald[h, lf, bp] };    WriteBreakHerald: PROCEDURE [h: IT.Handle, f: IT.LFHandle, b: IT.BBHandle] = {    OPEN IO;    BreakNum: PROC = { Text[" #"L, h]; Decimal[h, b.num] };    IO.EOL[h];    IF b.bt.ex = octal THEN {      Text["Octal-break"L, h]; BreakNum[]; Text[" in frame: "L, h];      IS.LongNum[h, IP.GF[h, f], [pointer[]]]; Text[", byte-pc: "L, h];       IS.Num[h, b.pc, [card[]]];      EOL[h] }    ELSE {      Text[IF b.bt.bt = break THEN "Break"L ELSE "Trace"L, h];      BreakNum[];      Text[SELECT b.bt.ex FROM	entry => " at entry to "L,	exit => " at exit from "L,	ENDCASE => " in "L, h];      IQ.DisplayF[h, f];      IF b.condition # NIL AND IO.Numeric[h, b.condition] THEN {	s: LONG STRING ¬ b.condition;	IQ.Conditionalize[h, b, s];	IO.FreeString[h, s]}};    SELECT TRUE FROM      IP.EvalStackEmpty[h] => NULL;      b.bt.ex = entry AND b.symbolsAvailable => NULL;      b.bt.ex = exit => NULL;      ENDCASE => {EOL[h]; Line[h, " Eval-Stack not empty!"L] }};    ShowSignalError: PUBLIC PROCEDURE [h: IT.Handle, signalError: CPSwapDefs.SignalError] = {    SELECT signalError FROM      signal => IO.Text["*** uncaught SIGNAL "L, h];      error => IO.Text["*** uncaught ERROR "L, h];      ENDCASE => IO.Text["*** uncaught SIGNAL/ERROR (?) "L, h] };  Msg: PROCEDURE [h: IT.Handle, lf: IT.LFHandle] = {    IO.Text[" msg = "L, h];     IS.Num[h, WorldVMOps.Read[h.world, lf ! WorldVMOps.AddressFault => GOTO invalid], [none[]]];    EXITS invalid => {      IS.LongNum[h, lf, [pointer[]]];       IP.Error[h, invalidAddress] }};  PrintUCS: PUBLIC PROCEDURE[h: IT.Handle] = {    WITH sd: h.swapData SELECT FROM      uncaughtSignal => {	signal: IT.SignalDesc = LOOPHOLE[sd.signal];	args: IT.LFHandle = WorldVMOps.LFlong[h.world, sd.signalArgs];	isei: Symbols.ISEIndex ¬ Symbols.ISENull;        IF IQ.PreDeclared[h: h, sig: signal, print: TRUE].found THEN RETURN;	isei ¬ IP.Signal[h, signal];	IS.XferName[h, LOOPHOLE[signal], isei];        PrintArgs[h, isei, args ! SymbolTable.Missing => { Msg[h, args]; CONTINUE }];	IS.XferFrame[h, LOOPHOLE[signal]] };      ENDCASE };  PrintArgs: PUBLIC PROC [h: IT.Handle, signalSEI: Symbols.ISEIndex, lf: IT.LFHandle] = {    f: IT.Foo ¬ IP.XferCtx[h, signalSEI, lf, in];    IF f = NIL THEN ERROR SymbolTable.Missing[SymbolTable.NullHandle];    IF f.tsei = Symbols.RecordSENull THEN RETURN;    f.xfer ¬ TRUE;    f.addr.useStack ¬ TRUE;    f.displayFieldsOfRecordsAs ¬ fields;    IO.Display[h, f, TRUE       ! IQ.InvalidFrame => {	IO.Char[h, ' ]; 	IS.LongNum[h, f, [pointer[]]]; 	IS.WriteError[h, nGframe, FALSE]; 	CONTINUE}]};  CoreSwapMsg: PUBLIC PROC [h: IT.Handle, msg: IT.CoreSwapMessages] = {    IF msg = none THEN RETURN;    IO.Text[SELECT msg FROM      evalstack => "Eval-Stack not empty!"L,      interrupt => "*** interrupt ***"L,      maplog => "*** Processing VM Map ***"L,      ENDCASE => ERROR, h] };  SystemError: PUBLIC PROCEDURE[h: IT.Handle, bug: CARDINAL] = {    IO.Text["System Error ["L, h];     IS.Num[h, bug, [card[]]];     IO.Text["] in "L, h];    IQ.DisplayF[h, WorldVMOps.LFlong[h.world, h.swapData.lFrame]];     IO.EOL[h]};  }.
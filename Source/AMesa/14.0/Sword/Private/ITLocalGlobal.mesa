-- File: ITLocalGlobal.mesa - last edit:-- Litman              22-May-87 12:29:05-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.DIRECTORY  IJ USING [Names, NamesBody],  Inline USING [LongCOPY],  IO USING [AllocFob, zone],  IP USING [CBti, Complete, Entry, Exit, GF, InOut, PC, SignalSeiFromCatchFrameHandle, StateCtx, TypeForSe, XferCtx],  IQ USING [GetMainBody],  IT USING [BytePC, CBTIndex, Foo, GFHandle, Handle, HTIndex, ISEIndex, LFHandle, NILGF, nullPC],  SymbolOps USING [FirstCtxSe, Handle, NextSe],  Symbols USING [CBTIndex, CBTNull, ContextLevel, CTXIndex, CTXNull, HTIndex, IncludedCTXIndex, ISEIndex, ISENull, lG, RecordSENull, SEIndex, SENull, typeTYPE];ITLocalGlobal: PROGRAM IMPORTS Inline, IO, IP, IQ, SymbolOps  EXPORTS IJ = {  OPEN IT;  DisplayLocalsF: PUBLIC PROC[h: IT.Handle, lf: LONG POINTER, names: Names] RETURNS[new: Names] = {    gf: GFHandle = IP.GF[h, lf];    pc: BytePC = IP.PC[h, lf];    cbti: CBTIndex = IP.CBti[h, pc, gf];    f: Foo;    new ¬ names;    IF cbti = Symbols.CBTNull THEN RETURN;    new ¬ DisplayParametersF[h, lf, new];    new ¬ DisplayResultsF[h, lf, new];    f ¬ SetupLocalFoo[h, lf];    «IF IP.CbtSon[h, cbti] THEN {      list: CtxLink ¬ IP.ContextList[h, IP.PC[h, lf], gf, print];      IF list = NIL THEN RETURN;      new ¬ DumpContextList[h, f, IQ.GFrameMdi[h, gf], list, new ! UNWIND => IP.FreeContextList[h, list]];      IP.FreeContextList[h, list]}    ELSE» {      ictx: Symbols.IncludedCTXIndex;      level: Symbols.ContextLevel ¬ Symbols.lG;      ictx ¬ LOOPHOLE[h.bb[cbti].localCtx];      IF ictx # Symbols.CTXNull THEN level ¬ h.ctxb[ictx].level;      IF level > Symbols.lG THEN new ¬ DumpOne[h, ictx, new]}};      DisplayLocalsGF: PUBLIC PROC[h: IT.Handle, old: Names] RETURNS[names: Names] = {    gf: GFHandle = WITH h.iContext SELECT FROM      local => IP.GF[h, lf],      global => gf,      ENDCASE => NILGF;    lf: LFHandle ¬ IQ.GetMainBody[h, gf];    cbti: Symbols.CBTIndex;    ictx: Symbols.IncludedCTXIndex;    names ¬ old;    cbti ¬ GFCbti[h, gf];    names ¬ FrameFoo[h, gf, in, FALSE, cbti, names];    names ¬ FrameFoo[h, gf, out, FALSE, cbti, names];    IF cbti # Symbols.CBTNull THEN {      ictx ¬ LOOPHOLE[h.bb[cbti].localCtx];      names ¬ DumpOne[h, ictx, names]};    IF lf # NIL THEN names ¬ DisplayLocalsF[h, lf, names]};      DisplayParametersF: PROC [h: Handle, f: LFHandle, names: Names] RETURNS[new: Names] = {    new ¬ FrameFoo[h, f, in, IP.Entry[h, f, nullPC], FCbti[h, f], names]};      DisplayResultsF: PROC [h: Handle, f: LFHandle, names: Names] RETURNS[new: Names] = {    new ¬ FrameFoo[h, f, out, IP.Exit[h, f, nullPC], FCbti[h, f], names]};    GFCbti: PROC [h: Handle, gf: GFHandle] RETURNS [Symbols.CBTIndex] = {    RETURN[IP.CBti[h, nullPC, gf]]};      FCbti: PROC [h: Handle, f: LFHandle] RETURNS [Symbols.CBTIndex] = {    RETURN[IP.CBti[h, IP.PC[h, f], IP.GF[h, f]]]};      FrameFoo: PROC [h: Handle, p: LONG POINTER, io: IP.InOut, inState: BOOLEAN, cbti: Symbols.CBTIndex, names: Names] RETURNS[new: Names] = {    f: Foo;    sei: Symbols.SEIndex;    new ¬ names;    IF cbti = Symbols.CBTNull THEN RETURN;    IF h.bb[cbti].nesting = Catch THEN sei ¬ IP.SignalSeiFromCatchFrameHandle[h, p]    ELSE sei ¬ h.bb[cbti].ioType;    f ¬ IF inState --AND h.sv # NIL-- THEN IP.StateCtx[h, sei, io]     ELSE IP.XferCtx[h, sei, p, io]; -- A LIE!!! may have SV or be an error    IF f = NIL OR f.tsei = Symbols.RecordSENull THEN RETURN;    WITH h.seb[IP.TypeForSe[h, f.tsei]] SELECT FROM      record => {        FOR isei: Symbols.ISEIndex ¬ SymbolOps.FirstCtxSe[h.sym, fieldCtx], SymbolOps.NextSe[h.sym, isei] UNTIL isei = Symbols.SENull DO	  new ¬ AddNames[new, h.seb[isei].hash];	  ENDLOOP};      ENDCASE};        SetupLocalFoo: PROC [h: Handle, lf: LFHandle] RETURNS [f: Foo] = {    f ¬ IO.AllocFob[h];    f.addr.base ¬ lf;    f.indent ¬ 2;     f.xfer ¬ f.there ¬ TRUE;     f.displayFieldsOfRecordsAs ¬ variables};      SetupGlobalFoo: PROC[h: Handle, gf: GFHandle] RETURNS [f: Foo] = {    f ¬ IO.AllocFob[h];    f.addr.base ¬ gf;    f.indent ¬ 2;     f.xfer ¬ f.there ¬ TRUE;     f.displayFieldsOfRecordsAs ¬ variables};  DumpOne: PROC [h: Handle, ictx: Symbols.CTXIndex, names: Names] RETURNS[new: Names] = {    new ¬ names;    IF ictx = Symbols.CTXNull THEN RETURN;    IP.Complete[h, ictx];    new ¬ FieldCtx[h, ictx, 0, names]};      FieldCtx: PROCEDURE [h: Handle, ctx: Symbols.CTXIndex, pad: CARDINAL, names: Names] RETURNS[new: Names] = {    root, isei: ISEIndex;     GetNextSe: PROC[sei: ISEIndex] RETURNS[next: ISEIndex] = {      IF (next ¬ SymbolOps.NextSe[h.sym, sei]) = root       THEN next ¬ Symbols.ISENull};    new ¬ names;    root ¬ h.ctxb[ctx].seList;    FOR isei ¬ root, GetNextSe[isei] UNTIL isei = Symbols.ISENull DO      IF h.seb[isei].constant 	OR h.seb[isei].idType = Symbols.typeTYPE 	OR h.seb[isei].idCtx # ctx THEN LOOP;      new ¬ AddNames[new, h.seb[isei].hash];      ENDLOOP};      Names: TYPE = IJ.Names;  CreateNames: PUBLIC PROC RETURNS[Names] = {    RETURN[IO.zone.NEW[IJ.NamesBody[20] ¬ [size: 0, seq: NULL]]]};  DeleteNames: PUBLIC PROC [names: Names] = {IO.zone.FREE[@names]};  AddNames: PUBLIC PROC[h: Names, elt: Symbols.HTIndex] RETURNS[new: Names] = {    new ¬ IF h.size = h.max THEN ExpandNames[h] ELSE h;    new[new.size] ¬ elt;    new.size ¬ new.size + 1};  ExpandNames: PUBLIC PROC [h: Names] RETURNS [temp: Names] = {    temp ¬ IO.zone.NEW[IJ.NamesBody[h.max + 10] ¬ [size: h.size, seq: NULL]];    Inline.LongCOPY[from: @h[0], to: @temp[0], nwords: h.size*SIZE[Symbols.HTIndex]];    IO.zone.FREE[@h]};  «gnames: Names; -- temp use.»  «PutInWindow: PROC[h: Handle, names: Names, lg: IT.LG] = {    box: Window.Box ¬ Window.GetBox[h.tool];    optBox: Window.Box = IO.options.variableWindow;    toolname: LONG STRING ¬ [16];    height: INTEGER;     gnames ¬ names;    height ¬ (gnames.size+2)*FormSW.LineHeight[];    String.AppendString[toolname, IF lg = local THEN "Local"L ELSE "Global"L];    String.AppendString[toolname, " Variables"L];    IF optBox = Window.nullBox     THEN box ¬ [[box.place.x+300, box.place.y+50], [200, height]]    ELSE box ¬ [[box.place.x+optBox.place.x, box.place.y+optBox.place.y],       [optBox.dims.w, height]];    IF h.variableW = NIL THEN {      ENABLE GetITHandle => RESUME[h];      h.variableW ¬ Tool.Create[name: toolname, makeSWsProc: MakeSWs,         initialState: active, initialBox: box];      Context.Create[IO.MyContextType, h, ContextDestroyProc, h.variableW]}    ELSE {IO.EOL[h]; IO.Line[h, "Variable window already exists."L]}};»     «ContextDestroyProc: Context.DestroyProcType = {};»      «MakeSWs: Tool.MakeSWsProc = {    [] ¬ Tool.MakeFormSW[window: window, formProc: MakeVariableForm, options: [boldTags: FALSE], zone: IO.zone]};»        «GetITHandle: SIGNAL RETURNS[IT.Handle];»    «values: BOOLEAN ¬ TRUE;»    «MakeVariableForm: FormSW.ClientItemsProcType = {    varname: LONG STRING ¬ [20];    ss: String.SubStringDescriptor;    ItemsPerName: CARDINAL = IF values THEN 2 ELSE 1;    h: IT.Handle ¬ SIGNAL GetITHandle[];    items ¬ FormSW.AllocateItemDescriptor[gnames.size*ItemsPerName+1, IO.zone];    items[0] ¬ FormSW.CommandItem[tag: "Destroy"L,      place: FormSW.newLine, proc: DestroyVariableWindow, z: IO.zone];    FOR c: CARDINAL IN [0..gnames.size) DO      SymbolOps.SubStringForHash[h.sym, @ss, gnames[c]];      varname.length ¬ 0;      String.AppendSubString[varname, @ss];      items[c*ItemsPerName+1] ¬ FormSW.CommandItem[        tag: varname,        place: FormSW.newLine, proc: DumpVariable, z: IO.zone];      --IF values THEN {      --  tag: LONG STRING ¬       ENDLOOP;    RETURN[items, TRUE]};»      «DestroyVariableWindow: FormSW.ProcType = {    h: IT.Handle = Context.Find[IO.MyContextType,       ToolWindow.WindowForSubwindow[sw]];    --Tool.Destroy[h.variableW];    --h.variableW ¬ NIL;     gnames ¬ NIL};»        «DumpVariable: FormSW.ProcType = {    h: IT.Handle ¬ Context.Find[IO.MyContextType,      ToolWindow.WindowForSubwindow[sw]];    SendChars[h, " "L];    SendChars[h, item.tag];    SendChars[h, "\n"L]};»    «SendChars: PROC [h: IT.Handle, s: LONG STRING] = {    [] ¬ UserInput.StuffString[h.fileSW, s]};»  «Local: PUBLIC PROC[h: Handle, data: LONG UNSPECIFIED] = {    names: Names ¬ CreateNames[];    WITH h.iContext SELECT FROM      local => names ¬ DisplayLocalsF[h, lf, names];      global => names ¬ DisplayLocalsGF[h, names];      ENDCASE;    --PutInWindow[h, names, local];    DeleteNames[names]};»      «Global: PUBLIC PROC[h: Handle, data: LONG UNSPECIFIED] = {    names: Names ¬ CreateNames[];    names ¬ DisplayLocalsGF[h, names];    --PutInWindow[h, names, global];    DeleteNames[names]};»  }..
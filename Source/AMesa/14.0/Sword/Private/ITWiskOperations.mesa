-- File: ITWiskOperations.mesa - last edit:-- Litman              10-Apr-87 23:06:05-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.DIRECTORY  Ascii USING [ControlZ, CR, SP],  CatchFormat USING [CatchEV],  Context USING [CreateProcType, Data, Find, FindOrCreate, Type, UniqueType],  Copier USING [Handle, Outer],  Event USING [fileWindow],  EventTypes USING [createWindow, destroy, edit, FileWindowEvents, load, reset, store],  FileSW USING [GetFile, IsEditable, IsIt],  FileWindow USING [Enumerate, EnumerateProcType, FileInWindow, GetInfo, LoadWindow, SetSourceMenu, WindowForFile],  Heap USING [systemZone],  IA USING [],  IH USING [InterpreterForWorld],  IL USING [SC],  Inline USING [LongNumber],  IO USING [Decimal, EOL, Line, Text, zone],  IP USING [CacheCBti, CheckTimes, CodeBase, EntryPC, ExitPC, Fail, FileMissing, GetPc, GFrame, MultipleFrames, Original, PcToSource],  IQ USING [BPFail, BPWriteError, FindBB, GFrameMdi, Insert, NoFGT, Remove, ValidateGF],  IS USING [LongNum, Umbrella, WriteError],  IT USING [BBHandle, BreakType, BT, BTIndex, BytePC, CBTIndex, EVIndex, EXOI, GFHandle, Handle, MaxModuleString, MDIndex],  Menu USING [Error, Free, Handle, Make, MCRType, Uninstantiate],  PrincOps USING [PrefixHandle],  Runtime USING [IsBound],  Selection USING [Clear, Convert],  Stream USING [EndOfStream, GetChar, GetPosition, Handle, SetPosition],  String USING [AppendChar, Compare, EqualString, StringBoundsFault],  Supervisor USING [AddDependency, AgentProcedure, CreateSubsystem, DeleteSubsystem, nullSubsystem, RemoveDependency, SubsystemHandle],  SwordUsefulDefs USING [GetDefaultWorld, NoSession],  Symbols USING [BodyRecord, BTNull, CBTNull, RootBti],  SymbolTable USING [Handle, Missing],  TextSW USING [GetSelection, SetSelection],  UserTerminal USING [BlinkDisplay],  Window USING [Handle],  WorldVM USING [World],  WorldVMOps USING [Read];  ITWiskOperations: PROGRAM  IMPORTS Context, Copier, Event, FileSW, FileWindow, Heap, IH, IO, IP, IQ, IS, Menu, Runtime, Selection, Stream, String, Supervisor, SwordUsefulDefs, SymbolTable, TextSW, UserTerminal, WorldVMOps  EXPORTS IA, IL, IP = {    windows: BOOLEAN = Runtime.IsBound[LOOPHOLE[FileWindow.Enumerate]];  myContext: Context.Type = IF windows THEN Context.UniqueType[] ELSE last;    SourceTooLong: ERROR = CODE;  NotFound: SIGNAL = CODE;  BreakRec: TYPE = RECORD [sc: IL.SC, bt: IT.BreakType];  RelPC: TYPE = [0..LAST[CARDINAL]/2];    Item: TYPE = LONG POINTER TO ItemObject;  ItemObject: TYPE = RECORD [trustTime: BOOLEAN, gf: IT.GFHandle, world: WorldVM.World];  nullItem: ItemObject = [trustTime: FALSE, gf: NIL, world: NIL];    MenuIndex: TYPE = {attach, break, trace, clear};    DoAttach: PUBLIC PROC[window: Window.Handle] = {    item: Item = Context.FindOrCreate[myContext, window, CreateItem];    IF item = NIL THEN {--IO.Line[h, "Bad window!"L];-- UserTerminal.BlinkDisplay[]}    ELSE item.trustTime ¬ TRUE };  MyMCRs: Menu.MCRType = {    menuIndex: MenuIndex = VAL[index];    h: IT.Handle;    Umbilical: PROC[h: IT.Handle, u: LONG UNSPECIFIED] = {      SELECT menuIndex FROM	attach => DoAttach[window];	break => SetUp[h, window, set, break];	trace => SetUp[h, window, set, trace];	clear => SetUp[h, window, clear, break];	ENDCASE};    h ¬ IH.InterpreterForWorld[SwordUsefulDefs.GetDefaultWorld[      ! SwordUsefulDefs.NoSession => GOTO NoSession]];    IS.Umbrella[h, 0, Umbilical];    EXITS NoSession => UserTerminal.BlinkDisplay[] };    LoadWindow: PUBLIC PROCEDURE [h: IT.Handle, name: LONG STRING, gf: IT.GFHandle ¬ NIL, file: Stream.Handle ¬ NIL, position: LONG CARDINAL] = {    w: Window.Handle = FileWindow.WindowForFile[name];    streamInWindow: Stream.Handle;    loadIfSame: BOOLEAN ¬ FALSE;    IF w = NIL THEN { IO.Line[h, "No file window!"L]; UserTerminal.BlinkDisplay[]; RETURN };    streamInWindow ¬ FileWindow.FileInWindow[w].s;    IF streamInWindow # NIL AND gf # NIL THEN IP.CheckTimes[h, w, gf, streamInWindow ! IP.FileMissing => {loadIfSame ¬ TRUE; CONTINUE}];    FileWindow.LoadWindow[fileName: name, position: position, s: file, loadIfSame: loadIfSame, sw: w];    TextSW.SetSelection[w, position, position+1];    SetGF[h, w, IP.Original[h, gf]] };      Shorten: PROCEDURE [lc: LONG CARDINAL] RETURNS [CARDINAL] = {    OPEN ln: LOOPHOLE[lc, Inline.LongNumber];    IF ln.highbits # 0 THEN ERROR SourceTooLong;    RETURN [ln.lowbits] };      Break: PROCEDURE [h: IT.Handle, sw: Window.Handle, br: BreakRec] RETURNS [ok: BOOLEAN] = {    gf: IT.GFHandle;    pc: IT.BytePC;    cbti: IT.CBTIndex ¬ Symbols.CBTNull;    ep: IT.EVIndex ¬ 0;    index: CARDINAL ¬ 0;    mdi: IT.MDIndex;    SearchModule: PROCEDURE [base: SymbolTable.Handle] = {      startPc: IT.BytePC;      relPc: RelPC;      [relPc,cbti,index] ¬ ExploreFGT[base, Shorten[TextSW.GetSelection[sw].left]];      IF base.bb[cbti].inline THEN ERROR IQ.BPFail[inInline];      WITH body: base.bb[cbti] SELECT FROM        Catch => {	  Impossible: ERROR = CODE;	  catchCode: IT.BytePC;	  codebase: PrincOps.PrefixHandle;	  catchEv: CatchFormat.CatchEV;	  IF br.bt.ex = entry THEN ERROR Impossible; 	  codebase ¬ IP.CodeBase[h, gf];	  catchCode ¬ WorldVMOps.Read[h.world, @codebase.header.catchCode];	  catchEv ¬ LOOPHOLE[catchCode/2];	  startPc ¬ WorldVMOps.Read[h.world, @codebase[catchEv][body.index]]};	ENDCASE => {	  ep ¬ body.entryIndex;	  startPc ¬ IP.GetPc[h, gf, ep] };      pc ¬ startPc+relPc;      index ¬ IP.PcToSource[h, base, gf, pc, cbti, startPc] };    IF sw = NIL THEN {IO.Line[h, "No window!"L]; RETURN[FALSE]};    BEGIN ENABLE {      IQ.BPFail => {IQ.BPWriteError[h, type]; GOTO nogood};      IP.FileMissing => {IO.Text[name, h]; GOTO nogood};      IQ.NoFGT, SymbolTable.Missing => {IS.WriteError[h, nSymtab]; GOTO nogood};      IP.MultipleFrames => { IO.Text["Multiple instances; use Display Stack, Source to load window."L, h]; GOTO nogood};      IP.Fail => {IO.Text[s, h]; IS.WriteError[h, notFound, FALSE]; GOTO nogood};      SourceTooLong => { IO.Text["Source too long! (> 65535 characters)"L, h]; GOTO nogood}};    IF (gf ¬ GetContext[h, sw]) = NIL OR ~IQ.ValidateGF[h, gf] THEN { IS.LongNum[h, gf, [pointer[]]]; IS.WriteError[h, nGframe, FALSE]; GOTO nogood };    mdi ¬ IQ.GFrameMdi[h, gf, TRUE];    Copier.Outer[h.sym, mdi, SearchModule];    cbti ¬ IP.CacheCBti[h, mdi, gf, cbti];    SELECT br.bt.ex FROM      entry => pc ¬ IP.EntryPC[h, gf, ep];      exit => pc ¬ IP.ExitPC[h, cbti];      in => NULL;      ENDCASE;    IF br.sc = set THEN PostBreakMsg[h, IQ.Insert[h, gf, pc, br.bt, TRUE].num, gf, pc]    ELSE {      bbh: IT.BBHandle = IQ.FindBB[h, gf, pc];      num: CARDINAL = IF bbh # NIL THEN bbh.num ELSE 0 -- TRASH --;      IQ.Remove[h, gf,pc];      IO.EOL[h]; IO.Text["Breakpoint #"L, h]; IO.Decimal[h, num];       IO.Text[" cleared."L, h]; IO.EOL[h] }    EXITS nogood => RETURN[FALSE];    END; -- ENABLE     FixSelection[sw: sw, left: index, right: IF br.bt.ex = in THEN (index + 1) ELSE Shorten[TextSW.GetSelection[sw].right], set: br.sc=set];    RETURN[TRUE] };    PostBreakMsg: PROCEDURE [h: IT.Handle, brkNum: CARDINAL, gf: IT.GFHandle, pc: IT.BytePC] = {    ENABLE {      IP.FileMissing => {IO.Text[name, h]; GOTO nogood};      IQ.NoFGT, SymbolTable.Missing => { IO.Text["No symbol table!"L, h]; GOTO nogood};      IP.Fail => {IO.Text[s, h]; IS.WriteError[h, notFound, FALSE]; GOTO nogood};      SourceTooLong => { IO.Text["Source too long! (> 65535 characters)"L, h]; GOTO nogood}};    IO.EOL[h]; IO.Text["Breakpoint #"L, h];     IO.Decimal[h, brkNum]; IO.Line[h, "."L];     -- IP.Display[gf: gf, pc: pc, load: FALSE];    EXITS nogood => NULL};    « we start with currentSource and bestSource at the beginning of the source for this bti (body) currentPc and bestPc start out at 0 (the first [relative] pc for this body).  anytime we see a "normal" entry (ie an entry for the start of a statement) we either return because the statement is after the one we are interested in, or we update bestSource and bestPc.  If we see a "step" entry, we update either currentSource or currentPc as necessary.  currentSource and currentPc reflect where the fgt says the NEXT statement will start.  note that currentSource and currentPc do not necessarily reflect the start of a statement. Invariants:  bestSource is the source index of the start of the statement in this body with the highest index not greater than the index we are interested in.  likewise bestPc is the offset into the code for this body for the start of that statement. »« Don't touch this procedure unless you really know what you're doing. »  ClosestSource: PROCEDURE [bti: IT.BTIndex, index: CARDINAL, base: SymbolTable.Handle] RETURNS [bestSource: CARDINAL, bestPc: RelPC] = {    stepping: BOOLEAN ¬ FALSE;    curSource: CARDINAL;     currentPc: RelPC;    bestSource ¬ curSource ¬ base.bb[bti].sourceIndex;    bestPc ¬ currentPc ¬ 0;    IF BASE[base.fgTable] = NIL THEN RETURN[bestSource, 1];    WITH base.bb[bti].info SELECT FROM      External => 	FOR i: CARDINAL IN (startIndex..startIndex+indexLength) -- skip [0,0] -- DO 	  WITH fgtEntry: base.fgTable[i] SELECT FROM	    normal => {	      curSource ¬ curSource + fgtEntry.deltaSource;	      IF curSource > index THEN RETURN[bestSource, MAX[bestPc, 1]];	      bestSource ¬ curSource;	      currentPc ¬ currentPc + fgtEntry.deltaObject;	      IF fgtEntry.deltaSource # 0 --0 in INLINE code-- 		OR stepping --finishing off a single statement--		THEN bestPc ¬ currentPc;	      stepping ¬ FALSE };	    step => { -- note that it is possible to have multiple steps in a row	      SELECT fgtEntry.which FROM		source => curSource ¬ curSource + fgtEntry.delta;		object => currentPc ¬ currentPc + fgtEntry.delta;		ENDCASE;	      stepping ¬ TRUE };	    ENDCASE;	  ENDLOOP;      ENDCASE => RETURN[bestSource, MAX[bestPc, 1]]};      ExploreFGT: PROCEDURE [base: SymbolTable.Handle, index: CARDINAL] RETURNS [bestPc: RelPC, bestCbti: IT.CBTIndex, bestSource: CARDINAL] = {    CheckBti: PROCEDURE [h: SymbolTable.Handle, bti: IT.BTIndex]       RETURNS [stop: BOOLEAN] = {      source: CARDINAL;      pc: RelPC;      stop ¬ FALSE;      IF base.bb[bti].kind # Callable OR base.bb[bti].sourceIndex > index THEN RETURN;      [source, pc] ¬ ClosestSource[bti, index, base];      IF source <= bestSource THEN RETURN;      bestSource ¬ source; bestCbti ¬ LOOPHOLE[bti]; bestPc ¬ pc };    bestPc ¬ 0; bestCbti ¬ Symbols.RootBti; bestSource ¬ 0;    [] ¬ --SymbolOps.--EnumerateBodies[base, Symbols.RootBti, CheckBti] };      EnumerateBodies: PROC[h: SymbolTable.Handle, bti: IT.BTIndex, proc: PROC [h: SymbolTable.Handle, bti: IT.BTIndex] RETURNS [stop: BOOLEAN]] RETURNS [IT.BTIndex] = {    btLimit: IT.BTIndex = bti + h.stHandle.bodyBlock.size;    UNTIL LOOPHOLE[bti, CARDINAL] >= LOOPHOLE[btLimit, CARDINAL] DO      IF proc[h, bti] THEN RETURN[bti];      WITH entry: h.bb[bti] SELECT FROM	Callable => {	  bti ¬ bti +	    (WITH entry SELECT FROM	       Inner => SIZE[Inner Callable Symbols.BodyRecord],	       Catch => SIZE[Catch Callable Symbols.BodyRecord],	       ENDCASE => SIZE[Outer Callable Symbols.BodyRecord])}	ENDCASE => bti ¬ bti + SIZE[Other Symbols.BodyRecord];      REPEAT FINISHED => RETURN[Symbols.BTNull];      ENDLOOP };      FixSelection: PROCEDURE [sw: Window.Handle, left, right: CARDINAL, set: BOOLEAN] = {     Selection.Clear[];    TextSW.SetSelection[sw, left, right] };      GetContext: PROCEDURE [h: IT.Handle, w: Window.Handle] RETURNS [frame: IT.GFHandle] = {    mod: STRING ¬ [IT.MaxModuleString];    retry: BOOLEAN ¬ TRUE;    IF (frame ¬ GetGF[h, w]) # NIL THEN RETURN;    ParseOutModuleName[w, mod];    IF mod.length = 0 THEN RETURN[NIL];    frame ¬ IP.GFrame[h, mod];    IF frame = NIL THEN { IO.Text[" Cant find frame for "L, h]; IO.Line[h, mod]; RETURN };    frame ¬ IP.Original[h, frame];    IP.CheckTimes[h, w, frame, FileSW.GetFile[w].s];    SetGF[h, w, frame] };      MakeEXOI: PROCEDURE [s: LONG STRING] RETURNS [IT.EXOI] = {    RETURN[SELECT TRUE FROM      String.EqualString[s, "PROC"L] => entry,      String.EqualString[s, "PROCEDURE"L] => entry,      String.EqualString[s, "RETURN"L] => exit,      ENDCASE => in]};      SetUp: PUBLIC PROCEDURE [h: IT.Handle, w: Window.Handle, sc: IL.SC, bt: IT.BT] = {    br: BreakRec;    text: LONG STRING;    IF ~ValidateSource[w] THEN { IO.Line[h, "Selection not in file subwindow!"L]; GOTO fail };    IF FileSW.IsEditable[w] THEN { IO.Line[h, "File subwindow being edited!"L]; GOTO fail };    text ¬ Selection.Convert[string];    IF text = NIL THEN {IO.Line[h, "Text not selected!"L]; GOTO fail };    br ¬ [sc: sc, bt: [ex: MakeEXOI[text], bt: bt]];    Heap.systemZone.FREE[@text];    IF ~Break[h, w, br] THEN GOTO fail;    EXITS fail => UserTerminal.BlinkDisplay[] };      ValidateSource: PROCEDURE [w: Window.Handle] RETURNS [BOOLEAN] = {    IF ~FileSW.IsIt[w] THEN RETURN[FALSE];    RETURN[Selection.Convert[subwindow] = w]};      SkipLineComment: PROCEDURE [sh: Stream.Handle] = {    DO      SELECT Stream.GetChar[sh] FROM	Ascii.CR => RETURN;	'- => 	  SELECT Stream.GetChar[sh] FROM  	    '-, Ascii.CR => RETURN;	    ENDCASE;	ENDCASE;      ENDLOOP};      SkipBracketedComment: PROCEDURE [sh: Stream.Handle] = {    -- enter with the stream positioned so that the GetChar reads the     -- character immediately following the "<<"    -- returns with the stream positioned so that a GetChar will read the    -- character just after the ">>".    -- will skip nested comments    ch: CHAR ¬ Stream.GetChar[sh];    DO      SELECT ch FROM        '» => RETURN;	'> => 	  IF (ch ¬ Stream.GetChar[sh]) # '> THEN LOOP ELSE RETURN;	'« => SkipBracketedComment[sh];	'< => 	  IF (ch ¬ Stream.GetChar[sh]) # '< THEN LOOP 	  ELSE SkipBracketedComment[sh];	ENDCASE;	ch ¬ Stream.GetChar[sh];      ENDLOOP };      ParseOutModuleName: PROCEDURE [w: Window.Handle, module: STRING] = {    savePos: LONG CARDINAL;    found: BOOLEAN ¬ FALSE;    filename: LONG STRING;    stream: Stream.Handle;    [filename, stream] ¬ FileSW.GetFile[w];    savePos ¬ Stream.GetPosition[stream];    Stream.SetPosition[stream, 0];    DO      ENABLE Stream.EndOfStream, NotFound => EXIT;      GetId[stream, module];      IF String.EqualString[module, "DIRECTORY"L] THEN {	-- skip the directory section	char: CHARACTER ¬ Stream.GetChar[stream];	DO 	  SELECT char FROM	    '« => {SkipBracketedComment[stream]; char ¬ Stream.GetChar[stream]};	    '- =>	      IF ((char ¬ Stream.GetChar[stream]) = '-) 	      THEN {SkipLineComment[stream]; char ¬ Stream.GetChar[stream]};	    '< =>	      IF ((char ¬ Stream.GetChar[stream]) = '<)	      THEN {SkipBracketedComment[stream]; char ¬ Stream.GetChar[stream]};	    '; => EXIT;	    ENDCASE => char ¬ Stream.GetChar[stream];	  ENDLOOP}      ELSE {        nextId: STRING ¬ [IT.MaxModuleString];	GetId[stream, nextId];	found ¬ (String.EqualString[nextId, "PROGRAM"L] 	  OR String.EqualString[nextId, "MONITOR"L]);	EXIT};      ENDLOOP;    IF ~found THEN found ¬ TryCModule[filename, stream, module];    IF ~found THEN found ¬ TryFortranModule[filename, stream, module];    IF ~found THEN module.length ¬ 0;    Stream.SetPosition[stream, savePos]};      TryFortranModule: PROC[filename: LONG STRING, stream: Stream.Handle, module: STRING] RETURNS[found: BOOLEAN] = {    IF ~((filename[filename.length-2] = '.) AND (filename[filename.length-1] = 'f)) THEN RETURN[FALSE]    ELSE {      Stream.SetPosition[stream, 0];      DO        ENABLE Stream.EndOfStream, NotFound => { found ¬ FALSE; EXIT };	GetId[stream, module];        IF String.Compare[s1: module, s2: "PROGRAM"L, ignoreCase: TRUE] = 0	THEN { GetId[stream, module]; found ¬ TRUE; EXIT };        ENDLOOP}};      TryCModule: PROC[filename: LONG STRING, stream: Stream.Handle, module: STRING] RETURNS[found: BOOLEAN] = {    IF ~((filename[filename.length-2] = '.) AND (filename[filename.length-1] = 'c)) THEN RETURN[FALSE]    ELSE {      bracket: CARDINAL;      FOR bracket DECREASING IN [1..filename.length] DO	IF filename[bracket-1] = '> THEN EXIT;	REPEAT FINISHED => bracket ¬ 0;	ENDLOOP;      module.length ¬ filename.length-bracket-2;      found ¬ (module.length # 0);      FOR j: CARDINAL IN [0..module.length) DO 	module[j] ¬ filename[j+bracket];	ENDLOOP}};    GetId: PROCEDURE [s: Stream.Handle, token: STRING] = {    c: CHARACTER ¬ Stream.GetChar[s];    token.length ¬ 0;    DO       SELECT c FROM        '« => {SkipBracketedComment[s]; c ¬ Stream.GetChar[s]};	'- =>	  IF (c ¬ Stream.GetChar[s]) = '- 	  THEN {SkipLineComment[s]; c ¬ Stream.GetChar[s]}	  ELSE SIGNAL NotFound;	'< =>	  IF (c ¬ Stream.GetChar[s]) = '< 	  THEN {SkipBracketedComment[s]; c ¬ Stream.GetChar[s]}	  ELSE SIGNAL NotFound;	Ascii.ControlZ => 	  UNTIL Stream.GetChar[s] = Ascii.CR DO REPEAT FINISHED => c ¬ Ascii.CR ENDLOOP;	<= Ascii.SP, ': => IF token.length # 0 THEN RETURN ELSE c ¬ Stream.GetChar[s];	'=, '[ => SIGNAL NotFound;	ENDCASE => {	  String.AppendChar[token, c ! String.StringBoundsFault => CONTINUE]; 	  c ¬ Stream.GetChar[s]};      ENDLOOP};  -- GlobalFrame/SourceWindow correspondence stuff  IgnoreTimeStamp: PUBLIC PROCEDURE [h: IT.Handle, w: Window.Handle] RETURNS [BOOLEAN] = {    item: Item = FindItem[h, w];    RETURN[IF item = NIL THEN FALSE ELSE item.trustTime] };    ResetFrames: PUBLIC PROCEDURE[h: IT.Handle] = {    Proc: FileWindow.EnumerateProcType = { ResetGF[h, sw]; RETURN[continue] };    IF windows THEN FileWindow.Enumerate[Proc] };      GetGF: PROCEDURE [h: IT.Handle, w: Window.Handle] RETURNS [IT.GFHandle] = {     item: Item = FindItem[h, w];    RETURN [IF item = NIL THEN NIL ELSE item.gf] };      SetGF: PROCEDURE [h: IT.Handle, w: Window.Handle, gf: IT.GFHandle] = {    item: Item = Context.FindOrCreate[myContext, w, CreateItem];    IF item # NIL THEN { item.gf ¬ gf; item.world ¬ h.world }};      ResetGF: PROCEDURE [h: IT.Handle, w: Window.Handle] = {    item: Item = FindItem[h, w];     IF item # NIL THEN item­ ¬ nullItem };      CreateItem: Context.CreateProcType = {    RETURN[IO.zone.NEW[ItemObject ¬ [trustTime: FALSE, gf: NIL, world: NIL]], DestroyItem]};  DestroyItem: PROCEDURE [item: Context.Data, sw: Window.Handle] = {    IO.zone.FREE[@item]};      FindItem: PROCEDURE [h: IT.Handle, w: Window.Handle] RETURNS [item: Item] = {    IF w = NIL OR (item ¬ Context.Find[myContext, w]) = NIL OR (h # NIL AND item.world # h.world) THEN RETURN[NIL] };      SetupMenu: PROCEDURE[] = {    menuStrings: ARRAY MenuIndex OF LONG STRING ¬ [attach: "Attach"L, break: "Break"L, trace: "Trace"L, clear: "Clear"L];    FileWindow.SetSourceMenu[      Menu.Make[        name: "Debug Ops"L, 	strings: DESCRIPTOR[menuStrings.BASE, menuStrings.LENGTH],	mcrProc: MyMCRs,	copyStrings: TRUE,	permanent: TRUE]]};	  UnsetMenu: PROC[] = {    OneFileWindow: FileWindow.EnumerateProcType = {       Menu.Uninstantiate[sourceMenu, sw ! Menu.Error => CONTINUE]; RETURN[continue] };    sourceMenu: Menu.Handle = FileWindow.GetInfo[].sourceMenu;    IF sourceMenu = NIL THEN RETURN;    FileWindow.Enumerate[OneFileWindow];     sourceMenu.permanent ¬ FALSE;    Menu.Free[menu: sourceMenu, freeStrings: TRUE];    FileWindow.SetSourceMenu[NIL] };      SomethingChanged: Supervisor.AgentProcedure = {    w: Window.Handle = eventData;    -- the philosophy here is that there is no need to fiddle with a     -- window unless it has a context on it, that contexts will be added when     -- needed, and reset anytime it could be necessary    SELECT event FROM      EventTypes.createWindow,      EventTypes.destroy,      EventTypes.load,        -- if EventTypes.load is notified when you do a FileWindow.LoadWindow	-- we will need to put more smarts into ResetGF (or LoadWindow) so 	-- that the ignore timestamp info doesn't get lost over 	-- "Display Stack; Source" commands      EventTypes.edit,      EventTypes.reset,      EventTypes.store => ResetGF[NIL, w];      IN EventTypes.FileWindowEvents => ERROR;      ENDCASE };        UnloadITWiskOperations: PUBLIC --IA-- PROC[] = {    IF agent # Supervisor.nullSubsystem THEN {      Supervisor.RemoveDependency[client: agent, implementor: Event.fileWindow];      Supervisor.DeleteSubsystem[agent];      agent ¬ Supervisor.nullSubsystem };    IF windows THEN UnsetMenu[] };    agent: Supervisor.SubsystemHandle ¬ Supervisor.CreateSubsystem[SomethingChanged];   Supervisor.AddDependency[client: agent, implementor: Event.fileWindow];  IF windows THEN SetupMenu[];  }.
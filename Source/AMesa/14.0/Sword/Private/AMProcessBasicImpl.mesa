-- File: AMProcessBasicImpl.mesa - last edit:-- Litman              22-Apr-87 18:36:24-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.DIRECTORY  AMHeap USING [zone],  AMProcessBasic USING [ControlLink, Faulted, GFTable, GFTableObject, LFHandle, NullProcess, Process, State, StateArray],  CPSwapDefs USING [ProcessState],  Environment USING [Long, PageFromLongPointer, PageNumber, wordsPerPage],  ESCAlpha USING [aMR, aMW],  Frame USING [Alloc, Free, GetReturnFrame, MyGlobalFrame, MyLocalFrame, ReadGlobalLink, ReadLocalWord, ReadPC, ReadReturnLink, WriteReturnLink],  Freeze USING [freezeesTable, freezer, Frozen, qFreeze],  Inline USING [HighHalf, LongCOPY],  Mopcodes USING [op, zME],  PageMap USING [IsVacant],  PrincOps USING [BytePC, FrameVec, FSIndex, LargeReturnSlot, LocalFrameHandle, LocalOverhead, PrefixHandle, ShortControlLink, StateVector],  PrincOpsExtras USING [nullShortLink, SourceDest],  PrincOpsExtras2 USING [ControlLink, NullLink],   Process USING [Pause],  ProcessOperations USING [DisableInterrupts, EnableInterrupts, HandleToIndex, IndexToHandle, ReadPSB, Requeue],  PSB USING [FaultIndex, NoTimeout, PDA, Priority, ProcessStateBlock, PsbHandle, PsbIndex, PsbNull, qFrameFault, qPageFault, Queue, QueueEmpty, QueueHandle, qWriteProtectFault],  SDDefs USING [SD],  VM USING [MakeResident, MakeSwappable],  WorldVM USING [LocalWorld, Lock, Unlock, World],  WorldVMOps USING [Address, AddressFault, BytePC, CodebaseFromGf, CopyRead, CopyWrite, GFlong, LFlong, LFshort, Long, LongRead, NullProcess, PrefixHandle, Process, ProcessShort, Read, ReadCodeByte, World, Write],  WVMPatch USING [Patch];AMProcessBasicImpl: MONITOR   IMPORTS AMHeap, Environment, Frame, Freeze, Inline, PageMap, Process, ProcessOperations, VM, WorldVM, WorldVMOps, WVMPatch  EXPORTS AMProcessBasic   SHARES Freeze = {  zone: UNCOUNTED ZONE = AMHeap.zone;  NotImplemented: ERROR = CODE;    qFreeze: PSB.FaultIndex = Freeze.qFreeze;  freezeQueue: LONG POINTER TO PSB.Queue = @PSB.PDA.fault[qFreeze].queue;    LFHandle: TYPE = AMProcessBasic.LFHandle;    Info: PUBLIC PROC[world: WorldVM.World, process: AMProcessBasic.Process, freeze, thaw, fullStatus: BOOL, filter: AMProcessBasic.GFTable, wantedStates: AMProcessBasic.StateArray]    RETURNS[state: AMProcessBasic.State, faultData: LONG CARDINAL, priority: PSB.Priority, frame, frozenFrame, topFrame: LFHandle] = {    frozen: BOOL;    psbi: PSB.PsbIndex = WorldVMOps.ProcessShort[process];    processFrame, prevFrame, freezeTrap: PrincOps.LocalFrameHandle;    restOfStack: PrincOps.ShortControlLink;    LockFilter[filter];    Set[psbi];    restOfStack ¬ GetFreezee[world, psbi];    freezeTrap ¬ Freezer[world];    [priority, frozen, state, processFrame, faultData] ¬ InfoFromPSB[world, psbi, fullStatus];    IF state = dead THEN RETURN;    -- now, world and psbi are locked --    IF NOT wantedStates[state] THEN { Unlock[world]; Clear[psbi]; UnlockFilter[filter]; RETURN };    [frame, prevFrame] ¬ ApplyFilter[world, [frame[processFrame]], filter, [frame[freezeTrap]] ! UNWIND => { Unlock[world]; Clear[psbi]; UnlockFilter[filter] }];    frozenFrame ¬ IF restOfStack.frame = NIL THEN NIL ELSE (IF frozen THEN GetLink[world, restOfStack.frame].frame ELSE restOfStack.frame);    topFrame ¬ IF frozen OR (freezeTrap = processFrame) THEN frozenFrame ELSE processFrame;    SELECT TRUE FROM      (frame # freezeTrap AND frame # NIL) => { -- A victim was found and it's in unfrozen territory.	IF freeze THEN { -- freeze here --	  IF frame = processFrame THEN SetPsbFrame[world, psbi, freezeTrap] ELSE SetLink[world, prevFrame, [frame[freezeTrap]]];	  Unlock[world];	  IF restOfStack.frame # NIL THEN {	    tail: PrincOps.LocalFrameHandle ¬ WorldVMOps.LFshort[world, frame];	    DO 	      next: PrincOps.LocalFrameHandle = GetLink[world, tail].frame;	      IF next = freezeTrap THEN EXIT;	      tail ¬ next;	      ENDLOOP;	    SetLink[world, tail, restOfStack] };	  SetFreezee[world, psbi, [frame[WorldVMOps.LFshort[world, frame]]]];	  frozenFrame ¬ frame }	ELSE Unlock[world] };      (frame = freezeTrap) => {        [frame, prevFrame] ¬ ApplyFilter[world, restOfStack, filter, PrincOpsExtras2.NullLink ! UNWIND => { Unlock[world]; Clear[psbi]; UnlockFilter[filter] } ];	IF (frame # NIL) AND (frame # restOfStack.frame) AND (NOT frozen OR frame # frozenFrame) AND freeze AND thaw THEN {	  SetLink[world, prevFrame, [frame[freezeTrap]]];	  Unfreeze[world, psbi, processFrame, restOfStack];	  SetFreezee[world, psbi, [frame[WorldVMOps.LFshort[world, frame]]]];	  frozenFrame ¬ frame}	ELSE Unlock[world] };      ENDCASE => Unlock[world];    -- clean up --    Clear[psbi];    UnlockFilter[filter] };  InfoFromPSB: PROC[world: WorldVM.World, psbi: PSB.PsbIndex, fullStatus: BOOL]     RETURNS[priority: PSB.Priority, frozen: BOOLEAN, state: AMProcessBasic.State, processFrame: PrincOps.LocalFrameHandle, faultData: LONG CARDINAL ¬ 0] = {    psb: PSB.ProcessStateBlock;    -- prevent victim from proceeding --    -- Also disables interrupts and stops processor timeout scan if world = local    Lock[world];     BEGIN ENABLE UNWIND => { Unlock[world]; Clear[psbi] };    psb ¬ GetPSB[psbi, world];    priority ¬ psb.link.priority;    -- get status --    IF LOOPHOLE[psb.flags.available, CPSwapDefs.ProcessState].state = dead THEN { Unlock[world]; Clear[psbi]; state ¬ dead; RETURN };    frozen ¬ OnQueue[world, psbi, freezeQueue];    SELECT TRUE FROM      psb.flags.waiting => state ¬ waitingCV;      fullStatus => state ¬ GetQueueState[psbi, world, psb.link.failed];      ENDCASE => state ¬ unknown;    -- get context --    IF psb.link.preempted THEN { -- context must be a state vector      sv: PrincOps.StateVector;      stateAddr: WorldVMOps.Address = LOOPHOLE[PSB.PDA, WorldVMOps.Address] + LOOPHOLE[psb.context.state, CARDINAL];      IF world = local -- avoid making a procedure call to non-resident code! --      THEN Inline.LongCOPY[from: LOOPHOLE[stateAddr], to: @sv, nwords: SIZE[PrincOps.StateVector] ]      ELSE WorldVMOps.CopyRead[world: world, from: stateAddr, to: @sv, nwords: SIZE[PrincOps.StateVector] ];      processFrame ¬ sv.frame;      faultData ¬ SELECT state FROM	frameFault => sv.fsi,	pageFault, writeProtectFault => LOOPHOLE[sv.memPointer],	IN AMProcessBasic.Faulted => LOOPHOLE[@sv.dataArray, POINTER TO LONG CARDINAL]^,	ENDCASE => 0 }    ELSE processFrame ¬ psb.context.frame;    END--UNWIND catch-- };   GetQueueState: PROC[psbi: CARDINAL, world: WorldVM.World, enterFailed: BOOL] RETURNS[state: AMProcessBasic.State] = INLINE {    IF OnQueue[world, psbi, @PSB.PDA.ready] THEN RETURN[ready];    FOR q: PSB.FaultIndex IN PSB.FaultIndex DO       IF OnQueue[world, psbi, @(PSB.PDA.fault[q].queue)] THEN         SELECT q FROM	  PSB.qFrameFault => RETURN[frameFault];	  PSB.qPageFault,	  PSB.qPageFault+4 => RETURN[pageFault]; -- "+4" for software queues	  PSB.qWriteProtectFault,	  PSB.qWriteProtectFault+4 => RETURN[writeProtectFault];	  qFreeze => RETURN[ready];	  ENDCASE => RETURN[unknownFault];      ENDLOOP;    RETURN[IF enterFailed THEN waitingML ELSE unknown] };  OnQueue: PROC[world: WorldVM.World, psbi: PSB.PsbIndex, queueHandle: PSB.QueueHandle, remove: BOOL ¬ FALSE] RETURNS[BOOL] = INLINE {    IF world = local THEN {      tail, prev: PSB.PsbIndex;      IF queueHandle^ = PSB.QueueEmpty THEN RETURN[FALSE];      prev ¬ tail ¬ queueHandle.tail;      THROUGH [FIRST[PSB.PsbIndex]..LAST[PSB.PsbIndex]+1] -- garbage protection -- DO 	next: PSB.PsbIndex = PSB.PDA.block[prev].link.next;	IF next = psbi THEN {	  IF remove THEN ProcessOperations.Requeue[queueHandle, @PSB.PDA.ready, ProcessOperations.IndexToHandle[psbi]];	  RETURN[TRUE] };	prev ¬ next;	IF prev = tail THEN RETURN[FALSE];	ENDLOOP;      RETURN[FALSE] } -- actually, the queue is thoroughly mangled! --    ELSE RETURN[OnRemoteQueue[world, psbi, LOOPHOLE[queueHandle], remove]]};  OnRemoteQueue: PROC[world: WorldVM.World, psbi: PSB.PsbIndex, queueHandle: WorldVMOps.Address, remove: BOOL] RETURNS[BOOL] = {    dest: LONG POINTER TO PSB.Queue = IF remove THEN @PSB.PDA.ready ELSE NIL;    queue: PSB.Queue;    tail, prev: PSB.PsbIndex;    WorldVMOps.CopyRead[world: world, from: queueHandle, to: @queue, nwords: SIZE[PSB.Queue]];    IF queue = PSB.QueueEmpty THEN RETURN[FALSE];    prev ¬ tail ¬ queue.tail;    THROUGH [FIRST[PSB.PsbIndex]..LAST[PSB.PsbIndex]+1] -- garbage protection -- DO       psb: PSB.ProcessStateBlock ¬ GetPSB[prev, world];      IF psb.link.next = psbi THEN {	IF dest # NIL THEN {	  this: PSB.ProcessStateBlock ¬ GetPSB[psbi, world];	  newQueue: PSB.Queue;	  WorldVMOps.CopyRead[world: world, from: dest, to: @newQueue, nwords: SIZE[PSB.Queue]];	  -- dequeue --	  psb.link.next ¬ this.link.next;	  IF queue.tail = psbi THEN queue.tail ¬ IF prev = psbi THEN PSB.PsbNull ELSE prev;	  -- enqueue --	  IF newQueue.tail = PSB.PsbNull THEN this.link.next ¬ newQueue.tail ¬ psbi	  ELSE {	    -- scan queue for correct priority position --	    tempPSBI: PSB.PsbIndex ¬ newQueue.tail;	    temp: PSB.ProcessStateBlock ¬ GetPSB[tempPSBI, world];	    IF temp.link.priority >= this.link.priority THEN newQueue.tail ¬ psbi	    ELSE -- search until we find the correct priority --	      DO 		next: PSB.ProcessStateBlock ¬ GetPSB[temp.link.next, world];		IF this.link.priority > next.link.priority THEN EXIT;		tempPSBI ¬ temp.link.next; temp ¬ next;		ENDLOOP;	    this.link.next ¬ temp.link.next;	    temp.link.next ¬ psbi;	    WorldVMOps.CopyWrite[world: world, from: @temp, to: PsbAddr[world, tempPSBI], nwords: SIZE[PSB.ProcessStateBlock]]};	  -- copy back --	  WorldVMOps.CopyWrite[world: world, from: @psb, to: PsbAddr[world, prev], nwords: SIZE[PSB.ProcessStateBlock]];	  WorldVMOps.CopyWrite[world: world, from: @this, to: PsbAddr[world, psbi], nwords: SIZE[PSB.ProcessStateBlock]];	  WorldVMOps.CopyWrite[world: world, from: @queue, to: queueHandle, nwords: SIZE[PSB.Queue]];	  WorldVMOps.CopyWrite[world: world, from: @newQueue, to: dest, nwords: SIZE[PSB.Queue]]; };	RETURN[TRUE] };      prev ¬ psb.link.next;      IF prev = tail THEN RETURN[FALSE];      ENDLOOP;    RETURN[FALSE] }; -- actually, the queue is thoroughly mangled! --  GetPSB: PROC[psbi: PSB.PsbIndex, world: WorldVM.World, abort: BOOL ¬ FALSE] RETURNS[PSB.ProcessStateBlock] = INLINE {    IF world = local THEN {      IF abort THEN PSB.PDA.block[psbi].flags.abort ¬ TRUE;      RETURN[ PSB.PDA.block[psbi] ] }    ELSE RETURN[ GetRemotePSB[psbi, world, abort] ]};      GetRemotePSB: PROC[psbi: PSB.PsbIndex, world: WorldVM.World, abort: BOOL] RETURNS[psb: PSB.ProcessStateBlock] = {    psbAddr: WorldVMOps.Address = PsbAddr[world, psbi];    WorldVMOps.CopyRead[world: world, from: psbAddr, to: @psb, nwords: SIZE[PSB.ProcessStateBlock]];    IF abort THEN {      psb.flags.abort ¬ TRUE;      WorldVMOps.CopyWrite[world: world, from: @psb, to: psbAddr, nwords: SIZE[PSB.ProcessStateBlock]]}};  PsbAddr: PROC[world: WorldVM.World, psbi: PSB.PsbIndex] RETURNS[ WorldVMOps.Address] = {     RETURN[LOOPHOLE[PSB.PDA, WorldVMOps.Address] + psbi*SIZE[PSB.ProcessStateBlock]]};  Thaw: PUBLIC PROC[world: WorldVM.World, process: AMProcessBasic.Process] = {    psbi: PSB.PsbIndex = WorldVMOps.ProcessShort[process];    processFrame: PrincOps.LocalFrameHandle;    restOfStack: PrincOps.ShortControlLink;    Set[psbi];    restOfStack ¬ GetFreezee[world, psbi];    IF restOfStack.frame # NIL THEN {      processFrame ¬ InfoFromPSB[world, psbi, FALSE].processFrame; --locks world      Unfreeze[world, psbi, processFrame, restOfStack]}; --unlocks world    Clear[psbi] };  Unfreeze: PROC[world: WorldVM.World, psbi: PSB.PsbIndex, processFrame: PrincOps.LocalFrameHandle, restOfStack: PrincOps.ShortControlLink] = {    -- On entry process and world are locked.  On exit, only process is locked. --    freezeTrap: PrincOps.LocalFrameHandle = Freezer[world];    IF processFrame = freezeTrap THEN {      SetPsbFrame[world, psbi, restOfStack.frame];      [] ¬ OnQueue[world: world, psbi: psbi, queueHandle: freezeQueue, remove: TRUE] }    ELSE {      tail: PrincOps.LocalFrameHandle ¬ processFrame;      DO         next: PrincOps.LocalFrameHandle = GetLink[world, tail].frame;	IF next = freezeTrap THEN EXIT;	tail ¬ next;	ENDLOOP;      SetLink[world, tail, restOfStack] };    Unlock[world];    SetFreezee[world, psbi, PrincOpsExtras.nullShortLink] };    LockFilter: PROC[filter: AMProcessBasic.GFTable] = {    IF filter # NIL THEN {      base: Environment.PageNumber = Environment.PageFromLongPointer[filter];      top: Environment.PageNumber = Environment.PageFromLongPointer[filter + SIZE[AMProcessBasic.GFTableObject[filter.max]]-1];      VM.MakeResident[[page: base, count: top-base+1], wait] }};    UnlockFilter: PROC[filter: AMProcessBasic.GFTable] = {    IF filter # NIL THEN {      base: Environment.PageNumber = Environment.PageFromLongPointer[filter];      top: Environment.PageNumber = Environment.PageFromLongPointer[filter + SIZE[AMProcessBasic.GFTableObject[filter.max]]-1];      VM.MakeSwappable[[page: base, count: top-base+1]] }};    ApplyFilter: PROC[world: WorldVM.World, link: PrincOps.ShortControlLink, filter: AMProcessBasic.GFTable, stopAt: PrincOpsExtras2.ControlLink]    RETURNS[frame, prevFrame: PrincOps.LocalFrameHandle] = INLINE {    -- "filter" is resident; world is locked. --    -- "frame" ¬ the first frame whose global frame inside the filter     -- (or NIL if no such frame).    -- If "frame" is not NIL and not "processFrame",     -- prevFrame ¬ frame with returnlink "frame".    frame ¬ link.frame;    IF filter = NIL THEN RETURN;    IF world = local    THEN DO      IF stopAt = [frame[frame]] THEN EXIT;      IF AddrBad[frame] OR AddrBad[WorldVMOps.GFlong[world, Frame.ReadGlobalLink[frame]]] THEN { frame ¬ NIL; EXIT };      FOR i: CARDINAL IN [0..filter.count) DO 	IF WorldVMOps.GFlong[world, Frame.ReadGlobalLink[frame]] = filter[i] THEN GOTO found 	ENDLOOP;      IF Frame.ReadReturnLink[frame].frame = NIL OR Frame.ReadReturnLink[frame].proc THEN { frame ¬ NIL; EXIT };      prevFrame ¬ frame; frame ¬ Frame.ReadReturnLink[frame].frame;      REPEAT found => NULL      ENDLOOP    ELSE [frame, prevFrame] ¬ ApplyRemoteFilter[world, link, filter, stopAt] };      ApplyRemoteFilter: PROC[world: WorldVM.World, link: PrincOps.ShortControlLink, filter: AMProcessBasic.GFTable, stopAt: PrincOpsExtras2.ControlLink]    RETURNS[frame, prevFrame: PrincOps.LocalFrameHandle] = {    frame ¬ link.frame;    DO ENABLE WorldVMOps.AddressFault => { frame ¬ NIL; EXIT };      fHeader: PrincOps.LocalOverhead;      IF stopAt = [frame[frame]] THEN EXIT;      WorldVMOps.CopyRead[world: world, from: WorldVMOps.LFlong[world, frame], to: @fHeader, nwords: SIZE[PrincOps.LocalOverhead]];      FOR i: CARDINAL IN [0..filter.count) DO         IF fHeader.globallink = filter[i] THEN GOTO found 	ENDLOOP;      IF fHeader.returnlink.frame = NIL OR fHeader.returnlink.proc THEN { frame ¬ NIL; EXIT };      prevFrame ¬ frame; frame ¬ fHeader.returnlink.frame;      REPEAT found => NULL      ENDLOOP };      zTrapME: Mopcodes.op = 176B;  zTrapMRE: Mopcodes.op = 177B;      Dequeue: PROC[world: WorldVM.World, psbi: PSB.PsbIndex, frame: PrincOps.LocalFrameHandle] = {    -- Only implemented for world = local --    style: { ME, MRE };    op, trap: Mopcodes.op;    queue: LONG POINTER TO PSB.Queue;    code: LONG POINTER;    pc: PrincOps.BytePC;    DO       code ¬ WorldVMOps.CodebaseFromGf[world, WorldVMOps.GFlong[world, Frame.ReadGlobalLink[frame]]];      pc ¬ [Frame.ReadPC[frame]-1];      op ¬ WorldVMOps.ReadCodeByte[world, code, pc];      SELECT op FROM	Mopcodes.zME => { style ¬ ME; trap ¬ zTrapME };	ESCAlpha.aMR => { style ¬ MRE; trap ¬ zTrapMRE };	ESCAlpha.aMW => {	  style ¬ MRE;	  trap ¬ zTrapMRE;	  THROUGH [1..1000] DO 	    pc ¬ [pc + OpcodeLengths[op]]; 	    op ¬ WorldVMOps.ReadCodeByte[world, code, pc]; 	    IF op = ESCAlpha.aMR THEN EXIT;	    REPEAT FINISHED => ERROR	    ENDLOOP};        zTrapME, zTrapMRE => { 	  Process.Pause[1]; 	  LOOP --obscure: some other process being patched at same place--};        ENDCASE => { 	  Clear[psbi]; RETURN }; -- process will become ready by itself --      IF WVMPatch.Patch[world: LOOPHOLE[world], addr: code, pc: pc, op: trap] = op THEN EXIT;      -- otherwise, someone else is patching, so look again! --      ENDLOOP;    -- call copy of victim's frame, to evaluate queue pointers --    BEGIN    newFrame: PrincOps.LocalFrameHandle;    state: PrincOps.StateVector;    fsi: PrincOps.FSIndex ¬ Frame.ReadLocalWord[frame].fsi;    size: CARDINAL;    IF fsi >= PrincOps.LargeReturnSlot THEN { ERROR;       «size ¬ LOOPHOLE[frame-2, POINTER TO CARDINAL]^;      FOR i: PrincOps.FrameSizeIndex IN PrincOps.FrameSizeIndex DO 	IF size <= PrincOps.FrameVec[i] THEN { newFrame ¬ PrincOpsUtils.Alloc[fsi ¬ i]; EXIT };	REPEAT FINISHED => ERROR	ENDLOOP;» }    ELSE { size ¬ PrincOps.FrameVec[fsi]; newFrame ¬ Frame.Alloc[fsi] };    Inline.LongCOPY[from: frame, to: newFrame, nwords: PrincOps.FrameVec[fsi]];    Frame.WriteReturnLink[[frame[Frame.MyLocalFrame[]]], newFrame];    BEGIN    cl: PrincOpsExtras2.ControlLink ¬ [frame[newFrame]];    IF style = ME THEN LOOPHOLE[cl, PROC[BOOL]][FALSE] ELSE LOOPHOLE[cl, PROC][];    END;    state ¬ STATE;    SELECT TRUE FROM      (style = ME AND state.stkptr = 1) =>        queue ¬ LOOPHOLE[state.stk[0],POINTER];      (style = MRE AND state.stkptr = 2) =>        queue ¬ LOOPHOLE[state.stk[1],POINTER];      (style = ME AND state.stkptr = 2) =>        queue ¬ LOOPHOLE[	  Environment.Long[	    num[lowbits: state.stk[0], highbits: state.stk[1]]]];      (style = MRE AND state.stkptr = 4) =>        queue ¬ LOOPHOLE[	  Environment.Long[	    num[lowbits: state.stk[2], highbits: state.stk[3]]]];      ENDCASE => ERROR;    -- Beware if the queue should be in the victim's local frame! --    BEGIN    queueCard: LONG CARDINAL = LOOPHOLE[queue];    frameBase: LONG CARDINAL = LOOPHOLE[LONG[newFrame]];    IF queueCard > frameBase AND queueCard <= frameBase + size    THEN queue ¬ queue - frameBase + LOOPHOLE[LONG[frame],LONG CARDINAL];    END;    END;    -- remove the tangle trap --    IF WVMPatch.Patch[world: LOOPHOLE[world], addr: code, pc: pc, op: op] # trap THEN ERROR;    -- Transfer the process to the ready list if it's still on the queue --    BEGIN    handle: PSB.PsbHandle = ProcessOperations.IndexToHandle[psbi];    queuePage: Environment.PageNumber = LOOPHOLE[queue, LONG CARDINAL] / Environment.wordsPerPage;    THROUGH [1..50] -- garbage check --      DO [] ¬ queue^; -- queue may be non-resident --      ProcessOperations.DisableInterrupts[];      IF PageMap.IsVacant[queuePage] THEN EXIT;      ProcessOperations.EnableInterrupts[];      REPEAT FINISHED => ERROR      ENDLOOP;    -- now disabled, with queue swapped in --    IF OnQueue[world, psbi, queue] THEN {      ProcessOperations.EnableInterrupts[];      ProcessOperations.Requeue[queue, @PSB.PDA.ready, handle]}    ELSE ProcessOperations.EnableInterrupts[];    END } --Dequeue--;  AbortFrame: PROC RETURNS[ PrincOps.LocalFrameHandle ] = {    state: RECORD[a, b: UNSPECIFIED, v: PrincOps.StateVector];    psbi: PSB.PsbIndex;    sourceDest: PrincOpsExtras.SourceDest;    Caller: PROC[PrincOps.LocalFrameHandle] = LOOPHOLE[PrincOpsExtras2.ControlLink[frame[Frame.GetReturnFrame[]]]];    Caller[Frame.MyLocalFrame[]];    -- execution resumes in the victim process --    state.v ¬ STATE;    psbi ¬ ProcessOperations.HandleToIndex[ProcessOperations.ReadPSB[]];    Wait[psbi];    -- now the initiating process has finished with the victim's frames --    IF PSB.PDA.block[psbi].flags.abort THEN {      -- now read trapee's op-code, to distinguish ME from MRE --      caller: PrincOps.LocalFrameHandle = Frame.GetReturnFrame[];      cb: PrincOps.PrefixHandle = WorldVMOps.CodebaseFromGf[local, WorldVMOps.GFlong[local, Frame.ReadGlobalLink[caller]]];      pc: PrincOps.BytePC = [Frame.ReadPC[caller]-1];      op: Mopcodes.op = WorldVMOps.ReadCodeByte[local, cb, pc];      -- In the ME case, we handle aborted; otherwise MRE handles it --      IF op = Mopcodes.zME OR op = zTrapME      THEN { PSB.PDA.block[psbi].flags.abort ¬ FALSE; ERROR ABORTED }};    sourceDest.dest.frame ¬ Frame.GetReturnFrame[];    sourceDest.source ¬ PrincOpsExtras.nullShortLink;    STATE ¬ state.v;    RETURN WITH sourceDest };      SRecord: TYPE = RECORD[sourceDest: PrincOpsExtras.SourceDest, v: PrincOps.StateVector];  TrapME: PROC = {    state: SRecord;    state.v ¬ STATE;    state.v.instbyte ¬ Mopcodes.zME;    Trap[@state];    STATE ¬ state.v;    RETURN WITH state.sourceDest };  TrapMRE: PROC = {    state: SRecord;    state.v ¬ STATE;    state.v.instbyte ¬ ESCAlpha.aMR;    Trap[@state];    STATE ¬ state.v;    RETURN WITH state.sourceDest };  Trap: PROC[s: POINTER TO SRecord] = INLINE {    -- MUST be INLINE, since it assumes it's in the trap handler's local frame --    trapee: PrincOps.LocalFrameHandle = Frame.GetReturnFrame[];    IF Frame.ReadGlobalLink[Frame.ReadReturnLink[trapee].frame] = Frame.MyGlobalFrame[] THEN {      s.v.instbyte ¬ 0;      s.sourceDest.dest.frame ¬ Frame.ReadReturnLink[trapee].frame;      Frame.Free[trapee] }    ELSE s.sourceDest.dest.frame ¬ trapee };  OpcodeLengths: PACKED ARRAY [0..255] OF [0..3] = [     -- copied from Traps.mesa    1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,    1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,2,1,2,1,1,1,2,1,1,2,2,1,1,0,0,    1,1,2,1,2,1,2,1,2,1,2,2,2,2,2,1,2,2,2,1,1,1,1,2,2,1,2,2,2,2,2,2,    2,2,2,2,2,2,3,2,3,1,3,3,2,3,3,2,2,2,3,3,1,2,2,2,2,2,2,1,2,0,0,0,    2,1,1,1,1,1,1,1,2,3,2,2,3,2,2,3,2,2,2,2,2,2,2,2,1,1,2,1,1,2,2,2,    3,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,2,1,1,1,0,    1,1,1,1,1,1,1,1,1,1,1,1,1,2,3,2,2,1,1,1,1,1,1,1,2,3,1,1,2,3,3,1,    1,1,1,1,1,1,1,1,1,1,1,1,2,3,1,1,2,1,1,1,1,1,1,1,2,3,0,0,0,0,0,1];    Abort: PUBLIC PROC[world: WorldVM.World, process: AMProcessBasic.Process] = {    psbi: PSB.PsbIndex = WorldVMOps.ProcessShort[process];    state: AMProcessBasic.State;    frozen: BOOL;    processFrame: PrincOps.LocalFrameHandle;    trapFrame: PrincOps.LocalFrameHandle = AbortFrame[];    -- lock out anyone else from modifying victim process --    Set[psbi];    [frozen: frozen, state: state, processFrame: processFrame] ¬ InfoFromPSB[world, psbi, FALSE ! UNWIND => Frame.Free[trapFrame]];    IF state = dead THEN { Frame.Free[trapFrame]; RETURN };    -- now, world and psbi are locked --    [] ¬ GetPSB[psbi, world, TRUE];    IF frozen OR world # local THEN { Unlock[world]; Frame.Free[trapFrame] }    ELSE {      ENABLE UNWIND => Clear[psbi];      SetPsbFrame[world, psbi, trapFrame];      Frame.WriteReturnLink[[frame[processFrame]], trapFrame];      PSB.PDA.block[psbi].timeout ¬ PSB.NoTimeout;      Unlock[world];      IF (state = waitingCV OR  state = waitingML) AND NOT frozen THEN Dequeue[world, psbi, processFrame] };    -- world is unlocked and process has been requeued from any CV or ML queue --    Clear[psbi] };  ReturnLink: PUBLIC PROC[world: WorldVM.World, frame: LFHandle, process: AMProcessBasic.Process ¬ AMProcessBasic.NullProcess]     RETURNS[link: AMProcessBasic.ControlLink] = {    psbi: PSB.PsbIndex = WorldVMOps.ProcessShort[process];    ERROR NotImplemented };  freezerAddr: POINTER TO PrincOps.LocalFrameHandle = LOOPHOLE[@(SDDefs.SD[205B])];  freezeesAddr: POINTER TO LONG POINTER TO Freeze.Frozen = LOOPHOLE[@(SDDefs.SD[206B])];    GetFreezee: PROC[world: WorldVM.World, psbi: PSB.PsbIndex] RETURNS[PrincOps.ShortControlLink] = {     RETURN[      IF world = local THEN Freeze.freezeesTable[psbi]      ELSE LOOPHOLE[WorldVMOps.Read[world, Freezees[world, psbi]]]] };    SetFreezee: PROC[world: WorldVM.World, psbi: PSB.PsbIndex,     freezee: PrincOps.ShortControlLink] = {     WorldVMOps.Write[world, Freezees[world, psbi], freezee]};    Freezees: PROC[world: WorldVM.World, psbi: PSB.PsbIndex] RETURNS[WorldVMOps.Address] = {    freezees: LONG POINTER TO Freeze.Frozen = WorldVMOps.LongRead[world, WorldVMOps.Long[world, freezeesAddr]];     RETURN[@freezees[psbi]]};    Freezer: PROC[world: WorldVM.World] RETURNS[PrincOps.LocalFrameHandle] = {    RETURN[      IF world = local THEN Freeze.freezer      ELSE WorldVMOps.Read[world, WorldVMOps.Long[world, freezerAddr]]]};    GetLink: PROC[world: WorldVM.World, frame: PrincOps.LocalFrameHandle] RETURNS[PrincOps.ShortControlLink] = INLINE {    RETURN[      IF world = local THEN Frame.ReadReturnLink[frame]      ELSE GetRemoteLink[world, frame]]};  GetRemoteLink: PROC[world: WorldVM.World, frame: PrincOps.LocalFrameHandle] RETURNS[PrincOps.ShortControlLink] = {    fHeader: PrincOps.LocalOverhead;    WorldVMOps.CopyRead[world: world,      from: WorldVMOps.Long[world, frame - SIZE[PrincOps.LocalOverhead]],      to: @fHeader,      nwords: SIZE[PrincOps.LocalOverhead]];    RETURN[fHeader.returnlink] };  SetLink: PROC[world: WorldVM.World, frame: PrincOps.LocalFrameHandle, link: PrincOps.ShortControlLink] = INLINE {     IF world = local THEN Frame.WriteReturnLink[link, frame]     ELSE SetRemoteLink[world, frame, link]};  SetRemoteLink: PROC[world: WorldVM.World, frame: PrincOps.LocalFrameHandle, link: PrincOps.ShortControlLink] = {    fHeader: PrincOps.LocalOverhead;    WorldVMOps.CopyRead[world: world,      from: WorldVMOps.Long[world, frame - SIZE[PrincOps.LocalOverhead]],      to: @fHeader,      nwords: SIZE[PrincOps.LocalOverhead]];    fHeader.returnlink ¬ link;    WorldVMOps.CopyWrite[world: world,      from: @fHeader,      to: WorldVMOps.Long[world, frame - SIZE[PrincOps.LocalOverhead]],      nwords: SIZE[PrincOps.LocalOverhead]] };  SetPsbFrame: PROC[world: WorldVM.World, psbi: PSB.PsbIndex, trapFrame: PrincOps.LocalFrameHandle] = INLINE {    IF world = local THEN {      IF PSB.PDA.block[psbi].link.preempted -- context is state vector      THEN PSB.PDA[PSB.PDA.block[psbi].context.state].frame ¬ LOOPHOLE[trapFrame]      ELSE PSB.PDA.block[psbi].context.frame ¬ trapFrame }    ELSE SetRemotePsbFrame[world, psbi, trapFrame] };  SetRemotePsbFrame: PROC[world: WorldVM.World, psbi: PSB.PsbIndex, trapFrame: PrincOps.LocalFrameHandle] = {    psb: PSB.ProcessStateBlock ¬ GetPSB[psbi, world];    IF psb.link.preempted -- context is state vector -- THEN {      stateAddr: WorldVMOps.Address = LOOPHOLE[PSB.PDA, WorldVMOps.Address] + LOOPHOLE[psb.context.state, CARDINAL];      state: PrincOps.StateVector;      WorldVMOps.CopyRead[world: world, from: stateAddr, to: @state, nwords: SIZE[PrincOps.StateVector] ];      state.frame ¬ LOOPHOLE[trapFrame];      WorldVMOps.CopyWrite[world: world, from: @state, to: stateAddr, nwords: SIZE[PrincOps.StateVector] ]; }    ELSE {      psb.context.frame ¬ trapFrame;      WorldVMOps.CopyWrite[world: world, from: @psb, to: PsbAddr[world, psbi],      nwords: SIZE[PSB.ProcessStateBlock] ];};};    -- Synchronisation --    untangling: LONG POINTER TO PACKED ARRAY PSB.PsbIndex OF BOOLEAN = zone.NEW[PACKED ARRAY PSB.PsbIndex OF BOOLEAN ¬ ALL[FALSE]];    finishedUntangling: CONDITION ¬ [timeout:0];    Set: ENTRY PROC[psbi: PSB.PsbIndex] = INLINE {    WHILE untangling[psbi] DO WAIT finishedUntangling ENDLOOP;     untangling[psbi] ¬ TRUE };    Wait: ENTRY PROC[psbi: PSB.PsbIndex] = INLINE {    WHILE untangling[psbi] DO WAIT finishedUntangling ENDLOOP };    Clear: ENTRY PROC[psbi: PSB.PsbIndex] = INLINE {    untangling[psbi] ¬ FALSE; BROADCAST finishedUntangling };    -- Access to client memory with client stopped --  local: WorldVM.World = WorldVM.LocalWorld[];    Lock: PROC[world: WorldVM.World] = {    IF world = local THEN ProcessOperations.DisableInterrupts[]    ELSE WorldVM.Lock[world] };    Unlock: PROC[world: WorldVM.World] = INLINE {    IF world = local THEN ProcessOperations.EnableInterrupts[]    ELSE WorldVM.Unlock[world] };    AddrBad: PROC[addr: LONG UNSPECIFIED] RETURNS[BOOL] = INLINE {     IF Inline.HighHalf[addr] >= Environment.wordsPerPage THEN RETURN[TRUE];    RETURN[ PageMap.IsVacant[addr/Environment.wordsPerPage]] };  -- can't imagine residency making any difference  -- SpecialSpace.MakeProcedureResident[LOOPHOLE[Info]];  -- SpecialSpace.MakeProcedureResident[Dequeue];  -- TrapSupport.opTrapTable.main[zTrapME] ¬ LOOPHOLE[TrapME];  -- TrapSupport.opTrapTable.main[zTrapMRE] ¬ LOOPHOLE[TrapMRE];    }.. -- AMProcessBasicImpl
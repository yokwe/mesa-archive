-- SwordLowLevel.docThis document describes how Sword uses various low level facilities of Pilot and the Mesa architecture. Contents: a. The debugger fielderb. Manipulation of interruptsc. Access to framesd. Manipulation of processese. Manipulation of breakpointsf. Pilot and Tajo supporta. The debugger fielder in PilotNub is a port which awaits debugger requests. Interrupts must have been disabled by the caller. It saves the fault handlers, saves any processor state which resides in registers, turns off devices, and then does an outload (or goes to 915). There is an interface which allows the fielder to be changed. Sword's fielder is a port which first checks whether the local debugger can field the request. If not, control is passed to the PilotNub fielder. The local debugger cannot field the request if procedure calls have been disallowed, if a request of this type cannot be handled locally (for instance, a "bug"), if the user has specified that he does not wish a request of this type to be handled locally, or if the user has added the module in which the event occurred to the filter. If the local debugger can field the request, then the fielder is reset to the PilotNub fielder, interrupts are enabled, and control passes to a callback procedure in Sword (see RuntimeErrorImpl.mesa). The fielder accesses the following resident data: the code and local frame of the fielder, the global frame of RuntimeErrorImpl, and the external state vector. The fielder has a small window of vulnerability when the filter is being changed, but that is unlikely to cause deadlock. Sword assumes it is the only client calling SetDebuggerFielder!Note: «An error in Pilot kernel e.g. signal BoundsFault "should" be passed to the world swap debugger because the kernel may not be healthy enough to support Sword. There is a tradeoff here: there is no algorithmic way to decide if the kernel is healthy enough to support Sword, even if the problem is "inside" pilot kernel. But it would be nice to have a "sanity" component of the filter.I think Cedar had a filter that decided if the problem was in the operating system or in the "client". If we do not have such a filter, Pilot problems may trash Sword's world in various ways.One slightly sleazy way way to do a cheap filter is to figure out (at runtime) the module table index corresponding to the end of PilotKernel (doesn't have to be exact) and only handle problems not in the kernel. This works because PilotKernel is loaded first, and is first in the config and module tables. You can deduce the threshold mti from some strategically chosen exported procedure, I think. The filter might have to smartened up to handle traps and signals, which both apparently occur inside the kernel.It's tough to implement even the "cheap filter", because the check would have to look at unpinned data (global frame of the crash), to get the loadstate module table index. Also, as you say it's very tough to know which situations to let go: traps and signals I think should be handled, Bugs must world-swap, and I'm not sure about address faults or breakpoints.The lack of a sanity filter hasn't been a problem yet, but it may gain prominence when the Pilot people start trying to use same world debugging.» b. Manipulation of interrupts. In the debugger fielder, interrupts are enabled just before the callback to a local handler, and disabled when the callback returns. It is guaranteed that no faults will occur while interrupts are disabled (see RuntimeErrorImpl.mesa). In the process freezer, interrupts are disabled while the return links and the freezeTable are being accessed.c. Access to frames is not controlled. Although it is easy to imagine scenarios where the user could be burned, in practice it has not been necessary to freeze processes before the debugger accesses local frames. There are several reasons for this: the debugger caches memory data, users understand the volatility of local frames, and a crashed process is effectively frozen. I have not yet seen a debugger crash that occurred because a user accessed transient local frame data. Another reason we can usually get away with unsynchronized frame access is that the storage for most frames is permanently allocated in memory. The only thing that can change dynamically is who is using them and their data content. However, large frames are dynamically allocated (real and virtual memory) and Sword could address fault while accessing a large frame that some other process simultaneously deallocated. If this becomes a serious problem, a check could be put into the procedures which access large local frames; they could run through the largeFrameList and check that the frame is still mapped.d. Manipulation of processes (see FreezeImpl.mesa and AMProcessBasicImpl.mesa). Freezing and thawing processes are described below.There is a fixed frame procedure "FreezingPoint", aka the freezer, waiting to field all "freeze me" requests. It runs with interrupts disabled. When a freeze request arrives, a return link to the freezer is placed in the stack of the process, at a client specified frame. The old return link is placed in the freezeesTable, which has a spot for each process that might be frozen. The process is then left to run. When it reaches the return link to the freezer, the freezer allocates an instance of the procedure "FreezeTrapFrame", which holds the state of the process. The FreezeTrapFrame sets its own return link to the the link stored in the freezeesTable, then puts its own frame into the freezeesTable. The process is requeued from the ready queue to the "freeze queue".To thaw the process, then, is just a matter of requeuing the process from the freeze queue to the ready queue. When the process runs, FreezeTrapFrame restores the state, and control transfers to the process. The freezer is put into SDDefs.SD[205B] and the freezeesTable is put into SDDefs.SD[206B] for non-local debugger access (also maybe for microcode access).e. Manipulation of breakpoints. A breakpoint handler is inserted into SDDefs.SD, and the old breakpoint handler saved. When a breakpoint occurs, the debugger checks whether it owns the breakpoint. If so, it handles the breakpoint, else it calls the old breakpoint handler (see AMEventsImplA.mesa).f. Pilot and Tajo support. There are several features which would make same world debugging safer:1. An atomic operation that tells whether a virtual address is mapped (I maintain that there is a bug in Space.GetMapUnitAttributes such that it returns incorrect information). More generally, Pilot might provide a way to do:   BEGIN critical region   IF pointer mapped THEN access page containing pointer   END critical region2. A cleaner way to let users handle events in PilotNub.3. The window system should use monitored records instead of monitors.
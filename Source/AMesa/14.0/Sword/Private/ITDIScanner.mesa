-- Copyright (C) 1985  by Xerox Corporation. All rights reserved. -- ITDIScanner.mesaDIRECTORY  Ascii USING [NUL, ControlZ, CR],  ITDIGrammar USING [],  ITDIParseTable USING [    endmarker, HashTableRef, IndexTableRef, ScanTableRef, TableRef,     -- tokenCARD, tokenLCARD,     tokenCHAR, tokenDOT, tokenDOTS, tokenFLNUM,     tokenGE, tokenGREATER, tokenID,     tokenLE, tokenLESS, tokenLNUM, tokenNUM, tokenSTR, TSymbol, VocabularyRef],  Environment,  Heap,  LiteralOps,  IO, IS, IT,  String USING [SubStringDescriptor],  Real USING [RealException, PairToReal],  Runtime USING [GlobalFrame, GetTableBase],  SymbolOps USING [EnterString];ITDIScanner: PROGRAM   IMPORTS ITDIGrammar, Heap, LiteralOps, Real, Runtime, SymbolOps   EXPORTS IO, IS =  BEGIN OPEN ITDIParseTable, IT;    InvalidCharacter: PUBLIC SIGNAL [index: CARDINAL] = CODE;  InvalidNumber: PUBLIC SIGNAL [f: Foo] = CODE;  Atom: PUBLIC PROCEDURE[h: Handle] RETURNS [symbol: Token] =    BEGIN OPEN symbol;    first, last: CHARACTER;    uId: BOOLEAN;    i, j, k: CARDINAL;    s1, s2: CARDINAL;    DO      WHILE h.char IN [Ascii.NUL..' ] DO        SELECT h.char FROM          Ascii.ControlZ =>            DO              SELECT GetChar[h] FROM                Ascii.NUL => GOTO EndFile;                Ascii.CR => EXIT;                ENDCASE;              ENDLOOP;          Ascii.NUL => GOTO EndFile;          ENDCASE;        h.char ¬ GetChar[h];        ENDLOOP;      index ¬ h.charIndex;  value ¬ 0;      SELECT h.char FROM	'a, 'b, 'c, 'd, 'e, 'f, 'g, 'h, 'i, 'j, 'k, 'l, 'm,	'n, 'o, 'p, 'q, 'r, 's, 't, 'u, 'v, 'w, 'x, 'y, 'z, '_  =>          BEGIN          h.desc.offset ¬ index;          i ¬ 0;          DO            h.char ¬ GetChar[h];            SELECT h.char FROM              IN ['a..'z], IN ['A..'Z], IN ['0..'9], '_ => i ¬ i+1;              ENDCASE =>  EXIT;            ENDLOOP;          h.desc.length ¬ i+1;          class ¬ tokenID;          value ¬ SymbolOps.EnterString[h.sym, @h.desc];  EXIT          END;	'A, 'B, 'C, 'D, 'E, 'F, 'G, 'H, 'I, 'J, 'K, 'L, 'M,	'N, 'O, 'P, 'Q, 'R, 'S, 'T, 'U, 'V, 'W, 'X, 'Y, 'Z =>          BEGIN          h.desc.offset ¬ index;          i ¬ 0;  uId ¬ TRUE;  first ¬ last ¬ h.char;          DO            h.char ¬ GetChar[h];            SELECT h.char FROM              IN ['A..'Z] =>                BEGIN  last ¬ h.char;                i ¬ i+1;                END;              IN ['a..'z], IN ['0..'9], '_ =>                BEGIN  uId ¬ FALSE;                i ¬ i+1;                END;              ENDCASE =>  EXIT;            ENDLOOP;          i ¬ i+1;          IF uId THEN            BEGIN            k ¬ (LOOPHOLE[first, CARDINAL]*127 + LOOPHOLE[last, CARDINAL]) 	      MOD hashval + 1;            WHILE (j ¬ dHashTab[k].symbol) # 0 DO              IF dVocabIndex[j]-(s2¬dVocabIndex[j-1]) = i THEN                FOR s1 IN [index .. index+i) DO                  IF h.text[s1] # vocab.text[s2] THEN EXIT;                  s2 ¬ s2+1;                  REPEAT                    FINISHED => GO TO reserved;                  ENDLOOP;              IF (k ¬ dHashTab[k].link) = 0 THEN EXIT;              ENDLOOP;            END;          h.desc.length ¬ i;          class ¬ tokenID;          value ¬ SymbolOps.EnterString[h.sym, @h.desc];  EXIT          EXITS            reserved =>  BEGIN  class ¬ j;  EXIT  END;          END;        '0, '1, '2, '3, '4, '5, '6, '7, '8, '9  =>	  BEGIN	  valid: BOOLEAN;	  [class, value, valid] ¬ CollectNumber[h: h, i: 0];	  IF ~valid THEN SIGNAL InvalidNumber[LOOPHOLE[LONG[index]]];	  EXIT	  END;        '' =>          BEGIN          h.char ¬ GetChar[h];          class ¬ tokenCHAR;          value ¬ LiteralOps.Find[h.sym, LOOPHOLE[h.char, CARDINAL]];          h.char ¬ GetChar[h];  EXIT          END;        '" =>          BEGIN          h.desc.offset ¬ index+1;          i ¬ 0;          DO             h.char ¬ GetChar[h];            IF h.char = Ascii.NUL THEN h.char ¬ '";            IF h.char = '" THEN              BEGIN h.char ¬ GetChar[h]; IF h.char # '" THEN EXIT; END;            i ¬ i+1;            ENDLOOP;          h.desc.length ¬ i;          class ¬ tokenSTR;          value ¬ LiteralOps.LitFindString[h.sym, @h.desc];  EXIT          END;        '. => {	  IF h.qDot THEN {	    h.qDot ¬ FALSE; class ¬ tokenDOTS; 	    h.char ¬ GetChar[h]; EXIT};          h.char ¬ GetChar[h];	  SELECT h.char FROM            '.  => {class ¬ tokenDOTS; h.char ¬ GetChar[h]};	    IN ['0..'9] => {	      valid: BOOLEAN;	      h.buffer[0] ¬ '.;	      [class, value, valid] ¬ CollectNumber[h: h, i: 1, float: TRUE];	      IF ~valid THEN SIGNAL InvalidNumber[LOOPHOLE[LONG[index]]];	      EXIT};            ENDCASE => class ¬ tokenDOT;          EXIT};	'< => {          h.char ¬ GetChar[h];	  IF h.char = '= THEN {class ¬ tokenLE; h.char ¬ GetChar[h]} 	  ELSE class ¬ tokenLESS;	  EXIT};	'> => {          h.char ¬ GetChar[h];	  IF h.char = '= THEN {class ¬ tokenGE; h.char ¬ GetChar[h]}	  ELSE class ¬ tokenGREATER;	  EXIT};	            ENDCASE =>          BEGIN	  SELECT h.char FROM -- chset 0 translations	    244C => h.char ¬ '$;	    255C => h.char ¬ '^;	    264C => h.char ¬ '*;	    270C => h.char ¬ '/;	    ENDCASE;	  class ¬ dScanTab[h.char];          h.char ¬ GetChar[h];          IF class # 0 THEN EXIT ELSE SIGNAL InvalidCharacter[index];          END;      REPEAT        EndFile =>  BEGIN  class ¬ endmarker;  value ¬ 0  END;      ENDLOOP;    RETURN    END; -- Character source  GetChar: PROCEDURE[h: Handle] RETURNS [c: CHARACTER] =    BEGIN     h.charIndex ¬ h.charIndex + 1;    SELECT h.charIndex FROM      < h.text.length => c ¬ h.text[h.charIndex];      = h.text.length => RETURN['\\];      ENDCASE => RETURN[Ascii.NUL];    -- SELECT currentChar FROM    SELECT h.char FROM      IN [40C..177C] => NULL;      IN [241C..377C] => NULL;      ENDCASE => SIGNAL InvalidCharacter[h.charIndex];    END; -- numerical conversion    LongLit: TYPE = LONG UNSPECIFIED;  endMark: CHARACTER = 0C;    CollectNumber: PROC [h: Handle, i: CARDINAL, float: BOOLEAN ¬ FALSE]      RETURNS [class: TSymbol, value: UNSPECIFIED, valid: BOOLEAN] = {    hexCount: CARDINAL ¬ 0;    hexSig: PACKED ARRAY CHARACTER['a..'h] OF {F, T} ¬ ALL[F];    v: LongLit;    forcedLong: BOOLEAN = (h.char = '0); -- treat as long if first character 0        Accept: PROC = INLINE {      h.buffer[i] ¬ h.char;      IF (i ¬ i+1) >= h.iMax THEN ERROR;      h.char ¬ GetChar[h]};     maxWord: LONG CARDINAL = LAST[Environment.Word];    class ¬ tokenLNUM;    DO      SELECT h.char FROM	IN ['0..'9] => Accept[];	'e, 'E => {	  hexSig['e] ¬ T; hexCount ¬ hexCount + 1;  Accept[];	  IF hexCount = 1 AND h.char = '+ OR h.char = '- THEN {	    float ¬ TRUE; Accept[]}};	IN ['a..'f] => {hexSig[h.char] ¬ T; hexCount ¬ hexCount+1;  Accept[]};	IN ['A..'F] => {	  hexSig[h.char+('a-'A)] ¬ T; hexCount ¬ hexCount+1;  Accept[]};	'h, 'H => {hexSig['h] ¬ T; hexCount ¬ hexCount+1;  Accept[]};	'. => {	  IF hexCount # 0 OR float THEN EXIT;	  h.char ¬ GetChar[h];	  IF h.char = '. THEN {h.qDot ¬ TRUE; EXIT};	  float ¬ TRUE;	  h.buffer[i] ¬ '.;	  IF (i ¬ i+1) >= h.iMax THEN ERROR};	ENDCASE => EXIT;      ENDLOOP;    h.buffer[i] ¬ endMark;    SELECT TRUE FROM      float => {class ¬ tokenFLNUM; [v, valid] ¬ ScanFloating[h, h.buffer]};      (hexSig['h] = T) => [v, valid] ¬ ScanHex[h, h.buffer];      ENDCASE =>	SELECT hexCount FROM	  0 => [v, valid] ¬ ScanDecimal[h, h.buffer];	  1 =>	    SELECT hexSig FROM	      [F,T,F,F,F,F,F,F] => [v, valid] ¬ ScanOctal[h, h.buffer];	      [F,F,T,F,F,F,F,F] => {		class ¬ tokenCHAR;		[v, valid] ¬ ScanOctalChar[h, h.buffer]};	      [F,F,F,T,F,F,F,F] => [v, valid] ¬ ScanDecimal[h, h.buffer];	      [F,F,F,F,T,F,F,F] => {		class ¬ tokenFLNUM;		[v, valid] ¬ ScanFloating[h, h.buffer]};	    ENDCASE => [v, valid] ¬ ScanHex[h, h.buffer];	  ENDCASE => [v, valid] ¬ ScanHex[h, h.buffer];    SELECT class FROM      tokenCHAR => value ¬ EnterLit[h, v, FALSE];      tokenFLNUM => value ¬ EnterLit[h, v];      ENDCASE =>	IF LOOPHOLE[v, LONG CARDINAL] > maxWord OR (forcedLong AND i > 1) THEN	  value ¬ EnterLit[h, v]	ELSE {class ¬ tokenNUM; value ¬ EnterLit[h, v, FALSE]};    RETURN};      Digit: ARRAY CHARACTER ['0..'9] OF CARDINAL = [0,1,2,3,4,5,6,7,8,9];  HexDigit: ARRAY CHARACTER ['A..'F] OF CARDINAL = [10,11,12,13,14,15];    AppendDecimal: PROC [h: Handle, v: LONG CARDINAL, digit: CHARACTER ['0..'9]]      RETURNS [newV: LONG CARDINAL, valid: BOOLEAN] = {    maxV: LONG CARDINAL = 429496729;	-- (2**32-1)/10    maxD: CARDINAL = 5;			-- (2**32-1) MOD 10    d: [0..9] = Digit[digit];    valid ¬ v < maxV OR (v = maxV AND d <= maxD);    newV ¬ 10*v + d;    RETURN};  AppendOctal: PROC [h: Handle, v: LONG CARDINAL, digit: CHARACTER ['0..'7]]      RETURNS [newV: LONG CARDINAL, valid: BOOLEAN] = {    maxV: LONG CARDINAL = 3777777777b;	-- (2**32-1)/8    d: [0..7] = Digit[digit];    valid ¬ (v <= maxV);    newV ¬ 8*v + d;    RETURN};  AppendHex: PROC [h: Handle, v: LONG CARDINAL, digit: CHARACTER ['0..'F]]      RETURNS [newV: LONG CARDINAL, valid: BOOLEAN] = {    maxV: LONG CARDINAL = 1777777777b;	-- (2**32-1)/16    d: [0..15] = IF digit IN ['0..'9] THEN Digit[digit] ELSE HexDigit[digit];    valid ¬ (v <= maxV);    newV ¬ 16*v + d;    RETURN};  AppendToScale: PROC [h: Handle, v: CARDINAL, digit: CHARACTER ['0..'9]]      RETURNS [newV: CARDINAL, valid: BOOLEAN] = {    maxV: CARDINAL = 6553;		-- (2**16-1)/10    maxD: CARDINAL = 5;			-- (2**16-1) MOD 10    d: [0..9] = Digit[digit];    valid ¬ v < maxV OR (v = maxV AND d <= maxD);    newV ¬ 10*v + d;    RETURN};      ValidFraction: PROC [h: Handle, v: LONG CARDINAL, digit: CHARACTER ['0..'9]]     RETURNS [BOOLEAN] = {    maxV: LONG CARDINAL = 214748364;	-- (2**31-1)/10    maxD: CARDINAL = 7;			-- (2**31-1) MOD 10    RETURN [v < maxV OR (v = maxV AND Digit[digit] <= maxD)]};   ScanDecimal: PROC [h: Handle, s: LONG STRING]     RETURNS [value: LongLit, valid: BOOLEAN ¬ TRUE] = {    c: CHARACTER;    i: CARDINAL ¬ 0;    v: LONG CARDINAL ¬ 0;    IF s[i] NOT IN ['0..'9] THEN valid ¬ FALSE;    WHILE (c ¬ s[i]) IN ['0..'9] DO      IF valid THEN [v, valid] ¬ AppendDecimal[h, v, c];      i ¬ i+1;      ENDLOOP;    IF c = 'd OR c = 'D THEN {      scale: CARDINAL ¬ 0;      WHILE (c ¬ s[i¬i+1]) IN ['0..'9] DO	IF valid THEN [scale, valid] ¬ AppendToScale[h, scale, c];	ENDLOOP;      THROUGH [1 .. scale] WHILE valid DO	[v, valid] ¬ AppendDecimal[h, v, '0] ENDLOOP};     IF c # endMark THEN valid ¬ FALSE;     value ¬ v;     RETURN};          ScanOctal: PROC [h: Handle, s: LONG STRING]     RETURNS [value: LongLit, valid: BOOLEAN ¬ TRUE] = {    c: CHARACTER;    i: CARDINAL ¬ 0;    v: LONG CARDINAL ¬ 0;    IF s[i] NOT IN ['0..'7] THEN valid ¬ FALSE;    WHILE (c ¬ s[i]) IN ['0..'7] DO      IF valid THEN [v, valid] ¬ AppendOctal[h, v, c];      i ¬ i+1;      ENDLOOP;    IF c = 'b OR c = 'B THEN {      scale: CARDINAL ¬ 0;      WHILE (c ¬ s[i¬i+1]) IN ['0..'9] DO	IF valid THEN [scale, valid] ¬ AppendToScale[h, scale, c];	ENDLOOP;      THROUGH [1 .. scale] WHILE valid DO	[v, valid] ¬ AppendOctal[h, v, '0] ENDLOOP};    IF c # endMark THEN valid ¬ FALSE;    value ¬ v;    RETURN};  ScanOctalChar: PROC [h: Handle, s: LONG STRING]     RETURNS [value: LongLit, valid: BOOLEAN¬TRUE] = {    c: CHARACTER;    maxChar: CARDINAL = 377b;    i: CARDINAL ¬ 0;    v: LONG CARDINAL ¬ 0;    IF s[i] NOT IN ['0..'7] THEN valid ¬ FALSE;    WHILE (c ¬ s[i]) IN ['0..'7] DO      IF valid THEN [v, valid] ¬ AppendOctal[h, v, c];      i ¬ i+1;      ENDLOOP;    IF c = 'c OR c = 'C THEN c ¬ s[i¬i+1] ELSE valid ¬ FALSE;    IF c # endMark OR v NOT IN [0 .. maxChar] THEN valid ¬ FALSE;    value ¬ v;    RETURN};  ScanHex: PROC [h: Handle, s: LONG STRING]     RETURNS [value: LongLit, valid: BOOLEAN¬TRUE] = {    c: CHARACTER;    i: CARDINAL ¬ 0;    v: LONG CARDINAL ¬ 0;    IF s[i] NOT IN ['0..'9] THEN valid ¬ FALSE;    DO      SELECT (c ¬ s[i]) FROM	IN ['0..'9], IN ['A..'F] =>          IF valid THEN [v, valid] ¬ AppendHex[h, v, c];	IN ['a..'f] =>          IF valid THEN [v, valid] ¬ AppendHex[h, v, c-('a-'A)];        ENDCASE => EXIT;      i ¬ i + 1;      ENDLOOP;    IF c = 'h OR c = 'H THEN {      scale: CARDINAL ¬ 0;      WHILE (c ¬ s[i¬i+1]) IN ['0..'9] DO        IF valid THEN [scale, valid] ¬ AppendToScale[h, scale, c];        ENDLOOP;      THROUGH [1 .. scale] WHILE valid DO	[v, valid] ¬ AppendHex[h, v, '0] ENDLOOP};    IF c # endMark THEN valid ¬ FALSE;    value ¬ v;    RETURN};  ScanFloating: PROC [h: Handle, s: LONG STRING]     RETURNS [value: LongLit, valid: BOOLEAN ¬ TRUE] = {    c: CHARACTER;    i: CARDINAL ¬ 0;    v: LONG CARDINAL ¬ 0;    exp: INTEGER ¬ 0;    WHILE (c ¬ s[i]) IN ['0..'9] DO      valid ¬ valid AND ValidFraction[h, v, c];      IF valid THEN v ¬ AppendDecimal[h, v, c].newV      ELSE exp ¬ exp + 1;	-- should round      i ¬ i+1;      ENDLOOP;    IF c = '. THEN {      i ¬ i+1;      IF s[i] NOT IN ['0..'9] THEN valid ¬ FALSE;      WHILE (c ¬ s[i]) IN ['0..'9] DO	valid ¬ valid AND ValidFraction[h, v, c];	IF valid THEN {[v, valid] ¬ AppendDecimal[h, v, c]; exp ¬ exp-1}	ELSE NULL;	-- should round	i ¬ i+1;	ENDLOOP};    valid ¬ TRUE;    IF c = 'e OR c = 'E THEN {      scale: INTEGER ¬ 0;      op: {plus, minus} ¬ plus;      i ¬ i + 1;      SELECT s[i] FROM        '+ => i ¬ i+1;        '- => {op ¬ minus; i ¬ i+1};        ENDCASE;      IF s[i] NOT IN ['0..'9] THEN valid ¬ FALSE;      WHILE (c ¬ s[i]) IN ['0..'9] DO	IF valid THEN [scale, valid] ¬ AppendToScale[h, scale, c];	i ¬ i+1;	ENDLOOP;      exp ¬ IF op = plus THEN exp + scale ELSE exp - scale}; --need overflow check    IF c # endMark THEN valid ¬ FALSE;    value ¬ Real.PairToReal[v, exp		! Real.RealException => {valid ¬ FALSE; RESUME[NIL]}];    RETURN};      EnterLit: PROC [h: Handle, v: LongLit, long: BOOLEAN ¬ TRUE]     RETURNS [UNSPECIFIED] = {    vRep: ARRAY [0..SIZE[LongLit]) OF WORD ¬ LOOPHOLE[v];    RETURN [IF long      THEN LiteralOps.FindDescriptor[h.sym, DESCRIPTOR[vRep]]      ELSE LiteralOps.Find[h.sym, vRep[0]]]};   -- initialization/finalization  ScanInit: PUBLIC PROC [h: Handle, string: LONG STRING] = {    h.desc.base ¬ h.text ¬ string;  h.desc.offset ¬ h.charIndex ¬ 0;     h.char ¬ h.text[0];    SELECT h.char FROM      IN [40C..177C] => NULL;      IN [241C..377C] => NULL;      ENDCASE => SIGNAL InvalidCharacter[h.charIndex];    IF h.buffer = NIL THEN h.buffer ¬ Heap.systemZone.NEW[StringBody[256]];    h.iMax ¬ h.buffer.length ¬ h.buffer.maxlength;    h.qDot ¬ FALSE};  ScanReset: PUBLIC PROC[h: Handle] RETURNS [BOOLEAN] = {    RETURN [h.charIndex >= h.text.length]};  dHashTab: ITDIParseTable.HashTableRef ¬ NIL;  dScanTab: ITDIParseTable.ScanTableRef ¬ NIL;  vocab: ITDIParseTable.VocabularyRef ¬ NIL;  dVocabIndex: ITDIParseTable.IndexTableRef ¬ NIL;  Init: PROC = {    table: ITDIParseTable.TableRef ¬         Runtime.GetTableBase[Runtime.GlobalFrame[ITDIGrammar]];    dHashTab ¬ @table[table.scanTable.hashTab];    dScanTab ¬ @table[table.scanTable.scanTab];    vocab ¬ @table[table.scanTable.vocabBody];    dVocabIndex ¬ @table[table.scanTable.vocabIndex]};    Init[];     END.
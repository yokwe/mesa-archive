-- Copyright (C) 1986  by Xerox Corporation. All rights reserved. -- SwordUsefulDefsImpl.mesaDIRECTORYAMUseful, Environment, Event,IO, IP, IQ, IT, IH, IZ,Supervisor,SwordUsefulDefs,Window,WorldVMOps,WorldVM;SwordUsefulDefsImpl: PROGRAM   IMPORTS AMUseful, Event, IO, IP, IQ, IH, IZ, Supervisor, WorldVMOps, WorldVM    EXPORTS SwordUsefulDefs = PUBLIC {    localWorld: PUBLIC WorldVM.World = WorldVM.LocalWorld[];  defaultWorld: PUBLIC WorldVM.World ¬ NIL;    GFHandle: TYPE = SwordUsefulDefs.GFHandle;  ClientSource: TYPE = SwordUsefulDefs.ClientSource;  LongClientSource: TYPE = SwordUsefulDefs.LongClientSource;  ClientDest: TYPE = SwordUsefulDefs.ClientDest;  LongClientDest: TYPE = SwordUsefulDefs.LongClientDest;  LocalSource: TYPE = SwordUsefulDefs.LocalSource;  LocalDest: TYPE = SwordUsefulDefs.LocalDest;  ITHandle: TYPE = LONG POINTER TO ITObject;  ITObject: PUBLIC TYPE = IT.Object;    SetDefaultWorld: PROC[world: WorldVM.World] = {    defaultWorld ¬ world };    InterpreterAvailable: PROC[world: WorldVM.World] = {    h: ITHandle;    IF world # defaultWorld AND world # localWorld THEN RETURN;    h ¬ IH.InterpreterForWorld[world];    window ¬ h.tool;    fileSW ¬ h.fileSW;    Supervisor.NotifyDirectSubsystems[event: SwordUsefulDefs.setDUD, which: clients, subsystem: Event.spare2] };    LongREAD: PROC [loc: LongClientSource, world: WorldVM.World] RETURNS [val: UNSPECIFIED] = {    RETURN[WorldVMOps.Read[world, loc]]};      LongWRITE: PROC [loc: LongClientDest, val: UNSPECIFIED, world: WorldVM.World] = {    WorldVMOps.Write[world, loc, val]};      LongCopyREAD: PROC [from: LongClientSource, nwords: CARDINAL, to: LocalDest, world: WorldVM.World] = {    WorldVMOps.CopyRead[world, from, nwords, to]};      LongCopyWRITE: PROC [from: LocalSource, nwords: CARDINAL, to: LongClientDest, world: WorldVM.World] = {    WorldVMOps.CopyWrite[world, from, nwords, to]};    Lengthen: PROC [address: ClientSource, world: WorldVM.World] RETURNS [LongClientDest] = {    RETURN[WorldVMOps.Long[world, address]]};  FrameDesc: TYPE = LONG DESCRIPTOR FOR READONLY ARRAY OF GFHandle;  ConfigForFrame: PROC [gf: GFHandle, config: LONG STRING, world: WorldVM.World] = {    AMUseful.ConfigName[world, gf, config]};      Enumerate: PROC [proc: PROC [GFHandle] RETURNS [BOOLEAN], world: WorldVM.World] RETURNS [gf: GFHandle] = {    RETURN[AMUseful.EnumerateModules[world, proc]]};      Name: PROC [name: LONG STRING, gf: GFHandle, world: WorldVM.World] = {    ENABLE {      AMUseful.NoModule => ERROR InvalidFrame[gf] };    AMUseful.ModuleName[world, gf, name]};      Frame: PROC [name: LONG STRING, world: WorldVM.World] RETURNS [GFHandle] = {    RETURN[AMUseful.Frame[world, name]]};        Started: PROC [gf: GFHandle, world: WorldVM.World] RETURNS [BOOLEAN] = {    h: ITHandle ¬ IH.InterpreterForWorld[world];    RETURN [IP.Started[h, gf]]};      Valid: PROC [gf: GFHandle, world: WorldVM.World] RETURNS [BOOLEAN] = {    h: ITHandle ¬ IH.InterpreterForWorld[world];    RETURN [IQ.ValidateGF[h, gf]]};      Copied: PROC [gf: GFHandle, world: WorldVM.World] RETURNS [BOOLEAN] = {    h: ITHandle ¬ IH.InterpreterForWorld[world];    RETURN [IP.Copied[h, gf]]};      Original: PROC [new: GFHandle, world: WorldVM.World] RETURNS [old: GFHandle] = {    h: ITHandle ¬ IH.InterpreterForWorld[world];    RETURN [IP.Original[h, new]]};    Foo: TYPE = IT.Foo;  Bits: TYPE = SwordUsefulDefs.Bits;    GetAddress: PROC [foo: Foo] RETURNS [base: LONG POINTER, offset: Bits, there: BOOLEAN] = {    RETURN[foo.addr.base, foo.addr.offset, foo.there]};      GetSize: PROC [foo: Foo] RETURNS [words: CARDINAL, bits: Bits] = {    RETURN[foo.words, foo.bits]};      ReadValue: PROC [foo: Foo] = {    IP.GetValue[InterpreterForFoo[foo], foo]};      InterpreterForFoo: PROC[foo: Foo] RETURNS[h: ITHandle] = {    Ordered: PROC[l: LONG POINTER] RETURNS[LONG ORDERED POINTER] =       INLINE {RETURN[LOOPHOLE[l]]};    FOR h ¬ IZ.Interpreters, h.next UNTIL h = NIL DO      FOR fobtable: IT.FobTable ¬ h.fobs, fobtable.link         UNTIL fobtable = NIL DO        IF Ordered[fobtable] <= Ordered[foo] 	AND Ordered[foo] < Ordered[fobtable+Environment.wordsPerPage]	THEN RETURN;        ENDLOOP;      REPEAT FINISHED => ERROR;      ENDLOOP};    AddPrinter: PROC [type: LONG STRING, proc: IH.Printer, world: WorldVM.World] = {    h: ITHandle ¬ IH.InterpreterForWorld[world];    IH.AddPrinter[h, type, proc]};      RemovePrinter: PROC [type: LONG STRING, proc: IH.Printer, world: WorldVM.World] = {    h: ITHandle ¬ IH.InterpreterForWorld[world];    IH.RemovePrinter[h, type, proc]};    Interpreter: PROC [exp: LONG STRING, results: PROC[Foo], world: WorldVM.World] = {    MyResults: IT.FooProc = { results[f] };    h: ITHandle ¬ IH.InterpreterForWorld[world];    IO.Interpret[h, exp, MyResults]};   StringExpToNum: PROC [exp: LONG STRING, radix: CARDINAL, world: WorldVM.World]     RETURNS [UNSPECIFIED] = {    h: ITHandle ¬ IH.InterpreterForWorld[world];    RETURN[IO.StringExpToNum[h, exp, radix]]};  StringExpToLNum: PROC [exp: LONG STRING, radix: CARDINAL, world: WorldVM.World]     RETURNS [LONG UNSPECIFIED] = {    h: ITHandle ¬ IH.InterpreterForWorld[world];    RETURN[IO.StringExpToLNum[h, exp, radix]]};  StringExpToOctal: PROC [exp: LONG STRING, world: WorldVM.World] RETURNS [CARDINAL] = {    h: ITHandle ¬ IH.InterpreterForWorld[world];    RETURN[IO.StringExpToOctal[h, exp]]};  StringExpToLOctal: PROC [exp: LONG STRING, world: WorldVM.World] RETURNS [LONG CARDINAL] = {    h: ITHandle ¬ IH.InterpreterForWorld[world];    RETURN[IO.StringExpToLOctal[h, exp]]};  StringExpToDecimal: PROC [exp: LONG STRING, world: WorldVM.World] RETURNS [INTEGER] = {    h: ITHandle ¬ IH.InterpreterForWorld[world];    RETURN[IO.StringExpToDecimal[h, exp]]};  StringExpToLDecimal: PROC [exp: LONG STRING, world: WorldVM.World] RETURNS [LONG INTEGER] = {    h: ITHandle ¬ IH.InterpreterForWorld[world];    RETURN[IO.StringExpToLDecimal[h, exp]]};      -- Windows  window: Window.Handle ¬ NIL;  fileSW: Window.Handle ¬ NIL;    Text: PROCEDURE [s: LONG STRING, clientData: LONG POINTER ¬ NIL, world: WorldVM.World] = {    h: ITHandle ¬ IH.InterpreterForWorld[world];    IO.Text[s, h] };    -- Signals    MultipleFrames: SIGNAL [list: SwordUsefulDefs.FrameDesc] ¬ AMUseful.MultipleFrames;  InvalidAddress: ERROR [address: LONG POINTER] ¬ WorldVMOps.AddressFault;  InvalidFrame: ERROR [f: LONG POINTER] ¬ IQ.InvalidFrame;  InvalidNumber: ERROR [p: LONG POINTER] ¬ IO.InvalidNumber;  -- NotFound: ERROR [s: LONG STRING];  WriteProtected: ERROR [address: LONG POINTER] ¬ WorldVMOps.WriteProtected;  UserAborted: SIGNAL ¬ IO.UserAborted;    NoSession: ERROR = CODE;      }..
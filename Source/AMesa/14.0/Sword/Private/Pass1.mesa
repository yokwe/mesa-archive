-- Copyright (C) 1984, 1985  by Xerox Corporation. All rights reserved. -- ObjSymbolsA.mesa--  Yamamoto	 1-Jun-84 16:07:20--  Wagner	 6-Feb-85 14:06:37DIRECTORY  ComData,  Literals,  LiteralOps,  String,  Symbols,  SymbolOps,  SymbolSegment,  SymbolTable,  Tree;Pass1: PROGRAM  IMPORTS ComData, LiteralOps, SymbolOps  EXPORTS SymbolOps = {  OPEN Symbols, SymbolOps;      Handle: TYPE = SymbolTable.Handle;    Type: PUBLIC TYPE = Symbols.SEIndex;  Hash: PUBLIC TYPE = Symbols.HTIndex;  Body: PUBLIC TYPE = Symbols.BTIndex;  Id: PUBLIC TYPE = Symbols.ISEIndex;  Context: PUBLIC TYPE = Symbols.CTXIndex;  BitAddress: TYPE = Symbols.BitAddress;    BitSize: TYPE = CARDINAL;    null: Base RELATIVE POINTER [0..Limit) = LAST[Base RELATIVE POINTER [0..Limit)];  SubString: TYPE = String.SubString;  SubStringDescriptor: TYPE = String.SubStringDescriptor;    Error: PUBLIC SIGNAL[code: ErrorCode] = CODE;  ErrorCode: TYPE = {    expectingCons, expectingEnumerated, expectingRecord, expectingTranfer,    enumeratedOutOfOrder};  FillVariable: PROC [     h: Handle, sei: ISEIndex, name: LONG STRING, type: SEIndex, offset: BitAddress, nBits: CARDINAL] = {    desc: SubStringDescriptor;    hti: HTIndex;    IF name # NIL THEN {      desc ¬ [base:name, offset:0, length:name.length]; hti ¬ EnterString[h, @desc]}    ELSE hti ¬ HTNull;    FillCtxSe[h, sei, hti, FALSE];    h.seb[sei].idType ¬ type;  h.seb[sei].idValue ¬ SymbolOps.FromBitAddr[offset];  h.seb[sei].idInfo ¬ SymbolOps.FromCard[nBits];    SetIdAttr[h, sei, FALSE]};  FillConstant: PROC [h: Handle, sei: ISEIndex, name: LONG STRING, type: SEIndex, value: WORD] = {    desc: SubStringDescriptor ¬ [base:name, offset:0, length:name.length];    FillCtxSe[h, sei, EnterString[h, @desc], FALSE];    h.seb[sei].idType ¬ type;  h.seb[sei].idInfo ¬ SymbolOps.FromCard[0];  h.seb[sei].idValue ¬ SymbolOps.FromCard[value];    SetIdAttr[h, sei, TRUE]};  FillXferConstant: PROC [h: Handle, sei: ISEIndex, name: LONG STRING,     type: SEIndex, epN: CARDINAL] = {    desc: SubStringDescriptor ¬ [base:name, offset:0, length:name.length];    FillCtxSe[h, sei, EnterString[h, @desc], FALSE];    h.seb[sei].idType ¬ type;  h.seb[sei].idInfo ¬ FromBti[CBTNull];    h.seb[sei].idValue ¬ FromLink[Symbols.DummyLink[gfi:0, ep:epN]];    SetIdAttr[h, sei, TRUE]};  FillNamedType: PROC [h: Handle, sei: ISEIndex, s: LONG STRING, type: SEIndex] = {    desc: SubStringDescriptor ¬ [base:s, offset:0, length:s.length];    FillCtxSe[h, sei, EnterString[h, @desc], FALSE];  SetIdAttr[h, sei, TRUE];    h.seb[sei].idType ¬ typeTYPE;  h.seb[sei].idInfo ¬ FromSei[type];     h.seb[sei].idValue ¬ FromTreeIndex[Tree.NullIndex];    SetIdAttr[h, sei, TRUE]};  MakeTreeLiteral: PROC [h: Handle, val: WORD] RETURNS [Tree.Link] = {    RETURN [[literal[info:[word[LiteralOps.Find[h, val]]]]]]};  MakeRefType:  PROC [h: Handle, refType: SEIndex, counted, list: BOOLEAN ¬ FALSE]      RETURNS [sei: CSEIndex] = {    sei ¬ MakeNonCtxSe[h, SIZE[ref cons SERecord]];    h.seb[sei] ¬ [mark3: TRUE, mark4: TRUE,	body: cons[ref[		counted: counted,		var: FALSE,		readOnly: FALSE, ordered: FALSE, list: list, basing: FALSE,		refType: refType]]];    RETURN};  MakeLongType:  PROC [h: Handle, rangeType: SEIndex] RETURNS [sei: CSEIndex] = {    sei ¬ MakeNonCtxSe[h, SIZE[long cons SERecord]];    h.seb[sei] ¬ [mark3: TRUE, mark4: TRUE, body: cons[long[rangeType: rangeType]]];    RETURN};    NOuterSymbols: CARDINAL = 21;	-- number of predeclared ids (outer level only)  NExtraSymbols: CARDINAL = 4;	-- number of new predeclared ids    PrefillMesaSymbols: PUBLIC PROC [s: Handle] RETURNS[outerCtx: Context] =    BEGIN OPEN ComData;        tC0, tC1: Tree.Link;        tSei: CSEIndex;    rSei: RecordSEIndex;    tCtx: CTXIndex;    sei, seChain: ISEIndex;    outerChain: ISEIndex;      NextOuterSe: PROC [s: Handle] RETURNS [next: ISEIndex] = {      IF outerChain = ISENull THEN ERROR;      next ¬ outerChain;  outerChain ¬ NextSe[s, outerChain];  RETURN};    tSei ¬ LOOPHOLE[MakeBasicType[s, codeANY, TRUE, WordLength]];	-- guaranteed position    outerCtx ¬ NewCtx[s, lZ];    outerChain ¬ s.ctxb[outerCtx].seList ¬ SymbolOps.MakeSeChain[s, outerCtx, NOuterSymbols, FALSE];    -- make some constants      {tC0 ¬ MakeTreeLiteral[s, 0]; tC1 ¬ MakeTreeLiteral[s, 1]};    idANY ¬ NextOuterSe[s];      FillNamedType[s, idANY, "UNSPECIFIED"L, tSei];      IF tSei # typeANY THEN ERROR;    idINT ¬ NextOuterSe[s];  typeINT ¬ LOOPHOLE[MakeBasicType[s, codeINT, TRUE, WordLength]];      FillNamedType[s, idINT, "INTEGER"L, typeINT];    idCHAR ¬ NextOuterSe[s];  typeCHAR ¬ LOOPHOLE[MakeBasicType[s, codeCHAR, TRUE, ByteLength]];      FillNamedType[s, idCHAR, "CHARACTER"L, typeCHAR];    idBOOL ¬ NextOuterSe[s];      typeBOOL ¬ MakeNonCtxSe[s, SIZE[enumerated cons SERecord]];      tCtx ¬ NewCtx[s, lZ];      s.seb[typeBOOL] ¬ [mark3: TRUE, mark4: TRUE,	body: cons[enumerated[		ordered: TRUE, machineDep: TRUE, sparse: FALSE, unpainted: FALSE,		valueCtx: tCtx, nValues: 2]]];      s.ctxb[tCtx].seList ¬ seChain ¬ MakeSeChain[s, tCtx, 2, FALSE];      FillConstant[s, seChain, "FALSE"L, idBOOL, 0];  seChain ¬ NextSe[s, seChain];      FillConstant[s, seChain, "TRUE"L, idBOOL, 1];      FillNamedType[s, idBOOL, "BOOLEAN"L, typeBOOL];    idCARDINAL ¬ NextOuterSe[s];      typeCARDINAL ¬ LOOPHOLE[MakeSubrangeType[s, idINT, 0, 177777b]];      FillNamedType[s, idCARDINAL, "CARDINAL"L, typeCARDINAL];    FillNamedType[s, NextOuterSe[s], "WORD"L, typeCARDINAL];    idREAL ¬ NextOuterSe[s];      typeREAL ¬ MakeNonCtxSe[s, SIZE[real cons SERecord]];      s.seb[typeREAL] ¬ [mark3:TRUE, mark4:TRUE, body:cons[real[rangeType:idINT]]];      FillNamedType[s, idREAL, "REAL"L, typeREAL];    idNAT ¬ sei ¬ NextOuterSe[s];	-- NAT      FillNamedType[s, sei, "NAT"L, MakeSubrangeType[s, idINT, 0, 77777b]];    idTEXT ¬ NextOuterSe[s];      rSei ¬ LOOPHOLE[MakeRecordType[s]];      s.seb[rSei].length ¬ 2*WordLength;      s.seb[rSei].hints.default ¬ TRUE;      s.seb[rSei].hints.variant ¬ TRUE;      tCtx ¬ s.seb[rSei].fieldCtx; s.ctxb[tCtx].seList ¬ seChain ¬ MakeSeChain[s, tCtx, 2, FALSE];      FillVariable[s, seChain, "length"L, idNAT, [wd:0, bd:0], WordLength];        EnterExtension[s, seChain, default, tC0];      seChain ¬ NextSe[s, seChain];	BEGIN	tag: ISEIndex = MakeSeChain[s, CTXNull, 1, FALSE];	seqSei: CSEIndex = MakeNonCtxSe[s, SIZE[sequence cons SERecord]];	FillVariable[s, tag, "maxLength"L, idNAT, [wd:1, bd:0], WordLength];	  s.seb[tag].immutable ¬ TRUE;	s.seb[seqSei] ¬ [mark3: TRUE, mark4: TRUE,	    body: cons[sequence[		packed: TRUE, machineDep: TRUE,		controlled: TRUE, tagSei: tag,		componentType: idCHAR]]];	FillVariable[s, seChain, "text"L, seqSei, [wd:1, bd:0], WordLength];	END;      FillNamedType[s, idTEXT, "TEXT"L, rSei];    idSTRING ¬ NextOuterSe[s];    sei ¬ NextOuterSe[s];	-- StringBody      typeStringBody ¬ rSei ¬ LOOPHOLE[MakeRecordType[s]];      s.seb[rSei].length ¬ 2*WordLength;      s.seb[rSei].hints.default ¬ TRUE;      s.seb[rSei].hints.assignable ¬ s.seb[rSei].hints.voidable ¬ TRUE;   -- compatibility      tCtx ¬ s.seb[rSei].fieldCtx; s.ctxb[tCtx].seList ¬ seChain ¬ MakeSeChain[s, tCtx, 3, FALSE];      FillVariable[s, seChain, "length"L, idCARDINAL, [wd:0, bd:0], WordLength];        EnterExtension[s, seChain, default, tC0];      seChain ¬ NextSe[s, seChain];      FillVariable[s, seChain, "maxlength"L, idCARDINAL, [wd:1, bd:0], WordLength];        s.seb[seChain].immutable ¬ TRUE;      seChain ¬ NextSe[s, seChain];      tSei ¬ MakeNonCtxSe[s, SIZE[array cons SERecord]];      s.seb[tSei] ¬ [mark3: TRUE, mark4: TRUE,	body: cons[array[		packed: TRUE,		indexType: MakeSubrangeType[s, idINT, 0, 0],		componentType: idCHAR]]];      FillVariable[s, seChain, "text"L, tSei, [wd:2, bd:0], 0];      FillNamedType[s, sei, "StringBody"L, rSei];  typeSTRING ¬ MakeRefType[s, sei];      FillNamedType[s, idSTRING, "STRING"L, typeSTRING];    idLOCK ¬ NextOuterSe[s];      rSei ¬ LOOPHOLE[MakeRecordType[s]];      s.seb[rSei].length ¬ WordLength;      s.seb[rSei].hints.default ¬ TRUE;      tCtx ¬ s.seb[rSei].fieldCtx; s.ctxb[tCtx].seList ¬ seChain ¬ MakeSeChain[s, tCtx, 1, FALSE];      FillVariable[s, seChain, NIL, idANY, [wd:0, bd:0], WordLength];        EnterExtension[s, seChain, default, MakeTreeLiteral[s, 100000b]];      FillNamedType[s, idLOCK, "MONITORLOCK"L, rSei];  typeLOCK ¬ rSei;    idCONDITION ¬ NextOuterSe[s];	-- CONDITION      rSei ¬ LOOPHOLE[MakeRecordType[s]];      s.seb[rSei].length ¬ 2*WordLength;      s.seb[rSei].hints.default ¬ TRUE;      typeCONDITION ¬ rSei;      tCtx ¬ s.seb[rSei].fieldCtx; s.ctxb[tCtx].seList ¬ seChain ¬ MakeSeChain[s, tCtx, 2, FALSE];      FillVariable[s, seChain, "timeout"L, idCARDINAL, [wd:1, bd:0], WordLength];        EnterExtension[s, seChain, default, tC0];      seChain ¬ NextSe[s, seChain];      FillVariable[s, seChain, NIL, idANY, [wd:0, bd:0], WordLength];        EnterExtension[s, seChain, default, tC0];      FillNamedType[s, idCONDITION, "CONDITION"L, rSei];  typeCONDITION ¬ rSei;    sei ¬ NextOuterSe[s];	-- MDSZone      tSei ¬ MakeNonCtxSe[s, SIZE[zone cons SERecord]];      s.seb[tSei] ¬ [mark3:TRUE, mark4:TRUE, body:cons[zone[counted:FALSE, mds:TRUE]]];      FillNamedType[s, sei, "MDSZone"L, tSei];    idATOM ¬ sei ¬ NextOuterSe[s];      typeAtomRecord ¬ tSei ¬ MakeNonCtxSe[s, SIZE[opaque cons SERecord]];      s.seb[tSei] ¬ [mark3: TRUE, mark4: TRUE,	body: cons[opaque[	  id: NextSe[s, sei],	  length: 0, lengthKnown: FALSE]]];      tSei ¬ MakeRefType[h: s, refType: tSei, counted: TRUE];      typeATOM ¬ MakeLongType[s, tSei];      FillNamedType[s, idATOM, "ATOM"L, typeATOM];    seAnon ¬ NextOuterSe[s];      FillVariable[s, seAnon, "?"L,  typeANY, [wd:0, bd:0], WordLength];    FillConstant[s, NextOuterSe[s], "TRUE"L, idBOOL, 1];	-- TRUE    FillConstant[s, NextOuterSe[s], "FALSE"L, idBOOL, 0];	-- FALSE    idERROR ¬ NextOuterSe[s];    idUNWIND ¬ NextOuterSe[s];    idABORTED ¬ NextOuterSe[s];      tSei ¬ MakeNonCtxSe[s, SIZE[transfer cons SERecord]];      s.seb[tSei] ¬ [mark3: TRUE, mark4: TRUE,	body: cons[transfer[	  mode: error, safe: FALSE,	  typeIn: RecordSENull, typeOut: RecordSENull]]];      FillXferConstant[s, idERROR, "ERROR"L, tSei, LOOPHOLE[-1]];      FillXferConstant[s, idUNWIND, "UNWIND"L, tSei, 1];      FillXferConstant[s, idABORTED, "ABORTED"L, tSei, 2];    IF outerChain # ISENull THEN ERROR;    -- REF ANY      tSei ¬ MakeNonCtxSe[s, SIZE[any cons SERecord]];      s.seb[tSei] ¬ [mark3: TRUE, mark4: TRUE, body: cons[any[]]];      typeRefANY ¬ MakeLongType[s, MakeRefType[h: s, refType: tSei, counted: TRUE]];    -- LIST OF REF ANY      rSei ¬ LOOPHOLE[MakeRecordType[s]];      s.seb[rSei].length ¬ 2*(2*WordLength);      s.seb[rSei].hints.refField ¬ s.seb[rSei].hints.default ¬ TRUE;      typeListANY ¬ MakeLongType[s, MakeRefType[h: s, refType: rSei, counted: TRUE, list: TRUE]];      s.seb[rSei].painted ¬ FALSE;      s.seb[rSei].hints.comparable ¬ s.seb[rSei].hints.assignable ¬ TRUE;      s.seb[rSei].hints.refField ¬ TRUE;      tCtx ¬ s.seb[rSei].fieldCtx; s.ctxb[tCtx].seList ¬ seChain ¬ MakeSeChain[s, tCtx, 2, FALSE];      FillVariable[s, seChain, "first"L, typeRefANY, [wd:0, bd:0], 2*WordLength];      seChain ¬ NextSe[s, seChain];      FillVariable[s, seChain, "rest"L, typeListANY, [wd:2, bd:0], 2*WordLength];   -- predeclared types added for Cedar    outerChain ¬ s.ctxb[outerCtx].seList ¬ MakeSeChain[s, outerCtx, NExtraSymbols, TRUE];    FillNamedType[s, NextOuterSe[s], "BOOL"L, idBOOL];    FillNamedType[s, NextOuterSe[s], "CHAR"L, idCHAR];    sei ¬ NextOuterSe[s];	-- INT      tSei ¬ MakeLongType[s, idINT];      FillNamedType[s, sei, "INT"L, tSei];    sei ¬ NextOuterSe[s];		-- NATURAL (for SDD Trinity)      FillNamedType[s, sei, "NATURAL"L, idNAT];    SetSeLink[s, sei, idANY];    IF outerChain # ISENull THEN ERROR;    END; -- PrefillMesaSymbols  MakeBasicType: PUBLIC PROC[    s: Handle, code: [0..16), ordered: BOOLEAN, length: CARDINAL]    RETURNS [Type] = {    csei: CSEIndex ¬ MakeNonCtxSe[s, SIZE[basic cons SERecord]];    s.seb[csei] ¬ [      mark3: TRUE, mark4: TRUE,      body: cons[basic[ordered:ordered, code:code, length:length]]];    RETURN[csei]};        MakeRecordType: PUBLIC PROC [s: Handle] RETURNS [Type] = {    rSei: RecordSEIndex ¬ LOOPHOLE[SymbolOps.MakeNonCtxSe[s,       SIZE[-- notLinked -- record cons SERecord]]];    s.seb[rSei] ¬ [mark3: TRUE, mark4: TRUE,      body: cons[record[	machineDep: TRUE,	argument: FALSE,  monitored: FALSE, painted: TRUE,	hints: [	  comparable: TRUE, assignable: TRUE,	  variant: FALSE, unifield: FALSE, privateFields: FALSE,	  refField: FALSE, default: FALSE, voidable: TRUE],	fieldCtx: SymbolOps.NewCtx[s, lZ],	length: 0,	linkPart: notLinked[]]]];    RETURN[rSei]};  SetIdAttr: PROC [s: Handle, sei: ISEIndex, const: BOOLEAN] = {    s.seb[sei].immutable ¬ s.seb[sei].constant ¬ const;    s.seb[sei].extended ¬ s.seb[sei].linkSpace ¬ FALSE;    s.seb[sei].public ¬ s.seb[sei].mark3 ¬ s.seb[sei].mark4 ¬ TRUE};      MakeSubrangeType: PUBLIC PROC [    s: Handle, baseType: Type, origin: INTEGER, range: CARDINAL]     RETURNS [Type] = {    csei: CSEIndex ¬ LOOPHOLE[SymbolOps.MakeNonCtxSe[s, SIZE[subrange cons SERecord]]];    s.seb[csei] ¬ [mark3: TRUE, mark4: TRUE,      body: cons[subrange[	filled: TRUE, empty: range=0,	rangeType: baseType,	origin: origin, range: range]]];    RETURN[csei];    };      }.    
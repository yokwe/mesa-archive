-- File: DebugToolA.mesa - last edit:-- Litman              22-Apr-87 23:36:25-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.DIRECTORY  AMProcess USING [Adjust, CallDebugger, GetState, HowManyInList, LFHandle, Name, Process, ProcessList, ProcessRec, Thaw],  AMProcessBasic USING [State],  CmFile USING [Close, Error, FindSection, Handle, NextValue, TableError, UserDotCmOpen],  DebugToolOps USING [DeleteDObjet, CantDebug, CreateDObjet, FreezeAll, FreezeContext, FreezePSBI, FreezeReady, ListContext, ListLoadstate, LocalDebug, NoneDebug, OutloadDebug, RemoteDebug, ThawAll],  DObjet USING [ControlType, FreezeType, Hand, ListType, MaxFrozenProcesses, ProcessActions, ThawType, WorldType],  Exec USING [AddCommand, ExecProc, Handle, OutputProc, RemoveCommand],  Format USING [Char, LongNumber, Number, StringProc],  FormSW USING [AllocateItemDescriptor, ClientItemsProcType, CommandItem, ContextFromItem, Create, DisplayItem, Enumerated, EnumeratedItem, EnumeratedNotifyProcType, ItemHandle, line0, line1, line2, line3, LineHeight, nextLine, NumberItem, Options, ProcType, StringItem, TagOnlyItem],  Heap USING [Delete, Create],  MStream USING [Handle, Log, PleaseReleaseProc, SetLogReadLength],  Process USING [Detach],  PSB USING [Priority, PsbIndex],  Put USING [Line, Text],  Runtime USING [IsBound],  Stream USING [GetPosition, Handle],  String USING [AppendChar, AppendLongNumber, AppendNumber, AppendString, Equivalent, Replace],  StringLookUp USING [noMatch],  TextSW USING [Options],  Token USING [FreeTokenString, Handle, Item],  Tool USING [AddThisSW, Create, Destroy, MakeFormSW, MakeSWsProc, State, UnusedLogName],  ToolWindow USING [CreateSubwindow, State, TransitionProcType],  TTYSW USING [Create, defaultOptions, GetTTYHandle],  UserInput USING [ResetUserAbort, UserAbort],  Window USING [Handle],  WindowFont USING [defaultFont],  WorldVMOps USING [Process, ProcessShort];DebugToolA: MONITOR   IMPORTS AMProcess, CmFile, DebugToolOps, Exec, Format, FormSW, Heap, MStream, Process, Put, Runtime, Stream, String, Token, Tool, ToolWindow, TTYSW, UserInput, WindowFont, WorldVMOps  EXPORTS DebugToolOps = {  data: DObjet.Hand ¬ NIL;  zone: UNCOUNTED ZONE ¬ NIL;    FormItems: TYPE = {world, client, freeze, context, thaw, psbIndex,     list, --control,-- destroy};      UserAbort: PUBLIC PROC[d: DObjet.Hand] RETURNS[true: BOOLEAN] = {    IF (true ¬ UserInput.UserAbort[d.ttySW])    THEN UserInput.ResetUserAbort[d.ttySW]};      Output: PUBLIC Format.StringProc = {    d: DObjet.Hand = clientData;    Put.Text[d.ttySW, s]};      Number: PUBLIC PROC[val: UNSPECIFIED, radix: CARDINAL] = {    Format.Number[Output, val, [radix, FALSE, TRUE, 0], data];    SELECT radix FROM      8 => IF val ~IN[0..7] THEN Format.Char[Output, 'B, data];      16 => IF val ~IN[0..9] THEN Format.Char[Output, 'H, data];      ENDCASE };        LongNumber: PUBLIC PROC[val: LONG UNSPECIFIED, radix: CARDINAL] = {    Format.LongNumber[Output, val, [radix, FALSE, TRUE, 0], data];    SELECT radix FROM      8 => IF val ~IN[0..7] THEN Format.Char[Output, 'B, data];      16 => IF val ~IN[0..9] THEN Format.Char[Output, 'H, data];      ENDCASE };      CheckWorld: PROC = {    IF data.world = none THEN {      Put.Line[data.ttySW, "No world!"L];      ERROR ABORTED}};      ChangeWorld: FormSW.EnumeratedNotifyProcType = {    ENABLE DebugToolOps.CantDebug => {Put.Line[data.ttySW, "cant"L]; CONTINUE};    Put.Text[data.ttySW, "Preparing to "L];    SELECT data.world FROM      none => {        Put.Text[data.ttySW, "clear world..."L];	DebugToolOps.NoneDebug[data] };      local => {        Put.Text[data.ttySW, "LocalDebug..."L];        DebugToolOps.LocalDebug[data] };      outload => {        Put.Text[data.ttySW, "OutloadDebug..."L];        DebugToolOps.OutloadDebug[data] };      remote => {        Put.Text[data.ttySW, "RemoteDebug..."L];        DebugToolOps.RemoteDebug[data] };      ENDCASE;    Put.Line[data.ttySW, "done"L];    FormSW.DisplayItem[data.cFormSW, FormItems.world.ORD]};  ChangeFreeze:  FormSW.EnumeratedNotifyProcType = {    ENABLE UNWIND => {      data.freeze ¬ none;      FormSW.DisplayItem[data.cFormSW, FormItems.freeze.ORD]};    none: BOOLEAN;    CheckWorld[];    SELECT data.freeze FROM       all => none ¬ DebugToolOps.FreezeAll[data];      ready => none ¬ DebugToolOps.FreezeReady[data];      process => none ¬ DebugToolOps.FreezePSBI[data];      context => none ¬ DebugToolOps.FreezeContext[data];      ENDCASE;    IF ~none THEN RedisplayPFormSW[];    data.freeze ¬ none;    FormSW.DisplayItem[data.cFormSW, FormItems.freeze.ORD]};  ChangeThaw:  FormSW.EnumeratedNotifyProcType = {    ENABLE UNWIND => {      data.thaw ¬ none;      FormSW.DisplayItem[data.cFormSW, FormItems.thaw.ORD]};    CheckWorld[];    SELECT data.thaw FROM      all => DebugToolOps.ThawAll[data];      ENDCASE;    RedisplayPFormSW[];    data.thaw ¬ none;    FormSW.DisplayItem[data.cFormSW, FormItems.thaw.ORD]};  ChangeList:  FormSW.EnumeratedNotifyProcType = {    ENABLE UNWIND => {      data.list ¬ none;      FormSW.DisplayItem[data.cFormSW, FormItems.list.ORD]};    CheckWorld[];    SELECT data.list FROM      loadstate => DebugToolOps.ListLoadstate[data];      context => DebugToolOps.ListContext[data];      ENDCASE;    data.list ¬ none;    FormSW.DisplayItem[data.cFormSW, FormItems.list.ORD]};  «  ChangeControl:  FormSW.EnumeratedNotifyProcType = {    ENABLE UNWIND => {      data.control ¬ none;      FormSW.DisplayItem[data.cFormSW, FormItems.control.ORD]};    CheckWorld[];    SELECT data.control FROM      stop => DebugToolOps.Stop[data];      kill => DebugToolOps.Kill[data];      userscreen => DebugToolOps.Userscreen[data];      ENDCASE;    data.control ¬ none;    FormSW.DisplayItem[data.cFormSW, FormItems.control.ORD]};  »    MyDestroy: FormSW.ProcType = {    IF data # NIL THEN {       IF data.toolwindow # NIL THEN Tool.Destroy[data.toolwindow];      data ¬ DebugToolOps.DeleteDObjet[data] }};    RedisplayPFormSW: PROC = {    numberOfProcesses: CARDINAL = AMProcess.HowManyInList[data.processes];    h: INTEGER = (numberOfProcesses+1)*FormSW.LineHeight[];    newPFormSW: Window.Handle;    Tool.Destroy[data.pFormSW];    newPFormSW ¬ ToolWindow.CreateSubwindow[parent: data.toolwindow];    FormSW.Create[sw: newPFormSW, clientItemsProc: MakeProcessForm, options: [boldTags: FALSE], zone: data.zone];    Tool.AddThisSW[window: data.toolwindow, sw: newPFormSW, nextSW: data.ttySW, h: h];    data.pFormSW ¬ newPFormSW};  ClientTransition: ToolWindow.TransitionProcType = {    SELECT TRUE FROM      old = inactive => {};              new = inactive => {};      ENDCASE};  MakeSWs: Tool.MakeSWsProc = {    logName: LONG STRING ¬ [30];    stream: MStream.Handle;    options: TextSW.Options ¬ TTYSW.defaultOptions;    options.access ¬ append;    Tool.UnusedLogName[unused: logName, root: "ProcessControl.log"L];    data.cFormSW ¬ Tool.MakeFormSW[window: window, formProc: MakeCommandForm, zone: data.zone];    data.pFormSW ¬ Tool.MakeFormSW[window: window, formProc: MakeProcessForm, zone: data.zone];    stream ¬ MStream.Log[name: logName, release: [TruncateLog, NIL]];    data.ttySW ¬ ToolWindow.CreateSubwindow[parent: window];     TTYSW.Create[sw: data.ttySW, backupFile: logName, s: stream, options: options];    Tool.AddThisSW[window: window, sw: data.ttySW];    data.tty ¬ TTYSW.GetTTYHandle[data.ttySW]};      TruncateLog: MStream.PleaseReleaseProc = {    MStream.SetLogReadLength[stream, Stream.GetPosition[stream]];    RETURN[no]};      MakeCommandForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = FormItems.LAST.ORD + 1;    freeze: ARRAY[0..4) OF Enumerated ¬ [      ["All"L, DObjet.FreezeType.all],       ["Ready"L, DObjet.FreezeType.ready],       ["Process"L, DObjet.FreezeType.process],       ["Context"L, DObjet.FreezeType.context]];    thaw: ARRAY[0..1) OF Enumerated ¬ [      ["All"L, DObjet.ThawType.all]];    world: ARRAY[0..4) OF Enumerated ¬ [      ["None"L, DObjet.WorldType.none],       ["Local"L, DObjet.WorldType.local],       ["Outload"L, DObjet.WorldType.outload],       ["Remote"L, DObjet.WorldType.remote]];    list: ARRAY[0..2) OF Enumerated ¬ [      ["Loadstate"L, DObjet.ListType.loadstate],       ["Context"L, DObjet.ListType.context]];    control: ARRAY[0..3) OF Enumerated ¬ [      ["Stop"L, DObjet.ControlType.stop],       ["Kill"L, DObjet.ControlType.kill],      ["UserScreen"L, DObjet.ControlType.userscreen]];    char: CARDINAL = WindowFont.defaultFont.width['0];    items ¬ AllocateItemDescriptor[nItems, data.zone];    items[FormItems.world.ORD] ¬ EnumeratedItem[      tag: "World"L, place: [1*char, line0], feedback: all, proc: ChangeWorld,       choices: DESCRIPTOR[world], value: @data.world, z: data.zone];    items[FormItems.client.ORD] ¬ StringItem[      tag: "Client"L, place: [41*char, line0], inHeap: TRUE,       string: @data.client, z: data.zone];    items[FormItems.freeze.ORD] ¬ EnumeratedItem[      tag: "Freeze"L, place: [1*char, line1], feedback: all, proc: ChangeFreeze,      choices: DESCRIPTOR[freeze], value: @data.freeze, z: data.zone];    items[FormItems.context.ORD] ¬ StringItem[      tag: "Context"L, place: [41*char, line1], inHeap: TRUE,       string: @data.context, z: data.zone];    items[FormItems.thaw.ORD] ¬ EnumeratedItem[      tag: "Thaw"L, place: [1*char, line2], feedback: all, proc: ChangeThaw,       choices: DESCRIPTOR[thaw], value: @data.thaw, z: data.zone];    items[FormItems.psbIndex.ORD] ¬ NumberItem[      tag: "PsbIndex"L, place: [41*char, line2], signed: FALSE,       value: @data.psbIndex, z: data.zone];    items[FormItems.list.ORD] ¬ EnumeratedItem[      tag: "List"L, place: [1*char, line3], feedback: all, proc: ChangeList,       choices: DESCRIPTOR[list], value: @data.list, z: data.zone];    «items[FormItems.control.ORD] ¬ EnumeratedItem[      tag: "Control"L, place: [41*char, line3], feedback: all,       proc: ChangeControl,      choices: DESCRIPTOR[control], value: @data.control, z: data.zone];»    items[FormItems.destroy.ORD] ¬ CommandItem[      tag: "Destroy"L, place: [41*char, line3], proc: MyDestroy, z: data.zone];    RETURN[items: items, freeDesc: TRUE]};        ProcessLabelSize: CARDINAL = 56;  PData: TYPE = RECORD[psbi: PSB.PsbIndex, countProcesses: CARDINAL];    MakeProcessForm: FormSW.ClientItemsProcType = {    itemsPerProcess: CARDINAL = 1;    numberOfProcesses: CARDINAL = AMProcess.HowManyInList[data.processes];    countProcesses: CARDINAL ¬ 0;    item: CARDINAL ¬ 1;    shit: ARRAY[0..3) OF FormSW.Enumerated ¬ [      ["Adjust"L, 0], ["Thaw"L, 1], ["Debug"L, 2]];    items ¬ FormSW.AllocateItemDescriptor[      numberOfProcesses*itemsPerProcess + 1, data.zone];    items[0] ¬ FormSW.TagOnlyItem[tag: "Frozen Processes"L, readOnly: TRUE,       drawBox: TRUE, place: [6, FormSW.line0], z: data.zone];    data.actOnProcess ¬ ALL[none];    FOR l: AMProcess.ProcessList ¬ data.processes, l.next UNTIL l = NIL DO      pData: LONG POINTER TO PData;      description: STRING ¬ [ProcessLabelSize];      [] ¬ ProcessLabel[description, l.p];      items[item] ¬ FormSW.EnumeratedItem[        tag: description, place: [6, FormSW.nextLine], drawBox: TRUE, hasContext: TRUE,        feedback: all, proc: ChangeProcess, choices: DESCRIPTOR[shit], 	value: @data.actOnProcess[countProcesses], z: data.zone];      pData ¬ FormSW.ContextFromItem[items[item]];      pData­ ¬ [psbi: WorldVMOps.ProcessShort[l.p.psbi], countProcesses: countProcesses];      item ¬ item + itemsPerProcess;      IF (countProcesses ¬ countProcesses+1) >= DObjet.MaxFrozenProcesses THEN ERROR;      ENDLOOP;    RETURN[items: items, freeDesc: TRUE]};      ProcessLabel: PROC[description: STRING, p: AMProcess.Process]     RETURNS[stack: AMProcess.LFHandle] = {    state: AMProcessBasic.State;    faultData: LONG CARDINAL;    priority: PSB.Priority;    topFrame: BOOL;    stateRope: ARRAY AMProcessBasic.State OF STRING = [      "ready"L, "waitingSV"L, "waitingCV"L, "waitingML"L,      "frameFault"L, "pageFault"L, "writeProtectFault"L, "unknownFault"L,       "dead"L, "unknown"L, "uncaughtSignal"L, "breakpoint"L, "callDebugger"L];    IF description = NIL THEN RETURN;    description.length ¬ 0;        -- print process name    AMProcess.Name[p.psbi, description, data.processRadix];    -- print frozen frame    String.AppendString[description, " frame= "L];    [state, faultData, priority, stack, topFrame] ¬ AMProcess.GetState[p];    IF stack = NIL THEN String.AppendString[description, "none"L]    ELSE {      String.AppendLongNumber[description, stack, data.cardinalRadix];       SELECT data.cardinalRadix FROM        8 => «IF stack ~IN[0..7] THEN» String.AppendChar[description, 'B];	16 => «IF stack ~IN[0..9] THEN» String.AppendChar[description, 'H];	ENDCASE };        -- print state    String.AppendString[description, " state= "L];    IF topFrame THEN String.AppendChar[description, '(];    String.AppendString[description, stateRope[state]];    IF topFrame THEN String.AppendChar[description, ')];        -- print faultData    IF state IN [frameFault..unknownFault] THEN {      String.AppendString[description, " ["L];      String.AppendLongNumber[description, faultData];      String.AppendChar[description, ']]};          -- print priority    String.AppendString[description, " priority= "L];    String.AppendNumber[description, priority];        -- fill with blanks    BEGIN     extraSpace: CARDINAL = description.maxlength - description.length;    FOR i: CARDINAL IN [0..extraSpace) DO       String.AppendChar[description, ' ];      ENDLOOP;    END };  -- end ProcessLabel    ChangeProcess: FormSW.EnumeratedNotifyProcType = {    pData: LONG POINTER TO PData = FormSW.ContextFromItem[item];    psbi: PSB.PsbIndex = pData.psbi;    IF CheckAction[data.action, psbi] THEN {      ENABLE UNWIND => EndAction[data.action, psbi];      rec: AMProcess.ProcessRec ¬ [next: NIL, p: [world: data.World, psbi: psbi]];      SELECT data.actOnProcess[pData.countProcesses] FROM	Adjust => {	  AMProcess.Adjust[@rec, data.rootContext];	  RelabelProcessItem[item, index, [world: data.World, psbi: psbi]]};	Thaw => AMProcess.Thaw[@rec];	Debug => Process.Detach[FORK DoAction[data.action, psbi, index]];	ENDCASE;      EndAction[data.action, psbi] }    ELSE HasAnActionArea[psbi] };    RelabelProcessItem: PROC[item: FormSW.ItemHandle, index: CARDINAL, process: AMProcess.Process] = {    newDescription: STRING ¬ [ProcessLabelSize];     [] ¬ ProcessLabel[newDescription, process];    String.Replace[@item.tag, newDescription, data.zone];    FormSW.DisplayItem[data.pFormSW, index]};      DoAction: PROC[action: DObjet.ProcessActions,     psbi: PSB.PsbIndex, index: CARDINAL] = {    ENABLE UNWIND => EndAction[action, psbi];    description: STRING ¬ [ProcessLabelSize];    --FormSW.ToggleFlag[data.pFormSW, index, drawBox];    --FormSW.DisplayItem[data.pFormSW, index];    [] ¬ ProcessLabel[description, [world: data.World, psbi: psbi]];    AMProcess.CallDebugger[[world: data.World, psbi: psbi], description];    --FormSW.ToggleFlag[data.pFormSW, index, drawBox];    --FormSW.DisplayItem[data.pFormSW, index];    EndAction[action, psbi]};      CheckAction: ENTRY PROC[action: DObjet.ProcessActions, psbi: PSB.PsbIndex] RETURNS[ok: BOOL] = {    IF action[psbi] THEN RETURN[FALSE] ELSE {action[psbi] ¬ TRUE; RETURN[TRUE]}};    EndAction: ENTRY PROC[action: DObjet.ProcessActions, psbi: PSB.PsbIndex] = {    action[psbi] ¬ FALSE};    HasAnActionArea: PROC[psbi: PSB.PsbIndex] = {    psbname: STRING ¬ [10];    AMProcess.Name[psbi, psbname];    Put.Text[data.ttySW, psbname];    Put.Line[data.ttySW, " has an action area"L]};      ProcessUserCm: PROC[] = {    userCm: CmFile.Handle;    Option: TYPE = MACHINE DEPENDENT {      cardinalRadix(0), processRadix(1), noMatch(StringLookUp.noMatch) };    DefinedOption: TYPE = Option [cardinalRadix..processRadix];    optionTable: ARRAY DefinedOption OF LONG STRING ¬ [      cardinalRadix: "cardinalRadix"L, processRadix: "processRadix"L];    OctDecHex: PROC[option: LONG POINTER TO CARDINAL] = {      t: LONG STRING ¬ Token.Item[userCm, TRUE];      SELECT TRUE FROM	String.Equivalent[t, "octal"L] => option­ ¬ 8;	String.Equivalent[t, "decimal"L] => option­ ¬ 10;	String.Equivalent[t, "hex"L] => option­ ¬ 16;	ENDCASE;      t ¬ Token.FreeTokenString[t] };    userCm ¬ CmFile.UserDotCmOpen[ ! CmFile.Error => GOTO NoUserDotCm];    IF CmFile.FindSection[userCm, "ProcessControl"L] THEN {      DO ENABLE CmFile.TableError => RESUME;        val: Option ¬ VAL[CmFile.NextValue[userCm, LOOPHOLE[LONG[DESCRIPTOR[optionTable]]]]];	SELECT val FROM          noMatch => EXIT;          cardinalRadix => OctDecHex[@data.cardinalRadix];	  processRadix => OctDecHex[@data.processRadix];	  ENDCASE;        ENDLOOP};    [] ¬ CmFile.Close[userCm];    EXITS NoUserDotCm => NULL };      HelpProcessControl: Exec.ExecProc = {    out: Format.StringProc = Exec.OutputProc[h];    out["\nProcessControl.~ "L];    out["\n  enables freezing and thawing of processes"L] };    DoProcessControl: Exec.ExecProc = {    IF ~Runtime.IsBound[LOOPHOLE[AMProcess.CallDebugger]] THEN { Exec.OutputProc[h]["\nSword not loaded!"L]; RETURN[abort] };    IF zone = NIL THEN zone ¬ Heap.Create[initial: 4];    -- allows one instance only    IF data = NIL THEN {      data ¬ DebugToolOps.CreateDObjet[zone];      IF Runtime.IsBound[LOOPHOLE[Tool.Create]] THEN 	data.toolwindow ¬ Tool.Create[	  makeSWsProc: MakeSWs, initialState: active,	  clientTransition: ClientTransition, name: "ProcessControl"L,	  cmSection: "ProcessControl"L]};    ProcessUserCm[];    RETURN[normal] };        UndoProcessControl: Exec.ExecProc = {    IF data # NIL THEN {       IF data.toolwindow # NIL THEN Tool.Destroy[data.toolwindow];       data ¬ DebugToolOps.DeleteDObjet[data] };    IF zone # NIL THEN { Heap.Delete[zone]; zone ¬ NIL };    Exec.RemoveCommand[h, "ProcessControl.~"L];    RETURN[normal] };    DoAll: PROCEDURE = {    Exec.AddCommand[name: "ProcessControl.~"L, proc: DoProcessControl, unload: UndoProcessControl, help: HelpProcessControl]; };    DoAll[];    }.    
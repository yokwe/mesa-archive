-- Copyright (C) 1986  by Xerox Corporation. All rights reserved. -- WVMBootingImpl.mesaDIRECTORYCursor,File,FileTypes,Heap,HeraldWindow,MUsage,Process,ProcessPriorities,Space,System,TemporaryBooting,UserInput,Volume,WVMBooting;WVMBootingImpl: PROGRAM   IMPORTS Cursor, File, Heap, HeraldWindow, Process, Space, TemporaryBooting, UserInput, Volume  EXPORTS WVMBooting = {    zone: UNCOUNTED ZONE = Heap.systemZone;    procs: Procs ¬ NIL;  Procs: TYPE = LONG POINTER TO ProcsObject;  ProcsObject: TYPE = RECORD[next: Procs ¬ NIL,     c, b: WVMBooting.CheckpointProc ¬ NIL, r: WVMBooting.RollbackProc ¬ NIL,     clientData: LONG POINTER ¬ NIL];      -- file for outLoaded BOOLEAN  outloadCap: File.File = File.Create[Volume.systemID, 1, FileTypes.tUntypedFile];  -- space for outLoaded BOOLEAN  outLoaded: LONG POINTER TO BOOLEAN ¬ Space.ScratchMap[count: 1, usage: MUsage.debuggerOutloaded];  SetOutloaded: PROCEDURE [out: BOOLEAN] = INLINE {    outLoaded­ ¬ out; [] ¬ Space.CopyOut[outLoaded, [outloadCap, 0, 1]]};    Outloaded: PROCEDURE RETURNS [BOOLEAN] = INLINE {    [] ¬ Space.CopyIn[outLoaded, [outloadCap, 0, 1]]; RETURN[outLoaded­]};  InloadedTwice: PROC = {    HeraldWindow.AppendMessage["Inloaded twice! Click to boot."L];    Cursor.Set[mouseRed];    [] ¬ UserInput.WaitForConfirmation[];    Cursor.Set[textPointer];    TemporaryBooting.BootFromVolume[Volume.systemID]};    OutLoadInLoad: PUBLIC PROC[out, in: TemporaryBooting.BootLocation, switches: System.Switches ¬ System.defaultSwitches] = {    oldPriority: Process.Priority;    FOR p: Procs ¬ procs, p.next UNTIL p = NIL DO      IF p.c # NIL THEN p.c[p.clientData];       ENDLOOP;    --IF ~Riggle.RiggleWorldOk[] THEN Runtime.CallDebugger["Damn that riggle!!"L];    --IF ~Riggle.RiggleCheckVM[] THEN Runtime.CallDebugger["Damn that riggle!!"L];    SetOutloaded[TRUE];    oldPriority ¬ Process.GetPriority[];    Process.SetPriority[ProcessPriorities.priorityIOLow];    TemporaryBooting.OutLoadInLoad[      outloadLocation: NARROW[out, TemporaryBooting.BootLocation.file],      inloadLocation: in, pMicrocode: NIL, pGerm: NIL,       countGerm: 0, switches: switches];    Process.SetPriority[oldPriority];    IF ~Outloaded[] THEN InloadedTwice[] ELSE SetOutloaded[FALSE];    Cursor.Set[textPointer];    FOR p: Procs ¬ procs, p.next UNTIL p = NIL DO      IF p.r # NIL THEN p.r[p.clientData];       ENDLOOP };  RegisterProcs: PUBLIC PROC [c: WVMBooting.CheckpointProc ¬ NIL,     r: WVMBooting.RollbackProc ¬ NIL,     b: WVMBooting.CheckpointProc ¬ NIL,     clientData: LONG POINTER ¬ NIL] = {    FOR p: Procs ¬ procs, p.next UNTIL p = NIL DO      IF p.c = c AND p.b = b AND p.r = r AND p.clientData = clientData THEN EXIT;      REPEAT FINISHED => {        procs ¬ zone.NEW[ProcsObject ¬ [next: procs, c: c, r: r, b: b, clientData: clientData]]};      ENDLOOP};    Boot: PUBLIC PROC[boot: TemporaryBooting.BootLocation,     switches: System.Switches ¬ System.defaultSwitches]    RETURNS[rejection: LONG STRING] = {    ERROR };      Checkpoint: PUBLIC PROC[rejection: LONG STRING ¬ NIL] = {    ERROR };    Deregister: PUBLIC PROC [c: WVMBooting.CheckpointProc ¬ NIL,     r: WVMBooting.RollbackProc ¬ NIL, b: WVMBooting.CheckpointProc ¬ NIL,    clientData: LONG POINTER ¬ NIL] = {    -- found: BOOLEAN ¬ FALSE;    prev: Procs ¬ NIL;    p: Procs ¬ procs;    UNTIL p = NIL DO      IF p.c = c AND p.b = b AND p.r = r AND p.clientData = clientData THEN {        -- found ¬ TRUE;        IF prev = NIL THEN procs ¬ p.next ELSE prev.next ¬ p.next;	zone.FREE[@p]}      ELSE prev ¬ p;      p ¬ IF prev = NIL THEN procs ELSE prev.next;      ENDLOOP;    --IF ~found THEN ERROR--};    DeleteCheckpoint: PUBLIC PROC [volume: Volume.ID] = {    ERROR };      CallBootingProcs: PUBLIC PROC [rejection: LONG STRING] = {    ERROR };    UnloadWVMBooting: PUBLIC PROC[] = {    IF outLoaded = NIL THEN RETURN;    outLoaded ¬ Space.Unmap[outLoaded];    File.Delete[outloadCap] };    SetOutloaded[FALSE];    }..
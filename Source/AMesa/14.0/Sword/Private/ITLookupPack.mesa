-- File: ITLookupPack.mesa - last edit:-- Litman              21-Apr-87 19:13:23-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.DIRECTORY  Ascii USING [SP],  BcdDefs USING [GFIndex],  BcdOpsExtras USING [gfiOrigin],  Copier USING [Handle, Outer],  IC USING [GFFromControlLink, PCFromControlLink],  IG USING [StackZeroAddress],  IO USING [AllocFob, Char, Display, Line, Text, TopLevel, UserAbort, UserAborted],  IP USING [CheckStarted, Complete, ContextList, DisplayInMsg, Entry, EnumerateGF, Ep, Exit, FrameForHti, FreeContextList, GF, InOut, MakeFoo, Mode, NoAccessLink, NoPrevious, Normalize, NotRelocated, PC, Previous, SearchCtxForVal, SearchCtxList, StackFoo, StringToHti, TypeForSe],  IQ USING [FileMdi, FindFrame, FindMdi, GFrameMdi, InvalidFrame, LOrGType, ValidateF, ValidateGF],  IR USING [DIAbort, InConditional],  IS USING [Frame, GetModule, ReadPsb],  IT USING [BBHandle, BitAddress, ControlLink, CSEIndex, CTXIndex, CtxLink, EXOI, Foo, GFHandle, Handle, HTIndex, IncludedCTXIndex, ISEIndex, ModItem, LFHandle, MDIndex, nullPC, SEIndex, SignalDesc],  PrincOpsExtras USING [SignalDesc],  String USING [SubStringDescriptor],  SymbolOps USING [FindMdi, FindString, FirstCtxSe, Handle, NextSe, SearchContext, SubStringForHash],  Symbols USING [ContextLevel, CSENull, CTXIndex, CTXNull, DummyLink, HTNull, IncludedCTXIndex, IncludedCTXNull, ISENull, lG, lZ, MDIndex, MDNull, RecordSEIndex, RecordSENull, SENull, TransferMode],  SymbolTable USING [Handle, Missing],  WorldVMOps USING [LFlong, Long, Read];ITLookupPack: PROGRAM  IMPORTS Copier, IC, IG, IO, IP, IQ, IR, IS, SymbolOps, SymbolTable, WorldVMOps  EXPORTS IQ, IS, IP = {  OPEN IT;    Fail: PUBLIC SIGNAL [s: LONG STRING] = CODE;  NotFound: PUBLIC SIGNAL [s: LONG STRING] = Fail;  NotAnXfer: ERROR = CODE;  SearchingWrongContext: ERROR = CODE;  InCtx: PUBLIC PROCEDURE [h: Handle, id: IT.HTIndex, ctx: CTXIndex] RETURNS [Foo] = {    isei: IT.ISEIndex ¬ IP.SearchCtxList[h, id, ctx];    RETURN [IF isei = Symbols.ISENull THEN NIL ELSE IP.MakeFoo[h, isei]] };  InGF: PUBLIC PROC [h: Handle, id: IT.HTIndex, gf: GFHandle ¬ NIL, check: BOOLEAN ¬ TRUE] RETURNS [Foo] = {    mdi: Symbols.MDIndex;    IF gf = NIL THEN gf ¬ GFFromIContext[h];    mdi ¬ IQ.GFrameMdi[h, gf ! SymbolTable.Missing => GOTO bailout];    RETURN[GFFoo[h, id, gf, mdi, check]];    EXITS bailout => RETURN[NIL]};  GFFromIContext: PUBLIC PROC[h: Handle] RETURNS [GFHandle ¬ NIL] = {    ENABLE IQ.InvalidFrame, IP.NoAccessLink => GOTO badnews;    WITH h.iContext SELECT FROM      local => RETURN[IP.GF[h, lf]];      global => RETURN[gf];      process => RETURN[IP.GF[h, IS.Frame[h, IS.ReadPsb[h, psb]]]];      state => RETURN[IP.GF[h, lf]];      break => RETURN[bb.gf];      ENDCASE => RETURN[NIL];    EXITS badnews => RETURN[NIL]};          FrameFromIContext: PUBLIC PROC[h: Handle] RETURNS [LONG POINTER] = {    WITH h.iContext SELECT FROM      local => RETURN[lf];      global => RETURN[gf];      process => RETURN[IS.Frame[h, IS.ReadPsb[h, psb]]];      state => RETURN[lf];      break => RETURN[bb.gf];      ENDCASE;    RETURN[NIL]};          InMod: PUBLIC PROC [h: Handle, id: IT.HTIndex, mod: IT.HTIndex ¬ Symbols.HTNull] RETURNS [f: Foo] = {    gf: GFHandle ¬ NIL;    mdi: Symbols.MDIndex;    IF mod = Symbols.HTNull THEN mod ¬ IP.StringToHti[h, IS.GetModule[h]];    gf ¬ IP.FrameForHti[h, mod ! Fail => CONTINUE];    IF gf # NIL THEN { f ¬ InGF[h, id, gf, FALSE]; RETURN };    mdi ¬ IQ.FileMdi[h, mod ! SymbolTable.Missing => GOTO bailout];    f ¬ GFFoo[h, id, gf, mdi, TRUE       ! IP.NotRelocated => {	IO.Text[" Use Interface.importedVariable, not Interface$importedVariable\n"L, h];	GOTO bailout}];    EXITS bailout => RETURN[NIL] };  InLF: PUBLIC PROC [h: Handle, id: IT.HTIndex, lf: LFHandle ¬ NIL, check: BOOLEAN ¬ TRUE] RETURNS [f: Foo] = {    gf: GFHandle ¬ NIL;    exoi: EXOI;    list: CtxLink;    IF lf = NIL THEN lf ¬ FrameFromIContext[h];    IF lf = NIL THEN GOTO bailout;    IF IQ.LOrGType[h, lf] = global THEN RETURN[InGF[h, id, LOOPHOLE[lf], check]];    SELECT TRUE FROM      IP.Entry[h, lf, nullPC ! SymbolTable.Missing => GOTO bailout] => exoi ¬ entry;      IP.Exit[h, lf, nullPC] => exoi ¬ exit;      ENDCASE => exoi ¬ in;    gf ¬ IP.GF[h, lf ! IQ.InvalidFrame, IP.NoAccessLink => CONTINUE];    list ¬ IP.ContextList[h, IP.PC[h, lf], gf, search, exoi, lf];    IF list = NIL THEN RETURN[InGF[h, id, gf, check]];    f ¬ SearchList[h, id, list, lf, gf, exoi ! UNWIND => IP.FreeContextList[h, list]];    IP.FreeContextList[h, list];    IF f = NIL THEN f ¬ InGF[h, id, gf, check];    IF f = NIL THEN f ¬ TryCtx[h, id, [lf, 0], LOOPHOLE[2]]; -- finally try Predefined    EXITS bailout => RETURN[NIL] };      SearchList: PROC [h: Handle, id: IT.HTIndex, list: CtxLink, lf: LFHandle, gf: GFHandle, ex: EXOI] RETURNS [f: Foo ¬ NIL] = {    ba: BitAddress ¬ [base: lf, offset: 0]; -- assume in a local frame    level: Symbols.ContextLevel ¬ GetLevel[h, list];    ba.local ¬ (level # Symbols.lG) AND (level # Symbols.lZ); -- in a local frame    IF ~ba.local THEN ba.base ¬ gf; -- in a global frame    FOR i: CtxLink ¬ list, i.link UNTIL i = NIL DO      ba.useStack ¬ i.onStack;      SELECT GetLevel[h, i] FROM        Symbols.lZ => NULL; -- parameters of a catch phrase	= level => NULL; -- same level	< level => { -- list must be sorted by level, high to low	  level ¬ GetLevel[h, i];	  ba.local ¬ (level # Symbols.lG) AND (level # Symbols.lZ);	  SELECT TRUE FROM	    ~ba.local => ba.base ¬ gf; -- in a global frame	    IR.InConditional[h] => {	      «If we do this more than once, bad things will happen. Don't do this for now.	      IR.MakeOperand[h,  local 0 ];	      IR.DerefOperand[h,  to get to parent ];»	      ERROR IR.DIAbort };	    ENDCASE => { -- go up one static link	      CheckStaticLink[h, ex];	      ba.base ¬ lf ¬ WorldVMOps.Long[h.world, WorldVMOps.Read[h.world, lf]] }};	ENDCASE => ERROR SearchingWrongContext;      IF (f ¬ TryProcCtx[h, id, ba, i]) # NIL THEN EXIT;      ENDLOOP };        CheckStaticLink: PROC[h: IT.Handle, ex: EXOI] = {    IF ex = entry THEN { IO.Line[h, " static link not initialized!"L]; ERROR IO.UserAborted }};  GetLevel: PROC [h: Handle, i: CtxLink] RETURNS [Symbols.ContextLevel] = {    RETURN[WITH i SELECT FROM context => h.ctxb[ictx].level, empty => level, ENDCASE => ERROR]};  OnStack: PUBLIC PROC [h: Handle, id: IT.HTIndex, lf: LFHandle ¬ NIL, check: BOOLEAN ¬ TRUE] RETURNS [f: Foo] = {    WITH h.iContext SELECT FROM      break => RETURN[InBreakBlock[h, id, bb]];      ENDCASE;    IF lf = NIL THEN lf ¬ FrameFromIContext[h];    IF lf = NIL THEN RETURN[NIL];    -- IF h.search THEN RETURN[InLF[h, id, lf, check]];    IF IQ.ValidateGF[h, LOOPHOLE[lf]] THEN RETURN[InGF[h, id, LOOPHOLE[lf], check]];    f ¬ NIL;    DO      IF lf = NIL THEN EXIT;      IF (f ¬ InLF[h, id, lf, check ! SymbolTable.Missing => CONTINUE]) # NIL THEN EXIT;      lf ¬ IP.Previous[h, lf ! IP.NoPrevious => EXIT];      ENDLOOP };  LocalFrame: PROC [h: Handle, val: UNSPECIFIED, tm: Symbols.TransferMode] RETURNS [isei: IT.ISEIndex] = {    lf: LFHandle ¬ FrameFromIContext[h];    gf: GFHandle ¬ NIL;    list: CtxLink;    isei ¬ Symbols.ISENull;    IF lf = NIL THEN lf ¬ WorldVMOps.LFlong[h.world, h.swapData.lFrame];    IF ~IQ.ValidateF[h, lf].ok THEN RETURN;    gf ¬ IP.GF[h, lf ! IQ.InvalidFrame, IP.NoAccessLink => CONTINUE];    list ¬ IP.ContextList[h, IP.PC[h, lf], gf, search, in, NIL ! SymbolTable.Missing => GOTO bailout];    IF list = NIL THEN RETURN;    isei ¬ SearchListForValue[h, val, tm, list, lf ! UNWIND => IP.FreeContextList[h, list]];    IP.FreeContextList[h, list];    EXITS bailout => RETURN[Symbols.ISENull]};  SearchListForValue: PROC [h: Handle, val: UNSPECIFIED, tm: Symbols.TransferMode, list: CtxLink, lf: LFHandle] RETURNS [isei: IT.ISEIndex] = {    isei ¬ Symbols.ISENull;    FOR i: CtxLink ¬ list, i.link UNTIL i = NIL DO      WITH i SELECT FROM        context => IF ictx # Symbols.IncludedCTXNull AND (isei ¬ IP.SearchCtxForVal[h, val, ictx, tm]) # Symbols.ISENull THEN EXIT;	ENDCASE;      ENDLOOP };  IseiFromBreakCtx: PUBLIC PROC [h: Handle, id: IT.HTIndex] RETURNS [isei: IT.ISEIndex ¬ Symbols.ISENull] = {    list: CtxLink;    WITH ctx: h.iContext SELECT FROM      break => list ¬ IP.ContextList[h, ctx.bb.pc, ctx.bb.gf, search, ctx.bb.bt.ex];      ENDCASE => ERROR SearchingWrongContext;    IF list = NIL THEN RETURN;    -- search the list of PC contexts for this IT.HTIndex    FOR i: CtxLink ¬ list, i.link UNTIL i = NIL OR isei # Symbols.ISENull DO      WITH i SELECT FROM context => isei ¬ IP.SearchCtxList[h, id, ictx]; ENDCASE;      ENDLOOP;    IP.FreeContextList[h, list] };  InBreakBlock: PROC [h: Handle, id: IT.HTIndex, bb: BBHandle] RETURNS [f: Foo] = {    list: CtxLink ¬ IP.ContextList[h, bb.pc, bb.gf, search, bb.bt.ex];    IF list # NIL THEN {      f ¬ SearchList[h, id, list, NIL, bb.gf, bb.bt.ex ! 	IP.NotRelocated => RESUME[NIL];	UNWIND => IP.FreeContextList[h, list]];      IP.FreeContextList[h, list]};    IF f = NIL THEN f ¬ InGF[h, id, bb.gf, FALSE];    -- IR.MakeOperand[h, f]; fucks things up -- };  Signal: PUBLIC PROC [h: Handle, cl: SignalDesc] RETURNS [isei: IT.ISEIndex] = {    RETURN[Xfer[h, LOOPHOLE[cl], signal]]};  Procedure: PUBLIC PROC [h: Handle, cl: ControlLink] RETURNS [isei: IT.ISEIndex] = {    RETURN[Xfer[h, cl, proc]]};      Xfer: PROC [h: Handle, cl: ControlLink, tm: Symbols.TransferMode] RETURNS [isei: IT.ISEIndex] = {    ownGfi: BcdDefs.GFIndex = BcdOpsExtras.gfiOrigin;    gf: GFHandle = IC.GFFromControlLink[h, cl];    syms: ModItem;    val: Symbols.DummyLink = [      gfi: ownGfi,       ep: SELECT tm FROM	proc => IP.Ep[h, IC.PCFromControlLink[h, cl], gf].ep,	ENDCASE => LOOPHOLE[cl, PrincOpsExtras.SignalDesc].index];    IF gf = NIL THEN RETURN[Symbols.ISENull];    [] ¬ IQ.GFrameMdi[h, gf ! SymbolTable.Missing => GOTO bailout];    syms ¬ IQ.FindFrame[h, gf];    SELECT TRUE FROM      (isei ¬ IP.SearchCtxForVal[h, val, syms.outerCtx, tm]) # Symbols.ISENull => NULL;      (isei ¬ IP.SearchCtxForVal[h, val, syms.importCtx, tm]) # Symbols.ISENull => NULL;      (isei ¬ IP.SearchCtxForVal[h, val, syms.directoryCtx, tm]) # Symbols.ISENull => NULL;      (isei ¬ LocalFrame[h, val, tm]) # Symbols.ISENull => NULL;      ENDCASE => RETURN[Symbols.ISENull];    EXITS bailout => RETURN[Symbols.ISENull]};  XferCtx: PUBLIC PROC [h: Handle, sei: SEIndex, base: LONG POINTER, io: IP.InOut] RETURNS [f: Foo] = {    IF sei = Symbols.SENull THEN RETURN[NIL];    f ¬ IO.AllocFob[h];     f.xfer ¬ TRUE;    f.there ¬ TRUE;    f.displayFieldsOfRecordsAs ¬ variables;    f.addr.base ¬ base;    WITH h.seb[IP.TypeForSe[h, sei]] SELECT FROM      transfer => {	csei: IT.CSEIndex ¬ IF io = in THEN typeIn ELSE typeOut;	IF csei = Symbols.SENull THEN { f.addr.base ¬ NIL; f.tsei ¬ Symbols.CSENull }	ELSE {	  f.tsei ¬ csei;	  WITH rse: h.seb[csei] SELECT FROM	    record => [f.words, f.bits] ¬ IP.Normalize[rse.length];	    ENDCASE => ERROR}};      ENDCASE => ERROR NotAnXfer};  StateCtx: PUBLIC PROCEDURE [h: Handle, sei: SEIndex, io: IP.InOut] RETURNS [f: Foo] = {    f ¬ XferCtx[h, sei, NIL, io];    IF f = NIL OR f.tsei = Symbols.RecordSENull THEN RETURN;    IP.StackFoo[h, f];    f.addr.useStack ¬ TRUE };  GFFoo: PROC [h: Handle, hti: IT.HTIndex, gf: GFHandle, mdi: MDIndex, check: BOOLEAN] RETURNS [f: Foo] = {    ba: BitAddress;    syms: ModItem = IQ.FindMdi[h, mdi];    IF gf # NIL AND check THEN [] ¬ IP.CheckStarted[h, gf];    ba ¬ [base: gf, offset: 0, local: FALSE];    IF (f ¬ TryCtx[h, hti, ba, syms.outerCtx]) # NIL THEN RETURN;    IF (f ¬ SearchImportCtx[h, hti, ba, syms.importCtx]) # NIL THEN RETURN;    IF (f ¬ SearchDirectoryCtx[h, hti, ba, syms.directoryCtx, mdi]) # NIL THEN RETURN;    f ¬ TryCtx[h, hti, ba, LOOPHOLE[2]]}; -- finally try Predefined   SearchDirectoryCtx: PROC [h: Handle, hti: IT.HTIndex, ba: BitAddress, ictx: Symbols.CTXIndex, mdi: MDIndex] RETURNS [f: Foo] = {    mdRoot: MDIndex;    target: CTXIndex;    sei, isei: IT.ISEIndex;    ss: String.SubStringDescriptor;    found: BOOLEAN;    Search: PROC [base: SymbolTable.Handle] = {      newMdi: Symbols.MDIndex = SymbolOps.FindMdi[base, h.mdb[mdRoot].stamp];      ihti: IT.HTIndex ¬ SymbolOps.FindString[base, @ss];      found ¬ ihti # Symbols.HTNull AND newMdi # Symbols.MDNull;      IF ~found THEN RETURN;      FOR i: IncludedCTXIndex ¬ base.mdb[newMdi].ctx, base.ctxb[i].chain UNTIL i = Symbols.CTXNull DO	IF base.ctxb[i].map = target THEN { isei ¬ SymbolOps.SearchContext[base, ihti, i]; EXIT };	REPEAT FINISHED => isei ¬ Symbols.ISENull;	ENDLOOP;      found ¬ (isei # Symbols.ISENull) };    IF ictx = Symbols.CTXNull THEN RETURN[NIL];    IF (f ¬ TryCtx[h, hti, ba, ictx]) # NIL THEN RETURN;    IP.Complete[h, ictx];    SymbolOps.SubStringForHash[h.sym, @ss, hti];    FOR sei ¬ SymbolOps.FirstCtxSe[h.sym, ictx], SymbolOps.NextSe[h.sym, sei] UNTIL sei = Symbols.ISENull DO      ictx ¬ GetCtx[h, sei];      WITH h.ctxb[ictx] SELECT FROM	included => { mdRoot ¬ module; target ¬ map };	ENDCASE => LOOP;      Copier.Outer[h.sym, mdi, Search];      IF ~found THEN LOOP;      IF (isei ¬ IP.SearchCtxList[h, hti, ictx]) = Symbols.ISENull THEN EXIT;      SELECT IP.Mode[h, isei] FROM	refVal, refProc => NULL;	ENDCASE => f ¬ IP.MakeFoo[h, isei, ba];      EXIT;      ENDLOOP };  SearchImportCtx: PROC [h: Handle, hti: IT.HTIndex, ba: BitAddress, ictx: Symbols.CTXIndex] RETURNS [f: Foo] = {    isei: IT.ISEIndex;    IF ictx = Symbols.CTXNull THEN RETURN[NIL];    IF (f ¬ TryCtx[h, hti, ba, ictx]) # NIL THEN RETURN;    IP.Complete[h, ictx];    FOR isei ¬ SymbolOps.FirstCtxSe[h.sym, ictx], SymbolOps.NextSe[h.sym, isei] UNTIL isei = Symbols.ISENull DO      IF (f ¬ TryCtx[h, hti, ba, GetCtx[h, isei]]) # NIL THEN EXIT;      ENDLOOP };  GetCtx: PROC [h: Handle, isei: IT.ISEIndex] RETURNS [ctx: Symbols.CTXIndex] = {    csei: IT.CSEIndex ¬ IP.TypeForSe[h, isei];    DO      WITH h.seb[csei] SELECT FROM	definition => RETURN[defCtx];	record => RETURN[fieldCtx];	ref => csei ¬ IP.TypeForSe[h, refType];	long => csei ¬ IP.TypeForSe[h, rangeType];	ENDCASE => RETURN[Symbols.CTXNull];      ENDLOOP };  TryCtx: PROC [h: Handle, hti: IT.HTIndex, ba: BitAddress, ctx: CTXIndex] RETURNS [f: Foo] = {    isei: IT.ISEIndex = IP.SearchCtxList[h, hti, ctx];    IF IO.UserAbort[h] THEN ERROR IO.UserAborted;    IF isei = Symbols.ISENull THEN RETURN[NIL];    IF ba.useStack THEN ERROR SearchingWrongContext;    RETURN[IP.MakeFoo[h, isei, ba]] };      TryProcCtx: PROC [h: Handle, hti: IT.HTIndex, ba: BitAddress, list: CtxLink] RETURNS [f: Foo] = {    isei: IT.ISEIndex = IP.SearchCtxList[h, hti, WITH list SELECT FROM context => ictx, ENDCASE => Symbols.CTXNull];    IF IO.UserAbort[h] THEN ERROR IO.UserAborted;    IF isei = Symbols.ISENull THEN RETURN[NIL];    IF ba.useStack AND IP.Mode[h, isei] = val THEN {      ba.base ¬ IG.StackZeroAddress[h];      IF list.indirect THEN ba.base ¬ WorldVMOps.LFlong[h.world, WorldVMOps.Read[h.world, ba.base]] };    RETURN[IP.MakeFoo[h, isei, ba]]};  FindVar: PUBLIC PROC [h: Handle, var: LONG STRING] = {    hti: IT.HTIndex ¬ IP.StringToHti[h, var];    f: Foo;    gf: GFHandle;    SearchOne: PROC [g: GFHandle] RETURNS [BOOLEAN] = {      IO.TopLevel[h];      IF (f ¬ InGF[h, hti, g]) # NIL THEN {gf ¬ g; RETURN[TRUE]};      RETURN[FALSE]};    [] ¬ IP.EnumerateGF[h, SearchOne];    IF f = NIL THEN SIGNAL Fail[var];    f.hti ¬ Symbols.HTNull;     IO.Char[h, Ascii.SP];     IO.Display[h, f, TRUE];    IP.DisplayInMsg[h, gf, NIL] };  }.
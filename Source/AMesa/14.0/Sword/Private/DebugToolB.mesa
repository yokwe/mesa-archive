-- File: DebugToolB.mesa - last edit:-- Litman              22-Apr-87 18:13:02-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.DIRECTORY  AMEvents USING [GetEvents],  AMModel USING [ContextClass, IsNullContext, MostRecentNamedContext, nullContext],  AMProcess USING [AddProcessToList, DeleteProcessList, Freeze, GetProcesses, MergeProcessLists, ProcessList, Thaw],  AMProcessBasic USING [StateArray],  DebugToolOps USING [LongNumber, Number, Output],  DObjet USING [Hand, Object],  Format USING [Blank, CR, Line, Number, Text],  PSB USING [PsbIndex],  String USING [Empty],  WorldVM USING [BadWorld, InvalidateWorld, LocalWorld, NoWorld, OutloadWorld, RemoteWorld, World],  WorldVMOps USING [GetType];DebugToolB: PROGRAM   IMPORTS AMEvents, AMModel, AMProcess, DebugToolOps, Format, String, WorldVM, WorldVMOps  EXPORTS DebugToolOps = PUBLIC {  CantDebug: ERROR = CODE;  CreateDObjet: PROC[zone: UNCOUNTED ZONE] RETURNS[d: DObjet.Hand] = {    d ¬ zone.NEW[DObjet.Object ¬ [zone: zone]] };  DeleteDObjet: PROC[d: DObjet.Hand] RETURNS[nil: DObjet.Hand] = {    zone: UNCOUNTED ZONE = d.zone;    zone.FREE[@d];    RETURN[NIL] };      UnWorld: PROC[d: DObjet.Hand] = {    IF d.World # NIL THEN       SELECT WorldVMOps.GetType[d.World] FROM	remote => WorldVM.InvalidateWorld[d.World];	ENDCASE;    d.World ¬ WorldVM.NoWorld[] };  ChangeWorld: PROC[d: DObjet.Hand] RETURNS[okToChange: BOOLEAN] = {    IF d.processes # NIL AND ~DoThaw[d] THEN RETURN[FALSE]    ELSE { UnWorld[d]; RETURN [TRUE] }};      NoneDebug: PROC[d: DObjet.Hand] = {    IF ~ChangeWorld[d] THEN ERROR CantDebug };    LocalDebug: PROC[d: DObjet.Hand] = {    IF ~ChangeWorld[d] THEN ERROR CantDebug;    d.World ¬ WorldVM.LocalWorld[];    d.rootContext ¬ [world: d.World, classroom: world[]];    AMEvents.GetEvents[d.World, NIL, NIL] };  OutloadDebug: PROC[d: DObjet.Hand] = {    IF ~ChangeWorld[d] THEN ERROR CantDebug;    d.World ¬ WorldVM.OutloadWorld[d.client, NIL, d.tty ! WorldVM.BadWorld => ERROR CantDebug];    d.rootContext ¬ [world: d.World, classroom: world[]];    AMEvents.GetEvents[d.World, NIL, NIL] };  RemoteDebug: PROC[d: DObjet.Hand] = {    IF ~ChangeWorld[d] THEN ERROR CantDebug;    d.World ¬ WorldVM.RemoteWorld[d.client, NIL, d.tty ! WorldVM.BadWorld => ERROR CantDebug];    d.rootContext ¬ [world: d.World, classroom: world[]];    AMEvents.GetEvents[d.World, NIL, NIL] };  DontFreezeLocal: PROC[d: DObjet.Hand] = {    Format.Line[DebugToolOps.Output, "\nYou dont want to freeze entire local world!"L, d]};  StateArrayAll: PROC RETURNS[a: AMProcessBasic.StateArray ¬ ALL[TRUE]] = {};  StateArrayReady: PROC RETURNS[a: AMProcessBasic.StateArray ¬ ALL[FALSE]] = {    a[ready] ¬ TRUE };      FreezeAll: PROC[d: DObjet.Hand] RETURNS[none: BOOLEAN ¬ TRUE] = {    SELECT d.world FROM      none => NULL;      local => DontFreezeLocal[d];      ENDCASE => {	Format.Line[DebugToolOps.Output, "\nFreeze all processes..."L, d];	none ¬ Merge[d, AMProcess.GetProcesses[d.rootContext, StateArrayAll[]]]}};  FreezeReady: PROC[d: DObjet.Hand] RETURNS[none: BOOLEAN ¬ TRUE] = {    SELECT d.world FROM      none => NULL;      local => DontFreezeLocal[d];      ENDCASE => {	Format.Line[DebugToolOps.Output, "\nFreeze ready processes..."L, d];	none ¬ Merge[d, AMProcess.GetProcesses[d.rootContext, StateArrayReady[]]]}};  FreezePSBI: PROC[d: DObjet.Hand] RETURNS[none: BOOLEAN ¬ TRUE] = {    process: AMProcess.ProcessList ¬ AMProcess.AddProcessToList[NIL, [d.World, d.psbIndex]];    SELECT d.world FROM      none => NULL;      ENDCASE => {	Format.Text[DebugToolOps.Output, "\nFreeze process "L, d];	DebugToolOps.Number[d.psbIndex, d.processRadix];	Format.CR[DebugToolOps.Output, d];	AMProcess.Freeze[process, d.rootContext];		none ¬ Merge[d, process] }};      CheckContext: PROC[d: DObjet.Hand] = {    d.modelContext ¬ SELECT TRUE FROM      d.world = none => AMModel.nullContext,      String.Empty[d.context] => d.rootContext,      ENDCASE => AMModel.MostRecentNamedContext[d.context, d.rootContext]};      FreezeContext: PROC[d: DObjet.Hand] RETURNS[none: BOOLEAN ¬ TRUE] = {    Format.Text[DebugToolOps.Output, "\nFreeze processes inside "L, d];    IF d.context # NIL THEN Format.Line[DebugToolOps.Output, d.context, d];    CheckContext[d];    IF AMModel.IsNullContext[d.modelContext] THEN Format.Line[DebugToolOps.Output, "Invalid context!"L, d]    ELSE {      IF (d.world # local OR AMModel.ContextClass[d.modelContext] # world)       THEN none ¬ Merge[d, AMProcess.GetProcesses[d.modelContext, StateArrayAll[]]]      ELSE DontFreezeLocal[d]}};      Merge: PROC[d: DObjet.Hand, processList: AMProcess.ProcessList] RETURNS[none: BOOLEAN ¬ TRUE] = {    newList: AMProcess.ProcessList = AMProcess.MergeProcessLists[d.processes, processList];    Format.Line[DebugToolOps.Output, "Additional frozen processes: "L, d];    FOR scratch: AMProcess.ProcessList ¬ newList, scratch.next UNTIL scratch = NIL DO      found: BOOLEAN ¬ FALSE;      FOR scratch2: AMProcess.ProcessList ¬ d.processes, scratch2.next UNTIL scratch2 = NIL DO	IF scratch2.p = scratch.p THEN found ¬ TRUE;	ENDLOOP;      IF ~found THEN {        DebugToolOps.LongNumber[scratch.p.psbi, d.processRadix]; 	Format.Blank[DebugToolOps.Output, 1, d];	none ¬ FALSE };      ENDLOOP;    IF none THEN Format.Line[DebugToolOps.Output, "none"L, d];     Format.CR[DebugToolOps.Output, d];    [] ¬ AMProcess.DeleteProcessList[d.processes];    [] ¬ AMProcess.DeleteProcessList[processList];    d.processes ¬ newList };    CountActions: PROC[d: DObjet.Hand] RETURNS[count: CARDINAL ¬ 0] = {    FOR i: PSB.PsbIndex IN PSB.PsbIndex DO      IF d.action[i] THEN count ¬ count + 1;      ENDLOOP};        ThawAll: PROC[d: DObjet.Hand] = {[] ¬ DoThaw[d]};  DoThaw: PROC[d: DObjet.Hand] RETURNS[BOOLEAN] = {    count: CARDINAL = CountActions[d];    Format.Line[DebugToolOps.Output, "\nThaw all processes..."L, d];    IF count # 0 THEN {      Format.Text[DebugToolOps.Output, "\nThere are still "L, d];      Format.Number[DebugToolOps.Output, count, [], d];      Format.Line[DebugToolOps.Output, " action areas for frozen processes"L, d];      RETURN [FALSE]}    ELSE {      AMProcess.Thaw[d.processes];      d.processes ¬ AMProcess.DeleteProcessList[d.processes];      Format.Line[DebugToolOps.Output, "done"L, d];      RETURN [TRUE]}};  }.
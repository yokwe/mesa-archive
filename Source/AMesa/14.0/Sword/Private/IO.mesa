-- Copyright (C) 1986  by Xerox Corporation. All rights reserved. -- IO.mesaDIRECTORYAlloc,Ascii,Context,CPSwapDefs, -- external state vector definitionFormat,Inline,IT,Menu,Stream,String,Supervisor,Symbols,SymbolTable,TTY;IO: DEFINITIONS IMPORTS Format, Inline, Stream = {  OPEN IT;  «====================================================  PROCEDURES====================================================»  -- DebugOps    -- BEGIN zone sensitive  AllocFob: PROC[h: Handle] RETURNS [f: Foo];  FreePages: PROC [LONG POINTER];  Node: PROC [h: Handle, n: CARDINAL] RETURNS [LONG POINTER] = INLINE {    RETURN[zone.NEW[WordSeq[n]]]};  Pages: PROC [nPages: CARDINAL] RETURNS [LONG POINTER];  FreeString, FreeNode: PROC [h: Handle, p: LONG POINTER] = INLINE {    IF p # NIL THEN zone.FREE[@p]};  MakeString: PROC [h: Handle, nChars: CARDINAL] RETURNS [LONG STRING] = INLINE {    RETURN[zone.NEW[StringBody[nChars]]]};  -- END zone sensitive  DisplayFoo: FooProc;  Display: PROC [h: Handle, f: Foo, rec: BOOLEAN ¬ FALSE];  Zero: PROC [p: LONG POINTER, l: CARDINAL] = INLINE {    IF l = 0 THEN RETURN;    p­ ¬ 0;    Inline.LongCOPY[from: p, to: p+1, nwords: l-1] --ok-- };    Interpret: PROC [it: Handle,    exp: LONG STRING, results: FooProc ¬ DisplayFoo,     targetType: CSEIndex ¬ Symbols.typeANY];  IntConditional: PROCEDURE [h: Handle, exp: LONG STRING];  IntString: PROC [Handle, LONG STRING];  Numeric: PROC [Handle, LONG STRING] RETURNS [BOOLEAN];  StringToModule: PROC [Handle, LONG STRING] RETURNS [LONG STRING];  StringExpToNum: PROC [h: Handle, exp: LONG STRING, radix: CARDINAL]     RETURNS [UNSPECIFIED];  StringExpToLNum: PROC [h: Handle, exp: LONG STRING, radix: CARDINAL]     RETURNS [LONG UNSPECIFIED];  StringExpToOctal: PROC [Handle, LONG STRING] RETURNS [CARDINAL];  StringExpToLOctal: PROC [Handle, LONG STRING] RETURNS [LONG CARDINAL];  StringExpToDecimal: PROC [Handle, LONG STRING] RETURNS [INTEGER];  StringExpToLDecimal: PROC [Handle, LONG STRING] RETURNS [LONG INTEGER];  ParseError: SIGNAL [errorLoc: CARDINAL];  SyntaxError: SIGNAL [errorLoc: CARDINAL];  InvalidCharacter: SIGNAL [index: CARDINAL];  InvalidNumber: SIGNAL [f: Foo];  CommandNotAllowed: SIGNAL;  InvalidAddress: ERROR [address: LONG POINTER];  NotImplemented: SIGNAL [msg: LONG STRING];  TableOverflow: SIGNAL;  LiteralProblem: ERROR;    Abort, Proceed, Kill, Quit: SIGNAL;   -- CPOut     UserAborted: SIGNAL;  UserAbort: PROC[Handle] RETURNS[BOOLEAN];     SetOutput: PROC [Handle, TTY.Handle];    NewLine: PROC[h: Handle] RETURNS [BOOLEAN] = INLINE {RETURN[h.newLine]};    Blanks: PROCEDURE [h: Handle, n: CARDINAL];      Char: PROCEDURE [h: Handle, c: CHARACTER];    Line: PROCEDURE [h: Handle, s: LONG STRING] = INLINE {    Text[s, h]; EOL[h]};    EOL: PROC[h: Handle];  Text: Format.StringProc;  NonAbortableText: Format.StringProc;  SubString: PROCEDURE [h: Handle, s: String.SubString];    OutNumber: PROCEDURE [h: Handle, n: UNSPECIFIED,     f: Format.NumberFormat] = INLINE {Format.Number[Text, n, f, h]};      Octal: PROCEDURE [h: Handle, n: UNSPECIFIED] = INLINE {    Format.Octal[Text, n, h]};      Decimal: PROCEDURE [h: Handle, n: INTEGER] = INLINE {    Format.Decimal[Text, n, h]};      LongNumber: PROCEDURE [h: Handle, n: LONG UNSPECIFIED,     f: Format.NumberFormat] = INLINE {Format.LongNumber[Text, n, f, h]};      LongOctal: PROCEDURE [h: Handle, n: LONG UNSPECIFIED] = INLINE {    Format.LongOctal[Text, n, h]};    LongDecimal: PROCEDURE [h: Handle, n: LONG INTEGER] = INLINE {    Format.LongDecimal[Text, n, h]};  -- CPInit  AddStatisticsProcedure: PROCEDURE [Handle, PROCEDURE];  MCR: Menu.MCRType;  ShowRep: CommandProc;  Redisplay: PROCEDURE[h: Handle]; -- redisplay original swap reason  TopLevel: PROCEDURE[h: Handle]; -- resets Fobs and checks Symbol Table  CPLock: MONITORLOCK;  warning: CoreSwapMessages;  AcquireLoadState: PROCEDURE [h: Handle, newSession: BOOLEAN];  AddressFault: PROCEDURE [h: Handle, type: CPSwapDefs.StorageFaultType,     psb: Process];  Break: PROCEDURE [h: Handle, lf: LFHandle];  ShowBreak: PROCEDURE [h: Handle, lf: LFHandle]     RETURNS [bp: BBHandle];  CleanUp: PROCEDURE [Handle, Supervisor.Event];  CoreSwapMsg: PROCEDURE [Handle, CoreSwapMessages];  CoreSwap: PROCEDURE [h: Handle, why: CPSwapDefs.SwapReason];  FlushCaches: PROCEDURE [Handle, Supervisor.Event];  FlushCoreCache: PROCEDURE[h: Handle];  FlushLoadState: PROCEDURE[h: Handle];  GetUserMessage: PROCEDURE[h: Handle];  InvalidateNameCache: PROCEDURE[h: Handle];  StopBackgroundNameProcess: PROCEDURE[h: Handle];  NotifyNameLookupProcess: PROCEDURE [Handle, Supervisor.Event];  ProcessVMMapLog: PROCEDURE [h: Handle, newSession: BOOLEAN];  ReleaseBootFile: PROCEDURE[h: Handle];  SetupBootFile: PROCEDURE[h: Handle];  StartTTY: PROCEDURE[h: Handle];  StopTeledebugging: PROCEDURE[h: Handle];  StopTTY: PROCEDURE[h: Handle];  SystemError: PROCEDURE[h: Handle, bug: CARDINAL];  EndSession: PROCEDURE[h: Handle];  UCSHandler: PROCEDURE[h: Handle,     signalError: CPSwapDefs.SignalError,     args: LFHandle, signal: SignalDesc];  NewSession: ERROR;  -- Files: PROCEDURE;  -- SetupFileWindows: PROCEDURE;  -- MemCache: PROCEDURE [file: File.File];  StartDebugger: PROCEDURE[h: Handle];  MyContextType: Context.Type;    -- Things that maybe shouldn't be exported.  symboltable: SymbolTable.Handle;  alloc: Alloc.Handle;  zone: UNCOUNTED ZONE;  options: Options;    }.
-- File: ITSymsCold.mesa - last edit:-- Litman              22-Apr-87 15:11:39-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.DIRECTORY  Alloc USING [Handle, Reset],  AMLoadstate USING [AcquireBcd, Error, GFHandle, Handle, Index, MapCgfiToMth, MapRealToConfig],  Ascii USING [CR],  BcdDefs USING [Base, FTIndex, FTNull, FTSelf, MTIndex, NameRecord, NullName, NullVersion, VersionID, VersionStamp],  BcdDefsExtras USING [GFTVersionID],  BcdOps USING [BcdBase, MTHandle, NameString, SGHandle],  BcdOpsExtras USING [FTBaseFromBcd, MTBaseFromBcd, NameStringFromBcd, SGBaseFromBcd],  Copier USING [CopierInit, CreateFileTable, EnterFileSegment, FileInit, FileQuit, FindExternalCtx, FindMdEntry, Handle, Outer],  Environment USING [PageCount],  Event USING [fileSystem],  EventTypes USING [newSearchPath],  IE USING [],  IO USING [alloc, Blanks, Char, FreePages, Line, Pages, StringExpToLDecimal, symboltable, Text, zone],  IP USING [Fail, HtiForFrame, HtiToString, InMod, ResetPCache, StringToHti, TypeForSe],  IQ USING [CheckGF, FindFrame, FindMdi, Head],  IR USING [ResetLongs],  IS USING [CompareSes, WriteError],  IT USING [Foo, GFHandle, Handle, ModItem, MaxModCnt, MaxModuleString, ModCache],  IZ USING [Interpreters],  MFile USING [AddNotifyProc, Error, Filter, Handle, maxNameLength, NotifyProc, ReadOnly, Release, RemoveNotifyProc],  MSegment USING [Address, CopyIn, Create, Delete, Error, Handle, SwapUnitOption],  Process USING [Detach],  Runtime USING [GetBuildTime],  String USING [AppendString, AppendSubString, SubStringDescriptor],  Supervisor USING [AddDependency, AgentProcedure, CreateSubsystem, DeleteSubsystem, RemoveDependency, SubsystemHandle],  SymbolOps USING [Create, EnterString, Finalize, FindString, Handle, PrefillMesaSymbols, Reset, SubStringForHash],  Symbols USING [Base, HTIndex, HTNull, MDIndex, SEIndex],  SymbolTable USING [Handle, Missing, NullHandle],  Time USING [Append, Unpack],  WorldVMOps USING [GetLoadstate, GFshort];ITSymsCold: MONITOR LOCKS l USING l: Lock  IMPORTS Alloc, AMLoadstate, BcdOpsExtras, Copier, Event, IO, IP, IQ, IR, IS, IZ, MFile, MSegment, Process, Runtime, String, Supervisor, SymbolOps, SymbolTable, Time, WorldVMOps  EXPORTS IE, IQ = {    -- constants  swapUnits: MSegment.SwapUnitOption = [uniform[4]];  altoBias: CARDINAL = 1;  anyVersion: BcdDefs.VersionStamp = BcdDefs.NullVersion;  myVersion: BcdDefs.VersionStamp ¬ [net: 0, host: 0, time: Runtime.GetBuildTime[]];    -- locks  generalLock: MONITORLOCK;  hashLock: MONITORLOCK;  Lock: TYPE = LONG POINTER TO MONITORLOCK;    -- hashes  hashes: Hashes ¬ NIL; -- contains hashes for files that are waiting for MFile notification  Hashes: TYPE = LONG POINTER TO HashesObject;  HashesObject: TYPE = RECORD [seq: SEQUENCE length: CARDINAL OF Symbols.HTIndex];    -- used for temporarily copying in a bcd  bcdPages: Environment.PageCount ¬ 4;  bcdSeg: MSegment.Handle ¬ MSegment.Create[release: [], pages: bcdPages, swapInfo: [uniform[1]]];  bcd: BcdOps.BcdBase ¬ MSegment.Address[bcdSeg];    searchPathChanged: Supervisor.SubsystemHandle;    AddItem: PUBLIC PROC[h: IT.Handle, gf: IT.GFHandle] RETURNS [syms: IT.ModItem] = {    mth: BcdOps.MTHandle;    bcd: BcdOps.BcdBase;    seg: MSegment.Handle;    fgt: BOOLEAN;    hti: Symbols.HTIndex = IP.HtiForFrame[h, gf];    IF LookupHti[@hashLock, hti] THEN ERROR SymbolTable.Missing[SymbolTable.NullHandle];    [mth, bcd] ¬ MthForFrame[h, gf];    IF mth = NIL OR bcd = NIL THEN CacheFailure[h, hti];    [seg, fgt] ¬ FindSymbolSegment[h, mth, bcd];     IF seg = NIL THEN CacheFailure[h, hti];    syms ¬ CacheItem[h, gf, seg, mth, hti, fgt]};  AppendComplaint: PUBLIC PROC[msg, file: LONG STRING, have, want: LONG CARDINAL] = {    String.AppendString[msg, "Cant use "L];     String.AppendString[msg, file];    String.AppendString[msg," of "L];     AppendTime[msg, have];    IF want = 0 THEN RETURN;    String.AppendString[msg," instead of "L];    AppendTime[msg, want]};  AppendTime: PROC[msg: LONG STRING, time: LONG CARDINAL] = INLINE {     Time.Append[msg, Time.Unpack[LOOPHOLE[time]]]};      AttachOpaque: PUBLIC PROC[h: IT.Handle, type, file: LONG STRING] = {    opaquesei: Symbols.SEIndex;    item, mod: Symbols.HTIndex;    f: IT.Foo;    [mod, item] ¬ GetNames[h, type];    IF mod = Symbols.HTNull OR item = Symbols.HTNull THEN RETURN;    f ¬ IP.InMod[h, item, mod];    IF f = NIL THEN {      IO.Blanks[h, 1]; IO.Text[type];       IS.WriteError[h, notFound, FALSE]; RETURN};    opaquesei ¬ f.tsei;    f ¬ IP.InMod[h, item, IP.StringToHti[h, file]];    IF f = NIL OR IS.CompareSes[h, opaquesei, f.tsei] THEN {      itemstring: LONG STRING ¬ [IT.MaxModuleString];      IP.HtiToString[h, item, itemstring];      IO.Blanks[h, 1]; IO.Text[file, h];       IO.Char[h, '.]; IO.Text[itemstring, h];      IS.WriteError[h, notFound, FALSE]; RETURN};    WITH h.seb[IP.TypeForSe[h, opaquesei]] SELECT FROM      opaque => { -- here we completely munge the CSERecord        lengthKnown ¬ FALSE;        length ¬ LAST[CARDINAL];        id ¬ LOOPHOLE[f.tsei]};      ENDCASE => {        IO.Blanks[h, 1]; IO.Text[type, h];         IO.Text[" not opaque!"L, h]; RETURN}};   AttachSymbols: PUBLIC PROC[h: IT.Handle, frame, file: LONG STRING] = {    gf: IT.GFHandle = LOOPHOLE[IO.StringExpToLDecimal[h, frame]];    hti: Symbols.HTIndex;    IQ.CheckGF[h, gf];    hti ¬ IP.HtiForFrame[h, gf];    [] ¬ RemoveHti[@hashLock, h.sym, hti, TRUE];    [] ¬ OpenFile[h, gf, file, hti ! SymbolTable.Missing => { Complain[h, file, symbols]; CONTINUE }]};    OpenFile: PUBLIC PROC[h: IT.Handle, gf: IT.GFHandle, file: LONG STRING, hti: Symbols.HTIndex] RETURNS [syms: IT.ModItem] = {    -- This proc opens a file. The hti is for the file. The gf may be NIL.    filename: LONG STRING = [MFile.maxNameLength];    mfile: MFile.Handle;    seg: MSegment.Handle;    fgt: BOOLEAN;    mth: BcdOps.MTHandle;    IF LookupHti[@hashLock, hti] THEN ERROR SymbolTable.Missing[SymbolTable.NullHandle];    String.AppendString[filename, file];    CheckForExtension[h: h, name: filename];    [mfile,] ¬ MFileAndCheckVersion[h, filename, anyVersion, TRUE];    IF mfile = NIL THEN CacheFailure[h, hti];    IF gf # NIL AND bcd.definitions THEN {      Complain[h, filename, defs];       MFile.Release[mfile];       CacheFailure[h, hti]};    [seg, fgt] ¬ ModuleSymbols[h, mfile];    IF seg = NIL THEN CacheFailure[h, hti];    IF gf # NIL THEN DeleteItem[h, IQ.FindFrame[h, gf]];    mth ¬ IF gf = NIL THEN NIL ELSE MthForFrame[h, gf].mth;    syms ¬ CacheItem[h, gf, seg, mth, hti, fgt]};      GetNames: PROC[h: IT.Handle, type: LONG STRING] RETURNS[mod, item: Symbols.HTIndex ¬ Symbols.HTNull] = {    scratch: LONG STRING ¬ [IT.MaxModuleString];    gotMod: BOOLEAN ¬ FALSE;    scratch.length ¬ 0;    FOR c: CARDINAL IN [0..type.length) DO      IF type[c] = '. THEN {	IF (scratch.length = 0) THEN { IO.Line[h, " Empty Filename!"L]; RETURN };	mod ¬ IP.StringToHti[h, scratch];	gotMod ¬ TRUE;	scratch.length ¬ 0 }      ELSE {	scratch[scratch.length] ¬ type[c]; 	scratch.length ¬ scratch.length + 1 };      REPEAT FINISHED => {	IF (scratch.length = 0) OR ~gotMod THEN { IO.Line[h, " Empty Itemname!"L]; RETURN };	item ¬ IP.StringToHti[h, scratch]};      ENDLOOP };      CheckForExtension: PROC[h: IT.Handle, name: LONG STRING, ext: LONG STRING ¬ ".bcd"L, strip: BOOLEAN ¬ FALSE] = {    FOR i: CARDINAL IN [0..name.length) DO      IF name[i] = '. THEN { -- already an extension        IF strip THEN name.length ¬ i; 	RETURN};      REPEAT FINISHED => String.AppendString[name, ext];      ENDLOOP};        MakeFileName: PROC[filename: LONG STRING, name: BcdDefs.NameRecord, ssb: BcdOps.NameString, strip: BOOLEAN] = {    ss: String.SubStringDescriptor;    filename.length ¬ 0;    IF name = BcdDefs.NullName OR name = 0 THEN { String.AppendString[filename, "NULL"L]; RETURN };    ss ¬ [@ssb.string, name, ssb.size[name]];    String.AppendSubString[filename, @ss];    IF strip THEN CheckForExtension[h: NIL, name: filename, strip: TRUE];    CheckForExtension[NIL, filename]};      MthForFrame: PROC[h: IT.Handle, gf: IT.GFHandle] RETURNS [mth: BcdOps.MTHandle ¬ NIL, bcd: BcdOps.BcdBase ¬ NIL] = {    ENABLE AMLoadstate.Error => CONTINUE;    cgfi: CARDINAL;    config: AMLoadstate.Index;    loadstate: AMLoadstate.Handle = WorldVMOps.GetLoadstate[h.world];    [cgfi, config] ¬ AMLoadstate.MapRealToConfig[loadstate, WorldVMOps.GFshort[h.world, gf]];    bcd ¬ AMLoadstate.AcquireBcd[loadstate, config];    mth ¬ AMLoadstate.MapCgfiToMth[loadstate, cgfi, bcd]};  FindSymbolSegment: PROC[h: IT.Handle, mth: BcdOps.MTHandle, bcd: BcdOps.BcdBase]     RETURNS [seg: MSegment.Handle ¬ NIL, fgt: BOOLEAN ¬ FALSE] = {    ssb: BcdOps.NameString = BcdOpsExtras.NameStringFromBcd[bcd];    ftb: BcdDefs.Base = BcdOpsExtras.FTBaseFromBcd[bcd];    sgh: BcdOps.SGHandle = @BcdOpsExtras.SGBaseFromBcd[bcd][mth.sseg];    filename: LONG STRING ¬ [MFile.maxNameLength];    mfile: MFile.Handle ¬ NIL;    problem: Problem;    triedModule: BOOLEAN ¬ FALSE;    GetFile: PROC[fti: BcdDefs.FTIndex] RETURNS[mmfile: MFile.Handle ¬ NIL] = {      name: BcdDefs.NameRecord;      version: BcdDefs.VersionStamp;      SELECT fti FROM        BcdDefs.FTNull => RETURN[NIL];        BcdDefs.FTSelf => { -- Trouble. Try sourcefile name.	  version ¬ bcd.version;	  name ¬ ftb[bcd.sourceFile].name;	  MakeFileName[filename: filename, name: name, ssb: ssb, strip: TRUE];	  [mmfile, problem] ¬ MFileAndCheckVersion[h, filename, version, FALSE]; 	  IF problem = none THEN RETURN[mmfile];	  IF name # mth.name AND ~triedModule THEN { -- try module name --	    name ¬ mth.name;	    MakeFileName[filename: filename, name: name, ssb: ssb, strip: FALSE];	    [mmfile, problem] ¬ MFileAndCheckVersion[h, filename, version, FALSE];	    triedModule ¬ TRUE }};	ENDCASE => {	  name ¬ ftb[fti].name;	  version ¬ ftb[fti].version;	  MakeFileName[filename: filename, name: name, ssb: ssb, strip: FALSE];	  [mmfile, problem] ¬ MFileAndCheckVersion[h, filename, version, FALSE]}};    IF (mfile ¬ GetFile[sgh.file]) # NIL THEN {      seg ¬ MSegment.Create[file: mfile, release: [],         fileBase: (sgh.base - altoBias), pages: (sgh.pages + sgh.extraPages), 	swapInfo: swapUnits ! MSegment.Error => {}];      fgt ¬ (sgh.extraPages # 0);      RETURN };    IF (problem # none) AND (mth.file # sgh.file) AND ((mfile ¬ GetFile[mth.file]) # NIL) THEN       [seg, fgt] ¬ ModuleSymbols[h, mfile] };      Problem: TYPE = {none, noSuchFile, wrongVersion, other};    MFileAndCheckVersion: PROC[h: IT.Handle, filename: LONG STRING, version: BcdDefs.VersionStamp, attach: BOOLEAN]     RETURNS [mfile: MFile.Handle, problem: Problem] = {    mfile ¬ MFile.ReadOnly[filename, []       ! MFile.Error => 	SELECT code FROM 	  noSuchFile => IF attach THEN ERROR IP.Fail[filename] ELSE GOTO noSuchFile;	  conflictingAccess => {Complain[h, filename, conflict]; GOTO other};	  protectionFault => {Complain[h, filename, protection]; GOTO other};	  ENDCASE];    MSegment.CopyIn[bcdSeg, mfile, 0, bcdPages];    IF bcd.versionIdent # BcdDefs.VersionID AND bcd.versionIdent # BcdDefsExtras.GFTVersionID THEN {      Complain[h, filename, incompatible];       GOTO wrongVersion };    IF (version.time # anyVersion.time AND version.time # bcd.version.time) THEN {      VersionProblem[h: h, name: filename, have: bcd.version, want: version];      GOTO wrongVersion };    RETURN[mfile, none];    EXITS       noSuchFile => RETURN[NIL, noSuchFile];      wrongVersion => { MFile.Release[mfile]; RETURN[NIL, wrongVersion] };      other => RETURN[NIL, other]; };    Complain: PROC[h: IT.Handle, filename: LONG STRING, code: {incompatible, conflict, defs, protection, symbols}] = {    IO.Char[h, Ascii.CR]; IO.Text[filename, h];     IO.Text[SELECT code FROM      incompatible => " is compiled for an incompatible version of Mesa!  "L,      conflict => " cannot be acquired with read access!  "L,      defs => " is a definitions file!  "L,      protection => " is read protected!  "L,      symbols => " does not have any symbols in it!  "L,      ENDCASE => ERROR, h]};       VersionProblem: PROC[h: IT.Handle, name: LONG STRING, have, want: BcdDefs.VersionStamp] = {    msg: LONG STRING ¬ [120];    AppendComplaint[msg, name, have.time, want.time];    IO.Text[msg, h];     IO.Blanks[h, 1] };      ExpandBcdSeg: PROC[newPages: CARDINAL] = {    bcdPages ¬ newPages;    MSegment.Delete[bcdSeg];    bcdSeg ¬ MSegment.Create[release: [], pages: bcdPages, swapInfo: [uniform[1]]];    bcd ¬ MSegment.Address[bcdSeg]};      ModuleSymbols: PROC[h: IT.Handle, mfile: MFile.Handle] RETURNS [seg: MSegment.Handle, fgt: BOOLEAN] = {    ENABLE UNWIND => MFile.Release[mfile];    sgh: BcdOps.SGHandle;    mth: BcdOps.MTHandle;    IF mfile = NIL OR bcd.nConfigs # 0 THEN RETURN[NIL, FALSE];    IF bcd.nPages > bcdPages THEN ExpandBcdSeg[bcd.nPages];    MSegment.CopyIn[bcdSeg, mfile, 0, bcdPages];    mth ¬ @BcdOpsExtras.MTBaseFromBcd[bcd][FIRST[BcdDefs.MTIndex]];    sgh ¬ @BcdOpsExtras.SGBaseFromBcd[bcd][mth.sseg];    seg ¬ MSegment.Create[file: mfile, release: [], fileBase: sgh.base-altoBias, pages: sgh.pages+sgh.extraPages, swapInfo: swapUnits       ! MSegment.Error => IF code = baseOutOfRange THEN { seg ¬ NIL; CONTINUE }];    fgt ¬ (sgh.extraPages # 0)};    CacheItem: PROC[h: IT.Handle, gf: IT.GFHandle, seg: MSegment.Handle, mth: BcdOps.MTHandle, hti: Symbols.HTIndex, fgt: BOOLEAN] RETURNS [syms: IT.ModItem] = {    mdi: Symbols.MDIndex = Copier.EnterFileSegment[h.sym, hti, bcd.version, seg ! UNWIND => MSegment.Delete[seg]];    jumped: BOOLEAN = IF mth = NIL THEN FALSE ELSE mth.crossJumped;    EnterContexts: INTERNAL PROC[base: SymbolTable.Handle] = {      syms.outerCtx ¬ base.mainCtx;      syms.directoryCtx ¬ base.stHandle.directoryCtx;      syms.importCtx ¬ base.stHandle.importCtx;      syms.stopping ¬ FALSE};    syms ¬ AllocItem[h];    syms.frames[0] ¬ [h.world, gf];    syms.fgtAvailable ¬ fgt;    syms.crossJumped ¬ jumped;    syms.mdi ¬ mdi;    h.mdb[mdi].shared ¬ TRUE;    Copier.Outer[h.sym, mdi, EnterContexts];    syms.outerCtx ¬ Copier.FindExternalCtx[h.sym, mdi, syms.outerCtx];    syms.directoryCtx ¬ Copier.FindExternalCtx[h.sym, mdi, syms.directoryCtx];    syms.importCtx ¬ Copier.FindExternalCtx[h.sym, mdi, syms.importCtx]};    -- item management  AllocItem: PROC[h: IT.Handle] RETURNS [last: IT.ModItem] = {    FOR t: IT.ModCache ¬ IQ.Head, t.link UNTIL t = NIL DO      FOR i: CARDINAL IN [0..t.cnt) DO        last ¬ @t.subCache[i];        IF ~last.allocated THEN { last.allocated ¬ TRUE; RETURN[last] };	ENDLOOP;      ENDLOOP;    IF IQ.Head.cnt = IT.MaxModCnt THEN {      t: IT.ModCache ¬ IO.Pages[1];      t.link ¬ IQ.Head; t.cnt ¬ 0; IQ.Head ¬ t};    last ¬ @IQ.Head.subCache[IQ.Head.cnt];     last.allocated ¬ TRUE;    IQ.Head.cnt ¬ IQ.Head.cnt + 1 };  DeleteItem: PROC[h: IT.Handle, i: IT.ModItem] = {    IF i # NIL THEN i.allocated ¬ FALSE };    -- called on new sessions, overflow and invalidating caches        FreeItems: PUBLIC PROC[h: IT.Handle] = {RealFreeItems[@generalLock, h]};    RealFreeItems: ENTRY PROC[l: Lock, h: IT.Handle] = {    ENABLE UNWIND => NULL;    next: IT.ModCache;    RemoveAllHti[@hashLock, IO.symboltable];    FOR t: IT.ModCache ¬ IQ.Head.link, next UNTIL t = NIL DO      next ¬ t.link;       IO.FreePages[t];      ENDLOOP;    IQ.Head.cnt ¬ 0; IQ.Head.link ¬ NIL };  Prune: PUBLIC PROC[h: IT.Handle] = {RealPrune[@generalLock, h]};    RealPrune: ENTRY PROC[l: Lock, h: IT.Handle] = {    ENABLE UNWIND => NULL;    ss: String.SubStringDescriptor ¬ ["Sword"L, 0, 5];    id: Symbols.HTIndex = SymbolOps.EnterString[IO.symboltable, @ss];    IR.ResetLongs[h];    Alloc.Reset[IO.alloc]; -- Is this safe?    SymbolOps.Reset[IO.symboltable];    [] ¬ SymbolOps.PrefillMesaSymbols[IO.symboltable];    [] ¬ Copier.FindMdEntry[IO.symboltable, id, myVersion, id] --take first MD-- };    -- called from FilePack's notification stuff only   PurgeMdi: PROC[data: LONG POINTER, mdi: Symbols.MDIndex] = {    h: IT.Handle = data;    RealPurgeMdi[@generalLock, h, mdi]};    RealPurgeMdi: ENTRY PROC[l: Lock, h: IT.Handle, mdi: Symbols.MDIndex] = {    ENABLE UNWIND => NULL;    item: IT.ModItem = IQ.FindMdi[h, mdi];    DeleteItem[h, item];    -- Clear all pc caches    FOR h ¬ IZ.Interpreters, h.next UNTIL h = NIL DO      IP.ResetPCache[h];      ENDLOOP; };   -- notification stuff    CacheFailure: PROC[h: IT.Handle, hti: Symbols.HTIndex] = {    [] ¬ AddHti[@hashLock, h.sym, hti];    ERROR SymbolTable.Missing[SymbolTable.NullHandle]; };      AddHti: ENTRY PROC[l: Lock, sym: SymbolTable.Handle, hti: Symbols.HTIndex]     RETURNS[added: BOOLEAN] = {    empty: CARDINAL ¬ LAST[CARDINAL];    IF hashes = NIL THEN GrowHashes[];    FOR i: CARDINAL IN [0..hashes.length) DO      SELECT hashes[i] FROM        hti => RETURN[FALSE];	Symbols.HTNull => empty ¬ i;	ENDCASE;      ENDLOOP;    IF empty = LAST[CARDINAL] THEN { GrowHashes[]; empty ¬ hashes.length; };    AddFilter[sym, hti];    hashes[empty] ¬ hti;    RETURN[TRUE]; };        LookupHti: ENTRY PROC[l: Lock, hti: Symbols.HTIndex] RETURNS[found: BOOLEAN] = {    IF hashes = NIL THEN RETURN[FALSE];    FOR i: CARDINAL IN [0..hashes.length) DO      IF hashes[i] = hti THEN RETURN[TRUE];      ENDLOOP;    RETURN[FALSE]; };    RemoveHti: ENTRY PROC[l: Lock, sym: SymbolTable.Handle, hti: Symbols.HTIndex, dropFilter: BOOLEAN]     RETURNS[found: BOOLEAN] = {    IF hashes = NIL THEN RETURN[FALSE];    FOR i: CARDINAL IN [0..hashes.length) DO      IF hashes[i] = hti THEN {         IF dropFilter THEN DropFilter[sym, hti];        hashes[i] ¬ Symbols.HTNull; 	RETURN[TRUE] };      ENDLOOP;    RETURN[FALSE]; };       RemoveAllHti: ENTRY PROC[l: Lock, sym: SymbolTable.Handle] = {    IF hashes = NIL THEN RETURN;    FOR i: CARDINAL IN [0..hashes.length) DO      IF hashes[i] # Symbols.HTNull THEN {        DropFilter[sym, hashes[i]];	hashes[i] ¬ Symbols.HTNull; };      ENDLOOP; };      GrowHashes: INTERNAL PROC[] = {    oldLength: CARDINAL ¬ IF hashes = NIL THEN 0 ELSE hashes.length;    newLength: CARDINAL ¬ IF hashes = NIL THEN 30 ELSE hashes.length+10;    newHashes: Hashes ¬ IO.zone.NEW[HashesObject[newLength]];    FOR i: CARDINAL IN [0..oldLength) DO newHashes[i] ¬ hashes[i]; ENDLOOP;    FOR i: CARDINAL IN [oldLength..newLength) DO newHashes[i] ¬ Symbols.HTNull; ENDLOOP;    IF hashes # NIL THEN IO.zone.FREE[@hashes];    hashes ¬ newHashes; };      HtiToString: PROC[sym: SymbolTable.Handle, hti: Symbols.HTIndex, s: LONG STRING] = {    ss: String.SubStringDescriptor;    SymbolOps.SubStringForHash[sym, @ss, hti];    String.AppendSubString[s, @ss]};      StringToHti: PROC[sym: SymbolTable.Handle, s:  LONG STRING] RETURNS[hti: Symbols.HTIndex] = {    ss: String.SubStringDescriptor ¬ [s, 0, s.length];    RETURN [SymbolOps.FindString[sym, @ss]]};    AddFilter: INTERNAL PROC[sym: SymbolTable.Handle, hti: Symbols.HTIndex] = {    s: LONG STRING = [MFile.maxNameLength];    HtiToString[sym, hti, s];     CheckForExtension[NIL, s];    MFile.AddNotifyProc[BcdAvailable, [name: s, type: null, access: readOnly], sym]};      DropFilter: INTERNAL PROC[sym: SymbolTable.Handle, hti: Symbols.HTIndex] = {    s: LONG STRING = [MFile.maxNameLength];    HtiToString[sym, hti, s];     CheckForExtension[NIL, s];    MFile.RemoveNotifyProc[BcdAvailable, [name: s, type: null, access: readOnly], sym]};      BcdAvailable: MFile.NotifyProc = {    sym: SymbolTable.Handle = clientInstanceData;    hti: Symbols.HTIndex;    CheckForExtension[h: NIL, name: name, strip: TRUE];     hti ¬ StringToHti[sym, name];    [] ¬ RemoveHti[@hashLock, sym, hti, FALSE «MFile will remove notification»];     RETURN[TRUE]; };    SymbolsFile: MFile.NotifyProc = {    sym: SymbolTable.Handle = clientInstanceData;    Process.Detach[FORK RemoveAllHti[@hashLock, sym]]};    SeachPathChanged: Supervisor.AgentProcedure = {    sym: SymbolTable.Handle = instanceData;    IF event = EventTypes.newSearchPath THEN FreeItems[NIL]};    InitSym: PUBLIC PROC[alloc: Alloc.Handle, zone: UNCOUNTED ZONE] RETURNS[sym: SymbolTable.Handle] = {    sym ¬ SymbolOps.Create[IO.alloc, IO.zone];    [] ¬ SymbolOps.PrefillMesaSymbols[sym];    Copier.FileInit[h: sym, self: "Sword"L, version: myVersion, purgeProc: PurgeMdi, purgeData: NIL];    Copier.CopierInit[h: sym, coPilot: TRUE];    Copier.CreateFileTable[sym, 16];    MFile.AddNotifyProc[SymbolsFile, [name: "*.symbols"L, type: null, access: readOnly], sym];    searchPathChanged ¬ Supervisor.CreateSubsystem[agent: SeachPathChanged, instanceData: sym];    Supervisor.AddDependency[client: searchPathChanged, implementor: Event.fileSystem]};        StopSym: PUBLIC PROC[sym: SymbolTable.Handle] = {    Supervisor.RemoveDependency[client: searchPathChanged, implementor: Event.fileSystem];    Supervisor.DeleteSubsystem[searchPathChanged];    MFile.RemoveNotifyProc[SymbolsFile, [name: "*.symbols"L, type: null, access: readOnly], sym];    Copier.FileQuit[sym];    SymbolOps.Finalize[sym];    IF hashes # NIL THEN { RemoveAllHti[@hashLock, sym]; IO.zone.FREE[@hashes]; };    IF bcdSeg # NIL THEN MSegment.Delete[bcdSeg] };      }.
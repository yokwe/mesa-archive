-- File: ITDIMed.mesa - last edit:-- Litman              26-Mar-87 16:44:02-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.DIRECTORY  AMEvents USING [ApplyProcedure, ApplySignal, ArgsOrResults, BadResStack, WordSeq],  ComData USING [CSEIndex, typeCARDINAL, typeINT, typeStringBody],  CommandList USING [CSRptr, DIErr],  CommandTab USING [],  Environment USING [Long, LongNumber, maxCARDINAL, maxINTEGER],  IC USING [GetSignalDesc, GFFromControlLink, PCFromControlLink],  Inline USING [LongCOPY, LongNumber],  IO USING [AllocFob, Char, FreeNode, InvalidNumber, Node, Proceed, SubString, Text, zone],  IP USING [CBti, Complete, DerefProcDesc, DIFormat, GetControlLink, GetDesc, GetLongDesc, GetNumber, GetValue, HtiToString, Normalize, NotAnArray, NotAProcedure, Pad, StackFoo, StringToHti, TypeForSe, XferCtx],  IQ USING [DoProceed, DoRead, GFrameMdi],  IR USING [CheckLength, CheckLink, Dec, Deref, DerefOperand, DIAbort, Inc, InConditional, LengthenFob, LoopHoleWork, MakeCnt, MakeOperand, Pop, Push, PushLongVal, PushVal, Qualify, SelectOperand, Son, TargetTypeWork, Tos, VariantField, Work],  IS USING [CalculateAddr, Elements, HtiVal, ModeName, SeqToArray],  IT USING [ArrayHandle, ArrayInfo, BitAddress, ControlLink, CSEIndex, Foo, GFHandle, Handle, ISEIndex, LongDesc, MaxIdString, NumAddr, Number, NumberType, OpHandle, SEIndex, SequenceSEIndex, SignalDesc, WordSeq],  Mopcodes USING [op, zWLFS],  PrincOps USING [FieldDescriptor],  Runtime USING [ControlLink, GetTableBase, GlobalFrame],  String USING [SubStringDescriptor],  SymbolOps USING [BitsPerElement, Cardinality, FirstCtxSe, Handle, MakeNonCtxSe, NextSe, NormalType, RecField, TransferTypes, TypeForm, TypeRoot, UnderType, WordsForType, XferMode],  Symbols USING [ArraySEIndex, Base, BitAddress, CBTNull, codeCHAR, codeINT, CSEIndex, CSENull, HTIndex, HTNull, ISEIndex, ISENull, RecordSEIndex, SEIndex, SENull, SERecord, TransferMode, typeANY],  SymbolTable USING [Handle, Missing],  Tree USING [Base, Index, Link, Null],  TreeOps USING [Handle, OpName, Scan, ScanList],  Types USING [Assignable, Equivalent, Handle],  WorldVMOps USING [GetESV, Long, NilAddress];  ITDIMed: PROGRAM  IMPORTS AMEvents, com: ComData, CommandTab, IC, Inline, IO, IP, IQ, IR, IS, Runtime, SymbolOps, SymbolTable, TreeOps, Types, WorldVMOps  EXPORTS IP, IR = {  OPEN IT;    BadTree: ERROR = CODE;  BadTag: ERROR = CODE;  DerefError: ERROR = CODE;      Interval: PUBLIC PROC [h: Handle,       t: Tree.Link, type: Symbols.SEIndex,      openLow, openHigh, cntOnly: BOOLEAN ¬ FALSE] =    BEGIN     index: Tree.Index ¬ IR.CheckLink[h, t, subtree];    f1, f2: Foo;    size, size2: NumberType;    signed, signed2: BOOLEAN;    [f1, size, signed] ¬ MinimalRep[h, h.tb[index].son[1], type];    [f2, size2, signed2] ¬	MinimalRep[h, h.tb[index].son[2], 	  IF cntOnly THEN Symbols.typeANY ELSE type];    IF cntOnly THEN RETURN;    IF openLow THEN IR.Inc[h, f1, size, signed];    IF openHigh THEN IR.Dec[h, f2, size, signed2];    IR.MakeCnt[h, f2, f1, size, signed OR signed2];    END;      Size: PUBLIC PROC [h: Handle, f: Foo] =    BEGIN     IF ~f.typeOnly THEN AbortWithError[h, notType];    IR.PushVal[h, CARDINAL[      SymbolOps.WordsForType[h.sym, f.tsei]], com.typeCARDINAL];    IR.Tos[h].constant ¬ TRUE;    IR.MakeOperand[h, IR.Tos[h]];    END;      First: PUBLIC PROC [h: Handle, f: Foo] = {EndPoint[h, TRUE, f];    IR.Tos[h].constant ¬ TRUE;    IR.MakeOperand[h, IR.Tos[h]]};	  Last: PUBLIC PROC [h: Handle, f: Foo] = {EndPoint[h, FALSE, f];    IR.Tos[h].constant ¬ TRUE;     IR.MakeOperand[h, IR.Tos[h]]};      EndPoint: PROC [h: Handle, first: BOOLEAN, f: Foo] = {    -- code stolen from Pass3xb and Pass4xc of the compiler    type: CSEIndex;    MaxInteger: WORD = Environment.maxINTEGER;    MaxWord: WORD = Environment.maxCARDINAL;    val: RECORD [      SELECT OVERLAID * FROM        short => [v: WORD],	arry => [la: ARRAY [0..2) OF WORD],	long => [lv: LONG UNSPECIFIED]	ENDCASE];    IF ~f.typeOnly THEN AbortWithError[h, notType];    type ¬ IP.TypeForSe[h, f.tsei];    DO -- type can change in the relative case      WITH h.seb[type] SELECT FROM	basic => {	  SELECT code FROM	    Symbols.codeINT => -- GROSS CODE!!! complain to the compiler guru	      val.v ¬ IF first THEN MaxInteger+1 ELSE MaxInteger;	    Symbols.codeCHAR => 	      val.v ¬ IF first THEN 0 ELSE CARDINAL[SymbolOps.Cardinality[h.sym, type]]-1;	    ENDCASE => GO TO fail;	  GOTO short};	enumerated => {	  val.v ¬ IF first THEN 0 ELSE CARDINAL[SymbolOps.Cardinality[h.sym, type]]-1;	  GOTO short};	relative => {	  IF SymbolOps.TypeForm[h.sym, offsetType] # subrange THEN GO TO fail;	  type ¬ SymbolOps.UnderType[h.sym, offsetType];	  LOOP};	subrange => {	  -- val.v ¬ IF first THEN origin ELSE origin+range;	  val.v ¬ IF first THEN 0 ELSE range;	  GOTO short};	long => {	  IF SymbolOps.NormalType[h.sym, SymbolOps.UnderType[h.sym, rangeType]] # 	    com.typeINT THEN GO TO fail;	  val.la ¬ IF SymbolOps.UnderType[h.sym, rangeType] = com.typeINT	    THEN IF first THEN [0, MaxInteger+1] ELSE [MaxWord, MaxInteger]	    ELSE IF first THEN [0, 0] ELSE [MaxWord, MaxWord];	  GO TO long};	ENDCASE => GO TO fail;      REPEAT	short => IR.PushVal[h, val.v, type];	long => IR.PushLongVal[h, val.lv, type];      ENDLOOP;    EXITS fail => AbortWithError[h, typeMismatch] };  PushNil: PUBLIC PROC [h: Handle, f: Foo] =    BEGIN     LongArrayDesc: TYPE = LONG DESCRIPTOR FOR ARRAY OF UNSPECIFIED;    ArrayDesc: TYPE = DESCRIPTOR FOR ARRAY OF UNSPECIFIED;    nil: Foo = IO.AllocFob[h];    nil.constant ¬ TRUE;    IF f # NIL THEN {      csei: Symbols.CSEIndex ¬ IP.TypeForSe[h, f.tsei];      longNil, desc: BOOLEAN;      nil.tsei ¬ csei;      WITH h.seb[csei] SELECT FROM	long => {longNil ¬ TRUE; csei ¬ IP.TypeForSe[h, rangeType]};	ENDCASE => longNil ¬ FALSE;      desc ¬ h.seb[csei].typeTag = arraydesc;      SELECT TRUE FROM        longNil AND desc => {	  nil.addr.base ¬ IO.zone.NEW[LongArrayDesc ¬ NIL];	  nil.words ¬ SIZE[LongArrayDesc]};	longNil => {	  nil.addr.base ¬ IO.zone.NEW[LONG POINTER ¬ NIL];	  nil.words ¬ SIZE[LONG POINTER]};	desc => {	  nil.addr.base ¬ IO.zone.NEW[ArrayDesc ¬ NIL];	  nil.words ¬ SIZE[ArrayDesc]};	ENDCASE => {	  nil.addr.base ¬ IO.zone.NEW[POINTER ¬ NIL];	  nil.words ¬ SIZE[POINTER]}}    ELSE {      nil.tsei ¬ Symbols.typeANY;      nil.addr.base ¬ IO.zone.NEW[POINTER ¬ NIL];      nil.words ¬ SIZE[POINTER]};    IR.Push[h, nil];    IR.MakeOperand[h, nil];    END;      Assignable: PUBLIC PROCEDURE [h: Handle, f: Foo, csei: CSEIndex] =    BEGIN     left: Types.Handle ¬ [h.sym, csei];    right: Types.Handle ¬ [h.sym, IP.TypeForSe[h, f.tsei]];    leftSize: CARDINAL = CARDINAL[SymbolOps.WordsForType[h.sym, csei]];    rightSize: CARDINAL = TotalWords[h, f];    -- special check for short pointer to long pointer conversion    WITH h.seb[IP.TypeForSe[h, csei]] SELECT FROM      long =>         WITH h.seb[IP.TypeForSe[h, rangeType]] SELECT FROM 	  ref => 	    WITH h.seb[right.sei] SELECT FROM ref => IR.LengthenFob[h, f];	    ENDCASE;	  ENDCASE;      ENDCASE;    IF ~Types.Assignable[typeL: left, typeR: right] THEN      AbortWithError[h, typeMismatch, f.hti];    IF IR.InConditional[h] THEN IR.MakeOperand[h, f];    IP.GetValue[h, f];      WITH h.seb[IP.TypeForSe[h, csei]] SELECT FROM      subrange => {        size: NumberType ¬ SELECT rightSize FROM	  1 => one, 	  2 => two, 	  ENDCASE => nogood;        IF range # 0 AND leftSize # rightSize	  THEN AbortWithError[h, sizeMismatch, f.hti];        IF ~f.biased THEN {	  Subtract[h, f, size, FALSE, origin]; 	  f.biased ¬ TRUE}        }      ENDCASE;    SELECT TRUE FROM      f.tsei = csei => NULL;      csei = h.nullProc => NULL;      csei = h.nullSig => NULL;      csei = h.nullError => NULL;      TotalWords[h, f] = leftSize => RETURN;      leftSize # 2 => AbortWithError[h, sizeMismatch];      ~IR.CheckLength[h, f, 1] => AbortWithError[h, sizeMismatch];      ENDCASE => IR.LengthenFob[h, f];    END;      DumpArray: PUBLIC PROC [h: Handle, array: Foo] =    BEGIN      cnt: CARDINAL ¬ GetIndex[h];    start: CARDINAL ¬ GetIndex[h];    long: BOOLEAN;    target: CSEIndex;    [array, long, target] ¬ SetUpApply[h, array];    WITH h.seb[target] SELECT FROM      array => DoDesc[h, array, start, start+cnt, FALSE, long, FALSE];      arraydesc => DoDesc[h, array, start, start+cnt, TRUE, long, FALSE];      sequence => DoSequence[h, array, start, start+cnt, FALSE];      ENDCASE => AbortWithError[h, illegalIndexOp];    END;      GetIndex: PROC[h: Handle] RETURNS [c: CARDINAL] =    BEGIN     f: Foo ¬ IR.Pop[h];    n: Number;    n ¬ IP.GetNumber[h, f];    SELECT n.type FROM      one => c ¬ n.c;      ENDCASE => AbortWithError[h, indexTooBig];    END;      Memory: PUBLIC PROC [h: Handle, t: Tree.Link, type: Symbols.SEIndex] =    BEGIN     op: OpHandle = h.operand;    f: Foo;    lp: LONG POINTER;    n: Number;    h.operand ¬ NIL;    f ¬ IR.Son[h, t, type ! UNWIND => h.operand ¬ op];    h.operand ¬ op;    n ¬ IP.GetNumber[h, f, invalidAddress];    SELECT n.type FROM      one => lp ¬ WorldVMOps.Long[h.world, n.p];      two => lp ¬ n.lp;      ENDCASE;    IO.zone.FREE[@f.addr.base];    f.hti ¬ Symbols.HTNull;    f.tsei ¬ type;    f.addr.base ¬ lp;    f.there ¬ TRUE;    f.words ¬ 1;    f.constant ¬ FALSE;    IF IR.InConditional[h] THEN {IR.MakeOperand[h, f]; IR.DerefOperand[h, f]};    END;      TotalWords: PUBLIC PROC [h: Handle, f: Foo] RETURNS [cnt: CARDINAL] = {    cnt ¬ f.words;    IF f.bits # 0 THEN cnt ¬ cnt + 1 };      DumpMemory: PUBLIC PROCEDURE [h: Handle, fcnt: Foo] = {    fstart: Foo ¬ IR.Pop[h];    start: LONG POINTER;    cnt: CARDINAL;    n: Number;    n ¬ IP.GetNumber[h, fstart];    SELECT n.type FROM      one => start ¬ WorldVMOps.Long[h.world, n.p];      two => start ¬ n.lp;      ENDCASE => AbortWithError[h, invalidAddress];    n ¬ IP.GetNumber[h, fcnt];    SELECT n.type FROM      one => cnt ¬ n.c;      two => AbortWithError[h, wontDump];      ENDCASE => AbortWithError[h, invalidNumber];    IQ.DoRead[h, start, cnt]};      GetSize: PUBLIC PROCEDURE [h: Handle, index: Tree.Index, type: Symbols.SEIndex] RETURNS [size: NumberType, cnt: CARDINAL, signed: BOOLEAN] = {    it: Handle = h;    Process: TreeOps.Scan = {      tosSize: NumberType;      int: BOOLEAN;      IF t = Tree.Null THEN ERROR BadTree;      cnt ¬ cnt + 1;      [, tosSize, int] ¬ GetRep[it, t, type];      IF int THEN signed ¬ TRUE;      IF tosSize = size THEN RETURN;      size ¬ two };    cnt ¬ 0;  size ¬ one; signed ¬ FALSE;    TreeOps.ScanList[h.sym, h.tb[index].son[1], Process] };      MinimalRep: PUBLIC PROCEDURE [h: Handle, t: Tree.Link, type: Symbols.SEIndex] RETURNS [f: Foo, size: NumberType, signed: BOOLEAN] = {    p: LONG POINTER TO Inline.LongNumber;    [f, size, signed] ¬ GetRep[h, t, type];    IF size = one THEN RETURN;    p ¬ f.addr.base;    IF p.highbits # 0 THEN RETURN;    size ¬ one; f.words ¬ 1 };      GetRep: PUBLIC PROCEDURE [h: Handle, t: Tree.Link, type: Symbols.SEIndex] RETURNS [f: Foo, size: NumberType, signed: BOOLEAN] = {    n: Number;    offset: INTEGER ¬ 0;    IR.LoopHoleWork[h, t, type];    f ¬ IR.Tos[h];    WITH h.seb[IP.TypeForSe[h, f.tsei]] SELECT FROM      subrange => {offset ¬ origin; f.tsei ¬ IP.TypeForSe[h, rangeType]};      ENDCASE;    n ¬ IP.GetNumber[h, f];    size ¬ n.type;    WITH IP.DIFormat[h, f.tsei].vf SELECT FROM      int => signed ¬ TRUE;       ENDCASE => 	SELECT size FROM	  one => signed ¬ ~n.sign;	  two => signed ¬ ~n.lsign;	  ENDCASE => ERROR IO.InvalidNumber[f];    Subtract[h, f, size, signed, offset] };      Subtract: PROC [h: Handle, f: Foo, size: NumberType, signed: BOOLEAN, offset: CARDINAL] = {    num: NumAddr ¬ LOOPHOLE[f.addr.base];    IF WorldVMOps.NilAddress[h.world, f.addr.base] THEN RETURN;    IF signed THEN      SELECT size FROM	one => num.pi­ ¬ num.pi­ - offset;	two => num.pli­ ¬ num.pli­ - offset;	ENDCASE => ERROR IO.InvalidNumber[f]    ELSE      SELECT size FROM	one => num.pc­ ¬ num.pc­ - offset;	two => num.plc­ ¬ num.plc­ - offset;	ENDCASE => ERROR IO.InvalidNumber[f] };      Base: PUBLIC PROC [h: Handle, f: Foo, sei: SEIndex] = {    long: BOOLEAN;    WITH h.seb[IP.TypeForSe[h, f.tsei]] SELECT FROM      long => long ¬ TRUE;      ENDCASE => long ¬ FALSE;    IF ~f.there THEN AbortWithError[h, illegalConstantOp, f.hti];    IF long THEN LongBase[h, f, sei] ELSE ShortBase[h, f, sei];    IF IR.InConditional[h] THEN {      f.there ¬ FALSE;      f.constant ¬ TRUE;      IR.MakeOperand[h, f];      IR.SelectOperand[h: h, oldAddr: f.addr, newFoo: IR.Tos[h]];}};      ShortBase: PROC [h: Handle, f: Foo, sei: SEIndex] = {    asei: Symbols.ArraySEIndex;    d: LongDesc;    [d, asei] ¬ IP.GetDesc[h, f ! IP.NotAnArray => {AbortWithError[h, typeMismatch, f.hti]; ERROR}];    IR.PushLongVal[h, d.base, MakeLongType[h, MakePointerType[h, Symbols.typeANY]]];    IR.Tos[h].constant ¬ f.constant }; -- never true for now      LongBase: PROC [h: Handle, f: Foo, sei: SEIndex] = {    asei: Symbols.ArraySEIndex;    d: LongDesc;    [d, asei] ¬ IP.GetLongDesc[h, f ! IP.NotAnArray => {AbortWithError[h, typeMismatch, f.hti]; ERROR}];    IR.PushLongVal[h, d.base, MakeLongType[h, MakePointerType[h, Symbols.typeANY]]];    IR.Tos[h].constant ¬ f.constant }; -- never true for now      Length: PUBLIC PROC [h: Handle, f: Foo, sei: SEIndex] = {    asei: Symbols.ArraySEIndex;    WITH h.seb[IP.TypeForSe[h, f.tsei]] SELECT FROM      long => {	ld: LongDesc;	[ld, asei] ¬ IP.GetLongDesc[h, f ! IP.NotAnArray => {AbortWithError[h, typeMismatch, f.hti]; ERROR}];	IR.PushVal[h, ld.length, com.typeCARDINAL] };      ENDCASE => {	d: LongDesc;	[d, asei] ¬ IP.GetDesc[h, f ! IP.NotAnArray => {AbortWithError[h, typeMismatch, f.hti]; ERROR}];	IR.PushVal[h, d.length, com.typeCARDINAL] };    IR.Tos[h].constant ¬ TRUE;    IF IR.InConditional[h] THEN IR.MakeOperand[h, IR.Tos[h]] };      DerefApply: PROC [h: Handle, f: Foo] RETURNS [success: BOOLEAN] = {    tsei: Symbols.CSEIndex ¬ IP.TypeForSe[h, f.tsei];    DO      WITH h.seb[tsei] SELECT FROM	ref => IF basing THEN RETURN[FALSE] ELSE EXIT;	long => tsei ¬ IP.TypeForSe[h, rangeType];	ENDCASE => RETURN[FALSE];      ENDLOOP;    RETURN[IR.Deref[h, f]] };      SetUpApply: PROC [h: Handle, f: Foo]     RETURNS [newFoo: Foo, long: BOOLEAN, target: Symbols.CSEIndex] = {    IR.MakeOperand[h, f]; -- AHL 5/14/86    WHILE DerefApply[h, f] DO ENDLOOP;    target ¬ IP.TypeForSe[h, f.tsei];    WITH h.seb[target] SELECT FROM      long => {long ¬ TRUE; target ¬ IP.TypeForSe[h, rangeType]};      ENDCASE => long ¬ FALSE;    newFoo ¬ f;    WITH h.seb[target] SELECT FROM      record => {	IP.Complete[h, fieldCtx];        IF hints.unifield THEN {	  csei: Symbols.CSEIndex;	  csei ¬ IP.TypeForSe[h, SymbolOps.FirstCtxSe[h.sym, fieldCtx]];	  WITH h.seb[csei] SELECT FROM	    array, arraydesc => {newFoo.tsei ¬ target ¬ csei};	    ENDCASE}	ELSE {	  isei: Symbols.ISEIndex = IR.VariantField[h, target];	  IF isei = Symbols.ISENull THEN {	    IF target = com.typeStringBody THEN {	      IR.Qualify[h, f, IP.StringToHti[h, "text"L]];	      newFoo ¬ IR.Pop[h];	      target ¬ IP.TypeForSe[h, newFoo.tsei]}}	  ELSE {	    hti: Symbols.HTIndex = h.seb[isei].hash;	    target ¬ IP.TypeForSe[h, isei];	    WITH h.seb[target] SELECT FROM	      sequence =>		IF hti = Symbols.HTNull THEN newFoo.tsei ¬ target		ELSE {		  IR.Qualify[h, newFoo, hti];		  newFoo ¬ IR.Pop[h];		  target ¬ IP.TypeForSe[h, newFoo.tsei]};	      ENDCASE}}};      ENDCASE};      DoApply: PUBLIC PROC [h: Handle, t: Tree.Link, target: Foo] = {    uniOperand: BOOLEAN ¬ t # Tree.Null AND TreeOps.OpName[h.sym, t] # list;    long: BOOLEAN;    targetType: CSEIndex;    IF target = NIL THEN RETURN;    [target, long, targetType] ¬ SetUpApply[h, target];    WITH h.seb[targetType] SELECT FROM      record => {         --AbortWithError[h, constructor];        Constructor[h, t, target]; };      sequence => {	start: CARDINAL;	IF ~uniOperand THEN ERROR BadTree;	start ¬ GetStart[h, t, IP.TypeForSe[h, tagSei]];	DoSequence[h, target, start, start+1] };      array => {	start: CARDINAL;	IF ~uniOperand THEN ERROR BadTree;	start ¬ GetStart[h, t, indexType];	DoArray[h, target, start, start+1]; };      arraydesc => {	start: CARDINAL;	asei: Symbols.ArraySEIndex;	IF ~uniOperand THEN ERROR BadTree;	asei ¬ LOOPHOLE[SymbolOps.UnderType[h.sym, describedType]];	start ¬ GetStart[h, t, h.seb[asei].indexType];	DoDesc[h, target, start, start+1, TRUE, long]; };      transfer => { -- interpret call	IF IR.InConditional[h] THEN AbortWithError[h, spare1];	IF ~WorldVMOps.GetESV[h.world].swapData.mayCallDebuggee THEN AbortWithError[h, worryCall];	ProcedureCall[h, t, target]};      ref => {	tos: Foo;	IF ~basing THEN ERROR DerefError;	IR.Work[h, t];	tos ¬ IR.Tos[h];	IF ~uniOperand THEN AbortWithError[h, notRelative, tos.hti];	IF IR.InConditional[h] THEN AbortWithError[h, spare1];	Reloc[h, target, tos]; };      ENDCASE => AbortWithError[h, wrongBrackets, target.hti]; };        WLFS: PROC [UNSPECIFIED, LONG POINTER, PrincOps.FieldDescriptor] =    MACHINE CODE { Mopcodes.zWLFS };      DoSequence: PROC [h: Handle, f: Foo, start, stopPlusOne: CARDINAL, push: BOOLEAN ¬ TRUE] = {     ai: ArrayInfo;    sei: SequenceSEIndex = LOOPHOLE[IP.TypeForSe[h, f.tsei]];    IS.SeqToArray[h, f, sei, IP.Pad[h, f, LOOPHOLE[SymbolOps.TypeRoot[h.sym, sei]]], @ai];    ai.start ¬ start;    ai.stop ¬ stopPlusOne;    CheckSubrange[h, start, stopPlusOne, ai.length];    IF start = stopPlusOne-1 AND push THEN GetElement[h, @ai] ELSE IS.Elements[h, @ai]};      DoArray: PROC [h: Handle, f: Foo, start, stopPlusOne: CARDINAL, push: BOOLEAN ¬ TRUE] = {    ai: ArrayInfo;    d: LongDesc;    sei: Symbols.ArraySEIndex;    [d, sei] ¬ IP.GetDesc[h, f];    ai ¬ [start: start, stop: stopPlusOne, length: d.length, addr: f.addr, there: f.there, type: h.seb[sei].componentType,      packing: CARDINAL[SymbolOps.BitsPerElement[h.sym, h.seb[sei].componentType, h.seb[sei].packed]]];    CheckSubrange[h, start, stopPlusOne, d.length];    IF start = stopPlusOne-1 AND push THEN GetElement[h, @ai] ELSE IS.Elements[h, @ai]};      GetElement: PUBLIC PROCEDURE [h: Handle, ai: ArrayHandle] = {    f: Foo ¬ IO.AllocFob[h];  -- comes back zeroed    f.tsei ¬ ai.type;    f.there ¬ ai.there;    [f.words, f.bits] ¬ IP.Normalize[ai.packing];    f.addr ¬ IS.CalculateAddr[h, ai, ai.start];    IF IR.InConditional[h] THEN {      IR.MakeOperand[h, f];      IR.SelectOperand[h: h, oldAddr: ai.addr, newFoo: f];};    IR.Push[h, f] };      GetStart: PROC [h: Handle, t: Tree.Link, target: Symbols.SEIndex] RETURNS [CARDINAL] = {    -- get the subscript for sequences, arrays, and arrayDescriptors    op: OpHandle = h.operand;    f: Foo;    n: Number;    offset: INTEGER ¬ 0;    tsei: Symbols.CSEIndex ¬ IP.TypeForSe[h, target];    WITH h.seb[tsei] SELECT FROM      subrange => {offset ¬ origin; tsei ¬ IP.TypeForSe[h, rangeType]};      ENDCASE;    h.operand ¬ NIL;    IR.TargetTypeWork[h, t, tsei ! UNWIND => h.operand ¬ op];    h.operand ¬ op;    f ¬ IR.Pop[h];    -- IF IR.InConditional[h] AND ~f.constant THEN ERROR IR.DIAbort;    n ¬ IP.GetNumber[h, f];    SELECT n.type FROM      one => NULL;      two => AbortWithError[h, indexTooBig];      ENDCASE => AbortWithError[h, invalidNumber];    RETURN[n.c-offset] };      Reloc: PROC [h: Handle, base, rel: Foo] = {    csei: CSEIndex ¬ IP.TypeForSe[h, rel.tsei];    rr: RelocRec;    WITH h.seb[csei] SELECT FROM      relative => {	lengthen, pointer: BOOLEAN;	left: Types.Handle ¬ [h.sym, IP.TypeForSe[h, baseType]];	right: Types.Handle ¬ [h.sym, IP.TypeForSe[h, base.tsei]];	IF ~Types.Equivalent[left, right] THEN AbortWithError[h, wrongBase, base.hti];	rel.tsei ¬ offsetType;	[rr, lengthen, pointer] ¬ Relocate[h, base, rel];	IO.zone.FREE[@rel.addr.base];	rel.tsei ¬ IF lengthen THEN MakeLongType[h, IP.TypeForSe[h, resultType]] ELSE resultType;	rel.addr.base ¬ rr.base; rel.addr.offset ¬ rel.bits ¬ 0;	rel.words ¬ CARDINAL[SymbolOps.WordsForType[h.sym, resultType]];	rel.there ¬ FALSE; rel.hti ¬ Symbols.HTNull;	IF pointer AND ~IR.Deref[h, rel] THEN AbortWithError[h, notRelative] };      ENDCASE => AbortWithError[h, notRelative, rel.hti] };      Relocate: PROCEDURE [h: Handle, base, rel: Foo] RETURNS [rr: RelocRec ¬ [relDesc[NIL]], lengthen: BOOLEAN, deref: BOOLEAN] = {    ENABLE UNWIND => IF rr.rel # NIL THEN IO.zone.FREE[@rr.rel];    GetLongNumber: PROCEDURE [h: Handle, f: Foo, err: CommandList.DIErr] RETURNS [LONG CARDINAL] = {      n: Number = IP.GetNumber[h, f, err];       RETURN[IF n.type = one THEN n.c ELSE n.lc] };    baseAddr: LONG CARDINAL = GetLongNumber[h, base, invalidAddress];    csei: Symbols.CSEIndex ¬ IP.TypeForSe[h, rel.tsei];    getDesc: PROCEDURE [Handle, Foo] RETURNS [LongDesc, Symbols.ArraySEIndex];    rr.rel ¬ IO.zone.NEW[LongDesc];    WITH h.seb[csei] SELECT FROM      long => {csei ¬ IP.TypeForSe[h, rangeType]; getDesc ¬ IP.GetLongDesc};      ENDCASE => getDesc ¬ IP.GetDesc;    WITH h.seb[csei] SELECT FROM      arraydesc => {        -- rel describes a (possibly long) relative array discriptor off of base	-- we return a relocated descriptor	-- when we get called, operand describes the pointer, we need to fix it up	-- so that operand describes the descriptor	IF ~rel.there THEN AbortWithError[h, illegalConstantOp];	[rr.rel­, ] ¬ getDesc[h, rel];	rr.rel.base ¬ baseAddr + rr.rel.base;	RETURN[rr, (getDesc = IP.GetDesc), FALSE]};      ENDCASE => {        -- rel describes an offset off of a base ptr that will later be dereferenced	-- we want to select (narrow) the operand	offset: LONG CARDINAL = GetLongNumber[h, rel, notRelative];        rr.lc­ ¬ baseAddr + offset;	lengthen ¬ FALSE;	deref ¬ TRUE }};      RelocRec: TYPE = RECORD [SELECT OVERLAID * FROM    pointer => [lc: LONG POINTER TO LONG CARDINAL],    relDesc => [rel: LONG POINTER TO LongDesc],    foo => [base: LONG POINTER],    ENDCASE];      DoDesc: PROC [h: Handle, f: Foo, start, stopPlusOne: CARDINAL, descr, long: BOOLEAN, push: BOOLEAN ¬ TRUE] = {    sei: Symbols.ArraySEIndex;    d: LongDesc;    ai: ArrayInfo;    IF long THEN [d, sei] ¬ IP.GetLongDesc[h, f] ELSE [d, sei] ¬ IP.GetDesc[h, f];    IF WorldVMOps.NilAddress[h.world, d.base] THEN AbortWithError[h, invalidPointer];    IF ~descr AND ~f.there THEN AbortWithError[h, illegalConstantOp];    ai ¬ [start: start, stop: stopPlusOne, addr: [d.base, d.offset], length: d.length, there: descr OR f.there, type: h.seb[sei].componentType,      packing: CARDINAL[SymbolOps.BitsPerElement[h.sym, h.seb[sei].componentType, h.seb[sei].packed]]];    CheckSubrange[h, start, stopPlusOne, d.length];    IF start = stopPlusOne-1 AND push THEN GetElement[h, @ai]     ELSE IS.Elements[h, @ai]};     CheckSubrange: PROC[h: Handle, start, stopPlusOne, length: CARDINAL] = {    SELECT TRUE FROM     length = 0 => RETURN;     stopPlusOne > length => AbortWithError[h, invalidSubrange];     start >= stopPlusOne => AbortWithError[h, invalidSubrange];     start < stopPlusOne => RETURN;     ENDCASE => ERROR};       UnBias: PROC[h: IT.Handle, f: Foo] = {    type: CSEIndex = IP.TypeForSe[h, f.tsei];    WITH h.seb[type] SELECT FROM      subrange => {        num: NumAddr ¬ LOOPHOLE[f.addr.base];	SELECT TotalWords[h, f] FROM	  1 => num.pc­ ¬ num.pc­ + origin;	  2 => num.plc­ ¬ num.plc­ + origin;	  ENDCASE => ERROR IO.InvalidNumber[f];	f.biased ¬ FALSE };      ENDCASE };        Constructor: PUBLIC PROCEDURE [h: Handle, args: Tree.Link, recfoo: Foo] = {    it: Handle = h;    inRec: Symbols.RecordSEIndex;    inSize: CARDINAL;    isei: ISEIndex ¬ Symbols.ISENull;    argWords: LONG POINTER TO WordSeq ¬ NIL;    Collect: TreeOps.Scan = {      f: Foo;      offsetInBits: Symbols.BitAddress;      sizeInBits: Symbols.BitAddress;      isei ¬ IF isei = Symbols.ISENull THEN SymbolOps.FirstCtxSe[it.sym, it.seb[inRec].fieldCtx] ELSE SymbolOps.NextSe[it.sym, isei];      IF isei = Symbols.ISENull THEN AbortWithError[it, wrongNumberArgs, recfoo.hti]; -- too many arguments given      IR.TargetTypeWork[it, t, isei ! IR.DIAbort => {-- incorrect type -- IO.Text["  for field "L, it]; IS.HtiVal[it, it.seb[isei].hash]}];      [offsetInBits, LOOPHOLE[sizeInBits, CARDINAL]] ¬ SymbolOps.RecField[it.sym, isei];      f ¬ IR.Pop[it];      IP.GetValue[it, f];      IF sizeInBits.wd >= 1       THEN Inline.LongCOPY[from: f.addr.base, to: @argWords[offsetInBits.wd], nwords: sizeInBits.wd]      ELSE WLFS[f.addr.base­, @argWords[0], [offset: offsetInBits.wd, posn: offsetInBits.bd, size: sizeInBits.bd]] };    inRec ¬ LOOPHOLE[IP.TypeForSe[h, recfoo.tsei]];    inSize ¬ recfoo.words ¬ CARDINAL[SymbolOps.WordsForType[h.sym, inRec]];    BEGIN ENABLE UNWIND => IF argWords # NIL THEN IO.FreeNode[h, argWords];     argWords ¬ IO.Node[h, inSize];    TreeOps.ScanList[h.sym, args, Collect];    IF SymbolOps.NextSe[h.sym, isei] # Symbols.ISENull THEN AbortWithError[h, wrongNumberArgs, recfoo.hti];    -- recfoo.tsei ¬ inRec;    recfoo.typeOnly ¬ FALSE;    recfoo.addr.base ¬ argWords;    IR.Push[h, recfoo];    END -- ENABLE -- };      ProcedureCall: PUBLIC PROCEDURE [h: Handle, args: Tree.Link, procfoo: Foo] = {    it: Handle = h;    cnt: CARDINAL ¬ 0;    f: Foo;    inRec: Symbols.RecordSEIndex;    inSize: CARDINAL;    isei: ISEIndex ¬ Symbols.ISENull;    argWords, resWords: AMEvents.ArgsOrResults ¬ NIL;    tm: Symbols.TransferMode = SymbolOps.XferMode[h.sym, procfoo.tsei];    Collect: TreeOps.Scan = {      argSize: CARDINAL;      isei ¬ IF isei = Symbols.ISENull THEN SymbolOps.FirstCtxSe[it.sym, it.seb[inRec].fieldCtx] ELSE SymbolOps.NextSe[it.sym, isei];      IF isei = Symbols.ISENull THEN AbortWithError[it, wrongNumberArgs, procfoo.hti]; -- too many args      IR.TargetTypeWork[it, t, isei ! IR.DIAbort => {-- incorrect type -- IO.Text["  for argument """L, it]; IS.HtiVal[it, it.seb[isei].hash]; IO.Char[it, '"]}];      f ¬ IR.Pop[it];      argSize ¬ TotalWords[it, f];      IP.GetValue[it, f];      IF f.biased THEN UnBias[it, f]; -- subrange was biased by Assignable.      Inline.LongCOPY[from: f.addr.base, to: @argWords[cnt], nwords: argSize];      cnt ¬ cnt + argSize };    IF (tm # proc AND tm # signal AND tm # error) THEN CantApply[h, tm];    inRec ¬ SymbolOps.TransferTypes[h.sym, IP.TypeForSe[h, procfoo.tsei]].typeIn;    inSize ¬ CARDINAL[SymbolOps.WordsForType[h.sym, inRec]];    BEGIN ENABLE UNWIND => {      IF argWords # NIL THEN IO.zone.FREE[@argWords];      IF resWords # NIL THEN IO.zone.FREE[@resWords]};     argWords ¬ IO.zone.NEW[AMEvents.WordSeq[inSize]];    TreeOps.ScanList[h.sym, args, Collect];    IF cnt # SymbolOps.WordsForType[h.sym, inRec] OR (cnt # 0 AND SymbolOps.NextSe[h.sym, isei] # Symbols.ISENull) THEN AbortWithError[h, wrongNumberArgs, procfoo.hti]; -- too few args    [resWords, f] ¬ AllocateResults[h, procfoo.tsei];    SELECT tm FROM      proc => {        cl: ControlLink;	gf: GFHandle;	cl ¬ IP.DerefProcDesc[h, IP.GetControlLink[h, procfoo] ! IP.NotAProcedure => AbortWithError[h, notProcDesc, procfoo.hti]];	gf ¬ IC.GFFromControlLink[h, cl];	[] ¬ IQ.GFrameMdi[h, gf ! SymbolTable.Missing => AbortWithError[h, missingSyms]]; 	IF IP.CBti[h, IC.PCFromControlLink[h, cl], gf] = Symbols.CBTNull THEN AbortWithError[h, callingInline];	NotifyEveryone[h];	AMEvents.ApplyProcedure[h.world, cl, argWords, resWords ! AMEvents.BadResStack => CONTINUE]};      signal, error => {        sig: SignalDesc ¬ IC.GetSignalDesc[h, procfoo];        NotifyEveryone[h];        AMEvents.ApplySignal[h.world, sig, argWords, resWords ! AMEvents.BadResStack => CONTINUE]}      ENDCASE;    IF WorldVMOps.GetESV[h.world].swapData.reason # return THEN h.swapData ¬ WorldVMOps.GetESV[h.world].swapData;    CollectResults[h, f, resWords];    IO.zone.FREE[@argWords];        IO.zone.FREE[@resWords];    END -- ENABLE -- };      AllocateResults: PROC [h: Handle, procsei: SEIndex]     RETURNS[resWords: AMEvents.ArgsOrResults ¬ NIL, f: Foo] = {    f ¬ IP.XferCtx[h, procsei, NIL, out];    IF f = NIL THEN f ¬ IO.AllocFob[h];    resWords ¬ IO.zone.NEW[AMEvents.WordSeq[TotalWords[h, f]]]};      CollectResults: PROC [h: Handle, f: Foo, resWords: AMEvents.ArgsOrResults] = {    -- StackFoo reads state vector of client world, which is same as resWords.    IP.StackFoo[h, f];    f.addr.useStack ¬ TRUE;    f.xfer ¬ FALSE;    IR.Push[h, f]};      CantApply: PROC [h: Handle, tm: Symbols.TransferMode] = {    IO.Text[" Can't call "L, h];     IS.ModeName[h, tm];     IO.Text["!\n"L, h];    ERROR IR.DIAbort};      NotifyEveryone: PROC[h: Handle] = {    -- notifies direct subsystems    IQ.DoProceed[h ! IO.Proceed => GOTO goAhead];    ERROR IR.DIAbort;    EXITS goAhead => NULL};    MakeXferType: PUBLIC PROC [h: Handle, mode: Symbols.TransferMode] RETURNS [csei: Symbols.CSEIndex] = {    SELECT mode FROM      proc => {	IF h.nullProc # Symbols.CSENull THEN RETURN[h.nullProc];	csei ¬ h.nullProc ¬ SymbolOps.MakeNonCtxSe[h.sym, SIZE[transfer cons Symbols.SERecord]] };      signal => {	IF h.nullSig # Symbols.CSENull THEN RETURN[h.nullSig];	csei ¬ h.nullSig ¬ SymbolOps.MakeNonCtxSe[h.sym, SIZE[transfer cons Symbols.SERecord]] };      error => {	IF h.nullError # Symbols.CSENull THEN RETURN[h.nullError];	csei ¬ h.nullError ¬ SymbolOps.MakeNonCtxSe[h.sym, SIZE[transfer cons Symbols.SERecord]] };      ENDCASE;    h.seb[csei] ¬ Symbols.SERecord[mark3: TRUE, mark4: TRUE, body: cons[transfer[safe: FALSE, mode: mode, typeIn: Symbols.CSENull, typeOut: Symbols.CSENull]]] };      SetupLongs: PUBLIC PROC[h: Handle] = {    h.longs[0] ¬ [com.typeINT, Symbols.CSENull];    h.longs[1] ¬ [com.typeCARDINAL, Symbols.CSENull];    h.longs[2] ¬ [Symbols.typeANY, Symbols.CSENull];    h.nullProc ¬ h.nullError ¬ h.nullSig ¬ Symbols.CSENull };          ResetLongs: PUBLIC PROC[h: Handle] = {    i: CARDINAL;    FOR i IN [0..LENGTH[h.longs]) DO h.longs[i].lsei ¬ Symbols.CSENull ENDLOOP;    h.nullProc ¬ h.nullError ¬ h.nullSig ¬ Symbols.CSENull };      MakeLongType: PUBLIC PROC [h: Handle, rType: Symbols.SEIndex] RETURNS [type: Symbols.CSEIndex] = {    sei: CSEIndex ¬ SymbolOps.UnderType[h.sym, rType];    IF h.seb[sei].typeTag = long THEN RETURN[sei];    FOR i: CARDINAL IN [0..LENGTH[h.longs]) DO      IF h.longs[i].sei # sei THEN LOOP;      IF h.longs[i].lsei # Symbols.SENull THEN RETURN[h.longs[i].lsei];      h.longs[i].lsei ¬ type ¬ SymbolOps.MakeNonCtxSe[h.sym, SIZE[long cons Symbols.SERecord]];      EXIT      REPEAT FINISHED => type ¬ SymbolOps.MakeNonCtxSe[h.sym, SIZE[long cons Symbols.SERecord]];      ENDLOOP;    h.seb[type] ¬ Symbols.SERecord[mark3: TRUE, mark4: TRUE, body: cons[long[rangeType: rType]]] };      MakePointerType: PUBLIC PROC [h: Handle, cType: Symbols.SEIndex] RETURNS [type: Symbols.CSEIndex] = {    type ¬ SymbolOps.MakeNonCtxSe[h.sym, SIZE[ref cons Symbols.SERecord]];    h.seb[type] ¬ Symbols.SERecord[mark3: TRUE, mark4: TRUE, body: cons[ref[list: FALSE, counted: FALSE, ordered: FALSE, readOnly: FALSE, var: FALSE, basing: FALSE, refType: cType]]] };      AbortWithError: PUBLIC PROC [h: Handle, code: CommandList.DIErr, hti: Symbols.HTIndex ¬ Symbols.HTNull] = {    Error[h, code, hti]; ERROR IR.DIAbort };  messageBase: CommandList.CSRptr = Runtime.GetTableBase[Runtime.GlobalFrame[CommandTab]];  Error: PUBLIC PROC [h: Handle, code: CommandList.DIErr, hti: Symbols.HTIndex ¬ Symbols.HTNull] = {    ss: String.SubStringDescriptor ¬ [      base: @messageBase[messageBase.stringOffset],      offset: messageBase.DIErrorMessages[code].offset,      length: messageBase.DIErrorMessages[code].length];    s: STRING ¬ [MaxIdString];    IF hti # Symbols.HTNull THEN {IP.HtiToString[h, hti, s]; IO.Text[s, h]};    IO.SubString[h, @ss]};      }.
-- File: ITFramesHot.mesa - last edit:-- Litman              21-Apr-87 19:10:12-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.DIRECTORY  AMLoadstate USING [Error, GFHandle, Handle, MapRealToConfig, MapRealToEnh],  BcdOps USING [ENHandle],  Inline USING [HighHalf, LongCOPYReverse, LowHalf],  IO USING [FreePages, Line, Pages],  IP USING [EnumerateGF, ResetFrames],  IQ USING [],  IS USING [LongNum],  IT USING [BytePC, ControlLink, FrameDesc, FrameItemObject, FrameItem, MaxFrameCnt, FramePointer, FrameCache, GFHandle, Handle, LFHandle, LG, Overhead, PrefixHandle],  PrincOps USING [BytePC, ControlLink, GlobalFrameHandle, GlobalOverhead, GlobalWord, LocalOverhead, PrefixHandle, ShortControlLink],  WorldVMOps USING [AddressFault, BytePC, CodebaseFromGf, Codelinks, ControlLink, Copy, CopyRead, GetLoadstate, GetType, GFlong, GFshort, GlobalFrameHandle, LFlong, Long, LongGlobalFrameHandle, MakeControlLink, Read, Started];ITFramesHot: PROGRAM   IMPORTS AMLoadstate, IO, IP, IS, Inline, WorldVMOps  EXPORTS IP, IQ, IT = {  Clobbered: PUBLIC SIGNAL [f: IT.LFHandle] = CODE;  InvalidFrame: PUBLIC SIGNAL [f: LONG POINTER] = CODE;  MultipleFrames: PUBLIC ERROR [list: IT.FrameDesc] = CODE;  NoAccessLink: PUBLIC SIGNAL [f: IT.LFHandle] = CODE;  NoPrevious: PUBLIC SIGNAL [f: IT.LFHandle] = CODE;    FrameSize: CARDINAL = SIZE[PrincOps.LocalOverhead];  LongLocalFrameHandle: TYPE = LONG POINTER TO PrincOps.LocalOverhead;  LongGlobalFrameHandle: TYPE = LONG POINTER TO PrincOps.GlobalOverhead;  Overhead: PUBLIC TYPE = ARRAY [0..FrameSize) OF UNSPECIFIED;    sameWorldFrame: IT.FrameItemObject;  MakeOrdered: PROC[p: LONG POINTER] RETURNS[LONG ORDERED POINTER] = INLINE {    RETURN[LOOPHOLE[p]]};    Cache: PROC [h: IT.Handle, f: LONG POINTER, lg: IT.LG] RETURNS [item: IT.FrameItem] = {    ENABLE WorldVMOps.AddressFault => ERROR InvalidFrame[f];    fp: IT.FramePointer;    scratch: ARRAY [0..FrameSize) OF UNSPECIFIED;    t: IT.FrameCache;    top, bottom, i: CARDINAL;    IF f = NIL THEN ERROR InvalidFrame[f];    fp ¬ [fullPointer[f]];    fp.lg ¬ lg;    FOR t ¬ h.frameCache, t.link UNTIL t = NIL DO      top ¬ t.cnt;      bottom ¬ 0;      WHILE bottom < top DO	med: CARDINAL = (top+bottom)/2;	SELECT MakeOrdered[t.subCache[med].fp.frame] FROM	  < MakeOrdered[fp.frame] => bottom ¬ med+1;	  > MakeOrdered[fp.frame] => top ¬ med;	  ENDCASE => RETURN[@t.subCache[med]];	ENDLOOP;      ENDLOOP;    SELECT lg FROM      local => WorldVMOps.CopyRead[world: h.world, from: f-FrameSize, to: @scratch, nwords: FrameSize];      global => {        codebase: IT.PrefixHandle = WorldVMOps.CodebaseFromGf[h.world, f];	LOOPHOLE[scratch[1], PrincOps.GlobalWord].copy ¬ WorldVMOps.Copy[h.world, f];        LOOPHOLE[scratch[1], PrincOps.GlobalWord].started ¬ WorldVMOps.Started[h.world, f];	LOOPHOLE[scratch[1], PrincOps.GlobalWord].codelinks ¬ WorldVMOps.Codelinks[h.world, f];	scratch[2] ¬ Inline.LowHalf[codebase];	scratch[3] ¬ Inline.HighHalf[codebase];	IF WorldVMOps.GetType[h.world] = local THEN { sameWorldFrame ¬ [fp, scratch]; RETURN[@sameWorldFrame] }}; -- dont cache same world global frames      ENDCASE;    IF h.frameCache = NIL OR h.frameCache.cnt = IT.MaxFrameCnt THEN {      t ¬ IO.Pages[1]; t.link ¬ h.frameCache; t.cnt ¬ 0;       h.frameCache ¬ t }    ELSE t ¬ h.frameCache;     -- sequential insertion     FOR i DECREASING IN [1..t.cnt] DO      IF MakeOrdered[t.subCache[i-1].fp.frame] < MakeOrdered[fp.frame] THEN EXIT;      REPEAT FINISHED => i ¬ 0;      ENDLOOP;    Inline.LongCOPYReverse[from: @t.subCache[i], to: @t.subCache[i+1], nwords: (t.cnt-i)*SIZE[IT.FrameItemObject]];    item ¬ @t.subCache[i];      item­ ¬ [fp, scratch];    t.cnt ¬ t.cnt + 1 };    FlushFrameCache: PUBLIC PROCEDURE[h: IT.Handle] = {    next: IT.FrameCache;    IF h.frameCache = NIL THEN RETURN;    FOR t: IT.FrameCache ¬ h.frameCache.link, next UNTIL t = NIL DO      next ¬ t.link;       IO.FreePages[t];      ENDLOOP;    h.frameCache.link ¬ NIL;    h.frameCache.cnt ¬ 0;    IP.ResetFrames[h] };  LOrGType: PUBLIC PROC [h: IT.Handle, p: LONG POINTER] RETURNS [IT.LG] = {    RETURN[IF ValidateGF[h, p] THEN global ELSE local]};      MakeLocal: PROC[f: LONG POINTER] RETURNS[LongLocalFrameHandle] = INLINE {    RETURN[LOOPHOLE[f]]};      MakeGlobal: PROC[f: LONG POINTER] RETURNS[LongGlobalFrameHandle] = INLINE {    RETURN[LOOPHOLE[f]]};  ValidateF: PUBLIC PROCEDURE [h: IT.Handle, f: IT.LFHandle] RETURNS [ok: BOOLEAN, lf: LONG POINTER TO Overhead] = {    ENABLE WorldVMOps.AddressFault => GOTO false;    ll: LongLocalFrameHandle;    IF NotMod4[f] THEN GOTO false;    ll ¬ MakeLocal[@Cache[h, f, local ! InvalidFrame => GOTO false].frame];    IF ~ValidateGF[h, WorldVMOps.GFlong[h.world, ll.globallink]] THEN GOTO false;    RETURN[TRUE, LOOPHOLE[ll]];    EXITS false => RETURN[FALSE, NIL]};      GF: PUBLIC PROCEDURE [h: IT.Handle, f: IT.LFHandle] RETURNS [gf: IT.GFHandle] = {     ok: BOOLEAN;    lf: LongLocalFrameHandle;    [ok, LOOPHOLE[lf, LONG POINTER TO Overhead]] ¬ ValidateF[h, f];    IF ~ok THEN SIGNAL InvalidFrame[f];    RETURN[WorldVMOps.GFlong[h.world, lf.globallink]] };  PC: PUBLIC PROCEDURE [h: IT.Handle, f: IT.LFHandle] RETURNS [pc: IT.BytePC] = {    ok: BOOLEAN;    lf: LongLocalFrameHandle;    [ok, LOOPHOLE[lf, LONG POINTER TO Overhead]] ¬ ValidateF[h, f];    IF ~ok THEN SIGNAL InvalidFrame[f];    pc ¬ lf.pc;    IF f = WorldVMOps.LFlong[h.world, h.swapData.lFrame] THEN       SELECT h.swapData.reason FROM        breakpoint, storageFault => NULL;	ENDCASE => pc ¬ pc-1     ELSE pc ¬ pc-1 };  Previous: PUBLIC PROCEDURE [h: IT.Handle, f: IT.LFHandle] RETURNS [prev: IT.LFHandle] = {    link: PrincOps.ShortControlLink;    ok: BOOLEAN;    lf: LongLocalFrameHandle;    [ok, LOOPHOLE[lf, LONG POINTER TO Overhead]] ¬ ValidateF[h, f ! InvalidFrame => ERROR NoPrevious[f]];    IF ~ok THEN SIGNAL InvalidFrame[f];    link ¬ lf.returnlink;    THROUGH [0..100] DO       IF link.frame = NIL OR link.proc THEN ERROR NoPrevious[f];      IF link.indirect THEN { link ¬ WorldVMOps.Read[h.world, WorldVMOps.Long[h.world, link.link]]; LOOP };      RETURN[WorldVMOps.LFlong[h.world, link.frame]];      «IF ValidateF[h, prev].ok THEN RETURN ELSE ERROR Clobbered[f];»      REPEAT FINISHED => ERROR Clobbered[f];      ENDLOOP };      NotMod4: PROC[f: LONG UNSPECIFIED] RETURNS[BOOLEAN] = INLINE {    RETURN[(f MOD 4) # 0]};  ValidateGF: PUBLIC PROC [h: IT.Handle, gf: IT.GFHandle] RETURNS [BOOLEAN] = {    ENABLE AMLoadstate.Error, WorldVMOps.AddressFault => GOTO false;    short: WorldVMOps.GlobalFrameHandle;    IF gf = NIL OR NotMod4[gf] THEN RETURN[FALSE];    IF gf # WorldVMOps.GFlong[h.world, short ¬ WorldVMOps.GFshort[h.world, gf]] THEN RETURN[FALSE];    [] ¬ AMLoadstate.MapRealToConfig[WorldVMOps.GetLoadstate[h.world], short];    RETURN[TRUE];    EXITS false => RETURN[FALSE]};  CheckGF: PUBLIC PROC[h: IT.Handle, gf: IT.GFHandle] = {    IF ~ValidateGF[h, gf] THEN SIGNAL InvalidFrame[gf]};    Copied: PUBLIC PROCEDURE [h: IT.Handle, gf: IT.GFHandle] RETURNS [BOOLEAN] = {    lgf: LongGlobalFrameHandle = MakeGlobal[@Cache[h, gf, global].frame];    RETURN[lgf.word.copy]};  Started: PUBLIC PROCEDURE [h: IT.Handle, gf: IT.GFHandle] RETURNS [BOOLEAN] = {    lgf: LongGlobalFrameHandle = MakeGlobal[@Cache[h, gf, global].frame];    RETURN[lgf.word.started]};  CheckStarted: PUBLIC PROC [h: IT.Handle, gf: IT.GFHandle] RETURNS [running: BOOLEAN] = {    IF ~(running ¬ Started[h, gf])     THEN { IS.LongNum[h, gf, [pointer[]]]; IO.Line[h, " is not started!"L] }};  CodeLinks: PUBLIC PROCEDURE [h: IT.Handle, gf: IT.GFHandle] RETURNS [BOOLEAN] = {    lgf: LongGlobalFrameHandle = MakeGlobal[@Cache[h, gf, global].frame];    RETURN[lgf.word.codelinks]};  CodeBase: PUBLIC PROC [h: IT.Handle, gf: IT.GFHandle] RETURNS [IT.PrefixHandle] = {    lgf: LongGlobalFrameHandle = MakeGlobal[@Cache[h, gf, global].frame];    RETURN[lgf.codebase.codebase]};  SameCodebase: PUBLIC PROC [h: IT.Handle, gf1, gf2: IT.GFHandle] RETURNS [BOOLEAN] = {    RETURN[CodeBase[h, gf1] = CodeBase[h, gf2]]};        Original: PUBLIC PROC [h: IT.Handle, new: IT.GFHandle] RETURNS [old: IT.GFHandle] = {    RightFrame: PROC [gf: IT.GFHandle] RETURNS [BOOLEAN] = {      RETURN[gf # new AND ~Copied[h, gf] AND SameCodebase[h, new, gf]]};    IF ~Copied[h, new] THEN RETURN[new];    old ¬ IP.EnumerateGF[h, RightFrame]};      MakeDesc: PUBLIC PROC [h: IT.Handle, gf: IT.GFHandle, ep: CARDINAL] RETURNS [pd: IT.ControlLink] = {    enh: BcdOps.ENHandle = AMLoadstate.MapRealToEnh[WorldVMOps.GetLoadstate[h.world], WorldVMOps.GFshort[h.world, gf]];    RETURN[WorldVMOps.MakeControlLink[h.world, gf, enh.initialPC[ep]]]};  }.
-- File: AMUsefulImpl.mesa - last edit:-- Litman              20-Apr-87 10:26:03-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.DIRECTORY  AMLoadstate USING [AcquireBcd, BcdProc, EnumerateBcds, EnumerateModules, EnumerateModulesInConfig, Error, GetAttributes, GFHandle, Handle, Index, MapCgfiToMth, MapConfigToReal, MapRealToConfig, ModuleInfo, ModuleProc, nullIndex],  AMUseful USING [ConfigDesc, ConfigProc, ConfigRecord, FrameDesc, GFHandle, ModuleProc, NullConfigRecord, OuterConfig],  BcdDefs USING [Base, CTIndex, CTNull, CTRecord, FTSelf, MTIndex, MTNull, MTRecord, Namee, NameRecord, NullName, NullVersion, VersionStamp],  BcdOps USING [BcdBase, CTHandle, MTHandle, NameString, ProcessConfigs, ProcessModules],  BcdOpsExtras USING [CTBaseFromBcd, FTBaseFromBcd, GfiFromMti, MTBaseFromBcd, MthFromGfi, MthFromMti, MtiFromGfi, NameStringFromBcd],  String USING [AppendChar, AppendNumber, AppendString, AppendSubString, EqualSubString, SubStringDescriptor],  WorldVM USING [World],  WorldVMOps USING [GetLoadstate, GFlong, GFshort];AMUsefulImpl: PROGRAM   IMPORTS AMLoadstate, BcdOps, BcdOpsExtras, String, WorldVMOps  EXPORTS AMUseful = {  World: TYPE = WorldVM.World;  GFHandle: TYPE = AMUseful.GFHandle;  ConfigRecord: TYPE = AMUseful.ConfigRecord;  NullConfigRecord: ConfigRecord = AMUseful.NullConfigRecord;  NameStatus: TYPE = { ok, nullName, outOfRange, nullSize };    NoModule: PUBLIC ERROR = CODE;  NoConfig: PUBLIC ERROR = CODE;  MultipleFrames: PUBLIC SIGNAL [list: AMUseful.FrameDesc] = CODE;	  MultipleConfigs: PUBLIC SIGNAL [list: AMUseful.ConfigDesc] = CODE;    ModuleName: PUBLIC PROC[world: World, gf: GFHandle, name: LONG STRING] = {    ENABLE AMLoadstate.Error => { String.AppendString[name, "(bad module)"L]; CONTINUE };    bcd: BcdOps.BcdBase;    index: AMLoadstate.Index;    mti: BcdDefs.MTIndex;    mth: BcdOps.MTHandle;    nameRecord: BcdDefs.NameRecord;    status: NameStatus;    [index, mti] ¬ MapRealToConfig[world, gf];    bcd ¬ AMLoadstate.AcquireBcd[WorldVMOps.GetLoadstate[world], index];    IF bcd.nModules = 0 THEN ERROR NoModule;    mth ¬ BcdOpsExtras.MthFromMti[bcd, mti];    nameRecord ¬ «IF mth.namedInstance THEN BcdOps.FindName[bcd, [module[mti]]] ELSE» mth.name;    status ¬ WriteName2[nameRecord, bcd, name, FALSE];    IF status # ok THEN {       String.AppendChar[name, '[];       ConfigName[world, gf, name];       String.AppendString[name, ", mti:"L];      String.AppendNumber[name, mti];      String.AppendChar[name, ']]; }};      CtiName: PUBLIC PROC[world: World, config: ConfigRecord, name: LONG STRING] = {    ENABLE AMLoadstate.Error => { String.AppendString[name, "(bad config)"L]; CONTINUE };    bcd: BcdOps.BcdBase = AMLoadstate.AcquireBcd[WorldVMOps.GetLoadstate[world], config.index];    cth: BcdOps.CTHandle;     nameRecord: BcdDefs.NameRecord;    IF bcd.nConfigs = 0 THEN ERROR NoConfig;    cth ¬ CthFromCti[bcd, config.cti];    nameRecord ¬ «IF cth.namedInstance THEN BcdOps.FindName[bcd, [config[config.cti]]] ELSE» cth.name;    [] ¬ WriteName2[nameRecord, bcd, name, TRUE] };      ConfigName: PUBLIC PROC[world: World, gf: GFHandle, name: LONG STRING] = {    ENABLE AMLoadstate.Error => { String.AppendString[name, "(bad config)"L]; CONTINUE };    index: AMLoadstate.Index;    [, index] ¬ AMLoadstate.MapRealToConfig[WorldVMOps.GetLoadstate[world], WorldVMOps.GFshort[world, gf]];    CtiName[world, [index, FIRST[BcdDefs.CTIndex]], name]};      VersionStamp: PUBLIC PROC[world: World, gf: GFHandle] RETURNS[version: BcdDefs.VersionStamp] = {    ENABLE AMLoadstate.Error => { version ¬ BcdDefs.NullVersion; CONTINUE };    bcd: BcdOps.BcdBase;    index: AMLoadstate.Index;    cgfi: NATURAL;    mth: BcdOps.MTHandle;    loadstate: AMLoadstate.Handle = WorldVMOps.GetLoadstate[world];    [cgfi, index] ¬ AMLoadstate.MapRealToConfig[loadstate, WorldVMOps.GFshort[world, gf]];    bcd ¬ AMLoadstate.AcquireBcd[loadstate, index];    IF bcd.nModules = 0 THEN ERROR NoModule;    mth ¬ BcdOpsExtras.MthFromGfi[bcd, cgfi];    RETURN[IF mth.file = BcdDefs.FTSelf THEN bcd.version ELSE BcdOpsExtras.FTBaseFromBcd[bcd][mth.file].version] };    WriteName2: PROC[nameRecord: BcdDefs.NameRecord, bcd: BcdOps.BcdBase, target: LONG STRING, errorString: BOOLEAN] RETURNS[status: NameStatus] = {    nameString: BcdOps.NameString;    substring: String.SubStringDescriptor;    IF (nameRecord = BcdDefs.NullName) OR (nameRecord = 0) THEN {IF errorString THEN ErrorName[target, nullName]; RETURN[nullName]};    IF (nameRecord > (2*bcd.ssLimit - 4)) THEN {IF errorString THEN ErrorName[target, outOfRange]; RETURN[outOfRange]};    nameString ¬ BcdOpsExtras.NameStringFromBcd[bcd];    IF (nameString.size[nameRecord] = 0) THEN {IF errorString THEN ErrorName[target, nullSize]; RETURN[nullSize]};    substring ¬ [@nameString.string, nameRecord, nameString.size[nameRecord]];    String.AppendSubString[target, @substring];    RETURN[ok] };      ErrorName: PROC[string: LONG STRING, status: NameStatus] = {    String.AppendString[string,       SELECT status FROM         nullName => "[null name]"L,        outOfRange => "(name out of range)"L,	nullSize => "[null name]"L,	ENDCASE => ERROR]};	  WriteName: PUBLIC PROC[nameRecord: BcdDefs.NameRecord, bcd: BcdOps.BcdBase, target: LONG STRING] = {    [] ¬ WriteName2[nameRecord, bcd, target, TRUE]};  Frame: PUBLIC PROC[world: World, name: LONG STRING] RETURNS [gf: GFHandle] = {    ENABLE AMLoadstate.Error => { gf ¬ NIL; CONTINUE };    loadstate: AMLoadstate.Handle = WorldVMOps.GetLoadstate[world];    nameSS: String.SubStringDescriptor ¬ [name, 0, name.length];    MaxFrames: CARDINAL = 16;    frames: RECORD[size: CARDINAL ¬ 0, gfs: ARRAY [0..MaxFrames) OF GFHandle];    CheckBcd: AMLoadstate.BcdProc = {      -- PROC [bcdInfo: BcdInfo, index: Index] RETURNS [stop: BOOLEAN]      bcd: BcdOps.BcdBase;      ssb: BcdOps.NameString;      moduleSS: String.SubStringDescriptor;      CheckMod: AMLoadstate.ModuleProc = {        -- PROC [modInfo: ModuleInfo] RETURNS [stop: BOOLEAN]	IF modInfo.cgfi = 0 THEN RETURN[FALSE];	moduleSS.length ¬ ssb.size[	  moduleSS.offset ¬ AMLoadstate.MapCgfiToMth[loadstate, modInfo.cgfi, bcd].name];	IF String.EqualSubString[@nameSS, @moduleSS] THEN {	  IF frames.size = MaxFrames THEN RETURN[TRUE]; -- give up	  frames.gfs[frames.size] ¬ WorldVMOps.GFlong[world, modInfo.gf]; 	  frames.size ¬ frames.size + 1 };	RETURN[FALSE] }; --CheckMod      bcd ¬ AMLoadstate.AcquireBcd[loadstate, index ! AMLoadstate.Error => GOTO NoBcd];      ssb ¬ BcdOpsExtras.NameStringFromBcd[bcd];      moduleSS.base ¬ @ssb.string;      [] ¬ AMLoadstate.EnumerateModulesInConfig[loadstate, CheckMod, index];      RETURN[FALSE];      EXITS NoBcd => RETURN[FALSE] }; --CheckBcd    [] ¬ AMLoadstate.EnumerateBcds[l: loadstate, proc: CheckBcd, reverse: TRUE];    SELECT frames.size FROM      0 => RETURN[NIL];      1 => RETURN[frames.gfs[0]];      > 1 => {        SIGNAL MultipleFrames[DESCRIPTOR[BASE[frames.gfs], frames.size]];        RETURN[NIL] };      ENDCASE};        Config: PUBLIC PROC[world: World, name: LONG STRING] RETURNS [config: AMUseful.ConfigRecord] = {    ENABLE AMLoadstate.Error => { config ¬ AMUseful.NullConfigRecord; CONTINUE };    loadstate: AMLoadstate.Handle = WorldVMOps.GetLoadstate[world];    nameSS: String.SubStringDescriptor ¬ [name, 0, name.length];    MaxConfigs: CARDINAL = 16;    configs: RECORD[size: CARDINAL ¬ 0, cfs: ARRAY [0..MaxConfigs) OF AMUseful.ConfigRecord];    CheckBcd: AMLoadstate.BcdProc = {      -- PROC [bcdInfo: BcdInfo, index: Index] RETURNS [stop: BOOLEAN]      bcd: BcdOps.BcdBase;      ssb: BcdOps.NameString;      configSS: String.SubStringDescriptor;      CheckConfig: PROCEDURE [cth: BcdOps.CTHandle, cti: BcdDefs.CTIndex] RETURNS [stop: BOOLEAN] = {	configSS.length ¬ ssb.size[	  configSS.offset ¬ cth.name];	IF String.EqualSubString[@nameSS, @configSS] THEN {	  IF configs.size = MaxConfigs THEN RETURN[TRUE]; -- give up	  configs.cfs[configs.size] ¬ [index, cti]; 	  configs.size ¬ configs.size + 1 };	RETURN[FALSE] }; --CheckMod      bcd ¬ AMLoadstate.AcquireBcd[loadstate, index ! AMLoadstate.Error => GOTO NoBcd];      ssb ¬ BcdOpsExtras.NameStringFromBcd[bcd];      configSS.base ¬ @ssb.string;      [] ¬ BcdOps.ProcessConfigs[bcd, CheckConfig];      RETURN[FALSE];      EXITS NoBcd => RETURN[FALSE] }; --CheckBcd    [] ¬ AMLoadstate.EnumerateBcds[l: loadstate, proc: CheckBcd, reverse: TRUE];    SELECT configs.size FROM      0 => RETURN[AMUseful.NullConfigRecord];      1 => RETURN[configs.cfs[0]];      > 1 => {        SIGNAL MultipleConfigs[DESCRIPTOR[BASE[configs.cfs], configs.size]];        RETURN[AMUseful.NullConfigRecord] };      ENDCASE};      FirstSonConfig: PUBLIC PROC[world: World, index: AMLoadstate.Index, cti: BcdDefs.CTIndex] RETURNS[son: BcdDefs.Namee, level: CARDINAL] = {    ENABLE AMLoadstate.Error => { son ¬ [config[BcdDefs.CTNull]]; level ¬ 0; CONTINUE };    sonCti: BcdDefs.CTIndex;    FindFirstSonConfig: PROCEDURE [cthSon: BcdOps.CTHandle, ctiSon: BcdDefs.CTIndex] RETURNS [BOOLEAN] = {RETURN[cthSon.config = cti]};    FindFirstSonModule: PROCEDURE [mthSon: BcdOps.MTHandle, mtiSon: BcdDefs.MTIndex] RETURNS [BOOLEAN] = {RETURN[mthSon.config = cti]};    loadstate: AMLoadstate.Handle = WorldVMOps.GetLoadstate[world];    bcd: BcdOps.BcdBase = AMLoadstate.AcquireBcd[loadstate, index];    IF (sonCti ¬ BcdOps.ProcessConfigs[bcd, FindFirstSonConfig].cti) # BcdDefs.CTNull THEN son ¬ [config[sonCti]]    ELSE son ¬ [module[BcdOps.ProcessModules[bcd, FindFirstSonModule].mti]];    RETURN [son, FindLevel[bcd, son]] };      SiblingConfig: PROC[bcd: BcdOps.BcdBase, cti: BcdDefs.CTIndex, parent: BcdDefs.CTIndex] RETURNS[sib: BcdDefs.CTIndex] = {    ctb: BcdDefs.Base = BcdOpsExtras.CTBaseFromBcd[bcd];    sib ¬ cti;    DO       IF (sib ¬ sib + SIZE[BcdDefs.CTRecord] + ctb[sib].nControls*SIZE[BcdDefs.Namee]) = bcd.ctLimit THEN RETURN[BcdDefs.CTNull];      IF ctb[sib].config = parent THEN RETURN;      ENDLOOP };        SiblingModule: PROC[bcd: BcdOps.BcdBase, mti: BcdDefs.MTIndex, parent: BcdDefs.CTIndex] RETURNS[sib: BcdDefs.MTIndex] = {    mtb: BcdDefs.Base = BcdOpsExtras.MTBaseFromBcd[bcd];    sib ¬ mti;    DO       IF (sib ¬ sib + SIZE[BcdDefs.MTRecord]) = bcd.mtLimit THEN RETURN[BcdDefs.MTNull];      IF mtb[sib].config = parent THEN RETURN;      ENDLOOP };      Sibling: PUBLIC PROC[world: World, index: AMLoadstate.Index, namee: BcdDefs.Namee]     RETURNS[siblingIndex: AMLoadstate.Index, siblingNamee: BcdDefs.Namee, level: CARDINAL] = {    loadstate: AMLoadstate.Handle = WorldVMOps.GetLoadstate[world ! AMLoadstate.Error => GOTO NoBcd];    BEGIN    bcd: BcdOps.BcdBase = AMLoadstate.AcquireBcd[loadstate, index ! AMLoadstate.Error => GOTO NextBcd];    WITH namee SELECT FROM      config => {        IF cti = FIRST[BcdDefs.CTIndex] THEN GOTO NextBcd	ELSE { 	  parent: BcdDefs.CTIndex = CthFromCti[bcd, cti].config;	  siblingCti: BcdDefs.CTIndex;	  IF (siblingCti ¬ SiblingConfig[bcd, cti, parent]) # BcdDefs.CTNull THEN {	    siblingNamee ¬ [config[siblingCti]];	    level ¬ FindLevel[bcd, siblingNamee]}	  ELSE {	    FindModuleSibling: PROCEDURE [mthSib: BcdOps.MTHandle, mtiSib: BcdDefs.MTIndex] RETURNS[BOOLEAN] = {RETURN[mthSib.config = parent]};	    siblingNamee ¬ [module[BcdOps.ProcessModules[bcd, FindModuleSibling].mti]];	    level ¬ FindLevel[bcd, siblingNamee]}}};      module => {        IF bcd.nModules = 1 AND bcd.nConfigs = 0 THEN GOTO NextBcd	ELSE {	  siblingNamee ¬ [module[SiblingModule[bcd, mti, BcdOpsExtras.MthFromMti[bcd, mti].config]]];	  level ¬ FindLevel[bcd, siblingNamee]}};      ENDCASE;      siblingIndex ¬ index;      EXITS NextBcd => RETURN[index+1, NextBcd[loadstate, index+1], 0]; END;      EXITS NoBcd => RETURN[index+1, [config[BcdDefs.CTNull]], 0] };        NextBcd: PROC[loadstate: AMLoadstate.Handle, index: AMLoadstate.Index] RETURNS[namee: BcdDefs.Namee] = {    IF index >= AMLoadstate.GetAttributes[loadstate].nBcds THEN RETURN[[config[BcdDefs.CTNull]]] -- no more bcds    ELSE {      nextBcd: BcdOps.BcdBase = AMLoadstate.AcquireBcd[loadstate, index ! AMLoadstate.Error => GOTO NoBcd];      RETURN[IF nextBcd.nConfigs = 0 THEN [module[FIRST[BcdDefs.MTIndex]]] ELSE [config[FIRST[BcdDefs.CTIndex]]]]};    EXITS NoBcd => RETURN[[config[BcdDefs.CTNull]]] };      FindLevel: PROC[bcd: BcdOps.BcdBase, namee: BcdDefs.Namee] RETURNS[level: CARDINAL] = {    ctb: BcdDefs.Base = BcdOpsExtras.CTBaseFromBcd[bcd];    parent: BcdDefs.CTIndex;    WITH namee SELECT FROM      config => {        IF cti = BcdDefs.CTNull THEN RETURN[0];	level ¬ 0;	parent ¬ cti };      module => {        IF mti = BcdDefs.MTNull THEN RETURN[0];	level ¬ 1;	parent ¬ BcdOpsExtras.MthFromMti[bcd, mti].config };      ENDCASE => ERROR;    UNTIL parent = FIRST[BcdDefs.CTIndex] DO      level ¬ level+1;      parent ¬ ctb[parent].config;      ENDLOOP };        CthFromCti: PROC[bcd: BcdOps.BcdBase, cti: BcdDefs.CTIndex] RETURNS[BcdOps.CTHandle] = INLINE {    RETURN[@BcdOpsExtras.CTBaseFromBcd[bcd][cti]]};  MapConfigToReal: PUBLIC PROC[world: World, mti: BcdDefs.MTIndex, index: AMLoadstate.Index] RETURNS[GFHandle] = {    loadstate: AMLoadstate.Handle = WorldVMOps.GetLoadstate[world];    RETURN[WorldVMOps.GFlong[world, AMLoadstate.MapConfigToReal[loadstate, BcdOpsExtras.GfiFromMti[mti], index]]]};        MapRealToConfig: PUBLIC PROC[world: World, gf: GFHandle] RETURNS[index: AMLoadstate.Index, mti: BcdDefs.MTIndex] = {    cgfi: NATURAL;    loadstate: AMLoadstate.Handle = WorldVMOps.GetLoadstate[world];    [cgfi, index] ¬ AMLoadstate.MapRealToConfig[loadstate, WorldVMOps.GFshort[world, gf] ! AMLoadstate.Error => ERROR NoModule];    mti ¬ BcdOpsExtras.MtiFromGfi[cgfi]};      ModuleInConfig: PUBLIC PROC[world: World, gf: GFHandle, config: ConfigRecord] RETURNS[BOOLEAN] = {    indexWeWant: AMLoadstate.Index;    mtiWeWant: BcdDefs.MTIndex;    [indexWeWant, mtiWeWant] ¬ MapRealToConfig[world, gf];    IF config.index = indexWeWant THEN {      bcd: BcdOps.BcdBase = AMLoadstate.AcquireBcd[WorldVMOps.GetLoadstate[world], config.index ! AMLoadstate.Error => GOTO NoBcd];      ctb: BcdDefs.Base = BcdOpsExtras.CTBaseFromBcd[bcd];      FOR nextCti: BcdDefs.CTIndex ¬ BcdOpsExtras.MthFromMti[bcd, mtiWeWant].config, ctb[nextCti].config DO        IF nextCti = config.cti THEN RETURN[TRUE];	IF nextCti = BcdDefs.CTNull THEN RETURN[FALSE];	ENDLOOP }    ELSE RETURN[FALSE];    EXITS NoBcd => RETURN[FALSE]};      ConfigInConfig: PUBLIC PROC[world: World, inner: ConfigRecord, outer: ConfigRecord] RETURNS[BOOLEAN] = {    bcd: BcdOps.BcdBase;     ctb: BcdDefs.Base;     IF inner.index # outer.index THEN RETURN[FALSE];    bcd ¬ AMLoadstate.AcquireBcd[WorldVMOps.GetLoadstate[world], inner.index ! AMLoadstate.Error => GOTO NoBcd];    ctb ¬ BcdOpsExtras.CTBaseFromBcd[bcd];    DO      IF inner.cti = outer.cti THEN RETURN[TRUE];      IF inner.cti = BcdDefs.CTNull THEN RETURN[FALSE];      inner.cti ¬ ctb[inner.cti].config;      ENDLOOP;    EXITS NoBcd => RETURN[FALSE]};      EnumerateModules: PUBLIC PROC[world: World, proc: AMUseful.ModuleProc] RETURNS [gf: GFHandle] = {    Enum: PROCEDURE[modInfo: AMLoadstate.ModuleInfo] RETURNS [BOOLEAN] = {      RETURN[proc[WorldVMOps.GFlong[world, modInfo.gf]]]};    RETURN[WorldVMOps.GFlong[world, AMLoadstate.EnumerateModules[WorldVMOps.GetLoadstate[world], Enum, FALSE].gf]]};  EnumerateModulesInConfig: PUBLIC PROC[world: World, proc: AMUseful.ModuleProc, config: ConfigRecord] RETURNS [gf: GFHandle] = {    Enum: PROCEDURE[modInfo: AMLoadstate.ModuleInfo] RETURNS [BOOLEAN] = {      IF config.cti = AMUseful.OuterConfig THEN RETURN[proc[WorldVMOps.GFlong[world, modInfo.gf]]]; -- accelerator      FOR nextCti: BcdDefs.CTIndex ¬ mtb[BcdOpsExtras.MtiFromGfi[modInfo.cgfi]].config, ctb[nextCti].config DO        IF nextCti = config.cti THEN RETURN[proc[WorldVMOps.GFlong[world, modInfo.gf]]];	IF nextCti = BcdDefs.CTNull THEN RETURN[FALSE];	ENDLOOP };    bcd: BcdOps.BcdBase = AMLoadstate.AcquireBcd[WorldVMOps.GetLoadstate[world], config.index];    mtb: BcdDefs.Base = BcdOpsExtras.MTBaseFromBcd[bcd];    ctb: BcdDefs.Base = BcdOpsExtras.CTBaseFromBcd[bcd];    RETURN[WorldVMOps.GFlong[world, AMLoadstate.EnumerateModulesInConfig[WorldVMOps.GetLoadstate[world], Enum, config.index].gf]] };  EnumerateConfigsForModule: PUBLIC PROC[world: World, proc: AMUseful.ConfigProc, gf: GFHandle] RETURNS [ConfigRecord] = {    indexWeWant: AMLoadstate.Index;    mtiWeWant: BcdDefs.MTIndex;    [indexWeWant, mtiWeWant] ¬ MapRealToConfig[world, gf];    BEGIN    bcd: BcdOps.BcdBase = AMLoadstate.AcquireBcd[WorldVMOps.GetLoadstate[world], indexWeWant ! AMLoadstate.Error => GOTO NoBcd];    ctb: BcdDefs.Base = BcdOpsExtras.CTBaseFromBcd[bcd];    FOR nextCti: BcdDefs.CTIndex ¬ BcdOpsExtras.MthFromMti[bcd, mtiWeWant].config, ctb[nextCti].config UNTIL nextCti = BcdDefs.CTNull DO      IF proc[[indexWeWant, nextCti]] THEN RETURN[[indexWeWant, nextCti]];      REPEAT FINISHED => RETURN[AMUseful.NullConfigRecord];      ENDLOOP;    END;    EXITS NoBcd => RETURN[AMUseful.NullConfigRecord] };  EnumerateConfigs: PUBLIC PROC[world: World, proc: AMUseful.ConfigProc] RETURNS [config: ConfigRecord] = {    BcdProc: AMLoadstate.BcdProc = {      OneConfig: PROCEDURE [cth: BcdOps.CTHandle, cti: BcdDefs.CTIndex] RETURNS [BOOLEAN] = {        RETURN[proc[[index, cti]]]};      [, config.cti] ¬ BcdOps.ProcessConfigs[AMLoadstate.AcquireBcd[loadstate, index], OneConfig];      RETURN[config.cti # BcdDefs.CTNull]};    loadstate: AMLoadstate.Handle = WorldVMOps.GetLoadstate[world];    [, config.index] ¬ AMLoadstate.EnumerateBcds[loadstate, BcdProc, FALSE] };      EnumerateConfigsInConfig: PUBLIC PROC[world: World, proc: AMUseful.ConfigProc, config: ConfigRecord] RETURNS [end: ConfigRecord] = {    OneConfig: PROCEDURE [cth: BcdOps.CTHandle, cti: BcdDefs.CTIndex] RETURNS [BOOLEAN] = {      IF config.cti = AMUseful.OuterConfig THEN RETURN[proc[[config.index, cti]]]; -- accelerator      FOR nextCti: BcdDefs.CTIndex ¬ cti, ctb[nextCti].config DO        IF nextCti = config.cti THEN RETURN[proc[[config.index, cti]]];	IF nextCti = BcdDefs.CTNull THEN RETURN[FALSE];        ENDLOOP };    bcd: BcdOps.BcdBase ¬ AMLoadstate.AcquireBcd[WorldVMOps.GetLoadstate[world], config.index ! AMLoadstate.Error => GOTO NoBcd];    ctb: BcdDefs.Base = BcdOpsExtras.CTBaseFromBcd[bcd];    [, end.cti] ¬ BcdOps.ProcessConfigs[bcd, OneConfig];    end.index ¬ IF end.cti = BcdDefs.CTNull THEN AMLoadstate.nullIndex ELSE config.index;    EXITS NoBcd => RETURN[AMUseful.NullConfigRecord]};      }.
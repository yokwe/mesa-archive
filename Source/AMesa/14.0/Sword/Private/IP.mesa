-- File: IP.mesa - last edit:-- Litman               4-May-87 12:15:17-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.DIRECTORY  CatchFormat USING [CatchFrame],  CommandList USING [DIErr],  Environment USING [bitsPerWord],  Format USING [StringProc],  Inline USING [DIVMOD],  IT USING [ArraySEIndex, BitAddress, BTIndex, BytePC, CBTIndex, ControlLink, CSEIndex, CTXIndex, CtxLink, EVIndex, EXOI, Flavor, Foo, FrameDesc, GFHandle, Handle, HTIndex, HTNull, IncludedCTXIndex, ISEIndex, LFHandle, LongDesc, MDIndex, NILGF, Number, PcItem, PrefixHandle, RecordSEIndex, SEIndex, SignalDesc, UnionSEIndex, ValFormat, VType],  Literals USING [LitRecord],  Stream USING [Handle],  Symbols USING [TransferMode, TypeClass],  SymbolTable USING [Handle],  Window USING [Handle];IP: DEFINITIONS IMPORTS Inline = {  OPEN IT;    -- PcOps  EpCold: PROC [h: Handle, pc: BytePC, gf: GFHandle] RETURNS [ep: EVIndex, start: BytePC];  EpToCBtiCold: PROC [h: Handle, ep: EVIndex, gf: GFHandle, start: BytePC] RETURNS [cbti: CBTIndex];  CacheCBtiCold: PROC [h: Handle, mdi: MDIndex, gf: GFHandle, cbti: CBTIndex] RETURNS [CBTIndex];  ParentCbtiCold: PROC [h: Handle, pc: BytePC, gf: GFHandle, mdi: MDIndex] RETURNS [PcItem];  Bti: PROC [h: Handle, pc: BytePC, gf: GFHandle] RETURNS [bti: BTIndex]; -- in user's symbol table  ConvertCbti: PROC [h: Handle, lastBti: BTIndex, pc, start: BytePC, base: SymbolTable.Handle] RETURNS [bti: BTIndex];  FindPC: PROC [h: Handle, pc: BytePC, gf: GFHandle] RETURNS [PcItem];  FindUserCbti: PROC [Handle, GFHandle, CBTIndex] RETURNS [PcItem];  -- Pc  ResetPCache: PROC[h: Handle];  Entry: PROC [h: Handle, f: LFHandle, pc: BytePC] RETURNS [BOOLEAN];  Exit: PROC [h: Handle, f: LFHandle, pc: BytePC] RETURNS [BOOLEAN];  EvalStackEmpty: PROC[h: Handle] RETURNS [BOOLEAN];  GetPc: PROC [h: Handle, gf: GFHandle, i: EVIndex] RETURNS [pc: BytePC];  CbtSon: PROC [Handle, CBTIndex] RETURNS [BOOLEAN];  EntryPC: PROC [h: Handle, gf: GFHandle, i: EVIndex] RETURNS [pc: BytePC];  ExitPC: PROC [Handle, CBTIndex] RETURNS [BytePC];  Ep: PROC [h: Handle, pc: BytePC, gf: GFHandle] RETURNS [ep: EVIndex, start: BytePC];  LinkToIsei: PROC [Handle, ControlLink] RETURNS [ISEIndex];  CBti: PROC [h: Handle, pc: BytePC, gf: GFHandle] RETURNS [cbti: CBTIndex];  UserCBti: PROC [h: Handle, pc: BytePC, gf: GFHandle] RETURNS [cbti: CBTIndex];  CacheCBti: PROC [h: Handle, mdi: MDIndex, gf: GFHandle, cbti: CBTIndex] RETURNS [CBTIndex];  FreeContextList: PROC [Handle, CtxLink];  ContextList: PROC [h: Handle, pc: BytePC, gf: GFHandle, reason: Reason, exoi: EXOI ¬ in, lf: LFHandle ¬ NIL] RETURNS [CtxLink];  Reason: TYPE = {print,search};  NotInAnyProcedure: SIGNAL;  SignalSeiFromCatchFrameHandle: PROCEDURE [h: Handle, cf: LONG POINTER TO CatchFormat.CatchFrame] RETURNS [sei: SEIndex];  -- Lookup  InCtx: PROC [h: Handle, id: HTIndex, ctx: CTXIndex] RETURNS [Foo];  InGF: PROC [h: Handle, id: HTIndex, gf: GFHandle ¬ NILGF, check: BOOLEAN ¬ TRUE] RETURNS [Foo];  InMod: PROC [h: Handle, id: HTIndex, mod: HTIndex ¬ HTNull] RETURNS [Foo];  InLF: PROC [h: Handle, id: HTIndex, lf: LFHandle ¬ NIL, check: BOOLEAN ¬ TRUE] RETURNS [Foo];  OnStack: PROC [h: Handle, id: HTIndex, lf: LFHandle ¬ NIL, check: BOOLEAN ¬ TRUE] RETURNS [Foo];  Signal: PROC [Handle, SignalDesc] RETURNS [ISEIndex];  Procedure: PROC [Handle, ControlLink] RETURNS [ISEIndex];  StateCtx: PROC [Handle, SEIndex, InOut] RETURNS [Foo];  XferCtx: PROC [Handle, SEIndex, LONG POINTER, InOut] RETURNS [Foo];  InOut: TYPE = {in,out};  StringToHti: PROC [Handle, LONG STRING] RETURNS [HTIndex];  HtiToString: PROC [Handle, HTIndex, LONG STRING];  IseiFromBreakCtx: PROCEDURE [Handle, HTIndex] RETURNS [ISEIndex];  Mode: PROCEDURE [h: Handle, isei: ISEIndex] RETURNS [Flavor];  MakeFoo: PROC [h: Handle, isei: ISEIndex, ba: BitAddress ¬ [NIL, 0], sizeInc: CARDINAL ¬ 0] RETURNS [Foo];  StackFoo: PROC [Handle, Foo]; -- gets the Foo described, off of the stack  CopyLiteral: PROC [h: Handle, info: Literals.LitRecord] RETURNS [p: LONG POINTER, length: CARDINAL];  CopyMore: PROC [h: Handle, tsei: SEIndex, doVariants: BOOLEAN ¬ FALSE];  Complete: PROC [h: Handle, ictx: CTXIndex, variants: BOOLEAN ¬ FALSE];  CheckForHiddenPadding: PROC [h: Handle, f: Foo];  Fail: SIGNAL [s: LONG STRING];  NotRelocated: SIGNAL RETURNS [LONG POINTER];  NoStack: ERROR;  -- Lf  GF: PROC [h: Handle, f: LFHandle] RETURNS [gf: GFHandle];  Previous: PROC [h: Handle, f: LFHandle] RETURNS [prev: LFHandle];  PC: PROC [h: Handle, f: LFHandle] RETURNS [pc: BytePC];  CatchFrame: PROC [h: Handle, f: LFHandle] RETURNS [BOOLEAN];  Clobbered: SIGNAL [f: LFHandle];  NoPrevious: SIGNAL [f: LFHandle];  NoAccessLink: SIGNAL [f: LFHandle];  -- Gf  EnumerateGF: PROC [h: Handle, proc: PROC [GFHandle] RETURNS [BOOLEAN]] RETURNS [gf: GFHandle];  Name: PROC [h: Handle, name: LONG STRING, gf: GFHandle ¬ NILGF];  GFrame: PROC [h: Handle, name: LONG STRING ¬ NIL] RETURNS [f: GFHandle];  FrameForHti: PROC [h: Handle, hti: HTIndex ¬ HTNull] RETURNS [f: GFHandle];  HtiForFrame: PROC [h: Handle, gf: GFHandle] RETURNS [HTIndex];  CodeBase: PROC [Handle, GFHandle] RETURNS [PrefixHandle];  CheckStarted: PROC [Handle, GFHandle] RETURNS [BOOLEAN];  Started: PROC [Handle, GFHandle] RETURNS [BOOLEAN];  Shared: PROC [Handle, GFHandle] RETURNS [BOOLEAN];  Copied: PROC [Handle, GFHandle] RETURNS [BOOLEAN];  Original: PROC [h: Handle, new: GFHandle] RETURNS [old: GFHandle];  SameModule: PROC [h: Handle, gf1, gf2: GFHandle] RETURNS [BOOLEAN];  CodeLinks: PROC [Handle, GFHandle] RETURNS [BOOLEAN];  MakeDesc: PROC [h: Handle, gf: GFHandle, ep: CARDINAL] RETURNS [pd: ControlLink];  DisplayInMsg: PROC [h: Handle, gf: GFHandle, delim: STRING];  DisplayGFT: PROC[h: Handle];  DumpFrameDesc: PROC [h: Handle, mod: LONG STRING, list: FrameDesc];  MultipleFrames: ERROR [list: FrameDesc];  -- DI  MakeLongType: PROC [h: Handle, rType: SEIndex] RETURNS [type: CSEIndex];  GetNumber: PROC [h: Handle, f: Foo, code: CommandList.DIErr ¬ invalidNumber] RETURNS [n: Number];  DIFormat: PROC [h: Handle, sei: SEIndex] RETURNS [vf: ValFormat, intSub: BOOLEAN];  GetValue: PROC [h: Handle, f: Foo];  PutValue: PROC [h: Handle, lhs: Foo, from: LONG POINTER];  Normalize: PROC [bits: CARDINAL] RETURNS [word, offset: CARDINAL] =    INLINE {[word, offset] ¬ Inline.DIVMOD[bits, Environment.bitsPerWord]};  GetControlLink: PROC [Handle, Foo] RETURNS [ControlLink];  DerefProcDesc: PROC [Handle, ControlLink] RETURNS [ControlLink];  NotAProcedure: ERROR [cl: ControlLink];  GetDesc: PROC [Handle, Foo] RETURNS [LongDesc, ArraySEIndex];  GetLongDesc: PROC [Handle, Foo] RETURNS [LongDesc, ArraySEIndex];  NotAnArray: ERROR;  NotHere: ERROR;  SizeMismatch: ERROR;  SetDefaultRadix: PROC [CARDINAL];  CheckClass: PROC [h: Handle, tc: Symbols.TypeClass, f: Foo] RETURNS [UNSPECIFIED];  Pad: PROC [h: Handle, f: Foo, rsei: RecordSEIndex] RETURNS [pad: CARDINAL];  MapCtx: PROC [Handle, MDIndex, CTXIndex] RETURNS [IncludedCTXIndex];  SearchCtxList: PROC [h: Handle, hti: HTIndex, ctx: CTXIndex] RETURNS [sei: ISEIndex];  SearchCtxForVal: PROC [h: Handle, val: UNSPECIFIED, ctx: CTXIndex, tm: Symbols.TransferMode] RETURNS [sei: ISEIndex];  TypeForSe: PROC [h: Handle, sei: SEIndex] RETURNS [type: CSEIndex];   FindField: PROC [h: Handle, f: Foo, pad: CARDINAL, isei: ISEIndex] RETURNS [field: Foo];  TagIsei: PROC [h: Handle, f: Foo, pad: CARDINAL, usei: UnionSEIndex] RETURNS [isei: ISEIndex];  VariantType: PROC [Handle, UnionSEIndex] RETURNS [VType];  AbortWithError: PROC [h: Handle, code: CommandList.DIErr, hti: HTIndex ¬ HTNull];  Error: PROC [h: Handle, code: CommandList.DIErr, hti: HTIndex ¬ HTNull];  IllegalConditional: ERROR;    -- CPSource  IgnoreTimeStamp: PROC [Handle, Window.Handle] RETURNS [BOOLEAN];  LoadWindow: PROC [h: Handle, name: LONG STRING, gf: GFHandle ¬ NILGF, file: Stream.Handle ¬ NIL, position: LONG CARDINAL];  ResetFrames: PROC[h: Handle];  DisplaySource: PROC [h: Handle, gf: GFHandle, pc: BytePC, load: BOOLEAN];  SpecialDisplay: PROC [h: Handle, out: Format.StringProc, gf: GFHandle, pc: BytePC, load: BOOLEAN, msg: LONG STRING ¬ NIL, suppressErrors: BOOLEAN ¬ FALSE];  PcToSource: PROCEDURE [h: Handle, base: SymbolTable.Handle, gf: GFHandle, pc: BytePC, bti: BTIndex, start: BytePC] RETURNS [currentSource: CARDINAL];  CheckTimes: PROCEDURE [h: Handle, w: Window.Handle, gf: GFHandle, sh: Stream.Handle];  FileMissing: SIGNAL [name: LONG STRING];  MappingFailure: SIGNAL;  }.
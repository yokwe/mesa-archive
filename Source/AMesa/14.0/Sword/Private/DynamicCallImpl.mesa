-- DynamicCallImpl.mesaDIRECTORYIT, WorldVMOps, IO, IS, SymbolOps, Inline,AMLoadstate, AMUseful,BcdDefs, BcdDefsExtras,BcdOps,BcdOpsExtras,DynamicCall,PrincOps, PrincOpsExtras2,MFile,MSegment,Symbols,SymbolSegment,SymbolTable,String;DynamicCallImpl: PROGRAM   IMPORTS AMLoadstate, AMUseful, BcdOps, BcdOpsExtras, IO, IS, WorldVMOps, Inline,    MFile, SymbolTable, MSegment, String, SymbolOps  EXPORTS DynamicCall, SymbolTable = {    SymSegHandle: PUBLIC TYPE = MSegment.Handle;  «Modules: TYPE = LONG POINTER TO ModulesObject;  ModulesObject: TYPE = RECORD[length: CARDINAL ¬ 0,     of: SEQUENCE maxLength: CARDINAL OF ModuleRecord];»  ModuleRecord: TYPE = RECORD[index: AMLoadstate.Index, mti: BcdDefs.MTIndex];  NullModuleRecord: ModuleRecord = [index: AMLoadstate.nullIndex, mti: BcdDefs.MTNull];    «AddModule: PROC[modules: Modules, mod: ModuleRecord] RETURNS[Modules] = {    SELECT TRUE FROM       modules = NIL => modules ¬ IO.zone.NEW[ModulesObject[10]];      modules.length = modules.maxLength => {	temp: Modules ¬ IO.zone.NEW[ModulesObject[modules.length+10] ¬ [length: modules.length]];	FOR i: CARDINAL IN [0..modules.length) DO temp[i] ¬ modules[i]; ENDLOOP;	zone.FREE[@modules];	modules ¬ temp };      ENDCASE;    modules[modules.length] ¬ mod;    modules.length ¬ modules.length + 1 };»        CantParse: ERROR = CODE;    Parse: PROC[interfaceDotProc: LONG STRING]     RETURNS[interface, proc: String.SubStringDescriptor] = {    FOR i: CARDINAL IN [1..interfaceDotProc.length-1) DO      IF interfaceDotProc[i] = '. OR interfaceDotProc[i] = '$      THEN RETURN[        interface: [base: interfaceDotProc, offset: 0, length: i], 	proc: [base: interfaceDotProc, offset: i+1, 	  length: interfaceDotProc.length-i-1]];      REPEAT FINISHED => ERROR CantParse;      ENDLOOP};        Importer: PUBLIC PROC[h: IT.Handle, string: LONG STRING] = {      exportedLink: LONG POINTER;    exporterIndex: AMLoadstate.Index;      OneBcd: AMLoadstate.BcdProc = {      bcd: BcdOps.BcdBase = AMLoadstate.AcquireBcd[loadstate, index];      nameString: BcdOps.NameString = BcdOpsExtras.NameStringFromBcd[bcd];      ftb: BcdDefs.Base = BcdOpsExtras.FTBaseFromBcd[bcd];      lfb: BcdDefs.Base = BcdOpsExtras.LFBaseFromBcd[bcd];      imh: BcdOps.IMPHandle;      ss: String.SubStringDescriptor;      nameRecord: BcdDefs.NameRecord;      «FindImport: PROCEDURE [imh: BcdOps.IMPHandle, imi: BcdDefs.IMPIndex] RETURNS [BOOLEAN] = {        RETURN[ftb[imh.file].version = version]};»            «FindImport: PROCEDURE [imh: BcdOps.IMPHandle, imi: BcdDefs.IMPIndex] RETURNS [BOOLEAN] = {        impname: String.SubStringDescriptor ¬ [base: @nameString.string, 	  offset: imh.name, length: nameString.size[imh.name]];        RETURN[String.EqualSubString[@impname, @interface]]};»            FindImport: PROCEDURE [imh: BcdOps.IMPHandle, imi: BcdDefs.IMPIndex] RETURNS [BOOLEAN] = {        impname: String.SubStringDescriptor ¬ [base: @nameString.string, 	  offset: ftb[imh.file].name, length: nameString.size[ftb[imh.file].name]];        RETURN[String.EqualSubString[@impname, @interface]]};	      FindModule: PROCEDURE [mth: BcdOps.MTHandle, mti: BcdDefs.MTIndex] RETURNS [BOOLEAN] = {	PrintModule: PROC[] RETURNS[] = {	  nameRecord ¬ IF mth.namedInstance 	    THEN BcdOps.FindName[bcd, [module[mti]]] ELSE mth.name;	  ss ¬ [@nameString.string, nameRecord, nameString.size[nameRecord]];	  IO.Blanks[h, 2]; 	  IO.SubString[h, @ss] };	lfh: BcdOps.LFHandle;	IF mth.links = BcdDefs.LFNull THEN RETURN[FALSE];	lfh ¬ @lfb[mth.links];	FOR i: NAT IN [0..lfh.length) DO	  WITH lfh[i] SELECT FROM	    procedure => IF gfi = imh.gfi AND ep = item THEN { PrintModule[]; EXIT };	    signal => IF gfi = imh.gfi AND index = item THEN { PrintModule[]; EXIT };	    variable => IF gfi = imh.gfi AND offset = item THEN { PrintModule[]; EXIT };	    ENDCASE;	  ENDLOOP;	RETURN[FALSE] };	      SearchLinks: PROC [modInfo: AMLoadstate.ModuleInfo] RETURNS [stop: BOOLEAN] = {        PrintModule: PROC[] RETURNS[] = {	  mti: BcdDefs.MTIndex = BcdOpsExtras.MtiFromGfi[modInfo.cgfi];	  mth: BcdOps.MTHandle = BcdOpsExtras.MthFromGfi[bcd, modInfo.cgfi];	  nameRecord ¬ IF mth.namedInstance 	    THEN BcdOps.FindName[bcd, [module[mti]]] ELSE mth.name;	  ss ¬ [@nameString.string, nameRecord, nameString.size[nameRecord]];	  IO.Blanks[h, 2]; 	  IO.SubString[h, @ss] };	gf: WorldVMOps.LongGlobalFrameHandle = WorldVMOps.GFlong[h.world, modInfo.gf];        codebase: PrincOps.PrefixHandle = WorldVMOps.CodebaseFromGf[h.world, gf];        nLinks: [0..PrincOps.maxNLinks] = Inline.BITAND[WorldVMOps.Read[h.world, @codebase.header], 255];	LinksObject: TYPE = RECORD[of: SEQUENCE maxLength: CARDINAL OF LONG POINTER];	links: LONG POINTER TO LinksObject ¬ IO.zone.NEW[LinksObject[nLinks]];	from: LONG POINTER ¬ 	  IF WorldVMOps.Codelinks[h.world, gf] THEN codebase - nLinks*SIZE[LONG POINTER]	  ELSE gf - SIZE[PrincOpsExtras2.GlobalOverhead] - nLinks*SIZE[LONG POINTER];	WorldVMOps.CopyRead[world: h.world, from: from, to: @links[0], nwords: nLinks*SIZE[LONG POINTER]];	FOR i: [0..PrincOps.maxNLinks] IN [0..nLinks) DO	  IF links[i] = exportedLink THEN { PrintModule[]; EXIT };	  ENDLOOP;	IO.zone.FREE[@links];        RETURN[FALSE] };	      IF exportedLink = NIL OR index # exporterIndex THEN { -- nobody exporting proc, or different config	[imh,] ¬ BcdOps.ProcessImports[bcd, FindImport];	IF imh = NIL THEN RETURN[FALSE];	[] ¬ BcdOps.ProcessModules[bcd, FindModule] }      ELSE { -- search bound links for proc        [] ¬ AMLoadstate.EnumerateModulesInConfig[loadstate, SearchLinks, index] };      RETURN[FALSE] }; -- check if anyone else imports it           index: AMLoadstate.Index;    loadstate: AMLoadstate.Handle;    interface, proc: String.SubStringDescriptor;    item: CARDINAL;    version: BcdDefs.VersionStamp;    [interface, proc] ¬ Parse[string ! CantParse => GOTO nil];    [item, version] ¬ EpForProcedure[h, @interface, @proc];    IF item = ItemNull THEN GOTO nil;    [LOOPHOLE[exportedLink, PrincOpsExtras2.ImportLink], exporterIndex] ¬ ExporterInternal[h, string, FALSE];    loadstate ¬ WorldVMOps.GetLoadstate[h.world];    [,index] ¬ AMLoadstate.EnumerateBcds[loadstate, OneBcd, FALSE];    EXITS nil => NULL };      Exporter: PUBLIC PROC[h: IT.Handle, string: LONG STRING] = {    [] ¬ ExporterInternal[h, string, TRUE] };      ExporterInternal: PROC[h: IT.Handle, string: LONG STRING, print: BOOLEAN]     RETURNS[exportedLink: PrincOpsExtras2.ImportLink ¬ PrincOpsExtras2.nullProcImportLink,      exporterIndex: AMLoadstate.Index] = {    OneBcd: AMLoadstate.BcdProc = {      bcd: BcdOps.BcdBase = AMLoadstate.AcquireBcd[loadstate, index];      nameString: BcdOps.NameString = BcdOpsExtras.NameStringFromBcd[bcd];      ftb: BcdDefs.Base = BcdOpsExtras.FTBaseFromBcd[bcd];      eth: BcdOps.EXPHandle;      ss: String.SubStringDescriptor;      nameRecord: BcdDefs.NameRecord;            TryType: PROC[] = {        OneTypeMap: PROC[tmh: BcdOps.TMHandle, tmi: BcdDefs.TMIndex] RETURNS[BOOLEAN] = {          RETURN[tmh.version = version AND tmh.offset = item]};	OneFile: PROC[fth: BcdOps.FTHandle, fti: BcdDefs.FTIndex] RETURNS[BOOLEAN] = {	  RETURN[fth.version = typh.version]};	tmh: BcdOps.TMHandle;	typh: BcdOps.TYPHandle;	typi: BcdDefs.TYPIndex;	fth: BcdOps.FTHandle;	[tmh,] ¬ BcdOps.ProcessTypeMap[bcd, OneTypeMap];	IF tmh = NIL THEN RETURN;	typi ¬ tmh.map;	IF typi = BcdDefs.TYPNull THEN RETURN;	typh ¬ @BcdOpsExtras.TYPBaseFromBcd[bcd][typi];	[fth,] ¬ BcdOps.ProcessFiles[bcd, OneFile];	IF fth # NIL THEN {	  nameRecord ¬ fth.name;	  ss ¬ [@nameString.string, nameRecord, nameString.size[nameRecord]];	  IF print THEN {	    IO.Blanks[h, 2]; 	    IO.SubString[h, @ss]}}	ELSE	  IF bcd.version = typh.version THEN {	    nameRecord ¬ BcdOpsExtras.MTBaseFromBcd[bcd][FIRST[BcdDefs.MTIndex]].name;	    ss ¬ [@nameString.string, nameRecord, nameString.size[nameRecord]];	    IF print THEN {	      IO.Blanks[h, 2]; 	      IO.SubString[h, @ss] }}};            «FindExport: PROCEDURE [eth: BcdOps.EXPHandle, eti: BcdDefs.EXPIndex] RETURNS [BOOLEAN] = {        RETURN[ftb[eth.file].version = version]};»            «FindExport: PROCEDURE [eth: BcdOps.EXPHandle, eti: BcdDefs.EXPIndex] RETURNS [BOOLEAN] = {        expname: String.SubStringDescriptor ¬ [base: @nameString.string, 	  offset: eth.name, length: nameString.size[eth.name]];        RETURN[String.EqualSubString[@expname, @interface]]};»      FindExport: PROCEDURE [eth: BcdOps.EXPHandle, eti: BcdDefs.EXPIndex] RETURNS [BOOLEAN] = {        expname: String.SubStringDescriptor ¬ [base: @nameString.string, 	  offset: ftb[eth.file].name, length: nameString.size[ftb[eth.file].name]];        RETURN[String.EqualSubString[@expname, @interface]]};      [eth,] ¬ BcdOps.ProcessExports[bcd, FindExport];      IF eth = NIL THEN {TryType[]; RETURN[FALSE]};      IF eth.links[item] = BcdDefs.NullLink THEN {TryType[]; RETURN[FALSE]};      BEGIN        link: BcdDefs.Link;	cgfi: BcdDefs.GFIndex; 	mth: BcdOps.MTHandle; 	link ¬ eth.links[item];	WITH link SELECT FROM	  procedure => cgfi ¬ gfi; 	  signal => cgfi ¬ gfi;  	  variable => cgfi ¬ gfi;  	  type => {TryType[]; RETURN[FALSE]};	  ENDCASE;	mth ¬ BcdOpsExtras.MthFromGfi[bcd, cgfi];		BEGIN	old: BOOLEAN = mth.spare = BcdDefsExtras.OldMesaModule;	gf: WorldVMOps.LongGlobalFrameHandle ¬ AMUseful.MapConfigToReal[h.world, BcdOpsExtras.MtiFromGfi[cgfi], index];	gft: WorldVMOps.GlobalFrameHandle ¬ WorldVMOps.GFshort[h.world, gf];	WITH l: link SELECT FROM	  procedure => {	    enh: BcdOps.ENHandle = @BcdOpsExtras.ENBaseFromBcd[bcd][mth.entries];	    IF old 	    THEN exportedLink ¬ [oldProc[proc: [shortProc[gf: Inline.BITOR[Inline.LowHalf[gf], 1], pc: enh.initialPC[l.ep]]]]]	    ELSE exportedLink ¬ [newProc[proc: [longProc[gfi: Inline.BITOR[gft, 3], pc: enh.initialPC[l.ep]]]]] };	  signal => 	    IF old 	    THEN exportedLink ¬ [oldSignal[signal: [gf: Inline.LowHalf[gf], index: l.index]]]	    ELSE exportedLink ¬ [newSignal[signal: [gf: Inline.BITOR[gft, 3], index: l.index]]];	  variable => 	    exportedLink ¬ [variable[pointer: gf + l.offset]];	  ENDCASE;	exporterIndex ¬ index;	END;		nameRecord ¬ IF mth.namedInstance THEN BcdOps.FindName[bcd, [module[BcdOpsExtras.MtiFromGfi[cgfi]]]] ELSE mth.name;	ss ¬ [@nameString.string, nameRecord, nameString.size[nameRecord]];        IF print THEN {	  IO.Blanks[h, 2]; 	  IO.SubString[h, @ss] };	RETURN[FALSE]; -- check if anyone else exports it 	END };    index: AMLoadstate.Index;    loadstate: AMLoadstate.Handle;    interface, proc: String.SubStringDescriptor;    item: CARDINAL;    version: BcdDefs.VersionStamp;    [interface, proc] ¬ Parse[string ! CantParse => GOTO nil];    [item, version] ¬ EpForProcedure[h, @interface, @proc];    IF item = ItemNull THEN GOTO nil;    loadstate ¬ WorldVMOps.GetLoadstate[h.world];    [,index] ¬ AMLoadstate.EnumerateBcds[loadstate, OneBcd, FALSE];    EXITS nil => NULL };          ItemNull: CARDINAL = LAST[CARDINAL];  altoBias: CARDINAL = 1;    EpForProcedure: PROC[h: IT.Handle, interface, proc: String.SubString]     RETURNS[item: CARDINAL ¬ ItemNull, version: BcdDefs.VersionStamp ¬ BcdDefs.NullVersion] = {    filename: LONG STRING ¬ [MFile.maxNameLength];    BEGIN    mfile: MFile.Handle ¬ NIL;    segment: SymSegHandle ¬ NIL;    bcd: BcdOps.BcdBase;    mth: BcdOps.MTHandle;    sgh: BcdOps.SGHandle;    sym: SymbolTable.Handle;    Cleanup: PROC[] = {IF segment # NIL THEN MSegment.Delete[segment]};    String.AppendSubString[filename, interface];    [] ¬ String.AppendExtensionIfNeeded[@filename, ".bcd"L, NIL];    mfile ¬ MFile.ReadOnly[filename, [] ! MFile.Error => GOTO NoFile];    BEGIN ENABLE UNWIND => {Cleanup[]};    segment ¬ MSegment.Create[file: mfile, release: []];    bcd ¬ MSegment.Address[segment];    IF ~bcd.definitions THEN {Cleanup[]; RETURN};    version ¬ bcd.version;    mth ¬ @BcdOpsExtras.MTBaseFromBcd[bcd][FIRST[BcdDefs.MTIndex]];    sgh ¬ @BcdOpsExtras.SGBaseFromBcd[bcd][mth.sseg];    MSegment.Reset[segment: segment, fileBase: sgh.base-altoBias, pages: sgh.pages];    END; -- ENABLE     sym ¬ SymbolTable.Acquire[segment];    FOR sei: Symbols.ISEIndex ¬ SymbolOps.FirstCtxSe[sym, sym.mainCtx],       SymbolOps.NextSe[sym, sei] UNTIL sei = Symbols.ISENull DO      symbolname: String.SubStringDescriptor;      SymbolOps.SubStringForHash[sym, @symbolname, sym.seb[sei].hash];       IF String.EqualSubString[proc, @symbolname] AND 	  (IF sym.seb[sei].idType = Symbols.typeTYPE	  THEN (sym.seb[SymbolOps.UnderType[sym, sei]].typeTag = opaque)	  ELSE TRUE)      THEN {item ¬ SymbolOps.ToCard[sym.seb[sei].idValue]; EXIT};      REPEAT FINISHED => IS.WriteError[h, notFound, FALSE];      ENDLOOP;    SymbolTable.Release[sym];    Cleanup[];    EXITS NoFile => { IO.Text["  Cant find "L, h]; IO.Text[filename, h]; RETURN };    END };      }..
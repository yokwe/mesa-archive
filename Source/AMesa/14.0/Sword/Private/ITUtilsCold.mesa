-- File: ITUtilsCold.mesa - last edit:-- Litman              21-Apr-87 23:01:54-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.DIRECTORY  ComData USING [CSEIndex, ISEIndex, seAnon, typeBOOL, typeCONDITION, typeLOCK, typeStringBody],  Copier USING [AugmentContext, CompleteContext, CopyingInline, CopyUnion, FindExternalCtx, Handle, Outer, SEToken, TokenSymbol],  Environment USING [bitsPerWord],  IB USING [],  IC USING [],  IG USING [],  IO USING [EOL, Line, Node, Numeric, Pages, StringExpToLDecimal, Text],  IP USING [AbortWithError, CopyLiteral, GetValue, GF, GFrame, MakeDesc, NoAccessLink, Normalize, Pad, SearchCtxList, TypeForSe],  IQ USING [CheckGF, GFrameMdi, InvalidFrame, LOrGType, ValidateF, ValidateGF],  IR USING [],  IS USING [GFFromIContext, HtiVal, LongNum],  IT USING [ArraySEIndex, BitAddress, BTIndex, BytePC, ControlLink, CSEIndex, CTXIndex, Desc, Flavor, FobTable, Foo, GFHandle, Handle, HTIndex, IncludedCTXIndex, ISEIndex, LFHandle, LongDesc, MaxFobCnt, MDIndex, NullFob, RecordSEIndex, SEIndex, SignalDesc],  Mopcodes USING [zWLFS],  PrincOps USING [BytePC, ControlLink, FieldDescriptor, GlobalFrameHandle, MaxParamsInStack, StateVector],  PrincOpsExtras USING [ImportLink, nullProcImportLink, nullVariableImportLink, SignalDesc],  SymbolOps USING [Cardinality, EnterExtension, FindExtension, FirstCtxSe, FnField, Handle, NextSe, NormalType, ToBti, ToCard, ToLink, TypeForm, UnderType, WordsForType, XferMode],  Symbols USING [BitAddress, BTNull, CTXNull, DummyLink, ExtensionType, HTNull, IncludedCTXIndex, IncludedCTXNull, ISENull, MDNull, SENull, SERecord, TransferMode, typeANY, typeTYPE],  SymbolTable USING [Handle, Missing],  Tree USING [Link, Node, Null],  TreeOps USING [FreeTree],  WorldVMOps USING [Address, ControlLink, CopyRead, CopyWrite, GetLink, GetSV, GFFromControlLink, GFlong, GFshort, Long, NilAddress, Read, Write];ITUtilsCold: PROGRAM  IMPORTS IO, IP, IQ, IS, com: ComData, Copier, SymbolOps, SymbolTable, TreeOps, WorldVMOps  EXPORTS IB, IC, IG, IO, IP, IR   SHARES Copier = {  OPEN IT;  NotAProcedure: PUBLIC ERROR [cl: ControlLink] = CODE;  NotAnArray: PUBLIC ERROR = CODE;  NotHere: PUBLIC ERROR = CODE;  NoStack: PUBLIC ERROR = CODE;  SizeMismatch: PUBLIC ERROR = CODE;  NotRelocated: PUBLIC SIGNAL RETURNS [LONG POINTER] = CODE;  CantAssignInDebuggerImage: ERROR = CODE;  UnexpectedLiteral: ERROR = CODE;  LiteralProblem: PUBLIC ERROR = CODE;  OffsetVariableCrossesWordBoundary: ERROR = CODE;  ConfusedAboutImports: ERROR = CODE;  NoTree: ERROR = CODE;  -- finding union and discriminated types  VariantUnionType: PUBLIC PROC [h: Handle, type: SEIndex] RETURNS [vType: CSEIndex] = {    rType: CSEIndex ¬ IP.TypeForSe[h, type];    vType ¬ WITH h.seb[rType] SELECT FROM      record =>	IF hints.variant	THEN SymbolOps.UnderType[h.sym, IP.TypeForSe[h, UnionField[h, LOOPHOLE[rType]]]]	ELSE Symbols.typeANY,      ENDCASE => Symbols.typeANY };  SelectVariantType: PUBLIC PROCEDURE [h: Handle, type: SEIndex, tag: HTIndex] RETURNS [sei: ISEIndex] = {    vType: CSEIndex = VariantUnionType[h, type];    WITH h.seb[vType] SELECT FROM      union => sei ¬ IP.SearchCtxList[h, tag, caseCtx];      ENDCASE => sei ¬ Symbols.ISENull;    IF sei = Symbols.ISENull THEN IP.AbortWithError[h, unknownVariant, tag] };-- auxiliary procedures   UnionField: PROCEDURE [h: Handle, rSei: RecordSEIndex] RETURNS [ISEIndex] = {    sei, root, next: ISEIndex;    ctx: CTXIndex = h.seb[rSei].fieldCtx;    repeated: BOOLEAN;    IF h.ctxb[ctx].ctxType = simple THEN      FOR sei ¬ h.ctxb[ctx].seList, next UNTIL sei = Symbols.ISENull DO	next ¬ SymbolOps.NextSe[h.sym, sei];	IF next = Symbols.ISENull THEN RETURN [sei];	ENDLOOP    ELSE {      repeated ¬ FALSE;      DO	sei ¬ root ¬ h.ctxb[ctx].seList;	DO	  IF sei = Symbols.ISENull THEN EXIT;	  IF SymbolOps.TypeForm[h.sym, IP.TypeForSe[h, sei]] = union THEN RETURN [sei];	  IF (sei ¬ SymbolOps.NextSe[h.sym, sei]) = root THEN EXIT;	  ENDLOOP;	IF repeated THEN EXIT;	Copier.CopyUnion[h.sym, h.seb[rSei].fieldCtx];  repeated ¬ TRUE;	ENDLOOP};    RETURN [com.seAnon]};  MapCtx: PUBLIC PROC [h: Handle, mdi: MDIndex, ctx: CTXIndex] RETURNS [ictx: IncludedCTXIndex] = {    IF mdi = Symbols.MDNull OR ctx = Symbols.CTXNull THEN RETURN[Symbols.IncludedCTXNull];    FOR ictx ¬ h.mdb[mdi].ctx, h.ctxb[ictx].chain UNTIL ictx = Symbols.IncludedCTXNull DO      IF h.ctxb[ictx].map = ctx THEN EXIT;      REPEAT FINISHED => ictx ¬ Copier.FindExternalCtx[h.sym, mdi, ctx];      ENDLOOP };  SearchCtxForVal: PUBLIC PROC [h: Handle, val: UNSPECIFIED, ctx: CTXIndex, tm: Symbols.TransferMode] RETURNS [sei: ISEIndex] = {    IF ctx = Symbols.CTXNull THEN RETURN [Symbols.ISENull];    IF (sei ¬ SearchValContext[h, val, ctx, tm]) # Symbols.ISENull THEN RETURN;    WITH h.ctxb[ctx] SELECT FROM      included => IF ~complete THEN sei ¬ Copier.TokenSymbol[h.sym, ctx, Generator[h, module, map, val, tm]];      imported => sei ¬ SearchCtxForVal[h, val, includeLink, tm];      simple => NULL;      ENDCASE };  SearchValContext: PROC [h: Handle, val: UNSPECIFIED, ctx: CTXIndex, tm: Symbols.TransferMode] RETURNS [ISEIndex] = {    sei: ISEIndex;    root: ISEIndex ¬ h.ctxb[ctx].seList;    sei ¬ root;    DO      IF sei = Symbols.SENull THEN EXIT;      IF h.seb[sei].idValue = val AND CheckIsei[h.sym, sei, tm] THEN RETURN [sei];      WITH id: h.seb[sei] SELECT FROM        sequential =>  sei ¬ sei + SIZE[sequential id Symbols.SERecord];        linked =>  IF (sei ¬ id.link) = root THEN EXIT;        ENDCASE => EXIT;      ENDLOOP;    RETURN [Symbols.ISENull] };  Generator: PROC [h: Handle, mdi: MDIndex, ctx: CTXIndex, val: UNSPECIFIED, tm: Symbols.TransferMode]    RETURNS [token: Copier.SEToken] = {    Search: PROC [iBase: SymbolTable.Handle] = {      isei: ISEIndex;      FOR isei ¬ SymbolOps.FirstCtxSe[iBase, ctx],         SymbolOps.NextSe[iBase, isei] UNTIL isei = Symbols.ISENull DO	IF (iBase.seb[isei].idValue = val) AND CheckIsei[iBase, isei, tm] THEN EXIT;	ENDLOOP;      token ¬ [isei] };    Copier.Outer[h.sym, mdi, Search] };  CheckIsei: PROC [base: SymbolTable.Handle, isei: ISEIndex,     tm: Symbols.TransferMode] RETURNS [BOOLEAN] = {    SELECT SymbolOps.XferMode[base, base.seb[isei].idType] FROM      tm => RETURN[base.seb[isei].constant];      signal => IF tm = error THEN RETURN[base.seb[isei].constant];      error => IF tm = signal THEN RETURN[base.seb[isei].constant];      ENDCASE;    RETURN[FALSE] };  ArraySei: PROC [h: Handle, sei: SEIndex] RETURNS [asei: ArraySEIndex, desc, long: BOOLEAN] = {    csei: CSEIndex ¬ IP.TypeForSe[h, sei];    desc ¬ long ¬ FALSE;    DO      WITH h.seb[csei] SELECT FROM	array => {asei ¬ LOOPHOLE[csei]; EXIT};	arraydesc => {	  asei ¬ LOOPHOLE[SymbolOps.UnderType[h.sym, describedType]];	  desc ¬ TRUE;	  EXIT };	long => {long ¬ TRUE; csei ¬ IP.TypeForSe[h, rangeType]};	ENDCASE => NotAnArray;      ENDLOOP };  GetDesc: PUBLIC PROC [h: Handle, f: Foo] RETURNS [d: LongDesc, asei: ArraySEIndex] = {    desc, long: BOOLEAN;    [asei:asei, desc:desc, long:long] ¬ ArraySei[h, f.tsei];    IF long THEN ERROR SizeMismatch;    IF ~desc THEN {      d.base ¬ f.addr.base;      d.length ¬ CARDINAL[SymbolOps.Cardinality[h.sym, h.seb[asei].indexType]];      d.offset ¬ f.addr.offset }    ELSE {      sd: Desc;      IP.GetValue[h, f];      sd ¬ LOOPHOLE[f.addr.base, LONG POINTER TO Desc]­;      d.base ¬ WorldVMOps.Long[h.world, sd.base];      d.length ¬ sd.length;      d.offset ¬ 0 }};  GetLongDesc: PUBLIC PROC [h: Handle, f: Foo] RETURNS [ld: LongDesc, asei: ArraySEIndex] = {    desc, long: BOOLEAN;    lp: LONG POINTER TO LongDesc;    [asei:asei, desc:desc, long:long] ¬ ArraySei[h, f.tsei];    IF ~long THEN ERROR SizeMismatch;    IF ~desc THEN {      ld.base ¬ f.addr.base;      ld.length ¬ CARDINAL[SymbolOps.Cardinality[h.sym, h.seb[asei].indexType]];      ld.offset ¬ f.addr.offset }    ELSE {      IP.GetValue[h, f];      lp ¬ f.addr.base;      ld.base ¬ lp.base;      ld.length ¬ lp.length;      ld.offset ¬ 0 }};  WFS: PROC [UNSPECIFIED, LONG POINTER, PrincOps.FieldDescriptor] =    MACHINE CODE { Mopcodes.zWLFS };  PutValue: PUBLIC PROC [h: Handle, lhs: Foo, from: LONG POINTER] = {    to: LONG POINTER = lhs.addr.base;    SELECT TRUE FROM      lhs.there => NULL;      lhs.addr.useStack => {        -- get address of sv off of stack (yechh)        IF <<we couldn't get it>> TRUE THEN IP.AbortWithError[h, illegalConstantOp, lhs.hti]};      ENDCASE => ERROR CantAssignInDebuggerImage;    IF lhs.addr.offset # 0 OR lhs.bits # 0 THEN {      val: UNSPECIFIED ¬ WorldVMOps.Read[h.world, to];      fd: PrincOps.FieldDescriptor ¬ [offset: 0, posn: lhs.addr.offset, size: lhs.bits];      WFS[from­, @val, fd];      WorldVMOps.Write[h.world, to, val] }    ELSE WorldVMOps.CopyWrite[world: h.world, from: from, nwords: lhs.words, to: to] };      GetSignalDesc: PUBLIC --IC-- PROC[h: Handle, f: Foo] RETURNS [sig: IT.SignalDesc] = {    OPEN psig: LOOPHOLE[sig, PrincOpsExtras.SignalDesc];    IF f.there THEN IP.GetValue[h, f];    -- occurs for signals if index = 0    IF f.words = 1 THEN psig ¬ [gf: f.addr.base­, index: 0]    ELSE psig ¬ LOOPHOLE[f.addr.base, LONG POINTER TO PrincOpsExtras.SignalDesc]­ };      GetControlLink: PUBLIC PROC [h: Handle, f: Foo] RETURNS [cl: IT.ControlLink] = {    OPEN pcl: LOOPHOLE[cl, PrincOps.ControlLink];    IF f.there THEN IP.GetValue[h, f];    IF WorldVMOps.NilAddress[h.world, f.addr.base] THEN IP.AbortWithError[h, invalidAddress, Symbols.HTNull];    -- occurs for signals if index = 0    IF f.words = 1 THEN pcl ¬ [procedure[gf: f.addr.base­, pc: [0]]]    ELSE pcl ¬ LOOPHOLE[f.addr.base, LONG POINTER TO PrincOps.ControlLink]­ };  DerefProcDesc: PUBLIC PROC [h: Handle, cl: IT.ControlLink] RETURNS [IT.ControlLink] = {    OPEN pcl: LOOPHOLE[cl, PrincOps.ControlLink];    WHILE ~pcl.proc AND pcl.indirect DO      WorldVMOps.CopyRead[world: h.world, from: WorldVMOps.Long[h.world, pcl.link], to: @pcl, nwords: SIZE[ControlLink]];      ENDLOOP;    IF ~pcl.proc --OR cl.indirect-- THEN ERROR NotAProcedure[cl];    RETURN[cl] };    GetGlobalFrame: PUBLIC --IC-- PROC[h: IT.Handle, gf: PrincOps.GlobalFrameHandle] RETURNS[IT.GFHandle] = {    RETURN[WorldVMOps.GFlong[h.world, gf]]};    GFFromControlLink: PUBLIC --IC-- PROC[h: IT.Handle, cl: IT.ControlLink] RETURNS[IT.GFHandle] = {    RETURN[WorldVMOps.GFFromControlLink[h.world, cl]] };      PCFromControlLink: PUBLIC --IC-- PROC[h: IT.Handle, cl: IT.ControlLink] RETURNS[IT.BytePC] = {    RETURN[LOOPHOLE[cl, PrincOps.ControlLink].pc] };      GetModule: PUBLIC PROCEDURE [h: Handle, s: LONG STRING] RETURNS [gf: IT.GFHandle] = {    IF IO.Numeric[h, s] THEN gf ¬ LOOPHOLE[IO.StringExpToLDecimal[h, s]]    ELSE gf ¬ IP.GFrame[h, s] };  CopyMore: PUBLIC PROC [h: Handle, tsei: IT.SEIndex, doVariants: BOOLEAN ¬ FALSE] = {    csei: CSEIndex;    DO      WITH h.seb[tsei] SELECT FROM	id => tsei ¬ IF idType = Symbols.typeTYPE THEN SymbolOps.UnderType[h.sym, tsei] ELSE idType;	cons => { csei ¬ LOOPHOLE[tsei]; EXIT };	ENDCASE      ENDLOOP;    WITH h.seb[csei] SELECT FROM      enumerated => IF csei # com.typeBOOL THEN Complete[h, valueCtx];      record =>	SELECT csei FROM	  com.typeStringBody, com.typeLOCK, com.typeCONDITION => RETURN;	  ENDCASE => Complete[h, fieldCtx, doVariants];      ENDCASE};  Complete: PUBLIC PROCEDURE [h: Handle, ictx: IT.CTXIndex, variants: BOOLEAN ¬ FALSE] = {    CheckUnions: PROCEDURE [isei: ISEIndex] = {      tsei: SEIndex;      IF isei = Symbols.ISENull THEN RETURN;      tsei ¬ h.seb[isei].idType;      IF tsei = Symbols.typeTYPE THEN RETURN;      WITH se: h.seb[tsei] SELECT FROM	cons => WITH se SELECT FROM	  union =>  {	    Complete[h, caseCtx];	    FOR isei ¬ SymbolOps.FirstCtxSe[h.sym, caseCtx], SymbolOps.NextSe[h.sym, isei] UNTIL isei = Symbols.ISENull DO	      CopyMore[h, isei, TRUE];	      ENDLOOP};	  ENDCASE;	ENDCASE};    WITH h.ctxb[ictx] SELECT FROM      included =>         IF ~complete THEN {	  mdi: MDIndex;	  frame: GFHandle ¬ IS.GFFromIContext[h];	  mdi ¬ IQ.GFrameMdi[h, frame ! IQ.InvalidFrame, SymbolTable.Missing => GOTO bailout];	  « reset ¬ FALSE; -- hack! »	  Copier.AugmentContext[h.sym, LOOPHOLE[ictx], mdi ! Copier.CopyingInline => RESUME];	  EXITS bailout => NULL};      ENDCASE;    WITH h.ctxb[ictx] SELECT FROM      included =>         IF ~complete THEN {	  « reset ¬ FALSE; -- hack! »	  Copier.CompleteContext[h.sym, LOOPHOLE[ictx], full ! Copier.CopyingInline => RESUME] };      ENDCASE => RETURN;    IF variants THEN {      isei, root: ISEIndex;      isei ¬ root ¬ h.ctxb[ictx].seList;      DO	IF isei = Symbols.SENull THEN EXIT;	CheckUnions[isei];	WITH id: h.seb[isei] SELECT FROM	  sequential => isei ¬ isei + SIZE[sequential id Symbols.SERecord];	  linked => IF (isei ¬ id.link) = root THEN EXIT;	  ENDCASE => EXIT;	ENDLOOP}};  AddDesc: PROCEDURE [h: Handle, f: Foo, cl: ControlLink] = {    p: LONG POINTER TO ControlLink;    p ¬ IO.Node[h, SIZE[ControlLink]];    p­ ¬ cl;    f.addr.base ¬ p;    f.words ¬ SIZE[ControlLink]};  Constant: PROCEDURE [h: Handle, f: Foo, isei: IT.ISEIndex] = {    val: LONG POINTER;    length: CARDINAL ¬ 1;    IF ~h.seb[isei].extended THEN {      val ¬ IO.Node[h, length];      LOOPHOLE[val, LONG POINTER TO CARDINAL]­ ¬ SymbolOps.ToCard[h.seb[isei].idValue]}    ELSE {      tree: Tree.Link;      type: Symbols.ExtensionType;      [type, tree] ¬ SymbolOps.FindExtension[h.sym, isei];      IF type # value THEN ERROR UnexpectedLiteral;      IF tree = Tree.Null THEN {MakeFooError[h, noTree, h.seb[isei].hash]; ERROR NoTree};      WITH tree SELECT FROM	subtree =>	  SELECT h.tb[index].name FROM	    mwconst => tree ¬ h.tb[index].son[1];	    all => {MakeFooError[h, all, h.seb[isei].hash]; ERROR NoTree};	    ENDCASE => ERROR LiteralProblem;	literal => IF info.litTag # string THEN ERROR UnexpectedLiteral;	ENDCASE => ERROR UnexpectedLiteral;      WITH tree SELECT FROM	literal => [val, length] ¬ IP.CopyLiteral[h, info];	ENDCASE => ERROR LiteralProblem};    f.addr.base ¬ val;    f.words ¬ length;    f.constant ¬ TRUE };  Mode: PUBLIC PROCEDURE [h: Handle, isei: IT.ISEIndex] RETURNS [Flavor] = {    tsei: IT.SEIndex = IP.TypeForSe[h, isei];    transferMode: Symbols.TransferMode = SymbolOps.XferMode[h.sym, tsei];    constant: BOOLEAN = h.seb[isei].constant;    linkspace: BOOLEAN = h.seb[isei].linkSpace;    SELECT TRUE FROM      constant =>         SELECT transferMode FROM	  proc, program => {	    bti: IT.BTIndex = SymbolOps.ToBti[h.seb[isei].idInfo];	    IF h.seb[isei].extended THEN RETURN[inline];	    IF bti = Symbols.BTNull THEN RETURN[controlLink];	    WITH h.bb[bti] SELECT FROM	      Callable => IF inline THEN RETURN[inline] ELSE RETURN[proc];	      ENDCASE => {		CompilerScrewedUp: ERROR = CODE; 		ERROR CompilerScrewedUp }};	  signal, error => RETURN[signal];	  none => RETURN[manifest];	  ENDCASE => RETURN[manifest];      transferMode # none =>         IF linkspace THEN RETURN[refProc] 	ELSE RETURN[val]; -- predeclared (well known) SIGNAL or ERROR      linkspace => RETURN[refVal];      ENDCASE => RETURN[val]};        LinkError: PROCEDURE [h: Handle, gf: GFHandle] = {    IO.Text[" ! Can't find links from frame: "L, h];     IS.LongNum[h, gf, [pointer[]]];     IO.EOL[h] };  MakeFooError: PROCEDURE [h: Handle, err: {unbound, noTree, all}, u: HTIndex] = {    SELECT err FROM      unbound => {IO.EOL[h]; IS.HtiVal[h, u]; IO.Line[h, " is unbound!"L]};      noTree => {IO.Text[" ! Tree for "L, h]; IS.HtiVal[h, u]; IO.Line[h, " not in symbol table."L]};      all => {        IO.Text[" ! "L, h]; IS.HtiVal[h, u]; 	IO.Line[h, " is a constant array.  Look at source code for value."L]};      ENDCASE};  GetImportLink: PROC [h: Handle, gf: GFHandle, bitOffset: CARDINAL] RETURNS [link: PrincOpsExtras.ImportLink] = {    bitsPerLink: CARDINAL = Environment.bitsPerWord * SIZE[LONG POINTER];    linkNumber: CARDINAL = bitOffset/bitsPerLink;    IF ~IQ.ValidateGF[h, gf] THEN {      lf: LFHandle = LOOPHOLE[gf];      IF IQ.ValidateF[h, lf].ok THEN gf ¬ IP.GF[h, lf] ELSE ERROR };    link ¬ [variable[WorldVMOps.GetLink[h.world, gf, linkNumber]]] };  FrameAddress: PROC [h: Handle, ba: BitAddress, isei: IT.ISEIndex, sizeInc: CARDINAL] RETURNS [addr: BitAddress, size: CARDINAL] = {    delta: CARDINAL;    addr.useStack ¬ FALSE;    addr.local ¬ ba.local;    [delta, addr.offset] ¬ IP.Normalize[SymbolOps.ToCard[h.seb[isei].idValue]+ba.offset];    addr.base ¬ ba.base+delta;    size ¬ SymbolOps.ToCard[h.seb[isei].idInfo]+sizeInc };  StackAddress: PROC [h: Handle, ba: BitAddress, isei: IT.ISEIndex] RETURNS [addr: BitAddress, size: CARDINAL] = {    delta: CARDINAL;    offset: Symbols.BitAddress;    addr.useStack ¬ TRUE;    addr.local ¬ ba.local;    [offset, size] ¬ SymbolOps.FnField[h.sym, isei];    [delta, addr.offset] ¬ IP.Normalize[offset.bd+ba.offset];    addr.base ¬ ba.base+delta+offset.wd };  CheckForHiddenPadding: PUBLIC PROC [h: Handle, f: Foo] = {    csei: IT.CSEIndex = IP.TypeForSe[h, f.tsei];    WITH h.seb[csei] SELECT FROM      array => f.addr.offset ¬ IP.Pad[h, f, LOOPHOLE[csei]];      ENDCASE };  FixupFrame: PROC [h: Handle, base: LONG POINTER] RETURNS [gf: GFHandle] = {    -- base is either a long pointer to lf or gf.    SELECT IQ.LOrGType[h, base] FROM      global => gf ¬ base; -- definitely global      ENDCASE => gf ¬ IP.GF[h, base]; -- maybe local    IQ.CheckGF[h, gf] };  MakeFoo: PUBLIC PROCEDURE [h: Handle, isei: IT.ISEIndex, ba: IT.BitAddress ¬ [NIL, 0, FALSE], sizeInc: CARDINAL ¬ 0] RETURNS [f: Foo] = {    -- this procedure is called from all over the place, to create foos from IDs, either new foos or to fields from an existing foo.    flavor: Flavor;    gf: GFHandle;    IF isei = Symbols.ISENull THEN RETURN[NIL];    f ¬ AllocFob[h];    f.hti ¬ h.seb[isei].hash;    IF h.seb[isei].idType = Symbols.typeTYPE THEN { f.typeOnly ¬ TRUE; f.tsei ¬ isei; RETURN } ELSE f.tsei ¬ h.seb[isei].idType;    SELECT (flavor ¬ Mode[h, isei]) FROM      manifest, inline, controlLink => NULL;      ENDCASE =>         IF ~ba.useStack THEN {	  IF ba.base = NIL THEN ba.base ¬ SIGNAL NotRelocated;	  IF flavor # val THEN gf ¬ FixupFrame[h, ba.base] };    SELECT flavor FROM      manifest => Constant[h, f, isei ! NoTree => { f ¬ NIL; CONTINUE }];      val => {	size: CARDINAL;	f.there ¬ TRUE;	IF ba.useStack THEN [f.addr, size] ¬ StackAddress[h, ba, isei] ELSE [f.addr, size] ¬ FrameAddress[h, ba, isei, sizeInc];	[f.words, f.bits] ¬ IP.Normalize[size];	IF f.bits + f.addr.offset > Environment.bitsPerWord THEN ERROR OffsetVariableCrossesWordBoundary;	CheckForHiddenPadding[h, f]};      refProc => {	link: PrincOpsExtras.ImportLink ¬ GetImportLink[h, gf, SymbolOps.ToCard[h.seb[isei].idValue] ! IQ.InvalidFrame, IP.NoAccessLink => { LinkError[h, gf]; GOTO nolinks }];        IF link = PrincOpsExtras.nullVariableImportLink OR link = PrincOpsExtras.nullProcImportLink THEN { MakeFooError[h, unbound, f.hti]; GOTO nolinks };	AddDesc[h, f, LOOPHOLE[link.proc]];	EXITS nolinks => RETURN[NIL] };      refVal => {        temp: CSEIndex;	link: PrincOpsExtras.ImportLink ¬ GetImportLink[h, gf, SymbolOps.ToCard[h.seb[isei].idValue] ! IQ.InvalidFrame, IP.NoAccessLink => { LinkError[h, gf]; GOTO nolinks }];	IF link = PrincOpsExtras.nullVariableImportLink OR link = PrincOpsExtras.nullProcImportLink THEN { MakeFooError[h, unbound, f.hti]; GOTO nolinks };	temp ¬ SymbolOps.UnderType[h.sym, h.seb[isei].idType];	temp ¬ SymbolOps.NormalType[h.sym, temp];	WITH h.seb[temp] SELECT FROM	  ref => f.tsei ¬ IP.TypeForSe[h, refType];	  ENDCASE => ERROR ConfusedAboutImports;	f.there ¬ TRUE;	f.addr.base ¬ link.pointer;	WITH h.seb[f.tsei] SELECT FROM	  id => [f.words, f.bits] ¬ IP.Normalize[SymbolOps.ToCard[h.seb[isei].idInfo]];	  ENDCASE => f.words ¬ CARDINAL[SymbolOps.WordsForType[h.sym, f.tsei]];	CheckForHiddenPadding[h, f];	EXITS nolinks => RETURN[NIL] };      inline => {        IF h.seb[isei].extended THEN {	  treelink: Tree.Link;	  type: Symbols.ExtensionType;	  [type, treelink] ¬ SymbolOps.FindExtension[h.sym, isei];	  SymbolOps.EnterExtension[h.sym, isei, type, TreeOps.FreeTree[h.sym, treelink]]};	IO.Line[h, " !Inline"L];	RETURN[NIL] };      controlLink => {         -- pre-declared SIGNAL or ERROR (eg UNWIND, ABORTED, ERROR)        sig: PrincOpsExtras.SignalDesc = [gf: NIL, index: SymbolOps.ToCard[h.seb[isei].idValue]];	AddDesc[h, f, LOOPHOLE[sig]]};      proc => {        dummyLink: Symbols.DummyLink = SymbolOps.ToLink[h.seb[isei].idValue];	AddDesc[h, f, IP.MakeDesc[h, gf, dummyLink.ep]]};      signal => {        dummyLink: Symbols.DummyLink = SymbolOps.ToLink[h.seb[isei].idValue];        sig: PrincOpsExtras.SignalDesc = [gf: WorldVMOps.GFshort[h.world, gf], index: dummyLink.ep];        AddDesc[h, f, LOOPHOLE[sig]]};      ENDCASE };  AllocFob: PUBLIC PROCEDURE[h: Handle] RETURNS [f: Foo] = {    t: FobTable ¬ h.fobs;    IF t = NIL THEN {      h.fobs ¬ t ¬ IO.Pages[1];       t.link ¬ NIL; t.cnt ¬ 0 }    ELSE      IF t.cnt >= MaxFobCnt THEN {        h.fobs ¬ IO.Pages[1];        h.fobs.link ¬ t;         t ¬ h.fobs; t.cnt ¬ 0 };    t.subTable[t.cnt] ¬ NullFob;    f ¬ @t.subTable[t.cnt]; t.cnt ¬ t.cnt + 1 };    StackFoo: PUBLIC PROCEDURE [h: Handle, f: Foo] = {    sp: LONG POINTER ¬ StackZeroAddress[h];    f.there ¬ TRUE;    IF f.words > PrincOps.MaxParamsInStack THEN sp ¬ WorldVMOps.Long[h.world, WorldVMOps.Read[h.world, sp]];    f.addr.base ¬ sp };    StackZeroAddress: PUBLIC PROC[h: Handle] RETURNS[WorldVMOps.Address] = { -- returns client address    state: LONG POINTER TO dst PrincOps.StateVector = WorldVMOps.GetSV[h.world];    RETURN[@state.stk[0]]};  }.
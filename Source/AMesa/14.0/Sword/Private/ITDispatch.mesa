-- Copyright (C) 1986  by Xerox Corporation. All rights reserved. -- File: ITDispatch.mesa  edit by:  DIRECTORY  Ascii USING [BS, ControlC, ControlN, ControlQ, ControlS, ControlW, CR, DEL, SP],  CommandList USING [Command],  DynamicCall USING [Exporter, Importer],  ID USING [GoOperation],  IE USING [AttachDisplay],  IM USING [Hurdle, SingleStep],  IO USING [Char, EOL, IntString, Line, Redisplay, Text, TopLevel, UserAborted],  IP USING [DisplayGFT, GF, PC],  IQ USING [AsciiDisplay, AsciiRead, AttachCondition, AttachExpression, AttachOpaque, AttachSymbols, BreakAllEntries, BreakAllXits, BreakEntry, BreakExit, CallInterpreter, ClearAllBreaks, ClearAllEntries, ClearAllTraces, ClearAllXits, ClearB, ClearC, ClearE, ClearEntryBreak, ClearEntryTrace, ClearOctal, ClearXitBreak, ClearXitTrace, DebuggingMode, DisplayB, DisplayFrame, DisplayModule, DisplayStack, FindBB, FindVar, GetDebuggee, GetFrame, Invalidate, ListBreaks, OctalBreak, OctalRead, OctalWrite, SearchMode, SetOctalContext, SetProcessContext, TraceAllEntries, TraceAllXits, TraceEntry, TraceExit, WorryMode],  IS USING [Confirm, DisplayConfig, DisplayCurrent, DisplayProcess, DisplayQueue, DisplayReadyList, EvalStack, Execute, FindModule, GetComment, GetString, GetTwoStrings, ListConfigs, ListProcesses, ModuleBreak, ResetContext, ResetParse, SetConfig, SetModule, SetRootConfig, ShowTypeWithHandle, Umbrella, WriteCommand, WriteError],  IT USING [BBHandle, Handle, LFHandle, ParseProc, PromptProc],  IV USING [SendChars],  IX USING [],  String USING [LowerCase],  WorldVMOps USING [LFlong];  ITDispatch: PROGRAM  IMPORTS DynamicCall, ID, IE, IM, IO, IP, IQ, IS, IV, String, WorldVMOps  EXPORTS IS, IX = {  OPEN IS, IQ;      CommandNotAllowed: PUBLIC SIGNAL = CODE;  SmashedContext: ERROR = CODE;    DoExp: PROC [h: IT.Handle, data: LONG UNSPECIFIED] = {    CleanUp: PROC = {      IF savefileSW # NIL THEN {        h.fileSW ¬ savefileSW; --IO.SetOutput[h, savefileSW]--}};    bb: IT.BBHandle = data;    savefileSW: LONG POINTER --Window.Handle-- ¬ NIL;    IF bb = NIL THEN RETURN;    -- Tracepoint    IF bb.bt.bt = trace THEN {       IV.SendChars[h,         SELECT bb.bt.ex FROM 	  entry => "DSP"L, 	  exit => "DSR"L, 	  ENDCASE => "DSV"L]};    IF bb.spare # NIL THEN { -- Attach Display      ENABLE UNWIND => CleanUp[];      h.stream ¬ NIL;       savefileSW ¬ h.fileSW;      h.fileSW ¬ bb.spare;      IO.IntString[h, bb.exp];      CleanUp[];      IV.SendChars[h, "p\n"L]}    ELSE -- Attach Keystrokes      IV.SendChars[h, bb.exp]};    Go: PUBLIC PROCEDURE [h: IT.Handle] = {    «IS.ResetContext[h];»    Prompt[h, TRUE, TRUE];    WITH sd: h.swapData SELECT FROM      breakpoint => {        lf: IT.LFHandle ¬ WorldVMOps.LFlong[h.world, h.swapData.lFrame];        h.bbh ¬ IQ.FindBB[h, IP.GF[h, lf], IP.PC[h, lf]];        IS.Umbrella[h, h.bbh, DoExp]};      ENDCASE};        DispatchChar: PUBLIC IT.ParseProc = {    ENABLE IO.UserAborted => GOTO userAborted;    IF c = Ascii.BS OR c = Ascii.ControlW OR c = Ascii.ControlQ  THEN { Prompt[h]; RETURN };    SELECT (c ¬ String.LowerCase[c]) FROM      'a =>	SELECT h.prefix FROM	  cl => { h.prefix ¬ cla; WriteCommand[h, all]; IO.Char[h, ' ]; };	  b => { h.prefix ¬ ba; WriteCommand[h, all]; IO.Char[h, ' ]; };	  t => { h.prefix ¬ ta; WriteCommand[h, all]; IO.Char[h, ' ]; };	  top => { h.prefix ¬ a; WriteCommand[h, a]; };	  ENDCASE => GOTO what;      'b =>	SELECT h.prefix FROM	  d => GetString[h, [sId: bbNum, prompt: bbNum], IQ.DisplayB, break];	  l => Execute[h, breaks, IQ.ListBreaks];	  cl => GetString[h, [sId: bbNum, prompt: bbNum], IQ.ClearB, break];	  cla => Execute[h, breaks, IQ.ClearAllBreaks];	  cle => GetString[h, [sId: proc], IQ.ClearEntryBreak, breakProc];	  clx => GetString[h, [sId: proc], IQ.ClearXitBreak, breakProc];	  top => { h.prefix ¬ b; WriteCommand[h, break]; IO.Char[h, Ascii.SP] };	  ENDCASE => GOTO what;      'c =>	SELECT h.prefix FROM	  at => GetTwoStrings[h, [sId: bbNum, prompt: bbNum], [sId: exp, prompt: condition, atom: FALSE], IQ.AttachCondition, Condition];	  cl => GetString[h, [sId: bbNum, prompt: bbNum], IQ.ClearC, Condition];	  d => Execute[h, config, IS.DisplayConfig];	  l => Execute[h, configs, IS.ListConfigs];	  o => GetTwoStrings[h, [sId: frame], [prompt: bytePC, sId: pc], IQ.ClearOctal, clearGlobal];	  se => GetString[h, [sId: config], IS.SetConfig, config];	  top => { h.prefix ¬ c; WriteCommand[h, c]; };	  ENDCASE => GOTO what;      'd =>	SELECT h.prefix FROM	  as => GetTwoStrings[h, [sId: num1], [sId: num2, prompt: n10], AsciiDisplay, display];	  at => GetTwoStrings[h, [sId: bbNum, prompt: bbNum], [sId: exp, prompt: expression, atom: FALSE], IE.AttachDisplay, display];	  re => Execute[h, redisplay, IO.Redisplay];	  top => {WriteCommand[h, display]; IO.Char[h, Ascii.SP]; h.prefix ¬ d};	  ENDCASE => GOTO what;      'e =>	SELECT h.prefix FROM	  d => Execute[h, evalStack, IS.EvalStack];	  s => { WriteCommand[h, set]; IO.Char[h, Ascii.SP]; h.prefix ¬ se };	  b => GetString[h, [sId: proc], IQ.BreakEntry, entryProc];	  ba => ModuleBreak[h, IQ.BreakAllEntries, entriesMod];	  t => GetString[h, [sId: proc], IQ.TraceEntry, entryProc];	  ta => ModuleBreak[h, IQ.TraceAllEntries, entriesMod];	  cl => { WriteCommand[h, entry]; IO.Char[h, Ascii.SP]; h.prefix ¬ cle };	  cla => GetString[h, [sId: module], IQ.ClearAllEntries, entriesMod];	  f => GetString[h, [sId: spare1], DynamicCall.Exporter, spare6];	  ENDCASE => GOTO what;      'f =>	SELECT h.prefix FROM	  d => GetString[h, [sId: frame], DisplayFrame, frame];	  top => {WriteCommand[h, find]; IO.Char[h, Ascii.SP]; h.prefix ¬ f};	  ENDCASE => GOTO what;      'g =>	SELECT h.prefix FROM	  d => Execute[h, gft, IP.DisplayGFT];	  ENDCASE => GOTO what;      'h =>	SELECT h.prefix FROM	  top => Execute[h, spare3, IM.Hurdle];	  s => GetString[h, [sId: var], ShowTypeWithHandle, showType];	  ENDCASE => GOTO what;      'i =>	SELECT h.prefix FROM	  f => GetString[h, [sId: spare1], DynamicCall.Importer, spare7];	  ENDCASE => GOTO what;      'k =>	SELECT h.prefix FROM	  at => GetTwoStrings[h, [sId: bbNum, prompt: bbNum], [sId: exp, prompt: expression, atom: FALSE], IQ.AttachExpression, Exp];	  cl => GetString[h, [sId: bbNum, prompt: bbNum], IQ.ClearE, Exp];	  top => Confirm[h, kill, GoKill];	  ENDCASE => GOTO what;      'l =>	SELECT h.prefix FROM	  c => { h.prefix ¬ cl; WriteCommand[h, clear]; IO.Char[h, Ascii.SP]; };	  top => { h.prefix ¬ l; WriteCommand[h, list]; IO.Char[h, Ascii.SP] };	  ENDCASE => GOTO what;      'm =>	SELECT h.prefix FROM	  d => GetString[h, [sId: module], DisplayModule, module];	  se => GetString[h, [sId: module], IS.SetModule, moduleCtx];	  re => GetString[h, [sId: client, atom: FALSE], GetDebuggee, remote];	  f => GetString[h, [sId: module], IS.FindModule, module];	  ENDCASE => GOTO what;      'n =>        SELECT h.prefix FROM	  top => Execute[h, spare2, IM.SingleStep];	  ENDCASE => GOTO what;      'o =>	SELECT h.prefix FROM	  at => GetTwoStrings[h, [prompt: spare1, sId: frame], [prompt: name, sId:file], IQ.AttachOpaque];	  se => GetString[h, [sId: frame], SetOctalContext, octalCtx];	  top => {h.prefix ¬ o; WriteCommand[h, octal]; IO.Char[h, Ascii.SP]};	  ENDCASE => GOTO what;      'p =>	SELECT h.prefix FROM	  d => GetString[h, [sId: process], IS.DisplayProcess, process];	  l => Execute[h, processes, IS.ListProcesses];	  se => GetString[h, [sId: process], SetProcessContext, processCtx];	  top => Confirm[h, proceed, GoProceed];	  ENDCASE => GOTO what;      'q =>	SELECT h.prefix FROM	  d => GetString[h, [sId: queue], IS.DisplayQueue, queue];	  top => Confirm[h, quit, GoQuit];	  ENDCASE => GOTO what;      'r =>	SELECT h.prefix FROM	  as => GetTwoStrings[h, [sId: num1], [sId: num2, prompt: n10], AsciiRead, read];	  d => Execute[h, readyList, IS.DisplayReadyList];	  o => GetTwoStrings[h, [sId: num1], [prompt: n10, sId: num2], OctalRead, read];	  se => GetString[h, [sId: rconfig], IS.SetRootConfig, rootCtx];	  top => {h.prefix ¬ re; WriteCommand[h, re]};	  ENDCASE => GOTO what;      's =>	SELECT h.prefix FROM	  d => Execute[h, stack, DisplayStack];	  o => GetTwoStrings[h, [sId: frame], [sId: pc, prompt: bytePC], IQ.OctalBreak, breakGlobal];	  a => { h.prefix ¬ as; WriteCommand[h, ascii]; IO.Char[h, Ascii.SP] };	  at => GetTwoStrings[h, [prompt: symbols, sId: frame], [sId:file, prompt: name], IQ.AttachSymbols];	  re => Execute[h, reset, IS.ResetContext];	  top => { h.prefix ¬ s; WriteCommand[h, s]; };	  ENDCASE => GOTO what;      't =>	SELECT h.prefix FROM	  top => { h.prefix ¬ t; WriteCommand[h, trace]; IO.Char[h, Ascii.SP] };	  cla => Execute[h, traces, IQ.ClearAllTraces];	  cle => GetString[h, [sId: proc], IQ.ClearEntryTrace, traceProc];	  clx => GetString[h, [sId: proc], IQ.ClearXitTrace, traceProc];	  s => GetString[h, [sId: frame], GetFrame, start];	  a => { h.prefix ¬ at; WriteCommand[h, attach]; IO.Char[h, Ascii.SP] };	  ENDCASE => GOTO what;      'u =>	SELECT h.prefix FROM	  c => Execute[h, current, IS.DisplayCurrent];	  top => Confirm[h, userscreen, GoUserScreen];	  ENDCASE => GOTO what;      'v =>	SELECT h.prefix FROM	  f => GetString[h, [sId: var], FindVar, Variable];	  ENDCASE => GOTO what;      'w =>	SELECT h.prefix FROM	  o => GetTwoStrings[h, [sId: num1], [prompt: gets, sId: num2, colon: FALSE], OctalWrite, write];	  top => { WriteCommand[h, worry]; Confirm[h, IF h.worryBreaks THEN off ELSE on, WorryMode] };	  ENDCASE => GOTO what;      'x =>	SELECT h.prefix FROM	  b => GetString[h, [sId: proc], IQ.BreakExit, xitProc];	  ba => ModuleBreak[h, IQ.BreakAllXits, xitsMod];	  t => GetString[h, [sId: proc], IQ.TraceExit, xitProc];	  ta => ModuleBreak[h, IQ.TraceAllXits, xitsMod];	  cl => { h.prefix ¬ clx; WriteCommand[h, xit]; IO.Char[h, Ascii.SP]; };	  cla => GetString[h, [sId:module], IQ.ClearAllXits, xitsMod];	  ENDCASE => GOTO what;      ENDCASE =>	SELECT TRUE FROM	  h.prefix = top =>	    SELECT c FROM	      Ascii.ControlC => { WriteCommand[h, check]; Confirm[h, IF h.debugging THEN off ELSE on, DebuggingMode] };	      Ascii.ControlN => Confirm[h, invalidate, Invalidate];	      Ascii.ControlS => { WriteCommand[h, IF h.search THEN callStack ELSE oneFrame]; Confirm[h, null, SearchMode] };	      Ascii.SP => CallInterpreter[h];	      '- => GetComment[h];	      '? => UnknownCommand[h, firstCommand, worry];	      Ascii.CR => Prompt[h];	      ENDCASE => GOTO what;	  c = '? =>	    SELECT h.prefix FROM	      a => UnknownCommand[h, ascii, attach];	      as => UnknownCommand[h, adisplay, read];	      at => UnknownCommand[h, Condition, Symbols];	      b, t => UnknownCommand[h, all, xitProc];	      ba, ta => UnknownCommand[h, entriesMod, xitsMod];	      c => UnknownCommand[h, clear, current];	      cl => UnknownCommand[h, clearAll, xit];	      cla => UnknownCommand[h, clearAllBreaks, xitsMod];	      cle, clx => UnknownCommand[h, breakProc, traceProc];	      f => UnknownCommand[h, spare4, spare7];	      l => UnknownCommand[h, breaks, processes];	      d => UnknownCommand[h, displayBreak, stack];	      o => UnknownCommand[h, clearGlobal, write];	      re => UnknownCommand[h, redisplay, reset];	      s => UnknownCommand[h, set, start];	      se => UnknownCommand[h, config, rootCtx];	      ENDCASE => UnknownCommand[h, clear, current];	  ENDCASE => GOTO what;    EXITS       what => UnknownChar[h, c];      userAborted => { IS.WriteError[h, aborted]; Prompt[h, TRUE, TRUE] }};      UnknownCommand: PROCEDURE [h: IT.Handle, first, last: CommandList.Command] = {    IO.Line[h, " ?"L];    IO.Text["Your options are: "L, h];    FOR i: CommandList.Command IN [first..last) DO       IS.WriteCommand[h, i];      IO.Text[", "L, h];      ENDLOOP;    IS.WriteCommand[h, last];    IO.EOL[h];    Prompt[h] };      UnknownChar: PROCEDURE [h: IT.Handle, char: CHARACTER] = {    IF char = Ascii.DEL THEN IS.WriteError[h, XXX];    -- ELSE { IO.Char[h, char]; IO.Char[h, '?] };    Prompt[h] };      PromptProc: PROCEDURE[h: IT.Handle] = {    IO.EOL[h];    THROUGH [1..h.level] DO IO.Char[h, '>] ENDLOOP;    h.prefix ¬ top};    Prompt: PUBLIC PROCEDURE[h: IT.Handle, resetPrompt, resetParse: BOOLEAN ¬ FALSE] = {    -- Back to top level parse, prompt, and context if desired.    IF resetPrompt THEN ResetPrompt[h];    h.prompt[h];    IF resetParse THEN IS.ResetParse[h];    IO.TopLevel[h] }; -- Frees leftover trash.      SetPrompt: PUBLIC PROC[h: IT.Handle, proc: IT.PromptProc] = {    h.prompt ¬ proc;    h.prevPrompt ¬ h.prevPrevPrompt ¬ NIL};      ResetPrompt: PUBLIC PROC[h: IT.Handle] = { SetPrompt[h, PromptProc] };      GoProceed: PROC[h: IT.Handle] = {ID.GoOperation[h, proceed, TRUE]};  GoQuit: PROC[h: IT.Handle] = {ID.GoOperation[h, abort, TRUE]};  GoKill: PROC[h: IT.Handle] = {ID.GoOperation[h, kill, TRUE]};  GoUserScreen: PROC[h: IT.Handle] = {ID.GoOperation[h, screen, TRUE]};      }.
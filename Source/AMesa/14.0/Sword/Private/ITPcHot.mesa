-- File: ITPcHot.mesa - last edit:-- Litman              27-Apr-87 21:27:29-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.DIRECTORY  AMLoadstate USING [GFHandle, Handle, MapRealToEnh],  BcdOps USING [ENHandle],  Copier USING [Handle, Outer],  IO USING [Pages],  IP USING [CacheCBtiCold, CodeBase, ConvertCbti, EpCold, FindUserCbti, GF, ParentCbtiCold, PC, ResetPCache],  IQ USING [GFrameMdi, InvalidFrame],  IT USING [BTIndex, BytePC, CBTIndex, EVIndex, GFHandle, Handle, LFHandle, MDIndex, NILGF, nullPC, PcItem, PcItemNull],  Mopcodes USING [zBRK, zRET],  Symbols USING [BTNull, CBTNull, MDNull],  SymbolTable USING [Handle, Missing, NullHandle],  WorldVMOps USING [BytePC, GetLoadstate, GFshort, ReadCodeByte];ITPcHot: PROGRAM  IMPORTS AMLoadstate, Copier, IO, IP, IQ, SymbolTable, WorldVMOps  EXPORTS IP = {    NoBti: ERROR = CODE;  BadReason: ERROR = CODE;  AnyGf: IT.GFHandle = NIL;  Enumerate: PROCEDURE [h: IT.Handle, eproc: PROCEDURE [IT.PcItem] RETURNS [BOOLEAN], gf: IT.GFHandle] RETURNS [i: IT.PcItem] = {    penult, last: IT.PcItem ¬ IT.PcItemNull;    IF h.pcCache = NIL THEN { h.pcCache ¬ IO.Pages[1]; IP.ResetPCache[h] };    FOR i ¬ h.headPcItem, h.pcCache[i].link UNTIL i = IT.PcItemNull DO      IF (gf = h.pcCache[i].gf OR gf = AnyGf) AND eproc[i] THEN {	IF i # h.headPcItem THEN { -- sort	  h.pcCache[last].link ¬ h.pcCache[i].link; 	  h.pcCache[i].link ¬ h.headPcItem;	  h.headPcItem ¬ i };        RETURN[i] };      penult ¬ last;      last ¬ i;      REPEAT FINISHED =>         IF h.freePcItem = IT.PcItemNull THEN { -- make space	  h.pcCache[penult].link ¬ IT.PcItemNull;	  h.pcCache[last].link ¬ IT.PcItemNull;	  h.freePcItem ¬ last };      ENDLOOP };    FindUserCbti: PUBLIC PROCEDURE [h: IT.Handle, gf: IT.GFHandle, cbti: IT.CBTIndex] RETURNS [IT.PcItem] = {    Find: PROCEDURE [i: IT.PcItem] RETURNS [BOOLEAN] = {      RETURN[cbti = h.pcCache[i].userCbti]};    RETURN[Enumerate[h, Find, gf]]};  FindCbti: PUBLIC PROCEDURE [h: IT.Handle, cbti: IT.CBTIndex] RETURNS [i: IT.PcItem] = {    Find: PROCEDURE [i: IT.PcItem] RETURNS [BOOLEAN] = {      RETURN[cbti = h.pcCache[i].dCbti]};    RETURN[Enumerate[h, Find, AnyGf]]};    FindPC: PUBLIC PROCEDURE [h: IT.Handle, pc: IT.BytePC, gf: IT.GFHandle] RETURNS [IT.PcItem] = {    Find: PROCEDURE [i: IT.PcItem] RETURNS [BOOLEAN] = {      RETURN[(pc >= h.pcCache[i].start) AND (pc <= h.pcCache[i].end)]};    RETURN[Enumerate[h, Find, gf]]};  EvToPc: PROCEDURE [h: IT.Handle, gf: IT.GFHandle, ev: IT.EVIndex] RETURNS [CARDINAL] = {    enh: BcdOps.ENHandle = AMLoadstate.MapRealToEnh[WorldVMOps.GetLoadstate[h.world], WorldVMOps.GFshort[h.world, gf]];    RETURN[enh.initialPC[ev]]};  EntryPC: PUBLIC PROCEDURE [h: IT.Handle, gf: IT.GFHandle, i: IT.EVIndex] RETURNS [pc: IT.BytePC] = {    RETURN[EvToPc[h, gf, i] + 1] }; -- skip fsi byte  GetPc: PUBLIC PROCEDURE [h: IT.Handle, gf: IT.GFHandle, i: IT.EVIndex] RETURNS [pc: IT.BytePC] = {    RETURN[EvToPc[h, gf, i]] };   CbtSon: PUBLIC PROCEDURE [h: IT.Handle, cbti: IT.CBTIndex] RETURNS [BOOLEAN] = {    i: IT.PcItem ¬ FindCbti[h, cbti];    IF i = IT.PcItemNull THEN ERROR NoBti;    RETURN [h.pcCache[i].hasSons]};  Ep: PUBLIC PROCEDURE [h: IT.Handle, pc: IT.BytePC, gf: IT.GFHandle] RETURNS [ep: IT.EVIndex, start: IT.BytePC] = {    old: IT.PcItem ¬ FindPC[h, pc, gf];    IF old # IT.PcItemNull THEN {      ep ¬ h.pcCache[old].ep;       start ¬ h.pcCache[old].start }    ELSE [ep, start] ¬ IP.EpCold[h, pc, gf]};  CacheCBti: PUBLIC PROCEDURE [h: IT.Handle, mdi: IT.MDIndex, gf: IT.GFHandle, cbti: IT.CBTIndex] RETURNS [IT.CBTIndex] = {    i: IT.PcItem = IP.FindUserCbti[h, gf, cbti];    IF i # IT.PcItemNull THEN RETURN[h.pcCache[i].dCbti];    RETURN[IP.CacheCBtiCold[h, mdi, gf, cbti]]};  Fixup: PROCEDURE [h: IT.Handle, pc: IT.BytePC, gf: IT.GFHandle] RETURNS [IT.BytePC, IT.GFHandle] = {    IF gf = NIL THEN gf ¬ h.gContext;    IF pc = IT.nullPC THEN pc ¬ GetPc[h, gf, 0];    RETURN[pc, gf] };  ParentCbti: PUBLIC PROCEDURE [h: IT.Handle, pc: IT.BytePC, gf: IT.GFHandle] RETURNS [old: IT.PcItem, mdi: IT.MDIndex] = {    old ¬ FindPC[h, pc, gf];    mdi ¬ IQ.GFrameMdi[h, gf ! SymbolTable.Missing, IQ.InvalidFrame => GOTO noSyms];    IF old = IT.PcItemNull THEN old ¬ IP.ParentCbtiCold[h, pc, gf, mdi];    EXITS noSyms => mdi ¬ Symbols.MDNull };  Bti: PUBLIC PROCEDURE [h: IT.Handle, pc: IT.BytePC, gf: IT.GFHandle] RETURNS [bti: IT.BTIndex] = {    mdi: IT.MDIndex;    i: IT.PcItem;    ClosestBti: PROCEDURE [base: SymbolTable.Handle] = {      bti ¬ IP.ConvertCbti[h, bti, pc, h.pcCache[i].start, base]};    [pc, gf] ¬ Fixup[h, pc, gf];    [i, mdi] ¬ ParentCbti[h, pc, gf];    IF mdi = Symbols.MDNull OR i = IT.PcItemNull THEN RETURN[Symbols.BTNull];    IF (bti ¬ h.pcCache[i].userCbti) = Symbols.BTNull THEN RETURN;    IF ~h.pcCache[i].hasSons THEN RETURN;    Copier.Outer[h.sym, mdi, ClosestBti] };  CBti: PUBLIC PROCEDURE [h: IT.Handle, pc: IT.BytePC, gf: IT.GFHandle] RETURNS [cbti: IT.CBTIndex] = {    i: IT.PcItem;    [pc, gf] ¬ Fixup[h, pc, gf];    IF (i ¬ ParentCbti[h, pc, gf].old) = IT.PcItemNull THEN RETURN[Symbols.CBTNull];    RETURN[h.pcCache[i].dCbti]};  ExitPC: PUBLIC PROCEDURE [h: IT.Handle, cbti: IT.CBTIndex] RETURNS [IT.BytePC] = {    i: IT.PcItem = FindCbti[h, cbti];    IF i # IT.PcItemNull THEN RETURN[h.pcCache[i].end]     ELSE ERROR SymbolTable.Missing[SymbolTable.NullHandle]};  CbtiItem: PROCEDURE [h: IT.Handle, f: IT.LFHandle, pc: IT.BytePC] RETURNS [IT.PcItem, IT.BytePC] = {    SELECT TRUE FROM      f = NIL => { f ¬ h.lContext; pc ¬ IP.PC[h, f] };      pc = IT.nullPC => pc ¬ IP.PC[h, f];      ENDCASE;    RETURN[FindCbti[h, CBti[h, pc, IP.GF[h, f]]], pc] };  Entry: PUBLIC PROCEDURE [h: IT.Handle, f: IT.LFHandle, pc: IT.BytePC] RETURNS [BOOLEAN] = {    i: IT.PcItem;    [i, pc] ¬ CbtiItem[h, f, pc];    IF i = IT.PcItemNull THEN ERROR SymbolTable.Missing[SymbolTable.NullHandle];    RETURN[IT.BytePC[h.pcCache[i].start + 1] = pc] }; -- fsi  Exit: PUBLIC PROCEDURE [h: IT.Handle, f: IT.LFHandle, pc: IT.BytePC] RETURNS [BOOLEAN] = {    i: IT.PcItem;    [i, pc] ¬ CbtiItem[h, f, pc];    IF i = IT.PcItemNull THEN ERROR SymbolTable.Missing[SymbolTable.NullHandle];    IF h.pcCache[i].end # pc THEN RETURN[FALSE];    SELECT WorldVMOps.ReadCodeByte[h.world, IP.CodeBase[h, IP.GF[h,f]], pc] FROM      Mopcodes.zRET => RETURN[TRUE];      Mopcodes.zBRK => RETURN[TRUE];         «{        sp: WorldVMOps.Address = WorldVMOps.GetSV[h.world];	state: PrincOps.StateVector.dst;	IF sp = NIL THEN RETURN[TRUE]; 	WorldVMOps.CopyRead[world: h.world, from: sp, to: @state, nwords: SIZE[PrincOps.StateVector.dst]];        RETURN[state.instbyte = Mopcodes.zRET]};»      ENDCASE => RETURN[FALSE] };  }.
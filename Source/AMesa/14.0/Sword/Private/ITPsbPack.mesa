-- File: ITPsbPack.mesa - last edit:-- Litman              21-Apr-87 20:31:36-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.DIRECTORY  AMLoadstate USING [Error],  Ascii USING [BS, ControlQ, ControlW, CR, DEL, SP],  ComData USING [typeCONDITION, typeLOCK],  CPSwapDefs USING [FaultProcessingStage, FaultQueueItem, FaultQueuePtr, FaultType, ProcessState],  Inline USING [LongCOPYReverse],  IO USING [Char, Decimal, EOL, FreePages, Interpret, InvalidNumber, Line, options, Pages, StringExpToLOctal, Text, UserAbort, UserAborted],  IP USING [Clobbered, DisplaySource, GetNumber, GetValue, GF, Name, NoAccessLink, NoPrevious, PC, Previous, TypeForSe],  IQ USING [CallInterpreter, DisplayF, InvalidFrame],  IS USING [ResetParse, GetComment, LongNum, Num, Prompt, SetParse, Umbrella, WriteError],  IT USING [PromptProc, FooProc, Handle, LFHandle, MaxModuleString, NullProcess, Number, ParseProc, Process, ProcessStateBlock, PsbCache, PsbItemObject, PsbItem, MaxPsbCnt, StackType],  ITajo USING [ExecMatchPattern],  IX,  IY USING [ShowLongNum],  PrincOps USING [StateVector],  Process USING [GetCurrent],  ProcessOperations USING [IndexFromProcess, IndexToHandle],  PSB USING [FaultIndex, NullStateVectorHandle, PDA, Priority, ProcessStateBlock, PsbLink, qFrameFault, qPageFault, Queue, qWriteProtectFault, StartPsb, StateVectorHandle],  String USING [Empty, UpperCase],  SymbolTable USING [Missing],  WorldVM USING [LocalWorld],  WorldVMOps USING [Address, AddressFault, CopyRead, GetESV, GetSV, LFlong, Long, NullProcess, Process, ProcessLong, ProcessShort, Read];  ITPsbPack: PROGRAM   IMPORTS AMLoadstate, com: ComData, IO, IP, IQ, IS, ITajo, IX, IY, Inline, Process, ProcessOperations, String, SymbolTable, WorldVM, WorldVMOps  EXPORTS IP, IS = {    ProcessStateBlock: --PUBLIC-- TYPE = PSB.ProcessStateBlock;  PsbPointer: TYPE = LONG POINTER TO ProcessStateBlock;  -- cant export ProcessStateBlock because it has defaulted fields  Hack: PROC[psb: LONG POINTER TO IT.ProcessStateBlock] RETURNS[PsbPointer] = INLINE { RETURN[LOOPHOLE[psb]] };  first: IT.Process = WorldVMOps.ProcessLong[PSB.StartPsb];  Invalid: PUBLIC SIGNAL [psb: IT.Process] = CODE;  NotAnXfer: ERROR = CODE;      ReadPsb: PUBLIC PROC [h: IT.Handle, p: IT.Process] RETURNS [l: IT.PsbItem] = {    Check[h, p];    RETURN[Cache[h, p]]};          Cache: PROC [h: IT.Handle, p: IT.Process] RETURNS [item: IT.PsbItem] = {    top, bottom, i: CARDINAL;    t: IT.PsbCache;    FOR t ¬ h.psbCache, t.link UNTIL t = NIL DO      IF (top ¬ t.cnt) # 0 AND p > t.subCache[top-1].p THEN LOOP; -- accelerator      bottom ¬ 0;      WHILE bottom < top DO	med: CARDINAL = (top+bottom)/2;	SELECT t.subCache[med].p FROM	  < p => bottom ¬ med+1;	  > p => top ¬ med;	  ENDCASE => RETURN[@t.subCache[med]];	ENDLOOP;      ENDLOOP;    IF h.psbCache = NIL OR h.psbCache.cnt = IT.MaxPsbCnt THEN { t ¬ IO.Pages[1]; t.link ¬ h.psbCache; t.cnt ¬ 0; h.psbCache ¬ t } ELSE t ¬ h.psbCache;    FOR i DECREASING IN [1..t.cnt] DO      IF t.subCache[i-1].p < p THEN EXIT;      REPEAT FINISHED => i ¬ 0;      ENDLOOP;    Inline.LongCOPYReverse[from: @t.subCache[i], to: @t.subCache[i+1], nwords: (t.cnt-i)*SIZE[IT.PsbItemObject]];    item ¬ @t.subCache[i];    item.p ¬ p;    WorldVMOps.CopyRead[world: h.world, from: @PSB.PDA[ProcessOperations.IndexToHandle[WorldVMOps.ProcessShort[p]]], to: @item.psb, nwords: SIZE[ProcessStateBlock]];    t.cnt ¬ t.cnt + 1 };    ResetCache: PUBLIC PROC[h: IT.Handle] = {    IF h.psbCache # NIL THEN {      next: IT.PsbCache;      FOR t: IT.PsbCache ¬ h.psbCache.link, next UNTIL t = NIL DO	next ¬ t.link; 	IO.FreePages[t];	ENDLOOP;      h.psbCache.cnt ¬ 0; h.psbCache.link ¬ NIL};    h.lastPSB ¬ IT.NullProcess };      NextPsb: PUBLIC PROC [h: IT.Handle, p: IT.Process] RETURNS [item: IT.PsbItem] = {    DO      IF p = h.lastPSB OR p = IT.NullProcess THEN p ¬ first ELSE p ¬ p + 1;      item ¬ ReadPsb[h, p];      IF StateOK[h, item] THEN RETURN;      ENDLOOP };      Check: PROC [h: IT.Handle, p: IT.Process] = {    IF h.lastPSB = IT.NullProcess THEN h.lastPSB ¬ (first + WorldVMOps.Read[h.world, @PSB.PDA.count]-1);    IF p < first OR p > h.lastPSB THEN SIGNAL Invalid[p] };      Priority: PROC [p: PsbPointer] RETURNS [PSB.Priority] = INLINE {    RETURN[p.link.priority]};      WaitingCV: PROC [p: PsbPointer] RETURNS [BOOLEAN] = INLINE {    RETURN[p.flags.waiting]};      WaitingML: PROC [p: PsbPointer] RETURNS [BOOLEAN] = INLINE {    RETURN[p.link.failed]};    «StateOK: PROC [h: IT.Handle, item: IT.PsbItem] RETURNS [BOOLEAN] = INLINE {    RETURN[LOOPHOLE[Hack[@item.psb].flags.available, CPSwapDefs.ProcessState].state # dead]};»      StateOK: PROC [h: IT.Handle, item: IT.PsbItem] RETURNS [BOOLEAN] = INLINE {    RETURN[FlagState[Hack[@item.psb]].state # dead]};      FlagState: PROC [psb: PsbPointer] RETURNS [CPSwapDefs.ProcessState] = INLINE {    RETURN[LOOPHOLE[psb.flags.available]]};      «Running: PROC [h: IT.Handle, pi: IT.PsbItem] RETURNS [BOOLEAN] = {    p: PsbPointer = Hack[@pi.psb];    RETURN[      ~WaitingML[p]       AND ~WaitingCV[p]       AND FlagState[p].state = alive      AND HasStateVector[h, p.link.priority]       AND OnReadyList[h, pi]]};»      «WaitingState: PROC [h: IT.Handle, pi: IT.PsbItem] RETURNS [BOOLEAN] = {    p: PsbPointer = Hack[@pi.psb];    RETURN[      ~WaitingML[p]       AND ~WaitingCV[p]       AND FlagState[p].state = alive      AND ~(p.link.permanent OR p.link.preempted OR HasStateVector[h, p.link.priority])       AND OnReadyList[h, pi]]};»      HasStateVector: PROC [h: IT.Handle, p: PSB.Priority] RETURNS [BOOLEAN] = {    RETURN[WorldVMOps.Read[h.world, @PSB.PDA.state[p]] # PSB.NullStateVectorHandle]};      Frame: PUBLIC PROC [h: IT.Handle, psb: IT.PsbItem] RETURNS [IT.LFHandle] = {    pp: PsbPointer = Hack[@psb.psb];    IF psb.p = WorldVMOps.ProcessLong[h.swapData.process] THEN RETURN[WorldVMOps.LFlong[h.world, h.swapData.lFrame]];    IF psb.p = WorldVMOps.ProcessLong[ProcessOperations.IndexFromProcess[Process.GetCurrent[]]] AND h.world = WorldVM.LocalWorld[] THEN RETURN[NIL];     RETURN[WorldVMOps.LFlong[h.world, IF ~(pp.link.permanent OR pp.link.preempted) THEN pp.context.frame ELSE WorldVMOps.Read[h.world, @PSB.PDA[pp.context.state].frame]]] };      FaultAddr: PUBLIC PROC [h: IT.Handle, p: IT.Process] RETURNS [memPointer: LONG POINTER] = {     pp: PsbPointer = Hack[@ReadPsb[h, p].psb];    IF ~(pp.link.permanent OR pp.link.preempted) THEN RETURN[NIL];    WorldVMOps.CopyRead[world: h.world, from: @PSB.PDA[pp.context.state].faultData, to: @memPointer, nwords: SIZE[LONG POINTER]]};      ListProcesses: PUBLIC PROC[h: IT.Handle] = {    FOR i: IT.PsbItem ¬ NextPsb[h, h.lastPSB], NextPsb[h, i.p] DO      ENABLE IO.UserAborted, ABORTED => { IS.WriteError[h, aborted, FALSE]; EXIT; };      DumpPSB[h, i];       IO.EOL[h];      IF i.p = h.lastPSB THEN EXIT;      ENDLOOP };        FindModule: PUBLIC PROC [h: IT.Handle, moduleName: LONG STRING] = {    ENABLE IO.UserAborted, ABORTED => GOTO Aborted;    found, foundInThisProcess: BOOLEAN ¬ FALSE;    lf: IT.LFHandle;    gfName: LONG STRING ¬ [IT.MaxModuleString];    IO.EOL[h];    IF String.Empty[moduleName] THEN {IO.Text["No module name!"L, h]; RETURN};    FOR i: IT.PsbItem ¬ NextPsb[h, h.lastPSB], NextPsb[h, i.p] DO      lf ¬ Frame[h, i];      foundInThisProcess ¬ FALSE;      FOR j: CARDINAL ¬ 0, j+1 DO	ENABLE {	  WorldVMOps.AddressFault, 	  IP.NoAccessLink, 	  IP.Clobbered, 	  Invalid, 	  IQ.InvalidFrame => GOTO NextProcess;	  ABORTED => GOTO Aborted}; 	IF IO.UserAbort[h] THEN GOTO Aborted;	gfName.length ¬ 0;	IP.Name[h, gfName, IP.GF[h, lf]];	  -- get global frame name for current procedure	IF ITajo.ExecMatchPattern[gfName, moduleName] THEN {	  found ¬ TRUE;	  IO.EOL[h];	  IF NOT foundInThisProcess THEN {	    -- write stuff that can be stuffed to get to the desired context.	    IO.Text["SEP"L, h]; IY.ShowLongNum[h, i.p, IO.options.lpRadix, FALSE]; IO.EOL[h];	    foundInThisProcess ¬ TRUE};	    IO.Text["DSJ"L, h]; IO.Decimal[h, j]};	lf ¬ IP.Previous[h, lf ! IP.NoPrevious => GOTO NextProcess];	REPEAT NextProcess => NULL;	ENDLOOP;      IF i.p = h.lastPSB THEN EXIT;      ENDLOOP;    IF ~found THEN {IO.Text[moduleName, h]; IS.WriteError[h, notFound, FALSE]};    EXITS Aborted => IS.WriteError[h, aborted, FALSE]};    Caret: PROC[h: IT.Handle] = {IO.EOL[h]; IO.Text["  >"L, h]};    DumpStack: PROC [h: IT.Handle, psb: IT.Process, stacktype: IT.StackType] = {     h.headPSB ¬ h.currentPSB ¬ psb;    h.dumping ¬ stacktype;    IS.SetParse[h, StackCommands];    IX.SetPrompt[h, Caret] };      LongChar: TYPE = RECORD[u: UNSPECIFIED, pad, char: CHARACTER];     StackCommands: IT.ParseProc = {    ENABLE {      NoPrompt => CONTINUE;      IO.UserAborted => {IS.Prompt[h]; CONTINUE}};    lc: LONG UNSPECIFIED;    LOOPHOLE[lc, LongChar].char ¬ c;    IS.Umbrella[h, lc, UProcess];    IS.Prompt[h]};      NoPrompt: ERROR = CODE;  UProcess: PROC [h: IT.Handle, lc: LONG UNSPECIFIED] = {    char: CHARACTER = LOOPHOLE[lc, LongChar].char;    SELECT char FROM      Ascii.SP, Ascii.DEL, Ascii.BS, Ascii.ControlW, Ascii.ControlQ => NULL;      ENDCASE => IO.Char[h, char];    SELECT String.UpperCase[char] FROM      'N  => {	IF h.dumping = process THEN h.currentPSB ¬ NextPsb[h, h.currentPSB].p	ELSE {          link: PSB.PsbLink = WorldVMOps.Read[h.world, @PSB.PDA[ProcessOperations.IndexToHandle[WorldVMOps.ProcessShort[h.currentPSB]]].link];          h.currentPSB ¬ WorldVMOps.ProcessLong[link.next] };	IF h.currentPSB = h.headPSB OR h.currentPSB = IT.NullProcess 	THEN { IS.Prompt[h: h, resetParse: TRUE, resetPrompt: TRUE]; ERROR NoPrompt }	ELSE DumpPSB[h, ReadPsb[h, h.currentPSB]] };      'P  => DumpPriority[h, h.currentPSB];      'Q, Ascii.DEL => { IS.Prompt[h: h, resetParse: TRUE, resetPrompt: TRUE]; ERROR NoPrompt };      'R  => DumpRoot[h, h.currentPSB];      'L  => IF h.dumping = process THEN DumpSource[h, h.currentPSB, FALSE] ELSE BadChar[h];      'S  => IF h.dumping = process THEN DumpSource[h, h.currentPSB, TRUE] ELSE BadChar[h];      Ascii.SP => { IQ.CallInterpreter[h]; ERROR NoPrompt };      '- => { IS.GetComment[h]; ERROR NoPrompt };      '? => IF h.dumping = process THEN Error[h, processOptions] ELSE Error[h, options];      ENDCASE => BadChar[h]};      BadChar: PROC[h: IT.Handle] = {IO.Char[h, '?]};    DisplayReadyList: PUBLIC PROC[h: IT.Handle] = {    q: PSB.Queue = WorldVMOps.Read[h.world, @PSB.PDA.ready];    h.qHead ¬ WorldVMOps.ProcessLong[q.tail];    DumpQueue[h, FALSE] };      OnReadyList: PROC [h: IT.Handle, p: IT.PsbItem] RETURNS [BOOLEAN] = {    queue: PSB.Queue = WorldVMOps.Read[h.world, @PSB.PDA.ready];    RETURN[OnQueue[h, p.p, queue]] };  OnFaultQueue: PROC [h: IT.Handle, p: IT.Process, fi: PSB.FaultIndex] RETURNS [BOOLEAN] = {    q1: PSB.Queue = WorldVMOps.Read[h.world, @PSB.PDA.fault[fi].queue];    q2: PSB.Queue = WorldVMOps.Read[h.world, @PSB.PDA.fault[fi+4].queue];    RETURN[OnQueue[h, p, q2] OR OnQueue[h, p, q1]]};  OnQueue: PROC [h: IT.Handle, p: IT.Process, queue: PSB.Queue] RETURNS [BOOLEAN] = {    next: IT.Process ¬ WorldVMOps.ProcessLong[queue.tail];    sanityCheck: CARDINAL ¬ 0;    UNTIL next = IT.NullProcess OR sanityCheck = 100 DO      IF next = p THEN RETURN[TRUE];      next ¬ WorldVMOps.ProcessLong[Hack[@ReadPsb[h, next].psb].link.next];      IF (next = WorldVMOps.ProcessLong[queue.tail]) THEN RETURN[FALSE]; -- went around circular list      sanityCheck ¬ sanityCheck + 1;      REPEAT FINISHED => RETURN[FALSE];      ENDLOOP };      DumpQueue: PROC [h: IT.Handle, condition: BOOLEAN] = {    IF (h.qHead ¬ StartQueue[h, condition]) = IT.NullProcess THEN {      Error[h, emptyQ];       IX.ResetPrompt[h];      IS.ResetParse[h]}    ELSE {      DumpPSB[h, ReadPsb[h, h.qHead]];      DumpStack[h, h.qHead, queue]}};      StartQueue: PROC [h: IT.Handle, condition: BOOLEAN] RETURNS [IT.Process] = {    cleanupPsbLink: IT.Process;    local: IT.PsbItem;    IF h.qHead = IT.NullProcess THEN RETURN[IT.NullProcess];    local ¬ ReadPsb[h, h.qHead];    cleanupPsbLink ¬ WorldVMOps.ProcessLong[Hack[@local.psb].flags.cleanup];    IF ~condition OR cleanupPsbLink = IT.NullProcess THEN RETURN[WorldVMOps.ProcessLong[Hack[@local.psb].link.next]];    UNTIL cleanupPsbLink = IT.NullProcess OR cleanupPsbLink = h.qHead DO      h.qHead ¬ cleanupPsbLink;      local ¬ ReadPsb[h, h.qHead];      cleanupPsbLink ¬ WorldVMOps.ProcessLong[Hack[@local.psb].flags.cleanup];      ENDLOOP;    RETURN[IF cleanupPsbLink = IT.NullProcess THEN h.qHead ELSE IT.NullProcess]};      DisplayProcess: PUBLIC PROC [h: IT.Handle, p: LONG STRING] = {    psb: IT.Process ¬ StringToPSB[h, p];    DumpPSB[h, ReadPsb[h, psb]];    DumpStack[h, psb, process]};      DumpPSB: PUBLIC PROC [h: IT.Handle, psb: IT.PsbItem] = {    lf: IT.LFHandle;    pp: PsbPointer = Hack[@psb.psb];    IO.EOL[h];    IO.Text["PSB: "L, h];    IY.ShowLongNum[h, psb.p, IO.options.lpRadix, FALSE];    IF psb.p = WorldVMOps.ProcessLong[h.swapData.process] THEN IO.Char[h, '*];    IO.Text[", "L, h];    SELECT TRUE FROM      WaitingCV[pp] => IO.Text["waiting CV, "L, h];      WaitingML[pp] => IO.Text["waiting ML, "L, h];      OnReadyList[h, psb] => IO.Text[IF (pp.link.permanent OR pp.link.preempted OR HasStateVector[h, pp.link.priority]) THEN "ready, "L ELSE "waiting SV, "L, h];      ENDCASE => DisplayFault[h, pp.context.state, psb.p];    IF (lf ¬ Frame[h, psb]) = NIL THEN { Error[h, noFrame]; IO.EOL[h] }    ELSE IQ.DisplayF[h, lf       ! IQ.InvalidFrame => {          IS.LongNum[h, f, [pointer[]]]; Error[h, invalidFrame]; CONTINUE};        WorldVMOps.AddressFault => {	  IS.WriteError[h, badAddress, FALSE]; 	  IS.LongNum[h, addr, [pointer[]]];	  IO.Char[h, ']]; 	  CONTINUE};	AMLoadstate.Error => {          IS.WriteError[h, nAllowed, FALSE]; 	  CONTINUE}]};      DisplayFault: PROC [h: IT.Handle, sv: PSB.StateVectorHandle, psb: IT.Process] = {    DumpFaultProc: TYPE = PROCEDURE [s: LONG STRING ¬ NIL];        DumpFrameFault: DumpFaultProc = {      fsi: CARDINAL = WorldVMOps.Read[h.world, @PSB.PDA[sv].fsi];      IO.Text["frame fault"L, h];      IF s # NIL THEN IO.Text[s, h];      IO.Text[", fsi: "L, h];      IS.Num[h, fsi, [card[]]]; IO.Text[", "L, h]};    DumpPageFault: DumpFaultProc = {      addr: LONG POINTER;      IO.Text["page fault"L, h];      IF s # NIL THEN IO.Text[s, h];      IO.Text[", address: "L, h];      WorldVMOps.CopyRead[world: h.world, from: @PSB.PDA[sv].memPointer, to: @addr, nwords: SIZE[LONG POINTER]];      IS.LongNum[h, addr, [pointer[]]]; IO.Text[", "L, h]};    DumpWriteFault: DumpFaultProc = {      addr: LONG POINTER;      IO.Text["write fault"L, h];      IF s # NIL THEN IO.Text[s, h];      IO.Text[", address: "L, h];      WorldVMOps.CopyRead[world: h.world, from: @PSB.PDA[sv].memPointer, to: @addr, nwords: SIZE[LONG POINTER]];      IS.LongNum[h, addr, [pointer[]]]; IO.Text[", "L, h]};    FOR faultType: CPSwapDefs.FaultType IN CPSwapDefs.FaultType DO       faultQueue: CPSwapDefs.FaultQueuePtr;      dumpFaultProc: DumpFaultProc = SELECT faultType FROM frame => DumpFrameFault, page => DumpPageFault, write => DumpWriteFault, ENDCASE => NIL;      IF OnFaultQueue[h, psb, SELECT faultType FROM frame => PSB.qFrameFault, page => PSB.qPageFault, ENDCASE => PSB.qWriteProtectFault] THEN { dumpFaultProc[]; RETURN };      faultQueue ¬ WorldVMOps.GetESV[h.world].faultsBeingProcessed[faultType];      DO	faultQueueItem: CPSwapDefs.FaultQueueItem;	IF faultQueue = NIL THEN EXIT;	WorldVMOps.CopyRead[world: h.world, from: faultQueue, to: @faultQueueItem, nwords: SIZE[CPSwapDefs.FaultQueueItem]]; 	IF OnQueue[h, psb, faultQueueItem.queue] THEN {	  dumpFaultProc[SELECT faultQueueItem.state FROM	    awaitingHandler => " (awaiting handler)"L,	    beingProcessed => " (being processed)"L,	    errorFaultUnprocessed => " (error awaiting handler)"L,	    errorFaultBeingProcessed => " (error being processed)"L,	    ENDCASE => NIL];	  RETURN };	faultQueue ¬ faultQueueItem.next;	ENDLOOP;       REPEAT FINISHED => IO.Text["faulted, "L, h];      ENDLOOP };  DumpSource: PROC [h: IT.Handle, psb: IT.Process, loadSource: BOOLEAN] = {    lf: IT.LFHandle ¬ Frame[h, ReadPsb[h, psb]];    IO.EOL[h];    IP.DisplaySource[h, IP.GF[h, lf], IP.PC[h, lf], loadSource ! SymbolTable.Missing => {Error[h, noSyms]; CONTINUE}]};      DumpRoot: PROC [h: IT.Handle, psb: IT.Process] = {    lf: IT.LFHandle ¬ Frame[h, ReadPsb[h, psb]];    DO lf ¬ IP.Previous[h, lf ! IP.NoPrevious => EXIT]; ENDLOOP;    IF lf = NIL THEN RETURN;    IO.EOL[h];    IQ.DisplayF[h, lf]};      DumpPriority: PROC [h: IT.Handle, psb: IT.Process] = {    IO.Text["riority "L, h];     IS.Num[h, Priority[Hack[@ReadPsb[h, psb].psb]], [card[]]]};      EvalStack: PUBLIC PROCEDURE[h: IT.Handle] = {    sp: WorldVMOps.Address; --LONG POINTER TO PrincOps.StateVector.dst    state: PrincOps.StateVector.dst;    IO.Text[": "L, h];    IF h.pContext = WorldVMOps.ProcessLong[h.swapData.process] OR h.pContext = IT.NullProcess THEN {      IF (sp ¬ WorldVMOps.GetSV[h.world]) = NIL THEN { IO.Line[h, "empty!"L]; RETURN }}    ELSE {      local: PsbPointer ¬ Hack[@ReadPsb[h, h.pContext].psb];      IF ~(local.link.permanent OR local.link.preempted) THEN { IO.Line[h, "no state vector!"L]; RETURN };      sp ¬ @PSB.PDA[local.context.state] };    IO.Char[h, '(]; IS.LongNum[h, sp, [pointer[]]]; IO.Text[") "L, h];    WorldVMOps.CopyRead[world: h.world, from: sp, to: @state, nwords: SIZE[PrincOps.StateVector.dst]];     IF state.stkptr = 0 THEN { IO.Line[h, "empty!"L]; RETURN };    FOR i: CARDINAL IN [0..state.stkptr) DO IO.Char[h, ' ]; IS.Num[h, state.stk[i], [card[]]] ENDLOOP };        EvalStackEmpty: PUBLIC PROCEDURE[h: IT.Handle] RETURNS [BOOLEAN] = {    sp: WorldVMOps.Address = WorldVMOps.GetSV[h.world];    state: PrincOps.StateVector.dst;    IF sp = NIL THEN RETURN[TRUE];    WorldVMOps.CopyRead[world: h.world, from: sp, to: @state, nwords: SIZE[PrincOps.StateVector.dst]];    RETURN[state.stkptr = 0] };   StringToPSB: PROC [h: IT.Handle, p: LONG STRING] RETURNS [psb: IT.Process] = {    psb ¬ IT.NullProcess;    psb ¬ IO.StringExpToLOctal[h, p ! IO.InvalidNumber => CONTINUE];    IF psb # IT.NullProcess THEN Check[h, psb] };      DisplayQueue: PUBLIC PROC [h: IT.Handle, q: LONG STRING] = {    condition: BOOLEAN ¬ FALSE;    giveup: BOOLEAN ¬ FALSE;    call: BOOLEAN ¬ TRUE;    FindQueue: IT.FooProc = {      link: PSB.PsbLink;      n: IT.Number;      IF f = NIL THEN { giveup ¬ TRUE; RETURN };      IP.GetValue[h, f];      SELECT IP.TypeForSe[h, f.tsei] FROM	com.typeLOCK => { condition ¬ FALSE; link ¬ f.addr.base­ };	com.typeCONDITION => { condition ¬ TRUE; link ¬ f.addr.base­ };	ENDCASE => {	  call ¬ FALSE;	  n ¬ IP.GetNumber[h, f];	  SELECT n.type FROM	    one => link ¬ WorldVMOps.Read[h.world, WorldVMOps.Long[h.world, n.p]];	    two => link ¬ WorldVMOps.Read[h.world, n.lp];	    ENDCASE => { Error[h, invalidQueue]; IO.EOL[h]; giveup ¬ TRUE; RETURN }};      h.qHead ¬ WorldVMOps.ProcessLong[link.next] }; -- FindQueue    h.qHead ¬ IT.NullProcess;    IO.Interpret[h, q, FindQueue];    IF giveup THEN RETURN;    IF call THEN DumpQueue[h, condition]    ELSE { IX.SetPrompt[h, ConditionPrompt]; IS.SetParse[h, ConditionParse] }};      ConditionPrompt: IT.PromptProc = {    IO.Text[" Condition [Y or N]? "L, h] };    ConditionParse: IT.ParseProc = {    SELECT c FROM      'y, 'Y, Ascii.CR  => {IO.Line[h, "yes"L]; DumpQueue[h, TRUE]};      ENDCASE => {IO.Line[h, "no"L]; DumpQueue[h, FALSE]};    IS.Prompt[h]};  ErrorType: TYPE = { emptyQ, invalidQueue, noFrame, invalidFrame, processOptions, options, noSyms };      Error: PROC [h: IT.Handle, type: ErrorType] = {    SELECT type FROM      emptyQ => IO.Text[" Queue empty!"L, h];      invalidQueue => IO.Text[" Invalid address for queue!"L, h];      noFrame => IO.Text["No frame!"L, h];      invalidFrame => IS.WriteError[h, nGframe, FALSE];      processOptions => IO.Text[" --Options are: "" "", --, List source, Next, Priority, Quit, Root, Source"L, h];       options => IO.Text[" --Options are: Next, Priority, Quit, Root"L, h];      noSyms => IS.WriteError[h, nSymtab, FALSE];      ENDCASE };  }.
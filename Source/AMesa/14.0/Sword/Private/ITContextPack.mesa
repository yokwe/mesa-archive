-- File: ITContextPack.mesa - last edit:-- Litman              10-Apr-87 22:23:10-- Copyright (C) 1987 by Xerox Corporation. All rights reserved. DIRECTORY  AMLoadstate USING [AcquireBcd, BcdProc, EnumerateBcds, EnumerateModulesInConfig, Error, GetAttributes, GFHandle, Handle, Index, MapConfigToMth, MapConfigToReal, MapRealToConfig, ModuleProc, nullIndex],  BcdDefs USING [Base, CTIndex, CTNull, MTIndex, MTNull, MTRecord, NameRecord],  BcdOps USING [BcdBase, CTHandle, FindName, MTHandle, NameString, ProcessConfigs, ProcessModules],  BcdOpsExtras USING [CTBaseFromBcd, GfiFromMti, MthFromGfi, MthFromMti, MtiFromGfi, NameStringFromBcd],  IB USING [GetModule],  IM USING [strings],  IO USING [Abort, Blanks, Char, Decimal, EOL, Line, MakeString, options, SubString, Text, UserAbort, UserAborted],  IP USING [DumpFrameDesc, GF, MultipleFrames, Name, NoAccessLink, Original],  IQ USING [DisplayGF, InvalidFrame, ValidateGF],  IS USING [Frame, LongNum, ReadPsb, WriteError],  IT USING [GFHandle, Handle, LFHandle, MaxModuleString, NullProcess, Process],  IY USING [ShowLongNum],  String USING [EqualSubStrings, SubStringDescriptor],  WorldVMOps USING [AddressFault, GetLoadstate, GFlong, GFshort, LFlong, Process, ProcessLong];  ITContextPack: PROGRAM  IMPORTS AMLoadstate, BcdOps, BcdOpsExtras, IB, IM, IO, IP, IQ, IS, IY, String, WorldVMOps  EXPORTS IS = {    ResetContext: PUBLIC PROCEDURE[h: IT.Handle] = {    lf: IT.LFHandle;    gf: IT.GFHandle;    psb: IT.Process;    WITH sd: h.swapData SELECT FROM      storageFault => {        psb ¬ WorldVMOps.ProcessLong[sd.faultedProcess];       	lf ¬ IS.Frame[h, IS.ReadPsb[h, psb] ! WorldVMOps.AddressFault => {lf ¬ NIL; CONTINUE}] };      ENDCASE => {        psb ¬ WorldVMOps.ProcessLong[h.swapData.process];	lf ¬ WorldVMOps.LFlong[h.world, h.swapData.lFrame] };    BEGIN ENABLE IO.Abort, WorldVMOps.AddressFault => CONTINUE;      gf ¬ IP.GF[h, lf ! IQ.InvalidFrame, IP.NoAccessLink => { CleanupInvalidContext[h, lf]; GOTO Done }];      WriteContext[h, gf];      h.gContext ¬ gf;      END;    h.lContext ¬ lf;    h.pContext ¬ psb;    h.iContext ¬ [state[lf]];    EXITS Done => NULL };      SetOctal: PUBLIC PROCEDURE[h: IT.Handle, p: LONG POINTER] = {    IF IQ.ValidateGF[h, p] THEN SetGlobalInternal[h, p]     ELSE SetLocal[h, p] };      SetGlobal: PUBLIC PROCEDURE[h: IT.Handle, gf: IT.GFHandle] = {    IF IQ.ValidateGF[h, gf] THEN SetGlobalInternal[h, gf]    ELSE CleanupInvalidContext[h, gf] };          SetGlobalInternal: PROCEDURE[h: IT.Handle, gf: IT.GFHandle] = {    WriteContext[h, gf];    h.lContext ¬ NIL;    h.gContext ¬ gf;    h.pContext ¬ IT.NullProcess;    h.iContext ¬ [global[gf]]};      SetLocal: PUBLIC PROCEDURE[h: IT.Handle, lf: IT.LFHandle] = {    gf: IT.GFHandle;    gf ¬ IP.GF[h, lf ! IQ.InvalidFrame, IP.NoAccessLink => { CleanupInvalidContext[h, lf]; GOTO Done }];    WriteContext[h, gf];    h.lContext ¬ lf;    h.gContext ¬ gf;    h.pContext ¬ IT.NullProcess;    h.iContext ¬ [local[lf]];    EXITS Done => NULL };      SetProcess: PUBLIC PROCEDURE[h: IT.Handle, p: IT.Process] = {    SetLocal[h, IS.Frame[h, IS.ReadPsb[h, p]]];    h.pContext ¬ p;    h.iContext ¬ [process[p]]};      CleanupInvalidContext: PROCEDURE[h: IT.Handle, frame: LONG UNSPECIFIED] = {    ENABLE AMLoadstate.Error => GOTO none;    bcd: BcdOps.BcdBase;    loadstate: AMLoadstate.Handle = WorldVMOps.GetLoadstate[h.world];    IO.EOL[h]; IS.LongNum[h, frame, [pointer[]]]; IS.WriteError[h, nGframe, FALSE];    h.lContext ¬ NIL;     h.gContext ¬ NIL;     h.pContext ¬ IT.NullProcess;    h.config ¬ AMLoadstate.GetAttributes[loadstate].nBcds - 1;    bcd ¬ AMLoadstate.AcquireBcd[loadstate, h.config ! AMLoadstate.Error => GOTO none];    h.cti ¬ IF bcd.nConfigs = 0 AND bcd.nModules = 1 THEN BcdDefs.CTNull ELSE FIRST[BcdDefs.CTIndex];    EXITS none => {h.config ¬ AMLoadstate.nullIndex; h.cti ¬ BcdDefs.CTNull }};    WriteContext: PROCEDURE[h: IT.Handle, gf: IT.GFHandle] = {    index: AMLoadstate.Index;    cgfi: CARDINAL;    module: BcdOps.MTHandle;    loadstate: AMLoadstate.Handle = WorldVMOps.GetLoadstate[h.world];    [cgfi, index] ¬ AMLoadstate.MapRealToConfig[loadstate, WorldVMOps.GFshort[h.world, IP.Original[h, gf]] ! AMLoadstate.Error => GOTO noContext];    IF index = AMLoadstate.nullIndex THEN ERROR IQ.InvalidFrame[gf];    h.config ¬ index;    IF (module ¬ AMLoadstate.MapConfigToMth[loadstate, cgfi, index]) # NIL THEN h.cti ¬ module.config;    EXITS noContext => NULL };      SetRootConfig: PUBLIC PROCEDURE[h: IT.Handle, config: LONG STRING] = {    Rcount: CARDINAL ¬ 0;    configdesc: String.SubStringDescriptor;    savecti: BcdDefs.CTIndex ¬ BcdDefs.CTNull;    saveconfig: AMLoadstate.Index;    loadstate: AMLoadstate.Handle = WorldVMOps.GetLoadstate[h.world];    GetSetUp: AMLoadstate.BcdProc = { -- PROC [bcdInfo: BcdInfo, index: Index] RETURNS [stop: BOOLEAN]      found: BOOLEAN ¬ FALSE;      bcd: BcdOps.BcdBase;      CheckForRoot: PROCEDURE[cth: BcdOps.CTHandle, cti: BcdDefs.CTIndex] RETURNS [BOOLEAN] = {	IF IO.UserAbort[h] THEN SIGNAL IO.UserAborted;	IF cth.config # BcdDefs.CTNull THEN RETURN[FALSE];	IF ~(found ¬ TestName[cth.name]) THEN IF cth.namedInstance THEN found ¬ TestName[BcdOps.FindName[bcd, [config[cti]]]];	IF found THEN { savecti ¬ cti; Rcount ¬ Rcount+1; saveconfig ¬ index; };	RETURN[FALSE] };      TestName: PROCEDURE[name: BcdDefs.NameRecord] RETURNS [BOOLEAN] = {	tempssb: BcdOps.NameString = BcdOpsExtras.NameStringFromBcd[bcd];	ssd: String.SubStringDescriptor ¬ [base: @tempssb.string, offset: name, length: tempssb.size[name]];	RETURN[String.EqualSubStrings[@configdesc, @ssd]] };      bcd ¬ AMLoadstate.AcquireBcd[loadstate, index ! AMLoadstate.Error => GOTO NoBcd];      IF bcd.nConfigs = 0 AND bcd.nModules = 1 THEN {	mth: BcdOps.MTHandle ¬ BcdOpsExtras.MthFromMti[bcd, FIRST[BcdDefs.MTIndex]];	IF ~(found ¬ TestName[mth.name]) THEN IF mth.namedInstance THEN found ¬ TestName[BcdOps.FindName[bcd, [module[FIRST[BcdDefs.MTIndex]]]]];	IF found THEN { Rcount ¬ Rcount+1; saveconfig ¬ index; savecti ¬ BcdDefs.CTNull }}      ELSE [] ¬ BcdOps.ProcessConfigs[bcd, CheckForRoot];      RETURN[FALSE]      EXITS NoBcd => RETURN[FALSE] };    IM.strings[rconfig] ¬ config;    configdesc ¬ String.SubStringDescriptor[base: config, offset: 0, length: config.length];    [] ¬ AMLoadstate.EnumerateBcds[loadstate, GetSetUp, TRUE];    SELECT Rcount FROM      = 0 => NotFound[h, config];      = 1 => SetupRootConfig[h, saveconfig, savecti];      ENDCASE => WriteAmbiguousContext[h, config, Rcount] };      SetConfig: PUBLIC PROCEDURE[h: IT.Handle, config: LONG STRING] = {    bcd: BcdOps.BcdBase;    count: CARDINAL ¬ 0;    configdesc: String.SubStringDescriptor;    savecti: BcdDefs.CTIndex;    loadstate: AMLoadstate.Handle = WorldVMOps.GetLoadstate[h.world];    CheckConfigName: PROCEDURE[      cth: BcdOps.CTHandle, cti: BcdDefs.CTIndex] RETURNS [BOOLEAN] = {      found: BOOLEAN ¬ FALSE;      ssb: BcdOps.NameString ¬ BcdOpsExtras.NameStringFromBcd[bcd];      TestName: PROCEDURE[        ssb: BcdOps.NameString, name: BcdDefs.NameRecord] RETURNS [BOOLEAN] = {	ssd: String.SubStringDescriptor ¬ [base: @ssb.string, offset: name, length: ssb.size[name]];	RETURN[String.EqualSubStrings[@configdesc, @ssd]]};      IF IO.UserAbort[h] THEN SIGNAL IO.UserAborted;      IF ~SameConfig[h, bcd, cth.config, h.cti] THEN RETURN[FALSE];      IF ~(found ¬ TestName[ssb, cth.name]) THEN	IF cth.namedInstance THEN found ¬ TestName[ssb, BcdOps.FindName[bcd, [config[cti]]]];      IF found THEN { count ¬ count + 1; savecti ¬ cti; };      RETURN[FALSE] };    IM.strings[config] ¬ config;    configdesc ¬ String.SubStringDescriptor[base: config, offset: 0, length: config.length];    IF h.cti = BcdDefs.CTNull THEN {IO.Text[" -- Not allowed !"L, h]; RETURN};    bcd ¬ AMLoadstate.AcquireBcd[loadstate, h.config ! AMLoadstate.Error => {bcd ¬ NIL; CONTINUE}];    [] ¬ BcdOps.ProcessConfigs[bcd, CheckConfigName];    SELECT count FROM      = 0 => NotFound[h, config];      = 1 => IF SetupConfig[h, bcd, savecti, h.config] THEN h.cti ¬ savecti;      ENDCASE => WriteAmbiguousContext[h, config, count] };      NotFound: PROCEDURE[h: IT.Handle, s: LONG STRING]= {    IO.EOL[h]; IO.Text[s, h]; IO.Line[h, " not found!"L]};      SetModule: PUBLIC PROCEDURE[h: IT.Handle, mod: LONG STRING] = {    gf: IT.GFHandle ¬ IB.GetModule[h, mod ! IP.MultipleFrames => { IP.DumpFrameDesc[h, mod, list]; GOTO Done }];    IM.strings[module] ¬ mod;    IF gf = NIL THEN NotFound[h, NIL] ELSE SetGlobalInternal[h, gf];    EXITS Done => NULL };    -- retrieving    GetOctal: PUBLIC PROC[h: IT.Handle] RETURNS [p: LONG POINTER] = {    RETURN[h.lContext]};      GetLocal: PUBLIC PROC[h: IT.Handle] RETURNS [lf: IT.LFHandle] = {    RETURN[h.lContext]};      GetGlobal: PUBLIC PROC[h: IT.Handle] RETURNS [gf: IT.GFHandle] = {    RETURN[h.gContext]};      GetProcess: PUBLIC PROC[h: IT.Handle] RETURNS [p: IT.Process] = {    RETURN[h.pContext]};      GetRootConfig: PUBLIC PROC[h: IT.Handle] RETURNS [config: LONG STRING] = {    config ¬ IM.strings[rconfig]};      GetConfig: PUBLIC PROC[h: IT.Handle] RETURNS [config: LONG STRING] = {    config ¬ IM.strings[config]};      GetModule: PUBLIC PROC[h: IT.Handle] RETURNS [mod: LONG STRING] = {    IF (mod ¬ IM.strings[module]) = NIL THEN {      IM.strings[module] ¬ mod ¬ IO.MakeString[h, IT.MaxModuleString];      IP.Name[h, mod, GetGlobal[h]]}};      GetRootConfigIndex: PUBLIC PROC[h: IT.Handle] RETURNS [config: AMLoadstate.Index] = {    RETURN [h.config] };      GetConfigIndex: PUBLIC PROC[h: IT.Handle] RETURNS [cti: BcdDefs.CTIndex] = {    RETURN [h.cti] };      -- utilities    DisplayCurrent: PUBLIC PROC[h: IT.Handle] = {    bcd: BcdOps.BcdBase ¬ NIL;    IO.EOL[h];    IQ.DisplayGF[h, h.gContext, "Module:"L];    IF h.lContext # NIL THEN { IO.Text[", L"L, h]; Colon[h]; IS.LongNum[h, h.lContext, [pointer[]]]};    IF h.pContext # IT.NullProcess THEN { IO.Text[", PSB"L, h]; Colon[h]; IY.ShowLongNum[h, h.pContext, IO.options.lpRadix, FALSE]};    IO.EOL[h];    bcd ¬ AMLoadstate.AcquireBcd[WorldVMOps.GetLoadstate[h.world], h.config ! AMLoadstate.Error => GOTO noContext];    IF bcd.nConfigs # 0 THEN {      cth: BcdOps.CTHandle ¬ @BcdOpsExtras.CTBaseFromBcd[bcd][h.cti];      ssb: BcdOps.NameString ¬ BcdOpsExtras.NameStringFromBcd[bcd];      IO.Text["  Configuration"L, h]; Colon[h];      IF cth.namedInstance THEN {	PrintName[h, ssb, BcdOps.FindName[bcd, [config[h.cti]]]];	Colon[h] };      PrintName[h, ssb, cth.name];      IF h.cti # FIRST[BcdDefs.CTIndex] THEN {        cth ¬ @BcdOpsExtras.CTBaseFromBcd[bcd][FIRST[BcdDefs.CTIndex]];        IO.Text["  Root"L, h]; Colon[h];	IF cth.namedInstance THEN {	  PrintName[h, ssb, BcdOps.FindName[bcd, [config[FIRST[BcdDefs.CTIndex]]]]];	  Colon[h] };	PrintName[h, ssb, cth.name] };      IO.EOL[h];};    EXITS noContext => IO.Text["No valid context!!"L, h]};    ListConfigs: PUBLIC PROC[h: IT.Handle] = {    loadstate: AMLoadstate.Handle = WorldVMOps.GetLoadstate[h.world];    PrintConfigs: AMLoadstate.BcdProc = {      -- PROC [bcdInfo: BcdInfo, index: Index] RETURNS [stop: BOOLEAN]      bcd: BcdOps.BcdBase;      tempssb: BcdOps.NameString;      ListSons: PROCEDURE[level: CARDINAL, parent: BcdDefs.CTIndex] = {	WriteNames: PROCEDURE[cth: BcdOps.CTHandle, cti: BcdDefs.CTIndex] RETURNS [BOOLEAN] = {	  IF cth.config = parent THEN {	    IF IO.UserAbort[h] THEN SIGNAL IO.UserAborted;	    IO.EOL[h];	    IO.Blanks[h, level*2];	    IF cth.namedInstance THEN {	      PrintName[h, tempssb, BcdOps.FindName[bcd, [config[cti]]]];	      IO.Text[": "L, h]};	    PrintName[h, tempssb, cth.name];	    ListSons[level+1, cti]};	  RETURN[FALSE]};	[] ¬ EnumerateConfigNames[h, bcd, WriteNames]};      bcd ¬ AMLoadstate.AcquireBcd[loadstate, index ! AMLoadstate.Error => GOTO NoBcd];      tempssb ¬ BcdOpsExtras.NameStringFromBcd[bcd];      ListSons[0, BcdDefs.CTNull];      RETURN[FALSE]      EXITS NoBcd => RETURN[FALSE]};    [] ¬ AMLoadstate.EnumerateBcds[loadstate, PrintConfigs, TRUE] };      EnumerateConfigNames: PROCEDURE[h: IT.Handle, bcd: BcdOps.BcdBase, proc: PROCEDURE[BcdOps.CTHandle, BcdDefs.CTIndex] RETURNS [BOOLEAN]]    RETURNS[BcdDefs.CTIndex] = {    mth: BcdOps.MTHandle = BcdOpsExtras.MthFromMti[bcd, FIRST[BcdDefs.MTIndex]];    tempssb: BcdOps.NameString = BcdOpsExtras.NameStringFromBcd[bcd];    IF bcd.nConfigs = 0 AND bcd.nModules = 1 THEN {      IO.EOL[h];      IF mth.namedInstance THEN {	PrintName[h, tempssb, BcdOps.FindName[bcd, [module[FIRST[BcdDefs.MTIndex]]]]];	IO.Text[": "L, h] };      PrintName[h, tempssb, mth.name];      RETURN[BcdDefs.CTNull] };    RETURN[BcdOps.ProcessConfigs[bcd, proc].cti] };      DisplayConfig: PUBLIC PROCEDURE[h: IT.Handle] = {    bcd: BcdOps.BcdBase ¬ NIL;    ssb: BcdOps.NameString;    loadstate: AMLoadstate.Handle = WorldVMOps.GetLoadstate[h.world];    PrintModules: AMLoadstate.ModuleProc = {      -- PROC [modInfo: ModuleInfo] RETURNS [stop: BOOLEAN]      mth: BcdOps.MTHandle = BcdOpsExtras.MthFromGfi[bcd, modInfo.cgfi];      mti: BcdDefs.MTIndex = BcdOpsExtras.MtiFromGfi[modInfo.cgfi];      IF IO.UserAbort[h] THEN SIGNAL IO.UserAborted;      IO.EOL[h];      IF ~SameConfig[h, bcd, mth.config, h.cti] THEN RETURN[FALSE];      IF mth.namedInstance THEN {	PrintName[h, ssb, BcdOps.FindName[bcd, [module[mti]]]];	IO.Text[": "L, h] };      IQ.DisplayGF[h, WorldVMOps.GFlong[h.world, modInfo.gf], NIL];      RETURN[FALSE] };    bcd ¬ AMLoadstate.AcquireBcd[loadstate, h.config];    ssb ¬ BcdOpsExtras.NameStringFromBcd[bcd];    IO.Blanks[h, 2];    IF bcd.nConfigs # 0 THEN {      cth: BcdOps.CTHandle ¬ @BcdOpsExtras.CTBaseFromBcd[bcd][h.cti];      IF cth.namedInstance THEN {	PrintName[h, ssb, BcdOps.FindName[bcd, [config[h.cti]]]];	IO.Text[": "L, h] };      PrintName[h, ssb, cth.name] };    [] ¬ AMLoadstate.EnumerateModulesInConfig[loadstate, PrintModules, h.config] };      SetupRootConfig: PROCEDURE[h: IT.Handle, config: AMLoadstate.Index, cti: BcdDefs.CTIndex] = {    bcd: BcdOps.BcdBase ¬ AMLoadstate.AcquireBcd[WorldVMOps.GetLoadstate[h.world], config];    IF SetupConfig[h, bcd, cti, config] THEN {      h.config ¬ config;      h.cti ¬ cti}};      SetupConfig: PROCEDURE[h: IT.Handle, bcd: BcdOps.BcdBase, cti: BcdDefs.CTIndex, config: AMLoadstate.Index] RETURNS [BOOLEAN] = {    loadstate: AMLoadstate.Handle = WorldVMOps.GetLoadstate[h.world];    FindFirstModule: PROCEDURE[mth: BcdOps.MTHandle, mti: BcdDefs.MTIndex] RETURNS [BOOLEAN] = {      RETURN[SameConfig[h, bcd, mth.config, cti]] };    mti: BcdDefs.MTIndex ¬ BcdOps.ProcessModules[bcd, FindFirstModule].mti;    IF mti # BcdDefs.MTNull THEN {      gf: IT.GFHandle = WorldVMOps.GFlong[h.world, AMLoadstate.MapConfigToReal[loadstate, BcdOpsExtras.GfiFromMti[mti], config]];      h.gContext ¬ gf;      h.lContext ¬ NIL;      h.pContext ¬ IT.NullProcess;      h.iContext ¬ [global[gf]];      RETURN[TRUE]}    ELSE {IO.Text[" -- Not Allowed !"L, h]; RETURN[FALSE]}};      WriteAmbiguousContext: PROCEDURE[h: IT.Handle, s: LONG STRING, c: CARDINAL] = {    IO.Char[h, '!]; IO.Text[s, h]; IO.Text[" has "L, h]; IO.Decimal[h, c];    IO.Line[h, " instances -- this is an ambiguous reference."L] };      PrintName: PROCEDURE[h: IT.Handle, ssb: BcdOps.NameString, name: BcdDefs.NameRecord] = {    string: String.SubStringDescriptor;    string.base ¬ @ssb.string;    string.length ¬ ssb.size[string.offset ¬ name];    IO.SubString[h, @string] };      Colon: PROCEDURE[h: IT.Handle] = INLINE {IO.Text[": "L, h]};    SameConfig: PUBLIC PROCEDURE[h: IT.Handle, bcd: BcdOps.BcdBase, child, parent: BcdDefs.CTIndex] RETURNS [BOOLEAN] = {    cti: BcdDefs.CTIndex;    ctb: BcdDefs.Base = BcdOpsExtras.CTBaseFromBcd[bcd];    -- checks to see if child is related to parent    FOR cti ¬ child, ctb[cti].config UNTIL cti = BcdDefs.CTNull DO      IF cti = parent THEN RETURN[TRUE];      ENDLOOP;    RETURN[parent = BcdDefs.CTNull]};      }.
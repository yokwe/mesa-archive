-- Copyright (C) 1981, 1983, 1984, 1986  by Xerox Corporation. All rights reserved. -- TraceImpl.mesa; edited by-- Glassman	23-Dec-81 11:41:21-- Johnsson	26-Feb-81 11:16:20-- SHayes	28-Apr-81 17:36:52-- Daniels	23-Sep-83 17:07:04-- Litman	18-Jan-86 13:13:38DIRECTORY  Environment USING [PageFromLongPointer, PageNumber],  Frame USING [GetReturnFrame, MyLocalFrame],  FrameExtras USING [GFTHandleToLongGF, GlobalOverhead, WriteGlobalWord],  Inline USING [BITAND],  LoadState USING [LockBcdInfo, UnlockBcdInfo],  LoadStateFormat USING [Handle],  PageMap USING [flagsVacant, GetState],  PrincOps USING [StateVector],  PrincOpsExtras USING [SourceDest],  PrincOpsExtras2 USING [ControlLink, GlobalWord, NullLink],  ProcessOperations USING [DisableInterrupts, EnableInterrupts],  Runtime USING [CallDebugger],  SDDefs USING [SD, sXferTrap],  SpecialSpace USING [    MakeGlobalFrameResident, MakeGlobalFrameSwappable, MakeProcedureResident,    MakeProcedureSwappable, SpecialError],  XferTrap USING [WriteXTS],  Watch;TraceImpl: PROGRAM  IMPORTS    Environment, PageMap, Frame, FrameExtras, Inline, LoadState,     ProcessOperations, Runtime, SpecialSpace, XferTrap  EXPORTS Watch  SHARES PageMap = BEGIN  continueTracing: BOOLEAN ¬ FALSE;  StartTrace: PUBLIC PROC[loc: LONG POINTER, val: UNSPECIFIED, mask: WORD, equal: BOOLEAN] = {    xc: PrincOpsExtras.SourceDest;    state: PrincOps.StateVector;    a: RECORD [       keepStateAwayFromLocalZero: ARRAY [0..3) OF WORD ¬ TRASH,       loc: LONG POINTER,      val: UNSPECIFIED,      mask: WORD,      equal: BOOLEAN,      pageNumber: Environment.PageNumber] ¬       [loc: loc, val: val, mask: mask, equal: equal,         pageNumber: Environment.PageFromLongPointer[a.loc]];    continueTracing ¬ TRUE;    SpecialSpace.MakeProcedureResident[LOOPHOLE[StartTrace] ! SpecialSpace.SpecialError => CONTINUE];    SpecialSpace.MakeGlobalFrameResident[TraceImpl ! SpecialSpace.SpecialError => CONTINUE];    MarkFrames[TRUE];    SDDefs.SD[SDDefs.sXferTrap] ¬ LOOPHOLE[LONG[Frame.MyLocalFrame[]]];    ProcessOperations.DisableInterrupts[];    DO      state ¬ STATE;      XferTrap.WriteXTS[off];      xc.dest ¬ [frame[frame: Frame.GetReturnFrame[]]];      -- Dont check the location unless the page is swapped in,      -- to prevent unnecessary page faults. If we want to allow page faults,      -- then enable interrupts before doing the dereference.      IF PageMap.GetState[a.pageNumber].state.flags # PageMap.flagsVacant AND        (a.equal = (a.val = Inline.BITAND[a.loc­, a.mask])) THEN {        ProcessOperations.EnableInterrupts[];	Runtime.CallDebugger["TraceTrap"L];        ProcessOperations.DisableInterrupts[] };      IF continueTracing THEN {        XferTrap.WriteXTS[skip1];	STATE ¬ state;        TRANSFER WITH xc }      ELSE {        ProcessOperations.EnableInterrupts[];        SDDefs.SD[SDDefs.sXferTrap] ¬ LOOPHOLE[PrincOpsExtras2.NullLink];	MarkFrames[FALSE];        SpecialSpace.MakeGlobalFrameSwappable[TraceImpl ! SpecialSpace.SpecialError => CONTINUE];        SpecialSpace.MakeProcedureSwappable[LOOPHOLE[StartTrace] ! SpecialSpace.SpecialError => CONTINUE];	STATE ¬ state;        EXIT };      ENDLOOP };  StopTrace: PUBLIC PROC = {continueTracing ¬ FALSE};  StartWatch: PUBLIC PROC [loc: LONG POINTER] = {    StartTrace[loc, loc­, 177777B, FALSE]};  MarkFrames: PROC[on: BOOLEAN] = {    ls: LoadStateFormat.Handle = LoadState.LockBcdInfo[].loadState;    i: NAT ¬ 0;    DO      gw: PrincOpsExtras2.GlobalWord ¬ FrameExtras.GlobalOverhead[FrameExtras.GFTHandleToLongGF[ls[ls.moduleInfo][i].gfi]].word;      gw.trapxfers ¬ on;      FrameExtras.WriteGlobalWord[gw, FrameExtras.GFTHandleToLongGF[ls[ls.moduleInfo][i].gfi]];      i ¬ i + 1;      IF i = ls.nModules THEN EXIT;      ENDLOOP;    LoadState.UnlockBcdInfo[]};    END.
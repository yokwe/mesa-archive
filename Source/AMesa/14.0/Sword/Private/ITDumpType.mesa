-- Copyright (C) 1985  by Xerox Corporation. All rights reserved. -- ITDumpType.mesa; modified by:DIRECTORY  Alloc,  Ascii USING [SP],  Environment USING [bitsPerWord],   IO, IP, IQ, IR, IS, IT,  SymbolOps USING [FirstCtxSe, NextSe, TypeLink, UnderType, ToSei],  SymbolSegment,  Symbols USING [    BodyRecord, BTIndex, codeANY, CSEIndex, CSENull, CTXIndex, HTIndex, HTNull,     ISEIndex, ISENull, lZ, RecordSEIndex, SEIndex, SENull,    TransferMode, typeTYPE];  ITDumpType: PROGRAM  IMPORTS Alloc, IO, IP, IS, SymbolOps  EXPORTS IS =BEGIN OPEN IS, SymbolOps, Symbols;Sub: TYPE = PROCEDURE;NoSub: Sub = BEGIN RETURN END;Type: PUBLIC PROCEDURE [h: IT.Handle, isei: ISEIndex, pub: BOOLEAN ¬ FALSE, nest: CARDINAL ¬ 0,   recurring: BOOLEAN ¬ FALSE] = {  IF h.seb[isei].hash # HTNull THEN { IS.HtiVal[h, h.seb[isei].hash]; IO.Text[": "L, h] };  IF ~recurring THEN {    IO.Text[IF (pub ¬ h.seb[isei].public) THEN "PUBLIC "L ELSE "PRIVATE "L, h];    IO.Text["TYPE = "L, h] };  PrintType[h: h,     tsei: IF h.seb[isei].idType = typeTYPE THEN SymbolOps.ToSei[h.seb[isei].idInfo] ELSE h.seb[isei].idType,     pub: pub, nest: nest] };  TypedFieldCtx: PROCEDURE [h: IT.Handle,     ctx: CTXIndex, pub: BOOLEAN, rec: BOOLEAN ¬ TRUE, nest: CARDINAL ¬ 0] =  BEGIN OPEN h;  isei: ISEIndex ¬ SymbolOps.FirstCtxSe[sym, ctx];   first: BOOLEAN ¬ TRUE;  IF isei # ISENull AND seb[isei].idCtx # ctx     THEN isei ¬ SymbolOps.NextSe[sym, isei];  IF isei = ISENull THEN    BEGIN IF rec THEN IO.Text["[]"L, h]; RETURN END;  IF rec THEN IO.Char[h, '[];  FOR isei ¬ isei, SymbolOps.NextSe[sym, isei] UNTIL isei = ISENull DO    IF first THEN first ¬ FALSE    ELSE IF rec THEN IO.Text[", "L, h] ELSE IO.EOL[h];    Type[h, isei, pub, nest, TRUE];    ENDLOOP;  IF rec THEN IO.Char[h, ']];  END;  Indent: PROCEDURE [h: IT.Handle, level: CARDINAL] =  BEGIN  i: CARDINAL;  FOR i IN [0..level] DO IO.Text["  "L, h] ENDLOOP;  END;  PrintType: PROCEDURE [h: IT.Handle,     tsei: SEIndex, pub: BOOLEAN,    dosub: Sub ¬ NoSub, arraySub: BOOLEAN ¬ FALSE, nest: CARDINAL ¬ 0] =  BEGIN OPEN IO, h;  WITH t: seb[tsei] SELECT FROM    id =>       BEGIN      IF dosub = NoSub OR ~IP.DIFormat[h, LOOPHOLE[tsei]].intSub THEN	BEGIN	IS.HashVal[h, LOOPHOLE[tsei]];	UNTIL (tsei ¬ SymbolOps.TypeLink[sym, tsei]) = SENull DO	  WITH seb[tsei] SELECT FROM	    id =>	      BEGIN	      Char[h, ' ];	      IS.HashVal[h, LOOPHOLE[tsei]];	      IF ~mark3 OR ctxb[idCtx].level # lZ THEN		BEGIN dosub[]; RETURN END;	      END;	    ENDCASE;	  ENDLOOP;	END;      dosub[];      END;    cons =>      BEGIN      WITH t SELECT FROM	basic => NULL;	  ENDCASE => IP.CopyMore[h, tsei, TRUE];      WITH t SELECT FROM	--basic =>  won't see one, see the id first.	enumerated =>	  BEGIN isei: ISEIndex; first: BOOLEAN ¬ TRUE;	  Char[h, '{];	  FOR isei ¬ FirstCtxSe[sym, valueCtx], NextSe[sym, isei] 	    UNTIL isei= ISENull DO	    IF first THEN first ¬ FALSE ELSE Text[", "L, h];	    IS.HashVal[h, isei];	    ENDLOOP;	  Char[h, '}];	  END;	record =>	  BEGIN	  IF ctxb[fieldCtx].level # lZ THEN	    BEGIN	    fctx: CTXIndex = fieldCtx;	    bti: BTIndex ¬ FIRST[BTIndex];	    btlimit: BTIndex = LOOPHOLE[	      Alloc.Bounds[IO.alloc, SymbolSegment.bodyType].size];	    Text["FRAME ["L, h];	    UNTIL LOOPHOLE[bti, CARDINAL] >= LOOPHOLE[btlimit, CARDINAL] DO	      WITH entry: bb[bti] SELECT FROM		Callable =>		  BEGIN 		  IF entry.localCtx = fctx THEN 		    BEGIN 		    IS.HashVal[h, entry.id]; Char[h, ']];		    EXIT 		    END;		  bti ¬ bti + (WITH entry SELECT FROM		    Inner => SIZE[Inner Callable BodyRecord],		    Catch => SIZE[Catch Callable BodyRecord],		    ENDCASE => SIZE[Outer Callable BodyRecord]);		  END;		ENDCASE => bti ¬ bti + SIZE[Other BodyRecord];	      ENDLOOP;	    END	  ELSE	    BEGIN	    IF monitored THEN Text["MONITORED "L, h];	    IF machineDep THEN Text["MACHINE DEPENDENT "L, h];	    Text["RECORD "L, h];	    TypedFieldCtx[h, fieldCtx, pub];	    END;	  END;	ref =>	  BEGIN	  IF readOnly THEN Text["READ ONLY "L, h];	  IF ordered THEN Text["ORDERED "L, h];	  IF basing THEN Text["BASE "L, h];	  Text["POINTER"L, h];	  IF dosub # NoSub THEN	    BEGIN	    Char[h, Ascii.SP];	    dosub[];	    END;	  WITH seb[UnderType[sym, refType]] SELECT FROM	    basic => IF code = Symbols.codeANY THEN GO TO noprint;	    ENDCASE;	  Text[" TO "L, h];	  PrintType[h, refType, pub];	  EXITS	    noprint => NULL;	  END;	array =>	  BEGIN	  IF packed THEN Text["PACKED "L, h];	  Text["ARRAY "L, h];	  PrintType[h, indexType, pub, NoSub, TRUE];	  Text[" OF "L, h];	  PrintType[h, componentType, pub];	  END;	arraydesc =>	  BEGIN	  Text["DESCRIPTOR FOR "L, h];	  PrintType[h, describedType, pub];	  END;	transfer =>	  BEGIN	  IS.ModeName[h, mode];	  IF typeIn # CSENull THEN	    WITH in: seb[typeIn] SELECT FROM	      record => BEGIN Char[h, ' ];	        TypedFieldCtx[h, in.fieldCtx, pub];	        END;	      ENDCASE => ERROR;	  IF typeOut # CSENull THEN	    WITH out: seb[typeOut] SELECT FROM	      record => BEGIN	        Text[" RETURNS "L, h];	        TypedFieldCtx[h, out.fieldCtx, pub];	        END;	      ENDCASE => ERROR;	  END;	union =>	  BEGIN	  tagType: SEIndex;	  Text["SELECT "L, h];	  IF ~controlled THEN	    IF overlaid THEN Text["OVERLAID "L, h]	    ELSE Text["COMPUTED "L, h]	  ELSE 	    BEGIN IS.HashVal[h, tagSei]; Text[": "L, h] END;	  tagType ¬ seb[tagSei].idType;	  IF pub # seb[tagSei].public THEN Text[	    IF ~pub THEN "PUBLIC "L ELSE "PRIVATE "L, h];	  WITH seb[tagType] SELECT FROM	    id => PrintType[h, tagType, seb[tagSei].public];	    cons => Char[h, '*];	    ENDCASE;	  Text[" FROM "L, h];	  BEGIN temp, isei: ISEIndex; varRec: RecordSEIndex;	  FOR isei ¬ FirstCtxSe[sym, caseCtx], temp UNTIL isei = ISENull DO	    EOL[h];	    Indent[h, nest];	    IS.HashVal[h, isei];	    varRec ¬ LOOPHOLE[SymbolOps.ToSei[seb[isei].idInfo]];	    FOR temp ¬ NextSe[sym, isei], NextSe[sym, temp]		UNTIL temp = ISENull OR SymbolOps.ToSei[seb[temp].idInfo] # isei DO	      Text[", "L, h];	      IS.HashVal[h, temp];	      ENDLOOP;	    Text[" => "L, h];	    TypedFieldCtx[h: h,	      ctx: seb[varRec].fieldCtx, pub: pub, nest: nest+1];	    Char[h, ',];	    ENDLOOP;	  EOL[h];	  Indent[h, nest];	  Text["ENDCASE"L, h];	  END;	  END;	sequence => {	  IF packed THEN Text["PACKED "L, h];	  Text["SEQUENCE "L, h];	  IF ~controlled THEN Text["COMPUTED "L, h]	  ELSE {IS.HashVal[h, tagSei]; Text[": "L, h]};	  IF pub # seb[tagSei].public THEN Text[	    IF ~pub THEN "PUBLIC "L ELSE "PRIVATE "L, h];	  PrintType[h, seb[tagSei].idType, seb[tagSei].public];	  Text[" OF "L, h];	  PrintType[h, componentType, pub]};	relative =>	  BEGIN	  IF baseType # SENull THEN PrintType[h, baseType, pub];	  Text["RELATIVE "L, h];	  PrintType[h, offsetType, pub, dosub];	  END;	subrange =>	  BEGIN	  org: INTEGER ¬ origin;	  size: CARDINAL ¬ range;	  type: SEIndex ¬ rangeType;	  doit: Sub =	    BEGIN	    Text[" ["L, h];	    IS.TypedNum[h, org, type];	    Text[".."L, h];	    IF arraySub AND size = 177777B THEN	      BEGIN IS.TypedNum[h, org, type]; Char[h, ')] END	    ELSE	      BEGIN IS.TypedNum[h, org+size, type]; Char[h, ']] END;	    END;      PrintType[h, rangeType, pub, doit];	  END;	long =>	  BEGIN	  Text["LONG "L, h];	  PrintType[h, rangeType, pub];	  END;	real => Text["REAL"L, h];	opaque => {	  Text["TYPE "L, h];      IF lengthKnown THEN {	    Char[h, '[];	    Octal[h, length/Environment.bitsPerWord];	    Char[h, ']]}};	zone => {	  IF mds THEN Text["MDSZone "L, h]	  ELSE 	    {IF ~counted THEN Text["UNCOUNTED "L, h];	    Text["ZONE "L, h]}};	ENDCASE      END;    ENDCASE;  END;END.
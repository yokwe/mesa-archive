-- Copyright (C) 1986  by Xerox Corporation. All rights reserved. -- DebugUsefulDefsImpl.mesaDIRECTORYDebugUsefulDefs,Environment, Event USING [spare2],Format, IA,Supervisor,SwordUsefulDefs,Window,WorldVMOps USING [GFshort, GFlong];DebugUsefulDefsImpl: PROGRAM   IMPORTS SUD: SwordUsefulDefs, Environment, WorldVMOps, Event, Supervisor  EXPORTS DebugUsefulDefs, IA = PUBLIC {    LongClientSource: TYPE = DebugUsefulDefs.LongClientSource;  LocalDest: TYPE = DebugUsefulDefs.LocalDest;  LocalSource: TYPE = DebugUsefulDefs.LocalSource;  LongClientDest: TYPE = DebugUsefulDefs.LongClientDest;  ClientSource: TYPE = DebugUsefulDefs.ClientSource;  GFHandle: TYPE = DebugUsefulDefs.GFHandle;  Bits: TYPE = DebugUsefulDefs.Bits;  FrameDesc: TYPE = DebugUsefulDefs.FrameDesc;      -- READing and WRITEing  LongREAD: PROC [loc: LongClientSource] RETURNS [val: UNSPECIFIED]= {    ENABLE SUD.InvalidAddress => ERROR InvalidAddress[address];    RETURN[SUD.LongREAD[loc, SUD.GetDefaultWorld[]]]};  LongWRITE: PROC [loc: LongClientDest, val: UNSPECIFIED]= {    ENABLE {      SUD.InvalidAddress => ERROR InvalidAddress[address];      SUD.WriteProtected => ERROR WriteProtected[Environment.PageFromLongPointer[address]]};    SUD.LongWRITE[loc, val, SUD.GetDefaultWorld[]]};  LongCopyREAD: PROC [from: LongClientSource, nwords: CARDINAL, to: LocalDest]= {    ENABLE SUD.InvalidAddress => ERROR InvalidAddress[address];    SUD.LongCopyREAD[from, nwords, to, SUD.GetDefaultWorld[]]};  LongCopyWRITE: PROC [from: LocalSource, nwords: CARDINAL, to: LongClientDest]= {    ENABLE {      SUD.InvalidAddress => ERROR InvalidAddress[address];      SUD.WriteProtected => ERROR WriteProtected[Environment.PageFromLongPointer[address]]};    SUD.LongCopyWRITE[LOOPHOLE[from], nwords, to, SUD.GetDefaultWorld[]]};        Lengthen: PROC [c: ClientSource] RETURNS [LongClientDest] = {    RETURN[SUD.Lengthen[c, SUD.GetDefaultWorld[]]]};  ConfigForFrame: PROC [gf: GFHandle, config: LONG STRING]= {    ENABLE SUD.InvalidFrame => ERROR InvalidFrame[WorldVMOps.GFshort[SUD.GetDefaultWorld[], f]];    SUD.ConfigForFrame[WorldVMOps.GFlong[SUD.GetDefaultWorld[], gf], config, SUD.GetDefaultWorld[]]};  Enumerate: PROC [proc: PROC [GFHandle] RETURNS [BOOLEAN]] RETURNS [gf: GFHandle]= {    Proc: PROC [gf: SUD.GFHandle] RETURNS [BOOLEAN] = { RETURN[proc[WorldVMOps.GFshort[SUD.GetDefaultWorld[], gf]]] };    RETURN[WorldVMOps.GFshort[SUD.GetDefaultWorld[], SUD.Enumerate[Proc, SUD.GetDefaultWorld[]]]]};  Name: PROC [name: LONG STRING, gf: GFHandle]= {    ENABLE SUD.InvalidFrame => ERROR InvalidFrame[WorldVMOps.GFshort[SUD.GetDefaultWorld[], f]];    SUD.Name[name, WorldVMOps.GFlong[SUD.GetDefaultWorld[], gf], SUD.GetDefaultWorld[]]};  Frame: PROC [name: LONG STRING] RETURNS [GFHandle] = {    long: LONG POINTER ¬ SUD.Frame[name, SUD.GetDefaultWorld[]      ! SUD.MultipleFrames => {         frames: ARRAY [0..10) OF GFHandle; 	 FOR i: CARDINAL IN [0..list.LENGTH) DO 	   frames[i] ¬ WorldVMOps.GFshort[SUD.GetDefaultWorld[], list[i]]; ENDLOOP;	 SIGNAL MultipleFrames[DESCRIPTOR[BASE[frames], list.LENGTH]]; RESUME }];     IF long = NIL THEN ERROR NotFound[name] ELSE RETURN[WorldVMOps.GFshort[SUD.GetDefaultWorld[], long]]};  Started: PROC [gf: GFHandle] RETURNS [BOOLEAN]= {    RETURN[SUD.Started[WorldVMOps.GFlong[SUD.GetDefaultWorld[], gf], SUD.GetDefaultWorld[]]]};  Valid: PROC [gf: GFHandle] RETURNS [BOOLEAN]= {    IF gf = NIL THEN RETURN[FALSE];    RETURN[SUD.Valid[WorldVMOps.GFlong[SUD.GetDefaultWorld[], gf], SUD.GetDefaultWorld[]]]};  Copied: PROC [gf: GFHandle] RETURNS [BOOLEAN]= {    RETURN[SUD.Copied[WorldVMOps.GFlong[SUD.GetDefaultWorld[], gf], SUD.GetDefaultWorld[]]]};  Original: PROC [new: GFHandle] RETURNS [old: GFHandle]= {    RETURN[WorldVMOps.GFshort[SUD.GetDefaultWorld[], SUD.Original[WorldVMOps.GFlong[SUD.GetDefaultWorld[], new], SUD.GetDefaultWorld[]]]]};      Handle: TYPE = LONG POINTER TO Object;  Object: PUBLIC --DUD-- TYPE = SUD.Object;      GetAddress: PROC [h: Handle]     RETURNS [base: LONG POINTER, offset: Bits, there: BOOLEAN]= {    [base, offset, there] ¬ SUD.GetAddress[h]};  GetSize: PROC [h: Handle] RETURNS [words: CARDINAL, bits: Bits]= {    [words, bits] ¬ SUD.GetSize[h]};  ReadValue: PROC [h: Handle] = {    SUD.ReadValue[h]};		  -- Printers  AddPrinter: PROC [type: LONG STRING, proc: DebugUsefulDefs.Printer]= {    SUD.AddPrinter[type, proc, SUD.GetDefaultWorld[]]};  RemovePrinter: PROC [type: LONG STRING, proc: DebugUsefulDefs.Printer]= {    SUD.RemovePrinter[type, proc, SUD.GetDefaultWorld[]]};      -- Interpreter  Interpreter: PROC [exp: LONG STRING, results: PROC [Handle]]= {    SUD.Interpreter[exp, results, SUD.GetDefaultWorld[]]};   StringExpToNum: PROC [exp: LONG STRING, radix: CARDINAL]     RETURNS [UNSPECIFIED]= {    ENABLE SUD.InvalidNumber => ERROR InvalidNumber[p];    RETURN[SUD.StringExpToNum[exp, radix, SUD.GetDefaultWorld[]]]};  StringExpToLNum: PROC [exp: LONG STRING, radix: CARDINAL]     RETURNS [LONG UNSPECIFIED]= {    ENABLE SUD.InvalidNumber => ERROR InvalidNumber[p];    RETURN[SUD.StringExpToLNum[exp, radix, SUD.GetDefaultWorld[]]]};  StringExpToOctal: PROC [s: LONG STRING] RETURNS [CARDINAL]= {    ENABLE SUD.InvalidNumber => ERROR InvalidNumber[p];    RETURN[SUD.StringExpToOctal[s, SUD.GetDefaultWorld[]]]};  StringExpToLOctal: PROC [s: LONG STRING] RETURNS [LONG CARDINAL]= {    ENABLE SUD.InvalidNumber => ERROR InvalidNumber[p];    RETURN[SUD.StringExpToLOctal[s, SUD.GetDefaultWorld[]]]};  StringExpToDecimal: PROC [s: LONG STRING] RETURNS [INTEGER]= {    ENABLE SUD.InvalidNumber => ERROR InvalidNumber[p];    RETURN[SUD.StringExpToDecimal[s, SUD.GetDefaultWorld[]]]};  StringExpToLDecimal: PROC [s: LONG STRING] RETURNS [LONG INTEGER]= {    ENABLE SUD.InvalidNumber => ERROR InvalidNumber[p];    RETURN[SUD.StringExpToLDecimal[s, SUD.GetDefaultWorld[]]]};    -- Windows  window: Window.Handle ¬ NIL;  fileSW: Window.Handle ¬ NIL;  Text: Format.StringProc = { SUD.Text[s, clientData, SUD.GetDefaultWorld[]] };	    -- Signals    MultipleFrames: SIGNAL [list: FrameDesc] = CODE;  InvalidAddress: ERROR [address: LONG POINTER] = CODE;  InvalidFrame: ERROR [f: POINTER] = CODE;  InvalidNumber: ERROR [p: LONG POINTER] = CODE;  NotFound: ERROR [s: LONG STRING] = CODE;  WriteProtected: ERROR [page: Environment.PageNumber] = CODE;  UserAborted: SIGNAL = CODE;    UnloadDebugUsefulDefs: --IA-- PROC[] = {    IF windowAgent # Supervisor.nullSubsystem THEN {      Supervisor.RemoveDependency[client: windowAgent, implementor: Event.spare2];      Supervisor.DeleteSubsystem[windowAgent];      windowAgent ¬ Supervisor.nullSubsystem }};    ChangeWindows: Supervisor.AgentProcedure = {    IF event = SUD.setDUD THEN { window ¬ SUD.window; fileSW ¬ SUD.fileSW }};      windowAgent: Supervisor.SubsystemHandle ¬ Supervisor.CreateSubsystem[ChangeWindows];  Supervisor.AddDependency[client: windowAgent, implementor: Event.spare2];  }..
-- File: ITCommandActions.mesa - last edit:-- Litman              15-Apr-87 11:28:04-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.DIRECTORY  AMEvents USING [ApplyProcedure, Screen],  Ascii USING [BS, ControlA, ControlQ, ControlR, ControlV, ControlW, ControlX, CR, DEL, ESC, FF, NUL, SP, TAB],  ComData USING [typeCARDINAL],  CommandList USING [Command, CSRptr, Error],  CommandTab USING [],  CPSwapDefs USING [BreakpointHandlerItem, BreakpointHandlerPtr],  IB USING [GetModule],  IM USING [],  IO USING [Char, EOL, Interpret, InvalidCharacter, InvalidNumber, Line, MakeString, ParseError, Proceed, SubString, SyntaxError, Text, UserAbort, zone],  IP USING [DumpFrameDesc, Error, GetValue, MakeLongType, MultipleFrames],  IQ USING [DoProceed, DumpFrame, FlushFrameCache],  IS USING [DumpChar, Num, Prompt, SetOctal, SetProcess],  IT USING [CommandRec, ControlLink, Foo, FooProc, GFHandle, Handle, Number, NumberType, OneProc, PromptProc, StringArray, Strings, TermProc, TwoProc, Words, ZeroProc],  PrincOps USING [ControlLink],  Runtime USING [ControlLink, GetTableBase, GlobalFrame],  SDDefs USING [sBreakTrap, SD],  String USING [ExpandString, InvalidNumber, Overflow, StringToLongNumber, StringToNumber, SubStringDescriptor],  TTY USING [CharStatus, GetChar, GetEcho, Handle, LineOverflow, PutBackChar, PutChar, RemoveCharacter, RemoveCharacters, Rubout, SetEcho],  WorldVMOps USING [CopyRead, CopyWrite, GetESV, GFshort, Long];ITCommandActions: PROGRAM  IMPORTS AMEvents, com: ComData, CommandTab, IB, IO, IP, IQ, IS, Runtime, String, TTY, WorldVMOps   EXPORTS IM, IO, IQ, IS = {  OPEN IT;    stringArray: StringArray ¬ ALL[NIL];  strings: PUBLIC Strings ¬ DESCRIPTOR[stringArray];   base: CommandList.CSRptr = Runtime.GetTableBase[Runtime.GlobalFrame[CommandTab]];    WriteCommand: PUBLIC PROCEDURE [h: Handle, code: CommandList.Command] = {    ss: String.SubStringDescriptor;    IF code = null THEN RETURN;    ss ¬ [      base: @base[base.stringOffset],      offset: base.CommandStrings[code].offset,      length: base.CommandStrings[code].length];    IO.SubString[h, @ss]};  WriteError: PUBLIC PROCEDURE [h: Handle, error: CommandList.Error, eol: BOOLEAN ¬ TRUE] = {    ss: String.SubStringDescriptor ¬ [      base: @base[base.stringOffset],      offset: base.ErrorMessages[error].offset,      length: base.ErrorMessages[error].length];    IF eol THEN IO.EOL[h];    IO.SubString[h, @ss];    IF eol THEN IO.EOL[h]};  Confirm: PUBLIC PROCEDURE [h: Handle, code: CommandList.Command, call: ZeroProc] = {    WriteCommand[h, code];    WriteCommand[h, confirm];    IF IO.UserAbort[h] THEN WriteError[h, aborted]    ELSE       SELECT TTY.GetChar[h.tty] FROM	'y, 'Y, Ascii.CR => {IO.Char[h, Ascii.CR]; call[h]};	ENDCASE => WriteError[h, XXX];    IS.Prompt[h: h]};      GetComment: PUBLIC PROC [h: Handle] = {    GetLine[h, [prompt: comment, sId: comment, colon: FALSE], Comment, comment]};      Comment: PUBLIC PROC [h: Handle, s: LONG STRING] = {};  ModuleBreak: PUBLIC PROC [h: Handle, proc: TwoProc, prompt: CommandList.Command] = {    WriteCommand[h, prompt];    h.call2 ¬ proc;    GetText[h, [sId: module], GotBreakParam, IsTerm]};      GotBreakParam: PROC [h: Handle, s: LONG STRING] = {    h.call2[h, s, NIL]};  GetLine: PUBLIC PROC [h: Handle, com: CommandRec, call: OneProc, prompt: CommandList.Command ¬ null] = {    WriteCommand[h, prompt];    GetText[h, com, call, IsCR]};  GetString: PUBLIC PROC [h: Handle, com: CommandRec, call: OneProc, prompt: CommandList.Command ¬ null] = {    WriteCommand[h, prompt];    GetText[h, com, call, IF com.atom THEN IsAtom ELSE IsCR]};  GetText: PUBLIC PROCEDURE [h: Handle, com: CommandRec, call: OneProc, term: TermProc] = {    CollectString: PROC[c: CHARACTER] RETURNS[status: TTY.CharStatus] = {      SELECT c FROM	Ascii.ESC => IF str.length = 0 THEN { str.length ¬ saveLength; IO.Text[str, h]; status ¬ ignore };	Ascii.DEL => {WriteError[h, XXX]; status ¬ stop};	Ascii.NUL => status ¬ stop;	Ascii.BS, Ascii.ControlW, Ascii.ControlX => status ¬ ok;	ENDCASE => IF term[h, c] THEN status ¬ stop ELSE status ¬ ok};    saveLength: CARDINAL;    str: LONG STRING;    IF (str ¬ strings[(h.currentId ¬ com.sId)]) = NIL THEN {strings[h.currentId] ¬ str ¬ IO.MakeString[h, 10]};    WriteCommand[h, com.prompt];    IF com.colon THEN IO.Text[": "L, h];    saveLength ¬ str.length;    str.length ¬ 0;    [] ¬ TTY.SetEcho[h.tty, plain];    SELECT       GetEditedString[h.tty, str, CollectString	! TTY.LineOverflow => {	  String.ExpandString[@str, 10, IO.zone];	  ns ¬ strings[h.currentId] ¬ str;	  RESUME}] FROM      Ascii.DEL => IF call = GotBoth THEN PopPrompt[h];      Ascii.NUL => { TTY.PutBackChar[h.tty, Ascii.NUL] };      ENDCASE => call[h, str];    [] ¬ TTY.SetEcho[h.tty, none];    IF call # GotBoth THEN IS.Prompt[h] --extra prompt otherwise--};-- TTYImpl is a piece of shit.    GetEditedString: PUBLIC PROCEDURE [h: TTY.Handle, s: LONG STRING, t: PROCEDURE [c: CHARACTER] RETURNS [status: TTY.CharStatus]]    RETURNS [c: CHARACTER] = {    OPEN TTY;    WeirdEcho: PROCEDURE [c: CHARACTER] = {      SELECT GetEcho[h] FROM        none => NULL;        plain => PutChar[h, c];        stars => PutChar[h, '*]        ENDCASE};    WeirdErase: PROCEDURE [c: CHARACTER] = {      SELECT GetEcho[h] FROM        none => NULL;        plain =>          RemoveCharacters[h,            SELECT c FROM              Ascii.CR, Ascii.BS, Ascii.FF => 0,	      Ascii.TAB => 1,                IN [0C..Ascii.SP) => 2,              IN [Ascii.SP..377C -- '~ --] => 1,              ENDCASE => 0];        stars => RemoveCharacter[h, 1]        ENDCASE};    WeirdPutString: PROCEDURE = INLINE {      FOR i: CARDINAL IN [0..s.length) DO WeirdEcho[s[i]] ENDLOOP};    KillString: PROCEDURE = {      FOR i: CARDINAL DECREASING IN [0..s.length) DO WeirdErase[s[i]] ENDLOOP;      s.length ¬ 0};    WeirdPutString[];  -- show whatever default string is passed in, if any    DO      SELECT t[c ¬ GetChar[h]] FROM        stop => RETURN;        ignore => LOOP;        ok =>          SELECT c FROM            Ascii.DEL => SIGNAL Rubout;            Ascii.ControlA, Ascii.BS =>  -- backspace              IF s.length > 0 THEN WeirdErase[s[s.length ¬ s.length - 1]];            Ascii.ControlW, Ascii.ControlQ => {  -- backword              -- text to be backed up is of the form ...<li><v><ti>, the <v> and <ti>              -- are to be removed.              state: {ti, v, li} ¬ ti;              FOR i: CARDINAL DECREASING IN [0..s.length) DO                SELECT s[i] FROM                  IN ['A..'Z], IN ['a..'z], IN ['0..'9] =>                    IF state = ti THEN state ¬ v;                  ENDCASE => IF state = v THEN state ¬ li;                IF state = li THEN GO TO Done;                WeirdErase[s[i]];                REPEAT Done => s.length ¬ i + 1; FINISHED => s.length ¬ 0;                ENDLOOP};            Ascii.ControlX => KillString[];            Ascii.ControlR => {  -- refresh--              IF GetEcho[h] # none THEN {PutChar[h, Ascii.CR]; WeirdPutString[]};              LOOP};            Ascii.ControlV => {  -- dont parse next char              WHILE s.length >= s.maxlength DO s ¬ SIGNAL LineOverflow[s] ENDLOOP;              WeirdEcho[s[s.length] ¬ c ¬ GetChar[h]];              s.length ¬ s.length + 1};            ENDCASE => {              WHILE s.length >= s.maxlength DO s ¬ SIGNAL LineOverflow[s] ENDLOOP;              WeirdEcho[s[s.length] ¬ c];              s.length ¬ s.length + 1};        ENDCASE;      ENDLOOP};      GetTwoStrings: PUBLIC PROC [h: Handle, com1, com2: CommandRec, proc: TwoProc, prompt: CommandList.Command ¬ null] = {    WriteCommand[h, prompt];     h.call2 ¬ proc;    h.com2 ¬ com2;    GetText[h, com1, GotOne, IF com1.atom THEN IsAtom ELSE IsCR]};      GotOne: PROC [h: Handle, s: LONG STRING] = {    h.s1 ¬ s;    PushPrompt[h, NullPrompt];    GetText[h, h.com2, GotBoth, IF h.com2.atom THEN IsAtom ELSE IsCR]};  GotBoth: PROC [h: Handle, s2: LONG STRING] = {    ENABLE UNWIND => PopPrompt[h];    h.call2[h, h.s1, s2];     PopPrompt[h]};  NullPrompt: PromptProc = {};    PushPrompt: PUBLIC PROC[h: Handle, proc: IT.PromptProc] = {    IF h.prevPrevPrompt # NIL THEN ERROR;    h.prevPrevPrompt ¬ h.prevPrompt;    h.prevPrompt ¬ h.prompt;    h.prompt ¬ proc};      PopPrompt: PUBLIC PROC[h: Handle] = {    h.prompt ¬ h.prevPrompt;    h.prevPrompt ¬ h.prevPrevPrompt;    h.prevPrevPrompt ¬ NIL};    Execute: PUBLIC PROC [h: Handle, code: CommandList.Command, call: ZeroProc] = {    WriteCommand[h, code];    call[h];    IS.Prompt[h]};  IsAtom: PUBLIC PROCEDURE [h: Handle, c: CHARACTER] RETURNS [BOOLEAN] = {    RETURN[c = Ascii.SP OR c = Ascii.CR] };        IsCR: PUBLIC PROCEDURE [h: Handle, c: CHARACTER] RETURNS [BOOLEAN] = {    RETURN[c = Ascii.CR] };  IsTerm: PROC [h: Handle, c: CHARACTER] RETURNS [BOOLEAN] = {    RETURN [(h.cr ¬ c = Ascii.CR) OR c = Ascii.SP] };  -- Utilities    Numeric: PUBLIC PROC [h: Handle, s: LONG STRING] RETURNS [BOOLEAN] = {    IF s = NIL THEN RETURN[FALSE];    [] ¬ String.StringToNumber[s ! String.InvalidNumber, String.Overflow => GOTO TryHex];    RETURN[TRUE];    EXITS TryHex =>       FOR i: CARDINAL IN [0..s.length-1) DO        SELECT s[i] FROM	  IN ['0..'9] => LOOP;	  IN ['A..'F] => LOOP;	  IN ['a..'f] => LOOP;	  ENDCASE => RETURN[FALSE];	REPEAT FINISHED => RETURN[s[s.length-1] = 'h OR s[s.length-1] = 'H];	ENDLOOP};  StringExpToNum: PUBLIC PROC [h: Handle, exp: LONG STRING, radix: CARDINAL] RETURNS [u: UNSPECIFIED] = {    RETURN[String.StringToNumber[exp, radix ! String.InvalidNumber, String.Overflow => GOTO Else]];    EXITS Else => {      errors: BOOLEAN ¬ TRUE;      Result: FooProc = { errors ¬ FALSE; u ¬ ProcessNum[h, f, one].n.u };      IO.Interpret[h, exp, Result, com.typeCARDINAL 	! IO.ParseError, IO.SyntaxError, IO.InvalidCharacter => ERROR IO.InvalidNumber[NIL]];      IF errors THEN IO.InvalidNumber[NIL] }};  StringExpToLNum: PUBLIC PROC [h: Handle, exp: LONG STRING, radix: CARDINAL] RETURNS [u: LONG UNSPECIFIED] = {    RETURN[String.StringToLongNumber[exp, radix ! String.InvalidNumber, String.Overflow => GOTO Else]];    EXITS Else => {      errors: BOOLEAN ¬ TRUE;      Result: FooProc = { errors ¬ FALSE; u ¬ ProcessNum[h, f, two].n.lu };      IO.Interpret[h, exp, Result, IP.MakeLongType[h, com.typeCARDINAL]	! IO.ParseError, IO.SyntaxError, IO.InvalidCharacter => ERROR IO.InvalidNumber[NIL]];      IF errors THEN IO.InvalidNumber[NIL] }};  StringExpToOctal: PUBLIC PROC [h: Handle, s: LONG STRING] RETURNS [CARDINAL] = {    RETURN[StringExpToNum[h, s, 8]] };  StringExpToLOctal: PUBLIC PROC [h: Handle, s: LONG STRING] RETURNS [LONG CARDINAL] = {    RETURN[StringExpToLNum[h, s, 8]] };  StringExpToDecimal: PUBLIC PROC [h: Handle, s: LONG STRING] RETURNS [INTEGER] = {    RETURN[StringExpToNum[h, s, 10]] };  StringExpToLDecimal: PUBLIC PROC [h: Handle, s: LONG STRING] RETURNS [LONG INTEGER] = {    RETURN[StringExpToLNum[h, s, 10]] };  ProcessNum: PROC [h: Handle, f: Foo, size: IT.NumberType] RETURNS [n: IT.Number] = {    i: IT.NumberType;    p: LONG POINTER TO Words;    IF f.bits # 0 OR f.addr.offset # 0 THEN GOTO invalid;    n.type ¬ VAL[f.words];    SELECT n.type FROM      size => NULL;      one => IF size # two THEN GOTO invalid;      two => IF size = one THEN {IP.Error[h, sizeMismatch]; GOTO invalid};      ENDCASE => GOTO invalid;    IP.GetValue[h, f];    p ¬ f.addr.base;    FOR i IN [nogood..n.type) DO n.w[i] ¬ p[i]; ENDLOOP;    IF n.type # size THEN n.w[one] ¬ 0;    EXITS invalid => SIGNAL IO.InvalidNumber[f] };  CallInterpreter: PUBLIC PROC [h: Handle] = {     GetLine[h, [sId:di, colon:FALSE], IntString, di]};  IntString: PUBLIC PROC [h: Handle, s: LONG STRING] = {    IO.EOL[h];    IO.Interpret[h, s !      IO.InvalidCharacter => {	IO.Text[" !"L, h];	IS.DumpChar[h, s[index]];	IO.Line[h, " is an invalid character"L];	CONTINUE};      IO.SyntaxError => {	IO.Text[" ! Syntax error at ["L, h];	IS.Num[h, errorLoc, [card[]]];	IO.Line[h, "]."L];	CONTINUE};      IO.ParseError => {	IO.Text[" ! Parse error at ["L, h];	IS.Num[h, errorLoc, [card[]]];	IO.Line[h, "]."L];	CONTINUE}];    IO.EOL[h]};    OtherPrompt: PROC[h: Handle] = {    IO.Text["  >"L, h]};  DisplayFrame: PUBLIC PROC [h: Handle, s: LONG STRING] = {    ENABLE IP.MultipleFrames => {IP.DumpFrameDesc[h, s, list]; CONTINUE};    gf: GFHandle;    IF (gf ¬ IB.GetModule[h, s]) # NIL THEN IQ.DumpFrame[h, gf] };  SetOctalContext: PUBLIC PROC [h: Handle, s: LONG STRING] = {    IS.SetOctal[h, LOOPHOLE[StringExpToLDecimal[h, s]]] };  SetProcessContext: PUBLIC PROC [h: Handle, s: LONG STRING] = {    IS.SetProcess[h, LOOPHOLE[StringExpToLDecimal[h, s]]] };  StartUser: PUBLIC PROC [h: Handle, gf: LONG STRING] = {    ENABLE IP.MultipleFrames => {IP.DumpFrameDesc[h, gf, list]; CONTINUE};    frame: GFHandle;    IF ~WorldVMOps.GetESV[h.world].swapData.mayCallDebuggee THEN {IO.Line[h, " not permitted in worry mode!"L]; RETURN};    IF (frame ¬ IB.GetModule[h, gf]) # NIL THEN {      cl: PrincOps.ControlLink = [frame[WorldVMOps.GFshort[h.world, frame]]];      AMEvents.ApplyProcedure[world: h.world, control: LOOPHOLE[cl], args: NIL, result: NIL];      IQ.FlushFrameCache[h]}};        UserScreen: PUBLIC PROC[h: Handle] = {    IQ.DoProceed[h ! IO.Proceed => {AMEvents.Screen[h.world]; CONTINUE}]};  SearchMode: PUBLIC PROC[h: Handle] = { h.search ¬ ~h.search };  DebuggingMode: PUBLIC PROC[h: Handle] = { h.debugging ¬ ~h.debugging };  WorryMode: PUBLIC PROC[h: Handle] = {    temp: ControlLink;     item: CPSwapDefs.BreakpointHandlerItem;    WorldVMOps.CopyRead[world: h.world, from: WorldVMOps.Long[h.world, @SDDefs.SD[SDDefs.sBreakTrap]], to: @temp, nwords: SIZE[ControlLink]];    FOR bh: CPSwapDefs.BreakpointHandlerPtr ¬ WorldVMOps.GetESV[h.world].breakpointHandlers, item.next UNTIL bh = NIL DO      WorldVMOps.CopyRead[world: h.world, from: bh, to: @item, nwords: SIZE[CPSwapDefs.BreakpointHandlerItem]];      IF item.handler = LOOPHOLE[temp] THEN {        IF h.worryBreaks AND item.type = noAlloc THEN EXIT;	IF ~h.worryBreaks AND item.type = standard THEN EXIT;	IO.Text[SELECT item.type FROM	  standard => " standard"L,	  noAlloc => " worry"L,	  countTool => " count tool"L,	  topoGiggio => " TopoGiggio"L,	  ENDCASE => " unknown"L, h];	GOTO badHandler };      REPEAT FINISHED => {IO.Text[" unknown"L, h]; GOTO badHandler}      ENDLOOP;    FOR bh: CPSwapDefs.BreakpointHandlerPtr ¬ WorldVMOps.GetESV[h.world].breakpointHandlers, item.next UNTIL bh = NIL DO      WorldVMOps.CopyRead[world: h.world, from: bh, to: @item, nwords: SIZE[CPSwapDefs.BreakpointHandlerItem]];      IF item.type = (IF h.worryBreaks THEN standard ELSE noAlloc) THEN {        WorldVMOps.CopyWrite[world: h.world, to: WorldVMOps.Long[h.world, @SDDefs.SD[SDDefs.sBreakTrap]], from: @item.handler, nwords: SIZE[ControlLink]];	h.worryBreaks ¬ ~h.worryBreaks;	EXIT };      REPEAT FINISHED => {	IF h.worryBreaks THEN IO.Text[" worry"L, h] ELSE IO.Text[" standard"L, h];	IO.Line[h, " break handler not found!"L] };      ENDLOOP;    EXITS badHandler => IO.Line[h, " break handler currently installed!"L]; };        }.
-- Copyright (C) 1986  by Xerox Corporation. All rights reserved. -- AMEvents.mesaDIRECTORYAMModel,AMProcess,CPSwapDefs,WorldVM,WorldVMOps;AMEvents: DEFINITIONS = {  World: TYPE = WorldVM.World;  LFHandle: TYPE = WorldVMOps.LongLocalFrameHandle;  GFHandle: TYPE = WorldVMOps.LongGlobalFrameHandle;  BytePC: TYPE = WorldVMOps.BytePC;  ControlLink: TYPE = WorldVMOps.ControlLink;  PrefixHandle: TYPE = WorldVMOps.PrefixHandle;  SignalDesc: TYPE = WorldVMOps.SignalDesc;  Process: TYPE = WorldVMOps.Process;  NullProcess: Process = WorldVMOps.NullProcess;    EventProc: TYPE = PROC[data: LONG POINTER, event: Event]     RETURNS[outcome: Outcome];    «An EventProc is called whenever something interesting happens in the client world.  Returning from the event allows the client process to proceed, as specified by outcome.type:quit => raise ABORTED in victim processproceed => depending on the event.type:breakpoints => execute saved byte and continue (result=NIL)explicit call => return from the call (result=NIL)signals => RESUME[result]retry => redo the call that caused specified local frame, with given arguments.returnFrom => return control from specified local frame, with given result.»          Event: TYPE = LONG POINTER TO EventRec;  Eventuality: TYPE = {break, call, signal, fault, unknown};  EventRec: TYPE = RECORD[    world: World ¬ NIL, -- world requesting the debugger    session: INT ¬ 0, -- monotonic, incremented at StopEvents or when world boots    process: Process ¬ NullProcess, -- process requesting the debugger    frame: LFHandle ¬ NIL, -- local frame requesting the debugger    worry: BOOLEAN ¬ FALSE, -- TRUE => don't try to call client procedures --    detail: SELECT type: Eventuality FROM      break => [id: BreakID, clientData: LONG POINTER],      call => [msg: LONG STRING],      signal => [	  signalError: CPSwapDefs.SignalError, -- {signal(0), error(1)}	  signalArgs: LFHandle,	  signal: SignalDesc],      fault => [type: CPSwapDefs.StorageFaultType, faultedProcess: Process],      unknown => [why: LONG STRING], -- client bug; psbi and frame are valid.      ENDCASE];      Outcome: TYPE = RECORD[    SELECT type: * FROM    proceed => [result: ArgsOrResults],    quit => NULL,    kill => NULL,    retry => [frame: LFHandle, result: ArgsOrResults],    returnFrom => [frame: LFHandle, result: ArgsOrResults],    ENDCASE] ¬ [proceed[NIL]];      ArgsOrResults: TYPE = LONG POINTER TO WordSeq;  WordSeq: TYPE = RECORD [seq: SEQUENCE size: CARDINAL OF WORD];    GetEvents: PROC[world: World, data: LONG POINTER, proc: EventProc];  StopEvents: PROC[world: World];    ProvokeProcessEvent: PROC[p: AMProcess.Process,     frame: LFHandle, msg: LONG STRING] RETURNS[outcome: Outcome];    «"Debugging" is raised in a process when it is about to be suspended   for an event. "Debugged" is raised in a process when the EventProc   returns. NOTE: These are raised as "informational" signals: clients may   catch them, but must not jump out of their catch-phrase.  The signaller   will resume them.»    Debugging: --INFORMATIONAL-- SIGNAL;  Debugged: --INFORMATIONAL-- SIGNAL;      «registered "BootedNotifiers" are called at end of a client session.  This occurs when StopEvents is called for that world, or when AMEventsImpl notices that the debuggee has been booted.  All events for which "session" is <= the given "session" should return (their result will be ignored).  At end of session, all outstanding calls of "Apply" for that debuggee are terminated by raising the "EndSession" signal.»    BootedNotifier: TYPE = PROC[world: WorldVM.World, session: INT,     clientData: LONG POINTER];    -- worldName = NIL causes proc to be called for all booted events    RegisterBootedNotifier: PROC[proc: BootedNotifier, world: WorldVM.World ¬ NIL,    clientData: LONG POINTER ¬ NIL];    -- clientData = NIL implies wildcard match on clientData. ditto for world.     UnRegisterBootedNotifier: PROC[proc: BootedNotifier, world: WorldVM.World ¬ NIL,    clientData: LONG POINTER ¬ NIL];    «Will call same world debugger for future events.»    HandleLocalEvents: PROC [signals, breaks, faults, calldebug: BOOLEAN];    «Cause a local "call" event.  If someone is handling local events,   this will debug without a world-swap, otherwise it will world-swap. »    CallDebugger: PROC[msg: LONG STRING];    -- Breakpoints --  BreakID: TYPE = LONG POINTER TO BreakRec;  BreakRec: TYPE;    DuplicateBreakpoint: ERROR [id: BreakID];  IllegalBreakPoint: ERROR;    BreakAt: PROC[world: World, section: AMModel.Section,     clientData: LONG POINTER] RETURNS[id: BreakID];    -- beginning of section (statement or procedure).    BreakAfter: PROC[world: World, section: AMModel.Section,     clientData: LONG POINTER] RETURNS[id: BreakID];    -- end of section (procedure only).    FrameBreak: PROC[world: World, gf: GFHandle,     pc: BytePC, clientData: LONG POINTER] RETURNS[id: BreakID];    SetBreak: PROC[world: World, cb: PrefixHandle, pc: CARDINAL,     clientData: LONG POINTER] RETURNS[id: BreakID];     ClearBreak: PROC[id: BreakID];    -- Enumerator starts and ends with NIL.  NextBreak: PROC[world: World, prev: BreakID]     RETURNS[id: BreakID, clientData: LONG POINTER];        -- Procedure invokation --    ApplyProcedure: PROC[world: WorldVM.World, control: ControlLink,    args: ArgsOrResults, result: ArgsOrResults];    ApplySignal: PROC[world: WorldVM.World, signal: SignalDesc,     args: ArgsOrResults, result: ArgsOrResults];    BadControlLink: ERROR; -- "control" had wrong type class  BadArgType: ERROR; -- type of "arg" # range of type of "control"  BadResStack: ERROR; -- result stack size was incorrect.    -- debuggee was booted (or StopEvents was called) instead of returning.  EndSession: ERROR;       Kill: PROC[world: WorldVM.World];  -- TemporaryBooting.BootButton    Screen: PROC[world: WorldVM.World];    }..
-- File: ITFlowSW.mesa - last edit:-- Litman              17-Apr-87 16:37:44-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.DIRECTORY  Alloc USING [Handle, Overflow],  AMLoadstate USING [AcquireBcd, Error, Index],  AMModel USING [Context, ContextName, GFHandle],  AMUseful,  Ascii USING [ControlA, SP],  Atom USING [ATOM, MakeAtom],  BcdDefs USING [BCD, CTIndex, CTNull, FTIndex, FTSelf, FTNull, MTIndex, MTNull, Namee],  BcdOpsExtras USING [FTBaseFromBcd, CTBaseFromBcd, MthFromMti],  Context USING [Find],  Environment USING [Block],  Exec USING [MatchPattern],  Heap USING [systemZone],  II USING [],  IJ USING [CreateNames, DeleteNames, DisplayLocalsF, DisplayLocalsGF, Names],  IL USING [],  Inline USING [LongCOPY, LowHalf],  IO USING [EOL, FreeString, IntString, Line, MakeString, MyContextType, options, UserAborted, zone],  IP USING [Clobbered, GF, NoPrevious, Previous],  IQ USING [GFrameMdi, InvalidFrame, LocalDump],  IS USING [DumpPSB, Frame, NextPsb, Umbrella],  IT USING [GFHandle, Handle, HTIndex, InitZoom, LFHandle, LG, MaxIdString, MaxModuleString, PsbItem],  ITExtras USING [OptionsSpare],  Selection USING [Convert],  Stream USING [Block, Handle, PutByteProcedure, PutProcedure, PutWordProcedure],  String USING [AppendChar, AppendCharAndGrow, AppendString, AppendSubString, ExpandString, FreeString, SubStringDescriptor],  SymbolOps USING [Handle, SubStringForHash],  Symbols USING [HTIndex, HTNull],  SymbolTable USING [Handle, Missing],  TextSource USING [AsciiTextSearch, Handle, Position, ReadText, SearchFailed],  TextSW USING [Create, ForceOutput, GetSelection, GetSource, InsertString, IsIt, Position, PositionFromPlace, PositionIsVisible, ReplaceText, SetPosition, SetSelection, SetSource],  Time USING [Append, Unpack],  TIP USING [First, NotifyProc, Rest, Results, SetNotifyProc],  Tool USING [AddThisSW],  ToolWindow USING [CreateSubwindow, Handle, WindowForSubwindow],  TTYImpl USING [Handle],  Window USING [Handle, Place],  WindowFont USING [FontHeight],  WorldVMOps USING [LFlong, GetLoadstate, ProcessLong],  ZoomSource USING [Buffer, BufferForPosition, Close, Create, Destroy, EnumerateBuffers, Open, OpenProc];ITFlowSW: MONITOR   IMPORTS Alloc, AMLoadstate, AMModel, AMUseful, Atom, BcdOpsExtras, Context, Exec, Heap, IJ, Inline, IO, IP, IQ, IS, Selection, String, SymbolOps, SymbolTable, TextSource, TextSW, Time, TIP, Tool, ToolWindow, WindowFont, WorldVMOps, ZoomSource  EXPORTS II, IL  SHARES TTYImpl = {    varCache: VarCacheHandle ¬ IO.zone.NEW[VarCache[20]];  VarCacheHandle: TYPE = LONG POINTER TO VarCache;  VarCache: TYPE = RECORD [    size: CARDINAL ¬ 0,     seq: SEQUENCE max: CARDINAL OF RECORD[hash: Symbols.HTIndex, s: LONG STRING]];    OldTipInterpreter: TIP.NotifyProc ¬ NIL;   doPrimary: Atom.ATOM ¬ Atom.MakeAtom["DoPrimary"];  next: Atom.ATOM ¬ Atom.MakeAtom["ReplaceNextField"];  ZoomBuffer: TYPE = LONG POINTER TO ZoomBufferObject;  ZoomBufferObject: TYPE = RECORD[    line: LONG STRING ¬ NIL, -- must be first    zoomed: BOOLEAN ¬ FALSE,    dated: BOOLEAN ¬ FALSE,    marked: BOOLEAN ¬ FALSE,    h: IT.Handle ¬ NIL,    info: SELECT tag:* FROM      process => [p: IT.PsbItem],      frame => [f: IT.LFHandle],      variable => [f: IT.LFHandle, hash: Symbols.HTIndex],      config => [index: AMLoadstate.Index, cti: BcdDefs.CTIndex],      module => [gf: IT.GFHandle, level: CARDINAL],      gvariable => [gf: IT.GFHandle, hash: Symbols.HTIndex],      ENDCASE];        MeToHim: PROC[z: ZoomBuffer] RETURNS[ZoomSource.Buffer] = INLINE { RETURN[LOOPHOLE[z]]};  HimToMe: PROC[z: ZoomSource.Buffer] RETURNS[ZoomBuffer] = INLINE { RETURN[LOOPHOLE[z]]};      NoVariables: Symbols.HTIndex = LAST[Symbols.HTIndex];  FirstVariable: Symbols.HTIndex = NoVariables-1;      ZoomType: TYPE = {flow, config};    GetITSignal: SIGNAL RETURNS[IT.Handle, ZoomType] = CODE;    GetH: PROC[sw: Window.Handle] RETURNS[h: IT.Handle] = {    RETURN[Context.Find[IO.MyContextType, ToolWindow.WindowForSubwindow[sw]]]};    MakeFlowSW: PUBLIC PROC[h: IT.Handle] = {    ENABLE GetITSignal => RESUME[h, flow];    IF h.flowZoom # NIL THEN ZoomSource.Destroy[h.flowZoom];    [h.flowZoom] ¬ MakeZoomSW[h, 12, @h.flowSW, @h.flowInit]};         MakeConfigSW: PUBLIC PROC[h: IT.Handle] = {    ENABLE GetITSignal => RESUME[h, config];    IF h.configZoom # NIL THEN ZoomSource.Destroy[h.configZoom];    [h.configZoom] ¬ MakeZoomSW[h, 8, @h.configSW, @h.configInit]};      MakeZoomSW: PUBLIC PROC[it: IT.Handle, lines: CARDINAL, swPointer: LONG POINTER TO Window.Handle, init: LONG POINTER TO IT.InitZoom] RETURNS[zoom: TextSource.Handle] = {    sw: Window.Handle ¬ swPointer­;    zoom ¬ ZoomSource.Create[first: First, next: Next, close: Close, destroy: Destroy, zone: IO.zone];    IF sw = NIL THEN {      sw ¬ ToolWindow.CreateSubwindow[parent: it.tool];      TextSW.Create[sw: sw, source: zoom, allowTypeIn: FALSE];      Tool.AddThisSW[window: it.tool, sw: sw, nextSW: it.fileSW, h: lines*WindowFont.FontHeight[]];      OldTipInterpreter ¬ TIP.SetNotifyProc[window: sw, notify: TipInterpreter];      swPointer­ ¬ sw }    ELSE TextSW.SetSource[sw, zoom];    init­ ¬ [firstOpening: LOOPHOLE[IO.options.spare, ITExtras.OptionsSpare].autoOpen.b, rememberPos: 0];    ZoomSource.Open[source: zoom, sw: sw, pos: 0];     WHILE (init.firstOpening) DO       ZoomSource.Open[source: zoom, sw: sw, pos: init.rememberPos]; -- init gets modified      ENDLOOP;    TextSW.SetPosition[sw, init.rememberPos];    TextSW.ForceOutput[sw] };       First: ZoomSource.OpenProc = {    myPrev: ZoomBuffer = HimToMe[prev];    myNext: ZoomBuffer;    line: LONG STRING;    «IF ~ProcessesBoolean[h].b AND ~ConfigsBoolean[h].b THEN RETURN[NIL];»    IF myPrev = NIL THEN { -- first opening.       h: IT.Handle;      zoomType: ZoomType;      [h, zoomType] ¬ SIGNAL GetITSignal[];      SELECT zoomType FROM        flow => {	  firstPsb: IT.PsbItem ¬ IS.NextPsb[h, h.lastPSB];	  line ¬ ProcessLine[h, firstPsb];	  myNext ¬ IO.zone.NEW[ZoomBufferObject ¬ [line: line, zoomed: FALSE, h: h, info: process[firstPsb]]]};	config => {	  myNext ¬ ZoomBufferFromNamee[h: h, namee: [config[FIRST[BcdDefs.CTIndex]]], index: FIRST[AMLoadstate.Index], level: 0];	  IF h.configInit.firstOpening THEN AutoOpenConfig[myNext, position]};	ENDCASE}    ELSE {      WITH mine: myPrev SELECT FROM        process => {	  firstFrame: IT.LFHandle = IS.Frame[mine.h, mine.p];	  line ¬ FrameLine[mine.h, firstFrame];	  myNext ¬ IO.zone.NEW[ZoomBufferObject ¬ [line: line, zoomed: FALSE, h: mine.h, info: frame[firstFrame]]];	  mine.h.pContext ¬ mine.p.p;	  mine.h.flowInit.firstOpening ¬ FALSE };	frame => {	  -- get local variables	  hash: Symbols.HTIndex;	  --TextSW.RemoveAllSecondarySelections[mine.h.flowSW];	  [line, hash] ¬ VariableLine[mine.h, mine.f, FirstVariable, local];	  myNext ¬ IO.zone.NEW[ZoomBufferObject ¬ [line: line, zoomed: FALSE, h: mine.h, info: variable[mine.f, hash]]];	  mine.h.lContext ¬ mine.f};	variable => {RETURN[NIL] --IF mine.hash = NoVariables--};	config => { 	  sonNamee: BcdDefs.Namee;	  level: CARDINAL;	  --TextSW.RemoveAllSecondarySelections[mine.h.configSW];	  [sonNamee, level] ¬ AMUseful.FirstSonConfig[mine.h.world, mine.index, mine.cti];	  myNext ¬ ZoomBufferFromNamee[mine.h, sonNamee, mine.index, level];	  IF mine.h.configInit.firstOpening THEN AutoOpenConfig[myNext, position]};	module => {	  -- get global variables	  hash: Symbols.HTIndex;	  --TextSW.RemoveAllSecondarySelections[mine.h.configSW];	  [line, hash] ¬ VariableLine[mine.h, mine.gf, FirstVariable, global, mine.level+1];	  myNext ¬ IO.zone.NEW[ZoomBufferObject ¬ [line: line, zoomed: FALSE, h: mine.h, info: gvariable[mine.gf, hash]]];	  mine.h.gContext ¬ mine.gf};	gvariable => {RETURN[NIL] --IF mine.hash = NoVariables--};        ENDCASE;      myPrev.zoomed ¬ TRUE};    next ¬ MeToHim[myNext]};      Next: ZoomSource.OpenProc = {    myPrev: ZoomBuffer = HimToMe[prev];    myNext: ZoomBuffer;    line: LONG STRING;    WITH mine: myPrev SELECT FROM      process => {        nextPsb: IT.PsbItem;	line: LONG STRING;        IF mine.p.p = mine.h.lastPSB THEN RETURN[NIL];	nextPsb ¬ IS.NextPsb[mine.h, mine.p.p];	line ¬ ProcessLine[mine.h, nextPsb ! IO.UserAborted => GOTO Aborted];	myNext ¬ IO.zone.NEW[ZoomBufferObject ¬ [line: line, zoomed: FALSE, h: mine.h, info: process[nextPsb]]];	IF mine.h.flowInit.firstOpening AND nextPsb.p = WorldVMOps.ProcessLong[mine.h.swapData.process] THEN mine.h.flowInit.rememberPos ¬ position;	EXITS Aborted => RETURN[NIL] };      frame => {        nextFrame: IT.LFHandle = IP.Previous[mine.h, mine.f ! IP.NoPrevious, IP.Clobbered, IQ.InvalidFrame => GOTO last];        line: LONG STRING ¬ FrameLine[mine.h, nextFrame];	myNext ¬ IO.zone.NEW[ZoomBufferObject ¬ [line: line, zoomed: FALSE, h: mine.h, info: frame[nextFrame]]];        EXITS last => RETURN[NIL]};      variable => {	next: Symbols.HTIndex;	[line, next] ¬ VariableLine[mine.h, mine.f, mine.hash, local];	IF next = NoVariables THEN RETURN[NIL];	myNext ¬ IO.zone.NEW[ZoomBufferObject ¬ [line: line, zoomed: FALSE, h: mine.h, info: variable[mine.f, next]]]};      config => {        nextNamee: BcdDefs.Namee;	nextIndex: AMLoadstate.Index;	level: CARDINAL;	[nextIndex, nextNamee, level] ¬ AMUseful.Sibling[mine.h.world, mine.index, [config[mine.cti]]];	myNext ¬ ZoomBufferFromNamee[mine.h, nextNamee, nextIndex, level];	IF mine.h.configInit.firstOpening THEN AutoOpenConfig[myNext, position]};      module => {        nextNamee: BcdDefs.Namee;	myIndex, nextIndex: AMLoadstate.Index;	myMti: BcdDefs.MTIndex;	level: CARDINAL;	[myIndex, myMti] ¬ AMUseful.MapRealToConfig[mine.h.world, mine.gf];	[nextIndex, nextNamee, level] ¬ AMUseful.Sibling[mine.h.world, myIndex, [module[myMti]]];	myNext ¬ ZoomBufferFromNamee[mine.h, nextNamee, nextIndex, level];	IF mine.h.configInit.firstOpening THEN AutoOpenConfig[myNext, position]};      gvariable => {	next: Symbols.HTIndex;	[line, next] ¬ VariableLine[mine.h, mine.gf, mine.hash, global];	IF next = NoVariables THEN RETURN[NIL];	myNext ¬ IO.zone.NEW[ZoomBufferObject ¬ [line: line, zoomed: FALSE, h: mine.h, info: gvariable[mine.gf, next]]]};      ENDCASE;    next ¬ MeToHim[myNext]};      ZoomBufferFromNamee: PROC[h: IT.Handle, namee: BcdDefs.Namee, index: AMLoadstate.Index, level: CARDINAL] RETURNS[ZoomBuffer] = {    line: LONG STRING;    WITH next: namee SELECT FROM       config => {	IF next.cti = BcdDefs.CTNull THEN RETURN[NIL];	line ¬ ConfigLine[h, index, next.cti, level];	RETURN[IO.zone.NEW[ZoomBufferObject ¬ [line: line, zoomed: FALSE, h: h, info: config[index, next.cti]]]]};      module => {	gf: IT.GFHandle;	IF next.mti = BcdDefs.MTNull THEN RETURN[NIL];	gf ¬ AMUseful.MapConfigToReal[h.world, next.mti, index];	line ¬ ModuleLine[h, gf, level];	RETURN[IO.zone.NEW[ZoomBufferObject ¬ [line: line, zoomed: FALSE, h: h, info: module[gf, level]]]]};      ENDCASE => RETURN[NIL]};        AutoOpenConfig: PROC[buff: ZoomBuffer, position: TextSource.Position] = {    gfWeWant: IT.GFHandle;    IF buff = NIL THEN RETURN;    gfWeWant ¬ IP.GF[buff.h, WorldVMOps.LFlong[buff.h.world, buff.h.swapData.lFrame]];    WITH mine: buff SELECT FROM      config => {	IF AMUseful.ModuleInConfig[mine.h.world, gfWeWant, [mine.index, mine.cti]] THEN mine.h.configInit.rememberPos ¬ position };      module => 	IF mine.gf = gfWeWant THEN {	  mine.h.configInit.rememberPos ¬ position;	  mine.h.configInit.firstOpening ¬ FALSE };      ENDCASE => ERROR };      Close: PROC[buffer: ZoomSource.Buffer] = {    myPrev: ZoomBuffer ¬ HimToMe[buffer];    --TextSW.RemoveAllSecondarySelections[myPrev.h.flowSW];    --TextSW.RemoveAllSecondarySelections[myPrev.h.configSW];    IO.FreeString[myPrev.h, myPrev.line];    IO.zone.FREE[@myPrev]};      Destroy: PROC[buffer: ZoomSource.Buffer] = {Close[buffer]};    «SnarfLine: PROC[h: IT.Handle, callBack: PROC[LONG STRING], level: CARDINAL]     RETURNS[tag: LONG STRING] = {    oldStringOut: UserInput.StringProcType;    GatherTag: UserInput.StringProcType = {      String.AppendStringAndGrow[@tag, string, IO.zone]};    tag ¬ BlankZoomLine[h, level];    IO.EOL[h];    oldStringOut ¬ UserInput.SetStringOut[h.fileSW, GatherTag];    callBack[tag];    IO.EOL[h];    [] ¬ UserInput.SetStringOut[h.fileSW, oldStringOut]};»    SnarfLine: PROC[h: IT.Handle, callBack: PROC[LONG STRING], level: CARDINAL] RETURNS[tag: LONG STRING] = {    MyPutByte: Stream.PutByteProcedure = {       String.AppendCharAndGrow[@tag, LOOPHOLE[byte], IO.zone]};    MyPutWord: Stream.PutWordProcedure = {      chars: RECORD[a,b: CHARACTER] = LOOPHOLE[word];      longer: INTEGER = (tag.length + 2) - tag.maxlength;      IF longer > 0 THEN String.ExpandString[@tag, longer, IO.zone];      String.AppendChar[tag, chars.a];      String.AppendChar[tag, chars.b]};    MyPut: Stream.PutProcedure = {      longer: INTEGER = (tag.length + block.stopIndexPlusOne - block.startIndex) - tag.maxlength;      IF longer > 0 THEN String.ExpandString[@tag, longer, IO.zone];      FOR i: CARDINAL IN [block.startIndex..block.stopIndexPlusOne) DO        String.AppendChar[tag, LOOPHOLE[block.blockPointer[i], CHARACTER]];	ENDLOOP};    oldputByte: Stream.PutByteProcedure;    oldputWord: Stream.PutWordProcedure;    oldput: Stream.PutProcedure;    ttyImpl: TTYImpl.Handle = LOOPHOLE[h.tty];    stream: Stream.Handle = ttyImpl.stream;    tag ¬ BlankZoomLine[h, level];    IO.EOL[h];    oldputByte ¬ stream.putByte;     oldputWord ¬ stream.putWord;     oldput ¬ stream.put;     stream.putByte ¬ MyPutByte;    stream.putWord ¬ MyPutWord;    stream.put ¬ MyPut;    BEGIN ENABLE UNWIND => {      IO.FreeString[h, tag];       stream.putByte ¬ oldputByte;      stream.putWord ¬ oldputWord;      stream.put ¬ oldput };    callBack[tag];    END; -- ENABLE    IO.EOL[h];    stream.putByte ¬ oldputByte;    stream.putWord ¬ oldputWord;    stream.put ¬ oldput };      ProcessLevel: CARDINAL = 0;  LocalFrameLevel: CARDINAL = 1;  LocalVariableLevel: CARDINAL = 2;    ProcessLine: PROC[h: IT.Handle, psb: IT.PsbItem] RETURNS[tag: LONG STRING] = {    CallBack: PROC[LONG STRING] = {IS.DumpPSB[h, psb]};    RETURN[SnarfLine[h, CallBack, ProcessLevel]]};      FrameLine: PROC[h: IT.Handle, frame: IT.LFHandle] RETURNS[tag: LONG STRING] = {    CallBack: PROC[LONG STRING] = {      IF frame = NIL THEN IO.Line[h, "Current Process!"L]      ELSE IQ.LocalDump[h, frame ! Alloc.Overflow => RESUME[4]]};    RETURN[SnarfLine[h, CallBack, LocalFrameLevel]]};          VariableLine: ENTRY PROC[h: IT.Handle, frame: LONG POINTER, prevHash: Symbols.HTIndex, lg: IT.LG, level: CARDINAL ¬ LocalVariableLevel]     RETURNS[line: LONG STRING, nextHash: Symbols.HTIndex] = {    IF prevHash = NoVariables THEN RETURN[NIL, NoVariables];    IF prevHash = FirstVariable THEN {      FillVarCache[h, frame, lg, level];       RETURN[varCache[0].s, varCache[0].hash]}    ELSE       FOR c: CARDINAL IN [0..varCache.size-1) DO	IF varCache[c].hash = prevHash 	THEN RETURN[varCache[c+1].s, varCache[c+1].hash]; 	REPEAT FINISHED => RETURN[NIL, NoVariables];	ENDLOOP};	  BlankZoomLine: PROC[h: IT.Handle, level: CARDINAL] RETURNS[tag: LONG STRING] = {    SpacesPerLevel: CARDINAL = 2;    tag ¬ IO.MakeString[h, IT.MaxIdString+20];    tag.length ¬ (level+1)*SpacesPerLevel;    FOR i: CARDINAL IN [0..(level+1)*SpacesPerLevel) DO tag[i] ¬ Ascii.SP; ENDLOOP;    tag[level*SpacesPerLevel] ¬ Button};  printPackaged: BOOLEAN ¬ FALSE;	  PackagedCti: PROC[h: IT.Handle, config: AMUseful.ConfigRecord] RETURNS[unpackagedFile, repackaged: BOOLEAN] = {    bcd: LONG POINTER TO BcdDefs.BCD ¬ AMLoadstate.AcquireBcd[WorldVMOps.GetLoadstate[h.world], config.index];    IF config.cti # FIRST[BcdDefs.CTIndex] THEN RETURN[FALSE, FALSE];    RETURN[bcd.unpackagedFile # BcdDefs.FTNull, bcd.repackaged] };      PackagedModule: PROC[h: IT.Handle, gf: IT.GFHandle] RETURNS[packed, unpackageable: BOOLEAN] = {    index: AMLoadstate.Index;    mti: BcdDefs.MTIndex;    bcd: LONG POINTER TO BcdDefs.BCD;    [index, mti] ¬ AMUseful.MapRealToConfig[h.world, gf];    bcd ¬ AMLoadstate.AcquireBcd[WorldVMOps.GetLoadstate[h.world], index];    RETURN[BcdOpsExtras.MthFromMti[bcd, mti].packed, ~BcdOpsExtras.MthFromMti[bcd, mti].packageable]};    ConfigLine: PROC[h: IT.Handle, index: AMLoadstate.Index, cti: BcdDefs.CTIndex, level: CARDINAL] RETURNS[tag: LONG STRING] = {    tag ¬ BlankZoomLine[h, level];    AMUseful.CtiName[h.world, [index, cti], tag];    IF printPackaged THEN {      unpackagedFile, repackaged: BOOLEAN;      [unpackagedFile, repackaged] ¬ PackagedCti[h, [index, cti]];      IF unpackagedFile THEN String.AppendChar[tag, '$];      IF repackaged THEN String.AppendChar[tag, '#] };    String.AppendChar[tag, '\n]};      ModuleLine: PROC[h: IT.Handle, gf: IT.GFHandle, level: CARDINAL] RETURNS[tag: LONG STRING] = {    tag ¬ BlankZoomLine[h, level];    AMModel.ContextName[context: [h.world, prog[gf]], name: tag, radix: IO.options.pRadix      ! AMUseful.NoModule => {String.AppendString[tag, "(bad module)"L]; CONTINUE}];    [] ¬ IQ.GFrameMdi[h, gf       ! SymbolTable.Missing => { String.AppendString[tag, " No symbols."L]; CONTINUE };	Alloc.Overflow => RESUME[4]];    IF printPackaged THEN {      packed, unpackageable: BOOLEAN;      [packed, unpackageable] ¬ PackagedModule[h, gf];      IF packed THEN String.AppendChar[tag, '$];      IF unpackageable THEN String.AppendChar[tag, '#] };    String.AppendChar[tag, '\n]};      StringForHash: PROC[h: IT.Handle, s: LONG STRING, hash: Symbols.HTIndex] = INLINE {    ss: String.SubStringDescriptor;    SymbolOps.SubStringForHash[h.sym, @ss, hash];    s.length ¬ 0;    String.AppendSubString[s, @ss]};	  FillVarCache: PROC[h: IT.Handle, frame: LONG POINTER, lg: IT.LG, level: CARDINAL ¬ LocalVariableLevel] = {    Umbilical: PROCEDURE [IT.Handle, LONG UNSPECIFIED] = {      SELECT lg FROM        local => names ¬ IJ.DisplayLocalsF[h, frame, names];        global => names ¬ IJ.DisplayLocalsGF[h, names];	ENDCASE};    names: IJ.Names ¬ IJ.CreateNames[];    varname: LONG STRING ¬ [IT.MaxIdString];    h.iContext ¬ SELECT lg FROM       local => [local[frame]],       global => [global[frame]],      ENDCASE => ERROR;    IS.Umbrella[h, 0, Umbilical];    MakeNonEmpty[names]; RemoveDuplicates[names];    IF names.size > varCache.max THEN GrowVarCache[];    varCache.size ¬ names.size;    FOR c: CARDINAL IN [0..names.size) DO       CallBack: PROC[tag: LONG STRING] = {        PinkUmbrella: PROC[IT.Handle, LONG UNSPECIFIED] = {IO.IntString[h, varname]};	SELECT names[c] FROM 	  NoVariables => IO.Line[h, "No Variables!"L];	  Symbols.HTNull => IO.Line[h, "(anon)"L];	  ENDCASE => {	    StringForHash[h, varname, names[c]]; 	    IS.Umbrella[h, 0, PinkUmbrella]}};      varCache[c].hash ¬ names[c];       varCache[c].s ¬ SnarfLine[h, CallBack, level];      ENDLOOP;    IJ.DeleteNames[names]};      GrowVarCache: PROC[] = {    currentSize: CARDINAL = varCache.max;    IO.zone.FREE[@varCache];    varCache ¬ IO.zone.NEW[VarCache[currentSize+10]]};      MakeNonEmpty: PROC[names: IJ.Names] = {    IF names.size = 0 THEN {names[0] ¬ NoVariables; names.size ¬ 1}};    RemoveDuplicates: PROC[names: IJ.Names] = {    FOR a: CARDINAL IN [0..names.size) DO      FOR b: CARDINAL IN (a..names.size) DO        IF names[a] = names[b] THEN {	  Inline.LongCOPY[from: @names[b+1], to: @names[b], nwords: (names.size-b-1)*SIZE[Symbols.HTIndex]];	  names.size ¬ names.size - 1};	ENDLOOP;      ENDLOOP};    Button: CHARACTER = 264C;    -- get rid of this eventually  FrameFromSelection: PUBLIC PROC[h: IT.Handle] RETURNS[frame: LONG POINTER, lg: IT.LG] = {    window: Window.Handle = Selection.Convert[subwindow];    IF TextSW.IsIt[window] THEN {      position: TextSource.Position = TextSW.GetSelection[window].left;      zoom: TextSource.Handle = TextSW.GetSource[window];      buffer: ZoomBuffer = HimToMe[ZoomSource.BufferForPosition[zoom, position]];      IF buffer # NIL THEN 	WITH buffer SELECT FROM	  frame => RETURN[f, local];	  module => RETURN[gf, global];	  ENDCASE => RETURN[NIL, local] };    RETURN[NIL, local] };  Where: TYPE = RECORD[    SELECT tag:* FROM      process => [p: IT.PsbItem],      frame => [f: IT.LFHandle],      config => [index: AMLoadstate.Index, cti: BcdDefs.CTIndex],      module => [gf: IT.GFHandle],      string => [string: LONG STRING],      none => [],      ENDCASE];    CrossReference: PUBLIC «II» PROC[h: IT.Handle] RETURNS[foundSelection: BOOLEAN ¬ TRUE] = {    where: Where ¬ WhereIsSelection[h];    IF foundSelection ¬ (where.tag # none) THEN {       [] ¬ HighLightProcessSW[h, where];       [] ¬ HighLightConfigSW[h, where];      WITH where SELECT FROM string => String.FreeString[Heap.systemZone, string]; ENDCASE }};    WhereIsSelection: PROC[h: IT.Handle] RETURNS[where: Where] = {    window: Window.Handle = Selection.Convert[subwindow];    IF TextSW.IsIt[window] THEN {      position: TextSource.Position = TextSW.GetSelection[window].left;      zoom: TextSource.Handle = TextSW.GetSource[window];      buffer: ZoomBuffer = HimToMe[ZoomSource.BufferForPosition[zoom, position]];      IF buffer # NIL THEN 	WITH buffer SELECT FROM	  process => RETURN[[process[p]]];	  frame => RETURN[[frame[f]]];	  config => RETURN[[config[index, cti]]];	  module => RETURN[[module[gf]]];	  ENDCASE => RETURN[[none[]]] };    where ¬ GetSelection[] };      GetSelection: PROC[] RETURNS[where: Where] = {    string: LONG STRING ¬ Selection.Convert[string];    RETURN[IF string = NIL THEN [none[]] ELSE [string[string]]] };	  «ModuleFromSelection: PROC[h: IT.Handle] RETURNS[where: Where] = {    string: LONG STRING ¬ Selection.Convert[string];    IF string # NIL THEN {      gf: IT.GFHandle;      gf ¬ IB.GetModule[h, string ! IP.MultipleFrames => { gf ¬ NIL; CONTINUE }];      String.FreeString[Heap.systemZone, string];      IF gf # NIL THEN RETURN[[module[gf]]] };    RETURN[[none[]]]};»      «ConfigFromSelection: PROC[h: IT.Handle] RETURNS[where: Where] = {    string: LONG STRING ¬ Selection.Convert[string];    IF string # NIL THEN {      config: AMUseful.ConfigRecord;      config ¬ AMUseful.Config[h.world, string ! AMUseful.MultipleConfigs => RESUME];      String.FreeString[Heap.systemZone, string];      IF config # AMUseful.NullConfigRecord THEN RETURN[[config[config.index, config.cti]]] };    RETURN[[none[]]]};»    --  if selection is	hightlight in process sw	hightlight in config sw--    process		none				gf of top of stack--    frame		other lines with same gf	most zoomed line containing gf--    config		other lines with same gf	most zoomed line containing config--    module		other lines with same gf	most zoomed line containing gf  HighLightProcessSW: PROC[h: IT.Handle, where: Where] RETURNS[done: BOOLEAN] = {    EnumProc: PROC[buffer: ZoomSource.Buffer, first, last: TextSource.Position] RETURNS[stop: BOOLEAN] = {      doIt: BOOLEAN ¬ FALSE;      myBuffer: ZoomBuffer = HimToMe[buffer];      WITH buf: myBuffer SELECT FROM	process => {	  IF ~buf.zoomed THEN WITH w: where SELECT FROM	    process => {	      Enum: PROC[gf: IT.GFHandle] RETURNS[stop: BOOLEAN] = { 	        Enum1: PROC[gf1: IT.GFHandle] RETURNS[stop: BOOLEAN] = { RETURN[gf = gf1] };	        RETURN[EnumerateGFonProcessStack[h, w.p, Enum1] # NIL] };	      doIt ¬ EnumerateGFonProcessStack[h, buf.p, Enum] # NIL };	    frame => {	      Enum: PROC[gf: IT.GFHandle] RETURNS[stop: BOOLEAN] = { RETURN[gf = gf1] };	      gf1: IT.GFHandle = IF w.f = NIL THEN NIL ELSE IP.GF[h, w.f]; 	      doIt ¬ EnumerateGFonProcessStack[h, buf.p, Enum] # NIL };	    config => {	      Enum: PROC[gf: IT.GFHandle] RETURNS[stop: BOOLEAN] = { RETURN[AMUseful.ModuleInConfig[h.world, gf, [w.index, w.cti]]] };	      doIt ¬ EnumerateGFonProcessStack[h, buf.p, Enum] # NIL };	    module => {	      Enum: PROC[gf: IT.GFHandle] RETURNS[stop: BOOLEAN] = { RETURN[gf = w.gf] };	      doIt ¬ EnumerateGFonProcessStack[h, buf.p, Enum] # NIL };	    string => {	      doIt ¬ ModulePatternOnProcessStack[h, buf.p, w.string] OR ConfigPatternOnProcessStack[h, buf.p, w.string] };	    ENDCASE };	frame => {	  IF buf.f # NIL THEN WITH w: where SELECT FROM	    process => {	      Enum: PROC[gf: IT.GFHandle] RETURNS[stop: BOOLEAN] = { RETURN[gf = gf1] };	      gf1: IT.GFHandle = IP.GF[h, buf.f]; 	      doIt ¬ EnumerateGFonProcessStack[h, w.p, Enum] # NIL };	    frame => {	      gf: IT.GFHandle = IF w.f = NIL THEN NIL ELSE IP.GF[h, w.f];	      gf1: IT.GFHandle = IP.GF[h, buf.f];	      doIt ¬ gf = gf1 };	    config => {	      doIt ¬ AMUseful.ModuleInConfig[h.world, IP.GF[h, buf.f], [w.index, w.cti]] };	    module => {	      doIt ¬ IP.GF[h, buf.f] = w.gf };	    string => {	      doIt ¬ ModulePatternInModule[h, IP.GF[h, buf.f], w.string] OR ConfigPatternInModule[h, IP.GF[h, buf.f], w.string] };	    ENDCASE };	ENDCASE;      IF doIt THEN SecondarySelection[h.flowSW, myBuffer, first, last, FALSE];      stop ¬ FALSE };    IF h.flowZoom # NIL THEN ZoomSource.EnumerateBuffers[h.flowZoom, EnumProc]};      HighLightConfigSW: PROC[h: IT.Handle, where: Where] RETURNS[done: BOOLEAN] = {    EnumProc: PROC[buffer: ZoomSource.Buffer, first, last: TextSource.Position] RETURNS[stop: BOOLEAN] = {      doIt: BOOLEAN ¬ FALSE;      myBuffer: ZoomBuffer = HimToMe[buffer];      WITH buf: myBuffer SELECT FROM        config => {	  IF ~buf.zoomed THEN WITH w: where SELECT FROM	    process => {	      Enum: PROC[gf: IT.GFHandle] RETURNS[stop: BOOLEAN] = { RETURN[AMUseful.ModuleInConfig[h.world, gf, [buf.index, buf.cti]]] };	      doIt ¬ EnumerateGFonProcessStack[h, w.p, Enum] # NIL };	    frame => {	      doIt ¬ w.f # NIL AND AMUseful.ModuleInConfig[h.world, IP.GF[h, w.f], [buf.index, buf.cti]] };	    config => {	      doIt ¬ AMUseful.ConfigInConfig[h.world, [w.index, w.cti], [buf.index, buf.cti]] };	    module => {	      doIt ¬ AMUseful.ModuleInConfig[h.world, w.gf, [buf.index, buf.cti]] };	    string => {	      doIt ¬ ModulePatternInConfig[h, [buf.index, buf.cti], w.string] OR ConfigPatternInConfig[h, [buf.index, buf.cti], w.string]};	    ENDCASE };	module => {	  WITH w: where SELECT FROM	    process => {	      Enum: PROC[gf: IT.GFHandle] RETURNS[stop: BOOLEAN] = { RETURN[gf = buf.gf] };	      doIt ¬ EnumerateGFonProcessStack[h, w.p, Enum] # NIL };	    frame => {	      doIt ¬ w.f # NIL AND IP.GF[h, w.f] = buf.gf };	    config => {	      NULL };	    module => {	      doIt ¬ w.gf = buf.gf };	    string => {	      doIt ¬ ModulePatternInModule[h, buf.gf, w.string] };	    ENDCASE };	ENDCASE;      IF doIt THEN SecondarySelection[h.configSW, myBuffer, first, last, FALSE];      stop ¬ FALSE };    IF h.configZoom # NIL THEN ZoomSource.EnumerateBuffers[h.configZoom, EnumProc]};      EnumerateGFonProcessStack: PROC[h: IT.Handle, process: IT.PsbItem, proc: PROC[IT.GFHandle] RETURNS[stop: BOOLEAN]] RETURNS[gf: IT.GFHandle] = {    ENABLE IP.NoPrevious, IQ.InvalidFrame => { gf ¬ NIL; CONTINUE };    FOR lf: IT.LFHandle ¬ IS.Frame[h, process], IP.Previous[h, lf] UNTIL lf = NIL DO       gf ¬ IP.GF[h, lf];      IF proc[gf] THEN RETURN[gf];      REPEAT FINISHED => RETURN[NIL];      ENDLOOP };        EnumerateConfigsonProcessStack: PROC[h: IT.Handle, process: IT.PsbItem, proc: AMUseful.ConfigProc] RETURNS[config: AMUseful.ConfigRecord] = {    ENABLE IP.NoPrevious, IQ.InvalidFrame => { config ¬ AMUseful.NullConfigRecord; CONTINUE };    FOR lf: IT.LFHandle ¬ IS.Frame[h, process], IP.Previous[h, lf] UNTIL lf = NIL DO       config ¬ AMUseful.EnumerateConfigsForModule[h.world, proc, IP.GF[h, lf]];      IF config # AMUseful.NullConfigRecord THEN RETURN;      REPEAT FINISHED => RETURN[AMUseful.NullConfigRecord];      ENDLOOP };      ModuleGenerator: TYPE = PROC[proc: AMUseful.ModuleProc] RETURNS[IT.GFHandle];  ConfigGenerator: TYPE = PROC[proc: AMUseful.ConfigProc] RETURNS[AMUseful.ConfigRecord];  ModulePattern: PROC[h: IT.Handle, generator: ModuleGenerator, pattern: LONG STRING] RETURNS[BOOLEAN] = {    name: LONG STRING ¬ [IT.MaxModuleString];    Proc: AMUseful.ModuleProc = {      name.length ¬ 0;      AMUseful.ModuleName[h.world, gf, name];      RETURN[Exec.MatchPattern[name, pattern]]};    RETURN[generator[Proc] # NIL]};      ModulePatternOnProcessStack: PROC[h: IT.Handle, process: IT.PsbItem, pattern: LONG STRING] RETURNS[BOOLEAN] = {    Generator: ModuleGenerator = {      RETURN[EnumerateGFonProcessStack[h, process, proc]]};    RETURN[ModulePattern[h, Generator, pattern]]};    ModulePatternInConfig: PROC[h: IT.Handle, config: AMUseful.ConfigRecord, pattern: LONG STRING] RETURNS[BOOLEAN] = {    Generator: ModuleGenerator = {      RETURN[AMUseful.EnumerateModulesInConfig[h.world, proc, config]]};    RETURN[ModulePattern[h, Generator, pattern]]};      ModulePatternInModule: PROC[h: IT.Handle, gf: IT.GFHandle, pattern: LONG STRING] RETURNS[BOOLEAN] = {    Generator: ModuleGenerator = {      RETURN[IF proc[gf] THEN gf ELSE NIL]};    RETURN[ModulePattern[h, Generator, pattern]]};      ConfigPattern: PROC[h: IT.Handle, generator: ConfigGenerator, pattern: LONG STRING] RETURNS[BOOLEAN] = {    name: LONG STRING ¬ [IT.MaxIdString];    Proc: AMUseful.ConfigProc = {      name.length ¬ 0;      AMUseful.CtiName[h.world, config, name];      RETURN[Exec.MatchPattern[name, pattern]]};    RETURN[generator[Proc] # AMUseful.NullConfigRecord]};      ConfigPatternOnProcessStack: PROC[h: IT.Handle, process: IT.PsbItem, pattern: LONG STRING] RETURNS[BOOLEAN] = {    Generator: ConfigGenerator = {      RETURN[EnumerateConfigsonProcessStack[h, process, proc]]};    RETURN[ConfigPattern[h, Generator, pattern]]};    ConfigPatternInConfig: PROC[h: IT.Handle, config: AMUseful.ConfigRecord, pattern: LONG STRING] RETURNS[BOOLEAN] = {    Generator: ConfigGenerator = {      RETURN[AMUseful.EnumerateConfigsInConfig[h.world, proc, config]]};    RETURN[ConfigPattern[h, Generator, pattern]]};      ConfigPatternInModule: PROC[h: IT.Handle, gf: IT.GFHandle, pattern: LONG STRING] RETURNS[BOOLEAN] = {    Generator: ConfigGenerator = {      RETURN[AMUseful.EnumerateConfigsForModule[h.world, proc, gf]]};    RETURN[ConfigPattern[h, Generator, pattern]]};      ClearMarks: PUBLIC PROC[h: IT.Handle] = {    EnumConfig: PROC[buffer: ZoomSource.Buffer, first, last: TextSource.Position] RETURNS[stop: BOOLEAN] = {      myBuffer: ZoomBuffer = HimToMe[buffer];      SecondarySelection[h.configSW, myBuffer, first, last, TRUE];      RETURN[FALSE]};     EnumFlow: PROC[buffer: ZoomSource.Buffer, first, last: TextSource.Position] RETURNS[stop: BOOLEAN] = {      myBuffer: ZoomBuffer = HimToMe[buffer];      SecondarySelection[h.flowSW, myBuffer, first, last, TRUE];      RETURN[FALSE]};    IF h.configZoom # NIL THEN ZoomSource.EnumerateBuffers[h.configZoom, EnumConfig];    IF h.flowZoom # NIL THEN ZoomSource.EnumerateBuffers[h.flowZoom, EnumFlow] };    DateForSelection: PUBLIC PROC[h: IT.Handle] = {    window: Window.Handle = Selection.Convert[subwindow];    position: TextSource.Position = TextSW.GetSelection[window].left;    zoom: TextSource.Handle = TextSW.GetSource[window];    selectedBuffer: ZoomSource.Buffer = ZoomSource.BufferForPosition[zoom, position];    dateString: LONG STRING ¬ [30];    EnumProc: PROC[buffer: ZoomSource.Buffer, first, last: TextSource.Position] RETURNS[stop: BOOLEAN] = {      IF buffer = selectedBuffer THEN {        myBuffer: ZoomBuffer = HimToMe[buffer];        time: LONG CARDINAL;	WITH myBuffer SELECT FROM	  config => {	    ENABLE AMLoadstate.Error => { time ¬ 0; CONTINUE };	    bcd: LONG POINTER TO BcdDefs.BCD = AMLoadstate.AcquireBcd[WorldVMOps.GetLoadstate[h.world], index];	    file: BcdDefs.FTIndex = BcdOpsExtras.CTBaseFromBcd[bcd][cti].file;	    time ¬ IF file = BcdDefs.FTSelf THEN bcd.version.time ELSE BcdOpsExtras.FTBaseFromBcd[bcd][file].version.time };	  module => {	    time ¬ AMUseful.VersionStamp[h.world, gf].time };	  frame => {	    time ¬ AMUseful.VersionStamp[h.world, IP.GF[h, f]].time };	  ENDCASE => RETURN[TRUE];	IF myBuffer.dated THEN RETURN[TRUE] ELSE myBuffer.dated ¬ TRUE;	String.AppendString[dateString, "   "L];	Time.Append[s: dateString, unpacked: Time.Unpack[[time]], zone: TRUE];	TextSW.InsertString[sw: window, pos: last, s: dateString];	RETURN[TRUE] }      ELSE RETURN[FALSE] };    IF selectedBuffer = NIL THEN RETURN;    ZoomSource.EnumerateBuffers[zoom, EnumProc] };    FetchSelection: PUBLIC PROC[h: IT.Handle] = {    «window: Window.Handle = Selection.Convert[subwindow];    position: TextSource.Position = TextSW.GetSelection[window].left;    zoom: TextSource.Handle = TextSW.GetSource[window];    selectedBuffer: ZoomBuffer = HimToMe[ZoomSource.BufferForPosition[zoom, position]];    time: LONG CARDINAL;    IF selectedBuffer = NIL THEN RETURN;    WITH selectedBuffer SELECT FROM      module => {        fileTime: LONG CARDINAL = AMUseful.VersionStamp[h.world, gf].time;	fileName: LONG STRING ¬ [IT.MaxModuleString];	AMUseful.ModuleName[h.world, gf, fileName];	FTDefs.data.file ¬ fileName;	FTDefs.Fetch[];	results ¬ DFetchPublic.Find[findHandle, args];	IF Date.StringToPacked[results.createDate].dt = fileTime	  FileName.UnpackFilename[];	WITH myBuffer SELECT FROM	  module => {	    time ¬ AMUseful.VersionStamp[h.world, gf].time };	  ENDCASE => RETURN[TRUE];	IF myBuffer.dated THEN RETURN[TRUE] ELSE myBuffer.dated ¬ TRUE;	String.AppendString[string, "   "L];	Time.Append[string, Time.Unpack[[time]]];	TextSW.InsertString[sw: window, pos: last, s: string];	RETURN[TRUE] }      ELSE RETURN[FALSE] };    ZoomSource.EnumerateBuffers[zoom, EnumProc]» };        Mark: CHARACTER = Ascii.ControlA;  Clear: CHARACTER = Ascii.SP;      SecondarySelection: PROC[window: Window.Handle, buffer: ZoomBuffer, first, last: TextSource.Position, clear: BOOLEAN] = {    indent: CARDINAL;    chars: PACKED ARRAY [0..2) OF CHARACTER ¬ [Mark, Clear];    block: Environment.Block = [LOOPHOLE[LONG[@chars]], IF clear THEN 1 ELSE 0, IF clear THEN 2 ELSE 1];    IF buffer.marked # clear THEN RETURN;    FOR indent IN [0..buffer.line.length) DO      IF buffer.line[indent] = Button THEN EXIT;      ENDLOOP;    TextSW.ReplaceText[sw: window, pos: first+indent+1, count: 1, block: block, keepTrash: FALSE];    buffer.marked ¬ ~clear;    «[] ¬ TextSW.SetSecondarySelection[window, first, last, video]» };      InterestingPosition: PROC[window: Window.Handle, place: Window.Place] RETURNS[interesting: BOOLEAN ¬ FALSE] = {    position: CARDINAL = Inline.LowHalf[TextSW.PositionFromPlace[window, place]];    zoom: TextSource.Handle = TextSW.GetSource[window];    block: Environment.Block;    [block,] ¬ zoom.ReadText[position: position, maxLength: 1, class: alpha];    IF block.blockPointer = NIL THEN RETURN;    IF interesting ¬ (block.blockPointer[block.startIndex] = Button.ORD) THEN {      buffer: ZoomBuffer = HimToMe[ZoomSource.BufferForPosition[zoom, position]];      IF buffer.zoomed THEN {        ZoomSource.Close[zoom, window, position]; 	buffer.zoomed ¬ FALSE;	TextSW.SetSelection[sw: window, left: position+2, right: position+2]}      ELSE ZoomSource.Open[zoom, window, position]}};        SkipToNext: PROC[window: Window.Handle] RETURNS[BOOLEAN] = {    zoom: TextSource.Handle = TextSW.GetSource[window];    left, right: TextSW.Position;    string: LONG STRING ¬ [2];    [left, right] ¬ TextSW.GetSelection[window];    IF left = right THEN left ¬ 0;    String.AppendChar[string, Mark];    [, left] ¬ TextSource.AsciiTextSearch[source: zoom, string: string, start: left+1, stop: LAST[LONG CARDINAL]      ! TextSource.SearchFailed => {        [, left] ¬ TextSource.AsciiTextSearch[source: zoom, string: string, start: 0, stop: left-1	  ! TextSource.SearchFailed => GOTO NotFound];	CONTINUE }];    IF ~TextSW.PositionIsVisible[window, left] THEN TextSW.SetPosition[window, left];    TextSW.SetSelection[window, left, left+1];    RETURN[TRUE];    EXITS NotFound => RETURN[FALSE] };      TipInterpreter: TIP.NotifyProc = {    place: Window.Place;    FOR input: TIP.Results ¬ results, input.Rest[] UNTIL input = NIL DO      WITH z: input.First[] SELECT FROM        coords => place ¬ z.place;        atom =>          SELECT z.a FROM            doPrimary => IF InterestingPosition[window, place] THEN RETURN;	    next => IF SkipToNext[window] THEN RETURN;	    ENDCASE;        ENDCASE;      ENDLOOP;    OldTipInterpreter[window, results]};    }.
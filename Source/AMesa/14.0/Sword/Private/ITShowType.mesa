-- Copyright (C) 1986  by Xerox Corporation. All rights reserved. -- ITShowType.mesa DIRECTORY  BcdDefs USING [Base, FTSelf, MTIndex, VersionID],  BcdOps USING [BcdBase, MTHandle],  IO, IS, IT,  Environment USING [bitsPerWord, PageCount],  Format USING [    Blanks, Char, CR, Line, LongNumber, NumberFormat, Octal, Number,     StringProc, SubString],  MFile USING [CopyFileHandle, Error, Handle, ReadOnly],  MSegment USING [Address, Create, Delete, Error, Handle, Reset],  SpecialMFile USING [LeaderPages],  String USING [    AppendChar, AppendDecimal, AppendString, Empty, LowerCase,     SubString, SubStringDescriptor, StringBoundsFault],  Symbols USING [    BitAddress, BodyRecord, BTIndex, BTNull, codeANY, SERecord, CBTIndex,    codeCHAR, codeINT, CTXIndex, CSEIndex, ExtensionType, HTIndex, HTNull,    ISEIndex, ISENull, lZ, RecordSEIndex, RecordSENull, SEIndex, SENull,    StandardContext, TransferMode, typeANY, typeTYPE],  SymbolOps,  SymbolTable USING [Acquire, Release, SetCacheSize, Handle],  Table USING [Base, Limit],  Tree USING [Link, Node, Null],  TreeOps;  ITShowType: MONITOR  IMPORTS    Format, IO, MFile, MSegment, SpecialMFile, String, SymbolOps,    SymbolTable, TreeOps  EXPORTS IS =  BEGIN    --types      Handle: TYPE = SymbolTable.Handle;    EnumeratedSEIndex: TYPE = Table.Base RELATIVE POINTER [0..Table.Limit)    TO enumerated cons Symbols.SERecord;      ValFormat: TYPE = RECORD [    SELECT tag: * FROM      signed => [], --an INTEGER or subrange with base < 0      unsigned => [], -- a CARDINAL, WORD, UNSPECIFIED, or subrange w/ base >= 0      char => [], --a character      enum => [esei: EnumeratedSEIndex], --an enumerated type      array => [componentType: Symbols.SEIndex],      transfer => [mode: Symbols.TransferMode], --a PROCEDURE, SIGNAL, ERROR, PROGRAM, or PORT      ref => [], --a pointer      other => [], --anything else (whether single word or multi-word)      ENDCASE];    --global monitor data  symbols: Handle;		 --symbol table for current file  sseg: MSegment.Handle;		 --segment containing symbol table  module: String.SubStringDescriptor;	 --name of current file   defaultPublic: BOOLEAN ¬ TRUE;	 --outer RECORD is public or private?  indent: CARDINAL;			 --how many spaces to indent variants  showBits: BOOLEAN;  --if TRUE, show bit positions even if not MACHINE DEPENDENT  out: PROC [s: LONG STRING, clientData: LONG POINTER];    --no default for "clientData", so compiler catches missing data  cd: LONG POINTER;    --"Constants" (initialized by mainline code)  PrintSym: PROCEDURE [sei: Symbols.ISEIndex, colonstring: LONG STRING] =    BEGIN    savePublic: BOOLEAN ¬ defaultPublic;    typeSei: Symbols.SEIndex;    IF symbols.seb[sei].hash # Symbols.HTNull THEN {      PrintSei[sei]; out[colonstring, cd]};    IF symbols.seb[sei].public # defaultPublic THEN {      defaultPublic ¬ symbols.seb[sei].public;      out[IF defaultPublic THEN "PUBLIC "L ELSE "PRIVATE "L, cd]};    IF symbols.seb[sei].idType = Symbols.typeTYPE THEN      BEGIN      vf: ValFormat;      typeSei ¬ SymbolOps.ToSei[symbols.seb[sei].idInfo];      out["TYPE"L, cd];      WITH t: symbols.seb[typeSei] SELECT FROM        cons => WITH t SELECT FROM	  opaque => NULL;          ENDCASE => out[" = "L, cd];        ENDCASE => out[" = "L, cd];      vf ¬ PrintType[typeSei, NoSub];      PrintDefaultValue [sei, vf];      END    ELSE      BEGIN      vf: ValFormat;      typeSei ¬ symbols.seb[sei].idType;      IF symbols.seb[sei].immutable        AND NOT symbols.seb[sei].constant	AND (SELECT SymbolOps.XferMode[symbols, typeSei] FROM	  none, process => TRUE, ENDCASE => FALSE)	    --it's not a proc, signal, error, program, or port        THEN out["READONLY "L, cd];      vf ¬ PrintType[typeSei, NoSub];      IF symbols.seb[sei].constant THEN	WITH vf SELECT FROM	  transfer =>	    BEGIN	    bti: Symbols.CBTIndex = SymbolOps.ToBti[symbols.seb[sei].idInfo];	    out[" = "L, cd];	    SELECT TRUE FROM	      bti # Symbols.BTNull => 	        out[SELECT TRUE FROM		  mode = signal, mode = error =>"CODE"L,		  symbols.bb[bti].inline => "(INLINE)"L	,		  ENDCASE => "(procedure body)"L, cd];	      symbols.seb[sei].extended =>	        out["(MACHINE CODE)"L, cd];	      ENDCASE =>	        PrintTypedVal[symbols.seb[sei].idValue, vf] --a hardcoded constant	    END;	  ENDCASE =>	    BEGIN	    out[" = "L, cd];	    IF symbols.seb[sei].extended	      THEN PrintTreeLink[SymbolOps.FindExtension[symbols, sei].tree, vf, 0]	      ELSE	        BEGIN	        underTypeSei: Symbols.CSEIndex = SymbolOps.UnderType[symbols, typeSei];	        WITH symbols.seb[underTypeSei] SELECT FROM	          subrange => PrintTypedVal[SymbolOps.ToCard[symbols.seb[sei].idValue] + origin, vf];		     --normalize subrange	          ENDCASE => PrintTypedVal[symbols.seb[sei].idValue, vf];		END;	    END;      END;    defaultPublic ¬ savePublic;    END;      PrintTypedVal: PROCEDURE [val: UNSPECIFIED, vf: ValFormat] =    BEGIN    loophole: BOOLEAN ¬ FALSE;     WITH vf SELECT FROM      signed => PutSigned[val];      unsigned => PutUnsigned[val];      char => {        Format.Octal[out, val, cd]; PutChar['C]};      enum => PutEnum[val, esei];      transfer, ref => IF val = 0 THEN out ["NIL"L, cd] ELSE loophole ¬ TRUE;      ENDCASE => loophole ¬ TRUE;    IF loophole THEN        {out["LOOPHOLE ["L, cd];	PutUnsigned[val];	PutChar[']]};    END;      GetBitSpec: PROCEDURE [isei: Symbols.ISEIndex, bitspec: LONG STRING] =    BEGIN    a: Symbols.BitAddress = SymbolOps.ToBitAddr[symbols.seb[isei].idValue];    s: CARDINAL = SymbolOps.ToCard[symbols.seb[isei].idInfo];    bitspec.length ¬ 0;    String.AppendString[bitspec, " ("L];    String.AppendDecimal[bitspec, a.wd];    IF s # 0 THEN      {String.AppendChar[bitspec, ':];      String.AppendDecimal[bitspec, a.bd];      String.AppendString[bitspec, ".."L];      String.AppendDecimal[bitspec, a.bd+s-1]};    String.AppendString[bitspec, "): "L]    END;      OutArgType: PROCEDURE [sei: Symbols.CSEIndex] = {    IF sei = Symbols.SENull THEN out[": NIL"L, cd]    ELSE      WITH t: symbols.seb[sei] SELECT FROM        record => PrintFieldCtx[t.fieldCtx];	any => out[": ANY"L, cd];	ENDCASE};  PrintFieldCtx: PROCEDURE [ctx: Symbols.CTXIndex, md: BOOLEAN ¬ FALSE] =    BEGIN     isei: Symbols.ISEIndex ¬ SymbolOps.FirstCtxSe[symbols, ctx];    bitspec: LONG STRING ¬ [20];    first: BOOLEAN ¬ TRUE;    IF ~md THEN String.AppendString[bitspec, ": "L];    IF isei # Symbols.ISENull AND symbols.seb[isei].idCtx # ctx THEN       isei ¬ SymbolOps.NextSe[symbols, isei];    PutChar['[];    FOR isei ¬ isei, SymbolOps.NextSe[symbols, isei] UNTIL isei = Symbols.ISENull DO      IF first THEN first ¬ FALSE ELSE out[", "L, cd];      IF md THEN GetBitSpec[isei, bitspec];      PrintSym[isei, bitspec];      PrintDefaultValue[isei, GetValFormat[symbols.seb[isei].idType]];      ENDLOOP;    PutChar[']];    END;      PrintHti: PROCEDURE [hti: Symbols.HTIndex] =    BEGIN    desc: String.SubStringDescriptor;    s: String.SubString = @desc;    IF hti = Symbols.HTNull THEN out["(anonymous)"L, cd]    ELSE {      SymbolOps.SubStringForHash[symbols, s, hti]; Format.SubString[out, s, cd]};    RETURN    END;      PrintSei: PROCEDURE [sei: Symbols.ISEIndex] = {    PrintHti[      IF sei = Symbols.SENull       THEN Symbols.HTNull       ELSE symbols.seb[sei].hash]};      NoSub: PROCEDURE = {};    PutEnum: PROCEDURE [val: UNSPECIFIED, esei: EnumeratedSEIndex] =    BEGIN    FOR sei: Symbols.ISEIndex ¬       SymbolOps.FirstCtxSe[symbols, symbols.seb[esei].valueCtx], SymbolOps.NextSe[symbols, sei]       WHILE sei # Symbols.ISENull DO      IF symbols.seb[sei].idValue = val THEN {PrintSei[sei]; RETURN};      ENDLOOP;    out["LOOPHOLE ["L, cd];     PutUnsigned[val]; PutChar[']];    END;    GetValFormat: PROCEDURE [tsei: Symbols.SEIndex] RETURNS [vf: ValFormat] =    BEGIN    WITH t: symbols.seb[tsei] SELECT FROM      id => RETURN[GetValFormat[SymbolOps.UnderType[symbols, tsei]]];      cons =>	WITH t SELECT FROM	  basic =>  	    SELECT code FROM	      Symbols.codeANY => vf ¬ [unsigned[]];	      Symbols.codeINT => vf ¬ [signed[]];	      Symbols.codeCHAR => vf ¬ [char[]];	      ENDCASE;	  enumerated => vf ¬ [enum[LOOPHOLE[tsei]]];	  array => vf ¬ [array[componentType]];	  transfer => vf ¬ [transfer[mode]];	  relative => vf ¬ GetValFormat[offsetType];	  subrange =>	     {vf ¬ GetValFormat[rangeType];	     IF vf.tag = signed AND origin = 0 THEN vf ¬ [unsigned[]]};	  long => vf ¬ GetValFormat[rangeType];	  ref => vf ¬ [ref[]];	  ENDCASE => vf ¬ [other[]];       ENDCASE => vf ¬ [other[]];     END;	  PrintType: PROCEDURE [    tsei: Symbols.SEIndex, dosub: PROCEDURE] RETURNS [vf: ValFormat] =    BEGIN    bitspec: LONG STRING = [20];    vf ¬ GetValFormat[tsei];    WITH t: symbols.seb[tsei] SELECT FROM      id =>    	BEGIN	--print adjectives, if any        tseiNext: Symbols.SEIndex;	UNTIL (tseiNext ¬ SymbolOps.TypeLink[symbols, tsei]) = Symbols.SENull DO	  WITH symbols.seb[tsei] SELECT FROM	    id => {PrintSei[LOOPHOLE[tsei]]; PutBlanks[1]};	    ENDCASE;	  tsei ¬ tseiNext;	  ENDLOOP;	    	--print module qualification of last ID in chain	IF t.idCtx NOT IN Symbols.StandardContext THEN	  WITH c: symbols.ctxb[t.idCtx] SELECT FROM	    included =>	      BEGIN  	      hti: Symbols.HTIndex = symbols.mdb[c.module].moduleId;  	      PrintHti[hti]; --interface name  	      PutChar['.]; -- dot qualification  	      END;  	    simple =>  	      PutCurrentModuleDot[];	    ENDCASE;	      	--finally print that last ID	PrintSei[LOOPHOLE[tsei]];	dosub[];	END;	      cons =>	WITH t SELECT FROM	  --basic =>  won't see one, see the id first.	  	  enumerated =>	    BEGIN	    isei: Symbols.ISEIndex;	    v: CARDINAL ¬ 0;	    sv: CARDINAL;	    first: BOOLEAN ¬ TRUE;	    IF machineDep THEN out["MACHINE DEPENDENT "L, cd];	    PutChar['{];	    FOR isei ¬ SymbolOps.FirstCtxSe[symbols, valueCtx], SymbolOps.NextSe[symbols, isei] 	      UNTIL isei = Symbols.ISENull DO	      IF first THEN first ¬ FALSE ELSE out[", "L, cd];	      IF machineDep OR showBits THEN {	        hti: Symbols.HTIndex = symbols.seb[isei].hash;		sv ¬ SymbolOps.ToCard[symbols.seb[isei].idValue];		IF hti # Symbols.HTNull THEN PrintSei[isei];		IF sv # v OR hti = Symbols.HTNull OR showBits		   THEN {		     PutChar['(]; 		     PutUnsigned[sv]; 		     PutChar[')]};		v ¬ sv + 1}	      ELSE PrintSei[isei];	      IF Abort[] THEN {	        PutLine["  ...aborted}"L]; RETURN};	      ENDLOOP;	    PutChar['}];	    END;	  record =>	    BEGIN	    IF symbols.ctxb[fieldCtx].level # Symbols.lZ THEN	      BEGIN	      fctx: Symbols.CTXIndex = fieldCtx;	      bti: Symbols.BTIndex ¬ FIRST[Symbols.BTIndex];	      btlimit: Symbols.BTIndex = bti + symbols.stHandle.bodyBlock.size;	      out["FRAME ["L, cd];	      UNTIL LOOPHOLE[bti, CARDINAL] >= LOOPHOLE[btlimit, CARDINAL] DO		WITH entry: symbols.bb[bti] SELECT FROM		  Callable =>		    BEGIN		    IF entry.localCtx = fctx THEN {		      PrintSei[entry.id]; PutChar[']]; EXIT};		    bti ¬		      bti +			(WITH entry SELECT FROM			   Inner => SIZE[Inner Callable Symbols.BodyRecord],			   Catch => SIZE[Catch Callable Symbols.BodyRecord],			   ENDCASE => SIZE[Outer Callable Symbols.BodyRecord]);		    END;		  ENDCASE => bti ¬ bti + SIZE[Other Symbols.BodyRecord];		ENDLOOP;	      END	    ELSE	      BEGIN	      dp: BOOLEAN ¬ defaultPublic;	      IF defaultPublic AND hints.privateFields THEN {	        out["PRIVATE "L, cd];		defaultPublic ¬ FALSE};	      IF monitored THEN out["MONITORED "L, cd];	      IF machineDep THEN out["MACHINE DEPENDENT "L, cd];	      out["RECORD "L, cd];	      PrintFieldCtx[fieldCtx, machineDep OR showBits];	      defaultPublic ¬ dp;	      END;	    END;	  ref =>	    BEGIN	    IF var	      THEN IF readOnly	        THEN out ["READONLY "L, cd]		ELSE out ["VAR "L, cd]	      ELSE	        BEGIN		IF ordered THEN out["ORDERED "L, cd];		IF basing THEN out["BASE "L, cd];		out["POINTER"L, cd];		IF dosub # NoSub THEN {PutBlanks[1]; dosub[]};		WITH symbols.seb[SymbolOps.UnderType[symbols, refType]] SELECT FROM	           basic => IF code = Symbols.codeANY AND ~readOnly THEN 	             GO TO noprint;	           ENDCASE;	        out[" TO "L, cd];	        IF readOnly THEN out["READONLY "L, cd];		END;	    [] ¬ PrintType[refType, NoSub];	    EXITS noprint => NULL;	    END;	  array =>	    BEGIN	    IF packed THEN out["PACKED "L, cd];	    out["ARRAY "L, cd];	    [] ¬ PrintType[indexType, NoSub];	    out[" OF "L, cd];	    [] ¬ PrintType[componentType, NoSub];	    END;	  arraydesc =>	    BEGIN	    out["DESCRIPTOR FOR "L, cd];	    IF readOnly THEN out["READONLY "L, cd];	    [] ¬ PrintType[describedType, NoSub];	    END;	  transfer =>	    BEGIN	    PutModeName[mode];	    IF typeIn # Symbols.RecordSENull THEN {	      PutBlanks[1]; OutArgType[typeIn]};	    IF typeOut # Symbols.RecordSENull THEN	      BEGIN	      out[" RETURNS "L, cd];	      OutArgType[typeOut];	      END;	    END;	  union =>	    BEGIN	    tagType: Symbols.SEIndex;	    NewLine: PROCEDURE = {	      Format.CR[out, cd]; 	      PutBlanks[indent]};	    indent ¬ indent + 2;	    out["SELECT "L, cd];	    IF ~controlled THEN	      IF overlaid THEN out["OVERLAID "L, cd]	      ELSE out["COMPUTED "L, cd]	    ELSE 	      BEGIN 	      PrintSei[tagSei]; 	      IF machineDep OR showBits THEN {	        GetBitSpec[tagSei, bitspec]; out[bitspec, cd]}	      ELSE out[": "L, cd];	      END;	    tagType ¬ symbols.seb[tagSei].idType;	    IF symbols.seb[tagSei].public # defaultPublic THEN	      out[		IF defaultPublic THEN "PRIVATE "L ELSE "PUBLIC "L, cd];	    WITH symbols.seb[tagType] SELECT FROM	      id => [] ¬ PrintType[tagType, NoSub];	      cons => PutChar['*];	      ENDCASE;	    out[" FROM "L, cd];	    BEGIN	    temp, isei: Symbols.ISEIndex;	    varRec: Symbols.RecordSEIndex;	    FOR isei ¬ SymbolOps.FirstCtxSe[symbols, caseCtx], temp 	      UNTIL isei = Symbols.ISENull DO	      NewLine[];	      PrintSei[isei];	      varRec ¬ LOOPHOLE[SymbolOps.UnderType[symbols, SymbolOps.ToSei[symbols.seb[isei].idInfo]]];	      FOR temp ¬ SymbolOps.NextSe[symbols, isei], SymbolOps.NextSe[symbols, temp]		  UNTIL temp = Symbols.ISENull 		    OR SymbolOps.ToSei[symbols.seb[temp].idInfo] # isei DO	        out[", "L, cd];	        PrintSei[temp];	        ENDLOOP;	      out[" => "L, cd];	      PrintFieldCtx[symbols.seb[varRec].fieldCtx, machineDep OR showBits];	      PutChar[',]; --comma	      ENDLOOP;	    NewLine[];	    out["ENDCASE"L, cd];	    indent ¬ indent - 2;	    END;	    END;	  relative =>	    BEGIN	    IF baseType # Symbols.SENull THEN [] ¬ PrintType[baseType, NoSub];	    out[" RELATIVE "L, cd];	    [] ¬ PrintType[offsetType, dosub];	    END;	  sequence =>	    BEGIN	    tagType: Symbols.SEIndex;	    IF packed THEN out["PACKED "L, cd];	    out["SEQUENCE "L, cd];	    IF ~controlled THEN out["COMPUTED "L, cd]	    ELSE 	      BEGIN 	      PrintSei[tagSei]; 	      IF machineDep OR showBits THEN {	        GetBitSpec[tagSei, bitspec]; out[bitspec, cd]}	      ELSE out[": "L, cd];	      END;	    tagType ¬ symbols.seb[tagSei].idType;	    IF symbols.seb[tagSei].public # defaultPublic THEN	      out[		IF defaultPublic THEN "PRIVATE "L ELSE "PUBLIC "L, cd];	    [] ¬ PrintType[tagType, NoSub];	    out[" OF "L, cd];	    [] ¬ PrintType[componentType, NoSub];	    END;	  subrange =>	    BEGIN	    org: INTEGER ¬ origin;	    size: CARDINAL ¬ range;	    	    doit: PROCEDURE =	      BEGIN              vfSub: ValFormat = SELECT TRUE FROM                vf.tag = enum => vf,	        org < 0 => [signed[]]	        ENDCASE => [unsigned[]];	      PutChar['[];	      PrintTypedVal[org, vfSub];	      out[".."L, cd];	      IF empty THEN {		PrintTypedVal[org, vfSub]; PutChar[')]}	      ELSE {	        PrintTypedVal[org + size, vfSub]; PutChar[']]};	      END;	      	    [] ¬ PrintType[rangeType, doit];	    END;	  zone => SELECT TRUE FROM	    counted => out["ZONE"L, cd];	    mds => out["MDSZone"L, cd];	    ENDCASE => out["UNCOUNTED ZONE"L, cd];	  opaque => {	    IF lengthKnown THEN {	      PutChar['[];	      PutUnsigned[length/Environment.bitsPerWord];	      PutChar[']]}};	  long =>	    {IF NOT IsVar [rangeType] THEN out["LONG "L, cd];	    [] ¬ PrintType[rangeType, NoSub]};	  real => out["REAL"L, cd];	  ENDCASE => out["(? unknown TYPE)"L, cd];      ENDCASE;    END;    IsVar: PROC [tsei: Symbols.SEIndex] RETURNS [BOOLEAN] =    BEGIN    WITH t: symbols.seb[tsei] SELECT FROM      id => RETURN [FALSE];      cons => WITH t2: t SELECT FROM        ref => RETURN [t2.var]	ENDCASE => RETURN [FALSE];      ENDCASE => RETURN [FALSE];    END;        PutModeName: PROCEDURE [n: Symbols.TransferMode] =    BEGIN    ModePrintName: ARRAY Symbols.TransferMode OF LONG STRING =      ["PROCEDURE"L, "PORT"L, "SIGNAL"L, "ERROR"L, "PROCESS"L, "PROGRAM"L,	"NONE"L];    out[ModePrintName[n], cd];    END;    LUP: TYPE = LONG POINTER TO LONG UNSPECIFIED;  NodePointer: TYPE = LONG POINTER TO Tree.Node;    PrintDefaultValue: PROCEDURE [sei: Symbols.ISEIndex, vf: ValFormat] =    BEGIN    extType: Symbols.ExtensionType;    tree: Tree.Link;    [extType, tree] ¬ SymbolOps.FindExtension[symbols, sei];    IF extType # default THEN RETURN;    out[" ¬ "L, cd];    PrintTreeLink[tree, vf, 0];    END;    PrintTreeLink: PROCEDURE [    tree: Tree.Link, vf: ValFormat, recur: CARDINAL, sonOfDot: BOOLEAN ¬ FALSE] =    BEGIN    IF tree = Tree.Null THEN RETURN;    IF Abort[] THEN {PutLine["  ...aborted"L]; RETURN};    IF recur > 30       THEN {out["(Bug: Tree too deep!)"L, cd]; RETURN};    WITH t: tree SELECT FROM      subtree =>        BEGIN	node: NodePointer = @symbols.tb[t.index];	SELECT node.name FROM	  all =>	    BEGIN	    out["ALL["L, cd];	    WITH v: vf SELECT FROM	      array => PrintTreeLink[	        node.son[1], GetValFormat[v.componentType], recur+1];	      ENDCASE => 	        IF node.nSons = 1 THEN PrintTreeLink[node.son[1], vf, recur+1]		ELSE out["(Bug: not an array?)"L, cd];	    PutChar[']];	    END;	  mwconst, cast, loophole => PrintTreeLink[node.son[1], vf, recur+1];	  nil => out["NIL"L, cd];	  void => out["NULL"L, cd];	  dot, cdot =>	    BEGIN	    IF node.nSons # 2 THEN {	      out["(Bug: Dot node with other than two sons!)"L, cd]; 	      RETURN};	    PrintTreeLink[node.son[1], [other[]], recur+1, TRUE];	    PutChar['.]; --dot	    PrintTreeLink[node.son[2], [other[]], recur+1, TRUE];	    END;	  first, last, size, lengthen => 	    BEGIN	    out[	      SELECT node.name FROM 	        first => "FIRST["L, 		last => "LAST["L, 		size => "SIZE["L, 		ENDCASE => "LONG["L, cd];	    PrintTreeLink[node.son[1], vf, recur+1];	    PutChar[']];	    END;	  construct =>	    BEGIN	    PutChar['[];	    IF node.nSons = 2 THEN PrintTreeLink[node.son[2], vf, recur+1];	    PutChar[']];	    END;	  union =>	    BEGIN	    PrintTreeLink[node.son[1], vf, recur+1];	    PutChar['[];	    PrintTreeLink[node.son[2], vf, recur+1];	    PutChar[']];	    END;	  list =>	    BEGIN	    FOR j: CARDINAL IN [1..node.nSons) DO	      PrintTreeLink[node.son[j], [other[]], recur+1];	      out[", "L, cd];	      ENDLOOP;	    IF node.nSons # 0	      THEN PrintTreeLink[node.son[node.nSons], [other[]], recur+1]; 	    END;	  longTC =>	    BEGIN	    out["LONG "L, cd];	    PrintTreeLink[node.son[1], vf, recur+1];	    END;	  uparrow =>	    BEGIN	    ptr: Tree.Link = node.son[1];	    type: Symbols.CSEIndex;	    WITH p: ptr SELECT FROM	      symbol =>	        type ¬ SymbolOps.NormalType [symbols, SymbolOps.UnderType[symbols, 		  symbols.seb[p.index].idType]];	      subtree => type ¬ TreeOps.DecodeCSei[symbols.tb[p.index].info];	      ENDCASE => type ¬ Symbols.typeANY;	    PrintTreeLink[node.son[1], [other[]], recur+1];	    WITH q: symbols.seb[type] SELECT FROM	      ref => IF ~q.var THEN PutChar['­];	      ENDCASE => PutChar['­];	    END;	  ENDCASE => out["(complicated expression)"L, cd];	END;      hash => PrintHti[t.index];      symbol =>        {IF NOT sonOfDot	  AND symbols.seb[t.index].idCtx = symbols.stHandle.outerCtx	    THEN PutCurrentModuleDot[];	PrintSei[t.index]};      literal =>	BEGIN	WITH lr: t.info SELECT FROM	  word =>	    WITH symbols.ltb[lr.index] SELECT FROM	      short => PrintTypedVal[value, vf];	      long =>	        SELECT length FROM	          2 =>		    BEGIN		    loophole: BOOLEAN ¬ FALSE;		    SELECT vf.tag FROM		      signed => PutLongSigned[LOOPHOLE[@value, LUP]­];		      unsigned => PutLongUnsigned[LOOPHOLE[@value, LUP]­];		      transfer, ref =>		        IF LOOPHOLE[@value, LUP]­ = 0			  THEN out ["NIL"L, cd]			  ELSE loophole ¬ TRUE;		      ENDCASE => loophole ¬ TRUE;		    IF loophole THEN 		      BEGIN		      out["LOOPHOLE["L, cd];		      PutLongUnsigned[LOOPHOLE[@value, LUP]­];		      PutChar[']];		      END;		    END;		  ENDCASE => PutWordSeq[DESCRIPTOR[@value, length]];	      ENDCASE; --shouldn't happen! 	    ENDCASE --string-- => out["(LONG STRING)"L, cd];	  END;      ENDCASE; --shouldn't happen!    END;      IncorrectVersion: SIGNAL = CODE;  NoSymbols: SIGNAL = CODE;  MultipleModules: SIGNAL = CODE;  --Code stolen (and simplified) from ListerRoutines.Load  AcquireSymbols: PROCEDURE [fileName: LONG STRING] =    BEGIN    bcd: BcdOps.BcdBase;    sgb: BcdDefs.Base;    pages: Environment.PageCount ¬ 10;    codefile: MFile.Handle ¬ MFile.ReadOnly[fileName, []];    mh: BcdOps.MTHandle;    bcdseg: MSegment.Handle ¬ MSegment.Create[codefile, [], 0, pages];        BEGIN ENABLE UNWIND => {MSegment.Delete[bcdseg]};    DO      bcd ¬ MSegment.Address[bcdseg];      IF bcd.versionIdent # BcdDefs.VersionID THEN SIGNAL IncorrectVersion;      IF pages = bcd.nPages THEN EXIT;      pages ¬ bcd.nPages;      MSegment.Reset[segment: bcdseg, pages: pages];      ENDLOOP;    mh ¬ @LOOPHOLE[bcd + bcd.mtOffset, BcdDefs.Base][FIRST[BcdDefs.MTIndex]];    sgb ¬ LOOPHOLE[bcd + bcd.sgOffset];    IF bcd.nModules # 1 THEN SIGNAL MultipleModules;    IF sgb[mh.sseg].file # BcdDefs.FTSelf THEN SIGNAL NoSymbols    ELSE      sseg ¬ MSegment.Create[        file: MFile.CopyFileHandle[codefile, []], 	release: [],	fileBase: sgb[mh.sseg].base - SpecialMFile.LeaderPages[],	pages: sgb[mh.sseg].pages + sgb[mh.sseg].extraPages];    END;        MSegment.Delete[bcdseg];    symbols ¬ SymbolTable.Acquire[LOOPHOLE[sseg]];    END;    ReleaseSymbols: PROCEDURE =    BEGIN    SymbolTable.Release[symbols];    SymbolTable.SetCacheSize[0];    MSegment.Delete[sseg ! MSegment.Error => CONTINUE];    END;      Abort: PROCEDURE RETURNS [BOOLEAN]  = {    RETURN[ FALSE -- UserInput.UserAbort[DebugUsefulDefs.fileSW] -- ]};      ShowTypeWithProc: PUBLIC ENTRY PROC [      s: LONG STRING, layout: BOOLEAN ¬ FALSE,    output: Format.StringProc ¬ NIL, clientData: LONG POINTER ¬ NIL] = {    ENABLE UNWIND => NULL;    out ¬ output; cd ¬ clientData; showBits ¬ layout; ShowTypeInternal[s]};      ShowTypeWithHandle: PUBLIC ENTRY PROC [h: IT.Handle, s: LONG STRING] = {    ENABLE UNWIND => NULL;    out ¬ IO.Text; cd ¬ h; showBits ¬ FALSE; ShowTypeInternal[s]};    ShowTypeInternal: INTERNAL PROCEDURE [arg: LONG STRING] =    BEGIN    file: LONG STRING ¬ [IT.MaxModuleString];    item: LONG STRING ¬ [80];    BEGIN        HasWildCard: PROCEDURE [string: LONG STRING] RETURNS [BOOLEAN] =      BEGIN      IF string = NIL OR string.length = 0 THEN RETURN[TRUE];      FOR i: CARDINAL IN [0.. string.length) DO        IF string[i] = '* OR string[i] = '# THEN RETURN[TRUE];	ENDLOOP;      RETURN[FALSE];      END;        MaskSubString: PROCEDURE [      string: String.SubString, mask: LONG STRING,      stringIndex: CARDINAL, maskIndex: CARDINAL] RETURNS [outcome: BOOLEAN] =      BEGIN      -- local variables      i, j: CARDINAL;      IF (mask = NIL) OR (mask.length = 0) THEN RETURN[TRUE];      -- process each character in mask      FOR i IN [maskIndex..mask.length) DO	SELECT mask[i] FROM	  '* =>  -- matches any string of zero or more characters	    BEGIN	    FOR j IN [stringIndex..string.length] DO	      IF MaskSubString[string, mask, j, i + 1] THEN RETURN[TRUE]; ENDLOOP;	    RETURN[FALSE];	    END;	  '# =>  -- matches any single character	    IF stringIndex = string.length THEN RETURN[FALSE]	    ELSE stringIndex ¬ stringIndex + 1;	  ENDCASE =>	    IF stringIndex = string.length	      OR String.LowerCase[	        string.base[string.offset + stringIndex]] # 		  String.LowerCase[mask[i]]	      THEN RETURN[FALSE]	    ELSE stringIndex ¬ stringIndex + 1;	ENDLOOP;      -- string passes mask if entire string has been consumed      outcome ¬ stringIndex = string.length;      END;        PrintThis: PROCEDURE [sei: Symbols.ISEIndex] = {      PutCurrentModuleDot[]; PrintSym[sei, ": "L]; out[";\N"L, cd]};          Format.CR[out, cd];    GetCommand[arg, file, item];    IF file.length = 0 THEN GOTO badSyntax;    module ¬ [file, 0, file.length];    String.AppendString[file, ".bcd"L ! String.StringBoundsFault => GOTO badSyntax];        AcquireSymbols[file !      NoSymbols, IncorrectVersion, MultipleModules => GOTO badFormat;      MFile.Error, MSegment.Error => GOTO badName];    indent ¬ 0;        BEGIN ENABLE UNWIND => ReleaseSymbols[];    IF HasWildCard[item] THEN  -- look at all items      BEGIN      FOR sei: Symbols.ISEIndex ¬         SymbolOps.FirstCtxSe[symbols, symbols.stHandle.outerCtx], SymbolOps.NextSe[symbols, sei] 	UNTIL sei = Symbols.ISENull DO	 IF item = NIL OR item.length = 0 THEN PrintThis[sei]	 ELSE	   BEGIN	   ssd: String.SubStringDescriptor;           SymbolOps.SubStringForHash[symbols, @ssd, symbols.seb[sei].hash];	   IF MaskSubString[@ssd, item, 0, 0] THEN PrintThis[sei];	   END;	 IF Abort[] THEN {PutLine["  ...aborted"L]; EXIT};	 ENDLOOP;      END          ELSE --item specified      BEGIN      ssd: String.SubStringDescriptor ¬ [item, 0, item.length];      hti: Symbols.HTIndex = SymbolOps.FindString[symbols, @ssd];      sei: Symbols.ISEIndex =         SymbolOps.SearchContext[symbols, hti, symbols.stHandle.outerCtx];      PutCurrentModuleDot[];      IF sei = Symbols.ISENull         THEN {	   out[item, cd]; PutLine[" not found"L]}         ELSE {PrintSym[sei, ": "L]; PutChar[';]};      Format.CR[out, cd];      END;    END;         ReleaseSymbols[];        EXITS      badSyntax => PutLine ["Bad syntax in argument; must be Interface.Name or Interface$Name"L];        badFormat => {        out[file, cd]; 	PutLine[": file has bad format"L]};      badName => {        out[file, cd]; PutLine[": file not found"L]};    END;    END;      GetCommand: PROCEDURE [arg, file, item: LONG STRING] =     BEGIN     ENABLE String.StringBoundsFault => GOTO badSyntax;     i, j: CARDINAL ¬ 0;     item.length ¬ 0;     IF String.Empty[arg] THEN GOTO badSyntax;     FOR i IN [0..arg.length) DO       ch: CHARACTER = arg[i];       SELECT ch FROM         IN ['A..'Z], IN ['a..'z], IN ['0..'9] => String.AppendChar[file, ch];	 '., '$ => EXIT;	 ENDCASE => GOTO badSyntax;       REPEAT FINISHED => GOTO noItem;       ENDLOOP;     FOR j IN (i..arg.length) DO       ch: CHARACTER = arg[j];       SELECT ch FROM         '' => LOOP; --skip over single quote	 IN ['A..'Z], IN ['a..'z], IN ['0..'9], '*, '# => String.AppendChar[item, ch];	 ENDCASE => GOTO badSyntax;       ENDLOOP;     EXITS        badSyntax => file.length ¬ 0; 	noItem => {};      END;      SignedFormat: Format.NumberFormat =      [base: 10, zerofill: FALSE, unsigned: FALSE, columns: 0];        UnsignedFormat: Format.NumberFormat =      [base: 10, zerofill: FALSE, unsigned: TRUE, columns: 0];      PutBlanks: PROC [n: CARDINAL] = INLINE {     Format.Blanks [out, n, cd]};        PutChar: PROC [c: CHARACTER] = INLINE {     Format.Char [out, c, cd]};      PutLine: PROC [s: LONG STRING] = INLINE {     Format.Line [out, s, cd]};     PutSigned: PROCEDURE [val: UNSPECIFIED] = INLINE {     Format.Number[out, val, SignedFormat, cd]};        PutUnsigned: PROCEDURE [val: UNSPECIFIED] = INLINE {     Format.Number[out, val, UnsignedFormat, cd]};        PutLongSigned: PROCEDURE [val: LONG UNSPECIFIED] = INLINE {     Format.LongNumber[out, val, SignedFormat, cd]};        PutLongUnsigned: PROCEDURE [val: LONG UNSPECIFIED] = INLINE {     Format.LongNumber[out, val, UnsignedFormat, cd]};      PutCurrentModuleDot: PROCEDURE = {     Format.SubString[out, @module, cd];      PutChar['.]};      PutWordSeq: PROCEDURE [seq: LONG DESCRIPTOR FOR ARRAY OF UNSPECIFIED] =     BEGIN     PutChar['[];     FOR i: CARDINAL IN [0..LENGTH[seq]-1) DO       PutUnsigned[seq[i]];       out[", "L, cd];       ENDLOOP;     PutUnsigned[seq[LENGTH[seq]-1]];     PutChar[']];     END;    END...    
-- RiggleCheckImpl.mesaDIRECTORYBoot, BootFile, Environment, PageMap, ProcessorFace, Riggle, RealMemory, Space, WVMPrivate, WorldVM;RiggleImpl: PROGRAM   IMPORTS PageMap, ProcessorFace, RealMemory, Space, Environment  EXPORTS Riggle, WorldVM  SHARES PageMap = {    World: TYPE = LONG POINTER TO WorldObject;  WorldObject: PUBLIC TYPE = WVMPrivate.WorldObject;  OutloadWorld: TYPE = WVMPrivate.OutloadWorld;      memoryOutloadSize: Environment.PageCount = 2411; -- for a 3.7 MB Daybreak    pageZero: Environment.PageNumber = FIRST[Environment.PageNumber];  pageGerm: PageNumber = Boot.pageGerm + Boot.mdsiGerm*Environment.maxPagesInMDS;  -- (page 1)  pageEndGermVM: PageNumber = pageGerm + Boot.countGermVM;  -- end VM page usable by Germ.  RiggleCheckVM: PUBLIC PROCEDURE    RETURNS [BOOLEAN] = {    pagesToOutload: Environment.PageCount ¬ 0;    htOverhead: Environment.PageCount;    page, pageIntervalEnd: Environment.PageNumber;    -- count up the number of pages of VM backed by a real page + header/trailer pages     [page, pageIntervalEnd] ¬ GetNextPilotVM[pageZero];    DO      IF PageMap.IsMapped[page] THEN	pagesToOutload ¬ pagesToOutload + 1;      page ¬ page+1;      IF page >= pageIntervalEnd THEN {	[page, pageIntervalEnd] ¬ GetNextPilotVM[page];	IF page = pageIntervalEnd THEN EXIT  -- done with VM      };    ENDLOOP;    -- add in Header/Trailer overhead    htOverhead ¬ (pagesToOutload + BootFile.maxEntriesPerHeader - 1) / BootFile.maxEntriesPerHeader;    pagesToOutload ¬ pagesToOutload + htOverhead;    RETURN [pagesToOutload <= memoryOutloadSize];   };    PageNumber: TYPE = Environment.PageNumber;  PageCount: TYPE = Environment.PageCount;    GetNextPilotVM: PROC [page: PageNumber]    RETURNS [firstPage, endPage: PageNumber] =    BEGIN    PageBeforeOrAtInterval: PROC [pageInterval, pageEndInterval: PageNumber]      RETURNS [BOOLEAN] =      BEGIN      -- If GetNextPilotVM.page is <= pageInterval,      -- then sets GetNextPilotVM.firstPage, .endPage and returns TRUE.       IF pageEndInterval = pageInterval  -- (Germ caused null interval)        OR page > pageInterval THEN RETURN[FALSE]      ELSE --page <= pageInterval and non-null interval-- {        firstPage ¬ pageInterval; endPage ¬ pageEndInterval; RETURN[TRUE]};      END;    pageStart: PageNumber;    count: PageCount;    pageNext: PageNumber ¬ pageZero;  -- end of current interval / start of next.    --REPEAT .. UNTIL interval at or after page--    DO      [pageStart, count] ¬ ProcessorFace.GetNextAvailableVM[pageNext];      IF count = 0 THEN RETURN[0, 0];  -- no further available VM.      pageNext ¬ pageStart + count;  -- end of current interval      IF pageGerm IN [pageStart..pageNext) THEN {        IF pageEndGermVM > pageNext THEN ERROR;  -- Germ slops onto I/O page.        IF PageBeforeOrAtInterval[pageStart, pageGerm] THEN RETURN;        IF PageBeforeOrAtInterval[pageEndGermVM, pageNext] THEN RETURN}      ELSE IF PageBeforeOrAtInterval[pageStart, pageNext] THEN RETURN;      ENDLOOP;    END;  --GetNextPilotVM--    RiggleWorld: PUBLIC PROC[world: World] RETURNS[BOOLEAN] = {    RETURN[WITH world SELECT FROM          outload => riggle, --(file = File.nullFile),-- ENDCASE => FALSE]};  RiggleMapBootSpace: PUBLIC PROC[world: OutloadWorld] = {    -- copied from the TurboSwap germ's ProcessorHeadDove.mesa    -- it's documented better there!    germPageCount: CARDINAL = 40;    ioRegionPageCount: CARDINAL = 64;    reservedPageCount: CARDINAL = 256; -- ICK!!!    lastTemp, firstTemp: PageNumber;    first, last, clientOutLoad, outloadableMemory, denom, div, mod, x, outloadSize: CARDINAL;    [count: , realPageMin: firstTemp, realPageMax: lastTemp] ¬ RealMemory.Count[];     last ¬ CARDINAL[lastTemp];    first ¬ CARDINAL[firstTemp];    outloadableMemory ¬ (last - first + 1) + reservedPageCount - germPageCount - ioRegionPageCount;    denom ¬ 3 * BootFile.maxEntriesPerTrailer + 2;    div ¬ (outloadableMemory - 4) / denom;    mod ¬ (outloadableMemory - 4) MOD denom;    x ¬ (BootFile.maxEntriesPerTrailer * div + (BootFile.maxEntriesPerTrailer * mod + 2 * BootFile.maxEntriesPerHeader + 2) / denom);    outloadSize ¬ (x + 1 + (x - BootFile.maxEntriesPerHeader + BootFile.maxEntriesPerTrailer - 1 + BootFile.maxEntriesPerTrailer - 1) / BootFile.maxEntriesPerTrailer);    clientOutLoad ¬ last - outloadSize;    -- end copy    BEGIN      realPage: CARDINAL;      vmpage: PageNumber;      world.bootArea.bootSpace ¬ Space.Allocate[last - clientOutLoad];      realPage ¬ clientOutLoad;      vmpage ¬	Environment.PageFromLongPointer[world.bootArea.bootSpace.pointer];      THROUGH [0..world.bootArea.bootSpace.count) DO	PageMap.SetMapFlags[virtual: vmpage, real: realPage, 	  flags: PageMap.flagsClean];	realPage ¬ realPage + 1;	vmpage ¬ vmpage + 1;      ENDLOOP;    END };        RiggleUnMapBootSpace: PUBLIC PROC[world: OutloadWorld] = {    IF world.bootArea.bootSpace.pointer # NIL    THEN {      vmpage: PageNumber;      vmpage ¬ Environment.PageFromLongPointer[world.bootArea.bootSpace.pointer];      THROUGH [0..world.bootArea.bootSpace.count) DO	PageMap.SetMapFlags[virtual: vmpage, real: 0, 	  flags: PageMap.flagsVacant];	vmpage ¬ vmpage + 1;      ENDLOOP;      Space.Deallocate[world.bootArea.bootSpace];      world.bootArea.bootSpace.pointer ¬ NIL}};    }..
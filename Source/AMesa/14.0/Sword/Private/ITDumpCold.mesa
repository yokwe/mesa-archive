-- File: ITDumpCold.mesa - last edit:-- Litman              15-Apr-87 11:36:05-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.DIRECTORY  AMLoadstate USING [Error],  Ascii USING [SP],  Environment USING [bitsPerWord],  IB USING [BadLongNum],  IC USING [GetSignalDesc, GFFromControlLink],  IH USING [Printer, PrintHandle, PrintRec],  Inline USING [DBITSHIFT, LongCOPY, LongDivMod, LongMult],  IO USING [AllocFob, Char, Decimal, Display, DisplayFoo, FreeNode, Interpret, Node, options, Text, UserAbort, UserAborted, zone],  IP USING [CheckClass, CheckForHiddenPadding, DerefProcDesc, DisplayInMsg, FindField, GetControlLink, GetDesc, GetLongDesc, GetValue, LinkToIsei, Normalize, NotAProcedure, Signal, TypeForSe],  IQ USING [DisplayGF, InvalidFrame, PreDeclared, ValidateGF],  IS USING [CompareSes, HashVal, LongNum, NullVariant, Num, PrintUCS, WriteError],  IT USING [ArrayHandle, ArrayInfo, ArraySEIndex, BitAddress, ControlLink, CSEIndex, Fob, Foo, FooProc, GFHandle, Handle, ISEIndex, LongDesc, NullFob, SEIndex, SequenceSEIndex, SignalDesc, TransferSEIndex, RecordSEIndex],  IY USING [ShowNum],  PrincOps USING [ControlLink, nullLink, Port, unboundLink],  PrincOpsExtras2 USING [ControlLink, UnboundLink],  String USING [CopyToNewString],  SymbolOps USING [BitsPerElement, Cardinality, ToCard],  Symbols USING [CSENull, HTNull, ISENull, SENull, TransferMode],  WorldVMOps USING [Process, Read];ITDumpCold: PROGRAM  IMPORTS AMLoadstate, Inline, IB, IC, IO, IP, IQ, IS, IY, String, SymbolOps, WorldVMOps  EXPORTS IH, IS = {  TriedToPrintWrongType: ERROR [foo: IT.Foo] = CODE;  BadTag: ERROR = CODE;    printers: PUBLIC IH.PrintHandle ¬ NIL;    AddPrinter: PUBLIC PROCEDURE [h: IT.Handle, type: LONG STRING, proc: IH.Printer] = {    tsei: IT.CSEIndex ¬ Symbols.CSENull;    p: IH.PrintHandle;    GetType: IT.FooProc = {tsei ¬ IP.TypeForSe[h, f.tsei]};    IO.Interpret[h, type, GetType ! ANY => CONTINUE];    IF tsei # Symbols.CSENull AND proc # NIL THEN {      FOR p ¬ printers, p.link UNTIL p = NIL DO	IF p.tsei # Symbols.SENull THEN LOOP;	IF IS.CompareSes[h, tsei, p.tsei] THEN {p.proc ¬ proc; RETURN};	ENDLOOP;      p ¬ IO.Node[h, SIZE[IH.PrintRec]];      p­ ¬ [link: printers, sym: String.CopyToNewString[type, IO.zone], tsei: tsei, proc: proc];      printers ¬ p}};    RemovePrinter: PUBLIC PROCEDURE [h: IT.Handle, type: LONG STRING, proc: IH.Printer] = {    tsei: IT.CSEIndex ¬ Symbols.CSENull;    GetType: IT.FooProc = {tsei ¬ IP.TypeForSe[h, f.tsei]};    IO.Interpret[h, type, GetType ! ANY => CONTINUE];    IF tsei # Symbols.CSENull THEN       FOR p: LONG POINTER TO IH.PrintHandle ¬ @printers, @p.link UNTIL p­ = NIL DO	IF p.tsei # Symbols.SENull AND IS.CompareSes[h, tsei, p.tsei] AND proc = p.proc THEN {	  temp: IH.PrintHandle ¬ p­; p­ ¬ p.link; IO.FreeNode[h, temp];	  RETURN };	ENDLOOP};    ResetPrinters: PUBLIC PROCEDURE[h: IT.Handle] = {    Type: IT.FooProc = {p.tsei ¬ IP.TypeForSe[h, f.tsei]};    p: LONG POINTER TO IH.PrintRec;    FOR p ¬ printers, p.link UNTIL p = NIL DO       p.tsei ¬ Symbols.SENull;       ENDLOOP;    FOR p ¬ printers, p.link UNTIL p = NIL DO      IO.Interpret[h, p.sym, Type ! ANY => CONTINUE];      ENDLOOP};        SeqToArray: PUBLIC PROCEDURE [h: IT.Handle, f: IT.Foo, sei: IT.SequenceSEIndex, pad: CARDINAL, ai: IT.ArrayHandle] = {    tag: IT.Fob ¬ f­;    ba: IT.BitAddress;    words: CARDINAL;    isei: IT.ISEIndex;    IF ~h.seb[sei].controlled THEN {      ai­ ¬ [start: 0, stop: LAST[CARDINAL], length: LAST[CARDINAL], addr: tag.addr, type: h.seb[sei].componentType, there: TRUE,         packing: CARDINAL[SymbolOps.BitsPerElement[h.sym, h.seb[sei].componentType, h.seb[sei].packed]]];      RETURN};    isei ¬ h.seb[sei].tagSei;    tag.tsei ¬ IP.TypeForSe[h, isei];    [tag.words, tag.bits] ¬ IP.Normalize[SymbolOps.ToCard[h.seb[isei].idInfo]];    IF tag.bits + tag.addr.offset > Environment.bitsPerWord THEN ERROR BadTag;    ba ¬ [base: tag.addr.base, offset: ];    [words, ba.offset] ¬ IP.Normalize[tag.addr.offset+tag.bits];    ba.base ¬ tag.words + ba.base + words;    IP.GetValue[h, @tag];    ai­ ¬ [start: 0, stop: tag.addr.base­, length: tag.addr.base­, addr: ba, type: h.seb[sei].componentType, there: TRUE,      packing: CARDINAL[SymbolOps.BitsPerElement[h.sym, h.seb[sei].componentType, h.seb[sei].packed]]] };    Sequence: PUBLIC PROCEDURE [h: IT.Handle, f: IT.Foo, pad: CARDINAL, sei: IT.SequenceSEIndex, variant: PROCEDURE[h: IT.Handle] RETURNS [IT.RecordSEIndex] ¬ IS.NullVariant] = {    ai: IT.ArrayInfo;    seq: IT.Foo;    IF ~h.seb[sei].controlled THEN {IO.Text["(?) ..."L, h]; RETURN};    seq ¬ IP.FindField[h, f, pad, h.seb[sei].tagSei];    SeqToArray[h, seq, sei, pad, @ai];    Elements[h, @ai ! IO.UserAborted => {ControlDel[h]; CONTINUE}]};    Array: PUBLIC PROCEDURE [h: IT.Handle, f: IT.Foo] = {    sei: IT.ArraySEIndex ¬ IP.CheckClass[h, array, f];    ArrayCommon[h, sei, f.addr, f.there, CARDINAL[SymbolOps.Cardinality[h.sym, h.seb[sei].indexType]]]};    ArrayCommon: PROCEDURE [h: IT.Handle, tsei: IT.SEIndex, ba: IT.BitAddress, there: BOOLEAN, length: CARDINAL] = {    csei: IT.CSEIndex ¬ IP.TypeForSe[h, tsei];    sei: IT.ArraySEIndex;    ai: IT.ArrayInfo;    IF h.seb[csei].typeTag = array THEN sei ¬ LOOPHOLE[csei] ELSE ERROR TriedToPrintWrongType[NIL];    ai ¬ [start: 0, stop: length, length: length, addr: ba, there: there, type: h.seb[sei].componentType,      packing: CARDINAL[SymbolOps.BitsPerElement[h.sym, h.seb[sei].componentType, h.seb[sei].packed]]];    Elements[h, @ai ! IO.UserAborted => {ControlDel[h]; CONTINUE}]};    LongArrayDesc: PUBLIC PROCEDURE [h: IT.Handle, f: IT.Foo] = {    d: IT.LongDesc;    sei: IT.ArraySEIndex;    [d, sei] ¬ IP.GetLongDesc[h, f];    IO.Text["DESCRIPTOR["L, h]; IS.LongNum[h, d.base, [pointer[]]]; IO.Char[h, ',];    MyDecimal[h, d.length]; IO.Char[h, ']];    IF d.base = NIL THEN RETURN;    ArrayCommon[h, sei, [d.base, d.offset], TRUE, d.length] };    ArrayDesc: PUBLIC PROCEDURE [h: IT.Handle, f: IT.Foo] = {    d: IT.LongDesc;    sei: IT.ArraySEIndex;    [d, sei] ¬ IP.GetDesc[h, f];    IO.Text["DESCRIPTOR["L, h]; IS.LongNum[h, d.base, [pointer[]]]; IO.Char[h, ',];    MyDecimal[h, d.length]; IO.Char[h, ']];    IF d.base = NIL THEN RETURN;    ArrayCommon[h, sei, [d.base, d.offset], TRUE, d.length] };    Elements: PUBLIC PROCEDURE [h: IT.Handle, ai: IT.ArrayHandle, printAll: BOOLEAN ¬ FALSE] = {    fob: IT.Fob ¬ IT.NullFob;    fob.tsei ¬ ai.type;    fob.there ¬ ai.there;    fob.typeOnly ¬ FALSE;    [fob.words, fob.bits] ¬ IP.Normalize[ai.packing];    IP.CheckForHiddenPadding[h, @fob];    ai.addr.offset ¬ ai.addr.offset + fob.addr.offset;    fob.addr ¬ CalculateAddr[h, ai, ai.start];    IF ~fob.there THEN fob.addr.base ¬ CopyHeapNode[h, ai, fob.addr.base];    IO.Char[h, '(]; MyDecimal[h, ai.length]; IO.Text[")["L, h];    FOR i: CARDINAL IN [ai.start..ai.stop) DO      f: IT.Foo  ¬ IO.AllocFob[h];      IF i # ai.start THEN IO.Text[", "L, h];      f­ ¬ fob;      IF i = 3 AND ~printAll AND ai.length > IO.options.elementCnt THEN {	f.addr ¬ CalculateAddr[h, ai, ai.stop-1]; 	IO.Text["..., "L, h]; IO.Display[h, f, TRUE]; EXIT};      IO.Display[h, f, TRUE];      fob.addr ¬ IF ~fob.there THEN CalculateAddr[h, ai, i+1] ELSE NextAddr[h, fob.addr, ai.packing];      IF IO.UserAbort[h] THEN {ControlDel[h]; RETURN};      ENDLOOP;    IO.Char[h, ']]};    NextAddr: PROCEDURE [h: IT.Handle, ba: IT.BitAddress, packing: CARDINAL] RETURNS [IT.BitAddress] = INLINE {    words, bits: CARDINAL;    [words, bits] ¬ IP.Normalize[packing];    SELECT TRUE FROM      bits = 0 => ba.base ¬ ba.base + words;      bits + ba.offset = 16 => {ba.base ¬ ba.base + 1; ba.offset ¬ 0};      ENDCASE => ba.offset ¬ ba.offset + bits;    RETURN[ba]};        BytePointer: TYPE = MACHINE DEPENDENT RECORD [      p(0:0..31): SELECT OVERLAID * FROM	byte => [	  fill2(0:0..14): [0..77777B],	  whichByte(0:15..15): [0..1],	  tag(1:0..0): [0..1],	  fill1(1:1..15): [0..77777B]],	pointer => [pointer(0:0..31): LONG POINTER],	ENDCASE];    CalculateAddr: PUBLIC PROCEDURE [h: IT.Handle, ai: IT.ArrayHandle, n: CARDINAL] RETURNS [ba: IT.BitAddress] = {    OPEN Inline, bp: LOOPHOLE[ai.addr.base, BytePointer];    words, offset: CARDINAL;    IF bp.tag = 1 -- BytePointer    THEN {      bp.tag ¬ 0;      bp.pointer ¬ Inline.DBITSHIFT[bp.pointer, -1]};    ba.useStack ¬ ai.addr.useStack;    [words, offset] ¬ IP.Normalize[ai.packing];    ba.base ¬ ai.addr.base + LongMult[words, n];    [words, ba.offset] ¬ LongDivMod[LongMult[offset, n], Environment.bitsPerWord];    ba.base ¬ ba.base + words;    [words, ba.offset] ¬ IP.Normalize[ba.offset+ai.addr.offset];    ba.base ¬ ba.base + words;    IF ~ai.there THEN ba.base ¬ CopyHeapNode[h, ai, ba.base] };    CopyHeapNode: PROCEDURE [h: IT.Handle, ai: IT.ArrayHandle, node: LONG POINTER] RETURNS [lp: LONG POINTER] = INLINE {    cnt: CARDINAL = (ai.packing+Environment.bitsPerWord-1)/Environment.bitsPerWord;    lp ¬ IO.Node[h, cnt];    Inline.LongCOPY[from: node, nwords: cnt, to: lp]};      BadDesc: PROCEDURE [h: IT.Handle, cl: IT.ControlLink] = {    pcl: PrincOps.ControlLink = LOOPHOLE[cl, PrincOps.ControlLink];    SELECT TRUE FROM      pcl = PrincOps.nullLink => IO.Text["[NIL]"L, h];      pcl = PrincOps.unboundLink => IO.Text["[Unbound]"L, h];      pcl = LOOPHOLE[PrincOpsExtras2.UnboundLink] => IO.Text["[Unbound]"L, h];      --IC.GFFromControlLink[h, cl] = NILGF => IS.BadNum[h, pcl.pc];      ENDCASE => IB.BadLongNum[h, LOOPHOLE[cl]] };    XferName: PUBLIC PROCEDURE [h: IT.Handle, cl: IT.ControlLink, isei: IT.ISEIndex] = {    IF isei = Symbols.ISENull THEN BadDesc[h, cl] ELSE IS.HashVal[h, isei]};    XferFrame: PUBLIC PROCEDURE [h: IT.Handle, cl: IT.ControlLink] = {    IP.DisplayInMsg[h, IC.GFFromControlLink[h, cl], "module"L]};    Sig: PUBLIC PROCEDURE [h: IT.Handle, cl: IT.SignalDesc] = {    WITH sd: h.swapData SELECT FROM      uncaughtSignal => IF sd.signal = LOOPHOLE[cl] THEN {IS.PrintUCS[h]; RETURN};      ENDCASE;    IF IQ.PreDeclared[h, cl, TRUE].found THEN RETURN;    XferName[h, LOOPHOLE[cl], IP.Signal[h, cl]];    XferFrame[h, LOOPHOLE[cl]]};    Xfer: PUBLIC PROCEDURE [h: IT.Handle, f: IT.Foo] = {    sei: IT.TransferSEIndex ¬ IP.CheckClass[h, transfer, f];    SELECT h.seb[sei].mode FROM      process  => { IP.GetValue[h, f]; Process[h, f.addr.base­] };      port => { IP.GetValue[h, f]; Port[h, f.addr.base] };      signal => {IO.Text["SIGNAL "L, h]; Sig[h, IC.GetSignalDesc[h, f]] };      error => {IO.Text["ERROR "L, h]; Sig[h, IC.GetSignalDesc[h, f]] };      proc => Proc[h, IP.GetControlLink[h, f]];      program => Prog[h, IP.GetControlLink[h, f]];      ENDCASE => ERROR TriedToPrintWrongType[f]};    Proc: PUBLIC PROCEDURE [h: IT.Handle, cl: IT.ControlLink] = {    ENABLE IQ.InvalidFrame => GOTO bad;    newCl: IT.ControlLink;    IO.Text["PROCEDURE "L, h];    IF (newCl ¬ IP.DerefProcDesc[h, cl ! IP.NotAProcedure => GOTO bad]) # cl THEN {      IO.Text["(indirect, "L, h];       IS.Num[h, LOOPHOLE[cl, PrincOps.ControlLink].link, [pointer[]]];       IO.Text[") "L, h]};    XferName[h, newCl, IP.LinkToIsei[h, newCl ! IP.NotAProcedure, AMLoadstate.Error => GOTO bad]];    XferFrame[h, newCl];    EXITS bad => BadDesc[h, cl]};    Port: PUBLIC PROCEDURE [h: IT.Handle, port: LONG POINTER TO PrincOps.Port] = {    IO.Text["PORT ["L, h];     IS.LongNum[h, port.in, [card[]]];     IO.Text[", "L, h];     IS.LongNum[h, port.out, [card[]]];     IO.Char[h, ']]};    Process: PUBLIC PROCEDURE [h: IT.Handle, psb: UNSPECIFIED] = {    IO.Text["PROCESS ["L, h]; IY.ShowNum[h, psb, IO.options.lpRadix, FALSE]; IO.Char[h, ']]};    Prog: PUBLIC PROCEDURE [h: IT.Handle, cl: IT.ControlLink] = {    gf: IT.GFHandle = IC.GFFromControlLink[h, cl];    IF IQ.ValidateGF[h, gf] THEN IQ.DisplayGF[h, gf, "PROGRAM"L] ELSE BadDesc[h, cl]};    Opaque: PUBLIC PROCEDURE [h: IT.Handle, f: IT.Foo] = {    osei: IT.CSEIndex ¬ IP.CheckClass[h, opaque, f];    WITH h.seb[osei] SELECT FROM      opaque => {	IF ~lengthKnown AND length = LAST[CARDINAL] THEN {	  -- somebody did Attach Opaque	  -- reset the type of the foo and try again	  f.tsei ¬ id;	  f.hti ¬ Symbols.HTNull;	  IO.DisplayFoo[h, f];	  RETURN};	IF id # Symbols.ISENull THEN IS.HashVal[h, id];	IF lengthKnown AND length # 0 THEN {	  size: CARDINAL = length/Environment.bitsPerWord;	  IO.Char[h, '(]; IS.Num[h, size, [card[]]]; IO.Text["):"L, h];	  FOR j: CARDINAL IN [0..size) DO	    IO.Char[h, ' ];	    IS.Num[h, IF f.there THEN WorldVMOps.Read[h.world, f.addr.base+j] ELSE ReadMem[h, f.addr.base+j], [card[]]];	    IO.Char[h, Ascii.SP];	    IF IO.UserAbort[h] THEN {ControlDel[h]; RETURN};	    ENDLOOP}};      ENDCASE};    ReadMem: PUBLIC PROCEDURE [h: IT.Handle, p: LONG POINTER] RETURNS [UNSPECIFIED] = { RETURN[p­] };    MyDecimal: PROCEDURE [h: IT.Handle, u: UNSPECIFIED] = INLINE {    IO.Decimal[h, LOOPHOLE[u, INTEGER]]};    ControlDel: PROCEDURE[h: IT.Handle] = {    IS.WriteError[h, XXX] };      ModeName: PUBLIC PROCEDURE [h: IT.Handle, n: Symbols.TransferMode] = {    ModePrintName: ARRAY Symbols.TransferMode OF STRING = ["PROCEDURE"L, "PORT"L, "SIGNAL"L, "ERROR"L, "PROCESS"L, "PROGRAM"L, "NONE"L];    IO.Text[ModePrintName[n], h] };  }.
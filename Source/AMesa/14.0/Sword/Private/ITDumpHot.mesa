-- Copyright (C) 1986  by Xerox Corporation. All rights reserved. -- ITDumpHot.mesa; modified by DIRECTORY  Ascii USING [CR, DEL, LF, NUL, SP, TAB],  ComData USING [typeStringBody],  Inline USING [LongCOPY],  IB, IH, IO, IP, IR, IS, IT, IY,  String USING [SubString, SubStringDescriptor],  SymbolOps,  Symbols,  Types USING [Equivalent, Handle],  WorldVMOps;  ITDumpHot: PROGRAM  IMPORTS com: ComData, Inline, IH, IO, IP, IR, IS, SymbolOps, Types, WorldVMOps  EXPORTS IO, IB, IS, IY = {  OPEN IT;  SENull: Symbols.SEIndex = Symbols.SENull;  HTNull: Symbols.HTIndex = Symbols.HTNull;  RecordSENull: Symbols.RecordSEIndex = Symbols.RecordSENull;  NoTypeInfo: PUBLIC ERROR [sei: SEIndex] = CODE;  StrangeRecord: ERROR = CODE;      UserPrint: PROCEDURE [h: Handle, f: Foo] RETURNS [printed: BOOLEAN] = {    p: LONG POINTER TO IH.PrintRec;    aborted: BOOLEAN ¬ FALSE;    CallClient: PROC [h: Handle, foo: LONG UNSPECIFIED] = {      printed ¬ p.proc[foo ! IO.UserAborted => {aborted ¬ TRUE; CONTINUE}] };    printed ¬ FALSE;    IF f.tsei = SENull THEN RETURN;    FOR p ¬ IH.printers, p.link UNTIL p = NIL DO      IF p.tsei = SENull THEN LOOP;      IF CompareSes[h, p.tsei, f.tsei] THEN 	IS.Umbrella[h, f, CallClient ! ANY => {p.tsei ¬ SENull; CONTINUE}];      IF aborted THEN SIGNAL IO.UserAborted;      IF printed THEN RETURN;      ENDLOOP};      CompareSes: PUBLIC PROC [h: Handle, sei1, sei2: Symbols.SEIndex]     RETURNS [print: BOOLEAN] = {    left: Types.Handle ¬ [h.sym, IP.TypeForSe[h, sei1]];    right: Types.Handle ¬ [h.sym, IP.TypeForSe[h, sei2]];    IF right.sei = Symbols.typeANY THEN RETURN[FALSE];    RETURN[Types.Equivalent[type1: left, type2: right]]};    DisplayFoo: PUBLIC FooProc = {    Display[h, f ! IP.NotRelocated => IP.AbortWithError[h, spare2, f.hti]]};    Display: PUBLIC PROCEDURE [h: Handle, f: Foo, rec: BOOLEAN ¬ FALSE] = {    csei: CSEIndex;    IF f = NIL THEN RETURN;    IF f.typeOnly THEN      WITH h.seb[f.tsei] SELECT FROM	id => IS.Type[h, LOOPHOLE[f.tsei]];	ENDCASE => ERROR NoTypeInfo[f.tsei]    ELSE {      ENABLE WorldVMOps.AddressFault => {	IS.WriteError[h, badAddress, FALSE]; 	IS.LongNum[h, addr, [pointer[]]]; 	IO.Char[h, ']];	CONTINUE};      IF f.hti # HTNull THEN {	IF f.indent # 0 THEN IO.Blanks[h, f.indent];	HtiVal[h, f.hti];	IO.Text[IF rec THEN ":"L ELSE " = "L, h]};      IF ~UserPrint[h, f] THEN {	csei ¬ IP.TypeForSe[h, f.tsei];	IF csei = com.typeStringBody THEN {	  IF ~f.there THEN ERROR IP.NotHere;	  StringCommon[h, f.addr.base]; 	  IF ~rec THEN IO.EOL[h];	  RETURN};	WITH h.seb[csei] SELECT FROM	  basic, enumerated, ref, arraydesc,	  relative, subrange, long, real, zone => {	    IP.GetValue[h, f];	    IF f.there THEN IP.AbortWithError[h, nilChk, HTNull] };	  transfer, record, array, union, opaque => NULL;	  ENDCASE;	WITH h.seb[csei] SELECT FROM	  basic, ref, enumerated => TypedNum[h, f.addr.base­, f.tsei];	  zone => Zone[h, f, mds];	  relative => Relative[h, f];	  record => Record[h, f];	  array => IS.Array[h, f];	  arraydesc => IS.ArrayDesc[h, f];	  transfer => IS.Xfer[h, f];	  union => VariantPart[h, f, csei];	  subrange => Subrange[h, f];	  long => Long[h, f];	  real => IS.Real[h, f];	  opaque => IS.Opaque[h, f];	  sequence => {	    ai: ArrayInfo;	    IS.SeqToArray[h, f, LOOPHOLE[csei], 0, @ai];	    IS.Elements[h, @ai ! IO.UserAborted => {IS.WriteError[h, XXX]; CONTINUE}]};	  ENDCASE }};    IF ~rec THEN IO.EOL[h] };        Zone: PUBLIC PROCEDURE [h: Handle, f: Foo, short: BOOLEAN] = {    lp: LONG POINTER TO LONG UNSPECIFIED = f.addr.base;    IF short THEN TypedNum[h, f.addr.base­, f.tsei]     ELSE TypedLongNum[h, lp­, f.tsei] };      Basic: PUBLIC PROCEDURE [h: Handle, f: Foo] = {    [] ¬ IP.CheckClass[h, basic, f];    TypedNum[h, f.addr.base­, f.tsei] };      Pointer, StringPrinter: PUBLIC PROCEDURE [h: Handle, f: Foo] = {    [] ¬ IP.CheckClass[h, ref, f];    TypedNum[h, f.addr.base­, f.tsei] };      Relative: PUBLIC PROCEDURE [h: Handle, f: Foo] = {    csei: Symbols.CSEIndex ¬ IP.TypeForSe[h, f.tsei];    [] ¬ IP.CheckClass[h, relative, f];    WITH h.seb[csei] SELECT FROM      relative => {	offsetT: Symbols.CSEIndex = IP.TypeForSe[h, offsetType];	WITH h.seb[offsetT] SELECT FROM	  arraydesc => {f.tsei ¬ offsetT; IO.Text[" RELATIVE "L, h]; IS.ArrayDesc[h, f]};	  long => {	    csei: Symbols.CSEIndex ¬ IP.TypeForSe[h, rangeType];	    IF h.seb[csei].typeTag = arraydesc 	    THEN { f.tsei ¬ offsetT; IO.Text[" RELATIVE "L, h]; Long[h, f] }  	    ELSE {	      p: LONG POINTER TO LONG UNSPECIFIED = LOOPHOLE[f.addr.base];	      TypedLongNum[h, p­, f.tsei] }};	  ENDCASE => TypedNum[h, f.addr.base­, f.tsei]};      ENDCASE => ERROR };      Enumerated: PUBLIC PROCEDURE [h: Handle, f: Foo] = {    [] ¬ IP.CheckClass[h, enumerated, f];    TypedNum[h, f.addr.base­, f.tsei] };      NullVariant: PUBLIC PROC[Handle] RETURNS [Symbols.RecordSEIndex] = {    RETURN[Symbols.RecordSENull] };    Record: PUBLIC PROCEDURE [h: Handle, f: Foo] = {    variant: RecordSEIndex ¬ IP.CheckClass[h, record, f];    root: RecordSEIndex ¬ SymbolOps.RecordRoot[h.sym, variant];    VariantType: PROC[Handle] RETURNS [RecordSEIndex] = { RETURN[variant] };    IF root # RecordSENull THEN f.tsei ¬ root;    IF root = variant THEN variant ¬ RecordSENull;    RecordCommon[h, f, VariantType]};      RecordCommon: PROC [h: Handle, f: Foo, variant: PROC[Handle] RETURNS [Symbols.RecordSEIndex]] = {    rsei: RecordSEIndex ¬ IP.CheckClass[h, record, f];    IP.CopyMore[h, rsei];    WITH h.seb[f.tsei] SELECT FROM      id => HtiVal[h, hash];      ENDCASE;    FieldCtx[h, f, h.seb[rsei].fieldCtx, IP.Pad[h, f, rsei], variant, rsei] };      FieldCtx: PUBLIC PROCEDURE [h: Handle, f: Foo, ctx: Symbols.CTXIndex, pad: CARDINAL,    variant: PROC[Handle] RETURNS [Symbols.RecordSEIndex], rsei: Symbols.RecordSEIndex] = {    displayAsFields: BOOLEAN = f.displayFieldsOfRecordsAs = fields;    root,isei: ISEIndex;     first: BOOLEAN ¬ TRUE;    csei: CSEIndex;    GetNextSe: PROC = {      WITH id: h.seb[isei] SELECT FROM	sequential =>  isei ¬ isei + SIZE[sequential id Symbols.SERecord];	linked =>  IF (isei ¬ id.link) = root THEN isei ¬ Symbols.ISENull;	ENDCASE => isei ¬ Symbols.ISENull };    isei ¬ root ¬ h.ctxb[ctx].seList;    IF displayAsFields THEN IO.Char[h, '[];    DO      IF isei = Symbols.ISENull THEN EXIT;      IF h.seb[isei].constant 	OR h.seb[isei].idType = Symbols.typeTYPE 	OR h.seb[isei].idCtx # ctx THEN { GetNextSe[]; LOOP };      IF displayAsFields AND ~first THEN IO.Text[", "L, h];      csei ¬ IP.TypeForSe[h, isei];      WITH h.seb[csei] SELECT FROM 	union => {	  temp: BOOLEAN = f.addr.useStack;	  f.addr.useStack ¬ FALSE;	  PrintVariant[h, f, pad, LOOPHOLE[csei], variant];	  f.addr.useStack ¬ temp };	sequence => {	  HashVal[h, isei]; IO.Char[h, ':]; 	  IS.Sequence[h, f, pad, LOOPHOLE[csei], variant]};	ENDCASE => {	  temp: Foo ¬ IP.FindField[h, f, pad, isei];	  IF temp.typeOnly THEN { GetNextSe[]; LOOP };	  temp.addr.useStack ¬ temp.xfer ¬ FALSE;	  temp.displayFieldsOfRecordsAs ¬ fields;	  IF displayAsFields THEN temp.indent ¬ 0;	  Display[h, temp, displayAsFields]};      first ¬ FALSE;      GetNextSe[];      ENDLOOP;    WITH h.ctxb[ctx] SELECT FROM      included => IF ~complete THEN {	IF displayAsFields AND ~first THEN IO.Text[", "L, h] 	ELSE IO.Blanks[h, f.indent];	IO.Text["..."L, h] };      ENDCASE;    IF displayAsFields THEN IO.Char[h, ']] };      VariantPart: PROC[h: Handle, f: Foo, usei: CSEIndex] = {    recordFoo: Foo ¬ NIL;    FOR table: IT.FobTable ¬ h.fobs, table.link UNTIL table = NIL DO      FOR i: CARDINAL IN [0..table.cnt) DO	IF IR.VariantUnionType[h, table.subTable[i].tsei] = usei 	THEN recordFoo ¬ @table.subTable[i];	ENDLOOP;      ENDLOOP;     IF recordFoo # NIL THEN PrintVariant[h, recordFoo, 0, LOOPHOLE[usei], NullVariant]     ELSE ERROR };      PrintVariant: PROCEDURE [h: Handle, f: Foo, pad: CARDINAL, usei: UnionSEIndex,    variant: PROC[Handle] RETURNS [Symbols.RecordSEIndex]] = {    isei: ISEIndex;    bound: RecordSEIndex ¬ variant[h];    SELECT IP.VariantType[h, usei] FROM      controlled => {	IF (isei ¬ IP.TagIsei[h, f, pad, usei]) = Symbols.ISENull 	THEN { IO.Text["UnknownVariant[...]"L, h]; RETURN };	HashVal[h, isei];	RecordCommon[h, MakeVarFoo[h, f, pad, IP.TypeForSe[h, isei], bound], NullVariant] };      overlaid => {	IO.Text["OVERLAID"L, h];	IF bound = Symbols.RecordSENull THEN IO.Text["[...]"L, h]	ELSE RecordCommon[h, MakeVarFoo[h, f, pad, bound, Symbols.RecordSENull], NullVariant] };      computed => {	IO.Text["COMPUTED"L, h];	IF bound = Symbols.RecordSENull THEN IO.Text["[...]"L, h]	ELSE RecordCommon[h, MakeVarFoo[h, f, pad, bound, Symbols.RecordSENull], NullVariant] };      ENDCASE => ERROR StrangeRecord };      MakeVarFoo: PROC [h: Handle, r: Foo, pad: CARDINAL, tag, bound: CSEIndex] RETURNS [f: Foo] = {    --  IF bound # Symbols.RecordSENull AND bound # tag THEN    --  IO.Text[" ! Incorrect tag for bound variant. "L, h];    f ¬ IO.AllocFob[h];    f.tsei ¬ tag;    f.there ¬ r.there;    f.addr.base ¬ r.addr.base;    f.addr.offset ¬ pad;    [f.words, f.bits] ¬ IP.Normalize[CARDINAL[SymbolOps.BitsForType[h.sym, f.tsei]]];    IF ~r.there THEN FixupHeap[h: h, old: r, new: f] };      FixupHeap: PROC [h: Handle, old, new: Foo] = {    words: CARDINAL ¬ old.words + (IF old.bits = 0 THEN 0 ELSE 1);    new.addr.base ¬ IO.Node[h, words];    Inline.LongCOPY[from: old.addr.base, nwords: words, to: new.addr.base]};      Subrange: PUBLIC PROCEDURE [h: Handle, f: Foo] = {    sei: SubrangeSEIndex ¬ IP.CheckClass[h, subrange, f];    vf: ValFormat ¬ IP.DIFormat[h, sei].vf;    org,end,val: INTEGER;    org ¬ h.seb[sei].origin;    end ¬ org + h.seb[sei].range;    val ¬ org + f.addr.base­;    WITH vf SELECT FROM      card, none => NULL;      ENDCASE => SELECT org FROM	< end => IF val ~IN [org..end] THEN vf ¬ [none[]];	> end => IF LOOPHOLE[val,CARDINAL]	  ~IN [LOOPHOLE[org,CARDINAL]..LOOPHOLE[end,CARDINAL]] THEN vf ¬ [none[]];	ENDCASE;    Num[h, val, vf] };      Long: PUBLIC PROCEDURE [h: Handle, f: Foo] = {    sei: LongSEIndex ¬ IP.CheckClass[h, long, f];    p: LONG POINTER TO LONG UNSPECIFIED ¬ LOOPHOLE[f.addr.base];    rsei: SEIndex;    rsei ¬ h.seb[sei].rangeType;    WITH h.seb[IP.TypeForSe[h, rsei]] SELECT FROM      arraydesc => IS.LongArrayDesc[h, f];      ENDCASE => {	IF p = NIL THEN IO.Text[" CoPilot bug. Could not find long number\n"L, h]	ELSE TypedLongNum[h, p­, rsei] }};       DumpChar: PUBLIC PROCEDURE [h: Handle, c: UNSPECIFIED] = {    OPEN Ascii;	    SELECT c FROM      NUL => IO.Text["NUL"L, h];      TAB => IO.Text["TAB"L, h];      LF => IO.Text["LF"L, h];      14C => IO.Text["FF"L, h];      CR => IO.Text["CR"L, h];      33C => IO.Text["ESC"L, h];      IN CHARACTER[NUL..SP) => {	IO.Char[h, '­]; IO.Char[h, LOOPHOLE[c+100B, CHARACTER]] };      SP => IO.Text["SP"L, h];      DEL => IO.Text["DEL"L, h];      ENDCASE =>	IF c ~IN CHARACTER[NUL..DEL] THEN IO.Octal[h, c]	ELSE { IO.Char[h, '']; IO.Char[h, c] }};      HashVal: PUBLIC PROCEDURE [h: Handle, isei: ISEIndex] = {    HtiVal[h, IF isei = SENull THEN HTNull ELSE h.seb[isei].hash] };      HtiVal: PUBLIC PROCEDURE [h: Handle, hti: HTIndex] = {    IF hti = HTNull THEN IO.Text["(anon)"L, h]    ELSE {      desc: String.SubStringDescriptor;      ss: String.SubString ¬ @desc;      SymbolOps.SubStringForHash[h.sym, ss,hti];      IO.SubString[h, ss] }};      EnumVal: PUBLIC PROCEDURE [h: Handle, val: UNSPECIFIED,     esei: EnumeratedSEIndex] = {    ictx: CTXIndex = h.seb[esei].valueCtx;    sei: ISEIndex = IP.SearchCtxForVal[h, val, ictx, none];    IF sei # Symbols.ISENull THEN HashVal[h, sei] ELSE BadNum[h, val] };      TypedNum: PUBLIC PROCEDURE [h: Handle, val: UNSPECIFIED, tsei: SEIndex] = {    Num[h, val, IP.DIFormat[h, tsei].vf] };      TypedLongNum: PUBLIC PROCEDURE [h: Handle, val: LONG UNSPECIFIED, tsei: SEIndex] = {    LongNum[h, val, IP.DIFormat[h, tsei].vf] };    Num: PUBLIC PROCEDURE [h: Handle, val: UNSPECIFIED, vf: ValFormat] = {    WITH vf SELECT FROM      card => ShowNum[h, val, IO.options.cardRadix, IO.options.cardSigned];      int => ShowNum[h, val, IO.options.intRadix, IO.options.intSigned];      char => DumpChar[h, val];      pointer => 	IF val = NIL THEN IO.Text["NIL"L, h]	ELSE {ShowNum[h, val, IO.options.pRadix, FALSE]; IO.Char[h, '­]};      relative => {ShowNum[h, val, IO.options.relRadix, FALSE]; IO.Text["­R"L, h]};      string => {        Num[h, val, [pointer[]]]; 	StringCommon[h, WorldVMOps.Long[h.world, val]]};      enum => EnumVal[h, val, esei];      ENDCASE => BadNum[h, val]};      LongNum: PUBLIC PROCEDURE [h: Handle, val: LONG UNSPECIFIED, vf: ValFormat] = {    WITH vf SELECT FROM      card => ShowLongNum[h, val, IO.options.cardRadix, IO.options.cardSigned];      int => ShowLongNum[h, val, IO.options.intRadix, IO.options.intSigned];      pointer => 	IF val = NIL THEN IO.Text["NIL"L, h]	ELSE {ShowLongNum[h, val, IO.options.pRadix, FALSE]; IO.Char[h, '­]};      relative => {	ShowLongNum[h, val, IO.options.relRadix, FALSE]; 	IO.Text["­R"L, h]};      string => {LongNum[h, val, [pointer[]]]; StringCommon[h, val]};      ENDCASE => BadLongNum[h, val]};      ShowNum: PUBLIC --IY-- PROC [h: Handle, val: UNSPECIFIED, radix: CARDINAL,     signed: BOOLEAN] = {    IO.OutNumber[h, val, [radix, FALSE, ~signed, 0]];    SELECT radix FROM      8 => IF val ~IN[0..7] THEN IO.Char[h, 'B];      16 => IF val ~IN[0..9] THEN IO.Char[h, 'H];      ENDCASE};      ShowLongNum: PUBLIC --IY-- PROC [h: Handle, val: LONG UNSPECIFIED, radix: CARDINAL,     signed: BOOLEAN] = {    IO.LongNumber[h, val, [radix, FALSE, ~signed, 0]];    SELECT radix FROM      8 => IF val ~IN[0..7] THEN IO.Char[h, 'B];      16 => IF val ~IN[0..9] THEN IO.Char[h, 'H];      ENDCASE};    BadNum: PUBLIC PROCEDURE [h: Handle, val: UNSPECIFIED] = {    IO.Text["?["L, h];     ShowNum[h, val, IO.options.default, FALSE];     IO.Char[h, ']] };      BadLongNum: PUBLIC PROCEDURE [h: Handle, val: LONG UNSPECIFIED] = {    IO.Text["?["L, h];     ShowLongNum[h, val, IO.options.default, FALSE];     IO.Char[h, ']]};      StringCommon: PROCEDURE [h: Handle, ls: LONG STRING] = {    sb: StringBody;    IF ls = NIL THEN RETURN;    WorldVMOps.CopyRead[world:h.world, from: ls, nwords: SIZE[StringBody], to: @sb];    IO.Char[h, '(]; ShowNum[h, sb.length, 10, FALSE]; IO.Char[h, ',];    ShowNum[h, sb.maxlength, 10, FALSE]; IO.Text[")"""L, h];    UserLongText[h, ls ! IO.UserAborted => {IS.WriteError[h, XXX]; CONTINUE}];    IO.Char[h, '"]};      -- write strings from user world    UserText: PUBLIC PROCEDURE [h: Handle, s: STRING] = {    length: CARDINAL ¬ WorldVMOps.Read[h.world, WorldVMOps.Long[h.world, @s.length]];    UserDump[h, WorldVMOps.Long[h.world, s], 0, length] };      UserSubString: PUBLIC PROCEDURE[h: Handle, ss: String.SubString] = {    UserDump[h, ss.base, ss.offset, ss.length] };      UserLongText: PUBLIC PROCEDURE [h: Handle, s: LONG STRING] = {    length: CARDINAL = WorldVMOps.Read[h.world, @s.length];    UserDump[h, s, 0, length] };      UserDump: PROCEDURE [h: Handle, base: LONG STRING, offset, length: CARDINAL] = {    s: PACKED ARRAY [0..1] OF CHARACTER;    p: POINTER = @s;    read: BOOLEAN ¬ TRUE;    i: CARDINAL ¬ offset;    lastChar: CARDINAL = offset+length;    THROUGH [offset..lastChar) DO      IF read THEN p­ ¬ WorldVMOps.Read[h.world, @base.text+i/2];      IO.Char[h, s[i MOD 2]];      IF IO.UserAbort[h] THEN {IS.WriteError[h, XXX]; RETURN};      IF i >= lastChar THEN RETURN;      i ¬ i + 1;      read ¬ i MOD 2 = 0;      IF i + 3 > lastChar THEN LOOP      ELSE IF i - offset > IO.options.charCnt THEN {	IO.Text[" ... "L, h]; i ¬ lastChar - 3; read ¬ TRUE};      ENDLOOP};      }.
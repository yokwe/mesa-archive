-- Copyright (C) 1985  by Xerox Corporation. All rights reserved. -- AMModelLocationImpl.mesaDIRECTORYAMLoadstate,AMModel,AMModelLocation,AMModelSection,BcdDefs,BcdOps,BcdOpsExtras,Copier,Runtime,Symbols,SymbolOps,SymbolSegment,SymbolTable,String,WorldVM,WorldVMOps;AMModelLocationImpl: PROGRAM IMPORTS AMLoadstate, AMModelSection, BcdOpsExtras, Copier, Runtime, SymbolOps, WorldVMOpsEXPORTS AMModelLocation = {  GFHandle: TYPE = WorldVMOps.LongGlobalFrameHandle;  BytePC: TYPE = WorldVMOps.BytePC;  CodeLocation: TYPE = RECORD[gf: GFHandle, pc: BytePC];    Section: TYPE = AMModel.Section;  LocationProc: TYPE = AMModelLocation.LocationProc;  Position: TYPE = CARDINAL;  NullPosition: Position = LAST[Position];  World: TYPE = WorldVM.World;  EntryPoint: TYPE = CARDINAL;  NullEntryPoint: EntryPoint = LAST[EntryPoint];  defaultPc: BytePC = 1;  nullPc: BytePC = 0;    Nowhere: PUBLIC ERROR = CODE;    EntryLocations: PUBLIC PROC[section: AMModel.Section, proc: LocationProc] = {    codeloc: CodeLocation ¬ GetCodeLocation[section, TRUE];    [] ¬ proc[section.world, codeloc.gf, codeloc.pc]};    ExitLocations: PUBLIC PROC[section: AMModel.Section, proc: LocationProc] = {    codeloc: CodeLocation ¬ GetCodeLocation[section, FALSE];    [] ¬ proc[section.world, codeloc.gf, codeloc.pc]};    -- The entry BOOLEAN is ignored for now.  GetCodeLocation: PROC [section: Section, entry: BOOL]    RETURNS [codeloc: CodeLocation] = {    sym: SymbolTable.Handle = SymbolsForSection[section];    world: WorldVM.World = section.world;    WITH section SELECT FROM       statement => { 	bestCbti: Symbols.CBTIndex; 	pc: BytePC;  	IF prog.gf = NIL THEN ERROR;  -- section is not loaded	codeloc.gf ¬ prog.gf;	-- get code offset within procedure and cbti of procedure	[pc, , bestCbti] ¬ PcForSourcePosition[sym, sourcePosition, entry];	IF pc = defaultPc THEN ERROR Nowhere;	-- add code offset of procedure 	pc ¬ pc + PcForEntryPoint[world, prog.gf, sym.bb[bestCbti].entryIndex];	codeloc.pc ¬ pc};      proc => {	IF prog.gf = NIL THEN ERROR;  -- section is not loaded	codeloc.gf ¬ prog.gf;	codeloc.pc ¬ PcForEntryPoint[world, prog.gf, entryPointIndex]};      prog => {        entryPointOfProgram: CARDINAL = 0;	IF gf = NIL THEN ERROR;  -- section is not loaded	codeloc.gf ¬ gf;	codeloc.pc ¬ PcForEntryPoint[world, gf, entryPointOfProgram]};       ENDCASE => ERROR};               GetCodeAndSourceLocation: PUBLIC PROC [section: Section, entry: BOOL]     RETURNS [world: World, source: Position, codeloc: CodeLocation] = {    ERROR };       GetENRecord: PROC[world: World, gf:GFHandle]    RETURNS[LONG POINTER TO BcdDefs.ENRecord] = {    bcd: BcdOps.BcdBase;    enBase, mtBase: BcdDefs.Base;    cgfi: NATURAL;    index: AMLoadstate.Index;    enRecord: BcdDefs.ENRecord;    mth: BcdOps.MTHandle;    loadstate: AMLoadstate.Handle = WorldVMOps.GetLoadstate[world];    [cgfi, index] ¬ AMLoadstate.MapRealToConfig[loadstate, WorldVMOps.GFshort[world, gf]];    bcd ¬ AMLoadstate.AcquireBcd[loadstate, index];    enBase ¬ BcdOpsExtras.ENBaseFromBcd[bcd];    mtBase ¬ BcdOpsExtras.MTBaseFromBcd[bcd];    mth ¬ BcdOpsExtras.MthFromGfi[bcd, cgfi];    enRecord ¬ enBase[mth.entries];    RETURN[@enRecord]};      PcForEntryPoint: PROC[world: World, gf:GFHandle,    entryPoint: EntryPoint] RETURNS[BytePC] = {    enRecord: LONG POINTER TO BcdDefs.ENRecord ¬ GetENRecord[world, gf];    IF entryPoint >= enRecord.nEntries THEN ERROR;    RETURN[enRecord.initialPC[entryPoint]]};        EntryPointForPc: PROC[world: World, gf:GFHandle,    pc: BytePC] RETURNS[entryPoint: EntryPoint ¬ NullEntryPoint] = {    enRecord: LONG POINTER TO BcdDefs.ENRecord ¬ GetENRecord[world, gf];    FOR i: EntryPoint IN [FIRST[EntryPoint]..enRecord.nEntries) DO      IF enRecord.initialPC[i] = pc THEN RETURN[i];      ENDLOOP};    -- Finds best source and pc and body within a symbol table.  PcForSourcePosition: PROC[sym: SymbolTable.Handle, position: Position, entry: BOOLEAN]     RETURNS[bestPc: BytePC ¬ defaultPc, bestSource: Position ¬ 0,     bestCbti: Symbols.CBTIndex ¬ Symbols.CBTNull] = {    CheckBti: PROCEDURE [h: SymbolTable.Handle, bti: Symbols.BTIndex]       RETURNS [stop: BOOLEAN] = {      OPEN body: sym.bb[bti];      source: Position;      pc: BytePC;      IF body.kind # Callable OR body.sourceIndex > position THEN RETURN;      [source, pc] ¬ ClosestSource[sym, position, bti, entry];      IF source <= bestSource THEN RETURN;      bestSource ¬ source;      bestCbti ¬ LOOPHOLE[bti];      bestPc ¬ pc;      stop ¬ FALSE};    [] ¬ SymbolOps.EnumerateBodies[sym, Symbols.RootBti, CheckBti]};      -- Finds best source and pc within a body.  ClosestSource: PROCEDURE [sym: SymbolTable.Handle, position: Position,    bti: Symbols.BTIndex, entry: BOOLEAN]    RETURNS [closest: Position, firstPc: BytePC ¬ defaultPc] = {    OPEN body: sym.bb[bti];    currentPc: CARDINAL ¬ 0;    returnNext: BOOLEAN ¬ FALSE;    currentSource: Position ¬ body.sourceIndex;    closest ¬ body.sourceIndex;    IF BASE[sym.fgTable] = NIL THEN RETURN;    WITH body.info SELECT FROM      External => {        FOR fgt: Position IN (startIndex..startIndex + indexLength) DO	  WITH fgtEntry: sym.fgTable[fgt] SELECT FROM	    normal => {	      currentSource ¬ currentSource + fgtEntry.deltaSource;	      IF currentSource > position THEN {	        IF (entry OR returnNext) THEN RETURN		ELSE --exit-- returnNext ¬ TRUE} 	      ELSE {	        closest ¬ currentSource;		currentPc ¬ currentPc + fgtEntry.deltaObject;		firstPc ¬ currentPc }};	    step =>  -- note that it is possible to have multiple steps in a row	      SELECT fgtEntry.which FROM		source => currentSource ¬ currentSource + fgtEntry.delta;		object => currentPc ¬ currentPc + fgtEntry.delta;		ENDCASE;	    ENDCASE;	  ENDLOOP};      ENDCASE};       -- Acquires a symbol table for the section.   -- Makes sure that stamp is correct.   -- Enters module table entry in world symbols, if necessary.    SymbolsForSection: PROC[section: Section] RETURNS[SymbolTable.Handle] = {    programSection: LONG POINTER TO AMModel.SectionObj.prog ¬       WITH section SELECT FROM	prog => NARROW[section],	proc => prog,	statement => prog,	ENDCASE => ERROR;    worldSym: SymbolTable.Handle ¬ WorldVMOps.GetSym[programSection.world];        ss: String.SubStringDescriptor ¬       [programSection.moduleName, 0, programSection.moduleName.length];        moduleHti: Symbols.HTIndex;    mdi: Symbols.MDIndex;    -- IF worldSym = NIL THEN worldSym ¬ globalSym;    moduleHti ¬ SymbolOps.EnterString[worldSym, @ss];    mdi ¬ Copier.FindMdEntry[worldSym, moduleHti,      programSection.versionStamp, Symbols.HTNull      ! Copier.FileVersionMix => REJECT];      RETURN [Copier.GetSymbolTable[worldSym, mdi      ! Copier.FileProblem => REJECT]]};       SourcePositionForPc: PROC[world: WorldVM.World,     gf: GFHandle, pc: BytePC]     RETURNS[position: Position ¬ NullPosition] = {    CheckBti: PROCEDURE [h: SymbolTable.Handle, bti: Symbols.BTIndex]       RETURNS [stop: BOOLEAN ¬ FALSE] = {      OPEN body: sym.bb[bti];      WITH body SELECT FROM Callable => {      WITH body.info SELECT FROM	External => {	  currentSource: Position ¬ body.sourceIndex;	  currentPc: CARDINAL ¬ PcForEntryPoint[world, gf, entryIndex];	  IF currentPc > pc THEN RETURN[TRUE];	  FOR fgt: Position IN (startIndex..startIndex + indexLength) DO	    WITH fgtEntry: sym.fgTable[fgt] SELECT FROM	      normal => {		currentPc ¬ currentPc + fgtEntry.deltaObject;		IF currentPc > pc THEN {position ¬ currentSource; RETURN[TRUE]} 		ELSE currentSource ¬ currentSource + fgtEntry.deltaSource};	      step =>  		SELECT fgtEntry.which FROM		  source => currentSource ¬ currentSource + fgtEntry.delta;		  object => currentPc ¬ currentPc + fgtEntry.delta;		  ENDCASE;	      ENDCASE;	    ENDLOOP};	ENDCASE};	ENDCASE};    programSection: AMModel.Section ¬ SectionForLocation[world, gf, nullPc];    sym: SymbolTable.Handle = SymbolsForSection[programSection];    AMModelSection.FreeSection[programSection];    IF BASE[sym.fgTable] = NIL THEN RETURN[NullPosition];    [] ¬ SymbolOps.EnumerateBodies[sym, Symbols.RootBti, CheckBti]};        SectionForLocation: PUBLIC PROC[world: WorldVM.World,     gf: GFHandle, pc: BytePC]     RETURNS[section: AMModel.Section] = {    entryPoint: EntryPoint;    sourcePosition: Position;    IF world = NIL THEN ERROR;    IF gf = NIL THEN RETURN[AMModelSection.WorldSection[world]];    IF pc = nullPc THEN RETURN[AMModelSection.ProgramSection[world, gf]];    entryPoint ¬ EntryPointForPc[world, gf, pc];    IF entryPoint # NullEntryPoint    THEN RETURN[AMModelSection.ProcSection[world, gf, entryPoint]];    sourcePosition ¬ SourcePositionForPc[world, gf, pc];    RETURN[AMModelSection.StmtSection[world, gf, sourcePosition]]};         PcOnStatementBoundary: PUBLIC PROC[world: WorldVM.World,     gf: GFHandle,     pc: BytePC] RETURNS[BOOLEAN] = {    statementpc: BytePC;    proc: AMModelLocation.LocationProc = {statementpc ¬ pc};    section: AMModel.Section ¬ SectionForLocation[world, gf, pc];    EntryLocations[section, proc];    AMModelSection.FreeSection[section];    RETURN[statementpc = pc]};      myVersion: BcdDefs.VersionStamp ¬     [net: 125B, host: 125B, time: Runtime.GetBuildTime[]];    «  globalSym: SymbolTable.Handle ¬ NIL;    InitSym: PROC[] = {    weights: ARRAY SymbolSegment.Tables OF Alloc.TableInfo ¬ ALL[[, 1, 2]];    alloc: Alloc.Handle ¬ Alloc.Create[weights: DESCRIPTOR[weights]];    Alloc.Chunkify[alloc];    globalSym ¬ SymbolOps.Create[alloc, AMHeap.zone];    --[] ¬ SymbolOps.PrefillMesaSymbols[globalSym];    Copier.FileInit[h: globalSym, self: "AMModelLocationImpl"L,       version: myVersion, purgeProc: NIL, purgeData: NIL];    Copier.CopierInit[h: globalSym, coPilot: FALSE];    Copier.CreateFileTable[globalSym, 8]};    InitSym[];   »        }..
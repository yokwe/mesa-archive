-- Copyright (C) 1985  by Xerox Corporation. All rights reserved. -- ITDILuke.mesaDIRECTORY  CPSwapDefs USING [OperandDesc],  IO USING [Interpret, zone],  IR USING [InConditional],  IT USING [FooProc, Handle, TreeType],  Literals USING [LitRecord],  Tree USING [Link, NodeName],  TreeOps USING [Handle, OpName];ITDILuke: PROGRAM  IMPORTS IO, IR, TreeOps  EXPORTS IO, IR = {    WhosBeenScanningMyTree: ERROR = CODE;  BadTree: ERROR = CODE;  IntConditional: PUBLIC PROC [h: IT.Handle, exp: LONG STRING] = {    ENABLE UNWIND => IF IR.InConditional[h] THEN IO.zone.FREE[@h.operand];    NoOpResult: IT.FooProc = {-- should never get called-- ERROR};    IF IR.InConditional[h] THEN IO.zone.FREE[@h.operand];    h.operand ¬ IO.zone.NEW[CPSwapDefs.OperandDesc ¬ TRASH];     IF h.iContext.howSet # break THEN ERROR;    IO.Interpret[h, exp, NoOpResult];    IO.zone.FREE[@h.operand]};  CheckNode: PUBLIC PROC [h: IT.Handle, t: Tree.Link, name: Tree.NodeName] RETURNS [son1: Tree.Link] = {    IF TreeOps.OpName[h.sym, t] # name THEN ERROR BadTree;    WITH t SELECT FROM      subtree => son1 ¬ h.tb[index].son[1];      ENDCASE => ERROR BadTree};  CheckLink: PUBLIC PROC [h: IT.Handle, t: Tree.Link, type: IT.TreeType] RETURNS [UNSPECIFIED] = {    WITH t SELECT FROM      subtree => IF type = subtree THEN RETURN[index];      hash => IF type = hash THEN RETURN[index];      symbol => IF type = symbol THEN RETURN[index];      literal => IF type = literal THEN RETURN[info];      ENDCASE => ERROR BadTree;    ERROR WhosBeenScanningMyTree}; }..
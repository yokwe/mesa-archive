-- File: AMEventsImplB.mesa - last edit:-- Litman               9-Jun-87 10:48:30-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.-- Implements breakpoint events.DIRECTORY  AMEvents USING [BytePC, GFHandle, LFHandle, PrefixHandle],  AMEventsBackdoor USING [BreakID, BreakRec, BYTE, BytePC, PrefixHandle],  AMHeap USING [zone],  AMModel USING [GFHandle, Section],  AMModelLocation USING [BytePC, EntryLocations, ExitLocations, LocationProc],  Environment USING [Byte],  Mopcodes USING [zBRK],  PrincOps USING [BytePC, LocalOverhead],  WorldVM USING [LocalWorld, World],  WorldVMOps USING [AddressFault, BYTE, BytePC, ClearBreak, CodebaseFromGf, CopyRead, GFlong, IllegalPatch, PrefixHandle, ReadCodeByte, SetBreak, World, Write],  WVMPatch USING [AlreadyClear, AlreadySet, NotPatched, PatchTableFull];AMEventsImplB: MONITOR  IMPORTS AMModelLocation, AMHeap, WorldVM, WorldVMOps, WVMPatch  EXPORTS AMEvents, AMEventsBackdoor = {  BreakID: TYPE = LONG POINTER TO BreakRec;  BreakRec: PUBLIC TYPE = AMEventsBackdoor.BreakRec;  zone: UNCOUNTED ZONE = AMHeap.zone;  breaks: LONG POINTER TO BreakRec ¬ NIL;  localWorld: WorldVM.World ¬ WorldVM.LocalWorld[];    DuplicateBreakpoint: PUBLIC ERROR [id: BreakID] = CODE;  IllegalBreakPoint: PUBLIC ERROR = CODE;  BreakNotFound: PUBLIC ERROR = CODE;    BreakEvent: PUBLIC PROC [world: WorldVM.World, localFrame: AMEvents.LFHandle, instByteReceptacle: LONG POINTER TO WorldVMOps.BYTE] RETURNS [break: BreakID] = {    ENABLE WorldVMOps.AddressFault => { break ¬ NIL; CONTINUE };    localOverhead: PrincOps.LocalOverhead;    codebase: AMEvents.PrefixHandle;    pc: AMEvents.BytePC;    FindBreak: --ENTRY-- PROC RETURNS [BreakID] = {      ENABLE UNWIND => NULL;      FOR b: BreakID ¬ breaks, b.rest UNTIL b = NIL DO	IF b.world = world AND b.cb = codebase AND b.pc = pc THEN {	  WorldVMOps.Write[world: world, addr: instByteReceptacle, value: b.oldByte]; 	  RETURN[b]};	ENDLOOP;      -- state.instbyte ¬ 0;      RETURN[NIL]};    WorldVMOps.CopyRead[world: world, from: localFrame - SIZE[PrincOps.LocalOverhead], to: @localOverhead, nwords: SIZE[PrincOps.LocalOverhead]];    codebase ¬ WorldVMOps.CodebaseFromGf[world, WorldVMOps.GFlong[world, localOverhead.globallink]];    pc ¬ localOverhead.pc;    RETURN[FindBreak[]]};      ContinueFromBreak: PUBLIC PROC[world: WorldVM.World, cb: AMEvents.PrefixHandle, pc: AMEvents.BytePC, instByteReceptacle: LONG POINTER TO WorldVMOps.BYTE] = {    IF WorldVMOps.ReadCodeByte[world, cb, pc] # Mopcodes.zBRK     THEN --someone cleared it-- WorldVMOps.Write[world: world, addr: instByteReceptacle, value: 0] };      BreakAt: PUBLIC PROC[world: WorldVM.World, section: AMModel.Section, clientData: LONG POINTER] RETURNS[id: BreakID] = {    id ¬ BreakIt[TRUE, world, section, clientData]};  BreakAfter: PUBLIC PROC[world: WorldVM.World, section: AMModel.Section, clientData: LONG POINTER] RETURNS[id: BreakID] = {    id ¬ BreakIt[FALSE, world, section, clientData]};  breakpointHack: {mostRecent, leastRecent, all} ¬ all; -- ignored for now    BreakIt: PROC [at: BOOL, world: WorldVM.World, section: AMModel.Section, clientData: LONG POINTER] RETURNS [id: BreakID] = {    DoCodeLocation: AMModelLocation.LocationProc = {      codebase: AMEvents.PrefixHandle = WorldVMOps.CodebaseFromGf[world, gf];      id ¬ RealSetBreak[world, codebase, pc, clientData]};    IF at THEN AMModelLocation.EntryLocations[section, DoCodeLocation]    ELSE AMModelLocation.ExitLocations[section, DoCodeLocation]};    FrameBreak: PUBLIC PROC[world: WorldVM.World, gf: AMEvents.GFHandle, pc: AMEvents.BytePC, clientData: LONG POINTER] RETURNS[id: BreakID] = {    id ¬ SetBreak[world, WorldVMOps.CodebaseFromGf[world, gf], pc, clientData]};  SetBreak: PUBLIC PROC[world: WorldVM.World, cb: AMEvents.PrefixHandle, pc: AMEvents.BytePC, clientData: LONG POINTER] RETURNS[id: BreakID] = {    id ¬ RealSetBreak[world, cb, pc, clientData] };  RealSetBreak: ENTRY PROC [world: WorldVM.World, cb: AMEvents.PrefixHandle, pc: AMEvents.BytePC, clientData: LONG POINTER] RETURNS [BreakID] = {    ENABLE UNWIND => NULL;    oldByte: Environment.Byte;    FOR b: BreakID ¬ breaks, b.rest UNTIL b = NIL DO      IF b.world = world AND b.cb = cb AND b.pc = pc THEN RETURN WITH ERROR DuplicateBreakpoint[b];      ENDLOOP;    oldByte ¬ WorldVMOps.SetBreak[world, cb, pc       ! WorldVMOps.IllegalPatch => REJECT;        WVMPatch.PatchTableFull => REJECT;        WVMPatch.AlreadySet => RESUME];    breaks ¬ zone.NEW[BreakRec ¬ [world: world, cb: cb, pc: pc, oldByte: oldByte, clientData: clientData, rest: breaks]];    RETURN[breaks] };  ClearBreak: PUBLIC ENTRY PROC[id: BreakID] = {    ENABLE UNWIND => NULL;    prev: BreakID ¬ NIL;    b: BreakID;    FOR b ¬ breaks, b.rest UNTIL b = NIL DO      IF b = id THEN {	WorldVMOps.ClearBreak[b.world, b.cb, b.pc, b.oldByte	  ! WorldVMOps.IllegalPatch => REJECT;	    WorldVMOps.AddressFault => CONTINUE;	    WVMPatch.NotPatched => RESUME;	    WVMPatch.AlreadyClear => RESUME];	IF prev = NIL THEN breaks ¬ b.rest ELSE prev.rest ¬ b.rest;	zone.FREE[@b];	EXIT }      ELSE prev ¬ b;      ENDLOOP };      FlushBreaks: PUBLIC ENTRY PROC [world: WorldVM.World] = {    ENABLE UNWIND => NULL;    prev: BreakID ¬ NIL;    b: BreakID ¬ breaks;    UNTIL b = NIL DO      IF b.world = world THEN {	-- Doesn't actually clear the break.	IF b = breaks THEN breaks ¬ b.rest ELSE prev.rest ¬ b.rest;	zone.FREE[@b] }      ELSE prev ¬ b;      b ¬ IF prev = NIL THEN breaks ELSE prev.rest;      ENDLOOP };  -- Enumerator starts and ends with NIL.  NextBreak: PUBLIC PROC[world: WorldVM.World, prev: BreakID] RETURNS[id: BreakID, clientData: LONG POINTER] = {    ENABLE UNWIND => NULL;    FOR b: BreakID ¬ (IF prev = NIL THEN breaks ELSE prev.rest), b.rest UNTIL b = NIL DO      IF b.world = world OR world = NIL THEN RETURN[b, b.clientData];      ENDLOOP;    RETURN[NIL, NIL]};      }..
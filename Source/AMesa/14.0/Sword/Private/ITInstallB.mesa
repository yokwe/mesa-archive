-- File: ITInstallB.mesa - last edit:-- Litman              21-Apr-87 19:12:33-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.DIRECTORY  AMEvents USING [Event, GetEvents],  CmFile USING [Close, Error, FindSection, Handle, NextValue, ReadLineOrToken, TableError, UserDotCmOpen],  Environment USING [wordsPerPage],  Event USING [aboutToSwap, swapping, spare2],  EventTypes USING [abortSession, aboutToAbortSession, aboutToResume, flushSymbols, newSession, resumeDebuggee, resumeSession, spare2, swapCancelled],  ID USING [CleanupClient],  IK USING [EventHandler],  IM USING [strings],  IO USING [FreeString, Kill, Proceed, Quit, zone],  IP USING [ResetPCache],  IQ USING [FlushFrameCache, FreeItems, Prune, StartUser],  IS USING [DispatchChar, Prompt, ResetCache, ResetPrinters],  IT USING [FobTable, Foo, Handle, Options, ParseProc, StringId],  ITExtras USING [OptionsSpare],  MFile,  RuntimeError,   String USING [Empty, Equivalent, MakeString, Replace],  StringLookUp USING [noMatch],  Supervisor USING [EnumerationAborted, Event, NotifyDirectSubsystems],  Token USING [Boolean, FreeTokenString, Handle, Item, Number, SyntaxError, WindowBox],  WorldVM USING [BadWorld, RemoteWorld, World],  WorldVMOps USING [GetType];ITInstallB: PROGRAM   IMPORTS AMEvents, CmFile, Event, ID, IK, IM, IO, IP, IQ, IS, RuntimeError, String, Supervisor, Token, WorldVM, WorldVMOps  EXPORTS ID, IO, IQ, IS = {  options: PUBLIC IT.Options ¬ [];  SetString: PUBLIC PROCEDURE [h: IT.Handle, id: IT.StringId,     val: LONG STRING] = {    IO.FreeString[h, IM.strings[id]];    IM.strings[id] ¬ val};      DoKill: PUBLIC PROC[h: IT.Handle] = {    IF OkToLeave[h, EventTypes.aboutToAbortSession] THEN SIGNAL IO.Kill};       DoProceed: PUBLIC PROC[h: IT.Handle] = {    IF OkToLeave[h, EventTypes.aboutToResume] THEN SIGNAL IO.Proceed};      DoQuit: PUBLIC PROC[h: IT.Handle] = {    IF OkToLeave[h, EventTypes.aboutToAbortSession] THEN SIGNAL IO.Quit};      OkToLeave: PROC [h: IT.Handle, grumble: Supervisor.Event] RETURNS [ok: BOOLEAN ¬ TRUE] = {    BEGIN ENABLE Supervisor.EnumerationAborted => {ok ¬ FALSE; CONTINUE};    SELECT WorldVMOps.GetType[h.world] FROM      local => 	Supervisor.NotifyDirectSubsystems[	  event: grumble, 	  which: clients, 	  subsystem: Event.spare2];      outload =>         Supervisor.NotifyDirectSubsystems[	  event: grumble, 	  which: clients, 	  subsystem: Event.aboutToSwap];      remote =>         Supervisor.NotifyDirectSubsystems[	  event: EventTypes.spare2, 	  which: clients, 	  subsystem: Event.aboutToSwap, 	  eventData: @grumble];      ENDCASE;     END; -- ENABLE Supervisor.EnumerationAborted    IF ~ok THEN       Supervisor.NotifyDirectSubsystems[        event: EventTypes.swapCancelled, 	which: clients,         subsystem: Event.swapping]};      WordSeq: TYPE = RECORD [SEQUENCE COMPUTED CARDINAL OF WORD];    Pages: PUBLIC PROC [nPages: CARDINAL] RETURNS [LONG POINTER] = {    RETURN[IO.zone.NEW[WordSeq[nPages*Environment.wordsPerPage]]]};      FreePages: PUBLIC PROC [base: LONG POINTER] = {    IF base # NIL THEN IO.zone.FREE[@base]};  Invalidate: PUBLIC PROC[h: IT.Handle] = {    FlushCaches[h, EventTypes.newSession];    FlushCaches[h, EventTypes.flushSymbols] };       ResetSymbols: PUBLIC PROC[h: IT.Handle] = {    FlushCaches[h, EventTypes.flushSymbols] };    FlushCaches: PUBLIC PROC [h: IT.Handle, event: Supervisor.Event] = {    SELECT event FROM      EventTypes.flushSymbols => {	IQ.FreeItems[h]; -- ITSymsCold	IP.ResetPCache[h]; -- ITPcCold	IQ.Prune[h]; -- ITSymsCold	IS.ResetPrinters[h]}; -- ITDumpCold      EventTypes.newSession => {        IQ.FreeItems[h]; -- ITSymsCold	IP.ResetPCache[h]; -- ITPcCold	IQ.FlushFrameCache[h]; -- ITFramesHot	IS.ResetCache[h]}; -- ITPsbPack      EventTypes.resumeSession => {	IQ.FlushFrameCache[h]; -- ITFramesHot	IS.ResetCache[h]}; -- ITPsbPack      EventTypes.resumeDebuggee, EventTypes.abortSession => {	IQ.FlushFrameCache[h]; -- ITFramesHot	IP.ResetPCache[h]}; -- ITPcCold      ENDCASE};        TopLevel: PUBLIC PROC[h: IT.Handle] = {    FreeFobs[h]; };      FreeFobs: PROC[h: IT.Handle] =  {    first: IT.FobTable = h.fobs;    next: IT.FobTable;    IF first = NIL THEN RETURN;    FreeTable[first];    FOR t: IT.FobTable ¬ first.link, next UNTIL t = NIL DO      next ¬ t.link;      FreeTable[t];      FreePages[t];      ENDLOOP;    first.link ¬ NIL};      FreeTable: PROC [t: IT.FobTable] = {    FOR i: CARDINAL IN [0..t.cnt) DO      f: IT.Foo = @t.subTable[i];      IF ~f.there AND f.addr.base # NIL THEN IO.zone.FREE[@f.addr.base];      ENDLOOP;    t.cnt ¬ 0};  SetParse: PUBLIC PROC [h: IT.Handle, proc: IT.ParseProc] = {    h.parse ¬ proc;     h.prevParse ¬ NIL;     h.prevPrevParse ¬ NIL };  ResetParse: PUBLIC PROC[h: IT.Handle] = {    SetParse[h, IS.DispatchChar]};    PopParse: PUBLIC PROC [h: IT.Handle] = {    h.parse ¬ h.prevParse;     h.prevParse ¬ h.prevPrevParse;    h.prevPrevParse ¬ NIL};    PushParse: PUBLIC PROC [h: IT.Handle, proc: IT.ParseProc] = {    IF h.prevPrevParse # NIL THEN ERROR;    h.prevPrevParse ¬ h.prevParse;    h.prevParse ¬ h.parse;    h.parse ¬ proc};  ProcessUserCm: PUBLIC PROC = {    userCm: CmFile.Handle;    Option: TYPE = MACHINE DEPENDENT { boot(0), cRadix(1), cSigned(2), iRadix(3), iSigned(4), pRadix(5), lpRadix(6), relRadix(7), unspec(8), elements(9), chars(10), fault(11), uncaught(12), break(13), calldebug(14), processes(15), configs(16), variables(17), menu(18), resetLog(19), autoOpen(20), defaultOutload(21), maxFilters(22), filters(23), noMatch(StringLookUp.noMatch)};    DefinedOption: TYPE = Option [boot..filters];    optionTable: ARRAY DefinedOption OF LONG STRING ¬ [boot: "Boot"L, cRadix: "cRadix"L, cSigned: "cSigned", iRadix: "iRadix"L, iSigned: "iSigned"L, pRadix: "pRadix"L, lpRadix: "processRadix"L, relRadix: "relRadix"L, unspec: "unspec"L, elements: "elements"L, chars: "chars"L, fault: "fault"L, uncaught: "uncaught"L, break: "break"L, calldebug: "calldebug"L, processes: "processes"L, configs: "configs"L, variables: "variables"L, menu: "menu"L, resetLog: "resetLog"L, autoOpen: "autoOpen"L, defaultOutload: "defaultOutload"L, maxFilters: "maxFilters"L, filters: "filters"L];    OctDecHex: PROC[option: LONG POINTER TO CARDINAL] = {      t: LONG STRING ¬ Token.Item[userCm, TRUE];      SELECT TRUE FROM	String.Equivalent[t, "octal"L] => option­ ¬ 8;	String.Equivalent[t, "decimal"L] => option­ ¬ 10;	String.Equivalent[t, "hex"L] => option­ ¬ 16;	ENDCASE;      t ¬ Token.FreeTokenString[t] };    String.Replace[to: @IM.strings[outload], from: "<>Debuggee.outload"L, z: IO.zone];    userCm ¬ CmFile.UserDotCmOpen[ ! CmFile.Error => GOTO NoUserDotCm];    IF CmFile.FindSection[userCm, "Debugger"L] THEN {      DO ENABLE CmFile.TableError => RESUME;        val: Option ¬ VAL[CmFile.NextValue[userCm, LOOPHOLE[LONG[DESCRIPTOR[optionTable]]]]];	SELECT val FROM          noMatch => EXIT;          boot => { };	  cRadix => OctDecHex[@options.cardRadix];	  iRadix => OctDecHex[@options.intRadix];	  cSigned => options.cardSigned ¬ Token.Boolean[userCm, FALSE];	  iSigned => options.intSigned ¬ Token.Boolean[userCm, FALSE];	  pRadix => OctDecHex[@options.pRadix];	  lpRadix => OctDecHex[@options.lpRadix];	  relRadix => OctDecHex[@options.relRadix];	  unspec => OctDecHex[@options.default];	  elements => options.elementCnt ¬ Token.Number[userCm, 10 ! Token.SyntaxError => CONTINUE];	  chars => options.charCnt ¬ Token.Number[userCm, 10 ! Token.SyntaxError => CONTINUE];	  fault => options.fault.b ¬ Token.Boolean[userCm, FALSE];	  uncaught => options.uncaught.b ¬ Token.Boolean[userCm, FALSE];	  break => options.break.b ¬ Token.Boolean[userCm, FALSE];	  calldebug => options.calldebug.b ¬ Token.Boolean[userCm, FALSE];	  processes => options.processes.b ¬ Token.Boolean[userCm, FALSE];	  configs => options.configs.b ¬ Token.Boolean[userCm, FALSE];	  variables => options.variableWindow ¬ Token.WindowBox[userCm];	  menu => options.menu.b ¬ Token.Boolean[userCm, FALSE];	  resetLog => options.resetLog.b ¬ Token.Boolean[userCm, FALSE];	  autoOpen => LOOPHOLE[options.spare, ITExtras.OptionsSpare].autoOpen.b ¬ Token.Boolean[userCm, FALSE];	  defaultOutload => {	    IM.strings[outload] ¬ String.MakeString[IO.zone, MFile.maxNameLength];	    CmFile.ReadLineOrToken[userCm, IM.strings[outload], '\n] };	  maxFilters => RuntimeError.InitializeFilter[Token.Number[userCm, 10 ! Token.SyntaxError => LOOP]];	  filters => {	    IM.strings[filter] ¬ String.MakeString[IO.zone, MFile.maxNameLength];	    CmFile.ReadLineOrToken[userCm, IM.strings[filter], '\n] };	  ENDCASE;        ENDLOOP};    [] ¬ CmFile.Close[userCm];    EXITS NoUserDotCm => NULL };  GetFrame: PUBLIC PROC [h: IT.Handle, s: LONG STRING] = {    IQ.StartUser[h, s];    IS.Prompt[h] };       GetDebuggee: PUBLIC PROC [h: IT.Handle, s: LONG STRING] = {    BEGIN ENABLE WorldVM.BadWorld => CONTINUE;    remoteWorld: WorldVM.World;    IF String.Empty[s] THEN {ID.CleanupClient[h]; RETURN};    remoteWorld ¬ WorldVM.RemoteWorld[s, NIL, h.tty];    AMEvents.GetEvents[world: remoteWorld, data: NIL, proc: IK.EventHandler];    END; --ENABLE--    IS.Prompt[h] };      }..
-- File: ITDIHot.mesa - last edit:-- Litman              29-Apr-87 18:39:30-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.DIRECTORY  ComData USING [CSEIndex, typeCARDINAL, typeCHAR, typeINT, typeREAL, typeSTRING, typeStringBody],  CommandList USING [DIErr],  CPSwapDefs USING [FieldPosition, FieldSize, OperandDesc, OperandType, StackIndex],  IC USING [GFFromControlLink],  IG USING [StackZeroAddress],  Inline USING [HighHalf, LowHalf],  IO USING [AllocFob, EOL, SyntaxError, zone],  IP USING [AbortWithError, CheckForHiddenPadding, Complete, CopyLiteral, DerefProcDesc, Error, FindField, GetControlLink, GetValue, HtiForFrame, IllegalConditional, InCtx, InLF, InMod, MakeLongType, Mode, MultipleFrames, NotAProcedure, NotRelocated, OnStack, Pad, Procedure, PutValue, SearchCtxList, Signal, TagIsei, TypeForSe, VariantType],  IQ USING [Condition, ValidateGF],  IR USING [Abs, Assignable, Base, CheckLink, CheckNode, DoApply, DumpArray, DumpMemory, First, FoldExpr, GetSize, InConditional, Interval, Last, Length, LengthenFob, Long, MakePointerType, MakeXferType, Max, Memory, Min, PushNil, PutLongReps, PutReps, Relation, SelectVariantType, Size, TotalWords, VariantUnionType],  IS USING [GFFromIContext, Parse],  IT USING [arrayInt, bang, BitAddress, card, conditionalBreak, ControlLink, CSEIndex, CTXIndex, eol, exp, fileDollar, Fob, Foo, FooProc, frameDollar, GFHandle, Handle, HTIndex, int, ISEIndex, lcard, LFHandle, lint, memory, memoryInt, NullFob, Number, NumberType, OpHandle, RecordSEIndex, reps, SEIndex, Stack, typeDollar, UnionSEIndex, Words],  Literals USING [LitRecord],  PrincOps USING [ControlLink],  String USING [AppendOctal, AppendString],  SymbolOps USING [FirstCtxSe, Handle, NextSe, ToSei, TypeForm, TypeRoot, WordsForType],  Symbols USING [Base, ISENull, SENull, SERecord, typeANY],  SymbolTable USING [Handle, Missing],  Tree USING [Index, Link, NodeName, Null],  TreeOps USING [FreeTree, Handle, PopTree, Scan, ScanList],  WorldVMOps USING [GetMDS, Long, NilAddress];ITDIHot: PROGRAM  IMPORTS com: ComData, Inline, IG, IC, IO, IP, IQ, IR, IS, String, SymbolOps, SymbolTable, TreeOps, WorldVMOps  EXPORTS IO, IP, IR = {  OPEN IT;  Underflow: PUBLIC ERROR = CODE;  StackNotEmptyAtStatement: PUBLIC ERROR = CODE;  NotImplemented: PUBLIC SIGNAL [msg: LONG STRING] = CODE;  DIAbort: PUBLIC ERROR = CODE;  IllegalConditional: PUBLIC ERROR = CODE;    BadTree: ERROR = CODE;  WhosBeenScanningMyTree: ERROR = CODE;  Interpret: PUBLIC PROC [it: Handle, exp: LONG STRING, results: FooProc, targetType: IT.CSEIndex] = {    ProcessTree: TreeOps.Scan = {      Exp: TreeOps.Scan = {	ENABLE DIAbort => GOTO cleanExit;	son1: Foo;	IF t = Tree.Null THEN RETURN;	WITH t SELECT FROM	  subtree => {	    SELECT it.tb[index].name FROM	      conditionalBreak => {		Work[it, it.tb[index].son[1] ! DIAbort => {IP.Error[it, spare1]; ERROR IP.IllegalConditional}]};	      IT.exp => {		son1 ¬ FirstSon[it, index, it.target];		IF son1­ # NullFob THEN it.proc[it, son1] };	      memoryInt => {		IF IR.InConditional[it] THEN IP.AbortWithError[it, spare1];		son1 ¬ FirstSon[it, index, IP.MakeLongType[it, com.typeCARDINAL]];		IR.DumpMemory[it, son1] };	      arrayInt => {		IF IR.InConditional[it] THEN IP.AbortWithError[it, spare1];		son1 ¬ FirstSon[it, index, it.target];		Work[it, it.tb[index].son[2], IndexType[it, son1]];		IR.DumpArray[it, son1] };	      reps => {		n: Number;		IF IR.InConditional[it] THEN IP.AbortWithError[it, spare1];		son1 ¬ FirstSon[it, index, it.target];		n ¬ GetNumber[it, son1];		SELECT n.type FROM		  one => IR.PutReps[it, n.u];		  two => IR.PutLongReps[it, n.lu];		  ENDCASE };	      assign => {		rhs: Foo;		IF IR.InConditional[it] THEN IP.AbortWithError[it, spare1];		son1 ¬ FirstSon[it, index, it.target];		IF ~son1.there AND ~son1.addr.useStack THEN IP.AbortWithError[it, illegalConstantOp, son1.hti];		TargetTypeWork[it, it.tb[index].son[2], son1.tsei];		rhs ¬ Pop[it];		IP.PutValue[it, son1, rhs.addr.base] };	      eol => {		IF IR.InConditional[it] THEN IP.AbortWithError[it, spare1];		IO.EOL[it];		Exp[it.sym, it.tb[index].son[1]];		IO.EOL[it];		CheckForStackEmpty[it] };	      ENDCASE => ERROR WhosBeenScanningMyTree };	  ENDCASE => ERROR BadTree;	EXITS cleanExit => { ResetStack[it]; RETURN }};      IF t = Tree.Null THEN RETURN;      t ¬ IR.CheckNode[it, t, eol];      t ¬ IR.CheckNode[it, t, block];      TreeOps.ScanList[it.sym, t, Exp];      CheckForStackEmpty[it] };    t: Tree.Link;    IF ~IS.Parse[it, exp] THEN SIGNAL IO.SyntaxError[0];    t ¬ TreeOps.PopTree[it.sym];    it.proc ¬ results;    it.target ¬ targetType;    ProcessTree[it.sym, t ! UNWIND => { ResetStack[it]; [] ¬ TreeOps.FreeTree[it.sym, t] }];    ResetStack[it]; [] ¬ TreeOps.FreeTree[it.sym, t] };      IndexType: PROC [h: Handle, f: Foo] RETURNS [csei: IT.CSEIndex] = {    csei ¬ IP.TypeForSe[h, f.tsei];    DO      WITH h.seb[csei] SELECT FROM        array => RETURN[IP.TypeForSe[h, indexType]];        arraydesc => csei ¬ IP.TypeForSe[h, describedType];        ref => csei ¬ IP.TypeForSe[h, refType];        long => csei ¬ IP.TypeForSe[h, rangeType];        sequence => RETURN[IP.TypeForSe[h, tagSei]];        record => {          IP.Complete[h, fieldCtx];          IF hints.unifield THEN csei ¬ IP.TypeForSe[h, SymbolOps.FirstCtxSe[h.sym, fieldCtx]]          ELSE {            isei: IT.ISEIndex = VariantField[h, csei];            IF isei = Symbols.ISENull THEN { IF csei = com.typeStringBody THEN RETURN[com.typeCARDINAL] ELSE EXIT }            ELSE csei ¬ IP.TypeForSe[h, isei]}};        ENDCASE => EXIT;      ENDLOOP;    IP.AbortWithError[h, illegalIndexOp, f.hti] };  FirstSon: PUBLIC PROC [h: Handle, index: Tree.Index, type: IT.SEIndex ¬ Symbols.typeANY] RETURNS [f: Foo] = {    son: Tree.Link;    son ¬ h.tb[index].son[1];    Work[h, son, type];    f ¬ IF son # Tree.Null THEN Pop[h] ELSE NIL };  Son: PUBLIC PROC [h: Handle, t: Tree.Link, target: IT.SEIndex] RETURNS [Foo] = {    IF t = Tree.Null THEN ERROR WhosBeenScanningMyTree;    Work[h, t, target];    RETURN[Tos[h]] };  NumberWork: PUBLIC PROC [h: Handle, t: Tree.Link, number, target: IT.SEIndex] = {    csei: IT.SEIndex;    target ¬ IP.TypeForSe[h, target];    csei ¬      SELECT TRUE FROM        target = Symbols.typeANY => number,        SymbolOps.WordsForType[h.sym, target] # 1 => number,        ENDCASE => target;    TargetTypeWork[h, t, csei] };  Work: PUBLIC PROC [h: Handle, t: Tree.Link, type: IT.SEIndex ¬ Symbols.typeANY] = {    IF t = Tree.Null THEN RETURN;    WITH t SELECT FROM      subtree => SubtreeWork[h, index, type];      hash => Push[h, HashWork[h, index, type]];      symbol => Push[h, SymbolWork[h, index]];  -- type only      literal => Push[h, FindLiteral[h, info]];      ENDCASE => ERROR BadTree };  LoopHoleWork: PUBLIC PROC [h: Handle, t: Tree.Link, type: IT.SEIndex] = {    f: Foo ¬ NIL;    IF t = Tree.Null THEN RETURN;    WITH t SELECT FROM      subtree => {SubtreeWork[h, index, type]; f ¬ Pop[h]};      hash => f ¬ HashWork[h, index, type];      literal => f ¬ FindLiteral[h, info];      ENDCASE => ERROR BadTree;    LoopHole[h, f, type, TRUE];    Push[h, f] };  TargetTypeWork: PUBLIC PROC [h: Handle, t: Tree.Link, type: IT.SEIndex] = {    f: Foo ¬ NIL;    IF t = Tree.Null THEN RETURN;    WITH t SELECT FROM      subtree => {SubtreeWork[h, index, type]; f ¬ Pop[h]};      hash => f ¬ HashWork[h, index, type];      literal => {f ¬ FindLiteral[h, info]; FixupLiteral[h, f, type]};      ENDCASE => ERROR BadTree;    IR.Assignable[h, f, IP.TypeForSe[h, type]];    Push[h, f] };  FixupLiteral: PROC [h: Handle, f: Foo, type: IT.SEIndex] = {    csei: IT.CSEIndex ¬ IP.TypeForSe[h, type];    f.tsei ¬ csei;    SELECT csei FROM      com.typeCARDINAL, Symbols.typeANY, com.typeINT => NULL;      ENDCASE => {        WITH h.seb[csei] SELECT FROM          long => IF NumberLength[h, f] = one THEN IR.Long[h, f, rangeType = com.typeINT];          ENDCASE}};  SymbolWork: PROC [h: Handle, index: IT.SEIndex] RETURNS [f: Foo] = INLINE {    f ¬ IO.AllocFob[h];     f.tsei ¬ index;     f.typeOnly ¬ TRUE};    BitSize: PROCEDURE [words: CARDINAL, bits: CARDINAL] RETURNS [CPSwapDefs.FieldSize] = INLINE {    bitSize: CARDINAL = words*16+bits;    RETURN[IF bitSize NOT IN CPSwapDefs.FieldSize THEN 17 ELSE bitSize]};    DerefOperand: PUBLIC PROCEDURE [h: Handle, f: Foo] = {    IF h.operand = NIL THEN RETURN;    IF h.operand.fieldSize > 16 AND h.operand.fieldSize # 32 THEN GOTO badOperand;    WITH op: h.operand­ SELECT FROM      immediate =>        IF h.operand.fieldSize = 32 	  THEN h.operand.vp ¬ memory[address: LOOPHOLE[op.value]]	  ELSE h.operand.vp ¬ memory[address: WorldVMOps.Long[h.world, CARDINAL[op.value]]];      localVariable =>         IF h.operand.fieldSize = 32 	  THEN h.operand.vp ¬ localIndirect[index: op.index, offset: 0]	  ELSE h.operand.vp ¬ localIndirectShort[index: op.index, offset: 0];      stack =>          IF h.operand.fieldSize = 32 	  THEN h.operand.vp ¬ stackIndirect[index: op.index, offset: 0]	  ELSE h.operand.vp ¬ stackIndirectShort[index: op.index, offset: 0];      memory =>          IF h.operand.fieldSize = 32 	  THEN h.operand.vp ¬ memoryIndirect[addressOfPointer: LOOPHOLE[op.address, LONG POINTER], offset: 0]	  ELSE h.operand.vp ¬ memoryIndirectShort[addressOfPointer: LOOPHOLE[op.address, LONG POINTER], offset: 0];      ENDCASE => GOTO badOperand;    h.operand.fieldPosition ¬ 0;    h.operand.fieldSize ¬ BitSize[f.words, f.bits];    EXITS badOperand => IF IR.InConditional[h] THEN ERROR DIAbort };    SelectOperand: PUBLIC PROCEDURE [h: Handle, oldAddr: BitAddress, newFoo: Foo] = {    bitsPerWord: CARDINAL = 16 «Environment.bitsPerWord»;    assert: BOOLEAN[TRUE..(bitsPerWord = CPSwapDefs.FieldPosition.LAST+1)] = TRUE;    oldBitOffset, newBitOffset: LONG CARDINAL;    words: LONG CARDINAL;    IF ~IR.InConditional[h] OR newFoo = NIL THEN RETURN;    -- normalize the offsets    oldBitOffset ¬ LOOPHOLE[oldAddr.base, LONG CARDINAL]*16+oldAddr.offset;    newBitOffset ¬ LOOPHOLE[newFoo.addr.base, LONG CARDINAL]*16+newFoo.addr.offset;    words ¬ (newBitOffset-oldBitOffset)/16;    h.operand.fieldPosition ¬ CARDINAL[(newBitOffset-oldBitOffset) MOD 16];    h.operand.fieldSize ¬ BitSize[newFoo.words, newFoo.bits];    SELECT h.operand.type FROM      counter => ERROR DIAbort;      localVariable => IF words > CARDINAL.LAST THEN ERROR DIAbort;      stack => IF words > CPSwapDefs.StackIndex.LAST THEN ERROR DIAbort;      memory => IF words > CARDINAL.LAST THEN ERROR DIAbort;      localIndirect => IF words > CARDINAL.LAST THEN ERROR DIAbort;      localIndirectShort => IF words > CARDINAL.LAST THEN ERROR DIAbort;      stackIndirect => IF words > CARDINAL.LAST THEN ERROR DIAbort;      stackIndirectShort => IF words > CARDINAL.LAST THEN ERROR DIAbort;      memoryIndirect => IF words > CARDINAL.LAST THEN ERROR DIAbort;      memoryIndirectShort => IF words > CARDINAL.LAST THEN ERROR DIAbort;      ENDCASE => ERROR DIAbort;    WITH op: h.operand­ SELECT FROM      immediate => <<extract field from constant>>         -- maybe someday, but for now --	IP.AbortWithError[h, illegalConstantOp];      localVariable => op.index ¬ CARDINAL[words];      stack => op.index ¬ CARDINAL[words];      memory => op.address ¬ newFoo.addr.base;      localIndirect => op.offset ¬ CARDINAL[words] + op.offset; -- ugh      localIndirectShort => op.offset ¬ CARDINAL[words] + op.offset; -- ugh      stackIndirect => op.offset ¬ CARDINAL[words] + op.offset; -- ugh      stackIndirectShort => op.offset ¬ CARDINAL[words] + op.offset; -- ugh      memoryIndirect => op.offset ¬ CARDINAL[words] + op.offset; -- ugh      memoryIndirectShort => op.offset ¬ CARDINAL[words] + op.offset; -- ugh      ENDCASE };    ShortImmediateOperand: PUBLIC PROCEDURE [h: Handle,     val: LONG POINTER TO CARDINAL] = {    h.operand­ ¬ [0, 16, immediate[LONG[val­]]]};      LongImmediateOperand: PUBLIC PROCEDURE[h: Handle,    val: LONG POINTER TO LONG CARDINAL] ={    h.operand­ ¬ [0, 32, immediate[val­]]};      MakeOperand: PUBLIC PROCEDURE [h: Handle, f: Foo] = {    noLocals: BOOLEAN;    IF f = NIL OR ~IR.InConditional[h] OR h.operand­ # [0, 16, counter[0]] -- already in use? ugh    THEN RETURN;    -- IF operand.type # counter THEN ERROR DIAbort;    -- if the foo is local and you are at entry or exit, change to stack?    -- nope, looks like it will already be in stack mode.    -- we assume that for local and stack mode, that we provided    -- NIL for the lf/base so f.addr.base will be the offset we want.    WITH h.iContext SELECT FROM      break => noLocals ¬ bb.bt.ex = entry --OR (bb.bt.ex = exit)--;      -- the user might want to use the old local variables at exit      ENDCASE => ERROR DIAbort;      -- if we aren't in a break context, but operand is non-NIL something      -- very strange is going on    SELECT TRUE FROM      f.constant => {        IF f.there THEN IP.AbortWithError[h, illegalConstantOp, f.hti];        IF f.words < 2 THEN {	  p: LONG POINTER TO CARDINAL = f.addr.base;	  h.operand.vp ¬ immediate[p­]}	ELSE {	  p: LONG POINTER TO LONG CARDINAL = f.addr.base;	  h.operand.vp ¬ immediate[p­]}};      f.addr.useStack => {        -- h.operand.vp ¬ stack[CARDINAL[LOOPHOLE[f.addr.base, LONG CARDINAL]]];	long: LONG CARDINAL = LOOPHOLE[f.addr.base - IG.StackZeroAddress[h]];	stackOffset: CPSwapDefs.StackIndex = CARDINAL[long];	h.operand.vp ¬ stack[stackOffset] };      ~f.addr.local => h.operand.vp ¬ memory[f.addr.base];      noLocals => ERROR DIAbort;      ENDCASE => h.operand.vp ¬ localVariable[CARDINAL[LOOPHOLE[f.addr.base, LONG CARDINAL]]];    h.operand.fieldPosition ¬ f.addr.offset;    h.operand.fieldSize ¬ BitSize[f.words, f.bits] };  HashWork: PROC [h: Handle, index: IT.HTIndex, hint: IT.SEIndex] RETURNS [f: Foo ¬ NIL] = {    IF hint # Symbols.typeANY THEN {      csei: IT.CSEIndex ¬ IP.TypeForSe[h, hint];      DO        WITH h.seb[csei] SELECT FROM          enumerated => f ¬ IP.InCtx[h, index, valueCtx];          subrange => {csei ¬ IP.TypeForSe[h, rangeType]; LOOP};          ENDCASE;        IF f # NIL THEN RETURN ELSE EXIT;        ENDLOOP};    f ¬ IP.OnStack[h, index];    IF f = NIL THEN IP.AbortWithError[h, notFound, index] };  SubtreeWork: PROC [h: Handle, index: Tree.Index, type: IT.SEIndex] = {    SELECT h.tb[index].name FROM      plus, minus, times, div, mod => {	f: Foo ¬ FirstSon[h, index, type];        Work[h, h.tb[index].son[2]];         Push[h, f];        IR.FoldExpr[h, h.tb[index].name];	IF IR.InConditional[h] THEN 	  IF Tos[h].constant THEN MakeOperand[h, Tos[h]] ELSE ERROR DIAbort };      uminus => {        -- in conditionals only legal if the the primary is a constant	-- we depend on FoldExpr to maintain that bit in the Foo        Work[h, h.tb[index].son[1]];	IR.FoldExpr[h, uminus];	IF IR.InConditional[h] THEN 	  IF ~Tos[h].constant THEN ERROR DIAbort 	  ELSE MakeOperand[h, Tos[h]] };      relE, relN, relL, relLE, relG, relGE => {        IF IR.InConditional[h] THEN {	  -- Evaluate the left h.operand, and put in in our pocket.	  -- Reset the operand, and evaluate the right operand	  -- If the operand is still a counter after evaluation of the 	  -- expression, then nobody called MakeOperand so we call it.	  f: Foo;	  lop: CPSwapDefs.OperandDesc;	  h.operand­ ¬ [0, 16, counter[0]];	  f ¬ FirstSon[h, index];	  IF h.operand.type = counter THEN MakeOperand[h, f];	  lop ¬ h.operand­;	  h.operand­ ¬ [0, 16, counter[0]];	  TargetTypeWork[h, h.tb[index].son[2], IP.TypeForSe[h, f.tsei]];	  f ¬ Pop[h];	  IF h.operand.type = counter THEN MakeOperand[h, f];	  IQ.Condition[h: h, left: lop, rel: h.tb[index].name, right: h.operand­];}	ELSE {	  lhs, rhs: Foo;	  lhs ¬ FirstSon[h, index];	  IP.GetValue[h, lhs];	  TargetTypeWork[h, h.tb[index].son[2], IP.TypeForSe[h, lhs.tsei]];	  rhs ¬ Pop[h];	  IR.Relation[h, lhs, rhs, h.tb[index].name] }};      base => IR.Base[h, FirstSon[h, index], type];      length => IR.Length[h, FirstSon[h, index], type];      size => IR.Size[h, FirstSon[h, index]];      first => IR.First[h, FirstSon[h, index]];      last => IR.Last[h, FirstSon[h, index]];      clit => {        f: Foo ¬ FindLiteral[h, IR.CheckLink[h, h.tb[index].son[1], literal]];        f.tsei ¬ com.typeCHAR;        f.addr.offset ¬ 8;	f.words ¬ 0; -- ugh	f.bits ¬ 8; -- ugh        Push[h, f] };      mwconst => {        f: Foo ¬ FindLiteral[h, IR.CheckLink[h, h.tb[index].son[1], literal]];        f.tsei ¬ type;        Push[h, f] };      lint => Work[h, h.tb[index].son[1], IP.MakeLongType[h, Symbols.typeANY]];      lcard => Work[h, h.tb[index].son[1], IP.MakeLongType[h, com.typeCARDINAL]];      int => NumberWork[h, h.tb[index].son[1], Symbols.typeANY, type];      card => NumberWork[h, h.tb[index].son[1], com.typeCARDINAL, type];      spareS3 => Work[h, h.tb[index].son[1], com.typeREAL];      typeDollar => {        id: IT.HTIndex ¬ IR.CheckLink[h, h.tb[index].son[2], hash];        mod: IT.HTIndex ¬ IR.CheckLink[h, h.tb[index].son[1], hash];        f: Foo ¬ IP.InMod[h, id, mod ! IP.MultipleFrames => IP.AbortWithError[h, wrongDollar, mod]];        IF f = NIL THEN IP.AbortWithError[h, notFound, id];        IF ~f.typeOnly THEN IP.Error[h, notType, id];        Push[h, f] };      addr => TakeAddress[h, FirstSon[h, index, type]];      arraydesc => NotImpl[h, arraydesc];      typecode => {        op: OpHandle = h.operand;	f: Foo;	h.operand ¬ NIL;	f ¬ FirstSon[h, index, type ! UNWIND => h.operand ¬ op];	h.operand ¬ op;	TakeType[h, f]};      uparrow => {        f: Foo ¬ Son[h, h.tb[index].son[1], type];	MakeOperand[h, f];	IF ~Deref[h, f] THEN IP.AbortWithError[h, invalidPointer, f.hti] };      dot => Qualify[h, FirstSon[h, index], IR.CheckLink[h, h.tb[index].son[2], hash]];      apply => {        f: Foo ¬ FirstSon[h, index];	--IF f.typeOnly THEN IP.AbortWithError[h, wrongBrackets, f.hti];	IR.DoApply[h, h.tb[index].son[2], f]};      loophole => {        f: Foo;        IF h.tb[index].son[2] = Tree.Null THEN {          Work[h, h.tb[index].son[1], type]; f ¬ Tos[h]; LoopHole[h, f, type]}        ELSE {          Work[h, h.tb[index].son[2], type];          f ¬ Pop[h];          IF ~f.typeOnly THEN IP.Error[h, notType, f.hti];          LoopHoleWork[h, h.tb[index].son[1], f.tsei] }};      fileDollar => {        id: IT.HTIndex ¬ IR.CheckLink[h, h.tb[index].son[2], hash];        mod: IT.HTIndex ¬ IR.CheckLink[h, h.tb[index].son[1], hash];        f: Foo ¬ IP.InMod[h, id, mod ! IP.MultipleFrames => IP.AbortWithError[h, wrongDollar, mod]];        IF f = NIL THEN IP.AbortWithError[h, notFound, id];        Push[h, f] };      frameDollar => {        id: IT.HTIndex ¬ IR.CheckLink[h, h.tb[index].son[2], hash];        f: Foo ¬ FindLiteral[h, IR.CheckLink[h, h.tb[index].son[1], literal]];        f ¬ IP.InLF[h, id, LOOPHOLE[f.addr.base, LONG POINTER TO LFHandle]­];        IF f = NIL THEN IP.AbortWithError[h, notFound, id];        Push[h, f] };      memory => IR.Memory[h, h.tb[index].son[1], type];      nil => IR.PushNil[h, FirstSon[h, index, type]];      procTC => {        f: Foo ¬ IO.AllocFob[h];        f.tsei ¬ IR.MakeXferType[h, proc];        f.typeOnly ¬ TRUE;        Push[h, f] };      errorTC => {        f: Foo ¬ IO.AllocFob[h];        f.tsei ¬ IR.MakeXferType[h, error];        f.typeOnly ¬ TRUE;        Push[h, f] };      signalTC => {        f: Foo ¬ IO.AllocFob[h];        f.tsei ¬ IR.MakeXferType[h, signal];        f.typeOnly ¬ TRUE;        Push[h, f] };      longTC => {        f: Foo ¬ Son[h, h.tb[index].son[1], type];        f.tsei ¬ IP.MakeLongType[h, f.tsei] };      pointerTC => {        f: Foo ¬ Son[h, h.tb[index].son[1], type];        f.tsei ¬ IR.MakePointerType[h, f.tsei] };      discrimTC => {        f: Foo ¬ Son[h, h.tb[index].son[1], type];        f.tsei ¬ IR.SelectVariantType[h, f.tsei, IR.CheckLink[h, h.tb[index].son[2], hash]] };      lengthen => {        f: Foo ¬ Son[h, h.tb[index].son[1], type];	IF IR.InConditional[h] AND ~f.constant THEN ERROR DIAbort;	IR.LengthenFob[h, f]};      abs => {        IR.Abs[h, h.tb[index].son[1], type];	IF IR.InConditional[h] AND ~Tos[h].constant THEN ERROR DIAbort};      min, max => {        size: NumberType;        cnt: CARDINAL;        signed: BOOLEAN;        [size, cnt, signed] ¬ IR.GetSize[h, index, type];        SELECT h.tb[index].name FROM	  min => IR.Min[h, size, cnt, signed];	  max => IR.Max[h, size, cnt, signed];	  ENDCASE;	IF IR.InConditional[h] AND ~Tos[h].constant THEN ERROR DIAbort };      intOO => IR.Interval[h: h, t: h.tb[index].son[1], type: type, openLow: TRUE, openHigh: TRUE];      intOC => IR.Interval[h:h,t: h.tb[index].son[1], type: type, openLow: TRUE];      intCO => IR.Interval[h:h,t: h.tb[index].son[1], type: type, openHigh: TRUE];      intCC => IR.Interval[h:h,t: h.tb[index].son[1], type: type];      bang => IR.Interval[h:h,t: h.tb[index].son[1], type: type, cntOnly: TRUE];      ENDCASE => NotImpl[h, h.tb[index].name] };  NotImpl: PROC [h: Handle, n: Tree.NodeName] = {    s: STRING ¬ [20];    String.AppendString[s, "Tree node "L];    String.AppendOctal[s, n];    SIGNAL NotImplemented[s] };  Deref: PUBLIC PROC [h: Handle, f: Foo] RETURNS [success: BOOLEAN] = {    tsei: IT.CSEIndex ¬ IP.TypeForSe[h, f.tsei];    ref: IT.SEIndex;    DO      WITH h.seb[tsei] SELECT FROM        ref => {          IF f.typeOnly THEN {            f­ ¬ NullFob;            f.tsei ¬ refType;            f.typeOnly ¬ TRUE;            WITH h.seb[refType] SELECT FROM id => f.hti ¬ hash; ENDCASE;            RETURN[TRUE]};          ref ¬ IP.TypeForSe[h, refType];          EXIT};        long => tsei ¬ IP.TypeForSe[h, rangeType];        subrange => tsei ¬ IP.TypeForSe[h, rangeType];        ENDCASE => GOTO cant;      ENDLOOP;    IF ~IR.InConditional[h] THEN {      n: Number;      IF f.addr.base = NIL THEN IP.AbortWithError[h, nilChk, f.hti];      n ¬ GetNumber[h, f, invalidPointer];      IF n.lp = NIL THEN IP.AbortWithError[h, nilChk, f.hti];      SELECT n.type FROM	one => f.addr.base ¬ WorldVMOps.Long[h.world, n.p];	two => f.addr.base ¬ n.lp;	ENDCASE};    f.tsei ¬ ref;    f.words ¬ CARDINAL[SymbolOps.WordsForType[h.sym, ref]];    f.typeOnly ¬ FALSE;    f.addr.offset ¬ 0;    f.addr.useStack ¬ FALSE;    f.bits ¬ 0;    f.there ¬ TRUE;    f.constant ¬ FALSE;    IP.CheckForHiddenPadding[h, f];    IF IR.InConditional[h] THEN DerefOperand[h, f];    RETURN[TRUE];    EXITS cant => RETURN[FALSE] };  Qualify: PUBLIC PROC [h: Handle, f: Foo, hti: IT.HTIndex] = {    original, root: CSEIndex;    MakeOperand[h, f];    WHILE Deref[h, f] DO NULL ENDLOOP;    original ¬ IP.TypeForSe[h, f.tsei];    root ¬ IP.TypeForSe[h, SymbolOps.TypeRoot[h.sym, original]];    SELECT TRUE FROM      QualifyCsei[h, f, hti, original] => RETURN;      root # original => IF QualifyCsei[h, f, hti, root] THEN RETURN;      ENDCASE;    IP.AbortWithError[h, notValidField, hti] };  QualifyCsei: PUBLIC PROC [h: Handle, f: Foo, hti: IT.HTIndex, csei: IT.CSEIndex] RETURNS [found: BOOLEAN] = {    ENABLE IP.NotRelocated => IF IR.InConditional[h] THEN RESUME[NIL] ELSE IP.AbortWithError[h, spare2, f.hti];    pad: CARDINAL;    WITH h.seb[csei] SELECT FROM      opaque =>         IF ~lengthKnown AND length = LAST[CARDINAL] THEN {	  -- somebody has attached this opaque type, reset the type of the foo and try again	  f.tsei ¬ id;	  Qualify[h, f, hti];	  RETURN[TRUE] };      record => {        isei: IT.ISEIndex;        pad ¬ IP.Pad[h, f, LOOPHOLE[csei]];        IF (found ¬ SearchCtx[h, f, fieldCtx, hti, pad]) THEN { SelectOperand[h: h, oldAddr: f.addr, newFoo: Tos[h]]; RETURN };        IF hints.variant AND (found ¬ SearchVariants[h, f, hti, pad, LOOPHOLE[IR.VariantUnionType[h, LOOPHOLE[csei]]]]) THEN { SelectOperand[h: h, oldAddr: f.addr, newFoo: Tos[h]]; RETURN };        IF (isei ¬ VariantField[h, csei]) # Symbols.ISENull THEN          WITH h.seb[IP.TypeForSe[h, isei]] SELECT FROM            sequence => {	      IF (found ¬ CheckSeqTag[h, f, hti, pad, tagSei]) THEN SelectOperand[h: h, oldAddr: f.addr, newFoo: Tos[h]]; 	      RETURN };            ENDCASE };      sequence => {        IF (found ¬ CheckSeqTag[h, f, hti, 0, tagSei]) THEN SelectOperand[h: h, oldAddr: f.addr, newFoo: Tos[h]]; 	RETURN };      definition => {        temp: Fob ¬ NullFob;        gf: GFHandle ¬ IS.GFFromIContext[h];        isei: IT.ISEIndex = IP.SearchCtxList[h, hti, defCtx];        reallyThere: BOOLEAN;        IF isei = Symbols.ISENull THEN RETURN[FALSE];        temp.addr.base ¬ gf;        temp.tsei ¬ f.tsei;        temp.there ¬ TRUE;        temp.indent ¬ f.indent;        reallyThere ¬ SELECT IP.Mode[h, isei] FROM refVal => TRUE, refProc => FALSE, ENDCASE => FALSE;        IF (found ¬ SearchCtx[h, @temp, defCtx, hti, 0]) THEN Tos[h].f.there ¬ reallyThere; 	RETURN };      enumerated => {        Push[h, HashWork[h, hti, csei]];	RETURN[TRUE] };      ENDCASE => IP.AbortWithError[h, typeMismatch, f.hti];    RETURN[FALSE] };  VariantField: PUBLIC PROC [h: Handle, type: IT.CSEIndex] RETURNS [sei: IT.ISEIndex] = {    WITH t: h.seb[type] SELECT FROM      record => {        root: IT.ISEIndex;        sei ¬ root ¬ SymbolOps.FirstCtxSe[h.sym, t.fieldCtx];        DO          IF sei = Symbols.SENull THEN RETURN;          SELECT SymbolOps.TypeForm[h.sym, h.seb[sei].idType] FROM            sequence, union => RETURN;            ENDCASE;          WITH id: h.seb[sei] SELECT FROM            sequential => sei ¬ sei + SIZE[sequential id Symbols.SERecord];            linked => IF (sei ¬ id.link) = root THEN RETURN[Symbols.ISENull];            ENDCASE => RETURN[Symbols.ISENull];          ENDLOOP};      ENDCASE => RETURN[Symbols.ISENull] };  SearchCtx: PROC [h: Handle, f: Foo, ctx: IT.CTXIndex, hti: IT.HTIndex, pad: CARDINAL] RETURNS [BOOLEAN] = {    isei: IT.ISEIndex ¬ IP.SearchCtxList[h, hti, ctx];    field: Foo;    IF isei = Symbols.ISENull THEN RETURN[FALSE];    IF f.typeOnly THEN {      field ¬ IO.AllocFob[h];      field­ ¬ f­;      field.hti ¬ h.seb[isei].hash;      field.tsei ¬ isei }    ELSE {      temp: BOOLEAN = f.addr.useStack;      f.addr.useStack ¬ FALSE;      field ¬ IP.FindField[h, f, pad, isei];      f.addr.useStack ¬ temp;      IF field = NIL THEN RETURN[FALSE]};    Push[h, field];    RETURN[TRUE] };  CheckSeqTag: PROC [h: Handle, f: Foo, hti: IT.HTIndex, pad: CARDINAL, tag: IT.ISEIndex] RETURNS [BOOLEAN] = {    IF h.seb[tag].hash # hti THEN RETURN[FALSE];    Push[h, IP.FindField[h, f, pad, tag]];    RETURN[TRUE] };  SearchRecord: PROC [h: Handle, f: Foo, sei: IT.SEIndex, hti: IT.HTIndex, pad: CARDINAL] RETURNS [BOOLEAN] = {    rsei: IT.RecordSEIndex ¬ LOOPHOLE[IP.TypeForSe[h, sei]];    RETURN[SearchCtx[h, f, h.seb[rsei].fieldCtx, hti, pad]] };  SearchVariants: PROC [h: Handle, f: Foo, hti: IT.HTIndex, pad: CARDINAL, usei: UnionSEIndex] RETURNS [BOOLEAN] = {    isei: IT.ISEIndex;    IF usei = Symbols.typeANY THEN RETURN[FALSE];    SELECT IP.VariantType[h, usei] FROM      controlled => {        isei ¬ h.seb[usei].tagSei;        IF h.seb[isei].hash = hti THEN {          field: Foo ¬ IP.FindField[h, f, pad, isei];          IF field = NIL THEN RETURN[FALSE];          Push[h, field];          RETURN[TRUE] };        isei ¬ IP.TagIsei[h, f, pad, usei];        IF isei = Symbols.ISENull THEN RETURN[FALSE];        RETURN[SearchRecord[h, f, SymbolOps.ToSei[h.seb[isei].idInfo], hti, pad]] };      overlaid => {        IP.Complete[h, h.seb[usei].caseCtx];        FOR isei ¬ SymbolOps.FirstCtxSe[h.sym, h.seb[usei].caseCtx], 	  SymbolOps.NextSe[h.sym, isei] UNTIL isei = Symbols.ISENull DO          IF SearchRecord[h, f, SymbolOps.ToSei[h.seb[isei].idInfo], hti, pad] THEN RETURN[TRUE];          ENDLOOP;        RETURN[FALSE] };      computed => {        cnt: CARDINAL ¬ 0;        IP.Complete[h, h.seb[usei].caseCtx];        FOR isei ¬ SymbolOps.FirstCtxSe[h.sym, h.seb[usei].caseCtx], SymbolOps.NextSe[h.sym, isei] UNTIL isei = Symbols.ISENull DO          IF SearchRecord[h, f, SymbolOps.ToSei[h.seb[isei].idInfo], hti, pad] THEN cnt ¬ cnt + 1;          IF cnt > 1 THEN IP.AbortWithError[h, notUniqueField, hti];          ENDLOOP;        RETURN[cnt = 1] };      ENDCASE => ERROR };  TakeAddress: PROC [h: Handle, f: Foo] = {    addr: LONG POINTER = f.addr.base;    tsei: IT.SEIndex = IR.MakePointerType[h, f.tsei];    IF IR.InConditional[h] THEN ERROR DIAbort;    IF f.addr.offset # 0 OR ~f.there THEN IP.AbortWithError[h, invalidAddress, f.hti];    IF Inline.HighHalf[addr] = WorldVMOps.GetMDS[h.world] THEN PushVal[h, Inline.LowHalf[addr], tsei] ELSE PushLongVal[h, addr, tsei];    f.constant ¬ FALSE };  TakeType: PROC [h: Handle, f: Foo] = {    Push[h, SymbolWork[h, IP.TypeForSe[h, f.tsei]]]};  LoopHole: PUBLIC PROC [h: Handle, f: Foo, type: IT.SEIndex, lengthen: BOOLEAN ¬ FALSE] = {    tSize: CARDINAL;    checkSize: BOOLEAN ¬ TRUE;    csei: IT.CSEIndex = IP.TypeForSe[h, type];    WITH h.seb[csei] SELECT FROM subrange => checkSize ¬ (range # 0); ENDCASE;    SELECT TRUE FROM      f = NIL => RETURN;      f.tsei = type => RETURN;      type = h.nullProc => type ¬ LoopHoleControlLink[h, f, LOOPHOLE[IP.Procedure] ! IP.NotAProcedure => GO TO notProc];      type = h.nullSig OR type = h.nullError => type ¬ LoopHoleControlLink[h, f, LOOPHOLE[IP.Signal] ! IP.NotAProcedure => GO TO notProc];      ~checkSize => NULL;      IR.TotalWords[h, f] = (tSize ¬ CARDINAL[SymbolOps.WordsForType[h.sym, csei]]) => NULL;      ~lengthen => IP.AbortWithError[h, sizeMismatch];      tSize # 2 => IP.AbortWithError[h, sizeMismatch];      ~CheckLength[h, f, 1] => IP.AbortWithError[h, sizeMismatch];      ENDCASE => IR.LengthenFob[h, f];    f.tsei ¬ type;    EXITS notProc => IP.AbortWithError[h, notProcDesc]};  LoopHoleControlLink: PROC [h: Handle, f: Foo, clproc: PROC [Handle, ControlLink] RETURNS [IT.ISEIndex]] RETURNS [isei: IT.SEIndex] = {    gf: GFHandle;    desc: ControlLink ¬ IP.GetControlLink[h, f];    IF LOOPHOLE[desc, PrincOps.ControlLink].indirect THEN desc ¬ IP.DerefProcDesc[h, desc];     gf ¬ IC.GFFromControlLink[h, desc];    IF ~IQ.ValidateGF[h, gf] THEN IP.AbortWithError[h, notProcDesc];    isei ¬ clproc[h, desc ! SymbolTable.Missing => {isei ¬ Symbols.ISENull; CONTINUE}];    IF isei = Symbols.ISENull THEN IP.AbortWithError[h, notFound, IP.HtiForFrame[h, gf]]    ELSE RETURN[IP.TypeForSe[h, isei]]};  FindLiteral: PROC [h: Handle, info: Literals.LitRecord] RETURNS [f: Foo] = {    f ¬ IO.AllocFob[h];    [f.addr.base, f.words] ¬ IP.CopyLiteral[h, info];    WITH info SELECT FROM      string => f.tsei ¬ com.typeSTRING;      ENDCASE => f.tsei ¬ Symbols.typeANY;    f.constant ¬ TRUE };  CheckLength: PUBLIC PROC [h: Handle, f: Foo, size: CARDINAL] RETURNS [BOOLEAN] = {    IF f.words # size OR f.bits # 0 OR f.addr.offset # 0 THEN RETURN[FALSE]    ELSE RETURN[TRUE] };  NumberLength: PUBLIC PROC [h: Handle, f: Foo] RETURNS [nt: NumberType] = {    IF CheckLength[h, f, 1] THEN RETURN[one];    IF CheckLength[h, f, 2] THEN RETURN[two];    RETURN[nogood] };  GetNumber: PUBLIC PROC [h: Handle, f: Foo, code: CommandList.DIErr ¬ invalidNumber] RETURNS [n: Number] = {    p: LONG POINTER TO Words;    csei: IT.CSEIndex;    size: CARDINAL = IR.TotalWords[h, f];    IF size IN [1..2] THEN n.type ¬ LOOPHOLE[size] ELSE IP.AbortWithError[h, code];    IP.GetValue[h, f];    p ¬ f.addr.base;    IF WorldVMOps.NilAddress[h.world, p] THEN IP.AbortWithError[h, code];    FOR i: NumberType IN [nogood..n.type) DO n.w[i] ¬ p[i]; ENDLOOP;    IF (csei ¬ IP.TypeForSe[h, f.tsei]) = com.typeCARDINAL THEN RETURN;    WITH h.seb[csei] SELECT FROM      subrange => IF n.type = one THEN n.i ¬ n.i + origin ELSE IP.AbortWithError[h, invalidSubrange];      ENDCASE };  PushVal: PUBLIC PROC [h: Handle, u: UNSPECIFIED, tsei: IT.SEIndex] = {    f: Foo ¬ IO.AllocFob[h];    p: LONG POINTER TO UNSPECIFIED;    f.addr.base ¬ p ¬ IO.zone.NEW[UNSPECIFIED ¬ u];    f.words ¬ SIZE[UNSPECIFIED];    f.tsei ¬ tsei;    Push[h, f] };  PushLongVal: PUBLIC PROC [h: Handle, lu: LONG UNSPECIFIED, tsei: IT.SEIndex] = {    f: Foo ¬ IO.AllocFob[h];    p: LONG POINTER TO LONG UNSPECIFIED;    f.addr.base ¬ p ¬ IO.zone.NEW[LONG UNSPECIFIED ¬ lu];    f.words ¬ SIZE[LONG UNSPECIFIED];    f.tsei ¬ IP.MakeLongType[h, tsei];    Push[h, f] };  Push: PUBLIC PROC [h: Handle, f: Foo] = {    h.fooStack ¬ IO.zone.NEW[Stack ¬ [h.fooStack, f]] };  Pop: PUBLIC PROC[h: Handle] RETURNS [f: Foo] = {    old: LONG POINTER TO Stack ¬ h.fooStack;    IF old = NIL THEN ERROR Underflow;    f ¬ old.foo;    h.fooStack ¬ old.link;    IO.zone.FREE[@old] };  ResetStack: PROC[h: Handle] = {    UNTIL h.fooStack = NIL DO      temp: LONG POINTER TO Stack ¬ h.fooStack;      h.fooStack ¬ temp.link;      IO.zone.FREE[@temp];      ENDLOOP };  Tos: PUBLIC PROC[h: Handle] RETURNS [f: Foo] = {    old: LONG POINTER TO Stack ¬ h.fooStack;    IF old = NIL THEN ERROR Underflow;    RETURN[old.foo] };  CheckForStackEmpty: PUBLIC PROC[h: Handle] = {    IF h.fooStack # NIL THEN ERROR StackNotEmptyAtStatement };  }.
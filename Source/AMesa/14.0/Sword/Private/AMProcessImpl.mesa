-- File: AMProcessImpl.mesa - last edit:-- Litman              22-Apr-87 18:19:07-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.DIRECTORY  AMEvents USING [LFHandle, Outcome, ProvokeProcessEvent],  AMHeap USING [zone],  AMModel USING [ChildProc, Context, ContextChildren, ContextWorld, IsNullContext, nullContext],  AMProcess USING [ArgsOrResults, LFHandle, Process, ProcessList, ProcessRec],  AMProcessBasic USING [Abort, GFTable, GFTableObject, Info, Process, State, StateArray, Thaw],  PSB USING [PDA, Priority, PsbIndex, StartPsb],  String USING [AppendLongNumber, AppendString],  WorldVM USING [LocalWorld, World],  WorldVMOps USING [Process, Read];AMProcessImpl: MONITOR   IMPORTS AMEvents, AMModel, AMProcessBasic, AMHeap, String, WorldVM, WorldVMOps  EXPORTS AMProcess = PUBLIC {  zone: UNCOUNTED ZONE = AMHeap.zone;  GetProcesses: ENTRY PROC[context: AMModel.Context, states: AMProcessBasic.StateArray] RETURNS[processList: AMProcess.ProcessList ¬ NIL] = {    world: WorldVM.World = IF AMModel.IsNullContext[context] THEN WorldVM.LocalWorld[] ELSE AMModel.ContextWorld[context];    count: CARDINAL = WorldVMOps.Read[world, @PSB.PDA.count];      filter: AMProcessBasic.GFTable ¬ ContextFrames[context, world];     FOR psbi: PSB.PsbIndex DECREASING IN [PSB.StartPsb..PSB.StartPsb+count) DO      state: AMProcessBasic.State;      frame: AMProcess.LFHandle;      [state: state, frame: frame] ¬ ProcessInfo[world, psbi, TRUE, FALSE, TRUE, filter, states];      IF state # dead AND frame # NIL THEN processList ¬ AddProcessToList[processList, [world, psbi]];      ENDLOOP;    IF filter # NIL THEN zone.FREE[@filter]};      AddProcessToList: PROC[processList: AMProcess.ProcessList, process: AMProcess.Process] RETURNS[AMProcess.ProcessList] = {    RETURN[zone.NEW[AMProcess.ProcessRec ¬ [next: processList, p: process]]]};      InList: PROC[processList: AMProcess.ProcessList, process: AMProcess.Process] RETURNS[BOOLEAN ¬ FALSE] = {    FOR l: AMProcess.ProcessList ¬ processList, l.next UNTIL l = NIL DO      IF l.p = process THEN RETURN[TRUE];      ENDLOOP};      MergeProcessLists: PROC[listA, listB: AMProcess.ProcessList] RETURNS[listC: AMProcess.ProcessList ¬ NIL] = {    -- Does not alter listA or listB. Assumes no duplicates within a list.    FOR l: AMProcess.ProcessList ¬ listA, l.next UNTIL l = NIL DO           listC ¬ AddProcessToList[listC, l.p];      ENDLOOP;    FOR l: AMProcess.ProcessList ¬ listB, l.next UNTIL l = NIL DO      IF ~InList[listC, l.p] THEN listC ¬ AddProcessToList[listC, l.p];      ENDLOOP };        DeleteProcessList: PROC[list: AMProcess.ProcessList] RETURNS[nil: AMProcess.ProcessList ¬ NIL] = {    UNTIL list = NIL DO        nil ¬ list.next;      zone.FREE[@list];      list ¬ nil;      ENDLOOP};      Name: PROC[p: WorldVMOps.Process, s: LONG STRING, radix: CARDINAL ¬ 10] = {    String.AppendString[s, "PSB "L];    String.AppendLongNumber[s, p, radix]};      Freeze: PROC[processes: AMProcess.ProcessList, context: AMModel.Context ¬ AMModel.nullContext] = {    FreezeOrAdjust[processes, context, FALSE]};      Adjust: PROC[processes: AMProcess.ProcessList, context: AMModel.Context ¬ AMModel.nullContext] = {    FreezeOrAdjust[processes, context, TRUE]};      FreezeOrAdjust: ENTRY PROC[l: AMProcess.ProcessList, context: AMModel.Context, thaw: BOOL] = {    world: WorldVM.World = IF AMModel.IsNullContext[context] THEN WorldVM.LocalWorld[] ELSE AMModel.ContextWorld[context];    count: CARDINAL = WorldVMOps.Read[world, @PSB.PDA.count];    filter: AMProcessBasic.GFTable ¬ ContextFrames[context, world];    FOR this: AMProcess.ProcessList ¬ l, this.next UNTIL this = NIL DO      IF this.p.world = world AND this.p.psbi IN [PSB.StartPsb..PSB.StartPsb+count)      THEN [] ¬ ProcessInfo[this.p.world, this.p.psbi, TRUE, thaw, FALSE, filter];      ENDLOOP;    IF filter # NIL THEN zone.FREE[@filter]};  Thaw: PROC[processes: AMProcess.ProcessList] = {    FOR this: AMProcess.ProcessList ¬ processes, this.next UNTIL this = NIL DO      count: CARDINAL = WorldVMOps.Read[this.p.world, @PSB.PDA.count];      IF this.p.psbi IN [PSB.StartPsb..PSB.StartPsb+count) THEN AMProcessBasic.Thaw[this.p.world, this.p.psbi];      ENDLOOP};        Abort: PROC[p: AMProcess.Process] = {    AMProcessBasic.Abort[p.world, p.psbi]};    NotImplemented: PRIVATE ERROR = CODE;      GetState: PROC[p: AMProcess.Process] RETURNS[state: AMProcessBasic.State, faultData: LONG CARDINAL, priority: PSB.Priority, stack: AMProcess.LFHandle, topFrame: BOOL] = {    frame, frozenframe, topframe: AMProcess.LFHandle;    [state, faultData, priority, frame, frozenframe, topframe] ¬ ProcessInfo[p.world, p.psbi];    SELECT TRUE FROM      frame # NIL => {stack ¬ frame; topFrame ¬ FALSE};      frozenframe # NIL => {stack ¬ frozenframe; topFrame ¬ FALSE};      topframe # NIL => {stack ¬ topframe; topFrame ¬ TRUE};      ENDCASE => {stack ¬ NIL; topFrame ¬ FALSE}};      CallDebugger: PROC[p: AMProcess.Process, msg: LONG STRING] = {    frozenFrame: AMProcess.LFHandle ¬ ProcessInfo[world: p.world, psbi: p.psbi, freeze: FALSE].frozenFrame;    IF frozenFrame = NIL THEN frozenFrame ¬ ProcessInfo[world: p.world, psbi: p.psbi, freeze: TRUE].frozenFrame;    IF frozenFrame # NIL THEN {      outcome: AMEvents.Outcome ¬ AMEvents.ProvokeProcessEvent[p, frozenFrame, msg];      WITH o: outcome SELECT FROM        proceed => NULL;        quit => Abort[p];        retry, returnFrom => ERROR NotImplemented[];        ENDCASE => ERROR}};      ReturnFrom: PROC[p: AMProcess.Process, frame: AMProcess.LFHandle, result: AMProcess.ArgsOrResults] = {    «STUB» ERROR NotImplemented };      Retry: PROC[p: AMProcess.Process, frame: AMProcess.LFHandle, args: AMProcess.ArgsOrResults] = {    «STUB» ERROR NotImplemented };    LocalOnly: ERROR = CODE;      ContextFrames: INTERNAL PROC[context: AMModel.Context, world: WorldVM.World]    RETURNS[filter: AMProcessBasic.GFTable ¬ NIL] = {    Add: AMModel.ChildProc = {      WITH c SELECT FROM        world => NULL;	model => [] ¬ AMModel.ContextChildren[c, Add];	prog => {	  IF filter = NIL OR filter.count = filter.max THEN {	    old: AMProcessBasic.GFTable ¬ filter;	    IF old # NIL THEN {	      filter ¬ zone.NEW[AMProcessBasic.GFTableObject[filter.max*2] ¬ 	        [count: old.count, seq: NULL]];	      FOR i: CARDINAL IN [0..old.count) DO filter[i] ¬ old[i] ENDLOOP;	      zone.FREE[@old] }	    ELSE filter ¬ zone.NEW[AMProcessBasic.GFTableObject[10]]};	  filter[filter.count] ¬ gf;	  filter.count ¬ filter.count+1 };	ENDCASE;	RETURN[FALSE] };    IF AMModel.ContextWorld[context] = world THEN [] ¬ Add[context] };      ProcessInfo: PROC[world: WorldVM.World, psbi: WorldVMOps.Process,       freeze: BOOL ¬ FALSE, thaw: BOOL ¬ FALSE, fullStatus: BOOL ¬ FALSE,       filter: AMProcessBasic.GFTable ¬ NIL, states: AMProcessBasic.StateArray ¬ ALL[TRUE]]    RETURNS[state: AMProcessBasic.State, faultData: LONG CARDINAL,       priority: PSB.Priority, frame: AMProcess.LFHandle,       frozenFrame: AMProcess.LFHandle, topFrame: AMProcess.LFHandle] = {    [state, faultData, priority, frame, frozenFrame, topFrame] ¬       AMProcessBasic.Info[world, psbi, freeze, thaw, fullStatus, filter, states] };    }.
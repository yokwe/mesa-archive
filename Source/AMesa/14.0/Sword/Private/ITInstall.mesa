-- File: ITInstall.mesa - last edit:-- Litman              21-Apr-87 15:24:23-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.  DIRECTORY  Alloc USING [AddNotify, Chunkify, Create, Destroy, DropNotify, Handle, Notifier, TableInfo],  AMEvents USING [CallDebugger, Event, EventProc, GetEvents, HandleLocalEvents, Outcome, Process, StopEvents, World],  AMHeap USING [zone],  Ascii USING [CR, NUL],  Context USING [Create, DestroyProcType, Find, Type, UniqueType],  EventTypes USING [newSession, resumeSession],  Exec USING [AddCommand, ExecProc, FreeTokenString, GetToken, GetTTY, Handle, MatchPattern, Object, Outcome, OutputProc, ReleaseTTY, RemoveCommand],  ExecInternal USING [Object],  Format USING [StringProc],  Heap USING [Create, Delete],  HeraldWindow USING [AppendBrokenMessage, AppendMessage],  IA USING [UnloadDebugUsefulDefs, UnloadITWiskOperations],  ID USING [ProcessUserCm, Filter],  IE USING [StopSym],  IH USING [],  IK USING [],  IL USING [MakeCommandForm, MakeConfigSW, MakeFlowSW, SetFormSWClient],  IM,  IO USING [EOL, FlushCaches, Kill, NonAbortableText, options, Proceed, Quit, Redisplay, SetOutput, zone],  IQ USING [ClearAllBreaks, InitSym, Invalidate],  IS USING [Go, Prompt, ResetContext, ShowTypeWithProc, Umbrella],  IT USING [ClientFormItems, Handle, Object, Process, WordBoolean],  ITExtras USING [InterpreterState, Spare],  ITajo USING [],  IV USING [PutLongRepsWithProc],  IZ USING [],  Menu USING [Destroy, Handle, Instantiate, Make, MCRType, Uninstantiate],  MFile USING [Error, Handle, maxNameLength, Object, ReadWrite, Release, Type],  Process USING [Detach, GetPriority, Priority, priorityForeground, SetPriority],  Runtime USING [IsBound],  RuntimeInternal USING [WorryCallDebugger],  Selection USING [Convert, LongNumber],  String USING [AppendChar, AppendDecimal, AppendString, Equivalent, EquivalentString, FreeString, InvalidNumber, MakeString],  SwordUsefulDefs USING [InterpreterAvailable, SetDefaultWorld],  SymbolSegment,  SymbolTable USING [Handle, Object],  Time,  Tool USING [Create, Destroy, MakeFormSW, MakeSWsProc, MakeTTYSW, State],  ToolWindow USING [Activate, Handle, SetName, State, TransitionProcType],  TTY USING [CharsAvailable, GetChar, Handle, nullHandle, PutLine, SetEcho],  TTYSW USING [Error, GetTTYHandle],  TTYSword USING [],  UserInput USING [StuffCharacter],  Watch USING [StopTrace],  Window USING [Handle, Object, Root, rootWindow, GetParent, GetChild, Stack, ValidateTree],  WorldVM USING [BadWorld, InvalidateWorld, LocalWorld, OutloadWorld, RemoteWorld, SetTTY, UnloadWVMOutLd, UnloadWVMTeledebug, VolumeForOutload, World, WorldName, WorldType],  WorldVMExtras USING [SetBreakNumber],  WorldVMOps USING [GetESV, GetType, Process, ProcessLong, SetSymbols],  WVMBooting USING [UnloadWVMBooting];  ITInstall: MONITOR LOCKS l USING l: Lock  IMPORTS Alloc, AMEvents, AMHeap, Context, Exec, Heap, HeraldWindow, IA, ID, IE, IL, IM, IO, IQ, IS, IV, Menu, MFile, Process, Runtime, RuntimeInternal, Selection, String, SwordUsefulDefs, Time, Tool, ToolWindow, TTY, TTYSW, UserInput, Watch, Window, WorldVM, WorldVMExtras, WorldVMOps, WVMBooting  EXPORTS IA, IH, IK, IL, IO, ITajo, IV, IZ, TTYSword  = {    zone: PUBLIC «IO» UNCOUNTED ZONE ¬ Heap.Create[initial: 64, increment: 64, largeNodeThreshold: 32765, ownerChecking: FALSE, checking: FALSE];  alloc: PUBLIC «IO» Alloc.Handle ¬ NIL;  symboltable: PUBLIC «IO» SymbolTable.Handle ¬ NIL;  MyContextType: PUBLIC «IO» Context.Type ¬ IF windows THEN Context.UniqueType[] ELSE last;  Interpreters: PUBLIC «IZ» IT.Handle ¬ NIL;  Lock: TYPE = LONG POINTER TO MONITORLOCK;  EnumerateProcType: TYPE = PROC[h: IT.Handle] RETURNS[done: BOOLEAN];     Available: CONDITION; -- should be in ITExtras  SetupCleanup: MONITORLOCK; -- protects Interpreters  windows: BOOLEAN = Runtime.IsBound[LOOPHOLE[Tool.Create]];      menu: Menu.Handle ¬ NIL;  ttyGlobal: TTY.Handle ¬ TTY.nullHandle;  execGlobal: Exec.Handle ¬ NIL;    FileSWChanged: CONDITION;  FileSWLock: MONITORLOCK;  WaitFileSW: ENTRY PROC[l: Lock] = { WAIT FileSWChanged };  BroadcastFileSW: ENTRY PROC[l: Lock] = { BROADCAST FileSWChanged };  ResetFileSW: PROC[h: IT.Handle] = { h.fileSW ¬ NIL };  FileSWChange: PROC[h: IT.Handle] RETURNS[BOOLEAN] = { RETURN[h.fileSW # NIL] };    Activated: CONDITION;  ActivateLock: MONITORLOCK;  SomebodyWaiting: ENTRY PROC[l: Lock] = { WAIT Activated };  BroadcastActivated: ENTRY PROC[l: Lock] = { BROADCAST Activated };  StringProc: PROC[h: IT.Handle] RETURNS[outcome: AMEvents.Outcome] = {    ENABLE { « ABORTED gets caught in AMEvents »      IO.Proceed => { outcome ¬ [proceed[NIL]]; CONTINUE };      IO.Quit => { outcome ¬ [quit[]]; CONTINUE };      IO.Kill => { outcome ¬ [kill[]]; CONTINUE }};    UmbilicalGo1: PROC[IT.Handle, LONG UNSPECIFIED] = { IS.ResetContext[h] };     UmbilicalGo2: PROC[IT.Handle, LONG UNSPECIFIED] = { IO.Redisplay[h] };     UmbilicalGo3: PROC[IT.Handle, LONG UNSPECIFIED] = { IS.Go[h] };    UmbilicalGo4: PROC[IT.Handle, LONG UNSPECIFIED] = {      c: CHARACTER;      c ¬ TTY.GetChar[h.tty ! ABORTED => IF CatchFirstAbortedP[h] THEN GOTO WaitForActivation ELSE GOTO Ignore];      IF c = Ascii.NUL THEN NullSignal[h] ELSE h.parse[h, c];      EXITS         Ignore => NULL;        WaitForActivation => { 	  UNTIL ~CatchFirstAbortedP[h] DO SomebodyWaiting[@ActivateLock]; ENDLOOP;	  ResetFileSW[h];	  UNTIL FileSWChange[h] DO WaitFileSW[@FileSWLock]; ENDLOOP;	  IS.Prompt[h] }};    DoStackSubwindow[h];    IS.Umbrella[h, 0, UmbilicalGo1];    IS.Umbrella[h, 0, UmbilicalGo2];    ResetNullSignal[h];    FOR i: CARDINAL IN [0..TTY.CharsAvailable[h.tty]) DO [] ¬ TTY.GetChar[h.tty]; ENDLOOP; -- flush tty    IS.Umbrella[h, 0, UmbilicalGo3];    DO IS.Umbrella[h, 0, UmbilicalGo4] ENDLOOP };    Transition: ToolWindow.TransitionProcType = {    h: IT.Handle;    IF (h ¬ Context.Find[MyContextType, window]) = NIL THEN h ¬ SIGNAL GetITHandle[];    SELECT new FROM      inactive => CatchFirstAborted[h];      tiny => NULL;      active => { ResetCatch[h]; BroadcastActivated[@ActivateLock] };      ENDCASE};    CatchFirstAborted: PROC[h: IT.Handle] = {    LOOPHOLE[h.spare, ITExtras.Spare].state ¬ ITExtras.InterpreterState.catchFirstAborted };      CatchFirstAbortedP: PROC[h: IT.Handle] RETURNS[BOOLEAN] = {    RETURN[LOOPHOLE[h.spare, ITExtras.Spare].state = ITExtras.InterpreterState.catchFirstAborted]};      ResetCatch: PROC[h: IT.Handle] = {    LOOPHOLE[h.spare, ITExtras.Spare].state ¬ ITExtras.InterpreterState.reset };        NullSignal: PROC[h: IT.Handle] = {    SELECT LOOPHOLE[h.spare, ITExtras.Spare].state FROM      ITExtras.InterpreterState.proceed => SIGNAL IO.Proceed;      ITExtras.InterpreterState.quit => SIGNAL IO.Quit;      ITExtras.InterpreterState.kill => SIGNAL IO.Kill;      ITExtras.InterpreterState.abort => ERROR ABORTED;      ENDCASE };        ResetNullSignal: PROC[h: IT.Handle] = {    LOOPHOLE[h.spare, ITExtras.Spare].state ¬ ITExtras.InterpreterState.reset };      SendChars: PUBLIC «IV» PROC [h: IT.Handle, s: LONG STRING] = {    i: CARDINAL ¬ 0;    IF s = NIL THEN RETURN;    UNTIL i >= s.length DO      IF s[i] = '\\ THEN {        SELECT s[i+1] FROM          'n => { 	    -- h.parse[h, Ascii.CR]; 	    [] ¬ UserInput.StuffCharacter[h.fileSW, Ascii.CR]; i ¬ i + 2 };	  ENDCASE}      ELSE {         -- h.parse[h, s[i]]; 	[] ¬ UserInput.StuffCharacter[h.fileSW, s[i]]; i ¬ i + 1 };      ENDLOOP};      CantOpenLog: ERROR = CODE;  GetITHandle: PUBLIC «IL» SIGNAL[] RETURNS[IT.Handle] = CODE;    AllocateInterpreter: PROC[] RETURNS[h: IT.Handle] = {    h ¬ zone.NEW[IT.Object]; Enlink[h];    h.sym ¬ symboltable;     h.flows ¬ IO.options.processes;    h.configs ¬ IO.options.configs;    Alloc.AddNotify[alloc, UpdateBases, h];    h.logname ¬ NIL };      CreateOne: PROC[world: WorldVM.World] RETURNS[h: IT.Handle] = {    namestripe: LONG STRING ¬ [MFile.maxNameLength]; -- might need more    h ¬ AllocateInterpreter[];    h.world ¬ world;    String.AppendString[namestripe, "Dormant"L];    PutLogIntoNamestripe[h, namestripe];    CreateTool[h, namestripe, inactive];    IL.SetFormSWClient[h, dormant] };      InterpreterForWorld: PUBLIC «IH» PROC[world: WorldVM.World] RETURNS[h: IT.Handle] = {    FOR h ¬ Interpreters, h.next UNTIL h = NIL DO      IF h.world = world THEN RETURN;      REPEAT FINISHED => RETURN[CreateOne[world]];      ENDLOOP };    SomeInterpreter: PUBLIC «IH» PROC[worldType: WorldVM.WorldType] RETURNS[h: IT.Handle] = {    FOR h ¬ Interpreters, h.next UNTIL h = NIL DO      IF (worldType = none) OR (WorldVMOps.GetType[h.world] = worldType) THEN RETURN;      REPEAT FINISHED => RETURN[CreateOne[WorldVM.LocalWorld[]]];      ENDLOOP};  Enlink: PROC[h: IT.Handle] = {h.next ¬ Interpreters; Interpreters ¬ h};    Delink: PROC[h: IT.Handle] = {    IF h = Interpreters THEN Interpreters ¬ h.next    ELSE {       prev: IT.Handle ¬ Interpreters;      FOR temp: IT.Handle ¬ Interpreters.next, temp.next UNTIL temp = NIL DO        IF temp = h THEN { prev.next ¬ h.next; EXIT } ELSE prev ¬ temp;        REPEAT FINISHED => ERROR;        ENDLOOP}};	  MakeSWs: Tool.MakeSWsProc = {    it: IT.Handle;    IF (it ¬ Context.Find[MyContextType, window]) = NIL THEN it ¬ SIGNAL GetITHandle[];    BEGIN ENABLE GetITHandle => RESUME[it];      it.formSW ¬ Tool.MakeFormSW[window: window, formProc: IL.MakeCommandForm, zone: IO.zone];      it.fileSW ¬ Tool.MakeTTYSW[window: window, name: it.logname, resetLengthOnNewSession: IO.options.resetLog.b ! TTYSW.Error => GOTO CantOpenLog];      BroadcastFileSW[@FileSWLock];      EXITS CantOpenLog => { HeraldWindow.AppendBrokenMessage["Cant open"L, it.logname, NIL]; ERROR CantOpenLog };      END;    IO.SetOutput[it, TTYSW.GetTTYHandle[it.fileSW]]};      DoStackSubwindow: PROC[h: IT.Handle] = {    IF h.flows.b THEN IL.MakeFlowSW[h];     IF h.configs.b THEN IL.MakeConfigSW[h] };      CreateTool: PROC[h: IT.Handle, namestripe: LONG STRING, initialState: Tool.State] = {    ENABLE GetITHandle => RESUME[h];    h.tool ¬ Tool.Create[name: namestripe, tinyName1: h.logname, tinyName2: NIL, named: TRUE,       makeSWsProc: MakeSWs, initialState: initialState, clientTransition: Transition, cmSection: "Debugger"L];    Context.Create[MyContextType, h, DestroyContext, h.tool]};    GetInterpreter: INTERNAL PROC[l: Lock, event: AMEvents.Event] RETURNS[free: IT.Handle] = {    free ¬ NIL;    FOR h: IT.Handle ¬ Interpreters, h.next UNTIL h = NIL DO      SELECT h.client FROM        outload, remote =>  	  IF (h.world = event.world) THEN { -- use it	    IF h.session # event.session THEN MakeAvailable[l, h]; -- booted	    RETURN[h] };        dormant => {	  IF (WorldVMOps.ProcessLong[h.swapData.process] = event.process) AND (h.world = event.world) THEN RETURN[h]	  ELSE free ¬ h };	ENDCASE;      ENDLOOP };        MakeAvailable: INTERNAL PROC[l: Lock, h: IT.Handle] = {    LOOPHOLE[h.spare, ITExtras.Spare].available ¬ FALSE;    TellFileSubwindow[h, abort];    UNTIL LOOPHOLE[h.spare, ITExtras.Spare].available DO WAIT Available; ENDLOOP };  TellFileSubwindow: PROC[h: IT.Handle, todo: {proceed, quit, kill, abort}] = {    LOOPHOLE[h.spare, ITExtras.Spare].state ¬ SELECT todo FROM      proceed => ITExtras.InterpreterState.proceed,      quit => ITExtras.InterpreterState.quit,      kill => ITExtras.InterpreterState.kill,      abort => ITExtras.InterpreterState.abort,      ENDCASE => ERROR;    [] ¬ UserInput.StuffCharacter[h.fileSW, Ascii.NUL]; };        PutWorldIntoNamestripe: PROC[namestripe: LONG STRING, world: WorldVM.World] = {    SELECT WorldVMOps.GetType[world] FROM      local => NULL;      outload => String.AppendString[namestripe, "Outload: "L];      remote => String.AppendString[namestripe, "Remote: "L];      ENDCASE;    String.AppendString[namestripe, WorldVM.WorldName[world]];    SELECT WorldVMOps.GetType[world] FROM      outload => {        volume: LONG STRING ¬ WorldVM.VolumeForOutload[world];	IF volume # NIL THEN {          String.AppendString[namestripe, ", volume: "L];          String.AppendString[namestripe, volume] }};      ENDCASE; };        PutLogIntoNamestripe: PROC[h: IT.Handle, namestripe: LONG STRING] = {    IF h.logname = NIL THEN {      temp: LONG STRING ¬ String.MakeString[IO.zone, MFile.maxNameLength];      UnusedLogName[temp, "Debug.log"L];      h.logname ¬ temp };    String.AppendString[namestripe, " ("L];    String.AppendString[namestripe, h.logname];    String.AppendChar[namestripe, ')]};    EnumerateHandles: PROC[proc: EnumerateProcType] = {    FOR h: IT.Handle ¬ Interpreters, h.next UNTIL h = NIL DO      IF proc[h] THEN EXIT;      ENDLOOP };      UnusedLogName: PROC[unused, root: LONG STRING] = {    -- different from Tool.UnusedLogName    same: BOOLEAN ¬ FALSE;    saveLen: CARDINAL;    number: INTEGER ¬ 0;    Used: EnumerateProcType = { RETURN[same ¬ String.EquivalentString[unused, h.logname]] };    unused.length ¬ 0;    String.AppendString[to: unused, from: root];    saveLen ¬ unused.length;    DO      EnumerateHandles[proc: Used];      IF ~same THEN {        ENABLE MFile.Error => CONTINUE;	MFile.Release[MFile.ReadWrite[unused, [], text]]; EXIT };      unused.length ¬ saveLen;      String.AppendDecimal[s: unused, n: number ¬ number + 1];      ENDLOOP};      Setup: ENTRY PROC[l: Lock, event: AMEvents.Event, data: LONG POINTER]     RETURNS[h: IT.Handle] = {    ENABLE UNWIND => NULL;    namestripe: LONG STRING ¬ [MFile.maxNameLength]; -- might need more    PutWorldIntoNamestripe[namestripe, event.world];    IF (h ¬ GetInterpreter[l, event]) = NIL THEN h ¬ AllocateInterpreter[];    IF (ttyGlobal = TTY.nullHandle) THEN {      priorityPrev: Process.Priority;      IF ~windows THEN RuntimeInternal.WorryCallDebugger["No TTYHandle for debugger"L];      PutLogIntoNamestripe[h, namestripe];      «We arrive in EventHandler with the same priority as the client.       Create tool at the priority which is least likely to cause a state vector lockup.»      priorityPrev ¬ Process.GetPriority[];      Process.SetPriority[Process.priorityForeground];      IF h.tool = NIL THEN CreateTool[h, namestripe, active]      ELSE {	ToolWindow.SetName[h.tool, namestripe]; 	ToolWindow.Activate[window: h.tool];	IF h.tool.GetParent.GetChild # h.tool THEN { -- not visible	  h.tool.Stack[h.tool.GetParent.GetChild];	  Window.rootWindow.ValidateTree }};      Process.SetPriority[priorityPrev];      IL.SetFormSWClient[h, WorldToClient[event.world]];      IF (h.world # event.world) OR (h.session # event.session) THEN {         String.AppendChar[namestripe, ' ];        Time.AppendCurrent[namestripe];        IO.EOL[h]; 	IO.NonAbortableText[namestripe, h]; 	IO.EOL[h] }}    ELSE {      IF h.tool # NIL THEN { Tool.Destroy[h.tool]; h.tool ¬ NIL };      IO.SetOutput[h, ttyGlobal];      h.client ¬ WorldToClient[event.world] }};        WorldToClient: PROC[world: WorldVM.World] RETURNS[IT.ClientFormItems] = {    RETURN[      SELECT WorldVMOps.GetType[world] FROM	local => local, outload => outload, remote => remote, 	ENDCASE => spare]};      DestroyHandle: PUBLIC «IK» PROC[h: IT.Handle] RETURNS[success: BOOLEAN] = {    IF h # NIL AND h.client = dormant THEN {      IF h.tool # NIL THEN { Tool.Destroy[h.tool]; h.tool ¬ h.fileSW ¬ NIL };      SwordUsefulDefs.InterpreterAvailable[h.world];      Delink[h];      Alloc.DropNotify[alloc, UpdateBases, h];      IF h.logname # NIL THEN String.FreeString[zone, h.logname];      zone.FREE[@h];      RETURN[TRUE]}    ELSE RETURN[FALSE]};        DestroyContext: Context.DestroyProcType = {};    Cleanup: ENTRY PROC[l: Lock, h: IT.Handle, event: AMEvents.Event, data: LONG POINTER] = {    ENABLE UNWIND => NULL;    IF h.tool # NIL THEN {      namestripe: LONG STRING ¬ [MFile.maxNameLength]; -- might need more      String.AppendString[namestripe, "Dormant"L];      PutLogIntoNamestripe[h, namestripe];      ToolWindow.SetName[h.tool, namestripe];      IL.SetFormSWClient[h, dormant] }    ELSE {      h.client ¬ dormant;      [] ¬ TTY.SetEcho[ttyGlobal, plain] };    LOOPHOLE[h.spare, ITExtras.Spare].available ¬ TRUE;    NOTIFY Available };      EventHandler: PUBLIC «IK» AMEvents.EventProc =  {    ENABLE CantOpenLog => CONTINUE;    h: IT.Handle ¬ Setup[@SetupCleanup, event, data];    BEGIN ENABLE UNWIND => Cleanup[@SetupCleanup, h, event, data];    newWorld: BOOLEAN ¬ h.world # event.world;     newSession: BOOLEAN ¬ h.session # event.session;    IF ~newWorld AND newSession THEN {       IQ.ClearAllBreaks[h];       WorldVMExtras.SetBreakNumber[h.world, 0] };    h.session ¬ event.session;     h.world ¬ event.world;    SwordUsefulDefs.InterpreterAvailable[h.world];    [] ¬ WorldVM.SetTTY[h.world, h.tty];    h.swapData ¬ WorldVMOps.GetESV[h.world].swapData;        IO.FlushCaches[h, IF newWorld OR newSession THEN EventTypes.newSession ELSE EventTypes.resumeSession];    IF newSession THEN h.level ¬ 0;    h.level ¬ h.level + 1;    outcome ¬ StringProc[h ! UNWIND => h.level ¬ h.level - 1];    h.level ¬ h.level - 1;    IF h.level = 0 THEN Cleanup[@SetupCleanup, h, event, data];    END };      StartTrap: PROC[] = { -- initialize global items    none: Alloc.TableInfo = [, 1, 4];    rare: Alloc.TableInfo = [, 2, 8];    some: Alloc.TableInfo = [, 8, 16];    alot: Alloc.TableInfo = [, 32, 64];    weights: ARRAY SymbolSegment.Tables OF Alloc.TableInfo ¬ [      «SymbolSegment.treeType:» rare,       «SymbolSegment.seType:» alot,       «SymbolSegment.htType:» some,       «SymbolSegment.ssType:» some,       «SymbolSegment.ctxType:» some,       «SymbolSegment.mdType:» some,       «SymbolSegment.bodyType:» some,       «SymbolSegment.ltType:» rare,       «SymbolSegment.stType:» rare,       «SymbolSegment.extType:» rare,      «SymbolSegment.atType:» none,      «SymbolSegment.constType:» none,      «SymbolSegment.codeType:» none];    alloc ¬ Alloc.Create[weights: DESCRIPTOR[weights]];    Alloc.Chunkify[alloc];    symboltable ¬ IQ.InitSym[alloc, zone];    WorldVMOps.SetSymbols[symboltable];    ID.ProcessUserCm[]; -- initializes options.    ID.Filter[IM.strings[filter]];    AMEvents.GetEvents[world: WorldVM.LocalWorld[], data: NIL, proc: EventHandler];    AMEvents.HandleLocalEvents[signals: IO.options.uncaught.b, breaks: IO.options.break.b, faults: IO.options.fault.b, calldebug: IO.options.calldebug.b]};      UpdateBases: Alloc.Notifier = {    h: IT.Handle = clientData;    h.tb ¬ base[SymbolSegment.treeType]; -- 0    h.seb ¬ base[SymbolSegment.seType]; -- 1    h.ht.BASE ¬ base[SymbolSegment.htType]; «h.ht ¬ base[Symbols.htType];»       h.ssb ¬ LOOPHOLE[base[SymbolSegment.ssType], LONG STRING]; «h.ssb ¬ base[Symbols.ssType];»       h.ctxb ¬ base[SymbolSegment.ctxType]; -- 4    h.mdb ¬ base[SymbolSegment.mdType]; -- 5    h.bb ¬ base[SymbolSegment.bodyType]; -- 6    h.ltb ¬ base[SymbolSegment.ltType]}; -- 7      ExecMatchPattern: PUBLIC «ITajo» PROC[string, pattern: LONG STRING] RETURNS[matched: BOOLEAN] = {    RETURN[Exec.MatchPattern[string, pattern]]};      TTYLocalDebug: PUBLIC «TTYSword» PROC[tty: TTY.Handle] = {    ttyGlobal ¬ tty };    UndoMenu: PROC[] = {    IF menu = NIL THEN RETURN;    Menu.Uninstantiate[window: Window.Root[], menu: menu];    Menu.Destroy[menu];    menu ¬ NIL };    DoMenu: PROC[] = {    array: ARRAY [0..4) OF LONG STRING ¬ ["Sword"L, "rep?"L, "showType"L, "type&bits"L];    menu ¬ Menu.Make[name: "Debugger"L, strings: DESCRIPTOR[array], mcrProc: MyMCR];    Menu.Instantiate[window: Window.Root[], menu: menu]};      MyMCR: Menu.MCRType = {    SELECT index FROM       0 => Process.Detach[FORK TopOfFork[NIL, NIL, TTY.nullHandle]];       1 => ShowRep[];      2 => ShowType[FALSE];      3 => ShowType[TRUE];      ENDCASE};    ShowRep: PROC[] = {    output: Format.StringProc = { HeraldWindow.AppendMessage[msg: s, newLine: FALSE, clearOld: FALSE] };    n: LONG CARDINAL ¬ Selection.LongNumber[radix: 10 ! String.InvalidNumber => GOTO Error];    HeraldWindow.AppendMessage[NIL, TRUE, FALSE];    IV.PutLongRepsWithProc[n, output, NIL];    EXITS Error => NULL };       ShowType: PROC[layout: BOOLEAN] = {    output: Format.StringProc = { HeraldWindow.AppendMessage[msg: s, newLine: FALSE, clearOld: FALSE] };    s: LONG STRING ¬ Selection.Convert[string];    IS.ShowTypeWithProc[s, layout, output, NIL] };    ParseLocalSwitches: PROC[l: LONG STRING] RETURNS[outload, remote, setDUD: BOOLEAN] = {    sw: BOOLEAN ¬ TRUE;    outload ¬ FALSE;    remote ¬ FALSE;    setDUD ¬ TRUE;    IF l = NIL THEN RETURN;    FOR i: CARDINAL IN [0..l.length) DO       SELECT l[i] FROM         '~, '- => sw ¬ FALSE;	'o, 'O => {outload ¬ sw; sw ¬ TRUE};	'r, 'R => {remote ¬ sw; sw ¬ TRUE};	's, 'S => {setDUD ¬ sw; sw ¬ TRUE};        ENDCASE;      ENDLOOP};    DoInterpreter: PUBLIC «IA» Exec.ExecProc = {    token, switches: LONG STRING;    [token, switches] ¬ Exec.GetToken[h];    SELECT TRUE FROM      (token # NIL AND String.Equivalent[token, "ttyon"L]) => {	IF execGlobal # NIL THEN Exec.ReleaseTTY[ttyGlobal]; -- start using tty	ttyGlobal ¬ Exec.GetTTY[execGlobal ¬ h];	[] ¬ Exec.FreeTokenString[token] };      (token # NIL AND String.Equivalent[token, "ttyoff"L]) => {	IF execGlobal # NIL THEN Exec.ReleaseTTY[ttyGlobal]; -- stop using tty	ttyGlobal ¬ TTY.nullHandle; execGlobal ¬ NIL;	[] ¬ Exec.FreeTokenString[token] };      (ttyGlobal # TTY.nullHandle) => {	TopOfFork[token, switches, ttyGlobal]}; -- make tty Interpreter      ~windows => {	ttyGlobal ¬ Exec.GetTTY[execGlobal ¬ h];	TopOfFork[token, switches, ttyGlobal]}; -- make tty Interpreter      ENDCASE => {        -- workaround for bug ExecsA$ProcessCommandLine creates no tty        tty: TTY.Handle = IF LOOPHOLE[h, LONG POINTER TO ExecInternal.Object].w = TTY.nullHandle THEN TTY.nullHandle ELSE Exec.GetTTY[h];        Process.Detach[FORK TopOfFork[token, switches, tty]] }}; -- make tool interpreter	  PutLine: PROC[tty: TTY.Handle, s: LONG STRING] = {    IF tty = TTY.nullHandle THEN HeraldWindow.AppendMessage[s, TRUE, FALSE]    ELSE TTY.PutLine[tty, s] };  TopOfFork: PUBLIC PROC[client, switches: LONG STRING, tty: TTY.Handle] = {    ENABLE {      WorldVM.BadWorld => {PutLine[tty, "Bad world!"L]; GOTO Cleanup; };      ABORTED => {PutLine[tty, "aborted"L ! ABORTED => CONTINUE]; GOTO Cleanup; }};    outload, remote, setDUD: BOOLEAN;    [outload, remote, setDUD] ¬ ParseLocalSwitches[switches];    SELECT TRUE FROM      outload => { 	world: WorldVM.World ¬ WorldVM.OutloadWorld[client, switches, tty];	IF setDUD THEN SwordUsefulDefs.SetDefaultWorld[world];	AMEvents.GetEvents[world: world, data: NIL, proc: EventHandler] };      remote => { 	world: WorldVM.World ¬ WorldVM.RemoteWorld[client, switches, tty];	IF setDUD THEN SwordUsefulDefs.SetDefaultWorld[world];	AMEvents.GetEvents[world: world, data: NIL, proc: EventHandler] };      ENDCASE => {        --IF setDUD THEN SwordUsefulDefs.SetDefaultWorld[WorldVM.LocalWorld[]];        AMEvents.CallDebugger["Sword"L] };    GOTO Cleanup;    EXITS Cleanup => {      IF client # NIL THEN [] ¬ Exec.FreeTokenString[client];      IF switches # NIL THEN [] ¬ Exec.FreeTokenString[switches]}};       UnloadInterpreter: PUBLIC «IA» Exec.ExecProc = {    next: IT.Handle;    output: Format.StringProc = Exec.OutputProc[h];    AMEvents.StopEvents[WorldVM.LocalWorld[]];    FOR h: IT.Handle ¬ Interpreters, next UNTIL h = NIL DO      next ¬ h.next;      IQ.Invalidate[h];      WorldVM.InvalidateWorld[h.world];      IF ~DestroyHandle[h] THEN { output["Sword not dormant!\n"L]; RETURN[abort] };      ENDLOOP;    WorldVM.UnloadWVMOutLd[];    WorldVM.UnloadWVMTeledebug[];    WVMBooting.UnloadWVMBooting[];    Watch.StopTrace[];    IF AMHeap.zone # NIL THEN { Heap.Delete[AMHeap.zone]; AMHeap.zone ¬ NIL };    IF symboltable # NIL THEN { IE.StopSym[symboltable]; symboltable ¬ NIL };    IF alloc # NIL THEN { Alloc.Destroy[alloc]; alloc ¬ NIL };    IF zone # NIL THEN { Heap.Delete[zone]; zone ¬ NIL };    IF IO.options.menu.b AND windows THEN UndoMenu[];    IA.UnloadITWiskOperations[];    IA.UnloadDebugUsefulDefs[];    Exec.RemoveCommand[h, "Sword.~"L] };      HelpInterpreter: PUBLIC «IA» Exec.ExecProc = {    out: Format.StringProc = Exec.OutputProc[h];    out["\nSword.~ <outload file/o> <remote host/r>"L];    out["\n  Additional switches:"L];    out["\n    s - set DebugUsefulDefs client (setDUD)"L] };  StartTrap[];  Exec.AddCommand[name: "Sword.~"L, proc: DoInterpreter, unload: UnloadInterpreter, help: HelpInterpreter];  IF IO.options.menu.b AND windows THEN DoMenu[];    }.
-- File: WVMOutLd.mesa - last edit:-- Litman               1-May-87 16:30:24-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.DIRECTORY  AMHeap USING [zone],  Boot USING [Location, LVBootFiles],  BootFile USING [MemorySizeToFileSize],  CmFile USING [Close, Error, FindItem, Handle, ReadLineOrToken, UserDotCmOpen],  Cursor USING [Set, Type],  Device USING [nullType, Type],  Environment USING [bytesPerPage],  Event USING [powerOff, swapping],  EventTypes USING [bootPhysicalVolume, newSession, powerOff, tellFileSystemSwappingIn, tellFileSystemSwappingOut],  File USING [File, ID, nullFile, nullID, PageNumber],  HeraldWindow USING [AppendBrokenMessage],  MFile USING [Acquire, ByteCount, EnumerateDirectory, EnumerateProc, Error, GetFullName, Handle, maxNameLength, PleaseReleaseProc, ReadWrite, Release, SetAccess, SetLength, Type],  OthelloOpsExtras USING [GetVolumeBootFile, MapStartListHeader, NoStartListHeader, SetGetSwitchesSuccess, StartListHeadPtr],  Runtime USING [NarrowFault],  Snapshot USING [OutLoad],  Space USING [Unmap],  SpecialFile USING [SetDebuggerFiles],  SpecialMFile USING [GetCapaWithAccess, LeaderPages],  SpecialSpace USING [realMemorySize],  SpecialVolume USING [GetLogicalVolumeBootFiles],  String USING [AppendExtensionIfNeeded, AppendString, CopyToNewString, Empty, FreeString, MakeString, Replace],  Supervisor USING [AddDependency, AgentProcedure, CreateSubsystem, DeleteSubsystem, Event, NotifyDirectSubsystems, nullSubsystem, RemoveDependency, SubsystemHandle],  System USING [defaultSwitches, Switches],  TajoOps USING [OutloadProcType, SetOutloadProc, SetPlace],  TemporaryBooting USING [BootLocation, GetFileLocation, GetVolumeLocation, InvalidParameters, MakeBootable, VolumeLocation],  TTY USING [Handle],  UserInput USING [ReturnToNotifier],  Volume USING [Close, GetLabelString, GetNext, GetType, ID, maxNameLength, nullID, Open, systemID, Type, TypeSet, Unknown],  WorldVM USING [BadWorld, World, WorldObject],  WorldVMExtras USING [EnumerateWorlds, WorldProc],  WVMBooting USING [OutLoadInLoad],  WVMCacheOps USING [],  WVMPrivate USING [OutloadWorld, StopOutload, WorldObject];WVMOutLd: PROGRAM   IMPORTS AMHeap, BootFile, CmFile, Cursor, Event, HeraldWindow, MFile, OthelloOpsExtras, Runtime, Snapshot, Space, SpecialFile, SpecialMFile, SpecialSpace, SpecialVolume, String, Supervisor, TajoOps, TemporaryBooting, UserInput, Volume, WorldVM, WorldVMExtras, WVMBooting, WVMPrivate  EXPORTS WorldVM, WVMPrivate, WVMCacheOps  SHARES Device = {    zone: UNCOUNTED ZONE = AMHeap.zone;    numberOfVolumes: CARDINAL ¬ 0;  volumes: ARRAY [0..MaxVolumes) OF VolumeRec;  MaxVolumes: CARDINAL = 10;  VolumeRec: TYPE = RECORD[    volumeLocation: TemporaryBooting.VolumeLocation,    volName: LONG STRING,     id: Volume.ID,     outloadName: LONG STRING,     outloadFile: File.File];      -- debuggeeName: LONG STRING ¬ NIL;  debuggerFile: File.File ¬ File.nullFile;  mfiles: LONG POINTER TO MFilesObject ¬ NIL;  MFilesObject: TYPE = RECORD [    size: CARDINAL ¬ 0,     seq: SEQUENCE max: CARDINAL OF RECORD[mfile: MFile.Handle, pfile: File.ID]];     World: TYPE = LONG POINTER TO WorldObject;  WorldObject: PUBLIC TYPE = WVMPrivate.WorldObject;  OutloadWorld: TYPE = WVMPrivate.OutloadWorld;  mfileLeader: CARDINAL = SpecialMFile.LeaderPages[];  outloadLength: MFile.ByteCount = Environment.bytesPerPage * BootFile.MemorySizeToFileSize[countReal: SpecialSpace.realMemorySize];    ParseSwitches: PROC[l: LONG STRING] RETURNS[ignoreMaplog: BOOLEAN] = {    sw: BOOLEAN ¬ TRUE;    ignoreMaplog ¬ FALSE;    IF l = NIL THEN RETURN;    FOR i: CARDINAL IN [0..l.length) DO       SELECT l[i] FROM         '~, '- => sw ¬ FALSE;	'm, 'M => {ignoreMaplog ¬ sw; sw ¬ TRUE};        ENDCASE;      ENDLOOP};      -- file must exist already    LocateOutload: PUBLIC PROC[where, switches: LONG STRING, tty: TTY.Handle]     RETURNS[file: File.File, leaderPages: CARDINAL, riggle, ignoreMaplog: BOOLEAN] = {    mfile: MFile.Handle;    copy: LONG STRING;    IF RiggleString[where] THEN RETURN[File.nullFile, 0, TRUE, FALSE];    copy ¬ String.CopyToNewString[where, zone, 7];    [] ¬ String.AppendExtensionIfNeeded[@copy, "outload"L, zone];    -- make sure file exists, be careful not to create file    mfile ¬ MFile.Acquire[name: copy, access: anchor, release: [PleaseRelease, NIL], type: binary ! MFile.Error => { String.FreeString[zone, copy]; ERROR WorldVM.BadWorld }];    file ¬ SpecialMFile.GetCapaWithAccess[mfile];    [] ¬ UpdateMFile[file.fileID, mfile];    leaderPages ¬ mfileLeader;    riggle ¬ FALSE;    ignoreMaplog ¬ ParseSwitches[switches];    String.FreeString[zone, copy] };      -- file will be created if it doesn't exist  CreateOutload: PROC[where: LONG STRING] RETURNS[file: File.File, leaderPages: CARDINAL, riggle: BOOLEAN] = {    mfile: MFile.Handle;    exists: BOOLEAN ¬ TRUE;    IF RiggleString[where] THEN RETURN[File.nullFile, 0, TRUE];        «    mfile ¬ MFile.Acquire[name: where, access: anchor, release: [], type: binary ! MFile.Error => {exists ¬ FALSE; CONTINUE}];    IF exists THEN MFile.SetAccess[mfile, readWrite ! MFile.Error => ERROR WorldVM.BadWorld]    ELSE mfile ¬ MFile.ReadWrite[name: where, release: [], type: binary, initialLength: outloadLength ! MFile.Error => ERROR WorldVM.BadWorld];    MFile.SetLength[mfile, outloadLength]; -- file size must be set before making bootable    MFile.Release[mfile]; -- let mfile do any notifications    mfile ¬ MFile.Acquire[name: where, access: anchor, release: [PleaseRelease, NIL], type: binary];    »    mfile ¬ MFile.Acquire[name: where, access: anchor, release: [PleaseRelease, NIL], type: binary ! MFile.Error => {exists ¬ FALSE; CONTINUE}];    IF exists THEN MFile.SetAccess[mfile, readWrite ! MFile.Error => ERROR WorldVM.BadWorld]    ELSE mfile ¬ MFile.ReadWrite[name: where, release: [PleaseRelease, NIL], type: binary, initialLength: outloadLength ! MFile.Error => ERROR WorldVM.BadWorld];    MFile.SetLength[mfile, outloadLength];    MFile.SetAccess[mfile, anchor];        file ¬ SpecialMFile.GetCapaWithAccess[mfile];    IF ~exists THEN TemporaryBooting.MakeBootable[file: file, firstPage: mfileLeader ! TemporaryBooting.InvalidParameters => CONTINUE];    [] ¬ UpdateMFile[file.fileID, mfile];    leaderPages ¬ mfileLeader;    riggle ¬ FALSE };      RiggleString: PROC[string: LONG STRING] RETURNS[BOOLEAN] = INLINE {    RETURN[String.Empty[string]]};    GoOutload: PUBLIC PROC[world: OutloadWorld] = {    debuggerLoc: file TemporaryBooting.BootLocation;    debuggeeFile: File.File = world.file;    debuggeeLoc: TemporaryBooting.BootLocation;    IF world.riggle THEN {GoOutloadRiggle[world]; RETURN};    debuggeeLoc ¬ TemporaryBooting.GetFileLocation[debuggeeFile, mfileLeader];    IF debuggerFile = File.nullFile THEN [debuggerFile,,] ¬ CreateOutload[where: "<>Debugger.outload"L];    SpecialFile.SetDebuggerFiles[      debugger: debuggerFile, debuggerFirstPage: mfileLeader,      debuggee: debuggeeFile, debuggeeFirstPage: mfileLeader];    debuggerLoc ¬ TemporaryBooting.GetFileLocation[debuggerFile, mfileLeader];    OutloadInload[debuggerLoc, debuggeeLoc] };      -- defs from DoveInputOutputExtra  memoryDevice: Device.Type = [LAST[CARDINAL]];  debuggerLocation: CARDINAL = 0;  debuggeeLocation: CARDINAL = 1;      GoOutloadRiggle: PROC[world: OutloadWorld] = {    debuggerLoc: Boot.Location;    debuggeeLoc: Boot.Location;    debuggerLoc ¬ [      memoryDevice,      0,      any[        a: debuggerLocation,        b: TRASH,        c: TRASH,        d: TRASH,        e: TRASH,        f: TRASH,        g: TRASH,        h: TRASH]];    debuggeeLoc ¬ [      memoryDevice,      0,      any[        a: debuggeeLocation,        b: TRASH,        c: TRASH,        d: TRASH,        e: TRASH,        f: TRASH,        g: TRASH,        h: TRASH]];    OutloadInload[out: [file[LOOPHOLE[debuggerLoc]]], in: [file[LOOPHOLE[debuggeeLoc]]]] };      «SetOutloadForVolume: PUBLIC PROC[volume: LONG STRING, outloadName: LONG STRING] RETURNS[found: BOOLEAN] = {    FOR i: CARDINAL IN [0..numberOfVolumes) DO      IF String.Equivalent[volume, volumes[i].volName] THEN {        String.Replace[@volumes[i].outloadName, outloadName, zone];	volumes[i].outloadFile ¬ File.nullFile;	RETURN[TRUE]; };      REPEAT FINISHED => RETURN[FALSE];      ENDLOOP; };»         VolumeForOutload: PUBLIC PROC[world: World] RETURNS[volume: LONG STRING] = {    w: OutloadWorld = NARROW[world, OutloadWorld ! Runtime.NarrowFault => GOTO nil];    match: CARDINAL;    IF w.file = File.nullFile THEN RETURN[NIL];    FOR i: CARDINAL IN [0..numberOfVolumes) DO      IF w.file = volumes[i].outloadFile THEN { match ¬ i; EXIT };      REPEAT FINISHED => RETURN[NIL];      ENDLOOP;     IF w.esv.systemVolumeID = Volume.nullID THEN RETURN[volumes[match].volName]    ELSE { -- find matching volume id      FOR i: CARDINAL IN [0..numberOfVolumes) DO	IF w.esv.systemVolumeID = volumes[i].id THEN {	  -- any future herald boot will use this outloadFile	  volumes[i].outloadFile ¬ volumes[match].outloadFile;	  String.Replace[@volumes[i].outloadName, volumes[match].outloadName, zone];	  RETURN[volumes[i].volName] };	REPEAT FINISHED => RETURN[NIL];	ENDLOOP };    EXITS nil => RETURN[NIL] };        VolumeForBootLocation: PROC[boot: TemporaryBooting.BootLocation] RETURNS[vol: LONG POINTER TO VolumeRec] = {    WITH boot SELECT FROM      logicalVolume => 	FOR i: CARDINAL IN [0..numberOfVolumes) DO	  IF volumeLocation = volumes[i].volumeLocation THEN RETURN[@volumes[i]];	  REPEAT FINISHED => { -- someone installed a new boot file	    nVols: CARDINAL ¬ 0;	    FOR vol: Volume.ID ¬ Volume.GetNext[Volume.nullID, all], Volume.GetNext[vol, all] UNTIL vol = Volume.nullID DO 	      newBootLocation: TemporaryBooting.BootLocation.logicalVolume = 	        TemporaryBooting.GetVolumeLocation[vol ! TemporaryBooting.InvalidParameters => LOOP];              IF boot = newBootLocation THEN { volumes[nVols].volumeLocation ¬ newBootLocation.volumeLocation; RETURN[@volumes[nVols]] };	      nVols ¬ nVols + 1;	      REPEAT FINISHED => ERROR;              ENDLOOP };	  ENDLOOP;       ENDCASE => RETURN[NIL] };        TajoOutload: TajoOps.OutloadProcType = {    ENABLE WorldVM.BadWorld => UserInput.ReturnToNotifier[" Cant create outload file!"L];    debuggerLoc: file TemporaryBooting.BootLocation;    riggle: BOOLEAN;    vol: LONG POINTER TO VolumeRec;    IF (vol ¬ VolumeForBootLocation[boot]) # NIL THEN {      [vol.outloadFile,,riggle] ¬ CreateOutload[where: vol.outloadName];      IF riggle THEN { TajoOutloadRiggle[boot, switches]; RETURN }};    IF debuggerFile = File.nullFile THEN [debuggerFile,,] ¬ CreateOutload[where: "<>Debugger.outload"L];    IF vol # NIL THEN      SpecialFile.SetDebuggerFiles[	debugger: debuggerFile, debuggerFirstPage: mfileLeader,	debuggee: vol.outloadFile, debuggeeFirstPage: mfileLeader];    debuggerLoc ¬ TemporaryBooting.GetFileLocation[file: debuggerFile, firstPage: mfileLeader];    IF boot = [none[]] THEN { -- from HardBoot      inLoaded: BOOLEAN = Snapshot.OutLoad[debuggerFile, mfileLeader];      IF inLoaded THEN {         Supervisor.NotifyDirectSubsystems[event: EventTypes.newSession, which: clients, subsystem: Event.swapping];        Cursor.Set[textPointer]; 	ERROR UserInput.ReturnToNotifier[NIL] }}    ELSE {      OutloadInload[out: debuggerLoc, in: boot, switches: switches];      Supervisor.NotifyDirectSubsystems[event: EventTypes.newSession, which: clients, subsystem: Event.swapping];      ERROR UserInput.ReturnToNotifier[NIL]; }};      TajoOutloadRiggle: TajoOps.OutloadProcType = {    ENABLE WorldVM.BadWorld => CONTINUE;    debuggerLoc: Boot.Location;    debuggerLoc ¬ [      memoryDevice,      0,      any[        a: debuggerLocation,        b: TRASH,        c: TRASH,        d: TRASH,        e: TRASH,        f: TRASH,        g: TRASH,        h: TRASH]];    OutloadInload[out: [file[LOOPHOLE[debuggerLoc]]], in: boot, switches: switches];    Supervisor.NotifyDirectSubsystems[event: EventTypes.newSession, which: clients, subsystem: Event.swapping];    ERROR UserInput.ReturnToNotifier[NIL]; };      OutloadInload: PROC[out, in: TemporaryBooting.BootLocation, switches: System.Switches ¬ System.defaultSwitches] = {    Cursor.Set[hourGlass];    Supervisor.NotifyDirectSubsystems[event: EventTypes.tellFileSystemSwappingOut, which: clients, subsystem: Event.swapping];    --Supervisor.NotifyDirectSubsystems[event: EventTypes.resumeDebuggee, which: clients, subsystem: Event.swapping];    WVMBooting.OutLoadInLoad[out, in, switches];    --Supervisor.NotifyDirectSubsystems[event: EventTypes.resumeSession, which: clients, subsystem: Event.swapping];    Supervisor.NotifyDirectSubsystems[event: EventTypes.tellFileSystemSwappingIn, which: clients, subsystem: Event.swapping] };      WorldForOutload: PROC[outloadFile: File.File] RETURNS[OutloadWorld] = {    OneWorld: WorldVMExtras.WorldProc = {       RETURN[WITH world: LOOPHOLE[w, World] SELECT FROM outload => (world.file = outloadFile), ENDCASE => FALSE] };    RETURN[LOOPHOLE[WorldVMExtras.EnumerateWorlds[OneWorld], OutloadWorld]] };        CurrentOutloadWorld: PUBLIC PROC[world: World] RETURNS[BOOLEAN] = {    w: OutloadWorld = NARROW[world, OutloadWorld ! Runtime.NarrowFault => GOTO false];    bootFiles: Boot.LVBootFiles;    debuggee: File.File;    IF w.riggle THEN RETURN[TRUE];    SpecialVolume.GetLogicalVolumeBootFiles[Volume.systemID, @bootFiles];    debuggee ¬ File.File[fileID: bootFiles[debuggee].fID.fileID, volumeID: Volume.systemID];    RETURN[(debuggee = w.file)];    EXITS false => RETURN[FALSE] };        all: Volume.TypeSet = [normal: TRUE, debugger: TRUE, debuggerDebugger: TRUE, nonPilot: TRUE];        MakeVolumes: PROC[] = {    userCm: CmFile.Handle;    userCm ¬ CmFile.UserDotCmOpen[! CmFile.Error => { userCm ¬ NIL; CONTINUE }];    FOR vol: Volume.ID ¬ Volume.GetNext[Volume.nullID, all], Volume.GetNext[vol, all] UNTIL vol = Volume.nullID DO       volumeRec: LONG POINTER TO VolumeRec = @volumes[numberOfVolumes];      localTemp: TemporaryBooting.VolumeLocation;      found: BOOLEAN ¬ FALSE;      localTemp ¬ TemporaryBooting.GetVolumeLocation[vol ! TemporaryBooting.InvalidParameters => CONTINUE].volumeLocation;      volumeRec.volumeLocation ¬ localTemp;      volumeRec.id ¬ vol;      volumeRec.outloadFile ¬ File.nullFile;      Volume.GetLabelString[vol, volumeRec.volName ¬ String.MakeString[zone, Volume.maxNameLength]];      volumeRec.outloadName ¬ String.MakeString[zone, MFile.maxNameLength];      IF userCm # NIL THEN {        SELECT TRUE FROM 	  CmFile.FindItem[userCm, "Debugger"L, volumeRec.volName] => {	    CmFile.ReadLineOrToken[userCm, volumeRec.outloadName, '\n];	    [] ¬ String.AppendExtensionIfNeeded[@volumeRec.outloadName, "outload"L, zone];	    found ¬ TRUE };	  CmFile.FindItem[userCm, "Debugger"L, "defaultOutload"L] => {	    CmFile.ReadLineOrToken[userCm, volumeRec.outloadName, '\n];	    [] ¬ String.AppendExtensionIfNeeded[@volumeRec.outloadName, "outload"L, zone];	    found ¬ TRUE };	  ENDCASE };      IF ~found THEN String.AppendString[volumeRec.outloadName, "<>Debuggee.outload"L];      IF numberOfVolumes = MaxVolumes THEN EXIT;      numberOfVolumes ¬ numberOfVolumes + 1;      ENDLOOP;     IF userCm # NIL THEN userCm ¬ CmFile.Close[userCm] };      DeleteVolumes: PROC[] = {    FOR nVols: CARDINAL IN [0..numberOfVolumes) DO      IF volumes[nVols].volName # NIL THEN { String.FreeString[zone, volumes[nVols].volName]; volumes[nVols].volName ¬ NIL };      IF volumes[nVols].outloadName # NIL THEN { String.FreeString[zone, volumes[nVols].outloadName]; volumes[nVols].outloadName ¬ NIL };      ENDLOOP };      UnloadWVMOutLd: PUBLIC --WorldVMExtras3-- PROC[] = {    TajoOps.SetOutloadProc[NIL];    IF hardbootAgent # Supervisor.nullSubsystem THEN {      Supervisor.RemoveDependency[client: hardbootAgent, implementor: Event.swapping];      Supervisor.RemoveDependency[client: hardbootAgent, implementor: Event.powerOff];      Supervisor.DeleteSubsystem[hardbootAgent];      hardbootAgent ¬ Supervisor.nullSubsystem };    DeleteVolumes[];    ReleaseMFiles[]; };      PleaseRelease: MFile.PleaseReleaseProc = {     outloadFile: File.File = SpecialMFile.GetCapaWithAccess[file];    FOR nVols: CARDINAL IN [0..numberOfVolumes) DO      IF volumes[nVols].id # Volume.systemID THEN {	bootFile: File.File;	firstPage: File.PageNumber;	outcome: OthelloOpsExtras.SetGetSwitchesSuccess;	pStartListHeader: OthelloOpsExtras.StartListHeadPtr;	[bootFile, firstPage] ¬ OthelloOpsExtras.GetVolumeBootFile[volumes[nVols].id, pilot ! Volume.Unknown => LOOP];	IF bootFile = File.nullFile THEN LOOP;	Volume.Open[volumes[nVols].id];	[outcome, pStartListHeader] ¬ OthelloOpsExtras.MapStartListHeader[bootFile, firstPage, readOnly ! OthelloOpsExtras.NoStartListHeader => GOTO NextVolume];	IF outcome # success THEN GOTO NextVolume;	IF LOOPHOLE[pStartListHeader.locDebuggee, Boot.Location].deviceType # Device.nullType	THEN { -- debugger pointers have been set	  IF LOOPHOLE[pStartListHeader.locDebuggee, Boot.Location].diskFileID.fID.fileID = outloadFile.fileID THEN { 	    outloadName: LONG STRING ¬ [MFile.maxNameLength];	    MFile.GetFullName[file, outloadName];	    HeraldWindow.AppendBrokenMessage["Cant acquire "L, outloadName, NIL, TRUE, FALSE];	    HeraldWindow.AppendBrokenMessage[" while debugger pointers are set from volume "L, volumes[nVols].volName, NIL, FALSE, FALSE];	    [] ¬ Space.Unmap[pStartListHeader]; 	    Volume.Close[volumes[nVols].id];	    RETURN[no] }};	[] ¬ Space.Unmap[pStartListHeader];	Volume.Close[volumes[nVols].id];	EXITS NextVolume => Volume.Close[volumes[nVols].id] };      REPEAT FINISHED => {         world: OutloadWorld = WorldForOutload[outloadFile];	IF world # NIL THEN WVMPrivate.StopOutload[world]; 	IF outloadFile = debuggerFile THEN debuggerFile ¬ File.nullFile;	RemoveMFile[file];        RETURN[goAhead] };      ENDLOOP };        CloseOutload: PUBLIC PROC[world: OutloadWorld] = { };        GrowMFiles: PROC[] = {    SELECT TRUE FROM      mfiles = NIL => mfiles ¬ zone.NEW[MFilesObject[3]];      mfiles.size = mfiles.max => {	new: LONG POINTER TO MFilesObject ¬ zone.NEW[MFilesObject[mfiles.max+3]];	FOR i: CARDINAL IN [0..mfiles.size) DO new[i] ¬ mfiles[i] ENDLOOP;	new.size ¬ mfiles.size;	zone.FREE[@mfiles]; mfiles ¬ new };      ENDCASE };        UpdateMFile: PROC[pfile: File.ID, mfile: MFile.Handle] RETURNS[added: BOOLEAN] = {    GrowMFiles[];    FOR i: CARDINAL IN [0..mfiles.size) DO       IF mfiles[i].pfile = pfile THEN {        IF mfiles[i].mfile # mfile THEN { MFile.Release[mfiles[i].mfile]; mfiles[i].mfile ¬ mfile };        RETURN[FALSE] };       REPEAT FINISHED => {        mfiles[mfiles.size] ¬ [mfile, pfile];	mfiles.size ¬ mfiles.size.SUCC;	RETURN[TRUE] };      ENDLOOP };        ReleaseMFiles: PROC[] = {    IF mfiles = NIL THEN RETURN;    FOR i: CARDINAL IN [0..mfiles.size) DO       IF mfiles[i].mfile # NIL THEN MFile.Release[mfiles[i].mfile]; ENDLOOP;    zone.FREE[@mfiles] };    RemoveMFile: PROC[mfile: MFile.Handle] = {    FOR i: CARDINAL IN [0..mfiles.size) DO      IF mfiles[i].mfile = mfile THEN mfiles[i] ¬ [NIL, File.nullID];       ENDLOOP };      ProtectOutloadFiles: PROC[] = {    Protect: MFile.EnumerateProc = {      mfile: MFile.Handle = fileProc[access: anchor, release: [PleaseRelease, NIL]];      [] ¬ UpdateMFile[SpecialMFile.GetCapaWithAccess[mfile].fileID, mfile];      RETURN[done: FALSE] };    -- only looks on searchpath    MFile.EnumerateDirectory[name: "*.outload"L, proc: Protect, which: filesOnly] };      HardBoot: Supervisor.AgentProcedure = {    SELECT event FROM      EventTypes.bootPhysicalVolume,      EventTypes.powerOff => TajoOutload[[none[]], System.defaultSwitches];      ENDCASE};    hardbootAgent: Supervisor.SubsystemHandle ¬ Supervisor.CreateSubsystem[HardBoot];  volumeType: Volume.Type = Volume.GetType[Volume.systemID];  IF volumeType = debugger OR volumeType = debuggerDebugger THEN TajoOps.SetPlace[copilot]; -- This ensures that the OutloadProc will be called.  TajoOps.SetOutloadProc[TajoOutload];  Supervisor.AddDependency[client: hardbootAgent, implementor: Event.swapping];  Supervisor.AddDependency[client: hardbootAgent, implementor: Event.powerOff];  MakeVolumes[];  ProtectOutloadFiles[];    }..
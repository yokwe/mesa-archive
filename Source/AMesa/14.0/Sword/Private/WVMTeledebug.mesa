-- Copyright (C) 1986  by Xerox Corporation. All rights reserved. -- WVMTeledebug.mesaDIRECTORY  AddressTranslation USING [Error, NetworkAddress, PrintError, StringToNetworkAddress],  AMHeap USING [zone],  Boot USING [pageGerm],  Environment USING [bytesPerWord, LongPointerFromPage],  Format USING [NetworkAddress, StringProc],  HeraldWindow USING [FreeCursorSlot, GetCursorSlot, SetCursor, SetCursorState],  Inline USING [LongCOPY],  NSConstants USING [teleDebugSocket],  NSTypes USING [ExchangeClientType, maxDataBytesPerExchange],  PacketExchange USING [CreateRequestor, Delete, Error, ExchangeClientType, nullExchangeHandle, SendRequest, Timeout],  Process USING [Pause, SecondsToTicks],  Router USING [GetDelayToNet, NoTableEntryForNet],  Space USING [Activate],  String USING [Empty],  System USING [NetworkAddress, nullNetworkAddress],  TeledebugProtocol USING [CoreFetchAckHandle, CoreFetchReqHandle, CoreStoreAckHandle, CoreStoreReqHandle, DiskFetchAckHandle, DiskFetchReqHandle, DiskStoreAckHandle, DiskStoreReqHandle, Handle, PageData, RequestType, TeledebugBuffer],  TTY USING [Handle, PutChar, PutDecimal, PutLine, PutText, ResetUserAbort, UserAbort],  WorldVM USING [BadWorld, World, WorldObject],  WorldVMOps USING [AddressFault, Process, Read],  WVMCacheOps USING [],  WVMCacheRep USING [Segment],  WVMPrivate USING [RemoteWorld, WorldObject];WVMTeledebug: MONITOR  IMPORTS AddressTranslation, AMHeap, Environment, Format, HeraldWindow, Inline, PacketExchange, Process, Router, Space, String, TTY, WorldVM, WorldVMOps  EXPORTS WorldVM, WVMCacheOps, WVMPrivate = {    zone: UNCOUNTED ZONE = AMHeap.zone;  BYTE: TYPE = [0..255];  ByteSeq: TYPE = RECORD [PACKED SEQUENCE COMPUTED CARDINAL OF BYTE];  Segment: TYPE = WVMCacheRep.Segment;  World: TYPE = LONG POINTER TO WorldObject;  WorldObject: PUBLIC TYPE = WVMPrivate.WorldObject;  RemoteWorld: TYPE = WVMPrivate.RemoteWorld;    -- Checks (not in interface to elimate dependency on NSTypes). This prevents us from overflowing the buffer.  MaxSize: TYPE = CARDINAL [0..NSTypes.maxDataBytesPerExchange];  Buf: TYPE = TeledebugProtocol.TeledebugBuffer;  nullReqSize: MaxSize = SIZE[null Buf] * Environment.bytesPerWord;  coreStoreReqSize: MaxSize = SIZE[coreStoreReq Buf] * Environment.bytesPerWord;  coreFetchReqSize: MaxSize = SIZE[coreFetchReq Buf] * Environment.bytesPerWord;  diskFetchReqSize: MaxSize = SIZE[diskFetchReq Buf] * Environment.bytesPerWord;  diskStoreReqSize: MaxSize = SIZE[diskStoreReq Buf] * Environment.bytesPerWord;  coreStoreAckSize: MaxSize = SIZE[coreStoreAck Buf] * Environment.bytesPerWord;  diskStoreAckSize: MaxSize = SIZE[diskStoreAck Buf] * Environment.bytesPerWord;  coreFetchAckSize: MaxSize = SIZE[coreFetchAck Buf] * Environment.bytesPerWord;  diskFetchAckSize: MaxSize = SIZE[diskFetchAck Buf] * Environment.bytesPerWord;    SetTTY: PUBLIC PROC[world: World, tty: TTY.Handle] RETURNS[old: TTY.Handle] = {     old ¬ world.tty; world.tty ¬ tty };    FlushRemoteBootFile: PUBLIC PROCEDURE[world: World] = { };    UnloadWVMTeledebug: PUBLIC PROC[] = { };    CloseConnection: PUBLIC PROC[world: RemoteWorld] = {    IF world # NIL THEN FreeStorage[world] };      LocateRemote: PUBLIC PROC [where, switches: LONG STRING, tty: TTY.Handle]     RETURNS[host: System.NetworkAddress, waitTime: LONG CARDINAL, rs232: BOOLEAN] = {    out: Format.StringProc = { TTY.PutText[tty, s] };    success: BOOLEAN ¬ TRUE;    hops: CARDINAL ¬ 2;    IF String.Empty[where] THEN RETURN[System.nullNetworkAddress, 0, TRUE];    [host, ] ¬ AddressTranslation.StringToNetworkAddress[where      ! AddressTranslation.Error => {	  AddressTranslation.PrintError[errorRecord, out];	  ERROR WorldVM.BadWorld }];    TTY.PutText[tty, "\nHost "L];    host.socket ¬ NSConstants.teleDebugSocket;    TTY.PutText[tty, where]; TTY.PutText[tty, " = "L];    Format.NetworkAddress[proc: out, networkAddress: host, format: octal];    TTY.PutText[tty, " is "L];    hops ¬ Router.GetDelayToNet[host.net       ! Router.NoTableEntryForNet => {success ¬ FALSE; CONTINUE}];    IF success THEN {      TTY.PutDecimal[tty, hops];      TTY.PutText[tty, " hop"L];       IF hops # 1 THEN TTY.PutChar[tty, 's];       TTY.PutLine[tty, " away."L]}    ELSE TTY.PutLine[tty, " probably unreachable."L];    waitTime ¬ TimeForHops[hops];    rs232 ¬ FALSE };      TimeForHops: PROCEDURE [hops: CARDINAL] RETURNS [LONG CARDINAL] = {    RETURN[IF hops = 1 THEN 1500 ELSE 1500 + 2000*hops]};      SetupRemoteBootFile: PUBLIC PROC[world: RemoteWorld] = {    ENABLE ABORTED => { --TTY.PutLine[world.tty, "aborted."L]-- };    germPagePtr: LONG POINTER = Environment.LongPointerFromPage[Boot.pageGerm];    AllocateStorage[world];    TTY.PutText[world.tty, "Waiting for client..."L];    [] ¬ WorldVMOps.Read[world, germPagePtr];    TTY.PutLine[world.tty, "client responds."L]};      AllocateStorage: ENTRY PROC[world: RemoteWorld] = {    ENABLE UNWIND => NULL;    IF world.rs232 THEN {      «IF ~LoadRS232C[world.tty] THEN RETURN;      IF channelState # created THEN {	lineNumber: CARDINAL ¬ RS232C.GetNextLine[RS232C.nullLineNumber];	commParamsObject: RS232C.CommParamObject ¬ [duplex: full, lineType: asynchronous, lineSpeed: bps19200, accessDetail: directConn[]];	commParams: RS232CEnvironment.CommParamHandle ¬ @commParamsObject;	TTY.PutText[world.tty, "Opening RS232C channel..."L];	channelHandle ¬ RS232C.Create[lineNumber: lineNumber, commParams: commParams, preemptOthers: preemptAlways, preemptMe: preemptNever	  ! RS232C.NoRS232CHardware, RS232C.ChannelInUse => ERROR WorldVM.BadWorld];	RS232C.SetParameter[channelHandle, [charLength[8]]];	RS232C.SetParameter[channelHandle, [correspondent[RS232CCorrespondents.ttyHost]]];	RS232C.SetParameter[channelHandle, [dataTerminalReady[TRUE]]];	RS232C.SetParameter[channelHandle, [frameTimeout[40]]];	RS232C.SetParameter[channelHandle, [parity[none]]];	RS232C.SetParameter[channelHandle, [requestToSend[TRUE]]];	RS232C.SetParameter[channelHandle, [stopBits[1]]];	--RS232C.SetParameter[channelHandle, [flowControl[[type: xOnXOff, xOn: Ascii.ControlQ, xOff: Ascii.ControlS]]]];	RS232C.SetParameter[channelHandle, [flowControl[[type: none, xOn: 0, xOff: 0]]]];	TTY.PutLine[world.tty, "done"L];	channelState ¬ created }»}    ELSE       world.peh ¬ PacketExchange.CreateRequestor[waitTime: world.waitTime, retransmissionInterval: world.waitTime];    IF world.packetCursor = NIL THEN {      world.packetCursor ¬ HeraldWindow.GetCursorSlot[];      HeraldWindow.SetCursor[world.packetCursor, ftpBoxes]};    IF world.req.blockPointer = NIL THEN world.req.blockPointer ¬ AllocBlock[];     IF world.ack.blockPointer = NIL THEN world.ack.blockPointer ¬ AllocBlock[]};      FreeStorage: ENTRY PROC[world: RemoteWorld] = {    ENABLE UNWIND => NULL;    IF world.rs232 THEN {      «IF channelState # deleted THEN {        RS232C.Suspend[channelHandle, all];	IF channelProcess # NIL THEN { 	  Process.Abort[channelProcess]; 	  UNTIL channelProcess = NIL DO WAIT channelAborted; ENDLOOP };        RS232C.Delete[channelHandle];	channelState ¬ deleted }»}    ELSE {      IF world.peh # PacketExchange.nullExchangeHandle THEN {        PacketExchange.Delete[world.peh]; 	world.peh ¬ PacketExchange.nullExchangeHandle }};    IF world.packetCursor # NIL THEN world.packetCursor ¬ HeraldWindow.FreeCursorSlot[world.packetCursor];    IF world.req.blockPointer # NIL THEN world.req.blockPointer ¬ FreeBlock[world.req.blockPointer];     IF world.ack.blockPointer # NIL THEN world.ack.blockPointer ¬ FreeBlock[world.ack.blockPointer]};      AllocBlock: PROC RETURNS [LONG POINTER] = {    RETURN[zone.NEW[ByteSeq[MaxSize.LAST]]]};      FreeBlock: PROC [lp: LONG POINTER] RETURNS[LONG POINTER] = {    IF lp # NIL THEN zone.FREE[@lp]; RETURN[NIL]};    GoRemote: PUBLIC PROCEDURE[world: RemoteWorld] = {    out: TeledebugProtocol.Handle = LOOPHOLE[world.req.blockPointer];    out.body ¬ null[];    out.type ¬ go;    world.req.stopIndexPlusOne ¬ nullReqSize;    IF ~SendAndReceive[world] THEN ERROR;    out.type ¬ goReply;    [] ¬ SendAndReceive[world, FALSE]};  RemoteCoreRead: PUBLIC PROC [world: RemoteWorld, cs: Segment] RETURNS [BOOLEAN] = {    IF ~ReadCorePage[world, cs] THEN RETURN[FALSE];    cs.writeprotect ¬       SELECT cs.flags FROM         writeProtected, writeProtectedReferenced => TRUE,        ENDCASE => FALSE;    RETURN[TRUE]};  ReadCorePage: PROC [world: RemoteWorld, cs: Segment] RETURNS [BOOLEAN] = {    in: TeledebugProtocol.CoreFetchAckHandle = LOOPHOLE[world.ack.blockPointer];    Setup[world, cs, coreFetchReq];    IF ~SendAndReceive[world] OR in.flags = vacant THEN RETURN[FALSE];    cs.flags ¬ in.flags;    Inline.LongCOPY[@in.data, SIZE[TeledebugProtocol.PageData], cs.address];    RETURN[TRUE]};  RemoteDiskRead: PUBLIC PROC [world: RemoteWorld, cs: Segment] = {    Space.Activate[cs.space];    IF ~ReadDiskPage[world, cs] THEN ERROR WorldVMOps.AddressFault[Environment.LongPointerFromPage[cs.mempage]] };    ReadDiskPage: PROC [world: RemoteWorld, cs: Segment] RETURNS [BOOLEAN] = {    in: TeledebugProtocol.DiskFetchAckHandle = LOOPHOLE[world.ack.blockPointer];    Setup[world, cs, diskFetchReq];    IF ~SendAndReceive[world] THEN RETURN[FALSE];    Inline.LongCOPY[@in.data, SIZE[TeledebugProtocol.PageData], cs.address];    RETURN[TRUE] };  RemoteCoreWrite: PUBLIC PROC [world: RemoteWorld, cs: Segment] = {    in: TeledebugProtocol.CoreStoreAckHandle = LOOPHOLE[world.ack.blockPointer];    Setup[world, cs, coreStoreReq];    IF ~SendAndReceive[world] OR in.flags # cs.flags THEN ERROR };  RemoteDiskWrite: PUBLIC PROC [world: RemoteWorld, cs: Segment] = {    Setup[world, cs, diskStoreReq];    IF ~SendAndReceive[world] THEN ERROR };  Setup: PROC [world: RemoteWorld, cs: Segment, request: TeledebugProtocol.RequestType] = {    IF world.rs232 THEN { «RS232Setup[world, cs, request]» }    ELSE EnetSetup[world, cs, request] };    EnetSetup: PROC [world: RemoteWorld, cs: Segment, request: TeledebugProtocol.RequestType] = {    SELECT request FROM      coreStoreReq => {        out: TeledebugProtocol.CoreStoreReqHandle = LOOPHOLE[world.req.blockPointer];	out.body ¬ coreStoreReq[page: cs.mempage, flags: cs.flags, data:];	Inline.LongCOPY[cs.address, SIZE[TeledebugProtocol.PageData], @out.data];	world.req.stopIndexPlusOne ¬ coreStoreReqSize;	world.ack.stopIndexPlusOne ¬ coreStoreAckSize;	out.type ¬ coreStore };      coreFetchReq => {        out: TeledebugProtocol.CoreFetchReqHandle = LOOPHOLE[world.req.blockPointer];	out.body ¬ coreFetchReq[page: cs.mempage];	world.req.stopIndexPlusOne ¬ coreFetchReqSize;	world.ack.stopIndexPlusOne ¬ coreFetchAckSize;	out.type ¬ coreFetch };      diskStoreReq => {        out: TeledebugProtocol.DiskStoreReqHandle = LOOPHOLE[world.req.blockPointer];	out.body ¬ diskStoreReq[page: cs.mempage, entry: cs.entry­, data:];	Inline.LongCOPY[cs.address, SIZE[TeledebugProtocol.PageData], @out.data];	world.req.stopIndexPlusOne ¬ diskStoreReqSize;	world.ack.stopIndexPlusOne ¬ diskStoreAckSize;	out.type ¬ diskStore };      diskFetchReq => {        out: TeledebugProtocol.DiskFetchReqHandle = LOOPHOLE[world.req.blockPointer];	out.body ¬ diskFetchReq[page: cs.mempage, entry: cs.entry­];	world.req.stopIndexPlusOne ¬ diskFetchReqSize;	world.ack.stopIndexPlusOne ¬ diskFetchAckSize;	out.type ¬ diskFetch };      ENDCASE };  SendAndReceive: PROC [world: RemoteWorld, wait: BOOLEAN ¬ TRUE] RETURNS [BOOLEAN] = {    IF world.rs232 THEN RETURN[FALSE «RS232SendAndReceive[world, wait]»]    ELSE RETURN[EnetSendAndReceive[world, wait]] };    EnetSendAndReceive: PROC [world: RemoteWorld, wait: BOOLEAN] RETURNS [BOOLEAN] = {    DO      nBytes: CARDINAL;      replyType: NSTypes.ExchangeClientType;      IF world.timeout THEN {        HeraldWindow.SetCursor[world.packetCursor, ftpBoxes];	world.timeout ¬ FALSE };      HeraldWindow.SetCursorState[world.packetCursor, negative];      [nBytes: nBytes, replyType: replyType] ¬         PacketExchange.SendRequest[world.peh, world.host, world.req, world.ack, teledebug 	  ! PacketExchange.Timeout => {	      CheckAbort[world];	      IF wait THEN {		IF ~world.timeout THEN { 		  HeraldWindow.SetCursor[world.packetCursor, retry];		  world.timeout ¬ TRUE };		HeraldWindow.SetCursorState[world.packetCursor, invert];		RESUME }	      ELSE GOTO noReply};	    PacketExchange.Error => {	      CheckAbort[world];	      SELECT why FROM 		noDestinationSocket, noRouteToDestination, noReceiverAtDestination => { 		  IF wait THEN {		    IF ~world.timeout THEN { 		      HeraldWindow.SetCursor[world.packetCursor, retry];		      world.timeout ¬ TRUE };		    HeraldWindow.SetCursorState[world.packetCursor, invert];		    Process.Pause[Process.SecondsToTicks[10]]; 		    RETRY }		  ELSE GOTO noReply};		aborted => ERROR ABORTED;		ENDCASE => REJECT}];      HeraldWindow.SetCursorState[world.packetCursor, positive];      IF replyType # teledebug THEN ERROR;      IF ~Like[world, nBytes] THEN ERROR;      RETURN[LOOPHOLE[world.ack.blockPointer, TeledebugProtocol.Handle].type = ack];      ENDLOOP;    EXITS noReply => RETURN[TRUE] };      CheckAbort: PROCEDURE[world: World] = {    IF TTY.UserAbort[world.tty] THEN { TTY.ResetUserAbort[world.tty]; ERROR ABORTED }};  Like: PROC [world: RemoteWorld, bytes: CARDINAL] RETURNS [BOOLEAN] = {    out: TeledebugProtocol.Handle = LOOPHOLE[world.req.blockPointer];    WITH out SELECT FROM      null => {        in: TeledebugProtocol.Handle = LOOPHOLE[world.ack.blockPointer];	RETURN[in.request = null AND in.type = ack]};      coreStoreReq => {        in: TeledebugProtocol.CoreStoreAckHandle = LOOPHOLE[world.ack.blockPointer];	RETURN[in.request = coreStoreAck AND page = in.page AND bytes >= coreStoreAckSize]};      coreFetchReq => {        in: TeledebugProtocol.CoreFetchAckHandle = LOOPHOLE[world.ack.blockPointer];	RETURN[in.request = coreFetchAck AND page = in.page AND bytes >= coreFetchAckSize]};      diskStoreReq => {        in: TeledebugProtocol.DiskStoreAckHandle = LOOPHOLE[world.ack.blockPointer];	RETURN[in.request = diskStoreAck AND page = in.page AND bytes >= diskStoreAckSize]};      diskFetchReq => {        in: TeledebugProtocol.DiskFetchAckHandle = LOOPHOLE[world.ack.blockPointer];	RETURN[in.request = diskFetchAck AND page = in.page AND bytes >= diskFetchAckSize]};      ENDCASE;    RETURN[FALSE]};    «channelHandle: RS232C.ChannelHandle; -- only one RS232 channel  channelState: {created, deleted} ¬ deleted;  channelProcess: PROCESS ¬ NIL;  channelAborted: CONDITION;»    «ChannelProcessAborted: ENTRY PROC[] = {     -- workaround    «IF ProcessorInfo.GetMachineType[] = daybreak THEN       LOOPHOLE[	LOOPHOLE[channelHandle, RS232CInternal.ChannelStatusHandle].face,	  RS232CSubDriver.LineHandle].transfersPending ¬ 0;»    -- end workaround    channelProcess ¬ NIL; NOTIFY channelAborted; };»    «LoadRS232C: PROC[tty: TTY.Handle] RETURNS[ok: BOOLEAN ¬ TRUE] = {    out: Format.StringProc = { TTY.PutString[tty, s] };    IF ~Runtime.IsBound[LOOPHOLE[RS232C.Create]] THEN IF Exec.Load[write: out, name: "RS232CIO.bcd"L] = NIL THEN ok ¬ FALSE;    IF ~Runtime.IsBound[LOOPHOLE[RS232CFace.On]] THEN      SELECT ProcessorInfo.GetMachineType[] FROM	dandelion => IF Exec.Load[write: out, name: "RS232CIOHeadsDLion.bcd"L] = NIL THEN ok ¬ FALSE;	daybreak, daisy => IF Exec.Load[write: out, name: "RS232CIOHeadsDove.bcd"L] = NIL THEN ok ¬ FALSE;	ENDCASE => { out["Unknown machine type!"L]; ok ¬ FALSE }};»     «RS232SendAndReceive: PROC [world: RemoteWorld, wait: BOOLEAN ¬ TRUE] RETURNS [BOOLEAN] = {    nBytes: CARDINAL;    status: RS232C.TransferStatus;    eventGet, eventPut: RS232C.CompletionHandle;    physicalRecordGet, physicalRecordPut: RS232CEnvironment.PhysicalRecord;    physicalRecordHandleGet: RS232CEnvironment.PhysicalRecordHandle = @physicalRecordGet;    physicalRecordHandlePut: RS232CEnvironment.PhysicalRecordHandle = @physicalRecordPut;    physicalRecordGet.header ¬ physicalRecordGet.trailer ¬ physicalRecordPut.header ¬ physicalRecordPut.trailer ¬ [NIL, 0, 0];    channelProcess ¬ Process.GetCurrent[];    DO      IF world.timeout THEN {        HeraldWindow.SetCursor[world.packetCursor, ftpBoxes];	world.timeout ¬ FALSE };      HeraldWindow.SetCursorState[world.packetCursor, negative];      BEGIN	physicalRecordPut.body ¬ world.req;	physicalRecordGet.body ¬ world.ack;	eventGet ¬ RS232C.Get[channelHandle, physicalRecordHandleGet];	eventPut ¬ RS232C.Put[channelHandle, physicalRecordHandlePut];	[nBytes, status] ¬ RS232C.TransmitNow[channelHandle, eventPut ! ABORTED => GOTO Aborted];	SELECT status FROM	  success => NULL;	  aborted => GOTO Aborted;	  ENDCASE => ERROR;	[nBytes, status] ¬ RS232C.TransferWait[channelHandle, eventGet ! ABORTED => GOTO Aborted];	SELECT status FROM	  -- no Timeout	  success => NULL;	  aborted => GOTO Aborted;	  dataLost => ERROR; --LOOP;	  deviceError => ERROR; --LOOP; probably lost bytes, need to clear latch bit?	  ENDCASE => ERROR;	  END;       HeraldWindow.SetCursorState[world.packetCursor, positive];      IF ~RS232Like[world, nBytes] THEN LOOP; -- ERROR;      channelProcess ¬ NIL;      RETURN[LOOPHOLE[world.ack.blockPointer, TeledebugProtocol.Handle].type = ack];      ENDLOOP;    EXITS Aborted => { ChannelProcessAborted[]; ERROR ABORTED }};»        «RS232Setup: PROC [world: RemoteWorld, cs: Segment, request: TeledebugProtocol386.RequestType] = {    SELECT request FROM      coreStoreReq => {        out: TeledebugProtocol386.CoreStoreReqHandle = LOOPHOLE[world.req.blockPointer];	out.body ¬ coreStoreReq[pid: cs.process, page: cs.mempage, flags: cs.flags, data:];	Inline.LongCOPY[cs.address, SIZE[TeledebugProtocol386.PageData], @out.data];	world.req.stopIndexPlusOne ¬ TeledebugProtocol386.coreStoreReqSize;	world.ack.stopIndexPlusOne ¬ TeledebugProtocol386.coreStoreAckSize;	out.type ¬ coreStore };      coreFetchReq => {        out: TeledebugProtocol386.CoreFetchReqHandle = LOOPHOLE[world.req.blockPointer];	out.body ¬ coreFetchReq[pid: cs.process, page: cs.mempage];	world.req.stopIndexPlusOne ¬ TeledebugProtocol386.coreFetchReqSize;	world.ack.stopIndexPlusOne ¬ TeledebugProtocol386.coreFetchAckSize;	out.type ¬ coreFetch };      diskStoreReq => {        out: TeledebugProtocol386.DiskStoreReqHandle = LOOPHOLE[world.req.blockPointer];	out.body ¬ diskStoreReq[pid: cs.process, page: cs.mempage, entry: cs.entry­, data:];	Inline.LongCOPY[cs.address, SIZE[TeledebugProtocol386.PageData], @out.data];	world.req.stopIndexPlusOne ¬ TeledebugProtocol386.diskStoreReqSize;	world.ack.stopIndexPlusOne ¬ TeledebugProtocol386.diskStoreAckSize;	out.type ¬ diskStore };      diskFetchReq => {        out: TeledebugProtocol386.DiskFetchReqHandle = LOOPHOLE[world.req.blockPointer];	out.body ¬ diskFetchReq[pid: cs.process, page: cs.mempage, entry: cs.entry­];	world.req.stopIndexPlusOne ¬ TeledebugProtocol386.diskFetchReqSize;	world.ack.stopIndexPlusOne ¬ TeledebugProtocol386.diskFetchAckSize;	out.type ¬ diskFetch };      ENDCASE };»      «RS232Like: PROC [world: RemoteWorld, bytes: CARDINAL] RETURNS [BOOLEAN] = {    out: TeledebugProtocol386.Handle = LOOPHOLE[world.req.blockPointer];    WITH out SELECT FROM      null => {        in: TeledebugProtocol386.Handle = LOOPHOLE[world.ack.blockPointer];	RETURN[in.request = null AND in.type = ack]};      coreStoreReq => {        in: TeledebugProtocol386.CoreStoreAckHandle = LOOPHOLE[world.ack.blockPointer];	RETURN[in.request = coreStoreAck AND page = in.page AND bytes >= TeledebugProtocol386.coreStoreAckSize]};      coreFetchReq => {        in: TeledebugProtocol386.CoreFetchAckHandle = LOOPHOLE[world.ack.blockPointer];	RETURN[in.request = coreFetchAck AND page = in.page AND bytes >= TeledebugProtocol386.coreFetchAckSize]};      diskStoreReq => {        in: TeledebugProtocol386.DiskStoreAckHandle = LOOPHOLE[world.ack.blockPointer];	RETURN[in.request = diskStoreAck AND page = in.page AND bytes >= TeledebugProtocol386.diskStoreAckSize]};      diskFetchReq => {        in: TeledebugProtocol386.DiskFetchAckHandle = LOOPHOLE[world.ack.blockPointer];	RETURN[in.request = diskFetchAck AND page = in.page AND bytes >= TeledebugProtocol386.diskFetchAckSize]};      ENDCASE;    RETURN[FALSE]};»    }.
-- File: ITStmtMap.mesa - last edit:-- Litman              22-May-87 14:53:16-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.DIRECTORY  Ascii USING [ControlZ, CR],  Copier USING [Handle, Outer],  FileWindow USING [FileInWindow, WindowForFile],  Format USING [Char, LongNumber, StringProc],  IO USING [Text],  IP USING [Ep, IgnoreTimeStamp, LoadWindow, UserCBti],  IQ USING [AppendComplaint, CrossJumped, GFrameMdi, NoFGT],  IT USING [BytePC, GFHandle, Handle, MaxModuleString, NILGF, nullPC],  MFile USING [GetProperties, GetTimes, Handle, maxNameLength],  MStream USING [Error, GetFile, Handle, ReadOnly],  Runtime USING [IsBound],  Stream USING [Delete, EndOfStream, GetChar, GetPosition, Handle, SetPosition],  String USING [AppendString, Equivalent],  Symbols USING [BTIndex, BTNull, CBTIndex, MDIndex],  SymbolSegment USING [FGTEntry],  SymbolTable USING [Handle, Missing],  Time USING [defaultTime, Packed],  Window USING [Handle];ITStmtMap: PROGRAM  IMPORTS Copier, FileWindow, Format, IO, IP, IQ, MFile, MStream, Runtime, Stream, String, SymbolTable  EXPORTS IP = {     windows: BOOLEAN = Runtime.IsBound[LOOPHOLE[FileWindow.FileInWindow]];  FileMissing: PUBLIC SIGNAL [name: LONG STRING] = CODE;  MappingFailure: PUBLIC SIGNAL = CODE;  TooLong: ERROR = CODE;    Handle: TYPE = SymbolTable.Handle;  PcToSource: PUBLIC PROCEDURE [h: IT.Handle, base: Handle, gf: IT.GFHandle, pc: IT.BytePC, bti: Symbols.BTIndex, start: IT.BytePC] RETURNS [currentSource: CARDINAL] = {    -- finds i such that pc is in [fgt[i].cIndex..fgt[i+1].cIndex)    i, s, l: CARDINAL;    deltaPc: CARDINAL ¬ pc - start;    stride: CARDINAL ¬ 0;    IF bti = Symbols.BTNull THEN ERROR MappingFailure;    currentSource ¬ base.bb[bti].sourceIndex;    WITH base.bb[bti].info SELECT FROM      External => { s ¬ startIndex; l ¬ indexLength; };      ENDCASE => ERROR;    WITH base.bb[bti] SELECT FROM Other => deltaPc ¬ deltaPc - relOffset; ENDCASE;    IF l = 1 THEN RETURN;    FOR i IN (s..s + l) DO      WITH base.fgTable[i] SELECT FROM        normal => {          IF deltaObject > deltaPc THEN RETURN;          deltaPc ¬ deltaPc - deltaObject;          currentSource ¬ currentSource + deltaSource + stride;          stride ¬ 0 };        step =>          IF which = object THEN            IF delta > deltaPc THEN RETURN ELSE deltaPc ¬ deltaPc - delta          ELSE stride ¬ stride + delta;        ENDCASE;      ENDLOOP };  -- the first approximation to this algorithm is this:  -- find the name of the source file from the symbols  -- acquire the file, if that fails, complain about the file being missing  -- check the dates, if they are incorrect complain about version mismatch  -- complication #1, we may have been told to ignore the timestamp. then  -- we can't complain about version mismatch until we check to see if we  -- should ignore the date.    -- complication #2, the source we get by trying to acquire may be wrong  -- but the correct file may have been loaded (by hand) into a source window  -- and the user expects us to use it    -- the idea here is to get the name of the source from the symbol table  -- and try to acquire it.  If we succeed in getting a file with the right  -- name we check it for the date.  If that is correct too we are happy  -- and return.  If we can't find the file, or it has the wrong date, then  -- we need to check the windows to see if (1) we should ignore the stamp  -- or (2) the right source is already loaded, first we let the file system  -- tell us which window it would load the source into if we asked it to  -- (IE which window can possibly have the right source in it).  If there is  -- none, then we complain about the file either being missing or the  -- wrong date, depending if we found it earlier.  If there is a window, we  -- first make sure that it has our file in it (if not we complain as above)  -- and look at (1) the date on the source in that window and (2) the  -- ignore timestamp bit, if either is correct we return happy.    -- note that if the user has the correct file loaded into one window, and  -- a wrong version in another window, he may lose if the file system sees  -- the bogus one first and filewindow also sees the bogus window first...  -- tough, I don't feel like enumerating all filewindows myself.        PCToSourceOuter: PROCEDURE [it: IT.Handle, pc: IT.BytePC, gf: IT.GFHandle, s: STRING] RETURNS [h: Stream.Handle ¬ NIL, index: LONG CARDINAL ¬ 0] = {        OpenSymbols: PROC [base: Handle] = {      fileId: STRING ¬ [IT.MaxModuleString];      want: Time.Packed = [base.stHandle.sourceVersion.time];      have: Time.Packed ¬ Time.defaultTime;      status: {good, missing, badVersion} ¬ good;      nameInWindow: LONG STRING;      streamInWindow: Stream.Handle;      shortNameInWindow: LONG STRING ¬ [MFile.maxNameLength];      w: Window.Handle;      BEGIN      String.AppendString[fileId, base.sourceFile];      IF fileId[fileId.length - 1] = '. THEN fileId.length ¬ fileId.length - 1;      IF s # NIL THEN String.AppendString[s, fileId];      h ¬ MStream.ReadOnly[fileId, [] ! MStream.Error => IF code = fileNotAvailable THEN {status ¬ missing; CONTINUE}];      IF status = good THEN {        have ¬ MFile.GetTimes[MStream.GetFile[h]].create;	IF have = want THEN GOTO done;	status ¬ badVersion;	-- if the file window has the file and we are to ignore the timestamp	-- we will get the stream from the window so we gun the current stream	h.delete[h];	h ¬ NIL };      -- can't get the file from the name in the symbols try getting it from a window      -- ASSERT h = NIL AND status # good      w ¬ FileWindow.WindowForFile[fileId];      IF w = NIL THEN GOTO done;      [nameInWindow, streamInWindow] ¬ FileWindow.FileInWindow[w];      IF nameInWindow = NIL OR streamInWindow = NIL THEN GOTO done;      [] ¬ MFile.GetProperties[MStream.GetFile[streamInWindow], shortNameInWindow];      IF ~String.Equivalent[fileId, shortNameInWindow] THEN GOTO done;      -- instead of worrying about the name, we should worry about the GF this file      -- belongs to, maybe checking the item, creating one if necessary?  After all      -- the client could have renamed the source to something totally bizzare, but      -- it might still be the source that was used to create the bcd we are       -- interested in.  The only real way to tell is to look at the module name      -- IN THE FILE and the create date.      h ¬ MStream.ReadOnly[nameInWindow, [] ! MStream.Error => IF code = fileNotAvailable THEN GOTO done];      have ¬ MFile.GetTimes[MStream.GetFile[h]].create;      IF have # want AND ~IP.IgnoreTimeStamp[it, w] THEN { status ¬ badVersion; GOTO done };      status ¬ good;      GOTO done;      EXITS        done => SELECT status FROM	  good => {	    IF pc = IT.nullPC THEN RETURN;	    index ¬ PcToSource[it, base, gf, pc, cbti, start]};	  missing => ERROR FileMissing[fileId];	  badVersion => Complain[it, have, want, fileId];	  ENDCASE;      END };    mdi: Symbols.MDIndex;    cbti: Symbols.CBTIndex;    start: IT.BytePC;    IF gf = IT.NILGF THEN gf ¬ it.gContext;    -- the order of the following three assignments may be important    -- especially look out for side effects in the procedure calls, notably    -- (pre-)loading of the Pc cache    cbti ¬ IP.UserCBti[it, pc, gf];    IF pc # IT.nullPC THEN start ¬ IP.Ep[it, pc, gf ! SymbolTable.Missing => GOTO missing].start;    mdi ¬ IQ.GFrameMdi[it, gf, TRUE ! SymbolTable.Missing => GOTO missing];    Copier.Outer[it.sym, mdi, OpenSymbols ! UNWIND => IF h # NIL THEN h.delete[h]];    EXITS missing => NULL };    Complain: PROCEDURE [h: IT.Handle, have, want: Time.Packed, file: LONG STRING] = {    msg: LONG STRING ¬ [120];    IQ.AppendComplaint[msg: msg, file: file, have: have, want: want];    ERROR FileMissing[msg]};  CheckTimes: PUBLIC PROCEDURE [h: IT.Handle, w: Window.Handle, gf: IT.GFHandle, sh: Stream.Handle] = {    name: LONG STRING ¬ [IT.MaxModuleString];    want: Time.Packed;    GetVersion: PROC [base: Handle] = {      want ¬ [base.stHandle.sourceVersion.time];      String.AppendString[name, base.sourceFile]};    IF ~IP.IgnoreTimeStamp[h, w] THEN {      have: Time.Packed = MFile.GetTimes[MStream.GetFile[sh]].create;      Copier.Outer[h.sym, IQ.GFrameMdi[h, gf, FALSE], GetVersion];      IF want # have THEN Complain[h, have, want, name]}};  DisplaySource: PUBLIC PROC [h: IT.Handle, gf: IT.GFHandle, pc: IT.BytePC, load: BOOLEAN] = {    SpecialDisplay[h, NIL, gf, pc, load]};  SpecialDisplay: PUBLIC PROC [h: IT.Handle, out: Format.StringProc, gf: IT.GFHandle, pc: IT.BytePC, load: BOOLEAN, msg: LONG STRING ¬ NIL, suppressErrors: BOOLEAN ¬ FALSE] = {    fileId: STRING ¬ [IT.MaxModuleString];    file: Stream.Handle ¬ NIL;    index: LONG CARDINAL;    BEGIN ENABLE UNWIND => IF file # NIL THEN Stream.Delete[file];    IF ~windows THEN load ¬ FALSE;    IF out = NIL THEN out ¬ IO.Text;    [file, index] ¬ PCToSourceOuter[h, pc, gf, fileId       ! IQ.NoFGT => IF ~suppressErrors THEN ERROR FileMissing[NIL];        MappingFailure => CONTINUE];    IF file = NIL THEN RETURN;    IF ~suppressErrors AND IQ.CrossJumped[h, gf] THEN out[" Cross jumped!\n"L, h];    index ¬ PrintTextLine[h, out, file, index, msg];     IF load THEN IP.LoadWindow[h, fileId, gf, file, index] ELSE Stream.Delete[file];    END };  PrintTextLine: PROC [h: IT.Handle, out: Format.StringProc, sh: Stream.Handle, i: LONG CARDINAL, msg: LONG STRING ¬ NIL] RETURNS [index: LONG CARDINAL] = {    start, lineIndex: LONG CARDINAL ¬ i;    char: CHARACTER;    n: [1..100];    FOR n IN [1..100] UNTIL lineIndex = 0 DO      lineIndex ¬ lineIndex - 1;      Stream.SetPosition[sh, lineIndex];      IF Stream.GetChar[sh] = Ascii.CR THEN {start ¬ lineIndex + 1; EXIT};      ENDLOOP;    FOR n IN [1..100] DO      SELECT (char ¬ Stream.GetChar[sh ! Stream.EndOfStream => EXIT]) FROM        Ascii.CR, Ascii.ControlZ => EXIT;        ENDCASE => {          Format.Char[out, char, h];          IF Stream.GetPosition[sh] = i THEN { out["<"L, h]; out[msg, h]; out[">"L, h] }};      ENDLOOP;    out["  [", h]; Format.LongNumber[out, i, [], h]; out["]\n"L, h];    RETURN[start] };  }.
-- Copyright (C) 1985  by Xerox Corporation. All rights reserved. -- IQ.mesaDIRECTORYAlloc,CommandList, -- possible input commands for CoPilotCPSwapDefs, -- external state vector definitionIT,SymbolTable,Tree;IQ: DEFINITIONS = {  OPEN IT;  «====================================================  PROCEDURES====================================================»  -- BP  WriteUserBB: PROC [h: Handle, ubb: CPSwapDefs.UBBPointer];  FindUserBB: PROC [h: Handle, ph: PrefixHandle, pc: BytePC] RETURNS [CARDINAL];  GetUserBB: PROC [h: Handle, ph: PrefixHandle, pc: BytePC] RETURNS [CARDINAL];  FreeUserBB: PROC [h: Handle, ph: PrefixHandle, pc: BytePC];  AllocBB: PROC[h: Handle] RETURNS [BBHandle];  FreeBB: PROC [Handle, BBHandle];  DeleteBB: PROC [h: Handle, bb: BBHandle] RETURNS [last: BOOLEAN];  FindBB: PROC [h: Handle, gf: GFHandle, pc: BytePC] RETURNS [bb: BBHandle];  FindBBNum: PROC [Handle, CARDINAL] RETURNS [BBHandle];  ResetBBs: PROCEDURE[h: Handle];  EnumerateBBs: PROC [h: Handle,     proc: PROC [Handle, BBHandle] RETURNS [BOOLEAN], gf: GFHandle ¬ NILGF]    RETURNS [BBHandle];  BreakEntry, BreakExit, TraceEntry, TraceExit: PROC [h: Handle,     proc: LONG STRING];  ClearEntryBreak, ClearXitBreak: PROC [h: Handle, proc: LONG STRING];  ClearEntryTrace, ClearXitTrace: PROC [h: Handle, proc: LONG STRING];  BreakAllEntries, BreakAllXits: PROC [h: Handle, mod, exp: LONG STRING];  TraceAllEntries, TraceAllXits: PROC [h: Handle, mod, exp: LONG STRING];  ClearAllEntries, ClearAllXits: PROC [h: Handle, mod: LONG STRING];  ClearBreak: PROC [h: Handle, bbNum: LONG STRING];  ClearDefault: PROC [Handle, BBHandle];  AttachCondition: PROC [h: Handle, bbNum, cond: LONG STRING];  AttachExpression: PROC [h: Handle, bbNum, exp: LONG STRING];  ClearCondition: PROC [h: Handle, bbNum: LONG STRING];  ClearExpression: PROC [h: Handle, bbNum: LONG STRING];  ListBreak: PROC [h: Handle, bbNum: LONG STRING];  DisplayB: PROC [Handle, LONG STRING];  ClearB: PROC [Handle, LONG STRING];  ClearC: PROC [Handle, LONG STRING];  ClearE: PROC [Handle, LONG STRING];  ClearAllBreaks, ClearAllTraces, ListBreaks: PROCEDURE[h: Handle];  OctalBreak, ClearOctal: PROC [h: Handle, gf, pc: LONG STRING];  Insert: PROC [h: Handle,     gf: GFHandle, pc: BytePC, bt: BreakType, haveSyms: BOOLEAN]    RETURNS [bb: BBHandle];  Remove: PROC [h: Handle, gf: GFHandle, pc: BytePC];  Conditionalize: PROC [Handle, BBHandle, LONG STRING];  Condition: PROC [h: Handle,     left: CPSwapDefs.OperandDesc,     rel: Tree.NodeName,     right: CPSwapDefs.OperandDesc];  Expressionalize: PROC [Handle, BBHandle, LONG STRING];  List: PROC [Handle, BBHandle];  BPValidate: PROC [h: Handle, lf: LFHandle] RETURNS [BOOLEAN];  BPFail: ERROR [type: CommandList.BPError];  BPAbortWithError: PROC [h: Handle, err: CommandList.BPError];  BPWriteError: PROC [h: Handle, err: CommandList.BPError];  BPAbortWithWrittenError: PROC [h: Handle, err: CommandList.BPError] = INLINE {    BPWriteError[h, err]; BPAbortWithError[h, err]};  BPAppendError: PROC [Handle, LONG STRING, CommandList.BPError];    -- Frames  LOrGType: PROC [Handle, LONG POINTER] RETURNS [LG];  ValidateF: PROC [Handle, LFHandle]     RETURNS [ok: BOOLEAN, lf: LongLocalFrameHandle];  CheckF: PROC [Handle, LFHandle] RETURNS [LongLocalFrameHandle];  ValidateGF: PROC [Handle, GFHandle] RETURNS [BOOLEAN];  CheckGF: PROC [Handle, GFHandle];  DisplayF: PROC [Handle, LFHandle];  DisplayGF: PROC [h: Handle, gf: GFHandle, delim: STRING];  DisplayLocalsF: PROC [Handle, LFHandle];  DisplayParametersF: PROC [Handle, LFHandle];  DisplayResultsF: PROC [Handle, LFHandle];  DisplayLocalsGF: PROC [Handle, GFHandle];  DisplayParametersGF: PROC [Handle, GFHandle];  DisplayResultsGF: PROC [Handle, GFHandle];  InMainBody: PROC [h: Handle, f: LFHandle] RETURNS [BOOLEAN];  GetMainBody: PROC [Handle, GFHandle] RETURNS [LFHandle];  FlushFrameCache: PROC[h: Handle];  PreDeclared: PROC [h: Handle, sig: SignalDesc, print: BOOLEAN]     RETURNS [found: BOOLEAN, sei: SEIndex];  InvalidFrame: SIGNAL [f: LONG POINTER];    -- CPSyms  AppendComplaint: PROC [msg, file: LONG STRING, have, want: LONG CARDINAL];  AttachSymbols: PROC [h: Handle, frame, file: LONG STRING];  AttachOpaque: PROC [h: Handle, type, file: LONG STRING];  AttachBcd: PROC [h: Handle, gf: GFHandle, file: LONG STRING];  FileMdi: PROC [h: Handle, hti: HTIndex, fgt: BOOLEAN ¬ FALSE]     RETURNS [MDIndex];  GFrameMdi: PROC [h: Handle, gf: GFHandle, fgt: BOOLEAN ¬ FALSE]     RETURNS [MDIndex];  Stopping: PROC [h: Handle, gf: GFHandle, fgt: BOOLEAN ¬ FALSE]     RETURNS [BOOLEAN];  CrossJumped: PROC [h: Handle, gf: GFHandle, fgt: BOOLEAN ¬ FALSE]     RETURNS [BOOLEAN];  NoFGT: ERROR;  Enumerate: PROC [h: Handle, proc: PROC [ModItem] RETURNS [BOOLEAN]]     RETURNS [syms: ModItem];  FindMdi: PROC [h: Handle, mdi: MDIndex] RETURNS [ModItem];  FindMod: PROC [Handle, HTIndex] RETURNS [ModItem];  FindFrame: PROC [Handle, GFHandle] RETURNS [ModItem];  FreeItems: PROC[h: Handle];  Prune: PROC[h: Handle];  OpenFile: PROC [h: Handle, gf: GFHandle, file: LONG STRING,     hti: HTIndex] RETURNS [ModItem];  AddItem: PROC [Handle, GFHandle] RETURNS [ModItem];   InitSym: PROC[alloc: Alloc.Handle, zone: UNCOUNTED ZONE]    RETURNS[sym: SymbolTable.Handle];  Head: ModCache;    -- Actions  AsciiDisplay, AsciiRead: PROC [h: Handle, start, chars: LONG STRING];  Comment: PROC [Handle, LONG STRING];  DebuggingMode: PROC[h: Handle];  DisplayFrame: PROC [Handle, LONG STRING];  GlobalDump: PROC [h: Handle, gf: GFHandle];  LocalDump: PROC [h: Handle, f: LFHandle];  DisplayModule: PROC [Handle, LONG STRING];  DisplayStack: PROC[h: Handle];  DoKill: PROC[h: Handle];  DoProceed: PROC[h: Handle];  DoQuit: PROC[h: Handle];  FindVar: PROC [Handle, LONG STRING];  GetDebuggee: PROC [Handle, LONG STRING];  GetFrame: PROC [Handle, LONG STRING];  Invalidate: PROC[h: Handle];  OctalRead: PROC [h: Handle, start, cnt: LONG STRING];  DoRead: PROC [h: Handle, start: LONG POINTER, cnt: CARDINAL];  OctalWrite: PROC [h: Handle, loc, val: LONG STRING];  PrintCoremap: PROC[h: Handle];  SearchMode: PROC[h: Handle];  SetOctalContext: PROC [Handle, LONG STRING];  SetProcessContext: PROC [Handle, LONG STRING];  StartUser: PROC [h: Handle, gf: LONG STRING];  TeleDebug: PROC [Handle, LONG STRING];  UserScreen: PROC[h: Handle];  WorryMode: PROC[h: Handle];  Spare: PROC[h: Handle];  Spare1: PROC [Handle, LONG STRING];  Spare2: PROC [Handle, LONG STRING, LONG STRING];  DumpFrame: PROC [Handle, LONG POINTER];  CallInterpreter: PROC [h: Handle];    -- DebugSymbols  Open: PROC [h: Handle, mdi: MDIndex, inner: PROC [SymbolTable.Handle]];  ResetSymbols: PROC[h: Handle]; -- recovers from Alloc.Failure  GetTypeInfo: PROC [Handle, Foo] RETURNS [hti: HTIndex,     type: SEIndex];         }..
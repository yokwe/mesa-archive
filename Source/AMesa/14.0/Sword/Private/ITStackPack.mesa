-- File: ITStackPack.mesa - last edit:-- Litman               1-May-87 10:51:27-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.DIRECTORY  AMLoadstate, BcdOps, WorldVMOps, BcdOpsExtras, BcdDefs,  AMUseful USING [VersionStamp],  Ascii USING [BS, ControlQ, ControlW, DEL, SP],  IL USING [],  IO USING [Blanks, Char, Decimal, EOL, InvalidNumber, Line, Numeric, StringExpToDecimal, StringExpToLOctal, SubString, Text, UserAborted],  IP USING [CatchFrame, CheckStarted, DisplaySource, DumpFrameDesc, Ep, Exit, GF, GFrame, MultipleFrames, NoPrevious, PC, Previous],  IQ USING [CallInterpreter, DisplayF, DisplayGF, DisplayLocalsF, DisplayLocalsGF, DisplayParametersF, DisplayParametersGF, DisplayResultsF, DisplayResultsGF, GetMainBody, GFrameMdi, InvalidFrame, ValidateF, ValidateGF],  IS USING [GetComment, GetString, Prompt, SetParse, Umbrella],  IT USING [BytePC, GFHandle, Handle, LFHandle, MDIndex, MDNull, NILGF, nullPC, ParseProc],  String USING [LowerCase, AppendString, SubStringDescriptor, AppendChar],  SymbolTable USING [Missing],  Time USING [Append, Unpack];  ITStackPack: PROGRAM  IMPORTS AMLoadstate, WorldVMOps, BcdOpsExtras,    AMUseful, IO, IP, IQ, IS, String, SymbolTable, Time  EXPORTS IL, IQ = {  OPEN IT;    DFMsg: TYPE = {invalid, noSyms, options, gso, del, na, source, npf, dso, catch, lso};        WriteMsg: PROC [h: Handle, msg: DFMsg] = {    IO.Text[SELECT msg FROM      invalid => " ! Current context invalid."L,      noSyms => "No symbols for "L,      options => "--Options are: "L,      gso => """ "", --, List source, Parameters, Quit, Return values, Source, Variables"L,      del => " XXX"L,      na => " not available"L,      source => " Source: "L,      npf => "No previous frame!"L,      dso => ", Globals, Jump, Next"L,      catch => "CatchFrame:  "L,      lso => "Jump, Next, Quit  >"L,      ENDCASE => "?"L, h] };      StackParse: PROC[h: Handle] = {    IS.SetParse[h, StackCommands];    h.prompt ¬ Caret };      DisplayStack: PUBLIC PROC[h: Handle] = {     StackParse[h];    IO.Blanks[h, 1];    SELECT TRUE FROM      h.lContext # NIL => { LocalDump[h, h.lContext]; h.stackLevel ¬ 0 };      h.gContext # NILGF => GlobalDump[h, h.gContext];      ENDCASE => {         WriteMsg[h, invalid]; 	IS.Prompt[h: h, resetPrompt: TRUE, resetParse: TRUE] }};      DisplayModule: PUBLIC PROC [h: Handle, m: LONG STRING] = {    gf: GFHandle ¬ NILGF;    StackParse[h];    IF IO.Numeric[h, m] THEN gf ¬ LOOPHOLE[IO.StringExpToLOctal[h, m]]     ELSE gf ¬ IP.GFrame[h, m       ! IQ.InvalidFrame => CONTINUE;	IP.MultipleFrames => { IP.DumpFrameDesc[h, m, list]; CONTINUE }];    IF gf # NILGF THEN GlobalDump[h, gf] };      DumpFrame: PUBLIC PROC [h: Handle, f: LONG POINTER] = {    StackParse[h];    IF IQ.ValidateGF[h, f] THEN GlobalDump[h, f]     ELSE { h.lContext ¬ f; LocalDump[h, f]; h.stackLevel ¬ 0 }};      Caret: PROC[h: Handle] = {IO.Text["  >"L, h]};      GlobalDump: PUBLIC PROC [h: Handle, gf: GFHandle] = {    mdi: IT.MDIndex ¬ IT.MDNull;    lf: LFHandle;    IF (lf ¬ IQ.GetMainBody[h, gf]) # NIL THEN { LocalDump[h, lf]; RETURN };    IO.EOL[h];    mdi ¬ IQ.GFrameMdi[h, gf ! SymbolTable.Missing => CONTINUE];    h.iContext ¬ [global[gf]];    IF mdi = IT.MDNull THEN { WriteMsg[h, noSyms]; h.stackOptions ¬ limited }    ELSE h.stackOptions ¬ global;    IQ.DisplayGF[h, gf, NIL] };      LocalDump: PUBLIC PROC [h: Handle, f: LFHandle] = {    mdi: IT.MDIndex ¬ IT.MDNull;    IO.EOL[h];    mdi ¬ IQ.GFrameMdi[h, IP.GF[h, f] ! SymbolTable.Missing => CONTINUE];    h.iContext ¬ [local[f]];    IF mdi = IT.MDNull THEN { WriteMsg[h, noSyms]; h.stackOptions ¬ limited }    ELSE h.stackOptions ¬ local;    IF IP.CatchFrame[h, f] THEN WriteMsg[h, catch];     IQ.DisplayF[h, f] };      Jump: PROC [h: Handle, s: LONG STRING] = {    nFrames: CARDINAL;    nFrames ¬ IO.StringExpToDecimal[h, s       ! IO.InvalidNumber => { nFrames ¬ 10; IO.Text["10"L, h]; CONTINUE }];    DumpJump[h, nFrames, FALSE]};    DumpJump: PROC [h: Handle, n: INTEGER, oneFrame: BOOLEAN] = {    error: BOOLEAN ¬ FALSE;    actual: INTEGER;    frame: LFHandle;    jumps: INTEGER;    i: INTEGER ¬ 0;    WITH h.iContext SELECT FROM      local => frame ¬ IF n >= 0 THEN lf ELSE h.lContext;      ENDCASE => RETURN;    IF n >= 0 THEN jumps ¬ n    ELSE {       IF (ABS[n] > h.stackLevel) THEN { error ¬ TRUE; actual ¬ -h.stackLevel; jumps ¬ 0 }      ELSE jumps ¬ h.stackLevel + n;      h.stackLevel ¬ 0 };    FOR i IN [0..jumps) DO      frame ¬ IP.Previous[h, frame ! IP.NoPrevious => { error ¬ TRUE; actual ¬ i; EXIT }];      h.stackLevel ¬ h.stackLevel + 1;      ENDLOOP;    IF ~oneFrame AND error THEN { IO.Char[h, '(]; IO.Decimal[h, actual]; IO.Char[h, ')] };    IO.EOL[h];    IF oneFrame AND error THEN WriteMsg[h, npf] ELSE LocalDump[h, frame]};      DoSource: PROC [h: Handle, frame: LONG POINTER, load: BOOLEAN] = {    ENABLE SymbolTable.Missing => { h.stackOptions ¬ limited; BadChar[h]; CONTINUE };    SELECT h.stackOptions FROM      local => {	pc: BytePC ¬ IP.PC[h, frame];	gf: GFHandle ¬ IP.GF[h, frame];	IF IP.Exit[h, frame, pc] THEN {	  IO.Text[" at exit. "L, h];	  pc ¬ IP.Ep[h, pc, gf].start };	IP.DisplaySource[h, gf, pc, load]};      global => IP.DisplaySource[h, frame, IT.nullPC, load];      ENDCASE => BadChar[h]};    LongChar: TYPE = RECORD[u: UNSPECIFIED, pad, char: CHARACTER];     StackCommands: PUBLIC ParseProc = {    ENABLE {      NoPrompt => CONTINUE;      IO.UserAborted => {IS.Prompt[h]; CONTINUE}};    lc: LONG UNSPECIFIED;    LOOPHOLE[lc, LongChar].char ¬ c;    IS.Umbrella[h, lc, UDS];    IS.Prompt[h]};      NoPrompt: ERROR = CODE;      UDS: PROC [h: Handle, lc: LONG UNSPECIFIED] = {    char: CHARACTER = LOOPHOLE[lc, LongChar].char;    frame: LONG POINTER;    WITH h.iContext SELECT FROM      local => frame ¬ lf;      global => frame ¬ gf;      ENDCASE => { IS.Prompt[h, TRUE, TRUE]; ERROR NoPrompt };    SELECT char FROM      Ascii.SP, Ascii.DEL, Ascii.BS, Ascii.ControlW, Ascii.ControlQ => NULL;      ENDCASE => IO.Char[h, char];    SELECT String.LowerCase[char] FROM      'n =>         SELECT h.stackOptions FROM	  global => BadChar[h];	  ENDCASE => DumpJump[h, 1, TRUE];      'b =>         SELECT h.stackOptions FROM	  global => BadChar[h];	  ENDCASE => DumpJump[h, -1, TRUE];      'j =>        SELECT h.stackOptions FROM	  global => BadChar[h];	  ENDCASE => {	    IS.GetString[h, [sId: jump], Jump, n10]; 	    ERROR NoPrompt };      'v =>         SELECT h.stackOptions FROM	  local => IQ.DisplayLocalsF[h, frame];	  global => { [] ¬ IP.CheckStarted[h, frame]; IQ.DisplayLocalsGF[h, frame] };	  ENDCASE => BadChar[h];      'g =>         IF h.stackOptions = limited THEN BadChar[h]        ELSE {	  IF IQ.ValidateF[h, frame].ok THEN IQ.DisplayLocalsGF[h, IP.GF[h, frame]]          ELSE IQ.DisplayLocalsGF[h, frame]};      's => DoSource[h, frame, TRUE];      'l => DoSource[h, frame, FALSE];      'p =>         SELECT h.stackOptions FROM	  local => IQ.DisplayParametersF[h, frame];	  global => { [] ¬ IP.CheckStarted[h, frame]; IQ.DisplayParametersGF[h, frame] };	  ENDCASE => BadChar[h];      'r =>         SELECT h.stackOptions FROM	  local => IQ.DisplayResultsF[h, frame];	  global => { [] ¬ IP.CheckStarted[h, frame]; IQ.DisplayResultsGF[h, frame] };	  ENDCASE => BadChar[h];      'q, Ascii.DEL => {        IS.Prompt[h: h, resetPrompt: TRUE, resetParse: TRUE]; 	ERROR NoPrompt };      'd => PrintTime[h, frame];      Ascii.SP => { IQ.CallInterpreter[h]; ERROR NoPrompt };      '- => { IS.GetComment[h]; ERROR NoPrompt };      '? => ListOptions[h] ;      ENDCASE => BadChar[h] };        PrintTime: PROC[h: Handle, frame: LONG POINTER] = {    string: LONG STRING ¬ [24];    gf: GFHandle = IF IQ.ValidateF[h, frame].ok THEN IP.GF[h, frame] ELSE frame;    time: LONG CARDINAL ¬ AMUseful.VersionStamp[h.world, gf].time;    String.AppendString[string, "  "L];    Time.Append[string, Time.Unpack[[time]]];    IO.Line[h, string];    BEGIN -- see if there is a .symbols file      ENABLE AMLoadstate.Error => CONTINUE;      bcd: BcdOps.BcdBase;      index: AMLoadstate.Index;      cgfi: NATURAL;      mth: BcdOps.MTHandle;      sgh: BcdOps.SGHandle;      loadstate: AMLoadstate.Handle = WorldVMOps.GetLoadstate[h.world];      [cgfi, index] ¬ AMLoadstate.MapRealToConfig[loadstate, WorldVMOps.GFshort[h.world, gf]];      bcd ¬ AMLoadstate.AcquireBcd[loadstate, index];      mth ¬ BcdOpsExtras.MthFromGfi[bcd, cgfi];      sgh ¬ @BcdOpsExtras.SGBaseFromBcd[bcd][mth.sseg];      SELECT sgh.file FROM        BcdDefs.FTNull, BcdDefs.FTSelf, mth.file => NULL;	ENDCASE => {	  fth: BcdOps.FTHandle = @BcdOpsExtras.FTBaseFromBcd[bcd][sgh.file];	  names: BcdOps.NameString ¬ BcdOpsExtras.NameStringFromBcd[bcd];	  ss: String.SubStringDescriptor ¬ [@names.string, fth.name, names.size[fth.name]];	  IO.Text["  ("L, h];	  IO.SubString[h, @ss];	  IO.Text[" of "L, h];	  string.length ¬ 0;	  time ¬ fth.version.time;	  Time.Append[string, Time.Unpack[[time]]];	  String.AppendChar[string, ')];	  IO.Line[h, string] };      END };      BadChar: PROC[h: Handle] = {IO.Char[h, '?]};      ListOptions: PROC[h: Handle] = {    WriteMsg[h, options];    IF h.stackOptions = limited THEN WriteMsg[h, lso]    ELSE { WriteMsg[h, gso]; IF h.stackOptions = local THEN WriteMsg[h, dso] };    IO.EOL[h]};        }.
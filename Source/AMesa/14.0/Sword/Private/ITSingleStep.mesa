-- File: ITSingleStep.mesa - last edit:-- Litman              21-Apr-87 19:19:06-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.DIRECTORY  AMEvents USING [LFHandle, ProvokeProcessEvent],  AMModelLocation USING [BytePC, GFHandle, PcOnStatementBoundary],  AMProcess USING [AddProcessToList, Freeze, Thaw],  IM USING [],  IP USING [GF, PC],  IT USING [BytePC, GFHandle, Handle, LFHandle, Process],  Process USING [SetPriority],  ProcessOperations USING [HandleFromIndex],  ProcessPriorities USING [priorityClientHigh],  PSB USING [PDA, ProcessStateBlock],  WorldVMOps USING [Process, ProcessShort];ITSingleStep: MONITOR   IMPORTS AMEvents, AMModelLocation, AMProcess, IP, Process, ProcessOperations, WorldVMOps  EXPORTS IM = {  Hurdle: PUBLIC PROC[h: IT.Handle] = {};    SingleStep: PUBLIC PROC[h: IT.Handle] = {    «IF h.world = WorldVM.LocalWorld[] THEN {      Process.Detach[FORK WatchMyStep[h, WorldVMOps.ProcessLong[h.ESV.swapData.process]]];      h.stackLevel ¬ 1000;      [] ¬ UserInput.StuffCharacter[h.fileSW, Ascii.NUL]; -- proceed client -- }»};       WatchMyStep: ENTRY PROC[h: IT.Handle, process: IT.Process] = {    timeout: CONDITION ¬ [timeout: 1];    frame: IT.LFHandle;    psbHandle: LONG POINTER TO PSB.ProcessStateBlock = @PSB.PDA[ProcessOperations.HandleFromIndex[WorldVMOps.ProcessShort[process]]];    Process.SetPriority[ProcessPriorities.priorityClientHigh];    DO WAIT timeout;      IF ~(psbHandle.link.permanent OR psbHandle.link.preempted)      THEN frame ¬ psbHandle.context.frame      ELSE frame ¬ PSB.PDA[psbHandle.context.state].frame;      IF PcOnStatementBoundary[h, frame] THEN {        AMProcess.Freeze[processes: AMProcess.AddProcessToList[NIL, [h.world, process]]];        [] ¬ AMEvents.ProvokeProcessEvent[frame: frame, p: [h.world, process], msg: "step"L];	AMProcess.Thaw[processes: AMProcess.AddProcessToList[NIL, [h.world, process]]];	EXIT };       ENDLOOP};        PcOnStatementBoundary: PROC[h: IT.Handle, frame: IT.LFHandle] RETURNS[BOOLEAN] = {    pc: IT.BytePC = IP.PC[h, frame];    gf: IT.GFHandle = IP.GF[h, frame];    RETURN[AMModelLocation.PcOnStatementBoundary[world: h.world, gf: gf, pc: pc]]};  }..  
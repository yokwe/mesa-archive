-- File: ITFramesCold.mesa - last edit:-- Litman               4-May-87 12:34:28-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.DIRECTORY  AMLoadstate USING [Error, AcquireBcd, Index],  AMUseful USING [EnumerateModules, MapRealToConfig],  Ascii USING [SP],  BcdDefs USING [MTIndex],  BcdDefsExtras USING [OldMesaModule],  BcdOps USING [BcdBase],  BcdOpsExtras USING [MthFromMti],  CatchFormat USING [CatchFrame],  ComData USING [idABORTED, idERROR, idUNWIND],  IC USING [GFFromControlLink],  IO USING [AllocFob, Char, Display, EOL, Text],  IP USING [CBti, CbtSon, CodeLinks, Complete, ContextList, Copied, Entry, Exit, Fail, FreeContextList, GF, InOut, Name, NoPrevious, PC, Previous, Signal, Started, StateCtx, TypeForSe, XferCtx],  IQ USING [GFrameMdi, InvalidFrame, Stopping, ValidateF, ValidateGF],  IS USING [FieldCtx, GetGlobal, HashVal, LongNum, Num, WriteError],  IT USING [BytePC, ControlLink, CtxLink, Foo, FrameDesc, GFHandle, Handle, LFHandle, MaxModuleString, nullPC, SignalDesc],  PrincOpsExtras USING [SignalDesc, nullSignal],  SDDefs USING [SD, sSignal],  SymbolOps USING [FirstCtxSe],  Symbols USING [CBTIndex, CBTNull, ContextLevel, CTXIndex, CTXNull, HTNull, IncludedCTXIndex, ISENull, lG, lL, MDIndex, RecordSENull, SEIndex],  SymbolTable USING [Handle, Missing],  WorldVMOps USING [AddressFault, CopyRead, GetLoadstate, LFlong, Long, Read];  ITFramesCold: PROGRAM  IMPORTS AMUseful, AMLoadstate, BcdOpsExtras, com: ComData, IC, IO, IP, IQ, IS, SymbolOps, SymbolTable, WorldVMOps  EXPORTS IP, IQ = {  OPEN IT;    EnumerateGF: PUBLIC PROC [h: Handle, proc: PROC [GFHandle] RETURNS [BOOLEAN]] RETURNS [gf: GFHandle] = {    RETURN[AMUseful.EnumerateModules[h.world, proc]]};      CatchFrame: PUBLIC PROCEDURE [h: Handle, f: LFHandle] RETURNS [BOOLEAN] = {    RETURN[CatchFrameParent[h, f] # NIL]};      GetSignallerGF: PROCEDURE[h: Handle] RETURNS[GFHandle] = {    cl: ControlLink;    WorldVMOps.CopyRead[world: h.world,      from: WorldVMOps.Long[h.world, @SDDefs.SD[SDDefs.sSignal]], to: @cl, nwords: SIZE[ControlLink]       ! WorldVMOps.AddressFault => GOTO bad];    RETURN[IC.GFFromControlLink[h, cl]];    EXITS bad => RETURN[NIL]};  CatchFrameParent: PROC [h: Handle, f: LFHandle] RETURNS [L0: LFHandle] = {    nextGf: GFHandle;    next: LFHandle ¬ NIL;    next ¬ IP.Previous[h, f ! ANY => CONTINUE];    IF next = NIL THEN RETURN[NIL];    nextGf ¬ IP.GF[h, next];    IF nextGf # GetSignallerGF[h] THEN RETURN[NIL];    L0 ¬ WorldVMOps.LFlong[h.world, WorldVMOps.Read[h.world, f]];    IF ~IQ.ValidateF[h, L0].ok THEN RETURN[NIL];    IF ~IQ.ValidateF[h, next].ok OR IP.GF[h, f] # IP.GF[h, L0] THEN RETURN[NIL] };      InMainBody: PUBLIC PROCEDURE [h: Handle, f: LFHandle] RETURNS [in: BOOLEAN] = {    cbti: Symbols.CBTIndex ¬ IP.CBti[h, IP.PC[h, f], IP.GF[h, f]];    IF cbti = Symbols.CBTNull THEN RETURN [FALSE];    in ¬ h.ctxb[h.bb[cbti].localCtx].level = Symbols.lG };      DisplayF: PUBLIC PROC [h: Handle, f: LFHandle] = {    gf: GFHandle = IP.GF[h, f];    pc: BytePC = IP.PC[h, f];    cbti: Symbols.CBTIndex = IP.CBti[h, pc, gf];    IF cbti # Symbols.CBTNull THEN { IS.HashVal[h, h.bb[cbti].id]; IO.Text[", "L, h] };    IO.Text["L: "L, h]; IS.LongNum[h, f, [pointer[]]];     IO.Text[", PC: "L, h]; IS.Num[h, pc, [card[]]];    DisplayInMsg[h, gf, NIL]};      FCbti: PROC [h: Handle, f: LFHandle] RETURNS [Symbols.CBTIndex] = {    RETURN[IP.CBti[h, IP.PC[h, f], IP.GF[h, f]]] };      DisplayParametersF: PUBLIC PROC [h: Handle, f: LFHandle] = {    FrameFoo[h, f, in, IP.Entry[h, f, nullPC], FCbti[h, f]] };      DisplayResultsF: PUBLIC PROC [h: Handle, f: LFHandle] = {    FrameFoo[h, f, out, IP.Exit[h, f, nullPC], FCbti[h, f]] };      SignalSeiFromCatchFrameHandle: PUBLIC PROCEDURE [h: Handle, cf: LONG POINTER TO CatchFormat.CatchFrame] RETURNS [sei: Symbols.SEIndex] = {    sig: SignalDesc;    IF cf = NIL THEN RETURN[Symbols.ISENull];    WorldVMOps.CopyRead[world: h.world, from: @cf.signal, to: @sig, nwords: SIZE[SignalDesc]];    IF (sei ¬ PreDeclared[h, sig, FALSE].sei) = Symbols.ISENull THEN       IF (sei ¬ IP.Signal[h, sig]) = Symbols.ISENull THEN 	[] ¬ IQ.GFrameMdi[h, IC.GFFromControlLink[h, LOOPHOLE[sig]] 	  ! SymbolTable.Missing => {	    mod: LONG STRING ¬ [IT.MaxModuleString]; 	    IP.Name[h, mod, IC.GFFromControlLink[h, LOOPHOLE[sig]]];	    ERROR IP.Fail[mod]}]};	    PreDeclared: PUBLIC --IQ-- PROCEDURE [h: Handle, sig: SignalDesc, print: BOOLEAN]     RETURNS [found: BOOLEAN ¬ FALSE, sei: Symbols.SEIndex ¬ Symbols.ISENull] = {    OPEN psig: LOOPHOLE[sig, PrincOpsExtras.SignalDesc];    IF psig.gf = NIL OR psig.gf = LOOPHOLE[-1] THEN       SELECT psig.index FROM	-1 => { found ¬ TRUE; sei ¬ com.idERROR; IF print THEN IO.Text["ERROR"L, h] };	1 => { found ¬ TRUE; sei ¬ com.idUNWIND; IF print THEN IO.Text["UNWIND"L, h] };	2 => { found ¬ TRUE; sei ¬ com.idABORTED; IF print THEN IO.Text["ABORTED"L, h] };	ENDCASE;    IF psig = PrincOpsExtras.nullSignal THEN {      found ¬ TRUE; IF print THEN IO.Text["NIL"L, h]; }    };      FrameFoo: PROC [h: Handle, p: LONG POINTER, io: IP.InOut, inState: BOOLEAN, cbti: Symbols.CBTIndex] = {    f: Foo;    sei: Symbols.SEIndex;    IF cbti = Symbols.CBTNull THEN RETURN;    sei ¬ IF h.bb[cbti].nesting = Catch THEN SignalSeiFromCatchFrameHandle[h, p] ELSE h.bb[cbti].ioType;    f ¬ IF inState --AND h.sv # NIL-- THEN IP.StateCtx[h, sei, io]     ELSE IP.XferCtx[h, sei, p, io]; -- A LIE!!! may have SV or be an error    IF f = NIL OR f.tsei = Symbols.RecordSENull THEN RETURN;    f.indent ¬ 2;    f.xfer ¬ TRUE;    f.displayFieldsOfRecordsAs ¬ variables;    IO.EOL[h];    WITH h.seb[IP.TypeForSe[h, f.tsei]] SELECT FROM      record => IF h.seb[SymbolOps.FirstCtxSe[h.sym, fieldCtx]].hash = Symbols.HTNull THEN IO.Text["  (anon) = "L, h];      ENDCASE;    IO.Display[h, f]};      SetupLocalFoo: PROC [h: Handle, lf: LFHandle] RETURNS [f: Foo] = {    f ¬ IO.AllocFob[h];    f.addr.base ¬ lf;    f.indent ¬ 2;     f.xfer ¬ TRUE;    f.there ¬ TRUE;     f.displayFieldsOfRecordsAs ¬ variables};      SetupGlobalFoo: PROC[h: Handle, gf: GFHandle] RETURNS [f: Foo] = {    f ¬ IO.AllocFob[h];    f.addr.base ¬ gf;    f.indent ¬ 2;     f.xfer ¬ TRUE;    f.there ¬ TRUE;     f.displayFieldsOfRecordsAs ¬ variables};      DisplayLocalsF: PUBLIC PROC[h: Handle, lf: LFHandle] = {    f: Foo;    gf: GFHandle = IP.GF[h, lf];    pc: BytePC = IP.PC[h, lf];    cbti: Symbols.CBTIndex = IP.CBti[h, pc, gf];    IF cbti = Symbols.CBTNull THEN RETURN;    DisplayParametersF[h, lf];    DisplayResultsF[h, lf];    f ¬ SetupLocalFoo[h, lf];    IF IP.CbtSon[h, cbti] THEN {      list: CtxLink ¬ IP.ContextList[h, IP.PC[h, lf], gf, print];      IF list = NIL THEN RETURN;      DumpContextList[h, f, IQ.GFrameMdi[h, gf], list         ! UNWIND => IP.FreeContextList[h, list]];      IP.FreeContextList[h, list]}    ELSE {      ictx: Symbols.IncludedCTXIndex;      level: Symbols.ContextLevel ¬ Symbols.lG;      ictx ¬ LOOPHOLE[h.bb[cbti].localCtx];      IF ictx # Symbols.CTXNull THEN level ¬ h.ctxb[ictx].level;      IF level > Symbols.lG THEN DumpOne[h, f, ictx]}};      DumpOne: PROC [h: Handle, f: Foo, ictx: Symbols.CTXIndex] = {    IF ictx = Symbols.CTXNull THEN RETURN;    IP.Complete[h, ictx];    IO.EOL[h];    IS.FieldCtx[h, f, ictx, 0] };      DumpContextList: PROC [h: Handle, f: Foo, mdi: Symbols.MDIndex, list: CtxLink] = {    level: Symbols.ContextLevel ¬ MAX[Symbols.lL, GetLevel[h, list]];    FOR i: CtxLink ¬ list, i.link UNTIL i = NIL DO      level ¬ MAX[level, GetLevel[h, i]];      ENDLOOP;    FOR i: CtxLink ¬ list, i.link UNTIL i = NIL DO      f.indent ¬ i.indent;      IF GetLevel[h, i] < level THEN LOOP;      WITH i SELECT FROM        context => DumpOne[h, f, ictx];	empty => LOOP;	ENDCASE;      ENDLOOP };      GetLevel: PROC [h: Handle, i: CtxLink] RETURNS [Symbols.ContextLevel] = {    RETURN[WITH i SELECT FROM context => h.ctxb[ictx].level, empty => level, ENDCASE => ERROR]};  -- global frames    GFCbti: PROC [h: Handle, gf: GFHandle] RETURNS [Symbols.CBTIndex] = {    RETURN[IP.CBti[h, nullPC, gf]]};      DisplayParametersGF: PUBLIC PROC [h: Handle, gf: GFHandle] = {    lf: LFHandle ¬ GetMainBody[h, gf];    IF lf # NIL THEN DisplayParametersF[h, lf]    ELSE FrameFoo[h, gf, in, FALSE, GFCbti[h, gf]] };      DisplayResultsGF: PUBLIC PROC [h: Handle, gf: GFHandle] = {    lf: LFHandle ¬ GetMainBody[h, gf];    IF lf # NIL THEN DisplayResultsF[h, lf]    ELSE FrameFoo[h, gf, out, FALSE, GFCbti[h, gf]] };      DisplayLocalsGF: PUBLIC PROC [h: Handle, gf: GFHandle] = {    lf: LFHandle ¬ GetMainBody[h, gf];    cbti: Symbols.CBTIndex ¬ GFCbti[h, gf];    ictx: Symbols.IncludedCTXIndex;    FrameFoo[h, gf, in, FALSE, cbti];    FrameFoo[h, gf, out, FALSE, cbti];    ictx ¬ LOOPHOLE[h.bb[cbti].localCtx];    DumpOne[h, SetupGlobalFoo[h, gf], ictx];    IF lf # NIL THEN DisplayLocalsF[h, lf] };      DisplayInMsg: PUBLIC PROC [h: Handle, gf: GFHandle, delim: STRING] = {    IO.Text[" (in "L, h];    DisplayGF[h, gf, delim       ! IQ.InvalidFrame => {	  IO.Char[h, ' ]; IS.LongNum[h, f, [pointer[]]]; 	  IS.WriteError[h, nGframe, FALSE];	  CONTINUE}];    IO.Char[h, ')]};      DisplayGF: PUBLIC PROC [h: Handle, gf: GFHandle, delim: STRING] = {    mod: STRING ¬ [MaxModuleString];    IP.Name[h, mod, gf ! AMLoadstate.Error, IQ.InvalidFrame => CONTINUE];    IF mod.length # 0 THEN {      IF delim # NIL THEN { IO.Text[delim,h]; IO.Char[h,' ] };      IO.Text[mod,h]; IO.Text[", "L,h] };    IO.Text["G: "L, h]; PrintFrame[h, gf] };      printLinks: BOOLEAN ¬ FALSE;  printOld: BOOLEAN ¬ FALSE;      PrintFrame: PROC [h: Handle, gf: GFHandle] = {    IS.LongNum[h, gf, [pointer[]]];    IF IP.Copied[h, gf] THEN IO.Char[h, '*];    IF ~IP.Started[h, gf] THEN IO.Char[h, '~];    IF printLinks AND IP.CodeLinks[h, gf] THEN IO.Char[h, '"];    IF printOld AND OldModule[h, gf] THEN IO.Char[h, '-]; };      OldModule: PROC[h: Handle, gf: GFHandle] RETURNS[BOOLEAN] = {    ENABLE ANY => GOTO Error;    index: AMLoadstate.Index;    mti: BcdDefs.MTIndex;    bcd: BcdOps.BcdBase;    [index, mti] ¬ AMUseful.MapRealToConfig[h.world, gf];    bcd ¬ AMLoadstate.AcquireBcd[WorldVMOps.GetLoadstate[h.world], index];    RETURN[BcdOpsExtras.MthFromMti[bcd, mti].spare = BcdDefsExtras.OldMesaModule];    EXITS Error => RETURN[FALSE] };      GetMainBody: PUBLIC PROC [h: Handle, gf: GFHandle] RETURNS [f: LFHandle] = {    IF ~IQ.ValidateGF[h, gf] OR ~IP.Started[h, gf] THEN RETURN[NIL];    IF IQ.Stopping[h, gf ! SymbolTable.Missing => GOTO null] THEN RETURN[WorldVMOps.LFlong[h.world, WorldVMOps.Read[h.world, gf]]];    FOR f ¬ h.lContext, IP.Previous[h, f ! IP.NoPrevious => GOTO null] UNTIL f = NIL DO      IF IP.GF[h, f] = gf AND InMainBody[h, f] THEN RETURN;      ENDLOOP;    EXITS null => RETURN[NIL]};      DisplayGFT: PUBLIC PROCEDURE[h: Handle] = {    module: LONG STRING ¬ [MaxModuleString];    GFWrite: PROCEDURE[frame: GFHandle] RETURNS [BOOLEAN] = {       ENABLE IQ.InvalidFrame, WorldVMOps.AddressFault => GOTO InvalidFrame;      IF frame = NIL THEN RETURN[FALSE];      module.length ¬ 0;      IP.Name[h, module, frame];      IO.Text[module, h]; IO.Text[", G:"L, h]; PrintFrame[h, frame]; IO.EOL[h];      RETURN[FALSE];      EXITS InvalidFrame => {        IO.Text["!Invalid frame, G:"L, h]; IS.LongNum[h, frame, [pointer[]]]; IO.EOL[h];	RETURN[FALSE] }};    IO.EOL[h];    [] ¬ EnumerateGF[h, GFWrite]};      DumpFrameDesc: PUBLIC PROC [h: Handle, mod: LONG STRING, list: FrameDesc] = {    IO.EOL[h]; IO.Text["! "L, h]; IO.Text[mod, h];     IO.Text[" has frames at"L, h];    FOR i: CARDINAL IN [0..list.LENGTH) DO      IO.Char[h, Ascii.SP]; IS.LongNum[h, list[i], [pointer[]]];      ENDLOOP;    IO.EOL[h];    IO.Text["Use SEt Octal context or Display Frame command."L, h]};        Current: PUBLIC PROC[h: Handle] RETURNS [GFHandle] = {RETURN[IS.GetGlobal[h]]};    }.
-- File: ITPcCold.mesa - last edit:-- Litman               4-May-87 12:42:09-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.DIRECTORY  AMLoadstate USING [GFHandle, Handle, MapRealToEnh],  BcdOps USING [ENHandle],  CatchFormat USING [CatchEV, CatchEVHandle, CatchIndex, CatchNull],  Copier USING [CopyExternalBody, Handle, Outer],  Environment USING [bitsPerWord],  IC USING [GFFromControlLink, PCFromControlLink],  IO USING [FreeNode, Node],  IP USING [Bti, CacheCBti, CBti, CodeBase, Fail, FindPC, FindUserCbti, GetPc, MapCtx,  Reason, SignalSeiFromCatchFrameHandle, TypeForSe],  IQ USING [GFrameMdi],  IT USING [BTIndex, BytePC, CBTIndex, ControlLink, CtxItem, CtxLink, EVIndex, EVNull, EXOI, GFHandle, Handle, LFHandle, MDIndex, PcCacheLimit, PcItem, PcItemNull, PcItemObject],  PrincOps USING [BytePC, MaxParamsInStack, PrefixHandle],  SymbolOps USING [EnumerateBodies, Handle, ParentBti, SiblingBti, SonBti],  Symbols USING [Base, BodyRecord, BTIndex, BTNull, CatchIndex, CBTIndex, CBTNull, ContextLevel, CSEIndex, CSENull, CTXIndex, CTXNull, ISEIndex, ISENull, MDIndex, RecordSEIndex, RecordSENull, RootBti],  SymbolTable USING [Handle],  WorldVMOps USING [GetLoadstate, GFshort, Read];ITPcCold: PROGRAM  IMPORTS AMLoadstate, Copier, IC, IO, IP, IQ, SymbolOps, WorldVMOps  EXPORTS IP = {    NotInAnyProcedure: PUBLIC SIGNAL = CODE;  CantCacheInlines: ERROR = CODE;  NotCallable: ERROR = CODE;  NoBti: ERROR = CODE;  BadReason: ERROR = CODE;  FirstFree: PROCEDURE [h: IT.Handle] RETURNS [i: IT.PcItem] = {    IF (i ¬ h.freePcItem) # IT.PcItemNull THEN h.freePcItem ¬ h.pcCache[i].link ELSE ERROR };  ResetPCache: PUBLIC PROCEDURE[h: IT.Handle] = {    h.freePcItem ¬ h.headPcItem ¬ IT.PcItemNull;    IF h.pcCache # NIL THEN       FOR i: IT.PcItem ¬ FIRST[IT.PcItem], i+SIZE[IT.PcItemObject] UNTIL LOOPHOLE[i, CARDINAL] >= IT.PcCacheLimit DO	h.pcCache[i].link ¬ h.freePcItem; h.freePcItem ¬ i;	ENDLOOP };    GetEp: PROCEDURE [h: IT.Handle, gf: IT.GFHandle, pc: IT.BytePC] RETURNS [ep: IT.EVIndex, start: IT.BytePC, catch: CatchFormat.CatchIndex] = {    diff: CARDINAL ¬ LAST[CARDINAL];    lp: PrincOps.PrefixHandle = IP.CodeBase[h, gf];    enh: BcdOps.ENHandle = AMLoadstate.MapRealToEnh[WorldVMOps.GetLoadstate[h.world], WorldVMOps.GFshort[h.world, gf]];    ev: CatchFormat.CatchEVHandle;    catchCodeBytePc: CARDINAL = WorldVMOps.Read[h.world, @lp.header.catchCode];    -- is pc in a procedure?    FOR i: CARDINAL IN [0..enh.nEntries) DO      cstart: CARDINAL = enh.initialPC[i];      IF cstart > pc OR pc - cstart > diff THEN LOOP;      diff ¬ pc - cstart;      ep ¬ i; start ¬ cstart;      ENDLOOP;    IF (catchCodeBytePc = 0) OR (catchCodeBytePc > pc) OR (pc - catchCodeBytePc > diff) THEN      IF diff < LAST[CARDINAL] THEN RETURN[ep, start, CatchFormat.CatchNull]      ELSE SIGNAL NotInAnyProcedure;    -- is pc in a CatchPhrase?    ep ¬ IT.EVNull;    catch ¬ CatchFormat.CatchNull;    ev ¬ @lp[LOOPHOLE[catchCodeBytePc/2, CatchFormat.CatchEV]];    FOR c: CatchFormat.CatchIndex IN [0..WorldVMOps.Read[h.world, ev]) DO      cstart: CARDINAL = WorldVMOps.Read[h.world, @ev[c]];      IF cstart > pc OR pc - cstart > diff THEN LOOP;      diff ¬ pc - cstart;      catch ¬ c; start ¬ cstart;      ENDLOOP;    IF diff = LAST[CARDINAL] THEN SIGNAL NotInAnyProcedure };      GetPcForCatch: PROC[h: IT.Handle, gf: IT.GFHandle, catch: CatchFormat.CatchIndex] RETURNS[cstart: IT.BytePC] = {    lp: PrincOps.PrefixHandle = IP.CodeBase[h, gf];    catchCodeBytePc: CARDINAL = WorldVMOps.Read[h.world, @lp.header.catchCode];    ev: CatchFormat.CatchEVHandle = @lp[LOOPHOLE[catchCodeBytePc/2, CatchFormat.CatchEV]];    cstart ¬ WorldVMOps.Read[h.world, @ev[catch]]};  EpCold: PUBLIC PROCEDURE [h: IT.Handle, pc: IT.BytePC, gf: IT.GFHandle] RETURNS [ep: IT.EVIndex, start: IT.BytePC] = {    ENABLE NoBti => { SIGNAL NotInAnyProcedure; CONTINUE };    catch: CatchFormat.CatchIndex;    [ep, start, catch] ¬ GetEp[h, gf, pc];    CheckPc[h, pc, ConvertEp[h, gf, IQ.GFrameMdi[h, gf], ep, start, catch]]};  CheckPc: PROCEDURE [h: IT.Handle, pc: IT.BytePC, i: IT.PcItem] = {    IF pc < h.pcCache[i].start OR pc > h.pcCache[i].end THEN SIGNAL NotInAnyProcedure };  UserCBti: PUBLIC PROCEDURE [h: IT.Handle, pc: IT.BytePC, gf: IT.GFHandle] RETURNS [IT.CBTIndex] = {    item: IT.PcItem = IP.FindPC[h, pc, gf];    IF item = IT.PcItemNull THEN RETURN[Symbols.CBTNull] ELSE RETURN[h.pcCache[item].userCbti] };  CacheCBtiCold: PUBLIC PROCEDURE [h: IT.Handle, mdi: IT.MDIndex, gf: IT.GFHandle, cbti: IT.CBTIndex] RETURNS [dCbti: IT.CBTIndex] = {    initialPc: IT.BytePC;    ep: IT.EVIndex ¬ IT.EVNull;    i: IT.PcItem;    catch: BOOLEAN ¬ FALSE;    FillInEp: PROCEDURE [base: SymbolTable.Handle] = {      body: Callable Symbols.BodyRecord = base.bb[cbti];      ep ¬ body.entryIndex;      WITH body SELECT FROM         Catch => { catch ¬ TRUE; ep ¬ index };	ENDCASE };    Copier.Outer[h.sym, mdi, FillInEp];    initialPc ¬ IF catch THEN GetPcForCatch[h, gf, ep] ELSE IP.GetPc[h, gf, ep];    i ¬ CacheIt[h, cbti, ep, initialPc, gf, mdi];    dCbti ¬ h.pcCache[i].dCbti };  CacheIt: PROCEDURE [h: IT.Handle, cbti: IT.CBTIndex, ep: IT.EVIndex, start: IT.BytePC, gf: IT.GFHandle, mdi: IT.MDIndex] RETURNS [i: IT.PcItem] = {    CheckInline: PROCEDURE [base: SymbolTable.Handle] = { IF base.bb[cbti].inline THEN ERROR CantCacheInlines };    FillInFromTable: PROCEDURE [base: SymbolTable.Handle] = {      body: Callable Symbols.BodyRecord = base.bb[cbti];      h.pcCache[i].hasSons ¬ body.firstSon # Symbols.BTNull;      WITH body.info SELECT FROM	External => h.pcCache[i].end ¬ (start+bytes-1);	ENDCASE => ERROR;      WITH body SELECT FROM	Inner => h.pcCache[i].inner ¬ TRUE;	ENDCASE };    Copier.Outer[h.sym, mdi, CheckInline];    i ¬ FirstFree[h];    h.pcCache[i] ¬ [link: h.headPcItem, ep: ep, gf: gf, start: start, userCbti: cbti, end:, dCbti:, hasSons:, inner: FALSE];    h.headPcItem ¬ i;    Copier.Outer[h.sym, mdi, FillInFromTable];    h.pcCache[i].dCbti ¬ Copier.CopyExternalBody[h.sym, mdi, cbti] };  FindBtiWithEp: PROCEDURE [h: IT.Handle, mdi: IT.MDIndex, ep: IT.EVIndex, catch: CatchFormat.CatchIndex] RETURNS [bti: IT.CBTIndex] = {    isCatch: BOOLEAN = catch # CatchFormat.CatchNull;    Find: PROCEDURE [base: SymbolTable.Handle] = {      SearchForEp: PROCEDURE [h: SymbolTable.Handle, bti: IT.BTIndex] RETURNS [BOOLEAN] = {	WITH body: base.bb[bti] SELECT FROM	  Callable => {	    IF body.inline THEN RETURN [FALSE];	    IF isCatch THEN { 	      WITH body SELECT FROM	        Catch => RETURN[catch = index];		ENDCASE => RETURN[FALSE] } 	    ELSE RETURN[ep = body.entryIndex] };	  ENDCASE => RETURN[FALSE] }; -- SearchForEp	bti ¬ LOOPHOLE[SymbolOps.EnumerateBodies[base, Symbols.RootBti, SearchForEp]] }; --Find    bti ¬ Symbols.CBTNull;    Copier.Outer[h.sym, mdi, Find];    IF bti = Symbols.CBTNull THEN ERROR NoBti };  ConvertEp: PROCEDURE [h: IT.Handle, gf: IT.GFHandle, mdi: IT.MDIndex, ep: IT.EVIndex, start: IT.BytePC, catch: CatchFormat.CatchIndex] RETURNS [i: IT.PcItem] = {    bti: IT.CBTIndex ¬ FindBtiWithEp[h, mdi, ep, catch];    i ¬ CacheIt[h, bti, ep, start, gf, mdi] };  LinkToIsei: PUBLIC PROCEDURE [h: IT.Handle, cl: IT.ControlLink] RETURNS [Symbols.ISEIndex] = {    cbti: IT.CBTIndex = IP.CBti[h, IC.PCFromControlLink[h, cl], IC.GFFromControlLink[h, cl]];    IF cbti = Symbols.CBTNull THEN RETURN[Symbols.ISENull];    RETURN[h.bb[cbti].id] };  ParentCbtiCold: PUBLIC PROCEDURE [h: IT.Handle, pc: IT.BytePC, gf: IT.GFHandle, mdi: IT.MDIndex] RETURNS [i: IT.PcItem ¬ IT.PcItemNull] = {    ENABLE NoBti => {SIGNAL NotInAnyProcedure; CONTINUE};    ep: IT.EVIndex;    start: IT.BytePC;    catch: CatchFormat.CatchIndex;    [ep, start, catch] ¬ GetEp[h, gf, pc];    i ¬ ConvertEp[h, gf, mdi, ep, start, catch];    CheckPc[h, pc, i]};  ConvertCbti: PUBLIC PROCEDURE [h: IT.Handle, lastBti: IT.BTIndex, pc, start: IT.BytePC, base: SymbolTable.Handle] RETURNS [bti: IT.BTIndex] = {    bodyStart: IT.BytePC;    WITH body: base.bb[lastBti] SELECT FROM      Callable => IF body.nesting # Catch THEN start ¬ start+1; -- fudge for the fsi byte      ENDCASE;    bti ¬ lastBti;    DO      FOR lastBti ¬ SymbolOps.SonBti[base, bti], SymbolOps.SiblingBti[base, lastBti] UNTIL lastBti = Symbols.BTNull DO	WITH body: base.bb[lastBti] SELECT FROM	  Callable => LOOP;	  Other => {	    bodyStart ¬ start + body.relOffset;	    WITH body.info SELECT FROM	      External => IF pc IN [bodyStart..bodyStart+bytes) THEN { bti ¬ lastBti; EXIT };	      ENDCASE };	  ENDCASE;	REPEAT FINISHED => RETURN	ENDLOOP;      ENDLOOP };        ContextList: PUBLIC PROCEDURE [h: IT.Handle, pc: IT.BytePC, gf: IT.GFHandle, reason: IP.Reason, exoi: IT.EXOI ¬ in, lf: IT.LFHandle ¬ NIL] RETURNS [IT.CtxLink] = {    bti: IT.BTIndex ¬ IP.Bti[h, pc, gf];    list: IT.CtxLink ¬ NIL;    mdi: Symbols.MDIndex ¬ IQ.GFrameMdi[h, gf];    Base: PROCEDURE [iBase: SymbolTable.Handle] = {      list ¬ Walk[h, bti, iBase, reason, exoi, gf, signalCsei]};    signalCsei: Symbols.CSEIndex ¬ CollectCbtis[h, mdi, bti, gf, lf];    Copier.Outer[h.sym, mdi, Base];    FOR i: IT.CtxLink ¬ list, i.link UNTIL i = NIL DO      IF ~i.mapped THEN i.body ¬ context[IP.MapCtx[h, mdi, WITH i SELECT FROM context => ictx, ENDCASE => ERROR]];      ENDLOOP;    SELECT reason FROM      print => RETURN[list];      search => RETURN[Reverse[list]];      ENDCASE => ERROR BadReason };  CollectCbtis: PROCEDURE [h: IT.Handle, mdi: Symbols.MDIndex, bti: IT.BTIndex, argGf: IT.GFHandle, lf: IT.LFHandle] RETURNS[signalCsei: Symbols.CSEIndex ¬ Symbols.CSENull] = {    list: ARRAY Symbols.ContextLevel OF IT.CBTIndex ¬ ALL[Symbols.CBTNull];    length: Symbols.ContextLevel ¬ 0;    Collect: PROCEDURE [iBase: SymbolTable.Handle] = {      FOR ibti: IT.BTIndex ¬ bti, SymbolOps.ParentBti[iBase, ibti] UNTIL ibti = Symbols.BTNull DO	WITH iBase.bb[ibti] SELECT FROM	  Callable => { list[length] ¬ LOOPHOLE[ibti]; length ¬ length + 1 };	  ENDCASE;	IF bti = Symbols.RootBti THEN EXIT;	ENDLOOP };    Copier.Outer[h.sym, mdi, Collect];    FOR i: Symbols.ContextLevel IN [0..length) DO      cbti: IT.CBTIndex = IP.CacheCBti[h, mdi, argGf, list[i]];      IF cbti # Symbols.CBTNull AND h.bb[cbti].ioType = Symbols.CSENull THEN signalCsei ¬ IP.TypeForSe[h, IP.SignalSeiFromCatchFrameHandle[h, lf ! IP.Fail => CONTINUE]];      ENDLOOP };  Walk: PROCEDURE [h: IT.Handle, bti: Symbols.BTIndex, base: SymbolTable.Handle, why: IP.Reason, ex: IT.EXOI, argGf: IT.GFHandle, signalCsei: Symbols.CSEIndex] RETURNS [list: IT.CtxLink] = {    ibti: Symbols.BTIndex;    indent: CARDINAL ¬ 0;    list ¬ NIL;    FOR ibti ¬ bti, SymbolOps.ParentBti[base, ibti] UNTIL ibti = Symbols.BTNull DO      indent ¬ indent + 2;      WITH base.bb[ibti] SELECT FROM	Callable => IF why = print THEN EXIT;	ENDCASE;      IF ibti = Symbols.RootBti THEN EXIT;      ENDLOOP;    FOR ibti ¬ bti, SymbolOps.ParentBti[base, ibti] UNTIL ibti = Symbols.BTNull DO      WITH body: base.bb[ibti] SELECT FROM	Callable => {	  list ¬ AddToList[h, list, body.localCtx, indent, body.level];	  IF why = print THEN RETURN;	  list ¬ AddArguments[h, list, ibti, ex, argGf, signalCsei];	  ex ¬ in };	ENDCASE => list ¬ AddToList[h, list, body.localCtx, indent, body.level];      indent ¬ indent - 2;      IF ibti = Symbols.RootBti THEN RETURN;      ENDLOOP };  AddToList: PROCEDURE [h: IT.Handle, list: IT.CtxLink, ctx: Symbols.CTXIndex, indent: CARDINAL, level: Symbols.ContextLevel] RETURNS [newList: IT.CtxLink] = {    null: BOOLEAN ¬ (ctx = Symbols.CTXNull);    newList ¬ IO.Node[h, SIZE[IT.CtxItem]];    newList­ ¬ [link: list, indirect: FALSE, indent: indent, onStack: FALSE, mapped: null, body: TRASH];    IF null THEN newList.body ¬ empty[level] ELSE newList.body ¬ context[ctx] };  AddArguments: PROCEDURE [h: IT.Handle, list: IT.CtxLink, bti: IT.BTIndex, ex: IT.EXOI, argGf: IT.GFHandle, signalCsei: Symbols.CSEIndex] RETURNS [newList: IT.CtxLink] = {    i: IT.PcItem = IP.FindUserCbti[h, argGf, LOOPHOLE[bti]];    cbti: IT.CBTIndex;    csei: Symbols.CSEIndex;    IF i = IT.PcItemNull THEN ERROR NotCallable;    cbti ¬ h.pcCache[i].dCbti;     csei ¬ h.bb[cbti].ioType;    IF csei = Symbols.CSENull THEN csei ¬ signalCsei; « catch body »    IF csei = Symbols.CSENull THEN RETURN[list];    WITH h.seb[csei] SELECT FROM      transfer => {        newList ¬ AddRecord[h, list, LOOPHOLE[typeOut], ex = exit];        newList ¬ AddRecord[h, newList, LOOPHOLE[typeIn], ex = entry] };      ENDCASE => ERROR NotCallable; };  AddRecord: PROCEDURE [h: IT.Handle, list: IT.CtxLink, rsei: Symbols.RecordSEIndex, onStack: BOOLEAN] RETURNS [newList: IT.CtxLink] = {    IF rsei = Symbols.RecordSENull THEN RETURN [list];    newList ¬ IO.Node[h, SIZE[IT.CtxItem]];    newList­ ¬ [link: list, indent:, onStack: onStack, mapped: TRUE, body: context[h.seb[rsei].fieldCtx],      indirect: (h.seb[rsei].length/Environment.bitsPerWord > PrincOps.MaxParamsInStack)] };  Reverse: PROCEDURE [list: IT.CtxLink] RETURNS [reverse: IT.CtxLink] = {    next: IT.CtxLink;    reverse ¬ NIL;    FOR i: IT.CtxLink ¬ list, next UNTIL i = NIL DO      next ¬ i.link;      i.link ¬ reverse;      reverse ¬ i;      ENDLOOP };  FreeContextList: PUBLIC PROCEDURE [h: IT.Handle, p: IT.CtxLink] = {    next: IT.CtxLink;    FOR p ¬ p, next UNTIL p = NIL DO       next ¬ p.link;       IO.FreeNode[h, p];      ENDLOOP };  }.
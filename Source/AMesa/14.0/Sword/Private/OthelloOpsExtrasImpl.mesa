-- OthelloOpsExtrasImpl.mesaDIRECTORYOthelloOps, OthelloOpsExtras, Space, Inline, Environment, File, Volume, BootFile, Boot, StartList, SpecialVolume;OthelloOpsExtrasImpl: PROGRAM   IMPORTS Space, Environment, File, Volume, Inline, SpecialVolume  EXPORTS OthelloOpsExtras = {  OPEN OthelloOps;    Bug: ERROR [bugType: BugType] = CODE;  BugType: TYPE = {    impossibleBootFileType, startListOffEndOfBootFile, whereDidTheDriveGo,    whereDidTheLogicalVolumeGo};  NoStartListHeader: PUBLIC ERROR [code: SetGetSwitchesSuccess] = CODE;  MapStartListHeader: PUBLIC PROC [    file: File.File, firstPage: File.PageNumber, access: Space.Access ¬ readWrite]    RETURNS [outcome: SetGetSwitchesSuccess, pStartListHeader: OthelloOpsExtras.StartListHeadPtr] =    << Maps space (readWrite or readOnly) to the page containing the start list header    in the boot file starting at firstPage of file, and returns a pointer to it.    If any trouble, NoStartListHeader is raised (and the space is not mapped).>>    BEGIN    shortBootFile: SetGetSwitchesSuccess = SetGetSwitchesSuccess[other];    pBootHeader: LONG POINTER TO BootFile.Header ¬ NIL;  -- and space.    startListPage: Environment.PageNumber;    offsetStartListInPage: CARDINAL;    remainingBootFilePages: Environment.PageCount;    headerPage: File.PageNumber;    nEntries: CARDINAL;    entries: LONG POINTER TO ARRAY [0..0) OF BootFile.MapEntry;    bootFileSize: File.PageCount;    BEGIN    ENABLE      UNWIND => IF pBootHeader # NIL THEN pBootHeader ¬ Space.Unmap[pBootHeader];    bootFileSize ¬ File.GetSize[      file !      File.Unknown, Volume.Unknown, Volume.NotOnline, Volume.NotOpen =>        ERROR NoStartListHeader[nullBootFile]];    -- Map space to boot file header, get location of start list out of it:    IF firstPage > bootFileSize THEN ERROR NoStartListHeader[shortBootFile];    pBootHeader ¬ Space.Map[  -- map to header page      window: [file, firstPage, 1], swapUnits: [unitary[]], access: access !      Volume.ReadOnly => ERROR NoStartListHeader[cantWriteBootFile];      File.MissingPages => ERROR NoStartListHeader[other]].mapUnit.pointer;    IF pBootHeader.version # BootFile.currentVersion THEN      ERROR NoStartListHeader[other];    startListPage ¬ Environment.PageFromLongPointer[pBootHeader.pStartListHeader];    offsetStartListInPage ¬ Inline.LongDivMod[      num: LOOPHOLE[pBootHeader.pStartListHeader],      den: Environment.wordsPerPage].remainder;    -- Set up loop variables:    remainingBootFilePages ¬ pBootHeader.countData;    entries ¬ @pBootHeader.entries;    nEntries ¬ BootFile.maxEntriesPerHeader;    headerPage ¬ firstPage;    DO  --until get to header page which describes page containing start list--      -- At this point we have either a boot file Header or Trailer page,      -- and are looking at the map entries in it,      -- searching for the vm page containing the start list.      nEntries ¬ CARDINAL[MIN[remainingBootFilePages, nEntries]];      FOR k: CARDINAL IN [0..nEntries) DO        IF entries[k].virtual = startListPage THEN          BEGIN  -- found file page containing start list.          startListHeaderPages: Environment.PageCount = Space.PagesFromWords[            StartList.Header.SIZE + Environment.wordsPerPage - 1];  -- can start anywhere in page.          pBootHeader ¬ Space.Unmap[pBootHeader];  -- unmap the header/trailer page.          -- Map the start list header:          IF headerPage + 1 + k + startListHeaderPages > bootFileSize THEN            ERROR NoStartListHeader[shortBootFile];          pStartListHeader ¬            Space.Map[              window: [file, headerPage + 1 + k, startListHeaderPages],              swapUnits: [unitary[]], access: access !              Volume.ReadOnly => ERROR NoStartListHeader[cantWriteBootFile];              File.MissingPages => ERROR NoStartListHeader[other]].mapUnit.pointer              + offsetStartListInPage;          RETURN[            outcome:            IF pStartListHeader.version # StartList.VersionID THEN            startListHeaderHasBadVersion ELSE success,              pStartListHeader: pStartListHeader];          END;        ENDLOOP;      -- It's not described in this Header or Trailer page; go for the next:      headerPage ¬ headerPage + 1 + nEntries;  -- step past header and data pages.      remainingBootFilePages ¬ remainingBootFilePages - nEntries;      pBootHeader ¬ Space.Unmap[pBootHeader];      IF remainingBootFilePages = 0 THEN ERROR Bug[startListOffEndOfBootFile];      IF headerPage > bootFileSize THEN ERROR NoStartListHeader[shortBootFile];      pBootHeader ¬ Space.Map[  -- map to trailer page        window: [file, headerPage, 1], swapUnits: [unitary[]], access: access !        Volume.ReadOnly => ERROR NoStartListHeader[cantWriteBootFile];        File.MissingPages => ERROR NoStartListHeader[other]].mapUnit.pointer;      entries ¬ @LOOPHOLE[pBootHeader, LONG POINTER TO BootFile.Trailer].entries;      nEntries ¬ BootFile.maxEntriesPerTrailer;      ENDLOOP;    END;  --ENABLE UNWIND--    END;  --GetStartListHeader--    GetVolumeBootFile: PUBLIC PROC [lvID: Volume.ID, type: BootFileType]    RETURNS [file: File.File, firstPage: File.PageNumber] =    BEGIN    bootFiles: Boot.LVBootFiles;    cType: Boot.BootFileType = ConvertBootFileType[type];    SpecialVolume.GetLogicalVolumeBootFiles[lvID, @bootFiles];    IF bootFiles[cType].fID.fileID = File.nullID THEN RETURN[File.nullFile, 0]    ELSE {      file ¬ [bootFiles[cType].fID.fileID, lvID];      RETURN[file, bootFiles[cType].firstPage]};    END;     ConvertBootFileType: PROC [x: BootFileType] RETURNS [Boot.BootFileType] =    BEGIN    SELECT x FROM      hardMicrocode => RETURN[hardMicrocode];      softMicrocode => RETURN[softMicrocode];      germ => RETURN[germ];      pilot => RETURN[pilot];      ENDCASE => ERROR Bug[impossibleBootFileType];    END;  }..
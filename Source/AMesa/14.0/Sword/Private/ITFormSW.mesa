-- File: ITFormSW.mesa - last edit:-- Litman              20-Apr-87 11:20:12-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.DIRECTORY  AMEvents USING [BootedNotifier, CallDebugger, GetEvents, Screen, StopEvents],  Ascii USING [CR, DEL, NUL],  Context USING [Find],  Cursor USING [Set],  FormSW USING [AllocateItemDescriptor, BooleanItem, ClientItemsProcType, CommandItem, Display, DisplayItem, Enumerated, EnumeratedItem, EnumeratedNotifyProcType, FilterProcType, FindItem, ItemHandle, line0, line1, line2, line3, NotifyProcType, nullIndex, ProcType, SetTypeIn, StringEditProc, StringItem],  IA USING [TopOfFork],  ID USING [],  II USING [ClearMarks, CrossReference, DateForSelection, FetchSelection, FrameFromSelection],  IK USING [DestroyHandle, EventHandler],  IL USING [CreateOptions, DoAttach, GetITHandle, MakeConfigSW, MakeFlowSW, SC, SetUp, ShowType],  IM USING [strings],  IO USING [Kill, Line, MyContextType, Proceed, Quit, ShowRep, zone, UserAborted],  IP USING [DisplaySource, GF, PC],  IQ USING [AsciiRead, AttachCondition, AttachExpression, AttachSymbols, ClearAllBreaks, DoKill, DoProceed, DoQuit, ListBreaks, OctalRead, OctalWrite, StartUser],  IS USING [EvalStack, FindModule, Umbrella, WriteError],  IT USING [ClearEnumerated, ClientFormItems, GoFormItems, Handle, LG, nullPC, WordBoolean],  ITExtras USING [InterpreterState, Spare],  Process USING [Detach],  Selection USING [Convert],  SwordUsefulDefs USING [SetDefaultWorld],  Token,  Tool USING [DeleteThisSW],  ToolWindow USING [Handle, WindowForSubwindow],  TTY,  UserInput USING [SetInputFocus, StuffCharacter, WaitForConfirmation],  UserTerminal USING [BlinkDisplay],  Watch USING [GetLP, NonLocalStartWatch, NonLocalStopTrace, StartWatch, StopTrace],  Window USING [Handle],  WindowFont USING [CharWidth],  WorldVM USING [BadWorld, InvalidateWorld, LocalWorld, OutloadWorld, RemoteWorld, World],  WorldVMOps USING [GetType];ITFormSW: PROGRAM  IMPORTS AMEvents, Context, Cursor, FormSW, IA, II, IK, IL, IM, IO, IP, IQ, IS, Process, Selection, SwordUsefulDefs, Token, Tool, ToolWindow, UserInput, UserTerminal, Watch, WindowFont, WorldVM, WorldVMOps  EXPORTS ID, IL = {  FormItems: TYPE = {go, breakNumber, gf, address, module, clientOutload, clientRemote, condition, keystrokes, value, file, client, destroy, apply, configs, processes, abort, read, write, attach, another, source, findModule, clear, date, «fetch,» rep, showType, typebits, break, watch, options};      GetH: PROC[sw: Window.Handle] RETURNS[h: IT.Handle] = {    RETURN[Context.Find[IO.MyContextType, ToolWindow.WindowForSubwindow[sw]]]};      Processes: FormSW.NotifyProcType = {    h: IT.Handle = GetH[sw];    IF h.flows.b THEN {       IF h.client # dormant THEN IL.MakeFlowSW[h]       ELSE { «UserTerminal.BlinkDisplay[]; h.flows.b ¬ FALSE; FormSW.DisplayItem[sw, index]» }}    ELSE { Tool.DeleteThisSW[h.flowSW]; h.flowSW ¬ NIL; h.flowZoom ¬ NIL }};    Configs: FormSW.NotifyProcType = {    h: IT.Handle = GetH[sw];    IF h.configs.b THEN {       IF h.client # dormant THEN IL.MakeConfigSW[h]       ELSE { «UserTerminal.BlinkDisplay[]; h.configs.b ¬ FALSE; FormSW.DisplayItem[sw, index]» } }    ELSE { Tool.DeleteThisSW[h.configSW]; h.configSW ¬ NIL; h.configZoom ¬ NIL }};        Confirm: PROC[] RETURNS[okay: BOOLEAN] = {    Cursor.Set[mouseRed];    okay ¬ UserInput.WaitForConfirmation[].okay;    Cursor.Set[textPointer] };      DormantError: PROC[h: IT.Handle] = {    UserTerminal.BlinkDisplay[];    IO.Line[h, "Sword dormant!"L];    };        GoOperation: PUBLIC PROC[h: IT.Handle, go: IT.GoFormItems, signal: BOOLEAN] = {    IF h.client = dormant THEN { DormantError[h]; RETURN };    IF (signal OR Confirm[]) THEN {      SELECT go FROM	proceed => IQ.DoProceed[h ! IO.Proceed => IF signal THEN REJECT ELSE { TellFileSubwindow[h, proceed]; CONTINUE }];	abort => IQ.DoQuit[h ! IO.Quit => IF signal THEN REJECT ELSE { TellFileSubwindow[h, quit]; CONTINUE }];	kill => IQ.DoKill[h ! IO.Kill => IF signal THEN REJECT ELSE { TellFileSubwindow[h, kill]; CONTINUE }];	screen => IQ.DoProceed[h ! IO.Proceed => { AMEvents.Screen[h.world]; CONTINUE }];	start => NULL;	ENDCASE }};    Go: FormSW.EnumeratedNotifyProcType = {    h: IT.Handle = GetH[sw];    IF h.go = start THEN {      IF h.client # dormant THEN { ChangeForm[sw, startGF]; h.call1 ¬ StartGF }      ELSE DormantError[h] }    ELSE GoOperation[h, h.go, FALSE];    h.go ¬ IT.ClearEnumerated;    FormSW.DisplayItem[sw, index]};      Client: FormSW.EnumeratedNotifyProcType = {    h: IT.Handle = GetH[sw];    oldClient: IT.ClientFormItems = oldValue;    SELECT oldClient FROM      local, outload, remote «dormant» => {        SELECT h.client FROM	  setDUD => NULL;	  ENDCASE => CleanupClient[h] };      ENDCASE => NULL;    SELECT h.client FROM      local => {        h.client ¬ dormant;        Process.Detach[FORK TopOfFork]};      outload => {        ChangeForm[sw, outloadWorld]; h.call1 ¬ OutloadWorld;	SetFormSWClient[h, dormant]};      remote => {        ChangeForm[sw, remoteWorld]; h.call1 ¬ RemoteWorld;	SetFormSWClient[h, dormant]};      setDUD => {        IF oldClient # dormant THEN SwordUsefulDefs.SetDefaultWorld[h.world];	SetFormSWClient[h, oldClient]};      dormant => NULL;      ENDCASE};        TopOfFork: PROC = {AMEvents.CallDebugger["Sword"L]};      SetFormSWClient: PUBLIC PROC[h: IT.Handle, client: IT.ClientFormItems] = {    h.client ¬ client;    FormSW.DisplayItem[h.formSW, FormItems.client.ORD]};    CleanupClient: PUBLIC PROC[h: IT.Handle] = {    SELECT WorldVMOps.GetType[h.world] FROM      local => {        AbortWindow[h.world, 0, h]}; -- get rid of event      outload => {        AbortWindow[h.world, 0, h]; -- get rid of event	AMEvents.StopEvents[h.world]; -- get rid of actor	WorldVM.InvalidateWorld[h.world] }; -- get rid of world      remote => {        AbortWindow[h.world, 0, h]; -- get rid of event	AMEvents.StopEvents[h.world]; -- get rid of actor	WorldVM.InvalidateWorld[h.world] }; -- get rid of world      ENDCASE => {        AbortWindow[h.world, 0, h]; -- get rid of event	AMEvents.StopEvents[h.world]; -- get rid of actor	WorldVM.InvalidateWorld[h.world] }}; -- get rid of world        TellFileSubwindow: PROC[h: IT.Handle, todo: {proceed, quit, kill, abort}] = {    LOOPHOLE[h.spare, ITExtras.Spare].state ¬ SELECT todo FROM      proceed => ITExtras.InterpreterState.proceed,      quit => ITExtras.InterpreterState.quit,      kill => ITExtras.InterpreterState.kill,      abort => ITExtras.InterpreterState.abort,      ENDCASE => ERROR;    [] ¬ UserInput.StuffCharacter[h.fileSW, Ascii.NUL]; };    AbortWindow: AMEvents.BootedNotifier = {    h: IT.Handle = clientData;    TellFileSubwindow[h, abort]};	  MyOptions:  FormSW.ProcType = {    h: IT.Handle = GetH[sw];    IL.CreateOptions[h]};      Another:  FormSW.ProcType = {    Process.Detach[FORK IA.TopOfFork[NIL, NIL, TTY.nullHandle]];};  MyDestroy:  FormSW.ProcType = {    h: IT.Handle = GetH[sw];    success: BOOLEAN;    SELECT h.client FROM      local => success ¬ IK.DestroyHandle[h];      outload => success ¬ IK.DestroyHandle[h];      remote => success ¬ IK.DestroyHandle[h]; -- SetUserAbort?      dormant => success ¬ IK.DestroyHandle[h];      ENDCASE;    IF ~success THEN UserTerminal.BlinkDisplay[] };  Read:  FormSW.EnumeratedNotifyProcType = {    h: IT.Handle = GetH[sw];    SELECT h.read FROM      octal => { ChangeForm[sw, readOctal]; h.call1 ¬ ReadOctal };      ascii => { ChangeForm[sw, readAscii]; h.call1 ¬ ReadAscii };      evalstack => IS.EvalStack[h];      ENDCASE;    h.read ¬ IT.ClearEnumerated;    FormSW.DisplayItem[sw, index]};      Write:  FormSW.EnumeratedNotifyProcType = {    h: IT.Handle = GetH[sw];    SELECT h.write FROM      octal => { ChangeForm[sw, writeOctal]; h.call1 ¬ WriteOctal};      ENDCASE;    h.write ¬ IT.ClearEnumerated;    FormSW.DisplayItem[sw, index]};  Attach:  FormSW.EnumeratedNotifyProcType = {    h: IT.Handle = GetH[sw];    SELECT h.attach FROM      source => {        window: Window.Handle = Selection.Convert[subwindow];        IL.DoAttach[window]};      symbols => { ChangeForm[sw, attachSymbols]; h.call1 ¬ AttachSymbols};      ENDCASE;    h.attach ¬ IT.ClearEnumerated;    FormSW.DisplayItem[sw, index]};  Source:  FormSW.ProcType = {    h: IT.Handle = GetH[sw];    frame: LONG POINTER;    lg: IT.LG;    [frame, lg] ¬ II.FrameFromSelection[h];    IF frame # NIL THEN {      Umbilical: PROC[h: IT.Handle, u: LONG UNSPECIFIED] = {        IP.DisplaySource[h: h, 	  gf: IF lg = local THEN IP.GF[h, frame] ELSE LOOPHOLE[frame], 	  pc: IF lg = local THEN IP.PC[h, frame] ELSE IT.nullPC, 	  load: TRUE]};      IS.Umbrella[h, 0, Umbilical]}    ELSE UserTerminal.BlinkDisplay[]};  FindModule:  FormSW.ProcType = {    h: IT.Handle = GetH[sw];    IF ~II.CrossReference[h] THEN { ChangeForm[sw, findModule]; h.call1 ¬ Findmodule }};      Clear:  FormSW.ProcType = {    h: IT.Handle = GetH[sw];    II.ClearMarks[h] };        Date:  FormSW.ProcType = {    h: IT.Handle = GetH[sw];    II. DateForSelection[h] };      Fetch:  FormSW.ProcType = {    h: IT.Handle = GetH[sw];    II.FetchSelection[h] };  Rep:  FormSW.ProcType = {    h: IT.Handle = GetH[sw];    Umbilical: PROC[h: IT.Handle, u: LONG UNSPECIFIED] = {IO.ShowRep[h]};    IS.Umbrella[h, 0, Umbilical]};  ShowType:  FormSW.ProcType = {    h: IT.Handle = GetH[sw];    Umbilical: PROC[h: IT.Handle, u: LONG UNSPECIFIED] = {IL.ShowType[h, FALSE]};    IS.Umbrella[h, 0, Umbilical]};  Typebits:  FormSW.ProcType = {    h: IT.Handle = GetH[sw];    Umbilical: PROC[h: IT.Handle, u: LONG UNSPECIFIED] = {IL.ShowType[h, TRUE]};    IS.Umbrella[h, 0, Umbilical]};    BreakInWindow: PROC[h: IT.Handle, sc: IL.SC] = {    window: Window.Handle = Selection.Convert[subwindow];    IL.SetUp[h, window, sc, break]};  Break:  FormSW.EnumeratedNotifyProcType = {    h: IT.Handle = GetH[sw];    Umbilical: PROC[h: IT.Handle, u: LONG UNSPECIFIED] = {      SELECT h.break FROM	setbreak => BreakInWindow[h, set];	clearbreak => BreakInWindow[h, clear];	clearall => IQ.ClearAllBreaks[h];	list => IQ.ListBreaks[h];	attachCondition => { ChangeForm[sw, attachCondition]; h.call1 ¬ AttachCondition};	attachKey => { ChangeForm[sw, attachKey]; h.call1 ¬ AttachKey};	ENDCASE};     IF h.client # dormant THEN IS.Umbrella[h, 0, Umbilical] ELSE DormantError[h];    h.break ¬ IT.ClearEnumerated;    FormSW.DisplayItem[sw, index]};      WatchIt:  FormSW.NotifyProcType = {    h: IT.Handle = GetH[sw];    IF h.client = dormant THEN {      DormantError[h];       h.watch ¬ off;      FormSW.DisplayItem[sw, index];      RETURN };    SELECT h.watch FROM      off =>         IF h.world = WorldVM.LocalWorld[] 	THEN Watch.StopTrace[] 	ELSE [] ¬ Watch.NonLocalStopTrace[h];      on => {         ChangeForm[sw, watchOn]; 	h.call1 ¬ WatchOn; 	h.watch ¬ off «in case they Abort» };      ENDCASE };      PromptForm: TYPE = {attachCondition, attachKey, attachSymbols, writeOctal, readOctal, readAscii, startGF, findModule, outloadWorld, remoteWorld, watchOn, none};      ChangeForm: PROC[sw: Window.Handle, promptForm: PromptForm] = {    ApplyAbort: PROC[i: FormItems] RETURNS[BOOLEAN] = INLINE {RETURN[i = apply OR i = abort]};    item: FormSW.ItemHandle;    FOR i: FormItems IN FormItems DO      item ¬ FormSW.FindItem[sw, i.ORD];      item.flags.invisible ¬ 	SELECT promptForm FROM	  attachCondition => ~((i = breakNumber) OR (i = condition) OR ApplyAbort[i]),	  attachKey => ~((i = breakNumber) OR (i = keystrokes) OR ApplyAbort[i]),	  attachSymbols => ~((i = gf) OR (i = file) OR ApplyAbort[i]),	  writeOctal => ~((i = address) OR (i = value) OR ApplyAbort[i]),	  readOctal => ~((i = address) OR (i = value) OR ApplyAbort[i]),	  readAscii => ~((i = address) OR (i = value) OR ApplyAbort[i]),	  startGF => ~((i = gf) OR ApplyAbort[i]),	  findModule => ~((i = module) OR ApplyAbort[i]),	  outloadWorld => ~((i = clientOutload) OR ApplyAbort[i]),	  remoteWorld => ~((i = clientRemote) OR ApplyAbort[i]),	  watchOn => ~((i = address) OR ApplyAbort[i]),	  none => ((i IN [breakNumber..file]) OR ApplyAbort[i]),	  ENDCASE => ERROR;      ENDLOOP;    FormSW.Display[sw];    IF promptForm # none THEN UserInput.SetInputFocus[sw, NullNotify, TRUE, NIL];    FormSW.SetTypeIn[sw: sw,       index: SELECT promptForm FROM         attachCondition, attachKey => FormItems.breakNumber.ORD,	attachSymbols, startGF => FormItems.gf.ORD, 	writeOctal, readOctal, readAscii, watchOn => FormItems.address.ORD,	findModule => FormItems.module.ORD,	outloadWorld => FormItems.clientOutload.ORD,	remoteWorld => FormItems.clientRemote.ORD,	ENDCASE => FormSW.nullIndex,      position: LAST[CARDINAL]]};        NullNotify:PROCEDURE [Window.Handle, LONG POINTER] = {};      AttachCondition: PROC[h: IT.Handle, s: LONG STRING] = {    IQ.AttachCondition[h, IM.strings[bbNum], IM.strings[exp]]};  AttachKey: PROC[h: IT.Handle, s: LONG STRING] = {    IQ.AttachExpression[h, IM.strings[bbNum], IM.strings[exp]]};  AttachSymbols: PROC[h: IT.Handle, s: LONG STRING] = {    IQ.AttachSymbols[h, IM.strings[frame], IM.strings[file]]};  WriteOctal: PROC[h: IT.Handle, s: LONG STRING] = {    IQ.OctalWrite[h, IM.strings[num1], IM.strings[num2]]};    ReadOctal: PROC[h: IT.Handle, s: LONG STRING] = {    IQ.OctalRead[h, IM.strings[num1], IM.strings[num2]]};  ReadAscii: PROC[h: IT.Handle, s: LONG STRING] = {    IQ.AsciiRead[h, IM.strings[num1], IM.strings[num2]]};  WatchOn: PROC[h: IT.Handle, s: LONG STRING] = {    loc: LONG POINTER = Watch.GetLP[h, IM.strings[num1]];    IF h.world = WorldVM.LocalWorld[] THEN { Watch.StartWatch[loc]; h.watch ¬ on }    ELSE {      IF Watch.NonLocalStartWatch[h, loc].success THEN h.watch ¬ on      ELSE h.watch ¬ off }};  StartGF: PROC[h: IT.Handle, s: LONG STRING] = {    IQ.StartUser[h, IM.strings[frame]]};  Findmodule: PROC[h: IT.Handle, s: LONG STRING] = {    IS.FindModule[h, IM.strings[module]]};      SetDebuggeeFile: PROC[h: IT.Handle, s: LONG STRING] = {};      GetToken: PROC[s: LONG STRING] RETURNS[token, switches: LONG STRING] = {    i: CARDINAL ¬ 0;    GetChar: Token.GetCharProcType = {       IF i = s.length THEN RETURN[Ascii.NUL];       c ¬ s[i]; i ¬ i + 1 };    tokenObject: Token.Object ¬ [getChar: GetChar];    data: Token.StandardFilterState;    TokenFilter: Token.FilterProcType ¬ {      RETURN[        SELECT TRUE FROM          Token.WhiteSpace[c, data], c = Ascii.NUL => FALSE,          c = '/ => FALSE,          ENDCASE => TRUE]};    IF s = NIL THEN RETURN[NIL, NIL];    token ¬ Token.MaybeQuoted[@tokenObject, @data, TokenFilter ! Token.UnterminatedQuote => RESUME];    switches ¬ IF tokenObject.break = '/       THEN Token.MaybeQuoted[@tokenObject, NIL, TokenFilter ! Token.UnterminatedQuote => RESUME]      ELSE NIL };        FreeToken: PROC[token, switches: LONG STRING] = {    IF token # NIL THEN token ¬ Token.FreeTokenString[token];    IF switches # NIL THEN switches ¬ Token.FreeTokenString[switches] };    ParseSwitches: PROC[l: LONG STRING] RETURNS[setDUD: BOOLEAN] = {    sw: BOOLEAN ¬ TRUE;    setDUD ¬ TRUE;    IF l = NIL THEN RETURN;    FOR i: CARDINAL IN [0..l.length) DO       SELECT l[i] FROM         '~, '- => sw ¬ FALSE;	's, 'S => {setDUD ¬ sw; sw ¬ TRUE};        ENDCASE;      ENDLOOP};    -- similar code in ITInstall   OutloadWorld: PROC[h: IT.Handle, s: LONG STRING] = {    Process.Detach[FORK Worldly[h, s, outload]]};      RemoteWorld: PROC[h: IT.Handle, s: LONG STRING] = {    Process.Detach[FORK Worldly[h, s, remote]]};      Worldly: PROC[h: IT.Handle, s: LONG STRING, which: {outload, remote}] = {    world: WorldVM.World;    token, switches: LONG STRING;    BEGIN ENABLE {      WorldVM.BadWorld => {         IO.Line[h, "Bad world!"L ! IO.UserAborted => CONTINUE]; 	FreeToken[token, switches]; GOTO Done };      ABORTED => {         IS.WriteError[h, aborted ! IO.UserAborted, ABORTED => CONTINUE]; 	FreeToken[token, switches]; GOTO Done }};      IF which = outload THEN {	[token, switches] ¬ GetToken[IM.strings[outload]];	world ¬ WorldVM.OutloadWorld[token, switches, h.tty] }      ELSE { -- which = remote	[token, switches] ¬ GetToken[IM.strings[client]];	world ¬ WorldVM.RemoteWorld[token, switches, h.tty] };      END; -- ENABLE     IF ParseSwitches[switches].setDUD THEN SwordUsefulDefs.SetDefaultWorld[world];    FreeToken[token, switches];    AMEvents.GetEvents[world: world, data: NIL, proc: IK.EventHandler];    EXITS Done => NULL };        ApplyOrAbort: FormSW.ProcType = {    --ENABLE UNWIND => ChangeForm[sw, none];    h: IT.Handle = GetH[sw];    SELECT index FROM      FormItems.apply.ORD => IS.Umbrella[h, 0, h.call1];      FormItems.abort.ORD => NULL;      ENDCASE;    ChangeForm[sw, none]};  CheckForStringDone: FormSW.FilterProcType = {    --ENABLE UNWIND => ChangeForm[sw, none];    h: IT.Handle = GetH[sw];    IF string = NIL THEN RETURN;    SELECT string[0] FROM      Ascii.DEL => { ChangeForm[sw, none]};      Ascii.CR => {IS.Umbrella[h, 0, h.call1]; ChangeForm[sw, none]};      ENDCASE => FormSW.StringEditProc[sw, item, insert, string]};  charWidth: CARDINAL = WindowFont.CharWidth['0];  CharPos: PROC[char: CARDINAL] RETURNS [x: INTEGER] = INLINE {    x ¬ charWidth * char};    MakeCommandForm: PUBLIC FormSW.ClientItemsProcType = {    OPEN FormSW;    h: IT.Handle = IL.GetITHandle[];    nItems: CARDINAL = FormItems.LAST.ORD + 1;    go: ARRAY[0..5) OF Enumerated ¬ [["proceed"L, 0], ["abort"L, 1], ["kill"L, 2], ["screen"L, 3], ["start"L, 4]];    client: ARRAY[0..5) OF Enumerated ¬ [      ["local"L, IT.ClientFormItems.local.ORD],       ["outload"L, IT.ClientFormItems.outload.ORD],       ["remote"L, IT.ClientFormItems.remote.ORD],       ["dormant"L, IT.ClientFormItems.dormant.ORD],      ["setDUD"L, IT.ClientFormItems.setDUD.ORD]];    read: ARRAY[0..3) OF Enumerated ¬ [["ascii"L, 1], ["octal"L, 0], ["stack"L, 2]];    write: ARRAY[0..1) OF Enumerated ¬ [["octal"L, 0]];    attach: ARRAY[0..2) OF Enumerated ¬ [["source"L, 0], ["symbols"L, 1]];    break: ARRAY[0..6) OF Enumerated ¬ [["set"L, 0], ["clear"L, 1], ["clearall"L, 2], ["list"L, 3], ["attachCond"L, 4], ["attachKey"L, 5]];    watch: ARRAY [0..2) OF Enumerated ¬ [["off"L, 0], ["on"L, 1]];     items ¬ AllocateItemDescriptor[nItems, IO.zone];    items[FormItems.go.ORD] ¬ EnumeratedItem[tag: "go"L, place: [CharPos[1], line0], feedback: all, proc: Go, choices: DESCRIPTOR[go], value: @h.go, z: IO.zone];    items[FormItems.breakNumber.ORD] ¬ StringItem[invisible: TRUE, tag: "BreakNumber"L, place: [CharPos[1], line0], inHeap: TRUE, string: @IM.strings[bbNum], z: IO.zone, filterProc: CheckForStringDone];    items[FormItems.gf.ORD] ¬ StringItem[invisible: TRUE, tag: "GF"L, place: [CharPos[1], line0], inHeap: TRUE, string: @IM.strings[frame], z: IO.zone, filterProc: CheckForStringDone];    items[FormItems.address.ORD] ¬ StringItem[invisible: TRUE, tag: "Address"L, place: [CharPos[1], line0], inHeap: TRUE, string: @IM.strings[num1], z: IO.zone, filterProc: CheckForStringDone];    items[FormItems.module.ORD] ¬ StringItem[invisible: TRUE, tag: "Module"L, place: [CharPos[1], line0], inHeap: TRUE, string: @IM.strings[module], z: IO.zone, filterProc: CheckForStringDone];     items[FormItems.clientOutload.ORD] ¬ StringItem[invisible: TRUE, tag: "Outload file"L, place: [CharPos[1], line0], inHeap: TRUE, string: @IM.strings[outload], z: IO.zone, filterProc: CheckForStringDone];    items[FormItems.clientRemote.ORD] ¬ StringItem[invisible: TRUE, tag: "Remote host"L, place: [CharPos[1], line0], inHeap: TRUE, string: @IM.strings[client], z: IO.zone, filterProc: CheckForStringDone];    items[FormItems.condition.ORD] ¬ StringItem[invisible: TRUE, tag: "Condition"L, place: [CharPos[41], line0], inHeap: TRUE, string: @IM.strings[exp], z: IO.zone, filterProc: CheckForStringDone];    items[FormItems.keystrokes.ORD] ¬ StringItem[invisible: TRUE, tag: "Keystrokes"L, place: [CharPos[41], line0], inHeap: TRUE, string: @IM.strings[exp], z: IO.zone, filterProc: CheckForStringDone];    items[FormItems.value.ORD] ¬ StringItem[invisible: TRUE, tag: "Value"L, place: [CharPos[41], line0], inHeap: TRUE, string: @IM.strings[num2], z: IO.zone, filterProc: CheckForStringDone];    items[FormItems.file.ORD] ¬ StringItem[invisible: TRUE, tag: "File"L, place: [CharPos[41], line0], inHeap: TRUE, string: @IM.strings[file], z: IO.zone, filterProc: CheckForStringDone];    items[FormItems.client.ORD] ¬ EnumeratedItem[tag: "client"L, place: [CharPos[44], line0], feedback: one, proc: Client, choices: DESCRIPTOR[client], value: @h.client, z: IO.zone];    items[FormItems.destroy.ORD] ¬ CommandItem[tag: "destroy"L, place: [CharPos[69], line0], proc: MyDestroy, z: IO.zone];        items[FormItems.apply.ORD] ¬ CommandItem[invisible: TRUE, tag: "Apply"L, place: [CharPos[1], line1], proc: ApplyOrAbort, z: IO.zone];    items[FormItems.configs.ORD] ¬ BooleanItem[tag: "configs"L, place: [CharPos[1], line1], proc: Configs, switch: @h.configs.b, z: IO.zone];    items[FormItems.processes.ORD] ¬ BooleanItem[tag: "processes"L, place: [CharPos[10], line1], proc: Processes, switch: @h.flows.b, z: IO.zone];    items[FormItems.abort.ORD] ¬ CommandItem[invisible: TRUE, tag: "Abort"L, place: [CharPos[13], line1], proc: ApplyOrAbort, z: IO.zone];     items[FormItems.read.ORD] ¬ EnumeratedItem[tag: "read"L, place: [CharPos[22], line1], feedback: one, proc: Read, choices: DESCRIPTOR[read], value: @h.read, z: IO.zone];    items[FormItems.write.ORD] ¬ EnumeratedItem[tag: "write"L, place: [CharPos[36], line1], feedback: one, proc: Write, choices: DESCRIPTOR[write], value: @h.write, z: IO.zone];    items[FormItems.attach.ORD] ¬ EnumeratedItem[tag: "attach"L, place: [CharPos[51], line1], feedback: one, proc: Attach, choices: DESCRIPTOR[attach], value: @h.attach, z: IO.zone];    items[FormItems.another.ORD] ¬ CommandItem[tag: "another"L, place: [CharPos[69], line1], proc: Another, z: IO.zone];    items[FormItems.source.ORD] ¬ CommandItem[tag: "source"L, place: [CharPos[1], line2], proc: Source, z: IO.zone];    items[FormItems.findModule.ORD] ¬ CommandItem[tag: "findModule"L, place: [CharPos[11], line2], proc: FindModule, z: IO.zone];    items[FormItems.clear.ORD] ¬ CommandItem[tag: "clear"L, place: [CharPos[25], line2], proc: Clear, z: IO.zone];    items[FormItems.date.ORD] ¬ CommandItem[tag: "date"L, place: [CharPos[34], line2], proc: Date, z: IO.zone];    «items[FormItems.fetch.ORD] ¬ CommandItem[tag: "fetch"L, place: [CharPos[33], line2], proc: Fetch, z: IO.zone];»    items[FormItems.rep.ORD] ¬ CommandItem[tag: "rep?"L, place: [CharPos[47], line2], proc: Rep, z: IO.zone];    items[FormItems.showType.ORD] ¬ CommandItem[tag: "showType"L, place: [CharPos[55], line2], proc: ShowType, z: IO.zone];    items[FormItems.typebits.ORD] ¬ CommandItem[tag: "type&bits"L, place: [CharPos[67], line2], proc: Typebits, z: IO.zone];    items[FormItems.break.ORD] ¬ EnumeratedItem[tag: "break"L, place: [CharPos[1], line3], feedback: all, proc: Break, choices: DESCRIPTOR[break], value: @h.break, z: IO.zone];    items[FormItems.watch.ORD] ¬ BooleanItem[tag: "watch"L, place: [CharPos[61], line3], proc: WatchIt, switch: LOOPHOLE[@h.watch], z: IO.zone];    items[FormItems.options.ORD] ¬ CommandItem[tag: "options"L, place: [CharPos[69], line3], proc: MyOptions, z: IO.zone];    RETURN[items: items, freeDesc: TRUE] };  }.    
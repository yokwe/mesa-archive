-- File: AMLoadstateImpl.mesa - last edit:-- Litman              22-Apr-87 15:41:41-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.DIRECTORY  AMHeap USING [zone],  AMLoadstate USING [BcdInfo, BcdProc, ErrorCode, ModuleInfo, ModuleProc],  BcdDefs USING [Base, FTIndex, NameRecord, VersionStamp],  BcdOps USING [BcdBase, ENHandle, FTHandle, MTHandle, NameString],  BcdOpsExtras USING [ENBaseFromBcd, gfiOrigin, MthFromGfi, nullGFIndex],  Environment USING [PageCount, wordsPerPage],  Heap USING [Error, NWords],  Inline USING [LongCOPY],  LoadState USING [LockBcdInfo, LPBcdInfoTable, LPModuleInfoTable, UnlockBcdInfo],  LoadStateFormat USING [BcdInfo, Handle, ID, Index, ModuleInfo, nullIndex, Object, oldNullModule, VersionID],  MFile USING [Error, Handle, maxNameLength, Object, ReadOnly],  MSegment USING [Address, Create, Delete, Error, Handle, Object],  PrincOps USING [GlobalFrameHandle, GlobalVariables],  Space USING [ScratchMap, Unmap],  String USING [AppendString],  WorldVM USING [LocalWorld, World],  WorldVMOps USING [Address, AddressFault, CopyRead, GetESV, LoadstateAddress, Read, ValidLoadstate];AMLoadstateImpl: MONITOR   IMPORTS AMHeap, BcdOpsExtras, Heap, Inline, LoadState, MFile, MSegment, Space, String, WorldVM, WorldVMOps  EXPORTS AMLoadstate = {  Error: PUBLIC ERROR [code: AMLoadstate.ErrorCode] = CODE;    zone: UNCOUNTED ZONE = AMHeap.zone;    local: PUBLIC Handle ¬ NIL;  nonLocals: Handle ¬ NIL;    BcdSequence: TYPE = RECORD [seq: SEQUENCE max: LoadStateFormat.ID OF BcdObject];  BcdHandle: TYPE = LONG POINTER TO BcdObject;  BcdObject: TYPE = RECORD[space: LONG POINTER, inHeap: BOOLEAN, pageCount: NATURAL, version: LONG CARDINAL];  NullBcdObject: BcdObject = [NIL, FALSE, 0, 0];      ModuleInfo: TYPE = LoadStateFormat.ModuleInfo;  BcdInfo: TYPE = LoadStateFormat.BcdInfo;  Index: TYPE = LoadStateFormat.Index;  Handle: TYPE = LONG POINTER TO Object;  Object: PUBLIC TYPE = RECORD[    next: Handle ¬ NIL,    world: WorldVM.World ¬ NIL,    format: LoadStateFormat.Handle ¬ NIL,    bcdInfo: LoadState.LPBcdInfoTable ¬ NIL,    moduleInfo: LoadState.LPModuleInfoTable ¬ NIL,    bcds: LONG POINTER TO BcdSequence ¬ NIL,    pages: Environment.PageCount ¬ 0];      AcquireLoadstate: PUBLIC PROC[world: WorldVM.World] RETURNS[l: Handle ¬ NIL] = {    ENABLE UNWIND => DestroyLoadstate[l];    formatObject: LoadStateFormat.Object;    new: LoadStateFormat.Handle;    pages: Environment.PageCount;    IF world = WorldVM.LocalWorld[] THEN {      bcdInfo: LoadState.LPBcdInfoTable;      IF local = NIL THEN local ¬ zone.NEW[Object];       [new, bcdInfo] ¬ LoadState.LockBcdInfo[];      local­ ¬ [world: world, format: new, bcdInfo: bcdInfo, moduleInfo: @new[new.moduleInfo], bcds: NIL];      LoadState.UnlockBcdInfo[];      WorldVMOps.ValidLoadstate[world];      RETURN[local] };    new ¬ WorldVMOps.LoadstateAddress[world];    IF new = NIL THEN ERROR Error[invalidParameters];    WorldVMOps.CopyRead[world: world, from: new, to: @formatObject, nwords: SIZE[LoadStateFormat.Object] ! WorldVMOps.AddressFault => ERROR Error[invalidAddress]];    IF formatObject.versionident # LoadStateFormat.VersionID THEN ERROR Error[versionMismatch];    pages ¬ (SIZE[LoadStateFormat.Object] + (formatObject.maxBcds * SIZE[BcdInfo]) + (formatObject.maxModules * SIZE[ModuleInfo]) + Environment.wordsPerPage - 1) / Environment.wordsPerPage;    FOR l ¬ nonLocals, l.next UNTIL l = NIL DO      IF l.world = world THEN {         IF WorldVMOps.GetESV[world].loadStateDirty THEN CopyLoadstate[l, new, pages];	EXIT };      REPEAT FINISHED => {         l ¬ zone.NEW[Object ¬ [next: nonLocals, world: world]]; 	nonLocals ¬ l;	CopyLoadstate[l, new, pages] };      ENDLOOP;    ExpandBcds[l];    WorldVMOps.ValidLoadstate[world] };      CopyLoadstate: PROC[l: Handle, new: LoadStateFormat.Handle, pages: Environment.PageCount] = {    WorldVMOps.GetESV[l.world].loadStateDirty ¬ FALSE;    IF pages > l.pages THEN {       [] ¬ FreeNode[l.format, TRUE];       [l.format,] ¬ GetNode[pages];       l.pages ¬ pages };    Copy[world: l.world, from: new, to: l.format, pages: pages ! Error => { FixupLoadstate[l.format]; CONTINUE } -- plunge ahead anyway --];    l.moduleInfo ¬ @l.format[l.format.moduleInfo];    l.bcdInfo ¬ LOOPHOLE[@l.format[l.format.bcdInfo]] };      ExpandBcds: PROC[l: Handle] = {    SELECT TRUE FROM      l.bcds = NIL => {        l.bcds ¬ zone.NEW[BcdSequence[l.format.nBcds]];	Zero[@l.bcds[0], l.format.nBcds*SIZE[BcdObject]] };      l.bcds.max < l.format.nBcds => {        new: LONG POINTER TO BcdSequence ¬ zone.NEW[BcdSequence[l.format.nBcds]];	FOR i: CARDINAL IN [0..l.bcds.max) DO new[i] ¬ l.bcds[i]; ENDLOOP;	Zero[@new[l.bcds.max], (new.max-l.bcds.max)*SIZE[BcdObject]];	zone.FREE[@l.bcds];	l.bcds ¬ new };      ENDCASE };      FixupLoadstate: PROC[format: LoadStateFormat.Handle] = {    moduleInfo: LoadState.LPModuleInfoTable = @format[format.moduleInfo];    bcdInfo: LoadState.LPBcdInfoTable = LOOPHOLE[@format[format.bcdInfo]];    -- This loop does the WRONG THING if gf is on the next page and gf # NIL    FOR i: CARDINAL IN (0..format.nModules) DO      IF moduleInfo[i].gf = NIL THEN { moduleInfo[i] ¬ moduleInfo[i-1] };      ENDLOOP };        WordSeq: TYPE = RECORD [SEQUENCE COMPUTED CARDINAL OF WORD];    GetNode: PROC [pages: Environment.PageCount] RETURNS [LONG POINTER, BOOLEAN] = {    ENABLE Heap.Error => { IF type = insufficientSpace THEN ERROR Error[insufficientSpace] };    words: LONG CARDINAL = pages*Environment.wordsPerPage;    IF words > Heap.NWords.LAST THEN RETURN[Space.ScratchMap[pages], FALSE]    ELSE RETURN[zone.NEW[WordSeq[CARDINAL[words]]], TRUE]};      FreeNode: PROC [p: LONG POINTER, inHeap: BOOLEAN] RETURNS[nil: LONG POINTER ¬ NIL] = {    IF p # NIL THEN { IF inHeap THEN zone.FREE[@p] ELSE [] ¬ Space.Unmap[p] }};        DestroyLoadstate: PUBLIC PROC[l: Handle] = {    prevl: Handle ¬ NIL;    nextl: Handle ¬ nonLocals;    IF l = NIL OR l = local THEN RETURN;    UNTIL nextl = NIL DO       IF nextl = l THEN {        IF prevl = NIL THEN nonLocals ¬ nextl.next ELSE prevl.next ¬ nextl.next;	EXIT };      prevl ¬ nextl; nextl ¬ nextl.next;      REPEAT FINISHED => GOTO NotFound; --ERROR;      ENDLOOP;    IF l.bcds # NIL THEN       FOR i: CARDINAL IN [0..l.bcds.max) DO	[] ¬ FreeNode[l.bcds[i].space, l.bcds[i].inHeap];	REPEAT FINISHED => zone.FREE[@l.bcds];	ENDLOOP;     IF l.format # NIL THEN l.format ¬ FreeNode[l.format, TRUE];    zone.FREE[@l];    EXITS NotFound => NULL };    Validate: ENTRY PROC[l: Handle] = {    ENABLE UNWIND => NULL;    reason: AMLoadstate.ErrorCode;    IF l = local THEN {      [local.format, local.bcdInfo] ¬ LoadState.LockBcdInfo[];      local.moduleInfo ¬ @local.format[local.format.moduleInfo];      LoadState.UnlockBcdInfo[];      RETURN };    SELECT TRUE FROM      l = NIL => reason ¬ loadStateMissing;      l.world = NIL => reason ¬ loadStateMissing;      l.format = NIL => reason ¬ loadStateMissing;      l.bcdInfo = NIL => reason ¬ bcdInfoMissing;      l.moduleInfo = NIL => reason ¬ moduleInfoMissing;      ENDCASE => RETURN;    RETURN WITH ERROR Error[reason] };  MapConfigToReal: PUBLIC PROCEDURE [l: Handle, cgfi: NATURAL, index: Index] RETURNS [gf: PrincOps.GlobalFrameHandle] = {    ENABLE UNWIND => NULL;    Validate[l];    IF cgfi = BcdOpsExtras.nullGFIndex THEN RETURN[NIL];    FOR i: CARDINAL IN [0..l.format.nModules) DO      IF l.moduleInfo[i].index = index AND l.moduleInfo[i].cgfi = cgfi THEN RETURN[l.moduleInfo[i].gf];      ENDLOOP;    RETURN[NIL]};      MapRealToConfig: PUBLIC PROCEDURE [l: Handle, gf: PrincOps.GlobalFrameHandle] RETURNS [cgfi: NATURAL, index: Index] = {    moduleInfo: LoadState.LPModuleInfoTable;    bottom, -- index of smallest candidate    top: CARDINAL; -- index just above largest candidate    Validate[l];    bottom ¬ 0;    top ¬ l.format.nModules;    moduleInfo ¬ l.moduleInfo;    WHILE bottom < top DO      med: CARDINAL = (bottom+top)/2;      SELECT MakeOrdered[moduleInfo[med].gf] FROM        < MakeOrdered[gf] => bottom ¬ med+1;        > MakeOrdered[gf] => top ¬ med;	ENDCASE => RETURN[moduleInfo[med].cgfi, moduleInfo[med].index];      ENDLOOP;    ERROR Error[invalidParameters]};      MakeOrdered: PROC[gf: PrincOps.GlobalFrameHandle]     RETURNS[ORDERED POINTER TO PrincOps.GlobalVariables] = INLINE {    RETURN[LOOPHOLE[gf]]};      MapConfigToMth: PUBLIC PROCEDURE [l: Handle, cgfi: NATURAL, index: Index] RETURNS [mth: BcdOps.MTHandle] = {    bcd: BcdOps.BcdBase;    IF index = LoadStateFormat.nullIndex THEN RETURN[NIL];    bcd ¬ AcquireBcd[l, index ! Error => {bcd ¬ NIL; CONTINUE}];    RETURN[MapCgfiToMth[l, cgfi, bcd]]};      MapRealToEnh: PUBLIC PROCEDURE [l: Handle, gf: PrincOps.GlobalFrameHandle] RETURNS [enh: BcdOps.ENHandle] = {    cgfi: NATURAL;    index: Index;    bcd: BcdOps.BcdBase;    mth: BcdOps.MTHandle;    [cgfi, index] ¬ MapRealToConfig[l, gf];    IF index = LoadStateFormat.nullIndex THEN RETURN[NIL];    bcd ¬ AcquireBcd[l, index ! Error => {bcd ¬ NIL; CONTINUE}];    mth ¬ MapCgfiToMth[l, cgfi, bcd];    IF mth = NIL THEN RETURN[NIL];    RETURN[@BcdOpsExtras.ENBaseFromBcd[bcd][mth.entries]] };      MapCgfiToMth: PUBLIC PROC [l: Handle, cgfi: NATURAL, bcd: BcdOps.BcdBase] RETURNS [mth: BcdOps.MTHandle] = {    IF bcd = NIL THEN RETURN[NIL];    mth ¬ IF cgfi IN [BcdOpsExtras.gfiOrigin..bcd.firstdummy) THEN BcdOpsExtras.MthFromGfi[bcd, cgfi] ELSE NIL};    AcquireBcd: PUBLIC PROCEDURE [l: Handle, index: Index] RETURNS [bcd: BcdOps.BcdBase] = {    info: LoadStateFormat.BcdInfo;    version: LONG CARDINAL;    bcdHandle: BcdHandle;    Validate[l];    IF index NOT IN [0..l.format.nBcds) THEN ERROR Error[invalidParameters];    info ¬ l.bcdInfo[index];    IF l = local THEN RETURN[info.base];    WorldVMOps.CopyRead[world: l.world, from: @(PointerToBcdBase[info.base].version.time), to: @version, nwords: SIZE[LONG CARDINAL]       ! WorldVMOps.AddressFault => ERROR Error[invalidAddress]];    bcdHandle ¬ @l.bcds[index];    IF bcdHandle.space # NIL AND bcdHandle.version = version THEN RETURN[bcdHandle.space];    IF bcdHandle.pageCount # info.pages THEN {      bcdHandle.pageCount ¬ info.pages;      [] ¬ FreeNode[bcdHandle.space, bcdHandle.inHeap];      [bcdHandle.space, bcdHandle.inHeap] ¬ GetNode[info.pages] };    Copy[world: l.world, from: info.base, to: bcdHandle.space, pages: info.pages      ! Error => {	IF code = invalidAddress THEN [] ¬ AcquireLocalBcd[l, info.base, bcdHandle.space, version];	CONTINUE -- plunge ahead anyway -- }];    IF info.pages # PointerToBcdBase[bcdHandle.space].nPages THEN {      bcdHandle.space ¬ FreeNode[bcdHandle.space, bcdHandle.inHeap];      bcdHandle.pageCount ¬ 0;      ERROR Error[couldNotAcquireALoadedBcd] };    bcdHandle.version ¬ version;    RETURN[bcdHandle.space] };      PointerToBcdBase: PROC[lp: LONG POINTER] RETURNS[BcdOps.BcdBase] = INLINE { RETURN[lp] };      AcquireLocalBcd: PROC[l: Handle, hisBase, myBase: BcdOps.BcdBase, version: LONG CARDINAL] RETURNS[success: BOOLEAN ¬ FALSE] = {    -- maplog may not be complete but perhaps we can acquire bcd locally    -- and copy it into myBase    ENABLE WorldVMOps.AddressFault => CONTINUE;    mseg: MSegment.Handle ¬ NIL;    msegAddress: BcdOps.BcdBase ¬ NIL;    Cleanup: PROC[] = { IF mseg # NIL THEN MSegment.Delete[mseg]; };    target: LONG STRING ¬ [MFile.maxNameLength];    fti: BcdDefs.FTIndex = WorldVMOps.Read[l.world, @hisBase.sourceFile];    ftOffset: CARDINAL = WorldVMOps.Read[l.world, @hisBase.ftOffset];    ftb: BcdDefs.Base = LOOPHOLE[hisBase + ftOffset];    fth: BcdOps.FTHandle = @ftb[fti];    name: BcdDefs.NameRecord = WorldVMOps.Read[l.world, @fth.name];    ssOffset: CARDINAL = WorldVMOps.Read[l.world, @hisBase.ssOffset];    ssb: BcdOps.NameString = LOOPHOLE[hisBase + ssOffset];    nameSize: BcdDefs.NameRecord = [name+3];    nameString: BcdDefs.NameRecord = [name+4];    word: RECORD[SELECT OVERLAID * FROM      chars => [chars: PACKED ARRAY [0..1] OF CHARACTER],      word => [word: WORD],      ENDCASE];    word ¬ WorldVMOps.Read[l.world, ssb + nameSize/2];    target.length ¬ LOOPHOLE[IF (nameSize MOD 2) = 0 THEN word.chars[0] ELSE word.chars[1]];    FOR i: CARDINAL IN [nameString..nameString+target.length) DO      IF i MOD 2 = 0 THEN {        word ¬ WorldVMOps.Read[l.world, ssb + i/2];	target.text[i-nameString] ¬ word.chars[0] }      ELSE         target.text[i-nameString] ¬ word.chars[1];      ENDLOOP;    FOR i: CARDINAL IN [0..target.length) DO      IF target[i] = '. THEN { target.length ¬ i; EXIT };      ENDLOOP;    String.AppendString[target, ".bcd"L];    BEGIN ENABLE MFile.Error, MSegment.Error => { Cleanup[]; CONTINUE };      mseg ¬ MSegment.Create[MFile.ReadOnly[target, []], []];      msegAddress ¬ MSegment.Address[mseg];      IF msegAddress.version.time = version THEN {	Inline.LongCOPY[from: msegAddress, to: myBase, nwords: msegAddress.nPages*Environment.wordsPerPage];	success ¬ TRUE };      Cleanup[];      END };      GetAttributes: PUBLIC PROCEDURE [l: Handle] RETURNS [nBcds, nModules: CARDINAL] = {    ENABLE UNWIND => NULL;     Validate[l ! Error => IF code = loadStateMissing THEN GOTO failed ELSE CONTINUE];     RETURN[l.format.nBcds, l.format.nModules];    EXITS failed => RETURN[nBcds: 0, nModules: 0]};    nullBcdInfo: BcdInfo = [FALSE, FALSE, 1, NIL, 0];    EnumerateBcds: PUBLIC PROC [l: Handle, proc: AMLoadstate.BcdProc, reverse: BOOLEAN] RETURNS [BcdInfo, Index] = {    Validate[l];    IF reverse THEN      FOR config: CARDINAL DECREASING IN [0..l.format.nBcds) DO         IF proc[l.bcdInfo[config], config] THEN RETURN[l.bcdInfo[config], config];	ENDLOOP    ELSE      FOR config: CARDINAL IN [0..l.format.nBcds) DO         IF proc[l.bcdInfo[config], config] THEN RETURN[l.bcdInfo[config], config] 	ENDLOOP;    RETURN[nullBcdInfo, LoadStateFormat.nullIndex]};      EnumerateModules: PUBLIC PROCEDURE [l: Handle, proc: AMLoadstate.ModuleProc, reverse: BOOLEAN]  RETURNS [ModuleInfo] = {    Validate[l];    IF reverse THEN      FOR i: CARDINAL DECREASING IN [0..l.format.nModules) DO         IF proc[l.moduleInfo[i]] THEN RETURN[l.moduleInfo[i]]; 	ENDLOOP    ELSE      FOR i: CARDINAL IN [0..l.format.nModules) DO	IF proc[l.moduleInfo[i]] THEN RETURN [l.moduleInfo[i]];	ENDLOOP;    RETURN[LoadStateFormat.oldNullModule]};      EnumerateModulesInConfig: PUBLIC PROCEDURE [l: Handle, proc: AMLoadstate.ModuleProc, index: Index] RETURNS [ModuleInfo] = {    Validate[l];    FOR i: CARDINAL DECREASING IN [0..l.format.nModules) DO      mod: AMLoadstate.ModuleInfo = l.moduleInfo[i];      IF mod.index = index AND mod.cgfi # BcdOpsExtras.nullGFIndex AND proc[mod] THEN RETURN [mod];      ENDLOOP;    RETURN[LoadStateFormat.oldNullModule]};      Copy: PROC [world: WorldVM.World, from, to: LONG POINTER, pages: Environment.PageCount] = {    error: BOOLEAN ¬ FALSE;    IF LOOPHOLE[from, LONG CARDINAL] MOD Environment.wordsPerPage # 0 THEN ERROR;    FOR i: Environment.PageCount IN [0..pages) DO      WorldVMOps.CopyRead[world: world, from: from, to: to, nwords: Environment.wordsPerPage	! WorldVMOps.AddressFault => { Zero[to, Environment.wordsPerPage]; error ¬ TRUE; CONTINUE }];      from ¬ from + Environment.wordsPerPage;      to ¬ to + Environment.wordsPerPage;      ENDLOOP;    IF error THEN ERROR Error[invalidAddress] };      Zero: PROC [p: LONG POINTER, l: CARDINAL] = INLINE {    IF l = 0 THEN RETURN;    p­ ¬ 0;    Inline.LongCOPY[from: p, to: p+1, nwords: l-1] --ok-- };  }.
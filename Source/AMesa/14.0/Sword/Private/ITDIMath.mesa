-- File: ITDIMath.mesa - last edit:-- Litman              24-May-87 14:02:01-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.DIRECTORY  ComData USING [CSEIndex, typeCARDINAL, typeINT, typeREAL],  Format USING [Char, LongNumber, Number, NumberFormat, StringProc, Text],  IO USING [InvalidNumber, Text, zone],  IP USING [AbortWithError, DIFormat, GetNumber, GetValue, MakeLongType, TypeForSe],  IR USING [CheckLength, NumberLength, Pop, Push, PushLongVal, PushVal, Son, Tos],  IT USING [BYTE, DecimalNumberFormat, Foo, Handle, HexNumberFormat, IntegerNumberFormat, LongNumFormat, NumAddr, Number, NumberType, NumFormat, OctalNumberFormat],  IV USING [],  Real USING [FAdd, FDiv, FMul, FSub, RealException],  Symbols USING [CSEIndex, CSENull, SEIndex, typeANY],  Tree USING [Link, NodeName],  WorldVMOps USING [Long];  ITDIMath: PROGRAM   IMPORTS com: ComData, Format, IO, IP, IR, Real, WorldVMOps  EXPORTS IR, IV = {  OPEN IT;    LengtheningGarbage: ERROR = CODE;    CompType: TYPE = {min, max};  CompResult: TYPE = {lt, eq, gt};    PutReps: PUBLIC «IR» PROCEDURE [h: Handle, n: UNSPECIFIED] = {     PutRepsWithProc[n, IO.Text, h] };  PutLongReps: PUBLIC «IR» PROCEDURE [h: Handle, n: LONG UNSPECIFIED] = {    PutLongRepsWithProc[n, IO.Text, h] };  PutRepsWithProc: PUBLIC «IV» PROC[n: UNSPECIFIED, output: Format.StringProc, clientData: LONG POINTER] = {    OPEN LOOPHOLE[n, NumFormat];    Octal[output, c, clientData];     Equals[output, clientData]; Hex[output, c, clientData];     Equals[output, clientData]; Decimal[output, i, clientData];    IF b1 # 0 THEN {      Equals[output, clientData]; Bytes[output, b1, b2, clientData];      IF b1 > 15 OR b2 > 15 THEN {        Equals[output, clientData]; Octal[output, b1, clientData]; Text[output, ",,"L, clientData]; Octal[output, b2, clientData]};      IF b1 < 128 AND b2 < 128 THEN {	Equals[output, clientData]; Char[output, LOOPHOLE[b1], clientData]; Text[output, ",,"L, clientData]; 	Char[output, LOOPHOLE[b2], clientData]}}    ELSE IF b2 IN [1..127] THEN {Equals[output, clientData]; Char[output, LOOPHOLE[b2], clientData]};    IF n1 # 0 OR n3 # 0 THEN {      -- display nibbles      Equals[output, clientData];      IF b1 # 0 THEN {	IF n1 # 0 THEN { 	  OutNumber[output, n1, DecimalNumberFormat, clientData]; Char[output, ':, clientData]};	OutNumber[output, n2, DecimalNumberFormat, clientData]; Text[output, ",,"L, clientData]};      IF n3 # 0 THEN {OutNumber[output, n3, DecimalNumberFormat, clientData]; Char[output, ':, clientData]};      OutNumber[output, n4, DecimalNumberFormat, clientData]}};      PutLongRepsWithProc: PUBLIC «IV» PROC[n: LONG UNSPECIFIED, output: Format.StringProc, clientData: LONG POINTER] = {    OPEN LOOPHOLE[n, LongNumFormat];    LongNumber[output, c, OctalNumberFormat, clientData]; IF c > 7 THEN Char[output, 'B, clientData];    Equals[output, clientData]; LongNumber[output, c, HexNumberFormat, clientData]; IF c > 7 THEN Char[output, 'H, clientData];    Equals[output, clientData]; LongNumber[output, c, DecimalNumberFormat, clientData];    IF i < 0 THEN {Equals[output, clientData]; LongNumber[output, c, IntegerNumberFormat, clientData]};    Equals[output, clientData]; Octal[output, w1, clientData]; Char[output, ' , clientData]; Octal[output, w2, clientData];     Equals[output, clientData]; Bytes[output, b1, b2, clientData]; Char[output, ' , clientData]; Bytes[output, b3, b4, clientData] };  Text: PROC[proc: Format.StringProc, s: LONG STRING, clientData: LONG POINTER] = INLINE {    Format.Text[proc, s, clientData]};  Char: PROC[proc: Format.StringProc, char: CHARACTER, clientData: LONG POINTER] = INLINE {    Format.Char[proc, char, clientData]};  OutNumber: PROC[proc: Format.StringProc, n: UNSPECIFIED, format: Format.NumberFormat, clientData: LONG POINTER] = INLINE {    Format.Number[proc, n, format, clientData]};  LongNumber: PROC[proc: Format.StringProc, n: LONG UNSPECIFIED, format: Format.NumberFormat, clientData: LONG POINTER] = INLINE {    Format.LongNumber[proc, n, format, clientData]};  Equals: PROCEDURE[proc: Format.StringProc, clientData: LONG POINTER] = INLINE {    Text[proc, " = "L, clientData]};  Octal: PROCEDURE [proc: Format.StringProc, n: UNSPECIFIED, clientData: LONG POINTER] = INLINE {    OutNumber[proc, n, OctalNumberFormat, clientData]; IF LOOPHOLE[n, CARDINAL] > 7 THEN Char[proc, 'B, clientData]};  Hex: PROCEDURE [proc: Format.StringProc, n: UNSPECIFIED, clientData: LONG POINTER] = INLINE {    OutNumber[proc, n, HexNumberFormat, clientData]; IF LOOPHOLE[n, CARDINAL] > 7 THEN Char[proc, 'H, clientData]};  Decimal: PROCEDURE [proc: Format.StringProc, n: INTEGER, clientData: LONG POINTER] = {    OutNumber[proc, n, DecimalNumberFormat, clientData];    IF n < 0 THEN {Equals[proc, clientData]; OutNumber[proc, n, IntegerNumberFormat, clientData]}};      Bytes: PROCEDURE [proc: Format.StringProc, b1, b2: BYTE, clientData: LONG POINTER] = {    OutNumber[proc, b1, DecimalNumberFormat, clientData];     Text[proc, ",,"L, clientData];     OutNumber[proc, b2, DecimalNumberFormat, clientData]};          LengthenFob: PUBLIC PROCEDURE [h: Handle, f: Foo] = {    IP.GetValue[h, f];    IF IR.CheckLength[h, f, 2] THEN RETURN;    IF ~IR.CheckLength[h, f,1] THEN IP.AbortWithError[h, cantLengthen];    WITH IP.DIFormat[h, f.tsei].vf SELECT FROM      int => Long[h, f, TRUE];      card => Long[h, f, FALSE];      string, pointer => {	new: LONG POINTER TO LONG POINTER ¬ IO.zone.NEW[LONG POINTER ¬ WorldVMOps.Long[h.world, f.addr.base­]];	IO.zone.FREE[@f.addr.base];	f.addr.base ¬ new;	f.words ¬ 2};      ENDCASE => Long[h, f, FALSE];    f.tsei ¬ IP.MakeLongType[h, IP.TypeForSe[h, f.tsei]] };      Abs: PUBLIC PROCEDURE [h: Handle, t: Tree.Link, target: Symbols.SEIndex] = {    f: Foo ¬ IR.Son[h, t,target];    p: NumAddr;    IP.GetValue[h, f];    p ¬ LOOPHOLE[f.addr.base];    SELECT IR.NumberLength[h, f] FROM      nogood => IP.AbortWithError[h, invalidNumber];      one => IF IP.TypeForSe[h, f.tsei] = com.typeINT THEN p.pi­ ¬ ABS[p.pi­];      two =>         WITH h.seb[IP.TypeForSe[h, f.tsei]] SELECT FROM	  long => 	    SELECT IP.TypeForSe[h, rangeType] FROM 	      com.typeINT => p.pli­ ¬ ABS[p.pli­];	      ENDCASE;	  ENDCASE;       ENDCASE };      Long: PUBLIC PROCEDURE [h: Handle, f: Foo, signed: BOOLEAN] = {    new: NumAddr;    old: NumFormat ¬ LOOPHOLE[f.addr.base­];    IF f.there THEN ERROR LengtheningGarbage;    new ¬ LOOPHOLE[IO.zone.NEW[LONG UNSPECIFIED]];    IF signed THEN new.pli­ ¬ LONG[old.i] ELSE new.plc­ ¬ LONG[old.c];    IO.zone.FREE[@f.addr.base];    f.addr.base ¬ LOOPHOLE[new];    f.words ¬ 2};      Compare: PROCEDURE [h: Handle, f1, f2: Foo, size: NumberType, signed: BOOLEAN] RETURNS [res: CompResult] = {    CompareSU: PROCEDURE [p1, p2: LONG POINTER TO CARDINAL] RETURNS[CompResult] = INLINE {      RETURN[SELECT TRUE FROM p1­ < p2­ => lt, p1­ > p2­ => gt, ENDCASE => eq]};    CompareSS: PROCEDURE [p1, p2: LONG POINTER TO INTEGER] RETURNS[CompResult] = INLINE {      RETURN[SELECT TRUE FROM p1­ < p2­ => lt, p1­ > p2­ => gt, ENDCASE => eq]};    CompareLU: PROCEDURE [p1, p2: LONG POINTER TO LONG CARDINAL] RETURNS[CompResult] = INLINE {      RETURN[SELECT TRUE FROM p1­ < p2­ => lt, p1­ > p2­ => gt, ENDCASE => eq]};    CompareLS: PROCEDURE [p1, p2: LONG POINTER TO LONG INTEGER] RETURNS[CompResult] = INLINE {      RETURN[SELECT TRUE FROM p1­ < p2­ => lt, p1­ > p2­ => gt, ENDCASE => eq]};    RETURN[      SELECT Foo.NIL FROM        f1 => gt,	f2 => lt,	ENDCASE => (SELECT size FROM	  one => 	    IF signed 	    THEN CompareSS[f1.addr.base, f2.addr.base] 	    ELSE CompareSU[f1.addr.base, f2.addr.base],	  two => 	    IF signed 	    THEN CompareLS[f1.addr.base, f2.addr.base] 	    ELSE CompareLU[f1.addr.base, f2.addr.base],	  ENDCASE => ERROR IO.InvalidNumber[f1])]};      MinMax: PROC [h: Handle, size: NumberType, cnt: CARDINAL, signed: BOOLEAN, comp: CompType] = {    const: BOOLEAN;    f, current: Foo;    IF cnt = 0 THEN {IR.Push[h, NIL]; RETURN};    current ¬ IR.Pop[h];    IF ~IR.CheckLength[h, current, LOOPHOLE[size]] THEN Long[h, current, signed];    const ¬ current.constant;    FOR i: CARDINAL IN [1..cnt) DO      f ¬ IR.Pop[h];      IF ~IR.CheckLength[h, f, LOOPHOLE[size]] THEN Long[h, f, signed];      const ¬ const AND f.constant;      SELECT Compare[h, f, current, size, signed] FROM	lt => IF comp = min THEN current ¬ f;	gt => IF comp = max THEN current ¬ f;	ENDCASE;      ENDLOOP;    current.constant ¬ const;    IR.Push[h, current]};      Max: PUBLIC PROCEDURE [h: Handle, size: NumberType, cnt: CARDINAL, signed: BOOLEAN] = {    MinMax[h, size,cnt,signed,max]};      Min: PUBLIC PROCEDURE [h: Handle, size: NumberType, cnt: CARDINAL, signed: BOOLEAN] = {    MinMax[h , size,cnt,signed,min]};      Inc: PUBLIC PROC [h: Handle, f: Foo, size: NumberType, signed: BOOLEAN] = {    num: NumAddr ¬ LOOPHOLE[f.addr.base];    IF signed THEN      SELECT size FROM	one => num.pi­ ¬ num.pi­ + 1;	two => num.pli­ ¬ num.pli­ + 1;	ENDCASE => ERROR IO.InvalidNumber[f]    ELSE      SELECT size FROM	one => num.pc­ ¬ num.pc­ + 1;	two => num.plc­ ¬ num.plc­ + 1;	ENDCASE => ERROR IO.InvalidNumber[f] };      Dec: PUBLIC PROC [h: Handle, f: Foo, size: NumberType, signed: BOOLEAN] = {    num: NumAddr ¬ LOOPHOLE[f.addr.base];    IF signed THEN      SELECT size FROM	one => num.pi­ ¬ num.pi­ - 1;	two => num.pli­ ¬ num.pli­ - 1;	ENDCASE => ERROR IO.InvalidNumber[f]    ELSE      SELECT size FROM	one => num.pc­ ¬ num.pc­ - 1;	two => num.plc­ ¬ num.plc­ - 1;	ENDCASE => ERROR IO.InvalidNumber[f] };      MakeCnt: PUBLIC PROC [h: Handle, top, sub: Foo, size: NumberType, signed: BOOLEAN] = {    res: NumAddr ¬ LOOPHOLE[top.addr.base];    num: NumAddr ¬ LOOPHOLE[sub.addr.base];    IF signed THEN      SELECT size FROM	one => res.pi­ ¬ res.pi­ - num.pi­ + 1;	two => res.pli­ ¬ res.pli­ - num.pli­ + 1;	ENDCASE => ERROR IO.InvalidNumber[top]    ELSE      SELECT size FROM	one => res.pc­ ¬ res.pc­ - num.pc­ + 1;	two => res.plc­ ¬ res.plc­ - num.plc­ + 1;	ENDCASE => ERROR IO.InvalidNumber[top] };      Repr: TYPE = [none..all];    signed: CARDINAL = 1;    unsigned: CARDINAL = 2;    long: CARDINAL = 4;    other: CARDINAL = 8;            none: CARDINAL = 0;    both: CARDINAL = signed+unsigned;    all: CARDINAL = other+long+both;      -- literals  TreeLiteralValue: PROC [h: Handle, f: Foo] RETURNS [WORD] = {    n: Number = IP.GetNumber[h, f];    SELECT n.type FROM      one => RETURN[n.u];      ENDCASE => IP.AbortWithError[h, sizeMismatch];    ERROR };      LongLiteralValue: PROC [h: Handle, f: Foo] RETURNS [LONG UNSPECIFIED] = {    n: Number = IP.GetNumber[h, f];    SELECT n.type FROM      one => {LengthenFob[h, f]; RETURN[LongLiteralValue[h, f]]};      two => RETURN[n.lu];      ENDCASE => IP.AbortWithError[h, sizeMismatch];    ERROR };      MakeTreeLiteral: PROC [h: Handle, u: UNSPECIFIED, signed: BOOLEAN] = {    IR.PushVal[h, u, IF signed THEN com.typeINT ELSE com.typeCARDINAL] };      MakeLongLiteral: PROC [h: Handle, lu: LONG UNSPECIFIED, signed: BOOLEAN] =    BEGIN    IR.PushLongVal[h, lu, IF signed THEN com.typeINT ELSE com.typeCARDINAL];    END;      AddRep: PROCEDURE [h: Handle, f: Foo, op: Tree.NodeName, csei: Symbols.CSEIndex, rep: Repr]      RETURNS [Symbols.CSEIndex, Repr] =    BEGIN    new: Repr ¬ GetRep[h, f, op].rep;    islong: BOOLEAN ¬ new > long OR rep > long;    IF new > long AND rep < long THEN csei ¬ IP.MakeLongType[h, csei];    new ¬ new MOD long; rep ¬ rep MOD long;    SELECT TRUE FROM      rep = both => rep ¬ new;      rep = signed => NULL;      new = signed => rep ¬ signed;      ENDCASE => rep ¬ unsigned;    IF islong THEN rep ¬ rep + long;    RETURN[csei,rep];    END;      GetRep: PROC [h: Handle, f: Foo, op: Tree.NodeName]     RETURNS [csei: Symbols.CSEIndex, rep: Repr] = {    subtraction: BOOLEAN ¬ op = minus OR op = uminus;    n: Number ¬ IP.GetNumber[h, f];    signedNum: BOOLEAN ¬ IF n.type = one THEN n.sign ELSE n.lsign;    [csei,rep] ¬ TypedRep[h, f];    IF subtraction THEN      csei ¬ IF n.type = one THEN com.typeINT         ELSE IP.MakeLongType[h, com.typeINT];    IF op = uminus AND n.type = one AND signedNum THEN       csei ¬ IP.MakeLongType[h, com.typeINT];    SELECT rep MOD long FROM      none => NULL;      unsigned => IF subtraction THEN rep ¬ rep - 1;      signed => IF ~subtraction AND ~signedNum THEN rep ¬ rep + 2;  -- make both       both =>	IF subtraction THEN rep ¬ rep - 2	ELSE IF signedNum THEN rep ¬ rep - 1;  -- make it unsigned      ENDCASE;    IF n.type = two AND rep < long THEN rep ¬ rep + long};      TypedRep: PROC [h: Handle, f: Foo] RETURNS [csei: Symbols.CSEIndex, rep: Repr] =     BEGIN    save: Symbols.CSEIndex ¬ Symbols.CSENull;    csei ¬ IP.TypeForSe[h, f.tsei];    rep ¬ none;    DO      SELECT csei FROM	com.typeCARDINAL => rep ¬ rep + unsigned;	com.typeINT => rep ¬ rep + signed;	Symbols.typeANY => rep ¬ rep + both;	ENDCASE => {	  csei ¬ IP.TypeForSe[h, csei];	  WITH h.seb[csei] SELECT FROM	    long => {rep ¬ long; save ¬ csei; 	      csei ¬ IP.TypeForSe[h, rangeType]; LOOP};	    subrange => {save ¬ csei; csei ¬ IP.TypeForSe[h, rangeType]; LOOP};	    ref => rep ¬ rep + unsigned;	    ENDCASE => rep ¬ rep + both};      IF save # Symbols.CSENull THEN csei ¬ save;      EXIT;      ENDLOOP;    END;    -- dispatch  Mode: TYPE = {ss, su, ls, lu, other};    ModeMap: ARRAY Repr OF Mode =    [ss, ss, su, su, ls, ls, lu, lu,    other, ss, su, su, other, ls, lu, lu];      UnaryOp: ARRAY Mode OF PROC [h: Handle, node: Foo] =    [UnarySS, UnarySU, UnaryLS, UnaryLU, UnaryOpError];      BinaryOp: ARRAY Mode OF PROC [h: Handle, node: Foo, op: Tree.NodeName] =    [BinarySS, BinarySU, BinaryLS, BinaryLU, OpError];      FoldExpr: PUBLIC PROC [h: Handle, op: Tree.NodeName] =    BEGIN    left: Foo ¬ IR.Pop[h];    rep: Repr;    csei: Symbols.CSEIndex;    [csei, rep] ¬ GetRep[h, left, op];    SELECT op FROM      plus, minus, times, div, mod =>         IF left.tsei = com.typeREAL OR IR.Tos[h].tsei = com.typeREAL 	  THEN csei ¬ BinReal[h, op, left]	ELSE { 	  [csei, rep] ¬ AddRep[h, IR.Tos[h], op, csei, rep];	  BinaryOp[ModeMap[rep]][h, left, op]	  };      uminus => {        IF left.tsei = com.typeREAL THEN csei ¬ UnaryMinusReal[h, left]        ELSE UnaryOp[ModeMap[rep]][h, left];	};      ENDCASE;    IR.Tos[h].tsei ¬ csei;    END;    BinReal: PROC[h: Handle, op: Tree.NodeName, left: Foo] RETURNS[Symbols.CSEIndex] = {    ENABLE Real.RealException => RESUME[NIL];    right: Foo ¬ IR.Pop[h];    leftreal, rightreal: REAL;    leftInt: LONG INTEGER ¬ LongLiteralValue[h, left];    rightInt: LONG INTEGER ¬ LongLiteralValue[h, right];        IF left.tsei = com.typeREAL THEN leftreal ¬ LOOPHOLE[leftInt]      ELSE leftreal ¬ leftInt;    IF right.tsei = com.typeREAL THEN rightreal ¬ LOOPHOLE[rightInt]      ELSE rightreal ¬ rightInt;          SELECT op FROM      plus => leftreal ¬ Real.FAdd[leftreal, rightreal];       minus => leftreal ¬ Real.FSub[leftreal, rightreal];      times => leftreal ¬ Real.FMul[leftreal, rightreal];      div => leftreal ¬ Real.FDiv[leftreal, rightreal];      mod => IP.AbortWithError[h, overflow];      ENDCASE => ERROR;    IR.PushLongVal[h, leftreal, com.typeREAL];    RETURN[com.typeREAL]    };      UnaryMinusReal: PROC[h: Handle, left: Foo] RETURNS[Symbols.CSEIndex] = {    lu: LONG UNSPECIFIED ¬ LongLiteralValue[h, left];    zero: REAL = 0.0;    real: REAL;    real ¬ Real.FSub[zero, LOOPHOLE[lu] ! Real.RealException => RESUME[NIL]];    IR.PushLongVal[h, real, com.typeREAL];    RETURN[com.typeREAL]    };          -- operations    MinSS: INTEGER = FIRST[INTEGER];  MaxSS: INTEGER = LAST[INTEGER];  LastInt: CARDINAL = MaxSS;      UnarySS: PROC [h: Handle, node: Foo] =    BEGIN    unspec: CARDINAL = TreeLiteralValue[h, node];    IF unspec <= LastInt THEN {      int: INTEGER = unspec;      MakeTreeLiteral[h, -int,TRUE]}    ELSE {      longunspec: LONG UNSPECIFIED = LONG[unspec];      longint: LONG INTEGER = longunspec;       MakeLongLiteral[h, -longint,TRUE]};    IR.Tos[h].constant ¬ node.constant;    END;      BinarySS: PROC [h: Handle, node: Foo, op: Tree.NodeName] =    BEGIN    rhs: Foo ¬ IR.Pop[h];    v: INTEGER;    v1: INTEGER = TreeLiteralValue[h, node];    v2: INTEGER = TreeLiteralValue[h, rhs];    SELECT op FROM      plus =>	IF (IF v1 >= 0 THEN v2 <= MaxSS-v1 ELSE v2 >= MinSS-v1)	  THEN  v ¬ v1 + v2	  ELSE  GO TO Overflow;      minus =>	IF (IF v1 >= 0 THEN v1-MaxSS <= v2 ELSE v1-MinSS >= v2)	  THEN  v ¬ v1 - v2	  ELSE  GO TO Overflow;      times =>	IF (SELECT TRUE FROM	    (v1 > 0) AND (v2 > 0) => v2 <= MaxSS / v1,	    (v1 > 0) AND (v2 < 0) => v2 >= MinSS / v1,	    (v1 < 0) AND (v2 > 0) => v1 >= MinSS / v2,	    (v1 < 0) AND (v2 < 0) =>		v1 # MinSS AND v2 # MinSS AND v2 >= MaxSS / v1,	    ENDCASE => TRUE)	  THEN  v ¬ v1 * v2	  ELSE GO TO Overflow;      div =>	IF v2 # 0 AND (v2 # -1 OR v1 # MinSS)	  THEN  v ¬ v1 / v2	  ELSE  GO TO Overflow;      mod =>	IF v2 # 0 THEN v ¬ v1 MOD v2 ELSE GO TO Overflow;      ENDCASE => ERROR;    MakeTreeLiteral[h, v,TRUE];    IR.Tos[h].constant ¬ node.constant AND rhs.constant;    EXITS      Overflow => IP.AbortWithError[h, overflow];    END;          MaxSU: CARDINAL = LAST[CARDINAL];    UnarySU: PROC [h: Handle, node: Foo] =    BEGIN    v1: CARDINAL = TreeLiteralValue[h, node];    IF v1 # 0 THEN IP.AbortWithError[h, overflow];    MakeTreeLiteral[h, v1,FALSE];    IR.Tos[h].constant ¬ node.constant;    END;      BinarySU: PROC [h: Handle, node: Foo, op: Tree.NodeName] =    BEGIN    rhs: Foo ¬ IR.Pop[h];    v: CARDINAL;    v1: CARDINAL = TreeLiteralValue[h, node];    v2: CARDINAL = TreeLiteralValue[h, rhs];    SELECT op FROM      plus =>  IF v2 <= MaxSU-v1 THEN v ¬ v1 + v2 ELSE GO TO Overflow;      minus => IF v1 >= v2 THEN v ¬ v1 - v2 ELSE GO TO Overflow;      times =>	IF v1 = 0 OR v2 <= MaxSU/v1 THEN v ¬ v1 * v2 ELSE GO TO Overflow;      div =>   IF v2 # 0 THEN v ¬ v1 / v2 ELSE GO TO Overflow;      mod =>   IF v2 # 0 THEN v ¬ v1 MOD v2 ELSE GO TO Overflow;      ENDCASE => ERROR;    MakeTreeLiteral[h, v,FALSE];    IR.Tos[h].constant ¬ node.constant AND rhs.constant;    EXITS      Overflow => IP.AbortWithError[h, overflow];    END;          MinLS: LONG INTEGER = FIRST[LONG INTEGER];  MaxLS: LONG INTEGER = LAST[LONG INTEGER];    UnaryLS: PROC [h: Handle, node: Foo] =    BEGIN    v: LONG INTEGER;    v1: LONG INTEGER = LongLiteralValue[h, node];    IF v1 # MinLS THEN v ¬ -v1 ELSE IP.AbortWithError[h, overflow];    MakeLongLiteral[h, v, TRUE];    IR.Tos[h].constant ¬ node.constant;    END;      BinaryLS: PROC [h: Handle, node: Foo, op: Tree.NodeName]  =    BEGIN    rhs: Foo ¬ IR.Pop[h];    v: LONG INTEGER;    v1: LONG INTEGER = LongLiteralValue[h, node];    v2: LONG INTEGER = LongLiteralValue[h, rhs];    SELECT op FROM      plus =>	IF (IF v1 >= 0 THEN v2 <= MaxLS-v1 ELSE v2 >= MinLS-v1)	  THEN  v ¬ v1 + v2	  ELSE  GO TO Overflow;      minus =>	IF (IF v1 >= 0 THEN v1-MaxLS <= v2 ELSE v1-MinLS >= v2)	  THEN  v ¬ v1 - v2	  ELSE  GO TO Overflow;      times =>	IF (SELECT TRUE FROM	    (v1 > 0) AND (v2 > 0) => v2 <= MaxLS / v1,	    (v1 > 0) AND (v2 < 0) => v2 >= MinLS / v1,	    (v1 < 0) AND (v2 > 0) => v1 >= MinLS / v2,	    (v1 < 0) AND (v2 < 0) =>		v1 # MinLS AND v2 # MinLS AND v2 >= MaxLS / v1,	    ENDCASE => TRUE)	  THEN  v ¬ v1 * v2	  ELSE GO TO Overflow;      div =>	IF v2 # 0 AND (v2 # -1 OR v1 # MinLS)	  THEN  v ¬ v1 / v2	  ELSE  GO TO Overflow;      mod =>	IF v2 # 0 THEN v ¬ v1 MOD v2 ELSE GO TO Overflow;      ENDCASE => ERROR;    MakeLongLiteral[h, v, TRUE];    IR.Tos[h].constant ¬ node.constant AND rhs.constant;    EXITS      Overflow => IP.AbortWithError[h, overflow];    END;          MaxLU: LONG CARDINAL = LAST[LONG CARDINAL];    UnaryLU: PROC [h: Handle, node: Foo] =    BEGIN    v1: LONG CARDINAL = LongLiteralValue[h, node];    IF v1 # 0 THEN IP.AbortWithError[h, overflow];    MakeLongLiteral[h, v1,FALSE];    IR.Tos[h].constant ¬ node.constant;    END;      BinaryLU: PROC [h: Handle, node: Foo, op: Tree.NodeName] =    BEGIN    rhs: Foo ¬ IR.Pop[h];    v: LONG CARDINAL;    v1: LONG CARDINAL = LongLiteralValue[h, node];    v2: LONG CARDINAL = LongLiteralValue[h, rhs];    SELECT op FROM      plus =>  IF v2 <= MaxLU-v1 THEN v ¬ v1 + v2 ELSE GO TO Overflow;      minus => IF v1 >= v2 THEN v ¬ v1 - v2 ELSE GO TO Overflow;      times =>	IF v1 = 0 OR v2 <= MaxLU/v1 THEN v ¬ v1 * v2 ELSE GO TO Overflow;      div =>   IF v2 # 0 THEN v ¬ v1 / v2 ELSE GO TO Overflow;      mod =>   IF v2 # 0 THEN v ¬ v1 MOD v2 ELSE GO TO Overflow;      ENDCASE => ERROR;    MakeLongLiteral[h, v,FALSE];    IR.Tos[h].constant ¬ node.constant AND rhs.constant;    EXITS      Overflow => IP.AbortWithError[h, overflow];    END;      OpError: PROC [h: Handle, node: Foo, op: Tree.NodeName] = {    IP.AbortWithError[h, overflow]};  UnaryOpError: PROC [h: Handle, node: Foo] = {    IP.AbortWithError[h, overflow]};    }.
-- File: TraceImplB.mesa - last edit:-- Litman               9-May-87 18:49:12-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.DIRECTORYAMEvents,Inline,WorldVMOps, IO, IP, IT,String,Watch USING [];TraceImplB: PROGRAM   IMPORTS AMEvents, Inline, String, WorldVMOps, IO, IP  EXPORTS Watch = {  StartTraceArgSize: CARDINAL =     SIZE[LONG POINTER] + SIZE[UNSPECIFIED] + SIZE[WORD] + SIZE[BOOLEAN];  StartTraceResSize: CARDINAL = 0;  StartWatchArgSize: CARDINAL = SIZE[LONG POINTER];  StartWatchResSize: CARDINAL = 0;  StopTraceArgSize: CARDINAL = 0;  StopTraceResSize: CARDINAL = 0;  NonLocalStartTrace: PUBLIC PROC [h: IT.Handle, loc: LONG POINTER,     val: UNSPECIFIED, mask: WORD, equal: BOOLEAN]     RETURNS[success: BOOLEAN] = {    argWords: AMEvents.ArgsOrResults ¬ IO.zone.NEW[AMEvents.WordSeq[StartTraceArgSize]];    resWords: AMEvents.ArgsOrResults ¬ IO.zone.NEW[AMEvents.WordSeq[StartTraceResSize]];    argWords[0] ¬ Inline.LowHalf[loc];    argWords[1] ¬ Inline.HighHalf[loc];    argWords[2] ¬ val;    argWords[3] ¬ mask;    argWords[4] ¬ LOOPHOLE[equal];    success ¬ ApplyProcedure[h, "StartTrace"L, argWords, resWords];    IO.zone.FREE[@argWords];    IO.zone.FREE[@resWords] };  NonLocalStartWatch: PUBLIC PROC [h: IT.Handle, loc: LONG POINTER]     RETURNS[success: BOOLEAN] = {    argWords: AMEvents.ArgsOrResults ¬ IO.zone.NEW[AMEvents.WordSeq[StartWatchArgSize]];    resWords: AMEvents.ArgsOrResults ¬ IO.zone.NEW[AMEvents.WordSeq[StartWatchResSize]];    argWords[0] ¬ Inline.LowHalf[loc];    argWords[1] ¬ Inline.HighHalf[loc];    success ¬ ApplyProcedure[h, "StartWatch"L, argWords, resWords];    IO.zone.FREE[@argWords];    IO.zone.FREE[@resWords] };  NonLocalStopTrace: PUBLIC PROC[h: IT.Handle]     RETURNS[success: BOOLEAN] = {    argWords: AMEvents.ArgsOrResults ¬ IO.zone.NEW[AMEvents.WordSeq[StopTraceArgSize]];    resWords: AMEvents.ArgsOrResults ¬ IO.zone.NEW[AMEvents.WordSeq[StopTraceResSize]];    success ¬ ApplyProcedure[h, "StopTrace"L, argWords, resWords];    IO.zone.FREE[@argWords];    IO.zone.FREE[@resWords] };      ApplyProcedure: PROC[h: IT.Handle, proc: LONG STRING,     argWords, resWords: AMEvents.ArgsOrResults]     RETURNS[success: BOOLEAN] = {    ev: IT.EVIndex;    pc: IT.BytePC;    cl: IT.ControlLink;    gf: IT.GFHandle = IP.GFrame[h, "TraceImpl"L ! IP.MultipleFrames => GOTO Failed];    IF gf = NIL THEN { IO.Line[h, " TraceImpl not found!"L]; GOTO Failed };    ev ¬ EntryPointForProc[proc];    pc ¬ IP.GetPc[h, gf, ev];    cl ¬ WorldVMOps.MakeControlLink[h.world, gf, pc];    AMEvents.ApplyProcedure[h.world, cl, argWords, resWords       ! AMEvents.BadResStack => CONTINUE];    RETURN[TRUE];    EXITS Failed => RETURN[FALSE] };      « WARNING. THIS PROCEDURE KNOWS ABOUT THE INTERNALS OF TraceImpl!! »    EntryPointForProc: PROC[proc: LONG STRING] RETURNS[ev: IT.EVIndex] = {    RETURN[SELECT TRUE FROM      String.Equal[proc, "StartTrace"L] => 1,      String.Equal[proc, "StartWatch"L] => 3,      String.Equal[proc, "StopTrace"L] => 4,      ENDCASE => ERROR] };  }.
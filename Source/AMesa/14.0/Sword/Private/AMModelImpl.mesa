-- File: AMModelImpl.mesa - last edit:-- Litman              22-Oct-87 14:01:04-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.DIRECTORY  AMLoadstate USING [BcdProc, EnumerateBcds, EnumerateModulesInConfig, GFHandle, Handle, MapConfigToReal, ModuleProc],  AMModel USING [ChildProc, Class, Context, GFHandle, IsNullContext, nullContext, Section],  AMUseful USING [CtiName, GFHandle, ModuleName, NoConfig, OuterConfig],  BcdOpsExtras USING [gfiOrigin],  Format USING [Char, LongNumber, Number, StringProc],  String USING [AppendString, Equal],  WorldVM USING [World, WorldName],  WorldVMOps USING [GetLoadstate, GFlong];AMModelImpl: PROGRAM   IMPORTS AMModel, AMLoadstate, AMUseful, Format, String, WorldVM, WorldVMOps   EXPORTS AMModel = {    RootContext: PUBLIC PROC[world: WorldVM.World] RETURNS[AMModel.Context] = {    RETURN[[world, world[]]]};      ContextWorld: PUBLIC PROC[context: AMModel.Context] RETURNS[WorldVM.World] = {    RETURN[context.world]};      ContextClass: PUBLIC PROC[context: AMModel.Context] RETURNS[AMModel.Class] = {    RETURN[context.tag]};    AppendLongNumber: PROC[string: LONG STRING, val: LONG UNSPECIFIED, radix: CARDINAL] = {    Output: Format.StringProc = { String.AppendString[to: string, from: s] };    Format.LongNumber[Output, val, [radix, FALSE, TRUE, 0]];    SELECT radix FROM      8 => IF val ~IN[0..7] THEN Format.Char[Output, 'B];      16 => IF val ~IN[0..9] THEN Format.Char[Output, 'H];      ENDCASE };      AppendNumber: PROC[string: LONG STRING, val: UNSPECIFIED, radix: CARDINAL] = {    Output: Format.StringProc = { String.AppendString[to: string, from: s] };    Format.Number[Output, val, [radix, FALSE, TRUE, 0]];    SELECT radix FROM      8 => IF val ~IN[0..7] THEN Format.Char[Output, 'B];      16 => IF val ~IN[0..9] THEN Format.Char[Output, 'H];      ENDCASE };  ContextName: PUBLIC PROC[context: AMModel.Context, name: LONG STRING, radix: CARDINAL ¬ 10] = {    WITH context SELECT FROM      world => String.AppendString[name, WorldVM.WorldName[context.world]];       model => { -- <configName>:ConfigIndex#<index in loadstate>  	AMUseful.CtiName[world, [index, AMUseful.OuterConfig], name 	  ! AMUseful.NoConfig => { 	    anyCgfi: NATURAL = BcdOpsExtras.gfiOrigin;	    anyGfh: AMModel.GFHandle = WorldVMOps.GFlong[context.world, AMLoadstate.MapConfigToReal[WorldVMOps.GetLoadstate[context.world], anyCgfi, index]];	    AMUseful.ModuleName[world, anyGfh, name]; CONTINUE }];	String.AppendString[name, ", Config:"L];	AppendNumber[name, index, radix]};      prog => { -- <progName>:gfh#<gfh>         AMUseful.ModuleName[world, gf, name];	String.AppendString[name, ", G:"L];	AppendLongNumber[name, gf, radix]};      interface => -- <interface name>        ERROR; «STUB»        proc => -- <procName>:fh#<fh>         ERROR; «STUB»       statement => -- <ContextName[proc]>:FGT#<index in fgt>         ERROR; «STUB»       none =>         ERROR; «STUB»       ENDCASE};« Enumerator. For world, calls ChildProc for every bcdInfo in the loadstate. For model, calls ChildProc for every module in the configuration.»  ContextChildren: PUBLIC PROC[context: AMModel.Context, p: AMModel.ChildProc] RETURNS[ans: AMModel.Context ¬ AMModel.nullContext] = {    WITH context SELECT FROM      world => {        DoBcd: AMLoadstate.BcdProc = {	  cont: AMModel.Context ¬ [context.world, model[index]]; 	  IF p[cont] THEN {ans ¬ cont; RETURN[TRUE]} ELSE RETURN[FALSE]};	[] ¬ AMLoadstate.EnumerateBcds[WorldVMOps.GetLoadstate[context.world], DoBcd, TRUE]};      model => {        DoModule: AMLoadstate.ModuleProc  = {	  cont: AMModel.Context ¬ [context.world, prog[WorldVMOps.GFlong[context.world, modInfo.gf]]];	  IF p[cont] THEN {ans ¬ cont; RETURN[TRUE]} ELSE RETURN[FALSE]};	[] ¬ AMLoadstate.EnumerateModulesInConfig[WorldVMOps.GetLoadstate[context.world], DoModule, index]};      prog =>         ERROR; «STUB»      interface =>         ERROR; «STUB»        proc =>          ERROR; «STUB»       statement =>          ERROR; «STUB»       none =>         ERROR; «STUB»       ENDCASE => ERROR };«EXAMPLE USAGE: given a module name and a world context, this returns a Context for the most recently loaded global frame for a program with that name. name must identify a model or prog (someday interface) if context identifies a world, or a prog (someday interface) if context identifies a model. The format of the name should be the same as that produced by ContextName, with elided fields meaning don't care. The result will be either a model or prog (someday interface) context.»  MostRecentNamedContext: PUBLIC PROC[name: LONG STRING,     context: «world or model» AMModel.Context] RETURNS[ans: AMModel.Context] = {    FindName: AMModel.ChildProc = {      fancyName: LONG STRING ¬ [60];      ContextName[c, fancyName];      Filter[fancyName];      IF String.Equal[fancyName, name] THEN { ans ¬ c; RETURN[TRUE] }      ELSE         WITH c SELECT FROM          model => {	    [] ¬ ContextChildren[c, FindName];	    RETURN[~AMModel.IsNullContext[ans]]};          ENDCASE => RETURN[FALSE]};    ans ¬ AMModel.nullContext;    [] ¬ ContextChildren[context, FindName]};      Filter: PROC[s: LONG STRING] = INLINE {    FOR i: CARDINAL IN [0..s.length) DO       IF s[i] = ', THEN { s.length ¬ i; EXIT };       ENDLOOP };    NextSection: PUBLIC PROC[section: AMModel.Section] RETURNS[AMModel.Section] = {     ERROR };      NoNextSection: PUBLIC ERROR = CODE;  }..  
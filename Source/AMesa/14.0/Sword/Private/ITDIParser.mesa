-- Copyright (C) 1985  by Xerox Corporation. All rights reserved. -- ITDIParser.mesaDIRECTORY  ITDIGrammar USING [],  IO, IS, IT,  Inline USING [LongCOPY],  ITDIParseTable USING [    ActionEntry, ActionTag, DefaultMarker, FinalState, InitialState,     NActionsRef, NLengthsRef, NStartsRef, NSymbolsRef, NTDefaultsRef,     ProdDataRef, State, TableRef, TActionsRef, TIndex, TLengthsRef,     TStartsRef, TSymbol, TSymbolsRef],  Runtime USING [GlobalFrame, GetTableBase];ITDIParser: PROGRAM   IMPORTS ITDIGrammar, IO, IS, Inline, Runtime EXPORTS IO, IS =  BEGIN OPEN IT;  ParseError: PUBLIC SIGNAL [errorLoc: CARDINAL] = CODE;  SyntaxError: PUBLIC SIGNAL [errorLoc: CARDINAL] = CODE;    InputLoc: PUBLIC PROCEDURE[h: Handle] RETURNS [CARDINAL] = {    RETURN [h.inputLoc]};  Parse: PUBLIC PROCEDURE [h: Handle, string: LONG STRING]     RETURNS [complete: BOOLEAN] =    BEGIN OPEN h;    i, valid, k, m: CARDINAL;		-- stack pointers    j, j0: CARDINAL;    tj: ITDIParseTable.ActionEntry;    IF string = NIL THEN RETURN[FALSE];    ParseInit[h];    IS.ScanInit[h, string];    i ¬ top ¬ valid ¬ qI ¬ 0;    s[0] ¬ currentState ¬ ITDIParseTable.InitialState;    [inputSymbol, inputValue, inputLoc] ¬ IS.Atom[h].symbol;    WHILE currentState # ITDIParseTable.FinalState DO      j0 ¬ tStart[currentState];      FOR j IN [j0 .. j0 + tLength[currentState]) DO	SELECT tSymbol[j] FROM	  inputSymbol, ITDIParseTable.DefaultMarker => EXIT;	  ENDCASE;	REPEAT	  FINISHED => ERROR SyntaxError[inputLoc];	ENDLOOP;      tj ¬ tAction[j];       IF ~tj.tag.reduce	-- scan or scan reduce entry -- THEN {	  IF qI > 0 THEN {	      FOR k IN (valid..i] DO s[k] ¬ s[top+(k-valid)] ENDLOOP;	      IS.ProcessQueue[h 	        ! ParseError => ERROR SyntaxError[inputLoc]];	      qI ¬ 0};	  top ¬ valid ¬ i ¬ i+1;	  v[i] ¬ inputValue;  l[i] ¬ inputLoc;	  [inputSymbol,inputValue,inputLoc]  ¬ IS.Atom[h].symbol};      WHILE tj.tag # ITDIParseTable.ActionTag[FALSE, 0] DO	IF qI >= queueSize THEN ExpandQueue[h, 128];	q[qI] ¬ tj;  qI ¬ qI + 1;	i ¬ i-tj.tag.pLength;	-- pop 1 state per rhs symbol	currentState ¬ s[IF i > valid THEN top+(i-valid) ELSE (valid ¬ i)];	lhs ¬ proddata[tj.transition].lhs;	  BEGIN	  IF currentState <= lastntstate THEN {	      j ¬ nStart[currentState];	      FOR j IN [j..j+nLength[currentState]) DO		IF lhs = nSymbol[j] THEN {tj ¬ nAction[j]; GO TO nfound};		ENDLOOP};	  tj ¬ ntDefaults[lhs];	  EXITS	    nfound => NULL;	  END;	i ¬ i+1;	ENDLOOP;      IF (m ¬ top+(i-valid)) >= stackSize THEN ExpandStack[h, 32];      s[m] ¬ currentState ¬ tj.transition;    ENDLOOP;    IS.ProcessQueue[h ! ParseError => ERROR SyntaxError[inputLoc]];    RETURN [IS.ScanReset[h]]    END;  ExpandStack: PROCEDURE [h: Handle, delta: CARDINAL] = {    newSize: CARDINAL = h.stackSize + delta;    sS: CARDINAL = newSize*SIZE[ITDIParseTable.State];    sL: CARDINAL = newSize*SIZE[CARDINAL];    sV: CARDINAL = newSize*SIZE[UNSPECIFIED];    newS: SRef ¬ IO.Node[h, sS+sL+sV];    newL: LRef ¬ LOOPHOLE[newS, LONG POINTER]+sS;    newV: VRef ¬ newL+sL;    IF h.stackSize # 0 THEN {      Inline.LongCOPY[from: h.s, nwords: h.stackSize, to: newS];      Inline.LongCOPY[from: h.l, nwords: h.stackSize, to: newL];      Inline.LongCOPY[from: h.v, nwords: h.stackSize, to: newV];      IO.FreeNode[h, h.s]};    h.s ¬ newS;  h.l ¬ newL;  h.v ¬ newV;  h.stackSize ¬ newSize};  ExpandQueue: PROCEDURE [h: Handle, delta: CARDINAL] = {    newSize: CARDINAL = h.queueSize + delta;    newQ: QRef ¬ IO.Node[h, newSize*SIZE[ITDIParseTable.ActionEntry]];    IF h.queueSize # 0 THEN {      Inline.LongCOPY[        from: h.q, nwords: h.queueSize*SIZE[ITDIParseTable.ActionEntry], to: newQ];      IO.FreeNode[h, h.q]};    h.q ¬ newQ;  h.queueSize ¬ newSize};  ParseInit: PUBLIC PROC[h: Handle] = {    h.stackSize ¬ h.queueSize ¬ 0;    ExpandStack[h, 32];  ExpandQueue[h, 128]};      tStart: ITDIParseTable.TStartsRef ¬ NIL;  tLength: ITDIParseTable.TLengthsRef ¬ NIL;  tSymbol: ITDIParseTable.TSymbolsRef ¬ NIL;  tAction: ITDIParseTable.TActionsRef ¬ NIL;  nStart: ITDIParseTable.NStartsRef ¬ NIL;  nLength: ITDIParseTable.NLengthsRef ¬ NIL;  nSymbol: ITDIParseTable.NSymbolsRef ¬ NIL;  nAction: ITDIParseTable.NActionsRef ¬ NIL;  ntDefaults: ITDIParseTable.NTDefaultsRef ¬ NIL;  proddata: ITDIParseTable.ProdDataRef ¬ NIL;  InitParseTables: PROC[] = {    table: ITDIParseTable.TableRef ¬       Runtime.GetTableBase[Runtime.GlobalFrame[ITDIGrammar]];    tStart ¬ @table[table.parseTable.tStart];    tLength ¬ @table[table.parseTable.tLength];    tSymbol ¬ @table[table.parseTable.tSymbol];    tAction ¬ @table[table.parseTable.tAction];    nStart ¬ @table[table.parseTable.nStart];    nLength ¬ @table[table.parseTable.nLength];    nSymbol ¬ @table[table.parseTable.nSymbol];    nAction ¬ @table[table.parseTable.nAction];    ntDefaults ¬ @table[table.parseTable.ntDefaults];    proddata ¬ @table[table.parseTable.prodData];    IS.QueueInit[proddata]};      InitParseTables[];      END.
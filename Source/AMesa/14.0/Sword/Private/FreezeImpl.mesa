-- File: FreezeImpl.mesa - last edit:-- Litman              15-Apr-87 14:49:21-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.DIRECTORY  Frame USING [Free, GetReturnFrame, MyLocalFrame, SetReturnLink],  Freeze USING [FreezableProcesses, Frozen, qFreeze],  PrincOps USING [ControlLink, LocalFrameHandle, StateVector],  PrincOpsExtras USING [nullShortLink, SourceDest],  ProcessOperations USING [DisableInterrupts, EnableInterrupts, HandleToIndex, ReadPSB, Requeue],  PSB USING [PDA, PsbIndex, QueueHandle],  SDDefs USING [SD],  SpecialSpace USING [MakeGlobalFrameResident, MakeGlobalFrameSwappable, MakeProcedureResident, MakeProcedureSwappable, SpecialError];FreezeImpl: PROGRAM   IMPORTS Frame, ProcessOperations, SpecialSpace  EXPORTS Freeze = {« The freezer is put into SDDefs.SD[205B].The freezeesTable is put into SDDefs.SD[206B].They are in SD for non-local debugger access (also maybe for microcode access).The freezer is the permanent frame for FreezingPoint (there's only one).There is one FreezeTrapFrame instance for each frozen process.Each frozen process gets an instance of FreezeTrapFrame, which gets putinto freezeesTable[process]. So when you get frozen:1. someone puts a returnlink to the freezer in your callstack somewhere.2. they put your old returnlink into the freezeesTable.3. they let you run.4. you eventually follow returnlink to the freezer.5. In the freezer, DisableInterrupts, save STATE, allocate FreezeTrapFrame.6. In FreezeTrapFrame, copy STATE.7. In FreezeTrapFrame, set FreezeTrapFrame returnlink to freezeesTable.8. In FreezeTrapFrame, set freezeesTable to FreezeTrapFrame.9. Go back to the freezer.10. In the freezer, EnableInterrupts.11. In the freezer, Requeue current process from readyQueue to freezeQueue.So when you get thawed:1. someone requeues your process from freezeQueue to readyQueue.2. you start to run in FreezeTrapFrame.3. resume STATE.4. return to client code, free FreezeTrapFrame.5. set freezeesTable to null. »  freezeesTable: PUBLIC Freeze.Frozen ¬ ALL[PrincOpsExtras.nullShortLink];  freezer: PUBLIC PrincOps.LocalFrameHandle;    FreezingPoint: PROC RETURNS[PrincOps.LocalFrameHandle] = {    freezeQueue: PSB.QueueHandle = @PSB.PDA.fault[Freeze.qFreeze].queue;    state: RECORD[pad: LONG CARDINAL, v: PrincOps.StateVector.dst];    Caller: PROC[PrincOps.LocalFrameHandle] = LOOPHOLE[PrincOps.ControlLink[frame[Frame.GetReturnFrame[]]]];    Caller[Frame.MyLocalFrame[]];    ProcessOperations.DisableInterrupts[];    DO      state.v ¬ STATE;      FreezeTrapFrame[@state.v];      ProcessOperations.EnableInterrupts[];      ProcessOperations.Requeue[@PSB.PDA.ready, freezeQueue, ProcessOperations.ReadPSB[]];      ProcessOperations.DisableInterrupts[];      ENDLOOP };      FreezeTrapFrame: PROC[sv: POINTER TO PrincOps.StateVector.dst] = {    -- executed with interrupts disabled --    state: RECORD[pad: LONG CARDINAL, v: PrincOps.StateVector.dst];    sourceDest: PrincOpsExtras.SourceDest;    Caller: PROC = LOOPHOLE[PrincOps.ControlLink[frame[Frame.GetReturnFrame[]]]];    psbi: PSB.PsbIndex = ProcessOperations.HandleToIndex[ProcessOperations.ReadPSB[]];    IF psbi > Freeze.FreezableProcesses.LAST THEN ERROR;    state.v ¬ sv^;    Frame.SetReturnLink[freezeesTable[psbi]];    freezeesTable[psbi] ¬ [frame[Frame.MyLocalFrame[]]];    Caller[];    sourceDest.dest ¬ [frame[Frame.GetReturnFrame[]]];    sourceDest.source ¬ PrincOpsExtras.nullShortLink;    STATE ¬ state.v;    RETURN WITH sourceDest };    PrepareToUnload: PUBLIC PROC[] = {    Frame.Free[freezer];    SDDefs.SD[205B] ¬ SDDefs.SD[206B] ¬ 0;    SpecialSpace.MakeGlobalFrameSwappable[FreezeImpl ! SpecialSpace.SpecialError => CONTINUE];    SpecialSpace.MakeProcedureSwappable[LOOPHOLE[FreezingPoint] ! SpecialSpace.SpecialError => CONTINUE];    SpecialSpace.MakeProcedureSwappable[LOOPHOLE[FreezeTrapFrame] ! SpecialSpace.SpecialError => CONTINUE] };  SDDefs.SD[205B] ¬ LONG[freezer ¬ FreezingPoint[]];  SDDefs.SD[206B] ¬ @freezeesTable;   SpecialSpace.MakeProcedureResident[LOOPHOLE[FreezingPoint] ! SpecialSpace.SpecialError => IF error = alreadyResident THEN CONTINUE];  SpecialSpace.MakeProcedureResident[LOOPHOLE[FreezeTrapFrame] ! SpecialSpace.SpecialError => IF error = alreadyResident THEN CONTINUE];  SpecialSpace.MakeGlobalFrameResident[FreezeImpl];  }.
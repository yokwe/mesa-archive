-- File: AMEventsImplA.mesa - last edit:-- Litman              21-Apr-87 23:45:51-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.DIRECTORY  AMEvents USING [ArgsOrResults, BootedNotifier, BreakID, BreakRec, BytePC, ControlLink, Event, EventProc, EventRec, LFHandle, Outcome, Process, SignalDesc, World],  AMEventsBackdoor USING [BreakEvent, BreakRec, BYTE, BytePC, ConditionTrue, ContinueFromBreak, FlushBreaks],  AMHeap USING [zone],  AMProcess USING [Process],  CPSwapDefs USING [ExternalStateVector, SignalError, StorageFaultType, SwapData, SwapInfo, SwapReason],  FastBreak USING [FastBreakHandler, SpecifyDefaultBreakHandler],  Frame USING [Alloc, Free, GetReturnFrame, GetReturnLink, MyLocalFrame, ReadGlobalLink, ReadPC, ReadReturnLink, SetReturnFrame, SetReturnLink, WriteReturnLink],  FrameExtras USING [GFTHandleToLongGF],  Freeze USING [PrepareToUnload],  Inline USING [LongCOPY],  Mopcodes USING [zBRK, zRET],  PrincOps USING [BYTE, BytePC, ControlLink, FrameSizeIndex, FrameVec, LocalFrameHandle, LocalOverhead, MaxParamsInStack, NullLink, NullLocalFrame, ShortControlLink, StateVector],  PrincOpsExtras USING [SignalDesc, SourceDest],  Process USING [Abort, Detach, GetCurrent],  ProcessOperations USING [HandleToIndex, ProcessFromIndex, ReadPSB],  PSB USING [PDA],  Runtime USING [CallDebugger],  RuntimeError USING [BreakProc, CDProc, FaultProc, InformationalSignal, PrepareToUnload, RegisterCallDebugHandler, RegisterFaultHandler, RegisterUncaughtSignalHandler, UCSProc, UNCAUGHT],  SDDefs USING [sBreakTrap, SD, sSignal, sSignalList],  SpecialRuntimeExtras USING [ProgramFromGlobalFrame],  TemporaryBooting USING [BootButton],  VM USING [AbortFaultedProcess],  WorldVM USING [AfterHeraldBoot, BadWorld, BeforeHeraldBoot, CurrentOutloadWorld, Go, LocalWorld, World],  WorldVMExtras2,  WorldVMOps USING [Address, BYTE, BytePC, CodebaseFromGf, ControlLink, CopyRead, GetESV, GetType, GFFromControlLink, GFlong, GFshort, LFlong, LFshort, Long, Process, ProcessLong, ProcessShort, ReadCodeByte],  WVMBooting USING [CheckpointProc, Deregister, RegisterProcs, RollbackProc];AMEventsImplA: MONITOR    IMPORTS AMEventsBackdoor, AMHeap, FastBreak, Frame, FrameExtras, Freeze, Inline, Process, ProcessOperations, Runtime, RuntimeError, SpecialRuntimeExtras, TemporaryBooting, VM, WorldVM, WorldVMExtras2, WorldVMOps, WVMBooting  EXPORTS AMEvents = {  BreakID: TYPE = LONG POINTER TO BreakRec;  BreakRec: PUBLIC TYPE = AMEventsBackdoor.BreakRec;    LFHandle: TYPE = AMEvents.LFHandle;  ControlLink: TYPE = AMEvents.ControlLink;  BytePC: TYPE = AMEvents.BytePC;  NullLink: ControlLink = LOOPHOLE[PrincOps.NullLink];  BYTE: TYPE = PrincOps.BYTE;  swapInfoAddr: LONG POINTER TO CPSwapDefs.SwapInfo = LOOPHOLE[@PSB.PDA.available];      actors: Actor ¬ NIL;  -- the list of event watchers  localActor: Actor ¬ NIL; -- event watcher for local world  clientChanged: CONDITION; -- notified when any actor's level, bootCount, or running changes.  oldCatcher: RuntimeError.UCSProc ¬ NIL;  oldBreaker: RuntimeError.BreakProc ¬ NIL;  oldBreak: PROC ¬ NIL;  oldFaulter: RuntimeError.FaultProc ¬ NIL;  oldCallDebug: RuntimeError.CDProc ¬ NIL;    getLocalSignals: BOOLEAN ¬ FALSE;   getLocalBreaks: BOOLEAN ¬ FALSE;  getLocalFaults: BOOLEAN ¬ FALSE;  getLocalCallDebug: BOOLEAN ¬ FALSE;    bootedNotifierRegistry: BootedNotifierRegistry ¬ NIL;  BootedNotifierRegistry: TYPE = LONG POINTER TO BNRec;    BNRec: TYPE = RECORD[    proc: AMEvents.BootedNotifier,    world: WorldVM.World,    clientData: LONG POINTER,    rest: BootedNotifierRegistry];    zone: UNCOUNTED ZONE = AMHeap.zone;  localWorld: WorldVM.World = WorldVM.LocalWorld[];      supressUncaughtAborted: BOOL = FALSE;  crashOnRecursiveAppearance: BOOL = TRUE;  informing: BOOLEAN = FALSE;     Debugging: --INFORMATIONAL-- PUBLIC SIGNAL = CODE;  Debugged: --INFORMATIONAL-- PUBLIC SIGNAL = CODE;  BadControlLink: PUBLIC ERROR = CODE; -- "control" had wrong type class  BadArgType: PUBLIC ERROR = CODE; -- type of "arg" # range of type of "control"  BadResStack: PUBLIC ERROR = CODE; -- result stack size was incorrect.  -- debuggee was booted (or StopEvents was called) instead of returning.  EndSession: PUBLIC ERROR = CODE;  KillThisTurkey: PUBLIC ERROR = CODE;  NotImplemented: PUBLIC ERROR = CODE;    Operation: TYPE = { screen, kill, callDebuggee, start, boot, proceed, quit, init };  Actor: TYPE = LONG POINTER TO ActorObject;  ActorObject: TYPE = RECORD[    next: Actor,    world: WorldVM.World,    proc: AMEvents.EventProc, -- event notification handler    data: LONG POINTER,	-- data to be passed back to the event proc    users: CARDINAL ¬ 1, -- reference count on GetEvents/StopEvents    listener: PROCESS ¬ NIL, -- if not NIL, the process looking at the client    running: BOOLEAN ¬ TRUE, -- client is running    calling: BOOLEAN ¬ FALSE, -- client is doing callDebuggee    bootCount: CARDINAL ¬ 0, -- incremented when a client session ends    bootSession: LONG CARDINAL ¬ 0, -- used to determine if client was booted    level: CARDINAL ¬ 0]; -- nesting level of client procedure calls  GetEvents: PUBLIC ENTRY PROC[world: WorldVM.World, data: LONG POINTER, proc: AMEvents.EventProc] = {    ENABLE UNWIND => NULL;    IF proc = NIL THEN {      IF localActor = NIL OR data # NIL THEN ERROR      ELSE { proc ¬ localActor.proc; data ¬ localActor.data }};    FOR a: Actor ¬ actors, a.next UNTIL a = NIL DO      IF a.world = world THEN {	a.users ¬ a.users + 1;	a.data ¬ data; a.proc ¬ proc; EXIT };      REPEAT FINISHED => { -- create actor	new: Actor = zone.NEW[ActorObject ¬ [next: actors, world: world, data: data, proc: proc]];	actors ¬ new;	SELECT WorldVMOps.GetType[world] FROM	  local => { localActor ¬ new; GrabLocalEvents[] };	  outload => {	    WVMBooting.RegisterProcs[c: MyCheckpoint, r: MyRollback, b: NIL, clientData: new];	    Process.Detach[new.listener ¬ FORK LookAtClient[new, init]]};	  remote => {	    Process.Detach[new.listener ¬ FORK LookAtClient[new, init]]};	  ENDCASE => {	    Process.Detach[new.listener ¬ FORK LookAtClient[new, init]]}};      ENDLOOP };        MyCheckpoint: ENTRY WVMBooting.CheckpointProc =  {    ENABLE UNWIND => NULL;    a: Actor = NARROW[clientData];    IF (~a.running -- proceed is not through AMEvents        OR (a.running AND a.calling)) -- or they swapped during callDebuggee      AND a.users # 0 -- and an event handler exists      AND WorldVM.CurrentOutloadWorld[a.world] THEN { -- and this is world to be inloaded      -- Someone did a herald boot of an existing outload world      WorldVM.BeforeHeraldBoot[a.world]; }};  MyRollback: ENTRY WVMBooting.RollbackProc =  {    ENABLE UNWIND => NULL;    a: Actor = NARROW[clientData];    IF (~a.running -- not a normal proceed        OR (a.running AND a.calling)) -- or they swapped during callDebuggee      AND a.users # 0 -- and an event handler exists      AND WorldVM.CurrentOutloadWorld[a.world] THEN { -- and this is world to be inloaded      -- Someone did a herald boot of an existing outload world and returned      a.running ¬ TRUE;      WorldVM.AfterHeraldBoot[a.world];      Process.Detach[a.listener ¬ FORK LookAtClient[a, boot]] }};      StopEvents: PUBLIC PROC[world: WorldVM.World] = {    a: Actor;    oldSession: CARDINAL;    [a, oldSession] ¬ EntryStop[world];    AMEventsBackdoor.FlushBreaks[world];    IF a # NIL THEN { CallBootedNotifiers[a.world, oldSession]; zone.FREE[@a] }};  EntryStop: ENTRY PROC [world: WorldVM.World] RETURNS [a: Actor, oldSession: CARDINAL] = {    ENABLE UNWIND => NULL;    prev: Actor ¬ NIL;    FOR a ¬ actors, a.next UNTIL a = NIL DO      IF a.world = world THEN {        a.users ¬ a.users - 1;  	IF a.users = 0 THEN { -- destroy actor	  IF a = actors THEN actors ¬ actors.next ELSE prev.next ¬ a.next;	  IF a.listener # NIL THEN { Process.Abort[a.listener]; a.listener ¬ NIL };	  oldSession ¬ a.bootCount; a.bootCount ¬ a.bootCount + 1; BROADCAST clientChanged;	  SELECT WorldVMOps.GetType[world] FROM	    local => { localActor ¬ NIL; ReleaseLocalEvents[] };	    outload => WVMBooting.Deregister[c: MyCheckpoint, r: MyRollback, b: NIL, clientData: a];	    ENDCASE }	ELSE a ¬ NIL;	EXIT };      prev ¬ a;      ENDLOOP};  InvokeEvent: PROC [a: Actor, event: AMEvents.Event]     RETURNS [outcome: AMEvents.Outcome] = INLINE {    RETURN[a.proc[a.data, event]] };      ActorForWorld: ENTRY PROC[world: WorldVM.World] RETURNS[a: Actor] = {    FOR a ¬ actors, a.next UNTIL a = NIL DO       IF a.world = world THEN RETURN;       ENDLOOP };  ProvokeProcessEvent: PUBLIC PROC [p: AMProcess.Process, frame: LFHandle, msg: LONG STRING] RETURNS [outcome: AMEvents.Outcome] = {    a: Actor;    event: AMEvents.Event ¬ zone.NEW[AMEvents.EventRec ¬ [detail: call[msg]]];    event.frame ¬ frame;    event.world ¬ p.world;    event.process ¬ p.psbi;    a ¬ ActorForWorld[event.world];    IF a # NIL THEN event.session ¬ a.bootCount;    IF a = localActor THEN GatherLocalESV[event, NIL];    IF a # NIL THEN outcome ¬ InvokeEvent[a, event] ELSE outcome ¬ [proceed[NIL]];    zone.FREE[@event] };    -- from ApplyProcedure, Kill, Screen  CallClient: PROC [world: WorldVM.World, which: Operation, state: POINTER TO dst PrincOps.StateVector ¬ NIL, control: ControlLink ¬ NullLink] RETURNS [ok: BOOLEAN] = {    a: Actor = ActorForWorld[world];    IF a = NIL THEN RETURN[FALSE];    GetOutcome[a, which, state, control];    RETURN[TRUE] };  -- from CallClient  GetOutcome: ENTRY PROC [a: Actor, which: Operation[screen..start], state: POINTER TO dst PrincOps.StateVector ¬ NIL, control: ControlLink ¬ NullLink] = {    ENABLE UNWIND => NULL;    level, bootCount: CARDINAL;    DO       IF a.running THEN WAIT clientChanged      ELSE {        IF a.users = 0 THEN ERROR EndSession[];        level ¬ a.level; a.level ¬ a.level + 1; -- bump level	bootCount ¬ a.bootCount; -- remember bootcount	EXIT };      ENDLOOP;    a.running ¬ TRUE;    Process.Detach[a.listener ¬ FORK RunClient[a, which, state, control]];    IF which # kill THEN       UNTIL a.level = level DO -- wait until RunClient is done	IF a.bootCount # bootCount THEN ERROR EndSession[];	WAIT clientChanged;	ENDLOOP;    IF which = callDebuggee OR which = start THEN       WITH WorldVMOps.GetESV[a.world].swapData SELECT FROM	return => WorldVMOps.CopyRead[world: a.world, from: sv, to: state, nwords: SIZE[dst PrincOps.StateVector]];	returnAborted => state.stkptr ¬ 0;	ENDCASE => NULL; --ERROR;    a.running ¬ FALSE;    BROADCAST clientChanged };  -- from GetOutcome, RemoteEvent  RunClient: PROC [a: Actor, which: Operation, state: POINTER TO dst PrincOps.StateVector ¬ NIL, control: ControlLink ¬ NullLink] = {    Unlock: ENTRY PROC = {      ENABLE UNWIND => NULL;      a.running ¬ FALSE;      a.listener ¬ NIL;      BROADCAST clientChanged};    IF ~a.running THEN ERROR; -- caller must have set TRUE    BEGIN ENABLE {      ABORTED, WorldVM.BadWorld => { Unlock[]; StopEvents[a.world]; CONTINUE };      UNWIND => Unlock[] };    esv: LONG POINTER TO CPSwapDefs.ExternalStateVector = WorldVMOps.GetESV[a.world];    SELECT which FROM      screen => esv.swapData.body ¬ showScreen[];      kill => esv.swapData.body ¬ kill[];      callDebuggee => esv.swapData.body ¬ callDebuggee[proc: LOOPHOLE[control], sv: state­];      start => esv.swapData.body ¬ start[gFrame: LOOPHOLE[WorldVMOps.GFshort[a.world, WorldVMOps.GFFromControlLink[a.world, control]]], sv: state­];      boot => NULL;      proceed => esv.swapData.body ¬ proceed[];      quit => esv.swapData.body ¬ quit[];      ENDCASE => ERROR;         WorldVM.Go[a.world];    LookAtClient[a, which];    END };   -- from GetEvents, MyRollback, RunClient  LookAtClient: PROC [a: Actor, which: Operation] = {     ENABLE ABORTED => CONTINUE;    reason: CPSwapDefs.SwapReason;    NotifyHappening: ENTRY PROC [event: AMEvents.Event] = {      ENABLE UNWIND => NULL;      IF event = NIL THEN «client is returning from a call» a.level ¬ a.level - 1      ELSE {	event.session ¬ a.bootCount;	IF which = callDebuggee OR which = start THEN a.calling ¬ TRUE; -- was doing a call when this event occurred	Process.Detach[FORK RemoteEvent[a, a.level, a.bootCount, event]]}; -- look at event	IF which = callDebuggee OR which = start THEN a.calling ¬ FALSE;      a.listener ¬ NIL;      BROADCAST clientChanged};    IF ~a.running THEN ERROR; -- someone should still have the lock! --    IF a.bootSession # WorldVMOps.GetESV[a.world].bootSession THEN { -- client was booted      IF a.bootSession # 0 THEN which ¬ boot; -- bootSession is initially 0      a.bootSession ¬ WorldVMOps.GetESV[a.world].bootSession };    IF which = boot THEN {      NotifyBooted: ENTRY PROC RETURNS [oldSession: CARDINAL] = {	ENABLE UNWIND => NULL;	oldSession ¬ a.bootCount;	a.bootCount ¬ a.bootCount+1;	a.listener ¬ NIL; 	BROADCAST clientChanged };      Start: ENTRY PROC RETURNS [ok: BOOL] = {	ENABLE UNWIND => NULL;	IF (ok ¬ a.users # 0) THEN { a.listener ¬ Process.GetCurrent[]; a.level ¬ 0 }};      AMEventsBackdoor.FlushBreaks[a.world];      CallBootedNotifiers[a.world, NotifyBooted[]];       IF ~Start[] THEN RETURN };    reason ¬ WorldVMOps.GetESV[a.world].swapData.reason;    IF (reason = return OR reason = returnAborted) AND a.level > 0 -- return at level 0 is illegal --    THEN NotifyHappening[NIL] «client is returning from a call»     ELSE {      event: AMEvents.Event;      WITH WorldVMOps.GetESV[a.world].swapData SELECT FROM	breakpoint => {	  unknown: LONG STRING ¬ "No state for breakpoint"G;	  break: BreakID ¬ AMEventsBackdoor.BreakEvent[a.world, WorldVMOps.LFlong[a.world, lFrame], WorldVMOps.Long[a.world, instByteReceptacle]];	  event ¬ IF break = NIL THEN UnknownEvent[unknown] ELSE zone.NEW[AMEvents.EventRec ¬ [detail: break[break, break.clientData]]]};	callDebugger => event ¬ zone.NEW[AMEvents.EventRec ¬ [detail: call[message]]];	uncaughtSignal => event ¬ SignalEvent[a.world, signalError, WorldVMOps.Long[a.world, signalArgs], LOOPHOLE[signal]];	ENDCASE => event ¬ UnknownEvent["Unknown entry reason"G];      event.world ¬ a.world;      event.process ¬ WorldVMOps.GetESV[a.world].swapData.process;      event.frame ¬ WorldVMOps.GetESV[a.world].swapData.lFrame;      event.worry ¬ ~WorldVMOps.GetESV[a.world].swapData.mayCallDebuggee;      NotifyHappening[event] }};  -- from LookAtClient  RemoteEvent: PROC [a: Actor, level: CARDINAL, bootCount: CARDINAL, event: AMEvents.Event] = {    ENABLE ABORTED, EndSession => {IF event # NIL THEN zone.FREE[@event]; CONTINUE};    Unlock: ENTRY PROC = {      ENABLE UNWIND => NULL;      a.running ¬ FALSE;      BROADCAST clientChanged};    Lock: ENTRY PROC RETURNS [BOOL] = {      ENABLE UNWIND => NULL;      DO	IF a.running THEN { WAIT clientChanged; LOOP };	IF a.bootCount # bootCount THEN RETURN[FALSE];	IF a.level # level THEN { WAIT clientChanged; LOOP };	EXIT;	ENDLOOP;      a.running ¬ TRUE;      a.listener ¬ Process.GetCurrent[];      RETURN[TRUE]};    outcome: AMEvents.Outcome;    cb: LONG POINTER;    pc: BytePC;    instByteReceptacle: LONG POINTER TO BYTE;    WITH e: event SELECT FROM      break => {         id: BreakID = e.id; cb ¬ id.cb; pc ¬ id.pc;        instByteReceptacle ¬ WorldVMOps.Long[event.world, NARROW[WorldVMOps.GetESV[event.world].swapData, CPSwapDefs.SwapData.breakpoint].instByteReceptacle] };      ENDCASE;    Unlock[];    outcome ¬ InvokeEvent[a, event];    IF event.type = break THEN AMEventsBackdoor.ContinueFromBreak[event.world, cb, pc, instByteReceptacle];    zone.FREE[@event];    IF Lock[] THEN RunClient[a, WITH outcome SELECT FROM proceed => proceed, quit => quit, kill => kill, ENDCASE => ERROR NotImplemented[]] };  RopeFromRemote: PROC [world: WorldVM.World, addr: WorldVMOps.Address, s: LONG STRING] = {    temp: STRING = [0];    min: CARDINAL = SIZE[StringBody[0]];    IF addr = 0 THEN RETURN;    WorldVMOps.CopyRead[world: world, from: addr, to: temp, nwords: min];    s.length ¬ MIN[temp.length, s.maxlength];    WorldVMOps.CopyRead[world: world, from: addr+min, to: s+min, nwords: SIZE[StringBody[s.length]]-min]};      GrabLocalEvents: INTERNAL PROC = {    -- already did this in the control list for AbstractMachine -- };  ReleaseLocalEvents: INTERNAL PROC = {    IF getLocalBreaks THEN SDDefs.SD[SDDefs.sBreakTrap] ¬ LOOPHOLE[oldBreak];    RuntimeError.PrepareToUnload[];    Freeze.PrepareToUnload[]; };  HandleLocalEvents: PUBLIC PROC [signals, breaks, faults, calldebug: BOOLEAN] = {    ENABLE UNWIND => NULL;    IF localActor # NIL THEN {      IF signals # getLocalSignals THEN        IF signals 	-- was false now true	THEN oldCatcher ¬ RuntimeError.RegisterUncaughtSignalHandler[MyCatcher]	-- was true now false	ELSE [] ¬ RuntimeError.RegisterUncaughtSignalHandler[oldCatcher];      IF breaks # getLocalBreaks THEN        IF breaks	-- was false now true	THEN {	  --oldBreaker ¬ RuntimeError.RegisterBreakHandler[MyBreaker]}	  oldBreak ¬ LOOPHOLE[SDDefs.SD[SDDefs.sBreakTrap]];	  FastBreak.SpecifyDefaultBreakHandler[MyBreak]; 	  SDDefs.SD[SDDefs.sBreakTrap] ¬ LOOPHOLE[FastBreak.FastBreakHandler]}	-- was true now false	ELSE { 	  --[] ¬ RuntimeError.RegisterBreakHandler[oldBreaker]};	  FastBreak.SpecifyDefaultBreakHandler[oldBreak];	  SDDefs.SD[SDDefs.sBreakTrap] ¬ LOOPHOLE[oldBreak]};      IF faults # getLocalFaults THEN        IF faults	-- was false now true	THEN oldFaulter ¬ RuntimeError.RegisterFaultHandler[MyFaulter]	-- was true now false	ELSE [] ¬ RuntimeError.RegisterFaultHandler[oldFaulter];      IF calldebug # getLocalCallDebug THEN        IF calldebug	-- was false now true	THEN oldCallDebug ¬ RuntimeError.RegisterCallDebugHandler[MyCallDebug]	-- was true now false	ELSE [] ¬ RuntimeError.RegisterCallDebugHandler[oldCallDebug];      getLocalSignals ¬ signals;      getLocalBreaks ¬ breaks;      getLocalFaults ¬ faults;      getLocalCallDebug ¬ calldebug}};    MyCallDebug: RuntimeError.CDProc = {    -- PROC [msg: LONG STRING, frame: PrincOps.LocalFrameHandle]    LocalEvent[event: zone.NEW[AMEvents.EventRec ¬ [detail: call[msg]]], f: WorldVMOps.LFlong[localWorld, frame], stack: NIL]};      MyFaulter: RuntimeError.FaultProc = {    -- PROC [type: CPSwapDefs.StorageFaultType, process: PSB.PsbIndex, frame: PrincOps.LocalFrameHandle]    LocalEvent[event: FaultEvent[localWorld, type, WorldVMOps.ProcessLong[process]], f: WorldVMOps.LFlong[localWorld, frame], stack: NIL]};  MyCatcher: RuntimeError.UCSProc = {    -- PROC [signalError: CPSwapDefs.SignalError, sigArgs: POINTER, signal: PrincOpsExtras.SignalDesc, frame: PrincOps.LocalFrameHandle]    «guestDebug: BOOL = guestProcs.IsGuestProcess[];»    IF supressUncaughtAborted AND signal = LOOPHOLE[ABORTED] THEN { TurkeyCatcher[frame]; ERROR KillThisTurkey };    BEGIN ENABLE RuntimeError.UNCAUGHT =>       -- ERROR [ucsignal: SIGNAL, parameters: WORD]      IF crashOnRecursiveAppearance THEN	IF ucsignal -- arg of catch-phrase -- 	  = LOOPHOLE[signal] -- arg of this procedure -- 	  THEN Runtime.CallDebugger["Recursively uncaught signal"L];    «IF guestDebug THEN {      debugLocally: BOOLEAN;      guestProcs.disableGuest[TRUE];      debugLocally ¬ guestProcs.guestLocalEvent[        SignalEvent[localWorld, signalError, WorldVMOps.Long[localWorld, sigArgs], LOOPHOLE[signal]], 	WorldVMOps.LFlong[localWorld, frame], NIL, FALSE];      IF debugLocally THEN {         LocalEvent[	  SignalEvent[localWorld, signalError, WorldVMOps.Long[localWorld, sigArgs], LOOPHOLE[signal]], 	  WorldVMOps.LFlong[localWorld, frame], NIL] };      guestProcs.disableGuest[FALSE] }    ELSE» {      LocalEvent[        SignalEvent[localWorld, signalError, WorldVMOps.Long[localWorld, sigArgs], LOOPHOLE[signal]], 	WorldVMOps.LFlong[localWorld, frame], NIL] };    END -- ENABLE RuntimeError.UNCAUGHT -- };  TurkeyCatcher: PROC [root: PrincOps.LocalFrameHandle] = {    endProcess: PrincOps.ShortControlLink = Frame.ReadReturnLink[root];    CallerControlLink: PrincOps.ControlLink = [frame[Frame.GetReturnFrame[]]];    Caller: PROC = LOOPHOLE[CallerControlLink];    Frame.WriteReturnLink[[frame[Frame.MyLocalFrame[]]], root];    Frame.SetReturnFrame[PrincOps.NullLocalFrame];    Caller[ ! KillThisTurkey => CONTINUE];    Frame.SetReturnLink[endProcess]};  MyBreak: PROC = {    state: RECORD[padding: LONG CARDINAL, v: dst PrincOps.StateVector];    break: BreakID;    caller: PrincOps.LocalFrameHandle;    codeBase: LONG POINTER;    pc: PrincOps.BytePC;    instByteReceptacle: BYTE;    state.v ¬ STATE;    BEGIN    sourceDest: PrincOpsExtras.SourceDest;    caller ¬ Frame.GetReturnFrame[];    codeBase ¬ WorldVMOps.CodebaseFromGf[localWorld, WorldVMOps.GFlong[localWorld, Frame.ReadGlobalLink[caller]]];    pc ¬ Frame.ReadPC[caller];    instByteReceptacle ¬ state.v.instbyte;    IF (break ¬ AMEventsBackdoor.BreakEvent[localWorld, WorldVMOps.LFlong[localWorld, caller], @instByteReceptacle]) = NIL THEN {      IF WorldVMOps.ReadCodeByte[localWorld, codeBase, pc] = Mopcodes.zBRK THEN {	sourceDest.dest ¬ LOOPHOLE[oldBreak];	sourceDest.source ¬ Frame.GetReturnLink[];	STATE ¬ state.v;	RETURN WITH sourceDest }}    ELSE {      state.v.instbyte ¬ instByteReceptacle;      IF AMEventsBackdoor.ConditionTrue[caller, codeBase, pc, @state.v] THEN {        LocalEvent[event: zone.NEW[AMEvents.EventRec ¬ [detail: break[break, break.clientData]]], f: WorldVMOps.LFlong[localWorld, caller], stack: @state.v, return: (state.v.instbyte = Mopcodes.zRET)];	IF WorldVMOps.GetESV[localActor.world].swapData.reason = quit THEN ERROR ABORTED }};    sourceDest.dest ¬ [frame[caller]];    sourceDest.source ¬ -- PrincOpsExtras.nullShortLink;      state.v.stk[state.v.stkptr]; -- in case we broke just after xfer    AMEventsBackdoor.ContinueFromBreak[localWorld, codeBase, pc, @instByteReceptacle];    state.v.instbyte ¬ instByteReceptacle;    --IF XferTrap.ReadXTS[] = on THEN XferTrap.WriteXTS[skip1];    STATE ¬ state.v;    RETURN WITH sourceDest;    END };        «MyBreaker: RuntimeError.BreakProc = {    break: BreakID ¬ AMEventsBackdoor.BreakEvent[localWorld, sv, frame];    IF break = NIL THEN RETURN[FALSE]    ELSE {      saveBreak: AMEventsBackdoor.BreakRec ¬ break­;      instByteReceptacle­ ¬ sv.instbyte;      LocalEvent[	zone.NEW[AMEvents.EventRec ¬ 	  [detail: break[break.id, break.clientData]]], 	  frame, sv, sv.instbyte = Mopcodes.zRET];      IF ReadCodeByte[saveBreak.world, saveBreak.addr,         saveBreak.pc] # Mopcodes.zBRK      THEN --someone cleared it-- instByteReceptacle­ ¬ 0;      RETURN[TRUE]}};»        CallDebugger: PUBLIC PROC [msg: LONG STRING] = {    IF localActor # NIL THEN LocalEvent[event: zone.NEW[AMEvents.EventRec ¬ [detail: call[msg]]], f: WorldVMOps.LFlong[localWorld, Frame.GetReturnFrame[]], stack: NIL]    ELSE Runtime.CallDebugger["Call debugger"L] };      currentFrame: --debugging-- PrincOps.LocalFrameHandle;  LocalEvent: PROC [event: AMEvents.Event, f: LFHandle, stack: LONG POINTER TO dst PrincOps.StateVector, return: BOOL ¬ FALSE] = {    ENABLE {      UNWIND => zone.FREE[@event];       ABORTED => {zone.FREE[@event]; CONTINUE}};    outcome: AMEvents.Outcome;    currentFrame ¬ Frame.MyLocalFrame[];    event.process ¬ ProcessOperations.HandleToIndex[ProcessOperations.ReadPSB[]];    event.world ¬ localActor.world;    event.session ¬ localActor.bootCount;    event.frame ¬ f;    event.worry ¬ FALSE;    WorldVMExtras2.LocalCome[event.world];    GatherLocalESV[event, stack];     IF informing THEN RuntimeError.InformationalSignal[Debugging];    outcome ¬ InvokeEvent[localActor, event ! ABORTED => {outcome ¬ [quit[]]; CONTINUE}]; --assume they want to quit     IF informing THEN RuntimeError.InformationalSignal[Debugged];    WITH outcome SELECT FROM      proceed => WorldVMOps.GetESV[event.world].swapData.body ¬ proceed[];      quit =>         WITH event SELECT FROM          fault => {	    WorldVMOps.GetESV[event.world].swapData.body ¬ proceed[];	    VM.AbortFaultedProcess[	      ProcessOperations.ProcessFromIndex[WorldVMOps.ProcessShort[faultedProcess]], 	      SELECT type FROM addressFault => addressFault, writeProtectFault => writeFault, ENDCASE => ERROR, 	      ABORTED, NIL]};          ENDCASE => -- PilotNub will raise ABORTED for us.	    WorldVMOps.GetESV[event.world].swapData.body ¬ quit[];      kill => TemporaryBooting.BootButton[];      retry, returnFrom => ERROR NotImplemented[];      ENDCASE => ERROR;    WorldVMExtras2.LocalGo[event.world];    zone.FREE[@event]};    GatherLocalESV: PROC[event: AMEvents.Event, stack: LONG POINTER TO dst PrincOps.StateVector] = {    esv: LONG POINTER TO CPSwapDefs.ExternalStateVector = WorldVMOps.GetESV[event.world];    esv.swapData.lFrame ¬ WorldVMOps.LFshort[event.world, event.frame];    esv.swapData.process ¬ WorldVMOps.ProcessShort[event.process];    esv.swapData.mayCallDebuggee ¬ ~event.worry;    «IF stack # NIL THEN WorldVMOps.GetSV[event.world]­ ¬ stack­;»    WITH event SELECT FROM      call => esv.swapData.body ¬ callDebugger[msg];      break => esv.swapData.body ¬ breakpoint[NIL, stack];      -- signal => esv is correct;      -- fault => esv is correct;      -- unknown =>       ENDCASE};  UnknownEvent: PROC [msg: LONG STRING] RETURNS [event: AMEvents.Event] = {    event ¬ zone.NEW[AMEvents.EventRec ¬ [worry: TRUE, detail: unknown[msg]]]};  SignalEvent: PROC [world: WorldVM.World,       signalError: CPSwapDefs.SignalError, -- {signal(0), error(1)}      signalArgs: LFHandle,      signal: AMEvents.SignalDesc]     RETURNS [AMEvents.Event] = {    RETURN[zone.NEW[AMEvents.EventRec ¬ [world: world, detail: signal[signalError, signalArgs, signal]]]]};        FaultEvent: PROC [world: WorldVM.World, type: CPSwapDefs.StorageFaultType, process: AMEvents.Process] RETURNS [AMEvents.Event] = {    RETURN[zone.NEW[AMEvents.EventRec ¬ [world: world, detail: fault[type, process]]]]};  ComputeFrameSize: PROC[size: CARDINAL] RETURNS[fsi: PrincOps.FrameSizeIndex] = {    size ¬ size + SIZE[PrincOps.LocalOverhead];    FOR fsi IN PrincOps.FrameSizeIndex DO      IF size <= PrincOps.FrameVec[fsi] THEN RETURN;      REPEAT FINISHED => ERROR--args too big for any frame!--      ENDLOOP};        esvResultState: dst PrincOps.StateVector; -- temp  ApplyProcedure: PUBLIC PROC[world: WorldVM.World, control: ControlLink, args: AMEvents.ArgsOrResults, result: AMEvents.ArgsOrResults] = {    OPEN cl: LOOPHOLE[control, PrincOps.ControlLink];    argsize: CARDINAL = (IF args = NIL THEN 0 ELSE args.size);    state: dst PrincOps.StateVector;    state.instbyte ¬ 0;    IF (argsize > PrincOps.MaxParamsInStack) THEN {      fsi: PrincOps.FrameSizeIndex = ComputeFrameSize[argsize];      lf: PrincOps.LocalFrameHandle;      IF world # localWorld THEN ERROR;      lf ¬ Frame.Alloc[fsi];       state.stkptr ¬ 1;       state.stk[0] ¬ lf;      Inline.LongCOPY[from: @args[0], to: lf, nwords: argsize]}    ELSE {      state.stkptr ¬ argsize;      IF argsize # 0 THEN Inline.LongCOPY[from: @args[0], to: @state.stk[0], nwords: argsize] };    IF world = localWorld THEN {      prog: PROGRAM = IF ~cl.proc THEN SpecialRuntimeExtras.ProgramFromGlobalFrame[FrameExtras.GFTHandleToLongGF[LOOPHOLE[cl.frame]]] ELSE NIL;      STATE ¬ state;       IF cl.proc THEN LOOPHOLE[control, PROCEDURE][] ELSE START prog;       state ¬ STATE;      «WorldVMOps.GetSV[world]­ ¬ state»       esvResultState ¬ state;      WorldVMOps.GetESV[world].swapData.body ¬ return[sv: @esvResultState]; }    ELSE {       IF ~CallClient[world, IF cl.proc THEN callDebuggee ELSE start, @state, control] THEN ERROR };    GetResults[world, result, state]};      ApplySignal: PUBLIC PROC[world: WorldVM.World, signal: AMEvents.SignalDesc, args: AMEvents.ArgsOrResults, result: AMEvents.ArgsOrResults] = {    sigproc: PROC;    state: dst PrincOps.StateVector;    state.instbyte ¬ 0;    IF world # localWorld THEN ERROR BadControlLink[];    IF (args.size > PrincOps.MaxParamsInStack - 1) THEN {      fsi: PrincOps.FrameSizeIndex = ComputeFrameSize[args.size];      lf: PrincOps.LocalFrameHandle = Frame.Alloc[fsi];      state.stkptr ¬ SIZE[SIGNAL] + SIZE[PrincOps.LocalFrameHandle]; -- 3      state.stk[0] ¬ lf; -- LocalFrameHandle for signalArgs      Inline.LongCOPY[from: @signal, to: @state.stk[1], nwords: SIZE[SIGNAL]];      Inline.LongCOPY[from: @args[0], to: lf, nwords: args.size];      sigproc ¬ LOOPHOLE[SDDefs.SD[SDDefs.sSignalList]]}    ELSE {      state.stkptr ¬ SIZE[SIGNAL] + args.size;      Inline.LongCOPY[from: @args[0], to: @state.stk[0], nwords: args.size];      Inline.LongCOPY[from: @signal, to: @state.stk[args.size], nwords: SIZE[SIGNAL]];      sigproc ¬ LOOPHOLE[SDDefs.SD[SDDefs.sSignal]]};    STATE ¬ state;     sigproc[];     state ¬ STATE;    «WorldVMOps.GetSV[world]­ ¬ state;»    esvResultState ¬ state;    WorldVMOps.GetESV[world].swapData.body ¬ return[sv: @esvResultState];    GetResults[world, result, state]};      GetResults: PROC[world: WorldVM.World, result: AMEvents.ArgsOrResults, state: dst PrincOps.StateVector] = {    resultsize: CARDINAL = (IF result = NIL THEN 0 ELSE result.size);    IF (resultsize > PrincOps.MaxParamsInStack) THEN {      lf: PrincOps.LocalFrameHandle = state.stk[0];      IF state.stkptr # 1 THEN ERROR BadResStack[];      WorldVMOps.CopyRead[world: world, from: WorldVMOps.Long[world, lf], nwords: resultsize, to: @result[0]];      IF world = localWorld THEN Frame.Free[lf]}    ELSE {      IF state.stkptr # resultsize THEN ERROR BadResStack[];      Inline.LongCOPY[from: @state.stk[0], to: @result[0], nwords: state.stkptr]}};    Kill: PUBLIC PROC [world: WorldVM.World] =  {    IF world # localWorld THEN [] ¬ CallClient[world, kill ! EndSession => CONTINUE]};  Screen: PUBLIC PROC [world: WorldVM.World] = {    IF world # localWorld THEN [] ¬ CallClient[world, screen ! EndSession => CONTINUE]};   RegisterBootedNotifier: PUBLIC ENTRY PROC[proc: AMEvents.BootedNotifier, world: WorldVM.World ¬ NIL, clientData: LONG POINTER ¬ NIL] = {    ENABLE UNWIND => NULL;    bootedNotifierRegistry ¬ zone.NEW[BNRec ¬ [proc: proc, world: world, clientData: clientData, rest: bootedNotifierRegistry]]};  UnRegisterBootedNotifier: PUBLIC ENTRY PROC[proc: AMEvents.BootedNotifier, world: WorldVM.World ¬ NIL, clientData: LONG POINTER ¬ NIL] = {    ENABLE UNWIND => NULL;    prev: BootedNotifierRegistry ¬ NIL;    FOR this: BootedNotifierRegistry ¬ bootedNotifierRegistry, this.rest UNTIL this = NIL DO      IF this.proc = proc AND (world = NIL OR world = this.world) AND (clientData = NIL OR clientData = this.clientData) THEN {        kill: BootedNotifierRegistry ¬ this;        IF prev = NIL THEN bootedNotifierRegistry ¬ this.rest ELSE prev.rest ¬ this.rest;	zone.FREE[@kill]}      ELSE prev ¬ this;      ENDLOOP};      CallBootedNotifiers: PROC [world: WorldVM.World, session: CARDINAL] = {    FOR bnr: BootedNotifierRegistry ¬ bootedNotifierRegistry, NextBootedNotifier[world, bnr] UNTIL bnr = NIL DO      bnr.proc[world, session, bnr.clientData];      ENDLOOP };       NextBootedNotifier: ENTRY PROC [world: WorldVM.World, bnr: BootedNotifierRegistry] RETURNS [next: BootedNotifierRegistry ¬ NIL--nomore--] = {    ENABLE UNWIND => NULL;    FOR this: BootedNotifierRegistry ¬ bnr.rest, this.rest UNTIL this = NIL DO      IF this.world = NIL OR world = this.world THEN RETURN[this];      ENDLOOP};        «FalseProc: PROC RETURNS [isGuest: BOOL] = { RETURN[FALSE] };»    «guestProcs: LONG POINTER TO AMEventsBackdoor.GuestProcsRec ¬    zone.NEW[AMEventsBackdoor.GuestProcsRec ¬ [IsGuestProcess: FalseProc]];»      «RegisterGuestProcs: PUBLIC PROC [newProcs: LONG POINTER TO  AMEventsBackdoor.GuestProcsRec] = {    guestProcs ¬ newProcs };»  }.
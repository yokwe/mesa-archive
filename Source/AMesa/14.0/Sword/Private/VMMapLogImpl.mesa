-- Copyright (C) 1983, 1984, 1986  by Xerox Corporation. All rights reserved. -- VMMapLogImpl.mesa     8-Oct-84 17:41:37 by EKN  -- This module really has trouble with exported types! -- TO DO:--   Use an actual Usage for the buffer.DIRECTORY  Environment USING [PageNumber],  File USING [nullFile],  Inline USING [LongCOPY, LongCOPYReverse],  VMMapLog USING [    Entry, EntryHandle, DiskErrorType, Log, Operation, SpecialLookup],  VMMapLogInternal USING [Entry, EntryHandle],  VMMapLogExtras USING [BugType],  DiskChannel USING [    Create, defaultTries, DoIO, Drive, GetNextDrive, GetDriveTag, Handle,    goodCompletion, IORequest, IOStatus, nullDrive],  Space USING [    Interval, PageCount, PageFromLongPointer, PageNumber, PageOffset, ScratchMap,    unknownUsage],  PilotDisk USING [LabelCheckSum, Label],  VM USING [Kill, MakeResident, MakeSwappable, ReturnWait];VMMapLogImpl: MONITOR  -- just protects buffer, etc for MovePages.  IMPORTS DiskChannel, Inline, PilotDisk, Space, VM EXPORTS VMMapLog, VMMapLogExtras =  BEGIN  -- Public Items:  nullEntry: PUBLIC Entry ¬ [    page: 0, count: 0, writeProtected: FALSE, fill: 0,    backingStorage: nil[ALL[0]]];  InvalidPageNumber: PUBLIC ERROR = CODE;  DiskError: PUBLIC ERROR [error: VMMapLog.DiskErrorType] = CODE;  LogFull: PUBLIC ERROR = CODE;  WriteProtected: PUBLIC ERROR = CODE;  Unmapped: PUBLIC ERROR = CODE;  -- Implementation Items:  Entry: PUBLIC TYPE = VMMapLogInternal.Entry;  E: PROC [e: VMMapLog.Entry] RETURNS [VMMapLogInternal.Entry] = INLINE    -- Use of this procedure is the only way to access the opaque Entries    -- inside a VMMapLog.LogDesc without loopholes.    {RETURN[e]};    PEntries: TYPE =  -- for debugger.    LONG POINTER TO ARRAY [0..2000--say--) OF VMMapLogInternal.Entry;  labelReadBuffer: Space.PageNumber;  labelReadBufferCount: Space.PageCount = 1;  drive: DiskChannel.Drive ¬ DiskChannel.nullDrive;  chan: DiskChannel.Handle;  Bug: PUBLIC SIGNAL [type: VMMapLogExtras.BugType] = CODE;  FindEntry: PUBLIC PROCEDURE [    vmPage: Environment.PageNumber, log: VMMapLog.Log,    specialLookup: VMMapLog.SpecialLookup]    RETURNS [entry: LONG POINTER TO Entry] =    BEGIN    hi: CARDINAL ¬ log.count - 1;    lo: CARDINAL ¬ 0;    IF log.count = 0 THEN ERROR Unmapped;    WHILE hi >= lo DO      mid: CARDINAL = (hi + lo)/2;      entry ¬        (IF specialLookup = NIL THEN @log.entries[mid]         ELSE specialLookup[log, mid]);      SELECT vmPage FROM        > entry.page + entry.count - 1 => lo ¬ mid + 1;        < entry.page => IF mid = 0 THEN EXIT ELSE hi ¬ mid - 1        ENDCASE => RETURN;      ENDLOOP;    ERROR Unmapped;    END;  --FindEntry--  FindFirstForInsert: PUBLIC PROCEDURE [log: VMMapLog.Log]    RETURNS [index: CARDINAL] =    BEGIN    FOR index IN [0..log.count - 1) DO      IF E[log.entries[index]].page > E[log.entries[index + 1]].page THEN RETURN;      ENDLOOP;    index ¬ log.count;    END;  InEntry: PUBLIC PROCEDURE [    page: Environment.PageNumber, entry: VMMapLogInternal.EntryHandle]    RETURNS [BOOLEAN] = {RETURN[page IN [entry.page..entry.page + entry.count)]};  InsertEntry: PUBLIC PROCEDURE [    entry: LONG POINTER TO Entry, log: VMMapLog.Log] =    BEGIN    entryEnd: Environment.PageNumber ¬ entry.page + entry.count;    hi: CARDINAL;    lo: CARDINAL ¬ 0;    IF entry.count = 0 THEN RETURN;  -- a vacuous entry    IF log.count > 0 THEN      BEGIN      mid: CARDINAL;      IF E[log.entries[hi ¬ log.count-1]].page < entry.page      THEN {lo ¬ log.count; GOTO done};      -- Find the spot to insert into --      WHILE hi >= lo DO        mid ¬ (hi + lo)/2;        SELECT E[log.entries[mid]].page FROM          > entry.page => IF mid = 0 THEN EXIT ELSE hi ¬ mid - 1;          < entry.page => lo ¬ mid + 1;          ENDCASE => {lo ¬ mid; EXIT};        ENDLOOP;      EXITS done => NULL;      END    ELSE lo ¬ 0;  -- this is the first entry    --ASSERT: entry.page <= log.entries[lo].page    -- or alternatively: log.entries[lo].page >= entry.page.        IF entry.kind = nil THEN      BEGIN  -- it's an unmap      -- Accumulate the entries that are covered by this unmap:      -- Note that any of the matching map entries may be absent due to       --   their cancellation and re-use in the debugee world.      maxDeletableEntries: CARDINAL = log.count - lo;      entriesToDelete: CARDINAL;      FOR entriesToDelete ¬ 0, entriesToDelete.SUCC        WHILE entriesToDelete < maxDeletableEntries	AND E[log.entries[lo + entriesToDelete]].page < entryEnd DO  --	--ASSERT: entries[lo + entriesToDelete].page >= entry.page.        ENDLOOP;      -- Delete the map entries:      Inline.LongCOPY[        from: @log.entries[lo + entriesToDelete], to: @log.entries[lo],	nwords: (log.count-(lo + entriesToDelete))*VMMapLog.Entry.SIZE];      log.count ¬ log.count - entriesToDelete;      END    ELSE      BEGIN  -- it's a map      IF log.count >= log.limit THEN ERROR LogFull;      IF lo < log.count THEN -- there is a following entry.        IF entry.page = E[log.entries[lo]].page	OR entryEnd > E[log.entries[lo]].page THEN {	  -- ERROR Bug[duplicateOrOverlappingMapEntry];	  SIGNAL Bug[duplicateOrOverlappingMapEntry];	  log.count ¬ log.count - 1 }	ELSE 	  -- Make room in table:	  Inline.LongCOPYReverse[	    from: @log.entries[lo], to: @log.entries[lo + 1],	    nwords: (log.count-lo)*VMMapLog.Entry.SIZE];      log.entries[lo] ¬ entry­;  -- insert the new map entry      log.count ¬ log.count + 1;      END;    END;  --InsertEntry--  IsWriteProtected: PUBLIC PROCEDURE [entry: VMMapLogInternal.EntryHandle]    RETURNS [BOOLEAN] = {RETURN[entry.writeProtected]};  MovePages: PUBLIC ENTRY PROCEDURE [    op: VMMapLog.Operation, clientVMPage: Environment.PageNumber,    entry: VMMapLogInternal.EntryHandle, buffer: Space.Interval,    count: Environment.PageNumber ¬ 1] =    BEGIN    ENABLE UNWIND => NULL;  -- unlock monitor.    WITH diskEntry: entry SELECT FROM      disk =>  -- (this is the only valid variant)        BEGIN  --disk entry--        thisLabelReadBuffer: Space.PageNumber;        req: DiskChannel.IORequest;        offset: Space.PageOffset ¬ clientVMPage - entry.page;        label: PilotDisk.Label;        status: DiskChannel.IOStatus;        throwAway: BOOLEAN;        IF clientVMPage + count > diskEntry.page + diskEntry.count THEN          RETURN WITH ERROR InvalidPageNumber;        -- Find the Drive, create a channel to it:        IF drive = DiskChannel.nullDrive          OR diskEntry.driveTag # DiskChannel.GetDriveTag[drive] THEN          BEGIN          drive ¬ DiskChannel.nullDrive;          UNTIL (drive ¬ DiskChannel.GetNextDrive[drive]) = DiskChannel.nullDrive            DO            IF DiskChannel.GetDriveTag[drive] = diskEntry.driveTag THEN {              chan ¬ DiskChannel.Create[drive]; EXIT};            REPEAT FINISHED => ERROR Bug[cantFindDrive];            ENDLOOP;          END;        -- Set up common fields of IO request block,        --   both for label read, and data transfer:        req.diskPage ¬ diskEntry.diskPage + offset;        req.tries ¬ DiskChannel.defaultTries;        req.useSamePage ¬ FALSE;        req.label ¬ @label;        -- Read the label:        << (We are only given a checksum of the label. We must read the	  actual label, and compare its checksum. If it agrees, we	  assume that the label read is the label of the desired pages.	  The label is used in reading or writing the actual client data.	  	  If this is a client READ operation, we read the label and first page	  of data into the client buffer instead of a private buffer.	  If the client only wanted one page, we're done. >>        thisLabelReadBuffer ¬          IF op = read THEN Space.PageFromLongPointer[buffer.pointer]          ELSE labelReadBuffer;        VM.Kill[[page: thisLabelReadBuffer, count: labelReadBufferCount]];        VM.MakeResident[          [page: thisLabelReadBuffer, count: labelReadBufferCount], wait];        req.command ¬ [header: verify, label: read, data: read];        req.count ¬ 1;        req.memoryPage ¬ thisLabelReadBuffer;        status ¬ DiskChannel.DoIO[chan, @req].status;        VM.MakeSwappable[          [page: thisLabelReadBuffer, count: labelReadBufferCount]];        IF thisLabelReadBuffer # Space.PageFromLongPointer[buffer.pointer] THEN          VM.Kill[[page: thisLabelReadBuffer, count: labelReadBufferCount]];        throwAway ¬ SignalIfError[status].labelVerifyError;  -- (expect labelVerifyError)        IF PilotDisk.LabelCheckSum[req.label, offset] # diskEntry.labelCheck THEN          RETURN WITH ERROR DiskError[labelDoesNotMatch];        IF op = read AND count = 1 THEN RETURN;  -- that's all he wanted.        --ASSERT: op = write or reading more than one page.        -- Set the IO request block to move a run of pages --        -- (We verify the labels this time as we read or write.)        req.command ¬          IF op = write THEN [verify, verify, write] ELSE [verify, verify, read];        req.count ¬ count;        req.memoryPage ¬ Space.PageFromLongPointer[buffer.pointer];        VM.MakeResident[          [Space.PageFromLongPointer[buffer.pointer], buffer.count], wait];        status ¬ DiskChannel.DoIO[chan, @req].status;        VM.MakeSwappable[          [Space.PageFromLongPointer[buffer.pointer], buffer.count]];        IF status # DiskChannel.goodCompletion THEN {  -- (test is perf accelerator only)          IF SignalIfError[status].labelVerifyError THEN            RETURN WITH ERROR DiskError[labelDoesNotMatch]};        END;  --disk entry--      ENDCASE => ERROR Bug[invalidEntryType];  -- all other types are invalid    END;  --MovePages--  SeeEntry: PUBLIC PROCEDURE [entry: VMMapLogInternal.EntryHandle]    RETURNS [page: Environment.PageNumber, count: [1..4096]] = {    RETURN[page: entry.page, count: entry.count]};  SignalIfError: PROCEDURE [status: DiskChannel.IOStatus]    RETURNS [labelVerifyError: BOOLEAN] =    -- NOTE: The caller is responsible for unlocking his monitor.    BEGIN    WITH status SELECT FROM      invalidChannel, invalidDriveState => ERROR Bug[problemWithDrive];      disk =>        SELECT status FROM          inProgress => ERROR Bug[inProgressReturnedByDoIO];          goodCompletion => NULL;          notReady => ERROR Bug[driveNotReady];          labelVerifyError => RETURN WITH ERROR DiskError[labelDoesNotMatch];          headerCRCError, labelCRCError, dataCRCError, headerNotFound,            dataVerifyError => RETURN WITH ERROR DiskError[unreadablePage];          writeFault, memoryError, memoryFault, clientError => ERROR Bug[myError];          recalibrateError, seekTimeout, overrunError, otherError =>            RETURN WITH ERROR DiskError[hardwareError];          ENDCASE => ERROR Bug[impossibleEndcase];      ENDCASE => ERROR Bug[impossibleEndcase];    END;  --SignalIfError--  -- Main body:  labelReadBuffer ¬ Space.PageFromLongPointer[    Space.ScratchMap[count: labelReadBufferCount, usage: Space.unknownUsage]];  END.Log12-Jan-82 19:35:23   JXP      Fixed problem in bin searches in insertEntry and and FindEntry to handle   a boundary condition24-Feb-82 11:46:49   AWL         When writing, make the client's buffer resident and implement SpecialLookup24-Mar-82 23:26:42   RXJ        Write from "buffer" instead of "labelReadBuffer"!18-Apr-83 18:23:53   EKN   	Update to Klamath 9-May-83 18:07:44   WDK        Don't map infinite size labelReadBuffer. Use Map rather than Allocate + MapAt. MovePages: Clarify logic and comments for combining label read with user request. label read should be vrr, not vvr. Don't use RuntimeInternal. Merge all private errors. Create local definition for SpecialLookup; Improve documentation of local definition of Log; shoot corresponding LOOPHOLEs. Alphabetize procs. Improve error handling, especially on label read. Use LongCOPY for table manipulation. 4-Jul-83 18:06:54   WDK     	count=0 means vacuous entry.13-Jul-83 14:25:11   AWL      	nullEntry must set all fields.24-Aug-83 18:18:15   WDK        Add sanity checks in InsertEntry. Didn't handle unmap with no or only partial matching map entries. Didn't detect duplicate or overlapping maps.25-Aug-83  9:47:16   WDK     	Don't check if insert at end. 8-Oct-84 17:41:50   EKN        Copyrite formatted.
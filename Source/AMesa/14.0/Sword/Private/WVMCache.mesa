-- Copyright (C) 1986  by Xerox Corporation. All rights reserved. -- WVMCache.mesaDIRECTORY  AMHeap USING [zone],  AMLoadstate USING [AcquireLoadstate, DestroyLoadstate, Error],  BootFile USING [currentVersion, Header, MapEntry, maxEntriesPerHeader, maxEntriesPerTrailer, Trailer],  CPSwapDefs USING [currentVersion, ExternalStateVector, oldVersion, SwapInfo],  Environment USING [lastPageCount, lastPageNumber, Long, LongPointerFromPage, PageFromLongPointer, PageNumber, wordsPerPage],  File USING [File, PageNumber],  Inline USING [HighHalf, LongCOPY, LowHalf],  PageMap USING [State, Flags, flagsVacant, GetState, IsVacant, RealPageNumber],  PSB USING [PDA],  Riggle USING [RiggleMapBootSpace, RiggleUnMapBootSpace, RiggleWorld],  Space USING [Access, Error, GetMapUnitAttributes, Interval, Kill, Map, MapAt, MDS, nullInterval, ScratchMap, Unmap, UnmapAt],  TTY USING [PutLine],  VM USING [GetSwapUnitAttributes, Interval, nullInterval],  VMMapLog USING [Descriptor, DiskError, Entry, EntryBasePointer, EntryHandle, EntryPointer, FindEntry, InEntry, InsertEntry, IsWriteProtected, LogFull, MovePages, SeeEntry, Unmapped],  VMMapLogExtras USING [Bug],  WorldVM USING [BadWorld, WorldObject],  WorldVMExtras USING [Address, NullProcess, Process, SwapState],  WorldVMOps USING [Address, NullProcess, Process, ShortAddress],  WVMCacheOps USING [CloseConnection, CloseOutload, FlushRemoteBootFile, RemoteCoreRead, RemoteCoreWrite, RemoteDiskRead, RemoteDiskWrite, RemoteWorld, SetupRemoteBootFile],  WVMCacheRep USING [BootFileHeaders, BootFileHeadersObject, BootFileMapItem, Cache, CacheObject, MapEntryP, Maplog, MFEntrySize, mfMapPages, Segment, SegmentObject],  WVMPrivate USING [ClientWorld, LocalWorld, OutloadWorld, RemoteWorld, WorldObject];  WVMCache: MONITOR LOCKS l USING l: Lock  IMPORTS AMHeap, AMLoadstate, Environment, Inline, PageMap, Riggle, Space, TTY, VM, VMMapLog, VMMapLogExtras, WorldVM, WVMCacheOps  EXPORTS WorldVM, WorldVMExtras, WorldVMOps, WVMPrivate  SHARES PageMap = {  OPEN WVMCacheRep;    zone: UNCOUNTED ZONE = AMHeap.zone;  Lock: TYPE = LONG POINTER TO MONITORLOCK;    World: TYPE = LONG POINTER TO WorldObject;  WorldObject: PUBLIC TYPE = WVMPrivate.WorldObject;  OutloadWorld: TYPE = WVMPrivate.OutloadWorld;  RemoteWorld: TYPE = WVMPrivate.RemoteWorld;  LocalWorld: TYPE = WVMPrivate.LocalWorld;  ClientWorld: TYPE = WVMPrivate.ClientWorld;  Address: TYPE = WorldVMOps.Address;  Process: TYPE = WorldVMOps.Process;  NullProcess: Process = WorldVMOps.NullProcess;    CacheSize: CARDINAL = 8;  Segments: TYPE = [0..CacheSize);    PageNumber: TYPE = Environment.PageNumber;  wordsPerPage: CARDINAL = Environment.wordsPerPage;    AddressFault: PUBLIC SIGNAL [address: Address] = CODE;  WriteProtected: PUBLIC SIGNAL [address: Address] = CODE;      CreateCache: ENTRY PROC[l: Lock, world: World] = {    ENABLE UNWIND => NULL;    NewCS: PROC[] RETURNS[CS: Cache] = {      CS ¬ zone.NEW[CacheObject[CacheSize]];      CS.scratch ¬ Space.ScratchMap[CacheSize];      FOR i: Segments IN Segments DO	CS[i].space ¬ [pointer: CS.scratch+i*wordsPerPage, count: 1];	ENDLOOP };    WITH world SELECT FROM      local => IF seg = NIL THEN seg ¬ zone.NEW[SegmentObject];      outload => IF CS = NIL THEN CS ¬ NewCS[];       remote => IF CS = NIL THEN CS ¬ NewCS[];      client => NULL;      ENDCASE; };        DeleteCache: ENTRY PROC[l: Lock, world: World] = {    ENABLE UNWIND => NULL;    FreeCS: PROC[CS: LONG POINTER TO Cache] = {      CS.scratch ¬ Space.Unmap[CS.scratch];      zone.FREE[CS] };    WITH world SELECT FROM      local => IF seg # NIL THEN zone.FREE[@seg];      outload => IF CS # NIL THEN FreeCS[@CS];       remote => IF CS # NIL THEN FreeCS[@CS];      client => NULL;      ENDCASE; };        KillCache: ENTRY PROC[l: Lock, world: World] = {    ENABLE UNWIND => NULL;    ClearCS: PROC[CS: Cache] = {      FOR i: Segments IN Segments DO	CS[i].address ¬ CS[i].space.pointer;	CS[i].inuse ¬ FALSE;	ENDLOOP;      CS.currentUseValue ¬ 0; };    WITH world SELECT FROM      local => IF seg # NIL THEN seg.inuse ¬ FALSE;      outload => IF CS # NIL THEN ClearCS[CS];      remote => IF CS # NIL THEN ClearCS[CS];      client => NULL;      ENDCASE; };      FlushCache: ENTRY PROC[l: Lock, world: World] = {    ENABLE UNWIND => NULL;    FlushSegments: INTERNAL PROC[l: Lock, CS: Cache] = {      bootSession: LONG CARDINAL = world.esv.bootSession;      FOR i: Segments IN Segments DO	IF CS[i].inuse AND CS[i].session = bootSession THEN FlushCS[l, world, @CS[i]];	ENDLOOP;      CS.currentUseValue ¬ 0; };    WITH world SELECT FROM      local => IF seg # NIL THEN seg.inuse ¬ FALSE;      outload => IF CS # NIL THEN FlushSegments[l, CS];      remote => IF CS # NIL THEN FlushSegments[l, CS];      client => NULL;      ENDCASE; };      FlushCS: INTERNAL PROC [l: Lock, world: World, cs: Segment] = {    SELECT TRUE FROM      ~cs.dirty => NULL;      (world.type = remote) => {	IF cs.bootfile THEN {	  SELECT cs.flags FROM	    clean, dirty => cs.flags ¬ dirty;	    referenced, dirtyReferenced => cs.flags ¬ dirtyReferenced;	    writeProtected, writeProtectedReferenced => NULL; 	    ENDCASE;	  WVMCacheOps.RemoteCoreWrite[NARROW[world, RemoteWorld], cs] }	ELSE WVMCacheOps.RemoteDiskWrite[NARROW[world, RemoteWorld], cs]; 	Space.Kill[cs.space] };      cs.bootfile =>         IF ~cs.writeprotect THEN {	  me: MapEntryP = FindPageInBootFile[l, NARROW[world, OutloadWorld], cs.mempage].bm;	  me.flags.dirty ¬ TRUE };      ENDCASE => {	VMMapLog.MovePages[write, cs.mempage, cs.entry, cs.space 	  ! VMMapLog.DiskError => ERROR AMLoadstate.Error[diskErrorInVMMap]];	Space.Kill[cs.space] };    cs.inuse ¬ FALSE;    cs.address ¬ cs.space.pointer};      BootFileAddress: PROC [bootSpace: Space.Interval, page: File.PageNumber]     RETURNS [LONG POINTER] = {    IF page >= bootSpace.count THEN ERROR WorldVM.BadWorld;    RETURN[bootSpace.pointer + page*wordsPerPage] };    FindPageInBootFile: INTERNAL PROC [l: Lock, world: OutloadWorld, memPage: PageNumber]     RETURNS [filePage: File.PageNumber, bm: LONG POINTER TO BootFile.MapEntry] = {    -- returns file page if it's in the boot file; zero otherwise    -- WHILE (world.bootArea.bfmHead = NIL) DO WAIT world.bootArea.bfmHeadOK ENDLOOP;    bfmHead: BootFileHeaders ¬ world.bootArea.bfmHead;    FOR i: CARDINAL IN [0..bfmHead.max) DO      IF memPage <= bfmHead[i].lastMemPage THEN {        bfm: BootFileMapItem = bfmHead[i];	bottom: CARDINAL ¬ 0;	top: CARDINAL ¬ bfm.entryCount;	WHILE bottom < top DO	  med: CARDINAL = (top+bottom)/2;	  SELECT bfm.entries[med].virtual FROM	    < memPage => bottom ¬ med+1;	    > memPage => top ¬ med;	    ENDCASE => RETURN[filePage: bfm.filePageOffset + med, bm: @bfm.entries[med]];	  REPEAT FINISHED => GOTO NotFound;	  ENDLOOP };      REPEAT NotFound => NULL;      ENDLOOP;    RETURN[filePage: 0, bm: NIL]};      SwappedIn: PUBLIC PROC[world: World, addr: Address, process: Process ¬ NullProcess] RETURNS[BOOLEAN] = {    RETURN[GetPageState[world, addr, process].swapState = in]};    GetPageState: PUBLIC PROC[world: World, addr: Address, process: Process]    RETURNS [swapState: WorldVMExtras.SwapState, access: Space.Access, flags: PageMap.Flags, real: PageMap.RealPageNumber] = {    page: PageNumber = Environment.PageFromLongPointer[addr];    IF page > Environment.lastPageNumber THEN ERROR AddressFault[addr];    WITH world SELECT FROM      none => ERROR;      local => {	-- Warning: results will be bogus a microsecond from now.	state: PageMap.State;	[state, real] ¬ PageMap.GetState[page];	flags ¬ state.flags;	access ¬ IF flags.readonly THEN readOnly ELSE readWrite;	swapState ¬	  IF flags # PageMap.flagsVacant THEN in	  ELSE IF Space.GetMapUnitAttributes[addr].interval.count = 0 THEN unmapped ELSE out;        RETURN };      outload => {	filePage: File.PageNumber;	bm: MapEntryP;	Entry: ENTRY PROC[l: Lock] = {[filePage, bm] ¬ FindPageInBootFile[l, NARROW[world, OutloadWorld], page]};	Entry[@world.cacheLock];	IF filePage = 0 THEN { --outload and swapped out--	  entry: VMMapLog.EntryHandle = LookupVMMapEntry[world, page];	  IF entry = NIL THEN RETURN[unmapped, TRASH, PageMap.flagsVacant, 0]	  ELSE RETURN[out, IF VMMapLog.IsWriteProtected[entry] THEN readOnly ELSE readWrite, PageMap.flagsVacant, 0]}	ELSE { --outload and swapped in--	  RETURN[in, IF bm.flags.readonly THEN readOnly ELSE readWrite, bm.flags, bm.real] }};        remote => {	cs: Segment = GetCS[world: world, mempage: page, process: process, justCore: TRUE];	IF cs # NIL AND cs.bootfile THEN {  --remote and swapped in--	  RETURN[in, IF LOOPHOLE[cs.flags, PageMap.Flags].readonly THEN readOnly ELSE readWrite, LOOPHOLE[cs.flags], 0] }	ELSE {  --remote and swapped out--	  entry: VMMapLog.EntryHandle = LookupVMMapEntry[world, page];	  IF entry = NIL THEN RETURN[unmapped, TRASH, PageMap.flagsVacant, 0]	  ELSE RETURN[out, IF VMMapLog.IsWriteProtected[entry] THEN readOnly ELSE readWrite, PageMap.flagsVacant, 0]}};        ENDCASE };      NewSeg: INTERNAL PROC[l: Lock, world: World, justCore: BOOLEAN, mempage: PageNumber, sp: Segment, process: Process]     RETURNS[BOOLEAN] = {    sp.process ¬ process;    sp.mempage ¬ mempage;    sp.session ¬ world.esv.bootSession;    IF NewCoreSegment[l, world, sp] THEN RETURN[TRUE];    IF justCore THEN RETURN[FALSE];    NewDiskSegment[world, sp];    RETURN[TRUE]; };      NewCoreSegment: INTERNAL PROC [l: Lock, world: World, cs: Segment] RETURNS [found: BOOLEAN] = {    found ¬       WITH world SELECT FROM	outload => OutloadCoreRead[l, NARROW[world, OutloadWorld], cs],        remote => WVMCacheOps.RemoteCoreRead[NARROW[world, RemoteWorld], cs],	ENDCASE => ERROR;    IF ~found THEN RETURN;    cs.inuse ¬ TRUE;    cs.dirty ¬ FALSE;    cs.bootfile ¬ TRUE };      NewDiskSegment: PROC [world: World, cs: Segment] = {    entry: VMMapLog.EntryHandle = LookupVMMapEntry[world, cs.mempage];    IF entry = NIL THEN ERROR AddressFault[Environment.LongPointerFromPage[cs.mempage]];    cs.entry ¬ entry;    cs.dirty ¬ FALSE;    cs.writeprotect ¬ VMMapLog.IsWriteProtected[entry];    cs.bootfile ¬ FALSE;    WITH world SELECT FROM      outload => OutloadDiskRead[NARROW[world, OutloadWorld], cs];      remote => WVMCacheOps.RemoteDiskRead[NARROW[world, RemoteWorld], cs];      ENDCASE;    cs.inuse ¬ TRUE};      OutloadCoreRead: INTERNAL PROC [l: Lock, world: OutloadWorld, cs: Segment] RETURNS [BOOLEAN] = {    bm: MapEntryP;    filePage: File.PageNumber;    [filePage: filePage, bm: bm] ¬ FindPageInBootFile[l, world, cs.mempage];    IF filePage = 0 THEN RETURN[FALSE]    ELSE {      cs.writeprotect ¬ bm.flags.readonly;      cs.address ¬ BootFileAddress[world.bootArea.bootSpace, filePage];      RETURN[TRUE]}};      OutloadDiskRead: PROC [world: OutloadWorld, cs: Segment] = {    VMMapLog.MovePages[read, cs.mempage, cs.entry, cs.space       ! VMMapLog.DiskError => ERROR AMLoadstate.Error[diskErrorInVMMap]];    cs.address ¬ cs.space.pointer };      GetCS: PROC [world: World, mempage: PageNumber, process: Process, justCore: BOOLEAN ¬ FALSE]     RETURNS [Segment] = {    IF mempage > Environment.lastPageNumber     THEN ERROR AddressFault[Environment.LongPointerFromPage[mempage]];    WITH world SELECT FROM      local => RETURN[GetLocalCS[@world.cacheLock, NARROW[world, LocalWorld], mempage, process]];      outload, remote => RETURN[GetNonLocalCS[@world.cacheLock, world, mempage, process, justCore]];      none => ERROR AddressFault[Environment.LongPointerFromPage[mempage]];      ENDCASE => RETURN[NIL]; };    GetLocalCS: ENTRY PROC[l: Lock, world: LocalWorld, mempage: PageNumber, process: Process]     RETURNS [sp: Segment] = {    ENABLE UNWIND => NULL;    access: Space.Access;    swapUnit: VM.Interval;    sp ¬ world.seg;    sp.address ¬ Environment.LongPointerFromPage[mempage];    sp.process ¬ process;    [swapUnit, access,,] ¬ VM.GetSwapUnitAttributes[mempage ! Space.Error => ERROR AddressFault[sp.address]];    IF PageMap.IsVacant[mempage] AND swapUnit = VM.nullInterval THEN ERROR AddressFault[sp.address];    sp.writeprotect ¬ (swapUnit # VM.nullInterval) AND (access = readOnly); };      GetNonLocalCS: ENTRY PROC[l: Lock, world: World, mempage: PageNumber, process: Process, justCore: BOOLEAN]     RETURNS [Segment] = {    ENABLE UNWIND => NULL;    bootSession: LONG CARDINAL = world.esv.bootSession;    SearchSegments: INTERNAL PROC[l: Lock, CS: Cache] RETURNS[sp: Segment] = {      minUseVal: CARDINAL ¬ CS.currentUseValue;      minUseIndex: CARDINAL ¬ 0;      i: Segments;      CS.cacheAccess ¬ CS.cacheAccess + 1;      FOR i IN Segments DO	sp ¬ @CS[i];	IF ~sp.inuse THEN { 	  CS.cacheMisses ¬ CS.cacheMisses + 1; 	  IF ~NewSeg[l, world, justCore, mempage, sp, process] THEN RETURN[NIL]; 	  EXIT; };	IF sp.mempage = mempage AND sp.session = bootSession THEN EXIT;	IF sp.lastused < minUseVal THEN { minUseVal ¬ sp.lastused; minUseIndex ¬ i };	REPEAT FINISHED => {	  CS.cacheMisses ¬ CS.cacheMisses + 1;	  FOR i IN Segments DO	    CS[i].lastused ¬ CS[i].lastused - minUseVal;	    ENDLOOP;	  CS.currentUseValue ¬ CS.currentUseValue - minUseVal;	  FlushCS[l, world, sp ¬ @CS[minUseIndex]];	  IF ~NewSeg[l, world, justCore, mempage, sp, process] THEN RETURN[NIL]; };	ENDLOOP;      sp.lastused ¬ CS.currentUseValue ¬ CS.currentUseValue + 1; };    WITH world SELECT FROM      outload => RETURN[SearchSegments[l, CS]];      remote => RETURN[SearchSegments[l, CS]];      ENDCASE => RETURN[NIL]; };  NilAddress: PUBLIC PROC[world: World, addr: Address] RETURNS[BOOLEAN] = {    Order: PROC[addr: Address] RETURNS[LONG ORDERED POINTER] = INLINE {RETURN[LOOPHOLE[addr]]};    LongNIL: LONG ORDERED POINTER = NIL;    LongOne: LONG ORDERED POINTER = Order[Environment.LongPointerFromPage[1]];    ShortNIL: LONG ORDERED POINTER = Order[Long[world, NIL]];    ShortOne: LONG ORDERED POINTER = Order[Long[world, Inline.LowHalf[LongOne]]];    RETURN[      (Order[addr] >= LongNIL AND Order[addr] < LongOne) OR      (Order[addr] >= ShortNIL AND Order[addr] < ShortOne)]};      Long: PUBLIC PROC[world: World, addr: WorldVMOps.ShortAddress] RETURNS[Address] = {    RETURN[LOOPHOLE[Environment.Long[any[low: addr, high: world.esv.mds]], Environment.Long].lu]};    PageOffset: TYPE = [0..wordsPerPage);    PageAndOffsetFromLongPointer: PROCEDURE [p: Address] RETURNS [page: PageNumber, offset: PageOffset] = {    page ¬ Environment.PageFromLongPointer[p];    offset ¬ PageOffset[p - page*wordsPerPage]};      Read: PUBLIC PROC [world: World, addr: Address, process: Process ¬ NullProcess] RETURNS[UNSPECIFIED] = {    mempage: PageNumber;    offset: CARDINAL;    WITH world SELECT FROM client => RETURN[clientProcs.Read[addr, process]]; ENDCASE;    [mempage, offset] ¬ PageAndOffsetFromLongPointer[addr];    RETURN[(GetCS[world, mempage, process].address + offset)­]};      LongRead: PUBLIC PROC [world: World, addr: Address, process: Process ¬ NullProcess] RETURNS[lu: LONG UNSPECIFIED] = {    CopyRead[world: world, from: addr, nwords: 2, to: @lu, process: process]};        CopyRead: PUBLIC PROC [world: World, from: Address, nwords: CARDINAL, to: LONG POINTER, process: Process ¬ NullProcess] = {    mempage: PageNumber;    i: CARDINAL ¬ 0;    count, offset: CARDINAL;    s: Segment;    IF nwords = 0 THEN RETURN;    WITH world SELECT FROM client => { clientProcs.CopyRead[from, nwords, to, process]; RETURN }; ENDCASE;    [mempage, offset] ¬ PageAndOffsetFromLongPointer[from];    s ¬ GetCS[world, mempage, process];    DO      count ¬ MIN[nwords, wordsPerPage-offset];      Inline.LongCOPY[from: s.address+offset, to: to+i, nwords: count];      i ¬ i + count;      IF (nwords ¬ nwords - count) = 0 THEN EXIT;      offset ¬ 0;      s ¬ GetCS[world, mempage ¬ mempage + 1, process];      ENDLOOP};      Write: PUBLIC PROC[world: World, addr: Address, value: UNSPECIFIED, process: Process ¬ NullProcess] = {    WITH world SELECT FROM client => { clientProcs.Write[addr, value, process]; RETURN }; ENDCASE;    WriteCommon[world, addr, value, TRUE, process]};      SpecialWrite: PUBLIC PROC[world: World, addr: Address, value: UNSPECIFIED, process: Process ¬ NullProcess] = {    WriteCommon[world, addr, value, FALSE, process]};      WriteCommon: PROC[world: World, addr: Address, value: UNSPECIFIED, protect: BOOLEAN, process: Process] = {    mempage: PageNumber;    offset: CARDINAL;    s: Segment;    [mempage, offset] ¬ PageAndOffsetFromLongPointer[addr];    s ¬ GetCS[world, mempage, process];    IF s.writeprotect AND protect THEN ERROR WriteProtected[addr];    (s.address + offset)­ ¬ value;    s.dirty ¬ TRUE};      LongWrite: PUBLIC PROC[world: World, addr: Address, value: LONG UNSPECIFIED, process: Process ¬ NullProcess] = {    CopyWrite[world: world, from: @value, nwords: 2, to: addr, process: process]};      CopyWrite: PUBLIC PROC [world: World, from: LONG POINTER, nwords: CARDINAL, to: Address, process: Process ¬ NullProcess] = {    mempage: PageNumber;    i: CARDINAL ¬ 0;    count, offset: CARDINAL;    s: Segment;    IF nwords = 0 THEN RETURN;    WITH world SELECT FROM client => { clientProcs.CopyWrite[from, nwords, to, process]; RETURN }; ENDCASE;    [mempage, offset] ¬ PageAndOffsetFromLongPointer[to];    s ¬ GetCS[world, mempage, process];    DO      IF s.writeprotect THEN ERROR WriteProtected[mempage];      s.dirty ¬ TRUE;      count ¬ MIN[nwords, wordsPerPage-offset];      Inline.LongCOPY[to: s.address+offset, from: from+i, nwords: count];      IF (nwords ¬ nwords - count) = 0 THEN EXIT;      i ¬ i + count;      offset ¬ 0;      s ¬ GetCS[world, mempage ¬ mempage + 1, process];      ENDLOOP };        SetupBootFile: PROC[world: World] = {    CreateCache[@world.cacheLock, world];    KillCache[@world.cacheLock, world];    WITH world SELECT FROM      local => NULL;      outload => {         ENABLE UNWIND => IF world.type = outload THEN StopOutload[NARROW[world, OutloadWorld]];        -- UnmapMFSpace[world];         -- UnmapBootSpace[NARROW[world, OutloadWorld]]; 	-- UnmapBFM[@world.cacheLock, NARROW[world, OutloadWorld]];        MapMFSpace[world];        MapBootSpace[NARROW[world, OutloadWorld]]; 	MapBFM[@world.cacheLock, NARROW[world, OutloadWorld]] };      remote => {         ENABLE UNWIND => IF world.type = remote THEN StopTeledebugging[NARROW[world, RemoteWorld]];        -- UnmapMFSpace[world];        -- WVMCacheOps.ReleaseRemoteBootFile[NARROW[world, RemoteWorld]];        MapMFSpace[world];        WVMCacheOps.SetupRemoteBootFile[NARROW[world, RemoteWorld]] };      client => NULL;      ENDCASE };        FlushBootFile: PROC[world: World] = {    FlushCache[@world.cacheLock, world];    -- KillCache[world];    WITH world SELECT FROM      local => NULL;       outload => { 	-- UnmapBFM[@world.cacheLock, NARROW[world, OutloadWorld]];	-- make sure anything written to outload file gets flushed        FlushBootSpace[NARROW[world, OutloadWorld]]; 	-- UnmapMFSpace[world]; -- };      remote => {         -- don't do anything        -- this shouldnt stop teledebugging --        WVMCacheOps.FlushRemoteBootFile[NARROW[world, RemoteWorld]];	-- UnmapMFSpace[world] -- };      client => NULL;      ENDCASE };        MapBFM: ENTRY PROC[l: Lock, world: OutloadWorld] = {    -- bootfile consists of one header and some number of trailers.    ENABLE UNWIND => NULL;    curmax: CARDINAL ¬ BootFile.maxEntriesPerHeader;    curbase: File.PageNumber ¬ 0;    bfh: LONG POINTER TO BootFile.Header ¬ BootFileAddress[world.bootArea.bootSpace, curbase];    entries: LONG POINTER TO ARRAY [0..0) OF BootFile.MapEntry ¬ @bfh.entries;    pagesremaining: CARDINAL ¬ CARDINAL[bfh.countData];    bfmHeadSize: CARDINAL ¬ ((CARDINAL[bfh.countData] - BootFile.maxEntriesPerHeader + BootFile.maxEntriesPerTrailer - 1)/BootFile.maxEntriesPerTrailer) + 1;    IF bfh.version # BootFile.currentVersion OR pagesremaining > 16384 «sanity check 8M memory» THEN RETURN WITH ERROR WorldVM.BadWorld;    IF world.bootArea.bfmHead = NIL THEN {      world.bootArea.bfmHead ¬ zone.NEW[BootFileHeadersObject[bfmHeadSize]];       --NOTIFY world.bootArea.bfmHeadOK-- }    ELSE {      IF world.bootArea.bfmHead.max # bfmHeadSize THEN {        zone.FREE[@world.bootArea.bfmHead];        world.bootArea.bfmHead ¬ zone.NEW[BootFileHeadersObject[bfmHeadSize]]}};    FOR n: CARDINAL IN [0..world.bootArea.bfmHead.max) DO       entryCount: CARDINAL = MIN[curmax, pagesremaining];      IF BootFileAddress[world.bootArea.bootSpace, curbase]­ # BootFile.currentVersion THEN RETURN WITH ERROR WorldVM.BadWorld;      world.bootArea.bfmHead[n] ¬ [entries: entries, entryCount: entryCount, lastMemPage: entries[entryCount-1].virtual, filePageOffset: curbase+1];      pagesremaining ¬ pagesremaining - entryCount;       curbase ¬ curbase + 1 + entryCount;      entries ¬ BootFileAddress[world.bootArea.bootSpace, curbase] + SIZE[BootFile.Trailer];      curmax ¬ BootFile.maxEntriesPerTrailer;      ENDLOOP;    IF pagesremaining # 0 THEN ERROR };    UnmapBFM: ENTRY PROC[l: Lock, world: OutloadWorld] = {    ENABLE UNWIND => NULL;    IF world.bootArea.bfmHead # NIL THEN zone.FREE[@world.bootArea.bfmHead] };        MapBootSpace: PROC[world: OutloadWorld] = {    IF world.bootArea.bootSpace.pointer = NIL THEN {      IF Riggle.RiggleWorld[world] THEN Riggle.RiggleMapBootSpace[world]       ELSE world.bootArea.bootSpace ¬ Space.Map[window: [file: world.file, base: world.leaderPages, count: Environment.lastPageCount], swapUnits: [uniform[1]]         ! Space.Error => {}]}    ELSE world.bootArea.bootSpace ¬ Space.MapAt[at: world.bootArea.bootSpace, window: [file: world.file, base: world.leaderPages, count: Environment.lastPageCount], swapUnits: [uniform[1]]	! Space.Error => {}]};	    UnmapBootSpace: PROC[world: OutloadWorld] = {    IF world.bootArea.bootSpace.pointer # NIL THEN {      IF Riggle.RiggleWorld[world] THEN Riggle.RiggleUnMapBootSpace[world]      ELSE world.bootArea.bootSpace.pointer ¬ Space.Unmap[world.bootArea.bootSpace.pointer] }};	    FlushBootSpace: PROC[world: OutloadWorld] = {    IF world.bootArea.bootSpace.pointer # NIL THEN {      IF Riggle.RiggleWorld[world] THEN Riggle.RiggleUnMapBootSpace[world]      ELSE world.bootArea.bootSpace ¬ Space.UnmapAt[world.bootArea.bootSpace.pointer] }};        WordSeq: TYPE = RECORD [SEQUENCE COMPUTED CARDINAL OF WORD];        MapMFSpace: PROC[world: World] = {    DoMaplog: PROC[maplog: LONG POINTER TO Maplog] = {      IF maplog.space.pointer = NIL THEN {	maplog.space ¬ [pointer: zone.NEW[WordSeq[mfMapPages*wordsPerPage]], count: mfMapPages];	maplog.logDesc ¬ [count: 0, limit: (mfMapPages*wordsPerPage)/MFEntrySize, entries: maplog.space.pointer];	maplog.firstTime ¬ TRUE;	maplog.lastEntry ¬ NIL; }};    WITH world SELECT FROM      outload => DoMaplog[@maplog];      remote => DoMaplog[@maplog];      ENDCASE };        UnmapMFSpace: PROC[world: World] = {    UndoMaplog: PROC[maplog: LONG POINTER TO Maplog] = {      IF maplog.space.pointer # NIL THEN {        zone.FREE[@maplog.space.pointer];        maplog.firstTime ¬ TRUE;	maplog.logDesc ¬ [0,0,NIL];	maplog.space ¬ Space.nullInterval;	maplog.lastEntry ¬ NIL }};    WITH world SELECT FROM      outload => UndoMaplog[@maplog];      remote => UndoMaplog[@maplog];      ENDCASE };    ProcessVMMapLog: PROC [world: World] = {    Process: PROC[maplog: LONG POINTER TO Maplog] = {      root: LONG POINTER TO VMMapLog.Descriptor = world.esv.mapLog;      base: VMMapLog.EntryBasePointer;      entry: VMMapLog.Entry;      reader, writer, limit: VMMapLog.EntryPointer;      maplog.lastEntry ¬ NIL;      IF root = NIL THEN RETURN;      CopyRead[world: world, from: @root.self, to: @entry, nwords: MFEntrySize];      base ¬ Environment.LongPointerFromPage[VMMapLog.SeeEntry[@entry].page];      reader ¬ Read[world, @root.reader];      writer ¬ Read[world, @root.writer];      limit ¬ Read[world, @root.limit];      IF maplog.firstTime OR ResetMaplog[world] THEN {        reader ¬ LOOPHOLE[0]; -- big assumptions here. 	maplog.logDesc.entries[0] ¬ entry; 	maplog.logDesc.count ¬ 1; 	maplog.firstTime ¬ FALSE; };      UNTIL reader = writer DO	CopyRead[world, @base[reader], MFEntrySize, @entry	  ! AddressFault => { TTY.PutLine[world.tty, " Invalid maplog!"L]; EXIT }];	VMMapLog.InsertEntry[@entry, @maplog.logDesc	  ! VMMapLog.LogFull => { ExpandMapLog[maplog]; RETRY };	    VMMapLogExtras.Bug => IF type = duplicateOrOverlappingMapEntry THEN RESUME];	reader ¬ reader + MFEntrySize;	IF reader = limit THEN reader ¬ FIRST[VMMapLog.EntryPointer];	ENDLOOP };      WITH world SELECT FROM        outload => Process[@maplog];	remote => Process[@maplog];	ENDCASE };	  ExpandMapLog: PROC[maplog: LONG POINTER TO Maplog] = {    extra: CARDINAL = 10;    new: LONG POINTER ¬ zone.NEW[WordSeq[(CARDINAL[maplog.space.count]+extra)*wordsPerPage]];    Inline.LongCOPY[from: maplog.space.pointer, to: new, nwords: CARDINAL[maplog.space.count]*wordsPerPage];    zone.FREE[@maplog.space.pointer];    maplog.space.pointer ¬ maplog.logDesc.entries ¬ new;    maplog.space.count ¬ maplog.space.count+extra;    maplog.logDesc.limit ¬ (CARDINAL[maplog.space.count]*wordsPerPage)/MFEntrySize;    maplog.lastEntry ¬ NIL; };  LookupVMMapEntry: PROC [world: World, mempage: PageNumber] RETURNS [VMMapLog.EntryHandle] = {    Lookup: PROC[maplog: LONG POINTER TO Maplog] RETURNS[VMMapLog.EntryHandle] = {      IF maplog.lastEntry # NIL AND VMMapLog.InEntry[mempage, maplog.lastEntry] THEN RETURN[maplog.lastEntry];      maplog.lastEntry ¬ VMMapLog.FindEntry[mempage, @maplog.logDesc ! VMMapLog.Unmapped => { maplog.lastEntry ¬ NIL; CONTINUE }];      RETURN[maplog.lastEntry]};    WITH world SELECT FROM      outload => RETURN[Lookup[@maplog]];      remote => RETURN[Lookup[@maplog]];      ENDCASE => RETURN[NIL] };    swapInfoAddr: LONG POINTER TO CPSwapDefs.SwapInfo = LOOPHOLE[@PSB.PDA.available];      PutLocalESV: PROC[world: World] = INLINE {    esvAddr: LONG POINTER TO CPSwapDefs.ExternalStateVector = (swapInfoAddr­.externalStateVector);    -- do not write over anything besides swapData    esvAddr­.swapData ¬ world.esv.swapData};      GetLocalESV: PROC[world: World] = INLINE {    esvAddr: LONG POINTER TO CPSwapDefs.ExternalStateVector = (swapInfoAddr­.externalStateVector);    world.esv ¬ esvAddr­ };      PutNonLocalESV: PROC[world: World] =  {    esvAddr: WorldVMOps.Address = LongRead[world, @(swapInfoAddr­.externalStateVector)];    -- maplog stuff    WITH world SELECT FROM      local => ERROR;      outload => {        root: LONG POINTER TO VMMapLog.Descriptor = world.esv.mapLog;	writer: VMMapLog.EntryPointer;	IF root # NIL THEN {	  writer ¬ Read[world, @root.writer];          SetMaplog[world, FALSE];	  Write[world, @root.reader, writer] }};      remote => NULL;      client => NULL;      ENDCASE;     CopyWrite[world: world, from: @world.esv, nwords: SIZE[CPSwapDefs.ExternalStateVector], to: esvAddr] };    WordBoolean: TYPE = RECORD[SELECT OVERLAID * FROM word => [w: WORD], bool => [b: BOOLEAN], ENDCASE];        ResetMaplog: PROC[world: World] RETURNS[BOOLEAN] = {    wordBoolean: WordBoolean ¬ [word[world.esv.spareA]]; -- Pilot 12.2 or greater if TRUE    RETURN[wordBoolean.b]; };      SetMaplog: PROC[world: World, b: BOOLEAN] = {    wordBoolean: WordBoolean ¬ [bool[b]]; -- Pilot 12.2 or greater will set TRUE    world.esv.spareA ¬ wordBoolean.w; };    GetNonLocalESV: PROC[world: World] RETURNS[newSession: BOOLEAN] =  {    oldBootSession: LONG CARDINAL = world.esv.bootSession;    esvAddr: WorldVMOps.Address = LongRead[world, @(swapInfoAddr­.externalStateVector)];    CopyRead[world: world, from: esvAddr, nwords: SIZE[CPSwapDefs.ExternalStateVector], to: @world.esv];    newSession ¬ (oldBootSession # world.esv.bootSession) };        GFT: PROC[version: CARDINAL] RETURNS[BOOLEAN] = {    SELECT version FROM      CPSwapDefs.oldVersion --01054-- => RETURN[FALSE];      CPSwapDefs.currentVersion --01055-- => RETURN[TRUE];      ENDCASE => ERROR WorldVM.BadWorld; };        GetMaplog: PUBLIC PROC[world: World] = {    ENABLE UNWIND => NULL;    WITH world SELECT FROM      local => {        SetupBootFile[world ! ABORTED => {}];        GetLocalESV[world];	world.globalFrameTable ¬ GFT[world.esv.version];        world.esv.mds ¬ Inline.HighHalf[Space.MDS[].pointer]};      outload => {        newSession: BOOLEAN;	IF NOT world.running AND world.state # creating THEN ERROR;        SetupBootFile[world ! ABORTED => {}];        newSession ¬ GetNonLocalESV[world];	world.globalFrameTable ¬ GFT[world.esv.version];	maplog.firstTime ¬ newSession;	IF ~maplog.ignoreMaplog THEN ProcessVMMapLog[world] };        remote => {        newSession: BOOLEAN;        IF NOT world.running AND world.state # creating THEN ERROR;        SetupBootFile[world ! ABORTED => {}];        newSession ¬ GetNonLocalESV[world];	world.globalFrameTable ¬ GFT[world.esv.version];	maplog.firstTime ¬ TRUE; 	ProcessVMMapLog[world] };       client => {        newSession: BOOLEAN;        IF NOT world.running AND world.state # creating THEN ERROR;        newSession ¬ GetNonLocalESV[world];	world.globalFrameTable ¬ GFT[world.esv.version] };      ENDCASE;    world.loadstate ¬ AMLoadstate.AcquireLoadstate[world ! AMLoadstate.Error => {world.loadstate ¬ NIL; CONTINUE}]};      FlushMaplog: PUBLIC PROC[world: World] = {    WITH world SELECT FROM      local => PutLocalESV[world];      outload => PutNonLocalESV[world];      remote => PutNonLocalESV[world];       client => PutNonLocalESV[world];      ENDCASE;    FlushBootFile[world]};        StopLocal: PUBLIC PROC[world: LocalWorld] = {    DeleteCache[@world.cacheLock, world];    AMLoadstate.DestroyLoadstate[world.loadstate];    world.loadstate ¬ NIL };      StopOutload: PUBLIC PROC[world: OutloadWorld] = {    DeleteCache[@world.cacheLock, world];    UnmapMFSpace[world];    UnmapBootSpace[world];     UnmapBFM[@world.cacheLock, world];    WVMCacheOps.CloseOutload[world];    AMLoadstate.DestroyLoadstate[world.loadstate];     world.loadstate ¬ NIL };      StopTeledebugging: PUBLIC PROC[world: RemoteWorld] = {    DeleteCache[@world.cacheLock, world];    UnmapMFSpace[world];    WVMCacheOps.CloseConnection[world];    AMLoadstate.DestroyLoadstate[world.loadstate];      world.loadstate ¬ NIL };      StopClient: PUBLIC PROC[world: ClientWorld] = {    world.clientProcs.StopClient[] };        }.
-- Copyright (C) 1985  by Xerox Corporation. All rights reserved. DIRECTORY  Alloc USING [Top],  Copier USING [HtiToMdi],  IO, IP, IQ, IT,  String USING [EquivalentString],  Symbols USING [MDNull, MDRecord, mdType, OwnMdi];ITSymsHot: PROGRAM  IMPORTS Alloc, Copier, IO, IP, IQ, String  EXPORTS IQ = {  OPEN IT;  NoFGT: PUBLIC ERROR = CODE;  ZeroMdi: ERROR = CODE;  SymbolTableProblem: ERROR = CODE;      Enumerate: PUBLIC PROC [h: Handle, proc: PROC [IT.ModItem] RETURNS [BOOLEAN]] RETURNS [syms: IT.ModItem] = {    FOR t: IT.ModCache ¬ Head, t.link UNTIL t = NIL DO      FOR i: CARDINAL IN [0..t.cnt) DO        syms ¬ @t.subCache[i];        IF syms.allocated AND proc[syms] THEN RETURN;	ENDLOOP;      ENDLOOP;    RETURN[NIL]};    FindMod: PUBLIC PROC [h: Handle, name: HTIndex] RETURNS [IT.ModItem] = {    mdi: MDIndex = Copier.HtiToMdi[h.sym, name];    IF mdi = Symbols.MDNull THEN RETURN[NIL] ELSE RETURN[FindMdi[h, mdi]]};  FindMdi: PUBLIC PROC [h: Handle, mdi: MDIndex] RETURNS [IT.ModItem] = {    Find: PROC [syms: IT.ModItem] RETURNS[BOOLEAN] = {RETURN[mdi = syms.mdi]};    RETURN[Enumerate[h, Find]]};  FindFrame: PUBLIC PROC [h: Handle, gf: GFHandle] RETURNS [i: IT.ModItem] = {    Find: PROC [syms: IT.ModItem] RETURNS[BOOLEAN] = {RETURN[(gf = syms.frames[0].gf) AND (h.world = syms.frames[0].world)]};    RETURN[Enumerate[h, Find]]};  FileMdi: PUBLIC PROC [h: Handle, hti: HTIndex, fgt: BOOLEAN ¬ FALSE] RETURNS [MDIndex] = {    limit: MDIndex = Alloc.Top[IO.alloc, Symbols.mdType];    mdiName: STRING ¬ [MaxModuleString];    filename: STRING ¬ [MaxModuleString];    syms: IT.ModItem ¬ NIL;    IP.HtiToString[h, hti, filename];    FOR mdi: MDIndex ¬ Symbols.OwnMdi, mdi + SIZE[Symbols.MDRecord] UNTIL mdi = limit DO      mdiName.length ¬ 0;       IP.HtiToString[h, h.mdb[mdi].moduleId, mdiName];      IF String.EquivalentString[mdiName, filename] THEN {syms ¬ FindMdi[h, mdi]; EXIT};      ENDLOOP;    IF syms = NIL THEN syms ¬ IQ.OpenFile[h, NILGF, filename, hti];    SetSegment[h, syms, fgt];    RETURN[syms.mdi]};  GFrameMdi: PUBLIC PROC [h: Handle, gf: GFHandle, fgt: BOOLEAN ¬ FALSE] RETURNS [MDIndex] = {    RETURN[SetUp[h,gf,fgt].mdi]};  Stopping: PUBLIC PROC [h: Handle, gf: GFHandle, fgt: BOOLEAN ¬ FALSE] RETURNS [BOOLEAN] = {    RETURN[SetUp[h,gf,fgt].stopping]};  CrossJumped: PUBLIC PROC [h: Handle, gf: GFHandle, fgt:BOOLEAN ¬ FALSE] RETURNS[BOOLEAN] = {    RETURN[SetUp[h,gf,fgt].crossJumped]};  SetUp: PROC [h: Handle, gf: GFHandle, fgt: BOOLEAN ¬ FALSE] RETURNS [syms: IT.ModItem] = {    IQ.CheckGF[h, gf];    IF (syms ¬ FindFrame[h, gf]) = NIL THEN syms ¬ IQ.AddItem[h, gf];    SetSegment[h, syms, fgt]};  SetSegment: PUBLIC PROC [h: Handle, syms: IT.ModItem, fgt: BOOLEAN] = {    SELECT TRUE FROM      syms.mdi = Symbols.OwnMdi => ERROR ZeroMdi;      ~fgt OR syms.fgtAvailable => RETURN;      ENDCASE => ERROR NoFGT};    Head: PUBLIC IT.ModCache ¬ IO.Pages[1];  Head.link ¬ NIL;   Head.cnt ¬ 0;    }.
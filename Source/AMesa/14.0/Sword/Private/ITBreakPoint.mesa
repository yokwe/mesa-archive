-- Copyright (C) 1986  by Xerox Corporation. All rights reserved. -- ITBreakPoint.Mesa, edited by,DIRECTORY  AMEvents USING [BreakID, BytePC, ClearBreak, DuplicateBreakpoint, FrameBreak, NextBreak],  AMLoadstate USING [GFHandle, Handle, MapRealToEnh],  AMUseful USING [NoModule],  BcdOps USING [ENHandle],  CommandList USING [BPError, CSRptr],  CommandTab USING [],  IB USING [GetModule],  IC USING [GFFromControlLink, PCFromControlLink],  IO USING [Char, Decimal, EOL, FreeNode, FreeString, Line, Node, StringExpToDecimal, StringExpToLDecimal, SubString, Text, zone],  IP USING [CBti, CodeBase, DerefProcDesc, DisplayInMsg, DisplaySource, ExitPC, Fail, FileMissing, GetControlLink, MultipleFrames, NotAProcedure, OnStack, Original, StringToHti],  IQ USING [BPAbortWithError, BPAbortWithWrittenError, BPWriteError, CheckGF, ClearCondition, Conditionalize, FreeUserBB, GFrameMdi, InvalidFrame, NoFGT],  IS USING [HashVal, LongNum, Num, WriteError],  IT USING [BBHandle, BreakBlock, BreakType, BYTE, BytePC, CBTIndex, ControlLink, EXOI, Foo, GFHandle, Handle, HTIndex],  Runtime USING [ControlLink, GetTableBase, GlobalFrame],  String USING [AppendSubString, CopyToNewString, SubStringDescriptor],  Symbols USING [CBTNull, lL],  SymbolTable USING [Missing],  WorldVMExtras USING [GetBreakNumber, SetBreakNumber],  WorldVMOps USING [GetLoadstate, GFshort, IllegalPatch, ReadCodeByte],  WVMPatch USING [PatchTableFull];  ITBreakPoint: PROGRAM  IMPORTS AMEvents, AMLoadstate, AMUseful, CommandTab, IB, IC, IO, IP, IQ, IS, Runtime, String, SymbolTable, WorldVMExtras, WorldVMOps, WVMPatch  EXPORTS IQ = {  -- THE LINK field of a BBHandle is the AMEvents.BreakID.        BPFail: PUBLIC SIGNAL [type: CommandList.BPError] = CODE;     Alloc: PROC [h: IT.Handle]  RETURNS [bb: IT.BBHandle] = {    bb ¬ IO.Node[h, SIZE[IT.BreakBlock]]};      Free: PROC [h: IT.Handle, bb: IT.BBHandle, newSession: BOOLEAN] = {    IF bb.condition # NIL THEN {      IO.FreeString[h, bb.condition];      bb.condition ¬ NIL;      IF ~newSession THEN IQ.FreeUserBB[h, IP.CodeBase[h, bb.gf], bb.pc]};    IF bb.exp # NIL THEN IO.FreeString[h, bb.exp];    IO.FreeNode[h, bb]};          EnumerateBBs: PUBLIC PROC [h: IT.Handle, proc: PROC [IT.Handle, IT.BBHandle] RETURNS [stop: BOOLEAN], gf: IT.GFHandle ¬ NIL] RETURNS [bb: IT.BBHandle] = {    breakID: AMEvents.BreakID;    [breakID, bb] ¬ AMEvents.NextBreak[h.world, NIL];    UNTIL breakID = NIL DO      IF (gf = NIL OR bb.gf = gf) AND proc[h, bb] THEN RETURN;      [breakID, bb] ¬ AMEvents.NextBreak[h.world, breakID];      ENDLOOP};      DeleteBB: PROC [h: IT.Handle, bb: IT.BBHandle] = {    Find: PROC [h: IT.Handle, break: IT.BBHandle] RETURNS [stop: BOOLEAN] = {RETURN[bb = break]};    IF EnumerateBBs[h, Find, bb.gf] = NIL THEN BPWriteError[h, notFound];    Free[h, bb, FALSE]};      FindBB: PUBLIC PROC [h: IT.Handle, gf: IT.GFHandle, pc: IT.BytePC] RETURNS [bb: IT.BBHandle] = {    FindOne: PROC [h: IT.Handle, b: IT.BBHandle] RETURNS [BOOLEAN] = { RETURN[b.pc = pc] };    gf ¬ IP.Original[h, gf ! IQ.InvalidFrame => CONTINUE];    bb ¬ EnumerateBBs[h, FindOne, gf]};      FindBBNum: PUBLIC PROC [h: IT.Handle, c: CARDINAL] RETURNS [bb: IT.BBHandle] = {    FindOne: PROC [h: IT.Handle, b: IT.BBHandle] RETURNS [BOOLEAN] = { RETURN[b.num = c] };    bb ¬ EnumerateBBs[h, FindOne]};      Insert: PUBLIC PROC [h: IT.Handle, gf: IT.GFHandle, pc: IT.BytePC, bt: IT.BreakType, haveSyms: BOOLEAN] RETURNS [bb: IT.BBHandle ¬ NIL] = {    inst: IT.BYTE;    IQ.CheckGF[h, gf];    IF (bb ¬ FindBB[h, gf, pc]) # NIL THEN {      IF bb.bt.bt = bt.bt THEN ERROR BPFail[alreadySet]      ELSE { bb.bt.bt ¬ bt.bt; RETURN }};    gf ¬ IP.Original[h, gf];    --IF (inst ¬ WorldVMOps.ReadCodeByte[h.world, IP.CodeBase[h, gf], pc]) = Mopcodes.zBRK THEN ERROR BPFail[alreadySet];    inst ¬ WorldVMOps.ReadCodeByte[h.world, IP.CodeBase[h, gf], pc];    bb ¬ Alloc[h];    bb­ ¬ [link: NIL, gf: gf, inst: inst, pc: pc, bt: bt, symbolsAvailable: haveSyms, num: TRASH, context: NIL, condition: NIL, exp: NIL, there: FALSE, step: FALSE];    WorldVMExtras.SetBreakNumber[h.world, bb.num ¬ WorldVMExtras.GetBreakNumber[h.world] + 1];    bb.link ¬ LOOPHOLE[      AMEvents.FrameBreak[h.world, gf, pc, bb	! WVMPatch.PatchTableFull => ERROR BPFail[patchTableFull]; 	  AMEvents.DuplicateBreakpoint => { bb.link ¬ LOOPHOLE[id]; CONTINUE };	  WorldVMOps.IllegalPatch => CONTINUE ]]};    Remove: PUBLIC PROC [h: IT.Handle, gf: IT.GFHandle, pc: IT.BytePC] = {    p: IT.BBHandle;    id: AMEvents.BreakID;    gf ¬ IP.Original[h, gf ! IQ.InvalidFrame => CONTINUE];    IF (p ¬ FindBB[h, gf, pc]) = NIL THEN ERROR BPFail[notFound];    id ¬ LOOPHOLE[p.link];    DeleteBB[h, p];    AMEvents.ClearBreak[id ! WorldVMOps.IllegalPatch => CONTINUE]};      GetCbti: PROC [h: IT.Handle, s: LONG STRING] RETURNS [cbti: IT.CBTIndex, cl: IT.ControlLink] = {    hti: IT.HTIndex = IP.StringToHti[h, s];    f: IT.Foo ¬ IP.OnStack[h: h, id: hti, check: FALSE];    IF f = NIL THEN ERROR IP.Fail[s];    cl ¬ IP.DerefProcDesc[h, IP.GetControlLink[h, f]];    cbti ¬ IP.CBti[h, IC.PCFromControlLink[h, cl], IC.GFFromControlLink[h, cl]]};      SetUp: PROC [h: IT.Handle, s: LONG STRING, ex: IT.EXOI, noSyms: BOOLEAN ¬ FALSE] RETURNS [gf: IT.GFHandle, pc: IT.BytePC] = {    cl: IT.ControlLink;    cbti: IT.CBTIndex;    [cbti, cl] ¬ GetCbti[h, s ! IP.NotAProcedure => GOTO Inline];    IF CheckInline[h, cbti] THEN GOTO Inline;    gf ¬ IC.GFFromControlLink[h, cl];    IF ex = entry THEN pc ¬ IC.PCFromControlLink[h, cl] + 1 -- skip fsi byte    ELSE {      IF cbti = Symbols.CBTNull THEN IQ.BPAbortWithWrittenError[h, noSym];      pc ¬ IP.ExitPC[h, cbti] };    EXITS Inline => IQ.BPAbortWithWrittenError[h, inInline]};      CheckInline: PROC [h: IT.Handle, cbti: IT.CBTIndex]     RETURNS [inline: BOOLEAN] = {    IF cbti = Symbols.CBTNull THEN RETURN[FALSE] ELSE RETURN[h.bb[cbti].inline]};      SetIt: PROC [h: IT.Handle, body: LONG STRING, bt: IT.BreakType] = {    gf: IT.GFHandle;    pc: IT.BytePC;    syms: BOOLEAN ¬ TRUE;    [gf, pc] ¬ SetUp[h, body, bt.ex];    [] ¬ IQ.GFrameMdi[h, gf, TRUE ! IQ.NoFGT, SymbolTable.Missing => {syms ¬ FALSE; CONTINUE}];    IO.Char[h, ' ];    SetOne[h, gf, pc, bt, syms]};      SetOne: PROC [h: IT.Handle, gf: IT.GFHandle, pc: IT.BytePC, bt: IT.BreakType, syms: BOOLEAN] = {    bb: IT.BBHandle;    bb ¬ Insert[h, gf, pc, bt, syms ! BPFail => BPWriteError[h, type]];    IO.Text["Breakpoint #"L, h]; IO.Decimal[h, bb.num];    IO.Line[h, "."L] };      ClearIt: PROC [h: IT.Handle, body: LONG STRING, ex: IT.EXOI] = {    pc, noSymsPc: IT.BytePC;    gf: IT.GFHandle;    [gf, pc] ¬ SetUp[h, body, ex];    FOR nosyms: BOOLEAN IN BOOLEAN DO      Remove[h, gf, pc ! BPFail =>	IF nosyms OR type # notFound OR ex # entry THEN BPWriteError[h, type] 	ELSE {	  noSymsPc ¬ SetUp[h, body, ex, TRUE].pc;	  IF noSymsPc = pc THEN BPWriteError[h, type] ELSE {pc ¬ noSymsPc; LOOP}}];      EXIT;      ENDLOOP};      ClearAllBreaks: PUBLIC PROC[h: IT.Handle] = {ClearAll[h, FALSE]};  ClearAllTraces: PUBLIC PROC[h: IT.Handle] = {ClearAll[h, TRUE]};  ClearAll: PROC[h: IT.Handle, justTraces: BOOLEAN] = {    breakID: AMEvents.BreakID;    bb: IT.BBHandle;    [breakID, bb] ¬ AMEvents.NextBreak[h.world, NIL];    IF breakID = NIL THEN RETURN; -- no message please    IO.EOL[h];    UNTIL breakID = NIL DO      nextbb: IT.BBHandle;      [breakID, nextbb] ¬ AMEvents.NextBreak[h.world, breakID];      IF ~justTraces OR bb.bt.bt = trace THEN Remove[h, bb.gf, bb.pc ! BPFail => { CantRemove[h, bb, type]; CONTINUE }];      bb ¬ nextbb;      REPEAT FINISHED => {         IO.Text["All "L, h];        IO.Text[IF justTraces THEN "traces"L ELSE "breaks"L, h]; 	IO.Line[h, " cleared"L] };      ENDLOOP };      CantRemove: PROC[h: IT.Handle, bb: IT.BBHandle, type: CommandList.BPError] = {    IO.Decimal[h, bb.num]; IO.Text[" -- "L, h]; BPWriteError[h, type]; IO.EOL[h]};      GetBreak: PROC [h: IT.Handle, num: LONG STRING] RETURNS [bb: IT.BBHandle] = {    i: INTEGER ¬ IO.StringExpToDecimal[h, num];    bb ¬ FindBBNum[h, LOOPHOLE[i,CARDINAL]];    IF bb = NIL THEN {BPWriteError[h, notFound]; IO.EOL[h]}};      AtBreak: PROC[h: IT.Handle] RETURNS [BOOLEAN] = {    IF h.bbh = NIL THEN IS.WriteError[h, notAtBreak, FALSE] ELSE IO.Decimal[h, h.bbh.num];    IO.EOL[h];    RETURN[h.bbh # NIL]};  ClearBreak: PUBLIC PROC [h: IT.Handle, bbNum: LONG STRING] = {ClearDefault[h, GetBreak[h, bbNum]]};  ClearDefault: PUBLIC PROC [h: IT.Handle, bb: IT.BBHandle] = {IF bb # NIL THEN Remove[h, bb.gf, bb.pc]};  BreakEntry: PUBLIC PROC [h: IT.Handle, proc: LONG STRING] = {SetIt[h, proc,[entry,break]]};  BreakExit: PUBLIC PROC [h: IT.Handle, proc: LONG STRING] = {SetIt[h, proc,[exit,break]]};  TraceEntry: PUBLIC PROC [h: IT.Handle, proc: LONG STRING] = {SetIt[h, proc,[entry,trace]]};  TraceExit: PUBLIC PROC [h: IT.Handle, proc: LONG STRING] = {SetIt[h, proc,[exit,trace]]};  ClearEntryBreak, ClearEntryTrace: PUBLIC PROC [h: IT.Handle, proc: LONG STRING] = {ClearIt[h, proc,entry]};  ClearXitBreak, ClearXitTrace: PUBLIC PROC [h: IT.Handle, proc: LONG STRING] = {ClearIt[h, proc,exit]};  BreakAllEntries: PUBLIC PROC [h: IT.Handle, mod, exp: LONG STRING] = {DoAll[h, mod,[entry,break],exp,TRUE]};  BreakAllXits: PUBLIC PROC [h: IT.Handle, mod, exp: LONG STRING] = {DoAll[h, mod,[exit,break],exp,TRUE]};  TraceAllEntries: PUBLIC PROC [h: IT.Handle, mod, exp: LONG STRING] = {DoAll[h, mod,[entry,trace],exp,TRUE]};  TraceAllXits: PUBLIC PROC [h: IT.Handle, mod, exp: LONG STRING] = {DoAll[h, mod,[exit,trace],exp,TRUE]};  ClearAllEntries: PUBLIC PROC [h: IT.Handle, mod: LONG STRING] = {DoAll[h, mod,[entry,break],NIL,FALSE]};  ClearAllXits: PUBLIC PROC [h: IT.Handle, mod: LONG STRING] = {DoAll[h, mod,[exit,break],NIL,FALSE]};  ClearExpression: PUBLIC PROC [h: IT.Handle, bbNum: LONG STRING] = {AttachExpression[h, bbNum,NIL]};      Expressionalize: PUBLIC PROC [h: IT.Handle, bb: IT.BBHandle, exp: LONG STRING] = {    IF bb = NIL THEN RETURN;    IF bb.exp # NIL THEN IO.FreeString[h, bb.exp];    bb.exp ¬ exp};      AttachExpression: PUBLIC PROC [h: IT.Handle, bbNum, exp: LONG STRING] = {    bb: IT.BBHandle ¬ FindBBNum[h, IO.StringExpToDecimal[h, bbNum]];    IF bb # NIL THEN Expressionalize[h, bb, String.CopyToNewString[exp, IO.zone]]    ELSE IQ.BPAbortWithWrittenError[h, notFound]};  DisplayB: PUBLIC PROC [h: IT.Handle, s: LONG STRING] = {    SELECT TRUE FROM      s.length # 0 => {IO.EOL[h]; ListBreak[h, s]};      AtBreak[h] => {IO.EOL[h]; List[h, h.bbh]};      ENDCASE};        ClearB: PUBLIC PROC [h: IT.Handle, s: LONG STRING] = {    IF s.length # 0 THEN {ClearBreak[h, s]; h.bbh ¬ NIL; RETURN};    IF AtBreak[h] THEN {ClearDefault[h, h.bbh]; h.bbh ¬ NIL}};      ClearC: PUBLIC PROC [h: IT.Handle, s: LONG STRING] = {    IF s.length # 0 THEN {IQ.ClearCondition[h, s]; RETURN};    IF AtBreak[h] THEN IQ.Conditionalize[h, h.bbh, NIL]};      ClearE: PUBLIC PROC [h: IT.Handle, s: LONG STRING] = {    IF s.length # 0 THEN {AttachExpression[h, s, NIL]; RETURN};    IF AtBreak[h] THEN Expressionalize[h, h.bbh, NIL]};    DoAll: PROC [h: IT.Handle, mod: LONG STRING, bt: IT.BreakType, exp: LONG STRING, set: BOOLEAN] = {    enh: BcdOps.ENHandle;    pc: IT.BytePC;    cbti: IT.CBTIndex;    gf: IT.GFHandle;    gf ¬ IB.GetModule[h, mod ! IP.MultipleFrames => {gf ¬ list[0]; CONTINUE}];    [] ¬ IQ.GFrameMdi[h, gf ! SymbolTable.Missing => {IQ.BPAbortWithWrittenError[h, noSym]; ERROR}];    enh ¬ AMLoadstate.MapRealToEnh[WorldVMOps.GetLoadstate[h.world], WorldVMOps.GFshort[h.world, gf]];    IO.EOL[h];    FOR i: CARDINAL IN [0..enh.nEntries) DO      pc ¬ enh.initialPC[i];      cbti ¬ IP.CBti[h, pc, gf];      IF cbti # Symbols.CBTNull AND h.bb[cbti].level # Symbols.lL THEN LOOP;      SELECT bt.ex FROM	entry => pc ¬ pc + 1; -- skip the fsi byte	exit => pc ¬ IP.ExitPC[h, cbti];	ENDCASE => ERROR;      PrintName[h, cbti]; IO.Text[" -- "L, h];      IF set THEN SetOne[h, gf, pc, bt, TRUE ! BPFail => {IO.EOL[h]; CONTINUE}]      ELSE Remove[h, gf, pc ! BPFail => {BPWriteError[h, type]; IO.EOL[h]; CONTINUE}];      ENDLOOP};      PrintName: PROC [h: IT.Handle, cbti: IT.CBTIndex] = {    IF cbti # Symbols.CBTNull THEN IS.HashVal[h, h.bb[cbti].id]};      Convert: PROC [h: IT.Handle, gf, pc: LONG STRING] RETURNS [IT.GFHandle, IT.BytePC] = {    RETURN[LOOPHOLE[IO.StringExpToLDecimal[h, gf]], IO.StringExpToDecimal[h, pc]]};      OctalBreak: PUBLIC PROC [h: IT.Handle, gf, pc: LONG STRING] = {    ogf: IT.GFHandle;    opc: IT.BytePC;    [ogf, opc] ¬ Convert[h: h, gf: gf, pc: pc];    IO.Text[" -- "L, h];    SetOne[h, ogf, opc, [octal,break], FALSE]};      ClearOctal: PUBLIC PROC [h: IT.Handle, gf,pc: LONG STRING] = {    ogf: IT.GFHandle;    opc: IT.BytePC;    [ogf, opc] ¬ Convert[h: h, gf: gf, pc: pc];    Remove[h, ogf, opc]};      ListBreaks: PUBLIC PROC[h: IT.Handle] = {    ListOne: PROC [h: IT.Handle, bb: IT.BBHandle] RETURNS [BOOLEAN] = {List[h, bb]; RETURN[FALSE]};    IO.EOL[h];    [] ¬ EnumerateBBs[h, ListOne]};      ListBreak: PUBLIC PROC [h: IT.Handle, bbNum: LONG STRING] = {   List[h, GetBreak[h, bbNum]]};    List: PUBLIC PROC [h: IT.Handle, b: IT.BBHandle] = {    ENABLE AMUseful.NoModule => CONTINUE;    IF b = NIL THEN RETURN;    IO.Decimal[h, b.num]; IO.Text[" -- "L, h];    IF b.bt.ex = octal THEN {      IO.Text["Octal-break in frame: "L, h]; IS.LongNum[h, b.gf, [pointer[]]];      IO.Text[", byte-pc: "L, h]; IS.Num[h, b.pc, [card[]]]; IO.Line[h, "."L]}    ELSE {      IO.Text[IF b.bt.bt = break THEN "Break"L ELSE "Trace"L, h];      IO.Text[SELECT b.bt.ex FROM entry => " at entry to "L, exit => " at exit from "L, ENDCASE => " in "L, h];      PrintName[h, IP.CBti[h, b.pc, b.gf]];      IP.DisplayInMsg[h, b.gf,NIL]; IO.Char[h, '.];      IF b.condition # NIL THEN { IO.Text["  Condition: "L, h]; IO.Text[b.condition, h] };      IF b.exp # NIL THEN { IO.Text["  Keystrokes: "L, h]; IO.Text[b.exp, h] };      IO.EOL[h];      IF b.bt.ex = in THEN IP.DisplaySource[h, b.gf,b.pc,FALSE	! IP.FileMissing => { IO.Text[name, h]; BPWriteError[h, notFound]};	  SymbolTable.Missing => {BPWriteError[h, noSym]; CONTINUE};	  IQ.InvalidFrame => CONTINUE]}};      BPAbortWithError: PUBLIC PROC [h: IT.Handle, err: CommandList.BPError] = {ERROR BPFail[err]};      base: CommandList.CSRptr = Runtime.GetTableBase[Runtime.GlobalFrame[CommandTab]];  BPWriteError: PUBLIC PROC [h: IT.Handle, err: CommandList.BPError] = {    ss: String.SubStringDescriptor ¬ [      base: @base[base.stringOffset],      offset: base.BPErrorMessages[err].offset,      length: base.BPErrorMessages[err].length];    IO.SubString[h, @ss]};      BPAppendError: PUBLIC PROC [h: IT.Handle, s: LONG STRING, err: CommandList.BPError] = {    ss: String.SubStringDescriptor ¬ [      base: @base[base.stringOffset],      offset: base.BPErrorMessages[err].offset,      length: MIN[s.maxlength, base.BPErrorMessages[err].length]];    String.AppendSubString[s, @ss]};      }.
-- Copyright (C) 1985  by Xerox Corporation. All rights reserved. -- FastBreakImpl.mesa-- Russ Atkinson, February 11, 1985 11:39:31 pm PST-- Litman       11-Apr-85 12:00:27  DIRECTORY  Runtime USING [CallDebugger],  Environment USING [Byte, wordsPerPage, PageFromLongPointer],  FastBreak USING [FastBreakData, FastBreakId, FastBreakProc, BytePC, LocalFrameHandle, GlobalFrameHandle],  SpecialSpace USING [MakeProcedureResident, MakeGlobalFrameResident,    SpecialError],  Frame USING [GetReturnFrame, ReadPC, ReadGlobalLink],   Mopcodes,  PrincOps USING [StateVector, PrefixHandle],  PrincOpsExtras USING [SourceDest],  XferTrap USING [ReadXTS, WriteXTS],  Space USING [ScratchMap, Unmap],  VM USING [MakeResident, MakeSwappable],  WorldVM,  WorldVMOps;FastBreakImpl: MONITOR  IMPORTS Environment, Frame, Runtime, Space, SpecialSpace,     XferTrap, WorldVM, WorldVMOps, VM  EXPORTS FastBreak = {    BytePC: TYPE = FastBreak.BytePC;  LocalFrameHandle: TYPE = FastBreak.LocalFrameHandle;  GlobalFrameHandle: TYPE = FastBreak.GlobalFrameHandle;  FastBreakProc: TYPE = FastBreak.FastBreakProc;  FastBreakData: TYPE = FastBreak.FastBreakData;  FastBreakId: TYPE = FastBreak.FastBreakId;  FastBreakEntryPtr: TYPE = LONG POINTER TO FastBreakEntry;  FastBreakEntry: TYPE = RECORD [    count: INTEGER ¬ 0,    next: FastBreakEntryPtr ¬ NIL,    gf: GlobalFrameHandle ¬ NIL,    pc: BytePC ¬ [0],    inst: Environment.Byte ¬ 0,    data: LONG POINTER ¬ NIL,    proc: FastBreakProc ¬ NIL];  fastBreakPages: CARDINAL = 2;  maxFastBreaks: CARDINAL =    (fastBreakPages * Environment.wordsPerPage) / SIZE[FastBreakEntry];  FastBreakArrayPtr: TYPE = LONG POINTER TO FastBreakArray;  FastBreakArray: TYPE = ARRAY [0..maxFastBreaks) OF FastBreakEntry;  arrayPtr: FastBreakArrayPtr ¬ NIL;  space: LONG POINTER ¬ NIL;  -- valid iff arrayPtr # NIL  oldBreakTrap: PROC ¬ NIL;  fastBreaksLeft: NAT ¬ maxFastBreaks;  inUseChain: FastBreakEntryPtr ¬ NIL;  freeChain: FastBreakEntryPtr ¬ NIL;  firstTime: BOOL ¬ TRUE;  SpecifyDefaultBreakHandler: PUBLIC PROC [old: PROC] = {    «SpecifyDefaultBreakHandler[old] specifies the old breakpoint handler     to be used when a non-fast break is encountered.  It should be called      before FastBreakHandler is installed.»    oldBreakTrap ¬ old; };  FastBreakHandler: PUBLIC PROC = {    «Executed by (non-worry) BRK instruction.  Examines our wonder little     resident data structure to determine whether or not to take a FAST break.      If not, then we pass control to the old break handler (whatever it is).      There can be races between this procedure and the setting/cearing     procedures, but it is not easy to remove these races due to atomicity    considerations.»    state: RECORD[padding: LONG CARDINAL, sv: dst PrincOps.StateVector];    fp: LocalFrameHandle;    state.sv ¬ STATE;    BEGIN    sourceDest: PrincOpsExtras.SourceDest;    fp ¬ Frame.GetReturnFrame[];    IF inUseChain # NIL THEN {      pc: BytePC ¬ Frame.ReadPC[fp];      gf: GlobalFrameHandle ¬ Frame.ReadGlobalLink[fp];      ep: FastBreakEntryPtr ¬ inUseChain;      inst: Environment.Byte ¬ Mopcodes.zBRK;      useOld: BOOL ¬ FALSE;      WHILE ep # NIL DO        entry: FastBreakEntry ¬ ep^;  -- copy in one burst to reduce races	IF entry.gf = gf AND entry.pc = pc THEN {          inst ¬ entry.inst;          ep.count ¬ entry.count + 1;          IF entry.proc # NIL THEN  -- call the user's routine            IF entry.proc[entry.data, fp, @state.sv] THEN useOld ¬ TRUE };        ep ¬ entry.next;        ENDLOOP;      IF inst # Mopcodes.zBRK THEN {        «We have handled a fast break.  Now we must clean up our act to allow	 continuation.  Notice that we do not allow upper-level breakpoints 	 AND fast breaks, although we allow multiple fast breaks.»        IF XferTrap.ReadXTS[] = on THEN XferTrap.WriteXTS[skip1];        IF useOld THEN {          «We have handled a fast break, but we have been requested to make 	  this into a pseudo-break event.  The easiest way is just to call 	  the debugger.»          Runtime.CallDebugger["FastBreak proc requested a break."] };        state.sv.instbyte ¬ inst;	STATE ¬ state.sv;	RETURN }};    «At this point we have NOT handled a fast break, so we have to go to the     old break handler in the hopes that it knows what to do.»    IF XferTrap.ReadXTS[] = on THEN XferTrap.WriteXTS[skip1];    sourceDest.source ¬ [frame[fp]];    sourceDest.dest ¬ LOOPHOLE[oldBreakTrap];    STATE ¬ state.sv;    RETURN WITH sourceDest;    END };  FastBreaksLeft: PUBLIC PROC RETURNS [NAT] = {    «FastBreaksLeft[] returns the number of fast break slots remaining in     the table.»    RETURN[fastBreaksLeft]; };  SetFastBreak: PUBLIC ENTRY PROC [    gf: GlobalFrameHandle, pc: BytePC,    proc: FastBreakProc ¬ NIL, data: FastBreakData ¬ NIL]    RETURNS [id: FastBreakId, alreadySet: BOOLEAN ¬ FALSE] = {    «SetFastBreak[gf, pc, proc, data] adds a fast break at the specified     location.  The pointer returned is used to distinguish which break to      clear when clearing the break.  If NIL is returned, then the breakpoint      could not be set (due to the table being full).»    ENABLE UNWIND => NULL;    ep: FastBreakEntryPtr ¬ freeChain;    inst: Environment.Byte ¬ Mopcodes.zBRK;    needToSet: BOOL ¬ TRUE;    IF arrayPtr = NIL THEN {      -- Make a new array, and make sure that it is resident.      fb: FastBreakEntryPtr;      IF firstTime THEN {        «this is the latest time that we can make ourselves resident 	and still be safe about it»        SpecialSpace.MakeGlobalFrameResident[FastBreakImpl !	  SpecialSpace.SpecialError => IF error = alreadyResident THEN CONTINUE];        SpecialSpace.MakeProcedureResident[LOOPHOLE[SetFastBreak] !	  SpecialSpace.SpecialError => IF error = alreadyResident THEN CONTINUE];        SpecialSpace.MakeProcedureResident[LOOPHOLE[ClearFastBreak] !	  SpecialSpace.SpecialError => IF error = alreadyResident THEN CONTINUE];        SpecialSpace.MakeProcedureResident[LOOPHOLE[ClearAllFastBreaks] !	  SpecialSpace.SpecialError => IF error = alreadyResident THEN CONTINUE];        SpecialSpace.MakeProcedureResident[LOOPHOLE[ClearInternal] !	  SpecialSpace.SpecialError => IF error = alreadyResident THEN CONTINUE];        SpecialSpace.MakeProcedureResident[LOOPHOLE[CountBreaksAtLocation] !	  SpecialSpace.SpecialError => IF error = alreadyResident THEN CONTINUE];        firstTime ¬ FALSE;	};      space ¬ Space.ScratchMap[fastBreakPages];      VM.MakeResident[        [Environment.PageFromLongPointer[space], fastBreakPages], wait];      arrayPtr ¬ space;      fastBreaksLeft ¬ maxFastBreaks;      arrayPtr^ ¬ ALL[FastBreakEntry[]];      ep ¬ freeChain ¬ fb ¬ @arrayPtr[0];      FOR i: CARDINAL IN [0..maxFastBreaks - 1) DO        next: FastBreakEntryPtr ¬ fb + SIZE[FastBreakEntry];        fb.next ¬ next;        fb ¬ next;        ENDLOOP;      };    «    inst ¬ DebugOps.ReadCodeByte[gf, pc];    IF inst = Mopcodes.zBRK THEN {      -- There is already a breakpoint here.      FOR eep: FastBreakEntryPtr ¬ inUseChain, eep.next WHILE eep # NIL DO        IF eep.gf = gf AND eep.pc = pc THEN RETURN[LOOPHOLE[eep], TRUE];        ENDLOOP;      RETURN[NIL, TRUE];      };    »    IF ep = NIL THEN RETURN[NIL, FALSE];    id ¬ @ep.count;    -- Remove the entry from the free chain    freeChain ¬ ep.next;    -- Fill in the entry    ep^ ¬ [      count: 0, next: inUseChain, gf: gf, pc: pc, inst: inst,      data: data, proc: proc];    -- Put the entry on the inUseChain    inUseChain ¬ ep;    ep.inst ¬ SetBreak[gf, pc];    };  ClearFastBreak: PUBLIC ENTRY PROC [    id: FastBreakId, proc: FastBreakProc ¬ NIL,    data: FastBreakData ¬ NIL] RETURNS [found: BOOL ¬ FALSE] = {    «ClearFastBreak[id, proc, data] clears the specified fast break, provided     that the parameters agree with an active fast break.  TRUE is returned iff     such a break was found.»    ENABLE UNWIND => NULL;    ep: FastBreakEntryPtr ¬ inUseChain;    lag: FastBreakEntryPtr ¬ NIL;    WHILE ep # NIL DO      IF LOOPHOLE[id, FastBreakEntryPtr] = ep AND ep.proc = proc        AND ep.data = data THEN {        ClearInternal[ep, lag]; RETURN[TRUE]; };      lag ¬ ep;      ep ¬ ep.next;      ENDLOOP;    };  ClearAllFastBreaks: PUBLIC ENTRY PROC [    releaseResources: BOOL ¬ TRUE] RETURNS [cleared: NAT ¬ 0] = {    «ClearAllFastBreaks[] clears all fast breaks.  It also releases system    resources used by fast breaks if releaseResources = TRUE.  It returns the    number of fast breaks removed.»    ENABLE UNWIND => NULL;    WHILE inUseChain # NIL DO      -- Clear out one break      ClearInternal[inUseChain]; cleared ¬ cleared + 1; ENDLOOP;    IF releaseResources AND arrayPtr # NIL THEN {      arrayPtr ¬ NIL;      VM.MakeSwappable[        [Environment.PageFromLongPointer[space], fastBreakPages]];      space ¬ Space.Unmap[space];      fastBreaksLeft ¬ maxFastBreaks;      };    };  ClearInternal: INTERNAL PROC [    ep: FastBreakEntryPtr, lag: FastBreakEntryPtr ¬ NIL] = {    SELECT CountBreaksAtLocation[ep.gf, ep.pc] FROM      0 => RETURN;      1 => {        -- Time to restore the old instruction        ClearBreak[ep.gf, ep.pc, ep.inst];        };      ENDCASE;    -- Now, remove the entry from the inUseChain    IF lag = NIL THEN inUseChain ¬ ep.next ELSE lag.next ¬ ep.next;    -- Put the block back on the free chain    ep.next ¬ freeChain;    freeChain ¬ ep;    fastBreaksLeft ¬ fastBreaksLeft + 1;    };  CountBreaksAtLocation: INTERNAL PROC [    gf: GlobalFrameHandle, pc: BytePC]    RETURNS [count: CARDINAL ¬ 0] = {    ep: FastBreakEntryPtr ¬ inUseChain;    WHILE ep # NIL DO      IF ep.gf = gf AND ep.pc = pc THEN count ¬ count + 1;      ep ¬ ep.next;      ENDLOOP;    };      SetBreak: PROC[gf: GlobalFrameHandle, pc: BytePC]     RETURNS[byte: Environment.Byte] = {    local: WorldVM.World = WorldVM.LocalWorld[];    cb: PrincOps.PrefixHandle = WorldVMOps.CodebaseFromGf[local, WorldVMOps.GFlong[local, gf]];    byte ¬ WorldVMOps.SetBreak[local, cb, pc] };      ClearBreak: PROC[gf: GlobalFrameHandle, pc: BytePC,     inst: Environment.Byte] = {    local: WorldVM.World = WorldVM.LocalWorld[];    cb: PrincOps.PrefixHandle = WorldVMOps.CodebaseFromGf[local, WorldVMOps.GFlong[local, gf]];    WorldVMOps.ClearBreak[local, cb, pc, inst] };  }.
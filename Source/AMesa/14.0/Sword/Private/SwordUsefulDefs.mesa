-- Copyright (C) 1986  by Xerox Corporation. All rights reserved. -- SwordUsefulDefs.mesaDIRECTORY  Environment USING [bitsPerWord],  EventTypes USING [firstDebugEvent],  IT USING [Fob],  Window USING [Handle],  Supervisor USING [Event],  WorldVMOps USING [GetType, LongGlobalFrameHandle, ShortAddress, Address],   WorldVM USING [World];  SwordUsefulDefs: DEFINITIONS IMPORTS WorldVMOps = {    World: TYPE = WorldVM.World;    SetDefaultWorld: PROC[world: World];  GetDefaultWorld: PROC RETURNS[world: World] = INLINE {    IF (WorldVMOps.GetType[world ¬ IF defaultWorld # NIL THEN defaultWorld ELSE localWorld] = none) THEN ERROR NoSession };    defaultWorld: PRIVATE READONLY World;  localWorld: PRIVATE READONLY World;    setDUD: Supervisor.Event = [EventTypes.firstDebugEvent+10]; -- used with Event.spare2  InterpreterAvailable: PROC[world: World];      GFHandle: TYPE = WorldVMOps.LongGlobalFrameHandle;  ClientSource: TYPE = WorldVMOps.ShortAddress;  LongClientSource: TYPE = WorldVMOps.Address;  ClientDest: TYPE = WorldVMOps.ShortAddress;  LongClientDest: TYPE = WorldVMOps.Address;  LocalSource: TYPE = LONG POINTER;  LocalDest: TYPE = LONG POINTER;    -- READing and WRITEing  LongREAD: PROC [loc: LongClientSource, world: World] RETURNS [val: UNSPECIFIED];  LongWRITE: PROC [loc: LongClientDest, val: UNSPECIFIED, world: World];  LongCopyREAD: PROC [from: LongClientSource, nwords: CARDINAL, to: LocalDest, world: World];  LongCopyWRITE: PROC [from: LocalSource, nwords: CARDINAL, to: LongClientDest, world: World];    ShortREAD: PROC [loc: ClientSource, world: World] RETURNS [val: UNSPECIFIED] = INLINE {    RETURN[LongREAD[Lengthen[loc, world], world]]};  ShortWRITE: PROC [loc: ClientDest, val: UNSPECIFIED, world: World] = INLINE {    LongWRITE[Lengthen[loc, world], val, world]};  ShortCopyREAD: PROC [from: ClientSource, nwords: CARDINAL, to: LocalDest, world: World] = INLINE {    LongCopyREAD[Lengthen[from, world], nwords, to, world]};  ShortCopyWRITE: PROC [from: LocalSource, nwords: CARDINAL, to: ClientDest, world: World] = INLINE {    LongCopyWRITE[from, nwords, Lengthen[to, world], world]};      Lengthen: PROC [address: ClientSource, world: World] RETURNS [LongClientDest];  -- Global frames  FrameDesc: TYPE = LONG DESCRIPTOR FOR READONLY ARRAY OF GFHandle;  ConfigForFrame: PROC [gf: GFHandle, config: LONG STRING, world: World];  Enumerate: PROC [proc: PROC [GFHandle] RETURNS [BOOLEAN], world: World] RETURNS [gf: GFHandle];  Name: PROC [name: LONG STRING, gf: GFHandle, world: World];  Frame: PROC [name: LONG STRING, world: World] RETURNS [GFHandle];  Started: PROC [gf: GFHandle, world: World] RETURNS [BOOLEAN];  Valid: PROC [gf: GFHandle, world: World] RETURNS [BOOLEAN];  Copied: PROC [gf: GFHandle, world: World] RETURNS [BOOLEAN];  Original: PROC [new: GFHandle, world: World] RETURNS [old: GFHandle];    -- Client variables  Handle: TYPE = LONG POINTER TO Object;  Object: TYPE = IT.Fob;  Bits: TYPE = [0..Environment.bitsPerWord);  GetAddress: PROC [Handle] RETURNS [base: LONG POINTER, offset: Bits, there: BOOLEAN];  GetSize: PROC [Handle] RETURNS [words: CARDINAL, bits: Bits];  ReadValue: PROC [Handle];	-- noop if previously read  -- Printers  Printer: TYPE = PROC[Handle] RETURNS[BOOLEAN]; -- returns TRUE if printed   AddPrinter: PROC [type: LONG STRING, proc: Printer, world: World];  RemovePrinter: PROC [type: LONG STRING, proc: Printer, world: World];  -- Interpreter  Interpreter: PROC [exp: LONG STRING, results: PROC [Handle], world: World];   StringExpToNum: PROC [exp: LONG STRING, radix: CARDINAL, world: World] RETURNS [UNSPECIFIED];  StringExpToLNum: PROC [exp: LONG STRING, radix: CARDINAL, world: World] RETURNS [LONG UNSPECIFIED];  StringExpToOctal: PROC [exp: LONG STRING, world: World] RETURNS [CARDINAL];  StringExpToLOctal: PROC [exp: LONG STRING, world: World] RETURNS [LONG CARDINAL];  StringExpToDecimal: PROC [exp: LONG STRING, world: World] RETURNS [INTEGER];  StringExpToLDecimal: PROC [exp: LONG STRING, world: World] RETURNS [LONG INTEGER];    -- Windows  window: READONLY Window.Handle;  fileSW: READONLY Window.Handle;  Text: PROCEDURE [s: LONG STRING, clientData: LONG POINTER ¬ NIL, world: World];     -- Signals  NoSession: ERROR;  MultipleFrames: VAR SIGNAL [list: FrameDesc];  InvalidAddress: VAR ERROR [address: LONG POINTER];  InvalidFrame: VAR ERROR [f: LONG POINTER];  InvalidNumber: VAR ERROR [p: LONG POINTER];  NotFound: VAR ERROR [s: LONG STRING];  WriteProtected: VAR ERROR [address: LONG POINTER];  UserAborted: VAR SIGNAL;    }.
-- File: ITDebugger.mesa - last edit:-- Litman              14-Apr-87 14:29:51-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.DIRECTORY  AMEvents USING [HandleLocalEvents],  AMModel USING [ChildProc, Context, ContextChildren, IsNullContext, MostRecentNamedContext, RootContext],  Ascii USING [NUL, SP],  Format USING [NumberFormat],  FormSW USING [AllocateItemDescriptor, BooleanItem, ClientItemsProcType, CommandItem, Enumerated, EnumeratedItem, FilterProcType, ItemHandle, line0, line1, line2, line3, line4, line5, LineHeight, nextPlace, NumberItem, Options, ProcType, StringEditProc, StringItem],  Heap USING [systemZone],  HeraldWindow USING [AppendBrokenMessage, AppendMessage],  IL USING [],  IM USING [strings],  Inline USING [DBITSHIFT, HighHalf, LowHalf],  ID,  IO USING [Char, EOL, FreeNode, IntString, InvalidNumber, Line, Node, options, OutNumber, StringExpToDecimal, StringExpToLDecimal, Text, UserAbort, zone],  IQ USING [],  IS USING [Confirm, LongNum, ShowTypeWithProc, WriteError],  IT USING [CommandProc, Handle, Options, ZeroProc],  ITExtras USING [OptionsSpare],  RuntimeError USING [ClearFilter, RegisterFilter, TooManyFilters],  Selection USING [Convert],  String USING [AppendCharAndGrow, Empty, ExpandString, FreeString, MakeString],  Token USING [FreeTokenString, GetCharProcType, Handle, Item, Object],  Tool USING [Create, Destroy, MakeFormSW, MakeSWsProc],  Watch USING [],  Window USING [Box, GetBox, Handle, Object],  WindowFont,  WorldVM USING [LocalWorld, World],  WorldVMOps USING [GFshort, Long, Read, SpecialWrite, Write, WriteProtected];ITDebugger: PROGRAM  IMPORTS AMEvents, AMModel, FormSW, Heap, HeraldWindow, IM, Inline, IO, IS, RuntimeError, Selection, String, Token, Tool, Window, WindowFont, WorldVM, WorldVMOps  EXPORTS ID, IL, IO, IQ, Watch = {    -- Temporary use only.  optionsSW: Window.Handle ¬ NIL;  thisForm: LONG POINTER TO IT.Options ¬ NIL;  Abort: PUBLIC SIGNAL = CODE;  CommandNotAllowed: PUBLIC SIGNAL = CODE;  Proceed: PUBLIC SIGNAL = CODE;  Quit: PUBLIC SIGNAL = CODE;  Kill: PUBLIC SIGNAL = CODE;  ShowType: PUBLIC PROCEDURE [h: IT.Handle, showBits: BOOLEAN] = {    s: LONG STRING ¬ Selection.Convert[string];    Cleanup: PROC = {String.FreeString[Heap.systemZone, s]};    IF s = NIL THEN RETURN;    IS.ShowTypeWithProc[s, showBits, IO.Text, h ! UNWIND => Cleanup[]];    Cleanup[]};    ShowRep: PUBLIC IT.CommandProc = {    s: LONG STRING ¬ Selection.Convert[string];    Cleanup: PROC = {String.FreeString[Heap.systemZone, s]};    IF s = NIL THEN RETURN;    String.AppendCharAndGrow[@s, '?, Heap.systemZone];    IO.IntString[h, s ! UNWIND => Cleanup[]];    Cleanup[]};      ParamIndex: TYPE = {    cRadix, cSigned, iRadix, iSigned, apply, pRadix, lpRadix, abort, relRadix,     unspec, elements, chars, filter,    fault, uncaught, break, calldebug, processes, configs, autoOpen};    CreateOptions: PUBLIC PROC[h: IT.Handle] = {    box: Window.Box = Window.GetBox[h.tool];    IF optionsSW = NIL     THEN optionsSW ¬ Tool.Create[      name: "Sword Options"L, makeSWsProc: OptionSW, initialState: active,      initialBox:         [[box.place.x+14, box.place.y+50],         [492, 7*FormSW.LineHeight[]]]]    ELSE IO.Line[h, "Options window already exists."L]};      OptionSW: Tool.MakeSWsProc = {    thisForm ¬ IO.Node[NIL, SIZE[IT.Options]];    thisForm­ ¬ IO.options;    [] ¬ Tool.MakeFormSW[window: window, formProc: MakeOptions, zone: IO.zone]};  DoOptions: FormSW.ProcType = {    SELECT index FROM      ParamIndex.abort.ORD => NULL;      ParamIndex.apply.ORD => {        IO.options ¬ thisForm­;	AMEvents.HandleLocalEvents[	  signals: thisForm.uncaught.b, 	  breaks: thisForm.break.b,	  faults: thisForm.fault.b, 	  calldebug: thisForm.calldebug.b];	Filter[IM.strings[filter]]};      ENDCASE => ERROR;    IO.FreeNode[NIL, thisForm];    Tool.Destroy[optionsSW];    optionsSW ¬ NIL };      Filter: PUBLIC «ID» PROC[filter: LONG STRING] = {    i: CARDINAL ¬ 0;    tokenObject: Token.Object ¬ [getChar: getChar];    getChar: Token.GetCharProcType = {      c ¬ IF i >= filter.length THEN Ascii.NUL ELSE filter[i]; i ¬ i+1 };    world: WorldVM.World = WorldVM.LocalWorld[];    rootContext: AMModel.Context = AMModel.RootContext[world];    context: AMModel.Context;    moduleOrConfig: LONG STRING;    RuntimeError.ClearFilter[];    IF String.Empty[filter] THEN RETURN;    DO       ENABLE RuntimeError.TooManyFilters => {        HeraldWindow.AppendMessage[msg: " Too many filters!!"L, clearOld: FALSE];        [] ¬ Token.FreeTokenString[moduleOrConfig]; EXIT };      Add: AMModel.ChildProc = {	WITH c SELECT FROM	  world => NULL;	  model => [] ¬ AMModel.ContextChildren[c, Add];	  prog => RuntimeError.RegisterFilter[LOOPHOLE[WorldVMOps.GFshort[world, gf]]];	  ENDCASE;	RETURN[FALSE]};      IF (moduleOrConfig ¬ Token.Item[@tokenObject]) = NIL THEN EXIT;      context ¬ AMModel.MostRecentNamedContext[moduleOrConfig, rootContext];      IF AMModel.IsNullContext[context] THEN {        HeraldWindow.AppendBrokenMessage[moduleOrConfig, " not found!"L] }      ELSE [] ¬ Add[context];      [] ¬ Token.FreeTokenString[moduleOrConfig];      ENDLOOP };          StringFilterProc: FormSW.FilterProcType = {    IF string # NIL THEN {      im: LONG STRING = IM.strings[filter];      IF im = NIL       THEN IM.strings[filter] ¬ String.MakeString[IO.zone, string.length+20]      ELSE {	IF (im.length + string.length) > im.maxlength	THEN String.ExpandString[@IM.strings[filter], string.length+20, IO.zone]};      FormSW.StringEditProc[sw, item, insert, string]}};      charWidth: CARDINAL = WindowFont.CharWidth['0];  CharPos: PROC[char: CARDINAL] RETURNS [x: INTEGER] = INLINE {    x ¬ charWidth * char};    MakeOptions: FormSW.ClientItemsProcType = {    ParamArray: TYPE = ARRAY ParamIndex OF FormSW.ItemHandle;    itemHandle: LONG POINTER TO ParamArray;    nItems: CARDINAL = ParamIndex.LAST.ORD + 1;    octal: FormSW.Enumerated = ["octal"L, 8];    decimal: FormSW.Enumerated = ["decimal"L, 10];    hex: FormSW.Enumerated = ["hex"L, 16];    odh: ARRAY [0..3) OF FormSW.Enumerated ¬ [octal, decimal, hex];    items ¬ FormSW.AllocateItemDescriptor[nItems: nItems, z: IO.zone];     itemHandle ¬ LOOPHOLE[BASE[items]];    itemHandle­ ¬ [      cRadix: FormSW.EnumeratedItem[        tag: "CARDINAL"L, place: [CharPos[1], FormSW.line0], feedback: all, 	choices: DESCRIPTOR[odh],	value: @thisForm.cardRadix,	z: IO.zone],      cSigned: FormSW.BooleanItem[        tag: "signed"L, place: [CharPos[33], FormSW.line0], 	switch: @thisForm.cardSigned,	z: IO.zone],      iRadix: FormSW.EnumeratedItem[        tag: "INTEGER"L, place: [CharPos[42], FormSW.line0], feedback: all, 	choices: DESCRIPTOR[odh],	value: @thisForm.intRadix,	z: IO.zone],      iSigned: FormSW.BooleanItem[        tag: "signed"L, place: [CharPos[73], FormSW.line0], 	switch: @thisForm.intSigned,	z: IO.zone],      apply: FormSW.CommandItem[tag: "Apply"L, place: [CharPos[1], FormSW.line1],         proc: DoOptions,	z: IO.zone],      pRadix: FormSW.EnumeratedItem[        tag: "POINTER"L, place: [CharPos[9], FormSW.line1], feedback: all, 	choices: DESCRIPTOR[odh],	value: @thisForm.pRadix,	z: IO.zone],      lpRadix: FormSW.EnumeratedItem[        tag: "PROCESS"L, place: [CharPos[42], FormSW.line1], feedback: all, 	choices: DESCRIPTOR[odh], value: @thisForm.lpRadix,	z: IO.zone],      abort: FormSW.CommandItem[tag: "Abort"L, place: [CharPos[1], FormSW.line2],         proc: DoOptions,	z: IO.zone],      relRadix: FormSW.EnumeratedItem[        tag: "RELATIVE"L, place: [CharPos[9], FormSW.line2], feedback: all, 	choices: DESCRIPTOR[odh],	value: @thisForm.relRadix,	z: IO.zone],      unspec: FormSW.EnumeratedItem[        tag: "UNSPECIFIED"L, place: [CharPos[42], FormSW.line2], feedback: all, 	choices: DESCRIPTOR[odh],	value: @thisForm.default,	z: IO.zone],      elements: FormSW.NumberItem[        tag: "Array elements "L, place: [CharPos[1], FormSW.line3], signed: FALSE,        notNegative: TRUE,	value: @thisForm.elementCnt,	z: IO.zone],      chars: FormSW.NumberItem[        tag: "String length "L, place: [CharPos[42], FormSW.line3], signed: FALSE,        notNegative: TRUE,	value: @thisForm.charCnt,	z: IO.zone],      filter: FormSW.StringItem[tag: "filter"L, inHeap: FALSE,         filterProc: StringFilterProc,        place: [CharPos[1], FormSW.line4], string: @IM.strings[filter],        z: IO.zone],      fault: FormSW.BooleanItem[readOnly: FALSE,        tag: "fault"L, place: [CharPos[1], FormSW.line5], 	switch: @thisForm.fault.b,	z: IO.zone],      uncaught: FormSW.BooleanItem[readOnly: FALSE,        tag: "uncaught"L, place: FormSW.nextPlace, 	switch: @thisForm.uncaught.b,	z: IO.zone],      break: FormSW.BooleanItem[readOnly: FALSE,        tag: "break"L, place: FormSW.nextPlace, 	switch: @thisForm.break.b,	z: IO.zone],      calldebug: FormSW.BooleanItem[readOnly: FALSE,        tag: "calldebug"L, place: FormSW.nextPlace, 	switch: @thisForm.calldebug.b,	z: IO.zone],      processes: FormSW.BooleanItem[readOnly: FALSE,        tag: "processes"L, place: FormSW.nextPlace, 	switch: @thisForm.processes.b,	z: IO.zone],      configs: FormSW.BooleanItem[readOnly: FALSE,        tag: "configs"L, place: FormSW.nextPlace, 	switch: @thisForm.configs.b,	z: IO.zone],      autoOpen: FormSW.BooleanItem[readOnly: FALSE,        tag: "autoOpen"L, place: FormSW.nextPlace, 	switch: @LOOPHOLE[thisForm.spare, ITExtras.OptionsSpare].autoOpen.b,	z: IO.zone]];      RETURN[items: items, freeDesc: TRUE]};        AsciiRead, AsciiDisplay: PUBLIC PROC [h: IT.Handle, start, chars: LONG STRING] = {    AsciiDump[h,start,chars]};      BytePointer: TYPE = MACHINE DEPENDENT RECORD [    p(0:0..31): SELECT OVERLAID * FROM      byte => [        fill2(0:0..14): [0..77777B],        whichByte(0:15..15): [0..1],        tag(1:0..0): [0..1],        fill1(1:1..15): [0..77777B]],      pointer => [pointer(0:0..31): LONG POINTER],      ENDCASE];  AsciiDump: PROCEDURE [h: IT.Handle, start, chars: LONG STRING] = {    ENABLE IO.InvalidNumber => CONTINUE;    i: CARDINAL;    s: PACKED ARRAY [0..1] OF CHARACTER;    p: POINTER = @s;    lp: LONG POINTER ¬ GetLP[h, start];    bp: BytePointer ¬ LOOPHOLE[lp];    cnt: CARDINAL ¬ IO.StringExpToDecimal[h, chars];    IF bp.tag = 1 THEN {      bp.tag ¬ 0;      i ¬ bp.whichByte;      cnt ¬ cnt + bp.whichByte;      lp ¬ Inline.DBITSHIFT[bp.pointer, -1];      p­ ¬ WorldVMOps.Read[h.world, lp] }    ELSE i ¬ 0;    IO.EOL[h];    DO      IF i MOD 2 = 0 THEN p­ ¬ WorldVMOps.Read[h.world, lp+i/2];      IO.Char[h, s[i MOD 2]];      IF IO.UserAbort[h] THEN {IS.WriteError[h, aborted]; EXIT};      IF (i ¬ i + 1) >= cnt THEN EXIT;      ENDLOOP};  GetLP: PUBLIC PROC [h: IT.Handle, s: LONG STRING] RETURNS [LONG POINTER] = {    lp: LONG POINTER ¬ LOOPHOLE[IO.StringExpToLDecimal[h, s]];    lengthen: BOOLEAN = s[0] # '0 AND Inline.HighHalf[lp] = 0;    IF lengthen THEN lp ¬ WorldVMOps.Long[h.world, Inline.LowHalf[lp]];    RETURN[lp]};      OctalRead: PUBLIC PROC [h: IT.Handle, start, cnt: LONG STRING] = {    lp: LONG POINTER ¬ GetLP[h, start];    num: CARDINAL ¬ IO.StringExpToDecimal[h, cnt];    DoRead[h, lp, num]};  DoRead: PUBLIC PROC [h: IT.Handle, start: LONG POINTER, cnt: CARDINAL] = {    i: INTEGER ¬ -1;    radix: CARDINAL = IO.options.cardRadix;    format: Format.NumberFormat = [radix, FALSE, TRUE, 7];    trailer: CHARACTER =       SELECT radix FROM 8 => 'B, 16 => 'H, ENDCASE => Ascii.SP;    FOR j: LONG CARDINAL IN [LOOPHOLE[start]..LOOPHOLE[start+cnt]) DO      IF IO.UserAbort[h] THEN {IS.WriteError[h, aborted]; EXIT};      IF (i ¬ i+1) MOD 8 = 0 THEN {	IO.EOL[h];	IS.LongNum[h, j, [card[]]];	IO.Char[h, '/]};      IO.OutNumber[h, WorldVMOps.Read[h.world, j], format];      IO.Char[h, trailer];      ENDLOOP };  OctalWrite: PUBLIC PROC [h: IT.Handle, loc, val: LONG STRING] = {    lp: LONG POINTER ¬ GetLP[h, loc];    v: UNSPECIFIED ¬ IO.StringExpToDecimal[h, val];    WorldVMOps.Write[h.world, lp, v       ! WorldVMOps.WriteProtected => {          SpecialWrite: IT.ZeroProc = { WorldVMOps.SpecialWrite[h.world, lp, v] };	  IO.Text[" Write Protected! "L , h];	  IS.Confirm[h, null, SpecialWrite]}]};    }.
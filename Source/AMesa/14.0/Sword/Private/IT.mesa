-- File: IT.mesa - last edit:-- Litman              27-Apr-87 16:48:54-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.DIRECTORY  Ascii USING [NUL],  BcdDefs USING [CTIndex, CTNull],  CommandList USING [Command],  CPSwapDefs USING [SwapData, OperandDesc],  Environment USING [bitsPerWord, wordsPerPage],  Format USING [NumberFormat],  ITDIParseTable USING [ActionEntry, EndMarker, HashIndex, InitialState, NTState, State, TSymbol],  Stream USING [Handle],  String USING [SubStringDescriptor],  Symbols USING [ArraySEIndex, Base, BTIndex, BTNull, CBTIndex, CBTNull, ContextLevel, CSEIndex, CSENull, CTXIndex, CTXNull, HTIndex, HTNull, HTRecord, IncludedCTXIndex, IncludedCTXNull, ISEIndex, ISENull, Limit, MDIndex, MDNull, RecordSEIndex, RefSEIndex, SEIndex, SENull, SERecord],  SymbolTable USING [Handle],  TextSource USING [Handle, nullPosition, Position],  Tree USING [Link, NodeName],  TTY USING [Handle, nullHandle],  Window USING [Box, Handle, nullBox, Object],  WorldVMOps USING [BYTE, BytePC, ControlLink, LongGlobalFrameHandle, LongLocalFrameHandle, NullProcess, PrefixHandle, Process, SignalDesc, World];IT: DEFINITIONS = {  Handle: TYPE = LONG POINTER TO Object;  Object: TYPE = MONITORED RECORD[    next: Handle ¬ NIL,    logname: LONG STRING ¬ NIL,     world: WorldVMOps.World ¬ NIL,     session: LONG INTEGER ¬ LAST[LONG INTEGER], -- AMEvents session    sym: SymbolTable.Handle ¬ NIL,     seb, tb, bb, mdb, ctxb, ltb: Symbols.Base ¬ NIL, -- for interpreter     ht: LONG DESCRIPTOR FOR ARRAY Symbols.HTIndex OF Symbols.HTRecord ¬ DESCRIPTOR[NIL, 0],     ssb: LONG STRING ¬ NIL,    printers: PrintHandle ¬ NIL,    tool: Window.Handle ¬ NIL,     formSW: Window.Handle ¬ NIL,    fileSW: Window.Handle ¬ NIL, -- TTY subwindow.    stream: Stream.Handle ¬ NIL, -- Stream to tty subwindow.    tty: TTY.Handle ¬ TTY.nullHandle,        flows, configs: WordBoolean ¬ [f1[FALSE]],    flowSW, configSW: Window.Handle ¬ NIL,    flowZoom, configZoom: TextSource.Handle ¬ NIL,    flowInit, configInit: InitZoom ¬ [FALSE, TextSource.nullPosition],        go: GoFormItems ¬ ClearEnumerated,    client: ClientFormItems ¬ local,    read: ReadFormItems ¬ ClearEnumerated,    write: WriteFormItems ¬ ClearEnumerated,    attach: AttachFormItems ¬ ClearEnumerated,    break: BreakFormItems ¬ ClearEnumerated,    watch: WatchFormItems ¬ off,         level: CARDINAL ¬ 0, -- Interpreter nesting level.        -- Caches    frameCache: FrameCache ¬ NIL,    pcCache: PcCache ¬ NIL,    headPcItem, freePcItem: PcItem ¬ PcItemNull,    psbCache: PsbCache ¬ NIL,        -- breaks    worryBreaks: BOOLEAN ¬ FALSE,    operand: OpHandle ¬ NIL, -- For constructing conditional break.    bbh: BBHandle ¬ NIL, -- Current Pilot break block if this is a break.    numberOfBreaks: CARDINAL ¬ 0,        -- interface    lastLineEnd: LONG CARDINAL ¬ 0,    prefix: Prefix ¬ top,    parse, prevParse, prevPrevParse: ParseProc ¬ NIL,     prompt, prevPrompt, prevPrevPrompt: PromptProc ¬ NIL,    term: TermProc ¬ NIL,    newLine: BOOLEAN ¬ TRUE, -- output    cr: BOOLEAN ¬ FALSE, -- input    firstChar: BOOLEAN ¬ TRUE,     currentId: StringId ¬ NULL,    com2: CommandRec ¬ NULL,    s1: LONG STRING ¬ NIL,    call0: ZeroProc ¬ NIL,    call1: OneProc ¬ NIL,    call2: TwoProc ¬ NIL,        -- ESV    swapData: CPSwapDefs.SwapData ¬ NULL,        -- context     lContext: LFHandle ¬ NILLF,    gContext: GFHandle ¬ NILGF,    pContext: Process ¬ NullProcess,    iContext: InterpretContext ¬ [global[NILGF]],    lastPSB, headPSB, currentPSB, qHead: Process ¬ NullProcess,        -- Interpreter stuff    search, debugging: BOOLEAN ¬ FALSE,    target: Symbols.CSEIndex ¬ Symbols.CSENull,    cti: BcdDefs.CTIndex ¬ BcdDefs.CTNull,    config: CARDINAL ¬ LAST[CARDINAL], --LoadStateFormat.Index    fobs: FobTable ¬ NIL,    trees: TreeList ¬ NIL,    proc: FooProc ¬ NIL,    fooStack: LONG POINTER TO Stack ¬ NIL,    longs: ARRAY [0..3) OF LongRec ¬ ALL[[Symbols.CSENull, Symbols.CSENull]],    nullProc, nullError, nullSig: Symbols.CSEIndex ¬ Symbols.CSENull,        -- Display Stack or Display Process mode    stackOptions: StackOptions ¬ global,    stackLevel: CARDINAL ¬ 0,     dumping: StackType ¬ process,        -- Parsing    q: QRef ¬ NIL,    v: VRef ¬ NIL,    l: LRef ¬ NIL,    s: SRef ¬ NIL,    currentState: ITDIParseTable.State ¬ ITDIParseTable.InitialState,    inputSymbol, lhs: ITDIParseTable.TSymbol ¬ ITDIParseTable.EndMarker,    inputLoc, qI, top, stackSize, queueSize: CARDINAL ¬ 0,    inputValue: UNSPECIFIED ¬ 0,    buffer: LONG STRING ¬ NIL,		-- token assembly area    iMax: CARDINAL ¬ 0,			-- iMax = buffer.maxlength    text: LONG STRING ¬ NIL,        -- the input string    desc: String.SubStringDescriptor ¬ [NIL, 0, 0],  -- initial buffer segment    charIndex: CARDINAL ¬ 0,                -- index of current character    char: CHARACTER ¬ Ascii.NUL,        -- most recently scanned character    qDot: BOOLEAN ¬ FALSE,	-- used to resolve decimal point vs. interval    spare: LONG UNSPECIFIED];      WordBoolean: TYPE = RECORD [SELECT OVERLAID * FROM     f1 => [b: BOOLEAN],    f2 => [w: WORD],    ENDCASE];    GoFormItems: TYPE = MACHINE DEPENDENT {proceed(0), abort(1), kill(2), screen(3), start(4), (65535)};  ReadFormItems: TYPE = MACHINE DEPENDENT {octal(0), ascii(1), evalstack(2), (65535)};  WriteFormItems: TYPE = MACHINE DEPENDENT {octal(0), (65535)};  AttachFormItems: TYPE = MACHINE DEPENDENT {source(0), symbols(1), (65535)};  BreakFormItems: TYPE = MACHINE DEPENDENT {setbreak(0), clearbreak(1), clearall(2), list(3), attachCondition(4), attachKey(5), (65535)};  WatchFormItems: TYPE = MACHINE DEPENDENT {off(0), on(1)};  ClientFormItems: TYPE = MACHINE DEPENDENT {local(0), outload(1), remote(2), dormant(3), setDUD(4), spare(5), (65535)};  ClearEnumerated: UNSPECIFIED = LAST[CARDINAL];      LongRec: TYPE = RECORD [sei, lsei: Symbols.CSEIndex];    InitZoom: TYPE = RECORD [firstOpening: BOOLEAN, rememberPos: TextSource.Position];    StackOptions: TYPE = MACHINE DEPENDENT {global(0), local(1), limited(2), (65535)};    lognameMax: CARDINAL = 12;    Prefix: TYPE = {a, as, at, b, ba, c, cl, cla, cle, clx, d, f, l, o, re, s, se, t, ta, top};    StackType: TYPE = {process, queue};      ZeroProc: TYPE = PROC [Handle];  OneProc: TYPE = PROC [Handle, LONG STRING];  TwoProc: TYPE = PROC [Handle, LONG STRING, LONG STRING];    lastntstate: ITDIParseTable.State = LAST[ITDIParseTable.NTState];  DefaultMarker: ITDIParseTable.TSymbol = FIRST[ITDIParseTable.TSymbol];  Token: TYPE = RECORD [    class: ITDIParseTable.TSymbol,    value: UNSPECIFIED,    index: CARDINAL];  hashval: ITDIParseTable.HashIndex = LAST[ITDIParseTable.HashIndex];   QRef: TYPE = LONG POINTER TO ARRAY OF ITDIParseTable.ActionEntry;  VRef: TYPE = LONG POINTER TO ARRAY OF UNSPECIFIED;  LRef: TYPE = LONG POINTER TO ARRAY OF CARDINAL;  SRef: TYPE = LONG POINTER TO ARRAY OF ITDIParseTable.State;    FooProc: TYPE = PROC [h: Handle, f: Foo];    ModCache: TYPE = LONG POINTER TO ModCacheObject;    ModCacheObject: TYPE = RECORD [link: ModCache, cnt: CARDINAL, subCache: ARRAY [0..0) OF ModItemObject];  MaxModCnt: CARDINAL = (Environment.wordsPerPage - SIZE[ModCacheObject]) / SIZE[ModItemObject];  ModItem: TYPE = LONG POINTER TO ModItemObject;  ModItemObject: TYPE = RECORD [    allocated: BOOLEAN ¬ FALSE,    crossJumped: BOOLEAN,    mdi: Symbols.MDIndex,    frames: GFandWorldList,    stopping: BOOLEAN ¬ NULL,    fgtAvailable: BOOLEAN,    outerCtx: Symbols.CTXIndex ¬ Symbols.IncludedCTXNull,    sourceOk: BOOLEAN ¬ FALSE,    directoryCtx: Symbols.CTXIndex ¬ Symbols.IncludedCTXNull,    importCtx: Symbols.CTXIndex ¬ Symbols.IncludedCTXNull];  GFandWorldList: TYPE = ARRAY [0..MaxGFandWorld) OF GFandWorld;  GFandWorld: TYPE = RECORD[world: WorldVMOps.World, gf: GFHandle];  MaxGFandWorld: CARDINAL = 2; -- say  PcCache: TYPE = LONG BASE POINTER TO UNSPECIFIED;  PcCacheLimit: CARDINAL = (Environment.wordsPerPage / SIZE[PcItemObject]) * SIZE[PcItemObject];  PcItemNull: PcItem = LAST[PcItem];  PcItem: TYPE = PcCache RELATIVE ORDERED POINTER [0..256) TO PcItemObject;  PcItemObject: TYPE = RECORD [    link: PcItem,    ep: EVIndex,    gf: GFHandle,    start, end: BytePC,    hasSons: BOOLEAN,    inner: BOOLEAN,    dCbti: Symbols.CBTIndex,    userCbti: Symbols.CBTIndex];  PsbCache: TYPE = LONG POINTER TO PsbCacheObject;  PsbCacheObject: TYPE = RECORD [link: PsbCache, cnt: CARDINAL, subCache: ARRAY [0..0) OF PsbItemObject];  MaxPsbCnt: CARDINAL = (Environment.wordsPerPage - SIZE[PsbCacheObject]) / SIZE[PsbItemObject];  PsbItem: TYPE = LONG POINTER TO PsbItemObject;  PsbItemObject: TYPE = RECORD [p: Process, psb: ProcessStateBlock];  ProcessStateBlock: TYPE[8];  FrameCache: TYPE = LONG POINTER TO FrameCacheObject;  FrameCacheObject: TYPE = RECORD [link: FrameCache, cnt: CARDINAL, subCache: ARRAY [0..0) OF FrameItemObject];  MaxFrameCnt: CARDINAL = (Environment.wordsPerPage - SIZE[FrameCacheObject])/SIZE[FrameItemObject];  FrameItem: TYPE = LONG POINTER TO FrameItemObject;  FrameItemObject: TYPE = RECORD [fp: FramePointer, frame: Overhead];  FramePointer: TYPE = RECORD [SELECT OVERLAID * FROM    pointer => [fill: [0..77777B], lg: LG, fill1: [0..177777B]],    fullPointer => [frame: LONG POINTER],    local => [lf: LFHandle],    global => [gf: GFHandle],    ENDCASE];  LG: TYPE = {local, global};  Overhead: TYPE[4];  LongLocalFrameHandle: TYPE = LONG POINTER TO Overhead;  LongGlobalFrameHandle: TYPE = LONG POINTER TO Overhead;    TreeList: TYPE = LONG POINTER TO TreeSeq;  TreeSeq: TYPE = RECORD [length: NAT, seq: SEQUENCE max: NAT OF Tree.Link];    Stack: TYPE = RECORD [link: LONG POINTER TO Stack, foo: Foo];    Options: TYPE = RECORD [    intRadix: CARDINAL ¬ 10,    intSigned: BOOLEAN ¬ TRUE,    cardRadix: CARDINAL ¬ 8,    cardSigned: BOOLEAN ¬ FALSE,    default: CARDINAL ¬ 8,    pRadix: CARDINAL ¬ 8,    lpRadix: CARDINAL ¬ 8,    relRadix: CARDINAL ¬ 10,    elementCnt: CARDINAL ¬ LAST[CARDINAL],    charCnt: CARDINAL ¬ LAST[CARDINAL],    fault, uncaught, break, calldebug: WordBoolean ¬ [f1[TRUE]],     processes, configs: WordBoolean ¬ [f1[FALSE]],    menu, resetLog: WordBoolean ¬ [f1[FALSE]],    variableWindow: Window.Box ¬ Window.nullBox,    spare: LONG UNSPECIFIED ¬ 0];      Strings: TYPE = LONG DESCRIPTOR FOR StringArray;  StringArray: TYPE = ARRAY StringId OF LONG STRING;  StringId: TYPE = {var, process, queue, module, proc, config, rconfig, source, condition, frame, pc, comment, exp, di, file, num1, num2, bbNum, filter, client, outload, jump, spare1, spare2, spare3};    CommandRec: TYPE = RECORD [    prompt: CommandList.Command ¬ null,    sId: StringId,    colon: BOOLEAN ¬ TRUE,    atom: BOOLEAN ¬ TRUE];      ParseProc: TYPE = PROC [h: Handle, c: CHARACTER];  PromptProc: TYPE = PROC [h: Handle];    InterpretContext: TYPE = RECORD [    SELECT howSet:* FROM      none => NULL,      local => [lf: LFHandle],      process => [psb: Process],      global => [gf: GFHandle],      state => [lf: LFHandle],      break => [bb: BBHandle],      spare => [u: LONG UNSPECIFIED],      ENDCASE];        MaxIdString: CARDINAL = 60;  MaxModuleString: CARDINAL = 60;    BitAddress: TYPE = RECORD [    base: LONG POINTER,    offset: [0..Environment.bitsPerWord],    local: BOOLEAN ¬ FALSE,    useStack: BOOLEAN ¬ FALSE];  FobTable: TYPE = LONG POINTER TO FobTableObject;  FobTableObject: TYPE = RECORD [link: FobTable, cnt: CARDINAL, subTable: ARRAY [0..0) OF Fob];  MaxFobCnt: CARDINAL = (Environment.wordsPerPage - SIZE[FobTableObject])/SIZE[Fob];      Foo: TYPE = LONG POINTER TO Fob;  Fob: TYPE = RECORD [    xfer: BOOLEAN,    biased: BOOLEAN,    there: BOOLEAN,    hti: Symbols.HTIndex,    typeOnly: BOOLEAN,    constant: BOOLEAN,    tsei: Symbols.SEIndex,    addr: BitAddress,    words: CARDINAL,	    bits: [0..Environment.bitsPerWord),    displayFieldsOfRecordsAs: {fields, variables},    indent: [0..32),    spare: [0..64)];  NullFob: Fob = [    xfer: FALSE, biased: FALSE, hti: Symbols.HTNull, there: FALSE,     typeOnly: FALSE, constant: FALSE, tsei: Symbols.SENull, addr: [NIL, 0, FALSE],         words: 0, bits: 0, displayFieldsOfRecordsAs: fields, indent: 0, spare: 0];  BBHandle: TYPE = LONG POINTER TO BreakBlock;  BreakBlock: TYPE = RECORD [    link: BBHandle,     gf: GFHandle,    context: GFHandle,    condition, exp: LONG STRING,    pc: BytePC,     num: CARDINAL,     inst: BYTE,     symbolsAvailable: BOOLEAN,    there: BOOLEAN,    step: BOOLEAN,    bt: BreakType,    spare: LONG POINTER ¬ NIL];  BreakType: TYPE = RECORD [ex: EXOI, bt: BT];  EXOI: TYPE = {entry, exit, octal, in};  BT: TYPE = {break, trace};  EnumeratedSEIndex: TYPE = Symbols.Base RELATIVE POINTER [0..Symbols.Limit) TO    enumerated cons Symbols.SERecord;  SequenceSEIndex: TYPE = Symbols.Base RELATIVE POINTER [0..Symbols.Limit) TO    sequence cons Symbols.SERecord;  UnionSEIndex: TYPE = Symbols.Base RELATIVE POINTER [0..Symbols.Limit) TO    union cons Symbols.SERecord;  ArrayDescSEIndex: TYPE = Symbols.Base RELATIVE POINTER [0..Symbols.Limit) TO    arraydesc cons Symbols.SERecord;  TransferSEIndex: TYPE = Symbols.Base RELATIVE POINTER [0..Symbols.Limit) TO    transfer cons Symbols.SERecord;  SubrangeSEIndex: TYPE = Symbols.Base RELATIVE POINTER [0..Symbols.Limit) TO    subrange cons Symbols.SERecord;  LongSEIndex: TYPE = Symbols.Base RELATIVE POINTER [0..Symbols.Limit) TO    long cons Symbols.SERecord;      NumberType: TYPE = {nogood, one, two};  -- ordered for Words  Words: TYPE = ARRAY NumberType[nogood..two) OF WORD;    Number: TYPE = RECORD [type: NumberType, pad: [0..37777B],    body: SELECT OVERLAID * FROM      integer => [i: INTEGER],      cardinal => [c: CARDINAL],      pointer => [p: POINTER],      unspecified => [u: UNSPECIFIED],      rep => [sign: BOOLEAN, fill1: [0..77777B)],      longInt => [li: LONG INTEGER],      longCard => [lc: LONG CARDINAL],      longPoint => [lp: LONG POINTER],      longUnspec => [lu: LONG UNSPECIFIED],      longRep => [fill2: UNSPECIFIED, lsign: BOOLEAN, fill3: [0..77777B)],      numArray => [w: Words],      ENDCASE];  NumAddr: TYPE = RECORD [SELECT OVERLAID * FROM      int => [pi: LONG POINTER TO INTEGER],      card => [pc: LONG POINTER TO CARDINAL],      lInt => [pli: LONG POINTER TO LONG INTEGER],      lCard => [plc: LONG POINTER TO LONG CARDINAL],      ENDCASE];  NumFormat: TYPE = RECORD [SELECT OVERLAID * FROM      int => [i: INTEGER],      card => [c: CARDINAL],      bytes => [b1, b2: BYTE],      nibbles => [n1, n2, n3, n4: [0..16)],      ENDCASE];  LongNumFormat: TYPE = RECORD [ SELECT OVERLAID * FROM      int => [i: LONG INTEGER],      card => [c: LONG CARDINAL],      words => [w1, w2: CARDINAL],      bytes => [b1, b2, b3, b4: BYTE],      ENDCASE];  Desc: TYPE = RECORD [base: POINTER, length: CARDINAL, offset: [0..Environment.bitsPerWord]];  LongDesc: TYPE = RECORD [base: LONG POINTER, length: CARDINAL, offset: [0..Environment.bitsPerWord]];    OctalFormat: Format.NumberFormat = [8,FALSE,TRUE,6];  OctalNumberFormat: Format.NumberFormat = [8,FALSE,TRUE,0];  HexNumberFormat: Format.NumberFormat = [16,FALSE,TRUE,0];  DecimalNumberFormat: Format.NumberFormat = [10,FALSE,TRUE,0];  IntegerNumberFormat: Format.NumberFormat = [10,FALSE,FALSE,0];  ValFormat: TYPE = RECORD [    SELECT tag: * FROM      none => [],      card => [],      int => [],      char => [],      pointer => [],      relative => [],      string => [],      enum => [esei: EnumeratedSEIndex],      ENDCASE];        WordSeq: TYPE = RECORD [SEQUENCE COMPUTED CARDINAL OF WORD];    PrintHandle: TYPE = LONG POINTER TO PrintRec;  PrintRec: TYPE = RECORD [    link: PrintHandle,    sym: LONG STRING,    tsei: Symbols.SEIndex,    proc: Printer];  ArrayHandle: TYPE = LONG POINTER TO ArrayInfo;  ArrayInfo: TYPE = RECORD [    addr: BitAddress,    start: CARDINAL,    stop: CARDINAL,    length: CARDINAL,    packing: CARDINAL,  -- in bits    there: BOOLEAN,    type: Symbols.SEIndex];  Printer: TYPE = PROC [Handle, Foo] RETURNS [BOOLEAN];    TermProc: TYPE = PROC [Handle, CHARACTER] RETURNS [BOOLEAN];  CommandProc: TYPE = PROCEDURE [h: Handle ¬ NIL];    CoreSwapMessages: TYPE = {none, cantSwap, evalstack, interrupt, maplog};  GFHandle: TYPE = WorldVMOps.LongGlobalFrameHandle;  NILGF: GFHandle = NIL;  LFHandle: TYPE = WorldVMOps.LongLocalFrameHandle;  NILLF: LFHandle = NIL;  Process: TYPE = WorldVMOps.Process;  NullProcess: Process = WorldVMOps.NullProcess;  ControlLink: TYPE = WorldVMOps.ControlLink;  SignalDesc: TYPE = WorldVMOps.SignalDesc;  PrefixHandle: TYPE = WorldVMOps.PrefixHandle;  BytePC: TYPE = WorldVMOps.BytePC;  BYTE: TYPE = WorldVMOps.BYTE;    VType: TYPE = {controlled, overlaid, computed};  exp: Tree.NodeName = exit;  memoryInt: Tree.NodeName = open;  arrayInt: Tree.NodeName = unit;  reps: Tree.NodeName = label;  conditionalBreak: Tree.NodeName = internal;  eol: Tree.NodeName = rowcons;  frameDollar: Tree.NodeName = index;  fileDollar: Tree.NodeName = cdot;  typeDollar: Tree.NodeName = dollar;  card: Tree.NodeName = stringinit;  lcard: Tree.NodeName = textlit;  int: Tree.NodeName = signalinit;  lint: Tree.NodeName = procinit;  bang: Tree.NodeName = cast;  memory: Tree.NodeName = openx;    OpHandle: TYPE = LONG POINTER TO CPSwapDefs.OperandDesc;  TreeType: TYPE = {subtree, hash, symbol, literal};    FrameDesc: TYPE = LONG DESCRIPTOR FOR READONLY ARRAY OF GFHandle;  Flavor: TYPE = {    manifest, refVal, refProc, val, inline, controlLink, proc, signal};    nullPC: BytePC = 0;  CtxLink: TYPE = LONG POINTER TO CtxItem;  CtxItem: TYPE = RECORD [    link: CtxLink,    indirect: BOOLEAN,    onStack: BOOLEAN,    indent: [0..37777B],    mapped: BOOLEAN,    body: SELECT tag:* FROM      context => [ictx: Symbols.CTXIndex],      empty => [level: Symbols.ContextLevel],      ENDCASE];        EVIndex: TYPE = CARDINAL;  EVNull: EVIndex = LAST[EVIndex];    MDIndex: TYPE = Symbols.MDIndex;  MDNull: MDIndex = Symbols.MDNull;  BTIndex: TYPE = Symbols.BTIndex;  BTNull: BTIndex = Symbols.BTNull;    CBTIndex: TYPE = Symbols.CBTIndex;    CBTNull: CBTIndex = Symbols.CBTNull;  CTXIndex: TYPE = Symbols.CTXIndex;  CTXNull: CTXIndex = Symbols.CTXNull;    IncludedCTXIndex: TYPE = Symbols.IncludedCTXIndex;    IncludedCTXNull: IncludedCTXIndex = Symbols.IncludedCTXNull;  HTIndex: TYPE = Symbols.HTIndex;  HTNull: HTIndex = Symbols.HTNull;  SEIndex: TYPE = Symbols.SEIndex;  SENull: SEIndex = Symbols.SENull;    ISEIndex: TYPE = Symbols.ISEIndex;    ISENull: ISEIndex = Symbols.ISENull;    CSEIndex: TYPE = Symbols.CSEIndex;    CSENull: CSEIndex = Symbols.CSENull;    ArraySEIndex: TYPE = Symbols.ArraySEIndex;    RefSEIndex: TYPE = Symbols.RefSEIndex;    RecordSEIndex: TYPE = Symbols.RecordSEIndex;    }.
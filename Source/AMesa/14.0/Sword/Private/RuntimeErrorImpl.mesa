-- File: RuntimeErrorImpl.mesa - last edit:-- Litman              15-Apr-87 15:02:24-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.« This module sneaks in below Runtime. It catches events just before an outload and swap to the Debugger volume. It is the only way, at the moment, to intercept uncaught signals before a swap. This is because Signals calls RuntimeInternal.ProcessUncaught directly, which then does CallDebuggerWithSwapData.As for faults, we should probably use SpecialSpace.RegisterAddressFaultFielder andSpecialSpace.RegisterWriteProtectFaultFielder, but the current fielder (PageFaultImpl$AwaitAddressFault) is good enough. Besides all it does isProcessOperations.Requeue the process from the hardware queue to the software queue. »DIRECTORY  CPSwapDefs USING [ExternalStateVector],  DebuggerSwap USING [AwaitDebuggerRequest, SetDebuggerFielder],  Environment,  Frame USING [Free, GetReturnFrame, SetReturnFrame],  FrameExtras,  Inline,   PrincOps USING [LocalFrameHandle, Port, PortHandle],  PrincOpsExtras2 USING [ControlLink, GFTHandle, nullGFH],  ProcessOperations USING [DisableInterrupts, EnableInterrupts],  RuntimeError USING [BreakProc, CDProc, FaultProc, UCSProc],  Space USING [ScratchMap, Unmap],  SpecialSpace USING [MakeGlobalFrameResident, MakeGlobalFrameSwappable, MakeProcedureResident, MakeProcedureSwappable, SpecialError],  VM USING [MakeResident, MakeSwappable];RuntimeErrorImpl: MONITOR  IMPORTS DebuggerSwap, Environment, Frame, FrameExtras, Inline, ProcessOperations, Space, SpecialSpace, VM  EXPORTS RuntimeError = {  ESVPointer: TYPE = LONG POINTER TO CPSwapDefs.ExternalStateVector;  ControlLink: TYPE = PrincOpsExtras2.ControlLink;  pilotDebuggerFielder: PROC [pEsv: ESVPointer];  InitializeAwaitDebuggerRequest: PROC = {    awaitDebuggerRequest: DebuggerSwap.AwaitDebuggerRequest;    LOOPHOLE[awaitDebuggerRequest, PrincOps.Port].out ¬ Frame.GetReturnFrame[];    pilotDebuggerFielder ¬ LOOPHOLE[LONG[DebuggerSwap.SetDebuggerFielder[@awaitDebuggerRequest]]];    DO  -- forever      pESV: ESVPointer = awaitDebuggerRequest[];      Frame.SetReturnFrame[LOOPHOLE[awaitDebuggerRequest, PrincOps.Port].dest.frame]; -- for debugging me      IF pESV.swapData.mayCallDebuggee AND ~InFilter[pESV.swapData.lFrame] THEN {	WITH sd: pESV.swapData SELECT FROM	  storageFault =>  	    IF faultHandler # NIL THEN {	      ProcessOperations.EnableInterrupts[];	      [] ¬ DebuggerSwap.SetDebuggerFielder[LOOPHOLE[LOOPHOLE[pilotDebuggerFielder, ControlLink].port]];	      faultHandler[sd.type, sd.faultedProcess, sd.lFrame];	      [] ¬ DebuggerSwap.SetDebuggerFielder[@awaitDebuggerRequest];	      ProcessOperations.DisableInterrupts[]}	    ELSE pilotDebuggerFielder[pESV];	  breakpoint => 	    IF breakHandler # NIL THEN {	      ProcessOperations.EnableInterrupts[];	      [] ¬ DebuggerSwap.SetDebuggerFielder[LOOPHOLE[LOOPHOLE[pilotDebuggerFielder, ControlLink].port]];	      IF ~breakHandler[sd.instByteReceptacle, sd.sv, sd.lFrame] THEN {		  ProcessOperations.DisableInterrupts[];		  pilotDebuggerFielder[pESV];		  ProcessOperations.EnableInterrupts[]};	      [] ¬ DebuggerSwap.SetDebuggerFielder[@awaitDebuggerRequest];	      ProcessOperations.DisableInterrupts[]}	    ELSE pilotDebuggerFielder[pESV];	  uncaughtSignal => 	    IF ucsHandler # NIL THEN {	      ProcessOperations.EnableInterrupts[];	      [] ¬ DebuggerSwap.SetDebuggerFielder[LOOPHOLE[LOOPHOLE[pilotDebuggerFielder, ControlLink].port]];	      ucsHandler[sd.signalError, sd.signalArgs, LOOPHOLE[sd.signal], sd.lFrame];	      [] ¬ DebuggerSwap.SetDebuggerFielder[@awaitDebuggerRequest];	      ProcessOperations.DisableInterrupts[]}	    ELSE pilotDebuggerFielder[pESV]; 	  callDebugger => 	    IF cdHandler # NIL THEN {	      ProcessOperations.EnableInterrupts[];	      [] ¬ DebuggerSwap.SetDebuggerFielder[LOOPHOLE[LOOPHOLE[pilotDebuggerFielder, ControlLink].port]];	      cdHandler[sd.message, sd.lFrame];	      [] ¬ DebuggerSwap.SetDebuggerFielder[@awaitDebuggerRequest];	      ProcessOperations.DisableInterrupts[]}	    ELSE pilotDebuggerFielder[pESV];	  ENDCASE => pilotDebuggerFielder[pESV]}	ELSE pilotDebuggerFielder[pESV];      ENDLOOP }; -- end InitializeAwaitDebuggerRequest          faultHandler: RuntimeError.FaultProc ¬ NIL;  ucsHandler: RuntimeError.UCSProc ¬ NIL;  cdHandler: RuntimeError.CDProc ¬ NIL;  breakHandler: RuntimeError.BreakProc ¬ NIL;    GFHandle: TYPE = PrincOpsExtras2.GFTHandle;  maxFilters: CARDINAL ¬ 0;  filters: LONG POINTER TO ARRAY [0..0) OF GFHandle ¬ NIL;   WPP: CARDINAL = Environment.wordsPerPage;      RegisterUncaughtSignalHandler: PUBLIC ENTRY PROC [proc: RuntimeError.UCSProc] RETURNS [old: RuntimeError.UCSProc] = {    old ¬ ucsHandler;    ucsHandler ¬ proc};    RegisterFaultHandler: PUBLIC ENTRY PROC [proc: RuntimeError.FaultProc] RETURNS [old: RuntimeError.FaultProc] = {    old ¬ faultHandler;    faultHandler ¬ proc};    RegisterCallDebugHandler: PUBLIC ENTRY PROC [proc: RuntimeError.CDProc]  RETURNS [old: RuntimeError.CDProc] = {    old ¬ cdHandler;    cdHandler ¬ proc};      RegisterBreakHandler: PUBLIC ENTRY PROC [proc: RuntimeError.BreakProc] RETURNS [old: RuntimeError.BreakProc] = {    old ¬ breakHandler;    breakHandler ¬ proc};      InitializeFilter: PUBLIC PROC[n: CARDINAL] = {    pages: CARDINAL ¬ (n * SIZE[GFHandle] + WPP - 1) / WPP;    words: CARDINAL ¬ pages * WPP;    IF pages = 0 THEN RETURN;    filters ¬ Space.ScratchMap[count: pages];    VM.MakeResident[[Environment.PageFromLongPointer[filters], pages], wait];    Zero[filters, words];    maxFilters ¬ words / SIZE[GFHandle] };      Zero: PROC [p: LONG POINTER, l: CARDINAL] = INLINE {    IF l = 0 THEN RETURN;    p­ ¬ 0;    Inline.LongCOPY[from: p, to: p+1, nwords: l-1] --ok-- };      RegisterFilter: PUBLIC PROC[gf: GFHandle] = {    NoneEmpty: CARDINAL = LAST[CARDINAL];    empty: CARDINAL ¬ NoneEmpty;    FOR i: CARDINAL IN [0..maxFilters) DO      SELECT filters[i] FROM        PrincOpsExtras2.nullGFH => empty ¬ i;        gf => RETURN;	ENDCASE;      REPEAT FINISHED =>         IF empty = NoneEmpty THEN ERROR TooManyFilters ELSE filters[empty] ¬ gf;      ENDLOOP};        TooManyFilters: PUBLIC ERROR = CODE;    UnRegisterFilter: PUBLIC PROC[gf: GFHandle] = {    FOR i: CARDINAL IN [0..maxFilters) DO      IF filters[i] = gf THEN { filters[i] ¬ PrincOpsExtras2.nullGFH; RETURN };      REPEAT FINISHED => ERROR NoSuchFilter;      ENDLOOP };    NoSuchFilter: PUBLIC ERROR = CODE;    ClearFilter: PUBLIC PROC[] = { Zero[filters, maxFilters * SIZE[GFHandle]]; };    InFilter: PROC[lf: PrincOps.LocalFrameHandle] RETURNS[BOOLEAN] = INLINE {    gf: GFHandle = FrameExtras.ReadGlobalLink[lf];    FOR i: CARDINAL IN [0..maxFilters) DO      IF gf = filters[i] THEN RETURN[TRUE];      REPEAT FINISHED => RETURN[FALSE];      ENDLOOP};    InformationalSignal: PUBLIC PROC [signal: SIGNAL] = {};  UNCAUGHT: PUBLIC ERROR[ucsignal: SIGNAL, parameters: WORD] = CODE;    -- Pretend we were never here.  PrepareToUnload: PUBLIC PROC[] = {    myPort: POINTER TO DebuggerSwap.AwaitDebuggerRequest ¬ DebuggerSwap.SetDebuggerFielder[LOOPHOLE[LOOPHOLE[pilotDebuggerFielder, ControlLink].port]];    Frame.Free[LOOPHOLE[myPort, PrincOps.PortHandle].frame];    SpecialSpace.MakeGlobalFrameSwappable[RuntimeErrorImpl ! SpecialSpace.SpecialError => CONTINUE];    SpecialSpace.MakeProcedureSwappable[InitializeAwaitDebuggerRequest ! SpecialSpace.SpecialError => CONTINUE];    IF filters # NIL THEN {      VM.MakeSwappable[[Environment.PageFromLongPointer[filters], (maxFilters * SIZE[GFHandle]) / WPP]];      filters ¬ Space.Unmap[filters] }};  -- Main  SpecialSpace.MakeGlobalFrameResident[RuntimeErrorImpl ! SpecialSpace.SpecialError => IF error = alreadyResident THEN CONTINUE];  SpecialSpace.MakeProcedureResident[InitializeAwaitDebuggerRequest ! SpecialSpace.SpecialError => IF error = alreadyResident THEN CONTINUE];  [] ¬ InitializeAwaitDebuggerRequest[];  }.
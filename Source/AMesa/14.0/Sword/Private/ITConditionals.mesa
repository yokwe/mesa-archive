-- File: ITConditionals.mesa - last edit:-- Litman              21-Apr-87 19:06:31-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.DIRECTORY  CommandList USING [BPError],  CPSwapDefs USING [BBHandle, OperandDesc, UBBPointer, UserBreakBlock],  IO USING [FreeString, IntConditional, InvalidNumber, StringExpToDecimal, zone],  IP USING [CodeBase, IllegalConditional],  IQ USING [BPAbortWithWrittenError, BPFail, BPWriteError, FindBBNum],  IT USING [BBHandle, BytePC, Handle, InterpretContext, PrefixHandle],  String USING [CopyToNewString, Equal],  Tree USING [NodeName],  WorldVMOps USING [CopyRead, CopyWrite, GetESV, Read];ITConditionals: PROGRAM IMPORTS IO, IP, IQ, String, WorldVMOps  EXPORTS IQ = {  ubb: CPSwapDefs.UBBPointer; -- transient  AttachCondition: PUBLIC PROC [h: IT.Handle, bbNum, cond: LONG STRING] = {    Conditionalize[h, GetBreak[h, bbNum], cond]};  ClearCondition: PUBLIC PROCEDURE [h: IT.Handle, bbNum: LONG STRING] = {    AttachCondition[h, bbNum, NIL]};  Conditionalize: PUBLIC PROC [h: IT.Handle, bb: IT.BBHandle, cond: LONG STRING] = {    ENABLE IP.IllegalConditional => {      IF bb.condition # NIL THEN {        IO.FreeString[h, bb.condition];	bb.condition ¬ NIL};      CONTINUE };    userBB: CPSwapDefs.UserBreakBlock;    IF bb = NIL THEN IQ.BPAbortWithWrittenError[h, notFound];    IF cond = NIL OR cond.length = 0 THEN {      IF bb.condition # NIL THEN {        IO.FreeString[h, bb.condition];	bb.condition ¬ NIL };      FreeUserBB[h, IP.CodeBase[h, bb.gf], bb.pc];      RETURN };    IF h.worryBreaks THEN IQ.BPWriteError[h, worryOn];    userBB ¬ [      codeBase: IP.CodeBase[h, bb.gf],       pc: LOOPHOLE[bb.pc],       inst: bb.inst,       relation:,       leftOperand: TRASH,       rightOperand: TRASH];    ubb ¬ @userBB;    ParseConditional[h, cond, @userBB, bb];    bb.condition ¬ String.CopyToNewString[cond, IO.zone];    WriteUserBB[h, @userBB] };  GetBreak: PROC [h: IT.Handle, num: LONG STRING] RETURNS [bb: IT.BBHandle] = {    i: INTEGER ¬ 0;    i ¬ IO.StringExpToDecimal[h, num ! IO.InvalidNumber => CONTINUE];    IF i = 0 THEN RETURN[NIL];    RETURN [IQ.FindBBNum[h, LOOPHOLE[i, CARDINAL]]] };  ParseConditional: PROCEDURE [h: IT.Handle, c: LONG STRING, p: CPSwapDefs.UBBPointer, bb: IT.BBHandle] = {    oldContext: IT.InterpretContext = h.iContext;    IF Counter[h, c, p] THEN RETURN;    h.iContext ¬ [break[bb]];    IO.IntConditional[h, c ! UNWIND => h.iContext ¬ oldContext];    h.iContext ¬ oldContext };    Counter: PROC [h: IT.Handle, c: LONG STRING, p: CPSwapDefs.UBBPointer] RETURNS [BOOLEAN] = {    SELECT TRUE FROM      String.Equal[c, "TRUE"L] =>  p.rightOperand ¬ [0, 32, immediate[value: 1]];      String.Equal[c, "FALSE"L] =>  p.rightOperand ¬ [0, 32, immediate[value: 0]];      ENDCASE => {        FOR i: CARDINAL IN [0..c.length) DO 	  IF c[i] ~IN['0..'9] THEN RETURN[FALSE]	  ENDLOOP;	p.rightOperand ¬ [0, 32, immediate[value: IO.StringExpToDecimal[h, c]]]};    p.leftOperand ¬ [0, 32, counter[timesSoFar: 0]];    p.relation ¬ eq;    RETURN[TRUE] };    Condition: PUBLIC PROC [h: IT.Handle, left: CPSwapDefs.OperandDesc, rel: Tree.NodeName, right: CPSwapDefs.OperandDesc] = {    SELECT rel FROM      relE => ubb.relation ¬ eq;      relN => ubb.relation ¬ ne;      relL => ubb.relation ¬ lt;      relLE => ubb.relation ¬ le;      relG => ubb.relation ¬ gt;      relGE => ubb.relation ¬ ge;      ENDCASE => IQ.BPAbortWithWrittenError[h, invalidRelation];    ubb.leftOperand ¬ left;    ubb.rightOperand ¬ right };      WriteUserBB: PUBLIC PROC [h: IT.Handle, ubb: CPSwapDefs.UBBPointer] = {    i: CARDINAL;    i ¬ GetUserBB[h, ubb.codeBase, ubb.pc ! IQ.BPFail => IQ.BPAbortWithWrittenError[h, type]];    WorldVMOps.CopyWrite[world: h.world, from: ubb, to: @WorldVMOps.GetESV[h.world].breakBlocks.blocks[i], nwords: SIZE[CPSwapDefs.UserBreakBlock]] };  GetUserBB: PUBLIC PROC [h: IT.Handle, ph: IT.PrefixHandle, pc: IT.BytePC] RETURNS [i: CARDINAL] = {    i ¬ FindUserBBInternal[h, ph, pc, TRUE];    IF i = LAST[CARDINAL] THEN ERROR IQ.BPFail[tooManyConditions] };  FindUserBB: PUBLIC PROC [h: IT.Handle, ph: IT.PrefixHandle, pc: IT.BytePC] RETURNS [i: CARDINAL] = {    RETURN[FindUserBBInternal[h, ph, pc, FALSE]]};    FindUserBBInternal: PROC [h: IT.Handle, ph: IT.PrefixHandle, pc: IT.BytePC, returnUnused: BOOLEAN] RETURNS [i: CARDINAL] = {    bbHandle: CPSwapDefs.BBHandle = WorldVMOps.GetESV[h.world].breakBlocks;    n: CARDINAL = WorldVMOps.Read[h.world, @bbHandle.length];    lastUnused: CARDINAL ¬ LAST[CARDINAL];    FOR i DECREASING IN [0..n) DO      prefix: IT.PrefixHandle;      WorldVMOps.CopyRead[world: h.world, from: @bbHandle.blocks[i].codeBase, to: @prefix, nwords: SIZE[IT.PrefixHandle]];      IF prefix = NIL THEN lastUnused ¬ i       ELSE IF prefix = ph AND WorldVMOps.Read[h.world, @bbHandle.blocks[i].pc] = pc THEN RETURN[i];      ENDLOOP;    RETURN[IF returnUnused THEN lastUnused ELSE LAST[CARDINAL]] };  FreeUserBB: PUBLIC PROCEDURE [h: IT.Handle, ph: IT.PrefixHandle, pc: IT.BytePC] = {    i: CARDINAL = FindUserBB[h, ph, pc];    prefix: IT.PrefixHandle ¬ NIL;    IF i = LAST[CARDINAL] THEN IQ.BPAbortWithWrittenError[h, conditionNotFound];    WorldVMOps.CopyWrite[world: h.world, from: @prefix, to: @WorldVMOps.GetESV[h.world].breakBlocks.blocks[i].codeBase, nwords: SIZE[IT.PrefixHandle]] };  }.
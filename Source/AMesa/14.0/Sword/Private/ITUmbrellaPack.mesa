-- File: ITUmbrellaPack.mesa - last edit:-- Litman              22-Apr-87 11:51:01-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.DIRECTORY  Alloc USING [Failure, Handle, Overflow],  AMLoadstate USING [Error, ErrorCode],  AMUseful USING [NoModule],  CommandList USING [Error],  Copier USING [FileProblem, FileVersion, FileVersionMix],  File USING [File, Unknown],  IO USING [Blanks, Char, Decimal, EOL, InvalidCharacter, InvalidNumber, Line, LiteralProblem, NotImplemented, ParseError, SyntaxError, Text, UserAborted],  IP USING [Clobbered, Fail, FileMissing, NoAccessLink, NoPrevious, NoStack, NotAnArray, NotHere, NotInAnyProcedure],  IQ USING [BPFail, InvalidFrame, ResetSymbols],  IS USING [HtiVal, Invalid, LongNum, WriteError],  IT USING [Handle],  Runtime USING [CallDebugger],  Space USING [InsufficientSpace],  SpecialRuntime USING [ResumeError],  String USING [InvalidNumber, StringBoundsFault],  WorldVMOps USING [AddressFault, WriteProtected];  ITUmbrellaPack: PROGRAM  IMPORTS Alloc, AMLoadstate, AMUseful, Copier, File, IO, IP, IQ, IS, Runtime, Space, SpecialRuntime, String, WorldVMOps  EXPORTS IS = {    LoadStateMsgs: PROC[h: IT.Handle, code: AMLoadstate.ErrorCode] = {    Msgs: ARRAY AMLoadstate.ErrorCode OF STRING = [      invalidParameters: "Invalid Parameters"L,      invalidAddress: "Invalid Address"L,      versionMismatch: "Version Mismatch"L,      loadStateMissing: "LoadState Missing"L,      bcdInfoMissing: "BcdInfo Missing"L,      moduleInfoMissing: "ModuleInfo Missing"L,      moduleTableMissing: "ModuleTable Missing"L,      diskErrorInVMMap: "DiskError In VMMap"L,      insufficientSpace: "Insufficient Space"L,      couldNotAcquireALoadedBcd: "Could not acquire a loaded bcd"L,      other: "other"L];    IO.Line[h, Msgs[code]] };    LiteralProblem: PROCEDURE[h: IT.Handle] = {    -- workaround for pruning Fob tree too much and flushing literal nodes     -- that have pointers to them still around in the symbol table    IO.Line[h, "!Literal problem"L]};    Checking: PROC[h: IT.Handle] = {    IF h.debugging THEN Runtime.CallDebugger["Debugger problem? Proceed should recover."L]};      PrintFrame: PROC[h: IT.Handle, f: LONG POINTER, error: CommandList.Error] = {    IO.Char[h, ' ];     IS.LongNum[h, f, [pointer[]]];    IS.WriteError[h, error, FALSE];     IO.Char[h, ' ]; };      Umbrella: PUBLIC PROC [it: IT.Handle, data: LONG UNSPECIFIED, proc: PROC [IT.Handle, LONG UNSPECIFIED]] = {    BEGIN ENABLE IO.UserAborted => CONTINUE;    BEGIN ENABLE {      -- ABORTED => CONTINUE;      Alloc.Failure => {        IO.Text[" warning: "L, it]; IS.WriteError[it, symbolOverflow, FALSE];	IO.Char[it, '[]; IO.Decimal[it, table]; IO.Char[it, ']];	Checking[it]; GOTO AllocFailure; };      Alloc.Overflow => {        «Checking[it];» RESUME[4] };      AMUseful.NoModule => { IS.WriteError[it, nGframe, FALSE]; CONTINUE };      IQ.BPFail => CONTINUE;      Copier.FileProblem => { -- Could not open file.	IO.Blanks[it, 1]; IS.HtiVal[it, hti]; IS.WriteError[it, notFound, FALSE]; 	Checking[it]; RESUME[TRUE]};      Copier.FileVersion => { -- Have wrong version on disk.	IO.Blanks[it, 1]; IS.HtiVal[it, hti]; IS.WriteError[it, diffver, FALSE];	Checking[it]; RESUME[TRUE]};      Copier.FileVersionMix => {	-- No one needs to know that there are two versions.	-- Blanks[it, 1]; IS.HtiVal[it, hti]; IS.WriteError[it, diffver, FALSE]; 	Checking[it]; RESUME};      AMLoadstate.Error => {        IS.WriteError[it, nAllowed, FALSE]; LoadStateMsgs[it, code];	Checking[it]; CONTINUE};      IS.Invalid => {        IS.LongNum[it, psb, [card[]]]; IS.WriteError[it, nPsb, FALSE];         Checking[it]; CONTINUE};      IP.FileMissing => {	IS.WriteError[it, file, FALSE]; 	IF name # NIL THEN IO.Text[name, it] ELSE IS.WriteError[it, compress, FALSE]; 	CONTINUE };      IP.NotInAnyProcedure => { IS.WriteError[it, invalidPc]; Checking[it]; RESUME};      IO.InvalidCharacter => { IS.WriteError[it, badChar]; CONTINUE};      IO.NotImplemented => { IO.Text[msg, it]; IS.WriteError[it, notImpl, FALSE]; CONTINUE};      IO.ParseError => { IS.WriteError[it, badParse]; CONTINUE};      IO.SyntaxError => { IS.WriteError[it, badSyntax]; CONTINUE};      IO.LiteralProblem => { LiteralProblem[it]; Checking[it]; CONTINUE};      WorldVMOps.AddressFault => {	IS.WriteError[it, badAddress, FALSE]; 	IS.LongNum[it, addr, [pointer[]]]; 	IO.Char[it, ']]; 	Checking[it]; CONTINUE};      IO.InvalidNumber => { IS.WriteError[it, num]; CONTINUE};      IO.UserAborted => GOTO UserAborted;      WorldVMOps.WriteProtected => {	IS.WriteError[it, writeProtect, FALSE]; 	IS.LongNum[it, addr, [pointer[]]]; 	IO.Char[it, ']]; 	Checking[it]; CONTINUE};      IP.NotAnArray => { IS.WriteError[it, notArray]; Checking[it]; CONTINUE};      IP.NotHere => { IS.WriteError[it, notHere]; Checking[it]; CONTINUE};      File.Unknown => { IS.WriteError[it, badDir]; Checking[it]; CONTINUE};      IQ.InvalidFrame => { PrintFrame[it, f, nGframe]; CONTINUE };      IP.Clobbered => { PrintFrame[it, f, cFrame]; CONTINUE };      IP.NoAccessLink => { PrintFrame[it, f, nAccesslink]; CONTINUE };      IP.NoPrevious => { PrintFrame[it, f, nReturnlink]; CONTINUE };      IP.Fail => { IO.EOL[it]; IO.Text[s, it]; IS.WriteError[it, notFound, FALSE]; CONTINUE};      IP.NoStack => { IS.WriteError[it, noStack]; Checking[it]; CONTINUE};      SpecialRuntime.ResumeError => { IS.WriteError[it, resume]; Checking[it]; CONTINUE};      Space.InsufficientSpace => {	IS.WriteError[it, insufficientVM, FALSE]; 	IS.LongNum[it, available, [card[]]]; 	IO.Char[it, ']]; 	Checking[it]; CONTINUE};      String.InvalidNumber => { IS.WriteError[it, num]; CONTINUE};      String.StringBoundsFault => {        «IO.Text[" """L, it]; 	IO.Text[s, it]; 	IS.WriteError[it, tooLong, FALSE]; 	Checking[it]; CONTINUE»	RESUME[NIL] }};    IF proc = NIL THEN {«TajoOps.Notifier[FALSE]»} ELSE proc[it, data];    EXITS       UserAborted => IS.WriteError[it, aborted];      AllocFailure => IQ.ResetSymbols[it];    END; «ENABLE»    END; «ENABLE IO.UserAborted» };        }.
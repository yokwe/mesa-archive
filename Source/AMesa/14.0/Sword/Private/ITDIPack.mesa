-- file ITDIPack.mesa rewritten by PGS, 28-Apr-87  0:22DIRECTORY  ComData USING [idANY, idBOOL, idCARDINAL, idCHAR, idINT, idREAL, idSTRING],  IO, IR, IS, IT,  ITDIParseTable,  Tree,  TreeOps USING [    PushHash, PushList, PushLit, PushNode, PushSe, PushStringLit, PushTree];  ITDIPack: PROGRAM  IMPORTS dataPtr: ComData, IO, IR, TreeOps  EXPORTS IS =  BEGIN OPEN IT, TreeOps;    proddata: ITDIParseTable.ProdDataRef ¬ NIL;    QueueInit: PUBLIC PROC [lproddata: ITDIParseTable.ProdDataRef] = {    proddata ¬ lproddata};        ProcessQueue: PUBLIC PROCEDURE [h: Handle] =    BEGIN OPEN h;    rule: [0..256);    i: CARDINAL;    vTop: UNSPECIFIED;    FOR i IN [0..qI) DO      top ¬ top-q[i].tag.pLength+1;  vTop ¬ v[top];      rule ¬ proddata[q[i].transition].rule;      SELECT rule FROM            0  => -- TABLE: ITDIGrammar  TYPE: ITDIParseTable   EXPORTS: SELF	--GOAL:  goal		--TERMINALS:	--    id  num  lnum flnum card lcard string  char 	--    ,   ;   ¬   +   -   *   /   ^   .   @    $   %	--    =   #   <  >   <=   >=      	--    INTEGER  CARDINAL  CHARACTER  BOOLEAN  REAL	--    POINTER  DESCRIPTOR  LONG  TO  BASE	--    ABS  MAX  MIN  MOD  LENGTH	--    LOOPHOLE  SIZE  FIRST  LAST TYPE	--    )   ]   (   [	--    STRING  UNSPECIFIED  MEMORY  !   \   ..   '?   &	--    WORD  PROCEDURE  PROC  ERROR  SIGNAL	--    NIL		--ALIASES:	--  id       tokenID	--  num      tokenNUM	--  lnum     tokenLNUM	--  flnum    tokenFLNUM	--  card     tokenCARD	--  lcard    tokenLCARD	--  string   tokenSTR	--  char     tokenCHAR	--  -        tokenMINUS	--  .        tokenDOT	--  ..       tokenDOTS	--  =        tokenEQUAL	--  <        tokenLESS	--  <=       tokenLE	--  >        tokenGREATER	--  >=       tokenGE	--  eof      endmarker		--  PRODUCTIONS:		--  goal					::= stmtlist \	PushNode[sym, eol,1];  -- all finished	      1  => -- stmtlist				::= statementlist 	    -- stmtlist					::= statementlist ;	  BEGIN	  PushList[sym, v[top]];  PushNode[sym, block,1];	  END;	        2  => -- statementlist				::= statementlist ; statement	BEGIN	-- clear the way for the next statement 	vTop ¬ v[top]+1; PushNode[sym, eol,1];	END;	      3  => -- statement				::= lhs ¬ exp	  PushNode[sym, assign,2];	        4  => -- statement				::= exp	  PushNode[sym, exp,1];	        5  => -- statement				::= exp '?	  PushNode[sym, reps,1];	        6  => -- statement				::= MEMORY interval	  PushNode[sym, memoryInt,1];	        7  => -- statement				::= lhs interval	  PushNode[sym, arrayInt,2];	        8  => -- statement				::= relation	  IF IR.InConditional[h] THEN PushNode[sym, conditionalBreak,1]	  ELSE PushNode[sym, exp,1];	        9  => -- typeexp					::= id	  PushHash[sym, v[top]];	        10  => -- typeid					::= INTEGER	  PushSe[sym, dataPtr.idINT];      11  => -- typeid					::= CARDINAL	  PushSe[sym, dataPtr.idCARDINAL];      12  => -- typeid					::= CHARACTER	  PushSe[sym, dataPtr.idCHAR];      13  => -- typeid					::= BOOLEAN	  PushSe[sym, dataPtr.idBOOL];      14  => -- typeid					::= REAL	  PushSe[sym, dataPtr.idREAL];      15  => -- typeid					::= STRING	  PushSe[sym, dataPtr.idSTRING];      16  => -- typeid					::= UNSPECIFIED	  PushSe[sym, dataPtr.idANY];      17  => -- typeid					::= WORD	  PushSe[sym, dataPtr.idANY];	        18  => -- typeid					::= PROCEDURE	    -- typeid					::= PROC	  BEGIN	  PushTree[sym, Tree.Null]; PushNode[sym, procTC,1];	  END;      19  => -- typeid					::= ERROR	  BEGIN	  PushTree[sym, Tree.Null]; PushNode[sym, errorTC,1];	  END;      20  => -- typeid					::= SIGNAL	  BEGIN	  PushTree[sym, Tree.Null]; PushNode[sym, signalTC,1];	  END;	        21  => -- typeid					::= POINTER	  BEGIN	  PushSe[sym, dataPtr.idANY];	  PushNode[sym, pointerTC,1];	  END;	        22  => -- typeid					::= id . id	  BEGIN	  PushHash[sym, v[top]];  PushHash[sym, v[top+2]];	  PushNode[sym, typeDollar,2];	  END;	        23  => -- typeid					::= id id	  BEGIN	  PushHash[sym, v[top+1]];  PushHash[sym, v[top]];	  PushNode[sym, discrimTC,2];	  END;	        24  => -- typeid					::= id typeid	  BEGIN	  PushHash[sym, v[top]];  PushNode[sym, discrimTC,2];	  END;	        25  => -- typeid					::= id $ id	  BEGIN	  PushHash[sym, v[top]];  PushHash[sym, v[top+2]];	  PushNode[sym, typeDollar,2];	  END;	        26  => -- typecons				::= POINTER TO typeexp	    -- typecons					::= @ typeexp	  PushNode[sym, pointerTC,1];	        27  => -- typecons				::= LONG typeexp	  PushNode[sym, longTC,1];	        28  => -- sum					::= sum addop product	    -- relation					::= sum relationtail 	  PushNode[sym, v[top+1],2];	        29  => -- addop					::= +	  vTop ¬ Tree.NodeName[plus];      30  => -- addop					::= - 	  vTop ¬ Tree.NodeName[minus];	        31  => -- relop					::= = 	  vTop ¬ Tree.NodeName[relE];      32  => -- relop					::= # 	  vTop ¬ Tree.NodeName[relN];      33  => -- relop					::= < 	  vTop ¬ Tree.NodeName[relL];      34  => -- relop					::= <= 	  vTop ¬ Tree.NodeName[relLE];      35  => -- relop					::= > 	  vTop ¬ Tree.NodeName[relG];      36  => -- relop					::= >= 	  vTop ¬ Tree.NodeName[relGE];	        37  => -- product					::= product multop factor 	  PushNode[sym, v[top+1],2];	        38  => -- multop					::= * 	  vTop ¬ Tree.NodeName[times];      39  => -- multop					::= / 	  vTop ¬ Tree.NodeName[div];      40  => -- multop					::= MOD 	  vTop ¬ Tree.NodeName[mod];	        41  => -- factor					::= - primary 	  PushNode[sym, uminus,1];	        42  => -- primary					::= num	  BEGIN	  PushLit[sym, v[top]];  PushNode[sym, int,1]	  END;	        43  => -- primary					::= lnum 	  BEGIN	  PushLit[sym, v[top]];  PushNode[sym, mwconst,1];	  PushNode[sym, lint,1];	  END;	        44  => -- primary					::= card	  BEGIN	  PushLit[sym, v[top]];  PushNode[sym, card,1];	  END;	        45  => -- primary					::= lcard 	  BEGIN	  PushLit[sym, v[top]];  PushNode[sym, mwconst,1];	  PushNode[sym, lcard,1];	  END;	        46  => -- primary					::= char	  BEGIN	  PushLit[sym, v[top]];  PushNode[sym, clit,1];	  END;	        47  => -- primary					::= string 	  PushStringLit[sym, v[top]];	        48  => -- primary					::= NIL	  BEGIN	  PushTree[sym, Tree.Null]; PushNode[sym, nil,1];	  END;	        49  => -- primary					::= NIL [ typeexp ]	  PushNode[sym, nil,1];	        50  => -- primary					::= prefixop [ explist ] 	  BEGIN	  PushList[sym, v[top+2]];  PushNode[sym, v[top],1];	  END;	        51  => -- primary					::= typeop [ typeexp ] 	  PushNode[sym, v[top],1];	        52  => -- primary 					::= @ lhs	  PushNode[sym, addr,1];	        53  => -- primary					::= DESCRIPTOR [ desclist ] 	  PushNode[sym, arraydesc,1];	        54  => -- primary					::= primary %	  BEGIN	  PushTree[sym, Tree.Null]; PushNode[sym, loophole,2];	  END;	        55  => -- primary					::= primary % ( typeexp )	  PushNode[sym, loophole,2];	        56  => -- lhs					::= id 	  PushHash[sym, v[top]];	        57  => -- lhs					::= LOOPHOLE [ exp ]  	  BEGIN	  PushTree[sym, Tree.Null]; PushNode[sym, loophole,2];	  END;	        58  => -- lhs					::= LOOPHOLE [ exp , typeexp ]  	  PushNode[sym, loophole,2];	        59  => -- lhs					::= MEMORY [ exp ] 	  PushNode[sym, memory,1];	        60  => -- lhs					::= id $ id 	  BEGIN	-- go to file named by first id to lookup second id 	  PushHash[sym, v[top]];  PushHash[sym, v[top+2]];	  PushNode[sym, fileDollar,2];	  END;	        61  => -- lhs					::= lnum $ id 	  BEGIN	-- go to frame named by first id to lookup second id 	  PushLit[sym, v[top]];  PushHash[sym, v[top+2]];	  PushNode[sym, frameDollar,2];	  END;	        62  => -- qualifier					::= [ explist ]	  BEGIN	  PushList[sym, v[top+1]]; PushNode[sym, apply,2];	  END;	        63  => -- qualifier					::= . id 	  BEGIN	  PushHash[sym, v[top+1]];  PushNode[sym, dot,2];	  END;	        64  => -- qualifier					::= ^ 	  PushNode[sym, uparrow,1];	        65  => -- prefixop					::= LONG 	  vTop ¬ Tree.NodeName[lengthen];      66  => -- prefixop					::= ABS 	  vTop ¬ Tree.NodeName[abs];      67  => -- prefixop					::= MIN 	  vTop ¬ Tree.NodeName[min];      68  => -- prefixop					::= MAX 	  vTop ¬ Tree.NodeName[max];      69  => -- prefixop					::= BASE 	  vTop ¬ Tree.NodeName[base];      70  => -- prefixop					::= LENGTH 	  vTop ¬ Tree.NodeName[length];	        71  => -- typeop					::= SIZE 	  vTop ¬ Tree.NodeName[size];      72  => -- typeop					::= FIRST 	  vTop ¬ Tree.NodeName[first];      73  => -- typeop					::= LAST 	  vTop ¬ Tree.NodeName[last];	        74  => -- interval					::= [ bounds ]	  PushNode[sym, intCC,1];      75  => -- interval					::= [ bounds )	  PushNode[sym, intCO,1];      76  => -- interval					::= ( bounds ]	  PushNode[sym, intOC,1];      77  => -- interval					::= ( bounds )	  PushNode[sym, intOO,1];      78  => -- interval					::= [ exp ! exp ]	  BEGIN	  PushList[sym, 2];  PushNode[sym, bang,1];	  END;	        79  => -- bounds					::= exp .. exp	  PushList[sym, 2];	        80  => -- desclist					::= exp , exp 	  BEGIN	  PushTree[sym, Tree.Null];  PushList[sym, 3];	  END;	        81  => -- desclist					::= exp , exp , typeexp 	  PushList[sym, 3];	        82  => -- typeexp					::= typeid	    -- typeexp					::= typecons	    -- typeexp					::= typeextractor	    -- desclist					::= exp 	    -- exp					::= sum	    -- sum					::= product	    -- product					::= factor	    -- factor					::= primary 	    -- primary					::= lhs	    -- lhs					::= ( exp )  	    -- lhs					::= lhs qualifier 	    -- relationtail				::= relop sum 	  NULL;	        83  => -- explist					::= exp	    -- statementlist				::= statement	  vTop ¬ 1;	        84  => -- explist					::= explist , exp	  vTop ¬ v[top]+1;	        85  => -- explist					::= 	  vTop ¬ 0;  -- empty expression list	        86  => -- typeextractor				::= TYPE [ exp ]	    -- typeextractor				::= & exp	  PushNode[sym, typecode,1];	        87  => -- primary					::= flnum	  BEGIN	  PushLit[sym, v[top]];  PushNode[sym, mwconst,1];	  PushNode[sym, spareS3,1];	  END;      	            88  => -- typeid					::= lnum $ id	  BEGIN	  PushLit[sym, v[top]];  PushHash[sym, v[top+2]];	  PushNode[sym, frameDollar,2];	  END;     	      	        ENDCASE => SIGNAL IO.ParseError[l[top]]; -- error or unimplemented            v[top] ¬ vTop;    ENDLOOP;    RETURN    END;      END.
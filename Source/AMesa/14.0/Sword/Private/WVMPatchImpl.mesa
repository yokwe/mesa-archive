-- Copyright (C) 1986  by Xerox Corporation. All rights reserved. -- WVMPatchImpl.MesaDIRECTORY  CPSwapDefs USING [PatchTable, PatchTableEntry],  Environment USING [Byte, PageFromLongPointer],  Mopcodes USING [op, zBRK],  PageMap USING [Flags, ExchangeFlags, flagsVacant, flagsDirtyReferenced],  PrincOps USING [BYTE, InstWord],  ProcessOperations,  SpecialSpace,  WorldVM USING [LocalWorld, World, WorldObject],  WorldVMOps USING [Address, AddressFault, BYTE, BytePC, CopyRead, CopyWrite, NullProcess, PrefixHandle, Process, Read, SpecialWrite, SwappedIn, World, Write],  WVMPatch USING [],  WVMPrivate USING [WorldObject];WVMPatchImpl: PROGRAM  IMPORTS Environment, PageMap, WorldVMOps, WorldVM, SpecialSpace, ProcessOperations  EXPORTS WorldVMOps, WorldVM, WVMPatch   SHARES PageMap = {    BYTE: TYPE = WorldVMOps.BYTE;  BytePC: TYPE = WorldVMOps.BytePC;  Process: TYPE = WorldVMOps.Process;  NullProcess: Process = WorldVMOps.NullProcess;  Address: TYPE = WorldVMOps.Address;  PrefixHandle: TYPE = WorldVMOps.PrefixHandle;  World: TYPE = LONG POINTER TO WorldObject;  WorldObject: PUBLIC TYPE = WVMPrivate.WorldObject;  local: WorldVM.World ¬ WorldVM.LocalWorld[];  NotPatched: PUBLIC SIGNAL = CODE;  PatchTableFull: PUBLIC ERROR = CODE;  IllegalPatch: PUBLIC ERROR = CODE;  AlreadySet: PUBLIC SIGNAL = CODE;  AlreadyClear: PUBLIC SIGNAL  = CODE;      SetBreak: PUBLIC PROC[world: World, addr: Address, offset: BytePC, process: Process ¬ NullProcess] RETURNS [oldByte: Environment.Byte] = {    oldByte ¬ Patch[world, addr, offset, Mopcodes.zBRK];    IF oldByte = Mopcodes.zBRK THEN SIGNAL AlreadySet };      ClearBreak: PUBLIC PROC[world: World, addr: Address, offset: BytePC, oldByte: Environment.Byte, process: Process ¬ NullProcess] = {    brk: Mopcodes.op = Patch[world, addr, offset, oldByte];    IF brk # Mopcodes.zBRK THEN SIGNAL AlreadyClear };       ReadCodeByte: PUBLIC PROC[world: World, cb: PrefixHandle, pc: BytePC, process: Process ¬ NullProcess] RETURNS [BYTE] = {    iword: PrincOps.InstWord = ReadCodeWord[world, cb, pc/2];    RETURN[IF pc MOD 2 = 0 THEN iword.evenbyte ELSE iword.oddbyte]};    ReadCodeWord: PUBLIC PROC[world: World, cb: PrefixHandle, offset: INTEGER, process: Process ¬ NullProcess] RETURNS [UNSPECIFIED] = {    lpc: Address;    iword: PrincOps.InstWord;    patched: BOOLEAN;    pti: CARDINAL;    lpc ¬ cb + offset;    [patched, pti] ¬ CheckPatchTable[world, lpc];    IF patched THEN iword ¬ ReadPatchTableEntry[world, world.esv.patchTable, pti].value    ELSE iword ¬ WorldVMOps.Read[world, lpc];    RETURN[iword] };      WriteCodeByte: PUBLIC PROC[world: World, cb: PrefixHandle, pc: BytePC, op: BYTE, process: Process ¬ NullProcess] = {    [] ¬ Patch[world, cb, pc, op] };    Patch: PUBLIC PROC[world: World, addr: Address, pc: BytePC, op: BYTE] RETURNS [oldByte: BYTE] = {    codeAddr: Address = addr + pc/2;    patched: BOOLEAN;    iword: PrincOps.InstWord;    otherByte: BYTE;    pti: CARDINAL;    patchTable: LONG POINTER TO CPSwapDefs.PatchTable = world.esv.patchTable;    ptlength: CARDINAL = WorldVMOps.Read[world, @patchTable.length];    [patched, pti] ¬ CheckPatchTable[world, codeAddr];    iword ¬ WorldVMOps.Read[world, codeAddr ! WorldVMOps.AddressFault => REJECT --ERROR IllegalPatch-- ];    IF (pc MOD 2) = 0 THEN { oldByte ¬ iword.evenbyte; iword.evenbyte ¬ op; otherByte ¬ iword.oddbyte }     ELSE { oldByte ¬ iword.oddbyte; iword.oddbyte ¬ op; otherByte ¬ iword.evenbyte };    IF (op = Mopcodes.zBRK) THEN { -- add a patch entry      IF patched THEN WritePatchTableEntry[world, patchTable, pti, [codeAddr, iword]]      ELSE {	ptmaxlength: CARDINAL = WorldVMOps.Read[world, @patchTable.maxlength];	IF ptlength = ptmaxlength THEN ERROR PatchTableFull;	WorldVMOps.Write[world, @patchTable.length, ptlength+1];	WritePatchTableEntry[world, patchTable, ptlength, [codeAddr, iword]] }}    ELSE { -- remove an existing patch entry      IF patched THEN {        IF (otherByte = Mopcodes.zBRK) THEN WritePatchTableEntry[world, patchTable, pti, [codeAddr, iword]]	ELSE {	  WorldVMOps.Write[world, @patchTable.length, ptlength-1]; 	  FOR pti IN [pti..ptlength-1) DO	    WritePatchTableEntry[world, patchTable, pti, ReadPatchTableEntry[world, patchTable, pti+1]];	    ENDLOOP }}      ELSE SIGNAL NotPatched };    IF world # local THEN {       IF WorldVMOps.SwappedIn[world, codeAddr] THEN WorldVMOps.SpecialWrite[world, codeAddr, iword] }    ELSE {      «To be sure the patch is applied first swap it out. When next swapped in the patch will be applied. Works for all but resident code.      Space.MakeWritable[[codeAddr, 1]]; Space.Kill[[codeAddr, 1]]; Space.MakeReadOnly[[codeAddr, 1]];»      AtomicWrite[codeAddr, iword] }};        AtomicWrite: PROC[codeAddr: Address, iword: PrincOps.InstWord] = {    -- If swapped in then munge readonly flag and do write. Interrupts should be disabled around this piece of code.    flagsPrev: PageMap.Flags;    SpecialSpace.MakeProcedureResident[LOOPHOLE[AtomicWrite] ! SpecialSpace.SpecialError => IF error = alreadyResident THEN CONTINUE];    SpecialSpace.MakeGlobalFrameResident[WVMPatchImpl ! SpecialSpace.SpecialError => IF error = alreadyResident THEN CONTINUE];    ProcessOperations.DisableInterrupts[];    flagsPrev ¬ PageMap.ExchangeFlags[Environment.PageFromLongPointer[codeAddr], PageMap.flagsDirtyReferenced].oldState.flags;    IF flagsPrev # PageMap.flagsVacant THEN {      IF flagsPrev.readonly THEN LOOPHOLE[codeAddr, LONG POINTER TO PrincOps.InstWord]­ ¬ iword       ELSE NULL «ERROR» };    [] ¬ PageMap.ExchangeFlags[Environment.PageFromLongPointer[codeAddr], flagsPrev];    ProcessOperations.EnableInterrupts[];    SpecialSpace.MakeGlobalFrameSwappable[WVMPatchImpl ! SpecialSpace.SpecialError => IF error = alreadySwappable THEN CONTINUE];    SpecialSpace.MakeProcedureSwappable[LOOPHOLE[AtomicWrite] ! SpecialSpace.SpecialError => IF error = alreadySwappable THEN CONTINUE] };        ReadPatchTableEntry: PROC[world: World, pt: LONG POINTER TO CPSwapDefs.PatchTable, pti: CARDINAL] RETURNS [pte: CPSwapDefs.PatchTableEntry] = INLINE {    WorldVMOps.CopyRead[world: world, from: @pt.entries[pti], to: @pte, nwords: SIZE[CPSwapDefs.PatchTableEntry]]};  WritePatchTableEntry: PROC[world: World, pt: LONG POINTER TO CPSwapDefs.PatchTable, pti: CARDINAL, pte: CPSwapDefs.PatchTableEntry] = INLINE {    WorldVMOps.CopyWrite[world: world, to: @pt.entries[pti], from: @pte, nwords: SIZE[CPSwapDefs.PatchTableEntry]]};        CheckPatchTable: PROC[world: World, addr: Address] RETURNS [found: BOOLEAN, pti: CARDINAL] = {    pt: LONG POINTER TO CPSwapDefs.PatchTable ¬ world.esv.patchTable;    ptlength: CARDINAL = WorldVMOps.Read[world, @pt.length];    FOR pti: CARDINAL IN [0..ptlength) DO      pte: CPSwapDefs.PatchTableEntry ¬ ReadPatchTableEntry[world, pt, pti];      IF pte.address = addr THEN RETURN[TRUE, pti];      ENDLOOP;    RETURN[FALSE, 0] };  }.
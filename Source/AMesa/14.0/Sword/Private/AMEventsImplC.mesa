-- File: AMEventsImplC.mesa - last edit:-- Litman              22-Oct-87 13:47:48-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.-- conditional breakpointsDIRECTORYAMEventsBackdoor, CPSwapDefs, Inline,Mopcodes,  PrincOps USING [LocalFrameHandle, BytePC, StateVector, PrefixHandle, FieldDescriptor], PSB USING [PDA],RuntimeInternal;AMEventsImplC: PROGRAM   IMPORTS RuntimeInternal, Inline  EXPORTS AMEventsBackdoor = {    swapInfoAddr: LONG POINTER TO CPSwapDefs.SwapInfo =    LOOPHOLE[@PSB.PDA.available];  ConditionTrue: PUBLIC PROC[lFrame: PrincOps.LocalFrameHandle,    codeBase: PrincOps.PrefixHandle, pc: PrincOps.BytePC,     sv: POINTER TO dst PrincOps.StateVector]     RETURNS[BOOLEAN] = {    esvAddr: LONG POINTER TO CPSwapDefs.ExternalStateVector =       (swapInfoAddr­.externalStateVector);    FOR k: CARDINAL IN [0..esvAddr.breakBlocks.length) DO      breakBlock: LONG POINTER TO CPSwapDefs.UserBreakBlock =        @esvAddr.breakBlocks.blocks[k];      IF breakBlock.codeBase = codeBase AND breakBlock.pc = pc       THEN RETURN[ConditionSatisfied[breakBlock, lFrame, sv]];      REPEAT FINISHED => RETURN[TRUE];      ENDLOOP};    ConditionSatisfied: PROC [    breakBlock: CPSwapDefs.UBBPointer, lFrame: PrincOps.LocalFrameHandle,    state: POINTER TO dst PrincOps.StateVector]    RETURNS [BOOLEAN] =  --out-of-line--    -- Returns TRUE if the breakpoint's condition is satisfied.    -- NOTE: This procedure is out-of-line    -- because the resident code is smaller that way.    BEGIN    leftOperand: LONG CARDINAL =      GetOperand[@breakBlock.leftOperand, lFrame, state];    rightOperand: LONG CARDINAL =      GetOperand[@breakBlock.rightOperand, lFrame, state];    RETURN[      SELECT breakBlock.relation FROM        eq => leftOperand = rightOperand,        ge => leftOperand >= rightOperand,        gt => leftOperand > rightOperand,        le => leftOperand <= rightOperand,        lt => leftOperand < rightOperand,	ne => leftOperand # rightOperand,	ENDCASE => MyBugValue[funnyCase]];    END;  --ConditionSatisfied--        BugType: TYPE = {badFieldSize, funnyCase, notImplemented};  MyBug: PROC [type: BugType] = {RuntimeInternal.Bug[type]};  MyBugValue: PROC [type: BugType] RETURNS [UNSPECIFIED] =    {MyBug[type]; RETURN[0]};  MyBugLongValue: PROC [type: BugType] RETURNS [LONG UNSPECIFIED] =    {MyBug[type]; RETURN[0]};  GetOperand: PUBLIC --RuntimeInternal.-- PROC [    opDesc: LONG POINTER TO CPSwapDefs.OperandDesc,    lFrame: PrincOps.LocalFrameHandle,    state: POINTER TO dst PrincOps.StateVector]    RETURNS [opVal: LONG CARDINAL] =    BEGIN    PS: TYPE = POINTER TO CPSwapDefs.ShortOrLong;    PPS: TYPE = POINTER TO PS;    PLPS: TYPE = POINTER TO LONG POINTER TO CPSwapDefs.ShortOrLong;    IF opDesc.fieldSize = 32 THEN      BEGIN  -- long operand      RETURN[WITH op: opDesc SELECT FROM	counter => op.timesSoFar ¬ op.timesSoFar.SUCC, 	immediate => op.value,	localVariable => LOOPHOLE[@lFrame[op.index], PS].long,	stack => LOOPHOLE[@state.stk[op.index], PS].long,	memory => op.address.long,	localIndirect => (LOOPHOLE[@lFrame[op.index], PLPS]­+op.offset).long,	localIndirectShort => (LOOPHOLE[@lFrame[op.index], PPS]­+op.offset).long,	stackIndirect => (LOOPHOLE[@state.stk[op.index], PLPS]­+op.offset).long,	stackIndirectShort => (LOOPHOLE[@state.stk[op.index], PPS]­+op.offset).long,	memoryIndirect => (op.addressOfPointer­+op.offset).long,	memoryIndirectShort => (op.addressOfPointer­+op.offset).long,	ENDCASE => MyBugLongValue[funnyCase]	];      END    ELSE      BEGIN  -- short operand      ReadField: PROC [LONG POINTER TO CARDINAL, PrincOps.FieldDescriptor]	RETURNS [CARDINAL] = MACHINE CODE {Mopcodes.zRLFS};      shortVal: CARDINAL ¬ WITH op: opDesc SELECT FROM	counter => Inline.LowHalf[op.timesSoFar ¬ op.timesSoFar.SUCC],	immediate => Inline.LowHalf[op.value],	localVariable => lFrame[op.index],	stack => state.stk[op.index],	memory => op.address.short,	localIndirect => (LOOPHOLE[@lFrame[op.index], PLPS]­+op.offset).short,	localIndirectShort => (LOOPHOLE[@lFrame[op.index], PPS]­+op.offset).short,	stackIndirect => (LOOPHOLE[@state.stk[op.index], PLPS]­+op.offset).short,	stackIndirectShort => (LOOPHOLE[@state.stk[op.index], PPS]­+op.offset).short,	memoryIndirect => (op.addressOfPointer­+op.offset).short,	memoryIndirectShort => (op.addressOfPointer­+op.offset).short,	ENDCASE => MyBugValue[funnyCase];      IF opDesc.fieldSize > 16 THEN MyBug[badFieldSize];      RETURN[LONG[ReadField[@shortVal,	[offset: 0, posn: opDesc.fieldPosition, size: opDesc.fieldSize]]]];      END;    END; --GetOperand--  }..
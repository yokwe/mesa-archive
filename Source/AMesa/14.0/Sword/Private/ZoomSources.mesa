-- Copyright (C) 1985  by Xerox Corporation. All rights reserved. -- File: ZoomSources.mesa - last edited by:-- Riggle	 17-Sep-85 11:46:05DIRECTORY  Ascii,  ByteBlt,  Context,  Environment,  Heap,  Inline,  Selection,  String,  TextDisplay USING [LineTable, Update],  TextSource,  --TextSW,  TextSWOps USING [TSWContext, textSWContext],  Window USING [Handle],  ZoomSource;ZoomSources: MONITOR LOCKS zoom­.lock USING zoom: ZoomHandle   IMPORTS ByteBlt, Context, Heap, Inline,      Selection, String, TextDisplay, TextSource, --TextSW,--    TextSWOps  EXPORTS ZoomSource = {    «    Data Structure: doubly linked circular list.    There is always at least one element in the list, the first line in the file.    It may be of zero length, however.        Visibility Theory: given a line, succeeding lines are "below" it if they     are indented    a greater amount.  The first "level" below a given line A     is defined to be that set of lines    indented less or equally to the     first line below A.  If there are no lines below A as defined    in the     first sentence above, then there are no "levels" below A.  These     definitions apply    recursively to all lines.        Practical Exceptions: The first and last lines of the source are always     visible.  No    logical reasons, it just makes the code easier.  The      first line of the source is considered    to be indented less than any      other line regardless of its "true" indentation.»  bufferGrowIncrement: CARDINAL = 16;    -- line lengths are multiples of bufferGrowIncrement.      -- Should be an even number       sz: UNCOUNTED ZONE = Heap.systemZone;    Line: TYPE = LONG POINTER TO LineObject;  LineObject: TYPE = RECORD [    buffer: ZoomSource.Buffer ¬ NIL,     indentLevel: INTEGER ¬ 0,    next, prev: Line ¬ NIL,     vnext, vprev: Line ¬ NIL];    ZoomHandle: TYPE = LONG POINTER TO ZoomSourceObject;  ZoomSourceObject: TYPE = RECORD [    procs: TextSource.Procedures ¬ @zoomProcs,    z: UNCOUNTED ZONE ¬ NIL,    currentLine: Line ¬ NIL,    empty: BOOLEAN ¬ TRUE,    vStartOfCurrentLine: TextSource.Position ¬ 0,    firstLine: Line ¬ NIL,    freeLines: Line ¬ NIL,    veof: TextSource.Position ¬ 0, -- viewed eof    lock: MONITORLOCK,    first, next: ZoomSource.OpenProc ¬ NIL,     close, destroy: ZoomSource.CloseProc ¬ NIL];  zoomProcs: TextSource.ProceduresObject ¬ [    actOn: ActOnZoom, doEditAction: TextSource.AsciiDoEditAction,    getLength: GetZoomLength, readText: ReadZoomText,    replaceText: ReplaceZoomText, scanText: ScanZoomText,    setLength: SetZoomLength];      ZtoS: PROC[zoom: ZoomHandle] RETURNS[TextSource.Handle] = INLINE {    RETURN[LOOPHOLE[zoom]]};  StoZ: PROC[source: TextSource.Handle] RETURNS[ZoomHandle] = INLINE {    RETURN[LOOPHOLE[source]]};  -- Zoom Source Creation & Loading routines  Create: PUBLIC PROCEDURE [first, next: ZoomSource.OpenProc,      close, destroy: ZoomSource.CloseProc, zone: UNCOUNTED ZONE]    RETURNS [source: TextSource.Handle] = {    LockedCreate: ENTRY PROC [zoom: ZoomHandle] = {      StringHolder: TYPE = RECORD[s: LONG STRING];      string: LONG STRING ¬ String.MakeString[sz, 0];      zoom.currentLine ¬ zoom.firstLine ¬ MakeLine[zoom];      zoom.firstLine.buffer ¬ zone.NEW[LONG STRING ¬ string];      --String.AppendChar[string, Ascii.CR];      zoom.veof ¬ 0 --1--};    zoom: ZoomHandle;    zoom ¬ zone.NEW[ZoomSourceObject ¬ [first: first, next: next, close: close,      destroy: destroy]];    zoom.z ¬ zone;    LockedCreate[zoom];    RETURN[ZtoS[zoom]]};    Indent: INTERNAL PROCEDURE [zoom: ZoomHandle, l: Line]     RETURNS [indent: INTEGER ¬ 0] = {    -- calculate the indent level of a line    -- blank lines are considered at the same indent level as their parents    -- first line is -1 indent by definition    -- IF l = zoom.firstLine THEN RETURN [-1];     FOR i: CARDINAL IN [0..l.buffer.length) DO      SELECT l.buffer[i] FROM        '  => indent ¬ indent + 1;  	'\t => indent ¬ indent + Tabs[i];        '\n => RETURN[MAX[l.prev.indentLevel, 0]];        ENDCASE => EXIT;      ENDLOOP};    NewIndent: INTERNAL PROCEDURE [zoom: ZoomHandle, l: Line] = {    -- calculate the indent level of a line    -- propagates indent changes through to blank lines that follow    i: INTEGER;    WHILE (i ¬ Indent[zoom, l]) # l.indentLevel DO      l.indentLevel ¬ i;      l ¬ l.next;      ENDLOOP};    Tabs: PROCEDURE [column: CARDINAL] RETURNS [CARDINAL] = INLINE {    RETURN [8 - column MOD 8]};      EnumerateBuffers: PUBLIC PROC[source: TextSource.Handle,     proc: ZoomSource.EnumProc] = {    zoom: ZoomHandle = StoZ[source];    first, last: TextSource.Position ¬ 0;     line: Line ¬ zoom.firstLine;    IF ~IsIt[source] THEN RETURN;    DO      last ¬ first+line.buffer.length-1;      IF proc[line.buffer, first, last] THEN EXIT;       line ¬ line.next;      IF line = zoom.firstLine THEN EXIT;      first ¬ last+1;      ENDLOOP};    -- Zoom Source Interface routines   CleanUp: PROCEDURE [zoom: ZoomHandle] = {    -- destroy zoomsource    -- interesting paradox:  zoom can't be freed if this is an ENTRY PROC!!!    zone: UNCOUNTED ZONE = zoom.z;    line, next: Line;    line ¬ zoom.firstLine;    UNTIL line = NIL DO      next ¬ line.next;      zoom.close[line.buffer];      zone.FREE[@line];      line ¬ next;      IF line = zoom.firstLine THEN EXIT;      ENDLOOP;    line ¬ zoom.freeLines;    UNTIL line = NIL DO      next ¬ line.next;      zone.FREE[@line];      line ¬ next;      IF line = zoom.freeLines THEN EXIT;      ENDLOOP;    zone.FREE[@zoom]};  IsIt: PUBLIC PROCEDURE [source: TextSource.Handle] RETURNS [BOOLEAN] = {    RETURN[source # NIL AND source­ = @zoomProcs]};  Destroy: PUBLIC PROCEDURE [source: TextSource.Handle] = {    -- destroys source    zoom: ZoomHandle = StoZ[source];    IF ~IsIt[source] THEN RETURN;    CleanUp[zoom]};  ActOnZoom: PROCEDURE [source: TextSource.Handle, action: TextSource.Action] = {    zoom: ZoomHandle = StoZ[source];    SELECT action FROM      destroy => CleanUp[zoom];      mark => NULL;      sleep => NULL;      truncate => NULL;      wakeup => NULL;      ENDCASE => ERROR};    GetZoomLength: PROCEDURE [source: TextSource.Handle]    RETURNS [TextSource.Position] = {    zoom: ZoomHandle = StoZ[source];    RETURN [LockedGetZoomLength[zoom]]};    LockedGetZoomLength: ENTRY PROCEDURE [zoom: ZoomHandle]    RETURNS [TextSource.Position] = {    RETURN [zoom.veof]};      SetZoomLength: PROCEDURE [source: TextSource.Handle,     position: TextSource.Position]    RETURNS [TextSource.Position] = {    zoom: ZoomHandle = StoZ[source];    RETURN [LockedSetZoomLength[zoom, position]]};    LockedSetZoomLength: ENTRY PROCEDURE [zoom: ZoomHandle,     position: TextSource.Position]    RETURNS [TextSource.Position] = {    -- truncates source    line: Line;    index: CARDINAL;    IF position > zoom.veof THEN      position ¬ IF zoom.veof > 0 THEN zoom.veof - 1 ELSE zoom.veof;    line ¬ LineFromPosition[zoom, position];    index ¬ Inline.LowHalf[position - zoom.vStartOfCurrentLine];    zoom.veof ¬ zoom.veof + DoReplaceText[zoom, line, zoom.firstLine.prev,       index, zoom.firstLine.prev.buffer.length, FALSE, [NIL, 0, 0]];    RETURN [zoom.veof]};    -- The heart of the source    LineFromPosition: INTERNAL PROCEDURE [zoom: ZoomHandle,     editPos: TextSource.Position]    RETURNS [line: Line] = {    -- complicated but hopefully speedy way of finding line from position    pos: TextSource.Position;    BEGIN      IF (zoom.firstLine.buffer = NIL OR         editPos IN [0..zoom.firstLine.buffer.length))       THEN { -- on first line	zoom.currentLine ¬ zoom.firstLine;	zoom.vStartOfCurrentLine ¬ 0;	RETURN [zoom.currentLine]};      editPos ¬ MIN[zoom.veof, editPos];       IF editPos IN [zoom.veof - zoom.firstLine.vprev.buffer.length..zoom.veof]       THEN { -- on last line	zoom.currentLine ¬ zoom.firstLine.vprev;	zoom.vStartOfCurrentLine ¬ zoom.veof - zoom.currentLine.buffer.length;	RETURN [zoom.currentLine]};      IF editPos IN        [zoom.vStartOfCurrentLine..        zoom.vStartOfCurrentLine+zoom.currentLine.buffer.length)       THEN RETURN [zoom.currentLine]; -- current line      IF editPos < (pos ¬ zoom.vStartOfCurrentLine) THEN	FOR line ¬ zoom.currentLine.vprev, line.vprev DO -- before current line	  pos ¬ pos - line.buffer.length;	  IF editPos >= pos THEN GOTO done;	  ENDLOOP      ELSE	FOR line ¬ zoom.currentLine, line.vnext DO -- after current line	  pos ¬ pos + line.buffer.length;	  IF editPos < pos THEN GOTO done2; 	  ENDLOOP;    EXITS      done => {	zoom.vStartOfCurrentLine ¬ pos;	zoom.currentLine ¬ line};      done2 => {	zoom.vStartOfCurrentLine ¬ pos - line.buffer.length;	zoom.currentLine ¬ line};    END};    -- Routines to change the visible portions of source.     OpenAll: PUBLIC PROCEDURE [source: TextSource.Handle, sw: Window.Handle,     pos: TextSource.Position] = {    -- make all lines below this line visible    zoom: ZoomHandle = StoZ[source];    IF ~IsIt[source] THEN RETURN;    DoOpen[zoom, sw, pos, TRUE]};  Open: PUBLIC PROCEDURE [source: TextSource.Handle, sw: Window.Handle,     pos: TextSource.Position] = {    -- make lines one level below this line visible    zoom: ZoomHandle = StoZ[source];    IF ~IsIt[source] THEN RETURN;    DoOpen[zoom, sw, pos, FALSE]};    DoOpen: PROCEDURE [zoom: ZoomHandle, sw: Window.Handle,     pos: TextSource.Position, all: BOOLEAN] = {    delta: LONG INTEGER ¬ 0;    -- cant lock this. hope nobody modifies the source!    Locked: ENTRY PROC [zoom: ZoomHandle] = {      line: Line ¬ LineFromPosition[zoom, pos];      pos ¬ zoom.vStartOfCurrentLine+line.buffer.length;      IF (line.next.indentLevel <=  line.indentLevel) THEN {        IF zoom.empty THEN {zoom.z.FREE[@zoom.firstLine.buffer]};	FOR sonBuffer: ZoomSource.Buffer ¬ 	  zoom.first[line.buffer, pos],	  zoom.next[sonBuffer, pos+delta] 	  UNTIL sonBuffer = NIL DO 	  newline: Line;	  IF zoom.empty THEN {newline ¬ zoom.firstLine; zoom.empty ¬ FALSE}	  ELSE newline ¬ MakeLine[zoom];	  newline.buffer ¬ sonBuffer;	  NewIndent[zoom, newline];	  InsertLine[line: newline, after: line]; 	  delta ¬ delta + newline.buffer.length;	  line ¬ newline;	  REPEAT FINISHED => zoom.veof ¬ zoom.veof + delta;	  ENDLOOP}};    Locked[zoom];    --TextSW.Update[sw: sw, from: pos-1, to: pos+delta-1,     --  charsDeleted: FALSE];    --Update[sw, pos, pos+delta, delta]    Update[sw, pos, pos, delta]    };      	      DoClose: PROCEDURE [zoom: ZoomHandle, sw: Window.Handle,     pos: TextSource.Position, all: BOOLEAN] = {    delta: LONG INTEGER ¬ 0;    Locked: ENTRY PROC [zoom: ZoomHandle] = {      line: Line = LineFromPosition[zoom, pos];      from, to: Line;      pos ¬ zoom.vStartOfCurrentLine+line.buffer.length;      from ¬ line.next;      IF from.indentLevel <= line.indentLevel THEN RETURN;      FOR to ¬ from.next, to.next UNTIL to.indentLevel <= line.indentLevel DO        ENDLOOP;      delta ¬ DeleteLines[zoom, from, to];      zoom.veof ¬ zoom.veof + delta};    Locked[zoom];    -- delta is negative.    --TextSW.Update[sw: sw, from: pos-1, to: pos-delta-1,     --  charsDeleted: TRUE];    Update[sw, pos, pos-delta, delta]    };    Close: PUBLIC PROCEDURE [source: TextSource.Handle, sw: Window.Handle,     pos: TextSource.Position] = {    -- close all lines below this line (all the ones indented more)    zoom: ZoomHandle = StoZ[source];    IF ~IsIt[source] THEN RETURN;    DoClose[zoom, sw, pos, FALSE]};        InsertViewedLine: INTERNAL PROCEDURE [zoom: ZoomHandle, prevLine,     l: Line, delete: BOOLEAN] RETURNS [delta: LONG INTEGER ¬ 0] = {    -- insert or deleted a line     -- and return the number of characters inserted or deleted    IF ~delete THEN {      IF l.vprev # l THEN RETURN; -- already viewed       l.vnext ¬ prevLine.vnext;      l.vprev ¬ prevLine;      prevLine.vnext.vprev ¬ l;      prevLine.vnext ¬ l;      delta ¬ l.buffer.length}     ELSE {      IF l.vprev = l THEN RETURN; -- already gone      -- last line must remain visible for editing to work      IF l = zoom.firstLine.prev THEN RETURN;       l.vprev.vnext ¬ l.vnext;      l.vnext.vprev ¬ l.vprev;      delta ¬ -l.buffer.length;      l.vnext ¬ l.vprev ¬ l}}; -- for safety    Update: PROC [sw: Window.Handle, first, last: TextSource.Position,    delta: LONG INTEGER] = {    -- a really spiffo window repainting algorithm stolen from EditUtilImplA    tsw: TextSWOps.TSWContext ¬ Context.Find[TextSWOps.textSWContext, sw];    lt: TextDisplay.LineTable;    realLast: TextSource.Position ¬ MAX[last, first+ABS[delta]];    FOR i: CARDINAL IN [0..tsw.splits.length) DO      lt ¬ tsw.splits[i].lineTable;      FOR j: CARDINAL IN [1..lt.length) DO        IF lt[j].pos # TextSource.nullPosition THEN	  IF lt[j].pos >= first AND lt[j].pos <= realLast THEN 	    lt[j].pos ¬ TextSource.nullPosition -- invalidates the position	  ELSE IF lt[j].pos > last THEN	    lt[j].pos ¬ lt[j].pos + delta        ENDLOOP;      -- FixSelection[tsw.splits[i].source, @tsw.selection, first, delta];      IF realLast <= lt[0].pos THEN {        lt.lastPositionPlusOne ¬ lt.lastPositionPlusOne + delta;        lt[0].pos ¬ lt[0].pos + delta}      ELSE IF first <= lt.lastPositionPlusOne THEN	lt.lastPositionPlusOne ¬ lt.lastPositionPlusOne + delta;      tsw.splits[i].Update[first, last,@tsw.selection, TRUE];    ENDLOOP};      -- Line creation/metamorphosis/destruction routines    MakeLine: INTERNAL PROCEDURE [zoom: ZoomHandle] RETURNS [line: Line] = {    IF (line ¬ zoom.freeLines) # NIL THEN      zoom.freeLines ¬ zoom.freeLines.next    ELSE       line ¬ zoom.z.NEW[LineObject ¬ []];    line.next ¬ line.vnext ¬ line.prev ¬ line.vprev ¬ line;    line.indentLevel ¬ -10; -- something apropriately absurd    line.buffer ¬ NIL};      GrowLine: INTERNAL PROCEDURE [zoom: ZoomHandle, line: Line,     maxlength: CARDINAL] = {    String.ExpandString[s: line.buffer,       longer: maxlength - line.buffer.maxlength, z: zoom.z]};    DestroyLine: INTERNAL PROCEDURE [zoom: ZoomHandle, line: Line] = {    IF line = zoom.firstLine THEN RETURN;    line.next ¬ zoom.freeLines;    zoom.freeLines ¬ line;    zoom.close[line.buffer]};    -- TextSource Read, Scan, and Replace Procedures    ScanZoomText: PROCEDURE [source: TextSource.Handle,     start: TextSource.Position, type: TextSource.ScanType,     direction: TextSource.Direction]    RETURNS [position: TextSource.Position] = {    -- a ScanTextProc that knows how to find lines quickly    zoom: ZoomHandle = StoZ[source];    ImFaster: ENTRY PROCEDURE [zoom: ZoomHandle] = {      line: Line ¬ LineFromPosition[zoom, start];      position ¬ zoom.vStartOfCurrentLine +         (IF direction = left THEN 0 ELSE line.buffer.length)};    IF type = line THEN ImFaster[zoom]    ELSE position ¬ TextSource.AsciiScanText[source, start, type, direction]};    ReadZoomText: PROCEDURE [    source: TextSource.Handle, position: TextSource.Position,     maxLength: CARDINAL, class: TextSource.Class]    RETURNS [block: Environment.Block, next: TextSource.Position] = {    zoom: ZoomHandle = StoZ[source];    [block, next] ¬ LockedReadZoomText[zoom, position, maxLength, class]};    LockedReadZoomText: ENTRY PROCEDURE [    zoom: ZoomHandle, position: TextSource.Position, maxLength: CARDINAL,     class: TextSource.Class]    RETURNS [block: Environment.Block, next: TextSource.Position] = {    line: Line;    index: CARDINAL;    IF position >= zoom.veof THEN RETURN [[NIL, 0, 0], zoom.veof];    line ¬ LineFromPosition[zoom, position];    index ¬ Inline.LowHalf[position - zoom.vStartOfCurrentLine];    block ¬ [blockPointer: LOOPHOLE[@line.buffer.text], startIndex: index,      stopIndexPlusOne: MIN[line.buffer.length, maxLength + index]];    RETURN[block, position + block.stopIndexPlusOne - block.startIndex]};    ReplaceZoomText: TextSource.ReplaceTextProc = {    zoom: ZoomHandle = StoZ[source];    [new, delta] ¬ LockedReplaceZoomText[zoom, block, from, to, deleteToTrashbin];    };  LockedReplaceZoomText: ENTRY PROCEDURE [zoom: ZoomHandle,    block: Environment.Block, from: TextSource.Position, to: TextSource.Position,    deleteToTrashbin: BOOLEAN ¬ TRUE]    RETURNS [new: TextSource.Position, delta: LONG INTEGER] = {    fromLine, toLine: Line;    fromIndex, toIndex: CARDINAL;    IF from > zoom.veof THEN from ¬ zoom.veof;    IF to > zoom.veof THEN to ¬ zoom.veof;    toLine ¬ LineFromPosition[zoom, to];    toIndex ¬ Inline.LowHalf[to - zoom.vStartOfCurrentLine];    fromLine ¬ LineFromPosition[zoom, from]; -- fromLine is currentLine    fromIndex ¬ Inline.LowHalf[from - zoom.vStartOfCurrentLine];    delta ¬ DoReplaceText[zoom, fromLine, toLine, fromIndex, toIndex,      deleteToTrashbin, block];    zoom.veof ¬ zoom.veof + delta; -- zoom.currentLine ¬ zoom.firstLine; ++ set in SplitLine & JoinLastLine instead -- zoom.vStartOfCurrentLine ¬ 0;    new ¬ from + (IF delta < 0 THEN LONG[0] ELSE delta)};    DoReplaceText: INTERNAL PROCEDURE [zoom: ZoomHandle, fromLine, toLine: Line,    fromIndex, toIndex: CARDINAL, deleteToTrashBin: BOOLEAN,     block: Environment.Block]    RETURNS [delta: LONG INTEGER] = {    trash: LONG STRING;    IF fromLine = toLine AND fromIndex = toIndex THEN deleteToTrashBin ¬ FALSE;    IF deleteToTrashBin THEN      trash ¬ SaveTrashedLines[zoom, fromLine, toLine, fromIndex, toIndex];    IF fromLine = toLine THEN { -- intra line       IF BlockContainsCR[block] THEN { -- save rest of line, etc        IF toIndex = toLine.buffer.length 	THEN { -- no rest of line => we must be at eof	  toLine.buffer.length ¬ fromIndex; -- deletion	  [, delta] ¬ Append[zoom, toLine, block, TRUE];	  delta ¬ delta + fromIndex - toIndex}        ELSE {	  toLine ¬ SplitLine[zoom, toLine, toIndex]; -- left half of line	  toLine.buffer.length ¬ fromIndex;	  [toLine, delta] ¬ Append[zoom, toLine, block, FALSE];	  JoinLastLine[zoom, toLine, 0];	  delta ¬ delta + fromIndex - toIndex}}       ELSE { -- over write possible	source, dest: Environment.Block;         inserted: CARDINAL = block.stopIndexPlusOne - block.startIndex;	deleted: CARDINAL = toIndex - fromIndex;	change: INTEGER ¬ inserted - deleted;	IF change + INTEGER[toLine.buffer.length] >	  INTEGER[toLine.buffer.maxlength] 	  THEN -- overflow	  GrowLine[zoom, toLine, CARDINAL[change] + toLine.buffer.length];	source ¬ [LOOPHOLE[@toLine.buffer.text], toIndex, toLine.buffer.length]; 	dest ¬ [LOOPHOLE[@toLine.buffer.text], toIndex+change,	  toLine.buffer.maxlength];	IF change # 0 THEN	  [] ¬ ByteBlt.ByteBlt[to: dest, from: source, overLap: move];	OverWrite[zoom, toLine, fromIndex, block];	toLine.buffer.length ¬ toLine.buffer.length + change;	delta ¬ change}}     ELSE { -- across lines      del: LONG INTEGER;      delta ¬ -(fromLine.buffer.length - fromIndex + toIndex);      fromLine.buffer.length ¬ fromIndex;      delta ¬ delta + DeleteLines[zoom, fromLine.next, toLine];      [toLine, del] ¬ Append[zoom, fromLine, block, FALSE];      JoinLastLine[zoom, toLine, toIndex];      delta ¬ delta + del};    IF deleteToTrashBin     THEN Selection.SetTrashBin[trash, ConvertTrash, ClearTrash]};      OverWrite: INTERNAL PROC [zoom: ZoomHandle, line: Line, index: CARDINAL,    block: Environment.Block] = {    -- room has been made in line for block to be inserted.      -- Bounds checking has already been done, delta calculated etc.    dest: Environment.Block = [LOOPHOLE[@line.buffer.text], index,      line.buffer.maxlength];    [] ¬ ByteBlt.ByteBlt[to: dest, from: block, overLap: move];    NewIndent[zoom, line]};    Append: INTERNAL PROC [zoom: ZoomHandle, line: Line, block: Environment.Block,    atEOF: BOOLEAN]    RETURNS [last: Line, delta: LONG INTEGER ¬ 0] = {    -- append text to line, making new lines as needed    -- returns last line    start: CARDINAL ¬ block.startIndex;    stopPlusOne, change: CARDINAL;    makeALine: BOOLEAN ¬ FALSE; -- start on a fresh line after "line"    WHILE start < block.stopIndexPlusOne DO      stopPlusOne ¬ GetLine[block, start];      IF makeALine       THEN {        l: Line = MakeLine[zoom];	InsertLine[l, line];	line ¬ l;	makeALine ¬ FALSE}       ELSE         IF stopPlusOne - start + line.buffer.length > line.buffer.maxlength 	THEN -- overflow --        GrowLine[zoom, line, stopPlusOne - start + line.buffer.length];      change ¬ ByteBlt.ByteBlt[        to: [LOOPHOLE[@line.buffer.text], 	  line.buffer.length, line.buffer.maxlength],	from: [block.blockPointer, start, stopPlusOne],	overLap: move];      delta ¬ delta + change;      line.buffer.length ¬ line.buffer.length + change;      NewIndent[zoom, line];      makeALine ¬ line.buffer[line.buffer.length-1] = '\n         AND (stopPlusOne # block.stopIndexPlusOne OR atEOF);      start ¬ stopPlusOne;      ENDLOOP;    IF makeALine THEN { -- blank line at EOF      l: Line = MakeLine[zoom];      InsertLine[l, line];      line ¬ l};    RETURN [line, delta]};  GetLine: PROC [block: Environment.Block, start: CARDINAL]     RETURNS [i: CARDINAL] = {    -- scans a block starting at start for a CR.      -- returns position one past CR, or end of block if no CR found    c: LONG POINTER TO PACKED ARRAY OF CHARACTER = LOOPHOLE[block.blockPointer];    FOR i IN [start..block.stopIndexPlusOne) DO      IF c[i] = '\n THEN RETURN [i+1];    ENDLOOP;    RETURN [block.stopIndexPlusOne]};    BlockContainsCR: PROC [block: Environment.Block] RETURNS [BOOLEAN] = {    c: LONG POINTER TO PACKED ARRAY OF CHARACTER = LOOPHOLE[block.blockPointer];    FOR i: CARDINAL IN [block.startIndex..block.stopIndexPlusOne) DO      IF c[i] = '\n THEN RETURN [TRUE];      REPEAT FINISHED => RETURN [FALSE];      ENDLOOP};    SplitLine: INTERNAL PROC [zoom: ZoomHandle, line: Line, index: CARDINAL]    RETURNS [Line] = {    -- saves rest of line in a new buffer and inserts it after line.    -- guaranteed by caller that rest of line not empty    -- returns line containing left half of split buffer    l: Line = MakeLine[zoom];    dest: Environment.Block = [LOOPHOLE[@l.buffer.text], 0, l.buffer.maxlength];    source: Environment.Block = [LOOPHOLE[@line.buffer.text], index,       line.buffer.length];    IF index = 0 THEN { -- tricky stuff!      InsertLine[l, line.vprev];      IF line = zoom.firstLine THEN zoom.firstLine ¬ l;      IF line = zoom.currentLine THEN zoom.currentLine ¬ l;      RETURN [l]};    [] ¬ ByteBlt.ByteBlt[to: dest, from: source, overLap: move];    l.buffer.length ¬ line.buffer.length - index;    line.buffer.length ¬ index;    InsertLine[l, line];    RETURN [line]};    JoinLastLine: INTERNAL PROC [zoom: ZoomHandle, line: Line, index: CARDINAL] = {    -- join line to line.next starting at index in line.next    -- if last char in line is a CR, left justify line.next instead    -- calculate indent of line.next    next: Line ¬ line.next;    Justify: PROC[] = {      IF index > 0 THEN {        dest: Environment.Block = 	  [LOOPHOLE[@next.buffer.text], 0, next.buffer.maxlength];        source: Environment.Block = 	  [LOOPHOLE[@next.buffer.text], index, next.buffer.length];	[] ¬ ByteBlt.ByteBlt[to: dest, from: source, overLap: move];	next.buffer.length ¬ next.buffer.length - index}};    IF line.buffer.length = 0 THEN { -- he's empty. guaranteed to be a next line      IF line = zoom.firstLine THEN zoom.firstLine ¬ next;      IF line = zoom.currentLine THEN zoom.currentLine ¬ next;      [] ¬ DeleteLines[zoom, line, line.next];      Justify[]}     ELSE       IF line.buffer[line.buffer.length-1] = '\n THEN Justify[]      ELSE {	dest, source: Environment.Block;	IF (next.buffer.length - index + line.buffer.length >	  line.buffer.maxlength) 	THEN -- overflow	  GrowLine[zoom, line, next.buffer.length - index + line.buffer.length];	dest ¬ [LOOPHOLE[@line.buffer.text], line.buffer.length,	  line.buffer.maxlength];	source ¬ [LOOPHOLE[@next.buffer.text], index, next.buffer.length];	line.buffer.length ¬ line.buffer.length + 	  ByteBlt.ByteBlt[to: dest, from: source, 	  overLap: move];	[] ¬ DeleteLines[zoom, next, next.next];	next ¬ line};    NewIndent[zoom, next]};    -- Utilities    DeleteLines: INTERNAL PROCEDURE [zoom: ZoomHandle, fromLine, toLine: Line]    RETURNS [delta: LONG INTEGER ¬ 0] = {    -- delete the lines [fromLine..toLine)    -- return real and visible characters deleted    next: Line;    FOR l: Line ¬ fromLine, next UNTIL l = toLine DO      next ¬ l.next;      IF l.vprev # l THEN delta ¬ delta - l.buffer.length; -- it is visible      l.prev.next ¬ l.next;      l.next.prev ¬ l.prev;      l.vprev.vnext ¬ l.vnext;      l.vnext.vprev ¬ l.vprev;      DestroyLine[zoom, l];    ENDLOOP};    InsertLine: INTERNAL PROCEDURE [line, after: Line] = {    -- insert a line after the given line    line.next ¬ after.next;    line.vnext ¬ after.vnext;    after.next.prev ¬ line;    after.vnext.vprev ¬ line;    line.prev ¬ after;    line.vprev ¬ after;    after.next ¬ line;    after.vnext ¬ line};    -- Trash Bin routines    SaveTrashedLines: INTERNAL PROCEDURE [zoom: ZoomHandle, fromLine, toLine: Line,    fromIndex, toIndex: CARDINAL]    RETURNS [trash: LONG STRING] = {    -- count up length    trashLength: CARDINAL ¬ 0;    FOR l: Line ¬ fromLine, l.next UNTIL l = toLine.next DO      trashLength ¬ trashLength + (SELECT TRUE FROM        fromLine = toLine => toIndex - fromIndex,	fromLine = l => fromLine.buffer.length - fromIndex,	toLine = l => toIndex,        ENDCASE => l.buffer.length);      ENDLOOP;    trash ¬ String.MakeString[sz, trashLength];    FOR l: Line ¬ fromLine, l.next UNTIL l = toLine.next DO      to: Environment.Block = [LOOPHOLE[@trash.text], trash.length, trashLength];      from: Environment.Block = [LOOPHOLE[@l.buffer.text],	  (SELECT l FROM	    fromLine => fromIndex,	  ENDCASE => 0),	  (SELECT l FROM	    toLine => toIndex,	    ENDCASE => l.buffer.length)];      IF from.startIndex = from.stopIndexPlusOne THEN LOOP;      trash.length ¬ trash.length + ByteBlt.ByteBlt[to, from, move];      ENDLOOP};    ConvertTrash: PROC [data: LONG STRING, target: Selection.Target]    RETURNS [LONG POINTER] = {    SELECT target FROM      length => RETURN[sz.NEW[LONG CARDINAL ¬ data.length]];      string => RETURN [String.CopyToNewString[data, sz]];--      source =>    ENDCASE => RETURN[NIL]};    ClearTrash: PROC [data: LONG STRING] = {    String.FreeString[sz, data]};      BufferForPosition: PUBLIC PROC[source: TextSource.Handle,     pos: TextSource.Position] RETURNS[ZoomSource.Buffer] = {    zoom: ZoomHandle = StoZ[source];    sum: TextSource.Position ¬ 0;    IF ~IsIt[source] THEN RETURN[NIL];    FOR line: Line ¬ zoom.firstLine, line.next DO      sum ¬ sum + line.buffer.length;      IF pos < sum THEN RETURN[line.buffer];       ENDLOOP};  }..
-- Copyright (C) 1980, 1981, 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- File: CommandCentralImpl.mesa - last edit:-- SXW   :	13-Jul-81  7:27:10-- BXM  :	16-Jul-81 12:02:08-- RXL  :	10-Dec-80  9:21:56-- LXR    :	17-Jan-84 10:49:28-- RXJ     :	 6-Dec-82 21:01:46-- MXS     :	 4-Jun-81 17:25:20-- BTL  :	 8-Apr-81 10:40:42-- JGS:		17-Dec-81 10:09:35-- SXS   :	15-Dec-81 15:08:35-- RXR   :	14-Apr-83 16:46:13-- PXK    :	22-Jan-82 17:12:01-- MEW :	17-May-85 12:26:38-- Derived from JGS    's CommandCentral.mesa of October 11, 1980  2:28 PMDIRECTORY  Ascii USING [CR, NUL],  Context USING [Create, Destroy, Find, Type, UniqueType],  Environment USING [charsPerPage, charsPerWord],  Exec USING [    CheckAbortProc, ExecProc, Handle, LookupCommand, Object, Outcome, Run],  ExecInternal USING [    bootSwitches, clientVolume, codeLinks, Do,     Log, MapClientVolumeNameToID, Object, ProcessBootSwitchList,     RunClientPrograms, runSwitches, useBackground, volumeLabel],  ExecUtilities USING [commandCentralWindow],  Expand USING [ExpandString, UnknownCommandFile],  Event USING[fileSystem],  EventTypes USING [newSearchPath],  File USING [File, nullFile],  FileSW USING [Create, defaultOptions, Destroy, GetFile, Options],  Format USING [StringProc],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType, CommandItem,    DisplayItem, Enumerated, EnumeratedItem, EnumeratedNotifyProcType,    GetSelection, line0, line1, line2, line3, line4, nullEnumeratedValue,    ProcType, StringItem],  Heap USING [systemZone],  MFile USING [    Acquire, AddNotifyProc, CopyFileHandle, Error, Handle, NotifyProc, Release,    ReleaseChoice, RemoveNotifyProc],  MsgSW USING [AppendString, Clear],  MStream USING [Create, Error, GetFile, Handle, PleaseReleaseProc, ReadOnly],  Process USING [Detach, SetPriority, priorityBackground, priorityNormal],  Put USING [Char, LongString, Text],  Queue USING [Empty, Init, QHead, StringToQR],  Runtime USING [GetBcdTime],  Selection USING [Clear, Convert],  SpecialExec USING [binderSwitches, compilerSwitches],  SpecialMFile USING [GetCapaWithAccess],  Stream USING [Handle],  String USING [AppendString, CopyToNewString, Empty, EmptyString, FreeString,    Replace],  Supervisor USING[    AddDependency, AgentProcedure, CreateSubsystem, DeleteSubsystem,    InvalidSubsystem, NoSuchDependency, nullSubsystem, RemoveDependency,     SubsystemHandle],  System USING [Switches],  Time USING [Append, Unpack],  Token USING [GetCharProcType, Object],  Tool USING [    Create, Destroy, MakeFormSW, MakeMsgSW, MakeStringSW, MakeSWsProc, SwapSWs],  ToolDriver USING [Address, NoteSWs, RemoveSWs],  ToolWindow USING [CreateSubwindow, Destroy, State, TransitionProcType,     WindowForSubwindow],  UserInput USING [UserAbort],  UserTerminal USING [BlinkDisplay],  Version USING [Append],  Volume USING [ID],  Window USING [Box, GetBox, Handle];    CommandCentralImpl: MONITOR LOCKS l USING l: Lock  IMPORTS    Context, Event, Exec, ExecInternal, ExecUtilities, Expand, FileSW, FormSW,    Heap, MFile, MsgSW, MStream, Process, Put, Queue, Runtime,     Selection, SpecialExec, SpecialMFile, String, Supervisor, Time,     Tool, ToolDriver, ToolWindow, UserInput, UserTerminal, Version, Window  EXPORTS Exec =      BEGIN      Handle: PUBLIC TYPE = LONG POINTER TO Object;  Object: PUBLIC TYPE = ExecInternal.Object;  Lock: TYPE = LONG POINTER TO MONITORLOCK;    Command: TYPE = {compiler, binder};  CurrentLog: TYPE =  {empty, compiler, binder};    CCHandle: TYPE = LONG POINTER TO CCObject;  CCObject: TYPE = RECORD [    herald: ARRAY Command OF LONG STRING ¬ ALL[NIL],    name: ARRAY Command OF LONG STRING ¬ ALL[NIL],    argList: ARRAY Command OF LONG STRING ¬ ALL[NIL],    emptyString: LONG STRING ¬ NIL,    window, msgSW, formSW, optionSW: Window.Handle ¬ NIL,  -- the real things    emptySW, compilerSW, binderSW: Window.Handle ¬ NIL,  -- log windows    currentLog: CurrentLog ¬ empty,    run: LONG STRING ¬ NIL,    logInSW: UNSPECIFIED ¬ 0,    binderLogState, compilerLogState: LogState ¬ unloaded,    windowLock: MONITORLOCK ¬ [],    windowCondition: CONDITION,    pleaseUnloadCompiler: BOOLEAN ¬ FALSE,    pleaseUnloadBinder: BOOLEAN ¬ FALSE,    abortGo: BOOLEAN ¬ FALSE,    goLock: MONITORLOCK ¬ [],    loadLock: MONITORLOCK ¬ [],    logFiles: ARRAY ExecInternal.Log OF LONG STRING ¬ ALL[NIL],    searchPathAgent: Supervisor.SubsystemHandle ¬ Supervisor.nullSubsystem,    csTemp, bsTemp, rsTemp, volTemp: LONG STRING ¬ NIL,    useBg: BOOLEAN ¬ FALSE,    rsIndex: CARDINAL ¬ 0,    rsValueStart: CARDINAL ¬ 0,    z: UNCOUNTED ZONE ];    ccContext: Context.Type = Context.UniqueType[];    globalWindow: Window.Handle ¬ NIL;  -- Global copy of window handle    LogState: TYPE = {unloaded, loading, loaded, unloading};    charsPerPage: CARDINAL = Environment.charsPerPage;  charsPerWord: CARDINAL = Environment.charsPerWord;    FindContext: PROCEDURE [sw: Window.Handle] RETURNS [data: CCHandle] = {    w: Window.Handle ¬ ToolWindow.WindowForSubwindow[sw];    RETURN[Context.Find[ccContext, IF w = NIL THEN sw ELSE w]];    };    Output: Format.StringProc = {    MsgSW.AppendString[FindContext[globalWindow]­.msgSW, s]};    CommandCentralAborted: PROCEDURE RETURNS [abort: BOOLEAN] = {      RETURN[UserInput.UserAbort[globalWindow]]};    IsAborted: Exec.CheckAbortProc = {RETURN[CommandCentralAborted[]]};      SearchPathAgentProc: Supervisor.AgentProcedure =     BEGIN    data: CCHandle ¬ instanceData;    oldFh, newFh: MFile.Handle ¬ NIL;    oldSh: MStream.Handle ¬ NIL;    oldFile, newFile: File.File ¬ File.nullFile;    logInSWCopy: CurrentLog ¬ data.currentLog;    PrepareToDelete: PROCEDURE[log: CurrentLog] RETURNS [deleteIt: BOOLEAN] =      BEGIN      GetCurrentLog: ENTRY PROCEDURE [l:Lock] RETURNS [oldFile: File.File] =        BEGIN        sw: Window.Handle ¬ IF log = compiler THEN data.compilerSW ELSE data.binderSW;        IF sw = NIL THEN RETURN[File.nullFile];        [,oldSh] ¬ FileSW.GetFile[sw];	IF oldSh = NIL THEN RETURN[File.nullFile];        oldFh ¬ MStream.GetFile[oldSh ! MFile.Error => CONTINUE];        IF oldFh = NIL THEN RETURN[File.nullFile];        oldFile ¬ SpecialMFile.GetCapaWithAccess[oldFh];        END;      oldFile ¬ GetCurrentLog[@data.windowLock];      IF oldFile = File.nullFile THEN RETURN[FALSE];      newFh ¬ MFile.Acquire[       IF log = compiler THEN  "Compiler.log"L ELSE "Binder.log"L,        anchor, [] ! MFile.Error => CONTINUE];      IF newFh = NIL THEN RETURN[TRUE];  --no log in current search path      newFile ¬ SpecialMFile.GetCapaWithAccess[newFh];      MFile.Release[newFh];      IF oldFile # newFile THEN RETURN[TRUE] ELSE RETURN[FALSE];      END;          IF event # EventTypes.newSearchPath THEN RETURN;    IF PrepareToDelete[logInSWCopy] THEN {        IF logInSWCopy = compiler THEN [] ¬ ReleaseCompilerLog[oldSh, data]        ELSE [] ¬ ReleaseBinderLog[oldSh, data]};    END;        -- Compiler-specific feedback stuff  ReleaseCompilerLog: MStream.PleaseReleaseProc =    BEGIN    data: CCHandle ¬ instanceData;    LockedReleaseCompilerLog: ENTRY PROCEDURE [l: Lock]      RETURNS [MFile.ReleaseChoice] =      BEGIN      ENABLE UNWIND => NULL;      IF data.compilerSW = NIL THEN RETURN[later];      SELECT data.compilerLogState FROM        loaded => {          data.compilerLogState ¬ unloading;          Process.Detach[FORK ClearCompiler[data]];          RETURN[later]};        unloading => RETURN[later];        loading => {data.pleaseUnloadCompiler ¬ TRUE; RETURN[later]};        ENDCASE => RETURN[no]; -- unloaded      END;    RETURN[LockedReleaseCompilerLog[@data.windowLock]];    END;        ClearCompiler: PROCEDURE [data: CCHandle] = {    SwapOutCompiler: ENTRY PROCEDURE [l: Lock] RETURNS [ok: BOOLEAN ¬ TRUE] = {      ENABLE UNWIND => NULL;      IF data.compilerSW = NIL THEN RETURN[FALSE];      IF data.currentLog = compiler THEN {        [] ¬ Tool.SwapSWs[window: data.window, oldSW: data.compilerSW, newSW: data.emptySW];        data.logInSW ¬ FormSW.nullEnumeratedValue;        data.currentLog ¬ empty}};    DoneWithCompiler: ENTRY PROCEDURE [l: Lock] = {      ENABLE UNWIND => NULL;      data.compilerLogState ¬ unloaded;      BROADCAST data.windowCondition};    IF ~SwapOutCompiler[@data.windowLock] THEN RETURN;    FileSW.Destroy[data.compilerSW];    DoneWithCompiler[@data.windowLock]};        CompilerNotify: MFile.NotifyProc =    BEGIN    data: CCHandle ¬ clientInstanceData;    s: MStream.Handle ¬ NIL;    f: MFile.Handle ¬ NIL;    GetStream: ENTRY PROCEDURE [l: Lock] RETURNS [s: MStream.Handle ¬ NIL] =      BEGIN      SELECT data.compilerLogState FROM         loading, loaded => RETURN; -- someone beat us to the window	 ENDCASE;      s ¬ MStream.Create[file: f, release: [ReleaseCompilerLog, data]                        ! MStream.Error => CONTINUE];      IF s # NIL THEN data.compilerLogState ¬ loading;      END;    f ¬ MFile.CopyFileHandle[      file, [], readOnly ! MFile.Error => CONTINUE];    IF f = NIL THEN RETURN;    s ¬ GetStream[@data.windowLock];    IF s = NIL THEN RETURN;    LoadCompilerLog[@data.windowLock, s, data];    LoadCompilerSW[@data.windowLock, data];    END;      LoadCompilerLog: ENTRY PROCEDURE [l: Lock, s: MStream.Handle, data: CCHandle] =    BEGIN    ENABLE UNWIND => NULL;    options: FileSW.Options ¬ FileSW.defaultOptions;    options.menu ¬ FALSE;    IF data.compilerSW = NIL OR data.pleaseUnloadCompiler THEN {      s.delete[s]; data.pleaseUnloadCompiler ¬ FALSE;       data.compilerLogState ¬ unloaded; RETURN};    DO      SELECT data.compilerLogState FROM        unloaded => {data.compilerLogState ¬ loading; EXIT}; -- is this possible?        loading => EXIT;	loaded => {s.delete[s]; RETURN};        ENDCASE => WAIT data.windowCondition;  -- unloading      ENDLOOP;    FileSW.Create[      sw: data.compilerSW, name: "Compiler.log"L, s: s, allowTypeIn: FALSE,      options: options];    data.compilerLogState ¬ loaded;    END;	  LoadCompilerSW: ENTRY PROCEDURE [l: Lock, data: CCHandle] =    BEGIN    ENABLE UNWIND => NULL;    IF data.compilerSW = NIL OR data.compilerLogState # loaded THEN RETURN;    IF data.pleaseUnloadCompiler THEN {Process.Detach[FORK ClearCompiler[data]]; RETURN};    SELECT data.currentLog FROM      binder => {        [] ¬ Tool.SwapSWs[window: data.window, oldSW: data.binderSW, newSW: data.compilerSW];        data.binderLogState ¬ unloading;        Process.Detach[FORK ClearBinder[data]]};      empty =>        [] ¬ Tool.SwapSWs[window: data.window, oldSW: data.emptySW, newSW: data.compilerSW];      ENDCASE;    data.currentLog ¬ compiler;    data.logInSW ¬ ExecInternal.Log[compiler];    FormSW.DisplayItem[sw: data.formSW, index: Rep[log]];    END;          ReleaseBinderLog: MStream.PleaseReleaseProc =    BEGIN    data: CCHandle ¬ instanceData;    LockedReleaseBinderLog: ENTRY PROCEDURE [l: Lock]      RETURNS [MFile.ReleaseChoice] =      BEGIN      ENABLE UNWIND => NULL;      IF data.binderSW = NIL THEN RETURN[later];      SELECT data.binderLogState FROM        loaded => {          data.binderLogState ¬ unloading;          Process.Detach[FORK ClearBinder[data]];          RETURN[later]};        unloading => RETURN[later];        loading => {data.pleaseUnloadBinder ¬ TRUE; RETURN[later]};        ENDCASE => RETURN[no];      END;    RETURN[LockedReleaseBinderLog[@data.windowLock]];    END;    ClearBinder: PROCEDURE[data: CCHandle] = {    SwapOutBinder: ENTRY PROCEDURE [l: Lock] RETURNS [ok: BOOLEAN ¬ TRUE] = {      ENABLE UNWIND => NULL;      IF data.binderSW = NIL THEN RETURN[FALSE];      IF data.currentLog = binder THEN {        [] ¬ Tool.SwapSWs[window: data.window, oldSW: data.binderSW, newSW: data.emptySW];        data.logInSW ¬ FormSW.nullEnumeratedValue;        data.currentLog ¬ empty}};    DoneWithBinder: ENTRY PROCEDURE [l: Lock] = {      ENABLE UNWIND => NULL;      data.binderLogState ¬ unloaded;      BROADCAST data.windowCondition};    IF ~SwapOutBinder[@data.windowLock] THEN RETURN;    FileSW.Destroy[data.binderSW];    DoneWithBinder[@data.windowLock]};      BinderNotify: MFile.NotifyProc =    BEGIN    data: CCHandle ¬ clientInstanceData;    s: MStream.Handle ¬ NIL;    f: MFile.Handle ¬ NIL;    GetStream: ENTRY PROCEDURE [l: Lock] RETURNS [s: MStream.Handle ¬ NIL] =      BEGIN      SELECT data.binderLogState FROM         loading, loaded => RETURN; -- someone beat us to the window	 ENDCASE;      s ¬ MStream.Create[file: f, release: [ReleaseBinderLog, data]                        ! MStream.Error => CONTINUE];      IF s # NIL THEN data.binderLogState ¬ loading;      END;    f ¬ MFile.CopyFileHandle[      file, [], readOnly ! MFile.Error => CONTINUE];    IF f = NIL THEN RETURN;    s ¬ GetStream[@data.windowLock];    IF s = NIL THEN RETURN;    LoadBinderLog[@data.windowLock, s, data];    LoadBinderSW[@data.windowLock, data];    END;      LoadBinderLog: ENTRY PROCEDURE [l: Lock, s: MStream.Handle, data: CCHandle] =    BEGIN    ENABLE UNWIND => NULL;    options: FileSW.Options ¬ FileSW.defaultOptions;    options.menu ¬ FALSE;    IF data.binderSW = NIL OR data.pleaseUnloadBinder THEN {      s.delete[s]; data.pleaseUnloadBinder ¬ FALSE;      data.binderLogState ¬ unloaded; RETURN};    DO      SELECT data.binderLogState FROM        unloaded => {data.binderLogState ¬ loading; EXIT}; -- is this possible?;        loading => EXIT;        loaded => {s.delete[s]; RETURN};        ENDCASE => WAIT data.windowCondition;  -- unloading      ENDLOOP;    FileSW.Create[      sw: data.binderSW, name: "Binder.log"L, s: s, allowTypeIn: FALSE,      options: options];    data.binderLogState ¬ loaded;    END;      LoadBinderSW: ENTRY PROCEDURE [l: Lock, data: CCHandle] =    BEGIN    ENABLE UNWIND => NULL;    IF data.binderSW = NIL OR data.binderLogState # loaded THEN RETURN;    IF data.pleaseUnloadBinder THEN {Process.Detach[FORK ClearBinder[data]]; RETURN};    SELECT data.currentLog FROM      compiler => {        [] ¬ Tool.SwapSWs[window: data.window, oldSW: data.compilerSW, newSW: data.binderSW];        data.compilerLogState ¬ unloading;        Process.Detach[FORK ClearCompiler[data]]};      empty => [] ¬ Tool.SwapSWs[window: data.window, oldSW: data.emptySW, newSW: data.binderSW];      ENDCASE;    data.currentLog ¬ binder;    data.logInSW ¬ ExecInternal.Log[binder];    FormSW.DisplayItem[sw: data.formSW, index: Rep[log]];    END;              -- Executive Commands Invoked from Menu        ExpandLines: FormSW.ProcType =    BEGIN    data: CCHandle ¬ FindContext[sw];    MsgSW.Clear[data.msgSW];    ExpandItem[@data.argList[compiler], Rep[cs], data];    ExpandItem[@data.argList[binder], Rep[bs], data];    ExpandItem[@data.run, Rep[rs], data];    END;        Compile: FormSW.ProcType =     BEGIN    data: CCHandle ¬ FindContext[sw];    MsgSW.Clear[data.msgSW];     Process.Detach[FORK ForkedCompile[data]]; END;        ForkedCompile: PROCEDURE [data: CCHandle] =    BEGIN    ENABLE UNWIND => NULL;    SetPriority[];    DoCommand[      compiler, data !      ABORTED => {DisplayMsg[data, "Aborted."L, TRUE]; data.abortGo ¬ TRUE; CONTINUE}];    END;        CompileForGo: INTERNAL PROCEDURE [data: CCHandle] =    BEGIN    DoCommand[      compiler, data !      ABORTED => {DisplayMsg[data, "Aborted."L, TRUE]; data.abortGo ¬ TRUE; CONTINUE}];    END;        Bind: FormSW.ProcType =     BEGIN     data: CCHandle ¬ FindContext[sw];    MsgSW.Clear[data.msgSW];     Process.Detach[FORK ForkedBind[data]]; END;    ForkedBind: PROC [data: CCHandle] =    BEGIN    SetPriority[];    DoCommand[binder, data ! ABORTED => {DisplayMsg[data, "Aborted."L, TRUE]; CONTINUE}];    END;    BindForGo: INTERNAL PROCEDURE [data: CCHandle] =    BEGIN    DoCommand[      binder, data !      ABORTED => {DisplayMsg[data, "Aborted."L, TRUE]; data.abortGo ¬ TRUE; CONTINUE}];    END;    Run: FormSW.ProcType =    BEGIN    data: CCHandle ¬ FindContext[sw];    MsgSW.Clear[data.msgSW];    ExecInternal.RunClientPrograms[data.run, Output];  -- some danger of race with this string    END;      Go: FormSW.ProcType =     BEGIN     data: CCHandle ¬ FindContext[sw];    MsgSW.Clear[data.msgSW];     Process.Detach[FORK ForkedGo[@data.goLock, data]]; END;      ForkedGo: ENTRY PROCEDURE [l: Lock, data: CCHandle] =    BEGIN    ENABLE UNWIND => NULL;    data.abortGo ¬ FALSE;    SetPriority[];    CompileForGo[data];    IF ~data.abortGo THEN BindForGo[data];    IF ~data.abortGo THEN ExecInternal.RunClientPrograms[data.run, Output];    -- some danger of race with this string    END;      -- Error Reporting Procedures      DisplayMsg: PROCEDURE [data: CCHandle, s: LONG STRING, flash: BOOLEAN ¬ TRUE] =    BEGIN    NewLine[data];    Put.LongString[data.msgSW, s];    IF flash THEN UserTerminal.BlinkDisplay[];    END;      NotFound: PROCEDURE [data: CCHandle, name: LONG STRING] =    BEGIN OPEN Put;    NewLine[data];    Char[data.msgSW, '"];    LongString[data.msgSW, name];    Text[data.msgSW, """ not found."L];    UserTerminal.BlinkDisplay[];    END;      NewLine: PROCEDURE [data: CCHandle] = {Put.Char[data.msgSW, Ascii.CR]};    GetProc: ENTRY PROCEDURE [l: Lock, command: Command, Write: Format.StringProc, data: CCHandle]    RETURNS [proc: Exec.ExecProc ¬ NIL, clientData: LONG POINTER ¬ NIL] = {    i: CARDINAL ¬ 0;    aborted: BOOLEAN ¬ FALSE;    get: Token.GetCharProcType ¬ {      IF i >= data.name[command].length THEN RETURN[Ascii.NUL];      c ¬ data.name[command][i];      i ¬ i + 1};    t: Token.Object ¬ [getChar: get, break: Ascii.NUL];    codeLinks: BOOLEAN ¬ ExecInternal.codeLinks;    [proc: proc, clientData: clientData] ¬ Exec.LookupCommand[data.name[command]];    IF proc # NIL THEN RETURN;    NewLine[data];    Exec.Run[      @t, Write, CommandCentralAborted, codeLinks !         ABORTED => {aborted ¬ TRUE; CONTINUE}];    IF ~aborted THEN       [proc: proc, clientData: clientData] ¬         Exec.LookupCommand[data.name[command]]};      -- Command Processing Support Procedures      DoCommand: PROCEDURE [command: Command, data: CCHandle] =    BEGIN    outcome: Exec.Outcome ¬ normal;    arg: LONG STRING;    proc: Exec.ExecProc;    clientData: LONG POINTER ¬ NIL;    compilerComQ, compilerRemQ, binderComQ, binderRemQ: Queue.QHead ¬ Queue.Init[];    object: ARRAY Command OF ExecInternal.Object ¬ [      [comQ: @compilerComQ, remQ: @compilerRemQ,       output: Output, checkForAbort: IsAborted],      [comQ: @binderComQ, remQ: @binderRemQ,       output: Output, checkForAbort: IsAborted]];    Write: Format.StringProc = {Put.LongString[data.msgSW, s]};    IF String.EmptyString[data.argList[command]] THEN RETURN;    IF command = binder THEN NewLine[data];    [proc, clientData] ¬ GetProc[@data.loadLock, command, Output, data];    IF proc = NIL THEN GO TO abort;    IF CommandCentralAborted[] THEN {data.abortGo ¬ TRUE; ERROR ABORTED};    arg ¬ Expand.ExpandString[      data.argList[command], CommandCentralAborted !      Expand.UnknownCommandFile => {NotFound[data, name]; GO TO abort};      MFile.Error => {DisplayMsg[data, "Error from file system"L, TRUE]; GO TO abort}];    Queue.StringToQR[arg, object[command].comQ];    data.z.FREE[@arg]; arg ¬ NIL;    Write[data.herald[command]];    outcome ¬ proc[@object[command], clientData];    Queue.Empty[object[command].comQ]; -- reset comQ in case it wasn't consumed    IF outcome # normal THEN data.abortGo ¬ TRUE;    EXITS abort => data.abortGo ¬ TRUE;    END;      ExpandItem: PROCEDURE [s: LONG POINTER TO LONG STRING, index: CARDINAL, data: CCHandle] =    BEGIN    temp: LONG STRING ¬ s­;    hasSelection: BOOLEAN = Selection.Convert[subwindow] = data.formSW;    IF String.EmptyString[s­] THEN RETURN;    IF hasSelection AND FormSW.GetSelection[data.formSW].index = index THEN      Selection.Clear[];    s­ ¬ Expand.ExpandString[      temp ! Expand.UnknownCommandFile => {NotFound[data, temp]; GOTO notFound}];    data.z.FREE[@temp];    FormSW.DisplayItem[data.formSW, index];    EXITS notFound => NULL    END;    SetPriority: PROCEDURE =    BEGIN    Process.SetPriority[      IF ExecInternal.useBackground THEN Process.priorityBackground      ELSE Process.priorityNormal];    END;      -- Initialization and Window Management      MakeSWs: Tool.MakeSWsProc =    BEGIN OPEN Tool;    data: CCHandle ¬ FindContext[window];    addresses: ARRAY [0..2) OF ToolDriver.Address;    data.window ¬ window;    globalWindow ¬ window;    data.msgSW ¬ MakeMsgSW[window: window, lines: 2];    data.formSW ¬ MakeFormSW[window: window, formProc: MakeForm];    data.logInSW ¬ FormSW.nullEnumeratedValue;    data.emptySW ¬ MakeStringSW[window: window, s: @data.emptyString, access: read];    data.compilerSW ¬ ToolWindow.CreateSubwindow[parent: NIL];    data.binderSW ¬ ToolWindow.CreateSubwindow[parent: NIL];    addresses ¬ [["msgSW"L, data.msgSW], ["formSW"L, data.formSW]];    ToolDriver.NoteSWs["Executive"L, DESCRIPTOR[addresses]];    END;      Parms: TYPE = MACHINE DEPENDENT{    expand, compile, bind, run, go, options, cs, bs, rs, log};  Rep: PROCEDURE [Parms] RETURNS [CARDINAL] = MACHINE CODE BEGIN END;   MakeForm: FormSW.ClientItemsProcType =    BEGIN OPEN FormSW;    data: CCHandle ¬ FindContext[sw];    logChoices: ARRAY [0..2) OF Enumerated ¬ [      ["Compiler"L, ExecInternal.Log[compiler]], [      "Binder"L, ExecInternal.Log[binder]]];    items ¬ AllocateItemDescriptor[Rep[LAST[Parms]] + 1];    items[Rep[expand]] ¬ CommandItem[      tag: "Expand"L, place: [0, line0], proc: ExpandLines];    items[Rep[compile]] ¬ CommandItem[      tag: "Compile"L, place: [10*7, line0], proc: Compile];    items[Rep[bind]] ¬ CommandItem[      tag: "Bind"L, place: [21*7, line0], proc: Bind];    items[Rep[run]] ¬ CommandItem[tag: "Run"L, place: [29*7, line0], proc: Run];    items[Rep[go]] ¬ CommandItem[tag: "Go"L, place: [36*7, line0], proc: Go];    items[Rep[options]] ¬ CommandItem[      tag: "Options"L, place: [42*7, line0], proc: OptionsWindow];    items[Rep[cs]] ¬ StringItem[      tag: "Compile"L, place: [0, line1], string: @data.argList[compiler],      inHeap: TRUE];    items[Rep[bs]] ¬ StringItem[      tag: "Bind"L, place: [0, line2], string: @data.argList[binder], inHeap: TRUE];    items[Rep[rs]] ¬ StringItem[      tag: "Run"L, place: [0, line3], string: @data.run, inHeap: TRUE];    items[Rep[log]] ¬ EnumeratedItem[      tag: "Log"L, place: [0, line4], proc: ChangeLogSW,      choices: DESCRIPTOR[logChoices], value: @data.logInSW];    RETURN[items: items, freeDesc: TRUE];    END;        ChangeLogSW: FormSW.EnumeratedNotifyProcType =    BEGIN    data: CCHandle ¬ FindContext[sw];    s: MStream.Handle ¬ NIL;    logInSWCopy: UNSPECIFIED;    GetStream: ENTRY PROCEDURE [l: Lock] RETURNS [s: MStream.Handle ¬ NIL] =      BEGIN      s ¬ MStream.ReadOnly[name: data.logFiles[logInSWCopy],          release: [IF logInSWCopy = ExecInternal.Log[compiler] THEN	             ReleaseCompilerLog ELSE ReleaseBinderLog, data] 		     ! MStream.Error => CONTINUE];      IF s = NIL THEN RETURN;      IF logInSWCopy = ExecInternal.Log[compiler] THEN        data.compilerLogState ¬ loading      ELSE data.binderLogState ¬ loading;       END;    SameLog: ENTRY PROC [l: Lock] RETURNS [BOOLEAN] = {      RETURN[oldValue = (logInSWCopy ¬ data.logInSW)]};    IF SameLog[@data.windowLock] THEN RETURN;    s ¬ GetStream[@data.windowLock];    IF s = NIL THEN {DisplayMsg[data, "No log file"L]; RETURN};    IF logInSWCopy = ExecInternal.Log[compiler] THEN {      LoadCompilerLog[@data.windowLock, s, data];      LoadCompilerSW[@data.windowLock, data]}    ELSE {LoadBinderLog[@data.windowLock, s, data];          LoadBinderSW[@data.windowLock, data]};    END;    NOOPCleanup: PROCEDURE [data: CCHandle, window: Window.Handle] = {};      -- The context is only a copy of the main window's context      OptionsWindow: FormSW.ProcType =    BEGIN        data: CCHandle ¬ FindContext[sw];    box: Window.Box = Window.GetBox[data.window];        OptionSW: Tool.MakeSWsProc = {  --put this in here so can get to data      [] ¬ Tool.MakeFormSW[window: window, formProc: MakeOptions]};          MakeOptions: FormSW.ClientItemsProcType =      BEGIN OPEN FormSW;      nOptions: CARDINAL = 7;      runSwitches, volumeLabel: LONG STRING ¬ NIL;      Get: PROC = {	String.Replace[@runSwitches, ExecInternal.runSwitches, Heap.systemZone];	String.Replace[@volumeLabel, ExecInternal.volumeLabel, Heap.systemZone];	String.Replace[@data.csTemp, SpecialExec.compilerSwitches, Heap.systemZone];	String.Replace[@data.bsTemp, SpecialExec.binderSwitches, Heap.systemZone];	data.useBg ¬ ExecInternal.useBackground};      rsTag: STRING = "Client Switches"L;      ExecInternal.Do[Get];      String.Replace[@data.rsTemp, runSwitches, Heap.systemZone];      String.Replace[@data.volTemp, volumeLabel, Heap.systemZone];      String.FreeString[Heap.systemZone, runSwitches];      String.FreeString[Heap.systemZone, volumeLabel];      items ¬ AllocateItemDescriptor[nOptions];      items[0] ¬ CommandItem[tag: "Apply"L, place: [0, line0], proc: ApplyOptions];      items[1] ¬ StringItem[	tag: "Compiler Switches"L, place: [12*7, line0], string: @data.csTemp,	inHeap: TRUE];      items[2] ¬ StringItem[	tag: "Binder Switches"L, place: [12*7, line1], string: @data.bsTemp,	inHeap: TRUE];      items[3] ¬ BooleanItem[	tag: "UseBackground"L, place: [0, line2], switch: @data.useBg];      items[4] ¬ StringItem[	tag: "Client Volume"L, place: [12*7, line2], string: @data.volTemp,	inHeap: TRUE];      items[5] ¬ CommandItem[tag: "Abort"L, place: [0, line3], proc: RemoveOptions];      items[data.rsIndex ¬ 6] ¬ StringItem[	tag: rsTag, place: [12*7, line3], string: @data.rsTemp, inHeap: TRUE];      data.rsValueStart ¬ rsTag.length + 2;  -- 2 = length of ": "      RETURN[items, TRUE]      END;        IF data.optionSW = NIL THEN {      data.optionSW ¬ Tool.Create[        name: "Executive Options"L, makeSWsProc: OptionSW, initialState: active,        initialBox: [[box.place.x + 15, box.place.y + 125], [50*7, 5*15 + 2]]];      Context.Create[ccContext, data, NOOPCleanup, data.optionSW]}    ELSE ApplyOptions[data.optionSW];    END;      ApplyOptions: FormSW.ProcType =    BEGIN OPEN String;    data: CCHandle ¬ FindContext[sw];    bootSwitches: System.Switches;    clientVolume: Volume.ID;    Update: PROC = {      ExecInternal.bootSwitches ¬ bootSwitches;      ExecInternal.clientVolume ¬ clientVolume;      String.Replace[@ExecInternal.volumeLabel, data.volTemp, Heap.systemZone];      String.Replace[@ExecInternal.runSwitches, data.rsTemp, Heap.systemZone];      String.Replace[@SpecialExec.compilerSwitches, data.csTemp, Heap.systemZone];      String.Replace[@SpecialExec.binderSwitches, data.bsTemp, Heap.systemZone];      ExecInternal.useBackground ¬ data.useBg};    bootSwitches ¬ ExecInternal.ProcessBootSwitchList[data.rsTemp];    clientVolume ¬ ExecInternal.MapClientVolumeNameToID[data.volTemp];    ExecInternal.Do[Update];    String.FreeString[Heap.systemZone, data.volTemp];    data.volTemp ¬ NIL;    String.FreeString[Heap.systemZone, data.rsTemp];    data.rsTemp ¬ NIL;    String.FreeString[Heap.systemZone, data.csTemp];    data.csTemp ¬ NIL;    String.FreeString[Heap.systemZone, data.bsTemp];    data.bsTemp ¬ NIL;    RemoveOptions[sw];    END;        RemoveOptions: FormSW.ProcType =    BEGIN     data: CCHandle ¬ FindContext[sw];    Context.Destroy[ccContext, data.optionSW];    Tool.Destroy[data.optionSW];     data.optionSW ¬ NIL;    END;        BuildExecutiveTool: PROCEDURE [data: CCHandle] =    BEGIN    name: LONG STRING ¬ data.z.NEW[StringBody [50]];    String.AppendString[name, "Command Central "L];    Version.Append[name];    String.AppendString[name, " of "L];    Time.Append[name, Time.Unpack[Runtime.GetBcdTime[]]];    data.window ¬ Tool.Create[      name: name, makeSWsProc: MakeSWs, clientTransition: CleanupExecutiveTool,      initialBox: [[40, 40], [400, 250]], cmSection: "CommandCentral"L];    globalWindow ¬ data.window;    data.z.FREE[@name];    END;      CleanupExecutiveTool: ToolWindow.TransitionProcType = {    data: CCHandle ¬ FindContext[window];    IF old = inactive AND data = NIL THEN {      data ¬ MakeNewDataObject[];      Context.Create[ccContext, data, Cleanup, window] };    LockedCleanupExecutiveTool[@data.windowLock, data.window, old, new, data];    IF new = inactive AND data # NIL THEN Context.Destroy[ccContext, window]};      LockedCleanupExecutiveTool: ENTRY PROCEDURE [    l: Lock, window: Window.Handle, old, new: ToolWindow.State, data: CCHandle] =    BEGIN    ENABLE UNWIND => NULL;    IF new = inactive THEN {      MFile.RemoveNotifyProc[        proc: CompilerNotify, filter: [name: "Compiler.log"L, access: readOnly],        clientInstanceData: data];      MFile.RemoveNotifyProc[        proc: BinderNotify, filter: [name: "Binder.log"L, access: readOnly],        clientInstanceData: data];      ToolDriver.RemoveSWs["Executive"L];      data.msgSW ¬ NIL;      data.formSW ¬ NIL;      IF data.currentLog # compiler THEN ToolWindow.Destroy[data.compilerSW];      data.compilerSW ¬ NIL;      data.compilerLogState ¬ unloaded;      IF data.currentLog # binder THEN ToolWindow.Destroy[data.binderSW];      data.binderSW ¬ NIL;      data.binderLogState ¬ unloaded;      IF data.currentLog # empty THEN ToolWindow.Destroy[data.emptySW];      data.emptySW ¬ NIL;      IF data.optionSW # NIL THEN RemoveOptions[NIL];      data.logInSW ¬ FormSW.nullEnumeratedValue};    IF old = inactive THEN {      data.currentLog ¬ empty;      data.logInSW ¬ FormSW.nullEnumeratedValue;      MFile.AddNotifyProc[        proc: CompilerNotify, filter: [name: "Compiler.log"L, access: readOnly],        clientInstanceData: data];      MFile.AddNotifyProc[        proc: BinderNotify, filter: [name: "Binder.log"L, access: readOnly],        clientInstanceData: data]};    END;    Cleanup: PROCEDURE [data: CCHandle, window: Window.Handle] =     BEGIN     IF data # NIL THEN {      String.FreeString[data.z, data.herald[compiler]];      String.FreeString[data.z, data.herald[binder]];      String.FreeString[data.z, data.name[compiler]];      String.FreeString[data.z, data.name[binder]];      String.FreeString[data.z, data.logFiles[compiler]];      String.FreeString[data.z, data.logFiles[binder]];      String.FreeString[data.z, data.csTemp];      String.FreeString[data.z, data.bsTemp];      String.FreeString[data.z, data.rsTemp];      String.FreeString[data.z, data.volTemp];      Supervisor.RemoveDependency[        client: data.searchPathAgent, implementor: Event.fileSystem !        Supervisor.NoSuchDependency => CONTINUE];      Supervisor.DeleteSubsystem[data.searchPathAgent !        Supervisor.InvalidSubsystem => CONTINUE];      Heap.systemZone.FREE[@data] }    END;     MakeNewDataObject: PROCEDURE RETURNS [data: CCHandle] =    BEGIN     data ¬ Heap.systemZone.NEW[CCObject ¬ [z: Heap.systemZone]];    data.herald ¬ [      String.CopyToNewString["Compiling..."L, data.z],      String.CopyToNewString["Binding..."L, data.z]];    data.name  ¬ [      String.CopyToNewString["Compiler"L, data.z],      String.CopyToNewString["Binder"L, data.z]];    data.logFiles ¬ [      NIL,      String.CopyToNewString["compiler.log"L, data.z],      String.CopyToNewString["binder.log"L, data.z]];    data.searchPathAgent ¬ Supervisor.CreateSubsystem[      agent: SearchPathAgentProc, instanceData: data];    Supervisor.AddDependency[      client: data.searchPathAgent, implementor: Event.fileSystem];    END;      Initialize: PROCEDURE =     BEGIN     data: CCHandle ¬ MakeNewDataObject[];    BuildExecutiveTool[data];     IF ExecUtilities.commandCentralWindow = NIL THEN       ExecUtilities.commandCentralWindow ¬ data.window;    END;  -- Mainline code  Initialize[];  END.
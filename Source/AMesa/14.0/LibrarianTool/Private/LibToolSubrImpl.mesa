-- LibToolSubrImpl.mesa -- Last edited by: DSC on   27-Feb-86 13:44:56-- Copyright (C) 1984, 1985, 1986 by Xerox Corporation. All rights reserved.DIRECTORY  Format USING [Decimal, StringProc],  Heap USING [systemZone],  Librarian USING [    CreatePropertyList, DestroyPropertyList, Error, Handle, NextLibject, nullAtom,    PropertyList],  LibToolCommon USING [AbortProc, AtomArray, QueryMode, WriteProc],  LibToolOps USING [    AtomArray, CheckInLJ, CheckOutLJ, CreateLJ, DestroyLJ, FileNameFromPL,    QueryAndPrint, QueryLJ],  LibToolSubr USING [Command, Handle, Object],  LibToolTransfer USING [Retrieve],  Profile USING [GetLibrarian, String],  String USING [    AppendString, Copy, CopyToNewString, Empty, EmptyString, Length];LibToolSubrImpl: PROGRAM  IMPORTS Heap, Format, Librarian, LibToolOps, LibToolTransfer, Profile, String  EXPORTS LibToolSubr =  {  WriteProc: TYPE = LibToolCommon.WriteProc;  AbortProc: TYPE = LibToolCommon.AbortProc;  AtomArray: TYPE = LibToolCommon.AtomArray;  Handle: TYPE = LibToolSubr.Handle;  Object: TYPE = LibToolSubr.Object;  EnumOps: TYPE = {destroy, count, query};  «  General PROCEDURE to do all the actions that we plan to do. It'scompletely parametrized so that we could call it from the Exec or theTool. It assumes that the connection to the librarian server is alreadycorrectly established. We pay the price of the "SELECT" even if all the callshave the same command parameter, but it keeps things simple and avoidsduplicate code for each action. A good PROCEDURE paramter may solve thisproblem.Some signals that I expect to be raised by certain Libraian procsare caught here so that I could gracefully recover from themrather having the umbrella catch it. This way, if I have multiplelibjects operated upon, then the whole operation does not get aborted.Instead, only the libject used here is killed.Note: If the argument is a wild card, then the wildcount should be returned,Otherwise, the value is "1".»  Action: PUBLIC PROCEDURE [h: Handle, libject: LONG STRING, nLibjects: CARDINAL]    RETURNS [      wasAborted: BOOLEAN ¬ FALSE, stop: BOOLEAN ¬ FALSE,      wildcount: CARDINAL ¬ 0] = {    newrname: LONG STRING ¬ [100];  -- In batch mode, concat(remotename, libjectname).    IF h.checkAbort[] -- upon entry  -- THEN {GOTO aborted; };    IF ~WildPattern[libject] THEN {wildcount ¬ 1; };    SELECT h.command FROM      close => NULL;  -- We took care of this already...      count => {        ENABLE          Librarian.Error => {            IF code = noSuchLibject THEN {              h.Write["Libject: "L];              QWrite[h.Write, libject];              h.Write[" does not exist.\n"L];              GOTO bad}            ELSE {REJECT; }};        [wildcount, wasAborted] ¬ PatternCount[          libject: libject, server: h.server, zone: h.zone, Write: h.Write,          user: h.user, onlyIfCheckedOut: h.onlyIfCheckedOut,          checkAbort: h.checkAbort];        };      checkOut => {        ENABLE          Librarian.Error => {            IF code = noSuchLibject THEN {              h.Write["Libject: "L];              QWrite[h.Write, libject];              h.Write[" does not exist.\n"L];              GOTO bad}            ELSE              IF code = alreadyCheckedOut THEN {                h.Write["Libject: "L];                QWrite[h.Write, libject];                h.Write[" is already checked out.\n"L];                }              ELSE {REJECT}};        IF WildPattern[libject] THEN {          WildGripe["Can't check out a pattern"L, libject, h.Write]; }        ELSE {          s: LONG STRING ¬ [100];          pl: Librarian.PropertyList ¬ Librarian.CreatePropertyList[h.zone];          Cleanup: PROCEDURE = {Librarian.DestroyPropertyList[pl]};          BEGIN          ENABLE UNWIND => Cleanup[];          IF ~ReasonGiven[h.reason] THEN {            h.Write[              "Please supply a check out REASON. Libject was not checked out.\n"L];            RETURN;            };          -- Query the libject to get its remote info.          IF h.retrieve THEN {            [] ¬ LibToolOps.QueryLJ[libject, h.server, h.atoms, @pl];            LibToolOps.FileNameFromPL[pl, h.atoms, h.zone, s];            [] ¬ LibToolTransfer.Retrieve[name: s, h: h];            };          LibToolOps.CheckOutLJ[            lj: libject, reason: h.reason, server: h.server, zone: h.zone,            Write: h.Write];          Cleanup[];          END}};      checkIn => {        ENABLE          Librarian.Error => {            IF code = notCheckedOutToYou THEN {              h.Write["Libject: "L];              QWrite[h.Write, libject];              h.Write[" is not checked out to you.\n"L];              GOTO bad}            ELSE              IF code = notCheckedOut THEN {                h.Write["Libject: "L];                QWrite[h.Write, libject];                h.Write[" is not checked out"L]}              ELSE {REJECT; }};        IF WildPattern[libject] THEN {          WildGripe["Can't check in a pattern"L, libject, h.Write]; }        ELSE {          LibToolOps.CheckInLJ[lj: libject, server: h.server, Write: h.Write]}};      query => {        ENABLE          Librarian.Error => {            IF code = noSuchLibject THEN {              h.Write["Libject: "L];              QWrite[h.Write, libject];              h.Write[" does not exist.\n"L];              GOTO bad}            ELSE {REJECT}};        IF WildPattern[libject] THEN {          [wildcount, wasAborted] ¬ PatternQuery[            libject: libject, server: h.server, queryAtom: h.atoms, zone: h.zone,            Write: h.Write, user: h.user, onlyIfCheckedOut: h.onlyIfCheckedOut,            checkAbort: h.checkAbort, mode: h.queryMode];          }        ELSE {          SimpleQuery[            libject: libject, server: h.server, queryAtom: h.atoms, zone: h.zone,            Write: h.Write, mode: h.queryMode, user: h.user,            onlyIfCheckedOut: h.onlyIfCheckedOut];          }};      create => {        ENABLE          Librarian.Error => {            IF code = libjectAlreadyExists THEN {              h.Write["Libject: "L];              QWrite[h.Write, libject];              h.Write[" already exists.\n"L];              GOTO bad}            ELSE {REJECT; }};        IF WildPattern[libject] THEN {          WildGripe["Can't create a pattern"L, libject, h.Write]; }        ELSE {          IF h.batch THEN {  -- We don't care about the remote name parameter being "unique" per libject.             String.Copy[to: newrname, from: h.remotename];            String.AppendString[to: newrname, from: libject];            WriteNewRemoteName[newrname, h.Write];            LibToolOps.CreateLJ[              lj: libject, rname: newrname, reason: h.reason, server: h.server,              zone: h.zone, Write: h.Write, qAtoms: h.atoms];            }          ELSE {            IF nLibjects = 1 THEN {  -- Safe to do for the first one.              LibToolOps.CreateLJ[                lj: libject, rname: h.remotename, reason: h.reason,                server: h.server, zone: h.zone, Write: h.Write, qAtoms: h.atoms]};            IF (nLibjects > 1) THEN {              h.Write[                "Only the first libject was created for the given remotename parameter.\n"L];              stop ¬ TRUE;              RETURN};            }}};      destroy => {        ENABLE          Librarian.Error => {            IF code = noSuchLibject THEN {              h.Write["Libject: "L];              h.Write[libject];              h.Write[" does not exist.\n"L];              GOTO bad}            ELSE {REJECT; }};        IF WildPattern[libject] THEN {          [wildcount, wasAborted] ¬ PatternDestroy[            libject: libject, server: h.server, zone: h.zone, Write: h.Write,            user: --h.user-- NIL, onlyIfCheckedOut: --h.onlyIfCheckedOut-- FALSE,            checkAbort: h.checkAbort];          }        ELSE {          LibToolOps.DestroyLJ[lj: libject, server: h.server, Write: h.Write]}};      ENDCASE => ERROR;    IF wasAborted -- During one of the operations -- THEN GOTO aborted;    EXITS      aborted => {        stop ¬ TRUE;        h.Write["User abort.\n"L];        RETURN[wasAborted: TRUE, wildcount: 0];        };      bad => {        h.Write["Errors encountered. Continuing with any remaining.\n"L];        RETURN[wasAborted: FALSE, wildcount: 0];        };    };  -- Action  -- Quote a string when writing.  QWrite: PUBLIC PROCEDURE [Write: WriteProc, s: LONG STRING] = {    Write["'"L]; Write[s]; Write["'"L]; };  WildPattern: PUBLIC PROCEDURE [pat: LONG STRING] RETURNS [sure: BOOLEAN] = {    FOR i: CARDINAL IN [0..pat.length) DO      IF pat[i] = '* OR pat[i] = '# THEN RETURN[TRUE]; ENDLOOP;    RETURN[FALSE];    };  GiveWarningsIfAny: PUBLIC PROCEDURE [    command: LibToolSubr.Command, batch: BOOLEAN, Write: WriteProc] = {    IF command # create AND batch THEN {      Write[        "Warning: Batch mode is not applicable for a command other than create.\n"L];      };    };  -- GiveWarningsIfAny  ValidOptions: PUBLIC PROCEDURE [    command: LibToolSubr.Command, batch: BOOLEAN, remotename: LONG STRING,    Write: WriteProc, database, libject: LONG STRING]    RETURNS [yes: BOOLEAN ¬ TRUE] = {    -- Separate out command that require multiple libject parameters. If we do not need them, take care of them here to avoid looping over tokens.     IF command # close AND String.Empty[libject] THEN {      Write["Please enter a libject and try again.\n"L]; RETURN[FALSE]; };    IF String.Empty[database] THEN {  -- Always need a database.      Write["Please enter a database and try again.\n"L]; RETURN[FALSE]};    IF command = create AND String.Empty[remotename] THEN {      Write["For the create command, a remote name is required.\n"L];      RETURN[FALSE];      };    IF command = create AND batch THEN {  -- The rname BETTER END in a > or a /      IF        ~(remotename[String.Length[remotename] - 1] = '/           OR remotename[String.Length[remotename] - 1] = '>) THEN {        Write[          "For the create command in batch mode, a remote name must end in a '> or a '/ since each libject name will be appended to it.\n"L];        RETURN[FALSE];        };      };    };  -- ValidOptions  GetServer: PUBLIC PROCEDURE RETURNS [db: LONG STRING] = {    StuffString: PROCEDURE [str: Profile.String] = {      db ¬ String.CopyToNewString[s: str, z: Heap.systemZone]};    Profile.GetLibrarian[StuffString]};  WriteNewRemoteName: PUBLIC PROCEDURE [newrname: LONG STRING, Write: WriteProc] =    {Write["remotename set to: '"L]; Write[newrname]; Write["'\n"L]; };  -- WriteNewRemoteName  WildGripe: PUBLIC PROCEDURE [msg, pat: LONG STRING, Write: WriteProc] = {    Write[msg]; Write[": '"L]; Write[pat]; Write["'.\n"L]; };  -- WildGripe  Help: PUBLIC PROCEDURE [Write: WriteProc] = {    Write[      "Name: LibrarianToolCommands:Query!	Query each libjects specified in the libject(s) field. 	Wild cards are allowed.CheckIn! Check in each libject specified in the libject(s) field.CheckOut! Check out eachlibject specified in the libject(s) field. 	A reason is REQUIRED. Try putting in something meaningful. 		(don't say FOO!)Destroy! Destroys each libject specifed in the libject(s) field. 	Wild cards allowed.Count! Counts each libject specifed in the libject(s) field. 	Wild cards are allowed. 	A grand total is given is multiple libjects are specified. 	Useful to do before destroying many libjects.	"L];    Write[      "Fields: Database: (STRING)  The librarian database that you want to use. Only one allowed.Libject(s): (STRING) The list of libjects separated by spaces that you want to operate on.  	They may include wildcards that include '# and '* for queries, counting and destroying.Reason: The reason why you want to create or checkout a libject.Remotename: (STRING) A remote file name to be used for two purposes	1) When createing a single libject specified in the libject field, this 	name will be used for the libject's remotename property.	2) When creating MANY libjects specified in the libject field, this	name will be used as a prefix to which each libject will be appended to.	For example, use [Server]<Directory>DF> for libjects	A.df, B.df	will create remotename properties	[Server]<Directory>DF>A.df and	[Server]<Directory>DF>B.df.	The Remotename MUST end in a directory delimitor character which is	either '/ (NS) or '> (IFS) style. Try to make the delimitor match the	type of the server you are using.Batch: (BOOLEAN) Turned on when you want to create mulitple libjects using only 	one Create! command. Otherwise, the tool will complain since it cannot	determine if you want the same remotename for ALL libjects to be created,	or if you want multiple remote names specified. This may be changed.OnlyIfCheckedOut: (BOOLEAN) Is used by the Query, Count or Destroy commands. Only	the libjects which are checked out will be operated on.User: (STRING) Is applicable only when OnlyIfCheckedOut is turned ON. This 	acts as a filter for the libjects only checked out by the 'user'.		"L];    };  SummaryMsg: PUBLIC PROCEDURE [    nFound: CARDINAL, libject, user: LONG STRING, Write: WriteProc,    wasAborted, onlyIfCheckedOut: BOOLEAN] = {    Write["Grand Total Summary\n"L];    TellHowMany[      nFound: nFound, libject: libject, Write: Write, wasAborted: wasAborted,      user: user, onlyIfCheckedOut: onlyIfCheckedOut, done: "encountered"L];    };  -- Per action counts.  TellHowMany: PUBLIC PROCEDURE [    nFound: CARDINAL, libject, user, done: LONG STRING, Write: WriteProc,    wasAborted, onlyIfCheckedOut: BOOLEAN] = {    proc: Format.StringProc = {Write[s]; };    IF nFound = 0 THEN {Write["\nNo libjects matching the pattern: "L]; }    ELSE {      Write["\nTotal of "L];      Format.Decimal[proc, nFound];      Write[" libjects matching the pattern: "L];      };    QWrite[Write, libject];    Write[" were "L];    Write[done];    Write[".\n"L];    IF onlyIfCheckedOut THEN {      Write["Such that they were CHECKED OUT"L];      IF ~String.Empty[user] THEN {Write[" by "L]; QWrite[Write, user]; };      Write[".\n"L];      };    IF wasAborted THEN {      Write[        "However, the enumeration was aborted by the user, thus the figures may be wrong.\n"L];      };    };  -- PRIVATE PROCEDURES  PatternCount: PROCEDURE [    libject, user: LONG STRING, server: Librarian.Handle, zone: UNCOUNTED ZONE,    Write: WriteProc, onlyIfCheckedOut: BOOLEAN, checkAbort: AbortProc]    RETURNS [nFound: CARDINAL ¬ 0, wasAborted: BOOLEAN ¬ FALSE] = {    Write["Counting..."L];    [nFound, wasAborted] ¬ EnumerateLibjects[      libject: libject, user: user, server: server, zone: zone, Write: Write,      onlyIfCheckedOut: onlyIfCheckedOut, checkAbort: checkAbort, op: count,      mode: normal];    Write["Done.\n"L];    TellHowMany[      nFound: nFound, libject: libject, Write: Write, wasAborted: wasAborted,      user: user, onlyIfCheckedOut: onlyIfCheckedOut, done: "counted"L];    };  -- PatternCount  PatternQuery: PROCEDURE [    libject, user: LONG STRING, server: Librarian.Handle, queryAtom: AtomArray,    zone: UNCOUNTED ZONE, Write: WriteProc, onlyIfCheckedOut: BOOLEAN,    checkAbort: AbortProc, mode: LibToolCommon.QueryMode]    RETURNS [nFound: CARDINAL ¬ 0, wasAborted: BOOLEAN ¬ FALSE] = {    Write["------------------\n"L];    Write["Enumeration start.\n"L];    Write["------------------\n"L];    [nFound, wasAborted] ¬ EnumerateLibjects[      libject: libject, user: user, server: server, zone: zone, Write: Write,      onlyIfCheckedOut: onlyIfCheckedOut, checkAbort: checkAbort,      queryAtom: queryAtom, op: query, mode: mode];    TellHowMany[      nFound: nFound, libject: libject, Write: Write, wasAborted: wasAborted,      user: user, onlyIfCheckedOut: onlyIfCheckedOut, done: "found"L];    Write["----------------\n"L];    Write["Enumeration end.\n"L];    Write["----------------\n"L];    };  -- PatternQuery  EnumerateLibjects: PROCEDURE [    libject, user: LONG STRING, server: Librarian.Handle, zone: UNCOUNTED ZONE,    Write: WriteProc, onlyIfCheckedOut: BOOLEAN, checkAbort: AbortProc,    queryAtom: AtomArray ¬ ALL[Librarian.nullAtom], op: EnumOps,    mode: LibToolCommon.QueryMode]    RETURNS [nFound: CARDINAL ¬ 0, wasAborted: BOOLEAN ¬ FALSE] = {    nextLibject: LONG STRING ¬ NIL;    -- Set up initial condition.    nextLibject ¬ Librarian.NextLibject[      handle: server, current: NIL, mask: libject, user: user,      onlyIfCheckedOut: onlyIfCheckedOut];    WHILE (~String.EmptyString[nextLibject]) DO      nFound ¬ SUCC[nFound];      SELECT op FROM        destroy =>          LibToolOps.DestroyLJ[lj: nextLibject, server: server, Write: Write];        query =>          LibToolOps.QueryAndPrint[            lj: nextLibject, server: server, queryAtom: queryAtom, zone: zone,            Write: Write, queryMode: mode];        count => NULL;  -- counting already done         ENDCASE;      IF checkAbort[] THEN {        Write["User abort of enumeration.\n"L]; wasAborted ¬ TRUE; EXIT; };      nextLibject ¬ Librarian.NextLibject[        handle: server, current: nextLibject, mask: libject, user: user,        onlyIfCheckedOut: onlyIfCheckedOut];      ENDLOOP;    };  -- EnumerateLibjects  SimpleQuery: PROCEDURE [    libject, user: LONG STRING, server: Librarian.Handle, queryAtom: AtomArray,    zone: UNCOUNTED ZONE, Write: WriteProc, mode: LibToolCommon.QueryMode,    onlyIfCheckedOut: BOOLEAN] = {    LibToolOps.QueryAndPrint[      lj: libject, server: server, queryAtom: queryAtom, zone: zone, Write: Write,      queryMode: mode, user: user, onlyIfCheckedOut: onlyIfCheckedOut];    Write["\n"L];    };  -- SimpleQuery  PatternDestroy: PROCEDURE [    libject, user: LONG STRING, server: Librarian.Handle, zone: UNCOUNTED ZONE,    Write: WriteProc, onlyIfCheckedOut: BOOLEAN, checkAbort: AbortProc]    RETURNS [nFound: CARDINAL ¬ 0, wasAborted: BOOLEAN ¬ FALSE] = {    Write["------------------\n"L];    Write["Enumerated destroy start.\n"L];    Write["------------------\n"L];    [nFound, wasAborted] ¬ EnumerateLibjects[      libject: libject, user: user, server: server, zone: zone, Write: Write,      onlyIfCheckedOut: onlyIfCheckedOut, checkAbort: checkAbort, op: destroy,      mode: normal];    TellHowMany[      nFound: nFound, libject: libject, Write: Write, wasAborted: wasAborted,      user: user, onlyIfCheckedOut: onlyIfCheckedOut, done: "destroyed"L];    Write["----------------\n"L];    Write["Enumerated destroy end.\n"L];    Write["----------------\n"L];    };  -- PatternDestroy  ReasonGiven: PROCEDURE [reason: LONG STRING] RETURNS [ok: BOOLEAN] = {    ok ¬ ~String.Empty[reason]; };  }...Change log 8-Apr-85 10:43:16	DSC  	Added LibToolCommon.17-Sep-85 15:32:25	DSC  	Made ifCheckout work for non patterns.18-Sep-85 16:29:17	DSC  	Fix AR 7586 about freeing nodes twice.27-Feb-86 11:12:21	DSC  	Fix Antonio's problem with the while stmt on an enumeration I just use one enumerator variable. 
-- LibExecImpl.mesa-- Copyright (C) 1984 by Xerox Corporation. All rights reserved.-- Last edited by: dsc on  8-Apr-85 10:48:23-- What's allowed:-- query [librarian/l] user/u libject [librarian/l] user2/u libject-- query [librarian/l] libject/o-- checkout [librarian/l] reason/r libject-- checkin [librarian/l] libject[/s]DIRECTORY  LibExec, Event, Exec, Format, Librarian, LibToolCommon, LibToolOps, LibToolSubr, String;LibExecImpl: PROGRAM  IMPORTS LibToolSubr, Event, Exec, Librarian, LibToolOps, String  EXPORTS LibExec =  {  Command: TYPE = LibToolSubr.Command;  AbortProc: TYPE = LibToolCommon.AbortProc;  WriteProc: TYPE = LibToolCommon.WriteProc;  AtomArray: TYPE = LibToolCommon.AtomArray;    -- Basically a subst for the CommandRoutine in DFLibToolImpl.  -- Try to mirror the changes. The routines may be combined,  -- but's its sometimes hard. The action routine does the  -- abstraction anyhow....  DoOp: PUBLIC PROCEDURE [h: Exec.Handle, command: Command, zone: UNCOUNTED ZONE]    RETURNS [outcome: Exec.Outcome ¬ error] = {        libject: 	LONG STRING ¬ NIL;  -- Each libject in given list of 1 or more.    switch: 	LONG STRING ¬ NIL;    user: 	LONG STRING ¬ NIL;    reason: 	LONG STRING ¬ NIL;    odb: 	LONG STRING ¬ [100];    db: 	LONG STRING ¬ [100];        onlyIfCheckedOut: 	BOOLEAN ¬ FALSE;    retrieve: 		BOOLEAN ¬ FALSE;    wasLibject: 	BOOLEAN ¬ FALSE;    wasAborted: 	BOOLEAN ¬ FALSE;  -- If user requested stop, grandTotal will be false.    stop: 		BOOLEAN ¬ FALSE;  -- invalid operation = stop going through libjects.        server: 	Librarian.Handle ¬ Librarian.nullHandle;    atoms: 	LibToolCommon.AtomArray ¬ ALL[Librarian.nullAtom];    lhandle: 	LibToolSubr.Handle ¬ zone.NEW[LibToolSubr.Object ¬ []];    handle: 	Event.Handle ¬ Event.StartingProcess["DFLibTool is still running"L];        nLibjects: 	INTEGER ¬ 0;  -- How many tokens given in command line.    count: 	CARDINAL ¬ 0;  -- Count of libjects per operation with wildcards.    grandTotal: CARDINAL ¬ 0;  -- Total libjects per run with wildcards.        Cleanup: PROCEDURE = {      IF lhandle # NIL THEN {zone.FREE[@lhandle]};      IF libject # NIL THEN {libject ¬ Exec.FreeTokenString[libject]};      IF user # NIL THEN {String.FreeString[z: zone, s: user]};      IF reason # NIL THEN {String.FreeString[z: zone, s: reason]};      Event.DoneWithProcess[handle];      LibToolOps.CloseConnection[server: @server, Write: Write];      --FinishCommand[];      };    CheckAbort: AbortProc = {RETURN[Exec.CheckForAbort[h]]};    FreeAndGetNext: PROCEDURE = {      [] ¬ Exec.FreeTokenString[libject];      [] ¬ Exec.FreeTokenString[switch];      [libject, switch] ¬ Exec.GetToken[h: h]};          Write: WriteProc = {      fsp: Format.StringProc ¬ Exec.OutputProc[h]; fsp[s]};          BEGIN    ENABLE {      UNWIND => {Cleanup[]};      Librarian.Error => {        errorString: LONG STRING = [80];        Write["\nLibrarian error of '"L];        Librarian.StringForErrorCode[code, errorString];        Write[errorString];        Write["'.\n"L];        server ¬ Librarian.nullHandle;  -- don't trust server, so smash it.        outcome ¬ error;        GOTO exit};      };  -- of ENABLE    IF Exec.EndOfCommandLine[h] THEN {  -- no args?      HelpFor[command, h];      RETURN[warning];      };    [libject, switch] ¬ Exec.GetToken[h];    WHILE ~(String.Empty[libject] AND String.Empty[switch]) AND ~stop DO      wasLibject ¬ DecodeSwitches[libject, switch, command, @onlyIfCheckedOut, @retrieve, @user, @reason, Write, zone, db];  -- Not a parameter, such as user/u      IF wasLibject THEN {        nLibjects ¬ nLibjects + 1;        -- Changed database, or non specified yet.        IF ~String.Equal[odb, db] OR String.Empty[db] THEN {          IF ~SetLib[db, @server, Write, odb, @atoms, zone] THEN EXIT};	SetHandle[lhandle, command, CheckAbort, Write, reason, user, atoms, server, onlyIfCheckedOut, retrieve, zone];        [wasAborted, stop, count] ¬ LibToolSubr.Action[h: lhandle, libject: libject, nLibjects: nLibjects];        grandTotal ¬ grandTotal + count;        };      FreeAndGetNext[];    ENDLOOP;    SELECT TRUE FROM      nLibjects > 1 => {  -- Useful only when they are multiple args.	SELECT command FROM	  query => {	    LibToolSubr.SummaryMsg[	      nFound: grandTotal, libject: "your args"L, user: user, Write: Write,	      wasAborted: wasAborted, onlyIfCheckedOut: onlyIfCheckedOut]};	  ENDCASE => NULL};      nLibjects = 0 => {Write["No libjects?.\n"L]; HelpFor[command, h]};        ENDCASE;    Write["Done.\n-----\n"L];    Cleanup[];    RETURN[IF wasAborted THEN abort ELSE normal];    EXITS exit => Cleanup[];    END};        SetHandle: PROCEDURE [lhandle: LibToolSubr.Handle, command: Command, CheckAbort: AbortProc, Write: WriteProc, reason, user: LONG STRING, atoms: LibToolCommon.AtomArray,  server: Librarian.Handle, onlyIfCheckedOut, retrieve: BOOLEAN, zone: UNCOUNTED ZONE] = {      lhandle.command ¬ command;      lhandle.checkAbort ¬ CheckAbort;      lhandle.Write ¬ Write;      lhandle.reason ¬ reason;      lhandle.retrieve ¬ retrieve;      lhandle.remotename ¬ NIL;      lhandle.batch ¬ FALSE;      lhandle.atoms ¬ atoms;      lhandle.server ¬ server;      lhandle.onlyIfCheckedOut ¬ onlyIfCheckedOut;      lhandle.user ¬ user;      lhandle.zone ¬ zone;    };        -- Sets the switch variables.     -- Returns     --   TRUE 	if there is libject for the token     --   FALSE 	if a parameter (such as user) or just a switch.    DecodeSwitches: PROCEDURE [tok, switch: LONG STRING, command: Command, onlyIfCheckedOut, retrieve: LONG POINTER TO BOOLEAN, user, reason: LONG POINTER TO LONG STRING, Write: WriteProc, zone: UNCOUNTED ZONE, db: LONG STRING] RETURNS [inc: BOOLEAN ¬ FALSE] = {      -- Set all previous swithes to default.      IF switch = NIL THEN RETURN[TRUE];      onlyIfCheckedOut­ ¬ FALSE;      String.FreeString[z: zone, s: user­];      user­ ¬ NIL;      «      String.FreeString[z: zone, s: reason­];      reason­ ¬ NIL;      »      -- Set the boolean and LONG STRING flags...       IF switch.length > 1 THEN {        Write["switch could be only one letter: '"L];        Write[switch];        Write["'.\n"L];        };      -- u switch implicitly means onlyIfCheckedOut .      SELECT switch[0] FROM        's => {	    IF command # checkOut THEN {Write["s switch usable only for checkOut.\n"L]}	    ELSE IF tok = NIL THEN {Write["must specify a libject for 's' switch.\n"L]}	    ELSE {retrieve­ ¬ TRUE; inc ¬ TRUE}};        'l => {          IF tok = NIL 	    THEN {Write["must specify a librarian for 'l' switch.\n"L]}	  ELSE {String.Copy[to: db, from: tok]}};        'u => {          IF command # query 	    THEN {Write["u switch usable only for queries.\n"L]}	  ELSE {            String.Replace[to: user, from: tok, z: zone];            onlyIfCheckedOut­ ¬ TRUE}};        'o => {          IF command # query 	    THEN {Write["o switch usable only for queries.\n"L]}          ELSE {onlyIfCheckedOut­ ¬ TRUE; 	        inc ¬ TRUE}};        'r => {          IF command # checkOut THEN {            Write["r switch usable only for checkouts.\n"L]}          ELSE {	    String.Replace[to: reason, from: tok, z: zone]}};        ENDCASE => {Write["Unknown switch: '"L]; Write[switch]; Write["'.\n"L]};      };         SetLib: PROCEDURE [db: LONG STRING, server: LONG POINTER TO Librarian.Handle, Write: WriteProc, odb: LONG STRING, atoms: LONG POINTER TO LibToolCommon.AtomArray, zone: UNCOUNTED ZONE] RETURNS [ok: BOOLEAN ¬ TRUE] = {      -- db is empty if the user didn't specify.      IF String.Empty[db] THEN {        String.Copy[to: db, from: LibToolSubr.GetServer[]];        IF String.Empty[db] THEN {          Write["No librarian specified in Profile entry.\n"L]; RETURN[FALSE]; };        }      ELSE {  -- User did specify, or we have a new server (multiple librarian/l lines).        IF server­ # Librarian.nullHandle THEN          LibToolOps.CloseConnection[server: server, Write: Write];        };      server­ ¬ LibToolOps.OpenConnection[        servername: db, zone: zone, Write: Write];  -- But open one ANYHOW.      String.Copy[to: odb, from: db];  -- Save the old one to detect new libnames.      LibToolOps.MakeQueryAtoms[server­, atoms];      };  HelpFor: PROCEDURE [command: Command, h: Exec.Handle] = {      SELECT command FROM        checkOut => [] ¬ EHelpCO[h];        checkIn => [] ¬ EHelpCI[h];        query => [] ¬ EHelpQ[h];        ENDCASE => ERROR;  };    EHelpCI: PUBLIC Exec.ExecProc = {    fsp: Format.StringProc ¬ Exec.OutputProc[h];    Write: WriteProc = {fsp[s]};    Write["Usage: CheckInLibject.~ [librarian/l] libject...\n"L];    };      EHelpCO: PUBLIC Exec.ExecProc = {    fsp: Format.StringProc ¬ Exec.OutputProc[h];    Write: WriteProc = {fsp[s]};    Write["Usage: CheckOutLibject.~ [librarian/l] reason/r libject[/s]...-- checks out libject with given reason. /s retrieves files.\n"L];    };      EHelpQ: PUBLIC Exec.ExecProc = {    fsp: Format.StringProc ¬ Exec.OutputProc[h];    Write: WriteProc = {fsp[s]};    Write["Usage: QueryLibject.~  [librarian/l] libject[/o] | [user/u] libject...-- queries all libjects [checked out][by user]. Wild cards (* & #) allowed.\n"L];    };  }...    Change log  30-Jan-85 13:33:32	DSC  	Rename to (ugh) LibrarianTool   8-Apr-85 10:48:34	DSC  	Add LibToolCommon
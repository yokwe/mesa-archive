-- LibToolOpsImpl.mesa-- Copyright (C) 1984 by Xerox Corporation. All rights reserved.-- Last edited by DSC on  17-Sep-85 16:39:05DIRECTORY  Auth,  FileName,  Format,  LibToolCommon,  LibToolOps,  Librarian,  Profile,  String;LibToolOpsImpl: PROGRAM  IMPORTS Auth, FileName, Format, Librarian, Profile, String EXPORTS LibToolOps =  {  WriteProc: TYPE = LibToolCommon.WriteProc;  AtomArray: TYPE = LibToolCommon.AtomArray;  QueryMode: TYPE = LibToolCommon.QueryMode;  MaxString: INTEGER = 100;  -- Public procedures.  OpenConnection: PUBLIC PROCEDURE [    servername: LONG STRING, zone: UNCOUNTED ZONE, Write: WriteProc]    RETURNS [server: Librarian.Handle] = {    idCopy: Auth.IdentityHandle ¬ NIL;    LibOpen: PROCEDURE [id: Auth.IdentityHandle] = {      idCopy ¬ Auth.CopyIdentity[id, zone]};          Write["Opening connection to '"L]; Write[servername]; Write["' ..."L];    -- Get copy of IdentityHandle.    Profile.GetID[proc: LibOpen];    server ¬ Librarian.Open[servername, idCopy, zone];    Auth.FreeIdentity[@idCopy, zone];    Write[" done.\n"L];    };  -- of OpenConnection  CloseConnection: PUBLIC PROCEDURE [    server: LONG POINTER TO Librarian.Handle, Write: WriteProc] = {    IF server­ # Librarian.nullHandle THEN {      Write["Closing connection ..."L];      Librarian.Close[        server­ ! Librarian.Error => IF code = invalidHandle THEN CONTINUE];      Write[" done.\n"L]};    server­ ¬ Librarian.nullHandle;    };  -- of CloseConnection        QueryLJ: PUBLIC PROCEDURE [    lj: LONG STRING, server: Librarian.Handle, queryAtom: AtomArray, pl: LONG POINTER TO Librarian.PropertyList] RETURNS [libjectCheckedOut: BOOLEAN]  = {      [pl­, libjectCheckedOut] ¬ Librarian.Query[      handle: server, libject: lj,      what: DESCRIPTOR[BASE[queryAtom], LENGTH[queryAtom]]];  };    -- I pay the price of a CreatePropertyList even if the queryMode is terse.  -- Should fix that.  QueryAndPrint: PUBLIC PROCEDURE [    lj: LONG STRING, server: Librarian.Handle, queryAtom: AtomArray,    zone: UNCOUNTED ZONE, Write: WriteProc, queryMode: QueryMode ¬ normal, onlyIfCheckedOut: BOOLEAN ¬ FALSE, user: LONG STRING ¬ NIL] = {    pl: Librarian.PropertyList ¬ Librarian.CreatePropertyList[zone];    libjectCheckedOut: BOOLEAN ¬ FALSE;    unKnown: LONG STRING ¬ "Unknown "L;    Cleanup: PROCEDURE = {Librarian.DestroyPropertyList[pl]};    BEGIN ENABLE UNWIND => Cleanup[];    GetStrProp: PROCEDURE [plist: Librarian.PropertyList, tag: Librarian.Atom]      RETURNS [answer: LONG STRING] = {      ENABLE Librarian.WrongPropertyType => {answer ¬ unKnown; GOTO exit; };      answer ¬ Librarian.GetStringProperty[plist: plist, tag: tag];      EXITS exit => NULL;      };    GetCOUser: PROCEDURE RETURNS [LONG STRING] = {     RETURN[GetStrProp[plist: pl, tag: queryAtom[checkOutUserAtom]]];    };    UserOk: PROCEDURE [pl: Librarian.PropertyList, user: LONG STRING] RETURNS [BOOLEAN] = {     RETURN[String.Equivalent[user, GetCOUser[]]];    };    WorthShowing: PROCEDURE RETURNS[BOOLEAN] = {     RETURN[~onlyIfCheckedOut -- Show anything     OR (onlyIfCheckedOut AND libjectCheckedOut AND user = NIL) -- without User     OR (onlyIfCheckedOut  AND libjectCheckedOut AND user # NIL AND UserOk[pl, user]) -- With user and user matches what was given.     ]    };    IF server = Librarian.nullHandle THEN {      Write["No connection established.\n"L]; RETURN};  -- Should never happen    libjectCheckedOut ¬ QueryLJ[lj, server, queryAtom, @pl];    SELECT queryMode FROM    normal => {      Write["Querying '"L];      Write[lj];      Write["' ..."L];      -- This boolean business is clearly suboptimal.      IF WorthShowing[] THEN  {      DisplayQueryPropertyList[pl: pl, isCheckedOut: libjectCheckedOut, lj: lj, qAtoms: queryAtom,	zone: zone, Write: Write]};      IF onlyIfCheckedOut AND ~libjectCheckedOut AND  user = NIL THEN {Write[lj]; Write[" not checked out\n"L]};      IF onlyIfCheckedOut AND libjectCheckedOut AND user # NIL AND ~UserOk[pl, user] THEN {         Write[lj]; Write[" not checked out by: '"L]; Write[user]; Write["' but by: '"L]; Write[GetCOUser[]]; Write["'.\n"L];      };    };    terse => {      IF WorthShowing[] THEN {      Write[lj];      Write[" "L]};    };    ENDCASE;    Cleanup[];    END};  -- of QueryLJ  CreateLJ: PUBLIC PROCEDURE [    lj, rname, reason: LONG STRING, server: Librarian.Handle,    zone: UNCOUNTED ZONE, Write: WriteProc, qAtoms: AtomArray] = {    host, dir, name: LONG STRING ¬ NIL;    version: LONG INTEGER ¬ 0;    vfn: FileName.VFN ¬ NIL;    pl: Librarian.PropertyList ¬ Librarian.CreatePropertyList[zone];    Cleanup: PROCEDURE = {	IF vfn # NIL THEN {FileName.FreeVFN[vfn]; vfn ¬ NIL};	IF pl # NIL THEN {Librarian.DestroyPropertyList[pl]};    };    BEGIN      ENABLE UNWIND => {Cleanup[]};      IF server = Librarian.nullHandle THEN {	Write["No connection established.\n"L]; Cleanup[]; RETURN};      IF String.Empty[rname] THEN {	Write["Please supply a remotename of the form: '[host]<dir1>dir2>...dirN>filename'.\n"L];	Cleanup[];	RETURN};      vfn ¬ FileName.AllocVFN[rname ! FileName.Error => {Cleanup[]; GOTO exit}];      IF vfn.host = NIL THEN {Write["NIL host.\n"L]; GOTO exit};      IF vfn.directory = NIL THEN {Write["NIL dir.\n"L]; GOTO exit};      IF vfn.name = NIL THEN {Write["NIL name.\n"L]; GOTO exit};      Write["Creating '"L];      Write[lj];      Write["' ..."L];      Librarian.Create[server, lj];  -- Will fail if libject already exists.      Write[" done.\n"L];      -- Now the libject is checked out.      Librarian.AddStringProperty[plist: pl, tag: qAtoms[hostAtom], string: vfn.host];      Librarian.AddStringProperty[plist: pl, tag: qAtoms[directoryAtom], string: vfn.directory];      Librarian.AddStringProperty[plist: pl, tag: qAtoms[nameAtom], string: vfn.name];      Librarian.AddStringProperty[plist: pl, tag: qAtoms[reasonAtom],string: IF ReasonGiven[reason] THEN reason ELSE "Initial creation."L];      -- Should set the version property too. The VFN version contains a string, so must convert that to a number first.      IF vfn.version # NIL THEN {       -- Don't do this if the version is not an integer.	version ¬ String.StringToLongNumber[s: vfn.version ! String.InvalidNumber => GOTO skip;];	Librarian.AddIntegerProperty[pl, qAtoms[versionAtom], version];	EXITS skip => {Write["Remote file name's version is not a number, so it is left blank.\n"];};      };      Librarian.SetPropertiesAndCheckIn[handle: server, libject: lj, pl: pl];      END;  -- of ENABLE      Cleanup[];      EXITS exit => {Write["remote name cannot be parsed.\n"L]; };    };  -- of CreateLJ  DestroyLJ: PUBLIC PROCEDURE [    lj: LONG STRING, server: Librarian.Handle, Write: WriteProc] = {    IF server = Librarian.nullHandle THEN {Write["No connection established.\n"L]}    ELSE {      Write["Destroying '"L];      Write[lj];      Write["' ..."L];      Librarian.Destroy[server, lj];      Write[" done.\n"L]}};  -- of DestroyLJ  CheckOutLJ: PUBLIC PROCEDURE [    lj, reason: LONG STRING, server: Librarian.Handle, zone: UNCOUNTED ZONE,    Write: WriteProc] = {    reasonAtom: Librarian.Atom ¬ Librarian.MakeAtom[server, "Reason"L];    pl: Librarian.PropertyList ¬ Librarian.CreatePropertyList[zone];    Cleanup: PROCEDURE = {Librarian.DestroyPropertyList[pl]; };    -- A libject MUST have a reason string.    -- For example, if Reason = NIL, or empty, we will have    -- trouble when we query it later.     -- Use an extra BLOCK to get the variables accessible in the EXITS clause.    BEGIN    ENABLE UNWIND => Cleanup[];    IF ~ReasonGiven[reason] THEN {      Write["Please supply a check out REASON. Libject was not checked out.\n"L];      }    ELSE {      Write["Check out '"L];      Write[lj];      Write["' ..."L];      Librarian.CheckOut[        handle: server, libject: lj !        Librarian.Error =>          IF code = alreadyCheckedOut THEN {            Write["Already checked out.\n"L]; Cleanup[]; GOTO quit}; ];      Librarian.AddStringProperty[plist: pl, tag: reasonAtom, string: reason];      Librarian.SetPropertiesAndCheckIn[        handle: server, libject: lj, pl: pl !        Librarian.Error => IF code = notCheckedOutToYou THEN CONTINUE];      Librarian.CheckOut[handle: server, libject: lj];      Write[" done.\n"L];      };    Cleanup[];    EXITS quit => NULL;    END};  -- of CheckOut  CheckInLJ: PUBLIC PROCEDURE [    lj: LONG STRING, server: Librarian.Handle, Write: WriteProc] = {    ENABLE {      Librarian.Error => {        IF code = notCheckedOut THEN {Write["Not checked out.\n"L]; CONTINUE; }        ELSE {REJECT; };        };      };    Write["Check in '"L];    Write[lj];    Write["' ..."L];    Librarian.CheckIn[handle: server, libject: lj];    Write["done.\n"L]};  --Private procedures.  -- Display the Librarian property list in the FormSW.  DisplayQueryPropertyList: PUBLIC PROCEDURE [    pl: Librarian.PropertyList, isCheckedOut: BOOLEAN, lj: LONG STRING,    qAtoms: AtomArray, zone: UNCOUNTED ZONE, Write: WriteProc] = {    AppendVal: Format.StringProc = {      String.Copy[convertedStr, s ! String.StringBoundsFault => RESUME ]};  -- of AppendVal    -- Get all string properties this way to catch the signal the "right" way.    unKnown: LONG STRING = "Unknown"L;    GetStrProp: PROCEDURE [plist: Librarian.PropertyList, tag: Librarian.Atom]      RETURNS [answer: LONG STRING] = {      ENABLE Librarian.WrongPropertyType => {answer ¬ unKnown; GOTO exit; };      answer ¬ Librarian.GetStringProperty[plist: plist, tag: tag];      EXITS exit => NULL;      };    -- For formatted strings.    convertedStr: LONG STRING ¬ [MaxString];    checkOutUser, changeTime, host, directory, name, version, create, reason: LONG      STRING ¬ NIL;    checkOutUser ¬ GetStrProp[plist: pl, tag: qAtoms[checkOutUserAtom]];    host ¬ GetStrProp[plist: pl, tag: qAtoms[hostAtom]];    directory ¬ GetStrProp[plist: pl, tag: qAtoms[directoryAtom]];    name ¬ GetStrProp[plist: pl, tag: qAtoms[nameAtom]];    reason ¬ GetStrProp[plist: pl, tag: qAtoms[reasonAtom]];    Format.Date[      proc: AppendVal,      pt: Librarian.GetTimeProperty[      plist: pl, tag: qAtoms[changeTimeAtom] !      Librarian.WrongPropertyType => {convertedStr ¬ unKnown; CONTINUE; }],      format: mailDate];    changeTime ¬ String.CopyToNewString[s: convertedStr, z: zone];    Format.LongDecimal[      proc: AppendVal,      n: Librarian.GetIntegerProperty[      plist: pl, tag: qAtoms[versionAtom] !      Librarian.WrongPropertyType => {convertedStr ¬ unKnown; CONTINUE; }]];    version ¬ String.CopyToNewString[s: convertedStr, z: zone];    Format.Date[      proc: AppendVal,      pt: Librarian.GetTimeProperty[      plist: pl, tag: qAtoms[createAtom] !      Librarian.WrongPropertyType => {convertedStr ¬ unKnown; CONTINUE; }],      format: full];    create ¬ String.CopyToNewString[s: convertedStr, z: zone];    Write["\n-------------------\n"L];    Write["Query of:\t'"L];    Write[lj];    Write["'"L];    Write[IF isCheckedOut THEN "(checked out)\n"L ELSE "(checked in)\n"L];    Write["Checkout/in by:\t'"L];    Write[checkOutUser];    Write["'\n"L];    Write["Checkout/in at:\t'"L];    Write[changeTime];    Write["'\n"L];    Write["Remote file:\t'"L];    Write["["L];    Write[host];    Write["]"L];    Write[directory];    Write[">"L];    Write[name];    Write["!"L];    Write[version];    Write["'\n"L];    Write["Create Date:\t'"L];    Write[create];    Write["'\n"L];    Write["Checkout Reason:\t'"L];    Write[reason];    Write["'\n"L];    Write["-------------------\n"L];    String.FreeString[z: zone, s: changeTime];    String.FreeString[z: zone, s: version];    String.FreeString[z: zone, s: create];    };  -- of DisplayQueryPropertyList      -- Client should pass in a string long enough to handle the typical filenames. Will fix to take expandable  FileNameFromPL: PUBLIC PROCEDURE [pl: Librarian.PropertyList, qAtoms: AtomArray, zone: UNCOUNTED ZONE, s: LONG STRING] = {   host, directory, name: LONG STRING ¬ NIL;   version: LONG STRING ¬ [3]; -- Versions are usually less than 4 digits.   AppendVal: Format.StringProc = {String.Copy[version, s ! String.StringBoundsFault => RESUME ]};   host ¬ GSP[plist: pl, tag: qAtoms[hostAtom]];   directory ¬ GSP[plist: pl, tag: qAtoms[directoryAtom]];   name ¬ GSP[plist: pl, tag: qAtoms[nameAtom]];   Format.LongDecimal[proc: AppendVal,n: Librarian.GetIntegerProperty[plist: pl, tag: qAtoms[versionAtom] !      Librarian.WrongPropertyType => {version ¬ NIL; CONTINUE; }]];   String.AppendChar[s, '[];   String.AppendString[s, host];   String.AppendChar[s, ']];   String.AppendString[s, directory];   String.AppendChar[s, '>];   String.AppendString[s, name];   IF version # NIL THEN {     String.AppendChar[s, '!];     String.AppendString[s, version];   };  };    GSP: PROCEDURE [plist: Librarian.PropertyList, tag: Librarian.Atom]    RETURNS [answer: LONG STRING] = {    ENABLE Librarian.WrongPropertyType => {answer ¬ NIL; GOTO exit; };    answer ¬ Librarian.GetStringProperty[plist: plist, tag: tag];    EXITS exit => NULL;  };  MakeQueryAtoms: PUBLIC PROCEDURE [    server: Librarian.Handle, qAtoms: LONG POINTER TO AtomArray] = {    -- Reserved atoms.    qAtoms[checkOutUserAtom] ¬ Librarian.MakeAtom[      handle: server, s: "CheckOutUser"L];    qAtoms[changeTimeAtom] ¬ Librarian.MakeAtom[handle: server, s: "ChangeTime"L];    -- For our application.    qAtoms[hostAtom] ¬ Librarian.MakeAtom[handle: server, s: "host"L];    qAtoms[directoryAtom] ¬ Librarian.MakeAtom[handle: server, s: "directory"L];    qAtoms[nameAtom] ¬ Librarian.MakeAtom[handle: server, s: "name"L];    qAtoms[versionAtom] ¬ Librarian.MakeAtom[handle: server, s: "version"L];    qAtoms[createAtom] ¬ Librarian.MakeAtom[handle: server, s: "create"L];    qAtoms[reasonAtom] ¬ Librarian.MakeAtom[handle: server, s: "reason"L];    };  -- of MakeQueryAtoms  --Private procedures.    ReasonGiven: PROCEDURE [reason: LONG STRING] RETURNS [ok: BOOLEAN] = {    ok ¬ ~String.Empty[reason]; };  }...Change log 8-Apr-85 10:46:34	DSC  	Added LibToolCommon 6-May-85 11:30:08	DSC  	Fixed Open so that I/O does not occure within the Profile monitor (lock).12-Jul-85 14:04:18	DSC  	Add trap to String.InvalidNumber12-Sep-85 15:08:20	DSC  	Call Auth.{Copy, Free}Identity17-Sep-85 15:47:23	DSC  	Fix QueryAndPrint for onlyIfCheckedOut 
-- File: LibToolImpl.mesa Last edited by: -- 	DSC   16-Sep-85 12:37:27-- Copyright (C) 1984 by Xerox Corporation. All rights reserved.«Description: A tool for managing libjects (librarian objects) The properties are set by the tool for the DF related stuff. Currently, you can query, checkin/out, delete and create libjects. Creating batch mode takes the Remotename, and appends the libject  names to it. When not in batch mode, only one libject may be created since the whole remotename is used.»DIRECTORY  CmFile USING [Close, Error, FindSection, Handle, NextValue, TableError, UserDotCmOpen],  Event USING [DoneWithProcess, Handle, Object, StartingProcess, toolWindow],  EventTypes USING [deactivate],  Exec USING [AddCommand, ExecProc, Handle, Object, Outcome, OutputProc, RemoveCommand],  Format USING [StringProc],  FormSW USING [AllocateItemDescriptor, BooleanItem, ClientItemsProcType, CommandItem, Destroy, Display, Enumerated, EnumeratedItem, EnumeratedNotifyProcType, FindItem, ItemHandle, line0, line1, line2, line4, line5, line6, LineN, nullIndex, ProcType, SetTypeIn, StringItem],  Heap USING [Create, Delete, systemZone],  LibExec USING [DoOp, EHelpCI, EHelpCO, EHelpQ],  Librarian USING [Error, Handle, nullAtom, nullHandle, StringForErrorCode],  LibToolCommon USING [AbortProc, AtomArray, WriteProc],  LibToolOps USING [AtomArray, CloseConnection, MakeQueryAtoms, OpenConnection],  LibToolSubr USING [Action, Command, GetServer, GiveWarningsIfAny, Handle, Help, Object, SummaryMsg, ValidOptions],  MFile USING [maxNameLength],  Process USING [Detach],  Put USING [CR, Line, Text],  Runtime USING [GetBcdTime, IsBound],  String USING [AppendChar, AppendString, CopyToNewString, Empty, Equal, FreeString, Replace],  StringLookUp USING [noMatch, TableDesc],  Supervisor USING [AddDependency, AgentProcedure, CreateSubsystem, EnumerationAborted, RemoveDependency, SubsystemHandle],  Time USING [Append, Unpack],  Token USING [Filtered, FreeTokenString, Handle, Item, NonWhiteSpace, StringToHandle],  Tool USING [Create, Destroy, MakeFileSW, MakeFormSW, MakeMsgSW, MakeSWsProc, UnusedLogName],  ToolWindow USING [Activate, TransitionProcType],  UserInput USING [UserAbort],  Window USING [Handle, Object],  WindowFont USING [CharWidth];LibToolImpl: MONITOR  IMPORTS CmFile, LibExec, LibToolSubr, Event, Exec, FormSW, Heap, Librarian, LibToolOps, Process, Put, Runtime, String, Supervisor, Time, Tool, Token, ToolWindow, UserInput, WindowFont = {  WriteProc: TYPE = LibToolCommon.WriteProc;  AbortProc: TYPE = LibToolCommon.AbortProc;  AtomArray: TYPE = LibToolCommon.AtomArray;    ItemsHandle: TYPE = LONG POINTER TO Items;  Items: TYPE = RECORD [  -- Extra fields are for word alignment without making this machine dependent.    database: LONG STRING ¬ NIL, 	foo1: WORD ¬ 0,    libjects: LONG STRING ¬ NIL, 	foo2: WORD ¬ 0,    reason: LONG STRING ¬ NIL, 		foo3: WORD ¬ 0,    remotename: LONG STRING ¬ NIL,  	foo4: WORD ¬ 0,    batch: BOOLEAN ¬ FALSE, 		foo5: WORD  ¬ 0,    onlyIfCheckedOut: BOOLEAN ¬ FALSE,	foo6: WORD ¬ 0,    user: LONG STRING ¬ NIL,    	foo7: WORD ¬ 0,    retrieve: BOOLEAN ¬ FALSE,    	foo8: WORD ¬ 0,    mode: UNSPECIFIED ¬ 0,    		foo9: WORD ¬ 0,    queryMode: UNSPECIFIED ¬ 0,    	foo10: WORD ¬ 0,    localDir:  LONG STRING ¬ NIL,    	foo11: WORD ¬ 0,    output: UNSPECIFIED ¬ 0,    	foo12: WORD ¬ 0,    condition: UNSPECIFIED ¬ 0   ];     -- User mode selects visibility of form items.  Mode: TYPE = {queryMode, checkinoutMode, adminMode};    FormItems: TYPE = {mode, close, database, libjects, query, count, output, condition, user, reason, checkIn, checkOut, retrieve, localDir, batch, remotename, destroy, create};    -- Each item has a ModeKey that determines its visibility.  ModeKey: TYPE = ARRAY Mode OF BOOLEAN;      DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = RECORD [    msgSW: Window.Handle ¬ NIL,    formSW: Window.Handle ¬ NIL,    fileSW: Window.Handle ¬ NIL,    visibilityTable: ARRAY FormItems OF ModeKey ¬ ALL[ALL[FALSE]],    windowItems: ItemsHandle ¬ NIL,    windowItemsCopy: ItemsHandle ¬ NIL,    server: Librarian.Handle ¬ Librarian.nullHandle,    atoms: LibToolCommon.AtomArray ¬ ALL[Librarian.nullAtom]];  -- Global variables.  data: DataHandle ¬ NIL;  wh: Window.Handle ¬ NIL;  zone: UNCOUNTED ZONE ¬ NIL;  inactive: BOOLEAN ¬ TRUE;    -- Synchronization data.  commandIsRunning: BOOLEAN ¬ FALSE;  untilDone: CONDITION;  agent: Supervisor.SubsystemHandle = Supervisor.CreateSubsystem[CheckDeactivate];  CheckDeactivate: Supervisor.AgentProcedure = {    IF event = EventTypes.deactivate AND wh # NIL AND wh = eventData      AND commandIsRunning THEN {      Put.Line[data.msgSW, "The LibrarianTool is still processsing a command: aborting deactivation"L];      ERROR Supervisor.EnumerationAborted}};  -- CheckDeactivate  -- Show the fields relevant to the commands in question.  -- Should fix to avoid using constants [0..2] here.    ModeChange:  FormSW.EnumeratedNotifyProcType = {    m: Mode ¬ SELECT data.windowItems.mode FROM    = 0 =>  queryMode,    = 1 =>  checkinoutMode,     = 2 =>  adminMode,    ENDCASE => queryMode;    SetUserVisibility[data.windowItems.condition, data.formSW];    SetVisibility[mode: m, w: data.formSW];    FormSW.SetTypeIn[sw: data.formSW, index: FormSW.nullIndex, position: 0];  -- Avoid having the type-in at an invisible field.    FormSW.Display[sw: data.formSW]};      -- The user field turns on only when requested.  -- TODO: Make sure that the user field is filled in  -- when the "by user" is chosen.  ConditionChange: FormSW.EnumeratedNotifyProcType = {    SetUserVisibility[data.windowItems.condition, data.formSW];    FormSW.Display[sw: data.formSW];  };    -- Set up the visibility translation table.  InitVisiTable: PROCEDURE =  {      -- Go through each item in the FormItems to make sure    -- that they have values for all modes.    FOR item: FormItems IN [mode..libjects] DO      FOR m: Mode IN Mode DO         data.visibilityTable[item][m] ¬ TRUE;    ENDLOOP; ENDLOOP;        -- The three modes are QueryMode, CheckInOut and Admin.        -- QueryMode    FOR item: FormItems IN [query..user] DO      data.visibilityTable[item][queryMode] ¬ TRUE;    ENDLOOP;    -- CheckInOut.    FOR item: FormItems IN [reason..localDir] DO      data.visibilityTable[item][checkinoutMode] ¬ TRUE;    ENDLOOP;    -- Admin.    FOR item: FormItems IN [batch..create] DO      data.visibilityTable[item][adminMode] ¬ TRUE;    ENDLOOP;  };  -- set the visibility relevant to the "mode" passed in.    SetVisibility: PROCEDURE [mode: Mode, w: Window.Handle] = {    ih: FormSW.ItemHandle;    -- For this mode, set the visibility to what's needed.    FOR item: FormItems IN FormItems DO       ih ¬ FormSW.FindItem[sw: w, index: item.ORD];       ih.flags.invisible ¬ ~data.visibilityTable[item][mode];    ENDLOOP;  };      -- Used for setting the "user" field on depending on the query mode.  -- Should fix to avoid using constants.  SetUserVisibility: PROCEDURE[m: UNSPECIFIED, w: Window.Handle] = {    ih: FormSW.ItemHandle;    invis: BOOLEAN;    ih ¬ FormSW.FindItem[sw: w, index: FormItems.user.ORD];    SELECT m FROM      0 => -- all -- invis ¬ TRUE;      1 => -- if checked out -- invis ¬ TRUE;      2 => -- if checked out by user  -- invis ¬ FALSE;    ENDCASE => ERROR;    ih.flags.invisible ¬ invis;    FormSW.SetTypeIn[sw: data.formSW, index: FormSW.nullIndex, position: 0];   };    -- Conver the form item to the internal command enumeration.    FormItemToCommand: PROCEDURE [fi: FormItems] RETURNS [cm: LibToolSubr.Command] = {    cm ¬ SELECT fi FROM        query => query,        checkIn => checkIn,        destroy => destroy,        close => close,        count => count,        checkOut => checkOut,        create => create        ENDCASE => ERROR};   -- Main entry proc for tool.  CommandProc: FormSW.ProcType = {    fi: FormItems = VAL[index];    IF StartCommand[] THEN {Process.Detach[FORK CommandRoutine[FormItemToCommand[fi]]]}};       StartCommand: PROC RETURNS [ok: BOOLEAN] = {    IF ~Enter[] THEN {Put.Line[data.msgSW, "Tool still busy."L]; ok ¬ FALSE}    ELSE {Put.CR[data.msgSW]; ok ¬ TRUE};    RETURN};   FinishCommand: PROC = {Leave[]};   -- Forked off proc. Will snapshot all data.  CommandRoutine: PROCEDURE [command: LibToolSubr.Command] = {    libject: LONG STRING ¬ NIL; -- Each libject parsed from list.    th: Token.Handle ¬ NIL;  -- Token handle for scanning the libject list.    nLibjects: INTEGER ¬ 0; 	-- How many tokens given in command line.    handle: Event.Handle ¬ Event.StartingProcess["LibrarianTool is still running"L];    count: CARDINAL ¬ 0;  -- Count of libjects PER operation with wildcards.    grandTotal: CARDINAL ¬ 0;  -- Total libjects per run with wildcards.    wasAborted: BOOLEAN ¬ FALSE;  -- If user requested stop, grandTotal will be false.    stop: BOOLEAN ¬ FALSE;  -- invalid operation = stop going through libjects.    lhandle: LibToolSubr.Handle ¬ zone.NEW[LibToolSubr.Object ¬ []];    localDir: LONG STRING ¬ [MFile.maxNameLength]; -- local directory for retrievals.    Cleanup: PROCEDURE = {      IF libject # NIL THEN {libject ¬ Token.FreeTokenString[libject]};      IF lhandle # NIL THEN {zone.FREE[@lhandle]};      Event.DoneWithProcess[handle];      FinishCommand[]};        FreeAndGetNext: PROCEDURE [s: LONG STRING] = {      [] ¬ Token.FreeTokenString[libject];      libject ¬ Token.Filtered[h: th, data: NIL, filter: Token.NonWhiteSpace]};          BEGIN  ENABLE {      UNWIND => {Cleanup[]};    ABORTED => {	Write["\nAborted.\n"L];	GOTO exit};          Librarian.Error => {        errorString: LONG STRING = [80];        Write["\nLibrarian error of '"L];        Librarian.StringForErrorCode[code, errorString];        Write[errorString];        Write["'.\n"L];        GOTO exit}};          -- Make copies of what's on the screen so that they won't get modified during run time.    SnapShotItems[to: data.windowItemsCopy, from: data.windowItems, z: zone];        -- The items on the screen translate into other internal flags being set.     -- Examples of these include the "conditions" for queries.    DecodeOptions[data.windowItemsCopy];        -- Make sure that the options are appropriate for this command.    IF ~LibToolSubr.ValidOptions[      command: command, batch: data.windowItemsCopy.batch, remotename: data.windowItemsCopy.remotename,      Write: Write, database: data.windowItems.database, libject: data.windowItemsCopy.libjects] THEN      GOTO exit;          -- User may have changed data.database since we last ran.    IF ~String.Equal[data.windowItems.database, data.windowItemsCopy.database] THEN {      IF data.windowItemsCopy.database # NIL THEN zone.FREE[@data.windowItemsCopy.database];      data.windowItemsCopy.database ¬ String.CopyToNewString[s: data.windowItems.database, z: zone];      LibToolOps.CloseConnection[server: @data.server, Write: Write];      };          -- Open if already closed, but not if we want to close.    IF data.server = Librarian.nullHandle AND command # close THEN {      data.server ¬ LibToolOps.OpenConnection[        servername: data.windowItemsCopy.database, zone: zone, Write: Write];      -- Always make the atoms here to make atoms only once.      LibToolOps.MakeQueryAtoms[data.server, @data.atoms];  -- Make the atoms for each DF property       };          -- Sanity check assertion. The open failed.    IF data.server = Librarian.nullHandle AND command # close THEN {      Write["No connection. Program error.\n"L];       GOTO exit};          -- No need to interate over libjects here.    IF command = close THEN {      LibToolOps.CloseConnection[server: @data.server, Write: Write];      GOTO exit;      };          -- Discuss "funny" inputs that may not necessarily make sense.    LibToolSubr.GiveWarningsIfAny[command, data.windowItemsCopy.batch, Write];    th ¬ Token.StringToHandle[s: data.windowItemsCopy.libjects];    libject ¬ Token.Filtered[h: th, data: NIL, filter: Token.NonWhiteSpace];  -- Due to a BUG in TokensA, I CANNOT use Token.FileName.    -- Assign things that don't change.    SetUpLibHandle[lhandle, localDir, command];    WHILE (libject # NIL) AND ~stop DO      nLibjects ¬ nLibjects.SUCC;      [wasAborted, stop, count] ¬ LibToolSubr.Action[h: lhandle, libject: libject, nLibjects: nLibjects];      grandTotal ¬ grandTotal + count;      FreeAndGetNext[libject];      ENDLOOP;    IF nLibjects > 1 THEN {  -- Useful only when they are multiple args.      SELECT command FROM        count, query, destroy => {          LibToolSubr.SummaryMsg[            nFound: grandTotal, libject: data.windowItemsCopy.libjects, user: data.windowItemsCopy.user,            Write: Write, wasAborted: wasAborted,            onlyIfCheckedOut: data.windowItemsCopy.onlyIfCheckedOut]};        ENDCASE => NULL;      };    Write["Done.\n-----\n"L];    Cleanup[];    EXITS exit => Cleanup[];    END};  -- CommandRoutine  -- Misc procedures    SetUpLibHandle: PROCEDURE [lhandle: LibToolSubr.Handle, localDir: LONG STRING, command: LibToolSubr.Command] = {     lhandle.command ¬ command;    lhandle.checkAbort ¬ CheckAbort;    lhandle.Write ¬ Write;    -- libject skipped since it will change.    lhandle.reason ¬ data.windowItemsCopy.reason;    lhandle.retrieve ¬ data.windowItemsCopy.retrieve;     -- Need to fix up data.windowItemsCopy.localDir, which may lack leading '<>' into localDir    SetLocalDir[data.windowItemsCopy.localDir, localDir];    -- localDir now contains the "right" thing.    lhandle.localDir ¬ localDir;    lhandle.remotename ¬ data.windowItemsCopy.remotename;    lhandle.user ¬ data.windowItemsCopy.user;    lhandle.batch ¬ data.windowItemsCopy.batch;    lhandle.onlyIfCheckedOut ¬ data.windowItemsCopy.onlyIfCheckedOut;    lhandle.queryMode ¬ IF data.windowItemsCopy.queryMode = 0 THEN normal ELSE terse;    lhandle.server ¬ data.server;    lhandle.zone ¬ zone;    lhandle.atoms ¬ data.atoms;  };  Write: WriteProc = {Put.Text[data.fileSW, s]};    CheckAbort: AbortProc = {RETURN[UserInput.UserAbort[wh]]};    -- Fix up local dir to have <> prepended to it.  SetLocalDir: PROCEDURE [localDir, localName: LONG STRING] = {   IF ~String.Empty[localDir] THEN {     IF localDir[0] # '< AND localDir[0] # '> THEN {       String.AppendString[localName, "<>"L];     };     String.AppendString[localName, localDir];     IF localDir[localDir.length-1] # '> THEN String.AppendChar[localName, '>];     };  };    ProcessUserDotCM: PROCEDURE =  -- Tool related PROCEDURE's  -- Keep this in here, since we may want to add different options.  BEGIN    CMOption: TYPE = MACHINE DEPENDENT{      Server(0), NamePrefix, noMatch(StringLookUp.noMatch)};    DefinedOption: TYPE = CMOption [Server..NamePrefix];    cmOptionTable: ARRAY DefinedOption OF LONG STRING ¬ [      Server: "Server"L, NamePrefix: "NamePrefix"L];    cmIndex: CMOption;    CheckType: PROCEDURE [h: CmFile.Handle, table: StringLookUp.TableDesc]      RETURNS [index: CARDINAL] = CmFile.NextValue;    MyNextValue: PROCEDURE [      h: CmFile.Handle,      table: LONG DESCRIPTOR FOR ARRAY DefinedOption OF LONG STRING]      RETURNS [index: CMOption] = LOOPHOLE[CheckType];    cmFile: CmFile.Handle ¬ CmFile.UserDotCmOpen[      ! CmFile.Error => IF code = fileNotFound THEN GOTO return];    IF CmFile.FindSection[cmFile, "Librarian"L] THEN      DO        SELECT        (cmIndex ¬ MyNextValue[          h: cmFile, table: DESCRIPTOR[cmOptionTable] !          CmFile.TableError => RESUME ]) FROM          noMatch => EXIT;          Server =>            BEGIN  -- Get            value: LONG STRING = Token.Item[cmFile];            data.windowItems.database ¬ String.CopyToNewString[s: value, z: Heap.systemZone];            [] ¬ Token.FreeTokenString[value];            END;          ENDCASE;        ENDLOOP;    [] ¬ CmFile.Close[cmFile];    EXITS return => NULL;    END;  FreeItems: PROCEDURE [z: UNCOUNTED ZONE, items: ItemsHandle] = {    IF items.database # NIL THEN {String.FreeString[z, items.database]; items.database ¬ NIL};    IF items.libjects # NIL THEN {String.FreeString[z, items.libjects]; items.libjects ¬ NIL};    IF items.remotename # NIL THEN {String.FreeString[z, items.remotename]; items.remotename ¬ NIL};    IF items.reason # NIL THEN {String.FreeString[z, items.reason]; items.reason ¬ NIL};    IF items.user # NIL THEN {String.FreeString[z, items.user]; items.user ¬ NIL};    IF items.localDir # NIL THEN {String.FreeString[z, items.localDir]; items.localDir ¬ NIL};    };  SnapShotItems: PROCEDURE [to, from: ItemsHandle, z: UNCOUNTED ZONE] = {  -- Snapshot some of the formsw stuff.    String.Replace[to: @to.libjects, from: from.libjects, z: zone];    String.Replace[to: @to.remotename, from: from.remotename, z: zone];    String.Replace[to: @to.reason, from: from.reason, z: zone];    String.Replace[to: @to.user, from: from.user, z: zone];    String.Replace[to: @to.localDir, from: from.localDir, z: zone];    to.batch ¬ from.batch;    to.onlyIfCheckedOut ¬ from.onlyIfCheckedOut;    to.retrieve ¬ from.retrieve;    to.queryMode ¬ from.queryMode;    to.condition ¬ from.condition;    };      -- This whole section needs to be re-written to take advantage  -- of various enumerated. The magic constants are too hard to maintain.  --  -- Does the mode require the "user" field?  UserFieldNeeded: PROCEDURE [i: ItemsHandle] RETURNS [BOOLEAN] = {   IF i.condition IN [0..1] THEN RETURN [FALSE] ELSE RETURN[TRUE];  };      DecodeOptions: PROCEDURE [i: ItemsHandle] = {  -- Decode the     SELECT i.condition FROM    0 => i.onlyIfCheckedOut ¬ FALSE;    1 => i.onlyIfCheckedOut ¬ TRUE;    2 => i.onlyIfCheckedOut ¬ TRUE;    ENDCASE => ERROR;    -- Keep the user field if user if "valid" in the context    IF ~UserFieldNeeded[i] THEN {       IF i.user # NIL THEN {String.FreeString[zone, i.user]; i.user ¬ NIL};    };  };  WakeUp: PROC = {  -- Called when the tool is activated.    IF zone = NIL THEN InitHeap[];    IF data = NIL THEN {       data ¬ zone.NEW[Data ¬ []];       data.windowItems ¬ zone.NEW[Items ¬ []];       data.windowItemsCopy ¬ zone.NEW[Items ¬ []]};    data.windowItems.database ¬ LibToolSubr.GetServer[];    inactive ¬ FALSE;    };  Sleep: ENTRY PROC = {  -- Called when the tool in inactivated.    inactive ¬ TRUE;    Supervisor.RemoveDependency[client: agent, implementor: Event.toolWindow];    IF data # NIL THEN {      WHILE commandIsRunning DO WAIT untilDone ENDLOOP;      LibToolOps.CloseConnection[@data.server, Write ! Librarian.Error => CONTINUE];      FormSW.Destroy[data.formSW];      FreeItems[zone, data.windowItems];      FreeItems[zone, data.windowItemsCopy];      zone.FREE[@data.windowItems];      zone.FREE[@data.windowItemsCopy];      zone.FREE[@data]};    IF zone # NIL THEN KillHeap[]};  Nap: PROCEDURE = {  -- Close any open connections before going tiny.    IF ~commandIsRunning THEN {      LibToolOps.CloseConnection[@data.server, Write ! Librarian.Error => CONTINUE;]}};  -- Sleep will be called when Destroy'ed.  ClientTransition: ToolWindow.TransitionProcType = {    SELECT TRUE FROM      (old = inactive) => WakeUp[];      (new = inactive) => Sleep[];      (new = tiny) => Nap[];      ENDCASE;    };  -- See it for all documentation.   -- LibToolSubr.Help is not an ExecProc so that we may add  -- a help window, or write it to the log window, etc. depending  -- on the runtime option.    Help: Exec.ExecProc = {    fsp: Format.StringProc ¬ Exec.OutputProc[h];    Write: WriteProc = {fsp[s]};    LibToolSubr.Help[Write];    };      -- Heap initialization and cleanup.  InitHeap: PROCEDURE = INLINE {zone ¬ Heap.Create[initial: 8, swapUnitSize: 4]};  KillHeap: PROCEDURE = INLINE {Heap.Delete[zone]; zone ¬ NIL};  LibExecCall: Exec.ExecProc = {  -- Called when the librariantool itself is run from the exec.  -- Will give warning messages if on a ttytajo boot file.    IF ~Runtime.IsBound[LOOPHOLE[Tool.Create]]  THEN {      EWrite[h, "LibrarianTool commands available through Exec are:"L];      EWrite[h, "CheckoutLibject.~, CheckInLibject.~ and QueryLibject.~"L];      RETURN};         IF inactive AND wh # NIL THEN {      ToolWindow.Activate[wh]}    ELSE {Exec.OutputProc[h]["LibrarianTool is active.\n"L]}};    MakeTool: PROCEDURE RETURNS [wh: Window.Handle ¬ NIL] = {  -- Creates the tool, inits the heap.    herald: LONG STRING ¬ [100];    IF zone = NIL THEN InitHeap[];    String.AppendString[herald, "LibrarianTool of "L];    Time.Append[herald, Time.Unpack[Runtime.GetBcdTime[]]];    herald.length ¬ herald.length - 3;    IF Runtime.IsBound[LOOPHOLE[Tool.Create]] THEN {      wh ¬ Tool.Create[	makeSWsProc: MakeSWs, initialState: default,	clientTransition: ClientTransition, name: herald, cmSection: "LibrarianTool"L,	tinyName1: "Librarian"L, tinyName2: "Tool"L]}  };  EWrite: PROCEDURE [h: Exec.Handle, s: LONG STRING] = {  -- A write procedure to the executive.  -- Should use the PF package someday.    fsp: Format.StringProc ¬ Exec.OutputProc[h];    fsp[s]};    ExecCall: PROCEDURE [command: LibToolSubr.Command, h: Exec.Handle] RETURNS [outcome: Exec.Outcome]= {  -- Entry to the executive command processing. Does monitored synch.    handle: Event.Handle ¬ Event.StartingProcess["LibrarianTool is still running"L];    Cleanup: PROCEDURE = {      Event.DoneWithProcess[handle];      FinishCommand[]};    BEGIN    ENABLE UNWIND => Cleanup[];       IF zone = NIL THEN InitHeap[];       IF ~Enter[] THEN {	 EWrite[h, "LibrarianTool is busy.\n"L];	 outcome ¬ error	} ELSE {	  outcome ¬ LibExec.DoOp[h, command, zone];	};	Cleanup[];   END};    -- Entry points into the executive command processor with the correct operation parameter.  CheckOutExec: Exec.ExecProc = {RETURN[ExecCall[checkOut, h]]};  CheckInExec: Exec.ExecProc = {RETURN[ExecCall[checkIn, h]]};  QueryExec: Exec.ExecProc = {RETURN[ExecCall[query, h]]};    Unload: Exec.ExecProc = {  -- free the tool resources.  -- As a side effect, calls the transition proc.    IF wh # NIL THEN Tool.Destroy[wh];    wh ¬ NIL;    [] ¬ Exec.RemoveCommand[h, "LibrarianTool.~"L];    [] ¬ Exec.RemoveCommand[h, "CheckoutLibject.~"L];    [] ¬ Exec.RemoveCommand[h, "CheckInLibject.~"L];    [] ¬ Exec.RemoveCommand[h, "QueryLibject.~"L]};         Init: PROCEDURE = {  -- Register executive commande, initialize heap and creates a tool if possible.    Exec.AddCommand["LibrarianTool.~"L, LibExecCall, Help, Unload];    Exec.AddCommand["CheckoutLibject.~"L, CheckOutExec, LibExec.EHelpCO, Unload];    Exec.AddCommand["CheckInLibject.~"L, CheckInExec, LibExec.EHelpCI, Unload];    Exec.AddCommand["QueryLibject.~"L, QueryExec, LibExec.EHelpQ, Unload];    IF zone = NIL THEN InitHeap[];    IF Runtime.IsBound[LOOPHOLE[Tool.Create]]  THEN {      wh ¬ MakeTool[];    };   };  MakeSWs: Tool.MakeSWsProc = {  -- Creates the three main windows and sets the visibility of fields according the mode.    logName: LONG STRING ¬ [20];    InitVisiTable[];    Tool.UnusedLogName[unused: logName, root: "LibrarianTool.log"L];    data.msgSW ¬ Tool.MakeMsgSW[window: window];    data.formSW ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    data.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    Supervisor.AddDependency[client: agent, implementor: Event.toolWindow];    SetVisibility[data.windowItems.mode, data.formSW];    SetUserVisibility[data.windowItems.condition, data.formSW];    };          -- Copied mostly from the output of "FormSWLayOutTool".    charWidth: CARDINAL ¬ WindowFont.CharWidth['0];      CharPos: PROC[char: CARDINAL] RETURNS [x: INTEGER] = {  -- Gives width of a typical character    x ¬ charWidth * char};  MakeForm: FormSW.ClientItemsProcType = {  -- Created form sub window.    OPEN FormSW;    nItems: CARDINAL = FormItems.LAST.ORD + 1;    mode: ARRAY[0..3) OF Enumerated ¬ [      ["Query"L, 0], ["CheckInOut"L, 1],      ["Administrative"L, 2]];    output: ARRAY[0..2) OF Enumerated ¬ [      ["verbose"L, 0], ["terse"L, 1]];    condition: ARRAY[0..3) OF Enumerated ¬ [      ["all"L, 0], ["if checked out"L, 1],      ["if checked out by user"L, 2]];        items ¬ AllocateItemDescriptor[nItems];    items[FormItems.mode.ORD] ¬ EnumeratedItem[invisible: ~data.visibilityTable[mode][queryMode],      tag: "Command"L, place: [CharPos[1], line0], feedback: all, proc: ModeChange, choices: DESCRIPTOR[mode], value: @data.windowItems.mode];    items[FormItems.close.ORD] ¬ CommandItem[invisible: ~data.visibilityTable[close][queryMode],      tag: "Close"L, place: [CharPos[59], line0], proc: CommandProc];    items[FormItems.database.ORD] ¬ StringItem[invisible: ~data.visibilityTable[database][queryMode],      tag: "Database"L, place: [CharPos[1], line1], inHeap: TRUE, string: @data.windowItems.database];    items[FormItems.libjects.ORD] ¬ StringItem[invisible: ~data.visibilityTable[libjects][queryMode],      tag: "Libjects"L, place: [CharPos[1], line2], inHeap: TRUE, string: @data.windowItems.libjects];    items[FormItems.query.ORD] ¬ CommandItem[invisible: ~data.visibilityTable[query][queryMode],      tag: "Query"L, place: [CharPos[1], line4], proc: CommandProc];    items[FormItems.count.ORD] ¬ CommandItem[invisible: ~data.visibilityTable[count][queryMode],      tag: "Count"L, place: [CharPos[11], line4], proc: CommandProc];    items[FormItems.output.ORD] ¬ EnumeratedItem[invisible: ~data.visibilityTable[output][queryMode],      tag: "Output"L, place: [CharPos[1], line5], feedback: all, choices: DESCRIPTOR[output], value: @data.windowItems.queryMode];    items[FormItems.condition.ORD] ¬ EnumeratedItem[invisible: ~data.visibilityTable[condition][queryMode],      tag: "Condition"L, place: [CharPos[27], line5], feedback: all, proc: ConditionChange, choices: DESCRIPTOR[condition], value: @data.windowItems.condition];    items[FormItems.user.ORD] ¬ StringItem[invisible: ~data.visibilityTable[user][queryMode],      tag: "User"L, place: [CharPos[1], line6], inHeap: TRUE, string: @data.windowItems.user];    items[FormItems.reason.ORD] ¬ StringItem[invisible: ~data.visibilityTable[reason][queryMode],      tag: "Reason"L, place: [CharPos[1], line4], inHeap: TRUE, string: @data.windowItems.reason];    items[FormItems.checkIn.ORD] ¬ CommandItem[invisible: ~data.visibilityTable[checkIn][queryMode],      tag: "CheckIn"L, place: [CharPos[1], line5], proc: CommandProc];    items[FormItems.checkOut.ORD] ¬ CommandItem[invisible: ~data.visibilityTable[checkOut][queryMode],      tag: "CheckOut"L, place: [CharPos[11], line5], proc: CommandProc];    items[FormItems.retrieve.ORD] ¬ BooleanItem[invisible: ~data.visibilityTable[retrieve][queryMode],      tag: "Retrieve"L, place: [CharPos[23], line5], switch: @data.windowItems.retrieve];    items[FormItems.localDir.ORD] ¬ StringItem[invisible: ~data.visibilityTable[localDir][queryMode],      tag: "LocalDir"L, place: [CharPos[34], line5], inHeap: TRUE, string: @data.windowItems.localDir];    items[FormItems.batch.ORD] ¬ BooleanItem[invisible: ~data.visibilityTable[batch][queryMode],      tag: "Batch"L, place: [CharPos[1], LineN[5]], drawBox: TRUE, switch: @data.windowItems.batch];    items[FormItems.remotename.ORD] ¬ StringItem[invisible: ~data.visibilityTable[remotename][queryMode],      tag: "Remotename"L, place: [CharPos[21], LineN[5]], inHeap: TRUE, string: @data.windowItems.remotename];    items[FormItems.destroy.ORD] ¬ CommandItem[invisible: ~data.visibilityTable[destroy][queryMode],      tag: "Destroy Libject"L, place: [CharPos[1], LineN[6]], proc: CommandProc];    items[FormItems.create.ORD] ¬ CommandItem[invisible: ~data.visibilityTable[create][queryMode],      tag: "Create Libject"L, place: [CharPos[21], LineN[6]], proc: CommandProc];          RETURN[items: items, freeDesc: TRUE];    };  -- Synch.  Enter: ENTRY PROC RETURNS [ok: BOOLEAN] = {    ENABLE UNWIND => NULL;    IF commandIsRunning THEN RETURN[FALSE];    commandIsRunning ¬ TRUE;    RETURN[TRUE]};  Leave: ENTRY PROC = {  -- Sets condition variables    ENABLE UNWIND => NULL; commandIsRunning ¬ FALSE; NOTIFY untilDone};  -- Mainline code  Init[];  -- this gets string out of global frame  }... -- OF LibToolImpl.mesa  LOGTime: 26-Jul-84 16:13:56   By: DSC 	Action: Create.Time: 30-Jan-85 13:33:02   By: DSC 	Action: Renamed to (ugh) LibrarianTool.Time: 15-Mar-85 11:24:49   By: DSC 	Action: renamed to LibToolImpl.Time: 28-Mar-85 11:24:28   By: DSC 	Action: Cleanup and make libhandle.Time:  9-Apr-85 10:20:14   By: DSC	Action: Change interface to add mode.Time: 16-May-85 14:47:42   By: DSC	Action: New interface. Time: 17-Jun-85 11:51:42   By: DSC 	Action: Placed ABORT catch here.Time: 19-Jul-85 10:41:09   By: DSC 	Action: Spelling error in enumerated.Time: 22-Jul-85 12:21:26   By: DSC 	Action: Avoid multi-tool instances.Time: 12-Sep-85 15:20:09   By: DSC 	Action: error message (double space) fix.Time: 16-Sep-85 10:03:00   By: DSC 	Action: FormSW.SetTypeIn fix. 
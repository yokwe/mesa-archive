-- File: EtherTesterTajo.mesa - last edit:-- AOF                 10-Apr-87 11:48:32-- Copyright (C) 1983, 1984, 1987 by Xerox Corporation. All rights reserved. DIRECTORY  BitBlt USING [],  Cursor USING [Object, Store],  Display USING [Bitmap, infinity, Invert, replaceFlags, Text, White],  Format USING [HostNumber, StringProc],  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, ProcType, Enumerated, newLine,    sameLine, BooleanItem, CommandItem, EnumeratedItem, NumberItem, StringItem],  HeraldWindow USING [AppendMessage],  MsgSW USING [Post],  Put USING [Char, CR, HostNumber, Line, Number, Text],  Runtime USING [CallDebugger, GetBcdTime, GlobalFrame],  SpecialSpace USING [MakeGlobalFrameResident, MakeProcedureResident],  SpecialSystem USING [GetProcessorID],  String USING [AppendLongNumber, AppendString],  System USING [HostNumber, switches],  Time USING [Append, Unpack, AppendCurrent],  Tool USING [AddThisSW, Create, MakeSWsProc, MakeMsgSW, MakeFormSW, MakeFileSW],  ToolWindow USING [CreateSubwindow, DisplayProcType, nullBox, TransitionProcType],  Unformat USING [Error, HostNumber],  UserInput USING [ReturnToNotifier],  Window USING [Box, Handle],  WindowFont USING [CharWidth, FontHeight],  NewEthernetFace USING [GetPacketLength, GetStatus, GetRetries, TurnOn],  EtherTesterDefs USING [    StartTest, StopTheWorld, DontBeAHog, InitializeCSBs, CleanThingsUp, Buffer,    Pattern, activeProcesses, stats, realBackground, FlipperType];EtherTesterTajo: PROGRAM  IMPORTS    Cursor, Display, Format, FormSW, HeraldWindow, MsgSW, Put, Runtime, SpecialSpace,    SpecialSystem, String, System, Time, Tool, ToolWindow, Unformat, UserInput, WindowFont,    NewEthernetFace, EtherTesterDefs  EXPORTS EtherTesterDefs =  BEGIN  -- Global Data  cursor: PUBLIC ARRAY [0..8) OF LONG CARDINAL;  log: PUBLIC Window.Handle;  me, source, dest: PUBLIC System.HostNumber ¬    LOOPHOLE[SpecialSystem.GetProcessorID[]];  recvSize: PUBLIC CARDINAL ¬ defaultRecvSize;  sendSize: PUBLIC CARDINAL ¬ defaultSendSize;  ticksBeforeSend: PUBLIC CARDINAL ¬ defaultTicksBeforeSend;  blankDisplay: PUBLIC BOOLEAN ¬ FALSE;  promiscuous: PUBLIC BOOLEAN ¬ FALSE;  broadcasting: PUBLIC BOOLEAN ¬ FALSE;  check: PUBLIC BOOLEAN ¬ FALSE;  flipem: PUBLIC BOOLEAN ¬ FALSE;  smashTheCursor: PUBLIC BOOLEAN ¬ FALSE;  doChecksum: PUBLIC BOOLEAN ¬ TRUE;  doStats: PUBLIC BOOLEAN ¬ TRUE;  showRunts, showGarbage, dallyBeforeOutput: PUBLIC BOOLEAN ¬ FALSE;  defaultNumberOfRecvBuffers: CARDINAL = 6;  numberOfRecvBuffers: PUBLIC CARDINAL ¬ defaultNumberOfRecvBuffers;  defaultNumberOfSendBuffers: CARDINAL = 1;  numberOfSendBuffers: PUBLIC CARDINAL ¬ defaultNumberOfSendBuffers;  showStrangeStatus, showWrongLength: PUBLIC BOOLEAN ¬ TRUE;  showWrongData, showOnlyBadAlign: PUBLIC BOOLEAN ¬ TRUE;  bumpPacketNumber, dallyIfBehind: PUBLIC BOOLEAN ¬ TRUE;  -- Private Data  EtherNetBoard: CARDINAL ¬ defaultEtherNetBoard;  herald: LONG STRING = [50];  form, boxes: Window.Handle ¬ NIL;  msg: Window.Handle;  defaultEtherNetBoard: CARDINAL = 1;  defaultRecvSize: CARDINAL = 2020;  defaultSendSize: CARDINAL = 2000;  defaultTicksBeforeSend: CARDINAL = 0;  myHostNumber: LONG STRING ¬ [30];  sourceHostNumber: LONG STRING ¬ [30];  destHostNumber: LONG STRING ¬ [30];  pattern: PUBLIC EtherTesterDefs.Pattern ¬ ignore;  patternChoices: ARRAY EtherTesterDefs.Pattern OF FormSW.Enumerated ¬ [    ignore: ["Ignore"L, EtherTesterDefs.Pattern[ignore]],    zeros: ["Zeros"L, EtherTesterDefs.Pattern[zeros]],    ones: ["Ones"L, EtherTesterDefs.Pattern[ones]],    alternating: ["125252B"L, EtherTesterDefs.Pattern[alternating]],    pairs: ["146314B"L, EtherTesterDefs.Pattern[pairs]],    oneTwentyFive: ["125B"L, EtherTesterDefs.Pattern[oneTwentyFive]],    countBytes: ["CountBytes"L, EtherTesterDefs.Pattern[countBytes]],    countWords: ["CountWords"L, EtherTesterDefs.Pattern[countWords]],    lenOne: ["Len-1"L, EtherTesterDefs.Pattern[lenOne]],    lenSix: ["Len-6"L, EtherTesterDefs.Pattern[lenSix]]];  -- Tool Commands  Stop: FormSW.ProcType = BEGIN EtherTesterDefs.StopTheWorld[]; END;  Send: FormSW.ProcType =    BEGIN    ComplainIfRunningAndSuch["Sending..."L];    PrintDest[];    IF ~EtherTesterDefs.StartTest[SendOnly, EtherNetBoard] THEN      Trouble["Can't find specified Ethernet(2) board."L];    END;  Recv: FormSW.ProcType =    BEGIN    ComplainIfRunningAndSuch["Receiving..."L];    PrintSource[];    IF ~EtherTesterDefs.StartTest[ReceiveOnly, EtherNetBoard] THEN      Trouble["Can't find specified Ethernet(2) board."L];    END;  SendAndRecv: FormSW.ProcType =    BEGIN    ComplainIfRunningAndSuch["Sending and Receiving..."L];    PrintSource[];    PrintDest[];    IF ~EtherTesterDefs.StartTest[SendAndReceive, EtherNetBoard] THEN      Trouble["Can't find specified Ethernet(2) board."L];    END;  EchoServer: FormSW.ProcType =    BEGIN    ComplainIfRunningAndSuch["Echo Server..."L];    PrintSource[];    PrintDest[];    IF ~EtherTesterDefs.StartTest[EchoServer, EtherNetBoard] THEN      Trouble["Can't find specified Ethernet(2) board."L];    END;  EchoUser: FormSW.ProcType =    BEGIN    ComplainIfRunningAndSuch["Echo User..."L];    PrintSource[];    PrintDest[];    IF ~EtherTesterDefs.StartTest[EchoUser, EtherNetBoard] THEN      Trouble["Can't find specified Ethernet(2) board."L];    END;  -- Useful in Command Routines  ComplainIfRunningAndSuch: PROCEDURE [header: STRING] =    BEGIN    ENABLE UNWIND => NULL;    IF EtherTesterDefs.activeProcesses # 0 THEN      Trouble["A test is already running.  Please Stop it first."L];    source ¬ StringToHostNumber[sourceHostNumber, "Syntax error in Source."L];    dest ¬ StringToHostNumber[destHostNumber, "Syntax error in Dest."L];    me ¬ StringToHostNumber[myHostNumber, "Syntax error in MyHostNmber."L];    IF recvSize < 6 THEN Trouble["Input buffer too small (6)."L];    IF recvSize > 3100 THEN Trouble["Input buffer too big (3100)."L];    IF sendSize > 3000 THEN Trouble["Output buffer too big (3000)."L];    IF sendSize < 7 THEN Trouble["Output buffer too small (7)."L];    MsgSW.Post[msg, header];    Put.CR[log];    PrintTime[log];    Put.Line[log, "  Running....."L];    IF sendSize < 30 THEN      Put.Line[        log,        "***** Warning: Sending packets shorter than allowed by Ethernet Spec. (30 words)"L];    IF sendSize > 757 THEN      Put.Line[        log,        "***** Warning: Sending packets longer than allowed by Ethernet Spec. (757 words)"L];    IF blankDisplay THEN Put.Line[log, "Display off while testing."L];    END;  PrintDest: PROCEDURE =    BEGIN    SELECT TRUE FROM      broadcasting => Put.Line[log, "Output packets will be BROADCAST!"L];      dest = me => Put.Line[log, "Output packets will be sent to me."L];      ENDCASE =>        BEGIN        Put.Text[log, "Output packets will be sent to "L];        Put.HostNumber[log, dest, octal];        Put.Line[log, "."L];        END;    IF check THEN Put.Line[log, "Output data will be formatted."L];    Put.Text[log, "Output packet length is "L];    D[sendSize];    Put.Line[log, " words."L];    END;  PrintSource: PROCEDURE =    BEGIN    IF promiscuous THEN Put.Line[log, "Reading everything."L]    ELSE Put.Line[log, "Reading just packets for me."L];    IF check THEN Put.Line[log, "Input data will be checked."L];    Put.Text[log, "Input buffer length is "L];    D[recvSize];    Put.Line[log, " words."L];    END;  -- Other Tool Stuff  ClientTransition: ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      old = inactive => EtherTesterDefs.InitializeCSBs[];      new = inactive =>        BEGIN msg ¬ form ¬ log ¬ NIL; EtherTesterDefs.CleanThingsUp[]; END;      ENDCASE;    END;  MakeSWs: Tool.MakeSWsProc =    BEGIN    msg ¬ Tool.MakeMsgSW[window: window, lines: 1];    form ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    MakeBoxesSW[window];    log ¬ Tool.MakeFileSW[window: window, name: "EtherTester.log$"L];    END;  MakeForm: FormSW.ClientItemsProcType =    BEGIN    nParams: CARDINAL = 33;    i: INTEGER ¬ -1;    longChoices: LONG POINTER TO ARRAY EtherTesterDefs.Pattern OF      FormSW.Enumerated = @patternChoices;    items ¬ FormSW.AllocateItemDescriptor[nParams];    items[i ¬ (i + 1)] ¬ FormSW.CommandItem[      tag: "Stop"L, proc: Stop, place: FormSW.newLine];    items[i ¬ (i + 1)] ¬ FormSW.CommandItem[tag: "Send"L, proc: Send];    items[i ¬ (i + 1)] ¬ FormSW.CommandItem[tag: "Recv"L, proc: Recv];    items[i ¬ (i + 1)] ¬ FormSW.CommandItem[      tag: "SendAndRecv"L, proc: SendAndRecv];    items[i ¬ (i + 1)] ¬ FormSW.CommandItem[tag: "EchoServer"L, proc: EchoServer];    items[i ¬ (i + 1)] ¬ FormSW.CommandItem[tag: "EchoUser"L, proc: EchoUser];    items[i ¬ (i + 1)] ¬ FormSW.BooleanItem[      tag: "ShowRunts"L, switch: @showRunts, place: FormSW.newLine];    items[i ¬ (i + 1)] ¬ FormSW.BooleanItem[      tag: "ShowGarbage"L, switch: @showGarbage];    items[i ¬ (i + 1)] ¬ FormSW.BooleanItem[      tag: "ShowStrange"L, switch: @showStrangeStatus];    items[i ¬ (i + 1)] ¬ FormSW.BooleanItem[      tag: "ShowWrongLength"L, switch: @showWrongLength];    items[i ¬ (i + 1)] ¬ FormSW.BooleanItem[      tag: "ShowWrongData"L, switch: @showWrongData];    items[i ¬ (i + 1)] ¬ FormSW.BooleanItem[      tag: "ShowOnlyBadAlign"L, switch: @showOnlyBadAlign];    items[i ¬ (i + 1)] ¬ FormSW.BooleanItem[      tag: "DoChecksum"L, switch: @doChecksum, place: FormSW.newLine];    items[i ¬ (i + 1)] ¬ FormSW.BooleanItem[tag: "Flipem"L, switch: @flipem];    items[i ¬ (i + 1)] ¬ FormSW.BooleanItem[      tag: "SmashCursor"L, switch: @smashTheCursor];    items[i ¬ (i + 1)] ¬ FormSW.BooleanItem[      tag: "BlankDisplay"L, switch: @blankDisplay];    items[i ¬ (i + 1)] ¬ FormSW.BooleanItem[tag: "DoStats"L, switch: @doStats];    items[i ¬ (i + 1)] ¬ FormSW.BooleanItem[tag: "CheckInput"L, switch: @check];    items[i ¬ (i + 1)] ¬ FormSW.BooleanItem[      tag: "BumpPacketNumber"L, switch: @bumpPacketNumber];    items[i ¬ (i + 1)] ¬ FormSW.NumberItem[      tag: "Board"L, value: @EtherNetBoard, boxWidth: 30,      default: defaultEtherNetBoard, place: FormSW.newLine];    items[i ¬ (i + 1)] ¬ FormSW.BooleanItem[      tag: "DallyIfBehind"L, switch: @dallyIfBehind];    items[i ¬ (i + 1)] ¬ FormSW.BooleanItem[      tag: "DallyBeforeOutput"L, switch: @dallyBeforeOutput];    items[i ¬ (i + 1)] ¬ FormSW.NumberItem[      tag: "TicksBeforeSend"L, value: @ticksBeforeSend,      default: defaultTicksBeforeSend, boxWidth: 30];    items[i ¬ (i + 1)] ¬ FormSW.EnumeratedItem[      tag: "Pattern"L, value: @pattern,      choices: LOOPHOLE[DESCRIPTOR[longChoices­]]];    items[i ¬ (i + 1)] ¬ FormSW.BooleanItem[      tag: "Promiscuous"L, switch: @promiscuous, place: FormSW.newLine];    items[i ¬ (i + 1)] ¬ FormSW.BooleanItem[      tag: "Broadcasting"L, switch: @broadcasting];    items[i ¬ (i + 1)] ¬ FormSW.StringItem[      place: [200, FormSW.sameLine], tag: "MyHostNumber"L, string: @myHostNumber];    items[i ¬ (i + 1)] ¬ FormSW.StringItem[      tag: "Source"L, string: @sourceHostNumber, place: FormSW.newLine];    items[i ¬ (i + 1)] ¬ FormSW.StringItem[      tag: "Dest"L, place: [200, FormSW.sameLine], string: @destHostNumber];    items[i ¬ (i + 1)] ¬ FormSW.NumberItem[      tag: "NumberOfRecvBuffers"L, value: @numberOfRecvBuffers,      default: defaultNumberOfRecvBuffers, place: FormSW.newLine];    items[i ¬ (i + 1)] ¬ FormSW.NumberItem[      place: [200, FormSW.sameLine], tag: "InputBufferLength"L, value: @recvSize,      default: defaultRecvSize];    items[i ¬ (i + 1)] ¬ FormSW.NumberItem[      tag: "NumberOfSendBuffers"L, value: @numberOfSendBuffers,      default: defaultNumberOfSendBuffers, place: FormSW.newLine];    items[i ¬ (i + 1)] ¬ FormSW.NumberItem[      place: [200, FormSW.sameLine], tag: "OutputBufferLength"L, value: @sendSize,      default: defaultSendSize];    IF (i + 1) # nParams THEN ERROR;    RETURN[items, TRUE];    END;  -- Flipper Subwindow Stuff  Flipper: TYPE = {left, right, off};  lineHeight: CARDINAL ¬ WindowFont.FontHeight[];  charWidth: CARDINAL ¬ WindowFont.CharWidth['0];  flipperWidth: CARDINAL = 8*charWidth;  blanks: LONG STRING = "        "L;  flippers: ARRAY EtherTesterDefs.FlipperType OF Flipper ¬ ALL[off];  flipperBoxes: ARRAY EtherTesterDefs.FlipperType OF Window.Box = [    [[1*flipperWidth, 10], [16, 16]], [[2*flipperWidth, 10], [16, 16]], [    [3*flipperWidth, 10], [16, 16]], [[4*flipperWidth, 10], [16, 16]], [    [5*flipperWidth, 10], [16, 16]], [[6*flipperWidth, 10], [16, 16]], [    [7*flipperWidth, 10], [16, 16]], [[8*flipperWidth, 10], [16, 16]], [    [9*flipperWidth, 10], [16, 16]], [[10*flipperWidth, 10], [16, 16]], [    [11*flipperWidth, 10], [16, 16]], [[12*flipperWidth, 10], [16, 16]]];  flipperTags: ARRAY EtherTesterDefs.FlipperType OF LONG STRING = [    "send"L, " coll"L, "s err"L, "recv"L, "no in"L, "no out"L, "r err"L, "echo"L,    "late"L, "lost"L, "dally"L, "idle"L];  flipperData: ARRAY EtherTesterDefs.FlipperType OF LONG POINTER    TO LONG CARDINAL = [    @EtherTesterDefs.stats.pktsOut, @EtherTesterDefs.stats.collisions,    @EtherTesterDefs.stats.errsOut, @EtherTesterDefs.stats.pktsIn,    @EtherTesterDefs.stats.missed, @EtherTesterDefs.stats.packetsNotEchoed,    @EtherTesterDefs.stats.errsIn, @EtherTesterDefs.stats.packetsEchoed,    @EtherTesterDefs.stats.lateEchos, @EtherTesterDefs.stats.echosMissed,    @EtherTesterDefs.stats.dallyForEcho, @EtherTesterDefs.realBackground];  left: ARRAY [0..1] OF ARRAY [0..8) OF WORD ¬ [ALL[177400B], ALL[000377B]];  right: ARRAY [0..1] OF ARRAY [0..8) OF WORD ¬ [ALL[177400B], ALL[000377B]];  off: ARRAY [0..1] OF ARRAY [0..8) OF WORD ¬ [ALL[0], ALL[0]];  DisplayBoxes: ToolWindow.DisplayProcType =    BEGIN    FOR which: EtherTesterDefs.FlipperType IN EtherTesterDefs.FlipperType DO      pattern: LONG POINTER;      rightEdge: CARDINAL = flipperBoxes[which].place.x + 16;      leftEdge: CARDINAL = rightEdge - charWidth*flipperTags[which].length;      string: LONG STRING ¬ flipperTags[which];      SELECT flippers[which] FROM        left => pattern ¬ @left;        right => pattern ¬ @right;        off =>          BEGIN          pattern ¬ @off;          string ¬ blanks;          [] ¬ Display.Text[            window, blanks, [rightEdge - flipperWidth, 10 + 16 + 5],	    NIL, Display.infinity, Display.replaceFlags];          END;        ENDCASE => ERROR;      Display.White[boxes, flipperBoxes[which]];      Display.Bitmap[window, flipperBoxes[which], [pattern, 0, 0], 16, Display.replaceFlags];      [] ¬ Display.Text[        window, string, [leftEdge, 10 + 16 + 5 + lineHeight],	NIL, Display.infinity, Display.replaceFlags];      ENDLOOP;    END;  UpdateNumbers: PUBLIC PROCEDURE =    BEGIN    FOR which: EtherTesterDefs.FlipperType IN EtherTesterDefs.FlipperType DO      n: LONG CARDINAL = flipperData[which]­;      string: STRING = [20];      rightEdge, leftEdge: CARDINAL;      IF n = 0 OR n = LAST[LONG CARDINAL] THEN LOOP;      String.AppendLongNumber[string, n, 10];      rightEdge ¬ flipperBoxes[which].place.x + 16;      leftEdge ¬ rightEdge - charWidth*string.length;      [] ¬ Display.Text[        boxes, string, [leftEdge, 10 + 16 + 5],	NIL, Display.infinity, Display.replaceFlags];      ENDLOOP;    END;  SetupBoxes: PUBLIC PROCEDURE =    BEGIN flippers ¬ ALL[left]; DisplayBoxes[boxes]; END;  FlipBox: PUBLIC PROCEDURE [which: EtherTesterDefs.FlipperType] =    BEGIN    SELECT flippers[which] FROM      left => flippers[which] ¬ right;      off, right => flippers[which] ¬ left;      ENDCASE => ERROR;    Display.Invert[boxes, flipperBoxes[which]];    END;  SetDownBoxes: PUBLIC PROCEDURE =    BEGIN flippers ¬ ALL[off]; DisplayBoxes[boxes]; END;  MakeBoxesSW: PROCEDURE [window: Window.Handle] =    BEGIN    box: Window.Box ¬ ToolWindow.nullBox;    box.dims.h ¬ 10 + 16 + 5 + lineHeight + lineHeight + 10;    boxes ¬ ToolWindow.CreateSubwindow[parent: window, display: DisplayBoxes, box: box];    Tool.AddThisSW[window: window, sw: boxes, swType: vanilla];    END;  -- Miscellaneous routines  ShowPacket: PUBLIC PROCEDURE [why: LONG STRING, this: EtherTesterDefs.Buffer] =    BEGIN    limit: CARDINAL = 30;    length: CARDINAL = NewEthernetFace.GetPacketLength[this.iocb] + 2;  -- CRC    p: LONG POINTER ¬ @this.header;    IF this = NIL THEN Debugger["AttemptToPrintNilBuffer"L];    Put.Text[log, why];    Put.Line[log, "."L];    Put.Text[log, "Status: "L];    O[NewEthernetFace.GetStatus[this.iocb]];    Put.Text[log, ", Length: "L];    D[this.length];    Put.Text[log, ", Used: "L];    D[NewEthernetFace.GetPacketLength[this.iocb]];    Put.Text[log, ", Retries: "L];    O[NewEthernetFace.GetRetries[this.iocb]];    Put.Line[log, "."L];    Put.Text[log, "Dest: "L];    Put.HostNumber[log, this.header.dest, octal];    Put.Text[log, ", Source: "L];    Put.HostNumber[log, this.header.source, octal];    Put.Text[log, ", Type: "L];    O[this.header.packetType];    Put.Char[log, '.];    Put.CR[log];    Put.Text[log, "IOCB:  "L];    FOR i: CARDINAL IN [0..8) DO O7[(this.iocb + i)­]; ENDLOOP;    FOR i: CARDINAL IN [0..IF TRUE THEN length ELSE MIN[limit, length]) DO      IF (i MOD 8) = 0 THEN        BEGIN        Put.CR[log];        IF EtherTesterDefs.DontBeAHog[] THEN EXIT;        -- ShowPacket is called at interrupt level so we must call DontBeAHog to let        -- other guys get a chance to run. Also checks for Stop key.        O4[i];        Put.Text[log, "/  "L];        END;      O7[(p + i)­];      ENDLOOP;    Put.CR[log];    IF FALSE AND length > limit THEN Put.Line[log, "...."L];    END;  SmashTheCursor: PUBLIC PROCEDURE =    BEGIN    foo: Cursor.Object ¬ [[last, 8, 8], LOOPHOLE[cursor]];    Cursor.Store[@foo];    END;  Death: PROCEDURE [e: STRING] = BEGIN DO Runtime.CallDebugger[e]; ENDLOOP; END;  Debugger: PROCEDURE [e: STRING] = BEGIN Runtime.CallDebugger[e]; END;  PrintTime: PROCEDURE [w: Window.Handle] =    BEGIN s: STRING = [20]; Time.AppendCurrent[s]; Put.Text[w, s]; END;  Trouble: PROCEDURE [s: STRING] =    BEGIN MsgSW.Post[msg, s]; UserInput.ReturnToNotifier[s]; END;  -- Some useful I/O routines  O: PROCEDURE [u: UNSPECIFIED] =    BEGIN Put.Number[log, u, [8, FALSE, TRUE, 0]]; END;  O4: PROCEDURE [u: UNSPECIFIED] =    BEGIN Put.Number[log, u, [8, FALSE, TRUE, 4]]; END;  O7: PROCEDURE [u: UNSPECIFIED] =    BEGIN Put.Number[log, u, [8, FALSE, TRUE, 7]]; END;  D: PROCEDURE [u: UNSPECIFIED] =    BEGIN Put.Number[log, u, [10, FALSE, TRUE, 0]]; END;  StringToHostNumber: PROCEDURE [s: LONG STRING, text: STRING]    RETURNS [System.HostNumber] =    BEGIN    RETURN[      Unformat.HostNumber[s, octal !        Unformat.Error => Trouble[text]]];    END;      AppendHostNumber: PROCEDURE [t: LONG STRING, host: System.HostNumber] =    BEGIN    Append: Format.StringProc = BEGIN String.AppendString[t, s]; END;    Format.HostNumber[Append, host, octal];    END;  -- Initialization  InitializeThings: PROCEDURE =    BEGIN    text: STRING = [200];    String.AppendString[herald, "Ethernet Tester of "L];    Time.Append[herald, Time.Unpack[Runtime.GetBcdTime[]]];    String.AppendString[text, herald];    String.AppendString[text, " running on "L];    AppendHostNumber[text, me];    String.AppendString[text, "."L];    HeraldWindow.AppendMessage[text];    IF ~System.switches['>] = down THEN      BEGIN      HeraldWindow.AppendMessage[        "The > switch needs to be down before this program will run."L];      RETURN      END;    AppendHostNumber[myHostNumber, me];    AppendHostNumber[sourceHostNumber, source];    AppendHostNumber[destHostNumber, dest];    [] ¬ Tool.Create[      name: herald, makeSWsProc: MakeSWs, clientTransition: ClientTransition];    -- Force the EthernetHead to stay resident to avoid 938s if we are testing a new head.  Note that we never undo this operation.    SpecialSpace.MakeGlobalFrameResident[      LOOPHOLE[Runtime.GlobalFrame[LOOPHOLE[NewEthernetFace.TurnOn]]]];    SpecialSpace.MakeProcedureResident[LOOPHOLE[NewEthernetFace.TurnOn]];    END;  InitializeThings[];  END.
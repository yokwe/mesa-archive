-- File: NewEthernetHeadDove.mesa - last edit:-- AOF                  6-Sep-85 20:59:38-- BKI                 19-Aug-85 19:52:43)-- Copyright (C) 1985 by Xerox Corporation. All rights reserved.DIRECTORY  DeviceCleanup USING [Await, Item],  DoveHandlerIDs USING [ethernet],  DoveInputOutput USING [BuildMesaClientCondition, ByteSwap, GetHandlerIORegionPtr, GetIORegionOffset, LockMem, LongPointerToOpieAddress, nilOpieAddress, NotifyIOP, OpieAddress, OpieAddressToLongPointer, QueueBlock],  Environment USING [first64K, wordsPerPage],  EthernetHardFaceDove USING [CommandSelect, Status],  EthernetIOFaceDove USING [FunctionContextBlock, IOCB],  NewEthernetFace USING [GlobalStatePtr, Status],  HostNumbers USING [broadcastHostNumber, HostNumber],  Inline USING [BITAND, LowHalf];NewEthernetHeadDove: PROGRAM  IMPORTS DeviceCleanup, DoveInputOutput, Inline  EXPORTS NewEthernetFace =  BEGIN  OPEN DoveIO: DoveInputOutput, EthernetHardFace: EthernetHardFaceDove,    EthernetIOFace: EthernetIOFaceDove;    ControlBlockRecord: PUBLIC TYPE = EthernetIOFace.IOCB;  DeviceHandle: PUBLIC TYPE = RECORD [CARDINAL];    IOCB: TYPE = LONG POINTER TO EthernetIOFace.IOCB;    controlBlockSize: PUBLIC CARDINAL _ SIZE[EthernetIOFace.IOCB];  globalStateSize: PUBLIC CARDINAL _ SIZE[EthernetIOFace.IOCB];  hearSelf: PUBLIC BOOLEAN _ FALSE;  nullDeviceHandle: PUBLIC DeviceHandle _ [123456B];    cleanupInitialized: BOOLEAN _ FALSE;  fcb: LONG POINTER TO EthernetIOFace.FunctionContextBlock =    DoveIO.GetHandlerIORegionPtr[DoveHandlerIDs.ethernet];  gState: RECORD [inInterrupt, outInterrupt: WORD];  self: DeviceHandle = [0];    AddCleanup: PUBLIC PROCEDURE [device: DeviceHandle] =    BEGIN    item: DeviceCleanup.Item;    -- There is no way to remove a cleanup procedure yet, so we have a flag    -- to avoid duplicates.    IF cleanupInitialized THEN RETURN;    cleanupInitialized _ TRUE;    DO      SELECT DeviceCleanup.Await[@item] FROM        kill => MakeSureOff[];	turnOff => MakeSureOff[];	turnOn => {          -- Note that this does NOT really put things back together.  It simply smashes things to a safe state.  The intention is that the driver will notice that nothing is happening and then call TurnOff+TurnOn to reset things.  That allows Pilot to reset the GMT clock on the way back from the debugger without getting tangled up with the normal Ethernet driver.	  MakeSureOff[];	  fcb.mesaInQueue _ [];	  fcb.mesaOutQueue _ [];	  gState.inInterrupt _ 0;	  gState.outInterrupt _ 0;	  -- I included the following statement because the Dandelion version does a similar thing.  However, I do not understand why it is necessary since EthernetFace.TurnOn is going to be called soon afterwards?  It may even be harmful since the i82586 is still programmed with the old parameters.	  fcb.mesaClientStateRequest _ on;	  };	ENDCASE;      ENDLOOP;    END;    GetNextDevice: PUBLIC PROCEDURE [device: DeviceHandle] RETURNS [DeviceHandle] =    BEGIN    -- IF ReadEEProm[ethernetPresent]=FALSE THEN RETURN[nullDeviceHandle];    RETURN[IF device=nullDeviceHandle THEN self ELSE nullDeviceHandle];    END;    GetPacketLength: PUBLIC PROCEDURE [cb: IOCB] RETURNS [CARDINAL] =    BEGIN    RETURN[WITH iocb: cb SELECT FROM input => iocb.count/2, ENDCASE => 0];    END;    GetPacketsMissed: PUBLIC PROCEDURE [device: DeviceHandle] RETURNS [CARDINAL] =    BEGIN    RETURN[IF device#self THEN 0 ELSE DoveIO.ByteSwap[fcb.scb.rscErrs]];    END;    GetRetries: PUBLIC PROCEDURE [cb: IOCB] RETURNS [CARDINAL] =    BEGIN    RETURN[      LOOPHOLE[cb.status, EthernetHardFace.Status.command.transmit].collisions];    END;    GetStatus: PUBLIC PROCEDURE [cb: IOCB] RETURNS [status: NewEthernetFace.Status] =    BEGIN    IF NOT cb.status.done THEN RETURN[<<IF cb.status.handled THEN>> pending <<ELSE queued>>];    IF NOT cb.status.isDequeued THEN {      DeQueue[        queuePtr: IF cb.type=input THEN @fcb.mesaInQueue ELSE @fcb.mesaOutQueue,        cb: cb];      ByteSwapIOCB[cb];      cb.status.isDequeued ¬ TRUE;      };    WITH iocb: cb SELECT FROM      input => {        OPEN inStatus: LOOPHOLE[	  iocb.i586Status, EthernetHardFace.Status.receiveFrame];	status _ SELECT TRUE FROM	  cb.status.okay =>	    IF Inline.BITAND[iocb.count, 1] # 0 THEN ok<<dippled>> ELSE ok,	  inStatus.ovrnErr => overrun,	  cb.status.frameTooLong => packetTooLong,	  inStatus.crcErr =>	    IF inStatus.alnErr THEN crcAndBadAlignment ELSE crc,	  inStatus.alnErr => badAlignmentButOkCrc,	  ENDCASE => otherError;	IF status = ok THEN {	  count: CARDINAL _ (iocb.length/2)-1;	  p: LONG POINTER = DoveIO.OpieAddressToLongPointer[iocb.address];	  DO	    (p + count)^ _ (p + count)^;	    IF count < Environment.wordsPerPage THEN {p^ _ p^; EXIT};	    count _ count - Environment.wordsPerPage;	    ENDLOOP;	  };	};      output => {        OPEN outStatus: LOOPHOLE[	  iocb.i586Status, EthernetHardFace.Status.command.transmit];	status _ SELECT TRUE FROM	  cb.status.okay => ok,	  cb.status.interruptTimeout => pending,	  outStatus.underrun => underrun,	  outStatus.tooManyCollisions => tooManyCollisions,	  ENDCASE => otherError;	};      command => {        OPEN cmdStatus: LOOPHOLE[iocb.i586Status, EthernetHardFace.Status.command];	status _ IF cb.status.okay THEN ok	ELSE WITH cmdStatus SELECT iocb.action FROM	  ENDCASE => otherError;	};      reset, startRU => status ¬ IF cb.status.okay THEN ok ELSE otherError;      ENDCASE => ERROR;    END;    Initiate: PUBLIC PROCEDURE [device: DeviceHandle, cb: IOCB] =    BEGIN    IF device#self THEN RETURN;    cb.next ¬ DoveIO.nilOpieAddress;    cb.status ¬ [done: FALSE, handled: FALSE];    DoveIO.BuildMesaClientCondition[      clientConditionPtr: @cb.clientCondition, mask: gState.outInterrupt];    ByteSwapIOCB[cb];    EnQueue[queuePtr: @fcb.mesaOutQueue, cb: cb];    DoveIO.NotifyIOP[fcb.etherOutWorkMask];    END;    QueueInput: PUBLIC PROCEDURE [device: DeviceHandle, buffer: LONG POINTER, length: CARDINAL, cb: IOCB] =    BEGIN    IF device#self THEN RETURN;    cb^ _ [      next: DoveIO.nilOpieAddress,      clientCondition: NULL,      status: [done: FALSE, handled: FALSE],      op: input[        address: DoveIO.LongPointerToOpieAddress[buffer], length: length*2]      ];    DoveIO.BuildMesaClientCondition[      clientConditionPtr: @cb.clientCondition, mask: gState.inInterrupt];    ByteSwapIOCB[cb];    EnQueue[queuePtr: @fcb.mesaInQueue, cb: cb];    DoveIO.NotifyIOP[fcb.etherInWorkMask];    END;    QueueOutput: PUBLIC PROCEDURE [device: DeviceHandle, buffer: LONG POINTER, length: CARDINAL, cb: IOCB] =    BEGIN    count: CARDINAL _ length - 1;    p: LONG POINTER = buffer;    IF device#self THEN RETURN;    DO      foo: UNSPECIFIED _ (p + count)^;      IF count < Environment.wordsPerPage THEN {foo _ p^; EXIT};      count _ count - Environment.wordsPerPage;      ENDLOOP;    cb^ _ [      next: DoveIO.nilOpieAddress,      clientCondition: NULL,      status: [done: FALSE, handled: FALSE],      op: output[        address: DoveIO.LongPointerToOpieAddress[buffer], length: length*2]      ];    DoveIO.BuildMesaClientCondition[      clientConditionPtr: @cb.clientCondition, mask: gState.outInterrupt];    ByteSwapIOCB[cb];    EnQueue[queuePtr: @fcb.mesaOutQueue, cb: cb];    DoveIO.NotifyIOP[fcb.etherOutWorkMask];    END;    RemoveCleanup: PUBLIC PROCEDURE [device: DeviceHandle] =    BEGIN    END;    Start: PUBLIC PROCEDURE =    BEGIN    --RemainingStartChain.Start[];    END;    TurnOff: PUBLIC PROCEDURE [device: DeviceHandle] =    BEGIN    IF device#self THEN RETURN;    MakeSureOff[];    END;    TurnOn: PUBLIC PROCEDURE [device: DeviceHandle, host: HostNumbers.HostNumber, inInterrupt, outInterrupt: WORD, globalState: NewEthernetFace.GlobalStatePtr] =    BEGIN    DoOutput: PROCEDURE RETURNS [ok: BOOLEAN] =      BEGIN      i: CARDINAL;      Initiate[device: device, cb: cb];      FOR i ¬ 0, i+1 UNTIL cb.status.done DO ENDLOOP;      DeQueue[queuePtr: @fcb.mesaOutQueue, cb: cb];      RETURN[cb.status.okay];      END;    cb: IOCB = @Environment.first64K[globalState];    IF device#self THEN RETURN;    MakeSureOff[];    fcb.mesaInQueue _ [];    fcb.mesaOutQueue _ [];    gState.outInterrupt ¬ 0;    fcb.mesaClientStateRequest _ on;    cb.op ¬ reset[];    IF ~DoOutput[] THEN RETURN;    cb.op ¬ command[      action: configure,      select: [configure[        byteCount: 9,	fifoLimit: 11,	saveBadFrames: TRUE,	addrTypeLoc: buffer,	promiscuousMode: (host=HostNumbers.broadcastHostNumber)	]]      ];    IF ~DoOutput[] THEN RETURN;    IF host#HostNumbers.broadcastHostNumber THEN {      cb.op ¬ command[action: individualAddr, select: [individualAddr[id: host]]];      IF ~DoOutput[] THEN RETURN};    cb.op ¬ startRU[];    IF ~DoOutput[] THEN RETURN;    gState _ [inInterrupt: inInterrupt, outInterrupt: outInterrupt];    END;    ByteSwapIOCB: PROCEDURE [cb: IOCB] =    BEGIN    ByteSwapIndirect: PROCEDURE [p: LONG POINTER TO UNSPECIFIED] = {      p­ ¬ DoveIO.ByteSwap[p­]};    cb.i586Status ¬ DoveIO.ByteSwap[cb.i586Status];    WITH iocb: cb SELECT FROM      input, output => {        iocb.length ¬ DoveIO.ByteSwap[iocb.length];	iocb.count ¬ DoveIO.ByteSwap[iocb.count];	};      command =>        WITH sel: iocb.select SELECT iocb.action FROM	  nop, individualAddr, configure, dumpStatus, diagnose => NULL;	  multicastAddr => ByteSwapIndirect[@sel+0<<unused,byteCount>>];	--transmit => Error[notSupported];	  timeDomainRfl => ByteSwapIndirect[@sel.results];          ENDCASE => ERROR;      reset, startRU => NULL;      ENDCASE => ERROR;    END;    DeQueue: PROCEDURE [queuePtr: LONG POINTER TO DoveIO.QueueBlock, cb: IOCB] =    BEGIN    cbOA: DoveIO.OpieAddress = DoveIO.LongPointerToOpieAddress[cb];    IF queuePtr.queueHead=cbOA THEN {      queuePtr.queueHead _ cb.next;      IF queuePtr.queueTail=cbOA THEN queuePtr.queueTail ¬ DoveIO.nilOpieAddress;      }    ELSE {      FOR chase: IOCB ¬ DoveIO.OpieAddressToLongPointer[queuePtr.queueHead],      DoveIO.OpieAddressToLongPointer[chase.next] WHILE chase#NIL DO	IF chase.next=cbOA THEN {	  chase.next _ cb.next;	  IF queuePtr.queueTail=cbOA THEN	    queuePtr.queueTail _ DoveIO.LongPointerToOpieAddress[chase];	  EXIT};	ENDLOOP;      };    END;    EnQueue: PROCEDURE [queuePtr: LONG POINTER TO DoveIO.QueueBlock, cb: IOCB] =    BEGIN    cbOA: DoveIO.OpieAddress = DoveIO.LongPointerToOpieAddress[cb];    IF queuePtr.queueHead=DoveIO.nilOpieAddress THEN queuePtr.queueHead ¬ cbOA    ELSE LOOPHOLE[      DoveIO.OpieAddressToLongPointer[queuePtr.queueTail],IOCB].next ¬ cbOA;    [] ¬ DoveIO.LockMem[      operation: overwriteIfNil,      address: DoveIO.GetIORegionOffset[@queuePtr.queueNext],      value: Inline.LowHalf[LOOPHOLE[cbOA]], --ToDo: UGLY--      mask: fcb.etherLockMask];    queuePtr.queueTail ¬ cbOA;    END;    MakeSureOff: PROCEDURE = INLINE    BEGIN    fcb.mesaClientStateRequest _ off;    DoveIO.NotifyIOP[fcb.etherInWorkMask];    DoveIO.NotifyIOP[fcb.etherOutWorkMask];    UNTIL --fcb.mesaInClientState=off AND-- fcb.mesaOutClientState=off DO ENDLOOP;    END;    END.LOG 6-Aug-84 17:10:26	BKI   	Creation 3-Apr-85 18:09:20	BKI   	GetPacketLength returns 0 on non-input iocbs.29-Jul-85 10:53:15	JPM	Opie redesign conversion.11-Aug-85 18:51:39	BKI	Remove unused local variables, cbOA....				Reset and reprogram chip in TurnOn.15-Aug-85  8:24:13	JPM	Comment out new TurnOn code till driver supports it.19-Aug-85 19:52:43	BKI	Include TurnOn code. Fix bugs (GetStatus; SELECT iocb.type; DeQueue iocb in TurnOn).
-- File: EtherTesterStats.mesa - last edit:-- AOF                 10-Apr-87 11:40:45-- Copyright (C) 1981, 1984 , 1987 by Xerox Corporation. All rights reserved. -- EtherTesterStats.mesa, HGM, 19-Dec-81 12:45:31DIRECTORY  Format USING [],  -- needed by Put.Number  Put USING [Char, CR, Text, Line],  String USING [AppendLongNumber],  System USING [Pulses, GetClockPulses, PulsesToMicroseconds],  Time USING [AppendCurrent],  Window USING [Handle],  EtherTesterDefs USING [cursor, log, Stats];EtherTesterStats: MONITOR  IMPORTS Put, String, System, Time, EtherTesterDefs EXPORTS EtherTesterDefs =  BEGIN  -- Global Data  stats: PUBLIC EtherTesterDefs.Stats;  realBackground: PUBLIC LONG CARDINAL;  -- Private Data  oldPulses: System.Pulses;  elapsedTime, recentTime: LONG CARDINAL;  -- in mili seconds  leftoverMicroseconds: LONG CARDINAL;  StatsInit: PUBLIC PROCEDURE =    BEGIN    stats ¬ [      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,      0, 0, 0];    oldPulses ¬ System.GetClockPulses[];    elapsedTime ¬ recentTime ¬ leftoverMicroseconds ¬ 0;    realBackground ¬ EtherTesterDefs.cursor[7] ¬ 1;    END;  StatsPeek: PUBLIC PROCEDURE =    BEGIN    StatsUpdateClock[];    IF recentTime > 3600000 THEN      BEGIN StatsPrint[TRUE]; recentTime ¬ recentTime - 3600000; END;    END;  StatsUpdateClock: ENTRY PROCEDURE = BEGIN StatsClock[]; END;  StatsClock: INTERNAL PROCEDURE =    BEGIN    now: System.Pulses ¬ System.GetClockPulses[];    microSec, milliSec: LONG CARDINAL;    EtherTesterDefs.cursor[7] ¬ realBackground ¬ realBackground + 1;    microSec ¬      leftoverMicroseconds + System.PulsesToMicroseconds[[now - oldPulses]];    IF microSec < 1000000 THEN RETURN;    oldPulses ¬ now;    milliSec ¬ microSec/1000;    elapsedTime ¬ elapsedTime + milliSec;    recentTime ¬ recentTime + milliSec;    leftoverMicroseconds ¬ microSec - (milliSec*1000);    END;  StatsPrint: PUBLIC ENTRY PROCEDURE [partial: BOOLEAN] =    BEGIN    StatsClock[];    PrintTime[EtherTesterDefs.log];    Put.Text[      EtherTesterDefs.log,      IF partial THEN "  The time so far is "L ELSE "  This run lasted "L];    LD[elapsedTime/1000];    Put.Line[EtherTesterDefs.log, " seconds."L];    Put.Text[EtherTesterDefs.log, "It took "L];    LD[elapsedTime/realBackground];    Put.Line[EtherTesterDefs.log, " ms/background cycle."L];    PrintLine[stats.pktsOut, "Packets Sent OK"L];    PrintLine[stats.wdsOut, "Words Sent"L];    PrintLine[stats.collisions, "Collisions"];    PrintLine[stats.coll1, "Packets with 1 collision"L];    PrintLine[stats.coll2, "Packets with 2 collisions"L];    PrintLine[stats.coll3, "Packets with 3 collisions"L];    PrintLine[stats.coll4, "Packets with 4 collisions"L];    PrintLine[stats.coll5, "Packets with 5 collisions"L];    PrintLine[stats.coll6, "Packets with 6 collisions"L];    PrintLine[stats.coll7, "Packets with 7 collisions"L];    PrintLine[stats.coll8, "Packets with 8 collisions"L];    PrintLine[stats.coll9, "Packets with 9 collisions"L];    PrintLine[stats.coll10, "Packets with 10 collisions"L];    PrintLine[stats.coll11, "Packets with 11 collisions"L];    PrintLine[stats.coll12, "Packets with 12 collisions"L];    PrintLine[stats.coll13, "Packets with 13 collisions"L];    PrintLine[stats.coll14, "Packets with 14 collisions"L];    PrintLine[stats.coll15, "Packets with 15 collisions"L];    PrintLine[stats.collx, "Packets with funny collision mask  ******"L];    PrintLine[stats.loadOverflow, "Packets with too many collisions"L];    PrintLine[stats.lateCollisions, "Late collisions  ******"L];    PrintLine[stats.errsOut, "Errors from Transmitter"L];    PrintLine[stats.funnyOut, "Funny Output Errors ******"L];    PrintLine[stats.overrunOut, "Output overruns"L];    PrintLine[Mpp[stats.pktsOut], "Microsec/Pkt Sent"L];    PrintLine[BitsPerSecond[stats.wdsOut], "Bits/Sec Sent"L];    PrintLine[stats.pktsIn, "Packets Received OK"L];    PrintLine[stats.wdsIn, "Words Received"L];    PrintLine[stats.wrongLength, "Packets received with wrong length **"L];    PrintLine[      stats.wrongPackets, "Packets received with at least one wrong word **"L];    PrintLine[stats.wrongWords, "Wrong words received **"L];    PrintLine[stats.missed, "Input packets missed (no buffer)"L];    PrintLine[stats.errsIn, "Errors from Receiver"L];    PrintLine[stats.funnyIn, "Funny Input Errors ******"L];    PrintLine[stats.shortIn, "Short Packets ******"L];    PrintLine[stats.longIn, "Long Packets ******"L];    PrintLine[stats.shortBuffer, "Buffer Overflow  ******"L];    PrintLine[stats.itIn, "Input IT only errors  ******"L];    PrintLine[stats.crcIn, "Input CRC errors"L];    PrintLine[stats.crcItIn, "Input CRC+IT errors"L];    PrintLine[stats.overrunIn, "Input overruns"L];    PrintLine[stats.bc, "Broadcast packets Received"L];    PrintLine[stats.bcWords, "Words in Broadcast packets"L];    PrintLine[stats.toMe, "Packets to ME"L];    PrintLine[stats.toOther, "Packets to somebody else"L];    PrintLine[stats.fromMe, "Packets from ME"L];    PrintLine[stats.packetsEchoed, "Packets Echoed"L];    PrintLine[stats.packetsNotEchoed, "Packets Not Echoed (no output buffer)"L];    PrintLine[stats.lateEchos, "Late Echo Packets ****"L];    PrintLine[stats.packetsTooLongToEcho, "Packets Too Long To Echo ****"L];    PrintLine[stats.echosMissed, "Echos Missed"L];    PrintLine[stats.dallyForEcho, "Dallys for Echo"L];    PrintLine[stats.runts, "Runts"L];    PrintLine[stats.runtsMarkedOk, "Runts marked OK  *****"L];    PrintLine[stats.multicastRunts, "Runts via mullticast"L];    PrintLine[Mpp[stats.pktsIn], "Microsec/Pkt Received"L];    PrintLine[BitsPerSecond[stats.wdsIn], "Bits/Sec Received"L];    Put.CR[EtherTesterDefs.log];    END;  PrintLine: PROCEDURE [one: LONG CARDINAL, name: LONG STRING] =    BEGIN    IF one = 0 THEN RETURN;    LD12[one];    Put.Text[EtherTesterDefs.log, "    "L];    Put.Text[EtherTesterDefs.log, name];    Put.CR[EtherTesterDefs.log];    END;  LD: PROCEDURE [u: LONG CARDINAL] =    BEGIN    foo: STRING = [20];    String.AppendLongNumber[foo, u, 10];    Put.Text[EtherTesterDefs.log, foo];    END;  LD12: PROCEDURE [u: LONG CARDINAL] =    BEGIN    foo: STRING = [20];    String.AppendLongNumber[foo, u, 10];    THROUGH [foo.length..12) DO Put.Char[EtherTesterDefs.log, ' ]; ENDLOOP;    Put.Text[EtherTesterDefs.log, foo];    END;  PrintTime: PROCEDURE [w: Window.Handle] =    BEGIN s: STRING = [20]; Time.AppendCurrent[s]; Put.Text[w, s]; END;  BitsPerSecond: PROCEDURE [wd: LONG CARDINAL] RETURNS [LONG CARDINAL] =    BEGIN    t: LONG CARDINAL;    IF elapsedTime < 1000 THEN RETURN[0];    SELECT wd FROM      < 100000000 => BEGIN t ¬ 16*wd; RETURN[t/(elapsedTime/1000)]; END;      ENDCASE => BEGIN t ¬ wd/(elapsedTime/1000); RETURN[16*t]; END;    END;  Mpp: PROCEDURE [packets: LONG CARDINAL] RETURNS [LONG CARDINAL] =    BEGIN    t, p: LONG CARDINAL;    IF packets = 0 THEN RETURN[0];    SELECT elapsedTime FROM      < 2000000 => BEGIN t ¬ elapsedTime*1000; p ¬ packets; END;      ENDCASE =>        BEGIN t ¬ elapsedTime; p ¬ packets/1000; IF p = 0 THEN RETURN[0]; END;    RETURN[t/p];    END;  END.
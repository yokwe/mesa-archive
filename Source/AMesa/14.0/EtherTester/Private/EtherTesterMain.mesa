-- File: EtherTesterMain.mesa - last edit:-- AOF                 10-Apr-87 11:37:40-- Copyright (C) 1983, 1984, 1985, 1987 by Xerox Corporation. All rights reserved. DIRECTORY  BitBlt USING [],  Checksum USING [ComputeChecksum],  Environment USING [Byte],  Inline USING [LongCOPY],  Process USING [    Detach, GetPriority, MsecToTicks, Pause, Priority, priorityBackground,    priorityForeground, SetPriority, SetTimeout, Ticks, Yield],  ProcessPriorities USING [priorityIOLow],  ResidentHeap USING [FreeNode, MakeNode],  Runtime USING [CallDebugger],  SpecialRuntime USING [AllocateNakedCondition, DeallocateNakedCondition],  System USING [broadcastHostNumber, HostNumber, nullNetworkNumber],  TajoMisc USING [SetState],  UserInput USING [UserAbort],  NSConstants USING [echoerSocket],  NSTypes USING [BufferBody],  NewEthernetFace USING [    AddCleanup, DeviceHandle, GetNextDevice, GetPacketLength, GetPacketsMissed,    GetRetries, GetStatus, nullDeviceHandle, QueueInput, QueueOutput, Status,    TurnOff, TurnOn, GlobalStatePtr, globalStateSize],  EtherTesterDefs USING [    AllocateOneBuffer, AllocateOneIOCB, blankDisplay, Buffer, BufferBody,    bumpPacketNumber, broadcasting, check, cursor, doChecksum, dallyBeforeOutput,    dallyIfBehind, dest, FreeOneIOCB, FlipBox, flipem, FreeOneBuffer, Header, log,    me, numberOfRecvBuffers, numberOfSendBuffers, pattern, promiscuous, recvSize,    sendSize, SetupBoxes, SetDownBoxes, showGarbage, showOnlyBadAlign, ShowPacket,    showRunts, showStrangeStatus, showWrongData, showWrongLength, smashTheCursor,    SmashTheCursor, source, stats, StatsInit, StatsPeek, StatsPrint, TestMode,    ticksBeforeSend, UpdateNumbers];EtherTesterMain: MONITOR  IMPORTS    Checksum, NewEthernetFace, Inline, Process, SpecialRuntime, TajoMisc,    UserInput, Runtime, EtherTesterDefs, ResidentHeap  EXPORTS EtherTesterDefs =  BEGIN OPEN EtherTesterDefs;  -- Global Data  activeProcesses: PUBLIC CARDINAL ¬ 0;  lensPattern: ARRAY [0..4) OF Environment.Byte = [0, 125B, 377B, 125B];  -- Private Data  ether: NewEthernetFace.DeviceHandle;  pleaseStop: BOOLEAN;  -- Ethernet packet types:  ns: WORD = 3000B;  nullChecksum: WORD = 177777B;  lastInputBuffer, lastOutputBuffer: Buffer;  oldMissed, recvSequenceNumber, sendSequenceNumber: CARDINAL;  inInterruptBits, outInterruptBits: WORD;  inputWait, outputWait: LONG POINTER TO CONDITION ¬ NIL;  letBackgroundRun, waitToStart, oneTick, fiveSeconds: CONDITION;  endMarker: CARDINAL = 119;  -- Just a random number. . .  state: NewEthernetFace.GlobalStatePtr;   StartTest: PUBLIC PROCEDURE [test: TestMode, board: CARDINAL]    RETURNS [status: BOOLEAN] =    BEGIN    IF ~InitEther[board] THEN RETURN[FALSE];    SELECT test FROM      SendOnly => Start[EtherOutput, NIL];      ReceiveOnly => Start[EtherInput, NIL];      SendAndReceive => Start[EtherInput, EtherOutput];      -- Start receive before send to avoid lost packets      EchoServer => Start[EtherServer, NIL];      EchoUser => Start[EtherUser, NIL];      ENDCASE;    RETURN[TRUE];    END;  InitEther: PROCEDURE [board: CARDINAL] RETURNS [status: BOOLEAN] =    BEGIN    ether ¬ NewEthernetFace.nullDeviceHandle;    THROUGH [1..board] DO      ether ¬ NewEthernetFace.GetNextDevice[ether];      IF ether = NewEthernetFace.nullDeviceHandle THEN EXIT;      ENDLOOP;    IF ether = NewEthernetFace.nullDeviceHandle THEN RETURN[FALSE];    NewEthernetFace.AddCleanup[ether];    Process.SetTimeout[@oneTick, 1];    Process.SetTimeout[@fiveSeconds, Process.MsecToTicks[5000]];    RETURN[TRUE];    END;  StopTheWorld: PUBLIC PROCEDURE =    BEGIN    pleaseStop ¬ TRUE;    UNTIL activeProcesses = 0 DO Process.Pause[1]; PokeEverybody[]; ENDLOOP;    END;  EtherInput: ENTRY PROCEDURE =    BEGIN    this: Buffer ¬ SetupInputBuffers[];    UNTIL pleaseStop DO      status: NewEthernetFace.Status ¬ WaitForInputToArrive[this];      IF status = pending THEN LOOP;      CollectInputStats[this, status];      IF status = ok AND this.header.dest = me AND this.header.source = dest THEN        BEGIN        IF check THEN CheckBuffer[this];        IF doChecksum THEN CheckChecksum[this];        END;      AppendInput[this];      this ¬ this.next;      ENDLOOP;    UNTIL this.idle DO      status: NewEthernetFace.Status ¬ WaitForInputToArrive[this];      IF status = pending THEN EXIT;      CollectInputStats[this, status];      IF status = ok AND this.header.dest = me AND this.header.source = dest THEN        BEGIN        IF check THEN CheckBuffer[this];        IF doChecksum THEN CheckChecksum[this];        END;      this.idle ¬ TRUE;      this ¬ this.next;      ENDLOOP;    ReturnInputBuffers[];    Stopping[];    END;  EtherOutput: ENTRY PROCEDURE =    BEGIN    this: Buffer ¬ SetupOutputBuffers[TRUE];    UNTIL pleaseStop DO      status: NewEthernetFace.Status ¬ WaitUntilBufferHasBeenSent[this];      IF status = pending THEN LOOP;      CollectOutputStats[this, status];      IF dallyIfBehind        AND ((sendSequenceNumber - recvSequenceNumber) >= numberOfSendBuffers)        THEN        BEGIN        stats.dallyForEcho ¬ stats.dallyForEcho + 1;        FlipBox[dally];        WAIT letBackgroundRun;        END;      SendBuffer[this];      this ¬ this.next;      ENDLOOP;    UNTIL this.idle DO      status: NewEthernetFace.Status ¬ WaitUntilBufferHasBeenSent[this];      IF status = pending THEN EXIT;      CollectOutputStats[this, status];      this.idle ¬ TRUE;      this ¬ this.next;      ENDLOOP;    ReturnOutputBuffers[];    Stopping[];    END;  EtherServer: ENTRY PROCEDURE =    BEGIN    this: Buffer ¬ SetupInputBuffers[];    that: Buffer ¬ SetupOutputBuffers[FALSE];    UNTIL pleaseStop DO      status: NewEthernetFace.Status ¬ WaitForInputToArrive[this];      IF status = pending THEN LOOP;      CollectInputStats[this, status];      IF status = ok AND this.header.packetType = ns        AND this.body.destination.socket = NSConstants.echoerSocket        AND this.body.packetType = echo        AND this.body.echoType = echoRequest THEN        BEGIN        outStatus: NewEthernetFace.Status ¬          IF that.idle THEN ok ELSE NewEthernetFace.GetStatus[that.iocb];        IF doChecksum THEN CheckChecksum[this];        IF outStatus # pending THEN          BEGIN          IF ~that.idle THEN CollectOutputStats[that, outStatus];          IF sendSize < NewEthernetFace.GetPacketLength[this.iocb] THEN            BEGIN            stats.packetsTooLongToEcho ¬ stats.packetsTooLongToEcho + 1;            AppendInput[this];            this ¬ this.next;            LOOP;            END;          that.header.dest ¬ this.header.source;          that.header.source ¬ source;          that.header.packetType ¬ ns;          that.length ¬ NewEthernetFace.GetPacketLength[this.iocb];          Inline.LongCOPY[            to: @that.body, from: @this.body, nwords: that.length - SIZE[Header]];          -- Caution: sendSize must be large enough to hold echo packet!	  that.body.transportControl ¬ [FALSE, 0, 0];          that.body.packetType ¬ echo;          that.body.destination ¬ this.body.source;          that.body.source ¬ this.body.destination;          that.body.source.host ¬ source;  -- might be broadcast          that.body.echoType ¬ echoResponse;          IF doChecksum THEN SetChecksum[that]          ELSE that.body.checksum ¬ nullChecksum;          that.idle ¬ FALSE;          AppendOutput[that];          that ¬ that.next;          stats.packetsEchoed ¬ stats.packetsEchoed + 1;          IF flipem THEN FlipBox[echoed];          END        ELSE          BEGIN          stats.packetsNotEchoed ¬ stats.packetsNotEchoed + 1;          IF flipem THEN FlipBox[noOut];          END;        END;      AppendInput[this];      this ¬ this.next;      ENDLOOP;    UNTIL that.idle DO      status: NewEthernetFace.Status ¬ WaitUntilBufferHasBeenSent[that];      IF status = pending THEN EXIT;      CollectOutputStats[that, status];      that.idle ¬ TRUE;      that ¬ that.next;      ENDLOOP;    UNTIL this.idle DO      status: NewEthernetFace.Status ¬ WaitForInputToArrive[this];      IF status = pending THEN EXIT;      CollectInputStats[this, status];      IF status = ok AND this.header.dest = me AND this.header.source = dest THEN        BEGIN        IF check THEN CheckBuffer[this];        IF doChecksum THEN CheckChecksum[this];        END;      this.idle ¬ TRUE;      this ¬ this.next;      ENDLOOP;    ReturnOutputBuffers[];    ReturnInputBuffers[];    Stopping[];    END;  EtherUser: ENTRY PROCEDURE =    BEGIN    this: Buffer ¬ SetupInputBuffers[];    that: Buffer ¬ SetupOutputBuffers[TRUE];    dally: BOOLEAN ¬ TRUE;    UNTIL pleaseStop DO      IF dallyIfBehind AND dally        AND ((sendSequenceNumber - recvSequenceNumber) >= numberOfSendBuffers)        THEN        BEGIN        stats.dallyForEcho ¬ stats.dallyForEcho + 1;        FlipBox[dally];        dally ¬ FALSE;        WAIT letBackgroundRun;        END      ELSE        BEGIN  -- input packets are piling up while we WAIT        status: NewEthernetFace.Status ¬ WaitUntilBufferHasBeenSent[that];        IF status # pending THEN          BEGIN          CollectOutputStats[that, status];          SendBuffer[that];          that ¬ that.next;          END;        dally ¬ TRUE;        END;      UNTIL pleaseStop DO  -- look all of the packets that have arrived        status: NewEthernetFace.Status ¬ NewEthernetFace.GetStatus[this.iocb];        IF status = pending THEN EXIT;        CollectInputStats[this, status];        ProcessEchoBuffer[this, status];        this ¬ this.next;        ENDLOOP;      ENDLOOP;    UNTIL that.idle DO      status: NewEthernetFace.Status;      THROUGH [0..1000) DO        status ¬ NewEthernetFace.GetStatus[that.iocb];        IF status # pending THEN EXIT;        ENDLOOP;      IF status = pending THEN EXIT;      CollectOutputStats[that, status];      that.idle ¬ TRUE;      that ¬ that.next;      ENDLOOP;    UNTIL this.idle DO      status: NewEthernetFace.Status ¬ WaitForInputToArrive[this];      IF status = pending THEN EXIT;      CollectInputStats[this, status];      ProcessEchoBuffer[this, status];      this.idle ¬ TRUE;      this ¬ this.next;      ENDLOOP;    ReturnInputBuffers[];    ReturnOutputBuffers[];    Stopping[];    END;  SendBuffer: INTERNAL PROCEDURE [that: Buffer] =    BEGIN    IF check THEN FillBuffer[that]    ELSE      BEGIN      IF bumpPacketNumber THEN sendSequenceNumber ¬ sendSequenceNumber + 1;      that.body.echoWords[0] ¬ sendSequenceNumber;      END;    IF doChecksum THEN SetChecksum[that] ELSE that.body.checksum ¬ nullChecksum;    IF dallyBeforeOutput THEN WAIT letBackgroundRun;    DelayBeforeSending[];    AppendOutput[that];    END;  ProcessEchoBuffer: INTERNAL PROCEDURE [    this: Buffer, status: NewEthernetFace.Status] =    BEGIN    IF status = ok AND this.header.dest = me AND this.header.source = dest      AND this.body.echoType = echoResponse THEN      BEGIN      thisSequenceNumber: CARDINAL ¬ this.body.echoWords[0];      IF doChecksum THEN CheckChecksum[this];      IF bumpPacketNumber THEN recvSequenceNumber ¬ recvSequenceNumber + 1;      SELECT LOOPHOLE[thisSequenceNumber - recvSequenceNumber, INTEGER] FROM        0 =>          BEGIN          stats.packetsEchoed ¬ stats.packetsEchoed + 1;          IF flipem THEN FlipBox[echoed];          IF check THEN CheckBuffer[this];          END;        > 0 =>          BEGIN  -- Early, we must have lost something          UNTIL recvSequenceNumber = thisSequenceNumber DO            stats.echosMissed ¬ stats.echosMissed + 1;            IF flipem THEN FlipBox[lost];            IF bumpPacketNumber THEN recvSequenceNumber ¬ recvSequenceNumber + 1;            ENDLOOP;          -- Copy of code above for normal case          stats.packetsEchoed ¬ stats.packetsEchoed + 1;          IF flipem THEN FlipBox[echoed];          IF check THEN CheckBuffer[this];          END;        < 0 =>          BEGIN          stats.lateEchos ¬ stats.lateEchos + 1;          IF flipem THEN FlipBox[late];          IF bumpPacketNumber THEN recvSequenceNumber ¬ recvSequenceNumber - 1;          END;        ENDCASE => ERROR;      END;    AppendInput[this];    END;  SetupInputBuffers: INTERNAL PROCEDURE RETURNS [Buffer] =    BEGIN    recvSequenceNumber ¬ 0;    lastInputBuffer ¬ AllocateBuffer[recvSize];    lastInputBuffer.next ¬ lastInputBuffer;    THROUGH [1..numberOfRecvBuffers) DO      temp: Buffer ¬ AllocateBuffer[recvSize];      -- put on front of chain      temp.next ¬ lastInputBuffer.next;      lastInputBuffer.next ¬ temp;      ENDLOOP;    oldMissed ¬ NewEthernetFace.GetPacketsMissed[ether];    FOR finger: Buffer ¬ lastInputBuffer.next, finger.next DO      AppendInput[finger]; IF finger = lastInputBuffer THEN EXIT; ENDLOOP;    WAIT waitToStart;  -- until everybody else is ready before playing with the cursor    RETURN[lastInputBuffer.next];    END;  ReturnInputBuffers: PROCEDURE =    BEGIN    finger: Buffer ¬ lastInputBuffer.next;    lastInputBuffer.next ¬ NIL;    TurnEtherOff[];  -- Beware of MapOutOfBounds    UNTIL finger = NIL DO      temp: Buffer ¬ finger.next; FreeBuffer[finger]; finger ¬ temp; ENDLOOP;    END;  SetupOutputBuffers: INTERNAL PROCEDURE [start: BOOLEAN] RETURNS [Buffer] =    BEGIN    sendSequenceNumber ¬ 0;    lastOutputBuffer ¬ AllocateBuffer[sendSize];    lastOutputBuffer.next ¬ lastOutputBuffer;    THROUGH [1..numberOfSendBuffers) DO      temp: Buffer ¬ AllocateBuffer[sendSize];      -- put on front of chain      temp.next ¬ lastOutputBuffer.next;      lastOutputBuffer.next ¬ temp;      ENDLOOP;    FOR finger: Buffer ¬ lastOutputBuffer.next, finger.next DO      DelayBeforeSending[];      FillBuffer[finger];      IF doChecksum THEN SetChecksum[finger]      ELSE finger.body.checksum ¬ nullChecksum;      IF start THEN AppendOutput[finger] ELSE finger.idle ¬ TRUE;      IF finger = lastOutputBuffer THEN EXIT;      ENDLOOP;    RETURN[lastOutputBuffer.next];    END;  ReturnOutputBuffers: PROCEDURE =    BEGIN    finger: Buffer ¬ lastOutputBuffer.next;    lastOutputBuffer.next ¬ NIL;    -- Give output a chance to unwind so we don't generate a bad packet    THROUGH [0..1000) DO Process.Yield[]; ENDLOOP;    TurnEtherOff[];    UNTIL finger = NIL DO      temp: Buffer ¬ finger.next; FreeBuffer[finger]; finger ¬ temp; ENDLOOP;    END;  WaitForInputToArrive: INTERNAL PROCEDURE [b: Buffer]    RETURNS [status: NewEthernetFace.Status] =    BEGIN    status ¬ pending;    UNTIL pleaseStop OR (status ¬ NewEthernetFace.GetStatus[b.iocb]) # pending DO      WAIT inputWait; ENDLOOP;    END;  CollectInputStats: INTERNAL PROCEDURE [    this: Buffer, status: NewEthernetFace.Status] =    BEGIN    length: CARDINAL = NewEthernetFace.GetPacketLength[this.iocb];    temp: CARDINAL ¬ NewEthernetFace.GetPacketsMissed[ether];    IF this.endPlusOne­ # endMarker THEN      BEGIN      screwup: STRING = "Microcode wrote past the end of the buffer"L;      ShowPacket[screwup, this];      Runtime.CallDebugger[screwup];      END;    stats.missed ¬ stats.missed + (temp - oldMissed);    oldMissed ¬ temp;    cursor[2] ¬ cursor[2] + 1;    IF flipem THEN FlipBox[recv];    IF length < SIZE[Header] THEN      BEGIN      stats.runts ¬ stats.runts + 1;      IF status = ok THEN stats.runtsMarkedOk ¬ stats.runtsMarkedOk + 1;      IF ~promiscuous AND this.header.dest # me        AND this.header.dest # System.broadcastHostNumber THEN        stats.multicastRunts ¬ stats.multicastRunts + 1;      IF showRunts THEN ShowPacket["Runt", this];      RETURN;      END;    SELECT status FROM      ok =>        BEGIN        stats.pktsIn ¬ stats.pktsIn + 1;        stats.wdsIn ¬ stats.wdsIn + length;        SELECT this.header.dest FROM          System.broadcastHostNumber =>            BEGIN            stats.bc ¬ stats.bc + 1;            stats.bcWords ¬ stats.bcWords + length;            END;          me => stats.toMe ¬ stats.toMe + 1;          ENDCASE => stats.toOther ¬ stats.toOther + 1;        SELECT this.header.source FROM          me => stats.fromMe ¬ stats.fromMe + 1;          ENDCASE => NULL;        IF this.header.dest = me AND this.header.source = dest THEN          BEGIN          IF length # sendSize THEN            BEGIN            IF length < sendSize THEN stats.shortIn ¬ stats.shortIn + 1;            IF length > sendSize THEN stats.longIn ¬ stats.longIn + 1;            IF showWrongLength THEN              ShowPacket["Wrong length packet marked ok", this];            END;          END;        END;      ENDCASE =>        BEGIN        cursor[0] ¬ cursor[0] + 1;        IF flipem THEN FlipBox[errIn];        stats.errsIn ¬ stats.errsIn + 1;        SELECT status FROM          packetTooLong => stats.shortBuffer ¬ stats.shortBuffer + 1;          badAlignmentButOkCrc =>            BEGIN            stats.itIn ¬ stats.itIn + 1;            IF showOnlyBadAlign THEN ShowPacket["Only bad alignment", this];            END;          crc => stats.crcIn ¬ stats.crcIn + 1;          crcAndBadAlignment => stats.crcItIn ¬ stats.crcItIn + 1;          overrun => stats.overrunIn ¬ stats.overrunIn + 1;          ENDCASE =>            BEGIN            stats.funnyIn ¬ stats.funnyIn + 1;            IF showStrangeStatus THEN              BEGIN              ShowPacket["Funny input status", this];              Pause[];  -- don't print out too much              END;            END;        IF showGarbage THEN ShowPacket["Garbage packet", this];        END;    END;  DelayBeforeSending: INTERNAL PROCEDURE =    BEGIN    THROUGH [0..ticksBeforeSend) UNTIL pleaseStop DO WAIT oneTick; ENDLOOP;    END;  WaitUntilBufferHasBeenSent: INTERNAL PROCEDURE [b: Buffer]    RETURNS [status: NewEthernetFace.Status] =    BEGIN    UNTIL (status ¬ NewEthernetFace.GetStatus[b.iocb]) # pending DO      IF pleaseStop THEN RETURN[pending]; WAIT outputWait; ENDLOOP;    END;  CollectOutputStats: INTERNAL PROCEDURE [    this: Buffer, status: NewEthernetFace.Status] =    BEGIN    cursor[5] ¬ cursor[5] + 1;    IF flipem THEN FlipBox[sent];    SELECT status FROM      ok =>        BEGIN        retries: CARDINAL = NewEthernetFace.GetRetries[this.iocb];        stats.pktsOut ¬ stats.pktsOut + 1;        stats.wdsOut ¬ stats.wdsOut + this.length;        stats.collisions ¬ stats.collisions + retries;        SELECT retries FROM          0 => NULL;          1 => stats.coll1 ¬ stats.coll1 + 1;          2 => stats.coll2 ¬ stats.coll2 + 1;          3 => stats.coll3 ¬ stats.coll3 + 1;          4 => stats.coll4 ¬ stats.coll4 + 1;          5 => stats.coll5 ¬ stats.coll5 + 1;          6 => stats.coll6 ¬ stats.coll6 + 1;          7 => stats.coll7 ¬ stats.coll7 + 1;          8 => stats.coll8 ¬ stats.coll8 + 1;          9 => stats.coll9 ¬ stats.coll9 + 1;          10 => stats.coll10 ¬ stats.coll10 + 1;          11 => stats.coll11 ¬ stats.coll11 + 1;          12 => stats.coll12 ¬ stats.coll12 + 1;          13 => stats.coll13 ¬ stats.coll13 + 1;          14 => stats.coll14 ¬ stats.coll14 + 1;          15 => stats.coll15 ¬ stats.coll15 + 1;          ENDCASE =>            BEGIN            stats.collx ¬ stats.collx + 1;            IF showStrangeStatus THEN              ShowPacket["Funny retransmission mask", this];            END;        END;      ENDCASE =>        BEGIN        cursor[0] ¬ cursor[0] + 1;        IF flipem THEN FlipBox[errOut];        stats.errsOut ¬ stats.errsOut + 1;        SELECT status FROM          tooManyCollisions => stats.loadOverflow ¬ stats.loadOverflow + 1;          underrun => stats.overrunOut ¬ stats.overrunOut + 1;          lateCollision =>            BEGIN            stats.lateCollisions ¬ stats.lateCollisions + 1;            IF showGarbage THEN ShowPacket["Late Collision", this];            END;          ENDCASE =>            BEGIN            stats.funnyOut ¬ stats.funnyOut + 1;            IF showStrangeStatus THEN ShowPacket["Funny output status", this];            Pause[];  -- don't print out too much            END;        END;    END;  FillBuffer: PROCEDURE [this: Buffer] =    BEGIN    end: CARDINAL =      sendSize - SIZE[Header] - SIZE[echo NSTypes.BufferBody] - 1;    IF bumpPacketNumber THEN sendSequenceNumber ¬ sendSequenceNumber + 1;    IF end < sendSize THEN      SELECT pattern FROM        zeros =>          FOR i: CARDINAL IN (0..end) DO this.body.echoWords[i] ¬ 0; ENDLOOP;        ones =>          FOR i: CARDINAL IN (0..end) DO            this.body.echoWords[i] ¬ 177777B; ENDLOOP;        alternating =>          FOR i: CARDINAL IN (0..end) DO            this.body.echoWords[i] ¬ 125252B; ENDLOOP;        pairs =>          FOR i: CARDINAL IN (0..end) DO            this.body.echoWords[i] ¬ 146314B; ENDLOOP;        oneTwentyFive =>          FOR i: CARDINAL IN (0..end) DO this.body.echoWords[i] ¬ 125B; ENDLOOP;        countBytes =>          FOR i: CARDINAL IN (0..end) DO            k: CARDINAL ¬ i*2; this.body.echoWords[i] ¬ k*400B + k + 1; ENDLOOP;        countWords, ignore =>          FOR i: CARDINAL IN (0..end) DO this.body.echoWords[i] ¬ i; ENDLOOP;        lenOne =>          FOR i: CARDINAL IN [2..2*end) DO            this.body.echoBytes[i] ¬ lensPattern[i/1 MOD 4]; ENDLOOP;        lenSix =>          FOR i: CARDINAL IN [2..2*end) DO            this.body.echoBytes[i] ¬ lensPattern[i/6 MOD 4]; ENDLOOP;        ENDCASE =>          FOR i: CARDINAL IN (0..end) DO this.body.echoWords[i] ¬ 1000B; ENDLOOP;    this.header.dest ¬ IF broadcasting THEN System.broadcastHostNumber ELSE dest;    this.header.source ¬ source;    this.header.packetType ¬ ns;    this.body ¬ [      checksum:, pktLength: 2*(sendSize - SIZE[Header]),      transportControl: [FALSE, 0, 0], packetType: echo,      destination: [System.nullNetworkNumber, dest, NSConstants.echoerSocket],      source: [System.nullNetworkNumber, source, LOOPHOLE[sendSequenceNumber]],      nsBody: echo[echoType: echoRequest, echoBody:]];    this.body.echoWords[0] ¬ sendSequenceNumber;    END;  CheckBuffer: PROCEDURE [this: Buffer] =    BEGIN    end: CARDINAL =      sendSize - SIZE[Header] - SIZE[echo NSTypes.BufferBody] - 1;    bad: CARDINAL ¬ 0;    length: CARDINAL = NewEthernetFace.GetPacketLength[this.iocb];    IF length # sendSize THEN      BEGIN stats.wrongLength ¬ stats.wrongLength + 1; RETURN; END;    IF end < sendSize THEN      SELECT pattern FROM        ignore => NULL;        zeros =>          FOR i: CARDINAL IN (0..end) DO            IF this.body.echoWords[i] # 0 THEN bad ¬ bad + 1; ENDLOOP;        ones =>          FOR i: CARDINAL IN (0..end) DO            IF this.body.echoWords[i] # 177777B THEN bad ¬ bad + 1; ENDLOOP;        alternating =>          FOR i: CARDINAL IN (0..end) DO            IF this.body.echoWords[i] # 125252B THEN bad ¬ bad + 1; ENDLOOP;        pairs =>          FOR i: CARDINAL IN (0..end) DO            IF this.body.echoWords[i] # 146314B THEN bad ¬ bad + 1; ENDLOOP;        oneTwentyFive =>          FOR i: CARDINAL IN (0..end) DO            IF this.body.echoWords[i] # 125B THEN bad ¬ bad + 1; ENDLOOP;        countBytes =>          FOR i: CARDINAL IN (0..end) DO            k: CARDINAL ¬ i*2;            IF this.body.echoWords[i] # k*400B + k + 1 THEN bad ¬ bad + 1;            ENDLOOP;        countWords =>          FOR i: CARDINAL IN (0..end) DO            IF this.body.echoWords[i] # i THEN bad ¬ bad + 1; ENDLOOP;        lenOne =>          FOR i: CARDINAL IN [2..end) DO            IF this.body.echoBytes[i] # lensPattern[i/1 MOD 4] THEN bad ¬ bad + 1;            ENDLOOP;        lenSix =>          FOR i: CARDINAL IN [2..end) DO            IF this.body.echoBytes[i] # lensPattern[i/6 MOD 4] THEN bad ¬ bad + 1;            ENDLOOP;        ENDCASE => NULL;    IF bad # 0 THEN      BEGIN      stats.wrongPackets ¬ stats.wrongPackets + 1;      stats.wrongWords ¬ stats.wrongWords + bad;      IF showWrongData THEN ShowPacket["Data mismatch", this];      END;    END;  SetChecksum: PROCEDURE [b: Buffer] =    BEGIN    words: CARDINAL;    words ¬ (b.body.pktLength - 1)/2;    IF words < SIZE[Header] + SIZE[echo NSTypes.BufferBody] THEN      b.body.checksum ¬ nullChecksum    ELSE      b.body.checksum ¬ Checksum.ComputeChecksum[        nWords: words, p: @b.body.pktLength];    END;  CheckChecksum: PROCEDURE [b: Buffer] =    BEGIN    words: CARDINAL;    checksum: WORD;    IF b.body.checksum = nullChecksum THEN RETURN;    words ¬ (b.body.pktLength - 1)/2;    IF words > b.length THEN RETURN;    -- must be a bad length field in the packet    checksum ¬ Checksum.ComputeChecksum[nWords: words, p: @b.body.pktLength];    IF b.body.checksum # checksum THEN ShowPacket["Bad Software Checksum", b];    END;  AppendInput: PROCEDURE [new: Buffer] =    BEGIN    p: LONG POINTER ¬ @new.header;    FOR i: CARDINAL IN [0..20) DO (p + i)­ ¬ 0; ENDLOOP;    NewEthernetFace.QueueInput[ether, @new.header, new.length, new.iocb];    END;  AppendOutput: PROCEDURE [new: Buffer] =    BEGIN    NewEthernetFace.QueueOutput[ether, @new.header, new.length, new.iocb];    END;  AllocateBuffer: PROCEDURE [size: CARDINAL] RETURNS [b: Buffer] =    BEGIN    b ¬ AllocateOneBuffer[SIZE[BufferBody] + size];    -- We're allocating more than we need. The driver thinks the buffer ends at    -- @b.header + size and it really ends at @b.header + size + SIZE[Header]    -- + SIZE[echo NSTypes.BufferBody].    b.length ¬ size;    b.idle ¬ FALSE;    b.endPlusOne ¬ LOOPHOLE[@b.header + size];    b.endPlusOne­ ¬ endMarker;    -- marks the end of the buffer so we can see if the microcode overshoots    b.iocb ¬ AllocateOneIOCB[];    END;  FreeBuffer: PROCEDURE [b: Buffer] =    BEGIN FreeOneIOCB[b.iocb]; FreeOneBuffer[b]; END;  InitializeCSBs: PUBLIC PROCEDURE =    BEGIN    [inputWait, inInterruptBits] ¬ SpecialRuntime.AllocateNakedCondition[];    [outputWait, outInterruptBits] ¬ SpecialRuntime.AllocateNakedCondition[];    Process.SetTimeout[inputWait, 100];    Process.SetTimeout[outputWait, 100];    END;  CleanThingsUp: PUBLIC PROCEDURE =    BEGIN    DoIt: PROCEDURE [who: LONG POINTER TO LONG POINTER TO CONDITION] =      BEGIN      IF who­ = NIL THEN RETURN;      SpecialRuntime.DeallocateNakedCondition[who­];      who­ ¬ NIL;      END;    DoIt[@inputWait];    DoIt[@outputWait];    END;  TurnEtherOn: PROCEDURE =    BEGIN    host: System.HostNumber;    state ¬ IF NewEthernetFace.globalStateSize # 0 THEN      ResidentHeap.MakeNode[NewEthernetFace.globalStateSize, a8].node      ELSE LOOPHOLE[NIL];    host ¬ IF promiscuous THEN System.broadcastHostNumber ELSE source;    NewEthernetFace.TurnOn[      ether, LOOPHOLE[host], inInterruptBits, outInterruptBits, state];    END;  TurnEtherOff: PROCEDURE =  BEGIN  NewEthernetFace.TurnOff[ether];  IF NewEthernetFace.globalStateSize # 0 THEN [] ¬ ResidentHeap.FreeNode[state];   END;  Pause: INTERNAL PROCEDURE = BEGIN WAIT fiveSeconds; END;  StartOne: ENTRY PROCEDURE [who: PROCEDURE] =    BEGIN activeProcesses ¬ activeProcesses + 1; Process.Detach[FORK who[]]; END;  Start: PROCEDURE [a, b: PROCEDURE] =    BEGIN    oldPriority: Process.Priority = Process.GetPriority[];    SetupBoxes[];    IF blankDisplay THEN [] ¬ TajoMisc.SetState[off];    activeProcesses ¬ 0;  -- input watcher    pleaseStop ¬ FALSE;    StatsInit[];    TurnEtherOn[];    Process.SetPriority[ProcessPriorities.priorityIOLow];    StartOne[WaitForStop];    Process.SetPriority[Process.priorityForeground];    IF a # NIL THEN StartOne[a];    IF b # NIL THEN StartOne[b];    Process.SetPriority[Process.priorityBackground];    Process.Detach[FORK Watcher[]];    Process.SetPriority[oldPriority];    END;  Watcher: PROCEDURE =    BEGIN    -- Let starter get back to Tajo so it won't smash our cursor    THROUGH [0..100) DO Process.Yield[]; ENDLOOP;    cursor ¬ [-1, 0, 0, 0, 0, 0, 0, -1];    StartEverybody[];    UNTIL activeProcesses = 0 DO      StatsPeek[];      Process.Yield[];      StartEverybody[];      FlipBox[idle];      UpdateNumbers[];      IF smashTheCursor THEN SmashTheCursor[];      ENDLOOP;    IF blankDisplay THEN [] ¬ TajoMisc.SetState[on];    SetDownBoxes[];    StatsPrint[FALSE];    END;  StartEverybody: ENTRY PROCEDURE =    BEGIN BROADCAST waitToStart; BROADCAST letBackgroundRun; END;  PokeEverybody: ENTRY PROCEDURE =    BEGIN NOTIFY inputWait­; NOTIFY outputWait­; END;  DontBeAHog: PUBLIC PROCEDURE RETURNS [stop: BOOLEAN] =    BEGIN    IF UserInput.UserAbort[log] THEN pleaseStop ¬ TRUE;    Process.Yield[];    RETURN[pleaseStop];    END;  WaitForStop: PROCEDURE =    BEGIN    halfSecond: Process.Ticks = Process.MsecToTicks[500];    UNTIL pleaseStop DO      IF UserInput.UserAbort[log] THEN pleaseStop ¬ TRUE;      Process.Pause[5];  -- don't hang on our ML if sender is swamped      ENDLOOP;    EnterStopping[];    END;  EnterStopping: ENTRY PROCEDURE =    BEGIN    Stopping[];    END;  Stopping: INTERNAL PROCEDURE =    BEGIN    activeProcesses ¬ activeProcesses - 1;    pleaseStop ¬ TRUE;    BROADCAST fiveSeconds;    BROADCAST inputWait­;    END;  END.
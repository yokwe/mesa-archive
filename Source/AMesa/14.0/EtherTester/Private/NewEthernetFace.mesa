-- Copyright (C) 1982, 1984  by Xerox Corporation. All rights reserved. -- NewEthernetFace.mesa, HGM, 15-Mar-82 17:25:36DIRECTORY  Environment USING [Base],  HostNumbers USING [HostNumber];NewEthernetFace: DEFINITIONS =  BEGIN  -- Note: This in an Ethernet 2 face.  See EthernetOneFace for the interface to the old Ethernet.  -- We may also have to do something about multicasting one of these days.  -- PROCEDURES  GetNextDevice: PROCEDURE [DeviceHandle] RETURNS [DeviceHandle];  -- Return handle of next device in physical order (starts and ends with EthernetFace.nullDeviceHandle).  AddCleanup: PROCEDURE [DeviceHandle];  RemoveCleanup: PROCEDURE [DeviceHandle];  -- Add/delete the device cleanup procedure which is used to turn off an Ethernet controller around world swaps (see DeviceCleanup.mesa).  For now, RemoveCleanup doesn't do anything, but the (leftover) cleanup proc is careful to avoid doing anything nasty.  (Extra calls to AddCleanup are currently ignored.)  TurnOn: PROCEDURE [    device: DeviceHandle, host: HostNumbers.HostNumber,    inInterrupt, outInterrupt: WORD, globalState: GlobalStatePtr];  TurnOff: PROCEDURE [device: DeviceHandle];  -- Turn on/off the device associated with this DeviceHandle.  Calling TurnOn when the device is already on may forget any operations currently in progress.  Extra calls to TurnOff are harmless.   QueueOutput: PROCEDURE [    device: DeviceHandle, buffer: LONG POINTER, length: CARDINAL,    cb: ControlBlock];  QueueInput: PROCEDURE [    device: DeviceHandle, buffer: LONG POINTER, length: CARDINAL,    cb: ControlBlock];  -- Queue the buffer for transmit or receive.  A (different) control block must be passed in with each call for the private use of the head.  cb should be a pointer to a block of EthernetFace.controlBlockSize words.  It must be allocated within the first 64K and must be quad word aligned.  The buffer must have 11 in the low 2 bits (ie it starts one word before a quad word aligned buffer) and less than 32K words long.  When GetStatus[cb] returns anything other than pending, both the control block and the data buffer are available for reuse.   GetStatus: PROCEDURE [cb: ControlBlock] RETURNS [status: Status];  -- Returns the status of the packet associated with this control block.  See the comments on Status below.  GetRetries: PROCEDURE [cb: ControlBlock] RETURNS [CARDINAL];  -- Returns the number of times the packet was retransmitted because of collisions.  GetPacketLength: PROCEDURE [cb: ControlBlock] RETURNS [CARDINAL];  -- Returns the length in words of a recently arrived packet.  GetPacketsMissed: PROCEDURE [DeviceHandle] RETURNS [CARDINAL];  -- Returns the number of input packets missed because a buffer was not ready.  -- TYPES  DeviceHandle: TYPE [1];  GlobalStatePtr: TYPE = Environment.Base RELATIVE POINTER;  Status: TYPE = {    pending, ok,    overrun,  -- Input data arrived when FIFO was full    underrun,  -- Output FIFO went empty before end of packet was set    packetTooLong,  -- Input packet didn't fit into buffer    tooManyCollisions,  -- More than 16 attempts to transmit the same packet    lateCollision,  -- Somebody steped on the packet after a round trip time    crc, crcAndBadAlignment,    badAlignmentButOkCrc,  -- aka Dribble    spare1, spare2, spare3, otherError};  -- Note: The error conditions are an open ended set to allow a smart driver to collect statistics.  Thus new error conditions may be added to allow more sophisticated data collection, so a driver should not get upset if it encounters a strange error status that it does not understand.  ControlBlock: TYPE = LONG POINTER TO ControlBlockRecord;  ControlBlockRecord: TYPE;  -- EXPORTED VARIABLES  globalStateSize: READONLY CARDINAL;  controlBlockSize: READONLY CARDINAL;  nullDeviceHandle: READONLY DeviceHandle;  hearSelf: READONLY BOOLEAN;  END.
-- Copyright (C) 1981, 1982, 1983, 1986 by Xerox Corporation. All rights reserved. -- file: CSegDebugContents.mesa--  Bruce,	 5-Oct-81 20:39:35--  Sweet,	11-Sep-83  1:27:48--  Haynes,	29-Nov-82 15:49:59--  Wagner,	17-Jun-86 17:20:04DIRECTORY  Ascii,  CatchFormat,  CSegDebugDefs,  DebugUsefulDefs,  Environment,  ESCAlpha,  Format,  FormSW,  Inline,  Mopcodes,  MopOps,  OpTableDefs,  PrincOps,  PrincOpsExtras2,  RESOut,  String;  CSegDebugContents: PROGRAM   IMPORTS     DebugUsefulDefs, Inline, MopOps, OpTableDefs, RESOut   EXPORTS CSegDebugDefs =  BEGIN OPEN RESOut, CSegDebugDefs;  gFrame: PUBLIC LONG CARDINAL ¬ 0;  gfi: PUBLIC CARDINAL ¬ 0;  bytePC: PUBLIC CARDINAL ¬ 0;  nBytes: PUBLIC CARDINAL ¬ 10;  bytesShown: PUBLIC CARDINAL ¬ 0;  bytesSeen: PUBLIC CARDINAL ¬ 0;  absMode: PUBLIC BOOLEAN ¬ FALSE;  absAddr: PUBLIC LONG CARDINAL ¬ 0;      EscName: PROC [alpha: BYTE] = {    s: STRING ¬ [12];    MopOps.AppendEscAlpha[s, alpha];    IF s.length < 8 THEN THROUGH [s.length..8) DO PChar[Ascii.SP] ENDLOOP     ELSE PChar[Ascii.SP];    PString[s]};      SdName: PROC [op: BYTE] = {    s: STRING ¬ [12];    MopOps.AppendSdName[s, op];    IF s.length < 8 THEN THROUGH [s.length..8) DO PChar[Ascii.SP] ENDLOOP     ELSE PChar[Ascii.SP];    PString[s]};          shortfall: CARDINAL ¬ 0;  offset: CARDINAL;  byte: [0..1];  GetByte: PROC RETURNS [b: BYTE] =    BEGIN    w: RECORD [high, low: BYTE] = GetWord[offset];    b ¬ IF byte = 0 THEN w.high ELSE w.low;    byte ¬ 1 - byte;    IF byte = 0 THEN offset ¬ offset + 1;    END;  GetWord: PROC [delta: INTEGER] RETURNS [UNSPECIFIED] =    BEGIN    IF absMode THEN      RETURN [DebugUsefulDefs.LongREAD[LOOPHOLE[absAddr + delta]]]    ELSE      BEGIN      gfte: PrincOpsExtras2.GFTItem;      ReadGFTEntry[@gfte];      gfte.codebase.out ¬ FALSE;      RETURN [DebugUsefulDefs.LongREAD[gfte.codebase.codebase + delta]];      END;    END;      DoubleWord: TYPE = RECORD [    SELECT OVERLAID * FROM      dbl => [w1, w2: CARDINAL],      lnk => [link: PrincOps.ControlLink],      ENDCASE];  GetDouble: PROC [delta: INTEGER] RETURNS [d: DoubleWord] =    BEGIN    d.w1 ¬ GetWord[delta];    d.w2 ¬ GetWord[delta+1];    END;  PutAsCode: PUBLIC PROCEDURE =    BEGIN    shortfall ¬ PutCodeBytes[nBytes];    bytesShown ¬ nBytes - shortfall;    END;  PutAsOctal: PUBLIC PROCEDURE =    BEGIN    offset ¬ bytePC/2;    byte ¬ bytePC MOD 2;    IF byte # 0 THEN offset ¬ offset + 1;    PutOctalWords[nBytes];    bytesShown ¬ 2*nBytes + byte;    END;  PutAsAscii: PUBLIC PROCEDURE =    BEGIN    offset ¬ bytePC/2;    byte ¬ bytePC MOD 2;    PutAsciiText[nBytes];    bytesShown ¬ nBytes;    END;  PutAsBytes: PUBLIC PROCEDURE =    BEGIN    offset ¬ bytePC/2;    byte ¬ bytePC MOD 2;    PutOctalBytes[nBytes];    bytesShown ¬ nBytes;    END;    UpdateGFI: PUBLIC PROCEDURE =    BEGIN    gfo: PrincOpsExtras2.GlobalOverhead;    ReadGFrame[@gfo];    gfi ¬ Inline.BITAND[gfo.word, 0FFFCH];    END;  UpdateGFrame: PUBLIC PROCEDURE =    BEGIN    gfte: PrincOpsExtras2.GFTItem;    ReadGFTEntry[@gfte];    gFrame ¬ LOOPHOLE[gfte.globalFrame];    END;    BumpGFI: PUBLIC PROCEDURE =    BEGIN    gfi ¬ gfi + SIZE[PrincOpsExtras2.GFTItem];    UpdateGFrame[];    END;  DisplayPrefix: PUBLIC PROC =    BEGIN    csp: PrincOps.CodeSegment;    gfo: PrincOpsExtras2.GlobalOverhead;    PCr[];    IF ~absMode THEN      BEGIN      ReadGFrame[@gfo];      PString["Frame: "L];      PLongOctal[gFrame];      PNextOctal["gfi"L, Inline.BITAND[gfo.word, 0FFFCH]];      PrintCodeBase[Inline.BITAND[gfo.word, 0FFFCH]];      IF gfo.word.codelinks THEN PNext["codelinks"L];      IF ~gfo.extra.started THEN PNext["~started"L];      IF gfo.extra.copied THEN PNext["copied"L];      IF gfo.extra.alloced THEN PNext["alloced"L];      IF gfo.extra.shared THEN PNext["shared"L];      IF gfo.word.trapxfers THEN PNext["trapxfers"L];      PCr[];      PString["Code - "L];      END;    ReadPrefix[@csp];    PString["globalFsi: "L]; POctal[csp.header.globalFsi];    PNextUnsigned["nlinks"L, csp.header.nlinks];    IF csp.header.stops THEN PNext["stops"L];    IF csp.header.available # 0 THEN       PNextOctal["available"L, csp.header.available];    PNextUnsigned["mainPC"L, csp.header.mainBodyPC];    PNextUnsigned["catchEV"L, csp.header.catchCode/2];    END;      DisplayLocalFrame: PUBLIC PROC [frame: PrincOps.LocalFrameHandle] = {    overhead: PrincOps.LocalOverhead;    nlocals: CARDINAL;    PCr[];    PString["Local Frame: "L];    POctal[frame];    IF LOOPHOLE[frame, CARDINAL] MOD 4 # 0 THEN {      PString[" -- not 0 mod 4"L]; RETURN};    DebugUsefulDefs.LongCopyREAD[      from: frame - SIZE[PrincOps.LocalOverhead],      to: @overhead,      nwords: SIZE[PrincOps.LocalOverhead]];    PNextUnsigned["fsi"L, overhead.word.fsi];    PNextOctal["ret", overhead.returnlink];    PNextOctal["gfi", overhead.globallink];    PNextOctal["pc", overhead.pc];    nlocals ¬ PrincOps.FrameVec[overhead.word.fsi] - SIZE[PrincOps.LocalOverhead];    PCr[];    FOR i: CARDINAL IN [0..nlocals) DO      val: CARDINAL = DebugUsefulDefs.ShortREAD[frame + i];      cols: CARDINAL ¬ Log8[val];      IF val > 7 THEN cols ¬ cols + 1;      IF i # 0 AND MakeRoom[cols+2, 0] THEN PString[", "]      ELSE {PString["local("L]; POctal[i]; PString["):	"L]};      POctal[val];      ENDLOOP};  DisplayCatchInfo: PUBLIC PROC =    BEGIN OPEN CatchFormat;    catchEV: CatchEV;    count, enableCount: CARDINAL;    enableTable: EnableTable;    PCr[];    [catchEV: catchEV, catchCount: count,     enableTable: enableTable, enableCount: enableCount] ¬ FindCatchTables[];    PString["catchEV: "L]; POctal[catchEV];    IF catchEV = CatchEVNull THEN RETURN;        PNextUnsigned["nCEntries", count];    PNextUnsigned["nOuterEna"L, enableCount];    END;  CatchEVNull: CatchFormat.CatchEV = LOOPHOLE[0];  EnableTableNull: CatchFormat.EnableTable = LOOPHOLE[0];    FindCatchTables: PRIVATE PROC RETURNS [    catchEV: CatchFormat.CatchEV, catchCount: CARDINAL,     enableTable: CatchFormat.EnableTable, enableCount: CARDINAL] =    BEGIN    csp: PrincOps.CodeSegment;    epc: PrincOps.BytePC;    ReadPrefix[@csp];    epc ¬ csp.header.catchCode;    catchEV ¬ LOOPHOLE[epc/2];    IF catchEV = CatchEVNull THEN RETURN [CatchEVNull, 0, EnableTableNull, 0];    catchCount ¬ GetWord[LOOPHOLE[catchEV]];    enableTable ¬ LOOPHOLE[catchEV + 1 + catchCount * SIZE[PrincOps.BytePC]];    enableCount ¬ GetWord[LOOPHOLE[enableTable]];    END;      DisplayEnableTable: PUBLIC PROC =    BEGIN OPEN CatchFormat;    catchEV: CatchEV;    count, enableCount, level: CARDINAL;    enableTable: EnableTable;    ei: EnableItem;    more: BOOLEAN ¬ TRUE;    PCr[];    [catchEV: catchEV, catchCount: count,      enableTable: enableTable, enableCount: enableCount] ¬ FindCatchTables[];    IF enableCount = 0 THEN {PString["No enables"L]; RETURN};    level ¬ 0;    DO      more ¬ FALSE;      FOR i: NATURAL IN [0..enableCount) DO        GetEnableItem[@ei, LOOPHOLE[enableTable + 1 + i*SIZE[EnableItem]]];	PCr[];	THROUGH [0..level) DO PChar[Ascii.SP] ENDLOOP;	PString["start: "L]; POctal[ei.start];	PNextOctal["length"L, ei.length, level+2];	PNextOctal["index"L, ei.index, level+2];	IF ei.alsoNested THEN PNext["alsoNested"L,,level+2];	more ¬ more OR ei.alsoNested;        ENDLOOP;      IF ~more THEN EXIT;      enableTable ¬ enableTable + enableCount * SIZE[EnableItem];      enableCount ¬ GetWord[LOOPHOLE[enableTable]];      level ¬ level + 4;      ENDLOOP;    END;  FindEnable: PUBLIC PROC [pc: PrincOps.BytePC] =    BEGIN OPEN CatchFormat;    enableCount: CARDINAL;    enableTable: EnableTable;    index: CatchIndex ¬ CatchNull;    ei: EnableItem;        PCr[]; PString["pc: "L]; POctal[pc];    [enableTable: enableTable, enableCount: enableCount] ¬ FindCatchTables[];    IF enableCount = 0 THEN GO TO none;    DO      FOR i: NATURAL IN [0..enableCount) DO        GetEnableItem[@ei, LOOPHOLE[enableTable + 1 + i*SIZE[EnableItem]]];	IF pc IN [ei.start..ei.start + ei.length) THEN {index ¬ ei.index; EXIT};	REPEAT	  FINISHED => GO TO done;        ENDLOOP;      IF ~ei.alsoNested THEN EXIT;      enableTable ¬ enableTable + enableCount * SIZE[EnableItem];      enableCount ¬ GetWord[LOOPHOLE[enableTable]];      REPEAT        done => NULL;      ENDLOOP;    IF index = CatchNull THEN GO TO none;    PString[" enabled for catch: "L];    POctal[index];    EXITS      none => PString[" not enabled"L];    END;  PrintCodeBase: PROC [gfi: PrincOpsExtras2.GFTIndex] =    BEGIN    gfte: PrincOpsExtras2.GFTItem;    wasOut: BOOLEAN;    ReadGFTEntry[@gfte];    wasOut ¬ gfte.codebase.out;    gfte.codebase.out ¬ FALSE;    PNextLongOctal["code base"L, gfte.codebase.codebase] ;    IF wasOut THEN PNext["out"L];    END;  ReadPrefix: PROC [csp: LONG POINTER TO PrincOps.CodeSegment] =    BEGIN    p: LONG POINTER TO CARDINAL = LOOPHOLE[csp];    FOR i: CARDINAL IN [0..SIZE[PrincOps.CodeSegment]) DO      (p+i)­ ¬ GetWord[i];      ENDLOOP;    END;  ReadGFrame: PROC [gfo: LONG POINTER TO PrincOpsExtras2.GlobalOverhead] =    BEGIN    DebugUsefulDefs.LongCopyREAD[      from: LOOPHOLE[gFrame - SIZE[PrincOpsExtras2.GlobalOverhead]],      nwords: SIZE[PrincOpsExtras2.GlobalOverhead],      to: gfo];    END;    ReadGFTEntry: PROC [gfte: LONG POINTER TO PrincOpsExtras2.GFTItem] =    BEGIN    DebugUsefulDefs.LongCopyREAD[      from: LOOPHOLE[PrincOpsExtras2.GFT+gfi],      nwords: SIZE[PrincOpsExtras2.GFTItem],      to: gfte];    END;  PutCatchEntryItem: PUBLIC PROC [cepi: CARDINAL] =    BEGIN    epc: PrincOps.BytePC = GetCatchEntryItem[cepi];    PCr[];    PString["cep["L]; POctal[cepi]; PString["] = bpc: "L];    POctal[epc];    END;  GetCatchEntryItem: PUBLIC PROC [cepi: CARDINAL] RETURNS [PrincOps.BytePC] =    BEGIN OPEN CatchFormat;    catchEV: CatchEV;    count: CARDINAL;    [catchEV: catchEV, catchCount: count] ¬ FindCatchTables[];    IF cepi >= count THEN {      Complain["Not a valid catch index"L];      ERROR cancelAction};    RETURN[GetWord[LOOPHOLE[catchEV + 1 + cepi*SIZE[PrincOps.BytePC]]]];    END;  GetEnableItem: PROC [eni: LONG POINTER TO CatchFormat.EnableItem, start: CARDINAL] =    BEGIN    p: LONG POINTER TO CARDINAL = LOOPHOLE[eni];    FOR i: CARDINAL IN [0..SIZE[CatchFormat.EnableItem]) DO      (p+i)­ ¬ GetWord[start+i];      ENDLOOP;    END;      FindEntry: PRIVATE PROC [    pc: CARDINAL, nEntries: CARDINAL,     GetEntryPC: PROC [CARDINAL] RETURNS [PrincOps.BytePC]]     RETURNS [bestI: INTEGER] =    BEGIN    bestPc: CARDINAL ¬ 0;    bestI ¬ -1;    FOR i: CARDINAL IN [0..nEntries) DO      epc: PrincOps.BytePC = GetEntryPC[i];      IF epc IN (bestPc..pc] THEN {bestI ¬ i; bestPc ¬ epc};       ENDLOOP;    END;  FindCEP: PUBLIC PROC [pc: PrincOps.BytePC] =    BEGIN    bestPc: CARDINAL ¬ 0;    bestI: INTEGER ¬ -1;    count: CARDINAL;    [catchCount: count] ¬ FindCatchTables[];    bestI ¬ FindEntry[pc, count, GetCatchEntryItem];    PCr[];    PString["pc = "L]; POctal[pc];    IF bestI = -1 THEN PString[" not found"L]    ELSE {PString[" closest to cep "L]; POctal[bestI]; PutCatchEntryItem[bestI]};    END;      GoToCEP: PUBLIC PROC [cep: CARDINAL] =    BEGIN    pc: PrincOps.BytePC = GetCatchEntryItem[cep];    op: BYTE;    fsi: CARDINAL;    offset ¬ pc/2;    byte ¬ pc MOD 2;    op ¬ GetByte[];    IF op = Mopcodes.zJ2 THEN {fsi ¬ GetByte[]; bytePC ¬ pc+2}    ELSE {fsi ¬ 1; bytePC ¬ pc};    PCr[];    PString["Catch entry point: "L]; POctal[cep];    PNextUnsigned["fsi"L, fsi];    END;      PutAllLinks: PUBLIC PROC = {    csp: PrincOps.CodeSegment;    ReadPrefix[@csp];    FOR i: CARDINAL IN [0..csp.header.nlinks) DO      PutLink[i];      ENDLOOP;    };  PutLink: PUBLIC PROC [lki: PUBLIC CARDINAL] =    BEGIN    codeLinks: BOOLEAN;    link: PrincOps.ControlLink;    delta: INTEGER = -INTEGER[SIZE[PrincOps.ControlLink]*(lki+1)];    IF absMode THEN codeLinks ¬ TRUE    ELSE      BEGIN      gfo: PrincOpsExtras2.GlobalOverhead;      ReadGFrame[@gfo];      codeLinks ¬ gfo.word.codelinks;      END;    IF codeLinks THEN link ¬ GetDouble[delta].d.link    ELSE DebugUsefulDefs.LongCopyREAD[      from: LOOPHOLE[gFrame - SIZE[PrincOpsExtras2.GlobalOverhead] + delta],      to: @link,      nwords: SIZE[PrincOpsExtras2.ControlLink]];    PCr[];    PString[SELECT TRUE FROM     absMode => "(?code?"L,     codeLinks => "(code"L,     ENDCASE => "(frame"L];    PString[")link["L]; POctal[lki]; PString["] = "L];    PLongOctal[LOOPHOLE[link]];    IF LOOPHOLE[link.frame, CARDINAL] MOD 4 ~ IN [0..1] THEN      RETURN; -- must be a pointer, below might be as well    PString[" = ["L];     IF link.proc THEN {PString["proc,"L]; link.proc ¬ FALSE}    ELSE PString["sig,"L];    POctal[link.frame]; PChar[',];    POctal[link.pc]; PChar[']];    END;  PrintPos: PROC [word, bytepc: BOOLEAN ¬ FALSE, delta: CARDINAL ¬ 1] =    BEGIN    parity: ARRAY [0..1] OF STRING = [",E"L, ",O"L];    pc: CARDINAL ¬ 2*offset + byte - delta;    wo: CARDINAL ¬ pc / 2;    bo: CARDINAL ¬ pc MOD 2;    IF word THEN POctal[wo];     IF word AND bytepc THEN {PString[parity[bo]]; PChar[Ascii.TAB]};    IF bytepc THEN POctal[pc];    PChar[':]; PChar[Ascii.TAB];    END;      BackupPC: PUBLIC PROC =     BEGIN    oldPC: CARDINAL = bytePC;    delta: CARDINAL ¬ MIN[oldPC, 10];    DoNothing: PROC [pc: CARDINAL, op: Operation] RETURNS [BOOLEAN] = {      RETURN[FALSE]};    WHILE delta # 0 DO      bytePC ¬ oldPC - delta;      IF GenOperations[DoNothing, delta] = 0 THEN EXIT;      delta ¬ delta - 1;      ENDLOOP;    bytePC ¬ oldPC - delta;    END;  PutCodeBytes: PROCEDURE [n: CARDINAL] RETURNS [unused: CARDINAL] =    {RETURN[GenOperations[PutInstLine, n!      UNWIND => bytesShown ¬ bytesSeen]]};  GenOperations: PUBLIC PROCEDURE [      Action: PROC [pc: CARDINAL, op: Operation] RETURNS [BOOLEAN],      n: CARDINAL] RETURNS [unused: CARDINAL] =    BEGIN    op: Operation;    il: [0..3];    pc: CARDINAL;    inst: BYTE;    total: CARDINAL = n;    offset ¬ bytePC/2;    byte ¬ bytePC MOD 2;    WHILE n > 0 DO      ENABLE UNWIND => bytesSeen ¬ total - n;      pc ¬ offset*2+byte;      inst ¬ GetByte[];      il ¬ MAX[CARDINAL[OpTableDefs.InstLength[inst]], 1];      IF il > n THEN RETURN[n];      op ¬ [inst: inst, params: il-1]; op.padded ¬ FALSE;      SELECT il FROM        1 => NULL;        2 => op.param[1] ¬ GetByte[];        3 => {op.param[1] ¬ GetByte[]; op.param[2] ¬ GetByte[]};        ENDCASE;      n ¬ n - il;      IF Action[pc, op] THEN EXIT;      ENDLOOP;    RETURN[0];    END;  PutInstLine: PROCEDURE [pc: CARDINAL, op: Operation]    RETURNS [stop: BOOLEAN ¬ FALSE] =    BEGIN    mopString: STRING = [10];    parity: ARRAY [0..1] OF STRING = [",E"L, ",O"L];    oper: Operation = op; -- Mopcodes has an op defined in it    PutPair: PROCEDURE [alpha: CARDINAL] =      BEGIN      a: CARDINAL = alpha/16;      b: CARDINAL = alpha MOD 16;      PChar['[];      POctal[a];      PChar[',];      POctal[b];      PChar[']];      RETURN      END;    PCr[];    POctal[pc/2];    PString[parity[pc MOD 2]]; PChar[Ascii.TAB];    POctal[pc]; PChar[':]; PChar[Ascii.TAB];    mopString.length ¬ 0;    MopOps.AppendMopcodeName[mopString, oper.inst];    PString[mopString];    IF oper.padded THEN PChar['*];    SELECT oper.params FROM      0 => IF oper.inst IN JumpOp THEN {	PChar[Ascii.TAB]; PutJumpAddress[op.inst, 0]};      1 =>        BEGIN OPEN Mopcodes;        PChar[Ascii.TAB];        SELECT oper.inst FROM          zRLIP, zRLILP, zRLDIP, zRLDILP, zRGIP, zRGILP, zWLIP, 	  zWLILP, zWLDILP, zJEP, zJNEP, zR0F, zRL0F, zW0F, zPS0F, 	  zWS0F, zWL0F => PutPair[oper.param[1]];          ENDCASE => POctal[oper.param[1]];	IF oper.inst IN JumpOp THEN PutJumpAddress[oper.inst, oper.param[1]];	SELECT oper.inst FROM	  zESC => EscName[oper.param[1]];	  zKFCB => SdName[oper.param[1]];	  ENDCASE;        END;      2 =>         BEGIN OPEN Mopcodes;        PChar[Ascii.TAB];        SELECT oper.inst FROM          zRF, zRLF, zWF, zPSF, zWLF, zPSLF =>            BEGIN            POctal[oper.param[1]];            PString[", "L];            PutPair[oper.param[2]];            END;	  zRLIPF, zRLILPF =>            BEGIN            PutPair[oper.param[1]];            PString[", "L];            PutPair[oper.param[2]];            END;          zJEBB, zJNEBB, zESCL =>            BEGIN            POctal[oper.param[1]];            PString[", "L];            POctal[oper.param[2]];	    IF oper.inst = zESCL THEN EscName[oper.param[1]];            END;          ENDCASE =>            BEGIN            POctal[oper.wparam];            END;        SELECT oper.inst FROM	  zJIB, zJIW => NULL;	  IN JumpOp  => PutJumpAddress[oper.inst, oper.wparam];	  ENDCASE;        END;      ENDCASE;    END;      JumpOp: TYPE = [Mopcodes.zJ2..Mopcodes.zJIW];  PutJumpAddress: PROCEDURE [jop: BYTE, arg: INTEGER] =    BEGIN OPEN Mopcodes;    d: RECORD [SELECT OVERLAID * FROM      word => [i: INTEGER],      bytes => [b1, b2: BYTE],      nibbles => [fill: BYTE, n1, n2: [0..16)],      ENDCASE] = [word[arg]];    SELECT OpTableDefs.InstLength[jop] FROM      1 =>	SELECT jop FROM	  IN [zJ2..zJ8] => arg ¬ jop - zJ2 + 2;	  IN [zJZ3..zJZ4] => arg ¬ jop - zJZ3 + 3;	  IN [zJNZ3..zJNZ4] => arg ¬ jop - zJNZ3 + 3;	  ENDCASE => ERROR;      2 =>	BEGIN	SELECT jop FROM	  zJEP, zJNEP => arg ¬ d.n2 + 4;	  ENDCASE => IF arg > 177B THEN arg ¬ Inline.BITOR[arg, 177400B];	arg ¬ arg - 1;	END;      ENDCASE =>         BEGIN	SELECT jop FROM	  zJEBB, zJNEBB => {	    arg ¬ d.b2;	    IF arg > 177B THEN arg ¬ Inline.BITOR[arg, 177400B]};	  ENDCASE;	arg ¬ arg - 2;	END;    PString["	("L]; POctal[2*offset+byte+arg-1]; PChar[')];    END;  Octal0: Format.NumberFormat =     [base: 8, unsigned: TRUE, zerofill: FALSE, columns: 0];  Decimal0: Format.NumberFormat =     [base: 10, unsigned: TRUE, zerofill: FALSE, columns: 0];  PutOctalWords: PUBLIC PROCEDURE [count: CARDINAL] =    BEGIN    cols, val: CARDINAL;    PCr[];    FOR i: CARDINAL IN [0..count) DO      ENABLE UNWIND => bytesShown ¬ i*2; -- could be "off" by 1      val ¬ GetWord[offset]; offset ¬ offset + 1;      cols ¬ Log8[val];      IF val > 7 THEN cols ¬ cols + 1;      IF i # 0 AND MakeRoom[cols+2, 0] THEN PString[", "]      ELSE PrintPos[word: TRUE, delta: 2];      POctal[val];      ENDLOOP;    END;  PutOctalBytes: PUBLIC PROCEDURE [count: CARDINAL] =    BEGIN    cols, val: CARDINAL;    PCr[];    FOR i: CARDINAL IN [0..count) DO      ENABLE UNWIND => bytesShown ¬ i;      val ¬ GetByte[];      cols ¬ Log8[val];      IF val > 7 THEN cols ¬ cols + 1;      IF i # 0 AND MakeRoom[cols+2, 0] THEN PString[", "]      ELSE PrintPos[TRUE, TRUE];      POctal[val];      ENDLOOP;    END;  PutAsciiText: PUBLIC PROCEDURE [count: CARDINAL] =    BEGIN    cols: CARDINAL;    ch: CHARACTER;    PCr[];    FOR i: CARDINAL IN [0..count) DO      ENABLE UNWIND => bytesShown ¬ i;      ch ¬ LOOPHOLE[GetByte[]];      cols ¬ SELECT ch FROM        Ascii.CR, Ascii.SP => 4,	Ascii.TAB, Ascii.ESC, Ascii.NUL, Ascii.DEL => 5,	< 40C => 2,	> 200C => 5,	ENDCASE => 1;      IF i = 0 OR ~MakeRoom[cols, 0] THEN PrintPos[TRUE, TRUE];      SELECT ch FROM        Ascii.SP => PString["<SP>"L];        Ascii.CR => PString["<CR>"L];	Ascii.TAB => PString["<TAB>"L];	Ascii.ESC => PString["<ESC>"L];	Ascii.NUL => PString["<NUL>"L];	Ascii.DEL => PString["<DEL>"L];	< 40C => {PChar['­]; PChar[ch + 100B]};	> 200C => {PChar['<]; PNumber[ch, Octal0]; PChar['>]};	ENDCASE => PChar[ch];      ENDLOOP;    END;  END.
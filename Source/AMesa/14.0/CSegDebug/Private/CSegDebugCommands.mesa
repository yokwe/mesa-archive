-- Copyright (C) 1981, 1982, 1983, 1986  by Xerox Corporation. All rights reserved. -- CSegDebugCommands.mesa, edited by--   Sweet,	 9-Sep-83 10:44:10--   Bruce,	15-Sep-81 18:36:33--   Haynes,	29-Nov-82 15:31:38--   MEW	17-Jun-86 16:34:08DIRECTORY  Ascii USING [CR, SP, TAB],  CSegDebugCommandDefs USING [ParamIndex],  CSegDebugDefs,  FormSW,  Inline USING [LongNumber],  MsgSW USING [Clear, Post],  Put USING [Char, Text],  RESOut,  Selection USING [Convert, LongNumber],  String USING [InvalidNumber],  UserInput USING [UserAbort],  Window USING [GetBox],  WindowFont USING [CharWidth];CSegDebugCommands: PROGRAM   IMPORTS     CSegDebugDefs, FormSW, MsgSW, Put,    Selection, String, UserInput, Window, WindowFont  EXPORTS CSegDebugDefs, RESOut =  BEGIN OPEN CSegDebugDefs;  handle: PUBLIC RESOut.WindowsHandle ¬ NIL;  autoNext: PUBLIC BOOLEAN ¬ TRUE;  sp: CARDINAL = WindowFont.CharWidth[Ascii.SP];  cancelAction: PUBLIC ERROR [endLine: BOOLEAN ¬ FALSE] = CODE;  ParamNotify: PUBLIC FormSW.ProcType =    BEGIN OPEN CSegDebugCommandDefs;    ENABLE {      cancelAction => {        IF endLine THEN Put.Text[handle.fileSW, " XXX"L];        GO TO done};      ABORTED => {Put.Text[handle.fileSW, " XXX"L]; GO TO done}};    Complain[""L];    SELECT LOOPHOLE[index, ParamIndex] FROM      gfCmd => {	gFrame ¬ GetLongSelectionValue[];	UpdateGFI[];	FormSW.DisplayItem[sw, LOOPHOLE[ParamIndex[gfVal]]];	FormSW.DisplayItem[sw, LOOPHOLE[ParamIndex[gfiVal]]]};      gfiCmd => {	gfi ¬ GetSelectionValue[];	UpdateGFrame[];	FormSW.DisplayItem[sw, LOOPHOLE[ParamIndex[gfiVal]]];	FormSW.DisplayItem[sw, LOOPHOLE[ParamIndex[gfVal]]]};      nextGFI => {        BumpGFI[];	FormSW.DisplayItem[sw, LOOPHOLE[ParamIndex[gfVal]]];	FormSW.DisplayItem[sw, LOOPHOLE[ParamIndex[gfiVal]]]};      find => {	found: BOOLEAN ¬ FALSE;	found ¬ Search[!cancelAction => CONTINUE];	IF found OR autoNext THEN {bytesShown ¬ bytesSeen; DoNext[]}};      bpcCmd => {	bytePC ¬ GetSelectionValue[];	FormSW.DisplayItem[sw, LOOPHOLE[ParamIndex[bpcVal]]]};      plus1 => {	bytePC ¬ bytePC + 1;	FormSW.DisplayItem[sw, LOOPHOLE[ParamIndex[bpcVal]]]};      wpc => {	t: INTEGER ¬ GetSelectionValue[];	bytePC ¬ 2*CARDINAL[t];	FormSW.DisplayItem[sw, LOOPHOLE[ParamIndex[bpcVal]]]};      backup => {	BackupPC[];	FormSW.DisplayItem[sw, LOOPHOLE[ParamIndex[bpcVal]]]};      findCEp => FindCEP[GetSelectionValue[]];      goCEp => {        GoToCEP[GetSelectionValue[]];	FormSW.DisplayItem[sw, LOOPHOLE[ParamIndex[bpcVal]]]};      nCmd => {	nBytes ¬ GetSelectionValue[];	FormSW.DisplayItem[sw, LOOPHOLE[ParamIndex[nVal]]]};      next => DoNext[];      findEna => FindEnable[GetSelectionValue[]];      rangeCmd => {	searchRange ¬ GetSelectionValue[];	FormSW.DisplayItem[sw, LOOPHOLE[ParamIndex[rangeVal]]]};      code => {	PutAsCode[!cancelAction => CONTINUE];	IF autoNext THEN DoNext[]};      octal => {	PutAsOctal[!cancelAction => CONTINUE];	IF autoNext THEN DoNext[]};      bytes => {	PutAsBytes[!cancelAction => CONTINUE];	IF autoNext THEN DoNext[]};      ascii => {	PutAsAscii[!cancelAction => CONTINUE];	IF autoNext THEN DoNext[]};      numMop => MopToString[GetSelectionValue[]];      prefix => DisplayPrefix[];      localFr => DisplayLocalFrame[GetSelectionValue[]];      catch => DisplayCatchInfo[];      enables => DisplayEnableTable[];      cevi => PutCatchEntryItem[GetSelectionValue[]];      link => PutLink[GetSelectionValue[]];      allLinks => PutAllLinks[];      mopNum => StringToMop[Selection.Convert[string]];      ENDCASE;    EXITS      done => NULL;    END;  DoNext: PROC =    BEGIN OPEN CSegDebugCommandDefs;    bytePC ¬ bytePC + bytesShown;    bytesShown ¬ 0;    FormSW.DisplayItem[handle.formSW, LOOPHOLE[ParamIndex[bpcVal]]];    END;  GetSelectionValue: PUBLIC PROCEDURE RETURNS [val: UNSPECIFIED] =    BEGIN    num: Inline.LongNumber;    num.lc ¬ GetLongSelectionValue[];    SELECT num.highbits FROM      0, 177777B => NULL;      ENDCASE => {Complain["number too big"L]; ERROR cancelAction};    RETURN[num.lowbits];    END;  GetLongSelectionValue: PUBLIC PROCEDURE RETURNS [val: LONG UNSPECIFIED] =    BEGIN    val ¬ Selection.LongNumber[radix: 10 !	String.InvalidNumber => GO TO noNumber];    RETURN;    EXITS      noNumber =>	BEGIN	Complain["Select a number first"L];	ERROR cancelAction;	END;    END;  Complain: PUBLIC PROCEDURE [msg: LONG STRING, clear: BOOLEAN ¬ TRUE] =    BEGIN    IF handle.msgSW = NIL THEN RETURN;    IF clear THEN MsgSW.Clear[handle.msgSW];    MsgSW.Post[sw: handle.msgSW, string: msg, prefix: FALSE, endOfMsg: FALSE];    END;-- log writing procedures  charsOnLine: CARDINAL ¬ 0;  PChar: PUBLIC PROCEDURE [c: CHARACTER] =    BEGIN    IF UserInput.UserAbort[handle.main] THEN ERROR cancelAction[TRUE];    Put.Char[handle.fileSW, c];    charsOnLine ¬ SELECT c FROM      Ascii.TAB  => ((charsOnLine+8)/8)*8,      Ascii.CR => 0,      ENDCASE => charsOnLine + 1;    END;  MakeRoom: PUBLIC PROCEDURE [chars, indent: CARDINAL]       RETURNS [was: BOOLEAN]=    BEGIN    charsPerLine: CARDINAL = handle.fileSW.GetBox[].dims.w/sp-3;    IF charsOnLine + chars <= charsPerLine THEN RETURN [TRUE];    PChar[Ascii.CR];    THROUGH [0..indent/8) DO PChar[Ascii.TAB]; ENDLOOP;    THROUGH [0..indent MOD 8) DO PChar[Ascii.SP]; ENDLOOP;    RETURN[FALSE];    END;  END.
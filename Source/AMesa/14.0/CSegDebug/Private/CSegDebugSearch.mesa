-- Copyright (C) 1981, 1982, 1983  by Xerox Corporation. All rights reserved. -- CSegDebugSearch.mesa--   Edited by Bruce,	15-Sep-81 18:12:29-- Charles,		27-Sep-82 19:06:42-- Sweet,		14-Jan-83 12:10:33DIRECTORY  Ascii USING [SP],  CSegDebugDefs USING [BYTE, bytePC, bytesSeen, GenOperations, Operation],  Heap USING [systemZone],  MopOps USING [AppendMopcodeName, MopcodeValue],  OpTableDefs USING [InstLength],  RESOut USING [cancelAction, Complain, PCr, POctal, PString],  String USING [    AppendChar, FreeString, InvalidNumber, StringBoundsFault, StringToDecimal],  UserTerminal USING [BlinkDisplay];CSegDebugSearch: PROGRAM  IMPORTS     CSegDebugDefs, Heap, MopOps, OpTableDefs, RESOut, String,     UserTerminal  EXPORTS CSegDebugDefs =  BEGIN OPEN RESOut, CSegDebugDefs;  StringToMop: PUBLIC PROC [s: LONG STRING] =    BEGIN -- s is from heap, free after use    ENABLE UNWIND => String.FreeString[Heap.systemZone, s];    inst: BYTE = MopForString[s];    PCr[]; PString[s]; PString[" = "L]; POctal[inst];    String.FreeString[Heap.systemZone, s];    END;  MopToString: PUBLIC PROC [inst: BYTE] =    BEGIN -- s is from heap, free after use    s: STRING = [10];    MopOps.AppendMopcodeName[s, inst];    PCr[]; POctal[inst]; PString[" = "L]; PString[s];    END;  keyString: PUBLIC LONG STRING ¬ NIL;  searchRange: PUBLIC CARDINAL ¬ 100;  KeySeq: TYPE = RECORD[ seq: SEQUENCE l: CARDINAL OF Operation];  IntSeq: TYPE = RECORD[ seq: SEQUENCE l: CARDINAL OF INTEGER];    Search: PUBLIC PROC RETURNS [found: BOOLEAN] =    BEGIN    keyOps: LONG POINTER TO KeySeq;    kptr: CARDINAL ¬ 0;    k, p: CARDINAL;    operand: STRING = [20];    op: Operation;    SkipWhite: PROC =      BEGIN      WHILE kptr < keyString.length AND keyString[kptr] <= Ascii.SP DO        kptr ¬ kptr + 1;	ENDLOOP;      END;        Scan: PROC [operand: STRING] =      BEGIN      operand.length ¬ 0;      SkipWhite[];      WHILE kptr < keyString.length AND keyString[kptr] > Ascii.SP	AND keyString[kptr] # '; DO        String.AppendChar[operand, keyString[kptr] !	  String.StringBoundsFault => 	    BadForm["Token too long: "L, operand, "..."L]];        kptr ¬ kptr + 1;	ENDLOOP;      END;    IF keyString = NIL OR keyString.length = 0 THEN       {Complain["Enter search key"L]; RETURN};    k ¬ 1;    FOR i: CARDINAL IN [0..keyString.length) DO      IF keyString[i] = '; THEN k ¬ k+1;      ENDLOOP;    keyOps ¬ Heap.systemZone.NEW[KeySeq[k]];    k ¬ 0;    BEGIN ENABLE UNWIND => Heap.systemZone.FREE[@keyOps];    DO      ENABLE String.InvalidNumber => BadForm["Invalid number: "L, operand];      b: BYTE;      il: CARDINAL;      Scan[operand];      IF operand.length = 0 THEN EXIT;      b ¬ IF operand[0] IN ['0..'9] THEN String.StringToDecimal[operand]        ELSE MopForString[operand];      il ¬ MAX[CARDINAL[OpTableDefs.InstLength[b]], 1];      op ¬ [inst: b, params: il-1];      p ¬ 1;      DO        SkipWhite[];	IF kptr = keyString.length THEN EXIT;	IF keyString[kptr] = '; THEN {kptr ¬ kptr + 1; EXIT};	IF p = 3 THEN BadForm["Too many"L, " operand bytes"L];        Scan[operand];	SELECT operand[0] FROM	  '* => {	    IF operand.length # 1 THEN	      BadForm["Missing space or '; after '*"L];	    op.wild[p] ¬ TRUE};	  IN ['0..'9] => op.param[p] ¬ String.StringToDecimal[operand];	  ENDCASE => BadForm["Missing '; before "L, operand];	p ¬ p+1;        ENDLOOP;      IF p # il THEN	BadForm[	  IF p > il THEN "Too many"L ELSE "Too few"L,	  " operand bytes"L];      keyOps[k] ¬ op;      k ¬ k+1;      ENDLOOP;    found ¬ FindOpString[keyOps];    IF ~found THEN UserTerminal.BlinkDisplay[];    END;    Heap.systemZone.FREE[@keyOps];    END;  BadForm: PROC [s1, s2, s3, s4: LONG STRING ¬ NIL] =    BEGIN    RESOut.Complain[s1];    IF s2 # NIL THEN RESOut.Complain[s2, FALSE];    IF s3 # NIL THEN RESOut.Complain[s3, FALSE];    IF s4 # NIL THEN RESOut.Complain[s4, FALSE];    ERROR RESOut.cancelAction;    END;  MopForString: PROC [s: LONG STRING] RETURNS [BYTE] =    BEGIN    i: INTEGER = MopOps.MopcodeValue[s];    IF i = -1 THEN {      BadForm["Unrecognized Mopcode: "L, s]; ERROR} --BadForm doesn't return    ELSE RETURN [i];    END;  FailureFn: PROCEDURE [key: LONG POINTER TO KeySeq]     RETURNS[ff: LONG POINTER TO IntSeq] =    BEGIN    i,j: INTEGER;    l: INTEGER = key.l;    ff ¬ Heap.systemZone.NEW[IntSeq[l]];    -- set up failure function    j ¬ 0; i ¬ ff[0] ¬ -1;    WHILE j < l-1 DO      WHILE i >= 0 AND key[j].inst # key[i].inst DO i ¬ ff[i] ENDLOOP;      i ¬ i+1; j ¬ j+1;      ff[j] ¬ IF key[j].inst = key[i].inst THEN ff[i] ELSE i;      ENDLOOP;    END;  FindOpString: PROCEDURE [key: LONG POINTER TO KeySeq]     RETURNS[BOOLEAN] =    BEGIN    l: INTEGER = key.l;    k: INTEGER;    ff: LONG POINTER TO IntSeq;    lastPC: CARDINAL;    extra: CARDINAL;    first: BOOLEAN ¬ TRUE;    EqualOps: PROC [kop, op: Operation] RETURNS [BOOLEAN] =      BEGIN      IF key[k].inst # op.inst THEN GO TO different;      SELECT key[k].params FROM        0 => NULL;        1 => IF ~key[k].wild[1] AND key[k].param[1] # op.param[1] THEN           GO TO different;        2 =>IF (~key[k].wild[1] AND key[k].param[1] # op.param[1]) OR           (~key[k].wild[2] AND key[k].param[2] # op.param[2]) THEN           GO TO different;        ENDCASE => ERROR;      RETURN[TRUE];      EXITS        different => RETURN [FALSE];      END;    testOp: PROCEDURE [pc: CARDINAL, op: Operation] RETURNS [BOOLEAN] =      BEGIN      IF first THEN {first ¬ FALSE; RETURN [FALSE]}; -- start from .+1      WHILE k >= 0 DO 	IF EqualOps[key[k], op] THEN EXIT;	k ¬ ff[k];	ENDLOOP;      IF k = 0 THEN lastPC ¬ pc;      k ¬ k+1;      RETURN[k=l];      END;    ff ¬ FailureFn[key];    k¬0;    extra ¬ GenOperations[testOp, searchRange!      UNWIND => Heap.systemZone.FREE[@ff]];    IF k=l THEN {bytePC ¬ lastPC; bytesSeen ¬ 0}    ELSE bytesSeen ¬ searchRange - extra;    Heap.systemZone.FREE[@ff];    RETURN [k=l];    END;  END.
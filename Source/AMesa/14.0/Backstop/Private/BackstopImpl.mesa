-- Copyright (C) 1981, 1984  by Xerox Corporation. All rights reserved. -- BackstopImpl.mesa  -- Edited by LXR     on   6-Feb-84 12:56:35-- Edited by JGS     on   2-Mar-81  9:50:19DIRECTORY  Backstop,  BackstopInternal,  BackstopNub USING [ErrorEntry, ErrorType, stackSize],  BSState USING [GSHandle, GState],  CPSwapDefs USING [    currentVersion, ExternalStateVector, ProcessState,     SwapData, SwapInfo, SwapReason],  DebugUsefulDefs USING [    InvalidAddress, LongCopyREAD, LongREAD, ShortCopyREAD, ShortREAD],  FrameExtras USING [GFTHandleToLongGF],  File USING [File,  PageNumber],  Heap USING [systemZone],  Inline USING [BITAND],  Log USING [Close, GetIndex, Install, PutBlock, SetRestart],  PrincOps USING [    BytePC, LocalFrameHandle, LocalVariables,    localWordOffset, ShortControlLink, stackDepth, StateVector],  PrincOpsExtras2 USING [LongGlobalFrameHandle, LocalOverhead, NewSignalDesc, ProcDesc],  ProcessOperations USING [IndexToHandle],  PSB USING [PsbIndex, PsbNull, PDA, ProcessStateBlock, StartPsb],  SDDefs USING [SD, sSignal],  System USING [GetGreenwichMeanTime],  TemporaryBooting USING [BootFromPhysicalVolume, BootFromVolume],  Volume USING [ID, nullID, systemID];BackstopImpl: PROGRAM  IMPORTS    DebugUsefulDefs, Heap, Log, FrameExtras, Inline,    ProcessOperations,     System, TemporaryBooting, Volume  EXPORTS Backstop, BSState, BackstopNub =  BEGIN  ASSERT: BOOLEAN [TRUE..TRUE] = (BackstopNub.stackSize = PrincOps.stackDepth);  Process: PUBLIC TYPE = PSB.PsbIndex;  Frame: PUBLIC TYPE = POINTER TO PrincOpsExtras2.LocalOverhead;  ProcessData: PUBLIC TYPE = RECORD [a, b, c, d: UNSPECIFIED];  -- PSB.ProcessStateBlock  GlobalFrame: PUBLIC TYPE = PrincOpsExtras2.LongGlobalFrameHandle;  PC: PUBLIC TYPE = PrincOps.BytePC;  SwapReason: PUBLIC TYPE = CPSwapDefs.SwapReason;  Signal: PUBLIC TYPE =  PrincOpsExtras2.NewSignalDesc;  SignalMsg: PUBLIC TYPE = PrincOps.LocalFrameHandle;  bootFileOffset: CARDINAL = 0; -- if this constant is changed, BSMemCache must be edited    Words: TYPE = RECORD [SEQUENCE COMPUTED CARDINAL OF WORD];  Reason: TYPE = {abortSession, newSession};  fake1: Process ¬ PSB.PsbNull;  nullProcess: PUBLIC Process = fake1;  fake2: Frame ¬ NIL;  nullFrame: PUBLIC Frame = fake2;  NotLoggingError: PUBLIC ERROR = CODE;  NotAFault: PUBLIC ERROR = CODE;  gstate: BSState.GState ¬ [];  gs: PUBLIC BSState.GSHandle ¬ @gstate;  clientProcessed: BOOLEAN ¬ FALSE;  LogEntry: TYPE = BackstopInternal.LogEntry;  entry: BackstopInternal.Handle ¬ Heap.systemZone.NEW[LogEntry];  VersionMismatch: PUBLIC SIGNAL = CODE;  first: PSB.PsbIndex = PSB.StartPsb;  current, last: PSB.PsbIndex ¬ PSB.PsbNull;  localframe: PrincOpsExtras2.LocalOverhead;  lastframe: Frame ¬ NIL;  FrameToFrameHandle: PROCEDURE [f: Frame] RETURNS [PrincOps.LocalFrameHandle] =    INLINE {RETURN[LOOPHOLE[f + PrincOps.localWordOffset]]};  FrameHandleToFrame: PROCEDURE [f: PrincOps.LocalFrameHandle] RETURNS [Frame] =    INLINE {RETURN[LOOPHOLE[f - PrincOps.localWordOffset]]};    ReadFrame: PROCEDURE [f: Frame] RETURNS [Frame] =    BEGIN    lastframe ¬ f;    DebugUsefulDefs.LongCopyREAD[      to: @localframe, from: lastframe, nwords: SIZE[PrincOpsExtras2.LocalOverhead]];    RETURN[@localframe];    END;  CreateBackstopLog: PUBLIC PROCEDURE [size: CARDINAL, file: File.File, firstPageNumber: File.PageNumber ¬ 0] =    BEGIN    Log.Install[file, firstPageNumber];    entry­ ¬ LogEntry[recordType: version[id: BackstopInternal.BackstopVersion]];    Log.PutBlock[level: error, pointer: entry, size: SIZE[version LogEntry]];    Log.Close[];    END;  LogError: PUBLIC PROCEDURE =    BEGIN    ENABLE DebugUsefulDefs.InvalidAddress => GOTO impossible;    f: Frame ¬ nullFrame;    IF ~clientProcessed THEN {ProcessClient[]; clientProcessed ¬ TRUE};    IF ~gstate.loggingError THEN ERROR NotLoggingError;    Log.SetRestart[Log.GetIndex[]];    f ¬ ReadFrame[FrameHandleToFrame[gstate.localFrame]];    BEGIN    SELECT gstate.error FROM      signal =>        BEGIN        entry­ ¬ LogEntry[          recordType: error[          BackstopNub.ErrorEntry[          globalFrame: FrameExtras.GFTHandleToLongGF[f.globallink], pc: f.pc,	  time: System.GetGreenwichMeanTime[],          options: signal[signal: gstate.signal, msg: gstate.signalmsg,	                  stk: ALL[0]]]]];	 WITH entry SELECT FROM	   error =>  WITH error SELECT FROM	     signal => DebugUsefulDefs.ShortCopyREAD[	       from: gstate.signalmsg, nwords: BackstopNub.stackSize, to: @stk];	     ENDCASE;	   ENDCASE;        Log.PutBlock[level: error, pointer: entry, size: SIZE[error LogEntry]];        END;      call =>        BEGIN        s: LONG STRING ¬ gstate.usermsg;        length: CARDINAL ¬ DebugUsefulDefs.LongREAD[@s.length];        temp: PACKED ARRAY [0..1] OF CHARACTER;        entry: LONG POINTER TO error LogEntry ¬          LOOPHOLE[Heap.systemZone.NEW[          Words [SIZE[error LogEntry] + (length + 1)/2]]];        entry­ ¬ [          recordType: error[          BackstopNub.ErrorEntry[          globalFrame: FrameExtras.GFTHandleToLongGF[f.globallink], pc: f.pc,	  time: System.GetGreenwichMeanTime[],          options: call[msg: [length: length, maxlength: length, text: NULL]]]]];        WITH e: entry.error SELECT FROM          call =>            BEGIN            FOR i: CARDINAL IN [0..length) DO              IF i MOD 2 = 0 THEN temp ¬ DebugUsefulDefs.LongREAD[@s.text + i/2];              e.msg.text[i] ¬ temp[i MOD 2];              ENDLOOP;            END;          ENDCASE;        Log.PutBlock[          level: error, pointer: entry,          size: SIZE[error LogEntry] + (length + 1)/2];        Heap.systemZone.FREE[@entry];        END;      other =>        BEGIN        entry­ ¬ LogEntry[          recordType: error[          BackstopNub.ErrorEntry[          globalFrame: FrameExtras.GFTHandleToLongGF[f.globallink], pc: f.pc,	  time: System.GetGreenwichMeanTime[],          options: other[reason: LOOPHOLE[gs.ESV.swapData.reason, SwapReason]]]]];        Log.PutBlock[level: error, pointer: entry, size: SIZE[error LogEntry]];        END;      unused =>        BEGIN        entry­ ¬ LogEntry[          recordType: error[          BackstopNub.ErrorEntry[          globalFrame: FrameExtras.GFTHandleToLongGF[f.globallink], pc: f.pc, 	  time: System.GetGreenwichMeanTime[],          options: unused[]]]];        Log.PutBlock[level: error, pointer: entry, size: SIZE[error LogEntry]];        END;      interrupt =>        BEGIN        entry­ ¬ LogEntry[          recordType: error[          BackstopNub.ErrorEntry[          globalFrame: FrameExtras.GFTHandleToLongGF[f.globallink], pc: f.pc, 	  time: System.GetGreenwichMeanTime[],          options: interrupt[]]]];        Log.PutBlock[level: error, pointer: entry, size: SIZE[error LogEntry]];        END;      addressfault =>        BEGIN        entry­ ¬ LogEntry[          recordType: error[          BackstopNub.ErrorEntry[          globalFrame: FrameExtras.GFTHandleToLongGF[f.globallink], pc: f.pc,	  time: System.GetGreenwichMeanTime[],          options: addressfault[faultedProcess: ]]]];        Log.PutBlock[level: error, pointer: entry, size: SIZE[error LogEntry]];        END;      writeprotectfault =>        BEGIN        entry­ ¬ LogEntry[          recordType: error[          BackstopNub.ErrorEntry[          globalFrame: FrameExtras.GFTHandleToLongGF[f.globallink], pc: f.pc,	  time: System.GetGreenwichMeanTime[],          options: writeprotectfault[faultedProcess: ]]]];        Log.PutBlock[level: error, pointer: entry, size: SIZE[error LogEntry]];        END;      ENDCASE;    END;    EXITS impossible => NULL;    END;  GetError: PUBLIC PROCEDURE RETURNS [BackstopNub.ErrorType] =    BEGIN    IF ~clientProcessed THEN {ProcessClient[]; clientProcessed ¬ TRUE};    IF ~gstate.loggingError THEN ERROR NotLoggingError;    RETURN[gstate.error]    END;  LogProcess: PUBLIC PROCEDURE [process: Process] =    BEGIN    ENABLE DebugUsefulDefs.InvalidAddress => GOTO impossible;    local: PSB.ProcessStateBlock;    IF ~clientProcessed THEN {ProcessClient[]; clientProcessed ¬ TRUE};    IF ~gstate.loggingError THEN ERROR NotLoggingError;    DebugUsefulDefs.LongCopyREAD[      from: @PSB.PDA[ProcessOperations.IndexToHandle[process]], to: @local,      nwords: SIZE[PSB.ProcessStateBlock]];    entry­ ¬ LogEntry[recordType: process[psb: local]];    Log.PutBlock[level: error, pointer: entry, size: SIZE[process LogEntry]];    EXITS impossible => NULL;    END;  GetCurrentProcess: PUBLIC PROCEDURE RETURNS [process: Process] =    BEGIN    IF ~clientProcessed THEN {ProcessClient[]; clientProcessed ¬ TRUE};    IF ~gstate.loggingError THEN ERROR NotLoggingError;    RETURN[gs.ESV.swapData.process]    END;  GetFaultedProcess: PUBLIC PROCEDURE RETURNS [process: Process] =    BEGIN    IF ~clientProcessed THEN {ProcessClient[]; clientProcessed ¬ TRUE};    IF ~gstate.loggingError THEN ERROR NotLoggingError;    IF gstate.error # addressfault AND gstate.error # writeprotectfault THEN       ERROR NotAFault;    RETURN[gstate.faultedProcess]    END;  GetNextProcess: PUBLIC PROCEDURE [process: Process] RETURNS [next: Process] =    BEGIN    ENABLE DebugUsefulDefs.InvalidAddress => GOTO impossible;    self: Process = process;    IF ~clientProcessed THEN {ProcessClient[]; clientProcessed ¬ TRUE};    IF ~gstate.loggingError THEN ERROR NotLoggingError;    last ¬ first + DebugUsefulDefs.LongREAD[@PSB.PDA.count] - 1;    current ¬ LOOPHOLE[gs.ESV.swapData.process];    IF process = nullProcess THEN RETURN[current];    DO      IF process = last THEN process ¬ first ELSE process ¬ process + 1;      IF process = self OR process = current THEN RETURN[nullProcess];      IF Validate[process] AND StateOK[process] THEN RETURN[process];      ENDLOOP;    EXITS impossible => RETURN[nullProcess];    END;  StateOK: PROCEDURE [process: Process] RETURNS [BOOLEAN] =    BEGIN    local: PSB.ProcessStateBlock;    DebugUsefulDefs.LongCopyREAD[      from: @PSB.PDA[ProcessOperations.IndexToHandle[process]], to: @local,      nwords: SIZE[PSB.ProcessStateBlock]];    RETURN[LOOPHOLE[local.flags.available, CPSwapDefs.ProcessState].state # dead]    END;  Validate: PROCEDURE [p: Process] RETURNS [BOOLEAN] = {    last ¬ first + DebugUsefulDefs.LongREAD[@PSB.PDA.count] - 1;    RETURN[p >= first AND p <= last]};  LogFrame: PUBLIC PROCEDURE [frame: Frame] =    BEGIN    ENABLE DebugUsefulDefs.InvalidAddress => GOTO impossible;    IF ~clientProcessed THEN {ProcessClient[]; clientProcessed ¬ TRUE};    IF ~gstate.loggingError THEN ERROR NotLoggingError;    IF frame = nullFrame THEN RETURN;    IF frame = lastframe THEN frame ¬ @localframe ELSE frame ¬ ReadFrame[frame];    entry­ ¬ LogEntry[      recordType: frame[      localFrame: FrameToFrameHandle[frame], globalFrame: FrameExtras.GFTHandleToLongGF[frame.globallink],      pc: frame.pc]];    Log.PutBlock[level: error, pointer: entry, size: SIZE[frame LogEntry]];    EXITS impossible => NULL;    END;  ValidateF: PROCEDURE [f: Frame] RETURNS [BOOLEAN] = {    RETURN[(LOOPHOLE[f, CARDINAL] MOD 4) = 0]};      GetNextFrame: PUBLIC PROCEDURE [process: Process, frame: Frame]    RETURNS [next: Frame] =    BEGIN    ENABLE DebugUsefulDefs.InvalidAddress => GOTO impossible;    link: PrincOps.ShortControlLink;    IF ~clientProcessed THEN {ProcessClient[]; clientProcessed ¬ TRUE};    IF ~gstate.loggingError THEN ERROR NotLoggingError;    IF ~ValidateF[frame] THEN RETURN[nullFrame];    IF lastframe # NIL AND frame = lastframe THEN      RETURN[FrameHandleToFrame[localframe.returnlink.frame]];    IF frame = nullFrame THEN      BEGIN      local: PSB.ProcessStateBlock;      IF ~Validate[process] THEN RETURN[nullFrame];      DebugUsefulDefs.LongCopyREAD[        from: @PSB.PDA[ProcessOperations.IndexToHandle[process]], to: @local,        nwords: SIZE[PSB.ProcessStateBlock]];      IF ~(local.link.permanent OR local.link.preempted) THEN         RETURN[FrameHandleToFrame[local.context.frame]]      ELSE        RETURN[          FrameHandleToFrame[            DebugUsefulDefs.LongREAD[@PSB.PDA[local.context.state].frame]]];      END;    frame ¬ ReadFrame[frame];    link ¬ frame.returnlink;    THROUGH [0..100] DO      SELECT TRUE FROM        link.proc => RETURN[nullFrame];        ~link.proc AND link.indirect => link ¬ DebugUsefulDefs.ShortREAD[LOOPHOLE[link]];        ENDCASE =>          IF link.frame = NIL THEN RETURN[nullFrame]          ELSE RETURN[FrameHandleToFrame[link.frame]];      ENDLOOP;    EXITS impossible => RETURN[nullFrame];    END;  ProcessClient: PROCEDURE =    BEGIN    swapInfo: CPSwapDefs.SwapInfo;    e: CPSwapDefs.ExternalStateVector;    DebugUsefulDefs.LongCopyREAD[      to: @swapInfo, from: @PSB.PDA.available, nwords: SIZE[CPSwapDefs.SwapInfo]      << ! DebugUsefulDefs.InvalidAddress => GOTO done>>];    DebugUsefulDefs.LongCopyREAD[      to: @e, from: swapInfo.externalStateVector,      nwords: SIZE[CPSwapDefs.ExternalStateVector]];    gs.ESV ¬ e;    gs.mds ¬ e.mds;    WITH sd: gs.ESV.swapData SELECT FROM       breakpoint => gs.StatePtr ¬ sd.sv;      return => gs.StatePtr ¬ sd.sv;      storageFault => {gs.StatePtr ¬ @gs.StateVector; GetSV[sd.faultedProcess]};      ENDCASE => gs.StatePtr ¬ NIL;    gs.signal ¬ LOOPHOLE[LONG[0]];    gs.loggingError ¬ TRUE;    gs.error ¬ other;    gs.localFrame ¬ e.swapData.lFrame;    SetDebugeeType[];    FlushCaches[];    WITH sd: e.swapData SELECT FROM      interrupt => gs.error ¬ interrupt;       bug => gs.error ¬ bug;       callDebugger =>        BEGIN        gs.error ¬ call;	gs.usermsg ¬ sd.message;        END;      uncaughtSignal =>        BEGIN        gs.error ¬ signal;        gs.signal ¬ sd.signal;        gs.signalmsg ¬ sd.signalArgs;        END;      storageFault => {gs.error ¬ IF sd.type = addressFault THEN addressfault                                  ELSE writeprotectfault;		       gs.faultedProcess ¬ sd.faultedProcess};      ENDCASE;    END;  SaveSignallerGF: PROCEDURE =    BEGIN    pd: PrincOpsExtras2.ProcDesc;    DebugUsefulDefs.LongCopyREAD[      from: SDDefs.SD+SDDefs.sSignal, to: @pd, nwords: SIZE[PrincOpsExtras2.ProcDesc] !       DebugUsefulDefs.InvalidAddress => GOTO bad];    gs.sigGF ¬ FrameExtras.GFTHandleToLongGF[Inline.BITAND[pd.gfi, 0FFFCH]];    EXITS bad => gs.sigGF ¬ NIL;    END;  GetSV: PROCEDURE [psb: PSB.PsbIndex] =    BEGIN -- may not work for processes with permanently allocated state vectors; ask Dale or Allen    local: PSB.ProcessStateBlock;    DebugUsefulDefs.LongCopyREAD[      from: @PSB.PDA[ProcessOperations.IndexToHandle[psb]],      to: @local,      nwords: SIZE[PSB.ProcessStateBlock]];    DebugUsefulDefs.LongCopyREAD[from: @PSB.PDA[local.context.state],      to: @gs.StateVector, nwords: SIZE[PrincOps.StateVector]]    END;  SetDebugeeType: PROCEDURE =    BEGIN    IF gs.ESV.version # CPSwapDefs.currentVersion THEN SIGNAL VersionMismatch;    END;  FlushCaches: PROCEDURE  =    BEGIN    SaveSignallerGF[ ! DebugUsefulDefs.InvalidAddress => CONTINUE];    END;  Proceed: PUBLIC PROCEDURE [boot: Volume.ID] =    BEGIN    IF boot = Volume.nullID THEN       TemporaryBooting.BootFromPhysicalVolume[Volume.systemID]    ELSE TemporaryBooting.BootFromVolume[boot];    END;  END.
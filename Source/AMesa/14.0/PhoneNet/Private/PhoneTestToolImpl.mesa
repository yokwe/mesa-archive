-- File: PhoneTestToolImpl.mesa - last edit:-- AOF                 14-Apr-87 16:59:19-- Created by FormSWLayoutTool on 29-Sep-85 10:49-- Copyright (C) 1985, 1987 by Xerox Corporation. All rights reserved.DIRECTORY  AddressTranslation USING [    Error, NetworkAddress, StringToNetworkAddress],  Buffer USING [Buffer, ReturnBuffer],  BufferDisplay USING [Format, Level1Packet, OutputProc],  Checksums USING [SetChecksum, TestChecksum],  Format USING [Date, Decimal, HostNumber, LongNumber, StringProc],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType, CommandItem,    DisplayItem, Enumerated, EnumeratedItem, EnumeratedNotifyProcType,    line0, line1, line2, line4, line6, line7, line8, line9, NotifyProcType,    NumberItem, ProcType, StringItem],  Heap USING [Create],  Inline USING [DBITSHIFT, LongNumber, LowByte, LowHalf],  NSBuffer USING [    AccessHandle, Body, Buffer, DestroyPool, GetBuffer, MakePool, ReturnBuffer],  NSConstants USING [echoerSocket],  NSTypes USING [bytesPerIDPHeader, maxIDPDataBytes],  PhoneAdoption USING [AdoptForNS, DisownFromNS],  PhoneNet USING [    Destroy, EntityClass, Initialize, InvalidLineNumber, Negotiation],  PhoneNetFriends USING [    EnumerateDriverInfo, NetEnumerator, nullNetEnumerate, PhoneNetEvents,    PhoneNetInfo, State],  PhoneNetInternal,  Process USING [    Abort, Detach, EnableAborts, GetCurrent, InitializeCondition, Pause,    SecondsToTicks, SetPriority],  ProcessPriorities USING [priorityClient],  Protocol1 USING [EncapsulateAndTransmit],  Put USING [Text],  RS232C USING [    ChannelHandle, ChannelInUse, CommParamObject, Create, Delete, Duplexity,     InvalidParameter, LineSpeed, TransferStatus],  RS232CEnvironment USING [CommParamObject, Duplexity, LineSpeed],  RS232CInternal USING [ChannelStatusHandle],  Socket USING [SetPacketBytes, SwapSourceAndDestination],  SpecialCommunication USING [SetSpyProc, SpyProc],  System USING [    GetGreenwichMeanTime, HostNumber, NetworkAddress, nullSocketNumber],  Tool USING [    Create, MakeFileSW, MakeFormSW, MakeMsgSW, MakeSWsProc, UnusedLogName],  ToolWindow USING [State, TransitionProcType],  UserInput USING [UserAbort],  Window USING [Box, Handle],  WindowFont USING [CharWidth];PhoneTestToolImpl: MONITOR  IMPORTS    AddressTranslation, Buffer, BufferDisplay, Checksums, Format, FormSW,    Heap, Inline, NSBuffer, PhoneAdoption, PhoneNet, PhoneNetInternal, Process,    Protocol1, Put, RS232C, Socket, SpecialCommunication, System, Tool,    UserInput, WindowFont, PhoneNetFriends  EXPORTS RS232C =  BEGIN  ChannelHandle: PUBLIC TYPE = RS232CInternal.ChannelStatusHandle;  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = MACHINE DEPENDENT RECORD [    msgSW(0): Window.Handle ¬ NIL,    formSW(2): Window.Handle ¬ NIL,    fileSW(4): Window.Handle ¬ NIL,    remotesID(6): LONG STRING ¬ NIL,    entityClass(8): PhoneNet.EntityClass ¬ internetworkRouter,    negotiationMode(9): PhoneNet.Negotiation ¬ active,    lineSpeed(10): RS232CEnvironment.LineSpeed ¬ bps2400,    duplexity(11): RS232CEnvironment.Duplexity ¬ full,    driverActivated(12): BOOLEAN ¬ FALSE,    verbose(13): BufferDisplay.Format ¬ octal2,    packetsInFlight(14): INTEGER ¬ 1,    dataPattern(15): DataPattern ¬ page,    packetLengthMin(16): NATURAL ¬ 0,    packetLengthMax(17): NATURAL ¬ maxBytes,    receiverStarted(18): BOOLEAN ¬ FALSE,    echoServerStarted(19): BOOLEAN ¬ FALSE,    test(20): TestParms ¬ []];  TestParms: TYPE = RECORD[    fiveSeconds: CONDITION,    line: LONG STRING ¬ NIL,    flightCount: INTEGER ¬ 0,    testInProgress: BOOLEAN ¬ FALSE,    cH: ChannelHandle ¬ NIL,    commParams: RS232C.CommParamObject ¬ [      duplex: full, lineType: bitSynchronous,      lineSpeed: bps4800, accessDetail: directConn[]]];  FormItems: TYPE = {remotesID, stats, entityClass, negotiationMode,    lineSpeed, duplexity, driverActivated, verbose, packetsInFlight,    dataPattern, packetLengthMin, packetLengthMax, startSender,    startEchoUser, receiverStarted, echoServerStarted};  DataPattern: TYPE = {zeros, ones, icbs, icws, random, page};  <<statArray: FaceArray;>>  FaceStatus: TYPE = LONG POINTER TO FaceArray;  FaceArray: TYPE = ARRAY RS232C.TransferStatus OF CARDINAL;  data: DataHandle ¬ NIL;  wh: Window.Handle ¬ NIL;  zone: UNCOUNTED ZONE ¬ Heap.Create[initial: 4];  outproc: Format.StringProc = {Put.Text[data.fileSW, s]};  maxBytes: NATURAL = NSTypes.maxIDPDataBytes;  initialBox: Window.Box = [place: [x:512, y: 231], dims: [w: 512, h: 350]];  To: PROC[b: NSBuffer.Buffer] RETURNS[Buffer.Buffer] = INLINE    {RETURN[LOOPHOLE[b]]};  From: PROC[b: Buffer.Buffer] RETURNS[NSBuffer.Buffer] = INLINE    {RETURN[LOOPHOLE[b]]};  AdjustFlightCount: ENTRY PROC[adjust: INTEGER] =    BEGIN    ENABLE UNWIND => NULL;    Loop: TYPE = {first, second};    SELECT adjust FROM      +1 =>	FOR loop: Loop IN Loop	  UNTIL data.test.flightCount < data.packetsInFlight DO 	  WAIT data.test.fiveSeconds;	  IF loop = LAST[Loop] THEN {outproc["#"L]; adjust ¬ 0};	  ENDLOOP;      -1 => NOTIFY data.test.fiveSeconds;      ENDCASE;    data.test.flightCount ¬ data.test.flightCount + adjust;    END;  --AdjustFlightCount  ActivateDriver:  PROC =    BEGIN    found: BOOLEAN;    state: PhoneNetInternal.State;    data.test.commParams.duplex ¬ data.duplexity;    data.test.commParams.lineSpeed ¬ data.lineSpeed;    [] ¬ PhoneNetInternal.RegisterSpy[InternalSpy];    outproc["Creating channel..."L];        data.test.cH ¬ RS232C.Create[      0, @data.test.commParams, preemptAlways, preemptNever !      RS232C.InvalidParameter =>        {outproc["error: invalid parameter...\n"L]; GOTO error};      RS232C.ChannelInUse =>        {outproc["error: channel in use...\n"L]; GOTO error}];    outproc["okay...initializing driver..."L];    PhoneNet.Initialize[      lineNumber: 0, channel: data.test.cH, commParams: @data.test.commParams,      negotiationMode: data.negotiationMode, hardwareStatsAvailable: TRUE,      ourEntityClass: data.entityClass, clientHostNumber: ];    outproc["okay...adopting ns protocol family..."];    [found, state] ¬ PhoneNetInternal.FindLine[0];    IF found THEN      BEGIN      PhoneAdoption.AdoptForNS[@state.phoneNetObject];      outproc["done\n"L];      END    ELSE      BEGIN      outproc["phonenet not initialized..."L];      PhoneNet.Destroy[0 !	PhoneNet.InvalidLineNumber =>	  {outproc["PhoneNet.InvalidLineNumber\n"L]; GOTO error}];      RS232C.Delete[data.test.cH]; outproc["channel deleted..."L];      GOTO error;      END;    EXITS error =>      BEGIN      data.driverActivated ¬ FALSE;  --reset - we failed      FormSW.DisplayItem[data.formSW, FormItems.driverActivated.ORD];      END;    END;  --ActivateDriver  DeactivateDriver: PROC =    BEGIN    found: BOOLEAN;    state: PhoneNetInternal.State;    [] ¬ PhoneNetInternal.RegisterSpy[NIL];    outproc["Disowning from ns protocol family..."L];    [found, state] ¬ PhoneNetInternal.FindLine[0];    IF found THEN      BEGIN      PhoneAdoption.DisownFromNS[@state.phoneNetObject];      outproc["okay...destroying phonenet driver..."L];      END    ELSE {outproc["line 0 not found..."L]; GOTO error};    PhoneNet.Destroy[0 !      PhoneNet.InvalidLineNumber =>        {outproc["PhoneNet.InvalidLineNumber..."L]; GOTO error}];    outproc["okay...deleting RS232C channel..."L];    RS232C.Delete[data.test.cH];    outproc["done\n"L];    EXITS error => outproc["done\n"L];    END;  --DeactivateDriver  InternalSpy: PhoneNetInternal.Spy =    BEGIN    IF data.verbose = octal2 THEN RETURN;    outproc["Spy("L];    Format.Decimal[outproc, lineNumber];    outproc[IF sent THEN ") xmt ["L ELSE ") rcv ["L];    outproc[SELECT type FROM      null => "null"L, terminateRequest => "terminateRequest"L,      terminateReply => "terminateReply"L, areYouThere => "areYouThere"L,      iAmHere => "iAmHere"L, myOptions => "myOptions"L,      optionsAck => "optionsAck"L, versionReject => "versionReject"L,      classReject => "classReject"L, addressReject => "addressReject"L,      sizeReject => "sizeReject"L, ENDCASE => "???"L];    outproc["["L];    WITH c: body SELECT type FROM      myOptions =>	BEGIN	outproc["highestVersionNumber: "L];	outproc[SELECT c.highestVersionNumber FROM	  null => "null(0)"L, old => "old(1)"L, siuSpecial => "siuSpecial(2)"L,	  version3 => "version3(3)"L, ENDCASE => "???"L];	outproc[", lowestVersionNumber: "L];	outproc[SELECT c.lowestVersionNumber FROM	  null => "null(0)"L, old => "old(1)"L, siuSpecial => "siuSpecial(2)"L,	  version3 => "version3(3)"L, ENDCASE => "???"L];	outproc[", sourceHost: ."L];	Format.HostNumber[outproc, c.sourceHost, hex];	outproc["., entityClass: "L];	outproc[SELECT c.entityClass FROM	  internetworkRouter => "internetworkRouter(0)"L,	  clusterRouter => "clusterRouter(1)"L, siu => "siu(2)"L,	  remoteHost => "remoteHost(3)"L, ENDCASE => "???"L];	END;      optionsAck =>	BEGIN	outproc["sourceHost: ."L];	Format.HostNumber[outproc, c.destinationHost, hex];	outproc["."L];	END;      versionReject =>	BEGIN	outproc["highestVersionNumber: "L];	outproc[SELECT c.highestVersionNumber FROM	  null => "null(0)"L, old => "old(1)"L, siuSpecial => "siuSpecial(2)"L,	  version3 => "version3(3)"L, ENDCASE => "???"L];	END;      classReject =>	BEGIN	outproc["entityClass: "L];	outproc[SELECT c.entityClass FROM	  internetworkRouter => "internetworkRouter(0)"L,	  clusterRouter => "clusterRouter(1)"L, siu => "siu(2)"L,	  remoteHost => "remoteHost(3)"L, ENDCASE => "???"L];	END;      ENDCASE => NULL;    outproc["]\n"L];      END;  --InternalSpy  ToggleDriver: FormSW.NotifyProcType =    {IF data.driverActivated THEN ActivateDriver[] ELSE DeactivateDriver[]};  StartSender:  ENTRY FormSW.ProcType =     BEGIN    IF data.test.testInProgress THEN {outproc["Test in progress\n"L]; RETURN};    data.test.testInProgress ¬ TRUE;    Process.Detach[FORK SenderProcess[]];    END;  SenderProcess: PROC =    BEGIN    found: BOOLEAN;    n: CARDINAL ¬ 0;    watcher: PROCESS;    body: NSBuffer.Body;    sb: NSBuffer.Buffer ¬ NIL;    pool: NSBuffer.AccessHandle;    state: PhoneNetInternal.State;    him, me: System.NetworkAddress;    bitsout, time: LONG CARDINAL ¬ 0;    bytes: NATURAL ¬ data.packetLengthMin;    outproc["Sender test process started\n"L];    Process.SetPriority[ProcessPriorities.priorityClient];    IF data.remotesID = NIL THEN      {outproc["need address... done\n"L]; GOTO err};     him ¬ AddressTranslation.StringToNetworkAddress[data.remotesID !      AddressTranslation.Error =>	{outproc["address untranslatable... done\n"L]; GOTO err}].addr;    him.socket ¬ System.nullSocketNumber;    me ¬ AddressTranslation.StringToNetworkAddress["ME"L].addr;    [found, state] ¬ PhoneNetInternal.FindLine[0];    IF ~found THEN {outproc["no phonenet\n"L]; RETURN};    pool ¬ NSBuffer.MakePool[data.packetsInFlight, 0];    watcher ¬ FORK Watcher[Process.GetCurrent[]];    time ¬ System.GetGreenwichMeanTime[];  --start of test    bitsout ¬ 0;  --number of bits    FOR packets: CARDINAL IN [0..LAST[CARDINAL]) DO      ENABLE ABORTED => {outproc["...aborted\n"L]; EXIT};      --send a packet.      body ¬ (sb ¬ NSBuffer.GetBuffer[aH: pool, function: send]).ns;      sb.fo.network ¬ LOOPHOLE[@state.phoneNetObject];      body.destination ¬ him; sb.ns.source ¬ me;      body.packetType ¬ private;      FillDataArea[body, bytes];      Socket.SetPacketBytes[sb, bytes];      Checksums.SetChecksum[body];      Protocol1.EncapsulateAndTransmit[To[sb], @him.host]; sb ¬ NIL;      bitsout ¬ bitsout +        Inline.DBITSHIFT[(bytes + NSTypes.bytesPerIDPHeader), 3];      IF (bytes ¬ bytes + 1) > data.packetLengthMax THEN        bytes ¬ data.packetLengthMin;      ENDLOOP;    time ¬ System.GetGreenwichMeanTime[] - time;    IF sb # NIL THEN NSBuffer.ReturnBuffer[sb];    Process.Abort[watcher]; JOIN watcher;    NSBuffer.DestroyPool[pool];    outproc["\nBits/sec out: "L];    bitsout ¬ bitsout / (IF time = 0 THEN LONG[1] ELSE time);    Format.LongNumber[outproc, bitsout, [base: 10]];    outproc["\nSender test process ended\n"L];    data.test.testInProgress ¬ FALSE;    EXITS err => data.test.testInProgress ¬ FALSE;    END;  --SenderProcess  StartEchoUser: ENTRY FormSW.ProcType =    BEGIN    IF data.test.testInProgress THEN {outproc["Test in progresss\n"L]; RETURN};    data.test.testInProgress ¬ TRUE;    Process.Detach[FORK EchoUserProcess[]];    END;  --StartEchoUser  EchoUserProcess: PROC =    BEGIN    mySpy: SpecialCommunication.SpyProc =      BEGIN      SELECT TRUE FROM        (function = send) => b.requeueData ¬ 0;  --buffer going out	(b.fo.driver.device = phonenet) =>  --this is us	  BEGIN	  SELECT TRUE FROM	    (Checksums.TestChecksum[From[b].ns]) =>	      BEGIN	      bitsin ¬ bitsin + Inline.DBITSHIFT[	        (bytes + NSTypes.bytesPerIDPHeader), 3];	      outproc["!"L];	      END;	    (data.verbose # octal2) => DisplayVerbose[b];	    ENDCASE => outproc["*"L];	  AdjustFlightCount[-1];  --one less in the pipe	  Buffer.ReturnBuffer[b]; b ¬ NIL;  --no point pushing farther	  END;	ENDCASE;      RETURN[b];      END;  --mySpy    found: BOOLEAN;    n: CARDINAL ¬ 0;    watcher: PROCESS;    body: NSBuffer.Body;    sb: NSBuffer.Buffer ¬ NIL;    pool: NSBuffer.AccessHandle;    state: PhoneNetInternal.State;    him, me: System.NetworkAddress;    bytes: NATURAL ¬ data.packetLengthMin;    bitsout, bitsin, time: LONG CARDINAL ¬ 0;    outproc["Echo test process started\n"L];    Process.SetPriority[ProcessPriorities.priorityClient];    IF data.remotesID = NIL THEN      {outproc["need address... done\n"L]; GOTO err};     him ¬ AddressTranslation.StringToNetworkAddress[data.remotesID !      AddressTranslation.Error =>	{outproc["address untranslatable... done\n"L]; GOTO err}].addr;    him.socket ¬ NSConstants.echoerSocket;    me ¬ AddressTranslation.StringToNetworkAddress["ME"L].addr;    [found, state] ¬ PhoneNetInternal.FindLine[0];    IF ~found THEN {outproc["no phonenet\n"L]; RETURN};    pool ¬ NSBuffer.MakePool[data.packetsInFlight, 0];    [] ¬ SpecialCommunication.SetSpyProc[mySpy, ns];    watcher ¬ FORK Watcher[Process.GetCurrent[]];    time ¬ System.GetGreenwichMeanTime[];  --start of test    bitsout ¬ bitsin ¬ 0;  --number of bits    FOR packets: CARDINAL IN [0..LAST[CARDINAL]) DO      ENABLE ABORTED => {outproc["...aborted\n"L]; EXIT};      AdjustFlightCount[+1];  --wait for flight count to settle      body ¬ (sb ¬ NSBuffer.GetBuffer[aH: pool, function: send]).ns;      sb.fo.network ¬ LOOPHOLE[@state.phoneNetObject];      body.packetType ¬ private;      Socket.SetPacketBytes[sb, bytes];      body.destination ¬ him; body.source ¬ me;      FillDataArea[body, bytes];      Checksums.SetChecksum[body];      Protocol1.EncapsulateAndTransmit[To[sb], @him.host]; sb ¬ NIL;      bitsout ¬ bitsout +        Inline.DBITSHIFT[(bytes + NSTypes.bytesPerIDPHeader), 3];      IF (bytes ¬ bytes + 1) > data.packetLengthMax THEN        bytes ¬ data.packetLengthMin;      ENDLOOP;    time ¬ System.GetGreenwichMeanTime[] - time;    [] ¬ SpecialCommunication.SetSpyProc[NIL, ns];    IF sb # NIL THEN NSBuffer.ReturnBuffer[sb];    Process.Abort[watcher]; JOIN watcher;    outproc["\nBits/sec out: "L];    bitsout ¬ bitsout / (IF time = 0 THEN LONG[1] ELSE time);    Format.LongNumber[outproc, bitsout, [base: 10]];    outproc["  Bits/sec in: "L];    bitsin ¬ bitsin / (IF time = 0 THEN LONG[1] ELSE time);    Format.LongNumber[outproc, bitsin, [base: 10]];    outproc["\nEcho test process ended\n"L];    NSBuffer.DestroyPool[pool];    data.test.testInProgress ¬ FALSE;    EXITS err => data.test.testInProgress ¬ FALSE;    END;  --EchoUserProcess  ToggleReceiver:  ENTRY FormSW.NotifyProcType =    BEGIN    SELECT TRUE FROM      (~data.receiverStarted) =>	BEGIN	data.test.testInProgress ¬ FALSE;	[] ¬ SpecialCommunication.SetSpyProc[NIL, ns];	outproc["Receiver stopped\n"];	END;      (data.test.testInProgress) =>        BEGIN	outproc["Test in progress"L];	data.receiverStarted ¬ FALSE;	FormSW.DisplayItem[data.formSW, FormItems.receiverStarted.ORD];	END;      ENDCASE =>	BEGIN	outproc["Receiver started\n"L];	data.test.testInProgress ¬ TRUE;	[] ¬ SpecialCommunication.SetSpyProc[ReceiverSpy, ns];	END;    END;  --ToggleReceiver  ToggleEchoServer:  ENTRY FormSW.NotifyProcType =    BEGIN    SELECT TRUE FROM      (~data.echoServerStarted) =>	BEGIN	data.test.testInProgress ¬ FALSE;	[] ¬ SpecialCommunication.SetSpyProc[NIL, ns];	outproc["Echo server stopped\n"];	END;      (data.test.testInProgress) =>        BEGIN	outproc["Test in progress"L];	data.echoServerStarted ¬ FALSE;	FormSW.DisplayItem[data.formSW, FormItems.echoServerStarted.ORD];	END;      ENDCASE =>	BEGIN	data.test.testInProgress ¬ TRUE;	outproc["Echo server started\n"];	[] ¬ SpecialCommunication.SetSpyProc[EchoSpy, ns];	END;    END;  --ToggleEchoServer  ToggleVerbosity: FormSW.EnumeratedNotifyProcType =    BEGIN    SELECT TRUE FROM      (data.verbose = octal2) =>        IF data.test.line # NIL THEN zone.FREE[@data.test.line];      (data.test.line = NIL) => data.test.line ¬ zone.NEW[StringBody[6000]];      ENDCASE;    END;  --ToggleVerbosity  DisplayVerbose: PROC[b: Buffer.Buffer] =    BEGIN    putproc: BufferDisplay.OutputProc = {Put.Text[data.fileSW, s]};    outproc["\nBuffer("L];    Format.LongNumber[outproc, @b.bufferBody,      [base: SELECT data.verbose FROM octal1, ascii => 8, ENDCASE => 16]];    outproc[")\n"L];    IF data.test.line = NIL THEN RETURN;  --probably too early    data.test.line.length ¬ 0;  --just in case the last user didn't    BufferDisplay.Level1Packet[b, data.test.line, data.verbose, putproc];    outproc["\n"L];    END;  --DisplayVerbose  EchoSpy: SpecialCommunication.SpyProc =    BEGIN    SELECT TRUE FROM      (function = send) => NULL;  --this isn't us | its going out      (b.fo.driver.device = phonenet) =>	BEGIN	SELECT TRUE FROM	  (Checksums.TestChecksum[From[b].ns]) =>	    BEGIN	    Socket.SwapSourceAndDestination[From[b]];  --move it back	    Checksums.SetChecksum[From[b].ns];  --recompute the checksum	    Protocol1.EncapsulateAndTransmit[b, @From[b].ns.destination.host];	    outproc["!"L];	    END;	  (data.verbose # octal2) => {DisplayVerbose[b]; Buffer.ReturnBuffer[b]};	  ENDCASE => {outproc["*"L]; Buffer.ReturnBuffer[b]};	b ¬ NIL;	END;      ENDCASE;    RETURN[b];    END;  --EchoSpy  FillDataArea: PROC[body: NSBuffer.Body, bytes: CARDINAL] =    BEGIN    words: NATURAL ¬ (bytes + 1) / 2;    FOR i: NATURAL IN[0..words) DO      SELECT data.dataPattern FROM        icbs =>	  BEGIN	  body.nsBytes[i * 2] ¬ Inline.LowByte[(i * 2) + bytes];	  body.nsBytes[(i * 2) + 1] ¬ Inline.LowByte[(i * 2) + bytes + 1];	  END;	page =>	  BEGIN	  offset: CARDINAL[0..256) = Inline.LowByte[	    (Inline.LowHalf[@body.nsWords[i]] MOD 256) * 2];	  body.nsBytes[i * 2] ¬ offset;	  body.nsBytes[(i * 2) + 1] ¬ offset + 1;	  END;	icws => body.nsWords[i] ¬ i;	ones => body.nsWords[i] ¬ LAST[CARDINAL];	zeros => body.nsWords[i] ¬ FIRST[CARDINAL];	ENDCASE => body.nsWords[i] ¬ FIRST[CARDINAL];       ENDLOOP;    END;  --FillDataArea  ReceiverSpy: SpecialCommunication.SpyProc =    BEGIN    IF b.fo.driver.device = phonenet THEN      BEGIN      SELECT TRUE FROM        (Checksums.TestChecksum[From[b].ns]) => outproc["!"L];	(data.verbose # octal2) => DisplayVerbose[b];	ENDCASE => outproc["*"L];      Buffer.ReturnBuffer[b]; b ¬ NIL;      END;    RETURN[b];  --consume these trash packets!    END;  --ReceiverSpy  Statistics: FormSW.ProcType =    BEGIN    out: Format.StringProc = outproc;    info: PhoneNetFriends.PhoneNetInfo;    current: PhoneNetFriends.NetEnumerator ¬ PhoneNetFriends.nullNetEnumerate;    --UNTIL all done-- DO      [current, info] ¬ PhoneNetFriends.EnumerateDriverInfo[current];      IF current = PhoneNetFriends.nullNetEnumerate THEN EXIT;      out["\n\nPhoneNetInfo["L];      out["State: {"L];      out[SELECT info.state FROM	idle => "awaiting physical medium"L,	option1 => "active negotiation"L,	option2 => "passive negotiation"L,	option3 => "awaiting options"L,	option4 => "awaiting optionsAck"L,	data => "data transfer"L,	terminate1 => "await terminateReply"L,	terminate2 => "termination dally"L,	ENDCASE => "???"L];      out["}, "L];      out["timeStarted: "L];      Format.Date[out, info.timeStarted];       out[", "];      out["timeConnectionEstablished: "L];      Format.Date[out, info.timeConnectionEstablished];       out[", "];      out["remoteHostNumber: "L];      Format.HostNumber[out, info.remoteHostNumber, octal];       out[", "];      out["protocolVersion:  {"L];      IF info.state = data THEN	out[SELECT info.protocolVersion FROM	  null => "null"L,  old => "old"L, siuSpecial => "siuSpecial"L,	  version3 => "version3"L, ENDCASE => "???"L]      ELSE out["<state # data>"L];      out["}, "L];      out["lineNumber:  "L]; Format.Decimal[out, info.lineNumber]; out[", "L];      out["duplexity: {"L];      out[SELECT info.duplexity FROM half => "half"L, ENDCASE => "full"L];      out["}, "L];      out["lineSpeed: {"L];      out[SELECT info.lineSpeed FROM        bps50 => "bps50"L, bps75 => "bps75"L, bps110 => "bps110"L,	bps134p5 => "bps134p5"L, bps150 => "bps150"L, bps300 => "bps300"L,	bps600 => "bps600"L, bps1200 => "bps1200"L, bps2400 => "bps2400"L,	bps3600 => "bps3600"L, bps4800 => "bps4800"L, bps7200 => "bps7200"L,	bps9600 => "bps9600"L, bps19200 => "bps19200"L, bps28800 => "bps28800"L,	bps38400 => "bps38400"L, bps48000 => "bps48000"L,	bps56000 => "bps56000"L, bps57600 => "bps57600"L,	ENDCASE => "???"L];      out["}, "L];      out["speed: "L]; Format.Decimal[out, info.speed]; out["Kbps, "L];      out["negotiationMode: {"L];      out[IF info.negotiationMode = active THEN "active"L ELSE "passive"L];      out["}, "L];      out["theirEntityClass: {"L];      out[SELECT info.theirEntityClass FROM	internetworkRouter => "internetworkRouter"L,	clusterRouter => "clusterRouter"L, siu => "siu"L,	remoteHost => "remoteHost"L, ENDCASE => "???"L];      out["}, "L];      out["hardwareStatsAvailable: "L];      out[IF info.hardwareStatsAvailable THEN "TRUE"L ELSE "FALSE"L];      out[", "L];      out["clientHostNumber: "L];      Format.HostNumber[out, info.remoteHostNumber, octal];       out[", "];      out["sendQueueLength: "L];      Format.Decimal[out, info.sendQueueLength];      out[", "L];      BEGIN      first: BOOLEAN ¬ TRUE;      event: ARRAY PhoneNetFriends.PhoneNetEvents OF STRING = [	"pktsSent"L, "bytesSent"L, "sendErrorBadStatus"L, "nsSent"L,	"pupSent"L, "rawSent"L, "controlSent"L, 	-- receiving	"pktsReceived"L, "bytesReceived"L, "nsReceived"L, "pupReceived"L,	"controlPktReceived"L, "unknownPktTypeReceived"L, "pktsRejected"L,	"rcvErrorDataLost"L, "rcvErrorCRC"L, "rcvErrorNoGet"L, "rcvErrorUnknown"L,	"rcvErrorFrameTimeout"L, "rcvDeviceError"L, 	-- line status	"dsrDropped"L, "congestion"L,  -- queue too long	"connTooGreedy"L, "queueTooOld"L, "tooLongSinceLastReceive"L,	"connectionEstablishedEvents"L, "connectionNotEstablishedEvents"L,	"noResponseEvents"L, 		-- development statistics	"notInDataState"L, "noPupTranslation"L, "sendingNoDSR"L,	"pktsRejectedBadLength"L, "noSmallBufferAvailable"L,	"noBufferAvailable"L, "protocolError"L];      --this next section requires mods to the PhoneNetDriver      out["stats: ["L];      FOR i: PhoneNetFriends.PhoneNetEvents IN PhoneNetFriends.PhoneNetEvents DO        IF info.stats[i] # 0 THEN	  BEGIN	  IF ~first THEN out[", "L] ELSE first ¬ FALSE;	  out[event[i]]; out[": "L];	  Format.LongNumber[out, info.stats[i], [base: 10]];	  END;	REPEAT FINISHED => out["]"L];	ENDLOOP;      END;      out["]"L];      <<BEGIN      first: BOOLEAN ¬ TRUE;      i: RS232C.TransferStatus;      fs: FaceStatus ¬ info.clientData;      stati: ARRAY RS232C.TransferStatus OF STRING = [	"success"L, "dataLost"L, "deviceError"L, "frameTimeout"L,	"checksumError"L, "parityError"L, "asynchFramingError"L,	"invalidChar"L, "invalidFrame"L, "aborted"L, "disaster"L];       out[", transfer status: ["L];      FOR i IN RS232C.TransferStatus DO        IF fs[i] # 0 THEN	  BEGIN	  IF ~first THEN out[", "L] ELSE first ¬ FALSE;	  out[stati[i]]; out[": "L];	  Format.Decimal[out, fs[i]];	  END;	REPEAT FINISHED => out["]"L];	ENDLOOP;      out["]"L];      END;>>      out["]\n"L];      ENDLOOP;        END;  --Statistics  Watcher: PROC[parent: PROCESS] =    BEGIN    ENABLE ABORTED => CONTINUE;    UNTIL UserInput.UserAbort[wh] DO Process.Pause[2]; ENDLOOP;    Process.Abort[parent];    END;  --Watcher  ClientTransition: ToolWindow.TransitionProcType = {    SELECT TRUE FROM      old = inactive =>        BEGIN        IF data = NIL THEN data ¬ zone.NEW[Data ¬ []];	Process.InitializeCondition[	  @data.test.fiveSeconds, Process.SecondsToTicks[5]];	Process.EnableAborts[@data.test.fiveSeconds];	END;      new = inactive =>        IF data # NIL THEN {zone.FREE[@data.test.line]; zone.FREE[@data]};      ENDCASE;    };  Init: PROCEDURE = {    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default, initialBox: initialBox,      clientTransition: ClientTransition, name: "PhoneTestTool"L,      cmSection: "PhoneTestTool"L];    };  MakeSWs: Tool.MakeSWsProc = {    logName: LONG STRING ¬ [20];    Tool.UnusedLogName[unused: logName, root: "PhoneTestTool.log"L];    data.msgSW ¬ Tool.MakeMsgSW[window: window];    data.formSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeForm, zone: zone];    data.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    };  charWidth: CARDINAL ¬ WindowFont.CharWidth['0];  CharPos: PROC[char: CARDINAL] RETURNS [x: INTEGER] = {    x ¬ charWidth * char};  MakeForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = FormItems.LAST.ORD + 1;    entityClass: ARRAY[0..4) OF Enumerated ¬ [      ["internetworkRouter"L, PhoneNet.EntityClass[internetworkRouter]],      ["clusterRouter"L, PhoneNet.EntityClass[clusterRouter]],      ["siu"L, PhoneNet.EntityClass[siu]],      ["remoteHost"L, PhoneNet.EntityClass[remoteHost]]];    negotiationMode: ARRAY[0..2) OF Enumerated ¬ [      ["active"L, PhoneNet.Negotiation[active]],      ["passive"L, PhoneNet.Negotiation[passive]]];    lineSpeed: ARRAY[0..7) OF Enumerated ¬ [      ["bps1200"L, RS232CEnvironment.LineSpeed[bps1200]],      ["bps2400"L, RS232CEnvironment.LineSpeed[bps2400]],      ["bps3600"L, RS232CEnvironment.LineSpeed[bps3600]],      ["bps4800"L, RS232CEnvironment.LineSpeed[bps4800]],      ["bps9600"L, RS232CEnvironment.LineSpeed[bps9600]],      ["bps19200"L, RS232CEnvironment.LineSpeed[bps19200]],      ["bps56000"L, RS232CEnvironment.LineSpeed[bps56000]]];    duplexity: ARRAY[0..1) OF Enumerated ¬ [      ["full"L, RS232CEnvironment.Duplexity[full]]];    dataPattern: ARRAY[0..6) OF Enumerated ¬ [      ["0's"L, DataPattern[zeros]], ["1's"L, DataPattern[ones]],      ["incrementing bytes"L, DataPattern[icbs]],      ["incrementing words"L, DataPattern[icws]],      ["random"L, DataPattern[random]],      ["page relative"L, DataPattern[page]]];    verbosity: ARRAY[0..4) OF Enumerated ¬ [      ["off", BufferDisplay.Format[octal2]],      ["octal", BufferDisplay.Format[octal1]],      ["ascii", BufferDisplay.Format[ascii]],      ["hex", BufferDisplay.Format[hex]]];    items ¬ AllocateItemDescriptor[nItems, zone];    items[FormItems.remotesID.ORD] ¬ StringItem[      tag: "Remote's ID"L, place: [CharPos[1], line0], inHeap: TRUE,      string: @data.remotesID, z: zone];    items[FormItems.stats.ORD] ¬ CommandItem[      tag: "current statistics"L, place: [CharPos[37], line0],      proc: Statistics, z: zone];    items[FormItems.entityClass.ORD] ¬ EnumeratedItem[      tag: "Entity class"L, place: [CharPos[1], line1],      choices: DESCRIPTOR[entityClass], value: @data.entityClass, z: zone];    items[FormItems.negotiationMode.ORD] ¬ EnumeratedItem[      tag: "negotiation class"L, place: [CharPos[37], line1],      choices: DESCRIPTOR[negotiationMode], value: @data.negotiationMode,      z: zone];    items[FormItems.lineSpeed.ORD] ¬ EnumeratedItem[      tag: "Line speed"L, place: [CharPos[1], line2],      choices: DESCRIPTOR[lineSpeed], value: @data.lineSpeed, z: zone];    items[FormItems.duplexity.ORD] ¬ EnumeratedItem[      tag: "duplexity"L, place: [CharPos[37], line2],      choices: DESCRIPTOR[duplexity], value: @data.duplexity, z: zone];    items[FormItems.driverActivated.ORD] ¬ BooleanItem[      tag: "Driver activated"L, place: [CharPos[1], line4],      proc: ToggleDriver, switch: @data.driverActivated, z: zone];    items[FormItems.verbose.ORD] ¬ EnumeratedItem[      tag: "verbose"L, place: [CharPos[37], line4], proc: ToggleVerbosity,      choices: DESCRIPTOR[verbosity], value: @data.verbose, z: zone];    items[FormItems.packetsInFlight.ORD] ¬ NumberItem[      tag: "Packets in flight"L, place: [CharPos[1], line6],      signed: FALSE, value: @data.packetsInFlight, z: zone];    items[FormItems.dataPattern.ORD] ¬ EnumeratedItem[      tag: "data pattern"L, place: [CharPos[37], line6],      choices: DESCRIPTOR[dataPattern], value: @data.dataPattern, z: zone];    items[FormItems.packetLengthMin.ORD] ¬ NumberItem[      tag: "Packet length(min)"L, place: [CharPos[1], line7],      signed: FALSE, value: @data.packetLengthMin, z: zone];    items[FormItems.packetLengthMax.ORD] ¬ NumberItem[      tag: "packet length(max)"L, place: [CharPos[37], line7],      signed: FALSE, value: @data.packetLengthMax, z: zone];    items[FormItems.startSender.ORD] ¬ CommandItem[      tag: "Start sender"L, place: [CharPos[1], line8],      proc: StartSender, z: zone];    items[FormItems.startEchoUser.ORD] ¬ CommandItem[      tag: "Start echo user"L, place: [CharPos[37], line8],      proc: StartEchoUser, z: zone];    items[FormItems.receiverStarted.ORD] ¬ BooleanItem[      tag: "Receiver started"L, place: [CharPos[1], line9],      proc: ToggleReceiver, switch: @data.receiverStarted, z: zone];    items[FormItems.echoServerStarted.ORD] ¬ BooleanItem[      tag: "Echo server started"L, place: [CharPos[37], line9],      proc: ToggleEchoServer, switch: @data.echoServerStarted, z: zone];    RETURN[items: items, freeDesc: TRUE];    };  -- Mainline code  Init[];  -- this gets string out of global frame  END...    
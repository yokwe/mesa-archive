-- Copyright (C) 1981, 1982, 1983  by Xerox Corporation. All rights reserved. -- file: Mileage.mesa - last edit by-- Loretta,	10-Nov-81  9:24:42-- Karlton,	19-Aug-83 16:08:14-- Johnsson,	22-Sep-82 16:21:12-- JGS,		14-Sep-81  7:58:36DIRECTORY  Ascii USING [CR, DEL, NUL, SP, TAB],  Date USING [StringToPacked],  Exec USING [AddCommand, ExecProc, GetTTY, Handle, ReleaseTTY],  MStream USING [ReadWrite],  Real USING [AppendReal, PlusZero, StringToReal],  Stream USING [Delete, EndOfStream, GetChar, Handle, PutBlock, PutChar],  String USING [AppendChar, AppendDecimal, AppendString],  Time USING [Current, Invalid, Packed, Unpack, Unpacked],  TTY USING [GetChar, GetID, GetLine, Handle, PutChar, PutString, Rubout];Mileage: PROGRAM   IMPORTS Date, Exec, MStream, Real, Stream, String, Time, TTY =  BEGIN  zero: REAL = Real.PlusZero;  litersPerGal: REAL = 3.785306;  galsPerLiter: REAL = 0.264179;  BufferObject: TYPE = RECORD [s: STRING, offset: CARDINAL];  Buffer: TYPE = POINTER TO BufferObject;  BreakClass: TYPE = {alpha, number, other};  DataPoint: TYPE = {start, prev, new, cum, slide};  slideSize: CARDINAL = 5;  SlideRange: TYPE = [0..slideSize);  OverFlow: ERROR = CODE;    tty: TTY.Handle;  exec: Exec.Handle;  -- procedures  Confirm: PROCEDURE RETURNS [t: BOOLEAN] = {    TTY.PutString[tty, " [Confirm] "L];    DO      SELECT TTY.GetChar[tty] FROM        'y, 'Y, Ascii.CR => {TTY.PutString[tty, "Yes"L]; t ¬ TRUE; EXIT};        'n, 'N, Ascii.DEL => {TTY.PutString[tty, "No"L]; t ¬ FALSE; EXIT};        ENDCASE => TTY.PutChar[tty, '?];      ENDLOOP};  ConvertDate: PROCEDURE [s: STRING] = {    date: Time.Packed ¬ Time.Current[];    unpacked: Time.Unpacked;    months: ARRAY [0..12) OF LONG STRING = [      "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep",      "Oct", "Nov", "Dec"];    date ¬ Date.StringToPacked[s ! Time.Invalid => CONTINUE].dt;    unpacked ¬ Time.Unpack[date];    s.length ¬ 0;    IF unpacked.day < 10 THEN String.AppendChar[s, Ascii.SP];    String.AppendDecimal[s, unpacked.day];    String.AppendString[s, months[unpacked.month]];    unpacked.year ¬ unpacked.year MOD 100;    IF unpacked.year < 10 THEN String.AppendChar[s, '0];    String.AppendDecimal[s, unpacked.year]};  FixedRealToString: PROCEDURE [s: STRING, r: REAL] = {    temp: LONG STRING = [30];    c: CHARACTER;    i: CARDINAL ¬ 0;    Real.AppendReal[temp, r + 0.05];  -- round up the tenths    THROUGH [0..temp.length) DO      String.AppendChar[s, c ¬ temp[i]];      i ¬ i + 1;      IF c = '. THEN EXIT;      REPEAT FINISHED => String.AppendChar[s, '.];      ENDLOOP;    String.AppendChar[s, IF i < temp.length THEN temp[i] ELSE '0]};  GetFile: PROCEDURE [prompt: STRING] RETURNS [Stream.Handle] = {    name: STRING ¬ [80];    IF prompt # NIL THEN TTY.PutString[tty, prompt];    name.length ¬ 0;    TTY.GetID[tty, name];    TTY.PutChar[tty, Ascii.CR];    RETURN[MStream.ReadWrite[name, [], text]]};  GetGallons: PROCEDURE [b: Buffer] RETURNS [gals: REAL] = {    c: CHARACTER;    gals ¬ RealScan[b];    c ¬ Lop[b];    IF c = '/ THEN {gals ¬ gals/RealScan[b]; c ¬ Lop[b]};    IF c = 'l OR c = 'L THEN gals ¬ gals * galsPerLiter;    IF gals < .3 THEN gals ¬ gals * 100.0};  Lop: PROCEDURE [b: Buffer] RETURNS [CHARACTER] = {    IF b.offset >= b.s.length THEN RETURN[Ascii.NUL];    b.offset ¬ b.offset + 1;    RETURN[b.s[b.offset - 1]]};  OutReal: PROCEDURE [stream: Stream.Handle, r: REAL, w: CARDINAL ¬ 8] = {    s: STRING = [20];    FixedRealToString[s, r];    THROUGH [0..w - s.length) DO Stream.PutChar[stream, Ascii.SP] ENDLOOP;    OutString[stream, s]};  OutString: PROCEDURE [stream: Stream.Handle, string: STRING] = {      Stream.PutBlock[stream, [LOOPHOLE[LONG[@string.text]], 0, string.length]]};  RealScan: PROCEDURE [b: Buffer] RETURNS [REAL] = {    number: LONG STRING = [20];    ScanUntil[NIL, b, TRUE, number];    ScanUntil[number, b, FALSE, number];    RETURN[Real.StringToReal[number]]};  ScanUntil: PROCEDURE [    string: LONG STRING, b: Buffer, is: BOOLEAN, class: BreakClass] = {    c: CHARACTER;    IF string # NIL THEN string.length ¬ 0;    DO      IF b.offset >= b.s.length THEN RETURN;      SELECT (c ¬ b.s[b.offset]) FROM        IN ['A..'Z], IN ['a..'z] => IF is = (class = alpha) THEN RETURN;        IN ['0..'9], '. => IF is = (class = number) THEN RETURN;        ENDCASE => IF is = (class = other) THEN RETURN;      IF string # NIL THEN String.AppendChar[string, c];      b.offset ¬ b.offset + 1;      ENDLOOP};  SkipDate: PROCEDURE [b: Buffer] = {    ScanUntil[NIL, b, FALSE, other];  -- skip leading white space    ScanUntil[NIL, b, TRUE, other]};  WriteReal: PROCEDURE [r: REAL] = {    s: STRING = [20]; FixedRealToString[s, r]; TTY.PutString[tty, s]};  DoIt: Exec.ExecProc = {    file: Stream.Handle;    lineString: STRING = [200];    lastLine: STRING = [200];    lineBuffer: BufferObject ¬ [lineString, 0];    line: Buffer = @lineBuffer;    miles, gallons, mpg, travelled: ARRAY DataPoint OF REAL ¬ ALL[zero];    slideGallons, slideMiles: ARRAY SlideRange OF REAL ¬ ALL[zero];    slideGallonsTotal, slideMilesTotal, slideMPG: REAL ¬ zero;    slideIndex: SlideRange ¬ 0;    Compute: PROCEDURE = {      travelled[new] ¬ miles[new] - miles[prev];      mpg[new] ¬ travelled[new]/gallons[new];      travelled[cum] ¬ miles[new] - miles[start];      gallons[cum] ¬ gallons[prev] + gallons[new];      mpg[cum] ¬ travelled[cum]/gallons[cum];      slideGallonsTotal ¬ slideGallonsTotal - slideGallons[slideIndex];      slideMilesTotal ¬ slideMilesTotal - slideMiles[slideIndex];      slideGallons[slideIndex] ¬ gallons[new];      slideMiles[slideIndex] ¬ travelled[new];      slideGallonsTotal ¬ slideGallonsTotal + slideGallons[slideIndex];      slideMilesTotal ¬ slideMilesTotal + slideMiles[slideIndex];      slideMPG ¬ slideMilesTotal/slideGallonsTotal;      slideIndex ¬ (slideIndex + 1) MOD 5};    GetLastLine: PROCEDURE [s: Stream.Handle] = {      lastLine.length ¬ 0;      DO        IF GetLine[s] THEN EXIT;        SkipDate[line];        [] ¬ RealScan[line];  -- total miles        slideGallons[slideIndex] ¬ RealScan[line];        slideMiles[slideIndex] ¬ RealScan[line];        slideIndex ¬ (slideIndex + 1) MOD slideSize;        ENDLOOP;      FOR i: SlideRange IN SlideRange DO        slideGallonsTotal ¬ slideGallonsTotal + slideGallons[i];        slideMilesTotal ¬ slideMilesTotal + slideMiles[i]        ENDLOOP};    GetLine: PROCEDURE [s: Stream.Handle] RETURNS [eof: BOOLEAN ¬ FALSE] = {      line.s.length ¬ line.offset ¬ 0;      DO        c: CHARACTER ¬ Stream.GetChar[s ! Stream.EndOfStream => GOTO allGone];	IF c = Ascii.CR THEN EXIT;        String.AppendChar[line.s, c];	ENDLOOP;      lastLine.length ¬ 0;      String.AppendString[lastLine, line.s];      EXITS allGone => eof ¬ TRUE};    GetNewData: PROCEDURE [data: Stream.Handle] = {      date: STRING = [40];      comment: STRING = [100];      line.s ¬ lineString;      DO        TTY.PutChar[tty, Ascii.CR];        TTY.PutString[tty, "Date: "L];        date.length ¬ 0;	TTY.GetLine[tty, date];        IF date.length = 0 THEN RETURN;        ConvertDate[date];        TTY.PutString[tty, "Mileage: "L];        lineString.length ¬ 0;	TTY.GetLine[tty, lineString];        line.offset ¬ 0;        miles[new] ¬ RealScan[line];        TTY.PutString[tty, "Gallons: "L];        lineString.length ¬ 0;	TTY.GetLine[tty, lineString];        line.offset ¬ 0;        gallons[new] ¬ GetGallons[line];        TTY.PutString[tty, "Comment: "L];        comment.length ¬ 0;	TTY.GetLine[tty, comment];        Compute[];        WriteReal[travelled[new]];        TTY.PutChar[tty, '/];        WriteReal[gallons[new]];        TTY.PutString[tty, " = "L];        WriteReal[mpg[new]];        IF (travelled[new] < 100.0 OR travelled[new] > 500.0 OR	  mpg[new] < 10.0 OR mpg[new] > 1.5 * mpg[cum])          AND ~Confirm[] THEN EXIT;        TTY.PutChar[tty, Ascii.CR];        OutString[data, date];        Stream.PutChar[data, Ascii.TAB];        OutReal[data, miles[new]];        OutReal[data, gallons[new]];        OutReal[data, travelled[new]];        OutReal[data, mpg[new]];        OutReal[data, gallons[cum]];        OutReal[data, travelled[cum], 9];        OutReal[data, mpg[cum]];        OutReal[data, slideMPG];        IF comment.length > 0 THEN {          OutString[data, "  "L]; OutString[data, comment]};        Stream.PutChar[data, Ascii.CR];        miles[prev] ¬ miles[new];        gallons[prev] ¬ gallons[cum];        ENDLOOP};    GetOldData: PROCEDURE [data: Stream.Handle] = {      DO        [] ¬ GetLine[data];        IF line.s.length = 0 THEN EXIT;  -- find blank line at start of file        ENDLOOP;      [] ¬ GetLine[data];  -- get first data line      miles[start] ¬ RealScan[line];      GetLastLine[data];      IF lastLine.length # 0 THEN {        line.s ¬ lastLine;        SkipDate[line];        miles[prev] ¬ RealScan[line];        [] ¬ RealScan[line];			-- skip previous gallons        [] ¬ RealScan[line];			-- skip previous miles travelled        [] ¬ RealScan[line];			-- skip previous miles/gallon        gallons[prev] ¬ RealScan[line]}		-- old cum gallons      ELSE miles[prev] ¬ miles[start]};    exec ¬ h;    tty ¬ Exec.GetTTY[h];    file ¬ GetFile["Input File: "L];    IF file # NIL THEN {ENABLE UNWIND => Exec.ReleaseTTY[tty];      GetOldData[file];      GetNewData[file ! TTY.Rubout => CONTINUE];      Stream.Delete[file]};    Exec.ReleaseTTY[tty]};  -- main line code  Exec.AddCommand["Mileage.~"L, DoIt];  END.  
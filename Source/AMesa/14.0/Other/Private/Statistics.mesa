-- File: Statistics.mesa - last edit:-- bjd                  3-Mar-88 11:27:19-- JGS     	October 14, 1980  11:10 AM-- LXR     		5-Jan-82 14:32:24-- BTL  	       11-Feb-82 11:21:54-- RXR   	       24-Nov-82 13:37:33-- RSF             25-Aug-83 12:21:38-- RLC                  6-Feb-87 11:14:50   -- Copyright (C) 1982, 1983, 1988 by Xerox Corporation. All rights reserved. DIRECTORY  Ascii USING [CR, NUL, SP],  BcdDefs USING [BCD, Base, LFNull, MTIndex, MTRecord, VersionID],  Environment USING [bytesPerPage, bytesPerWord, PageCount, wordsPerPage],  Exec USING [    AddCommand, CheckForAbort, ExecProc, FreeTokenString, GetToken, Handle,     Outcome, OutputProc, PutChar],  Format USING [Char, CR, Date, Number, NumberFormat, StringProc],  Heap USING [systemZone],  MFile USING [Error, Handle, maxNameLength, ReadOnly, Release],  MSegment USING [Address, Create, Delete, Error, Handle, PagesForWords, Reset],  MStream USING [Error, SetLength, ReadOnly, WriteOnly],  Runtime USING [CallDebugger, GetBcdTime],  Stream USING [Delete, GetBlock, GetPosition, Handle, PutBlock],  String USING [AppendChar, AppendLongNumber, AppendString, EmptyString],  Time USING [Append, Current, Unpack],  Version USING [Append];Statistics: PROGRAM  IMPORTS     Exec, Format, Heap, MFile, MSegment, MStream, Runtime, Stream,    String, Time, Version =  BEGIN    WordType: TYPE = RECORD [seq: SEQUENCE l:CARDINAL OF WORD];    SP: CHARACTER = Ascii.SP;  CR: CHARACTER = Ascii.CR;  NUL: CHARACTER = Ascii.NUL;    z: UNCOUNTED ZONE = Heap.systemZone;     exec: Exec.Handle;  execProc: Format.StringProc;  outputFileName: LONG STRING ¬ [MFile.maxNameLength];  sourceExt: LONG STRING ¬ [MFile.maxNameLength];  outputFileInitialized: BOOLEAN ¬ FALSE;    bcdFile: MFile.Handle ¬ NIL;  bcdSeg: MSegment.Handle ¬ NIL;  sourceStream: Stream.Handle ¬ NIL;    buffer: LONG POINTER ¬ NIL;  BufPages: CARDINAL = 40;    StatType: TYPE = {    char, line, codebytes, framesize, nlinks, codepages, sympages};    stats: ARRAY StatType OF CARDINAL;  total, subtotal: ARRAY StatType OF LONG CARDINAL;    StatsDesired: TYPE = LONG POINTER TO ARRAY StatType OF BOOLEAN;  StatsWanted, localStatsWanted: ARRAY StatType OF BOOLEAN;    format: ARRAY StatType OF Format.NumberFormat = [    char:      [base: 10, zerofill: FALSE, unsigned: TRUE, columns: charField],    line:      [base: 10, zerofill: FALSE, unsigned: TRUE, columns: lineField],    codebytes: [base: 10, zerofill: FALSE, unsigned: TRUE, columns: codebyteField],    framesize: [base: 10, zerofill: FALSE, unsigned: TRUE, columns: framesizeField],    nlinks:    [base: 10, zerofill: FALSE, unsigned: TRUE, columns: nlinksField],    codepages: [base: 10, zerofill: FALSE, unsigned: TRUE, columns: codepageField],    sympages:  [base: 10, zerofill: FALSE, unsigned: TRUE, columns: sympageField] ];    charField, codebyteField: CARDINAL = 7;  nlinksField, lineField, framesizeField: CARDINAL = 6;  codepageField: CARDINAL = 5;  sympageField: CARDINAL = 4;  fsiField: CARDINAL = 4;  filenameField: CARDINAL = 26;      GetStatistics: Exec.ExecProc =    BEGIN    ENABLE UNWIND => Finalize[];    status: Exec.Outcome;    Initialize[h];    status ¬ ProcessCommands[! MStream.Error, MFile.Error => {      Exec.OutputProc[h]["Problems accessing a file. Aborting"L];      status ¬ error; CONTINUE}];    Finalize[];    RETURN[status];    END;      Initialize: PROC [h: Exec.Handle] =    BEGIN    exec ¬ h;    execProc ¬ Exec.OutputProc[h];    stats ¬ ALL[0];    total ¬ ALL[0];    subtotal ¬ ALL[0];    StatsWanted ¬ [      char: TRUE, line: TRUE,       codebytes: TRUE, framesize: TRUE, nlinks: TRUE,       codepages: TRUE, sympages: TRUE];    localStatsWanted ¬ [      char: TRUE, line: TRUE,       codebytes: TRUE, framesize: TRUE, nlinks: TRUE,       codepages: TRUE, sympages: TRUE];    PutHeadingToExecWindow[];    buffer ¬ z.NEW[WordType[BufPages * Environment.wordsPerPage]];    outputFileName.length ¬ 0;    String.AppendString[outputFileName, "Statistics.stats"L];    sourceExt.length ¬ 0;    String.AppendString[sourceExt, ".mesa"L];    outputFileInitialized ¬ FALSE;    END;    PutHeadingToExecWindow: PROC = {    herald: LONG STRING ¬ [80];    Exec.PutChar[exec, CR];    String.AppendString[herald, "Mesa Statistics Package "L];    Version.Append[herald];    String.AppendString[herald, " of "L];    Time.Append[herald, Time.Unpack[Runtime.GetBcdTime[]]];    herald.length ¬ herald.length - 3;    execProc[herald];  Exec.PutChar[exec, CR];    execProc["  Statistics as of "L];    herald.length ¬ 0;    Time.Append[herald, Time.Unpack[Time.Current[]]];    herald.length ¬ herald.length - 3;    execProc[herald];  Exec.PutChar[exec, CR];    Exec.PutChar[exec, CR]};    Finalize: PROC =    BEGIN    DestroyBcd[];    DestroySourceStream[];    IF buffer # NIL THEN {z.FREE[@buffer];  buffer ¬ NIL};    CloseOutputFile[];    END;      ProcessCommands: PROC RETURNS [Exec.Outcome] = {    name, switches: LONG STRING;    command: BOOLEAN;    i: CARDINAL;    lastActionWasTotal: BOOLEAN;  -- force total at end if not already requested    DO      IF Exec.CheckForAbort[exec] THEN RETURN[abort];      [name, switches] ¬ Exec.GetToken[exec];      IF String.EmptyString[name] THEN EXIT;      lastActionWasTotal ¬ FALSE;      localStatsWanted ¬ StatsWanted;      command ¬ FALSE;      IF ~String.EmptyString[switches] THEN {	i ¬ 0;	WHILE i < switches.length DO	  SELECT switches[i] FROM	    'e, 'E => {	      sourceExt.length ¬ 0;	      String.AppendChar[s: sourceExt, c: '.];	      String.AppendString[to: sourceExt, from: name];	      command ¬ TRUE};	    'o, 'O => {	      outputFileName.length ¬ 0;	      String.AppendString[to: outputFileName, from: name];	      IF outputFileInitialized THEN CloseOutputFile[];	      command ¬ TRUE};	    'm, 'M => SetSwitchesForSource[wanted: TRUE, st: @localStatsWanted];	    'b, 'B => SetSwitchesForBcd[wanted: TRUE, st: @localStatsWanted];	    'x, 'X => {	      SetSwitchesForBcd[wanted: FALSE, st: @localStatsWanted];	      SetManagerSwitches[wanted: TRUE, st: @localStatsWanted]};	    '-, '~ => {	      i ¬ i + 1;	      SELECT switches[i] FROM	        'b, 'B => SetSwitchesForBcd[wanted: FALSE, st: @localStatsWanted];	        'm, 'M => SetSwitchesForSource[		  wanted: FALSE, st: @localStatsWanted];	        'x, 'X => SetManagerSwitches[wanted: FALSE, st: @localStatsWanted];	        ENDCASE};	    'c, 'C => {	      command ¬ TRUE;	      SELECT name[0] FROM	        'b, 'B => SetSwitchesForBcd[wanted: TRUE, st: @StatsWanted];	        'd, 'D => Runtime.CallDebugger["Called from Statistics"L];                'h, 'H => OutputHeading[];      	        'm, 'M => SetSwitchesForSource[wanted: TRUE, st: @StatsWanted];      	        'x, 'X => {	          SetSwitchesForBcd[wanted: FALSE, st: @StatsWanted];      	          SetManagerSwitches[wanted: TRUE, st: @StatsWanted]};      	        't, 'T => {		  Total[name: "TOTAL:"L, subt: FALSE];		  lastActionWasTotal ¬ TRUE};      	        's, 'S => Total[name: "SUBTOTAL:"L, subt: TRUE];      	        '-, '~ =>      	          SELECT name[1] FROM      	            'b, 'B => SetSwitchesForBcd[wanted: FALSE, st: @StatsWanted];      	            'm, 'M => SetSwitchesForSource[		      wanted: FALSE, st: @StatsWanted];      	            'x, 'X => SetManagerSwitches[wanted: FALSE, st: @StatsWanted];      	            ENDCASE;      	        ENDCASE};            ENDCASE; -- on switch          i ¬ i + 1;          ENDLOOP};      IF ~command THEN {  -- a file to process	IF ~outputFileInitialized THEN InitializeOutputFile[];	StripExtension[name];	PutString[name];	THROUGH [name.length..filenameField) DO PutChar[SP] ENDLOOP;	RecordSrcStats[name 	  ! MStream.Error => { 	      SetSwitchesForSource[FALSE, @localStatsWanted];  CONTINUE}];	RecordBcdStats[name 	  ! MFile.Error, MSegment.Error => { 	      SetSwitchesForBcd[FALSE, @localStatsWanted];  CONTINUE}];	TallyStats[];	PrintStats[];	PutCR[]};      name ¬ Exec.FreeTokenString[name];      switches ¬ Exec.FreeTokenString[switches];      ENDLOOP;    IF ~lastActionWasTotal THEN Total[name: "TOTAL:"L, subt: FALSE];    RETURN[normal]};      StripExtension: PROC [name: LONG STRING] = {    FOR i: CARDINAL IN [0..name.length) DO      IF name[i] = '. THEN {name.length ¬ i;  RETURN};      ENDLOOP};      InitializeOutputFile: PROC = {    fullOutputName: LONG STRING ¬ [MFile.maxNameLength];    IF outputFileInitialized THEN CloseOutputFile[];    OpenOutput[name: outputFileName, ext: ".stats"L];    OutputHeading[];    String.AppendString[to: fullOutputName, from: outputFileName];    FOR i: CARDINAL IN [0..outputFileName.length) DO      IF outputFileName[i] = '. THEN {fullOutputName.length ¬ i;  EXIT};      ENDLOOP;    String.AppendString[to: fullOutputName, from: ".stats"L];    execProc["Statistics written to "L];    execProc[fullOutputName];  Exec.PutChar[exec, CR];    outputFileInitialized ¬ TRUE};      OutputHeading: PROC = {    type: StatType;    herald: LONG STRING ¬ [60];    header: ARRAY StatType OF LONG STRING =      ["  chars "L, "  lines "L, "  code  "L, "   frame "L, "nlinks "L,       " code    "L, "symbol"L];    header2: ARRAY StatType OF LONG STRING =      ["        "L, "        "L, "  bytes "L, "   size  "L, "       "L,       " pages   "L, "pages"L];    PutCR[];    String.AppendString[herald, "Mesa Statistics Package "L];    Version.Append[herald];    String.AppendString[herald, " of "L];    Time.Append[herald, Time.Unpack[Runtime.GetBcdTime[]]];    herald.length ¬ herald.length - 3;    PutString[herald];      PutCR[];    PutString["  Statistics as of "L];    herald.length ¬ 0;    Time.Append[herald, Time.Unpack[Time.Current[]]];    herald.length ¬ herald.length - 3;    PutString[herald];      PutCR[];    PutCR[];    THROUGH [0..filenameField) DO PutChar[SP] ENDLOOP;    FOR type IN StatType DO      IF localStatsWanted[type] THEN PutString[header[type]];       ENDLOOP;    PutCR[];    THROUGH [0..filenameField) DO PutChar[SP] ENDLOOP;    FOR type IN StatType DO      IF localStatsWanted[type] THEN PutString[header2[type]];       ENDLOOP;    PutCR[];    THROUGH [0..filenameField) DO PutChar[SP] ENDLOOP;    WriteDashes[]};      WriteDashes: PROC = {    FOR type: StatType IN StatType DO      IF localStatsWanted[type] THEN	BEGIN	IF type = LAST[StatType] THEN PutChar[SP];	THROUGH [0..format[type].columns) DO PutChar['-] ENDLOOP;	PutString["  "L];	END;      ENDLOOP;    PutCR[];  PutCR[]};      CloseOutputFile: PROC = {    CloseOutput[];    outputFileInitialized ¬ FALSE};       SetSwitchesForSource: PROC [wanted: BOOLEAN, st: StatsDesired] = {    st[char] ¬ wanted;  st[line] ¬ wanted};      SetSwitchesForBcd: PROC [wanted: BOOLEAN, st: StatsDesired] = {    st[codebytes] ¬ wanted;    st[framesize] ¬ wanted;    st[nlinks] ¬ wanted;    st[codepages] ¬ wanted;    st[sympages] ¬ wanted};      SetManagerSwitches: PROC [wanted: BOOLEAN, st: StatsDesired] = {    st[char] ¬ wanted;    st[line] ¬ wanted;    st[codebytes] ¬ wanted;    st[framesize] ¬ wanted};      SetDefsStatsAndSwitches: PROC = {    localStatsWanted[codebytes] ¬ FALSE;    localStatsWanted[framesize] ¬ FALSE;    localStatsWanted[nlinks] ¬ FALSE;    localStatsWanted[codepages] ¬ FALSE;    stats[nlinks] ¬ 0;    stats[framesize] ¬ 0;    stats[codepages] ¬ 0;    stats[codebytes] ¬ 0};      RecordSrcStats: PROC [name: LONG STRING] = {    ENABLE UNWIND => DestroySourceStream[];    sourceName: LONG STRING ¬ [MFile.maxNameLength];    IF localStatsWanted[char] OR localStatsWanted[line] THEN {      sourceStream ¬ NIL;      String.AppendString[to: sourceName, from: name];      OptionallyAddExtension[name: sourceName, ext: sourceExt];      sourceStream ¬ MStream.ReadOnly[sourceName, []];      GetSrcStats[sourceStream];      DestroySourceStream[]}};      DestroySourceStream: PROC = {    IF sourceStream # NIL THEN {Stream.Delete[sourceStream]; sourceStream ¬ NIL}};      OptionallyAddExtension: PROC [name, ext: LONG STRING] = {    FOR i: CARDINAL IN [0..name.length) DO       IF name[i] = '. THEN RETURN;       ENDLOOP;    String.AppendString[name, ext]};      GetSrcStats: PROC [stream: Stream.Handle] =    BEGIN    bytes: CARDINAL;    nc, nl: CARDINAL ¬ 0;    crock: LONG POINTER TO PACKED ARRAY OF CHARACTER = buffer;    [bytesTransferred: bytes] ¬ Stream.GetBlock[      stream, [buffer, 0, (BufPages * Environment.bytesPerPage)]];    UNTIL bytes = 0 DO      FOR i: CARDINAL IN [0..bytes) DO	nc ¬ nc + 1; 	IF crock[i] = CR THEN nl ¬ nl + 1; 	ENDLOOP;        [bytesTransferred: bytes] ¬ Stream.GetBlock[	  stream, [buffer, 0, (BufPages * Environment.bytesPerPage)]];      ENDLOOP;    stats[char] ¬ nc;  stats[line] ¬ nl;    END;      RecordBcdStats: PROC [name: LONG STRING] = {    ENABLE UNWIND => DestroyBcd[];    bcdName: LONG STRING ¬ [MFile.maxNameLength];    any: BOOLEAN ¬ FALSE;    FOR type: StatType IN [codebytes..sympages] DO      any ¬ (any OR localStatsWanted[type]);       ENDLOOP;    IF any THEN {      bcdFile ¬ NIL;  bcdSeg ¬ NIL;      String.AppendString[to: bcdName, from: name];      OptionallyAddExtension[name: bcdName, ext: ".bcd"];      bcdFile ¬ MFile.ReadOnly[name: bcdName, release: []];      GetModule[bcdFile];      IF bcdSeg # NIL THEN {GetBcdStats[];  DestroyBcd[]}      ELSE SetSwitchesForBcd[FALSE, @localStatsWanted]}};        DestroyBcd: PROC = {    IF bcdSeg # NIL THEN {MSegment.Delete[bcdSeg];  bcdSeg ¬ NIL}};        GetModule: PROC [bcdFile: MFile.Handle] = {    bcd: LONG POINTER TO BcdDefs.BCD;    pages: Environment.PageCount;    bcdSeg ¬ MSegment.Create[      file: bcdFile, release: [], fileBase: 0, pages: 10      ! MSegment.Error => {MFile.Release[bcdFile];  bcdFile ¬ NIL;  GOTO NoFile}];    bcd ¬ MSegment.Address[bcdSeg];    IF bcd.versionIdent # BcdDefs.VersionID THEN {      PutString["  bad version ID "L];      PutNumber[        n: bcd.versionIdent, 	f: [base: 10, zerofill: FALSE, unsigned: TRUE, columns: 0]];      DestroyBcd[];      RETURN};    IF (pages ¬ bcd.nPages) > 10 THEN {      MSegment.Reset[        segment: bcdSeg, pages: pages ! MSegment.Error => GOTO NoFile];      bcd ¬ MSegment.Address[bcdSeg]};    IF bcd.nConfigs # 0 THEN {      PutString["  not Compiler created: "L];      PutNumber[        n: bcd.nConfigs, 	f: [base: 10, zerofill: FALSE, unsigned: TRUE, columns: 0]];      PutString["  configs"L];  PutCR[];      DestroyBcd[];      RETURN};    EXITS NoFile => DestroyBcd[]};      GetBcdStats: PROC = {    bcd: LONG POINTER TO BcdDefs.BCD;    mth: LONG POINTER TO BcdDefs.MTRecord;    sgb, lfb: BcdDefs.Base;    bcd ¬ MSegment.Address[bcdSeg];    mth ¬ @LOOPHOLE[bcd + bcd.mtOffset, BcdDefs.Base][FIRST[BcdDefs.MTIndex]];    sgb ¬ LOOPHOLE[bcd + bcd.sgOffset];    lfb ¬ LOOPHOLE[bcd + bcd.lfOffset];    IF bcd.definitions THEN SetDefsStatsAndSwitches[]    ELSE {      stats[nlinks] ¬          (IF mth.links = BcdDefs.LFNull THEN 0 ELSE lfb[mth.links].length);      stats[framesize] ¬ mth.framesize;      stats[codepages] ¬ sgb[mth.code.sgi].pages;      stats[codebytes] ¬ mth.code.length};    stats[sympages] ¬ sgb[mth.sseg].pages};      TallyStats: PROC =    BEGIN    FOR type: StatType IN StatType DO      IF localStatsWanted[type] THEN        subtotal[type] ¬ (subtotal[type] + stats[type]);      ENDLOOP;    END;      PrintStats: PROC =    BEGIN    FOR type: StatType IN StatType DO      IF localStatsWanted[type] THEN	BEGIN	PutNumber[n: stats[type], f: format[type]];	IF type = codepages THEN	  BEGIN	  bytes: CARDINAL ¬ stats[codebytes] + stats[nlinks]*2;	  bytes ¬ (IF stats[nlinks] MOD 2 = 0 THEN 4 ELSE 2) + bytes;	  IF MSegment.PagesForWords[bytes/Environment.bytesPerWord] # stats[codepages] THEN 	    PutChar['*]	  ELSE PutChar[SP];	  END;	IF type # LAST[StatType] THEN PutString["  "L];	END      ELSE	BEGIN	IF type = codepages THEN PutChar[SP];	FOR i: CARDINAL IN [0..format[type].columns) DO PutChar[SP] ENDLOOP;	IF type # LAST[StatType] THEN PutString["  "L];	END      ENDLOOP;    END;      Total: PROC [name: LONG STRING, subt: BOOLEAN] =    BEGIN    THROUGH [0..filenameField) DO PutChar[SP] ENDLOOP;    WriteDashes[];    PutString[name];    THROUGH [name.length..filenameField) DO PutChar[SP] ENDLOOP;    FOR type: StatType IN StatType DO      IF localStatsWanted[type] THEN	BEGIN	WriteDouble[	  num: IF subt THEN subtotal[type] ELSE subtotal[type] + total[type], 	  format: format[type]];	IF type = codepages THEN PutChar[SP];	IF type # LAST[StatType] THEN PutString["  "L];	END;      ENDLOOP;    PutCR[];    PutCR[];    IF subt THEN       FOR type: StatType IN StatType DO        total[type] ¬ (total[type] + subtotal[type]);	ENDLOOP    ELSE total ¬ [0, 0, 0, 0, 0, 0, 0];    subtotal ¬ [0, 0, 0, 0, 0, 0, 0];    END;      WriteDouble: PROC [num: LONG INTEGER, format: Format.NumberFormat] =    BEGIN    temp: LONG STRING ¬ [20];    String.AppendLongNumber[temp, num, 10];    IF temp.length > format.columns THEN      FOR i: CARDINAL IN [0..format.columns) DO PutChar['*] ENDLOOP    ELSE      BEGIN      FOR i: CARDINAL IN [temp.length..format.columns) DO         PutChar[SP]; 	ENDLOOP;      PutString[temp];      END;    END; -- Output routines      out: Stream.Handle ¬ NIL;  OpenOutput: PROC [name, ext: LONG STRING] = {    sname: LONG STRING ¬ [MFile.maxNameLength];    String.AppendString[sname, name];    FOR i: CARDINAL IN [0..sname.length) DO      IF name[i] = '. THEN {sname.length ¬ i;  EXIT};       ENDLOOP;    String.AppendString[sname, ext];    out ¬ MStream.WriteOnly[sname, [], text]};    CloseOutput: PROC = {    IF out # NIL THEN {      MStream.SetLength[out, Stream.GetPosition[out]];      Stream.Delete[out];  out ¬ NIL}};  Put: PUBLIC Format.StringProc =  {    [] ¬ Stream.PutBlock[out, [LOOPHOLE[@s.text], 0, s.length]]};  PutString: PROC [s: LONG STRING] = {Put[s]};  PutChar: PROC [c: CHARACTER] = {Format.Char[Put, c]};  PutCR: PROC = {Format.CR[Put]};  PutTime: PROC [t: LONG CARDINAL] = {Format.Date[Put, [LOOPHOLE[t]], full]};  PutOctal: PROC [o: UNSPECIFIED] = {Format.Number[Put, o, [8, FALSE, FALSE, 1]]};  PutNumber: PROC [n: CARDINAL, f: Format.NumberFormat] = {    Format.Number[Put, n, f]};         -- Register Statistics      Init: PROC = {Exec.AddCommand[name: "Statistics.~", proc: GetStatistics]};      Init[];    END. 6-Feb-87 11:14:50 - rlc - mds relief changes: STRING ¬ LONG STRING, POINTER ¬ LONG POINTER
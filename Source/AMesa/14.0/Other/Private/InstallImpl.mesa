-- File: InstallImpl.mesa - last edit:-- AOF                 24-May-87 15:51:47-- NS                  18-Jan-85 17:18:54-- JGS    .pa           8-Jan-85 14:24:42-- NS                  28-Jul-86 14:36:08-- NS                  13-Feb-85 13:05:35-- DSC                 18-Apr-85 10:42:50-- Copyright (C) 1985, 1987 by Xerox Corporation. All rights reserved.DIRECTORY  Cursor USING [Object, Type, UniqueType],  Environment: TYPE USING [bytesPerPage, PageCount, PageNumber, PageOffset],  Exec: TYPE USING [    AddCommand, CheckForAbort, Confirm, EndOfCommandLine, ExecProc,    FreeTokenString, GetNameandPassword, GetToken, Handle, Outcome, OutputProc],  File: TYPE USING [    Create, Delete, File, MakePermanent, nullFile, PageCount, PageNumber,    SetSize, Type, Unknown],  FileName: TYPE USING [AllocVFN, Error, FreeVFN, NormalizeVFN, VFN],  FileTransfer: TYPE USING [    ClientProc, Connection, Create, Destroy, Error, GetStreamInfo, MessageProc,    ReadStream, SetPrimaryCredentials, SetProcs],  FileTypes: TYPE USING [tUntypedFile],  Format: TYPE USING [Line, StringProc],  Heap: TYPE USING [systemZone],  HeraldWindow USING [FreeCursorSlot, GetCursorSlot,SetCursorState, StoreCursor, Slot],  OthelloDefs: TYPE USING [    LeaderPage, leaderPages, lpNoteLength, lpVersion],  OthelloOps: TYPE USING [BadSwitches,    BootFileType, DecodeSwitches, GetVolumeBootFile, MakeBootable,    MakeUnbootable, SetSwitches, SetPhysicalVolumeBootFile, SetVolumeBootFile],  PrincOps: TYPE USING [Port],  Space: TYPE USING [CopyOut, Interval, Map, PageCount, PageOffset, Unmap],  SpecialVolume: TYPE USING [OpenVolume],  Stream: TYPE USING [Delete, GetBlock, Handle],  String: TYPE USING [    AppendCharAndGrow, AppendString, AppendStringAndGrow, CopyToNewString,    Empty, EqualString, EquivalentString, StringBoundsFault],  System: TYPE USING [defaultSwitches, Switches, UpDown],  TemporaryBooting: TYPE USING [InvalidParameters],  Time: TYPE USING [Append, Unpack],  Volume: TYPE USING [    Close, GetLabelString, GetNext, GetStatus, GetType, ID, InsufficientSpace,    maxNameLength, NeedsScavenging, nullID, Status, systemID, Type, TypeSet];InstallImpl: MONITOR  IMPORTS    Cursor, Exec, File, FileName, FileTransfer, Format, Heap, HeraldWindow,     OthelloOps, Space, SpecialVolume, Stream, String, Time,     TemporaryBooting, Volume =  BEGIN    myCursorType: Cursor.Type ¬ Cursor.UniqueType[];  cursor: Cursor.Object ¬ [info:[myCursorType, 8, 8],    array: [177400B, 125252B, 177400B, 125252B, 177400B, 125252B, 177400B, 125252B, 052525B, 000377B, 052525B, 000377B, 052525B, 000377B, 052525B, 000377B]];    slot: HeraldWindow.Slot;    volumeName: STRING = [Volume.maxNameLength];  volume: Volume.ID ¬ Volume.nullID;  volumeOpened: BOOLEAN ¬ FALSE;  originalVolumeStatus: Volume.Status ¬ unknown;  write: Format.StringProc ¬ NIL;  exec: Exec.Handle ¬ NIL;  InstallFiles: ENTRY Exec.ExecProc = {    ENABLE UNWIND => {volumeOpened ¬ FALSE};    token, switches: LONG STRING ¬ NIL;    type: OthelloOps.BootFileType ¬ pilot;    haveOne: BOOLEAN ¬ FALSE;    confirm: BOOLEAN ¬ FALSE;    FreeTokens: PROCEDURE = {      [] ¬ Exec.FreeTokenString[token]; [] ¬ Exec.FreeTokenString[switches]};    exec ¬ h;    write ¬ h.OutputProc[];    [] ¬ SetVolumeName["Extra"L];    UNTIL h.EndOfCommandLine[] DO  -- parse command line      ENABLE UNWIND => FreeTokens[];      confirm ¬ FALSE;      [token, switches] ¬ h.GetToken[];      SELECT TRUE FROM        String.Empty[token] AND String.Empty[switches] => {          outcome ¬ IF haveOne THEN error ELSE InstallHelp[h]; EXIT};        String.Empty[token] => {          sw: System.Switches = OthelloOps.DecodeSwitches[switches];	  SELECT System.UpDown.down FROM 	    sw['b], sw['B] => type ¬ pilot;	    sw['g], sw['G] => type ¬ germ;	    sw['m], sw['M] => type ¬ softMicrocode;	    ENDCASE => confirm ¬ TRUE;	  FreeTokens[];	  LOOP};        ENDCASE;      IF ~SetVolumeName[token] THEN {        write["Error: volume "L];        write[token];        write[" not found!"L];        outcome ¬ error;        EXIT};      FreeTokens[];      [token, switches] ¬ h.GetToken[];      IF ~String.Empty[switches] OR ~(String.EqualString[token, "¬"L] OR String.EqualString[token, "¬"L]) THEN confirm ¬ TRUE      ELSE {FreeTokens[]; [token, switches] ¬ h.GetToken[]};      IF h.CheckForAbort[] THEN {outcome ¬ abort; EXIT};      IF ~String.Empty[token] THEN {        IF confirm THEN {	  write["Installing "L];	  write[SELECT type FROM	    germ => "germ"L, pilot => "boot", ENDCASE => "microcode"L];	  write[" file "L];	  write[token];	  write[" on volume "L];	  write[volumeName];	  write["  "L];	  IF ~h.Confirm[] THEN {outcome ¬ abort; EXIT}};        outcome ¬ InstallFileOnVolume[token, switches, type !	    UNWIND => CloseVolume[]]};      haveOne ¬ TRUE;      REPEAT	FINISHED => IF ~haveOne THEN outcome ¬ InstallHelp[h];      ENDLOOP;    FreeTokens[]};  SetVolumeName: PROCEDURE [v: LONG STRING] RETURNS [ok: BOOLEAN ¬ TRUE] = {    CloseVolume[];    volumeName.length ¬ 0;    String.AppendString[      volumeName, v !      String.StringBoundsFault => {        write["Volume name too long!"L]; ok ¬ FALSE; CONTINUE}]};  OpenVolume: PROCEDURE RETURNS [BOOLEAN] = {    OPEN Volume;    myType: Volume.Type = Volume.GetType[Volume.systemID];    all: TypeSet ¬ [      normal: TRUE, debugger: myType = debugger OR myType = debuggerDebugger,      debuggerDebugger: myType = debuggerDebugger];    name: STRING = [maxNameLength];    IF ~volumeOpened THEN {      FOR volume ¬ GetNext[nullID, all], GetNext[volume, all] UNTIL volume =        nullID DO        name.length ¬ 0;        GetLabelString[volume, name];        IF String.EquivalentString[name, volumeName] THEN EXIT;        ENDLOOP;      SELECT volume FROM        nullID => {          write[volumeName]; Format.Line[write, " not found!"L]; RETURN[FALSE]};        Volume.systemID => {          write[volumeName];          Format.Line[write, " is your system volume!"L];          RETURN[FALSE]};        ENDCASE;      SELECT (originalVolumeStatus ¬ Volume.GetStatus[volume]) FROM        openRead => Volume.Close[volume];        openReadWrite => RETURN[TRUE];        unknown, partiallyOnLine, closedAndInconsistent => RETURN[FALSE];        ENDCASE => NULL;      SpecialVolume.OpenVolume[volume: volume, access: readWrite        ! Volume.NeedsScavenging => GOTO YouLose];      volumeOpened ¬ TRUE};    RETURN[TRUE];    EXITS YouLose => {      write[volumeName];      Format.Line[write, " needs scavenging."L];      RETURN[FALSE]}};  CloseVolume: PROC = {    IF volumeOpened THEN {      Volume.Close[volume];      IF originalVolumeStatus = openRead THEN        SpecialVolume.OpenVolume[volume: volume, access: read];      volumeOpened ¬ FALSE}};  PortRep: TYPE = PrincOps.Port;  InstallFileOnVolume: PROC [      name, switches: LONG STRING, type: OthelloOps.BootFileType]    RETURNS [outcome: Exec.Outcome ¬ normal] = { -- from OthelloFTP (sort of)    created: BOOLEAN ¬ FALSE;    file: File.File;    firstPage: File.PageNumber;    -- clean the PORT up from last time    LOOPHOLE[GetFile, PortRep].in ¬ 0;    -- CONNECT GetFile.out TO Retrieve;    LOOPHOLE[GetFile, PortRep].out ¬ LOOPHOLE[Retrieve];    write["Opening "];    write[volumeName];    write["... "L];    IF ~OpenVolume[] THEN RETURN[error] ELSE Format.Line[write, " open."L];    [file, firstPage] ¬ OthelloOps.GetVolumeBootFile[volume, type];    IF NOT GetFile[name: name] THEN {CloseVolume[]; RETURN[error]};    IF (created ¬ file = File.nullFile) THEN      file ¬ File.Create[volume, 1, FileTypes.tUntypedFile]    ELSE      OthelloOps.MakeUnbootable[        file, type, firstPage !	File.Unknown => CONTINUE;        TemporaryBooting.InvalidParameters => {	  outcome ¬ warning;          write["Warning: trouble making unbootable"L]; CONTINUE}];    slot ¬ HeraldWindow.GetCursorSlot[];    HeraldWindow.StoreCursor[slot, @cursor.array];        write[" Fetching... "L];    IF NOT GetFile[      file: file ! UNWIND => {IF created THEN file.Delete; CloseVolume[]}]      THEN {IF created THEN file.Delete; CloseVolume[]; RETURN[error]};    write["Installing "L];    write[SELECT type FROM      germ => "germ"L, pilot => "boot", ENDCASE => "microcode"L];    write[" file..."L];    file.MakePermanent;    OthelloOps.MakeBootable[      file, type, OthelloDefs.leaderPages !      TemporaryBooting.InvalidParameters => {	outcome ¬ warning;        write["Warning: trouble making bootable"L]; CONTINUE}];    OthelloOps.SetVolumeBootFile[file, type, OthelloDefs.leaderPages];    Format.Line[write, " installed."L];    [] ¬ HeraldWindow.FreeCursorSlot[slot];    IF type # pilot THEN {      write["Making Physical Volume boot..."L];      OthelloOps.SetPhysicalVolumeBootFile[file, type, OthelloDefs.leaderPages]};    IF NOT String.Empty[switches] THEN      SetDefaultSwitches[file, OthelloDefs.leaderPages, switches];    CloseVolume[]};  GetFile: PORT [    file: File.File ¬ File.nullFile, name: LONG STRING ¬ NIL]    RETURNS [BOOLEAN];  Retrieve: PROC [file: File.File, name: LONG STRING]    RETURNS [gotIt: BOOLEAN ¬ TRUE] =     BEGIN     bufferPages: Space.PageCount = 64;    bufferBytes: CARDINAL = CARDINAL[bufferPages*Environment.bytesPerPage];    buffer: LONG POINTER ¬ NIL;    vfn: FileName.VFN ¬ NIL;    conn: FileTransfer.Connection ¬ NIL;    readStream: Stream.Handle ¬ NIL;    fileSize: File.PageCount;     ResumeSetup: PORT [BOOLEAN]      RETURNS [file: File.File, name: LONG STRING];    Message: FileTransfer.MessageProc = {     write[s1]; write[s2]; write[s3]; write[s4]};    Cleanup: PROC = {     IF readStream # NIL THEN {readStream.Delete; readStream ¬ NIL};     IF buffer # NIL THEN buffer ¬ Space.Unmap[buffer];     IF vfn # NIL THEN {FileName.FreeVFN[vfn]; vfn ¬ NIL};     IF conn # NIL THEN {conn.Destroy; conn ¬ NIL}};    Twiddles: PROC = {                    HeraldWindow.SetCursorState[slot,invert];               };     BEGIN       ENABLE {    FileTransfer.Error => {     write ["File transfer error... "L];     Cleanup[];     ERROR ABORTED;     };    FileName.Error => {     write ["File name error..."L];     Cleanup[];     ERROR ABORTED;     };    Volume.InsufficientSpace => {     write["Not enough room for file!"L];     Cleanup[];     ERROR ABORTED;     }};             LoginUser: FileTransfer.ClientProc = {     user: STRING = [64];     password: STRING = [64];     exec.GetNameandPassword[user, password];     conn.SetPrimaryCredentials[user: user, password: password]};                   conn ¬ FileTransfer.Create[];    -- CONNECT ResumeSetup.out TO GetFile    LOOPHOLE[ResumeSetup, PortRep].out ¬ @GetFile;    -- CONNECT GetFile.out TO ResumeSetup    LOOPHOLE[GetFile, PortRep].out ¬ @ResumeSetup;    conn.SetProcs[clientData: NIL, messages: Message, login: LoginUser];         vfn ¬ FileName.AllocVFN[name];    readStream ¬ conn.ReadStream[files: vfn];     file ¬ ResumeSetup[gotIt].file;    fileSize ¬      (FileTransfer.GetStreamInfo[readStream].size + Environment.bytesPerPage -         1)/Environment.bytesPerPage + OthelloDefs.leaderPages;    file.SetSize[fileSize];    buffer ¬ Space.Map[      window: [file: File.nullFile, base: NULL, count: bufferPages],       class: data, swapUnits: [uniform[4]]].pointer;    SetLeaderPage[file, readStream, vfn];    FOR windowPage: Space.PageOffset ¬ OthelloDefs.leaderPages,      windowPage + bufferPages WHILE windowPage < fileSize DO      bytesTransferred: CARDINAL ¬ readStream.GetBlock[        [buffer, 0, bufferBytes]].bytesTransferred;      Twiddles[];      [] ¬ Space.CopyOut[buffer, [file, windowPage, bufferPages]];      ENDLOOP;    Cleanup[];    RETURN[TRUE];    END; -- ENABLE   END;   SetLeaderPage: PROC [    file: File.File, stream: Stream.Handle, vfn: FileName.VFN] = {    lp: LONG POINTER TO OthelloDefs.LeaderPage = Space.Map[      [file, 0, OthelloDefs.leaderPages]].pointer;    note: LONG STRING ¬ Heap.systemZone.NEW[StringBody[60]];    -- STARTKLUDGE: work around the FileTransfer not giving the host name    <<String.AppendStringAndGrow[      @note, FileTransfer.GetStreamName[stream], Heap.systemZone];>>    vfn.NormalizeVFN;    IF NOT String.Empty[vfn.host] THEN {      String.AppendStringAndGrow[@note, "["L, Heap.systemZone];      String.AppendStringAndGrow[@note, vfn.host, Heap.systemZone];      String.AppendStringAndGrow[@note, "]"L, Heap.systemZone]};    IF NOT String.Empty[vfn.directory] THEN {      String.AppendStringAndGrow[@note, vfn.directory, Heap.systemZone];      String.AppendStringAndGrow[@note, ">"L, Heap.systemZone]};    IF NOT String.Empty[vfn.name] THEN      String.AppendStringAndGrow[@note, vfn.name, Heap.systemZone];    IF NOT String.Empty[vfn.version] THEN {      String.AppendStringAndGrow[@note, "!"L, Heap.systemZone];      String.AppendStringAndGrow[@note, vfn.version, Heap.systemZone]};    -- ENDKLUDGE    String.AppendStringAndGrow[@note, " ("L, Heap.systemZone];    -- STARTKLUDGE: Time.Append screws up on StringBoundsFault    {oldLength: CARDINAL = note.length;    Time.Append[      s: note, zone: TRUE,      unpacked: Time.Unpack[FileTransfer.GetStreamInfo[stream].create] !      String.StringBoundsFault => {        ns ¬ String.CopyToNewString[	  s: note, z: Heap.systemZone, longer: s.maxlength - s.length + 20];	Heap.systemZone.FREE[@note];	note ¬ ns;	note.length ¬ oldLength;        RETRY}];    };-- ENDKLUDGE    String.AppendCharAndGrow[@note, '), Heap.systemZone];    lp.version ¬ OthelloDefs.lpVersion;    lp.length ¬ MIN[note.length, OthelloDefs.lpNoteLength];    FOR i: CARDINAL IN [0..lp.length) DO      lp.note[i] ¬ note[i];      ENDLOOP;    [] ¬ Space.Unmap[lp];    Heap.systemZone.FREE[@note]};      SetDefaultSwitches: PROC [    file: File.File, firstPage: File.PageNumber,    switchString: LONG STRING] = {    switches: System.Switches ¬ System.defaultSwitches;    decodesuccess: BOOLEAN ¬ TRUE;    write["Setting default boot switches to "L];    write[switchString];    write[" ... "L];    switches ¬ OthelloOps.DecodeSwitches[switchString ! OthelloOps.BadSwitches =>  {Format.Line[write, "bad switches"L]; decodesuccess ¬ FALSE; CONTINUE}];    IF decodesuccess THEN {      IF OthelloOps.SetSwitches[file, firstPage, switches] # success       THEN	Format.Line[write, "failed"L]      ELSE         Format.Line[write, "set."L];    }};  InstallHelp: Exec.ExecProc = {    Format.Line[      h.OutputProc[],      "Command format: Install.~ volume ¬ bootFile/bootSwitches"L]};  {Exec.AddCommand["Install.~"L, InstallFiles, InstallHelp]};  END.    -- log  -- NSG      18-Jan-85 17:19:06 merged Install2 with Install  -- NSG      13-Feb-85 13:05:53 added code to twiddle cursor to mark progress  -- DSC      18-Apr-85 10:30:22 Made DecodeSwitches catch BadSwitches.
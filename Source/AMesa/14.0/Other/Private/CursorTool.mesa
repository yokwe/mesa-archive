-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- CursorTool.mesa, Edited by-- Sweet	19-Jan-82 16:17:14-- Daniels	14-Dec-82 15:49:05-- Loretta	20-Apr-83 11:36:05DIRECTORY  Atom USING [ATOM, MakeAtom],  Cursor USING [GetInfo, Handle, Object, Set, Store, Type, UniqueType],  Display USING [Black, Bitmap, replaceFlags, White],  Format USING [NumberFormat],  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, CommandItem, ItemDescriptor,     ItemHandle, newLine, ProcType],  Heap USING [systemZone, systemMDSZone],  Inline USING [BITAND],  MsgSW USING [Clear, Post],  Put USING [Char, Number, Text],  Selection USING [Convert, Source],  String USING [AppendChar, InvalidNumber, StringBoundsFault, StringToDecimal],  TIP USING [    CreateClient, CreateTable, First, InvalidTable, NotifyProc, Rest, Results,    Table],  Tool USING [AddThisSW, Create, MakeFileSW, MakeFormSW, MakeMsgSW, MakeSWsProc],  ToolWindow USING [Box, CreateSubwindow],  Window USING [    Box, EnumerateInvalidBoxes, Handle, InvalidateBox, Place, nullBox, Validate];  CursorTool: PROGRAM   IMPORTS    Atom, Cursor, Display, FormSW, Heap, Inline, MsgSW, Put, Selection, String, TIP, Tool, ToolWindow, Window =  BEGIN  toolwindow: Window.Handle;  msgSW, formSW, logSW, graphicSW: Window.Handle;    CursorSize: CARDINAL = 16;  SquareSize: CARDINAL = 12;  BorderSize: CARDINAL = 8;  nCards: CARDINAL = CursorSize*CursorSize/16;  CardArray: TYPE = ARRAY [0..nCards) OF CARDINAL;  cursorCard: POINTER TO CardArray =    Heap.systemMDSZone.NEW[CardArray ¬ ALL[0]];  newCursorBits: POINTER TO ARRAY [0..CursorSize) OF    PACKED ARRAY [0..CursorSize) OF BOOLEAN = LOOPHOLE[cursorCard];      startPlace: Window.Place ¬ [0, 0];  whiteCursorBox: Window.Box ¬ [    startPlace,     [w: CursorSize+2*BorderSize, h: CursorSize+2*BorderSize]];  blackCursorBox: Window.Box ¬ [    [x: whiteCursorBox.place.x + whiteCursorBox.dims.w + BorderSize,     y: whiteCursorBox.place.y],     [w: CursorSize+2*BorderSize, h: CursorSize+2*BorderSize]];  gridBox: Window.Box ¬ [    [x: whiteCursorBox.place.x + BorderSize,      y: whiteCursorBox.place.y + whiteCursorBox.dims.h + BorderSize],    [w: CursorSize*SquareSize + 1, h: CursorSize*SquareSize + 1]];  graphicBox: Window.Box ¬ [    startPlace,    [w: 2*BorderSize + CursorSize * SquareSize,     h: 4*BorderSize + CursorSize + CursorSize * SquareSize]];  Intersect: PROC [b1, b2: LONG POINTER TO Window.Box]     RETURNS [box: Window.Box] = {    corner: Window.Place;    box.place.x ¬ MAX[b1.place.x, b2.place.x];    box.place.y ¬ MAX[b1.place.y, b2.place.y];    corner.x ¬ MIN[b1.place.x + b1.dims.w, b2.place.x + b2.dims.w];    corner.y ¬ MIN[b1.place.y + b1.dims.h, b2.place.y + b2.dims.h];    IF corner.x <= box.place.x OR corner.y <= box.place.y THEN      RETURN[Window.nullBox];    box.dims ¬ [w: corner.x - box.place.x+1, h: corner.y - box.place.y+1]};  SquarePlace: PROC [r, c: CARDINAL] RETURNS [Window.Place] = {    RETURN[      [x: gridBox.place.x + c*SquareSize,       y: gridBox.place.y + r*SquareSize]]};  ColorProc: TYPE = PROC [Window.Handle, Window.Box];  CProc: PROC [val: BOOLEAN] RETURNS [ColorProc] = INLINE {    RETURN[IF val THEN Display.Black ELSE Display.White]};  RepaintSquare: PROC [i, j: CARDINAL, val: BOOLEAN] = {    paint: ColorProc = CProc[val];    place: Window.Place ¬ SquarePlace[i, j];    place.x ¬ place.x + 1; place.y ¬ place.y + 1;    paint[graphicSW, [place, [SquareSize - 1, SquareSize - 1]]]};  RepaintGridBox: PROC [box: Window.Box] = {    firsti, firstj, lasti, lastj: CARDINAL;    firsti ¬ (box.place.y - gridBox.place.y)/SquareSize;    firstj ¬ (box.place.x - gridBox.place.x)/SquareSize;    lasti ¬ (box.place.y - gridBox.place.y + box.dims.h)/SquareSize + 1;    lastj ¬ (box.place.x - gridBox.place.x + box.dims.w)/SquareSize + 1;    FOR i: CARDINAL IN [firsti..MIN[CursorSize, lasti]] DO      Display.Black[        window: graphicSW,        box: [          place: SquarePlace[i, firstj],          dims: [w: (MIN[CursorSize, lastj] - firstj)*SquareSize + 1, h: 1]]];      ENDLOOP;    FOR j: CARDINAL IN [firstj..MIN[CursorSize, lastj]] DO      Display.Black[        window: graphicSW,        box: [          place: SquarePlace[firsti, j],          dims: [w: 1, h: (MIN[CursorSize, lasti] - firsti)*SquareSize + 1]]];      ENDLOOP;    FOR i: CARDINAL IN [firsti..MIN[CursorSize-1, lasti]] DO      FOR j: CARDINAL IN [firstj..MIN[CursorSize-1, lastj]] DO	RepaintSquare[i, j, newCursorBits[i][j]];	ENDLOOP;      ENDLOOP};  RepaintBlackCursor: PROC = {    Display.White[graphicSW, blackCursorBox];    Display.Bitmap[      window: graphicSW,      box: [	place: [x: blackCursorBox.place.x + BorderSize,	 y: blackCursorBox.place.y + BorderSize],	dims: [w: CursorSize, h: CursorSize]],      address: [word: newCursorBits, bit: 0],      bitmapBitWidth: CursorSize,      flags: Display.replaceFlags]};  RepaintWhiteCursor: PROC = {    Display.Black[graphicSW, whiteCursorBox];    Display.Bitmap[      window: graphicSW,      box: [	place: [x: whiteCursorBox.place.x + BorderSize,	 y: whiteCursorBox.place.y + BorderSize],	dims: [w: CursorSize, h: CursorSize]],      address: [word: newCursorBits, bit: 0],      bitmapBitWidth: CursorSize,      flags: [        direction: forward, disjoint: TRUE, disjointItems: TRUE, gray: FALSE,        srcFunc: complement, dstFunc: null]]};  SetBit: PROC [i, j: CARDINAL, val: BOOLEAN] = INLINE {    IF newCursorBits[i][j] # val THEN SetABit[i, j, val]};  SetABit: PROC [i, j: CARDINAL, val: BOOLEAN] = {    turnOn: ColorProc = CProc[val];    turnOff: ColorProc = CProc[~val];    RepaintSquare[i, j, val];    turnOn[graphicSW, [      [x: blackCursorBox.place.x + BorderSize + j,       y: blackCursorBox.place.y + BorderSize + i],      [1, 1]]];    turnOff[graphicSW, [      [x: whiteCursorBox.place.x + BorderSize + j,       y: whiteCursorBox.place.y + BorderSize + i],      [1, 1]]];    newCursorBits[i][j] ¬ val};  Init: PROC = {    OPEN Atom;    atoms ¬ Heap.systemZone.NEW[AtomArray ¬ [      MakeAtom["PaintCursor"L], MakeAtom["SetCursor"L], MakeAtom["SetTextPointer"L], MakeAtom["Track"L], MakeAtom["Black"L], MakeAtom["White"L], MakeAtom["Start"L], MakeAtom["Finish"L]]];    myTIP ¬ TIP.CreateTable[      file: "CursorTool.TIP"L, contents: "-- CursorTool.TIP-- Version of  7-Dec-82 14:32:01[DEF,Chord,(SELECT TRIGGER FROM  ~1 Down BEFORE 250 => { COORDS SetCursor };  ENDCASE => { COORDS ~2 })]  SELECT TRIGGER FROM  MOUSE => SELECT ENABLE FROM    Point Down => SELECT ENABLE FROM      Adjust Up => COORDS, Track;      ENDCASE;    Adjust Down => SELECT ENABLE FROM      Point Up => COORDS, Track;      ENDCASE;    ENDCASE;    ENTER => SELECT ENABLE FROM    Menu Down => COORDS, SetCursor;    ENDCASE => SetTextPointer;      Menu Down => COORDS, SetCursor;    Menu Up => COORDS, PaintCursor;    MENU Down => COORDS, SetCursor;    MENU Up => COORDS, PaintCursor;    Point Down => [Chord,Adjust,Black Start];    Point Up => COORDS, Finish;    Adjust Down => [Chord,Point,White Start];    Adjust Up => COORDS, Finish;    ENDCASE..."L      ! TIP.InvalidTable => RESUME];    toolwindow ¬ Tool.Create[      makeSWsProc: MakeMySWs, name: "Cursor Tool"L, cmSection: "CursorTool"L]};  DisplayGraphicSW: PROC [window: Window.Handle] = {    checkBoxes: PROC [w: Window.Handle, box: Window.Box] = {      nb: Window.Box = Intersect[@box, @gridBox];      IF nb # Window.nullBox THEN RepaintGridBox[nb]};    RepaintWhiteCursor[];    RepaintBlackCursor[];    Window.EnumerateInvalidBoxes[window, checkBoxes]};  MakeMySWs: Tool.MakeSWsProc = {    toolwindow ¬ window;    msgSW ¬ Tool.MakeMsgSW[window: window];    formSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeParameterArray];    logSW ¬ Tool.MakeFileSW[window: window, name: "CursorTool.log"L, h: 100];    -- this should use Tool.MakeClientSW    graphicSW ¬ ToolWindow.CreateSubwindow[      parent: window, display: DisplayGraphicSW, box: graphicBox];    Tool.AddThisSW[window: window, sw: graphicSW, swType: vanilla];    TIP.CreateClient[window: graphicSW, table: myTIP, notify: TIPMe]};    FormIndex: TYPE = {clear, load, complement, write};    ParamNotify: FormSW.ProcType = {    fx: FormIndex = VAL[index];    MsgSW.Clear[msgSW];    SELECT fx FROM      clear => {	newCursorBits­ ¬ ALL[ALL[FALSE]];	Window.InvalidateBox[graphicSW, graphicBox];	Window.Validate[graphicSW]};      load => {        LoadCursor[]; 	Window.InvalidateBox[graphicSW, graphicBox];	Window.Validate[graphicSW]};      complement => {	FOR i: CARDINAL IN [0..CursorSize) DO	  FOR j: CARDINAL IN [0..CursorSize) DO	    newCursorBits[i][j] ¬ ~newCursorBits[i][j];	    ENDLOOP;	  ENDLOOP;	Window.InvalidateBox[graphicSW, graphicBox];	Window.Validate[graphicSW]};      write => WriteCursor[];      ENDCASE};  MakeParameterArray: FormSW.ClientItemsProcType = {    OPEN FormSW;    params: ItemDescriptor = AllocateItemDescriptor[FormIndex.LAST.ORD + 1];    paramArray: LONG POINTER TO ARRAY FormIndex OF FormSW.ItemHandle =      LOOPHOLE[BASE[params]];    paramArray­ ¬ [      CommandItem[tag: "clear"L, place: newLine, proc: ParamNotify],      CommandItem[tag: "load"L, proc: ParamNotify],      CommandItem[tag: "comp"L, proc: ParamNotify],      CommandItem[tag: "write"L, proc: ParamNotify]];    RETURN[items: params, freeDesc: TRUE]};  noMore: SIGNAL = CODE;  LoadCursor: PROC = {    source: Selection.Source ¬ Selection.Convert[source];    buff: STRING ¬ [20];    bufptr: CARDINAL ¬ 0;    GetCh: PROC RETURNS [ch: CHARACTER] = {      IF source = NIL THEN SIGNAL noMore;      IF buff.length = bufptr THEN {	source.proc[source.data, buff];	IF buff.length = 0 THEN {	  source.destroy[source]; source ¬ NIL; SIGNAL noMore};	bufptr ¬ 0};      ch ¬ buff[bufptr];      bufptr ¬ bufptr + 1};    GetNum: PROC RETURNS [num: CARDINAL] = {      s: STRING = [20];      ch: CHARACTER ¬ ' ;      DO 	SELECT ch FROM	  ' , '[, '], ',, '\t, '\n => NULL;	  ENDCASE => EXIT;        ch ¬ GetCh[!noMore => IF s.length # 0 THEN EXIT];        ENDLOOP;      IF ch ~IN ['0..'9] THEN SIGNAL String.InvalidNumber;      DO 	SELECT ch FROM	  IN ['0..'9], 'b, 'd, 'B, 'D => NULL;	  ENDCASE => EXIT;	String.AppendChar[s, ch];        ch ¬ GetCh[];        ENDLOOP;      num ¬ String.StringToDecimal[s]};    BEGIN      ENABLE {	String.InvalidNumber => {	  MsgSW.Post[msgSW, "Invalid number"L];	  GO TO failed};	String.StringBoundsFault => {	  MsgSW.Post[	    sw: msgSW, string: "Number too long: "L, endOfMsg: FALSE];	  MsgSW.Post[msgSW, s];	  GO TO failed};	noMore => {	  MsgSW.Post[msgSW, "Not enough data"L];	  GO TO failed}};    FOR i: CARDINAL IN [0..nCards) DO      cursorCard[i] ¬ GetNum[];      ENDLOOP;    EXITS      failed => NULL;    END; -- of ENABLE    IF source # NIL THEN source.destroy[source]};  WriteCursor: PROC = {    octal6: Format.NumberFormat = [      base: 8, unsigned: TRUE, zerofill: TRUE, columns: 6];    first: BOOLEAN ¬ TRUE;    FOR i: CARDINAL IN [0..nCards) DO      IF first THEN {	Put.Text[logSW, "["L];        first ¬ FALSE}      ELSE Put.Text[logSW, ", "L];      Put.Number[logSW, cursorCard[i], octal6];      Put.Char[logSW, 'B];      ENDLOOP;    Put.Char[logSW, ']]};    AtomIndex: TYPE = {    PaintCursor, SetCursor, SetTextPointer, Track, Black, White, Start, Finish};  AtomArray: TYPE = ARRAY AtomIndex OF Atom.ATOM;    atoms: LONG POINTER TO AtomArray ¬ NIL;  myTIP: TIP.Table ¬ NIL;    TIPMe: TIP.NotifyProc = {    black: BOOLEAN ¬ TRUE;    place: Window.Place ¬ [0, 0];    FOR r: TIP.Results ¬ results, r.Rest UNTIL r = NIL DO      WITH z: r.First SELECT FROM	atom => SELECT z.a FROM	  atoms[PaintCursor] => PaintCursor[place];	  atoms[SetCursor] => {	    cur: Cursor.Object ¬ [	      info: [type: myCursorType, hotX: 0, hotY: 0],	      array: cursorCard­];	    Cursor.Store[@cur]};	  atoms[SetTextPointer] => Cursor.Set[textPointer];	  atoms[Track] => Track[place];	  atoms[Black] => black ¬ TRUE;	  atoms[White] => black ¬ FALSE;	  atoms[Start] => Start[place, black];	  atoms[Finish] => Finish[place];	  ENDCASE;        coords => place ¬ z.place; -- remember the place	ENDCASE;      ENDLOOP};      PaintCursor: PROC [place: Window.Place] = {    Truncate: PROC [c: CARDINAL] RETURNS [CARDINAL] = INLINE {      RETURN [Inline.BITAND[c, 177760B]]};    place ¬ [Truncate[place.x], Truncate[place.y]];    IF place.x > gridBox.place.x + CursorSize*SquareSize OR        place.y > gridBox.place.y + CursorSize*SquareSize THEN {      Display.Bitmap[        window: graphicSW,        box: [place, [w: CursorSize, h: CursorSize]],        address: [word: newCursorBits, bit: 0],        bitmapBitWidth: CursorSize,        flags: Display.replaceFlags];      Cursor.Set[textPointer]}};      myCursorType: Cursor.Type = Cursor.UniqueType[];    PaintData: TYPE = RECORD [place: Window.Place, black: BOOLEAN];  paintData: LONG POINTER TO PaintData ¬ NIL;    Start: PROC [place: Window.Place, black: BOOLEAN] = {    IF paintData # NIL THEN RETURN;    DoPaint[paintData ¬ Heap.systemZone.NEW[PaintData ¬ [place, black]]]};    DoPaint: PROC [p: LONG POINTER TO PaintData] = {    i, j: CARDINAL;    IF p.place.x >= p.place.x AND      p.place.y >= gridBox.place.y THEN {      i ¬ (p.place.y - gridBox.place.y)/SquareSize;      j ¬ (p.place.x - gridBox.place.x)/SquareSize;      IF i < CursorSize AND j < CursorSize THEN SetBit[i, j, p.black]}};    Track: PROC [place: Window.Place] = {    IF paintData = NIL OR place = paintData.place THEN RETURN;    paintData.place ¬ place;    DoPaint[paintData]};    Finish: PROC [place: Window.Place] = {    IF paintData = NIL THEN {      IF Cursor.GetInfo[].type = myCursorType THEN PaintCursor[place]}    ELSE {Track[place]; Heap.systemZone.FREE[@paintData]}};    Init[];    END.
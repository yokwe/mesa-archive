-- Copyright (C) 1981, 1982, 1983  by Xerox Corporation. All rights reserved. -- Dump.mesa - last edit:-- Mark:	13-Apr-81 20:54:57-- SHayes:	 2-Sep-81 16:32:53-- Rhonda:	23-Sep-81 16:33:00-- Loretta:	 9-Nov-81 16:12:43-- Johnsson:	22-Sep-82 15:00:28-- Saaranzin:	13-Sep-83 18:36:38DIRECTORY  Ascii USING [CR, SP, TAB],  Environment USING [bytesPerWord],  Exec USING [    AddCommand, CheckForAbort, ExecProc, FreeTokenString, GetToken, Handle, Outcome, OutputProc, PutChar],  Format USING [Number, NumberFormat, StringProc],  MStream USING [EndOf, Error, ReadOnly, WriteOnly],  String USING [Length],  Stream USING [Delete, GetBlock, GetChar, Handle, PutChar];Dump: PROGRAM  IMPORTS    Exec, Format, MStream, String, Stream =  BEGIN  Switches: TYPE = POINTER TO SwitchArray;  SwitchArray: TYPE = PACKED ARRAY CHARACTER['a..'z] OF BOOLEAN;  DumpProcType: TYPE = PROCEDURE [input, output: Stream.Handle, switches: Switches, h: Exec.Handle];    ExecCallingCDump: Exec.ExecProc = {RETURN[ExecCalling[h, 'C]]};  ExecCallingODump: Exec.ExecProc = {RETURN[ExecCalling[h, 'O]]};  ExecCalling: PROCEDURE [h: Exec.Handle, firstChar: CHARACTER] RETURNS [outcome: Exec.Outcome ¬ normal] =    BEGIN    switchSense: BOOLEAN = TRUE;    switches: SwitchArray;    inputFileName, outputFileName, sw: LONG STRING;    input, output: Stream.Handle ¬ NIL;    Cleanup: PROCEDURE =      BEGIN      inputFileName ¬ Exec.FreeTokenString[inputFileName];      outputFileName ¬ Exec.FreeTokenString[outputFileName];      IF input # NIL THEN {Stream.Delete[input]; input ¬ NIL};      IF output # NIL THEN {Stream.Delete[output]; output ¬ NIL};      END;    ProcessSwitches: PROCEDURE [sw : LONG STRING] =      BEGIN      FOR i: CARDINAL IN [0..String.Length[sw]) DO        switches[sw[i]] ¬ switchSense	ENDLOOP;      END;    switches ¬ ALL[FALSE];    [inputFileName, sw] ¬ Exec.GetToken[h];    ProcessSwitches[sw];    [] ¬ Exec.FreeTokenString[sw];    [outputFileName, sw] ¬ Exec.GetToken[h];    ProcessSwitches[sw];    [] ¬ Exec.FreeTokenString[sw];    IF inputFileName = NIL OR outputFileName = NIL THEN      BEGIN      PostLine[h, "Command syntax is:"L];      PostLine[h, "commandName inputFile/optionalSwitches outputFile/optionalSwitches"L];      RETURN;      END;    BEGIN ENABLE ANY => {PostLine[h, "Unknown error"L]; Cleanup[]; CONTINUE};    input ¬ MStream.ReadOnly[inputFileName, [] ! MStream.Error => CONTINUE];    IF input = NIL THEN {      PostString[h, "Cannot acquire input file "L];      PostLine[h, inputFileName];      Cleanup[];      RETURN};    output ¬ MStream.WriteOnly[      outputFileName, [], text ! MStream.Error => CONTINUE];    IF output = NIL THEN {      PostString[h, "Cannot acquire output file "L];      PostLine[h, outputFileName];      Cleanup[];      RETURN};    PostString[h, outputFileName];    PostString[h, " ¬ "L];    PostChar[h, firstChar]; PostString[h, "Dump["L];    PostString[h, inputFileName];    PostChar[h, ']];    IF switches # ALL[FALSE] THEN      BEGIN      PostChar[h, '/];      FOR i: CHARACTER['a..'z] IN ['a..'z] DO IF switches[i] THEN PostChar[h, i]; ENDLOOP;      END;    PostLine[h, ""L];    (SELECT firstChar FROM       'C => CDump, ENDCASE => ODump)[input, output, @switches, h];    Cleanup[];    END;    END;  OutAddress: PROCEDURE [stream: Stream.Handle, loc, base: CARDINAL] =    BEGIN    OutNumber[stream, loc, [base:base, zerofill:FALSE, unsigned:TRUE, columns:5]];    Stream.PutChar[stream, '/];    Stream.PutChar[stream, Ascii.TAB];    END;      OutNumber: PROCEDURE [stream: Stream.Handle, i: CARDINAL, format: Format.NumberFormat] =    BEGIN    Output: Format.StringProc = {OutString[stream, s]};    Format.Number[Output, i, format];    END;      OutString: PROCEDURE [stream: Stream.Handle, string: LONG STRING] =    BEGIN    i: CARDINAL;    FOR i IN [0..string.length) DO      Stream.PutChar[stream, string[i]]      ENDLOOP;    END;      PostLine: PROCEDURE [h: Exec.Handle, s: LONG STRING] = BEGIN PostString[h, s]; PostChar[h, Ascii.CR]; END;  PostString: PROCEDURE [h: Exec.Handle, s: LONG STRING] = BEGIN Exec.OutputProc[h][s] END;  PostChar: PROCEDURE [h: Exec.Handle, c: CHARACTER] = BEGIN Exec.PutChar[h, c] END;      CDump: DumpProcType =    BEGIN    i: CARDINAL;    c: CHARACTER;    charsPerLine: CARDINAL = 64;    charsPerSection: CARDINAL = 512;    charsPerGroup: CARDINAL = 8;    difcount: CARDINAL ¬ 0;        OutString[output,     "             0         10         20         30         40         50         60         70"L];    Stream.PutChar[output, Ascii.CR];        FOR i ¬ 0, i+1 WHILE TRUE DO      IF i MOD charsPerSection = 0 THEN Stream.PutChar[output, Ascii.CR];      IF MStream.EndOf[input] THEN EXIT ELSE c ¬ Stream.GetChar[input];      IF i MOD charsPerLine = 0 THEN {OutAddress[output, i, 8]; Stream.PutChar[output, '|]};      Stream.PutChar[output, IF c IN [Ascii.SP..176C] THEN c ELSE Ascii.SP];      IF i MOD charsPerLine = charsPerLine-1 THEN	BEGIN	  Stream.PutChar[output,'|]; 	  Stream.PutChar[output, Ascii.CR];	  IF Exec.CheckForAbort[h] THEN EXIT; --check after each group--        END      ELSE IF i MOD charsPerGroup = charsPerGroup-1 THEN OutString[output, "| |"L];      ENDLOOP;          IF i MOD charsPerLine # 0 THEN Stream.PutChar[output, Ascii.CR];    END;   ODump: DumpProcType =    BEGIN    i,loc: CARDINAL;    w: ARRAY [0..7] OF [0..177777B];    p: POINTER TO PACKED ARRAY [0..15] OF CHARACTER = LOOPHOLE[@w];    char: CHARACTER;    words, bytes: CARDINAL;    base: CARDINAL = IF switches['h] THEN 16 ELSE 8;    format: Format.NumberFormat = Format.NumberFormat[      base:base, zerofill:FALSE, unsigned:TRUE, columns:7];    FOR loc ¬ 0, loc+8 WHILE TRUE DO      [bytesTransferred: bytes] ¬         Stream.GetBlock[input, 	  [LOOPHOLE[LONG[BASE[w]]], 0, LENGTH[w] * Environment.bytesPerWord]];      IF bytes = 0 THEN EXIT;      OutAddress[output, loc, base];      IF (bytes MOD 2) = 1 THEN p[bytes] ¬ 0C;      words ¬ (bytes+1)/2;      FOR i IN [0..words) DO OutNumber[output, w[i], format] ENDLOOP;      FOR i IN [7*words..7*8+2) DO Stream.PutChar[output, Ascii.SP] ENDLOOP;      Stream.PutChar[output,'|];      FOR i IN [0..bytes) DO	SELECT (char ¬ p[i]) FROM	  < Ascii.SP, >= 177C, 140C => Stream.PutChar[output, Ascii.SP];	  ENDCASE => Stream.PutChar[output, char];	ENDLOOP;       Stream.PutChar[output, '|];      Stream.PutChar[output, Ascii.CR];      IF Exec.CheckForAbort[h] THEN EXIT;      ENDLOOP;    END;     -- mainline code    Exec.AddCommand["CDump.~", ExecCallingCDump];  Exec.AddCommand["ODump.~", ExecCallingODump];  END..  
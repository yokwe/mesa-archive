-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. --Last edit by JAC     5-Nov-84 14:16:23DIRECTORY  Ascii USING [CR],  Inline USING [BITAND, BITOR],  String USING [AppendChar, AppendNumber, AppendString],  DsyAssembler,  DsyFile USING [LogErrLine],  DsyLabel,  DsyP2Hash USING [    bad, errorLevel, miRtoV, miVtoR, Not, realMI, Reserved];DsyConstrainedImpl: PROGRAM  IMPORTS Inline, String, DsyFile, DsyLabel, DsyP2Hash EXPORTS DsyLabel =  BEGIN OPEN DsyLabel, DsyAssembler;  AllocateConstrained: PROCEDURE [ca: LONG POINTER TO ConstraintAttribute] =    BEGIN    anon: MiSeqNum;    anonoff: CARDINAL [0..15];    base: CARDINAL;    blockSize: CARDINAL;    ccCur: LONG POINTER TO ConstraintChain;    ccDone: LONG POINTER TO ConstraintChain ¬ NIL;    ccOld: LONG POINTER TO ConstraintChain;    ccToDo: LONG POINTER TO ConstraintChain;    errorMsgSent: BOOLEAN ¬ FALSE;    i, j, k: CARDINAL;    mapCur: ARRAY [0..16) OF MiSeqNum ¬ ALL[Empty];    mask: INTEGER;    modCur: ModuloIndex;    newInx: INTEGER;    stuck: BOOLEAN;    MoveCC: PROCEDURE =      -- this procedure is used to move a constraint chain (ccCur) from the chain of ccToDo to the chain of ccDone.  ccCur and ccOld are also updated.      BEGIN      ccTemp: LONG POINTER TO ConstraintChain ¬ ccCur;      -- now move ccCur from ccToDo to ccDone      IF ccToDo # ccCur THEN        BEGIN ccOld.nextConstraint ¬ ccTemp.nextConstraint; END      ELSE        BEGIN ccToDo ¬ ccTemp.nextConstraint; ccOld ¬ ccTemp.nextConstraint; END;      ccCur ¬ ccTemp.nextConstraint;      ccTemp.nextConstraint ¬ ccDone;      ccDone ¬ ccTemp;      END;  -- end MoveCC    AllocErr: PROCEDURE [type: {abs, block, no}, mi1, mi2: MiSeqNum] =      BEGIN      Estr: LONG STRING ¬ [120];      Estr.length ¬ 0;      IF DsyP2Hash.errorLevel < DsyP2Hash.bad THEN        DsyFile.LogErrLine["Allocation Errors:"L];      DsyP2Hash.errorLevel ¬ 200;      errorMsgSent ¬ TRUE;      SELECT type FROM        abs =>          BEGIN          String.AppendString[Estr, "Allocation Abs Conflict between "L];          AppendSymbolName[Estr, mi1];          String.AppendString[Estr, " and "L];          IF mi2 # DsyP2Hash.Reserved THEN AppendSymbolName[Estr, mi2]          ELSE String.AppendString[Estr, "Reserve clause "L];          END;        block =>          BEGIN          String.AppendString[Estr, "Could not allocate block containing "L];          AppendSymbolName[Estr, mi1];          END;        no =>          BEGIN          String.AppendString[Estr, "No place for block containing "L];          AppendSymbolName[Estr, mi1];          END;        ENDCASE;      DsyFile.LogErrLine[Estr];      PrintBlockData[ccToDo, ccDone];      END;  -- end AllocErr    UNTIL ca = NIL DO      ccDone ¬ NIL;      BEGIN      ccCur ¬ ca.constraints;      IF ca.maxModulo = maxmaxModulo THEN        BEGIN  -- abs loop        ccToDo ¬ ccCur;        ccOld ¬ ccCur;        modCur ¬ ca.maxModulo;        UNTIL ccCur = NIL DO  -- place first abs          IF ccCur.modulo = modCur THEN            BEGIN            IF DsyP2Hash.miRtoV[ccCur.offset] # Empty              AND DsyP2Hash.miRtoV[ccCur.offset] # ccCur.miIndex1 THEN              AllocErr[abs, ccCur.miIndex1, DsyP2Hash.miRtoV[ccCur.offset]]            ELSE              BEGIN              DsyP2Hash.miRtoV[ccCur.offset] ¬ ccCur.miIndex1;              DsyP2Hash.miVtoR[ccCur.miIndex1] ¬ ccCur.offset;              END;            MoveCC[];            END          ELSE BEGIN ccOld ¬ ccCur; ccCur ¬ ccCur.nextConstraint; END;          ENDLOOP;  -- end place first abs        -- reprocess original chain, look for labels bound to allocated ones        stuck ¬ FALSE;        UNTIL ccToDo = NIL DO  -- linked to abs outer loop          IF stuck THEN GOTO AllocError1;          ccCur ¬ ccToDo;          ccOld ¬ ccCur;          stuck ¬ TRUE;          UNTIL ccCur = NIL DO  -- linked to abs inner loop            IF DsyP2Hash.miVtoR[ccCur.miIndex2] # DsyP2Hash.Not THEN              BEGIN              IF DsyP2Hash.miVtoR[ccCur.miIndex1] # DsyP2Hash.Not THEN                BEGIN                -- both labels already allocated                MoveCC[];                stuck ¬ FALSE;                END              ELSE                BEGIN                -- miIndex2 has been allocated, miIndex 1 has not                mask ¬                  SELECT ccCur.modulo FROM                    1 => -2,                    2 => -4,                    3 => -8,                    4 => -16,                    ENDCASE => 0;                newInx ¬ Inline.BITOR[                  ccCur.offset, Inline.BITAND[                  DsyP2Hash.miVtoR[ccCur.miIndex2], mask]];                IF DsyP2Hash.miRtoV[newInx] # Empty                  AND DsyP2Hash.miRtoV[newInx] # ccCur.miIndex1 THEN                  AllocErr[abs, ccCur.miIndex1, DsyP2Hash.miRtoV[newInx]]                ELSE                  BEGIN                  DsyP2Hash.miRtoV[newInx] ¬ ccCur.miIndex1;                  DsyP2Hash.miVtoR[ccCur.miIndex1] ¬ newInx;                  END;                MoveCC[];                stuck ¬ FALSE;                END;              END            ELSE              BEGIN              -- label 2 has not been allocated              -- it is safe to not look at label 1 in this situation except for some pathological situations with multiple at's per m-i.              ccOld ¬ ccCur;              ccCur ¬ ccCur.nextConstraint;              END;            ENDLOOP;  -- end linked to abs inner loop          ENDLOOP;  -- end linked to abs outer loop        GOTO Verify;  -- absolute chain all allocated        END;  -- end abs loop      ccToDo ¬ ccCur;      ccOld ¬ ccCur;      modCur ¬ ca.maxModulo;      anon ¬ Empty;      FOR j IN [0..16) DO mapCur[j] ¬ Empty ENDLOOP;      UNTIL ccCur = NIL DO  -- init mapCur loop        IF ccCur.modulo = modCur THEN          BEGIN          IF ccCur.miIndex1 < DsyP2Hash.realMI THEN	    IF (mapCur[ccCur.offset] # Empty) AND (mapCur[ccCur.offset] # ccCur.miIndex1) THEN	      GOTO AllocError5            ELSE mapCur[ccCur.offset] ¬ ccCur.miIndex1          ELSE {anon ¬ ccCur.miIndex1; anonoff ¬ ccCur.offset; };          MoveCC[];          END        ELSE BEGIN ccOld ¬ ccCur; ccCur ¬ ccCur.nextConstraint; END;        ENDLOOP;  -- end init mapCur loop      -- reprocess original chain, look for labels bound to allocated ones      stuck ¬ FALSE;      UNTIL ccToDo = NIL DO  -- cc outer loop        IF stuck THEN GOTO AllocError2;        ccCur ¬ ccToDo;        ccOld ¬ ccCur;        stuck ¬ TRUE;        UNTIL ccCur = NIL DO  -- cc inner loop          k ¬ 16;          FOR j IN [0..15] DO IF mapCur[j] = ccCur.miIndex2 THEN k ¬ j ENDLOOP;          IF k = 16 THEN            BEGIN            IF ccCur.miIndex2 # anon THEN {              ccOld ¬ ccCur; ccCur ¬ ccCur.nextConstraint; LOOP; }            ELSE k ¬ anonoff;            END;          mask ¬ SELECT ccCur.modulo FROM 1 => -2, 2 => -4, 3 => -8, ENDCASE => 0;          newInx ¬ Inline.BITOR[ccCur.offset, Inline.BITAND[k, mask]];          IF mapCur[newInx] # Empty AND mapCur[newInx] # ccCur.miIndex1 THEN            GOTO AllocError3;          mapCur[newInx] ¬ ccCur.miIndex1;          stuck ¬ FALSE;          MoveCC[];          ENDLOOP;  -- end cc inner loop        ENDLOOP;  -- end cc outer loop      -- mapCur now contains all the indecis from the constraint block      -- now find a place for the block      blockSize ¬        SELECT ca.maxModulo FROM 1 => 2, 2 => 4, 3 => 8, 4 => 16, ENDCASE => 16;      k ¬ 16/blockSize;      j ¬ 0;      DO  -- block advance loop        BEGIN	base ¬ j*blockSize;	IF base >= 4096 THEN GOTO AllocError4;        FOR i IN [0..blockSize) DO  -- check loop          IF DsyP2Hash.miRtoV[base + i] # Empty AND mapCur[i] # Empty THEN            GOTO NextBlock;          ENDLOOP;  -- end check loop        FOR i IN [0..blockSize) DO  -- place loop          IF mapCur[i] # Empty THEN            BEGIN	    IF DsyP2Hash.miVtoR[mapCur[i]] # DsyP2Hash.Not THEN	    --multiple constraints on this address => allocation error	      GOTO AllocError5            ELSE DsyP2Hash.miVtoR[mapCur[i]] ¬ base + i;            DsyP2Hash.miRtoV[base + i] ¬ mapCur[i];            END;          ENDLOOP;  -- end place loop        EXIT;        EXITS NextBlock => BEGIN j ¬ j + 1; LOOP; END;        END;        ENDLOOP;  -- end block advance loop            GOTO Verify;      EXITS        AllocError1 => AllocErr[block, ccToDo.miIndex1, Empty];        AllocError2 => AllocErr[block, ccToDo.miIndex1, Empty];        AllocError3 => AllocErr[block, ccCur.miIndex1, Empty];	AllocError4 => AllocErr[no, ccDone.miIndex1, Empty];	AllocError5 => AllocErr[block, ccDone.miIndex1, Empty];         Verify =>          BEGIN  -- verify operatin          ccCur ¬ ccDone;          ccToDo ¬ ccCur;          ccOld ¬ ccCur;          ccDone ¬ NIL;          errorMsgSent ¬ FALSE;          UNTIL (ccCur = NIL) OR errorMsgSent DO  -- verify loop            -- now verify that all constraint restrictions are satisfied            mask ¬              SELECT ccCur.modulo FROM                5 => 4095,                4 => 15,                3 => 7,                2 => 3,                1 => 1,                ENDCASE => 1;            IF DsyP2Hash.miVtoR[ccCur.miIndex1] = DsyP2Hash.Not THEN {              AllocErr[block, ccCur.miIndex1, Empty]; MoveCC; LOOP; };            IF DsyP2Hash.miVtoR[ccCur.miIndex2] = DsyP2Hash.Not THEN              BEGIN              IF ccCur.miIndex2 >= DsyP2Hash.realMI THEN                DsyP2Hash.miVtoR[ccCur.miIndex2] ¬ DsyP2Hash.miVtoR[ccCur.miIndex1]              ELSE AllocErr[block, ccCur.miIndex2, Empty];              END;            IF (ccCur.miIndex2 < DsyP2Hash.realMI)              AND                (Inline.BITAND[DsyP2Hash.miVtoR[ccCur.miIndex1], mask] #                  ccCur.offset                  OR Inline.BITOR[DsyP2Hash.miVtoR[ccCur.miIndex1], mask] #                    Inline.BITOR[DsyP2Hash.miVtoR[ccCur.miIndex2], mask]) THEN              AllocErr[block, ccCur.miIndex1, Empty];                        MoveCC[];            ENDLOOP;  -- end verify loop          END;  -- end verify operation      END;      ca ¬ ca.caChain;      ENDLOOP;    END;  -- end AllocateConstrained  ProcessConstraints: PUBLIC PROCEDURE [ca: LONG POINTER TO ConstraintAttribute] =    BEGIN    -- order Constraints from largest to smallest    caList: ARRAY [0..11] OF LONG POINTER TO ConstraintAttribute ¬ ALL[NIL];    caCur: LONG POINTER TO ConstraintAttribute ¬ ca;    caNext: LONG POINTER TO ConstraintAttribute;    cc: LONG POINTER TO ConstraintChain;    i: CARDINAL;    inx: CARDINAL;    UNTIL caCur = NIL DO      inx ¬ (caCur.maxModulo*2);      caNext ¬ caCur.caChain;      caCur.caChain ¬ caList[inx];      caList[inx] ¬ caCur;      cc ¬ caCur.constraints;      caCur ¬ caNext;      ENDLOOP;    FOR i DECREASING IN [2..11] DO AllocateConstrained[caList[i]]; ENDLOOP;      END;  -- end ProcessConstraints  PrintBlockData: PROCEDURE [cc1, cc2: LONG POINTER TO ConstraintChain] =    BEGIN    Estr: LONG STRING ¬ [175];    ccCur: LONG POINTER TO ConstraintChain;    PrintConsLine: PROCEDURE [cc: LONG POINTER TO ConstraintChain] =      BEGIN      Estr.length ¬ 0;      String.AppendString[Estr, " * "L];      AppendSymbolName[Estr, cc.miIndex1];      String.AppendChar[Estr, ' ];      String.AppendNumber[Estr, cc.offset, 16];      String.AppendString[Estr, " mod "L];      String.AppendString[        Estr,        SELECT cc.modulo FROM          1 => "2"L,          2 => "4"L,          3 => "8"L,          4 => "10'x"L,          ENDCASE => "1000'x"L];      DsyFile.LogErrLine[Estr];      END;  -- end PrintConsLine    Estr.length ¬ 0;    String.AppendString[Estr, "The Block Constraints are:"];    String.AppendChar[Estr, Ascii.CR];    DsyFile.LogErrLine[Estr];    Estr.length ¬ 0;    String.AppendString[Estr, " * Label1   Label2   offset   modulo"L];    String.AppendChar[Estr, Ascii.CR];    DsyFile.LogErrLine[Estr];    ccCur ¬ cc1;    UNTIL ccCur = NIL DO  -- print loop 1      PrintConsLine[ccCur]; ccCur ¬ ccCur.nextConstraint; ENDLOOP;  -- end print loop    ccCur ¬ cc2;    UNTIL ccCur = NIL DO  -- print loop 2      PrintConsLine[ccCur]; ccCur ¬ ccCur.nextConstraint; ENDLOOP;  -- end print loop    Estr.length ¬ 0;    String.AppendChar[Estr, Ascii.CR];    DsyFile.LogErrLine[Estr];    END;  -- end PrintBlockData  END...--Log of last edit:--JAC   	23-Aug-84 15:54:30	added a check for multiple constraints in the place loop of AllocateConstrained--JAC   	24-Aug-84  9:59:54	added a check for multiple constraints in init mapCur loop of AllocateConstrained--JAC   	 5-Nov-84 14:13:47	fixed arrows for Mesa 11.1
-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. -- The purpose of this module is to create Encoding records for each Phrase of a microcode statement.  A microcode statement consists of a list of Phrase records.  A Phrase represents the text in a statement between commas.  Each Phrase consists of a list of PhraseElement records and a list of Encoding records.  A PhraseElement represents an element of a Phrase such as a D Register, a "+" operation, a constant, etc.  The Encoding record represents how the Phrase will be encoded into fields of the microinstruction.  There will be more than one Encoding record if the Phrase has more than one possible way of being encoded.    --Last edit by JAC           24-Feb-85 14:55:28DIRECTORY  DsyExpressionTablesImplA USING [    patternOpx, patternOpor, patternOpand, patternOpNand, patternOpNor,    patternOpxor, patternOpNxor],  DsyExpressionTablesImplB USING [    patternCin0, patternCin1, patternCinX, patternOpAPlusB, patternOpXPlusCI, patternOpminus,    patternOpmpy],  DsyFile USING [LogErrAndSrcLines],  String USING [EqualString],  DsyAssembler,  DsyModule;DsyEncodeImpl: PROGRAM  IMPORTS    String, DsyAssembler, ETA: DsyExpressionTablesImplA,    ETB: DsyExpressionTablesImplB, DsyFile  EXPORTS DsyAssembler, DsyModule =  BEGIN OPEN DsyAssembler;  -- GLOBAL VARIABLES  aBus: PUBLIC BOOLEAN;  aFile: PUBLIC BOOLEAN;  aluGets: PUBLIC BOOLEAN;  bBus: PUBLIC BOOLEAN;  cycleTypeSpecified: PUBLIC BOOLEAN;  destination: PUBLIC ArgumentType;  expression: PUBLIC BOOLEAN;  hasArrow: PUBLIC BOOLEAN;  offsetAdder: PUBLIC BOOLEAN;  mdr: PUBLIC BOOLEAN;  memory: PUBLIC BOOLEAN;  popIB: PUBLIC BOOLEAN;  --PRIVATE VARIABLES    aBusThisPhrase: BOOLEAN;  bBusThisPhrase: BOOLEAN;  expressionFound: BOOLEAN;  lastNextEncodingPtrInNewChain: LONG POINTER TO EncodingPtr;  mdrThisPhrase: BOOLEAN;  negated: BOOLEAN;  nextOldEncoding: EncodingPtr;  nullExpression: Expression = Expression[    operand1: zero, operation: x, operand2: zero, carry: x];  operationsEncountered: INTEGER;  --number of operations encountered or assumed in this MI excluding use of the offset adder.  QAssigned: BOOLEAN ¬ FALSE;  trialEncoding: EncodingPtr;  patternOpx: LONG DESCRIPTOR FOR ARRAY OF ExpressionPattern;  patternOpor: LONG DESCRIPTOR FOR ARRAY OF ExpressionPattern;  patternOpNor: LONG DESCRIPTOR FOR ARRAY OF ExpressionPattern;  patternOpand: LONG DESCRIPTOR FOR ARRAY OF ExpressionPattern;  patternOpNand: LONG DESCRIPTOR FOR ARRAY OF ExpressionPattern;  patternOpxor: LONG DESCRIPTOR FOR ARRAY OF ExpressionPattern;  patternOpNxor: LONG DESCRIPTOR FOR ARRAY OF ExpressionPattern;  patternOpAPlusB: LONG DESCRIPTOR FOR ARRAY OF ExpressionPattern;  patternOpXPlusCI: LONG DESCRIPTOR FOR ARRAY OF ExpressionPattern;  patternOpminus: LONG DESCRIPTOR FOR ARRAY OF ExpressionPattern;  patternOpmpy: LONG DESCRIPTOR FOR ARRAY OF ExpressionPattern;  InitGlobalEncode: PUBLIC PROCEDURE =    BEGIN    patternOpx ¬ DESCRIPTOR[@ETA.patternOpx, LENGTH[ETA.patternOpx]];    patternOpor ¬ DESCRIPTOR[@ETA.patternOpor, LENGTH[ETA.patternOpor]];    patternOpNor ¬ DESCRIPTOR[@ETA.patternOpNor, LENGTH[ETA.patternOpNor]];    patternOpand ¬ DESCRIPTOR[@ETA.patternOpand, LENGTH[ETA.patternOpand]];    patternOpNand ¬ DESCRIPTOR[@ETA.patternOpNand, LENGTH[ETA.patternOpNand]];    patternOpxor ¬ DESCRIPTOR[@ETA.patternOpxor, LENGTH[ETA.patternOpxor]];    patternOpNxor ¬ DESCRIPTOR[@ETA.patternOpNxor, LENGTH[ETA.patternOpNxor]];    patternOpAPlusB ¬ DESCRIPTOR[      @ETB.patternOpAPlusB, LENGTH[ETB.patternOpAPlusB]];    patternOpXPlusCI ¬ DESCRIPTOR[      @ETB.patternOpXPlusCI, LENGTH[ETB.patternOpXPlusCI]];    patternOpminus ¬ DESCRIPTOR[@ETB.patternOpminus, LENGTH[ETB.patternOpminus]];    patternOpmpy ¬ DESCRIPTOR[@ETB.patternOpmpy, LENGTH[ETB.patternOpmpy]];    aFile ¬ aluGets ¬ bBus ¬ cycleTypeSpecified ¬ expression ¬ hasArrow ¬ offsetAdder ¬ mdr ¬ memory ¬ popIB ¬ FALSE;    aBus ¬ aBusThisPhrase ¬ bBusThisPhrase ¬ expressionFound ¬ mdrThisPhrase ¬ negated ¬ FALSE;    destination ¬ ArgumentType[];    END;  --of procedure InitGlobalEncode  EncodeExpression: PROCEDURE [phrase: PhrasePtr] =    BEGIN    -- Try to encode phrase.expression in each existing Encoding record for the given Phrase.  We create a new chain of Encoding records for the Phrase.  There may be more than one possible encoding of the expression that follows the first entry.    encoding: EncodingPtr ¬ phrase.encoding;    firstExpression: ExpressionPatternPtr;    limit: CARDINAL ¬ 0;  --size of expression table array for current operation    position: CARDINAL ¬ 0;  --position of pattern within expression table array of current pattern    secondExpression: PatternPtr;    BEGIN  -- Begin EncodeExpression.    trialEncoding ¬ AllocateEncodingRecord[];    lastNextEncodingPtrInNewChain ¬ @phrase.encoding;    expressionFound ¬ FALSE;    IF phrase.encoding = NIL THEN RETURN;    IF phrase.expression = nullExpression THEN RETURN;    [firstExpression, secondExpression, position, limit] ¬ FindExpression[phrase];    IF firstExpression = NIL THEN      BEGIN SyntaxError[phrase, invalidExpression]; GO TO SyntaxError; END;    -- Save the old list of encoding records.  The old list will be replaced by a new list.    nextOldEncoding ¬ phrase.encoding;    phrase.encoding ¬ NIL;    UNTIL nextOldEncoding = NIL DO  -- once for each encoding in the list      SearchForPattern[phrase, firstExpression, secondExpression, position, limit];      nextOldEncoding ¬ nextOldEncoding.nextEncoding;      ENDLOOP;    EXITS SyntaxError => phrase.syntaxError ¬ TRUE;    -- FormatError => NULL;    END;  -- of SyntaxError block    -- If any patterns could not be encoded, error messages are chained onto tempFormatErrorMsgs.  If we found a pattern that works, we delete the temp error messages.  If no pattern could be encoded, we will print all of the error messages.    IF NOT expressionFound THEN MakeTempErrorMsgsPermanent[phrase];    RETURN;    END;  EncodeExtract: PROCEDURE [phrase: PhrasePtr] RETURNS [encoded: BOOLEAN ¬ TRUE] =    BEGIN    --Begin error block    BEGIN    IF mdrThisPhrase THEN {      DsyFile.LogErrAndSrcLines["MDR ¬ requires an Abus source only"L];      GOTO SyntaxError};    IF (phrase.currentElement ¬ phrase.currentElement.nextElement) = NIL THEN {      DsyFile.LogErrAndSrcLines["Extract requires 3 arguments"L]; GOTO SyntaxError}    ELSE      WITH phrase.currentElement.elementRec SELECT FROM  --ABus source        register =>          BEGIN          IF registerType IN [A..zero] THEN {            phrase.arg1 ¬ [regnum, registerType];	    IF registerType IN [stkMinus2..stkPlus1] THEN phrase.isStk ¬ TRUE;            phrase.expression.operand1 ¬ aBus}          ELSE {            DsyFile.LogErrAndSrcLines["Abus source expected"L];            phrase.arg1 ¬ [rAZero, zero];            encoded ¬ FALSE};          END;        star => {phrase.arg1 ¬ [rAZero, zero]};        constant =>          IF value = 0 THEN {            phrase.arg1 ¬ [rAZero, zero]; phrase.expression.operand1 ¬ bBus}          ELSE {            DsyFile.LogErrAndSrcLines["Illegal argument in Extract"L];            encoded ¬ FALSE};        ENDCASE =>          BEGIN          DsyFile.LogErrAndSrcLines["Illegal argument in Extract"L];          encoded ¬ FALSE;          END;    IF (phrase.currentElement ¬ phrase.currentElement.nextElement) = NIL THEN {      DsyFile.LogErrAndSrcLines["Extract requires 3 arguments"L]; GOTO SyntaxError}    ELSE      WITH phrase.currentElement.elementRec SELECT FROM  --Bbus source        register =>          BEGIN          IF registerType IN [zero..ibSE] THEN {            phrase.arg2 ¬ [regnum, registerType];            phrase.expression.operand2 ¬ bBus}          ELSE {            DsyFile.LogErrAndSrcLines["Bbus source expected"L];            phrase.arg2 ¬ [rBZero, zero];            encoded ¬ FALSE};          END;        star => {phrase.arg2 ¬ [rBZero, zero]};        constant =>          IF value = 0 THEN {            phrase.arg2 ¬ [rAZero, zero]; phrase.expression.operand2 ¬ bBus}          ELSE {            DsyFile.LogErrAndSrcLines["Illegal argument in Extract"L];            encoded ¬ FALSE};        ENDCASE =>          BEGIN          DsyFile.LogErrAndSrcLines["Illegal argument in Extract"L];          encoded ¬ FALSE;          END;    IF (phrase.currentElement ¬ phrase.currentElement.nextElement) = NIL THEN {      DsyFile.LogErrAndSrcLines["Extract requires 3 arguments"L]; GOTO SyntaxError}    ELSE      WITH phrase.currentElement.elementRec SELECT FROM  --bits to extract        constant =>          IF value IN [0..16) THEN phrase.arg3 ¬ value          ELSE {            DsyFile.LogErrAndSrcLines["bits to extract is illegal"L];            encoded ¬ FALSE};        variable =>          IF val IN [0..16) THEN phrase.arg3 ¬ val          ELSE {            DsyFile.LogErrAndSrcLines["Bits to extract is illegal"L];            encoded ¬ FALSE};        ENDCASE =>          BEGIN          DsyFile.LogErrAndSrcLines["Illegal argument in Extract"L];          encoded ¬ FALSE;          END;    IF (phrase.currentElement ¬ phrase.currentElement.nextElement) # NIL THEN {      phrase.currentElement ¬ NIL;      DsyFile.LogErrAndSrcLines["Extract requires only 3 arguments"L];      GOTO SyntaxError};    EXITS SyntaxError => encoded ¬ FALSE;    END;  --of error block    RETURN;    END;  --of EncodeExtract  EncodeLHS: PROCEDURE [phrase: PhrasePtr] =    BEGIN    -- Begin with the left hand side of an expression.    BEGIN  -- SyntaxError block    IF phrase.currentElement = NIL THEN RETURN;    WITH phrase.currentElement.elementRec SELECT FROM      register =>        BEGIN        EncodeRegisterLHS[phrase, registerType, regnum];        IF NOT NextElementIsArrow[phrase] THEN          BEGIN          SyntaxError[phrase, arrowMissing];          GOTO SyntaxError;  -- syntax error if next element is not arrow          END;        phrase.currentElement ¬ phrase.currentElement.nextElement;        IF phrase.currentElement.nextElement = NIL THEN          BEGIN          SyntaxError[phrase, noRHS];          GOTO SyntaxError;  -- syntax error if no right hand side          END;        EncodeRHS[phrase];        END;      macro =>         BEGIN	EncodeMacro[phrase, macroIndex]; 	IF (phrase.currentElement ¬ phrase.currentElement.nextElement) # NIL THEN {	  SyntaxError[phrase, unexpectedRHS];	  GOTO SyntaxError};	END;      macroArrow =>        BEGIN        phrase.arg3 ¬ macroIndex;        IF macroIndex IN [linkSize..startMemorySize) THEN memory ¬ TRUE;        IF String.EqualString[macroTable[macroIndex].macro, "MDR¬"L] THEN {          mdr ¬ TRUE; mdrThisPhrase ¬ TRUE};        IF String.EqualString[macroTable[macroIndex].macro, "Abus¬"L] THEN {          aBusThisPhrase ¬ TRUE; aBus ¬ TRUE};        IF String.EqualString[macroTable[macroIndex].macro, "Bbus¬"L] THEN {          bBus ¬ TRUE; bBusThisPhrase ¬ TRUE};	IF String.EqualString[macroTable[macroIndex].macro, "ALU¬"L] THEN           aluGets ¬ TRUE;        IF phrase.currentElement.nextElement # NIL THEN {          EncodeOnePattern[            phrase, @macroTable[macroIndex].pattern, Assignment[            macro[macroIndex]]];          EncodeRHS[phrase];          IF mdrThisPhrase THEN            SELECT phrase.expression.operand1 FROM              aBus => NULL;              zero => EncodeZero[phrase];              ENDCASE => {SyntaxError[phrase, unexpectedRHS]; GOTO SyntaxError};          IF aBusThisPhrase THEN            SELECT phrase.expression.operand1 FROM              aBus => NULL;              zero => EncodeZero[phrase];              ENDCASE => {SyntaxError[phrase, unexpectedRHS]; GOTO SyntaxError};          IF bBusThisPhrase THEN            SELECT phrase.expression.operand1 FROM              bBus => NULL;              zero => EncodeZero[phrase];              ENDCASE => {SyntaxError[phrase, unexpectedRHS]; GOTO SyntaxError}}        ELSE GOTO SyntaxError;        END;      ENDCASE => {SyntaxError[phrase, unexpectedLHS]; GOTO SyntaxError};    EXITS SyntaxError => phrase.syntaxError ¬ TRUE;    END;  -- of SyntaxError block    RETURN;    END;  --end EncodeLHS  EncodeMacro: PROCEDURE [phrase: PhrasePtr, macroIndex: MacroIndex] =    BEGIN    -- Given a MacroIndex, try to encode the macro in each existing Encoding record for the given Phrase.  We create a new chain of Encoding records for the Phrase.  The MacroIndex points to the first entry in the macro table for the given macro. There may be more than one possible encoding that follows the first entry.    extract: BOOLEAN ¬ FALSE;    firstMacro: MacroPatternPtr;    lastMacro: MacroPatternPtr;    lastNextEncodingPtrInNewChain: LONG POINTER TO EncodingPtr;    nextMacro: MacroPatternPtr;    nextOldEncoding: EncodingPtr;    oldEncodingList: EncodingPtr;    successful: BOOLEAN ¬ FALSE;  -- Assume not successful.    trialEncoding: EncodingPtr;    BEGIN  --error block    -- Point to the first entry in the macro table for the given macroIndex. There may be other possible encodings that follow this entry.    firstMacro ¬ @macroTable[macroIndex];    phrase.arg3 ¬ macroIndex;    IF String.EqualString[firstMacro.macro, "EXTRACT"L] THEN {      IF NOT EncodeExtract[phrase] THEN GOTO SyntaxError      ELSE {        IF phrase.expression.operand1 = zero THEN firstMacro.pattern.rA ¬ x;        IF phrase.expression.operand2 = zero THEN firstMacro.pattern.rB ¬ x};      extract ¬ TRUE};    IF String.EqualString[firstMacro.macro, "pop"L] THEN phrase.isPop ¬ TRUE;    IF String.EqualString[firstMacro.macro, "push"L] THEN phrase.isPush ¬ TRUE;    IF String.EqualString[firstMacro.macro, "OffsetAdder"L] THEN      offsetAdder ¬ TRUE;    IF String.EqualString[firstMacro.macro, "Read"L] THEN      cycleTypeSpecified ¬ TRUE;    IF String.EqualString[firstMacro.macro, "Write"L] THEN      cycleTypeSpecified ¬ TRUE;    IF String.EqualString[firstMacro.macro, "DoubleRead"L] THEN      cycleTypeSpecified ¬ TRUE;    IF String.EqualString[firstMacro.macro, "DoubleWrite"L] THEN      cycleTypeSpecified ¬ TRUE;    IF String.EqualString[firstMacro.macro, "PopIB"L] THEN      popIB ¬ TRUE;    -- Save the old list of encoding records.  The old list will be replaced by a new list.    oldEncodingList ¬ phrase.encoding;    phrase.encoding ¬ NIL;    trialEncoding ¬ AllocateEncodingRecord[];    lastNextEncodingPtrInNewChain ¬ @phrase.encoding;    nextOldEncoding ¬ oldEncodingList;    UNTIL nextOldEncoding = NIL DO  -- once for each encoding in the list      nextMacro ¬ firstMacro;      DO  -- once for each possible encoding of the macro        -- Move the old encoding to trialEncoding so that we can modify it and still have the unmodified version.        trialEncoding­ ¬ nextOldEncoding­;        IF EncodePattern[          phrase, @nextMacro.pattern, trialEncoding, Assignment[macro[macroIndex]]]          THEN          BEGIN          -- We have an encoding of the macro that works.  Chain it onto the list of encoding records for this phrase.          lastNextEncodingPtrInNewChain­ ¬ trialEncoding;          trialEncoding.nextEncoding ¬ NIL;          lastNextEncodingPtrInNewChain ¬ @trialEncoding.nextEncoding;          trialEncoding ¬ AllocateEncodingRecord[];          successful ¬ TRUE;          END;        lastMacro ¬ nextMacro;        nextMacro ¬ nextMacro + SIZE[MacroPattern];        IF NOT String.EqualString[lastMacro.macro, nextMacro.macro] THEN EXIT;        ENDLOOP;      nextOldEncoding ¬ nextOldEncoding.nextEncoding;      ENDLOOP;    EXITS SyntaxError => phrase.syntaxError ¬ TRUE;    END;  --error block     -- If any patterns could not be encoded, error messages are chained onto tempFormatErrorMsgs.  If we found a pattern that works, we delete the temp error messages.  If no pattern could be encoded, we will print all of the error messages.    IF extract THEN {      firstMacro.pattern.rA ¬ arg1;  --restore macroTable      firstMacro.pattern.rB ¬ arg2;      phrase.expression.operand1 ¬ zero;  --make sure doesn't go thru EncodeExpression      phrase.expression.operand2 ¬ zero};    IF NOT successful THEN MakeTempErrorMsgsPermanent[phrase];    RETURN;    END;  EncodeOnePattern: PROCEDURE [    phrase: PhrasePtr, pattern: PatternPtr, assignment: Assignment] =    --The current pattern has only one way to encoded.  See if it will fit into the trial encoding.    BEGIN    nextOldEncoding: EncodingPtr;    successful: BOOLEAN ¬ FALSE;  -- Assume not successful.    trialEncoding: EncodingPtr;    lastNextEncodingPtrInNewChain: LONG POINTER TO EncodingPtr;    trialEncoding ¬ AllocateEncodingRecord[];    lastNextEncodingPtrInNewChain ¬ @phrase.encoding;    -- The old list will be replaced by a new list.    nextOldEncoding ¬ phrase.encoding;    phrase.encoding ¬ NIL;    UNTIL nextOldEncoding = NIL DO  -- once for each encoding in the list      trialEncoding­ ¬ nextOldEncoding­;      IF EncodePattern[phrase, pattern, trialEncoding, assignment] THEN        BEGIN        -- We have an encoding of the register that works.  Chain it onto the list of encoding records for this phrase.        lastNextEncodingPtrInNewChain­ ¬ trialEncoding;        trialEncoding.nextEncoding ¬ NIL;        lastNextEncodingPtrInNewChain ¬ @trialEncoding.nextEncoding;        trialEncoding ¬ AllocateEncodingRecord[];        successful ¬ TRUE;        END;      nextOldEncoding ¬ nextOldEncoding.nextEncoding;      ENDLOOP;    IF NOT successful THEN      BEGIN      SyntaxError[phrase, unexpectedLHS];      phrase.syntaxError ¬ TRUE;      MakeTempErrorMsgsPermanent[phrase];      RETURN;      END;    -- If any patterns could not be encoded, error messages are chained onto tempFormatErrorMsgs.  If we found a pattern that works, we delete the temp error messages.  If no pattern could be encoded, we will print all of the error messages.    END;  --EncodeOnePattern  EncodeOperation: PROCEDURE [phrase: PhrasePtr] RETURNS [noSyntaxError: BOOLEAN] =    BEGIN    -- Called by EncodeRHS when the first operand has been found.  Look for and encode the operation that follows the first operand of an expression. The operation (if any) will be encoded in phrase.expression.operation.    noSyntaxError ¬ TRUE;    IF aBusThisPhrase OR bBusThisPhrase OR mdrThisPhrase THEN      IF phrase.currentElement.nextElement = NIL THEN {        phrase.currentElement ¬ phrase.currentElement.nextElement; RETURN}      ELSE {        SyntaxError[phrase, unexpectedRHS];        noSyntaxError ¬ FALSE;        phrase.currentElement ¬ NIL;        RETURN};    IF phrase.currentElement.nextElement = NIL THEN {      IF phrase.arg3 IN [linkSize..macroArrowSize - 2) THEN  --memory operation?        phrase.currentElement ¬ phrase.currentElement.nextElement      ELSE MakeOperation[phrase];      operationsEncountered ¬ operationsEncountered + 1;      RETURN}    ELSE phrase.currentElement ¬ phrase.currentElement.nextElement;    operationsEncountered ¬ operationsEncountered + 1;    WITH phrase.currentElement.elementRec SELECT FROM      plus =>        BEGIN        IF phrase.arg1.negate THEN          BEGIN          SyntaxError[phrase, unexpectedLHS];          noSyntaxError ¬ FALSE;          RETURN;          END;        phrase.expression.operation ¬ aPlusB;        phrase.expression.carry ¬ zero;        noSyntaxError ¬ EncodeSecondOperand[phrase];        END;      minus =>        BEGIN        IF phrase.arg1.negate THEN          BEGIN          SyntaxError[phrase, unexpectedLHS];          noSyntaxError ¬ FALSE;          RETURN;          END;        phrase.expression.operation ¬ minus;        phrase.expression.carry ¬ one;        noSyntaxError ¬ EncodeSecondOperand[phrase];        END;      mpy =>        BEGIN        IF phrase.arg1.negate THEN          BEGIN          SyntaxError[phrase, unexpectedLHS];          noSyntaxError ¬ FALSE;          RETURN;          END;        phrase.expression.operation ¬ mpy;        IF phrase.currentElement.nextElement.nextElement # NIL THEN          SyntaxError[phrase, unexpectedLHS];        noSyntaxError ¬ EncodeSecondOperand[phrase];        END;      logical =>        BEGIN        SELECT logicalOperation FROM          and => phrase.expression.operation ¬ and;          or => phrase.expression.operation ¬ or;          xor => phrase.expression.operation ¬ xor;          nand => phrase.expression.operation ¬ Nand;          nor => phrase.expression.operation ¬ Nor;          nxor => phrase.expression.operation ¬ Nxor;          ENDCASE;        noSyntaxError ¬ EncodeSecondOperand[phrase];        END;      ENDCASE =>        BEGIN SyntaxError[phrase, operationMissing]; noSyntaxError ¬ FALSE; END;    RETURN;    END;  EncodePhrase: PROCEDURE [phrase: PhrasePtr] =    BEGIN    phrase.expression ¬ nullExpression;    phrase.encoding ¬ AllocateEncodingRecord[];    phrase.currentElement ¬ phrase.firstElement;    phrase.syntaxError ¬ phrase.formatError ¬ negated ¬ aBusThisPhrase ¬ bBusThisPhrase ¬ mdrThisPhrase ¬ QAssigned ¬ FALSE;    phrase.errorMsgs ¬ phrase.tempErrorMsgs ¬ NIL;    EncodeLHS[phrase];    RETURN;    END;  --of procedure EncodePhrase  EncodePlusOrMinusOne: PROCEDURE [phrase: PhrasePtr]    RETURNS [noSyntaxError: BOOLEAN] =  --new    BEGIN    -- This is called by EncodeSecondOperand when a second operand has been encountered.  Look for plus or minus one that may follow expression.    noSyntaxError ¬ TRUE;    BEGIN  -- error block    IF (phrase.currentElement ¬ phrase.currentElement.nextElement) = NIL THEN      RETURN;    WITH phrase.currentElement.elementRec SELECT FROM      plus =>        BEGIN        IF phrase.expression.operation # aPlusB THEN          BEGIN SyntaxError[phrase, invalidPlus]; GO TO SyntaxError; END;        SELECT NextElementIsOneOrZero[phrase] FROM          bad => BEGIN SyntaxError[phrase, oneMissing]; GO TO SyntaxError; END;          one => phrase.expression.carry ¬ one;          zero => phrase.expression.carry ¬ zero;          ENDCASE;        END;      minus =>        BEGIN        IF phrase.expression.operation # minus THEN          BEGIN SyntaxError[phrase, invalidMinus]; GO TO SyntaxError; END;        SELECT NextElementIsOneOrZero[phrase] FROM          bad => BEGIN SyntaxError[phrase, oneMissing]; GO TO SyntaxError; END;          zero => phrase.expression.carry ¬ one;          one => phrase.expression.carry ¬ zero;          ENDCASE;        END;      ENDCASE =>        BEGIN SyntaxError[phrase, missingPlusOrMinus]; GO TO SyntaxError; END;    EXITS SyntaxError => BEGIN noSyntaxError ¬ FALSE; RETURN; END;    END;  -- of error block    phrase.currentElement ¬ phrase.currentElement.nextElement;    END;  --of procedure EncodePlusOrMinusOne  EncodeRegisterLHS: PROCEDURE [    phrase: PhrasePtr, type: RegisterType, register: CARDINAL] =    BEGIN    assignment: Assignment;  -- used to remember which encoding fields were caused by a register assignment    pattern: PatternPtr;    SELECT type FROM      R =>        BEGIN        assignment ¬ [register[R]];        pattern ¬ @patternAssignR;        phrase.dest ¬ register;        END;      D =>        BEGIN        assignment ¬ [register[D]];        pattern ¬ @patternAssignD;        phrase.dest ¬ register;        END;      aUpper8 =>        BEGIN        assignment ¬ [register[aUpper8]];        pattern ¬ @patternAssignAU8;        phrase.dest ¬ register;        END;      aUpper16 =>        BEGIN        assignment ¬ [register[aUpper16]];        pattern ¬ @patternAssignAU16;        phrase.dest ¬ register;        END;      aLower16 =>        BEGIN        assignment ¬ [register[aLower16]];        pattern ¬ @patternAssignAL16;        phrase.dest ¬ register;        END;      CSBank =>        BEGIN assignment ¬ [register[CSBank]]; pattern ¬ @patternAssignCSBank; END;      stkPtr =>        BEGIN assignment ¬ [register[stkPtr]]; pattern ¬ @patternAssignStk; END;      stkMinus2 =>        BEGIN        assignment ¬ [register[stkMinus2]];        pattern ¬ @patternAssignStkMinus2;        END;      stkMinus1 =>        BEGIN        assignment ¬ [register[stkMinus1]];        pattern ¬ @patternAssignStkMinus1;        END;      stkZero =>        BEGIN        assignment ¬ [register[stkZero]];        pattern ¬ @patternAssignStkZero;        END;      stkPlus1 =>        BEGIN        assignment ¬ [register[stkPlus1]];        pattern ¬ @patternAssignStkPlus1;        END;      Q =>         BEGIN 	assignment ¬ [register[Q]];        pattern ¬ @patternAssignQ;	QAssigned ¬ TRUE; 	END;      CIP => BEGIN assignment ¬ [register[CIP]]; pattern ¬ @patternAssignCIP; END;      timerHigh =>        BEGIN        assignment ¬ [register[timerHigh]];        pattern ¬ @patternAssignTimerHigh;        END;      timerLow =>        BEGIN        assignment ¬ [register[timerLow]];        pattern ¬ @patternAssignTimerLow;        END;      prescaler =>        BEGIN        assignment ¬ [register[prescaler]];        pattern ¬ @patternAssignPrescaler;        END;      ENDCASE =>        BEGIN        SyntaxError[phrase, unexpectedLHS];        phrase.syntaxError ¬ TRUE;        MakeTempErrorMsgsPermanent[phrase];        RETURN;        END;    EncodeOnePattern[phrase, pattern, assignment];    END;  --of procedure EncodeRegisterLHS  EncodeRHS: PROCEDURE [phrase: PhrasePtr] =    BEGIN    -- Look for and encode the right hand side of an expression.  This is called by EncodeLHS when a register assignment or macroArrow has been found as the first element of a phrase.    BEGIN  -- Error block    IF (phrase.currentElement ¬ phrase.currentElement.nextElement) = NIL THEN      RETURN;  -- no right hand side    WITH phrase.currentElement.elementRec SELECT FROM      macroRHS =>        BEGIN        IF phrase.currentElement.nextElement # NIL THEN {	  IF memory AND (String.EqualString[macroTable[macroIndex].macro, "MD"L] OR String.EqualString[macroTable[macroIndex].macro, "MDu"L]) THEN {	  --if true phrase looks like MAR ¬ RBusDest ¬ [MD, A + offset] and only 1 encoding will exist on phrase.encoding so it is permissable to modify phrase.encoding	    IF phrase.arg3 = startMemorySize - 1 THEN  {--Map ¬	      SyntaxError[phrase, unexpectedRHS];	      GOTO SyntaxError};	    phrase.encoding.mo.value ¬ moU;	    phrase.encoding.mo.assignment ¬ Assignment[macro[macroIndex]];	    EncodeRHS[phrase];	    RETURN}          ELSE {	    IF macroTable[macroIndex].macro[0] = 'M AND phrase.currentElement.nextElement # NIL THEN {	      SyntaxError[phrase, unexpectedRHS];	      GOTO SyntaxError};	    EncodeMacro[phrase, macroIndex];	    IF NOT EncodeOperation[phrase] THEN GOTO SyntaxError}}	ELSE {	  EncodeMacro[phrase, macroIndex];	  IF phrase.arg3 > macroArrowSize + 1 THEN  --if ib.high or ib.low and no operation then error => unexpected end of phrase	    phrase.currentElement ¬ phrase.currentElement.nextElement};        END;      macro =>         BEGIN	IF String.EqualString[macroTable[macroIndex].macro, "EXTRACT"L] THEN	  EncodeMacro[phrase, macroIndex]	ELSE {	  SyntaxError[phrase, unexpectedRHS];	  GOTO SyntaxError};	END;      register =>        BEGIN        IF NextElementIsArrow[phrase] THEN          BEGIN          -- We have a multiple assignment statement	  IF phrase.arg3 = 0 THEN  --register was found as previous element	    IF registerType = Q THEN {	      assignment: Assignment ¬ Assignment[register[Q]];	      pattern: PatternPtr ¬ @patternAssignQSp1;	      EncodeOnePattern[phrase, pattern, assignment]}	    ELSE {	      IF QAssigned THEN {  --Q was assigned previously in the phrase	        assignment: Assignment ¬ Assignment[register[Q]];	        pattern: PatternPtr ¬ @patternAssignQSp1;	        phrase.encoding.rD ¬ FieldAssignment[Assignment[null[]], rDNoop];	        EncodeOnePattern[phrase, pattern, assignment]};	      EncodeRegisterLHS[phrase, registerType, regnum]}	  ELSE IF phrase.arg3 NOT IN [linkSize..startMemorySize] THEN {	    SyntaxError[phrase, unexpectedLHS];	    GOTO SyntaxError}	  ELSE   --MAR ¬ or Map ¬ or MDR ¬ encoded previously	    IF phrase.encoding.rD.value = rDNoop THEN  --a register hasn't been assigned to	      EncodeRegisterLHS[phrase, registerType, regnum]	    ELSE  --register has been assigned to	      IF QAssigned THEN {	        assignment: Assignment ¬ Assignment[register[Q]];	        pattern: PatternPtr ¬ @patternAssignQSp1;	        phrase.encoding.rD ¬ FieldAssignment[Assignment[null[]], rDNoop];	        EncodeOnePattern[phrase, pattern, assignment];		EncodeRegisterLHS[phrase, registerType, regnum]}	      ELSE 	        IF registerType = Q THEN {		  assignment: Assignment ¬ Assignment[register[Q]];	          pattern: PatternPtr ¬ @patternAssignQSp1;	          EncodeOnePattern[phrase, pattern, assignment]}	        ELSE EncodeRegisterLHS[phrase, registerType, regnum];              phrase.currentElement ¬ phrase.currentElement.nextElement;          IF phrase.currentElement.nextElement = NIL THEN            BEGIN            SyntaxError[phrase, noRHS];            GO TO SyntaxError;  -- syntax error if no right hand side            END;          EncodeRHS[phrase];          RETURN;          END  -- of multiple assignment        ELSE          BEGIN  -- simple assignment            SELECT registerType FROM            D =>              BEGIN              phrase.expression.operand1 ¬ aBus;              phrase.arg1 ¬ [regnum, D, negated];              END;            CIP => {              phrase.expression.operand1 ¬ aBus; phrase.arg1 ¬ [0, CIP, negated]};            CSBank => {              phrase.expression.operand1 ¬ aBus;              phrase.arg1 ¬ [0, CSBank, negated]};            prescaler => {              phrase.expression.operand1 ¬ aBus;              phrase.arg1 ¬ [0, prescaler, negated]};            chipVersion => {              phrase.expression.operand1 ¬ aBus;              phrase.arg1 ¬ [0, chipVersion, negated]};            stkPtr => {              phrase.expression.operand1 ¬ aBus;              phrase.arg1 ¬ [0, stkPtr, negated]};            aUpper16 =>              BEGIN              phrase.expression.operand1 ¬ aBus;              phrase.arg1 ¬ [regnum, aUpper16, negated];              END;            aLower16 =>              BEGIN              phrase.expression.operand1 ¬ aBus;              phrase.arg1 ¬ [regnum, aLower16, negated];              END;            R =>              BEGIN              phrase.expression.operand1 ¬ bBus;              phrase.arg1 ¬ [regnum, R, negated];              END;            timerHigh => {              phrase.expression.operand1 ¬ aBus;              phrase.arg1 ¬ [0, timerHigh, negated]};            timerLow => {              phrase.expression.operand1 ¬ aBus;              phrase.arg1 ¬ [0, timerLow, negated]};            Q => {              phrase.expression.operand1 ¬ bBus; phrase.arg1 ¬ [0, Q, negated]};            ibCtr => {              phrase.expression.operand1 ¬ aBus;              phrase.arg1 ¬ [0, ibCtr, negated]};            ib => {              phrase.expression.operand1 ¬ bBus; phrase.arg1 ¬ [0, ib, negated]};            ibSE => {              phrase.expression.operand1 ¬ bBus; phrase.arg1 ¬ [0, ibSE, negated]};            stkMinus2 =>              BEGIN              phrase.expression.operand1 ¬ aBus;              phrase.isStk ¬ TRUE;              phrase.arg1 ¬ [0, stkMinus2, negated]              END;            stkMinus1 =>              BEGIN              phrase.expression.operand1 ¬ aBus;              phrase.isStk ¬ TRUE;              phrase.arg1 ¬ [0, stkMinus1, negated]              END;            stkZero =>              BEGIN              phrase.expression.operand1 ¬ aBus;              phrase.isStk ¬ TRUE;              phrase.arg1 ¬ [0, stkZero, negated]              END;            stkPlus1 =>              BEGIN              phrase.expression.operand1 ¬ aBus;              phrase.isStk ¬ TRUE;              phrase.arg1 ¬ [0, stkPlus1, negated]              END;            A =>              BEGIN              phrase.expression.operand1 ¬ aBus;              phrase.arg1 ¬ [regnum, A, negated];              aFile ¬ TRUE;              END;            ENDCASE =>              BEGIN              SyntaxError[phrase, unexpectedRHS];              phrase.syntaxError ¬ TRUE;              END;          IF NOT EncodeOperation[phrase] THEN GO TO SyntaxError;          END;  -- of simple assignment        END;      macroArrow =>        BEGIN        IF phrase.arg3 # 0 THEN {          SyntaxError[phrase, unexpectedRHS]; GOTO SyntaxError}        ELSE {          phrase.arg3 ¬ macroIndex;          IF macroIndex IN [linkSize..startMemorySize) THEN memory ¬ TRUE;          IF String.EqualString[macroTable[macroIndex].macro, "MDR¬"L] THEN            mdr ¬ TRUE;          IF String.EqualString[macroTable[macroIndex].macro, "Rbus¬"L] THEN {            SyntaxError[phrase, multipleArrows]; GOTO SyntaxError};          IF phrase.currentElement.nextElement # NIL THEN {            EncodeOnePattern[              phrase, @macroTable[macroIndex].pattern, Assignment[              macro[macroIndex]]];            EncodeRHS[phrase];            IF mdr AND phrase.expression.operand1 # aBus THEN {              SyntaxError[phrase, unexpectedRHS]; GOTO SyntaxError}            ELSE RETURN}          ELSE GOTO SyntaxError};        END;      minus =>        BEGIN        phrase.expression.operand1 ¬ zero;        phrase.expression.operation ¬ minus;        phrase.expression.carry ¬ one;        IF NOT EncodeSecondOperand[phrase] THEN GO TO SyntaxError;        END;      not =>        BEGIN        IF NOT negated THEN negated ¬ TRUE        ELSE {SyntaxError[phrase, doubleNot]; GO TO SyntaxError};        EncodeRHS[phrase];	IF phrase.expression.operation # and THEN {SyntaxError[phrase, unexpectedRHS]; GO TO SyntaxError};        RETURN;        END;      constant =>        BEGIN        SELECT value FROM          0 => phrase.expression.operand1 ¬ zero;          ENDCASE => phrase.expression.operand1 ¬ bBus;        phrase.arg1.arg ¬ value;        phrase.arg1.negate ¬ negated;        IF NOT EncodeOperation[phrase] THEN GO TO SyntaxError;        END;      ENDCASE => BEGIN SyntaxError[phrase, unexpectedRHS]; GOTO SyntaxError; END;    IF phrase.currentElement # NIL THEN      BEGIN SyntaxError[phrase, endOfPhrase]; GO TO SyntaxError; END;    EncodeExpression[phrase];    EXITS SyntaxError => phrase.syntaxError ¬ TRUE;    END;  -- OF error block    RETURN;    END;  --of procedure EncodeRHS  EncodeSecondOperand: PROCEDURE [phrase: PhrasePtr]    RETURNS [noSyntaxError: BOOLEAN] =  --new    BEGIN    -- Look for and encode the operand that follows the operation.  This is called by EncodeOperation when an operation (plus, minus or logical) has been encountered.    noSyntaxError ¬ TRUE;    BEGIN  -- error block    IF (phrase.currentElement ¬ phrase.currentElement.nextElement) = NIL THEN      BEGIN      SyntaxError[phrase, noOperand];      GO TO SyntaxError;  -- error if operation is not followed by operand      END;    WITH phrase.currentElement.elementRec SELECT FROM      register =>        BEGIN        phrase.expression.operand2 ¬ zero;        SELECT registerType FROM          R =>            BEGIN            phrase.expression.operand2 ¬ bBus;            phrase.arg2 ¬ [regnum, R, negated];            END;          chipVersion => {            phrase.expression.operand2 ¬ aBus;            phrase.arg2 ¬ [0, chipVersion, negated]};          Q => {phrase.expression.operand2 ¬ bBus; phrase.arg2 ¬ [0, Q, negated]};          stkPtr => {            phrase.expression.operand2 ¬ aBus; phrase.arg2 ¬ [0, stkPtr, negated]};          CSBank => {            phrase.expression.operand2 ¬ aBus; phrase.arg2 ¬ [0, CSBank, negated]};          D =>            BEGIN            phrase.expression.operand2 ¬ aBus;            phrase.arg2 ¬ [regnum, D, negated];            END;          timerHigh => {            phrase.expression.operand2 ¬ aBus;            phrase.arg2 ¬ [0, timerHigh, negated]};          timerLow => {            phrase.expression.operand2 ¬ aBus;            phrase.arg2 ¬ [0, timerLow, negated]};          CIP => {            phrase.expression.operand2 ¬ aBus; phrase.arg2 ¬ [0, CIP, negated]};          aUpper16 =>            BEGIN            phrase.expression.operand2 ¬ aBus;            phrase.arg2 ¬ [regnum, aUpper16, negated]            END;          aLower16 =>            BEGIN            phrase.expression.operand2 ¬ aBus;            phrase.arg2 ¬ [regnum, aLower16, negated];            END;          ib => {            phrase.expression.operand2 ¬ bBus; phrase.arg2 ¬ [0, ib, negated]};          ibSE => {            phrase.expression.operand2 ¬ bBus; phrase.arg2 ¬ [0, ibSE, negated]};          ibCtr => {            phrase.expression.operand2 ¬ aBus; phrase.arg2 ¬ [0, ibCtr, negated]};          stkMinus2 =>            BEGIN            phrase.expression.operand2 ¬ aBus;            phrase.isStk ¬ TRUE;            phrase.arg2 ¬ [0, stkMinus2, negated]            END;          stkMinus1 =>            BEGIN            phrase.expression.operand2 ¬ aBus;            phrase.isStk ¬ TRUE;            phrase.arg2 ¬ [0, stkMinus1, negated]            END;          stkZero =>            BEGIN            phrase.expression.operand2 ¬ aBus;            phrase.isStk ¬ TRUE;            phrase.arg2 ¬ [0, stkZero, negated]            END;          stkPlus1 =>            BEGIN            phrase.expression.operand2 ¬ aBus;            phrase.isStk ¬ TRUE;            phrase.arg2 ¬ [0, stkPlus1, negated]            END;          prescaler => {            phrase.expression.operand2 ¬ aBus;            phrase.arg2 ¬ [0, prescaler, negated]};          A =>            BEGIN            phrase.expression.operand2 ¬ aBus;            phrase.arg2 ¬ [regnum, A, negated];            aFile ¬ TRUE;            END;          ENDCASE => {SyntaxError[phrase, unexpectedRHS]; GOTO SyntaxError};        noSyntaxError ¬ EncodePlusOrMinusOne[phrase];        END;      macroRHS =>        BEGIN		IF macroTable[macroIndex].macro[0] = 'M THEN {	  SyntaxError[phrase, unexpectedRHS]; GOTO SyntaxError};        EncodeMacro[phrase, macroIndex];	noSyntaxError ¬ EncodePlusOrMinusOne[phrase];        END;      not =>        BEGIN        IF NOT negated THEN negated ¬ TRUE        ELSE {SyntaxError[phrase, doubleNot]; GOTO SyntaxError};        noSyntaxError ¬ EncodeSecondOperand[phrase];	IF phrase.expression.operation # and THEN {	  SyntaxError[phrase, unexpectedRHS]; GOTO SyntaxError};        END;      constant =>        BEGIN        SELECT phrase.expression.operation FROM          aPlusB =>            SELECT value FROM              0 =>                BEGIN                phrase.expression.operand2 ¬ zero;                IF phrase.currentElement.nextElement = NIL THEN {                  phrase.expression.operation ¬ xPlusCI;                  phrase.expression.carry ¬ zero};                END;              1 =>                BEGIN                IF phrase.currentElement.nextElement = NIL THEN {                  phrase.expression.operand2 ¬ zero;                  phrase.expression.operation ¬ xPlusCI;                  phrase.expression.carry ¬ one}                ELSE GOTO normal;                END;              ENDCASE => GOTO normal;          minus =>            SELECT value FROM              0 =>                BEGIN                phrase.expression.operand2 ¬ zero;                IF phrase.currentElement.nextElement = NIL THEN                  phrase.expression.carry ¬ one;                END;              1 =>                BEGIN                IF phrase.currentElement.nextElement = NIL THEN {                  phrase.expression.operand2 ¬ zero;                  phrase.expression.carry ¬ zero}                ELSE GOTO normal;                END;              ENDCASE => GOTO normal;          ENDCASE =>            SELECT value FROM              0 => phrase.expression.operand2 ¬ zero;              1 =>                BEGIN                phrase.expression.operand2 ¬ bBus;                phrase.arg2.arg ¬ value;                END;              ENDCASE => GOTO normal;        noSyntaxError ¬ EncodePlusOrMinusOne[phrase];        phrase.arg2.negate ¬ negated;        EXITS          normal =>            BEGIN            phrase.arg2.arg ¬ value;            phrase.arg2.negate ¬ negated;            phrase.expression.operand2 ¬ bBus;            noSyntaxError ¬ EncodePlusOrMinusOne[phrase];            END;        END;      ENDCASE => SyntaxError[phrase, unexpectedRHS];    EXITS SyntaxError => noSyntaxError ¬ FALSE;    END;  -- OF error block    RETURN;    END;  EncodeStatement: PUBLIC PROCEDURE [statement: StatementPtr]    RETURNS [successful: BOOLEAN] =    BEGIN    -- Create one or more Encoding records for each Phrase of the Statement.  Encoding of the Phrase will be aborted if a syntax error is encountered, but encoding will continue if format or timing errors are detected.  If not successful, error messsages are queued on phrase.errorMsgs.      formatError: BOOLEAN ¬ FALSE;    phrase: PhrasePtr ¬ statement.firstPhrase;    syntaxError: BOOLEAN ¬ FALSE;    operationsEncountered ¬ 0;    UNTIL phrase = NIL DO      EncodePhrase[phrase];      syntaxError ¬ syntaxError OR phrase.syntaxError;      formatError ¬ formatError OR phrase.formatError;      phrase ¬ phrase.nextPhrase;      ENDLOOP;        IF memory OR offsetAdder THEN       operationsEncountered ¬ operationsEncountered - 1;  --use of the offset adder isn't included in count    IF operationsEncountered > 0 THEN       expression ¬ TRUE    ELSE expression ¬ FALSE;        statement.formatError ¬ formatError;    statement.syntaxError ¬ syntaxError;    RETURN[NOT (syntaxError OR formatError)];    END;  EncodeZero: PROCEDURE [phrase: PhrasePtr] =    BEGIN    -- Try to encode phrase.expression in each existing Encoding record for the given Phrase.  We create a new chain of Encoding records for the Phrase.  There may be more than one possible encoding of the expression that follows the first entry. Only called if the first operand is zero.    encoding: EncodingPtr ¬ phrase.encoding;    firstExpression: ExpressionPatternPtr;    limit: CARDINAL ¬ 0;  --size of expression table array for current operation    position: CARDINAL ¬ 0;  --position of pattern within expression table array of current pattern    secondExpression: PatternPtr;    BEGIN  -- Begin EncodeZero error block.    trialEncoding ¬ AllocateEncodingRecord[];    lastNextEncodingPtrInNewChain ¬ @phrase.encoding;    expressionFound ¬ FALSE;    IF phrase.encoding = NIL THEN RETURN;    [firstExpression, secondExpression, position, limit] ¬ FindExpression[phrase];    IF firstExpression = NIL THEN      BEGIN SyntaxError[phrase, invalidExpression]; GO TO SyntaxError; END;    IF phrase.expression.operation = x AND bBusThisPhrase THEN {  --point to rB encodings      firstExpression ¬ firstExpression + SIZE[ExpressionPattern];      position ¬ position + 1};    -- Save the old list of encoding records.  The old list will be replaced by a new list.    nextOldEncoding ¬ phrase.encoding;    phrase.encoding ¬ NIL;    UNTIL nextOldEncoding = NIL DO  -- once for each encoding in the list      SearchForPattern[phrase, firstExpression, secondExpression, position, limit];      nextOldEncoding ¬ nextOldEncoding.nextEncoding;      ENDLOOP;    EXITS SyntaxError => phrase.syntaxError ¬ TRUE;    -- FormatError => NULL;    END;  -- of SyntaxError block    -- If any patterns could not be encoded, error messages are chained onto tempFormatErrorMsgs.  If we found a pattern that works, we delete the temp error messages.  If no pattern could be encoded, we will print all of the error messages.    IF NOT expressionFound THEN MakeTempErrorMsgsPermanent[phrase];    RETURN;    END;  --of procedure EncodeZeroB  FindExpression: PROCEDURE [phrase: PhrasePtr]    RETURNS [eP: ExpressionPatternPtr, pP: PatternPtr, position, limit: CARDINAL] =    --find the first pattern matching the operation and arguments    BEGIN    expressionArgs: ExpressionArgs ¬ [      phrase.expression.operand1, phrase.expression.operand2];    i: CARDINAL;    table: LONG DESCRIPTOR FOR ARRAY OF ExpressionPattern;    table ¬      SELECT phrase.expression.operation FROM        x => patternOpx,        or => patternOpor,        Nor => patternOpNor,        and => patternOpand,        Nand => patternOpNand,        xor => patternOpxor,        Nxor => patternOpNxor,        aPlusB => patternOpAPlusB,        xPlusCI => patternOpXPlusCI,        minus => patternOpminus,        mpy => patternOpmpy,        ENDCASE => patternOpx;    limit ¬ LENGTH[table];    eP ¬ NIL;    position ¬ 0;    FOR i IN [0..LENGTH[table]) DO  --Find matching operands      position ¬ i;      IF table[i].expressionArgs = expressionArgs THEN        BEGIN eP ¬ @table[i]; EXIT; END;      ENDLOOP;    pP ¬      SELECT phrase.expression.carry FROM        zero => @ETB.patternCin0,        one => @ETB.patternCin1,        ENDCASE => @ETB.patternCinX;    END;  --end FindExpression  MakeExtract: PROCEDURE [phrase: PhrasePtr] =    --encode EXTRACT phrase    BEGIN    pattern: Pattern;    assignment: Assignment ¬ [expression[]];    pattern ¬ Pattern[op: one, rB: arg1, shift: value];    phrase.arg3 ¬ 0;    EncodeOnePattern[phrase, @pattern, assignment];    END;  --end MakeExtract  MakeOperation: PROCEDURE [phrase: PhrasePtr] =    --since the microcoder has not provided and operation one must be selected in order to encode the phrase.  constants use B + carryin. Bbus sources use the extractor and Abus source use A + carryin.    BEGIN    IF (phrase.currentElement.elementRec.type = constant) THEN {      IF NOT phrase.arg1.negate THEN phrase.expression.operation ¬ xPlusCI      ELSE {SyntaxError[phrase, invalidExpression]; phrase.syntaxError ¬ TRUE}}    ELSE {      WITH phrase.currentElement.elementRec SELECT FROM        register =>          IF registerType IN [A..ibCtr] THEN            IF NOT phrase.arg1.negate THEN phrase.expression.operation ¬ xPlusCI            ELSE {SyntaxError[phrase, unexpectedRHS]; phrase.syntaxError ¬ TRUE}          ELSE            IF registerType IN [Q..ibSE] THEN {              IF String.EqualString[macroTable[phrase.arg3].macro, "ALU¬"L] THEN                IF NOT phrase.arg1.negate THEN                  phrase.expression.operation ¬ xPlusCI                ELSE {                  SyntaxError[phrase, unexpectedRHS]; phrase.syntaxError ¬ TRUE}              ELSE {MakeExtract[phrase]; phrase.expression ¬ nullExpression}}            ELSE {SyntaxError[phrase, unexpectedRHS]; phrase.syntaxError ¬ TRUE}        ENDCASE => {          SyntaxError[phrase, unexpectedRHS]; phrase.syntaxError ¬ TRUE}};    phrase.currentElement ¬ phrase.currentElement.nextElement;    END;  --end MakeOperation  NextElementIsArrow: PROCEDURE [phrase: PhrasePtr] RETURNS [isArrow: BOOLEAN] =    BEGIN    IF phrase.currentElement.nextElement = NIL THEN isArrow ¬ FALSE    ELSE      IF phrase.currentElement.nextElement.elementRec.type = arrow THEN         isArrow ¬ TRUE      ELSE isArrow ¬ FALSE;    END;  --of procedure NextElementIsArrow  NextElementIsOneOrZero: PROCEDURE [phrase: PhrasePtr]    RETURNS [{one, zero, bad}] =    BEGIN    -- Look to see if one follows plus or minus.    IF (phrase.currentElement ¬ phrase.currentElement.nextElement) = NIL THEN      RETURN[bad];    WITH phrase.currentElement.elementRec SELECT FROM      constant =>        SELECT value FROM          1 => RETURN[one];          0 => RETURN[zero];          ENDCASE => RETURN[bad];      ENDCASE;    RETURN[bad];    END;  SearchForPattern: PROCEDURE [    phrase: PhrasePtr, first: ExpressionPatternPtr, second: PatternPtr,    position, limit: CARDINAL] =    BEGIN    lastExpression: ExpressionPatternPtr;    nextExpression: ExpressionPatternPtr ¬ first;    --the expression table entries are arranged in by a pattern for register encodings followed by a pattern for constant encodings, followed by register, etc.  if either argument is a constant, the pattern for constant must be gotten and the position within the table updated.    IF ((phrase.arg1.regType = zero) AND (phrase.expression.operand1 = bBus))      OR ((phrase.arg2.regType = zero) AND (phrase.expression.operand2 = bBus))      THEN {      nextExpression ¬ nextExpression + SIZE[ExpressionPattern];      position ¬ position + 1};    UNTIL nextExpression = NIL DO  -- once for each possible encoding of the macro      -- Move the old encoding to trialEncoding so that we can modify it and still have the unmodified version.      trialEncoding­ ¬ nextOldEncoding­;      BEGIN      IF NOT EncodePattern[        phrase, @nextExpression.pattern, trialEncoding, Assignment[expression[]]]        THEN GOTO skip;      IF second # NIL AND second.ci # x THEN        IF NOT EncodePattern[          phrase, second, trialEncoding, Assignment[expression[]]] THEN GOTO skip;      BEGIN      -- We have an encoding of the expression that works.  Chain it onto the list of encoding records for this phrase.      lastNextEncodingPtrInNewChain­ ¬ trialEncoding;      trialEncoding.nextEncoding ¬ NIL;      lastNextEncodingPtrInNewChain ¬ @trialEncoding.nextEncoding;      trialEncoding ¬ AllocateEncodingRecord[];      expressionFound ¬ TRUE;      END;      EXITS skip => NULL;      END;      --Try next pattern if one is available      lastExpression ¬ nextExpression;      nextExpression ¬ nextExpression + (2 * SIZE[ExpressionPattern]);      position ¬ position + 2;      IF (lastExpression.expressionArgs # nextExpression.expressionArgs)        OR (position >= limit) THEN EXIT;      ENDLOOP;    RETURN;    END;  --of procedure SearchForPattern  -- MAIN LINE CODE  END...  --Log of last edit:--JAC   	23-Oct-84 10:22:50	added check for ALU¬ in EncodeLHS--JAC   	26-Oct-84 15:42:52	cleaned up test for ALU¬--JAC   	 5-Nov-84 14:17:45	fixed arrows for Mesa 11.1--JAC   	13-Nov-84 15:07:28	added check for MDR ¬ EXTRACT and made it illegal--JAC   	11-Jan-85 17:02:22	MD is not available in ALU operations--JAC   	24-Feb-85 14:55:42	made aBus public; added aBusThisPhrase
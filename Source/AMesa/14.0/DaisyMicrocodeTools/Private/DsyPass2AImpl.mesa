-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. --Last edit by JAC       5-Nov-84 14:31:16DIRECTORY  Ascii USING [SP],  Environment USING [Byte, bytesPerWord, Block],  Stream USING [GetBlock, GetPosition, GetWord, PutChar, PutBlock, SetPosition],  String USING [AppendNumber, AppendDecimal, AppendString, WordsForString],  DsyAssembler USING [cycle0, cycle1, cycle4, MEntryPtr],  DsyuFormat,  DsyControl USING [noFinalFiles],  DsyFile USING [    fbInStream, LogErrLine, LogLine, LogText, OpenNextFb, OpenNextSi, OpenStFile,    siStream, stStream],  DsyLabel,  DsyModule USING [DisplayM, ReleaseMTSpace],  DsyP2Hash USING [    bad, curID, curMI, DisplayPass2Hash, errorLevel, ExportDataRec,    ExportDataRecPtr, exportRecList, ExportRec, ExportRecPtr, FindPass2Label,    GetMiSpace, GetPass2Space, GetXSpace, GetXString, InsertPass2Hash, MiLtoV,    miLtoV, MiVtoLtxt, miVtoLtxt, labIoff, miVtoR, MiVtoR, Mi2Res, mi2Res, miIoff,    Not, NoTxt, Pass2Entry, Pass2HashEntry, Pass2HashEntryPtr, realMI, RefChain,    RefChainPtr];DsyPass2AImpl: PROGRAM  IMPORTS Stream, String, DsyControl, DsyFile, DsyLabel, DsyModule, DsyP2Hash  EXPORTS DsyLabel, DsyModule =  BEGIN OPEN DsyuFormat, DsyLabel;  AppendSymbolName: PUBLIC PROCEDURE [str: LONG STRING, mi: CARDINAL [0..5120)] =    BEGIN    i, j: CARDINAL ¬ 0;    name: LONG STRING ¬ [64];    FOR i DECREASING IN [0..mi] DO      IF DsyP2Hash.miVtoLtxt[i] # DsyP2Hash.NoTxt THEN BEGIN j ¬ i; EXIT; END;      ENDLOOP;    IF DsyP2Hash.miVtoLtxt[j] = DsyP2Hash.NoTxt THEN      String.AppendString[str, "beginning m-i "L]    ELSE      BEGIN      Stream.SetPosition[DsyFile.stStream, DsyP2Hash.miVtoLtxt[j]];      ReadLabelFromST[name];      String.AppendString[str, name];      IF mi <= j THEN RETURN;      String.AppendString[str, " + "L];      String.AppendNumber[str, mi - j, 16];      END;    END;  -- end AppendSymbolName  MoveExportsAndCheck: PROCEDURE =    BEGIN    nextEP: LONG POINTER TO DsyP2Hash.ExportDataRecPtr ¬ @DsyP2Hash.exportRecList;    FinalSTScan: PROCEDURE [hePtr: DsyP2Hash.Pass2HashEntryPtr] =      BEGIN      export: BOOLEAN ¬ hePtr.ptr.export;      import: BOOLEAN ¬ hePtr.ptr.import;      incons: BOOLEAN ¬ hePtr.ptr.incons;      target: BOOLEAN ¬ hePtr.ptr.target;      tempP: DsyP2Hash.RefChainPtr;      WITH x: hePtr.ptr­ SELECT FROM        notFound => {          IF export THEN SymbolError[notFexport, hePtr.key];          IF import THEN SymbolError[notFimport, hePtr.key];          IF NOT export AND NOT import AND NOT incons THEN            SymbolError[notFound, hePtr.key];          IF incons AND NOT target THEN SymbolError[notarganon, hePtr.key];          IF NOT export AND NOT import AND incons THEN {            tempP ¬ x.refChain;            UNTIL tempP = NIL DO  -- satisfy ref chain              DsyP2Hash.miLtoV[tempP.labIndex] ¬ DsyP2Hash.curMI;              tempP ¬ tempP.next;              ENDLOOP;            DsyP2Hash.curMI ¬ DsyP2Hash.curMI + 1;            };          };        found =>          BEGIN          IF export THEN            BEGIN            nextEP­ ¬ DsyP2Hash.GetXSpace[SIZE[DsyP2Hash.ExportDataRec]];            nextEP.id ¬ DsyP2Hash.curID;            nextEP.miIndex ¬ x.miIndex;            nextEP.next ¬ NIL;            nextEP.s ¬ DsyP2Hash.GetXString[hePtr.key.length];            String.AppendString[nextEP.s, hePtr.key];            nextEP ¬ @nextEP.next;            END;          IF import THEN SymbolError[import, hePtr.key]          ELSE {  -- cycle check            }          END;        impVal =>          BEGIN          IF export THEN            BEGIN            nextEP­ ¬ DsyP2Hash.GetXSpace[SIZE[DsyP2Hash.ExportDataRec]];            nextEP.id ¬ x.expPtr.id;            nextEP.addr ¬ x.expPtr.addr;            nextEP.miIndex ¬ Empty;            nextEP.next ¬ NIL;            nextEP.s ¬ DsyP2Hash.GetXString[hePtr.key.length];            String.AppendString[nextEP.s, hePtr.key];            nextEP ¬ @nextEP.next;            END;          END;        ENDCASE;      END;  -- end FinalSTScan    DsyP2Hash.realMI ¬ DsyP2Hash.curMI;    DsyP2Hash.DisplayPass2Hash[FinalSTScan];    END;  -- end MoveExportsAndCheck  Pass2: PUBLIC PROCEDURE[] =    BEGIN    Pass2Init0[];    DsyFile.OpenStFile[];    ReadSIFiles[];    ReadFBFiles[];    MoveExportsAndCheck[];    Pass2Part2[];    END;  -- end Pass2  Pass2Init0: PROCEDURE =    BEGIN    i: CARDINAL;    DsyP2Hash.miVtoLtxt ¬ DsyP2Hash.GetMiSpace[SIZE[DsyP2Hash.MiVtoLtxt]];    DsyP2Hash.miVtoR ¬ DsyP2Hash.GetMiSpace[SIZE[DsyP2Hash.MiVtoR]];    FOR i IN [0..5120) DO      DsyP2Hash.miVtoLtxt[i] ¬ DsyP2Hash.NoTxt;      DsyP2Hash.miVtoR[i] ¬ DsyP2Hash.Not;      ENDLOOP;    DsyP2Hash.miLtoV ¬ DsyP2Hash.GetMiSpace[SIZE[DsyP2Hash.MiLtoV]];    DsyP2Hash.mi2Res ¬ DsyP2Hash.GetMiSpace[SIZE[DsyP2Hash.Mi2Res]];    FOR i IN [0..4096) DO DsyP2Hash.mi2Res[i] ¬ FALSE; ENDLOOP;    END;  -- end Pass2Init1  ProcessExports: PROCEDURE =  --read in all the exports from the fb files which had EXPORTS macros (indicated by a /x switch in this assembly.  The exports and values are found after the MIs in a fb file.    BEGIN    hePtr: DsyP2Hash.Pass2HashEntryPtr;    str: LONG STRING;    strBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[@str.text], startIndex: 0, stopIndexPlusOne: 0      -- dynamic -- ];    tempP: DsyP2Hash.RefChainPtr;    xrp: DsyP2Hash.ExportRecPtr ¬ DsyP2Hash.GetPass2Space[SIZE[DsyP2Hash.ExportRec]];    xrpBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[xrp], startIndex: 0,      stopIndexPlusOne: Environment.bytesPerWord*SIZE[DsyP2Hash.ExportRec]];    DO  -- for each export record      [] ¬ Stream.GetBlock[DsyFile.fbInStream, xrpBlock];      IF xrp.length = 0 THEN EXIT;  -- we are at end of file      str ¬ DsyP2Hash.GetPass2Space[String.WordsForString[xrp.length]];      str­ ¬ [length: xrp.length, maxlength: xrp.length, text:];  --length must be set to xrp.length since GetBlock does not update string length and setting it to 0 will result in hePtr returning NIL from FindPass2Label      strBlock.blockPointer ¬ LOOPHOLE[@str.text];  --must reassign value since the space for str was not allocated until 2 instructions before i.e. a bogus pointer was put in during allocation of strBlock      strBlock.stopIndexPlusOne ¬ xrp.length;      [] ¬ Stream.GetBlock[DsyFile.fbInStream, strBlock];      hePtr ¬ DsyP2Hash.FindPass2Label[str];      IF hePtr = NIL THEN LOOP;  -- not seen yet      IF NOT hePtr.ptr.import THEN LOOP;  -- not used here      WITH x: hePtr.ptr­ SELECT FROM        found => NULL;  -- previously caused error        notFound =>          BEGIN          tempP ¬ x.refChain;          UNTIL tempP = NIL DO  -- satisfy ref chain            DsyP2Hash.miLtoV[tempP.labIndex] ¬ DsyP2Hash.curMI;            tempP ¬ tempP.next;            ENDLOOP;          DsyP2Hash.miVtoR[DsyP2Hash.curMI] ¬ xrp.addr;          DsyP2Hash.curMI ¬ DsyP2Hash.curMI + 1;          hePtr.ptr­ ¬ DsyP2Hash.Pass2Entry[            export: hePtr.ptr.export, import: TRUE, incons: hePtr.ptr.incons,            isCycle: hePtr.ptr.isCycle, needsCycle: hePtr.ptr.needsCycle,	    entry: impVal[xrp]];          xrp ¬ DsyP2Hash.GetPass2Space[SIZE[DsyP2Hash.ExportRec]];          END;        impVal =>          BEGIN IF xrp.id # x.expPtr.id THEN SymbolError[export, hePtr.key]; END;        ENDCASE;      ENDLOOP;  -- end for each export record    END;  -- end ProcessExports  PutOutRegister: PROCEDURE [Mptr: DsyAssembler.MEntryPtr] =    BEGIN    lsr: LabelSymbolRec;    lsrBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[LONG[@lsr]], startIndex: 0,      stopIndexPlusOne: Environment.bytesPerWord*SIZE[LabelSymbolRec]];    lsr ¬ LabelSymbolRec[      external: FALSE, labIndex: 0, length: Mptr­.key.length, element: regR[0]];    WITH Mptr­.ptr SELECT FROM      register =>          BEGIN        SELECT registerType FROM          R => lsr.element ¬ regR[regnum];          D => lsr.element ¬ regD[regnum];	  A => lsr.element ¬ regA[regnum];          ENDCASE => RETURN;        END;      ENDCASE => RETURN;    [] ¬ Stream.PutBlock[DsyFile.stStream, lsrBlock];    [] ¬ Stream.PutBlock[      DsyFile.stStream, Environment.Block[      blockPointer: LOOPHOLE[@Mptr­.key.text], startIndex: 0,      stopIndexPlusOne: lsr.length]];    -- for Alto Mesa compatibility    IF lsr.length MOD 2 = 1 THEN Stream.PutChar[DsyFile.stStream, Ascii.SP];    END;  -- end PutOutRegister  PutOutToST: PROCEDURE [hePtr: DsyP2Hash.Pass2HashEntryPtr] =    BEGIN    lsr: LabelSymbolRec;    lsrBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[LONG[@lsr]], startIndex: 0,      stopIndexPlusOne: Environment.bytesPerWord*SIZE[LabelSymbolRec]];    lsr ¬ LabelSymbolRec[      external: FALSE, pad3: 0, labIndex: 0, length: hePtr­.key.length,      element: label[pad1: 0, miIndex: 0]];    WITH x: hePtr.ptr­ SELECT FROM      found => lsr.element ¬ label[pad1: 0, miIndex: x.miIndex];      ENDCASE;    [] ¬ Stream.PutBlock[DsyFile.stStream, lsrBlock];    [] ¬ Stream.PutBlock[      DsyFile.stStream, Environment.Block[      blockPointer: LOOPHOLE[@hePtr­.key.text], startIndex: 0,      stopIndexPlusOne: lsr.length]];    -- for Alto Mesa compatibility    IF lsr.length MOD 2 = 1 THEN Stream.PutChar[DsyFile.stStream, Ascii.SP];    END;  -- end PutOutToST  ReadFBFiles: PROCEDURE =    BEGIN    fbr: FinalBinaryRec;    fbrBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[LONG[@fbr]], startIndex: 0,      stopIndexPlusOne: Environment.bytesPerWord*SIZE[FinalBinaryRec]];    UNTIL DsyFile.OpenNextFb[] DO  -- for each fb file      DO  -- for each fb record        [] ¬ Stream.GetBlock[DsyFile.fbInStream, fbrBlock];        IF fbr.addr = 177777B THEN EXIT;        DsyP2Hash.mi2Res[fbr.addr] ¬ TRUE;        ENDLOOP;  -- end of fb record      ProcessExports[];      ENDLOOP;  -- end of fb file    END;  ReadLabelFromST: PUBLIC PROCEDURE [str: LONG STRING] =    BEGIN    lsr: LabelSymbolRec;    lsrBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[LONG[@lsr]], startIndex: 0,      stopIndexPlusOne: Environment.bytesPerWord*SIZE[LabelSymbolRec]];    [] ¬ Stream.GetBlock[DsyFile.stStream, lsrBlock];    [] ¬ Stream.GetBlock[      DsyFile.stStream, Environment.Block[      blockPointer: LOOPHOLE[@str.text], startIndex: 0,      stopIndexPlusOne: lsr.length]];    str.length ¬ lsr.length;    END;  -- end ReadLabelFromST  ReadSIFiles: PROCEDURE =    BEGIN    miIoffset, labIoffset: CARDINAL ¬ 0;    misize, labsize: CARDINAL ¬ 0;    lsr: LabelIntRec ¬ LabelIntRec[miIndex: Empty];    lsrBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[LONG[@lsr]], startIndex: 0,      stopIndexPlusOne: Environment.bytesPerWord*SIZE[LabelIntRec]];    hePtr: DsyP2Hash.Pass2HashEntryPtr;    refChainPtr: DsyP2Hash.RefChainPtr;    stIndex: CARDINAL ¬ 0;    str: LONG STRING ¬ [64];    tempP: DsyP2Hash.RefChainPtr;    DsyP2Hash.curMI ¬ DsyP2Hash.miIoff[0] ¬ DsyP2Hash.labIoff[0] ¬ 0;    -- first put out registers    IF NOT DsyControl.noFinalFiles THEN DsyModule.DisplayM[PutOutRegister];    DsyModule.ReleaseMTSpace[];    -- next read each si file    UNTIL DsyFile.OpenNextSi[] OR DsyP2Hash.errorLevel > DsyP2Hash.bad DO  -- for each si file      miIoffset ¬ DsyP2Hash.miIoff[stIndex];      labIoffset ¬ DsyP2Hash.labIoff[stIndex];      UNTIL DsyP2Hash.errorLevel > DsyP2Hash.bad DO  -- for each si record        [] ¬ Stream.GetBlock[DsyFile.siStream, lsrBlock];        IF lsr.length = 0 THEN          BEGIN  -- we are at end of file          --update offsets and save for reading ml files          stIndex ¬ stIndex + 1;          misize ¬ Stream.GetWord[DsyFile.siStream];          labsize ¬ Stream.GetWord[DsyFile.siStream];          DsyFile.LogText["The number of micro-instructions in this file =  "L];          str.length ¬ 0;          String.AppendDecimal[str, misize];          DsyFile.LogLine[str];          IF DsyP2Hash.miIoff[stIndex - 1] + misize > 4096 THEN            BEGIN            DsyP2Hash.errorLevel ¬ 200;            DsyFile.LogErrLine["You have more than 4096 m-i's."L];            EXIT;            END;          DsyP2Hash.curMI ¬ DsyP2Hash.miIoff[stIndex] ¬            DsyP2Hash.miIoff[stIndex - 1] + misize;          DsyP2Hash.labIoff[stIndex] ¬ DsyP2Hash.labIoff[stIndex - 1] + labsize;          EXIT;  -- get next si file          END;        IF lsr.found AND (lsr.miIndex + miIoffset > 4096) THEN          BEGIN          DsyP2Hash.errorLevel ¬ 200;          DsyFile.LogErrLine["You have more than 4096 m-i's."L];          EXIT;          END;        str.length ¬ lsr.length;        [] ¬ Stream.GetBlock[          DsyFile.siStream, Environment.Block[          blockPointer: LOOPHOLE[@str.text], startIndex: 0,          stopIndexPlusOne: lsr.length]];        hePtr ¬ DsyP2Hash.FindPass2Label[str];        IF hePtr = NIL THEN          BEGIN  -- not seen yet          hePtr ¬ DsyP2Hash.GetPass2Space[            SIZE[DsyP2Hash.Pass2HashEntry] + SIZE[DsyP2Hash.Pass2Entry] +              String.WordsForString[str.length]];          hePtr.ptr ¬ LOOPHOLE[hePtr + SIZE[DsyP2Hash.Pass2HashEntry]];          hePtr.key ¬ LOOPHOLE[hePtr.ptr + SIZE[DsyP2Hash.Pass2Entry]];          hePtr.key­ ¬ [length: 0, maxlength: str.length, text:];          String.AppendString[hePtr.key, str];          hePtr.next ¬ NIL;          DsyP2Hash.InsertPass2Hash[hePtr];          IF lsr.found THEN            BEGIN  -- new found            hePtr.ptr­ ¬ DsyP2Hash.Pass2Entry[              export: lsr.export, import: lsr.import, incons: lsr.incons,              target: lsr.target, isCycle: lsr.isCycle, 	      needsCycle: lsr.needsCycle, cycleOK: lsr.cycleOK, 	      memStatus: lsr.memStatus, entry: found[lsr.miIndex + miIoffset]];                	              	    DsyP2Hash.miLtoV[lsr.labIndex + labIoffset] ¬ lsr.miIndex + miIoffset;            DsyP2Hash.miVtoLtxt[lsr.miIndex + miIoffset] ¬ Stream.GetPosition[              DsyFile.stStream];            PutOutToST[hePtr];            END  -- end new found          ELSE            BEGIN  -- new not found            refChainPtr ¬ DsyP2Hash.GetPass2Space[SIZE[DsyP2Hash.RefChain]];            refChainPtr­ ¬ DsyP2Hash.RefChain[lsr.labIndex + labIoffset, NIL];            hePtr.ptr­ ¬ DsyP2Hash.Pass2Entry[              export: lsr.export, import: lsr.import, incons: lsr.incons,              target: lsr.target, isCycle: lsr.isCycle,	      needsCycle: lsr.needsCycle, cycleOK: lsr.cycleOK,	      memStatus: lsr.memStatus, entry: notFound[refChainPtr]];            END;  -- end new not found          END  -- end not seen yet        ELSE          BEGIN  -- seen before          hePtr.ptr.export ¬ hePtr.ptr.export OR lsr.export;          hePtr.ptr.import ¬ hePtr.ptr.import OR lsr.import;          hePtr.ptr.incons ¬ hePtr.ptr.incons OR lsr.incons;          hePtr.ptr.target ¬ hePtr.ptr.target OR lsr.target;          IF lsr.found THEN            BEGIN  -- (found) and label seen before            WITH x: hePtr.ptr­ SELECT FROM              found => 	        SymbolError[multiple, hePtr.key];              notFound =>                BEGIN                tempP ¬ x.refChain;                UNTIL tempP = NIL DO                  DsyP2Hash.miLtoV[tempP.labIndex] ¬ lsr.miIndex + miIoffset;                  tempP ¬ tempP.next;                  ENDLOOP;		IF hePtr.ptr.needsCycle # lsr.isCycle AND 		  NOT hePtr.ptr.cycleOK THEN		  IF NOT (((hePtr.ptr.needsCycle = DsyAssembler.cycle0 AND lsr.isCycle = DsyAssembler.cycle1) OR (hePtr.ptr.needsCycle = DsyAssembler.cycle1 AND lsr.isCycle = DsyAssembler.cycle0))  OR		    (hePtr.ptr.needsCycle = DsyAssembler.cycle4 AND (hePtr.ptr.memStatus = read OR hePtr.ptr.memStatus = write) AND lsr.isCycle IN [DsyAssembler.cycle0..DsyAssembler.cycle1])) THEN		    SymbolError[wrongcycle, hePtr.key];                hePtr.ptr­ ¬ DsyP2Hash.Pass2Entry[                  export: hePtr.ptr.export, import: hePtr.ptr.import,                  incons: hePtr.ptr.incons, target: hePtr.ptr.target,		  isCycle: lsr.isCycle, needsCycle: hePtr.ptr.needsCycle,		  cycleOK: hePtr.ptr.cycleOK,                   memStatus: lsr.memStatus, entry: found[lsr.miIndex + miIoffset]];                DsyP2Hash.miLtoV[lsr.labIndex + labIoffset] ¬                  lsr.miIndex + miIoffset;                DsyP2Hash.miVtoLtxt[lsr.miIndex + miIoffset] ¬ Stream.GetPosition[                  DsyFile.stStream];                PutOutToST[hePtr];                END;              ENDCASE;            END  -- end (found) and label seen before          ELSE            BEGIN  -- (NOT found) and label seen before            WITH x: hePtr.ptr­ SELECT FROM              found =>                BEGIN 		DsyP2Hash.miLtoV[lsr.labIndex + labIoffset] ¬ x.miIndex;		IF hePtr.ptr.isCycle # lsr.needsCycle AND 		  NOT lsr.cycleOK THEN		  IF NOT (((lsr.needsCycle = DsyAssembler.cycle0 AND hePtr.ptr.isCycle = DsyAssembler.cycle1) OR (lsr.needsCycle = DsyAssembler.cycle1 AND hePtr.ptr.isCycle = DsyAssembler.cycle0)) OR		    (lsr.needsCycle = DsyAssembler.cycle4 AND (lsr.memStatus = read OR lsr.memStatus = write) AND hePtr.ptr.isCycle IN [DsyAssembler.cycle0..DsyAssembler.cycle1])) THEN		    SymbolError[wrongcycle, hePtr.key]; 		END;              notFound =>                BEGIN  -- chain onto refChain                tempP ¬ x.refChain;                x.refChain ¬ DsyP2Hash.GetPass2Space[SIZE[DsyP2Hash.RefChain]];                x.refChain.labIndex ¬ lsr.labIndex + labIoffset;                x.refChain.next ¬ tempP;		IF NOT lsr.cycleOK THEN 		  IF NOT hePtr.ptr.cycleOK THEN {		    IF lsr.needsCycle # hePtr.ptr.needsCycle THEN		      IF NOT ((lsr.needsCycle = DsyAssembler.cycle4 AND hePtr.ptr.needsCycle = DsyAssembler.cycle0 AND (lsr.memStatus = read OR lsr.memStatus = write)) OR		        (lsr.needsCycle = DsyAssembler.cycle0 AND hePtr.ptr.needsCycle = DsyAssembler.cycle4 AND (hePtr.ptr.memStatus = read OR hePtr.ptr.memStatus = write)) OR		         ((lsr.needsCycle = DsyAssembler.cycle0 AND hePtr.ptr.needsCycle = DsyAssembler.cycle1) OR (hePtr.ptr.needsCycle = DsyAssembler.cycle0 AND lsr.needsCycle = DsyAssembler.cycle1))) THEN		        SymbolError[wrongcycle, hePtr.key]}		  ELSE {		    hePtr.ptr.needsCycle ¬ lsr.needsCycle;		    hePtr.ptr.cycleOK ¬ lsr.cycleOK};                END;              ENDCASE;            END;  -- end (NOT found) and label seen before          END;  -- end seen before        ENDLOOP;  -- for each si record      ENDLOOP;  -- for each si file    DsyFile.LogText["The TOTAL number of micro-instructions =  "L];    str.length ¬ 0;    String.AppendNumber[str, DsyP2Hash.curMI, 10];    DsyFile.LogLine[str];    END;  -- end ReadSIFiles  SymbolError: PROCEDURE [    type: {      undefined, multiple, import, export, notFexport, notFimport, notFound,      notarganon, wrongcycle}, s: LONG STRING] =    BEGIN    IF DsyP2Hash.errorLevel < DsyP2Hash.bad THEN      DsyFile.LogErrLine["Allocation Errors:"L];    DsyP2Hash.errorLevel ¬ 200;    DsyFile.LogText[      (SELECT type FROM         undefined => "symbol is Undefined : "L,         multiple => "symbol is Multiply defined : "L,         import => "symbol is imported AND defined : "L,         export => "symbol is imported AND Multiply exported : "L,         notFexport => "symbol is exported AND NOT defined : "L,         notFimport => "symbol is imported AND NOT exported : "L,         notarganon => "symbol is used as base address AND NOT gone to : "L,         wrongcycle => "symbol is wrong cycle : "L,         ENDCASE => "symbol was not found : "L)];    DsyFile.LogLine[s];    END;  -- end SymbolError  END...  --Log--JAC   	17-Aug-84 11:09:01	added cycleOK checking to ReadSIFiles--JAC   	 5-Nov-84 14:31:29	fixed arrows for Mesa 11.1
-- TVErrorImpl.mesa-- Created by jAC   CxC    on  4-Dec-84 10:03:23-- last edit by CxC   	  4-Dec-84 10:03:29-- Copyright (C) Xerox Corporation 1984. All rights reserved.DIRECTORY  Heap,  MFile,  MStream,  Put,  String,  TVError;TVErrorImpl: PROGRAM  IMPORTS Heap, MFile, MStream, Put, String   EXPORTS TVError  = {    zone: UNCOUNTED ZONE _ Heap.systemZone;  err: BOOLEAN _ FALSE;    MakeFile: PUBLIC PROCEDURE [log: LONG POINTER, name: LONG STRING] RETURNS                                    [ptr: MStream.Handle, temp: BOOLEAN] = {    ENABLE MStream.Error => {Put.Line[log, "UnKnown MStream error"L];                                           CONTINUE};    filename: LONG STRING _ zone.NEW[StringBody[40]];    oldname: LONG STRING _ zone.NEW[StringBody[40]];    handle: MFile.Handle _ NIL;    err _ FALSE;    filename _ ConstructName[name,filename];    String.Copy[to:oldname, from:filename];    String.AppendString[oldname,"$"L];    handle _ MFile.Acquire[name: oldname, access: delete, release: [proc: Release]                  ! MFile.Error => {ReportError[log,code,oldname]; CONTINUE};];    IF err THEN RETURN[NIL,TRUE];    MFile.Delete[handle ! MFile.Error => {ReportError[log,code,oldname];                   CONTINUE};];    IF err THEN RETURN[NIL,TRUE];    handle _ MFile.Acquire[name:filename, access:rename, release: [proc: Release]                   ! MFile.Error => {ReportError[log,code,filename]; CONTINUE};];    IF err THEN RETURN[NIL,TRUE];     MFile.Rename[handle, oldname ! MFile.Error => {ReportError[log,code,filename];                  CONTINUE};];    IF err THEN RETURN[NIL,TRUE];    ptr _ MStream.WriteOnly[filename,[],text];    zone.FREE[@filename];    zone.FREE[@oldname];    RETURN[ptr,FALSE];    };  ConstructName: PROCEDURE [orig,filename: LONG STRING] RETURNS                                    [f: LONG STRING] = {    i: CARDINAL;    filename.length _ orig.length;    FOR i IN [0..orig.length] DO      filename[i] _ orig[i];      IF orig[i] = '. THEN EXIT;      ENDLOOP;      filename.length _ i;      String.AppendString[filename,".errors"L];      RETURN[filename];     };  ReportError: PROCEDURE [log: LONG POINTER, type: MFile.ErrorCode,                                    fname: LONG STRING] = {    err _ FALSE;    SELECT type FROM      noSuchFile, invalidHandle => NULL;      conflictingAccess => {Put.Text[log,"Can't access file - "L];                            Put.LongString[log,fname];			    Put.CR[log];                            err _ TRUE;};      ENDCASE => {Put.Text[log,"Unknown MFile error accessing file - "L];                  Put.LongString[log,fname];		  Put.CR[log];		  err _ TRUE};    };      Release: MFile.PleaseReleaseProc = {    RETURN[goAhead]};      }...                    
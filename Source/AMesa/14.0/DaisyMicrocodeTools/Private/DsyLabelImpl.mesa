-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. --File: DsyLabelImpl.mesa--Last edit by JAC           21-May-85 15:42:27                            DIRECTORY  Ascii USING [CR],  Environment USING [Byte, bytesPerWord, Block],  Heap USING [MakeNode],  Inline USING [BITSHIFT, BITAND, BITNOT],  DsyuFormat,  Stream USING [PutBlock, PutWord],  String USING [    AppendChar, AppendDecimal, AppendString, EqualString, EqualSubString,    StringBoundsFault, SubStringDescriptor, WordsForString],  DsyAssembler,  DsyControl USING [FatalError, linkLoad, linkVal, statement],  DsyFile USING [    ebStream, LogErrAndSrcLines, LogErrArgAndSrcLines, LogErrLine, LogLine,    mlStream, siStream],  DsyLabel,  DsyModule;DsyLabelImpl: PROGRAM  IMPORTS    Heap, Inline, Stream, String, DsyAssembler, DsyControl, DsyFile, DsyLabel,    DsyModule  EXPORTS DsyLabel, DsyModule =  BEGIN OPEN DsyuFormat, DsyAssembler, DsyControl, DsyLabel, String;  adjMI: BOOLEAN;  --is the previous MI the previous MI in the code?  atLabel: HashEntryPtr;  bogusPart: LONG STRING = "#¬+"L;  --if MI needs label to keep information but doesn't have one append this to last label to create bogus label  bogusSubString: SubStringDescriptor ¬ SubStringDescriptor[bogusPart, 0, 3];  curLabelSeqNum: CARDINAL;  curMI: CurrentMI;  curMISeqNum: CARDINAL;  curMILabelSeqNum: CARDINAL;  errgcb: BOOLEAN;  extCurDestField: BOOLEAN;  --did the previus MI in the code branch?  flaggedByStar: CARDINAL;  --does this MI have a GOTO[*]?  fromCycleOK: PUBLIC BOOLEAN;  fromDest: PUBLIC ArgumentType;  fromMI: LabelEntry;  immCurDestField: BOOLEAN;  MiRes: TYPE = PACKED ARRAY [0..4096) OF BOOLEAN;  miRes: LONG POINTER TO MiRes;  miResUsed: BOOLEAN;  newAtEntry: BOOLEAN ¬ FALSE;  none: CARDINAL = 4096;  startAddress: INTEGER;  startAddressPlus1: INTEGER;  thisLabel: LabelListPtr;  --list of labels for this MI  thisMI: LabelEntry;  toLabel: LabelListPtr;  --list of labels branched to by this MI  canceledBr: PUBLIC BOOLEAN;  --branch canceled?  canceledBr1: PUBLIC BOOLEAN;  --bit 1 of condition bits 1?  curLineLab: PUBLIC LONG STRING ¬ [64];  --current line's label  curLineNum: PUBLIC CARDINAL;  hasLabel: PUBLIC BOOLEAN;  immLastDestField: PUBLIC BOOLEAN;  lastLabel: PUBLIC HashEntryPtr;  branchType: PUBLIC BranchType;  natc: PUBLIC BOOLEAN;  --NATC loophole  cycleOK: PUBLIC BOOLEAN;  --CycleOK loophole  oldok: PUBLIC BOOLEAN;  --oldok loophole  reference: PUBLIC ArgumentType;  wok: PUBLIC BOOLEAN;  --Write ok loophole  InitGlobalLabel: PUBLIC PROC =    BEGIN    i: CARDINAL;    miRes ¬ DsyModule.MTtempHeap.NEW[MiRes];    FOR i IN [0..4096) DO miRes[i] ¬ FALSE; ENDLOOP;    startAddress ¬ startAddressPlus1 ¬ -1;    lastLabel ¬ NIL;    LabelInit[];    END;  -- end InitGlobalLabel  AppendLabel: PUBLIC PROC [    --append label to label list at the end if possible    list: LONG POINTER TO LabelListPtr, hep: HashEntryPtr] =    BEGIN    mum: LabelListPtr;    ptr: LabelListPtr;    mum ¬ GetStmtSpace[SIZE[LabelList]];    IF list­ # NIL THEN {      ptr ¬ list­;      UNTIL ptr.next = NIL DO ptr ¬ ptr.next; ENDLOOP;      mum­ ¬ [next: NIL, label: hep];      ptr.next ¬ mum}    ELSE {mum­ ¬ [next: list­, label: hep]; list­ ¬ mum};    END;  -- end AppendLabel    BuildEarlyBinary: PUBLIC PROC [encodingPtr: EncodingPtr] =    BEGIN    earlyBinaryRec: EarlyBinaryRec ¬ [      partialBinary: BuildPartialBinary[encodingPtr], destMI: curMI, last: FALSE,      parityMasks: parity, sa: none];    ebrBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[LONG[@earlyBinaryRec]], startIndex: 0,      stopIndexPlusOne: Environment.bytesPerWord * SIZE[EarlyBinaryRec]];    [] ¬ Stream.PutBlock[DsyFile.ebStream, ebrBlock];    END;  -- end BuildEarlyBinary  BuildPartialBinary: PROC [encodingPtr: EncodingPtr]    RETURNS [partialBinary: PartialBinary] =    BEGIN    BuildField1: PROCEDURE [moValue, aValue: CARDINAL]      RETURNS [field1Value: CARDINAL] =      BEGIN      temp: Op2rA;      temp.aAdr ¬ aValue;      temp.mo ¬ moValue;      temp.pad ¬ 0;      field1Value ¬ temp.word;      END;    BuildField2: PROCEDURE [itValue, omValue, ibValue: CARDINAL]      RETURNS [field2Value: CARDINAL] =      BEGIN      temp: Op2rB;      temp.ib ¬ ibValue;      temp.om ¬ omValue;      temp.it ¬ itValue;      temp.pad ¬ 0;      field2Value ¬ temp.word;      END;    BuildrBField: PROCEDURE [hiValue, imuValue: CARDINAL]      RETURNS [rBFieldValue: CARDINAL] =      BEGIN      op3rB: Op3rB;      op3rB.imu ¬ imuValue;      op3rB.hi ¬ hiValue;      op3rB.pad ¬ 0;      rBFieldValue ¬ op3rB.word;      END;  --of procedure BuildrBField    constraintRec: ConstraintRec;    crBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[LONG[@constraintRec]], startIndex: 0,      stopIndexPlusOne: Environment.bytesPerWord * SIZE[ConstraintRec]];    dspB: SplitdspB;    enil: Encoding ¬ Encoding[];    isStar: BOOLEAN ¬ flaggedByStar = curMISeqNum;    rD: SplitrD;    IF encodingPtr = NIL THEN encodingPtr ¬ @enil;    rD.word ¬ encodingPtr.rD.value;    dspB.word ¬ encodingPtr.dspB.value;    SELECT encodingPtr.op.value FROM      0 =>        partialBinary ¬ PartialBinary[instruction: Instruction[          op: encodingPtr.op.value, rA: encodingPtr.rA.value,          rB: encodingPtr.rB.value, rDHi2: rD.rDHi2, rDLo4: rD.rDLo4,          operation: encodingPtr.alu.value, ci: encodingPtr.ci.value,          special2: encodingPtr.sp2.value, special1: encodingPtr.sp1.value,          dspBHi: dspB.dspBHi, dspBLo3: dspB.dspBLo3, inia: 0],          cycle: encodingPtr.cycle.value, ibdisp: isStar, mdr: mdr];      1 =>        partialBinary ¬ PartialBinary[instruction: Instruction[          op: encodingPtr.op.value, rA: encodingPtr.rA.value,          rB: encodingPtr.rB.value, rDHi2: rD.rDHi2, rDLo4: rD.rDLo4,          operation: encodingPtr.shift.value, ci: 0,          special2: encodingPtr.sp2.value, special1: encodingPtr.sp1.value,          dspBHi: dspB.dspBHi, dspBLo3: dspB.dspBLo3, inia: 0],          cycle: encodingPtr.cycle.value, ibdisp: isStar, mdr: mdr];      2 =>        partialBinary ¬ PartialBinary[instruction: Instruction[          op: encodingPtr.op.value,          rA: BuildField1[encodingPtr.mo.value, encodingPtr.aAdr.value],          rB: BuildField2[          encodingPtr.it.value, encodingPtr.om.value, encodingPtr.ib.value],          rDHi2: rD.rDHi2, rDLo4: rD.rDLo4, operation: encodingPtr.aiu.value,          ci: encodingPtr.ac.value, special2: encodingPtr.ail.value,          special1: encodingPtr.sp1.value, dspBHi: dspB.dspBHi,          dspBLo3: dspB.dspBLo3, inia: 0], cycle: encodingPtr.cycle.value,          ibdisp: isStar, mdr: mdr];      3 =>        partialBinary ¬ PartialBinary[instruction: Instruction[          op: encodingPtr.op.value, rA: encodingPtr.rA.value,          rB: BuildrBField[encodingPtr.hiByte.value, encodingPtr.imu.value],          rDHi2: rD.rDHi2, rDLo4: rD.rDLo4, operation: encodingPtr.alu.value,          ci: encodingPtr.ci.value, special2: encodingPtr.iml.value,          special1: encodingPtr.sp1.value, dspBHi: dspB.dspBHi,          dspBLo3: dspB.dspBLo3, inia: 0], cycle: encodingPtr.cycle.value,          ibdisp: isStar, mdr: mdr];      ENDCASE;    END;  -- end BuildPartialBinary  BrConstrain: PUBLIC PROC [    --set up constraint records for branches    lab1, lab2: LONG STRING, offset: CARDINAL, modulo: ModuloIndex] =    BEGIN    constraintRec: ConstraintRec;    crBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[LONG[@constraintRec]], startIndex: 0,      stopIndexPlusOne: Environment.bytesPerWord * SIZE[ConstraintRec]];    lab1rec, lab2rec: LabelRec;    eP: HashEntryPtr;    IF NOT EqualString[lab1, "$"L] THEN {      eP ¬ ProcessDestLabel[lab1];      lab1rec ¬ LabelRec[labeled[eP.ptr.labelseqnum]];      curMI.dest ¬ LabelRec[labeled[eP.ptr.labelseqnum]];      }    ELSE {      lab1rec ¬ LabelRec[unlabeled[curMISeqNum + 1]]; immCurDestField ¬ TRUE; };    IF NOT EqualString[lab2, "$"L] THEN {      eP ¬ ProcessDestLabel[lab2];      lab2rec ¬ LabelRec[labeled[eP.ptr.labelseqnum]];      }    ELSE {      lab2rec ¬ LabelRec[unlabeled[curMISeqNum + 1]]; immCurDestField ¬ TRUE; };    curMI.andMask ¬ maxNumMI - 1;    curMI.orMask ¬ 0;    constraintRec ¬ ConstraintRec[lab1rec, lab2rec, offset, modulo];    [] ¬ Stream.PutBlock[DsyFile.mlStream, crBlock];    offset ¬ Inline.BITAND[37B, Inline.BITSHIFT[1, modulo]] - 1;    constraintRec ¬ ConstraintRec[lab2rec, lab1rec, offset, modulo];    [] ¬ Stream.PutBlock[DsyFile.mlStream, crBlock];    END;  -- end BrConstrain  CheckDestSame: PROCEDURE [toMI: LabelEntryPtr] = INLINE    --two different MIs are jumping to the same location.  make sure that both MIs believe that they require the same memory cycle and type    BEGIN    IF NOT cycleOK THEN {      nextMICycle: Cycle ¬        SELECT thisMI.memStatus FROM          singleRead, singleWrite => (thisMI.needsCycle + 1) MOD 4,          doubleRead, doubleWrite => (thisMI.needsCycle + 1) MOD 5,          read, write => (thisMI.needsCycle + 1) MOD 5,          ENDCASE => 0;      nextMIMemStatus: MemStatus ¬        IF nextMICycle = 0 THEN none ELSE thisMI.memStatus;      IF toMI.target > 1 THEN {  --check to insure that all MI's which branch to this MI's destination require same cycle and type        SELECT nextMICycle FROM          0 =>            IF nextMICycle # toMI.needsCycle THEN              IF toMI.memStatus = read OR toMI.memStatus = write THEN {                toMI.memStatus ¬ none; toMI.needsCycle ¬ nextMICycle}              ELSE MemoryError[destCycleConflict];          1 => NULL;  --can never be one          2 =>            IF nextMICycle # toMI.needsCycle THEN MemoryError[destCycleConflict]            ELSE              SELECT nextMIMemStatus FROM                read =>                  IF toMI.memStatus NOT IN [read..doubleRead] THEN                    MemoryError[destTypeConflict];                write =>                  IF toMI.memStatus NOT IN [write..doubleWrite] THEN                    MemoryError[destTypeConflict];                singleRead =>                  IF toMI.memStatus = read THEN toMI.memStatus ¬ nextMIMemStatus                  ELSE                    IF toMI.memStatus # singleRead THEN                      MemoryError[destTypeConflict];                singleWrite =>                  IF toMI.memStatus = write THEN toMI.memStatus ¬ nextMIMemStatus                  ELSE                    IF toMI.memStatus # singleWrite THEN                      MemoryError[destTypeConflict];                doubleRead =>                  IF toMI.memStatus = read THEN toMI.memStatus ¬ nextMIMemStatus                  ELSE                    IF toMI.memStatus # doubleRead THEN                      MemoryError[destTypeConflict];                doubleWrite =>                  IF toMI.memStatus = write THEN toMI.memStatus ¬ nextMIMemStatus                  ELSE                    IF toMI.memStatus # doubleWrite THEN                      MemoryError[destTypeConflict];                ENDCASE;          3 =>            IF nextMICycle # toMI.needsCycle THEN MemoryError[destCycleConflict];  --don't check cycle types because c3 may be guessed wrong if its really a read but MD isn't read the type will be a write          4 =>            IF nextMICycle # toMI.needsCycle THEN              IF NOT (nextMIMemStatus = read OR nextMIMemStatus = write)                OR (toMI.needsCycle # cycle0) THEN MemoryError[destCycleConflict];          ENDCASE}      ELSE {  --this is the first time the MI has been targeted, just set up the record        toMI.needsCycle ¬ nextMICycle;        toMI.memStatus ¬ nextMIMemStatus;        IF toMI.needsCycle = 0 AND thisMI.needsCycle # 0 THEN          toMI.jumpFromEnd ¬ TRUE}};    END;  --of procedure CheckDestSame  CheckDfnForLabels: PUBLIC PROCEDURE =    --make sure that no definitions module contains a label    BEGIN    IF curLabelSeqNum # 0 THEN {      DsyFile.LogErrLine["Labels are illegal in definitions modules"L];      FatalError};    END;  --of procedure CheckDfnForLabels  Constrain: PUBLIC PROCEDURE [    lab1, lab2: LONG STRING, offset: CARDINAL, modulo: ModuloIndex] =    BEGIN    constraintRec: ConstraintRec;    crBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[LONG[@constraintRec]], startIndex: 0,      stopIndexPlusOne: Environment.bytesPerWord * SIZE[ConstraintRec]];    lab1rec, lab2rec: LabelRec;    eP: HashEntryPtr;    IF NOT EqualString[lab1, "$"L] THEN {      eP ¬ ProcessDestLabel[lab1];      lab1rec ¬ LabelRec[labeled[eP.ptr.labelseqnum]];      }    ELSE {      lab1rec ¬ LabelRec[unlabeled[curMISeqNum + 1]]; immCurDestField ¬ TRUE; };    IF NOT EqualString[lab2, "$"L] THEN {      IF EqualString[lab2, lab1] THEN lab2rec ¬ lab1rec      ELSE {        eP ¬ ProcessDestLabel[lab2];        lab2rec ¬ LabelRec[labeled[eP.ptr.labelseqnum]];        };      }    ELSE {      lab2rec ¬ LabelRec[unlabeled[curMISeqNum + 1]]; immCurDestField ¬ TRUE; };    constraintRec ¬ ConstraintRec[lab1rec, lab2rec, offset, modulo];    [] ¬ Stream.PutBlock[DsyFile.mlStream, crBlock];    END;  -- end Constrain  DetachAtLabel: PROCEDURE [    list: LONG POINTER TO LabelListPtr, atPtr: HashEntryPtr] =    --take the at label from the list of labels for this instruction    BEGIN    prev: LabelListPtr;    ptr: LabelListPtr;    prev ¬ ptr ¬ list­;    UNTIL ptr = NIL DO      IF String.EqualString[ptr.label.key, atPtr.key] THEN EXIT      ELSE {prev ¬ ptr; ptr ¬ ptr.next};      ENDLOOP;    IF prev = ptr THEN list­ ¬ NIL ELSE prev.next ¬ NIL;    END;  --of procedure DetachAtLabel  EndOfStatementProc: PUBLIC PROCEDURE =    --error checking for each statement    BEGIN    constraintRec: ConstraintRec;    crBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[LONG[@constraintRec]], startIndex: 0,      stopIndexPlusOne: Environment.bytesPerWord * SIZE[ConstraintRec]];    enil: Encoding ¬ Encoding[];    eP: EncodingPtr ¬ DsyControl.statement.encoding;    ptr: LabelListPtr;    temp: AddressConstant;    temp3: Extract3;    temp4: Extract4;    IF DsyControl.linkLoad THEN {      constraintRec ¬ ConstraintRec[curMI.dest, curMI.dest, DsyControl.linkVal, 4];      [] ¬ Stream.PutBlock[DsyFile.mlStream, crBlock];      linkLoad ¬ FALSE;      };    IF eP = NIL THEN eP ¬ @enil;    destination ¬ GetrDField[eP.rD.value, eP.rB.value];    thisMI.pBr ¬ (eP.dspB.value # dspBNoop) AND (eP.dspB.value # dspBIBDisp)      AND (eP.dspB.value # dspBAlwaysIBDisp);    thisMI.ibDisp ¬ (eP.dspB.value = dspBIBDisp)      OR (eP.dspB.value = dspBAlwaysIBDisp);    thisMI.isStar ¬ flaggedByStar = curMISeqNum;    thisMI.isBr ¬ canceledBr;    thisMI.pageCrossCanceled ¬ canceledBr1;    thisMI.ldStkp ¬ eP.rD.value = rDStkPtr;    thisMI.isstk ¬ eP.isPop OR eP.isPush;    thisMI.isGetsIB ¬ eP.rB.value IN [rBIB..rBIBSE];    IF fromMI.pBr THEN thisMI.needsBr ¬ TRUE;    IF fromMI.pageCross THEN thisMI.needsCancelPage ¬ TRUE;    IF fromMI.ldStkp THEN thisMI.stknok ¬ TRUE;    IF fromMI.isGetsIB THEN thisMI.fromGetsIB ¬ TRUE;    DsyModule.SetUpMemStatus[@thisMI, atLabel, thisLabel, newAtEntry];    IF NOT natc AND atLabel # NIL THEN AppendLabel[@thisLabel, atLabel];    IF hasLabel THEN lastLabel ¬ thisLabel.label;    IF NOT hasLabel AND atLabel = NIL AND NOT immLastDestField THEN      DsyFile.LogErrAndSrcLines["This MI cannot be gotten to "L];    ptr ¬ thisLabel;    UNTIL ptr = NIL DO  --LabelRec set up previously by MI jumped from      thisMI.target ¬ thisMI.target + ptr.label.ptr.target;      thisMI.needsBr ¬ thisMI.needsBr OR ptr.label.ptr.needsBr;      thisMI.needsCancelPage ¬ thisMI.needsCancelPage        OR ptr.label.ptr.needsCancelPage;      thisMI.isBr ¬ thisMI.isBr AND ptr.label.ptr.isBr;      thisMI.stknok ¬ thisMI.stknok OR ptr.label.ptr.stknok;      thisMI.ldStkpnok ¬ thisMI.ldStkpnok OR ptr.label.ptr.ldStkpnok;      thisMI.needsStar ¬ thisMI.needsStar AND ptr.label.ptr.needsStar;      thisMI.jumpFromEnd ¬ thisMI.jumpFromEnd OR ptr.label.ptr.jumpFromEnd;      thisMI.alwaysJumpFromCycleOK ¬ thisMI.alwaysJumpFromCycleOK        AND ptr.label.ptr.alwaysJumpFromCycleOK;      thisMI.fromGetsIB ¬ thisMI.fromGetsIB OR ptr.label.ptr.fromGetsIB;      thisMI.usesMD ¬ thisMI.usesMD OR ptr.label.ptr.usesMD;      thisMI.startWrite ¬ thisMI.startWrite OR ptr.label.ptr.startWrite;      thisMI.destination ¬ ptr.label.ptr.destination;      thisMI.referenced ¬ ptr.label.ptr.referenced;      ptr ¬ ptr.next;      ENDLOOP;    DsyModule.CheckMemory[eP, @fromMI, @thisMI];    thisMI.c2ok ¬ thisMI.needsCycle = 2      AND thisMI.memStatus IN [write..doubleWrite]      AND ((canceledBr AND NOT canceledBr1) OR (wok AND canceledBr1));    thisMI.usesMD ¬ thisMI.usesMD      OR (memory AND (eP.mo.value = moU OR eP.mo.value = moDoubleU));    thisMI.usedOffsetAdder ¬ thisMI.usedOffsetAdder OR offsetAdder;    thisMI.startWrite ¬ thisMI.startWrite      OR (memory AND thisMI.memStatus IN [singleWrite..doubleWrite]);    IF (ptr ¬ thisLabel) = NIL THEN      DsyModule.CheckAFile[eP, @thisMI, @fromMI, thisLabel, toLabel]    ELSE {      UNTIL ptr = NIL DO        DsyModule.CheckAFile[eP, ptr.label.ptr, @fromMI, thisLabel, toLabel];        thisMI.c2ok ¬ thisMI.c2ok AND ptr.label.ptr.c2ok;        ptr ¬ ptr.next;        ENDLOOP};    IF branchType = disp AND cycleOK THEN {      DsyFile.LogErrAndSrcLines[        "LOOPHOLE[CycleOK] and DISPn not allowed in same MI"L];      cycleOK ¬ FALSE};    IF eP.op.value = 2 THEN {      temp.word ¬ eP.ac.value;      temp.pad ¬ 255;      temp4.word ¬ eP.aiu.value;  --extract 4 bits of aiu from value      temp.aiu ¬ temp4.lower4;      temp3.word ¬ eP.ail.value;  --extract 3 bits of ail from value      temp.ail ¬ temp3.lower3;      temp.word ¬ Inline.BITNOT[temp.word];  --values are stored complemented      IF (temp.word # 0 OR eP.om.value # omImmed)        AND (offsetAdder OR (thisMI.isCycle = 1)) THEN thisMI.pageCross ¬ TRUE;      };    IF offsetAdder THEN      IF NOT (aFile OR reference.regType = aLower16) THEN        DsyFile.LogErrAndSrcLines["The offset adder requires use of the A file"L];    IF memory THEN      IF NOT aFile THEN        DsyFile.LogErrAndSrcLines["MAR¬ requires use of the A file"L];    IF expression AND eP.op.value = 2 THEN      DsyFile.LogErrAndSrcLines["Expression invalid"L];    IF thisMI.needsCancelPage AND NOT (thisMI.pageCrossCanceled OR thisMI.isBr)      THEN {  --see comment 6 lines below      IF fromMI.pageCross AND NOT (canceledBr1 OR canceledBr) THEN        DsyFile.LogErrAndSrcLines["This MI needs a CANCELBR[ ,1]"L]      ELSE        IF NOT (canceledBr1 OR canceledBr) THEN          DsyFile.LogErrAndSrcLines["This MI needs a CANCELBR[ ,1]"L]}    ELSE      IF thisMI.needsBr AND NOT thisMI.isBr THEN  --make allowance for the case that a dispatch condition is set up in previous instruction and canceled in this one which also contains an at from a previous dispatch that does not set up a dispatch condition.  in this case, thisMI.isBr will be false but no error exists.        IF fromMI.pBr AND NOT canceledBr THEN          DsyFile.LogErrAndSrcLines["This MI needs a CANCELBR"L]        ELSE          IF NOT canceledBr THEN            DsyFile.LogErrAndSrcLines["This MI needs a CANCELBR"L];    IF thisMI.pageCrossCanceled AND NOT wok AND thisMI.isCycle = 2      AND thisMI.memStatus IN [write..doubleWrite] AND thisMI.needsCancelPage THEN      DsyFile.LogErrAndSrcLines[        "Illegal CANCELBR on memory write - - write may abort"L];    IF thisMI.stknok AND thisMI.isstk THEN      DsyFile.LogErrAndSrcLines[        "This MI increments or decrements the stack and StkP loaded in previous instruction"L];    IF eP.isPop AND eP.isPush THEN      DsyFile.LogErrAndSrcLines["This MI both pops and pushes the stack"L];    IF (eP.isPop AND NOT eP.isStk) OR (eP.isPush AND NOT eP.isStk) THEN      DsyFile.LogErrAndSrcLines["This MI needs a stack reference"L];    IF thisMI.isStar AND (NOT thisMI.needsStar) AND thisMI.target > 0 THEN      DsyFile.LogErrAndSrcLines[        "This MI is jumped to from a MI which does not have an IBDisp"L];    IF thisMI.isStar THEN      IF immLastDestField THEN {        IF NOT fromMI.ibDisp THEN          DsyFile.LogErrAndSrcLines["This MI does not need a GOTO[*]"L]}      ELSE        IF NOT (hasLabel OR (atLabel # NIL)) THEN          DsyFile.LogErrAndSrcLines["This MI does not need a GOTO[*]"L];    IF (eP.rD.value = rDCIP)      AND (eP.sp1.value = sp1IncCIP OR eP.sp1.value = sp1DIncCIP) THEN      DsyFile.LogErrAndSrcLines[        "This MI cannot set CIP and increment it at the same time"L];    IF (eP.sp2.value = sp2PopIB OR eP.ib.value = ibPopIB)      AND (eP.dspB.value = dspBIBDisp) THEN      DsyFile.LogErrAndSrcLines[        "This MI cannot PopIB and do an IBDisp at the same time"];    IF bBus AND eP.op.value = cycle2 THEN      DsyFile.LogErrAndSrcLines["Bbus ¬ is illegal during this op"L];    IF aBus AND eP.op.value = cycle2 AND eP.mo.value # moNoop THEN       DsyFile.LogErrAndSrcLines["Abus ¬ is illegal during this op unless mo = Noop"L];    IF thisMI.fromGetsIB AND thisMI.memStatus IN [singleWrite..doubleWrite]      AND thisMI.needsCycle = cycle1 THEN      DsyFile.LogErrAndSrcLines[        "This MI may not start a memory reference since an IBEmpty trap may occur"L];    IF aluGets AND (eP.op.value = cycle1 OR eP.op.value = cycle2) THEN      DsyFile.LogErrAndSrcLines["ALU ¬ is illegal during this op"L];    IF atLabel # NIL THEN {  --update up LabelRec for this MI which is within a table      DetachAtLabel[@thisLabel, atLabel];      atLabel.ptr.isBr ¬ atLabel.ptr.isBr AND thisMI.isBr;      atLabel.ptr.pageCross ¬ atLabel.ptr.pageCross OR thisMI.pageCross;      atLabel.ptr.pageCrossCanceled ¬ atLabel.ptr.pageCrossCanceled        AND thisMI.pageCrossCanceled;      atLabel.ptr.isstk ¬ atLabel.ptr.isstk OR thisMI.isstk;      atLabel.ptr.ibDisp ¬ atLabel.ptr.ibDisp OR thisMI.ibDisp;      atLabel.ptr.isStar ¬ atLabel.ptr.isStar OR thisMI.isStar;      atLabel.ptr.needsStar ¬ atLabel.ptr.needsStar AND thisMI.needsStar;      atLabel.ptr.jumpFromEnd ¬ atLabel.ptr.jumpFromEnd OR thisMI.jumpFromEnd;      atLabel.ptr.c2ok ¬ thisMI.c2ok AND atLabel.ptr.c2ok;      atLabel.ptr.usesMD ¬ thisMI.usesMD OR atLabel.ptr.usesMD;      atLabel.ptr.usedOffsetAdder ¬ thisMI.usedOffsetAdder OR atLabel.ptr.usedOffsetAdder;      atLabel.ptr.isGetsIB ¬ thisMI.isGetsIB OR atLabel.ptr.isGetsIB;      atLabel.ptr.fromGetsIB ¬ thisMI.fromGetsIB OR atLabel.ptr.fromGetsIB;      atLabel.ptr.startWrite ¬ thisMI.startWrite OR atLabel.ptr.startWrite;      atLabel.ptr.memStatus ¬ thisMI.memStatus;      atLabel.ptr.needsCycle ¬ thisMI.needsCycle;      atLabel.ptr.isCycle ¬ thisMI.isCycle};    ptr ¬ thisLabel;    UNTIL ptr = NIL DO  --set up LabelRec ignoring the fact that this MI may be part of a table.  another MI could jump into the table without dispatching into it and if so the record as used for the table is not what is needed.      ptr.label.ptr.isBr ¬ canceledBr;      ptr.label.ptr.pageCross ¬ thisMI.pageCross;      ptr.label.ptr.pageCrossCanceled ¬ canceledBr1;      ptr.label.ptr.isstk ¬ thisMI.isstk;      ptr.label.ptr.ibDisp ¬ thisMI.ibDisp;      ptr.label.ptr.isStar ¬ thisMI.isStar;      ptr.label.ptr.needsStar ¬ thisMI.needsStar;      ptr.label.ptr.jumpFromEnd ¬ thisMI.jumpFromEnd;      ptr.label.ptr.c2ok ¬ thisMI.c2ok;      ptr.label.ptr.usesMD ¬ memory        AND (eP.mo.value = moU OR eP.mo.value = moDoubleU);      ptr.label.ptr.usedOffsetAdder ¬ thisMI.usedOffsetAdder;      ptr.label.ptr.isGetsIB ¬ eP.rB.value IN [rBIB..rBIBSE];      ptr.label.ptr.fromGetsIB ¬ thisMI.fromGetsIB;      ptr.label.ptr.startWrite ¬ memory        AND thisMI.memStatus IN [singleWrite..doubleWrite];      ptr.label.ptr.memStatus ¬ thisMI.memStatus;      ptr.label.ptr.needsCycle ¬ thisMI.needsCycle;      ptr.label.ptr.isCycle ¬ thisMI.isCycle;      ptr ¬ ptr.next;      ENDLOOP;    ptr ¬ toLabel;    UNTIL ptr = NIL DO  --Set up record for instruction branched to      IF ptr.label.ptr.found OR ptr.label.ptr.incons THEN {        IF thisMI.pBr AND NOT ptr.label.ptr.isBr THEN {          IF NOT errgcb THEN            DsyFile.LogErrAndSrcLines[              "This MI goes to an MI which needs a CANCELBR"L];          errgcb ¬ TRUE;          };        IF thisMI.pageCross THEN          SELECT thisMI.memStatus FROM            singleRead, doubleRead =>              IF NOT (ptr.label.ptr.pageCrossCanceled OR ptr.label.ptr.isBr) THEN                DsyFile.LogErrAndSrcLines[                  "This MI goes to an MI which needs a CANCELBR[, 1] or BRANCH"L];            singleWrite, doubleWrite =>              IF NOT ptr.label.ptr.c2ok THEN                DsyFile.LogErrAndSrcLines[                  "This MI goes to an MI which needs a BRANCH or a CANCELBR[ ,1], LOOPHOLE[wok] "L];            read, write => NULL;  --this branch will never be taken. during c1 either the cycle type is known or an error message has been generated            ENDCASE;        IF thisMI.ldStkp AND ptr.label.ptr.isstk THEN          DsyFile.LogErrAndSrcLines[            "This MI goes to an MI which increments or decrements the stack and StkP loaded here"L];        ptr.label.ptr.needsStar ¬ thisMI.ibDisp AND ptr.label.ptr.needsStar;        IF thisMI.pBr THEN          ptr.label.ptr.needsBr ¬ thisMI.pBr OR ptr.label.ptr.needsBr;        IF thisMI.pageCross THEN          ptr.label.ptr.needsCancelPage ¬ ptr.label.ptr.needsCancelPage            OR thisMI.pageCross;        IF thisMI.ldStkp THEN          ptr.label.ptr.stknok ¬ ptr.label.ptr.stknok OR thisMI.ldStkp;        ptr.label.ptr.fromGetsIB ¬ ptr.label.ptr.fromGetsIB OR thisMI.isGetsIB;        IF ptr.label.ptr.isStar AND NOT thisMI.ibDisp THEN          DsyFile.LogErrAndSrcLines[            "This MI  goes to an MI which does not need a GOTO[*]"L];        IF thisMI.isGetsIB AND ptr.label.ptr.startWrite THEN          DsyFile.LogErrAndSrcLines[            "This MI goes to an MI that may not start a memory reference since an IBEmpty trap may occur"L];        IF NOT cycleOK THEN JumpCheckMemory[ptr]}      ELSE {  --label not encountered yet        CheckDestSame[ptr.label.ptr];        ptr.label.ptr.alwaysJumpFromCycleOK ¬ ptr.label.ptr.alwaysJumpFromCycleOK          AND cycleOK;        ptr.label.ptr.fromGetsIB ¬ ptr.label.ptr.fromGetsIB OR thisMI.isGetsIB;            ptr.label.ptr.needsStar ¬ thisMI.ibDisp AND ptr.label.ptr.needsStar;        IF thisMI.pBr THEN          ptr.label.ptr.needsBr ¬ thisMI.pBr OR ptr.label.ptr.needsBr;        IF thisMI.pageCross THEN          ptr.label.ptr.needsCancelPage ¬ ptr.label.ptr.needsCancelPage            OR thisMI.pageCross;        IF thisMI.ldStkp THEN          ptr.label.ptr.stknok ¬ ptr.label.ptr.stknok OR thisMI.ldStkp};      ptr ¬ ptr.next;      ENDLOOP;    DsyModule.CheckSourceLine[];    ResetLabel[];    END;  -- end EndOfStatementProc  GetLabelEntry: PUBLIC PROC [name: LONG STRING]    RETURNS [hashEntryPtr: HashEntryPtr] =    BEGIN    str: LONG STRING;    labelEntryPtr: LabelEntryPtr;    labelEntryPtr ¬ Heap.MakeNode[      LTtempHeap,      SIZE[LabelEntry] + SIZE[HashEntry] + WordsForString[name.length]];    hashEntryPtr ¬ LOOPHOLE[labelEntryPtr + SIZE[LabelEntry]];    str ¬ LOOPHOLE[hashEntryPtr + SIZE[HashEntry]];    str­ ¬ [length: 0, maxlength: name.length, text:];    AppendString[str, name];    labelEntryPtr­ ¬ LabelEntry[];    hashEntryPtr­ ¬ HashEntry[str, labelEntryPtr, NIL];    END;  -- end GetLabelEntry  JumpCheckMemory: PROCEDURE [ptr: LabelListPtr] = INLINE    --error checking for memory cycles. called when the current microinstruction jumps to an instruction which has already been found.    BEGIN    SELECT thisMI.memStatus FROM      read =>        IF ptr.label.ptr.needsCycle # thisMI.needsCycle + 1 THEN          IF thisMI.needsCycle # 3 THEN MemoryError[jumpCycleConflict]          ELSE thisMI.memStatus ¬ singleRead        ELSE          SELECT ptr.label.ptr.memStatus FROM            singleRead, doubleRead => thisMI.memStatus ¬ ptr.label.ptr.memStatus;            read => NULL;            ENDCASE =>              IF ptr.label.ptr.needsCycle < cycle3 THEN MemoryError[typeConflict];      write =>        IF ptr.label.ptr.needsCycle # thisMI.needsCycle + 1 THEN          IF thisMI.needsCycle # cycle3 THEN MemoryError[jumpCycleConflict]          ELSE thisMI.memStatus ¬ singleWrite        ELSE          SELECT ptr.label.ptr.memStatus FROM            singleWrite, doubleWrite => thisMI.memStatus ¬ ptr.label.ptr.memStatus;            write => NULL;            ENDCASE =>              IF ptr.label.ptr.needsCycle < cycle3 THEN MemoryError[typeConflict];      singleRead =>        IF thisMI.needsCycle # cycle3 THEN          IF ptr.label.ptr.isCycle # ((thisMI.needsCycle + 1) MOD 4) THEN            MemoryError[jumpCycleConflict]          ELSE {            IF ptr.label.ptr.memStatus NOT IN [read..singleRead] THEN {              IF ptr.label.ptr.needsCycle # cycle3 THEN MemoryError[typeConflict]}}        ELSE          IF ptr.label.ptr.isCycle NOT IN [cycle0..cycle1] THEN            MemoryError[jumpCycleConflict];      singleWrite =>        IF thisMI.needsCycle # cycle3 THEN          IF ptr.label.ptr.isCycle # ((thisMI.needsCycle + 1) MOD 4) THEN            MemoryError[jumpCycleConflict]          ELSE {            IF ptr.label.ptr.memStatus NOT IN [write..singleWrite] THEN {              IF ptr.label.ptr.needsCycle # cycle3 THEN MemoryError[typeConflict]}}        ELSE          IF ptr.label.ptr.isCycle NOT IN [cycle0..cycle1] THEN            MemoryError[jumpCycleConflict];      doubleRead =>        IF thisMI.needsCycle # cycle4 THEN          IF ptr.label.ptr.isCycle # ((thisMI.needsCycle + 1) MOD 5) THEN            MemoryError[jumpCycleConflict]          ELSE {            IF NOT              (ptr.label.ptr.memStatus = doubleRead                OR ptr.label.ptr.memStatus = read) THEN {              IF ptr.label.ptr.needsCycle < cycle3 THEN MemoryError[typeConflict]}}        ELSE          IF ptr.label.ptr.isCycle NOT IN [cycle0..cycle1] THEN            MemoryError[jumpCycleConflict];      doubleWrite =>        IF thisMI.needsCycle # cycle4 THEN          IF ptr.label.ptr.isCycle # ((thisMI.needsCycle + 1) MOD 5) THEN            MemoryError[jumpCycleConflict]          ELSE {            IF NOT              (ptr.label.ptr.memStatus = doubleWrite                OR ptr.label.ptr.memStatus = write) THEN {              IF ptr.label.ptr.needsCycle < cycle3 THEN MemoryError[typeConflict]}}        ELSE          IF ptr.label.ptr.isCycle NOT IN [cycle0..cycle1] THEN            MemoryError[jumpCycleConflict];      none =>        IF ptr.label.ptr.isCycle NOT IN [cycle0..cycle1] THEN          MemoryError[jumpCycleConflict];      ENDCASE => MemoryError[jumpCycleConflict]    END;  --of procedure JumpCheckMemory  LabelInit: PROC =    BEGIN    atLabel ¬ NIL;    thisLabel ¬ NIL;    toLabel ¬ NIL;    thisMI ¬ LabelEntry[];    fromMI ¬ LabelEntry[];    reference ¬ ArgumentType[];    curLabelSeqNum ¬ curMISeqNum ¬ 0;    curMILabelSeqNum ¬ none;    immLastDestField ¬ immCurDestField ¬ extCurDestField ¬ FALSE;    adjMI ¬ hasLabel ¬ newAtEntry ¬ FALSE;    wok ¬ oldok ¬ cycleOK ¬ natc ¬ canceledBr ¬ canceledBr1 ¬ FALSE;    branchType ¬ none;    flaggedByStar ¬ 0FFFFH;    fromCycleOK ¬ FALSE;    fromDest ¬ ArgumentType[];    errgcb ¬ FALSE;    miResUsed ¬ FALSE;    curMI ¬ CurrentMI[dest: LabelRec[unlabeled[1]]];    curLineLab.length ¬ 0;    AppendString[curLineLab, "beginning m-i"L];    curLineNum ¬ 0;    END;  -- end LabelInit  McFileEndProc: PUBLIC PROC =    BEGIN    constraintRec: ConstraintRec;    crBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[LONG[@constraintRec]], startIndex: 0,      stopIndexPlusOne: Environment.bytesPerWord * SIZE[ConstraintRec]];    earlyBinaryRec: EarlyBinaryRec;    ebrBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[LONG[@earlyBinaryRec]], startIndex: 0,      stopIndexPlusOne: Environment.bytesPerWord * SIZE[EarlyBinaryRec]];    lsr: LabelIntRec;    lsrBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[LONG[@lsr]], startIndex: 0,      stopIndexPlusOne: Environment.bytesPerWord * SIZE[LabelIntRec]];    str: LONG STRING ¬ "  Number of m-i  =  xxxxx"L;    IF immLastDestField AND (NOT (flaggedByStar = (curMISeqNum - 1))) THEN      DsyFile.LogErrAndSrcLines["The last MI lacks a destination "L];    DsyModule.CheckSourceLine[];    -- write a final ml record    constraintRec ¬ ConstraintRec[LabelRec[special[]], LabelRec[special[]], 0, 0];    [] ¬ Stream.PutBlock[DsyFile.mlStream, crBlock];    -- write a final eb record    earlyBinaryRec ¬ EarlyBinaryRec[      partialBinary: PartialBinary[], destMI: CurrentMI[], last: TRUE];    [] ¬ Stream.PutBlock[DsyFile.ebStream, ebrBlock];    -- write the reserves    [] ¬ Stream.PutWord[DsyFile.mlStream, LOOPHOLE[miResUsed, WORD]];    IF miResUsed THEN      [] ¬ Stream.PutBlock[        DsyFile.mlStream, Environment.Block[        blockPointer: LOOPHOLE[miRes], startIndex: 0,        stopIndexPlusOne: Environment.bytesPerWord * SIZE[MiRes]]];    -- write out symbol table    DisplayLabels[PutOutSymbol];    -- put out the final record    lsr ¬ LabelIntRec[      export: FALSE, import: FALSE, found: FALSE, labIndex: 0, length: 0,      miIndex: Empty];    [] ¬ Stream.PutBlock[DsyFile.siStream, lsrBlock];    [] ¬ Stream.PutWord[DsyFile.siStream, curMISeqNum];    [] ¬ Stream.PutWord[DsyFile.siStream, curLabelSeqNum];    str.length ¬ str.length - 5;    AppendDecimal[str, curMISeqNum];    AppendChar[str, Ascii.CR];    DsyFile.LogLine[str];    LabelInit[];    END;  -- end McFileEndProc  MakeLabelEntry: PROC [name: LONG STRING] RETURNS [hashEntryPtr: HashEntryPtr] =    BEGIN    hashEntryPtr ¬ NIL;    IF name # NIL THEN {      hashEntryPtr ¬ FindLabel[name];      IF hashEntryPtr = NIL THEN {  -- label was not in table        hashEntryPtr ¬ GetLabelEntry[name];        hashEntryPtr.ptr.labelseqnum ¬ curLabelSeqNum;        [] ¬ InsertLabel[hashEntryPtr];        curLabelSeqNum ¬ curLabelSeqNum + 1;        };      };    END;  -- end MakeLabelEntry  ProcessAt: PUBLIC PROC [    offset: CARDINAL, modulo: ModuloIndex, name: LONG STRING] =    BEGIN    str: LONG STRING ¬ [100];    labelRec: LabelRec ¬ LabelRec[special[]];    begLabelSeqNum: LabelSeqNum ¬ curLabelSeqNum;    constraintRec: ConstraintRec;    crBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[LONG[@constraintRec]], startIndex: 0,      stopIndexPlusOne: Environment.bytesPerWord * SIZE[ConstraintRec]];    hashEntryPtr: HashEntryPtr;    IF name # NIL THEN {      hashEntryPtr ¬ MakeLabelEntry[name];      hashEntryPtr.ptr.incons ¬ TRUE;      atLabel ¬ hashEntryPtr}    ELSE {      IF NOT hasLabel THEN {        name ¬ GetStmtSpace[WordsForString[30]];        name­ ¬ StringBody[maxlength: 30, length: 0, text:];        IF lastLabel = NIL THEN AppendString[name, bogusPart]        ELSE {          AppendString[            name, lastLabel.key !            StringBoundsFault => {              ns ¬ GetStmtSpace[WordsForString[lastLabel.key.length]];              ns­ ¬ StringBody[maxlength: lastLabel.key.length, length: 0, text:];              AppendString[ns, s];              RESUME [ns]}];          AppendString[            name, bogusPart !            StringBoundsFault => {              ns ¬ GetStmtSpace[WordsForString[lastLabel.key.length + 6]];              ns­ ¬ StringBody[                maxlength: lastLabel.key.length + 6, length: 0, text:];              AppendString[ns, s];              RESUME [ns]}]};        hashEntryPtr ¬ MakeLabelEntry[name];        atLabel ¬ hashEntryPtr};      labelRec ¬ LabelRec[unlabeled[curMISeqNum]]};    hasLabel ¬ TRUE;    IF labelRec.type = special THEN      labelRec ¬        SELECT TRUE FROM          hashEntryPtr.ptr.found => LabelRec[unlabeled[hashEntryPtr.ptr.miseqnum]],          ENDCASE => LabelRec[labeled[hashEntryPtr.ptr.labelseqnum]];    constraintRec ¬ ConstraintRec[      LabelRec[unlabeled[curMISeqNum]], labelRec, offset, modulo];    [] ¬ Stream.PutBlock[DsyFile.mlStream, crBlock];    newAtEntry ¬ curLabelSeqNum > begLabelSeqNum;    END;  -- end ProcessAt  ProcessDestLabel: PUBLIC PROC [name: LONG STRING]    RETURNS [hashEntryPtr: HashEntryPtr] =    BEGIN    IF EqualString[name, "$"L] THEN RETURN;    extCurDestField ¬ TRUE;    IF name = NIL THEN RETURN[NIL];    hashEntryPtr ¬ MakeLabelEntry[name];    AppendLabel[@toLabel, hashEntryPtr];    END;  -- end ProcessDestLabel  ProcessExternal: PUBLIC PROC [type: BuiltinMacroType, name: LONG STRING] =    BEGIN    hashEntryPtr: HashEntryPtr ¬ MakeLabelEntry[name];    SELECT type FROM      export => hashEntryPtr.ptr.export ¬ TRUE;      import => hashEntryPtr.ptr.import ¬ TRUE;      ENDCASE;    END;  -- end ProcessExternal  ProcessLineLabel: PUBLIC PROC [name: LONG STRING]    RETURNS [hashEntryPtr: HashEntryPtr] =    BEGIN    curLineLab.length ¬ 0;    AppendString[curLineLab, name];    curLineNum ¬ 0;    hashEntryPtr ¬ MakeLabelEntry[name];    curMILabelSeqNum ¬ curLabelSeqNum;    hashEntryPtr.ptr.labeled ¬ TRUE;    hashEntryPtr.ptr.found ¬ TRUE;    IF hashEntryPtr.ptr.miseqnum # NullIndex THEN      DsyFile.LogErrArgAndSrcLines["Label previously defined "L, name];    hashEntryPtr.ptr.miseqnum ¬ curMISeqNum;    curMILabelSeqNum ¬ hashEntryPtr.ptr.labelseqnum;    hasLabel ¬ TRUE;    AppendLabel[@thisLabel, hashEntryPtr];    END;  -- end ProcessLineLabel  ProcessReserve: PUBLIC PROC [lowAddr, highAddr: CARDINAL] =    BEGIN    i: CARDINAL;    miResUsed ¬ TRUE;    FOR i IN [lowAddr..highAddr] DO miRes[i] ¬ TRUE ENDLOOP;    END;  -- end ProcessReserve  ProcSA: PUBLIC PROC [name: LONG STRING, sa: BOOLEAN] =    --process start address    BEGIN    earlyBinaryRec: EarlyBinaryRec;    ebrBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[LONG[@earlyBinaryRec]], startIndex: 0,      stopIndexPlusOne: Environment.bytesPerWord * SIZE[EarlyBinaryRec]];    hashEntryPtr: HashEntryPtr;    IF name = NIL THEN RETURN;    hashEntryPtr ¬ MakeLabelEntry[name];    IF sa THEN {      IF (startAddress # -1) AND (startAddress # hashEntryPtr.ptr.labelseqnum) THEN        DsyFile.LogErrAndSrcLines["Multiple start addresses"L];      startAddress ¬ hashEntryPtr.ptr.labelseqnum;      earlyBinaryRec ¬ [        destMI: CurrentMI[dest: LabelRec[labeled[hashEntryPtr.ptr.labelseqnum]]],        last: FALSE, sa: sa]}    ELSE {      IF (startAddressPlus1 # -1) AND (startAddress # hashEntryPtr.ptr.labelseqnum)        THEN DsyFile.LogErrAndSrcLines["Multiple start plus 1 addresses"L];      startAddressPlus1 ¬ hashEntryPtr.ptr.labelseqnum;      earlyBinaryRec ¬ [        destMI: CurrentMI[dest: LabelRec[labeled[hashEntryPtr.ptr.labelseqnum]]],        last: FALSE, sa: saPlus1]};    [] ¬ Stream.PutBlock[DsyFile.ebStream, ebrBlock];    END;  -- end ProcSA  PutOutSymbol: PROC [hptr: HashEntryPtr] =    --write symbols to file    BEGIN    last3Chars: SubStringDescriptor;    lsr: LabelIntRec;    lsrBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[LONG[@lsr]], startIndex: 0,      stopIndexPlusOne: Environment.bytesPerWord * SIZE[LabelIntRec]];    IF hptr.key.length >= bogusPart.length THEN {      last3Chars ¬ SubStringDescriptor[hptr.key, hptr.key.length - 3, 3];      IF String.EqualSubString[@last3Chars, @bogusSubString] THEN RETURN};  --don't put bogus label needed by assembler into symbol table    lsr ¬ LabelIntRec[      export: hptr.ptr.export, import: hptr.ptr.import, incons: hptr.ptr.incons,      found: hptr.ptr.found, target: (hptr.ptr.target > 0),      isCycle: hptr.ptr.isCycle, needsCycle: hptr.ptr.needsCycle,      cycleOK: hptr.ptr.alwaysJumpFromCycleOK,       memStatus: hptr.ptr.memStatus, labIndex: hptr.ptr.labelseqnum,       length: hptr.key.length, miIndex: hptr.ptr.miseqnum];    [] ¬ Stream.PutBlock[DsyFile.siStream, lsrBlock];    [] ¬ Stream.PutBlock[      DsyFile.siStream, Environment.Block[      blockPointer: LOOPHOLE[@hptr.key.text], startIndex: 0,      stopIndexPlusOne: hptr.key.length]];    END;  -- end PutOutSymbol  ResetLabel: PUBLIC PROCEDURE =     --reintialize variables for every microcode statement    BEGIN    adjMI ¬ (immCurDestField OR NOT extCurDestField) AND (NOT thisMI.isStar);    atLabel ¬ NIL;    thisLabel ¬ NIL;    toLabel ¬ NIL;    aFile ¬ bBus ¬ aBus ¬ offsetAdder ¬ mdr ¬ cycleTypeSpecified ¬ memory ¬      expression ¬ popIB ¬ aluGets ¬ FALSE;    immLastDestField ¬ adjMI;    IF immLastDestField THEN {fromDest ¬ destination; fromCycleOK ¬ cycleOK}    ELSE {fromCycleOK ¬ FALSE; fromDest ¬ ArgumentType[]};    IF adjMI THEN fromMI ¬ thisMI ELSE fromMI ¬ LabelEntry[];    thisMI ¬ LabelEntry[];    curMISeqNum ¬ curMISeqNum + 1;    curMI ¬ CurrentMI[dest: LabelRec[unlabeled[curMISeqNum + 1]]];    curMILabelSeqNum ¬ none;    curLineNum ¬ curLineNum + 1;    adjMI ¬ extCurDestField ¬ immCurDestField ¬ FALSE;    hasLabel ¬ canceledBr ¬ canceledBr1 ¬ FALSE;    wok ¬ oldok ¬ cycleOK ¬ natc ¬ bBus ¬ newAtEntry ¬ FALSE;    branchType ¬ none;    errgcb ¬ FALSE;    destination ¬ ArgumentType[];    reference ¬ ArgumentType[];    parity ¬ ParityMasks[];    END;  --end of ResetLabel  SetDest: PUBLIC PROC [lab: LONG STRING, and: CARDINAL, or: CARDINAL] =    BEGIN    hP: HashEntryPtr;    IF String.EqualString[lab, "*"L] THEN {flaggedByStar ¬ curMISeqNum; RETURN};    curMI.andMask ¬ and;    curMI.orMask ¬ or;    IF lab.length = 0 THEN {      curMI.dest ¬ LabelRec[absolute[and]]; extCurDestField ¬ TRUE; }    ELSE {      IF EqualString[lab, "$"L] THEN RETURN;      hP ¬ ProcessDestLabel[lab];      curMI.dest ¬ LabelRec[labeled[hP.ptr.labelseqnum]];      hP.ptr.target ¬ hP.ptr.target + 1;      };    END;  -- end SetDest  END...--Log--JAC   	17-Aug-84 11:10:49	added cycleOK to LabelIntRec so must be written in PutOutSymbol --JAC   	 5-Nov-84 14:20:17	fixed arrows for Mesa 11.1--JAC   	 5-Nov-84 14:20:17	added test for ABus ¬ during op = 2--JAC   	21-May-85 15:42:10	added usedOffsetAdder
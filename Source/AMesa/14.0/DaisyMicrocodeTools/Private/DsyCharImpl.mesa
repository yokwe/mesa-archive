-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. --File: DsyCharImpl.mesa --Last edit by JAC        5-Nov-84 14:15:57 DIRECTORY  Ascii USING [CR, ControlZ],  Environment USING [Byte],  Stream USING [PutChar],  String USING [AppendNumber, AppendString],  DsyAssembler,  DsyControl USING [flagNestedComments],  DsyFile USING [erStream, LogErrAndSrcLines, LogLine, LogText],  DsyLabel USING [curLineLab, curLineNum],  DsyModule;DsyCharImpl: PROGRAM IMPORTS Stream, String, DsyControl, DsyLabel, DsyFile EXPORTS DsyModule =  BEGIN OPEN DsyAssembler;  -- global variables  char: CHARACTER;  -- current (most recently scanned) character  tB: LONG POINTER TO PACKED ARRAY [0..0) OF CHARACTER;  tCur, tMax: CARDINAL;  -- procedures  GetNextProcessChar: PUBLIC PROCEDURE RETURNS [charX: CHARACTER] =  --get next character in file    BEGIN    squiggleLevel: CARDINAL ¬ 0;  --brace count    DO  --main get character loop      char ¬ IF tCur >= tMax THEN EofChar ELSE tB[tCur];      tCur ¬ tCur + 1;      SELECT char FROM        Ascii.CR => NULL;        EofChar => {          IF squiggleLevel # 0 THEN            DsyFile.LogErrAndSrcLines["End of file encountered within Comment "L];          RETURN[char];          };        '{ => 	  BEGIN	  squiggleLevel ¬ squiggleLevel + 1;	  IF squiggleLevel > 1 AND DsyControl.flagNestedComments THEN {	    DsyFile.LogText["Nested comment found at "L];	    PrintSourceLine};	  END;        '} =>          IF squiggleLevel > 0 THEN squiggleLevel ¬ squiggleLevel - 1          ELSE DsyFile.LogErrAndSrcLines["Unmatched comment character"L];        ENDCASE => IF squiggleLevel = 0 THEN RETURN[char];      ENDLOOP;  -- end main get character loop    END;  -- end of procedure GetNextProcessChar  LogSourceLine: PUBLIC PROCEDURE =  --log the source line and the its position within file (last label + offset)    BEGIN    str: LONG STRING ¬ [100];    str.length ¬ 0;    String.AppendString[str, "At location: "L];    String.AppendString[str, DsyLabel.curLineLab];    IF DsyLabel.curLineNum # 0 THEN {      String.AppendString[str, " + "L];      String.AppendNumber[str, DsyLabel.curLineNum, 16];      IF DsyLabel.curLineNum > 9 THEN {        String.AppendString[str, "'x ("L];        String.AppendNumber[str, DsyLabel.curLineNum, 10];        String.AppendString[str, ")"L];        };      };    DsyFile.LogLine[str];     PrintSourceLine;       END;  -- end of procedure LogSourceLine      PrintSourceLine: PROCEDURE =  --print the current line    BEGIN        tLog: CARDINAL;    char: CHARACTER;    n: [1..100];    IF tCur = 0 THEN ERROR ELSE tLog ¬ tCur - 1;    FOR n IN [1..100] DO      IF tLog = 0 THEN EXIT;      IF tB[tLog ¬ tLog - 1] = Ascii.CR THEN {tLog ¬ tLog + 1; EXIT};      ENDLOOP;    FOR n IN [1..100] DO      char ¬ IF tLog >= tMax THEN EofChar ELSE tB[tLog];      SELECT char FROM        EofChar, Ascii.CR, Ascii.ControlZ => EXIT;        ENDCASE => Stream.PutChar[DsyFile.erStream, char];      tLog ¬ tLog + 1;      ENDLOOP;    Stream.PutChar[DsyFile.erStream, Ascii.CR];    Stream.PutChar[DsyFile.erStream, Ascii.CR];    END;  --of procedure PrintSourceLine  ScanInit: PUBLIC PROCEDURE [    segmentAddress: LONG POINTER, sourceLength: CARDINAL] =    BEGIN tCur ¬ 0; tB ¬ segmentAddress; tMax ¬ sourceLength; END;  -- of ScanInit proc  END...--Log of last edits:--JAC   	 5-Nov-84 14:16:13	fixed arrows for Mesa 11.1
-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved. -- Last edit by JAC	11-Jun-85 13:42:39-- CPPanelImpl.mesa, AYC   , 11-Nov-84 21:22:20-- from CPPaneler.mesa, HGM, 21-Nov-83  0:19:16--DIRECTORY  Heap USING [systemZone],  Inline USING [BITAND, HighHalf, LowHalf],  String USING [AppendLongNumber, AppendNumber, AppendString, CopyToNewString],  Tool USING [AddThisSW],  ToolWindow USING [CreateSubwindow, nullBox],  Window USING [Box, Handle],  WindowFont USING [CharWidth, defaultFont, FontHeight, Handle],    CPDef USING [IBDisp, MDR, RealCS],  CPKernel USING [    Error, InKernel, ReadAReg, ReadCS, ReadDReg, ReadLink, ReadMap, ReadOther,    ReadMemoryWord, ReadRReg, ReadVirturalMemory, WriteAReg, WriteDReg, WriteLink,    WriteMap, WriteOther, WriteMemoryWord, WriteRReg, WriteVirturalMemory],  CPPanel USING [],  CPSymbol USING [    AppendMI, AppendSymbol, Error, Eval, nullRealCS, Symbol, VirturalToRealCS],  CPuFormat USING [MI],  PanelSW USING [    AppendPanelData, Clear, ClientError, ClientProcsObject, Create, Destroy,    FreeRSProcType, LHTypeInEvalProcType, ModifyTypeInProcType, Handle,    ReadTargetProcType, RegisterSpec, RHTypeInEvalProcType, SWType, TileLayout, Update];CPPanelImpl: PROGRAM  IMPORTS    Heap, Inline, String, Tool, ToolWindow, WindowFont,    CPKernel, CPSymbol, PanelSW  EXPORTS CPPanel =  BEGIN    z: UNCOUNTED ZONE = Heap.systemZone;  Nibble: TYPE = [0..0FH];  messages: Window.Handle = NIL;    font: WindowFont.Handle = WindowFont.defaultFont;  fontHeight: INTEGER = WindowFont.FontHeight[font];  digitWidth: INTEGER = WindowFont.CharWidth['0, font];  lineHeight: CARDINAL = fontHeight + 2;  tileHeight: CARDINAL = lineHeight;  tileRows: CARDINAL = 18;  tileColumns: CARDINAL = 3;  tileFlagLength: CARDINAL = digitWidth;  tileLVLength: CARDINAL = 12*digitWidth + 4;  tileRVLength: CARDINAL = 7*digitWidth + 4;  tileLength: CARDINAL = tileFlagLength + tileLVLength + tileRVLength;  tileBoxWidth: CARDINAL = tileColumns*tileLength + 12*digitWidth;  tilesPerRow: CARDINAL = tileBoxWidth/tileLength;  numTiles: CARDINAL = tileRows*tilesPerRow;  rowLayout: ARRAY [0..tileColumns) OF PanelSW.TileLayout ¬ [    [tileFlagLength, tileLVLength, tileRVLength],    [tileFlagLength, tileLVLength, tileRVLength],    [tileFlagLength, tileLVLength, tileRVLength + 21*digitWidth] ];  panelProcs: PanelSW.ClientProcsObject ¬ [    FreeRS, LHTypeInEval, NIL, ReadTarget, RHTypeInEval];  panel: PanelSW.Handle ¬ NIL;  RegisterSpec: TYPE = LONG POINTER TO RegisterSpecObject;  RegisterSpecObject: TYPE = CPSymbol.Symbol;  AbsToRep: PROCEDURE [rs: PanelSW.RegisterSpec] RETURNS [RegisterSpec] = INLINE    BEGIN RETURN[LOOPHOLE[rs, RegisterSpec]] END;  RepToAbs: PROCEDURE [rs: RegisterSpec] RETURNS [PanelSW.RegisterSpec] = INLINE    BEGIN RETURN[LOOPHOLE[rs, PanelSW.RegisterSpec]] END;  FreeRS: PanelSW.FreeRSProcType = BEGIN z.FREE[@rs]; END;  AllocateRegisterSpec: PROCEDURE [value: CPSymbol.Symbol]    RETURNS [PanelSW.RegisterSpec] =    BEGIN    rs: RegisterSpec;    rs ¬ z.NEW[CPSymbol.Symbol];    rs­ ¬ value;    RETURN[RepToAbs[rs]];    END;  ReadTarget: PanelSW.ReadTargetProcType =    BEGIN    myrs: RegisterSpec = AbsToRep[rs];    value: LONG CARDINAL;    s ¬ NIL;					-- formated result    IF rs = NIL THEN RETURN;    IF ~CPKernel.InKernel[] THEN RETURN;    BEGIN ENABLE CPKernel.Error => ERROR PanelSW.ClientError[unknown, reason];    WITH myrs SELECT FROM      number => ERROR;      link => value ¬ CPKernel.ReadLink[link];      realCS =>        BEGIN	MI: CPuFormat.MI ¬ CPKernel.ReadCS[real];        s ¬ z.NEW[StringBody[30]];	CPSymbol.AppendMI[s, MI];	RETURN;	END;      virtCS =>        BEGIN	real: CPDef.RealCS;	MI: CPuFormat.MI;	[real, , ] ¬ CPSymbol.VirturalToRealCS[virt];        s ¬ z.NEW[StringBody[30]];	IF real = CPSymbol.nullRealCS THEN	  BEGIN	  String.AppendString[s, "????"L];	  RETURN;	  END;	MI ¬ CPKernel.ReadCS[real];	CPSymbol.AppendMI[s, MI];	RETURN;	END;      rReg => value ¬ CPKernel.ReadRReg[r];      dReg => value ¬ CPKernel.ReadDReg[d];      aReg => value ¬ LOOPHOLE[CPKernel.ReadAReg[a]];      map => value ¬ CPKernel.ReadMap[map];      real => value ¬ CPKernel.ReadMemoryWord[real];      virt => value ¬ CPKernel.ReadVirturalMemory[virt];      other => value ¬ CPKernel.ReadOther[other];      ENDCASE => ERROR;          END;    s ¬ z.NEW[StringBody[16]];    IF Inline.HighHalf[value] # 0 THEN      BEGIN      low: CARDINAL = Inline.LowHalf[value];      String.AppendNumber[s, Inline.HighHalf[value], 16];      SELECT TRUE FROM					-- leading zeros        (low > 0FFFH) => NULL;        (low > 0FFH) => String.AppendString[s, "0"L];        (low > 0FH) => String.AppendString[s, "00"L];        ENDCASE => String.AppendString[s, "000"L];      String.AppendLongNumber[s, low, 16];      END    ELSE String.AppendLongNumber[s, value, 16];    END;  RHTypeInEval: PanelSW.RHTypeInEvalProcType =    BEGIN    myrs: RegisterSpec = AbsToRep[rs];    symbol: CPSymbol.Symbol;        display ¬ NIL;    IF rs = NIL OR typeIn = NIL OR typeIn.length = 0 THEN RETURN;    IF ~CPKernel.InKernel[] THEN RETURN;    symbol ¬ CPSymbol.Eval[typeIn !      CPSymbol.Error => ERROR PanelSW.ClientError[unknown, reason] ];    BEGIN ENABLE CPKernel.Error => ERROR PanelSW.ClientError[unknown, reason];    WITH myrs SELECT FROM      link => CPKernel.WriteLink[link, ExtractNibble[symbol]];      realCS, virtCS => ERROR PanelSW.ClientError[unknown, "Please use SourceDebug to update Control Store"L];      rReg => CPKernel.WriteRReg[r, ExtractNumber[symbol]];      dReg => CPKernel.WriteDReg[d, ExtractNumber[symbol]];      aReg => CPKernel.WriteAReg[a, ExtractLongNumber[symbol]];      map => CPKernel.WriteMap[map, ExtractNumber[symbol]];      real => CPKernel.WriteMemoryWord[real, ExtractNumber[symbol]];      virt => CPKernel.WriteVirturalMemory[virt, ExtractNumber[symbol]];      other => CPKernel.WriteOther[other, ExtractNumber[symbol]];      ENDCASE => ERROR;          END;    display ¬ ReadTarget[rs, TRUE];    END;    ExtractNibble: PROCEDURE [symbol: CPSymbol.Symbol] RETURNS [Nibble] =    BEGIN    WITH symbol SELECT FROM      number => RETURN[Inline.BITAND[Inline.LowHalf[n], 0FH]];      ENDCASE;    ERROR PanelSW.ClientError[unknown, "Unreasonable source/dest combination"L];    END;  ExtractNumber: PROCEDURE [symbol: CPSymbol.Symbol] RETURNS [WORD] =    BEGIN    WITH symbol SELECT FROM      number => RETURN[Inline.LowHalf[n]];      real => RETURN[CPKernel.ReadMemoryWord[real]];      virt => RETURN[CPKernel.ReadVirturalMemory[virt]];      ENDCASE;    ERROR PanelSW.ClientError[unknown, "Unreasonable source/dest combination"L];    END;  ExtractLongNumber: PROCEDURE [symbol: CPSymbol.Symbol] RETURNS [LONG UNSPECIFIED] =    BEGIN    WITH symbol SELECT FROM      number => RETURN[n];      ENDCASE;    ERROR PanelSW.ClientError[unknown, "Unreasonable source/dest combination"L];    END;  AppendPanelData: PUBLIC PROCEDURE [textSW: Window.Handle] = {    PanelSW.AppendPanelData[textSW, panel];    };  LHTypeInEval: PanelSW.LHTypeInEvalProcType =    BEGIN    value: CPSymbol.Symbol;    display ¬ NIL;    newRs ¬ NIL;    IF typeIn = NIL OR typeIn.length = 0 THEN RETURN;    value ¬ CPSymbol.Eval[typeIn !      CPSymbol.Error => ERROR PanelSW.ClientError[unknown, reason] ];    WITH value SELECT FROM      number => value ¬ [real[LOOPHOLE[n]]];	-- make number into real memory addr      ENDCASE => NULL;    newRs ¬ AllocateRegisterSpec[value];    IF normalize THEN      BEGIN      temp: STRING ¬ [200];      CPSymbol.AppendSymbol[temp, value];      display ¬ String.CopyToNewString[temp, z];      END    ELSE display ¬ String.CopyToNewString[typeIn, z];    END;    MakePanelSW: PUBLIC PROCEDURE [    parent: Window.Handle,    err: Window.Handle,    modifyTypeIn: PanelSW.ModifyTypeInProcType,    typeIn: LONG POINTER TO LONG STRING] RETURNS [psw: Window.Handle] =    BEGIN    increment: LONG POINTER TO CARDINAL ¬ NIL;    box: Window.Box ¬ ToolWindow.nullBox;    box.dims.h ¬ tileRows*tileHeight;    panelProcs.modifyTypeIn ¬ modifyTypeIn;    psw ¬ ToolWindow.CreateSubwindow[parent: parent, box: box];    panel ¬ PanelSW.Create[      psw, err, numTiles, DESCRIPTOR[rowLayout], @panelProcs, typeIn, increment, NIL, , ];    Tool.AddThisSW[window: parent, sw: psw, swType: PanelSW.SWType[]];    END;      Destroy: PUBLIC PROCEDURE =    BEGIN    IF panel # NIL THEN PanelSW.Destroy[panel];    panel ¬ NIL;    END;      GetPanel: PUBLIC PROCEDURE RETURNS [PanelSW.Handle] = BEGIN RETURN[panel]; END;      Clear: PUBLIC PROCEDURE = BEGIN IF panel # NIL THEN PanelSW.Clear[panel]; END;      Refresh: PUBLIC PROCEDURE = BEGIN IF panel # NIL THEN PanelSW.Update[panel] END;      Initialize: PUBLIC PROCEDURE =    BEGIN    IF panel # NIL THEN PanelSW.Clear[panel];    END;    END...-- Log of last edits-- JAC	11-Jun-85 13:42:13	PanelSW.Create has 3 more parameters
-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. --Last edit by JAC     5-Nov-84 14:13:24 DIRECTORY  Ascii USING [CR],  String USING [AppendString, AppendChar],  DsyuFormat,  DsyAssembler,  DsyFile USING [LogErrAndSrcLines, LogLine],  DsyLabel,  DsyP2Hash USING [    bad, constraintArray, curMI, errorLevel, miRtoV, miVtoR, Not];DsyAllocImpl: PROGRAM  IMPORTS String, DsyAssembler, DsyFile, DsyLabel, DsyP2Hash EXPORTS DsyLabel =  BEGIN OPEN DsyuFormat, DsyAssembler, DsyLabel;  AddConstraint: PUBLIC PROCEDURE [ccp: LONG POINTER TO ConstraintChain] =    BEGIN    AppendConstraint: PROCEDURE [      ccTail, ccHead: LONG POINTER TO ConstraintChain] =      -- append the Tail chain at the back of The Head chain (Head will be the new head) .      BEGIN      UNTIL ccHead.nextConstraint = NIL DO ccHead ¬ ccHead.nextConstraint ENDLOOP;      ccHead.nextConstraint ¬ ccTail;      END;  -- end AppendConstraint    ChangeConstraintPtrs: PROCEDURE [      ccNew, ccOld: LONG POINTER TO ConstraintChain] =      BEGIN      -- update all constraintArray entries which point to ccOld, so that they point to ccNew.      ccCur: LONG POINTER TO ConstraintChain ¬ ccOld;      UNTIL ccCur = NIL DO        DsyP2Hash.constraintArray[ccCur­.miIndex1] ¬ ccNew;        IF ccCur.modulo # maxmaxModulo THEN          DsyP2Hash.constraintArray[ccCur­.miIndex2] ¬ ccNew;        ccCur ¬ ccCur.nextConstraint;        ENDLOOP;      END;  -- end ChangeConstraintPtrs    IF ccp­.modulo = maxmaxModulo THEN      -- absolute placement, miIndex2 not useful       IF DsyP2Hash.constraintArray[ccp­.miIndex1] = NIL THEN        -- one label only. . not listed        DsyP2Hash.constraintArray[ccp­.miIndex1] ¬ ccp      ELSE        -- one label only. . listed        AppendConstraint[ccp, DsyP2Hash.constraintArray[ccp­.miIndex1]]    ELSE      -- not an absolute placement.  both Indecis useful      IF DsyP2Hash.constraintArray[ccp­.miIndex1] = NIL THEN        BEGIN        IF DsyP2Hash.constraintArray[ccp­.miIndex2] = NIL THEN          BEGIN          -- neither label listed          DsyP2Hash.constraintArray[ccp­.miIndex1] ¬ ccp;          DsyP2Hash.constraintArray[ccp­.miIndex2] ¬ ccp;          END        ELSE          BEGIN          -- label 2 only listed          DsyP2Hash.constraintArray[ccp­.miIndex1] ¬ DsyP2Hash.constraintArray[            ccp­.miIndex2];          AppendConstraint[ccp, DsyP2Hash.constraintArray[ccp­.miIndex2]];          END;        END      ELSE        BEGIN        IF DsyP2Hash.constraintArray[ccp­.miIndex2] = NIL THEN          BEGIN          -- label 1 only listed          DsyP2Hash.constraintArray[ccp­.miIndex2] ¬ DsyP2Hash.constraintArray[            ccp­.miIndex1];          AppendConstraint[ccp, DsyP2Hash.constraintArray[ccp­.miIndex1]];          END        ELSE          -- both labels listed          IF DsyP2Hash.constraintArray[ccp­.miIndex1] # DsyP2Hash.constraintArray[            ccp­.miIndex2] THEN            BEGIN            -- both labels in different chains            AppendConstraint[              DsyP2Hash.constraintArray[ccp­.miIndex2], DsyP2Hash.constraintArray[              ccp­.miIndex1]];            ChangeConstraintPtrs[              DsyP2Hash.constraintArray[ccp­.miIndex1], DsyP2Hash.constraintArray[              ccp­.miIndex2]];            AppendConstraint[ccp, DsyP2Hash.constraintArray[ccp­.miIndex1]]            END            -- both labels listed in same chain          ELSE AppendConstraint[ccp, DsyP2Hash.constraintArray[ccp­.miIndex1]];        END;    END;  -- end AddConstraint  AllocateUnconstrained: PUBLIC PROCEDURE =    BEGIN    v: CARDINAL;    r: CARDINAL ¬ 0;    FOR v IN [0..DsyP2Hash.curMI) DO      IF DsyP2Hash.miVtoR[v] = DsyP2Hash.Not THEN        BEGIN        UNTIL r >= 4096 OR DsyP2Hash.miRtoV[r] = Empty DO r ¬ r + 1 ENDLOOP;        IF r >= 4096 THEN BEGIN ErrMsg[toomany, NIL, v]; RETURN; END;        DsyP2Hash.miVtoR[v] ¬ r;        DsyP2Hash.miRtoV[r] ¬ v;        END;      ENDLOOP;    END;  -- end AllocateUnconstrained  BuildCAList: PUBLIC PROCEDURE    RETURNS [caOut: LONG POINTER TO ConstraintAttribute] =    BEGIN    ca: LONG POINTER TO ConstraintAttribute;    ccCur: LONG POINTER TO ConstraintChain;    ccOut: LONG POINTER TO ConstraintChain;    i: CARDINAL;    max: CARDINAL [0..maxmaxModulo];    caOut ¬ NIL;    FOR i IN [0..4096) DO  -- scan constraintArray for ConstraintChain's      IF DsyP2Hash.constraintArray[i] # NIL THEN        BEGIN        ccOut ¬ DsyP2Hash.constraintArray[i];        max ¬ 0;        ccCur ¬ DsyP2Hash.constraintArray[i];                UNTIL ccCur = NIL DO  -- scan ConstraintChain for Attributes          max ¬ MAX[max, ccCur.modulo];          IF DsyP2Hash.constraintArray[ccCur­.miIndex1] # NIL THEN            BEGIN            IF ccCur­.miIndex1 <= DsyP2Hash.curMI              AND DsyP2Hash.miVtoR[ccCur­.miIndex1] # DsyP2Hash.Not THEN              max ¬ maxmaxModulo;            DsyP2Hash.constraintArray[ccCur­.miIndex1] ¬ NIL;                        END;          IF ccCur.modulo # maxmaxModulo THEN            IF DsyP2Hash.constraintArray[ccCur­.miIndex2] # NIL THEN              BEGIN              IF ccCur­.miIndex2 <= DsyP2Hash.curMI                AND DsyP2Hash.miVtoR[ccCur­.miIndex2] # DsyP2Hash.Not THEN                max ¬ maxmaxModulo;              DsyP2Hash.constraintArray[ccCur­.miIndex2] ¬ NIL;              END;          ccCur ¬ ccCur.nextConstraint;          ENDLOOP;  -- end scan of ConstraintChain's for Attributes        ca ¬ GetPassSpace[SIZE[ConstraintAttribute]];        ca­ ¬ ConstraintAttribute[caOut, ccOut, max];        caOut ¬ ca;        END;      ENDLOOP;  -- end scan for ConstraintChain's    END;  -- end BuildCAList  ErrMsg: PROCEDURE [type: {uncon, toomany}, s: LONG STRING, mi1: MIIndex] =    BEGIN    Estr: LONG STRING ¬ [150];  -- string for error messages    Estr.length ¬ 0;    IF DsyP2Hash.errorLevel < DsyP2Hash.bad THEN      DsyFile.LogErrAndSrcLines["Allocation Errors:"L];    DsyP2Hash.errorLevel ¬ 200;    SELECT type FROM      uncon =>        BEGIN        String.AppendString[Estr, "Unable to allocate unconstrained "L];        String.AppendString[Estr, s];        AppendSymbolName[Estr, mi1];        String.AppendChar[Estr, Ascii.CR];        String.AppendString[Estr, "Possibly control memory full."L];        END;      toomany =>        BEGIN        String.AppendString[          Estr, "Too many m-i's plus reserves.  Control memory full."L];        END;      ENDCASE;    String.AppendChar[Estr, Ascii.CR];    DsyFile.LogLine[Estr];    END;  -- end ErrMsg  END...--Log of last edits--JAC   	 5-Nov-84 14:13:47	fixed arrows for Mesa 11.1
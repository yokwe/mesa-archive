-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved. -- Last edit by JAC   		12-Mar-85  9:50:27-- CPLoadBootImpl.mesa, AYC   , 14-Dec-84 17:32:28-- from CPLoaderBoot.mesa, HGM, 11-Oct-83 21:25:24------ Note: IORegion layout need more work (20-Nov-84 14:34:47, AYChen$)--DIRECTORY  Boot USING [bootPhysicalVolume, countGermVM, pageGerm, pRequest, Request],  BootFile USING [    currentVersion, MapEntry, Header, maxEntriesPerHeader, maxEntriesPerTrailer,    Trailer],  DeviceTypes USING [anyPilotDisk],  DoveInputOutput USING [RealPageCount, RealPageNumber],  Environment USING [bytesPerPage, PageCount, PageNumber, wordsPerPage],  Format USING [CR, Line, LongDecimal, StringProc, Text],  Heap USING [Create, Delete],  Inline USING [LowByte, LowHalf],  MStream USING [EndOf, Error, ReadOnly],  PageMap USING [],  PilotSwitches USING [hang],  Stream USING [Delete, EndOfStream, GetBlock, Handle],  String USING [AppendExtensionIfNeeded, CopyToNewString],  System USING [GetClockPulses, Pulses, PulsesToMicroseconds],  Space USING [LongPointerFromPage, PageFromLongPointer],    CPDef USING [maxMIs, RealMemory, VirturalMemory],  CPCommand USING [Error, RefreshWindow],  CPKernel USING [Error, ReadMap, WriteMemoryBlock]; CPLoadBootImpl: PROGRAM  IMPORTS    Format, Heap, Inline, MStream, Stream, String, System,    CPCommand, CPKernel, Space  EXPORTS CPCommand =  BEGIN  z: UNCOUNTED ZONE;  -- Daisy with single A-Chip (1MB) physical memory layout as of 22-Oct-84 15:53:48  -- func	hex		octal			decimal  -- vmm	[0..20000)	[0..400000)		[0..131072)  -- ioregion	[24000..?)	[440000..?)		[147456..?)  -- display	[40000..60000)	[1000000..1400000)	[262144..393216)  -- free	[60000..FFFFF]	[1400000..3777777]	[393216..1048575]  -- the germ goes into virtural [1..n).  -- The rest of free memory is mapped behind the germ.  -- After the germ loads a boot file, free memory is behind the boot file.    --these are current at 1/22 but will change and is not in DoveInputOutput  ioRegionPageCount: DoveInputOutput.RealPageCount ¬ 64;  ioRegionVirtualPage: DoveInputOutput.RealPageNumber ¬ 256 - ioRegionPageCount;  ioRegionRealPage: DoveInputOutput.RealPageNumber ¬ 288;  --120H = 440B    firstFreePage:  DoveInputOutput.RealPageNumber = 64;  -- mapPagesCount for 16K word map for simulator. real machine is 64K  mapPagesCount: PUBLIC DoveInputOutput.RealPageCount ¬ 64;  firstMapPage: PUBLIC DoveInputOutput.RealPageNumber ¬ 0;  realMapLoc: LONG POINTER = Space.LongPointerFromPage[firstMapPage];  tempCountGermVM: CARDINAL = Inline.LowHalf[Boot.countGermVM];  realPageForGerm: CARDINAL = firstFreePage+(256-tempCountGermVM);virtualPageForGerm: LONG CARDINAL = Boot.pageGerm;  virtualPageForPRequest: LONG CARDINAL = Space.PageFromLongPointer[Boot.pRequest];  realPageForPRequest: CARDINAL = realPageForGerm + Inline.LowHalf[virtualPageForPRequest - virtualPageForGerm];  displayBankPages: CARDINAL = 256;  --location is determined at boot time. this requires 186 code to be run  displayRealPage: DoveInputOutput.RealPageNumber;    MapEntry: TYPE = MACHINE DEPENDENT RECORD [    rpLow: [0..0FFH], r, d, w: BOOLEAN, rpHigh: [0..37B]];          LoadGerm: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, file: LONG STRING] =    BEGIN    filename: LONG STRING;    stream: Stream.Handle;    z ¬ Heap.Create[initial: 2];    filename ¬ String.CopyToNewString[file, z];    [] ¬ String.AppendExtensionIfNeeded[@filename, "germ"L, z];    Format.Text[log, "Loading Germ from "L, arg];    Format.Text[log, filename, arg];    Format.Line[log, "."L, arg];    stream ¬ MStream.ReadOnly[filename, [] ! MStream.Error =>      ERROR CPCommand.Error["Can't read that file"] ];    LoadGermFromStream[log, arg, stream !      UNWIND => BEGIN Stream.Delete[stream]; z.FREE[@filename]; END ];    Stream.Delete[stream];    z.FREE[@filename];    Heap.Delete[z];    CPCommand.RefreshWindow[];    END;   LoadGermFromStream: PROCEDURE [log: Format.StringProc, arg: LONG POINTER, stream: Stream.Handle] =    BEGIN ENABLE      Stream.EndOfStream => ERROR CPCommand.Error["Truncated germ file"L];    wordsPerMI: CARDINAL = 3;    buffersize: CARDINAL = CPDef.maxMIs*wordsPerMI;    buffer: ARRAY [0..Environment.wordsPerPage) OF WORD;    start, stop: System.Pulses;    ms: LONG CARDINAL;    page: Environment.PageCount ¬ Boot.pageGerm;    words, blocks: LONG CARDINAL ¬ 0;    from: CPDef.VirturalMemory ¬ LOOPHOLE[Boot.pageGerm*Environment.wordsPerPage];    WriteMem: PROCEDURE [ra: LONG POINTER, p: LONG POINTER, nwords: CARDINAL] =      BEGIN      CPKernel.WriteMemoryBlock[to: ra, count: nwords, data: p          ! CPKernel.Error => ERROR CPCommand.Error[reason] ];      blocks ¬ blocks + 1;      words ¬ words + nwords;      END;    start ¬ System.GetClockPulses[];    ResetMap[];    MapIORegion[];    DO      bytes: CARDINAL ¬ 0;      me: MapEntry;      rp: Environment.PageCount;      to: CPDef.RealMemory;      IF MStream.EndOf[stream] THEN EXIT;      [bytes, , ] ¬ Stream.GetBlock[        sH: stream,        block: [	  blockPointer: LOOPHOLE[LONG[@buffer]],	  startIndex: 0,          stopIndexPlusOne: Environment.bytesPerPage]];      IF bytes # Environment.bytesPerPage THEN ERROR CPCommand.Error["Truncated Germ File"L];      to ¬ MapGermPage[from];      rp ¬ Space.PageFromLongPointer[to];      me ¬ [rpLow: rp MOD 400B, w: FALSE, d: FALSE, r: FALSE, rpHigh: rp/400B];            -- is this the correct location for the map entry?      WriteMem[ra: realMapLoc+page, p: @me, nwords: SIZE[MapEntry]];      WriteMem[ra: to, p: @buffer, nwords: Environment.wordsPerPage];      from ¬ from + Environment.wordsPerPage;      page ¬ page + 1;      ENDLOOP;    stop ¬ System.GetClockPulses[];    ms ¬ System.PulsesToMicroseconds[[stop - start]]/1000;    Info[log, arg, ms, words, blocks];    END;	  LoadBootFile: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, file: LONG STRING, pagesOrbanks: CARDINAL] =    BEGIN    filename: LONG STRING;    stream: Stream.Handle;    pages: Environment.PageCount;    z ¬ Heap.Create[initial: 2];    filename ¬ String.CopyToNewString[file, z];    [] ¬ String.AppendExtensionIfNeeded[@filename, "boot"L, z];    Format.Text[log, "Loading CP boot file from "L, arg];    Format.Text[log, filename, arg];    Format.Line[log, "."L, arg];    stream ¬ MStream.ReadOnly[filename, [] ! MStream.Error =>      ERROR CPCommand.Error["Can't read that file"] ];    << SELECT TRUE FROM      pagesOrbanks = 0 =>        BEGIN        pages ¬ FindPages[];        Format.Text[log, "This machine has "L, arg];        Format.LongDecimal[log, pages, arg];        Format.Line[log, " pages of memory."L, arg];        END;      pagesOrbanks < 16 => pages ¬ 256 * pagesOrbanks      ENDCASE => pages ¬ pagesOrbanks;>>      -- pages in simulator.  need to get from the IOP later  //JCraig       pages ¬ 1024;    Format.Text[log, "This machine has "L, arg];    Format.LongDecimal[log, pages, arg];    Format.Line[log, " pages of memory."L, arg];          LoadBootFileFromStream[log, arg, stream, pages !      UNWIND => BEGIN Stream.Delete[stream]; z.FREE[@filename]; END ];    Stream.Delete[stream];    z.FREE[@filename];    Heap.Delete[z];    CPCommand.RefreshWindow[];    END;      LoadBootFileFromStream: PROCEDURE [log: Format.StringProc, arg: LONG POINTER, stream: Stream.Handle, pages: Environment.PageCount] =    BEGIN ENABLE Stream.EndOfStream => ERROR CPCommand.Error["Truncated germ file"L];    headerStorage: ARRAY [0..Environment.wordsPerPage) OF WORD;    header: LONG POINTER TO BootFile.Header = LOOPHOLE[LONG[@headerStorage]];    bufferStorage: ARRAY [0..Environment.wordsPerPage) OF WORD;    buffer: LONG POINTER = @bufferStorage;    IORegionPages: CARDINAL = 1;    realPage: Environment.PageCount ¬ FirstUsablePage[];    WriteMem: PROCEDURE [ra: LONG POINTER, p: LONG POINTER, nwords: CARDINAL] =      BEGIN      CPKernel.WriteMemoryBlock[to: ra, count: nwords, data: p          ! CPKernel.Error => ERROR CPCommand.Error[reason] ];      blocks ¬ blocks + 1;      words ¬ words + nwords;      END;    GetRealPage: PROCEDURE [vp: Environment.PageCount] RETURNS [rp: Environment.PageCount] =    -- needs work to watch for display bank and IORegion ///JCraig      BEGIN      IF pages = 0 THEN ERROR CPCommand.Error["Oops, ran out of pages"L];      rp ¬ realPage;      realPage ¬ realPage + 1;      SELECT realPage FROM        firstMapPage => realPage ¬ realPage + mapPagesCount;	ioRegionRealPage => realPage ¬ ioRegionRealPage + ioRegionPageCount;	realPageForGerm => realPage ¬ realPage + tempCountGermVM;	<< --to be added when we have a real IOP	IN [displayRealPage..displayRealPage+displayBankPages) => realPage ¬ displayRealPage + displayBankPages;  >>	ENDCASE => NULL;      pages ¬ pages - 1;      END;    start, stop: System.Pulses;    wordsPerMI: CARDINAL = 3;    buffersize: CARDINAL = CPDef.maxMIs*wordsPerMI;    ms: LONG CARDINAL;    words, blocks: LONG CARDINAL ¬ 0;    thisRealPage: Environment.PageCount;    lastUsedVMPage: Environment.PageCount ¬ 0;    countData, countGroup: LONG CARDINAL;    entries: LONG POINTER TO ARRAY [0..0) OF BootFile.MapEntry;    start ¬ System.GetClockPulses[];    --    -- start setting up the vitrural/real memory map     --    ResetMap[ ! CPKernel.Error => ERROR CPCommand.Error[reason] ];  -- Fill with vacant    IF pages < firstMapPage + mapPagesCount + 2 THEN      ERROR CPCommand.Error["Not enough pages for map (and such)"L];<<  to be added when we have a real IOP with a display. does the IORegion need initialized in any way?    pages ¬ pages - mapPagesCount - displayBankPages;      MapIORegion[];     pages ¬ pages - ioRegionPageCount;     -- end of IORegion initialize IORegion virtural map entries>>        -- for simulator only.  delete when we have a real IOP with a display    pages ¬ pages - mapPagesCount;    MapIORegion[];    pages ¬ pages - ioRegionPageCount;    --    -- *boot file version check    --    [] ¬ Stream.GetBlock[      sH: stream,      block: [        blockPointer: LOOPHOLE[header], startIndex: 0,        stopIndexPlusOne: Environment.bytesPerPage]];    IF header.version # BootFile.currentVersion THEN      ERROR CPCommand.Error["not (current) bootfile"L];    FOR rp: CARDINAL IN [realPageForGerm..realPageForPRequest] DO  -- initialize the germ's SD vector pages      me: MapEntry;      me ¬ MapEntry[  -- Germ's SD        rpLow: rp MOD 400B, rpHigh: rp/400B,        r: TRUE, d: TRUE, w: FALSE];      WriteMem[realMapLoc + virtualPageForGerm + (rp - realPageForGerm), @me, SIZE[MapEntry]];      ENDLOOP;    BEGIN  -- write pRequest    pRequestOffset: WORD = Inline.LowByte[Inline.LowHalf[Boot.pRequest]];    pRequest: LONG POINTER TO Boot.Request =       Space.LongPointerFromPage[realPageForPRequest] + pRequestOffset;    request: Boot.Request;    request ¬ [      action: Boot.bootPhysicalVolume,      location: [deviceType: DeviceTypes.anyPilotDisk, deviceOrdinal: 0, vp: ],      pStartListHeader: header.pStartListHeader,      inLoadMode: ,      session: ];    request.switches[PilotSwitches.hang] ¬ down;    WriteMem[ra: pRequest, p: @request, nwords: SIZE[Boot.Request]];    END;    IF (countData ¬ header.countData) > pages THEN      ERROR CPCommand.Error["Not enough pages for Boot file"L];    countGroup ¬ MIN[countData, BootFile.maxEntriesPerHeader];    entries ¬ LOOPHOLE[@header.entries];    --    -- Read/Write Germ from boot file to real meory    --    DO      trailer: LONG POINTER TO BootFile.Trailer = LOOPHOLE[header];      FOR i: LONG CARDINAL IN [0..countGroup) DO        OPEN bfe: entries[IF i > LAST[CARDINAL] THEN ERROR ELSE CARDINAL[i]];        me: MapEntry;        [] ¬ Stream.GetBlock[          sH: stream,          block: [            blockPointer: buffer,	    startIndex: 0,            stopIndexPlusOne: Environment.bytesPerPage]];        thisRealPage ¬ GetRealPage[bfe.virtual];       << Perhaps a check should be placed in here for a large "thisRealPage">>        me ¬ [          rpLow: CARDINAL[thisRealPage MOD 400B], rpHigh: CARDINAL[thisRealPage/400B],          r: bfe.flags.referenced, d: bfe.flags.dirty, w: bfe.flags.readonly];        WriteMem[ra: realMapLoc + bfe.virtual, p: @me, nwords: 1];	WriteMem[ra: Space.LongPointerFromPage[thisRealPage],	  	p: buffer, nwords: Environment.wordsPerPage];        lastUsedVMPage ¬ MAX[lastUsedVMPage, bfe.virtual];        ENDLOOP;      IF (countData ¬ countData - countGroup) = 0 THEN EXIT;      countGroup ¬ MIN[countData, BootFile.maxEntriesPerTrailer];      [] ¬ Stream.GetBlock[        sH: stream,        block: [          blockPointer: LOOPHOLE[trailer],	  startIndex: 0,          stopIndexPlusOne: Environment.bytesPerPage]];      IF header.version # BootFile.currentVersion THEN        ERROR CPCommand.Error["bad trailer version?"L];      entries ¬ LOOPHOLE[@trailer.entries];      ENDLOOP;    --    -- Put any extra memory in map following last used mapped VM    --    WHILE pages > 0 DO      me: MapEntry;      lastUsedVMPage ¬ lastUsedVMPage + 1;      thisRealPage ¬ GetRealPage[lastUsedVMPage];      << Perhaps a check should be placed in here for a large "thisRealPage">>      me ¬ [        rpLow: CARDINAL[thisRealPage MOD 400B],        r: FALSE, d: FALSE, w: FALSE, rpHigh: CARDINAL[thisRealPage/400B]];      WriteMem[ra: realMapLoc + lastUsedVMPage, p: @me, nwords: 1];      -- pages is decremented in GetRealPage[]      ENDLOOP;    stop ¬ System.GetClockPulses[];    ms ¬ System.PulsesToMicroseconds[[stop - start]]/1000;    Info[log, arg, ms, words, blocks];    END;  ResetMap: PROCEDURE =    BEGIN ENABLE UNWIND => NULL;    -- not referenced & dirty & write-protect => vacant    -- assume a 16K word map    from: Environment.PageCount ¬ firstMapPage;    vacantPage: ARRAY [0..Environment.wordsPerPage) OF MapEntry       ¬ ALL[MapEntry[rpLow: 0, r: FALSE, d: TRUE, w: TRUE, rpHigh: 0]];    vacantPagePtr: LONG POINTER ¬ @vacantPage;    FOR offset: LONG CARDINAL IN [0..mapPagesCount) DO      CPKernel.WriteMemoryBlock[realMapLoc + offset*256, Environment.wordsPerPage, vacantPagePtr ! CPKernel.Error => CPCommand.Error[reason] ];      ENDLOOP;    END;    MapGermPage: PROCEDURE [virtural: CPDef.VirturalMemory] RETURNS [real: CPDef.RealMemory] =    BEGIN    page: Environment.PageCount ¬ Space.PageFromLongPointer[virtural];    IF page ~IN [Boot.pageGerm..Boot.countGermVM) THEN      ERROR CPCommand.Error["Germ doesn't fit in allocated space"L];    BEGIN      offset: Environment.PageNumber = mapPagesCount;  -- VMM Starts at Real[0]      IF page = 0 OR page = 0FFH THEN ERROR CPCommand.Error["MapGermPage confusion"L];      page ¬ page + offset;      RETURN[Space.LongPointerFromPage[page]];      END;    END;      MapIORegion: PROCEDURE   =    BEGIN    me: MapEntry;    FOR offset: CARDINAL IN [0..ioRegionPageCount) DO  --map the IORegion      me ¬ [          rpLow: ioRegionRealPage MOD 400B + offset,          r: TRUE, d: TRUE, w: FALSE, rpHigh: ioRegionRealPage/400B];      CPKernel.WriteMemoryBlock[realMapLoc + ioRegionVirtualPage + offset,        SIZE[MapEntry], @me! CPKernel.Error => ERROR CPCommand.Error[reason]];      ENDLOOP;    END;   FindPages: PROCEDURE RETURNS [pages: Environment.PageCount] =    BEGIN  -- Binary search    low: CARDINAL ¬ 0;    high: CARDINAL ¬ 0FFFH;  -- 16K Map for now ############    WHILE high > low DO      probe: CARDINAL = (low + high ) / 2;      me: MapEntry = LOOPHOLE[CPKernel.ReadMap[probe        ! CPKernel.Error => ERROR CPCommand.Error[reason] ]];      IF Vacant[me] THEN high ¬ probe - 1      ELSE        BEGIN        low ¬ probe + 1;	pages ¬ RealPageNumber[me] + 1;	END;      ENDLOOP;    END;      FirstUsablePage: PROCEDURE RETURNS [Environment.PageCount] =    BEGIN    RETURN[firstFreePage];    END;      Vacant: PROCEDURE [me: MapEntry] RETURNS [BOOLEAN] =    BEGIN    RETURN[~me.r AND me.d AND me.w];    END;      RealPageNumber: PROCEDURE [me: MapEntry] RETURNS [CARDINAL] =    BEGIN    RETURN[me.rpHigh*400B + me.rpLow];    END;      Info: PROCEDURE [log: Format.StringProc, arg: LONG POINTER, ms, words, blocks: LONG CARDINAL] =    BEGIN    Format.Text[log, "It took "L, arg];    Format.LongDecimal[log, ms, arg];    Format.Text[log, " ms to load "L, arg];    Format.LongDecimal[log, words, arg];    Format.Text[log, " words in "L, arg];    Format.LongDecimal[log, blocks, arg];    Format.Text[log, " blocks."L, arg];    IF ms # 0 THEN      BEGIN      Format.Text[log, " ("L, arg];      Format.LongDecimal[log, words*16*1000/ms, arg];      Format.Text[log, " bits/sec)"L, arg];      END;    Format.CR[log, arg];    END;    END.  -- Log-- JAC   	18-Jan-85 17:36:56	changed LoadBoot for simulator-- JAC   	22-Jan-85 16:04:48	fixup LoadBoot -- JAC   	23-Jan-85 17:05:10	fixup LoadGerm-- JAC   	28-Jan-85 12:08:09	put number of pages in log window-- JAC   	 9-Mar-85 15:18:22	added MapIORegion in LoadBoot-- JAC   	12-Mar-85  9:50:53	change firstFreePage from 256 to 64  
-- Copyright (C) 1984, 1985 by Xerox Corporation. All rights reserved. -- HBSampleImpl.mesa-- Written by FS   on   8-Nov-84 13:35:54-- Last edited by --  RDH	 21-Jun-85 16:21:02 Add SetHighAddrBits in IOPTrigMask. --  RDH	 14-Jun-85 11:02:18 Change file names of IOPBermuda files: I186* ¬ IOPB*.  Change call to IOPBSymbol.Eval for change to IOPBSymbol interface. --  RDH	  3-May-85 10:46:20 Catch RunTime.UnboundProcedure on call to I186Symbol.Eval. --  RDH	 22-Apr-85 11:09:20 Add capability to do symbolic input on the IOP side. --  RDH	 15-Mar-85 14:16:29 Fix up state feedback.  Add checking before starting sample to avoid killing program running in the IOP. --  RDH	 14-Mar-85 12:07:41 Deal with Bad Check Sum caused by user rebooting unexpectedly.--  RDH	 13-Mar-85 11:35:30 Catch CPSymbol.Error.  Improve error messages.--  RDH	 6-Mar-85 16:50:55 Add stuff for checking on the safety of polling the history buffer.--  RDH	 3-Mar-85 15:31:48 Avoid deadlock on bindweed timeout.--  RDH	24-Feb-85 14:45:58 Change to work with new ReadHistoryBuffer bindweed command.--  RDH	 5-Feb-85 12:22:34 Add time stamping.--  RDH	 1-Feb-85 16:27:28 Add boolean item to lower formSW to distinguish symbolic name for nia and bank select, fix bugs.--  RDH	24-Jan-85 17:39:35 Take symbolic name for nia and bank select.--  RDH	21-Jan-85 17:30:09 Introduce names for IO locations.--  RDH	15-Jan-85 16:41:01 Run FixArrows.DIRECTORY  CPDef,  CPSymbol,  Environment,  HBAccess,  HBAction,  HBIO,  Heap,  I186,  IOPB,  IOPBKernel,  IOPBSymbol,   Inline,  Process,  Put,  Runtime,  String,  StrCnvrt,  Time,  Window;HBSampleImpl: PROGRAM  IMPORTS  CPSymbol, HBAccess, HBAction, HBIO, Heap, IOPB, IOPBKernel,     IOPBSymbol, Inline, Process, Put, Runtime, String, StrCnvrt, Time  EXPORTS  HBIO =  BEGIN    timeAndTrig: PUBLIC HBIO.TimeAndTrigger;      --$$$$$$$$$$$$$$$$$$$$$$$$  StrToNum  $$$$$$$$$$$$$$$$$$$$$$$$$$--  StrToNum: PROCEDURE [    s1: LONG STRING, max, base, dc: CARDINAL, tr: BOOLEAN]    RETURNS [LONG UNSPECIFIED, BOOLEAN] =  BEGIN  maxlen: ARRAY[0..9) OF ARRAY[0..2) OF CARDINAL ¬ [    [7,2], [3,1], [24,6], [10,3], [4,1], [16,4], [16,4], [4,1], [13,4]];  dontcareH: ARRAY[0..2) OF Environment.Byte ¬ [0, 17B];  dontcareB: ARRAY[0..2) OF Environment.Byte ¬ [0, 1B];  num: LONG UNSPECIFIED ¬ 0;  newNum: LONG UNSPECIFIED ¬ 0;  curSize: CARDINAL ¬ 0;  IF NOT tr THEN num ¬ 37777777777B;  IF base # 0 THEN {    FOR i:CARDINAL IN [0..s1.length) DO      IF s1.text[i] # '  THEN {        IF tr THEN {          SELECT s1.text[i] FROM            IN ['0..'9] => {newNum ¬ s1.text[i] - '0};            IN ['A..'F] => {newNum ¬ s1.text[i] - 'A + 10};            IN ['a..'f] => {newNum ¬ s1.text[i] - 'a + 10};            'X, 'x => {newNum ¬ dontcareH[dc]};            ENDCASE => RETURN[0,FALSE]}	ELSE {	  SELECT s1.text[i] FROM	    IN ['0..'9], IN ['A..'F], IN ['a..'f] => {newNum ¬ 17B};	    'X, 'x => {newNum ¬ 0B};	    ENDCASE => RETURN[0, FALSE]};	curSize ¬ curSize + 1;	IF curSize > maxlen[max][base] THEN RETURN[0, FALSE];        num ¬ Inline.DBITSHIFT[num, 4];        num ¬ Inline.DBITOR[Inline.DBITAND[num, 37777777760B], newNum]};      ENDLOOP}  ELSE {    FOR i:CARDINAL IN [0..s1.length) DO      IF s1.text[i] # '  THEN {        IF tr THEN {          SELECT s1.text[i] FROM            IN ['0..'1] => {newNum ¬ s1.text[i] - '0};	    'X, 'x => {newNum ¬ dontcareB[dc]};	    ENDCASE => RETURN[0, FALSE]}	ELSE {	  SELECT s1.text[i] FROM	    IN ['0..'1] => {newNum ¬ 1B};	    'X, 'x => {newNum ¬ 0B};	    ENDCASE => RETURN[0, FALSE]};	curSize ¬ curSize + 1;	IF curSize > maxlen[max][base] THEN RETURN[0, FALSE];        num ¬ Inline.DBITSHIFT[num, 1];        num ¬ Inline.DBITOR[Inline.DBITAND[num, 37777777776B], newNum]};    ENDLOOP};  RETURN[num, TRUE];  END;  --$$$$$$$$$$$$$$$$$$$$$$$$  AppendNum  $$$$$$$$$$$$$$$$$$$$$$$$$$--  AppendNum: PROCEDURE [n1, n2: LONG UNSPECIFIED, nshift: CARDINAL] RETURNS [LONG UNSPECIFIED] =    {RETURN[Inline.DBITOR[Inline.DBITSHIFT[n1, nshift], n2]]};  --$$$$$$$$$$$$$$$$$$$$$$$$  IOPTrigMask  $$$$$$$$$$$$$$$$$$$$$$$$$$--  IOPTrigMask: PROCEDURE [    wh: Window.Handle, address, st, arb, dt, nw, wc:LONG STRING, dc: CARDINAL,    tr: BOOLEAN, useSym: BOOLEAN]     RETURNS [LONG UNSPECIFIED, LONG UNSPECIFIED, BOOLEAN] =   BEGIN    error: {NoError, emptyField, badAddr, badStatus, badArbitor, badData,      badNWait, badWildCard, symbolLookupError, badSymAddr, pcWasNotInitialized,      symbolWasUndefined, otherError} ¬ NoError;    symbol: IOPBSymbol.Symbol;    setHighAddrBitsMask: I186.Address = 0F00000H;    result: BOOLEAN;    temp, word0, word1: LONG UNSPECIFIED;    wildhi, wildlo: LONG UNSPECIFIED;    word1 ¬ 0;    IF String.Length[address] = 0 THEN {Put.Line[wh,"Empty Address field..."L];       error ¬ emptyField};    IF String.Length[st] = 0 THEN {Put.Line[wh,"Empty Status field..."L];      error ¬ emptyField};    IF String.Length[arb] = 0 THEN {Put.Line[wh,"Empty Arbitor field..."L];      error ¬ emptyField};    IF String.Length[dt] = 0 THEN {Put.Line[wh,"Empty Data field..."L];      error ¬ emptyField};    IF String.Length[nw] = 0 THEN {Put.Line[wh,"Empty NWait field..."L];      error ¬ emptyField};    IF String.Length[wc] = 0 THEN {Put.Line[wh,"Empty WildCard field..."L];      error ¬ emptyField};          IF error = emptyField THEN BEGIN       Put.Line[wh, "Sample Aborted..."L];      RETURN [0,0,FALSE]      END;          [temp, result] ¬ StrToNum[wc, 0, HBIO.globSW.iOPWCParam, dc, tr];    wildhi ¬ Inline.DBITAND[Inline.DBITSHIFT[temp, -5], 3B];    wildlo ¬ Inline.DBITAND[temp, 37B];    IF NOT result THEN error ¬ badWildCard;    word0 ¬ wildlo;    [temp, result] ¬ StrToNum[st, 1, HBIO.globSW.iStParam, dc, tr];    IF NOT result THEN error ¬ badStatus    ELSE word0 ¬ AppendNum[word0, Inline.DBITAND[temp,7B], 3];        IF NOT useSym THEN BEGIN      [temp, result] ¬ StrToNum[address, 2, HBIO.globSW.iopAddrParam, dc, tr];      IF NOT result THEN error ¬ badAddr      ELSE word0 ¬ AppendNum[word0, Inline.DBITAND[temp,77777777B], 24];      END ELSE BEGIN      IF tr THEN BEGIN  -- if we are generating a trigger --        [symbol: symbol, newS:] ¬ IOPBSymbol.Eval[s: address, dataType: byte, 	  addressType: iop ! 	  IOPB.Error => {	    SELECT code FROM	      undefinedSymbol => {	        Put.Line[wh, "Undefined Symbol"];		error ¬ symbolWasUndefined;		};	      pcNotInitialized => {	        Put.Line[wh, "PC Not Initialized"];		error ¬ pcWasNotInitialized;		};	      ENDCASE => { 	        Put.Line[wh, "Error looking up symbol"];		error ¬ symbolLookupError;		};	    GOTO LookUpErr;};	  Runtime.UnboundProcedure => {	    Put.Line[wh, "Wrong version of IOPBermuda is loaded."L];	    Put.Line[wh, "Can't do symbolic input for IOP."L];	    error ¬ symbolLookupError;	    GOTO LookUpErr;}];	WITH symbol SELECT FROM	  register => {	    Put.Char[wh, '"];	    Put.Text[wh, address];   	    Put.Line[wh, """ is not an I186 memory address."L];	    error ¬ badSymAddr;};	  word, byte => {	    temp ¬ Inline.DBITOR[addr, setHighAddrBitsMask]; --High 4 bits on bus are 1's.	    word0 ¬ AppendNum[word0, Inline.DBITAND[temp,77777777B], 24];};	  ENDCASE;	EXITS	  LookUpErr => NULL;	END ELSE BEGIN	temp ¬ 0FFFFFFH;	word0 ¬ AppendNum[word0, Inline.DBITAND[temp,77777777B], 24];	END;      END;	        [word1, result] ¬ StrToNum[arb, 3, HBIO.globSW.arbParam, dc, tr];    IF NOT result THEN error ¬ badArbitor;    word1 ¬ AppendNum[Inline.DBITAND[word1,1777B], wildhi, 2];    [temp, result] ¬ StrToNum[nw, 4, HBIO.globSW.nWaitParam, dc, tr];    IF NOT result THEN error ¬ badNWait    ELSE word1 ¬ AppendNum[word1, Inline.DBITAND[temp,17B], 4];    [temp, result] ¬ StrToNum[dt, 5, HBIO.globSW.iOPDataParam, dc, tr];    IF NOT result THEN error ¬ badData    ELSE word1 ¬ AppendNum[word1, Inline.DBITAND[temp,177777B], 16];    SELECT error FROM      NoError => RETURN[word0, word1, TRUE];      emptyField => NULL;      badAddr => BEGIN        Put.Line[wh,"Invalid numbers found in Address field."L];	END;      badStatus => BEGIN        Put.Line[wh,"Invalid numbers found in Status field."L];	END;      badArbitor => BEGIN        Put.Line[wh,"Invalid numbers found in Arbitor field."L];	END;      badData => BEGIN        Put.Line[wh,"Invalid numbers found in Data field."L];	END;      badNWait => BEGIN        Put.Line[wh,"Invalid numbers found in NWait field."L];	END;      badWildCard => BEGIN        Put.Line[wh,"Invalid numbers found in WildCard field."L];	END;      symbolWasUndefined, symbolLookupError => BEGIN        Put.Text[wh,"Error looking up """L];	Put.Text[wh, address];	Put.Line[wh, """"];	END;      badSymAddr => BEGIN        Put.Line[wh,"Bad data in addr field."L];	END;      ENDCASE;    Put.Line[wh,"Sample Aborted..."L];    RETURN[0, 0, FALSE];  END;--IOPTrigMask--  --$$$$$$$$$$$$$$$$$$$$$$$$  CSTrigMask  $$$$$$$$$$$$$$$$$$$$$$$$$$--  CSTrigMask: PROCEDURE [    wh: Window.Handle, nia, bs, wc: LONG STRING, dc: CARDINAL, tr: BOOLEAN,    useSym: BOOLEAN] RETURNS [LONG UNSPECIFIED, BOOLEAN] =   BEGIN         symbol: CPSymbol.Symbol;    trigMaskInfo: HBIO.CSTrigMaskInfo;     error: {noError, emptyNIA, emptyBankSel, emptyWildCard, badNIA, badBankSel, badWildCard, badVirtual, symbolLookupError, notaCSLocation} ¬ noError;    result: BOOLEAN;    temp: LONG UNSPECIFIED;    IF String.Length[nia] = 0 THEN BEGIN      Put.Line[wh,"Empty NIA field..."L];       error ¬ emptyNIA;      END;    IF String.Length[bs] = 0 AND NOT useSym THEN BEGIN       Put.Line[wh,"Empty BankSel field..."L]; error ¬ emptyBankSel;      END;    IF String.Length[wc] = 0 THEN BEGIN      Put.Line[wh,"Empty WildCard field..."L];       error ¬ emptyWildCard;      END;    IF error IN [emptyNIA..emptyWildCard] THEN BEGIN       Put.Line[wh, "Sample Aborted..."L];      RETURN[0, FALSE];      END;        IF NOT useSym THEN BEGIN  -- string in nia field is a number. --          [temp, result] ¬ StrToNum[nia, 8, HBIO.globSW.cSNIAParam, dc, tr];      trigMaskInfo.nia ¬ LongToWordInCSBank[temp];      IF NOT result THEN error ¬ badNIA;            [temp, result] ¬ StrToNum[bs, 7, HBIO.globSW.bSParam, dc, tr];      trigMaskInfo.banksel ¬ LongToHWBankSelect[temp];      IF NOT result THEN error ¬ badBankSel;            END ELSE BEGIN -- string in nia field is a label plus offset. --      IF tr THEN BEGIN  -- if we are generating a trigger --        symbol ¬ CPSymbol.Eval[nia ! CPSymbol.Error => {	  Put.Line[wh, reason];	  error ¬ symbolLookupError;	  GOTO LookUpErr;}	  ];        WITH symbol SELECT FROM          virtCS =>	    BEGIN	    real: CPDef.RealCS;	    [real, , ] ¬ CPSymbol.VirturalToRealCS[virt];	    IF real # CPSymbol.nullRealCS THEN BEGIN	      [wordInBank: trigMaskInfo.nia, hwBankSelect: trigMaskInfo.banksel] 	        ¬ RealCSToHWBankAndWordInBank[real];	      END ELSE BEGIN	      Put.Line[wh,"No real address for that virtual!"L];	      Put.Line[wh, "Sample Aborted..."L];	      error ¬ badVirtual;	      RETURN[0, FALSE];	      END;	    END;	  ENDCASE => error ¬ notaCSLocation; 	EXITS	  LookUpErr => NULL;	END ELSE BEGIN  -- if we are generating a mask --	trigMaskInfo.nia ¬ 0FFFH;	trigMaskInfo.banksel ¬ 0FH;	END;      END;        [temp, result] ¬ StrToNum[wc, 6, HBIO.globSW.cSWCParam, dc, tr];    IF NOT result THEN error ¬ badWildCard;    trigMaskInfo.wildcard ¬ LongToCSWildCard[temp];        SELECT error FROM       noError => RETURN[LOOPHOLE[trigMaskInfo, LONG UNSPECIFIED], TRUE];      emptyNIA, emptyBankSel, emptyWildCard => RETURN[0, FALSE];      badNIA => BEGIN        Put.Line[wh,"Invalid numbers found in NIA field"L];	Put.Line[wh, "Sample Aborted..."L];	END;      badBankSel => BEGIN        Put.Line[wh,"Invalid numbers found in BankSel field"L];	Put.Line[wh, "Sample Aborted..."L];	END;      badWildCard => BEGIN        Put.Line[wh,"Invalid numbers found in WildCard field"L];	Put.Line[wh, "Sample Aborted..."L];	END;      notaCSLocation => BEGIN        Put.Text[wh, nia];	Put.Line[wh, " is not CS location."L];	Put.Line[wh, "Sample Aborted..."L];	END;      badVirtual => NULL;       symbolLookupError => BEGIN        Put.Line[wh, "Sample Aborted..."L];	END;      ENDCASE;      RETURN[0, FALSE];      END;--CSTrigMask--  --$$$$$$$$$$$$$$$$$$$$$$$$  SendTrigMask  $$$$$$$$$$$$$$$$$$$$$$$$$$--  SendTrigMask: PROCEDURE [trg0, trg1, msk0, msk1: LONG UNSPECIFIED, wh: Window.Handle] = {    ma3, ma2, ma1, ma0, tr3, tr2, tr1, tr0: UNSPECIFIED;    ma3 ¬ Inline.BITOR[Inline.BITAND[Inline.HighHalf[msk0],177400B],      Inline.BITSHIFT[Inline.HighHalf[msk1],-8]];    ma2 ¬ Inline.BITOR[Inline.BITSHIFT[Inline.HighHalf[msk0],8],      Inline.BITAND[Inline.HighHalf[msk1],377B]];    ma1 ¬ Inline.BITOR[Inline.BITAND[Inline.LowHalf[msk0],177400B],      Inline.BITSHIFT[Inline.LowHalf[msk1],-8]];    ma0 ¬ Inline.BITOR[Inline.BITSHIFT[Inline.LowHalf[msk0],8],      Inline.BITAND[Inline.LowHalf[msk1],377B]];    tr3 ¬ Inline.BITOR[Inline.BITAND[Inline.HighHalf[trg0],177400B],      Inline.BITSHIFT[Inline.HighHalf[trg1],-8]];    tr2 ¬ Inline.BITOR[Inline.BITSHIFT[Inline.HighHalf[trg0],8],      Inline.BITAND[Inline.HighHalf[trg1],377B]];    tr1 ¬ Inline.BITOR[Inline.BITAND[Inline.LowHalf[trg0],177400B],      Inline.BITSHIFT[Inline.LowHalf[trg1],-8]];    tr0 ¬ Inline.BITOR[Inline.BITSHIFT[Inline.LowHalf[trg0],8],      Inline.BITAND[Inline.LowHalf[trg1],377B]];    tr3 ¬ Inline.BITOR[Inline.BITNOT[tr3], Inline.BITNOT[ma3]];    tr2 ¬ Inline.BITOR[Inline.BITNOT[tr2], Inline.BITNOT[ma2]];    tr1 ¬ Inline.BITOR[Inline.BITNOT[tr1], Inline.BITNOT[ma1]];    tr0 ¬ Inline.BITOR[Inline.BITNOT[tr0], Inline.BITNOT[ma0]];        HBAction.WriteMaskRegs[maskReg0: ma0, maskReg1: ma1, maskReg2: ma2,       maskReg3: ma3 ! HBAction.HBProb => GOTO SBTimeout];    HBAction.WriteTriggerRegs[trigReg0: tr0, trigReg1: tr1, trigReg2: tr2,       trigReg3: tr3];    EXITS    SBTimeout => {HBIO.sbWorking ¬ FALSE};};        --$$$$$$$$$$$$$$$$$$$$$$$$  SampleIOP  $$$$$$$$$$$$$$$$$$$$$$$$$$--  SampleIOP: PUBLIC PROCEDURE [    wh: Window.Handle, addr, st, arb, dt, nw, wc, delay: LONG STRING,    useSym: BOOLEAN] = BEGIN        trigWord0, trigWord1, maskWord0, maskWord1: LONG UNSPECIFIED;    ok: BOOLEAN; --for checking parameters.    trigWatcher: PROCESS;  -- Process which will wait for triggering to occur and copy the history buffer into memory.    sampleOK: BOOLEAN;  -- for checking if it is ok to start a sample. i.e. that there is no sample already happening.        --Convert and check the parameters for the sample.    delayNum: CARDINAL ¬ StrCnvrt.StrToCard[numStr: delay, max: 7 !      StrCnvrt.StrCnvrtErr => BEGIN        Put.Line[wh,"Bad data in delay field."L]; 	GOTO ConvertError;	END;];    delayNum ¬ delayNum * 2; -- Delay twice as long in IOP mode since there are actually two samples in every item.    [trigWord0, trigWord1, ok] ¬       IOPTrigMask[wh, addr, st, arb, dt, nw, wc, 1, TRUE, useSym];    IF NOT ok THEN RETURN;    [maskWord0, maskWord1, ok] ¬      IOPTrigMask[wh, addr, st, arb, dt, nw, wc, 0, FALSE, useSym];    IF NOT ok THEN RETURN;        --Check that setting up the sample won't kill a program running in the IOP.    IF NOT(I186Idle[] OR RunningOpie[]) THEN BEGIN      Put.Line[wh,"Setting up sample would kill the program running in the IOP."L];      Put.Line[wh,"Either stop the IOP or set RunningOpie and try again."L];      RETURN;      END;        -- Check for permission to start a sample.    sampleOK ¬ HBAccess.AskForSampleAccess[];    IF NOT sampleOK THEN BEGIN      Put.Line[wh,"Sample is already in progress!  Use Stop! to abort."L];      RETURN;      END;        --Save the time of the sample and the parameters as they were given.    SaveTimeAndTrigIOP[wh: wh, addr: addr, status: st, arbiter: arb, data: dt,       nWait: nw, wildCards: wc, delay: delay,       timeEtc: @HBIO.timeAndTrig, z: Heap.systemZone];          --Set up the history buffer and start the sampling.    SendTrigMask[trigWord0, trigWord1, maskWord0, maskWord1, wh];    HBAction.StartSample[delay: delayNum, target: iop ! HBAction.HBProb =>       GOTO SBTimeout];    HBIO.NotifyUserOfStateChange[readSample];    PostMessage["Sample begun"L];        --Release part of the control of the history buffer to allow manual trigger or manual stop.    HBAccess.ReleaseHB[];        --Fork a process to watch for the end of the sample and copy the data.    --Get rid of the hour glass before the sample is complete.    trigWatcher ¬ FORK CheckerReader[wh];    Process.Detach[trigWatcher];            EXITS    SBTimeout => {      HBAccess.ReleaseHB[];--Clear the way for TriggerDetected.      HBAccess.TriggerDetected[];--Release sampling control.      HBAccess.ReleaseHB[]; --Release all control.      HBIO.sbWorking ¬ FALSE};    ConvertError => NULL;    END; --SampleIOP----$$$$$$$$$$$$$$$$$$$$$$$$  SampleCS  $$$$$$$$$$$$$$$$$$$$$$$$$$--  SampleCS: PUBLIC PROCEDURE [    wh: Window.Handle, nia, bs, wc, delay: LONG STRING,     useSym: BOOLEAN] = BEGIN        trigWord, maskWord: LONG UNSPECIFIED;    ok: BOOLEAN;--for checking parameters.    trigWatcher: PROCESS;  -- Process which will wait for triggering to occur and copy the history buffer into memory.    sampleOK: BOOLEAN;  -- for checking if it is ok to start a sample. i.e. that there is no sample already happening.        --Convert and check the parameters for the sample.    delayNum: CARDINAL ¬ StrCnvrt.StrToCard[numStr: delay, max: 15!      StrCnvrt.StrCnvrtErr => BEGIN      Put.Line[wh,"Bad data in delay field."L];       GOTO ConvertError;      END;];    [trigWord, ok] ¬ CSTrigMask[wh, nia, bs, wc, 1, TRUE, useSym];    IF NOT ok THEN RETURN;    [maskWord, ok] ¬ CSTrigMask[wh, nia, bs, wc, 0, FALSE, useSym];    IF NOT ok THEN RETURN;        --Check that setting up the sample won't kill a program running in the IOP.    IF NOT(I186Idle[] OR RunningOpie[]) THEN BEGIN      Put.Line[wh,"Setting up sample would kill the program running in the IOP."L];      Put.Line[wh,"Either stop the IOP or set RunningOpie and try again."L];      RETURN;      END;        -- Check for permission to start a sample.    sampleOK ¬ HBAccess.AskForSampleAccess[];    IF NOT sampleOK THEN BEGIN      Put.Line[wh,"Sample is already in progress!  Use Stop! to abort."L];      RETURN;      END;        --Save the time of the sample and the parameters as they were given.    SaveTimeAndTrigCS[wh: wh, nia: nia, bankSel: bs, wildCards: wc,       delay: delay, timeEtc: @HBIO.timeAndTrig,       z: Heap.systemZone, useSymb: useSym];        --Set up the history buffer and start the sampling.    SendTrigMask[0, trigWord, 0, maskWord, wh];    HBAction.StartSample[delay: delayNum, target: cs ! HBAction.HBProb =>      GOTO SBTimeout];    HBIO.NotifyUserOfStateChange[readSample];    PostMessage["Sample begun"L];    --Release part of the control of the history buffer to allow manual trigger or manual stop.    HBAccess.ReleaseHB[];        --Fork a process to watch for the end of the sample and copy the data.    --Get rid of the hour glass before the sample is complete.    trigWatcher ¬ FORK CheckerReader[wh];    Process.Detach[trigWatcher];        EXITS    SBTimeout => {      HBAccess.ReleaseHB[];--Clear the way for TriggerDetected.      HBAccess.TriggerDetected[];--Release sampling control.      HBAccess.ReleaseHB[]; --Release all control.      HBIO.sbWorking ¬ FALSE};    ConvertError => NULL;    END;--SampleCS--   --$$$$$$$$$$$$$$$$$$$$$$$$$$  CheckerReader  $$$$$$$$$$$$$$$$$$$$$--  --Wait until the history buffer triggers and times out.  Then copy the contents of the buffer into memory.  This procedure is called in a FORK and hence must catch all of the signals that could be generated by it and its progeny.  Furthermore it runs with sampling set in HBAccess.  Thus if it fails to complete somehow deadlock will result.    CheckerReader: PROC[errOut: Window.Handle] = BEGIN      hbStatusReg: HBAction.HBStatus;    lastTest, okToPoll: BOOLEAN;    lastTest ¬ I186Idle[] OR RunningOpie[];    PollingChange[lastTest];    DO      okToPoll ¬ I186Idle[] OR RunningOpie[];      IF okToPoll # lastTest THEN BEGIN        PollingChange[okToPoll];	lastTest ¬ okToPoll;	END;      IF okToPoll THEN BEGIN	hbStatusReg ¬ HBAction.ReadStatus[! HBAction.HBProb => {	  --If there is an error in CheckerReader we must try to put the pieces back together to allow a second attempt.	  Put.Line[errOut, "Timeout polling history buffer."L]; LOOP;} ];	HBIO.NotifyUserOfStateChange[hbStatusReg.state];--Keep the display updated.	SELECT hbStatusReg.state FROM	  idle =>  EXIT;--Done waiting.  HB has triggered and timed out.	  ENDCASE => WaitASec[];--Wait before checking again.	END ELSE BEGIN	WaitASec[];--Wait a second before checking if its become ok to poll.	END;      ENDLOOP;      CopyBuffer[HBIO.displayBuffer];    END;--CheckerReader--      --$$$$$$$$$$$$$$$$$$$$$    CopyBuffer    $$$$$$$$$$$$$$$$$$$--  --Called when a trigger has been detected.  Release sample control of HB.  Copy the entire buffer from the hardware buffer to the display buffer.  Set flags for display.  Release all control of History Buffer.    CopyBuffer: PUBLIC PROC[dest: LONG POINTER TO HBAction.SWBuffer] = BEGIN      --History buffer has triggered and its delay has timed out.    --Get full access to history buffer locking out everything but status reading.    HBAccess.TriggerDetected[];    PostMessage["Triggered and timed out."L];--Save looking at LED's.    --Copy the contents of the buffer into memory.    HBAction.ReadWholeBuffer[dest ! HBAction.HBProb => BEGIN      SELECT probType FROM        bindweedTimeout => {	  HBIO.ErrMessage["Error reading history buffer."L];	  HBIO.ErrMessage["Display buffer contents are questionable."L];	  HBIO.somethingInSWBuffer ¬ TRUE;	  HBAccess.ReleaseHB[];	  CONTINUE;};        bindweedBadCheckSum => {	  HBIO.ErrMessage["Bad Checksum while reading history buffer."L];	  HBIO.ErrMessage["Try running HBSetUp.bermuda in IOPBermuda."L];	  HBIO.triggeredBut ¬ TRUE;--Flag for display to notice later.--	  HBIO.somethingInSWBuffer ¬ TRUE;	  HBAccess.ReleaseHB[];	  CONTINUE;};	ENDCASE => REJECT;      END;--catch phrase--];    HBIO.somethingInSWBuffer ¬ TRUE;    HBAccess.ReleaseHB[];    END;--CopyBuffer--              --$$$$$$$$$$$$$$$$$$$$$    WaitASec    $$$$$$$$$$$$$$$$$$$--  --Do nothing for a little bit.  WaitASec: PROC = BEGIN    Process.Pause[Process.MsecToTicks[1000]];    END;--WaitASec--              --$$$$$$$$$$$$$$$$$$$$$    I186Idle    $$$$$$$$$$$$$$$$$$$--  --Check and see if IopBermuda thinks the 80186 is idle.  I186Idle: PUBLIC PROC RETURNS [idle: BOOLEAN ¬ TRUE] = BEGIN    SELECT IOPBKernel.GetState[] FROM      dead, booted, halted => RETURN[TRUE];      running, iopBreak, singleStep => RETURN[FALSE];      ENDCASE;    END;--I186Idle--          --$$$$$$$$$$$$$$$$$$$$$    RunningOpie    $$$$$$$$$$$$$$$$$$$--  --Check and see if the user claims that it is ok to poll even if the 186 is running.  RunningOpie: PUBLIC PROC RETURNS [BOOLEAN] = BEGIN    RETURN[HBIO.runningOpie];    END;--RunningOpie--          --$$$$$$$$$$$$$$$$$$$$$    PollingChange    $$$$$$$$$$$$$$$$$$$--  --Print a message telling about a change to the polling state.  PollingChange: PROC[newOkToPoll: BOOLEAN] = BEGIN    SELECT newOkToPoll FROM      TRUE => PostMessage["Polling history buffer"L];      FALSE => PostMessage["Not polling history buffer"L];      ENDCASE;    END;--PollingChange--          --$$$$$$$$$$$$$$$$$$$  SaveTimeAndTrigIOP  $$$$$$$$$$$$$$$$$$$$$$$$$--  -- Save the strings specifying the trigger, time, and delay for an iop sample into a global variable for being written with any displays that are made from this sample.  Use the given UNCOUNTED ZONE to free any strings already in the record and to allocate space for the new strings.    SaveTimeAndTrigIOP: PROC[wh: Window.Handle, addr, status, arbiter, data, nWait,    wildCards, delay: LONG STRING, timeEtc: LONG POINTER TO HBIO.TimeAndTrigger,     z: UNCOUNTED ZONE ¬ Heap.systemZone] = BEGIN    FreeTimeStamp[z: z, timeStamp: timeEtc];    SaveTimeAndDelay[delay, timeEtc, z];    timeEtc­ ¬ [time: timeEtc.time, delay: timeEtc.delay,       targetSpecificData: iop[addr: String.CopyToNewString[addr, z],       data: String.CopyToNewString[data, z],      arbiter: String.CopyToNewString[arbiter, z],      i186state: String.CopyToNewString[status, z],      wildCards: String.CopyToNewString[wildCards, z],      nWaits: String.CopyToNewString[nWait, z]]];    END;--SaveTimeAndTrigIOP--       --$$$$$$$$$$$$$$$$$$$$$$$$  SaveTimeAndTrigCS  $$$$$$$$$$$$$$$$$$$$--  -- Save the strings specifying the trigger, time, and delay for a cs sample into a global variable for being written with any displays that are made from this sample.  Use the given UNCOUNTED ZONE to free any strings already in the record and to allocate space for the new strings.    SaveTimeAndTrigCS: PROC[wh: Window.Handle, nia, bankSel, wildCards,     delay: LONG STRING, useSymb: BOOLEAN,     timeEtc: LONG POINTER TO HBIO.TimeAndTrigger,     z: UNCOUNTED ZONE ¬ Heap.systemZone] = BEGIN    FreeTimeStamp[z: z, timeStamp: timeEtc];    SaveTimeAndDelay[delay, timeEtc, z];    SELECT useSymb FROM      FALSE => timeEtc­ ¬ [time: timeEtc.time, delay: timeEtc.delay,         targetSpecificData: cs[csStuff: FALSE[nia: String.CopyToNewString[nia, z],        bankSel: String.CopyToNewString[bankSel, z],        wildCards: String.CopyToNewString[wildCards, z]]]];      TRUE => timeEtc­ ¬ [time: timeEtc.time, delay: timeEtc.delay,        targetSpecificData: cs[csStuff: TRUE[nia: String.CopyToNewString[nia, z],	wildCards: String.CopyToNewString[wildCards, z]]]];      ENDCASE;    END;--SaveTimeAndTrigCS--         --$$$$$$$$$$$$$$$$$$$$$$$  FreeTimeStamp  $$$$$$$$$$$$$$$$$$$$$$$$$$--  FreeTimeStamp: PUBLIC PROC[z: UNCOUNTED ZONE,     timeStamp: LONG POINTER TO HBIO.TimeAndTrigger] = BEGIN        WITH time: timeStamp SELECT FROM      cs => BEGIN        WITH time SELECT FROM	  TRUE => BEGIN            String.FreeString[z, nia];            String.FreeString[z, wildCards];	    END;	  FALSE => BEGIN            String.FreeString[z, nia];            String.FreeString[z, bankSel];            String.FreeString[z, wildCards];	    END;	  ENDCASE;	END;      iop => BEGIN        String.FreeString[z, time.addr];        String.FreeString[z, time.data];        String.FreeString[z, time.arbiter];        String.FreeString[z, time.i186state];        String.FreeString[z, time.wildCards];        String.FreeString[z, time.nWaits];	END;      ENDCASE;    String.FreeString[z, timeStamp.time];    String.FreeString[z, timeStamp.delay];    END;--FreeTimeStamp--               --$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$--  SaveTimeAndDelay: PROC[delay: LONG STRING, timeEtc: LONG POINTER TO     HBIO.TimeAndTrigger, z: UNCOUNTED ZONE ¬ Heap.systemZone] = BEGIN    MaxTimeLen: CARDINAL = 40;     timeEtc.time ¬ String.MakeString[z, MaxTimeLen];    Time.Append[s: timeEtc.time, unpacked: Time.Unpack[ , ], zone: TRUE,      zoneStandard: ];    timeEtc.delay ¬ String.CopyToNewString[delay, z];    END;--SaveTimeAndDelay--           --$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$--  LongToWordInCSBank: PROC[longWord: LONG UNSPECIFIED] RETURNS [HBIO.WordInCSBank]    = BEGIN        LongCSBank: TYPE = MACHINE DEPENDENT RECORD[      varRec(0: 0..31): SELECT OVERLAID * FROM      csAddr => [	fill(0: 0..3): [0..0FH],         bankAddr(0: 4..15): HBIO.WordInCSBank,        garb(1: 0..15): [0..0FFFFH]],      long => [long(0: 0..31): LONG UNSPECIFIED],      ENDCASE];          longCSBank: LongCSBank;    longCSBank.long ¬ longWord;    RETURN[longCSBank.bankAddr];     END;  --$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$--  LongToHWBankSelect: PROC[longWord: LONG UNSPECIFIED] RETURNS [HBIO.HWBankSelect]    = BEGIN    LongHWBankSelect: TYPE = MACHINE DEPENDENT RECORD[      varRec(0: 0..31): SELECT OVERLAID * FROM      csBank => [        fill(0: 0..11): [0..0FFFH],        csBank(0: 12..15): HBIO.HWBankSelect,        garb(1: 0..15): [0..0FFFFH]],      long => [long(0: 0..31): LONG UNSPECIFIED],      ENDCASE];          longHWBankSelect: LongHWBankSelect;    longHWBankSelect.long ¬ longWord;    RETURN[longHWBankSelect.csBank];     END;  --$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$--  LongToCSWildCard: PROC[longWord: LONG UNSPECIFIED] RETURNS [HBIO.CSWildCard]    = BEGIN    RETURN[Inline.LowHalf[longWord]];     END;  --$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$--  RealCSToHWBankAndWordInBank: PROC[realCS: CPDef.RealCS] RETURNS    [hwBankSelect: HBIO.HWBankSelect, wordInBank: HBIO.WordInCSBank] = BEGIN    temp: CPDef.BankAndWordsPerBank ¬ LOOPHOLE[realCS, CPDef.BankAndWordsPerBank];    SELECT temp.bank FROM      0 => hwBankSelect ¬ 0EH;      1 => hwBankSelect ¬ 0DH;      2 => hwBankSelect ¬ 0BH;      3 => hwBankSelect ¬ 7;      ENDCASE => SIGNAL HBIO.HBErr[RealCSToHWBankAndWordInBankErrNo];    wordInBank ¬ temp.wordInBank;    END;          --$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$--  PostMessage: PROC[message: LONG STRING] = {HBIO.ErrMessage[message];};                --$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$--  HBErr: PUBLIC SIGNAL[errNo: HBIO.HBErrNumber] = CODE;            END.
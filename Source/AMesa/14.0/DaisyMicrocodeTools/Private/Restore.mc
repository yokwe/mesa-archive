{ -- Copyright (C) 1984 by Xerox Corporation.  All rights reserved. -- Last edit by  -- JAC		 8-Apr-86 17:57:29	to work around SChip bug, put a 0 in memory location mailbox+4 when no longer in kernel -- JAC      	   9-Mar-85 17:13:29 -- Restore.mc,           AYC   , 14-Nov-84 19:44:53 -- from SiriusKernel.mc, FXB   , 24-Apr-84 16:03:25 -- To continue executing from a breakpoint or a halt where the state of Sirius is disturbed do the following: 1. retreive first and second level dispatch bits from aMailbox 2. restore MDu and MDv 3. restore aMailBox 4. put first level dispatch bits on the Bbus 5. put second level dispatch bits on the Bbus and dispatch on low bits of Bbus 6. execute broken instruction with BDisp in branch field IOP puts first level dispatch flags in mailBox[3:0] and second level dispatch in mailbox[7:4], then overlays and has Sirius execute the following instructions}Reserve[0,0FDF];Restore:	MAR ¬ [aMailBox + 3], Read,	c1, at[0FE0];	Noop, CANCELBR[$,1], 		c2, at[0FE1];	dKernel ¬ MDu,			c3;		MAR ¬ [aMailBox + 4], Write, c1;	MDR ¬ 0, CANCELBR[$,1], LOOPHOLE[wok], c2;	Noop, c3;		{restore U and V registers}        MAR ¬ [aMailBox + 1], DoubleRead, c1;	Noop, CANCELBR[$,1],		  c2;		{ restore aMailBox}	aMailBox.high ¬ raSaveHi,	  c3;	aMailBox.low ¬ raSaveLow,	  c4;	Wait:	Noop, GOTO[Wait];{ -- IOP overlays the following code to restore the old machine statekContinue:		{shift right 4 places, Bbus[3:0] ¬ first level dispatch flags}	rdKernelSave ¬ EXTRACT[0, rdKernelSave, 4],	at[0FDD];			{Bbus[3:0] ¬ second level dispatch flags}	Bbus ¬ rdKernelSave, BDisp,			at[0FDE];	 		{stuff broken instruction here}Loop:	DISP4[Loop,0F], GOTO[Loop],			at[0FDF];	 -- Now start Sirius with NIA = kContinue and NIAp2Hold = kContinue + 1}
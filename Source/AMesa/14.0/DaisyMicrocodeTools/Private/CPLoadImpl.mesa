-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved. -- Last edit by:-- JAC/JWF	29-Aug-86 17:34:51-- CPLoadImpl.mesa, AYC   , 20-Nov-84 10:55:07-- from CPLoader.mesa, HGM, 23-Oct-83 18:33:47--DIRECTORY  Environment USING [bytesPerWord, LongNumber, wordsPerPage],  Format USING [CR, Line, LongDecimal, StringProc, Text],  Heap USING [systemZone],  MStream USING [Error, ReadOnly],  Stream USING [Delete, EndOfStream, GetBlock, GetWord, Handle],  String USING [AppendExtensionIfNeeded, CopyToNewString],  System USING [GetClockPulses, Pulses, PulsesToMicroseconds],  CPDef USING [Bank, RealCS, sizeOfCS, maxMIs, wordsPerBank, ROffset, StartAddr, StartAddrPlusOne],  CPuFormat USING [MI, mi],  CPCommand USING [Error, RefreshWindow],  CPKernel USING [    Error, LoadBankType, OneMI, optionsData, WriteMemoryBlock, SetShiftReg],  CPKernelOps USING [WriteCSBlockInternal, SetShiftRegInternal, SetStopShiftReg],  CPSymbol USING [    AddCSSymbol, AddARegSymbol, AddDRegSymbol, AddRRegSymbol, AddToMap, Error, VirturalCS],  DsyuFormat USING [FinalBinaryRec, LabelSymbolRec];CPLoadImpl: PROGRAM  IMPORTS    Format, Heap, MStream, Stream, String, System,    CPCommand, CPKernel, CPKernelOps, CPSymbol  EXPORTS CPCommand, CPKernelOps =  BEGIN    z: UNCOUNTED ZONE = Heap.systemZone;    Load: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, file: LONG STRING, bank: CARDINAL] =    BEGIN    filename: LONG STRING;    stream: Stream.Handle;    filename ¬ String.CopyToNewString[file, z];    [] ¬ String.AppendExtensionIfNeeded[@filename, "fb"L, z];    Format.Text[log, "Loading CP from "L, arg];    Format.Text[log, filename, arg];    Format.Line[log, "."L, arg];    stream ¬ MStream.ReadOnly[filename, [] ! MStream.Error =>      ERROR CPCommand.Error["Can't read that file"] ];    LoadFromStream[log, arg, stream, bank !      UNWIND => BEGIN Stream.Delete[stream]; z.FREE[@filename]; END ];    Stream.Delete[stream];    z.FREE[@filename];    CPCommand.RefreshWindow[];    END;  LoadFromStream: PROCEDURE [log: Format.StringProc, arg: LONG POINTER, stream: Stream.Handle, bank: CPKernel.LoadBankType] =    BEGIN ENABLE      BEGIN      Stream.EndOfStream => ERROR CPCommand.Error["Truncated fb file"L];      CPKernel.Error => ERROR CPCommand.Error[reason];      END;    start, stop: System.Pulses;    ms: LONG CARDINAL;    instructions: CARDINAL ¬ 0;    fbrBytes: CARDINAL = Environment.bytesPerWord*SIZE[DsyuFormat.FinalBinaryRec];    fbr: DsyuFormat.FinalBinaryRec ¬ TRASH;    fbrptr: POINTER = @fbr;    pb: POINTER TO CPuFormat.mi = LOOPHOLE[@fbr.partialBinary];    last: CARDINAL ¬ 0;    miInClump: CARDINAL ¬ 0;    clump: ARRAY [0..CPDef.maxMIs) OF CPKernel.OneMI;    offset: CARDINAL = bank * CPDef.wordsPerBank;  -- ***  Hack until Mass is smarter    start ¬ System.GetClockPulses[];    DO      bytes: CARDINAL;      [bytes, , ] ¬ Stream.GetBlock[          sH: stream,          block: [            blockPointer: fbrptr,	    startIndex: 0,            stopIndexPlusOne: fbrBytes]];      IF bytes # fbrBytes THEN ERROR CPCommand.Error["Truncated fb"];      IF fbr.addr >= CPDef.sizeOfCS THEN EXIT;      fbr.addr ¬ fbr.addr + offset;      IF fbr.miNum = CPDef.StartAddr OR fbr.miNum = CPDef.StartAddrPlusOne THEN        BEGIN        CPKernel.SetShiftReg[fbr.miNum, fbr.addr];	CPKernelOps.SetStopShiftReg[fbr.miNum, fbr.addr];        END      ELSE        BEGIN	IF instructions # 0 THEN	  BEGIN	  IF last + 1 # fbr.addr OR miInClump = CPDef.maxMIs THEN	    BEGIN            CPKernelOps.WriteCSBlockInternal[miInClump, @clump[0]];	    miInClump ¬ 0;	    END;	  END;	clump[miInClump] ¬ [fbr.addr, pb­];	last ¬ fbr.addr;	miInClump ¬ miInClump + 1;	instructions ¬ instructions + 1;        IF TRUE THEN	  BEGIN	  fbr.miNum ¬ fbr.miNum + offset;	  CPSymbol.AddToMap[	  	fbr.addr, fbr.miNum, fbr.partialBinary.ibdisp, fbr.partialBinary.mdr];	  END;        END      ENDLOOP;    IF miInClump # 0 THEN CPKernelOps.WriteCSBlockInternal[miInClump, @clump[0]];    stop ¬ System.GetClockPulses[];    ms ¬ System.PulsesToMicroseconds[[stop - start]]/1000;    Info[log, arg, ms, instructions];    END;<< ###########################################################################   This procedure was added for multi-bank control store support. The bank   parameter that is passed to it is not used. It is retained for compatability   only. Each time the kernel or an overlay is loaded it is loaded into all   available banks of control store. The procedure "LoadFromMemoryInternal"   was the original "LoadFromMemory".   ########################################################################### >>     LoadFromMemory: PUBLIC PROCEDURE [fbFile: LONG POINTER, bank: CPDef.Bank] =     BEGIN     FOR bankCounter: CPDef.Bank IN [0..CPKernel.optionsData.banksofMicrocode - 1]        DO	LoadFromMemoryInternal[fbFile, bankCounter];	ENDLOOP;     END;  LoadFromMemoryInternal: PROCEDURE [fbFile: LONG POINTER, bank: CPDef.Bank] =    BEGIN    fbr: LONG POINTER TO DsyuFormat.FinalBinaryRec ¬ fbFile;    miInClump: CARDINAL ¬ 0;    clump: ARRAY [0..CPDef.maxMIs) OF CPKernel.OneMI;    offset: CARDINAL = bank * CPDef.wordsPerBank;  -- ***  Hack until Mass is smarter    last: CARDINAL ¬ fbr.addr + offset - 1;    DO      IF fbr.addr >= CPDef.sizeOfCS THEN EXIT;      -- (pointing to memory: WriteProtected) fbr.addr ¬ fbr.addr + offset;      IF fbr.miNum =  CPDef.StartAddr OR fbr.miNum = CPDef.StartAddrPlusOne THEN        BEGIN        CPKernelOps.SetShiftRegInternal[fbr.miNum, fbr.addr + offset];        END      ELSE        BEGIN        pb: LONG POINTER TO CPuFormat.mi = LOOPHOLE[@fbr.partialBinary];	IF last + 1 # fbr.addr + offset OR miInClump = CPDef.maxMIs THEN	  BEGIN          CPKernelOps.WriteCSBlockInternal[miInClump, @clump[0]];	  miInClump ¬ 0;	  END;	last ¬ fbr.addr + offset;	clump[miInClump] ¬ [fbr.addr + offset, pb­];	miInClump ¬ miInClump + 1;        END;      fbr ¬ fbr + SIZE[DsyuFormat.FinalBinaryRec];      ENDLOOP;    IF miInClump # 0 THEN CPKernelOps.WriteCSBlockInternal[miInClump, @clump[0]];    END;<< ###########################################################################   This procedure was added for multi-bank control store support. Each time   an overlay is loaded it is loaded into all available banks of control store.    The procedure "LoadOverlayInternal" was the original "LoadOverlay".   ########################################################################### >>     LoadOverlay: PUBLIC PROCEDURE [fbFile: LONG POINTER] =     BEGIN     FOR bankCounter: CPDef.Bank IN [0..CPKernel.optionsData.banksofMicrocode - 1]        DO	LoadOverlayInternal[fbFile, bankCounter];	ENDLOOP;     END;    LoadOverlayInternal: PROCEDURE [fbFile: LONG POINTER, bank: CPDef.Bank] =    BEGIN ENABLE      BEGIN      CPKernel.Error => ERROR CPCommand.Error[reason];      END;    fbr: LONG POINTER TO DsyuFormat.FinalBinaryRec ¬ fbFile;    miInClump: CARDINAL ¬ 0;    clump: ARRAY [0..CPDef.maxMIs) OF CPKernel.OneMI;    offset: CARDINAL = bank * CPDef.wordsPerBank;  -- ***  Hack until Mass is smarter    last: CARDINAL ¬ fbr.addr + offset - 1;    DO      IF fbr.addr >= CPDef.sizeOfCS THEN EXIT;      IF fbr.miNum = CPDef.StartAddr OR fbr.miNum = CPDef.StartAddrPlusOne THEN        ERROR CPKernel.Error["Can't set Starting Address in Overlay"L]      ELSE        BEGIN        pb: LONG POINTER TO CPuFormat.mi = LOOPHOLE[@fbr.partialBinary];	IF miInClump = CPDef.maxMIs THEN CPKernel.Error["Overlay too big"L];	IF last + 1 # fbr.addr + offset THEN	  BEGIN	  CPKernelOps.WriteCSBlockInternal[miInClump, @clump[0]];	  miInClump ¬ 0;	  END;	last ¬ fbr.addr + offset;      	clump[miInClump] ¬ [fbr.addr + offset, pb­];	miInClump ¬ miInClump + 1;        END;      fbr ¬ fbr + SIZE[DsyuFormat.FinalBinaryRec];      ENDLOOP;    IF miInClump # 0 THEN CPKernelOps.WriteCSBlockInternal[miInClump, @clump[0]];    END;      Info: PROCEDURE [log: Format.StringProc, arg: LONG POINTER, ms, instructions: LONG CARDINAL] =    BEGIN    Format.Text[log, "It took "L, arg];    Format.LongDecimal[log, ms, arg];    Format.Text[log, " ms to load "L, arg];    Format.LongDecimal[log, instructions, arg];    Format.Text[log, " instructions."L, arg];    IF ms # 0 THEN      BEGIN      Format.Text[log, " ("L, arg];      Format.LongDecimal[log, instructions*16*SIZE[CPuFormat.MI]*1000/ms, arg];      Format.Text[log, " bits/sec)"L, arg];      END;    Format.CR[log, arg];    END;   LoadSymbols: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, file: LONG STRING, bank: CARDINAL] =    BEGIN    filename: LONG STRING;    stream: Stream.Handle;    filename ¬ String.CopyToNewString[file, z];    [] ¬ String.AppendExtensionIfNeeded[@filename, "st"L, z];    Format.Text[log, "Loading CP symbols from "L, arg];    Format.Text[log, filename, arg];    Format.Line[log, "."L, arg];    stream ¬ MStream.ReadOnly[filename, [] ! MStream.Error =>      ERROR CPCommand.Error["Can't read that file"] ];    LoadSymbolsFromStream[log, arg, stream, bank !      UNWIND => BEGIN Stream.Delete[stream]; z.FREE[@filename]; END ];    Stream.Delete[stream];    z.FREE[@filename];    END;      LoadSymbolsFromStream: PROCEDURE [log: Format.StringProc, arg: LONG POINTER, stream: Stream.Handle, bank: CPKernel.LoadBankType] =    BEGIN    start, stop: System.Pulses;    ms: LONG CARDINAL;    tags, rReg, dReg, aReg: CARDINAL ¬ 0;    lsr: DsyuFormat.LabelSymbolRec ¬ TRASH;    bytesPerRec: CARDINAL = Environment.bytesPerWord*SIZE[DsyuFormat.LabelSymbolRec];    sym: LONG STRING = [100];    offset: CARDINAL = bank * CPDef.wordsPerBank;  -- ***  Hack until Mass is smarter    start ¬ System.GetClockPulses[];    DO      bytes, wordsExpected: CARDINAL;      [bytes, , ] ¬ Stream.GetBlock[        sH: stream,        block: [          blockPointer: LOOPHOLE[LONG[@lsr]],	  startIndex: 0,          stopIndexPlusOne: bytesPerRec]];      IF bytes = 0 THEN EXIT;      IF bytes # bytesPerRec THEN ERROR CPCommand.Error["Symbol file truncated"L];      IF lsr.length = 0 THEN ERROR CPCommand.Error["Zero length tag"L];      IF lsr.length > sym.maxlength THEN ERROR CPCommand.Error["Huge label string"L];      wordsExpected ¬ (lsr.length + (Environment.bytesPerWord - 1))/Environment.bytesPerWord;      [bytes, , ] ¬  Stream.GetBlock[        sH: stream,        block: [          blockPointer: LOOPHOLE[@sym.text],	  startIndex: 0,          stopIndexPlusOne: Environment.bytesPerWord*wordsExpected]];      sym.length ¬ lsr.length;      BEGIN ENABLE CPSymbol.Error =>        BEGIN	Format.Text[log, "Troubles adding "L, arg];	Format.Text[log, sym, arg];	Format.Text[log, " to symbol table: "L, arg];	Format.Text[log, reason, arg];	Format.CR[log, arg];	CONTINUE;	END;      WITH lsr SELECT FROM        label =>	  BEGIN	  virt: CPSymbol.VirturalCS;	  IF miIndex >= CPDef.wordsPerBank THEN ERROR;	  virt ¬ miIndex + offset;	  CPSymbol.AddCSSymbol[sym, virt];	  tags ¬ tags + 1;	  END;        regR =>	  BEGIN	  CPSymbol.AddRRegSymbol[sym, addr - CPDef.ROffset];	  rReg ¬ rReg + 1;	  END;        regD =>	  BEGIN	  CPSymbol.AddDRegSymbol[sym, addr];	  dReg ¬ dReg + 1;	  END;        regA =>	  BEGIN	  CPSymbol.AddARegSymbol[sym, addr];	  aReg ¬ aReg + 1;	  END;        ENDCASE => ERROR CPSymbol.Error["Unrecognized type in symbol record"L];       END;      ENDLOOP;    stop ¬ System.GetClockPulses[];    ms ¬ System.PulsesToMicroseconds[[stop - start]]/1000;    InfoSymbols[log, arg, ms, tags, rReg, dReg, aReg];    END;    InfoSymbols: PROCEDURE [    log: Format.StringProc, arg: LONG POINTER, ms: LONG CARDINAL, tags, rReg, dReg, aReg: CARDINAL] =    BEGIN    Format.Text[log, "It took "L, arg];    Format.LongDecimal[log, ms, arg];    Format.Text[log, " ms to load "L, arg];    Format.LongDecimal[log, tags, arg];    Format.Text[log, " tags, "L, arg];    Format.LongDecimal[log, rReg, arg];    Format.Text[log, " R, "L, arg];    Format.LongDecimal[log, dReg, arg];    Format.Text[log, " D, and "L, arg];    Format.LongDecimal[log, aReg, arg];    Format.Line[log, " A Reg symbols."L, arg];    END;  LoadReal: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, file: LONG STRING] =    BEGIN    filename: LONG STRING;    stream: Stream.Handle;    filename ¬ String.CopyToNewString[file, z];    [] ¬ String.AppendExtensionIfNeeded[@filename, "cpr"L, z];    Format.Text[log, "Loading real memory from "L, arg];    Format.Text[log, filename, arg];    Format.Line[log, "."L, arg];    stream ¬ MStream.ReadOnly[filename, [] ! MStream.Error =>      ERROR CPCommand.Error["Can't read that file"] ];    LoadRealFromStream[log, arg, stream !      UNWIND => BEGIN Stream.Delete[stream]; z.FREE[@filename]; END ];    Stream.Delete[stream];    z.FREE[@filename];    CPCommand.RefreshWindow[];    END;  LoadRealFromStream: PROCEDURE [log: Format.StringProc, arg: LONG POINTER, stream: Stream.Handle] =    BEGIN ENABLE      Stream.EndOfStream => ERROR CPCommand.Error["Truncated cpr file"L];    wordsPerMI: CARDINAL = 3;    buffersize: CARDINAL = CPDef.maxMIs*wordsPerMI;    buffer: ARRAY [0..Environment.wordsPerPage) OF WORD;    start, stop: System.Pulses;    ms: LONG CARDINAL;    wordsStored, blocks: LONG CARDINAL ¬ 0;    start ¬ System.GetClockPulses[];    DO      bufptr: LONG POINTER ¬ @buffer;      nextblock: BOOLEAN ¬ FALSE;      words, bytes, writecount: CARDINAL ¬ 0;      where: Environment.LongNumber;      words ¬ Stream.GetWord[stream];      IF words = 0 THEN EXIT;      IF words > Environment.wordsPerPage THEN        ERROR CPCommand.Error["CPR Block larger than a page"L];      where.highbits ¬ Stream.GetWord[stream];      where.lowbits ¬ Stream.GetWord[stream];      [bytes, , ] ¬ Stream.GetBlock[        sH: stream,        block: [	  blockPointer: LOOPHOLE[LONG[@buffer]],	  startIndex: 0,          stopIndexPlusOne: words*Environment.bytesPerWord]];      IF bytes # Environment.bytesPerWord * words THEN ERROR CPCommand.Error["Truncated CPR"L];      blocks ¬ blocks + 1;      wordsStored ¬ wordsStored + words;      WHILE ~nextblock DO        writecount ¬ IF words > buffersize THEN buffersize ELSE words;        CPKernel.WriteMemoryBlock[where.lp, writecount, bufptr ! CPKernel.Error => ERROR CPCommand.Error[reason] ];        IF words > buffersize THEN {	  words ¬ words - buffersize;	  bufptr ¬ bufptr + buffersize;	  where.lp ¬ where.lp + buffersize} ELSE nextblock ¬ TRUE;        ENDLOOP;      ENDLOOP;    stop ¬ System.GetClockPulses[];    ms ¬ System.PulsesToMicroseconds[[stop - start]]/1000;    InfoReal[log, arg, ms, wordsStored, blocks];    END;	  InfoReal: PROCEDURE [log: Format.StringProc, arg: LONG POINTER, ms, words, blocks: LONG CARDINAL] =    BEGIN    Format.Text[log, "It took "L, arg];    Format.LongDecimal[log, ms, arg];    Format.Text[log, " ms to load "L, arg];    Format.LongDecimal[log, words, arg];    Format.Text[log, " words in "L, arg];    Format.LongDecimal[log, blocks, arg];    Format.Text[log, " blocks."L, arg];    IF ms # 0 THEN      BEGIN      Format.Text[log, " ("L, arg];      Format.LongDecimal[log, words*16*1000/ms, arg];      Format.Text[log, " bits/sec)"L, arg];      END;    Format.CR[log, arg];    END;  END.-- JAC/JWF	29-Aug-86 17:34:51	for new CPCommand
-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. ---- CPSourceSymbolImpl.mesa, AYC   , 11-Dec-84 11:25:39-- from CPSymbolImpl.mesa,  AYC   , 15-Aug-84  9:29:24--DIRECTORY  Environment USING [bytesPerWord, LongNumber],  Format USING [CR, Line, LongDecimal, StringProc, Text],  Heap USING [Create],  MStream USING [Error, ReadOnly],  Stream USING [Delete, EndOfStream, GetBlock, Handle],  Inline USING [LowHalf],  String USING [AppendExtensionIfNeeded, AppendString, CopyToNewString],  System USING [GetClockPulses, Pulses, PulsesToMicroseconds],    CPCommand USING [Error],  CPDef USING [    AReg, Bank, BankAndWordsPerBank, DReg, IBDisp, maxMIs, MDR, RealCS,    RReg, ROffset, sizeOfCS, StartAddr, StartAddrPlusOne, wordsPerBank],  CPKernel USING [Error, OneMI, ReadBank],  CPSourceSymbol USING [nullRealCS, nullVirturalCS, VirturalCS],  CPuFormat USING [mi, MI],  DsyuFormat USING [FinalBinaryRec, LabelSymbolRec],  SymbolHash USING [    Create, EnumerateEntries, GetInfo, GetString, Handle, Hash, Insert,    Lookup, nullHash, PutInfo, Reset];CPSourceSymbolImpl: MONITOR  IMPORTS Format, Heap, Inline, MStream, Stream, String, System,  	  CPCommand, CPKernel, SymbolHash  EXPORTS CPSourceSymbol =  BEGIN    WordInBank: TYPE = [0..CPDef.wordsPerBank);  z: UNCOUNTED ZONE = Heap.Create[10];    Error: PUBLIC ERROR [reason: LONG STRING] = CODE;    -- setup hash table for label, rReg, dReg and aReg  csSymbols: SymbolHash.Handle ¬ SymbolHash.Create[100];  rRegSymbols: SymbolHash.Handle ¬ SymbolHash.Create[2];  dRegSymbols: SymbolHash.Handle ¬ SymbolHash.Create[2];  aRegSymbols: SymbolHash.Handle ¬ SymbolHash.Create[2];    csInverse: ARRAY CPDef.Bank OF LONG POINTER TO ARRAY WordInBank OF SymbolHash.Hash ¬ ALL[NIL];  rRegInverse: LONG POINTER TO ARRAY CPDef.RReg OF SymbolHash.Hash ¬ z.NEW[ARRAY CPDef.RReg OF SymbolHash.Hash];  dRegInverse: LONG POINTER TO ARRAY CPDef.DReg OF SymbolHash.Hash ¬ z.NEW[ARRAY CPDef.DReg OF SymbolHash.Hash];  aRegInverse: LONG POINTER TO ARRAY CPDef.AReg OF SymbolHash.Hash ¬ z.NEW[ARRAY CPDef.AReg OF SymbolHash.Hash];    info: ARRAY CPDef.Bank OF LONG POINTER TO ARRAY WordInBank OF Info ¬ ALL[NIL];  Info: TYPE = RECORD [    valid: BOOLEAN,    ibdisp: CPDef.IBDisp,    mdr: CPDef.MDR,    virtural: CPSourceSymbol.VirturalCS];      ClearSymbolTable: PUBLIC ENTRY PROCEDURE =    BEGIN    FOR bank: CPDef.Bank IN CPDef.Bank DO      IF info[bank] = NIL THEN LOOP;      info[bank]­ ¬ ALL [[FALSE,FALSE,FALSE,]];      ENDLOOP;    FOR bank: CPDef.Bank IN CPDef.Bank DO      IF csInverse[bank] = NIL THEN LOOP;      csInverse[bank]­ ¬ ALL[SymbolHash.nullHash];      ENDLOOP;    rRegInverse­ ¬ ALL[SymbolHash.nullHash];    dRegInverse­ ¬ ALL[SymbolHash.nullHash];    aRegInverse­ ¬ ALL[SymbolHash.nullHash];    SymbolHash.Reset[csSymbols];    SymbolHash.Reset[rRegSymbols];    SymbolHash.Reset[dRegSymbols];    SymbolHash.Reset[aRegSymbols];    END;      AddToMap: ENTRY PROCEDURE [real: CPDef.RealCS, virtural: CPSourceSymbol.VirturalCS, ibdisp: CPDef.IBDisp, mdr: CPDef.MDR] =    BEGIN    bank: CPDef.Bank;    wordInBank: WordInBank;    IF real ~IN CPDef.RealCS THEN ERROR;    [bank, wordInBank] ¬ SplitReal[real];    BeSureInfoExists[bank, wordInBank];    info[bank][wordInBank] ¬ [TRUE, ibdisp, mdr, virtural];    END;    AddCSSymbol: ENTRY PROCEDURE [tag: LONG STRING, virt: CPSourceSymbol.VirturalCS] =    BEGIN ENABLE UNWIND => NULL;    hash: SymbolHash.Hash ¬ SymbolHash.Lookup[csSymbols, tag];    bank: CPDef.Bank;    wordInBank: WordInBank;    IF hash # SymbolHash.nullHash THEN      BEGIN      IF virt = SymbolHash.GetInfo[csSymbols, hash] THEN RETURN;  -- Ignore duplicates      ERROR Error["Duplicate CS Symbol"L];      END;    hash ¬ SymbolHash.Insert[csSymbols, tag];    SymbolHash.PutInfo[csSymbols, hash, virt];    [bank, wordInBank] ¬ SplitVirt[virt];    BeSureInverseExists[bank, wordInBank];    csInverse[bank][wordInBank] ¬ hash;    END;      AddRRegSymbol: ENTRY PROCEDURE [tag: LONG STRING, r: CPDef.RReg] =    BEGIN ENABLE UNWIND => NULL;    hash: SymbolHash.Hash ¬ SymbolHash.Lookup[rRegSymbols, tag];    IF hash # SymbolHash.nullHash THEN      BEGIN      IF r = SymbolHash.GetInfo[rRegSymbols, hash] THEN RETURN;  -- Ignore duplicates      ERROR Error["Duplicate RReg Symbol"L];      END;    hash ¬ SymbolHash.Insert[rRegSymbols, tag];    SymbolHash.PutInfo[rRegSymbols, hash, r];    rRegInverse[r] ¬ hash;    END;      AddDRegSymbol: ENTRY PROCEDURE [tag: LONG STRING, d: CPDef.DReg] =    BEGIN ENABLE UNWIND => NULL;    hash: SymbolHash.Hash ¬ SymbolHash.Lookup[dRegSymbols, tag];    IF hash # SymbolHash.nullHash THEN      BEGIN      IF d = SymbolHash.GetInfo[dRegSymbols, hash] THEN RETURN;  -- Ignore duplicates      ERROR Error["Duplicate DReg Symbol"L];      END;    hash ¬ SymbolHash.Insert[dRegSymbols, tag];    SymbolHash.PutInfo[dRegSymbols, hash, d];    dRegInverse[d] ¬ hash;    END;    AddARegSymbol: ENTRY PROCEDURE [tag: LONG STRING, a: CPDef.AReg] =    BEGIN ENABLE UNWIND => NULL;    hash: SymbolHash.Hash ¬ SymbolHash.Lookup[aRegSymbols, tag];    IF hash # SymbolHash.nullHash THEN      BEGIN      IF a = SymbolHash.GetInfo[aRegSymbols, hash] THEN RETURN;  -- Ignore duplicates      ERROR Error["Duplicate AReg Symbol"L];      END;    hash ¬ SymbolHash.Insert[aRegSymbols, tag];    SymbolHash.PutInfo[aRegSymbols, hash, a];    aRegInverse[a] ¬ hash;    END;  LookupInCSTable: PUBLIC ENTRY PROCEDURE [tag: LONG STRING] RETURNS [ok: BOOLEAN, virt: CPSourceSymbol.VirturalCS] =    BEGIN    hash: SymbolHash.Hash ¬ SymbolHash.Lookup[csSymbols, tag];    bank: CPDef.Bank;    wordInBank: WordInBank;    IF hash = SymbolHash.nullHash THEN RETURN[FALSE, ];    ok ¬ TRUE;    virt ¬ Inline.LowHalf[SymbolHash.GetInfo[csSymbols, hash]];    [bank, wordInBank] ¬ SplitVirt[virt];    BeSureInverseExists[bank, wordInBank];    csInverse[bank][wordInBank] ¬ hash;    END;      LookupInRRegTable: PUBLIC ENTRY PROCEDURE [tag: LONG STRING] RETURNS [ok: BOOLEAN, r: CPDef.RReg] =    BEGIN    hash: SymbolHash.Hash ¬ SymbolHash.Lookup[rRegSymbols, tag];    IF hash = SymbolHash.nullHash THEN RETURN[FALSE, ];    ok ¬ TRUE;    r ¬ Inline.LowHalf[SymbolHash.GetInfo[rRegSymbols, hash]];    rRegInverse[r] ¬ hash;    END;      LookupInDRegTable: PUBLIC ENTRY PROCEDURE [tag: LONG STRING] RETURNS [ok: BOOLEAN, d: CPDef.DReg] =    BEGIN    hash: SymbolHash.Hash ¬ SymbolHash.Lookup[dRegSymbols, tag];    IF hash = SymbolHash.nullHash THEN RETURN[FALSE, ];    ok ¬ TRUE;    d ¬ Inline.LowHalf[SymbolHash.GetInfo[dRegSymbols, hash]];    dRegInverse[d] ¬ hash;    END;      LookupInARegTable: PUBLIC ENTRY PROCEDURE [tag: LONG STRING] RETURNS [ok: BOOLEAN, a: CPDef.AReg] =    BEGIN    hash: SymbolHash.Hash ¬ SymbolHash.Lookup[aRegSymbols, tag];    IF hash = SymbolHash.nullHash THEN RETURN[FALSE, ];    ok ¬ TRUE;    a ¬ Inline.LowHalf[SymbolHash.GetInfo[aRegSymbols, hash]];    aRegInverse[a] ¬ hash;    END;          LookUpCS: PUBLIC PROCEDURE [s: LONG STRING, virturalCS: CPSourceSymbol.VirturalCS] RETURNS[hit: BOOLEAN ¬ FALSE] =    BEGIN    PrintMatches: PROCEDURE [hash: SymbolHash.Hash] =      BEGIN      IF SymbolHash.GetInfo[csSymbols, hash] # virturalCS THEN RETURN;      IF hit THEN {	String.AppendString[s, "!"L];	RETURN;	};      String.AppendString[s, SymbolHash.GetString[csSymbols, hash]];      hit ¬ TRUE;      END;    SymbolHash.EnumerateEntries[csSymbols, PrintMatches];    END;  LookUpRReg: PUBLIC PROCEDURE [s: LONG STRING, r: CPDef.RReg] RETURNS[hit: BOOLEAN ¬ FALSE] =    BEGIN    PrintMatches: PROCEDURE [hash: SymbolHash.Hash] =      BEGIN      IF SymbolHash.GetInfo[rRegSymbols, hash] # r - CPDef.ROffset THEN RETURN;      IF hit THEN {	String.AppendString[s, "!"L];	RETURN;	};      String.AppendString[s, SymbolHash.GetString[rRegSymbols, hash]];      hit ¬ TRUE;      END;    SymbolHash.EnumerateEntries[rRegSymbols, PrintMatches];    END;  LookUpDReg: PUBLIC PROCEDURE [s: LONG STRING, d: CPDef.DReg] RETURNS[hit: BOOLEAN ¬ FALSE] =    BEGIN    PrintMatches: PROCEDURE [hash: SymbolHash.Hash] =      BEGIN      IF SymbolHash.GetInfo[dRegSymbols, hash] # d THEN RETURN;      IF hit THEN {	String.AppendString[s, "!"L];	RETURN;	};      String.AppendString[s, SymbolHash.GetString[dRegSymbols, hash]];      hit ¬ TRUE;      END;    SymbolHash.EnumerateEntries[dRegSymbols, PrintMatches];    END;  LookUpAReg: PUBLIC PROCEDURE [s: LONG STRING, a: CPDef.RReg] RETURNS[hit: BOOLEAN ¬ FALSE] =    BEGIN    PrintMatches: PROCEDURE [hash: SymbolHash.Hash] =      BEGIN      IF SymbolHash.GetInfo[aRegSymbols, hash] # a THEN RETURN;      IF hit THEN {	String.AppendString[s, "!"L];	RETURN;	};      String.AppendString[s, SymbolHash.GetString[aRegSymbols, hash]];      hit ¬ TRUE;      END;    SymbolHash.EnumerateEntries[aRegSymbols, PrintMatches];    END;    RealToVirturalCS: PUBLIC ENTRY PROCEDURE [real: CPDef.RealCS]    RETURNS [CPSourceSymbol.VirturalCS, CPDef.IBDisp, CPDef.MDR] =    BEGIN    p: LONG POINTER TO Info;    bank: CPDef.Bank;    wordInBank: WordInBank;    [bank, wordInBank] ¬ SplitReal[real];    IF info[bank] = NIL THEN RETURN[CPSourceSymbol.nullVirturalCS,FALSE,FALSE];    p ¬ @info[bank][wordInBank];    IF ~p.valid THEN RETURN[CPSourceSymbol.nullVirturalCS,FALSE,FALSE];    RETURN[p.virtural, p.ibdisp, p.mdr];    END;      VirturalToRealCS: PUBLIC ENTRY PROCEDURE [virtural: CPSourceSymbol.VirturalCS]    RETURNS [CPDef.RealCS, CPDef.IBDisp, CPDef.MDR] =    BEGIN    FOR real: CPDef.RealCS IN CPDef.RealCS DO      p: LONG POINTER TO Info;      bank: CPDef.Bank;      wordInBank: WordInBank;      [bank, wordInBank] ¬ SplitReal[real];      IF info[bank] = NIL THEN LOOP;      p ¬ @info[bank][wordInBank];      IF p.valid AND virtural = p.virtural THEN RETURN[real, p.ibdisp, p.mdr];      ENDLOOP;    RETURN[CPSourceSymbol.nullRealCS,FALSE,FALSE];    END;  SplitReal: PROCEDURE [real: CPDef.RealCS] RETURNS [bank: CPDef.Bank, wordInBank: WordInBank] =    BEGIN    temp: CPDef.BankAndWordsPerBank = LOOPHOLE[real];    RETURN[temp.bank, temp.wordInBank];    END;    SplitVirt: PROCEDURE [virt: CPSourceSymbol.VirturalCS] RETURNS [bank: CPDef.Bank, wordInBank: WordInBank] =    BEGIN    temp: CPDef.BankAndWordsPerBank = LOOPHOLE[virt];    RETURN[temp.bank, temp.wordInBank];    END;    BeSureInverseExists: PROCEDURE [bank: CPDef.Bank, wordInBank: WordInBank] =    BEGIN    IF csInverse[bank] # NIL THEN RETURN;    csInverse[bank] ¬ z.NEW[ARRAY WordInBank OF SymbolHash.Hash];    csInverse[bank]­ ¬ ALL [SymbolHash.nullHash];    END;      BeSureInfoExists: PROCEDURE [bank: CPDef.Bank, wordInBank: WordInBank] =    BEGIN    IF info[bank] # NIL THEN RETURN;    info[bank] ¬ z.NEW[ARRAY WordInBank OF Info];    info[bank]­ ¬ ALL [[FALSE, , , ]];    END;      LoadPrivateSymbols: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, file: LONG STRING] =    BEGIN    filename: LONG STRING;    stream: Stream.Handle;    filename ¬ String.CopyToNewString[file, z];    [] ¬ String.AppendExtensionIfNeeded[@filename, "st"L, z];    Format.Text[log, "Loading CP symbols from "L, arg];    Format.Text[log, filename, arg];    Format.Line[log, "."L, arg];    stream ¬ MStream.ReadOnly[filename, [] ! MStream.Error =>      BEGIN z.FREE[@filename]; ERROR CPCommand.Error["Can't read that file"]; END ];    LoadSymbolsFromStream[log, arg, stream !      UNWIND => BEGIN Stream.Delete[stream]; z.FREE[@filename]; END ];    Stream.Delete[stream];    z.FREE[@filename];    filename ¬ String.CopyToNewString[file, z];    [] ¬ String.AppendExtensionIfNeeded[@filename, "fb"L, z];    Format.Text[log, "Loading CP Binary from "L, arg];    Format.Text[log, filename, arg];    Format.Line[log, "."L, arg];    stream ¬ MStream.ReadOnly[filename, [] ! MStream.Error =>      BEGIN z.FREE[@filename]; ERROR CPCommand.Error["Can't read that file"]; END ];    LoadFromStream[log, arg, stream !      UNWIND => BEGIN Stream.Delete[stream]; z.FREE[@filename]; END ];    Stream.Delete[stream];    z.FREE[@filename];    END;      LoadSymbolsFromStream: PROCEDURE [log: Format.StringProc, arg: LONG POINTER, stream: Stream.Handle] =    BEGIN    start, stop: System.Pulses;    ms: LONG CARDINAL;    tags, rReg, dReg, aReg: CARDINAL ¬ 0;    lsr: DsyuFormat.LabelSymbolRec ¬ TRASH;    bytesPerRec: CARDINAL = Environment.bytesPerWord*SIZE[DsyuFormat.LabelSymbolRec];    sym: LONG STRING = [100];    offset: CARDINAL = CPKernel.ReadBank[] * CPDef.wordsPerBank;  -- ***  Hack until Mass is smarter    start ¬ System.GetClockPulses[];    DO      bytes, wordsExpected: CARDINAL;      [bytes, , ] ¬ Stream.GetBlock[        sH: stream,        block: [          blockPointer: LOOPHOLE[LONG[@lsr]],	  startIndex: 0,          stopIndexPlusOne: bytesPerRec]];      IF bytes = 0 THEN EXIT;      IF bytes # bytesPerRec THEN ERROR CPCommand.Error["Symbol file truncated"L];      IF lsr.length = 0 THEN ERROR CPCommand.Error["Zero length tag"L];      IF lsr.length > sym.maxlength THEN ERROR CPCommand.Error["Huge label string"L];      wordsExpected ¬ (lsr.length + (Environment.bytesPerWord - 1))/Environment.bytesPerWord;      [bytes, , ] ¬  Stream.GetBlock[        sH: stream,        block: [          blockPointer: LOOPHOLE[@sym.text],	  startIndex: 0,          stopIndexPlusOne: Environment.bytesPerWord*wordsExpected]];      sym.length ¬ lsr.length;      BEGIN ENABLE Error =>        BEGIN	Format.Text[log, "Troubles adding "L, arg];	Format.Text[log, sym, arg];	Format.Text[log, " to symbol table: "L, arg];	Format.Text[log, reason, arg];	Format.CR[log, arg];	CONTINUE;	END;      WITH lsr SELECT FROM        label =>	  BEGIN	  virt: CPSourceSymbol.VirturalCS;	  IF miIndex >= CPDef.wordsPerBank THEN ERROR;	  virt ¬ miIndex + offset;	  AddCSSymbol[sym, virt];	  tags ¬ tags + 1;	  END;        regR =>	  BEGIN	  AddRRegSymbol[sym, addr - CPDef.ROffset];	  rReg ¬ rReg + 1;	  END;        regD =>	  BEGIN	  AddDRegSymbol[sym, addr];	  dReg ¬ dReg + 1;	  END;        regA =>	  BEGIN	  AddARegSymbol[sym, addr];	  aReg ¬ aReg + 1;	  END;        ENDCASE => ERROR Error["Unrecognized type in symbol record"L];       END;      ENDLOOP;    stop ¬ System.GetClockPulses[];    ms ¬ System.PulsesToMicroseconds[[stop - start]]/1000;    InfoSymbols[log, arg, ms, tags, rReg, dReg, aReg];    END;    InfoSymbols: PROCEDURE [    log: Format.StringProc, arg: LONG POINTER, ms: LONG CARDINAL, tags, rReg, dReg, aReg: CARDINAL] =    BEGIN    Format.Text[log, "It took "L, arg];    Format.LongDecimal[log, ms, arg];    Format.Text[log, " ms to load "L, arg];    Format.LongDecimal[log, tags, arg];    Format.Text[log, " tags, "L, arg];    Format.LongDecimal[log, rReg, arg];    Format.Text[log, " R, "L, arg];    Format.LongDecimal[log, dReg, arg];    Format.Text[log, " D, and "L, arg];    Format.LongDecimal[log, aReg, arg];    Format.Line[log, " A Reg symbols."L, arg];    END;  LoadFromStream: PROCEDURE [log: Format.StringProc, arg: LONG POINTER, stream: Stream.Handle] =    -- Load Virtural Control Store Symbol value    BEGIN ENABLE      BEGIN      Stream.EndOfStream => ERROR CPCommand.Error["Truncated fb file"L];      CPKernel.Error => ERROR CPCommand.Error[reason];      END;    start, stop: System.Pulses;    ms: LONG CARDINAL;    instructions: CARDINAL ¬ 0;    fbrBytes: CARDINAL = Environment.bytesPerWord*SIZE[DsyuFormat.FinalBinaryRec];    fbr: DsyuFormat.FinalBinaryRec ¬ TRASH;    fbrptr: POINTER = @fbr;    pb: POINTER TO CPuFormat.mi = LOOPHOLE[@fbr.partialBinary];    last: CARDINAL ¬ 0;    miInClump: CARDINAL ¬ 0;    clump: ARRAY [0..CPDef.maxMIs) OF CPKernel.OneMI;    offset: CARDINAL = CPKernel.ReadBank[] * CPDef.wordsPerBank;  -- ***  Hack until Mass is smarter    start ¬ System.GetClockPulses[];    DO      bytes: CARDINAL;      [bytes, , ] ¬ Stream.GetBlock[          sH: stream,          block: [            blockPointer: fbrptr,	    startIndex: 0,            stopIndexPlusOne: fbrBytes]];      IF bytes # fbrBytes THEN ERROR CPCommand.Error["Truncated fb"];      IF fbr.addr >= CPDef.sizeOfCS THEN EXIT;      fbr.addr ¬ fbr.addr + offset;      IF fbr.miNum = CPDef.StartAddr OR fbr.miNum = CPDef.StartAddrPlusOne THEN        BEGIN	-- Can not set Starting Addresses here        END      ELSE        BEGIN	IF instructions # 0 THEN	  BEGIN	  IF last + 1 # fbr.addr OR miInClump = CPDef.maxMIs THEN	    BEGIN	    --	    -- Do not Write Control Store	    --	    -- CPKernelOps.WriteCSBlockInternal[miInClump, @clump[0]];	    miInClump ¬ 0;	    END;	  END;	clump[miInClump] ¬ [fbr.addr, pb­];	last ¬ fbr.addr;	miInClump ¬ miInClump + 1;	instructions ¬ instructions + 1;        IF TRUE THEN	  BEGIN	  fbr.miNum ¬ fbr.miNum + offset;	  AddToMap[fbr.addr, fbr.miNum, fbr.partialBinary.ibdisp, fbr.partialBinary.mdr];	  END;        END      ENDLOOP;    --    -- Do not Write Control Store    --    -- IF miInClump # 0 THEN CPKernelOps.WriteCSBlockInternal[miInClump, @clump[0]];    stop ¬ System.GetClockPulses[];    ms ¬ System.PulsesToMicroseconds[[stop - start]]/1000;    InfoBinary[log, arg, ms, instructions];    END;      InfoBinary: PROCEDURE [log: Format.StringProc, arg: LONG POINTER, ms, instructions: LONG CARDINAL] =    BEGIN    Format.Text[log, "It took "L, arg];    Format.LongDecimal[log, ms, arg];    Format.Text[log, " ms to load "L, arg];    Format.LongDecimal[log, instructions, arg];    Format.Text[log, " instructions."L, arg];    IF ms # 0 THEN      BEGIN      Format.Text[log, " ("L, arg];      Format.LongDecimal[log, instructions*16*SIZE[CPuFormat.MI]*1000/ms, arg];      Format.Text[log, " bits/sec)"L, arg];      END;    Format.CR[log, arg];    END;   ClearSymbolTable[];  END.
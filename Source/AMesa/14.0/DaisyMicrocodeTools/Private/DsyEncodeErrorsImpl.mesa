-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. -- The purpose of this module is to create, delete, and print error messages that occur during encoding.  Syntax error messages are queued onto phrase.errorMsgs.  Other error messages are created and queued onto phrase.tempErrorMsgs.  Messages are saved here temporarily because an alternate encoding may save the day.  If no encoding works, MakeTempErrorMsgsPermamanent will be called to requeue the messages onto phrase.errorMsgs.  --Last edit by JAC             5-Nov-84 14:17:14  DIRECTORY  Inline USING [LDIVMOD],  DsyFile USING [LogErrAndSrcLines, LogLine],  DsyAssembler,  String USING [AppendChar, AppendString, WordsForString];DsyEncodeErrorsImpl: PROGRAM  IMPORTS Inline, DsyFile, DsyAssembler, String EXPORTS DsyAssembler =  BEGIN OPEN DsyAssembler;  -- GLOBAL VARIABLES  constant: LONG STRING ¬ [10];  msg: LONG STRING ¬ [250];  -- All messages are created in this string.  -- SIGNALS AND ERRORS GENERATED  EncodeErrorsError: ERROR [    {invalidAFileErrorCode, invalidSyntaxErrorCode, invalidMemoryErrorCode}] = CODE;  AFileError: PUBLIC PROCEDURE [code: AFileErrorCode] =  --type error messages to log file    BEGIN    SELECT code FROM      illegalJumpReference => DsyFile.LogErrAndSrcLines["The use of the A register conflicts with use in MI jumped to or from"L];      illegalJumpSource => DsyFile.LogErrAndSrcLines["Illegal source for MDR ¬ as a result of an MI jumped to or from"L];      illegalReference => DsyFile.LogErrAndSrcLines["The use of the A register conflicts with use in previous MI"L];      illegalSource => DsyFile.LogErrAndSrcLines["Source for MDR ¬ conflicts with previous destination"L];      ENDCASE => ERROR EncodeErrorsError[invalidAFileErrorCode]    END;  --of procedure AFileError      AppendAssignment: PROCEDURE [assignment: Assignment] =    BEGIN    -- Append the cause of an assignment onto msg.  For every field in the Encoding record, we remember what caused the assignment just for this purpose.  When two elements conflict, we can say what what phrase elements cause the conflict.    WITH assignment SELECT FROM      expression => String.AppendString[msg, "expression"L];      macro =>        BEGIN        String.AppendString[msg, "macro "L];        String.AppendString[msg, macroTable[macroIndex].macro];        END;      register => String.AppendString[msg, RegisterTypeString[registerType]];      ENDCASE => String.AppendString[msg, "invalidAssignment"L];    RETURN;    END;  AppendDecimal: PROCEDURE [string: LONG STRING, number: CARDINAL] =    BEGIN    base: CARDINAL = 10;    charZero: CARDINAL = LOOPHOLE['0];    Digit: PROCEDURE =      BEGIN      remainder: CARDINAL;      IF number # 0 THEN        BEGIN        [number, remainder] ¬ Inline.LDIVMOD[number, 0, base];        Digit;        String.AppendChar[string, LOOPHOLE[remainder + charZero, CHARACTER]];        END;      RETURN;      END;    IF number = 0 THEN String.AppendChar[string, '0] ELSE Digit;    RETURN;    END;  ChainMsg: PROCEDURE [list: LONG POINTER TO ErrorMsgPtr] =    BEGIN    -- Chain msg onto phrase.errorMsgs.    newErrorMsg: ErrorMsgPtr;    lastErrorMsg: ErrorMsgPtr;    -- Allocate a new error message and initialize it with the contents of msg.    newErrorMsg ¬ GetStmtSpace[SIZE[ErrorMsg] + String.WordsForString[msg.length]];    newErrorMsg­ ¬ [      nextMsg: NIL, msg: LOOPHOLE[@newErrorMsg.length, LONG STRING], length: 0,      maxlength: msg.length];    String.AppendString[newErrorMsg.msg, msg];    -- Chain the new error mesesage onto the list.    IF list­ = NIL THEN      BEGIN  -- the chain is empty.  Chain the first record.      list­ ¬ newErrorMsg;      RETURN;      END;    lastErrorMsg ¬ list­;    DO  -- Find the end of the chain      IF lastErrorMsg.nextMsg = NIL THEN EXIT;      lastErrorMsg ¬ lastErrorMsg.nextMsg;      ENDLOOP;    lastErrorMsg.nextMsg ¬ newErrorMsg;    RETURN;    END;  ConstantString: PROCEDURE [value: CARDINAL] RETURNS [LONG STRING] =    BEGIN    -- Convert value to string and append to global constant.    constant.length ¬ 0;    AppendDecimal[constant, value];    RETURN[constant];    END;    FormatError: PUBLIC PROCEDURE [    phrase: PhrasePtr, assignment1, assignment2: Assignment,    fieldName: LONG STRING] =    BEGIN    -- There is a conflict in field fieldName.  assignment1 has already been assigned, and assignment2 conflicts.  Create an error message and chain it onto phrase.tempErrorMsgs.  The error messages will be chained onto phrase.errorMsgs if no pattern that works can be found.    msg.length ¬ 0;    AppendAssignment[assignment1];    String.AppendString[msg, " conflicts with "L];    AppendAssignment[assignment2];    String.AppendString[msg, " in field "L];    String.AppendString[msg, fieldName];    ChainMsg[@phrase.tempErrorMsgs];    RETURN;    END;  MakeTempErrorMsgsPermanent: PUBLIC PROCEDURE [phrase: PhrasePtr] =    BEGIN    -- Move phrase.tempErrorMsgs to phrase.errorMsgs.    lastErrorMsg: ErrorMsgPtr;    phrase.formatError ¬ TRUE;    IF phrase.tempErrorMsgs = NIL THEN RETURN;    IF phrase.errorMsgs = NIL THEN phrase.errorMsgs ¬ phrase.tempErrorMsgs    ELSE      BEGIN      lastErrorMsg ¬ phrase.errorMsgs;      DO  -- Find the end of the chain        IF lastErrorMsg.nextMsg = NIL THEN EXIT;        lastErrorMsg ¬ lastErrorMsg.nextMsg;        ENDLOOP;      lastErrorMsg.nextMsg ¬ phrase.tempErrorMsgs;      END;    phrase.tempErrorMsgs ¬ NIL;    RETURN;    END;      MemoryError: PUBLIC PROCEDURE [code: MemoryErrorCode] =  --type error messages to log file     BEGIN    SELECT code FROM      atCycleError => DsyFile.LogErrAndSrcLines["Cycle required by at conflicts with one required by previous branch"L];      atTypeConflict => DsyFile.LogErrAndSrcLines["Memory cycle type required by at conflicts with one required by previous branch"L];      cycleConflict => DsyFile.LogErrAndSrcLines["Cycle Conflict"L];      cycleIllegalHere => DsyFile.LogErrAndSrcLines["Illegal use of cycle"L];      dataNotAvailable => DsyFile.LogErrAndSrcLines["Memory data not available yet"L];      destCycleConflict => DsyFile.LogErrAndSrcLines["This MI and another MI which jumps to the same MI require it to have different cycles"];      destTypeConflict => DsyFile.LogErrAndSrcLines["This MI and another MI which jumps to the same MI require it to have different memory types"];      fromCycleError => DsyFile.LogErrAndSrcLines["Previous MI and a MI which jumps to the current MI require conflicting cycles"L];      fromTypeConflict => DsyFile.LogErrAndSrcLines["Previous MI and a MI which jumps to the current MI require conflicting memory cycle types"L];      illegalMDRSource => DsyFile.LogErrAndSrcLines["MDR ¬ requires only an Abus source"L];      illegalStart => DsyFile.LogErrAndSrcLines["This MI cannot start a memory cycle"L];      jumpCycleConflict => DsyFile.LogErrAndSrcLines["This MI has a cycle conflict with the MI it jumps to"L];      jumpNeedsCycle => DsyFile.LogErrAndSrcLines["This MI jumps to an MI which needs a cycle phrase"L];      jumpTypeConflict => DsyFile.LogErrAndSrcLines["Memory cycle type conflict with MI jumped from or MI with same at label"L];      mdrIllegal => DsyFile.LogErrAndSrcLines["MDR ¬ illegal here"L];      needsCycle => DsyFile.LogErrAndSrcLines["This MI needs a cycle phrase"L];      needsMARType => DsyFile.LogErrAndSrcLines["This MI requires a memory cycle type"L];      noMDR => DsyFile.LogErrAndSrcLines["This MI needs MDR ¬ "L];      typeConflict => DsyFile.LogErrAndSrcLines["Memory cycle type conflict with the MI to which this MI jumps"L];       ENDCASE => EncodeErrorsError[invalidMemoryErrorCode];    END;  --of procedure MemoryError  PrintPhraseErrorMsgs: PROCEDURE [phrase: PhrasePtr] =    BEGIN    errorMsg: ErrorMsgPtr ¬ phrase.errorMsgs;    UNTIL errorMsg = NIL DO      DsyFile.LogLine[errorMsg.msg]; errorMsg ¬ errorMsg.nextMsg; ENDLOOP;    errorMsg ¬ phrase.tempErrorMsgs;    UNTIL errorMsg = NIL DO      DsyFile.LogLine[errorMsg.msg]; errorMsg ¬ errorMsg.nextMsg; ENDLOOP;    RETURN;    END;  PrintStatementErrorMsgs: PUBLIC PROCEDURE [statement: StatementPtr] =    BEGIN    phrase: PhrasePtr ¬ statement.firstPhrase;    UNTIL phrase = NIL DO      PrintPhraseErrorMsgs[phrase];            phrase ¬ phrase.nextPhrase;      ENDLOOP;    DsyFile.LogErrAndSrcLines["Unable to encode Statement.  Noop inserted"L];    RETURN;    END;  RegisterTypeString: PROCEDURE [registerType: RegisterType]    RETURNS [string: LONG STRING] =     BEGIN    string ¬      SELECT registerType FROM        R => "R register",        D => "D register",        aUpper8, aUpper16, aLower16 => "A register",        CIP => "CIP",        stkPtr => "STK",        Q => "Q",        ENDCASE => "unknownRegType";    RETURN;    END;  SyntaxError: PUBLIC PROCEDURE [phrase: PhrasePtr, code: SyntaxErrorCode] =    BEGIN    msg.length ¬ 0;    SELECT code FROM      invalidExpression => String.AppendString[msg, "Invalid expression"L];      arrowMissing => String.AppendString[msg, "Arrow missing"L];      noRHS => String.AppendString[msg, "Right hand side of expression missing"L];      unexpectedLHS =>        String.AppendString[msg, "Unexpected element in LHS of expression "L];      operationMissing =>        String.AppendString[msg, "Operation expected but not found "L];      missingPlusOrMinus =>        String.AppendString[msg, "Plus or minus one expected "L];      unexpectedRHS =>        String.AppendString[msg, "Unexpected element in RHS of expression "L];      invalidSecondOperand =>        String.AppendString[msg, "Invalid second operand "L];      invalidOperand => 	String.AppendString[msg, "Invalid operand "L];      doubleNot => String.AppendString[msg, "Only one not operand permitted"L];      oneMissing =>        String.AppendString[msg, "One following plus expected "L];      multipleArrows => String.AppendString[msg, "R bus conflict"L];      invalidPlus => String.AppendString[msg, "+1 is invalid"L];      invalidMinus => String.AppendString[msg, "-1 is invalid"L];      noOperand => String.AppendString[msg, "No operand follows operation"L];      endOfPhrase => String.AppendString[msg, "Unexpected end of phrase"L];      ENDCASE => ERROR EncodeErrorsError[invalidSyntaxErrorCode];    ChainMsg[@phrase.errorMsgs];    RETURN;    END;  END... --Log of last edits:--JAC   	 5-Nov-84 14:17:25	fixed arrows for Mesa 11.1
{ --	Copyright (C) 1984 by Xerox Corporation.  All rights reserved. -- Last edit by: -- JAC		 2-Jun-86 17:40:05	save MDu and MDv before SChip bug workaround -- JAC		 9-Apr-86 11:49:01	work around SChip bug by writng a nonzero value to mailbox+4 when in the kernel -- DaisyKernel.mc,       AYC   ,  7-Nov-84 18:43:22 -- from SiriusKernel.mc, FXB   , 24-Apr-84 16:03:25 -- -- Breakpoint handler part of Daisy Kernel microcode --}{ -- -- one of the following is the first instruction excuted after a breakpoint. The -- first level dispatch bits are saved in low nibble of low byte of dKernel register --}Reserve[0, 0FCD];kEntry:	dKernel ¬ dKernel or  0, DISP4[kDisp2], at[0FE0];	dKernel ¬ dKernel or  1, DISP4[kDisp2], at[1, 10, kEntry];	dKernel ¬ dKernel or  2, DISP4[kDisp2], at[2, 10, kEntry];	dKernel ¬ dKernel or  3, DISP4[kDisp2], at[3, 10, kEntry];	dKernel ¬ dKernel or  4, DISP4[kDisp2], at[4, 10, kEntry];	dKernel ¬ dKernel or  5, DISP4[kDisp2], at[5, 10, kEntry];	dKernel ¬ dKernel or  6, DISP4[kDisp2], at[6, 10, kEntry];	dKernel ¬ dKernel or  7, DISP4[kDisp2], at[7, 10, kEntry];	dKernel ¬ dKernel or  8, DISP4[kDisp2], at[8, 10, kEntry];	dKernel ¬ dKernel or  9, DISP4[kDisp2], at[9, 10, kEntry];	dKernel ¬ dKernel or  0A, DISP4[kDisp2], at[0A, 10, kEntry];	dKernel ¬ dKernel or  0B, DISP4[kDisp2], at[0B, 10, kEntry];	dKernel ¬ dKernel or  0C, DISP4[kDisp2], at[0C, 10, kEntry];	dKernel ¬ dKernel or  0D, DISP4[kDisp2], at[0D, 10, kEntry];	dKernel ¬ dKernel or  0E, DISP4[kDisp2], at[0E, 10, kEntry];	dKernel ¬ dKernel or  0F, DISP4[kDisp2], at[0F, 10, kEntry];	{ -- -- The second level dispatch bits are saved in high nibble of low byte of dKernel -- register, then it goes into a wait loop at kDisp2[0FF0] --}kDisp2:	dKernel ¬ dKernel or 0, GOTO[SignalInKernel], at[0FF0];	dKernel ¬ dKernel or 10, GOTO[SignalInKernel], at[1, 10, kDisp2];	dKernel ¬ dKernel or 20, GOTO[SignalInKernel], at[2, 10, kDisp2];	dKernel ¬ dKernel or 30, GOTO[SignalInKernel], at[3, 10, kDisp2];	dKernel ¬ dKernel or 40, GOTO[SignalInKernel], at[4, 10, kDisp2];	dKernel ¬ dKernel or 50, GOTO[SignalInKernel], at[5, 10, kDisp2];	dKernel ¬ dKernel or 60, GOTO[SignalInKernel], at[6, 10, kDisp2];	dKernel ¬ dKernel or 70, GOTO[SignalInKernel], at[7, 10, kDisp2];	dKernel ¬ dKernel or 80, GOTO[SignalInKernel], at[8, 10, kDisp2];	dKernel ¬ dKernel or 90, GOTO[SignalInKernel], at[9, 10, kDisp2];	dKernel ¬ dKernel or 0A0, GOTO[SignalInKernel], at[0A, 10, kDisp2];	dKernel ¬ dKernel or 0B0, GOTO[SignalInKernel], at[0B, 10, kDisp2];	dKernel ¬ dKernel or 0C0, GOTO[SignalInKernel], at[0C, 10, kDisp2];	dKernel ¬ dKernel or 0D0, GOTO[SignalInKernel], at[0D, 10, kDisp2];	dKernel ¬ dKernel or 0E0, GOTO[SignalInKernel], at[0E, 10, kDisp2];	dKernel ¬ dKernel or 0F0, GOTO[SignalInKernel], at[0F, 10, kDisp2];SignalInKernel:		raSaveHi ¬ aMailBox.page;	raSaveLow ¬ aMailBox.low;		rdSave ¬ dKtemp;	rdKernelSave ¬ dKernel;		dKtemp ¬ MDu;	dKernel ¬ MDv;		aMailBox.low ¬ wordOfMainMemoryMailBox;	aMailBox.low ¬ aMailBox.low or lowPageOfMainMemoryMailBox;	aMailBox.high ¬ hiPageOfMainMemoryMailBox;		Noop;		MAR ¬ [aMailBox + 4], Write,			c1;	MDR ¬ aMailBox.low, CANCELBR[$,1], LOOPHOLE[wok], c2;	Noop, 						c3;			aMailBox.high ¬ raSaveHi;StayHere:	aMailBox.low ¬ raSaveLow, GOTO[StayHere];{ -- IOP overlays the following code to restore the old machine state -- and start Sirius with NIA = kContinue and NIAp2Hold = kContinue + 1}kContinue:		{shift right 4 places, Bbus[3:0] ¬ first level dispatch flags}	rdKernelSave ¬ EXTRACT[0, rdKernelSave, 4],	at[0FDD];			{Bbus[3:0] ¬ second level dispatch flags}	Bbus ¬ rdKernelSave, BDisp,			at[0FDE];	 		{stuff broken instruction here}Loop:	CANCELBR[Loop,0F], 				at[0FDF];	
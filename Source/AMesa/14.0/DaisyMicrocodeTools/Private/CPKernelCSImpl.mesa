-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved. -- Last edit by JAC   		   11-Jun-85 12:41:56-- CPKernelCSImpl.mesa,    AYC   , 14-Dec-84 17:06:26-- from CPKernelCSDLion.mesa, HGM, 11-Oct-83 22:13:41--DIRECTORY  Environment USING [bytesPerWord, Byte],  Inline USING [BITSHIFT, BITXOR, LongCOPY],  Bindweed USING [Error, maxMIs, ReadCPControlStore, WriteCPControlStore],  CPDef USING [BankAndWordsPerBank, RealCS],  CPKernel USING [OneMI, Error],  CPKernelDef,  CPKernelOps USING [AddressOutOfRange],  CPuFormat USING [mi, MI, uField];CPKernelCSImpl: MONITOR  IMPORTS Inline, Bindweed, CPKernel, CPKernelOps, CPuFormat  EXPORTS CPKernel, CPKernelOps =  BEGIN OPEN CPKernelDef;    ---- Constants Definition--    bytesPerMi: CARDINAL = 6;    wordsPerMi: CARDINAL = bytesPerMi / Environment.bytesPerWord;    bufferSize: CARDINAL = Bindweed.maxMIs*bytesPerMi;---- WriteCSInternal: write a single microinstruction (3-words) to control store--  WriteCS: PUBLIC ENTRY PROCEDURE [real: CPDef.RealCS, MI: CPuFormat.MI] =    BEGIN ENABLE UNWIND => NULL; WriteCSInternal[real, MI] END;  WriteCSInternal: PUBLIC INTERNAL PROCEDURE [real: CPDef.RealCS, MI: CPuFormat.MI] =    BEGIN ENABLE UNWIND => NULL;    bankAndWordsPerBank: CPDef.BankAndWordsPerBank = LOOPHOLE[real];    localMI: CPuFormat.MI ¬ MI;    IF real ~IN CPDef.RealCS THEN CPKernelOps.AddressOutOfRange[];  --  CPKernelOps.SetNewBank[bankAndWordsPerBank.bank];    FixParity[@localMI];    WriteMIInternal[real, @localMI]    END;  WriteMIInternal: INTERNAL PROCEDURE [real: CPDef.RealCS, miptr: LONG POINTER TO CPuFormat.MI] =    BEGIN ENABLE       BEGIN       UNWIND => NULL;      Bindweed.Error =>        SELECT code FROM	  timeout => ERROR CPKernel.Error["Timeout"L];	  badCheckSum => ERROR CPKernel.Error["Bad Checksum"L]; 	  ENDCASE => ERROR CPKernel.Error["Umblicial problems"L];      END;    block: PACKED ARRAY [0..bufferSize) OF Environment.Byte ¬ ALL[0];    Inline.LongCOPY[miptr, wordsPerMi, @block];    Bindweed.WriteCPControlStore[real, 1, block];    END;  WriteCSBad: PUBLIC ENTRY PROCEDURE [real: CPDef.RealCS, MI: CPuFormat.MI] =    BEGIN ENABLE UNWIND => NULL; WriteCSBadInternal[real, MI] END;  WriteCSBadInternal: PUBLIC INTERNAL PROCEDURE [real: CPDef.RealCS, MI: CPuFormat.MI] =    BEGIN ENABLE UNWIND => NULL;    bankAndWordsPerBank: CPDef.BankAndWordsPerBank = LOOPHOLE[real];    localMI: CPuFormat.MI ¬ MI;    IF real ~IN CPDef.RealCS THEN CPKernelOps.AddressOutOfRange[];  --   CPKernelOps.SetNewBank[bankAndWordsPerBank.bank];    FixParity[@localMI];    localMI.context.common.parity ¬ ~localMI.context.common.parity;							-- extra care with parity    WriteMIInternal[real, @localMI]    END;---- WriteBlock: write a block (by count) to control store--  WriteCSBlock: PUBLIC ENTRY PROCEDURE [count: CARDINAL, clump: LONG POINTER TO CPKernel.OneMI] =    BEGIN ENABLE UNWIND => NULL;    WriteCSBlockInternal[count, clump];    END;  WriteCSBlockInternal: PUBLIC PROCEDURE [count: CARDINAL, clump: LONG POINTER TO CPKernel.OneMI] =    BEGIN ENABLE       BEGIN       UNWIND => NULL;       Bindweed.Error =>        SELECT code FROM	  timeout => ERROR CPKernel.Error["Timeout"L];	  badCheckSum => ERROR CPKernel.Error["Bad Checksum"L]; 	  ENDCASE => ERROR CPKernel.Error["Umblicial problems"L];      END;    startaddr: CARDINAL ¬ clump.real;    block: PACKED ARRAY [0..bufferSize) OF Environment.Byte ¬ ALL[0];    finger: POINTER ¬ @block;    FOR i: CARDINAL IN [0..count) DO      currentMI: CPuFormat.MI ¬ LOOPHOLE[clump.mi,CPuFormat.MI];      FixParity[@currentMI];      Inline.LongCOPY[@currentMI, wordsPerMi, finger];      finger ¬ finger + wordsPerMi;      clump ¬ clump + SIZE[CPKernel.OneMI];      ENDLOOP;    Bindweed.WriteCPControlStore[startaddr, count, block];    END;  FixParity: PUBLIC ENTRY PROCEDURE [data: LONG POINTER TO CPuFormat.MI] =    BEGIN    words: LONG POINTER = data;    parity: WORD ¬ 0;    odd: WORD ¬ 1;    data.context.common.parity ¬ FALSE;    FOR i: CARDINAL IN [0..SIZE[CPuFormat.MI]) DO      parity ¬ Inline.BITXOR[parity, (words+i)­];      ENDLOOP;    parity ¬ Inline.BITXOR[parity, Inline.BITSHIFT[parity, -8]];    parity ¬ Inline.BITXOR[parity, Inline.BITSHIFT[parity, -4]];    parity ¬ Inline.BITXOR[parity, Inline.BITSHIFT[parity, -2]];    parity ¬ Inline.BITXOR[parity, Inline.BITSHIFT[parity, -1]];    data.context.common.parity ¬ LOOPHOLE[Inline.BITXOR[parity, odd]];    END;  ReadCS: PUBLIC ENTRY PROCEDURE [real: CPDef.RealCS] RETURNS [CPuFormat.MI] =    BEGIN ENABLE UNWIND => NULL; RETURN[ReadCSInternal[real]] END;  ReadCSInternal: PUBLIC INTERNAL PROCEDURE [real: CPDef.RealCS] RETURNS [CPuFormat.MI] =    BEGIN ENABLE       BEGIN       UNWIND => NULL;       Bindweed.Error =>        SELECT code FROM	  timeout => ERROR CPKernel.Error["Timeout"L];	  badCheckSum => ERROR CPKernel.Error["Bad Checksum"L]; 	  ENDCASE => ERROR CPKernel.Error["Umblicial problems"L];      END;    bankAndWordsPerBank: CPDef.BankAndWordsPerBank = LOOPHOLE[real];    csdata: PACKED ARRAY [0..bytesPerMi) OF Environment.Byte ¬ ALL[0];    IF real ~IN CPDef.RealCS THEN CPKernelOps.AddressOutOfRange[]; --   CPKernelOps.SetNewBank[bankAndWordsPerBank.bank];    csdata ¬ Bindweed.ReadCPControlStore[real];    RETURN[CPuFormat.uField[LOOPHOLE[csdata,CPuFormat.mi]]];    END;    END.  -- Log-- JAC   	23-Jan-85 11:26:54	Bindweed procedure name change-- JAC   	11-Jun-85 12:45:19	Bindweed error name change
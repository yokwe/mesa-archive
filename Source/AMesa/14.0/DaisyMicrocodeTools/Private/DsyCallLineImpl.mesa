-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. --Last edit by JAC      5-Nov-84 14:15:15DIRECTORY  Environment USING [bytesPerWord],  Exec USING [FreeTokenString, GetToken, Handle],  Heap USING [systemZone],  String USING [AppendChar, AppendString, LowerCase, StringToDecimal],  DsyControl USING [    config, endStop, debugStop, execHandle, FatalError, flagNestedComments, noFinalFiles,    noFTfile, TtyLine2],  DsyFile USING [    aFlagSet, CreateLogFile, defsFilesCnt, defsFileNames, importsOnly,    maxNumFiles, outFile, passTwoOnly, siPrologLength, sourceFilesCnt,    sourceFileNames],  DsyModule;DsyCallLineImpl: PROGRAM  IMPORTS Exec, Heap, String, DsyControl, DsyFile   EXPORTS DsyModule =  BEGIN  ProcessCallLine: PUBLIC PROCEDURE[] =  --process the command line    BEGIN    commandLineError: BOOLEAN ¬ FALSE;    constructedString: LONG STRING ¬ [64];    execName, execSwitch: LONG STRING;    sourceFile: BOOLEAN;    CommandLineError: PROCEDURE [str: LONG STRING] =      BEGIN      commandLineError ¬ TRUE;      DsyControl.TtyLine2["Error in Command Line - "L, str];      END;  -- CommandLineError proc    DsyFile.defsFilesCnt ¬ 0;    DsyFile.sourceFilesCnt ¬ 0;    DO      [execName, execSwitch] ¬ Exec.GetToken[DsyControl.execHandle];      IF execName = NIL AND execSwitch = NIL THEN {        IF DsyFile.sourceFilesCnt = 0 THEN          CommandLineError["No sources files on command line "L];        EXIT};      sourceFile ¬ TRUE;      IF execSwitch # NIL THEN {        char: CHARACTER;        i: CARDINAL;        FOR i IN [0..execSwitch.length) DO          SELECT (char ¬ String.LowerCase[execSwitch[i]]) FROM            'a => DsyFile.aFlagSet ¬ TRUE;            'c => {              sourceFile ¬ FALSE;              DsyControl.config ¬ String.StringToDecimal[execName]};            'd => {              sourceFile ¬ FALSE;              IF execName # NIL THEN                IF DsyFile.defsFilesCnt IN [0..DsyFile.maxNumFiles) THEN {                  DsyFile.defsFileNames[DsyFile.defsFilesCnt] ¬ CopyString[                    execName, 4];                  String.AppendString[                    DsyFile.defsFileNames[DsyFile.defsFilesCnt], ".dfn"L];                  DsyFile.siPrologLength ¬                    DsyFile.siPrologLength +                      Environment.bytesPerWord*(SIZE[CARDINAL] + SIZE[                                                  LONG CARDINAL]) +                      DsyFile.defsFileNames[DsyFile.defsFilesCnt].length;                  DsyFile.defsFilesCnt ¬ DsyFile.defsFilesCnt + 1}                ELSE CommandLineError["Too many files on call line."L]              ELSE CommandLineError["d switch requires a file name."L]};            'e => DsyControl.endStop ¬ TRUE;	    'f => DsyControl.flagNestedComments ¬ TRUE;            'n => DsyControl.noFinalFiles ¬ TRUE;            'o => {              sourceFile ¬ FALSE;              IF execName # NIL THEN                IF DsyFile.outFile.length = 0 THEN {                  String.AppendString[DsyFile.outFile, execName];                  String.AppendString[DsyFile.outFile, ".xx"L]}                ELSE CommandLineError["Only one output file allowed."L]              ELSE CommandLineError["o switch requires a file name."L]};            's => DsyControl.debugStop ¬ TRUE;            't => DsyControl.noFTfile ¬ TRUE;            'x => DsyFile.importsOnly[DsyFile.sourceFilesCnt] ¬ TRUE;            'p => DsyFile.passTwoOnly[DsyFile.sourceFilesCnt] ¬ TRUE;            ENDCASE => {              constructedString.length ¬ 0;              String.AppendChar[constructedString, char];              String.AppendString[constructedString, " is not a valid switch."L];              CommandLineError[constructedString]};          ENDLOOP;        [] ¬ Exec.FreeTokenString[execSwitch]};      IF sourceFile THEN        IF execName # NIL THEN          IF DsyFile.sourceFilesCnt IN [0..DsyFile.maxNumFiles) THEN {            DsyFile.sourceFileNames[DsyFile.sourceFilesCnt] ¬ CopyString[	      execName, 3];            String.AppendString[              DsyFile.sourceFileNames[DsyFile.sourceFilesCnt], ".mc"L];            DsyFile.sourceFilesCnt ¬ DsyFile.sourceFilesCnt + 1}          ELSE CommandLineError["Too many files on call line."L]        ELSE          IF DsyFile.importsOnly[DsyFile.sourceFilesCnt]            OR DsyFile.passTwoOnly[DsyFile.sourceFilesCnt] THEN            CommandLineError["2 and x switches require a file name."L];      [] ¬ Exec.FreeTokenString[execName];      ENDLOOP;    IF DsyFile.outFile.length = 0 THEN       CommandLineError["No output file specified or missing /o."L];    IF commandLineError THEN DsyControl.FatalError;    DsyFile.CreateLogFile[];    END;  -- end ProcessCallLine  CopyString: PROCEDURE [old: LONG STRING, extra: CARDINAL] RETURNS [new: LONG STRING] =    BEGIN    new ¬ Heap.systemZone.NEW[StringBody[old.length + extra]];    String.AppendString[new, old];    END;  END...  --Log of last edits:--JAC   	 5-Nov-84 14:15:48	fixed arrows for Mesa 11.1
-- TestVectorIOImpl.mesa-- Created by jAC   CxC    28-Sep-84 17:16:01-- last edit by jAC   CxC      1-Oct-84  9:21:39-- Copyright (C) Xerox Corporation 1984. All rights reserved.DIRECTORY  Bindweed,  Environment USING[Byte],  Format,  Heap,  I186 USING [Address,Register],  Inline,  OMF,  Put,  TestVectorIO,  UserTerminal,  Window USING[Handle];TestVectorIOImpl: PROGRAM  IMPORTS Bindweed, Heap, Inline, OMF, Put, UserTerminal  EXPORTS TestVectorIO =  BEGIN    State: TYPE = {dead, booted, halted, running, iopBreak, singleStep};  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = MACHINE DEPENDENT RECORD [    msgSW(0): Window.Handle _ NIL,    formSW(2): Window.Handle _ NIL,    fileSW(4): Window.Handle _ NIL,    filename(6): LONG STRING _ NIL,    mode(8): CARDINAL _ 0,    vector(9): LONG STRING _ NIL];      z: UNCOUNTED ZONE _ NIL;  handle: OMF.Handle _ NIL;  data: DataHandle _ NIL;  registers: ARRAY [0..I186.Register.LAST.ORD] OF WORD _ ALL[0];  maxAddress: LONG CARDINAL = 0FFFFFH;  state: State _ dead;  seq: CARDINAL _ 0;  savedRegistersAddress: I186.Address = 0400H;    Error: PUBLIC ERROR [reason: LONG STRING] = CODE;    Boot: PUBLIC PROCEDURE = {       ENABLE UNWIND => NULL;    SetNewState[dead];    Bindweed.Boot[];    SetNewState[booted];    };    Continue: PUBLIC PROCEDURE =    BEGIN   ENABLE { UNWIND => NULL};    BeSureInKernel[];   Bindweed.Continue;   SetNewState[running];    END;    Load: PUBLIC PROCEDURE [log: LONG POINTER, filename: LONG STRING]=    {      ENABLE {UNWIND => handle _ OMF.ReleaseHandle[handle: handle];};  --  filename: LONG STRING _ "Vector.lm";      endOfInput: BOOLEAN _ FALSE;      recordType: OMF.RecordType _ null;      hexFormat: Format.NumberFormat = [base: 16];    -- DIFFICULT TO RECLAIM THE SPACE USED BY THIS PROC,    -- MAY BE EASIER TO DELETE HEAP ON EXIT    LoadPEData: PROCEDURE [      pEDataPtr: LONG POINTER TO OMF.PhysicalEnumeratedData] = {      <<      Put.Text[log, "Physical Enumerated Data\nAddress: "L];      Put.LongNumber[        log, LONG[pEDataPtr.frameNumber] * 16 + pEDataPtr.offset, hexFormat];      Put.Line[log, "\nData:"L];      FOR i: CARDINAL IN [0..pEDataPtr.dataPtr.length) DO        Put.Number[log, pEDataPtr.dataPtr[i], hexFormat];        Put.Blank[log, 1];        ENDLOOP;      Put.CR[log];      Put.CR[log];      >>           WriteMemoryDataSequence[address: LONG[pEDataPtr.frameNumber] * 16 + pEDataPtr.offset,	 data: pEDataPtr.dataPtr];            };    LoadStartAddress: PROCEDURE [modEndPtr: LONG POINTER TO OMF.ModuleEndData] = {      IF NOT modEndPtr.moduleType.hasStartAddress THEN RETURN;      WITH start: modEndPtr SELECT FROM        physicalAddr => {          	WriteRegister[reg: CS, data: start.frameNumber];	WriteRegister[reg: IP, data: Inline.LowHalf[start.offset]];	 <<          Put.Text[log, "StartAddress: "L];          Put.LongNumber[            log, LONG[start.frameNumber] * 16 + start.offset, hexFormat];          Put.CR[log];	  >>          };        ENDCASE => ERROR Error["Illegal Start address in object file"L];      };    LoadPIData: PROCEDURE [pIDataPtr: LONG POINTER TO OMF.PhysicalIteratedData] =      {      initialSize: NATURAL = 16;      totalData: LONG POINTER TO OMF.DataSequence _ z.NEW[        OMF .DataSequence[initialSize] _ [length: 0, seq: NULL]];      ProcessIteratedData: PROCEDURE [        iBlockPtr: LONG POINTER TO OMF.IteratedBlock] = {        iteratedBlockPtr: LONG POINTER TO OMF.IteratedBlock _ iBlockPtr;        THROUGH [1..iBlockPtr.repeatCount] DO          IF iBlockPtr.blockCount = 0 THEN AppendBlock[iBlockPtr.dataPtr]          ELSE ProcessIteratedData[iBlockPtr.next];          ENDLOOP;        };      AppendBlock: PROCEDURE [data: LONG POINTER TO OMF.DataSequence] = {        IF totalData.length + data.length < totalData.maxlength THEN {          FOR i: NATURAL IN [0..data.length) DO            totalData[totalData.length + i] _ data[i]; ENDLOOP;          totalData.length _ totalData.length + data.length}        ELSE {          tempData: LONG POINTER TO OMF.DataSequence _ z.NEW[            OMF .DataSequence[2 * (totalData.length + data.length)] _ [            length: 0, seq: NULL]];          FOR i: NATURAL IN [0..totalData.length) DO            tempData[i] _ totalData[i]; ENDLOOP;          FOR i: NATURAL IN [0..data.length) DO            tempData[totalData.length + i] _ data[i];            tempData.length _ totalData.length + data.length;            ENDLOOP;          z.FREE[@totalData];          totalData _ tempData;          }};      ProcessIteratedData[pIDataPtr.iteratedDataBlockPtr];      <<      Put.Text[log, "Physical Iterated Data\nAddress: "L];      Put.LongNumber[        log, LONG[pIDataPtr.frameNumber] * 16 + pIDataPtr.offset, hexFormat];      Put.Line[log, "\nData:"L];      FOR i: CARDINAL IN [0..totalData.length) DO        Put.Number[log, totalData[i], hexFormat];        Put.Blank[log, 1];        ENDLOOP;      Put.CR[log];      Put.CR[log];      >>            WriteMemoryDataSequence[address: LONG[pIDataPtr.frameNumber] * 16 + pIDataPtr.offset,	 data: totalData];	       };          IF z # NIL THEN {Heap.Delete[z]; z _ NIL;};    z _ Heap.Create[initial: 50, increment: 50];    Put.Text[log, "Loading "L];    Put.Text[log, "80186 from "L];    Put.Text[log, filename];    Put.Text[log, "..."L];        IF NOT InKernel[] THEN ERROR Error["Aborted...not in Kernel"L];    -- Be sure you have booted first or you won't have a symbol table    handle _ OMF.GetHandle[      operation: read, fileName: filename, extension: "lm"L, heap: z].handle;    UNTIL endOfInput DO      recordType _ OMF.GetRecordType[handle: handle];      SELECT recordType FROM        debugSymbol => NULL; -- ignore symbols        physicalEnumeratedData =>	  LoadPEData[pEDataPtr: OMF.GetPhysicalEnumeratedData[handle]];        physicalIteratedData =>	  LoadPIData[pIDataPtr: OMF.GetPhysicalIteratedData[handle]];	publicDefinition =>  NULL; -- ignore symbols        registerInitialization =>          --LoadRegInt[regIntPtr: OMF.GetRegisterInitialization[handle]];          Put.Line[            log, "register Initialization loading not implemented."L];        moduleEnd => LoadStartAddress[modEndPtr: OMF.GetModuleEnd[handle]];        ENDCASE => NULL;      endOfInput _ OMF.AdvanceToNextRecord[handle: handle];      ENDLOOP;    handle _ OMF.ReleaseHandle[handle: handle];    IF z # NIL THEN {Heap.Delete[z]; z _ NIL;};    -- ICEAddressMap.Sort;  sort address map and do Xreffing with symbol table    Put.Line[log, "Done."L];    };      ReadMemoryDataSequence: PUBLIC PROCEDURE [    address: I186.Address, data: LONG POINTER TO Bindweed.Sequence] = {    ENABLE UNWIND => NULL;    start, length: NATURAL _ 0;    IF address > maxAddress THEN {UserTerminal.BlinkDisplay[]; RETURN;};    Bindweed.ReadMemoryBlock[      address: address, addressType: iOPLogical, sequence: data];    };  ReadMemoryByte: PUBLIC PROCEDURE [address: I186.Address]    RETURNS [data: Environment.Byte _ 0] =    BEGIN    ENABLE UNWIND => NULL;        dataSequencePtr: LONG POINTER TO Bindweed.Sequence _ Heap.systemZone.NEW[      Bindweed .Sequence[1] _ [length: 1, seq: NULL]];    IF address > maxAddress THEN {UserTerminal.BlinkDisplay[]; RETURN;};    BeSureInKernel[];    Bindweed.ReadMemoryBlock[      address: address, addressType: iOPLogical, sequence: dataSequencePtr];    data _ dataSequencePtr[0];    Heap.systemZone.FREE[@dataSequencePtr];    END;  ReadMemoryWord: PUBLIC  PROCEDURE [address: I186.Address]    RETURNS [data: WORD _ 0] =    BEGIN    ENABLE UNWIND => NULL;        dataSequencePtr: LONG POINTER TO Bindweed.Sequence _ Heap.systemZone.NEW[      Bindweed .Sequence[2] _ [length: 2, seq: NULL]];    IF address > maxAddress THEN {UserTerminal.BlinkDisplay[]; RETURN;};    BeSureInKernel[];    Bindweed.ReadMemoryBlock[      address: address, addressType: iOPLogical, sequence: dataSequencePtr];    data _ dataSequencePtr[0] + 256 * dataSequencePtr[1];    Heap.systemZone.FREE[@dataSequencePtr];    END;      ReadSavedRegisters: PUBLIC PROCEDURE = {    ENABLE UNWIND => NULL;    registerSeq: LONG POINTER TO Bindweed.Sequence _ Heap.systemZone.NEW[      Bindweed .Sequence[2 * (I186.Register.LAST.ORD + 1)] _ [      length: 2 * (I186.Register.LAST.ORD + 1), seq: NULL]];    Bindweed.ReadMemoryBlock[      address: savedRegistersAddress, addressType: iOPLogical,      sequence: registerSeq];    FOR i: CARDINAL IN [0..I186.Register.LAST.ORD] DO      registers[i] _ registerSeq[2 * i] + (registerSeq[2 * i + 1] * 256); ENDLOOP;    Heap.systemZone.FREE[@registerSeq];    };  SetNewState: PROCEDURE [newState: State] =    BEGIN state _ newState; seq _ seq + 1; END;  Stop: PUBLIC PROCEDURE = {    ENABLE UNWIND => NULL;    SELECT state FROM      dead => ERROR Error["80186 is dead"L];      booted, halted, iopBreak, singleStep =>        ERROR Error["Can't Stop unless Running"L];      running, dead => NULL;      ENDCASE => ERROR;    Bindweed.StopIOP;     SetNewState[halted]};      WriteMemoryByte: PUBLIC PROCEDURE [    address: I186.Address, data: Environment.Byte] =    BEGIN    ENABLE UNWIND => NULL;    dataPtr: LONG POINTER TO Bindweed.Sequence _ Heap.systemZone.NEW[      Bindweed .Sequence[1] _ [length: 1, seq: NULL]];    IF address > maxAddress THEN {UserTerminal.BlinkDisplay[]; RETURN;};    BeSureInKernel[];    dataPtr[0] _ data;    Bindweed.WriteMemoryBlock[      address: address, addressType: iOPLogical, sequence: dataPtr];    Heap.systemZone.FREE[@dataPtr];    END;  WriteMemoryWord: PUBLIC PROCEDURE [address: I186.Address, data: WORD] =    BEGIN    ENABLE UNWIND => NULL;    dataPtr: LONG POINTER TO Bindweed.Sequence _ Heap.systemZone.NEW[      Bindweed .Sequence[2] _ [length: 2, seq: NULL]];    IF address > maxAddress THEN {UserTerminal.BlinkDisplay[]; RETURN;};    BeSureInKernel[];    dataPtr[0] _ data MOD 256;    dataPtr[1] _ data / 256;    Bindweed.WriteMemoryBlock[      address: address, addressType: iOPLogical, sequence: dataPtr];    Heap.systemZone.FREE[@dataPtr];    END;      WriteMemoryDataSequence: PUBLIC PROCEDURE [    address: I186.Address, data: LONG POINTER TO Bindweed.Sequence] = {    ENABLE UNWIND => NULL;     start, length: NATURAL _ 0;        IF address > maxAddress THEN {UserTerminal.BlinkDisplay[]; RETURN;};    Bindweed.WriteMemoryBlock[      address: address, addressType: iOPLogical, sequence: data];    };      WriteRegister: PUBLIC PROCEDURE [reg: I186.Register, data: WORD] = {    ENABLE UNWIND => NULL; BeSureInKernel[]; registers[ORD[reg]] _ data; };  WriteSavedRegisters: PUBLIC PROCEDURE = {    ENABLE UNWIND => NULL;    registerSeq: LONG POINTER TO Bindweed.Sequence _ Heap.systemZone.NEW[      Bindweed .Sequence[2 * (I186.Register.LAST.ORD + 1)] _ [      length: 2 * (I186.Register.LAST.ORD + 1), seq: NULL]];    FOR i: CARDINAL IN [0..I186.Register.LAST.ORD] DO      registerSeq[2 * i] _ registers[i] MOD 256;      registerSeq[2 * i + 1] _ registers[i] / 256;      ENDLOOP;    Bindweed.WriteMemoryBlock[      address: savedRegistersAddress, addressType: iOPLogical,      sequence: registerSeq];    Heap.systemZone.FREE[@registerSeq];    };  InKernel: PROCEDURE RETURNS [BOOLEAN] =    BEGIN    ENABLE UNWIND => NULL;    RETURN[      SELECT state FROM        dead, running => FALSE,        booted, halted, singleStep, iopBreak => TRUE,        ENDCASE => ERROR];    END;  BeSureInKernel: PROCEDURE =    BEGIN    SELECT state FROM      dead => ERROR Error["80186 is dead"L];      booted, halted, singleStep => NULL;      running => ERROR Error["80186 is running"L];      iopBreak => NULL;      ENDCASE => NULL; -- ERROR;    END;  END.
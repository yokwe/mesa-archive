-- Copyright (C) 1984, 1985 by Xerox Corporation. All rights reserved. -- HBIO.mesa-- Written by FS  on   8-Nov-84 13:46:16-- Last edited by --  RDH	16-May-85 18:16:45 Make HBDisplay public.--  RDH	22-Apr-85 13:34:31 Add capability to do symbolic I/O on the IOP side.--  RDH	15-Mar-85 14:24:54 Add CopyBuffer, I186Idle, and RunningOpie.--  RDH	14-Mar-85 11:25:22 Add variables for slow reading and BadCheckSum recovery.--  RDH	25-Feb-85 12:01:44 Change display procs.--  RDH	22-Feb-85 10:36:21 Remove some HW details to HBAction.--  RDH	 5-Feb-85 12:15:30 Add time stamping.--  RDH	 1-Feb-85 14:03:10 Fix arrangement of CSSample.--  RDH	31-Jan-85 11:41:51 Add parameter for new boolean item.--  RDH	23-Jan-85 16:58:27 Add data structures and signal.--  RDH	21-Jan-85 17:19:18 Introduce names for IO locations.--  RDH	15-Jan-85 16:42:17 Run FixArrows.DIRECTORY  CPDef,  FormSW,  HBAction,  Window;  HBIO: DEFINITIONS =  BEGIN      HWBankSelect: TYPE = [0..16); -- 4 active low bits, each selects a bank. --  NoBank: HWBankSelect = 0FH;  BankNumber: TYPE = [0..CPDef.numberOfBanks);	-- [0..4) --  WordInCSBank: TYPE = [0..CPDef.wordsPerBank);  IOData: TYPE = WORD;  IOPBusAddrLo: TYPE = CARDINAL;  IOPBusAddrHi: TYPE = [0..0FFH];  I186Status: TYPE = [0..7];  BusArb: TYPE = [0..3FFH];  WaitCycles: TYPE = [0..0FH];  CSWildCardNibble: TYPE = [0..0FH];  CSWildCard: TYPE = MACHINE DEPENDENT RECORD[    wild0(0:0..3): CSWildCardNibble,    wild1(0:4..7): CSWildCardNibble,    wild2(0:8..11):  CSWildCardNibble,    wild3(0:12..15): CSWildCardNibble];  IOPWildLo: TYPE = [0..1FH];  IOPWildHi: TYPE = [0..3];       CSSample: TYPE = MACHINE DEPENDENT RECORD [    dummy(0:0..31): SELECT OVERLAID * FROM      fields => [        wildcard(0:0..15): HBIO.CSWildCard,        banksel(1:0..3): HBIO.HWBankSelect,        nia(1:4..15): HBIO.WordInCSBank],      words => [        word0(0:0..15): WORD,	word1(1:0..15): WORD],      ENDCASE    ];      IOPSample: TYPE = MACHINE DEPENDENT RECORD [    dummy(0:0..63): SELECT OVERLAID * FROM      fields => [        wildlo(0:0..4): IOPWildLo,	status(0:5..7): I186Status, 	addrhi(0:8..15): IOPBusAddrHi,	addrlo(1:0..15): IOPBusAddrLo,	arbt(2:0..9): BusArb,	wildhi(2:10..11): IOPWildHi,	nwait(2:12..15): WaitCycles,	iodata(3): IOData],      words => [        word0(0:0..15): WORD,	word1(1:0..15): WORD,        word2(2:0..15): WORD,	word3(3:0..15): WORD],      ENDCASE    ];      CSTrigMaskInfo: TYPE = MACHINE DEPENDENT RECORD [    banksel(0:0..3): HBIO.HWBankSelect,    nia(0:4..15): HBIO.WordInCSBank,    wildcard(1:0..15): HBIO.CSWildCard];      --Time and Trigger Info  TimeAndTrigger: TYPE = RECORD[    time: LONG STRING ¬ NIL,    delay: LONG STRING ¬ NIL,    targetSpecificData: SELECT target: HBAction.TargetDevice FROM      cs => [csStuff: SELECT useSymb: BOOLEAN FROM        TRUE => [nia, wildCards: LONG STRING ¬ NIL],	FALSE => [nia, bankSel, wildCards: LONG STRING ¬ NIL],	ENDCASE],      iop => [addr, data, arbiter, i186state, wildCards, nWaits:         LONG STRING ¬ NIL],      ENDCASE ¬ iop[NIL,NIL,NIL,NIL,NIL,NIL]];    FreeTimeStamp: PROC[z: UNCOUNTED ZONE,     timeStamp: LONG POINTER TO TimeAndTrigger];  SwitchHandle: TYPE = LONG POINTER TO Switches;  Switches: TYPE = MACHINE DEPENDENT RECORD [    iopAddrParam(0): UNSPECIFIED ¬ 1,    iStParam(1): UNSPECIFIED ¬ 1,    arbParam(2): UNSPECIFIED ¬ 1,    iOPDataParam(3): UNSPECIFIED ¬ 1,    nWaitParam(4): UNSPECIFIED ¬ 1,    iOPWCParam(5): UNSPECIFIED ¬ 1,    cSNIAParam(6): UNSPECIFIED ¬ 1,    bSParam(7): UNSPECIFIED ¬ 1,    cSWCParam(8): UNSPECIFIED ¬ 0,    iOPAddrDisp(9): UNSPECIFIED ¬ 1,    iOPStDisp(10): UNSPECIFIED ¬ 1,    arbDisp(11): UNSPECIFIED ¬ 1,    iOPDataDisp(12): UNSPECIFIED ¬ 1,    nWaitDisp(13): UNSPECIFIED ¬ 1,    iOPWCDisp(14): UNSPECIFIED ¬ 1,    cSNIADisp(15): UNSPECIFIED ¬ 1,    bSDisp(16): UNSPECIFIED ¬ 1,    cSWCDisp(17): UNSPECIFIED ¬ 1,    fileName(18): LONG STRING ¬ NIL];  -- from HBCommandImpl  globSW: SwitchHandle;  sbWorking: BOOLEAN;  ErrMessage: PROC[message: LONG STRING];  Aborted: PROC[] RETURNS[BOOLEAN];  NotifyUserOfStateChange: PROC[newState: HBAction.HBState];  HBDisplay: FormSW.ProcType;  -- Routines from HBOption  OpenOpWindow: PROCEDURE;  OptionInit: PROCEDURE;  OptionFree: PROCEDURE;  OptionNew: PROCEDURE;-- Routines from HBDisplay  DoDisplay: PROCEDURE[display, heading: Window.Handle, low, high: INTEGER,    target: HBAction.TargetDevice];  DisplayIOPSample: PROCEDURE [      Window.Handle, Window.Handle, INTEGER, INTEGER] RETURNS [CARDINAL];  DisplayCSSample: PROCEDURE [      Window.Handle, Window.Handle, INTEGER, INTEGER] RETURNS [CARDINAL];-- Routines from HBSampleImpl  CopyBuffer: PROCEDURE[dest: LONG POINTER TO HBAction.SWBuffer];  I186Idle: PROC RETURNS [idle: BOOLEAN];  RunningOpie: PROC RETURNS [BOOLEAN];  SampleIOP: PROCEDURE [    Window.Handle, LONG STRING, LONG STRING, LONG STRING, LONG STRING,LONG STRING,    LONG STRING, LONG STRING, BOOLEAN];  SampleCS: PROCEDURE [    Window.Handle,  LONG STRING, LONG STRING, LONG STRING, LONG STRING, BOOLEAN];  HBErr: SIGNAL[errNo: HBErrNumber];    HBErrNumber: TYPE = {otherErr, userAbort, RealCSToHWBankAndWordInBankErrNo};    --Data Objects    displayBuffer: LONG POINTER TO HBAction.SWBuffer; --Pointer to the place to which Sample copies the data from the history buffer after sampling is complete and from which Display reads the data.    runningOpie: BOOLEAN; --Parrots the boolean in the command form subwindow.  If true the user should be running something in the 186 which includes process control enough to handle a Bindweed call.  This is used to check if its ok to poll the history buffer.    somethingInSWBuffer: BOOLEAN; --True if there is meaningful data in the software copy of the buffer.  False until the history buffer triggers and the buffer is read into memory.    --This variable is set by HBSampleImpl whenever a Sample command is successfully executed and is read by HBDisplayImpl whenever a Display command is successfully executed.    timeAndTrig: TimeAndTrigger;    triggeredBut: BOOLEAN; --True if the history buffer has triggerred and timed out but there was a bad check sum during a call to Bindweed.ReadHistoryBuffer.  This is presumed to be because the IOP is using ROM instead of RAM.  This means that either the user must run remheads.lm in Bindweed or slow reading must be used to read the history buffer.  It primarily flags that the display buffer has not been updated to show the results of the latest trigger.    lowestCorrect: INTEGER; --[-8192..1]--  highestCorrect: INTEGER; --[-1..8192]--  -- These are used for slow reading of the history buffer.  They indicate the lowest and the highest samples that have been copied into the display buffer.    END.
-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. -- The purpose of this module is to fill in Encoding records from patterns.  If a pattern cannot be encoded due to a field conflict or bus conflict, an error message will be chained to phrase.tempErrorMsgs.  If an alternate pattern can be encoded, the error messages will be deleted; otherwise they will be chained onto phrase.errorMsgs by the Encode module. --Last edit by JAC           19-Dec-84 11:41:33      DIRECTORY  DsyAssembler,  DsyuFormat USING [Op2rA],  Inline USING [BITNOT, BITXOR],  String USING [EqualString];DsyEncodePatternImpl: PROGRAM  IMPORTS DsyAssembler, Inline, String EXPORTS DsyAssembler =  BEGIN OPEN DsyAssembler;  -- GLOBAL VARIABLES;  initialEncoding: Encoding ¬ [];  -- SIGNALS AND ERRORS GENERATED  EncodePatternError: ERROR [    {    opInvalid, rAInvalid, rBInvalid, rDInvalid, aluInvalid, ciInvalid, sp2Invalid,    sp1Invalid, dspBInvalid, shiftInvalid, ibInvalid, itInvalid, aAdrInvalid,    omInvalid, moInvalid, ailInvalid, aiuInvalid, cycleInvalid}] = CODE;  AllocateEncodingRecord: PUBLIC PROCEDURE RETURNS [encoding: EncodingPtr] =    BEGIN OPEN encoding;    -- Allocate and initialize Encoding record.     encoding ¬ GetStmtSpace[SIZE[Encoding]];    encoding­ ¬ initialEncoding;    RETURN;    END;  -- end AllocateEncodingRecord        EncodePattern: PUBLIC PROCEDURE [    phrase: PhrasePtr, pattern: PatternPtr, encoding: EncodingPtr,    assignment: Assignment] RETURNS [successful: BOOLEAN] =    BEGIN    -- Given a pointer to a pattern, a pointer to an Encoding record, and two arguments, fill in the Encoding record. The Assignment indicates what the field is being assigned to: a macro, an expression, or a register assignment.  This is used to print an error message in case of a conflict.    addressConstant: AddressConstant;    constant: ImmediateData;    fa: FieldAssignment;    high: BOOLEAN ¬ FALSE;    rAField: DsyuFormat.Op2rA;    savedEncoding: Encoding;    text: LONG STRING;    trialPattern: Pattern ¬ pattern­;    value: CARDINAL;        ConstantValid: PROCEDURE RETURNS [valid: BOOLEAN] =      BEGIN            SELECT phrase.expression.operation FROM        aPlusB, xPlusCI => 	  IF phrase.arg2.arg IN [0..127] THEN valid ¬ TRUE	  ELSE valid ¬ FALSE;	minus =>	  IF phrase.arg2.arg IN [0..128] THEN valid ¬ TRUE	  ELSE valid ¬ FALSE; 	ENDCASE => {SyntaxError[phrase, invalidExpression]; valid ¬ FALSE};      END;  --of procedure ConstantValid    Field: PROCEDURE = INLINE      BEGIN      IF fa.assignment.type # null THEN        IF fa.value # value THEN          BEGIN          FormatError[phrase, assignment, fa.assignment, text];          successful ¬ FALSE;          END;      END;  -- end Field    FindrAValue: PROCEDURE [argument: ArgumentType] RETURNS [value: CARDINAL] =      --given an argument record consisting of the type of operand and the register number if appropriate, this procedure returns the value to be placed in the encoded rA field      BEGIN      value ¬ rAZero;      SELECT argument.regType FROM        D => value ¬ argument.arg;        zero => value ¬ rAZero;        chipVersion => value ¬ rAChipVersion;        CSBank => value ¬ rACSBank;        stkPtr => value ¬ rAStkPtr;        stkMinus2 => value ¬ rAStkRef + rAStkM2Offset;        stkMinus1 => value ¬ rAStkRef + rAStkM1Offset;        stkZero => value ¬ rAStkRef + rAStk0Offset;        stkPlus1 => value ¬ rAStkRef + rAStkP1Offset;        aUpper16 => value ¬ rAAUpper16 + argument.arg;        aLower16 => value ¬ rAALower16 + argument.arg;        CIP => value ¬ rACIP;        ibCtr => value ¬ rAIBCtr;        timerHigh => value ¬ rATimerHigh;        timerLow => value ¬ rATimerLow;        prescaler => value ¬ rAPrescaler;        A => {SyntaxError[phrase, invalidOperand]; successful ¬ FALSE};        aUpper16 => {SyntaxError[phrase, invalidOperand]; successful ¬ FALSE};        ENDCASE => {SyntaxError[phrase, invalidOperand]; successful ¬ FALSE};      END;  --of procedure FindrAValue    FindrBValue: PROCEDURE [argument: ArgumentType]      RETURNS [value: CARDINAL ¬ rBZero] =      --given an argument record consisting of the type of operand and the register number if appropriate, this procedure returns the value to be placed in the encoded rB field      BEGIN      value ¬        SELECT argument.regType FROM          zero => rBZero,          Q => rBQ,          ib => rBIB,          ibSE => rBIBSE,          R => argument.arg,          ENDCASE => ERROR EncodePatternError[rBInvalid];      END;  --of procedure FindrBValue    IF encoding = NIL THEN RETURN[FALSE];    savedEncoding ¬ encoding­;    successful ¬ TRUE;  -- Assume this is going to work.    IF trialPattern.op # x THEN      BEGIN      value ¬        SELECT trialPattern.op FROM          zero => 0,          one => 1,          two => 2,          three => 3,          ENDCASE => ERROR EncodePatternError[opInvalid];      fa ¬ encoding.op;      text ¬ "op"L;      Field[];      encoding.op ¬ FieldAssignment[assignment, value];      END;    IF trialPattern.rA # x THEN      BEGIN      value ¬ rAZero;      SELECT trialPattern.rA FROM        arg1 => value ¬ FindrAValue[phrase.arg1];        arg2 => value ¬ FindrAValue[phrase.arg2];        ENDCASE => ERROR EncodePatternError[rAInvalid];      fa ¬ encoding.rA;      text ¬ "rA"L;      Field[];      encoding.rA ¬ FieldAssignment[assignment, value];      END;    IF trialPattern.rB # x THEN      BEGIN      value ¬        SELECT trialPattern.rB FROM          arg1 => FindrBValue[phrase.arg1],          arg2 => FindrBValue[phrase.arg2],          ENDCASE => ERROR EncodePatternError[rBInvalid];      fa ¬ encoding.rB;      text ¬ "rB"L;      Field[];      encoding.rB ¬ FieldAssignment[assignment, value];      END;    IF trialPattern.rD # noop THEN      BEGIN      value ¬        SELECT trialPattern.rD FROM          dFile => phrase.dest,          csBank => rDCSBank,          stkPtr => rDStkPtr,          stkMinus2 => rDStkMinus2,          stkMinus1 => rDStkMinus1,          stkZero => rDStkZero,          stkPlus1 => rDStkPlus1,          sameAsrB => rDSameAsrB,          CIP => rDCIP,          Q => rDQ,          aUpper8 => rDAUpper8 + phrase.dest,          aUpper16 => rDAUpper16 + phrase.dest,          aLower16 => rDALower16 + phrase.dest,          timerHigh => rDTimerHigh,          timerLow => rDTimerLow,          prescaler => rDPrescaler,          ENDCASE => ERROR EncodePatternError[rDInvalid];      fa ¬ encoding.rD;      text ¬ "rD"L;      Field[];      encoding.rD ¬ FieldAssignment[assignment, value];      END;    IF trialPattern.alu # x THEN      BEGIN      SELECT TRUE FROM        phrase.arg1.negate =>          IF trialPattern.alu # aAndB THEN {            SyntaxError[phrase, invalidExpression]; successful ¬ FALSE}          ELSE            SELECT phrase.arg1.regType FROM              IN [A..ibCtr] => trialPattern.alu ¬ naAndB;              IN [Q..ibSE] => trialPattern.alu ¬ aAndNB;              zero =>                IF phrase.arg2.regType IN [A..ibCtr] THEN trialPattern.alu ¬ aAndNB                ELSE trialPattern.alu ¬ naAndB;              ENDCASE;        phrase.arg2.negate =>          IF trialPattern.alu # aAndB THEN {            SyntaxError[phrase, invalidExpression]; successful ¬ FALSE}          ELSE            SELECT phrase.arg2.regType FROM              IN [A..ibCtr] => trialPattern.alu ¬ naAndB;              IN [Q..ibSE] => trialPattern.alu ¬ aAndNB;              zero =>                IF phrase.arg1.regType IN [A..ibCtr] THEN trialPattern.alu ¬ aAndNB                ELSE trialPattern.alu ¬ naAndB;              ENDCASE;        ENDCASE;      value ¬        SELECT trialPattern.alu FROM          aPlusB => aluAPlusB,          aMinusB => aluAinusB,          bMinusA => aluBMinusA,          aAndB => aluAAndB,          aOrB => aluAOrB,          aXorB => aluAXorB,          aPlusCI => aluAPlusCI,          bPlusCI => aluBPlusCI,          aAndNB => aluAAndNB,          aNandB => aluANAndB,          aNorB => aluANOrB,          aNxorB => aluANXorB,          mpy => aluMPY,          naAndB => aluNAAndB,          ENDCASE => ERROR EncodePatternError[aluInvalid];      fa ¬ encoding.alu;      text ¬ "alu"L;      Field[];      encoding.alu ¬ FieldAssignment[assignment, value];      END;    IF trialPattern.ci # x THEN      BEGIN      IF encoding.op.value # 2 THEN {        value ¬          SELECT trialPattern.ci FROM            one => 1,            zero => 0,            ENDCASE => ERROR EncodePatternError[ciInvalid];        fa ¬ encoding.ci;        text ¬ "ci"L;        Field[];        encoding.ci ¬ FieldAssignment[assignment, value]};      END;    IF trialPattern.sp2 # noop THEN      BEGIN      value ¬        SELECT trialPattern.sp2 FROM          eopTrapRq => sp2EOPTrapRq,          clrMInt => sp2ClrMInt,          popIB => sp2PopIB,          uSource => sp2USource,          vSource => sp2VSource,          ENDCASE => ERROR EncodePatternError[sp2Invalid];      fa ¬ encoding.sp2;      text ¬ "sp2"L;      Field[];      encoding.sp2 ¬ FieldAssignment[assignment, value];      END;    IF trialPattern.sp1 # noop THEN      BEGIN      value ¬        SELECT trialPattern.sp1 FROM          assignQ => sp1AssignQ,          incCIP => sp1IncCIP,          dincCIP => sp1DIncCIP,          link0 => sp1Link0,          link1 => sp1Link1,          link2 => sp1Link2,          link3 => sp1Link3,          ENDCASE => ERROR EncodePatternError[sp1Invalid];      fa ¬ encoding.sp1;      text ¬ "sp1"L;      Field[];      encoding.sp1 ¬ FieldAssignment[assignment, value];      END;    IF trialPattern.dspB # noop THEN      BEGIN      value ¬        SELECT trialPattern.dspB FROM          L0Disp => dspBL0Disp,          L1Disp => dspBL1Disp,          L2Disp => dspBL2Disp,          L3Disp => dspBL3Disp,          aDisp => dspBADisp,          aluDisp => dspBALUDisp,          pcDisp => dspBPCDisp,          zeroBr => dspBZeroBr,          bDisp => dspBBDisp,          rDisp => dspBRDisp,          mintDisp => dspBMIntDisp,          aHighDisp => dspBAHighDisp,          readOKBr => dspBReadOKBr,          writeOKBr => dspBWriteOKBr,          ibDisp => dspBIBDisp,          alwaysIBDisp => dspBAlwaysIBDisp,          ENDCASE => ERROR EncodePatternError[dspBInvalid];      fa ¬ encoding.dspB;      text ¬ "dspB"L;      Field[];      encoding.dspB ¬ FieldAssignment[assignment, value];      END;    IF trialPattern.shift # x THEN      BEGIN      value ¬        SELECT trialPattern.shift FROM          value => phrase.arg3          ENDCASE => ERROR EncodePatternError[shiftInvalid];      fa ¬ encoding.shift;      text ¬ "shift"L;      Field[];      encoding.shift ¬ FieldAssignment[assignment, value];      END;    IF trialPattern.ib # noop THEN      BEGIN      fa ¬ encoding.ib;      text ¬ "ib"L;      value ¬        SELECT trialPattern.ib FROM          uReg => ibUReg,          vReg => ibVReg,          clear => ibClrIB,          pop => ibPopIB,          assigned => ibNoop,          ENDCASE => ERROR EncodePatternError[ibInvalid];      Field[];      encoding.ib ¬ FieldAssignment[assignment, value];      END;    IF trialPattern.it # x THEN      BEGIN      value ¬        SELECT trialPattern.it FROM          t => 1,          f => 0,          ENDCASE => ERROR EncodePatternError[itInvalid];      fa ¬ encoding.it;      text ¬ "it"L;      Field[];      encoding.it ¬ FieldAssignment[assignment, value];      END;    IF trialPattern.aAdr # x THEN  --aAdr must appear before mo in  this procedure      BEGIN      fa ¬ encoding.aAdr;      IF encoding.mo.assignment.type # null THEN {  --MAR¬ or MAP¬ encoded previously        value ¬          SELECT trialPattern.aAdr FROM            value =>              IF phrase.expression.operand1 = aBus THEN phrase.arg1.arg              ELSE                IF phrase.expression.operand2 = aBus THEN phrase.arg2.arg                ELSE ERROR EncodePatternError[aAdrInvalid],            ENDCASE => ERROR EncodePatternError[aAdrInvalid]}      ELSE {  --MDR¬ or ABus¬ or use OffsetAdder        IF phrase.arg1.regType = zero THEN rAField.word ¬ phrase.arg2.arg        ELSE rAField.word ¬ phrase.arg1.arg;        value ¬ rAField.aAdr;        IF phrase.dest = 0FFFFH AND NOT offsetAdder THEN {  --not using OffsetAdder          trialPattern.aiu ¬ x;          trialPattern.ail ¬ x;          trialPattern.ac ¬ x;          trialPattern.om ¬ x;          trialPattern.mo ¬ noop;          IF phrase.arg1.regType = zero THEN            rAField.word ¬ FindrAValue[phrase.arg2]          ELSE rAField.word ¬ FindrAValue[phrase.arg1];          IF rAField.word > 7 THEN {            SyntaxError[phrase, invalidOperand]; successful ¬ FALSE}          ELSE value ¬ rAField.aAdr}};      fa ¬ encoding.aAdr;      text ¬ "aAdr"L;      Field[];      encoding.aAdr ¬ FieldAssignment[assignment, value];      END;    IF trialPattern.om # x THEN      BEGIN      fa ¬ encoding.om;      value ¬ moNoop;      SELECT phrase.expression.operand1 FROM        aBus =>          SELECT phrase.expression.operand2 FROM            bBus =>              SELECT phrase.arg2.regType FROM                ib => value ¬ omIBByte;                zero => value ¬ omImmed;                ENDCASE => {                  SyntaxError[phrase, invalidSecondOperand]; successful ¬ FALSE};            aBus => {              SyntaxError[phrase, invalidSecondOperand]; successful ¬ FALSE};            zero =>              IF phrase.arg3 = 0 THEN value ¬ omImmed              ELSE                IF phrase.arg3 < macroTableSize THEN                  IF String.EqualString[macroTable[phrase.arg3].macro, "ib.high"L]                    THEN value ¬ omIBUpperNib                  ELSE                    IF String.EqualString[macroTable[phrase.arg3].macro, "ib.low"L]                      THEN value ¬ omIBLowerNib                    ELSE                      IF phrase.arg3 IN [linkSize..macroArrowSize) THEN                        value ¬ omImmed                      ELSE {                        SyntaxError[phrase, invalidSecondOperand];                        successful ¬ FALSE}                ELSE {                  SyntaxError[phrase, invalidSecondOperand]; successful ¬ FALSE};            ENDCASE => ERROR EncodePatternError[omInvalid];        bBus =>          SELECT phrase.arg1.regType FROM            ib => value ¬ omIBByte;            zero => value ¬ omImmed;            ENDCASE => {SyntaxError[phrase, invalidOperand]; successful ¬ FALSE};        zero =>          IF phrase.arg3 = 0 THEN value ¬ omImmed          ELSE            IF phrase.arg3 < macroTableSize THEN              IF String.EqualString[macroTable[phrase.arg3].macro, "ib.high"L] THEN                value ¬ omIBUpperNib              ELSE                IF String.EqualString[macroTable[phrase.arg3].macro, "ib.low"L]                  THEN value ¬ omIBLowerNib                ELSE {                  SyntaxError[phrase, invalidSecondOperand]; successful ¬ FALSE}            ELSE {SyntaxError[phrase, invalidSecondOperand]; successful ¬ FALSE};        ENDCASE => ERROR EncodePatternError[omInvalid];      text ¬ "om"L;      Field[];      encoding.om ¬ FieldAssignment[assignment, value];      END;    IF trialPattern.mo # noop THEN      BEGIN      IF encoding.mo.assignment.type = null THEN {  --MAR¬ or MAP¬ not encoded previously        IF encoding.aAdr.assignment.type = null THEN  --encode MAR¬ or MAP¬  or Read, Write, etc.          value ¬            SELECT trialPattern.mo FROM              A => moA,              U => moU,              read => moRead,              doubleRead => moDoubleRead,              write => moWrite,              doubleWrite => moDoubleWrite,              map => moMap,              ENDCASE => ERROR EncodePatternError[moInvalid]        ELSE  --MDR¬ or ABus¬          value ¬ rAField.mo;        fa ¬ encoding.mo;        text ¬ "mo"L;        Field[];        encoding.mo ¬ FieldAssignment[assignment, value]};      END;    IF trialPattern.aiu # x THEN      BEGIN      IF (encoding.om.value # omImmed) AND (phrase.expression.operation # aPlusB)        THEN {SyntaxError[phrase, invalidOperand]; successful ¬ FALSE};      addressConstant.word ¬ Inline.BITNOT[0];      SELECT phrase.expression.operand1 FROM        aBus =>          SELECT phrase.expression.operand2 FROM            aBus => addressConstant.word ¬ Inline.BITNOT[0];            bBus =>              IF NOT ConstantValid[] THEN {                SyntaxError[phrase, invalidOperand]; successful ¬ FALSE}              ELSE                IF phrase.expression.operation IN [aPlusB..xPlusCI] THEN                  addressConstant.word ¬ Inline.BITNOT[phrase.arg2.arg]                ELSE                  IF phrase.expression.operation = minus THEN                    addressConstant.word ¬ Inline.BITNOT[-phrase.arg2.arg]                  ELSE {SyntaxError[phrase, invalidOperand]; successful ¬ FALSE};            zero =>              SELECT phrase.expression.operation FROM                xPlusCI =>                  BEGIN                  addressConstant.word ¬ Inline.BITNOT[0 + FindCarry[phrase]];                  phrase.expression.carry ¬ zero;                  END;                minus =>                  BEGIN                  addressConstant.word ¬ Inline.BITNOT[0 - FindCarry[phrase]];                  phrase.expression.carry ¬ one;                  END;                ENDCASE => addressConstant.word ¬ Inline.BITNOT[0];            ENDCASE => addressConstant.word ¬ Inline.BITNOT[0];        bBus =>          IF phrase.arg1.arg NOT IN [0..128] THEN {            SyntaxError[phrase, invalidOperand]; successful ¬ FALSE}          ELSE            IF phrase.expression.operation IN [aPlusB..xPlusCI] THEN              addressConstant.word ¬ Inline.BITNOT[phrase.arg1.arg]            ELSE              IF phrase.expression.operation = minus THEN                addressConstant.word ¬ Inline.BITNOT[-phrase.arg1.arg]              ELSE {SyntaxError[phrase, invalidOperand]; successful ¬ FALSE};        zero => addressConstant.word ¬ Inline.BITNOT[0];        ENDCASE => ERROR EncodePatternError[aiuInvalid];      value ¬ addressConstant.aiu;      fa ¬ encoding.aiu;      text ¬ "aiu"L;      Field[];      encoding.aiu ¬ FieldAssignment[assignment, value];      END;    IF trialPattern.ail # x THEN      BEGIN      value ¬ addressConstant.ail;      fa ¬ encoding.ail;      text ¬ "ail"L;      Field[];      encoding.ail ¬ FieldAssignment[assignment, value];      END;    IF trialPattern.ac # x THEN      BEGIN      IF encoding.om.value # omImmed THEN        value ¬ Inline.BITXOR[1, FindCarry[phrase]]  --complement for encoding      ELSE        SELECT phrase.expression.operation FROM          IN [aPlusB..xPlusCI] =>            IF phrase.expression.carry = one THEN {              SyntaxError[phrase, invalidExpression];              successful ¬ FALSE;              value ¬ 0}            ELSE value ¬ addressConstant.ac;          minus =>            IF phrase.expression.carry = zero THEN {              SyntaxError[phrase, invalidExpression];              successful ¬ FALSE;              value ¬ 0}            ELSE value ¬ addressConstant.ac;          ENDCASE => value ¬ addressConstant.ac;      fa ¬ encoding.ac;      text ¬ "ac"L;      Field[];      encoding.ac ¬ FieldAssignment[assignment, value];      END;    IF trialPattern.imu # x THEN      BEGIN      const: CARDINAL ¬ Inline.BITNOT[0];      IF phrase.expression.operand1 = bBus THEN const ¬ phrase.arg1.arg      ELSE        IF phrase.expression.operand2 = bBus THEN const ¬ phrase.arg2.arg        ELSE          IF phrase.expression.operand1 = zero OR phrase.expression.operand2 = zero            THEN const ¬ 0          ELSE {SyntaxError[phrase, invalidOperand]; successful ¬ FALSE};      IF const < 256 THEN {constant.word ¬ Inline.BITNOT[const]; high ¬ FALSE}      ELSE        IF (const MOD 256) = 0 THEN {          constant.word ¬ Inline.BITNOT[const / 256]; high ¬ TRUE}        ELSE {SyntaxError[phrase, invalidOperand]; successful ¬ FALSE};      value ¬ constant.imu;      fa ¬ encoding.imu;      text ¬ "imu"L;      Field[];      encoding.imu ¬ FieldAssignment[assignment, value];      END;    IF trialPattern.iml # x THEN      BEGIN      value ¬ constant.iml;      fa ¬ encoding.iml;      text ¬ "iml"L;      Field[];      encoding.iml ¬ FieldAssignment[assignment, value];      END;    IF trialPattern.hiByte # x THEN      BEGIN      value ¬ IF high THEN hiByteTrue ELSE hiByteFalse;      fa ¬ encoding.hiByte;      text ¬ "hiByte"L;      Field[];      encoding.hiByte ¬ FieldAssignment[assignment, value];      END;    IF trialPattern.cycle # x THEN      BEGIN      value ¬        SELECT trialPattern.cycle FROM          c1 => cycle1,          c2 => cycle2,          c3 => cycle3,          c4 => cycle4          ENDCASE => ERROR EncodePatternError[cycleInvalid];      fa ¬ encoding.cycle;      text ¬ "cycle"L;      Field[];      encoding.cycle ¬ FieldAssignment[assignment, value];      END;    encoding.isStk ¬ encoding.isStk OR phrase.isStk;    encoding.isPop ¬ encoding.isPop OR phrase.isPop;    encoding.isPush ¬ encoding.isPush OR phrase.isPush;    IF NOT successful THEN encoding­ ¬ savedEncoding;    RETURN;    END;  -- end of procedure EncodePattern   FindCarry: PROCEDURE [phrase: PhrasePtr] RETURNS [carry: CARDINAL] =    BEGIN    SELECT phrase.expression.operation FROM      minus =>        carry ¬          SELECT phrase.expression.carry FROM zero => 1, one => 0, ENDCASE => 0;      ENDCASE =>        carry ¬          SELECT phrase.expression.carry FROM zero => 0, one => 1, ENDCASE => 0;    END;  --of procedure FindCarry  GetrAField: PUBLIC PROCEDURE [rA: CARDINAL] RETURNS [reference: ArgumentType] =    BEGIN    reference ¬      SELECT rA FROM        IN [rAAUpper16..rAALower16) => ArgumentType[rA - rAAUpper16, aUpper16],        IN [rAALower16..rACIP) => ArgumentType[rA - rAALower16, aLower16],        IN [rAFirstDReg..rAZero) => ArgumentType[rA, D],        rAChipVersion => ArgumentType[0, chipVersion],        rACSBank => ArgumentType[0, CSBank],        rAStkPtr => ArgumentType[0, stkPtr],        rAStkRef + rAStkP1Offset, rAStkRef + rAStkP1Offset + rAPush,          rAStkRef + rAStkP1Offset + rAPop => ArgumentType[0, stkPlus1],        rAStkRef + rAStk0Offset, rAStkRef + rAStk0Offset + rAPush,          rAStkRef + rAStk0Offset + rAPop => ArgumentType[0, stkZero],        rAStkRef + rAStkM1Offset, rAStkRef + rAStkM1Offset + rAPush,          rAStkRef + rAStkM1Offset + rAPop => ArgumentType[0, stkMinus1],        rAStkRef + rAStkM2Offset, rAStkRef + rAStkM2Offset + rAPush,          rAStkRef + rAStkM2Offset + rAPop => ArgumentType[0, stkMinus2],        rACIP => ArgumentType[0, CIP],        rAIBCtr => ArgumentType[0, ibCtr],        rATimerLow => ArgumentType[0, timerLow],        rATimerHigh => ArgumentType[0, timerHigh],        rAPrescaler => ArgumentType[0, prescaler],        ENDCASE => ArgumentType[];    END;  --of procedure GetrAField  GetrDField: PUBLIC PROCEDURE [rD: CARDINAL, rB: CARDINAL]    RETURNS [reference: ArgumentType] =    BEGIN    reference ¬      SELECT rD FROM        IN [rDFirstDReg..rDLastDReg] => ArgumentType[rD, D],        rDCSBank => ArgumentType[0, CSBank],        rDStkPtr => ArgumentType[0, stkPtr],        rDStkPlus1 => ArgumentType[0, stkPlus1],        rDStkZero => ArgumentType[0, stkZero],        rDStkMinus1 => ArgumentType[0, stkMinus1],        rDStkMinus2 => ArgumentType[0, stkMinus2],        IN [rDAUpper8..rDAUpper16) => ArgumentType[rD - rDAUpper8, aUpper8],        IN [rDAUpper16..rDALower16) => ArgumentType[rD - rDAUpper16, aUpper16],        IN [rDALower16..rDCIP) => ArgumentType[rD - rDALower16, aLower16],        rDCIP => ArgumentType[0, CIP],        rDTimerLow => ArgumentType[0, timerLow],        rDTimerHigh => ArgumentType[0, timerHigh],        rDSameAsrB => ArgumentType[rB, R],        rDQ => ArgumentType[0, Q],        rDPrescaler => ArgumentType[0, prescaler],        ENDCASE => ArgumentType[];    END;  --of procedure GetrBField  END...--Log of last edits:--JAC   	 5-Nov-84 14:18:09	fixed arrows for Mesa 11.1--JAC   	19-Dec-84 11:41:46	added ConstantValid
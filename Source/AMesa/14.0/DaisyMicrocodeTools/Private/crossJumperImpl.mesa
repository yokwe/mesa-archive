-- Copyright (C) [1984] by Xerox Corporation. All rights reserved.-- crossJumperImpl.mesa-- last edited by-- RDH      	22-Aug-84 10:14:28DIRECTORY  Environment USING [bytesPerWord],  Exec USING [AddCommand, ExecProc, GetToken, OutputProc],  Format USING [CR, Line, LongDecimal, StringProc, Text, Date],  Heap USING [systemZone],  MFile USING [Type],  MStream USING [Error, Handle, ReadOnly, ReleaseData, WriteOnly],  Stream USING [Delete, EndOfStream, GetBlock, Handle, PutString],  String USING [AppendExtensionIfNeeded, AppendString, Copy, CopyToNewString,    Length],  System USING [GetClockPulses, GetGreenwichMeanTime, Pulses, PulsesToMicroseconds],  UserInput USING [UserAbort],  CPDef USING [sizeOfCS, wordsPerBank],  CPCommand USING [Error, LoadSymbols],    CPSymbol USING [AppendVirturalCS, ClearSymbolTable],  DsyuFormat USING [FinalBinaryRec, PartialBinary];crossJumperImpl : PROGRAMIMPORTS Exec, Format, Heap, MStream, Stream, String, System, UserInput,    CPCommand, CPSymbol= BEGIN  z: UNCOUNTED ZONE = Heap.systemZone;  outStream: Stream.Handle _ NIL;  -- for output to the output file.  Feedback: Format.StringProc;   -- for output to the executive.  compareAddr: BOOLEAN _ FALSE; -- flag which tells whether or not --  	  	-- to include the next address field in the comparison.      CrossJumpMain: Exec.ExecProc = BEGIN    defOutFileName: LONG STRING = "crossJump.log"L;    maxNameLen: CARDINAL = 30;    outfilename: LONG STRING _ [maxNameLen];    positiveSense: BOOL _ TRUE; -- flag for negative options.    doit: BOOL _ TRUE; -- flag for skipping arguments which    			-- are not input filenames.    accessProc: PROC [name: LONG STRING, release: MStream.ReleaseData,         type: MFile.Type _ unknown] 	RETURNS [MStream.Handle] _ MStream.WriteOnly;    filename, switches: LONG STRING _ NIL;        Feedback _ Exec.OutputProc[h];    compareAddr _ FALSE; -- reset default flag on new invocation.    String.Copy[from: defOutFileName, to: outfilename];--set default outfile.        [filename, switches] _ Exec.GetToken[h];    BEGIN    ENABLE BEGIN      CPCommand.Error => BEGIN        TailMessage[reason]; CONTINUE;        END;      END;-- ENABLE    CPSymbol.ClearSymbolTable[];  --  Clear the symbol table.    WHILE NOT (String.Length[switches] = 0 AND String.Length[filename] = 0)       -- while there is something on the input line to read.       DO -- process switches and call CrossJump.	 FOR i: CARDINAL IN [0..String.Length[switches]) DO	   IF switches[i] = '~ OR switches[i] = '- THEN BEGIN	     positiveSense _ FALSE;	     END 	   ELSE BEGIN	     SELECT TRUE FROM	       (switches[i] = 'o OR switches[i] = 'O) AND 	         String.Length[filename] > 0 => BEGIN	         String.Copy[from: filename, to: outfilename];	         doit _ FALSE;	         END;	       (switches[i] = 'o OR switches[i] = 'O) AND	         String.Length[filename] = 0 => BEGIN	         String.Copy[from: defOutFileName, to: outfilename];	         doit _ FALSE;	         END;	       (switches[i] = 'a OR switches[i] = 'A) => BEGIN	         compareAddr _ positiveSense;	         END;	       ENDCASE;	     END;-- of ELSE 	       -- done processing switches	   ENDLOOP; -- FOR loop	   -- done processing switches	   	 --  Read the .st file, open the output file, call CrossJump,	 --  and close the output file. 	 IF doit AND String.Length[filename] > 0 THEN BEGIN	   StripExtension[filename];	   CPCommand.LoadSymbols[Feedback, NIL, filename, 0];	              outStream _ MStream.WriteOnly[name: outfilename,	     release: MStream.ReleaseData[NIL, NIL], type: MFile.Type[text] !	     --Catch Phrase-- MStream.Error => BEGIN	       TailMessage[outfilename];	       TailMessage[" could not be opened."L];	       GOTO getOut;	       END; ];	   Format.Text[proc: Feedback,             s: "Output from the scan can be found in "L];	   Format.Text[proc: Feedback, s: outfilename];	   Format.Line[proc: Feedback, s: "."L]; 	   CrossJump[log: LogString, arg: outStream, file: filename];           Stream.Delete[outStream];	   EXITS	     getOut => NULL;           END;-- IF	doit _ TRUE; -- reset doit flag.        [filename, switches] _ Exec.GetToken[h]; 	ENDLOOP;-- WHILE loop --     END;  END;  --CrossJumpMain        CrossJump: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER,    file: LONG STRING] =    BEGIN    filename: LONG STRING;    stream: Stream.Handle;    filename _ String.CopyToNewString[file, z];    [] _ String.AppendExtensionIfNeeded[@filename, "fb"L, z];    Feedback["Scanning "L];    Feedback[filename];    Format.Line[proc: Feedback, s: " for Cross Jump opportunities."L];    Format.Text[log, filename, arg];    Format.Line[log, ":", arg];    IF NOT compareAddr THEN      Format.Text[log, "Not "L, arg];    Format.Line[log, "Comparing Next Address Fields."L, arg];    stream _ MStream.ReadOnly[filename, [] ! MStream.Error =>      ERROR CPCommand.Error["Can't read that file"] ];    CrossJumpFromStream[log, arg, stream !      UNWIND => BEGIN Stream.Delete[stream]; z.FREE[@filename]; END ];    Format.CR[log, arg];    Format.CR[log, arg];    Stream.Delete[stream];    z.FREE[@filename];    END;  CrossJumpFromStream: PROCEDURE [    log: Format.StringProc, arg: LONG POINTER, stream: Stream.Handle] =    BEGIN ENABLE      BEGIN      Stream.EndOfStream =>BEGIN        Stream.Delete[stream];        ERROR CPCommand.Error["Truncated fb file"L];	END;      CPCommand.Error => ERROR CPCommand.Error[reason];      END;    Info: TYPE = ARRAY [0..CPDef.wordsPerBank) OF       RECORD [mi: DsyuFormat.PartialBinary, exists: BOOLEAN, virt: CARDINAL];    start, stop: System.Pulses;    ms: LONG CARDINAL;    instructions: CARDINAL _ 0;    fbrBytes: CARDINAL = Environment.bytesPerWord*SIZE[DsyuFormat.FinalBinaryRec];    b: POINTER = @fbr;    fbr: DsyuFormat.FinalBinaryRec _ TRASH;    pb: POINTER TO DsyuFormat.PartialBinary = @fbr.partialBinary;    virtptr: POINTER TO CARDINAL = @fbr.miNum;    info: LONG POINTER TO Info _ NIL;    start _ System.GetClockPulses[];    info _ z.NEW[Info];    info^ _ ALL[[TRASH, FALSE, TRASH]];    DO      bytes: CARDINAL;      [bytes, , ] _ Stream.GetBlock[          sH: stream,          block: [            blockPointer: b,	    startIndex: 0,            stopIndexPlusOne: fbrBytes]];      IF bytes # fbrBytes THEN ERROR CPCommand.Error["Truncated fb"];      IF fbr.addr >= CPDef.sizeOfCS THEN EXIT;      IF fbr.miNum IN [0FFFEH..0FFFFH] THEN        BEGIN	 NULL; -- This slot initializes a TPC        END      ELSE        BEGIN	info[fbr.addr] _ [pb^, TRUE, virtptr^];	instructions _ instructions + 1;        END;      IF UserInput.UserAbort[NIL] THEN EXIT;  -- Better than nothing...      ENDLOOP;    FOR i: CARDINAL IN [0..CPDef.wordsPerBank) DO      hit: BOOLEAN _ FALSE;      IF ~info[i].exists THEN LOOP;      FOR j: CARDINAL IN [i+1..CPDef.wordsPerBank) DO        IF ~info[j].exists THEN LOOP;	 IF (compareAddr AND info[i].mi = info[j].mi) OR	    (~compareAddr AND EqualExceptForAddr[info[i].mi, info[j].mi]) THEN	  BEGIN	  temp: STRING = [200];	  IF ~hit THEN	    BEGIN	    hit _ TRUE;	    CPSymbol.AppendVirturalCS[temp, info[i].virt];	    END;	  String.AppendString[temp, " = "L];	  CPSymbol.AppendVirturalCS[temp, info[j].virt];          Format.Text[log, temp, arg];	  info[j].exists _ FALSE;	  END;        ENDLOOP;      IF hit THEN BEGIN         Format.CR[log, arg];        Format.CR[log, arg];	END;      IF UserInput.UserAbort[NIL] THEN EXIT;  -- Better than nothing...      ENDLOOP;    z.FREE[@info];    stop _ System.GetClockPulses[];    ms _ System.PulsesToMicroseconds[[stop - start]]/1000;    InfoCrossJump[log, arg, ms, instructions];    END;      InfoCrossJump: PROCEDURE [    log: Format.StringProc, arg: LONG POINTER, ms, instructions: LONG CARDINAL] =    BEGIN    Format.Text[log, "It took "L, arg];    Format.LongDecimal[log, ms, arg];    Format.Text[log, " ms to Cross Jump "L, arg];    Format.LongDecimal[log, instructions, arg];    Format.Text[log, " instructions."L, arg];    IF ms # 0 THEN      BEGIN      Format.Text[log, " ("L, arg];      Format.LongDecimal[log, instructions*16*SIZE[DsyuFormat.PartialBinary]*1000/ms, arg];      Format.Text[log, " bits/sec)"L, arg];      END;    Format.CR[log, arg];    END;<<******EqualExceptForAddr returns true if the first 35 bits of the microinstructionsleftMi and rightMi are the same.   It does not consider the remaining 13 bitswhich represent the  next instruction address and a parity bit.******>>EqualExceptForAddr: PROCEDURE [leftMi, rightMi: DsyuFormat.PartialBinary]   RETURNS [equal: BOOLEAN] = BEGIN  left2words, right2words :  POINTER TO LONG CARDINAL;  --assign  left2words _ LOOPHOLE[@leftMi];  right2words _ LOOPHOLE[@rightMi];  --compare and return  RETURN[left2words^ = right2words^ AND leftMi.instruction.dspBLo3 = rightMi.instruction.dspBLo3];  END;-- EqualExceptForAddr    PostDate: PROCEDURE =    BEGIN    Format.CR[LogString, outStream];    Format.Date[LogString, System.GetGreenwichMeanTime[], dateTime, , outStream];    Format.CR[LogString, outStream];    END;  TailMessage: PROCEDURE [s: LONG STRING] =    BEGIN    Feedback[s];    END;    LogString: Format.StringProc =    BEGIN    Stream.PutString[sH: clientData, string: s];    END;      StripExtension: PROC [filename: LONG STRING] = BEGIN    FOR i: CARDINAL IN [0..filename.length) DO      IF filename[i] = '. THEN BEGIN        filename.length _ i+1;        EXIT;        END;      ENDLOOP;    END;-- StripExtension  Init: PROCEDURE =   BEGIN   Exec.AddCommand["CrossJumper.~"L, CrossJumpMain];   END; --Init  --MainLine Code:  Init[];	END.
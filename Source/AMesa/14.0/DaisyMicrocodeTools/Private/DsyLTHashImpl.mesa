-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. --Last edit by JAC    	 5-Nov-84 14:20:27 DIRECTORY  Heap USING [Create, Delete, FreeNode],  DsyAssembler USING [GetPassSpace],  DsyLabel,  DsyModule;DsyLTHashImpl: PROGRAM IMPORTS DsyAssembler, Heap EXPORTS DsyLabel, DsyModule =  BEGIN OPEN DsyLabel;  -- GLOBAL VARIABLES  LHSize: CARDINAL = 201;  -- should be a prime  HashTable: TYPE = ARRAY [0..LHSize) OF HashEntryPtr;  hashTable: LONG POINTER TO HashTable;  LTtempHeap: PUBLIC UNCOUNTED ZONE;  InitGlobalLTHash: PUBLIC PROCEDURE = {hashTable ¬ NIL; LTtempHeap ¬ NIL};  BuildHashCode: PROCEDURE [str: LONG STRING] RETURNS [hc: CARDINAL] = INLINE    BEGIN    i: CARDINAL;    hc ¬ 0;    FOR i IN [0..str.length) DO hc ¬ (2*hc) + LOOPHOLE[str[i], CARDINAL]; ENDLOOP;    hc ¬ (hc + (hc/16)) MOD LHSize;    RETURN[hc];    END;  --  of Procedure BuildHashCode      ClearHashTable: PUBLIC PROCEDURE =    BEGIN    i: CARDINAL;    FOR i IN [0..LHSize) DO      hashTable[i] ¬ NIL;      ENDLOOP;    END;   -- of Procedure ClearHashTable      DeletePrevDest: PUBLIC PROCEDURE [current: LabelEntryPtr] =   BEGIN   destPtr: DestPtr;   tempDestPtr: DestPtr;   destPtr ¬ current.destination;   UNTIL destPtr = NIL DO     tempDestPtr ¬ destPtr.next;     Heap.FreeNode[LTtempHeap, destPtr];     destPtr ¬ tempDestPtr;     ENDLOOP;   current.destination ¬ NIL;   END;  --of procedure DeletePrevDest  DisplayLabels: PUBLIC PROCEDURE [proc: PROCEDURE [HashEntryPtr]] =  --display and delete labels    BEGIN    i: CARDINAL;    p: HashEntryPtr;    pp: HashEntryPtr;    refPtr: ArgReferencePtr;    tempRefPtr: ArgReferencePtr;    FOR i IN [0..LHSize) DO      p ¬ hashTable[i];      UNTIL p = NIL DO        pp ¬ p.next; 	proc[p];	refPtr ¬ p.ptr.referenced;	UNTIL refPtr = NIL DO	  tempRefPtr ¬ refPtr.next;	  Heap.FreeNode[LTtempHeap, refPtr];	  refPtr ¬ tempRefPtr;	  ENDLOOP;	DeletePrevDest[p.ptr];	Heap.FreeNode[LTtempHeap, p.ptr];	p ¬ pp;	ENDLOOP;      ENDLOOP;    END;  --  of Procedure DisplayLabels  EqualString: PROCEDURE [str1, str2: LONG STRING] RETURNS [BOOLEAN] = INLINE    BEGIN    i: CARDINAL;    IF str1.length # str2.length THEN RETURN[FALSE];    FOR i IN [0..str1.length) DO IF str1[i] # str2[i] THEN RETURN[FALSE]; ENDLOOP;    RETURN[TRUE];    END;  --  of Procedure EqualString  FindLabel: PUBLIC PROCEDURE [str: LONG STRING] RETURNS [h: HashEntryPtr] =    BEGIN    hashCode: CARDINAL;    p: HashEntryPtr;    hashCode ¬ BuildHashCode[str];    p ¬ hashTable[hashCode];    UNTIL p = NIL DO      IF EqualString[p.key, str] THEN RETURN[p]; p ¬ p.next; ENDLOOP;    RETURN[NIL];    END;  -- of procedure FindLabel  InitLTHeap: PUBLIC PROCEDURE [initPages, incrPages: CARDINAL] =    BEGIN    i: CARDINAL;    IF LTtempHeap # NIL THEN Heap.Delete[LTtempHeap];    LTtempHeap ¬ Heap.Create[      initial: initPages, increment: incrPages];    hashTable ¬ DsyAssembler.GetPassSpace[SIZE[HashTable]];    FOR i IN [0..LHSize) DO hashTable[i] ¬ NIL; ENDLOOP;    END;  --  of Procedure InitLTHeap  InsertLabel: PUBLIC PROCEDURE [h: HashEntryPtr] RETURNS [error: BOOLEAN] =    BEGIN    hashCode: CARDINAL;    hp: LONG POINTER TO HashEntryPtr;    p: HashEntryPtr;    IF hashTable = NIL THEN InitLTHeap[16, 8];    hashCode ¬ BuildHashCode[h.key];    p ¬ hashTable[hashCode];    hp ¬ @hashTable[hashCode];    UNTIL p = NIL DO      IF EqualString[p.key, h.key] THEN RETURN[TRUE];      hp ¬ @p.next;      p ¬ p.next;      ENDLOOP;    hp­ ¬ h;    RETURN[FALSE];    END;  -- of procedure InsertLabel  ReleaseLTSpace: PUBLIC PROCEDURE =    BEGIN    IF LTtempHeap # NIL THEN {      Heap.Delete[LTtempHeap];      LTtempHeap ¬ NIL};     hashTable ¬ NIL;     END;  --  of procedure ReleaseLTSpace    END...--Log of last edits:--JAC   	 5-Nov-84 14:20:37	fixed arrows for Mesa 11.1
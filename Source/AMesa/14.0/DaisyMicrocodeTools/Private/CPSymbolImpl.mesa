-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved -- Last edit by JAC   	 	 8-Jan-85 17:34:12-- CPSymbolImpl.mesa, AYC   ,  3-Jan-85 17:25:55-- from CPSymboler.mesa, HGM, 12-Nov-83 22:51:27--DIRECTORY  Heap USING [Create],  Inline USING [LowHalf],  String USING [AppendChar, AppendLongNumber, AppendNumber, AppendString],    CPDef USING [    AReg, Bank, BankAndWordsPerBank, DReg, IBDisp, Link, Map, MDR, OtherReg,    RealCS, RealMemory, RReg, ROffset, VirturalMemory, wordsPerBank],  CPuFormat USING [MI],  CPSymbol USING [nullRealCS, nullVirturalCS, Symbol, VirturalCS],  SymbolHash USING [    Create, EnumerateEntries, GetInfo, GetString, Handle, Hash, Insert,    Lookup, nullHash, PutInfo, Reset];CPSymbolImpl: MONITOR  IMPORTS Heap, Inline, String, SymbolHash  EXPORTS CPSymbol =  BEGIN    WordInBank: TYPE = [0..CPDef.wordsPerBank);  z: UNCOUNTED ZONE = Heap.Create[10];    Error: PUBLIC ERROR [reason: LONG STRING] = CODE;    -- setup hash table for label, rReg, dReg and aReg  csSymbols: SymbolHash.Handle ¬ SymbolHash.Create[100];  rRegSymbols: SymbolHash.Handle ¬ SymbolHash.Create[2];  dRegSymbols: SymbolHash.Handle ¬ SymbolHash.Create[2];  aRegSymbols: SymbolHash.Handle ¬ SymbolHash.Create[2];    csInverse: ARRAY CPDef.Bank OF LONG POINTER TO ARRAY WordInBank OF SymbolHash.Hash ¬ ALL[NIL];  rRegInverse: LONG POINTER TO ARRAY CPDef.RReg OF SymbolHash.Hash ¬ z.NEW[ARRAY CPDef.RReg OF SymbolHash.Hash];  dRegInverse: LONG POINTER TO ARRAY CPDef.DReg OF SymbolHash.Hash ¬ z.NEW[ARRAY CPDef.DReg OF SymbolHash.Hash];  aRegInverse: LONG POINTER TO ARRAY CPDef.AReg OF SymbolHash.Hash ¬ z.NEW[ARRAY CPDef.AReg OF SymbolHash.Hash];    info: ARRAY CPDef.Bank OF LONG POINTER TO ARRAY WordInBank OF Info ¬ ALL[NIL];  Info: TYPE = RECORD [    valid: BOOLEAN,    ibdisp: CPDef.IBDisp,    mdr: CPDef.MDR,    virtural: CPSymbol.VirturalCS];      ClearSymbolTable: PUBLIC ENTRY PROCEDURE =    BEGIN    FOR bank: CPDef.Bank IN CPDef.Bank DO      IF info[bank] = NIL THEN LOOP;      info[bank]­ ¬ ALL [[FALSE,FALSE,FALSE,]];      ENDLOOP;    FOR bank: CPDef.Bank IN CPDef.Bank DO      IF csInverse[bank] = NIL THEN LOOP;      csInverse[bank]­ ¬ ALL[SymbolHash.nullHash];      ENDLOOP;    rRegInverse­ ¬ ALL[SymbolHash.nullHash];    dRegInverse­ ¬ ALL[SymbolHash.nullHash];    aRegInverse­ ¬ ALL[SymbolHash.nullHash];    SymbolHash.Reset[csSymbols];    SymbolHash.Reset[rRegSymbols];    SymbolHash.Reset[dRegSymbols];    SymbolHash.Reset[aRegSymbols];    END;      AddToMap: PUBLIC ENTRY PROCEDURE [real: CPDef.RealCS, virtural: CPSymbol.VirturalCS, ibdisp: CPDef.IBDisp, mdr: CPDef.MDR] =    BEGIN    bank: CPDef.Bank;    wordInBank: WordInBank;    IF real ~IN CPDef.RealCS THEN ERROR;    [bank, wordInBank] ¬ SplitReal[real];    BeSureInfoExists[bank, wordInBank];    info[bank][wordInBank] ¬ [TRUE, ibdisp, mdr, virtural];    END;    AddCSSymbol: PUBLIC ENTRY PROCEDURE [tag: LONG STRING, virt: CPSymbol.VirturalCS] =    BEGIN ENABLE UNWIND => NULL;    hash: SymbolHash.Hash ¬ SymbolHash.Lookup[csSymbols, tag];    bank: CPDef.Bank;    wordInBank: WordInBank;    IF hash # SymbolHash.nullHash THEN      BEGIN      IF virt = SymbolHash.GetInfo[csSymbols, hash] THEN RETURN;  -- Ignore duplicates      ERROR Error["Duplicate CS Symbol"L];      END;    hash ¬ SymbolHash.Insert[csSymbols, tag];    SymbolHash.PutInfo[csSymbols, hash, virt];    [bank, wordInBank] ¬ SplitVirt[virt];    BeSureInverseExists[bank, wordInBank];    csInverse[bank][wordInBank] ¬ hash;    END;      AddRRegSymbol: PUBLIC ENTRY PROCEDURE [tag: LONG STRING, r: CPDef.RReg] =    BEGIN ENABLE UNWIND => NULL;    hash: SymbolHash.Hash ¬ SymbolHash.Lookup[rRegSymbols, tag];    IF hash # SymbolHash.nullHash THEN      BEGIN      IF r = SymbolHash.GetInfo[rRegSymbols, hash] THEN RETURN;  -- Ignore duplicates      ERROR Error["Duplicate RReg Symbol"L];      END;    hash ¬ SymbolHash.Insert[rRegSymbols, tag];    SymbolHash.PutInfo[rRegSymbols, hash, r];    rRegInverse[r] ¬ hash;    END;      AddDRegSymbol: PUBLIC ENTRY PROCEDURE [tag: LONG STRING, d: CPDef.DReg] =    BEGIN ENABLE UNWIND => NULL;    hash: SymbolHash.Hash ¬ SymbolHash.Lookup[dRegSymbols, tag];    IF hash # SymbolHash.nullHash THEN      BEGIN      IF d = SymbolHash.GetInfo[dRegSymbols, hash] THEN RETURN;  -- Ignore duplicates      ERROR Error["Duplicate DReg Symbol"L];      END;    hash ¬ SymbolHash.Insert[dRegSymbols, tag];    SymbolHash.PutInfo[dRegSymbols, hash, d];    dRegInverse[d] ¬ hash;    END;    AddARegSymbol: PUBLIC ENTRY PROCEDURE [tag: LONG STRING, a: CPDef.AReg] =    BEGIN ENABLE UNWIND => NULL;    hash: SymbolHash.Hash ¬ SymbolHash.Lookup[aRegSymbols, tag];    IF hash # SymbolHash.nullHash THEN      BEGIN      IF a = SymbolHash.GetInfo[aRegSymbols, hash] THEN RETURN;  -- Ignore duplicates      ERROR Error["Duplicate AReg Symbol"L];      END;    hash ¬ SymbolHash.Insert[aRegSymbols, tag];    SymbolHash.PutInfo[aRegSymbols, hash, a];    aRegInverse[a] ¬ hash;    END;  LookupInCSTable: PUBLIC ENTRY PROCEDURE [tag: LONG STRING] RETURNS [ok: BOOLEAN, virt: CPSymbol.VirturalCS] =    BEGIN    hash: SymbolHash.Hash ¬ SymbolHash.Lookup[csSymbols, tag];    bank: CPDef.Bank;    wordInBank: WordInBank;    IF hash = SymbolHash.nullHash THEN RETURN[FALSE, ];    ok ¬ TRUE;    virt ¬ Inline.LowHalf[SymbolHash.GetInfo[csSymbols, hash]];    [bank, wordInBank] ¬ SplitVirt[virt];    BeSureInverseExists[bank, wordInBank];    csInverse[bank][wordInBank] ¬ hash;    END;      LookupInRRegTable: PUBLIC ENTRY PROCEDURE [tag: LONG STRING] RETURNS [ok: BOOLEAN, r: CPDef.RReg] =    BEGIN    hash: SymbolHash.Hash ¬ SymbolHash.Lookup[rRegSymbols, tag];    IF hash = SymbolHash.nullHash THEN RETURN[FALSE, ];    ok ¬ TRUE;    r ¬ Inline.LowHalf[SymbolHash.GetInfo[rRegSymbols, hash]];    rRegInverse[r] ¬ hash;    END;      LookupInDRegTable: PUBLIC ENTRY PROCEDURE [tag: LONG STRING] RETURNS [ok: BOOLEAN, d: CPDef.DReg] =    BEGIN    hash: SymbolHash.Hash ¬ SymbolHash.Lookup[dRegSymbols, tag];    IF hash = SymbolHash.nullHash THEN RETURN[FALSE, ];    ok ¬ TRUE;    d ¬ Inline.LowHalf[SymbolHash.GetInfo[dRegSymbols, hash]];    dRegInverse[d] ¬ hash;    END;      LookupInARegTable: PUBLIC ENTRY PROCEDURE [tag: LONG STRING] RETURNS [ok: BOOLEAN, a: CPDef.AReg] =    BEGIN    hash: SymbolHash.Hash ¬ SymbolHash.Lookup[aRegSymbols, tag];    IF hash = SymbolHash.nullHash THEN RETURN[FALSE, ];    ok ¬ TRUE;    a ¬ Inline.LowHalf[SymbolHash.GetInfo[aRegSymbols, hash]];    aRegInverse[a] ¬ hash;    END;          AppendAllVirturalCS: PUBLIC PROCEDURE [s: LONG STRING, virturalCS: CPSymbol.VirturalCS] =    BEGIN    hit: BOOLEAN ¬ FALSE;    PrintMatches: PROCEDURE [hash: SymbolHash.Hash] =      BEGIN      IF SymbolHash.GetInfo[csSymbols, hash] # virturalCS THEN RETURN;      IF hit THEN String.AppendString[s, ", "L];      String.AppendString[s, SymbolHash.GetString[csSymbols, hash]];      hit ¬ TRUE;      END;    SymbolHash.EnumerateEntries[csSymbols, PrintMatches];    END;      AppendAllRReg: PUBLIC PROCEDURE [s: LONG STRING, r: CPDef.RReg] =    BEGIN    hit: BOOLEAN ¬ FALSE;    PrintMatches: PROCEDURE [hash: SymbolHash.Hash] =      BEGIN      IF SymbolHash.GetInfo[rRegSymbols, hash] # r THEN RETURN;      IF hit THEN String.AppendString[s, ", "L];      String.AppendString[s, SymbolHash.GetString[rRegSymbols, hash]];      hit ¬ TRUE;      END;    SymbolHash.EnumerateEntries[rRegSymbols, PrintMatches];    END;  AppendAllDReg: PUBLIC PROCEDURE [s: LONG STRING, d: CPDef.DReg] =    BEGIN    hit: BOOLEAN ¬ FALSE;    PrintMatches: PROCEDURE [hash: SymbolHash.Hash] =      BEGIN      IF SymbolHash.GetInfo[dRegSymbols, hash] # d THEN RETURN;      IF hit THEN String.AppendString[s, ", "L];      String.AppendString[s, SymbolHash.GetString[dRegSymbols, hash]];      hit ¬ TRUE;      END;    SymbolHash.EnumerateEntries[dRegSymbols, PrintMatches];    END;      AppendAllAReg: PUBLIC PROCEDURE [s: LONG STRING, a: CPDef.AReg] =    BEGIN    hit: BOOLEAN ¬ FALSE;    PrintMatches: PROCEDURE [hash: SymbolHash.Hash] =      BEGIN      IF SymbolHash.GetInfo[aRegSymbols, hash] # a THEN RETURN;      IF hit THEN String.AppendString[s, ", "L];      String.AppendString[s, SymbolHash.GetString[aRegSymbols, hash]];      hit ¬ TRUE;      END;    SymbolHash.EnumerateEntries[aRegSymbols, PrintMatches];    END;      AppendSymbol: PUBLIC PROCEDURE [s: LONG STRING, symbol: CPSymbol.Symbol] =    BEGIN    WITH symbol SELECT FROM      link => AppendLink[s, link];      realCS => AppendRealCS[s, real];      virtCS => AppendVirturalCS[s, virt];      rReg => AppendRReg[s, r];      dReg => AppendDReg[s, d];      aReg => AppendAReg[s, a];      map => AppendMap[s, map];      real => AppendReal[s, real];      virt => AppendVirtural[s, virt];      other => AppendOther[s, other];      ENDCASE => ERROR;    END;     AppendLink: PUBLIC PROCEDURE [s: LONG STRING, link: CPDef.Link] =    BEGIN    String.AppendString[s, "L"L];    String.AppendNumber[s, link, 16];    END;      AppendRealCS: PUBLIC PROCEDURE [s: LONG STRING, realCS: CPDef.RealCS] =    BEGIN    String.AppendString[s, ".CR "L];    AppendNumber[s, realCS];    END;      AppendVirturalCS: PUBLIC PROCEDURE [s: LONG STRING, virturalCS: CPSymbol.VirturalCS] =    BEGIN    FOR i: CARDINAL IN [0..100) DO      hash: SymbolHash.Hash;      bank: CPDef.Bank;      wordInBank: WordInBank;      IF virturalCS < i THEN EXIT;      [bank, wordInBank] ¬ SplitVirt[virturalCS - i];      IF csInverse[bank] = NIL THEN LOOP;      hash ¬ csInverse[bank][wordInBank];      IF hash # SymbolHash.nullHash THEN        BEGIN        String.AppendString[s, SymbolHash.GetString[csSymbols, hash]];	IF i > 0 THEN	  BEGIN	  String.AppendChar[s, '+];	  IF i > 9 THEN String.AppendChar[s, '0];	  String.AppendNumber[s, i, 16];	  END;        RETURN;        END;      ENDLOOP;    String.AppendString[s, ".CV "L];    AppendNumber[s, virturalCS];    END;      AppendRReg: PUBLIC PROCEDURE [s: LONG STRING, r: CPDef.RReg] =    BEGIN    hash: SymbolHash.Hash;    IF r ~IN CPDef.RReg THEN RegOutOfRange[];    hash ¬ rRegInverse[r];    IF hash # SymbolHash.nullHash THEN      BEGIN      String.AppendString[s, SymbolHash.GetString[rRegSymbols, hash]];      RETURN;      END;    String.AppendString[s, ".R "L];    AppendNumber[s, r + CPDef.ROffset];    END;  AppendDReg: PUBLIC PROCEDURE [s: LONG STRING, d: CPDef.DReg] =    BEGIN    hash: SymbolHash.Hash;    IF d ~IN CPDef.DReg THEN RegOutOfRange[];    hash ¬ dRegInverse[d];    IF hash # SymbolHash.nullHash THEN      BEGIN      String.AppendString[s, SymbolHash.GetString[dRegSymbols, hash]];      RETURN;      END;    String.AppendString[s, ".D "L];    AppendNumber[s, d];    END;      AppendAReg: PUBLIC PROCEDURE [s: LONG STRING, a: CPDef.AReg] =    BEGIN    hash: SymbolHash.Hash;    IF a ~IN CPDef.AReg THEN RegOutOfRange[];    hash ¬ aRegInverse[a];    IF hash # SymbolHash.nullHash THEN      BEGIN      String.AppendString[s, SymbolHash.GetString[aRegSymbols, hash]];      RETURN;      END;    String.AppendString[s, ".A "L];    AppendNumber[s, a];    END;      AppendMap: PUBLIC PROCEDURE [s: LONG STRING, map: CPDef.Map] =    BEGIN    String.AppendString[s, ".MAP "L];    AppendNumber[s, map];    END;      AppendReal: PUBLIC PROCEDURE [s: LONG STRING, real: CPDef.RealMemory] =    BEGIN    String.AppendString[s, ".MR "L];    AppendLongNumber[s, real];    END;      AppendVirtural: PUBLIC PROCEDURE [s: LONG STRING, virtural: CPDef.VirturalMemory] =    BEGIN    String.AppendString[s, ".MV "L];    AppendLongNumber[s, virtural];    END;    AppendOther: PUBLIC PROCEDURE [s: LONG STRING, other: CPDef.OtherReg] =    BEGIN    SELECT other FROM      RTChigh => String.AppendString[s, ".RTChigh"L];      RTClow => String.AppendString[s, ".RTClow"L];      qReg => String.AppendString[s, ".Q"L];      uReg => String.AppendString[s, ".MDu"L];      vReg => String.AppendString[s, ".MDv"L];      CSBank => String.AppendString[s,  ".CSBank"L];      Ib => String.AppendString[s, ".Ib"L];      IBCtr => String.AppendString[s, ".IBCtr"L];      PScaler => String.AppendString[s, ".PScaler"L];      CIP => String.AppendString[s, ".CIP"L];      CVN => String.AppendString[s, ".CVN"L];      StkPtr => String.AppendString[s, ".StkPtr"L];      StkP1 => String.AppendString[s, ".STK(1)"L];      StkP0 => String.AppendString[s, ".STK(0)"L];      StkM1 => String.AppendString[s, ".STK(~1)"L];      StkM2 => String.AppendString[s, ".STK(~2)"L];      ENDCASE => ERROR;    END;    AppendMI: PUBLIC PROCEDURE [s: LONG STRING, MI: CPuFormat.MI] =    BEGIN    foo: POINTER = @MI;    FOR i: CARDINAL IN [0..SIZE[CPuFormat.MI]) DO      temp: STRING = [4];      IF i # 0 THEN String.AppendChar[s, ' ];      String.AppendNumber[temp, (foo + i)­, 16];      FOR k: CARDINAL IN [temp.length..4) DO String.AppendChar[s, ' ]; ENDLOOP;      String.AppendString[s, temp];      ENDLOOP;    END;    AppendNumber: PUBLIC PROCEDURE [s: LONG STRING, w: UNSPECIFIED] =    BEGIN    IF w < 1000B THEN String.AppendChar[s, '0];    String.AppendNumber[s, w, 16];    END;   AppendLongNumber: PUBLIC PROCEDURE [s: LONG STRING, w: LONG UNSPECIFIED] =    BEGIN    IF w < 1000B THEN String.AppendChar[s, '0];    String.AppendLongNumber[s, w, 16];    END;      RealToVirturalCS: PUBLIC ENTRY PROCEDURE [real: CPDef.RealCS]    RETURNS [CPSymbol.VirturalCS, CPDef.IBDisp, CPDef.MDR] =    BEGIN    p: LONG POINTER TO Info;    bank: CPDef.Bank;    wordInBank: WordInBank;    [bank, wordInBank] ¬ SplitReal[real];    IF info[bank] = NIL THEN RETURN[CPSymbol.nullVirturalCS,FALSE,FALSE];    p ¬ @info[bank][wordInBank];    IF ~p.valid THEN RETURN[CPSymbol.nullVirturalCS,FALSE,FALSE];    RETURN[p.virtural, p.ibdisp, p.mdr];    END;      VirturalToRealCS: PUBLIC ENTRY PROCEDURE [virtural: CPSymbol.VirturalCS]    RETURNS [CPDef.RealCS, CPDef.IBDisp, CPDef.MDR] =    BEGIN    FOR real: CPDef.RealCS IN CPDef.RealCS DO      p: LONG POINTER TO Info;      bank: CPDef.Bank;      wordInBank: WordInBank;      [bank, wordInBank] ¬ SplitReal[real];      IF info[bank] = NIL THEN LOOP;      p ¬ @info[bank][wordInBank];      IF p.valid AND virtural = p.virtural THEN RETURN[real, p.ibdisp, p.mdr];      ENDLOOP;    RETURN[CPSymbol.nullRealCS,FALSE,FALSE];    END;  EnumerateCSSymbols: PUBLIC --ENTRY-- PROCEDURE [proc: PROCEDURE [LONG STRING, CPSymbol.VirturalCS]] =    BEGIN ENABLE UNWIND => NULL;    CallHim: PROCEDURE [hash: SymbolHash.Hash] =      BEGIN      virt: CPSymbol.VirturalCS ¬ Inline.LowHalf[SymbolHash.GetInfo[csSymbols, hash]];      proc[SymbolHash.GetString[csSymbols, hash], virt];      END;    SymbolHash.EnumerateEntries[csSymbols, CallHim];    END;      EnumerateRRegSymbols: PUBLIC ENTRY PROCEDURE [proc: PROCEDURE [LONG STRING, CPDef.RReg]] =    BEGIN ENABLE UNWIND => NULL;    CallHim: PROCEDURE [hash: SymbolHash.Hash] =      BEGIN      r: CPDef.RReg ¬ Inline.LowHalf[SymbolHash.GetInfo[rRegSymbols, hash]];      proc[SymbolHash.GetString[rRegSymbols, hash], r];      END;    SymbolHash.EnumerateEntries[rRegSymbols, CallHim];    END;      EnumerateDRegSymbols: PUBLIC ENTRY PROCEDURE [proc: PROCEDURE [LONG STRING, CPDef.DReg]] =    BEGIN ENABLE UNWIND => NULL;    CallHim: PROCEDURE [hash: SymbolHash.Hash] =      BEGIN      d: CPDef.DReg ¬ Inline.LowHalf[SymbolHash.GetInfo[dRegSymbols, hash]];      proc[SymbolHash.GetString[dRegSymbols, hash], d];      END;    SymbolHash.EnumerateEntries[dRegSymbols, CallHim];    END;      EnumerateARegSymbols: PUBLIC ENTRY PROCEDURE [proc: PROCEDURE [LONG STRING, CPDef.AReg]] =    BEGIN ENABLE UNWIND => NULL;    CallHim: PROCEDURE [hash: SymbolHash.Hash] =      BEGIN      a: CPDef.AReg ¬ Inline.LowHalf[SymbolHash.GetInfo[aRegSymbols, hash]];      proc[SymbolHash.GetString[aRegSymbols, hash], a];      END;    SymbolHash.EnumerateEntries[aRegSymbols, CallHim];    END;      EnumerateMap: PUBLIC ENTRY PROCEDURE [    proc: PROCEDURE [CPDef.RealCS, CPSymbol.VirturalCS, CPDef.IBDisp, CPDef.MDR]] =    BEGIN ENABLE UNWIND => NULL;    FOR real: CPDef.RealCS IN CPDef.RealCS DO      p: LONG POINTER TO Info;      bank: CPDef.Bank;      wordInBank: WordInBank;      [bank, wordInBank] ¬ SplitReal[real];      IF info[bank] = NIL THEN LOOP;      p ¬ @info[bank][wordInBank];      IF ~p.valid THEN LOOP;      proc[real, p.virtural, p.ibdisp, p.mdr];      ENDLOOP;    END;      SplitReal: PROCEDURE [real: CPDef.RealCS] RETURNS [bank: CPDef.Bank, wordInBank: WordInBank] =    BEGIN    temp: CPDef.BankAndWordsPerBank = LOOPHOLE[real];    RETURN[temp.bank, temp.wordInBank];    END;    BeSureInfoExists: PROCEDURE [bank: CPDef.Bank, wordInBank: WordInBank] =    BEGIN    IF info[bank] # NIL THEN RETURN;    info[bank] ¬ z.NEW[ARRAY WordInBank OF Info];    info[bank]­ ¬ ALL [[FALSE, , , ]];    END;      SplitVirt: PROCEDURE [virt: CPSymbol.VirturalCS] RETURNS [bank: CPDef.Bank, wordInBank: WordInBank] =    BEGIN    temp: CPDef.BankAndWordsPerBank = LOOPHOLE[virt];    RETURN[temp.bank, temp.wordInBank];    END;    BeSureInverseExists: PROCEDURE [bank: CPDef.Bank, wordInBank: WordInBank] =    BEGIN    IF csInverse[bank] # NIL THEN RETURN;    csInverse[bank] ¬ z.NEW[ARRAY WordInBank OF SymbolHash.Hash];    csInverse[bank]­ ¬ ALL [SymbolHash.nullHash];    END;      RegOutOfRange: PROCEDURE =    BEGIN    foo: BOOLEAN ¬ TRUE;    IF foo THEN ERROR Error["Register number out of range. (SymbolImpl)"L];    END;      ClearSymbolTable[];  END.  -- Log:-- JAC   	 8-Jan-85 17:34:32	.U => .MDu and .V => .MDv
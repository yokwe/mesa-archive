-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. --Last edit by JAC     17-Dec-84 15:50:57 DIRECTORY  Ascii USING [CR, TAB],  String USING [AppendChar, AppendString, EqualString],  DsyAssembler USING [EofChar, Flagword, MyString, MyStringPtr, sizeArgArray],  DsyControl USING [argBuf, numArgs],  DsyFile USING [LogErrAndSrcLines, LogErrArgAndSrcLines, LogLine],  DsyModule USING [GetNextProcessChar];DsyPhraseImpl: PROGRAM IMPORTS String, DsyControl, DsyFile, DsyModule EXPORTS DsyModule  =  BEGIN OPEN DsyAssembler;  AdvanceargBuffer: PROCEDURE [    argInxP: LONG POINTER TO CARDINAL [0..DsyAssembler.sizeArgArray],    curSP: LONG POINTER TO LONG STRING] =    BEGIN    IF argInxP­ = DsyAssembler.sizeArgArray THEN {      DsyFile.LogErrArgAndSrcLines[        "Macro has Too many args"L, DsyControl.argBuf[0]]}    ELSE      BEGIN      DsyControl.numArgs ¬ argInxP­ ¬ argInxP­ + 1;      curSP­ ¬ DsyControl.argBuf[argInxP­];      curSP­.length ¬ 0;      END;    END;  -- end of procedure AdvanceargBuffer  AppendStr: PROCEDURE [curS: LONG STRING, char: CHARACTER] RETURNS [BOOLEAN] =    INLINE    BEGIN    IF curS.length >= curS.maxlength THEN {      DsyFile.LogErrArgAndSrcLines["String too long"L, curS]; RETURN[TRUE]}    ELSE String.AppendChar[curS, char];    RETURN[FALSE];    END;  -- end AppendStr  BreakPhraseArg: PUBLIC PROCEDURE [myS: MyStringPtr] RETURNS [flags: Flagword] =  --process an argument input line (within brackets in input line)    BEGIN    char: CHARACTER;    argInx: CARDINAL [0..DsyAssembler.sizeArgArray] ¬ 0;    bCount, pCount: CARDINAL ¬ 0;    curS: LONG STRING ¬ DsyControl.argBuf[0];    flags ¬ Flagword[];    DsyControl.numArgs ¬ 0;    curS.length ¬ 0;    IF myS.String = NIL THEN RETURN;    DO      BEGIN      SELECT char ¬ Nextch[myS] FROM        EofChar => RETURN;        ', =>          IF pCount = 0 AND bCount = 1 THEN AdvanceargBuffer[@argInx, @curS]          ELSE GOTO Out;        IN ['0..'9] =>          BEGIN          IF flags.FirstChar THEN flags.LeadDigit ¬ TRUE;          flags.FirstChar ¬ FALSE;          GOTO Out;          END;        '[ =>          BEGIN          IF flags.FirstChar THEN            BEGIN flags.LeadBrkt ¬ TRUE; flags.FirstChar ¬ FALSE; GOTO Out; END          ELSE            BEGIN            bCount ¬ bCount + 1;            IF bCount # 1 THEN GOTO Out            ELSE              BEGIN flags.HasArgs ¬ TRUE; AdvanceargBuffer[@argInx, @curS]; END;            END;          END;        '] =>          BEGIN          IF flags.LeadBrkt THEN BEGIN flags.LeadBrkt ¬ FALSE; GOTO Out; END;          IF bCount = 1 THEN RETURN ELSE BEGIN bCount ¬ bCount - 1; GOTO Out; END;          END;        '( => BEGIN pCount ¬ pCount + 1; IF pCount # 0 THEN GOTO Out; END;        ') => BEGIN IF pCount # 1 THEN GOTO Out ELSE pCount ¬ pCount - 1; END;	'- =>	  IF bCount # 0 THEN  {	    IF curS.length # 0 THEN 	      AdvanceargBuffer[@argInx, @curS];	    IF AppendStr[curS, char] THEN flags.Error ¬ TRUE;	    AdvanceargBuffer[@argInx, @curS]}	  ELSE GOTO Out;        ENDCASE => GOTO Out;      EXITS        Out =>          BEGIN          flags.FirstChar ¬ FALSE;          IF AppendStr[curS, char] THEN flags.Error ¬ TRUE;          IF flags.Error THEN EXIT;          END;      END;      ENDLOOP;    END;  -- end BreakPhraseArg  BreakPhraseMain: PUBLIC PROCEDURE [myS: MyStringPtr] RETURNS [flags: Flagword] =  --process the input line    BEGIN    char: CHARACTER;    argInx: CARDINAL [0..DsyAssembler.sizeArgArray] ¬ 0;  --current position in argBuf    bCount: CARDINAL ¬ 0;  --bracket count    pCount: CARDINAL ¬ 0;  --parenthesis count     curS: LONG STRING ¬ DsyControl.argBuf[0];  --Note that the contents of argBuf is destroyed upon entry to this procedure    flags ¬ Flagword[];    DsyControl.numArgs ¬ 0;    curS.length ¬ 0;    DO      BEGIN      IF myS = NIL THEN char ¬ DsyModule.GetNextProcessChar[]      ELSE {char ¬ Nextch[myS]; IF char = EofChar THEN RETURN};      SELECT char FROM  -- character handling same in arrow clause or not        Ascii.CR => LOOP;        EofChar =>          BEGIN          IF pCount # 0 OR bCount # 0 THEN {            DsyFile.LogErrAndSrcLines["Unexpected EOF"L]; flags.Error ¬ TRUE};          flags.Eof ¬ TRUE;          RETURN;          END;        ', =>          BEGIN          IF flags.FirstChar THEN LOOP;          IF pCount = 0 AND bCount = 0 THEN {            IF curS.length = 0 THEN DsyControl.numArgs ¬ DsyControl.numArgs - 1;            RETURN};          IF pCount = 0 AND bCount = 1 THEN            BEGIN            IF NOT flags.ArrowClause OR curS.length # 0 THEN              AdvanceargBuffer[@argInx, @curS];            END          ELSE GOTO Out;          END;        '; =>          IF pCount # 0 OR bCount # 0 THEN            BEGIN            DsyFile.LogErrAndSrcLines["Unexepcted semicolon"L];            flags.Error ¬ TRUE;            RETURN;            END          ELSE BEGIN flags.Semi ¬ TRUE; RETURN; END;        ': =>          BEGIN 	  IF argInx # 0 THEN DsyFile.LogErrAndSrcLines[	    "Illegal label.  May be missing a semicolon on previous/current line."L];	  IF pCount = 0 AND bCount = 0 THEN flags.Label ¬ TRUE; 	  RETURN; 	  END;        '! => BEGIN curS.length ¬ 0; flags ¬ Flagword[]; LOOP; END;        IN ['0..'9] =>          BEGIN          IF flags.FirstChar THEN flags.LeadDigit ¬ TRUE;          flags.FirstChar ¬ FALSE;          GOTO Out;          END;        '[ =>          BEGIN          IF flags.FirstChar THEN            BEGIN flags.LeadBrkt ¬ TRUE; flags.FirstChar ¬ FALSE; GOTO Out; END          ELSE            BEGIN            IF bCount = 0 THEN              BEGIN              flags.HasArgs ¬ TRUE;	      IF curS.length # 0 THEN AdvanceargBuffer[@argInx, @curS];               END;            bCount ¬ bCount + 1;            IF bCount # 1 THEN GOTO Out;            END;          END;        '] =>          BEGIN          IF flags.LeadBrkt THEN BEGIN flags.LeadBrkt ¬ FALSE; GOTO Out; END;                    SELECT bCount FROM            0 =>	      BEGIN              DsyFile.LogErrArgAndSrcLines[                "Unbalanced brackets"L, DsyControl.argBuf[0]];              flags.Error ¬ TRUE;              END;	    1 => bCount ¬ bCount - 1;            > 1 => BEGIN bCount ¬ bCount - 1; GOTO Out; END;	    	    ENDCASE;            END;        '¬ =>          IF pCount = 0 AND bCount = 0 THEN            BEGIN            flags.ArrowClause ¬ TRUE;            IF curS.length # 0 THEN AdvanceargBuffer[@argInx, @curS];            IF AppendStr[curS, '¬] THEN flags.Error ¬ TRUE;            AdvanceargBuffer[@argInx, @curS];            END          ELSE GOTO Out; 	137C =>  --pre Mesa 11.1 backarrow          IF pCount = 0 AND bCount = 0 THEN            BEGIN            flags.ArrowClause ¬ TRUE;            IF curS.length # 0 THEN AdvanceargBuffer[@argInx, @curS];            IF AppendStr[curS, '¬] THEN flags.Error ¬ TRUE;            AdvanceargBuffer[@argInx, @curS];            END          ELSE GOTO Out;        ENDCASE =>          BEGIN  -- process remaining characters          IF flags.ArrowClause THEN            SELECT char FROM  -- chars in arrow clauses              '+, '&, '~ =>                BEGIN                IF curS.length # 0 THEN AdvanceargBuffer[@argInx, @curS];                IF AppendStr[curS, char] THEN flags.Error ¬ TRUE;                AdvanceargBuffer[@argInx, @curS];                END;	      '- => 	        IF bCount # 2 THEN {  --bCount = 2 and - encounted => STK[-1], STK[-2]		  IF curS.length # 0 THEN   		    AdvanceargBuffer[@argInx, @curS];		  IF AppendStr[curS, char] THEN flags.Error ¬ TRUE;		  AdvanceargBuffer[@argInx, @curS]}		ELSE IF AppendStr[curS, char] THEN flags.Error ¬ TRUE;	      Ascii.TAB => LOOP;              < 041C, '(, ') =>                BEGIN                IF curS.length = 0 THEN LOOP;                AdvanceargBuffer[@argInx, @curS];                END;              ENDCASE => GOTO Out          ELSE            SELECT char FROM  -- chars not in arrow clauses              < 041C => LOOP;	      '- =>	        IF bCount # 2 THEN {  --bCount = 2 and - encounted => STK[-1], STK[-2]		  IF curS.length # 0 THEN   		    AdvanceargBuffer[@argInx, @curS];		  IF AppendStr[curS, char] THEN flags.Error ¬ TRUE;		  AdvanceargBuffer[@argInx, @curS]}		ELSE IF AppendStr[curS, char] THEN flags.Error ¬ TRUE;	      '+ => --+'s are illegal except in arithmetic clauses.  Bermuda needs them to be special characters	        BEGIN		DsyFile.LogErrAndSrcLines["Unexpected +"L];		flags.Error ¬ TRUE;		END;  --ignore the character              '( => BEGIN pCount ¬ pCount + 1; IF pCount # 1 THEN GOTO Out; END;              ') =>                BEGIN                IF pCount = 0 THEN                  BEGIN                  DsyFile.LogErrArgAndSrcLines[                    "Unbalanced parenthesis"L, DsyControl.argBuf[0]];                  flags.Error ¬ TRUE;                  pCount ¬ 1;                  END;                pCount ¬ pCount - 1;                IF pCount # 0 THEN GOTO Out;                END;              --  ENDCASE   feed char thru              ENDCASE => BEGIN flags.FirstChar ¬ FALSE; GOTO Out; END;          END;      EXITS        Out =>          BEGIN          IF AppendStr[curS, char] THEN flags.Error ¬ TRUE;          IF flags.Error THEN EXIT;          END;      END;      ENDLOOP;    END;  -- end BreakPhraseMain  Nextch: PROCEDURE [myS: MyStringPtr] RETURNS [char: CHARACTER] = INLINE    BEGIN    IF myS.NextChar >= myS.String.length THEN RETURN[EofChar];    char ¬ myS.String[myS.NextChar];    myS.NextChar ¬ myS.NextChar + 1;    END;  -- end Nextch  SkipUntil: PUBLIC PROCEDURE [str: LONG STRING] =    BEGIN    char: CHARACTER;    msg: LONG STRING ¬ [150];    s: LONG STRING ¬ [100];    String.AppendString[msg, "Skipping until  "L];    String.AppendString[msg, str];    DsyFile.LogLine[msg];    DO      char ¬ DsyModule.GetNextProcessChar[];      SELECT char FROM        EofChar => {DsyFile.LogErrAndSrcLines["EOF while skipping"L]; RETURN};        ';, < 041C => s.length ¬ 0;        '! => IF String.EqualString[s, str] THEN EXIT;        ENDCASE => IF s.length < 100 THEN String.AppendChar[s, char];      ENDLOOP;    msg.length ¬ 0;    String.AppendString[msg, str];    String.AppendString[msg, "  Found"L];    DsyFile.LogLine[msg];    END;  -- end SkipUntil  END... --Log of last edits:--JAC   	 5-Nov-84 14:32:04	fixed arrows for Mesa 11.1--JAC   	28-Nov-84 21:20:00	tabs don't advance the argBuf even if in arrow clause--JAC   	 7-Dec-84 18:21:33	+'s are illegal expect in arithmetic clauses--JAC   	17-Dec-84 15:51:07	argInx # 0 if label => error
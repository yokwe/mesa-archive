-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. -- Last edit by JAC   	 5-Nov-84 14:22:51-- The purpose of this module is to allocate space for the macro hash table.      DIRECTORY  Heap USING [Create, Delete],  DsyAssembler,  DsyModule;DsyMTSpaceImpl: PROGRAM IMPORTS Heap EXPORTS DsyModule =  BEGIN  OPEN DsyAssembler, DsyModule;  -- GLOBAL VARIABLES  MTable: TYPE = ARRAY [0..MHSize) OF MEntryPtr;  mTable: LONG POINTER TO MTable;  MHSize: CARDINAL = 457;  -- should be a prime  MTtempHeap: PUBLIC UNCOUNTED ZONE;  InitGlobalMTSpace: PUBLIC PROCEDURE =    BEGIN mTable ¬ NIL; MTtempHeap ¬ NIL; InitMTHeap[16, 8]; END;  --  of Procedure InitGlobalMTSpace  BuildHashCode: PROCEDURE [str: LONG STRING] RETURNS [hc: CARDINAL] = INLINE    BEGIN    i: CARDINAL;    hc ¬ 0;    FOR i IN [0..str.length) DO hc ¬ (2*hc) + LOOPHOLE[str[i], CARDINAL]; ENDLOOP;    hc ¬ (hc + (hc/16)) MOD MHSize;    RETURN[hc];    END;  --  of Procedure BuildHashCode  DisplayM: PUBLIC PROCEDURE [proc: PROCEDURE [MEntryPtr]] =    BEGIN    i: CARDINAL;    p: MEntryPtr;    pp: MEntryPtr;    FOR i IN [0..MHSize) DO      p ¬ mTable[i];      UNTIL p = NIL DO pp ¬ p.next; proc[p]; p ¬ pp; ENDLOOP;      ENDLOOP;    END;  --  of Procedure DisplayM  EqualString: PROCEDURE [str1, str2: LONG STRING] RETURNS [BOOLEAN] = INLINE    BEGIN    i: CARDINAL;    IF str1.length # str2.length THEN RETURN[FALSE];    FOR i IN [0..str1.length) DO IF str1[i] # str2[i] THEN RETURN[FALSE]; ENDLOOP;    RETURN[TRUE];    END;  --  of Procedure EqualString  FindM: PUBLIC PROCEDURE [str: LONG STRING] RETURNS [m: MEntryPtr] =    BEGIN    hashCode: CARDINAL;    first: BOOLEAN ¬ TRUE;    p: MEntryPtr;    pold: MEntryPtr;    ptem: MEntryPtr;    hashCode ¬ BuildHashCode[str];    p ¬ mTable[hashCode];    UNTIL p = NIL DO      IF EqualString[p.key, str] THEN        BEGIN        IF NOT first THEN          BEGIN          ptem ¬ mTable[hashCode];          mTable[hashCode] ¬ p;          pold.next ¬ p.next;          p.next ¬ ptem;          END;        RETURN[p];        END;      pold ¬ p;      p ¬ p.next;      first ¬ FALSE;      ENDLOOP;    RETURN[NIL];    END;  -- of procedure FindM  InitMTHeap: PUBLIC PROCEDURE [initPages, incrPages: CARDINAL] =    BEGIN    i: CARDINAL;    IF MTtempHeap # NIL THEN Heap.Delete[MTtempHeap];    MTtempHeap ¬ Heap.Create[      initial: initPages, increment: incrPages];    mTable ¬ MTtempHeap.NEW[MTable];    FOR i IN [0..MHSize) DO mTable[i] ¬ NIL; ENDLOOP;    END;  -- end InitMTHeap  InsertM: PUBLIC PROCEDURE [m: MEntryPtr] RETURNS [error: BOOLEAN] =    BEGIN    hashCode: CARDINAL;    mp: LONG POINTER TO MEntryPtr;    p: MEntryPtr;    hashCode ¬ BuildHashCode[m.key];    p ¬ mTable[hashCode];    mp ¬ @mTable[hashCode];    UNTIL p = NIL DO      IF EqualString[p.key, m.key] THEN RETURN[TRUE];      mp ¬ @p.next;      p ¬ p.next;      ENDLOOP;    mp­ ¬ m;    RETURN[FALSE];    END;  -- of procedure InsertM  ReleaseMTSpace: PUBLIC PROCEDURE =    BEGIN IF MTtempHeap # NIL THEN Heap.Delete[MTtempHeap]; MTtempHeap ¬ NIL; END;  -- end ReleaseMTSpace  -- Mainline  END...--Log of last edits:--JAC   	 5-Nov-84 14:23:02	fixed arrows for Mesa 11.1
-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. -- Last edit by JAC   		10-Jan-85 11:43:39-- CPSourceEvalImpl.mesa, AYC   , 11-Dec-84  9:38:35-- from CPEvalImpl.mesa,  AYC   , 14-Aug-84 14:53:38--DIRECTORY  Ascii USING [CR, LF, FF, SP, TAB],  Inline USING [LowHalf],  String USING [AppendString, Equivalent, SubString, SubStringDescriptor],    CPDef USING [    AReg, DReg, IBDisp, Link, Map, MDR, OtherReg, RealCS, RealMemory, RReg,    ROffset, sizeOfCS, VirturalMemory],  CPSourceSymbol USING [    Error, LookupInCSTable, LookupInRRegTable, LookupInDRegTable,    LookupInARegTable, nullRealCS, nullVirturalCS, RealToVirturalCS, Symbol,    Type, VirturalCS, VirturalToRealCS],  Evaluate USING [Error, EvaluateSubString, Type, unspecified, Value],  StringExtras USING [StringToLongCardinal];CPSourceEvalImpl: PROGRAM  IMPORTS Inline, String, CPSourceSymbol, Evaluate, StringExtras  EXPORTS CPSourceSymbol =  BEGIN    GetPcAndFlags: PUBLIC PROCEDURE [s: LONG STRING]    RETURNS [pc: CPDef.RealCS, ibdisp: CPDef.IBDisp, mdr: CPDef.MDR] =    BEGIN    symbol: CPSourceSymbol.Symbol ¬ Eval[s];    WITH symbol SELECT FROM      number =>        BEGIN	virt: CPSourceSymbol.VirturalCS;	pc ¬ Inline.LowHalf[n];	[virt, ibdisp, mdr] ¬ CPSourceSymbol.RealToVirturalCS[pc];	IF virt = CPSourceSymbol.nullVirturalCS THEN ERROR CPSourceSymbol.Error["Illegal Virtual Address"L];	END;      realCS =>        BEGIN	virt: CPSourceSymbol.VirturalCS;	pc ¬ real;	[virt, ibdisp, mdr] ¬ CPSourceSymbol.RealToVirturalCS[pc];	IF virt = CPSourceSymbol.nullVirturalCS THEN ERROR CPSourceSymbol.Error["Illegal Real Address"L];	END;      virtCS =>        BEGIN	[pc, ibdisp, mdr] ¬ CPSourceSymbol.VirturalToRealCS[virt];	IF pc = CPSourceSymbol.nullRealCS THEN ERROR CPSourceSymbol.Error["Can't translate to a real CS address"L];	END;      ENDCASE => ERROR CPSourceSymbol.Error["CP ControlStore address required"L];    END;	  Eval: PUBLIC PROCEDURE [s: LONG STRING] RETURNS [CPSourceSymbol.Symbol] =    BEGIN    type: Evaluate.Type;    value: Evaluate.Value;    shortValue: CARDINAL;    pointer: LONG POINTER;    smytype: CPSourceSymbol.Type;    ss: String.SubStringDescriptor;        IF s = NIL OR s.length = 0 THEN ERROR CPSourceSymbol.Error["...Operand required"];    ss ¬ [base: s, offset: 0, length: s.length];    TrimSubString[@ss];    [type, value] ¬ Evaluate.EvaluateSubString[@ss, Lookup !        Evaluate.Error => ERROR CPSourceSymbol.Error[reason] ];    shortValue ¬ Inline.LowHalf[value];    pointer ¬ LOOPHOLE[value];    smytype ¬ IF type = Evaluate.unspecified THEN number ELSE LOOPHOLE[type];    SELECT smytype FROM      number => RETURN[[number[value]]];      link =>        BEGIN	IF value ~IN CPDef.Link THEN RegOutOfRange[];        RETURN[[link[shortValue]]];	END;      realCS =>        BEGIN        IF shortValue >= CPDef.sizeOfCS THEN AddressOutOfRange[];        RETURN[[realCS[shortValue]]];	END;      virtCS => RETURN[[virtCS[shortValue]]];      rReg =>        BEGIN	IF value - CPDef.ROffset ~IN CPDef.RReg THEN RegOutOfRange[];	RETURN[[rReg[shortValue]]];	END;      dReg =>        BEGIN	IF value ~IN CPDef.DReg THEN RegOutOfRange[];	RETURN[[dReg[shortValue]]];	END;      aReg =>        BEGIN	IF value ~IN CPDef.AReg THEN RegOutOfRange[];	RETURN[[aReg[shortValue]]];	END;      map =>        BEGIN	IF value ~IN CPDef.Map THEN AddressOutOfRange[];	RETURN[[map[shortValue]]];	END;      real => RETURN[[real[pointer]]];      virt => RETURN[[virt[pointer]]];      other =>        BEGIN	IF LOOPHOLE[shortValue,CPDef.OtherReg] ~IN CPDef.OtherReg THEN OutOfRange[];        RETURN[[other[LOOPHOLE[shortValue]]]];	END;      ENDCASE => ERROR;    END;        Lookup: PROCEDURE [s: LONG STRING] RETURNS [type: Evaluate.Type, value: Evaluate.Value] =    BEGIN    ok: BOOLEAN;    virt: CPSourceSymbol.VirturalCS;    r: CPDef.RReg;    d: CPDef.DReg;    a: CPDef.AReg;    symbol: CPSourceSymbol.Symbol;    [ok, virt] ¬ CPSourceSymbol.LookupInCSTable[s];    IF ok THEN RETURN[LOOPHOLE[CPSourceSymbol.Type[virtCS]], LONG[virt]];    [ok, r] ¬ CPSourceSymbol.LookupInRRegTable[s];    IF ok THEN RETURN[LOOPHOLE[CPSourceSymbol.Type[rReg]], LONG[r + CPDef.ROffset]];    [ok, d] ¬ CPSourceSymbol.LookupInDRegTable[s];    IF ok THEN RETURN[LOOPHOLE[CPSourceSymbol.Type[dReg]], LONG[d]];    [ok, a] ¬ CPSourceSymbol.LookupInARegTable[s];    IF ok THEN RETURN[LOOPHOLE[CPSourceSymbol.Type[aReg]], LONG[a]];    [ok, symbol] ¬ StringAsSpecial[s];    IF ok THEN      BEGIN      type ¬ LOOPHOLE[symbol.type];      WITH symbol SELECT FROM        number => value ¬ n;        link => value ¬ link;        realCS => value ¬ real;        virtCS => value ¬ virt;        rReg => value ¬ r;        dReg => value ¬ d;        aReg => value ¬ a;        map => value ¬ map;        real => value ¬ LOOPHOLE[real];        virt => value ¬ LOOPHOLE[virt];        other => value ¬ LONG[LOOPHOLE[other]];        ENDCASE => ERROR;      RETURN;      END;    [ok, value] ¬ StringExtras.StringToLongCardinal[s];    IF ok THEN RETURN[Evaluate.unspecified, value];    BEGIN    temp: LONG STRING = [100];    String.AppendString[temp, "Undefined Symbol: "L];    String.AppendString[temp, s];    ERROR CPSourceSymbol.Error[temp];    END;    END;  StringAsSpecial: PROCEDURE [s: LONG STRING] RETURNS [BOOLEAN, CPSourceSymbol.Symbol] =    BEGIN    SELECT TRUE FROM      String.Equivalent[s, ".CR"L] => RETURN[TRUE, [realCS[0]]];      String.Equivalent[s, ".CV"L] => RETURN[TRUE, [virtCS[0]]];      String.Equivalent[s, ".R"L] => RETURN[TRUE, [rReg[0]]];      String.Equivalent[s, ".D"L] => RETURN[TRUE, [dReg[0]]];      String.Equivalent[s, ".A"L] => RETURN[TRUE, [aReg[0]]];      String.Equivalent[s, ".RTChigh"L] => RETURN[TRUE, [other[RTChigh]]];      String.Equivalent[s, ".RTClow"L] => RETURN[TRUE, [other[RTClow]]];      String.Equivalent[s, ".Q"L] => RETURN[TRUE, [other[qReg]]];      String.Equivalent[s, ".MDu"L] => RETURN[TRUE, [other[uReg]]];      String.Equivalent[s, ".MDv"L] => RETURN[TRUE, [other[vReg]]];      String.Equivalent[s, ".CSBANK"L] => RETURN[TRUE, [other[CSBank]]];      String.Equivalent[s, ".IB"L] => RETURN[TRUE, [other[Ib]]];      String.Equivalent[s, ".IBCTR"L] => RETURN[TRUE, [other[IBCtr]]];      String.Equivalent[s, ".MAP"L] => RETURN[TRUE, [map[0]]];      String.Equivalent[s, ".MR"L] => RETURN[TRUE, [real[NIL]]];      String.Equivalent[s, ".MV"L] => RETURN[TRUE, [virt[NIL]]];      String.Equivalent[s, ".PSCALER"L] => RETURN[TRUE, [other[PScaler]]];      String.Equivalent[s, ".CIP"L] => RETURN[TRUE, [other[CIP]]];      String.Equivalent[s, ".NIB"L] => RETURN[TRUE, [aReg[0]]];      String.Equivalent[s, ".CVN"L] => RETURN[TRUE, [other[CVN]]];      String.Equivalent[s, ".STKPTR"L] => RETURN[TRUE, [other[StkPtr]]];      String.Equivalent[s, ".STK[1]"L] => RETURN[TRUE, [other[StkP1]]];      String.Equivalent[s, ".STK[0]"L] => RETURN[TRUE, [other[StkP0]]];      String.Equivalent[s, ".STK[~1]"L] => RETURN[TRUE, [other[StkM1]]];      String.Equivalent[s, ".STK[~2]"L] => RETURN[TRUE, [other[StkM2]]];      String.Equivalent[s, ".LINK"L] => RETURN[TRUE, [link[0]]];      String.Equivalent[s, "L0"L] => RETURN[TRUE, [link[0]]];      String.Equivalent[s, "L1"L] => RETURN[TRUE, [link[1]]];      String.Equivalent[s, "L2"L] => RETURN[TRUE, [link[2]]];      String.Equivalent[s, "L3"L] => RETURN[TRUE, [link[3]]];      ENDCASE => RETURN[FALSE, ];    END;        AddressOutOfRange: PROCEDURE =    BEGIN    foo: BOOLEAN ¬ TRUE;    IF foo THEN ERROR CPSourceSymbol.Error["Address out of range. (CPSourceEvalImpl)"L];    END;      RegOutOfRange: PROCEDURE =    BEGIN    foo: BOOLEAN ¬ TRUE;    IF foo THEN ERROR CPSourceSymbol.Error["Register number out of range. (CPSourceEvalImpl)"L];    END;      OutOfRange: PROCEDURE =    BEGIN    foo: BOOLEAN ¬ TRUE;    IF foo THEN ERROR CPSourceSymbol.Error["No more implicit register definition. (CPSourceEvalImpl)"L];    END;      TrimSubString: PROCEDURE [ss: String.SubString] =    BEGIN    FOR i: CARDINAL IN [ss.offset..ss.offset + ss.length) DO      IF ~BlankCharacter[ss.base[i]] THEN        BEGIN  --  remove leading blanks        ss.length ¬ ss.length - (i - ss.offset);        ss.offset ¬ i;	EXIT;	END;      REPEAT FINISHED =>        BEGIN  --all blanks	ss.length ¬ 0;        RETURN;	END;      ENDLOOP;    FOR i: CARDINAL DECREASING IN [ss.offset..ss.offset + ss.length) DO      IF ~BlankCharacter[ss.base[i]] THEN        BEGIN  --  remove trailing blanks        ss.length ¬ ss.length - (ss.offset + ss.length - 1 - i);	EXIT;	END;      ENDLOOP;    END;      BlankCharacter: PROCEDURE [c: CHARACTER] RETURNS [BOOLEAN] =    BEGIN    SELECT c FROM      Ascii.FF, Ascii.SP, Ascii.CR, Ascii.LF, Ascii.TAB => RETURN[TRUE];      ENDCASE => RETURN[FALSE];    END;    END.  -- Log:-- JAC   	 8-Jan-85 17:33:16	.U => .MDu and .V => .MDv-- JAC   	10-Jan-85 11:43:25	spell virtual correctly
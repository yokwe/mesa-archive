-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. -- Last edit by JAC   		 4-Aug-86 12:22:09-- CPKernelDaisy.mesa,  AYC   , 14-Dec-84 17:15:15-- from CPKernelDLion.mesa, HGM,21-Jan-84 14:46:15--DIRECTORY  Environment USING [bytesPerPage, bytesPerWord, Block, Byte],  Format USING [Blank, Line, Number, StringProc],  Heap USING [systemZone],  Inline USING [BITNOT, BITOR, BITSHIFT, HighByte, HighHalf, LowByte, LowHalf],  Process USING [MsecToTicks, Pause],  Runtime USING [GetTableBase],  UserInput USING [UserAbort],  Bindweed USING [AddressType, Error, maxData, ReadIOByte, ReadMemoryBlock,     Sequence, ResetCP, --ShiftReg,-- StartCP, StopCP, WriteIOByte, WriteMemoryBlock],  CPCommand USING [SetPC],  CPDef USING [Bank, BankAndWordsPerBank, IBDspB, MiNum, NopDspB, numberOfBanks, RealCS,    StartAddr, StartAddrPlusOne, wordsPerBank],  CPKernel USING [AtBreak, Error, optionsData, FixParity, ShiftReg, State, StopID, StopInfoType, UpdateLoadBankItem],  CPKernelDef,  CPKernelOps USING [    --AddressOutOfRange,-- DataOutOfRange, LoadFromMemory, LoadOverlay,    PrepareToContinueFromBreak, PrepareToContinueFromStop, ReadCSInternal,    SaveCurrentBreakID, WriteCSInternal],  CPuFormat,  DoveInputOutput USING [OpieAddressType],  KernelMicrocode USING [DaisyKernel, KernelOverlay, Restore, SaveMD];CPKernelDaisy: MONITOR  IMPORTS    --DoveInputOutput,-- Format, Heap, Inline, Process, Runtime, UserInput,    Bindweed, CPCommand, CPKernel, CPKernelOps, CPuFormat, KernelMicrocode  EXPORTS CPKernel, CPKernelOps   SHARES DoveInputOutput =  BEGIN OPEN CPKernelDef, CPuFormat;    z: UNCOUNTED ZONE = Heap.systemZone;  MaxBindweedSpace: LONG CARDINAL =  1FFFFFH --0FF000H--; -- is this true?  it certainly is the maximum address that the CP can access but Bindweed may have a different limit  maxWords: CARDINAL = (Bindweed.maxData-1)/Environment.bytesPerWord;    banksThisMachine: CARDINAL ¬ 0;  currentBank, savedBank: PUBLIC CARDINAL ¬ 0;  kernelLoaded: BOOLEAN ¬ FALSE;  state: CPKernel.State ¬ dead;    WordInBank: TYPE = [0..CPDef.wordsPerBank);  ShiftRegister: CPKernel.ShiftReg ¬ [0,0,0,0,0,0,FALSE,FALSE,FALSE];  Debug: CPKernel.ShiftReg ¬ [0,0,0,0,0,0,FALSE,FALSE,FALSE];  StopInfo: CPKernel.StopInfoType ¬ [ShiftRegister,];  seqptr: LONG POINTER TO Bindweed.Sequence  			¬ z.NEW[Bindweed.Sequence[Bindweed.maxData]];        InKernel: PUBLIC ENTRY PROCEDURE RETURNS [BOOLEAN] =    BEGIN ENABLE UNWIND => NULL;    RETURN[SELECT state FROM      booted => TRUE,      dead => FALSE,      stopped => TRUE,      running => FALSE,      cpBreak => TRUE,      ENDCASE => ERROR ];    END;        SetNewState: PUBLIC PROCEDURE [new: CPKernel.State] =    BEGIN    state ¬ new;    END;  GetState: PUBLIC ENTRY PROCEDURE RETURNS [CPKernel.State] =    BEGIN    RETURN[state];    END;  GetStateInternal: PUBLIC INTERNAL PROCEDURE RETURNS [CPKernel.State] =    BEGIN    RETURN[state];    END;  ResetShiftReg: PROCEDURE =    BEGIN    ShiftRegister ¬ [0,0,0,0,00,,FALSE,FALSE,FALSE];    StopInfo ¬ [ShiftRegister,];    END;  GetStopInfo: PUBLIC PROCEDURE    RETURNS [CPDef.RealCS, CPDef.RealCS, BOOLEAN, BOOLEAN, BOOLEAN, CPuFormat.mi] =    BEGIN    RETURN[StopInfo.shiftReg.INIA + StopInfo.shiftReg.BS * CPDef.wordsPerBank,           StopInfo.shiftReg.INIAHold +	      StopInfo.shiftReg.BSHold * CPDef.wordsPerBank,	   StopInfo.shiftReg.EOPTrap,	   StopInfo.shiftReg.ExInt,	   StopInfo.shiftReg.CSParity, LOOPHOLE[StopInfo.MI, CPuFormat.mi]];    END;      SetStopShiftReg: PUBLIC PROCEDURE [miNum: CPDef.MiNum, pc: CPDef.RealCS]=    BEGIN ENABLE UNWIND => NULL;    data: CPDef.BankAndWordsPerBank = LOOPHOLE[pc];    IF pc ~IN CPDef.RealCS THEN CPKernelOps.DataOutOfRange[];    SELECT miNum FROM      CPDef.StartAddr =>        BEGIN        StopInfo.shiftReg.BS ¬ data.bank;	StopInfo.shiftReg.INIA ¬ data.wordInBank;	END;      CPDef.StartAddrPlusOne =>        BEGIN	StopInfo.shiftReg.BSHold ¬ data.bank;	StopInfo.shiftReg.INIAHold ¬ data.wordInBank;	END;      ENDCASE => CPKernelOps.DataOutOfRange[];    END;   GetShiftReg: PUBLIC ENTRY PROCEDURE RETURNS [CPKernel.ShiftReg] =    BEGIN    RETURN[ShiftRegister];    END;      Timeout: PROCEDURE =    BEGIN SetNewState[dead]; ERROR CPKernel.Error["Timeout"L]; END;      BadChecksum: PROCEDURE =    BEGIN ERROR CPKernel.Error["Bad Checksum"L]; END;      UmbilicalNotWorking: PROCEDURE =    BEGIN SetNewState[dead]; ERROR CPKernel.Error["Umbilical not working"L]; END;  SetShiftReg: PUBLIC ENTRY PROCEDURE [miNum: CPDef.MiNum, pc: CPDef.RealCS] =    BEGIN ENABLE UNWIND => NULL;    SetShiftRegInternal[miNum, pc];    END;   SetShiftRegInternal: PUBLIC PROCEDURE [miNum: CPDef.MiNum, pc: CPDef.RealCS] =    BEGIN ENABLE UNWIND => NULL;    data: CPDef.BankAndWordsPerBank = LOOPHOLE[pc];    IF pc ~IN CPDef.RealCS THEN CPKernelOps.DataOutOfRange[];    SELECT miNum FROM      CPDef.StartAddr =>        BEGIN        ShiftRegister.BS ¬ data.bank;	ShiftRegister.INIA ¬ data.wordInBank;	END;      CPDef.StartAddrPlusOne =>        BEGIN	ShiftRegister.BSHold ¬ data.bank;	ShiftRegister.INIAHold ¬ data.wordInBank;	END;      ENDCASE => CPKernelOps.DataOutOfRange[];    END;   SetShiftRegflags: PUBLIC ENTRY PROCEDURE [EOPTrap: BOOLEAN, EXTInt: BOOLEAN, CSParity: BOOLEAN] =    BEGIN ENABLE UNWIND => NULL;    SetShiftRegflagsInternal[EOPTrap, EXTInt, CSParity];    END;   SetShiftRegflagsInternal: INTERNAL PROCEDURE [EOPTrap: BOOLEAN, EXTInt: BOOLEAN, CSParity: BOOLEAN] =    BEGIN ENABLE UNWIND => NULL;    ShiftRegister.EOPTrap ¬ EOPTrap;    ShiftRegister.ExInt ¬ EXTInt;    ShiftRegister.CSParity ¬ CSParity;    END;      GetShiftRegflags: PUBLIC ENTRY PROCEDURE RETURNS [EOPTrap: BOOLEAN, EXTInt: BOOLEAN, CSParity: BOOLEAN] =    BEGIN ENABLE UNWIND => NULL;    RETURN[ShiftRegister.EOPTrap, ShiftRegister.ExInt, ShiftRegister.CSParity];    END;   ProbeForStateChange: PUBLIC ENTRY PROCEDURE [log: Format.StringProc, arg: LONG POINTER] =--  need more work, (14-Aug-84 10:07:51, AYChen$)    BEGIN ENABLE UNWIND => NULL;    IF state = dead THEN RETURN;  -- Who cares what it's doing?    IF PollSiriusInternal[log, arg] THEN	BEGIN	savedBank ¬ currentBank ¬ ShiftRegister.BS; -- ReadBankInternal[];	CPKernelOps.SaveCurrentBreakID[];	SetNewState[cpBreak];	END;    END;    Boot: PUBLIC ENTRY PROCEDURE [log: Format.StringProc, arg: LONG POINTER] =    BEGIN ENABLE       BEGIN      Bindweed.Error =>         SELECT code FROM	  timeout => Timeout[];	  badCheckSum => BadChecksum[];	  ENDCASE => UmbilicalNotWorking[];      UNWIND => NULL;      END;    SetNewState[dead];    kernelLoaded ¬ FALSE;    currentBank ¬ savedBank ¬ 0;    banksThisMachine ¬ 1;    Bindweed.ResetCP[];    SaveRegitsters[log, arg];    CPKernelOps.LoadFromMemory[Runtime.GetTableBase[KernelMicrocode.KernelOverlay], 0];    SetNewState[booted];    ResetShiftReg[];    END;    HalfBoot: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE UNWIND => NULL;    SetNewState[dead];    kernelLoaded ¬ FALSE;    currentBank ¬ savedBank ¬ 0;    banksThisMachine ¬ 1;    SetNewState[booted];    END;    Reset: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE UNWIND => NULL;--  set kernel into idle    SetNewState[dead];    savedBank ¬ 0;    SetShiftRegInternal[CPDef.StartAddr,CPKernelDef.kLoop + savedBank * CPDef.wordsPerBank];    SetShiftRegInternal[CPDef.StartAddrPlusOne,CPKernelDef.kLoop + savedBank * CPDef.wordsPerBank];    SetNewState[stopped];    END;    LoadKernel: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE UNWIND => NULL;--    SetNewBank[0];    CPKernelOps.LoadFromMemory[Runtime.GetTableBase[KernelMicrocode.DaisyKernel], 0];    SetNewState[stopped];    kernelLoaded ¬ TRUE;    END;     LoadKernelHigh: PUBLIC ENTRY PROCEDURE [bank: CPDef.Bank] =--  a hook, load same kernel code into higher banks. (6-Jun-84 10:31:17, AYChen$)    BEGIN ENABLE UNWIND => NULL;--    SetNewBank[bank];    CPKernelOps.LoadFromMemory[Runtime.GetTableBase[KernelMicrocode.DaisyKernel], bank];    END;    Start: PUBLIC ENTRY PROCEDURE [log: Format.StringProc, arg: LONG POINTER, uPC, NextuPC: LONG STRING] =    BEGIN ENABLE UNWIND => NULL;    RestoreRegitsters[log, arg];    CPCommand.SetPC[log, arg, uPC, NextuPC];    SetNewBank[currentBank]; -- changed 0 to currentBank 28-Apr-87 15:52:33 JWF <<   CPKernelOps.LoadFromMemory[Runtime.GetTableBase[KernelMicrocode.DaisyKernel], 0];    kernelLoaded ¬ TRUE;  >>  --done in RestoreRegitsters now    StartSirius[];    SetNewState[running];    END;      ContinueAfterStop: PUBLIC ENTRY PROCEDURE [log: Format.StringProc, arg: LONG POINTER] =    BEGIN    MI: CPuFormat.MI;    mi: CPuFormat.mi;    holdAddress: CPDef.RealCS;    EOPTrap, EXTInt, CSParity: BOOLEAN;    RestoreRegitsters[log, arg];    [,holdAddress, EOPTrap, EXTInt, CSParity, mi] ¬ GetStopInfo[];    MI ¬ LOOPHOLE[mi, CPuFormat.MI];    MI.context.common.inia ¬ SplitReal[holdAddress].wordInBank;    CPKernelOps.PrepareToContinueFromStop[LOOPHOLE[MI, CPuFormat.mi]];    SetNewBank[savedBank]; -- Added 28-Apr-87 15:55:10 JWF--  SetShiftRegflagsInternal[EOPTrap, EXTInt, CSParity];      SetShiftRegInternal[CPDef.StartAddr, CPKernelDef.kContinue + savedBank * CPDef.wordsPerBank];    SetShiftRegInternal[CPDef.StartAddrPlusOne, CPKernelDef.kContinue+1 + savedBank * CPDef.wordsPerBank];--  Format.Text[log, "Start from Continue => "L, arg];--  DebugLog[log, arg, ShiftRegister];    StartSirius[];    SetNewState[running];    END;      ContinueAfterBreak: PUBLIC ENTRY PROCEDURE [log: Format.StringProc, arg: LONG POINTER, mi: CPuFormat.mi] =    BEGIN ENABLE UNWIND => NULL;    RestoreRegitsters[log, arg];    CPKernelOps.PrepareToContinueFromBreak[mi];--  SetShiftRegflagsInternal[FALSE, FALSE, FALSE];--  SetNewBank needs more work. (11-Jun-84 18:08:19, AYChen$)--  SetNewBank[0];--  SetupToGetBackToBank0[];    IF ~kernelLoaded THEN ERROR;    SetNewBank[savedBank];    SetShiftRegInternal[CPDef.StartAddr,CPKernelDef.kContinue + savedBank * CPDef.wordsPerBank];    SetShiftRegInternal[CPDef.StartAddrPlusOne,CPKernelDef.kContinue+1 + savedBank * CPDef.wordsPerBank];    StartSirius[];    SetNewState[running];    END;  SplitReal: PROCEDURE [real: CPDef.RealCS] RETURNS [bank: CPDef.Bank, wordInBank: WordInBank] =    BEGIN    temp: CPDef.BankAndWordsPerBank = LOOPHOLE[real];    RETURN[temp.bank, temp.wordInBank];    END;    RestoreRegitsters: INTERNAL PROCEDURE [log: Format.StringProc, arg: LONG POINTER] =    BEGIN    kernelLoaded ¬ FALSE;    CPKernelOps.LoadOverlay[Runtime.GetTableBase[KernelMicrocode.Restore]];    SetShiftRegInternal[CPDef.StartAddr,CPKernelDef.kEntry + savedBank * CPDef.wordsPerBank];    SetShiftRegInternal[CPDef.StartAddrPlusOne,CPKernelDef.kEntry+1 + savedBank * CPDef.wordsPerBank];--  Format.Line[log, "Start in RestoreRegister => "L, arg];--  DebugLog[log, arg, ShiftRegister];    StartSirius[];    Pause[50];		-- wait for 32 micro-instructions    Debug ¬ LOOPHOLE[StopSirius[], CPKernel.ShiftReg];--  Format.Line[log, "Stop in RestoreRegister <= "L, arg];--  DebugLog[log, arg, Debug];--  SetNewBank[0];    CPKernelOps.LoadFromMemory[Runtime.GetTableBase[KernelMicrocode.DaisyKernel], 0];    kernelLoaded ¬ TRUE;    END;      SaveRegitsters: INTERNAL PROCEDURE [log: Format.StringProc, arg: LONG POINTER] =    BEGIN    kernelLoaded ¬ FALSE;--  SetNewBank[0];    CPKernelOps.LoadOverlay[Runtime.GetTableBase[KernelMicrocode.SaveMD]];    SetShiftRegInternal[CPDef.StartAddr,CPKernelDef.kEntry + savedBank * CPDef.wordsPerBank];    SetShiftRegInternal[CPDef.StartAddrPlusOne,CPKernelDef.kEntry+1 + savedBank * CPDef.wordsPerBank];--  Format.Text[log, "SaveRegister Start => "L, arg];--  DebugLog[log, arg, ShiftRegister];    StartSirius[];    Pause[250];		-- wait for memory    Debug ¬ LOOPHOLE[StopSirius[], CPKernel.ShiftReg];--  Format.Text[log, "SaveRegisters <= "L, arg];--  DebugLog[log, arg, Debug];    Pause[];    END;      Stop: PUBLIC ENTRY PROCEDURE [log: Format.StringProc, arg: LONG POINTER]=    BEGIN ENABLE UNWIND => NULL;    MI: CPuFormat.MI;--  mi: CPuFormat.mi;    BrkID: CPuFormat.ByteImmediate ¬ LOOPHOLE[Inline.BITNOT[CPKernel.StopID]];    BDisp: CPuFormat.Bits4;    SELECT state FROM      booted => RETURN;      dead => ERROR CPKernel.Error["CP/IOP is dead"L];      stopped => RETURN;      running => NULL;      cpBreak => RETURN;      ENDCASE => ERROR;    --    -- 1. stop Sirius, current shift register content is returned.    -- 2. read and save the next instruction    -- 3. write and (excute,start,stop) next instruction in cs scratch pad    -- 4. overlay and (excute,start,stop) the register saving microcode    --    StopInfo.shiftReg ¬ LOOPHOLE[StopSirius[], CPKernel.ShiftReg];    ShiftRegister ¬ StopInfo.shiftReg;    savedBank ¬ currentBank ¬ ShiftRegister.BS;--  Format.Text[log, "stop in Stop <= "L, arg];--  DebugLog[log, arg, StopInfo.shiftReg];    IF StopInfo.shiftReg.INIA = CPKernelDef.kDisp2 THEN {      SaveRegitsters[log, arg];      CPKernelOps.SaveCurrentBreakID[];      CPKernelOps.LoadOverlay[Runtime.GetTableBase[KernelMicrocode.KernelOverlay]];      SetNewState[cpBreak];      RETURN WITH ERROR CPKernel.Error["Sirius At Break Point. <<Sirius already Halted>>"L];      };    StopInfo.MI ¬ MI ¬ CPKernelOps.ReadCSInternal[StopInfo.shiftReg.INIA + savedBank * CPDef.wordsPerBank];    --    -- dKernel ¬ StopID(255), BDisp, Disp4[kEntry];    --    -- SetNewBank[0];    CPKernelOps.LoadFromMemory[Runtime.GetTableBase[KernelMicrocode.DaisyKernel], 0];    kernelLoaded ¬ TRUE;    BDisp ¬ Inline.BITOR[Inline.BITSHIFT    	[MI.context.common.dspBBits33,3],MI.context.common.dspBBits20];    IF BDisp = CPDef.IBDspB OR BDisp IN [0..3] THEN BDisp ¬ CPDef.NopDspB;    CPKernelOps.WriteCSInternal[CPKernelDef.kBuffer + savedBank * CPDef.wordsPerBank ,CPuFormat.uAlign    	[3,ZeroA,TRUE,BrkID.imu,CPKernelDef.dKernel,AorB,,BrkID.iml,noopSp1,		BDisp,CPKernelDef.kEntry,]];    SetShiftRegInternal[CPDef.StartAddr,CPKernelDef.kBuffer + savedBank * CPDef.wordsPerBank];    SetShiftRegInternal[CPDef.StartAddrPlusOne,CPKernelDef.kEntry + savedBank * CPDef.wordsPerBank];--  Format.Text[log, "Start in Scratch => "L, arg];--  DebugLog[log, arg, ShiftRegister];    StartSirius[];    Pause[50];		-- wait 6 u-instructions    Debug ¬ LOOPHOLE[StopSirius[], CPKernel.ShiftReg];--  mi ¬ LOOPHOLE[CPKernelOps.ReadCSInternal[CPKernelDef.kBuffer], CPuFormat.mi];--  Format.Number[log, mi.word1, [16,,,], arg];--  Format.Number[log, mi.word2, [16,,,], arg];--  Format.Number[log, mi.word3, [16,,,], arg];--  Format.Line[log, "."L, arg];--  Format.Text[log, "Stop in Scratch <= "L, arg];--  DebugLog[log, arg, Debug];    SaveRegitsters[log, arg];--  savedBank ¬ currentBank ¬ ShiftRegister.BS;  ReadBankInternal[];  (14-Aug-84 10:44:23, AYChen$)    CPKernelOps.LoadOverlay[Runtime.GetTableBase[KernelMicrocode.KernelOverlay]];    SetNewState[stopped];    END;<< Not Needed JWF 30-Apr-87 12:42:40DecodeBank: PROC[bankIn: CARDINAL] RETURNS[CARDINAL] =   BEGIN   SELECT bankIn FROM      1 => RETURN[0];      2 => RETURN[1];      4 => RETURN[2];      8 => RETURN[3];      ENDCASE => ERROR CPKernel.Error["Error: Can't decode bank -- invalid format"L];   END;   EncodeBank: PROC[bankIn: CARDINAL] RETURNS[CARDINAL] =   BEGIN   SELECT bankIn FROM      0 => RETURN[1];      1 => RETURN[2];      2 => RETURN[4];      3 => RETURN[8];      ENDCASE => ERROR CPKernel.Error["Error: Can't encode bank -- invalid format"L];   END;>>   PollSirius: PUBLIC ENTRY PROCEDURE[log: Format.StringProc, arg: LONG POINTER] RETURNS [BOOLEAN] =    BEGIN ENABLE      BEGIN      UNWIND => NULL;      CPKernel.Error => ERROR CPKernel.Error[reason];      END;    IF CPKernel.AtBreak[] THEN RETURN WITH ERROR CPKernel.Error["Already at BreakPoint"L];    RETURN[PollSiriusInternal[log, arg]];    END;      AutoPollSirius: PUBLIC ENTRY PROCEDURE [log: Format.StringProc, arg: LONG POINTER] RETURNS [BOOLEAN] =    BEGIN ENABLE      BEGIN      UNWIND => NULL;      CPKernel.Error => ERROR CPKernel.Error["reason"L];      END;    IF (state ¬ GetStateInternal[]) = running THEN {      WHILE ~PollSiriusInternal[log, arg]      DO      IF UserInput.UserAbort[arg] THEN        RETURN WITH ERROR CPKernel.Error["User Aborted..."L];      ENDLOOP;      RETURN[TRUE];}    ELSE      RETURN WITH ERROR CPKernel.Error["CP not running"L];    END;  DebugLog: PROC [log: Format.StringProc, arg: LONG POINTER, sr: CPKernel.ShiftReg] =    BEGIN    Format.Number[log, sr.INIA, [16,,], arg];    Format.Blank[log, 2, arg];    Format.Number[log, sr.INIAHold, [16,,], arg];    Format.Line[log, "."L, arg];    END;      PollSiriusInternal: INTERNAL PROCEDURE [log: Format.StringProc, arg: LONG POINTER] RETURNS[BOOLEAN] =    BEGIN           modifiedKernelAddress: LONG POINTER ¬ LOOPHOLE[CPKernelDef.kMailBox + 4 --12021H--];    mailboxData: WORD;        SELECT state FROM      booted => RETURN[FALSE];      dead => RETURN[FALSE];      stopped => RETURN[FALSE];      running => NULL;      cpBreak => RETURN[FALSE];      ENDCASE => ERROR;<<    ShiftRegister ¬ LOOPHOLE[StopSirius[], CPKernel.ShiftReg];--  Format.Text[log, "PollSirius: Stop <= "L, arg];--  DebugLog[log, arg, ShiftRegister];    IF ShiftRegister.INIA # CPKernelDef.kDisp2 THEN      BEGIN      Pause[200];--    Format.Text[log, "PollSirius: Start => "L, arg];--    DebugLog[log, arg, ShiftRegister];      StartSirius[];      Pause[250];      RETURN[FALSE];      END;>>          mailboxData ¬ ReadMemoryWordInternal[modifiedKernelAddress];    IF mailboxData = 0 THEN RETURN[FALSE];    ShiftRegister ¬ LOOPHOLE[StopSirius[], CPKernel.ShiftReg];    savedBank ¬ currentBank ¬ ShiftRegister.BS;        SaveRegitsters[log, arg];    CPKernelOps.SaveCurrentBreakID[];    CPKernelOps.LoadOverlay[Runtime.GetTableBase[KernelMicrocode.KernelOverlay]];    RETURN[TRUE];    END;      StartSirius: PUBLIC PROCEDURE =    BEGIN ENABLE       BEGIN       UNWIND => NULL;       Bindweed.Error =>        SELECT code FROM	  timeout => Timeout[];	  badCheckSum => BadChecksum[]; 	  ENDCASE => UmbilicalNotWorking[];      END;    Bindweed.StartCP[LOOPHOLE[ShiftRegister, PACKED ARRAY [0..6) OF Environment.Byte]];    END;  StopSirius: PUBLIC PROCEDURE RETURNS [PACKED ARRAY [0..6) OF Environment.Byte] =    BEGIN ENABLE       BEGIN       UNWIND => NULL;       Bindweed.Error =>        SELECT code FROM	  timeout => Timeout[];	  badCheckSum => BadChecksum[]; 	  ENDCASE => UmbilicalNotWorking[];      END;    RETURN[Bindweed.StopCP[]];    END;      Pause: PUBLIC PROCEDURE [msec: CARDINAL ¬ 50]		-- min pause time  	= {Process.Pause[Process.MsecToTicks[msec]]};		  ConvertToIOPAddressing: PROCEDURE [address: LONG CARDINAL] RETURNS [LONG CARDINAL] =   --When there is more than one a chip in the system,  the addressing for A chips one and two are switched between the iop and mesa world.  Since the IOP is reading memory for us, we must convert to its way of looking at the world.    BEGIN    IF CPKernel.optionsData.aChips = 1 THEN RETURN[address];    IF address IN [0..100000H) THEN RETURN[address+100000H];    IF address IN [100000H..200000H) THEN RETURN[address-100000H];    RETURN[address];    END;  ReadMemoryWord: PUBLIC ENTRY PROCEDURE [address: LONG POINTER] RETURNS [WORD] =    BEGIN ENABLE UNWIND => NULL;    RETURN[ReadMemoryWordInternal[address]];    END;  ReadMemoryWordInternal: PUBLIC INTERNAL PROCEDURE [address: LONG POINTER] RETURNS [WORD] =    BEGIN ENABLE UNWIND => NULL;    sequence: LONG POINTER TO Bindweed.Sequence;    IF CPKernel.optionsData.useOpie THEN        BEGIN        sequence ¬ ReadMemoryInternal[LOOPHOLE[address, LONG CARDINAL], real];	END     ELSE        BEGIN	sequence ¬ ReadMemoryInternal[LOOPHOLE[address, LONG CARDINAL], iOPLogical];	END;    RETURN[Inline.BITOR[Inline.BITSHIFT[sequence[0], 8], sequence[1]]];    END;  ReadMemory: PUBLIC ENTRY PROCEDURE [address: LONG POINTER, addresstype: Bindweed.AddressType, words: NATURAL ¬ 1] RETURNS [LONG POINTER TO Bindweed.Sequence] =    BEGIN ENABLE UNWIND => NULL;    RETURN[ReadMemoryInternal[LOOPHOLE[address, LONG CARDINAL], addresstype, words]];    END;    ReadMemoryInternal: INTERNAL PROCEDURE [address: LONG CARDINAL, addresstype: Bindweed.AddressType, words: NATURAL ¬ 1] RETURNS [LONG POINTER TO Bindweed.Sequence] =     BEGIN     IF CPKernel.optionsData.useOpie THEN        BEGIN	RETURN[ReadMemoryInternalUsingOpie[address, addresstype, words]];	END     ELSE        BEGIN	RETURN[ReadMemoryInternalWithoutOpie[address, addresstype, words]];	END;     END;           ReadMemoryInternalUsingOpie: INTERNAL PROCEDURE [address: LONG CARDINAL, addresstype: Bindweed.AddressType, words: NATURAL ¬ 1] RETURNS [LONG POINTER TO Bindweed.Sequence] =    BEGIN ENABLE       BEGIN       UNWIND => NULL;       Bindweed.Error =>        SELECT code FROM	  timeout => Timeout[];	  badCheckSum => BadChecksum[]; 	  ENDCASE => UmbilicalNotWorking[];      END;      addr: DoveInputOutput.OpieAddressType = extendedBus;    bindweedAddress: RECORD  [      SELECT OVERLAID * FROM        one => [address: LONG CARDINAL],	many => [highHigh: Environment.Byte,	       highLow: Environment.Byte,	       lowHigh: Environment.Byte,	       lowLow: Environment.Byte],	ENDCASE];    address ¬ address * Environment.bytesPerWord;        IF CPKernel.optionsData.aChipAddressSwap THEN       address ¬ ConvertToIOPAddressing[address];           IF address > MaxBindweedSpace THEN    	CPKernel.Error["Memory Address out of Range"L];    bindweedAddress.highHigh ¬ Inline.LowByte[Inline.LowHalf[address]];      bindweedAddress.highLow ¬ Inline.HighByte[Inline.LowHalf[address]];    bindweedAddress.lowHigh ¬ Inline.LowByte[Inline.HighHalf[address]];      bindweedAddress.lowLow ¬ ORD[addr];    seqptr.length ¬ words*Environment.bytesPerWord;    Bindweed.ReadMemoryBlock[bindweedAddress.address, addresstype, seqptr];    RETURN[seqptr];    END;  ReadMemoryInternalWithoutOpie: INTERNAL PROCEDURE [BindweedAddress: LONG CARDINAL, addresstype: Bindweed.AddressType, words: NATURAL ¬ 1] RETURNS [LONG POINTER TO Bindweed.Sequence] =    BEGIN ENABLE       BEGIN       UNWIND => NULL;       Bindweed.Error =>        SELECT code FROM	  timeout => Timeout[];	  badCheckSum => BadChecksum[]; 	  ENDCASE => UmbilicalNotWorking[];      END;      addressForMapping:  RECORD [      SELECT OVERLAID * FROM        fromMesa => [fullAddr: LONG CARDINAL],	forIOP =>   [offset: [0..65535],	            ignore: [0..1024),		    aChip: [0..4),		    map: [0..8),		    offset1: [0..2)],	ENDCASE];    newMapRegValue: [0..8);    currentMapValue: WORD;    savedMapValue: RECORD [      aChip1: [0..16),      aChip2: [0..16),      aChip3: [0..16),      aChip4: [0..16)];    aChip: [0..4);        BindweedAddress ¬ BindweedAddress * Environment.bytesPerWord;        IF CPKernel.optionsData.aChipAddressSwap THEN       BindweedAddress ¬ ConvertToIOPAddressing[BindweedAddress];           addressForMapping.fullAddr ¬ BindweedAddress;    aChip ¬ addressForMapping.aChip;    addressForMapping.aChip ¬ 0;    newMapRegValue ¬ addressForMapping.map;    savedMapValue.aChip1 ¬ Bindweed.ReadIOByte[0808H];    savedMapValue.aChip2 ¬ Bindweed.ReadIOByte[0908H];    savedMapValue.aChip3 ¬ Bindweed.ReadIOByte[0A08H];    savedMapValue.aChip4 ¬ Bindweed.ReadIOByte[0B08H];    currentMapValue ¬ 8;    currentMapValue ¬ Inline.BITOR[currentMapValue, newMapRegValue];    SELECT aChip FROM      0 => BEGIN           Bindweed.WriteIOByte[0808H, currentMapValue];	   Bindweed.WriteIOByte[0908H, 0];	   Bindweed.WriteIOByte[0A08H, 0];	   Bindweed.WriteIOByte[0B08H, 0];	   END;      1 => BEGIN           Bindweed.WriteIOByte[0808H, 0];	   Bindweed.WriteIOByte[0908H, currentMapValue];	   Bindweed.WriteIOByte[0A08H, 0];	   Bindweed.WriteIOByte[0B08H, 0];	   END;      2 => BEGIN           Bindweed.WriteIOByte[0808H, 0];	   Bindweed.WriteIOByte[0908H, 0];	   Bindweed.WriteIOByte[0A08H, currentMapValue];	   Bindweed.WriteIOByte[0B08H, 0];	   END;      3 => BEGIN           Bindweed.WriteIOByte[0808H, 0];	   Bindweed.WriteIOByte[0908H, 0];	   Bindweed.WriteIOByte[0A08H, 0];	   Bindweed.WriteIOByte[0B08H, currentMapValue];	   END;      ENDCASE;    addressForMapping.map ¬ 4;    seqptr.length ¬ words*Environment.bytesPerWord;    Bindweed.ReadMemoryBlock[addressForMapping.fullAddr, addresstype, seqptr]; << SwapBytes[seqptr];>>    Bindweed.WriteIOByte[0808H, savedMapValue.aChip1];    Bindweed.WriteIOByte[0908H, savedMapValue.aChip2];    Bindweed.WriteIOByte[0A08H, savedMapValue.aChip3];    Bindweed.WriteIOByte[0B08H, savedMapValue.aChip4];        RETURN[seqptr];    END;      WriteMemoryWord: PUBLIC ENTRY PROCEDURE [address: LONG POINTER, data: WORD] =    BEGIN ENABLE UNWIND => NULL;    sequence: LONG POINTER TO Bindweed.Sequence    		¬ z.NEW[Bindweed.Sequence[Environment.bytesPerWord]]; -- 2 bytes    sequence.length ¬ Environment.bytesPerWord;    sequence[0] ¬ LOOPHOLE[Inline.HighByte[data]];    sequence[1] ¬ LOOPHOLE[Inline.LowByte[data]];    IF CPKernel.optionsData.useOpie THEN        BEGIN        WriteMemoryInternal[LOOPHOLE[address], real, sequence];  --BECOMES real WHEN GET REAL OPIE	END     ELSE        BEGIN	WriteMemoryInternal[LOOPHOLE[address], iOPLogical, sequence];	END;    z.FREE[@sequence];    END;  WriteMemoryBlock: PUBLIC ENTRY PROCEDURE [    to: LONG POINTER, count: CARDINAL, data: LONG POINTER] =    BEGIN ENABLE UNWIND => NULL;    WriteMemoryBlockInternal[LOOPHOLE[to], count, data];    END;  WriteMemoryBlockInternal: INTERNAL PROCEDURE [    to: LONG CARDINAL, count: CARDINAL, data: LONG POINTER] =    BEGIN ENABLE UNWIND => NULL;    send: CARDINAL;    sequence: LONG POINTER TO Bindweed.Sequence ¬ z.NEW[Bindweed.Sequence[Environment.bytesPerPage]];    WHILE count > 0 DO      send ¬ MIN[count, maxWords];      FOR i: NATURAL IN [0..send) DO	sequence[i*Environment.bytesPerWord] ¬ LOOPHOLE[Inline.HighByte[(data+i)­]];	sequence[i*Environment.bytesPerWord+1] ¬ LOOPHOLE[Inline.LowByte[(data+i)­]];	ENDLOOP;      sequence.length ¬ send * Environment.bytesPerWord;      IF CPKernel.optionsData.useOpie THEN        BEGIN         WriteMemoryInternal[to, real, sequence];	 END      ELSE         BEGIN	 WriteMemoryInternal[to, iOPLogical, sequence];	 END;      count ¬ count - send;      data ¬ data + send;      to ¬ to + send;      ENDLOOP;    z.FREE[@sequence];    END;   WriteMemory: PUBLIC ENTRY PROCEDURE [address: LONG POINTER, addresstype: Bindweed.AddressType, sequence: LONG POINTER TO Bindweed.Sequence] =    BEGIN ENABLE UNWIND => NULL;    addresstype ¬ real;      WriteMemoryInternal[LOOPHOLE[address], addresstype, sequence];    END;  WriteMemoryInternal: INTERNAL PROCEDURE [address: LONG CARDINAL, addresstype: Bindweed.AddressType, sequence: LONG POINTER TO Bindweed.Sequence] =     BEGIN     IF CPKernel.optionsData.useOpie THEN        BEGIN        WriteMemoryInternalUsingOpie[address, addresstype, sequence];        END     ELSE        BEGIN        WriteMemoryInternalWithoutOpie[address, addresstype, sequence];        END;     END;  WriteMemoryInternalUsingOpie: INTERNAL PROCEDURE [address: LONG CARDINAL, addresstype: Bindweed.AddressType, sequence: LONG POINTER TO Bindweed.Sequence] =    BEGIN ENABLE       BEGIN UNWIND => NULL;        Bindweed.Error =>        SELECT code FROM	  timeout => Timeout[];	  badCheckSum => BadChecksum[]; 	  ENDCASE => UmbilicalNotWorking[];     END;    -- Bindweed is byte addressing    addr: DoveInputOutput.OpieAddressType = extendedBus;    bindweedAddress: RECORD  [      SELECT OVERLAID * FROM        one => [address: LONG CARDINAL],	many => [highHigh: Environment.Byte,	       highLow: Environment.Byte,	       lowHigh: Environment.Byte,	       lowLow: Environment.Byte],	ENDCASE];    address ¬ address * Environment.bytesPerWord;        IF CPKernel.optionsData.aChipAddressSwap THEN       address ¬ ConvertToIOPAddressing[address];           IF address > MaxBindweedSpace THEN    	CPKernel.Error["Memory Address out of Range"L];    bindweedAddress.highHigh ¬ Inline.LowByte[Inline.LowHalf[address]];    bindweedAddress.highLow ¬ Inline.HighByte[Inline.LowHalf[address]];      bindweedAddress.lowHigh ¬ Inline.LowByte[Inline.HighHalf[address]];    bindweedAddress.lowLow ¬ ORD[addr];     Bindweed.WriteMemoryBlock[bindweedAddress.address, addresstype, sequence];    END;  WriteMemoryInternalWithoutOpie: INTERNAL PROCEDURE [address: LONG CARDINAL, addresstype: Bindweed.AddressType, sequence: LONG POINTER TO Bindweed.Sequence] =    BEGIN ENABLE       BEGIN UNWIND => NULL;        Bindweed.Error =>        SELECT code FROM	  timeout => Timeout[];	  badCheckSum => BadChecksum[]; 	  ENDCASE => UmbilicalNotWorking[];     END;    -- Bindweed is byte addressing    addressForMapping:  RECORD [      SELECT OVERLAID * FROM        fromMesa => [fullAddr: LONG CARDINAL],        forIOP =>   [offset: [0..65535],	            ignore: [0..1024),		    aChip: [0..4),		    map: [0..8),		    offset1: [0..2)],	ENDCASE];    newMapRegValue: [0..8);    currentMapValue: WORD;    savedMapValue: RECORD [      aChip1: [0..16),      aChip2: [0..16),      aChip3: [0..16),      aChip4: [0..16)];    aChip: [0..4);        address ¬ address * Environment.bytesPerWord;        IF CPKernel.optionsData.aChipAddressSwap THEN       address ¬ ConvertToIOPAddressing[address];           addressForMapping.fullAddr ¬ address;        aChip ¬ addressForMapping.aChip;    addressForMapping.aChip ¬ 0;    newMapRegValue ¬ addressForMapping.map;    savedMapValue.aChip1 ¬ Bindweed.ReadIOByte[0808H];    savedMapValue.aChip2 ¬ Bindweed.ReadIOByte[0908H];    savedMapValue.aChip3 ¬ Bindweed.ReadIOByte[0A08H];    savedMapValue.aChip4 ¬ Bindweed.ReadIOByte[0B08H];    currentMapValue ¬ 8;    currentMapValue ¬ Inline.BITOR[currentMapValue, newMapRegValue];    SELECT aChip FROM      0 => BEGIN           Bindweed.WriteIOByte[0808H, currentMapValue];	   Bindweed.WriteIOByte[0908H, 0];	   Bindweed.WriteIOByte[0A08H, 0];	   Bindweed.WriteIOByte[0B08H, 0];	   END;      1 => BEGIN           Bindweed.WriteIOByte[0808H, 0];	   Bindweed.WriteIOByte[0908H, currentMapValue];	   Bindweed.WriteIOByte[0A08H, 0];	   Bindweed.WriteIOByte[0B08H, 0];	   END;      2 => BEGIN           Bindweed.WriteIOByte[0808H, 0];	   Bindweed.WriteIOByte[0908H, 0];	   Bindweed.WriteIOByte[0A08H, currentMapValue];	   Bindweed.WriteIOByte[0B08H, 0];	   END;      3 => BEGIN           Bindweed.WriteIOByte[0808H, 0];	   Bindweed.WriteIOByte[0908H, 0];	   Bindweed.WriteIOByte[0A08H, 0];	   Bindweed.WriteIOByte[0B08H, currentMapValue];	   END;      ENDCASE;    addressForMapping.map ¬ 4; << SwapBytes[sequence];>>    Bindweed.WriteMemoryBlock[addressForMapping.fullAddr, addresstype, sequence];        Bindweed.WriteIOByte[0808H, savedMapValue.aChip1];    Bindweed.WriteIOByte[0908H, savedMapValue.aChip2];    Bindweed.WriteIOByte[0A08H, savedMapValue.aChip3];    Bindweed.WriteIOByte[0B08H, savedMapValue.aChip4];    END; <<  SwapBytes: PROCEDURE [blockPtr: LONG POINTER TO Bindweed.Sequence] = {   temp: Environment.Byte ¬ 0;    i: CARDINAL ¬ 0;    UNTIL i >= blockPtr.length DO      temp ¬ blockPtr[i];      blockPtr[i] ¬ blockPtr[i + 1];      blockPtr[i+1] ¬ temp;      i ¬ i + 2;      ENDLOOP;      };>>  FindBanks: PUBLIC ENTRY PROCEDURE RETURNS [CPDef.Bank] =    BEGIN ENABLE UNWIND => NULL;    banksThisMachine ¬ CPDef.numberOfBanks;  -- Bypass error trap        FOR bank: CPDef.Bank IN [1..CPDef.numberOfBanks) -- don't check bank 0      DO      cs: CPDef.RealCS = bank * CPDef.wordsPerBank + kBuffer;      Three: TYPE = RECORD [a, b, c: WORD];      writeValue: CPuFormat.mi = LOOPHOLE[Three[cs, 0, cs]];  -- parity      readValue, expectedValue: CPuFormat.mi;           CPKernelOps.WriteCSInternal[cs, LOOPHOLE[writeValue, CPuFormat.MI]];      readValue ¬ LOOPHOLE[CPKernelOps.ReadCSInternal[cs], CPuFormat.mi];            expectedValue ¬ writeValue;      CPKernel.FixParity[@LOOPHOLE[expectedValue, CPuFormat.MI]];            IF readValue # expectedValue THEN        BEGIN	RETURN[bank]; -- Return the number of banks (highest bank number + 1)	END;      ENDLOOP;    RETURN[CPDef.numberOfBanks - 1];    END;<<   FindBanks: PUBLIC ENTRY PROCEDURE RETURNS [CPDef.Bank] =    BEGIN ENABLE UNWIND => NULL;    banksThisMachine ¬ CPDef.numberOfBanks;  -- Bypass error trap    FOR bank: CPDef.Bank IN [1..CPDef.numberOfBanks) DO      cs: CPDef.RealCS = bank * CPDef.wordsPerBank + kBuffer;      Three: TYPE = RECORD [a, b, c: WORD];      address: CPuFormat.mi = LOOPHOLE[Three[cs, 0, cs]];  -- parity      CPKernelOps.WriteCSInternal[cs, LOOPHOLE[address, CPuFormat.MI]];      IF LOOPHOLE[CPKernelOps.ReadCSInternal[kBuffer],CPuFormat.mi] = address THEN        BEGIN	IF bank # 1 THEN ERROR CPKernel.Error["Bank searching mixup - write smashed bank 0"L];	RETURN[banksThisMachine ¬ 1];	END;      IF LOOPHOLE[CPKernelOps.ReadCSInternal[cs],CPuFormat.mi] # address THEN        BEGIN	RETURN[banksThisMachine ¬ bank];	END;      ENDLOOP;    RETURN[banksThisMachine ¬ CPDef.numberOfBanks];    END;>>    ReadBank: PUBLIC PROCEDURE RETURNS [CPDef.Bank] =    BEGIN ENABLE UNWIND => NULL;    RETURN[savedBank];    END;   WriteBank: PUBLIC ENTRY PROCEDURE [bank: CPDef.Bank] =    BEGIN ENABLE UNWIND => NULL;    WriteBankInternal[bank];    END;  RawWriteBank: PUBLIC ENTRY PROCEDURE [bank: CPDef.Bank] =    BEGIN ENABLE UNWIND => NULL;    -- Yetch, copy all this code to avoid error trap (see SetNewBank below)    -- only used by CSBankTester.mesa    -- need more work 7-Jun-84 16:00:14, AYChen$    R56: CARDINAL = 56;    initbank: ByteImmediate ¬ LOOPHOLE[Inline.BITNOT[3CH]];    newbank: ByteImmediate ¬ LOOPHOLE[Inline.BITNOT[bank]];    zerobank: ByteImmediate ¬ LOOPHOLE[Inline.BITNOT[0]];    IF (kBuffer + 11) # 0FFFH THEN ERROR;  -- Catch dangling branch    IF ~kernelLoaded THEN ERROR CPKernel.Error["Can't switch banks until Kernel has been loaded"L];    IF currentBank # 0 THEN      BEGIN      currentBank ¬ 0;      ExecuteCPBuffer[];  -- The instruction we left behind      END;    IF bank = 0 THEN RETURN;    CPKernelOps.WriteCSInternal[      kBuffer + 0 + savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[3,csBank,TRUE,initbank.imu,	rBsame,AandBInvert,,initbank.iml,noopSp1,noopDsp,kContinue,]];    CPKernelOps.WriteCSInternal[      kContinue + 0 + savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[3,ZeroA,TRUE,newbank.imu,        dKernel,AorB,,newbank.iml,noopSp1,noopDsp,kContinue+1,]];    CPKernelOps.WriteCSInternal[      kContinue + 1 + savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[      0,R56,dKernel,csBank,AorB,,noopSp2,noopSp1,noopDsp,kLoop,]];    SetShiftRegInternal[CPDef.StartAddr, CPKernelDef.kBuffer + 0 + savedBank * CPDef.wordsPerBank];    SetShiftRegInternal[CPDef.StartAddrPlusOne, CPKernelDef.kWait + savedBank * CPDef.wordsPerBank];    StartSirius[];    Pause[50];    [] ¬ StopSirius[];    currentBank ¬ bank;    CPKernelOps.WriteCSInternal[      kBuffer + 0 + savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[3,csBank,TRUE,zerobank.imu,	rBsame,AandBInvert,,zerobank.iml,noopSp1,noopDsp,kContinue,]];    CPKernelOps.WriteCSInternal[      kContinue + 0 + savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[3,ZeroA,TRUE,zerobank.imu,        dKernel,AorB,,zerobank.iml,noopSp1,noopDsp,kContinue+1,]];    CPKernelOps.WriteCSInternal[      kContinue + 1 + savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[      0,R56,dKernel,csBank,AorB,,noopSp2,noopSp1,noopDsp,kLoop,]];    END;  WriteBankInternal: INTERNAL PROCEDURE [bank: CPDef.Bank] =    BEGIN    SetNewBank[bank];  -- Validity check / raises error if out of range    CPKernel.UpdateLoadBankItem[bank];--  savedBank ¬ bank;    END;  SetupToGetBackToBank0: INTERNAL PROCEDURE =    -- need more work, I am not sure what is this for, 10-Jun-84  0:43:30, AYChen$    --    -- next time we execute the buffer, we can reset back to bank #0    -- kBuffer, kContinue, kContinue should be somewhere other than these.    --    BEGIN    bank: CARDINAL = 0;    R56: CARDINAL = 56;    initbank: ByteImmediate ¬ LOOPHOLE[Inline.BITNOT[3CH]];    newbank: ByteImmediate ¬ LOOPHOLE[Inline.BITNOT[bank]];    IF banksThisMachine = 1 THEN RETURN;    IF currentBank # 0 THEN RETURN;    CPKernelOps.WriteCSInternal[      kBuffer + 0 + savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[3,csBank,TRUE,initbank.imu,	rBsame,AandBInvert,,initbank.iml,noopSp1,noopDsp,kContinue,]];    CPKernelOps.WriteCSInternal[      kContinue + 0 + savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[3,ZeroA,TRUE,newbank.imu,        dKernel,AorB,,newbank.iml,noopSp1,noopDsp,kContinue+1,]];    CPKernelOps.WriteCSInternal[      kContinue + 1 + savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[      0,R56,dKernel,csBank,AorB,,noopSp2,noopSp1,noopDsp,kLoop,]];    END;SetNewBank: PUBLIC INTERNAL PROCEDURE [bank: CPDef.Bank] =    BEGIN    IF bank >= CPKernel.optionsData.banksofMicrocode THEN       BEGIN       ERROR CPKernel.Error["Bank number too big"L];       END;    END;    <<  SetNewBank: PUBLIC INTERNAL PROCEDURE [bank: CPDef.Bank] =    BEGIN    R56: CARDINAL = 56;    initbank: ByteImmediate ¬ LOOPHOLE[Inline.BITNOT[3CH]];    newbank: ByteImmediate ¬ LOOPHOLE[Inline.BITNOT[bank]];    --    IF (kBuffer + 11) # 0FFFH THEN ERROR;  Catch dangling branch    IF bank = currentBank THEN RETURN;    IF ~kernelLoaded THEN ERROR CPKernel.Error["Can't switch banks until Kernel has been loaded"L];        IF bank >= CPKernel.optionsData.banksofMicrocode THEN       ERROR CPKernel.Error["Bank number too big"L]; <<          IF currentBank # 0 THEN      BEGIN      ERROR;	-- (28-Jun-84 11:53:17, AYChen$)      <<currentBank ¬ 0;      ExecuteCPBuffer[];  -- The instruction we left behind>>      END;    IF bank = 0 THEN RETURN; >>     --    --  multi Banks Control Store will not be in version one    --  (7-Jun-84 14:12:07, AYChen$)    --    -- SetupToGetBackToBank0[];    --    -- Note: three instructions in Continue overlay has been destoryed    --    --       kBuffer: R24 ¬ CSBank AND ~3C00,	goto kContinue;    --     kContinue: dKernel ¬ newBank,	goto kContinue + 1;;    --  kContinue+ 1: CSBank ¬ R24 or dKernel,	goto kLoop;    --    CPKernelOps.WriteCSInternal[      kBuffer + savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[3,csBank,TRUE,initbank.imu,	rBsame,AandBInvert,,initbank.iml,noopSp1,noopDsp,kContinue,]];    CPKernelOps.WriteCSInternal[      kContinue + savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[3,ZeroA,TRUE,newbank.imu,        dKernel,AorB,,newbank.iml,noopSp1,noopDsp,kContinue+1,]];    CPKernelOps.WriteCSInternal[      kContinue + 1 + savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[      0,R56,dKernel,csBank,AorB,,noopSp2,noopSp1,noopDsp,kLoop,]];    SetShiftRegInternal[CPDef.StartAddr, CPKernelDef.kBuffer + savedBank * CPDef.wordsPerBank];    SetShiftRegInternal[CPDef.StartAddrPlusOne, CPKernelDef.kWait + savedBank * CPDef.wordsPerBank];    StartSirius[];    Process.Pause[Process.MsecToTicks[1080]];    [] ¬ StopSirius[];    currentBank ¬ bank;    END;>>  ExecuteCPBuffer: PUBLIC INTERNAL PROCEDURE =-- need more work, (25-Jun-84 15:45:46, AYChen$)    BEGIN    temp: PACKED ARRAY [0..2) OF Environment.Byte;    block: Environment.Block ¬ [LOOPHOLE[LONG[@temp]], 0, 2];    IF ~kernelLoaded THEN ERROR CPKernel.Error["Can't Execute Buffer before Kernel loaded"L];    IF currentBank # 0 THEN ERROR CPKernel.Error["Can't Execute Buffer in wrong bank"L];    IF FALSE THEN      BEGIN--      WriteIOPCommand[writePort];--      WriteCPCommand[executeBuffer];      RETURN;      END;--    temp[0] ¬ LOOPHOLE[IOPKernelOps.Command[writePort]];    temp[1] ¬ LOOPHOLE[Command[executeBuffer]];--    IOPKernelOps.WriteBlockInternal[block ! IOPKernel.Error => ERROR CPKernel.Error[reason] ];    END;<<  --  -- used by CSBankTester.mesa only, 11-Jun-84 13:44:51, AYChen$  --  RawReadBank: PUBLIC ENTRY PROCEDURE RETURNS [CPDef.Bank] =    BEGIN ENABLE UNWIND => NULL;    RETURN[ReadBankInternal[]];    END;  ReadBankInternal: INTERNAL PROCEDURE RETURNS [CPDef.Bank] =    BEGIN    data: CPDef.BankAndWordsPerBank;    IF CPKernel.optionsData.banksofMicrocode = 1 THEN RETURN[0];    WriteIOPCommand[readTPC];    WriteByteInternal[0];  -- 3 bits tpc address    data ¬ LOOPHOLE[ReadWordInternal[]];    RETURN[Inline.BITAND[data.bank, 3]];  -- Yetch, only 2 bits come back    END;>>  END.  -- Log-- JAC   	17-Jan-85 16:00:02	add offsetForReal0-- JAC   	28-Jan-85 11:48:17	Bindweed procedures name change-- JAC   	20-Feb-85 18:39:57	RestoreRegitsters before Starting-- JAC   	25-Feb-85 20:06:31	set PC after restoring registers during a start-- JAC   	11-Jun-85 12:53:07	Bindweed error changed names-- JAC   	16-Jan-86 11:55:55	offsetForReal0 is now public-- JAC   	15-Mar-86 12:48:00	add map register stuff-- JAC   	21-Mar-86 14:22:06	save and restore the map register-- JAC   	24-Mar-86 18:52:21	fix shift register flags-- JAC   	 9-Apr-86 18:10:58	work around Schip bug (halting) by changing PollSiriusInternal to look at memory location instead of the CS addr-- JAC   	 2-May-86 17:36:22	do Bindweed.Reset when booting.  use CPKernelDef.kMailBox in PollSiriusInternal-- JAC   	10-May-86 18:03:51	comment out use of DoveInputOutput-- JAC   	 4-Aug-86 11:49:25	remove offsetForReal0; add countOfAChips-- JWF		 8-Dec-86 15:27:01	Added no Opie option-- JWF		 8-Dec-86 16:35:15	Added A chip swapping switch-- JWF		 9-Dec-86 11:28:16	Replaced countOfAChips with optionsData-- JWF		10-Dec-86 15:47:25	Removed SwapBytes
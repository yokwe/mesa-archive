-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved. ---- CPSymbolDebugImpl.mesa, AYC   ,  7-Sep-84 13:53:23-- CPSymsDebug.mesa,          HGM,  7-Mar-83 14:29:27-- DIRECTORY  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, CommandItem, newLine, ProcType,    ToggleVisibility],  Put USING [CR, Decimal, Line, Number, Text],  Runtime USING [GetBcdTime],  String USING [AppendString],  Time USING [Append, Unpack],  Tool USING [Create, Destroy, MakeFormSW, MakeFileSW, MakeSWsProc,    UnusedLogName],  ToolWindow USING [TransitionProcType],  UserInput USING [UserAbort],  Version USING [Append],  Window USING [Handle],    CPDef USING [AReg, DReg, IBDisp, MDR, RealCS, ROffset, RReg],  CPCommand USING [],  CPSymbol USING [    AppendAllRReg, AppendAllDReg, AppendAllAReg, AppendNumber, AppendVirturalCS,    EnumerateCSSymbols, EnumerateRRegSymbols, EnumerateDRegSymbols,    EnumerateARegSymbols, EnumerateMap,    LookupInARegTable, LookupInDRegTable, LookupInRRegTable, VirturalCS];CPSymbolDebugImpl: PROGRAM  IMPORTS    FormSW, Put, Runtime, String, Time, Tool, UserInput, Version,    CPSymbol  EXPORTS CPCommand =  BEGIN    form, log: Window.Handle ¬ NIL;  ToolHandle: Window.Handle ¬ NIL;  WindowHandle: Window.Handle ¬ NIL;  SymDebugIx: CARDINAL ¬ 0;      CS: FormSW.ProcType =    BEGIN    n: CARDINAL ¬ 0;    PrintOne: PROCEDURE [s: LONG STRING, virt: CPSymbol.VirturalCS] =      BEGIN      n ¬ n + 1;      IF UserInput.UserAbort[log] THEN RETURN;      Put.Number[log, virt, [16, FALSE, TRUE, 4]];      Put.Text[log, "  "L];      Put.Text[log, s];      Put.CR[log];      END;    Put.Line[log, "Control Store symbols"L];    CPSymbol.EnumerateCSSymbols[PrintOne];    Put.Text[log, "There are "L];    Put.Decimal[log, n];    Put.Line[log, " Control Store symbols."L];    Put.CR[log];    END;  Map: FormSW.ProcType =    BEGIN    n: CARDINAL ¬ 0;    PrintOne: PROCEDURE [real: CPDef.RealCS, virt: CPSymbol.VirturalCS, ibdisp: CPDef.IBDisp, mdr: CPDef.MDR] =      BEGIN      n ¬ n + 1;      IF UserInput.UserAbort[log] THEN RETURN;      Put.Number[log, real, [16, FALSE, TRUE, 4]];      Put.Number[log, virt, [16, FALSE, TRUE, 5]];      IF ibdisp THEN Put.Text[log, " TRUE  "L] ELSE Put.Text[log, "FALSE "L];      IF mdr THEN Put.Text[log, " TRUE  "L] ELSE Put.Text[log, "FALSE "L];      Put.CR[log];      END;    Put.Line[log, "Control Storage Map Info"L];    Put.Line[log, "real virt IBDisp  MDR¬"L];    CPSymbol.EnumerateMap[PrintOne];    Put.Text[log, "There are "L];    Put.Decimal[log, n];    Put.Line[log, " active map slots."L];    Put.CR[log];    END;	  MapandSymbol: FormSW.ProcType =    BEGIN    n: CARDINAL ¬ 0;    PrintOne: PROCEDURE [real: CPDef.RealCS, virt: CPSymbol.VirturalCS, ibdisp: CPDef.IBDisp, mdr: CPDef.MDR] =      BEGIN      temp: STRING = [100];      n ¬ n + 1;      IF UserInput.UserAbort[log] THEN RETURN;      Put.Number[log, real, [16, FALSE, TRUE, 4]];      Put.Number[log, virt, [16, FALSE, TRUE, 5]];      IF ibdisp THEN Put.Text[log, " TRUE  "L] ELSE Put.Text[log, "FALSE "L];      IF mdr THEN Put.Text[log, " TRUE  "L] ELSE Put.Text[log, "FALSE "L];      Put.Text[log, "  "L];      CPSymbol.AppendVirturalCS[temp, virt];      Put.Text[log, temp];      Put.CR[log];      END;    Put.Line[log, "Control Storage Map and Symbol Info"L];    Put.Line[log, "real virt  IBDisp  MDR¬  symbol"L];    CPSymbol.EnumerateMap[PrintOne];    Put.Text[log, "There are "L];    Put.Decimal[log, n];    Put.Line[log, " active map slots."L];    Put.CR[log];    END;	  Duplicates: FormSW.ProcType =    BEGIN    PrintDuplicates: PROCEDURE [s: LONG STRING, virt: CPSymbol.VirturalCS] =      BEGIN      ok: BOOLEAN;      r: CPDef.RReg;      d: CPDef.DReg;      a: CPDef.AReg;      [ok, r] ¬ CPSymbol.LookupInRRegTable[s];      IF ok THEN        BEGIN	Put.Text[log, "CS symbol "L];	Put.Text[log, s];	Put.Text[log, " clashes with .R "L];        Put.Number[log, r, [16, FALSE, TRUE, 1]];	Put.Line[log, "."L];	END;      [ok, d] ¬ CPSymbol.LookupInDRegTable[s];      IF ok THEN        BEGIN	Put.Text[log, "CS symbol "L];	Put.Text[log, s];	Put.Text[log, " clashes with .D "L];        Put.Number[log, d, [16, FALSE, TRUE, 1]];	Put.Line[log, "."L];	END;      [ok, a] ¬ CPSymbol.LookupInARegTable[s];      IF ok THEN        BEGIN	Put.Text[log, "CS symbol "L];	Put.Text[log, s];	Put.Text[log, " clashes with .A "L];        Put.Number[log, a, [16, FALSE, TRUE, 2]];	Put.Line[log, "."L];	END;      END;    Put.Line[log, "Scaning for Duplicate symbols:"L];    CPSymbol.EnumerateCSSymbols[PrintDuplicates];    Put.Line[log, "Done."L];    END;	  RRegs: FormSW.ProcType =    BEGIN    n: CARDINAL ¬ 0;    PrintOne: PROCEDURE [s: LONG STRING, r: CPDef.RReg] =      BEGIN      n ¬ n + 1;      IF UserInput.UserAbort[log] THEN RETURN;      Put.Number[log, r + CPDef.ROffset, [16, FALSE, TRUE, 4]];      Put.Text[log, "  "L];      Put.Text[log, s];      Put.CR[log];      END;    Put.Line[log, "R Register symbols"L];    CPSymbol.EnumerateRRegSymbols[PrintOne];    Put.Text[log, "There are "L];    Put.Decimal[log, n];    Put.Line[log, " R register symbols."L];    Put.CR[log];    END;  RRegsTable: FormSW.ProcType =    BEGIN    Put.Line[log, "R Register table"L];    FOR r: CPDef.RReg IN CPDef.RReg DO      temp: STRING = [200];      String.AppendString[temp, ".R "L];      CPSymbol.AppendNumber[temp, r + CPDef.ROffset];      String.AppendString[temp, " = "L];      CPSymbol.AppendAllRReg[temp, r];      Put.Text[log, temp];      Put.Line[log, "."];      ENDLOOP;    Put.CR[log];    END;      DRegs: FormSW.ProcType =    BEGIN    n: CARDINAL ¬ 0;    PrintOne: PROCEDURE [s: LONG STRING, d: CPDef.DReg] =      BEGIN      n ¬ n + 1;      IF UserInput.UserAbort[log] THEN RETURN;      Put.Number[log, d, [16, FALSE, TRUE, 4]];      Put.Text[log, "  "L];      Put.Text[log, s];      Put.CR[log];      END;    Put.Line[log, "D Register symbols"L];    CPSymbol.EnumerateDRegSymbols[PrintOne];    Put.Text[log, "There are "L];    Put.Decimal[log, n];    Put.Line[log, " D register symbols."L];    Put.CR[log];    END;  DRegsTable: FormSW.ProcType =    BEGIN    Put.Line[log, "D Register table"L];    FOR d: CPDef.DReg IN CPDef.DReg DO      temp: STRING = [200];      String.AppendString[temp, ".D "L];      CPSymbol.AppendNumber[temp, d];      String.AppendString[temp, " = "L];      CPSymbol.AppendAllDReg[temp, d];      Put.Text[log, temp];      Put.Line[log, "."];      ENDLOOP;    Put.CR[log];    END;      ARegs: FormSW.ProcType =    BEGIN    n: CARDINAL ¬ 0;    PrintOne: PROCEDURE [s: LONG STRING, a: CPDef.AReg] =      BEGIN      n ¬ n + 1;      IF UserInput.UserAbort[log] THEN RETURN;      Put.Number[log, a, [16, FALSE, TRUE, 4]];      Put.Text[log, "  "L];      Put.Text[log, s];      Put.CR[log];      END;    Put.Line[log, "A Register symbols"L];    CPSymbol.EnumerateARegSymbols[PrintOne];    Put.Text[log, "There are "L];    Put.Decimal[log, n];    Put.Line[log, " A Register symbols."L];    Put.CR[log];    END;  ARegsTable: FormSW.ProcType =    BEGIN    Put.Line[log, "U Register table"L];    FOR a: CPDef.AReg IN CPDef.AReg DO      temp: STRING = [200];      String.AppendString[temp, ".A "L];      CPSymbol.AppendNumber[temp, a];      String.AppendString[temp, " = "L];      CPSymbol.AppendAllAReg[temp, a];      Put.Text[log, temp];      Put.Line[log, "."];      ENDLOOP;    Put.CR[log];    END;      Destroy: FormSW.ProcType =    BEGIN    DestoryWindow[];    END;      SymbolDebugCreate: PUBLIC PROCEDURE[lowerform: Window.Handle, SymbolDebugIx: CARDINAL] =    BEGIN    herald: STRING = [100];    String.AppendString[herald, "Sirius Symbol Debugger (CPBermuda) "L];    Version.Append[herald];    String.AppendString[herald, " of "L];    Time.Append[herald, Time.Unpack[Runtime.GetBcdTime[]]];    WindowHandle ¬ lowerform;    SymDebugIx ¬ SymbolDebugIx;    ToolHandle ¬ Tool.Create[      name: herald,      cmSection: "Sirius SymbolDebug"L,      makeSWsProc: MakeSWs,      clientTransition: ClientTransition];    END;    SymbolDebugDestory: PUBLIC PROCEDURE =    BEGIN    IF ToolHandle # NIL THEN DestoryWindow[];    END;  DestoryWindow: PROCEDURE =    BEGIN    Tool.Destroy[ToolHandle];    FormSW.ToggleVisibility[WindowHandle, SymDebugIx];    ToolHandle ¬ NIL;    END;      MakeSWs: Tool.MakeSWsProc =    BEGIN    logFileName: STRING = [40];    Tool.UnusedLogName[logFileName, "CPSymbolDebug.log$"L];    form ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    log ¬ Tool.MakeFileSW[window: window, name: logFileName];    END;    MakeForm: FormSW.ClientItemsProcType =    BEGIN    nParams: CARDINAL = 11;    items ¬ FormSW.AllocateItemDescriptor[nParams];    items[0] ¬ FormSW.CommandItem[tag: "RRegs"L, proc: RRegs, place: FormSW.newLine];    items[1] ¬ FormSW.CommandItem[tag: "RRegsTable"L, proc: RRegsTable];    items[2] ¬ FormSW.CommandItem[tag: "ControlStore"L, proc: CS];    items[3] ¬ FormSW.CommandItem[tag: "DRegs"L, proc: DRegs, place: FormSW.newLine];    items[4] ¬ FormSW.CommandItem[tag: "DRegsTable"L, proc: DRegsTable];    items[5] ¬ FormSW.CommandItem[tag: "Map"L, proc: Map];    items[6] ¬ FormSW.CommandItem[tag: "MapAndSymbol"L, proc: MapandSymbol];    items[7] ¬ FormSW.CommandItem[tag: "ARegs"L, proc: ARegs, place: FormSW.newLine];    items[8] ¬ FormSW.CommandItem[tag: "ARegsTable"L, proc: ARegsTable];    items[9] ¬ FormSW.CommandItem[tag: "Duplicates"L, proc: Duplicates];    items[10] ¬ FormSW.CommandItem[tag: "Destroy"L, proc: Destroy];    RETURN[items, TRUE];    END;       ClientTransition: ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      old = inactive =>        BEGIN        END;      new = inactive =>        BEGIN	END;      ENDCASE;    END;	  END.
$MOD186 	NAME TVECTOR;*********************************************************************;*                                                                   *;*    			TEST VECTOR PROGRAM                          *;*                                                                   *;*	   	      Created by jAC   CxC                           *;*		         November 9, 15:39:21                        *;*                                                                   *;*		Last Modified:  7-Jan-85 21:02:03                    *;*                                                                   *;* This routine will apply SCI test vectors to the Sirius Simulator. *;* The test vectors are in the format as follows:                    *;*                                                                   *;* Byte 0  	Cycle Inputs (to the S Chip)                         *;* Byte 1 	Phase Inputs (to the S Chip)                         *;* Byte 2	ASH7-0 (Read on Cycle boundry)                       *;* Byte 3	NIA11-NIA04 (Read on Cycle boundry)                  *;* Byte 4	NIA3-0 & BS3-0 (Read on Cycle boundry)               *;* Byte 5	Cycle Outputs (from S Chip)                          *;* Byte 6	Phase Outputs (bits 5-7) and Dir Control (bits 0,1)  *;* Byte 7	AS15-AS08 (Bi-Directional)                           *;* Byte 8	AS7 -AS00 (Bi-Directional)                           *;* Byte 9	CSD47-CSD40 (Bi-Directional)                         *;* Byte 10	CSD39-CSD32 (Bi-Directional)                         *;* Byte 11	CSD31-CSD24 (Bi-Directional)                         *;* Byte 12	CSD23-CSD16 (Bi-Directional)                         *;* Byte 13	CSD15-CSD08 (Bi-Directional)                         *;* Byte 14	CSD07-CSD00 (Bi-Directional)                         *;* Byte 15	Control bits (not used by S Chip)                    *;* Byte 16	Control bits (not used by S Chip)                    *;*                                                                   *;*                                                                   *;* The following systax is used for LOC86                            *;*                                                                   *;* $LOC86 TVector.lnk to TVector.lm addresses -                      *;* *_(segments(CODE(1000H),DATA(2000H),IOPELocalRam(0H)))            *;*                                                                   *;*********************************************************************;			Modification History;9-Nov-84 15:39:21	CxC    - Initial creation (let there be program!);13-Nov-84 11:15:25	CxC    - Added ErrFlag; Corrected Vector length to;			         17 bytes; Fixed comparision routine;Added;			         delay to clock routines.;13-Nov-84 13:25:07	CxC    - Fixed bug in count; Added Pause routine;29-Nov-84 13:45:13	CxC    - Added Bindweed Notify routines;29-Nov-84 15:14:10	CxC    - Fixed bug which displays count	;30-Nov-84  9:10:13	CxC    - Fixed bug in Cont routine;10-Dec-84 10:48:54	CxC    - Deleted routine to set default delay ;				 Changed ASZ and CSZ timing and added DirData;18-Dec-84 11:21:29	CxC    - Added routines for RespU, RespV & Reset ;				 changing at rising edge of clock; 7-Jan-85 21:02:12	CxC    - Modified AssertPhase routine so that CSZ;				 is turned off before applying CSDOe.;$Title	(Sirius Test Vector Program)$	NOLIST		;Next line includes definitions file$	INCLUDE(UMBDEFS.ASM)$	INCLUDE(IOPDEFS.ASM)$	INCLUDE(IOPLRAM.ASM)$	LIST		;Previous line included definitions file;;	ASSUME	CS:CODE, DS:DATA, ES:DATA;========================================;	Port Equates;RdASH	EQU	0E0H		;ASH and NIA Port (bytes 2 & 3 of testvector) RCycleIn	EQU	0E0H		;Cycle input port (byte 0) WCyclOut	EQU	0E2H		;Cycle output port (bytes 4 & 5) RPhIn	EQU	0E2H		;Phase input port (byte 1) WPhOut	EQU	0E4H		;Phase output port (byte 6) RDirCntl	EQU	0E4H		;Direction control port (byte 6) WASData	EQU	0E6H		;AS data port (bytes 7 & 8) R/WCSD1	EQU	0E8H		;CSD port (bytes 13 & 14) R/WCSD2	EQU	0EAH		;CSD port (bytes 11 & 12) R/WCSD3	EQU	0ECH		;CSD port (bytes 9 & 10) R/WClock	EQU	0EEH		;S-Chip Clock controliopStatusMask	EQU	00800H	;bit 4 set to notify iopHalt		EQU	02HbwMinReply	EQU	3	; the minimum length of a reply	;========================================DATA	SEGMENTErrFlag	DB	00		;Vector comparision error flagNumber	DW	0000		;Number of vectors to testDelay	DW	0000		;Clock delay countCOUNT	DW	0000Pointer	DW	0000		;Pointer to Test Vector TableDirData	DB	00		;ASZ and CSZ stateResult	DB	17 DUP(?)	;Resulting test vectorOrig	DB	17 DUP(?)	;Original vector in event of errorTable	DB	4000 DUP(?)	;Table of test vectorsDATA	ENDS;========================================IOPELocalRam	SEGMENT		COMMON		ORG 	400H		PUBLIC	BindweedBuffer		BurdockDataSpace	LABEL	FAR		;Data Space for Budock		;			savedRegisters  		LABEL	FARsavedAX	DW	?	;savedBX	DW	?	;savedCX	DW	?	;savedDX	DW	?	;savedSP	DW	?	;savedBP	DW	?	;savedSI	DW	?	;savedDI	DW	?	;savedCS	DW	?	;savedDS	DW	?	;savedSS	DW	?	;savedES	DW	?	;savedIP	DW	?	;savedFLAGS	DW	?	debugStatus		DW	?	;status sent to debuggeriopDebugState		DB	?	;current debugging stateIsABreakPoint		DB	?	;set to YES by the debugger 					;if an INT 3 was executedSingleStepFlags		DW	?	;an extra copy of the Status Word used by 					;the single step handler to save the 					;interrupt flag during a single stepCSOfBreakPoint		DW	?IPOfBreakPoint		DW	?										IOPELocalRam	ENDS;========================================bwDownNotifyBuffer	STRUC	bwFiller	DB	3	DUP	(?)	downNotifyMask		DW	?bwDownNotifyBuffer	ENDS	bwReplyBuffer	STRUC	bwCount1	DB	?	bwCount2	DB	?	status		DW	?	empty		DB	?	replyData	DB	?bwReplyBuffer	ENDS		;========================================;Main test routine begins here!!;CODE	SEGMENTStart:	JMP	Init		;Initialization jump locationCont:	JMP	RStart		;Continue jump location	;Init:	MOV	AX,DATA		;DS=Data and ES=Data	MOV	DS,AX		;  /	MOV	ES,AX		; /	XOR	SI,SI		;Set SI = 0000 (1st Vector)	MOV	Pointer,SI	;Save pointer	MOV	COUNT,0001	;Init Count	MOV	AX,0001		;  /	OUT	90H,AX		; /	;TestIt:	MOV	BX,OFFSET Table ;BX = Start of test vector table	MOV	DI,OFFSET Result;DI = address of result	CALL	CopyVector	;Copy vector to result	CALL	CheckCycle	;Compare the cycle data	CALL	ClockLow	;Clock S-Chip	CALL	AssertCycle	;Set-up cycle data	CALL	ClockHigh	CALL	AssertCycleH	;Set-up RespU,RespV, & Reset for Cycle	CALL	CheckPhase	;Get Phase data	CALL	ClockLow	CALL	AssertPhase	;Set-up Phase Input data	CALL	ClockHigh	CALL	AssertPhaseH	;Set-up RespU,RespV, & Reset for Phase	CALL	Compare		;Are the two test vectors the same??	CMP	ErrFlag,00	;    /	JNZ	Err		;  Nope report errorRStart:	MOV	SI,Pointer	;Retrieve pointer	ADD	SI,17		;Point to next vector	MOV	Pointer,SI	;Save pointer	MOV  	AX,COUNT	;Done yet? (Number= # of vectors total)	CMP	NUMBER,AX	;   /      (Count = # of vectors tested)	JZ	Done		;  /	INC	AX		;Update count & Display it	MOV	COUNT,AX	; /	OUT	90H,AX		;/	JMP	TestIt	;Err:	JMP	Error;;	Test Completed;;This routine is jumped to upon completion;of test. It will display the final count on the display.;Done:	MOV	AX,COUNT	;Display count	OUT	090H,AX		; /	MOV	ErrFlag,00	;       	CALL	Notify		;Tell Mesa Program that we're doneD1:	JMP	D1	;;;	Phase Setup Routine;;This routine will set-up the input data to the;S-Chip prior to the Phase Boundry of the clock.;AssertPhase:	MOV	AL,DirData	;Turn off CSZ until done!!	AND	AL,02H		;  keep old ASZ state	OUT	DirCntl,AL	;  /	;	MOV	AL,1[BX][SI]	;Get phase inputs from test vector	OUT	PhIn,AL		;  Latch 'em	;	MOV	DL,6[BX][SI]	;Get direction control info	TEST	DL,01H		;Should I latch CSD data?	JZ	APhase1		; I guess not	MOV	AX,13[BX][SI]	;Get CSD00-CSD15	OUT	CSD1,AX		; and latch it	MOV	AX,11[BX][SI]	;Do the same for CSD16-CSD31	OUT	CSD2,AX		; /	MOV	AX,9[BX][SI]	;One more time for CSD32-CSD47	OUT	CSD3,AX		; (boy thats alot of bits!!)	;APhase1:MOV	AH,DirData	;Update CSZ control line ONLY!!	AND	AH,02H		;  Keep old ASZ state	MOV	AL,DL		;  Get new states	AND	AL,01H		;  Only update CSZ	OR	AL,AH		;   /	MOV	DirData,AL	;  Save new state	OUT	DirCntl,AL	;  /	RET;;	Phase High Setup Routine;;This routine will latch the S-Chip inputs RespU', RespV';and Reset'. These values can only be latched when SClkIn ;is High (this is controlled by hardware). This routine ;will also latch the other Phase Inputs, but this should;not matter because since they have already been latched ;with these same values in the AssertPhase routine.;AssertPhaseH:	MOV	AL,1[BX][SI]	;Get phase inputs from test vector	OUT	PhIn,AL		;  Latch 'em	RET;;	Cycle Setup Routine;;This routine will set-up the input data to the;S-Chip prior to the Cycle Boundry of the clock.;AssertCycle:	MOV	AL,[BX][SI]	;Get cycle inputs	OUT	CycleIn,AL	; output 'em (RespU,V & Reset won't be latched)	MOV	DL,6[BX][SI]	;Should I latch AS data?	TEST	DL,02H		;Check ASZ bit	JZ	ACycle1		;Don't do it!	MOV	AX,7[BX][SI]	;Output AS data	OUT	ASData,AX	; /ACycle1:MOV	AH,DirData	;Update ASZ control line	AND	AH,01H		;  Keep old CSZ state	MOV	AL,DL		;  Get new states	AND	AL,02H		;  Only update ASZ	OR	AL,AH		;   /	MOV	DirData,AL	;  Save new state	OUT	DirCntl,AL	;  /	RET;;	Cycle High Setup Routine;;This routine will latch the S-Chip inputs RespU', RespV';and Reset'. These values can only be latched when SClkIn ;is High (this is controlled by hardware). This routine ;will also latch the other Cycle Inputs, but this should;not matter because since they have already been latched ;with these same values in the AssertCycle routine.;AssertCycleH:	MOV	AL,[BX][SI]	;Get cycle inputs	OUT	CycleIn,AL	; output 'em 	RET;;	Clock Routines;;These routines are used to toggle the S-Chip;clock line. After toggling the line they each;pause for a time set by the value of Delay.;ClockLow:	XOR	AL,AL		;Zero AL and output to clock	OUT	Clock,AL	; /	MOV	CX,Delay	;Wait before continuingLowDly:	LOOP	LowDly		; /	RET;ClockHigh:	MOV	AL,01H		;Set clock line high	OUT	Clock,AL	; /	MOV	CX,Delay	;Wait before continuingHighDly:LOOP	HighDly		; /	RET;;	Copy Vector Routine;;This routine will copy the test vector from the table ;to the result location. No registers are affected.;CopyVector:	PUSH	DI		;Save registers	PUSH	SI		;  /	PUSH	CX		; /	MOV	CX,17		;Move 17 bytes	CLD			;Dir = increment	MOV	DI,OFFSET Result;Destination address	ADD	SI,OFFSET Table	;Source addressREP	MOVSB			;Move it	POP	CX		;Restore registers	POP	SI		;  /	POP	DI		; /	RET	;;	Phase Check Routine	;;This routine will input data from the S-Chip;and store it in the result vector.;CheckPhase:	IN	AL,PhOut	;Read Phase data from S-Chip	MOV	AH,AL		;Save it	MOV	CX,15[BX][SI]	;See which outputs to check	TEST	CX,0100H	;Should I check Phi1Out?	JZ	CkPh1		;  nope	AND	BYTE PTR 6[DI],0EFH	;Zero Phi1Out bit in result	AND	AL,01H		;  mask out Phi1Out	SAL	AL,4		;  move to high nibble	OR	6[DI],AL	;  and insert into resultCkPh1:	TEST	CX,08H		;Should I check Cx'?	JZ	CkPh2		;  nope	AND	BYTE PTR 6[DI],0BFH	;Zero Cx bit in result	MOV	AL,AH		;  Retrieve S-Chip phase data	AND	AL,04H		;  mask out Cx	SAL	AL,4		;  move to high nibble	OR	6[DI],AL	;  and insert into resultCkPh2:	TEST	CX,04H		;Should I check Cy'?	JZ	CkPh3		;  nope	AND	BYTE PTR 6[DI],0DFH	;Zero Cy bit in result	MOV	AL,AH		;  Retrieve S-Chip phase data	AND	AL,02H		;  mask out Cy	SAL	AL,4		;  move to high nibble	OR	6[DI],AL	;  and insert into resultCKPh3:	TEST	CX,080H		;Check AS?	JZ	CKPh4		;  NO	IN	AX,ASData	;  Read AS data	MOV	7[DI],AX	;  Store it in result vectorCKPh4:	TEST	CX,020H		;Should I check CSD0?	JZ	CKPh5		;  No	IN	AX,CSD1		;  Read CSData	AND	AX,0100H	;  Mask CSData 0	AND	13[DI],0FEFFH	;  Zero CSData 0 in result vector	OR	13[DI],AX	;  Update result vectorCKPh5:	TEST	CX,010H		;How about CSData?	JZ	CKPh6		;  No	IN	AX,CSD3		;  Read CSData32-47	MOV	9[DI],AX	;  Store it in result vector	IN	AX,CSD2		;  Now read CSData16-31	MOV	11[DI],AX	;  and store it in result vector	IN	AX,CSD1		;  Now CSData0-15	AND	AX,0FEFFH       ;  Don't want CSD0	AND	13[DI],0100H	;  want to keep CSD0 in result vector	OR	13[DI],AX	;  now update result vector.CKPh6:	RET;;	Check Cycle Routine;;This routine will input cycle sampled data from the S-Chip;and store it in the result vector.;CheckCycle:	IN	AX,RdASH		;Read ASH and NIA data	MOV	CX,15[BX][SI]		;See which outputs to check	TEST	CX,040H			;Should I check ASH?	JZ	CkCyc1			;  nope	MOV	2[DI],AL		;  Write data to result vectorCkCyc1:	TEST	CX,01H			;Should I check NIA?	JZ	CkCyc2			;  no	MOV	3[DI],AH		;  Write NIA4-11 to result vector	IN	AX,CyclOut		;  Read NIA0 - NIA3	AND	AL,0F0H			;  Strip off BS data	AND	BYTE PTR 4[DI],0FH	;  zero NIA in result vector	OR	4[DI],AL		;  and update with new NIACkCyc2:	TEST	CX,0200H		;Should I check BS?	JZ	CkCyc3			;  no	IN	AX,CyclOut		;  Get BS and Cycle output data	AND	AL,0FH			;  Get rid of NIA data	AND	BYTE PTR 4[DI],0F0H	;  zero BS in result vector	OR	4[DI],AL		;  and write to result vector CkCyc3:	TEST	CX,02H			;How about IOPIntRq?	JZ	CkCyc4			;  no	IN	AX,CyclOut		;  Get Cycle output data	AND	AH,08H			;  just want IOPIntRq	AND	BYTE PTR 5[DI],0F7H	;  Update result vector	OR	5[DI],AH		;   /CkCyc4:	TEST	CX,04H			;Check Cy?	JZ	CkCyc5			;  no	IN	AX,CyclOut		;  Get Cycle output data	AND	AH,02H			;  just want Cy	AND	BYTE PTR 5[DI],0FDH	;  Update result vector	OR	5[DI],AH		;   /CkCyc5:	TEST	CX,08H			;Check Cx?	JZ	CkCyc6			;  no	IN	AX,CyclOut		;  Get Cycle output data	AND	AH,04H			;  just want Cx	AND	BYTE PTR 5[DI],0FBH	;  Update result vector	OR	5[DI],AH		;   /CkCyc6:	TEST	CX,0100H		;Check Phi1Out?	JZ	CkCyc7			;  no	IN	AX,CyclOut		;  Get Cycle output data	AND	AH,01H			;  just want Phi1Out	AND	BYTE PTR 5[DI],0FEH	;  Update result vector	OR	5[DI],AH		;   /CkCyc7:	RET;;	Comparision Routine;;This routine compares the result vector pointed;to by [DI] with orginal test vector pointed to by;[BX][SI]. If they compare then the ErrFlag is set  to zero;else it is set to 0FFH.;This routine perserves the contents of all registers;Compare:	PUSH	DI		;Save registers	PUSH	SI		;   /	PUSH	CX		;  /	ADD	SI,OFFSET Table	;This is not very elegant but it works	MOV	CX,17		;Number of bytes in test vector	MOV	ErrFlag,00h	;Zero error flagComp:	MOV	AL,[SI]	MOV	AH,[DI]	XOR	AH,AL	JNZ	CompErr	INC	SI		;Point to next byte	INC	DI		; /	LOOP	CompExit:	POP	CX		;Retrieve registers	POP	SI		;  /	POP	DI		; /	RETCompErr:MOV	ErrFlag,0FFH	;Set error flag	JMP	Exit;;	Error Routine;;This routine is jumped to when two test vectors;did not compare. It will stop remainder of test;and set appropiate flags. It will also copy the;original vector into the space ORIG so that;MESA program can get to it.;Error:	PUSH	DI		;Save pointers	PUSH	SI		; /	ADD	SI,OFFSET Table	;Point to vector in error	MOV	DI,OFFSET Orig	;Where to put vector	MOV	CX,17		;Number of bytes in vectorREP	MOVSB			;Move it	POP	SI		;Restore pointers	POP	DI	;Err1:	MOV	AX,COUNT	;Display Count	OUT	090H,AX		; /	CALL	Notify		;Tell Mesa program that we're doneErr2:	JMP	Err2;;	Bindweed Notify Routines;;These routines will interrupt the Mesa program.;Don't ask me what they do. I just know they work;Modified from routines written by Frank FXB   .		;	ASSUME	DS: IOPELocalRam	;Notify: CLI	CALL 	SaveState	MOV	AX,SEG debugStatus	;Where debugStatus is	MOV	DS, AX	MOV	BX, OFFSET debugStatus	;Where debugStatus is	OR	[BX], iopStatusMask 	; set "naked notify" bits	MOV	iopDebugState, iopHalt		MOV	CX, 0			; Let Debugger know that we Broke	CALL	CreateReply	CALL	SendReply	STI	MOV	AX,DATA		;Reset DS	MOV	DS,AX		; /	RET;;;Subroutine CreateReply;CreateReply:;	on entry: CL = length of data;	AH checksum	MOV	BX,OFFSET BindweedBuffer	ADD	CL, bwMinReply	MOV	[BX].bwCount1, CL	MOV	[BX].bwCount2, CL	MOV	DX, debugStatus	MOV	[BX].status,DX	MOV	AX, 0	MOV	debugStatus, AX	XOR	AH, AH		; clear checksum	ADD	CL, 1 		;include  2 count bytes - checksum byte	XOR	CH, CH		;clear high byte of loop counterchecksumLoop:	ADD	AH, [BX]	;add buffer byte to checksum	INC	BX		;increment bindweed buffer index	LOOP	checksumLoop	MOV	AL, 0	SUB	AL, AH	MOV	[BX], AL 	;insert checksum				;buffer is now ready to send	RET;;	;Subroutine: SendReply;	SendReply:	MOV 	CL, BindweedBuffer	;get count	ADD	CL, 2		;include count bytes	XOR	CH, CH	MOV	BX, OFFSET BindweedBufferSendBWBuffer:	MOV	DL, [BX]	CALL	DebPutOutByte	INC	BX	LOOP	SendBWBuffer	RET;;DebPutOutByte:	IN	AL, i8255portC		;(portC is the status port!)	TEST	AL, i8255outReady		;Check for "ok to put byte"	JZ	DebPutOutByte		;wait	MOV	AL, Dl			;Get the argument	OUT	i8255portA, AL		;	RET;;------------------------------Save State at absolute addresses-------------SaveState:			;to be called only in interrupt routines	PUSH	DS	PUSH	AX	MOV	AX, SEG savedRegisters	MOV	DS, AX	POP	AX	MOV	savedAX, AX	POP 	AX          ; AX _ DS on stack 	MOV	savedDS, AX   	MOV	savedBX, BX	MOV	savedCX, CX	MOV	savedDX, DX	MOV	savedBP, BP	MOV	savedSI, SI	MOV	savedDI, DI	MOV 	savedES, ES;	POP	BX 	    ;POP return address of (NEAR) subroutine - 1 word;	POP	AX		; POP IP saved during interrrupt call;	MOV	savedIP, AX;	POP	AX		;POP CS saved during interrupt call;	MOV	savedCS, AX;	POP	AX		; POP FLAGS saved during interrupt call;	MOV	savedFLAGS, AX ;	MOV	savedSP, SP;	MOV	savedSS, SS;	PUSH	BX  	   ;PUSH 1 WORD return address of subroutine	RET;---------------------------Done with Notify Routines-------------------------;CODE	ENDS		END	Start
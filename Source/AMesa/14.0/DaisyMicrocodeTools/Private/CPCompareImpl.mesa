-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved. ---- CPCompareImpl.mesa,   AYC   , 15-Aug-84  9:57:36-- from CPLoaderExtra.mesa, HGM, 26-Dec-83 20:32:36--DIRECTORY  Environment USING [bytesPerWord],  Format USING [CR, Line, LongDecimal, StringProc, Text],  Heap USING [systemZone],  Inline USING [BITAND, BITSHIFT, BITXOR],  MStream USING [Error, ReadOnly],  Stream USING [Delete, EndOfStream, GetBlock, Handle],  String USING [AppendChar, AppendExtensionIfNeeded, AppendString, CopyToNewString],  System USING [GetClockPulses, Pulses, PulsesToMicroseconds],  UserInput USING [UserAbort],  CPDef USING [Bank, RealCS, sizeOfCS, StartAddr, StartAddrPlusOne, wordsPerBank],  CPCommand USING [Error, RefreshWindow],  CPKernel USING [Error, ReadCS, ReadBank],  CPSymbol USING [AppendRealCS, AppendMI],  CPuFormat USING [MI],  DsyuFormat USING [FinalBinaryRec];CPCompareImpl: PROGRAM  IMPORTS    Format, Heap, Inline, MStream, Stream, String, System, UserInput,    CPCommand, CPKernel, CPSymbol  EXPORTS CPCommand =  BEGIN    z: UNCOUNTED ZONE = Heap.systemZone;  Compare: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, file: LONG STRING] =    BEGIN    filename: LONG STRING;    stream: Stream.Handle;    filename ¬ String.CopyToNewString[file, z];    [] ¬ String.AppendExtensionIfNeeded[@filename, "fb"L, z];    Format.Text[log, "Comparing CP with "L, arg];    Format.Text[log, filename, arg];    Format.Line[log, "."L, arg];    stream ¬ MStream.ReadOnly[filename, [] ! MStream.Error =>      ERROR CPCommand.Error["Can't read that file"] ];    CompareFromStream[log, arg, stream !      UNWIND => BEGIN Stream.Delete[stream]; z.FREE[@filename]; END ];    Stream.Delete[stream];    z.FREE[@filename];    CPCommand.RefreshWindow[];    END;  CompareFromStream: PROCEDURE [log: Format.StringProc, arg: LONG POINTER, stream: Stream.Handle] =    BEGIN ENABLE      BEGIN      Stream.EndOfStream => ERROR CPCommand.Error["Truncated fb file"L];      CPKernel.Error => ERROR CPCommand.Error[reason];      END;    start, stop: System.Pulses;    ms: LONG CARDINAL;    instructions, mismatches: CARDINAL ¬ 0;    fbrBytes: CARDINAL = Environment.bytesPerWord*SIZE[DsyuFormat.FinalBinaryRec];    b: POINTER = @fbr;    fbr: DsyuFormat.FinalBinaryRec ¬ TRASH;    pb: POINTER TO CPuFormat.MI = LOOPHOLE[@fbr.partialBinary];    offset: CARDINAL = CPKernel.ReadBank[] * CPDef.wordsPerBank;  -- ***  Hack until Vespers is smarter    start ¬ System.GetClockPulses[];    DO      bytes: CARDINAL;      [bytes, , ] ¬ Stream.GetBlock[          sH: stream,          block: [            blockPointer: b,	    startIndex: 0,            stopIndexPlusOne: fbrBytes]];      IF bytes # fbrBytes THEN ERROR CPCommand.Error["Truncated fb"];      IF fbr.addr >= CPDef.sizeOfCS THEN EXIT;      fbr.addr ¬ fbr.addr + offset;      IF fbr.miNum = CPDef.StartAddr OR fbr.miNum = CPDef.StartAddrPlusOne THEN        BEGIN	NULL; -- Can't compare starting addresses        END      ELSE        BEGIN	addr: CPDef.RealCS ¬ fbr.addr;	expected: CPuFormat.MI ¬ pb­;	found: CPuFormat.MI ¬ CPKernel.ReadCS[addr];	badParity: BOOLEAN ¬ BadParity[found];	instructions ¬ instructions + 1;	IF found # expected OR badParity THEN	  BEGIN	  xor: CPuFormat.MI;	  text: STRING = [200];	  FOR i: CARDINAL IN [0..SIZE[CPuFormat.MI]) DO	    a: POINTER = LOOPHOLE[@expected+i];	    b: POINTER = LOOPHOLE[@found+i];	    c: POINTER = LOOPHOLE[@xor+i];	    c­ ¬ Inline.BITXOR[a­, b­];	    ENDLOOP;	  IF mismatches = 0 THEN	    Format.Line[log, "    Addr         expected            found              xor"L, arg];	  mismatches ¬ mismatches + 1;	  CPSymbol.AppendRealCS[text, addr];	  FOR i: CARDINAL IN [text.length..8) DO String.AppendChar[text, ' ]; ENDLOOP;	  String.AppendString[text, "   "L];	  CPSymbol.AppendMI[text, expected];	  String.AppendString[text, "   "L];	  CPSymbol.AppendMI[text, found];	  IF badParity THEN String.AppendString[text, "*  "L]	  ELSE String.AppendString[text, "   "L];	  CPSymbol.AppendMI[text, xor];	  Format.Line[log, text, arg];	  END;        END;      IF UserInput.UserAbort[NIL] THEN EXIT;  -- Better than nothing...      ENDLOOP;    stop ¬ System.GetClockPulses[];    ms ¬ System.PulsesToMicroseconds[[stop - start]]/1000;    InfoCompare[log, arg, ms, instructions, mismatches];    END;      BadParity: PROCEDURE [data: CPuFormat.MI] RETURNS [BOOLEAN] =    BEGIN    words: LONG POINTER = @data;    parity: WORD ¬ 0;    odd: WORD ¬ 1;    FOR i: CARDINAL IN [0..SIZE[CPuFormat.MI]) DO      parity ¬ Inline.BITXOR[parity, (words+i)­];      ENDLOOP;    parity ¬ Inline.BITXOR[parity, Inline.BITSHIFT[parity, -8]];    parity ¬ Inline.BITXOR[parity, Inline.BITSHIFT[parity, -4]];    parity ¬ Inline.BITXOR[parity, Inline.BITSHIFT[parity, -2]];    parity ¬ Inline.BITXOR[parity, Inline.BITSHIFT[parity, -1]];    RETURN[Inline.BITAND[parity, 1] # odd];    END;  InfoCompare: PROCEDURE [    log: Format.StringProc, arg: LONG POINTER, ms, instructions, mismatches: LONG CARDINAL] =    BEGIN    Format.Text[log, "It took "L, arg];    Format.LongDecimal[log, ms, arg];    Format.Text[log, " ms to compare "L, arg];    Format.LongDecimal[log, instructions, arg];    Format.Text[log, " instructions."L, arg];    IF ms # 0 THEN      BEGIN      Format.Text[log, " ("L, arg];      Format.LongDecimal[log, instructions*16*SIZE[CPuFormat.MI]*1000/ms, arg];      Format.Text[log, " bits/sec)"L, arg];      END;    Format.CR[log, arg];    IF mismatches # 0 THEN      BEGIN      Format.Text[log, "There were "L, arg];      Format.LongDecimal[log, mismatches, arg];      Format.Line[log, " mismatches."L, arg];      END;    END;  END.
-- Copyright (C) 1985  by Xerox Corporation. All rights reserved. -- StrCnvrtImpl.mesa, RdH       , 22-Jan-85 15:42:27-- Last edited by --  Rick RDH      	 5-Feb-85 17:10:00 Add StrToCard.--  Rick RDH      	22-Jan-85 16:54:56 Create.DIRECTORY  Inline,  StrCnvrt,  String;  StrCnvrtImpl: PROGRAM IMPORTS Inline, StrCnvrt, String EXPORTS StrCnvrt = BEGIN    --$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$--  -- Convert the substring into a number according to the given base.  -- Check that it fits into the given bounds.  -- Interpret x's as dont care's according to the dontCare parameter.  -- Ignore blanks both before and in the middle of a number.  -- May raise StrCnvrt.StrCnvrtErr for a variety of reasons.  SubStrToNum: PUBLIC PROC[numSubStr: String.SubString, min: LONG INTEGER ¬ 0,     max: LONG INTEGER ¬ CARDINAL.LAST, radix: StrCnvrt.Radix ¬ 16,     dontCare: StrCnvrt.DontCareType ¬ mustCare] RETURNS     [num: LONG UNSPECIFIED ¬ 0] = BEGIN        start: BOOLEAN ¬ TRUE;    digit: CARDINAL;    negative: BOOLEAN ¬ FALSE;        IF String.Length[numSubStr.base] < numSubStr.length THEN       StrCnvrt.StrCnvrtErr["SubStrToNum passed a bad substring"];           FOR i: CARDINAL IN [numSubStr.offset..numSubStr.offset+numSubStr.length) DO      SELECT numSubStr.base[i] FROM        '  => NULL;	'x, 'X => { 	  SELECT dontCare FROM	    zeros => num ¬ num * radix + 0;	    ones => num ¬ num * radix + (radix - 1);  	    reallyDontCare => num ¬ num * radix;	    mustCare => ERROR StrCnvrt.StrCnvrtErr["Unwanted don't cares"L];	    ENDCASE;	  start ¬ FALSE;};	IN ['0..'9] => {	  digit ¬ numSubStr.base[i] - '0;	  IF digit < radix THEN	    num ¬ num * radix + digit	    ELSE ERROR StrCnvrt.StrCnvrtErr["Digits inconsistant with radix"L];	  start ¬ FALSE;};	IN ['a..'f] => {	  digit ¬ numSubStr.base[i] - 'a + 10;	  IF digit < radix THEN	    num ¬ num * radix + digit	    ELSE ERROR StrCnvrt.StrCnvrtErr["Digits too big for radix"L];	  start ¬ FALSE;};	IN ['A..'F] => {	  digit ¬ numSubStr.base[i] - 'A + 10;	  IF digit < radix THEN	    num ¬ num * radix + digit	    ELSE ERROR StrCnvrt.StrCnvrtErr["Digits too big for radix"L];	  start ¬ FALSE;};	'- => {	  IF start THEN BEGIN	    negative ¬ TRUE;	    start ¬ FALSE;	    END ELSE BEGIN	    ERROR StrCnvrt.StrCnvrtErr["Minus not at start of string"L];	    END;	  }	ENDCASE => { StrCnvrt.StrCnvrtErr["Non-numeric characters in string"L]; };      ENDLOOP;            IF negative THEN num ¬ -num;        -- Check bounds --    IF min > num THEN ERROR StrCnvrt.StrCnvrtErr["Number too small"L];    IF max < num THEN ERROR StrCnvrt.StrCnvrtErr["Number too large"L];  END; --SubStrToNum--      --$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$--  StrToNum: PUBLIC PROC[numStr: LONG STRING, min: LONG INTEGER ¬ 0,     max: LONG INTEGER ¬ CARDINAL.LAST, radix: StrCnvrt.Radix ¬ 16,     dontCare: StrCnvrt.DontCareType ¬ mustCare] RETURNS [LONG INTEGER] =     BEGIN    numSubStr: String.SubStringDescriptor;    IF String.Length[numStr] = 0 THEN BEGIN      ERROR StrCnvrtErr["StrToNum passed null string."];      END;    numSubStr ¬ [numStr, 0, numStr.length];    RETURN[SubStrToNum[numSubStr: @numSubStr, min: min, max: max, radix: radix,      dontCare: dontCare]];    END; --StrToNum--      --$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$--  StrToCard: PUBLIC PROC[numStr: LONG STRING, min: LONG INTEGER ¬ 0,     max: LONG INTEGER ¬ CARDINAL.LAST, radix: StrCnvrt.Radix ¬ 16,     dontCare: StrCnvrt.DontCareType ¬ mustCare] RETURNS [CARDINAL] = BEGIN        RETURN[Inline.LowHalf[StrToNum[numStr, min, max, radix, dontCare]]];    END;--StrToCard--    --$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$--  StrCnvrtErr: PUBLIC ERROR [typeOfErr: LONG STRING] = CODE;    END.
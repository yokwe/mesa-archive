-- Copyright (C) 1984, 1985 by Xerox Corporation. All rights reserved. -- HBCommandImpl.mesa-- Create by FS  :   14-Nov-84 12:46:35-- Last edited by --  RDH	 17-May-85 13:52:25 Correct tag to UseSymbols on boolean item.--  RDH	 16-May-85 18:17:44 Make HBDisplay public.--  RDH	 22-Apr-85 11:56:32 Add capability to use symbolic IOP addresses.--  RDH	 15-Mar-85 15:54:01 Add checking to ManualTrigger and Stop.--  RDH	 14-Mar-85 12:22:00 Include bit numbers in tags for parameter form items.--  RDH	  6-Mar-85 16:34:23 Add stuff for detecting if i186 is running or idle.--  RDH	 27-Feb-85 11:29:22 Cosmetic changes to commandSW.--  RDH	 24-Feb-85 12:07:51 Remove Boot command.  Implement NotifyUserOfStateChange.  Use HBAction instead of Bindweed directly.--  RDH	 5-Feb-85 12:27:18 Change ClientTransition for timeStamping.  Fix storage leak.--  RDH	31-Jan-85 13:09:13 Add boolean item to paraformSW to distinguish Symbolic CS addresses from numeric.--  RDH	21-Jan-85 17:24:48 Introduce names for IO locations.--  RDH	15-Jan-85 16:37:21 Run FixArrows and remove Bindweed.Continue's.DIRECTORY  Exec,  FormSW,  Heap,  HBAccess,  HBAction,  HBIO,  Inline,  Put,  String,  System,  Tool,  ToolWindow,  UserInput,  Window;HBCommandImpl: PROGRAM  IMPORTS    Exec, FormSW, Heap, HBAccess, HBAction, HBIO, Inline, Put, String, Tool, UserInput  EXPORTS    HBIO = BEGIN  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = MACHINE DEPENDENT RECORD [    cmdformSW(0): Window.Handle ¬ NIL,    msgSW(2): Window.Handle ¬ NIL,    paraformSW(4): Window.Handle ¬ NIL,    titleSW(6): Window.Handle ¬ NIL,    fileSW(8): Window.Handle ¬ NIL,    targetDevice(10): HBAction.TargetDevice ¬ iop,    delayX(11): LONG STRING ¬ NIL,    from(13): LONG STRING ¬ NIL,    to(15): LONG STRING ¬ NIL,    hBState(17): HBAction.HBState ¬ idle,    fileName(18): LONG STRING ¬ NIL,    iOPAddress(20): LONG STRING ¬ NIL,    status(22): LONG STRING ¬ NIL,    arbitor(24): LONG STRING ¬ NIL,    data(26): LONG STRING ¬ NIL,    nWait(28): LONG STRING ¬ NIL,    iOPwildCard(30): LONG STRING ¬ NIL,    cSNIA(32): LONG STRING ¬ NIL,    bankSel(34): LONG STRING ¬ NIL,    cSwildCard(36): LONG STRING ¬ NIL,    distCNT(38): LONG STRING ¬ NIL,    symbolicAddr(40): BOOLEAN ¬ FALSE,    runningOpie(41): BOOLEAN ¬ FALSE];        FormCmdItems: TYPE = {sample, targetDevice, delayX, option, stop0,    hBdisplay, from, to, runningOpie, stop1, readState, hBState, distCNT,    load, save, fileName};  FormParaItems: TYPE = {iOPAddress, status, arbitor, data, nWait, iOPwildCard,    cSNIA, bankSel, cSwildCard, symbolicAddr};  data: DataHandle ¬ NIL;  wh: Window.Handle ¬ NIL;  zone: UNCOUNTED ZONE ¬ Heap.systemZone;  globSW: PUBLIC HBIO.SwitchHandle ¬ NIL;  displayBuffer: PUBLIC LONG POINTER TO HBAction.SWBuffer ¬ NIL;  initialized: BOOLEAN ¬ FALSE;  sbWorking: PUBLIC BOOLEAN ¬ TRUE;  somethingInSWBuffer: PUBLIC BOOLEAN ¬ FALSE;  runningOpie: PUBLIC BOOLEAN ¬ FALSE;    --$$$$$$$$$$$$$$$$$$$$$$$$$      MessageTimeout    $$$$$$$$$$$$$$$$$$$$$$--  MessageTimeout: PROCEDURE = {    data.hBState ¬ idle;    FormSW.DisplayItem[data.cmdformSW, ORD[FormCmdItems.hBState]];    Put.Line[data.msgSW, "i186 Timeout..."L];    sbWorking ¬ TRUE};      --$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$   ErrMessage   $$$$$$$$$$$$$$$$$$$$$$$$$$--  ErrMessage: PUBLIC PROC[message: LONG STRING] = BEGIN    Put.Line[data.msgSW, message];    END;--ErrMessage--                 --$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$   Aborted   $$$$$$$$$$$$$$$$$$$$$$$$$$--  Aborted: PUBLIC PROC[] RETURNS[BOOLEAN] = BEGIN    RETURN[UserInput.UserAbort[data.fileSW] OR UserInput.UserAbort[data.cmdformSW]      OR  UserInput.UserAbort[data.paraformSW]];    END;--Aborted--            --$$$$$$$$$$$$$$$$$$$$$$$$$      Sample    $$$$$$$$$$$$$$$$$$$$$$--  Sample:  FormSW.ProcType = BEGIN    ok: CARDINAL ¬ 0;    <<    [delay, ok] ¬ GetNum[data.delayX];    IF ok = 1 THEN {      Put.Line[data.msgSW, "Empty field \'Delay\'"L]; RETURN};    IF (delay > 16) THEN {      Put.Line[data.msgSW, "Bad number in field \'Delay\'"L]; RETURN};    delay ¬ delay * 256;    >>    IF data.targetDevice = iop THEN      HBIO.SampleIOP[data.msgSW, data.iOPAddress, data.status, data.arbitor,         data.data, data.nWait, data.iOPwildCard, data.delayX, data.symbolicAddr]    ELSE      HBIO.SampleCS[        data.msgSW, data.cSNIA, data.bankSel, data.cSwildCard, data.delayX,        data.symbolicAddr];    IF NOT sbWorking THEN MessageTimeout[];    END;--Sample--      --$$$$$$$$$$$$$$$$$$$      NotifyUserOfStateChange    $$$$$$$$$$$$--  --Record the new state and display it.   NotifyUserOfStateChange: PUBLIC PROC[newState: HBAction.HBState] = BEGIN    data.hBState ¬ newState;    FormSW.DisplayItem[data.cmdformSW, ORD[FormCmdItems.hBState]];    END;--NotifyUserOfStateChange--      --$$$$$$$$$$$$$$$$$$$$$   Option   $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$--  --Open options window.  Option:  FormSW.ProcType = {HBIO.OpenOpWindow[]};  --$$$$$$$$$$$$$$$$$$$$$  Stop0  $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$--  --Called when user bugs ManualTrigger!.  Manually trigger the history buffer.  Read and display the new state.  Check that there is a sample going on to stop and that stopping the sample won't kill the program running in the IOP.        Stop0:  FormSW.ProcType = BEGIN    statusWord: HBAction.HBStatus;    notSampling: BOOLEAN;        --Check for a sample taking place by trying to get access to the history buffer for a sample.  If we get it then there is no sample going on and we should not try and stop it.    notSampling ¬ HBAccess.AskForSampleAccess[];    IF notSampling THEN BEGIN      HBIO.ErrMessage["Not sampling.  Nothing to trigger."L];      --Release sample access and then all access.      HBAccess.ReleaseHB[]; HBAccess.TriggerDetected[];      HBAccess.ReleaseHB[];      RETURN;      END;           --Check that triggering the sample won't kill a program running in the IOP.    IF NOT(HBIO.I186Idle[] OR HBIO.RunningOpie[]) THEN BEGIN      HBIO.ErrMessage["To trigger the sample would kill the program running in the IOP."L];      HBIO.ErrMessage["Either stop the IOP or set RunningOpie and try again."L];      RETURN;      END;        HBAction.ManualTrig[!HBAction.HBProb => GO TO SBTimeout];    Put.Line[data.fileSW, "History Buffer is Manually Triggered.."L];    statusWord ¬ HBAction.ReadStatus[];    HBIO.NotifyUserOfStateChange[newState: statusWord.state];    EXITS    SBTimeout => {sbWorking ¬ FALSE; MessageTimeout[]};    END;--Stop0--    --$$$$$$$$$$$$$$$$$$$$$  GetNum  $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$--  GetNum: PROCEDURE [str: LONG STRING] RETURNS [INTEGER, CARDINAL] = {    num: INTEGER ¬ 0;    start: CARDINAL ¬ 0;    neg: BOOLEAN ¬ FALSE;    IF str = NIL THEN RETURN[0,1];    IF str.text[0] = '- THEN {neg ¬ TRUE; start ¬ 1};    FOR i:CARDINAL IN [start..str.length) DO      SELECT str.text[i] FROM        IN ['0..'9] => {num ¬ num * 16 + str.text[i] - '0};        IN ['A..'F] => {num ¬ num * 16 + str.text[i] - 'A + 10};        IN ['a..'f] => {num ¬ num * 16 + str.text[i] - 'a + 10};        ENDCASE => {RETURN[0,2]};      IF num > 2048 THEN RETURN[2500,2];      ENDLOOP;    IF neg THEN num ¬ -num;    RETURN[num, 0]};  --$$$$$$$$$$$$$$$$$$$$$  HBDisplay  $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$--  HBDisplay: PUBLIC FormSW.ProcType = BEGIN    bottom, top: INTEGER;    ok: CARDINAL ¬ 0;    [bottom, ok] ¬ GetNum[data.from];    IF ok # 0 THEN {      IF ok = 2 THEN {        Put.Line[data.msgSW, "Bad number in field \'from\'"L]; RETURN}      ELSE  Put.Line[data.msgSW, "Empty field \'from\'"L]; RETURN};    [top, ok] ¬ GetNum[data.to];    IF ok # 0 THEN {      IF ok = 2 THEN {        Put.Line[data.msgSW, "Bad number in field \'to\'"L]; RETURN}      ELSE Put.Line[data.msgSW, "Empty field \'to\'"L]; RETURN};    HBIO.DoDisplay[display: data.fileSW, heading: data.titleSW, low: bottom,      high: top, target: data.targetDevice];     IF NOT sbWorking THEN MessageTimeout[];    END;--HBDisplay----$$$$$$$$$$$$$$$$$$$$$$$$$$   Stop1    $$$$$$$$$$$$$$$$$$$$$$$$$--  --Called when user bugs Stop!.  Check that there is a sample going on to stop and that stopping the sample won't kill the program running in the IOP.  Stop the sampling process.  Check that the sample is stopped.  Show the user the new state.  Stop1:  FormSW.ProcType = BEGIN    statusWord: HBAction.HBStatus;    notSampling: BOOLEAN;        --Check for a sample taking place by trying to get access to the history buffer for a sample.  If we get it then there is no sample going on and we should not try and stop it.    notSampling ¬ HBAccess.AskForSampleAccess[];    IF notSampling THEN BEGIN      HBIO.ErrMessage["Not sampling.  Nothing to stop."L];      --Release sample access and then all access.      HBAccess.ReleaseHB[]; HBAccess.TriggerDetected[];      HBAccess.ReleaseHB[];      RETURN;      END;           --Check that stopping the sample won't kill a program running in the IOP.    IF NOT(HBIO.I186Idle[] OR HBIO.RunningOpie[]) THEN BEGIN      HBIO.ErrMessage["Stopping sample would kill the program running in the IOP."L];      HBIO.ErrMessage["Either stop the IOP or set RunningOpie and try again."L];      RETURN;      END;        HBAction.ManualStop[!HBAction.HBProb => GO TO SBTimeout];    Put.Line[data.fileSW, "History Buffer is Manually Stopped.."L];    statusWord ¬ HBAction.ReadStatus[];    HBIO.NotifyUserOfStateChange[newState: statusWord.state];        EXITS    SBTimeout => {sbWorking ¬ FALSE; MessageTimeout[]};    END;--Stop1--    --$$$$$$$$$$$$$$$$$$$$$$$$$$   GetStrFromNum    $$$$$$$$$$$$$$$$$$$$$$$$$--  GetStrFromNum: PROCEDURE [d: WORD] RETURNS[LONG STRING] = {    str: LONG STRING ¬ [4];    num: WORD;    FOR i:INTEGER IN [0..3) DO      num ¬ Inline.BITAND[Inline.BITSHIFT[d, (i*4 - 8)], 17B];      SELECT num FROM        IN [0..9] => {String.AppendChar[str, num + '0]};	IN [10..15] => {String.AppendChar[str, num - 10 + 'A]};	ENDCASE => {};      ENDLOOP;    RETURN[str]};  --$$$$$$$$$$$$$$$$$$$$$$$$$$   ReadState    $$$$$$$$$$$$$$$$$$$$$$$$$--  --Called when user bugs HBState!.  Check to avoid bombing IOP program.  Then read the status register.  Update the state field and the distCNT field in the commandSW.  ReadState:  FormSW.ProcType = BEGIN    statusWord: HBAction.HBStatus;           --Check that reading the history buffer's state won't kill a program running in the IOP.    IF NOT(HBIO.I186Idle[] OR HBIO.RunningOpie[]) THEN BEGIN      HBIO.ErrMessage["Reading state would kill the program running in the IOP."L];      HBIO.ErrMessage["Either stop the IOP or set RunningOpie and try again."L];      RETURN;      END;        statusWord ¬ HBAction.ReadStatus[!HBAction.HBProb => GOTO SBTimeout];    data.hBState ¬ statusWord.state;    String.Copy[data.distCNT, GetStrFromNum[statusWord.delayCntr]];    FormSW.DisplayItem[data.cmdformSW, ORD[FormCmdItems.hBState]];    FormSW.DisplayItem[data.cmdformSW, ORD[FormCmdItems.distCNT]];    EXITS    SBTimeout => {sbWorking ¬ FALSE; MessageTimeout[]};    END;--ReadState--  --$$$$$$$$$$$$$$$$$$$$$$$$$$   Save    $$$$$$$$$$$$$$$$$$$$$$$$$--  Save:  FormSW.ProcType = {    Put.Line[data.fileSW, "Save called"L]};  --$$$$$$$$$$$$$$$$$$$$$$$$$$   Load    $$$$$$$$$$$$$$$$$$$$$$$$$--  Load:  FormSW.ProcType = {    Put.Line[data.fileSW, "Load called"L]};      --$$$$$$$$$$$$$$$$$$$$   ToggleRunningOpie    $$$$$$$$$$$$$$$$$$$$$--  ToggleRunningOpie: FormSW.NotifyProcType = {    HBIO.runningOpie ¬ NOT HBIO.runningOpie;    };      --$$$$$$$$$$$$$$$$$$$$$$$$$$   HideBankSelect    $$$$$$$$$$$$$$$$$$$$$$$$$--  HideBankSelect: FormSW.NotifyProcType = {    bankSelectIndex: CARDINAL = FormParaItems.bankSel.ORD;    FormSW.ToggleVisibility[sw: data.paraformSW, index: bankSelectIndex];};  --$$$$$$$$$$$$$$$$$$$$$$$$$$   ClientTransition    $$$$$$$$$$$$$$$$$$$$$$$$$--  ClientTransition: ToolWindow.TransitionProcType = BEGIN    SELECT TRUE FROM      old = inactive => BEGIN        HBIO.OptionNew[];        IF globSW = NIL THEN globSW ¬ zone.NEW[HBIO.Switches ¬ []];	IF displayBuffer = NIL THEN displayBuffer ¬ zone.NEW[HBAction.SWBuffer];        IF data = NIL THEN BEGIN	  data ¬ zone.NEW[Data ¬ []];	  data.distCNT ¬ String.MakeString[zone, 8]	  END;	somethingInSWBuffer ¬ FALSE;	END;      new = inactive => BEGIN        HBIO.OptionFree[];	zone.FREE[@globSW.fileName];        IF globSW # NIL THEN zone.FREE[@globSW];        IF displayBuffer # NIL THEN zone.FREE[@displayBuffer];        IF data # NIL THEN BEGIN	  String.FreeString[zone, data.distCNT];	  zone.FREE[@data]	  END;	HBIO.FreeTimeStamp[z: Heap.systemZone, timeStamp: @HBIO.timeAndTrig];	END;      ENDCASE;    END;--ClientTransition----$$$$$$$$$$$$$$$$$$$$$$$$$$$$    Init    $$$$$$$$$$$$$$$$$$$$--  --Make the connection to the history buffer and create the window.  Init: PROCEDURE[h: Exec.Handle] = BEGIN    hbReady: BOOLEAN;    Box: ToolWindow.Box ¬ [[512,30],[512,740]];        IF initialized THEN RETURN;        --Get history buffer ready to talk.    hbReady ¬ HBAction.InitConnectionToHB[h];    IF NOT hbReady THEN RETURN;          --Create the tool window.    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default, initialBox: Box,      clientTransition: ClientTransition, name: "DaisyHistoryBuffer"L,      cmSection: "DaisyHistoryBuffer"L];    initialized ¬ TRUE;    END;--Init--  --$$$$$$$$$$$$$$$$$$$$$$$$$$$$    Unload    $$$$$$$$$$$$$$$$$$$$--  Unload: Exec.ExecProc = {    [] ¬ Exec.UnloadCommand[h, "DaisyHistoryBuffer.~"];    Tool.Destroy[wh];    };--$$$$$$$$$$$$$$$$$$$$$$$$$$$$    MakeSWs    $$$$$$$$$$$$$$$$$$$$--  MakeSWs: Tool.MakeSWsProc = {    logName: LONG STRING ¬ [30];    Tool.UnusedLogName[unused: logName, root: "DaisyHistoryBuffer.log"L];    data.cmdformSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeCmdForm];    data.msgSW ¬ Tool.MakeMsgSW[window: window, lines: 15, h: 80];    data.paraformSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeParaForm, h: 88];    data.titleSW ¬ Tool.MakeMsgSW[window: window, lines: 5, h: 15];    data.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    };  --$$$$$$$$$$$$$$$$$$$$$$$$$$$$    MakeCmdForm    $$$$$$$$$$$$$$$$$$$$--  MakeCmdForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = FormCmdItems.LAST.ORD + 1;    targetDevice: ARRAY      [ORD[FIRST[HBAction.TargetDevice]]..ORD[LAST[HBAction.TargetDevice]]] OF      Enumerated ¬ [      ["IOP"L, ORD[HBAction.TargetDevice[iop]]],       ["CS"L, ORD[HBAction.TargetDevice[cs]]]];    hBState: ARRAY [ORD[FIRST[HBAction.HBState]]..ORD[LAST[HBAction.HBState]]] OF      Enumerated ¬ [      ["Sampling"L, ORD[HBAction.HBState[readSample]]],       ["Idle"L, ORD[HBAction.HBState[idle]]],      ["Triggered"L, ORD[HBAction.HBState[delay]]],       ["Illegal"L, ORD[HBAction.HBState[illegal]]]];    items ¬ AllocateItemDescriptor[nItems];    items[FormCmdItems.sample.ORD] ¬ CommandItem[      tag: "Sample"L, place: [6, line0], proc: Sample];    items[FormCmdItems.targetDevice.ORD] ¬ EnumeratedItem[      tag: ""L, place: [120, line0], feedback: all,       choices: DESCRIPTOR[targetDevice], value: @data.targetDevice];    items[FormCmdItems.delayX.ORD] ¬ StringItem[      tag: "Delay(X256)"L, place: [210, line0], inHeap: TRUE,       string: @data.delayX];    items[FormCmdItems.option.ORD] ¬ CommandItem[      tag: "Options"L, place: [354, line0], proc: Option];    items[FormCmdItems.stop0.ORD] ¬ CommandItem[      tag: "ManualTrigger"L, place: [6, line1], proc: Stop0];    items[FormCmdItems.hBdisplay.ORD] ¬ CommandItem[      tag: "Display"L, place: [132, line1], proc: HBDisplay];    items[FormCmdItems.from.ORD] ¬ StringItem[      tag: "From"L, place: [186, line1], inHeap: TRUE, string: @data.from];    items[FormCmdItems.to.ORD] ¬ StringItem[      tag: "To"L, place: [264, line1], inHeap: TRUE, string: @data.to];    items[FormCmdItems.runningOpie.ORD] ¬ BooleanItem[tag: "Running Opie"L,      place: [354, line1], switch: @data.runningOpie, drawBox: TRUE,       proc: ToggleRunningOpie];    items[FormCmdItems.stop1.ORD] ¬ CommandItem[      tag: "Stop"L, place: [6, line2], proc: Stop1];    items[FormCmdItems.readState.ORD] ¬ CommandItem[      tag: "HBState"L, place: [78, line2], proc: ReadState];    items[FormCmdItems.hBState.ORD] ¬ EnumeratedItem[      tag: ":"L, place: [126, line2], readOnly: TRUE,       choices: DESCRIPTOR[hBState], value: @data.hBState];    items[FormCmdItems.distCNT.ORD] ¬ StringItem[      tag: "DistCNT"L, place: [240, line2], readOnly: TRUE, inHeap: TRUE,       string: @data.distCNT];    items[FormCmdItems.load.ORD] ¬ CommandItem[      tag: "Load"L, place: [6, line3], proc: Load];    items[FormCmdItems.save.ORD] ¬ CommandItem[      tag: "Save"L, place: [60, line3], proc: Save];    items[FormCmdItems.fileName.ORD] ¬ StringItem[      tag: "FileName"L, place: [120, line3], inHeap: TRUE,       string: @data.fileName];    RETURN[items: items, freeDesc: TRUE];    };      --$$$$$$$$$$$$$$$$$$$$$$$$$      MakeParaForm    $$$$$$$$$$$$$$$$$$$$$$--  MakeParaForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = FormParaItems.LAST.ORD + 1;    items ¬ AllocateItemDescriptor[nItems];    items[FormParaItems.iOPAddress.ORD] ¬ StringItem[      tag: "IOP => Address(24)"L, place: [6, line0], inHeap: TRUE,       string: @data.iOPAddress];    items[FormParaItems.status.ORD] ¬ StringItem[      tag: "Status(3)"L, place: [284, line0], inHeap: TRUE, string: @data.status];    items[FormParaItems.arbitor.ORD] ¬ StringItem[      tag: "Arbitor(10)"L, place: [364, line0], inHeap: TRUE,       string: @data.arbitor];    items[FormParaItems.data.ORD] ¬ StringItem[      tag: "Data(16)"L, place: [48, line1], inHeap: TRUE, string: @data.data];    items[FormParaItems.nWait.ORD] ¬ StringItem[      tag: "NWait(4)"L, place: [204, line1], inHeap: TRUE, string: @data.nWait];    items[FormParaItems.iOPwildCard.ORD] ¬ StringItem[      tag: "WildCard(7)"L, place: [312, line1], inHeap: TRUE,       string: @data.iOPwildCard];    items[FormParaItems.cSNIA.ORD] ¬ StringItem[      tag: "CS => NIA(12)"L, place: [6, line2], inHeap: TRUE,       string: @data.cSNIA];    items[FormParaItems.bankSel.ORD] ¬ StringItem[      tag: "BankSel(4)"L, place: [164, line2], inHeap: TRUE,       string: @data.bankSel];    items[FormParaItems.cSwildCard.ORD] ¬ StringItem[      tag: "WildCard(16)"L, place: [272, line2], inHeap: TRUE,       string: @data.cSwildCard];    items[FormParaItems.symbolicAddr.ORD] ¬ BooleanItem[tag: "Use Symbols"L,      place: [6, line3], switch: @data.symbolicAddr, drawBox: TRUE,       proc: HideBankSelect];    RETURN[items: items, freeDesc: TRUE];    };  --$$$$$$$$$$$$$$$$$$$$$$$$$$$$    IgnoreCommandLine    $$$$$$$$$$$$$$$$$$$$--  IgnoreCommandLine: Exec.ExecProc = BEGIN     IF NOT initialized THEN {Init[h]; HBIO.OptionInit[]};     END;    --$$$$$$$$$$$$$$$$$$$$$$$$$$$$    Register    $$$$$$$$$$$$$$$$$$$$--  Register: PROC = BEGIN    Exec.AddCommand[name: "DaisyHistoryBuffer.~"L, proc: IgnoreCommandLine];     END;  --$$$$$$$$$$$$$$$$$$$$$$$$$$$$    Mainline code    $$$$$$$$$$$$$$$$$$$$--  Register[];  END...   
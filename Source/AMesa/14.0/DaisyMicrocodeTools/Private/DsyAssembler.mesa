-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. --Last edit by JAC           24-Feb-85 14:54:04DIRECTORY  MFile USING [Handle],  MSegment USING [Handle];DsyAssembler: DEFINITIONS =  BEGIN      -- TYPE DECLARATIONS    AddressConstant: TYPE = RECORD [    SELECT OVERLAID *  FROM      word => [word: WORD],      separate => [pad: [0..256),                   aiu: [0..16),                   ail: [0..8),		   ac: [0..2)],      ENDCASE];        AFileErrorCode: TYPE = {illegalJumpReference, illegalJumpSource, illegalReference, illegalSource};          ArgumentType: TYPE = RECORD [    arg: CARDINAL ¬ 0,    regType: RegisterType ¬ zero,    negate: BOOLEAN ¬ FALSE];    Assignment: TYPE = RECORD [    -- This record is used to keep track of what causes a field assignment.  This allows us to print a meaningful error message when a field assignment conflicts and insure that it is known that a field has been assigned.    element: SELECT type: * FROM      null => NULL,      expression => NULL,      macro => [macroIndex: MacroIndex],      register => [registerType: RegisterType],      builtinMacro => [type: BuiltinMacroType],      ENDCASE];  BuiltinMacroType: TYPE = {    add, and, mul, or, xor  -- use Arith proc    , sub, lshift, rshift  -- use Arith2 proc    , goto, gotoabs, branch, cancelbr, disp2, disp3, disp4, ret  -- use Branch proc    , equal, greater, andZero  -- use If proc    , import, export  -- use External proc    , sa, saPlus1  --use StartAddress proc    , setConstant, setLabel  --use Set proc    , null  -- for other procs    };  Carry: TYPE = {zero, one, x};  ElementRec: TYPE = RECORD [  --type of elements which may occur in a phrase    element: SELECT type: * FROM      name => [string: LONG STRING],      arrow => NULL,      partialArrow => NULL,      plus => NULL,      minus => NULL,      mpy => NULL,      not => NULL,      logical => [logicalOperation: LogicalOperation],      register => [registerType: RegisterType, regnum: CARDINAL],      constant => [value: CARDINAL],      variable => [val: CARDINAL],      macro => [macroIndex: MacroIndex],      macroArrow => [macroIndex: MacroIndex],      macroRHS => [macroIndex: MacroIndex],      link => [macroIndex: MacroIndex],      arrowPhrase => NULL,      userMacro => [str: LONG STRING],      label => [str: LONG STRING, value: CARDINAL],      builtinMacro => [        proc: PROCEDURE [BuiltinMacroType] RETURNS [RetType],        type: BuiltinMacroType],      undefinedToken => NULL,      star => NULL,      empty => NULL,      ENDCASE];  Encoding: TYPE = RECORD [    nextEncoding: EncodingPtr ¬ NIL,  -- points to next possible encoding of phrase;  NIL if no alternate.    op: FieldAssignment ¬ [Assignment[null[]], 0],    rA: FieldAssignment ¬ [Assignment[null[]], rAZero],    rB: FieldAssignment ¬ [Assignment[null[]], rBZero],    rD: FieldAssignment ¬ [Assignment[null[]], rDNoop],    alu: FieldAssignment ¬ [Assignment[null[]], 0],    ci: FieldAssignment ¬ [Assignment[null[]], 0],    sp2: FieldAssignment ¬ [Assignment[null[]], sp2Noop],    sp1: FieldAssignment ¬ [Assignment[null[]], sp1Noop],    dspB: FieldAssignment ¬ [Assignment[null[]], dspBNoop],    shift: FieldAssignment ¬ [Assignment[null[]], 0],    ib: FieldAssignment ¬ [Assignment[null[]], ibNoop],    it: FieldAssignment ¬ [Assignment[null[]], 0],    aAdr: FieldAssignment ¬ [Assignment[null[]], 0],    om: FieldAssignment ¬ [Assignment[null[]], omImmed],    mo: FieldAssignment ¬ [Assignment[null[]], moNoop],    ac: FieldAssignment ¬ [Assignment[null[]], 1],    aiu: FieldAssignment ¬ [Assignment[null[]], 15],    ail: FieldAssignment ¬ [Assignment[null[]], 7],    hiByte: FieldAssignment ¬ [Assignment[null[]], 0],    imu: FieldAssignment ¬ [Assignment[null[]], 31],     iml: FieldAssignment ¬ [Assignment[null[]], 7],    cycle: FieldAssignment ¬ [Assignment[null[]], 0],    isStk: BOOLEAN ¬ FALSE,    isPop: BOOLEAN ¬ FALSE,    isPush: BOOLEAN ¬ FALSE      ];  EncodingPtr: TYPE = LONG POINTER TO Encoding;  ErrorMsg: TYPE = RECORD [    nextMsg: ErrorMsgPtr,    msg: LONG STRING,  -- points to length    length: CARDINAL,    maxlength: CARDINAL];  -- followed by text  ErrorMsgPtr: TYPE = LONG POINTER TO ErrorMsg;  Expression: TYPE = RECORD [    operation: Operation ¬ x,    operand1: Operand ¬ zero,    operand2: Operand ¬ zero,    carry: Carry ¬ x];  ExpressionArgs: TYPE = RECORD [operand1: Operand, operand2: Operand];  ExpressionPattern: TYPE = RECORD [    expressionArgs: ExpressionArgs, pattern: Pattern];  ExpressionPatternPtr: TYPE = LONG POINTER TO ExpressionPattern;    Extract4: TYPE = RECORD [    SELECT OVERLAID * FROM      word => [word: WORD],      separate => [pad: [0..4096),                   lower4: [0..16)],      ENDCASE];        Extract3: TYPE = RECORD [    SELECT OVERLAID * FROM      word => [word: WORD],      separate => [pad: [0..8192),                   lower3: [0..8)],      ENDCASE];  FieldAssignment: TYPE = RECORD [assignment: Assignment, value: CARDINAL];    Flagword: TYPE = RECORD [    FirstChar: BOOLEAN ¬ TRUE,    ArrowClause: BOOLEAN ¬ FALSE,    HasArgs: BOOLEAN ¬ FALSE,    LeadDigit: BOOLEAN ¬ FALSE,    LeadBrkt: BOOLEAN ¬ FALSE,    Semi: BOOLEAN ¬ FALSE,    Label: BOOLEAN ¬ FALSE,    Error: BOOLEAN ¬ FALSE,    Eof: BOOLEAN ¬ FALSE];    ImmediateData: TYPE = RECORD [    SELECT OVERLAID *  FROM      word => [word: WORD],      separate => [pad: [0..256),                   imu: [0..32),                   iml: [0..8)],      ENDCASE];      LogicalOperation: TYPE = {and, or, xor, nand, nor, nxor};  MacroIndex: TYPE = [0..256);  MacroPattern: TYPE = RECORD [macro: LONG STRING, pattern: Pattern];  MacroPatternPtr: TYPE = LONG POINTER TO MacroPattern;    MemoryErrorCode: TYPE  = {atCycleError, atTypeConflict, cycleIllegalHere, cycleConflict, dataNotAvailable, destCycleConflict, destTypeConflict, fromCycleError, fromTypeConflict, illegalMDRSource, illegalStart, jumpCycleConflict, jumpTypeConflict, jumpNeedsCycle, needsCycle, needsMARType, noMDR, mdrIllegal, typeConflict};    MEntry: TYPE = RECORD [    key: LONG STRING, ptr: LONG POINTER TO ElementRec, next: MEntryPtr];  MEntryPtr: TYPE = LONG POINTER TO MEntry;  MyString: TYPE = RECORD [NextChar: CARDINAL, String: LONG STRING];  MyStringPtr: TYPE = LONG POINTER TO MyString;  Operand: TYPE = {zero, aBus, bBus};  Operation: TYPE = {x, Nx, or, Nor, and, Nand, xor, Nxor, aPlusB, xPlusCI, minus, mpy};    ParityMasks: TYPE = RECORD [    mask1: CARDINAL ¬ 0,    mask2: CARDINAL ¬ 0,    mask3: CARDINAL ¬ 0];    passMultiSeg: TYPE = RECORD[PassFileHandle: MFile.Handle ¬ NIL,    PassSeg: MSegment.Handle,    PassSegPtr: LONG POINTER,    nextSeg: LONG POINTER TO passMultiSeg ¬ NIL];  passMultiSegPtr: TYPE = LONG POINTER TO passMultiSeg;  Pattern: TYPE = RECORD [    op: {zero, one, two, three, x} ¬ x,    rA: {x, arg1, arg2} ¬ x,    rB: {x, arg1, arg2} ¬ x,    rD: {dFile, csBank, stkPtr, stkMinus2, stkMinus1, stkZero, stkPlus1, sameAsrB, CIP, Q, noop, A, aUpper8, aUpper16, aLower16, timerHigh, timerLow, prescaler} ¬ noop,    alu: {x, aPlusB, aMinusB, bMinusA, aAndB, aOrB, aXorB, aPlusCI, bPlusCI, aAndNB, aNandB, aNorB, aNxorB, mpy, naAndB} ¬ x,    ci: {x, zero, one} ¬ x,    sp2: {noop, eopTrapRq, clrMInt, popIB, uSource, vSource} ¬ noop,    sp1: {noop, incCIP, dincCIP, link0, link1, link2, link3, assignQ} ¬ noop,    dspB: {noop, L0Disp, L1Disp, L2Disp, L3Disp, aDisp, aluDisp, pcDisp, zeroBr, bDisp, rDisp, mintDisp, aHighDisp, readOKBr, writeOKBr, ibDisp, alwaysIBDisp} ¬ noop,    shift: {x, value} ¬ x,    ib: {noop, uReg, vReg, clear, pop, assigned} ¬ noop,  --see DsyEncodeImpl for an explanation of assigned    it: {x, t, f} ¬ x,    aAdr: {x, value} ¬ x,    om: {x, value} ¬ x,    mo: {A, map, U, read, doubleRead, write, doubleWrite, noop} ¬ noop,    ac: {x, value} ¬ x,    aiu: {x, value} ¬ x,    ail: {x, value} ¬ x,    hiByte: {x, value} ¬ x,    imu: {x, value} ¬ x,    iml: {x, value} ¬ x,    cycle: {x, c1, c2, c3, c4} ¬ x];    PatternPtr: TYPE = LONG POINTER TO Pattern;    Phrase: TYPE = RECORD [    nextPhrase: PhrasePtr ¬ NIL,  -- next phrase in stataement; NIL if end of statement    firstElement: PhraseElementPtr ¬ NIL,  -- points to first PhraseElement of phrase    currentElement: PhraseElementPtr ¬ NIL,  -- points to current PhraseElement of phrase being scanned by EncodePhrase    encoding: EncodingPtr ¬ NIL,  -- points to encoding for this phrase    expression: Expression ¬ [],  -- if this phrase has an expression, this will be filled in.    dest: CARDINAL ¬ 0FFFFH,    arg1: ArgumentType,  -- used for expression, if any    arg2: ArgumentType,  -- used for expression, if any    arg3: CARDINAL ¬ 0,  -- used for number of bits to extract if any or macroIndex    syntaxError: BOOLEAN ¬ FALSE,    formatError: BOOLEAN ¬ FALSE,    isStk: BOOLEAN ¬ FALSE,    isPop: BOOLEAN ¬ FALSE,      isPush: BOOLEAN ¬ FALSE,    tempErrorMsgs: ErrorMsgPtr ¬ NIL,    errorMsgs: ErrorMsgPtr ¬ NIL    -- When format errors are encountered, they are chained onto tempErrorMsgs.  If a pattern is found that works, this list will be deleted; otherwise it will be chained onto errorMsgs.    ];  PhrasePtr: TYPE = LONG POINTER TO Phrase;  PhraseElement: TYPE = RECORD [    nextElement: PhraseElementPtr,  -- next element in phrase;  NIL if end of phrase    elementRec: ElementRec];  PhraseElementPtr: TYPE = LONG POINTER TO PhraseElement;    RegisterType: TYPE = {A, aUpper8, aUpper16, aLower16, D, chipVersion, CSBank, stkPtr, stkMinus2, stkMinus1, stkZero, stkPlus1, CIP, timerHigh, timerLow, prescaler, ibCtr, zero, Q, R, ib, ibSE};  -- placement is significant    RetType: TYPE = RECORD [    Type: SELECT Element: * FROM      Value => [val: CARDINAL],      Text => [txt: LONG STRING],      Null => NULL,      Error => NULL,      ENDCASE];    Statement: TYPE = RECORD [    firstPhrase: PhrasePtr ¬ NIL,    encoding: EncodingPtr ¬ NIL,    syntaxError: BOOLEAN ¬ FALSE,    formatError: BOOLEAN ¬ FALSE];  StatementPtr: TYPE = LONG POINTER TO Statement;    stmtMultiSeg: TYPE = RECORD[StmtFileHandle: MFile.Handle ¬ NIL,    StmtSeg: MSegment.Handle,    StmtSegPtr: LONG POINTER,    nextSeg: LONG POINTER TO stmtMultiSeg ¬ NIL];  stmtMultiSegPtr: TYPE = LONG POINTER TO stmtMultiSeg;    SyntaxErrorCode: TYPE = {    invalidExpression, arrowMissing, noRHS, unexpectedLHS, operationMissing,    missingPlusOrMinus, unexpectedRHS, invalidOperand, invalidSecondOperand, doubleNot,    oneMissing, invalidPlus, invalidMinus, multipleArrows, noOperand, endOfPhrase};  --PROCEDURES  AFileError: PROCEDURE [AFileErrorCode];  AllocateEncodingRecord: PROCEDURE RETURNS [encoding: EncodingPtr];  -- in DsyEncodePatternImpl  CreatePassSegment: PROCEDURE;   --in DsyTempSpaceImpl  CreateStmtSegment: PROCEDURE;  DeletePassSegment: PROCEDURE;     DeleteStmtSegment: PROCEDURE;    EncodePattern: PROCEDURE [    phrase: PhrasePtr, pattern: PatternPtr, encoding: EncodingPtr,    assignment: Assignment] RETURNS [successful: BOOLEAN];  -- in DsyEncodePatternImpl  EncodeStatement: PROCEDURE [statement: StatementPtr]    RETURNS [successful: BOOLEAN];  -- in DsyEncodeImpl  FormatError: PROCEDURE [    phrase: PhrasePtr, assignment1, assignment2: Assignment,    fieldName: LONG STRING];  -- in DsyEncodeErrorsImpl     FreePassSpace: PROCEDURE;   --in DsyTempSpaceImpl  FreeStmtSpace: PROCEDURE;    GetPassSpace: PROCEDURE[nWords: CARDINAL] RETURNS [LONG POINTER];  GetrAField: PROCEDURE [rA: CARDINAL] RETURNS [reference: ArgumentType];  GetrDField: PROCEDURE [rD: CARDINAL, rB: CARDINAL] RETURNS [reference: ArgumentType];  GetStmtSpace: PROCEDURE[nWords: CARDINAL] RETURNS [LONG POINTER];   MakeTempErrorMsgsPermanent: PROCEDURE [phrase: PhrasePtr];  -- in DsyEncodeErrorsImpl  MemoryError: PROCEDURE [code: MemoryErrorCode];  --in DsyEncodeErrorImpl  PrintStatementErrorMsgs: PROCEDURE [statement: StatementPtr];  -- in DsyEncodeErrorsImpl  MergeStatementEncoding: PROCEDURE [statement: StatementPtr]    RETURNS [successful: BOOLEAN];  -- in DsyMergeImpl  SyntaxError: PROCEDURE [phrase: PhrasePtr, code: SyntaxErrorCode];  -- in DsyEncodeErrorsImpl  -- constants  linkSize: CARDINAL = 4;  --index of next macro after Ln ¬ in macro table  macroArrowSize: CARDINAL = 13;  --index of next macro after xxx ¬ (macroArrow) in macro table  macroRHSSize: CARDINAL = 21;  --index of next macro after macros valid as RHS of eqns  macroTableSize: CARDINAL = 90;  maxArgLength: CARDINAL = 100;  maxStringLength: CARDINAL = 400;  sizeArgArray: CARDINAL = 11;  startMemorySize: CARDINAL = 8;  --index of next macro after start memory operation macros in macro table    --values for each encoding of a field:  rAFirstDReg: CARDINAL = 0;  rAZero: CARDINAL = 16;  rAChipVersion: CARDINAL = 17;  rACSBank: CARDINAL = 18;  rAStkPtr: CARDINAL = 19;  rAStkRef: CARDINAL = 20;     rAPush: CARDINAL = 4;  rAPop: CARDINAL = 8;  rAAUpper16: CARDINAL = 32;  rAALower16: CARDINAL = 40;  rACIP: CARDINAL = 48;  rAIBCtr: CARDINAL = 49;  rATimerLow: CARDINAL = 50;  rATimerHigh: CARDINAL = 51;  rAPrescaler: CARDINAL = 54;  rAStkP1Offset: CARDINAL = 0;  rAStk0Offset: CARDINAL = 1;  rAStkM1Offset: CARDINAL = 2;  rAStkM2Offset: CARDINAL = 3;    rBZero: CARDINAL = 0;  rBQ: CARDINAL = 1;  rBIB: CARDINAL = 2;  rBIBSE: CARDINAL = 3;    rDFirstDReg: CARDINAL = 0;  rDLastDReg: CARDINAL = 15;  rDCSBank: CARDINAL = 18;  rDStkPtr: CARDINAL = 19;  rDStkPlus1: CARDINAL = 20;  rDStkZero: CARDINAL = 21;  rDStkMinus1: CARDINAL = 22;  rDStkMinus2: CARDINAL = 23;  rDAUpper8: CARDINAL = 24;  rDAUpper16: CARDINAL = 32;  rDALower16: CARDINAL = 40;  rDCIP: CARDINAL = 48;  rDTimerLow: CARDINAL = 50;  rDTimerHigh: CARDINAL = 51;  rDSameAsrB: CARDINAL = 52;  rDQ: CARDINAL = 53;  rDPrescaler: CARDINAL = 54;  rDNoop: CARDINAL = 63;   aluAPlusB: CARDINAL = 0;  aluAinusB: CARDINAL = 1;  aluBMinusA: CARDINAL = 2;  aluAAndB: CARDINAL = 3;  aluAOrB: CARDINAL = 4;  aluAXorB: CARDINAL = 5;  aluAPlusCI: CARDINAL = 6;  aluAAndNB: CARDINAL = 7;  aluMPY: CARDINAL = 8;  aluANAndB: CARDINAL = 11;  aluANOrB: CARDINAL = 12;  aluANXorB: CARDINAL = 13;  aluBPlusCI: CARDINAL = 14;  aluNAAndB: CARDINAL = 15;    sp2Noop: CARDINAL = 0;  sp2EOPTrapRq: CARDINAL = 1;  sp2ClrMInt: CARDINAL = 2;  sp2PopIB: CARDINAL = 3;  sp2USource: CARDINAL = 4;  sp2VSource: CARDINAL = 5;    sp1Noop: CARDINAL = 0;  sp1AssignQ: CARDINAL = 1;  sp1IncCIP: CARDINAL = 2;  sp1DIncCIP: CARDINAL = 3;  sp1Link0: CARDINAL = 4;  sp1Link1: CARDINAL = 5;  sp1Link2: CARDINAL = 6;  sp1Link3: CARDINAL = 7;    dspBL0Disp: CARDINAL = 0;  dspBL1Disp: CARDINAL = 1;  dspBL2Disp: CARDINAL = 2;  dspBL3Disp: CARDINAL = 3;  dspBADisp: CARDINAL = 4;  dspBALUDisp: CARDINAL = 5;  dspBPCDisp: CARDINAL = 6;  dspBZeroBr: CARDINAL = 7;  dspBNoop: CARDINAL = 8;  dspBBDisp: CARDINAL = 9;  dspBRDisp: CARDINAL = 10;  dspBMIntDisp: CARDINAL = 11;  dspBAHighDisp: CARDINAL = 12;  dspBReadOKBr: CARDINAL = 13;  dspBWriteOKBr: CARDINAL = 14;  dspBIBDisp: CARDINAL = 15;  dspBAlwaysIBDisp: CARDINAL = 15;    ibNoop: CARDINAL = 0;  ibClrIB: CARDINAL = 1;  ibPopIB: CARDINAL = 2;  ibUReg: CARDINAL = 4;  ibVReg: CARDINAL = 5;  ibPopUReg: CARDINAL = 6;  ibPopVReg: CARDINAL = 7;    omImmed: CARDINAL = 0;  omIBByte: CARDINAL = 1;  omIBUpperNib: CARDINAL = 2;  omIBLowerNib: CARDINAL = 3;    moNoop: CARDINAL = 0;  moA: CARDINAL = 1;  moMap: CARDINAL = 2;  moU: CARDINAL = 3;  moRead: CARDINAL = 4;  moDoubleRead: CARDINAL = 5;  moWrite: CARDINAL = 4;  moDoubleWrite: CARDINAL = 5;  moDoubleU: CARDINAL = 7;    amPhysical: CARDINAL = 0;  amVirtual: CARDINAL = 1;    hiByteFalse: CARDINAL = 0;  hiByteTrue: CARDINAL = 1;    itDoNotInhibit: CARDINAL = 0;  itInhibit: CARDINAL = 1;    cycle0: CARDINAL = 0;  cycle1: CARDINAL = 1;  cycle2: CARDINAL = 2;  cycle3: CARDINAL = 3;  cycle4: CARDINAL = 4;      -- characters  EofChar: CHARACTER = 004C;  NUL: CHARACTER = 0C;  semiChar: CHARACTER = ';;  -- character arrays  CharOf: ARRAY [0..9] OF CHARACTER = ['0, '1, '2, '3, '4, '5, '6, '7, '8, '9];      --variables  macroTable: LONG POINTER TO ARRAY [0..macroTableSize) OF MacroPattern;  patternAssignAU8: PUBLIC Pattern;  patternAssignAU16: PUBLIC Pattern;  patternAssignAL16: PUBLIC Pattern;  patternAssignCIP: PUBLIC Pattern;  patternAssignCSBank: PUBLIC Pattern;  patternAssignD: PUBLIC Pattern;  patternAssignPrescaler: PUBLIC Pattern;  patternAssignQ: PUBLIC Pattern;  patternAssignQSp1: PUBLIC Pattern;  patternAssignR: PUBLIC Pattern;  patternAssignStk: PUBLIC Pattern;  patternAssignStkMinus2: PUBLIC Pattern;  patternAssignStkMinus1: PUBLIC Pattern;  patternAssignStkZero: PUBLIC Pattern;  patternAssignStkPlus1: PUBLIC Pattern;  patternAssignTimerHigh: PUBLIC Pattern;  patternAssignTimerLow: PUBLIC Pattern;  patternCin0: Pattern;  patternCin1: Pattern;  patternCinX: Pattern;  aBus: BOOLEAN;  aFile: BOOLEAN;  aluGets: BOOLEAN;  bBus: BOOLEAN;  cycleTypeSpecified: BOOLEAN;  destination: ArgumentType;    errors: BOOLEAN;  expression: BOOLEAN;  --does this MI have an expression which uses the alu (not the offset adder)?  mdr: BOOLEAN;  memory: BOOLEAN;  offsetAdder: BOOLEAN;   parity: ParityMasks;   popIB: BOOLEAN;  version: LONG STRING;  END...   --A statement consists of a list of phrase record which contains a list of the phrase elements and the encoding record(s) for the phrase.  The encoding record represents how the statement will be encoding into the fields of the microinstruction. A phrase represents the text in a statement between commas.  A PhraseElement represents an element of a phrase such as a D Register, a "+" operation, a constant, etc.  --To encode a statement, the phrase elements of the first phrase are read in and built into the record for the phrase.  This continues for each phrase in the instruction. Next, an encoding record for each phrase is built. There may be more that one encoding for each phrase. Finally,if no errors exist all the phrases are merged together into a single encoding for the statement, by trying each encoding for every phrase.  If errors exist the encoding for the statement is considered to be a Noop. Processing continues after some additional end of statement checks for illegal instruction sequences with the previous instruction and ones that to which it may branch, with the next instruction in the file.--Last edit log:--JAC   	 8-Oct-84 17:17:17	changed val to CARDINAL in RetType--JAC   	 9-Oct-84 10:46:04	added lshift, rshift to BuiltinMacroType--JAC   	 9-Oct-84 14:45:56	changed maxArgLength to 100--JAC   	23-Oct-84 10:22:30	added aluGets--JAC   	 5-Nov-84 14:13:47	fixed arrows for Mesa 11.1--JAC   	24-Feb-85 14:51:32	added aBus boolean
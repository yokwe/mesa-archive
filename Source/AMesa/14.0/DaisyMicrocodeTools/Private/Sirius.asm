$MOD186$PAGELENGTH (95)$PAGEWIDTH  (136);Copyright (C) 1984 by Xerox Corporation. All rights reserved.;-- stored as [Iris]<WMicroTools>Dove>Sirius.asm;-- created on  22-Oct-84  8:50:39; IOP code used by the Sirius Chip debugger for reading and writing control store and stopping and starting the Sirius Chip.;-- last edited by:;;--	JAC		 6-May-86 14:32:31	add reset of CP;--	JAC		 1-May-86 16:00:34	upgrade to new proms?;--	JAC		20-Feb-86 16:33:29	get rid of import of MoonSys.def;--	FXB   .PA	 9-Nov-84 12:51:18	corrected swapped start addresses;--	FXB   .PA	24-Oct-84 17:24:54	fixed flipped words;--	FXB   .PA	24-Oct-84 14:24:14	took out FAR returns;--	FXB   .PA	24-Oct-84  9:59:01:   WriteSiriusCS writes multiple words ;--	FXB   .PA	22-Oct-84 10:04:30NAME	SIRIUSIOPELocalRam	SEGMENT	AT 0EXTRN		BindweedBuffer: BYTEIOPELocalRam	ENDSSiriusSeg	SEGMENT		ASSUME CS: SiriusSeg	ReadSiriusControlStoreVector 	EQU 17*4StartSiriusVector 		EQU 18*4StopSiriusVector		EQU 20*4WriteSiriusControlStoreVector	EQU 21*4ResetSiriusVector		EQU 24*4	BytesInShiftRegister		EQU 6BytesPerMicroInstruction	EQU 6;Data from control store is port 080H bit 13 i.e. CSReadPort	EQU	080H 	;bit 13 contains data from Sirius shift registerSiriusPort	EQU	0B0H 	;The port for controlling the Sirius chipResetPort	EQU 	0C0H;bit 7: RAMWrEnable;bit 6: CSShift';bit 5: CSDOe;bit 4: shift data;bit 3: ShiftClk;bit 2: Halt';bit 1: ResetSChip';bit 0: IOPIntSChipRam		EQU  8000HNCSShift	EQU  4000HCSShift		EQU  0CSDOe		EQU  2000HSData		EQU  1000HSClock		EQU  800HNHalt		EQU  200HIOPInt		EQU  100HCSDataBit	EQU  2000HNoResets	EQU 3FFHResetMesa	EQU 3BFHInitializeVectors:	MOV	AX, 900H	MOV	SP, AX	XOR	AX, AX	MOV	ES, AX				;make ES point to low RAM	MOV	AX, OFFSET StartSirius		MOV	SI, StartSiriusVector	MOV	ES:[SI], AX			;Store the new IP	MOV	ES:[SI + 2], CS			;and the new CS	MOV	AX, OFFSET StopSirius		MOV	SI, StopSiriusVector	MOV	ES:[SI], AX			;Store the new IP	MOV	ES:[SI + 2], CS			;and the new CS	MOV	AX, OFFSET ReadSiriusControlStore		MOV	SI, ReadSiriusControlStoreVector	MOV	ES:[SI], AX			;Store the new IP	MOV	ES:[SI + 2], CS			;and the new CS	MOV	AX, OFFSET WriteSiriusControlStore 	      	MOV	SI, WriteSiriusControlStoreVector	MOV	ES:[SI], AX			;Store the new IP	MOV	ES:[SI + 2], CS			;and the new CS		MOV	AX, OFFSET ResetSirius 	      	MOV	SI, ResetSiriusVector	MOV	ES:[SI], AX			;Store the new IP	MOV	ES:[SI + 2], CS			;and the new CS	EndlessLoop:	JMP EndlessLoop	;*****************************************************************************;CPBermuda Commands:;;on exit CX contains ?ResetSirius:PUSHA	CALL 	ResetCP		POPA	MOV 	CL, 0	IRET	ReadSiriusControlStore:	PUSHA	MOV	DI, OFFSET BindweedBuffer	CALL	ReadCSWord	POPA	MOV	CL, BytesInShiftRegister + 1		IRET	  StartSirius:	PUSHA	MOV	DI, OFFSET BindweedBuffer	CALL	WriteShift	CALL	StartCP	POPA	MOV	CL, 0		IRET		StopSirius:	PUSHA	MOV	DI, OFFSET BindweedBuffer	CALL	StopCP	CALL	ReadShift	POPA	MOV	CL, BytesInShiftRegister + 1	IRET		WriteSiriusControlStore:	PUSHA	MOV	DI, OFFSET BindweedBuffer	MOV	BX, [DI].WriteCSAddress	MOV	CL, [DI].WriteCSWords	XOR	CH, CHWriteSiriusCS:	PUSH	CX		CALL	WriteCSWord	POP	CX	ADD	DI, BytesPerMicroInstruction	INC	BX	LOOP	WriteSiriusCS	POPA	MOV	CL, 0	IRET			Delay: 	SHL 	AX, 15       	RET	StopCP: MOV	AX, NCSShift     	;Assert Halt	OUT	SiriusPort, AX	CALL 	Delay			;WAIT 38 cycles        RET		ResetCP:MOV	AX, NCSShift     	;Assert Halt 	OUT	SiriusPort, AX	CALL 	Delay			;WAIT 38 cycles	MOV	Ax, ResetMesa            ;Assert Halt and Reset	OUT     ResetPort, AXKDelay:	MOV	CX, 0FFH		;get mode reg bits	KDelay1: LOOP	KDelay1			;write mode reg bits	MOV	AX, NoResets	OUT     ResetPort, AX	MOV	AX, NCSShift    	 ;Assert Halt	OUT	SiriusPort, AX        RET		;***************************************************************************;SUBROUTINE: ReadShift;;on entry: DS = 0 DI = index into low RAM ;DX used to store shift register data;;ReadShift:	MOV	CX, 3	CALL 	ShiftWordInX		;get EOPTrap/ExtInt/CSParity bits	ROR	DX, 5			  	MOV	[DI].InCSData3, DH	CALL 	ShiftWordIn		CALL	BankIn 	MOV	[DI].InCSAddress1, DX	;save BSp2Hold and NIAp2Hold	CALL 	ShiftWordIn		;shift out and discard	CALL 	ShiftWordIn		;48 bits of old CSData from 	CALL 	ShiftWordIn		;the shift register	CALL 	ShiftWordIn		CALL	BankIn 	MOV	[DI].InCSAddress, DX	;Save BS and NIA	MOV	AX,  CSShift		;Deassert control store output enable	OUT	SiriusPort, AX        Ret	;*******************************************************************************	StopSiriusReplyBuffer	STRUC	junk	DB 	5 DUP (?)	InCSAddress	DW ?	InCSAddress1	DW ?	InCSData3	DB ?StopSiriusReplyBuffer	ENDSStartSiriusWriteBuffer	STRUC	overhead	DB	3 DUP (?)	OutCSAddress	DW	?	OutCSAddress1	DW	?	OutCSData3	DB	?StartSiriusWriteBuffer	ENDSControlStoreReadReplyBuffer	STRUC	bwOverhead	DB	5 DUP (?)	InCSData0	DW	?	InCSData1	DW	?	InCSData2	DW	?ControlStoreReadReplyBuffer	ENDSControlStoreReadCommandBuffer	STRUC	overhead2	DB	3 DUP (?)	ReadCSAddress	DW		?ControlStoreReadCommandBuffer	ENDS		ControlStoreWriteBuffer 	STRUC	protocol	DB	3 DUP (?)	WriteCSWords	DB	?	WriteCSAddress	DW	?	OutCSData0	DW	?	OutCSData1	DW	?	OutCSData2	DW	?ControlStoreWriteBuffer	ENDS					       	;***************************************************************************;SUBROUTINE: WriteShift;; on entry: DS = 0 DI = index into low RAM indicating last address for data.; Addressing is done using DS as DI's default segment, may need to do use a; different pointer and have DS as the segment register	WriteShift:	MOV	AX,  CSShift	OUT	SiriusPort, AX		;Assert CSShift'	MOV	DL, [DI].OutCSData3	;get first byte of data	MOV	CX, 3		 ; loop counter for 16 bit word	CALL	ShiftWordOutX		;CSParity/ExtInt/EOPTrap        MOV	DX, [DI].OutCSAddress1	;get address of 2nd uinstr to be started	CALL	BankOut 	CALL	ShiftWordOut		;write address of 2nd uInstr to be started	CALL	ShiftWordOut		;shift in 48 bits to fill the        CALL	ShiftWordOut		;CSData portion of the shift register        CALL	ShiftWordOut		; with garbage data	MOV	DX, [DI].OutCSAddress	;shift in address	CALL	BankOut 	CALL	ShiftWordOut		;of first uinstr to be executed        RET	StartCP:MOV	AX,  NCSShift		OUT	SiriusPort, AX		;which allows first uInstr to be fetched	NOP				;wait while uInstr is fetched and loaded	MOV	AX,  NCSShift+NHalt	;Deassert Halt	OUT	SiriusPort, AX        RET;******************************************************************************;SUBROUTINE: ReadCSWord;; Read a 48-bit word from control store and store it at the address pointed to by DI;;	;ReadCSWord:	MOV	AX,  CSShift	OUT	SiriusPort, AX		;Assert CSShift'	MOV	DX, [DI].ReadCSAddress	;get address of 2nd uinstr to be started	CALL	BankOut 	CALL	ShiftWordOut	;write address of 2nd uInstr to be started	CALL	ShiftWordOut		;shift in 48 bits to fill the 	CALL	ShiftWordOut		;CSData portion of the shift register	CALL	ShiftWordOut		; with garbage data	MOV	DX, [DI].ReadCSAddress	;shift in address	CALL	BankOut 	CALL	ShiftWordOut		;of first uinstr to be executed	MOV	AX,  NCSShift	OUT	SiriusPort, AX		;CS chips send data to Sirius		;raise and lower clock bit to load data into the CSData 	;portion of the shift register	MOV	AX,  NCSShift+SClock	OUT	SiriusPort, AX		;rising edge of clock	MOV	AX,  NCSShift		OUT	SiriusPort, AX		;falling edge of clock		MOV	AX, CSShift		;Turn off bank sel	OUT	SiriusPort, AX					CALL	SShiftWordIn	MOV	[DI].InCSData2, DX 	;	CALL	SShiftWordIn	MOV	[DI].InCSData1, DX 	;	CALL	SShiftWordIn	MOV	[DI].InCSData0, DX 	;		MOV	AX,  CSShift	OUT	SiriusPort, AX        Ret		;********************************************************************************;SUBROUTINE: WriteCSWord;; cycles: 2981;;	DI: offset of BindweedBuffer;	BX: Control Store Address;WriteCSWord:	MOV	AX, CSShift	OUT	SiriusPort, AX		;	MOV	DX, [DI].OutCSData2	;        	CALL 	ShiftWordOut		;shift in 48 bits of Control Store Data	MOV	DX, [DI].OutCSData1	;        CALL	ShiftWordOut		;	MOV	DX, [DI].OutCSData0	;        CALL	ShiftWordOut		;	MOV	DX, BX			;shift in CONTROL STORE ADDRESS         CALL	BankOut      	CALL	ShiftWordOut		;shift in 16 bits of BS and NIA		MOV	AX, CSShift		; disable S Chip output buffers	OUT	SiriusPort, AX				MOV	AX, Ram+NCSShift	; enable Bank Select and Write enables	OUT	SiriusPort, AX		;	;This allows the BS bits to enable the proper bank's Chip Selects 	;and turns on the write enable to the bank.  Initially, nonsense is 	;written.  The idea is to select a bank while keeping the control 	;store chip data outputs disabled.		MOV	AX, CSDOe+Ram+NCSShift+IOPInt	; send write data from S Chip with Write enable and bank select still on.  Actual writing happens now.	OUT	SiriusPort, Ax		;	MOV	AX, CSDOe+IOPInt	; turn off write enables and bank select while leaving output data enabled.  This satisfies RAM hold time.	OUT	SiriusPort, AX		;	MOV	AX, CSShift		; turn off everything	OUT	SiriusPort, AX		;        RET;*******************************************************************************;SUBROUTINE: ShiftWordIn;; shift 16 bits from the Sirius shift register and place them in DX;; Register usage:  Word from control store returned in DX, AL used for IO,;			CX used as a loop counter	ShiftWordIn: 	MOV	CX, 16ShiftWordInX: 	MOV	AX, CSDOe	  ;falling edge of clock pulse        OUT	SiriusPort, AX	CLCShiftWordInLoop:	IN	AX, CSReadPort		  ;read Control Store Data 	RCL	AX, 3			  ;Carry _ Control Store Data	RCR	DX, 1			  ;MSB of DX _ Control Store Data        MOV	AX, CSDOe+SClock  ;rising edge of clock pulse	OUT	SiriusPort, AX	MOV	AX, CSDOe	  ;falling edge of clock pulse	OUT	SiriusPort, AX	LOOP	ShiftWordInLoop	Ret;********************************************************************************	;SUBROUTINE: SShiftWordIn  Short Tap;; shift 16 bits from the Sirius shift register and place them in DX;; Register usage:  Word from control store returned in DX, AL used for IO,;			CX used as a loop counter	SShiftWordIn: 	MOV	CX, 16	MOV	AX,  CSDOe+IOPInt	;falling edge of clock pulse	OUT	SiriusPort, AX	CLCSShiftWordInLoop:	IN	AX, CSReadPort		        ;read Control Store Data 	RCL	AX, 3			        ;Carry _ Control Store Data	RCR	DX, 1			        ;MSB of DX _ Control Store Data	MOV	AX,  CSDOe+SClock+IOPInt	;rising edge of clock pulse	OUT	SiriusPort, AX	MOV	AX,  CSDOe+IOPInt	;falling edge of clock pulse	OUT	SiriusPort, AX	LOOP	SShiftWordInLoop	RET			;********************************************************************************;*SUBROUTINE: ShiftWordOut;;shift 16 bits contained in DX into the Sirius shift register;;*;* Register usage: Word to be written stored in DX, AL used for IO,;*			CX used as a loop counter;							ShiftWordOut:	MOV	CX, 16		 ; loop counter for 16 bit wordShiftWordOutX:	ROL	DX, 12		 ; rotate LSB of word to bit 12 ShiftWordOutLoop:	MOV	AX, SData  ;bit 12 mask in low byte     	AND	AX, DX		 ;mask out bit 12 	OR	AX,  SClock+CSDOe		OUT	SiriusPort, AX  ;rising edge of clock with CS Parity	XOR	AX, SClock		       	OUT	SiriusPort, AX	  ; falling edge of clock pulse with data bit	ROR	DX, 1		  ;shift next data bit to bit 12	LOOP	ShiftWordOutLoop		        Ret;************************************************************************** BankOut:	MOV	AX, DX       	AND	AX, 0F000H		AND	DX, 0FFFH	MOV	CX, 1000H       	CMP 	AX, 0	JE 	BankOutRet	MOV	CX, 2000H       	CMP 	AX, 1000H	JE 	BankOutRet	MOV	CX, 4000H         	CMP 	AX, 2000H	JE 	BankOutRet	MOV	CX, 8000H       BankOutRet:	OR	DX, CX	RET	BankIn:	MOV	AX, DX       	AND	AX, 0F000H		AND	DX, 0FFFH	MOV	CX, 0000H       	CMP 	AX, 1000H	JE 	BankInRet	MOV	CX, 1000H       	CMP 	AX, 2000H	JE 	BankInRet	MOV	CX, 2000H         	CMP 	AX, 4000H	JE 	BankInRet	MOV	CX, 3000H 	      BankInRet:	OR	DX, CX	RET	SiriusSeg	ENDSEND	InitializeVectors
-- Copyright (C) 1985  by Xerox Corporation. All rights reserved. -- HBAction.mesa, RdH       , 21-Feb-85 16:27:17-- Last edited by --  Rick RDH      	21-Feb-85 16:27:21 Create.DIRECTORY  Bindweed,  Exec;HBAction: DEFINITIONS = BEGIN  --Constants    delayMultiplier: CARDINAL = 256;    swBufferBlockSize: CARDINAL = Bindweed.hbWords;   --120, but do you believe a comment?--    wordsInHBMemory: CARDINAL = 8192;    cSSamplesInHBMemory: CARDINAL = wordsInHBMemory / wordsPerCSSample;    iOPSamplesInHBMemory: CARDINAL = wordsInHBMemory / wordsPerIOPSample;    maxItemsInBlock: CARDINAL = swBufferBlockSize/wordsPerCSSample;    wordsPerCSSample: CARDINAL = 2;    wordsPerIOPSample: CARDINAL = 4;      numBlocksInSwBuffer: CARDINAL =     (wordsInHBMemory + swBufferBlockSize - 1) / swBufferBlockSize;    -- Ceiling function of wordsInHBMemory / swBufferBlockSize    CntrlReg: HBCmdReg = 3FE0H;  StartReg: HBCmdReg = 3FE2H;  ManTrig: HBCmdReg = 3FE4H;  ManStop: HBCmdReg = 3FE6H;  ResetInt: HBCmdReg = 3FE8H;  StatReg: HBCmdReg = 3FEAH;  DataHiReg: HBCmdReg = 3FECH;  DataLoReg: HBCmdReg = 3FEEH;    MaskReg3: HBCmdReg = 3FF0H;  MaskReg2: HBCmdReg = 3FF2H;  MaskReg1: HBCmdReg = 3FF4H;  MaskReg0: HBCmdReg = 3FF6H;  TrigReg3: HBCmdReg = 3FF8H;  TrigReg2: HBCmdReg = 3FFAH;  TrigReg1: HBCmdReg = 3FFCH;  TrigReg0: HBCmdReg = 3FFEH;    --Types    DelayCount: TYPE = [0..DelayRange.LAST*delayMultiplier); --The number of samples remaining to be taken before timeout occurs.      DelayRange: TYPE = [0..16);--the range of possible values which can be supplied to the History buffer to specify the number of samples to be taken after triggering.  The history buffer multiplies this number by delayMultiplier to give the actual number of samples taken after triggering.    -- IO locations of DaisyHistoryBuffer commands and registers.  HBCmdReg: TYPE = CARDINAL;    -- The format of the history buffer control word.      HBControl: TYPE = MACHINE DEPENDENT RECORD [    unusedA(0: 0..3): [0..16) ¬ 0,    delayOption(0: 4..7): DelayRange ¬ 0,    unusedB(0: 8..11): [0..16) ¬ 0,    intrpt(0: 12..12): IntrptState ¬ off,    readDir(0: 13..13): ReadDir ¬ forward,    target(0: 14..14): TargetDevice,    mode(0: 15..15): HBMode];    HBBlockIndex: TYPE = [0..numBlocksInSwBuffer);    HBMode: TYPE = MACHINE DEPENDENT {read(0), sample(1)};    HBProbType: TYPE = {bindweedTimeout, bindweedBadCheckSum,    bindweedUmbilicalNotWorking, badBufferBlock, badBuffer, otherErr};  HBState: TYPE = MACHINE DEPENDENT {readSample(0), idle(1),     delay(2), illegal(3)};      -- The format of the history buffer status register.      HBStatus: TYPE = MACHINE DEPENDENT RECORD [    state(0: 0..1): HBState,    target(0: 2..2): TargetDevice,    mode(0: 3..3): HBMode,    delayCntr(0: 4..15): DelayCount];        HistoryBufferBlock: TYPE = ARRAY WordIndexInBufferBlock OF WORD;  ItemIndexInBlock: TYPE = [0..maxItemsInBlock);   IntrptState: TYPE = MACHINE DEPENDENT {off(0), on(1)};  ReadDir: TYPE = MACHINE DEPENDENT {backward(0), forward(1)};  SWBuffer: TYPE = ARRAY HBBlockIndex OF HistoryBufferBlock;  TargetDevice: TYPE = MACHINE DEPENDENT {iop(0), cs(1)};  WordIndexInBufferBlock: TYPE = [0..swBufferBlockSize);      --Procs    DiscardDblWord: PROC;    DiscardQuadWord: PROC;    InitConnectionToHB: PROC[exec: Exec.Handle] RETURNS [ready: BOOLEAN];    ManualStop: PROC;  ManualTrig: PROC;    ReadHistoryBufferBlock: PROC[block: LONG POINTER TO HistoryBufferBlock];      ReadWholeBuffer: PROC[buffer: LONG POINTER TO SWBuffer];      ReadStatus: PROC RETURNS[status: HBStatus];      Start: PROC;      StartReadCSForw: PROC;      StartReadIOPForw: PROC;      StartSample: PROC[delay: DelayRange, target: TargetDevice];      WriteTriggerRegs: PROC[trigReg0, trigReg1, trigReg2, trigReg3: UNSPECIFIED];    WriteMaskRegs: PROC[maskReg0, maskReg1, maskReg2, maskReg3: UNSPECIFIED];    WriteControlReg: PROC[cntlReg: HBControl];      --Signals    HBProb: SIGNAL[probType: HBProbType];      --Data Objects      END.
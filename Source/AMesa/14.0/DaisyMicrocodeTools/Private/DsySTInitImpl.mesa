-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. --Last edit by JAC            5-Nov-84 14:32:11DIRECTORY  Ascii USING [CR],  Inline USING [BITAND, BITOR, BITSHIFT, BITXOR],  Heap USING [MakeNode],  String USING [    AppendChar, AppendNumber, AppendString, AppendSubString, EqualString,    SubStringDescriptor, WordsForString],  DsyAssembler USING [    BuiltinMacroType, ElementRec, maxArgLength, MEntry, MEntryPtr, MyString,    ParityMasks, RegisterType, RetType, sizeArgArray],  DsyControl USING [assemblerDirective, config, ifsInThisFile, numArgs],  DsyFile USING [LogErrAndSrcLines, LogErrArgAndSrcLines, LogLine],  DsyLabel USING [    branchType, BrConstrain, canceledBr, canceledBr1, Constrain, cycleOK, maxNumMI,    natc, oldok, ProcessAt, ProcessExternal, ProcessReserve, ProcSA, SetDest, wok],  DsyModule USING [    BreakPhraseArg, BreakPhraseMain, InsertM, InterpretArg, InterpretMain,    MTtempHeap, SaveArgs, SkipUntil];DsySTInitImpl: PROGRAM  IMPORTS Heap, Inline, String, DsyControl, DsyFile, DsyLabel, DsyModule  EXPORTS DsyAssembler, DsyModule =  BEGIN OPEN DsyAssembler;  parity: PUBLIC ParityMasks ¬ ParityMasks[];  numBuiltins: INTEGER = 16;  builtinProcs: ARRAY [0..numBuiltins) OF PROCEDURE [BuiltinMacroType]    RETURNS [ret: RetType] = [    Arith  -- [00]    -- add  adds up to nine args    -- and  ands up to nine args    -- mul  muls up to nine args    -- or  ors up to nine args    -- xor  xors up to nine args    -- nand up to nine args    -- nxor up to nine args    -- nor up to nine args    , Arith2  -- [01]    -- sub  subtracts arg2 from arg1    -- lshift  left shift arg1 by arg2    -- rshift  right shift arg1 by arg2    , Branch  -- [02]    -- goto  arg1 is destination label    -- gotoabs  arg1 is absolute destination    -- branch  arg1 = 0 dest, arg1 = 1 dest, arg3 = branch condition    -- cancelbr  arg1 is destination label, arg2 (optional) is a mask    -- disp2  arg1 = dest, arg2 = mask (2 bit dispatch)    -- disp3  arg1 = dest, arg2 = mask (3 bit dispatch)    -- disp4  arg1 = dest, arg2 = mask (4 bit dispatch)    -- ret  arg1 is destination label, acts like disp    , If  -- [03]    -- equal  if arg1 = arg2 then arg3 else arg4    -- greater  if arg1 > arg2 then arg3 else arg4    -- andZero  if (arg1 and arg2) = 0 then arg3 else arg4    , Set  -- [04] sets variable named in arg1 to value of arg2    , PrintVar  -- [05] print variable named in arg1    , MacroDef  -- [06] arg1 = user macro name, arg2 = expansion    , RegDef  -- [07] arg1 = register name, arg2 = U/UY/R/RH, arg3 = reg address    , External  -- [08]    -- import  imports up to nine symbols    -- export  exports up to nine symbols    , At  -- [09]     -- at  arg1 = offset, arg2 = modulo (default 4096),    --arg3 = label (default current micro-instruction)    , Reserve  -- [10] reserve locations from arg1 thru arg2    , PrintString  -- [11] print string onto error file.  String must not contain commas, comment brackets, parens or brackets.    , StartAddress  -- [12] arg1 is starting label    , SkipTo  -- [13] arg1 bang label to skip to    , LoopHole  -- [14] adds loophole of type arg1    , Parity  --[15] to test out the parity generator    ];  AddBuiltin: PROCEDURE [    str: LONG STRING, procnum: INTEGER, type: BuiltinMacroType] =    --add builtin macro to the symbol table    BEGIN    s: LONG STRING;    proc: PROCEDURE [BuiltinMacroType] RETURNS [RetType];    mptr: MEntryPtr ¬ Heap.MakeNode[      DsyModule.MTtempHeap,      SIZE[builtinMacro ElementRec] + SIZE[MEntry] + String.WordsForString[        str.length]];    ETptr: LONG POINTER TO ElementRec;    ETptr ¬ LOOPHOLE[mptr + SIZE[MEntry]];    s ¬ LOOPHOLE[ETptr + SIZE[builtinMacro ElementRec]];    s­ ¬ StringBody[maxlength: str.length, length: 0, text:];    String.AppendString[s, str];    proc ¬ builtinProcs[procnum];    ETptr­ ¬ ElementRec[builtinMacro[proc, type]];    mptr­ ¬ MEntry[s, ETptr, NIL];    IF DsyModule.InsertM[mptr] THEN      DsyFile.LogErrArgAndSrcLines["Builtin already defined "L, str];    END;  -- end AddBuiltin  AddSTEntry: PROCEDURE [str: LONG STRING, er: ElementRec, erSize: CARDINAL] =    --add an entry to the symbol table whose size is given by erSize and whose elementRec has a type with NULL arguments    BEGIN    s: LONG STRING;    erptr: LONG POINTER TO ElementRec ¬ Heap.MakeNode[      DsyModule.MTtempHeap,      erSize + SIZE[MEntry] + String.WordsForString[str.length]];    mptr: MEntryPtr;    erptr­ ¬ er;    mptr ¬ LOOPHOLE[erptr + erSize];    s ¬ LOOPHOLE[mptr + SIZE[MEntry]];    s­ ¬ StringBody[maxlength: str.length, length: 0, text:];    String.AppendString[s, str];    mptr­ ¬ MEntry[s, erptr, NIL];    [] ¬ DsyModule.InsertM[mptr];    END;  --of procedure AddSTEntry  Arith: PROCEDURE [type: BuiltinMacroType] RETURNS [ret: RetType] =    BEGIN    i: CARDINAL;    val: CARDINAL;    myS: MyString;    mynumArgs: CARDINAL ¬ DsyControl.numArgs;    argArray: ARRAY [0..DsyAssembler.sizeArgArray] OF LONG STRING ¬ ALL[NIL];    et: ElementRec;    DsyControl.assemblerDirective ¬ DsyControl.assemblerDirective + 1;    DsyModule.SaveArgs[@argArray, mynumArgs];    val ¬ SELECT type FROM mul => 1, and => 0FFFFH, ENDCASE => 0;    FOR i IN [1..mynumArgs] DO      myS ¬ [0, argArray[i]];      et ¬ DsyModule.InterpretArg[DsyModule.BreakPhraseArg[@myS]];      SELECT type FROM        add => val ¬ val + GetValue[et];        and => val ¬ Inline.BITAND[val, GetValue[et]];        mul => val ¬ val * GetValue[et];        or => val ¬ Inline.BITOR[val, GetValue[et]];        xor => val ¬ Inline.BITXOR[val, GetValue[et]];        ENDCASE;      ENDLOOP;    RETURN[RetType[Value[val]]];    END;  -- end Arith  Arith2: PROCEDURE [type: BuiltinMacroType] RETURNS [ret: RetType] =    BEGIN    val, val1, val2: CARDINAL;    myS: MyString;    mynumArgs: CARDINAL ¬ DsyControl.numArgs;    argArray: ARRAY [0..DsyAssembler.sizeArgArray] OF LONG STRING ¬ ALL[NIL];    DsyControl.assemblerDirective ¬ DsyControl.assemblerDirective + 1;    DsyModule.SaveArgs[@argArray, mynumArgs];    IF DsyControl.numArgs # 2 THEN      DsyFile.LogErrAndSrcLines["Sub and shift require two args"L];    myS ¬ [0, argArray[1]];    val1 ¬ GetValue[DsyModule.InterpretArg[DsyModule.BreakPhraseArg[@myS]]];    myS ¬ [0, argArray[2]];    val2 ¬ GetValue[DsyModule.InterpretArg[DsyModule.BreakPhraseArg[@myS]]];    val ¬       SELECT type FROM         sub => val1 - val2,	lshift => Inline.BITSHIFT[val1, val2],        rshift => Inline.BITSHIFT[val1, -val2], 	ENDCASE => 0;    RETURN[RetType[Value[val]]];    END;  -- end Arith2  At: PROCEDURE [type: BuiltinMacroType] RETURNS [ret: RetType] =    BEGIN    myS: MyString;    mynumArgs: CARDINAL ¬ DsyControl.numArgs;    modA: CARDINAL;    offset: CARDINAL;    modulo: CARDINAL;    name: LONG STRING;    argArray: ARRAY [0..DsyAssembler.sizeArgArray] OF LONG STRING ¬ ALL[NIL];    Log: PROCEDURE [in: CARDINAL] RETURNS [out: CARDINAL] = INLINE      BEGIN      out ¬ SELECT in FROM 2 => 1, 4 => 2, 8 => 3, 16 => 4, ENDCASE => 0;      IF out = 0 THEN        DsyFile.LogErrAndSrcLines["Illegal modulo in at -- not 2,4,8, or 16 "L];      END;  -- end Log    DsyModule.SaveArgs[@argArray, mynumArgs];    DsyControl.assemblerDirective ¬ DsyControl.assemblerDirective - 1;    IF mynumArgs NOT IN [1..3] THEN      DsyFile.LogErrAndSrcLines["at requires 1, 2, or 3 args"L];    name ¬ IF mynumArgs < 3 THEN NIL ELSE argArray[3];    myS ¬ MyString[0, argArray[2]];    modA ¬      IF mynumArgs > 1 THEN GetValue[      DsyModule.InterpretArg[DsyModule.BreakPhraseArg[@myS]]] ELSE 4096;    modulo ¬ IF mynumArgs < 2 THEN 5 ELSE Log[modA];    myS ¬ MyString[0, argArray[1]];    offset ¬ GetValue[DsyModule.InterpretArg[DsyModule.BreakPhraseArg[@myS]]];    IF offset NOT IN [0..modA) THEN      BEGIN      DsyFile.LogErrAndSrcLines["Illegal offset in at -- not in [0..modulo] "L];      offset ¬ 0;      END;    DsyLabel.ProcessAt[LOOPHOLE[offset], modulo, name];    RETURN[RetType[Null[]]];    END;  -- end At  Branch: PROCEDURE [type: BuiltinMacroType] RETURNS [ret: RetType] =    BEGIN    et: ElementRec;    myS: MyString;    mynumArgs: CARDINAL ¬ DsyControl.numArgs;    offset1: CARDINAL ¬ 0;    offset2: CARDINAL ¬ 1;    modulo: CARDINAL ¬ 1;    andMask: INTEGER ¬ DsyLabel.maxNumMI - 1;    noSetDest: BOOLEAN ¬ FALSE;    orMask: INTEGER ¬ 0;    argArray: ARRAY [0..DsyAssembler.sizeArgArray] OF LONG STRING ¬ ALL[NIL];    DsyModule.SaveArgs[@argArray, mynumArgs];    DsyControl.assemblerDirective ¬ DsyControl.assemblerDirective - 1;    IF DsyControl.numArgs < 1 THEN      DsyFile.LogErrAndSrcLines["No args for goto type macro"L]    ELSE      BEGIN      SELECT type FROM        goto => NULL;        branch =>          BEGIN          DsyLabel.branchType ¬ branch;          IF mynumArgs NOT IN [2..3] THEN            DsyFile.LogErrAndSrcLines["Wrong number of args for BRANCH"L]          ELSE            BEGIN            IF mynumArgs = 3 THEN              BEGIN              myS ¬ MyString[0, argArray[3]];              offset1 ¬ GetValue[                DsyModule.InterpretArg[DsyModule.BreakPhraseArg[@myS]]];              modulo ¬                SELECT offset1 FROM                  1, 2 => 2,                  3, 5, 6 => 3,                  7, 11, 13, 14 => 4,                  ENDCASE => 0;              IF modulo = 0 THEN                DsyFile.LogErrArgAndSrcLines["Illegal BRANCH mask "L, argArray[3]];              IF Inline.BITAND[offset1, 1] # 0 THEN DsyLabel.canceledBr1 ¬ TRUE;              END;            DsyLabel.BrConstrain[argArray[1], argArray[2], offset1, modulo];            noSetDest ¬ TRUE;            END;          END;        cancelbr =>          BEGIN          DsyLabel.branchType ¬ cancelbr;          offset1 ¬ 1;          IF mynumArgs NOT IN [1..2] THEN            DsyFile.LogErrAndSrcLines["Wrong number of args for CANCELBR"L]          ELSE            IF mynumArgs = 2 THEN              BEGIN              myS ¬ MyString[0, argArray[2]];              offset1 ¬ GetValue[                DsyModule.InterpretArg[DsyModule.BreakPhraseArg[@myS]]];              modulo ¬                SELECT offset1 FROM                  = 0 => 6,                  < 2 => 1,                  < 4 => 2,                  < 8 => 3,                  < 16 => 4,                  ENDCASE => 5;              IF modulo = 5 THEN                DsyFile.LogErrArgAndSrcLines[                  "Illegal CANCELBR mask "L, argArray[2]];              IF modulo < 5 THEN                DsyLabel.Constrain[argArray[1], argArray[1], offset1, modulo];              END            ELSE DsyLabel.Constrain[argArray[1], argArray[1], 1, modulo];          IF Inline.BITAND[offset1, 1] # 0 THEN DsyLabel.canceledBr1 ¬ TRUE;          END;        disp2 =>          BEGIN          DsyLabel.branchType ¬ disp;          andMask ¬ DsyLabel.maxNumMI - 4;          myS ¬ MyString[0, argArray[2]];          IF mynumArgs = 2 THEN            orMask ¬ GetValue[              DsyModule.InterpretArg[DsyModule.BreakPhraseArg[@myS]]];          END;        disp3 =>          BEGIN          DsyLabel.branchType ¬ disp;          andMask ¬ DsyLabel.maxNumMI - 8;          myS ¬ MyString[0, argArray[2]];          IF mynumArgs = 2 THEN            orMask ¬ GetValue[              DsyModule.InterpretArg[DsyModule.BreakPhraseArg[@myS]]];          END;        ret, disp4 =>          BEGIN          DsyLabel.branchType ¬ disp;          andMask ¬ DsyLabel.maxNumMI - 16;          myS ¬ MyString[0, argArray[2]];          IF mynumArgs = 2 THEN            orMask ¬ GetValue[              DsyModule.InterpretArg[DsyModule.BreakPhraseArg[@myS]]];          END;        gotoabs =>          BEGIN          myS ¬ MyString[0, argArray[1]];          et ¬ DsyModule.InterpretArg[DsyModule.BreakPhraseArg[@myS]];          WITH et SELECT FROM            variable, constant => andMask ¬ GetValue[et];            label => andMask ¬ value;            ENDCASE => DsyFile.LogErrAndSrcLines["Illegal argument for GOTOABS"L];          argArray[1].length ¬ 0;          END;        ENDCASE;      IF Inline.BITAND[orMask, andMask] # 0 THEN        DsyFile.LogErrAndSrcLines["DISP mask conflicts with DISP size"L];      IF Inline.BITAND[orMask, 1] # 0 THEN DsyLabel.canceledBr1 ¬ TRUE;      IF type # goto THEN DsyLabel.canceledBr ¬ TRUE;      IF NOT noSetDest THEN DsyLabel.SetDest[argArray[1], andMask, orMask];      END;    RETURN[RetType[Null[]]];    END;  BuildLabelSTEntry: PROCEDURE [var: LONG STRING, val: CARDINAL]    RETURNS [mptr: MEntryPtr] =    --build label entry for symbol table.  used only for SetLabel. check to make sure label value isn't bigger than bank size.    BEGIN    str1: LONG STRING;    etptr: LONG POINTER TO label ElementRec ¬ Heap.MakeNode[      DsyModule.MTtempHeap,      SIZE[label ElementRec] + SIZE[MEntry] + String.WordsForString[var.length]];    mptr ¬ LOOPHOLE[etptr + SIZE[label ElementRec]];    str1 ¬ LOOPHOLE[mptr + SIZE[MEntry]];    str1­ ¬ StringBody[maxlength: var.length, length: 0, text:];    String.AppendString[str1, var];    IF val NOT IN [0..DsyLabel.maxNumMI) THEN {      DsyFile.LogErrAndSrcLines["Invalid SetLabel value"L]; val ¬ 0};    etptr­ ¬ ElementRec[label[str1, val]];    mptr­ ¬ MEntry[str1, etptr, NIL];    END;  -- end BuildLabelSTEntry  BuildMacroSTEntry: PROCEDURE [mac: LONG STRING, exp: LONG STRING]    RETURNS [mptr: MEntryPtr] =    --build macro entry for symbol table    BEGIN    str1: LONG STRING;    str2: LONG STRING;    etptr: LONG POINTER TO userMacro ElementRec ¬ Heap.MakeNode[      DsyModule.MTtempHeap,      SIZE[userMacro ElementRec] + SIZE[MEntry] + String.WordsForString[mac.length]        + String.WordsForString[exp.length]];    mptr ¬ LOOPHOLE[etptr + SIZE[userMacro ElementRec]];    str1 ¬ LOOPHOLE[mptr + SIZE[MEntry]];    str2 ¬ LOOPHOLE[str1 + String.WordsForString[mac.length]];    str1­ ¬ StringBody[maxlength: mac.length, length: 0, text:];    str2­ ¬ StringBody[maxlength: exp.length, length: 0, text:];    String.AppendString[str1, mac];    String.AppendString[str2, exp];    etptr­ ¬ ElementRec[userMacro[str2]];    mptr­ ¬ MEntry[str1, etptr, NIL];    END;  -- end BuildMacroSTEntry  BuildRegSTEntry: PROCEDURE [name: LONG STRING, rt: RegisterType, val: CARDINAL]    RETURNS [mptr: MEntryPtr] =    --build register entry for symbol table and check to make sure haven't referenced a nonexistant register    BEGIN    str1: LONG STRING;    etptr: LONG POINTER TO ElementRec ¬ Heap.MakeNode[      DsyModule.MTtempHeap,      SIZE[register ElementRec] + SIZE[MEntry] + String.WordsForString[        name.length]];    mptr ¬ LOOPHOLE[etptr + SIZE[register ElementRec]];    str1 ¬ LOOPHOLE[mptr + SIZE[MEntry]];    str1­ ¬ StringBody[maxlength: name.length, length: 0, text:];    String.AppendString[str1, name];    SELECT rt FROM      R =>        BEGIN        IF val NOT IN [4..64) THEN {          DsyFile.LogErrArgAndSrcLines["R register not in 4..63 "L, name];          etptr­ ¬ ElementRec[register[R, 63]]}        ELSE etptr­ ¬ ElementRec[register[R, val]];        END;      D =>        BEGIN        IF val NOT IN [0..16) THEN          DsyFile.LogErrArgAndSrcLines["D register not in 0..15 "L, name];        etptr­ ¬ ElementRec[register[D, Inline.BITAND[15, val]]];        END;      aUpper8 =>        BEGIN        IF val NOT IN [0..8) THEN          DsyFile.LogErrArgAndSrcLines["A register not in 0..7 "L, name];        etptr­ ¬ ElementRec[register[aUpper8, Inline.BITAND[7, val]]];        END;      aUpper16 =>        BEGIN        IF val NOT IN [0..8) THEN          DsyFile.LogErrArgAndSrcLines["A register not in 0..7 "L, name];        etptr­ ¬ ElementRec[register[aUpper16, Inline.BITAND[7, val]]];        END;      aLower16 =>        BEGIN        IF val NOT IN [0..8) THEN          DsyFile.LogErrArgAndSrcLines["A register not in 0..7 "L, name];        etptr­ ¬ ElementRec[register[aLower16, Inline.BITAND[7, val]]];        END;      A =>        BEGIN        IF val NOT IN [0..8) THEN          DsyFile.LogErrArgAndSrcLines["A register not in 0..7 "L, name];        etptr­ ¬ ElementRec[register[A, Inline.BITAND[7, val]]];        END;      ENDCASE;    mptr­ ¬ MEntry[str1, etptr, NIL];    END;  -- end BuildRegSTEntry  BuildVarSTEntry: PROCEDURE [var: LONG STRING, val: CARDINAL]    RETURNS [mptr: MEntryPtr] =    BEGIN    str1: LONG STRING;    etptr: LONG POINTER TO variable ElementRec ¬ Heap.MakeNode[      DsyModule.MTtempHeap,      SIZE[variable ElementRec] + SIZE[MEntry] + String.WordsForString[        var.length]];    mptr ¬ LOOPHOLE[etptr + SIZE[variable ElementRec]];    str1 ¬ LOOPHOLE[mptr + SIZE[MEntry]];    str1­ ¬ StringBody[maxlength: var.length, length: 0, text:];    String.AppendString[str1, var];    IF val NOT IN [0..65535] THEN {      DsyFile.LogErrAndSrcLines["Invalid constant value"L]; val ¬ 0};    etptr­ ¬ ElementRec[variable[val]];    mptr­ ¬ MEntry[str1, etptr, NIL];    END;  -- end BuildVarSTEntry  External: PROCEDURE [type: BuiltinMacroType] RETURNS [ret: RetType] =    BEGIN    i: CARDINAL;    mynumArgs: CARDINAL ¬ DsyControl.numArgs;    argArray: ARRAY [0..DsyAssembler.sizeArgArray] OF LONG STRING ¬ ALL[NIL];    DsyControl.assemblerDirective ¬ DsyControl.assemblerDirective + 1;    DsyModule.SaveArgs[@argArray, mynumArgs];    FOR i IN [1..mynumArgs] DO      DsyLabel.ProcessExternal[type, argArray[i]]; ENDLOOP;    RETURN[RetType[Null[]]];    END;  -- end External  GetValue: PROCEDURE [et: ElementRec] RETURNS [value: CARDINAL] =    BEGIN    WITH et SELECT FROM      constant => RETURN[value];      variable => RETURN[val];      ENDCASE =>        BEGIN        DsyFile.LogErrAndSrcLines[          "Invalid argument in builtin macro: numeric value expected"L];        RETURN[0];        END;    END;  -- end GetValue  If: PROCEDURE [type: BuiltinMacroType] RETURNS [ret: RetType] =    BEGIN    myS, myS1, myS2: MyString;    mynumArgs: CARDINAL ¬ DsyControl.numArgs;    val1, val2: CARDINAL;    argArray: ARRAY [0..DsyAssembler.sizeArgArray] OF LONG STRING ¬ ALL[NIL];    DsyModule.SaveArgs[@argArray, mynumArgs];    IF DsyControl.numArgs NOT IN [3..4] THEN      DsyFile.LogErrAndSrcLines["Wrong number of args for if type macro"L];    myS1 ¬ [0, argArray[1]];    myS2 ¬ [0, argArray[2]];    val1 ¬ GetValue[DsyModule.InterpretArg[DsyModule.BreakPhraseArg[@myS1]]];    val2 ¬ GetValue[DsyModule.InterpretArg[DsyModule.BreakPhraseArg[@myS2]]];    myS ¬      SELECT type FROM        equal => IF val1 = val2 THEN [0, argArray[3]] ELSE [0, argArray[4]],        greater => IF val1 > val2 THEN [0, argArray[3]] ELSE [0, argArray[4]],        andZero =>          IF Inline.BITAND[val1, val2] = 0 THEN [0, argArray[3]]          ELSE [0, argArray[4]],        ENDCASE => [0, NIL];    IF myS.String # NIL THEN      BEGIN      String.AppendChar[myS.String, ',];      UNTIL myS.String.length <= myS.NextChar DO        DsyModule.InterpretMain[DsyModule.BreakPhraseMain[@myS]] ENDLOOP;      END;    END;  -- end If  InitMacroTable: PUBLIC PROCEDURE =    BEGIN    -- insert builtin's    AddBuiltin["Add"L, 0, add];    AddBuiltin["And"L, 0, and];    AddBuiltin["Mul"L, 0, mul];    AddBuiltin["Or"L, 0, or];    AddBuiltin["Xor"L, 0, xor];    AddBuiltin["Sub"L, 1, sub];    AddBuiltin["Lshift"L, 1, lshift];    AddBuiltin["Rshift"L, 1, rshift];    AddBuiltin["GOTO"L, 2, goto];    AddBuiltin["CALL"L, 2, goto];    AddBuiltin["GOTOABS"L, 2, gotoabs];    AddBuiltin["BRANCH"L, 2, branch];    AddBuiltin["CANCELBR"L, 2, cancelbr];    AddBuiltin["DISP2"L, 2, disp2];    AddBuiltin["DISP3"L, 2, disp3];    AddBuiltin["DISP4"L, 2, disp4];    AddBuiltin["RET"L, 2, ret];    AddBuiltin["IfEqual"L, 3, equal];    AddBuiltin["IfGreater"L, 3, greater];    AddBuiltin["IfAndZero"L, 3, andZero];    AddBuiltin["Set"L, 4, setConstant];    AddBuiltin["SetLabel"L, 4, setLabel];    AddBuiltin["PrintVar"L, 5, null];    AddBuiltin["MacroDef"L, 6, null];    AddBuiltin["RegDef"L, 7, null];    AddBuiltin["IMPORT"L, 8, import];    AddBuiltin["EXPORT"L, 8, export];    AddBuiltin["at"L, 9, null];    AddBuiltin["Reserve"L, 10, null];    AddBuiltin["Print"L, 11, null];    AddBuiltin["StartAddress"L, 12, sa];    AddBuiltin["StartAddressPlus1"L, 12, saPlus1];    AddBuiltin["SkipTo"L, 13, null];    AddBuiltin["LOOPHOLE"L, 14, null];    AddBuiltin["PARITY"L, 15, null];    AddSTEntry["¬"L, ElementRec[arrow[]], SIZE[arrow ElementRec]];    AddSTEntry["+"L, ElementRec[plus[]], SIZE[plus ElementRec]];    AddSTEntry["-"L, ElementRec[minus[]], SIZE[minus ElementRec]];    AddSTEntry["MpyStep"L, ElementRec[mpy[]], SIZE[mpy ElementRec]];    AddSTEntry["~"L, ElementRec[not[]], SIZE[not ElementRec]];    AddSTEntry["and"L, ElementRec[logical[and]], SIZE[logical ElementRec]];    AddSTEntry["or"L, ElementRec[logical[or]], SIZE[logical ElementRec]];    AddSTEntry["xor"L, ElementRec[logical[xor]], SIZE[logical ElementRec]];    AddSTEntry["nand"L, ElementRec[logical[nand]], SIZE[logical ElementRec]];    AddSTEntry["nor"L, ElementRec[logical[nor]], SIZE[logical ElementRec]];    AddSTEntry["nxor"L, ElementRec[logical[nxor]], SIZE[logical ElementRec]];    AddSTEntry["Cin¬"L, ElementRec[partialArrow[]], SIZE[partialArrow ElementRec]];    AddSTEntry["ib¬"L, ElementRec[partialArrow[]], SIZE[partialArrow ElementRec]];    AddSTEntry["Q"L, ElementRec[register[Q, 0]], SIZE[register ElementRec]];    AddSTEntry[      "StkP"L, ElementRec[register[stkPtr, 0]], SIZE[register ElementRec]];    AddSTEntry[      "RTC.high"L, ElementRec[register[timerHigh, 0]], SIZE[register ElementRec]];    AddSTEntry[      "RTC.low"L, ElementRec[register[timerLow, 0]], SIZE[register ElementRec]];    AddSTEntry["NIB"L, ElementRec[register[A, 0]], SIZE[register ElementRec]];    AddSTEntry[      "NIB.low"L, ElementRec[register[aLower16, 0]], SIZE[register ElementRec]];    AddSTEntry[      "NIB.page"L, ElementRec[register[aUpper16, 0]], SIZE[register ElementRec]];    AddSTEntry[      "NIB.high"L, ElementRec[register[aUpper8, 0]], SIZE[register ElementRec]];    AddSTEntry[      "STK-2"L, ElementRec[register[stkMinus2, 0]], SIZE[register ElementRec]];    AddSTEntry[      "STK-1"L, ElementRec[register[stkMinus1, 0]], SIZE[register ElementRec]];    AddSTEntry[      "STK0"L, ElementRec[register[stkZero, 0]], SIZE[register ElementRec]];    AddSTEntry[      "STK1"L, ElementRec[register[stkPlus1, 0]], SIZE[register ElementRec]];    AddSTEntry[      "ChipVersionNo"L, ElementRec[register[chipVersion, 0]], SIZE[      register ElementRec]];    AddSTEntry[      "CSBank"L, ElementRec[register[CSBank, 0]], SIZE[register ElementRec]];    AddSTEntry["CIP"L, ElementRec[register[CIP, 0]], SIZE[register ElementRec]];    AddSTEntry[      "Prescaler"L, ElementRec[register[prescaler, 0]], SIZE[register ElementRec]];    AddSTEntry["ib"L, ElementRec[register[ib, 0]], SIZE[register ElementRec]];    AddSTEntry["ibSE"L, ElementRec[register[ibSE, 0]], SIZE[register ElementRec]];    AddSTEntry[      "ibCtr"L, ElementRec[register[ibCtr, 0]], SIZE[register ElementRec]];    AddSTEntry[      "Config"L, ElementRec[variable[DsyControl.config]], SIZE[      variable ElementRec]];    AddSTEntry["*"L, ElementRec[star[]], SIZE[star ElementRec]];    AddSTEntry["MD"L, ElementRec[empty[]], SIZE[empty ElementRec]];    AddSTEntry["MDu"L, ElementRec[empty[]], SIZE[empty ElementRec]];    AddSTEntry["MDv"L, ElementRec[empty[]], SIZE[empty ElementRec]];    END;  LoopHole: PROCEDURE [type: BuiltinMacroType] RETURNS [ret: RetType] =    BEGIN    argArray: ARRAY [0..DsyAssembler.sizeArgArray] OF LONG STRING ¬ ALL[NIL];    mynumArgs: CARDINAL ¬ DsyControl.numArgs;    DsyModule.SaveArgs[@argArray, mynumArgs];    IF DsyControl.numArgs # 1 THEN      DsyFile.LogErrAndSrcLines["Wrong number of args for LOOPHOLE"L];    SELECT TRUE FROM      String.EqualString[argArray[1], "oldAReg"L] => DsyLabel.oldok ¬ TRUE;      String.EqualString[argArray[1], "wok"L] => DsyLabel.wok ¬ TRUE;      String.EqualString[argArray[1], "natc"L] => DsyLabel.natc ¬ TRUE;      String.EqualString[argArray[1], "CycleOK"L] => DsyLabel.cycleOK ¬ TRUE;      ENDCASE => DsyFile.LogErrAndSrcLines["Unknown argument to LOOPHOLE"L];    RETURN[RetType[Null[]]];    END;  -- end MacroDef  MacroDef: PROCEDURE [type: BuiltinMacroType] RETURNS [ret: RetType] =    BEGIN    argArray: ARRAY [0..DsyAssembler.sizeArgArray] OF LONG STRING ¬ ALL[NIL];    mptr: MEntryPtr;    mynumArgs: CARDINAL ¬ DsyControl.numArgs;    DsyControl.assemblerDirective ¬ DsyControl.assemblerDirective + 1;    DsyModule.SaveArgs[@argArray, mynumArgs];    IF DsyControl.numArgs # 2 THEN      DsyFile.LogErrAndSrcLines["Wrong number of args for MacroDef"L];    mptr ¬ BuildMacroSTEntry[argArray[1], argArray[2]];    IF DsyModule.InsertM[mptr] THEN      DsyFile.LogErrArgAndSrcLines["Macro already defined "L, argArray[1]];    RETURN[RetType[Null[]]];    END;  -- end MacroDef  Parity: PROCEDURE [type: BuiltinMacroType] RETURNS [ret: RetType] =    BEGIN    argArray: ARRAY [0..DsyAssembler.sizeArgArray] OF LONG STRING ¬ ALL[NIL];    mynumArgs: CARDINAL ¬ DsyControl.numArgs;    myS: MyString;    tempString: LONG STRING ¬ [64];    wordMask: String.SubStringDescriptor;    DsyModule.SaveArgs[@argArray, mynumArgs];    DsyControl.assemblerDirective ¬ DsyControl.assemblerDirective - 1;    IF DsyControl.numArgs # 1 THEN      DsyFile.LogErrAndSrcLines["Wrong number of args for PARITY"L]    ELSE      IF argArray[1].length # 12 THEN        DsyFile.LogErrAndSrcLines["Mask is not 48 bits wide"L]      ELSE {        --mask for first word of MI:        tempString.length ¬ 0;        wordMask ¬ String.SubStringDescriptor[          base: argArray[1], offset: 0, length: 4];        String.AppendSubString[tempString, @wordMask];        myS ¬ [0, tempString];        parity.mask1 ¬ GetValue[          DsyModule.InterpretArg[DsyModule.BreakPhraseArg[@myS]]];        --mask for second word of MI:        tempString.length ¬ 0;        wordMask ¬ String.SubStringDescriptor[          base: argArray[1], offset: 4, length: 4];        String.AppendSubString[tempString, @wordMask];        myS ¬ [0, tempString];        parity.mask2 ¬ GetValue[          DsyModule.InterpretArg[DsyModule.BreakPhraseArg[@myS]]];        --mask for second word of MI:        tempString.length ¬ 0;        wordMask ¬ String.SubStringDescriptor[          base: argArray[1], offset: 8, length: 4];        String.AppendSubString[tempString, @wordMask];        myS ¬ [0, tempString];        parity.mask3 ¬ GetValue[          DsyModule.InterpretArg[DsyModule.BreakPhraseArg[@myS]]]};    RETURN[RetType[Null[]]];    END;  --of procedure Parity  PrintString: PROCEDURE [type: BuiltinMacroType] RETURNS [ret: RetType] =    --print message onto .er file    BEGIN    mynumArgs: CARDINAL ¬ DsyControl.numArgs;    argArray: ARRAY [0..DsyAssembler.sizeArgArray] OF LONG STRING ¬ ALL[NIL];    DsyControl.assemblerDirective ¬ DsyControl.assemblerDirective + 1;    DsyModule.SaveArgs[@argArray, mynumArgs];    DsyFile.LogLine[argArray[1]];    RETURN[RetType[Null[]]];    END;  -- end PrintString  PrintVar: PROCEDURE [type: BuiltinMacroType] RETURNS [ret: RetType] =    --print value of variable onto the .er file    BEGIN    msg: LONG STRING ¬ [maxArgLength];    myS: MyString;    mynumArgs: CARDINAL ¬ DsyControl.numArgs;    et: ElementRec;    argArray: ARRAY [0..DsyAssembler.sizeArgArray] OF LONG STRING ¬ ALL[NIL];    DsyControl.assemblerDirective ¬ DsyControl.assemblerDirective + 1;    DsyModule.SaveArgs[@argArray, mynumArgs];    IF DsyControl.numArgs > 1 THEN      DsyFile.LogErrAndSrcLines["Too many args for PrintVar"L];    String.AppendString[msg, argArray[1]];    String.AppendString[msg, " = "L];    myS ¬ [0, argArray[1]];    et ¬ DsyModule.InterpretArg[DsyModule.BreakPhraseArg[@myS]];    WITH et SELECT FROM      variable =>        BEGIN        String.AppendNumber[msg, val, 16];        String.AppendChar[msg, Ascii.CR];        END;      ENDCASE =>         BEGIN	DsyFile.LogErrAndSrcLines["Illegal PrintVar"L];        RETURN[RetType[Error[]]];	END;    DsyFile.LogLine[msg];    RETURN[RetType[Null[]]];    END;  -- end PrintVar  RegDef: PROCEDURE [type: BuiltinMacroType] RETURNS [ret: RetType] =    BEGIN    aMulDefined: BOOLEAN ¬ FALSE;    myS: MyString;    val: CARDINAL;    mptr: MEntryPtr;    regtype: RegisterType;    mynumArgs: CARDINAL ¬ DsyControl.numArgs;    argArray: ARRAY [0..DsyAssembler.sizeArgArray] OF LONG STRING ¬ ALL[NIL];    DsyControl.assemblerDirective ¬ DsyControl.assemblerDirective + 1;    DsyModule.SaveArgs[@argArray, mynumArgs];    IF DsyControl.numArgs # 3 THEN      DsyFile.LogErrAndSrcLines["RegDef requires 3 args"L];    IF argArray[2].length > 2 THEN      DsyFile.LogErrArgAndSrcLines[        "Illegal register type in RegDef, R assumed "L, argArray[2]];    regtype ¬      SELECT argArray[2][0] FROM        'R, 'r => IF argArray[2].length = 1 THEN R ELSE Q,        'A, 'a => IF argArray[2].length = 1 THEN A ELSE Q,        'D, 'd => IF argArray[2].length = 1 THEN D ELSE Q,        ENDCASE => Q;    IF regtype = Q THEN      BEGIN      regtype ¬ R;      DsyFile.LogErrArgAndSrcLines[        "Illegal register type in RegDef, R assumed "L, argArray[2]];      END;    myS ¬ [0, argArray[3]];    val ¬ GetValue[DsyModule.InterpretArg[DsyModule.BreakPhraseArg[@myS]]];    IF regtype = A THEN {      String.AppendString[argArray[1], ".low"L];      mptr ¬ BuildRegSTEntry[argArray[1], aLower16, val];      argArray[1].length ¬ argArray[1].length - 4;      aMulDefined ¬ aMulDefined OR DsyModule.InsertM[mptr];      String.AppendString[argArray[1], ".page"L];      mptr ¬ BuildRegSTEntry[argArray[1], aUpper16, val];      argArray[1].length ¬ argArray[1].length - 5;      aMulDefined ¬ aMulDefined OR DsyModule.InsertM[mptr];      String.AppendString[argArray[1], ".high"L];      mptr ¬ BuildRegSTEntry[argArray[1], aUpper8, val];      argArray[1].length ¬ argArray[1].length - 5;      aMulDefined ¬ aMulDefined OR DsyModule.InsertM[mptr];      IF aMulDefined THEN        DsyFile.LogErrArgAndSrcLines[          "Register name already defined "L, argArray[1]]};    mptr ¬ BuildRegSTEntry[argArray[1], regtype, val];    --correct reference to register number in BuildRegSTEntry by val    IF DsyModule.InsertM[mptr] THEN      DsyFile.LogErrArgAndSrcLines["Register name already defined "L, argArray[1]];    RETURN[RetType[Null[]]];    END;  -- end RegDef  Reserve: PROCEDURE [type: BuiltinMacroType] RETURNS [ret: RetType] =    --reserve a region in control store where this assembly cannot put code    BEGIN    myS: MyString;    low, high: CARDINAL;    mynumArgs: CARDINAL ¬ DsyControl.numArgs;    argArray: ARRAY [0..DsyAssembler.sizeArgArray] OF LONG STRING ¬ ALL[NIL];    DsyControl.assemblerDirective ¬ DsyControl.assemblerDirective + 1;    DsyModule.SaveArgs[@argArray, mynumArgs];    IF DsyControl.numArgs NOT IN [1..2] THEN      BEGIN      DsyFile.LogErrAndSrcLines["Reserve requires one or two args"L];      RETURN[RetType[Null[]]];      END;    myS ¬ [0, argArray[1]];    low ¬ GetValue[DsyModule.InterpretArg[DsyModule.BreakPhraseArg[@myS]]];    IF mynumArgs = 2 THEN      BEGIN      myS ¬ [0, argArray[2]];      high ¬ GetValue[DsyModule.InterpretArg[DsyModule.BreakPhraseArg[@myS]]];      DsyLabel.ProcessReserve[low, high];      END    ELSE DsyLabel.ProcessReserve[low, low];    RETURN[RetType[Null[]]];    END;  -- end RegDef  Set: PROCEDURE [type: BuiltinMacroType] RETURNS [ret: RetType] =    --define a constant or a label for GOTOABS    BEGIN    value: CARDINAL;    myS: MyString;    mptr: MEntryPtr;    mynumArgs: CARDINAL ¬ DsyControl.numArgs;    argArray: ARRAY [0..DsyAssembler.sizeArgArray] OF LONG STRING ¬ ALL[NIL];    et: ElementRec;    DsyControl.assemblerDirective ¬ DsyControl.assemblerDirective + 1;    DsyModule.SaveArgs[@argArray, mynumArgs];    IF mynumArgs # 2 THEN      BEGIN      DsyFile.LogErrAndSrcLines["Set requires two args"L];      RETURN[RetType[Null[]]];      END;    myS ¬ [0, argArray[2]];    value ¬ GetValue[DsyModule.InterpretArg[DsyModule.BreakPhraseArg[@myS]]];    myS ¬ [0, argArray[1]];    et ¬ DsyModule.InterpretArg[DsyModule.BreakPhraseArg[@myS]];    IF type = setConstant THEN      WITH et SELECT FROM        variable =>          DsyFile.LogErrAndSrcLines[            "Multiple definition of constant not allowed"L];        undefinedToken =>          BEGIN          mptr ¬ BuildVarSTEntry[argArray[1], value];          [] ¬ DsyModule.InsertM[mptr];          END;        ENDCASE => 	  BEGIN	  DsyFile.LogErrAndSrcLines["Illegal constant name"L];	  RETURN[RetType[Error[]]];	  END    ELSE      WITH et SELECT FROM        undefinedToken =>          BEGIN          mptr ¬ BuildLabelSTEntry[argArray[1], value];          [] ¬ DsyModule.InsertM[mptr];          END;        ENDCASE => 	  BEGIN	  DsyFile.LogErrAndSrcLines["Illegal constant name"L];	  RETURN[RetType[Error[]]];	  END;    RETURN[RetType[Null[]]];    END;  -- end Set   SkipTo: PROCEDURE [type: BuiltinMacroType] RETURNS [ret: RetType] =    --used in conditional code generation    BEGIN    argArray: ARRAY [0..DsyAssembler.sizeArgArray] OF LONG STRING ¬ ALL[NIL];    mynumArgs: CARDINAL ¬ DsyControl.numArgs;    DsyModule.SaveArgs[@argArray, mynumArgs];    IF DsyControl.numArgs # 1 THEN      DsyFile.LogErrAndSrcLines["SkipTo requires one arg"L];    DsyModule.SkipUntil[argArray[1]];    DsyControl.ifsInThisFile ¬ TRUE;  -- force .si to be deleted        RETURN[RetType[Null[]]];    END;  -- end SkipTo  StartAddress: PROCEDURE [type: BuiltinMacroType] RETURNS [ret: RetType] =    --process StartAddress and StartAddressPlus1    BEGIN    mynumArgs: CARDINAL ¬ DsyControl.numArgs;    argArray: ARRAY [0..DsyAssembler.sizeArgArray] OF LONG STRING ¬ ALL[NIL];    DsyControl.assemblerDirective ¬ DsyControl.assemblerDirective + 1;    DsyModule.SaveArgs[@argArray, mynumArgs];    IF DsyControl.numArgs # 1 THEN      DsyFile.LogErrAndSrcLines["StartAddress requires one arg"L];    IF type = sa THEN DsyLabel.ProcSA[argArray[1], TRUE]    ELSE DsyLabel.ProcSA[argArray[1], FALSE];    RETURN[RetType[Null[]]];    END;  -- end StartAddress  END.  --Log of Last Edit:--JAC   	22-Aug-84 16:07:16	CancelBr's now execute SetDest--JAC   	23-Aug-84 15:07:09	add 1 to assemblerDirective when the line contains an  assembler directive, and decrement by 1 otherwise.--JAC   	22-Sep-84 17:21:36	when RetType is error, print an error message before returning--JAC   	 9-Oct-84 10:46:43	added Lshift and Rshift as BuiltInMacros--JAC   	 5-Nov-84 14:32:22	fixed arrows for Mesa 11.1
-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. --Last edit by JAC               21-May-85 15:37:19DIRECTORY  DsyuFormat USING [LabelSeqNum, PartialBinary],  DsyAssembler;DsyLabel: DEFINITIONS =  BEGIN OPEN DsyAssembler;    ArgReference: TYPE = RECORD [    next: ArgReferencePtr,    reference: ArgumentType,    oldok: BOOLEAN];  ArgReferencePtr: TYPE = LONG POINTER TO ArgReference;    BranchType: TYPE = {none, branch, cancelbr, disp};  ConstraintAttribute: TYPE = RECORD [    caChain: LONG POINTER TO ConstraintAttribute ¬ NIL,    constraints: LONG POINTER TO ConstraintChain ¬ NIL,    maxModulo: ModuloIndex ¬ 0];  -- end ConstraintAttribute  ConstraintChain: TYPE = RECORD [    nextConstraint: LONG POINTER TO ConstraintChain ¬ NIL,    miIndex1: CARDINAL [0..5120) ¬ NullIndex,    miIndex2: CARDINAL [0..5120) ¬ NullIndex,    offset: CARDINAL [0..4096) ¬ 0,    modulo: ModuloIndex ¬ 0];  -- end ConstraintChain  ConstraintRec: TYPE = RECORD [    label1: LabelRec ¬ LabelRec[special[]],    label2: LabelRec ¬ LabelRec[special[]],    offset: CARDINAL [0..4096) ¬ 0,    modulo: ModuloIndex ¬ 0];  -- end ConstraintRec  CurrentMI: TYPE = RECORD [    dest: LabelRec ¬ LabelRec[special[]],    andMask: CARDINAL [0..maxNumMI) ¬ 4095,    orMask: CARDINAL [0..maxNumMI) ¬ 0];  -- end CurrentMI      Cycle: TYPE = CARDINAL [0..4];    DestReference: TYPE = RECORD [    next: DestPtr,    dest: ArgumentType];  DestPtr: TYPE = LONG POINTER TO DestReference;  EarlyBinaryRec: TYPE = RECORD [    partialBinary: DsyuFormat.PartialBinary,    destMI: CurrentMI,    last: BOOLEAN ¬ FALSE,    parityMasks: ParityMasks,    sa: {none, sa, saPlus1} ¬ none];  -- end EarlyBinaryRec  Empty: CARDINAL [0..5120) = 5119;  HashEntry: TYPE = RECORD [    key: LONG STRING, ptr: LabelEntryPtr ¬ NIL, next: HashEntryPtr ¬ NIL];  HashEntryPtr: TYPE = LONG POINTER TO HashEntry;  LTtempHeap: UNCOUNTED ZONE;  LabelEntry: TYPE = RECORD [    export: BOOLEAN ¬ FALSE,    import: BOOLEAN ¬ FALSE,    incons: BOOLEAN ¬ FALSE,    labeled: BOOLEAN ¬ FALSE,    found: BOOLEAN ¬ FALSE,    target: CARDINAL ¬ 0,    miseqnum: MiSeqNum ¬ NullIndex,    labelseqnum: DsyuFormat.LabelSeqNum ¬ 0,    isGetsIB: BOOLEAN ¬ FALSE,    fromGetsIB: BOOLEAN ¬ FALSE,        --branches:     pBr: BOOLEAN ¬ FALSE,  --set up branch condition    needsBr: BOOLEAN ¬ FALSE,    isBr: BOOLEAN ¬ TRUE,    ibDisp: BOOLEAN ¬ FALSE,    isStar: BOOLEAN ¬ FALSE,    needsStar: BOOLEAN ¬ TRUE,    pageCross: BOOLEAN ¬ FALSE,  --page cross branch set up    needsCancelPage: BOOLEAN ¬ FALSE,  --need cancel for page cross branch    pageCrossCanceled: BOOLEAN ¬ TRUE,  --page cross branch canceled?        --stack operations:    ldStkp: BOOLEAN ¬ FALSE,      stknok: BOOLEAN ¬ FALSE,    isstk: BOOLEAN ¬ FALSE,    ldStkpnok: BOOLEAN ¬ FALSE,        --cycle information:    isCycle: Cycle ¬ 0,    needsCycle: Cycle ¬ 0,    alwaysJumpFromCycleOK: BOOLEAN ¬ TRUE,        --memory operations:    memStatus: MemStatus ¬ none,    usesMD: BOOLEAN ¬ FALSE,    startWrite:  BOOLEAN ¬ FALSE,    jumpFromEnd: BOOLEAN ¬ FALSE,  --set TRUE for label branched to if current MI ends a memory cycle before branching    c2ok: BOOLEAN ¬ TRUE,  --cycle 2 of a write either has a branch or the 1 bit is masked and the MI has a LOOPHOLE[wok]        --AFile checking    destination: DestPtr ¬ NIL,    referenced: ArgReferencePtr ¬ NIL,    usedOffsetAdder: BOOLEAN ¬ FALSE];   --end LabelEntry  LabelEntryPtr: TYPE = LONG POINTER TO LabelEntry;  LabelList: TYPE = RECORD [    next: LabelListPtr ¬ NIL, label: HashEntryPtr];  -- end LabelList  LabelListPtr: TYPE = LONG POINTER TO LabelList;  LabelRec: TYPE = RECORD [    element: SELECT type: LabelType FROM      unlabeled => [miseqnum: MiSeqNum],      labeled => [labelseqnum: DsyuFormat.LabelSeqNum],      absolute => [value: CARDINAL [0..4096)],      special => NULL,      ENDCASE];  -- end LabelRec  LabelIntRec: TYPE = RECORD [    export: BOOLEAN ¬ FALSE,    import: BOOLEAN ¬ FALSE,    incons: BOOLEAN ¬ FALSE,    found: BOOLEAN ¬ FALSE,    target: BOOLEAN ¬ FALSE,    isCycle: Cycle ¬ cycle0,    needsCycle: Cycle ¬ cycle0,    cycleOK: BOOLEAN ¬ FALSE,    memStatus: MemStatus ¬ none,    labIndex: DsyuFormat.LabelSeqNum ¬ 0,    length: [0..256) ¬ 0,    miIndex: CARDINAL [0..5120) ¬ Empty];  -- end LabelIntRec  LabelType: TYPE = {absolute, unlabeled, labeled, external, special};  maxmaxModulo: CARDINAL = 5;  maxNumMI: CARDINAL = 4096;    MemStatus: TYPE = {none, read, singleRead, doubleRead, write, singleWrite, doubleWrite};  --position is important!  MiSeqNum: TYPE = CARDINAL [0..5120);  Modulo: ARRAY [0..5] OF CARDINAL = [1, 2, 4, 8, 16, 4096];  ModuloIndex: TYPE = [0..5];  NullIndex: CARDINAL [0..5120) = 5118;  canceledBr: BOOLEAN;  canceledBr1: BOOLEAN;  --first bit of condition bit canceled (i.e. 1)  cycleOK: BOOLEAN;  curLineLab: LONG STRING;  curLineNum: CARDINAL;  fromCycleOK: BOOLEAN;  fromDest: ArgumentType;  hasLabel: BOOLEAN;  immLastDestField: BOOLEAN;  lastLabel: HashEntryPtr;  branchType: BranchType;  natc: BOOLEAN;  oldok: BOOLEAN;  --Use of old contents of A register ok  reference: ArgumentType;  wok: BOOLEAN;  --Write ok loophole  -- procedures  --Implemented in DsyAllocImpl:  AddConstraint: PROCEDURE [ccp: LONG POINTER TO ConstraintChain];    AllocateUnconstrained: PROCEDURE;   BuildCAList: PROCEDURE RETURNS [caOut: LONG POINTER TO ConstraintAttribute];    ProcessConstraints: PROCEDURE [ca: LONG POINTER TO ConstraintAttribute];       --Implemented in DsyLabelImpl:  BrConstrain: PROCEDURE [    lab1, lab2: LONG STRING, offset: CARDINAL, modulo: ModuloIndex];    BuildEarlyBinary: PROCEDURE [encodingPtr: EncodingPtr];  CheckDfnForLabels: PROCEDURE;    Constrain: PROCEDURE [    lab1, lab2: LONG STRING, offset: CARDINAL, modulo: ModuloIndex];   GetLabelEntry: PROCEDURE [name: LONG STRING] RETURNS [hashEntryPtr: HashEntryPtr];   McFileEndProc: PROCEDURE;    ProcessAt: PROCEDURE [offset: CARDINAL, modulo: ModuloIndex, name: LONG STRING];  ProcessDestLabel: PROCEDURE [name: LONG STRING] RETURNS [hashEntryPtr: HashEntryPtr];  ProcessExternal: PROCEDURE [type: BuiltinMacroType, name: LONG STRING];    ProcessLineLabel: PROCEDURE [name: LONG STRING] RETURNS [hashEntryPtr: HashEntryPtr];  ProcessReserve: PUBLIC PROCEDURE [lowAddr, highAddr: CARDINAL];   ProcSA: PUBLIC PROCEDURE [name: LONG STRING, sa: BOOLEAN];  ResetLabel: PUBLIC PROCEDURE;   SetDest: PROCEDURE [lab: LONG STRING, and: CARDINAL, or: CARDINAL];     --Implemented in DsyLTHashImpl:   ClearHashTable: PUBLIC PROCEDURE;   DeletePrevDest: PROCEDURE [current: LabelEntryPtr];   DisplayLabels: PROCEDURE [proc: PROCEDURE [HashEntryPtr]];    EndOfStatementProc: PROCEDURE;    FindLabel: PROCEDURE [str: LONG STRING] RETURNS [h: HashEntryPtr];     InitLTHeap: PROCEDURE [initPages, incrPages: CARDINAL];    InsertLabel: PROCEDURE [h: HashEntryPtr] RETURNS [error: BOOLEAN];   ReleaseLTSpace: PROCEDURE;      --Implemented in DsyPass2AImpl:   AppendSymbolName: PROCEDURE [str: LONG STRING, mi: CARDINAL [0..5120)];    ReadLabelFromST: PROCEDURE [str: LONG STRING];    --Implemented in DsyPass2BImpl:   Pass2Part2: PROCEDURE;   END...      --Log--JAC   	17-Aug-84 10:30:41	added cycleOK to LabelIntRec to retain info if jump between modules using LOOPHOLE[CycleOK]--JAC   	 5-Nov-84 14:19:56	fixed arrows for Mesa 11.1--JAC   	21-May-85 15:37:30	added usedOffsetAdder to LabelEntry
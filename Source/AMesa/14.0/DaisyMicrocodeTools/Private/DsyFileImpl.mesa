-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. --Last edit by JAC     5-Nov-84 14:19:26 DIRECTORY  Ascii USING [CR],  Environment USING [Block, Byte, bytesPerWord],  Exec USING [Outcome],  Inline USING [HighHalf, LowHalf],    MFile USING [    Acquire, Delete, Error, GetAccess, GetCreateDate, GetLength, GetTimes, Handle, Release],  MSegment USING [Address, Create, Delete, Handle],  MStream USING [    Error, GetFile, Handle, ReadOnly, ReadWrite, SetLength, WriteOnly],  Stream USING [    Block, Delete, GetBlock, GetPosition, GetWord, Handle, PutBlock, PutChar,     PutString, PutWord, SetPosition],  String USING [AppendString, Copy, EqualStrings],  System USING [GetGreenwichMeanTime, SecondsSinceEpoch],  Time USING [Append, Packed, Unpack],  DsyAssembler USING [version],  DsyControl USING [BeginTime,    errorsInThisFile, ifsInThisFile, errorsExist, FatalError, needsSourceLine, TtyLine, TtyText2],  DsyFile USING [fileNameMaxlenght, maxNumFiles],    DsyModule USING [ScanInit];DsyFileImpl: PROGRAM  IMPORTS     Inline, MFile, MSegment, MStream, Stream, String, System, Time, DsyAssembler, DsyControl, DsyModule  EXPORTS DsyFile, DsyModule =  BEGIN  -- Public Variables  aFlagSet: PUBLIC BOOLEAN;  currentFile: PUBLIC LONG STRING ¬ [64];  defsFilesCnt: PUBLIC CARDINAL [0..DsyFile.maxNumFiles);  defsFileNames: PUBLIC ARRAY [0..DsyFile.maxNumFiles) OF LONG STRING;  ebStream: PUBLIC Stream.Handle;  erStream: PUBLIC Stream.Handle;  fbFileSize: PUBLIC LONG CARDINAL;  fbInStream: PUBLIC Stream.Handle;  fbOutStream: PUBLIC Stream.Handle;  fbSeg: PUBLIC MSegment.Handle;  fImc: PUBLIC CARDINAL [0..DsyFile.maxNumFiles);  ftStream: PUBLIC Stream.Handle;  importsOnly: PUBLIC PACKED ARRAY [0..DsyFile.maxNumFiles) OF BOOLEAN;  mlStream: PUBLIC Stream.Handle;  outFile: PUBLIC LONG STRING ¬ [64];  passTwoOnly: PUBLIC PACKED ARRAY [0..DsyFile.maxNumFiles) OF BOOLEAN;  PassFileHandle: PUBLIC MFile.Handle;  -- fixed portion of  siPrologLength is  version, time, defsCount  siPrologLength: PUBLIC CARDINAL;  siStream: PUBLIC Stream.Handle;  sourceFilesCnt: PUBLIC CARDINAL [0..DsyFile.maxNumFiles);  sourceFileNames: PUBLIC ARRAY [0..DsyFile.maxNumFiles) OF LONG STRING;  stStream: PUBLIC Stream.Handle;  StmtFileHandle: PUBLIC MFile.Handle;  -- Private Variables  createDate: LONG STRING ¬ [20];  createTime: Time.Packed;  curSI: CARDINAL [0..DsyFile.maxNumFiles);  defsTimes: ARRAY [0..DsyFile.maxNumFiles) OF LONG CARDINAL;  errorsInFile: PACKED ARRAY [0..DsyFile.maxNumFiles) OF BOOLEAN;  fIdf: CARDINAL [0..DsyFile.maxNumFiles);  fIeb: CARDINAL [0..DsyFile.maxNumFiles);  fIfb: CARDINAL [0..DsyFile.maxNumFiles);    fIml: CARDINAL [0..DsyFile.maxNumFiles);  fIsi: CARDINAL [0..DsyFile.maxNumFiles);  ifsInFile: PACKED ARRAY [0..DsyFile.maxNumFiles) OF BOOLEAN;  sourceFile: MFile.Handle;  sourceSegment: MSegment.Handle;  -- Public Procedures  InitBackupFile: PUBLIC PROCEDURE =     BEGIN        NoRoom: PROCEDURE =      BEGIN      errorMessage: LONG STRING = "No room on volume.  Please clean up before retrying.";      DsyControl.TtyLine[errorMessage];      LogLine[errorMessage];            DsyControl.FatalError      END;              StmtFileHandle ¬ MFile.Acquire[name: ReplaceExt[outFile, "sf"], access: readWrite, release: [NIL,NIL] ! MFile.Error =>        IF code = noRoomOnVolume THEN NoRoom];    PassFileHandle ¬ MFile.Acquire[name: ReplaceExt[outFile, "pf"], access: readWrite, release: [NIL,NIL] ! MFile.Error =>        IF code = noRoomOnVolume THEN { MFile.Release[StmtFileHandle]; 	  MFile.Delete[MFile.Acquire[name: ReplaceExt[outFile, "sf"], access: delete, release: [NIL,NIL]]];	  NoRoom}]    END; --InitBackupFile        InitGlobalFile: PUBLIC PROCEDURE =    BEGIN    -- Public Variables    aFlagSet ¬ FALSE;    ebStream ¬ NIL;    erStream ¬ NIL;    fbFileSize ¬ 0;    fbInStream ¬ NIL;    fbOutStream ¬ NIL;    fbSeg ¬ NIL;        ftStream ¬ NIL;    mlStream ¬ NIL;    StmtFileHandle ¬ NIL;    PassFileHandle ¬ NIL;    outFile.length ¬ 0;    -- fixed portion of  siPrologLength is version, time, defsCount    siPrologLength ¬      Environment.bytesPerWord*(SIZE[CARDINAL] + SIZE[LONG CARDINAL] + SIZE[                                  CARDINAL]) + DsyAssembler.version.length;    siStream ¬ NIL;    stStream ¬ NIL;    -- Private Variables    fIdf ¬ 0;    fIeb ¬ 0;    fIfb ¬ 0;    fImc ¬ 0;    fIml ¬ 0;    fIsi ¬ 0;    sourceFile ¬ NIL;    currentFile.length ¬ 0;    sourceSegment ¬ NIL;    FOR index: CARDINAL IN [0..DsyFile.maxNumFiles) DO       importsOnly[index] ¬ passTwoOnly[index] ¬ FALSE    ENDLOOP;    END;  -- InitGlobalFile  Finish: PUBLIC PROCEDURE[outcome: Exec.Outcome] =    BEGIN    IF ebStream # NIL THEN ebStream ¬ CloseStream[ebStream];    IF erStream # NIL THEN erStream ¬ CloseStream[erStream];    IF fbInStream # NIL THEN fbInStream ¬ CloseStream[fbInStream];    IF fbOutStream # NIL THEN fbOutStream ¬ CloseStream[fbOutStream];    IF fbSeg # NIL THEN fbSeg ¬ DeleteSegment[fbSeg];    IF ftStream # NIL THEN ftStream ¬ CloseStream[ftStream];    IF sourceSegment # NIL THEN {      MSegment.Delete[sourceSegment]; sourceSegment ¬ NIL; sourceFile ¬ NIL};    IF sourceFile # NIL THEN {MFile.Release[sourceFile]; sourceFile ¬ NIL};    IF mlStream # NIL THEN mlStream ¬ CloseStream[mlStream];    IF siStream # NIL THEN {      siStream ¬ CloseStream[siStream];      IF (outcome # normal) AND (currentFile.length # 0) THEN         MFile.Delete[MFile.Acquire[ReplaceExt[currentFile, "si"], delete, [NIL,NIL]]]};    IF stStream # NIL THEN stStream ¬ CloseStream[stStream];    END;  -- Finish  CloseStream: PUBLIC PROCEDURE [sh: Stream.Handle]    RETURNS [nilSh: Stream.Handle ¬ NIL] = {    IF sh = NIL THEN ERROR;     SELECT MFile.GetAccess[MStream.GetFile[sh]] FROM        readWrite, writeOnly => MStream.SetLength[sh, Stream.GetPosition[sh]];    ENDCASE;    Stream.Delete[sh];    sh ¬ NIL};  CreateLogFile: PUBLIC PROCEDURE =    BEGIN    erStream ¬ MStream.WriteOnly[ReplaceExt[outFile, "er"], [NIL, NIL], text];    END;  -- CreateLogFile    DeleteSegment: PUBLIC PROCEDURE [sh: MSegment.Handle] RETURNS [nilsh: MSegment.Handle ¬ NIL] =    BEGIN    MSegment.Delete[sh];    sh ¬ NIL;        END;   --DeleteSegment      DeleteSIs: PUBLIC PROCEDURE =    BEGIN    FOR curSI IN [0..sourceFilesCnt) DO      IF errorsInFile[curSI] OR (DsyControl.errorsExist AND ifsInFile[curSI]) THEN        MFile.Delete[MFile.Acquire[          ReplaceExt[sourceFileNames[curSI], "si"], delete, [NIL, NIL]]]    ENDLOOP;    END;  LogErrArgAndSrcLines: PUBLIC PROCEDURE [str1, str2: LONG STRING] =    BEGIN LogErrLine2[str1, str2]; DsyControl.needsSourceLine ¬ TRUE; END;  LogErrAndSrcLines: PUBLIC PROCEDURE [str: LONG STRING] = {    LogErrLine[str]; DsyControl.needsSourceLine ¬ TRUE};  LogErrAndSrcLinesBadChar: PUBLIC PROCEDURE [char: CHARACTER] =    BEGIN    Stream.PutString[erStream, "The character: "L];    Stream.PutChar[erStream, char];    LogErrAndSrcLines[" is illegal in arguments."L];    END;  LogErrLine: PUBLIC PROCEDURE [str: LONG STRING] = {    LogErrText[str]; Stream.PutChar[erStream, Ascii.CR]};  LogErrLine2: PUBLIC PROCEDURE [str1, str2: LONG STRING] = {    LogText[str1]; LogErrLine[str2]};  LogErrLineBadFile: PROCEDURE [str: LONG STRING] = {    LogErrLine2["Can't aquire file: "L, str]};  LogErrText: PUBLIC PROCEDURE [str: LONG STRING] =    BEGIN    DsyControl.errorsInThisFile ¬ TRUE;    DsyControl.errorsExist ¬ TRUE;    Stream.PutString[erStream, str];    END;    LogErrText2: PUBLIC PROCEDURE [str1, str2: LONG STRING] = {    LogText[str1]; LogErrText[str2]};  LogLine: PUBLIC PROCEDURE [str: LONG STRING] = {    Stream.PutString[erStream, str]; Stream.PutChar[erStream, Ascii.CR]};    LogText: PUBLIC PROCEDURE [str: LONG STRING] = {    Stream.PutString[erStream, str]};  LogText2: PUBLIC PROCEDURE [str1, str2: LONG STRING] = {    LogText[str1]; LogText[str2]};  OpenFbOut: PUBLIC PROCEDURE =    BEGIN    fbOutStream ¬ MStream.WriteOnly[      ReplaceExt[outFile, "fb"], [NIL, NIL], binary !      MStream.Error => IF code = fileNotAvailable THEN GOTO fna ELSE REJECT];    EXITS fna => {LogErrLineBadFile[outFile]; DsyControl.FatalError};    END;  OpenFbSort: PUBLIC PROCEDURE RETURNS [p: LONG POINTER] =    BEGIN    fbHandle: MFile.Handle;        fbHandle ¬ MFile.Acquire[      name: ReplaceExt[outFile, "fb"], access: readWrite, release: [NIL, NIL]];    IF (fbFileSize ¬ MFile.GetLength[fbHandle]) = 0 THEN {MFile.Release[fbHandle];       RETURN};    fbSeg ¬ MSegment.Create[file: fbHandle, release: [NIL, NIL]];    p ¬ MSegment.Address[segment: fbSeg];    END;  OpenFt: PUBLIC PROCEDURE =    BEGIN    ftStream ¬ MStream.WriteOnly[      ReplaceExt[outFile, "ft"], [NIL, NIL], binary !      MStream.Error => IF code = fileNotAvailable THEN GOTO fna ELSE REJECT];    EXITS fna => {LogErrLineBadFile[outFile]; DsyControl.FatalError};    END;  OpenNextDf: PUBLIC PROCEDURE RETURNS [thru: BOOLEAN ¬ FALSE] =    BEGIN    dfName: LONG STRING;    DsyControl.BeginTime ¬ System.GetGreenwichMeanTime[];    IF fIdf = 0 THEN LogLine["Reading Defs Files ..."L]    ELSE {MSegment.Delete[sourceSegment]; sourceSegment ¬ NIL};    IF fIdf = defsFilesCnt THEN RETURN[TRUE];    dfName ¬ defsFileNames[fIdf];    sourceFile ¬ MFile.Acquire[      name: dfName, access: readOnly, release: [NIL, NIL] !      MFile.Error =>        SELECT code FROM	  conflictingAccess, illegalName, protectionFault, noSuchFile => 	    {LogErrLineBadFile[dfName]; GOTO fNA};	  ENDCASE => REJECT];    createTime ¬ MFile.GetCreateDate[file: sourceFile];    defsTimes[fIdf] ¬  System.SecondsSinceEpoch[createTime];    createDate.length ¬ 0;    Time.Append[s: createDate,      unpacked: Time.Unpack[time: createTime],      zone: FALSE];    CreateSourceSegment[dfName];    DsyControl.TtyText2[dfName, "   of "L];    DsyControl.TtyText2[createDate,"  "L];    LogText2[dfName, "   of "L];    LogLine[createDate];    fIdf ¬ fIdf + 1;    EXITS fNA => DsyControl.FatalError;    END;  -- of OpenNextDf proc  OpenNextEb: PUBLIC PROCEDURE RETURNS [thru: BOOLEAN ¬ FALSE] =    BEGIN    sfi: CARDINAL [0..DsyFile.maxNumFiles);    IF fIeb # 0 THEN ebStream ¬ CloseStream[ebStream];    FOR sfi IN [fIeb..sourceFilesCnt) DO      IF importsOnly[sfi] THEN LOOP;      ebStream ¬ MStream.ReadOnly[        ReplaceExt[sourceFileNames[sfi], "eb"], [NIL, NIL]];      fIeb ¬ sfi + 1;      RETURN[FALSE];      REPEAT FINISHED => RETURN[TRUE];      ENDLOOP;    END;  -- of OpenNextEb proc  OpenNextFb: PUBLIC PROCEDURE RETURNS [thru: BOOLEAN ¬ FALSE] =    BEGIN    sfi: CARDINAL [0..DsyFile.maxNumFiles);    IF fIfb # 0 THEN fbInStream ¬ CloseStream[fbInStream];    FOR sfi IN [fIfb..sourceFilesCnt) DO      IF ~importsOnly[sfi] THEN LOOP;      fbInStream ¬ MStream.ReadOnly[        ReplaceExt[sourceFileNames[sfi], "fb"], [NIL, NIL]];      fIfb ¬ sfi + 1;      RETURN[FALSE];      REPEAT FINISHED => RETURN[TRUE];      ENDLOOP;    END;  -- of OpenNextFb proc  OpenNextMc: PUBLIC PROCEDURE RETURNS [thru: BOOLEAN ¬ FALSE] =    BEGIN        sfi: CARDINAL [0..DsyFile.maxNumFiles);    mcTime: LONG CARDINAL;    DsyControl.BeginTime ¬ System.GetGreenwichMeanTime[];    createDate.length ¬ 0;    IF fImc = 0 THEN LogLine["Reading Source Files ..."L]    ELSE {      errorsInFile[fImc - 1] ¬ DsyControl.errorsInThisFile;      ifsInFile[fImc - 1] ¬ DsyControl.ifsInThisFile;      MSegment.Delete[sourceSegment];      sourceSegment ¬ NIL;      mlStream ¬ CloseStream[mlStream];      ebStream ¬ CloseStream[ebStream];      siStream ¬ CloseStream[siStream]};    DsyControl.errorsInThisFile ¬ FALSE;    DsyControl.ifsInThisFile ¬ FALSE;    FOR sfi IN [fImc..sourceFilesCnt) DO      IF passTwoOnly[sfi] OR importsOnly[sfi] THEN LOOP;      String.Copy[currentFile, sourceFileNames[sfi]];      sourceFile ¬ MFile.Acquire[        name: currentFile, access: readOnly, release: [NIL, NIL] !        MFile.Error =>          IF code = noSuchFile OR code = conflictingAccess THEN GOTO fNA          ELSE REJECT];      createTime ¬ MFile.GetCreateDate[file: sourceFile];      mcTime ¬ System.SecondsSinceEpoch[createTime];      IF aFlagSet THEN        IF PresentAndTimely[ReplaceExt[currentFile, "eb"], mcTime]          AND PresentAndTimely[ReplaceExt[currentFile, "ml"], mcTime]          AND PresentAndTimely[ReplaceExt[currentFile, "si"], mcTime]          AND CheckSiProlog[currentFile, mcTime] THEN {          MFile.Release[sourceFile]; sourceFile ¬ NIL; LOOP};      Time.Append[s: createDate,          unpacked: Time.Unpack[time: createTime],	zone: FALSE];      CreateSourceSegment[ReplaceExt[currentFile, "mc"]];      DsyControl.TtyText2[currentFile, "  of "L];      DsyControl.TtyText2[createDate, "  "L];      LogText2[currentFile, "    of "L];      LogLine[createDate];      ebStream ¬ MStream.WriteOnly[        name: ReplaceExt[currentFile, "eb"], release: [NIL, NIL], type: binary !        MStream.Error => IF code = fileNotAvailable THEN GOTO fNA ELSE REJECT];      mlStream ¬ MStream.WriteOnly[        name: ReplaceExt[currentFile, "ml"], release: [NIL, NIL], type: binary !        MStream.Error => IF code = fileNotAvailable THEN GOTO fNA ELSE REJECT];      siStream ¬ MStream.WriteOnly[        name: ReplaceExt[currentFile, "si"], release: [NIL, NIL], type: binary !        MStream.Error => IF code = fileNotAvailable THEN GOTO fNA ELSE REJECT];      WriteSiProlog[mcTime];      fImc ¬ sfi + 1;      RETURN[FALSE];      REPEAT        fNA => {LogErrLineBadFile[currentFile]; DsyControl.FatalError};        FINISHED => RETURN[TRUE];      ENDLOOP;    END;  -- of OpenNextMc proc  OpenNextMl: PUBLIC PROCEDURE RETURNS [thru: BOOLEAN ¬ FALSE] =    BEGIN    sfi: CARDINAL [0..DsyFile.maxNumFiles);    IF fIml # 0 THEN mlStream ¬ CloseStream[mlStream];    FOR sfi IN [fIml..sourceFilesCnt) DO      IF importsOnly[sfi] THEN LOOP;      mlStream ¬ MStream.ReadOnly[        ReplaceExt[sourceFileNames[sfi], "ml"], [NIL, NIL]];      fIml ¬ sfi + 1;      RETURN[FALSE];      REPEAT FINISHED => RETURN[TRUE];      ENDLOOP;    END;  -- of OpenNextMl proc  OpenNextSi: PUBLIC PROCEDURE RETURNS [thru: BOOLEAN ¬ FALSE] =    BEGIN    sfi: CARDINAL [0..DsyFile.maxNumFiles);    IF fIsi = 0 THEN LogLine["Reading SI Files ..."L]    ELSE {      siStream ¬ CloseStream[siStream];      IF ifsInFile[fIsi - 1] THEN        MFile.Delete[          MFile.Acquire[          ReplaceExt[sourceFileNames[fIsi - 1], "si"], delete, [NIL, NIL]]]};    FOR sfi IN [fIsi..sourceFilesCnt) DO      IF importsOnly[sfi] THEN LOOP;      siStream ¬ MStream.ReadOnly[        ReplaceExt[sourceFileNames[sfi], "si"], [NIL, NIL]];      Stream.SetPosition[siStream, siPrologLength];  -- skip siProlog      LogText2[sourceFileNames[sfi], "   "L];      fIsi ¬ sfi + 1;      RETURN[FALSE];      REPEAT FINISHED => RETURN[TRUE];      ENDLOOP;    END;  -- of OpenNextSi proc  OpenStFile: PUBLIC PROCEDURE =    BEGIN    stStream ¬ MStream.ReadWrite[ReplaceExt[outFile, "st"], [NIL, NIL], binary];    END;  -- of OpenStFile proc  ReplaceExt: PUBLIC PROCEDURE [name, ext: LONG STRING] RETURNS [LONG STRING] = {    name.length ¬ name.length - 2; String.AppendString[name, ext]; RETURN[name]};  -- Private Procedures  CheckSiProlog: PROCEDURE [name: LONG STRING, sftime: LONG CARDINAL]    RETURNS [consistent: BOOLEAN ¬ FALSE] =    BEGIN    dfi: CARDINAL [0..DsyFile.maxNumFiles);    nameSink: LONG STRING ¬ [DsyFile.fileNameMaxlenght];    nameBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[@nameSink.text], startIndex: 0, stopIndexPlusOne: 0      -- variable -- ];    sh: MStream.Handle;    timeSink: LONG CARDINAL;    timeBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[LONG[@timeSink]], startIndex: 0,      stopIndexPlusOne: Environment.bytesPerWord*SIZE[LONG CARDINAL]];    versionSink: LONG STRING ¬ [18];    versionBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[@versionSink.text], startIndex: 0, stopIndexPlusOne:       0];    sh ¬ MStream.ReadOnly[name: name, release: [NIL, NIL]];    versionSink.length ¬ versionBlock.stopIndexPlusOne ¬ Stream.GetWord[sh];    IF Stream.GetBlock[sh, versionBlock].why = normal       AND String.EqualStrings[DsyAssembler.version, versionSink]      AND Stream.GetBlock[sh, timeBlock].why = normal AND sftime = timeSink      AND defsFilesCnt = Stream.GetWord[sh] THEN      FOR dfi IN [0..defsFilesCnt) DO        nameSink.length ¬ nameBlock.stopIndexPlusOne ¬ Stream.GetWord[sh];        IF Stream.GetBlock[sh, nameBlock].why # normal          OR Stream.GetBlock[sh, timeBlock].why # normal          OR ~String.EqualStrings[defsFileNames[dfi], nameSink]          OR defsTimes[dfi] # timeSink THEN EXIT;        REPEAT FINISHED => consistent ¬ TRUE;        ENDLOOP;    sh ¬ CloseStream[sh];    END;  -- of CheckSiProlog proc  CreateSourceSegment: PROCEDURE [name: LONG STRING] =    BEGIN    es: LONG STRING ¬ [64];  -- error string    length: LONG CARDINAL ¬ MFile.GetLength[sourceFile];    IF length = 0 THEN {      LogErrText2[name, " of "L];      LogErrLine2[createDate, " is a zero length file."L]; DsyControl.FatalError};    IF Inline.HighHalf[length] # 0 THEN {      LogErrLine2[name, " length > 64k pages."L]; DsyControl.FatalError};    sourceSegment ¬ MSegment.Create[file: sourceFile, release: [NIL, NIL]];    sourceFile ¬ NIL;    DsyModule.ScanInit[MSegment.Address[sourceSegment], Inline.LowHalf[length]];    END;  -- of CreateSourceSegment proc  PresentAndTimely: PROCEDURE [name: LONG STRING, mcTime: LONG CARDINAL]    RETURNS [pat: BOOLEAN ¬ TRUE] =    BEGIN    fh: MFile.Handle;    fh ¬ MFile.Acquire[      name: name, access: readOnly, release: [NIL, NIL] !      MFile.Error =>        IF code = noSuchFile THEN GOTO notPresent        ELSE IF code = conflictingAccess THEN GOTO fNA ELSE REJECT];    pat ¬ mcTime < System.SecondsSinceEpoch[MFile.GetTimes[fh].create];    MFile.Release[fh];    EXITS      notPresent => pat ¬ FALSE;      fNA => {LogErrLineBadFile[name]; DsyControl.FatalError};    END;  -- of PresentAndTimely proc  WriteSiProlog: PROCEDURE [mcTime: LONG CARDINAL] =    BEGIN    dfi: CARDINAL [0..DsyFile.maxNumFiles);    timeSource: LONG CARDINAL;    timeBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[LONG[@timeSource]], startIndex: 0,      stopIndexPlusOne: Environment.bytesPerWord*SIZE[LONG CARDINAL]];    Stream.PutWord[siStream, DsyAssembler.version.length];    Stream.PutString[siStream, DsyAssembler.version];    timeSource ¬ mcTime;    Stream.PutBlock[siStream, timeBlock];    Stream.PutWord[siStream, defsFilesCnt];    FOR dfi IN [0..defsFilesCnt) DO      Stream.PutWord[siStream, defsFileNames[dfi].length];      Stream.PutString[siStream, defsFileNames[dfi]];      timeSource ¬ defsTimes[dfi];      Stream.PutBlock[siStream, timeBlock];      ENDLOOP;    END;  -- of WriteSiProlog proc  END...--Log of last edits:--JAC   	 5-Nov-84 14:19:34	fixed arrows for Mesa 11.1
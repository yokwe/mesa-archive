-- Copyright (C) 1984, 1985 by Xerox Corporation. All rights reserved. -- HBDisplayImpl.mesa-- Written by FS  :  14-Nov-84 17:26:43-- Last edited by --  RDH	21-Jun-85 16:33:13 Add clearHighAddrBits to DisplayIopItem.--  RDH	13-Jun-85 19:05:36 I186* ¬ IOPB* as per FB's changes to IOPBermuda.  Change call to IOPBSymbol.AppendAddress for change to IOPBSymbol interface.--  RDH	17-May-85 13:55:22 Fix IOP heading for symbolic IOP capability.--  RDH	 3-May-85 10:47:35 Catch Runtime.UnboundProcedure on call to I186Symbol.AppendMemoryAddress.--  RDH	22-Apr-85 12:43:42 Add symbolic IOP capability.--  RDH	19-Mar-85 18:26:54 Fix repeat after 44 samples bug.--  RDH	15-Mar-85 10:47:52 Correct spelling error.--  RDH	14-Mar-85 11:42:01 Deal with BadCheckSum when user Reboots IOPBermuda at a bad time.--  RDH	25-Feb-85 11:22:44 Revise to use HBAction instead of Bindweed directly and to use new algorithm which reads whole buffer after trigger.--  RDH	 5-Feb-85 12:18:25 Add time stamping.--  RDH	23-Jan-85 14:52:36 Make minute improvement to data structure.--  RDH	22-Jan-85 13:42:27 Deal with kernel and invalid nia's.--  RDH	21-Jan-85 17:30:33 Introduce names for IO locations.--  RDH	17-Jan-85 11:52:40 Add symbolic output of control store addresses.--  RDH	15-Jan-85 16:38:53 Run FixArrows.DIRECTORY  CPDef,  CPKernelDef,  CPSymbol,  HBAccess,  HBAction,  HBIO,  Heap,  Inline,  I186,  IOPB,  IOPBSymbol,  Put,  Runtime,  String,  Window;HBDisplayImpl: PROGRAM  IMPORTS    CPSymbol, HBAccess, HBAction, HBIO, Heap, Inline, IOPBSymbol, Put,    Runtime, String  EXPORTS  HBIO =     BEGIN    --For slow read when unable to use ReadHistoryBuffer.  triggeredBut: PUBLIC BOOLEAN ¬ FALSE;  lowestCorrect: PUBLIC INTEGER ¬ 1;  highestCorrect: PUBLIC INTEGER ¬ -1;          IopDisplayProc: TYPE = PROC[item: HBIO.IOPSample, position: INTEGER,     outputWindow: Window.Handle];  CsDisplayProc: TYPE = PROC[item: HBIO.CSSample, position: INTEGER,     outputWindow: Window.Handle];    FourWord: TYPE = MACHINE DEPENDENT RECORD [    word0(0): WORD,    word1(1): WORD,    word2(2): WORD,    word3(3): WORD];      IOPDataHandle: TYPE = LONG POINTER TO IOPData;  IOPData: TYPE = MACHINE DEPENDENT RECORD [    content(0): FourWord ¬ [0,0,0,0],    ptr(4): IOPDataHandle ¬ NIL];      TwoWord: TYPE = MACHINE DEPENDENT RECORD [    word0(0): WORD,    word1(1): WORD];      CSDataHandle: TYPE = LONG POINTER TO CSData;  CSData: TYPE = MACHINE DEPENDENT RECORD [    content(0): TwoWord ¬ [0,0],    ptr(2): CSDataHandle ¬ NIL];            IOPSample: TYPE = MACHINE DEPENDENT RECORD [    wildlo(0:0..4): HBIO.IOPWildLo,    status(0:5..7): HBIO.I186Status,    addrhi(0:8..15): HBIO.IOPBusAddrHi,    addrlo(1:0..15): HBIO.IOPBusAddrLo,    arbt(2:0..9): HBIO.BusArb,    wildhi(2:10..11): HBIO.IOPWildHi,    nwait(2:12..15): HBIO.WaitCycles,    iodata(3): HBIO.IOData];    -- Bermuda Kernel Control Store locations. --   BermudaKernel: TYPE = [CPKernelDef.kContinue..0FFFH];    NumForm: TYPE = ARRAY[0..2) OF CARDINAL;  zone: UNCOUNTED ZONE ¬ Heap.systemZone;    maxSymLabelDisplayField: CARDINAL = 24;    BadBankSelect: SIGNAL[badBs: HBIO.HWBankSelect] = CODE;    DHBuffError: ERROR[err: LONG STRING] = CODE;    DisplayIOPHeading: PROCEDURE [wh: Window.Handle] = {    addrHeader: ARRAY[0..2) OF STRING ¬ [      "--------- ADDR --------------------------------"L,       "- ADDR ----------------------"L];    statHeader: ARRAY[0..2) OF STRING ¬ [      "- S --"L, " S -"L];    arbtHeader: ARRAY[0..2) OF STRING ¬ [      "- ARBITOR ---"L, " ARBT "L];    nwaitHeader: ARRAY[0..2) OF STRING ¬ [      "-- NW --"L, "- NW "L];    dataHeader: ARRAY[0..2) OF STRING ¬ [      "------ DATA --------"L, "- DATA -"L];    wildHeader: ARRAY[0..2) OF STRING ¬ [      "--- WC ---"L, " WC -"L];    Put.Text[wh,"- TR --"];    Put.Text[wh,addrHeader[HBIO.globSW.iOPAddrDisp]];    Put.Text[wh,statHeader[HBIO.globSW.iOPStDisp]];    Put.Text[wh,arbtHeader[HBIO.globSW.arbDisp]];    Put.Text[wh,nwaitHeader[HBIO.globSW.nWaitDisp]];    Put.Text[wh,dataHeader[HBIO.globSW.iOPDataDisp]];    Put.Line[wh,wildHeader[HBIO.globSW.iOPWCDisp]]};        --$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$--      DisplayCSHeading: PROCEDURE [wh: Window.Handle] = {    bsHeader: ARRAY[0..2) OF STRING ¬ [      "- BS --"L, " BS "L];    niaHeader: ARRAY[0..2) OF STRING ¬ [      "----- NIA -----"L, "- NIA "L];    labelPlusOffset: STRING = "----- Symbolic NIA -----"L;    wildHeader: ARRAY[0..2) OF STRING ¬ [      "---- Wild Cards ----"L, "-- WC --"L];    Put.Text[wh,"- TR --"];    Put.Text[wh,bsHeader[HBIO.globSW.bSDisp]];    Put.Text[wh,niaHeader[HBIO.globSW.cSNIADisp]];    Put.Text[wh,labelPlusOffset];    Put.Line[wh,wildHeader[HBIO.globSW.cSWCDisp]]};  --$$$$$$$$$$$$$$$$$$$  DoDisplay    $$$$$$$$$$$$$$$$$$$$$--  --Check for access and the sense of doing a display.  Call DisplayFromBuffer to do the displaying and release access.   DoDisplay: PUBLIC PROC[display, heading: Window.Handle,     low, high: INTEGER, target: HBAction.TargetDevice] = BEGIN        --Assume that low and high are already checked and are ok.    --Check on access to display buffer.    IF NOT HBAccess.AskForGeneralAccess[] THEN BEGIN      HBIO.ErrMessage["Sample is going on.  Can't do display."L];      RETURN;      END;    --Check if a sample has been done yet.    IF NOT HBIO.somethingInSWBuffer THEN BEGIN      HBIO.ErrMessage["No sample has taken place.  Displayed data is garbage."L];      END;          --Check that the sampled data has been copied into the display buffer.    IF HBIO.triggeredBut THEN BEGIN      HBAction.ReadWholeBuffer[HBIO.displayBuffer ! HBAction.HBProb => BEGIN        SELECT probType FROM	  bindweedBadCheckSum => {	    HBIO.ErrMessage["Bad Check Sum.  Try running HBSetUp.bermuda in IOPBermuda."L];	    GOTO errorOut;};	  bindweedTimeout => {	    HBIO.ErrMessage["I186 timeout."L];	    GOTO errorOut;};	  ENDCASE => REJECT;	END;];      HBIO.triggeredBut ¬ FALSE;--History buffer successfully filled.      END;	              --Display the heading.    SELECT target FROM      iop => DisplayIOPHeading[heading];      cs => DisplayCSHeading[heading];      ENDCASE;          --Display the time stamp and trigger info.    DisplayTimeAndTrigger[display, HBIO.timeAndTrig];    DisplayFromBuffer[low: low, high: high, target: target, window: display !      HBIO.HBErr => NULL;];    Put.CR[display];    Put.CR[display];    HBAccess.ReleaseHB[];    EXITS      errorOut => HBAccess.ReleaseHB[];    END;--DoDisplay--       --$$$$$$$$$$$$$$$$$$$  DisplayFromBuffer    $$$$$$$$$$$$$$$$$$$$$--  --Display the samples taken from low to high inclusive where low and high are the offsets in samples from the trigger point.  All the samples are already copied from history buffer memory into HBIO.displayBuffer.  The display buffer is a little bit bigger than history buffer memory due to the size of a history buffer block not dividing the history buffer memory size evenly.  This means that samples starting with the trigger and shortly thereafter are in both the last and the first block.     DisplayFromBuffer: PROC[low, high: INTEGER, target: HBAction.TargetDevice,    window: Window.Handle] = BEGIN    wordIndexInSWBuffer: CARDINAL;    wordsInSWBuffer: CARDINAL = HBAction.swBufferBlockSize *      HBAction.numBlocksInSwBuffer;    wordIndexInBlock: HBAction.WordIndexInBufferBlock;    blockNumber: HBAction.HBBlockIndex;    itemsInBlockToDo: [0..HBAction.swBufferBlockSize];    wordsPerItem: CARDINAL = SELECT target FROM      cs => HBAction.wordsPerCSSample,      ENDCASE --iop-- => HBAction.wordsPerIOPSample;    itemsPerBlock: CARDINAL = SELECT target FROM      cs => HBAction.swBufferBlockSize/HBAction.wordsPerCSSample,      ENDCASE --iop-- => HBAction.swBufferBlockSize/HBAction.wordsPerIOPSample;    nItems: CARDINAL ¬ (high - low) + 1;        --Compute the block number, the word index in the block, and the number of remaining items to be displayed in the block of the block with low in it.    SELECT low FROM      >= 0 => { wordIndexInSWBuffer ¬ (low*wordsPerItem); };      < 0  => { wordIndexInSWBuffer ¬ (HBAction.wordsInHBMemory +        (low*wordsPerItem)) MOD wordsInSWBuffer; };      ENDCASE;    blockNumber ¬ wordIndexInSWBuffer/HBAction.swBufferBlockSize;    wordIndexInBlock ¬ wordIndexInSWBuffer MOD HBAction.swBufferBlockSize;    itemsInBlockToDo ¬ itemsPerBlock - (wordIndexInBlock/wordsPerItem);        --Call DisplayItemsFromBlock to display either the rest of the items in the block or all the remaining items to be done whichever is smaller.  If there are more items to be done than there are items left in the block, make a tail recursive call to finish up.    IF itemsInBlockToDo >= nItems THEN BEGIN      DisplayItemsFromBlock[block: HBIO.displayBuffer[blockNumber],        firstWordToBeDisplayed: wordIndexInBlock, numItems: nItems,        posRelativeToTrigger: low, target: target, window: window];      END ELSE BEGIN      DisplayItemsFromBlock[block: HBIO.displayBuffer[blockNumber],        firstWordToBeDisplayed: wordIndexInBlock, numItems: itemsInBlockToDo,        posRelativeToTrigger: low, target: target, window: window];      DisplayFromBuffer[low: low+itemsInBlockToDo, high: high, target: target,        window: window];      END;           END;--DisplayFromBuffer--       --$$$$$$$$$$$$$$$$$$$$    DisplayItemsFromBlock    $$$$$$$$$$$$$$$--  --Get a display proc.  Take words from the displayBuffer and pass them to the display proc for interpretation.  After each item check for user abort.  Since this proc is called from a recursive proc raise a signal rather than simply return when user abort is detected.    DisplayItemsFromBlock: PROC[block: HBAction.HistoryBufferBlock,    firstWordToBeDisplayed: HBAction.WordIndexInBufferBlock,     numItems: [0..HBAction.swBufferBlockSize], posRelativeToTrigger: INTEGER,    target: HBAction.TargetDevice, window: Window.Handle] = BEGIN        wordIndex:      [FIRST[HBAction.WordIndexInBufferBlock]..      LAST[HBAction.WordIndexInBufferBlock]+1] ¬ firstWordToBeDisplayed;      --wordIndex really should be a HBAction.WordIndexInBufferBlock but it needs to equal the upper bound at the end of the loop on the last iteration.    iopItem: HBIO.IOPSample;    csItem: HBIO.CSSample;    iopDispProc: IopDisplayProc;     csDispProc: CsDisplayProc;        SELECT target FROM      iop => {iopDispProc ¬ GetIopDisplayProc[];};      cs => {csDispProc ¬ GetCsDisplayProc[];};      ENDCASE;       FOR i: HBAction.ItemIndexInBlock IN [0..numItems) DO      SELECT target FROM        iop => BEGIN	  --Copy 4 words into iopItem	  iopItem.word0 ¬ block[wordIndex];	  iopItem.word1 ¬ block[wordIndex+1];	  iopItem.word2 ¬ block[wordIndex+2];	  iopItem.word3 ¬ block[wordIndex+3];	  wordIndex ¬ wordIndex + 4;	  iopDispProc[item: iopItem, position: posRelativeToTrigger+i,	    outputWindow: window];	  END;	cs => BEGIN	  --Copy 2 words into csItem	  csItem.word0 ¬ block[wordIndex];	  csItem.word1 ¬ block[wordIndex+1];	  wordIndex ¬ wordIndex + 2;	  csDispProc[item: csItem, position: posRelativeToTrigger+i,	    outputWindow: window];	  END;	ENDCASE;      --Check for abort.      IF HBIO.Aborted[] THEN BEGIN        HBIO.ErrMessage["Display aborted."L];	SIGNAL HBIO.HBErr[userAbort];	END;      ENDLOOP;    END;--DisplayItemsFromBlock--              --$$$$$$$$$$$$$$$$$$$$$   GetIopDisplayProc   $$$$$$$$$$$$$$$$$$$$$$--  GetIopDisplayProc: PROC[] RETURNS[IopDisplayProc] = BEGIN    RETURN[DisplayIopItem];    END;--GetIopDisplayProc--            --$$$$$$$$$$$$$$$$$$$$$   GetCsDisplayProc   $$$$$$$$$$$$$$$$$$$$$$--  GetCsDisplayProc: PROC[] RETURNS[CsDisplayProc] = BEGIN    RETURN[DisplayDaisyCsItem];    END;--GetCsDisplayProc--                   --$$$$$$$$$$$$$$$$$$$$$   DisplayIopItem   $$$$$$$$$$$$$$$$$$$$$$--  DisplayIopItem: IopDisplayProc    --PROC[item: HBIO.IOPSample, position: INTEGER, outputWindow: Window.Handle]--    = BEGIN       sp: ARRAY[0..8) OF NumForm ¬ [      [8,2], [16,4], [3,1], [10,3], [4,1], [16,4], [2,1], [5,2]];       nf: NumForm ¬ [2, 16];    clearHighAddrBitsMask: I186.Address = 0FFFFFH;    iopAddrHighBitsMask: HBIO.IOPBusAddrHi = 0F0H;    maxLen: CARDINAL = 100;    label: LONG STRING ¬ [maxLen];    addrStringFieldWidth: CARDINAL = 20;    processor: IOPB.Processor;          Put.Text[outputWindow, "\N "L];    SELECT position FROM      >0 => {Put.Text[outputWindow, "+"L]; Put.Number[outputWindow, position, [16,TRUE,FALSE,3]]};      <0 => {Put.Number[outputWindow, position, [16,TRUE,FALSE,4]]}      ENDCASE => {Put.Text[outputWindow, "TRIG"L]};    Put.Text[outputWindow,"   "L];        Put.Number[outputWindow, item.addrhi, [nf[HBIO.globSW.iOPAddrDisp],TRUE,TRUE,      sp[0][HBIO.globSW.iOPAddrDisp]]];    Put.Number[outputWindow, item.addrlo, [nf[HBIO.globSW.iOPAddrDisp],TRUE,TRUE,      sp[1][HBIO.globSW.iOPAddrDisp]]];    Put.Text[outputWindow,"   "L];        --Add the label plus offset of the address.    IF item.status = 4 --If it's an instruction fetch--  THEN BEGIN      instrAddr: I186.Address;      instrAddr ¬ Inline.DBITAND[GetAddrFromIOPSampleItem[item],        clearHighAddrBitsMask];      SELECT Inline.BITAND[item.addrhi, iopAddrHighBitsMask] FROM         0F0H => processor ¬ iop;	0E0H => processor ¬ pc;	ENDCASE => { 	  String.AppendString[label, "Strange address"L]; 	  GOTO Leave;	  };      IOPBSymbol.AppendAddress[s: label, addr: instrAddr,         processor: processor ! Runtime.UnboundProcedure => CONTINUE;];      EXITS        Leave => NULL;      END;          PutStringInSpace[label, addrStringFieldWidth, outputWindow];                Put.Number[outputWindow, item.status, [nf[HBIO.globSW.iOPStDisp],TRUE,TRUE,      sp[2][HBIO.globSW.iOPStDisp]]];    Put.Text[outputWindow,"   "L];    Put.Number[outputWindow, item.arbt, [nf[HBIO.globSW.arbDisp],TRUE,TRUE,      sp[3][HBIO.globSW.arbDisp]]];    Put.Text[outputWindow,"    "L];    IF (item.nwait < 2) THEN BEGIN      IF HBIO.globSW.nWaitDisp = 0 THEN BEGIN         Put.Text[outputWindow,"????"L];        END ELSE BEGIN 	Put.Text[outputWindow,"?"L];        END;      END ELSE BEGIN      Put.Number[outputWindow, (item.nwait - 2), [nf[HBIO.globSW.nWaitDisp],TRUE,TRUE,        sp[4][HBIO.globSW.nWaitDisp]]];      END;    Put.Text[outputWindow,"    "L];    Put.Number[outputWindow, item.iodata, [nf[HBIO.globSW.iOPDataDisp],TRUE,TRUE,      sp[5][HBIO.globSW.iOPDataDisp]]];    Put.Text[outputWindow,"   "L];    Put.Number[outputWindow, item.wildhi, [nf[HBIO.globSW.iOPWCDisp],TRUE,TRUE,      sp[6][HBIO.globSW.iOPWCDisp]]];    Put.Text[outputWindow,"  "L];    Put.Number[outputWindow, item.wildlo, [nf[HBIO.globSW.iOPWCDisp],TRUE,TRUE,      sp[7][HBIO.globSW.iOPWCDisp]]];    SELECT  item.status FROM      0 => {Put.Text[outputWindow,"    Intr. ACK"L]};      1 => {Put.Text[outputWindow,"    Read I/O"L]};      2 => {Put.Text[outputWindow,"    Write I/O"L]};      3 => {Put.Text[outputWindow,"    Halt"L]};      4 => {Put.Text[outputWindow,"    Instr. Fetch"L]};      5 => {Put.Text[outputWindow,"    Read Memory"L]};      6 => {Put.Text[outputWindow,"    Write Memory"L]};      7 => {Put.Text[outputWindow,"    Passive"L]};      ENDCASE => {Put.Text[outputWindow,"   Unknown case Software Error"L]};    END;--DisplayIopItem--			        --$$$$$$$$$$$$$$$$$$$$$   DisplayDaisyCsItem   $$$$$$$$$$$$$$$$$$$$$$--  DisplayDaisyCsItem: CsDisplayProc     --PROC[item: HBIO.CSSample, position: INTEGER,--    --outputWindow: Window.Handle]--    = BEGIN      sp: ARRAY[0..6) OF NumForm ¬ [      [4,1], [12,3], [4,1], [4,1], [4,1], [4,1]];    nf: NumForm ¬ [2, 16];    Put.Text[outputWindow, "\N "L];    --Display the position relative to the trigger.    SELECT position FROM      >0 => BEGIN	Put.Text[outputWindow, "+"L]; 	Put.Number[outputWindow, position, [16,TRUE,FALSE,3]];        END;      <0 => BEGIN        Put.Number[outputWindow, position, [16,TRUE,FALSE,4]];        END;      =0 => Put.Text[outputWindow, "TRIG"L];      ENDCASE;    Put.Text[outputWindow,"   "L];    Put.Number[outputWindow, item.banksel, [nf[HBIO.globSW.bSDisp], TRUE,      TRUE, sp[0][HBIO.globSW.bSDisp]]];    Put.Text[outputWindow,"   "L];    Put.Number[outputWindow, item.nia, [nf[HBIO.globSW.cSNIADisp],TRUE,TRUE,      sp[1][HBIO.globSW.cSNIADisp]]];    Put.Text[outputWindow,"   "L];        -- Get the symbolic form of the nia.  label + offset.     BEGIN        ENABLE BadBankSelect => {         IF badBs = HBIO.NoBank THEN Put.Text[outputWindow, "No bank selected.   "L]          ELSE Put.Text[outputWindow, "Too many banks selected."L];        CONTINUE;};      	ellipsis: LONG STRING ¬ ".."L;	ellipsisLength: CARDINAL = String.Length[ellipsis];	symLabelTailLength: CARDINAL = 5;	symLabelLeaveOutLength: CARDINAL = symLabelTailLength + ellipsisLength;	symLabelFirstPartLength: CARDINAL = maxSymLabelDisplayField -           symLabelLeaveOutLength;	baseSubStr, tailSubStr: String.SubStringDescriptor;	labelPlusOffsetLen: CARDINAL;      virtCS: CPSymbol.VirturalCS;	realCS: CPDef.RealCS;	symbolicCSAddr: LONG STRING ¬ [80];      realCS ¬ MakeRealCS[bs: item.banksel, addr: item.nia];      [virtCS, , ] ¬ CPSymbol.RealToVirturalCS[realCS];	IF virtCS # CPSymbol.nullVirturalCS THEN BEGIN          CPSymbol.AppendVirturalCS[symbolicCSAddr, virtCS];        END ELSE IF item.nia IN BermudaKernel THEN BEGIN	  String.AppendString[symbolicCSAddr, "In Kernel"L];        END ELSE BEGIN	  String.AppendString[symbolicCSAddr, "Invalid CS location"L];        END;            --If the string is too long, print the beginning and the ending.--	labelPlusOffsetLen ¬ String.Length[symbolicCSAddr];	SELECT labelPlusOffsetLen FROM          IN [0..maxSymLabelDisplayField] => BEGIN             Put.Text[outputWindow, symbolicCSAddr];            Put.Blanks[outputWindow, maxSymLabelDisplayField -            String.Length[symbolicCSAddr]];              END;          >maxSymLabelDisplayField => BEGIN             baseSubStr ¬ [symbolicCSAddr, 0, symLabelFirstPartLength];            Put.SubString[outputWindow, @baseSubStr];              Put.Text[outputWindow, ellipsis];            tailSubStr ¬ [symbolicCSAddr, labelPlusOffsetLen - symLabelTailLength,              symLabelTailLength];            Put.SubString[outputWindow, @tailSubStr];	    END;        ENDCASE => ERROR DHBuffError["Negative String Length"L];        END;    Put.Text[outputWindow," "L];    Put.Number[outputWindow, item.wildcard.wild0, [nf[HBIO.globSW.cSWCDisp],TRUE,TRUE,      sp[2][HBIO.globSW.cSWCDisp]]];    Put.Text[outputWindow," "L];    Put.Number[outputWindow, item.wildcard.wild1, [nf[HBIO.globSW.cSWCDisp],TRUE,TRUE,      sp[3][HBIO.globSW.cSWCDisp]]];    Put.Text[outputWindow," "L];    Put.Number[outputWindow, item.wildcard.wild2, [nf[HBIO.globSW.cSWCDisp],TRUE,TRUE,      sp[4][HBIO.globSW.cSWCDisp]]];    Put.Text[outputWindow," "L];    Put.Number[outputWindow, item.wildcard.wild3, [nf[HBIO.globSW.cSWCDisp],TRUE,TRUE,      sp[5][HBIO.globSW.cSWCDisp]]];    END;--DisplayDaisyCsItem--              --$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$--  DisplayTimeAndTrigger: PROC[wh: Window.Handle, timeEtc: HBIO.TimeAndTrigger] =    BEGIN    Put.Line[wh, timeEtc.time];    Put.Text[wh, "Sample of "L];    WITH time: timeEtc SELECT FROM      cs => BEGIN        Put.Text[wh, "Daisy Control Store"L];	WITH time SELECT FROM	  TRUE => BEGIN	    Put.Line[wh, " using symbolic input."L];	    Put.Text[wh, "nia	"L];	    Put.Line[wh, nia];	    Put.Text[wh, "wildCards	"L];	    Put.Line[wh, wildCards];	    END;	  FALSE => BEGIN	    Put.Line[wh, " using hex input."L];	    Put.Text[wh, "nia	"L];	    Put.Line[wh, nia];	    Put.Text[wh, "bankSel	"L];	    Put.Line[wh, bankSel];	    Put.Text[wh, "wildCards	"L];	    Put.Line[wh, wildCards];	    END;	  ENDCASE;	END;      iop => BEGIN        Put.Line[wh, "IOP info"L];	Put.Text[wh, "address	"L];	Put.Line[wh, time.addr];	Put.Text[wh, "data	"L];	Put.Line[wh, time.data];	Put.Text[wh, "arbiter	"L];	Put.Line[wh, time.arbiter];	Put.Text[wh, "i186state	"L];	Put.Line[wh, time.i186state];	Put.Text[wh, "nWaits	"L];	Put.Line[wh, time.nWaits];	Put.Text[wh, "wildCards	"L];	Put.Line[wh, time.wildCards];	END;      ENDCASE;    Put.Text[wh, "Delay	"L];    Put.Line[wh, HBIO.timeAndTrig.delay];    Put.CR[wh];    END;--DisplayTimeAndTrigger--  --$$$$$$$$$$$$$$$$$$$$$$$$$$   MakeRealCS   $$$$$$$$$$$$$$$$$$$$$$$$$$$--  --Form a 14 bit CPDef.RealCS from HWBankSelect(4 bits active low) and an address   in a bank.--    MakeRealCS: PROC[bs: HBIO.HWBankSelect, addr: HBIO.WordInCSBank] RETURNS     [realCS: CPDef.RealCS] = BEGIN    realCS ¬ addr + (BankSelectEncode[bs] * CPDef.wordsPerBank);    END;  --MakeRealCS--   --$$$$$$$$$$$$$$$$$$$  BankSelectEncode  $$$$$$$$$$$$$$$$$$$$$$$$$--  -- Convert HWBankSelect to BankNumber --  -- bit 0 = 0 implies bank 0 selected. --  -- If none or more than one bank is selected, raise a signal. --  BankSelectEncode: PROC[bs: HBIO.HWBankSelect] RETURNS [bankNumber: HBIO.BankNumber] =    BEGIN    SELECT bs FROM      0EH => bankNumber ¬ 0;      0DH => bankNumber ¬ 1;      0BH => bankNumber ¬ 2;      7 => bankNumber ¬ 3;      ENDCASE => SIGNAL BadBankSelect[bs];    END; --BankSelectEncode--        --$$$$$$$$$$$$$$$$$$$  PutStringInSpace  $$$$$$$$$$$$$$$$$$$$$$$$$--  --Write the given string into the given window.  If the string is shorter or the same as the given space then add spaces to fill the difference.  If it is longer than the given space, leave off the end and put in an ellipsis to show that it is incomplete.  PutStringInSpace: PROC[string: LONG STRING, space: CARDINAL, window: Window.Handle] = BEGIN    substr: String.SubStringDescriptor;    SELECT String.Length[string] FROM      = 0  => BEGIN        Put.Blanks[window, space];	RETURN;	END;      <= space  => BEGIN        Put.Text[window, string];	Put.Blanks[window, space - String.Length[string]];	RETURN;	END;      > space  => BEGIN        substr.base ¬ string;	substr.offset ¬ 0;	substr.length ¬ space-2;	Put.SubString[window, @substr];	Put.Text[window, ".."L];	RETURN;	END;      ENDCASE;    END;--PutStringInSpace--        	--$$$$$$$$$$$$$$$$$$$  GetAddrFromIOPSampleItem  $$$$$$$$$$$$$$$$$$$$$$$$$--  --Convert the two cardinal fields of the address in the item into a long whose actual type is I186.Address.  GetAddrFromIOPSampleItem: PROC[item: HBIO.IOPSample] RETURNS [I186.Address] =    BEGIN    Converter: TYPE = MACHINE DEPENDENT RECORD[    varRec(0: 0..31): SELECT OVERLAID * FROM      i186 => [addr(0: 0..31): I186.Address],      item => [addrLo(0: 0..15): CARDINAL, addrHi(1: 0..15): CARDINAL],      ENDCASE];    convert: Converter;    convert.addrLo ¬ item.addrlo;    convert.addrHi ¬ item.addrhi;    RETURN[convert.addr];    END; --GetAddrFromIOPSampleItem--       END.    
-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. --File: DsyMemoryImpl.mesa--This module does the error checking for memory cycles--Last edit by JAC   	21-May-85 15:42:36DIRECTORY  Heap USING [MakeNode],  DsyAssembler,   DsyLabel,  DsyModule;DsyMemoryImpl: PROGRAM IMPORTS Heap, DsyAssembler, DsyLabel EXPORTS DsyModule =  BEGIN OPEN DsyAssembler, DsyLabel;  CheckAFile: PUBLIC PROCEDURE [    eP: EncodingPtr, thisMI: LabelEntryPtr, fromMI: LabelEntryPtr,    thisLabel, toLabel: LabelListPtr] =    BEGIN    <<Illegal references to the same A register are as follows:    A.page ¬ mumble;    RBusDest ¬ A.low;        AND        [A.low | A.high] ¬ mumble;    RBusDest ¬ A.page;        AND        [A.page | A.low | A.high] ¬ mumble;    MAR ¬ [A], [Read | Write | DoubleWrite | DoubleRead];        AND        [A.low] ¬ mumble;    MAR ¬ [MD, A], [Read | Write | DoubleWrite | DoubleRead];        AND        ABusDest ¬ mumble;    MDR ¬ ABusDest;        CIP ¬ mumble;  writes low byte of NIB    RBusDest ¬ NIB.low        [A.page] ¬ mumble;    RBusDest ¬ A.low + offset, OffsetAdder;        [A.low] ¬ mumble;    RBusDest ¬ A.low + offset, OffsetAdder;        CIP ¬ mumble;    MAR ¬ [NIB], [Read | Write | DoubleWrite | DoubleRead];        CIP ¬ mumble;    RBusDest ¬ NIB.low + offset, OffsetAdder;>>    CheckPrevDest: PROCEDURE [destPtr: DestPtr] = INLINE      BEGIN      UNTIL destPtr = NIL DO        FindErrors[destPtr.dest, reference, oldok, TRUE, mdr, usesMD, offsetAdder];        destPtr ¬ destPtr.next;        ENDLOOP;      END;  --of procedure CheckPrevDest    FindErrors: PROCEDURE [      destination, reference: ArgumentType,      oldok, jumped, isMDR, usesMD, offsetAdderUsed: BOOLEAN] =      BEGIN      IF destination.regType = aUpper16 AND reference.regType = aLower16        AND destination.arg = reference.arg AND NOT oldok THEN {        IF jumped THEN AFileError[illegalJumpReference]        ELSE AFileError[illegalReference]};      IF destination.regType = aLower16 AND reference.regType = aUpper16        AND destination.arg = reference.arg AND NOT oldok THEN {        IF jumped THEN AFileError[illegalJumpReference]        ELSE AFileError[illegalReference]};      IF destination.regType = aUpper8 AND reference.regType = aUpper16        AND destination.arg = reference.arg AND NOT oldok THEN {        IF jumped THEN AFileError[illegalJumpReference]        ELSE AFileError[illegalReference]};      IF destination.regType IN [aUpper8..aLower16] AND reference.regType = A        AND destination.arg = reference.arg AND NOT oldok AND NOT usesMD THEN {        IF jumped THEN AFileError[illegalJumpReference]        ELSE AFileError[illegalReference]};      IF destination.regType = aLower16 AND reference.regType = A        AND destination.arg = reference.arg AND NOT oldok AND usesMD THEN {        IF jumped THEN AFileError[illegalJumpReference]        ELSE AFileError[illegalReference]};      IF (destination = reference) AND isMDR AND (NOT reference = nullReference)        THEN {        IF jumped THEN AFileError[illegalJumpSource]        ELSE AFileError[illegalSource]};      IF destination.regType = CIP AND reference.regType = aLower16        AND reference.arg = 0 THEN {        IF jumped THEN AFileError[illegalJumpReference]        ELSE AFileError[illegalReference]};      IF destination.regType = aLower16 AND offsetAdderUsed         AND NOT oldok AND destination.arg = reference.arg THEN {        IF jumped THEN AFileError[illegalJumpReference]        ELSE AFileError[illegalReference]};      IF destination.regType = CIP AND reference.regType = A        AND reference.arg = 0 AND NOT oldok THEN {        IF jumped THEN AFileError[illegalJumpReference]        ELSE AFileError[illegalReference]};      END;  --of procedure FindErrors    nullReference: ArgumentType = ArgumentType[];    ptr: LabelListPtr;    refPtr: ArgReferencePtr;    usesMD: BOOLEAN ¬ thisMI.usesMD      OR (memory AND (eP.mo.value = moU OR eP.mo.value = moDoubleU));    IF eP.op.value # 2 THEN reference ¬ GetrAField[eP.rA.value]    ELSE      IF memory THEN reference ¬ ArgumentType[eP.aAdr.value, A]      ELSE        IF offsetAdder AND aFile THEN reference ¬ ArgumentType[eP.aAdr.value, aLower16]        ELSE {  --assume ABus ¬          reference ¬ ArgumentType[eP.aAdr.value, D]};    IF immLastDestField THEN      IF thisMI.destination = NIL THEN        FindErrors[fromDest, reference, oldok, FALSE, mdr, usesMD, offsetAdder]      ELSE {        FindErrors[fromDest, reference, oldok, FALSE, mdr, usesMD, offsetAdder];        CheckPrevDest[thisMI.destination]}    ELSE {  --if not immLastDestField then must have an at or label so check destination record already set up if seen before      IF thisMI.destination # NIL THEN CheckPrevDest[thisMI.destination]};    IF thisLabel # NIL THEN SaveReference[thisMI, reference, oldok];  --saves reference on file not in the thisMI of DsyLabel.    ptr ¬ toLabel;    UNTIL ptr = NIL DO  --may process errors multiple times since for each label on the current MI this code is gone through      IF ptr.label.ptr.found OR ptr.label.ptr.incons THEN {        refPtr ¬ ptr.label.ptr.referenced;        UNTIL refPtr = NIL DO          FindErrors[            destination, refPtr.reference, refPtr.oldok, TRUE,            ptr.label.ptr.isCycle = 2            AND ptr.label.ptr.memStatus IN [write..doubleWrite],            ptr.label.ptr.usesMD,	    ptr.label.ptr.usedOffsetAdder];          refPtr ¬ refPtr.next;          ENDLOOP}      ELSE SaveDestination[ptr.label.ptr, destination];      IF ptr.label.ptr.incons THEN SaveDestination[ptr.label.ptr, destination];      ptr ¬ ptr.next;      ENDLOOP;    END;  --of procedure CheckAFile  CheckFromPrevious: PROCEDURE [    eP: EncodingPtr, fromMI: LabelEntryPtr, thisMI: LabelEntryPtr] =    --the previous MI in the file will be executed before this one i.e. the previous MI did not jump elsewhere.  make sure the correct thing happens in this MI    BEGIN    SELECT fromMI.memStatus FROM      singleRead =>        BEGIN        thisMI.needsCycle ¬ (fromMI.needsCycle + 1) MOD 4;        IF fromMI.needsCycle = cycle3 THEN SetUpPresent[eP, thisMI]        ELSE {          thisMI.memStatus ¬ fromMI.memStatus;          CheckStatus[thisMI.needsCycle, fromMI.memStatus, eP, thisMI]};        END;      singleWrite =>        BEGIN        thisMI.needsCycle ¬ (fromMI.needsCycle + 1) MOD 4;        IF fromMI.needsCycle = cycle3 THEN SetUpPresent[eP, thisMI]        ELSE {          thisMI.memStatus ¬ fromMI.memStatus;          CheckStatus[thisMI.needsCycle, thisMI.memStatus, eP, thisMI]};        END;      doubleRead =>        BEGIN        thisMI.needsCycle ¬ (fromMI.needsCycle + 1) MOD 5;        IF fromMI.needsCycle = cycle4 THEN SetUpPresent[eP, thisMI]        ELSE {          thisMI.memStatus ¬ fromMI.memStatus;          CheckStatus[thisMI.needsCycle, thisMI.memStatus, eP, thisMI]};        END;      doubleWrite =>        BEGIN        thisMI.needsCycle ¬ (fromMI.needsCycle + 1) MOD 5;        IF fromMI.needsCycle = cycle4 THEN SetUpPresent[eP, thisMI]        ELSE {          thisMI.memStatus ¬ fromMI.memStatus;          CheckStatus[thisMI.needsCycle, thisMI.memStatus, eP, thisMI]};        END;      read =>        IF fromMI.needsCycle = cycle3 THEN          IF thisMI.isCycle = cycle4 THEN {            thisMI.memStatus ¬ doubleRead;            thisMI.needsCycle ¬ cycle4;            CheckStatus[thisMI.needsCycle, thisMI.memStatus, eP, thisMI];            IF lastLabel.ptr.isCycle # 0 THEN              lastLabel.ptr.memStatus ¬ thisMI.memStatus            ELSE MemoryError[cycleConflict]}          ELSE {            IF thisMI.isCycle IN [cycle0..cycle1] THEN {              SetUpPresent[eP, thisMI];              fromMI.memStatus ¬ singleRead;              IF lastLabel.ptr.isCycle # 0 THEN                lastLabel.ptr.memStatus ¬ fromMI.memStatus}            ELSE MemoryError[cycleConflict]}        ELSE {          thisMI.memStatus ¬ fromMI.memStatus;	  IF (fromMI.needsCycle + 1) > 4 THEN	    MemoryError[cycleConflict]          ELSE thisMI.needsCycle ¬ fromMI.needsCycle + 1;          CheckStatus[thisMI.needsCycle, thisMI.memStatus, eP, thisMI]};      write =>        IF fromMI.needsCycle = cycle3 THEN          IF thisMI.isCycle = cycle4 THEN {            thisMI.memStatus ¬ doubleWrite;            thisMI.needsCycle ¬ cycle4;            CheckStatus[thisMI.needsCycle, thisMI.memStatus, eP, thisMI];            IF lastLabel.ptr.isCycle # 0 THEN              lastLabel.ptr.memStatus ¬ thisMI.memStatus            ELSE MemoryError[cycleConflict]}          ELSE {            IF thisMI.isCycle IN [cycle0..cycle1] THEN {              SetUpPresent[eP, thisMI];              fromMI.memStatus ¬ singleWrite;              IF lastLabel.ptr.isCycle # 0 THEN                lastLabel.ptr.memStatus ¬ fromMI.memStatus}            ELSE MemoryError[cycleConflict]}        ELSE {          thisMI.memStatus ¬ fromMI.memStatus;	  IF (fromMI.needsCycle + 1) > 4 THEN	    MemoryError[cycleConflict]          ELSE thisMI.needsCycle ¬ fromMI.needsCycle + 1;          CheckStatus[thisMI.needsCycle, thisMI.memStatus, eP, thisMI]};      none => SetUpPresent[eP, thisMI];      ENDCASE;    END;  --of procedure CheckFromPrevious  CheckMemory: PUBLIC PROCEDURE [    eP: EncodingPtr, fromMI: LabelEntryPtr, thisMI: LabelEntryPtr] =    <<Possible memory cycle instruction configuration:1)  series of instructions    MAR ¬ [mumble], c1;  {fromMI is valid}    series of instructions    2)  MAR ¬ [mumble], c1;  Label: mumble, c2;  {fromMI is valid}    series of instructions    mumble, GOTO[label];  {must check to see that jump into memory cycle is OK}    3)  mumble, GOTO[label1];  label2: MAR ¬ [mumble], c1;  {fromMI is not valid}    series of instructions    GOTO[label2];  {must check to see that jump into memory cycle is OK}    4)  GOTO[label1];  label2: mumble, c2;  {fromMI is not valid}    series of instructions    mumble, GOTO[label2];  {must check to see that jump into memory cycle is OK}    A forward jump into label is also possible in each case.5)  MAR ¬ [mumble], c1, GOTO[label];    series of instructions  label: mumble, c2;  {must set up LabelRec so that memory cycle can be checked when label is found}>>    BEGIN    getsMDu: BOOLEAN ¬ (eP.sp2.value = sp2USource) OR (eP.ib.value = ibUReg);    getsMDv: BOOLEAN ¬ (eP.sp2.value = sp2VSource) OR (eP.ib.value = ibVReg);    memStatus: MemStatus;    start: BOOLEAN;    thisMI.isCycle ¬ eP.cycle.value;    IF immLastDestField THEN  --cases 1 and 2      IF (thisMI.memStatus = none) AND NOT thisMI.jumpFromEnd THEN  --either not seen or not jumped to from memory cycle        IF NOT fromCycleOK THEN CheckFromPrevious[eP, fromMI, thisMI]        ELSE {          [start, memStatus] ¬ StartMemory[eP];          IF start THEN {            thisMI.needsCycle ¬ cycle1;            thisMI.memStatus ¬ memStatus;            IF memory THEN {              IF NOT cycleTypeSpecified THEN MemoryError[needsMARType];              IF thisMI.isCycle # cycle1 THEN MemoryError[needsCycle]}            ELSE {thisMI.memStatus ¬ none; thisMI.needsCycle ¬ cycle0}}          ELSE            IF mdr THEN              IF thisMI.isCycle = cycle2 THEN {                thisMI.memStatus ¬ write; thisMI.needsCycle ¬ cycle2}              ELSE                IF thisMI.isCycle = cycle3 THEN {                  thisMI.memStatus ¬ doubleWrite; thisMI.needsCycle ¬ cycle3}                ELSE MemoryError[noMDR]            ELSE              IF getsMDu THEN                IF thisMI.isCycle = cycle3 THEN {                  thisMI.memStatus ¬ read; thisMI.needsCycle ¬ cycle3}                ELSE {                  IF thisMI.isCycle = cycle4 THEN {                    thisMI.memStatus ¬ doubleRead; thisMI.needsCycle ¬ cycle4}}              ELSE                IF getsMDv THEN                  IF thisMI.isCycle = cycle3 THEN {                    thisMI.memStatus ¬ read; thisMI.needsCycle ¬ cycle3}                  ELSE {                    IF thisMI.isCycle = cycle4 THEN {                      thisMI.memStatus ¬ doubleRead; thisMI.needsCycle ¬ cycle4}}                ELSE                  SELECT thisMI.isCycle FROM                    cycle0 => {                      thisMI.memStatus ¬ none; thisMI.needsCycle ¬ cycle0};                    cycle2 => {                      thisMI.memStatus ¬ read; thisMI.needsCycle ¬ cycle2};                    cycle3 => {                      thisMI.memStatus ¬ write; thisMI.needsCycle ¬ cycle3};                    cycle4 => {                      thisMI.memStatus ¬ doubleRead; thisMI.needsCycle ¬ cycle4};                    ENDCASE => MemoryError[cycleIllegalHere]}      ELSE {  --label jumped to from previus memory cycle or an at with label has been seen before        IF NOT fromCycleOK THEN {          CompareFromAndJump[thisMI, fromMI];          CheckFromPrevious[eP, fromMI, thisMI]}        ELSE CheckStatus[thisMI.needsCycle, thisMI.memStatus, eP, thisMI]}    ELSE {  --cases 3 and 4      IF (thisMI.memStatus = none) AND NOT thisMI.jumpFromEnd THEN {  --either not seen or not jumped to from a memory cycle        [start, memStatus] ¬ StartMemory[eP];        IF start THEN {          thisMI.needsCycle ¬ cycle1;          thisMI.memStatus ¬ memStatus;          IF memory THEN {            IF NOT cycleTypeSpecified THEN MemoryError[needsMARType];            IF thisMI.isCycle # cycle1 THEN MemoryError[needsCycle]}          ELSE {thisMI.memStatus ¬ none; thisMI.needsCycle ¬ cycle0}}        ELSE          IF mdr THEN            IF hasLabel THEN              IF thisMI.isCycle = cycle2 THEN {                thisMI.memStatus ¬ write; thisMI.needsCycle ¬ cycle2}              ELSE                IF thisMI.isCycle = cycle3 THEN {                  thisMI.memStatus ¬ doubleWrite; thisMI.needsCycle ¬ cycle3}                ELSE MemoryError[noMDR]            ELSE MemoryError[cycleIllegalHere]          ELSE            IF getsMDu THEN              IF hasLabel THEN                IF thisMI.isCycle = cycle3 THEN {                  thisMI.memStatus ¬ read; thisMI.needsCycle ¬ cycle3}                ELSE {                  IF thisMI.isCycle = cycle4 THEN {                    thisMI.memStatus ¬ doubleRead; thisMI.needsCycle ¬ cycle4}}              ELSE {IF thisMI.isCycle # 0 THEN MemoryError[cycleIllegalHere]}            ELSE              IF getsMDv THEN                IF hasLabel THEN                  IF thisMI.isCycle = cycle3 THEN {                    thisMI.memStatus ¬ read; thisMI.needsCycle ¬ cycle3}                  ELSE {                    IF thisMI.isCycle = cycle4 THEN {                      thisMI.memStatus ¬ doubleRead; thisMI.needsCycle ¬ cycle4}}                ELSE {IF thisMI.isCycle # 0 THEN MemoryError[cycleIllegalHere]}              ELSE                IF hasLabel THEN                  SELECT thisMI.isCycle FROM                    cycle0 => {                      thisMI.memStatus ¬ none; thisMI.needsCycle ¬ cycle0};                    cycle2 => {                      thisMI.memStatus ¬ read; thisMI.needsCycle ¬ cycle2};                    cycle3 => {                      thisMI.memStatus ¬ write; thisMI.needsCycle ¬ cycle3};                    cycle4 => {                      thisMI.memStatus ¬ doubleRead; thisMI.needsCycle ¬ cycle4};                    ENDCASE => MemoryError[cycleIllegalHere]                ELSE IF thisMI.isCycle # 0 THEN MemoryError[cycleIllegalHere]}      ELSE {  --label jumped to from previous memory cycle or an at with label has been seen before         IF          (thisMI.needsCycle = 4            AND (thisMI.memStatus = read OR thisMI.memStatus = write))          AND (thisMI.isCycle < 2) THEN {          thisMI.memStatus ¬ none;          thisMI.needsCycle ¬ 0;          thisMI.jumpFromEnd ¬ TRUE};        CheckStatus[thisMI.needsCycle, thisMI.memStatus, eP, thisMI]}};    END;  --of procedure CheckMemory  CheckStatus: PROCEDURE [    --see if what's expected in the memory cycle occurs    needsCycle: Cycle, memStatus: MemStatus, eP: EncodingPtr,    thisMI: LabelEntryPtr] =    BEGIN    getsMDu: BOOLEAN ¬ (eP.sp2.value = sp2USource) OR (eP.ib.value = ibUReg);    getsMDv: BOOLEAN ¬ (eP.sp2.value = sp2VSource) OR (eP.ib.value = ibVReg);    start: BOOLEAN;    startStatus: MemStatus;    [start, startStatus] ¬ StartMemory[eP];    SELECT memStatus FROM      singleRead =>        IF (needsCycle = cycle2) AND (getsMDu OR getsMDv) THEN          MemoryError[dataNotAvailable];      singleWrite =>        IF (needsCycle = cycle2) AND (NOT mdr) THEN MemoryError[noMDR];      doubleWrite =>        IF ((needsCycle = cycle2) OR (needsCycle = cycle3)) AND (NOT mdr) THEN          MemoryError[noMDR];      doubleRead =>        IF ((needsCycle = cycle2) AND getsMDu)          OR ((needsCycle = cycle3) AND getsMDv) THEN          MemoryError[dataNotAvailable];      ENDCASE;    IF needsCycle # 0 THEN {      IF thisMI.isCycle # needsCycle THEN MemoryError[cycleConflict]}    ELSE      IF (thisMI.isCycle # 0) AND (immLastDestField OR (NOT hasLabel)) THEN        MemoryError[cycleIllegalHere];    IF start THEN {      IF needsCycle # cycle0 THEN MemoryError[illegalStart]      ELSE SetUpPresent[eP, thisMI]};    IF mdr      AND NOT        ((needsCycle = cycle2 OR needsCycle = cycle3)          AND thisMI.memStatus IN [write..doubleWrite]) THEN      MemoryError[mdrIllegal];    END;  --of procedure CheckStatus  CompareFromAndJump: PROCEDURE [thisMI: LabelEntryPtr, fromMI: LabelEntryPtr] =    --make sure that the previous instruction and the instruction which jumps to this MI are looking for the same memory cycle type and cycle number    BEGIN    DO      SELECT thisMI.needsCycle FROM        cycle0 =>          BEGIN          IF (fromMI.needsCycle # cycle0)            AND NOT (fromMI.needsCycle = 3 AND fromMI.memStatus IN [read..singleRead])            AND NOT (fromMI.needsCycle = 3 AND fromMI.memStatus IN [write..singleWrite])            AND NOT (fromMI.needsCycle = 4 AND fromMI.memStatus = doubleRead)            AND NOT (fromMI.needsCycle = 4 AND fromMI.memStatus = doubleWrite) THEN            MemoryError[fromCycleError];          EXIT;          END;        cycle1 =>          BEGIN          IF fromMI.needsCycle # cycle0 THEN MemoryError[fromCycleError];          EXIT;          END;        cycle2 =>          BEGIN          IF fromMI.needsCycle # cycle1 THEN MemoryError[jumpCycleConflict]          ELSE            IF thisMI.memStatus # fromMI.memStatus THEN              IF thisMI.memStatus = read OR thisMI.memStatus = write THEN                thisMI.memStatus ¬ fromMI.memStatus              ELSE MemoryError[fromTypeConflict];          EXIT;          END;        cycle3 =>          BEGIN          IF fromMI.needsCycle # cycle2 THEN MemoryError[fromCycleError]          ELSE            IF fromMI.memStatus # thisMI.memStatus THEN              IF                (fromMI.memStatus = read                  AND                    (thisMI.memStatus = singleRead                      OR thisMI.memStatus = doubleRead))                OR                  (fromMI.memStatus = write                    AND                      (thisMI.memStatus = singleWrite                        OR thisMI.memStatus = doubleWrite)) THEN                fromMI.memStatus ¬ thisMI.memStatus              ELSE                IF                  (thisMI.memStatus = read                    AND                      (fromMI.memStatus = singleRead                        OR fromMI.memStatus = doubleRead))                  OR                    (thisMI.memStatus = write                      AND                        (fromMI.memStatus = singleWrite                          OR fromMI.memStatus = doubleWrite)) THEN                  thisMI.memStatus ¬ fromMI.memStatus;          -- ELSE MemoryError[fromTypeConflict]; ignore c3 memory type conflicts as the wrong type may have been guessed previously          EXIT;          END;        cycle4 =>          BEGIN          IF fromMI.needsCycle # cycle3 THEN            IF thisMI.memStatus = read OR thisMI.memStatus = write THEN {              thisMI.memStatus ¬ none; thisMI.needsCycle ¬ 0; LOOP}            ELSE MemoryError[fromCycleError]          ELSE            IF thisMI.memStatus # fromMI.memStatus THEN              IF (thisMI.memStatus = write AND fromMI.memStatus = doubleWrite)                OR (thisMI.memStatus = read AND fromMI.memStatus = doubleRead) 		THEN                thisMI.memStatus ¬ fromMI.memStatus              ELSE                IF (fromMI.memStatus = write AND thisMI.memStatus = doubleWrite)                  OR (fromMI.memStatus = read AND thisMI.memStatus = doubleRead)                  THEN fromMI.memStatus ¬ thisMI.memStatus                ELSE 		  IF (thisMI.memStatus = write AND fromMI.memStatus = singleWrite)		    OR (thisMI.memStatus = read AND fromMI.memStatus = singleRead) THEN {		    thisMI.memStatus ¬ none; thisMI.needsCycle ¬ 0; LOOP}		  ELSE MemoryError[fromTypeConflict];          EXIT;          END;        ENDCASE;      ENDLOOP    END;  --of procedure CompareFromAndJump  SaveDestination: PROCEDURE [current: LabelEntryPtr, destination: ArgumentType] =    --save the current destination    BEGIN    ptr: DestPtr;    destPtr: DestPtr ¬ Heap.MakeNode[LTtempHeap, SIZE[DestReference]];    destPtr.dest ¬ destination;    ptr ¬ current.destination;    current.destination ¬ destPtr;    destPtr.next ¬ ptr;    END;  --of procedure SaveDestination  SaveReference: PROCEDURE [    currentMI: LabelEntryPtr, ref: ArgumentType, oldok: BOOLEAN] =    --save the register number and type of A file reference if any and if MI had a LOOPHOLE[OldAReg]    BEGIN    ptr: ArgReferencePtr;    refPtr: ArgReferencePtr ¬ Heap.MakeNode[LTtempHeap, SIZE[ArgReference]];    refPtr.reference ¬ ref;    refPtr.oldok ¬ oldok;    ptr ¬ currentMI.referenced;    currentMI.referenced ¬ refPtr;    refPtr.next ¬ ptr;    END;  --of procedure SaveReference  SetUpMemStatus: PUBLIC PROCEDURE [    thisMI: LabelEntryPtr, atLabel: HashEntryPtr, thisLabel: LabelListPtr,    newAtEntry: BOOLEAN] =    BEGIN    IF atLabel # NIL THEN      IF atLabel.ptr.needsCycle > 1 THEN {        thisMI.memStatus ¬ atLabel.ptr.memStatus;        thisMI.needsCycle ¬ atLabel.ptr.needsCycle};    IF thisLabel # NIL THEN      IF atLabel = NIL OR newAtEntry THEN {        thisMI.memStatus ¬ thisLabel.label.ptr.memStatus;        thisMI.needsCycle ¬ thisLabel.label.ptr.needsCycle}      ELSE        IF thisLabel.label.ptr.target > 0          AND NOT thisLabel.label.ptr.alwaysJumpFromCycleOK THEN          SELECT thisMI.needsCycle FROM            cycle0 =>              IF thisLabel.label.ptr.needsCycle # cycle0 THEN                MemoryError[atCycleError];            cycle1 =>              IF thisLabel.label.ptr.needsCycle # cycle0 THEN                MemoryError[atCycleError];            cycle2 =>              IF thisLabel.label.ptr.needsCycle # cycle2 THEN                MemoryError[atCycleError]              ELSE                IF thisMI.memStatus # thisLabel.label.ptr.memStatus THEN                  IF thisMI.memStatus = read OR thisMI.memStatus = write THEN                    thisMI.memStatus ¬ thisLabel.label.ptr.memStatus                  ELSE MemoryError[atTypeConflict];            cycle3 =>              IF thisLabel.label.ptr.needsCycle # cycle3 THEN                MemoryError[atCycleError]              ELSE                IF thisMI.memStatus # thisLabel.label.ptr.memStatus THEN                  IF                    (thisMI.memStatus = write                      AND                        (thisLabel.label.ptr.memStatus = singleWrite                          OR thisLabel.label.ptr.memStatus = doubleWrite))                    OR                      (thisMI.memStatus = read                        AND                          (thisLabel.label.ptr.memStatus = singleRead                            OR thisLabel.label.ptr.memStatus = doubleRead)) THEN                    thisMI.memStatus ¬ thisLabel.label.ptr.memStatus                  ELSE                    IF                      (thisLabel.label.ptr.memStatus = write                        AND                          (thisMI.memStatus = singleWrite                            OR thisMI.memStatus = doubleWrite))                      OR                        (thisLabel.label.ptr.memStatus = read                          AND                            (thisMI.memStatus = singleRead                              OR thisMI.memStatus = doubleRead)) THEN                      thisLabel.label.ptr.memStatus ¬ thisMI.memStatus                    ELSE MemoryError[atTypeConflict];            cycle4 =>              IF thisLabel.label.ptr.needsCycle # cycle3 THEN                MemoryError[atCycleError]              ELSE                IF thisMI.memStatus # thisLabel.label.ptr.memStatus THEN                  IF                    (thisMI.memStatus = write                      AND thisLabel.label.ptr.memStatus = doubleWrite)                    OR                      (thisMI.memStatus = read                        AND thisLabel.label.ptr.memStatus = doubleRead) THEN                    thisMI.memStatus ¬ thisLabel.label.ptr.memStatus                  ELSE                    IF                      (thisLabel.label.ptr.memStatus = write                        AND thisMI.memStatus = doubleWrite)                      OR                        (thisLabel.label.ptr.memStatus = read                          AND thisMI.memStatus = doubleRead) THEN                      thisLabel.label.ptr.memStatus ¬ thisMI.memStatus                    ELSE MemoryError[atTypeConflict];            ENDCASE;    END;  --of procedure SetUpMemStatus  StartMemory: PROCEDURE [eP: EncodingPtr]    RETURNS [start: BOOLEAN ¬ FALSE, memStatus: MemStatus] =    --see if memory cycle is started    BEGIN    memStatus ¬      SELECT TRUE FROM        (eP.mo.value = moA) AND (eP.it.value = itDoNotInhibit) => singleRead,        (eP.mo.value = moA) AND (eP.it.value = itInhibit) => singleWrite,        (eP.mo.value = moMap) AND (eP.it.value = itDoNotInhibit) => singleRead,        (eP.mo.value = moMap) AND (eP.it.value = itInhibit) => singleWrite,        (eP.mo.value = moU) AND (eP.it.value = itDoNotInhibit) => singleRead,        (eP.mo.value = moU) AND (eP.it.value = itInhibit) => singleWrite,        (eP.mo.value = moDoubleRead) AND (eP.it.value = itDoNotInhibit) =>          doubleRead,        (eP.mo.value = moDoubleRead) AND (eP.it.value = itInhibit) => doubleWrite,        (eP.mo.value = moDoubleU) AND (eP.it.value = itDoNotInhibit) => doubleRead,        (eP.mo.value = moDoubleU) AND (eP.it.value = itInhibit) => doubleWrite,        ENDCASE => none;    IF memStatus # none THEN start ¬ TRUE;    END;  --of procedure StartMemory  SetUpPresent: PROCEDURE [eP: EncodingPtr, thisMI: LabelEntryPtr] =    --only called if its ok for memory cycle to be started    BEGIN    memStatus: MemStatus;    start: BOOLEAN;    [start, memStatus] ¬ StartMemory[eP];    SELECT thisMI.isCycle FROM      0 =>        IF start AND memory THEN {          thisMI.needsCycle ¬ 1;          thisMI.memStatus ¬ memStatus;          MemoryError[needsCycle]}        ELSE {thisMI.memStatus ¬ none; thisMI.needsCycle ¬ 0};      1 =>        BEGIN        IF NOT start THEN MemoryError[cycleIllegalHere]        ELSE thisMI.memStatus ¬ memStatus;        IF memory AND NOT cycleTypeSpecified THEN MemoryError[needsMARType];        thisMI.needsCycle ¬ 1;        END;      ENDCASE => MemoryError[cycleIllegalHere];    END;  --of procedure SetUpPresent  END...  --Last edit by JAC   	15-Aug-84 11:01:24	in CompareFromAndJump when thisMI.needsCycle = cycle0 and fromMI.needsCycle = cycle3, added the check for read and write.--JAC   	28-Aug-84 18:08:47	in CheckFromPrevious add check for (fromMI.needsCycle + 1) > 4 in case Vespers gets so confused it tries to assign 5 to thisMI.needsCycle--JAC   	26-Sep-84 11:02:54  	in CompareFromAndJump add last check when thisMI.needsCycle = 4, before givivg up and declaring fromTypeConflict --JAC   	 5-Nov-84 14:21:42	fixed arrows for Mesa 11.1--JAC   	29-Mar-85 10:37:25	in CheckAFile when initializing reference if op = 2 when not memory reference and using offsetAdder make add 'AND aFile' to make sure using don't assume aLower16 when someone one may have used a D register--JAC   	21-May-85 15:46:32	add more illegal A file checking and usedOffsetAdder
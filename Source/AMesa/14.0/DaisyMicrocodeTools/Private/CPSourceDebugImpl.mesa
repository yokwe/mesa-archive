-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. -- Last edit by JAC   		30-Jan-85  9:48:41-- CPSourceDebugImpl.mesa, AYC   ,  5-Nov-84 11:47:14--DIRECTORY  Format USING [Number, NumberFormat, Line, StringProc, Text],  FormSW USING [AllocateItemDescriptor, DisplayItem, StringItem, CommandItem,    ClientItemsProcType, newLine, ProcType, sameLine, ToggleVisibility],  Heap USING [systemZone],  Inline USING [BITAND, BITOR, BITSHIFT, BITXOR, LongCOPY, LowHalf],  Put USING [CR, Line, Text],  Runtime USING [GetBcdTime],  Selection USING [Convert],  String USING [AppendNumber, AppendString, AppendStringAndGrow, CopyToNewString],  TextSW USING [ForceOutput],  Time USING [Append, Unpack],  Tool USING [Create, Destroy, MakeMsgSW, MakeFormSW, MakeFileSW, DefaultHeight,       UnusedLogName],  ToolWindow USING [TransitionProcType],  Version USING [Append],  Window USING [Handle],      CPCommand USING [Error],  CPDef USING [RealCS],  CPKernel USING [Error, WriteCS],  CPKernelOps USING [ReadCSInternal],  CPSourceSymbol USING [ClearSymbolTable, Error, Eval, LoadPrivateSymbols,    LookUpAReg, LookUpCS, LookUpDReg, LookUpRReg, nullRealCS, RealToVirturalCS,    Symbol, VirturalToRealCS],  CPuFormat USING [MI, mi, FormatCommon, FormatThree, FormatTwo, uField],  StringExtras USING [BlankCharacter, TrimString];     CPSourceDebugImpl: PROGRAM    IMPORTS Format, FormSW, Heap, Inline, Put, Runtime, Selection, String,	TextSW, Time, Tool, Version,	CPCommand, CPKernel, CPKernelOps, CPSourceSymbol, CPuFormat, StringExtras    EXPORTS CPCommand =BEGIN     Keys: TYPE = LONG STRING;    ABusDomain: TYPE = [0..63];  BBusDomain: TYPE = [0..3];  RBusDomain: TYPE = [0..63];  ALUDomain: TYPE = [0..15];  SP2Domain: TYPE = [0..7];  SP1Domain: TYPE = [0..7];  BDispDomain: TYPE = [0..15];  MODomain: TYPE = [0..7];  AFileDomain: TYPE = [0..7];  RWDomain: TYPE = [0..1];  ibDomain: TYPE = [0..3];  IBDomain: TYPE = [0..7];  Arrow: STRING = " ¬ "L;  CarryIn: STRING = "1"L;  Comma: STRING = ", "L;  EOL: STRING = "];"L;  Left: STRING = "["L;  Plus: STRING = " + "L;  plusOne: STRING = "+ 1"L;  Right: STRING = "]"L;  Abus: STRING = "Abus"L;  ALU: STRING = "ALU"L;  Bbus: STRING = "Bbus"L;  complement: STRING = "'"L;  Extract: STRING = "EXTRACT["L;  GoTo: STRING = "GOTOABS["L;  high: STRING = ".high"L;  low: STRING = ".low"L;  Map: STRING = "Map ¬ "L;  Mar: STRING = "MAR ¬ "L;  MDu: STRING = "MDu"L;  page: STRING = ".page"L;  pop: STRING = ", pop"L;  push: STRING = ", push"L;  RReg: STRING = ".R"L;  Space: STRING = " "L;    ABusTable: ARRAY ABusDomain OF Keys ¬ [    ".D0"L, ".D1"L, ".D2"L, ".D3"L, ".D4"L, ".D5"L, ".D6"L, ".D7"L,    ".D8"L, ".D9"L, ".DA"L, ".DB"L, ".DC"L, ".DD"L, ".DE"L, ".DF"L,    "0"L, "ChipVersionNumber"L, "csBank"L, "Stkptr"L, "Stk[1]"L, "Stk[0]"L,    "Stk[~1]"L, "Stk[~2]"L, "Stk[1]"L, "Stk[0]"L, "Stk[~1]"L, "Stk[~2]"L,    "Stk[1]"L, "Stk[0]"L, "Stk[~1]"L, "Stk[~2]"L, ".A0.page"L, ".A1.page"L,    ".A2.page"L, ".A3.page"L, ".A4.page"L, ".A5.page"L, ".A6.page"L, ".A7.page"L,    ".A0.low"L, ".A1.low"L, ".A2.low"L, ".A3.low"L, ".A4.low"L, ".A5.low"L,    ".A6.low"L, ".A7.low"L, "CIP"L, "IBCtr"L, "TimerLow"L, "TimerHigh"L,    ""L, ""L, "PreScaler"L, ""L,""L,""L,""L,""L,""L,""L,""L,"RBus"L];      BBusTable: ARRAY BBusDomain OF Keys ¬ [    "0"L, "Q"L, "ib"L, "ibSE"L];      RBusTable: ARRAY ABusDomain OF Keys ¬ [    ".D0"L, ".D1"L, ".D2"L, ".D3"L, ".D4"L, ".D5"L, ".D6"L, ".D7"L,    ".D8"L, ".D9"L, ".DA"L, ".DB"L, ".DC"L, ".DD"L, ".DE"L, ".DF"L,    ""L, ""L, "csBank"L, "Stkptr"L, "Stk[1]"L, "Stk[0]"L, "Stk[~1]"L,    "Stk[~2]"L, ".A0.high"L, ".A1.high"L, ".A2.high"L, ".A3.high"L, ".A4.high"L,    ".A5.high"L, ".A6.high"L, ".A7.high"L,".A0.page"L, ".A1.page"L, ".A2.page"L,    ".A3.page"L, ".A4.page"L, ".A5.page"L, ".A6.page"L, ".A7.page"L, ".A0.low"L,    ".A1.low"L, ".A2.low"L, ".A3.low"L, ".A4.low"L, ".A5.low"L, ".A6.low"L,    ".A7.low"L, "CIP"L, ""L, "TimerLow"L, "TimerHigh"L, ""L, "Q"L,    "PreScaler"L, ""L, ""L, ""L, ""L, ""L, ""L, ""L, ""L, "ALU"L];      ALUTable: ARRAY ALUDomain OF Keys ¬ [    " + "L, " - "L, " - "L, " and "L, " or "L, " xor "L, " + "L, " and "L,    " MPYStep "L, ""L, ""L, " nand "L, " nor "L, " nxor "L, " + "L, " and "L];      SP2Table: ARRAY SP2Domain OF Keys ¬ [    ""L, "SetEOPInt"L, "ClearInterrupts"L, "PopIB"L, MDu, "MDv"L, ""L, ""L];      SP1Table: ARRAY SP1Domain OF Keys ¬ [    ""L, "Q"L, "IncCIP"L, "DIncCIP"L, "L"L, "L"L, "L"L, "L"L];  BDispTable: ARRAY BDispDomain OF Keys ¬ [    "L0Disp"L, "L1Disp"L, "L2Disp"L, "L3Disp", "ADisp"L, "ALUDisp"L, "PCDisp"L,    "ZeroBr"L, ""L, "BDisp", "RDisp", "MIntDisp"L, "AHiDisp"L, "ReadOk",    "WriteOk", "IBDisp"L];      MOType: TYPE = RECORD [RW: ARRAY RWDomain OF Keys, MO: Keys];  MOTable: ARRAY MODomain OF MOType ¬ [    [[""L,""L],""L], [["Read"L, "Write"L], Mar], [["Read"L, "Write"L], Map],    [["Read"L, "Write"L], Mar], [[""L,""L],""L], [["DoubleRead"L, "DoubleWrite"L],    Mar], [[""L,""L],""L], [["DoubleRead"L,"DoubleWrite"L], Mar]];      AfileTable: ARRAY AFileDomain OF Keys ¬ [    ".A0.low"L, ".A1.low"L, ".A2.low"L, ".A3.low"L, ".A4.low"L, ".A5.low"L,    ".A6.low"L, ".A7.low"L];      ibTable: ARRAY ibDomain  OF Keys ¬ [    ""L, "ib"L, "ib.high"L, "ib.low"L];      IBTable: ARRAY IBDomain  OF Keys ¬ [    ""L, "ClrIB"L, "PopIB"L, ""L, "ib ¬ MDu"L, "ib ¬ MDv"L, "ib ¬ MDu, PopIB"L, "ib ¬ MDv, PopIB"L];      fileHandle: TYPE = LONG POINTER TO fileObject;  fileObject: TYPE = RECORD [	value: CARDINAL,	next: fileHandle,	filename: LONG STRING ¬ NIL  ];	  SrcDebugHandle: TYPE = LONG POINTER TO SrcDebugObject;     SrcDebugObject: TYPE = RECORD [   	msgSW: Window.Handle,    	cmdSW: Window.Handle,    	formSW: Window.Handle  ];  SrcDebugData: SrcDebugHandle ¬ NIL;  log: Window.Handle ¬ NIL;  window: Window.Handle ¬ NIL;  WindowHandle: Window.Handle ¬ NIL;  filehead: fileHandle ¬ NIL;  fhandle: fileHandle ¬ NIL;    Addrptr: LONG STRING ¬ NIL;  Dataptr: LONG STRING ¬ NIL;    ABus: STRING = [30];  BBus: STRING = [30];  RBus: STRING = [30];  stack: STRING = [8];  instruction: STRING = [200];  z: UNCOUNTED ZONE = Heap.systemZone;   SytnxError: ERROR [reason: LONG STRING] = CODE;      GetABus: PROCEDURE[text, stkop: LONG STRING, data: WORD] =    BEGIN    text.length ¬ 0;    stkop.length ¬ 0;    SELECT TRUE FROM      data IN [0..15] => {        IF ~CPSourceSymbol.LookUpDReg[text, data] THEN	  String.AppendString[text, ABusTable[data]];	RETURN;	};      data IN [24..27] => String.AppendString[stkop, push];      data IN [28..31] => String.AppendString[stkop, pop];      data IN [32..47] =>        IF CPSourceSymbol.LookUpAReg[text, Inline.BITAND[data,7]] THEN {	  SELECT TRUE FROM	    data IN [32..39] => String.AppendString[text, page];	    data IN [40..47] => String.AppendString[text, low];	    ENDCASE => NULL;	    RETURN;	  }	ENDCASE => NULL;    String.AppendString[text, ABusTable[data]];    END;      GetBBus: PROCEDURE[text: LONG STRING, data: WORD] =    BEGIN    text.length ¬ 0;    IF data < 4 THEN {      String.AppendString[text, BBusTable[data]];      RETURN;      };    IF ~CPSourceSymbol.LookUpRReg[text, data] THEN {      String.AppendString[text, RReg];      String.AppendNumber[text, data, 16];      };    END;  GetRBus: PROCEDURE[text, ABus: LONG STRING, bit54:WORD, bit30:WORD] =    BEGIN    data: WORD ¬ Inline.BITOR[Inline.BITSHIFT[bit54,4], bit30];    text.length ¬ 0;    IF data = 52 THEN {      String.AppendString[text, ABus];      RETURN;      };    SELECT TRUE FROM      data IN [0..15] => {        IF ~CPSourceSymbol.LookUpDReg[text, data] THEN	  String.AppendString[text, ABusTable[data]];	RETURN;	};      data IN [24..47] =>        IF CPSourceSymbol.LookUpAReg[text, Inline.BITAND[data,7]] THEN {	  SELECT TRUE FROM	    data IN [24..31] => String.AppendString[text, high];	    data IN [32..39] => String.AppendString[text, page];	    data IN [40..47] => String.AppendString[text, low];	    ENDCASE => NULL;	    RETURN;	  }       ENDCASE => NULL;    String.AppendString[text, RBusTable[data]];    END;  AppendALU: PROCEDURE[text, ABus, BBus: LONG STRING, data: WORD, cin: BOOLEAN] =    BEGIN    SELECT data FROM      2 => BEGIN	String.AppendString[text, BBus];	String.AppendString[text, ALUTable[data]];	String.AppendString[text, ABus];        IF ~cin THEN {	  String.AppendString[text, ALUTable[data]];	  String.AppendString[text, CarryIn];	  };	RETURN;	END;      6 => BEGIN        String.AppendString[text, ABus];	IF cin THEN {	  String.AppendString[text, ALUTable[data]];	  String.AppendString[text, CarryIn];	  };	IF BBus.length # 0 THEN {	  String.AppendString[text, Comma];	  String.AppendString[text, Bbus];	  String.AppendString[text, Arrow];          String.AppendString[text, BBus];	  };	RETURN;	END;      14 => BEGIN	String.AppendString[text, BBus];	IF cin THEN {	  String.AppendString[text, ALUTable[data]];	  String.AppendString[text, CarryIn];	  };	IF ABus.length # 0 THEN {	  String.AppendString[text, Comma];	  String.AppendString[text, Abus];	  String.AppendString[text, Arrow];          String.AppendString[text, ABus];	  };	RETURN;	END;      ENDCASE;          String.AppendString[text, ABus];    IF data = 15 THEN String.AppendString[text, complement];    String.AppendString[text, ALUTable[data]];    String.AppendString[text, BBus];    IF data = 7 THEN String.AppendString[text, complement];    IF (data = 0 AND cin) OR (data = 1 AND ~cin) THEN	BEGIN	String.AppendString[text, ALUTable[data]];	String.AppendString[text, CarryIn];	RETURN;	END;    END;  AppendSP2: PROCEDURE[text, RBus: LONG STRING, data, sp1: WORD] =    BEGIN    IF data IN [6..7] THEN RETURN;    IF data # 0 THEN BEGIN      String.AppendString[text, Comma];      IF data IN [4..5] THEN {	String.AppendString[text, RBus];	String.AppendString[text, Arrow];	IF sp1 = 1 THEN {          String.AppendString[text, SP1Table[sp1]];          String.AppendString[text, Arrow];	  };	};      String.AppendString[text, SP2Table[data]];      END;    END;  AppendSP1: PROCEDURE[text: LONG STRING, inia, data: WORD] =    BEGIN    IF data ~IN [0..1] THEN BEGIN      String.AppendString[text, Comma];      String.AppendString[text, SP1Table[data]];      IF data IN [4..7] THEN {	String.AppendNumber[text, Inline.BITAND[data, 3], 10];	String.AppendString[text, Arrow];	String.AppendNumber[text, Inline.BITAND[inia, 15], 10];	};      END;    END;      AppendBDisp: PROCEDURE[text: LONG STRING, high, low: WORD] =    BEGIN     data: WORD ¬ Inline.BITOR[Inline.BITSHIFT[high,3], low];     IF data = 8 THEN RETURN;     String.AppendString[text, Comma];     String.AppendString[text, BDispTable[data]];     END;  AppendInia: PROCEDURE[text: LONG STRING, data:WORD] =    BEGIN    Append: Format.StringProc = { String.AppendString[text, s]; };    RealCS: CPDef.RealCS;    String.AppendString[text, Comma];    String.AppendString[text, GoTo];    [RealCS, ,] ¬ CPSourceSymbol.RealToVirturalCS[data];    IF ~CPSourceSymbol.LookUpCS[text, RealCS] THEN      Format.Number[proc: Append, n: data, format: Format.NumberFormat[base: 16, zerofill: TRUE, columns: 4]];    String.AppendString[text, EOL];    END;      AppendExtract: PROCEDURE[text, ABus, BBus: LONG STRING, data: WORD] =    BEGIN    Append: Format.StringProc = { String.AppendString[text, s]; };    String.AppendString[text, Extract];    String.AppendString[text, ABus];    String.AppendString[text, Comma];    String.AppendString[text, BBus];    String.AppendString[text, Comma];    Format.Number[proc: Append, n: data, format: Format.NumberFormat[base: 16, zerofill: TRUE, columns: 2]];    String.AppendString[text, Right];    END;  GetImmediate: PROCEDURE[text: LONG STRING, h: BOOLEAN, lmu, iml: WORD] =    BEGIN    Append: Format.StringProc = { String.AppendString[text, s]; };    data: WORD ¬ Inline.BITOR[Inline.BITSHIFT[lmu, 3], iml];    value: WORD ¬ Inline.BITXOR[data, 255];    text.length ¬ 0;    Format.Number[proc: Append, n: value, format: Format.NumberFormat[base: 16, zerofill: TRUE, columns: 3]];    IF h THEN String.AppendString[text, "00"L];    END;      AppendMO: PROCEDURE[text, rw: LONG STRING, data: WORD, it: BOOLEAN] =    BEGIN    String.AppendString[text, MOTable[data].MO];    String.AppendString[rw, MOTable[data].RW[LOOPHOLE[it]]];    END;      AppendAfile: PROCEDURE[text, ABus, RW: LONG STRING, mo, data: WORD] =    BEGIN    IF mo = 3 OR mo = 7 THEN {      String.AppendString[text, Left];      String.AppendString[text, MDu];      String.AppendString[text, Comma];      }    ELSE IF ABus.length # 0 THEN String.AppendString[text, Left];    IF CPSourceSymbol.LookUpAReg[text, data] THEN	String.AppendString[text, low]    ELSE	String.AppendString[text, AfileTable[data]];    IF ABus.length # 0 THEN {      String.AppendString[text, Plus];      String.AppendString[text, ABus];      String.AppendString[text, Right];      };    IF (mo = 3 OR mo = 7) AND ABus.length = 0 THEN      String.AppendString[text, Right];    IF RW.length # 0 THEN {      String.AppendString[text, Comma];      String.AppendString[text, RW];      };    END;  GetOffset: PROCEDURE[text: LONG STRING, om, aiu, ail: WORD, ac: BOOLEAN] =    BEGIN    Append: Format.StringProc = { String.AppendString[text, s]; };    text.length ¬ 0;    SELECT om FROM      0 => BEGIN        value: WORD ¬ Inline.BITOR[Inline.BITSHIFT[aiu, 3], ail];	value ¬ Inline.BITSHIFT[Inline.BITXOR[value, 127], 1];	value ¬ Inline.BITOR[value, Inline.BITXOR[ac, 1]];	Format.Number[proc: Append, n: value, format: Format.NumberFormat[base: 16, zerofill: TRUE, columns: 3]];	END;      1, 2, 3 => String.AppendString[text, ibTable[om]];      ENDCASE;    END;  AppendIB: PROCEDURE[text: LONG STRING, ib: WORD] =    BEGIN    String.AppendString[instruction, Comma];    String.AppendString[instruction, IBTable[ib]];    END;      AppendNewFileName: PROCEDURE[s: LONG STRING] =    BEGIN    lasthandle: fileHandle ¬ NIL;    hashvalue: CARDINAL ¬ Hash[s];    IF filehead = NIL THEN      BEGIN      filehead ¬ z.NEW[fileObject];      filehead.next ¬ NIL;      filehead.filename ¬ String.CopyToNewString[s, z];      filehead.value ¬ Hash[s];      RETURN;      END;    FOR h: fileHandle ¬ filehead, h.next UNTIL h = NIL DO      IF Hash[h.filename] = hashvalue THEN RETURN;      lasthandle ¬ h;      ENDLOOP;    fhandle ¬ z.NEW[fileObject];    fhandle.next ¬ NIL;    fhandle.filename ¬ String.CopyToNewString[s, z];    fhandle.value ¬ Hash[s];    lasthandle.next ¬ fhandle;    END;  Hash: PROC [s: LONG STRING] RETURNS [c: CARDINAL] = {    one, two: CARDINAL ¬ 0;    c ¬ 0;    FOR i: NATURAL IN [0..s.length) DO      one ¬ one*31 + (s[i] - 0C);      two ¬ two + (s[i] - 0C);      ENDLOOP;    c ¬ Inline.BITXOR[one, two]};  ClearSymbolAndFilename: PROCEDURE =    BEGIN    CPSourceSymbol.ClearSymbolTable[];    UNTIL filehead = NIL DO      fhandle ¬ filehead;      filehead ¬ fhandle.next;      z.FREE[@fhandle];      ENDLOOP;    END;  StringHexToCardinal: PROCEDURE[s: LONG STRING, offset: CARDINAL] RETURNS[value: CARDINAL] =    BEGIN    base: CARDINAL ¬ 16;    value ¬ 0;    FOR i: CARDINAL IN [0..3] DO      IF value*base/base # value THEN RETURN;      SELECT s[i+offset] FROM        IN ['0..'9] => value ¬ value*base + (s[i+offset] - '0);        IN ['A..'F] => value ¬ value*base + (s[i+offset] - 'A + 10);        IN ['a..'f] => value ¬ value*base + (s[i+offset] - 'a + 10);        ENDCASE => ERROR SytnxError["Error: Unknown character"L];      ENDLOOP;  END;    RemoveBlanks: PROCEDURE[s: LONG STRING] RETURNS[CARDINAL] =    BEGIN    i, j: CARDINAL ¬ 0;    IF s.length = 0 THEN RETURN[s.length];    FOR i IN [0..s.length) DO      IF ~StringExtras.BlankCharacter[s[i]] THEN {	s[j] ¬ s[i];	j ¬ j + 1;	};      ENDLOOP;      s.length ¬ j;      RETURN[s.length];    END;      LoadPrivateSymbols: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    filename: LONG STRING ¬ Selection.Convert[string];    BEGIN ENABLE UNWIND => z.FREE[@filename];    CPSourceSymbol.LoadPrivateSymbols[LogWrite, log, filename];    AppendNewFileName[filename];    z.FREE[@filename];    END;    END;  ClearPrivateSymbols: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    BEGIN    ClearSymbolAndFilename[];    END;    END;  FileLoaded: FormSW.ProcType =    BEGIN    IF filehead # NIL THEN {      Put.Line[log, "The following symbol file(s) are loaded:"L];      FOR h: fileHandle ¬ filehead, h.next UNTIL h = NIL DO	Put.Text[log, "    "L];	Put.Line[log, h.filename];	ENDLOOP;	TailMessage["Done"L];	RETURN;      };    PostMessage["No symbol file is loaded."L];    END;      Destroy: FormSW.ProcType =    BEGIN    DestoryWindow[];    END;      SourceDebugDestory: PUBLIC PROCEDURE =    BEGIN    IF window # NIL THEN DestoryWindow[];    END;  DestoryWindow: PROCEDURE =    BEGIN    Tool.Destroy[window];    ClearSymbolAndFilename[];    FormSW.ToggleVisibility[WindowHandle, SourceIx];    window ¬ NIL;    END;      SourceDebugCreate: PUBLIC PROCEDURE[Handle: Window.Handle, SourceDebugIx: CARDINAL] = {    herald: STRING = [100];    String.AppendString[herald, "Sirius Source Debugger (CPBermuda) "L];    Version.Append[herald];    String.AppendString[herald, " of "L];    Time.Append[herald, Time.Unpack[Runtime.GetBcdTime[]]];    WindowHandle ¬ Handle;    SourceIx ¬ SourceDebugIx;    window ¬ Tool.Create[      name: herald,      makeSWsProc: MakeSWs,      clientTransition: ClientTransition,      cmSection: "CS Translator"L,      tinyName1: "CS Translator"L,      tinyName2: NIL,      named:TRUE];  };  WriteControlStore: FormSW.ProcType =    BEGIN ENABLE SytnxError =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    Address: LONG STRING ¬ String.CopyToNewString[Addrptr, z];            BEGIN ENABLE UNWIND => z.FREE[@Address];    symbol: CPSourceSymbol.Symbol;    IF Address = NIL OR Address.length = 0 THEN      ERROR SytnxError["CSAddress required"L];    symbol ¬ CPSourceSymbol.Eval[Address !      CPSourceSymbol.Error => ERROR SytnxError[reason] ];    WITH symbol SELECT FROM      link, rReg, dReg, aReg, map, real, virt, other =>	ERROR SytnxError["Please use main window to update fields"L];      realCS, virtCS => TranslateAndWrite[ExtractRealCS[symbol], TRUE];      ENDCASE => ERROR SytnxError["Bad Control Store Location"L];    z.FREE[@Address];    END;    END;      ExtractRealCS: PROCEDURE [symbol: CPSourceSymbol.Symbol] RETURNS [CPDef.RealCS] =    BEGIN    WITH symbol SELECT FROM      number => RETURN[Inline.LowHalf[n]];      realCS => RETURN[real];      virtCS =>        BEGIN	real: CPDef.RealCS;	[real, , ] ¬ CPSourceSymbol.VirturalToRealCS[virt];	IF real = CPSourceSymbol.nullRealCS THEN	  ERROR SytnxError["Can't translate that address to a .CR"L];	RETURN[real];	END;      ENDCASE;    ERROR SytnxError["Unreasonable source/dest combination"L];    END;  Translate: FormSW.ProcType =    BEGIN ENABLE SytnxError =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    TranslateAndWrite[write: FALSE];    END;  TranslateAndWrite: PROCEDURE [real: CPDef.RealCS ¬ 0, write: BOOLEAN ¬ FALSE] =    BEGIN    string: LONG STRING ¬ Selection.Convert[string];    value: CPSourceSymbol.Symbol;    mi: CPuFormat.mi;        BEGIN ENABLE UNWIND => z.FREE[@string];        PostMessage["Translating "L];    IF string = NIL THEN BEGIN      IF Dataptr = NIL OR Dataptr.length = 0 THEN {        TailMessage["... Error: Selection required"L];        RETURN;	}      ELSE String.AppendStringAndGrow[@string, Dataptr, z];      END;    TailMessage[string];    value ¬ CPSourceSymbol.Eval[string ! CPSourceSymbol.Error => BEGIN      value ¬ [number[0]];      CONTINUE;      END;];    WITH value SELECT FROM      number =>        BEGIN	[] ¬ StringExtras.TrimString[string];        IF RemoveBlanks[string] # 12 THEN	  ERROR SytnxError["Error: Bad Control Store"];	Dataptr.length ¬ 0;	String.AppendStringAndGrow[@Dataptr, string, z];	FormSW.DisplayItem[SrcDebugData.cmdSW, DataIn];        FOR i : CARDINAL IN [0..SIZE[CPuFormat.mi]) DO	  RawCS: CARDINAL ¬ StringHexToCardinal[Dataptr, i*4];	  Inline.LongCOPY[@RawCS, 1, @mi+i];	  ENDLOOP;	END;      realCS =>        BEGIN ENABLE CPKernel.Error => ERROR SytnxError[reason];	mi ¬ LOOPHOLE[CPKernelOps.ReadCSInternal[real], CPuFormat.mi];	END;      virtCS =>        BEGIN ENABLE CPKernel.Error => ERROR SytnxError[reason];	real: CPDef.RealCS;	[real, , ] ¬ CPSourceSymbol.VirturalToRealCS[virt];	IF real = CPSourceSymbol.nullRealCS THEN	  ERROR SytnxError["Error: Invalid virtual address"L];	mi ¬ LOOPHOLE[CPKernelOps.ReadCSInternal[real], CPuFormat.mi];	END;      ENDCASE => ERROR SytnxError["Error: Unknown Symbol"];    Convertmi[LogWrite, log, mi];    IF write THEN CPKernel.WriteCS[real, LOOPHOLE[mi, CPuFormat.MI] ! CPKernel.Error => ERROR SytnxError[reason]];    z.FREE[@string];    END;    END;   Convertmi: PROCEDURE[log: Format.StringProc, arg: LONG POINTER, mi: CPuFormat.mi] =    BEGIN    instruction: CPuFormat.MI ¬ CPuFormat.uField[mi];    SELECT instruction.context.common.opcode FROM      0 => FromZero[LOOPHOLE[instruction, CPuFormat.FormatCommon], log, arg];      1 => FromOne[LOOPHOLE[instruction, CPuFormat.FormatCommon], log, arg];      2 => FromTwo[LOOPHOLE[instruction, CPuFormat.FormatTwo], log, arg];      3 => FromThree[LOOPHOLE[instruction, CPuFormat.FormatThree], log, arg];      ENDCASE;    END;    FromZero: PROCEDURE [Common: CPuFormat.FormatCommon, log: Format.StringProc, arg: LONG POINTER] =    BEGIN    instruction.length ¬ 0;    GetABus[ABus, stack, Common.rA];    GetBBus[BBus, Common.rB];    GetRBus[RBus, BBus, Common.rDBits54, Common.rDBits30];    IF Common.sp2 IN [4..5] THEN      String.AppendString[instruction, ALU]    ELSE BEGIN      String.AppendString[instruction, RBus];      IF Common.sp1 = 1 THEN {        String.AppendString[instruction, Arrow];        String.AppendString[instruction, SP1Table[Common.sp1]];	};      END;    String.AppendString[instruction, Arrow];    AppendALU[instruction, ABus, BBus, Common.AluOrShift, Common.cin];    IF stack.length # 0 THEN String.AppendString[instruction, stack];    AppendSP2[instruction, RBus, Common.sp2, Common.sp1];    AppendSP1[instruction, Common.inia, Common.sp1];    AppendBDisp[instruction, Common.dspBBits33, Common.dspBBits20];    AppendInia[instruction, Common.inia];    Format.Text[log, "Text: "L, arg];    Format.Line[log, instruction, arg];    END;          FromOne: PROCEDURE [Common: CPuFormat.FormatCommon, log: Format.StringProc, arg: LONG POINTER] =    BEGIN    instruction.length ¬ 0;    GetABus[ABus, stack, Common.rA];    GetBBus[BBus, Common.rB];    GetRBus[RBus, BBus, Common.rDBits54, Common.rDBits30];    IF Common.sp2 IN [4..5] THEN      String.AppendString[instruction, ALU]    ELSE BEGIN      String.AppendString[instruction, RBus];      IF Common.sp1 = 1 THEN {        String.AppendString[instruction, Arrow];        String.AppendString[instruction, SP1Table[Common.sp1]];	};      END;    String.AppendString[instruction, Arrow];    AppendExtract[instruction, ABus, BBus, Common.AluOrShift];    IF stack.length # 0 THEN String.AppendString[instruction, stack];    AppendSP2[instruction, RBus, Common.sp2, Common.sp1];    AppendSP1[instruction, Common.inia, Common.sp1];    AppendBDisp[instruction, Common.dspBBits33, Common.dspBBits20];    AppendInia[instruction, Common.inia];    Format.Text[log, "Text: "L, arg];    Format.Line[log, instruction, arg];    END;      FromTwo: PROCEDURE [Two: CPuFormat.FormatTwo, log: Format.StringProc, arg: LONG POINTER] =    BEGIN    RW: STRING = [20];    instruction.length ¬ 0;    AppendMO[instruction, RW, Two.mo, Two.it];    GetRBus[RBus, ABus, Two.rDBits54, Two.rDBits30];    String.AppendString[instruction, RBus];    IF Two.sp1 = 1 THEN {      String.AppendString[instruction, Arrow];      String.AppendString[instruction, SP1Table[Two.sp1]];      };    String.AppendString[instruction, Arrow];    GetOffset[ABus, Two.om, Two.aiu, Two.ail, Two.ac];    AppendAfile[instruction, ABus, RW, Two.mo, Two.aadr];    AppendIB[instruction, Two.ib];    AppendSP1[instruction, Two.inia, Two.sp1];    AppendBDisp[instruction, Two.dspBBits33, Two.dspBBits20];    AppendInia[instruction, Two.inia];    Format.Text[log, "Text: "L, arg];    Format.Line[log, instruction, arg];    END;      FromThree: PROCEDURE [Three: CPuFormat.FormatThree, log: Format.StringProc, arg: LONG POINTER] =    BEGIN    instruction.length ¬ 0;    GetABus[ABus, stack, Three.rA];    GetImmediate[BBus, Three.h, Three.lmu, Three.iml];    GetRBus[RBus, BBus, Three.rDBits54, Three.rDBits30];    String.AppendString[instruction, RBus];    IF Three.sp1 = 1 THEN {      String.AppendString[instruction, Arrow];      String.AppendString[instruction, SP1Table[Three.sp1]];      };    String.AppendString[instruction, Arrow];    AppendALU[instruction, ABus, BBus, Three.alu, Three.cin];    IF stack.length # 0 THEN String.AppendString[instruction, stack];    AppendSP1[instruction, Three.inia, Three.sp1];    AppendBDisp[instruction, Three.dspBBits33, Three.dspBBits20];    AppendInia[instruction, Three.inia];    Format.Text[log, "Text: "L, arg];    Format.Line[log, instruction, arg];    END;     MakeSWs: PROCEDURE [window: Window.Handle] = {    SrcDebugData ¬ SrcDebugSetup[NIL, window, MakeForm];  };  SrcDebugSetup: PROCEDURE [    herald: LONG STRING,    window: Window.Handle,    parameterItemsProc: FormSW.ClientItemsProcType,    makeFormSWaFileSW: BOOLEAN ¬ TRUE,    formSWHeight: INTEGER ¬ Tool.DefaultHeight]    RETURNS [SrcDebugData: SrcDebugHandle] = {     updateLog: STRING ¬ [20];    Tool.UnusedLogName[unused: updateLog, root: "Source.log$"L];    SrcDebugData ¬ Heap.systemZone.NEW[SrcDebugObject];    SrcDebugData­ ¬ SrcDebugObject[      msgSW: Tool.MakeMsgSW[window: window, lines: 4],      cmdSW: Tool.MakeFormSW[window: window, formProc: parameterItemsProc],      formSW: log ¬ Tool.MakeFileSW[window: window, name: updateLog]];  };  AddrIn: CARDINAL = 6;  DataIn: CARDINAL = 7;  SourceIx: CARDINAL ¬ 0;  -- toggle menu entry in main window    MakeForm: FormSW.ClientItemsProcType = {    OPEN FormSW;        items ¬ AllocateItemDescriptor[8];    freeDesc ¬ TRUE;    items[0] ¬ FormSW.CommandItem[tag: "LoadPrivateSymbols"L, place: FormSW.newLine, proc: LoadPrivateSymbols];    items[1] ¬ CommandItem[tag:"ClearPrivateSymbols"L, proc: ClearPrivateSymbols];    items[2] ¬ CommandItem[tag:"FileLoaded"L, proc: FileLoaded];    items[3] ¬ CommandItem[tag:"Destroy"L, place: FormSW.newLine, proc: Destroy];    items[4] ¬ CommandItem[tag:"WriteCS"L, proc: WriteControlStore];    items[5] ¬ FormSW.CommandItem[tag: "Translate"L, proc: Translate];    items[AddrIn] ¬ StringItem[tag:"CSAddress"L, place: FormSW.newLine, string: @Addrptr, inHeap:TRUE];    items[DataIn] ¬ StringItem[tag:"CSData"L, place: [150, sameLine], string: @Dataptr, inHeap:TRUE];    };    ClientTransition: ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      old = inactive =>        BEGIN        END;      new = inactive =>        BEGIN	IF Dataptr # NIL THEN z.FREE[@Dataptr];	IF Addrptr # NIL THEN z.FREE[@Addrptr];	END;      ENDCASE;    END;  LogWrite: Format.StringProc =    BEGIN    Put.Text[clientData, s];    END;  PostMessage: PROCEDURE [s: LONG STRING] =    BEGIN    Put.CR[log];    Put.Text[log, s];    TextSW.ForceOutput[log];    END;  TailMessage: PROCEDURE [s: LONG STRING] =    BEGIN    Put.Text[log, s];    Put.Line[log, "."L];    TextSW.ForceOutput[log];    END;  END...-- Log:-- JAC   	 9-Jan-85 15:46:31	spell virtual correctly-- JAC   	15-Jan-85 14:51:06	change IBTable-- JAC   	30-Jan-85  9:49:05	spell Unknown correctly
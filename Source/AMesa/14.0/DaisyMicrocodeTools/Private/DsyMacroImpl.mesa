-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. --DsyMacroImpl.mesa--Last edit by JAC      1-Apr-85 11:10:46 DIRECTORY   String USING [AppendChar, AppendString, EqualString,  StringBoundsFault, WordsForString],  DsyAssembler USING [    CharOf, ElementRec, EofChar, Flagword, GetStmtSpace, maxStringLength, MEntryPtr,    MyString, MyStringPtr, Phrase, PhrasePtr, PhraseElement, PhraseElementPtr,    RetType, sizeArgArray],  DsyControl USING [argBuf, linkLoad, linkVal, numArgs, statement],  DsyFile USING [    LogErrAndSrcLines, LogErrAndSrcLinesBadChar, LogErrArgAndSrcLines],  DsyLabel USING [ProcessLineLabel],  DsyModule USING [BreakPhraseArg, BreakPhraseMain, FindM, SaveArgs];DsyMacroImpl: PROGRAM  IMPORTS DsyControl, DsyFile, DsyLabel, DsyModule, DsyAssembler, String  EXPORTS DsyModule =  BEGIN  OPEN DsyControl, DsyModule, DsyAssembler;  ExpandArrow: PUBLIC PROCEDURE [flags: Flagword]    RETURNS [peptr: PhraseElementPtr] =    BEGIN    -- Arrow phrase is in argBuf[0..numArgs] .  Phrase must be expanded into a phrase record with a chain of phrase elements.    -- first look-up each syntactic element in the symbol table and build a chain of phrase elements.    invalid: BOOLEAN ¬ FALSE;    i: INTEGER;    mynumArgs: CARDINAL ¬ numArgs;    myS: MyString;    memRef: BOOLEAN ¬ flags.HasArgs;    newpeptr: PhraseElementPtr ¬ NIL;    pe: PhraseElement;    er: ElementRec;    valu: CARDINAL;    mptr: MEntryPtr;    tmptr: MEntryPtr;    ArgArray: ARRAY [0..DsyAssembler.sizeArgArray] OF LONG STRING ¬ ALL[NIL];    SaveArgs[@ArgArray, mynumArgs];    peptr ¬ NIL;    UNTIL ArgArray[mynumArgs].length # 0 DO mynumArgs ¬ mynumArgs - 1 ENDLOOP;    i ¬ mynumArgs;    DO      myS ¬ [0, ArgArray[i]];      er ¬ InterpretArg[BreakPhraseArg[@myS]];            WITH er SELECT FROM        arrow =>          BEGIN          -- try "XX¬" first          IF i = 0 THEN            BEGIN            DsyFile.LogErrAndSrcLines["Leading arrow illegal "L];            invalid ¬ TRUE;            EXIT;            END;          String.AppendChar[ArgArray[i - 1], '¬];          mptr ¬ FindM[ArgArray[i - 1]];          IF mptr = NIL THEN            BEGIN  -- "XX¬" not in ST            ArgArray[i - 1].length ¬ ArgArray[i - 1].length - 1;	    String.AppendString[ArgArray[i], ArgArray[i + 1]];	    mptr ¬ FindM[ArgArray[i]];	    IF mptr = NIL THEN	      BEGIN              newpeptr ¬ GetStmtSpace[SIZE[PhraseElement]];              newpeptr­ ¬ PhraseElement[peptr, ElementRec[arrow[]]];              peptr ¬ newpeptr;	      END	    ELSE peptr­ ¬ PhraseElement[peptr­.nextElement, mptr.ptr­]            END          ELSE            BEGIN  -- "XX¬" is in ST            pe.elementRec ¬ mptr.ptr­;            WITH pe.elementRec SELECT FROM              partialArrow =>  --implies XX¬Y must be in ST or not legal                BEGIN                String.AppendString[ArgArray[i - 1], ArgArray[i + 1]];                mptr ¬ FindM[ArgArray[i - 1]];                IF mptr = NIL THEN                  BEGIN                  DsyFile.LogErrArgAndSrcLines[                    "Unknown macro in arrow clause "L, ArgArray[i - 1]];                  invalid ¬ TRUE;                  END                ELSE                  BEGIN  -- "XX¬Y" is in ST                  peptr­ ¬ PhraseElement[peptr­.nextElement, mptr.ptr­];                  EXIT;                  END;                END;              link =>                BEGIN                valu ¬ 16;                IF peptr = NIL THEN                  BEGIN                  DsyFile.LogErrAndSrcLines["Link value not known"L];                  invalid ¬ TRUE;                  EXIT;                  END;                WITH peptr­.elementRec SELECT FROM                  constant => valu ¬ value;                  variable => valu ¬ val;                  ENDCASE;                IF valu NOT IN [0..15] THEN                  BEGIN                  DsyFile.LogErrAndSrcLines["Link value not in 0 - 15"L];                  invalid ¬ TRUE;                  EXIT;                  END                ELSE BEGIN linkLoad ¬ TRUE; linkVal ¬ valu; END;                peptr­ ¬ PhraseElement[NIL, ElementRec[macro[macroIndex]]];                EXIT;                END;	      macroArrow =>  --XX¬Y does not have to be in ST to be legal	        BEGIN		String.AppendString[ArgArray[i - 1], ArgArray[i + 1]];		tmptr ¬ FindM[ArgArray[i - 1]];		IF tmptr = NIL THEN {		  newpeptr ¬ GetStmtSpace[SIZE[PhraseElement]];		  newpeptr­ ¬ PhraseElement[peptr, ElementRec[macroArrow[macroIndex]]];		peptr ¬ newpeptr}		ELSE  --"XX¬Y" is in ST		  peptr­ ¬ PhraseElement[peptr.nextElement, tmptr.ptr­];		IF (i ¬ i - 2) < 0 THEN EXIT ELSE LOOP;		END;              ENDCASE;            END;	  IF (i ¬ i - 1) < 0 THEN EXIT ELSE LOOP;           END;        variable =>          BEGIN          IF val NOT IN [0..65535] THEN            BEGIN            DsyFile.LogErrAndSrcLines["Invalid variable value not in [0..65535]"L];            er ¬ ElementRec[constant[65535]];            END          ELSE er ¬ ElementRec[constant[val]];          END;        constant =>          IF value NOT IN [0..65535] THEN            BEGIN            DsyFile.LogErrAndSrcLines["Invalid constant value NOT IN [0..65535]"L];            er ¬ ElementRec[constant[65535]];            END;        undefinedToken =>          BEGIN	  DsyFile.LogErrArgAndSrcLines[            "Unknown macro in arrow clause "L, ArgArray[i]];            invalid ¬ TRUE;	  IF (i ¬ i - 1) < 0 THEN EXIT ELSE LOOP;          END;        ENDCASE;      -- token not arrow      IF invalid THEN EXIT;      newpeptr ¬ GetStmtSpace[SIZE[PhraseElement]];      newpeptr­ ¬ PhraseElement[peptr, er];      peptr ¬ newpeptr;      IF (i ¬ i - 1) < 0 THEN EXIT ELSE LOOP;      ENDLOOP;    IF invalid THEN peptr ¬ NIL;        END;  -- end ExpandArrow  ReduceStk: PROCEDURE [inFlags: Flagword] =  --Since brackets cause the numArgs to be advanced stack references are read into argBuf   --as argBuf[i] = STK and argBuf[i+1] = (-|1) and argBuf[i+2] = (1|2),  --this procedures converts it to STK1 STK0 STK-1 STK-2 and reduces the numArgs accordingly    BEGIN        ReduceArgs: PROCEDURE [stkIndex: CARDINAL, below: BOOLEAN] =    BEGIN    i: CARDINAL;    offset: CARDINAL;    IF below THEN {      String.AppendString[argBuf[stkIndex], argBuf[stkIndex + 1]];      String.AppendString[argBuf[stkIndex], argBuf[stkIndex + 2]];      offset ¬ 2}    ELSE {      String.AppendString[argBuf[stkIndex], argBuf[stkIndex + 1]];      offset ¬ 1};    argBuf[stkIndex + 1].length ¬ 0;    FOR i IN [stkIndex + 1..numArgs - offset] DO      String.AppendString[argBuf[i], argBuf[i + offset]];      argBuf[i + 1].length ¬ 0;      ENDLOOP;    numArgs ¬ numArgs - offset;    END;        i: CARDINAL;        i  ¬ 0;    DO      IF String.EqualString[argBuf[i], "STK"L] THEN {        SELECT argBuf[i + 1][0] FROM	  '- => IF argBuf[i + 1].length = 1 THEN 	          IF (argBuf[i + 2][0] = '2) OR (argBuf[i + 2][0] = '1) THEN ReduceArgs[i, TRUE]		  ELSE DsyFile.LogErrAndSrcLines["Illegal stack reference"L]		ELSE DsyFile.LogErrAndSrcLines["Illegal stack reference"L];	  '0 => IF argBuf[i + 1].length = 1 THEN ReduceArgs[i, FALSE]	        ELSE DsyFile.LogErrAndSrcLines["Illegal stack reference"L];	  '1 => IF argBuf[i + 1].length = 1 THEN ReduceArgs[i, FALSE]	        ELSE DsyFile.LogErrAndSrcLines["Illegal stack reference"L];	  ENDCASE => DsyFile.LogErrAndSrcLines["Illegal stack reference"L];        inFlags.HasArgs ¬ FALSE};      IF (i ¬ i + 1) > numArgs THEN EXIT;      ENDLOOP;  END;  -- end ReduceStk      ExpandUserMacroArg: PROCEDURE [ET: userMacro ElementRec, myS: MyStringPtr] =    BEGIN    char: CHARACTER;    val: INTEGER;    argMacroArg: MyString ¬ [0, ET.str];    argMacro: MyStringPtr ¬ @argMacroArg;    myS.String.length ¬ 0;    DO      char ¬ Nextch[argMacro];      SELECT char FROM        '# =>          BEGIN          char ¬ Nextch[argMacro];          IF char NOT IN ['0..'9] THEN DsyFile.LogErrAndSrcLinesBadChar[char];          val ¬ char - '0;          SELECT val FROM            0 => MyAppendChar[myS.String, CharOf[numArgs]];            <= numArgs => MyAppendString[myS.String, argBuf[val]];            ENDCASE;          END;        EofChar => EXIT;        ENDCASE => MyAppendChar[myS.String, char];      ENDLOOP;    END;  -- end ExpandUserMacroArg  ExpandUserMacroMain: PROCEDURE [ET: userMacro ElementRec] =    BEGIN    char: CHARACTER;    val: INTEGER;    str: LONG STRING ¬ [maxStringLength];    argMacroArg: MyString ¬ [0, ET.str];    argMacro: MyStringPtr ¬ @argMacroArg;    tempString: MyString ¬ MyString[0, str];    DO      char ¬ Nextch[argMacro];      SELECT char FROM        '# =>          BEGIN          char ¬ Nextch[argMacro];          IF char NOT IN ['0..'9] THEN DsyFile.LogErrAndSrcLinesBadChar[char];          val ¬ char - '0;          SELECT val FROM            0 => MyAppendChar[str, CharOf[numArgs]];            <= numArgs => MyAppendString[str, argBuf[val]];            ENDCASE;          END;        EofChar => EXIT;        ENDCASE => MyAppendChar[str, char];      ENDLOOP;    MyAppendChar[str, ',];    tempString.NextChar ¬ 0;    UNTIL tempString.String.length <= tempString.NextChar DO      InterpretMain[BreakPhraseMain[@tempString]] ENDLOOP;    END;  -- end ExpandUserMacroMain  IntegerConvert: PROCEDURE [str: LONG STRING] RETURNS [value: CARDINAL] =    BEGIN    val, octVal, decVal, hexVal: CARDINAL ¬ 0;    notOctal, notDecimal: BOOLEAN ¬ FALSE;    i: CARDINAL;    char: CHARACTER;    IntVal: PROCEDURE [char: CHARACTER] RETURNS [value: CARDINAL] =      BEGIN      value ¬        SELECT char FROM          IN ['0..'9] => char - '0,          IN ['a..'f] => (char - 'a) + 10,          IN ['A..'F] => (char - 'A) + 10,          ENDCASE => 0;      END;  -- end IntVal    value ¬ 0;    FOR i IN [0..str.length) DO      char ¬ str[i];      SELECT char FROM        IN ['0..'7] => NULL;        IN ['8..'9] => notOctal ¬ TRUE;        IN ['a..'f], IN ['A..'F] => notOctal ¬ notDecimal ¬ TRUE;        '' =>          BEGIN  -- base will follow prime character          IF i + 2 # str.length THEN {            DsyFile.LogErrAndSrcLines["Number has illegal format, 0 used"L];            RETURN[0];            };          SELECT str[i + 1] FROM            'b, 'B =>              IF notOctal THEN                DsyFile.LogErrAndSrcLines["non-octal character in octal string"L]  -- octal base              ELSE value ¬ octVal;            'd, 'D =>              IF notDecimal THEN                DsyFile.LogErrAndSrcLines[                  "non-decimal character in decimal string"L]  -- decimal base              ELSE value ¬ decVal;            'x, 'X => value ¬ hexVal;  -- hex base            ENDCASE => DsyFile.LogErrAndSrcLines["illegal digit in number"L];          RETURN[value];          END;        ENDCASE => DsyFile.LogErrAndSrcLines["illegal digit in number"L];      val ¬ IntVal[char];      octVal ¬ 8*octVal + val;      decVal ¬ 10*decVal + val;      hexVal ¬ 16*hexVal + val;      ENDLOOP;    RETURN[hexVal];  -- default is hex base    END;  -- end IntegerConvert  InterpretArg: PUBLIC PROCEDURE [inFlags: Flagword]    RETURNS [et: ElementRec] =    -- evaluate an arg or arrow element    BEGIN    ret: RetType;    mptr: MEntryPtr;    str: LONG STRING ¬ [maxStringLength];        myS: MyString;      SELECT TRUE FROM      inFlags.LeadDigit =>        et ¬ ElementRec[constant[IntegerConvert[argBuf[0]]]];       ENDCASE =>        BEGIN	IF inFlags.HasArgs THEN ReduceStk[inFlags];        mptr ¬ FindM[argBuf[0]];        IF mptr = NIL THEN et ¬ ElementRec[undefinedToken[]]        ELSE et ¬ mptr.ptr­;        END;    DO        WITH x: et SELECT FROM        userMacro =>          BEGIN	  str.length ¬ 0;          myS ¬ MyString[0, str];          ExpandUserMacroArg[x, @myS];          et ¬ InterpretArg[BreakPhraseArg[@myS]];          LOOP;          END;        builtinMacro =>          BEGIN                    ret ¬ x.proc[x.type];          WITH ret SELECT FROM            Null => et ¬ ElementRec[empty[]];            Text =>              BEGIN              myS ¬ MyString[0, txt];              et ¬ InterpretArg[BreakPhraseArg[@myS]];              END;            Value => et ¬ ElementRec[constant[val]];            ENDCASE;          LOOP;          END;        ENDCASE => RETURN;      ENDLOOP;    END;  -- end InterpretArg  InterpretMain: PUBLIC PROCEDURE [inFlags: Flagword] =    BEGIN    ChainPhraseRecord: PROCEDURE [peptr: PhraseElementPtr] =      BEGIN      -- create phrase record      pptr: PhrasePtr;      IF peptr = NIL THEN RETURN;      pptr ¬ GetStmtSpace[SIZE[Phrase]];      pptr­ ¬ Phrase[];      pptr­.firstElement ¬ peptr;      -- chain phrase record onto statement record      pptr­.nextPhrase ¬ statement.firstPhrase;      statement.firstPhrase ¬ pptr;      END;  -- end ChainPhraseRecord    er: ElementRec;    mptr: MEntryPtr;    peptr: PhraseElementPtr ¬ NIL;    IF argBuf[0].length = 0 THEN RETURN;    SELECT TRUE FROM      inFlags.ArrowClause =>        BEGIN        IF inFlags.HasArgs THEN ReduceStk[inFlags];        er ¬ ElementRec[arrowPhrase[]];        END;      inFlags.Label => er ¬ ElementRec[label[argBuf[0], 0]];      ENDCASE =>        BEGIN        mptr ¬ FindM[argBuf[0]];        IF mptr = NIL THEN er ¬ ElementRec[undefinedToken[]]        ELSE er ¬ mptr.ptr­;        END;    WITH x: er SELECT FROM      arrowPhrase => peptr ¬ ExpandArrow[inFlags];      userMacro => ExpandUserMacroMain[x];      macro =>        BEGIN        peptr ¬ GetStmtSpace[SIZE[PhraseElement]];        peptr­ ¬ PhraseElement[NIL, x];        END;      builtinMacro => [] ¬ x.proc[x.type];      label => [] ¬ DsyLabel.ProcessLineLabel[x.str];      undefinedToken => {        DsyFile.LogErrArgAndSrcLines["Undefined Macro "L, argBuf[0]]};      ENDCASE => DsyFile.LogErrArgAndSrcLines["Illegal use of "L, argBuf[0]];    ChainPhraseRecord[peptr];    END;  -- end InterpretMain  Nextch: PROCEDURE [myS: MyStringPtr] RETURNS [char: CHARACTER] = INLINE    BEGIN    IF myS.NextChar >= myS.String.length THEN RETURN[EofChar];    char ¬ myS.String[myS.NextChar];    myS.NextChar ¬ myS.NextChar + 1;    END;  -- end Nextch  MyAppendString: PROCEDURE [str, strX: LONG STRING] = INLINE    BEGIN    String.AppendString[      str, strX !      String.StringBoundsFault =>        BEGIN        ns ¬ DsyAssembler.GetStmtSpace[String.WordsForString[str.length + strX.length + 20]];   --get new storage the size of the 2 strings and some extra space	ns­ ¬ [maxlength: str.length + strX.length + 20, length: 0, text: ];        String.AppendString[ns, str];                RESUME [str ¬ ns];        END];    END;  -- end MyAppendString  MyAppendChar: PROCEDURE [str: LONG STRING, char: CHARACTER] = INLINE    BEGIN    String.AppendChar[      str, char !      String.StringBoundsFault =>        BEGIN        ns ¬ DsyAssembler.GetStmtSpace[String.WordsForString[str.length + 20]];	ns­ ¬ [maxlength: str.length + 20, length: 0, text: ];        String.AppendString[ns, str];                RESUME [str ¬ ns];        END];    END;  -- end MyAppendString  END...--Log of last edits:--JAC   	 5-Nov-84 14:20:54	fixed arrows for Mesa 11.1--JAC   	 1-Apr-85 11:10:59	added "DsyFile.LogErrArgAndSrcLines["Illegal use of "L, argBuf[0]]" in InterpretMain to catch cases of registers alone in a phrase
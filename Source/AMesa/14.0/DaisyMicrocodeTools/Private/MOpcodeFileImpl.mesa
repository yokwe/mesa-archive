-- Copyright (C) 1984  by Xerox Corporation. All rights reserved.-- File: MOpcodeFileImpl.mesa-- Author: JAC   		Created: 29-Nov-84 10:12:42-- Last edit by JAC   	11-Dec-84 14:48:51DIRECTORY  Ascii USING [ControlZ, CR],  Exec USING [Handle, OutputProc],  Format USING [Line, Number, NumberFormat, StringProc, Text],  MOpcodeAssembler,  Inline USING [HighHalf, LowHalf],  MFile USING [Acquire, Delete, Error, GetLength, Handle, Release, Rename],  MSegment USING [Address, Create, Delete, Handle],  MStream USING [SetLength, WriteOnly],    Stream USING [Delete, GetPosition, Handle, PutChar, PutString],  String USING [AppendChar, AppendString];MOpcodeFileImpl: PROGRAM  IMPORTS Exec, Format, MOpcodeAssembler, Inline, MFile, MSegment, MStream, Stream, String  EXPORTS MOpcodeAssembler =  BEGIN OPEN MOpcodeAssembler;    curPos: CARDINAL;  dest: LONG STRING ¬ [150];  lstStream: Stream.Handle;  maxPos: CARDINAL;  nextSourceFile: CARDINAL;  opStream: Stream.Handle;  source: LONG POINTER TO PACKED ARRAY [0..0) OF CHARACTER;  sourceSegment: MSegment.Handle;  tty: Format.StringProc;    Append: Format.StringProc =     BEGIN    String.AppendString[dest, s];    END;  --of procedure Append    CloseFiles: PUBLIC PROCEDURE [error: BOOLEAN] =  --close source and all output files    BEGIN    outFile: MFile.Handle;    IF opStream # NIL THEN {      MStream.SetLength[opStream, Stream.GetPosition[opStream]];      Stream.Delete[opStream];      opStream ¬ NIL;      IF NOT error THEN {        outFile ¬ MFile.Acquire[name: ReplaceExt[outputFile, ".tp"], access: rename, release: [NIL, NIL]];	MFile.Rename[file: outFile, newName: ReplaceExt[outputFile, ".op"] !	  MFile.Error => SELECT code FROM	    fileAlreadyExists => 	      BEGIN	      renameFile: MFile.Handle;	      renameFile ¬ MFile.Acquire[name: ReplaceExt[outputFile, ".op"], access: delete, release: [NIL, NIL]];	      MFile.Delete[renameFile];	      RETRY;	      END;  --of catch phrase for fileAlreadyExists	    ENDCASE => REJECT];	MFile.Release[outFile]}      ELSE {        outFile ¬ MFile.Acquire[name: ReplaceExt[outputFile, ".tp"], access: delete, release: [NIL, NIL]];	MFile.Delete[outFile]};      outFile ¬ NIL};    IF lstStream # NIL THEN {      MStream.SetLength[lstStream, Stream.GetPosition[lstStream]];      Stream.Delete[lstStream];      lstStream ¬ NIL};    IF sourceSegment # NIL THEN {      MSegment.Delete[sourceSegment];      sourceSegment ¬ NIL};    END;  --of procedure CloseFiles    GetNextChar: PUBLIC PROCEDURE RETURNS [char: CHARACTER, errorsEncountered: CommentError ¬ none] =  --get next character from input file    BEGIN    braceCount: CARDINAL ¬ 0;     DO  --get character main loop      char ¬ IF curPos >= maxPos THEN eofChar ELSE source[curPos];      curPos ¬ curPos + 1;      SELECT char FROM        Ascii.CR => 	  IF braceCount = 0 THEN RETURN	  ELSE {	    PrintSpaces[23];	    LogSourceLine[]};        eofChar => 	  BEGIN          IF braceCount # 0 THEN errorsEncountered ¬ eof;          RETURN;          END;        '{ => braceCount ¬ braceCount + 1;         '} =>          IF braceCount > 0 THEN braceCount ¬ braceCount - 1          ELSE {	    errorsEncountered ¬ unmatched};        ENDCASE => IF braceCount = 0 THEN RETURN;      ENDLOOP;  -- end main get character loop    END;  --of procedure GetNextChar      InitFiles: PUBLIC PROCEDURE [h: Exec.Handle] =    BEGIN    tty ¬ Exec.OutputProc[h];    lstStream ¬ opStream ¬ NIL;    sourceSegment ¬ NIL;    nextSourceFile ¬ 0;    END;   --of procedure InitFiles      LogErrLine: PUBLIC PROCEDURE [message: LONG STRING] =  --put an error message into the listing file    BEGIN    Stream.PutString[lstStream, "**********             "L];    Stream.PutString[lstStream, message];    Stream.PutChar[lstStream, Ascii.CR];    END;  --of procedure LogErrLine      LogSourceLine: PUBLIC PROCEDURE =  --log the source line     BEGIN    pos: CARDINAL;    char: CHARACTER;    n: [1..100];    IF curPos = 0 THEN FatalError ELSE pos ¬ curPos - 1;    FOR n IN [1..100] DO      IF pos = 0 THEN EXIT;      IF source[pos ¬ pos - 1] = Ascii.CR THEN {pos ¬ pos + 1; EXIT};      ENDLOOP;    FOR n IN [1..100] DO      char ¬ IF pos >= maxPos THEN eofChar ELSE source[pos];      SELECT char FROM        eofChar, Ascii.CR, Ascii.ControlZ => EXIT;        ENDCASE => Stream.PutChar[lstStream, char];      pos ¬ pos + 1;      ENDLOOP;    Stream.PutChar[lstStream, Ascii.CR];    END;  -- end of procedure LogSourceLine    OpenFiles: PUBLIC PROCEDURE =  --open output files    BEGIN    lstStream ¬ MStream.WriteOnly[      ReplaceExt[outputFile, ".ls"], [NIL, NIL], text];    opStream ¬ MStream.WriteOnly[      ReplaceExt[outputFile, ".tp"], [NIL, NIL], text];    END;  --of procedure OpenFiles      OpenNextSource: PUBLIC PROCEDURE RETURNS [done: BOOLEAN ¬ FALSE] =  --open next source file and create a segment upon it    BEGIN    inFile: MFile.Handle;    length: LONG CARDINAL;    IF nextSourceFile IN [0..sourceFilesCount) THEN {      IF nextSourceFile # 0 THEN {        MSegment.Delete[sourceSegment];        sourceSegment ¬ NIL};      inFile ¬ MFile.Acquire[	name: sourceFile[nextSourceFile], access: readOnly, release: [NIL, NIL]];      length ¬ MFile.GetLength[inFile];      IF length = 0 THEN {	TtyLine2[sourceFile[nextSourceFile], " is a zero length file."L]; FatalError};      IF Inline.HighHalf[length] # 0 THEN {	TtyLine2[sourceFile[nextSourceFile], " length > 64k pages."L]; FatalError};      sourceSegment ¬ MSegment.Create[file: inFile, release: [NIL, NIL]];      inFile ¬ NIL;      ScanInit[MSegment.Address[sourceSegment], Inline.LowHalf[length]];      nextSourceFile ¬ nextSourceFile + 1;      RETURN[FALSE]}    ELSE RETURN[TRUE];    END;  --of procedure OpenNextSource      PrintSpaces: PUBLIC PROCEDURE [spaces: CARDINAL] =   --put spaces in the listing file    BEGIN    i: CARDINAL;    dest: LONG STRING ¬ [50];    FOR i IN [0..spaces) DO String.AppendChar[dest, ' ]; ENDLOOP;    Stream.PutString[lstStream, dest];    END;  --of procedure PrintSpaces      PutDirectToOpFile: PUBLIC PROCEDURE [address: LONG STRING] =  --put string directly into .op file.  no error checking is done so it had better be valid nex digits    BEGIN    IF address.length # 0 THEN {      Stream.PutString[opStream, address];      Stream.PutChar[opStream, Ascii.CR]};    END;  --of procedure PutMemoryAddress      PutToListing: PUBLIC PROCEDURE [word: CARDINAL, columns: CARDINAL, spaces: CARDINAL] =   --format the word into given number of columns followed by given number of spaces in the listing file    BEGIN    dest.length ¬ 0;    Format.Number[      proc: Append,       n: word,       format:  Format.NumberFormat[        base: 16, 	zerofill: FALSE, 	unsigned: TRUE,	columns: columns]];     Stream.PutString[lstStream, dest];       PrintSpaces[spaces];    END;  --of procedure PutToListing      PutToOpFile: PUBLIC PROCEDURE [word: CARDINAL] =   --convert the word to hex and put it into the .op file    BEGIN      dest.length ¬ 0;      Format.Number[      proc: Append,       n: word,       format:  Format.NumberFormat[        base: 16, 	zerofill: TRUE, 	unsigned: TRUE,	columns: 4]];    Stream.PutString[opStream, dest];    Stream.PutChar[opStream, Ascii.CR];    END;  --of procedure PutToOpFile    ReplaceExt: PROCEDURE [name, ext: LONG STRING] RETURNS [LONG STRING] =    BEGIN    name.length ¬ name.length - 3;     String.AppendString[name, ext];    RETURN[name];    END;  --of procedure ReplaceExt    ScanInit: PROCEDURE [    segmentAddress: LONG POINTER, sourceLength: CARDINAL] =    BEGIN     curPos ¬ 0;     source ¬ segmentAddress;     maxPos ¬ sourceLength;     END;  -- of ScanInit proc    TtyLine: PUBLIC PROCEDURE [message: LONG STRING] =    BEGIN    Format.Line[tty, message];    END;  --of procedure TtyLine      TtyLine2: PUBLIC PROCEDURE [message1, message2: LONG STRING] =    BEGIN    Format.Text[tty, message1];    TtyLine[message2];    END;  --of procedure TtyLine2      END...--Last edit by:--JAC   	 	 4-Dec-84 18:51:27 	added PutMemoryAddress--JAC   	 	 5-Dec-84 10:23:01 	added OpenNextSource--JAC   	 	 6-Dec-84  9:51:30 	added temporary .tp output file so that the .op file is not destroyed if an error exists--JAC   	 	11-Dec-84 14:48:35 	added PutDirectToOpFile
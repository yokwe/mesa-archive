-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. --Last edit by JAC       29-Mar-85 11:19:06--Control the assembly flow: Initialize vars and tables, pass1 and pass2DIRECTORY  Exec USING [AddCommand, ExecProc, Handle, Outcome, OutputProc, RemoveCommand],  Format USING [CR, Decimal, Line, StringProc, Text],  Heap USING [Error, systemZone],   MFile USING [Acquire, Delete, Error],  MSegment USING [Error],   MStream USING [Error],  Runtime USING [CallDebugger, GetBcdTime],      String USING [AppendLongNumber, AppendString, StringBoundsFault],  System USING [GetGreenwichMeanTime, GreenwichMeanTime],  Time USING [Append, Unpack],  Volume USING [InsufficientSpace],  DsyAssembler USING [CreatePassSegment, DeletePassSegment, DeleteStmtSegment, FreePassSpace, Statement, maxArgLength, sizeArgArray, version],  DsyControl,  DsyFile USING [CloseStream, currentFile, defsFileNames, defsFilesCnt, DeleteSIs,  fImc, Finish, InitBackupFile, LogLine, outFile, ReplaceExt, siStream, sourceFileNames, sourceFilesCnt],  DsyLabel USING [ReleaseLTSpace],  DsyModule USING [    InitGlobalEncode, InitGlobalExpTablesA, InitGlobalExpTablesB, InitGlobalFile, InitGlobalLabel,    InitGlobalLTHash, InitGlobalMacroTables, InitGlobalMTSpace, InitGlobalP2Hash,    InitMacroTable, InitGlobalTempSpace, Pass1, Pass2, ProcessCallLine, ReleaseMTSpace],  DsyP2Hash USING [EraseMiSpace, ErasePass2Hash, EraseXSpace, InitPass2Space];DsyControlImpl: PROGRAM  IMPORTS Exec, Format, Heap, MFile, MSegment, MStream, Runtime, String, System, Time, Volume, DsyAssembler, DsyControl, DsyFile, DsyLabel, DsyModule, DsyP2Hash  EXPORTS  DsyAssembler, DsyControl =  BEGIN      FatalError: PUBLIC ERROR = CODE;  UserAbort: PUBLIC ERROR = CODE;  argBuf: PUBLIC ARRAY [0..DsyAssembler.sizeArgArray] OF LONG STRING;   -- argBuf is initialized in BreakPhraseMain when passed NIL. Note curS  assemblerDirective: PUBLIC INTEGER;  BeginTime: PUBLIC System.GreenwichMeanTime;  config: PUBLIC INTEGER;  curTime: PUBLIC LONG CARDINAL;  curTask: PUBLIC CARDINAL;  debugStop: PUBLIC BOOLEAN;  endStop: PUBLIC BOOLEAN;  errorsExist: PUBLIC BOOLEAN;  errorsInThisFile: PUBLIC BOOLEAN;  execHandle: PUBLIC Exec.Handle;  FinishTime: PUBLIC System.GreenwichMeanTime;  flagNestedComments: PUBLIC BOOLEAN;  ifsInThisFile: PUBLIC BOOLEAN;  linkLoad: PUBLIC BOOLEAN;  linkVal: PUBLIC [0..16);  needsSourceLine: PUBLIC BOOLEAN;      noFinalFiles: PUBLIC BOOLEAN;  noFTfile: PUBLIC BOOLEAN;  numArgs: PUBLIC CARDINAL [0..DsyAssembler.sizeArgArray];  statement: PUBLIC DsyAssembler.Statement;  tty: Format.StringProc;  version: PUBLIC LONG STRING ¬ [20];   InitGlobal: PROCEDURE [h: Exec.Handle] =    BEGIN    i: CARDINAL;    DsyAssembler.version.length ¬ 0;    Time.Append[s: DsyAssembler.version, unpacked: Time.Unpack[time: Runtime.GetBcdTime[]], zone: FALSE];    FOR i IN [0..DsyAssembler.sizeArgArray] DO      argBuf[i] ¬ Heap.systemZone.NEW[StringBody[DsyAssembler.maxArgLength]]; ENDLOOP;    --argBuf is initialized in BreakPhraseMain when passed NIL. Note curS     config ¬ 0;    curTask ¬ 0;    debugStop ¬ FALSE;    endStop ¬ FALSE;    errorsExist ¬ FALSE;    errorsInThisFile ¬ FALSE;    execHandle ¬ h;    flagNestedComments ¬ FALSE;    ifsInThisFile ¬ FALSE;    linkLoad ¬ FALSE;    needsSourceLine ¬ FALSE;            noFinalFiles ¬ FALSE;    noFTfile ¬ FALSE;    statement ¬ DsyAssembler.Statement[];    tty ¬ Exec.OutputProc[h];    END;  --end of procedure InitGlobal  Finish: PROCEDURE[outcome: Exec.Outcome]  =  --deallocate space before quitting    BEGIN    i: CARDINAL;    DsyFile.Finish[outcome];        DsyAssembler.DeletePassSegment;    FOR i IN [0..DsyFile.defsFilesCnt) DO      Heap.systemZone.FREE[@DsyFile.defsFileNames[i]]; ENDLOOP;    FOR i IN [0..DsyFile.sourceFilesCnt) DO      Heap.systemZone.FREE[@DsyFile.sourceFileNames[i]]; ENDLOOP;    FOR i IN [0..DsyAssembler.sizeArgArray] DO      Heap.systemZone.FREE[@argBuf[i]]; ENDLOOP;    IF outcome # normal THEN {      DsyModule.ReleaseMTSpace;       DsyLabel.ReleaseLTSpace;      DsyAssembler.DeleteStmtSegment;      DsyP2Hash.EraseMiSpace;      DsyP2Hash.ErasePass2Hash;      DsyP2Hash.EraseXSpace};          END;  -- Finish  Driver: PROCEDURE [h: Exec.Handle, clientData: LONG POINTER] RETURNS [    o: Exec.Outcome ¬ normal] =    BEGIN    InitGlobal[h];    Assemble[      ! FatalError => {o ¬ error; CONTINUE};      UserAbort => {o ¬ abort; CONTINUE};      Volume.InsufficientSpace => {o ¬ error; LogErrDeleteSI["Insufficient space"L]; CONTINUE};      Heap.Error =>         SELECT type FROM	  insufficientSpace => {o ¬ error; LogErrDeleteSI["Insufficient space"L]; CONTINUE};	  ENDCASE => {o ¬ error; Finish[o]; REJECT};      MFile.Error =>        SELECT code FROM	  noRoomOnVolume => {o ¬ error; LogErrDeleteSI["No room on volume"L]; CONTINUE};          noSuchFile => {TtyLine["No such file"L]; o ¬ error; CONTINUE};	  conflictingAccess => {LogErrDeleteSI["Conflicting access"L]; o ¬ error; CONTINUE};	  illegalName => {LogErrDeleteSI["Illegal name"L]; o ¬ error; CONTINUE};	  ENDCASE => {o ¬ error; Finish[o]; REJECT};      MSegment.Error =>        SELECT code FROM	  insufficientVM => {o ¬ error; LogErrDeleteSI["Insufficient VM"L]; CONTINUE}; 	  conflictingAccess => {LogErrDeleteSI["Conflicting access"L]; o ¬ error; CONTINUE};	  noRoomOnVolume => {o ¬ error; LogErrDeleteSI["No room on volume"L]; CONTINUE};	  ENDCASE => {o ¬ error; Finish[o]; REJECT};      MStream.Error =>        SELECT code FROM          fileNotAvailable => {LogErrDeleteSI["File not available"L]; o ¬ error; CONTINUE};	  ENDCASE => {Finish[o]; REJECT};      String.StringBoundsFault => RESUME[NIL];      UNWIND => {o ¬ error; Finish[o]; REJECT}];    TtyCR[];    IF ~errorsExist AND o = normal THEN {      DsyFile.LogLine[" "L]; DsyFile.LogLine["Done"L]; TtyLine["Done"L];       TtyLine["No errors"]};    IF errorsExist THEN {      DsyFile.LogLine[" "L]; DsyFile.LogLine["Errors"L];      TtyLine2["Errors. See File "L, DsyFile.ReplaceExt[DsyFile.outFile, "er"L]];      IF o = normal THEN o ¬ error};    IF endStop THEN Runtime.CallDebugger["Processing Complete"L];    Finish[o];    END;  -- end of procedure Driver  Assemble: PROCEDURE =    BEGIN        TotalTime: LONG CARDINAL;    str: LONG STRING ¬ [32];    str.length ¬ 0;    String.AppendString[str, "Vespers of "];    String.AppendString[str, DsyAssembler.version];          TtyLine[str];                DsyModule.InitGlobalTempSpace[];        DsyModule.InitGlobalLTHash[];    DsyModule.InitGlobalMTSpace[];            DsyModule.InitGlobalExpTablesA[];    DsyModule.InitGlobalExpTablesB[];    DsyModule.InitGlobalMacroTables[];    DsyModule.InitGlobalEncode[];    DsyModule.InitGlobalFile[];    DsyModule.InitGlobalLabel[];    DsyModule.InitGlobalP2Hash[];    DsyModule.ProcessCallLine[];    DsyModule.InitMacroTable[]; -- Must follow ProcessCallLine     DsyFile.InitBackupFile[];    DsyAssembler.CreatePassSegment;       DsyFile.LogLine[str];        IF debugStop THEN Runtime.CallDebugger["About to process"L];    TtyLine["Pass 1 ..."L];    DsyModule.Pass1[];    TtyLine[" "L];    DsyAssembler.FreePassSpace;    DsyFile.currentFile.length ¬ 0;  --no longer building si's            IF NOT errorsExist THEN {      DsyControl.BeginTime ¬ System.GetGreenwichMeanTime[];      DsyP2Hash.InitPass2Space[];      str.length ¬ 0;      TtyText["Pass 2 ... "];              DsyModule.Pass2[];          DsyControl.FinishTime ¬ System.GetGreenwichMeanTime[];      TotalTime ¬ DsyControl.FinishTime - DsyControl.BeginTime;      String.AppendLongNumber[str,TotalTime,10];      String.AppendString[str," second(s)"L];      TtyLine[str]}     ELSE DsyFile.DeleteSIs;  --Delete .si's with errors and conditional code    END;  --end of procedure Assemble      LogErrDeleteSI: PROCEDURE [errorMessage: LONG STRING] =  --log error line and delete current .si if working on one so that the .mc will reassemble next time    BEGIN    DsyControl.TtyLine[errorMessage];    DsyFile.LogLine[errorMessage];    IF DsyFile.siStream # NIL THEN {  --processing mc's      DsyFile.siStream ¬ DsyFile.CloseStream[DsyFile.siStream];      DsyFile.siStream ¬ NIL; --so won't try to reclose when cleaning up      IF DsyFile.fImc IN [0..DsyFile.sourceFilesCnt) THEN --in pass1 so delete .si        MFile.Delete[MFile.Acquire[DsyFile.ReplaceExt[ 	  DsyFile.sourceFileNames[DsyFile.fImc], "si"],delete, [NIL,NIL]]]};      END;  --of procedure NoRoom        --Output procedures to the exec:  TtyCR: PUBLIC PROCEDURE[] = {Format.CR[tty]};  TtyDec: PUBLIC PROCEDURE [i: INTEGER] = {Format.Decimal[tty, i]};  TtyLine: PUBLIC PROCEDURE [s: LONG STRING] = {Format.Line[tty, s]};  TtyLine2: PUBLIC PROCEDURE [s1, s2: LONG STRING] = {    Format.Text[tty, s1]; Format.Line[tty, s2]};  TtyText: PUBLIC PROCEDURE [s: LONG STRING] = {Format.Text[tty, s]};  TtyText2: PUBLIC PROCEDURE [s1, s2: LONG STRING] = {    Format.Text[tty, s1]; Format.Text[tty, s2]};      UnloadVespers: Exec.ExecProc =  {      Exec.RemoveCommand [h, "Vespers.~"L]};  --main line code  Exec.AddCommand[name: "Vespers.~"L, proc: Driver, unload: UnloadVespers];  END...  --Log of last edit:--JAC   	23-Aug-84 15:03:32	made assemblerDirective an INTEGER--JAC   	 7-Dec-84 15:51:21	catch errors to eliminate crashes--JAC   	29-Mar-85 11:31:36	only delete .si in LogErrDeleteSI if we are sure in pass1 and add unload proc
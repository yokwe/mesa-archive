-- Copyright (C) 1983, 1985  by Xerox Corporation. All rights reserved. -- CPMesaWindowImpl.mesa, JAC   ,  5-Apr-85 17:33:47-- Created from CPMesaWindow.mesa, HGM, 26-May-83 16:06:04DIRECTORY  Environment USING [Long],  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, CommandItem, GetTypeIn, newLine,    NumberItem, ProcType, StringItem],  Heap USING [systemZone],  Inline USING [BITAND, HighByte, HighHalf, LowByte, LowHalf],  Put USING [Blank, CR, Line, LongNumber, Number, Text],  Runtime USING [GetBcdTime],  Selection USING [Convert, ConvertInsertion],  String USING [AppendString, Empty, InvalidNumber],  TextSW USING [ForceOutput],  Time USING [Append, Unpack],  Tool USING [Create, MakeFormSW, MakeFileSW, MakeSWsProc, UnusedLogName],  ToolWindow USING [TransitionProcType],  UserInput USING [UserAbort],  Window USING [Handle],    CPDef USING [RReg],  CPKernel USING [Error, InKernel, ReadRReg, ReadVirturalMemory],  CPSymbol USING [Error, Eval, Symbol];CPMesaWindowImpl: PROGRAM  IMPORTS    FormSW, Heap, Inline, Put, Runtime, Selection, String, Time, TextSW, Tool, UserInput,    CPKernel, CPSymbol =  BEGIN    z: UNCOUNTED ZONE = Heap.systemZone;    log, form: Window.Handle ¬ NIL;  localFrame: LONG STRING ¬ z.NEW[StringBody[20]];  address: LONG STRING ¬ z.NEW[StringBody[20]];  count: CARDINAL;   DispStack: FormSW.ProcType =    BEGIN ENABLE      BEGIN      CPKernel.Error =>        BEGIN        PostMessage["Oops, "L];        TailMessage[reason];        CONTINUE;        END;      CPSymbol.Error => CONTINUE;      END;    rMDS, rvG, rPSB: CPDef.RReg;    mds: CARDINAL;    psb, gf, lf: ORDERED POINTER;    IF ~CPKernel.InKernel[] THEN      ERROR CPKernel.Error["Can't poke around while CP not in Kernel"L];    Put.CR[log];    Put.Text[log, "Display Stack: "L];    rMDS ¬ FindRReg["rMDS"L];    rvG ¬ FindRReg["rvG"L];    rPSB ¬ FindRReg["rPSB"L];    mds ¬ ReadRReg[rMDS];    psb ¬ ReadRReg[rPSB];    gf ¬ ReadRReg[rvG];    IF UseDefaultFrame[@lf] THEN {      Put.Text[log, "MDS="L];      Put.Number[log, mds, [16,FALSE,TRUE,0]];      Put.Text[log, ", PSB="L];      Put.Number[log, psb, [16,FALSE,TRUE,0]];      Put.Text[log, ", GF="L];      Put.Number[log, gf, [16,FALSE,TRUE,0]];      Put.Text[log, ", LF="L];      Put.Number[log, lf, [16,FALSE,TRUE,0]]};    Put.CR[log];    Put.Line[log, "LF-4/  FSI  RET   GF   PC"L];    FOR i: CARDINAL IN [0..100) UNTIL UserInput.UserAbort[log] DO      IF lf = NIL OR Inline.BITAND[lf, 3] # 0 THEN EXIT;      Put.Number[log, lf-4, [16,FALSE,TRUE,4]];      Put.Text[log, "/"L];      FOR p: ORDERED POINTER ¬ lf - 4, p + 1 UNTIL p > lf + 3 DO        Put.Number[log, ReadMemory[p, mds], [16,FALSE,TRUE,5]];        ENDLOOP;      lf ¬ ReadMemory[lf-3, mds];      Put.CR[log];      ENDLOOP;    END;   UseDefaultFrame: PROC [    lf: POINTER TO ORDERED POINTER] RETURNS [BOOLEAN] =     BEGIN    lf­ ¬ NIL;    IF Selection.ConvertInsertion[subwindow] = form AND      FormSW.GetTypeIn[form].index = 2 AND ~String.Empty[localFrame] THEN        lf­ ¬ StringToHex[localFrame ! String.InvalidNumber => CONTINUE]    ELSE {      s: LONG STRING ¬ Selection.Convert[string];      lf­ ¬ StringToHex[s ! String.InvalidNumber => CONTINUE];      z.FREE[@s]};    IF lf­ = NIL THEN {      rLF: CPDef.RReg ¬ FindRReg["rvL"L];      lf­ ¬ ReadRReg[rLF];      RETURN[TRUE]}    ELSE RETURN[FALSE];    END;      StringToHex: PROCEDURE [s: LONG STRING] RETURNS [v: UNSPECIFIED ¬ 0] =    BEGIN    char: CHARACTER;    cp: CARDINAL ¬ 0;    getchar: PROCEDURE =      BEGIN char ¬ IF cp >= s.length THEN 0C ELSE s[cp]; cp ¬ cp + 1; END;    IF s = NIL THEN String.InvalidNumber;    getchar[];    WHILE char <= '  DO      IF char = 0C THEN SIGNAL String.InvalidNumber; getchar[]; ENDLOOP;    DO      SELECT char FROM        IN ['0..'9] => v ¬ v*16 + (char - '0);	IN ['a..'f] => v ¬ v*16 + (char - 'a) + 10;	IN ['A..'F] => v ¬ v*16 + (char - 'A) + 10;	0C => EXIT;	ENDCASE => String.InvalidNumber;      getchar[];      ENDLOOP;    END;  LongStringToHex: PROCEDURE [s: LONG STRING] RETURNS [v: LONG UNSPECIFIED ¬ 0] =    BEGIN    char: CHARACTER;    cp: CARDINAL ¬ 0;    getchar: PROCEDURE =      BEGIN char ¬ IF cp >= s.length THEN 0C ELSE s[cp]; cp ¬ cp + 1; END;    IF s = NIL THEN String.InvalidNumber;    getchar[];    WHILE char <= '  DO      IF char = 0C THEN SIGNAL String.InvalidNumber; getchar[]; ENDLOOP;    DO      SELECT char FROM        IN ['0..'9] => v ¬ v*16 + (char - '0);	IN ['a..'f] => v ¬ v*16 + (char - 'a) + 10;	IN ['A..'F] => v ¬ v*16 + (char - 'A) + 10;	0C => EXIT;	ENDCASE => String.InvalidNumber;      getchar[];      ENDLOOP;    END;   ListProc: FormSW.ProcType =    BEGIN ENABLE      BEGIN      CPKernel.Error =>        BEGIN        PostMessage["Oops, "L];        TailMessage[reason];        CONTINUE;        END;      END;    rPTC: CPDef.RReg;    pdaMds: CARDINAL = 1;    firstProcess: CARDINAL = 10B;    pdaReady: POINTER = LOOPHOLE[0];    pdaCount: POINTER = LOOPHOLE[1];    stateVectors: POINTER = LOOPHOLE[8];    faultQueues: POINTER = LOOPHOLE[60B];    count: CARDINAL;    now: CARDINAL;    psb: ORDERED POINTER ¬ LOOPHOLE[firstProcess*8];    IF ~CPKernel.InKernel[] THEN      ERROR CPKernel.Error["Can't poke around while CP not in Kernel"L];    Put.CR[log];    Put.Text[log, "List Processes: "L];    rPTC ¬ FindRReg["rPTC"L];    now ¬ ReadRReg[rPTC];    count ¬ ReadMemory[pdaCount, pdaMds];    Put.Text[log, "rPTC="L];    Put.Number[log, now, [16,FALSE,TRUE,0]];    Put.Text[log, ", Count="L];    Put.Number[log, count, [16,FALSE,TRUE,0]];    Put.Text[log, ", Ready="L];    Put.Number[log, ReadMemory[pdaReady, pdaMds], [16,FALSE,TRUE,0]];    Put.CR[log];    Put.Text[log, "SV="L];    FOR i: CARDINAL IN [0..8) DO      Put.Number[log, ReadMemory[stateVectors+i, pdaMds], [16,FALSE,TRUE,5]];      ENDLOOP;    Put.CR[log];    Put.Text[log, "Fault="L];    FOR i: CARDINAL IN [0..16) DO      Put.Number[log, ReadMemory[faultQueues+i, pdaMds], [16,FALSE,TRUE,4]];      ENDLOOP;    Put.CR[log];    Put.Line[log, " PSB Time link flag  CTX  MDS"L];      FOR i: CARDINAL IN [0..count) UNTIL UserInput.UserAbort[log] DO      l, g, pc: POINTER;      time, link, flags, mds: WORD;      context: POINTER ¬ ReadMemory[psb+2, pdaMds];      IF context = NIL THEN BEGIN psb ¬ psb + 8; LOOP; END;      flags ¬ ReadMemory[psb+1, pdaMds];      IF Inline.BITAND[flags, 0C000H] # 0C000H THEN {psb ¬ psb + 8; LOOP};      Put.Number[log, psb, [16,FALSE,TRUE,4]];      link ¬ ReadMemory[psb+0, pdaMds];      flags ¬ ReadMemory[psb+1, pdaMds];      time ¬ ReadMemory[psb+3, pdaMds];      mds ¬ ReadMemory[psb+4, pdaMds];      Put.Number[log, link, [16,FALSE,TRUE,5]];      Put.Number[log, flags, [16,FALSE,TRUE,5]];      Put.Number[log, context, [16,FALSE,TRUE,5]];      IF time = 0 THEN Put.Text[log, "     "L]      ELSE Put.Number[log, time-now, [16,FALSE,TRUE,4]];      Put.Number[log, mds, [16,FALSE,TRUE,3]];      IF Inline.BITAND[link, 1] # 0 THEN l ¬ ReadMemory[context+15, pdaMds]      ELSE l ¬ context;      g ¬ ReadMemory[l-2, mds];      pc ¬ ReadMemory[l-1, mds];      Put.Text[log, "  L:"L];      Put.Number[log, l, [16,FALSE,TRUE,5]];      Put.Text[log, ", G:"L];      Put.Number[log, g, [16,FALSE,TRUE,5]];      Put.Text[log, ", PC:"L];      Put.Number[log, pc, [16,FALSE,TRUE,5]];      IF Inline.BITAND[link, 1] # 0 THEN        BEGIN  -- context is a state vector	insAndStackP: WORD = ReadMemory[context+14, pdaMds];	instByte: WORD = Inline.HighByte[insAndStackP];	stackP: WORD = Inline.LowByte[insAndStackP];	IF instByte # 0 THEN	  BEGIN          Put.Text[log, "  InstByte="L];          Put.Number[log, instByte, [16,FALSE,TRUE,0]];	  END;	IF stackP # 0 THEN	  BEGIN          Put.Text[log, ", StackP="L];          Put.Number[log, stackP, [16,FALSE,TRUE,0]];	  END;        Put.CR[log];        Put.Text[log, "      "L];	FOR i: CARDINAL IN [0..14) DO          Put.Number[log, ReadMemory[context+i, pdaMds], [16,FALSE,TRUE,5]];	  ENDLOOP;        Put.CR[log];        Put.Text[log, "      "L];	FOR i: CARDINAL IN [14..17) DO          Put.Number[log, ReadMemory[context+i, pdaMds], [16,FALSE,TRUE,5]];	  ENDLOOP;	END;      psb ¬ psb + 8;      Put.CR[log];      ENDLOOP    END;  ReadProc: FormSW.ProcType =    BEGIN ENABLE      BEGIN      CPKernel.Error =>        BEGIN        PostMessage["Oops, "L];        TailMessage[reason];        CONTINUE;        END;      END;    lp: LONG POINTER ¬ NIL;    IF ~CPKernel.InKernel[] THEN      ERROR CPKernel.Error["Can't poke around while CP not in Kernel"L];    lp ¬ LongStringToHex[address ! String.InvalidNumber => CONTINUE];    IF lp = NIL THEN RETURN;    Put.CR[log];    Put.Text[log, "Read at "L];    Put.Text[log, address];    Put.Text[log, " for "L];    Put.Number[log, count, [10,FALSE,TRUE,0]];    Put.CR[log];    FOR i: CARDINAL IN [0..count) UNTIL UserInput.UserAbort[log] DO      val: WORD = ReadMemory[Inline.LowHalf[lp], Inline.HighHalf[lp]];      IF i MOD 8 = 0 THEN {        Put.LongNumber[log, lp, [16,FALSE,TRUE,8]];	Put.Text[log, "/ "L]};      Put.Number[log, val, [16,FALSE,TRUE,5]];      IF i MOD 8 = 7 THEN Put.CR[log] ELSE Put.Blank[log];      lp ¬ lp+1;      ENDLOOP;    Put.CR[log];    END;      FindRReg: PROCEDURE [s: LONG STRING] RETURNS [r: CPDef.RReg] =    BEGIN    value: CPSymbol.Symbol;    value ¬ CPSymbol.Eval[s !      CPSymbol.Error =>        BEGIN        PostMessage["Can't find "L];        PostMessage[s];        PostMessage[" in symbol table: "L];        TailMessage[reason];	-- Let Error go up the stack        END];    WITH value SELECT FROM      rReg => RETURN[r];      ENDCASE =>        BEGIN        PostMessage[s];        PostMessage[" isn't an R Register"L];	ERROR CPSymbol.Error[NIL];	END;    END;      ReadRReg: PROCEDURE [r: CPDef.RReg] RETURNS [UNSPECIFIED] =    BEGIN    RETURN[CPKernel.ReadRReg[r]];    END;    ReadMemory: PROCEDURE [where: POINTER, mds: CARDINAL] RETURNS [UNSPECIFIED] =    BEGIN    long: Environment.Long ¬ [any[low: where, high: mds]];    RETURN[CPKernel.ReadVirturalMemory[long.lp]];    END;  PostMessage: PROCEDURE [s: LONG STRING] =    BEGIN    Put.CR[log];    Put.Text[log, s];    TextSW.ForceOutput[log]    END;  AppendMessage: PROCEDURE [s: LONG STRING] =    BEGIN    Put.Text[log, s];    TextSW.ForceOutput[log]    END;  TailMessage: PROCEDURE [s: LONG STRING] =    BEGIN    Put.Text[log, s];    Put.Line[log, "."L];    TextSW.ForceOutput[log]    END;    Initialize: PROCEDURE =    BEGIN    herald: STRING = [100];    String.AppendString[herald, "CPMesa of "L];    Time.Append[herald, Time.Unpack[Runtime.GetBcdTime[]]];    [] ¬ Tool.Create[      name: herald,      cmSection: "CP Mesa"L,      initialState: inactive,      makeSWsProc: MakeSWs,      clientTransition: ClientTransition];    END;    MakeSWs: Tool.MakeSWsProc =    BEGIN    logFileName: STRING = [40];    Tool.UnusedLogName[logFileName, "CPMesa.log$"L];    form ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    log ¬ Tool.MakeFileSW[window: window, name: logFileName, h: 100];    END;    MakeForm: FormSW.ClientItemsProcType =    BEGIN    nParams: CARDINAL = 6;    items ¬ FormSW.AllocateItemDescriptor[nParams];    items[0] ¬ FormSW.CommandItem[      tag: "ListProc"L, proc: ListProc, place: FormSW.newLine];    items[1] ¬ FormSW.CommandItem[tag: "DispStack"L, proc: DispStack];    items[2] ¬ FormSW.StringItem[      tag: "Local Frame"L, inHeap: FALSE, string: @localFrame];    items[3] ¬ FormSW.CommandItem[      tag: "Read"L, proc: ReadProc, place: FormSW.newLine];    items[4] ¬ FormSW.StringItem[      tag: "Address"L, inHeap: TRUE, string: @address, boxWidth: 100];    items[5] ¬ FormSW.NumberItem[      tag: "Count"L, value: @count, notNegative: TRUE];    RETURN[items, TRUE];    END;       ClientTransition: ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      old = inactive =>        BEGIN        END;      new = inactive =>        BEGIN        END;      ENDCASE;    END;	  Initialize[];  END.
-- Copyright (C) 1984  by Xerox Corporation. All rights reserved.-- File: MOpcodeAssemblerImpl.mesa-- Author: JAC   		Created: 29-Nov-84 10:12:42-- Last edit by JAC   	21-Jan-85 15:54:56--  MOpAsm treats mesa opcodes sort of like an assembly language and translates the opcodes into hex.  It produces 2 output files - a .ls file and a .op file.  After putting an address into the .op file, it may be run through MakeDLionCpr (Alternatively an address may be put into the source file as "@memoryAddress" which is directly transferred into the .op file which means no error checking for an incorrect address).  The .ls file is actually a listing containing the source code and its hex values.  The command line is of the form "MOpAsm outputFile/o inputFile"  where inputFile also specifies the extension.  There may be <= 20 input files on a command line.  MOpAsm expects its arguments to be byte quantities.  More than one argument should be separated by spaces or commas.  Comments are delimited by {} and only one opcode is allowed per line.  Any data found between !'s is put directly into the .op file with not error checking; nesting is not allowed.DIRECTORY  Ascii USING [CR, SP, TAB],  Exec USING [AddCommand, GetToken, Handle, Outcome],  Heap USING [systemZone],  MOpcodeAssembler,  MFile USING [Error],  MSegment USING [Error],  MStream USING [Error],  String USING [AppendChar, AppendString, StringBoundsFault, Equal];  MOpcodeAssemblerImpl: PROGRAM   IMPORTS Exec, Heap, MOpcodeAssembler, MFile, MSegment, MStream, String   EXPORTS MOpcodeAssembler =  BEGIN OPEN MOpcodeAssembler;     FatalError: PUBLIC ERROR = CODE;    outputFile: PUBLIC LONG STRING ¬ [64];  sourceFile: PUBLIC ARRAY [0..maxNumFiles] OF LONG STRING;  sourceFilesCount: PUBLIC CARDINAL;    argBuffer: ARRAY [0..argBufLength) OF LONG STRING;  argBufLength: CARDINAL =  5;  byteOffset: CARDINAL;  curOpcode: Opcode;  errorInSource: BOOLEAN;  high: BOOLEAN;  ibWord: CARDINAL ¬ 0;  maxArgLength: CARDINAL = 25;  tableIndex: CARDINAL;    Assemble: PROCEDURE [h: Exec.Handle] =    BEGIN        IF ProcessCallLine[h] THEN {      OpenFiles[];      UNTIL OpenNextSource[]  DO --for each source file	DO                     --for each line	  IF BreakUpLine[] THEN {	    IF TranslateOpcode[] THEN WriteToOutputFiles[]}	  ELSE {	    IF argBuffer[0].length # 0 THEN	      IF TranslateOpcode[] THEN WriteToOutputFiles[];	    EXIT};	  ENDLOOP;	ENDLOOP;      PutOutLastByte[];      CloseFiles[errorInSource]};        END;  --of procedure Assemble      BreakUpLine: PROCEDURE RETURNS [notFinished: BOOLEAN ¬ TRUE] =  --put the opcode and its arguments if any exist into the argBuffer    BEGIN    argIndex: CARDINAL ¬ 0;    char: CHARACTER;    dataToOpFile: BOOLEAN ¬ FALSE;    errorEncountered: CommentError ¬ none;    i: CARDINAL;    makingMemoryAddress: BOOLEAN ¬ FALSE;    toOpString: LONG STRING ¬ [25];    tooManyArgs: BOOLEAN ¬ FALSE;    FOR i IN [0..argBufLength) DO argBuffer[i].length ¬ 0; ENDLOOP;    DO      [char, errorEncountered] ¬ GetNextChar[];      IF errorEncountered # none THEN {        WHILE char # Ascii.CR AND char # eofChar DO 	  [char, ] ¬ GetNextChar[]; 	  ENDLOOP;	IF errorEncountered = eof THEN {	  ErrorInSource["Eof encountered within comment"L];	  RETURN[FALSE]}	ELSE ErrorInSource["Unmatched comment character"L];	IF char # eofChar THEN notFinished ¬ BreakUpLine[]	ELSE RETURN[FALSE];	RETURN};	      SELECT char FROM        Ascii.CR => 	  IF argBuffer[0].length # 0 THEN EXIT	  ELSE {	    PrintSpaces[23];	    LogSourceLine[];	    IF makingMemoryAddress THEN {	      makingMemoryAddress ¬ FALSE;	      PutOutLastByte[];	      PutDirectToOpFile[toOpString]}	    ELSE IF dataToOpFile THEN {	      PutDirectToOpFile[toOpString];	      toOpString.length ¬ 0}};	'@ => 	  BEGIN	  toOpString.length ¬ 0;	  String.AppendChar[toOpString, char];	  IF NOT (makingMemoryAddress OR dataToOpFile) THEN makingMemoryAddress ¬ TRUE;	  END;	'! =>	  BEGIN	  IF  makingMemoryAddress THEN {	    makingMemoryAddress ¬ FALSE;	    PutOutLastByte[];	    PutDirectToOpFile[toOpString]};	  IF dataToOpFile THEN {	    dataToOpFile ¬ FALSE;	    PutDirectToOpFile[toOpString]}	  ELSE {	    PutOutLastByte[];	    dataToOpFile ¬ TRUE;	    toOpString.length ¬ 0};	  END;	eofChar => 	  BEGIN	  IF dataToOpFile THEN ErrorInSource["Eof encountered within !...!"L];	  RETURN[FALSE];	  END;	Ascii.SP =>	  BEGIN	  IF NOT tooManyArgs THEN 	    IF argBuffer[argIndex].length # 0 THEN {	      argIndex ¬ argIndex + 1;	      IF NOT argIndex IN [0..argBufLength) THEN tooManyArgs ¬ TRUE};	  IF makingMemoryAddress THEN {	    makingMemoryAddress ¬ FALSE;	    PutOutLastByte[];	    PutDirectToOpFile[toOpString]}	  ELSE IF dataToOpFile THEN {	    PutDirectToOpFile[toOpString];	    toOpString.length ¬ 0};	  END;	', =>	  IF makingMemoryAddress OR dataToOpFile THEN String.AppendChar[toOpString, char] 	  ELSE IF NOT tooManyArgs THEN	    IF argBuffer[argIndex].length # 0 THEN {	      argIndex ¬ argIndex + 1;	      IF NOT argIndex IN [0..argBufLength) THEN tooManyArgs ¬ TRUE};	Ascii.TAB =>	  BEGIN	  IF NOT tooManyArgs THEN	    IF argBuffer[argIndex].length # 0 THEN {	      argIndex ¬ argIndex + 1;	      IF NOT argIndex IN [0..argBufLength) THEN tooManyArgs ¬ TRUE};	  IF makingMemoryAddress THEN {	    makingMemoryAddress ¬ FALSE;	    PutOutLastByte[];	    PutDirectToOpFile[toOpString]}	  ELSE IF dataToOpFile THEN {	    PutDirectToOpFile[toOpString];	    toOpString.length ¬ 0};	  END;	ENDCASE => 	  BEGIN	  SELECT TRUE FROM	  	   makingMemoryAddress => String.AppendChar[toOpString, char];	   dataToOpFile => String.AppendChar[toOpString, char];	   ENDCASE => IF NOT tooManyArgs THEN String.AppendChar[argBuffer[argIndex], char];	  END;	        ENDLOOP;    END;  --of procedure BreakUpLine    Control: PROCEDURE [h: Exec.Handle, clientData: LONG POINTER] RETURNS [o: Exec.Outcome ¬ normal] =    BEGIN    InitGlobal[h];    InitFiles[h];    InitOpcodeTable[];    Assemble[h     ! FatalError => {o ¬ error; TtyLine["Fatal error"L]; CONTINUE};     MFile.Error =>        SELECT code FROM         noSuchFile => {TtyLine["No such file"L]; o ¬ error; CONTINUE};	 conflictingAccess => {TtyLine["Conflicting access"L]; o ¬ error; CONTINUE};	 illegalName => {TtyLine["Illegal name"L]; o ¬ error; CONTINUE}; 	 noRoomOnVolume => {TtyLine["No room on volume"L]; o ¬ error; CONTINUE};	 ENDCASE => {Finish[o]; REJECT};     MSegment.Error =>       SELECT code FROM         insufficientVM => {TtyLine["Insufficient VM"L]; o ¬ error; CONTINUE};	 conflictingAccess => {TtyLine["Conflicting access"L]; o ¬ error; CONTINUE};	 noRoomOnVolume => {TtyLine["No room on volume"L]; o ¬ error; CONTINUE};	 ENDCASE => {Finish[o]; REJECT};     MStream.Error =>       SELECT code FROM         fileNotAvailable => {TtyLine["File not available"L]; o ¬ error; CONTINUE};	 ENDCASE => {Finish[o]; REJECT};     String.StringBoundsFault => RESUME[NIL];     UNWIND => {Finish[o]; REJECT}];    Finish[];    END;  --of procedure Control      ErrorInSource: PROCEDURE [message: LONG STRING] =    BEGIN    PrintSpaces[23];    LogSourceLine[];    LogErrLine[message];    errorInSource ¬ TRUE;    argBuffer[0].length ¬ 0;    END;  --of procedure ErrorInSource      Finish: PROCEDURE [o: Exec.Outcome ¬ normal] = INLINE    BEGIN    i: CARDINAL;    IF o = error THEN {      errorInSource ¬ TRUE;      CloseFiles[errorInSource]};    IF errorInSource THEN TtyLine["Errors..."L];    FOR i IN [0..argBufLength) DO      Heap.systemZone.FREE[@argBuffer[i]];       ENDLOOP;    FOR i IN [0..sourceFilesCount) DO      Heap.systemZone.FREE[@sourceFile[i]];       ENDLOOP;    END;  --of procedure Finish      InitGlobal: PROCEDURE [h: Exec.Handle] = INLINE    BEGIN    i: CARDINAL;    errorInSource ¬ FALSE;    byteOffset ¬ 0;    high ¬ TRUE;    outputFile.length ¬ 0;    FOR i IN [0..argBufLength) DO      argBuffer[i] ¬ Heap.systemZone.NEW[StringBody[maxArgLength]];      ENDLOOP;    END;  --of procedure InitGlobal    ProcessCallLine: PROCEDURE [h: Exec.Handle] RETURNS [successful: BOOLEAN ¬ TRUE] =  --the command line should consist of the input filename with extension and an output filename recognized by a /o.      BEGIN         commandLineError: BOOLEAN ¬ FALSE;    error: BOOLEAN ¬ FALSE;     execName: LONG STRING;    execSwitch: LONG STRING;      CommandLineError: PROCEDURE =      BEGIN      commandLineError ¬ TRUE;      TtyLine["Error in Command Line"L];      END;  -- CommandLineError proc         sourceFilesCount ¬ 0;    DO        [execName, execSwitch] ¬ Exec.GetToken[h];      IF execName = NIL AND execSwitch = NIL THEN EXIT;      IF execSwitch = NIL THEN        IF sourceFilesCount IN [0..maxNumFiles) THEN {	  sourceFile[sourceFilesCount] ¬ Heap.systemZone.NEW[StringBody[execName.length]];	  String.AppendString[sourceFile[sourceFilesCount], execName];	  sourceFilesCount ¬ sourceFilesCount + 1}	ELSE {IF NOT error THEN {CommandLineError[]; error ¬ TRUE}}      ELSE  	IF String.Equal[execSwitch, "o"L] OR String.Equal[execSwitch, "O"L] THEN	  IF outputFile.length = 0 THEN	    String.AppendString[outputFile, execName]	  ELSE {IF NOT error THEN {CommandLineError[]; error ¬ TRUE}}	ELSE {IF NOT error THEN {CommandLineError[]; error ¬ TRUE}};      ENDLOOP;    IF outputFile.length = 0 OR sourceFilesCount = 0 OR sourceFilesCount >= maxNumFiles THEN {      CommandLineError[];      RETURN[FALSE]};    IF commandLineError THEN RETURN[FALSE];    String.AppendString[outputFile, ".xx"];    END;  --of procedure ProcessCallLine      PutOutLastByte: PROCEDURE = INLINE  --put last byte in .op file if one was left by the last opcode    BEGIN     outWord: RECORD [       SELECT OVERLAID *  FROM         word => [word: WORD],         separate => [highByte: [0..256),	            lowByte: [0..256)],	ENDCASE];    IF NOT high THEN {      outWord.lowByte ¬ 0;      outWord.highByte ¬ ibWord;      PutToOpFile[outWord.word];      high ¬ NOT high};    END;  --of procedure PutOutLastByte            StringToNumber: PROCEDURE [str: LONG STRING] RETURNS [successful: BOOLEAN ¬ TRUE, value: CARDINAL] =    BEGIN    val, octVal, decVal, hexVal: CARDINAL ¬ 0;    notOctal, notDecimal: BOOLEAN ¬ FALSE;    i: CARDINAL;    char: CHARACTER;    IntVal: PROCEDURE [char: CHARACTER] RETURNS [value: CARDINAL] =      BEGIN      value ¬        SELECT char FROM          IN ['0..'9] => char - '0,          IN ['a..'f] => (char - 'a) + 10,          IN ['A..'F] => (char - 'A) + 10,          ENDCASE => 0;      END;  -- end IntVal    value ¬ 0;    FOR i IN [0..str.length) DO      char ¬ str[i];      SELECT char FROM        IN ['0..'7] => NULL;        IN ['8..'9] => notOctal ¬ TRUE;        IN ['a..'f], IN ['A..'F] => notOctal ¬ notDecimal ¬ TRUE;        '' =>          BEGIN  -- base will follow prime character          IF i + 2 # str.length THEN {            ErrorInSource["Number has illegal format, 0 used"L];            RETURN[FALSE, 0];            };          SELECT str[i + 1] FROM            'b, 'B =>              IF notOctal THEN {                ErrorInSource["non-octal character in octal string"L];  -- octal base                RETURN[FALSE, 0]}              ELSE value ¬ octVal;            'd, 'D =>              IF notDecimal THEN {                ErrorInSource[                  "non-decimal character in decimal string"L];  -- decimal base                RETURN[FALSE, 0]}              ELSE value ¬ decVal;            'x, 'X => value ¬ hexVal;  -- hex base            ENDCASE =>	      BEGIN	      ErrorInSource["illegal digit in number"L];              RETURN[FALSE, 0];	      END;          RETURN[TRUE, value];          END;        ENDCASE => 	  BEGIN	  ErrorInSource["illegal digit in number"L];	  RETURN[FALSE, 0];	  END;      val ¬ IntVal[char];      octVal ¬ 8*octVal + val;      decVal ¬ 10*decVal + val;      hexVal ¬ 16*hexVal + val;      ENDLOOP;    RETURN[TRUE, hexVal];    END;  --of procedure StringToNumber      TranslateOpcode: PROCEDURE RETURNS [successful: BOOLEAN ¬ TRUE] =  --find opcode in table and do some error checking     BEGIN    found: BOOLEAN ¬ FALSE;    opcodeIndex: CARDINAL;          tableIndex ¬ 0;    curOpcode ¬ Opcode[escUsed: FALSE, opcode: NIL, arg1: -1, arg2: -1];    UNTIL tableIndex = opcodeTableLength DO       IF String.Equal[argBuffer[0], "ESC"L] OR String.Equal[argBuffer[0], "ESCL"L] THEN {	curOpcode.escUsed ¬ TRUE;	opcodeIndex ¬ 1;        IF String.Equal[argBuffer[1], opcodeTable[tableIndex].opcode] THEN {found ¬ TRUE; EXIT}	ELSE tableIndex ¬ tableIndex + 1}      ELSE {        IF String.Equal[argBuffer[0], opcodeTable[tableIndex].opcode] THEN {found ¬ TRUE; EXIT}	ELSE tableIndex ¬ tableIndex + 1;	opcodeIndex ¬ 0};      ENDLOOP;    IF NOT found THEN {      ErrorInSource["Illegal opcode"L];      RETURN[FALSE]};    curOpcode.opcode ¬ opcodeTable[tableIndex].opcode;        --now do a little error checking    IF argBuffer[opcodeIndex + 1].length # 0 THEN {      [successful, curOpcode.arg1] ¬ StringToNumber[argBuffer[opcodeIndex + 1]];      IF NOT successful THEN RETURN};    IF argBuffer[opcodeIndex + 2].length # 0 THEN {      [successful, curOpcode.arg2] ¬ StringToNumber[argBuffer[opcodeIndex + 2]];      IF NOT successful THEN RETURN};    IF argBuffer[opcodeIndex + 3].length # 0 THEN {      ErrorInSource["Too many arguments for opcode"L];      RETURN[FALSE]};    IF opcodeTable[tableIndex].info.esc.escNeeded AND NOT curOpcode.escUsed THEN {      ErrorInSource["This should be an escape opcode"L];      RETURN[FALSE]};           IF curOpcode.escUsed AND NOT opcodeTable[tableIndex].info.esc.escNeeded THEN {      ErrorInSource["This should not be an escape opcode"L];      RETURN[FALSE]};     IF (opcodeTable[tableIndex].info.arg1 AND curOpcode.arg1 = -1) OR      (opcodeTable[tableIndex].info.arg2 AND curOpcode.arg2 = -1) THEN {      ErrorInSource["Insufficient number of arguments"L];      RETURN[FALSE]};     IF ((NOT opcodeTable[tableIndex].info.arg1) AND curOpcode.arg1 # -1) OR      ((NOT opcodeTable[tableIndex].info.arg2) AND curOpcode.arg2 # -1) THEN {      ErrorInSource["Too many arguments"L];      RETURN[FALSE]};     IF curOpcode.arg1 > 255 OR curOpcode.arg2 > 255 THEN {      ErrorInSource["Arguments should be byte quantities"L];      RETURN[FALSE]};    END;  --of procedure TranslateOpcode        WriteToOutputFiles: PROCEDURE =     BEGIN     outWord: RECORD [       SELECT OVERLAID *  FROM         word => [word: WORD],         separate => [highByte: [0..256),	            lowByte: [0..256)],	ENDCASE];    PutToListing[byteOffset, 4, 5];    IF NOT curOpcode.escUsed THEN       SELECT TRUE FROM        (NOT opcodeTable[tableIndex].info.arg1) AND (NOT opcodeTable[tableIndex].info.arg2) =>	  PutToListing[opcodeTable[tableIndex].info.opValue, 4, 10];	opcodeTable[tableIndex].info.arg1 AND (NOT opcodeTable[tableIndex].info.arg2) =>	  BEGIN	  outWord.lowByte ¬ curOpcode.arg1;	  outWord.highByte ¬ opcodeTable[tableIndex].info.opValue;	  PutToListing[outWord.word, 4, 10];	  END;  --of one argument	opcodeTable[tableIndex].info.arg1 AND opcodeTable[tableIndex].info.arg2 =>	  BEGIN	  outWord.lowByte ¬ curOpcode.arg1;	  outWord.highByte ¬ opcodeTable[tableIndex].info.opValue;	  PutToListing[outWord.word, 4, 3];	  PutToListing[curOpcode.arg2, 2, 5];	  END;  --of two arguments	ENDCASE    ELSE  {--escape opcode      IF opcodeTable[tableIndex].info.arg1 THEN {  --one argument        outWord.lowByte ¬ opcodeTable[tableIndex].info.opValue;	outWord.highByte ¬ opcodeTable[tableIndex].info.esc.escValue;        PutToListing[outWord.word, 4, 3];        PutToListing[curOpcode.arg1, 2, 5]}      ELSE  {      --no arguments        outWord.lowByte ¬ opcodeTable[tableIndex].info.opValue;	outWord.highByte ¬ opcodeTable[tableIndex].info.esc.escValue;        PutToListing[outWord.word, 4, 10]}};    byteOffset ¬ byteOffset + opcodeTable[tableIndex].info.bytes;    LogSourceLine[];            IF high THEN {  --previous opcode didn't leave a byte remaining      IF curOpcode.escUsed THEN {  --escape bytecode        outWord.lowByte ¬ opcodeTable[tableIndex].info.opValue;	outWord.highByte ¬ opcodeTable[tableIndex].info.esc.escValue;        PutToOpFile[outWord.word];	IF opcodeTable[tableIndex].info.arg1 THEN {  --leave byte to be written by next bytecode	  ibWord ¬ curOpcode.arg1;	  high ¬ NOT high}}      ELSE  --not an escape bytecode        IF opcodeTable[tableIndex].info.arg1 THEN {	  outWord.lowByte ¬ curOpcode.arg1;	  outWord.highByte ¬ opcodeTable[tableIndex].info.opValue;	  PutToOpFile[outWord.word];	  IF opcodeTable[tableIndex].info.arg2 THEN {--leave byte to be written by next bytecode	    ibWord ¬ curOpcode.arg2;	    high ¬ NOT high}}	ELSE {  --leave byte to be written by next bytecode	  ibWord ¬ opcodeTable[tableIndex].info.opValue;	  high ¬ NOT high}}    ELSE {  --byte was left by previous bytecode      IF curOpcode.escUsed THEN {  --escape opcode        outWord.lowByte ¬ opcodeTable[tableIndex].info.esc.escValue;	outWord.highByte ¬ ibWord;	PutToOpFile[outWord.word];	IF opcodeTable[tableIndex].info.arg1 THEN {	  high ¬ NOT high;	  outWord.lowByte ¬ curOpcode.arg1;	  outWord.highByte ¬ opcodeTable[tableIndex].info.opValue;	  PutToOpFile[outWord.word]}	ELSE  ibWord ¬ opcodeTable[tableIndex].info.opValue}  --leave for next bytecode      ELSE {  --not an escape opcode        outWord.lowByte ¬ opcodeTable[tableIndex].info.opValue;	outWord.highByte ¬ ibWord;	PutToOpFile[outWord.word];	IF opcodeTable[tableIndex].info.arg2 THEN { --two arguments so write both	  high ¬ NOT high;	  outWord.lowByte ¬ curOpcode.arg2;	  outWord.highByte ¬ curOpcode.arg1;	  PutToOpFile[outWord.word]}	ELSE  --only one argument so leave value to be written by next bytecode	  IF opcodeTable[tableIndex].info.arg1 THEN ibWord ¬ curOpcode.arg1	  ELSE high ¬ NOT high}};    END;  --of procedure WriteToOutputFiles      --main line code  Exec.AddCommand[name: "MOpAsm.~"L, proc: Control];    END...-- Last edit by:-- JAC   		 4-Dec-84 18:52:41	added ability to put memory address in source file-- JAC   		 5-Dec-84 10:22:28	added ability to have multiple source files-- JAC   		 5-Dec-84 10:22:28	print "Errors..." to exec if there is an error in any source file-- JAC   		 6-Dec-84 10:12:05	if find an @ put out last byte if necessary-- JAC   		12-Dec-84 11:39:56	all data between !'s are put directly into .op file-- JAC   		21-Jan-85 15:55:05	print error message if no output file specified
-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. -- The purpose of this module is to merge the Encoding records associated with each Phrase of a statement into a single Encoding record.  Each Phrase will have at least one Encoding record.  A Phrase will have more than one Encoding record if there is more than one possible encoding of the Phrase.  --Last edit by JAC      5-Nov-84 14:21:52  DIRECTORY  DsyAssembler;DsyMergeImpl: PROGRAM IMPORTS DsyAssembler EXPORTS DsyAssembler =  BEGIN OPEN DsyAssembler;  -- GLOBAL VARIABLES  -- SIGNALS AND ERRORS GENERATED  MergeError: ERROR [{aDinvalid, aluInInvalid, operationInvalid}] = CODE;    MergeEncoding: PROCEDURE [    phrase: PhrasePtr, mergedEncoding: EncodingPtr, trialEncoding: EncodingPtr]    RETURNS [successful: BOOLEAN] =    BEGIN    -- Attempt to merge trialEncoding into mergedEncoding.  Return TRUE if all fields can be merged.  If any format errors are encountered, a Field procedure will create an error message and chain it onto phrase.tempErrorMsgs.  These error messages can be printed later if no encoding can be successfully merged.     oldFA, newFA: FieldAssignment;    text: LONG STRING;        Field: PROCEDURE = INLINE      BEGIN      IF oldFA.assignment.type # null THEN        IF newFA.value # oldFA.value THEN          BEGIN          FormatError[phrase, newFA.assignment, oldFA.assignment, text];          successful ¬ FALSE;          END;      END;  -- end Field    successful ¬ TRUE;  -- assume successful    IF trialEncoding.op.assignment.type # null THEN      BEGIN      oldFA ¬ mergedEncoding.op;      newFA ¬ trialEncoding.op;      text ¬ "op"L;      Field[];      mergedEncoding.op ¬ newFA;      END;    IF trialEncoding.rA.assignment.type # null THEN      BEGIN      oldFA ¬ mergedEncoding.rA;      newFA ¬ trialEncoding.rA;      IF oldFA.value IN [rAStkRef..rAStkRef + rAPush) THEN {        IF trialEncoding.isPop THEN {	  newFA.value ¬ oldFA.value + rAPop;	  oldFA.value ¬ oldFA.value + rAPop}	ELSE IF trialEncoding.isPush THEN {	  newFA.value ¬ oldFA.value + rAPush;	  oldFA.value ¬ oldFA.value + rAPush}}      ELSE IF newFA.value IN [rAStkRef..rAStkRef + rAPush) THEN {        IF mergedEncoding.isPop THEN {          oldFA.value ¬ newFA.value + rAPop;	  newFA.value ¬ newFA.value + rAPop}        ELSE IF mergedEncoding.isPush THEN {          oldFA.value ¬ newFA.value + rAPush;	  newFA.value ¬ newFA.value + rAPush}};      text ¬ "rA"L;      Field[];      mergedEncoding.rA ¬ newFA;      END;    IF trialEncoding.rB.assignment.type # null THEN      BEGIN      oldFA ¬ mergedEncoding.rB;      newFA ¬ trialEncoding.rB;      text ¬ "rB"L;      Field[];      mergedEncoding.rB ¬ newFA;      END;    IF trialEncoding.rD.assignment.type # null THEN      BEGIN      value: CARDINAL ¬ 0;      oldFA ¬ mergedEncoding.rD;      newFA ¬ trialEncoding.rD;      IF newFA.value = rDSameAsrB THEN        SELECT mergedEncoding.op.value FROM          0, 1 => IF mergedEncoding.rB.assignment.type # null THEN {	            IF phrase.dest # mergedEncoding.rB.value THEN {		      FormatError[phrase, newFA.assignment, mergedEncoding.rB.assignment, text];		      successful ¬ FALSE}}		  ELSE {		    mergedEncoding.rB.value ¬ phrase.dest;		    mergedEncoding.rB.assignment ¬ newFA.assignment};	  2, 3 => 	    BEGIN	    SyntaxError[phrase, unexpectedLHS];	    successful ¬ FALSE;	    END;          ENDCASE;       text ¬ "rD"L;      Field[];    	           mergedEncoding.rD ¬ newFA;      END;    IF trialEncoding.sp1.assignment.type # null THEN      BEGIN      oldFA ¬ mergedEncoding.sp1;      newFA ¬ trialEncoding.sp1;      text ¬ "sp1"L;      Field[];      mergedEncoding.sp1 ¬ newFA;      END;    IF trialEncoding.dspB.assignment.type # null THEN      BEGIN      oldFA ¬ mergedEncoding.dspB;      newFA ¬ trialEncoding.dspB;      text ¬ "dspB"L;      Field[];      mergedEncoding.dspB ¬ newFA;      END;    IF trialEncoding.ci.assignment.type # null THEN      BEGIN      oldFA ¬ mergedEncoding.ci;      newFA ¬ trialEncoding.ci;      text ¬ "ci"L;      Field[];      mergedEncoding.ci ¬ newFA;      END;    IF trialEncoding.sp2.assignment.type # null THEN      BEGIN      oldFA ¬ mergedEncoding.sp2;      newFA ¬ trialEncoding.sp2;      text ¬ "sp2"L;      Field[];      mergedEncoding.sp2 ¬ newFA;      END;    IF trialEncoding.shift.assignment.type # null THEN      BEGIN      oldFA ¬ mergedEncoding.shift;      newFA ¬ trialEncoding.shift;      text ¬ "shift"L;      Field[];      mergedEncoding.shift ¬ newFA;      END;    IF trialEncoding.ib.assignment.type # null THEN      BEGIN      oldFA ¬ mergedEncoding.ib;      newFA ¬ trialEncoding.ib;      SELECT TRUE FROM        (oldFA.value = ibPopIB AND newFA.value = ibUReg) => 	  mergedEncoding.ib.value ¬ ibPopUReg;	(oldFA.value = ibPopIB AND newFA.value = ibVReg) => 	  mergedEncoding.ib.value ¬ ibPopVReg;	(newFA.value = ibPopIB AND oldFA.value = ibUReg) => 	  mergedEncoding.ib.value ¬ ibPopUReg;	(newFA.value = ibPopIB AND oldFA.value = ibVReg) => 	  mergedEncoding.ib.value ¬ ibPopVReg;	ENDCASE =>	  BEGIN          text ¬ "ib"L;          Field[];          mergedEncoding.ib ¬ newFA;	  END;      END;    IF trialEncoding.it.assignment.type # null THEN      BEGIN      oldFA ¬ mergedEncoding.it;      newFA ¬ trialEncoding.it;      text ¬ "it"L;      Field[];      mergedEncoding.it ¬ newFA;      END;    IF trialEncoding.aAdr.assignment.type # null THEN      BEGIN      oldFA ¬ mergedEncoding.aAdr;      newFA ¬ trialEncoding.aAdr;      text ¬ "aAdr"L;      Field[];      mergedEncoding.aAdr ¬ newFA;      END;    IF trialEncoding.mo.assignment.type # null THEN      BEGIN      IF mergedEncoding.mo.value # 0 THEN {        SELECT trialEncoding.mo.value FROM	  moA, moU => IF mergedEncoding.mo.value = moDoubleRead THEN {	                trialEncoding.mo.value ¬ trialEncoding.mo.value + 4;	                mergedEncoding.mo.value ¬ trialEncoding.mo.value}		      ELSE mergedEncoding.mo.value ¬ trialEncoding.mo.value;	   moMap => IF mergedEncoding.mo.value = moDoubleRead THEN {                      SyntaxError[phrase, invalidOperand]; successful ¬ FALSE}		    ELSE mergedEncoding.mo.value ¬ trialEncoding.mo.value;	   moRead, moWrite => 	     SELECT mergedEncoding.mo.value FROM	       moA, moU => trialEncoding.mo.value ¬ mergedEncoding.mo.value;	       moMap => trialEncoding.mo.value ¬ mergedEncoding.mo.value;	       ENDCASE => {SyntaxError[phrase, invalidOperand]; successful ¬ FALSE};	   moDoubleRead, moDoubleWrite => 	             SELECT mergedEncoding.mo.value FROM	       moA, moU => {trialEncoding.mo.value ¬ mergedEncoding.mo.value + 4; 	                    mergedEncoding.mo.value ¬ mergedEncoding.mo.value + 4};	       ENDCASE 	     ENDCASE  => {SyntaxError[phrase, invalidOperand]; successful ¬ FALSE}};              oldFA ¬ mergedEncoding.mo;      newFA ¬ trialEncoding.mo;      text ¬ "mo"L;      Field[];      mergedEncoding.mo ¬ newFA;      END;    IF trialEncoding.om.assignment.type # null THEN      BEGIN      oldFA ¬ mergedEncoding.om;      newFA ¬ trialEncoding.om;      text ¬ "om"L;      Field[];      mergedEncoding.om ¬ newFA;      END;    IF trialEncoding.aiu.assignment.type # null THEN      BEGIN      oldFA ¬ mergedEncoding.aiu;      newFA ¬ trialEncoding.aiu;      text ¬ "aiu"L;      Field[];      mergedEncoding.aiu ¬ newFA;      END;    IF trialEncoding.ail.assignment.type # null THEN      BEGIN      oldFA ¬ mergedEncoding.ail;      newFA ¬ trialEncoding.ail;      text ¬ "ail"L;      Field[];      mergedEncoding.ail ¬ newFA;      END;    IF trialEncoding.ac.assignment.type # null THEN      BEGIN      oldFA ¬ mergedEncoding.ac;      newFA ¬ trialEncoding.ac;      text ¬ "ac"L;      Field[];      mergedEncoding.ac ¬ newFA;      END;    IF trialEncoding.alu.assignment.type # null THEN        BEGIN      oldFA ¬ mergedEncoding.alu;      newFA ¬ trialEncoding.alu;      text ¬ "alu"L;           Field[];      mergedEncoding.alu ¬ newFA;      END;        IF trialEncoding.imu.assignment.type # null THEN      BEGIN      oldFA ¬ mergedEncoding.imu;      newFA ¬ trialEncoding.imu;      text ¬ "imu"L;      Field[];      mergedEncoding.imu ¬ newFA;      END;    IF trialEncoding.iml.assignment.type # null THEN      BEGIN      oldFA ¬ mergedEncoding.iml;      newFA ¬ trialEncoding.iml;      text ¬ "iml"L;      Field[];      mergedEncoding.iml ¬ newFA;      END;    IF trialEncoding.hiByte.assignment.type # null THEN      BEGIN      oldFA ¬ mergedEncoding.hiByte;      newFA ¬ trialEncoding.hiByte;      text ¬ "hiByte"L;      Field[];      mergedEncoding.hiByte ¬ newFA;      END;    IF trialEncoding.cycle.assignment.type # null THEN      BEGIN      oldFA ¬ mergedEncoding.cycle;      newFA ¬ trialEncoding.cycle;      text ¬ "cycle"L;      Field[];      mergedEncoding.cycle ¬ newFA;      END;    IF mergedEncoding.op.value = 2 AND expression THEN {      SyntaxError[phrase, invalidExpression];      successful ¬ FALSE};    mergedEncoding.isStk ¬ trialEncoding.isStk OR mergedEncoding.isStk;    mergedEncoding.isPop ¬ trialEncoding.isPop OR mergedEncoding.isPop;    mergedEncoding.isPush ¬ trialEncoding.isPush OR mergedEncoding.isPush;    RETURN;    END;  MergePhraseEncoding: PROCEDURE [phrase: PhrasePtr, mergedEncoding: EncodingPtr]    RETURNS [successful: BOOLEAN] =    BEGIN    -- Attempt to merge the Encoding of the phrase into the merged Encoding record.  Start with the first Encoding record for the Phrase.  If that doesn't work, try each successive Encoding record.  Return FALSE if none work.    trialEncoding: EncodingPtr;    nextPhrase: PhrasePtr;    savedEncoding: Encoding;    savedEncoding ¬ mergedEncoding­;  -- Save the merged Encoding so that we can restore it if this trial doesn't work.    trialEncoding ¬ phrase.encoding;  -- Try the first Encoding for this Phrase.  If this doesn't work, try the next Encoding for the Phrase, if there is one.    successful ¬ TRUE;  -- Assume this is going to work.    DO      IF MergeEncoding[phrase, mergedEncoding, trialEncoding] THEN        BEGIN  -- The Encoding of the current Phrase has been merged.        IF (nextPhrase ¬ phrase.nextPhrase) = NIL THEN RETURN[TRUE];        -- of every Phrase in the Statement has been merged.		        -- The Encoding of the current Phrase has been merged, and there is another Phrase in the Statement.  Call MergePhrase recursively, pointing to the next Phrase in the statement.        IF MergePhraseEncoding[nextPhrase, mergedEncoding] THEN RETURN;        END;  -- of current Phrase has been merged      -- The current Encoding for the Phrase did not work.  Restore the merged Encoding to what it was before this trial.        mergedEncoding­ ¬ savedEncoding;      -- See if there is another Encoding for this Phrase.  If not, this Phrase cannot be Encoded.  This does not necessarily mean the Statement cannot be Encoded.  If we back up, we may be able to encode a previous Phrase differently.      IF (trialEncoding ¬ trialEncoding.nextEncoding) = NIL THEN RETURN[FALSE];      ENDLOOP;    END;  MergeStatementEncoding: PUBLIC PROCEDURE [statement: StatementPtr]    RETURNS [successful: BOOLEAN] =    BEGIN    -- Create a single Encoding record by merging the Encoding records from each Phrase in the statement.  If any errors are detected, error messages will be queued on phrase.errorMsgs.    mergedEncoding: EncodingPtr;    mergedEncoding ¬ DsyAssembler.AllocateEncodingRecord[];    statement.encoding ¬ mergedEncoding;    successful ¬ MergePhraseEncoding[statement.firstPhrase, mergedEncoding];    -- We now have a merged Encoding record.    END;  -- MAIN LINE CODE  END...--Log of last edits:--JAC   	 5-Nov-84 14:22:01	fixed arrows for Mesa 11.1
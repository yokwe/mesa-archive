-- Copyright (C) 1984, 1985  by Xerox Corporation. All rights reserved. -- from PanelSWsB.mesa, HGM, 16-Mar-84 21:26:18-- JAC    31-May-85 16:54:15-- Arthur ayC :	28-Sep-84 12:23:59-- Frank FXB   :  2-Nov-84 10:04:52-- AMD:	22-Dec-82 11:14:06-- Mark: 22-Aug-80  2:27:34-- PXJ   : August 16, 1980  5:57 PM-- Last edit by PXO      on October 22, 1981  8:56 PM - Changed some procs to deal in longs.-- incremental display maintenanceDIRECTORY  Atom: TYPE USING [ATOM, MakeAtom],  Context USING [Find],  Cursor USING [Set],  Display: TYPE USING [Black, Block, Invert, Text, White],  Environment: TYPE USING [Block],  Heap: TYPE USING [systemZone],  Inline USING [DIVMOD],  Menu USING [Handle, Invoke, MCRType],  PanelSW USING [    ClientError, Handle, nilTileIndex, Object, RegisterSpec, ResolvePlaceToTile,    TileError, TileField, TileIndex, TileLayout, TileSpec],  PanelSWOps USING [    ActOnPanelProcType, ActOnTileProcType, BitFieldSpec, FindContext, FreeTile,    Handle, LockProcType, Object, PaintOp, Tile, TileFromSpec, TileObject],  Put USING [Blanks, Char, CR, Line, Text],  Selection USING [Convert],  String USING [    AppendString, CopyToNewString, Equivalent, Empty, ExpandString, InvalidNumber,    Length, StringBoundsFault, StringToNumber],  TIP: TYPE USING [    CreateTable, First, InvalidTable, NotifyProc, Results, Rest, Table],  ToolWindow USING [DisplayProcType],  UserTerminal: TYPE USING [BlinkDisplay],  Window USING [    Box, EnumerateInvalidBoxes, GetBox, Handle, InvalidateBox, Place, Validate],  WindowFont USING [CharWidth, Handle];CPPanelSWsB: MONITOR LOCKS h.lock USING h: PanelSWOps.Handle  IMPORTS    Atom, Context, Cursor, D: Display, Heap, Inline, Menu, PanelSW, PanelSWOps,    Put, Selection, String, TIP, UserTerminal, Window, WindowFont  EXPORTS PanelSW, PanelSWOps =  BEGIN  -- Standard preamble to hook up EXPORTed TYPEs  Object: PUBLIC TYPE = PanelSWOps.Object;  -- Global Data and STUFF  menuPNRDownPlace: Window.Place;  TwoFields: TYPE = RECORD [white, paint: PanelSWOps.BitFieldSpec];  ignoreTypeIn: BOOLEAN _ TRUE;  -- PUBLIC Procedures    AppendPanelData: PUBLIC ENTRY PROCEDURE [    textSW: Window.Handle, h: PanelSWOps.Handle] = {    ENABLE UNWIND => NULL;     dataInRow: BOOLEAN _ TRUE;    empty: BOOLEAN _ TRUE;    digitWidth: INTEGER = WindowFont.CharWidth['0, h.font];        Skip: PROCEDURE [length: CARDINAL, Used: CARDINAL] = {      blanks: INTEGER ¬ (length - 4)/digitWidth - Used;      IF blanks IN [0..100) THEN Put.Blanks[textSW, blanks];       };    IF h = NIL THEN RETURN;    FOR i: PanelSW.TileIndex IN [0..h.tiles.length) DO      IF i MOD h.numCols = 0 THEN {        empty _ TRUE;	IF dataInRow THEN Put.CR[textSW];        dataInRow _ FALSE;	FOR j: CARDINAL IN [0..h.numCols) DO	  IF h.tiles[i+j] # NIL THEN {empty _ FALSE; EXIT};	  ENDLOOP;	};      IF empty THEN LOOP;      IF i MOD h.numCols # 0 THEN Put.Blanks[textSW, 1];      IF h.tiles[i] = NIL THEN {        Put.Blanks[textSW, 1]; -- flag        Skip[h.rowDesc[i MOD h.numCols][left], 0];        Skip[h.rowDesc[i MOD h.numCols][right], 0];	LOOP;      };      dataInRow _ TRUE;      Put.Char[textSW, SELECT h.tiles[i].state FROM          bogus => '~,          changed => '*,          old => ' ,          ENDCASE => ERROR];      IF h.tiles[i].lh = NIL THEN	Skip[h.rowDesc[i MOD h.numCols][left], 0]      ELSE {        Put.Text[textSW, h.tiles[i].lh];	Skip[h.rowDesc[i MOD h.numCols][left], h.tiles[i].lh.length];      };      IF h.tiles[i].rh = NIL THEN  	Skip[h.rowDesc[i MOD h.numCols][right], 0]      ELSE {	Skip[h.rowDesc[i MOD h.numCols][right], h.tiles[i].rh.length];        Put.Text[textSW, h.tiles[i].rh];      };      ENDLOOP;    Put.CR[textSW];    };      Clear: PUBLIC PanelSWOps.ActOnPanelProcType = {    LockedFreeAllTiles: ENTRY PanelSWOps.LockProcType = {      ENABLE UNWIND => NULL;      FOR i: PanelSW.TileIndex IN [0..h.tiles.length) DO        PanelSWOps.FreeTile[h.tiles[i], h.cProcs.freeRS];        h.tiles[i] _ NIL        ENDLOOP};    IF h # NIL THEN {LockedFreeAllTiles[h]; Display[h]}};  ClearTile: PUBLIC PanelSWOps.ActOnTileProcType = {    LockedFreeTile: ENTRY PanelSWOps.LockProcType = {      ENABLE UNWIND => NULL;      PanelSWOps.FreeTile[h.tiles[ts.index], h.cProcs.freeRS];      h.tiles[ts.index] _ NIL};    IF h # NIL THEN {LockedFreeTile[h]; DisplayTile[h, ts]}};  Display: PUBLIC PanelSWOps.ActOnPanelProcType = {    IF h # NIL THEN {      h.sw.InvalidateBox[[[0, 0], h.sw.GetBox.dims], isDirty]; h.sw.Validate}};  DisplayTile: PUBLIC PanelSWOps.ActOnTileProcType = {    LockedDisplayTile: ENTRY PanelSWOps.LockProcType = {      ENABLE UNWIND => NULL;      isCurrent: BOOLEAN;      IF ts.index >= h.tiles.length THEN RETURN;      isCurrent _ (ts.index = h.current.index AND h.marked);      InternalDisplayTile[        h, ts.index, h.tiles[ts.index], [white: ALL[TRUE], paint: ALL[TRUE]]];      IF isCurrent THEN {h.marked _ FALSE; MarkCurrent[h]}};    IF h # NIL THEN LockedDisplayTile[h]};  ReadTile: PUBLIC PROC [h: PanelSWOps.Handle, ts: PanelSW.TileSpec]    RETURNS [s: LONG STRING] = {    tile: PanelSWOps.Tile = PanelSWOps.TileFromSpec[h, ts];    LockedReadTile: ENTRY PanelSWOps.LockProcType = {      ENABLE UNWIND => NULL; ReadTarget[h, ts]};    s _ NIL;    -- this is not safe in the face of preemptive processes!!!    IF tile # NIL THEN {LockedReadTile[h]; DisplayTile[h, ts]; RETURN[tile.rh]}};  StringFromTile: PUBLIC PROC [h: PanelSWOps.Handle, ts: PanelSW.TileSpec]    RETURNS [s: LONG STRING] = {    tile: PanelSWOps.Tile = PanelSWOps.TileFromSpec[h, ts];    -- this is not safe in the face of preemptive processes!!!    RETURN[      IF tile = NIL THEN NIL ELSE IF ts.field = right THEN tile.rh ELSE tile.lh]};  Update: PUBLIC PanelSWOps.ActOnPanelProcType = {    LockedUpdate: ENTRY PanelSWOps.LockProcType = {      ENABLE UNWIND => NULL;      fields: TwoFields _ [white: ALL[FALSE], paint: ALL[FALSE]];      tile: PanelSWOps.Tile;      i, j: PanelSW.TileIndex;      IF h.marked THEN UnmarkCurrent[h];      FOR i IN [0..h.numCols) DO  -- try to use same CP overlay in Burdock        D.White[          h.sw, [          [x: h.rowPlaceDesc[i][flag], y: 0], [          w: h.rowDesc[i][flag], h: h.sw.GetBox.dims.h]]];  -- Clear all flags        FOR j _ i, j + h.numCols UNTIL j >= h.tiles.length DO          ReadTarget[            h, [field: right, index: j] !            PanelSW.ClientError => {              Put.CR[h.err]; Put.Line[h.err, msg]; CONTINUE}];          IF (tile _ h.tiles[j]) # NIL THEN {            fields.paint[flag] _ (tile.state # old);            fields.paint[right] _ fields.white[right] _ (tile.state = changed);            InternalDisplayTile[h, j, tile, fields]};          ENDLOOP;        ENDLOOP;      MarkCurrent[h]};    IF h # NIL THEN LockedUpdate[h]};  UpdateTile: PUBLIC PanelSWOps.ActOnTileProcType = {    LockedUpdateTile: ENTRY PanelSWOps.LockProcType = {      ENABLE UNWIND => NULL;      isCurrent: BOOLEAN = (h.current.index = ts.index);      tile: PanelSWOps.Tile;      IF isCurrent AND h.marked THEN UnmarkCurrent[h];      ReadTarget[h, ts];      IF (tile _ h.tiles[ts.index]) # NIL THEN {        fields: PanelSWOps.BitFieldSpec _ [          flag: TRUE, left: FALSE, right: (tile.state = changed)];        InternalDisplayTile[h, ts.index, tile, [fields, fields]]};      IF isCurrent THEN MarkCurrent[h]};    IF h # NIL THEN LockedUpdateTile[h]};  InternalDisplayTile: INTERNAL PROC [    h: PanelSWOps.Handle, ti: PanelSW.TileIndex, tile: PanelSWOps.Tile,    fields: TwoFields] = {    col: CARDINAL;    row: CARDINAL;    rowDesc, rowPlaceDesc: LONG POINTER TO PanelSW.TileLayout;    x, y, w: INTEGER;    s: LONG STRING;    [row, col] _ Inline.DIVMOD[ti, h.numCols];    IF fields.white # ALL[FALSE] THEN      DoSomethingToFields[h, col, row, fields.white, whiten];    IF tile = NIL THEN RETURN;    y _ row * h.lineHeight;    rowDesc _ h.rowDesc[col].BASE;    rowPlaceDesc _ h.rowPlaceDesc[col].BASE;    IF fields.paint[flag] THEN {      s _        SELECT tile.state FROM          bogus => "~"L,          changed => "*"L,          old => NIL,          ENDCASE => ERROR;      IF s # NIL THEN {        x _ rowPlaceDesc[flag];        w _ rowDesc[flag];        [] _ D.Text[          window: h.sw, string: s, place: [x, y], font: h.font, lineLength: w]}};    IF fields.paint[left] THEN {      IF (s _ tile.lh) # NIL THEN {        x _ rowPlaceDesc[left];        w _ rowDesc[left];        [] _ D.Text[          window: h.sw, string: s, place: [x, y], font: h.font, lineLength: w]}};    IF fields.paint[right] THEN {      IF (s _ tile.rh) # NIL THEN {        spacer: INTEGER = 5;        fieldW: INTEGER = rowDesc[right];        block: Environment.Block _ [LOOPHOLE[@s.text], 0, s.length];        charW: INTEGER;        -- First figure out how long it is (for right justification)        w _ spacer;        FOR i: CARDINAL DECREASING IN [0..s.length) DO          IF w + (charW _ WindowFont.CharWidth[s[i], h.font]) > fieldW THEN {            IF w = spacer THEN GOTO Bogus;            block.startIndex _ block.startIndex.SUCC;            EXIT};          w _ w + charW;          REPEAT FINISHED => block.startIndex _ 0;          ENDLOOP;        x _ rowPlaceDesc[right] + fieldW - w;        [] _ D.Block[          window: h.sw, block: block, lineLength: w, place: [x, y],          font: h.font]};      EXITS Bogus => NULL}};  WriteTile: PUBLIC PROC [    h: PanelSWOps.Handle, ts: PanelSW.TileSpec, s: LONG STRING,    normalize: BOOLEAN] = {    leftWriteLost: BOOLEAN _ TRUE;    tile: PanelSWOps.Tile;    newVal: LONG STRING _ NIL;    regSpec: PanelSW.RegisterSpec _ NIL;    LockedStartTile: ENTRY PanelSWOps.LockProcType = {      ENABLE UNWIND => NULL;      tile _ h.tiles[ts.index];      IF ts.field = left THEN DoLeftTile[]      ELSE        IF tile # NIL THEN {          -- set up for outward call without monitor protection          regSpec _ tile.regSpec; tile.regSpec _ NIL; }};  	  -- now regSpec is only copy in existence    DoLeftTile: INTERNAL PROC = {      -- I think UNWINDing out of the next line is ok.  /HGM      [newVal, regSpec] _ h.cProcs.lhTypeInEval[ts, s, normalize];      leftWriteLost _ (newVal = NIL);      IF tile # NIL THEN {        -- Reset tile (except for rh)        Heap.systemZone.FREE[@tile.lh];        h.cProcs.freeRS[tile.regSpec];        tile.regSpec _ NIL;        IF leftWriteLost THEN {          -- Free up tile          Heap.systemZone.FREE[@tile.rh];          Heap.systemZone.FREE[@tile];          h.tiles[ts.index] _ NIL}};      IF ~leftWriteLost THEN {        IF tile = NIL THEN          h.tiles[ts.index] _ tile _ Heap.systemZone.NEW[            PanelSWOps.TileObject _ []];        tile.lh _ newVal;        newVal _ h.cProcs.readTarget[regSpec, TRUE]};      FinalizeTile[]};    LockedNewValue: ENTRY PanelSWOps.LockProcType = {      ENABLE UNWIND => NULL;      tile _ h.tiles[ts.index];  -- might have been zapped      FinalizeTile[]};    FinalizeTile: INTERNAL PROC = {      fields: PanelSWOps.BitFieldSpec _ ALL[TRUE];      isCurrent: BOOLEAN = (h.current.index = ts.index AND h.marked);      IF tile # NIL THEN {        IF tile.regSpec # NIL THEN RETURN;  -- oops, zapped!        tile.regSpec _ regSpec;  -- put only copy back        NewValue[tile, newVal];        fields[right] _ (tile.state = changed);        IF ts.field = left THEN {IF tile.state = old THEN tile.state _ changed}        ELSE fields[left] _ FALSE};      IF isCurrent AND fields # ALL[TRUE] THEN InvertCurrent[h];      InternalDisplayTile[h, ts.index, tile, [fields, fields]];      IF isCurrent THEN {h.marked _ FALSE; InvertCurrent[h]}};    IF h # NIL AND ts.index < h.tiles.length THEN {      LockedStartTile[h];      IF ts.field = right AND tile # NIL AND regSpec # NIL THEN {        newVal _ h.cProcs.rhTypeInEval[          ts, s, regSpec ! UNWIND => LockedNewValue[h]];        LockedNewValue[h]};      IF newVal = NIL THEN ERROR PanelSW.TileError[readFailed, ts]}};  -- Semi-PUBLIC PROCs  DisplayProc: PUBLIC ToolWindow.DisplayProcType = {    h: PanelSWOps.Handle = PanelSWOps.FindContext[window];    DoAnInvalidBox: PROC [wh: Window.Handle, box: Window.Box] = {      LockedDisplayProc: ENTRY PanelSWOps.LockProcType = {        ENABLE UNWIND => NULL;        topLeft, bottomRight: PanelSW.TileSpec;        leftCol, rightCol, offset, curIndex: PanelSW.TileIndex;        isCurrent: BOOLEAN;        [topLeft, bottomRight] _ DetermineAffectedTiles[h, @box];        IF topLeft.index = PanelSW.nilTileIndex THEN RETURN;        leftCol _ topLeft.index MOD h.numCols;        rightCol _ bottomRight.index MOD h.numCols;        offset _ 0;        THROUGH [leftCol..rightCol] DO  -- do col at a time          FOR curIndex _ topLeft.index + offset, curIndex + h.numCols UNTIL            curIndex > bottomRight.index DO            IF (isCurrent _ (h.current.index = curIndex)) AND h.marked THEN {              DoSomethingToCurrent[h, whiten]; h.marked _ FALSE};            InternalDisplayTile[  -- do partial tiles, but for now...              h, curIndex, h.tiles[curIndex], [              white: ALL[FALSE], paint: ALL[TRUE]]];            IF isCurrent THEN InvertCurrent[h];            ENDLOOP;          offset _ offset + 1;          ENDLOOP};      LockedDisplayProc[h]};    IF h # NIL THEN window.EnumerateInvalidBoxes[DoAnInvalidBox]};  PaintTile: PUBLIC PROC [h: PanelSWOps.Handle, tile: PanelSW.TileIndex] = {    LockedPaintTile: ENTRY PanelSWOps.LockProcType = {      ENABLE UNWIND => NULL;      isCurrent: BOOLEAN;      IF tile >= h.tiles.length THEN RETURN;      IF (isCurrent _ (h.current.index = tile)) AND h.marked THEN        UnmarkCurrent[h];      InternalDisplayTile[        h, tile, h.tiles[tile], [white: ALL[FALSE], paint: ALL[TRUE]]];      IF isCurrent THEN MarkCurrent[h]};    IF h # NIL THEN LockedPaintTile[h]};  TileWidth: PUBLIC PROC [h: PanelSWOps.Handle, tile: PanelSW.TileIndex]    RETURNS [w: CARDINAL] = {    tileLayout: LONG POINTER TO PanelSW.TileLayout = h.rowDesc[      tile MOD h.numCols].BASE;    w _ 0;    FOR tf: PanelSW.TileField IN PanelSW.TileField DO      w _ w + tileLayout[tf]; ENDLOOP};  -- Maintaining the "current" tile  InvertCurrent: PUBLIC INTERNAL PanelSWOps.ActOnPanelProcType = {    -- Caller guarantees h # NIL and h.current.index < h.tiles.length.    DoSomethingToCurrent[h, invert]; h.marked _ ~h.marked};  DoSomethingToCurrent: PUBLIC INTERNAL PROC [    h: PanelSWOps.Handle, op: PanelSWOps.PaintOp] = {    -- Caller guarantees h # NIL and h.current.index < h.tiles.length.    col, row: PanelSW.TileIndex;    fields: PanelSWOps.BitFieldSpec;    [row, col] _ Inline.DIVMOD[h.current.index, h.numCols];    FOR tf: PanelSW.TileField IN PanelSW.TileField DO      fields[tf] _ (h.current.field = tf) ENDLOOP;    DoSomethingToFields[h, col, row, fields, op]};  DoSomethingToFields: PUBLIC INTERNAL PROC [    h: PanelSWOps.Handle, col, row: PanelSW.TileIndex,    fields: PanelSWOps.BitFieldSpec, op: PanelSWOps.PaintOp] = {    y: INTEGER = row * h.lineHeight;    rowDesc: LONG POINTER TO PanelSW.TileLayout = h.rowDesc[col].BASE;    rowPlaceDesc: LONG POINTER TO PanelSW.TileLayout = h.rowPlaceDesc[col].BASE;    FOR tf: PanelSW.TileField IN PanelSW.TileField DO      IF fields[tf] THEN {        -- start here        x: INTEGER _ rowPlaceDesc[tf];        w: INTEGER _ rowDesc[tf];        FOR tfInner: PanelSW.TileField IN (tf..PanelSW.TileField.LAST] DO          IF ~fields[tfInner] THEN EXIT;          w _ w + rowDesc[tfInner];          fields[tfInner] _ FALSE;  -- mark these fields as done          ENDLOOP;        (SELECT op FROM           whiten => D.White,           blacken => D.Black,           invert => D.Invert,           ENDCASE => ERROR)[h.sw, [[x: x, y: y], [w: w, h: h.lineHeight]]]};      REPEAT FINISHED => RETURN;      ENDLOOP};  MarkCurrent: PUBLIC INTERNAL PanelSWOps.ActOnPanelProcType = {    -- Caller guarantees h # NIL.    IF h.current.index < h.tiles.length AND ~h.marked THEN InvertCurrent[h]};  UnmarkCurrent: PUBLIC INTERNAL PanelSWOps.ActOnPanelProcType = {    -- Caller guarantees h # NIL.    IF h.current.index < h.tiles.length AND h.marked THEN InvertCurrent[h]};  -- TIP stuff and MCRTypes  table: TIP.Table _ NIL;  track, enter, exit, plusOne, minusOne, writeSelection, fillColumn,    unmarkAndInvokeMenu, modifyTypeIn: Atom.ATOM _ NIL;  GetTable: PUBLIC PROC RETURNS [TIP.Table] = {    IF table = NIL THEN {      track _ Atom.MakeAtom["Track"L];      enter _ Atom.MakeAtom["Enter"L];      exit _ Atom.MakeAtom["Exit"L];      plusOne _ Atom.MakeAtom["PlusOne"L];      minusOne _ Atom.MakeAtom["MinusOne"L];      writeSelection _ Atom.MakeAtom["WriteSelection"L];      fillColumn _ Atom.MakeAtom["FillColumn"L];      unmarkAndInvokeMenu _ Atom.MakeAtom["UnmarkAndInvokeMenu"L];      modifyTypeIn _ Atom.MakeAtom["ModifyTypeIn"L];      table _ TIP.CreateTable[        file: "PanelSW.TIP"L,        contents:        "-- PanelSW.TIP, created by Burdock-- Version of 11-Feb-83 18:22:17SELECT TRIGGER FROM  MOUSE => COORDS, Track;    Point Down => SELECT TRIGGER FROM    Adjust Down BEFORE 250 =>      SELECT ENABLE FROM        LeftShift Down => COORDS, FillColumn;        ENDCASE => COORDS, UnmarkAndInvokeMenu;    ENDCASE => SELECT ENABLE FROM      LeftShift Down => COORDS, PlusOne;      ENDCASE => COORDS, WriteSelection;    Menu Down => SELECT ENABLE FROM    LeftShift Down => COORDS, FillColumn;    ENDCASE => COORDS, UnmarkAndInvokeMenu;  MENU Down => SELECT ENABLE FROM    LeftShift Down => COORDS, FillColumn;    ENDCASE => COORDS, UnmarkAndInvokeMenu;    Adjust Down => SELECT TRIGGER FROM    Point Down BEFORE 250 =>      SELECT ENABLE FROM        LeftShift Down => COORDS, FillColumn;        ENDCASE => COORDS, UnmarkAndInvokeMenu;    ENDCASE => SELECT ENABLE FROM      LeftShift Down => COORDS, MinusOne;      ENDCASE => COORDS, ModifyTypeIn;      ENTER => Enter;  EXIT => Exit;    ENDCASE..."L        ! TIP.InvalidTable => {UserTerminal.BlinkDisplay[]; RESUME }]};    RETURN[table]};  TIPMe: PUBLIC TIP.NotifyProc = {    h: PanelSWOps.Handle = PanelSWOps.FindContext[window];    place: Window.Place;    IF h = NIL THEN RETURN;    FOR r: TIP.Results _ results, r.Rest UNTIL r = NIL DO      WITH z: r.First SELECT FROM        coords => place _ z.place;        atom =>          SELECT z.a FROM            track => Track[h, place];            enter => {              Cursor.Set[textPointer];              h.lastPlace _ [INTEGER.LAST, INTEGER.LAST]};            exit => {              LockedUnmarkCurrent: ENTRY PanelSWOps.LockProcType = {                ENABLE UNWIND => NULL;                UnmarkCurrent[h];                h.current.index _ PanelSW.nilTileIndex};              LockedUnmarkCurrent[h]};            plusOne => {              menuPNRDownPlace _ place; PlusOne[window, NIL, CARDINAL.LAST]};            minusOne => {              menuPNRDownPlace _ place; MinusOne[window, NIL, CARDINAL.LAST]};            writeSelection => WriteSelection[h, place];            fillColumn => {              menuPNRDownPlace _ place; FillColumn[window, NIL, CARDINAL.LAST]};            unmarkAndInvokeMenu => {              LockedUnmarkCurrent: ENTRY PanelSWOps.LockProcType = {                ENABLE UNWIND => NULL;                UnmarkCurrent[h];                h.current.index _ PanelSW.nilTileIndex};              marked: BOOLEAN;              menuPNRDownPlace _ place;              IF (marked _ (h.current.index # PanelSW.nilTileIndex AND h.marked))                THEN LockedUnmarkCurrent[h];              Menu.Invoke[window, place]};            modifyTypeIn => {              ts: PanelSW.TileSpec _ PanelSW.ResolvePlaceToTile[h, place, FALSE];              tile: PanelSWOps.Tile;              h.cProcs.modifyTypeIn[                IF ts.index >= h.tiles.length OR (tile _ h.tiles[ts.index]) = NIL                THEN NIL ELSE IF ts.field = right THEN tile.rh ELSE tile.lh,                FALSE]};            ENDCASE;        ENDCASE;      ENDLOOP};  Track: PROC [h: PanelSWOps.Handle, place: Window.Place] = {    LockedTrack: ENTRY PanelSWOps.LockProcType = {      ENABLE UNWIND => NULL;      ts: PanelSW.TileSpec;      IF place = h.lastPlace THEN RETURN;      h.lastPlace _ place;      ts _ PanelSW.ResolvePlaceToTile[h, place, FALSE];      IF ts.field = flag THEN ts.field _ left;      IF ts # h.current THEN UnmarkCurrent[h];      IF ts.index < h.tiles.length THEN {h.current _ ts; MarkCurrent[h]}};    LockedTrack[h]};  WriteSelection: PROC [h: PanelSWOps.Handle, place: Window.Place] = {    ts: PanelSW.TileSpec;    selection: LONG STRING _ Selection.Convert[string];    text: LONG STRING _ NIL;    text _ selection;        IF String.Empty[text] AND h.typeIn = NIL THEN RETURN     ELSE IF selection = NIL THEN text _ h.typeIn^;    ts _ PanelSW.ResolvePlaceToTile[h, place, FALSE];    IF ts.index = PanelSW.nilTileIndex THEN RETURN;    IF ts.field = flag THEN ts.field _ left;        WriteTile[      h, ts, text, FALSE ! PanelSW.TileError => CONTINUE;      PanelSW.ClientError => {Put.CR[h.err]; Put.Line[h.err, msg]; CONTINUE}];    IF selection # NIL THEN Heap.systemZone.FREE[@selection]};  FillColumn: PUBLIC Menu.MCRType = {    count: CARDINAL _ CARDINAL.LAST;    h: PanelSWOps.Handle;    ts: PanelSW.TileSpec;    tile: PanelSWOps.Tile;    s: LONG STRING;    suffix: LONG STRING;    clearing: BOOLEAN;    TryThisString: PROC RETURNS [LONG STRING] = {      String.ExpandString[@s, 20, Heap.systemZone]; RETURN[s]};    IF (h _ PanelSWOps.FindContext[window]) = NIL THEN RETURN;    ts _ PanelSW.ResolvePlaceToTile[h, menuPNRDownPlace, FALSE];    IF ts.index = PanelSW.nilTileIndex THEN RETURN;    clearing _ (tile _ h.tiles[ts.index]) = NIL OR tile.lh = NIL;    IF ts.field = flag THEN ts.field _ left;    IF h.typeIn # NIL AND h.typeIn^ # NIL THEN      count _ String.StringToNumber[        h.typeIn^, 10 ! String.InvalidNumber => CONTINUE];    --IF count = 0 THEN RETURN;   What a turkey user!    -- changed so that column will be filled even if there is bad data in typeIn    IF clearing THEN s _ NIL    ELSE {      side: LONG STRING = (IF ts.field = left THEN tile.lh ELSE tile.rh);      s _ String.CopyToNewString[        side, Heap.systemZone, 100 - String.Length[side]]};    IF h.increment # NIL AND h.increment^ = 2 THEN suffix _ "+2"L     ELSE suffix _ "+1"L;    FOR i: CARDINAL IN [1..count] DO      IF (ts.index _ ts.index + h.numCols) >= h.tiles.length THEN EXIT;      IF clearing THEN {ClearTile[h, ts]; LOOP};      IF ts.field = left THEN        String.AppendString[          s, suffix ! String.StringBoundsFault => RESUME [TryThisString[]]];      WriteTile[        h, ts, s, TRUE ! PanelSW.TileError => EXIT;        PanelSW.ClientError => {Put.CR[h.err]; Put.Line[h.err, msg]; EXIT};        UNWIND => Heap.systemZone.FREE[@s]];      IF (tile _ h.tiles[ts.index]) = NIL OR tile.lh = NIL THEN EXIT;      IF ts.field = left THEN {        s.length _ 0;        String.AppendString[          s, tile.lh ! String.StringBoundsFault => RESUME [TryThisString[]]]};      ENDLOOP;    IF ~clearing THEN {      Heap.systemZone.FREE[@s];      IF (tile _ h.tiles[ts.index - h.numCols]) # NIL AND tile.lh # NIL THEN        IF ts.field = left THEN h.cProcs.modifyTypeIn[tile.lh, TRUE]}};  MinusOne: PUBLIC Menu.MCRType = {PlusOrMinusOne[window, minus]};  PlusOne: PUBLIC Menu.MCRType = {PlusOrMinusOne[window, plus]};  UpdateMCR: PUBLIC Menu.MCRType = {Update[PanelSWOps.FindContext[window]]};  MenuPNRDownPlace: PUBLIC PROC [h: PanelSWOps.Handle]    RETURNS [place: Window.Place] = {place _ menuPNRDownPlace};  ModifyLH: PUBLIC PROC [    h: PanelSWOps.Handle, ts: PanelSW.TileSpec, suffix: LONG STRING] = {    RealModifyLH[h, ts, suffix, FALSE]};  -- PRIVATE PROCs  DetermineAffectedTiles: PROC [h: PanelSWOps.Handle, box: POINTER TO Window.Box]    RETURNS [topLeft, bottomRight: PanelSW.TileSpec] = {    topLeft _ PanelSW.ResolvePlaceToTile[h, box.place, FALSE];    bottomRight _      IF topLeft.index = PanelSW.nilTileIndex THEN topLeft      ELSE PanelSW.ResolvePlaceToTile[        h, [x: box.place.x + box.dims.w - 1, y: box.place.y + box.dims.h - 1],        TRUE]};  NewValue: INTERNAL PROC [tile: PanelSWOps.Tile, new: LONG STRING] = {    IF new = NIL THEN tile.state _ bogus    ELSE {      tile.state _ IF String.Equivalent[tile.rh, new] THEN old ELSE changed;      IF tile.rh # NIL THEN Heap.systemZone.FREE[@tile.rh];      tile.rh _ new}};  PlusOrMinusOne: PROC [sw: Window.Handle, polarity: {plus, minus}] = {    h: PanelSWOps.Handle;    ts: PanelSW.TileSpec;    suffix: LONG STRING;    IF (h _ PanelSWOps.FindContext[sw]) = NIL THEN RETURN;    SELECT polarity FROM      plus => IF h.increment # NIL AND h.increment^ = 2 THEN suffix _ "+2"L              ELSE suffix _ "+1"L;      minus => IF h.increment # NIL AND h.increment^ = 2 THEN suffix _ "-2"L              ELSE suffix _ "-1"L;      ENDCASE => ERROR;              ts _ PanelSW.ResolvePlaceToTile[h, menuPNRDownPlace, FALSE];    RealModifyLH[      h, ts, suffix, TRUE ! PanelSW.TileError => CONTINUE;      PanelSW.ClientError => {Put.CR[h.err]; Put.Line[h.err, msg]; CONTINUE}]};  ReadTarget: INTERNAL PanelSWOps.ActOnTileProcType = {    tile: PanelSWOps.Tile = h.tiles[ts.index];    newRh: LONG STRING;    IF tile = NIL THEN RETURN;    newRh _ h.cProcs.readTarget[tile.regSpec, FALSE];    NewValue[tile, newRh]};  RealModifyLH: PROC [    h: PanelSWOps.Handle, ts: PanelSW.TileSpec, suffix: LONG STRING,    fudgeNil: BOOLEAN] = {    tile: PanelSWOps.Tile = PanelSWOps.TileFromSpec[h, ts];    s: LONG STRING;    IF tile = NIL OR tile.lh = NIL THEN      IF fudgeNil THEN {        IF h.typeIn # NIL THEN          s _ String.CopyToNewString[h.typeIn^, Heap.systemZone, suffix.length]}      ELSE RETURN    ELSE      s _ String.CopyToNewString[        h.tiles[ts.index].lh, Heap.systemZone, suffix.length];    String.AppendString[s, suffix];    ts.field _ left;    WriteTile[h, ts, s, TRUE];    Heap.systemZone.FREE[@s];    h.cProcs.modifyTypeIn[h.tiles[ts.index].lh, TRUE]};  END.  -- of PanelSWsB.mesa    LOG  FXB     1-Feb-84 21:57:19 - Corrected FREEing of NIL pointer in NewValue  FXB     16-Mar-84 20:49:39 - Added AppendPanelData  FXB    18-Mar-84 15:31:49 - fixed FillColumn so that column would be filled even if there is an invalid number in the typeIn  
-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved. -- Last edit by JAC   		   15-Jan-86 15:10:15-- CPKernelWriteImpl.mesa, AYC   , 13-Dec-84 11:27:15-- from CPKernelCommon.mesa,  HGM, 27-Oct-83  2:25:02--DIRECTORY  Inline USING [BITAND, HighHalf, LowHalf],  Runtime USING [GetTableBase],  CPDef USING [    AReg, DReg, Link, Map, mapOffset, OtherReg, RReg, ROffset, STACK,    StkDomain, StkRange, StartAddr, StartAddrPlusOne, VirturalMemory, wordsPerBank],  CPCommand USING [RefreshWindow],  CPKernel USING [Error, ReadMemoryWord, savedBank, StartSirius, StopSirius, WriteMemoryWord],  CPKernelDef,  CPKernelOps USING [AddressOutOfRange, LoadOverlay, MapAddress, SetShiftRegInternal,   WriteCSInternal],  CPuFormat,  KernelMicrocode USING [KernelOverlay, WriteLink];CPKernelWriteImpl: MONITOR  IMPORTS    Inline, Runtime,    CPCommand, CPKernel, CPKernelOps, CPuFormat, KernelMicrocode  EXPORTS CPKernel, CPKernelOps =  BEGIN OPEN CPKernelDef, CPuFormat;    Error: PUBLIC ERROR [reason: LONG STRING] = CODE;    WriteRReg: PUBLIC ENTRY PROCEDURE [r: CPDef.RReg, data: WORD] =    BEGIN ENABLE UNWIND => NULL;    --    -- RDestination: r ¬ MD, GOTO[Return], c2, at[0FE2];    --    WriteRRegInternal[r, data];    END;     WriteRRegInternal: INTERNAL PROCEDURE [r: CPDef.RReg, data: WORD] =    BEGIN ENABLE UNWIND => NULL;    IF r ~IN CPDef.RReg THEN AddressOutOfRange[];    CPKernel.WriteMemoryWord[kMailBox, data];    CPKernelOps.WriteCSInternal[      kRDestination + CPKernel.savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[0,ZeroA,ZeroB,noopD, , ,        noopSp2,noopSp1,noopDsp,kReturn,]];    CPKernelOps.WriteCSInternal[      kReturn + CPKernel.savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[0,ZeroA,r+CPDef.ROffset,rBsame,	AplusBplusCin,,Ureg,noopSp1,noopDsp,kWait,]];    CPKernelOps.SetShiftRegInternal[CPDef.StartAddr,kWriteState + CPKernel.savedBank * CPDef.wordsPerBank];    CPKernelOps.SetShiftRegInternal[CPDef.StartAddrPlusOne,kWriteState+1 + CPKernel.savedBank * CPDef.wordsPerBank];    CPKernel.StartSirius[];    Pause[];    [] ¬ CPKernel.StopSirius[];    CPKernelOps.WriteCSInternal[      kReturn + CPKernel.savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[0,ZeroA,ZeroB,noopD, , ,        noopSp2,noopSp1,noopDsp,kWait,]];    END;  WriteDReg: PUBLIC ENTRY PROCEDURE [d: CPDef.DReg, data: WORD] =    BEGIN ENABLE UNWIND => NULL;    --    -- RDestination: r ¬ MD, GOTO[Return], c1, at[0FE2];    --    IF d ~IN CPDef.DReg THEN AddressOutOfRange[];    CPKernel.WriteMemoryWord[kMailBox, data];    CPKernelOps.WriteCSInternal[      kRDestination + CPKernel.savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[0,ZeroA,ZeroB,noopD, , ,        noopSp2,noopSp1,noopDsp,kReturn,]];    CPKernelOps.WriteCSInternal[      kReturn + CPKernel.savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[      0,ZeroA,ZeroB,d,AplusBplusCin,,Ureg,noopSp1,noopDsp,kWait,]];    CPKernelOps.SetShiftRegInternal[CPDef.StartAddr,kWriteState + CPKernel.savedBank * CPDef.wordsPerBank];    CPKernelOps.SetShiftRegInternal[CPDef.StartAddrPlusOne,kWriteState+1 + CPKernel.savedBank * CPDef.wordsPerBank];    CPKernel.StartSirius[];    Pause[];    [] ¬ CPKernel.StopSirius[];    CPKernelOps.WriteCSInternal[      kReturn + CPKernel.savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[0,ZeroA,ZeroB,noopD, , ,        noopSp2,noopSp1,noopDsp,kWait,]];    END;   WriteAReg: PUBLIC ENTRY PROCEDURE [a: CPDef.AReg, data: LONG POINTER] =    BEGIN ENABLE UNWIND => NULL;    datahigh: WORD ¬ Inline.HighHalf[data];    datalow: WORD ¬ Inline.LowHalf[data];    highfield: CARDINAL = 24;    lowfield: CARDINAL = 40;    --    -- Write in two parts: A[23..8] first, then A[15..0]    -- RDestination: A.page ¬ MD, GOTO[Return], c1, at[0FE2];    -- RDestination: A.low ¬ MD, GOTO[Return], c1, at[0FE2];    --    IF a ~IN CPDef.AReg THEN AddressOutOfRange[];    datahigh ¬ Inline.BITAND[datahigh, 000FFH];    IF a = aMailBox THEN      BEGIN      WriteRRegInternal[raSaveHi - CPDef.ROffset, datahigh];      WriteRRegInternal[raSaveLow - CPDef.ROffset, datalow];      RETURN;      END;    CPKernel.WriteMemoryWord[kMailBox, datahigh];    CPKernelOps.WriteCSInternal[      kRDestination + CPKernel.savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[0,ZeroA,ZeroB,noopD, , ,        noopSp2,noopSp1,noopDsp,kReturn,]];    CPKernelOps.WriteCSInternal[      kReturn + CPKernel.savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[      0,ZeroA,ZeroB,a+highfield,AplusBplusCin,,Ureg,noopSp1,noopDsp,kWait,]];    CPKernelOps.SetShiftRegInternal[CPDef.StartAddr,kWriteState + CPKernel.savedBank * CPDef.wordsPerBank];    CPKernelOps.SetShiftRegInternal[CPDef.StartAddrPlusOne,kWriteState+1 + CPKernel.savedBank * CPDef.wordsPerBank];    CPKernel.StartSirius[];    Pause[];    [] ¬ CPKernel.StopSirius[];    CPKernel.WriteMemoryWord[kMailBox, datalow];    CPKernelOps.WriteCSInternal[      kReturn + CPKernel.savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[      0,ZeroA,ZeroB,a+lowfield,AplusBplusCin,,Ureg,noopSp1,noopDsp,kWait,]];    CPKernelOps.SetShiftRegInternal[CPDef.StartAddr,kWriteState + CPKernel.savedBank * CPDef.wordsPerBank];    CPKernelOps.SetShiftRegInternal[CPDef.StartAddrPlusOne,kWriteState+1 + CPKernel.savedBank * CPDef.wordsPerBank];    CPKernel.StartSirius[];    Pause[];    [] ¬ CPKernel.StopSirius[];    CPKernelOps.WriteCSInternal[      kReturn + CPKernel.savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[0,ZeroA,ZeroB,noopD, , ,        noopSp2,noopSp1,noopDsp,kWait,]];    END;    WriteLink: PUBLIC ENTRY PROCEDURE [link: CPDef.Link, data: Nibble] =    BEGIN ENABLE UNWIND => NULL;    kWriteLink: CARDINAL ¬ kLinkTable + data;    mask: CARDINAL = 4;    --    -- Overlay WriteLink.mc    --     -- kLinkTable+data: Ln ¬ data, at[0FEF+data];    --    IF link NOT IN CPDef.Link THEN AddressOutOfRange[];    IF data NOT IN Nibble THEN DataOutOfRange[];    CPKernelOps.LoadOverlay[Runtime.GetTableBase[KernelMicrocode.WriteLink]];    CPKernelOps.WriteCSInternal[      kWriteLink + CPKernel.savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[      0,ZeroA,ZeroB,noopD,AplusBplusCin,,noopSp2,link+mask,noopDsp,kWriteLink+1,]];    CPKernelOps.SetShiftRegInternal[CPDef.StartAddr,kWriteLink + CPKernel.savedBank * CPDef.wordsPerBank];    CPKernelOps.SetShiftRegInternal[CPDef.StartAddrPlusOne,kWriteLink+1 + CPKernel.savedBank * CPDef.wordsPerBank];    CPKernel.StartSirius[];    Pause[];    [] ¬ CPKernel.StopSirius[];    CPKernelOps.LoadOverlay[Runtime.GetTableBase[KernelMicrocode.KernelOverlay]];    END;    WriteMap: PUBLIC ENTRY PROCEDURE [map: CPDef.Map, data: WORD] =    BEGIN ENABLE UNWIND => NULL;    WriteMapInternal[map, data];    END;   WriteMapInternal: INTERNAL PROCEDURE [map: CPDef.Map, data: WORD] =    BEGIN    IF map ~IN CPDef.Map THEN AddressOutOfRange[];    CPKernel.WriteMemoryWord[LOOPHOLE[map + CPDef.mapOffset], data];    END;      WriteVirturalMemory: PUBLIC PROCEDURE [virt: CPDef.VirturalMemory, data: WORD] =    BEGIN    CPKernel.WriteMemoryWord[CPKernelOps.MapAddress[virt], data];    END;   WriteOther: PUBLIC ENTRY PROCEDURE [other: CPDef.OtherReg, data: WORD] =    BEGIN ENABLE UNWIND => NULL;    WriteOtherInternal[other, data];    END;   WriteOtherInternal: INTERNAL PROCEDURE [other: CPDef.OtherReg, data: WORD] =    BEGIN    SELECT other FROM      RTChigh => BEGIN	--   	-- RDestination: RTC.high ¬ MD, GOTO[Return], c2, at[0FE2];	--	CPKernelOps.WriteCSInternal[	  kReturn + CPKernel.savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[	  0,ZeroA,ZeroB,TimerHi,AplusBplusCin,,Ureg,noopSp1,noopDsp,kWait,]];	END;      RTClow => BEGIN	--   	-- RDestination: RTC.low ¬ MD, GOTO[Return], c2, at[0FE2];	--	CPKernelOps.WriteCSInternal[	  kReturn + CPKernel.savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[	  0,ZeroA,ZeroB,TimerLo,AplusBplusCin,,Ureg,noopSp1,noopDsp,kWait,]];	END;      qReg => BEGIN        --        -- RDestination: Q ¬ MD, GOTO[Return], c2, at[0FE2];        --        CPKernelOps.WriteCSInternal[	  kReturn + CPKernel.savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[	  0,ZeroA,ZeroB,QregD,AplusBplusCin,,Ureg,noopSp1,noopDsp,kWait,]];	END;      uReg => BEGIN        CPKernel.WriteMemoryWord[kMailBox+1, data];	RETURN;	END;      vReg => BEGIN        CPKernel.WriteMemoryWord[kMailBox+2, data];	RETURN;	END;      CSBank => BEGIN	--   	-- RDestination: CSBank ¬ MD, GOTO[Return], c2, at[0FE2];	--	CPKernelOps.WriteCSInternal[	  kReturn + CPKernel.savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[	  0,ZeroA,ZeroB,csBank,AplusBplusCin,,Ureg,noopSp1,noopDsp,kWait,]];	END;      PScaler => BEGIN	--   	-- RDestination: Prescaler ¬ MD, GOTO[Return], c2, at[0FE2];	--	CPKernelOps.WriteCSInternal[	  kReturn + CPKernel.savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[	  0,ZeroA,ZeroB,PreScal,AplusBplusCin,,Ureg,noopSp1,noopDsp,kWait,]];	END;      CIP => BEGIN	--   	-- RDestination: CIP ¬ MD, GOTO[Return], c2, at[0FE2];	--	CPKernelOps.WriteCSInternal[	  kReturn + CPKernel.savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[	  0,ZeroA,ZeroB,CIP,AplusBplusCin,,Ureg,noopSp1,noopDsp,kWait,]];	END;      StkPtr => BEGIN      	--   	-- RDestination: StkPtr ¬ MD, GOTO[Return], c2, at[0FE2];	--        IF LOOPHOLE[data,CPDef.STACK] ~IN CPDef.STACK  THEN		ERROR CPKernel.Error["Stack Write Error"];	CPKernelOps.WriteCSInternal[	  kReturn + CPKernel.savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[	  0,ZeroA,ZeroB,StkPtr,AplusBplusCin,,Ureg,noopSp1,noopDsp,kWait,]];	CPCommand.RefreshWindow[];	END;      StkP1 => BEGIN      	--   	-- RDestination: STK[1] ¬ MD, GOTO[Return], c2, at[0FE2];	--	WriteStack[0];	END;      StkP0 => BEGIN      	--   	-- RDestination: STK[0] ¬ MD, GOTO[Return], c2, at[0FE2];	--	WriteStack[1];	END;      StkM1 => BEGIN      	--   	-- RDestination: STK[-1] ¬ MD, GOTO[Return], c2, at[0FE2];	--	WriteStack[2];	END;      StkM2 => BEGIN      	--   	-- RDestination: STK[-2] ¬ MD, GOTO[Return], c2, at[0FE2];	--	WriteStack[3];	END;      ENDCASE => CantWriteThatRegister[];    CPKernel.WriteMemoryWord[kMailBox, data];    CPKernelOps.WriteCSInternal[      kRDestination + CPKernel.savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[0,ZeroA,ZeroB,noopD, , ,        noopSp2,noopSp1,noopDsp,kReturn,]];    CPKernelOps.SetShiftRegInternal[CPDef.StartAddr,kWriteState + CPKernel.savedBank * CPDef.wordsPerBank];    CPKernelOps.SetShiftRegInternal[CPDef.StartAddrPlusOne,kWriteState+1 + CPKernel.savedBank * CPDef.wordsPerBank];    CPKernel.StartSirius[];    Pause[];    [] ¬ CPKernel.StopSirius[];    CPKernelOps.WriteCSInternal[      kReturn + CPKernel.savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[0,ZeroA,ZeroB,noopD, , ,        noopSp2,noopSp1,noopDsp,kWait,]];    END;        WriteStack: PROCEDURE [stack: CPDef.StkDomain] =    BEGIN ENABLE UNWIND => NULL;    mask: CARDINAL = 20;    --    -- RDestination: STK[stack] ¬ MD, GOTO[Return], c2, at[0FE2];    --    stkptr: CARDINAL ¬ 0;    CPKernelOps.WriteCSInternal[kASource + CPKernel.savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[	  0,StkPtr,ZeroB,noopD,AplusBplusCin,,noopSp2,noopSp1,noopDsp,kReturn,]];    CPKernelOps.SetShiftRegInternal[CPDef.StartAddr,kReadABus + CPKernel.savedBank * CPDef.wordsPerBank];    CPKernelOps.SetShiftRegInternal[CPDef.StartAddrPlusOne,kReadABus+1 + CPKernel.savedBank * CPDef.wordsPerBank];    CPKernel.StartSirius[];    Pause[];    [] ¬ CPKernel.StopSirius[];    stkptr ¬ CPKernel.ReadMemoryWord[kMailBox];    stkptr ¬ SELECT stack FROM    	0 => stkptr + 1,	1 => stkptr,	2 => stkptr - 1,	3 => stkptr - 2,	ENDCASE => ERROR;    IF stkptr ~IN CPDef.StkRange THEN CPKernelOps.AddressOutOfRange[];    CPKernelOps.WriteCSInternal[      kReturn + CPKernel.savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[      0,ZeroA,ZeroB,stack+mask,AplusBplusCin,,Ureg,noopSp1,noopDsp,kWait,]];    END;        Pause: PROCEDURE = {-- spend something in and our of local frame --};  AddressOutOfRange: PUBLIC PROCEDURE =    BEGIN    ERROR Error["Address out of Range"L];    END;  DataOutOfRange: PUBLIC PROCEDURE =    BEGIN    ERROR Error["Data out of Range"L];    END;    CantWriteThatRegister: PUBLIC PROCEDURE =    BEGIN    ERROR Error["Can't write that register"L];    END;  END.-- Log-- JAC   	 9-Mar-85 17:03:13	mailbox is no long quadword aligned-- JAC   	15-Jan-86 15:10:26	kludge for A chip slowness
-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved. -- Last edit by JAC   		 9-Mar-85 17:04:33-- CPKernelReadImpl.mesa, AYC   , 27-Nov-84  7:55:17-- from CPKernelRead.mesa,   HGM, 13-Jun-83 16:24:25--DIRECTORY  Environment USING [LongNumber],  Inline USING [BITAND, LowHalf],  Runtime USING [GetTableBase],  CPDef USING [AReg, DReg, IBEmpty, Link, Map, mapOffset, OtherReg, RealMemory, ROffset,   RReg, StkDomain, StkRange, StartAddr, StartAddrPlusOne, VirturalMemory, wordsPerBank],  CPKernel USING [Error, ReadMemoryWord, savedBank, StartSirius, StopSirius],  CPKernelDef,  CPKernelOps USING [AddressOutOfRange, LoadOverlay, SetShiftRegInternal,    WriteCSInternal],  CPuFormat,  KernelMicrocode USING [KernelOverlay, ReadLink];CPKernelReadImpl: MONITOR  IMPORTS    Inline, Runtime,    CPKernel, CPKernelOps, CPuFormat, KernelMicrocode  EXPORTS CPKernel, CPKernelOps =  BEGIN OPEN CPKernelDef, CPuFormat;    ReadRReg: PUBLIC ENTRY PROCEDURE [r: CPDef.RReg] RETURNS [WORD] =    BEGIN ENABLE UNWIND => NULL;    --    -- ReadBBus: dKernel ¬ r, at[0FE5];    --    RETURN[ReadRRegInternal[r]];    END;      ReadRRegInternal: INTERNAL PROCEDURE [r: CPDef.RReg] RETURNS [WORD] =    BEGIN ENABLE UNWIND => NULL;    IF r ~IN CPDef.RReg THEN CPKernelOps.AddressOutOfRange[];    CPKernelOps.WriteCSInternal[      kReadBBus + CPKernel.savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[0,ZeroA, r+CPDef.ROffset,dKernel,AorB,,     	 noopSp2,noopSp1,noopDsp,kReadBBus+1,]];    CPKernelOps.SetShiftRegInternal[CPDef.StartAddr,kReadBBus + CPKernel.savedBank * CPDef.wordsPerBank];    CPKernelOps.SetShiftRegInternal[CPDef.StartAddrPlusOne,kReadBBus+1 + CPKernel.savedBank * CPDef.wordsPerBank];    CPKernel.StartSirius[];    Pause[];    [] ¬ CPKernel.StopSirius[];    RETURN[CPKernel.ReadMemoryWord[kMailBox]];    END;   ReadDReg: PUBLIC ENTRY PROCEDURE [d: CPDef.DReg] RETURNS [WORD] =    BEGIN ENABLE UNWIND => NULL;    --    -- ASource: MDR ¬ d, GOTO[Return], c1, at[0FE4];    --    IF d ~IN CPDef.DReg THEN CPKernelOps.AddressOutOfRange[];    CPKernelOps.WriteCSInternal[      kASource + CPKernel.savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[      0,d,ZeroB,noopD,AplusBplusCin,,noopSp2,noopSp1,noopDsp,kReturn,]];    CPKernelOps.SetShiftRegInternal[CPDef.StartAddr,kReadABus + CPKernel.savedBank * CPDef.wordsPerBank];    CPKernelOps.SetShiftRegInternal[CPDef.StartAddrPlusOne,kReadABus+1 + CPKernel.savedBank * CPDef.wordsPerBank];    CPKernel.StartSirius[];    Pause[];    [] ¬ CPKernel.StopSirius[];    RETURN[CPKernel.ReadMemoryWord[kMailBox]];    END;   ReadAReg: PUBLIC ENTRY PROCEDURE [a: CPDef.AReg] RETURNS [data: LONG POINTER] =    BEGIN    aReglocal: Environment.LongNumber;    pagefield: CARDINAL = 32;    lowfield: CARDINAL = 40;    --    -- Read in two parts: A[23..8] first, then A[15..0]    -- ASource: MDR ¬ a.page, GOTO[Return], c1, at[0FE4];    -- ASource: MDR ¬ a.low, GOTO[Return], c1, at[0FE4];    --    IF a ~IN CPDef.AReg THEN CPKernelOps.AddressOutOfRange[];    IF a = aMailBox THEN      BEGIN      aReglocal.high ¬ ReadRRegInternal[raSaveHi - CPDef.ROffset];      aReglocal.high ¬ Inline.BITAND[aReglocal.high, 000FFH];      aReglocal.low ¬ ReadRRegInternal[raSaveLow - CPDef.ROffset];      RETURN[aReglocal.lp];      END;    CPKernelOps.WriteCSInternal[      kASource + CPKernel.savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[      0,a+pagefield,ZeroB,noopD,AplusBplusCin,,noopSp2,noopSp1,noopDsp,kReturn,]];    CPKernelOps.SetShiftRegInternal[CPDef.StartAddr,kReadABus + CPKernel.savedBank * CPDef.wordsPerBank];    CPKernelOps.SetShiftRegInternal[CPDef.StartAddrPlusOne,kReadABus+1 + CPKernel.savedBank * CPDef.wordsPerBank];    CPKernel.StartSirius[];    Pause[];    [] ¬ CPKernel.StopSirius[];    aReglocal.high ¬ CPKernel.ReadMemoryWord[kMailBox];    aReglocal.high ¬ Inline.BITAND[aReglocal.high, 000FFH];    CPKernelOps.WriteCSInternal[      kASource + CPKernel.savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[      0,a+lowfield,ZeroB,noopD,AplusBplusCin,,noopSp2,noopSp1,noopDsp,kReturn,]];    CPKernelOps.SetShiftRegInternal[CPDef.StartAddr,kReadABus + CPKernel.savedBank * CPDef.wordsPerBank];    CPKernelOps.SetShiftRegInternal[CPDef.StartAddrPlusOne,kReadABus+1 + CPKernel.savedBank * CPDef.wordsPerBank];    CPKernel.StartSirius[];    Pause[];    [] ¬ CPKernel.StopSirius[];    aReglocal.low ¬ CPKernel.ReadMemoryWord[kMailBox];    RETURN[aReglocal.lp];    END;      ReadLink: PUBLIC ENTRY PROCEDURE [link: CPDef.Link] RETURNS [data: Nibble] =    BEGIN    --    -- Overlay ReadLink.mc    --     -- ReadLink: LnDisp, at[0FE8];    --    IF link ~IN CPDef.Link THEN CPKernelOps.AddressOutOfRange[];    CPKernelOps.LoadOverlay[Runtime.GetTableBase[KernelMicrocode.ReadLink]];    CPKernelOps.WriteCSInternal[      kReadLink + CPKernel.savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[      0,ZeroA,ZeroB,noopD,AplusBplusCin,,noopSp2,noopSp1,link,kReadLink+1,]];    CPKernelOps.SetShiftRegInternal[CPDef.StartAddr,kReadLink + CPKernel.savedBank * CPDef.wordsPerBank];    CPKernelOps.SetShiftRegInternal[CPDef.StartAddrPlusOne,kReadLink+1 + CPKernel.savedBank * CPDef.wordsPerBank];    CPKernel.StartSirius[];    Pause[];    [] ¬ CPKernel.StopSirius[];    data ¬ Inline.BITAND[CPKernel.ReadMemoryWord[kMailBox], 000FH];    CPKernelOps.LoadOverlay[Runtime.GetTableBase[KernelMicrocode.KernelOverlay]];    END;  ReadMap: PUBLIC ENTRY PROCEDURE [map: CPDef.Map] RETURNS [WORD] =    BEGIN ENABLE UNWIND => NULL;    RETURN[ReadMapInternal[map]];    END;   ReadMapInternal: PROCEDURE [map: CPDef.Map] RETURNS [WORD] =    BEGIN    IF map ~IN CPDef.Map THEN CPKernelOps.AddressOutOfRange[];    RETURN[CPKernel.ReadMemoryWord[LOOPHOLE[map + CPDef.mapOffset]]];    END;   ReadVirturalMemory: PUBLIC ENTRY PROCEDURE [virt: CPDef.VirturalMemory] RETURNS [WORD] =    BEGIN ENABLE UNWIND => NULL;    RETURN[CPKernel.ReadMemoryWord[MapAddressInternal[virt]]];    END;      MapAddress: PUBLIC ENTRY PROCEDURE [virt: CPDef.VirturalMemory] RETURNS [CPDef.RealMemory] = BEGIN RETURN[MapAddressInternal[virt]]; END;   MapAddressInternal: INTERNAL PROCEDURE [virt: CPDef.VirturalMemory] RETURNS [CPDef.RealMemory] =    BEGIN ENABLE UNWIND => NULL;    vmMap: LONG CARDINAL ¬ LOOPHOLE[virt];    page: CARDINAL = Inline.LowHalf[vmMap/256];    offset: CARDINAL = Inline.LowHalf[vmMap MOD 256];    mapEntry: MACHINE DEPENDENT RECORD [      pageLow: [0..0FFH], r, d, w: BOOLEAN, pageHigh: [0..01FH]];    mapEntry ¬ LOOPHOLE[ReadMapInternal[page]];    IF mapEntry.w AND mapEntry.d THEN      ERROR CPKernel.Error["Map entry is marked invalid"L];    vmMap ¬ mapEntry.pageHigh*10000H + mapEntry.pageLow*256 + offset;    RETURN[LOOPHOLE[vmMap]];    END;      ReadOther: PUBLIC ENTRY PROCEDURE [other: CPDef.OtherReg] RETURNS [data: WORD] =    BEGIN ENABLE UNWIND => NULL;    SELECT other FROM      RTChigh => BEGIN	--   	-- ASource: MDR ¬ RTC.high, GOTO[Return], c1, at[0FE4];	--	CPKernelOps.WriteCSInternal[	  kASource + CPKernel.savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[	  0,TimerHi,ZeroB,noopD,AplusBplusCin,,noopSp2,noopSp1,noopDsp,kReturn,]];	END;      RTClow => BEGIN	--   	-- ASource: MDR ¬ RTC.low, GOTO[Return], c1, at[0FE4];	--	CPKernelOps.WriteCSInternal[	  kASource + CPKernel.savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[	  0,TimerLo,ZeroB,noopD,AplusBplusCin,,noopSp2,noopSp1,noopDsp,kReturn,]];	END;      qReg => BEGIN        --        -- ReadBBus: dKernel ¬ Q, at[0FE5];        --        CPKernelOps.WriteCSInternal[	  kReadBBus + CPKernel.savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[	  0,ZeroA,QregB,dKernel,AorB,,noopSp2,noopSp1,noopDsp,kReadBBus+1,]];	CPKernelOps.SetShiftRegInternal[CPDef.StartAddr,kReadBBus + CPKernel.savedBank * CPDef.wordsPerBank];	CPKernelOps.SetShiftRegInternal[CPDef.StartAddrPlusOne,kReadBBus+1 + CPKernel.savedBank * CPDef.wordsPerBank];	CPKernel.StartSirius[];	Pause[];	[] ¬ CPKernel.StopSirius[];	RETURN[CPKernel.ReadMemoryWord[kMailBox]];	END;      uReg => BEGIN        RETURN[CPKernel.ReadMemoryWord[kMailBox+1]];	END;      vReg => BEGIN        RETURN[CPKernel.ReadMemoryWord[kMailBox+2]];	END;      CSBank => BEGIN	--   	-- ASource: MDR ¬ CSBank, GOTO[Return], c1, at[0FE4];	--	CPKernelOps.WriteCSInternal[	  kASource + CPKernel.savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[	  0,csBank,ZeroB,noopD,AplusBplusCin,,noopSp2,noopSp1,noopDsp,kReturn,]];	END;      Ib => BEGIN        --        -- ReadBBus: dKernel ¬ ib, at[0FE5];	--	-- read .IbCtr see first if can do a "¬ ib"        --	CPKernelOps.WriteCSInternal[	  kASource + CPKernel.savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[	  0,IbCtr,ZeroB,noopD,AplusBplusCin,,noopSp2,noopSp1,noopDsp,kReturn,]];	CPKernelOps.SetShiftRegInternal[CPDef.StartAddr,kReadABus + CPKernel.savedBank * CPDef.wordsPerBank];	CPKernelOps.SetShiftRegInternal[CPDef.StartAddrPlusOne,kReadABus+1 + CPKernel.savedBank * CPDef.wordsPerBank];	CPKernel.StartSirius[];	Pause[];	[] ¬ CPKernel.StopSirius[];	IF CPKernel.ReadMemoryWord[kMailBox] = CPDef.IBEmpty THEN		ERROR CPKernel.Error["IBEmpty -- instruction buffer not read"L];        CPKernelOps.WriteCSInternal[	  kReadBBus + CPKernel.savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[	  0,ZeroA,Ib,dKernel,AorB,,noopSp2,noopSp1,noopDsp,kReadBBus+1,]];	CPKernelOps.SetShiftRegInternal[CPDef.StartAddr,kReadBBus + CPKernel.savedBank * CPDef.wordsPerBank];	CPKernelOps.SetShiftRegInternal[CPDef.StartAddrPlusOne,kReadBBus+1 + CPKernel.savedBank * CPDef.wordsPerBank];	CPKernel.StartSirius[];	Pause[];	[] ¬ CPKernel.StopSirius[];	RETURN[CPKernel.ReadMemoryWord[kMailBox]];	END;      IBCtr => BEGIN	--   	-- ASource: MDR ¬ IBCtr, GOTO[Return], c1, at[0FE4];	--	IBCount: CARDINAL ¬ CPDef.IBEmpty; 	CPKernelOps.WriteCSInternal[	  kASource + CPKernel.savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[	  0,IbCtr,ZeroB,noopD,AplusBplusCin,,noopSp2,noopSp1,noopDsp,kReturn,]];	CPKernelOps.SetShiftRegInternal[CPDef.StartAddr,kReadABus + CPKernel.savedBank * CPDef.wordsPerBank];	CPKernelOps.SetShiftRegInternal[CPDef.StartAddrPlusOne,kReadABus+1 + CPKernel.savedBank * CPDef.wordsPerBank];	CPKernel.StartSirius[];	Pause[];	[] ¬ CPKernel.StopSirius[];	IBCount ¬ CPKernel.ReadMemoryWord[kMailBox];	RETURN[SELECT IBCount FROM		CPDef.IBEmpty => 0,		2 => 1,		3 => 2,		6 => 3,		7 => 4,		0EH => 5,		0FH => 6,		ENDCASE => ERROR CPKernel.Error["Unexpected IBCtr value"L]];	END;      PScaler => BEGIN	--   	-- ASource: MDR ¬ Prescaler, GOTO[Return], c1, at[0FE4];	--	CPKernelOps.WriteCSInternal[	  kASource + CPKernel.savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[	  0,PreScal,ZeroB,noopD,AplusBplusCin,,noopSp2,noopSp1,noopDsp,kReturn,]];	END;      CIP => BEGIN	--   	-- ASource: MDR ¬ CIP, GOTO[Return], c1, at[0FE4];	--	CPKernelOps.WriteCSInternal[	  kASource + CPKernel.savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[	  0,CIP,ZeroB,noopD,AplusBplusCin,,noopSp2,noopSp1,noopDsp,kReturn,]];	END;      CVN => BEGIN      	--   	-- ASource: MDR ¬ CVN, GOTO[Return], c1, at[0FE4];	--	CPKernelOps.WriteCSInternal[	  kASource + CPKernel.savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[	  0,CVN,ZeroB,noopD,AplusBplusCin,,noopSp2,noopSp1,noopDsp,kReturn,]];	END;      StkPtr => BEGIN      	--   	-- ASource: MDR ¬ StkPtr, GOTO[Return], c1, at[0FE4];	--	CPKernelOps.WriteCSInternal[	  kASource + CPKernel.savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[	  0,StkPtr,ZeroB,noopD,AplusBplusCin,,noopSp2,noopSp1,noopDsp,kReturn,]];	END;      StkP1 => BEGIN      	--   	-- ASource: MDR ¬ STK[1], GOTO[Return], c1, at[0FE4];	--	ReadStack[0];	END;      StkP0 => BEGIN      	--   	-- ASource: MDR ¬ STK[0], GOTO[Return], c1, at[0FE4];	--	ReadStack[1];	END;      StkM1 => BEGIN      	--   	-- ASource: MDR ¬ STK[-1], GOTO[Return], c1, at[0FE4];	--	ReadStack[2];	END;      StkM2 => BEGIN      	--   	-- ASource: MDR ¬ STK[-2], GOTO[Return], c1, at[0FE4];	--	ReadStack[3];	END;      ENDCASE => CantReadThatRegister[];    CPKernelOps.SetShiftRegInternal[CPDef.StartAddr,kReadABus + CPKernel.savedBank * CPDef.wordsPerBank];    CPKernelOps.SetShiftRegInternal[CPDef.StartAddrPlusOne,kReadABus+1 + CPKernel.savedBank * CPDef.wordsPerBank];    CPKernel.StartSirius[];    Pause[];    [] ¬ CPKernel.StopSirius[];    RETURN[CPKernel.ReadMemoryWord[kMailBox]];    END;    ReadStack: PROCEDURE [stack: CPDef.StkDomain] =    BEGIN ENABLE UNWIND => NULL;    mask: CARDINAL = 20;    --    -- ASource: MDR ¬ STK[stack], GOTO[Return], c1, at[0FE4];    --    stkptr: CARDINAL ¬ 0;    CPKernelOps.WriteCSInternal[kASource + CPKernel.savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[	  0,StkPtr,ZeroB,noopD,AplusBplusCin,,noopSp2,noopSp1,noopDsp,kReturn,]];    CPKernelOps.SetShiftRegInternal[CPDef.StartAddr,kReadABus + CPKernel.savedBank * CPDef.wordsPerBank];    CPKernelOps.SetShiftRegInternal[CPDef.StartAddrPlusOne,kReadABus+1 + CPKernel.savedBank * CPDef.wordsPerBank];    CPKernel.StartSirius[];    Pause[];    [] ¬ CPKernel.StopSirius[];    stkptr ¬ CPKernel.ReadMemoryWord[kMailBox];    stkptr ¬ SELECT stack FROM    	0 => stkptr + 1,	1 => stkptr,	2 => stkptr - 1,	3 => stkptr - 2,	ENDCASE => ERROR;    IF stkptr ~IN CPDef.StkRange THEN CPKernelOps.AddressOutOfRange[];    CPKernelOps.WriteCSInternal[kASource + CPKernel.savedBank * CPDef.wordsPerBank, CPuFormat.uAlign[      0,stack+mask,ZeroB,noopD,AplusBplusCin,,noopSp2,noopSp1,noopDsp,kReturn,]];    END;        Pause: PROCEDURE = {-- spend something in and our of local frame --};    CantReadThatRegister: PUBLIC PROCEDURE =    BEGIN    ERROR CPKernel.Error["Can't read that register"L];    END;  END.  -- Log:-- JAC   	10-Jan-85 13:22:13	added MapAddressInternal to break monitor lock in ReadVirturalMemory-- JAC   	 9-Mar-85 17:04:16	mailbox is no longer quadword aligned
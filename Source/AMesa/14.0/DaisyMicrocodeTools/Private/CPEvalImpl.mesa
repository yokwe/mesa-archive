-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved. -- Last edit by JAC   		 6-Apr-85 16:40:48-- CPEvalImpl.mesa, AYC   , 26-Oct-84 12:07:15-- from CPEvaler.mesa, HGM, 13-Nov-83  0:53:57--DIRECTORY  Ascii USING [CR, LF, FF, SP, TAB],  Inline USING [LowHalf],  String USING [AppendString, Equivalent, SubString, SubStringDescriptor],    CPDef USING [    AReg, DReg, IBDisp, Link, Map, MDR, OtherReg, RealCS, RealMemory, RReg, ROffset,    sizeOfCS, VirturalMemory],  CPSymbol USING [    Error, LookupInCSTable, LookupInRRegTable, LookupInDRegTable,    LookupInARegTable, nullRealCS, nullVirturalCS, RealToVirturalCS, Symbol,    Type, VirturalCS, VirturalToRealCS],  Evaluate USING [Error, EvaluateSubString, Type, unspecified, Value],  StringExtras USING [StringToLongCardinal];CPEvalImpl: PROGRAM  IMPORTS Inline, String, CPSymbol, Evaluate, StringExtras  EXPORTS CPSymbol =  BEGIN    GetPcAndFlags: PUBLIC PROCEDURE [s: LONG STRING]    RETURNS [pc: CPDef.RealCS, ibdisp: CPDef.IBDisp, mdr: CPDef.MDR] =    BEGIN    symbol: CPSymbol.Symbol ¬ Eval[s];    WITH symbol SELECT FROM      number =>        BEGIN	virt: CPSymbol.VirturalCS;	IF n NOT IN CPDef.RealCS THEN ERROR CPSymbol.Error["Illegal CS address"L];	pc ¬ Inline.LowHalf[n];	[virt, ibdisp, mdr] ¬ CPSymbol.RealToVirturalCS[pc];	IF virt = CPSymbol.nullVirturalCS THEN ERROR CPSymbol.Error["Illegal Virtual Address"L];	END;      realCS =>        BEGIN	virt: CPSymbol.VirturalCS;	pc ¬ real;	[virt, ibdisp, mdr] ¬ CPSymbol.RealToVirturalCS[pc];	IF virt = CPSymbol.nullVirturalCS THEN ERROR CPSymbol.Error["Illegal Real Address"L];	END;      virtCS =>        BEGIN	[pc, ibdisp, mdr] ¬ CPSymbol.VirturalToRealCS[virt];	IF pc = CPSymbol.nullRealCS THEN ERROR CPSymbol.Error["Can't translate to a real CS address"L];	END;      ENDCASE => ERROR CPSymbol.Error["CP ControlStore address required"L];    END;	  Eval: PUBLIC PROCEDURE [s: LONG STRING] RETURNS [CPSymbol.Symbol] =    BEGIN    type: Evaluate.Type;    value: Evaluate.Value;    shortValue: CARDINAL;    pointer: LONG POINTER;    smytype: CPSymbol.Type;    ss: String.SubStringDescriptor;        IF s = NIL OR s.length = 0 THEN ERROR CPSymbol.Error["...Operand required"];    ss ¬ [base: s, offset: 0, length: s.length];    TrimSubString[@ss];    [type, value] ¬ Evaluate.EvaluateSubString[@ss, Lookup !        Evaluate.Error => ERROR CPSymbol.Error[reason] ];    shortValue ¬ Inline.LowHalf[value];    pointer ¬ LOOPHOLE[value];    smytype ¬ IF type = Evaluate.unspecified THEN number ELSE LOOPHOLE[type];    SELECT smytype FROM      number => RETURN[[number[value]]];      link =>        BEGIN	IF value ~IN CPDef.Link THEN RegOutOfRange[];        RETURN[[link[shortValue]]];	END;      realCS =>        BEGIN        IF shortValue >= CPDef.sizeOfCS THEN AddressOutOfRange[];        RETURN[[realCS[shortValue]]];	END;      virtCS => RETURN[[virtCS[shortValue]]];      rReg =>        BEGIN	IF value - CPDef.ROffset ~IN CPDef.RReg THEN RegOutOfRange[];	RETURN[[rReg[shortValue - CPDef.ROffset]]];	END;      dReg =>        BEGIN	IF value ~IN CPDef.DReg THEN RegOutOfRange[];	RETURN[[dReg[shortValue]]];	END;      aReg =>        BEGIN	IF value ~IN CPDef.AReg THEN RegOutOfRange[];	RETURN[[aReg[shortValue]]];	END;      map =>        BEGIN	IF value ~IN CPDef.Map THEN AddressOutOfRange[];	RETURN[[map[shortValue]]];	END;      real => RETURN[[real[pointer]]];      virt => RETURN[[virt[pointer]]];      other =>        BEGIN	IF LOOPHOLE[shortValue,CPDef.OtherReg] ~IN CPDef.OtherReg THEN OutOfRange[];        RETURN[[other[LOOPHOLE[shortValue]]]];	END;      ENDCASE => ERROR;    END;        Lookup: PROCEDURE [s: LONG STRING] RETURNS [type: Evaluate.Type, value: Evaluate.Value] =    BEGIN    ok: BOOLEAN;    virt: CPSymbol.VirturalCS;    r: CPDef.RReg;    d: CPDef.DReg;    a: CPDef.AReg;    symbol: CPSymbol.Symbol;    [ok, virt] ¬ CPSymbol.LookupInCSTable[s];    IF ok THEN RETURN[LOOPHOLE[CPSymbol.Type[virtCS]], LONG[virt]];    [ok, r] ¬ CPSymbol.LookupInRRegTable[s];    IF ok THEN RETURN[LOOPHOLE[CPSymbol.Type[rReg]], LONG[r + CPDef.ROffset]];    [ok, d] ¬ CPSymbol.LookupInDRegTable[s];    IF ok THEN RETURN[LOOPHOLE[CPSymbol.Type[dReg]], LONG[d]];    [ok, a] ¬ CPSymbol.LookupInARegTable[s];    IF ok THEN RETURN[LOOPHOLE[CPSymbol.Type[aReg]], LONG[a]];    [ok, symbol] ¬ StringAsSpecial[s];    IF ok THEN      BEGIN      type ¬ LOOPHOLE[symbol.type];      WITH symbol SELECT FROM        number => value ¬ n;        link => value ¬ link;        realCS => value ¬ real;        virtCS => value ¬ virt;        rReg => value ¬ r;        dReg => value ¬ d;        aReg => value ¬ a;        map => value ¬ map;        real => value ¬ LOOPHOLE[real];        virt => value ¬ LOOPHOLE[virt];        other => value ¬ LONG[LOOPHOLE[other]];        ENDCASE => ERROR;      RETURN;      END;    [ok, value] ¬ StringExtras.StringToLongCardinal[s];    IF ok THEN RETURN[Evaluate.unspecified, value];    BEGIN    temp: LONG STRING = [100];    String.AppendString[temp, "Undefined Symbol: "L];    String.AppendString[temp, s];    ERROR CPSymbol.Error[temp];    END;    END;  StringAsSpecial: PROCEDURE [s: LONG STRING] RETURNS [BOOLEAN, CPSymbol.Symbol] =    BEGIN    SELECT TRUE FROM      String.Equivalent[s, ".CR"L] => RETURN[TRUE, [realCS[0]]];      String.Equivalent[s, ".CV"L] => RETURN[TRUE, [virtCS[0]]];      String.Equivalent[s, ".R"L] => RETURN[TRUE, [rReg[0]]];      String.Equivalent[s, ".D"L] => RETURN[TRUE, [dReg[0]]];      String.Equivalent[s, ".A"L] => RETURN[TRUE, [aReg[0]]];      String.Equivalent[s, ".RTChigh"L] => RETURN[TRUE, [other[RTChigh]]];      String.Equivalent[s, ".RTClow"L] => RETURN[TRUE, [other[RTClow]]];      String.Equivalent[s, ".Q"L] => RETURN[TRUE, [other[qReg]]];      String.Equivalent[s, ".MDu"L] => RETURN[TRUE, [other[uReg]]];      String.Equivalent[s, ".MDv"L] => RETURN[TRUE, [other[vReg]]];      String.Equivalent[s, ".CSBANK"L] => RETURN[TRUE, [other[CSBank]]];      String.Equivalent[s, ".IB"L] => RETURN[TRUE, [other[Ib]]];      String.Equivalent[s, ".IBCTR"L] => RETURN[TRUE, [other[IBCtr]]];      String.Equivalent[s, ".MAP"L] => RETURN[TRUE, [map[0]]];      String.Equivalent[s, ".MR"L] => RETURN[TRUE, [real[NIL]]];      String.Equivalent[s, ".MV"L] => RETURN[TRUE, [virt[NIL]]];      String.Equivalent[s, ".PSCALER"L] => RETURN[TRUE, [other[PScaler]]];      String.Equivalent[s, ".CIP"L] => RETURN[TRUE, [other[CIP]]];      String.Equivalent[s, ".NIB"L] => RETURN[TRUE, [aReg[0]]];      String.Equivalent[s, ".CVN"L] => RETURN[TRUE, [other[CVN]]];      String.Equivalent[s, ".STKPTR"L] => RETURN[TRUE, [other[StkPtr]]];      String.Equivalent[s, ".STK(1)"L] => RETURN[TRUE, [other[StkP1]]];      String.Equivalent[s, ".STK(0)"L] => RETURN[TRUE, [other[StkP0]]];      String.Equivalent[s, ".STK(~1)"L] => RETURN[TRUE, [other[StkM1]]];      String.Equivalent[s, ".STK(~2)"L] => RETURN[TRUE, [other[StkM2]]];      String.Equivalent[s, ".LINK"L] => RETURN[TRUE, [link[0]]];      String.Equivalent[s, "L0"L] => RETURN[TRUE, [link[0]]];      String.Equivalent[s, "L1"L] => RETURN[TRUE, [link[1]]];      String.Equivalent[s, "L2"L] => RETURN[TRUE, [link[2]]];      String.Equivalent[s, "L3"L] => RETURN[TRUE, [link[3]]];      ENDCASE => RETURN[FALSE, ];    END;        AddressOutOfRange: PROCEDURE =    BEGIN    foo: BOOLEAN ¬ TRUE;    IF foo THEN ERROR CPSymbol.Error["Address out of range. (CPEvalImpl)"L];    END;      RegOutOfRange: PROCEDURE =    BEGIN    foo: BOOLEAN ¬ TRUE;    IF foo THEN ERROR CPSymbol.Error["Register number out of range. (CPEvalImpl)"L];    END;      OutOfRange: PROCEDURE =    BEGIN    foo: BOOLEAN ¬ TRUE;    IF foo THEN ERROR CPSymbol.Error["No more implicit register definition. (CPEvalImpl)"L];    END;      TrimSubString: PROCEDURE [ss: String.SubString] =    BEGIN    FOR i: CARDINAL IN [ss.offset..ss.offset + ss.length) DO      IF ~BlankCharacter[ss.base[i]] THEN        BEGIN  --  remove leading blanks        ss.length ¬ ss.length - (i - ss.offset);        ss.offset ¬ i;	EXIT;	END;      REPEAT FINISHED =>        BEGIN  --all blanks	ss.length ¬ 0;        RETURN;	END;      ENDLOOP;    FOR i: CARDINAL DECREASING IN [ss.offset..ss.offset + ss.length) DO      IF ~BlankCharacter[ss.base[i]] THEN        BEGIN  --  remove trailing blanks        ss.length ¬ ss.length - (ss.offset + ss.length - 1 - i);	EXIT;	END;      ENDLOOP;    END;      BlankCharacter: PROCEDURE [c: CHARACTER] RETURNS [BOOLEAN] =    BEGIN    SELECT c FROM      Ascii.FF, Ascii.SP, Ascii.CR, Ascii.LF, Ascii.TAB => RETURN[TRUE];      ENDCASE => RETURN[FALSE];    END;    END.  -- Log:-- JAC   	 8-Jan-85 18:19:14	.U => >MDu and .V => .MDv-- JAC   	10-Jan-85 11:42:37	spell virtural correctly-- JAC   	10-Jan-85 17:32:25	stk uses ( not [-- JAC   	 6-Apr-85 16:40:52	check for in RealCS in GetPCAndFlags
-- TVector2Impl.mesa-- Created by jAC   CxC    on 20-Nov-84 15:53-- last edit by CxC   	 11-Jun-85 13:03:06-- Copyright (C) Xerox Corporation 1984. All rights reserved.DIRECTORY  Ascii,  Bindweed,  Environment,  Exec,  Format,  FormSW,  Heap,  MStream USING[ReadOnly,EndOf,Handle,Error],  Process,  Put,  Runtime,  Stream,  String,  TestVectorIO,   TextSW USING [ForceOutput],  Time,  Tool,  ToolWindow,  TTY,  TVError,  UserTerminal,  Version,  Window;TVector2Impl: PROGRAM  IMPORTS    Bindweed, Exec, FormSW, Heap, MStream, Process, Put, Runtime, Stream, String, Time, TestVectorIO, TextSW, Tool, TVError, TTY, UserTerminal, Version = {  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = MACHINE DEPENDENT RECORD [    msgSW(0): Window.Handle _ NIL,    formSW(2): Window.Handle _ NIL,    fileSW(4): Window.Handle _ NIL,    dontCares(6): UNSPECIFIED _ 0,    alwaysCheck(7): BOOLEAN _ FALSE,    loadrange(8): UNSPECIFIED _ 0,    errLog(9): BOOLEAN _ FALSE,    starting(10): CARDINAL _ 0,    delay(11): WORD _ 1,    filename(12): LONG STRING _ NIL,    ending(14): CARDINAL _ 0,    vector(15): LONG STRING _ NIL];       Location: TYPE = LONG POINTER TO ASMLoc;  ASMLoc: TYPE = MACHINE DEPENDENT RECORD [    base: WORD _ 0100H,    dataseg: WORD _ 0200H,    start: WORD _ 0000H,    continue: WORD _ 0003H,    ErrFlag: LONG CARDINAL _ 02000H,    number: LONG CARDINAL _ 02001H,    delay: LONG CARDINAL _ 02003H,    count: LONG CARDINAL _ 02005H,    result: LONG CARDINAL _ 0200AH,    original: LONG CARDINAL _ 0201BH,    table: LONG CARDINAL _ 0202CH];  Vector: TYPE = ARRAY [1..17] OF CARDINAL;  FormItems: TYPE = {boot, testSingleVector, dontCares, alwaysCheck, loadvectors, testMultipleVectors, loadrange, errLog, step, sendPreamble, starting, delay, stop, filename, ending, vector};  data: DataHandle _ NIL;  wh: Window.Handle _ NIL;  zone: UNCOUNTED ZONE _ Heap.systemZone;  location: Location _ NIL;  Running, Booted, Single, StopCalled, InErrLog, initialized, null, preamble,      Loaded, First: BOOLEAN _ FALSE;  err: CARDINAL _ 0;  errlog: MStream.Handle _ NIL;    hexbyte: Format.NumberFormat = [16, TRUE, TRUE, 2];  Error: PUBLIC ERROR [reason: LONG STRING] = CODE;    AppendMessage: PROCEDURE [s: LONG STRING] =    BEGIN    Put.Text[data.msgSW, s];    TextSW.ForceOutput[data.msgSW];    END;      BinaryCardinalToString: PROCEDURE[n, len: CARDINAL,s: LONG STRING] RETURNS                        [s1: LONG STRING] = {    s.length _ len;    FOR i: CARDINAL DECREASING IN [0..len - 1] DO      IF n MOD 2 = 0 THEN s[i] _ '0 ELSE s[i] _ '1;      n _ n / 2;      ENDLOOP;      RETURN[s]};         BinaryStringToCardinal: PROCEDURE [s: LONG STRING] RETURNS [n: CARDINAL _ 0] =     {    FOR i: CARDINAL IN [0..s.length) DO      SELECT s[i] FROM        '0 => n _ n * 2;	'1, '+ => n _ n * 2 + 1;	'x, 'X => IF data.dontCares = 0 THEN n _ n * 2 ELSE n _ n * 2 + 1;	ENDCASE => EXIT;      ENDLOOP;};   Boot:  FormSW.ProcType = {    ENABLE {    MStream.Error => {IF code = fileNotAvailable THEN {NewMessage[                                 "TVector.LM not found"L]; UserTerminal.BlinkDisplay[];} ELSE                               NewMessage["UnKnown MStream error"L]; CONTINUE};    TestVectorIO.Error => {AppendMessage[reason]; CONTINUE;};    Bindweed.Error => {SELECT code FROM                 timeout => { AppendMessage["Failed"L]; Put.Line[data.fileSW,                             "Timeout occured"L]};                 badCheckSum => { AppendMessage["Failed"L]; Put.Line[data.fileSW,                                 "Bad Chack Sum"L]};                 umbilicalNotWorking => {AppendMessage["Failed"L]; Put.Line                                     [data.fileSW, "Umbilical not working"L]};		 ENDCASE;		 CONTINUE};    Runtime.UnboundProcedure => { AppendMessage["Failed"L]; Put.Line[data.fileSW,                                  "BindweedConfig.bcd not loaded"L]; CONTINUE; };    UNWIND => NULL;    };    temp: MStream.Handle;    IF ~Running THEN     {NewMessage["Booting..."L];      TestVectorIO.Boot[];      temp _ MStream.ReadOnly["TVector.lm"L,[]]; -- See if file exists      Stream.Delete[temp];	      AppendMessage["Downloading file..."L];      TestVectorIO.Load[data.fileSW,"TVector.lm"L];      AppendMessage["Done"L];      Booted _ TRUE;      Loaded _ FALSE;      Process.Detach[FORK SendTwoNulls[]]}    ELSE      NewMessage["Must be stopped before booting"L];    };      SendTwoNulls: PROCEDURE = {    Process.SetPriority[Process.priorityBackground];    SendNull[];      UNTIL ~Running DO        Process.Pause[Process.MsecToTicks[10]];	ENDLOOP;      SendNull[];      UNTIL ~Running DO        Process.Pause[Process.MsecToTicks[10]];	ENDLOOP;      null ¬ FALSE;     };      Continue:  PROCEDURE= {    NewMessage[" "L];    TestVectorIO.ReadSavedRegisters[];    TestVectorIO.WriteRegister[IP,location.continue];    TestVectorIO.WriteRegister[CS,location.base];    TestVectorIO.WriteRegister[DS,location.dataseg];    TestVectorIO.WriteRegister[ES,location.dataseg];    TestVectorIO.WriteSavedRegisters[];    TestVectorIO.Continue[];    Running _ TRUE;    };            Convert: PROCEDURE [str: LONG STRING] RETURNS [array: Vector] = {    temp: LONG STRING _ zone.NEW[StringBody[16]];    temp1: LONG STRING _ zone.NEW[StringBody[16]];    numb: CARDINAL;    array[1] _ BinaryStringToCardinal[SubString[str,temp1,0,5]];    numb _ BinaryStringToCardinal[SubString[str,temp1,5,3]];    array[2] _ BinaryStringToCardinal[SubString[str,temp1,8,5]] * 8 + numb;    array[3] _ BinaryStringToCardinal[SubString[str,temp1,13,8]];    numb _ BinaryStringToCardinal[SubString[str,temp1,21,3]];    array[4] _ BinaryStringToCardinal[SubString[str,temp1,24,8]];    array[5] _ BinaryStringToCardinal[SubString[str,temp1,32,8]];    array[6] _ BinaryStringToCardinal[SubString[str,temp1,40,1]] * 8 + numb;--    temp _ SubString[str,temp1,41,3];    String.Copy[temp,SubString[str,temp1,41,3]];    String.AppendChar[temp,'0];    String.AppendChar[temp,'0];    String.AppendString[temp,SubString[str,temp1,44,2]];    array[7] _ BinaryStringToCardinal[temp];    array[8] _ BinaryStringToCardinal[SubString[str,temp1,46,8]];    array[9] _ BinaryStringToCardinal[SubString[str,temp1,54,8]];    array[10] _ BinaryStringToCardinal[SubString[str,temp1,62,8]];    array[11] _ BinaryStringToCardinal[SubString[str,temp1,70,8]];    array[12] _ BinaryStringToCardinal[SubString[str,temp1,78,8]];    array[13] _ BinaryStringToCardinal[SubString[str,temp1,86,8]];    array[14] _ BinaryStringToCardinal[SubString[str,temp1,94,8]];    array[15] _ BinaryStringToCardinal[SubString[str,temp1,102,8]];    array[16] _ BinaryStringToCardinal[SubString[str,temp1,110,8]];    array[17] _ BinaryStringToCardinal[SubString[str,temp1,118,2]];    IF data.alwaysCheck THEN {array[16] _ 255;                              array[17] _ 03;			      };    zone.FREE[@temp];    zone.FREE[@temp1];     };       Decode: PROCEDURE[array: Vector, str:LONG STRING]= {    numb, numb1: CARDINAL;    temp: LONG STRING _ zone.NEW[StringBody[16]];    str.length _ 0;    String.AppendString[str,BinaryCardinalToString[array[1],5,temp]];    numb _ array[2] / 8;    numb1 _ array[2] - numb * 8;    String.AppendString[str,BinaryCardinalToString[numb1,3,temp]];    String.AppendString[str,BinaryCardinalToString[numb,5,temp]];    String.AppendString[str,BinaryCardinalToString[array[3],8,temp]];    numb _ array[6] / 8;    numb1 _ array[6] - numb * 8;    String.AppendString[str,BinaryCardinalToString[numb1,3,temp]];    String.AppendString[str,BinaryCardinalToString[array[4],8,temp]];    String.AppendString[str,BinaryCardinalToString[array[5],8,temp]];    String.AppendString[str,BinaryCardinalToString[numb,1,temp]];    numb _ array[7] / 16;    numb1 _ array[7] - (numb * 16);    String.AppendString[str,BinaryCardinalToString[numb,3,temp]];    String.AppendString[str,BinaryCardinalToString[numb1,2,temp]];    String.AppendString[str,BinaryCardinalToString[array[8],8,temp]];    String.AppendString[str,BinaryCardinalToString[array[9],8,temp]];    String.AppendString[str,BinaryCardinalToString[array[10],8,temp]];    String.AppendString[str,BinaryCardinalToString[array[11],8,temp]];    String.AppendString[str,BinaryCardinalToString[array[12],8,temp]];    String.AppendString[str,BinaryCardinalToString[array[13],8,temp]];    String.AppendString[str,BinaryCardinalToString[array[14],8,temp]];    String.AppendString[str,BinaryCardinalToString[array[15],8,temp]];    String.AppendString[str,BinaryCardinalToString[array[16],8,temp]];    String.AppendString[str,BinaryCardinalToString[array[17],2,temp]];    zone.FREE[@temp];    };             DisplayVector: PROCEDURE[vector: Vector] = {    numb: CARDINAL;     FOR i: CARDINAL IN [1..17] DO      numb _ vector[i];      Put.Number[data.fileSW, numb, hexbyte];      Put.Text[data.fileSW, " "L];      ENDLOOP;    Put.CR[data.fileSW];    };      ErrLog: PROCEDURE[number: WORD, vec,result: Vector] = {    str: LONG STRING _ zone.NEW[StringBody[120]];    temp: LONG STRING _ zone.NEW[StringBody[10]];    InErrLog _ TRUE;    Decode[vec,str];    Stream.PutString[errlog,"/*"L];    temp.length _ 0;    String.AppendDecimal[temp,number];    Stream.PutString[errlog,temp];    Stream.PutString[errlog,"*/"L];    Stream.PutChar[errlog,Ascii.CR];    Stream.PutString[errlog,str];    Stream.PutChar[errlog,Ascii.CR];    Stream.PutString[errlog,"/*"L];    Decode[result,str];    Stream.PutString[errlog,str];    Stream.PutString[errlog,"*/"L];    Stream.PutChar[errlog,Ascii.CR];    zone.FREE[@str];    zone.FREE[@temp];    InErrLog _ FALSE;    };          Halted: Bindweed.NotifyProc = {    ENABLE {      TestVectorIO.Error => {NewMessage[reason]; CONTINUE};      Runtime.UnboundProcedure => {NewMessage["Bindweed is not loaded"L];             CONTINUE};      Bindweed.Error => {SELECT code FROM                 timeout => { AppendMessage["Failed"L]; Put.Line[data.fileSW,                             "Timeout occured"L]};                 badCheckSum => { AppendMessage["Failed"L]; Put.Line[data.fileSW,                                 "Bad Chack Sum"L]};                 umbilicalNotWorking => {AppendMessage["Failed"L]; Put.Line                                     [data.fileSW, "Umbilical not working"L]};		 ENDCASE;		 CONTINUE}};    Done: BOOLEAN;    NewMessage[" "L];    TestVectorIO.Stop[];    Running _ FALSE;    IF null THEN RETURN;    Done _ Results[];    IF ~Single AND ~StopCalled AND ~Done THEN Continue[];    IF ((~Single AND Done) OR StopCalled) AND errlog # NIL AND ~InErrLog THEN       {Stream.Delete[errlog]; errlog _ NIL;};     };        LoadFile: PROCEDURE [filename: LONG STRING] RETURNS [Loaded: BOOLEAN _ FALSE] =    BEGIN    ENABLE {TestVectorIO.Error => {NewMessage[reason]; CONTINUE;};            MStream.Error => {IF code = fileNotAvailable THEN {NewMessage[                                 "File not found"L]; UserTerminal.BlinkDisplay[];} ELSE                               NewMessage["UnKnown MStream error"L]; CONTINUE};};    filePtr: MStream.Handle;    temp: Stream.Position;    char: CHARACTER;    vector: Vector;    str: LONG STRING _ [122];    loc, len: LONG CARDINAL;    num, count: CARDINAL _ 0;    comment, skipCR: BOOLEAN _ FALSE;    loc _ location.table;    len _ 0;    str.length _ 0;    count _ 1;    filePtr _ MStream.ReadOnly[filename,[]];    NewMessage[" "L];    Put.Text[data.fileSW, "Reading "L];    Put.LongString[data.fileSW, filename];    UNTIL MStream.EndOf[filePtr] DO      char _ Stream.GetChar[filePtr];      IF len > 120 THEN char _ Ascii.CR;      SELECT char FROM        '0, '1, 'x, 'X, '+ => {len _ len + 1; 	                      String.AppendChar[str,char];	                      skipCR _ FALSE};	Ascii.CR => {IF skipCR THEN skipCR _ FALSE ELSE { 	               IF len = 120 THEN {vector _ Convert[str];                                            IF data.loadrange = 0 OR count IN                                                    [data.starting..data.ending] THEN {		           WriteVector[loc,vector];	                   loc _ loc + 17;		           str.length _ 0;		           len _ 0;		           num _ num + 1;			   count _ count + 1;		  	   IF num MOD 10 = 0 THEN Put.Text[data.fileSW, "."L]}			 ELSE			   {len _ 0;			   str.length _ 0;			   IF count MOD 10 = 0 THEN Put.Text[data.fileSW, "."L];			   count _ count + 1}}		       ELSE {		         Put.Text[data.fileSW, "Invalid vector length at ["L];	                 temp _ Stream.GetPosition[filePtr];		         Put.LongDecimal[data.fileSW, temp - len - 1];                         Put.Line[data.fileSW, "]"L];		         EXIT}}};	'/      => {IF ~comment THEN comment _ TRUE ELSE comment _ FALSE;	            skipCR _ TRUE;		    str.length _ 0;  -- In case comment had 0's, 1's or x's		    len _ 0};	ENDCASE => {IF ~comment THEN {                      Put.Text[data.fileSW, "Invalid character at ["L];	              temp _ Stream.GetPosition[filePtr];		      Put.LongDecimal[data.fileSW, temp-1];                      Put.Line[data.fileSW, "]"L];		      EXIT}};      ENDLOOP;    Stream.Delete[filePtr];    filePtr _ NIL;    TestVectorIO.WriteMemoryWord[location.number,num];    Put.CR[data.fileSW];    IF data.loadrange = 1 AND num # 0 THEN {      Put.Text[data.fileSW,"Vectors "L];      Put.LongDecimal[data.fileSW, data.starting];      Put.Text[data.fileSW," thru "L];      Put.LongDecimal[data.fileSW, data.ending];      Put.Line[data.fileSW," loaded"L];};    Put.LongDecimal[data.fileSW, num];    Put.Line[data.fileSW," vectors successfully loaded"L];    IF num # 0 THEN Loaded _ TRUE;    END;  LoadVectors:  FormSW.ProcType = {    ENABLE {    TestVectorIO.Error => {NewMessage[reason]; CONTINUE;};    Bindweed.Error => {SELECT code FROM                 timeout => { AppendMessage["Failed"L]; Put.Line[data.fileSW,                             "Timeout occured"L]};                 badCheckSum => { AppendMessage["Failed"L]; Put.Line[data.fileSW,                                 "Bad Chack Sum"L]};                 umbilicalNotWorking => {AppendMessage["Failed"L]; Put.Line                                     [data.fileSW, "Umbilical not working"L]};		 ENDCASE;		 CONTINUE};       UNWIND => NULL;    };    SELECT TRUE FROM      ~Booted => NewMessage["Must boot first"L];      Running => NewMessage["Test already in progress"L];      ENDCASE => {IF data.filename = NIL OR data.filename.length = 0 THEN {                    NewMessage["No file name entered"L]; RETURN};		 data.errLog _ FALSE;		 FormSW.DisplayItem[data.formSW,ORD[FormItems.errLog]];		 IF ~LoadFile[data.filename] THEN RETURN;                 Put.CR[data.msgSW];		 Put.Text[data.msgSW, "Vectors Loaded"L]; 		 err _ 0;		 Single _ FALSE;		 StopCalled _ FALSE;		 preamble _ FALSE;		 Loaded _ TRUE;		 First _ TRUE;        }};	  NewMessage: PROCEDURE  [s: LONG STRING] =    BEGIN    Put.CR[data.msgSW];    Put.Text[data.msgSW, s];    TextSW.ForceOutput[data.msgSW];    END;      NoBindweed: PROCEDURE = {    NewMessage["Bindweed is not loaded"L];    UserTerminal.BlinkDisplay[];    };  ReadVector: PROCEDURE [addr: LONG CARDINAL] RETURNS [data: Vector] = {    ENABLE UNWIND => NULL;    dataPtr: LONG POINTER TO Bindweed.Sequence _ Heap.systemZone.NEW[      Bindweed .Sequence[17] _ [length: 17, seq: NULL]];    TestVectorIO.ReadMemoryDataSequence[addr,dataPtr];    FOR i:CARDINAL IN [1..17] DO      data[i] _ dataPtr[i-1];      ENDLOOP;    Heap.systemZone.FREE[@dataPtr];    };      Results: PROCEDURE RETURNS [Done: BOOLEAN]= {    ENABLE {    TestVectorIO.Error => {NewMessage[reason]; CONTINUE;};    Bindweed.Error => {SELECT code FROM                 timeout => { AppendMessage["Failed"L]; Put.Line[data.fileSW,                             "Timeout occured"L]};                 badCheckSum => { AppendMessage["Failed"L]; Put.Line[data.fileSW,                                 "Bad Chack Sum"L]};                 umbilicalNotWorking => {AppendMessage["Failed"L]; Put.Line                                     [data.fileSW, "Umbilical not working"L]};		 ENDCASE;		 CONTINUE};    UNWIND => NULL;    };    Result, original: Vector;    count: WORD;    Flag: Environment.Byte;    Flag _ TestVectorIO.ReadMemoryByte[location.ErrFlag];    IF Flag = 255 THEN {      IF data.alwaysCheck THEN Put.Line[data.fileSW,"WARNING AlwaysCheck flag set"L];      Put.Text[data.fileSW, "Test failed at vector #"L];      count _ TestVectorIO.ReadMemoryWord[location.count];      Put.Decimal[data.fileSW, count];      Put.CR[data.fileSW];      original _ ReadVector[location.original];      Put.Text[data.fileSW, "Original vector  = "L];      DisplayVector[original];      Result _ ReadVector[location.result];      Put.Text[data.fileSW, "Resulting vector = "L];      DisplayVector[Result];      err _ err + 1;      Done _ FALSE;      IF data.errLog AND ~Single AND ~preamble THEN ErrLog[count,original,Result];      }    ELSE {      Put.CR[data.fileSW];      Put.Line[data.fileSW, "Test Complete"L];      Done _ TRUE};    count _ TestVectorIO.ReadMemoryWord[location.count];    Put.Decimal[data.fileSW, count - err];    Put.Text[data.fileSW, " out of "L];    Put.Decimal[data.fileSW, count];    Put.Line[data.fileSW, " vectors tested OK"L];    Put.CR[data.fileSW];    };      SendNull: PROCEDURE = {    ENABLE {    TestVectorIO.Error => {NewMessage[reason]; CONTINUE;};    Bindweed.Error => {SELECT code FROM                 timeout => { AppendMessage["Failed"L]; Put.Line[data.fileSW,                             "Timeout occured"L]};                 badCheckSum => { AppendMessage["Failed"L]; Put.Line[data.fileSW,                                 "Bad Chack Sum"L]};                 umbilicalNotWorking => {AppendMessage["Failed"L]; Put.Line                                     [data.fileSW, "Umbilical not working"L]};		 ENDCASE;		 CONTINUE};    UNWIND => NULL;    };    vector: Vector;    vector _ Convert["101111110010000000000110000000000000000011100100000000000000000001000000000011111100000000000000000000001111100000000000"L];    NewMessage[" "L];    TestVectorIO.ReadSavedRegisters[];    WriteVector[location.table,vector];    TestVectorIO.WriteMemoryWord[location.number,1];    TestVectorIO.WriteMemoryWord[location.delay,data.delay];      TestVectorIO.WriteRegister[IP,location.start];    TestVectorIO.WriteRegister[CS,location.base];    TestVectorIO.WriteRegister[DS,location.dataseg];    TestVectorIO.WriteSavedRegisters[];    TestVectorIO.Continue[];    Running _ TRUE;    null _ TRUE;    };  SendPreamble:  FormSW.ProcType = {    ENABLE {    TestVectorIO.Error => {NewMessage[reason]; CONTINUE;};    Bindweed.Error => {SELECT code FROM                 timeout => { AppendMessage["Failed"L]; Put.Line[data.fileSW,                             "Timeout occured"L]};                 badCheckSum => { AppendMessage["Failed"L]; Put.Line[data.fileSW,                                 "Bad Chack Sum"L]};                 umbilicalNotWorking => {AppendMessage["Failed"L]; Put.Line                                     [data.fileSW, "Umbilical not working"L]};		 ENDCASE;		 CONTINUE};    UNWIND => NULL;    };    SELECT TRUE FROM      ~Booted => NewMessage["Must boot first"L];      Running => NewMessage["Test already in progress"L];      ENDCASE => {IF ~LoadFile["Preamble.vectors"L] THEN RETURN;                 Put.CR[data.msgSW];                 Put.Text[data.msgSW, "Running Preamble..."L];		 TestVectorIO.ReadSavedRegisters[];		 TestVectorIO.WriteMemoryWord[location.delay,data.delay];		 TestVectorIO.WriteRegister[IP,location.start];		 TestVectorIO.WriteRegister[CS,location.base];		 TestVectorIO.WriteSavedRegisters[];		 TestVectorIO.Continue[];		 err _ 0;		 Running _ TRUE;		 Single _ FALSE;		 StopCalled _ FALSE;		 preamble _ TRUE;    }};  Step:  FormSW.ProcType = {    ENABLE {    TestVectorIO.Error => {NewMessage[reason]; CONTINUE;};    Bindweed.Error => {SELECT code FROM                 timeout => { AppendMessage["Failed"L]; Put.Line[data.fileSW,                             "Timeout occured"L]};                 badCheckSum => { AppendMessage["Failed"L]; Put.Line[data.fileSW,                                 "Bad Chack Sum"L]};                 umbilicalNotWorking => {AppendMessage["Failed"L]; Put.Line                                     [data.fileSW, "Umbilical not working"L]};		 ENDCASE;		 CONTINUE};     UNWIND => NULL;    };    number,count: WORD;    SELECT TRUE FROM      ~Booted => NewMessage["Must boot first"L];      Running => {NewMessage["Test already in progress"L];                  UserTerminal.BlinkDisplay[];};      ~Loaded => NewMessage["Must Load Vectors first"L];      ENDCASE =>  {        IF First THEN {TestVectorIO.WriteMemoryWord[location.delay,data.delay];	               TestVectorIO.WriteRegister[IP,location.start];	     	       TestVectorIO.WriteRegister[CS,location.base];		       TestVectorIO.WriteRegister[DS,location.dataseg];	               TestVectorIO.WriteSavedRegisters[];		       TestVectorIO.Continue[];		       Running _ TRUE;		       Single _ TRUE;		       First _ FALSE;		       RETURN;};        count _ TestVectorIO.ReadMemoryWord[location.count];	number _ TestVectorIO.ReadMemoryWord[location.number];	IF count > number THEN {Put.Line[data.fileSW,                                                           "No more vectors to step thru"L];                                                  RETURN};        Put.Text[data.fileSW, "Testing vector #"L];        Put.Decimal[data.fileSW, count+1];        Put.CR[data.fileSW];	Continue[];	Single _ TRUE;    }};  stop:  FormSW.ProcType = {    ENABLE {    TestVectorIO.Error => {NewMessage[reason]; CONTINUE;};    Bindweed.Error => {SELECT code FROM                 timeout => { AppendMessage["Failed"L]; Put.Line[data.fileSW,                             "Timeout occured"L]};                 badCheckSum => { AppendMessage["Failed"L]; Put.Line[data.fileSW,                                 "Bad Chack Sum"L]};                 umbilicalNotWorking => {AppendMessage["Failed"L]; Put.Line                                     [data.fileSW, "Umbilical not working"L]};		 ENDCASE;		 CONTINUE};    UNWIND => NULL;    };    temp: BOOLEAN;    StopCalled _ TRUE;    IF ~Running THEN RETURN;    TestVectorIO.Stop[];    NewMessage["Test stopped"L];    Put.CR[data.fileSW];    Running _ FALSE;    temp _ Results[];    IF errlog # NIL THEN {Stream.Delete[errlog]; errlog _ NIL;};     };       SubString: PROCEDURE [s,a: LONG STRING, start,len: CARDINAL] RETURNS                       [a1: LONG STRING] = {    j: CARDINAL _ 0;    a.length _ len;    IF start + len > s.length THEN len _ s.length - start;    FOR i: CARDINAL IN [start..start+len-1] DO      a[j] _ s[i];      j _ j + 1;      ENDLOOP;    RETURN[a];   };  TestSingleVector:  FormSW.ProcType = {    ENABLE {    TestVectorIO.Error => {NewMessage[reason]; CONTINUE;};    Bindweed.Error => {SELECT code FROM                 timeout => { AppendMessage["Failed"L]; Put.Line[data.fileSW,                             "Timeout occured"L]};                 badCheckSum => { AppendMessage["Failed"L]; Put.Line[data.fileSW,                                 "Bad Chack Sum"L]};                 umbilicalNotWorking => {AppendMessage["Failed"L]; Put.Line                                     [data.fileSW, "Umbilical not working"L]};		 ENDCASE;		 CONTINUE};    UNWIND => NULL;    };    vector: Vector;    SELECT TRUE FROM      ~Booted => NewMessage["Must boot first"L];      Running => {NewMessage["Test already in progress"L];                  UserTerminal.BlinkDisplay[];}      ENDCASE =>               {IF data.vector = NIL OR data.vector.length = 0 THEN                NewMessage["No vector entered"L]              ELSE              {IF data.vector.length # 120 THEN                                                     NewMessage["Invalid test vector - wrong length"L]              ELSE {	        err _ 0;                vector _ Convert[data.vector];                NewMessage[" "L];                TestVectorIO.ReadSavedRegisters[];	        WriteVector[location.table,vector];	        TestVectorIO.WriteMemoryWord[location.number,1];		TestVectorIO.WriteMemoryWord[location.delay,data.delay];	        TestVectorIO.WriteRegister[IP,location.start];		TestVectorIO.WriteRegister[CS,location.base];		TestVectorIO.WriteRegister[DS,location.dataseg];	        TestVectorIO.WriteSavedRegisters[];		Put.Text[data.fileSW, "Testing Vector "L];       	        DisplayVector[vector];		Put.CR[data.fileSW];	        TestVectorIO.Continue[];	        Running _ TRUE;		Single _ TRUE;		StopCalled _ FALSE;		preamble _ FALSE;		Loaded _ FALSE;     }}}};  TestMultipleVectors:  FormSW.ProcType = {    ENABLE {    TestVectorIO.Error => {NewMessage[reason]; CONTINUE;};    Bindweed.Error => {SELECT code FROM                 timeout => { AppendMessage["Failed"L]; Put.Line[data.fileSW,                             "Timeout occured"L]};                 badCheckSum => { AppendMessage["Failed"L]; Put.Line[data.fileSW,                                 "Bad Chack Sum"L]};                 umbilicalNotWorking => {AppendMessage["Failed"L]; Put.Line                                     [data.fileSW, "Umbilical not working"L]};		 ENDCASE;		 CONTINUE};    UNWIND => NULL;    };    abort: BOOLEAN;    SELECT TRUE FROM      ~Booted => NewMessage["Must boot first"L];      Running => NewMessage["Test already in progress"L];      ENDCASE => {IF data.filename = NIL OR data.filename.length = 0 THEN {                    NewMessage["No file name entered"L]; RETURN};		 IF data.errLog THEN {		   [errlog,abort] _ TVError.MakeFile[data.fileSW,data.filename];		   IF abort THEN RETURN;};		 IF ~LoadFile[data.filename] THEN RETURN;                 Put.CR[data.msgSW];                 Put.Text[data.msgSW, "Testing..."L];		 TestVectorIO.ReadSavedRegisters[];		 TestVectorIO.WriteMemoryWord[location.delay,data.delay];		 TestVectorIO.WriteRegister[IP,location.start];		 TestVectorIO.WriteRegister[CS,location.base];		 TestVectorIO.WriteSavedRegisters[];		 TestVectorIO.Continue[];		 err _ 0;		 Running _ TRUE;		 Single _ FALSE;		 StopCalled _ FALSE;		 preamble _ FALSE;		 Loaded _ FALSE;      }};        WriteVector: PROCEDURE [addr:LONG CARDINAL, data: Vector] = {    ENABLE UNWIND => NULL;    dataPtr: LONG POINTER TO Bindweed.Sequence _ Heap.systemZone.NEW[      Bindweed .Sequence[17] _ [length: 17, seq: NULL]];    FOR i:CARDINAL IN [1..17] DO      dataPtr[i-1] _ data[i];      ENDLOOP;    TestVectorIO.WriteMemoryDataSequence[addr,dataPtr];    Heap.systemZone.FREE[@dataPtr];    };  ClientTransition: ToolWindow.TransitionProcType = {    SELECT TRUE FROM      old = inactive => {        IF data = NIL THEN data _ zone.NEW[Data _ []];	IF location = NIL THEN location _ Heap.systemZone.NEW[ASMLoc _ []];	Booted _ FALSE;	Bindweed.AddNotify[Halted, 4 	  ! Runtime.UnboundProcedure => {NoBindweed[]; CONTINUE}; ];};      new = inactive => {        IF data # NIL THEN {zone.FREE[@data]};	IF location # NIL THEN Heap.systemZone.FREE[@location];	IF errlog # NIL THEN {Stream.Delete[errlog]; errlog _ NIL;};	  Bindweed.RemoveNotify[4, Halted  	  ! Runtime.UnboundProcedure => {NoBindweed[]; CONTINUE};];};      ENDCASE;    };  Init: PROCEDURE [h: Exec.Handle] = {    herald: STRING = [100];    ttH: TTY.Handle _ Exec.GetTTY[h];    String.AppendString[herald, "TestVector Tool "L];    Version.Append[herald];    String.AppendString[herald, " of "L];    Time.Append[herald, Time.Unpack[Runtime.GetBcdTime[]]];    IF  ~Runtime.IsBound[LOOPHOLE[Bindweed.ReadMemoryBlock, Runtime.ControlLink]]       THEN      BEGIN      TTY.PutString[h: ttH, s: "Please run IOPBermuda.bcd before continuing"L];      Exec.ReleaseTTY[ttH];    RETURN;    END;          wh _ Tool.Create[      makeSWsProc: MakeSWs, initialState: default,      clientTransition: ClientTransition, name: herald,      cmSection: "TVectorTool"L];    initialized _ TRUE;    };  MakeSWs: Tool.MakeSWsProc = {    logName: LONG STRING _ [29];    Tool.UnusedLogName[unused: logName, root: "TestVector.log"L];    data.msgSW _ Tool.MakeMsgSW[window: window];    data.formSW _ Tool.MakeFormSW[      window: window, formProc: MakeForm, h:105];    data.fileSW _ Tool.MakeFileSW[window: window, name: logName];    };  MakeForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = FormItems.LAST.ORD + 1;    dontCares: ARRAY[0..2) OF Enumerated _ [      ["0"L, 0], ["1"L, 1]];    loadrange: ARRAY[0..2) OF Enumerated _ [      ["All"L, 0], ["Range"L, 1]];    items _ AllocateItemDescriptor[nItems];    items[FormItems.boot.ORD] _ CommandItem[      tag: "Boot"L, place: [6, line0], proc: Boot];    items[FormItems.testSingleVector.ORD] _ CommandItem[      tag: "Test Single Vector"L, place: [60, line0], proc: TestSingleVector];    items[FormItems.dontCares.ORD] _ EnumeratedItem[      tag: "Don't Cares"L, place: [228, line0], feedback: all, choices: DESCRIPTOR[dontCares], value: @data.dontCares];    items[FormItems.alwaysCheck.ORD] _ BooleanItem[      tag: "AlwaysCheck"L, place: [378, line0], switch: @data.alwaysCheck];    items[FormItems.loadvectors.ORD] _ CommandItem[      tag: "Load"L, place: [6, line1], proc: LoadVectors];    items[FormItems.testMultipleVectors.ORD] _ CommandItem[      tag: "Test Multiple Vectors"L, place: [60, line1], proc: TestMultipleVectors];    items[FormItems.loadrange.ORD] _ EnumeratedItem[      tag: "Load"L, place: [228, line1], feedback: all, choices: DESCRIPTOR[loadrange], value: @data.loadrange];    items[FormItems.errLog.ORD] _ BooleanItem[      tag: "ErrLog"L, place: [378, line1], switch: @data.errLog];    items[FormItems.step.ORD] _ CommandItem[      tag: "Step"L, place: [6, line2], proc: Step];    items[FormItems.sendPreamble.ORD] _ CommandItem[      tag: "Send Preamble"L, place: [60, line2], proc: SendPreamble];    items[FormItems.starting.ORD] _ NumberItem[      tag: "Starting # "L, place: [228, line2], signed: FALSE, value: @data.starting];    items[FormItems.delay.ORD] _ NumberItem[      tag: "Delay"L, place: [378, line2], signed: FALSE, value: @data.delay];    items[FormItems.stop.ORD] _ CommandItem[      tag: "STOP"L, place: [6, line3], proc: stop];    items[FormItems.filename.ORD] _ StringItem[      tag: "Filename"L, place: [60, line3], inHeap: TRUE, string: @data.filename];    items[FormItems.ending.ORD] _ NumberItem[      tag: "Ending # "L, place: [240, line3], signed: FALSE, value: @data.ending];    items[FormItems.vector.ORD] _ StringItem[      tag: "Vector"L, place: [6, line4], inHeap: TRUE, string: @data.vector];    RETURN[items: items, freeDesc: TRUE];    }; IgnoreCommandLine: Exec.ExecProc = BEGIN IF NOT initialized THEN Init[h]; END;    Register: PROC = {Exec.AddCommand[name: "TVectorTool2.~"L, proc:                     IgnoreCommandLine]};  -- Mainline code  Register[];  -- this gets string out of global frame    }...    
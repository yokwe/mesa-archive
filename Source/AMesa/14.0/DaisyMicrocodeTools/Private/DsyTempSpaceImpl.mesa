-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. -- last edit by JAC   		 5-Nov-84 14:32:50-- The purpose of this module is to allocate and free temp storage.      DIRECTORY  Environment USING [bytesPerPage, wordsPerPage],  Heap USING [systemZone],  MFile USING [Acquire, CopyFileHandle, Delete, Handle, Release, SetLength],   MSegment USING [Address, Create, Delete, Error],  String USING [AppendString, WordsForString],  DsyAssembler,  DsyControl USING [argBuf, FatalError, TtyLine],  DsyFile USING [CloseStream, fImc, LogLine, outFile, ReplaceExt, PassFileHandle, siStream, sourceFileNames, StmtFileHandle],  DsyModule;  DsyTempSpaceImpl: PROGRAM  IMPORTS Heap, MFile, MSegment, String, DsyControl, DsyFile EXPORTS DsyModule, DsyAssembler =  BEGIN  OPEN DsyAssembler;     -- GLOBAL VARIABLES    CurrStmtPos: LONG POINTER;  CurrPassPos: LONG POINTER;  PassBytes: LONG CARDINAL = PassPages*Environment.bytesPerPage;  PassFileLength: LONG CARDINAL;    PassMultiSegPtr: passMultiSegPtr ¬ NIL;  PassPages: CARDINAL = 10;  PassWordsAllocated: CARDINAL ¬ 0;  StmtBytes: LONG CARDINAL = StmtPages*Environment.bytesPerPage;  StmtFileLength: LONG CARDINAL;   StmtMultiSegPtr: stmtMultiSegPtr ¬ NIL;   StmtPages: CARDINAL = 50;    StmtWordsAllocated: CARDINAL ¬ 0;    stringWords: CARDINAL;    TotalPassWords: CARDINAL = PassPages*Environment.wordsPerPage;  TotalStmtWords: CARDINAL = StmtPages*Environment.wordsPerPage;    --PRIVATE VARIABLES  errorMessage: LONG STRING = "Insufficient space.  Please clean up volume before retrying.";    InitGlobalTempSpace: PUBLIC PROCEDURE =    BEGIN    PassMultiSegPtr ¬ NIL;    StmtMultiSegPtr ¬ NIL;    PassWordsAllocated ¬ 0;    StmtWordsAllocated ¬ 0;    PassFileLength ¬ 0;    StmtFileLength ¬ 0;    stringWords ¬ String.WordsForString[maxArgLength];    END;  --InitGlobalTempSpace        SaveArgs: PUBLIC PROCEDURE [    arrayP: LONG POINTER TO ARRAY [0..sizeArgArray] OF LONG STRING,    num: [0..sizeArgArray]] =    BEGIN    i: CARDINAL;    arrayP­[0] ¬ GetStmtSpace[(num + 1)*stringWords];    arrayP­[0]­ ¬ [length: 0, maxlength: maxArgLength, text:];    String.AppendString[arrayP­[0], DsyControl.argBuf[0]];    FOR i IN [1..num] DO      arrayP­[i] ¬ LOOPHOLE[arrayP­[i - 1] + stringWords];      arrayP­[i]­ ¬ [length: 0, maxlength: maxArgLength, text:];      String.AppendString[arrayP­[i], DsyControl.argBuf[i]];      ENDLOOP;    END;      CreateStmtSegment: PUBLIC PROCEDURE =     BEGIN        NoRoom: PROCEDURE =      BEGIN      DsyControl.TtyLine[errorMessage];      DsyFile.LogLine[errorMessage];      IF DsyFile.siStream # NIL THEN {  --processing mc's        DsyFile.siStream ¬ DsyFile.CloseStream[DsyFile.siStream];	DsyFile.siStream ¬ NIL; --so won't try to reclose when cleaning up	MFile.Delete[MFile.Acquire[ DsyFile.ReplaceExt[DsyFile.sourceFileNames[DsyFile.fImc], "si"],delete, [NIL,NIL]]]};	MFile.Release[TempPtr­.StmtFileHandle];	Heap.systemZone.FREE[@TempPtr];	DsyControl.FatalError;	END;  --NoRoom	        TempPtr: stmtMultiSegPtr;            StmtFileLength ¬ StmtFileLength + StmtBytes;    MFile.SetLength[DsyFile.StmtFileHandle, StmtFileLength];    TempPtr ¬ Heap.systemZone.NEW[stmtMultiSeg];    TempPtr­.nextSeg ¬ StmtMultiSegPtr;    TempPtr­.StmtFileHandle ¬ MFile.CopyFileHandle[file: DsyFile.StmtFileHandle, release: [NIL, NIL]];    StmtMultiSegPtr ¬ TempPtr;    StmtMultiSegPtr­.StmtSeg ¬  MSegment.Create[file:StmtMultiSegPtr­.StmtFileHandle, release: [NIL, NIL], fileBase: (StmtFileLength-StmtBytes)/Environment.bytesPerPage, pages: StmtPages ! MSegment.Error => IF (code = insufficientVM) OR (code = noRoomOnVolume) THEN      NoRoom];    StmtMultiSegPtr­.StmtSegPtr ¬ MSegment.Address[StmtMultiSegPtr­.StmtSeg];     CurrStmtPos ¬ StmtMultiSegPtr­.StmtSegPtr;    END;   --CreateStmtSegment       CreatePassSegment: PUBLIC PROCEDURE =     BEGIN    TempPtr: passMultiSegPtr;    PassFileLength ¬ PassFileLength + PassBytes;    MFile.SetLength[DsyFile.PassFileHandle, PassFileLength];    TempPtr ¬ Heap.systemZone.NEW[passMultiSeg];    TempPtr­.nextSeg ¬ PassMultiSegPtr;    TempPtr­.PassFileHandle ¬ MFile.CopyFileHandle[file: DsyFile.PassFileHandle, release: [NIL, NIL]];    PassMultiSegPtr ¬ TempPtr;    PassMultiSegPtr­.PassSeg ¬ MSegment.Create[file: PassMultiSegPtr­.PassFileHandle, release: [NIL, NIL], fileBase: (PassFileLength-PassBytes)/Environment.bytesPerPage, pages: PassPages !       MSegment.Error => IF (code = insufficientVM) OR (code = noRoomOnVolume)         THEN {DsyControl.TtyLine[errorMessage];        DsyFile.LogLine[errorMessage];	MFile.Release[TempPtr­.PassFileHandle];	Heap.systemZone.FREE[@TempPtr];	DsyControl.FatalError}];    PassMultiSegPtr­.PassSegPtr ¬ MSegment.Address[PassMultiSegPtr­.PassSeg];    CurrPassPos ¬ PassMultiSegPtr­.PassSegPtr;    END;    DeletePassSegment: PUBLIC PROCEDURE =     BEGIN    TempPtr: passMultiSegPtr;    IF PassMultiSegPtr # NIL THEN {   --no user abort      IF PassMultiSegPtr.nextSeg # NIL THEN FreePassSpace;      TempPtr ¬ PassMultiSegPtr­.nextSeg;      MSegment.Delete[PassMultiSegPtr­.PassSeg];      Heap.systemZone.FREE[@PassMultiSegPtr];      PassMultiSegPtr ¬ TempPtr;      MFile.Release[DsyFile.PassFileHandle];           DsyFile.PassFileHandle ¬ MFile.Acquire[name: DsyFile.ReplaceExt[DsyFile.outFile, "pf"], access: delete, release: [NIL,NIL]];      MFile.Delete[DsyFile.PassFileHandle];      DsyFile.PassFileHandle ¬ NIL}          END;      DeleteStmtSegment: PUBLIC PROCEDURE =     BEGIN    TempPtr: stmtMultiSegPtr;              IF StmtMultiSegPtr # NIL THEN {       --no user abort      IF StmtMultiSegPtr­.nextSeg # NIL THEN FreeStmtSpace;      TempPtr ¬ StmtMultiSegPtr­.nextSeg;            MSegment.Delete[StmtMultiSegPtr­.StmtSeg];      Heap.systemZone.FREE[@StmtMultiSegPtr];      StmtMultiSegPtr ¬ TempPtr;               MFile.Release[DsyFile.StmtFileHandle];           DsyFile.StmtFileHandle ¬ MFile.Acquire[name: DsyFile.ReplaceExt[DsyFile.outFile, "sf"], access: delete, release: [NIL,NIL]];      MFile.Delete[DsyFile.StmtFileHandle];      DsyFile.StmtFileHandle ¬ NIL}       END;    FreePassSpace: PUBLIC PROCEDURE =     BEGIN    TempPtr: passMultiSegPtr;    UNTIL PassMultiSegPtr­.nextSeg = NIL DO      TempPtr ¬ PassMultiSegPtr­.nextSeg;      PassFileLength ¬ PassFileLength - PassBytes;      MFile.SetLength[DsyFile.PassFileHandle, PassFileLength];      MSegment.Delete[PassMultiSegPtr­.PassSeg];      Heap.systemZone.FREE[@PassMultiSegPtr];      PassMultiSegPtr ¬ TempPtr;            ENDLOOP;    CurrPassPos ¬ PassMultiSegPtr­.PassSegPtr;    PassWordsAllocated ¬ 0;    END;      FreeStmtSpace: PUBLIC PROCEDURE =     BEGIN    TempPtr: stmtMultiSegPtr;            UNTIL StmtMultiSegPtr­.nextSeg = NIL DO      TempPtr ¬ StmtMultiSegPtr­.nextSeg;      StmtFileLength ¬ StmtFileLength - StmtBytes;      MFile.SetLength[DsyFile.StmtFileHandle, StmtFileLength];      MSegment.Delete[StmtMultiSegPtr­.StmtSeg];      Heap.systemZone.FREE[@StmtMultiSegPtr];      StmtMultiSegPtr ¬ TempPtr;             ENDLOOP;    CurrStmtPos ¬ StmtMultiSegPtr­.StmtSegPtr;    StmtWordsAllocated ¬ 0;           END;    GetPassSpace: PUBLIC PROCEDURE[nWords: CARDINAL] RETURNS [LONG POINTER] =    BEGIN    OldPassPos: LONG POINTER;    PassWordsAllocated ¬ PassWordsAllocated + nWords;    IF PassWordsAllocated > TotalPassWords THEN      BEGIN      CreatePassSegment;      PassWordsAllocated ¬ nWords;      END;    OldPassPos ¬ CurrPassPos;    CurrPassPos ¬ CurrPassPos + nWords;    RETURN[OldPassPos];    END;      GetStmtSpace: PUBLIC PROCEDURE[nWords: CARDINAL] RETURNS [LONG POINTER] =     BEGIN    OldStmtPos: LONG POINTER;    StmtWordsAllocated ¬ StmtWordsAllocated + nWords;    IF StmtWordsAllocated > TotalStmtWords THEN      BEGIN      CreateStmtSegment;      StmtWordsAllocated ¬ nWords;      END;    OldStmtPos ¬ CurrStmtPos;            CurrStmtPos ¬ CurrStmtPos + nWords;        RETURN[OldStmtPos];    END;        END...--Log of last edits:--JAC   	 5-Nov-84 14:33:00	fixed arrows for Mesa 11.1
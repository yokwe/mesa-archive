-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. --Last edit by JAC          5-Nov-84 14:31:37DIRECTORY  Ascii USING [CR],  Environment USING [Byte, bytesPerWord, Block],   Format USING [Number, NumberFormat, StringProc],   Inline USING [BITAND, BITOR, BITSHIFT, BITXOR],  MSegment USING [Delete],  Stream USING [    GetBlock, GetPosition, GetWord, Position, PutBlock, PutChar, PutString,    SetPosition],  String USING [AppendChar, AppendDecimal, AppendString],  Time USING [AppendCurrent],  DsyAssembler USING [GetPassSpace, ParityMasks],  DsyuFormat,  DsyControl USING [FatalError, noFinalFiles, noFTfile],  DsyFile USING [    CloseStream, ebStream, fbFileSize, fbOutStream, fbSeg,  ftStream,    LogLine, LogText, mlStream, OpenFbOut, OpenFbSort, OpenFt, OpenNextEb,    OpenNextMl, outFile, stStream],  DsyLabel,    DsyP2Hash USING [    bad, ConstraintArray, constraintArray, curID, EraseMiSpace, ErasePass2Hash,    EraseXSpace, errorLevel, ExportDataRecPtr, ExportRec, exportRecList,    GetMiSpace, maxMI, miLtoV, miVtoLtxt, labIoff, MiRtoV, miRtoV,    miVtoR, Mi2Res, mi2Res, miIoff, NoTxt, realMI, Reserved];DsyPass2BImpl: PROGRAM  IMPORTS    Format, Inline, MSegment, Stream, String, Time, DsyAssembler, DsyControl, DsyFile, DsyLabel,    DsyP2Hash  EXPORTS DsyLabel =  BEGIN OPEN DsyuFormat, DsyAssembler, DsyLabel;  Words: TYPE = RECORD [word1, word2, word3: CARDINAL];  SortTable: TYPE = ARRAY [0..DsyP2Hash.maxMI+maxSA] OF FinalBinaryRec;    maxSA: CARDINAL = 7;  totalMIs:  MIIndex;  sortTable: LONG POINTER TO SortTable;  GenParity: PROCEDURE [pbPtr: LONG POINTER TO PartialBinary] =   --generate parity bit for MI    BEGIN    words: Words ¬ LOOPHOLE[pbPtr.instruction];    sum: CARDINAL;    sum ¬ Inline.BITXOR[words.word1, words.word2];    sum ¬ Inline.BITXOR[sum, words.word3];    sum ¬ Inline.BITXOR[sum, Inline.BITSHIFT[sum, -8]];    sum ¬ Inline.BITXOR[sum, Inline.BITSHIFT[sum, -4]];    sum ¬ Inline.BITXOR[sum, Inline.BITSHIFT[sum, -2]];    sum ¬ Inline.BITXOR[sum, Inline.BITSHIFT[sum, -1]];    sum ¬ Inline.BITAND[sum, 1];    IF sum = 0 THEN pbPtr­.instruction.parity ¬ Inline.BITXOR[1, pbPtr­.instruction.parity];    END;  -- end of procedure GenParity  Pass2Init1: PROCEDURE =     BEGIN    i: CARDINAL;    DsyP2Hash.ErasePass2Hash[];    DsyP2Hash.constraintArray ¬ DsyP2Hash.GetMiSpace[      SIZE[DsyP2Hash.ConstraintArray]];    FOR i IN [0..5120) DO      DsyP2Hash.constraintArray[i] ¬ NIL; ENDLOOP;    sortTable ¬ NIL;    END;  -- end of procedure Pass2Init1  Pass2Init2: PROCEDURE =     BEGIN    i: CARDINAL;    resCount: CARDINAL ¬ 0;    str: LONG STRING ¬ [10];    DsyP2Hash.miRtoV ¬ DsyP2Hash.GetMiSpace[SIZE[DsyP2Hash.MiRtoV]];    -- DsyP2Hash.miRtoV[address] = MIIndex of MI at that address    FOR i IN [0..4096) DO      IF DsyP2Hash.mi2Res[i] THEN {        DsyP2Hash.miRtoV[i] ¬ DsyP2Hash.Reserved; resCount ¬ resCount + 1; }      ELSE DsyP2Hash.miRtoV[i] ¬ Empty;      ENDLOOP;    DsyFile.LogText["The number of reserved locations = "L];    String.AppendDecimal[str, resCount];    DsyFile.LogLine[str];    DsyFile.LogText["The number of free locations = "L];    str.length ¬ 0;    String.AppendDecimal[str, 4096 - DsyP2Hash.realMI - resCount];    DsyFile.LogLine[str];    END;  -- end of procedure Pass2Init2  Pass2Part2: PUBLIC PROCEDURE =     BEGIN     ca: LONG POINTER TO ConstraintAttribute;    strIndex: Stream.Position;    {    Pass2Init1[];    strIndex ¬ Stream.GetPosition[DsyFile.stStream];    IF DsyP2Hash.errorLevel > DsyP2Hash.bad THEN GOTO Thru;        ReadInConstraint[];    IF DsyP2Hash.errorLevel > DsyP2Hash.bad THEN GOTO Thru;    ca ¬ BuildCAList[];    Pass2Init2[];    ProcessConstraints[ca];        IF DsyP2Hash.errorLevel > DsyP2Hash.bad THEN GOTO Thru;    AllocateUnconstrained[];    IF DsyP2Hash.errorLevel > DsyP2Hash.bad THEN GOTO Thru;    IF ~DsyControl.noFinalFiles THEN {      WriteFinalBinary[];      DsyP2Hash.EraseMiSpace[];      DsyP2Hash.EraseXSpace[];      Stream.SetPosition[DsyFile.stStream, strIndex];      MySort[];      RETURN;      };    GOTO Thru;    EXITS Thru => Stream.SetPosition[DsyFile.stStream, strIndex];    };    END;  -- end of procedure Pass2Part2  ReadInConstraint: PROCEDURE =     BEGIN    miIoffset, labIoffset: CARDINAL ¬ 0;    cr: ConstraintRec;    crBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[LONG[@cr]], startIndex: 0,      stopIndexPlusOne: Environment.bytesPerWord*SIZE[ConstraintRec]];    ccp: LONG POINTER TO ConstraintChain;    i: CARDINAL;    mii: MIIndex;    str: LONG STRING ¬ [100];    mi2Restemp: LONG POINTER TO DsyP2Hash.Mi2Res ¬ DsyP2Hash.GetMiSpace[      SIZE[DsyP2Hash.Mi2Res]];    resHere: BOOLEAN ¬ FALSE;    stIndex: CARDINAL ¬ 0;    spCnt: CARDINAL ¬ 0;    ccHere: LONG POINTER TO ConstraintChain ¬ NIL;    AddCC: PROCEDURE RETURNS [ccPtr: LONG POINTER TO ConstraintChain] = INLINE {      IF spCnt = 0 THEN {        ccHere ¬ DsyAssembler.GetPassSpace[SIZE[ConstraintChain]*250]; spCnt ¬ 249; }      ELSE {        ccHere ¬ LOOPHOLE[ccHere + SIZE[ConstraintChain]]; spCnt ¬ spCnt - 1; };      ccPtr ¬ ccHere;      };  -- end AddCC    UNTIL DsyFile.OpenNextMl[] DO  -- for each ml file      miIoffset ¬ DsyP2Hash.miIoff[stIndex];      labIoffset ¬ DsyP2Hash.labIoff[stIndex];      DO  -- for each constraint record        [] ¬ Stream.GetBlock[DsyFile.mlStream, crBlock];        IF cr.label2.type = special THEN EXIT;        mii ¬          WITH cr.label1 SELECT FROM            unlabeled => miseqnum + miIoffset,            labeled => DsyP2Hash.miLtoV[labelseqnum + labIoffset],            ENDCASE => 0;        ccp ¬ AddCC[];        ccp­.nextConstraint ¬ NIL;        ccp­.offset ¬ cr.offset;        ccp­.modulo ¬ cr.modulo;        ccp.miIndex1 ¬ mii;        WITH cr.label2 SELECT FROM          unlabeled => ccp.miIndex2 ¬ miseqnum + miIoffset;          labeled => ccp.miIndex2 ¬ DsyP2Hash.miLtoV[labelseqnum + labIoffset];          special => EXIT;          ENDCASE;        IF ccp.miIndex1 = Empty OR ccp.miIndex2 = Empty THEN LOOP;        AddConstraint[ccp];        ENDLOOP;  -- end for each constraint record      resHere ¬ LOOPHOLE[Stream.GetWord[DsyFile.mlStream], BOOLEAN];      IF resHere THEN {        [] ¬ Stream.GetBlock[          DsyFile.mlStream, Environment.Block[          blockPointer: LOOPHOLE[mi2Restemp], startIndex: 0,          stopIndexPlusOne: Environment.bytesPerWord*SIZE[DsyP2Hash.Mi2Res]]];        FOR i IN [0..4096) DO          DsyP2Hash.mi2Res[i] ¬ DsyP2Hash.mi2Res[i] OR mi2Restemp[i]; ENDLOOP};      stIndex ¬ stIndex + 1;      ENDLOOP;  -- end for each ml file    END;  -- end of procedure ReadInConstraint  MySort: PROCEDURE =  --Final binary records are originally put into fb file in the same sequence as they appeared in the mc.  Now put the fb into the order they appear in control store.    BEGIN            Index: TYPE = CARDINAL;    fbrSize: CARDINAL = SIZE[FinalBinaryRec];            Swap: PROCEDURE [p1, p2: Index] =      BEGIN      tempFbr: FinalBinaryRec;            tempFbr ¬ sortTable[p1];      sortTable[p1] ¬ sortTable[p2];      sortTable[p2] ¬ tempFbr;      END;  -- end Swap                 BubbleSort: PROCEDURE [min, max: Index] =      BEGIN            bound: Index ¬ max;      t: Index;      DO        t ¬ 0;	FOR j: Index IN [min..bound) DO	  IF sortTable[j].addr > sortTable[j+1].addr THEN {	    Swap[j, j+1];	    t ¬ j};	  ENDLOOP;	IF t = 0 THEN EXIT ELSE bound ¬ t;	ENDLOOP;       END;  -- end of procedure BubbleSort                Sort: PROCEDURE [min, max: Index] =      BEGIN      doMax: BOOLEAN ¬ TRUE;      middle: Index = (max + min) / 2;      i, j: Index;            IF min >=  max THEN RETURN;  <<fix for sort mechanism>>                 IF max - min < 8 THEN {BubbleSort[min, max]; RETURN};                  -- put the median of min, max, and middle at min       IF sortTable[middle].addr > sortTable[max].addr THEN Swap[middle, max];       IF sortTable[middle].addr > sortTable[min].addr THEN Swap[middle, min];       IF sortTable[min].addr > sortTable[max].addr THEN Swap[min, max];              i ¬ min;       j ¬ max;       WHILE i < j DO         IF sortTable[i].addr > sortTable[j].addr THEN {           Swap[i, j];	   doMax ¬ ~doMax};         IF doMax THEN j ¬ j - 1 ELSE i ¬ i + 1;         ENDLOOP;       Sort[min, i - 1];       Sort[i + 1, max];       END;  --end Sort              sortTable ¬ DsyFile.OpenFbSort[];    IF DsyFile.fbFileSize = 0 THEN RETURN;        Sort[0, totalMIs - 1];        MSegment.Delete[DsyFile.fbSeg];    DsyFile.fbSeg ¬ NIL;    sortTable ¬ NIL;    END;  -- of MySort proc  WriteFinalBinary: PROCEDURE =     BEGIN    count: INTEGER ¬ -1;    curLnum: MIIndex ¬ 0;    curMInum: MIIndex ¬ 0;    dest: LONG STRING ¬ [150];    ebr: EarlyBinaryRec;    ebrBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[LONG[@ebr]], startIndex: 0,      stopIndexPlusOne: Environment.bytesPerWord*SIZE[EarlyBinaryRec]];    exportRec: DsyP2Hash.ExportRec;    exrBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[LONG[@exportRec]], startIndex: 0,      stopIndexPlusOne: Environment.bytesPerWord*SIZE[DsyP2Hash.ExportRec]];    fbr: FinalBinaryRec;    fbrBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[LONG[@fbr]], startIndex: 0,      stopIndexPlusOne: Environment.bytesPerWord*SIZE[FinalBinaryRec]];    j: CARDINAL ¬ 0;    mi: Words;    miOff, labOff: CARDINAL ¬ 0;    sI: CARDINAL ¬ 0;    name: LONG STRING ¬ [64];    saaddr: MIIndex;    saname: LONG STRING ¬ [64];    destination: CARDINAL;    parity: ParityMasks;    ptr: DsyP2Hash.ExportDataRecPtr;    WriteFT: PROCEDURE =       BEGIN      rD: SplitrD;      dspB: SplitdspB;      ptr: LONG POINTER TO FinalBinaryRec ¬ @fbr;            Append: Format.StringProc =        BEGIN	  String.AppendString[dest, s];	END;  --of procedure Append	      PutInFT: PROCEDURE [number, columns, blanks: CARDINAL] =        BEGIN	Format.Number[proc: Append, n: number, format: Format.NumberFormat[base: 16, zerofill: TRUE, unsigned: TRUE, columns: columns]];	SELECT blanks FROM	  1 => String.AppendChar[dest, ' ];	  2 => String.AppendString[dest, "  "L];	  3 => String.AppendString[dest, "   "L];	  4 => String.AppendString[dest, "    "L];	  5 => String.AppendString[dest, "     "L];	  6 => String.AppendString[dest, "      "L];	  ENDCASE;	END;  --of procedure PutInFT      dest.length ¬ 0;      -- first word = virtual mi number      PutInFT[ptr.miNum, 4, 1];      -- second word = real address      PutInFT[ptr.addr, 4, 2];      PutInFT[ptr.partialBinary.instruction.op, 1, 1];      PutInFT[ptr.partialBinary.instruction.rA, 2, 1];      PutInFT[ptr.partialBinary.instruction.rB, 2, 1];      rD.pad ¬ 0;      rD.rDHi2 ¬ ptr.partialBinary.instruction.rDHi2;      rD.rDLo4 ¬ ptr.partialBinary.instruction.rDLo4;      PutInFT[rD.word, 2, 2];      PutInFT[ptr.partialBinary.instruction.operation, 1, 3];      PutInFT[ptr.partialBinary.instruction.ci, 1, 2];      PutInFT[ptr.partialBinary.instruction.special2, 1, 3];      PutInFT[ptr.partialBinary.instruction.special1, 1, 4];      dspB.pad ¬ 0;      dspB.dspBHi ¬ ptr.partialBinary.instruction.dspBHi;      dspB.dspBLo3 ¬ ptr.partialBinary.instruction.dspBLo3;      PutInFT[dspB.word, 1, 3];      PutInFT[ptr.partialBinary.instruction.inia, 3, 1];      PutInFT[ptr.partialBinary.instruction.parity, 1, 3];      PutInFT[ptr.partialBinary.cycle, 1, 6];      IF ptr.partialBinary.ibdisp THEN        PutInFT[1, 1, 5]      ELSE PutInFT[0, 1, 5];       IF ptr.partialBinary.mdr THEN        PutInFT[1, 1, 2]      ELSE PutInFT[0, 1, 2];      IF (fbr.miNum = 177777B) OR (fbr.miNum = 177776B) THEN {        Stream.SetPosition[DsyFile.stStream, DsyP2Hash.miVtoLtxt[saaddr]];        ReadLabelFromST[saname];        String.AppendString[dest, saname];        Stream.PutString[DsyFile.ftStream, dest];        Stream.PutChar[DsyFile.ftStream, Ascii.CR];        RETURN;        };      IF DsyP2Hash.miVtoLtxt[curLnum] = DsyP2Hash.NoTxt THEN count ¬ count + 1      ELSE {        count ¬ 0;        Stream.SetPosition[DsyFile.stStream, DsyP2Hash.miVtoLtxt[j]];        ReadLabelFromST[name];        };      String.AppendString[dest, name];      IF count # 0 THEN {        String.AppendString[dest, " + "L];	PutInFT[count, 4, 0]};      Stream.PutString[DsyFile.ftStream, dest];      Stream.PutChar[DsyFile.ftStream, Ascii.CR];      END;  -- end of procedure WriteFT     totalMIs ¬ 0;    DsyFile.OpenFbOut[];    IF NOT DsyControl.noFTfile THEN {      DsyFile.OpenFt[];      String.AppendString[dest, DsyFile.outFile];      String.AppendString[dest, " file created: "L];      Time.AppendCurrent[dest];      Stream.PutString[DsyFile.ftStream, dest];      Stream.PutChar[DsyFile.ftStream, Ascii.CR];      DsyFile.LogLine[dest];      Stream.PutString[        DsyFile.ftStream, "Vadr Radr op rA rB rD alu ci Sp2 Sp1 DspB inia P Cycle GOTO[*] mdr LABEL NAME"L];      Stream.PutChar[DsyFile.ftStream, Ascii.CR];      String.AppendString[name, "beginning m-i"L]};    UNTIL DsyFile.OpenNextEb[] DO  -- for each eb file      miOff ¬ DsyP2Hash.miIoff[sI];      labOff ¬ DsyP2Hash.labIoff[sI];      sI ¬ sI + 1;      DO  -- for each eb record        [] ¬ Stream.GetBlock[DsyFile.ebStream, ebrBlock];        IF ebr.last THEN EXIT;        fbr.partialBinary ¬ ebr.partialBinary;	parity ¬ ebr.parityMasks;        fbr.miNum ¬ curMInum;        fbr.addr ¬ DsyP2Hash.miVtoR[curMInum];        curLnum ¬ j ¬ curMInum;        WITH ebr.destMI.dest SELECT FROM          unlabeled => destination ¬ DsyP2Hash.miVtoR[miseqnum + miOff];          labeled => {            destination ¬ DsyP2Hash.miVtoR[DsyP2Hash.miLtoV[labelseqnum + labOff]];            saaddr ¬ DsyP2Hash.miLtoV[labelseqnum + labOff];            };          absolute => destination ¬ value;          ENDCASE;	SELECT ebr.sa FROM	  sa =>	    BEGIN	    fbr.miNum ¬ 177776B;            j ¬ curMInum - 1;            fbr.addr ¬ destination;	    END;	  saPlus1 =>	    BEGIN	    fbr.miNum ¬ 177777B;            j ¬ curMInum - 1;            fbr.addr ¬ destination;	    END;	  none => 	    fbr.partialBinary.instruction.inia ¬ Inline.BITOR[              ebr.destMI.orMask, Inline.BITAND[destination, ebr.destMI.andMask]];	  ENDCASE;        GenParity[@fbr.partialBinary];	mi ¬ LOOPHOLE[fbr.partialBinary.instruction];	mi.word1 ¬ Inline.BITXOR[mi.word1, parity.mask1];	mi.word2 ¬ Inline.BITXOR[mi.word2, parity.mask2];	mi.word3 ¬ Inline.BITXOR[mi.word3, parity.mask3];	fbr.partialBinary.instruction ¬ LOOPHOLE[mi];        IF ~DsyControl.noFTfile THEN WriteFT[];        [] ¬ Stream.PutBlock[DsyFile.fbOutStream, fbrBlock];        curMInum ¬ j + 1;	totalMIs ¬ totalMIs + 1;        ENDLOOP;  -- end eb record      ENDLOOP;  -- end eb file    fbr.miNum ¬ 0;    fbr.addr ¬ 177777B;    [] ¬ Stream.PutBlock[DsyFile.fbOutStream, fbrBlock];    -- now put out exports    ptr ¬ DsyP2Hash.exportRecList;    UNTIL ptr = NIL DO      exportRec ¬ DsyP2Hash.ExportRec[        id: ptr.id,        addr:        IF ptr.miIndex = Empty THEN ptr.addr ELSE DsyP2Hash.miVtoR[ptr.miIndex],        length: ptr.s.length];      [] ¬ Stream.PutBlock[DsyFile.fbOutStream, exrBlock];      [] ¬ Stream.PutBlock[        DsyFile.fbOutStream, Environment.Block[        blockPointer: LOOPHOLE[@ptr.s.text], startIndex: 0,        stopIndexPlusOne: exportRec.length]];      ptr ¬ ptr.next;      ENDLOOP;    exportRec ¬ DsyP2Hash.ExportRec[id: DsyP2Hash.curID, addr: 0, length: 0];    [] ¬ Stream.PutBlock[DsyFile.fbOutStream, exrBlock];    DsyFile.fbOutStream ¬ DsyFile.CloseStream[DsyFile.fbOutStream];    IF ~DsyControl.noFTfile THEN      DsyFile.ftStream ¬ DsyFile.CloseStream[DsyFile.ftStream];        IF curMInum > DsyP2Hash.maxMI THEN {      DsyFile.LogLine["Number of microinstructions exceeds maximum(4096)"];      DsyControl.FatalError};      IF totalMIs = 0 THEN {      DsyFile.LogLine["Error: No microinstructions were found"L];      DsyControl.FatalError};    END;  -- end of procedure WriteFinalBinary  END...--Log of last edits:--JAC   	 5-Nov-84 14:31:47	fixed arrows for Mesa 11.1
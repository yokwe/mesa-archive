-- Copyright (C) 1982, 1984  by Xerox Corporation. All rights reserved. -- FixChecksum.mesa, HGM, 13-Mar-82 13:24:58DIRECTORY  Checksum USING [ComputeChecksum],  Environment USING [wordsPerPage],  Exec USING [    AddCommand, ExecProc, FreeTokenString, GetToken, Outcome, OutputProc],  Format USING [Line, LongDecimal, Octal, StringProc, Text],  Inline USING [BITNOT, LowHalf],  MFile USING [Error, GetLength, Handle, ReadOnly, Release, SetAccess],  MSegment USING [Address, Create, Delete, Handle];FixChecksum: PROGRAM  IMPORTS    Checksum, Exec, Format, Inline, MFile, MSegment =  BEGIN  FixIt: Exec.ExecProc =    BEGIN    oldCS, oldValue, newCS, newValue: WORD ¬ 0;    Output: Format.StringProc = Exec.OutputProc[h];    file: MFile.Handle ¬ NIL;    seg: MSegment.Handle;    words: LONG CARDINAL;    buffer: LONG POINTER;    fileName, switches: LONG STRING;    failed: BOOLEAN ¬ FALSE;    [fileName, switches] ¬ Exec.GetToken[h];    IF fileName = NIL THEN      BEGIN      Format.Text[Output,"This program needs a filename as a parameter."];      RETURN[error];      END;    [] ¬ Exec.FreeTokenString[switches];    file ¬ MFile.ReadOnly[fileName, [] ! MFile.Error => CONTINUE];    IF file = NIL THEN      BEGIN      Format.Text[Output, fileName];      Format.Line[Output," is not on this disk."];      [] ¬ Exec.FreeTokenString[fileName];      RETURN[error];      END;    words ¬ (MFile.GetLength[file] + 1)/2;    Format.Text[Output, fileName];    Format.Text[Output," is "];    Format.LongDecimal[Output, words];    Format.Line[Output," words long."];    [] ¬ Exec.FreeTokenString[fileName];    IF words < 2 THEN      BEGIN      Format.Line[Output, "This program needs at least 1 word of data."];      RETURN[error];      END;    MFile.SetAccess[file, readWrite ! MFile.Error =>      BEGIN failed ¬ TRUE; CONTINUE; END ];    IF failed THEN      BEGIN      Format.Text[Output,"Can't modify file."];      MFile.Release[file];      RETURN[error];      END;    seg ¬ MSegment.Create[file, [], 0];    buffer ¬ MSegment.Address[seg];    BEGIN    loc: LONG POINTER ¬ buffer + words - 1;    IF words > 100*Environment.wordsPerPage THEN      BEGIN      hunk: CARDINAL ¬ 20*Environment.wordsPerPage;      finger: LONG POINTER ¬ buffer;      left: LONG CARDINAL ¬ words;      oldCS ¬ 0;      UNTIL left = 0 DO        IF left < hunk THEN hunk ¬ Inline.LowHalf[left];        oldCS ¬ Checksum.ComputeChecksum[oldCS, hunk, finger];        left ¬ left - hunk;        finger ¬ finger + hunk;        ENDLOOP;      END    ELSE oldCS ¬ Checksum.ComputeChecksum[0, Inline.LowHalf[words], buffer];    oldValue ¬ loc­;    newValue ¬ NewValueToMakeChecksumZero[oldCS, oldValue, words - 1, words];    loc­ ¬ newValue;    IF words > 100*Environment.wordsPerPage THEN      BEGIN      hunk: CARDINAL ¬ 20*Environment.wordsPerPage;      finger: LONG POINTER ¬ buffer;      left: LONG CARDINAL ¬ words;      newCS ¬ 0;      UNTIL left = 0 DO        IF left < hunk THEN hunk ¬ Inline.LowHalf[left];        newCS ¬ Checksum.ComputeChecksum[newCS, hunk, finger];        left ¬ left - hunk;        finger ¬ finger + hunk;        ENDLOOP;      END    ELSE newCS ¬ Checksum.ComputeChecksum[0, Inline.LowHalf[words], buffer];    END;    MSegment.Delete[seg];    Format.Text[Output,"The old checksum was "];    Format.Octal[Output, oldCS];    Format.Line[Output,"."];    IF newCS # 0 THEN      BEGIN      Format.Line[Output, "HELP! THIS PROGRAM IS BROKEN."];      RETURN[error];      END;    END;  NewValueToMakeChecksumZero: PROCEDURE [    oldChecksum: WORD, oldValue: WORD, offsetOfOldValue: LONG CARDINAL,  -- words    length: LONG CARDINAL] RETURNS [newValue: WORD] =    BEGIN    newValue ¬ OnesAdd[      LeftCycle[OnesSub[0, oldChecksum], offsetOfOldValue - length], oldValue]    END;  OnesAdd: PROCEDURE [a, b: CARDINAL] RETURNS [c: CARDINAL] = INLINE    BEGIN c ¬ a + b; IF c < a THEN c ¬ c + 1; IF c = 177777B THEN c ¬ 0; END;  OnesSub: PROCEDURE [a, b: CARDINAL] RETURNS [CARDINAL] = INLINE    BEGIN RETURN[OnesAdd[a, Inline.BITNOT[b]]]; END;  LeftCycle: PROCEDURE [a: WORD, b: LONG INTEGER] RETURNS [c: CARDINAL] = INLINE    BEGIN    n: LONG INTEGER ¬ b MOD 16;    c ¬ a;    IF b < 0 THEN n ¬ n + 16;    UNTIL n = 0 DO      IF c < 100000B THEN c ¬ c*2 ELSE c ¬ c*2 + 1; n ¬ n - 1; ENDLOOP;    END;  Init: PROC = {Exec.AddCommand["FixChecksum.~"L, FixIt]};  Init[];  END.
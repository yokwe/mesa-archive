-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved. -- VolumeVersionImpl.mesa       17-Aug-83 11:20:47 by WDK     -- BJD    	 28-Feb-84 14:10:16-- TEMPORARY HACK for Klamath <> Trinity cross volume problems.DIRECTORY  Device,  DiskChannel,  Environment,  File,  LogicalVolumeFormat,  OthelloOps,  PhysicalVolume,  PilotDisk,  PilotFileTypes,  Space,  VM,  Volume,  VolumeVersion;VolumeVersionImpl: PROGRAM  IMPORTS    DiskChannel, Environment, OthelloOps, PhysicalVolume, PilotDisk, Space, VM  EXPORTS VolumeVersion =  BEGIN  Bug: SIGNAL [b: BugType] = CODE;  BugType: TYPE = {    impossibleEndcase, invalidChannel, invalidDriveState};   Examine: PUBLIC PROCEDURE [volume: Volume.ID]    RETURNS [result: VolumeVersion.Result] =    BEGIN    lvRoot: LONG POINTER TO LogicalVolumeFormat.Descriptor;    physicalVol: PhysicalVolume.ID =      PhysicalVolume.GetContainingPhysicalVolume[volume];    pvHandle: PhysicalVolume.Handle =      PhysicalVolume.GetAttributes[physicalVol].instance;    deviceType: Device.Type;    index: CARDINAL;    subVolume: OthelloOps.SubVolume ¬ OthelloOps.nullSubVolume;    drive: DiskChannel.Drive;    DO      subVolume ¬ OthelloOps.GetNextSubVolume[physicalVol, subVolume];      IF subVolume = OthelloOps.nullSubVolume THEN RETURN[volumeUnknown];      IF subVolume.lvID = volume AND subVolume.firstLVPageNumber = 0 THEN EXIT;      ENDLOOP;    lvRoot ¬ Space.ScratchMap[count: 1].pointer;    [type: deviceType, index: index] ¬ PhysicalVolume.InterpretHandle[pvHandle];    FOR drive ¬ DiskChannel.GetNextDrive[prev: DiskChannel.nullDrive],       DiskChannel.GetNextDrive[prev: drive]      UNTIL drive = DiskChannel.nullDrive DO        dType: Device.Type;	dOrdinal: CARDINAL;	[deviceType: dType, deviceOrdinal: dOrdinal] ¬ 	  DiskChannel.GetDriveAttributes[drive];	IF dType=deviceType AND dOrdinal=index THEN EXIT	ENDLOOP;    BEGIN  --scope of Exit--    pageBuffer: Environment.PageNumber = Environment.PageFromLongPointer[lvRoot];    channel: DiskChannel.Handle = DiskChannel.Create[drive];    request: DiskChannel.IORequest ¬ [      diskPage: subVolume.firstPVPageNumber, memoryPage: pageBuffer,      tries: DiskChannel.defaultTries, label: @label,      count: 1, useSamePage: TRUE, command: [verify, read, read]];    status: DiskChannel.IOStatus;    countValid: File.PageCount;    label: PilotDisk.Label;         VM.MakeResident[[page: pageBuffer, count: 1], wait];    [status, countValid] ¬ DiskChannel.DoIO[channel, @request];    WITH boundStatus: status SELECT FROM      invalidChannel => Bug[invalidChannel];      invalidDriveState => Bug[invalidDriveState];      disk =>        IF boundStatus.status # goodCompletion THEN {result ¬ ioError; GOTO Exit};      ENDCASE => Bug[impossibleEndcase];    -- Check Logical Root Page Label:    IF volume = Volume.ID[label.fileID.id]      AND PilotDisk.GetLabelFilePage[@label] = LogicalVolumeFormat.rootPageNumber      AND ~label.temporary AND label.pad1 = 0 AND label.pad2 = 0      AND label.type = PilotFileTypes.tLogicalVolumeRootPage      THEN NULL ELSE {result ¬ badRootPageLabel; GOTO Exit};    IF lvRoot.seal # LogicalVolumeFormat.lvRootSeal THEN      {result ¬ trashedRootPage; GOTO Exit};    IF lvRoot.version # LogicalVolumeFormat.currentVersion THEN      {result ¬ otherVersion; GOTO Exit};    result ¬ currentVersion;        EXITS Exit => NULL    END;    lvRoot ¬ Space.Unmap[lvRoot];    END;   END.
-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. -- OthelloFloppy.mesa--   LXR    	10-Feb-84 16:25:51--   RXJ     	27-Feb-84 17:17:08DIRECTORY  AccessFloppy USING [    Attributes, AttributesRecord, Close, Error, ErrorType, GetAttributes,    leaderLength, LookUp, maxDataSize, Open, tFloppyLeaderPage, Time],  Ascii USING [CR, SP],  Environment USING [bytesPerPage, bytesPerWord],  Heap USING [systemZone],  File USING [File, nullFile, PageNumber, SetSize],  Floppy USING [    Error, ErrorType, FileHandle, GetFileAttributes, GetNextFile, nullFileID,    nullVolumeHandle, PageNumber, Read, VolumeHandle],  Format USING [Char, Date, Decimal, StringProc],  NSFile USING [String],  OthelloDefs USING [    AbortingCommand, CheckUserAbort, CommandProcessor, FlipCursor,    IndexTooLarge, leaderPages, MyNameIs, RegisterCommandProc,    SetCommandString, SetCursor, WriteLine, WriteString],  OthelloFetch USING [Destination, Object, Register, Select, SetLeaderPage],  Process USING [Detach],  Space USING [Map, ScratchMap, Unmap],  String USING [    AppendCharAndGrow, AppendLongDecimal, AppendStringAndGrow,    CopyToNewString, Length, LowerCase],  Time USING [Append, Unpack],  Volume USING [ID, InsufficientSpace];OthelloFloppy: PROGRAM  IMPORTS    AccessFloppy, File, Floppy, Format, Heap, OthelloDefs, OthelloFetch,    Process, Space, String, Time, Volume =  BEGIN  DoIndirect: PROC [cmFile: LONG STRING] RETURNS [mine: BOOLEAN] =    BEGIN    s: LONG STRING ¬ NIL;    GetString: PROC [c: LONG STRING] = {s ¬ String.CopyToNewString[c, Heap.systemZone]};    IF cmFile[0] = '[ THEN RETURN [FALSE];    OthelloFetch.Select[@fetcher]; OpenFloppy[];    Retrieve[cmFile, [string[GetString]]      ! UNWIND => Heap.systemZone.FREE[@s]];    OthelloDefs.WriteLine["done"L];    OthelloDefs.SetCommandString[s];    RETURN[TRUE]    END;      --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- MISC Stuff/Commands  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  floppy: Floppy.VolumeHandle ¬ Floppy.nullVolumeHandle;    FloppyOpen: PROC RETURNS [BOOLEAN] = INLINE {RETURN[floppy # Floppy.nullVolumeHandle]};    OpenCmd: PROC = {    OthelloDefs.MyNameIs[myNameIs: "Floppy Open"L, myHelpIs: "Prepare to read files from floppy"L];    OthelloFetch.Select[@fetcher];    OpenFloppy[]};  OpenFloppy: PROC = {    floppy ¬ AccessFloppy.Open[      ! AccessFloppy.Error => OthelloDefs.AbortingCommand["Can't open floppy"L];        Floppy.Error => {FloppyError[error]; RETRY}]};  CloseFloppy: PROC = {    AccessFloppy.Close[      ! AccessFloppy.Error, Floppy.Error => CONTINUE];    floppy ¬ Floppy.nullVolumeHandle};  FloppyList: PROC [pattern: LONG STRING] = {    ListFiles[IF String.Length[pattern] = 0 THEN NIL ELSE pattern]};  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Central commands  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  commandProcessor: OthelloDefs.CommandProcessor ¬ [FloppyCommands];  FloppyCommands: PROC [index: CARDINAL] = {    SELECT index FROM      0 => OpenCmd[];      ENDCASE => OthelloDefs.IndexTooLarge};  fetcher: OthelloFetch.Object ¬ [    Retrieve: Retrieve,    DoIndirect: DoIndirect,    List: FloppyList,    Close: CloseFloppy];  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- file retrieval Stuff/Commands  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  EnumProc: TYPE = PROCEDURE [    attributes: AccessFloppy.Attributes, fH: Floppy.FileHandle, name: LONG STRING]    RETURNS [stop: BOOLEAN ¬ FALSE];    ListFiles: PROCEDURE [pattern: LONG STRING] =    BEGIN    Write: Format.StringProc = {OthelloDefs.WriteString[s]};    ListOne: EnumProc =      BEGIN      Write[name];      FOR i: CARDINAL IN [name.length + WritePartial[Write, attributes]..40) DO	Format.Char[Write, Ascii.SP]; ENDLOOP;      Format.Date[Write, attributes.createDate, full];      Format.Char[Write, Ascii.CR];      END;    EnumerateFloppyFiles[ListOne, pattern ];    END;    WritePartial: PROCEDURE [Write: Format.StringProc, attributes: AccessFloppy.Attributes]    RETURNS [chars: CARDINAL ¬ 0] =    BEGIN    CountedNumber: PROCEDURE [n: LONG CARDINAL] RETURNS [CARDINAL] = {      s: STRING = [12];      String.AppendLongDecimal[s, n];      Write[s];      RETURN[s.length]};    IF attributes.offset # 0 OR attributes.size # attributes.totalSize THEN {      chars ¬ 4;      Format.Char[Write, '[];      chars ¬ chars + CountedNumber[attributes.offset];      Write[".."L];      chars ¬ chars + CountedNumber[attributes.offset+attributes.size-1];      Format.Char[Write, ']]};    END;  EnumerateFloppyFiles: PROCEDURE [    proc: EnumProc, pattern: LONG STRING ¬ NIL] =    BEGIN    nullFile: Floppy.FileHandle ¬ [volume: floppy, file: Floppy.nullFileID];    attributes: AccessFloppy.Attributes ¬ Heap.systemZone.NEW[      AccessFloppy.AttributesRecord[AccessFloppy.maxDataSize]];    name: LONG STRING = LOOPHOLE[@attributes.length];    BEGIN ENABLE Floppy.Error => {      FloppyError[error]; nullFile.volume ¬ floppy; RETRY};    FOR current: Floppy.FileHandle ¬       Floppy.GetNextFile[nullFile].nextFile,      Floppy.GetNextFile[current].nextFile      WHILE current#nullFile DO        ENABLE UNWIND => Heap.systemZone.FREE[@attributes];	OthelloDefs.CheckUserAbort[];	IF Floppy.GetFileAttributes[current].type # AccessFloppy.tFloppyLeaderPage THEN LOOP;        AccessFloppy.GetAttributes[current, attributes];        IF (pattern = NIL OR MaskFilename[file: name, mask: pattern])	  AND proc[attributes, current, name] THEN EXIT;        ENDLOOP;    END; -- ENABLE    Heap.systemZone.FREE[@attributes];    END;     MaskFilename: PROCEDURE [    file: LONG STRING, fileIndex: CARDINAL ¬ 0, mask: LONG STRING,    maskIndex: CARDINAL ¬ 0]    RETURNS [BOOLEAN] =    BEGIN    -- local variables    i, j: CARDINAL;    wildString: CHARACTER = '*;    wildChar: CHARACTER = '#;    -- process each character in mask    FOR i IN [maskIndex..mask.length) DO      SELECT mask[i] FROM        wildString =>  -- matches any string of zero or more characters          BEGIN          FOR j IN [fileIndex..file.length] DO            IF MaskFilename[file, j, mask, i + 1] THEN              RETURN[TRUE];            ENDLOOP;          RETURN[FALSE];          END;        wildChar =>  -- matches any single character          IF fileIndex = file.length THEN RETURN[FALSE]          ELSE fileIndex ¬ fileIndex + 1;        ENDCASE =>          IF fileIndex = file.length            OR String.LowerCase[file[fileIndex]] # String.LowerCase[mask[i]] THEN            RETURN[FALSE]          ELSE fileIndex ¬ fileIndex + 1;      ENDLOOP;    -- filename passes mask if entire filename has been consumed    RETURN[fileIndex = file.length];    END;  StartFeedback: SIGNAL = CODE;    -- must fix Retrieve to deal with boot files that is in pieces    Retrieve: PROC [fileName: LONG STRING, destination: OthelloFetch.Destination] = {    segmentPages, totalPages, bytes, offset: LONG CARDINAL;    name: LONG STRING ¬ NIL;    BEGIN    ENABLE Floppy.Error => {FloppyError[error]; RETRY};    fH: Floppy.FileHandle ¬ [floppy, Floppy.nullFileID];    [fh: fH, offset: offset, segmentPages: segmentPages, totalPages: totalPages, bytes: bytes, name: name] ¬ GetFile[fileName];    GrabBits[      fH: fH, offset: offset, segmentPages: segmentPages,      totalPages: totalPages, sizeBytes: bytes, destination: destination,      note: name !        StartFeedback => {	  OthelloDefs.WriteString["Fetching..."L];	  OthelloDefs.SetCursor[ftp];	  RESUME};	UNWIND => {OthelloDefs.SetCursor[pointer]; Heap.systemZone.FREE[@name]}];    Heap.systemZone.FREE[@name];    OthelloDefs.SetCursor[pointer];    END};      GetFile: PROC [fileName: LONG STRING] RETURNS [    fh: Floppy.FileHandle, offset, segmentPages, totalPages, bytes: LONG CARDINAL, name: LONG STRING] =     BEGIN    time: LONG STRING ¬ [20];    attributes: AccessFloppy.Attributes ¬ Heap.systemZone.NEW      [AccessFloppy.AttributesRecord[AccessFloppy.maxDataSize]];    name ¬ Heap.systemZone.NEW[StringBody[60]];    {ENABLE UNWIND =>       {Heap.systemZone.FREE[@attributes]; Heap.systemZone.FREE[@name]};    fh ¬ AccessFloppy.LookUp[      MakeNSString[fileName], attributes      	! AccessFloppy.Error =>  	  SELECT type FROM	    fileNotFound => OthelloDefs.AbortingCommand["No such file"L];	    volumeNotOpen => {	      CloseFloppy[];	      OpenFloppy[];	      RETRY}; 	    ENDCASE => OthelloDefs.AbortingCommand[ "Unexpected access floppy problem"L];	  Floppy.Error => {FloppyError[error]; RETRY}];    String.AppendStringAndGrow[      @name, LOOPHOLE[@attributes.length], Heap.systemZone];    String.AppendStringAndGrow[@name, " ("L, Heap.systemZone];    Time.Append[time, Time.Unpack[attributes.createDate]];    String.AppendStringAndGrow[@name, time, Heap.systemZone];    String.AppendCharAndGrow[@name, '), Heap.systemZone];    offset ¬ attributes.offset;    segmentPages ¬ attributes.size;    totalPages ¬ attributes.totalSize;    bytes ¬ attributes.totalSizeInBytes;    Heap.systemZone.FREE[@attributes]};    END;  MakeNSString: PROCEDURE [s: LONG STRING] RETURNS [NSFile.String] = {    IF s = NIL THEN RETURN[[bytes: NIL, length: 0, maxlength: 0]];    RETURN[[bytes: LOOPHOLE[@s.text], length: s.length, maxlength: s.maxlength]]};      bufPages: CARDINAL = 8;  GrabBits: PROC [    fH: Floppy.FileHandle, offset, segmentPages, totalPages: LONG CARDINAL,    sizeBytes: LONG CARDINAL, destination: OthelloFetch.Destination,    note: LONG STRING ¬ NIL] = {    base: File.PageNumber ¬ 0;    WITH destination SELECT FROM      pilotFileSystemWrite => {	buffer: LONG POINTER ¬ NIL;        File.SetSize[localFile, totalPages + OthelloDefs.leaderPages	! Volume.InsufficientSpace => OthelloDefs.AbortingCommand["Volume Full"L]];	OthelloFetch.SetLeaderPage[localFile, note];	SIGNAL StartFeedback;	WHILE base < segmentPages DO          thisPages: CARDINAL = CARDINAL[MIN[segmentPages-base, bufPages]];	  buffer ¬ Space.Map[	    window:[localFile, offset+base+OthelloDefs.leaderPages, thisPages],	    life: dead].pointer;          Floppy.Read[fH, base+AccessFloppy.leaderLength, thisPages, buffer !	    Floppy.Error => FloppyError[error];	    UNWIND => [] ¬ Space.Unmap[buffer]];          --buffer ¬ Space.Unmap[buffer, return];	  Process.Detach[LOOPHOLE[FORK Space.Unmap[buffer]]]; buffer ¬ NIL;          OthelloDefs.FlipCursor[];	  base ¬ base + thisPages;          ENDLOOP};      string => {        thisPages: CARDINAL = CARDINAL[MIN[segmentPages-base, bufPages]];        stringOverhead: CARDINAL = SIZE[StringBody]*Environment.bytesPerWord;        string: LONG STRING ¬ NIL;	IF segmentPages-base > thisPages THEN 	  OthelloDefs.AbortingCommand["Command file too long!"L];	SIGNAL StartFeedback;        string ¬ Space.ScratchMap[thisPages+1];        string­ ¬ [	  length: CARDINAL[sizeBytes],	  maxlength: bufPages*Environment.bytesPerPage - stringOverhead,	  text: ];        Floppy.Read[fH, base+AccessFloppy.leaderLength, thisPages, @string.text !	  Floppy.Error => FloppyError[error];	  UNWIND => [] ¬ Space.Unmap[string]];	stringProc[string];	[] ¬ Space.Unmap[string]};      rawWrite =>{	buffer: LONG POINTER = Space.ScratchMap[1];        count:  CARDINAL ¬ 0;	GetPage: PROC RETURNS [LONG POINTER] = {          IF count = 0 THEN SIGNAL StartFeedback;	  IF count = segmentPages THEN RETURN[NIL];          Floppy.Read[fH, base+count+AccessFloppy.leaderLength, 1, buffer !	        Floppy.Error => FloppyError[error];	        UNWIND => [] ¬ Space.Unmap[buffer]];	  count ¬ count + 1;          OthelloDefs.FlipCursor[];           RETURN[buffer]};        linkProc[GetPage ! UNWIND => [] ¬ Space.Unmap[buffer]];        [] ¬ Space.Unmap[buffer]};      ENDCASE => ERROR};     FloppyError: PROC [error: Floppy.ErrorType] =    BEGIN    myProc: Format.StringProc = {OthelloDefs.WriteString[s]};    SELECT error FROM      invalidVolumeHandle => {        AccessFloppy.Close[! AccessFloppy.Error, Floppy.Error => CONTINUE];	OpenFloppy[]; RETURN};      notReady => OthelloDefs.AbortingCommand["Can't open floppy"L];      badDisk, badSectors, hardwareError =>        OthelloDefs.AbortingCommand["Floppy hardware problem"L];      invalidFormat, invalidPageNumber, needsScavenging  =>        OthelloDefs.AbortingCommand["Floppy not readable"L];      ENDCASE => {        OthelloDefs.WriteString["Floppy error "L];        Format.Decimal[myProc, error.ORD]};    OthelloDefs.AbortingCommand[NIL]    END;      --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- initialization  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  OthelloDefs.RegisterCommandProc[@commandProcessor];  OthelloFetch.Register[@fetcher];  END.....  
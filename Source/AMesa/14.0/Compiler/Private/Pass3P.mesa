-- Copyright (C) 1983, 1986  by Xerox Corporation. All rights reserved. -- file Pass3P.mesa-- last modified by Satterthwaite, October 22, 1982 11:20 am-- last modified by Sweet,  1-Nov-83 16:19:59-- Wagner		25-Aug-86  8:15:25DIRECTORY  Alloc USING [Top, Words],  ComData USING [    defBodyLimit, interface, nBodies, nInnerBodies, ownSymbols, table, textIndex, zone],  CompilerUtil USING [],  CLog USING [Error, ErrorSei],  P3POps USING [AList, ANode, aStack, InitPass3POps, IncrCount,     AdjustForName, ComputeArgCounts, PushAList, PopAList, ExpandSei],  Symbols USING [    BodyInfo, BodyRecord, ContextLevel, SERecord,    ISEIndex, CSEIndex, RecordSEIndex, CTXIndex, BTIndex, CBTIndex,    ISENull, RecordSENull, CSENull, CTXNull, BTNull,    lL, RootBti, typeTYPE, bodyType],  SymbolOps USING [    ArgCtx, CopyArgSe, CopyXferType, CtxEntries, DelinkBti, FindExtension,    FirstCtxSe, LinkBti, MakeNonCtxSe, MakeSeChain, NewCtx, NextLevel,    NextSe, ParentBti, SetSeLink, SearchContext, TransferTypes,    StaticNestError, FromCard, FromTreeIndex, ToCard],  SymbolTable USING [Handle],  Tree USING [Index, Link, Null, NullIndex],  TreeOps USING [    CopyTree, FreeNode, FreeTree, GetNode, ListTail, MakeList, Map, NthSon, OpName,     PopTree, PushList, PushNode, PushTree, Scan, ScanList, ScanSons, SetAttr, SetInfo,    SetShared, Shared, UpdateList, UpdateLeaves,    DecodeBti, DecodeCard, EncodeBti, EncodeCard, EncodeSei];Pass3P: PROGRAM    IMPORTS      Alloc, Log: CLog, P3POps, SymbolOps, TreeOps,      dataPtr: ComData    EXPORTS CompilerUtil, P3POps = {  OPEN TreeOps, SymbolOps, Symbols, P3POps;  syms: SymbolTable.Handle ¬ NIL; -- driver  P3Postlude: PUBLIC PROC [expand: BOOLEAN] = {    syms ¬ dataPtr.ownSymbols;    InitPass3POps[syms];    IF expand THEN {LinkImportedBodies[]; ExpandInlines[RootBti]};    syms ¬ NIL;};-- included body copying  LinkImportedBodies: PROC = {    next: BTIndex;    btLimit: BTIndex = (dataPtr.table).Top[bodyType];    FOR bti: BTIndex ¬ LOOPHOLE[dataPtr.defBodyLimit], next UNTIL bti = btLimit DO      WITH body: syms.bb[bti] SELECT FROM	Callable => {	  IF body.inline THEN {body.link ¬ syms.bb[RootBti].link; syms.bb[RootBti].link ¬ [sibling, bti]};	  next ¬ bti + (SELECT body.nesting FROM			Inner => SIZE[Inner Callable BodyRecord],			Catch => SIZE[Catch Callable BodyRecord],			ENDCASE => SIZE[Outer Callable BodyRecord])};	ENDCASE => next ¬ bti + SIZE[Other BodyRecord];      ENDLOOP};-- inline expansion -- state information  currentMaster: CBTIndex;  masterBody: Tree.Index;  copyCtx: CTXIndex;  copying: PUBLIC BOOLEAN;  substSafe: BOOLEAN;  currentEnclosing: BTIndex;  bodyNesting: CARDINAL; -- overall control  ExpandInlines: PROC [rootBti: BTIndex] = {    bti: BTIndex ¬ rootBti;    aStack ¬ NIL;  sharingMap ¬ NIL;    UNTIL bti = BTNull DO      ExpandInlines[syms.bb[bti].firstSon];      WITH body: syms.bb[bti] SELECT FROM	Callable => IF body.inline THEN ExpandCalls[LOOPHOLE[bti, CBTIndex]];	ENDCASE;      bti ¬ IF syms.bb[bti].link.which=parent THEN BTNull ELSE syms.bb[bti].link.index;      ENDLOOP};  ExpandCalls: PROC [bti: CBTIndex] = {    saveIndex: CARDINAL = dataPtr.textIndex;    sei: ISEIndex = syms.bb[bti].id;    current, subNode: Tree.Index;    dataPtr.textIndex ¬ syms.bb[bti].sourceIndex;    WITH body: syms.bb[bti].info SELECT FROM      Internal => {	currentMaster ¬ bti;	IF syms.seb[sei].mark4 THEN {	  t: Tree.Link = FindExtension[syms, sei].tree;	  ComputeArgCounts[syms.bb[bti].ioType, t];	  masterBody ¬ GetNode[syms, t]}	ELSE masterBody ¬ body.bodyTree;	copying ¬ TRUE;	UNTIL (current ¬ body.thread) = Tree.NullIndex DO	  discard: BOOLEAN;	  -- process the thread (son[1])	    subNode ¬ GetNode[syms, syms.tb[current].son[1]];	    discard ¬ syms.tb[subNode].attr1;	    syms.tb[current].son[1] ¬ syms.tb[subNode].son[1];	    currentEnclosing ¬ DecodeBti[syms.tb[subNode].info];	    body.thread ¬ GetNode[syms, syms.tb[subNode].son[2]];	    syms.tb[subNode].son[1] ¬ syms.tb[subNode].son[2] ¬ Tree.Null;	    FreeNode[syms, subNode];	    syms.tb[current].shared ¬ FALSE;	  IF body.thread = Tree.NullIndex	   AND (~dataPtr.interface OR syms.bb[bti].level > lL) THEN copying ¬ FALSE;	  SELECT TRUE FROM	    discard => DiscardCall[current];	    ~RecursiveSubst[bti, currentEnclosing] => ExpandCall[current]	    ENDCASE => Log.ErrorSei[recursiveInline, syms.bb[bti].id];	  ENDLOOP};      ENDCASE => ERROR;    dataPtr.textIndex ¬ saveIndex};  DiscardCall: PROC [node: Tree.Index] = INLINE {	-- orphan subtree    [] ¬ DiscardTree[syms, [subtree[node]]]};      ExpandCall: PROC [node: Tree.Index] = {    typeIn, typeOut: RecordSEIndex;    masterCtx: CTXIndex = syms.bb[currentMaster].localCtx;    formalCtx: CTXIndex;    seChain, saveChain: ISEIndex;    nAssigns, nVars: CARDINAL;    extendedScope: BOOLEAN;    newBti: BTIndex;    t: Tree.Link;    IF syms.tb[node].name = call THEN dataPtr.textIndex ¬ DecodeCard[syms.tb[node].info];    bodyNesting ¬ 0;    IF copying OR masterCtx = CTXNull THEN copyCtx ¬ CTXNull    ELSE {      saveChain ¬ syms.ctxb[masterCtx].seList; syms.ctxb[masterCtx].seList ¬ ISENull;      syms.ctxb[masterCtx].level ¬ syms.bb[currentEnclosing].level;      copyCtx ¬ masterCtx};    [typeIn, typeOut] ¬ TransferTypes[syms, syms.bb[currentMaster].ioType];    substSafe ¬ syms.tb[node].attr3 AND syms.bb[currentMaster].hints.nameSafe;    nAssigns ¬ SELECT TRUE FROM	(typeIn = RecordSENull) => 0,	syms.tb[node].attr1 => ExtractArgs[typeIn, syms.seb[typeIn].fieldCtx, node],	ENDCASE => MapArgs[syms.seb[typeIn].fieldCtx, node];    syms.tb[node].son[2] ¬ FreeTree[syms, syms.tb[node].son[2]];    IF typeOut # RecordSENull AND RequiredFields[syms.seb[typeOut].fieldCtx] THEN {      formalCtx ¬ syms.seb[typeOut].fieldCtx;      IF copyCtx = CTXNull THEN copyCtx ¬ NewCtx[syms, syms.bb[currentEnclosing].level];      seChain ¬ MakeSeChain[syms, copyCtx, CtxVars[formalCtx], TRUE];      AppendSeChain[copyCtx, seChain];      MapIds[formalCtx, seChain, 0]};    IF syms.tb[masterBody].son[1] # Tree.Null THEN      PushTree[syms, ExpandOpens[syms, syms.tb[masterBody].son[1]]];    IF masterCtx # CTXNull THEN      IF ~copying THEN AppendSeChain[copyCtx, saveChain]    ELSE IF (nVars ¬ CtxVars[masterCtx]) # 0 THEN {      IF copyCtx = CTXNull THEN copyCtx ¬ NewCtx[syms, syms.bb[currentEnclosing].level];      seChain ¬ MakeSeChain[syms, copyCtx, nVars, FALSE];      MapIds[masterCtx, seChain, 0];      AppendSeChain[copyCtx, seChain]};   -- expand the body    IF copyCtx # CTXNull THEN newBti ¬ MakeEnclosingBody[BTNull, copyCtx];    t ¬ ExpandDecls[syms, syms.tb[masterBody].son[2]];    PushTree[syms, ExpandTree[syms, syms.tb[masterBody].son[3]]];    IF copyCtx = CTXNull THEN extendedScope ¬ FALSE    ELSE {      extendedScope ¬ nAssigns # 0 OR syms.tb[masterBody].son[1] # Tree.Null			  	OR syms.tb[masterBody].son[4] # Tree.Null;      PushTree[syms, t];  PushNode[syms, block, -2];      SetInfo[syms, EncodeBti[newBti]];  SetAttr[syms, 3, extendedScope];      SetAttr[syms, 1, syms.tb[masterBody].attr1]; SetAttr[syms, 2, syms.tb[masterBody].attr2];      WITH body: syms.bb[newBti].info SELECT FROM	Internal => {body.bodyTree ¬ GetNode[syms, t¬PopTree[syms]]; PushTree[syms, t]};	ENDCASE => ERROR};    IF syms.tb[masterBody].son[1] # Tree.Null THEN {      PushNode[syms, open, 2];  SetInfo[syms, EncodeCard[dataPtr.textIndex]]};    IF syms.tb[masterBody].son[4] # Tree.Null THEN {      PushTree[syms, ExpandTree[syms, syms.tb[masterBody].son[4]]];      PushNode[syms, lock, 2];  SetInfo[syms, EncodeCard[dataPtr.textIndex]]};    IF masterCtx # CTXNull AND copying AND nVars # 0 THEN UnmapIds[explicit];    IF copyCtx # CTXNull THEN currentEnclosing ¬ ParentBti[syms, currentEnclosing];    IF ~copying THEN PruneBody[masterBody];   -- complete the setup    IF syms.tb[node].nSons > 2 THEN {      PushTree[syms, syms.tb[node].son[3]];  syms.tb[node].son[3] ¬ Tree.Null;      PushNode[syms, enable, -2];        SetInfo[syms, EncodeCard[dataPtr.textIndex]]; SetAttr[syms, 3, TRUE]};    IF typeOut # RecordSENull AND RequiredFields[syms.seb[typeOut].fieldCtx] THEN UnmapIds[implicit];    IF typeIn # RecordSENull THEN UnmapIds[implicit];    syms.tb[node].son[2] ¬ MakeList[syms, nAssigns+1];    IF copyCtx # CTXNull AND nAssigns # 0 THEN UpdateBodyNesting[syms.tb[node].son[2], newBti];    syms.tb[node].name ¬ IF syms.tb[node].name = callx THEN substx ELSE subst;    syms.tb[node].attr1 ¬ syms.tb[masterBody].attr1; syms.tb[node].attr2 ¬ syms.tb[masterBody].attr2;    syms.tb[node].attr3 ¬ extendedScope;    ResetSharing[]};  RecursiveSubst: PROC [bti, parent: BTIndex] RETURNS [BOOLEAN] = {    UNTIL parent = BTNull DO      IF bti = parent THEN RETURN [TRUE];      parent ¬ ParentBti[syms, parent];      ENDLOOP;    RETURN [FALSE]};  PruneBody: PROC [node: Tree.Index] = {    OPEN syms.tb[node];    son[1] ¬ son[2] ¬ son[3] ¬ son[4] ¬ Tree.Null;  name ¬ procinit}; -- argument list testing/processing  NameSafe: PROC [t: Tree.Link] RETURNS [safe: BOOLEAN] = {    RETURN [~syms.bb[currentMaster].hints.argUpdated AND      (substSafe OR	(WITH t SELECT FROM	  symbol => syms.seb[index].immutable,	  literal => TRUE,	  subtree =>	    SELECT OpName[syms, t] FROM	      clit, llit, mwconst, nil => TRUE,	      uminus, loophole, cast, check => NameSafe[NthSon[syms, t, 1]],	      cdot => NameSafe[NthSon[syms, t, 2]],	      ENDCASE => FALSE,	  ENDCASE => FALSE))]};  VarRefs: PROC [sei: ISEIndex] RETURNS [CARDINAL] = INLINE {    RETURN [IF syms.seb[sei].mark4 THEN 2 ELSE ToCard[syms.seb[sei].idInfo]]};      CheapEval: PROC [t: Tree.Link, top: BOOLEAN ¬ TRUE] RETURNS [BOOLEAN] = {    RETURN [WITH t SELECT FROM      subtree => 	SELECT OpName[syms, t] FROM	  clit, llit, mwconst, nil, cdot => TRUE,	  loophole, cast, openx => CheapEval[NthSon[syms, t, 1], top],	  addr, uparrow, dot, dollar => CheapEval[NthSon[syms, t, 1], top],	  IN [index .. reloc] =>	    CheapEval[NthSon[syms, t, 1], FALSE] AND CheapEval[NthSon[syms, t, 2], FALSE],	  IN [or .. mod] =>	    top AND CheapEval[NthSon[syms, t, 1], FALSE]	     AND CheapEval[NthSon[syms, t, 2], FALSE],	  not, uminus, pred, succ =>	    top AND CheapEval[NthSon[syms, t, 1], FALSE],	  ENDCASE => FALSE,      ENDCASE => TRUE]};  MapByName: PROC [sei: ISEIndex, t: Tree.Link] RETURNS [BOOLEAN] = {    n: CARDINAL = VarRefs[sei];    RETURN [NameSafe[t] AND (n <= 2 OR CheapEval[t])]};  CountVars: PROC [ctx: CTXIndex, t: Tree.Link] RETURNS [n: CARDINAL ¬ 0] = {    sei: ISEIndex ¬ FirstCtxSe[syms, ctx];    CountVar: TreeOps.Scan = {      IF sei # ISENull THEN {IF ~MapByName[sei, t] THEN n ¬ n+1; sei ¬ NextSe[syms, sei]}};    ScanList[syms, t, CountVar];  RETURN};  RequiredFields: PROC [ctx: CTXIndex] RETURNS [BOOLEAN] = {    FOR sei: ISEIndex ¬ FirstCtxSe[syms, ctx], NextSe[syms, sei] UNTIL sei = ISENull DO      -- IF syms.seb[sei].hash = HTNull THEN RETURN [FALSE];      IF ToCard[syms.seb[sei].idInfo] # 0 THEN RETURN [TRUE];      ENDLOOP;    RETURN [FALSE]}; -- tree manipulation    DiscardTree: TreeOps.Map = {    IF t # Tree.Null THEN      WITH t SELECT FROM	subtree => {	  node: Tree.Index ¬ index;	  SELECT syms.tb[node].name FROM	    call, callx =>	      IF OpName[syms, syms.tb[node].son[1]] = thread THEN {	        -- mark for later discard (see DiscardCall)		subNode: Tree.Index = GetNode[syms, syms.tb[node].son[1]];		syms.tb[subNode].attr1 ¬ TRUE}	      ELSE {	        [] ¬ UpdateLeaves[syms, t, DiscardTree]; FreeNode[syms, node]};	    ENDCASE =>	      IF ~syms.tb[node].shared THEN {	        [] ¬ UpdateLeaves[syms, t, DiscardTree]; FreeNode[syms, node]}};	ENDCASE;    RETURN [Tree.Null]};		  ExpandTree: PUBLIC TreeOps.Map = {    WITH t SELECT FROM      symbol => v ¬ ExpandSei[index];      subtree => {	sNode: Tree.Index = index;	IF syms.tb[sNode].shared THEN	  v ¬ SELECT syms.tb[sNode].name FROM	    call, callx => ExpandThreadedCall[sNode],	    ENDCASE => ExpandShared[sNode]	ELSE	  SELECT syms.tb[sNode].name FROM	    body => v ¬ ExpandBody[sNode];	    block => v ¬ ExpandBlock[sNode, syms.tb[sNode].attr3];	    catch => v ¬ ExpandCatch[sNode];	    ditem => v ¬ ExpandBlock[sNode, FALSE];	    do => v ¬ ExpandDo[sNode];	    open, bind, bindx => v ¬ ExpandBinding[sNode];	    subst, substx => v ¬ ExpandSubst[sNode];	    lock => v ¬ ExpandLock[sNode];	    thread => v ¬ ExpandThread[sNode];	    ENDCASE => {	      v ¬ IF copying		    THEN CopyTree[syms, [baseP:@syms.tb, link:t], ExpandTree]		    ELSE UpdateLeaves[syms, t, ExpandTree];	      WITH v SELECT FROM		subtree => {		  dNode: Tree.Index = index;		  SELECT syms.tb[dNode].name FROM		    return => IF bodyNesting = 0 THEN UpdateReturn[dNode];		    xerror => IF bodyNesting = 0 THEN syms.tb[dNode].attr3 ¬ TRUE;		    ENDCASE => NULL};		ENDCASE => NULL}};      ENDCASE => v ¬ t;    RETURN};  RewriteNode: PROC [node: Tree.Index, nSons: CARDINAL] RETURNS [Tree.Link] = {    FOR i: CARDINAL DECREASING IN [1 .. nSons] DO syms.tb[node].son[i] ¬ PopTree[syms] ENDLOOP;    RETURN [[subtree[index: node]]]};  CopyNode: PROC [node: Tree.Index, nSons: CARDINAL] RETURNS [Tree.Link] = {    PushNode[syms, syms.tb[node].name, nSons];      SetInfo[syms, syms.tb[node].info];    SetAttr[syms, 1, syms.tb[node].attr1]; SetAttr[syms, 2, syms.tb[node].attr2]; SetAttr[syms, 3, syms.tb[node].attr3];    RETURN [PopTree[syms]]};      ExpandBlock: PROC [node: Tree.Index, extendedScope: BOOLEAN] RETURNS [v: Tree.Link] = {    EnterBlock[node, extendedScope];    PushTree[syms, ExpandDecls[syms, syms.tb[node].son[1]]];    PushTree[syms, ExpandTree[syms, syms.tb[node].son[2]]];    v ¬ IF copying THEN CopyNode[node, 2] ELSE RewriteNode[node, 2];    ExitBlock[GetNode[syms, v]];    RETURN};  ExpandBody: PROC [node: Tree.Index] RETURNS [v: Tree.Link] = {    EnterBody[node];    PushTree[syms, ExpandOpens[syms, syms.tb[node].son[1]]];    PushTree[syms, ExpandDecls[syms, syms.tb[node].son[2]]];    PushTree[syms, ExpandTree[syms, syms.tb[node].son[3]]];    PushTree[syms, ExpandTree[syms, syms.tb[node].son[4]]];    v ¬ IF copying THEN CopyNode[node, 4] ELSE RewriteNode[node, 4];    ExitBody[GetNode[syms, v]];    RETURN};  ExpandCatch: PROC [node: Tree.Index] RETURNS [v: Tree.Link] = {    EnterCatch[node];    PushTree[syms, ExpandTree[syms, syms.tb[node].son[1]]];    PushTree[syms, ExpandTree[syms, syms.tb[node].son[2]]];    v ¬ IF copying THEN CopyNode[node, 2] ELSE RewriteNode[node, 2];    ExitCatch[GetNode[syms, v]];    RETURN};  ExpandDo: PROC [node: Tree.Index] RETURNS [v: Tree.Link] = {    decl: BOOLEAN;    subNode: Tree.Index;    IF syms.tb[node].son[1] = Tree.Null THEN decl ¬ FALSE    ELSE {subNode ¬ GetNode[syms, syms.tb[node].son[1]]; decl ¬ OpName[syms, syms.tb[subNode].son[1]] = decl};    IF decl THEN {      nSons: CARDINAL = syms.tb[subNode].nSons;      EnterBlock[subNode, FALSE];      PushTree[syms, ExpandDecls[syms, syms.tb[subNode].son[1]]];      FOR i: CARDINAL IN [2..nSons] DO PushTree[syms, ExpandTree[syms, syms.tb[subNode].son[i]]] ENDLOOP;      IF copying THEN {PushNode[syms, syms.tb[subNode].name, nSons];       SetInfo[syms, syms.tb[subNode].info]}      ELSE PushTree[syms, RewriteNode[subNode, nSons]]}    ELSE PushTree[syms, ExpandTree[syms, syms.tb[node].son[1]]];    PushTree[syms, ExpandTree[syms, syms.tb[node].son[2]]];    PushTree[syms, ExpandOpens[syms, syms.tb[node].son[3]]];    FOR i: CARDINAL IN [4..6] DO PushTree[syms, ExpandTree[syms, syms.tb[node].son[i]]] ENDLOOP;    v ¬ IF copying THEN CopyNode[node, 6] ELSE RewriteNode[node, 6];    IF decl THEN {      newNode: Tree.Index = GetNode[syms, v];      ExitBlock[GetNode[syms, syms.tb[newNode].son[1]], newNode]};    RETURN};  ExpandBinding: PROC [node: Tree.Index] RETURNS [Tree.Link] = {    nSons: CARDINAL = syms.tb[node].nSons;    PushTree[syms, ExpandOpens[syms, syms.tb[node].son[1]]];    FOR i: CARDINAL IN [2..nSons] DO PushTree[syms, ExpandTree[syms, syms.tb[node].son[i]]] ENDLOOP;    RETURN [IF copying THEN CopyNode[node, nSons] ELSE RewriteNode[node, nSons]]};  ExpandSubst: PROC [node: Tree.Index] RETURNS [Tree.Link] = {    extendedScope: BOOLEAN = syms.tb[node].attr3;    PushTree[syms, ExpandTree[syms, syms.tb[node].son[1]]];    IF extendedScope THEN MapBlock[FindBlock[syms.tb[node].son[2]]];    PushTree[syms, ExpandTree[syms, syms.tb[node].son[2]]];    RETURN [IF copying THEN CopyNode[node, 2] ELSE RewriteNode[node, 2]]};  ExpandThreadedCall: PROC [node: Tree.Index] RETURNS [v: Tree.Link] = {    nSons: CARDINAL = syms.tb[node].nSons;    FOR i: CARDINAL IN [1 .. nSons] DO PushTree[syms, ExpandTree[syms, syms.tb[node].son[i]]] ENDLOOP;    v ¬ IF copying THEN CopyNode[node, nSons] ELSE RewriteNode[node, nSons];    ThreadSubst[node, v];    RETURN};      ExpandThread: PROC [node: Tree.Index] RETURNS [v: Tree.Link] = {    IF ~copying THEN {syms.tb[node].son[1] ¬ ExpandTree[syms, syms.tb[node].son[1]]; v ¬ [subtree[node]]}    ELSE {      PushTree[syms, ExpandTree[syms, syms.tb[node].son[1]]];  PushTree[syms, Tree.Null];      PushNode[syms, thread, 2];  SetInfo[syms, syms.tb[node].info];  v ¬ PopTree[syms]};    RETURN};  ExpandLock: PROC [node: Tree.Index] RETURNS [v: Tree.Link] = {    PushTree[syms, ExpandTree[syms, syms.tb[node].son[2]]];    PushTree[syms, ExpandTree[syms, syms.tb[node].son[1]]];    IF copying THEN {PushNode[syms, lock, -2]; SetInfo[syms, syms.tb[node].info]; v ¬ PopTree[syms]}    ELSE {      syms.tb[node].son[1] ¬ PopTree[syms];  syms.tb[node].son[2] ¬ PopTree[syms];      v ¬ [subtree[index: node]]};    RETURN};  UpdateReturn: PROC [node: Tree.Index] = {    typeOut: RecordSEIndex;    IF syms.tb[node].son[1] = Tree.Null AND     (typeOut¬TransferTypes[syms, syms.bb[currentMaster].ioType].typeOut) # RecordSENull THEN {      n: CARDINAL ¬ 0;      FOR sei: ISEIndex ¬ FirstCtxSe[syms, syms.seb[typeOut].fieldCtx], NextSe[syms, sei] UNTIL sei = ISENull DO        PushTree[syms, ExpandSei[sei]];  n ¬ n+1 ENDLOOP;      syms.tb[node].son[1] ¬ MakeList[syms, n]};    syms.tb[node].name ¬ result};  ExpandDecls: TreeOps.Map = {    n: CARDINAL;    ExpandDecl: TreeOps.Scan = {      node: Tree.Index;      LinkDecl: TreeOps.Scan = {	WITH t SELECT FROM	  symbol => {	    sei: ISEIndex = index;	    syms.seb[sei].idValue ¬ FromTreeIndex[node];	    IF ~syms.seb[sei].mark4 AND syms.tb[node].son[3] = Tree.Null AND ~syms.seb[sei].immutable THEN	      syms.seb[sei].idInfo ¬ FromCard[ToCard[syms.seb[sei].idInfo] - 1]};	  ENDCASE};      copy: Tree.Link;      IF OpName[syms, t] # typedecl THEN {	PushTree[syms, copy ¬ ExpandTree[syms, t]];  n ¬ n+1;	node ¬ GetNode[syms, copy];	ScanList[syms, syms.tb[node].son[1], LinkDecl]}};    IF OpName[syms, t] = initlist THEN {      node: Tree.Index = GetNode[syms, t];      PushTree[syms, ExpandTree[syms, syms.tb[node].son[1]]];      PushTree[syms, ExpandDecls[syms, syms.tb[node].son[2]]];      IF copying THEN {PushNode[syms, initlist, 2];  SetInfo[syms, syms.tb[node].info];  v ¬ PopTree[syms]}      ELSE v ¬ RewriteNode[node, 2]}    ELSE      IF copying THEN {n ¬ 0; ScanList[syms, t, ExpandDecl]; v ¬ MakeList[syms, n]}      ELSE v ¬ ExpandTree[syms, t];    RETURN};  SharingItem: TYPE = RECORD [old, new: Tree.Link, next: SharingList];  SharingList: TYPE = LONG POINTER TO SharingItem;  sharingMap: SharingList;  MapShared: PROC [t, v: Tree.Link] = {    p: SharingList ¬ (dataPtr.zone).NEW[SharingItem];    p­ ¬ [old:t, new:v, next:sharingMap];  sharingMap ¬ p;    SetShared[syms, v, TRUE]};  ExpandShared: PROC [node: Tree.Index] RETURNS [v: Tree.Link] = {    target: Tree.Link = [subtree[index: node]];    UpdateCount: TreeOps.Scan = {      WITH t SELECT FROM	symbol => IncrCount[index];	subtree => ScanSons[syms, t, UpdateCount];	ENDCASE => NULL};    FOR p: SharingList ¬ sharingMap, p.next UNTIL p = NIL DO      IF p.old = target THEN GO TO Found;      REPEAT	Found => v ¬ p.new;	FINISHED => v ¬ target;      ENDLOOP;    IF copying THEN UpdateCount[syms, v];  RETURN};  ResetSharing: PROC = {    p: SharingList;    UNTIL sharingMap = NIL DO      p ¬ sharingMap; sharingMap ¬ sharingMap.next; (dataPtr.zone).FREE[@p];      ENDLOOP};  ExpandOpens: TreeOps.Map = {    n: CARDINAL;    UpdateOpen: TreeOps.Scan = {      node: Tree.Index = GetNode[syms, t];      base: Tree.Link;      syms.tb[node].son[1] ¬ ExpandTree[syms, syms.tb[node].son[1]];      IF ~Shared[syms, base ¬ syms.tb[node].son[2]] THEN syms.tb[node].son[2] ¬ ExpandTree[syms, base]      ELSE {	SetShared[syms, base, FALSE];  base ¬ ExpandTree[syms, base];	SetShared[syms, base, TRUE];  syms.tb[node].son[2] ¬ base}};    ExpandOpen: TreeOps.Scan = {      node: Tree.Index = GetNode[syms, t];      base: Tree.Link = syms.tb[node].son[2];      copy: Tree.Link;      PushTree[syms, ExpandTree[syms, syms.tb[node].son[1]]];      IF ~Shared[syms, base] THEN PushTree[syms, ExpandTree[syms, base]]      ELSE {	SetShared[syms, base, FALSE];  PushTree[syms, copy ¬ ExpandTree[syms, base]];	SetShared[syms, base, TRUE];  MapShared[base, copy]};      PushNode[syms, item, 2];  SetInfo[syms, syms.tb[node].info];  n ¬ n+1};    IF ~copying THEN {ScanList[syms, t, UpdateOpen]; v ¬ t}    ELSE {n ¬ 0;  ScanList[syms, t, ExpandOpen]; v ¬ MakeList[syms, n]};    RETURN}; -- blocks and bodies  FindBlock: PROC [t: Tree.Link] RETURNS [node: Tree.Index] = {    DO      node ¬ GetNode[syms, t];      SELECT syms.tb[node].name FROM	list => t ¬ ListTail[syms, t];	block => EXIT;	open, enable => t ¬ syms.tb[node].son[2];	lock => t ¬ syms.tb[node].son[1];	ENDCASE => ERROR;      ENDLOOP;    RETURN};  EnterBlock: PROC [node: Tree.Index, extendedScope: BOOLEAN] = INLINE {    IF ~extendedScope THEN MapBlock[node]};  MapBlock: PROC [node: Tree.Index] = {    oldBti: BTIndex = DecodeBti[syms.tb[node].info];    oldCtx: CTXIndex = syms.bb[oldBti].localCtx;    seChain: ISEIndex;    newCtx: CTXIndex;    SELECT TRUE FROM      oldCtx = CTXNull => newCtx ¬ CTXNull;      ~copying => {newCtx ¬ oldCtx;  syms.ctxb[newCtx].level ¬ syms.bb[currentEnclosing].level};      ENDCASE => {	newCtx ¬ NewCtx[syms, syms.bb[currentEnclosing].level];	seChain ¬ MakeSeChain[syms, newCtx, CtxVars[oldCtx], FALSE];	AppendSeChain[newCtx, seChain];	MapIds[oldCtx, seChain, 0]};    [] ¬ MakeEnclosingBody[IF copying THEN BTNull ELSE oldBti, newCtx];    RETURN};  ExitBlock: PROC [node: Tree.Index, bodyNode: Tree.Index ¬ Tree.NullIndex] = {    oldBti: BTIndex = DecodeBti[syms.tb[node].info];    newBti: BTIndex = currentEnclosing;    syms.tb[node].info ¬ EncodeBti[newBti];    WITH body: syms.bb[newBti].info SELECT FROM      Internal => body.bodyTree ¬ IF bodyNode = Tree.NullIndex THEN node ELSE bodyNode;      ENDCASE;    IF copying AND syms.bb[oldBti].localCtx # CTXNull THEN UnmapIds[explicit];    currentEnclosing ¬ ParentBti[syms, currentEnclosing]};  MakeEnclosingBody: PROC [oldBti: BTIndex, ctx: CTXIndex] RETURNS [newBti: BTIndex] = {    newSon: BTIndex;    IF oldBti = BTNull THEN {      newBti ¬ (dataPtr.table).Words[bodyType, SIZE[Other BodyRecord]]; newSon ¬ BTNull}    ELSE {newSon ¬ syms.bb[oldBti].firstSon; DelinkBti[syms, oldBti]; newBti ¬ oldBti};    syms.bb[newBti] ¬ BodyRecord[	link: ,	firstSon: newSon,	type: BodyType[ctx],	localCtx: ctx,  level: syms.bb[currentEnclosing].level,	sourceIndex: ,	info: BodyInfo[Internal[	  bodyTree: Tree.NullIndex,	  thread: Tree.NullIndex,	  frameSize: ]],	extension: Other[relOffset: ]];    LinkBti[h: syms, bti: newBti, parent: currentEnclosing];    currentEnclosing ¬ newBti;    RETURN};  EnterBody: PROC [node: Tree.Index] = {     oldBti: CBTIndex = DecodeBti[syms.tb[node].info];    newBti: CBTIndex;    ioType: CSEIndex;    type: RecordSEIndex;    level: ContextLevel = NextLevel[syms, syms.bb[currentEnclosing].level       ! StaticNestError => {Log.Error[staticNesting]; RESUME}];    SetArgLevel: PROC [sei: CSEIndex] = {      ctx: CTXIndex = ArgCtx[syms, sei];      IF ctx # CTXNull THEN syms.ctxb[ctx].level ¬ level};    ctx: CTXIndex;    bodyNesting ¬ bodyNesting + 1;    IF ~copying THEN DelinkBti[syms, oldBti];    IF ~copying AND (syms.bb[oldBti].level > lL) = (level > lL) THEN {      ctx ¬ syms.bb[oldBti].localCtx;      IF ctx # CTXNull THEN syms.ctxb[ctx].level ¬ level;      ioType ¬ syms.bb[oldBti].ioType; type ¬ syms.bb[oldBti].type;      newBti ¬ oldBti}    ELSE {      id: ISEIndex;      IF level > lL THEN {	newBti ¬ (dataPtr.table).Words[bodyType, SIZE[Inner Callable BodyRecord]];	syms.bb[newBti] ¬ [,,,,,,, Callable[,,,,,,,,,, Inner[frameOffset: ]]]}      ELSE {	newBti ¬ (dataPtr.table).Words[bodyType, SIZE[Outer Callable BodyRecord]];	syms.bb[newBti] ¬ [,,,,,,, Callable[,,,,,,,,,, Outer[]]]};      IF ~copying THEN {	ctx ¬ syms.bb[oldBti].localCtx;	IF ctx # CTXNull THEN syms.ctxb[ctx].level ¬ level;	id ¬ syms.bb[oldBti].id;  ioType ¬ syms.bb[oldBti].ioType;  type ¬ syms.bb[oldBti].type;	syms.bb[newBti].firstSon ¬ syms.bb[oldBti].firstSon}      ELSE {	oldCtx: CTXIndex;	IF (id ¬ syms.bb[oldBti].id) # ISENull THEN	  id ¬ SearchContext[syms, syms.seb[id].hash, syms.bb[currentEnclosing].localCtx];	ioType ¬ CopyXferType[syms, syms.bb[oldBti].ioType];	MapFormals[oldType: syms.bb[oldBti].ioType, newType: ioType];	IF (oldCtx ¬ syms.bb[oldBti].localCtx) = CTXNull THEN ctx ¬ CTXNull	ELSE {	  ctx ¬ NewCtx[syms, level];	  syms.ctxb[ctx].seList ¬ MakeSeChain[syms, ctx, CtxVars[oldCtx], FALSE];	  MapIds[oldCtx, syms.ctxb[ctx].seList, 0]};	type ¬ BodyType[ctx];	syms.bb[newBti].firstSon ¬ BTNull;	dataPtr.nBodies ¬ dataPtr.nBodies+1;	IF level > lL THEN dataPtr.nInnerBodies ¬ dataPtr.nInnerBodies+1};      syms.bb[newBti].type ¬ type;      syms.bb[newBti].localCtx ¬ ctx;      syms.bb[newBti].info ¬ syms.bb[oldBti].info;      syms.bb[newBti].inline ¬ syms.bb[oldBti].inline;      syms.bb[newBti].resident ¬ syms.bb[oldBti].resident;      syms.bb[newBti].id ¬ id;      syms.bb[newBti].ioType ¬ ioType;      syms.bb[newBti].monitored ¬ syms.bb[oldBti].monitored;      syms.bb[newBti].entry ¬ syms.bb[oldBti].entry; syms.bb[newBti].internal ¬ syms.bb[oldBti].internal;      syms.bb[newBti].noXfers ¬ syms.bb[oldBti].noXfers;      syms.bb[newBti].hints ¬ syms.bb[oldBti].hints};    syms.bb[newBti].level ¬ level;    WITH t: syms.seb[ioType] SELECT FROM      transfer => {SetArgLevel[t.typeIn]; SetArgLevel[t.typeOut]};      ENDCASE;    LinkBti[h: syms, bti: newBti, parent: currentEnclosing];    currentEnclosing ¬ newBti};  ExitBody: PROC [node: Tree.Index] = {    newBti: CBTIndex = LOOPHOLE[currentEnclosing];    ExitBlock[node];    IF copying THEN UnmapFormals[syms.bb[newBti].ioType];    bodyNesting ¬ bodyNesting - 1};  EnterCatch: PROC [node: Tree.Index] = {     oldBti: CBTIndex = DecodeBti[syms.tb[node].info];    newBti: CBTIndex;    level: ContextLevel = NextLevel[syms, syms.bb[currentEnclosing].level       ! StaticNestError => {Log.Error[staticNesting]; RESUME}];    bodyNesting ¬ bodyNesting + 1;    IF ~copying THEN {      DelinkBti[syms, oldBti]; newBti ¬ oldBti; syms.bb[newBti].level ¬ level}    ELSE {      newBti ¬ (dataPtr.table).Words[bodyType, SIZE[Catch Callable BodyRecord]];      syms.bb[newBti] ¬ [        link: ,        firstSon: BTNull,        type: RecordSENull,        localCtx: CTXNull,        level: level,        sourceIndex: syms.bb[oldBti].sourceIndex,        info: syms.bb[oldBti].info,        extension: Callable[	  inline: FALSE,	  id: ISENull,	  ioType: CSENull,	  monitored: FALSE,	  noXfers: syms.bb[oldBti].noXfers,	  resident: syms.bb[oldBti].resident,	  entry: FALSE, internal: FALSE,	  entryIndex: 0,	  hints: syms.bb[oldBti].hints,	closure: Catch[index: ]]]};    FOR bti: BTIndex ¬ currentEnclosing, ParentBti[syms, bti] UNTIL bti = BTNull DO      WITH b: syms.bb[bti] SELECT FROM        Callable => {syms.bb[newBti].id ¬ b.id; EXIT};	ENDCASE;      ENDLOOP;    LinkBti[h: syms, bti: newBti, parent: currentEnclosing];    currentEnclosing ¬ newBti};      ExitCatch: PROC [node: Tree.Index] = {    newBti: CBTIndex = LOOPHOLE[currentEnclosing];    ExitBlock[node];    bodyNesting ¬ bodyNesting - 1};      UpdateBodyNesting: PROC [list: Tree.Link, newBti: BTIndex] = {    oldBti: BTIndex = ParentBti[syms, newBti];    UpdateLinks: TreeOps.Map = {      WITH t SELECT FROM	subtree => {	  node: Tree.Index = index;	  SELECT syms.tb[node].name FROM	    block => {	      bti: BTIndex = DecodeBti[syms.tb[node].info];	      IF ParentBti[syms, bti] = oldBti THEN {	        DelinkBti[syms, bti]; 	        LinkBti[syms, bti, newBti]};	      v ¬ t};	    thread => {	      IF syms.tb[node].info = EncodeBti[oldBti] THEN 	        syms.tb[node].info ¬ EncodeBti[newBti];	      syms.tb[node].son[1] ¬ UpdateLeaves[syms, syms.tb[node].son[1], UpdateLinks];	      v ¬ t};	    ENDCASE => v ¬ UpdateLeaves[syms, t, UpdateLinks]};	ENDCASE => v ¬ t};    UpdateItem: TreeOps.Scan = {      WITH t SELECT FROM	subtree => {	  node: Tree.Index = index;	  SELECT syms.tb[node].name FROM	    assign, extract =>	      syms.tb[node].son[2] ¬ UpdateLeaves[syms, syms.tb[node].son[2], UpdateLinks];	    ENDCASE};	ENDCASE};    ScanList[syms, list, UpdateItem]};  BodyType: PROC [ctx: CTXIndex] RETURNS [rSei: RecordSEIndex] = {    rSei ¬ LOOPHOLE[MakeNonCtxSe[syms, SIZE[notLinked record cons SERecord]]];    syms.seb[rSei].typeInfo ¬ record[	machineDep: FALSE, painted: TRUE, argument: FALSE,	hints: [	    unifield: FALSE, variant: FALSE,	    assignable: FALSE, comparable: FALSE, privateFields: TRUE,	    refField: FALSE, default: FALSE, voidable: FALSE],	length: 0,	fieldCtx: CTXNull,	monitored: FALSE,	linkPart: notLinked[]];    syms.seb[rSei].fieldCtx ¬ ctx;  syms.seb[rSei].mark3 ¬ TRUE;    RETURN}; -- id translation  AppendSeChain: PROC [ctx: CTXIndex, chain: ISEIndex] = {    last, next: ISEIndex;    SELECT TRUE FROM      chain = ISENull => NULL;      (last ¬ syms.ctxb[ctx].seList) = ISENull => syms.ctxb[ctx].seList ¬ chain;      ENDCASE => {	UNTIL (next ¬ NextSe[syms, last]) = ISENull DO last ¬ next ENDLOOP;	SetSeLink[syms, last, chain]}};  CtxVars: PROC [ctx: CTXIndex] RETURNS [n: CARDINAL ¬ 0] = {    FOR sei: ISEIndex ¬ FirstCtxSe[syms, ctx], NextSe[syms, sei] UNTIL sei = ISENull DO      IF syms.seb[sei].idType # typeTYPE THEN n ¬ n+1 ENDLOOP;    RETURN};  AllocateAList: PROC [ctx: CTXIndex] RETURNS [aLink: AList] = {    maxItems: CARDINAL = CtxEntries[syms, ctx];    aLink ¬ (dataPtr.zone).NEW[ANode[maxItems] ¬ [next:NIL, ctx:ctx, nItems:0, map:]]};  -- mapping  AllocateCopyEntries: PROC [nVars: CARDINAL] RETURNS [seChain: ISEIndex] = {    IF nVars = 0 THEN seChain ¬ ISENull    ELSE {      IF copyCtx = CTXNull THEN copyCtx ¬ NewCtx[syms, syms.bb[currentEnclosing].level];      seChain ¬ MakeSeChain[syms, copyCtx, nVars, TRUE];      AppendSeChain[copyCtx, seChain]};    RETURN};      FillArgSe: PROC [copy, master: ISEIndex] = {    CopyArgSe[syms, copy, master];    IF syms.seb[copy].mark4 THEN syms.seb[copy].idValue ¬ FromTreeIndex[Tree.NullIndex];    syms.seb[copy].mark4 ¬ FALSE;  syms.seb[copy].idInfo ¬ FromCard[0]};      ExtractArgs: PROC [argType: RecordSEIndex, formalCtx: CTXIndex, node: Tree.Index]      RETURNS [nAssigns: CARDINAL] = {    aLink: AList = AllocateAList[formalCtx];    nVars: CARDINAL = CtxEntries[syms, formalCtx];    seChain: ISEIndex = AllocateCopyEntries[nVars];    sei1: ISEIndex;    sei2: ISEIndex ¬ seChain;    FOR sei1 ¬ FirstCtxSe[syms, formalCtx], NextSe[syms, sei1] UNTIL sei1 = ISENull DO      val: Tree.Link = [symbol[index: sei2]];      FillArgSe[copy: sei2, master: sei1];      PushTree[syms, val];  PushTree[syms, Tree.Null];      PushNode[syms, assign, 2];  SetInfo[syms, EncodeCard[dataPtr.textIndex]];      IncrCount[sei2];      aLink.map[aLink.nItems] ¬ [id: sei1, name: FALSE, val: val];      aLink.nItems ¬ aLink.nItems + 1;      sei2 ¬ NextSe[syms, sei2];      ENDLOOP;    IF nVars = 0 THEN nAssigns ¬ 0    ELSE {      PushList[syms, nVars];  PushNode[syms, exlist, 1]; SetInfo[syms, EncodeSei[argType]];      PushTree[syms, syms.tb[node].son[2]];  syms.tb[node].son[2] ¬ Tree.Null;      PushNode[syms, extract, 2];  SetInfo[syms, EncodeCard[dataPtr.textIndex]];      nAssigns ¬ 1};    PushAList[aLink];    RETURN};  MapArgs: PROC [formalCtx: CTXIndex, node: Tree.Index]      RETURNS [nAssigns: CARDINAL ¬ 0] = {    aLink: AList = AllocateAList[formalCtx];    nVars: CARDINAL = CountVars[formalCtx, syms.tb[node].son[2]];    seChain: ISEIndex = AllocateCopyEntries[nVars];    sei1, sei2: ISEIndex;    MapArg: TreeOps.Map = {      name: BOOLEAN;      val: Tree.Link;      IF sei1 = ISENull THEN v ¬ t      ELSE {	IF MapByName[sei1, t] THEN {	  name ¬ TRUE; AdjustForName[syms, t]; val ¬ t}	ELSE {	  FillArgSe[copy: sei2, master: sei1];	  name ¬ FALSE;  val ¬ [symbol[index: sei2]];	  IF t # Tree.Null THEN {	    PushTree[syms, val];  PushTree[syms, t];	    PushNode[syms, assign, 2];  SetInfo[syms, EncodeCard[dataPtr.textIndex]];	    IncrCount[sei2];  nAssigns ¬ nAssigns + 1};	    sei2 ¬ NextSe[syms, sei2]};	aLink.map[aLink.nItems] ¬ [id: sei1, name: name, val: val];	aLink.nItems ¬ aLink.nItems + 1;	sei1 ¬ NextSe[syms, sei1];  v ¬ Tree.Null};      RETURN};    sei1 ¬ FirstCtxSe[syms, formalCtx];  sei2 ¬ seChain;    syms.tb[node].son[2] ¬ UpdateList[syms, syms.tb[node].son[2], MapArg];    PushAList[aLink];    RETURN};  MapIds: PROC [ctx: CTXIndex, chain: ISEIndex, nRefs: [0..1]] = {    aLink: AList = AllocateAList[ctx];    sei1: ISEIndex ¬ FirstCtxSe[syms, ctx];    sei2: ISEIndex ¬ chain;    UNTIL sei1 = ISENull DO      IF syms.seb[sei1].idType # typeTYPE THEN {	CopyArgSe[syms, sei2, sei1];	IF syms.seb[sei2].mark4 THEN 	  syms.seb[sei2].idValue ¬ FromTreeIndex[Tree.NullIndex];	syms.seb[sei2].idInfo ¬  FromCard[nRefs];	aLink.map[aLink.nItems] ¬ [id: sei1, name: FALSE, val: [symbol[index:sei2]]];	aLink.nItems ¬ aLink.nItems + 1;	sei2 ¬ NextSe[syms, sei2]};      sei1 ¬ NextSe[syms, sei1];      ENDLOOP;    PushAList[aLink]};  UnmapIds: PROC [decl: {implicit, explicit}] = {    aLink: AList ¬ PopAList[];    FOR i: CARDINAL IN [0..aLink.nItems) DO      WITH aLink.map[i].val SELECT FROM	symbol =>	  IF decl = implicit AND ~aLink.map[i].name THEN syms.seb[index].mark4 ¬ TRUE;	ENDCASE;      aLink.map[i].val ¬ DiscardTree[syms, aLink.map[i].val];      ENDLOOP;    (dataPtr.zone).FREE[@aLink]};  MapFields: PROC [oldRecord, newRecord: CSEIndex, nRefs: [0..1]] = {    oldCtx: CTXIndex = ArgCtx[syms, oldRecord];    IF oldCtx # CTXNull THEN {      aLink: AList = AllocateAList[oldCtx];      sei1: ISEIndex ¬ FirstCtxSe[syms, oldCtx];      sei2: ISEIndex ¬ FirstCtxSe[syms, ArgCtx[syms, newRecord]];      UNTIL sei1 = ISENull DO	syms.seb[sei2].idInfo ¬  FromCard[nRefs];	aLink.map[aLink.nItems] ¬ [id: sei1, name: FALSE, val: [symbol[index:sei2]]];	aLink.nItems ¬ aLink.nItems + 1;	sei1 ¬ NextSe[syms, sei1];  sei2 ¬ NextSe[syms, sei2];	ENDLOOP;      PushAList[aLink]}};  MapFormals: PROC [oldType, newType: CSEIndex] = {    WITH new: syms.seb[newType] SELECT FROM      transfer =>	WITH old: syms.seb[oldType] SELECT FROM	  transfer => {	    MapFields[old.typeIn, new.typeIn, 1];	    MapFields[old.typeOut, new.typeOut, 0]};	  ENDCASE => ERROR;      ENDCASE};  UnmapFormals: PROC [type: CSEIndex] = {    WITH t: syms.seb[type] SELECT FROM      transfer => {	IF ArgCtx[syms, t.typeOut] # CTXNull THEN UnmapIds[implicit];	IF ArgCtx[syms, t.typeIn] # CTXNull THEN UnmapIds[implicit]};      ENDCASE}; -- nested calls  ThreadSubst: PROC [node: Tree.Index, dest: Tree.Link] = {    dThread: Tree.Index = GetNode[syms, NthSon[syms, dest, 1]];    IF copying THEN {      sThread: Tree.Index;      DO	sThread ¬ GetNode[syms, syms.tb[node].son[1]];	IF syms.tb[sThread].name # thread THEN ERROR;	IF syms.tb[sThread].son[2] = Tree.Null THEN EXIT;	node ¬ GetNode[syms, syms.tb[sThread].son[2]];	ENDLOOP;      syms.tb[dThread].son[2] ¬ Tree.Null;      syms.tb[sThread].son[2] ¬ dest;  SetShared[syms, dest, TRUE]};    syms.tb[dThread].info ¬ EncodeBti[currentEnclosing]};  }.
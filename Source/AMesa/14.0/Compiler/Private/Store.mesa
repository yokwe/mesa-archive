-- Copyright (C) 1980, 1983, 1984, 1986  by Xerox Corporation. All rights reserved. -- file Store.mesa-- last modified by Sweet, 15-Jun-83 10:05:51-- last modified by Satterthwaite, November 24, 1980  4:13 PM-- last modified by Russ Atkinson (RRA), 11-Oct-80 15:07:37-- last modified by Wagner, 22-Aug-86  8:51:12DIRECTORY  Alloc USING [Notifier],  Code USING [fileindex, tailJumpOK, xtracting, xtractlex, xtractsei],  CodeDefs USING [    BoVarIndex, codeType, Lexeme, NullLex, StoreOptions, VarComponent, VarIndex, VarNull, wordlength],  ComData USING [ownSymbols],  Counting USING [VarVarAssignCounted],  FOpCodes USING [qFF, qLCO, qPSD, qPSDL, qSLD],  P5 USING [    All, Construct, ConstructExp, Exp, FreeTempSei, GenStringBodyLex,    GenTempLex, LogHeapFree, PushLProcDesc, RowCons,     SysCallN, VariantConstruct],  P5L USING [    AdjustComponent, ComponentForSE, CopyToTemp, EasilyLoadable, EasyToLoad,     FieldOfComponent, FieldOfVar, GenVarItem, LoadAddress, LoadComponent,     LoadVar, MakeBo, ModComponent, OVarItem, ReleaseVarItem, ReusableCopies,     StoreComponent, StoreVar, TOSComponent, TOSLex, VarForLex, VarVarAssign],  P5S,  P5U USING [    BitsForOperand, FieldAddress, LongTreeAddress, NextVar, OperandType, Out0,     Out1, PrevVar, PushLitVal, TreeLiteralValue, WordAligned],  Stack USING [Clear, Dup, Mark, Pop],  SymbolOps USING [FirstCtxSe, FnField, NextSe],  Symbols USING [    Base, BitAddress, CBTIndex, ContextLevel, ISEIndex, ISENull, lG, RecordSEIndex],  SymbolTable USING [Handle],  Tree USING [Index, Link, Null],  TreeOps USING [DecodeBti, GetNode, OpName, NthSon, ReverseUpdateList, ScanList];Store: PROGRAM    IMPORTS CPtr: Code, MPtr: ComData, Counting, P5U, P5L, P5, Stack, SymbolOps, TreeOps    EXPORTS CodeDefs, P5, P5S =  BEGIN  OPEN CodeDefs, SymbolOps;  -- imported definitions  BitAddress: TYPE = Symbols.BitAddress;  CBTIndex: TYPE = Symbols.CBTIndex;  ISEIndex: TYPE = Symbols.ISEIndex;  ISENull: ISEIndex = Symbols.ISENull;  lG: Symbols.ContextLevel = Symbols.lG;  RecordSEIndex: TYPE = Symbols.RecordSEIndex;  cb: Symbols.Base;                -- code base (local copy)    syms: SymbolTable.Handle ¬ NIL;  StoreNotify: PUBLIC Alloc.Notifier =    BEGIN  -- called by allocator whenever table area is repacked    syms ¬ MPtr.ownSymbols;    cb ¬ base[codeType];    END;  Assign: PUBLIC PROC [node: Tree.Index] =    BEGIN -- generates code for assignment statement (RRA)    [] ¬ ComAssign[	t1: syms.tb[node].son[1], t2: syms.tb[node].son[2],	options: [expr: FALSE, init: syms.tb[node].attr1,		  counted: syms.tb[node].attr2,  composite: syms.tb[node].attr3]];    END;  AssignExp: PUBLIC PROC [node: Tree.Index] RETURNS [l: Lexeme] =    BEGIN -- generates code for assignment expression (RRA)    l ¬ ComAssign[	t1: syms.tb[node].son[1], t2: syms.tb[node].son[2],	options: [expr: TRUE, init: syms.tb[node].attr1,		  counted: syms.tb[node].attr2,  composite: syms.tb[node].attr3]];    RETURN    END;  ComAssign: PROC [t1, t2: Tree.Link, options: StoreOptions] RETURNS [l: Lexeme] =    BEGIN -- can support counted assignments (RRA)    nbits: CARDINAL;    longAddressLhs: BOOLEAN ¬ P5U.LongTreeAddress[t1];    aligned: BOOLEAN ¬ FALSE;    lv, rv: VarIndex;    l ¬ NullLex;    nbits ¬ P5U.BitsForOperand[t1];    DO  -- until we get to something interesting      SELECT TreeOps.OpName[syms, t2] FROM	pad =>	  BEGIN	  t2 ¬ TreeOps.NthSon[syms, t2, 1];	  aligned ¬ TRUE;  nbits ¬ P5U.BitsForOperand[t2];	  END;	cast, safen => t2 ¬ TreeOps.NthSon[syms, t2, 1];	ENDCASE => EXIT;      ENDLOOP;    SELECT TreeOps.OpName[syms, t2] FROM      construct => {	IF options.expr THEN l ¬ P5.ConstructExp[t1, TreeOps.GetNode[syms, t2], options]	ELSE P5.Construct[t1, TreeOps.GetNode[syms, t2], options];	RETURN};      union => IF ~options.expr THEN {P5.VariantConstruct[t1, t2, options]; RETURN};      rowcons =>	IF ~longAddressLhs OR options.counted THEN	  BEGIN	  l ¬ P5.RowCons[t1, TreeOps.GetNode[syms, t2], options];	  RETURN	  END	ELSE IF nbits > 2*wordlength THEN	  BEGIN	  tlex: se Lexeme = P5.GenTempLex[(nbits+wordlength-1) / wordlength];	  [] ¬ P5.RowCons[[symbol[tlex.lexsei]], TreeOps.GetNode[syms, t2], TempOptions[options]];	  t2 ¬ [symbol[tlex.lexsei]];	  END;      all =>	BEGIN	l ¬ P5.All[t1, TreeOps.GetNode[syms, t2], options];	RETURN	END;      ENDCASE;    rv ¬ P5L.VarForLex[P5.Exp[t2]];    IF nbits <= 2*wordlength AND ~ProbablyDumpStack[t1] THEN {      P5L.LoadVar[rv];      rv ¬ P5L.VarForLex[P5L.TOSLex[(nbits+ wordlength-1)/wordlength]]};    lv ¬ P5L.VarForLex[P5.Exp[t1]];    IF aligned THEN      P5L.FieldOfVar[r: lv, wSize: nbits/wordlength, bSize: nbits MOD wordlength];    IF options.counted THEN      l ¬ Counting.VarVarAssignCounted[lv, rv, options, P5U.OperandType[t1]]    ELSE  l ¬ P5L.VarVarAssign[lv, rv, options.expr];    RETURN    END;  TempOptions: PROC [options: StoreOptions] RETURNS [StoreOptions] = {    options.init ¬ TRUE;  options.counted ¬ FALSE;    RETURN [options]};  Extract: PUBLIC PROC [node: Tree.Index] =    BEGIN    SExtract[node];    Stack.Clear[];    END;    SExtract: PROC [node: Tree.Index] =    BEGIN    t1: Tree.Link = syms.tb[node].son[1];    tsei: RecordSEIndex = LOOPHOLE[P5U.OperandType[t1]];    r: VarIndex;    transferrec: BOOLEAN ¬ FALSE;    r ¬ P5L.VarForLex[P5.Exp[syms.tb[node].son[2]	  ! P5.LogHeapFree => IF calltree = syms.tb[node].son[2] THEN 	    {transferrec ¬ TRUE; RESUME[TRUE, NullLex]}]];    ExtractFrom[t1, tsei, r, transferrec];    END;          ExtractExp: PUBLIC PROC [node: Tree.Index] RETURNS [Lexeme] =    BEGIN    t1: Tree.Link = syms.tb[node].son[1];    tsei: RecordSEIndex = LOOPHOLE[P5U.OperandType[t1]];    r, rret: VarIndex;    r ¬ P5L.VarForLex[P5.Exp[syms.tb[node].son[2]	  ! P5.LogHeapFree => IF calltree = syms.tb[node].son[2] THEN RESUME[FALSE, NullLex]]];    [first: r, next: rret] ¬ P5L.ReusableCopies[r, store, FALSE];    ExtractFrom[t1, tsei, r, FALSE];    RETURN [[bdo[rret]]]    END;  ExtractFrom: PUBLIC PROC [      t1: Tree.Link, tsei: RecordSEIndex, r: VarIndex, transferrec: BOOLEAN] =    BEGIN    saveExtractState: RECORD [      xtracting: BOOLEAN, xtractlex: Lexeme, xtractsei: Symbols.ISEIndex] =	[CPtr.xtracting, CPtr.xtractlex, CPtr.xtractsei];    fa: PROC [SymbolTable.Handle, ISEIndex] RETURNS [BitAddress, CARDINAL] = 	IF syms.seb[tsei].argument THEN FnField ELSE P5U.FieldAddress;    startsei: ISEIndex = FirstCtxSe[syms, syms.seb[tsei].fieldCtx];    sei: ISEIndex ¬ startsei;    isei: ISEIndex ¬ startsei;    node: Tree.Index = TreeOps.GetNode[syms, t1];    soncount: CARDINAL ¬ 0;    tbase, toffset: VarComponent;    onStack, useDup: BOOLEAN ¬ FALSE;    totalBits: CARDINAL;    trashOnStack: CARDINAL ¬ 0;    XCount: PROC [h: SymbolTable.Handle, t: Tree.Link] =      BEGIN      IF t # Tree.Null THEN soncount ¬ soncount+1;      END;    ExtractItem: PROC [h: SymbolTable.Handle, t: Tree.Link]  RETURNS [v: Tree.Link] =      BEGIN      posn: BitAddress;      size: CARDINAL;      v ¬ t;      [posn, size] ¬ fa[syms, sei];      IF t # Tree.Null THEN	BEGIN	subNode: Tree.Index = TreeOps.GetNode[syms, t];	rr: VarIndex;	offset, base: VarComponent;	soncount ¬ soncount-1;        IF onStack THEN offset ¬ toffset -- original record on stack	ELSE	  BEGIN	  IF useDup THEN	    BEGIN	    IF (transferrec OR soncount > 0) THEN Stack.Dup[load: FALSE];	    base ¬ P5L.TOSComponent[1];	    END	  ELSE base ¬ tbase;	  offset ¬ toffset;	  END;        P5L.FieldOfComponent[	  var: @offset, wd: posn.wd, bd: posn.bd,	  wSize: size/wordlength, bSize: size MOD wordlength];	IF fa # FnField AND totalBits <= wordlength THEN	  P5L.AdjustComponent[var: @offset, rSei: tsei, fSei: sei, tBits: totalBits];	IF onStack THEN rr ¬ P5L.OVarItem[offset]	ELSE	  BEGIN	  rr ¬ P5L.GenVarItem[bo];	  cb[rr] ¬ [body: bo[base: base, offset: offset]];	  END;	CPtr.xtractlex ¬ [bdo[rr]];	CPtr.xtractsei ¬ sei;	SELECT syms.tb[subNode].name FROM	  assign => Assign[subNode];	  extract => SExtract[subNode];	  ENDCASE => ERROR;	END      ELSE IF onStack THEN Stack.Pop[size/wordlength];      sei ¬ P5U.PrevVar[startsei, sei];      RETURN      END; -- of ExtractItem    xlist: Tree.Link ¬ syms.tb[node].son[1];    UNTIL (isei ¬ NextSe[syms, sei]) = ISENull DO      isei ¬ P5U.NextVar[isei];      IF isei = ISENull THEN EXIT;      sei ¬ isei;      ENDLOOP;    WITH cc: cb[r] SELECT FROM      o => WITH vv: cc.var SELECT FROM	stack =>	  IF P5U.WordAligned[tsei] THEN	    BEGIN	    trashOnStack ¬ vv.wd;	    vv.wd ¬ 0;	    toffset ¬ cc.var; 	    IF trashOnStack # 0 THEN	      P5L.ModComponent[var: @toffset, wd: trashOnStack];            P5L.ReleaseVarItem[r];	    onStack ¬ TRUE;	    END	  ELSE	    BEGIN -- copy whole thing to temp	    var: VarComponent ¬ P5L.CopyToTemp[r].var;	    r ¬ P5L.OVarItem[var];	    END;	ENDCASE;      ENDCASE;    IF ~onStack THEN      BEGIN      bor: BoVarIndex ¬ P5L.MakeBo[r];      IF bor = VarNull THEN -- not addressable	BEGIN -- r was not freed in this case	var: VarComponent ¬ P5L.CopyToTemp[r].var;	r ¬ P5L.OVarItem[var];	bor ¬ P5L.MakeBo[r]; -- it will work this time        END;      tbase ¬ cb[bor].base; toffset ¬ cb[bor].offset;      P5L.ReleaseVarItem[bor];      IF tbase.wSize > 1 THEN tbase ¬ P5L.EasilyLoadable[tbase, store]      ELSE IF ~P5L.EasyToLoad[tbase, store] THEN	BEGIN	P5L.LoadComponent[tbase];	useDup ¬ TRUE;	END;      END;    totalBits ¬ toffset.wSize * wordlength + toffset.bSize;    TreeOps.ScanList[syms, xlist, XCount];    IF soncount = 0 THEN      BEGIN      IF onStack THEN	trashOnStack ¬ trashOnStack + (totalBits+(wordlength-1))/wordlength;      END    ELSE      BEGIN      CPtr.xtracting ¬ TRUE;      syms.tb[node].son[1] ¬ TreeOps.ReverseUpdateList[syms, xlist, ExtractItem];      END;    IF transferrec THEN      BEGIN      IF ~useDup THEN P5L.LoadComponent[tbase];      P5U.Out0[FOpCodes.qFF];      END;    THROUGH [0..trashOnStack) DO Stack.Pop[] ENDLOOP;    [CPtr.xtracting, CPtr.xtractlex, CPtr.xtractsei] ¬ saveExtractState;    END;  ProbablyDumpStack: PUBLIC PROC [t: Tree.Link] RETURNS [BOOLEAN] =    BEGIN -- only a hint    node: Tree.Index;    WITH t SELECT FROM      subtree => node ¬ index;      ENDCASE => RETURN [FALSE];    RETURN [SELECT syms.tb[node].name FROM      loophole, pad, chop, uparrow, dot, dollar, not  => 	ProbablyDumpStack[syms.tb[node].son[1]],      and, or => 	ProbablyDumpStack[syms.tb[node].son[2]] OR	  ProbablyDumpStack[syms.tb[node].son[1]],      plus, minus, times, div, mod,      index, dindex, seqindex =>	ProbablyDumpStack[syms.tb[node].son[2]] OR	  ProbablyDumpStack[syms.tb[node].son[1]],      ifx =>	ProbablyDumpStack[syms.tb[node].son[3]] OR	  ProbablyDumpStack[syms.tb[node].son[2]] OR	  ProbablyDumpStack[syms.tb[node].son[1]],      IN [relE..notin] =>	ProbablyDumpStack[syms.tb[node].son[2]] OR	  ProbablyDumpStack[syms.tb[node].son[1]],      IN [callx..joinx] => TRUE,      ENDCASE => FALSE]    END;  ReleaseLex: PROC[l: Lexeme] =    BEGIN    WITH l SELECT FROM      bdo => P5L.ReleaseVarItem[lexbdoi];      ENDCASE;    END;  SAssign: PUBLIC PROC [sei: ISEIndex] =    BEGIN -- assigns to a simple variable from the stack    var: VarComponent = P5L.ComponentForSE[sei];    P5L.StoreComponent[var];    END;  SLAssign: PUBLIC PROC [sei: ISEIndex, l: Lexeme, exp: BOOLEAN, nwords: CARDINAL] =    BEGIN -- obsolete?    TLLAssign[Tree.Null, [se[sei]], l, exp, nwords*wordlength];    END;  TTAssign: PUBLIC PROC [t1, t2: Tree.Link] =    BEGIN -- not called for counted assignments (RRA)    [] ¬ ComAssign[t1: t1, t2: t2, options: [expr: FALSE]];    END;  TLLAssign: PUBLIC PROC [      leftson: Tree.Link, leftlex, l: Lexeme, exp: BOOLEAN, nbits: CARDINAL] =    BEGIN -- obsolete?    rightr, leftr: VarIndex;    rightr ¬ P5L.VarForLex[l];    IF leftson # Tree.Null THEN leftlex ¬ P5.Exp[leftson];    leftr ¬ P5L.VarForLex[leftlex];    [] ¬ P5L.VarVarAssign[leftr, rightr, exp];    END;  AssignText: PUBLIC PROC [coffset, foffset: CARDINAL] =    BEGIN    r: VarIndex;    Stack.Mark[];    P5U.Out1[FOpCodes.qLCO, coffset];    P5.SysCallN[174b --CedarSD.sInitHeapLiteral--, 2];    r ¬ P5L.GenVarItem[o];    cb[r] ¬ [body: o[var: [wSize: 2, space: frame[level: lG, wd: foffset]]]];    P5L.StoreVar[r];    END;  BodyInit: PUBLIC PROC [node: Tree.Index] RETURNS [Lexeme] =    BEGIN -- assigns proc. desc for proc. variable    bti: CBTIndex = TreeOps.DecodeBti[syms.tb[node].info];    CPtr.fileindex ¬ syms.bb[bti].sourceIndex;    P5.PushLProcDesc[bti];    RETURN [P5L.TOSLex[1]]    END;  ProcInit: PUBLIC PROC [node: Tree.Index] =    BEGIN    bti: CBTIndex = TreeOps.DecodeBti[syms.tb[node].info];    WITH body: syms.bb[bti] SELECT FROM      Inner =>	BEGIN	P5L.LoadComponent[[wSize: 2, space: pdesc[ep: body.entryIndex, part: all]]];	P5U.Out1[FOpCodes.qSLD, body.frameOffset];	END;      ENDCASE;    CPtr.tailJumpOK ¬ FALSE;    END;  StringInit: PUBLIC PROC [node: Tree.Index] RETURNS [Lexeme] =    BEGIN -- inits string storage and pushes pointer on stack    nchars: CARDINAL = P5U.TreeLiteralValue[syms.tb[node].son[2]];    l: se Lexeme;    long: BOOLEAN;    l ¬ P5.GenStringBodyLex[nchars];    long ¬ P5L.LoadAddress[P5L.VarForLex[l]];    P5.FreeTempSei[l.lexsei];    P5U.PushLitVal[0];    P5U.PushLitVal[nchars];    IF long THEN {      P5U.Out1[FOpCodes.qPSDL, 0];      RETURN [P5L.TOSLex[2]] }    ELSE {      P5U.Out1[FOpCodes.qPSD, 0];      RETURN [P5L.TOSLex[1]] }    END;  END.
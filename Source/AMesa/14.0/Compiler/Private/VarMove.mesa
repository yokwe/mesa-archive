-- Copyright (C) 1983, 1984, 1986  by Xerox Corporation. All rights reserved. -- VarMove.mesa--   Sweet,		 6-Apr-84 15:16:10--   Satterthwaite,	November 24, 1980  11:02 AM--   Johnsson,		12-Jun-83 13:14:34--   Wagner		22-Aug-86  9:01:43DIRECTORY  Alloc USING [Notifier],  Code USING [curctxlvl, initialLabel, stking],  CodeDefs,  ComData,  FOpCodes,  Inline USING [BITAND, BITSHIFT, LongNumber],  Literals USING [LTIndex, LTNull],  P5L,  P5U USING [Out0, Out1, Out2, OutJump],  PrincOps USING [FieldDescriptor, localbase],  Stack,  Symbols USING [Base, ContextLevel, lG, lZ],  SymbolTable USING [Handle];VarMove: PROGRAM    IMPORTS CPtr: Code, MPtr: ComData, Inline, P5U, P5L, Stack    EXPORTS P5L, CodeDefs =  BEGIN OPEN FOpCodes, CodeDefs, Symbols;  cb: Symbols.Base;    syms: SymbolTable.Handle ¬ NIL;  VarMoveNotify: PUBLIC Alloc.Notifier =    BEGIN  -- called by allocator whenever table area is repacked    cb ¬ base[codeType];    syms ¬ MPtr.ownSymbols;    END;      LoadComponent: PUBLIC PROC [var: VarComponent] =    BEGIN    Mask: ARRAY [0..15] OF CARDINAL = [      0b, 1b, 3b, 7b, 17b, 37b, 77b, 177b, 377b, 777b,      1777b, 3777b, 7777b, 17777b, 37777b, 77777b];    wS: CARDINAL = P5L.Words[var.wSize, var.bSize];    WITH vv: var SELECT FROM      faddr =>	BEGIN	w: CARDINAL ¬ vv.wd;	lvl: ContextLevel = vv.level;	SELECT lvl FROM	  lZ => ERROR;	  lG => IF MPtr.switches['o] THEN P5U.Out1[qGA, w] ELSE ERROR;	  CPtr.curctxlvl => P5U.Out1[qLA, w];	  ENDCASE =>	    BEGIN	    P5L.LoadComponent[P5L.BaseComponent[lvl]];	    w ¬ w - PrincOps.localbase;	    IF w # 0 THEN P5L.GenAdd[w];	    END;	END;      lfaddr =>	BEGIN	w: CARDINAL ¬ vv.wd;	lvl: ContextLevel = vv.level;	SELECT lvl FROM	  lZ => ERROR;	  lG => IF MPtr.switches['o] THEN P5U.Out1[qGA, w] ELSE P5U.Out1[qLGA, w];	  CPtr.curctxlvl => P5U.Out1[qLA, w];	  ENDCASE =>	    BEGIN	    P5L.LoadComponent[P5L.BaseComponent[lvl]];	    w ¬ w - PrincOps.localbase;	    IF w # 0 THEN P5L.GenAdd[w];	    END;	IF (lvl # lG) OR MPtr.switches['o] THEN 	  IF vv.op = pad THEN P5U.Out1[qLI, 0] ELSE P5U.Out0[qLP];	END;      frame =>	BEGIN	w: CARDINAL ¬ vv.wd; 	b: CARDINAL = vv.bd;	lvl: ContextLevel = vv.level;	delta: CARDINAL ¬ 0;	IF b # 0 THEN	  BEGIN	  IF Stack.RoomFor[2] AND b + var.bSize = wordlength THEN	    BEGIN	    P5L.LoadComponent[[wSize: 1, space: frame[wd: w, level: lvl]]];	    P5L.GenAnd[Mask[var.bSize]];	    var.bSize ¬ 0;	    END	  ELSE	    BEGIN	    r: VarIndex = P5L.GenVarItem[bo];	    IF var.wSize # 0 THEN ERROR;	    cb[r] ¬ [body: bo[	      base: P5L.AddrComponent[var],	      offset: [bSize: var.bSize, space: frame[bd: b]]]];	    MoveBo[r, load];	    RETURN	    END;	  delta ¬ 1;	  END;	BEGIN -- to declare LFOp	LFOp: ARRAY BOOLEAN OF ARRAY [1..2] OF BYTE = [[qLL, qLLD], [qLG, qLGD]];	IF var.wSize # 0 THEN SELECT lvl FROM	  lZ => ERROR;	  CPtr.curctxlvl, lG => 	    BEGIN	    IF var.wSize IN [1..2] THEN {	      P5U.Out1[LFOp[lvl=lG][var.wSize], w+delta];	      IF vv.immutable AND CPtr.stking THEN	        Stack.Also[n: var.wSize, place: [frame[tOffset: w+delta, tLevel: lvl]]]}	    ELSE	      FOR i: CARDINAL IN [0..var.wSize) DO		P5U.Out1[LFOp[lvl=lG][1], w+delta+i];	        IF vv.immutable AND CPtr.stking THEN	          Stack.Also[[frame[tOffset: w+delta+i, tLevel: lvl]]];		ENDLOOP;	    END;	  ENDCASE =>	    BEGIN	    r: VarIndex = P5L.GenVarItem[bo];	    cb[r] ¬ [body: bo[	      base: P5L.BaseComponent[lvl],	      offset: [wSize: var.wSize, space:		frame[wd: w+delta - PrincOps.localbase]]]];	    MoveBo[r, load];	    END;	END; -- scope of LFOp	IF var.bSize # 0 THEN	  BEGIN -- delta = 0 in this case	  IF Stack.RoomFor[2] THEN	    BEGIN	    P5L.LoadComponent[[wSize: 1, space: frame[wd: w+var.wSize, level: lvl]]];	    P5L.GenShift[var.bSize - wordlength];	    END	  ELSE	    BEGIN	    r: VarIndex = P5L.GenVarItem[bo];	    cb[r] ¬ [body: bo[	      base: P5L.AddrComponent[var],	      offset: [bSize: var.bSize, space: frame[wd: var.wSize]]]];	    MoveBo[r, load];	    END;	  END;	END;      frameup =>	BEGIN	r: VarIndex = P5L.GenVarItem[bo];	cb[r] ¬ [body: bo[	  base: [wSize: vv.pwSize, space: frame[wd: vv.wd, level: vv.level]],	  offset: [wSize: var.wSize, space: frame[wd: vv.delta]]]];	MoveBo[r, load];	END;      linkup =>	BEGIN	IF vv.wd MOD 2 # 0 THEN ERROR;	P5U.Out1[qLLK, vv.wd/2];	P5U.Out1[IF var.wSize = 2 THEN qRDL ELSE qRL, vv.delta];	END;      caddr => P5U.Out1[qLCO, vv.wd];      code =>	BEGIN	w: CARDINAL ¬ vv.wd; 	b: CARDINAL = vv.bd;	lti: Literals.LTIndex = vv.lti;	delta: CARDINAL ¬ 0;	IF lti # Literals.LTNull THEN	  BEGIN	  LoadFirst: PROC [val: CARDINAL] =	    BEGIN	    IF b # 0 THEN	      BEGIN	      IF var.wSize # 0 AND var.bSize + b # wordlength THEN ERROR;	      val ¬ Inline.BITAND[ 		Inline.BITSHIFT[val, b + var.bSize - wordlength], Mask[var.bSize]];	      var.bSize ¬ 0;	      END;	    P5U.Out1[qLI, val];	    END;	  LoadLast: PROC [val: CARDINAL] =	    BEGIN	    IF var.bSize # 0 THEN	      val ¬ Inline.BITSHIFT[val, var.bSize - wordlength];	    P5U.Out1[qLI, val];	    END;	  WITH ll: syms.ltb[lti] SELECT FROM	    short => LoadFirst[ll.value];	    long =>	      BEGIN	      LoadFirst[ll.value[0]];	      FOR i: CARDINAL IN [1..wS-1) DO		P5U.Out1[qLI, ll.value[i]];		ENDLOOP;	      IF wS > 1 THEN LoadLast[ll.value[wS-1]];	      END;	    ENDCASE => ERROR;	  RETURN	  END;	IF b # 0 THEN	  BEGIN	  IF var.wSize # 0 AND var.bSize + b # wordlength THEN ERROR;	  P5U.Out1[qLCO, w];	  P5L.GenRFC[0, b, var.bSize];	  var.bSize ¬ 0; delta ¬ 1;	  END;	FOR i: CARDINAL IN [0..var.wSize) DO	  P5U.Out1[qLCO, w];	  P5L.GenRFC[i+delta, 0, wordlength];	  ENDLOOP;	IF var.bSize # 0 THEN	  BEGIN	  P5U.Out1[qLCO, w];	  P5L.GenRFC[var.wSize, 0, var.bSize];	  END;	END;      link => {        IF vv.wd MOD 2 # 0 THEN ERROR;	P5U.Out1[qLLK, vv.wd/2]};      stack =>	BEGIN	w: CARDINAL = vv.wd;	b: [0..wordlength) = vv.bd;	IF w # 0 THEN	  BEGIN	  IF Stack.VDepthOf[vv.sti] # wS+w-1 THEN	    BEGIN	    nsti: StackIndex;	    Stack.Dump[];	    nsti ¬ Stack.Above[vv.sti, w];	    Stack.Forget[vv.sti, w];	    vv.sti ¬ nsti;	    GO TO notOnTop;	    END;	  IF wS > 1 THEN	    BEGIN	    fvar: VarComponent ¬ Stack.TempStore[wS];	    THROUGH [0..w) DO Stack.Pop[]; ENDLOOP;	    WITH vv: fvar SELECT FROM	      frame =>		BEGIN		vv.bd ¬ b;		IF var.bSize # 0 THEN		  BEGIN		  fvar.wSize ¬ fvar.wSize-1;  fvar.bSize ¬ var.bSize;		  END;		END;	      ENDCASE;	    P5L.LoadComponent[fvar];	    RETURN;	    END	  ELSE THROUGH [0..w) DO Stack.Exchange[]; Stack.Pop[] ENDLOOP;	  vv.sti ¬ Stack.Top[1];	  EXITS	    notOnTop => NULL;	  END;	IF b # 0 THEN	  BEGIN	  rest: StackIndex;	  IF var.wSize # 0 THEN	    BEGIN	    rest ¬ Stack.Above[vv.sti, 1];	    IF b+var.bSize # wordlength THEN ERROR;	    END;	  Stack.Load[vv.sti, 1];	  SELECT b + var.bSize FROM	    > wordlength => ERROR;	    = wordlength => NULL;	    ENDCASE => P5L.GenShift[b + var.bSize - wordlength];	  P5L.GenAnd[Mask[var.bSize]];	  var.bSize ¬ 0;	  IF var.wSize # 0 THEN Stack.Load[rest, var.wSize];	  END	ELSE Stack.Load[vv.sti, wS];	IF var.bSize # 0 THEN P5L.GenShift[var.bSize - wordlength];	END;      const => 	BEGIN	v1: CARDINAL ¬ vv.d1;	b: [0..wordlength) = vv.bd;	nw: CARDINAL = P5L.Words[var.wSize, var.bSize];	IF b # 0 THEN	  BEGIN -- Field taking machinery takes care of less than word case	  IF b + var.bSize # wordlength THEN ERROR;	  v1 ¬ Inline.BITAND[v1, Mask[var.bSize]];	  var.bSize ¬ 0;	  END;	P5U.Out1[qLI, v1];	IF nw = 2 THEN 	  BEGIN	  v2: CARDINAL = 	    IF var.bSize # 0 THEN Inline.BITSHIFT[vv.d2, var.bSize - wordlength]	    ELSE vv.d2;	  P5U.Out1[qLI, v2];	  END;	END;      pdesc => {	IF MPtr.switches['o] THEN {	  IF vv.part # low THEN P5U.Out1[qGA, 1];	  IF vv.part # high THEN {	    P5U.OutJump[JumpLIO, CPtr.initialLabel[vv.ep]];	    Stack.Incr[1] } } -- account for the load of the pc	ELSE {	  P5U.OutJump[JumpDESC, CPtr.initialLabel[vv.ep]];	  IF vv.part = high THEN P5U.Out0[qDIS]	  ELSE IF vv.part = low THEN P5U.Out0[qEXDIS];	  IF vv.part = all THEN Stack.Incr[2] ELSE Stack.Incr[1] }	};      sigdesc => 	IF MPtr.switches['o] THEN {	  P5U.Out1[qGA, 0];	  P5U.Out1[qLI, vv.sig]}	ELSE P5U.Out1[qDESC, vv.sig]; -- this shouldn't be fixed by the packager!!!      ENDCASE => ERROR;    END;      LoadVar: PUBLIC PROC [r: VarIndex] =    BEGIN    WITH cb[r] SELECT FROM      o => {P5L.LoadComponent[var]; P5L.ReleaseVarItem[r]};      bo => MoveBo[r, load];      bdo => MoveBdo[r, load];      ind => MoveInd[r, load];      ENDCASE => ERROR;    END;            MoveBo: PROC [r: VarIndex, dir: MoveDirection] =    BEGIN    base, offset: VarComponent;    foffset: POINTER TO frame VarComponent;    psize: CARDINAL;    RWFOp: ARRAY MoveDirection OF ARRAY [1..2] OF BYTE =      [[qRF, qRLF], [qWF, qWLF]];        MoveInitialFragment: PROC =      BEGIN -- let Peephole find RLIF, etc.      SELECT foffset.bd+offset.bSize FROM	< wordlength => IF offset.wSize # 0 THEN ERROR;	> wordlength => ERROR;	ENDCASE;      P5L.LoadComponent[base];      P5U.Out2[	RWFOp[dir][psize],	foffset.wd,	LOOPHOLE[PrincOps.FieldDescriptor[	  offset: 0, posn: foffset.bd, size: offset.bSize]]];      offset.bSize ¬ 0;      END;        MoveFinalFragment: PROC =      BEGIN      P5L.LoadComponent[base];      P5U.Out2[	RWFOp[dir][psize],	foffset.wd,	LOOPHOLE[PrincOps.FieldDescriptor[	  offset: 0, posn: foffset.bd, size: offset.bSize]]];      END;        WITH cc: cb[r] SELECT FROM      bo => {base ¬ cc.base; offset ¬ cc.offset};      ENDCASE => ERROR;    P5L.ReleaseVarItem[r];    WITH oo: offset SELECT FROM      frame => foffset ¬ @oo;      code =>	BEGIN	IF dir = store THEN ERROR;	IF oo.bd # 0 THEN	  BEGIN	  IF offset.wSize # 0 THEN 	    IF oo.bd + offset.bSize # wordlength THEN ERROR	    ELSE IF offset.wSize # 0 THEN 	      base ¬ P5L.EasilyLoadable[base, dir];	  P5L.LoadComponent[base];	  P5L.GenRFC[oo.wd, oo.bd, offset.bSize];	  offset.bSize ¬ 0; oo.wd ¬ oo.wd + 1;	  END;	IF offset.wSize > 1 OR offset.wSize # 0 AND offset.bSize # 0 THEN	  base ¬ P5L.EasilyLoadable[base, dir];	FOR i: CARDINAL IN [0..offset.wSize) DO	  P5L.LoadComponent[base];	  P5L.GenRFC[oo.wd+i, 0, wordlength];	  ENDLOOP;	IF offset.bSize # 0 THEN	  BEGIN	  P5L.LoadComponent[base];	  P5L.GenRFC[oo.wd+offset.wSize, 0, offset.bSize];	  END;	RETURN;	END;      ENDCASE => ERROR;    psize ¬ P5L.Words[base.wSize, base.bSize];    IF psize NOT IN [1..2] THEN ERROR;    WITH bb: base SELECT FROM      faddr =>	BEGIN	SELECT bb.level FROM	  lG, CPtr.curctxlvl => {	    IF bb.level = lG AND ~MPtr.switches['o] THEN ERROR;	    IF offset.wSize IN [1..2] AND offset.bSize = 0 AND foffset.bd = 0 THEN	      BEGIN	      LSFOp: ARRAY MoveDirection OF ARRAY [1..2] OF ARRAY BOOLEAN OF BYTE =		[[[qLL, qLG], [qLLD, qLGD]], [[qSL, qSG], [qSLD, qSGD]]];	      P5U.Out1[LSFOp[dir][offset.wSize][bb.level = lG], bb.wd + foffset.wd];	      RETURN	      END }	  ENDCASE => 	    BEGIN	    tr: VarIndex = P5L.GenVarItem[bo];	    cb[tr] ¬ [body: bo[base: P5L.BaseComponent[bb.level],	      offset: [wSize: offset.wSize, bSize: offset.bSize,		space: frame[		  wd: bb.wd - PrincOps.localbase + foffset.wd, bd: foffset.bd]]]];	    MoveBo[tr, dir];	    RETURN	    END;	END;      lfaddr =>         SELECT bb.level FROM	  lG =>	    IF offset.wSize IN [1..2] AND offset.bSize = 0 AND foffset.bd = 0 	     AND MPtr.switches['o] THEN	      BEGIN	      LSFOp: ARRAY MoveDirection OF ARRAY [1..2] OF BYTE =		[[qLG, qLGD], [qSG, qSGD]];	      P5U.Out1[LSFOp[dir][offset.wSize], bb.wd + foffset.wd];	      RETURN	      END;	  ENDCASE;      stack => IF base.bSize = 0 AND base.wSize IN [1..2] THEN	BEGIN	loc: StackLocRec = Stack.Loc[bb.sti, base.wSize];	WITH loc SELECT FROM	  contig => IF place.where = frame THEN	    BEGIN -- let recursive call check other criteria	    tr: VarIndex = P5L.GenVarItem[bo];	    cb[tr] ¬ [body: bo[base: P5L.EasilyLoadable[base, dir], offset: offset]];	    MoveBo[tr, dir];	    RETURN;	    END;	  ENDCASE;	END;      ENDCASE;    IF foffset.bd # 0 OR offset.bSize # 0 THEN      BEGIN      IF offset.wSize # 0 THEN base ¬ P5L.EasilyLoadable[base, dir];      IF foffset.bd # 0 THEN	BEGIN	IF dir = load THEN MoveInitialFragment[];	foffset.wd ¬ foffset.wd+1;	END      ELSE IF dir = store THEN MoveFinalFragment[];      END;    SELECT offset.wSize FROM      0 => NULL;      > MaxParmsInStack => ERROR;      1, 2 => 	BEGIN	RWOp: ARRAY MoveDirection OF ARRAY [1..2] OF ARRAY [1..2] OF BYTE =	  [[[qR, qRL], [qRD, qRDL]], [[qW, qWL], [qWD, qWDL]]];	P5L.LoadComponent[base];	P5U.Out1[RWOp[dir][offset.wSize][psize], foffset.wd];	END;      ENDCASE =>	BEGIN	n, wo, s: CARDINAL;	tr: VarIndex;	base ¬ P5L.EasilyLoadable[base, dir];	n ¬ offset.wSize;        s ¬ MIN[n, 2];	wo ¬ IF dir = load THEN foffset.wd ELSE foffset.wd + n-s;	WHILE n # 0 DO	  tr ¬ P5L.GenVarItem[bo];	  cb[tr] ¬ [body: bo[base: base, offset: [wSize: s, space: frame[wd: wo]]]];	  MoveBo[tr, dir];	  n ¬ n - s;	  IF dir = load THEN {wo ¬ wo + s; s ¬ MIN[n, 2]}	  ELSE {s ¬ MIN[n, 2]; wo ¬ wo - s};	  ENDLOOP;	END;    IF offset.bSize # 0 THEN      BEGIN      IF foffset.bd # 0 THEN foffset.wd ¬ foffset.wd - 1;      IF dir = load THEN MoveFinalFragment[]      ELSE IF foffset.bd # 0 THEN MoveInitialFragment[];      END;    END;      MoveBdo: PROC [r: VarIndex, dir: MoveDirection] =    BEGIN    base, disp, offset: VarComponent;    bpSize: [1..2];        WITH cc: cb[r] SELECT FROM      bdo => {base ¬ cc.base; disp ¬ cc.disp; offset ¬ cc.offset};      ENDCASE => ERROR;    P5L.ReleaseVarItem[r];        -- N.B. some of the following code is copied in MakeBo.  Any bugs should    --   be fixed in both places.    WITH vv: disp SELECT FROM      const =>	BEGIN	owd: CARDINAL;	ld: Inline.LongNumber;        bor: VarIndex;	IF disp.wSize > 1 OR disp.bSize # 0 THEN GO TO tooBig;	WITH offset SELECT FROM	  frame => owd ¬ wd;	  code => owd ¬ wd;	  ENDCASE => ERROR;	ld.lc ¬ LONG[CARDINAL[vv.d1]] + LONG[owd];	IF ld.highbits # 0 THEN GO TO tooBig;	P5L.ModComponent[var: @offset, wd: vv.d1];	bor ¬ P5L.GenVarItem[bo];	cb[bor] ¬ [body: bo[base: base, offset: offset]];	MoveBo[bor, dir];	RETURN;	EXITS	 tooBig => NULL;	END;      ENDCASE;        bpSize ¬ P5L.LoadSum[@disp, @base];    BEGIN    tr: VarIndex = P5L.GenVarItem[bo];    cb[tr] ¬ [body: bo[base: P5L.TOSComponent[bpSize], offset: offset]];    MoveBo[tr, dir];    END;    END;      MoveInd: PROC [r: VarIndex, dir: MoveDirection] =    BEGIN    base, index, offset: VarComponent;    packed, simple: BOOLEAN;    eWords, grain: CARDINAL;        WITH cc: cb[r] SELECT FROM      ind =>	BEGIN	base ¬ cc.base;  index ¬ cc.index;  offset ¬ cc.offset;	simple ¬ cc.simple;	WITH pp: cc SELECT FROM	  packed => {packed ¬ TRUE; grain ¬ pp.grain};	  notPacked => {packed ¬ FALSE; eWords ¬ pp.eWords};	  ENDCASE;	END;      ENDCASE => ERROR;    P5L.ReleaseVarItem[r];        IF ~packed THEN      BEGIN      tr: BdoVarIndex = LOOPHOLE[P5L.GenVarItem[bdo]];      cb[tr] ¬ [body: bdo[base: base, disp: NULL, offset: offset]];      IF eWords = 1 THEN cb[tr].disp ¬ index      ELSE	BEGIN	WITH vv: index SELECT FROM	  const =>	    BEGIN	    ld: Inline.LongNumber;	    ld.lc ¬ LONG[CARDINAL[vv.d1]] * LONG[eWords];	    vv.d1 ¬ ld.lowbits;	    IF ld.highbits # 0 THEN {vv.wSize ¬ 2; vv.d2 ¬ ld.highbits};	    cb[tr].disp ¬ index;	    GO TO const;	    END;	  ENDCASE;	P5L.LoadComponent[index];	P5U.Out1[qLI, eWords];	IF simple THEN	  BEGIN	  P5U.Out0[qMUL];	  cb[tr].disp ¬ P5L.TOSComponent[1];	  END	ELSE	  BEGIN	  P5U.Out0[qAMUL];	  P5U.Out0[qREC];	  cb[tr].disp ¬ P5L.TOSComponent[2];	  END;	EXITS	  const => NULL;	END;      MoveBdo[tr, dir];      END    ELSE      BEGIN      shift: [4..7] ¬ (SELECT grain FROM	1 => 4, 2 => 5, 4 => 6, 8 => 7, ENDCASE => ERROR);      obd: [0..wordlength);      owd: CARDINAL;      fd: PrincOps.FieldDescriptor;      bpSize: CARDINAL;      fromCode: BOOLEAN;      RWFSOp: ARRAY MoveDirection OF BYTE =	[qRLFS, qWLFS];      WITH oo: offset SELECT FROM	code => {obd ¬ oo.bd; owd ¬ oo.wd; fromCode ¬ TRUE};	frame =>	  BEGIN	  IF oo.level # lZ THEN ERROR;	  obd ¬ oo.bd; owd ¬ oo.wd;	  fromCode ¬ FALSE;	  END;	ENDCASE => ERROR;      fd ¬ [offset: 0, posn: obd, size: offset.bSize];      bpSize ¬ P5L.Words[base.wSize, base.bSize];      IF bpSize NOT IN [1..2] OR offset.wSize # 0 OR offset.bSize = 0	THEN ERROR;      IF ~fromCode AND fd = [offset: 0, posn: 0, size: 8] THEN	BEGIN	RWSTROp: ARRAY MoveDirection OF ARRAY [1..2] OF BYTE = 	  [[qRSTR, qRSTRL], [qWSTR, qWSTRL]];	alpha: CARDINAL ¬ owd;	P5L.LoadBoth[@base, @index, FALSE];	IF alpha > LAST[BYTE] THEN	  BEGIN	  P5L.GenAdd[alpha-LAST[BYTE]];	  alpha ¬ LAST[BYTE];	  END;	P5U.Out1[RWSTROp[dir][bpSize], alpha];	RETURN	END;      IF simple THEN	BEGIN	P5L.LoadComponent[base];	IF ~fromCode AND bpSize = 1 THEN P5U.Out0[FOpCodes.qLP];	P5L.LoadComponent[index];	IF owd # 0 THEN P5L.GenAdd[owd];	END      ELSE	BEGIN	Mask: ARRAY [4..7] OF CARDINAL = [17b, 7b, 3b, 1b];	IF owd # 0 THEN	  BEGIN	  P5L.LoadComponent[index];	  P5L.GenAdd[owd];	  index ¬ Stack.TempStore[1];	  END	ELSE index ¬ P5L.EasilyLoadable[index, load];	P5L.LoadComponent[base];	IF ~fromCode AND bpSize = 1 THEN P5U.Out0[FOpCodes.qLP];	P5L.LoadComponent[index];	P5L.GenShift[shift-8];	IF fromCode THEN P5U.Out0[FOpCodes.qADD]	ELSE P5U.Out0[FOpCodes.qADC];	P5L.LoadComponent[index];	P5L.GenAnd[Mask[shift]];	END;      P5L.GenShift[shift];      IF fd # LOOPHOLE[0] THEN P5L.GenAdd[fd];      IF fromCode THEN P5U.Out0[qRCFS] ELSE P5U.Out0[RWFSOp[dir]];      END;        END;      StoreComponent: PUBLIC PROC [var: VarComponent] =    BEGIN    w, b: CARDINAL;    lvl: ContextLevel;    WITH vv: var SELECT FROM      frame => {w ¬ vv.wd; b ¬ vv.bd; lvl ¬ vv.level};      frameup =>	BEGIN	r: VarIndex = P5L.GenVarItem[bo];	cb[r] ¬ [body: bo[	  base: [wSize: vv.pwSize, space: frame[wd: vv.wd, level: vv.level]],	  offset: [wSize: vv.wSize, space: frame[wd: vv.delta]]]];	MoveBo[r, store];	END;      linkup =>	BEGIN	r: VarIndex = P5L.GenVarItem[bo];	cb[r] ¬ [body: bo[	  base: [wSize: 2, space: link[wd: vv.wd]],	  offset: [wSize: vv.wSize, space: frame[wd: vv.delta]]]];	MoveBo[r, store];	END;      ENDCASE => ERROR;    IF b # 0 OR var.bSize # 0 THEN      BEGIN      r: VarIndex = P5L.GenVarItem[bo];      cb[r] ¬ [body: bo[	base: P5L.AddrComponent[var],	offset: [wSize: var.wSize, bSize: var.bSize, space: frame[bd: b]]]];      MoveBo[r, store];      END    ELSE      BEGIN      SFOp: ARRAY BOOLEAN OF ARRAY [1..2] OF BYTE = [[qSL, qSLD], [qSG, qSGD]];      SELECT lvl FROM	lZ => ERROR;	CPtr.curctxlvl, lG => IF var.wSize IN [1..2] THEN	  P5U.Out1[SFOp[lvl=lG][var.wSize], w]	ELSE	  FOR i: CARDINAL DECREASING IN [0..var.wSize) DO	    P5U.Out1[SFOp[lvl=lG][1], w+i];	    ENDLOOP;	ENDCASE =>	  BEGIN	  r: VarIndex = P5L.GenVarItem[bo];	  cb[r] ¬ [body: bo[base: P5L.BaseComponent[lvl],	    offset: [wSize: var.wSize,	      space: frame[wd: w - PrincOps.localbase]]]];	  MoveBo[r, store];	  END;      END;    END;      StoreVar: PUBLIC PROC [r: VarIndex] =    BEGIN    WITH cb[r] SELECT FROM      o => {P5L.StoreComponent[var]; P5L.ReleaseVarItem[r]};      bo => MoveBo[r, store];      bdo => MoveBdo[r, store];      ind => MoveInd[r, store];      ENDCASE => ERROR;    END;      END.
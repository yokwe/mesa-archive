-- Copyright (C) 1981, 1983, 1986  by Xerox Corporation. All rights reserved. -- file Pass3D.mesa-- last modified by Satterthwaite, October 25, 1982 12:21 pm-- last modified by Donahue, 10-Dec-81 10:22:58-- last modified by Sweet, 26-May-83 15:42:55-- Wagner		18-Aug-86 10:55:45DIRECTORY  ComData USING [    idANY, idCARDINAL, interface, mainCtx, moduleCtx, seAnon, textIndex,    typeINT, typeStringBody],  Inline USING [BITOR],  CLog USING [Error, ErrorHti, ErrorSei, ErrorTree],  P3 USING [    Attr, NPUse, SequenceNP, fullAttr, voidAttr,    mark, pathNP, phraseNP,    AssignableType, CheckDisjoint, ClearRefStack, CopyTree, Default, DefaultInit,    EnterComposite, Exp, FindSe, IndexType, InterfaceCtx, MakeFrameRecord,    MakeLongType, NewableType, OrderedType, PopCtx, PushCtx,    RAttr, RecordLhs, RecordMention, Rhs, RPop, RPush, RType, SafetyAttr,    SealRefStack, SearchCtxList, SelectVariantType, TargetType, TopCtx,    UnsealRefStack, VariantUnionType, Voidable, VoidExp, VoidItem],  Symbols USING [    Base, HTIndex, SEIndex, ISEIndex, CSEIndex, RecordSEIndex, CTXIndex, CBTIndex,    SENull, ISENull, CTXNull, codeANY, codeINT, lG, lZ, typeANY, typeTYPE],  SymbolOps USING [    ArgCtx, CopyXferType, EnterExtension, LinkMode, NormalType, RCType,    ReferentType, TypeForm, TypeLink, UnderType, XferMode,    FromCard, FromSei, ToCard, ToSei, ToTreeIndex],  SymbolTable USING [Handle],  Tree USING [Base, Index, Link, Null, NullIndex],  TreeOps USING [    DecodeCard, DecodeBti, DecodeCSei, DecodeSei, EncodeSei,    FreeTree, GetHash, GetNode, GetSe, ListHead, ListLength, Map, NthSon, OpName,    Scan, ScanList, UpdateList];Pass3D: PROGRAM    IMPORTS      Inline, Log: CLog, P3, SymbolOps, TreeOps,      dataPtr: ComData    EXPORTS P3 = {  OPEN TreeOps, SymbolOps, Symbols, P3;    syms: SymbolTable.Handle ¬ NIL;    Pass3DInit: PUBLIC PROC [h: SymbolTable.Handle] = { syms ¬ h };-- signals for type loop detection  CheckTypeLoop: SIGNAL [loopNode: Tree.Index] RETURNS [BOOLEAN] = CODE;  LogTypeLoop: SIGNAL [loopNode: Tree.Index] = CODE;-- declaration processing  ItemId: PUBLIC PROC [t: Tree.Link] RETURNS [ISEIndex] = {    RETURN [WITH t SELECT FROM      symbol => index,      subtree => ItemId[syms.tb[index].son[1]],      ENDCASE => ERROR]};  FirstId: PUBLIC PROC [node: Tree.Index] RETURNS [ISEIndex] = {    RETURN [ItemId[ListHead[syms, syms.tb[node].son[1]]]]};  DeclList: PUBLIC TreeOps.Scan = {ScanList[syms, t, DeclA]; ScanList[syms, t, DeclBInit]};  DeclA: TreeOps.Scan = {    node: Tree.Index = GetNode[syms, t];    type: SEIndex;    saveIndex: CARDINAL = dataPtr.textIndex;    IF syms.tb[node].attr3 = P3.mark THEN RETURN;	-- already processed    syms.tb[node].attr3 ¬ P3.mark;    dataPtr.textIndex ¬ DecodeCard[syms.tb[node].info];    syms.tb[node].son[2] ¬ TypeLink[syms.tb[node].son[2]	  ! CheckTypeLoop => {IF loopNode = node THEN RESUME [TRUE]};	    LogTypeLoop => {IF loopNode = node THEN RESUME}];    type ¬ TypeForTree[syms.tb[node].son[2]];    SELECT syms.tb[node].name FROM      typedecl => DefineTypeSe[syms.tb[node].son[1], type];      decl => DefineSeType[syms.tb[node].son[1], type, syms.tb[node].attr1];      ENDCASE => ERROR;    ClearRefStack[];    dataPtr.textIndex ¬ saveIndex};  DeclBField: TreeOps.Scan = {DeclBDefault[t, FALSE]};  DeclBVarField: TreeOps.Scan = {DeclBDefault[t, TRUE]};  DeclBDefault: PROC [t: Tree.Link, varOK: BOOLEAN ¬ FALSE] = {    node: Tree.Index = GetNode[syms, t];    saveIndex: CARDINAL = dataPtr.textIndex;    IF syms.tb[node].attr2 = P3.mark THEN RETURN;	-- already processed    syms.tb[node].attr2 ¬ P3.mark;    dataPtr.textIndex ¬ DecodeCard[syms.tb[node].info];    TypeAttr[typeExp: syms.tb[node].son[2], varOK: varOK];    SELECT syms.tb[node].name FROM      typedecl => NULL;      decl => {	type: SEIndex = TypeForTree[syms.tb[node].son[2]];	IF ~NewableType[type] THEN Log.ErrorTree[typeLength, syms.tb[node].son[2]];	IF syms.tb[node].son[3] # Tree.Null THEN {	  ScanList[syms, syms.tb[node].son[1], RecordDeclInit];	  syms.tb[node].son[3] ¬ DefaultExp[	      t: syms.tb[node].son[3], type: type, ids: syms.tb[node].son[1]]};	DefineSeValue[syms.tb[node].son[1], FALSE]};      ENDCASE => ERROR;    ClearRefStack[];    dataPtr.textIndex ¬ saveIndex};  DeclBInit: TreeOps.Scan = {    node: Tree.Index = GetNode[syms, t];    saveIndex: CARDINAL = dataPtr.textIndex;    IF syms.tb[node].attr2 = P3.mark THEN RETURN;	-- already processed    syms.tb[node].attr2 ¬ P3.mark;    dataPtr.textIndex ¬ DecodeCard[syms.tb[node].info];    [] ¬ CheckPositions[syms.tb[node].son[1], FieldAttrs[]];    SELECT syms.tb[node].name FROM      typedecl => {	TypeAttr[syms.tb[node].son[2]];	IF syms.tb[node].son[3] # Tree.Null THEN {	  syms.tb[node].son[3] ¬ DefaultExp[	    t:syms.tb[node].son[3], type:TypeForTree[syms.tb[node].son[2]], ids:syms.tb[node].son[1]];	  [] ¬ ProcessDefault[node]}};      decl => {	type: SEIndex;	constFlag, extFlag: BOOLEAN;	ctx: CTXIndex = TopCtx[];	TypeAttr[typeExp: syms.tb[node].son[2], varOK: InterfaceContext[ctx]];	type ¬ TypeForTree[syms.tb[node].son[2]];	IF ~NewableType[type] THEN Log.ErrorTree[typeLength, syms.tb[node].son[2]];	IF syms.tb[node].son[3] = Tree.Null THEN {	  IF ~InterfaceContext[ctx] AND ~syms.tb[node].attr1 THEN {	    syms.tb[node].son[3] ¬  DefaultInit[type];	    pathNP ¬ SequenceNP[pathNP][phraseNP]; RPop[]};	  constFlag ¬ FALSE}	ELSE {	  [syms.tb[node].son[3], extFlag] ¬ InitialExp[syms.tb[node].son[3], type];	  IF extFlag AND ~syms.tb[node].attr1 THEN Log.ErrorTree[misusedInline, syms.tb[node].son[3]];	  pathNP ¬ SequenceNP[pathNP][phraseNP];	  constFlag ¬ syms.tb[node].attr1 AND RAttr[].const;  RPop[];	  IF syms.tb[node].son[3] # Tree.Null THEN ScanList[syms, syms.tb[node].son[1], RecordDeclInit]};	SELECT TRUE FROM	  (syms.tb[node].son[3] = Tree.Null) =>	    IF ~InterfaceContext[ctx] AND ~Voidable[type] THEN	      Log.ErrorSei[missingInit, FirstId[node]];	  GlobalContext[ctx] =>	    SELECT RCType[syms, UnderType[syms, type]] FROM	      composite => EnterComposite[UnderType[syms, type], syms.tb[node].son[3], TRUE];	      ENDCASE => NULL;	  ENDCASE => NULL;	DefineSeValue[syms.tb[node].son[1], constFlag]};      ENDCASE => ERROR;    ClearRefStack[];    dataPtr.textIndex ¬ saveIndex};  RecordDeclInit: TreeOps.Scan = {    sei: ISEIndex = ItemId[t]; RecordMention[sei]; RecordLhs[sei]};  DefaultExp: PROC [t: Tree.Link, type: SEIndex, ids: Tree.Link] RETURNS [v: Tree.Link] = {    subType: CSEIndex = TargetType[UnderType[syms, type]];    ExpInit: TreeOps.Map = {      v ¬ Rhs[t, subType];  RPop[];  RETURN};    v ¬ UpdateList[syms, t, ExpInit];    IF VoidItem[v] AND ~Voidable[type] THEN Log.ErrorSei[defaultForm, ItemId[ids]];    RETURN};  InitialExp: PUBLIC PROC [t: Tree.Link, type: SEIndex]      RETURNS [v: Tree.Link, extended: BOOLEAN] = {    subType: CSEIndex = UnderType[syms, type];    v ¬ t;  extended ¬ FALSE;  phraseNP ¬ none;    SELECT OpName[syms, t] FROM      body => {	-- defer processing of bodies (see Body)	expNode: Tree.Index = GetNode[syms, t];	bti: CBTIndex = DecodeBti[syms.tb[expNode].info];	attr: Attr ¬ voidAttr;	SELECT XferMode[syms, type] FROM	  proc, program => NULL;	  ENDCASE =>	    IF TypeForm[syms, type] = definition THEN attr ¬ fullAttr ELSE Log.Error[bodyType];	syms.bb[bti].ioType ¬ SELECT syms.seb[type].seTag FROM			    cons => subType,			    ENDCASE => CopyXferType[syms, subType];	RPush[subType, attr];  extended ¬ syms.tb[expNode].attr3;  -- inline	CheckBodyType[subType, expNode]};      inline => {	expNode: Tree.Index = GetNode[syms, t];	CodeBody: TreeOps.Map = {RETURN [UpdateList[syms, t, NumericConst]]};	IF XferMode[syms, type] # proc THEN Log.Error[inlineType];	IF syms.tb[expNode].attr1 THEN Log.Error[attrClash];	syms.tb[expNode].son[1] ¬ UpdateList[syms, syms.tb[expNode].son[1], CodeBody];	RPush[subType, fullAttr];  extended ¬ TRUE;	CheckBodyType[subType, expNode]};      apply => {	expNode: Tree.Index = GetNode[syms, t];	IF syms.tb[expNode].son[1] = Tree.Null	 AND ReferentType[syms, subType] = dataPtr.typeStringBody	 AND ListLength[syms, syms.tb[expNode].son[2]] = 1 THEN	  syms.tb[expNode].name ¬ stringinit;	v ¬ Rhs[t, TargetType[subType]]};      signalinit => RPush[subType, voidAttr];      void => {v ¬ FreeTree[syms, t];  RPush[subType, voidAttr]};      ENDCASE => v ¬ Rhs[t, TargetType[subType]];    RETURN};  RecordField: PROC [ctx: CTXIndex] RETURNS [BOOLEAN] = INLINE {    RETURN [ctx = CTXNull OR (syms.ctxb[ctx].level = lZ AND ctx # dataPtr.moduleCtx)]};  GlobalContext: PROC [ctx: CTXIndex] RETURNS [BOOLEAN] = INLINE {    RETURN [~dataPtr.interface AND syms.ctxb[ctx].level = lG]};  InterfaceContext: PROC [ctx: CTXIndex] RETURNS [BOOLEAN] = INLINE {    RETURN [dataPtr.interface AND ctx = dataPtr.mainCtx]};  InterfaceSe: PROC [sei: ISEIndex] RETURNS [BOOLEAN] = INLINE {    RETURN [InterfaceContext[syms.seb[sei].idCtx]]};  CheckBodyType: PROC [type: CSEIndex, node: Tree.Index] = {    WITH t: syms.seb[type] SELECT FROM      transfer => {        IF TypeForm[syms, t.typeIn] = any OR TypeForm[syms, t.typeOut] = any THEN	  Log.Error[bodyType];	IF t.safe AND SafetyAttr[node] = none THEN Log.Error[unsafeBlock]};      ENDCASE};              DefineTypeSe: PROC [t: Tree.Link, info: SEIndex] = {    first: BOOLEAN ¬ TRUE;    UpdateSe: TreeOps.Scan = {      sei: ISEIndex = ItemId[t];      syms.seb[sei].idType ¬ typeTYPE;  syms.seb[sei].idInfo ¬ FromSei[info];      syms.seb[sei].immutable ¬ syms.seb[sei].constant ¬ TRUE;      IF first THEN {info ¬ sei; first ¬ FALSE};      syms.seb[sei].mark3 ¬ TRUE};    ScanList[syms, t, UpdateSe]};  DefineSeType: PROC [t: Tree.Link, type: SEIndex, fixed: BOOLEAN] = {    UpdateSe: TreeOps.Scan = {      sei: ISEIndex = ItemId[t];      syms.seb[sei].idType ¬ type;  syms.seb[sei].constant ¬ FALSE;      IF InterfaceSe[sei] THEN syms.seb[sei].immutable ¬ syms.seb[sei].immutable OR fixed      ELSE syms.seb[sei].immutable ¬ fixed;      syms.seb[sei].mark3 ¬ TRUE};    ScanList[syms, t, UpdateSe]};  DefineSeValue: PROC [t: Tree.Link, const: BOOLEAN] = {    UpdateSe: TreeOps.Scan = {      sei: ISEIndex = ItemId[t];      syms.seb[sei].constant ¬ const;      IF InterfaceSe[sei] AND LinkMode[syms, sei] = val THEN syms.seb[sei].immutable ¬ TRUE};    ScanList[syms, t, UpdateSe]};  ProcessDefault: PROC [node: Tree.Index] RETURNS [nonVoid: BOOLEAN] = {    copy: BOOLEAN;    v: Tree.Link = syms.tb[node].son[3];    DefineDefault: TreeOps.Scan = {      EnterExtension[syms, ItemId[t], default, IF copy THEN CopyTree[syms, v] ELSE v];      copy ¬ TRUE};    SELECT OpName[syms, v] FROM      stringinit => Log.ErrorSei[defaultForm, FirstId[node]];      lengthen =>	IF OpName[syms, NthSon[syms, v, 1]] = stringinit THEN	  Log.ErrorSei[defaultForm, FirstId[node]];      void => nonVoid ¬ FALSE;      ENDCASE => nonVoid ¬ TRUE;    copy ¬ FALSE;  ScanList[syms, syms.tb[node].son[1], DefineDefault];    syms.tb[node].son[3] ¬ Tree.Null}; -- forward reference resolution  ResolveType: PUBLIC PROC [sei: ISEIndex] = {    currentCtx: CTXIndex = TopCtx[];    IF syms.seb[sei].idCtx # currentCtx THEN {PopCtx[]; ResolveType[sei]; PushCtx[currentCtx]}    ELSE {      SealRefStack[];       DeclA[syms, [subtree[index: ToTreeIndex[syms.seb[sei].idValue]]]];       UnsealRefStack[]}};  ResolveValue: PUBLIC PROC [sei: ISEIndex] = {    currentCtx: CTXIndex = TopCtx[];    IF syms.seb[sei].idCtx # currentCtx THEN {PopCtx[]; ResolveValue[sei]; PushCtx[currentCtx]}    ELSE {      SealRefStack[];      IF RecordField[currentCtx] THEN         DeclBDefault[[subtree[index: ToTreeIndex[syms.seb[sei].idValue]]]]      ELSE          DeclBInit[syms, [subtree[index: ToTreeIndex[syms.seb[sei].idValue]]]];      UnsealRefStack[]}}; -- type expressions  CheckTypeId: PROC [sei: ISEIndex] RETURNS [BOOLEAN] = {    node: Tree.Index;    IF sei = ISENull THEN RETURN[FALSE];    IF syms.seb[sei].mark3 THEN RETURN [syms.seb[sei].idType = typeTYPE];    node ¬ ToTreeIndex[syms.seb[sei].idValue];    RETURN [node = Tree.NullIndex OR syms.tb[node].name = typedecl]};  TypeSymbol: PROC [sei: ISEIndex] RETURNS [val: Tree.Link] = {    entryIndex: CARDINAL = dataPtr.textIndex;    circular: BOOLEAN ¬ FALSE;    IF ~syms.seb[sei].mark3 THEN {      ENABLE	  LogTypeLoop => {	    saveIndex: CARDINAL = dataPtr.textIndex;	    dataPtr.textIndex ¬ entryIndex;	    Log.ErrorSei[circularType, sei];  circular ¬ TRUE;	    dataPtr.textIndex ¬ saveIndex};      declNode: Tree.Index = ToTreeIndex[syms.seb[sei].idValue];      IF syms.tb[declNode].attr3 # P3.mark THEN ResolveType[sei]      ELSE IF SIGNAL CheckTypeLoop[declNode] THEN SIGNAL LogTypeLoop[declNode]};    IF CheckTypeId[sei] AND ~circular THEN val ¬ [symbol[index: sei]]    ELSE {      IF ~circular AND sei # dataPtr.seAnon THEN Log.ErrorSei[nonTypeId, sei];      val ¬ [symbol[index: dataPtr.idANY]]};    RETURN};  PushArgCtx: PROC [sei: CSEIndex] = {    ctx: CTXIndex = ArgCtx[syms, sei];    IF ctx # CTXNull THEN PushCtx[ctx]};  PopArgCtx: PROC [sei: CSEIndex] = {    IF ArgCtx[syms, sei] # CTXNull THEN PopCtx[]};  TypeExp: PUBLIC TreeOps.Map = {    v ¬ TypeLink[t]; TypeAttr[v]; RETURN};  TypeAppl: PUBLIC TreeOps.Map = {    attr: Attr;    IF OpName[syms, t] = apply THEN {      node: Tree.Index = GetNode[syms, t];      rType: SEIndex;      syms.tb[node].son[1] ¬ TypeExp[syms, syms.tb[node].son[1]];      syms.tb[node].info ¬ EncodeSei[rType ¬ TypeForTree[syms.tb[node].son[1]]];      SELECT TRUE FROM	(UnderType[syms, rType] = dataPtr.typeStringBody),	(TypeForm[syms, VariantUnionType[rType]] = sequence) => {	  syms.tb[node].son[2] ¬ Rhs[syms.tb[node].son[2], dataPtr.typeINT]; attr ¬ RAttr[]; RPop[]};	(TypeForm[syms, VariantUnionType[rType]] = union) => {	  TypeDiscrim[rType, node];  phraseNP ¬ none; attr ¬ fullAttr};	ENDCASE => {	  Log.ErrorTree[typeClash, syms.tb[node].son[1]];	  syms.tb[node].son[2] ¬ Exp[syms.tb[node].son[2], typeANY]; attr ¬ RAttr[]; RPop[]};      v ¬ t}    ELSE {v ¬ TypeExp[syms, t]; phraseNP ¬ none; attr ¬ fullAttr};    RPush[typeTYPE, attr]};  ClusterExp: PROC [t: Tree.Link] RETURNS [val: Tree.Link] = {    WITH t SELECT FROM      hash => {        sei: ISEIndex = FindSe[index].symbol;        IF ~CheckTypeId[sei] THEN		-- prevent duplicate error messages          val ¬ Exp[IF sei = dataPtr.seAnon THEN [symbol[sei]] ELSE t, typeANY]        ELSE {val ¬ TypeSymbol[sei]; RPush[typeTYPE, fullAttr]}};      symbol => {        sei: ISEIndex = index;        IF ~CheckTypeId[sei] THEN val ¬ Exp[t, typeANY]        ELSE {val ¬ TypeSymbol[sei]; RPush[typeTYPE, fullAttr]}};      ENDCASE => {val ¬ TypeLink[t]; RPush[typeTYPE, fullAttr]};    RETURN};        TypeDot: PROC [rType: SEIndex, node: Tree.Index] = TypeDiscrim;    -- for now, should do other possible cluster items  TypeDiscrim: PROC [rType: SEIndex, node: Tree.Index] = {    t2: Tree.Link = syms.tb[node].son[2];    WITH h: t2 SELECT FROM      hash => {	iSei: ISEIndex = SelectVariantType[rType, h.index];	IF iSei # ISENull THEN {	  syms.tb[node].info ¬ EncodeSei[iSei];  syms.tb[node].son[2] ¬ [symbol[index: iSei]];	  syms.tb[node].name ¬ discrimTC}	ELSE {	  IF rType # typeANY THEN Log.ErrorTree[unknownVariant, t2];	  syms.tb[node].info ¬ EncodeSei[dataPtr.idANY]}};      ENDCASE => {	Log.ErrorTree[unknownVariant, t2]; syms.tb[node].son[2] ¬ VoidExp[syms, t2]}};  TypeForTree: PUBLIC PROC [t: Tree.Link] RETURNS [SEIndex] = {    -- N.B. assumes t evaluated by TypeLink or Exp    RETURN [WITH t SELECT FROM      symbol => index,      subtree =>	SELECT syms.tb[index].name FROM	  cdot, discrimTC => TypeForTree[syms.tb[index].son[2]],	  ENDCASE => DecodeSei[syms.tb[index].info],      ENDCASE => typeANY]};  FindLinkType: SIGNAL RETURNS [CSEIndex] = CODE;	-- to find list link type  TypeLink: PROC [typeExp: Tree.Link] RETURNS [val: Tree.Link] = {    WITH typeExp SELECT FROM      hash => {	sei: ISEIndex = FindSe[index].symbol;	IF sei # SENull THEN val ¬ TypeSymbol[sei]	ELSE {Log.ErrorHti[nonTypeId, index]; val ¬ [symbol[dataPtr.idANY]]}};      symbol => val ¬ TypeSymbol[index];      subtree => {	node: Tree.Index = index;	iSei: ISEIndex;	SELECT syms.tb[node].name FROM	  discrimTC => {	    syms.tb[node].son[1] ¬ TypeLink[syms.tb[node].son[1]];	    TypeDiscrim[TypeForTree[syms.tb[node].son[1]], node]};	  apply => {	    rType: SEIndex;	    syms.tb[node].son[1] ¬ TypeLink[syms.tb[node].son[1]];	    syms.tb[node].info ¬ EncodeSei[rType ¬ TypeForTree[syms.tb[node].son[1]]];	    IF TypeForm[syms, VariantUnionType[rType]] = union THEN TypeDiscrim[rType, node]	    ELSE Log.ErrorTree[noApplication, syms.tb[node].son[1]]};	  dot => {	    hti: HTIndex = GetHash[syms, syms.tb[node].son[2]];	    nDerefs: CARDINAL ¬ 0;	    found: BOOLEAN;	    next: SEIndex;	    ctx: CTXIndex ¬ CTXNull;	    syms.tb[node].son[1] ¬ ClusterExp[syms.tb[node].son[1]];	    FOR subType: CSEIndex ¬ RType[], UnderType[syms, next] DO	      WITH t: syms.seb[subType] SELECT FROM		mode => GOTO discrim;		definition, transfer => {		  ctx ¬ InterfaceCtx[subType, syms.tb[node].son[1]]; GO TO dot};		record => {ctx ¬ t.fieldCtx; GO TO dot};		ref => {IF (nDerefs ¬ nDerefs+1) > 63 THEN GO TO dot; next ¬ t.refType};		long => next ¬ t.rangeType;		subrange => next ¬ t.rangeType;		ENDCASE => GO TO dot;	      REPEAT		discrim => TypeDiscrim[TypeForTree[syms.tb[node].son[1]], node];		dot => {		  [found, iSei] ¬ SearchCtxList[hti, ctx];		  IF ~found THEN {iSei ¬ dataPtr.idANY; Log.ErrorHti[unknownField, hti]};		  syms.tb[node].name ¬ cdot;		  syms.tb[node].info ¬ EncodeSei[iSei];  		  syms.tb[node].son[2] ¬ TypeSymbol[iSei]};	      ENDLOOP;	    RPop[]};	  linkTC => syms.tb[node].info ¬ EncodeSei[SIGNAL FindLinkType[]];	  implicitTC => NULL;	  frameTC => {	    syms.tb[node].son[1] ¬ Exp[syms.tb[node].son[1], typeANY];  RPop[];	    syms.tb[node].info ¬ EncodeSei[MakeFrameRecord[syms.tb[node].son[1]]]};	  ENDCASE => {	    OPEN syms.tb[node];	    type: CSEIndex = DecodeCSei[info];	    WITH t: syms.seb[type] SELECT FROM	      enumerated => NULL;	      record => {PushCtx[t.fieldCtx]; ScanList[syms, son[1], DeclA]; PopCtx[]};	      ref => {		son[1] ¬ TypeLink[son[1] ! CheckTypeLoop => {RESUME [FALSE]}];		t.refType ¬ TypeForTree[son[1]]};	      array => {		IF son[1] = Tree.Null THEN t.indexType ¬ dataPtr.idCARDINAL		ELSE {son[1] ¬ TypeLink[son[1]]; t.indexType ¬ TypeForTree[son[1]]};		son[2] ¬ TypeLink[son[2]];  t.componentType ¬ TypeForTree[son[2]]};	      arraydesc => {		son[1] ¬ TypeLink[son[1] ! CheckTypeLoop => {RESUME [FALSE]}];		t.describedType ¬ TypeForTree[son[1]]};	      transfer => {		ENABLE  CheckTypeLoop => {RESUME [FALSE]};		CheckDisjoint[ArgCtx[syms, t.typeIn], ArgCtx[syms, t.typeOut]];		PushArgCtx[t.typeIn];		IF OpName[syms, son[1]] # anyTC THEN ScanList[syms, son[1], DeclA];		PushArgCtx[t.typeOut];		IF OpName[syms, son[2]] # anyTC THEN ScanList[syms, son[2], DeclA];		PopArgCtx[t.typeOut];  PopArgCtx[t.typeIn]};	      definition => t.defCtx ¬ dataPtr.mainCtx;	      union => {DeclA[syms, son[1]]; ScanList[syms, son[2], DeclA]};	      sequence => {		DeclA[syms, son[1]];		son[2] ¬ TypeLink[son[2]];  t.componentType ¬ TypeForTree[son[2]]};	      relative => {		son[1] ¬ TypeLink[son[1] ! CheckTypeLoop => {RESUME [FALSE]}];		t.baseType ¬ TypeForTree[son[1]];		son[2] ¬ TypeLink[son[2]];		t.resultType ¬ t.offsetType ¬ TypeForTree[son[2]]};	      opaque => IF t.id = SENull OR ~InterfaceSe[t.id] THEN Log.Error[misplacedType];	      zone => NULL;	      subrange => {		t.range ¬ LOOPHOLE[node];    -- to allow symbolic evaluation		son[1] ¬ TypeLink[son[1]]; t.rangeType ¬ TypeForTree[son[1]]};	      long => {		son[1] ¬ TypeLink[son[1] ! FindLinkType => {RESUME [type]}];		t.rangeType ¬ TypeForTree[son[1]]};	      any => NULL;	      ENDCASE => ERROR;	    syms.seb[type].mark3 ¬ TRUE};	val ¬ typeExp};      ENDCASE => ERROR;    RETURN};  TypeAttr: PROC [typeExp: Tree.Link, indirect, varOK: BOOLEAN ¬ FALSE] = {    WITH typeExp SELECT FROM      symbol =>	IF ~indirect THEN {	  sei: ISEIndex = index;	  IF syms.seb[sei].mark3 AND ~syms.seb[sei].mark4 THEN {	    declNode: Tree.Index = ToTreeIndex[syms.seb[sei].idValue];	    IF syms.tb[declNode].attr2 # P3.mark THEN ResolveValue[sei]}};      subtree => {	node: Tree.Index = index;	SELECT syms.tb[node].name FROM	  discrimTC => TypeAttr[syms.tb[node].son[1], indirect];	  cdot => TypeAttr[syms.tb[node].son[2], indirect];	  implicitTC, linkTC => NULL;	  frameTC => NULL;	  apply => syms.tb[node].son[2] ¬ VoidExp[syms, syms.tb[node].son[2]];	  dot => NULL;	  ENDCASE => {	    OPEN syms.tb[node];	    type: CSEIndex = DecodeCSei[info];	    subType: CSEIndex;	    WITH t: syms.seb[type] SELECT FROM	      enumerated =>		IF AssignedEnumeration[son[1]] AND ~t.machineDep THEN Log.Error[machDep];	      record => {		saveNP: NPUse = pathNP;		PushCtx[t.fieldCtx];  pathNP ¬ none;		ScanList[syms, son[1], DeclBField];		WITH s: t SELECT FROM		  linked => CheckDisjointPrefix[t.fieldCtx, s.linkType];		  notLinked => {		    attrs: FieldAttrs = CollectAttrs[				son[1], FieldAttrs[positionValid: t.machineDep]];		    UpdateHints[LOOPHOLE[type], attrs];		    attr1 ¬ AssignedPositions[attrs]};		  ENDCASE => ERROR;		PopCtx[];  pathNP ¬ saveNP};	      ref => {	        IF t.var AND ~varOK THEN Log.Error[var];		TypeAttr[son[1], TRUE]};	      array => {		IF son[1] # Tree.Null THEN TypeAttr[son[1]];		SELECT TRUE FROM		  ~IndexType[t.indexType] => {		    t.indexType ¬ typeANY; Log.Error[nonOrderedType]};		  (TypeForm[syms, t.indexType]=long) => Log.Error[subrangeNesting];		  ENDCASE;		TypeAttr[son[2], indirect];		IF ~NewableType[t.componentType] THEN Log.ErrorTree[typeLength, son[2]]};	      arraydesc => {		TypeAttr[son[1], TRUE];		IF TypeForm[syms, t.describedType] # array THEN Log.Error[descriptor]};	      transfer => {		saveNP: NPUse = pathNP;		IF t.mode = error THEN t.safe ¬ FALSE;		PushArgCtx[t.typeIn];		ArgAttr[t.typeIn, son[1], t.mode = proc OR t.mode = signal];		PushArgCtx[t.typeOut];		ArgAttr[t.typeOut, son[2], FALSE];		PopArgCtx[t.typeOut];  PopArgCtx[t.typeIn];		pathNP ¬ saveNP};	      definition => NULL;	      union => {		tagType: CSEIndex;		DeclBDefault[son[1]];		syms.seb[t.tagSei].immutable ¬ TRUE;		tagType ¬ TargetType[UnderType[syms, syms.seb[t.tagSei].idType]];		IF syms.seb[tagType].typeTag # enumerated THEN {		  Log.ErrorSei[nonTagType, t.tagSei]; tagType ¬ typeANY};		VariantList[son[2], tagType]};	      sequence => {		DeclBDefault[son[1]];		syms.seb[t.tagSei].immutable ¬ TRUE;		SELECT TRUE FROM		  ~IndexType[syms.seb[t.tagSei].idType] => Log.ErrorSei[nonTagType, t.tagSei];		  (TypeForm[syms, syms.seb[t.tagSei].idType]=long) => Log.Error[unimplemented];		  ENDCASE;		TypeAttr[son[2], indirect]};	      relative => {		vType: CSEIndex;		TypeAttr[son[1], TRUE];		IF syms.seb[NormalType[syms, UnderType[syms, t.baseType]]].typeTag # ref THEN Log.Error[relative];		TypeAttr[son[2]];		vType ¬ UnderType[syms, t.offsetType];  subType ¬ NormalType[syms, vType];		SELECT syms.seb[subType].typeTag FROM		  ref, arraydesc => NULL;		  ENDCASE => {Log.Error[relative]; subType ¬ typeANY};		IF syms.seb[UnderType[syms, t.baseType]].typeTag = long OR syms.seb[vType].typeTag = long THEN		  subType ¬ MakeLongType[subType, vType];		t.resultType ¬ subType};	      zone => NULL;	      opaque =>		IF son[1] # Tree.Null THEN {		  son[1] ¬ Rhs[son[1], dataPtr.typeINT];		  IF ~RAttr[].const THEN Log.ErrorTree[nonConstant, son[1]];		  RPop[]};	      subrange => {		target: CSEIndex;		subNode: Tree.Index = GetNode[syms, son[2]];		TypeAttr[son[1], indirect];  subType ¬ UnderType[syms, t.rangeType];		SELECT TRUE FROM		  (TypeForm[syms, subType] = ref) => target ¬ dataPtr.typeINT;		  OrderedType[subType] => {		    WITH s: syms.seb[subType] SELECT FROM		      long => {		        t.rangeType ¬ s.rangeType;			subType ¬ UnderType[syms, s.rangeType]};		      real => Log.Error[subrangeNesting];		      ENDCASE;		    target ¬ TargetType[subType]};		  ENDCASE => {Log.Error[nonOrderedType]; target ¬ typeANY};		syms.tb[subNode].son[1] ¬ EndPoint[syms.tb[subNode].son[1], target];		syms.tb[subNode].son[2] ¬ EndPoint[syms.tb[subNode].son[2], target]};	      long => {		TypeAttr[son[1], indirect, varOK];		subType ¬ UnderType[syms, t.rangeType];		WITH s: syms.seb[subType] SELECT FROM		  basic =>		    SELECT s.code FROM		      codeINT, codeANY => NULL;		      ENDCASE => Log.Error[long];		  ref, arraydesc => NULL;		  subrange => IF t.rangeType # dataPtr.idCARDINAL THEN Log.Error[long];		  ENDCASE => Log.Error[long]};	      any => NULL;	      ENDCASE => ERROR}};      ENDCASE => ERROR};            EndPoint: PROC [t: Tree.Link, target: CSEIndex] RETURNS [v: Tree.Link] = {        v ¬ Rhs[t, target];        IF ~RAttr[].const THEN Log.ErrorTree[nonConstant, v];        RPop[]}; -- record attribute collection  FieldAttrs: TYPE = RECORD [    positionValid: BOOLEAN ¬ FALSE,    noAssign: BOOLEAN ¬ FALSE,    refField, unVoidable, default: BOOLEAN ¬ FALSE,    positions: PACKED ARRAY {implicit, explicit} OF BOOLEAN ¬ [FALSE, FALSE]];  MergeAttrs: PROC [attr1, attr2: FieldAttrs] RETURNS [FieldAttrs] =    LOOPHOLE[Inline.BITOR];  UpdateHints: PROC [rSei: RecordSEIndex, attrs: FieldAttrs] = {    syms.seb[rSei].hints.assignable ¬ ~attrs.noAssign;    syms.seb[rSei].hints.refField ¬ attrs.refField;    syms.seb[rSei].hints.voidable ¬ ~attrs.unVoidable;    syms.seb[rSei].hints.default ¬ attrs.default};  AssignedPositions: PROC [attrs: FieldAttrs] RETURNS [assigned: BOOLEAN] = {    IF attrs.positionValid THEN {      IF attrs.positions = [TRUE, TRUE] THEN Log.Error[mixedPositions];      assigned ¬ attrs.positions[explicit]}    ELSE assigned ¬ FALSE;    RETURN};  CollectAttrs: PROC [t: Tree.Link, attrs: FieldAttrs] RETURNS [FieldAttrs] = {    ProcessField: TreeOps.Scan = {      node: Tree.Index = GetNode[syms, t];      type: SEIndex = TypeForTree[syms.tb[node].son[2]];      subType: CSEIndex = UnderType[syms, type];      attrs ¬ CheckPositions[syms.tb[node].son[1], attrs];      IF (IF syms.tb[node].son[3] = Tree.Null		THEN Default[type] = nonVoid		ELSE ProcessDefault[node]) THEN attrs.default ¬ TRUE;      WITH t: syms.seb[subType] SELECT FROM	union => {	  subNode: Tree.Index = GetNode[syms, syms.tb[node].son[2]];	  IF t.controlled THEN ProcessField[syms, syms.tb[subNode].son[1]];	  attrs ¬ MergeVariantAttrs[syms.tb[subNode].son[2], attrs];	  t.hints.refField ¬ attrs.refField; t.hints.voidable ¬ ~attrs.unVoidable;	  t.hints.default ¬ attrs.default;	  syms.tb[subNode].attr1 ¬ attrs.positions[explicit]};	sequence => {	  subNode: Tree.Index = GetNode[syms, syms.tb[node].son[2]];	  IF t.controlled THEN ProcessField[syms, syms.tb[subNode].son[1]];	  IF RCType[syms, UnderType[syms, t.componentType]] # none THEN {	    IF ~t.controlled THEN Log.Error[attrClash];	    attrs.refField ¬ --attrs.unVoidable ¬-- TRUE};	  attrs.noAssign ¬ TRUE;	  syms.tb[subNode].attr1 ¬ attrs.positions[explicit]};	ENDCASE => {	  IF ~attrs.refField AND RCType[syms, subType] # none THEN	    attrs.refField ¬ attrs.unVoidable ¬ TRUE;	  IF ~attrs.unVoidable AND ~Voidable[type] THEN attrs.unVoidable ¬ TRUE;	  IF ~AssignableType[subType, FALSE] THEN attrs.noAssign ¬ TRUE}};    ScanList[syms, t, ProcessField];    RETURN [attrs]};  ArgAttr: PROC [rSei: CSEIndex, t: Tree.Link, varOK: BOOLEAN] = {    IF rSei # SENull THEN      WITH syms.seb[rSei] SELECT FROM        record => {	  ScanList[syms, t, IF varOK THEN DeclBVarField ELSE DeclBField];	  UpdateHints[LOOPHOLE[rSei], CollectAttrs[t, FieldAttrs[]]]};	ENDCASE}; -- machine dependent layout  NumericConst: TreeOps.Map = {v ¬ Rhs[t, dataPtr.typeINT];  RPop[];  RETURN};  AssignedEnumeration: PROC [t: Tree.Link] RETURNS [assigned: BOOLEAN] = {    AssignElement: TreeOps.Scan = {      WITH t SELECT FROM	subtree => {	  node: Tree.Index = index;	  syms.tb[node].son[2] ¬ NumericConst[syms, syms.tb[node].son[2]];  assigned ¬ TRUE};	ENDCASE => NULL;      RETURN};    assigned ¬ FALSE;  ScanList[syms, t, AssignElement];  RETURN};  CheckPositions: PROC [t: Tree.Link, attrs: FieldAttrs] RETURNS [FieldAttrs] = {    CheckPosition: TreeOps.Scan = {      WITH t SELECT FROM	subtree => {	  node: Tree.Index = GetNode[syms, syms.tb[index].son[2]];	  IF ~attrs.positionValid THEN Log.ErrorSei[position, ItemId[syms.tb[index].son[1]]];	  syms.tb[node].son[1] ¬ NumericConst[syms, syms.tb[node].son[1]];	  IF syms.tb[node].son[2] # Tree.Null THEN {	    subNode: Tree.Index = GetNode[syms, syms.tb[node].son[2]];	    syms.tb[subNode].son[1] ¬ NumericConst[syms, syms.tb[subNode].son[1]];	    syms.tb[subNode].son[2] ¬ NumericConst[syms, syms.tb[subNode].son[2]]};	  attrs.positions[explicit] ¬ TRUE};	ENDCASE => attrs.positions[implicit] ¬ TRUE};    ScanList[syms, t, CheckPosition]; RETURN [attrs]}; -- variants  CheckDisjointPrefix: PROC [ctx: CTXIndex, link: SEIndex] = {    FOR sei: SEIndex ¬ link, SymbolOps.TypeLink[syms, sei] UNTIL sei = SENull DO      type: CSEIndex = UnderType[syms, sei];      WITH t: syms.seb[type] SELECT FROM	record => CheckDisjoint[ctx, t.fieldCtx];	ENDCASE;      ENDLOOP};         VariantList: PROC [t: Tree.Link, tagType: CSEIndex] = {    DefineTag: TreeOps.Scan = {      sei: ISEIndex = GetSe[syms, t];      syms.seb[sei].idValue ¬ FromCard[TagValue[syms.seb[sei].hash, tagType]]};    VariantItem: TreeOps.Scan = {      node: Tree.Index = GetNode[syms, t];      saveIndex: CARDINAL = dataPtr.textIndex;      dataPtr.textIndex ¬ DecodeCard[syms.tb[node].info];      ScanList[syms, syms.tb[node].son[1], DefineTag];      DeclBDefault[t];      dataPtr.textIndex ¬ saveIndex};    ScanList[syms, t, VariantItem]};  TagValue: PROC [tag: HTIndex, tagType: CSEIndex] RETURNS [CARDINAL] = {    matched: BOOLEAN;    sei: ISEIndex;    WITH syms.seb[tagType] SELECT FROM      enumerated => {	[matched, sei] ¬ SearchCtxList[tag, valueCtx];	IF matched THEN RETURN [ToCard[syms.seb[sei].idValue]]};      ENDCASE;    Log.ErrorHti[unknownTag, tag];  RETURN [0]};  MergeVariantAttrs: PROC [list: Tree.Link, prefixAttrs: FieldAttrs]      RETURNS [mergedAttrs: FieldAttrs] = {    ProcessVariant: TreeOps.Scan = {      node: Tree.Index = GetNode[syms, t];      ProcessLabel: TreeOps.Scan = {	sei: ISEIndex = GetSe[syms, t];	type: SEIndex = ToSei[syms.seb[sei].idInfo];	WITH v: syms.seb[type] SELECT FROM	  cons =>	    WITH r: v SELECT FROM	      record => {		subNode: Tree.Index = GetNode[syms, syms.tb[node].son[2]];		attrs: FieldAttrs = CollectAttrs[syms.tb[subNode].son[1], prefixAttrs];		UpdateHints[LOOPHOLE[type], attrs];		r.hints.default ¬ TRUE;		syms.tb[subNode].attr1 ¬ attrs.positions[explicit];		mergedAttrs ¬ MergeAttrs[mergedAttrs, attrs]};	      ENDCASE;	  id => NULL;	  ENDCASE};      ScanList[syms, syms.tb[node].son[1], ProcessLabel]};    mergedAttrs ¬ prefixAttrs;    ScanList[syms, list, ProcessVariant];  mergedAttrs.default ¬ prefixAttrs.default;    RETURN};  }.
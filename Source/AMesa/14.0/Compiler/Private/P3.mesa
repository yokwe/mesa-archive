-- Copyright (C) 1983, 1986  by Xerox Corporation. All rights reserved. -- file P3.mesa-- last modified by Satterthwaite, September 23, 1982 9:59 am-- last modified by Sweet, 28-Jan-83 10:51:39-- Wagner	19-Aug-86 11:18:45DIRECTORY  Copier USING [SEToken],  Inline USING [BITAND],  Symbols USING [    HTIndex, SEIndex, ISEIndex, CSEIndex, RecordSEIndex, RefSEIndex,    CTXIndex, IncludedCTXIndex, MDIndex, BTIndex, CBTIndex, Closure],  SymbolTable USING [Handle],  Tree USING [Index, Link],  TreeOps USING [Map, Scan];P3: DEFINITIONS IMPORTS Inline = {  OPEN Symbols;  mark: BOOLEAN = TRUE;		-- mark in tree as set by pass 3 -- defaults  DefaultForm: TYPE = {none, void, nonVoid}; -- text literals  TextForm: TYPE = {text, rope, ropeText}; -- attributes  Attr: TYPE = RECORD [    noAssign: BOOLEAN,    noXfer: BOOLEAN,    const: BOOLEAN];  emptyAttr: Attr = [noAssign:FALSE, noXfer:FALSE, const:FALSE];  fullAttr: Attr = [noAssign:TRUE, noXfer:TRUE, const:TRUE];  voidAttr: Attr = [noAssign:TRUE, noXfer:TRUE, const:FALSE];  And: PROC [Attr, Attr] RETURNS [Attr] = LOOPHOLE[Inline.BITAND]; -- reference counting and safety (Cedar)  LhsMode: TYPE = {none, uncounted, counted};  Safety: TYPE = {none, asserted, checked}; -- narrowing operations   NarrowOp: TYPE = RECORD [    error, indirect, rtTest, tagTest, computed, unImpl: BOOLEAN¬FALSE];     -- parameter use bookkeeping (for subst by name)  NPUse: TYPE = {none, ref, set, refset, unsafe};	-- (name) param use  NPMap: TYPE = ARRAY NPUse OF ARRAY NPUse OF NPUse;  SetNP: ARRAY NPUse OF NPUse = [set, refset, set, refset, unsafe];  MergeNP: NPMap =    [[  none,    ref,    set, refset, unsafe],     [   ref,    ref, unsafe, unsafe, unsafe],     [   set, unsafe,    set, unsafe, unsafe],     [refset, unsafe, unsafe, unsafe, unsafe],     [unsafe, unsafe, unsafe, unsafe, unsafe]];  SequenceNP: NPMap =    [[  none,    ref,    set, refset, unsafe],     [   ref,    ref, refset, refset, unsafe],     [   set, unsafe,    set, unsafe, unsafe],     [refset, unsafe, refset, unsafe, unsafe],     [unsafe, unsafe, unsafe, unsafe, unsafe]];  BoundNP: NPMap =    [[  none,    ref,    set, refset, unsafe],     [   ref,    ref, unsafe, refset, unsafe],     [   set, unsafe,    set, refset, unsafe],     [refset, refset, refset, refset, unsafe],     [unsafe, unsafe, unsafe, unsafe, unsafe]];    OpLevel: TYPE = {global, local, unknown};   -- intermediate result bookkeeping    OperandDescriptor: TYPE = RECORD[    type: CSEIndex,		-- type of operand    attr: Attr];		-- attributes  RStack: TYPE = RECORD [SEQUENCE length: NAT OF OperandDescriptor]; -- exported by Pass3B  Pass3BInit: PROC [SymbolTable.Handle];  Header: PROC [node: Tree.Index];  SetDefaultImport: PROC [iCtx: IncludedCTXIndex, implicitOK: BOOLEAN¬FALSE]; -- exported by Pass3T  Pass3TInit: PROC [SymbolTable.Handle];  AccessMode: PUBLIC PROC [CSEIndex] RETURNS [LhsMode];  AssignableType: PROC [type: CSEIndex, safe: BOOLEAN] RETURNS [BOOLEAN];  Bundling: PROC [CSEIndex] RETURNS [CARDINAL];  CanonicalType: PROC [CSEIndex] RETURNS [CSEIndex];  Default: PROC [SEIndex] RETURNS [DefaultForm];  DefaultInit: PROC [SEIndex] RETURNS [Tree.Link];  IdentifiedType: PROC [CSEIndex] RETURNS [BOOLEAN];  IndexType: PROC [SEIndex] RETURNS [BOOLEAN];  MakeLongType: PROC [SEIndex, CSEIndex] RETURNS [CSEIndex];  MakeRefType: PROC [      cType: SEIndex, hint: CSEIndex,      readOnly, counted, var: BOOLEAN ¬ FALSE]    RETURNS [RefSEIndex];  MarkedType: PROC [CSEIndex] RETURNS [CSEIndex];  Narrowing: PROC [type, target: CSEIndex] RETURNS [NarrowOp];  NewableType: PROC [SEIndex] RETURNS [BOOLEAN];  NullableType: PROC [SEIndex] RETURNS [BOOLEAN];  OrderedType: PROC [SEIndex] RETURNS [BOOLEAN];  TargetType: PROC [CSEIndex] RETURNS [CSEIndex];  Unbundle: PROC [RecordSEIndex] RETURNS [CSEIndex];  Voidable: PROC [SEIndex] RETURNS [BOOLEAN];  VoidItem: PROC [Tree.Link] RETURNS [BOOLEAN]; -- exported by Pass3D  Pass3DInit: PROC [SymbolTable.Handle];  DeclList: TreeOps.Scan;  FirstId: PROC [Tree.Index] RETURNS [ISEIndex];  InitialExp: PROC [Tree.Link, SEIndex] RETURNS [v: Tree.Link, extended: BOOLEAN];  ResolveType: PROC [ISEIndex];  ResolveValue: PROC [ISEIndex];  TypeAppl: TreeOps.Map;  TypeExp: TreeOps.Map;  TypeForTree: PROC [Tree.Link] RETURNS [SEIndex]; -- exported by Pass3I  Pass3IInit: PROC [SymbolTable.Handle, UNCOUNTED ZONE];  IdReset: TreeOps.Scan;  ArrangeKeys: PROC [	expList: Tree.Link,	nextKey: PROC RETURNS [HTIndex],	omittedValue: PROC RETURNS [Tree.Link]]    RETURNS [CARDINAL];  BaseTree: PROC [Tree.Link, CSEIndex] RETURNS [Tree.Link];  BindTree: PROC [Tree.Link, PROC [ISEIndex] RETURNS [Tree.Link]] RETURNS [Tree.Link];  BumpCount: PROC [ISEIndex];  CheckDisjoint: PROC [ctx1, ctx2: CTXIndex];  ClearRefStack: PROC;  CloseBase: PROC [Tree.Link, HTIndex];  ClusterId: PROC [HTIndex, CTXIndex] RETURNS [found: BOOLEAN, sei: ISEIndex];  CompleteRecord: PROC [rSei: RecordSEIndex, depth: Closure ¬ unit];  CopyTree: TreeOps.Map;  EnterIdList: PROC [IncludedCTXIndex, Tree.Link];  EnterComposite: PROC [type: CSEIndex, t: Tree.Link, init: BOOLEAN];  EnterType: PROC [type: SEIndex, canonical: BOOLEAN¬TRUE];  FieldId: PROC [HTIndex, RecordSEIndex] RETURNS [CARDINAL, ISEIndex];  FindSe: PROC [HTIndex] RETURNS [symbol: ISEIndex, base: Tree.Link, indirect: BOOLEAN];  Id: PROC [HTIndex] RETURNS [Tree.Link];  InterfaceId: PROC [HTIndex, CTXIndex] RETURNS [found: BOOLEAN, sei: ISEIndex];  MainIncludedCtx: PROC [MDIndex] RETURNS [IncludedCTXIndex];  MakeIdTable: PROC [CARDINAL];  OpenBase: PROC [Tree.Link, HTIndex] RETURNS [Tree.Link];  OpenPointer: PROC [Tree.Link, CSEIndex] RETURNS [Tree.Link, CSEIndex];  PopCtx: PROC;  PushCtx: PROC [CTXIndex];  PushHtCtx: PROC [HTIndex, Tree.Link, BOOLEAN];  PushRecordCtx: PROC [RecordSEIndex, Tree.Link, BOOLEAN];   RecordLhs: PROC [ISEIndex];  RecordMention: PROC [ISEIndex];  SealRefStack: PROC;  SearchCtxList: PROC [HTIndex, CTXIndex] RETURNS [found: BOOLEAN, sei: ISEIndex];  Shared: PROC [CTXIndex] RETURNS [BOOLEAN];  TopCtx: PROC RETURNS [CTXIndex];  UnsealRefStack: PROC;  UpdateTreeAttr: PROC [Tree.Link] RETURNS [attr: Attr]; -- exported by Pass3M    Pass3MInit: PROC [SymbolTable.Handle];  BodyForTree: PROC [Tree.Link] RETURNS [CBTIndex];  CatchPhrase: PROC [Tree.Link] RETURNS [unwindCaught: BOOLEAN];  CopyLock: PROC RETURNS [Tree.Link];  FindLockParams: PROC RETURNS [formal, actual: ISEIndex];  LockVar: PROC [Tree.Link] RETURNS [Tree.Link];  MakeFrameRecord: PROC [Tree.Link] RETURNS [CSEIndex];  MiscStmt: PROC [Tree.Index] RETURNS [Tree.Link];  MiscXfer: PROC [Tree.Index, CSEIndex] RETURNS [Tree.Link];  TextRep: PROC [SEIndex] RETURNS [TextForm];  XferForFrame: PROC [CTXIndex] RETURNS [CSEIndex];  InsertCatchLabel: SIGNAL [catchSeen, exit: BOOLEAN]; -- exported by Pass3S   Pass3SInit: PROC [SymbolTable.Handle];    pathNP: NPUse;  BodyList: PROC [firstBti: BTIndex];  BumpArgRefs: PROC [record: RecordSEIndex, write: BOOLEAN];  Case: PROC [Tree.Index, TreeOps.Map];  CheckLocals: PROC [Tree.Link] RETURNS [localsOnly: BOOLEAN];  SafetyAttr: PROC [Tree.Index] RETURNS [Safety];--  SetSafety: PROC [Safety];  Scope: PROC [Tree.Index, TreeOps.Map];  Stmt: TreeOps.Map; -- exported by Pass3V  Pass3VInit: PROC [SymbolTable.Handle];  DiscriminatedType: PROC [CSEIndex, Tree.Link] RETURNS [CSEIndex];  Discrimination: PROC [Tree.Index, TreeOps.Map];  SelectVariantType: PROC [SEIndex, HTIndex] RETURNS [ISEIndex];  SequenceField: PROC [RecordSEIndex] RETURNS [ISEIndex];  VariantUnionType: PROC [SEIndex] RETURNS [CSEIndex]; -- exported by Pass3Xa  phraseNP: NPUse;  Pass3XaInit: PROC [SymbolTable.Handle];  All: PROC [node: Tree.Index, target: CSEIndex, init: BOOLEAN¬FALSE];  Apply: PROC [Tree.Index, CSEIndex, BOOLEAN] RETURNS [Tree.Index];  Assignment: PROC [Tree.Index];  CheckScope: PROC [Tree.Link, CSEIndex] RETURNS [Tree.Link];  Dot: PROC [Tree.Index, CSEIndex] RETURNS [Tree.Index];  Extract: PROC [Tree.Index];  FieldDefault: PROC [ISEIndex] RETURNS [Tree.Link];  Initialization: PROC [CSEIndex, Tree.Link] RETURNS [Tree.Link];  InterfaceCtx: PROC [CSEIndex, Tree.Link] RETURNS [CTXIndex];  MatchFields: PROC [      record: RecordSEIndex, expList: Tree.Link,      init: BOOLEAN¬FALSE, scopeCheck: BOOLEAN¬TRUE]    RETURNS [Tree.Link]; -- exported by Pass3Xb  Pass3XbInit: PROC [SymbolTable.Handle, UNCOUNTED ZONE];  ExpReset: PROC;    rStack: LONG POINTER TO RStack;  rI: INTEGER;			-- index into rStack  Exp: PROC [Tree.Link, CSEIndex] RETURNS [Tree.Link];  Interval: PROC [Tree.Link, CSEIndex, BOOLEAN];  Float: PROC [t: Tree.Link, type, target: CSEIndex] RETURNS [Tree.Link];  ForceType: PROC [Tree.Link, CSEIndex] RETURNS [Tree.Link];  Lengthen: PROC [t: Tree.Link, target: CSEIndex] RETURNS [Tree.Link];  LongPath: PROC [Tree.Link] RETURNS [BOOLEAN];  OperandType: PROC [Tree.Link] RETURNS [CSEIndex];  Range: PROC [Tree.Link, CSEIndex] RETURNS [Tree.Link];  RAttr: PROC RETURNS [Attr];  RPop: PROC;  RPush: PROC [CSEIndex, Attr];  RType: PROC RETURNS [CSEIndex];  Shorten: PROC [t: Tree.Link, target: CSEIndex] RETURNS [Tree.Link];  VoidExp: TreeOps.Map; -- exported by Pass3Xc  Pass3XcInit: PROC [SymbolTable.Handle];  AddrOp: PROC [Tree.Index, CSEIndex];  BoolOp: PROC [node: Tree.Index];  Span: PROC [CSEIndex] RETURNS [first, last: Copier.SEToken];    OperandInline: PROC [Tree.Link] RETURNS [BOOLEAN];  OperandInternal: PROC [Tree.Link] RETURNS [BOOLEAN];  OperandLevel: PROC [t: Tree.Link] RETURNS [level: OpLevel];  OperandLhs: PROC [Tree.Link] RETURNS [LhsMode];    BalancedRhs: PROC [exp: Tree.Link, target: CSEIndex] RETURNS [val: Tree.Link];  GenericRhs: PROC [exp: Tree.Link, target: CSEIndex] RETURNS [val: Tree.Link];  Rhs: PROC [Tree.Link, CSEIndex] RETURNS [Tree.Link];  RhsPrime: PROC [Tree.Link, CSEIndex, BOOLEAN] RETURNS [Tree.Link];    }.
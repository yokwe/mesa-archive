-- Copyright (C) 1983, 1986  by Xerox Corporation. All rights reserved. -- file Pass3POps.mesa-- last modified by Satterthwaite, October 22, 1982 11:20 am-- last modified by Sweet,  1-Nov-83 16:19:59-- Wagner		20-Aug-86 19:00:04DIRECTORY  P3POps USING [AList, copying, ExpandTree],  Symbols USING [    ISEIndex, CSEIndex, RecordSEIndex, CTXIndex, ISENull, RecordSENull, CTXNull,     lZ, typeTYPE],  SymbolOps USING [    FirstCtxSe, NextSe, TransferTypes, FromCard, ToCard],  SymbolTable USING [Handle],  Tree USING [Index, Link],  TreeOps USING [Scan, ScanSons];Pass3POps: PROGRAM    IMPORTS      P3POps, SymbolOps, TreeOps    EXPORTS P3POps = {  OPEN TreeOps, SymbolOps, Symbols;  syms: SymbolTable.Handle ¬ NIL;    InitPass3POps: PUBLIC PROC [h: SymbolTable.Handle] = { syms ¬ h };    aStack: PUBLIC P3POps.AList;	-- current association list -- reference count adjustment   CountedSei: PUBLIC PROC [sei: ISEIndex] RETURNS [BOOLEAN] = {    ctx: CTXIndex = syms.seb[sei].idCtx;    RETURN [~syms.seb[sei].constant	AND syms.ctxb[ctx].level # lZ AND syms.ctxb[ctx].ctxType # included]};		  IncrCount: PUBLIC PROC [sei: ISEIndex] = {	-- modified BumpCount (Pass3I)    IF syms.seb[sei].idType # typeTYPE AND (~syms.seb[sei].mark4 OR CountedSei[sei]) THEN      syms.seb[sei].idInfo ¬ FromCard[ToCard[syms.seb[sei].idInfo] + 1]};  DecrCount: PUBLIC PROC [sei: ISEIndex] = {    IF syms.seb[sei].idType # typeTYPE AND (~syms.seb[sei].mark4 OR CountedSei[sei]) THEN      IF syms.seb[sei].idInfo # FromCard[0] THEN         syms.seb[sei].idInfo ¬ FromCard[ToCard[syms.seb[sei].idInfo] - 1]};  AdjustForName: PUBLIC TreeOps.Scan = {    WITH t SELECT FROM      symbol => DecrCount[index];      subtree => {        node: Tree.Index = index;        SELECT syms.tb[node].name FROM	  thread => AdjustForName[syms, syms.tb[node].son[1]];	  ENDCASE => ScanSons[syms, t, AdjustForName]};      ENDCASE};          SetCtxCounts: PUBLIC PROC [ctx: CTXIndex, nRefs: [0..1]] = {    FOR sei: ISEIndex ¬ FirstCtxSe[syms, ctx], NextSe[syms, sei] UNTIL sei = ISENull DO      IF ~syms.seb[sei].constant THEN syms.seb[sei].idInfo ¬ FromCard[nRefs];      ENDLOOP};        ComputeArgCounts: PUBLIC PROC [type: CSEIndex, body: Tree.Link] = {    typeIn, typeOut: RecordSEIndex;    argCtx, resultCtx: CTXIndex;    [typeIn, typeOut] ¬ TransferTypes[syms, type];    argCtx ¬ FieldCtx[typeIn];  resultCtx ¬ FieldCtx[typeOut];    IF argCtx # CTXNull OR resultCtx # CTXNull THEN {      UpdateCount: TreeOps.Scan = {	WITH t SELECT FROM	  symbol => {	    sei: ISEIndex = index;	    SELECT syms.seb[sei].idCtx FROM	      CTXNull => NULL;	      argCtx, resultCtx => 	        syms.seb[sei].idInfo ¬ FromCard[ToCard[syms.seb[sei].idInfo] + 1];	      ENDCASE};	  subtree => ScanSons[syms, t, UpdateCount];	  ENDCASE => NULL};                 SetCtxCounts[argCtx, 1];  SetCtxCounts[resultCtx, 0];      ScanSons[syms, body, UpdateCount]}};  FieldCtx: PUBLIC PROC [rSei: RecordSEIndex] RETURNS [CTXIndex] = {    RETURN [IF rSei = RecordSENull THEN CTXNull ELSE syms.seb[rSei].fieldCtx]};       -- association lists  PushAList: PUBLIC PROC [aLink: P3POps.AList] = {aLink.next ¬ aStack; aStack ¬ aLink};  PopAList: PUBLIC PROC RETURNS [aLink: P3POps.AList] = {    IF aStack = NIL THEN ERROR;  aLink ¬ aStack; aStack ¬ aLink.next};  ExpandSei: PUBLIC PROC [sei: ISEIndex] RETURNS [v: Tree.Link] = {    i: CARDINAL;    FOR aLink: P3POps.AList ¬ aStack, aLink.next UNTIL aLink = NIL DO      IF syms.seb[sei].idCtx = aLink.ctx THEN	FOR i IN [0 .. aLink.nItems) DO IF aLink.map[i].id = sei THEN GO TO Found ENDLOOP;      REPEAT	Found => {	  saveCopying: BOOLEAN = P3POps.copying;	  P3POps.copying ¬ TRUE;  v ¬ P3POps.ExpandTree[syms, aLink.map[i].val];	  P3POps.copying ¬ saveCopying};	FINISHED => {IF P3POps.copying THEN IncrCount[sei]; v ¬ [symbol[index:sei]]};      ENDLOOP;    RETURN};  }...
-- Copyright (C) 1981, 1983, 1986  by Xerox Corporation. All rights reserved. -- file Pass2.mesa; last modified by-- Satterthwaite,	October 11, 1982 8:40 am-- Donahue,		 9-Dec-81 12:03:59-- Sweet,		16-Aug-83 14:55:52-- Johnsson,		11-Jun-83 14:08:05-- Wagner		21-Aug-86  9:10:01DIRECTORY  Alloc USING [Bounds, Words],  ComData USING [    bodyIndex, catchIndex, defBodyLimit, idLOCK, importCtx, interface, mainCtx,    moduleCtx, monitored, nBodies, nInnerBodies, nSigCodes, ownSymbols, table, textIndex],  CompilerUtil USING [],  CLog USING [Error, ErrorHti],  LiteralOps USING [MasterString, StringReference],  Symbols USING [    BodyLink, BodyRecord, ContextLevel, SERecord, TransferMode,    HTIndex, SEIndex, CSEIndex, ISEIndex, RecordSEIndex,    CTXIndex, BTIndex, CBTIndex, CCBTIndex,    HTNull,  SENull,  CSENull,  ISENull,  RecordSENull,    CTXNull,  BTNull,  CBTNull,    lG, lL, lZ, RootBti, typeANY, typeTYPE, bodyType],  SymbolOps USING [    BlockLevel, FillCtxSe, FirstCtxSe, FromCard, FromTreeIndex, NewCtx,     MakeNonCtxSe, MakeSeChain,    NameClash, NextLevel, NextSe, SetMainCtx, StaticNestError],  SymbolTable USING [Handle],  Tree USING [Index, Link, NodeName, Null, NullIndex],  TreeOps USING [    DecodeBti, DecodeCard, EncodeBti, EncodeCard, EncodeSei, FreeNode, GetNode,     ListHead, ListLength, Map, NthSon, OpName, Scan, ScanList, UpdateList];Pass2: PROGRAM    IMPORTS      Alloc, Log: CLog, LiteralOps, SymbolOps, TreeOps,      dataPtr: ComData    EXPORTS CompilerUtil = {  OPEN TreeOps, SymbolOps, Symbols;  syms: SymbolTable.Handle ¬ NIL;    ContextInfo: TYPE = RECORD [    ctx: CTXIndex,    staticLevel: ContextLevel,    seChain: ISEIndex];  current: ContextInfo;  NewContext: PROC [level: ContextLevel, entries: NAT, unique: BOOLEAN] = {    OPEN c: current;    c.staticLevel ¬ level;    IF entries = 0 AND ~unique THEN {c.ctx ¬ CTXNull; c.seChain ¬ ISENull}    ELSE {      c.ctx ¬ NewCtx[syms, level];      syms.ctxb[c.ctx].seList ¬ c.seChain ¬ MakeSeChain[syms, c.ctx, entries, level=lG]}}; -- main driver  P2Unit: PUBLIC PROC [h: SymbolTable.Handle, t: Tree.Link] RETURNS [Tree.Link] = {    node: Tree.Index;        syms ¬ dataPtr.ownSymbols;    node ¬ GetNode[syms, t];      BEGIN      ENABLE {	-- default error reporting	NameClash => {Log.ErrorHti[duplicateId, hti]; RESUME};	StaticNestError => {Log.Error[staticNesting]; RESUME}};      dataPtr.textIndex ¬ DecodeCard[syms.tb[node].info];      dataPtr.bodyIndex ¬ CBTNull;      dataPtr.nBodies ¬ dataPtr.nInnerBodies ¬ dataPtr.nSigCodes ¬ 0;      dataPtr.catchIndex ¬ 0;      btLink ¬ [which:parent, index:BTNull];  catchParent ¬ ISENull;      NewContext[	level: lZ,	entries: ListLength[syms, syms.tb[node].son[1]] + CountIds[syms.tb[node].son[6]],	unique: FALSE];      dataPtr.moduleCtx ¬ current.ctx;      ScanList[syms, syms.tb[node].son[1], IdItem];      ImportList[syms.tb[node].son[2]];      -- process LOCKS clause	dataPtr.monitored ¬ syms.tb[node].son[5] # Tree.Null;	lockLambda ¬ Lambda[syms.tb[node].son[5], lL];      MainBody[syms.tb[node].son[6]];      dataPtr.defBodyLimit ¬ (dataPtr.table).Bounds[bodyType].size;      END;    syms ¬ NIL;    RETURN [t]};  ImportList: PROC [t: Tree.Link] = {    saved: ContextInfo = current;    NewContext[lG, ListLength[syms, t], FALSE];    dataPtr.importCtx ¬ current.ctx;    ScanList[syms, t, IdItem];    current ¬ saved};  MainBody: PROC [t: Tree.Link] = INLINE {    dataPtr.interface ¬ (OpName[syms, NthSon[syms, t, 2]] = definitionTC);    DeclList[t];    BodyList[RootBti]}; -- monitor lock processing  lockLambda: Tree.Index;  Lambda: PROC [item: Tree.Link, level: ContextLevel] RETURNS [node: Tree.Index] = {    node ¬ GetNode[syms, item];    IF node # Tree.NullIndex THEN {      saved: ContextInfo = current;      NewContext[level, CountIds[syms.tb[node].son[1]], FALSE];      syms.tb[node].info ¬ LOOPHOLE[current.ctx];      DeclList[syms.tb[node].son[1]];  Exp[syms, syms.tb[node].son[2]];      current ¬ saved};    RETURN};  ImplicitLock: PROC = {    sei: ISEIndex = current.seChain;    syms.tb[lockLambda].son[2] ¬ Ids[	list: syms.tb[lockLambda].son[2],	public: syms.tb[lockLambda].attr2,	link: Tree.NullIndex];    syms.seb[sei].idType ¬ dataPtr.idLOCK;     syms.seb[sei].idInfo ¬ FromCard[1]; syms.seb[sei].mark3 ¬ TRUE}; -- body processing  btLink: BodyLink;  catchParent: ISEIndex;  AllocateBody: PROC [node: Tree.Index, id: ISEIndex] RETURNS [bti: CBTIndex] = {    -- queue body for later processing    -- force nesting message here    SELECT NextLevel[syms, current.staticLevel] FROM      lG, lL => {	bti ¬ (dataPtr.table).Words[bodyType, SIZE[Outer Callable BodyRecord]];	syms.bb[bti] ¬ [,,,,,,, Callable[,,,,,,,,,,Outer[]]]};      ENDCASE => {	bti ¬ (dataPtr.table).Words[bodyType, SIZE[Inner Callable BodyRecord]];	syms.bb[bti] ¬ [,,,,,,, Callable[,,,,,,,,,, Inner[frameOffset: ]]]};    syms.bb[bti].firstSon ¬ BTNull;    syms.bb[bti].sourceIndex ¬ dataPtr.textIndex;    syms.bb[bti].info ¬ [Internal[bodyTree:node, thread:Tree.NullIndex, frameSize: ]];    syms.bb[bti].id ¬ id;    syms.bb[bti].entry ¬ syms.bb[bti].internal ¬ FALSE;    -- conservative initial approximations      syms.bb[bti].ioType ¬ typeANY;      syms.bb[bti].noXfers ¬ FALSE;      syms.bb[bti].hints ¬ [safe:FALSE, argUpdated:TRUE, nameSafe:FALSE, needsFixup:FALSE];    LinkBody[bti];  RETURN};  LinkBody: PROC [bti: BTIndex] = {    IF btLink.which = parent THEN {      syms.bb[bti].link ¬ btLink;      IF btLink.index # BTNull THEN syms.bb[btLink.index].firstSon ¬ bti			       ELSE IF bti # RootBti THEN ERROR}    ELSE {      syms.bb[bti].link ¬ syms.bb[btLink.index].link;      syms.bb[btLink.index].link ¬ [which:sibling, index: bti]}};  SetEntryAttr: PROC [t: Tree.Link, attr: Tree.NodeName] = {    IF OpName[syms, t] # body OR ~dataPtr.monitored THEN Log.Error[misplacedEntry]    ELSE {	-- see AllocateBody      node: Tree.Index = GetNode[syms, t];      bti: CBTIndex = DecodeBti[syms.tb[node].info];      SELECT attr FROM	entry => syms.bb[bti].entry ¬ TRUE;	internal => syms.bb[bti].internal ¬ TRUE;	ENDCASE}};  BodyList: PROC [firstBti: BTIndex] = {    FOR bti: BTIndex ¬ firstBti, syms.bb[bti].link.index UNTIL bti = BTNull DO      WITH syms.bb[bti] SELECT FROM	Callable => IF nesting # Catch THEN Body[LOOPHOLE[bti, CBTIndex]];	ENDCASE => NULL;      IF syms.bb[bti].link.which = parent THEN EXIT;      ENDLOOP};  Body: PROC [bti: CBTIndex] = {    node: Tree.Index = WITH syms.bb[bti].info SELECT FROM	Internal => bodyTree,	ENDCASE => ERROR;    level: ContextLevel;    nLocks: [0..1];    oldBodyIndex: CBTIndex = dataPtr.bodyIndex;    oldBtLink: BodyLink = btLink;    oldCatchParent: ISEIndex = catchParent;    saved: ContextInfo = current;    dataPtr.bodyIndex ¬ bti;    btLink ¬ [which:parent, index:bti];  catchParent ¬ syms.bb[bti].id;    level ¬ NextLevel[syms, saved.staticLevel ! StaticNestError => {RESUME}];    nLocks ¬ IF level = lG AND dataPtr.monitored AND syms.tb[lockLambda].attr1		THEN 1		ELSE 0;    NewContext[	level: level,	entries: nLocks + CountIds[syms.tb[node].son[2]],	unique: level = lG];    syms.bb[bti].localCtx ¬ current.ctx;  syms.bb[bti].level ¬ BlockLevel[level];    syms.bb[bti].monitored ¬ nLocks # 0;  syms.bb[bti].inline ¬ syms.tb[node].attr3;    syms.bb[bti].type ¬ IF current.ctx = CTXNull OR syms.bb[bti].inline      THEN RecordSENull      ELSE BodyType[current.ctx, syms.bb[bti].monitored];    IF level = lG THEN {      IF bti # RootBti THEN ERROR;      dataPtr.mainCtx ¬ current.ctx;  SetMainCtx[syms, current.ctx]};    ExpList[syms.tb[node].son[1]];    IF nLocks # 0 THEN ImplicitLock[];    DeclList[syms.tb[node].son[2]];    StmtList[syms.tb[node].son[3]];    BodyList[syms.bb[bti].firstSon];    current ¬ saved;  dataPtr.bodyIndex ¬ oldBodyIndex;    catchParent ¬ oldCatchParent;  btLink ¬ oldBtLink};  NewScope: PROC [node: Tree.Index, decls: Tree.Link] RETURNS [bti: BTIndex] = {    level: ContextLevel = BlockLevel[current.staticLevel];    NewContext[level:level, entries:CountIds[decls], unique:FALSE];    bti ¬ (dataPtr.table).Words[bodyType, SIZE[Other BodyRecord]];    syms.bb[bti] ¬ [	link: ,	firstSon: BTNull,	type: IF syms.bb[dataPtr.bodyIndex].inline		THEN RecordSENull ELSE BodyType[current.ctx, FALSE],	localCtx: current.ctx, level: level,	sourceIndex: DecodeCard[syms.tb[node].info],	info: [Internal[bodyTree:node, thread:Tree.NullIndex, frameSize: ]],	extension: Other[relOffset: ]];    LinkBody[bti];  btLink ¬ [which:parent, index:bti];    DeclList[decls]};  NewCatchScope: PROC [node: Tree.Index] RETURNS [bti: CCBTIndex] = {    -- force nesting message here    level: ContextLevel;    level ¬ NextLevel[syms, BlockLevel[current.staticLevel]];    NewContext[level:level, entries:0, unique:FALSE];    bti ¬ (dataPtr.table).Words[bodyType, SIZE[Catch Callable BodyRecord]];    syms.bb[bti] ¬ [	link: ,	firstSon: BTNull,	type: RecordSENull,	localCtx: CTXNull, level: level,	sourceIndex: DecodeCard[syms.tb[node].info],	info: [Internal[bodyTree:node, thread:Tree.NullIndex, frameSize: ]],	extension: Callable[	  inline: FALSE,	  id: catchParent,	  ioType: CSENull,	  monitored: FALSE, noXfers: FALSE, resident: FALSE,	  entry: FALSE, internal: FALSE,	  entryIndex: 0,	  hints: [FALSE, FALSE, FALSE, FALSE],	  closure: Catch[index: ]]];    LinkBody[bti];  btLink ¬ [which:parent, index:bti];      RETURN};  BodyType: PROC [ctx: CTXIndex, monitored: BOOLEAN] RETURNS [rSei: RecordSEIndex] = {    rSei ¬ LOOPHOLE[MakeNonCtxSe[syms, SIZE[notLinked record cons SERecord]]];    syms.seb[rSei].typeInfo ¬ record[	machineDep: FALSE, painted: TRUE, argument: FALSE,	hints: [	    unifield: FALSE, variant: FALSE,	    assignable: FALSE, comparable: FALSE, privateFields: TRUE,	    refField: FALSE, default: FALSE, voidable: FALSE],	length: 0,	fieldCtx: ctx,	monitored: monitored,	linkPart: notLinked[]];    RETURN};  CodeBody: PROC [node: Tree.Index] = {    InlineOp: TreeOps.Scan = {ExpList[t]};    ScanList[syms, syms.tb[node].son[1], InlineOp]}; -- declarations  DeclList: PROC [t: Tree.Link, linkId: SEIndex ¬ SENull] = {    DeclItem: TreeOps.Scan = {      node: Tree.Index = GetNode[syms, t];      saveIndex: CARDINAL = dataPtr.textIndex;      dataPtr.textIndex ¬ DecodeCard[syms.tb[node].info];      syms.tb[node].son[1] ¬ Ids[		list: syms.tb[node].son[1],		type: (syms.tb[node].name = typedecl),		public: syms.tb[node].attr2,		link: node];      syms.tb[node].attr2 ¬ syms.tb[node].attr3 ¬ FALSE;      SELECT syms.tb[node].name FROM	typedecl => {	  TypeExp[t:syms.tb[node].son[2], typeId:FirstId[syms.tb[node].son[1]], linkId:linkId];	  ExpList[syms.tb[node].son[3]]};	decl => {	  TypeExp[t:syms.tb[node].son[2], linkId:linkId];	  syms.tb[node].son[3] ¬ InitialValue[	    syms.tb[node].son[3], 	    IF syms.tb[node].attr1 THEN FirstId[syms.tb[node].son[1]] ELSE ISENull]};	ENDCASE => Log.Error[unimplemented];      dataPtr.textIndex ¬ saveIndex};    ScanList[syms, t, DeclItem]};  CountIds: PROC [declList: Tree.Link] RETURNS [n: NAT¬0] = {    NIds: TreeOps.Scan = {n ¬ n + ListLength[syms, NthSon[syms, t, 1]]};    ScanList[syms, declList, NIds];  RETURN};  InitialValue: PROC [t: Tree.Link, id: ISEIndex] RETURNS [v: Tree.Link] = {    v ¬ t;	-- the default    IF t # Tree.Null THEN      WITH t SELECT FROM	subtree => {	  node: Tree.Index = index;	  SELECT syms.tb[node].name FROM	    body => {	      bti: CBTIndex = AllocateBody[node, id];	      syms.tb[node].info ¬ EncodeBti[bti];	      IF ~syms.tb[node].attr3 THEN {		dataPtr.nBodies ¬ dataPtr.nBodies+1;		IF current.staticLevel >= lL THEN		  dataPtr.nInnerBodies ¬ dataPtr.nInnerBodies + 1};	      btLink ¬ [which:sibling, index:bti]};	    entry, internal => {	      v ¬ InitialValue[syms.tb[node].son[1], id];	      SetEntryAttr[v, syms.tb[node].name];	      syms.tb[node].son[1] ¬ Tree.Null;  FreeNode[syms, node]};	    signalinit => {	      syms.tb[node].info ¬ EncodeCard[dataPtr.nSigCodes];	      dataPtr.nSigCodes ¬ dataPtr.nSigCodes+1};	    inline => CodeBody[node];	    ENDCASE => ExpList[t]};	ENDCASE => ExpList[t]};  IdItem: TreeOps.Scan = {    node: Tree.Index = GetNode[syms, t];    saveIndex: CARDINAL = dataPtr.textIndex;    dataPtr.textIndex ¬ DecodeCard[syms.tb[node].info];    syms.tb[node].son[1] ¬ Ids[list: syms.tb[node].son[1], public: FALSE, link: node];    dataPtr.textIndex ¬ saveIndex}; -- id list manipulation  Ids: PROC [	list: Tree.Link,	public: BOOLEAN,	type: BOOLEAN ¬ FALSE,	link: Tree.Index]      RETURNS [Tree.Link] = {    Id: TreeOps.Map = {      WITH t SELECT FROM	hash, symbol => {	  hti: HTIndex = WITH t SELECT FROM				hash => index,				symbol => syms.seb[index].hash,				ENDCASE => ERROR;	  sei: ISEIndex = current.seChain;	  current.seChain ¬ NextSe[syms, current.seChain];	  FillCtxSe[syms, sei, hti, public];	  syms.seb[sei].idType ¬ IF type THEN typeTYPE ELSE typeANY;	  syms.seb[sei].public ¬ public;	  syms.seb[sei].immutable ¬ syms.seb[sei].constant ¬ FALSE;	  syms.seb[sei].idValue ¬ FromTreeIndex[link];  	  syms.seb[sei].idInfo ¬ FromCard[0];	  syms.seb[sei].extended ¬ syms.seb[sei].linkSpace ¬ FALSE;	  v ¬ [symbol[index: sei]]};	subtree => {	  node: Tree.Index = index;	  syms.tb[node].son[1] ¬ Id[syms, syms.tb[node].son[1]];  	  Position[syms.tb[node].son[2]];	  v ¬ t};	ENDCASE => ERROR;      RETURN};    RETURN [UpdateList[syms, list, Id]]};  FirstId: PROC [t: Tree.Link] RETURNS [ISEIndex] = {    head: Tree.Link = ListHead[syms, t];    RETURN [WITH head SELECT FROM      symbol => index,      subtree => FirstId[syms.tb[index].son[1]],      ENDCASE => ERROR]}; -- type manipulation  TypeExp: PROC [t: Tree.Link, typeId, linkId: SEIndex ¬ SENull] = {    sei: CSEIndex;    WITH t SELECT FROM      subtree => {	node: Tree.Index = index;	SELECT syms.tb[node].name FROM	  enumeratedTC => {	    sei ¬ MakeNonCtxSe[syms, SIZE[enumerated cons SERecord]];	    syms.seb[sei].typeInfo ¬ enumerated[		ordered: TRUE, sparse: FALSE,		machineDep: syms.tb[node].attr2,		unpainted: FALSE,		valueCtx: Enumeration[node], nValues: ];	    AssignValues[sei, IF typeId # SENull THEN typeId ELSE sei]};	  recordTC, monitoredTC => {	    tCtx: CTXIndex;	    nFields: NAT;	    sei ¬ MakeNonCtxSe[syms, SIZE[notLinked record cons SERecord]];	    [tCtx, nFields] ¬ FieldList[		t: syms.tb[node].son[1],		level: lZ,		typeId: IF typeId # SENull THEN typeId ELSE sei];	    syms.seb[sei].typeInfo ¬ record[		machineDep: syms.tb[node].attr1,		painted: TRUE,		argument: FALSE,		hints: [		  unifield: nFields = 1 AND ~syms.tb[node].attr2,		  variant: syms.tb[node].attr2,		  assignable: TRUE, comparable: FALSE, privateFields: FALSE,		  refField: FALSE, default: FALSE, voidable: TRUE],		length: ,		fieldCtx: tCtx,		monitored: syms.tb[node].name = monitoredTC,		linkPart: notLinked[]];	    IF syms.tb[node].name = monitoredTC AND syms.tb[node].attr1 THEN Log.Error[attrClash]};	  variantTC => {	    sei ¬ MakeNonCtxSe[syms, SIZE[linked record cons SERecord]];	    syms.seb[sei].typeInfo ¬ record[		machineDep: syms.tb[node].attr1,		painted: TRUE,		argument: FALSE,		hints: [		  unifield: FALSE,		  variant: syms.tb[node].attr2,		  assignable: TRUE, comparable: FALSE, privateFields: FALSE,		  refField: FALSE, default: FALSE, voidable: TRUE],		length: ,		fieldCtx: FieldList[t:syms.tb[node].son[1], level:lZ, typeId:typeId].ctx,		monitored: FALSE,		linkPart: linked[linkId]]};	  pointerTC => {	    sei ¬ MakeNonCtxSe[syms, SIZE[ref cons SERecord]];	    syms.seb[sei].typeInfo ¬ ref[		counted: FALSE,		var: FALSE,		ordered: syms.tb[node].attr1,		basing: syms.tb[node].attr2,		list: FALSE,		readOnly: syms.tb[node].attr3,		refType: ];	    TypeExp[syms.tb[node].son[1]]};	  varTC => {	    sei ¬ MakeNonCtxSe[syms, SIZE[ref cons SERecord]];	    syms.seb[sei].typeInfo ¬ ref[		counted: FALSE,		var: TRUE,		ordered: syms.tb[node].attr1,		basing: syms.tb[node].attr2,		list: FALSE,		readOnly: syms.tb[node].attr3,		refType: ];	    TypeExp[syms.tb[node].son[1]]};	  arrayTC => {	    sei ¬ MakeNonCtxSe[syms, SIZE[array cons SERecord]];	    syms.seb[sei].typeInfo ¬ array[		packed: syms.tb[node].attr3,		indexType: ,		componentType: ];	    OptTypeExp[syms.tb[node].son[1]];  TypeExp[syms.tb[node].son[2]]};	  arraydescTC => {	    sei ¬ MakeNonCtxSe[syms, SIZE[arraydesc cons SERecord]];	    syms.seb[sei].typeInfo ¬ arraydesc[	      readOnly: syms.tb[node].attr3, var: FALSE, describedType: ];	    TypeExp[syms.tb[node].son[1]]};	  procTC, processTC, portTC, signalTC, errorTC, programTC => {	    modeMap: ARRAY Tree.NodeName[procTC..programTC] OF TransferMode = [	      procTC: proc, processTC: process, portTC: port,	      signalTC: signal, errorTC: error, programTC: program];	    sei ¬ MakeNonCtxSe[syms, SIZE[transfer cons SERecord]];	    syms.seb[sei].typeInfo ¬ transfer[	      mode: modeMap[syms.tb[node].name], safe: syms.tb[node].attr3,	      typeIn:  ArgList[syms.tb[node].son[1]],	      typeOut: ArgList[syms.tb[node].son[2]]]};	  definitionTC => { 	    sei ¬ MakeNonCtxSe[syms, SIZE[definition cons SERecord]];	    syms.seb[sei].typeInfo ¬ definition[named: FALSE, defCtx: ]};	  unionTC => sei ¬ Union[node, linkId];	  sequenceTC => sei ¬ Sequence[node];	  relativeTC => {	    sei ¬ MakeNonCtxSe[syms, SIZE[relative cons SERecord]];	    syms.seb[sei].typeInfo ¬ relative[baseType: , offsetType: , resultType: ];	    TypeExp[syms.tb[node].son[1]];  TypeExp[syms.tb[node].son[2]]};	  subrangeTC => {	    sei ¬ MakeNonCtxSe[syms, SIZE[subrange cons SERecord]];	    syms.seb[sei].typeInfo ¬ subrange[		filled: FALSE,  empty: FALSE,		rangeType: ,		origin: , range: ];	    TypeExp[syms.tb[node].son[1]];  Exp[syms, syms.tb[node].son[2]]};	  longTC => {	    sei ¬ MakeNonCtxSe[syms, SIZE[long cons SERecord]];	    syms.seb[sei].typeInfo ¬ long[rangeType: ];	    TypeExp[syms.tb[node].son[1]]};	  opaqueTC => {	    sei ¬ MakeNonCtxSe[syms, SIZE[opaque cons SERecord]];	    syms.seb[sei].typeInfo ¬ opaque[		lengthKnown: syms.tb[node].son[1] # Tree.Null,		length: 0,		id: WITH syms.seb[typeId] SELECT FROM			id => LOOPHOLE[typeId],			ENDCASE => ISENull];	    Exp[syms, syms.tb[node].son[1]]};	  zoneTC => {	    sei ¬ MakeNonCtxSe[syms, SIZE[zone cons SERecord]];	    syms.seb[sei].typeInfo ¬ 	      zone[counted: ~syms.tb[node].attr1, mds: syms.tb[node].attr2]};	  implicitTC, linkTC, frameTC => sei ¬ CSENull;	  dot, discrimTC => {TypeExp[syms.tb[node].son[1]]; sei ¬ CSENull};	  apply => {	    TypeExp[syms.tb[node].son[1]]; 	    Exp[syms, syms.tb[node].son[2]]; 	    sei ¬ CSENull};	  ENDCASE => {sei ¬ CSENull; Log.Error[nonTypeCons]};	syms.tb[node].info ¬ EncodeSei[sei]};      ENDCASE => NULL};  OptTypeExp: PROC [t: Tree.Link] = {IF t # Tree.Null THEN TypeExp[t]};  Enumeration: PROC [node: Tree.Index] RETURNS [ctx: CTXIndex] = {    saved: ContextInfo = current;    NewContext[lZ, ListLength[syms, syms.tb[node].son[1]], TRUE];  ctx ¬ current.ctx;    syms.tb[node].son[1] ¬ Ids[	list: syms.tb[node].son[1],	public: syms.tb[node].attr1,	link: Tree.NullIndex];    current ¬ saved;  RETURN};  AssignValues: PROC [type: CSEIndex, valueType: SEIndex] = {    WITH t: syms.seb[type] SELECT FROM      enumerated => {	i: CARDINAL ¬ 0;	FOR sei: ISEIndex ¬ FirstCtxSe[syms, t.valueCtx], NextSe[syms, sei] UNTIL sei = SENull DO	  syms.seb[sei].idType ¬ valueType;  syms.seb[sei].idInfo ¬ FromCard[0];	  syms.seb[sei].idValue ¬ FromCard[i];  i ¬ i+1;	  syms.seb[sei].immutable ¬ syms.seb[sei].constant ¬ TRUE;	  syms.seb[sei].mark3 ¬ syms.seb[sei].mark4 ¬ TRUE;	  ENDLOOP;	t.nValues ¬ i};      ENDCASE => ERROR};  FieldList: PROC [t: Tree.Link, level: ContextLevel, typeId: SEIndex]       RETURNS [ctx: CTXIndex, nFields: NAT] = {    saved: ContextInfo = current;    nFields ¬ CountIds[t];    NewContext[level, nFields, TRUE];  ctx ¬ current.ctx;     DeclList[t, typeId];    current ¬ saved;  RETURN};  ArgList: PROC [t: Tree.Link] RETURNS [sei: CSEIndex] = {    IF t = Tree.Null THEN sei ¬ RecordSENull    ELSE {      tCtx: CTXIndex;      nFields: NAT;      sei ¬ MakeNonCtxSe[syms, SIZE[notLinked record cons SERecord]];      [tCtx, nFields] ¬ FieldList[t, lZ, sei];      syms.seb[sei].typeInfo ¬ record[		machineDep: FALSE,		painted: FALSE,		argument: TRUE,		hints: [		  unifield: nFields = 1,		  variant: FALSE,		  assignable: TRUE, comparable: FALSE, privateFields: FALSE,		  refField: FALSE, default: FALSE, voidable: TRUE],		length: ,		fieldCtx: tCtx,		monitored: FALSE,		linkPart: notLinked[]]};    RETURN};  TagField: PROC [t: Tree.Link, MakeTagType: PROC RETURNS [CSEIndex]]        RETURNS [tagId: ISEIndex] = {    saved: ContextInfo = current;    node: Tree.Index;    current.ctx ¬ CTXNull;  current.seChain ¬ MakeSeChain[syms, CTXNull, 1, FALSE];    DeclList[t];    node ¬ GetNode[syms, t];    tagId ¬ FirstId[syms.tb[node].son[1]];    IF OpName[syms, syms.tb[node].son[2]] = implicitTC THEN {      subNode: Tree.Index = GetNode[syms, syms.tb[node].son[2]];      IF MakeTagType # NIL THEN syms.tb[subNode].info ¬ EncodeSei[MakeTagType[]]      ELSE {Log.Error[attrClash]; syms.tb[subNode].info ¬ EncodeSei[typeANY]}};    current ¬ saved;  RETURN};  Union: PROC [node: Tree.Index, linkId: SEIndex] RETURNS [sei: CSEIndex] = {    saved: ContextInfo = current;    MakeTagType: PROC RETURNS [type: CSEIndex] = {      saved: ContextInfo = current;      CollectTags: TreeOps.Scan = {	node: Tree.Index = GetNode[syms, t];	syms.tb[node].son[1] ¬ Ids[		list: syms.tb[node].son[1],		public: syms.tb[node].attr2,		link: Tree.NullIndex	    ! NameClash => {RESUME}]};      NewContext[lZ, CountIds[syms.tb[node].son[2]], TRUE];      type ¬ MakeNonCtxSe[syms, SIZE[enumerated cons SERecord]];      syms.seb[type].typeInfo ¬ enumerated[		ordered: FALSE, sparse: FALSE,		machineDep: FALSE,		unpainted: FALSE,		valueCtx: current.ctx, nValues: ];      ScanList[syms, syms.tb[node].son[2], CollectTags];      AssignValues[type, type];      current ¬ saved;  RETURN};    tagId: ISEIndex = TagField[syms.tb[node].son[1], MakeTagType];    NewContext[lZ, CountIds[syms.tb[node].son[2]], TRUE];    DeclList[syms.tb[node].son[2], linkId      ! NameClash => {Log.ErrorHti[duplicateTag, hti]; RESUME}];    sei ¬ MakeNonCtxSe[syms, SIZE[union cons SERecord]];    syms.seb[sei].typeInfo ¬ union[		caseCtx: current.ctx,		machineDep: syms.tb[node].attr1,		overlaid: syms.tb[node].attr2,		controlled: syms.seb[tagId].hash # HTNull,		tagSei: tagId,		hints: [		  equalLengths: FALSE,		  refField: FALSE, default: FALSE, voidable: TRUE]];    current ¬ saved;  RETURN};  Sequence: PROC [node: Tree.Index] RETURNS [sei: CSEIndex] = {    tagId: ISEIndex = TagField[syms.tb[node].son[1], NIL];    IF syms.tb[node].attr2 THEN Log.Error[attrClash];    TypeExp[syms.tb[node].son[2]];    sei ¬ MakeNonCtxSe[syms, SIZE[sequence cons SERecord]];    syms.seb[sei].typeInfo ¬ sequence[	packed: syms.tb[node].attr3,	controlled: syms.seb[tagId].hash # HTNull,	machineDep: syms.tb[node].attr1,	tagSei: tagId,	componentType: ];    RETURN}; -- statements  Stmt: PROC [h: SymbolTable.Handle, t: Tree.Link] = {    node: Tree.Index;    saveIndex: CARDINAL = dataPtr.textIndex;    IF t = Tree.Null THEN RETURN;    WITH t SELECT FROM      subtree => {	node ¬ index;	dataPtr.textIndex ¬ DecodeCard[syms.tb[node].info];	SELECT syms.tb[node].name FROM	  assign => {Exp[syms, syms.tb[node].son[1]]; Exp[syms, syms.tb[node].son[2]]};	  extract => {ExpList[syms.tb[node].son[1]]; Exp[syms, syms.tb[node].son[2]]};	  apply => {	    Exp[syms, syms.tb[node].son[1]];  ExpList[syms.tb[node].son[2]];	    IF syms.tb[node].nSons > 2 THEN CatchPhrase[syms.tb[node].son[3]]};	  block => Block[node];	  if => {	    Exp[syms, syms.tb[node].son[1]]; 	    StmtList[syms.tb[node].son[2]]; 	    StmtList[syms.tb[node].son[3]]};	  case => {	    Exp[syms, syms.tb[node].son[1]]; 	    SelectionList[syms.tb[node].son[2], Stmt]; 	    Stmt[syms, syms.tb[node].son[3]]};	  bind => {	    Exp[syms, syms.tb[node].son[1]];  Exp[syms, syms.tb[node].son[2]];	    SelectionList[syms.tb[node].son[3], Stmt];	    Stmt[syms, syms.tb[node].son[4]]};	  do => DoStmt[node];	  return, resume => ExpList[syms.tb[node].son[1]];	  label => {StmtList[syms.tb[node].son[1]]; StmtList[syms.tb[node].son[2]]};	  goto, exit, loop, reject, continue, retry, syserror, stop, null => NULL;	  free => {	    Exp[syms, syms.tb[node].son[1]];  Exp[syms, syms.tb[node].son[2]];	    IF syms.tb[node].nSons > 3 THEN CatchPhrase[syms.tb[node].son[4]]};	  signal, error, xerror, start, restart,	  join, wait, notify, broadcast, dsk, lsk, xe, xf =>	    Exp[syms, syms.tb[node].son[1]];	  open => {ExpList[syms.tb[node].son[1]]; StmtList[syms.tb[node].son[2]]};	  enable => {CatchPhrase[syms.tb[node].son[1]]; StmtList[syms.tb[node].son[2]]};	  checked => Stmt[syms, syms.tb[node].son[1]];          list => ScanList[syms, t, Stmt];          item => Stmt[syms, syms.tb[node].son[2]];          ENDCASE => Log.Error[unimplemented]};      ENDCASE => NULL;    dataPtr.textIndex ¬ saveIndex};  StmtList: PROC [list: Tree.Link] = INLINE { Stmt[syms, list] };  Block: PROC [node: Tree.Index] = {    saved: ContextInfo = current;    bti: BTIndex = NewScope[node, syms.tb[node].son[1]];    syms.tb[node].info ¬ EncodeBti[bti];    StmtList[syms.tb[node].son[2]];    BodyList[syms.bb[bti].firstSon];    current ¬ saved;  btLink ¬ [which:sibling, index:bti]};  SelectionList: PROC [t: Tree.Link, selection: TreeOps.Scan] = {    Item: TreeOps.Scan = {      node: Tree.Index = GetNode[syms, t];      saveIndex: CARDINAL = dataPtr.textIndex;      dataPtr.textIndex ¬ DecodeCard[syms.tb[node].info];      IF OpName[syms, syms.tb[node].son[1]] # decl THEN {	ExpList[syms.tb[node].son[1]]; selection[syms, syms.tb[node].son[2]]}      ELSE {	saved: ContextInfo = current;	bti: BTIndex = NewScope[node, syms.tb[node].son[1]];	syms.tb[node].name ¬ ditem;  syms.tb[node].info ¬ EncodeBti[bti];  	syms.tb[node].attr3 ¬ FALSE;	selection[syms, syms.tb[node].son[2]];	current ¬ saved;  btLink ¬ [which:sibling, index:bti]};      dataPtr.textIndex ¬ saveIndex};    ScanList[syms, t, Item]};  DoStmt: PROC [node: Tree.Index] = {    OPEN syms.tb[node];    saved: ContextInfo = current;    bti: BTIndex ¬ BTNull;    IF syms.tb[node].son[1] # Tree.Null THEN {      subNode: Tree.Index = GetNode[syms, syms.tb[node].son[1]];      IF OpName[syms, syms.tb[subNode].son[1]] # decl THEN         Exp[syms, syms.tb[subNode].son[1]]      ELSE bti ¬ NewScope[node, syms.tb[subNode].son[1]];      syms.tb[subNode].info ¬ EncodeBti[bti];      SELECT syms.tb[subNode].name FROM	forseq => {	  Exp[syms, syms.tb[subNode].son[2]]; 	  Exp[syms, syms.tb[subNode].son[3]]};	upthru, downthru => Range[syms.tb[subNode].son[2]];	ENDCASE => ERROR};    Exp[syms, syms.tb[node].son[2]];    ExpList[syms.tb[node].son[3]];    StmtList[syms.tb[node].son[4]];     StmtList[syms.tb[node].son[5]];     StmtList[syms.tb[node].son[6]];    current ¬ saved;    IF bti # BTNull THEN btLink ¬ [which:sibling, index:bti]};  CatchPhrase: PROC [t: Tree.Link] = {    node: Tree.Index = GetNode[syms, t];    oldBodyIndex: CBTIndex = dataPtr.bodyIndex;    saved: ContextInfo = current;    bti: CCBTIndex;    dataPtr.bodyIndex ¬ bti ¬ NewCatchScope[node];    syms.tb[node].info ¬ EncodeBti[bti];    SelectionList[syms.tb[node].son[1], Stmt];      Stmt[syms, syms.tb[node].son[2]];    BodyList[syms.bb[bti].firstSon];    current ¬ saved;    dataPtr.bodyIndex ¬ oldBodyIndex;    btLink ¬ [which:sibling, index:bti]}; -- expressions  Exp: PROC [h: SymbolTable.Handle, t: Tree.Link] = {    IF t = Tree.Null THEN RETURN;    WITH t SELECT FROM      literal => WITH info SELECT FROM        string => 	  LiteralOps.StringReference[syms, LiteralOps.MasterString[syms, index]];	  ENDCASE;      subtree => {	node: Tree.Index = index;	SELECT syms.tb[node].name FROM	  apply => {	    Exp[syms, syms.tb[node].son[1]];  ExpList[syms.tb[node].son[2]];	    IF syms.tb[node].nSons > 2 THEN CatchPhrase[syms.tb[node].son[3]]};	  signalx, errorx, startx, fork, joinx,	  dot, uparrow, uminus, not, addr, create, cast =>	    Exp[syms, syms.tb[node].son[1]];	  plus, minus, times, div, mod,	  relE, relN, relL, relGE, relG, relLE, intOO, intOC, intCO, intCC,	  or, and, assignx => {	    Exp[syms, syms.tb[node].son[1]]; Exp[syms, syms.tb[node].son[2]]};	  in, notin => {Exp[syms, syms.tb[node].son[1]]; Range[syms.tb[node].son[2]]};	  ifx => {	    Exp[syms, syms.tb[node].son[1]]; 	    Exp[syms, syms.tb[node].son[2]]; 	    Exp[syms, syms.tb[node].son[3]]};	  casex => {	    Exp[syms, syms.tb[node].son[1]]; 	    SelectionList[syms.tb[node].son[2], Exp]; 	    Exp[syms, syms.tb[node].son[3]]};	  bindx => {	    Exp[syms, syms.tb[node].son[1]];  	    Exp[syms, syms.tb[node].son[2]];	    SelectionList[syms.tb[node].son[3], Exp];	    Exp[syms, syms.tb[node].son[4]]};	  extractx => {ExpList[syms.tb[node].son[1]]; Exp[syms, syms.tb[node].son[2]]};	  pred, succ, ord, lengthen, float, abs, min, max, base, length, all, val =>	    ExpList[syms.tb[node].son[1]];	  arraydesc => {	    SELECT ListLength[syms, syms.tb[node].son[1]] FROM	      1 => Exp[syms, syms.tb[node].son[1]];	      3 => {		subNode: Tree.Index = GetNode[syms, syms.tb[node].son[1]];		Exp[syms, syms.tb[subNode].son[1]];  Exp[syms, syms.tb[subNode].son[2]];		OptTypeExp[syms.tb[subNode].son[3]]};	      ENDCASE => ERROR};	  void, clit, atom, mwconst, syserrorx => NULL;	  llit => 	    IF current.staticLevel = Symbols.lG THEN 	      Exp[syms, syms.tb[node].son[1]];	  loophole => {Exp[syms, syms.tb[node].son[1]]; OptTypeExp[syms.tb[node].son[2]]};	  narrow, istype => {	    Exp[syms, syms.tb[node].son[1]]; OptTypeExp[syms.tb[node].son[2]];	    IF syms.tb[node].nSons > 2 THEN CatchPhrase[syms.tb[node].son[3]]};	  new => {	    Exp[syms, syms.tb[node].son[1]];	    TypeExp[syms.tb[node].son[2]];	    syms.tb[node].son[3] ¬ InitialValue[syms.tb[node].son[3], ISENull];	    IF syms.tb[node].nSons > 3 THEN CatchPhrase[syms.tb[node].son[4]]};	  first, last, typecode => TypeExp[syms.tb[node].son[1]];	  size => {TypeExp[syms.tb[node].son[1]]; Exp[syms, syms.tb[node].son[2]]};	  nil => OptTypeExp[syms.tb[node].son[1]];	  item => Exp[syms, syms.tb[node].son[2]];	  ENDCASE => Log.Error[unimplemented]};      ENDCASE => NULL};  ExpList: PROC [list: Tree.Link] = INLINE {ScanList[syms, list, Exp]};  Position: PROC [t: Tree.Link] = {    IF OpName[syms, t] = item THEN {      node: Tree.Index = GetNode[syms, t];      Exp[syms, syms.tb[node].son[1]];  Exp[syms, syms.tb[node].son[2]]}    ELSE Exp[syms, t]};  Range: PROC [t: Tree.Link] = {    node: Tree.Index;    WITH t SELECT FROM      subtree => {	node ¬ index;	SELECT syms.tb[node].name FROM	  subrangeTC => {TypeExp[syms.tb[node].son[1]]; Exp[syms, syms.tb[node].son[2]]};	  IN [intOO .. intCC] => Exp[syms, t];	  ENDCASE => TypeExp[t]};      ENDCASE => TypeExp[t]};  }.
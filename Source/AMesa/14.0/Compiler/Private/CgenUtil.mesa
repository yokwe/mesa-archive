-- Copyright (C) 1984, 1986  by Xerox Corporation. All rights reserved. -- CgenUtil.mesa, --    Sweet,		17-Apr-84 17:43:12--    Satterthwaite,	October 12, 1982 5:23 pm--    MEW		22-Aug-86  8:00:35--    NFS		13-Apr-87 10:47:39DIRECTORY  Alloc USING [FreeChunk, GetChunk, Handle, Notifier, Words],  Code USING [    CodeNotImplemented, codeptr, codeStart, enableLevel, enableList,    fileindex, stking, xtracting, xtractsei, ZEROlexeme],  CodeDefs USING [    BYTE, CCIndex, CCItem, CCNull, ChunkIndex, CodeCCIndex,     CodeChunkType, codeType, EINull, EnableIndex, EnableItem, JumpCCIndex,    JumpCCNull, JumpType, LabelCCIndex, LabelCCNull, Lexeme],  ComData USING [ownSymbols, switches, typeSTRING, zone],  FOpCodes USING [qJREL, qLI],  LiteralOps USING [DescriptorValue, Find, FindDescriptor, Value],  Literals USING [LitDescriptor],  OpTableDefs USING [InstLength],  P5 USING [NumberOfParams, P5Error, PushEffect],  P5U USING [],  PackageSymbols USING [ConstRecord, constType, WordIndex],  PrincOps USING [FrameVec, LocalOverhead],  Runtime USING [CallDebugger],  Stack USING [Also, Check],  SymbolOps USING [    FirstCtxSe, NextSe, NormalType, RecordRoot, ToBitAddr, ToCard, ToSei,     TypeRoot, UnderType, WordsForType],  Symbols USING [    Base, BitAddress, CCBTIndex, CSEIndex, ISEIndex, ISENull, lG,    RecordSEIndex, CTXIndex, SEIndex, SENull, typeANY, typeTYPE, WordLength],  SymbolTable USING [Handle],  Table USING [Base, Limit],  Tree USING [Index, Link, Null, NullIndex],  TreeOps USING [    DecodeCSei, DecodeSei, EncodeSei, PopTree, PushNode, PushTree,     Scan, ScanList, SetInfo];CgenUtil: PROGRAM    IMPORTS      Alloc, MPtr: ComData, CPtr: Code, LiteralOps, OpTableDefs,       P5, Runtime, Stack, SymbolOps, TreeOps    EXPORTS P5U =  BEGIN  OPEN SymbolOps, CodeDefs;    -- imported definitions  BYTE: TYPE = CodeDefs.BYTE;  BitAddress: TYPE = Symbols.BitAddress;  CSEIndex: TYPE = Symbols.CSEIndex;  ISEIndex: TYPE = Symbols.ISEIndex;  ISENull: ISEIndex = Symbols.ISENull;  RecordSEIndex: TYPE = Symbols.RecordSEIndex;  SEIndex: TYPE = Symbols.SEIndex;  SENull: SEIndex = Symbols.SENull;  WordLength: CARDINAL = Symbols.WordLength;  table: Alloc.Handle ¬ NIL;    syms: SymbolTable.Handle ¬ NIL;   cb: Symbols.Base;		-- code base (local copy)  cstb: Table.Base;		-- constant table base (local copy)  CgenUtilNotify: PUBLIC Alloc.Notifier =    BEGIN  -- called by allocator whenever table area is repacked    cb ¬ base[codeType];    cstb ¬ base[PackageSymbols.constType];    END;    AllocCodeCCItem: PUBLIC PROC [n: [0..3]] RETURNS [c: CodeCCIndex] =    BEGIN    c ¬ GetChunk[SIZE[code CCItem] + n];    cb[c] ¬ CCItem[      free: FALSE, flink: CCNull, blink: CCNull,      ccvalue: code[inst: 0, realinst: FALSE, isize: 0, fill: 0, parameters:]];    LinkCCItem[c];    RETURN    END;      BeginCatch: PUBLIC PROC RETURNS [first, cur: CCIndex] =    BEGIN    lbl: LabelCCIndex;    first ¬ CPtr.codeStart;    cur ¬ CPtr.codeptr;    lbl ¬ LabelAlloc[];    cb[lbl].catch ¬ TRUE;    CPtr.codeStart ¬ CPtr.codeptr ¬ lbl;    END;      BitsForOperand: PUBLIC PROC [t: Tree.Link] RETURNS [CARDINAL] =    BEGIN    RETURN [WITH t SELECT FROM      literal => WordLength,	-- not always TRUE, but good enough      ENDCASE => BitsForType[OperandType[t]]]    END;  BitsForType: PUBLIC PROC [sei: SEIndex] RETURNS [CARDINAL] =    BEGIN    csei: CSEIndex = UnderType[syms, sei];    RETURN [WITH syms.seb[csei] SELECT FROM      record => length,      ENDCASE => CARDINAL[WordsForType[syms, csei]*WordLength]]    END;  CCellAlloc: PUBLIC PROC [t: CodeChunkType] =    BEGIN -- allocates a cell for other than code or label    c: CCIndex;    nwords: CARDINAL;    SELECT t FROM      code => P5.P5Error[262];      label => P5.P5Error[263];      jump => nwords ¬ SIZE[jump CCItem];      other => nwords ¬ SIZE[other CCItem];      ENDCASE;    c ¬ GetChunk[nwords];    SELECT t FROM      jump => cb[c] ¬ CCItem[free: FALSE, flink: , blink: , ccvalue: jump[, , , , , , , ]];      other => cb[c] ¬ CCItem[free: FALSE, flink: , blink: , ccvalue: other[obody: ]];      ENDCASE;    LinkCCItem[c];    END;  CgenUtilInit: PUBLIC PROC [ownTable: Alloc.Handle] =    BEGIN    table ¬ ownTable;    syms ¬ MPtr.ownSymbols;    CPtr.ZEROlexeme ¬ Lexeme[literal[word[LiteralOps.Find[syms, 0]]]];    CPtr.fileindex ¬ 0;    IF GetChunk[2] # CCNull THEN ERROR;    END;  ComputeFrameSize: PUBLIC PROC [fs: CARDINAL] RETURNS [CARDINAL] =    BEGIN -- finds alloc-vector index for frame of size fs    OPEN PrincOps;    fs ¬ fs + SIZE[PrincOps.LocalOverhead];    FOR fx: CARDINAL IN [0..LENGTH[FrameVec]) DO      IF fs <= FrameVec[fx] THEN RETURN [fx] ENDLOOP;    ERROR    END;  CreateLabel: PUBLIC PROC RETURNS [c: LabelCCIndex] =    BEGIN -- allocates and inserts a label at codeptr    c ¬ LabelAlloc[];    InsertLabel[c];    END;  DeleteCell: PUBLIC PROC [c: CCIndex] =    BEGIN -- deletes cell from code stream    nwords: CARDINAL;    IF cb[c].blink # CCNull THEN cb[cb[c].blink].flink ¬ cb[c].flink;    IF cb[c].flink # CCNull THEN cb[cb[c].flink].blink ¬ cb[c].blink;    nwords ¬ WITH cc: cb[c] SELECT FROM      code => ParamCount[LOOPHOLE[c]] + SIZE[code CCItem],      label => SIZE[label CCItem],      jump => SIZE[jump CCItem],      other => SIZE[other CCItem],      ENDCASE => ERROR;    FreeChunk[c, nwords];    END;      EndCatch: PUBLIC PROC [oldfirst, oldcur: CCIndex] =    BEGIN    cfirst: CCIndex = CPtr.codeStart;    c: CCIndex ¬ oldcur;    CPtr.codeStart ¬ oldfirst;    CPtr.codeptr ¬ oldcur;    WHILE cb[c].flink # CCNull DO c ¬ cb[c].flink; ENDLOOP;    cb[cfirst].blink ¬ c;    cb[c].flink ¬ cfirst;    END;  EnumerateCaseArms: PUBLIC PROC [node: Tree.Index, action: TreeOps.Scan] =    BEGIN    ProcessItem: PROC [h: SymbolTable.Handle, t: Tree.Link] =      BEGIN      inode: Tree.Index;      WITH t SELECT FROM subtree => inode ¬ index; ENDCASE;      SELECT syms.tb[inode].name FROM	item, casetest => action[syms, syms.tb[inode].son[2]];	caseswitch => TreeOps.ScanList[syms, syms.tb[inode].son[3], ProcessItem];	ENDCASE;      END;    TreeOps.ScanList[syms, syms.tb[node].son[2], ProcessItem];    IF syms.tb[node].son[3] # Tree.Null THEN action[syms, syms.tb[node].son[3]];    END;  FieldAddress: PUBLIC PROC [h: SymbolTable.Handle, sei: ISEIndex]     RETURNS [BitAddress, CARDINAL] =      BEGIN      RETURN [ToBitAddr[syms.seb[sei].idValue], ToCard[syms.seb[sei].idInfo]]      END;  FreeChunk: PUBLIC PROC [i: CodeDefs.ChunkIndex, size: CARDINAL] =    BEGIN    FOR p: LONG POINTER TO MonitorRecord ¬ monList, p.next WHILE p # NIL DO      IF p.cell = i AND p.action = free THEN Runtime.CallDebugger["From FreeChunk"L];      ENDLOOP;    table.FreeChunk[LOOPHOLE[i], size, codeType];    END;  FullWordBits: PUBLIC PROC [bits: CARDINAL] RETURNS [CARDINAL] =    BEGIN    RETURN [((bits + WordLength - 1)/WordLength)*WordLength]    END;  GetChunk: PUBLIC PROC [size: CARDINAL] RETURNS [c: CodeDefs.ChunkIndex] =    BEGIN    c ¬ LOOPHOLE[table.GetChunk[size, CodeDefs.codeType]];    FOR p: LONG POINTER TO MonitorRecord ¬ monList, p.next WHILE p # NIL DO      IF p.cell = c AND p.action = allocate THEN Runtime.CallDebugger["From GetChunk"L];      ENDLOOP;    RETURN [c]    END;  InsertLabel: PUBLIC PROC [c: LabelCCIndex] = LinkCCItem;  LabelAlloc: PUBLIC PROC RETURNS [c: LabelCCIndex] =    BEGIN -- gets a chunk for a label but does not insert it in stream    c ¬ GetChunk[SIZE[label CCItem]];    cb[c] ¬ CCItem[      free: FALSE, flink: CCNull, blink: CCNull,      ccvalue: label[	offsetLoaded: FALSE,	labelinfo:	  generating[catch: FALSE, labelseen: FALSE, procEntry: FALSE,	    ei: EINull, jumplist: JumpCCNull]]];    RETURN    END;  LinkCCItem: PROC [c: CCIndex] =    BEGIN -- inserts a CCItem in list @ codeptr    IF CPtr.codeptr # CCNull THEN      BEGIN      cb[c].flink ¬ cb[CPtr.codeptr].flink;      IF cb[CPtr.codeptr].flink # CCNull THEN cb[cb[CPtr.codeptr].flink].blink ¬ c;      cb[CPtr.codeptr].flink ¬ c;      END    ELSE cb[c].flink ¬ CCNull;    cb[c].blink ¬ CPtr.codeptr;    CPtr.codeptr ¬ c;    END;  LongLiteralValue: PUBLIC PROC [t: Tree.Link] RETURNS [LONG UNSPECIFIED] = {    w: ARRAY [0..1] OF WORD;    desc: Literals.LitDescriptor = TreeLiteralDesc[t];    IF desc.length # 2 THEN ERROR;    w[0] ¬ syms.ltb[desc.offset][0];  w[1] ¬ syms.ltb[desc.offset][1];    RETURN [LOOPHOLE[w]]};  LongTreeAddress: PUBLIC PROC [t: Tree.Link] RETURNS [long: BOOLEAN ¬ FALSE] =    BEGIN    WITH t SELECT FROM      -- For MDS relief add check for global vars. (NFS)      symbol => {        ctxi: Symbols.CTXIndex = syms.seb[index].idCtx;        long ¬	  ~MPtr.switches['o] AND syms.ctxb[ctxi].level = Symbols.lG;};      subtree =>	BEGIN	node: Tree.Index = index;	IF node # Tree.NullIndex THEN	  SELECT syms.tb[node].name FROM	    loophole, cast, openx, pad, chop =>	      long ¬ LongTreeAddress[syms.tb[node].son[1]];	    dot, uparrow, dindex, seqindex, dollar, index, new, reloc =>	      long ¬ syms.tb[node].attr2;	    assignx => WITH syms.tb[node].son[2] SELECT FROM	      subtree => IF syms.tb[index].name = mwconst THEN		  long ¬ LongTreeAddress[syms.tb[node].son[1]]		ELSE long ¬ LongTreeAddress[syms.tb[node].son[2]];	      ENDCASE => long ¬ LongTreeAddress[syms.tb[node].son[2]];	    ifx => long ¬ LongTreeAddress[syms.tb[node].son[2]] OR		LongTreeAddress[syms.tb[node].son[3]];	    casex =>	      BEGIN	      LongArm: PROC [h: SymbolTable.Handle, t: Tree.Link] = {	        long ¬ long OR LongTreeAddress[t]};	      EnumerateCaseArms[node, LongArm];	      END;	    ENDCASE => NULL;	END;      ENDCASE => NULL;    RETURN    END;  MakeLongTreeLiteral: PUBLIC PROC [d: DESCRIPTOR FOR ARRAY OF WORD, type: CSEIndex]      RETURNS [Tree.Link] =    BEGIN    TreeOps.PushTree[syms, [literal[[word[index: LiteralOps.FindDescriptor[syms, d]]]]]];    TreeOps.PushNode[syms, mwconst, 1];      TreeOps.SetInfo[syms, TreeOps.EncodeSei[type]];    RETURN [TreeOps.PopTree[syms]]    END;   MakeTreeLiteral: PUBLIC PROC [val: WORD] RETURNS [Tree.Link] =    BEGIN    RETURN [[literal[[word[index: LiteralOps.Find[syms, val]]]]]]    END;  MarkedType: PUBLIC PROC [type: SEIndex] RETURNS [CSEIndex] =    BEGIN    subType: CSEIndex = NormalType[syms, UnderType[syms, type]];    RETURN [WITH t: syms.seb[subType] SELECT FROM      ref => UnderType[syms, TypeRoot[syms, t.refType]],      transfer => subType,      ENDCASE => Symbols.typeANY]    END;   MonitorAction: TYPE = {allocate, free};  MonitorRecord: TYPE = RECORD [    next: LONG POINTER TO MonitorRecord, cell: CCIndex, action: MonitorAction];  monList: LONG POINTER TO MonitorRecord ¬ NIL;  Monitor: PROC [cell: CCIndex, action: MonitorAction] =    BEGIN    p: LONG POINTER TO MonitorRecord =      (MPtr.zone).NEW[MonitorRecord ¬ [monList, cell, action]];    monList ¬ p;    END;      NewEnableItem: PUBLIC PROC [bti: Symbols.CCBTIndex] RETURNS [et: EnableIndex] =    BEGIN -- don't bother to keep sorted, OutCode sorts them    IF CPtr.enableLevel = LENGTH[CPtr.enableList] THEN       ERROR CPtr.CodeNotImplemented;    et ¬ GetChunk[SIZE[EnableItem]];    cb[et] ¬ [      free: FALSE, next: CPtr.enableList[CPtr.enableLevel],       bti: bti, startPC:, bytes:];    CPtr.enableList[CPtr.enableLevel] ¬ et;    END;  NextVar: PUBLIC PROC [sei: ISEIndex] RETURNS [ISEIndex] =    BEGIN -- starting at sei returns first variable on ctx-list    RETURN [SELECT TRUE FROM      (sei = ISENull) => ISENull,      (syms.seb[sei].idType # Symbols.typeTYPE) => sei,      ENDCASE => NextVar[NextSe[syms, sei]]]    END;  OperandType: PUBLIC PROC [t: Tree.Link] RETURNS [sei: CSEIndex] =    BEGIN -- compute type of tree    RETURN [WITH e:t SELECT FROM      symbol => UnderType[syms, syms.seb[e.index].idType],      literal => IF e.info.litTag = string THEN MPtr.typeSTRING ELSE ERROR,      subtree =>	IF e = Tree.Null THEN	  IF CPtr.xtracting THEN UnderType[syms, syms.seb[CPtr.xtractsei].idType] ELSE ERROR	ELSE TreeOps.DecodeCSei[syms.tb[e.index].info],      ENDCASE => ERROR]    END;  Out0: PUBLIC PROC [i: BYTE] =    BEGIN -- outputs an parameter-less instruction    c: CodeCCIndex;    pushEffect: CARDINAL = P5.PushEffect[i];    IF CPtr.stking THEN Stack.Check[i];    IF P5.NumberOfParams[i] # 0 THEN P5.P5Error[257];    c ¬ AllocCodeCCItem[0];    cb[c].inst ¬ i;    END;  Out1: PUBLIC PROC [i: BYTE, p1: WORD] =    BEGIN -- outputs an one-parameter instruction    c: CodeCCIndex;    pushEffect: CARDINAL = P5.PushEffect[i];    IF CPtr.stking THEN {      Stack.Check[i]; IF i = FOpCodes.qLI THEN Stack.Also[[const[p1]]]};    IF P5.NumberOfParams[i] # 1 THEN P5.P5Error[258];    c ¬ AllocCodeCCItem[1];    cb[c].inst ¬ i;    cb[c].parameters[1] ¬ p1;    END;  Out2: PUBLIC PROC [i: BYTE, p1, p2: WORD] =    BEGIN -- outputs an two-parameter instruction    c: CodeCCIndex;    pushEffect: CARDINAL = P5.PushEffect[i];    IF CPtr.stking THEN Stack.Check[i];    IF P5.NumberOfParams[i] # 2 THEN P5.P5Error[259];    c ¬ AllocCodeCCItem[2];    cb[c].inst ¬ i;    cb[c].parameters[1] ¬ p1;    cb[c].parameters[2] ¬ p2;    END;  Out3: PUBLIC PROC [i: BYTE, p1, p2, p3: WORD] =    BEGIN -- outputs an three-parameter instruction    c: CodeCCIndex;    pushEffect: CARDINAL = P5.PushEffect[i];    IF CPtr.stking THEN Stack.Check[i];    IF P5.NumberOfParams[i] # 3 THEN P5.P5Error[260];    c ¬ AllocCodeCCItem[3];    cb[c].inst ¬ i;    cb[c].parameters[1] ¬ p1;    cb[c].parameters[2] ¬ p2;    cb[c].parameters[3] ¬ p3;    END;      OutEnableMark: PUBLIC PROC [index: EnableIndex, start: BOOLEAN] =    BEGIN    CCellAlloc[other];    cb[CPtr.codeptr].ccvalue ¬ other[markEnable[start: start, index: index]];    END;  OutJump: PUBLIC PROC [jt: JumpType, l: LabelCCIndex] =    BEGIN -- outputs a jump-type code ceel into the code stream    SELECT jt FROM      Jump, JumpA, JumpC, JumpCA, JumpRet, JumpLIO, JumpDESC => NULL;      ENDCASE => IF CPtr.stking THEN Stack.Check[FOpCodes.qJREL];    CCellAlloc[jump];    WITH cb[CPtr.codeptr] SELECT FROM      jump =>	BEGIN	fixedup ¬ FALSE;	completed ¬ FALSE;	jtype ¬ jt;	destlabel ¬ l;	IF l # LabelCCNull THEN	  BEGIN	  thread ¬ cb[l].jumplist;	  cb[l].jumplist ¬ LOOPHOLE[CPtr.codeptr, JumpCCIndex];	  END	ELSE thread ¬ JumpCCNull;	END;      ENDCASE    END;      OutLocalCall: PUBLIC PROC [target: LabelCCIndex] =    BEGIN    CCellAlloc[other];    cb[CPtr.codeptr].ccvalue ¬ other[localCall[target: target]];    cb[target].offsetLoaded ¬ TRUE;    END;  OutSource: PUBLIC PROC [index: CARDINAL] =    BEGIN    CCellAlloc[other];    cb[CPtr.codeptr].ccvalue ¬ other[source[index: index]];    END;  ParamCount: PUBLIC PROC [c: CodeCCIndex] RETURNS [CARDINAL] =    BEGIN    RETURN [SELECT TRUE FROM      (cb[c].isize # 0) => cb[c].isize-1,      cb[c].realinst => OpTableDefs.InstLength[cb[c].inst]-1,      ENDCASE => P5.NumberOfParams[cb[c].inst]]    END;  PrevVar: PUBLIC PROC [ssei, sei: ISEIndex] RETURNS [ISEIndex] =    BEGIN -- returns vars in reverse order as those returned by  nextvar    psei: ISEIndex ¬ NextVar[ssei];    rsei: ISEIndex;    IF psei = sei THEN RETURN [psei];    UNTIL psei = sei DO rsei ¬ psei; psei ¬ NextVar[NextSe[syms, psei]] ENDLOOP;    RETURN [rsei];    END;  PushLitVal: PUBLIC PROC [v: UNSPECIFIED] =    BEGIN -- forces a constant onto the stack    Out1[FOpCodes.qLI, v];    END;  RecordConstant: PUBLIC PROC [offset: PackageSymbols.WordIndex, length: CARDINAL] =    BEGIN OPEN PackageSymbols;    csti: Table.Base RELATIVE POINTER [0..Table.Limit) TO ConstRecord =       table.Words[constType, SIZE[ConstRecord]];    cstb[csti] ¬ [offset: offset, length: length];    END;  ReferentType: PUBLIC PROC [type: SEIndex] RETURNS [SEIndex] =    BEGIN    subType: CSEIndex = NormalType[syms, UnderType[syms, type]];    RETURN [WITH t: syms.seb[subType] SELECT FROM      ref => t.refType,      ENDCASE => Symbols.typeANY]    END;  TreeLiteral: PUBLIC PROC [t: Tree.Link] RETURNS [BOOLEAN] =    BEGIN    RETURN [WITH t SELECT FROM      literal => info.litTag = word,      subtree =>	SELECT syms.tb[index].name FROM	  cast => TreeLiteral[syms.tb[index].son[1]],	  mwconst => TRUE,	  ENDCASE => FALSE,      ENDCASE => FALSE]    END;  TreeLiteralDesc: PUBLIC PROC [t: Tree.Link] RETURNS [Literals.LitDescriptor] = {    WITH t SELECT FROM      literal =>	WITH info SELECT FROM	  word => RETURN [LiteralOps.DescriptorValue[syms, index]];	  ENDCASE;      subtree => {	node: Tree.Index = index;	SELECT syms.tb[node].name FROM	  mwconst, cast => RETURN [TreeLiteralDesc[syms.tb[node].son[1]]];	  ENDCASE};      ENDCASE;    ERROR};  TreeLiteralValue: PUBLIC PROC [t: Tree.Link] RETURNS [WORD] =    BEGIN    RETURN [WITH e:t SELECT FROM      literal =>	WITH e.info SELECT FROM	  word => LiteralOps.Value[syms, index],	  ENDCASE => ERROR,      subtree =>	SELECT syms.tb[e.index].name FROM	  cast, mwconst =>  TreeLiteralValue[syms.tb[e.index].son[1]],	  ENDCASE => ERROR,      ENDCASE => ERROR]    END;  TypeForTree: PUBLIC PROC [t: Tree.Link] RETURNS [SEIndex] =    BEGIN    RETURN [WITH t SELECT FROM      subtree => TreeOps.DecodeSei[syms.tb[index].info],      symbol => index,      ENDCASE => ERROR]    END;  UnMonitor: PROC [cell: CCIndex, action: MonitorAction] =    BEGIN    p, q: LONG POINTER TO MonitorRecord;    IF monList = NIL THEN RETURN;    IF monList.cell = cell AND monList.action = action THEN      {p ¬ monList.next; (MPtr.zone).FREE[@monList]; monList ¬ p};    FOR p ¬ monList, p.next UNTIL p.next = NIL DO      IF p.next.cell = cell AND p.next.action = action THEN {	q ¬ p.next.next; (MPtr.zone).FREE[@p.next]; p.next ¬ q; RETURN};      ENDLOOP;    END;  VariantTag: PUBLIC PROC [type: SEIndex, ctx: Symbols.CTXIndex] RETURNS [WORD] =    BEGIN    next: SEIndex;    FOR sei: SEIndex ¬ type, next UNTIL sei = SENull DO      WITH se: syms.seb[sei] SELECT FROM        id =>	  BEGIN	  IF se.idCtx = ctx THEN RETURN [LOOPHOLE[se.idValue]];	  next ¬ ToSei[se.idInfo];	  END;	ENDCASE => EXIT;      ENDLOOP;    ERROR    END;  WordAligned: PUBLIC PROC [tsei: RecordSEIndex] RETURNS [BOOLEAN] =    BEGIN -- sees if a word-aligned record (never TRUE for a variant record)    -- always true for an argument record    sei: ISEIndex;    wa: INTEGER ¬ 0;    a: BitAddress;    tsei ¬ RecordRoot[syms, tsei];    IF syms.seb[tsei].hints.variant THEN RETURN [FALSE];    IF syms.seb[tsei].argument THEN RETURN [TRUE];    sei ¬ NextVar[FirstCtxSe[syms, syms.seb[tsei].fieldCtx]];    UNTIL sei = ISENull DO      a ¬ ToBitAddr[syms.seb[sei].idValue];      IF a.bd # 0 THEN RETURN [FALSE];      IF a.wd < wa THEN RETURN [FALSE];      wa ¬ a.wd;      sei ¬ NextVar[NextSe[syms, sei]];      ENDLOOP;    RETURN [TRUE]    END;  WordsForOperand: PUBLIC PROC [t: Tree.Link] RETURNS [n: CARDINAL] =    BEGIN -- compute number of words for storing value of tree    WITH t SELECT FROM      literal => n ¬ 1; -- multiwords will be subtrees      symbol => n ¬ WordsForSei[syms.seb[index].idType];      subtree => n ¬ CARDINAL[WordsForType[syms, OperandType[t]]];      ENDCASE;    RETURN    END;  WordsForSei: PUBLIC PROC [sei: SEIndex] RETURNS [CARDINAL] =    BEGIN    RETURN [IF sei = SENull THEN 0       ELSE CARDINAL[WordsForType[syms, UnderType[syms, sei]]]]    END;  WordsForString: PUBLIC PROC [nChars: CARDINAL] RETURNS [CARDINAL] =    BEGIN  -- computed for the object machine    RETURN [(nChars+1)/2 + 2]    END;  END.
-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. -- file CodeDefs.mesa--   Sweet,		17-Apr-84 17:15:08--   Satterthwaite,	January 9, 1981  12:13 PM--   Wagner,		13-Jun-86 15:14:51DIRECTORY  Alloc USING [Notifier],  Literals: TYPE USING [LTIndex, LTNull, STIndex],  PrincOps: TYPE USING [MaxFrameSize, MaxParamsInStack],  Symbols: TYPE USING [    BTIndex, CCBTIndex, ContextLevel, HTIndex, ISEIndex, ISENull, lZ,     RecordSEIndex],  SymbolSegment USING [codeType],  Table: TYPE USING [Base, Limit, Selector];CodeDefs: DEFINITIONS =  BEGIN OPEN Symbols;    codeType: Table.Selector = SymbolSegment.codeType;    BYTE: TYPE = [0..256);  wordlength: CARDINAL = 16;    Lexeme: TYPE = RECORD [    lexvalue: SELECT lextag: * FROM      se => [lexsei: ISEIndex],      literal => [	SELECT littag: * FROM	  word => [lexlti: Literals.LTIndex],	  string => [lexsti: Literals.STIndex]	  ENDCASE],      bdo => [lexbdoi: VarIndex],      stack => [lexsti: StackIndex]      ENDCASE];  NullLex: se Lexeme = Lexeme[se[Symbols.ISENull]];  MoveDirection: TYPE = {load, store};  VarSpace: TYPE = {faddr, frame, frameup, caddr, code, link, linkup, stack, const, pdesc, sigdesc, lfaddr};    PDescPart: TYPE = {all, low, high};  -- indicates how much of a procedure descriptor a VarComponents represents  VarTag: TYPE = {o, bo, bdo, ind};    AddrOp: TYPE = {pad, lengthen};  VarComponent: TYPE = RECORD [    wSize: CARDINAL ¬ 0 | NULL,    bSize: [0..wordlength) ¬ 0 | NULL,    space: SELECT tag: VarSpace FROM      frame => [	immutable: BOOLEAN ¬ FALSE,	level: ContextLevel ¬ lZ,	wd: CARDINAL ¬ 0,	bd: [0..wordlength) ¬ 0],      code => [        bd: [0..wordlength) ¬ 0,        wd: CARDINAL ¬ 0,        lti: Literals.LTIndex ¬ Literals.LTNull],      faddr => [wd: CARDINAL, level: ContextLevel],      lfaddr => [wd: CARDINAL, level: ContextLevel, op: AddrOp],      frameup => [	level: ContextLevel ¬ lZ,        pwSize: [1..2] ¬ 1,	immutable: BOOLEAN ¬ FALSE,	wd: CARDINAL ¬ 0,	delta: [0..PrincOps.MaxFrameSize) ¬ 0],      caddr, link => [wd: CARDINAL],      linkup => [	wd: CARDINAL,	delta: [0..PrincOps.MaxFrameSize) ¬ 0],      stack => [	bd: [0..wordlength) ¬ 0,	wd: CARDINAL ¬ 0,	sti: StackIndex],      const => [bd: [0..wordlength) ¬ 0, d1, d2: UNSPECIFIED ¬ NULL],      pdesc => [ep: CARDINAL, part: PDescPart ¬ all],      sigdesc => [sig: CARDINAL],      ENDCASE];  VarItem: TYPE = RECORD [ -- not many around simultaneously    free: BOOLEAN ¬ FALSE, -- required by allocator    body: SELECT tag: VarTag FROM      o => [var: VarComponent],      bo => [offset, base: VarComponent],      bdo => [offset, base, disp: VarComponent],      ind => [        offset, base, index: VarComponent,	simple: BOOLEAN,        packinfo: SELECT packtag: * FROM          packed => [grain: [1..wordlength)],          notPacked => [eWords: [0..PrincOps.MaxFrameSize)]          ENDCASE]      ENDCASE];  VarIndex: TYPE = Table.Base RELATIVE POINTER [0..Table.Limit) TO VarItem;  OVarIndex: TYPE = Table.Base RELATIVE POINTER [0..Table.Limit)    TO o VarItem;  BoVarIndex: TYPE = Table.Base RELATIVE POINTER [0..Table.Limit)    TO bo VarItem;  BdoVarIndex: TYPE = Table.Base RELATIVE POINTER [0..Table.Limit)    TO bdo VarItem;  IndVarIndex: TYPE = Table.Base RELATIVE POINTER [0..Table.Limit)    TO ind VarItem;  VarNull: VarIndex = FIRST[VarIndex];  RelativePC: TYPE = [0..77777B];  CCInfoType: TYPE = {generating, binding, coding};  CodeChunkType: TYPE = {code, label, jump, other};  CCItem: TYPE = RECORD [    free: BOOLEAN,    flink, blink: CCIndex,    ccvalue: SELECT cctag: CodeChunkType FROM      code => [	realinst: BOOLEAN,	inst: BYTE,	isize: [0..7],	lco: BOOLEAN ¬ FALSE,	fill: [0..7],	parameters: ARRAY [1..1) OF WORD],      label => [	offsetLoaded: BOOLEAN,	labelinfo: SELECT OVERLAID CCInfoType FROM          generating => [	    labelseen: BOOLEAN, ei: EnableIndex, 	    catch, procEntry: BOOLEAN, jumplist: JumpCCIndex],          binding => [minPC, maxPC: RelativePC],          coding => [filltoword, pc: RelativePC],          ENDCASE],      jump => [	jsize: [0..7],	jtype: JumpType,	jparam: BYTE,	fixedup, completed: BOOLEAN,	destlabel: LabelCCIndex,	forward: BOOLEAN,	jumpinfo: SELECT OVERLAID CCInfoType FROM          generating => [ei: EnableIndex, thread: JumpCCIndex],          binding => [minPC, maxPC: RelativePC],          coding => [filltoword, pc: RelativePC]          ENDCASE],      other => [obody: SELECT otag: * FROM	table => [	  tableSize: [0..37777B],          btab: BOOLEAN,          taboffset: NATURAL],	markbody => [          start: BOOLEAN,          index: BTIndex],	markEnable => [          start: BOOLEAN,          index: EnableIndex],	source => [index: CARDINAL],	localCall => [	  target: LabelCCIndex],	ENDCASE]      ENDCASE];        TableCodeBytes: CARDINAL = 3; -- for JIB or JIW  RelFileIndex: TYPE = [0..37777b];  NULLfileindex: CARDINAL = LAST[CARDINAL];  CCIndex: TYPE = Table.Base RELATIVE POINTER [0..Table.Limit) TO CCItem;  CCNull: CCIndex = FIRST[CCIndex];  JumpCCIndex: TYPE = Table.Base RELATIVE POINTER [0..Table.Limit) TO jump CCItem;  JumpCCNull: JumpCCIndex = LOOPHOLE[CCNull];  LabelCCIndex: TYPE = Table.Base RELATIVE POINTER [0..Table.Limit) TO label CCItem;  LabelCCNull: LabelCCIndex = LOOPHOLE[CCNull];  CodeCCIndex: TYPE = Table.Base RELATIVE POINTER [0..Table.Limit) TO code CCItem;  CodeCCNull: CodeCCIndex = LOOPHOLE[CCNull];  OtherCCIndex: TYPE = Table.Base RELATIVE POINTER [0..Table.Limit) TO other CCItem;  TableCCIndex: TYPE = Table.Base RELATIVE POINTER [0..Table.Limit) TO table other CCItem;  TableCCNull: TableCCIndex = LOOPHOLE[CCNull];  CJItem: TYPE = RECORD [    inst: CCIndex,     variant: SELECT tag:* FROM      fallIn => [lc: LabelCCIndex],      jumpIn => [jc: JumpCCIndex]      ENDCASE];  EnableItem: TYPE = RECORD [    free: BOOLEAN,    next: EnableIndex,    bti: Symbols.CCBTIndex,    startPC, bytes: CARDINAL];  EnableIndex: TYPE = Table.Base RELATIVE POINTER [0..Table.Limit) TO EnableItem;  EINull: EnableIndex = FIRST[EnableIndex];  CompareClass: TYPE = {word, byte};  JumpType: TYPE = {	JumpE, JumpN, JumpL, JumpGE, JumpG, JumpLE,	UJumpL, UJumpGE, UJumpG, UJumpLE, ZJumpE, ZJumpN, 	Jump, JumpA, JumpEnable, JumpC, JumpCA, JumpRet,	BYTEJumpE, BYTEJumpN, JumpLIO, JumpDESC};  LabelInfoRecord: TYPE = RECORD [    free: BOOLEAN ¬ FALSE,    thread: LabelInfoIndex,    catchLevel: [0..37777B],    body: SELECT tag:* FROM      named => [hti: HTIndex, cci: LabelCCIndex],      loop => [exit, loop: LabelCCIndex],      stmt => [retry, continue: LabelCCIndex]      ENDCASE];  LabelInfoIndex: TYPE =     Table.Base RELATIVE POINTER [0..Table.Limit) TO LabelInfoRecord;  NamedLabelInfoIndex: TYPE =     Table.Base RELATIVE POINTER [0..Table.Limit) TO named LabelInfoRecord;  LabelInfoNull: LabelInfoIndex = FIRST[LabelInfoIndex];  StackIndex: TYPE = Table.Base RELATIVE POINTER [0..Table.Limit) TO StackItem;  DataStackIndex: TYPE = Table.Base RELATIVE POINTER [0..Table.Limit) TO data StackItem;  StackNull: StackIndex = FIRST[StackIndex];  StackItem: TYPE = RECORD [    free: BOOLEAN ¬ FALSE,    uplink, downlink: StackIndex ¬ StackNull,    info: SELECT tag:* FROM      mark => [label: LabelCCIndex],      data => [	loaded: BOOLEAN ¬ TRUE,	backup: StackBackup ¬ [none[]]],      ENDCASE];-- loaded = FALSE and backup = none is a NO-NO.  StackBackup: TYPE = RECORD [SELECT where: StackBackupLoc FROM    none => [],    frame => [tLevel: Symbols.ContextLevel, tOffset: TempAddr],--    link => [link: CARDINAL],    const => [value: CARDINAL],    faddr => [tLevel: Symbols.ContextLevel, tOffset: TempAddr],    ENDCASE];  StackBackupLoc: TYPE = {none, frame, link, const, faddr};  StackPos: TYPE = [0..16);  StackLocRec: TYPE = RECORD [SELECT tag:* FROM    onStack => [depth: CARDINAL],    stored => [],    contig => [place: StackBackup],    mixed => [],    ENDCASE];-- StackLocRec semantics:--  obtained by lr: StackLocRec ¬ Stack.Loc[s, count];----	Tag		Meaning----	onStack		The "count" words are all on the stack.--			  There are "depth" words above them in the model--	none		Not a legal case--	frame contig	The "count" words are in contiguous temporaries--	link contig	"count" = 1 and value is in link "link"--	const contig	"count" = 1 and value is "value"--	stored		The "count" words are recoverable, but not contiguous--	mixed		"loaded" are on stack others not  EvalStackSize: CARDINAL;  MaxParmsInStack: CARDINAL = PrincOps.MaxParamsInStack;  TempAddr: TYPE = [0..PrincOps.MaxFrameSize);  TempSize: TYPE = [0..PrincOps.MaxFrameSize);  TempStateRecord: TYPE = RECORD[    pendtemplist, templist, heaplist: ISEIndex,    tempctxlvl: ContextLevel,    firstTemp, tempstart, framesz: INTEGER];  CaseCVState: TYPE = {single, singleLoaded, multi, none};  StoreOptions: TYPE = RECORD [    expr: BOOLEAN ¬ FALSE,    init: BOOLEAN ¬ FALSE,    counted: BOOLEAN ¬ FALSE,    composite: BOOLEAN ¬ FALSE];  ConsDestination: TYPE = RECORD [    bd: [0..wordlength) ¬ NULL,    bSize: [0..wordlength) ¬ NULL,    inFrame: BOOLEAN ¬ FALSE, -- can store directly into frame    fLevel: Symbols.ContextLevel ¬ NULL,    pLength: [1..2] ¬ 1,    ignoreSafen: BOOLEAN ¬ FALSE,    fOffset: CARDINAL ¬ NULL, -- offset of first word of record    pLoaded: BOOLEAN ¬ FALSE, -- pointer already on virtual stack    pSti: StackIndex ¬ NULL, -- the sti of the pointer if pLoaded    pDelta: INTEGER ¬ 0, -- word offset into record of pointer    remaining: CARDINAL ¬ 0,    wSize: CARDINAL ¬ NULL,    options: StoreOptions ¬ [],    pGlobAddr: BOOLEAN ¬ FALSE,    pBackup: StackBackup ¬ [none[]]];  StatementStateRecord: TYPE = RECORD [    retLabel, comRetLabel: LabelCCIndex,    outRecord: RecordSEIndex,    pendtemplist: ISEIndex,    stkPtr: UNSPECIFIED,    inlineFileIndex: CARDINAL];  ChunkIndex: TYPE = Table.Base RELATIVE POINTER [0..Table.Limit);  AddressNotify, CallsNotify, CgenUtilNotify,  ConstructorNotify, CountingNotify, CrossJumpNotify, DJumpsNotify,  DriverNotify, ExpressionNotify, FinalNotify, FlowNotify,  FlowExpressionNotify, OutCodeNotify, PeepholeNotify, SelectionNotify,  StackImplNotify, StatementNotify, StoreNotify, TempNotify, VarBasicsNotify,  VarMoveNotify, VarUtilsNotify: Alloc.Notifier;  Address, AJumps, Calls, CgenUtil, Constructor, CrossJump, DJumps, Driver,  Expression, Final, Flow, FlowExpression, OpTable, OutCode, PeepholeQ, PeepholeU,  PeepholeZ, StackImpl, Statement, Store, Temp, VarBasics, VarMove, VarUtils:    PROGRAM;END.
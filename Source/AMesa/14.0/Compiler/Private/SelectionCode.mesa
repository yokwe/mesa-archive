-- Copyright (C) 1983, 1986  by Xerox Corporation. All rights reserved. -- SelectionCode.mesa--   Satterthwaite,	October 14, 1982 8:42 am--   Sweet,		18-Feb-83 20:17:29--   Johnsson,		14-Jun-83 18:04:12--   Wagner		22-Aug-86  8:05:19DIRECTORY  Alloc USING [Notifier],  Code USING [caseCVState, codeptr, mwCaseCV, xtracting],  CodeDefs USING [    CaseCVState, CCIndex, CCItem, codeType, JumpCCNull, LabelCCIndex, LabelCCNull,    Lexeme, NullLex, OtherCCIndex, VarComponent, VarIndex, VarNull],  ComData USING [ownSymbols, typeBOOL, zone],  FOpCodes USING [qDIS, qLP],  P5 USING [    All, CallCatch, Construct, EnterBlock, ExitBlock, Exp, FlowTree, GenAnonLex,     LogHeapFree, PurgePendTempList, PushLex, PushRhs, ReleaseTempLex, RowCons,    StatementTree, SysCall, VariantConstruct],  P5L USING [    ComponentForLex, CopyLex, CopyToTemp, EasilyLoadable, FieldOfVarOnly, LoadVar,    NormalizeExp, NormalLex, OVarItem, ReleaseLex, ReleaseVarItem, ReusableCopies,    TOSLex, VarForLex],  P5S USING [Assign],  P5U USING [    CCellAlloc, EnumerateCaseArms, FreeChunk, InsertLabel, LabelAlloc, MakeLongTreeLiteral,    MakeTreeLiteral, OperandType, Out0, OutJump, PushLitVal, ReferentType,    TreeLiteral, TreeLiteralValue, TypeForTree, VariantTag, WordsForOperand],  SDDefs USING [sNarrowFault],  Stack USING [    Decr, DeleteToMark, Dump, Incr, Mark, Off, On, Pop, ResetToMark, UnMark],  SymbolOps USING [    RCType, TypeLink, UnderType, VariantField, WordsForType],  Symbols USING [Base, BTIndex, CSEIndex, ISEIndex, ISENull, SEIndex],  SymbolTable USING [Handle],  Tree USING [Index, Link, NodeName, Null],  TreeOps USING [    DecodeBti, DecodeSei, EncodeSei, FreeTree, GetNode, GetSe,     ListLength, Map, OpName, PopTree, PushNode, PushSe, PushTree,    Scan, ScanList, SetAttr, SetInfo, SetShared, UpdateList];SelectionCode: PROGRAM    IMPORTS MPtr: ComData, CPtr: Code, P5U, P5L, P5, P5S,       Stack, SymbolOps, TreeOps     EXPORTS CodeDefs, P5, P5S =  BEGIN  OPEN CodeDefs;  -- imported definitions  SEIndex: TYPE = Symbols.SEIndex;  ISEIndex: TYPE = Symbols.ISEIndex;  ISENull: ISEIndex = Symbols.ISENull;  CSEIndex: TYPE = Symbols.CSEIndex;  BTIndex: TYPE = Symbols.BTIndex;  syms: SymbolTable.Handle ¬ NIL;  cb: Symbols.Base;		-- code base (local copy)  SelectionNotify: PUBLIC Alloc.Notifier =    BEGIN  -- called by allocator whenever table area is repacked    syms ¬ MPtr.ownSymbols;    cb ¬ base[codeType];    END;  CaseDriver: PROC [	node: Tree.Index,	isExp: BOOLEAN,	item: PROC [		  node: Tree.Index, isExp: BOOLEAN, tempSei: ISEIndex, failLabel: LabelCCIndex]		RETURNS [VarIndex, ISEIndex],	endCaseLabel: LabelCCIndex ¬ LabelCCNull]      RETURNS [lex: Lexeme] =    BEGIN    caseEndLabel: LabelCCIndex = P5U.LabelAlloc[];    caseLPEndLabel: LabelCCIndex = P5U.LabelAlloc[];    nWords: CARDINAL = IF isExp THEN       CARDINAL[SymbolOps.WordsForType[syms, TreeOps.DecodeSei[syms.tb[node].info]]]       ELSE 0;    longExpValue: BOOLEAN;    valTsei: ISEIndex ¬ ISENull;    allConst: BOOLEAN;    CheckConst: TreeOps.Scan = {allConst ¬ allConst AND P5U.TreeLiteral[t]};    CaseItem: TreeOps.Map =      BEGIN      failLabel: LabelCCIndex = P5U.LabelAlloc[];      long: BOOLEAN ¬ FALSE;      r: VarIndex;      [r, valTsei] ¬ item[TreeOps.GetNode[syms, t], isExp, valTsei, failLabel];      IF isExp THEN	BEGIN	[long: long, tsei: valTsei] ¬ P5L.NormalizeExp[r, valTsei, allConst];	Stack.ResetToMark[];	END;      P5U.OutJump[Jump, IF long THEN caseLPEndLabel ELSE caseEndLabel];      P5U.InsertLabel[failLabel];      RETURN [TreeOps.FreeTree[syms, t]]      END;    IF isExp THEN {allConst ¬ TRUE;  P5U.EnumerateCaseArms[node, CheckConst]}    ELSE P5.PurgePendTempList[];      BEGIN      ENABLE P5.LogHeapFree => {RESUME [FALSE, NullLex]};      syms.tb[node].son[2] ¬ TreeOps.FreeTree[syms, TreeOps.UpdateList[syms, syms.tb[node].son[2], CaseItem]];      IF CPtr.caseCVState = singleLoaded THEN P5U.Out0[FOpCodes.qDIS];      IF endCaseLabel # LabelCCNull THEN P5U.InsertLabel[endCaseLabel];      IF isExp THEN	BEGIN	r: VarIndex;	long: BOOLEAN;	[r, valTsei] ¬ CaseValue[syms.tb[node].son[3], valTsei];	long ¬ P5L.NormalizeExp[r, valTsei, allConst].long;	P5U.OutJump[Jump, IF long THEN caseLPEndLabel ELSE caseEndLabel];	Stack.DeleteToMark[];	END      ELSE syms.tb[node].son[3] ¬ P5.StatementTree[syms, syms.tb[node].son[3]];      END;    P5U.InsertLabel[caseEndLabel];    longExpValue ¬ cb[caseLPEndLabel].jumplist # JumpCCNull;    IF longExpValue THEN      {Stack.Off[]; P5U.Out0[FOpCodes.qLP]; Stack.On[]}; -- unreached if all arms long    P5U.InsertLabel[caseLPEndLabel];    IF valTsei # ISENull THEN P5.ReleaseTempLex[[se[valTsei]]];    IF isExp THEN      BEGIN      Stack.Incr[SELECT TRUE FROM	nWords <= 2 => nWords,	longExpValue => 2,	ENDCASE => 1];      lex ¬ P5L.NormalLex[nWords, longExpValue, allConst];      END    ELSE lex ¬ NullLex;    RETURN    END;  CaseValue: PROC [t: Tree.Link, oTsei: ISEIndex] RETURNS [r: VarIndex, tsei: ISEIndex] =    BEGIN    SetupTemp: PROC = {      IF tsei = ISENull THEN tsei ¬ P5.GenAnonLex[P5U.WordsForOperand[t]].lexsei};    tsei ¬ oTsei;    SELECT TreeOps.OpName[syms, t] FROM      construct => {        SetupTemp[];	P5.Construct[[symbol[tsei]], TreeOps.GetNode[syms, t], [init: TRUE]];	r ¬ P5L.VarForLex[[se[tsei]]]};      union => {        SetupTemp[];	P5.VariantConstruct[[symbol[tsei]], t, [init: TRUE]];	r ¬ P5L.VarForLex[[se[tsei]]]};      rowcons => {        SetupTemp[];	[] ¬ P5.RowCons[[symbol[tsei]], TreeOps.GetNode[syms, t], [init: TRUE]];	r ¬ P5L.VarForLex[[se[tsei]]]};      all => {        SetupTemp[];	[] ¬ P5.All[[symbol[tsei]], TreeOps.GetNode[syms, t], [init: TRUE]];	r ¬ P5L.VarForLex[[se[tsei]]]};      -- mergecons => ...      ENDCASE => r ¬ P5L.VarForLex[P5.Exp[t]];    END;  CaseStmtExp: PUBLIC PROC [rootNode: Tree.Index, isExp: BOOLEAN] RETURNS [lex: Lexeme] =    BEGIN -- generate code for CASE statment and expression    cvSize: CARDINAL = P5U.WordsForOperand[syms.tb[rootNode].son[1]];    saveMwCaseCV: Lexeme = CPtr.mwCaseCV;    saveExtracting: BOOLEAN = CPtr.xtracting;    saveCaseCVState: CaseCVState = CPtr.caseCVState;    cvTlex: se Lexeme ¬ NullLex;    cvr: VarIndex;    CPtr.xtracting ¬ FALSE;    IF isExp THEN Stack.Mark[];    cvr ¬ P5L.VarForLex[P5.Exp[syms.tb[rootNode].son[1]	    ! P5.LogHeapFree => {RESUME [FALSE, NullLex]}]];    IF cvSize = 1 THEN {P5L.LoadVar[cvr]; CPtr.caseCVState ¬ singleLoaded}    ELSE      BEGIN      cvTlex ¬ P5.GenAnonLex[cvSize];      CPtr.mwCaseCV ¬ [bdo[P5L.OVarItem[P5L.CopyToTemp[cvr, cvTlex.lexsei].var]]];      CPtr.caseCVState ¬ multi;      END;    lex ¬ CaseDriver[rootNode, isExp, CaseItem];    IF cvTlex # NullLex THEN {P5.ReleaseTempLex[cvTlex]; P5L.ReleaseLex[CPtr.mwCaseCV]};    CPtr.mwCaseCV ¬ saveMwCaseCV;    CPtr.caseCVState ¬ saveCaseCVState;    CPtr.xtracting ¬ saveExtracting;    syms.tb[rootNode].son[1] ¬ TreeOps.FreeTree[syms, syms.tb[rootNode].son[1]];    syms.tb[rootNode].son[2] ¬ TreeOps.FreeTree[syms, syms.tb[rootNode].son[2]];    syms.tb[rootNode].son[3] ¬ TreeOps.FreeTree[syms, syms.tb[rootNode].son[3]];    IF syms.tb[rootNode].nSons > 3 THEN TreeOps.SetShared[syms, syms.tb[rootNode].son[4], FALSE];    RETURN    END;  CaseItem: PROC [	node: Tree.Index, isExp: BOOLEAN, tempSei: ISEIndex, failLabel: LabelCCIndex]      RETURNS [r: VarIndex, tSei: ISEIndex] =    BEGIN -- generate code for a CASE item    IF syms.tb[node].name = caseswitch THEN [r, tSei] ¬ Branch[node, isExp, tempSei, failLabel]    ELSE      BEGIN      tSei ¬ tempSei;      CaseTest[syms.tb[node].son[1], failLabel];      IF isExp THEN [r, tempSei] ¬ CaseValue[syms.tb[node].son[2], tempSei]      ELSE {syms.tb[node].son[2] ¬ P5.StatementTree[syms, syms.tb[node].son[2]]; r ¬ VarNull};      END;    RETURN    END;  CaseTest: PUBLIC PROC [t: Tree.Link, failLabel: LabelCCIndex] =    BEGIN    n: CARDINAL = TreeOps.ListLength[syms, t];    IF n = 1 THEN P5.FlowTree[t, FALSE, failLabel]    ELSE      BEGIN      lastSon: CARDINAL = n-1;      thisSon: CARDINAL ¬ 0;      itemLabel: LabelCCIndex = P5U.LabelAlloc[];      Test: PROC [h: SymbolTable.Handle, t: Tree.Link] =	BEGIN	IF thisSon # lastSon THEN {P5.FlowTree[t, TRUE, itemLabel]; thisSon ¬ thisSon+1}	ELSE {P5.FlowTree[t, FALSE, failLabel]; P5U.InsertLabel[itemLabel]};	END;      TreeOps.ScanList[syms, t, Test];      END;    END;  BranchTable: TYPE = RECORD [SEQUENCE length: NAT OF LabelCCIndex];  NewBranches: PROC [	t: Tree.Link,	itemLabel, failLabel: LabelCCIndex,	bt: LONG POINTER TO BranchTable]      RETURNS [new: BOOLEAN] =    BEGIN -- sees if any new branches need to be added to branch table    AddEntry: PROC [h: SymbolTable.Handle, t: Tree.Link] =      BEGIN      i: CARDINAL = P5U.TreeLiteralValue[t];      IF bt[i] = failLabel THEN {bt[i] ¬ itemLabel; new ¬ TRUE};      END;    new ¬ FALSE;  TreeOps.ScanList[syms, t, AddEntry];    RETURN    END;  Branch: PROC [	node: Tree.Index, isExp: BOOLEAN, tempSei: ISEIndex, failLabel: LabelCCIndex]      RETURNS [r: VarIndex, tSei: ISEIndex] =    BEGIN -- generate code for case switch if range is densely packed    nWords, range, i: CARDINAL;    btcp, saveCodePtr: CCIndex;    valLabel, valLPLabel: LabelCCIndex;    bt: LONG POINTER TO BranchTable;    first: BOOLEAN ¬ TRUE;    allConst: BOOLEAN;    longExp: BOOLEAN;    LookForConst: TreeOps.Scan =      BEGIN -- t is a casetest node      WITH t SELECT FROM        subtree => allConst ¬ allConst AND P5U.TreeLiteral[syms.tb[index].son[2]];        ENDCASE => ERROR;      END;    CaseItem: TreeOps.Map =      BEGIN      itemLabel: LabelCCIndex;      WITH t SELECT FROM	subtree =>	  BEGIN -- is an item	  bNode: Tree.Index = index;	  long: BOOLEAN ¬ FALSE;	  itemLabel ¬ P5U.LabelAlloc[];	  IF NewBranches[syms.tb[bNode].son[1], itemLabel, failLabel, bt] THEN	    BEGIN	    P5U.InsertLabel[itemLabel];	    IF isExp THEN	      BEGIN	      tr: VarIndex;	      IF first THEN first ¬ FALSE ELSE Stack.ResetToMark[];	      [tr, tSei] ¬ CaseValue[syms.tb[bNode].son[2], tSei];	      [nwords: nWords, long: long, tsei: tSei] ¬ P5L.NormalizeExp[tr, tSei, allConst];	      END	    ELSE syms.tb[bNode].son[2] ¬ P5.StatementTree[syms, syms.tb[bNode].son[2]];	    P5U.OutJump[Jump, IF long THEN valLPLabel ELSE valLabel];	    END	  ELSE P5U.FreeChunk[itemLabel, SIZE[label CCItem]];	  END;	ENDCASE;      RETURN [TreeOps.FreeTree[syms, t]]      END;    tSei ¬ tempSei;    IF isExp THEN {allConst ¬ TRUE; TreeOps.ScanList[syms, syms.tb[node].son[3], LookForConst]};    range ¬ P5U.TreeLiteralValue[syms.tb[node].son[2]];    valLabel ¬ P5U.LabelAlloc[];    valLPLabel ¬ P5U.LabelAlloc[];    P5.PushRhs[syms, syms.tb[node].son[1]];    P5U.PushLitVal[range];    Stack.Decr[2];    P5U.CCellAlloc[other];    cb[LOOPHOLE[CPtr.codeptr, OtherCCIndex]].obody ¬ 	table[btab: , tableSize: range, taboffset: ];    btcp ¬ CPtr.codeptr;    P5U.OutJump[JumpCA, failLabel];    bt ¬ (MPtr.zone).NEW[BranchTable[range]];    FOR i IN [0..range) DO bt[i] ¬ failLabel ENDLOOP;    syms.tb[node].son[3] ¬ TreeOps.FreeTree[syms, TreeOps.UpdateList[syms, syms.tb[node].son[3], CaseItem]];    saveCodePtr ¬ CPtr.codeptr;    CPtr.codeptr ¬ btcp;    FOR i IN [0..range) DO P5U.OutJump[JumpC, bt[i]] ENDLOOP;    CPtr.codeptr ¬ saveCodePtr;    P5U.InsertLabel[valLabel];    longExp ¬ cb[valLPLabel].jumplist # JumpCCNull;    IF longExp THEN P5U.Out0[FOpCodes.qLP];    P5U.InsertLabel[valLPLabel];    (MPtr.zone).FREE[@bt];    IF isExp THEN RETURN [P5L.VarForLex[P5L.NormalLex[nWords, longExp, allConst]], tSei]    ELSE RETURN [VarNull, tSei];    END;  BindStmtExp: PUBLIC PROC [rootNode: Tree.Index, isExp: BOOLEAN] RETURNS [lex: Lexeme] =    BEGIN -- discrimination with copying    saveMwCaseCV: Lexeme = CPtr.mwCaseCV;    saveExtracting: BOOLEAN = CPtr.xtracting;    saveCaseCVState: CaseCVState = CPtr.caseCVState;    typeTemp: BOOLEAN ¬ FALSE;    typeLex: se Lexeme ¬ NullLex;    pushableTag: BOOLEAN ¬ FALSE;    nItems: CARDINAL ¬ 0;    sourceType: CSEIndex = P5U.OperandType[syms.tb[rootNode].son[1]];            BindItem: PROC [	  node: Tree.Index, isExp: BOOLEAN, tempSei: ISEIndex, failLabel: LabelCCIndex]	RETURNS [r: VarIndex, tSei: ISEIndex] =      BEGIN      bti: BTIndex = TreeOps.DecodeBti[syms.tb[node].info];      subNode: Tree.Index = TreeOps.GetNode[syms, syms.tb[node].son[1]];      type: SEIndex = syms.seb[TreeOps.GetSe[syms, syms.tb[subNode].son[1]]].idType;      indirect: BOOLEAN = syms.tb[node].attr1;      subType: SEIndex;      nItems ¬ nItems + 1;      tSei ¬ tempSei;      P5.EnterBlock[bti];      IF syms.tb[rootNode].attr2 THEN ERROR      ELSE subType ¬ IF indirect THEN P5U.ReferentType[sourceType] ELSE sourceType;      BEGIN      saveCVState: CaseCVState = CPtr.caseCVState;      CPtr.caseCVState ¬ multi;	-- the value being discriminated      IF syms.tb[node].attr3 THEN	pushableTag ¬ TestTag[	  type: subType,	  target: IF indirect THEN P5U.ReferentType[type] ELSE type,	  failLabel: failLabel,	  indirect: indirect,	  long: indirect AND SymbolOps.WordsForType[syms, sourceType] # 1,	  onStack: pushableTag];      P5S.Assign[subNode];      CPtr.caseCVState ¬ saveCVState;      END;      IF isExp THEN [r, tSei] ¬ CaseValue[syms.tb[node].son[2], tSei]      ELSE {syms.tb[node].son[2] ¬ P5.StatementTree[syms, syms.tb[node].son[2]];  r ¬ VarNull};      P5.ExitBlock[bti];      RETURN      END;    endCaseLabel: LabelCCIndex ¬ LabelCCNull;    CPtr.xtracting ¬ FALSE;    Stack.Dump[];    IF isExp THEN Stack.Mark[];    CPtr.mwCaseCV ¬ SelectArg[syms.tb[rootNode].son[1], syms.tb[rootNode].attr1];    SELECT TRUE FROM      syms.tb[rootNode].attr2 => ERROR;      syms.tb[rootNode].attr1 =>	BEGIN	t: Tree.Link ¬ NilPredicate[sourceType];	endCaseLabel ¬ P5U.LabelAlloc[];	CPtr.caseCVState ¬ multi;	P5.FlowTree[t, TRUE, endCaseLabel];  t ¬ TreeOps.FreeTree[syms, t];	END;      ENDCASE;    lex ¬ CaseDriver[rootNode, isExp, BindItem, endCaseLabel];    IF typeLex # NullLex THEN P5.ReleaseTempLex[typeLex];    P5L.ReleaseLex[CPtr.mwCaseCV];    CPtr.mwCaseCV ¬ saveMwCaseCV;  CPtr.caseCVState ¬ saveCaseCVState;    CPtr.xtracting ¬ saveExtracting;    RETURN    END;  SelectArg: PROC [t: Tree.Link, indirect: BOOLEAN] RETURNS [Lexeme] =    BEGIN    l: Lexeme;    r: VarIndex;    l ¬ P5.Exp[t ! P5.LogHeapFree => {RESUME [FALSE, NullLex]}];    IF indirect THEN r ¬ P5L.OVarItem[P5L.EasilyLoadable[P5L.ComponentForLex[l], load]]    ELSE      BEGIN      r1: VarIndex;      [first: r1, next: r] ¬ P5L.ReusableCopies[P5L.VarForLex[l], load, FALSE, TRUE];      P5L.ReleaseVarItem[r1];      END;    RETURN [[bdo[r]]]    END;      PushCopy: PROC [l: Lexeme] = {P5.PushLex[P5L.CopyLex[l]]};          TestTag: PROC [        type, target: SEIndex, failLabel: LabelCCIndex, indirect, long, onStack: BOOLEAN]      RETURNS [pushable: BOOLEAN] =    BEGIN  OPEN SymbolOps;    link: SEIndex = TypeLink[syms, target];    subLink: CSEIndex = SymbolOps.UnderType[syms, link];    uType: CSEIndex = SymbolOps.UnderType[syms, syms.seb[SymbolOps.VariantField[syms, subLink]].idType];    IF SymbolOps.UnderType[syms, type] # subLink THEN		-- discriminate to the link type      BEGIN      [] ¬ TestTag[type, link, failLabel, indirect, long, onStack];      onStack ¬ pushable ¬ FALSE;      END    ELSE pushable ¬ TRUE;		-- should force non-commutativity    WITH u: syms.seb[uType] SELECT FROM      union =>        BEGIN OPEN TreeOps;        saveCVState: CaseCVState = CPtr.caseCVState;	tagSei: ISEIndex = u.tagSei;	t: Tree.Link;	PushTree[syms, Tree.Null];	IF onStack THEN CPtr.caseCVState ¬ single	ELSE	-- CPtr.caseCVState = multi	  BEGIN	  IF indirect THEN {PushNode[syms, uparrow, 1]; SetAttr[syms, 1, FALSE]; SetAttr[syms, 2, long]}	  ELSE PushNode[syms, cast, 1];	  SetInfo[syms, EncodeSei[subLink]];	  PushSe[syms, tagSei];  PushNode[syms, dollar, 2];	  SetInfo[syms, EncodeSei[SymbolOps.UnderType[syms, syms.seb[tagSei].idType]]];  	  SetAttr[syms, 2, long];	  END;	PushTree[syms, P5U.MakeTreeLiteral[P5U.VariantTag[target, u.caseCtx]]];	PushNode[syms, relE, 2];  SetInfo[syms, EncodeSei[MPtr.typeBOOL]];	t ¬ PopTree[syms];  P5.FlowTree[t, FALSE, failLabel];  t ¬ FreeTree[syms, t];	CPtr.caseCVState ¬ saveCVState;	END;      ENDCASE => ERROR;    RETURN    END;  TagPredicate: PROC [type, target: SEIndex, indirect, long: BOOLEAN] RETURNS [Tree.Link] =    BEGIN OPEN SymbolOps, TreeOps;    link: SEIndex = TypeLink[syms, target];    subLink: CSEIndex = SymbolOps.UnderType[syms, link];    uType: CSEIndex = SymbolOps.UnderType[syms, syms.seb[SymbolOps.VariantField[syms, subLink]].idType];    WITH u: syms.seb[uType] SELECT FROM      union =>        BEGIN	tagSei: ISEIndex = u.tagSei;	PushTree[syms, Tree.Null];	IF indirect THEN {PushNode[syms, uparrow, 1]; SetAttr[syms, 1, FALSE]; SetAttr[syms, 2, long]}	ELSE PushNode[syms, cast, 1];	SetInfo[syms, EncodeSei[subLink]];	PushSe[syms, tagSei];  PushNode[syms, dollar, 2];	SetInfo[syms, EncodeSei[SymbolOps.UnderType[syms, syms.seb[tagSei].idType]]];  	SetAttr[syms, 2, long];	PushTree[syms, P5U.MakeTreeLiteral[P5U.VariantTag[target, u.caseCtx]]];	PushNode[syms, relE, 2];  SetInfo[syms, EncodeSei[MPtr.typeBOOL]];	END;      ENDCASE => ERROR;    IF SymbolOps.UnderType[syms, type] # subLink THEN		-- discriminate to the link type      BEGIN      PushTree[syms, TagPredicate[type, link, indirect, long]];  PushNode[syms, and, -2];      END;    RETURN [PopTree[syms]]    END;  TypePredicate: PROC [      source: CSEIndex, dest: SEIndex, node: Tree.Index] RETURNS [t: Tree.Link¬Tree.Null] =    BEGIN OPEN TreeOps;	-- attrs, son[1] as in narrow, istype    indirect: BOOLEAN = syms.tb[node].attr1;    long: BOOLEAN = indirect AND SymbolOps.WordsForType[syms, source] = 2;    type: SEIndex;    IF syms.tb[node].attr2 THEN ERROR    ELSE type ¬ IF indirect THEN P5U.ReferentType[source] ELSE source;    IF syms.tb[node].attr3 THEN      BEGIN      -- add NIL test here if not attr2?      PushTree[syms,         TagPredicate[type, IF indirect THEN P5U.ReferentType[dest] ELSE dest, indirect, long]];      IF t # Tree.Null THEN {PushTree[syms, t]; PushNode[syms, and, -2]};      t ¬ PopTree[syms];      END;    RETURN    END;      NilPredicate: PROC [type: CSEIndex] RETURNS [Tree.Link] =    BEGIN OPEN TreeOps;    PushTree[syms, Tree.Null];    SELECT SymbolOps.WordsForType[syms, type] FROM      1 => PushTree[syms, P5U.MakeTreeLiteral[0]];      2 =>	BEGIN	zeros: ARRAY [0..2) OF WORD ¬ [0, 0];	PushTree[syms, P5U.MakeLongTreeLiteral[DESCRIPTOR[zeros], type]];	END;      ENDCASE => ERROR;    PushNode[syms, relE, 2];  SetInfo[syms, EncodeSei[MPtr.typeBOOL]];    RETURN [PopTree[syms]]    END;      OrTest: PROC [t1, t2: Tree.Link] RETURNS [Tree.Link] =    BEGIN OPEN TreeOps;    PushTree[syms, t1];  PushTree[syms, t2];  PushNode[syms, or, 2];      SetInfo[syms, EncodeSei[MPtr.typeBOOL]];    RETURN [PopTree[syms]]    END;              NarrowExp: PUBLIC PROC [node: Tree.Index] RETURNS [l: Lexeme] =    BEGIN    saveMwCaseCV: Lexeme = CPtr.mwCaseCV;    saveExtracting: BOOLEAN = CPtr.xtracting;    saveCaseCVState: CaseCVState = CPtr.caseCVState;    eLabel: LabelCCIndex = P5U.LabelAlloc[];    indirect: BOOLEAN = syms.tb[node].attr1;    sourceType: CSEIndex = P5U.OperandType[syms.tb[node].son[1]];    targetType: SEIndex =      IF syms.tb[node].son[2] # Tree.Null THEN         P5U.TypeForTree[syms.tb[node].son[2]]       ELSE TreeOps.DecodeSei[syms.tb[node].info];    nWords: CARDINAL = CARDINAL[SymbolOps.WordsForType[syms, sourceType]];    counted: BOOLEAN = indirect AND (SymbolOps.RCType[syms, sourceType] = simple);    t: Tree.Link;    CPtr.xtracting ¬ FALSE;    Stack.Dump[];  Stack.Mark[];    t ¬ TypePredicate[sourceType, targetType, node];    IF indirect # syms.tb[node].attr2 THEN t ¬ OrTest[NilPredicate[sourceType], t];    CPtr.mwCaseCV ¬ SelectArg[syms.tb[node].son[1], indirect];  CPtr.caseCVState ¬ multi;    IF indirect THEN PushCopy[CPtr.mwCaseCV];    P5.FlowTree[t, TRUE, eLabel];  t ¬ TreeOps.FreeTree[syms, t];    IF indirect THEN      BEGIN      IF counted THEN ERROR      ELSE {	Stack.Pop[nWords]; -- throw away pointer on this arm of conditional	Stack.Mark[]; 	P5.SysCall[SDDefs.sNarrowFault]};      P5L.ReleaseLex[CPtr.mwCaseCV];      Stack.Incr[nWords]; -- the pointer is already there from PushCopy      l ¬ P5L.TOSLex[nWords];      END    ELSE      BEGIN      len: CARDINAL = CARDINAL[        SymbolOps.WordsForType[syms, SymbolOps.UnderType[syms, targetType]]];      Stack.Dump[]; Stack.Mark[];       P5.SysCall[SDDefs.sNarrowFault];      IF len = nWords THEN l ¬ CPtr.mwCaseCV      ELSE	-- simulate a chop        BEGIN	r: VarIndex = P5L.VarForLex[CPtr.mwCaseCV];	P5L.FieldOfVarOnly[r: r, wSize: len];	l ¬ [bdo[r]];	END;      END;    CPtr.mwCaseCV ¬ saveMwCaseCV;  CPtr.caseCVState ¬ saveCaseCVState;    CPtr.xtracting ¬ saveExtracting;    P5.CallCatch[IF syms.tb[node].nSons > 2 THEN syms.tb[node].son[3] ELSE Tree.Null];    P5U.InsertLabel[eLabel];    Stack.UnMark[];    RETURN    END;  TypeRel: PUBLIC PROC [node: Tree.Index, tf: BOOLEAN, label: LabelCCIndex]  =    BEGIN    saveMwCaseCV: Lexeme = CPtr.mwCaseCV;    saveExtracting: BOOLEAN = CPtr.xtracting;    saveCaseCVState: CaseCVState = CPtr.caseCVState;    sourceType: CSEIndex = P5U.OperandType[syms.tb[node].son[1]];    t: Tree.Link;    CPtr.xtracting ¬ FALSE;    Stack.Dump[];    t ¬ TypePredicate[sourceType, P5U.TypeForTree[syms.tb[node].son[2]], node];    IF syms.tb[node].attr1 OR syms.tb[node].attr2 THEN      t ¬ OrTest[NilPredicate[sourceType], t];    CPtr.mwCaseCV ¬ SelectArg[syms.tb[node].son[1], syms.tb[node].attr1];  CPtr.caseCVState ¬ multi;    P5.FlowTree[t, tf, label];  t ¬ TreeOps.FreeTree[syms, t];    P5L.ReleaseLex[CPtr.mwCaseCV];    CPtr.mwCaseCV ¬ saveMwCaseCV;  CPtr.caseCVState ¬ saveCaseCVState;    CPtr.xtracting ¬ saveExtracting;    END;  GetCanonicalType: PUBLIC PROC [node: Tree.Index] RETURNS [Lexeme] = {ERROR};  END.
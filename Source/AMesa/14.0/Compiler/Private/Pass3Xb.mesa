-- Copyright (C) 1981, 1983, 1986  by Xerox Corporation. All rights reserved. -- file Pass3Xb.mesa-- last modified by Satterthwaite, October 25, 1982 8:58 am-- last modified by Donahue,  9-Dec-81 15:32:12-- last modified by Sweet, 18-Jul-83 16:25:55-- MEW		19-Aug-86 11:31:38DIRECTORY  ComData USING [    bodyIndex, idCARDINAL, interface, switches,    typeBOOL, typeCHAR, typeINT, typeREAL, typeLONGSTRING, typeSTRING],  CLog USING [    Error, ErrorHti, ErrorN, ErrorNode, ErrorSei, ErrorTree, Warning],  Literals USING [STIndex],  LiteralOps USING [MasterString],  P3 USING [    Attr, emptyAttr, fullAttr, voidAttr,    NarrowOp, NPUse, BoundNP, MergeNP, SequenceNP, TextForm, phraseNP,    AddrOp, All, And, Apply, Assignment, BoolOp, Bundling, CanonicalType, Case,    CatchPhrase, Discrimination, Dot, EnterType, Extract,    Id, IdentifiedType, IndexType, MakeLongType, MakeRefType, MarkedType,    MiscXfer, Narrowing, NullableType, OperandInline, OrderedType,    Range, RecordMention, RStack, SealRefStack, SearchCtxList, TargetType,    TypeAppl, TypeExp, TypeForTree, Unbundle, UnsealRefStack,    BalancedRhs, GenericRhs, Rhs],  P3S USING [currentBody, ImplicitInfo, implicitRecord, safety, self],  Symbols USING [    ContextLevel, CTXIndex, HTIndex, lG, SEIndex, ISEIndex,    CSEIndex, RecordSEIndex, CSENull, RecordSENull, codeCHAR,     codeINT, typeANY],  SymbolOps USING [ConstantId, NormalType, RCType, TypeForm, UnderType],  SymbolTable USING [Handle],  Tree USING [Index, Link, Null, NullIndex],  TreeOps USING [    DecodeCSei, EncodeSei, FreeNode, GetHash, GetNode, ListLength, Map, PopTree,     PushTree, PushNode, SetInfo, UpdateList],  Types USING [Assignable, Equivalent];Pass3Xb: PROGRAM    IMPORTS      Log: CLog, LiteralOps, P3, P3S, SymbolOps, TreeOps, Types,      dataPtr: ComData    EXPORTS P3, P3S = {  OPEN SymbolOps, Symbols, TreeOps, P3;  zone: UNCOUNTED ZONE ¬ NIL;    syms: SymbolTable.Handle ¬ NIL;    Pass3XbInit: PUBLIC PROC [h: SymbolTable.Handle, scratchZone: UNCOUNTED ZONE] = {    zone ¬ scratchZone;    implicit ¬ [type: typeANY, tree: Tree.Null, attr: emptyAttr];    P3S.implicitRecord ¬ RecordSENull;    syms ¬ h;    longUnsigned ¬ CSENull;  textType ¬ ALL[CSENull];    rStack ¬ zone.NEW[RStack[32]];    rI ¬ -1};    ExpReset: PUBLIC PROC = {    IF rStack # NIL THEN zone.FREE[@rStack];    syms ¬ NIL;    zone ¬ NIL};   -- intermediate result bookkeeping  rStack: PUBLIC LONG POINTER TO RStack ¬ NIL;  rI: PUBLIC INTEGER;			-- index into rStack  RPush: PUBLIC PROC [type: CSEIndex, attr: Attr] = {    rI ¬ rI + 1;    WHILE rI >= rStack.length DO      newLength: NAT = rStack.length + 16;      newStack: LONG POINTER TO RStack = zone.NEW[RStack[newLength]];      FOR i: INTEGER IN [0 .. rI) DO newStack[i] ¬ rStack[i] ENDLOOP;      zone.FREE[@rStack];      rStack ¬ newStack;      ENDLOOP;    rStack[rI] ¬ [type:type, attr:attr]};  RPop: PUBLIC PROC = {IF rI < 0 THEN ERROR; rI ¬ rI-1};  RType: PUBLIC PROC RETURNS [CSEIndex] = {RETURN [rStack[rI].type]};  RAttr: PUBLIC PROC RETURNS [Attr] = {RETURN [rStack[rI].attr]};  longUnsigned: CSEIndex;	-- a hint for mwconst  textType: ARRAY TextForm OF CSEIndex;		-- a hint for text literals -- tree manipulation utilities  TypeForString: PROCEDURE [sti: Literals.STIndex] RETURNS [CSEIndex] = {    IF dataPtr.switches['o] THEN RETURN[dataPtr.typeSTRING]    ELSE IF P3S.currentBody.level = Symbols.lG THEN RETURN[dataPtr.typeLONGSTRING]    ELSE IF syms.stb[LiteralOps.MasterString[syms, sti]].info # 0 THEN 	RETURN[dataPtr.typeLONGSTRING];    RETURN[dataPtr.typeSTRING];    };  OperandType: PUBLIC PROC [t: Tree.Link] RETURNS [c: CSEIndex] = {    RETURN[ WITH e:t SELECT FROM      symbol => UnderType[syms, syms.seb[e.index].idType],      literal =>	WITH e.info SELECT FROM	  string => TypeForString[index],	  ENDCASE => dataPtr.typeINT,      subtree => DecodeCSei[syms.tb[e.index].info],      ENDCASE => CSENull]};  LongPath: PUBLIC PROC [t: Tree.Link] RETURNS [long: BOOLEAN] = {    WITH t SELECT FROM      subtree => {	node: Tree.Index = index;	long ¬ IF node = Tree.NullIndex	  THEN FALSE	  ELSE SELECT syms.tb[node].name FROM	    loophole, cast, openx, pad, chop => LongPath[syms.tb[node].son[1]],	    cdot => LongPath[syms.tb[node].son[2]],	    ENDCASE  -- dot, uparrow, dindex, reloc, seqindex, dollar, index -- =>	      syms.tb[node].attr2};      symbol => {        -- global identifier means long pointer	ctxi: Symbols.CTXIndex ¬ syms.seb[index].idCtx;	IF dataPtr.switches['o] THEN RETURN[FALSE];	long ¬ (syms.ctxb[ctxi].level = Symbols.lG) };      ENDCASE => long ¬ FALSE;    RETURN}; -- type manipulation  EqualTypes: PROC [type1, type2: CSEIndex] RETURNS [BOOLEAN] = {    RETURN [Types.Equivalent[[syms, type1], [syms, type2]]]};          UnresolvedTypes: SIGNAL RETURNS [CSEIndex] = CODE;  BalanceTypes: PROC [type1, type2: CSEIndex] RETURNS [type: CSEIndex] = {    n1, n2: CARDINAL;    SELECT TRUE FROM      (type1 = type2), (type2 = typeANY) => type ¬ type1;      (type1 = typeANY) => type ¬ type2;      ENDCASE => {	n1 ¬ Bundling[type1];	n2 ¬ Bundling[type2];	WHILE n1 > n2 DO type1 ¬ Unbundle[LOOPHOLE[type1]]; n1 ¬ n1-1 ENDLOOP;	WHILE n2 > n1 DO type2 ¬ Unbundle[LOOPHOLE[type2]]; n2 ¬ n2-1 ENDLOOP;	-- check bundling	DO	  type1 ¬ TargetType[type1];	  type2 ¬ TargetType[type2];	  SELECT TRUE FROM	    Types.Assignable[[syms, type1], [syms, type2]] => {type ¬ type1; EXIT};	    Types.Assignable[[syms, type2], [syms, type1]] => {type ¬ type2; EXIT};	    ENDCASE;	  IF n1 = 0 THEN GO TO Fail;	  n1 ¬ n1-1;	  type1 ¬ Unbundle[LOOPHOLE[type1]];	  type2 ¬ Unbundle[LOOPHOLE[type2]];	  REPEAT	    Fail => type ¬ SIGNAL UnresolvedTypes;	  ENDLOOP};    RETURN};  ForceType: PUBLIC PROC [t: Tree.Link, type: CSEIndex] RETURNS [Tree.Link] = {    PushTree[syms, t];    IF t = Tree.Null THEN PushNode[syms, cast, 1]    ELSE WITH t SELECT FROM      subtree =>	SELECT syms.tb[index].name FROM	  construct, union, rowcons => PushNode[syms, cast, 1];	  openx => PushNode[syms, cast, 1];	  ENDCASE;      ENDCASE => PushNode[syms, cast, 1];    SetInfo[syms, EncodeSei[type]];  RETURN [PopTree[syms]]}; -- operators   UpArrow: PUBLIC PROC [node: Tree.Index] = {    OPEN syms.tb[node];    type, nType: CSEIndex;    attr: Attr;    son[1] ¬ Exp[son[1], typeANY];    type ¬ RType[];  attr ¬ RAttr[];  RPop[];  attr.const ¬ FALSE;    DO      nType ¬ NormalType[syms, type];      WITH t: syms.seb[nType] SELECT FROM	ref => {	  RPush[UnderType[syms, t.refType], attr];	  attr2 ¬ syms.seb[type].typeTag = long;	  IF P3S.safety = checked AND ~t.counted THEN	    Log.ErrorNode[unsafeOperation, node];	  EXIT};	record => {	  IF Bundling[nType] = 0 THEN GO TO fail;	  type ¬ Unbundle[LOOPHOLE[nType, RecordSEIndex]]};	ENDCASE => GO TO fail;      REPEAT	fail => {	  IF type # typeANY THEN Log.ErrorTree[typeClash, son[1]];	  RPush[typeANY, attr]};      ENDLOOP}; -- arithmetic expression manipulation  MakeNumeric: PROC [type: CSEIndex] RETURNS [CSEIndex] = {    RETURN [SELECT syms.seb[type].typeTag FROM      long => MakeLongType[dataPtr.typeINT, type],      ENDCASE => dataPtr.typeINT]};  EvalNumeric: PROC [t: Tree.Link] RETURNS [val: Tree.Link] = {    val ¬ GenericRhs[t, dataPtr.typeINT];    SELECT NormalType[syms, rStack[rI].type] FROM      dataPtr.typeINT => NULL;      typeANY => rStack[rI].type ¬ MakeNumeric[rStack[rI].type];      ENDCASE => Log.ErrorTree[typeClash, val];    RETURN};  ArithOp: PROC [node: Tree.Index] = {    OPEN syms.tb[node];    saveNP: NPUse;    son[1] ¬ EvalNumeric[son[1]];  saveNP ¬ phraseNP;    son[2] ¬ EvalNumeric[son[2]];     BalanceAttributes[node];    rStack[rI-1].attr ¬ And[rStack[rI-1].attr, rStack[rI].attr];    IF attr1 THEN rStack[rI-1].attr.const ¬ FALSE;    RPop[];  phraseNP ¬ MergeNP[saveNP][phraseNP]};  ArithType: PROC [type: CSEIndex] RETURNS [CSEIndex] = {    type ¬ NormalType[syms, type];    RETURN [WITH syms.seb[type] SELECT FROM      relative => NormalType[syms, UnderType[syms, offsetType]],      ENDCASE => type]};  Plus: PROC [node: Tree.Index] = {    OPEN syms.tb[node];    type: CSEIndex;    lr: BOOLEAN;    saveNP: NPUse;    son[1] ¬ GenericRhs[son[1], typeANY];  saveNP ¬ phraseNP;    type ¬ ArithType[rStack[rI].type];    IF syms.seb[type].typeTag = ref OR type = dataPtr.typeCHAR THEN {      IF RCType[syms, type] # none THEN Log.ErrorTree[typeClash, son[1]];      lr ¬ TRUE; son[2] ¬ EvalNumeric[son[2]]}    ELSE {      SELECT type FROM	dataPtr.typeINT, typeANY => NULL;	ENDCASE => Log.ErrorTree[typeClash, son[1]];      son[2] ¬ GenericRhs[son[2], typeANY];      lr ¬ FALSE;  type ¬ ArithType[rStack[rI].type];      SELECT TRUE FROM	type = dataPtr.typeINT, type = dataPtr.typeCHAR => NULL;	syms.seb[type].typeTag = ref =>	  IF RCType[syms, type] # none THEN Log.ErrorTree[typeClash, son[2]];	ENDCASE => {	  IF type # typeANY THEN Log.ErrorTree[typeClash, son[2]];	  rStack[rI].type ¬ MakeNumeric[rStack[rI].type]}};    IF P3S.safety = checked AND syms.seb[type].typeTag = ref THEN      Log.ErrorNode[unsafeOperation, node];    BalanceAttributes[node];    rStack[rI-1].attr ¬ And[rStack[rI-1].attr, rStack[rI].attr];    IF attr1 THEN rStack[rI-1].attr.const ¬ FALSE;    IF ~lr THEN rStack[rI-1].type ¬ rStack[rI].type;    RPop[];  phraseNP ¬ MergeNP[saveNP][phraseNP]};  Minus: PROC [node: Tree.Index] = {    OPEN syms.tb[node];    type, lType, rType: CSEIndex;    lr: BOOLEAN;    saveNP: NPUse;    son[1] ¬ GenericRhs[son[1], typeANY];  saveNP ¬ phraseNP;    type ¬ NormalType[syms, rStack[rI].type]; lType ¬ ArithType[type];  lr ¬ TRUE;    IF syms.seb[lType].typeTag = ref OR lType = dataPtr.typeCHAR THEN {      IF RCType[syms, lType] # none THEN Log.ErrorTree[typeClash, son[1]];      son[2] ¬ GenericRhs[son[2], typeANY];  rType ¬ ArithType[rStack[rI].type];      SELECT TRUE FROM	rType = typeANY => NULL;	Types.Equivalent[[syms, lType], [syms, rType]] => lr ¬ FALSE;	rType = dataPtr.typeINT => NULL;	ENDCASE => Log.ErrorTree[typeClash, son[2]]}    ELSE {      SELECT type FROM	dataPtr.typeINT, typeANY => NULL;	ENDCASE => {Log.ErrorTree[typeClash, son[1]]; rStack[rI].type ¬ typeANY};      son[2] ¬ EvalNumeric[son[2]]};    IF P3S.safety = checked AND syms.seb[lType].typeTag = ref THEN      Log.ErrorNode[unsafeOperation, node];    BalanceAttributes[node];    rStack[rI-1].attr ¬ And[rStack[rI-1].attr, rStack[rI].attr];    IF attr1 THEN rStack[rI-1].attr.const ¬ FALSE;    IF ~lr THEN rStack[rI-1].type ¬      IF attr2 THEN MakeLongType[dataPtr.typeINT, rStack[rI].type] ELSE dataPtr.typeINT;    RPop[];  phraseNP ¬ MergeNP[saveNP][phraseNP]};  UnaryOp: PROC [node: Tree.Index] = {    IF UniOperand[node] THEN {      syms.tb[node].son[1] ¬ EvalNumeric[syms.tb[node].son[1]];  SetAttributes[node];      IF syms.tb[node].attr1 THEN rStack[rI].attr.const ¬ FALSE}};  EnumOp: PROC [node: Tree.Index, target: CSEIndex] = {    IF UniOperand[node] THEN {      syms.tb[node].son[1] ¬ GenericRhs[syms.tb[node].son[1], target];  SetAttributes[node];      IF ~IndexType[RType[]] THEN Log.ErrorTree[typeClash, syms.tb[node].son[1]]}};  RelOp: PROC [node: Tree.Index, ordered: BOOLEAN] = {    OPEN syms.tb[node];    type: CSEIndex;    attr: Attr;    saveNP: NPUse;    implicitOp: BOOLEAN;    son[1] ¬ GenericRhs[son[1], typeANY];  saveNP ¬ phraseNP;     type ¬ NormalType[syms, RType[]];  attr ¬ RAttr[];    implicitOp ¬ (son[1] = Tree.Null);    son[2] ¬ GenericRhs[son[2], type];    type ¬ BalanceTypes[type, NormalType[syms, RType[]]      ! UnresolvedTypes => {Log.ErrorTree[typeClash, son[2]]; RESUME [typeANY]}];    IF (ordered AND ~OrderedType[type]) OR (~ordered AND ~IdentifiedType[type]) THEN      Log.ErrorNode[relationType, node];    BalanceAttributes[node];    attr ¬ And[attr, RAttr[]];    IF implicitOp AND son[1] # Tree.Null THEN Log.ErrorTree[typeClash, son[2]];    SELECT syms.seb[type].typeTag FROM      basic, enumerated => NULL;      transfer => {	IF OperandInline[son[1]] THEN Log.ErrorTree[misusedInline, son[1]];	IF OperandInline[son[2]] THEN Log.ErrorTree[misusedInline, son[2]];	attr.const ¬ FALSE};      real => attr.const ¬ FALSE;      ENDCASE;    RPop[];  RPop[];    RPush[dataPtr.typeBOOL, attr];  phraseNP ¬ MergeNP[saveNP][phraseNP]};  In: PROC [node: Tree.Index] = {    OPEN syms.tb[node];    type: CSEIndex;    saveNP: NPUse;    son[1] ¬ GenericRhs[son[1], typeANY];  saveNP ¬ phraseNP;    type ¬ RType[];    son[2] ¬ Range[son[2], CanonicalType[type]];    [] ¬ BalanceTypes[NormalType[syms, type], NormalType[syms, RType[]]      ! UnresolvedTypes => {Log.ErrorTree[typeClash, syms.tb[node].son[1]]; RESUME [typeANY]}];    BalanceAttributes[node];    rStack[rI-1].attr ¬ And[rStack[rI-1].attr, rStack[rI].attr];  RPop[];    rStack[rI].type ¬ dataPtr.typeBOOL;    phraseNP ¬ MergeNP[saveNP][phraseNP]};  Interval: PUBLIC PROC [t: Tree.Link, target: CSEIndex, constant: BOOLEAN] = {    node: Tree.Index = GetNode[syms, t];    type: CSEIndex;    attr: Attr;    saveNP: NPUse;    target ¬ TargetType[target];    syms.tb[node].son[1] ¬ BalancedRhs[syms.tb[node].son[1], target];  saveNP ¬ phraseNP;    type ¬ rStack[rI].type ¬ CanonicalType[rStack[rI].type];  attr ¬ RAttr[];    IF constant AND ~attr.const THEN Log.ErrorTree[nonConstant, syms.tb[node].son[1]];    syms.tb[node].son[2] ¬ BalancedRhs[syms.tb[node].son[2], target];      rStack[rI].type ¬ CanonicalType[rStack[rI].type];    [] ¬ BalanceTypes[NormalType[syms, type], NormalType[syms, RType[]]      ! UnresolvedTypes => {Log.ErrorTree[typeClash, syms.tb[node].son[2]]; RESUME [typeANY]}];    attr ¬ And[attr, RAttr[]];    IF constant AND ~RAttr[].const THEN Log.ErrorTree[nonConstant, syms.tb[node].son[2]];    BalanceAttributes[node];    IF syms.tb[node].attr1 THEN attr.const ¬ FALSE;    phraseNP ¬ MergeNP[saveNP][phraseNP];    RPop[]; rStack[rI].attr ¬ attr};  BalancedTarget: PROC [target, type: CSEIndex] RETURNS [CSEIndex] = {    RETURN [IF target = typeANY	OR (~EqualTypes[type, target] AND NormalType[syms, type] = target)      THEN TargetType[type]      ELSE target]};  ResolveTypes: PROC [type1, type2, target: CSEIndex, t: Tree.Link]      RETURNS [type: CSEIndex] = {    failed: BOOLEAN;    IF target = typeANY THEN failed ¬ TRUE    ELSE {      ENABLE UnresolvedTypes => {failed ¬ TRUE; RESUME [typeANY]};      failed ¬ FALSE;      type1 ¬ BalanceTypes[target, type1];      type2 ¬ BalanceTypes[target, type2];      type ¬ BalanceTypes[type1, type2]};    IF failed THEN {Log.ErrorTree[typeClash, t]; type ¬ typeANY};    RETURN};  IfExp: PROC [node: Tree.Index, target: CSEIndex] = {    OPEN syms.tb[node];    type: CSEIndex;    attr: Attr;    entryNP, saveNP: NPUse;    SealRefStack[];    son[1] ¬ Rhs[son[1], dataPtr.typeBOOL];     attr ¬ RAttr[];  RPop[];  entryNP ¬ phraseNP;    UnsealRefStack[];    son[2] ¬ BalancedRhs[son[2], target];    attr ¬ And[attr, RAttr[]]; saveNP ¬ SequenceNP[entryNP][phraseNP];    type ¬ RType[];  RPop[];    target ¬ BalancedTarget[target, type];    son[3] ¬ BalancedRhs[son[3], target];  attr ¬ And[attr, RAttr[]];    type ¬ BalanceTypes[type, RType[]	! UnresolvedTypes => {RESUME [ResolveTypes[type, RType[], target, son[3]]]}];    IF syms.seb[type].typeTag = transfer THEN {      IF OperandInline[son[2]] THEN Log.ErrorTree[misusedInline, son[2]];      IF OperandInline[son[3]] THEN Log.ErrorTree[misusedInline, son[3]];      attr.const ¬ FALSE};    phraseNP ¬ BoundNP[saveNP][SequenceNP[entryNP][phraseNP]];    RPop[];  RPush[type, attr]};  SelectExp: PROC [      node: Tree.Index, target: CSEIndex,      driver: PROC [Tree.Index, TreeOps.Map], foldable: BOOLEAN] = {    type: CSEIndex;    attr: Attr;    saveNP: NPUse;    started: BOOLEAN;    Selection: TreeOps.Map = {      subType: CSEIndex;      entryNP: NPUse = phraseNP;      v ¬ BalancedRhs[t, target];      subType ¬ BalanceTypes[type, RType[]	! UnresolvedTypes => {RESUME [ResolveTypes[type, RType[], target, v]]}];      IF syms.seb[subType].typeTag = transfer AND OperandInline[v] THEN        Log.ErrorTree[misusedInline, v];      saveNP ¬ BoundNP[saveNP][SequenceNP[entryNP][phraseNP]];      IF subType # typeANY THEN type ¬ subType;      IF ~started THEN target ¬ BalancedTarget[target, type];      attr ¬ And[attr, RAttr[]];  RPop[];  started ¬ TRUE;  RETURN};    type ¬ typeANY;  attr ¬ fullAttr;  started ¬ FALSE;  saveNP ¬ none;    driver[node, Selection];  attr ¬ And[attr, RAttr[]];  RPop[];    attr.const ¬ foldable AND attr.const AND syms.tb[node].attr2;    RPush[type, attr];  phraseNP ¬ saveNP};  MinMax: PROC [node: Tree.Index, target: CSEIndex] = {    OPEN syms.tb[node];    attr: Attr;    saveNP: NPUse;    started: BOOLEAN;    type: CSEIndex;        SubMinMax: TreeOps.Map = {      subType: CSEIndex;      v ¬ BalancedRhs[t, target];      attr ¬ And[attr, RAttr[]];  saveNP ¬ MergeNP[saveNP][phraseNP];      subType ¬ CanonicalType[RType[]];       subType ¬ BalanceTypes[subType, type 		! UnresolvedTypes => {RESUME[ResolveTypes[subType, type, target, v]]}];      IF type # subType AND subType # typeANY THEN {	IF ~OrderedType[subType] THEN Log.ErrorNode[relationType, node];	type ¬ subType;	IF ~started THEN target ¬ BalancedTarget[target, type]};      RPop[];  started ¬ TRUE;  RETURN};    attr ¬ fullAttr;  saveNP ¬ none;  started ¬ FALSE;  type ¬ typeANY;    son[1] ¬ UpdateList[syms, son[1], SubMinMax];    SELECT syms.seb[type].typeTag FROM      long => {attr1 ¬ FALSE; attr2 ¬ TRUE};      real => {attr1 ¬ TRUE; attr2 ¬ FALSE; attr.const ¬ FALSE};      ENDCASE => attr1 ¬ attr2 ¬ FALSE;    RPush[type, attr];  phraseNP ¬ saveNP};  TypeTest: PROC [node: Tree.Index, from, to: CSEIndex] = {    subType: CSEIndex = CanonicalType[from];    op: NarrowOp = Narrowing[type: subType, target: to];    SELECT TRUE FROM      op.error => Log.ErrorTree[typeClash, syms.tb[node].son[1]];      op.computed => Log.ErrorTree[missingBinding, syms.tb[node].son[1]];      op.unImpl => Log.Warning[unimplemented];      ENDCASE;    IF subType # from THEN syms.tb[node].son[1] ¬ ForceType[syms.tb[node].son[1], subType];    syms.tb[node].attr1 ¬ op.indirect;    IF (syms.tb[node].attr2 ¬ op.rtTest) THEN EnterType[MarkedType[to]];    syms.tb[node].attr3 ¬ op.tagTest};          EndPoint: PROC [node: Tree.Index] = {    OPEN syms.tb[node];    type: CSEIndex;    son[1] ¬ TypeExp[syms, son[1]];    type ¬ UnderType[syms, TypeForTree[son[1]]];      BEGIN      WITH syms.seb[type] SELECT FROM	basic =>	  SELECT code FROM	    codeINT, codeCHAR => NULL;	    ENDCASE => GO TO fail;        enumerated => NULL;	relative => IF TypeForm[syms, offsetType] # subrange THEN GO TO fail;        subrange => NULL;	long =>	  IF NormalType[syms, UnderType[syms, rangeType]] # dataPtr.typeINT THEN GO TO fail;        ENDCASE => GO TO fail;      EXITS	fail => Log.ErrorTree[typeClash, son[1]];      END;    RPush[type, fullAttr]};   AttrClass: PROC [type: CSEIndex] RETURNS [{short, long, real}] = {    RETURN [WITH t: syms.seb[type] SELECT FROM      long => long,      real => real,      relative => AttrClass[UnderType[syms, t.offsetType]],      ENDCASE => short]};  SetAttributes: PROC [node: Tree.Index] = {    SELECT AttrClass[rStack[rI].type] FROM      long => {syms.tb[node].attr1 ¬ FALSE; syms.tb[node].attr2 ¬ TRUE};      real => {syms.tb[node].attr1 ¬ TRUE; syms.tb[node].attr2 ¬ FALSE};      ENDCASE => syms.tb[node].attr1 ¬ syms.tb[node].attr2 ¬ FALSE};  BalanceAttributes: PROC [node: Tree.Index] = {    lType, rType: CSEIndex;    lType ¬ rStack[rI-1].type;  rType ¬ rStack[rI].type;    SELECT AttrClass[lType] FROM      long => {	SELECT AttrClass[rType] FROM	  long => {syms.tb[node].attr1 ¬ FALSE; syms.tb[node].attr2 ¬ TRUE};	  real => {	    rStack[rI-1].type ¬ rType;	    syms.tb[node].son[1] ¬ Float[syms.tb[node].son[1], lType, rType];	    rStack[rI-1].attr.const ¬ FALSE;	    syms.tb[node].attr1 ¬ TRUE;  syms.tb[node].attr2 ¬ FALSE};	  ENDCASE => {	    rStack[rI].type ¬ rType ¬ MakeLongType[rType, lType];	    syms.tb[node].son[2] ¬ Lengthen[syms.tb[node].son[2], rType];	    syms.tb[node].attr1 ¬ FALSE;  syms.tb[node].attr2 ¬ TRUE}};      real => {	syms.tb[node].attr1 ¬ TRUE;  syms.tb[node].attr2 ¬ FALSE;	SELECT AttrClass[rType] FROM	  real => NULL;	  ENDCASE => {	    rStack[rI].type ¬ lType;	    syms.tb[node].son[2] ¬ Float[syms.tb[node].son[2], rType, lType];	    rStack[rI].attr.const ¬ FALSE}};      ENDCASE =>	SELECT AttrClass[rType] FROM	  long => {	    rStack[rI-1].type ¬ lType ¬ MakeLongType[lType, rType];	    syms.tb[node].son[1] ¬ Lengthen[syms.tb[node].son[1], lType];	    syms.tb[node].attr1 ¬ FALSE;  syms.tb[node].attr2 ¬ TRUE};	  real => {	    rStack[rI-1].type ¬ rType;	    syms.tb[node].son[1] ¬ Float[syms.tb[node].son[1], lType, rType];	    rStack[rI-1].attr.const ¬ FALSE;	    syms.tb[node].attr1 ¬ TRUE;  syms.tb[node].attr2 ¬ FALSE};	  ENDCASE => syms.tb[node].attr1 ¬ syms.tb[node].attr2 ¬ FALSE};  Lengthen: PUBLIC PROC [t: Tree.Link, target: CSEIndex] RETURNS [Tree.Link] = {    PushTree[syms, t]; PushNode[syms, lengthen, 1];     SetInfo[syms, EncodeSei[target]]; RETURN [PopTree[syms]]};  Shorten: PUBLIC PROC [t: Tree.Link, target: CSEIndex] RETURNS [Tree.Link] = {    PushTree[syms, t]; PushNode[syms, shorten, 1];     SetInfo[syms, EncodeSei[target]]; RETURN [PopTree[syms]]};  Float: PUBLIC PROC [t: Tree.Link, type, target: CSEIndex] RETURNS [Tree.Link] = {    PushTree[syms, IF syms.seb[type].typeTag = long      THEN t      ELSE Lengthen[t, MakeLongType[type, typeANY]]];    SELECT NormalType[syms, type] FROM      dataPtr.typeINT => {PushNode[syms, float, 1]; SetInfo[syms, EncodeSei[target]]};      typeANY => NULL;      ENDCASE => Log.ErrorTree[typeClash, t];    RETURN [PopTree[syms]]};    LLit: PROC [node: Tree.Index] = {    attr: Attr ¬ fullAttr;    level: Symbols.ContextLevel = P3S.currentBody.level;    attr.const ¬ FALSE;     RPush[OperandType[syms.tb[node].son[1]], attr]}; -- expressions  implicit: PUBLIC P3S.ImplicitInfo;	-- implied attributes of Tree.Null    Exp: PUBLIC PROC [exp: Tree.Link, target: CSEIndex] RETURNS [val: Tree.Link] = {    type: CSEIndex;    phraseNP ¬ none;    IF exp = Tree.Null THEN {RPush[implicit.type, implicit.attr]; RETURN [Tree.Null]};    WITH e: exp SELECT FROM      symbol => {	sei: ISEIndex = e.index;	attr: Attr;	attr.noXfer ¬ attr.noAssign ¬ TRUE;  RecordMention[sei];	type ¬ UnderType[syms, syms.seb[sei].idType];	SELECT syms.ctxb[syms.seb[sei].idCtx].ctxType FROM	  included =>	    IF ~(attr.const¬ConstantId[syms, sei]) THEN Log.ErrorSei[unimplemented, sei];	  imported => attr.const ¬ ConstantId[syms, sei];	  ENDCASE => attr.const ¬ syms.seb[sei].constant;	RPush[type, attr];  val ¬ exp};      hash =>	WITH t: syms.seb[target] SELECT FROM	  enumerated => {	    sei: ISEIndex;	    IF ([sei: sei] ¬ SearchCtxList[e.index, t.valueCtx]).found THEN {	      RPush[target, fullAttr];  val ¬ [symbol[sei]]}	    ELSE val ¬ Id[e.index]};	  ENDCASE => val ¬ Id[e.index];      literal => {	attr: Attr;	attr.noXfer ¬ attr.noAssign ¬ TRUE;	WITH e.info SELECT FROM	  string => {	    [val, type] ¬ StringRef[exp, target];	    attr.const ¬ FALSE;	    IF dataPtr.interface THEN Log.ErrorTree[unimplemented, exp]};	  ENDCASE => {type ¬ dataPtr.typeINT; attr.const ¬ TRUE; val ¬ exp};	RPush[type, attr]};      subtree => {	node: Tree.Index ¬ e.index;	val ¬ exp;	-- the default	SELECT syms.tb[node].name FROM	  dot => {node ¬ Dot[node, target]; val ¬ [subtree[node]]};	  uparrow => UpArrow[node];	  apply => {	    node ¬ Apply[node, target, FALSE]; val ¬ [subtree[node]];	    CheckNonVoid[node, target]};	  uminus, abs => UnaryOp[node];	  plus => Plus[node];	  minus => Minus[node];	  times, div, mod => ArithOp[node];	  relE, relN => RelOp[node, FALSE];	  relL, relGE, relG, relLE => RelOp[node, TRUE];	  in, notin => In[node];	  not => syms.tb[node].son[1] ¬ Rhs[syms.tb[node].son[1], dataPtr.typeBOOL];	  or, and => BoolOp[node];	  ifx => IfExp[node, target];	  casex => SelectExp[node, target, Case, TRUE];	  bindx => SelectExp[node, target, Discrimination, FALSE];	  assignx => Assignment[node];	  extractx => {Extract[node]; CheckNonVoid[node, target]};	  min, max => MinMax[node, target];	  pred, succ => EnumOp[node, target];	  addr, base, length, arraydesc => AddrOp[node, target];	  all => All[node, target];	  mwconst =>	    IF syms.tb[node].attr1 THEN RPush[dataPtr.typeREAL, fullAttr]	    ELSE {	      IF longUnsigned = CSENull THEN	        longUnsigned ¬ MakeLongType[dataPtr.idCARDINAL, typeANY];	      RPush[longUnsigned, fullAttr]};	  void => RPush[target, voidAttr];	  clit => RPush[dataPtr.typeCHAR, fullAttr];	  llit => LLit[node];	  atom => {	    hti: HTIndex = GetHash[syms, syms.tb[node].son[1]];	    WITH t: syms.seb[target] SELECT FROM	      enumerated => {	        sei: ISEIndex;	        IF ~([sei: sei]¬SearchCtxList[hti, t.valueCtx]).found THEN	          Log.ErrorHti[unknownId, hti];	        syms.tb[node].son[1] ¬ Tree.Null;  FreeNode[syms, node];  node ¬ Tree.NullIndex;	        val ¬ [symbol[index: sei]];  RPush[target, fullAttr]};	      ENDCASE => Log.Error[unimplemented]};	  nil => {	    OPEN syms.tb[node];	    SELECT TRUE FROM	      (son[1] # Tree.Null) => {		son[1] ¬ TypeExp[syms, son[1]];  type ¬ UnderType[syms, TypeForTree[son[1]]]};	      (target # typeANY) => type ¬ target;	      ENDCASE => type ¬ MakeRefType[typeANY, typeANY];	    IF ~NullableType[type] THEN Log.ErrorTree[typeClash, val];	    RPush[type, fullAttr]};	  new, signalx, errorx, fork, joinx, create, startx, cons, listcons => {	    val ¬ MiscXfer[node, target];	    node ¬ GetNode[syms, val];  CheckNonVoid[node, target]};	  syserrorx => {	    RPush[CSENull, emptyAttr]; CheckNonVoid[node, target]};	  lengthen => {	    OPEN syms.tb[node];	    subType: CSEIndex;	    son[1] ¬ GenericRhs[		son[1],		WITH syms.seb[target] SELECT FROM		  long => TargetType[UnderType[syms, rangeType]],		  ENDCASE => target];	    subType ¬ TargetType[rStack[rI].type];	    IF subType = dataPtr.typeINT	     OR syms.seb[subType].typeTag = ref	     OR syms.seb[subType].typeTag = arraydesc	     OR subType = typeANY THEN rStack[rI].type ¬ MakeLongType[subType, target]	    ELSE {Log.ErrorTree[typeClash, son[1]]; rStack[rI].type ¬ typeANY}};	  narrow => {	    OPEN syms.tb[node];	    IF son[2] = Tree.Null THEN {	      IF target = typeANY THEN Log.ErrorNode[noTarget, node];	      type ¬ target}	    ELSE {son[2] ¬ TypeExp[syms, son[2]]; 	    type ¬ UnderType[syms, TypeForTree[son[2]]]};	    son[1] ¬ Exp[son[1], TargetType[type]];	    TypeTest[node: node, from: rStack[rI].type, to: type];	    IF attr3 AND ~attr1 AND son[2] = Tree.Null THEN Log.ErrorNode[noTarget, node];	    IF RCType[syms, type] = simple THEN {	      nType: CSEIndex = NormalType[syms, type];	      WITH t: syms.seb[nType] SELECT FROM	        ref => EnterType[t.refType, FALSE];	        ENDCASE => NULL};	    IF syms.tb[node].nSons > 2 THEN [] ¬ CatchPhrase[syms.tb[node].son[3]];	    rStack[rI].type ¬ type;	    rStack[rI].attr.const ¬ rStack[rI].attr.noXfer ¬ FALSE};	  istype => {	    OPEN syms.tb[node];	    son[1] ¬ Exp[son[1], typeANY];	    son[2] ¬ TypeExp[syms, son[2]]; type ¬ UnderType[syms, TypeForTree[son[2]]];	    TypeTest[node: node, from: RType[], to: type];	    rStack[rI].type ¬ dataPtr.typeBOOL; rStack[rI].attr.const ¬ FALSE};	  safen => syms.tb[node].son[1] ¬ Exp[syms.tb[node].son[1], target];	  loophole => {	    OPEN syms.tb[node];	    subType: CSEIndex;	    son[1] ¬ Exp[son[1], typeANY];  subType ¬ RType[];	    IF syms.seb[subType].typeTag = transfer AND OperandInline[son[1]] THEN	      Log.ErrorTree[misusedInline, son[1]];	    IF son[2] = Tree.Null THEN {	      IF target = typeANY THEN Log.ErrorNode[noTarget, node];	      rStack[rI].type ¬ target}	    ELSE {	      son[2] ¬ TypeExp[syms, son[2]];	      rStack[rI].type ¬ UnderType[syms, TypeForTree[son[2]]]};	    IF RCType[syms, rStack[rI].type] # none THEN {	      rStack[rI].attr.const ¬ FALSE;	      IF P3S.safety = checked THEN Log.ErrorNode[unsafeOperation, node]}};	  size => {	    OPEN syms.tb[node];	    attr: Attr;	    son[1] ¬ TypeAppl[syms, son[1]]; attr ¬ RAttr[]; RPop[];	    IF son[2] # Tree.Null THEN {	      saveNP: NPUse = phraseNP;	      son[2] ¬ Rhs[son[2], dataPtr.typeINT];	      attr ¬ And[attr, RAttr[]]; RPop[];	      phraseNP ¬ MergeNP[saveNP][phraseNP]};	    RPush[dataPtr.typeINT, attr]};	  first, last => EndPoint[node];	  typecode => {	    syms.tb[node].son[1] ¬ TypeExp[syms, syms.tb[node].son[1]];	    EnterType[TypeForTree[syms.tb[node].son[1]], FALSE];	    RPush[typeANY, fullAttr]};	  self => {	    val ¬ P3S.self.tree;  P3S.self.tree ¬ Tree.Null;	    phraseNP ¬ P3S.self.np;  RPush[P3S.self.type, P3S.self.attr];	    FreeNode[syms, node];  node ¬ Tree.NullIndex};	  val,	  cast => {	    syms.tb[node].son[1] ¬ Exp[syms.tb[node].son[1], target];	    rStack[rI].type ¬ target};	  ord =>	    IF UniOperand[node] THEN {	      syms.tb[node].son[1] ¬ Exp[syms.tb[node].son[1], typeANY];  SetAttributes[node];	      IF ~IndexType[RType[]] THEN Log.ErrorTree[typeClash, syms.tb[node].son[1]];	      rStack[rI].type ¬ MakeNumeric[RType[]]};--	  val =>--	    IF UniOperand[node] THEN {--	      IF ~IndexType[target] THEN Log.ErrorNode[noTarget, node];--	      syms.tb[node].son[1] ¬ EvalNumeric[syms.tb[node].son[1]];--	      rStack[rI].type ¬ target};	      	  stringinit => {	    syms.tb[node].son[2] ¬ Rhs[syms.tb[node].son[2], dataPtr.typeINT];	    IF ~RAttr[].const THEN Log.ErrorTree[nonConstant, syms.tb[node].son[2]];	    RPop[];  	    IF ~dataPtr.switches['o] AND 	      syms.ctxb[syms.bb[dataPtr.bodyIndex].localCtx].level = lG THEN	        RPush[dataPtr.typeLONGSTRING, voidAttr]	    ELSE	      RPush[dataPtr.typeSTRING, voidAttr]};	  ENDCASE => 	    IF syms.tb[node].name = item THEN 	      syms.tb[node].son[2] ¬ Exp[syms.tb[node].son[2], target]	    ELSE {Log.Error[unimplemented]; RPush[typeANY, emptyAttr]};	IF node # Tree.NullIndex THEN syms.tb[node].info ¬ EncodeSei[rStack[rI].type]};      ENDCASE;    RETURN};    CheckNonVoid: PROC [node: Tree.Index, target: CSEIndex] = {      IF rStack[rI].type = CSENull THEN	SELECT syms.tb[node].name FROM	  error => {syms.tb[node].name ¬ errorx; rStack[rI].type ¬ target};	  errorx, syserrorx => rStack[rI].type ¬ target;	  ENDCASE => {Log.ErrorNode[typeClash, node]; rStack[rI].type ¬ typeANY}};  VoidExp: PUBLIC PROC [h: SymbolTable.Handle, t: Tree.Link] RETURNS [v: Tree.Link] = {    v ¬ Exp[t, typeANY]; RPop[]; RETURN};  UniOperand: PROC [node: Tree.Index] RETURNS [valid: BOOLEAN] = {    l: CARDINAL = ListLength[syms, syms.tb[node].son[1]];    IF ~(valid ¬ l=1) THEN {      IF l > 1 THEN Log.ErrorN[listLong, l-1] ELSE Log.ErrorN[listShort, l+1];      syms.tb[node].son[1] ¬ UpdateList[syms, syms.tb[node].son[1], VoidExp];      RPush[typeANY, emptyAttr]};    RETURN}; -- overloaded string literals   StringRef: PROC [t: Tree.Link, target: CSEIndex] RETURNS [v: Tree.Link, type: CSEIndex] = {    WITH tt: t SELECT FROM       literal => WITH tt.info SELECT FROM 	string => type ¬ TypeForString[index];	ENDCASE => ERROR;      ENDCASE => ERROR;      v ¬ t};  }.
-- Copyright (C) 1981, 1982, 1983, 1986  by Xerox Corporation. All rights reserved. -- file Pass3I.mesa--   Satterthwaite,	October 1, 1982 10:56 am--   Donahue,		 8-Dec-81 15:29:30--   Sweet,		 8-Nov-83 18:09:08--   Johnsson,		19-Jun-83 18:36:19--   Wagner		18-Aug-86 11:35:32DIRECTORY  ComData: TYPE USING [    interface, moduleCtx, seAnon, switches, textIndex],  Copier: TYPE USING [CompleteContext, Delink, SearchFileCtx],  CLog: TYPE USING [ErrorHti, ErrorSei, ErrorTree, WarningSei],  P3: TYPE USING [    Attr, fullAttr, voidAttr, mark, MergeNP, phraseNP,    And, Exp, FirstId, InterfaceCtx, LongPath, MakeLongType, MakeRefType,    OperandType, ResolveType, ResolveValue, RPop, RPush, RType, SetDefaultImport,    TypeForTree, VariantUnionType, VoidExp],  P3S: TYPE USING [currentBody, currentScope, safety],  Symbols: TYPE USING [    CTXRecord, ExtensionType, MDIndex, HTIndex, SEIndex, ISEIndex, CSEIndex,     RecordSEIndex, CTXIndex, IncludedCTXIndex, Closure,    HTNull, SENull, ISENull, RecordSENull, CTXNull, IncludedCTXNull,    lG, lZ, StandardContext, typeTYPE, typeANY],  SymbolOps: TYPE USING [    ArgCtx, ConstantId, EnterExtension, FindExtension, FirstCtxSe, LinkMode,    NextSe, NormalType, RCType, ReferentType, SearchContext, SetSeLink,    TypeForm, TypeLink, TypeRoot, UnderType,     FromCard, ToCard, ToSei, ToTreeIndex],  SymbolTable USING [Handle],  Tree: TYPE USING [Index, Link, Null, NullIndex],  TreeOps: TYPE USING [    CopyTree, FreeTree, GetHash, GetNode, ListLength, Map, NthSon, OpName,    PopTree, PushTree, PushNode, Scan, ScanList, ScanSons, SearchList,    SetAttr, SetInfo, SetShared, Test, UpdateList, UpdateLeaves,    DecodeCard, DecodeCSei, DecodeSei, EncodeBti, EncodeSei];Pass3I: PROGRAM    IMPORTS      Copier, Log: CLog, P3, P3S, SymbolOps, TreeOps,       dataPtr: ComData    EXPORTS P3 = {   OPEN SymbolOps, P3, Symbols, TreeOps;-- uninitialized variable processing  RefItem: TYPE = RECORD [kind: {seal, rhs, lhs}, sei: ISEIndex];  RefSeal: RefItem = [kind:seal, sei:ISENull];  RefSequence: TYPE = RECORD [SEQUENCE length: CARDINAL OF RefItem];  RefStack: TYPE = LONG POINTER TO RefSequence;      refStack: RefStack;  refIndex: CARDINAL;  AdjustRefStack: PROC [n: CARDINAL] = {    oldStack: RefStack ¬ refStack;    refStack ¬ zone.NEW[RefSequence[n]];    FOR i: CARDINAL IN [0..refIndex) DO refStack[i] ¬ oldStack[i] ENDLOOP;    zone.FREE[@oldStack]};  RecordMention: PUBLIC PROC [sei: ISEIndex] = {    IF dataPtr.switches['u] AND     (ToCard[syms.seb[sei].idInfo] = 0 AND ~syms.seb[sei].mark4) THEN {      IF refIndex >= refStack.length THEN AdjustRefStack[refStack.length + 8];      refStack[refIndex] ¬ [kind:rhs, sei:sei];      refIndex ¬ refIndex + 1}    ELSE BumpCount[sei]};  RecordLhs: PUBLIC PROC [sei: ISEIndex] = {    key: RefItem;    IF dataPtr.switches['u] AND       -- an appearance of sei in a catchphrase can cause idInfo to be non-zero      -- here when it was 0 when the lhs was entered on the refStack!      (<<syms.seb[sei].idInfo = 0 AND>> ~syms.seb[sei].mark4) THEN {      key ¬ [kind:rhs, sei:sei];      FOR i: CARDINAL DECREASING IN [0..refIndex) DO	SELECT refStack[i] FROM	  key => {refStack[i].kind ¬ lhs; EXIT};	  RefSeal => EXIT;	  ENDCASE;	-- note absense of error if you don't find it, as it might not be there	ENDLOOP}};  SealRefStack: PUBLIC PROC = {    IF refIndex >= refStack.length THEN AdjustRefStack[refStack.length + 8];    refStack[refIndex] ¬ RefSeal;  refIndex ¬ refIndex + 1};  UnsealRefStack: PUBLIC PROC = {    ClearRefStack[];    refIndex ¬ refIndex - 1;    IF refStack[refIndex] # RefSeal THEN ERROR};  ClearRefStack: PUBLIC PROC = {    sei: ISEIndex;    FOR i: CARDINAL DECREASING IN [0..refIndex) UNTIL refStack[i] = RefSeal DO      sei ¬ refStack[i].sei;      IF refStack[i].kind = rhs       AND ~ConstantInit[sei]       AND (~dataPtr.interface OR syms.ctxb[syms.seb[sei].idCtx].level # lG) THEN	Log.WarningSei[uninitialized, sei];      BumpCount[sei];      refIndex ¬ refIndex - 1;      ENDLOOP;    IF refStack.length > 16 AND refIndex <= 16 THEN AdjustRefStack[16]};  ConstantInit: PROC [sei: ISEIndex] RETURNS [BOOLEAN] = {    node: Tree.Index;    IF syms.seb[sei].constant THEN RETURN [TRUE];    node ¬ ToTreeIndex[syms.seb[sei].idValue];    RETURN [syms.seb[sei].immutable	AND node # Tree.NullIndex AND OpName[syms, syms.tb[node].son[3]] = body]};    syms: SymbolTable.Handle ¬ NIL;  zone: UNCOUNTED ZONE ¬ NIL;    -- type table management  EnterType: PUBLIC PROC [type: SEIndex, canonical: BOOLEAN¬TRUE] = {    ERROR};  CompleteRCType: PROC [type: SEIndex] = {    subType: CSEIndex = UnderType[syms, TypeRoot[syms, type]];    IF RCType[syms, subType] # none THEN ERROR};  EnterComposite: PUBLIC PROC [type: CSEIndex, t: Tree.Link, init: BOOLEAN] = {    ERROR};  EnterDiscriminator: PROC [t: Tree.Link] = INLINE {	-- guarantee that union is copied    [] ¬ VariantUnionType[OpenedType[OperandType[t]]]};  EnterTags: PROC [type: SEIndex] = INLINE {    subType: CSEIndex ¬ OpenedType[UnderType[syms, type]];    DO      next: CSEIndex ¬ UnderType[syms, TypeLink[syms, subType]];      IF next = SENull THEN EXIT;      [] ¬ VariantUnionType[next];	-- guarantee that union is copied      subType ¬ next;      ENDLOOP};    -- identifier look-up  Id: PUBLIC PROC [hti: HTIndex] RETURNS [val: Tree.Link] = {    sei: ISEIndex;    type: CSEIndex;    ctx: CTXIndex;    baseV: Tree.Link;    attr: Attr ¬ voidAttr;    indirect: BOOLEAN;    [sei, baseV, indirect] ¬ FindSe[hti];    IF sei # ISENull THEN {      IF baseV = Tree.Null THEN RecordMention[sei] ELSE BumpCount[sei];      IF ~syms.seb[sei].mark3 THEN ResolveIdType[sei];      val ¬ [symbol[index: sei]];  type ¬ UnderType[syms, syms.seb[sei].idType];      ctx ¬ syms.seb[sei].idCtx;      SELECT syms.ctxb[ctx].ctxType FROM	included => {	  attr.const ¬ ConstantId[syms, sei];	  IF baseV = Tree.Null AND (~attr.const OR ~InterfaceConst[sei]) THEN	    Log.ErrorSei[notImported, sei]};	imported => {	  IF ~dataPtr.interface AND TypeForm[syms, NormalType[syms, type]] = ref THEN 	    [val, type] ¬ DeRef[val, type];	  attr.const ¬ FALSE};	ENDCASE => {	  IF ~ConstResolved[sei] THEN ResolveIdValue[sei];	  attr.const ¬ syms.seb[sei].constant};      SELECT TRUE FROM	baseV = Tree.Null => {	  IF ctx = P3S.currentBody.argCtx THEN phraseNP ¬ ref;	  IF syms.ctxb[ctx].level = lZ AND ~attr.const THEN	    SELECT ctx FROM	      IN StandardContext, dataPtr.moduleCtx => NULL;	      ENDCASE => Log.ErrorSei[missingBase, sei]};	(~attr.const AND syms.ctxb[ctx].ctxType # imported) => {	  attr ¬ And[UpdateTreeAttr[baseV], attr];	  PushTree[syms, CopyTree[syms, baseV]];  PushTree[syms, val];	  IF indirect THEN {PushNode[syms, dot, 2]; SetAttr[syms, 2, syms.seb[OperandType[baseV]].typeTag = long]}	  ELSE {PushNode[syms, dollar, 2]; SetAttr[syms, 2, LongPath[baseV]]};	  SetInfo[syms, EncodeSei[type]];  val ¬ PopTree[syms]};	ENDCASE;      IF VarType[type] THEN -- imported ones already dereferenced        [val, type] ¬ DeRef[val, type, TRUE];      IF syms.seb[sei].extended THEN attr ¬ And[UpdateExtension[sei], attr]}    ELSE {      attr ¬ And[UpdateTreeAttr[baseV], attr];  type ¬ OperandType[baseV];      IF indirect THEN [val, type] ¬ DeRef[CopyTree[syms, baseV], type]      ELSE val ¬ CopyTree[syms, baseV]};    RPush[type, attr];    RETURN};  DeRef: PROC [t: Tree.Link, type: CSEIndex, var: BOOLEAN ¬ FALSE]      RETURNS [Tree.Link, CSEIndex] = {    rType: CSEIndex = ReferentType[syms, type];    PushTree[syms, t];    PushNode[syms, uparrow, 1];    SetInfo[syms, EncodeSei[rType]];  SetAttr[syms, 2, syms.seb[type].typeTag = long];     SetAttr[syms, 3, var];    RETURN [PopTree[syms], rType]};  UpdateExtension: PROC [sei: ISEIndex] RETURNS [attr: Attr] = {    t: Tree.Link;    tag: ExtensionType;    [tag, t] ¬ FindExtension[syms, sei];    IF tag # value THEN attr ¬ fullAttr    ELSE {attr ¬ UpdateTreeAttr[t]; attr.const ¬ TRUE};    RETURN};      FieldId: PUBLIC PROC [hti: HTIndex, type: RecordSEIndex] RETURNS [n: CARDINAL, sei: ISEIndex] = {    [n, sei] ¬ SearchRecord[hti, type];    IF n # 0 THEN {      IF ~syms.seb[sei].mark3 THEN ResolveIdType[sei];      IF ~ConstResolved[sei] THEN ResolveIdValue[sei];      BumpCount[sei]};    RETURN};  InterfaceId: PUBLIC PROC [hti: HTIndex, ctx: CTXIndex]      RETURNS [found: BOOLEAN, sei: ISEIndex] = {    [found, sei] ¬ SearchCtxList[hti, ctx];    IF found  THEN {      SELECT syms.ctxb[syms.seb[sei].idCtx].ctxType FROM	imported => NULL;	included =>	  IF ~ConstantId[syms, sei] OR ~InterfaceConst[sei] THEN Log.ErrorSei[notImported, sei];	 ENDCASE => {	   IF ~syms.seb[sei].mark3 THEN ResolveIdType[sei];	   IF ~ConstResolved[sei] THEN ResolveIdValue[sei]};      BumpCount[sei]};    RETURN};  ClusterId: PUBLIC PROC [hti: HTIndex, ctx: CTXIndex]       RETURNS [found: BOOLEAN, sei: ISEIndex] = {    WITH c: syms.ctxb[ctx] SELECT FROM      simple => [found, sei] ¬ SearchCtxList[hti, ctx];      included => {        mdi: MDIndex = c.module;	IF syms.mdb[mdi].defaultImport = CTXNull THEN {  -- avoid creating spurious principal imports	  IF SearchCtxList[hti, ctx].found THEN	    [found, sei] ¬ SearchCtxList[hti, DefaultImport[LOOPHOLE[ctx], FALSE]]	  ELSE {found ¬ FALSE; sei ¬ ISENull}}	ELSE [found, sei] ¬ SearchCtxList[hti, syms.mdb[mdi].defaultImport]};      ENDCASE => {found ¬ FALSE; sei ¬ ISENull};    IF found THEN {      IF ~syms.seb[sei].mark3 THEN ResolveIdType[sei];      BumpCount[sei]};    RETURN};        -- service routines for above  InterfaceConst: PROC [sei: ISEIndex] RETURNS [BOOLEAN] = INLINE {    RETURN [SELECT LinkMode[syms, sei] FROM val, ref => FALSE, ENDCASE => TRUE]};  ConstResolved: PROC [sei: ISEIndex] RETURNS [BOOLEAN] = {    RETURN [(syms.seb[sei].mark4 OR       ToTreeIndex[syms.seb[sei].idValue] = Tree.NullIndex) OR ~syms.seb[sei].immutable      OR (syms.seb[sei].constant AND ~RootType[sei])]};  VarType: PROC [type: CSEIndex] RETURNS [BOOLEAN] = INLINE {    subType: CSEIndex = NormalType[syms, type];    RETURN [WITH t: syms.seb[subType] SELECT FROM      ref => t.var,      ENDCASE => FALSE]};        RootType: PROC [sei: ISEIndex] RETURNS [BOOLEAN] = INLINE {    RETURN [syms.seb[sei].idType = typeTYPE AND TypeLink[syms, sei] = SENull]};  ResolveIdType: PROC [sei: ISEIndex] = {    declNode: Tree.Index ¬ ToTreeIndex[syms.seb[sei].idValue];    IF syms.tb[declNode].attr3 # P3.mark THEN ResolveType[sei]};  ResolveIdValue: PROC [sei: ISEIndex] = {    declNode: Tree.Index ¬ ToTreeIndex[syms.seb[sei].idValue];    IF syms.seb[sei].mark3 AND syms.tb[declNode].attr2 # P3.mark THEN ResolveValue[sei]};  BumpCount: PUBLIC PROC [sei: ISEIndex] = {    OPEN syms.seb[sei];    IF idType # typeTYPE AND (~mark4 OR (syms.ctxb[idCtx].ctxType = imported AND ~constant)) THEN      idInfo ¬ FromCard[ToCard[idInfo] + 1]};-- keyed-list matching  CompleteRecord: PUBLIC PROC [rSei: RecordSEIndex, depth: Closure ¬ unit] = {    ctx: CTXIndex = syms.seb[rSei].fieldCtx;    WITH syms.ctxb[ctx] SELECT FROM      simple => NULL;      included => IF level = lZ THEN Copier.CompleteContext[syms, LOOPHOLE[ctx], depth];      ENDCASE};  ArrangeKeys: PUBLIC PROC [	expList: Tree.Link,	nextKey: PROC RETURNS [HTIndex],	omittedValue: PROC RETURNS [Tree.Link]]      RETURNS [nItems: CARDINAL] = {    Pair: TYPE = RECORD[key: HTIndex, val: Tree.Link];    PairList: TYPE = RECORD[SEQUENCE length: CARDINAL OF Pair];    a: LONG POINTER TO PairList;    n: CARDINAL;    duplicate: BOOLEAN;    ListItem: TreeOps.Map = {      node: Tree.Index = GetNode[syms, t];      hti: HTIndex = GetHash[syms, syms.tb[node].son[1]];      FOR i: CARDINAL IN [0 .. n) DO	IF hti = a[i].key THEN GO TO Duplicate;	REPEAT	  Duplicate => {duplicate ¬ TRUE; v ¬ t};	  FINISHED => {	    a[n] ¬ [key:hti, val:syms.tb[node].son[2]];  n ¬ n+1;	    syms.tb[node].son[2] ¬ Tree.Null;  v ¬ FreeTree[syms, t]};	ENDLOOP;      RETURN};    DuplicateItem: TreeOps.Scan = {      IF t # Tree.Null THEN {	node: Tree.Index = GetNode[syms, t];	Log.ErrorTree[duplicateKey, syms.tb[node].son[1]];	syms.tb[node].son[2] ¬ P3.VoidExp[syms, syms.tb[node].son[2]]}};    key: HTIndex;    m: CARDINAL;    n ¬ ListLength[syms, expList];  nItems ¬ 0;    a ¬ zone.NEW[PairList[n]];    n ¬ 0;  duplicate ¬ FALSE;  expList ¬ UpdateList[syms, expList, ListItem];  m ¬ n;    UNTIL (key ¬ nextKey[]) = HTNull DO      FOR i: CARDINAL IN [0 .. n) DO	IF key = a[i].key THEN GO TO Found;	REPEAT	  Found => {PushTree[syms, a[i].val]; a[i].key ¬ HTNull; m ¬ m-1};	  FINISHED => PushTree[syms, omittedValue[]];	ENDLOOP;      nItems ¬ nItems + 1;      ENDLOOP;    IF duplicate THEN ScanList[syms, expList, DuplicateItem];    IF m # 0 THEN      FOR i: CARDINAL IN [0 .. n) DO	IF a[i].key # HTNull THEN {	  Log.ErrorHti[unknownKey, a[i].key]; [] ¬ FreeTree[syms, P3.VoidExp[syms, a[i].val]]};	ENDLOOP;    [] ¬ FreeTree[syms, expList];  zone.FREE[@a];    RETURN};-- service routines for copying/mapping list structure  BindTree: PUBLIC PROC [        t: Tree.Link, binding: PROC [ISEIndex] RETURNS [Tree.Link]]      RETURNS [Tree.Link] = {          MapTree: TreeOps.Map = {      IF t = Tree.Null THEN v ¬ Tree.Null      ELSE WITH t SELECT FROM	symbol => v ¬ binding[index];	subtree => {	  node: Tree.Index = index;	  v ¬ SELECT TRUE FROM	    syms.tb[node].shared =>	      SELECT syms.tb[node].name FROM		call, callx => MapThreadedTree[syms, t],		ENDCASE => t,	    ENDCASE => TreeOps.CopyTree[syms, [baseP:@syms.tb, link:t], MapTree]};	ENDCASE => v ¬ t;      RETURN};         MapThread: TreeOps.Map = {      IF OpName[syms, t] = thread THEN {	node: Tree.Index = GetNode[syms, t];	PushTree[syms, MapTree[syms, syms.tb[node].son[1]]]; 	PushTree[syms, Tree.Null];	PushNode[syms, thread, 2]; SetAttr[syms, 1, FALSE]; 	SetInfo[syms, EncodeBti[P3S.currentScope]];	v ¬ PopTree[syms]}      ELSE v ¬ MapTree[syms, t]};        MapThreadedTree: TreeOps.Map = {      sThread: Tree.Index = GetNode[syms, NthSon[syms, t, 1]];      dThread: Tree.Index;      v ¬ TreeOps.CopyTree[syms, [baseP:@syms.tb, link:t], MapThread];      dThread ¬ GetNode[syms, NthSon[syms, v, 1]];      syms.tb[dThread].son[2] ¬ syms.tb[sThread].son[2];      syms.tb[sThread].son[2] ¬ v;  SetShared[syms, v, TRUE];      RETURN};          RETURN [MapTree[syms, t]]};      IdentityBinding: PROC [sei: ISEIndex] RETURNS [Tree.Link] = {    RETURN [[symbol[index: sei]]]};        CopyTree: PUBLIC TreeOps.Map = {    RETURN [BindTree[t, IdentityBinding]]};        -- attribute completion/updating  EnterRefLits: PROC [node: Tree.Index] = {    IF node # Tree.NullIndex THEN    SELECT syms.tb[node].name FROM      assign, assignx =>	IF syms.tb[node].attr2 AND syms.tb[node].attr3 THEN ERROR;      new =>	IF syms.tb[node].attr3 THEN ERROR;      ditem => {	sei: ISEIndex = FirstId[GetNode[syms, syms.tb[node].son[1]]];	UpdateNarrowing[syms.seb[sei].idType, syms.tb[node].attr2, syms.tb[node].attr3]};      narrow => {	IF RCType[syms, DecodeCSei[syms.tb[node].info]] = simple THEN ERROR;	UpdateNarrowing[DecodeSei[syms.tb[node].info], syms.tb[node].attr2, syms.tb[node].attr3]};      istype =>	UpdateNarrowing[TypeForTree[syms.tb[node].son[2]], syms.tb[node].attr2, syms.tb[node].attr3];      atom => ERROR;      bind, bindx => 	IF ~syms.tb[node].attr3 THEN EnterDiscriminator[NthSon[syms, syms.tb[node].son[1], 2]];      ENDCASE};  UpdateNarrowing: PROC [type: SEIndex, rtTest, tagTest: BOOLEAN] = {    IF rtTest THEN ERROR;    IF tagTest THEN EnterTags[type]};          UpdateTreeAttr: PUBLIC PROC [t: Tree.Link] RETURNS [attr: Attr] = {    -- traverses the tree, incrementing reference counts for ids    UpdateAttr: TreeOps.Scan = {      WITH t SELECT FROM	symbol => {	  IF syms.seb[index].idCtx = P3S.currentBody.argCtx THEN	    phraseNP ¬ MergeNP[phraseNP][ref];	  BumpCount[index]};	subtree => {	  node: Tree.Index = index;	  ScanSons[syms, t, UpdateAttr];	  EnterRefLits[node];	  SELECT syms.tb[node].name FROM	    assign, assignx => {	      attr.noAssign ¬ FALSE;  phraseNP ¬ MergeNP[phraseNP][set]};	    IN [call..join], IN [callx..joinx] => {	-- conservative	      P3S.currentBody.noXfers ¬ attr.noXfer ¬ FALSE;	      attr.noAssign ¬ FALSE;  phraseNP ¬ MergeNP[phraseNP][set]};	    new => P3S.currentBody.noXfers ¬ attr.noXfer ¬ FALSE;	    ENDCASE => NULL};	ENDCASE => NULL};    attr ¬ fullAttr;  phraseNP ¬ none;  UpdateAttr[syms, t];    attr.const ¬ FALSE;  RETURN};-- context stack management  ContextEntry: TYPE = RECORD [    base: Tree.Link,		-- the basing expr (empty if none)    indirect: BOOLEAN,		-- true iff basing expr is pointer    info: SELECT tag: * FROM      list => [ctx: CTXIndex],		-- a single context      record => [rSei: RecordSEIndex],	-- a group of contexts      hash => [ctxHti: HTIndex],	-- a single identifier      ENDCASE];  ContextSequence: TYPE = RECORD [SEQUENCE length: NAT OF ContextEntry];  ContextStack: TYPE = LONG POINTER TO ContextSequence;  ctxStack: ContextStack;  ctxIndex: INTEGER;  ContextIncr: CARDINAL = 16;  MakeStack: PROC [size: CARDINAL] RETURNS [ContextStack] = INLINE {    RETURN [zone.NEW[ContextSequence[size]]]};  ExpandStack: PROC = {    oldstack: ContextStack ¬ ctxStack;    ctxStack ¬ MakeStack[oldstack.length + ContextIncr];    FOR i: CARDINAL IN [0 .. oldstack.length) DO ctxStack[i] ¬ oldstack[i] ENDLOOP;    zone.FREE[@oldstack]};  PushCtx: PUBLIC PROC [ctx: CTXIndex] = {    IF (ctxIndex ¬ ctxIndex+1) >= ctxStack.length THEN ExpandStack[];    ctxStack[ctxIndex] ¬ [base:Tree.Null, indirect:FALSE, info:list[ctx]]};  SetCtxBase: PROC [base: Tree.Link, indirect: BOOLEAN] = {    ctxStack[ctxIndex].base ¬ base; ctxStack[ctxIndex].indirect ¬ indirect};  PushRecordCtx: PUBLIC PROC [rSei: RecordSEIndex, base: Tree.Link, indirect: BOOLEAN] = {     IF (ctxIndex ¬ ctxIndex+1) >= ctxStack.length THEN ExpandStack[];    ctxStack[ctxIndex] ¬ [base:base, indirect:indirect, info:record[rSei]]};      UpdateRecordCtx: PUBLIC PROC [type: RecordSEIndex] = {    WITH ctxStack[ctxIndex] SELECT FROM      record => rSei ¬ type;      ENDCASE => ERROR};  PushHtCtx: PUBLIC PROC [hti: HTIndex, base: Tree.Link, indirect: BOOLEAN] = {    IF (ctxIndex ¬ ctxIndex+1) >= ctxStack.length THEN ExpandStack[];    ctxStack[ctxIndex] ¬ [base:base, indirect:indirect, info:hash[hti]]};  PopCtx: PUBLIC PROC = {ctxIndex ¬ ctxIndex-1};  TopCtx: PUBLIC PROC RETURNS [CTXIndex] = {    RETURN [WITH ctxStack[ctxIndex] SELECT FROM list => ctx, ENDCASE => ERROR]};-- primary lookup  FindSe: PUBLIC PROC [hti: HTIndex] RETURNS [ISEIndex, Tree.Link, BOOLEAN] = {    found: BOOLEAN;    nHits: CARDINAL;    sei: ISEIndex;    FOR i: INTEGER DECREASING IN [0 .. ctxIndex] DO      WITH s: ctxStack[i] SELECT FROM	list => {	  [found, sei] ¬ SearchCtxList[hti, s.ctx];	  IF found THEN GO TO Found};	record => {	  [nHits, sei] ¬ SearchRecord[hti, s.rSei];	  SELECT nHits FROM	    = 1 => GO TO Found;	    > 1 => GO TO Ambiguous;	    ENDCASE};	hash => IF hti = s.ctxHti THEN {sei ¬ ISENull; GO TO Found};	ENDCASE;      REPEAT	Found => RETURN [sei, ctxStack[i].base, ctxStack[i].indirect];	Ambiguous => {	  Log.ErrorHti[ambiguousId, hti];	  RETURN [dataPtr.seAnon, Tree.Null, FALSE]};	FINISHED => {	  IF hti # HTNull THEN Log.ErrorHti[unknownId, hti];	  RETURN [dataPtr.seAnon, Tree.Null, FALSE]};      ENDLOOP};  SearchCtxList: PUBLIC PROC [hti: HTIndex, ctx: CTXIndex]      RETURNS [found: BOOLEAN, sei: ISEIndex] = {    IF ctx = CTXNull THEN RETURN [FALSE, ISENull];    WITH c: syms.ctxb[ctx] SELECT FROM      included => {	IF c.restricted THEN {	  sei ¬ SearchRestrictedCtx[hti, LOOPHOLE[ctx]]; found ¬ (sei # ISENull)}	ELSE {	  sei ¬ SearchContext[syms, hti, ctx];	  SELECT TRUE FROM	    (sei # ISENull) => found ¬ TRUE;	    (~c.closed AND ~c.reset) => 	      [found, sei] ¬ Copier.SearchFileCtx[syms, hti, LOOPHOLE[ctx]];	    ENDCASE => found ¬ FALSE};	IF found AND ~syms.seb[sei].public AND ~Shared[ctx]	 AND sei # dataPtr.seAnon THEN Log.ErrorHti[noAccess, hti]};      imported => {	iCtx: IncludedCTXIndex = c.includeLink;	sei ¬ SearchContext[syms, hti, ctx];	IF sei # ISENull THEN	  found ¬ ~syms.ctxb[iCtx].restricted OR CheckRestrictedCtx[hti, iCtx] # ISENull	ELSE {	  [found, sei] ¬ SearchCtxList[hti, iCtx];	  IF found AND  sei # dataPtr.seAnon THEN	    SELECT LinkMode[syms, sei] FROM	      val => {MoveSe[sei, ctx]; ImportSe[sei, ctx]};	      ref => {		MoveSe[sei, ctx];		IF ~dataPtr.interface AND ~VarType[UnderType[syms, syms.seb[sei].idType]] THEN {		  syms.seb[sei].idType ¬ MakeLongType[MakeRefType[			cType: syms.seb[sei].idType, readOnly: syms.seb[sei].immutable,			hint: typeANY], typeANY];		  syms.seb[sei].immutable ¬ TRUE};		ImportSe[sei, ctx]};	      ENDCASE}};      ENDCASE => {sei ¬ SearchContext[syms, hti, ctx]; found ¬ (sei # ISENull)};    RETURN};  MoveSe: PROC [sei: ISEIndex, ctx: CTXIndex] = {    Copier.Delink[syms, sei];  syms.seb[sei].idCtx ¬ ctx;    SetSeLink[syms, sei, syms.ctxb[ctx].seList];  syms.ctxb[ctx].seList ¬ sei};-- import handling  MainIncludedCtx: PUBLIC PROC [mdi: MDIndex] RETURNS [ctx: IncludedCTXIndex] = {    FOR ctx ¬ syms.mdb[mdi].ctx, syms.ctxb[ctx].chain UNTIL ctx = CTXNull DO      IF syms.ctxb[ctx].level = lG THEN EXIT ENDLOOP;    RETURN};  DefaultImport: PROC [iCtx: IncludedCTXIndex, new: BOOLEAN] RETURNS [CTXIndex] = {    mdi: MDIndex = syms.ctxb[iCtx].module;    IF syms.mdb[mdi].defaultImport = CTXNull THEN SetDefaultImport[iCtx, new];    RETURN [syms.mdb[mdi].defaultImport]};  ImportTree: PROC [t: Tree.Link, importCtx: CTXIndex] RETURNS [Tree.Link] = {    iCtx: IncludedCTXIndex = WITH c: syms.ctxb[importCtx] SELECT FROM      imported => c.includeLink,      ENDCASE => ERROR;    UpdateBinding: TreeOps.Map = {      WITH t SELECT FROM	symbol => {	  oldSei: ISEIndex = index;	  oldCtx: CTXIndex = syms.seb[oldSei].idCtx;	  newSei: ISEIndex;	  WITH c: syms.ctxb[oldCtx] SELECT FROM	    included =>	      IF c.level # lG OR InterfaceConst[oldSei] THEN newSei ¬ oldSei	      ELSE {		mdi: MDIndex = c.module;		saveRestricted: BOOLEAN = c.restricted;		saveShared: BOOLEAN = syms.mdb[mdi].shared;		targetCtx: CTXIndex;		c.restricted ¬ FALSE;  syms.mdb[mdi].shared ¬ TRUE;		targetCtx ¬ IF oldCtx = iCtx				THEN importCtx				ELSE DefaultImport[LOOPHOLE[oldCtx], TRUE];		newSei ¬ SearchCtxList[syms.seb[oldSei].hash, targetCtx].sei;		syms.mdb[mdi].shared ¬ saveShared; c.restricted ¬ saveRestricted};	    ENDCASE => newSei ¬ oldSei;	  v ¬ [symbol[index: newSei]];	  IF ~dataPtr.interface AND syms.ctxb[syms.seb[newSei].idCtx].ctxType = imported THEN {	    type: CSEIndex = UnderType[syms, syms.seb[newSei].idType];	    nType: CSEIndex = NormalType[syms, type];	    WITH s: syms.seb[nType] SELECT FROM	      ref => IF ~s.var THEN [v, ] ¬ DeRef[v, nType];	      ENDCASE};	  BumpCount[newSei]};	subtree => {	  node: Tree.Index = index;	  EnterRefLits[node];	  v ¬ UpdateLeaves[syms, t, UpdateBinding]};	ENDCASE => v ¬ t;      RETURN};    RETURN [UpdateBinding[syms, t]]};  ImportCtx: PROC [ctx, importCtx: CTXIndex] = {    FOR sei: ISEIndex ¬ FirstCtxSe[syms, ctx], NextSe[syms, sei] UNTIL sei = ISENull DO        ImportSe[sei, importCtx] ENDLOOP};  ImportSe: PROC [sei: ISEIndex, importCtx: CTXIndex] = {    t: Tree.Link;    tag: ExtensionType;    type: CSEIndex = UnderType[syms, syms.seb[sei].idType];    WITH t: syms.seb[type] SELECT FROM      transfer => {	ImportCtx[ArgCtx[syms, t.typeIn], importCtx];	ImportCtx[ArgCtx[syms, t.typeOut], importCtx]};      ENDCASE;    IF syms.seb[sei].extended THEN {      [tag, t] ¬ FindExtension[syms, sei];      EnterExtension[syms, sei, tag, ImportTree[t, importCtx]]}};-- searching records  SearchRecordSegment: PROC [hti: HTIndex, rSei: RecordSEIndex, suffixed: BOOLEAN]      RETURNS [nHits: CARDINAL, sei: ISEIndex] = {    tSei: CSEIndex;    found: BOOLEAN;    n: CARDINAL;    match: ISEIndex;    [found, sei] ¬ SearchCtxList[hti, syms.seb[rSei].fieldCtx];    nHits ¬ IF found THEN 1 ELSE 0;    IF syms.seb[rSei].hints.variant THEN {      tSei ¬ VariantUnionType[rSei];      WITH syms.seb[tSei] SELECT FROM	union => {	  IF ~suffixed AND ~controlled AND overlaid THEN {	    [n, match] ¬ SearchOverlays[hti, caseCtx];	    IF ~found THEN sei ¬ match;	    nHits ¬ nHits + n};	  IF controlled AND syms.seb[tagSei].hash = hti THEN {sei ¬ tagSei; nHits ¬ nHits + 1}};	sequence => {	  IF controlled AND syms.seb[tagSei].hash = hti THEN {sei ¬ tagSei; nHits ¬ nHits + 1}};	ENDCASE => NULL};    RETURN};  SearchOverlays: PROC [hti: HTIndex, ctx: CTXIndex]      RETURNS [nHits: CARDINAL, sei: ISEIndex] = {    vSei: ISEIndex;    rSei: SEIndex;    n: CARDINAL;    match: ISEIndex;    WITH syms.ctxb[ctx] SELECT FROM      included => Copier.CompleteContext[syms, LOOPHOLE[ctx]];      ENDCASE;    nHits ¬ 0;  sei ¬ ISENull;    FOR vSei ¬ FirstCtxSe[syms, ctx], NextSe[syms, vSei] UNTIL vSei = ISENull DO      IF syms.seb[vSei].public OR Shared[ctx] THEN {	rSei ¬ ToSei[syms.seb[vSei].idInfo];	WITH r: syms.seb[rSei] SELECT FROM	  id => NULL;	  cons =>	    WITH r SELECT FROM	      record => {		[n, match] ¬ SearchRecordSegment[hti, LOOPHOLE[rSei], FALSE];		IF nHits = 0 THEN sei ¬ match;		nHits ¬ nHits + n};	      ENDCASE => ERROR;	  ENDCASE};      ENDLOOP;    RETURN};  SearchRecord: PROC [hti: HTIndex, type: RecordSEIndex]      RETURNS [nHits: CARDINAL, sei: ISEIndex] = {    rSei: RecordSEIndex;    suffixed: BOOLEAN;    rSei ¬ type;  suffixed ¬ FALSE;    UNTIL rSei = RecordSENull DO      [nHits, sei] ¬ SearchRecordSegment[hti, rSei, suffixed];      IF nHits # 0 THEN RETURN;      rSei ¬ WITH syms.seb[rSei] SELECT FROM	linked => LOOPHOLE[UnderType[syms, linkType]],	ENDCASE => RecordSENull;      suffixed ¬ TRUE;      ENDLOOP;    RETURN [0, ISENull]};-- management of restricted contexts  Shared: PUBLIC PROC [ctx: CTXIndex] RETURNS [BOOLEAN] = {    RETURN [WITH c: syms.ctxb[ctx] SELECT FROM      included => syms.mdb[c.module].shared,      imported => Shared[c.includeLink],      ENDCASE => TRUE]};              CtxRestriction: TYPE = RECORD [ctx: IncludedCTXIndex, list: Tree.Link];  CtxIdTable: TYPE = RECORD [SEQUENCE length: CARDINAL OF CtxRestriction];  ctxIdTable: LONG POINTER TO CtxIdTable;  CtxHash: PROC [ctx: IncludedCTXIndex] RETURNS [CARDINAL] = INLINE {    RETURN [(LOOPHOLE[ctx, CARDINAL]/SIZE[included CTXRecord]) MOD ctxIdTable.length]};  MakeIdTable: PUBLIC PROC [nIdLists: CARDINAL] = {    ctxIdTable ¬ zone.NEW[CtxIdTable[nIdLists]];    FOR i: CARDINAL IN [0..nIdLists) DO ctxIdTable[i] ¬ [IncludedCTXNull, Tree.Null] ENDLOOP};  EnterIdList: PUBLIC PROC [ctx: IncludedCTXIndex, list: Tree.Link] = {    i: CARDINAL ¬ CtxHash[ctx];    DO      IF ctxIdTable[i].ctx = IncludedCTXNull THEN {ctxIdTable[i] ¬ [ctx, list]; EXIT};      IF (i ¬ i+1) = ctxIdTable.length THEN i ¬ 0;      ENDLOOP};  CheckRestrictedCtx: PROC [hti: HTIndex, ctx: IncludedCTXIndex]      RETURNS [sei: ISEIndex] = {    TestId: TreeOps.Test = {      WITH t SELECT FROM	hash => IF index = hti THEN sei ¬ dataPtr.seAnon;	symbol => IF syms.seb[index].hash = hti THEN sei ¬ index;	ENDCASE;      RETURN [sei # ISENull]};    i: CARDINAL ¬ CtxHash[ctx];    DO      IF ctxIdTable[i].ctx = ctx THEN EXIT;      IF (i ¬ i+1) = ctxIdTable.length THEN i ¬ 0;      ENDLOOP;    sei ¬ ISENull;  SearchList[syms, ctxIdTable[i].list, TestId];    IF sei # ISENull AND syms.seb[sei].idCtx = CTXNull THEN syms.seb[sei].idCtx ¬ ctx;    RETURN};  SearchRestrictedCtx: PROC [hti: HTIndex, ctx: IncludedCTXIndex]      RETURNS [sei: ISEIndex] = {    sei ¬ CheckRestrictedCtx[hti, ctx];    IF sei # ISENull AND sei # dataPtr.seAnon AND syms.seb[sei].idCtx # ctx THEN {      [ , sei] ¬ Copier.SearchFileCtx[syms, hti, ctx];      syms.seb[sei].public ¬ TRUE};	-- second copy, access already checked    RETURN};  CheckDirectoryIds: TreeOps.Scan = {        CheckId: TreeOps.Scan = {      WITH t SELECT FROM	symbol => IF syms.seb[index].idCtx = CTXNull THEN Log.WarningSei[unusedId, index];	ENDCASE};    node: Tree.Index = GetNode[syms, t];    saveIndex: CARDINAL = dataPtr.textIndex;    dataPtr.textIndex ¬ DecodeCard[syms.tb[node].info];    ScanList[syms, syms.tb[node].son[3], CheckId];    dataPtr.textIndex ¬ saveIndex};  CheckDisjoint: PUBLIC PROC [ctx1, ctx2: CTXIndex] = {    hti: HTIndex;    saveIndex: CARDINAL = dataPtr.textIndex;    IF ctx1 # CTXNull AND ctx2 # CTXNull THEN      FOR sei: ISEIndex ¬ FirstCtxSe[syms, ctx2], NextSe[syms, sei] UNTIL sei = ISENull DO	hti ¬ syms.seb[sei].hash;	IF hti # HTNull AND SearchContext[syms, hti, ctx1] # ISENull THEN {	  IF ~syms.seb[sei].mark3 THEN	    dataPtr.textIndex ¬ 	      DecodeCard[syms.tb[ToTreeIndex[syms.seb[sei].idValue]].info];	  Log.ErrorHti[duplicateId, hti]};	ENDLOOP;    dataPtr.textIndex ¬ saveIndex};-- basing management  OpenedType: PROC [type: CSEIndex] RETURNS [CSEIndex] = {    subType: CSEIndex = NormalType[syms, type];    RETURN [WITH syms.seb[subType] SELECT FROM      ref => UnderType[syms, refType],      ENDCASE => type]};  OpenPointer: PUBLIC PROC [t: Tree.Link, type: CSEIndex]     RETURNS [Tree.Link, CSEIndex] = {    nType, rType: CSEIndex;    nDerefs: CARDINAL ¬ 0;    DO      nType ¬ NormalType[syms, type];      WITH p: syms.seb[nType] SELECT FROM	ref => {	  rType ¬ UnderType[syms, p.refType];	  IF P3S.safety = checked AND ~p.counted THEN 	    Log.ErrorTree[unsafeOperation, t];	  IF syms.seb[NormalType[syms, rType]].typeTag # ref THEN EXIT;	  IF (nDerefs ¬ nDerefs+1) > 63 THEN EXIT};	ENDCASE;      [t, type] ¬ DeRef[t, type];      ENDLOOP;    RETURN [t, rType]};  BaseTree: PUBLIC PROC [t: Tree.Link, type: CSEIndex] RETURNS [val: Tree.Link] = {    PushTree[syms, t];  PushNode[syms, openx, 1];      SetInfo[syms, EncodeSei[type]];  SetAttr[syms, 1, FALSE];    val ¬ PopTree[syms];  SetShared[syms, val, TRUE];  RETURN};  OpenBase: PUBLIC PROC [t: Tree.Link, hti: HTIndex] RETURNS [v: Tree.Link] = {    type, vType, nType: CSEIndex;        OpenRecord: PROC [indirect: BOOLEAN] = {      WITH syms.seb[type] SELECT FROM	record => {	  v ¬ BaseTree[v, vType];	  IF hti # HTNull THEN PushHtCtx[hti, v, indirect]	  ELSE PushRecordCtx[LOOPHOLE[type, RecordSEIndex], v, indirect]};	ENDCASE => IF type # typeANY THEN Log.ErrorTree[typeClash, v]};    v ¬ Exp[t, typeANY];    type ¬ vType ¬ RType[];  nType ¬ NormalType[syms, vType];  RPop[];    WITH syms.seb[nType] SELECT FROM      definition, transfer => {        ctx: CTXIndex = InterfaceCtx[nType, v];	IF ctx = CTXNull THEN OpenRecord[FALSE]	ELSE IF hti # HTNull THEN PushHtCtx[hti, v, FALSE]	ELSE PushCtx[ctx]};      ref => {	[v, type] ¬ OpenPointer[v, vType];  vType ¬ OperandType[v];	OpenRecord[TRUE]};      ENDCASE => OpenRecord[FALSE];    RETURN};  CloseBase: PUBLIC PROC [t: Tree.Link, hti: HTIndex] = {    type: CSEIndex;        CloseRecord: PROC = {WITH syms.seb[type] SELECT FROM record => PopCtx[]; ENDCASE};    type ¬ NormalType[syms, OperandType[t]];    WITH syms.seb[type] SELECT FROM      definition => PopCtx[];      ref => {type ¬ UnderType[syms, refType]; CloseRecord[]};      ENDCASE => CloseRecord[]};-- initialization/finalization  Pass3IInit: PUBLIC PROC [h: SymbolTable.Handle, scratchZone: UNCOUNTED ZONE] = {    syms ¬ h;    zone ¬ scratchZone;    refStack ¬ zone.NEW[RefSequence[16]];    refIndex ¬ 0;    ctxStack ¬ MakeStack[2*ContextIncr];  ctxIndex ¬ -1};  IdReset: PUBLIC TreeOps.Scan = {    ScanList[syms, t, CheckDirectoryIds];    zone.FREE[@ctxIdTable];  zone.FREE[@ctxStack];    zone.FREE[@refStack];    zone ¬ NIL;    syms ¬ NIL };  }.
-- Copyright (C) 1983, 1984, 1986  by Xerox Corporation. All rights reserved. -- file Pass4Xa.mesa-- Satterthwaite,	October 1, 1982 4:14 pm-- Sweet,		11-Jan-84 13:49:02-- Johnsson,		11-Jun-83 14:20:34-- Wagner		20-Aug-86  9:53:10DIRECTORY  ComData USING [switches, typeINT, typeCARDINAL, typeCHAR],  Environment USING [bitsPerByte, bitsPerWord, maxCARDINAL, maxINTEGER],  Inline USING [BITAND, BITOR, BITSHIFT],  Literals USING [LitDescriptor],  LiteralOps USING [ValueDescriptor, FindDescriptor, MasterString],  CLog USING [Error, ErrorN, ErrorSei, ErrorTree],  OSMiscOps USING [FreeWords, Words],  P4 USING [    Attr, voidAttr, Covering, Prop, emptyProp, voidProp,    Repr, none, signed, unsigned, both, other, RegCount, maxRegs,    checked, CheckOver,    AdjustBias, BiasForType, BitsForType, CatchNest, CommonProp, ComputeIndexRegs,    Exp, ForceType, MakeStructuredLiteral, MakeTreeLiteral, NeutralExp,    OperandType, RegsForType, RepForType, RValue, StructuredLiteral, Subst,    TreeLiteral, TreeLiteralDesc, TreeLiteralValue, TypeExp, TypeForTree,    VAttr, VBias, VPop, VProp, VPush, VRegs, VRep, WordsForType, ZeroP],  Pass4 USING [implicitAttr, implicitBias, implicitType],  Symbols USING [    BitAddress, SEIndex, ISEIndex, CSEIndex, ArraySEIndex, RecordSEIndex,    ISENull, RecordSENull, typeANY],  SymbolOps USING [    ArgRecord, BitsPerElement, Cardinality, FirstVisibleSe, FnField, NextSe,    RCType, RecordRoot, UnderType, VariantField, ToBitAddr, ToCard],  SymbolTable USING [Handle],  Tree USING [Index, Link, Null],  TreeOps USING [    FreeNode, FreeTree, GetNode, GetSe, ListLength, Map, NthSon, OpName, PopTree,    PushTree, PushLit, PushNode, Scan, ScanList, SetAttr, SetInfo, UpdateList,    DecodeSei, DecodeCSei, EncodeSei],  Types USING [Assignable];Pass4Xa: PROGRAM    IMPORTS      Inline, Log: CLog, LiteralOps, OSMiscOps, P4, SymbolOps, TreeOps, Types,      dataPtr: ComData, passPtr: Pass4    EXPORTS P4 = {  OPEN SymbolOps, TreeOps, P4; -- pervasive definitions from Symbols  SEIndex: TYPE = Symbols.SEIndex;  ISEIndex: TYPE = Symbols.ISEIndex;  CSEIndex: TYPE = Symbols.CSEIndex;  RecordSEIndex: TYPE = Symbols.RecordSEIndex;  BitAddress: TYPE = Symbols.BitAddress;  syms: SymbolTable.Handle ¬ NIL;    Pass4XaInit: PUBLIC PROC [h: SymbolTable.Handle] = { syms ¬ h };   -- expression list manipulation  Safen: PROC [t: Tree.Link, prop: Prop, type: CSEIndex] RETURNS [Tree.Link] = {    PushTree[syms, t];    IF ~prop.noXfer OR (~prop.noAssign AND RCType[syms, type] # none) THEN      SELECT OpName[syms, t] FROM	construct, union, rowcons, all => NULL;	ENDCASE => {PushNode[syms, safen, 1]; SetInfo[syms, EncodeSei[type]]};    RETURN [PopTree[syms]]};  MakeRecord: PROC [record: RecordSEIndex, expList: Tree.Link] RETURNS [val: Tree.Link] = {    sei: ISEIndex;    const: BOOLEAN ¬ TRUE;    prop: Prop ¬ voidProp;    nRegs: RegCount ¬ 0;    EvaluateField: TreeOps.Map = {      type: CSEIndex = UnderType[syms, syms.seb[sei].idType];      IF t = Tree.Null THEN {	v ¬ Tree.Null;	IF BitsForType[type] # 0 OR VariantType[type] THEN const ¬ FALSE}      ELSE {	subProp: Prop;	v ¬ Rhs[t, type];	IF ~TreeLiteral[v] THEN	  WITH v SELECT FROM	    subtree =>	      SELECT syms.tb[index].name FROM	        mwconst => NULL;	        union => IF ~syms.tb[index].attr1 THEN const ¬ FALSE;	        ENDCASE => const ¬ FALSE;	    ENDCASE => const ¬ FALSE;	subProp ¬ VProp[];  nRegs ¬ MAX[VRegs[], nRegs];  VPop[];	v ¬ Safen[v, subProp, type];	prop ¬ CommonProp[prop, subProp]};      sei ¬ NextSe[syms, sei];      RETURN};    sei ¬ FirstVisibleSe[syms, syms.seb[record].fieldCtx];    val ¬ UpdateList[syms, expList, EvaluateField];    IF OpName[syms, val] = list THEN {      subNode: Tree.Index = GetNode[syms, val];      syms.tb[subNode].attr1 ¬ const};    VPush[BiasForType[record], [prop: prop, rep: other], nRegs];    RETURN};    VariantType: PROC [type: CSEIndex] RETURNS [BOOLEAN] = INLINE {      RETURN [SELECT syms.seb[type].typeTag FROM	union, sequence => TRUE,	ENDCASE => FALSE]};  MakeArgRecord: PUBLIC PROC [record: RecordSEIndex, expList: Tree.Link]      RETURNS [val: Tree.Link] = {    SELECT TRUE FROM      (expList = Tree.Null) => {val ¬ Tree.Null; VPush[0, voidAttr, 0]};      (record = Symbols.RecordSENull) => {val ¬ FreeTree[syms, expList]; VPush[0, voidAttr, 0]};      (OpName[syms, expList] = list) => val ¬ MakeRecord[record, expList];      ENDCASE => {	type: CSEIndex = UnderType[syms, syms.seb[FirstVisibleSe[syms, syms.seb[record].fieldCtx]].idType];	val ¬ Rhs[expList, type]};    RETURN};  -- construction of packed values (machine dependent)  WordLength: CARDINAL = Environment.bitsPerWord;  ByteLength: CARDINAL = Environment.bitsPerByte;  FillMultiWord: PUBLIC PROC [      words: LiteralOps.ValueDescriptor, origin: CARDINAL, t: Tree.Link] = {    desc: Literals.LitDescriptor = TreeLiteralDesc[t];    IF origin + desc.length <= LENGTH[words] THEN      FOR i: CARDINAL IN [0 .. desc.length) DO words[origin+i] ¬ syms.ltb[desc.offset][i] ENDLOOP};  PackRecord: PROC [record: RecordSEIndex, expList: Tree.Link] RETURNS [Tree.Link] = {    n: CARDINAL = WordsForType[record];    root, type: RecordSEIndex;    list: Tree.Link;    sei: ISEIndex;    offset: CARDINAL;    words: LiteralOps.ValueDescriptor;    more: BOOLEAN;    StoreBits: PROC [sei: ISEIndex, value: WORD] = {      OPEN Inline;      Masks: ARRAY [0..WordLength] OF WORD =	[0b, 1b, 3b, 7b, 17b, 37b, 77b, 177b, 377b, 777b,	 1777b, 3777b, 7777b, 17777b, 37777b, 77777b, 177777b];      address: BitAddress;      size, w, shift: CARDINAL;      IF syms.seb[root].argument THEN [address, size] ¬ FnField[syms, sei]      ELSE {address ¬ ToBitAddr[syms.seb[sei].idValue]; size ¬ ToCard[syms.seb[sei].idInfo]};      w ¬ address.wd;      shift ¬ (WordLength-offset) - (address.bd+size);      words[w] ¬ BITOR[words[w], BITSHIFT[BITAND[value, Masks[size]], shift]]};    PackField: TreeOps.Scan = {      node: Tree.Index;      address: BitAddress;      typeId: ISEIndex;      subType: CSEIndex;      SELECT TRUE FROM	t = Tree.Null => NULL;        TreeLiteral[t] => StoreBits[sei, TreeLiteralValue[t]];	ENDCASE => {	  node ¬ GetNode[syms, t];	  SELECT syms.tb[node].name FROM	    mwconst => {	      address ¬ IF syms.seb[root].argument	        THEN FnField[syms, sei].offset		ELSE ToBitAddr[syms.seb[sei].idValue];	      FillMultiWord[words, address.wd, syms.tb[node].son[1]]};	    union => {	      typeId ¬ WITH syms.tb[node].son[1] SELECT FROM		symbol => index,		ENDCASE => ERROR;	      subType ¬ UnderType[syms, syms.seb[sei].idType];	      WITH syms.seb[subType] SELECT FROM		union => IF controlled THEN 		  StoreBits[tagSei, LOOPHOLE[syms.seb[typeId].idValue]];		ENDCASE => ERROR;	      type ¬ LOOPHOLE[UnderType[syms, typeId], RecordSEIndex];	      list ¬ syms.tb[node].son[2];  more ¬ TRUE};	    ENDCASE => ERROR};      sei ¬ NextSe[syms, sei]};    words ¬ DESCRIPTOR[OSMiscOps.Words[n], n];    FOR i: CARDINAL IN [0 .. n) DO words[i] ¬ 0 ENDLOOP;    root ¬ type ¬ RecordRoot[syms, record];    offset ¬ IF syms.seb[record].length < WordLength		THEN WordLength - syms.seb[record].length		ELSE 0;    list ¬ expList;  more ¬ TRUE;    WHILE more DO      more ¬ FALSE;  sei ¬ FirstVisibleSe[syms, syms.seb[type].fieldCtx];      ScanList[syms, list, PackField];      ENDLOOP;    PushLit[syms, LiteralOps.FindDescriptor[syms, words]];    PushNode[syms, IF n=1 THEN cast ELSE mwconst, 1];  SetInfo[syms, EncodeSei[record]];    OSMiscOps.FreeWords[BASE[words]];    RETURN [PopTree[syms]]};    PadRecord: PUBLIC PROC [t: Tree.Link, lType: CSEIndex] RETURNS [Tree.Link] = {    IF StructuredLiteral[t] THEN {      nW: CARDINAL = WordsForType[lType];      words: LiteralOps.ValueDescriptor;      node: Tree.Index;      words ¬ DESCRIPTOR[OSMiscOps.Words[nW], nW];      FOR w: CARDINAL IN [0 .. nW) DO words[w] ¬ 0 ENDLOOP;      IF TreeLiteral[t] THEN words[0] ¬ TreeLiteralValue[t]      ELSE {	node ¬ GetNode[syms, t];	SELECT syms.tb[node].name FROM	      mwconst => FillMultiWord[words, 0, syms.tb[node].son[1]];	      ENDCASE => ERROR;	FreeNode[syms, node]};      PushLit[syms, LiteralOps.FindDescriptor[syms, words]];  PushNode[syms, mwconst, 1];      OSMiscOps.FreeWords[BASE[words]]}    ELSE {PushTree[syms, t]; PushNode[syms, pad, 1]};    SetInfo[syms, EncodeSei[lType]];    RETURN [PopTree[syms]]};  ExtractValue: PROC [t: Tree.Link, addr: BitAddress, size: CARDINAL, type: CSEIndex]      RETURNS [val: Tree.Link] = {    words: LiteralOps.ValueDescriptor;    desc: Literals.LitDescriptor = TreeLiteralDesc[t];    n: CARDINAL = size/WordLength;    IF n > 1 THEN {      IF addr.bd # 0 THEN Log.Error[unimplemented];      words ¬ DESCRIPTOR[OSMiscOps.Words[n], n];      FOR i: CARDINAL IN [0..n) DO words[i] ¬ syms.ltb[desc.offset][addr.wd+i] ENDLOOP;      PushLit[syms, LiteralOps.FindDescriptor[syms, words]];      PushNode[syms, mwconst, 1];  SetInfo[syms, EncodeSei[type]];      OSMiscOps.FreeWords[BASE[words]];      val ¬ PopTree[syms]}    ELSE      val ¬ MakeStructuredLiteral[		Inline.BITSHIFT[		  Inline.BITSHIFT[syms.ltb[desc.offset][addr.wd], addr.bd],		  -(WordLength - size)],		type];    RETURN};  UnpackField: PROC [t: Tree.Link, field: ISEIndex] RETURNS [val: Tree.Link] = {    rType: CSEIndex = OperandType[t];    vType: CSEIndex = UnderType[syms, syms.seb[field].idType];    addr: BitAddress;    addr ¬ ToBitAddr[syms.seb[field].idValue];    WITH r: syms.seb[rType] SELECT FROM      record =>	IF r.length < WordLength THEN addr.bd ¬ addr.bd + (WordLength - r.length);      ENDCASE => ERROR;    RETURN [ExtractValue[t, addr, ToCard[syms.seb[field].idInfo], vType]]};  UnpackElement: PROC [t: Tree.Link, i: CARDINAL] RETURNS [val: Tree.Link] = {    aType: CSEIndex = OperandType[t];    cType: CSEIndex;    addr: BitAddress;    nB, nW: CARDINAL;    WITH a: syms.seb[aType] SELECT FROM      array => {	cType ¬ UnderType[syms, a.componentType];	nB ¬ P4.CheckOver[BitsPerElement[syms, cType, a.packed]];	IF nB > ByteLength THEN {	  nW ¬ (nB+(WordLength-1))/WordLength;	  addr ¬ [wd:i*nW, bd:0];  nB ¬ nW*WordLength}	ELSE {	  itemsPerWord: CARDINAL = WordLength/nB;	  offset: CARDINAL = P4.CheckOver[IF WordsForType[aType] = 1				THEN WordLength - BitsForType[aType]				ELSE 0];	  addr ¬ [wd: i/itemsPerWord, bd: offset + (i MOD itemsPerWord)*nB]}};      ENDCASE => ERROR;    RETURN [ExtractValue[t, addr, nB, cType]]}; -- operators  Substx: PUBLIC PROC [node: Tree.Index] RETURNS [val: Tree.Link] = {    type: CSEIndex = DecodeCSei[syms.tb[node].info];    IF OpName[syms, syms.tb[node].son[2]] = result THEN {      saveChecked: BOOLEAN = checked;      subNode: Tree.Index = GetNode[syms, syms.tb[node].son[2]];      IF ~syms.tb[node].attr3 THEN checked ¬ syms.tb[node].attr1;      syms.tb[node].son[1] ¬ NeutralExp[syms, syms.tb[node].son[1]];      SELECT ListLength[syms, syms.tb[subNode].son[1]] FROM	0 => ERROR;	1 => {	  val ¬ 	  -- attr3 means bracketless return	  -- IF syms.tb[subNode].attr3	  --  THEN syms.tb[subNode].son[1]	  --  ELSE 	  -- causes potential size missmatches to be padded or chopped	  ForceType[syms.tb[subNode].son[1], type]};	ENDCASE => {	  PushTree[syms, Tree.Null];  PushTree[syms, syms.tb[subNode].son[1]];	  PushNode[syms, construct, 2];  	  SetInfo[syms, EncodeSei[type]];  val ¬ PopTree[syms]};      syms.tb[subNode].son[1] ¬ Tree.Null;  FreeNode[syms, node];      val ¬ Rhs[val, type];      checked ¬ saveChecked}    ELSE {      val ¬ Subst[node];      VPush[        BiasForType[type], [prop: emptyProp, rep: RepForType[type]], maxRegs]};    RETURN};  Call: PUBLIC PROC [node: Tree.Index] RETURNS [Tree.Link] = {    OPEN syms.tb[node];    type: CSEIndex;    prop: Prop;    son[1] ¬ Exp[son[1], none];  prop ¬ VProp[];  VPop[];    type ¬ OperandType[son[1]];    WITH t: syms.seb[type] SELECT FROM      transfer => {	IF attr1 AND name # xerror AND t.typeIn # Symbols.RecordSENull THEN	  son[2] ¬ Rhs[son[2], t.typeIn]	ELSE son[2] ¬ MakeArgRecord[ArgRecord[syms, t.typeIn], son[2]];	prop ¬ CommonProp[prop, VProp[]]; VPop[];	prop.noXfer ¬ prop.noAssign ¬ prop.noFreeVar ¬ FALSE;	IF nSons > 2 THEN CatchNest[son[3]];	VPush[BiasForType[t.typeOut], [prop: prop, rep: RepForType[t.typeOut]], maxRegs]};      ENDCASE => ERROR;    RETURN [[subtree[index: node]]]};  Construct: PUBLIC PROC [node: Tree.Index] RETURNS [val: Tree.Link] = {    OPEN syms.tb[node];    type: RecordSEIndex = LOOPHOLE[info];    record: RecordSEIndex = RecordRoot[syms, type];    prop: Prop;    nRegs: RegCount;    k: RegCount = RegsForType[type];    SELECT TRUE FROM      (OpName[syms, son[2]] = list) => {	subNode: Tree.Index;	son[2] ¬ MakeRecord[record, son[2]];  nRegs ¬ VRegs[];  prop ¬ VProp[];	subNode ¬ GetNode[syms, son[2]];	IF ~syms.tb[subNode].attr1 THEN {	-- ~all fields constant	  val ¬ [subtree[index: node]]; nRegs ¬ MAX[nRegs, k]}	ELSE {val ¬ PackRecord[type, son[2]]; FreeNode[syms, node]; nRegs ¬ k};	VPop[];  VPush[0, [prop: prop, rep: other], nRegs]};      (son[2] = Tree.Null) => {        val ¬ Tree.Null;  VPush[0, [prop: voidProp, rep: other], k]};      (OpName[syms, son[2]] = union) => {	son[2] ¬ Union[GetNode[syms, son[2]]];	IF OpName[syms, son[2]] = union THEN {	  subNode: Tree.Index = GetNode[syms, son[2]];	  IF syms.tb[subNode].attr1 THEN {val ¬ PackRecord[type, son[2]]; FreeNode[syms, node]}	  ELSE val ¬ [subtree[index: node]]}	ELSE {val ¬ ForceType[son[2], type]; son[2] ¬ Tree.Null; FreeNode[syms, node]}};      ENDCASE => val ¬ CastUniList[node, type, record];    RETURN};  Union: PUBLIC PROC [node: Tree.Index] RETURNS [val: Tree.Link] = {    OPEN syms.tb[node];    vSei: ISEIndex = WITH son[1] SELECT FROM symbol=>index, ENDCASE=>ERROR;    type: RecordSEIndex = LOOPHOLE[UnderType[syms, vSei]];    tSei: CSEIndex = UnderType[syms, DecodeSei[info]];    tagged: BOOLEAN =      WITH syms.seb[tSei] SELECT FROM union => controlled, ENDCASE => FALSE;    attr: Attr;    nRegs: RegCount;    attr2 ¬ tagged;    SELECT TRUE FROM      (OpName[syms, son[2]] = list OR OpName[syms, son[2]] = union) => {        son[2] ¬ MakeRecord[type, son[2]];  nRegs ¬ VRegs[];  attr ¬ VAttr[];        attr1 ¬ WITH son[2] SELECT FROM subtree => syms.tb[index].attr1, ENDCASE => FALSE;        val ¬ [subtree[index: node]];  VPop[];  attr.rep ¬ other;  VPush[0, attr, nRegs]};      (son[2] = Tree.Null) => {	attr1 ¬ TRUE; val ¬ [subtree[index: node]];	VPush[0, [prop: voidProp, rep: other], 1]};      ENDCASE =>	IF (~tagged OR ToCard[syms.seb[vSei].idValue] = 0) AND WordsForType[type] = 1	 AND ZeroOffset[	   IF tagged THEN TagSei[tSei] ELSE FirstVisibleSe[syms, syms.seb[type].fieldCtx]]	 THEN val ¬ CastUniList[node, tSei, type]	ELSE {	  son[2] ¬ MakeRecord[type, son[2]];  attr ¬ VAttr[];          attr1 ¬ StructuredLiteral[son[2]];	  val ¬ [subtree[index: node]];	  VPop[];  attr.rep ¬ other;  VPush[0, attr, RegsForType[type]]};    RETURN};  TagSei: PROC [tSei: CSEIndex] RETURNS [ISEIndex] = INLINE {    RETURN [WITH syms.seb[tSei] SELECT FROM union => tagSei, ENDCASE => Symbols.ISENull]};  ZeroOffset: PROC [sei: ISEIndex] RETURNS [BOOLEAN] = INLINE {    RETURN [sei # Symbols.ISENull AND ToBitAddr[syms.seb[sei].idValue] = [0, 0]]};  CastUniList: PROC [node: Tree.Index, type: CSEIndex, rType: RecordSEIndex]      RETURNS [val: Tree.Link] = {    target: CSEIndex = UnderType[syms, syms.seb[FirstVisibleSe[syms, syms.seb[rType].fieldCtx]].idType];    prop: Prop;    nRegs: RegCount;    val ¬ ForceType[Rhs[syms.tb[node].son[2], target], type];    prop ¬ VProp[];  nRegs ¬ VRegs[];  VPop[];    syms.tb[node].son[2] ¬ Tree.Null;  FreeNode[syms, node];    VPush[BiasForType[type], [prop: prop, rep: RepForType[type]], nRegs];    RETURN};  RowConstruct: PUBLIC PROC [node: Tree.Index] RETURNS [val: Tree.Link] = {    OPEN syms.tb[node];    aType: Symbols.ArraySEIndex = LOOPHOLE[info];    cType: CSEIndex = UnderType[syms, syms.seb[aType].componentType];    n: CARDINAL = P4.CheckOver[Cardinality[syms, syms.seb[aType].indexType]];    const, strings, lstrings: BOOLEAN;    prop: Prop ¬ voidProp;    nRegs: RegCount ¬ 0;    l: CARDINAL;    EvalElement: TreeOps.Map = {      IF t = Tree.Null THEN {v ¬ Tree.Null; const ¬ strings ¬ lstrings ¬ FALSE}      ELSE {	subProp: Prop;	v ¬ Rhs[t, cType];	IF TreeLiteral[v] THEN strings ¬ lstrings ¬ FALSE	ELSE	  WITH v SELECT FROM	    subtree =>	      SELECT syms.tb[index].name FROM		mwconst => strings ¬ lstrings ¬ FALSE;		ENDCASE => const ¬ strings ¬ lstrings ¬ FALSE;	    literal =>	      WITH info SELECT FROM		string => {		  const ¬ FALSE;		  IF LiteralOps.MasterString[syms, index] = index THEN lstrings ¬ FALSE		  ELSE strings ¬ FALSE};		ENDCASE;	    ENDCASE => const ¬ strings ¬ lstrings ¬ FALSE;	subProp ¬ VProp[];  nRegs ¬ MAX[VRegs[], nRegs];  VPop[];	v ¬ Safen[v, subProp, cType];        prop ¬ CommonProp[prop, subProp]};      RETURN};    w, nW: CARDINAL;    words: LiteralOps.ValueDescriptor;    bitsLeft: CARDINAL;    bitCount: CARDINAL;    PackElement: TreeOps.Scan = {      IF TreeLiteral[t] THEN {	bitsLeft ¬ bitsLeft - bitCount;	words[w] ¬ Inline.BITOR[words[w],		  Inline.BITSHIFT[TreeLiteralValue[t], bitsLeft]];	IF bitsLeft < bitCount THEN {w ¬ w+1; bitsLeft ¬ WordLength}}      ELSE {	node: Tree.Index = GetNode[syms, t];	SELECT syms.tb[node].name FROM	  mwconst => {	    FillMultiWord[words, w, syms.tb[node].son[1]];	    w ¬ w + WordsForType[cType]};	  ENDCASE => ERROR}};    SELECT (l ¬ ListLength[syms, son[2]]) FROM      = n => NULL;      > n => Log.ErrorN[listLong, l-n];      < n => Log.ErrorN[listShort, n-l];      ENDCASE;    const ¬ strings ¬ lstrings ¬ TRUE;  nRegs ¬ 0;    son[2] ¬ UpdateList[syms, son[2], EvalElement];    IF const AND l = n THEN {      nW ¬ WordsForType[aType];      words ¬ DESCRIPTOR[OSMiscOps.Words[nW], nW];      FOR w: CARDINAL IN [0 .. nW) DO words[w] ¬ 0 ENDLOOP;      bitCount ¬ P4.CheckOver[BitsPerElement[syms, cType, syms.seb[aType].packed]];      w ¬ 0;  bitsLeft ¬ IF nW = 1 THEN P4.CheckOver[BitsForType[aType]] ELSE WordLength;      ScanList[syms, son[2], PackElement];  FreeNode[syms, node];      PushLit[syms, LiteralOps.FindDescriptor[syms, words]];      PushNode[syms, IF nW = 1 THEN cast ELSE mwconst, 1];        SetInfo[syms, EncodeSei[aType]];      OSMiscOps.FreeWords[BASE[words]];      val ¬ PopTree[syms];  nRegs ¬ RegsForType[aType]}    ELSE {      IF (attr1 ¬ strings # lstrings) THEN prop.noFreeVar ¬ FALSE;      val ¬ [subtree[index: node]]};    VPush[0, [prop: prop, rep: other], nRegs];  RETURN};  All: PUBLIC PROC [node: Tree.Index] RETURNS [val: Tree.Link] = {    OPEN syms.tb[node];    aType: Symbols.ArraySEIndex = LOOPHOLE[info];    cType: CSEIndex = UnderType[syms, syms.seb[aType].componentType];    prop: Prop;    val ¬ [subtree[index: node]];    IF son[1] = Tree.Null THEN prop ¬ voidProp    ELSE {      son[1] ¬ Rhs[son[1], cType];      IF TreeLiteral[son[1]] AND WordsForType[aType] = 1 THEN {	nB: CARDINAL = P4.CheckOver[BitsPerElement[syms, cType, syms.seb[aType].packed]];	v, w: WORD;	v ¬ TreeLiteralValue[son[1]];  w ¬ 0;	THROUGH [1 .. Cardinality[syms, syms.seb[aType].indexType]] DO	  w ¬ Inline.BITOR[Inline.BITSHIFT[w, nB], v] ENDLOOP;	val ¬ ForceType[MakeTreeLiteral[w], aType];  FreeNode[syms, node]}      ELSE IF OperandType[son[1]] # cType THEN son[1] ¬ ForceType[son[1], cType];      prop ¬ VProp[];  VPop[];      son[1] ¬ Safen[son[1], prop, cType]};    VPush[0, [prop: prop, rep: other], RegsForType[aType]];    RETURN};  Dollar: PUBLIC PROC [node: Tree.Index] RETURNS [val: Tree.Link] = {    OPEN syms.tb[node];    attr: Attr;    bias: INTEGER;    sei: ISEIndex;    nRegs: RegCount;    k: RegCount = RegsForType[DecodeCSei[info]];    son[1] ¬ RValue[son[1], BiasForType[OperandType[son[1]]], none];    nRegs ¬ VRegs[];  attr.prop ¬ VProp[];  VPop[];    son[2] ¬ Exp[son[2], none];  attr.rep ¬ VRep[];  bias ¬ VBias[];    sei ¬ TreeOps.GetSe[syms, son[2]];    IF syms.seb[sei].constant THEN Log.ErrorSei[noFrameProcs, sei];    IF ~StructuredLiteral[son[1]] THEN {      val ¬ [subtree[index: node]]; nRegs ¬ MAX[nRegs, k];      attr.prop ¬ CommonProp[attr.prop, VProp[]];  attr.prop.noSelect ¬ FALSE}    ELSE      WITH son[2] SELECT FROM	symbol => {val ¬ UnpackField[son[1], index]; FreeNode[syms, node]; nRegs ¬ k};	ENDCASE => ERROR;    VPop[];    VPush[bias, attr, nRegs];  RETURN};  Index: PUBLIC PROC [node: Tree.Index] RETURNS [val: Tree.Link] = {    OPEN syms.tb[node];    iType, cType: CSEIndex;    next: SEIndex;    prop: Prop;    nRegs: RegCount;    son[1] ¬ Exp[son[1], none];  prop ¬ VProp[];    FOR aType: CSEIndex ¬ OperandType[son[1]], UnderType[syms, next] DO      WITH syms.seb[aType] SELECT FROM	array => {	  iType ¬ UnderType[syms, indexType]; cType ¬ UnderType[syms, componentType]; EXIT};	arraydesc => next ¬ describedType;	long => next ¬ rangeType;	ENDCASE => ERROR;      ENDLOOP;    IF name = dindex THEN {      son[2] ¬ RValue[son[2], BiasForType[iType], unsigned];      attr1 ¬ checked OR dataPtr.switches['n];      attr3 ¬ checked OR dataPtr.switches['b]}    ELSE son[2] ¬ Rhs[son[2], iType, TRUE];    prop ¬ CommonProp[prop, VProp[]];    SELECT TRUE FROM      (TreeLiteral[son[2]] AND OpName[syms, son[1]] = all) => {	subNode: Tree.Index = GetNode[syms, son[1]];	val ¬ syms.tb[subNode].son[1];	syms.tb[subNode].son[1] ¬ Tree.Null;  FreeNode[syms, node];	nRegs ¬ RegsForType[cType]};      (TreeLiteral[son[2]] AND  name = index AND StructuredLiteral[son[1]]) => {	val ¬ UnpackElement[son[1], TreeLiteralValue[son[2]]]; FreeNode[syms, node];	nRegs ¬ RegsForType[cType]};      ENDCASE => {	val ¬ [subtree[index:node]];	nRegs ¬ ComputeIndexRegs[node]; prop.noSelect ¬ FALSE};    VPop[]; VPop[];    VPush[BiasForType[cType], [prop: prop, rep: RepForType[cType]], nRegs];    RETURN};  SeqIndex: PUBLIC PROC [node: Tree.Index] RETURNS [Tree.Link] = {    OPEN syms.tb[node];    iType, cType, sType: CSEIndex;    prop: Prop;    nRegs: RegCount;    son[1] ¬ Exp[son[1], none];  prop ¬ VProp[];    sType ¬ OperandType[son[1]];    WITH t: syms.seb[sType] SELECT FROM      sequence => {	iType ¬ UnderType[syms, syms.seb[t.tagSei].idType]; cType ¬ UnderType[syms, t.componentType];	attr3 ¬ t.controlled AND (checked OR dataPtr.switches['b])};      array => {	iType ¬ UnderType[syms, t.indexType]; cType ¬ UnderType[syms, t.componentType];	attr3 ¬ checked OR dataPtr.switches['b]};      ENDCASE;    son[2] ¬ RValue[son[2], BiasForType[iType], TargetRep[RepForType[iType]]];    nRegs ¬ ComputeIndexRegs[node];    prop ¬ CommonProp[prop, VProp[]]; prop.noSelect ¬ FALSE;  VPop[]; VPop[];    VPush[BiasForType[cType], [prop: prop, rep: RepForType[cType]], nRegs];    RETURN [[subtree[index:node]]]};  Reloc: PUBLIC PROC [node: Tree.Index] RETURNS [val: Tree.Link] = {    prop: Prop;    nRegs: RegCount;    type: CSEIndex = DecodeCSei[syms.tb[node].info];    syms.tb[node].son[1] ¬ RValue[syms.tb[node].son[1], 0, unsigned];  prop ¬ VProp[];    syms.tb[node].son[2] ¬ RValue[syms.tb[node].son[2], 0, unsigned];  prop ¬ CommonProp[prop, VProp[]];    nRegs ¬ ComputeIndexRegs[node];  VPop[]; VPop[];    IF ~syms.tb[node].attr1 AND ZeroP[syms.tb[node].son[1]] THEN {      rType, subType, next: CSEIndex;      FOR subType ¬ OperandType[syms.tb[node].son[2]], next DO    -- CanonicalType	WITH r: syms.seb[subType] SELECT FROM	  relative => {	    rType ¬ UnderType[syms, r.resultType];	    PushTree[syms, syms.tb[node].son[2]];  syms.tb[node].son[2] ¬ Tree.Null;	    IF syms.tb[node].attr2 AND syms.seb[UnderType[syms, r.offsetType]].typeTag # long THEN {	      PushNode[syms, lengthen, 1];	      SetAttr[syms, 1, FALSE]; SetAttr[syms, 2, FALSE]; SetAttr[syms, 3, FALSE]}	    ELSE PushNode[syms, cast, 1];	    EXIT};	  record => next ¬ UnderType[syms, syms.seb[FirstVisibleSe[syms, r.fieldCtx]].idType];	  ENDCASE => ERROR;	ENDLOOP;      SetInfo[syms, EncodeSei[rType]];      PushNode[syms, uparrow, 1];  SetInfo[syms, EncodeSei[type]];      SetAttr[syms, 1, dataPtr.switches['n]];  SetAttr[syms, 2, syms.tb[node].attr2];      val ¬ PopTree[syms];  FreeNode[syms, node]}    ELSE val ¬ [subtree[node]];    prop.noSelect ¬ FALSE;    VPush[BiasForType[type], [prop: prop, rep: RepForType[type]], nRegs];    RETURN};  Assignment: PUBLIC PROC [node: Tree.Index] RETURNS [Tree.Link] = {    OPEN syms.tb[node];    lhsType: CSEIndex;    bias: INTEGER;    attr: Attr;    nRegs: RegCount;    son[1] ¬ Exp[son[1], none];    bias ¬ VBias[]; attr ¬ VAttr[]; nRegs ¬ VRegs[];    lhsType ¬ OperandType[son[1]];    son[2] ¬ Rhs[son[2], lhsType];    attr.prop ¬ CommonProp[attr.prop, VProp[]]; attr.prop.noAssign ¬ FALSE;    VPop[]; VPop[];  VPush[bias, attr, nRegs];    RETURN [RewriteAssign[node, lhsType]]};  Extract: PUBLIC PROC [node: Tree.Index] RETURNS [Tree.Link] = {    subNode: Tree.Index = GetNode[syms, syms.tb[node].son[1]];    rType: RecordSEIndex = LOOPHOLE[syms.tb[subNode].info];    prop: Prop ¬ voidProp;    sei: ISEIndex;    AssignItem: TreeOps.Map = {      type: CSEIndex;      saveType: CSEIndex = passPtr.implicitType;      saveBias: INTEGER = passPtr.implicitBias;      saveAttr: Attr = passPtr.implicitAttr;      IF t = Tree.Null THEN v ¬ Tree.Null      ELSE {	subNode: Tree.Index = GetNode[syms, t];	type ¬ UnderType[syms, syms.seb[sei].idType];	passPtr.implicitType ¬ type;	passPtr.implicitBias ¬ BiasForType[type];  passPtr.implicitAttr.rep ¬ RepForType[type];	v ¬ IF syms.tb[subNode].name = extract THEN Extract[subNode] ELSE Assignment[subNode];	prop ¬ CommonProp[prop, VProp[]];  VPop[]};      sei ¬ NextSe[syms, sei];      passPtr.implicitAttr ¬ saveAttr;  passPtr.implicitBias ¬ saveBias;      passPtr.implicitType ¬ saveType;  RETURN};    sei ¬ FirstVisibleSe[syms, syms.seb[rType].fieldCtx];    syms.tb[subNode].son[1] ¬ UpdateList[syms, syms.tb[subNode].son[1], AssignItem];    syms.tb[node].son[2] ¬ Exp[syms.tb[node].son[2], none];  prop ¬ CommonProp[prop, VProp[]];  VPop[];    VPush[BiasForType[rType], [prop: prop, rep: RepForType[rType]], maxRegs];    RETURN [[subtree[index:node]]]};  New: PUBLIC PROC [node: Tree.Index] RETURNS [Tree.Link] = {    OPEN syms.tb[node];    prop: Prop ¬ voidProp;    IF son[1] # Tree.Null THEN {son[1] ¬ Exp[son[1], none]; prop ¬ VProp[]; VPop[]};    IF OpName[syms, son[2]] = apply THEN {      subNode: Tree.Index = GetNode[syms, son[2]];      vSei: ISEIndex;      TypeExp[syms.tb[subNode].son[1]];      syms.tb[subNode].son[2] ¬ Rhs[syms.tb[subNode].son[2], dataPtr.typeCARDINAL];      prop ¬ CommonProp[prop, VProp[]];  VPop[];      vSei ¬ VariantField[syms, UnderType[syms, TypeForTree[syms.tb[subNode].son[1]]]];      IF vSei # Symbols.ISENull THEN {	vType: CSEIndex = UnderType[syms, syms.seb[vSei].idType];	n: CARDINAL = WITH t: syms.seb[vType] SELECT FROM		sequence => P4.CheckOver[Cardinality[syms, syms.seb[t.tagSei].idType]],		ENDCASE => 0;	subType: CSEIndex = OperandType[syms.tb[subNode].son[2]];	IF subType = dataPtr.typeINT OR ~(Cardinality[syms, subType] IN [1..n]) THEN  -- (0..n]	  syms.tb[subNode].son[2] ¬ CheckRange[syms.tb[subNode].son[2], n, dataPtr.typeCARDINAL]}}    ELSE TypeExp[son[2], OpName[syms, son[3]] = body];    SELECT OpName[syms, son[3]] FROM      body => {	expNode: Tree.Index = GetNode[syms, son[3]];	PushNode[syms, body, 0];  SetInfo[syms, syms.tb[expNode].info];  	son[3] ¬ PopTree[syms]};      signalinit => NULL;      ENDCASE =>	IF son[3] # Tree.Null THEN {	  type: CSEIndex = UnderType[syms, TypeForTree[son[2]]];	  subProp: Prop;	  son[3] ¬ Rhs[son[3], type];  subProp ¬ VProp[];  VPop[];	  IF attr3 THEN son[3] ¬ Safen[son[3], subProp, type];	  prop ¬ CommonProp[prop, subProp]};    IF nSons > 3 THEN CatchNest[son[4]];    prop.noXfer ¬ FALSE;  VPush[0, [prop: prop, rep: unsigned], maxRegs];    RETURN [[subtree[index:node]]]};  Narrow: PUBLIC PROC [node: Tree.Index] RETURNS [val: Tree.Link] = {    type: CSEIndex = DecodeCSei[syms.tb[node].info];    IF syms.tb[node].son[2] # Tree.Null THEN TypeExp[syms.tb[node].son[2]];    IF syms.tb[node].attr2 OR syms.tb[node].attr3 THEN {      OPEN syms.tb[node];      prop: Prop;      son[1] ¬ RValue[son[1], 0, RepForType[OperandType[son[1]]]];      prop ¬ VProp[];  prop.noXfer ¬ FALSE;  VPop[];      IF nSons > 2 THEN CatchNest[son[3]];      val ¬ [subtree[index: node]];      VPush[BiasForType[type], [prop: prop, rep: RepForType[type]], maxRegs]}    ELSE {      val ¬ Rhs[syms.tb[node].son[1], type];      syms.tb[node].son[1] ¬ Tree.Null;  FreeNode[syms, node];      IF OperandType[val] # type THEN val ¬ ForceType[val, type]}};  TargetRep: --PUBLIC-- PROC [rep: Repr] RETURNS [Repr] = INLINE {    RETURN [--IF rep = both THEN signed ELSE-- rep]};  Rhs: PUBLIC PROC [exp: Tree.Link, lType: CSEIndex, voidOK: BOOLEAN ¬ FALSE]      RETURNS [val: Tree.Link] = {    lBias: INTEGER = BiasForType[lType];    lRep: Repr = RepForType[lType];    nw: CARDINAL = WordsForType[lType];    rType: CSEIndex = OperandType[exp];    rRep: Repr;    val ¬ RValue[exp, lBias, TargetRep[lRep]];  rRep ¬ VRep[];    IF ~Types.Assignable[[syms, lType], [syms, rType]] THEN      Log.ErrorTree[typeClash, val];    IF ~(IF nw = 0 THEN voidOK ELSE WordsForType[rType] = nw) THEN      SELECT TRUE FROM	(syms.seb[lType].typeTag = record) AND (syms.seb[rType].typeTag = record) =>	  val ¬ PadRecord[val, lType];	(syms.seb[lType].typeTag = union) AND (syms.seb[rType].typeTag = union) => NULL;	ENDCASE => Log.ErrorTree[sizeClash, val];    IF (lType = dataPtr.typeINT AND rRep = unsigned) OR       ((rType = dataPtr.typeINT AND rRep = signed) AND lRep = unsigned) THEN      val ¬ CheckRange[val, P4.CheckOver[Environment.maxINTEGER-lBias]+1, lType]    ELSE      SELECT syms.seb[lType].typeTag FROM	subrange, enumerated, relative =>	  SELECT Cover[lType, lRep, rType, rRep] FROM	    full => NULL;	    partial => val ¬ CheckRange[val, P4.CheckOver[Cardinality[syms, lType]], lType];	    ENDCASE => IF nw # 0 THEN val ¬ BoundsFault[val, lType];	basic =>	  IF lType = dataPtr.typeCHAR AND (rRep # both OR TreeLiteral[val]) THEN	    val ¬ CheckRange[val, P4.CheckOver[Cardinality[syms, lType]], lType];	ENDCASE => NULL;    RETURN};  Cover: PUBLIC PROC [lType: CSEIndex, lRep: Repr, rType: CSEIndex, rRep: Repr]      RETURNS [Covering] = {    lLb, lUb, rLb, rUb: LONG INTEGER;    [lLb, lUb] ¬ Bounds[lType, lRep];    [rLb, rUb] ¬ Bounds[rType, rRep];    RETURN [      IF lLb <= rLb	THEN IF lUb < rLb THEN none ELSE IF lUb < rUb THEN partial ELSE full	ELSE IF lLb <= rUb THEN partial ELSE none]};  Bounds: PROC [type: CSEIndex, rep: Repr] RETURNS [lb, ub: LONG INTEGER] = {    WITH t: syms.seb[type] SELECT FROM      subrange => {lb ¬ t.origin; ub ¬ lb + t.range};      enumerated => {lb ¬ 0; ub ¬ t.nValues-1};      relative => [lb, ub] ¬ Bounds[UnderType[syms, t.offsetType], rep];      ENDCASE =>	SELECT rep FROM	  signed => {lb ¬ -Environment.maxINTEGER-1; ub ¬ Environment.maxINTEGER};	  both => {lb ¬ 0;  ub ¬ Environment.maxINTEGER};	  ENDCASE => {lb ¬ 0;  ub ¬ Environment.maxCARDINAL};    RETURN};  CheckRange: PUBLIC PROC [t: Tree.Link, bound: CARDINAL, type: CSEIndex]      RETURNS [val: Tree.Link] = {    SELECT TRUE FROM      (bound = 0) => val ¬ t;      TreeLiteral[t] =>	val ¬ IF TreeLiteralValue[t] >= bound THEN BoundsFault[t,type] ELSE t;      (checked OR dataPtr.switches['b]) AND ~Bounded[t, bound] => {	PushTree[syms, MakeTreeLiteral[bound]];  PushTree[syms, t];	PushNode[syms, check,-2];  	SetInfo[syms, EncodeSei[type]];  val ¬ PopTree[syms]};      ENDCASE => val ¬ t;    RETURN};  Bounded: PROC [t: Tree.Link, bound: CARDINAL] RETURNS [BOOLEAN] = INLINE {    IF OpName[syms, t] = mod THEN {      t2: Tree.Link = NthSon[syms, t, 2];      RETURN [TreeLiteral[t2] AND TreeLiteralValue[t2] IN [0..bound]]}    ELSE RETURN [FALSE]};  BoundsFault: PROC [t: Tree.Link, type: CSEIndex] RETURNS [Tree.Link] = {    Log.ErrorTree[boundsFault, AdjustBias[t, -BiasForType[type]]];    PushTree[syms, t];--  PushTree[syms, MakeTreeLiteral[0]]; PushNode[syms, check, 2];     SetInfo[syms, EncodeSei[type]];    RETURN [PopTree[syms]]};  RewriteAssign: PUBLIC PROC [node: Tree.Index, lType: CSEIndex] RETURNS [Tree.Link] = {    IF syms.seb[lType].typeTag = union THEN {      WITH syms.tb[node].son[1] SELECT FROM	subtree => {	  subType: CSEIndex;	  subNode: Tree.Index = index;	  SELECT syms.tb[subNode].name FROM	    dot => {	      subType ¬ OperandType[syms.tb[subNode].son[1]];	      PushTree[syms, syms.tb[subNode].son[1]];  PushNode[syms, uparrow, 1];	      SetInfo[syms, EncodeSei[WITH syms.seb[subType] SELECT FROM			ref => UnderType[syms, refType],			ENDCASE => Symbols.typeANY]];	      syms.tb[subNode].son[1] ¬ PopTree[syms];	      syms.tb[subNode].name ¬ dollar};	    dollar => NULL;	    ENDCASE => NULL};	-- flagged by code generators for now	ENDCASE => NULL};	-- flagged by code generators for now    IF syms.tb[node].name = assignx THEN       syms.tb[node].info ¬ EncodeSei[OperandType[syms.tb[node].son[1]]];    RETURN [[subtree[index: node]]]};  }.
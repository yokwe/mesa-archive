-- Copyright (C) 1981, 1983  by Xerox Corporation. All rights reserved. -- OpDefsGenerator.mesa; --   edited by JGS, 26-Oct-81  9:06:43--   edited by Sweet,  8-Feb-83 16:11:24DIRECTORY  Ascii USING [CR, SP, TAB],  Exec USING [AddCommand, ExecProc, GetTTY],  Format USING [Number, NumberFormat, StringProc],  Heap USING [systemZone],  MStream USING [EndOf, ReadOnly, WriteOnly],  Stream USING [    Delete, GetChar, GetPosition, Handle, PutChar, PutWord, SetPosition],  String USING [    AppendChar, AppendString, StringToNumber, StringToOctal],  Time USING [AppendCurrent],  TTY USING [GetChar, GetID, Handle, PutChar, PutLine, PutString];OpDefsGenerator: PROGRAM  IMPORTS    Exec, Format, Heap, MStream, String, Stream, Time, TTY =  BEGIN  CompStrDesc: TYPE = RECORD [offset, length: CARDINAL];  nChars: CARDINAL;  InStream, bOutStream: Stream.Handle;  numopcodes: CARDINAL = 256;  opcode: TYPE = [0..numopcodes);  StringData: LONG POINTER TO ARRAY opcode OF LONG STRING;  push: LONG POINTER TO ARRAY opcode OF CARDINAL;  pop: LONG POINTER TO ARRAY opcode OF CARDINAL;  len: LONG POINTER TO ARRAY opcode OF CARDINAL;  Name: PROCEDURE [s: LONG STRING] =    BEGIN    c: CHARACTER;    nc: CARDINAL ¬ 0;    CollectingChars: BOOLEAN ¬ FALSE;    s.length ¬ 0;    DO      IF MStream.EndOf[InStream] THEN RETURN;      c ¬ InStream.GetChar[];      SELECT c FROM        Ascii.SP, Ascii.TAB, Ascii.CR => IF CollectingChars THEN EXIT;        IN ['0..'9] =>          BEGIN          IF ~CollectingChars THEN            BEGIN InStream.SetPosition[InStream.GetPosition[] - 1]; EXIT END;          String.AppendChar[s, c];          END;        IN ['A..'Z], IN ['a..'z] =>          BEGIN CollectingChars ¬ TRUE; String.AppendChar[s, c]; END;        ENDCASE => SIGNAL SyntaxError;      ENDLOOP;    nChars ¬ nChars + s.length;    RETURN    END;  Atom: PROCEDURE [s: LONG STRING, del: CHARACTER] =    BEGIN    c: CHARACTER;    nc: CARDINAL ¬ 0;    CollectingChars: BOOLEAN ¬ FALSE;    DO      IF MStream.EndOf[InStream] THEN SIGNAL SyntaxError;      c ¬ InStream.GetChar[];      SELECT c FROM        Ascii.SP, Ascii.CR, Ascii.TAB => IF CollectingChars THEN EXIT;        IN ['0..'9], IN ['A..'Z], IN ['a..'z], '+ =>          BEGIN s[nc] ¬ c; nc ¬ nc + 1; CollectingChars ¬ TRUE END;        ENDCASE => EXIT;      ENDLOOP;    s.length ¬ nc;    IF c # del THEN SIGNAL SyntaxError;    RETURN    END;  SyntaxError: SIGNAL = CODE;  CollectOpData: PROCEDURE [stream: Stream.Handle] =    BEGIN    i: opcode;    name: STRING ¬ [20];    s: STRING ¬ [8];    code: CARDINAL;    CRcount: CARDINAL ¬ 0;    push­ ¬ ALL[0];    pop­ ¬ ALL[0];    len­ ¬ ALL[0];    FOR i IN opcode DO      IF StringData[i] # NIL THEN Heap.systemZone.FREE[@StringData[i]];      ENDLOOP;    nChars ¬ 0;    UNTIL CRcount = 3 DO      IF InStream.GetChar[] = Ascii.CR THEN CRcount ¬ CRcount + 1; ENDLOOP;    code ¬ 177777B;    THROUGH opcode DO      Name[name];      IF MStream.EndOf[InStream] THEN EXIT;      Atom[s, '(];      IF s.length = 1 AND s[0] = '+ THEN code ¬ code + 1      ELSE code ¬ String.StringToNumber[s, 8];      Atom[s, ')];  -- decimal, ignore it      IF name.length # 0 THEN        BEGIN        StringData[code] ¬ Heap.systemZone.NEW[StringBody[name.length]];        String.AppendString[StringData[code], name];        END;      Atom[s, ',];      push[code] ¬ String.StringToOctal[s];      Atom[s, ',];      pop[code] ¬ String.StringToOctal[s];      Atom[s, ';];      len[code] ¬ String.StringToOctal[s];      ENDLOOP;    FOR i IN opcode DO      IF i MOD 4 = 0 THEN        BEGIN        f: Format.NumberFormat = [8, TRUE, TRUE, 3];        OutString[stream, "--"L];        OutNameR[stream, StringData[i], 10];        OutNameR[stream, StringData[i + 1], 11];        OutNameR[stream, StringData[i + 2], 11];        OutNameR[stream, StringData[i + 3], 11];        OutString[stream, "   "L];        OutNumF[stream, i, f];        OutChar[stream, '-];        OutNumF[stream, i + 3, f];        OutString[stream, "  "L];        END;      OutString[stream, "  Q["L];      OutNum[stream, push[i]];      OutChar[stream, ',];      OutNum[stream, pop[i]];      OutChar[stream, ',];      OutNum[stream, len[i]];      OutChar[stream, ']];      IF i MOD 4 = 3 THEN        BEGIN        IF i = LAST[opcode] THEN OutString[stream, "];"L]        ELSE OutChar[stream, ',];        OutChar[stream, Ascii.CR];        END      ELSE OutChar[stream, ',];      ENDLOOP;    RETURN    END;  OctalDecimalError: SIGNAL [CARDINAL] = CODE;  OpNameTooLong: ERROR [CARDINAL] = CODE;  OutStrings: PROCEDURE =    BEGIN    charpos: CARDINAL ¬ 0;    i: opcode;    j: CARDINAL;    bOutStream.PutWord[numopcodes*SIZE[CompStrDesc] + 1];    FOR i IN opcode DO      bOutStream.PutWord[charpos];      j ¬ IF StringData[i] # NIL THEN StringData[i].length ELSE 0;      bOutStream.PutWord[j];      charpos ¬ charpos + j;      ENDLOOP;    bOutStream.PutWord[nChars];    bOutStream.PutWord[nChars];    FOR i IN opcode DO      IF StringData[i] # NIL THEN        BEGIN        FOR j IN [0..StringData[i].length) DO          bOutStream.PutChar[StringData[i][j]]; ENDLOOP;        END;      ENDLOOP;    bOutStream.Delete[];    RETURN    END;  OutOpParams: PROCEDURE =    BEGIN    stream: Stream.Handle ¬ MStream.WriteOnly[apoutfile, [], text];    time: STRING ¬ [20];    GetTime[time];    OutString[stream, "  -- generated by OpDefsGenerator "L];    OutString[stream, time];    OutString[      stream,      "  Q: TYPE = PRIVATE RECORD [    push, pop: [0..7], length: [0..3]];  OpParms: PRIVATE ARRAY [0..256) OF Q = ["L];    CollectOpData[stream];    stream.Delete[];    RETURN    END;  GetTime: PROCEDURE [time: STRING] =    BEGIN Time.AppendCurrent[time]; time.length ¬ time.length - 3; END;  OutMopcodes: PROCEDURE =    BEGIN    stream: Stream.Handle ¬ MStream.WriteOnly[amoutfile, [], text];    l, j: CARDINAL;    i: opcode;    time: STRING ¬ [20];    GetTime[time];    OutString[stream, "  -- generated by OpDefsGenerator "L];    OutString[stream, time];    OutChar[stream, Ascii.CR];    OutString[stream, modulename];    OutString[stream, ": DEFINITIONS =BEGINop: TYPE = [0..400B);"L];    FOR i IN opcode DO      IF StringData[i] # NIL AND (l ¬ StringData[i].length) # 0 THEN        BEGIN        IF l > 10 THEN ERROR OpNameTooLong[i];        FOR j IN (l..10) DO OutChar[stream, ' ] ENDLOOP;        OutString[stream, prefixString];        OutString[stream, StringData[i]];        OutString[stream, ": op = "L];        OutNumF[stream, i, [8, FALSE, FALSE, 3]];        OutChar[stream, 'B];        OutChar[stream, ';];        END      ELSE        BEGIN  -- null item, check for rest of line empty        FOR j ¬ i, j + 1 DO          IF StringData[j] # NIL AND StringData[j].length # 0 THEN EXIT;          IF j MOD 4 = 3 THEN GOTO empty;          ENDLOOP;        FOR j IN [0..22) DO OutChar[stream, ' ]; ENDLOOP;        EXITS          empty =>            BEGIN            blank: BOOLEAN ¬ j - i = 3;  -- TRUE iff whole line empty            i ¬ j;            IF blank THEN LOOP;  -- no CR            END;        END;      IF (i MOD 4) # 3 THEN OutChar[stream, ' ] ELSE OutChar[stream, Ascii.CR];      ENDLOOP;    OutString[stream, "END..."L];    stream.Delete[];    RETURN    END;  OutNameR: PROCEDURE [stream: Stream.Handle, s: LONG STRING, n: CARDINAL] =    BEGIN    l: CARDINAL ¬ IF s = NIL THEN 0 ELSE s.length;    THROUGH (l..n] DO OutChar[stream, Ascii.SP]; ENDLOOP;    OutString[stream, s];    RETURN    END;  OutNameL: PROCEDURE [stream: Stream.Handle, s: LONG STRING, n: CARDINAL] =    BEGIN    l: CARDINAL ¬ IF s = NIL THEN 0 ELSE s.length;    OutString[stream, s];    THROUGH (l..n] DO OutChar[stream, Ascii.SP]; ENDLOOP;    RETURN    END;  OutNum: PROCEDURE [stream: Stream.Handle, n: CARDINAL] =    BEGIN OutNumF[stream, n, [10, FALSE, FALSE, 1]]; RETURN END;  OutNumF: PROCEDURE [    stream: Stream.Handle, n: CARDINAL, f: Format.NumberFormat] =    BEGIN    PutS: Format.StringProc = {OutString[stream, s]};    Format.Number[PutS, n, f];    END;  OutString: PROCEDURE [stream: Stream.Handle, s: LONG STRING] =    BEGIN    i: CARDINAL;    IF s # NIL THEN      FOR i IN [0..s.length) DO stream.PutChar[s[i]]; ENDLOOP;    RETURN    END;  OutChar: PROCEDURE [stream: Stream.Handle, c: CHARACTER] =    BEGIN stream.PutChar[c]; RETURN END;  OutListing: PROCEDURE [filename: LONG STRING] =    BEGIN    stream: Stream.Handle ¬ MStream.WriteOnly[filename, [], text];    i: opcode;    time: STRING ¬ [18];    GetTime[time];    OutString[stream, filename];    OutString[stream, ";  "L];    OutString[stream, time];    OutChar[stream, Ascii.CR];    OutString[stream, "Format: name octal(decimal)push,pop,count"L];    FOR i IN opcode DO      OutNameL[stream, StringData[i], 8];      OutNumF[stream, i, [8, FALSE, FALSE, 3]];      OutChar[stream, '(];      OutNumF[stream, i, [10, FALSE, FALSE, 3]];      OutChar[stream, ')];      OutNum[stream, push[i]];      OutChar[stream, ',];      OutNum[stream, pop[i]];      OutChar[stream, ',];      OutNum[stream, len[i]];      OutChar[stream, ';];      IF i MOD 4 = 3 THEN OutChar[stream, Ascii.CR] ELSE OutString[stream, "  "L];      ENDLOOP;    stream.Delete[];    END;  DefaultNames: TYPE = {    infile, apoutfile, amoutfile, boutfile, listfile, modulename, prefix};  infile: LONG STRING;  apoutfile: LONG STRING;  amoutfile: LONG STRING;  boutfile: LONG STRING;  listfile: LONG STRING;  modulename: LONG STRING;  prefixString: LONG STRING;  SetDefaults: PROCEDURE [which: {mop, fop, nop}] =    BEGIN OPEN String;    MopDefaults: ARRAY DefaultNames OF STRING ¬ [      "OpCodes.txt", "OpParams", "Mopcodes.mesa", "OpNames.binary",      "Mopcodes.list", "Mopcodes", "z"];    FopDefaults: ARRAY DefaultNames OF STRING ¬ [      "FOpCodes.txt", "FOpParams", "FOpCodes.mesa", "FOpNames.binary",      "FOpCodes.list", "FOpCodes", "q"];    NopDefaults: ARRAY DefaultNames OF STRING ¬ [      "NOpCodes.txt", "NOpParams", "Mopcodes.mesa", "NOpNames.binary",      "NOpCodes.list", "Mopcodes", "z"];    p: POINTER TO ARRAY DefaultNames OF STRING =      SELECT which FROM mop => @MopDefaults, fop => @FopDefaults, ENDCASE => @NopDefaults;    infile.length ¬ 0;    AppendString[infile, p[infile]];    apoutfile.length ¬ 0;    AppendString[apoutfile, p[apoutfile]];    amoutfile.length ¬ 0;    AppendString[amoutfile, p[amoutfile]];    boutfile.length ¬ 0;    AppendString[boutfile, p[boutfile]];    listfile.length ¬ 0;    AppendString[listfile, p[listfile]];    modulename.length ¬ 0;    AppendString[modulename, p[modulename]];    prefixString.length ¬ 0;    AppendString[prefixString, p[prefix]];    END;  GetResponse: PROCEDURE [prompt, response: LONG STRING] =    BEGIN WriteString[prompt]; ReadID[response]; WriteChar[Ascii.CR]; END;  ttyHandle: TTY.Handle;    WriteString: PROC [s: LONG STRING] = {TTY.PutString[ttyHandle, s]};  WriteChar: PROC [c: CHARACTER] = {TTY.PutChar[ttyHandle, c]};  ReadID: PROC [s: LONG STRING] = {TTY.GetID[ttyHandle, s]};  ReadChar: PROC RETURNS [CHARACTER] = {RETURN[TTY.GetChar[ttyHandle]]};  WriteLine: PROC [s: LONG STRING] = {TTY.PutLine[ttyHandle, s]};  Command: Exec.ExecProc =    BEGIN    ttyHandle ¬ Exec.GetTTY[h];    infile ¬ Heap.systemZone.NEW[StringBody[40]];    apoutfile ¬ Heap.systemZone.NEW[StringBody[40]];    amoutfile ¬ Heap.systemZone.NEW[StringBody[40]];    boutfile ¬ Heap.systemZone.NEW[StringBody[40]];    listfile ¬ Heap.systemZone.NEW[StringBody[40]];    modulename ¬ Heap.systemZone.NEW[StringBody[40]];    prefixString ¬ Heap.systemZone.NEW[StringBody[10]];    StringData ¬ Heap.systemZone.NEW[ARRAY opcode OF LONG STRING];    push ¬ Heap.systemZone.NEW[ARRAY opcode OF CARDINAL];    pop ¬ Heap.systemZone.NEW[ARRAY opcode OF CARDINAL];    len ¬ Heap.systemZone.NEW[ARRAY opcode OF CARDINAL];    StringData­ ¬ ALL[NIL];    WriteString["Mesa OpData Generator"];    DO      DO        WriteString["Mopdata, Fopdata, Nopdata, or Quit: "];        SELECT ReadChar[] FROM          'm, 'M => BEGIN WriteLine["Mopdata"]; SetDefaults[mop]; EXIT END;          'n, 'N => BEGIN WriteLine["Nopdata"]; SetDefaults[nop]; EXIT END;          'f, 'F => BEGIN WriteLine["Fopdata"]; SetDefaults[fop]; EXIT END;          'q, 'Q => BEGIN WriteLine["Quit"]; GOTO done END;          ENDCASE;        ENDLOOP;      WriteChar[Ascii.CR];      WriteLine["Use escape key to get defaults"];      GetResponse["Input file: ", infile];      IF infile.length = 0 THEN EXIT;      GetResponse["  OpParams file: ", apoutfile];      GetResponse["  Mopcodes file: ", amoutfile];      GetResponse["     Module name (capitalize correctly): ", modulename];      GetResponse["     Prefix with: ", prefixString];      GetResponse["  binary file for OpName strings: ", boutfile];      GetResponse["  listing file: ", listfile];      InStream ¬ MStream.ReadOnly[infile, []];      bOutStream ¬ MStream.WriteOnly[boutfile, [], binary];      OutOpParams[];      OutStrings[];      OutMopcodes[];      OutListing[listfile];      InStream.Delete[];      REPEAT done => NULL;      ENDLOOP;    FOR i: CARDINAL IN opcode DO      IF StringData[i] # NIL THEN Heap.systemZone.FREE[@StringData[i]]; ENDLOOP;    Heap.systemZone.FREE[@StringData];    StringData ¬ NIL;    Heap.systemZone.FREE[@push];    push ¬ NIL;    Heap.systemZone.FREE[@pop];    pop ¬ NIL;    Heap.systemZone.FREE[@len];    len ¬ NIL;    Heap.systemZone.FREE[@infile];    Heap.systemZone.FREE[@apoutfile];    Heap.systemZone.FREE[@amoutfile];    Heap.systemZone.FREE[@boutfile];    Heap.systemZone.FREE[@listfile];    Heap.systemZone.FREE[@modulename];    Heap.systemZone.FREE[@prefixString];    END;  Exec.AddCommand["OpDefsGenerator.~"L, Command]  END...
-- Copyright (C) 1982, 1986  by Xerox Corporation. All rights reserved. -- file Pass3T.mesa-- last modified by Satterthwaite, September 23, 1982 10:11 am-- last modified by Sweet, 20-Oct-82 13:09:48-- Wagner		18-Aug-86 11:08:33DIRECTORY  ComData USING [typeAtomRecord],  P3 USING [    Attr, DefaultForm, LhsMode, NarrowOp, NPUse, phraseNP, voidAttr,    CompleteRecord, CopyTree, Initialization, RPush, UpdateTreeAttr,    VariantUnionType],  Symbols USING [    SERecord, SEIndex, ISEIndex, CSEIndex, RecordSEIndex, RefSEIndex, CTXIndex,    SENull, ISENull, lZ, typeANY],  SymbolOps USING [    CtxEntries, FindExtension, MakeNonCtxSe, NormalType, TypeForm, TypeLink,    TypeRoot, UnderType, VisibleCtxEntries, ToSei],  SymbolTable USING [Handle],  Tree USING [Link, Null],  TreeOps USING [    PushSe, PopTree, PushNode, PushProperList, PushTree, OpName, Scan, ScanList],  Types USING [Equivalent];Pass3T: PROGRAM    IMPORTS P3, SymbolOps, TreeOps, Types, dataPtr: ComData    EXPORTS P3 = {  OPEN TreeOps, SymbolOps, Symbols, P3;    syms: SymbolTable.Handle ¬ NIL;    Pass3TInit: PUBLIC PROC [h: SymbolTable.Handle] = {syms ¬ h}; -- type mappings  CanonicalType: PUBLIC PROC [type: CSEIndex] RETURNS [CSEIndex] = {    RETURN [WITH t: syms.seb[type] SELECT FROM      subrange => CanonicalType[UnderType[syms, t.rangeType]],      record =>	IF Bundling[type] # 0	  THEN CanonicalType[Unbundle[LOOPHOLE[type, RecordSEIndex]]]	  ELSE type,      ENDCASE => type]};  TargetType: PUBLIC PROC [type: CSEIndex] RETURNS [target: CSEIndex] = {    RETURN [WITH t: syms.seb[type] SELECT FROM      subrange => TargetType[UnderType[syms, t.rangeType]],      ENDCASE => type]};  Unbundle: PUBLIC PROC [record: RecordSEIndex] RETURNS [CSEIndex] = {    RETURN [UnderType[syms, syms.seb[syms.ctxb[syms.seb[record].fieldCtx].seList].idType]]}; -- type predicates  AccessMode: PUBLIC PROC [type: CSEIndex] RETURNS [LhsMode] = {    nType: CSEIndex = NormalType[syms, type];    RETURN [WITH t: syms.seb[nType] SELECT FROM      ref => SELECT TRUE FROM		t.readOnly => none,		t.counted => counted,		ENDCASE => uncounted,      arraydesc => IF t.readOnly THEN none ELSE uncounted,      relative => AccessMode[UnderType[syms, t.offsetType]],      ENDCASE => none]};  AssignableType: PUBLIC PROC [type: CSEIndex, safe: BOOLEAN] RETURNS [BOOLEAN] = {    RETURN [WITH t: syms.seb[type] SELECT FROM      mode, definition, any, nil, sequence => FALSE,      record => t.hints.assignable AND (~safe OR ~t.hints.variant),      array => AssignableType[UnderType[syms, t.componentType], safe],      transfer => t.mode # port,       opaque => t.lengthKnown,      ENDCASE => TRUE]};  Bundling: PUBLIC PROC [type: CSEIndex] RETURNS [nLevels: CARDINAL] = {    next: CSEIndex;    ctx: CTXIndex;    nLevels ¬ 0;    DO      IF type = SENull THEN EXIT;      WITH t: syms.seb[type] SELECT FROM	record => {	  IF ~t.hints.unifield THEN EXIT;	  ctx ¬ t.fieldCtx;	  WITH c: syms.ctxb[ctx] SELECT FROM	    included => {	      IF t.hints.privateFields AND ~syms.mdb[c.module].shared THEN EXIT;	      IF ~c.complete THEN CompleteRecord[LOOPHOLE[type, RecordSEIndex]];	      IF ~c.complete THEN EXIT};	    ENDCASE;	  IF CtxEntries[syms, ctx] # 1 OR t.hints.variant THEN EXIT;	  nLevels ¬ nLevels + 1;	  next ¬ Unbundle[LOOPHOLE[type, RecordSEIndex]]};	ENDCASE => EXIT;      type ¬ next;      ENDLOOP;    RETURN};  IdentifiedType: PUBLIC PROC [type: CSEIndex] RETURNS [BOOLEAN] = {    RETURN [WITH t: syms.seb[type] SELECT FROM      mode, definition, any, nil, union, sequence => FALSE,      record => 	IF t.hints.variant AND ~t.hints.comparable THEN	  SELECT syms.seb[VariantUnionType[type]].typeTag FROM	-- force copying now	    sequence => FALSE,	    ENDCASE => TRUE	ELSE TRUE,      opaque => t.lengthKnown,      ENDCASE => TRUE]};  IndexType: PUBLIC PROC [type: SEIndex] RETURNS [BOOLEAN] = {    sei: CSEIndex = UnderType[syms, type];    RETURN [WITH t: syms.seb[sei] SELECT FROM      basic => t.ordered,      enumerated => t.ordered,      subrange => IndexType[t.rangeType],      long =>  IndexType[t.rangeType],      ENDCASE => FALSE]};  NewableType: PUBLIC PROC [type: SEIndex] RETURNS [BOOLEAN] = {    sei: CSEIndex = UnderType[syms, type];    RETURN [WITH t: syms.seb[sei] SELECT FROM      mode, any, nil => FALSE,      opaque => t.lengthKnown,      ENDCASE => TRUE]};  NullableType: PUBLIC PROC [type: SEIndex] RETURNS [BOOLEAN] = {    sei: CSEIndex = NormalType[syms, UnderType[syms, type]];    RETURN [WITH t: syms.seb[sei] SELECT FROM      ref, transfer, arraydesc, zone => TRUE,      ENDCASE => FALSE]};  OrderedType: PUBLIC PROC [type: SEIndex] RETURNS [BOOLEAN] = {    sei: CSEIndex = UnderType[syms, type];    RETURN [WITH t: syms.seb[sei] SELECT FROM      basic => t.ordered,      enumerated => t.ordered,      ref => t.ordered,      relative => OrderedType[t.offsetType],      subrange => OrderedType[t.rangeType],      long, real => OrderedType[t.rangeType],      ENDCASE => FALSE]};  DiscrimId: PROC [sei: ISEIndex] RETURNS [BOOLEAN] = INLINE {    RETURN [syms.ctxb[syms.seb[sei].idCtx].level = lZ AND TypeLink[syms, sei] # SENull]}; -- defaults  Default: PUBLIC PROC [type: SEIndex] RETURNS [form: DefaultForm] = {    next: SEIndex;    form ¬ none;    FOR s: SEIndex ¬ type, next DO      WITH se: syms.seb[s] SELECT FROM	id => {	  sei: ISEIndex = LOOPHOLE[s];	  TestOption: TreeOps.Scan = {	    IF OpName[syms, t] = void THEN {IF form = none THEN form ¬ void}	    ELSE form ¬ nonVoid};	  IF syms.seb[sei].extended THEN {ScanList[syms, FindExtension[syms, sei].tree, TestOption]; EXIT};	  next ¬ ToSei[syms.seb[sei].idInfo]};	cons =>	  WITH t: se SELECT FROM	    ref => {IF t.counted THEN form ¬ nonVoid; EXIT};	    array => next ¬ t.componentType;	    record => {IF t.hints.default THEN form ¬ nonVoid; EXIT};	    transfer => {form ¬ nonVoid; EXIT};	    long => next ¬ t.rangeType;	    zone => {IF t.counted THEN form ¬ nonVoid; EXIT};	    ENDCASE => EXIT;	ENDCASE => ERROR;      ENDLOOP;    RETURN};  DefaultInit: PUBLIC PROC [type: SEIndex] RETURNS [v: Tree.Link] = {    next: SEIndex;    subType: CSEIndex ¬ UnderType[syms, type];    recordTail: Tree.Link ¬ Tree.Null;    tagId: ISEIndex ¬ ISENull;    v ¬ Tree.Null;    FOR s: SEIndex ¬ type, next DO      WITH se: syms.seb[s] SELECT FROM	id => {	  sei: ISEIndex = LOOPHOLE[s];	  CopyNonVoid: TreeOps.Scan = {	    IF OpName[syms, t] # void AND v = Tree.Null THEN v ¬ CopyTree[syms, t]};	  SELECT TRUE FROM	    (syms.seb[sei].extended AND recordTail = Tree.Null) => {	      ScanList[syms, FindExtension[syms, sei].tree, CopyNonVoid]; GO TO copy};	    (DiscrimId[sei] AND tagId = ISENull) => tagId ¬ sei;	    ENDCASE;	  next ¬ ToSei[syms.seb[sei].idInfo]};	cons =>	  WITH t: se SELECT FROM	    ref =>	      IF t.counted THEN {PushTree[syms, Tree.Null]; PushNode[syms, nil, 1]; GO TO eval}	      ELSE GO TO none;	    array =>	      IF Default[t.componentType] = nonVoid THEN {	        PushTree[syms, Tree.Null]; PushNode[syms, all, 1]; GO TO eval}	      ELSE GO TO none;	    record =>	      IF t.hints.default OR recordTail # Tree.Null THEN {		n: CARDINAL;		CompleteRecord[LOOPHOLE[s]];		n ¬ VisibleCtxEntries[syms, t.fieldCtx];		FOR i: CARDINAL IN [1..n] DO		  PushTree[syms, IF i # n THEN Tree.Null ELSE recordTail] ENDLOOP;		PushProperList[syms, n];  recordTail ¬ Tree.Null;		IF tagId = ISENull THEN {PushTree[syms, Tree.Null]; PushNode[syms, apply, -2]; GO TO eval}		ELSE {		  PushSe[syms, tagId];  tagId ¬ ISENull;		  PushNode[syms, apply,-2];   recordTail ¬ PopTree[syms];		  next ¬ TypeLink[syms, s];  subType ¬ UnderType[syms, next]}}	      ELSE GO TO none;	    transfer => {	      PushTree[syms, Tree.Null]; PushNode[syms, nil, 1]; GO TO eval};	    zone =>	      IF t.counted THEN {PushTree[syms, Tree.Null]; PushNode[syms, nil, 1]; GO TO eval}	      ELSE GO TO none;	    long => next ¬ t.rangeType;	    ENDCASE => GO TO none;	ENDCASE => ERROR;      REPEAT	none => {v ¬ Tree.Null; phraseNP ¬ none; RPush[subType, voidAttr]};	copy => RPush[subType, IF v=Tree.Null THEN voidAttr ELSE UpdateTreeAttr[v]];	eval => v ¬ Initialization[TargetType[subType], PopTree[syms]];      ENDLOOP;    RETURN};  Voidable: PUBLIC PROC [type: SEIndex] RETURNS [BOOLEAN] = {    next: SEIndex;    FOR s: SEIndex ¬ type, next DO      WITH se: syms.seb[s] SELECT FROM	id => {	  sei: ISEIndex = LOOPHOLE[s];	  IF syms.seb[sei].extended THEN RETURN [VoidItem[FindExtension[syms, sei].tree]];	  next ¬ ToSei[syms.seb[sei].idInfo]};	cons =>	  WITH t: se SELECT FROM	    ref => RETURN [~t.counted];	    array => next ¬ t.componentType;	    record => RETURN [t.hints.voidable];	    union => RETURN [t.hints.voidable];	    long => next ¬ t.rangeType;	    zone => RETURN [~t.counted];	    ENDCASE => RETURN [TRUE];	ENDCASE => ERROR;      ENDLOOP};  VoidItem: PUBLIC PROC [t: Tree.Link] RETURNS [void: BOOLEAN] = {    TestVoid: TreeOps.Scan = {IF OpName[syms, t] = void THEN void ¬ TRUE};    void ¬ FALSE;  ScanList[syms, t, TestVoid];  RETURN}; -- discrimination operations   Narrowing: PUBLIC PROC [type, target: CSEIndex] RETURNS [op: NarrowOp ¬ []] = {    typeL: CSEIndex ¬ target;    typeR: CSEIndex ¬ type;    nextL, nextR: SEIndex;    IF ~Types.Equivalent[[syms, type], [syms, target]] THEN     DO      WITH tR: syms.seb[typeR] SELECT FROM	any =>	  WITH tL: syms.seb[typeL] SELECT FROM	    any => EXIT;	    opaque => {	      op.rtTest ¬ TRUE;	      IF typeL # dataPtr.typeAtomRecord THEN op.unImpl ¬ TRUE;	      EXIT};	    ENDCASE => {	      op.rtTest ¬ TRUE;	      IF ~Discriminated[typeL] THEN EXIT;	      nextL ¬ typeL;  nextR ¬ TypeRoot[syms, typeL]};	record =>	  WITH tL: syms.seb[typeL] SELECT FROM	    record => {	      IF Types.Equivalent[[syms, typeL], [syms, typeR]]	        THEN EXIT;	      WITH vL: tL SELECT FROM	        linked => {		  uType: CSEIndex = VariantUnionType[vL.linkType];		  WITH u: syms.seb[uType] SELECT FROM		    union => IF u.controlled THEN op.tagTest ¬ TRUE ELSE op.computed ¬ TRUE;		    ENDCASE => op.error ¬ TRUE;		  nextL ¬ vL.linkType;  nextR ¬ typeR};		ENDCASE => op.error ¬ TRUE};	    ENDCASE => op.error ¬ TRUE;	ref =>	  WITH tL: syms.seb[typeL] SELECT FROM	    ref => {	      IF op.indirect OR (tL.counted # tR.counted) OR (tR.readOnly AND ~tL.readOnly)	        THEN op.error ¬ TRUE;	      op.indirect ¬ TRUE;	      nextL ¬ tL.refType;  nextR ¬ tR.refType};	    ENDCASE => op.error ¬ TRUE;	transfer =>	  WITH tL: syms.seb[typeL] SELECT FROM	    transfer => {	      IF op.indirect OR tL.mode # tR.mode OR tL.safe # tR.safe THEN	        op.error ¬ TRUE;	      SELECT tL.mode FROM		proc, signal, error => NULL;		ENDCASE => op.error ¬ TRUE;	      IF TypeForm[syms, tL.typeIn] = any OR TypeForm[syms, tL.typeOut] = any THEN	        op.error ¬ TRUE;	-- for now	      IF TypeForm[syms, tR.typeIn] = any THEN	        op.rtTest ¬ TRUE	      ELSE IF ~Types.Equivalent[	          [syms, tL.typeIn],		  [syms, tR.typeIn]] THEN op.error ¬ TRUE;	      IF TypeForm[syms, tR.typeOut] = any THEN	        op.rtTest ¬ TRUE	      ELSE IF ~Types.Equivalent[	          [syms, tL.typeOut],		  [syms, tR.typeOut]] THEN op.error ¬ TRUE;	      EXIT};	    ENDCASE => op.error ¬ TRUE;	long =>	  WITH tL: syms.seb[typeL] SELECT FROM	    long => {nextL ¬ tL.rangeType; nextR ¬ tR.rangeType};	    ENDCASE => op.error ¬ TRUE;	ENDCASE => {	  IF Types.Equivalent[[syms, typeL], [syms, typeR]]	    THEN EXIT;	  op.error ¬ TRUE};      IF op.error THEN EXIT;      typeL ¬ UnderType[syms, nextL];  typeR ¬ UnderType[syms, nextR];      ENDLOOP;    RETURN};      Discriminated: PROC [type: CSEIndex] RETURNS [BOOLEAN] = INLINE {    RETURN [TypeLink[syms, type] # SENull]};  -- check that at tag exists?      MarkedType: PUBLIC PROC [type: CSEIndex] RETURNS [CSEIndex] = {    subType: CSEIndex = NormalType[syms, type];    RETURN [WITH t: syms.seb[subType] SELECT FROM      ref => UnderType[syms, TypeRoot[syms, t.refType]],      transfer => subType,      ENDCASE => typeANY]};     -- type construction  MakeLongType: PUBLIC PROC [rType: SEIndex, hint: CSEIndex]      RETURNS [type: CSEIndex] = {    subType: CSEIndex = UnderType[syms, rType];    WITH t: syms.seb[hint] SELECT FROM      long => IF TargetType[UnderType[syms, t.rangeType]] = TargetType[subType] THEN RETURN [hint];      ENDCASE;    WITH t: syms.seb[subType] SELECT FROM      relative => {	oType: CSEIndex = MakeLongType[UnderType[syms, t.offsetType], UnderType[syms, t.resultType]];	type ¬ MakeNonCtxSe[syms, SIZE[relative cons SERecord]];	syms.seb[type] ¬ [mark3: TRUE, mark4: TRUE,	    body: cons[relative[		baseType: t.baseType, offsetType: oType, resultType: oType]]]};      ENDCASE => {	type ¬ MakeNonCtxSe[syms, SIZE[long cons SERecord]];	syms.seb[type] ¬ [mark3: TRUE, mark4: TRUE, body: cons[long[rangeType: rType]]]};    RETURN};  MakeRefType: PUBLIC PROC [        cType: SEIndex, hint: CSEIndex, readOnly, counted, var: BOOLEAN]      RETURNS [type: RefSEIndex] = {    WITH t: syms.seb[hint] SELECT FROM      ref =>	IF ~t.ordered	 AND t.readOnly = readOnly AND t.counted = counted AND t.var = var	 AND UnderType[syms, t.refType] = UnderType[syms, cType] THEN RETURN [LOOPHOLE[hint]];      ENDCASE;    type ¬ LOOPHOLE[MakeNonCtxSe[syms, SIZE[ref cons SERecord]]];    syms.seb[type] ¬ [mark3: TRUE, mark4: TRUE,	body: cons[ref[	    counted: counted,	    var: var,	    readOnly: readOnly, ordered: FALSE, list: FALSE, basing: FALSE,	    refType: cType]]];    RETURN};  }.
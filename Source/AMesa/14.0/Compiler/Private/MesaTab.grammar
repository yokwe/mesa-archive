-- grammar extracted from Pass1T.mesa by PGS,  7-Jan-87  3:57||CHAIN ||LISTS||TABLE1  1  id  2  num  3  lnum  4  flnum  5  string  6  lstring  7  char  8  atom  9  , 10  ; 11  : 12  .. 13  => 14  _ 15  = 16  # 17  < 18  > 19  <= 20  >= 21  ~ 22  + 23  - 24  * 25  / 26  ^ 27  . 28  @ 29  ! 30  '| 31  RECORD 32  POINTER 33  VAR 34  ARRAY 35  SEQUENCE 36  DESCRIPTOR 37  PROCEDURE 38  PROC 39  PORT 40  SIGNAL 41  ERROR 42  PROCESS 43  PROGRAM 44  MONITOR 45  DEFINITIONS 46  ZONE 47  RELATIVE 48  LONG 49  TYPE 50  FRAME 51  TO 52  ORDERED 53  UNCOUNTED 54  BASE 55  OF 56  PACKED 57  RETURNS 58  RESIDENT 59  MONITORED 60  OVERLAID 61  COMPUTED 62  MACHINE 63  DEPENDENT 64  DIRECTORY 65  IMPORTS 66  EXPORTS 67  SHARES 68  LOCKS 69  USING 70  PUBLIC 71  PRIVATE 72  ENTRY 73  INTERNAL 74  INLINE 75  READONLY 76  CODE 77  ABS 78  ALL 79  AND 80  APPLY 81  MAX 82  MIN 83  MOD 84  NOT 85  OR 86  ORD 87  PRED 88  LENGTH 89  NEW 90  START 91  SUCC 92  VAL 93  FORK 94  JOIN 95  LOOPHOLE 96  NARROW 97  ISTYPE 98  SIZE 99  FIRST100  LAST101  NIL102  TRASH103  NULL104  IF105  THEN106  ELSE107  WITH108  FROM109  FOR110  DECREASING111  IN112  THROUGH113  UNTIL114  WHILE115  REPEAT116  FINISHED117  RETURN118  EXIT119  LOOP120  GOTO121  GO122  FREE123  WAIT124  RESTART125  NOTIFY126  BROADCAST127  STOP128  RESUME129  REJECT130  CONTINUE131  RETRY132  TRANSFER133  STATE134  OPEN135  ENABLE136  ANY137  EXITS138  )139  ]140  }141  END142  ENDLOOP143  ENDCASE144  (145  [146  {147  BEGIN148  DO149  SELECT150  eof||TABLE2151  goal152  module153  directory154  identlist155  cedar156  proghead157  trusted158  checked159  block160  defhead161  defbody162  includeitem163  using164  resident165  safe166  class167  arguments168  locks169  interface170  public171  definitions172  imports173  shares174  open175  declist176  primary177  lambda178  ident179  typeexp180  moduleitem181  declaration182  entry183  readonly184  initialization185  default186  optsize187  procaccess188  idlist'189  identlist'190  position191  exp192  optbits193  bounds194  interval195  range196  typeid'197  typeappl198  typeid199  length200  typecons201  dependent202  elementlist203  element204  monitored205  reclist206  ordered207  base208  pointertype209  packed210  indextype211  transfermode212  heap213  pairlist214  typelist215  variantpair216  variantpart217  pairitem218  defaultopt219  vcasehead220  variantlist221  tagtype222  variantitem223  idlist224  pointerprefix225  initvalue226  inline227  codelist228  orderlist229  statement230  balstmt231  casehead232  casestmtlist233  basicstmt234  lhs235  explist236  forclause237  dotest238  scope239  doexit240  optargs241  transfer242  free243  optcatch244  exits245  enables246  statementlist247  binditem248  exitlist249  casestmtitem250  caselabel251  caseexpitem252  exititem253  casetest254  optrelation255  controlid256  direction257  catchcase258  catchany259  catchlist260  catchhead261  lhslist262  keyitem263  optexp264  transferop265  caseexplist266  disjunct267  conjunct268  negation269  not270  relation271  sum272  addop273  product274  multop275  factor276  relationtail277  relop278  prefixop279  new280  typeop281  qualifier282  desclist283  opttype284  exports285  fieldlist286  includelist287  modulelist288  elementlist'289  bindlist290  statementlist'291  casestmtlist'292  caselabel'293  exitlist'294  keylist295  caseexplist'296  arglist297  returnlist||TABLE3id            tokenIDnum           tokenNUMlnum          tokenLNUMflnum         tokenFLNUMstring        tokenSTRlstring       tokenLSTRchar          tokenCHARatom          tokenATOM-             tokenMINUS.             tokenDOT..            tokenDOTS=             tokenEQUAL=>            tokenARROW<             tokenLESS<=            tokenLE>             tokenGREATER>=            tokenGE#             tokenNE.             InitialSymbol||TABLE4  1     0  goal           ::= . module .   2     0                   | . module ..   3     1  module         ::= directory identlist cedar proghead trusted checked block   4     2                   | directory identlist cedar defhead defbody   5     3  includeitem    ::= id : FROM string using   6     4                   | id : TYPE using   7     4                   | id using   8     5                   | id : TYPE id using   9     6  cedar          ::=  10     7  proghead       ::= resident safe class arguments locks interface = public  11     8  resident       ::=  12     9                   | RESIDENT  13    10  defhead        ::= definitions locks imports shares = public  14    11  definitions    ::= DEFINITIONS  15    12  defbody        ::= BEGIN open declist END  16    12                   | BEGIN open declist ; END  17    12                   | { open declist }  18    12                   | { open declist ; }  19    13  locks          ::= LOCKS primary lambda  20   245                   |  21    14  lambda         ::= USING ident typeexp  22   245                   |  23    15  moduleitem     ::= id  24    16                   | id : id  25    17  declaration    ::= identlist public entry readonly typeexp initialization  26    18                   | identlist public TYPE = public typeexp default  27    19                   | identlist public TYPE optsize  28    20  public         ::= PUBLIC  29    21                   | PRIVATE  30    22                   |  31    21  procaccess     ::=  32    23  entry          ::= ENTRY  33    24                   | INTERNAL  34    25                   |  35    26  idlist'        ::= id  36    28                   | id , idlist'  37    26  identlist'     ::= id :  38    27                   | id position :  39    28                   | id , identlist'  40    29                   | id position , identlist'  41    30  position       ::= ( exp optbits )  42    31  optbits        ::= : bounds  43   245                   |  44    31  interval       ::= [ bounds ]  45    32                   | [ bounds )  46    33                   | ( bounds ]  47    34                   | ( bounds )  48    35  typeexp        ::= id  49   244                   | typeid  50   244                   | typecons  51    35  range          ::= id  52    43                   | id interval  53    44                   | typeid interval  54   244                   | interval  55   244                   | typeid  56    36  typeid'        ::= id . id  57    37                   | typeid' . id  58    37  typeappl       ::= typeappl . id  59    40                   | id length  60    41                   | typeid length  61    41                   | typeappl length  62    38  typeid         ::= id id  63    39                   | id typeid  64   244                   | typeid'  65    42  typecons       ::= interval  66    43                   | id interval  67    44                   | typeid interval  68    45                   | dependent { elementlist }  69    48                   | dependent monitored RECORD reclist  70    49                   | ordered base pointertype  71    50                   | VAR typeexp  72    51                   | packed ARRAY indextype OF typeexp  73    52                   | DESCRIPTOR FOR readonly typeexp  74    53                   | safe transfermode arguments  75    55                   | id RELATIVE typeexp  76    56                   | typeid RELATIVE typeexp  77    57                   | heap ZONE  78    58                   | LONG typeexp  79    59                   | FRAME [ id ]  80   244                   | typeappl  81    46  ident          ::= id position :  82   206                   | id :  83    46  element        ::= id ( exp )  84    47                   | ( exp )  85   206                   | id  86    54  safe           ::=  87    60  monitored      ::= MONITORED  88   243                   |  89    61  dependent      ::= MACHINE DEPENDENT  90    62                   |  91    63  reclist        ::= [ ]  92    63                   | NULL  93    64                   | [ pairlist ]  94    64                   | [ typelist ]  95    65                   | [ pairlist , variantpair ]  96    66                   | [ variantpart default ]  97   242                   | [ variantpair ]  98    67  variantpair    ::= identlist public variantpart default  99    67  pairitem       ::= identlist public typeexp default 100    68  defaultopt     ::= TRASH 101    68                   | NULL 102    69                   | exp '| TRASH 103    69                   | exp '| NULL 104   235                   | 105   244                   | exp 106    70  variantpart    ::= SELECT vcasehead FROM variantlist ENDCASE 107    70                   | SELECT vcasehead FROM variantlist , ENDCASE 108    71                   | packed SEQUENCE vcasehead OF typeexp 109    72  vcasehead      ::= ident public tagtype 110    73                   | COMPUTED tagtype 111    74                   | OVERLAID tagtype 112    75  tagtype        ::= * 113   244                   | typeexp 114    76  variantitem    ::= idlist => reclist 115    77  typelist       ::= typecons default 116    77                   | typeid default 117    78                   | id 118    79                   | id _ defaultopt 119    80                   | typecons default , typelist 120    80                   | typeid default , typelist 121    81                   | id , typelist 122    82                   | id _ defaultopt , typelist 123    83  pointertype    ::= pointerprefix 124    84                   | pointerprefix TO readonly typeexp 125    85  transfermode   ::= PROCEDURE 126    85                   | PROC 127    86                   | PORT 128    87                   | SIGNAL 129    88                   | ERROR 130    89                   | PROCESS 131    90                   | PROGRAM 132    91  initialization ::= 133   241                   | _ initvalue 134   242                   | = initvalue 135    92  initvalue      ::= procaccess trusted checked inline block 136    93                   | CODE 137    94                   | procaccess trusted checked MACHINE CODE BEGIN codelist END 138    94                   | procaccess trusted checked MACHINE CODE { codelist } 139   162                   | TRASH 140   162                   | NULL 141   244                   | exp 142    95  trusted        ::= 143    96  codelist       ::= orderlist 144    97                   | codelist ; orderlist 145    98  statement      ::= IF exp THEN statement 146    99                   | IF exp THEN balstmt ELSE statement 147   100                   | casehead casestmtlist ENDCASE => statement 148   244                   | basicstmt 149    99  balstmt        ::= IF exp THEN balstmt ELSE balstmt 150   100                   | casehead casestmtlist ENDCASE => balstmt 151   244                   | basicstmt 152   101  basicstmt      ::= lhs 153   102                   | lhs _ exp 154   103                   | [ explist ] _ exp 155   104                   | trusted checked block 156   105                   | casehead casestmtlist ENDCASE 157   106                   | forclause dotest DO scope doexit ENDLOOP 158   107                   | EXIT 159   108                   | LOOP 160   109                   | GOTO id 161   110                   | GO TO id 162   111                   | RETURN optargs 163   112                   | transfer lhs 164   113                   | free [ exp optcatch ] 165   114                   | WAIT lhs 166   115                   | ERROR 167   116                   | STOP 168   117                   | NULL 169   118                   | RESUME optargs 170   119                   | REJECT 171   120                   | CONTINUE 172   121                   | RETRY 173   122                   | lhs _ STATE 174   123                   | STATE _ lhs 175   124  block          ::= BEGIN scope exits END 176   124                   | { scope exits } 177   125  scope          ::= open enables statementlist 178   126                   | open enables declist ; statementlist 179   127  binditem       ::= exp 180   128                   | id : exp 181   129  exits          ::= EXITS exitlist 182   243                   | 183   130  casestmtitem   ::= caselabel => statement 184   130  caseexpitem    ::= caselabel => exp 185   130  exititem       ::= idlist => statement 186   131  casetest       ::= optrelation 187   132                   | exp 188   133  caselabel      ::= ident typeexp 189   239                   | caselabel' 190   133  controlid      ::= ident typeexp 191   206                   | id 192   134  forclause      ::= FOR controlid _ exp , exp 193   135                   | FOR controlid direction IN range 194   136                   | THROUGH range 195   245                   | 196   137  direction      ::= DECREASING 197   138                   | 198   139  dotest         ::= UNTIL exp 199   244                   | WHILE exp 200   245                   | 201   140  doexit         ::= 202   141                   | REPEAT exitlist 203   142                   | REPEAT exitlist FINISHED => statement 204   142                   | REPEAT exitlist FINISHED => statement ; 205   143  enables        ::= ENABLE catchcase ; 206   144                   | ENABLE catchany ; 207   145                   | ENABLE BEGIN catchlist END ; 208   145                   | ENABLE { catchlist } ; 209   243                   | 210   146  catchlist      ::= catchhead 211   147                   | catchhead catchcase 212   244                   | catchhead catchany 213   244                   | catchhead catchany ; 214   148  catchcase      ::= lhslist => statement 215   149  optargs        ::= [ explist ] 216   150                   | 217   242                   | lhs 218   151  transfer       ::= SIGNAL 219   152                   | ERROR 220   153                   | RETURN WITH ERROR 221   154                   | START 222   155                   | RESTART 223   156                   | JOIN 224   157                   | NOTIFY 225   158                   | BROADCAST 226   159                   | TRANSFER WITH 227   160                   | RETURN WITH 228   161  keyitem        ::= id : optexp 229   162  optexp         ::= TRASH 230   162                   | NULL 231   244                   | exp 232   245                   | 233   163  exp            ::= transferop lhs 234   164                   | IF exp THEN exp ELSE exp 235   165                   | casehead caseexplist ENDCASE => exp 236   166                   | lhs _ exp 237   167                   | [ explist ] _ exp 238   168                   | ERROR 239   244                   | disjunct 240   169  disjunct       ::= disjunct OR conjunct 241 C 244                   | conjunct 242   170  conjunct       ::= conjunct AND negation 243 C 244                   | negation 244   171  negation       ::= not relation 245 C 244                   | relation 246   172  relation       ::= sum optrelation 247   244                   | sum 248   172  sum            ::= sum addop product 249 C 244                   | product 250   172  product        ::= product multop factor 251 C 244                   | factor 252   173  optrelation    ::= not relationtail 253   244                   | relationtail 254   174  relationtail   ::= IN range 255   244                   | relop sum 256   175  relop          ::= = 257   176                   | # 258   177                   | < 259   178                   | <= 260   179                   | > 261   180                   | >= 262   181  addop          ::= + 263   182                   | - 264   183  multop         ::= * 265   184                   | / 266   185                   | MOD 267   186  factor         ::= addop primary 268 C 244                   | primary 269   187  primary        ::= num 270   188                   | lnum 271   189                   | flnum 272   190                   | string 273   191                   | lstring 274   192                   | atom 275   193                   | NIL 276   194                   | [ explist ] 277   195                   | prefixop [ orderlist ] 278   196                   | VAL [ orderlist ] 279   197                   | ALL [ orderlist ] 280   198                   | new [ typeexp initialization optcatch ] 281   199                   | typeop [ typeexp ] 282   201                   | SIZE [ typeexp ] 283   202                   | SIZE [ typeexp , exp ] 284   203                   | ISTYPE [ exp , typeexp ] 285   204                   | @ lhs 286   205                   | DESCRIPTOR [ desclist ] 287   244                   | lhs 288   200  qualifier      ::= . prefixop 289   200                   | . typeop 290   201                   | . SIZE 291   211                   | [ explist optcatch ] 292   212                   | . id 293   213                   | ^ 294   206  lhs            ::= id 295   207                   | char 296   208                   | NARROW [ exp opttype optcatch ] 297   209                   | LOOPHOLE [ exp opttype ] 298   210                   | APPLY [ exp , exp optcatch ] 299   244                   | ( exp ) 300   244                   | lhs qualifier 301   214  optcatch       ::= ! catchlist 302   243                   | 303   215  transferop     ::= SIGNAL 304   216                   | ERROR 305   217                   | START 306   218                   | JOIN 307   219                   | NEW 308   220                   | FORK 309   221  prefixop       ::= LONG 310   222                   | ABS 311   223                   | PRED 312   224                   | SUCC 313   225                   | ORD 314   226                   | MIN 315   227                   | MAX 316   228                   | BASE 317   229                   | LENGTH 318   230  typeop         ::= FIRST 319   231                   | LAST 320   232                   | NIL 321   233  desclist       ::= exp , exp opttype 322   244                   | exp 323   234  directory      ::= DIRECTORY ; 324   240                   | DIRECTORY includelist ; 325   245                   | 326   234  imports        ::= IMPORTS 327   240                   | IMPORTS modulelist 328   245                   | 329   234  pointerprefix  ::= POINTER 330   244                   | POINTER interval 331   234  exports        ::= EXPORTS 332   240                   | EXPORTS modulelist 333   245                   | 334   234  fieldlist      ::= [ ] 335   240                   | [ pairlist ] 336   240                   | [ typelist ] 337   235  using          ::= USING [ ] 338   244                   | USING [ idlist ] 339   245                   | 340   236  elementlist    ::= 341   244                   | elementlist' 342   236  casestmtlist   ::= 343   244                   | casestmtlist' 344   244                   | casestmtlist' ; 345   236  statementlist  ::= 346   244                   | statementlist' 347   244                   | statementlist' ; 348   236  exitlist       ::= 349   244                   | exitlist' 350   244                   | exitlist' ; 351   236  catchhead      ::= 352   238                   | catchhead catchcase ; 353   236  caseexplist    ::= 354   244                   | caseexplist' 355   244                   | caseexplist' , 356   237  declist        ::= declaration 357   238                   | declist ; declaration 358   237  pairlist       ::= pairitem 359   238                   | pairlist , pairitem 360   237  variantlist    ::= variantitem 361   238                   | variantlist , variantitem 362   237  orderlist      ::= optexp 363   238                   | orderlist , optexp 364   237  lhslist        ::= lhs 365   238                   | lhslist , lhs 366   237  includelist    ::= includeitem 367   238                   | includelist , includeitem 368   237  modulelist     ::= moduleitem 369   238                   | modulelist , moduleitem 370   237  elementlist'   ::= element 371   238                   | elementlist' , element 372   237  bindlist       ::= binditem 373   238                   | bindlist , binditem 374   237  statementlist' ::= statement 375   238                   | statementlist' ; statement 376   237  casestmtlist'  ::= casestmtitem 377   238                   | casestmtlist' ; casestmtitem 378   237  caselabel'     ::= casetest 379   238                   | caselabel' , casetest 380   237  exitlist'      ::= exititem 381   238                   | exitlist' ; exititem 382   237  keylist        ::= keyitem 383   238                   | keylist , keyitem 384   237  caseexplist'   ::= caseexpitem 385   238                   | caseexplist' , caseexpitem 386   239  identlist      ::= identlist' 387   239  idlist         ::= idlist' 388   239  explist        ::= orderlist 389   239                   | keylist 390   240  open           ::= OPEN bindlist ; 391   245                   | 392   241  class          ::= PROGRAM 393   242                   | MONITOR 394   241  casehead       ::= SELECT exp FROM 395   242                   | WITH binditem SELECT optexp FROM 396   242  readonly       ::= READONLY 397   243                   | 398   242  ordered        ::= ORDERED 399   243                   | 400   242  base           ::= BASE 401   243                   | 402   242  packed         ::= PACKED 403   243                   | 404   242  heap           ::= UNCOUNTED 405   242  inline         ::= INLINE 406   243                   | 407   244  arguments      ::= arglist returnlist 408   244  interface      ::= imports exports shares 409   244  shares         ::= SHARES idlist 410   245                   | 411   244  default        ::= _ defaultopt 412   245                   | 413   244  optsize        ::= [ exp ] 414   245                   | 415   244  bounds         ::= exp .. exp 416   244  length         ::= [ exp ] 417   244  indextype      ::= typeexp 418   245                   | 419   244  free           ::= lhs . FREE 420   244  catchany       ::= ANY => statement 421   244  not            ::= ~ 422   244                   | NOT 423   244  new            ::= lhs . NEW 424   244  opttype        ::= , typeexp 425   245                   | 426   244  arglist        ::= fieldlist 427   245                   | 428   244  returnlist     ::= RETURNS fieldlist 429   245                   | 430   246  checked        ::= 
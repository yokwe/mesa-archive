-- Copyright (C) 1983, 1986  by Xerox Corporation. All rights reserved. -- Pass3B.mesa; last modified by-- Satterthwaite,	September 23, 1982 10:11 am-- Sweet,		13-Jun-83 11:48:11-- Johnsson,		11-Jun-83 14:10:11-- Wagner		18-Aug-86 10:11:23DIRECTORY  Alloc USING [Words],  CommandUtil USING [KeyValue, ListLength],  ComData USING [    fileMap, importCtx, interface, moduleCtx, outerCtx, ownSymbols, table, textIndex, zone],  Copier USING [    CreateFileTable, EnterFile, FileProblem, FillModule, FreeSymbolTable,     GetSymbolTable, SearchFileCtx, UnknownModule],  LiteralOps: TYPE USING [StringValue],  CLog: TYPE USING [ErrorHti, ErrorSei, ErrorTree],  P3 USING [    mark,    EnterIdList, Exp, MakeIdTable, MakeFrameRecord, MakeLongType, MakeRefType,     PopCtx, PushCtx, RAttr, RPop, RType, Shared],  String USING [SubString, SubStringDescriptor],  Symbols USING [    Base, ctxType, SERecord, CTXRecord,     HTIndex, ISEIndex, CSEIndex, CTXIndex, IncludedCTXIndex, MDIndex, CBTIndex,    HTNull, ISENull, CTXNull, RootBti, BTNull, lG, OwnMdi, typeANY],  SymbolOps USING [    FillCtxSe, FirstCtxSe, FromCard, FromTreeIndex, LinkMode, MakeCtxSe,     MakeNonCtxSe, NameClash, NewCtx, NextSe, SearchContext, SubStringForHash,     ToBti, UnderType],  SymbolTable USING [Handle],  Tree USING [Base, Index, Link, Null, NullIndex],  TreeOps USING [    DecodeCard, GetHash, GetNode, ListLength, Map, Scan, ScanList,     SearchList, Test, UpdateList];Pass3B: PROGRAM    IMPORTS      Alloc, Copier, CommandUtil, LiteralOps, Log: CLog, P3, SymbolOps, TreeOps,      dataPtr: ComData    EXPORTS P3 = {  OPEN TreeOps, SymbolOps, Symbols, P3;    syms: SymbolTable.Handle ¬ NIL;  -- local copy of symbol tables    Pass3BInit: PUBLIC PROC [h: SymbolTable.Handle] = {syms ¬ h};  GetSe: PROC [t: Tree.Link] RETURNS [ISEIndex] = {    RETURN [WITH t SELECT FROM      symbol => index,      subtree => GetSe[syms.tb[index].son[1]],      ENDCASE => ERROR]};  ItemLabel: PROC [node: Tree.Index] RETURNS [ISEIndex] = INLINE {    RETURN [GetSe[syms.tb[node].son[1]]]};  MemberId: PROC [hti: HTIndex, list: Tree.Link] RETURNS [found: BOOLEAN ¬ FALSE] = {      TestItem: TreeOps.Test = {      RETURN [WITH t SELECT FROM        hash => IF index = hti THEN (found ¬ TRUE) ELSE FALSE,	subtree => TestItem[syms, syms.tb[index].son[1]],	ENDCASE => FALSE]};	    SearchList[syms, list, TestItem];    RETURN};     -- module header   HashTest: TYPE = PROC [hti: HTIndex] RETURNS [BOOLEAN];         Header: PUBLIC PROC [node: Tree.Index] = {        TestShared: HashTest = {      RETURN [MemberId[hti, syms.tb[node].son[3]] OR MemberId[hti, syms.tb[node].son[4]]]};          syms ¬ dataPtr.ownSymbols;    Directory[directory: syms.tb[node].son[1], shared: TestShared];    ScanList[syms, syms.tb[node].son[4], Sharing];    PushCtx[dataPtr.outerCtx];  PushCtx[dataPtr.moduleCtx];    Interfaces[imports: syms.tb[node].son[2], exports: syms.tb[node].son[3]];    PopCtx[];  PopCtx[];}; -- directory processing  Directory: PROC [directory: Tree.Link, shared: HashTest] = {    nIdLists: CARDINAL;    syms.mdb[OwnMdi].moduleId ¬ syms.seb[syms.bb[RootBti].id].hash;    nIdLists ¬ DirectoryScan[directory];    MakeIdTable[nIdLists];    DirectoryDecls[directory, shared]};  MdiMap: TYPE = RECORD [SEQUENCE length: CARDINAL OF MDIndex];  mdiMap: LONG POINTER TO MdiMap;    DirectoryScan: PROC [t: Tree.Link] RETURNS [nLists: CARDINAL ¬ 0] = {    i: CARDINAL ¬ 0;    nArgs: CARDINAL;        FileEntry: TreeOps.Scan = {      ss: String.SubStringDescriptor;      s: String.SubString = @ss;      node: Tree.Index = GetNode[syms, t];      id: HTIndex = syms.seb[ItemLabel[node]].hash;      IF nArgs # 0 THEN FindArg[s, id] ELSE s.base ¬ NIL;      SELECT TRUE FROM	(s.base # NIL) => nArgs ¬ nArgs-1;	(syms.tb[node].son[2].tag = literal) => TreeStringValue[s, syms.tb[node].son[2]];	ENDCASE => SymbolOps.SubStringForHash[syms, s, id];      mdiMap[i] ¬ Copier.EnterFile[syms, id, s];      i ¬ i + 1;      IF syms.tb[node].son[3] # Tree.Null THEN nLists ¬ nLists+1};        n: CARDINAL = ListLength[syms, t];    nLists ¬ 0;  nArgs ¬ CommandUtil.ListLength[dataPtr.fileMap];    Copier.CreateFileTable[syms, n];    mdiMap ¬ (dataPtr.zone).NEW[MdiMap[n]];    ScanList[syms, t, FileEntry];    -- see if files are there    FOR i IN [0..n) DO      logged: BOOLEAN ¬ FALSE;      h: SymbolTable.Handle ¬ Copier.GetSymbolTable[syms, mdiMap[i] !        Copier.FileProblem => logged ¬ TRUE]; -- let Pass3 report missing files      IF h = NIL THEN        {IF ~logged THEN Log.ErrorHti[fileName, syms.mdb[mdiMap[i]].fileId]}      ELSE Copier.FreeSymbolTable[h];      ENDLOOP;    RETURN};  FindArg: PROC [s: String.SubString, id: HTIndex] = INLINE {    key: String.SubStringDescriptor;    t: LONG STRING;    SubStringForHash[syms, @key, id];    t ¬ CommandUtil.KeyValue[@key, dataPtr.fileMap];    s­ ¬ IF t # NIL THEN [base: t, offset: 0, length: t.length] ELSE [NIL, 0, 0]};  TreeStringValue: PROC [s: String.SubString, t: Tree.Link] = {    WITH e:t SELECT FROM      literal =>	WITH e.info SELECT FROM	  string => {	    s.base ¬ LiteralOps.StringValue[syms, index]; s.offset ¬ 0; s.length ¬ s.base.length};	  ENDCASE => ERROR;      ENDCASE => ERROR};  DirectoryDecls: PROC [directory: Tree.Link, shared: HashTest] = {    i: CARDINAL ¬ 0;        DirectoryItem: TreeOps.Scan = {      node: Tree.Index = GetNode[syms, t];      sei: ISEIndex = ItemLabel[node];      key: HTIndex = WITH syms.tb[node].son[2] SELECT FROM	hash => index,	ENDCASE => syms.seb[sei].hash;      type: CSEIndex;      ctx: CTXIndex;      bti: CBTIndex;      saveIndex: CARDINAL = dataPtr.textIndex;      dataPtr.textIndex ¬ DecodeCard[syms.tb[node].info];      syms.tb[node].attr2 ¬ syms.tb[node].attr3 ¬ P3.mark;      Copier.FillModule[syms, sei, key, mdiMap[i]	  ! Copier.UnknownModule => {Log.ErrorHti[moduleId, hti]; RESUME}];      type ¬ UnderType[syms, syms.seb[sei].idType];      ctx ¬ WITH t: syms.seb[type] SELECT FROM	definition => t.defCtx,	transfer => IF (bti¬ToBti[syms.seb[sei].idInfo]) # BTNull THEN 	  syms.bb[bti].localCtx ELSE CTXNull,	ENDCASE => CTXNull;      IF ctx # CTXNull THEN {	WITH c: syms.ctxb[ctx] SELECT FROM	  included => syms.mdb[c.module].shared ¬ shared[syms.seb[sei].hash];	  ENDCASE;	syms.tb[node].son[3] ¬ IncludedIds[ctx, syms.tb[node].son[3]]};      i ¬ i + 1;      dataPtr.textIndex ¬ saveIndex};        ScanList[syms, directory, DirectoryItem];    (dataPtr.zone).FREE[@mdiMap]};  IncludedIds: PROC [ctx: CTXIndex, list: Tree.Link] RETURNS [val: Tree.Link] = {    includedCtx: IncludedCTXIndex;    IncludedId: TreeOps.Map = {      WITH t SELECT FROM	hash => {	  hti: HTIndex = index;	  sei: ISEIndex;	  found, duplicate, update: BOOLEAN;	  CheckDuplicate: TreeOps.Test = {	    RETURN [WITH t SELECT FROM	      symbol => IF index = sei THEN (duplicate ¬ TRUE) ELSE FALSE,	      ENDCASE => TRUE]};	  sei ¬ SearchContext[syms, hti, ctx];	  IF sei = ISENull THEN {	    [found, sei] ¬ Copier.SearchFileCtx[syms, hti, includedCtx]; update ¬ found}	  ELSE {	    found ¬ TRUE;  update ¬ LinkMode[syms, sei] = manifest;	    duplicate ¬ FALSE;  SearchList[syms, list, CheckDuplicate];	    IF duplicate THEN Log.ErrorHti[duplicateId, hti]};	  IF found THEN {	    IF ~syms.seb[sei].public AND ~Shared[includedCtx] THEN {	      Log.ErrorHti[noAccess, hti];  syms.seb[sei].public ¬ TRUE};	    IF update THEN syms.seb[sei].idCtx ¬ CTXNull;	    v ¬ [symbol[index: sei]]}	  ELSE {Log.ErrorHti[unknownId, hti]; v ¬ t}};	ENDCASE => ERROR;      RETURN};    WITH c: syms.ctxb[ctx] SELECT FROM      included =>	IF list # Tree.Null THEN {	  includedCtx ¬ LOOPHOLE[ctx];	  c.restricted ¬ TRUE;	  val ¬ UpdateList[syms, list, IncludedId];	  EnterIdList[includedCtx, val]}	ELSE val ¬ Tree.Null;      ENDCASE => ERROR;    RETURN};  Sharing: TreeOps.Scan = {    hti: HTIndex = GetHash[syms, t];    sei: ISEIndex = SearchContext[syms, hti, dataPtr.moduleCtx];    IF sei = ISENull THEN Log.ErrorHti[unknownId, hti]    ELSE {      type: CSEIndex = UnderType[syms, syms.seb[sei].idType];      ctx: CTXIndex ¬ CTXNull;      WITH syms.seb[type] SELECT FROM	definition => ctx ¬ defCtx;	transfer =>	  IF syms.seb[sei].mark4 AND syms.seb[sei].constant AND mode = program THEN	    ctx ¬ syms.bb[LOOPHOLE[syms.seb[sei].idInfo, CBTIndex]].localCtx;	ENDCASE;      IF ctx = CTXNull AND type # typeANY THEN Log.ErrorHti[typeClash, hti]}};  ImportType: PROC [mdi: MDIndex] RETURNS [CSEIndex] = {    sei: ISEIndex;    type: CSEIndex;    FOR sei ¬ FirstCtxSe[syms, dataPtr.moduleCtx], NextSe[syms, sei] UNTIL sei = ISENull DO      type ¬ UnderType[syms, syms.seb[sei].idType];      WITH t: syms.seb[type] SELECT FROM	definition =>	  WITH c: syms.ctxb[t.defCtx] SELECT FROM	    imported => IF syms.ctxb[c.includeLink].module = mdi THEN GO TO Found;	    ENDCASE;	ENDCASE;      REPEAT	Found => NULL;	FINISHED => {	  sei ¬ MakeCtxSe[syms, syms.mdb[mdi].moduleId, CTXNull];	  Copier.FillModule[syms, sei, syms.seb[sei].hash, mdi]};      ENDLOOP;    RETURN [UnderType[syms, syms.seb[sei].idType]]}; -- import/export processing  Interfaces: PROC [imports, exports: Tree.Link] = INLINE {    ScanList[syms, imports, ImportItem];    ScanList[syms, exports, ExportItem]};  ImportItem: TreeOps.Scan = {    node: Tree.Index = GetNode[syms, t];    sei: ISEIndex = ItemLabel[node];    type, vType: CSEIndex;    const: BOOLEAN;    saveIndex: CARDINAL = dataPtr.textIndex;    dataPtr.textIndex ¬ DecodeCard[syms.tb[node].info];    syms.tb[node].attr2 ¬ syms.tb[node].attr3 ¬ P3.mark;    syms.tb[node].son[2] ¬ Exp[syms.tb[node].son[2], typeANY];    vType ¬ RType[];  const ¬ RAttr[].const;  RPop[];    WITH v: syms.seb[vType] SELECT FROM      definition =>	SELECT syms.ctxb[v.defCtx].ctxType FROM	  included => {	    type ¬ ImportInstance[iType: vType, named: syms.tb[node].attr1];	    IF syms.tb[node].attr1 AND dataPtr.interface THEN Log.ErrorSei[nonDefinition, sei]};	  ENDCASE => {type ¬ typeANY; Log.ErrorTree[notPortable, syms.tb[node].son[2]]};      transfer => {	IF v.mode # program OR dataPtr.interface THEN	  Log.ErrorTree[notPortable, syms.tb[node].son[2]];	syms.seb[sei].immutable ¬ TRUE;	type ¬ MakeLongType[	  MakeRefType[MakeFrameRecord[syms.tb[node].son[2]], typeANY], 	  typeANY];	const ¬ FALSE};      ENDCASE => {	IF vType # typeANY THEN Log.ErrorTree[typeClash, syms.tb[node].son[2]];	type ¬ typeANY};    syms.seb[sei].idType ¬ type;    syms.seb[sei].immutable ¬ TRUE;     syms.seb[sei].constant ¬ const;     syms.seb[sei].idInfo ¬ FromCard[1];    syms.seb[sei].mark3 ¬ TRUE;    dataPtr.textIndex ¬ saveIndex};  ImportInstance: PROC [iType: CSEIndex, named: BOOLEAN] RETURNS [type: CSEIndex] = {    WITH t: syms.seb[iType] SELECT FROM      definition =>	WITH c: syms.ctxb[t.defCtx] SELECT FROM	  included => {	    ctx: CTXIndex = NewImportedCtx[LOOPHOLE[t.defCtx]];	    type ¬ MakeNonCtxSe[syms, SIZE[definition cons SERecord]];	    syms.seb[type] ¬ SERecord[mark3: TRUE, mark4: TRUE,			    body: cons[definition[named: named, defCtx: ctx]]];	    IF ~named THEN syms.mdb[c.module].defaultImport ¬ ctx};	  ENDCASE => ERROR;      ENDCASE => type ¬ typeANY;    RETURN};  NewImportedCtx: PROC [link: IncludedCTXIndex] RETURNS [ctx: CTXIndex] = {    ctx ¬ (dataPtr.table).Words[ctxType, SIZE[imported CTXRecord]];    syms.ctxb[ctx] ¬ CTXRecord[		    mark: FALSE,  varUpdated: FALSE,		    seList: ISENull,		    level: syms.ctxb[link].level,		    extension: imported[includeLink: link]];    RETURN};  ExportItem: TreeOps.Scan = {    node: Tree.Index = GetNode[syms, t];    type: CSEIndex;    saveIndex: CARDINAL = dataPtr.textIndex;    dataPtr.textIndex ¬ DecodeCard[syms.tb[node].info];    syms.tb[node].son[2] ¬ Exp[syms.tb[node].son[2], typeANY];  type ¬ RType[];  RPop[];    WITH d: syms.seb[type] SELECT FROM      definition => {	WITH syms.ctxb[d.defCtx] SELECT FROM	  included => syms.mdb[module].exported ¬ TRUE;	  ENDCASE => Log.ErrorTree[notPortable, syms.tb[node].son[2]]};      ENDCASE => IF type # typeANY THEN Log.ErrorTree[typeClash, syms.tb[node].son[2]];    dataPtr.textIndex ¬ saveIndex};  SetDefaultImport: PUBLIC PROC [iCtx: IncludedCTXIndex, implicitOK: BOOLEAN] = {    mdi: MDIndex;    syms ¬ dataPtr.ownSymbols;  -- make sure we have a current copy    mdi ¬ syms.ctxb[iCtx].module;    IF syms.mdb[mdi].defaultImport = CTXNull THEN {      sei: ISEIndex;      type: CSEIndex;      n: CARDINAL ¬ 0;      IF dataPtr.importCtx = CTXNull THEN dataPtr.importCtx ¬ NewCtx[syms, lG];      FOR sei ¬ FirstCtxSe[syms, dataPtr.importCtx], NextSe[syms, sei] UNTIL sei = ISENull DO	type ¬ UnderType[syms, syms.seb[sei].idType];	WITH t: syms.seb[type] SELECT FROM	  definition =>	    WITH c: syms.ctxb[t.defCtx] SELECT FROM	      imported =>		IF syms.ctxb[c.includeLink].module = mdi THEN {		  syms.mdb[mdi].defaultImport ¬ t.defCtx; n ¬ n+1};	      ENDCASE;	  ENDCASE;	ENDLOOP;      SELECT n FROM	0 => {	  IF ~implicitOK THEN Log.ErrorHti[missingImport, syms.mdb[mdi].moduleId];	  sei ¬ MakeCtxSe[syms, HTNull, dataPtr.importCtx];	  FillCtxSe[syms, sei, syms.mdb[mdi].moduleId, FALSE		! NameClash => {Log.ErrorHti[missingImport, hti]; RESUME}];	  syms.seb[sei].immutable ¬ syms.seb[sei].constant ¬ TRUE;	  syms.seb[sei].linkSpace ¬ syms.seb[sei].extended ¬ FALSE;	  syms.seb[sei].idType ¬ ImportInstance[iType: ImportType[mdi], named:FALSE];	  syms.seb[sei].idInfo ¬ FromCard[1];  	  syms.seb[sei].idValue ¬ FromTreeIndex[Tree.NullIndex];	  syms.seb[sei].mark3 ¬ TRUE;  syms.seb[sei].mark4 ¬ FALSE};	1 => NULL;	ENDCASE => Log.ErrorHti[missingImport, syms.mdb[mdi].moduleId];      IF syms.mdb[mdi].defaultImport = CTXNull THEN syms.mdb[mdi].defaultImport ¬ NewImportedCtx[iCtx]}; };  }.
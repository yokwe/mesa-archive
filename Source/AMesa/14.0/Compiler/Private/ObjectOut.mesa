-- Copyright (C) 1981, 1983, 1986  by Xerox Corporation. All rights reserved. -- ObjectOut.Mesa--   Satterthwaite,	 5-Oct-81 13:59:50--   Sweet,		 4-Aug-83  9:24:09--   Lewis,		29-Oct-81 16:28:06--   Johnsson,		13-Jun-83 20:21:43--   Wagner		22-Aug-86 11:52:02DIRECTORY  Alloc USING [Base, Handle, Bounds],  BcdDefs USING [SGRecord, VersionStamp, FTNull],  ComData USING [    catchBytes, codeByteOffsetList, codeOffsetList, compilerVersion,     codeSeg, defBodyLimit, entryVector, interface, fgTable,     fixupLoc, globalFrameSize, importCtx, jumpIndirectList, mainCtx,     moduleCtx, mtRoot, mtRootSize,    nBodies, nInnerBodies, objectBytes, objectVersion, ownSymbols, sourceFile,    sourceVersion, symSeg, zone],  CompilerUtil USING [],  Environment USING [bytesPerWord, wordsPerPage],  Fixup USING [JIHandle, PCHandle],  Inline USING [LowHalf],  Literals USING [Base, STNull],  LiteralOps USING [CopyLiteral, ForgetEntries],  MFile USING [Handle, SetTimes],  MStream USING [GetFile],  OSMiscOps USING [FreePages, FreeWords, StampToTime, Words],  PackageSymbols USING [    ConstRecord, OuterPackRecord, InnerPackRecord, IPIndex, IPNull, JIData],  PrincOps USING [BytePC],  Stream USING [    Handle, GetPosition, PutBlock, PutByte, PutWord, SetPosition],  Symbols USING [    Base, HTIndex, HTNull, BodyInfo, BTIndex, BTNull, RootBti, lL],  SymbolSegment USING [    Base, FGHeader, FGTEntry, ExtRecord, ExtIndex, STHeader, WordOffset,    VersionID, ltType, htType, ssType, seType, ctxType, mdType, bodyType,    extType, constType],  SymbolOps USING [    EnumerateBodies, HashBlock, HashForSe, SiblingBti, SonBti],  SymbolTable USING [Handle],  Table USING [IPointer, Selector],  Tree USING [Index, Link, Node, Null, NullIndex],  TreeOps USING [FreeTree, Map, NodeSize, UpdateLeaves];ObjectOut: PROGRAM    IMPORTS      Alloc, Inline, OSMiscOps, LiteralOps, MFile, MStream, Stream,       SymbolOps, TreeOps, dataPtr: ComData    EXPORTS CompilerUtil = {  StreamIndex: TYPE = LONG CARDINAL;  GetShortIndex: PROC [stream: Stream.Handle] RETURNS [CARDINAL] = INLINE {    RETURN [Inline.LowHalf[stream.GetPosition[]]]};      syms: SymbolTable.Handle ¬ NIL;    stream: Stream.Handle ¬ NIL;  zone: UNCOUNTED ZONE ¬ NIL;    PageSize: CARDINAL = Environment.wordsPerPage;  BytesPerWord: CARDINAL = Environment.bytesPerWord;  BytesPerPage: CARDINAL = PageSize*BytesPerWord;  NextFilePage: PUBLIC PROC RETURNS [CARDINAL] = {    fill: ARRAY [0..8) OF WORD ¬ ALL [0];    bytes: INTEGER ¬ (GetShortIndex[stream] MOD BytesPerPage);    r, m: INTEGER;    IF bytes MOD 2 = 1 THEN {      stream.PutByte[0]; bytes ¬ (bytes + 1) MOD BytesPerPage};    r ¬ bytes/BytesPerWord;    IF r # 0 THEN      FOR n: INTEGER ¬ PageSize-r, n-m WHILE n > 0 DO	m ¬ MIN[n, LENGTH[fill]];	[] ¬ stream.PutBlock[[LOOPHOLE[LONG[BASE[fill]]], 0, m*BytesPerWord]];	ENDLOOP;    RETURN [GetShortIndex[stream]/BytesPerPage + 1]};  WriteObjectWords: PROC [addr: LONG POINTER, n: CARDINAL] = {    [] ¬ stream.PutBlock[[LOOPHOLE[addr], 0, n*BytesPerWord]]};  RewriteObjectWords: PROC [index: StreamIndex, addr: LONG POINTER, n: CARDINAL] = {    saveIndex: StreamIndex = stream.GetPosition[];    stream.SetPosition[index];    [] ¬ stream.PutBlock[[LOOPHOLE[addr], 0, n*BytesPerWord]];    stream.SetPosition[saveIndex]};  WriteTableBlock: PROC [p: Table.IPointer, size: CARDINAL] = {    [] ¬ stream.PutBlock[[LOOPHOLE[p], 0, size*BytesPerWord]]}; -- bcd i/o  bcdOffset: CARDINAL;  bcdIndex: StreamIndex;    BCDIndex: PROC [offset: CARDINAL] RETURNS [StreamIndex] = INLINE {    RETURN [bcdIndex + offset*BytesPerWord]};  StartBCD: PUBLIC PROC = {    [] ¬ NextFilePage[];    bcdIndex ¬ stream.GetPosition[];    bcdOffset ¬ 0};  ReadBCDOffset: PUBLIC PROC RETURNS [CARDINAL] = {RETURN [bcdOffset]};  ReadBCDIndex: PUBLIC PROC RETURNS [StreamIndex] = {    RETURN [BCDIndex[bcdOffset]]};  AppendBCDWord: PUBLIC PROC [word: UNSPECIFIED] = {    stream.PutWord[word]; bcdOffset ¬ bcdOffset + 1};  AppendBCDWords: PUBLIC PROC [addr: LONG POINTER, n: CARDINAL] = {    WriteObjectWords[addr, n]; bcdOffset ¬ bcdOffset + n};  AppendBCDString: PUBLIC PROC [s: LONG STRING] = {    header: StringBody ¬ [length: s.length, maxlength: s.length, text:];    AppendBCDWords[@header, SIZE[StringBody[0]]];    AppendBCDWords[@s.text, SIZE[StringBody[s.length]] - SIZE[StringBody[0]]]};  FillBCDPage: PUBLIC PROC = {    IF bcdOffset MOD PageSize # 0 THEN {      [] ¬ NextFilePage[]; bcdOffset ¬ bcdOffset + (PageSize - bcdOffset MOD PageSize)}};  UpdateBCDWords: PUBLIC PROC [offset: CARDINAL, addr: LONG POINTER, n: CARDINAL] = {    RewriteObjectWords[BCDIndex[offset], addr, n]};  EndBCD: PUBLIC PROC = {[] ¬ NextFilePage[]}; -- symbol table i/o   PageCount: PROC [words: CARDINAL] RETURNS [CARDINAL] = {    RETURN [(words+(PageSize-1))/PageSize]};  SetFgt: PROC [d: SymbolSegment.WordOffset, sourceFile: LONG STRING]      RETURNS [fgBase, fgPages: CARDINAL] = {    np: CARDINAL = PageCount[d];    dataPtr.symSeg.pages ¬ np;    IF dataPtr.interface THEN {      fgBase ¬ 0;      dataPtr.symSeg.extraPages ¬ fgPages ¬ 0;      dataPtr.codeSeg.file ¬ BcdDefs.FTNull;      dataPtr.codeSeg.base ¬ dataPtr.codeSeg.pages ¬ 0;      dataPtr.objectBytes ¬ 0;      dataPtr.mtRoot.framesize ¬ dataPtr.globalFrameSize ¬ 0}    ELSE {       fgBase ¬ np;      dataPtr.symSeg.extraPages ¬ fgPages ¬ PageCount[	 (SIZE[StringBody[sourceFile.length]]-SIZE[StringBody[0]]) +	   LENGTH[dataPtr.fgTable]*SIZE[SymbolSegment.FGTEntry] +	   SIZE[SymbolSegment.FGHeader]]};    dataPtr.codeSeg.class ¬ code;  dataPtr.codeSeg.extraPages ¬ 0;    RETURN}; -- tree i/o  litBias: CARDINAL;    WriteExtension: PROC [table: Alloc.Handle] RETURNS [size: CARDINAL] = {    OPEN SymbolSegment;    treeLoc: Tree.Index;    OutputLiteral: PROC [t: literal Tree.Link] RETURNS [Tree.Link] = {      OPEN LiteralOps;      WITH t.info SELECT FROM	word => index ¬ CopyLiteral[syms, [baseP:@syms.ltb, index:index]]-litBias;	string => index ¬ Literals.STNull;	-- temporary	ENDCASE => ERROR;      RETURN [t]};    SetEmpty: TreeOps.Map = {RETURN [Tree.Null]};    OutputTree: TreeOps.Map = {      WITH link: t SELECT FROM	literal => v ¬ OutputLiteral[link];	subtree => {	  s: Tree.Link = TreeOps.UpdateLeaves[syms, link, OutputTree];	  IF s = Tree.Null THEN v ¬ Tree.Null	  ELSE	    WITH s SELECT FROM	      subtree => {		node: Tree.Index = index;		nw: CARDINAL = TreeOps.NodeSize[syms, @syms.tb, node];		WriteTableBlock[@syms.tb[node], nw];		[] ¬ TreeOps.FreeTree[syms, TreeOps.UpdateLeaves[syms, s, SetEmpty]];		v ¬ [subtree[index: treeLoc]];  treeLoc ¬ treeLoc + nw};	      ENDCASE => v ¬ s};	ENDCASE => v ¬ link;      RETURN};    extLimit: ExtIndex;    WriteTableBlock[@syms.tb[Tree.NullIndex], SIZE[Tree.Node]];    treeLoc ¬ FIRST[Tree.Index] + SIZE[Tree.Node];    [syms.extb, LOOPHOLE[extLimit, CARDINAL]] ¬ table.Bounds[extType];    FOR exti: ExtIndex ¬ FIRST[ExtIndex], exti + SIZE[ExtRecord] UNTIL exti = extLimit DO      syms.extb[exti].tree ¬        IF dataPtr.interface OR syms.extb[exti].type = value OR syms.extb[exti].type = default	  THEN OutputTree[syms, syms.extb[exti].tree]	  ELSE Tree.Null;      ENDLOOP;    RETURN [treeLoc-FIRST[Tree.Index]]}; -- package table i/o  WritePackTables: PROC [table: Alloc.Handle] = {    OPEN Symbols, PackageSymbols;    BodyLength: PROC [info: Symbols.BodyInfo] RETURNS [CARDINAL] = INLINE {      RETURN [WITH info SELECT FROM External => bytes, ENDCASE => 0]};    nOuter: CARDINAL = dataPtr.nBodies - dataPtr.nInnerBodies + 1;    outer: LONG DESCRIPTOR FOR ARRAY OF OuterPackRecord ¬      DESCRIPTOR[OSMiscOps.Words[nOuter*SIZE[OuterPackRecord]], nOuter];    next: CARDINAL ¬ 0;    nextIP: IPIndex ¬ FIRST[IPIndex];        OuterBody: PROC [bti: BTIndex, catch: BOOLEAN] = {      WITH body: syms.bb[bti] SELECT FROM	Callable =>	  IF ~body.inline AND body.nesting # Catch THEN {	    outer[next] ¬ OuterPackRecord[		hti: IF catch THEN Symbols.HTNull ELSE SymbolOps.HashForSe[syms, body.id],		entryIndex: IF catch THEN dataPtr.nBodies ELSE body.entryIndex,		length: IF catch THEN dataPtr.catchBytes ELSE BodyLength[body.info],		firstSon: InnerBodies[bti, catch],		resident: body.resident,		needsFixup: body.hints.needsFixup];	    next ¬ next + 1};	ENDCASE};    InnerBodies: PROC [root: BTIndex, catch: BOOLEAN] RETURNS [origin: IPIndex] = {      buffer: InnerPackRecord;      Enumerate: PROC [        root: BTIndex, proc: PROC [BTIndex] RETURNS [stop: BOOLEAN]]        RETURNS [bti: BTIndex] = IF catch THEN EnumerateBodiesBelowCatch	  ELSE EnumerateBodiesNotCatch;      ProcessBody: PROC [bti: BTIndex] RETURNS [BOOLEAN] = {	WITH body: syms.bb[bti] SELECT FROM	  Callable =>	    IF ~body.inline AND body.nesting # Catch AND 	      body.level > Symbols.lL THEN {	      IF origin # IPNull THEN WriteObjectWords[@buffer, SIZE[InnerPackRecord]];	      buffer ¬ InnerPackRecord[			  entryIndex: body.entryIndex,			  length:  BodyLength[body.info],			  needsFixup: body.hints.needsFixup,			  lastSon: FALSE];	      IF origin = IPNull THEN origin ¬ nextIP;	      nextIP ¬ nextIP + 1};	  ENDCASE => NULL;	RETURN [FALSE]};      origin ¬ IPNull;      IF root # Symbols.RootBti THEN [] ¬ Enumerate[root, ProcessBody]      ELSE	FOR sonBti: BTIndex ¬ SymbolOps.SonBti[syms, root], SymbolOps.SiblingBti[syms, sonBti]	 UNTIL sonBti = BTNull DO	  WITH body: syms.bb[sonBti] SELECT FROM	    Callable => IF catch THEN	      [] ¬ Enumerate[sonBti, ProcessBody];	         --  otherwise processed as an outer body	    ENDCASE => [] ¬ Enumerate[sonBti, ProcessBody];	  ENDLOOP;      IF origin # IPNull THEN {        buffer.lastSon ¬ TRUE; WriteObjectWords[@buffer, SIZE[InnerPackRecord]]};      RETURN};    EnumerateBodiesNotCatch: PROC [      root: BTIndex, proc: PROC [BTIndex] RETURNS [stop: BOOLEAN]]      RETURNS [bti: BTIndex] = {    prev: BTIndex;    catch: BOOLEAN;    bti ¬ root;    UNTIL bti = BTNull DO      WITH br: syms.bb[bti] SELECT FROM        Callable => catch ¬ br.nesting = Catch;	ENDCASE => catch ¬ FALSE;      IF ~catch AND proc[bti] THEN GO TO Stopped;      IF ~catch AND syms.bb[bti].firstSon # BTNull	THEN bti ¬ syms.bb[bti].firstSon	ELSE	  DO	    IF bti = root THEN GO TO Done;	    prev ¬ bti;  bti ¬ syms.bb[bti].link.index;	    IF syms.bb[prev].link.which # parent THEN EXIT;	    ENDLOOP;      REPEAT	Stopped => NULL;	Done => bti ¬ BTNull;      ENDLOOP;    RETURN};    EnumerateBodiesBelowCatch: PROC [      root: BTIndex, proc: PROC [BTIndex] RETURNS [stop: BOOLEAN]]      RETURNS [bti: BTIndex] = {    prev: BTIndex;    catch: BOOLEAN;    EnumProc: PROCEDURE [h: SymbolTable.Handle, bti: BTIndex] RETURNS [stop: BOOLEAN] = {      RETURN[proc[bti]] };    bti ¬ root;    UNTIL bti = BTNull DO      WITH br: syms.bb[bti] SELECT FROM        Callable => catch ¬ br.nesting = Catch;	ENDCASE => catch ¬ FALSE;      IF catch THEN [] ¬ SymbolOps.EnumerateBodies[syms, bti, EnumProc];      IF ~catch AND syms.bb[bti].firstSon # BTNull	THEN bti ¬ syms.bb[bti].firstSon	ELSE	  DO	    IF bti = root THEN GO TO Done;	    prev ¬ bti;  bti ¬ syms.bb[bti].link.index;	    IF syms.bb[prev].link.which # parent THEN EXIT;	    ENDLOOP;      REPEAT	Done => bti ¬ BTNull;      ENDLOOP;    RETURN};    OuterBody[Symbols.RootBti, FALSE];    FOR bti: BTIndex ¬ SymbolOps.SonBti[syms, Symbols.RootBti], SymbolOps.SiblingBti[syms, bti]     UNTIL bti = BTNull DO      OuterBody[bti, FALSE] ENDLOOP;    OuterBody[Symbols.RootBti, TRUE];     IF next # LENGTH[outer] OR nextIP # dataPtr.nInnerBodies THEN ERROR;    SortPackInfo[outer, 1, LENGTH[outer]-1];    WriteObjectWords[BASE[outer], nOuter*SIZE[OuterPackRecord]];    OSMiscOps.FreeWords[BASE[outer]]};      SortPackInfo: PROC [      a: LONG DESCRIPTOR FOR ARRAY OF PackageSymbols.OuterPackRecord,      l, u: CARDINAL] = {    -- Shell sort of a[l..u)    h, i, j, k: CARDINAL;    key: Symbols.HTIndex;    t: PackageSymbols.OuterPackRecord;    h ¬ u - l;    DO      h ¬ h/2;      FOR k IN [l+h .. u) DO	i ¬ k;  j ¬ k-h;  key ¬ a[k].hti;  t ¬ a[k];	WHILE key < a[j].hti DO	  a[i] ¬ a[j];  i ¬ j;	  IF j < l+h THEN EXIT;  j ¬ j-h;	  ENDLOOP;	a[i] ¬ t;	ENDLOOP;      IF h <= 1 THEN EXIT;      ENDLOOP};        DoConstantTables: PROC [table: Alloc.Handle, write: BOOLEAN]     RETURNS [total: CARDINAL] =    BEGIN -- writes out sequences sorted by pc    base: Alloc.Base;    p, nextp, firstp: Fixup.PCHandle;    j, nextj, firstj: Fixup.JIHandle;    t: CARDINAL;    [base, t] ¬ table.Bounds[SymbolSegment.constType];    IF write THEN stream.PutWord[t/SIZE[PackageSymbols.ConstRecord]];    IF write THEN WriteTableBlock[base, t];    total ¬ SIZE[CARDINAL] + t;        t ¬ 0;    IF dataPtr.codeOffsetList # NIL THEN {       p ¬ firstp ¬ dataPtr.codeOffsetList.next;      DO        t ¬ t + SIZE[PrincOps.BytePC];	p ¬ p.next;	IF p = firstp THEN EXIT;        ENDLOOP};    total ¬ total + SIZE[CARDINAL] + t;    IF write THEN {      stream.PutWord[t / SIZE[PrincOps.BytePC]];      IF dataPtr.codeOffsetList # NIL THEN {        p ¬ firstp;        DO          nextp ¬ p.next;          stream.PutWord[LOOPHOLE[p.pc, CARDINAL]];	  dataPtr.zone.FREE[@p];	  p ¬ nextp;	  IF p = firstp THEN EXIT;          ENDLOOP}};	    t ¬ 0;    IF dataPtr.codeByteOffsetList # NIL THEN {      p ¬ firstp ¬ dataPtr.codeByteOffsetList.next;      DO        t ¬ t + SIZE[PrincOps.BytePC];	p ¬ p.next;	IF p = firstp THEN EXIT;        ENDLOOP};    total ¬ total + SIZE[CARDINAL] + t;    IF write THEN {      stream.PutWord[t / SIZE[PrincOps.BytePC]];      IF dataPtr.codeByteOffsetList # NIL THEN {        p ¬ firstp;        DO          nextp ¬ p.next;          stream.PutWord[LOOPHOLE[p.pc, CARDINAL]];	  dataPtr.zone.FREE[@p];	  p  ¬ nextp;	  IF p = firstp THEN EXIT;          ENDLOOP}};	    t ¬ 0;    IF dataPtr.jumpIndirectList # NIL THEN {      j ¬ firstj ¬ dataPtr.jumpIndirectList.next;      DO        t ¬ t + SIZE[PackageSymbols.JIData];        j ¬ j.next;        IF j = firstj THEN EXIT;        ENDLOOP};    total ¬ total + SIZE[CARDINAL] + t;    IF write THEN {      stream.PutWord[t / SIZE[PackageSymbols.JIData]];      IF dataPtr.jumpIndirectList # NIL THEN {        j ¬ firstj;        DO          nextj ¬ j.next;          stream.PutWord[LOOPHOLE[j.pc, CARDINAL]];	  stream.PutWord[j.tableSize];	  dataPtr.zone.FREE[@j];	  j ¬ nextj;	  IF j = firstj THEN EXIT;          ENDLOOP}};    END; -- main drivers  StartObjectFile: PUBLIC PROC [      objectStream: Stream.Handle, scratchZone: UNCOUNTED ZONE] = {    obj: MFile.Handle = MStream.GetFile[objectStream];    MFile.SetTimes[file: obj, create: [dataPtr.objectVersion.time]];    stream ¬ objectStream; zone ¬ scratchZone};  TableOut: PUBLIC PROC [table: Alloc.Handle] = {    OPEN SymbolSegment;    h: STHeader;    fixupLoc: StreamIndex;    d: WordOffset;    nw: CARDINAL;    WriteSubTable: PROC [selector: Table.Selector] = {      base: Alloc.Base;      size: CARDINAL;      [base, size] ¬ table.Bounds[selector];      WriteTableBlock[base, size]};    syms ¬ dataPtr.ownSymbols;    dataPtr.symSeg.class ¬ symbols;    dataPtr.symSeg.base ¬ NextFilePage[];    h.versionIdent ¬ SymbolSegment.VersionID;    h.version ¬ dataPtr.objectVersion;    h.sourceVersion ¬ OSMiscOps.StampToTime[dataPtr.sourceVersion];    h.creator ¬ dataPtr.compilerVersion;    h.definitionsFile ¬ dataPtr.interface;    h.directoryCtx ¬ dataPtr.moduleCtx;    h.importCtx ¬ dataPtr.importCtx;    h.outerCtx ¬ dataPtr.mainCtx;    d ¬ SIZE[STHeader];    h.hvBlock.offset ¬ d;      d ¬ d + (h.hvBlock.size ¬ LENGTH[SymbolOps.HashBlock[syms]­]);    h.htBlock.offset ¬ d;  d ¬ d + (h.htBlock.size ¬ table.Bounds[htType].size);    h.ssBlock.offset ¬ d;  d ¬ d + (h.ssBlock.size ¬ table.Bounds[ssType].size);    IF dataPtr.interface THEN      h.innerPackBlock ¬ h.outerPackBlock ¬ h.constBlock ¬ [d, 0]    ELSE {      h.innerPackBlock.offset ¬ d;      d ¬ d + (h.innerPackBlock.size ¬ dataPtr.nInnerBodies*SIZE[PackageSymbols.InnerPackRecord]);      h.outerPackBlock.offset ¬ d;      d ¬ d + (h.outerPackBlock.size ¬	(dataPtr.nBodies-dataPtr.nInnerBodies+1) *	SIZE[PackageSymbols.OuterPackRecord]);      h.constBlock.offset ¬ d;        d ¬ d + (h.constBlock.size ¬ DoConstantTables[table, FALSE])};    h.seBlock.offset ¬ d;  d ¬ d + (h.seBlock.size ¬ table.Bounds[seType].size);    h.ctxBlock.offset ¬ d;  d ¬ d + (h.ctxBlock.size ¬ table.Bounds[ctxType].size);      h.mdBlock.offset ¬ d;  d ¬ d + (h.mdBlock.size ¬ table.Bounds[mdType].size);    h.bodyBlock.offset ¬ d;  d ¬ d + table.Bounds[bodyType].size;    h.bodyBlock.size ¬ dataPtr.defBodyLimit;    h.epMapBlock ¬ h.spareBlock ¬ [d, 0];    IF table.Bounds[extType].size # 0 THEN fixupLoc ¬ stream.GetPosition[]    ELSE {      h.treeBlock ¬ h.litBlock ¬ h.sLitBlock ¬ h.extBlock ¬ [d, 0];      [h.fgRelPgBase, h.fgPgCount] ¬ SetFgt[d, dataPtr.sourceFile]};    WriteObjectWords[@h, SIZE[STHeader]];    WriteObjectWords[BASE[SymbolOps.HashBlock[syms]­], h.hvBlock.size];    WriteSubTable[htType];    WriteSubTable[ssType];    IF ~dataPtr.interface THEN {      WritePackTables[table];      [] ¬ DoConstantTables[table, TRUE]};    WriteSubTable[seType];    WriteSubTable[ctxType];    WriteSubTable[mdType];    WriteSubTable[bodyType];    IF table.Bounds[extType].size # 0 THEN {      litBias ¬ LiteralOps.ForgetEntries[syms];      h.treeBlock.offset ¬ d;      h.treeBlock.size ¬ WriteExtension[table];      d ¬ d + h.treeBlock.size;      h.litBlock.offset ¬ d;      nw ¬ table.Bounds[ltType].size - litBias;      WriteTableBlock[table.Bounds[ltType].base+litBias, nw];      d ¬ d + (h.litBlock.size ¬ nw);      h.extBlock.offset ¬ d;      h.sLitBlock ¬ [d, 0];      WriteSubTable[extType];      d ¬ d + (h.extBlock.size ¬ table.Bounds[extType].size);      [h.fgRelPgBase, h.fgPgCount] ¬ SetFgt[d, dataPtr.sourceFile];      RewriteObjectWords[fixupLoc, @h, SIZE[STHeader]]};    IF ~dataPtr.interface THEN {      fg: FGHeader;      [] ¬ NextFilePage[];      nw ¬ SIZE[StringBody[dataPtr.sourceFile.length]]-SIZE[StringBody[0]];      fg.offset ¬ SIZE[FGHeader] + nw;      fg.length ¬ LENGTH[dataPtr.fgTable];      fg.sourceFile ¬ StringBody[			length: dataPtr.sourceFile.length,			maxlength: dataPtr.sourceFile.length,			text: -- written separately -- ];      WriteObjectWords[@fg, SIZE[FGHeader]];      WriteObjectWords[@dataPtr.sourceFile.text, nw];      WriteObjectWords[BASE[dataPtr.fgTable], LENGTH[dataPtr.fgTable]*SIZE[FGTEntry]];      OSMiscOps.FreePages[BASE[dataPtr.fgTable]]}};  EndObjectFile: PUBLIC PROC [update: BOOLEAN] = {    syms ¬ dataPtr.ownSymbols;    IF stream # NIL AND update THEN {      saveIndex: StreamIndex = stream.GetPosition[];      stream.SetPosition[dataPtr.fixupLoc];      [] ¬ stream.PutBlock[        [LOOPHOLE[@dataPtr.codeSeg], 	0,	SIZE[BcdDefs.SGRecord]*BytesPerWord]];      [] ¬ stream.PutBlock[        [LOOPHOLE[@dataPtr.symSeg], 0, SIZE[BcdDefs.SGRecord]*BytesPerWord]];      [] ¬ stream.PutBlock[        [LOOPHOLE[dataPtr.mtRoot], 0, dataPtr.mtRootSize*BytesPerWord]];      IF ~dataPtr.interface THEN {        stream.PutWord[dataPtr.nBodies];        [] ¬ stream.PutBlock[	  [LOOPHOLE[BASE[dataPtr.entryVector]], 	    0, 	    dataPtr.nBodies * SIZE[PrincOps.BytePC] * BytesPerWord]];	    OSMiscOps.FreeWords[BASE[dataPtr.entryVector]];	    dataPtr.entryVector ¬ NIL};      stream.SetPosition[saveIndex]};    IF dataPtr.mtRoot # NIL THEN {      OSMiscOps.FreeWords[dataPtr.mtRoot];       dataPtr.mtRoot ¬ NIL};    stream ¬ NIL;  zone ¬ NIL};  }.
-- Copyright (C) 1981, 1983, 1984, 1986  by Xerox Corporation. All rights reserved. -- file OutCode.mesa--   Sweet,		18-Apr-84 10:03:45--   Satterthwaite,	January 9, 1981  1:06 PM--   JGS,		29-Oct-81 16:24:31--   Johnsson,		12-Jun-83 12:56:39--   MEW		21-Aug-86 16:50:22DIRECTORY  Alloc USING [Notifier],  CatchFormat USING [EnableItem],  Code USING [codeptr, enableList, initialLabel],  CodeDefs USING [BYTE, CCIndex, CCItem, CCNull, codeType, EINull,     EnableIndex, LabelCCIndex, NULLfileindex, TableCodeBytes],  ComData USING [    catchBytes, catchIndex, codeByteOffsetList, codeOffsetList,     codeSeg, entryVector, fgTable, globalFrameSize, jumpIndirectList,    linkCount, mtRoot, nBodies, ownSymbols, stopping, switches, zone],  CompilerUtil USING [AcquireStream, NextFilePage, ReleaseStream],  Environment USING [bytesPerPage, bytesPerWord, wordsPerPage],  Fixup,  FOpCodes USING [qBLTC, qBLTCL, qGA, qLCO, qLGA, qLA],  Literals USING [MSTIndex, STIndex],  LiteralOps USING [EnumerateLocalStrings, EnumerateMasterStrings],  CLog USING [ErrorTree],  Mopcodes USING [zJIB, zJIW, zLFC, zLIW],  MopcodesExtras USING [zDESC],  OSMiscOps USING [FreePages, FreeWords, Pages, Words],  P5 USING [C1W, P5Error],  P5U USING [    ComputeFrameSize, FreeChunk, LabelAlloc, Out0, Out1, PushLitVal,    RecordConstant],  PrincOps USING [    AVHeapSize, BytePC, GlobalOverhead, MaxFrameSize, PrefixHeader],  Stack USING [Dump],  Stream USING [GetPosition, Handle, PutBlock, PutByte, PutWord, SetPosition],  String USING [WordsForString],  Symbols USING [Base, BodyInfo, CBTIndex, RootBti],  SymbolSegment USING [FGTEntry, ObjectStep, SourceStep, Stride],  SymbolTable USING [Handle];OutCode: PROGRAM    IMPORTS MPtr: ComData, CPtr: Code, CompilerUtil, LiteralOps, CLog,      OSMiscOps, P5, P5U, Stack, Stream, String --, SymbolOps     EXPORTS CodeDefs, P5 =  BEGIN  OPEN CodeDefs;  -- imported definitions  Address: TYPE = CARDINAL;  PageSize: CARDINAL = Environment.bytesPerPage;  BytesPerWord: CARDINAL = Environment.bytesPerWord;  WordsPerPage: CARDINAL = Environment.wordsPerPage;  BodyInfo: TYPE = Symbols.BodyInfo;  CBTIndex: TYPE = Symbols.CBTIndex;  FGTEntry: TYPE = SymbolSegment.FGTEntry;  STIndex: TYPE = Literals.STIndex;  MSTIndex: TYPE = Literals.MSTIndex;    CSegPrefix: TYPE = PrincOps.PrefixHeader;  syms: SymbolTable.Handle ¬ NIL;  cb: Symbols.Base;		-- code base (local copy)  OutCodeNotify: PUBLIC Alloc.Notifier =    BEGIN  -- called by allocator whenever table area is repacked    syms ¬ MPtr.ownSymbols;    cb ¬ base[codeType];    END;  FileSequenceError: SIGNAL = CODE;  StreamIndex: TYPE = LONG CARDINAL;  fgt: LONG DESCRIPTOR FOR ARRAY OF FGTEntry;  fgti: INTEGER;  fgtPages: CARDINAL;    LabelPendingInfo: TYPE = RECORD [offset: CARDINAL, next: LabelPendingRef];  LabelPendingRef: TYPE = LONG POINTER TO LabelPendingInfo;    LabelPcInfo: TYPE = RECORD [    label: LabelCCIndex, pc: Address, pending: LabelPendingRef];  LabelPcSeq: TYPE = RECORD [    count: NATURAL,     data: SEQUENCE max: [0..LAST[NATURAL]/SIZE[LabelPcInfo]) OF LabelPcInfo];  LabelPcList: TYPE = LONG POINTER TO LabelPcSeq;  labelPcList: LabelPcList ¬ NIL;    BytePair: TYPE = RECORD[SELECT OVERLAID * FROM      pair => [b1, b2: [0..256)],      single => [w: CARDINAL],      ENDCASE];        SetLabelPc: PROC [label: LabelCCIndex, pc: Address] =    BEGIN    saveIndex: StreamIndex = objectStream.GetPosition[];    pci: NATURAL = FindLabel[label];    pl, next: LabelPendingRef;    FOR pl ¬ labelPcList[pci].pending, next UNTIL pl = NIL DO      next ¬ pl.next;      objectStream.SetPosition[codeBase + pl.offset];      objectStream.PutWord[pc];      MPtr.zone.FREE[@pl];      ENDLOOP;    IF labelPcList[pci].pending # NIL THEN {      labelPcList[pci].pending ¬ NIL;      objectStream.SetPosition[saveIndex]};    labelPcList[pci].pc ¬ pc;    END;      PutLabelPc: PROC [label: LabelCCIndex] = {    pci: NATURAL = FindLabel[label];    pc: BytePair;    pc.w ¬ labelPcList[pci].pc;    IF pc.w = 0 THEN {      np: LabelPendingRef ¬ MPtr.zone.NEW[LabelPendingInfo ¬         [offset: codeByteIndex, next: labelPcList[pci].pending]];      labelPcList[pci].pending ¬ np};    WriteCodeByte[pc.b1]; WriteCodeByte[pc.b2]};           FindLabel: PROC [label: LabelCCIndex] RETURNS [pci: NATURAL] =    BEGIN    count: NATURAL ¬ IF labelPcList = NIL THEN 0 ELSE labelPcList.count;    FOR pci ¬ 0, pci + 1 WHILE pci < count DO      IF labelPcList[pci].label = label THEN RETURN;      ENDLOOP;    IF labelPcList = NIL OR count = labelPcList.max THEN {       new: LabelPcList ¬ MPtr.zone.NEW[LabelPcSeq[count+20] ¬          [count: count, data:]];       FOR j: NATURAL IN [0..count) DO new[j] ¬ labelPcList[j] ENDLOOP;       IF labelPcList # NIL THEN MPtr.zone.FREE[@labelPcList];       labelPcList ¬ new};    labelPcList[count] ¬ [label: label, pc: 0, pending: NIL];    labelPcList.count ¬ count + 1;    RETURN[count];    END;  objectStream: Stream.Handle ¬ NIL;  codeBase: StreamIndex;    catchEntry: LONG DESCRIPTOR FOR ARRAY OF PrincOps.BytePC;  codeByteIndex: CARDINAL;  lastObject, lastSource: CARDINAL;  StartCodeFile: PUBLIC PROC =    BEGIN -- called to set up bodytable and init binary file header    OPEN MPtr, PrincOps;    IF linkCount > 377B THEN P5.P5Error[834];    objectStream ¬ CompilerUtil.AcquireStream[object];    codeSeg.base ¬ CompilerUtil.NextFilePage[];    fgti ¬ -1; fgtPages ¬ 1;    codeBase ¬ objectStream.GetPosition[];    codeByteIndex ¬ SIZE[CSegPrefix]*BytesPerWord;    objectStream.SetPosition[codeBase + codeByteIndex];    labelPcList ¬ NIL;       -- if previous compilation died with fatal pass 5 error      -- that can leak small amounts of MPtr.zone storage.    fgt ¬ DESCRIPTOR[      OSMiscOps.Pages[fgtPages],       (fgtPages*WordsPerPage)/SIZE[FGTEntry]];    MPtr.entryVector ¬ DESCRIPTOR[      OSMiscOps.Words[nBodies*SIZE[BytePC]],       nBodies];    catchEntry ¬ DESCRIPTOR [      OSMiscOps.Words[MPtr.catchIndex * SIZE[PrincOps.BytePC]],      MPtr.catchIndex];    CPtr.initialLabel ¬ DESCRIPTOR [      OSMiscOps.Words[nBodies * SIZE[LabelCCIndex]], nBodies];    FOR i: CARDINAL IN [0..nBodies) DO      c: LabelCCIndex ¬ P5U.LabelAlloc[];      cb[c].offsetLoaded ¬ TRUE;      cb[c].procEntry ¬ TRUE;      CPtr.initialLabel[i] ¬ c;      ENDLOOP;    firstCatch ¬ lastCatch ¬ CCNull;    END;  MoveToCodeWord: PUBLIC PROC RETURNS [CARDINAL] =     BEGIN    IF codeByteIndex MOD 2 = 1 THEN {      objectStream.PutByte[377B]; codeByteIndex ¬ codeByteIndex+1};    RETURN [codeByteIndex/2]    END;  WriteCodeWord: PUBLIC PROC [w: WORD] =    BEGIN    IF codeByteIndex MOD 2 = 1 THEN P5.P5Error[835];    objectStream.PutWord[w];    codeByteIndex ¬ codeByteIndex+2;    END;  WriteCodeByte: PROC [b: BYTE] = {    objectStream.PutByte[b]; codeByteIndex ¬ codeByteIndex+1};  NewFgtEntry: PROC [source, object: CARDINAL] =    BEGIN -- enters new value into fgt    AddEntry: PROC [e: SymbolSegment.FGTEntry] =      BEGIN      IF (fgti ¬ fgti+1) >= LENGTH[fgt] THEN        BEGIN        oldfgt: LONG DESCRIPTOR FOR ARRAY OF FGTEntry ¬ fgt;          fgtPages ¬ fgtPages+1;        fgt ¬ DESCRIPTOR[            OSMiscOps.Pages[fgtPages],            (fgtPages*WordsPerPage)/SIZE[FGTEntry]];        FOR i: CARDINAL IN [0..LENGTH[oldfgt]) DO fgt[i] ¬ oldfgt[i] ENDLOOP;        OSMiscOps.FreePages[BASE[oldfgt]];        END;      fgt[fgti] ¬ e;      END;    t: CARDINAL;    dSource: CARDINAL ¬ source - lastSource;    dObject: CARDINAL ¬ object - lastObject;    WHILE dSource > SymbolSegment.SourceStep DO      t ¬ MIN[dSource, SymbolSegment.Stride];      AddEntry[[step[which: source, delta: t]]];      dSource ¬ dSource - t;      ENDLOOP;    WHILE dObject > SymbolSegment.ObjectStep DO      t ¬ MIN[dObject, SymbolSegment.Stride];      AddEntry[[step[which: object, delta: t]]];      dObject ¬ dObject - t;      ENDLOOP;    AddEntry[[normal[deltaObject: dObject, deltaSource: dSource]]];    lastSource ¬ source; lastObject ¬ object;    END;  OutJumpTables: PUBLIC PROC [start: CCIndex] RETURNS [bodyStart: Address] =    BEGIN -- outputs binary bytes starting at start    c, cj: CCIndex;    offset: CARDINAL;    byteTable: BOOLEAN;    bodyStart ¬ codeByteIndex;    offset ¬ bodyStart;    FOR c ¬ start, cb[c].flink UNTIL c = CCNull DO      WITH  cc:cb[c] SELECT FROM	code => offset ¬ offset + cc.isize;	other => WITH cc SELECT FROM	  table =>	    BEGIN	    offset ¬ offset + TableCodeBytes;	    taboffset ¬ MoveToCodeWord[];	    byteTable ¬ btab ¬ ByteableJumps[flink];	    FOR cj ¬ flink, cb[cj].flink DO	      WITH cb[cj] SELECT FROM		jump =>		  IF jtype = JumpC THEN		    BEGIN		    -- jBytes is surprisingly correct for both forward		    --   and backward jumps.		    jBytes: INTEGER ¬ cb[destlabel].pc - pc+1;		    jBytes ¬ jBytes+2;		    IF byteTable THEN WriteCodeByte[jBytes]		    ELSE WriteCodeWord[jBytes];		    END		  ELSE EXIT;		ENDCASE => EXIT;	      ENDLOOP;	    IF byteTable THEN [] ¬ MoveToCodeWord[];	    bodyStart ¬ codeByteIndex;	    END;	  ENDCASE;	ENDCASE;      ENDLOOP;    END;  OutChunks: PUBLIC PROC [start: CCIndex] =    BEGIN -- outputs binary bytes for body bti starting at start    c, nextC: CCIndex;    offset, nw: CARDINAL;    bodyStart: Address ¬ codeByteIndex;    labelToKeep: BOOLEAN;    offset ¬ bodyStart;        FOR c ¬ start, nextC UNTIL c = CCNull DO      labelToKeep ¬ FALSE;      WITH cc:cb[c] SELECT FROM	code =>	  BEGIN	  IF ~cc.realinst THEN ERROR;	  SELECT cc.isize FROM	    0 => IF cc.realinst THEN ERROR;	    1 =>	      BEGIN	      WriteCodeByte[cc.inst];	      END;	    2 =>	      BEGIN	      WriteCodeByte[cc.inst];	      WriteCodeByte[cc.parameters[1]];	      END;	    3 => 	      BEGIN	      IF cc.inst = Mopcodes.zLIW AND cc.lco THEN {		new: Fixup.PCHandle = MPtr.zone.NEW [Fixup.PCRec ¬ [		  pc: [offset], next: ]];		IF MPtr.codeOffsetList = NIL THEN new.next ¬ new		ELSE {		  new.next ¬ MPtr.codeOffsetList.next;		  MPtr.codeOffsetList.next ¬ new};		MPtr.codeOffsetList ¬ new;		fixupThisProc ¬ TRUE}; 	      WriteCodeByte[cc.inst];	      WriteCodeByte[cc.parameters[1]]; WriteCodeByte[cc.parameters[2]];	      END;	    ENDCASE => P5.P5Error[837];	  offset ¬ offset+cc.isize;	  END;	label => IF cc.offsetLoaded THEN 	  {SetLabelPc[label: LOOPHOLE[c], pc: offset]; labelToKeep ¬ TRUE};	jump => SELECT cc.jtype FROM	  JumpLIO, JumpDESC =>	    BEGIN	    new: Fixup.PCHandle = MPtr.zone.NEW [Fixup.PCRec ¬ [	      pc: [offset], next: ]];	    IF MPtr.codeByteOffsetList = NIL THEN new.next ¬ new 	    ELSE {	      new.next ¬ MPtr.codeByteOffsetList.next;	      MPtr.codeByteOffsetList.next ¬ new};	    MPtr.codeByteOffsetList ¬ new;	    WriteCodeByte[IF cc.jtype = JumpLIO THEN Mopcodes.zLIW 	      ELSE MopcodesExtras.zDESC];	    PutLabelPc[cc.destlabel];	    offset ¬ offset + 3;	    fixupThisProc ¬ TRUE;	    END;	  ENDCASE;	other => WITH cc SELECT FROM	  table =>	    BEGIN	    new: Fixup.JIHandle = MPtr.zone.NEW [Fixup.JIRec ¬ [	      pc: [offset], tableSize: tableSize, next: ]];	    IF MPtr.jumpIndirectList = NIL THEN new.next ¬ new	    ELSE {	      new.next ¬ MPtr.jumpIndirectList.next;	      MPtr.jumpIndirectList.next ¬ new};	    MPtr.jumpIndirectList ¬ new;	    CPtr.codeptr ¬ c;	    P5.C1W[IF btab THEN Mopcodes.zJIB ELSE Mopcodes.zJIW, taboffset];	    fixupThisProc ¬ TRUE;	    END;	  markbody =>	    IF start THEN	      BEGIN -- immediately prior chunk was source unless catch	      WITH br: syms.bb[index] SELECT FROM		Other => br.relOffset ¬ offset - bodyStart;		Callable => WITH brc: br SELECT FROM		  Catch => {		    catchEntry[brc.index] ¬ [offset];		    lastSource ¬ brc.sourceIndex;		    lastObject ¬ bodyStart ¬ offset;		    NewFgtEntry[lastSource, lastObject]}; -- a [0,0] for this body		  ENDCASE => ERROR;		ENDCASE => ERROR;	      syms.bb[index].info ¬ BodyInfo[External[bytes: , startIndex: fgti, indexLength: ]];	      END	    ELSE	      BEGIN	      WITH bi: syms.bb[index].info SELECT FROM		External =>		  BEGIN		  bi.indexLength ¬ fgti-bi.startIndex+1;		  WITH br: syms.bb[index] SELECT FROM		    Other => bi.bytes ¬ offset - br.relOffset - bodyStart;		    Callable => WITH brc: br SELECT FROM		      Catch => bi.bytes ¬ offset - catchEntry[brc.index];		      ENDCASE => ERROR;		    ENDCASE => ERROR;		  END;		ENDCASE;	      END;	  markEnable =>	    IF start THEN cb[index].startPC ¬ offset	    ELSE cb[index].bytes ¬ offset - cb[index].startPC;	  source => IF index # NULLfileindex THEN	    BEGIN	    IF index > lastSource OR	     (index = lastSource AND offset # lastObject) THEN 	     NewFgtEntry[index, offset];	    END;	  localCall =>	    BEGIN	    new: Fixup.PCHandle = MPtr.zone.NEW [Fixup.PCRec ¬ [	      pc: [offset], next: ]];	    IF MPtr.codeByteOffsetList = NIL THEN new.next ¬ new 	    ELSE {	      new.next ¬ MPtr.codeByteOffsetList.next;	      MPtr.codeByteOffsetList.next ¬ new};	    MPtr.codeByteOffsetList ¬ new;	    WriteCodeByte[Mopcodes.zLFC];	    PutLabelPc[target];	    offset ¬ offset + 3;	    fixupThisProc ¬ TRUE;	    END;	  ENDCASE;	ENDCASE;      nextC ¬ cb[c].flink;      IF labelToKeep THEN {        cb[c].flink ¬ CCNull;	cb[c].blink ¬ CCNull}      ELSE {        nw ¬ WITH cc: cb[c] SELECT FROM	  code => MAX[cc.isize, 1]-1+SIZE[code CCItem],	  label => SIZE[label CCItem],	  jump => SIZE[jump CCItem],	  other => SIZE[other CCItem],	  ENDCASE => ERROR;        P5U.FreeChunk[c, nw]};      ENDLOOP;    END;  fixupThisProc: BOOLEAN;    OutBinary: PUBLIC PROC [bti: CBTIndex, start: CCIndex] =    BEGIN -- outputs binary bytes for body bti starting at start    e, fs: CARDINAL;    bodyStart: Address;        fixupThisProc ¬ FALSE;        bodyStart ¬ OutJumpTables[start];    RemoveCatchCode[start];    e ¬ syms.bb[bti].entryIndex;    lastSource ¬ syms.bb[bti].sourceIndex;    lastObject ¬ bodyStart;    WITH bi: syms.bb[bti].info SELECT FROM      Internal =>	BEGIN	fs ¬ P5U.ComputeFrameSize[bi.frameSize];	IF syms.bb[bti].resident THEN fs ¬ fs+PrincOps.AVHeapSize;	END;      ENDCASE => P5.P5Error[836];    NewFgtEntry[source: lastSource, object: lastObject]; -- put out [0,0]    MPtr.entryVector[e] ¬ [bodyStart];    syms.bb[bti].info ¬ BodyInfo[External[bytes: , startIndex: fgti, indexLength: ]];    SetLabelPc[label: LOOPHOLE[start], pc: codeByteIndex];    WriteCodeByte[fs];    OutChunks[cb[start].flink]; cb[start].flink ¬ CCNull;    WITH syms.bb[bti].info SELECT FROM      External => {	indexLength ¬ fgti - startIndex+1; 	bytes ¬ codeByteIndex - bodyStart};      ENDCASE;    syms.bb[bti].hints.needsFixup ¬ fixupThisProc;    END;  RemoveCatchCode: PROC [start: CCIndex] =    BEGIN    c: CCIndex;    FOR c ¬ start, cb[c].flink UNTIL c = CCNull DO      WITH cc:cb[c] SELECT FROM	other => WITH cc SELECT FROM	  markbody =>	    IF start THEN	      BEGIN	      WITH br: syms.bb[index] SELECT FROM		Other => NULL;		Callable => WITH brc: br SELECT FROM		  Catch => {DelinkCatch[c]; RETURN};		  ENDCASE;		ENDCASE;	      END;	  ENDCASE;	ENDCASE;      ENDLOOP;    END;      firstCatch, lastCatch: CCIndex;    DelinkCatch: PROC [c: CCIndex] =    BEGIN    prev: CCIndex = cb[c].blink;    IF firstCatch = CCNull THEN firstCatch ¬ c    ELSE cb[lastCatch].flink ¬ c;     cb[c].blink ¬ lastCatch;    cb[prev].flink ¬ CCNull;    lastCatch ¬ c;    WHILE cb[lastCatch].flink # CCNull DO       lastCatch ¬ cb[lastCatch].flink;      ENDLOOP;    END;  ByteableJumps: PROC [j: CCIndex] RETURNS [BOOLEAN] =    BEGIN    DO    WITH cb[j] SELECT FROM      jump =>	IF jtype = JumpC THEN	  BEGIN	  jBytes: INTEGER = cb[destlabel].pc - pc + 3;	  IF ~forward OR jBytes > LAST[BYTE] THEN RETURN [FALSE];	  j ¬ cb[j].flink;	  END	ELSE RETURN [TRUE];      ENDCASE => RETURN [TRUE]    ENDLOOP    END;  WriteCodeString: PROC [s: LONG POINTER, nw: CARDINAL] =    BEGIN    FOR i: CARDINAL IN [0..nw)      DO objectStream.PutWord[(s+i)­] ENDLOOP;    END;  ProcessGlobalStrings: PUBLIC PROC [framestart: CARDINAL]      RETURNS [nextnewframe: CARDINAL] =    BEGIN    firstNewCode, nextNewCode: CARDINAL ¬ MoveToCodeWord[];    stSize, litSize: CARDINAL;        DoString: PROC [msti: MSTIndex] =      BEGIN      nw: CARDINAL;      IF syms.stb[msti].info = 0 THEN {syms.stb[msti].local ¬ TRUE; RETURN};      nw ¬ String.WordsForString[syms.stb[msti].string.length];      syms.stb[msti].info ¬ nextnewframe;       nextnewframe ¬ nextnewframe+nw;      IF nextnewframe > PrincOps.MaxFrameSize THEN	CLog.ErrorTree[addressOverflow, [literal[info: [string[index: msti]]]]];      syms.stb[msti].codeIndex ¬ nextNewCode;      nextNewCode ¬ nextNewCode + nw;      WriteCodeString[@syms.stb[msti].string, nw];      codeByteIndex ¬ codeByteIndex + 2*nw;      END; -- of doglobal    nextnewframe ¬ framestart;    LiteralOps.EnumerateMasterStrings[syms, DoString];    litSize ¬ nextNewCode - firstNewCode;  stSize ¬ nextnewframe - framestart;    IF litSize > 0 THEN       BEGIN      P5U.RecordConstant[firstNewCode, litSize];      IF stSize > 0 THEN BLTStrings[firstNewCode, stSize, framestart, FALSE];      END;    END;  ProcessLocalStrings: PUBLIC PROC [framestart: CARDINAL, first: STIndex]      RETURNS [nextnewframe: CARDINAL] =    BEGIN    nStrings: CARDINAL ¬ 0;    CountStrings: PROC [msti: MSTIndex] =      BEGIN      IF syms.stb[msti].local AND syms.stb[msti].codeIndex # 0 THEN nStrings ¬ nStrings+1;      END;    firstNewCode, nextNewCode: CARDINAL;    firstCode: BOOLEAN ¬ TRUE;    stSize, i, nw: CARDINAL;    curSize: CARDINAL ¬ 0;    StringInfo: TYPE = RECORD [offset: CARDINAL, sti: MSTIndex];    star: LONG DESCRIPTOR FOR ARRAY OF StringInfo;    InsertStrings: PROC [msti: MSTIndex] =      BEGIN      IF syms.stb[msti].local THEN	BEGIN 	co: CARDINAL = syms.stb[msti].codeIndex; 	IF co # 0 THEN	  BEGIN	  FOR i ¬ curSize, i-1 WHILE i>0 AND co < star[i-1].offset DO	    star[i] ¬ star[i-1];	    ENDLOOP; 	  star[i] ¬ [co, msti]; 	  curSize ¬ curSize+1;	  END	ELSE	  BEGIN	  nw: CARDINAL = String.WordsForString[syms.stb[msti].string.length];	  syms.stb[msti].info ¬ nextnewframe; 	  nextnewframe ¬ nextnewframe+nw;	  IF nextnewframe > PrincOps.MaxFrameSize THEN	    CLog.ErrorTree[addressOverflow, [literal[info: [string[index: msti]]]]];	  IF firstCode THEN {	    firstCode ¬ FALSE; firstNewCode ¬ nextNewCode ¬ MoveToCodeWord[]};	  syms.stb[msti].codeIndex ¬ nextNewCode;	  nextNewCode ¬ nextNewCode + nw;	  WriteCodeString[@syms.stb[msti].string, nw];	  codeByteIndex ¬ codeByteIndex + nw*2;	  END;	END;      END; -- of InsertStrings    nextnewframe ¬ framestart;    LiteralOps.EnumerateLocalStrings[syms, first, CountStrings];    IF nStrings # 0 THEN       star ¬ DESCRIPTOR[OSMiscOps.Words[nStrings*SIZE[StringInfo]], nStrings];    LiteralOps.EnumerateLocalStrings[syms, first, InsertStrings];    stSize ¬ nextnewframe - framestart;    IF stSize > 0 THEN       BEGIN      BLTStrings[firstNewCode, stSize, framestart, TRUE];      P5U.RecordConstant[firstNewCode, stSize];      END;    i ¬ 0;    WHILE i < nStrings DO      framestart ¬ nextnewframe;      nextNewCode ¬ firstNewCode ¬ star[i].offset;      WHILE i < nStrings AND star[i].offset = nextNewCode DO	nw ¬ String.WordsForString[syms.stb[star[i].sti].string.length];	nextNewCode ¬ nextNewCode + nw;	syms.stb[star[i].sti].info ¬ nextnewframe;	nextnewframe ¬ nextnewframe+nw;	IF nextnewframe > PrincOps.MaxFrameSize THEN	  CLog.ErrorTree[addressOverflow, [literal[info: [string[index: star[i].sti]]]]];	i ¬ i+1;	ENDLOOP;      stSize ¬ nextnewframe - framestart;      BLTStrings[firstNewCode, stSize, framestart, TRUE];      ENDLOOP;    IF nStrings # 0 THEN OSMiscOps.FreeWords[BASE[star]];    END;  BLTStrings: PROC [coffset, length, foffset: CARDINAL, local: BOOLEAN] =    BEGIN OPEN FOpCodes;    Stack.Dump[]; -- though I don't see how it could be non-empty now    P5U.Out1[qLCO, coffset];    P5U.PushLitVal[length];    P5U.Out1[IF local THEN qLA ELSE IF MPtr.switches['o] THEN qGA ELSE qLGA, foffset];    P5U.Out0[IF local OR MPtr.switches['o] THEN qBLTC ELSE qBLTCL];    END;      OutputCatchBodies: PROC =    BEGIN    IF firstCatch # CCNull THEN OutChunks[firstCatch];    MPtr.catchBytes ¬ codeByteIndex - 2*catchOffset; -- count CEV, etc    END;      OutputCatchTables: PROC =    BEGIN    maxLevel: CARDINAL = LENGTH[CPtr.enableList]-1;    OutEnableLevel: PROC [i: CARDINAL] =      BEGIN      n: CARDINAL ¬ 0;      ei: EnableIndex;      ee: CatchFormat.EnableItem;      lei: EnableIndex = CPtr.enableList[i];      lnei: EnableIndex;      FOR ei ¬ lei, cb[ei].next UNTIL ei = EINull DO         n ¬ n+1;	ENDLOOP;      WriteCodeWord[n];      FOR ei ¬ lei, cb[ei].next UNTIL ei = EINull DO         ee ¬ [	  start: [cb[ei].startPC], length: cb[ei].bytes,	  index: syms.bb[cb[ei].bti].index, alsoNested: FALSE];	IF i < maxLevel AND (lnei ¬ CPtr.enableList[i+1]) # EINull THEN	  BEGIN -- look for nexted catch phrases	  FOR nei: EnableIndex ¬ lnei, cb[nei].next UNTIL nei = EINull DO	    ns: CARDINAL = cb[nei].startPC;	    IF ns >= ee.start THEN {	      IF ns < ee.start + ee.length THEN ee.alsoNested ¬ TRUE;	      EXIT};	    ENDLOOP;	  END;	[] ¬ objectStream.PutBlock[	  [LOOPHOLE[LONG[@ee]], 0, SIZE[CatchFormat.EnableItem]*BytesPerWord]];	ENDLOOP;      END;        SortEnableLists[];    WriteCodeWord[LENGTH[catchEntry]];    IF LENGTH[catchEntry] # 0 THEN      [] ¬ objectStream.PutBlock[	  [LOOPHOLE[BASE[catchEntry]], 	   0,	   LENGTH[catchEntry]*SIZE[PrincOps.BytePC]*BytesPerWord]];    IF CPtr.enableList[0] = EINull THEN WriteCodeWord[0];    FOR l: CARDINAL IN [0..maxLevel] WHILE CPtr.enableList[l] # EINull DO      OutEnableLevel[l];      ENDLOOP;    END;    SortEnableLists: PROC = {    FOR l: CARDINAL IN [0..LENGTH[CPtr.enableList])         WHILE CPtr.enableList[l] # EINull DO      -- do simple insertion sort of each list      new: EnableIndex ¬ EINull;      next: EnableIndex;      FOR ei: EnableIndex ¬ CPtr.enableList[l], next UNTIL ei = EINull DO        next ¬ cb[ei].next;        IF new = EINull OR cb[ei].startPC < cb[new].startPC THEN {	  cb[ei].next ¬ new; new ¬ ei}        ELSE {          prevEi: EnableIndex ¬ new;          WHILE cb[prevEi].next # EINull AND 	      cb[cb[prevEi].next].startPC < cb[ei].startPC DO            prevEi ¬ cb[prevEi].next;            ENDLOOP;          cb[ei].next ¬ cb[prevEi].next;          cb[prevEi].next ¬ ei};        CPtr.enableList[l] ¬ new;        ENDLOOP;      ENDLOOP};      catchOffset: CARDINAL;  EndCodeFile: PUBLIC PROC RETURNS [nbytes: CARDINAL] =    BEGIN OPEN PrincOps;    maxLevel: CARDINAL = LENGTH[CPtr.enableList]-1;    saveindex, catchIndex: StreamIndex;    noCatch: BOOLEAN = LENGTH[catchEntry] = 0;    ctSize: CARDINAL ¬ 1 + LENGTH[catchEntry]*SIZE[PrincOps.BytePC] + 1;    prefix: CSegPrefix;    fs: CARDINAL;    IF noCatch THEN {catchOffset ¬ 0; MPtr.catchBytes ¬ 0}    ELSE {      lei: EnableIndex;      catchOffset ¬ MoveToCodeWord[];      catchIndex ¬ objectStream.GetPosition[];      FOR l: CARDINAL IN [0..maxLevel]         WHILE (lei ¬ CPtr.enableList[l]) # EINull DO        IF l # 0 THEN ctSize ¬ ctSize + 1;        FOR ei: EnableIndex ¬ lei, cb[ei].next UNTIL ei = EINull DO           ctSize ¬ ctSize + SIZE[CatchFormat.EnableItem];	  ENDLOOP;        ENDLOOP;      codeByteIndex ¬ codeByteIndex + ctSize*2; -- make room for catch entry, enables      objectStream.SetPosition[codeBase + codeByteIndex];      OutputCatchBodies[]};    MPtr.mtRoot.code.length ¬ codeByteIndex;    [] ¬ MoveToCodeWord[];    saveindex ¬ objectStream.GetPosition[];    IF ~noCatch THEN {      objectStream.SetPosition[catchIndex]; codeByteIndex ¬ catchOffset*2;      OutputCatchTables[]};    MPtr.fgTable ¬ DESCRIPTOR[BASE[fgt], fgti+1];    MPtr.codeSeg.pages ¬       (MPtr.mtRoot.code.length+(PageSize-1))/PageSize;    objectStream.SetPosition[codeBase];    fs ¬ P5U.ComputeFrameSize[MPtr.globalFrameSize];    IF syms.bb[Symbols.RootBti].resident THEN fs ¬ fs+PrincOps.AVHeapSize;    prefix ¬ [	globalFsi: fs,	available: 0, 	stops: MPtr.stopping, nlinks: MPtr.linkCount,	mainBodyPC: MPtr.entryVector[0],        catchCode: [catchOffset*2]];    [] ¬ objectStream.PutBlock[      [LOOPHOLE[LONG[@prefix]], 0, SIZE[CSegPrefix]*BytesPerWord]];    OSMiscOps.FreeWords[BASE[catchEntry]];    MPtr.mtRoot.framesize ¬ MPtr.globalFrameSize + SIZE[PrincOps.GlobalOverhead];    MPtr.mtRoot.crossJumped ¬ MPtr.switches['j];    objectStream.SetPosition[saveindex];    CompilerUtil.ReleaseStream[object];  objectStream ¬ NIL;    IF labelPcList # NIL THEN {      FOR i: NATURAL IN [0..labelPcList.count) DO        P5U.FreeChunk[labelPcList[i].label, SIZE[label CCItem]];        ENDLOOP;      MPtr.zone.FREE[@labelPcList]};    RETURN [MPtr.mtRoot.code.length]    END;  END.
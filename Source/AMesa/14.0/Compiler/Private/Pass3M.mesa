-- Copyright (C) 1981, 1983, 1986  by Xerox Corporation. All rights reserved. -- file Pass3M.mesa--   Satterthwaite,	October 8, 1982 3:30 pm--   Donahue,		 9-Dec-81 14:45:35--   Sweet,		 8-Nov-83 12:01:31--   Wagner		18-Aug-86 15:43:45DIRECTORY  Alloc USING [Top],  ComData USING [    bodyIndex, idUNWIND, seAnon, stopping, table, textIndex,    typeCONDITION, typeListANY, typeLOCK],  CLog USING [Error, ErrorSei, ErrorTree],  Pass3 USING [lockNode],  P3 USING [    Attr, fullAttr, NPUse, Safety, TextForm,    pathNP, phraseNP, BoundNP, MergeNP, SequenceNP, SetNP,    And, Apply, BindTree, BumpArgRefs, Bundling, CanonicalType, CheckLocals,    CheckScope, ClearRefStack, CopyTree, DefaultInit, EnterType, EnterComposite,    Exp, FirstId, InitialExp, LongPath, MakeLongType, MakeRefType, MatchFields,    NewableType, OperandInternal, OperandLhs, OperandType, PopCtx, PushCtx,    RAttr, Rhs, RPop, RPush, RType, SealRefStack, SearchCtxList,    Stmt, TypeAppl, TypeForTree, Unbundle, UnsealRefStack, UpdateTreeAttr,    Voidable, VoidExp],  P3S USING [BodyData, continued, currentBody, markCatch, safety],  String USING [SubStringDescriptor],  Symbols USING [    HTIndex, SERecord, SEIndex, ISEIndex, CSEIndex, RecordSEIndex, RefSEIndex,    bodyType, CTXIndex, BodyRecord, BTIndex, CBTIndex,    HTNull, SENull, ISENull, CSENull, RecordSENull, CTXNull, CBTNull,    lG, lZ, RootBti, typeANY],  SymbolOps USING [    ArgCtx, ArgRecord, EnterString, FindString, FirstCtxSe, MakeNonCtxSe,    NextSe, NormalType, ReferentType, TransferTypes, TypeForm,     TypeRoot, UnderType, ToBti, ToTreeIndex],  SymbolTable USING [Handle],  Tree USING [Index, Link, NodeName, Null, NullIndex],  TreeOps USING [    FreeNode, FreeTree, GetNode, ListLength, MakeList, MakeNode,    Map, NthSon, PopTree, PushList, PushTree, PushSe, PushNode, OpName,    ReverseUpdateList, Scan, ScanList, SetAttr, SetInfo, UpdateList,    DecodeBti, DecodeCard, EncodeCard, EncodeSei],  Types USING [Assignable, Equivalent];Pass3M: PROGRAM    IMPORTS      Alloc, Log: CLog, P3, P3S, SymbolOps, TreeOps, Types,      dataPtr: ComData, passPtr: Pass3    EXPORTS P3 = {  OPEN SymbolOps, Symbols, P3, TreeOps;  InsertCatchLabel: PUBLIC SIGNAL [catchSeen, exit: BOOLEAN] = CODE;  syms: SymbolTable.Handle ¬ NIL;    Pass3MInit: PUBLIC PROC [h: SymbolTable.Handle] = { syms ¬ h };  current: LONG POINTER TO P3S.BodyData = @P3S.currentBody; -- statements  MiscStmt: PUBLIC PROC [node: Tree.Index] RETURNS [val: Tree.Link] = {    val ¬ [subtree[index: node]];	-- the default    SELECT syms.tb[node].name FROM      signal, error, start, join, wait => {	PushTree[syms, SELECT syms.tb[node].name FROM	      start => Start[node],	      join => Join[node],	      wait => Wait[node],	      ENDCASE => Signal[node]];	SELECT RType[] FROM	  CSENull, typeANY => NULL;	  ENDCASE => Log.Error[nonVoidStmt];	SetInfo[syms, EncodeCard[dataPtr.textIndex]];  val ¬ PopTree[syms];  RPop[];	pathNP ¬ SequenceNP[pathNP][phraseNP];	IF OpName[syms, val] = error THEN current.reachable ¬ FALSE};      xerror => {	subNode: Tree.Index;	IF current.catchDepth # 0 THEN Log.Error[misplacedReturn];	syms.tb[node].name ¬ error;	val ¬ MiscStmt[node];  subNode ¬ GetNode[syms, val];	IF syms.tb[subNode].attr1 THEN Log.ErrorTree[typeClash, val];	SELECT syms.tb[subNode].name FROM	  error, errorx => syms.tb[subNode].name ¬ xerror;	  ENDCASE => NULL;	syms.tb[subNode].attr1 ¬ current.entry;  syms.tb[subNode].attr3 ¬ FALSE;	IF current.entry THEN syms.tb[subNode].attr2 ¬ CheckLocals[syms.tb[subNode].son[2]];	IF syms.tb[subNode].nSons > 2 THEN Log.Error[misplacedCatch];	current.reachable ¬ FALSE};      resume => Resume[node];      reject => {  	IF current.catchDepth = 0 THEN Log.Error[misplacedResume];	current.reachable ¬ FALSE};      continue, retry => {	SIGNAL InsertCatchLabel[catchSeen:FALSE, exit:syms.tb[node].name=continue];	current.reachable ¬ FALSE};      restart => {val ¬ Restart[node]; pathNP ¬ SequenceNP[pathNP][phraseNP]};      stop => {	IF dataPtr.bodyIndex # RootBti OR current.catchDepth # 0	 OR current.returnRecord # SENull THEN Log.Error[misplacedStop];	dataPtr.stopping ¬ TRUE;  pathNP ¬ SetNP[pathNP]};      notify, broadcast => {	OPEN syms.tb[node];	type: CSEIndex;	IF ~current.lockHeld THEN Log.Error[misplacedMonitorRef];	son[1] ¬ Exp[son[1], typeANY];	IF OperandLhs[son[1]] = none THEN Log.ErrorTree[nonLHS, son[1]];	type ¬ RType[];  RPop[];  pathNP ¬ SequenceNP[pathNP][phraseNP];	IF type # dataPtr.typeCONDITION THEN Log.ErrorTree[typeClash, son[1]]};      free => {	OPEN syms.tb[node];	type, subType: CSEIndex;	long, counted: BOOLEAN;	[v:son[1], long:long, counted:counted] ¬ EvalZone[son[1]];  RPop[];	son[2] ¬ Exp[son[2], typeANY];  type ¬ RType[];  RPop[];	subType ¬ NormalType[syms, type];	WITH s: syms.seb[subType] SELECT FROM	  ref => {	    IF s.readOnly THEN Log.ErrorTree[nonLHS, son[2]];	    type ¬ UnderType[syms, s.refType];	    IF long # (syms.seb[type].typeTag = long) THEN GO TO fail;	    type ¬ NormalType[syms, type];	    WITH t: syms.seb[type] SELECT FROM	      ref => IF t.counted # counted THEN GO TO fail;	      ENDCASE => GO TO fail;	    IF P3S.safety = checked AND ~counted THEN	      Log.ErrorTree[unsafeOperation, [subtree[node]]];	    EXITS	      fail => Log.ErrorTree[typeClash, son[2]]};	  ENDCASE => Log.ErrorTree[typeClash, son[2]];	IF nSons > 3 THEN {	  saveNP: NPUse = phraseNP;	  [] ¬ CatchPhrase[son[4]];  phraseNP ¬ MergeNP[saveNP][phraseNP]};	attr2 ¬ long;  attr3 ¬ counted;	SELECT TRUE FROM	  ~counted  => attr1 ¬ FALSE;	  (OpName[syms, son[2]] # addr) => {Log.ErrorTree[other, son[2]]; attr1 ¬ FALSE};	  ENDCASE => attr1 ¬ OperandLhs[NthSon[syms, son[2], 1]] = counted};      dsk, lsk, xe, xf => {	OPEN syms.tb[node];	v: Tree.Link;	v ¬ son[1] ¬ Exp[son[1], typeANY];  RPop[];	SELECT name FROM	  dsk, lsk => IF OperandLhs[son[1]] = none THEN GO TO fail;	  xe => current.noXfers ¬ FALSE;	  xf => current.reachable ¬ FALSE;	  ENDCASE;	IF name # dsk AND name # lsk THEN phraseNP ¬ SetNP[phraseNP];	pathNP ¬ SequenceNP[pathNP][phraseNP];	-- check for simple addressability	DO	  WITH v SELECT FROM	    symbol => IF syms.seb[index].constant THEN GO TO fail ELSE EXIT;	    subtree => SELECT syms.tb[index].name FROM	      dollar, loophole => v ¬ syms.tb[index].son[1];	      ENDCASE => GO TO fail;	    ENDCASE => GO TO fail;	  ENDLOOP;	IF P3S.safety = checked THEN Log.ErrorTree[unsafeOperation, [subtree[node]]];	EXITS	  fail => Log.ErrorTree[nonLHS, syms.tb[node].son[1]]};      enable => {	OPEN syms.tb[node];	saveEnabled: BOOLEAN = current.unwindEnabled;	IF CatchPhrase[son[1]].unwindCaught THEN current.unwindEnabled ¬ TRUE;	IF phraseNP # none THEN pathNP ¬ unsafe;	son[2] ¬ UpdateList[syms, son[2], Stmt];  attr3 ¬ FALSE;	current.unwindEnabled ¬ saveEnabled};      ENDCASE => Log.Error[unimplemented];    RETURN}; -- dynamic storage allocation  New: PROC [node: Tree.Index, target: CSEIndex] RETURNS [Tree.Link] = {    OPEN syms.tb[node];    pType: RefSEIndex;    subType, rootType: SEIndex;    attr: Attr;    saveNP: NPUse;    long, counted: BOOLEAN;    [v:son[1], long:long, counted:counted] ¬ EvalZone[son[1]];    attr ¬ RAttr[];  RPop[];  saveNP ¬ phraseNP;    current.noXfers ¬ attr.noXfer ¬ FALSE;  attr.const ¬ FALSE;    son[2] ¬ TypeAppl[syms, son[2]];    attr ¬ And[attr, RAttr[]];  saveNP ¬ MergeNP[saveNP][phraseNP];  RPop[];    subType ¬ TypeForTree[son[2]];  rootType ¬ TypeRoot[syms, subType];    IF ~NewableType[subType] THEN Log.ErrorTree[typeLength, son[2]];    IF counted THEN EnterType[rootType, FALSE];    IF son[3] = Tree.Null THEN son[3] ¬ DefaultInit[subType]    ELSE {       StringInit: PROC [t: Tree.Link] RETURNS [BOOLEAN] = INLINE {        RETURN [SELECT OpName[syms, t] FROM	  stringinit => TRUE,	  lengthen => (OpName[syms, NthSon[syms, t, 1]] = stringinit),	  ENDCASE => FALSE]};	        extFlag: BOOLEAN;      [son[3], extFlag] ¬ InitialExp[son[3], subType];      SELECT TRUE FROM	extFlag => Log.ErrorTree[misusedInline, son[3]];	StringInit[son[3]] => Log.ErrorTree[defaultForm, son[3]];	ENDCASE};    attr ¬ And[attr, RAttr[]];  phraseNP ¬ SequenceNP[saveNP][phraseNP];  RPop[];    pType ¬ MakeRefType[	cType: subType, readOnly: syms.tb[node].attr1, counted: counted,	hint: NormalType[syms, target]];    IF counted THEN {--    rType: RefSEIndex = MakeRefType[cType: rootType, counted: TRUE, hint: pType];--    EnterType[IF long THEN MakeLongType[rType, target] ELSE rType, FALSE];      IF son[3] # Tree.Null THEN EnterComposite[UnderType[syms, subType], son[3], TRUE]};    IF son[3] = Tree.Null AND ~Voidable[subType] THEN      Log.ErrorTree[missingInit, [subtree[node]]];    IF nSons > 3 THEN {      saveNP: NPUse = phraseNP;      [] ¬ CatchPhrase[son[4]];  phraseNP ¬ MergeNP[saveNP][phraseNP]};    attr2 ¬ long;  attr3 ¬ counted;    RPush[IF long THEN MakeLongType[pType, target] ELSE pType, attr];    RETURN [[subtree[index: node]]]};  EvalZone: PROC [t: Tree.Link] RETURNS [v: Tree.Link, long, counted: BOOLEAN] = {    type, nType: CSEIndex;    nDerefs: CARDINAL;    long ¬ TRUE;    counted ¬ FALSE;    IF t = Tree.Null THEN {v ¬ Tree.Null;  RPush[typeANY, fullAttr]}    ELSE {      v ¬ Exp[t, typeANY];  type ¬ RType[];  nDerefs ¬ 0;      DO	nType ¬ NormalType[syms, type];	WITH s: syms.seb[nType] SELECT FROM	  zone => {long ¬ ~s.mds; <<counted ¬ s.counted;>> GO TO success};	  ref => {	    IF (nDerefs ¬ nDerefs + 1) > 63 THEN GO TO failure;	    PushTree[syms, v];  PushNode[syms, uparrow, 1];  SetAttr[syms, 2, syms.seb[type].typeTag = long];	    type ¬ UnderType[syms, s.refType];  SetInfo[syms, EncodeSei[type]];  	    v ¬ PopTree[syms]};	  record =>	    IF Bundling[nType] # 0 THEN type ¬ Unbundle[LOOPHOLE[nType, RecordSEIndex]]	    ELSE GO TO failure;	  ENDCASE => GO TO failure;	REPEAT	  success => NULL;	  failure => Log.ErrorTree[typeClash, v];	ENDLOOP};    RETURN}; -- list allocation  Cons: PROC [node: Tree.Index, target: CSEIndex] RETURNS [Tree.Link] = {    nType: CSEIndex = NodeType[target, [subtree[node]]];    PushTree[syms, syms.tb[node].son[1]];  syms.tb[node].son[1] ¬ Tree.Null;    PushNode[syms, implicitTC, 0];  SetInfo[syms, EncodeSei[nType]];    PushTree[syms, syms.tb[node].son[2]];  syms.tb[node].son[2] ¬ Tree.Null;    PushTree[syms, Tree.Null];  PushNode[syms, apply, -2];  SetAttr[syms, 1, FALSE];    IF syms.tb[node].nSons > 2 THEN {      PushTree[syms, syms.tb[node].son[3]]; syms.tb[node].son[3] ¬ Tree.Null; PushNode[syms, new, 4]}    ELSE PushNode[syms, new, 3];    FreeNode[syms, node];    RETURN [Exp[PopTree[syms], target]]};  ListCons: PROC [node: Tree.Index, target: CSEIndex] RETURNS [Tree.Link] = {    nType: CSEIndex = NodeType[target, [subtree[node]]];    n: CARDINAL = ListLength[syms, syms.tb[node].son[2]];    k: CARDINAL ¬ n;    list, zone: Tree.Link;    ListItem: TreeOps.Map = {      PushTree[syms, IF (k¬k-1) = 0 THEN zone ELSE P3.CopyTree[syms, zone]];      PushNode[syms, implicitTC, 0];  SetInfo[syms, EncodeSei[nType]];      PushTree[syms, t];  PushTree[syms, list];  PushList[syms, 2];      PushTree[syms, Tree.Null];  PushNode[syms, apply, -2];  SetAttr[syms, 1, FALSE];      list ¬ MakeNode[syms, new, 3];      RETURN [Tree.Null]};    PushTree[syms, Tree.Null];  list ¬ MakeNode[syms, nil, 1];    IF n = 0 THEN [v: syms.tb[node].son[1]] ¬ EvalZone[syms.tb[node].son[1]]    ELSE {      zone ¬ syms.tb[node].son[1];  syms.tb[node].son[1] ¬ Tree.Null;      syms.tb[node].son[2] ¬ ReverseUpdateList[syms, syms.tb[node].son[2], ListItem]};    FreeNode[syms, node];    RETURN [Exp[list, target]]};  NodeType: PROC [target: CSEIndex, t: Tree.Link] RETURNS [nType: CSEIndex] = {    subType: CSEIndex = NormalType[syms, target];    WITH r: syms.seb[subType] SELECT FROM      ref => {	rType: CSEIndex = UnderType[syms, r.refType];	IF ~r.list AND (syms.seb[rType].typeTag = any OR rType = typeANY) THEN	  nType ¬ ReferentType[syms, dataPtr.typeListANY]	ELSE {	  IF ~r.list THEN Log.ErrorTree[typeClash, t];	  nType ¬ rType}};      ENDCASE =>	IF subType = typeANY THEN nType ¬ ReferentType[syms, dataPtr.typeListANY]	ELSE {Log.ErrorTree[typeClash, t]; nType ¬ typeANY};    RETURN}; -- control transfers  MiscXfer: PUBLIC PROC [node: Tree.Index, target: CSEIndex] RETURNS [val: Tree.Link] = {    SELECT syms.tb[node].name FROM      new => val ¬ New[node, target];      signalx, errorx => val ¬ Signal[node];      create => val ¬ Create[node, target];      startx => val ¬ Start[node];      fork => val ¬ Fork[node, target];      joinx => val ¬ Join[node];      cons => val ¬ Cons[node, target];      listcons => val ¬ ListCons[node, target];      ENDCASE => {Log.Error[unimplemented]; val ¬ [subtree[node]]};    RETURN};  MakeFrameRecord: PUBLIC PROC [t: Tree.Link] RETURNS [rSei: CSEIndex] = {    bti: CBTIndex = XferBody[t];    IF bti # CBTNull THEN {      argType: SEIndex = TransferTypes[syms, syms.bb[bti].ioType].typeIn;      rSei ¬ IF syms.bb[bti].type # RecordSENull AND argType = SENull        THEN syms.bb[bti].type        ELSE AllocFrameRecord[bti, argType]}    ELSE {Log.Error[nonTypeCons]; rSei ¬ typeANY};    RETURN};  AllocFrameRecord: PROC [bti: CBTIndex, link: SEIndex] RETURNS [sei: RecordSEIndex] = {    sei ¬ LOOPHOLE[MakeNonCtxSe[syms, SIZE[linked record cons SERecord]]];    syms.seb[sei] ¬ SERecord[mark3: TRUE, mark4: FALSE,	body: cons[record[	    machineDep: FALSE,	    painted: TRUE, argument: FALSE,	    hints: [		unifield: FALSE, variant: FALSE,		assignable: FALSE, comparable: FALSE, privateFields: TRUE,		refField: TRUE, default: FALSE, voidable: FALSE],	    fieldCtx: syms.bb[bti].localCtx,	    length: IF syms.bb[bti].type # RecordSENull THEN syms.seb[syms.bb[bti].type].length ELSE 0,	    monitored: syms.bb[bti].monitored,	    linkPart: linked[link]]]];    RETURN};  BodyForTree: PUBLIC PROC [t: Tree.Link] RETURNS [CBTIndex] = {    sei: ISEIndex;    node, subNode: Tree.Index;    WITH t SELECT FROM      symbol => {	sei ¬ index;	SELECT TRUE FROM	  syms.seb[sei].mark4 =>	    RETURN [IF syms.seb[sei].constant THEN 	      ToBti[syms.seb[sei].idInfo] ELSE CBTNull]; 	  syms.seb[sei].immutable => {	    node ¬ ToTreeIndex[syms.seb[sei].idValue];	    WITH syms.tb[node].son[3] SELECT FROM	      subtree => {		subNode ¬ index;		IF syms.tb[subNode].name = body THEN 		  RETURN [DecodeBti[syms.tb[subNode].info]]};	      ENDCASE};	  ENDCASE};      subtree => {	node ¬ index;	SELECT syms.tb[node].name FROM	  cdot, dot, dollar => RETURN [BodyForTree[syms.tb[node].son[2]]];	  ENDCASE};      ENDCASE;    RETURN [CBTNull]};  XferBody: PROC [t: Tree.Link] RETURNS [bti: CBTIndex] = {    sei: ISEIndex;    type: CSEIndex;    WITH t SELECT FROM      symbol => {	sei ¬ index;  type ¬ UnderType[syms, syms.seb[sei].idType];	bti ¬ WITH syms.seb[type] SELECT FROM	  transfer =>	    IF ~syms.seb[sei].immutable	      THEN CBTNull	      ELSE		SELECT mode FROM		  program =>		    IF syms.seb[sei].mark4 THEN 		      (IF syms.seb[sei].constant THEN 		        ToBti[syms.seb[sei].idInfo] ELSE CBTNull)		      ELSE RootBti,		  proc =>		    IF sei = syms.bb[dataPtr.bodyIndex].id THEN dataPtr.bodyIndex ELSE CBTNull,		  ENDCASE => CBTNull,	  ENDCASE => CBTNull};      ENDCASE => bti ¬ CBTNull;    RETURN};  XferForFrame: PUBLIC PROC [ctx: CTXIndex] RETURNS [type: CSEIndex ¬ CSENull] = {    bti: BTIndex ¬ FIRST[BTIndex];    btLimit: BTIndex = (dataPtr.table).Top[bodyType];    UNTIL bti = btLimit DO      WITH entry: syms.bb[bti] SELECT FROM	Callable => {	  IF entry.localCtx = ctx THEN RETURN [UnderType[syms, entry.ioType]];	  bti ¬ bti + (WITH  entry SELECT FROM		    Inner => SIZE[Inner Callable BodyRecord],		    Catch => SIZE[Catch Callable BodyRecord],		    ENDCASE => SIZE[Outer Callable BodyRecord])};	ENDCASE => bti ¬ bti + SIZE[Other BodyRecord];      ENDLOOP;    RETURN [CSENull]};  Create: PROC [node: Tree.Index, target: CSEIndex] RETURNS [val: Tree.Link] = {    subNode: Tree.Index;    nType: CSEIndex;    val ¬ ForceApplication[syms.tb[node].son[1]];    syms.tb[node].son[1] ¬ Tree.Null;  FreeNode[syms, node];    subNode ¬ GetNode[syms, val];      BEGIN  OPEN syms.tb[subNode];      type, mType, rType: CSEIndex;      attr: Attr;      CreateError: PROC = {Log.ErrorTree[typeClash, son[1]]; type ¬ typeANY};      name ¬ create;  attr1 ¬ TRUE;      son[1] ¬ Exp[son[1], typeANY];      mType ¬ RType[];  attr ¬ RAttr[];  RPop[];  phraseNP ¬ SetNP[phraseNP];      nType ¬ NormalType[syms, mType];      WITH syms.seb[nType] SELECT FROM	transfer =>	  IF mode = program THEN	    SELECT XferBody[son[1]] FROM	      CBTNull => type ¬ mType;	      RootBti => {		type ¬ IF syms.seb[NormalType[syms, target]].typeTag = ref		  THEN MakeLongType[		    MakeRefType[MakeFrameRecord[son[1]], NormalType[syms, target]],		    target]		  ELSE mType;		attr1 ¬ FALSE};	      ENDCASE => CreateError[]	  ELSE CreateError[];	ref => {	  type ¬ IF TypeForm[syms, mType] = long THEN mType 	    ELSE MakeLongType[mType, typeANY]; 	  rType ¬ UnderType[syms, refType];	  WITH syms.seb[rType] SELECT FROM	    record =>	      SELECT TRUE FROM		(syms.ctxb[fieldCtx].level # lG) => CreateError[];		(syms.seb[target].typeTag = transfer) => {		  type ¬ XferForFrame[fieldCtx];		  IF type = CSENull THEN {Log.Error[unimplemented]; type ¬ typeANY}};		ENDCASE;	    ENDCASE =>  IF refType # typeANY THEN CreateError[]};	ENDCASE => IF mType = typeANY THEN type ¬ typeANY ELSE CreateError[];      IF son[2] # Tree.Null THEN {	Log.ErrorTree[noApplication, son[1]]; son[2] ¬ UpdateList[syms, son[2], VoidExp]};      IF nSons > 2 THEN [] ¬ CatchPhrase[son[3]];      current.noXfers ¬ attr.noXfer ¬ FALSE;  attr.const ¬ FALSE;      RPush[type, attr];      END;    RETURN};  Start: PROC [node: Tree.Index] RETURNS [Tree.Link] = {    subNode: Tree.Index;    subNode ¬ Apply[GetNode[syms, ForceApplication[syms.tb[node].son[1]]], typeANY, TRUE];    SELECT syms.tb[subNode].name FROM      start, startx, apply => NULL;      ENDCASE => Log.ErrorTree[typeClash, syms.tb[subNode].son[1]];    syms.tb[node].son[1] ¬ Tree.Null;  FreeNode[syms, node];    RETURN [[subtree[subNode]]]};  Restart: PROC [node: Tree.Index] RETURNS [val: Tree.Link] = {    subNode: Tree.Index;    type: CSEIndex;    val ¬ ForceApplication[syms.tb[node].son[1]];    subNode ¬ GetNode[syms, val];      BEGIN  OPEN syms.tb[subNode];      name ¬ syms.tb[node].name;  info ¬ syms.tb[node].info;      son[1] ¬ Exp[son[1], typeANY];  type ¬ RType[];  RPop[];      phraseNP ¬ SetNP[phraseNP];      WITH syms.seb[type] SELECT FROM	ref => NULL;		-- a weak check for now	transfer =>	  IF mode # program OR XferBody[son[1]] # CBTNull THEN Log.ErrorTree[typeClash, son[1]];	ENDCASE => IF type # typeANY THEN Log.ErrorTree[typeClash, son[1]];      IF son[2] # Tree.Null THEN {	Log.ErrorTree[noApplication, son[1]]; son[2] ¬ UpdateList[syms, son[2], VoidExp]};      IF nSons > 2 THEN [] ¬ CatchPhrase[son[3]];      END;    current.noXfers ¬ FALSE;    syms.tb[node].son[1] ¬ Tree.Null;  FreeNode[syms, node];  RETURN};  Fork: PROC [node: Tree.Index, target: CSEIndex] RETURNS [Tree.Link] = {    subNode: Tree.Index;    type: CSEIndex;    attr: Attr;    t: Tree.Link ¬ ForceApplication[syms.tb[node].son[1]];    syms.tb[node].son[1] ¬ Tree.Null;  FreeNode[syms, node];    subNode ¬ Apply[GetNode[syms, t], typeANY, TRUE];  attr ¬ RAttr[];  RPop[];    SELECT syms.tb[subNode].name FROM      call, callx => {	s: Tree.Link ¬ syms.tb[subNode].son[1];	subType: CSEIndex;	IF OpName[syms, s] = thread THEN {	  s ¬ NthSon[syms, s, 1]; Log.ErrorTree[misusedInline, s]};	IF current.lockHeld AND OperandInternal[s] THEN	  Log.ErrorTree[internalCall, s];	subType ¬ OperandType[s];	WITH procType: syms.seb[subType] SELECT FROM	  transfer => {	    type ¬ MakeNonCtxSe[syms, SIZE[transfer cons SERecord]];	    syms.seb[type] ¬ SERecord[mark3: TRUE, mark4: TRUE,			  body: cons[transfer[			      mode: process, safe: procType.safe,			      typeIn: RecordSENull,			      typeOut: procType.typeOut]]];	    IF P3S.safety = checked THEN {	    	      CheckArg: TreeOps.Map = {	        argType: CSEIndex = OperandType[t];		subType: CSEIndex = NormalType[syms, argType];		WITH s: syms.seb[subType] SELECT FROM		  ref => {IF s.var THEN Log.ErrorTree[unsafeOperation, t]; v ¬ t};		  transfer => v ¬ CheckScope[t, argType];		  ENDCASE => v ¬ t;		RETURN};		  	      syms.tb[subNode].son[1] ¬ CheckScope[s, subType];	      syms.tb[subNode].son[2] ¬ UpdateList[syms, syms.tb[subNode].son[2], CheckArg]}};	  ENDCASE => ERROR;	syms.tb[subNode].name ¬ fork};      apply => type ¬ typeANY;      ENDCASE => {Log.ErrorTree[typeClash, syms.tb[node].son[1]]; type ¬ typeANY};    syms.tb[subNode].info ¬ EncodeSei[type];  RPush[type, attr];    RETURN [[subtree[subNode]]]};  Join: PROC [node: Tree.Index] RETURNS [Tree.Link] = {    subNode: Tree.Index;    subNode ¬ Apply[GetNode[syms, ForceApplication[syms.tb[node].son[1]]], typeANY, TRUE];    SELECT syms.tb[subNode].name FROM      join, joinx => NULL;      apply => NULL;      ENDCASE => Log.ErrorTree[typeClash, syms.tb[subNode].son[1]];    syms.tb[node].son[1] ¬ Tree.Null;  FreeNode[syms, node];    RETURN [[subtree[subNode]]]};  Wait: PROC [node: Tree.Index] RETURNS [val: Tree.Link] = {    subNode: Tree.Index;    saveNP: NPUse;    IF ~current.lockHeld THEN Log.Error[misplacedMonitorRef];    subNode ¬ Apply[GetNode[syms, ForceApplication[syms.tb[node].son[1]]], typeANY, TRUE];    SELECT syms.tb[subNode].name FROM      wait => NULL;      apply => NULL;      ENDCASE => Log.ErrorTree[typeClash, syms.tb[subNode].son[1]];    syms.tb[node].son[1] ¬ Tree.Null;  FreeNode[syms, node];    IF OperandLhs[syms.tb[subNode].son[1]] = none THEN Log.ErrorTree[nonLHS, syms.tb[subNode].son[1]];    [] ¬ FreeTree[syms, syms.tb[subNode].son[2]];    saveNP ¬ phraseNP;    syms.tb[subNode].son[2] ¬ syms.tb[subNode].son[1];  syms.tb[subNode].son[1] ¬ CopyLock[];    phraseNP ¬ MergeNP[saveNP][phraseNP];    RETURN [[subtree[subNode]]]}; -- monitors  LockVar: PUBLIC PROC [t: Tree.Link] RETURNS [val: Tree.Link] = {    type, nType: CSEIndex;    desc: String.SubStringDescriptor;    sei: ISEIndex;    nDerefs: CARDINAL;    long, b: BOOLEAN;    Dereference: PROC [type: CSEIndex] = {      PushTree[syms, val];  PushNode[syms, uparrow, 1];        SetInfo[syms, EncodeSei[type]];  SetAttr[syms, 2, long];      val ¬ PopTree[syms]};    val ¬ Exp[t, typeANY];  long ¬ LongPath[val];    type ¬ RType[];  RPop[];  nDerefs ¬ 0;    DO      IF type = dataPtr.typeLOCK THEN {IF nDerefs # 0 THEN Dereference[type]; GO TO success};      type ¬ UnderType[syms, TypeRoot[syms, type]];  nType ¬ NormalType[syms, type];      WITH syms.seb[nType] SELECT FROM	record => {	  IF monitored THEN {	    desc ¬ ["LOCK"L, 0, ("LOCK"L).length];	    [b, sei] ¬ SearchCtxList[EnterString[syms, @desc], fieldCtx];	    IF ~b THEN {Log.Error[noAccess]; sei ¬ dataPtr.seAnon};	    PushTree[syms, val];  PushSe[syms, sei];	    PushNode[syms, IF nDerefs = 0 THEN dollar ELSE dot, 2];	    SetInfo[syms, EncodeSei[dataPtr.typeLOCK]];  SetAttr[syms, 2, long];  val ¬ PopTree[syms];	    GO TO success};	  GO TO failure};	ref => {	  IF (nDerefs ¬ nDerefs + 1) > 63 THEN GO TO failure;	  long ¬ syms.seb[type].typeTag = long;	  IF nDerefs > 1 THEN Dereference[type];	  type ¬ UnderType[syms, refType]};	ENDCASE => GO TO failure;      REPEAT	success => NULL;	failure => Log.ErrorTree[typeClash, val];      ENDLOOP;    IF OperandLhs[val] = none THEN Log.ErrorTree[nonLHS, val];    RETURN};  FindLockParams: PUBLIC PROC RETURNS [formal, actual: ISEIndex] = {    node: Tree.Index = GetNode[syms, syms.tb[passPtr.lockNode].son[1]];    found: BOOLEAN;    IF node = Tree.NullIndex THEN formal ¬ actual ¬ ISENull    ELSE {      formal ¬ FirstId[node];      IF current.inputRecord = SENull THEN found ¬ FALSE      ELSE [found, actual] ¬ SearchCtxList[		    syms.seb[formal].hash,		    syms.seb[current.inputRecord].fieldCtx];      IF ~found THEN actual ¬ ISENull};    RETURN};  LambdaApply: PROC [t: Tree.Link, formal, actual: ISEIndex] RETURNS [v: Tree.Link] = {    BindFormal: PROC [sei: ISEIndex] RETURNS [Tree.Link] = {      RETURN [[symbol[index: IF sei = formal THEN actual ELSE sei]]]};    v ¬ BindTree[t, BindFormal];    [] ¬ UpdateTreeAttr[v];    RETURN};  CopyLock: PUBLIC PROC RETURNS [val: Tree.Link] = {    formal, actual: ISEIndex;    SELECT TRUE FROM      passPtr.lockNode = Tree.NullIndex => val ¬ Tree.Null;      syms.tb[current.bodyNode].son[4] # Tree.Null =>	val ¬ LambdaApply[syms.tb[current.bodyNode].son[4], ISENull, ISENull];      ENDCASE => {	[formal:formal, actual:actual] ¬ FindLockParams[];	IF formal # SENull THEN {	  IF actual = SENull THEN {Log.ErrorSei[missingLock, formal]; actual ¬ dataPtr.seAnon};	  IF ~Types.Assignable[		    [syms, UnderType[syms, syms.seb[formal].idType]],		    [syms, UnderType[syms, syms.seb[actual].idType]]] THEN	    Log.ErrorSei[typeClash, actual]};	val ¬ LambdaApply[syms.tb[passPtr.lockNode].son[2], formal, actual]};    RETURN}; -- signals  Signal: PUBLIC PROC [node: Tree.Index] RETURNS [val: Tree.Link] = {    subNode: Tree.Index;    nodeTag: Tree.NodeName = syms.tb[node].name;    subNode ¬ Apply[GetNode[syms, ForceApplication[syms.tb[node].son[1]]], typeANY, TRUE];    SELECT syms.tb[subNode].name FROM      signal, signalx => syms.tb[subNode].name ¬ nodeTag;      error, errorx => {	SELECT nodeTag FROM 	  signal, signalx => Log.ErrorTree[typeClash, syms.tb[subNode].son[1]];	  ENDCASE => NULL;	syms.tb[subNode].name ¬ nodeTag};      apply => NULL;      ENDCASE => Log.ErrorTree[typeClash, syms.tb[subNode].son[1]];    syms.tb[node].son[1] ¬ Tree.Null;  FreeNode[syms, node];    RETURN [[subtree[subNode]]]};  ForceApplication: PROC [t: Tree.Link] RETURNS [Tree.Link] = {    IF OpName[syms, t] = apply THEN  RETURN [t];    PushTree[syms, t];  PushTree[syms, Tree.Null];    RETURN [MakeNode[syms, apply, 2]]}; -- catch phrases  CatchPhrase: PUBLIC PROC [t: Tree.Link] RETURNS [unwindCaught: BOOLEAN] = {    saveReachable: BOOLEAN = current.reachable;    savePathNP: NPUse = pathNP;    saveSafety: Safety = P3S.safety;    enclosingSafe: BOOLEAN = (saveSafety = checked);    entryNP, exitNP: NPUse;    CatchItem: TreeOps.Scan = {      node: Tree.Index = GetNode[syms, t];      type: CSEIndex ¬ typeANY;      mixed, safe, error: BOOLEAN ¬ FALSE;      saveIndex: CARDINAL = dataPtr.textIndex;      CatchLabel: TreeOps.Map = {	subType: CSEIndex;	v ¬ Exp[t, typeANY];  subType ¬ CanonicalType[RType[]];  RPop[];	entryNP ¬ SequenceNP[entryNP][phraseNP];	WITH t: syms.seb[subType] SELECT FROM	  transfer =>	    IF t.mode = signal OR t.mode = error THEN {	      IF type = typeANY THEN type ¬ subType	      ELSE IF ~Types.Equivalent[		    [syms, type], [syms, subType]] THEN	        mixed ¬ TRUE;	      IF t.safe THEN safe ¬ TRUE;	      IF t.mode = error THEN error ¬ TRUE}	    ELSE Log.ErrorTree[typeClash, v];	  ENDCASE => IF subType # typeANY THEN Log.ErrorTree[typeClash, v];	RETURN};      dataPtr.textIndex ¬ DecodeCard[syms.tb[node].info];      syms.tb[node].son[1] ¬ UpdateList[syms, syms.tb[node].son[1], CatchLabel];      IF mixed THEN type ¬ typeANY;      syms.tb[node].son[2] ¬ CatchBody[          syms.tb[node].son[2], type, safe OR (error AND enclosingSafe)];      IF syms.tb[node].son[1] = Tree.Link[symbol[index: dataPtr.idUNWIND]] THEN {	unwindCaught ¬ TRUE;	IF current.entry AND ~current.unwindEnabled AND current.catchDepth = 0 THEN {	  PushTree[syms, syms.tb[node].son[2]];  PushTree[syms, CopyLock[]];	  PushNode[syms, unlock, 1];  SetInfo[syms, EncodeCard[dataPtr.textIndex]];	  syms.tb[node].son[2] ¬ MakeList[syms, 2]}};      syms.tb[node].info ¬ EncodeSei[IF type # typeANY THEN type ELSE SENull];      dataPtr.textIndex ¬ saveIndex;  RETURN};    CatchBody: PROC [body: Tree.Link, type: CSEIndex, safe: BOOLEAN]        RETURNS [val: Tree.Link] = {      saveRecord:  RecordSEIndex = current.resumeRecord;      saveFlag: BOOLEAN = current.resumeFlag;      current.catchDepth ¬ current.catchDepth + 1;      WITH t: syms.seb[type] SELECT FROM	transfer => {	  current.resumeFlag ¬ t.mode = signal;	  PushArgCtx[t.typeIn];	  BumpArgRefs[ArgRecord[syms, t.typeIn], TRUE];	  PushArgCtx[current.resumeRecord ¬ ArgRecord[syms, t.typeOut]];	  ClearRefStack[]};	ENDCASE => {	  current.resumeFlag ¬ FALSE; current.resumeRecord ¬ RecordSENull};      current.reachable ¬ TRUE;  pathNP ¬ entryNP;   <<   SELECT OpName[syms, body] FROM	block, checked => SetSafety[SafetyAttr[GetNode[syms, body]]]; 	ENDCASE;      IF safe AND P3S.safety = none THEN Log.Error[unsafeBlock];    >>      val ¬ UpdateList[syms, body, Stmt ! InsertCatchLabel => {IF catchSeen THEN RESUME}];      exitNP ¬ BoundNP[exitNP][pathNP];      WITH t: syms.seb[type] SELECT FROM	transfer => {PopArgCtx[t.typeOut]; PopArgCtx[t.typeIn]};	ENDCASE;      current.catchDepth ¬ current.catchDepth - 1;      current.resumeRecord ¬ saveRecord;  current.resumeFlag ¬ saveFlag;  --    SetSafety[saveSafety];        RETURN};    setLabel, continued: BOOLEAN;    node: Tree.Index = GetNode[syms, t];    SealRefStack[];    setLabel ¬ continued ¬ unwindCaught ¬ FALSE;  entryNP ¬ exitNP ¬ none;      BEGIN      ENABLE InsertCatchLabel => {	IF ~catchSeen THEN {	  setLabel ¬ TRUE;  IF exit THEN continued ¬ TRUE;	  SIGNAL InsertCatchLabel[catchSeen:TRUE, exit:exit]; RESUME}};      ScanList[syms, syms.tb[node].son[1], CatchItem];      IF syms.tb[node].nSons > 1 THEN        syms.tb[node].son[2] ¬ CatchBody[syms.tb[node].son[2], typeANY, enclosingSafe];      END;    IF setLabel THEN {P3S.markCatch ¬ TRUE; P3S.continued ¬ continued};    UnsealRefStack[];  current.reachable ¬ saveReachable;    phraseNP ¬ exitNP;  pathNP ¬ savePathNP;  RETURN};  PushArgCtx: PROC [sei: CSEIndex] = {    ctx: CTXIndex = ArgCtx[syms, sei];    IF ctx # CTXNull THEN {      syms.ctxb[ctx].level ¬ current.level + current.catchDepth; PushCtx[ctx]}};  PopArgCtx: PROC [sei: CSEIndex] = {    ctx: CTXIndex = ArgCtx[syms, sei];    IF ctx # CTXNull THEN {PopCtx[]; syms.ctxb[ctx].level ¬ lZ}};  Resume: PROC [node: Tree.Index] = {    OPEN syms.tb[node];    rSei: RecordSEIndex = current.resumeRecord;    IF ~current.resumeFlag THEN Log.Error[misplacedResume];    IF rSei # SENull AND son[1] = Tree.Null THEN {      n: CARDINAL ¬ 0;      BumpArgRefs[rSei, FALSE];      FOR sei: ISEIndex ¬ FirstCtxSe[syms, syms.seb[rSei].fieldCtx], NextSe[syms, sei] UNTIL sei = SENull DO	n ¬ n+1; 	IF n=1 AND syms.seb[sei].hash = HTNull THEN Log.Error[illDefinedReturn];	PushSe[syms, sei];	ENDLOOP;      son[1] ¬ MakeList[syms, n]}    ELSE {      son[1] ¬ IF attr1 AND rSei # SENull        THEN Rhs[son[1], rSei]	ELSE MatchFields[rSei, son[1]];      RPop[];      pathNP ¬ SequenceNP[pathNP][phraseNP]};    current.reachable ¬ FALSE}; -- Rope identification (temporary)   CheckHash: PROC [hti: HTIndex, s: LONG STRING] RETURNS [BOOLEAN] = {    desc: String.SubStringDescriptor;    desc ¬ [base: s, offset: 0, length: s.length];    RETURN [FindString[syms, @desc] = hti]};      TextRep: PUBLIC PROC [rType: SEIndex] RETURNS [form: TextForm ¬ text] = {    type: CSEIndex = UnderType[syms, rType];    rope: STRING = "Rope"L;    ropeRep: STRING = "RopeRep"L;    textRep: STRING = "TextRep"L;    WITH se: syms.seb[rType] SELECT FROM      id =>	IF CheckHash[se.hash, ropeRep] THEN form ¬ rope	ELSE IF CheckHash[se.hash, textRep] THEN form ¬ ropeText;      ENDCASE;    WITH t: syms.seb[type] SELECT FROM      record =>        WITH c: syms.ctxb[t.fieldCtx] SELECT FROM	  included => IF ~CheckHash[syms.mdb[c.module].moduleId, rope] THEN form ¬ text;	  ENDCASE => form ¬ text;      ENDCASE => form ¬ text;    RETURN};             }.
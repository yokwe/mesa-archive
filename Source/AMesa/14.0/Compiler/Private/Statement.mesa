-- Copyright (C) 1983, 1984, 1986  by Xerox Corporation. All rights reserved. -- Statement.mesa--   Sweet,		17-Apr-84 17:33:11--   Satterthwaite,	August 16, 1982 11:52 am--   Johnsson,		12-Jun-83 13:13:25--   Wagner		22-Aug-86  8:37:50DIRECTORY  Alloc USING [Notifier],  CatchFormat USING [CatchAction, defaultFsi],  Code USING [    actenable, caseCVState, catchcount, catchoutrecord,     CodeNotImplemented, codeptr, codeStart, curctxlvl, enableLevel,     fileindex, framesz,     inlineFileIndex, mwCaseCV, StackNotEmptyAtStatement, xtracting],  CodeDefs USING [    BYTE, CaseCVState, CCIndex, CCItem, codeType, EnableIndex,     JumpType, LabelCCIndex, LabelCCNull, LabelInfoIndex, Lexeme,     NULLfileindex, NullLex, OtherCCIndex, StackIndex, TempStateRecord,     VarComponent, VarIndex],  ComData USING [bodyIndex, ownSymbols, switches, textIndex],  FOpCodes USING [    qBC, qBNDCK, qCATCH, qCATCHFSI, qDADD, qDCMP, qDEC, qDSK, qDSUB,     qINC, qLP, qLSK, qXE, qXF, qNC, qREC, qRET, qUDCMP],  CLog USING [Error, Warning],  P5 USING [    BindStmtExp, CaseStmtExp, CaseTest, Exp, FlowTree, GenAnonLex, GenHeapLex,    GetLabelMark, LabelCreate, LabelList, LogHeapFree, MakeExitLabel, P5Error,    PopInVals, PopTempState, PurgeHeapList, PurgePendTempList, PushHeapList,    PushLex, PushRhs, PushTempState, ReleaseTempLex, SAssign, SysCall, SysError,    TTAssign],  P5L USING [LoadAddress, MakeComponent, OVarItem, VarForLex],  P5S USING [    Assign, Call, CatchMark, Continue, Exit, Extract, Free, GoTo, Join, Label, Lock,     Loop, ProcInit, Restart, Result, Resume, Retry, Return, RetWithError,     SigErr, Start, Stop, Subst, Unlock, Wait],  P5U USING [    BeginCatch, CCellAlloc, ComputeFrameSize, EndCatch, InsertLabel,    LabelAlloc, NewEnableItem, Out0, Out1, OutEnableMark, OutJump, OutSource,    PushLitVal, TreeLiteralValue, WordsForOperand],  PrincOps USING [AVHeapSize, localbase],  Stack USING [    Clear, Decr, Depth, Mark, New, Off, On,     Reset, Restore],  SymbolOps USING [TransferTypes],  Symbols USING [    Base, BTIndex, BTNull, CCBTIndex, CCBTNull, ContextLevel,    CSEIndex, CSENull, CTXIndex, CTXNull, ISEIndex, ISENull, RecordSEIndex,     RecordSENull],  SymbolTable USING [Handle],  Tree USING [Index, Link, NodeName, Null],  TreeOps USING [    DecodeBti, DecodeCard, DecodeCSei, FreeTree, GetNode, GetSe, ReverseUpdateList,     ScanList, SetShared, UpdateList];Statement: PROGRAM    IMPORTS MPtr: ComData, CPtr: Code, P5U, P5L, P5, P5S,      Stack, SymbolOps, TreeOps, Log: CLog    EXPORTS CodeDefs, P5 =  BEGIN  OPEN FOpCodes, CodeDefs;  -- imported definitions  ISEIndex: TYPE = Symbols.ISEIndex;  ISENull: ISEIndex = Symbols.ISENull;  CSEIndex: TYPE = Symbols.CSEIndex;  CSENull: CSEIndex = Symbols.CSENull;  RecordSEIndex: TYPE = Symbols.RecordSEIndex;  RecordSENull: RecordSEIndex = Symbols.RecordSENull;  BTIndex: TYPE = Symbols.BTIndex;  BTNull: BTIndex = Symbols.BTNull;  CCBTIndex: TYPE = Symbols.CCBTIndex;  cb: Symbols.Base;		-- code base (local copy)  syms: SymbolTable.Handle ¬ NIL;  StatementNotify: PUBLIC Alloc.Notifier =    BEGIN  -- called by allocator whenever table area is repacked    syms ¬ MPtr.ownSymbols;    cb ¬ base[codeType];    END;  catchEndLabel: LabelCCIndex ¬ LabelCCNull;  recentStmt: PUBLIC Tree.Link; -- for debugging  StatementTree: PUBLIC PROC [h: SymbolTable.Handle, t: Tree.Link] RETURNS [Tree.Link] =    BEGIN -- generates code for Mesa statements    node: Tree.Index;    saveHeapList: ISEIndex;    saveIndex: CARDINAL = MPtr.textIndex;    recentStmt ¬ t;    IF t = Tree.Null THEN RETURN [Tree.Null];    BEGIN    ENABLE       BEGIN      P5.LogHeapFree => RESUME [TRUE, P5.GenHeapLex[]];      CPtr.CodeNotImplemented => IF ~MPtr.switches['d] THEN	GO TO unimplementedConstruct;      END;    saveHeapList ¬ P5.PushHeapList[];    WITH t SELECT FROM      subtree =>	BEGIN        fIndex: CARDINAL ¬ CPtr.inlineFileIndex;	node ¬ index;	IF fIndex = NULLfileindex THEN fIndex ¬ TreeOps.DecodeCard[syms.tb[node].info];        IF fIndex # NULLfileindex THEN	  SELECT syms.tb[node].name FROM	    list, block, null => NULL; -- info is not a valid file index	    ENDCASE => 	      {CPtr.fileindex ¬ MPtr.textIndex ¬ fIndex; P5U.OutSource[fIndex]};	IF ~CPtr.xtracting AND Stack.Depth[] # 0 THEN	  {SIGNAL CPtr.StackNotEmptyAtStatement; Stack.Clear[]};	SELECT syms.tb[node].name FROM	  list => t ¬ TreeOps.UpdateList[syms, t, StatementTree];	  block => Block[node];	  start => P5S.Start[node];	  restart => P5S.Restart[node];	  stop => P5S.Stop[node];	  dsk => DumpStack[node];	  lsk => LoadStack[node];	  xe => XferEnable[node];	  xf => XferFree[node];	  call, portcall => P5S.Call[node];	  signal, error => P5S.SigErr[node];	  syscall => SysCallStmt[node];	  syserror => P5.SysError[];	  label => P5S.Label[node];	  assign => P5S.Assign[node];	  extract => P5S.Extract[node];	  if => IfStmt[node];	  case => [] ¬ P5.CaseStmtExp[node, FALSE];	  bind => [] ¬ P5.BindStmtExp[node, FALSE];	  do => DoStmt[node];	  exit => P5S.Exit[];	  loop => P5S.Loop[];	  retry => P5S.Retry[];	  continue => P5S.Continue[];	  goto => P5S.GoTo[node];	  catchmark => P5S.CatchMark[node];	  return => P5S.Return[node];	  resume => P5S.Resume[node];	  reject => Reject[];	  result => P5S.Result[node];	  open => Open[node];	  enable => Enable[node];	  checked => syms.tb[node].son[1] ¬ StatementTree[syms, syms.tb[node].son[1]];	  procinit => P5S.ProcInit[node];	  wait => P5S.Wait[node];	  notify => Notify[node];	  broadcast => Broadcast[node];	  join => P5S.Join[node];	  unlock => P5S.Unlock[node];	  lock => P5S.Lock[node];          subst => P5S.Subst[node];	  free => P5S.Free[node];	  xerror => P5S.RetWithError[node];	  null => NULL;	  ENDCASE => GO TO unimplementedConstruct;	END;      ENDCASE;    P5.PurgeHeapList[saveHeapList];    P5.PurgePendTempList[];    EXITS      unimplementedConstruct => {Log.Error[unimplemented]; Stack.Clear[]};    END;    MPtr.textIndex ¬ saveIndex;    RETURN [TreeOps.FreeTree[syms, t]]    END;  SysCallStmt: PROC [node: Tree.Index] =    BEGIN    Stack.Mark[];    TreeOps.ScanList[syms, syms.tb[node].son[2], P5.PushRhs];    P5.SysCall[P5U.TreeLiteralValue[syms.tb[node].son[1]]];    END;  Open: PROC [node: Tree.Index] =    BEGIN    OPEN TreeOps;    OpenItem: PROC [h: SymbolTable.Handle, t: Tree.Link] RETURNS [Tree.Link] =      BEGIN      SetShared[syms, t, FALSE];      RETURN [FreeTree[syms, t]]      END;    syms.tb[node].son[2] ¬ StatementTree[syms, syms.tb[node].son[2]];    syms.tb[node].son[1] ¬ ReverseUpdateList[syms, syms.tb[node].son[1], OpenItem];    END;  DumpStack: PROC [node: Tree.Index] = INLINE    BEGIN -- generates dumpstate    DLState[node, qDSK, TRUE];    END;  LoadStack: PROC [node: Tree.Index] = INLINE    BEGIN -- generates loadstate and enable    DLState[node, qLSK, TRUE];    END;  XferEnable: PROC [node: Tree.Index] = INLINE    BEGIN -- generates loadstate and enable    DLState[node, qXE, FALSE];    END;  XferFree: PROC [node: Tree.Index] = INLINE    BEGIN -- generates loadstate and free    DLState[node, qXF, FALSE];    P5U.OutJump[JumpRet, LabelCCNull];    END;  DLState: PROC [node: Tree.Index, opc: BYTE, stateV: BOOLEAN] =    BEGIN -- does state move after checking for small currentcontext address    lowBound: CARDINAL = PrincOps.localbase+3;    var: VarComponent = P5L.MakeComponent[P5L.VarForLex[P5.Exp[syms.tb[node].son[1]]]];    WITH var SELECT FROM      frame => 	BEGIN	IF level # CPtr.curctxlvl THEN {Log.Error[stateVector]; RETURN};	IF stateV AND  wd NOT IN [lowBound..LAST[BYTE]] THEN 	  Log.Warning[stateVector];	P5U.Out1[opc, wd];	END;      ENDCASE => Log.Error[stateVector];    END;  Block: PROC [node: Tree.Index] =    BEGIN    bti: BTIndex = TreeOps.DecodeBti[syms.tb[node].info];    EnterBlock[bti, FALSE];    syms.tb[node].son[1] ¬ StatementTree[syms, syms.tb[node].son[1]];    syms.tb[node].son[2] ¬ StatementTree[syms, syms.tb[node].son[2]];    ExitBlock[bti];    END;  EnterBlock: PUBLIC PROC [bti: BTIndex, catch: BOOLEAN] =    BEGIN    IF CPtr.inlineFileIndex = NULLfileindex THEN      CPtr.fileindex ¬ MPtr.textIndex ¬ syms.bb[bti].sourceIndex    ELSE syms.bb[bti].sourceIndex ¬ CPtr.inlineFileIndex;    IF ~catch THEN P5U.OutSource[syms.bb[bti].sourceIndex];    P5U.CCellAlloc[other];    cb[LOOPHOLE[CPtr.codeptr, OtherCCIndex]].obody ¬ markbody[start: TRUE, index: bti];    END;  ExitBlock: PUBLIC PROC [bti: BTIndex] =    BEGIN    P5U.CCellAlloc[other];    cb[LOOPHOLE[CPtr.codeptr, OtherCCIndex]].obody ¬ markbody[start: FALSE, index: bti];    END;  IfStmt: PROC [node: Tree.Index] =    BEGIN -- generates code for an IF statement    eLabel: LabelCCIndex = P5U.LabelAlloc[];    P5.FlowTree[syms.tb[node].son[1], FALSE, eLabel	! P5.LogHeapFree => RESUME [FALSE, NullLex]];    P5.PurgePendTempList[];    syms.tb[node].son[2] ¬ StatementTree[syms, syms.tb[node].son[2]];    IF syms.tb[node].son[3] # Tree.Null THEN      BEGIN      iLabel: LabelCCIndex = P5U.LabelAlloc[];      P5U.OutJump[Jump, iLabel];      P5U.InsertLabel[eLabel];      syms.tb[node].son[3] ¬ StatementTree[syms, syms.tb[node].son[3]];      P5U.InsertLabel[iLabel];      END    ELSE P5U.InsertLabel[eLabel];    END;  DoStmt: PROC [rootNode: Tree.Index] =    BEGIN --  generates code for all the loop statments    stepLoop, tempIndex, tempEnd, upLoop, forSeqLoop, bigForSeq: BOOLEAN ¬ FALSE;    signed, long: BOOLEAN ¬ FALSE;    sSon, eSon: Tree.Link;    node, subNode: Tree.Index;    bti: BTIndex ¬ BTNull;    intType: Tree.NodeName;    indexLex: se Lexeme;    endLex: Lexeme;    topLabel: LabelCCIndex = P5U.LabelAlloc[];    startLabel: LabelCCIndex;    finLabel: LabelCCIndex = P5U.LabelAlloc[];    endLabel, loopLabel: LabelCCIndex;    labelMark: LabelInfoIndex = P5.GetLabelMark[];    UpdateCV: PROC [loadLong: BOOLEAN] =      BEGIN      IF long THEN        BEGIN	IF loadLong THEN P5.PushLex[indexLex];	P5U.PushLitVal[1]; P5U.PushLitVal[0];	P5U.Out0[IF upLoop THEN qDADD ELSE qDSUB];	P5.SAssign[indexLex.lexsei];	END      ELSE P5U.Out0[IF upLoop THEN qINC ELSE qDEC];      END;    -- set up for EXIT clause    [exit: endLabel, loop: loopLabel] ¬ P5.MakeExitLabel[];    TreeOps.ScanList[syms, syms.tb[rootNode].son[5], P5.LabelCreate];    -- handle initialization node    IF syms.tb[rootNode].son[1] = Tree.Null THEN P5U.InsertLabel[topLabel]    ELSE      BEGIN      node ¬ TreeOps.GetNode[syms, syms.tb[rootNode].son[1]];      bti ¬ TreeOps.DecodeBti[syms.tb[node].info];      IF bti # BTNull THEN EnterBlock[bti, FALSE];      SELECT syms.tb[node].name FROM	forseq =>	  BEGIN	  ENABLE P5.LogHeapFree => RESUME [FALSE, NullLex];	  t1: Tree.Link = syms.tb[node].son[1];	  t2: Tree.Link = syms.tb[node].son[2];	  indexLex ¬ [se[TreeOps.GetSe[syms, t1]]];	  forSeqLoop ¬ TRUE;	  bigForSeq ¬ P5U.WordsForOperand[t1] > 2;	  IF bigForSeq THEN {P5.TTAssign[t1, t2]; P5U.InsertLabel[topLabel]}	  ELSE {P5.PushRhs[syms, t2]; P5U.InsertLabel[topLabel]; P5.SAssign[indexLex.lexsei]};	  P5.PurgeHeapList[ISENull];	  END;	upthru, downthru =>	  BEGIN	  ENABLE P5.LogHeapFree => RESUME [FALSE, NullLex];	  cvBound: Tree.Link = syms.tb[node].son[3];	  nonempty: BOOLEAN = syms.tb[node].attr1;	  stepLoop ¬ TRUE;	  upLoop ¬ syms.tb[node].name = upthru;	  subNode ¬ TreeOps.GetNode[syms, syms.tb[node].son[2]];	  intType ¬ syms.tb[subNode].name;	  IF syms.tb[subNode].attr1 THEN SIGNAL CPtr.CodeNotImplemented;	  long ¬ syms.tb[subNode].attr2;  signed ¬ syms.tb[subNode].attr3;	  WITH syms.tb[node].son[1] SELECT FROM	    subtree => -- son1 is empty	      {indexLex ¬ P5.GenAnonLex[IF long THEN 2 ELSE 1]; tempIndex ¬ TRUE};	    symbol => indexLex ¬ Lexeme[se[index]];	    ENDCASE;	  IF upLoop THEN {sSon ¬ syms.tb[subNode].son[1]; eSon ¬ syms.tb[subNode].son[2]}	  ELSE	    BEGIN	    SELECT intType FROM	      intCO => intType ¬ intOC;	      intOC => intType ¬ intCO;	      ENDCASE;	    sSon ¬ syms.tb[subNode].son[2];  eSon ¬ syms.tb[subNode].son[1];	    END;	  WITH e: eSon SELECT FROM	    literal =>	      WITH e.info SELECT FROM		word => endLex ¬ Lexeme[literal[word[index]]];		ENDCASE => P5.P5Error[769];	    symbol =>	      IF syms.seb[e.index].immutable THEN endLex ¬ Lexeme[se[e.index]]	      ELSE		BEGIN		endLex ¬ P5.GenAnonLex[IF long THEN 2 ELSE 1];		P5.PushRhs[syms, e];  tempEnd ¬ TRUE;		WITH endLex SELECT FROM se => P5.SAssign[lexsei]; ENDCASE;		END;	    ENDCASE =>	      BEGIN	      endLex ¬ P5.GenAnonLex[IF long THEN 2 ELSE 1];	      P5.PushRhs[syms, e];  tempEnd ¬ TRUE;	      WITH endLex SELECT FROM se => P5.SAssign[lexsei]; ENDCASE;	      END;	  startLabel ¬ P5U.LabelAlloc[];	  P5.PushRhs[syms, sSon];	  IF long THEN P5.SAssign[indexLex.lexsei];	  IF (intType = intCC OR intType = intOO) AND ~nonempty THEN	    BEGIN -- earlier passes check for empty intervals	    TopTest: ARRAY BOOLEAN OF	     ARRAY BOOLEAN OF ARRAY BOOLEAN OF JumpType = [	      [[UJumpL,UJumpLE],	-- unsigned, down, closed/open	       [UJumpG,UJumpGE]],	-- unsigned, up, closed/open	      [[JumpL,JumpLE],		-- signed, down, closed/open	       [JumpG,JumpGE]]];		-- signed, up, closed/open	    IF long THEN {P5U.Out0[qREC]; P5U.Out0[qREC]};	    P5.PushLex[endLex];	    IF long THEN	      {P5U.Out0[IF signed THEN qDCMP ELSE qUDCMP]; P5U.PushLitVal[0]};	    P5U.OutJump[TopTest[long OR signed][upLoop][intType = intOO], finLabel];	    IF ~long THEN P5U.Out0[qREC];	    END;	  IF ~long THEN Stack.Decr[1];	  P5U.OutJump[Jump, startLabel];	  P5U.InsertLabel[topLabel];	  IF ~long THEN P5U.Out0[qREC];	  SELECT intType FROM	    intCC => {UpdateCV[TRUE]; P5U.InsertLabel[startLabel]};	    intOC => UpdateCV[TRUE];	    intCO, intOO => NULL;	    ENDCASE;	  IF ~long THEN	    BEGIN	    IF cvBound # Tree.Null	      THEN {P5.PushRhs[syms, cvBound]; P5U.Out0[FOpCodes.qBNDCK]};	    P5.SAssign[indexLex.lexsei];	    END;	  END;	ENDCASE;      END;    -- now the pre-body test    IF syms.tb[rootNode].son[2] # Tree.Null THEN      P5.FlowTree[syms.tb[rootNode].son[2], FALSE, finLabel	  ! P5.LogHeapFree => RESUME [FALSE, NullLex]];    -- ignore the opens (syms.tb[rootNode].son3)    -- now the body    syms.tb[rootNode].son[4] ¬ StatementTree[syms, syms.tb[rootNode].son[4]];    -- now (update and) test the control variable    P5U.InsertLabel[loopLabel];    IF stepLoop THEN      BEGIN      IF long AND (intType = intOC OR intType = intOO) THEN P5U.InsertLabel[startLabel];      P5.PushLex[indexLex];      SELECT intType FROM	intCC => NULL;	intCO => {UpdateCV[FALSE]; P5U.InsertLabel[startLabel]};	intOC => IF ~long THEN P5U.InsertLabel[startLabel];	intOO => {IF ~long THEN P5U.InsertLabel[startLabel]; UpdateCV[FALSE]};	ENDCASE;      IF long THEN SELECT intType FROM	intCO, intOO => {P5U.Out0[qREC]; P5U.Out0[qREC]};	ENDCASE;      P5.PushLex[endLex];      IF long THEN	{P5U.Out0[IF signed THEN qDCMP ELSE qUDCMP]; P5U.PushLitVal[0]};      P5U.OutJump[	    IF ~long AND ~signed THEN 	      IF upLoop THEN UJumpL ELSE UJumpG	    ELSE IF upLoop THEN JumpL ELSE JumpG, topLabel];      P5U.OutJump[Jump, finLabel];      IF tempEnd THEN P5.ReleaseTempLex[LOOPHOLE[endLex, se Lexeme]];      IF tempIndex THEN P5.ReleaseTempLex[indexLex];      END    ELSE      BEGIN      IF forSeqLoop THEN	BEGIN	ENABLE P5.LogHeapFree => RESUME [FALSE, NullLex];	IF bigForSeq THEN P5.TTAssign[[symbol[indexLex.lexsei]], syms.tb[node].son[3]]	ELSE P5.PushRhs[syms, syms.tb[node].son[3]];	P5.PurgeHeapList[ISENull];	END;      P5U.OutJump[Jump, topLabel];      END;    Stack.Reset[];    P5.PurgePendTempList[];    -- now the labelled EXITs    P5.LabelList[syms.tb[rootNode].son[5], endLabel, labelMark];    -- finally the FINISHED clause    P5U.InsertLabel[finLabel];    syms.tb[rootNode].son[6] ¬ StatementTree[syms, syms.tb[rootNode].son[6]];    IF bti # BTNull THEN ExitBlock[bti];    P5U.InsertLabel[endLabel];    END;  CatchPhrase: PUBLIC PROC [node: Tree.Index] =    BEGIN -- process a catchphrase at procedure call    bti: CCBTIndex = LOOPHOLE[syms.tb[node].info];        CPtr.catchcount ¬ CPtr.catchcount + 1;    P5U.Out1[qCATCH, syms.bb[bti].index];    SCatchPhrase[node];    CPtr.catchcount ¬ CPtr.catchcount - 1;    END;  Enable: PROC [node: Tree.Index] =    BEGIN -- generate code for an ENABLE    saveActEnable: CCBTIndex = CPtr.actenable;    n1: Tree.Index = TreeOps.GetNode[syms, syms.tb[node].son[1]];    bti: CCBTIndex = LOOPHOLE[syms.tb[n1].info];    ei: EnableIndex = P5U.NewEnableItem[bti];        CPtr.catchcount ¬ CPtr.catchcount + 1;    SCatchPhrase[n1];    CPtr.actenable ¬ bti;    CPtr.enableLevel ¬ CPtr.enableLevel + 1;    CPtr.catchcount ¬ CPtr.catchcount - 1;    P5U.OutEnableMark[index: ei, start: TRUE];    syms.tb[node].son[2] ¬ StatementTree[syms, syms.tb[node].son[2]];    P5U.OutEnableMark[index: ei, start: FALSE];    CPtr.enableLevel ¬ CPtr.enableLevel - 1;    CPtr.actenable ¬ saveActEnable;    END;  SCatchPhrase: PUBLIC PROC [node: Tree.Index] =    BEGIN -- main subr for catchphrases and ENABLEs    first, cur: CCIndex;    saveCaseCVState: CaseCVState = CPtr.caseCVState;    saveMwCV: Lexeme = CPtr.mwCaseCV;    saveEndLabel: LabelCCIndex = catchEndLabel;    oldStkPtr: StackIndex = Stack.New[];    saveActEnable: CCBTIndex = CPtr.actenable;    saveEnableLevel: CARDINAL = CPtr.enableLevel;    tempState: TempStateRecord;    bti: CCBTIndex = LOOPHOLE[syms.tb[node].info];    initialFrameSize, cfsi: NAT;    CatchScan: PROC [h: SymbolTable.Handle, t: Tree.Link] =      BEGIN      fail: LabelCCIndex = P5U.LabelAlloc[];      [] ¬ CatchItem[node:TreeOps.GetNode[syms, t], failLabel: fail];      P5U.OutJump[Jump, catchEndLabel];      P5U.InsertLabel[fail];      END;    WITH syms.bb[bti].info SELECT FROM      Internal => initialFrameSize ¬ frameSize;      ENDCASE => ERROR;          catchEndLabel ¬ P5U.LabelAlloc[];    CPtr.curctxlvl ¬ CPtr.curctxlvl + 1;    P5.PushTempState[@tempState, initialFrameSize];        CPtr.mwCaseCV ¬ [bdo[P5L.OVarItem[[      wSize: 2, space: frame[wd: 1, level: CPtr.curctxlvl, immutable: TRUE]]]]];    CPtr.caseCVState ¬ multi;    CPtr.actenable ¬ Symbols.CCBTNull;    [first: first, cur: cur] ¬ P5U.BeginCatch[];    EnterBlock[bti, TRUE];    TreeOps.ScanList[syms, syms.tb[node].son[1], CatchScan];    IF syms.tb[node].son[2] # Tree.Null THEN       syms.tb[node].son[2] ¬ StatementTree[syms, syms.tb[node].son[2]];    CPtr.actenable ¬ saveActEnable;    CPtr.enableLevel ¬ saveEnableLevel;    P5U.InsertLabel[catchEndLabel];    Stack.Off[];    IF CPtr.actenable # BTNull THEN      BEGIN      P5U.PushLitVal[syms.bb[CPtr.actenable].index];      P5U.PushLitVal[CatchFormat.CatchAction.enable.ORD];      P5U.Out0[qRET];  P5U.OutJump[JumpRet,LabelCCNull];      END    ELSE      BEGIN      P5U.PushLitVal[CatchFormat.CatchAction.reject.ORD];      P5U.Out0[qRET];  P5U.OutJump[JumpRet,LabelCCNull];      END;    Stack.On[];    ExitBlock[bti];    CPtr.curctxlvl ¬ CPtr.curctxlvl-1;    CPtr.caseCVState ¬ saveCaseCVState;    CPtr.mwCaseCV ¬ saveMwCV;    catchEndLabel ¬ saveEndLabel;    cfsi ¬ P5U.ComputeFrameSize[CPtr.framesz];    P5.PopTempState[@tempState];    IF syms.bb[MPtr.bodyIndex].resident THEN       cfsi ¬ cfsi + PrincOps.AVHeapSize;    IF cfsi > CatchFormat.defaultFsi THEN {      CPtr.codeptr ¬ cb[CPtr.codeStart].flink; -- the starsyms.tbody node      P5U.Out1[FOpCodes.qCATCHFSI, cfsi]};    P5U.EndCatch[oldfirst: first, oldcur: cur];    Stack.Restore[oldStkPtr];    END;  CatchItem: PROC [node: Tree.Index, failLabel: LabelCCIndex] =    BEGIN -- generate code for a CATCH item    saveCatchOutRecord: RecordSEIndex = CPtr.catchoutrecord;    inRecord: RecordSEIndex;    tSei: CSEIndex = TreeOps.DecodeCSei[syms.tb[node].info];    saveInCtxLevel, saveOutCtxLevel: Symbols.ContextLevel;    inCtx, outCtx: Symbols.CTXIndex ¬ Symbols.CTXNull;    P5.CaseTest[syms.tb[node].son[1], failLabel];    IF tSei = CSENull THEN inRecord ¬ CPtr.catchoutrecord ¬ RecordSENull    ELSE      BEGIN      [inRecord, CPtr.catchoutrecord] ¬ SymbolOps.TransferTypes[syms, tSei];      IF inRecord # RecordSENull THEN	    BEGIN	    inCtx ¬ syms.seb[inRecord].fieldCtx;	    saveInCtxLevel ¬ syms.ctxb[inCtx].level;	    syms.ctxb[inCtx].level ¬ CPtr.curctxlvl;	    END;      IF CPtr.catchoutrecord # RecordSENull THEN	    BEGIN	    outCtx ¬ syms.seb[CPtr.catchoutrecord].fieldCtx;	    saveOutCtxLevel ¬ syms.ctxb[outCtx].level;	    syms.ctxb[outCtx].level ¬ CPtr.curctxlvl;	    END;      P5.PopInVals[inRecord, TRUE];      END;    syms.tb[node].son[2] ¬ StatementTree[syms, syms.tb[node].son[2]];    IF inCtx # Symbols.CTXNull THEN syms.ctxb[inCtx].level ¬ saveInCtxLevel;    IF outCtx # Symbols.CTXNull THEN syms.ctxb[outCtx].level ¬ saveOutCtxLevel;    CPtr.catchoutrecord ¬ saveCatchOutRecord;    END;  Reject: PROC = INLINE    BEGIN    P5U.OutJump[Jump,catchEndLabel];    END;  Notify: PROC [node: Tree.Index] =    BEGIN    r: VarIndex = P5L.VarForLex[P5.Exp[syms.tb[node].son[1]]];    IF ~P5L.LoadAddress[r].long THEN P5U.Out0[qLP];    P5U.Out0[qNC];    END;  Broadcast: PROC [node: Tree.Index] =    BEGIN    r: VarIndex = P5L.VarForLex[P5.Exp[syms.tb[node].son[1]]];    IF ~P5L.LoadAddress[r].long THEN P5U.Out0[qLP];    P5U.Out0[qBC];    END;  END.
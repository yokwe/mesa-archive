-- Copyright (C) 1980, 1981, 1982, 1983, 1984, 1986  by Xerox Corporation. All rights reserved. -- Interface.mesa - last modified by-- Russ Atkinson,	21-Nov-80 11:07:35-- Johnsson,		December 2, 1980  8:55 AM-- Sweet,		 8-Nov-83 13:57:19-- Loretta,		 4-Jun-81 14:13:44-- JGS,			28-Aug-81  8:46:57-- Lewis,		 9-Oct-81 13:43:41-- Bruce,		16-Nov-81 17:42:28-- Karlton,		15-Sep-82  9:11:26-- Daniels,		25-Apr-84 18:08:25-- MEW			25-Aug-86 10:08:50-- This module provides an externally callable interface for the compiler or formatter.DIRECTORY  CLog USING [Error],  ComData USING [CheckAborted],  CommandUtil USING [    CommandPtr, CopyString, Create, Destroy, Echo, Failed, FreePairList,    FreeString, GetNth, ListLength, PairList, Parse, SetExtension],  CompilerOps USING [    CompileAction, Punt, Sequencer, StreamId, TableHandle, TableId, Transaction],  CompilerUtil USING [FreeAllocTables],  DebugTab USING [],  ErrorTab USING [],  Exec USING [    AddCommand, CheckForAbort--, FeedbackProc--, GetChar, Handle, Outcome,     OutputProc],  Format USING [CR, Line, StringProc],  Heap USING [Create],  HeraldWindow USING [FreeCursorSlot, GetCursorSlot, Slot, StoreCursor],  Inline USING [DIVMOD, LongDivMod],  MesaTab USING [],  MFile USING [    Acquire, AcquireTemp, CopyFileHandle, Delete, Error, GetLength, GetTimes,    Handle, maxNameLength, Release, SetAccess, SetReadProtect, SwapNames, Type],  MStream USING [Copy, Create, Error, GetFile, Handle, ReadOnly, SetLength, WriteOnly],  Runtime USING [GetBcdTime, GetTableBase, IsBound],  SpecialExec USING [compilerSwitches],  Stream USING [Delete, Handle, PutBlock],  String USING [AppendChar, AppendDecimal, AppendString, EquivalentString],  Style USING [PressFinish],  Time USING [Append, AppendCurrent, Current, Packed, Unpack],  TimeStamp USING [Null],  UserTerminal USING [CursorArray],  Version USING [Append],  Volume USING [InsufficientSpace];  Interface: MONITOR []  IMPORTS    ComData, CompilerUtil, CLog, DebugTab, ErrorTab, Format, CommandUtil, CompilerOps,     Exec, Heap, HeraldWindow, Inline, MesaTab, MFile, MStream, Runtime,     SpecialExec, Stream, String, Style, Time, Version, Volume  EXPORTS CompilerOps, Style =  BEGIN  Char: TYPE = CHARACTER;  StreamHandle: TYPE = Stream.Handle;  cmdPtr: CommandUtil.CommandPtr ¬ NIL;  feedback: Format.StringProc;    -- special output stream control  SetTypescript: PROC = {IF log = NIL THEN log ¬ NewOutputStream[logName, text]};  NewLine: PROC = {Format.CR[logProc]};  NewOutputStream: PROC [s: LONG STRING, type: MFile.Type]     RETURNS [st: StreamHandle] = {    ENABLE MStream.Error => {      logProc["Can't open output file: "L];      logProc[s]; NewLine[]; errors ¬ TRUE;      ERROR ABORTED};    st ¬ MStream.WriteOnly[s, [], type];    MStream.SetLength[st, 0]};  NewInputStream: PROC [s: LONG STRING] RETURNS [StreamHandle] = {    ENABLE MStream.Error => {      logProc["Can't open input file: "L];      logProc[s]; NewLine[]; errors ¬ TRUE;      ERROR ABORTED};    RETURN[MStream.ReadOnly[s, []]]};  DeleteFile: PROC [name: LONG STRING] = {    file: MFile.Handle ¬ NIL;    IF name = NIL THEN RETURN;    file ¬ MFile.Acquire[name, delete, [] ! MFile.Error => CONTINUE];    IF file # NIL THEN MFile.Delete[file]};  WriteHerald: PROC [proc: Format.StringProc, id: LONG STRING] = {    OPEN Time, Format;    herald: STRING ¬ [60];    String.AppendString[      herald,      IF formatting THEN "Mesa Formatter "L ELSE "Mesa Compiler "L];    Version.Append[herald];    String.AppendString[herald, " of "L];    Time.Append[herald, Time.Unpack[Runtime.GetBcdTime[]]];    Line[proc, herald];    IF id = NIL THEN Line[feedback, herald];    IF id # NIL THEN {proc[id]; proc[" -- "L]};    herald.length ¬ 0;    Time.AppendCurrent[herald];    Line[proc, herald]};  AppendHMS: PROC [s: STRING, time: LONG CARDINAL] = {    OPEN Inline;    hr, min, sec: CARDINAL;    z: BOOLEAN ¬ FALSE;    W: PROC [t: CARDINAL, last: BOOLEAN ¬ FALSE] = {      IF t # 0 OR z THEN {        IF z AND t < 10 THEN String.AppendChar[s, '0];        String.AppendDecimal[s, t];        IF ~last THEN String.AppendChar[s, ':];        z ¬ TRUE}};    [min, sec] ¬ LongDivMod[time, 60];    [hr, min] ¬ DIVMOD[min, 60];    W[hr];    W[min];    W[sec, TRUE]};  ObjectInit: PROC = {    IF objectStream = NIL THEN {      objectStream ¬ NewOutputStream[objectName, binary];      MFile.SetReadProtect[MStream.GetFile[objectStream], TRUE]}};  ErrorInit: PROC = {    IF errorStream = NIL THEN      IF parms.switches['e] THEN {errorStream ¬ log}      ELSE {        errorName ¬ MakeErrorName[rootName];        errorStream ¬ NewOutputStream[errorName, text];        WriteHerald[ErrorStringProc, errorName];        Format.CR[ErrorStringProc]}};  ErrorStringProc: Format.StringProc = {    Stream.PutBlock[errorStream, [LOOPHOLE[@s.text], 0, s.length]]};    MakeErrorName: PROC [root: LONG STRING] RETURNS [LONG STRING] = {    RETURN[      CommandUtil.SetExtension[        CommandUtil.CopyString[root, 2 + ("errlog"L).length], "errlog"L]]};  GetStream: PROC [id: CompilerOps.StreamId] RETURNS [s: Stream.Handle] = {    SELECT id FROM      source => s ¬ sourceStream;      object => {IF objectStream = NIL THEN ObjectInit[]; s ¬ objectStream};      log => {IF errorStream = NIL THEN ErrorInit[]; s ¬ errorStream};      ENDCASE => ERROR};        -- compiler sequencing  Initialize: PROC = {    sourceFile: MFile.Handle;    sourceStream ¬ NewInputStream[sourceName];    sourceFile ¬ MStream.GetFile[sourceStream];    IF formatting AND MFile.GetLength[sourceFile] > LAST[CARDINAL] THEN       GO TO tooLong;    parms.sourceVersion ¬ TimeStamp.Null;    parms.sourceVersion.time ¬ LOOPHOLE[MFile.GetTimes[sourceFile].create];    IF formatterOverwrite THEN {      tempFile: MFile.Handle;      formatterSourceFile ¬ MFile.CopyFileHandle[sourceFile, [], rename !        MFile.Error => GO TO cantRename];      tempFile ¬ MFile.AcquireTemp[        type: text, initialLength: MFile.GetLength[sourceFile]];      objectStream ¬ MStream.Create[tempFile, []]}    ELSE IF formatterNewText THEN {      objectStream ¬ NewOutputStream[objectName, text !        UNWIND => {sourceStream.delete[sourceStream]; sourceStream ¬ NIL}];      MFile.SetReadProtect[MStream.GetFile[objectStream], TRUE]};    EXITS      cantRename => {       	  logProc["Can't replace file: "L]; logProc[sourceName]; NewLine[];	  sourceStream.delete[sourceStream]; sourceStream ¬ NIL;	  ERROR ABORTED};      tooLong => {	  logProc[sourceName]; logProc[" too long to be formatted."L]; NewLine[];	  sourceStream.delete[sourceStream]; sourceStream ¬ NIL;	  ERROR ABORTED};       };  Finalize: PROC = {    started: BOOLEAN = objectStream # NIL;    objectFile: MFile.Handle ¬      IF started THEN MStream.GetFile[objectStream] ELSE NIL;    tempFile: MFile.Handle;    IF parms.nErrors # 0 THEN {      IF ~started AND ~formatting THEN {        objectFile ¬ MFile.Acquire[	    name: objectName, access: anchor, release: [], mightWrite: TRUE !	  MFile.Error => CONTINUE];        IF objectFile # NIL THEN {	  MFile.SetReadProtect[objectFile, TRUE];	  MFile.Release[objectFile]}}}    ELSE {      IF objectFile # NIL THEN MFile.SetReadProtect[objectFile, FALSE];      IF formatterOverwrite THEN        tempFile ¬ MFile.CopyFileHandle[objectFile, [], rename]};    IF objectStream # NIL THEN objectStream.delete[objectStream];    IF sourceStream # NIL THEN sourceStream.delete[sourceStream];    IF formatterOverwrite THEN {      IF parms.nErrors = 0 THEN {        MFile.SwapNames[formatterSourceFile, tempFile ! 	  MFile.Error => GO TO acrossVolumes];        MFile.Release[tempFile]};      MFile.Release[formatterSourceFile];      EXITS        acrossVolumes => {	  in, out: Stream.Handle;	  MFile.SetAccess[formatterSourceFile, writeOnly !	    MFile.Error => {	      logProc["Can't replace file: "L]; logProc[sourceName]; NewLine[];	      MFile.Release[tempFile]; MFile.Release[formatterSourceFile];	      ERROR ABORTED}];	  MFile.SetAccess[tempFile, readOnly];	  in ¬ MStream.Create[tempFile, []];	  out ¬ MStream.Create[formatterSourceFile, []];	  [] ¬ MStream.Copy[from: in, to: out, bytes: LAST[LONG CARDINAL]];	  in.Delete[]; out.Delete[]};      };    IF errorStream # NIL AND errorStream # log THEN      errorStream.delete[errorStream];    objectStream ¬ sourceStream ¬ errorStream ¬ NIL;    IF errorName = NIL THEN {      errorName ¬ MakeErrorName[rootName]; DeleteFile[errorName]}};  WriteClosing: PROC [startTime: Time.Packed] = {    OPEN Format;    outcome: Exec.Outcome;    stats: STRING ¬ [90];  -- put time or bytes of code or nerrors    logProc[sourceName];    IF parms.nErrors # 0 THEN {      logProc[" aborted"L];      errors ¬ TRUE;      String.AppendDecimal[stats, parms.nErrors];      String.AppendString[stats, " err"L]}    ELSE {      String.AppendString[stats, "lines: "L];      String.AppendDecimal[stats, parms.sourceLines];      IF ~formatting AND parms.objectBytes # 0 THEN {        String.AppendString[stats, ", code: "L];        String.AppendDecimal[stats, parms.objectBytes];        String.AppendString[stats, ", links: "L];        String.AppendDecimal[stats, parms.linkCount];        String.AppendString[stats, ", frame: "L];        String.AppendDecimal[stats, parms.objectFrameSize]}};    IF parms.nWarnings # 0 THEN {      IF parms.switches['w] THEN warnings ¬ TRUE;      String.AppendChar[stats, ',];      String.AppendDecimal[stats, parms.nWarnings];      String.AppendString[stats, " warn"L]};    String.AppendString[stats, ", time: "L];    AppendHMS[stats, Time.Current[] - startTime];    NewLine[]; logProc[stats];    IF (parms.nWarnings # 0 OR parms.nErrors # 0) AND ~parms.switches['e] THEN {      NewLine[];      logProc["see "L];      logProc[rootName];      logProc[".errlog"L]};    outcome ¬      SELECT TRUE FROM        electiveAbort => abort,        parms.nErrors # 0 => error,        parms.nWarnings # 0 => warning,        ENDCASE => normal;    Format.Line[feedback, stats]};  StopCompiler: PROC [startTime: Time.Packed] = {    trailer: STRING ¬ [50];    String.AppendString[trailer, "Elapsed time: "L];    AppendHMS[trailer, Time.Current[] - startTime];    Format.Line[feedback, trailer];    IF moduleCount > 1 THEN {      NewLine[]; logProc[trailer]; NewLine[]};    IF log # NIL THEN {log.delete[log]; log ¬ NIL}};  transaction: CompilerOps.Transaction;  parms: LONG POINTER TO CompilerOps.Transaction = @transaction;  electiveAbort: BOOLEAN;  PermanentSwitchDefaults, SwitchDefaults: PACKED ARRAY CHARACTER ['a..'z] OF    BOOLEAN ¬ [    FALSE,  -- A  Formatter: convert arrows    FALSE,  -- B  Bounds checking    FALSE,  -- C  Unused    FALSE,  -- D  Call debugger on compiler error (FALSE => just log error)    FALSE,  -- E  If TRUE, errlog goes to Compiler.log    TRUE,   -- F  Floating point    FALSE,  -- G  Formatter: Don't close press file at end of input file    FALSE,  -- H  Formatter: Generate a press file    TRUE ,  -- I  Formatter: Interpress    TRUE,   -- J  cross-Jumping optimization    FALSE,  -- K  Formatter: 2 column landscape press file    FALSE,  -- L  Report Lousy code    TRUE,   -- M  Unused    FALSE,  -- N  Nil pointer checking    FALSE,  -- O  Old version: global frames in the MDS    FALSE,  -- P  Pause after compilation with errors    FALSE,  -- Q  Unused    FALSE,  -- R  Unused    TRUE,   -- S  Sort (by static frequency) global vars & entry indexes    TRUE,   -- T  Formatter: Overwrite input file with plain text formatted version    FALSE,  -- U  Uninitialized variable checking    FALSE,  -- V  Formatter: overwrite input file with bravo looks, fonts 6 and 7    TRUE,   -- W  report Warning messages    FALSE,  -- X  Unused    FALSE,  -- Y  Yell about KFCB    FALSE]; -- Z  Formatter: overwrite input file with bravo looks, fonts 0 and 1  logProc: Format.StringProc = {    IF s = NIL THEN RETURN;    IF log = NIL THEN {      Complain: Format.StringProc = Exec.OutputProc[eh];      Complain[s]}    ELSE Stream.PutBlock[log, [LOOPHOLE[@s.text], 0, s.length]]};    formatting: BOOLEAN = Runtime.IsBound[LOOPHOLE[Style.PressFinish]];  headerComment: PUBLIC LONG STRING ¬ NIL;  formatterOverwrite, formatterNewText: BOOLEAN;  formatterSourceFile: MFile.Handle;  sourceName, objectName, errorName: LONG STRING ¬ NIL;  sourceStream, objectStream, errorStream: StreamHandle ¬ NIL;  log: StreamHandle ¬ NIL;    logName: LONG STRING = IF formatting THEN "Formatter.log" ELSE "Compiler.Log";  rootName: LONG STRING ¬ [MFile.maxNameLength];  errors, warnings: BOOLEAN;  moduleCount: CARDINAL;  tableSegment: ARRAY CompilerOps .TableId[parse..debug] OF    CompilerOps.TableHandle;  needTableSetup: BOOLEAN ¬ TRUE;  compilerZone: UNCOUNTED ZONE ¬ NIL;  SetRoot: PROC [root, s: LONG STRING] = {    root.length ¬ 0;    FOR i: CARDINAL IN [0..s.length) DO      IF s[i] = '. THEN EXIT;       String.AppendChar[root, s[i]];       ENDLOOP};  nowCompiling: BOOLEAN ¬ FALSE;  DoneCompiling: ENTRY PROC = {nowCompiling ¬ FALSE};  AlreadyCompiling: ENTRY PROC RETURNS [BOOLEAN] = {    IF nowCompiling THEN RETURN[TRUE];    nowCompiling ¬ TRUE;    RETURN[FALSE]};  eh: Exec.Handle ¬ NIL;  -- * * * * * *  M A I N   B O D Y   C O D E  * * * * * *    Compile: PUBLIC PROC [h: Exec.Handle, clientData: LONG POINTER]       RETURNS [o: Exec.Outcome] =    BEGIN    ENABLE UNWIND => {CommandUtil.Destroy[cmdPtr]; DoneCompiling[]};    get: PROC RETURNS [CHARACTER] = {RETURN[Exec.GetChar[h]]};        slot: HeraldWindow.Slot;        DoGlobalSwitches: PROC [switches: LONG STRING] = {      sense: BOOLEAN ¬ TRUE;      IF switches = NIL THEN RETURN;      FOR i: CARDINAL IN [0..switches.length) DO        c: CHARACTER = switches[i];        SELECT c FROM          '-, '~ => sense ¬ ~sense;        « 'o, 'O => headerComment ¬ CommandUtil.FreeString[headerComment]; »          IN ['a..'z] => {SwitchDefaults[c] ¬ sense; sense ¬ TRUE};          IN ['A..'Z] => {SwitchDefaults[c + ('a - 'A)] ¬ sense; sense ¬ TRUE};          ENDCASE => NULL;        ENDLOOP};	    dieFace: ARRAY [1..6] OF UserTerminal.CursorArray ¬ [      [7777B, 10033B, 20605B, 54011B, 177763B, 100023B, 100021B, 100021B,       100021B, 103021B, 103031B, 100031B, 100022B, 100024B, 100030B, 177760B],      [7777B, 10003B, 20605B, 40013B, 177763B, 100021B, 130021B, 130025B,       100025B, 100021B, 100021B, 100031B, 100332B, 100324B, 100030B, 177760B],      [7777B, 10003B, 20605B, 40013B, 177763B, 100031B, 100331B, 100325B,       100025B, 103023B, 103023B, 100031B, 130032B, 130024B, 100030B, 177760B],      [7777B, 10003B, 20605B, 40011B, 177761B, 100031B, 130331B, 130321B,       100021B, 100023B, 100023B, 100021B, 130322B, 130324B, 100030B, 177760B],      [7777B, 10003B, 20605B, 40013B, 177763B, 100031B, 130331B, 130321B,       100021B, 103023B, 103023B, 100031B, 130332B, 130324B, 100030B, 177760B],      [7777B, 13003B, 20005B, 40151B, 177761B, 100031B, 130331B, 130325B,       100025B, 130323B, 130323B, 100021B, 130322B, 130324B, 100030B, 177760B]];         CheckForAbort: PROCEDURE RETURNS [aborted: BOOLEAN] = {      RETURN[Exec.CheckForAbort[h]]};        StartPass: PROC [pass: CARDINAL] RETURNS [goOn: BOOLEAN ¬ TRUE] = {      electiveAbort ¬ Exec.CheckForAbort[h];      IF electiveAbort THEN RETURN[FALSE];      IF pass IN [1..6] AND slot # NIL THEN {        HeraldWindow.StoreCursor[slot, @dieFace[pass]]};      IF pass # 0 THEN feedback["."L];      RETURN[TRUE]};    compilerStartTime, moduleStartTime: Time.Packed;        BEGIN -- to set up cantGo label    eh ¬ h;    ComData.CheckAborted ¬ CheckForAbort;    feedback ¬ Exec.--FeedbackProc--OutputProc[eh];        IF AlreadyCompiling[] THEN {       Complain: Format.StringProc = Exec.OutputProc[h];      Complain["Compiler already running"L];      RETURN [abort]};          IF Runtime.IsBound[LOOPHOLE[HeraldWindow.GetCursorSlot]] THEN      slot ¬ HeraldWindow.GetCursorSlot[]    ELSE slot ¬ NIL;        SwitchDefaults ¬ PermanentSwitchDefaults;    DoGlobalSwitches[SpecialExec.compilerSwitches];    IF needTableSetup THEN {      tableSegment[parse] ¬ LOOPHOLE[Runtime.GetTableBase[LOOPHOLE[MesaTab]]];      tableSegment[error] ¬ LOOPHOLE[Runtime.GetTableBase[LOOPHOLE[ErrorTab]]];      tableSegment[debug] ¬ LOOPHOLE[Runtime.GetTableBase[LOOPHOLE[DebugTab]]];      compilerZone ¬ Heap.Create[initial: 4, increment: 4, swapUnitSize: 4];      START CompilerOps.Sequencer[        explicitSwapping: FALSE, 	scratchZone: compilerZone,	tableSegment: tableSegment];      needTableSetup ¬ FALSE};    compilerStartTime ¬ Time.Current[];    moduleCount ¬ 0;    electiveAbort ¬ FALSE;    cmdPtr ¬ CommandUtil.Create[get];    -- do the compilation    SetTypescript[ ! ABORTED => {      logProc[" can't open Compiler.log"L]; electiveAbort ¬ TRUE; GO TO cantGo}];    WriteHerald[logProc, NIL];    errors ¬ warnings ¬ formatterOverwrite ¬ formatterNewText ¬ FALSE;    DO      args, results: CommandUtil.PairList;      switches: LONG STRING ¬ NIL;      sense: BOOLEAN;      BEGIN OPEN Format;      parms.op ¬ IF formatting THEN format ELSE compile;      parms.system ¬ pilot;  -- indicate that we are compiling ON Pilot      parms.switches ¬ SwitchDefaults;      parms.debugPass ¬ LAST[CARDINAL];      parms.getStream ¬ GetStream;      parms.startPass ¬ StartPass;      parms.objectBytes ¬ 0;      parms.objectFrameSize ¬ 0;      parms.linkCount ¬ 0;      parms.nErrors ¬ 0;      parms.nWarnings ¬ 0;      parms.sourceLines ¬ 0;      [sourceName, args, results, switches] ¬ CommandUtil.Parse[        cmd: cmdPtr, opX: 2 + ("mesa"L).length, resultX: 2 + ("mesa"L).length !        CommandUtil.Failed => GO TO badSyntax];      IF sourceName = NIL AND switches = NIL THEN EXIT;      NewLine[];      logProc["Command: "L];      CommandUtil.Echo[logProc, sourceName, args, results, switches];      IF CommandUtil.ListLength[results] > 1 THEN GO TO badSemantics;      IF sourceName = NIL THEN GO TO globalSwitches;      SetRoot[        rootName,        IF CommandUtil.ListLength[results] = 1 THEN CommandUtil.GetNth[results, 0]        ELSE sourceName];      IF switches # NIL THEN {        sense ¬ TRUE;        FOR i: CARDINAL IN [0..switches.length) DO          c: CHARACTER = switches[i];          SELECT c FROM            '-, '~ => sense ¬ ~sense;          « 'o, 'O => {              [] ¬ CommandUtil.FreeString[headerComment]; GOTO headerLine}; 	      What is all this for??? »            IN ['a..'z] => {parms.switches[c] ¬ sense; sense ¬ TRUE};            IN ['A..'Z] => {parms.switches[c + ('a - 'A)] ¬ sense; sense ¬ TRUE};            IN ['1..'5] => {parms.debugPass ¬ c - '0; sense ¬ TRUE};            ENDCASE;          ENDLOOP;        switches ¬ CommandUtil.FreeString[switches]};      sourceName ¬ CommandUtil.SetExtension[sourceName, "mesa"L];      parms.sourceId ¬ sourceName;      parms.fileMap ¬ args;      IF CommandUtil.ListLength[results] # 0 THEN {        objectName ¬ CommandUtil.GetNth[list: results, n: 0, delete: TRUE];        results ¬ CommandUtil.FreePairList[results]}      ELSE objectName ¬ CommandUtil.CopyString[rootName, 2 + ("mesa"L).length];      objectName ¬ CommandUtil.SetExtension[        objectName, IF formatting THEN "mesa"L ELSE "bcd"L];      parms.objectId ¬ objectName;      formatterNewText ¬         formatting AND	 (parms.switches['t] OR parms.switches['v] OR parms.switches['z]);      formatterOverwrite ¬         formatterNewText AND String.EquivalentString[objectName, sourceName];      NewLine[];      moduleCount ¬ moduleCount + 1;        BEGIN        item: STRING ¬ [60];        first: BOOLEAN ¬ TRUE;        String.AppendString[item, rootName];        FOR c: CHARACTER IN ['a..'z] DO          sd: BOOLEAN = PermanentSwitchDefaults[c];          IF parms.switches[c] # sd THEN {            IF first THEN {first ¬ FALSE; String.AppendChar[item, '/]};            IF sd THEN String.AppendChar[item, '~];            String.AppendChar[item, c]};          ENDLOOP;        feedback[item];        END;      Initialize[ ! ABORTED, MFile.Error =>         {feedback["-- aborted, see log"L]; Format.CR[feedback]; GOTO noSource}];      moduleStartTime ¬ Time.Current[];      CompilerOps.CompileAction[parms !         MFile.Error, Volume.InsufficientSpace => GO TO noDiskRoom;        ABORTED, CompilerOps.Punt => {CLog.Error[aborted]; GO TO punt};        UNWIND => {	  IF parms.nErrors = 0 THEN parms.nErrors ¬ 1;	  Finalize[]; 	  IF slot # NIL THEN slot ¬ HeraldWindow.FreeCursorSlot[slot]}];      Finalize[];      WriteClosing[moduleStartTime];      EXITS        noDiskRoom => {	  Format.Line[feedback,"Disk is full"L];	  Format.Line[logProc, "Disk is full"L];	  IF parms.nErrors = 0 THEN parms.nErrors ¬ 1;	  GO TO punt};        globalSwitches => {          objectName ¬ NIL; 	  DoGlobalSwitches[switches]; 	  switches ¬ CommandUtil.FreeString[switches]};        noSource => {errors ¬ TRUE};      « headerLine => {          headerComment ¬ sourceName;          sourceName ¬ NIL;          objectName ¬ NIL;          results ¬ CommandUtil.FreePairList[results];          switches ¬ CommandUtil.FreeString[switches]}; »        badSemantics => {          objectName ¬ NIL;          errors ¬ TRUE;          logProc[" -- Illegal command"L]};      END;      sourceName ¬ CommandUtil.FreeString[sourceName];      IF ~formatting THEN objectName ¬ CommandUtil.FreeString[objectName];      errorName ¬ CommandUtil.FreeString[errorName];      args ¬ CommandUtil.FreePairList[args];      results ¬ CommandUtil.FreePairList[results];      NewLine[]; IF log # NIL THEN log.sendNow[log, TRUE];      IF electiveAbort OR        ((errors OR (warnings AND parms.switches['w])) AND parms.switches['p]) THEN        GO TO truncateList;      REPEAT        badSyntax => {          NewLine[]; logProc["-- Illegal syntax"L]; errors ¬ TRUE};        truncateList => NULL;        punt => {	  Finalize[]; WriteClosing[moduleStartTime]; NewLine[];	  electiveAbort ¬ TRUE};      ENDLOOP;          EXITS      cantGo => NULL;    END;    StopCompiler[compilerStartTime];    CommandUtil.Destroy[cmdPtr];    IF slot # NIL THEN slot ¬ HeraldWindow.FreeCursorSlot[slot];    IF freeTablesAfterCompile THEN CompilerUtil.FreeAllocTables[];    IF formatting THEN Style.PressFinish[];    ComData.CheckAborted ¬ NIL;    o ¬ SELECT TRUE FROM      electiveAbort => abort,       errors => error,       warnings => warning,      ENDCASE => normal;    DoneCompiling[];    RETURN    END;  -- of Compile      AddCmd: PROC = {    Exec.AddCommand[      IF formatting THEN "Formatter.~"L ELSE "Compiler.~"L, Compile]};      freeTablesAfterCompile: BOOLEAN ¬ TRUE;  START ComData;  AddCmd[];  END. 
-- Copyright (C) 1983, 1986  by Xerox Corporation. All rights reserved. -- file Pass3Xc.mesa-- last modified by Satterthwaite, October 22, 1982 8:49 am-- last modified by Sweet,  5-Aug-83 14:07:30-- Wagner	19-Aug-86 11:41:54DIRECTORY  ComData USING [idCARDINAL, typeATOM, typeBOOL, typeCHAR, typeINT, typeStringBody],  Copier USING [SEToken, NullSEToken, CtxFirst, CtxNext, CtxValue],  CLog USING [Error, ErrorN, ErrorNode, ErrorTree, WarningTree],  P3 USING [    AccessMode, Attr, fullAttr, LhsMode, NPUse, MergeNP, SetNP,    And, BodyForTree, Bundling, CanonicalType, ClearRefStack, Exp, Float, ForceType, Interval,     Lengthen, LongPath, MakeLongType, MakeRefType, OpLevel, OperandType, OrderedType,     rStack, rI, RAttr, RecordLhs, RPop, RPush, RType, SealRefStack, SequenceField,     SequenceNP, Shorten, TargetType, TypeExp, TypeForTree, Unbundle, UnsealRefStack, VoidExp],  P3S USING [currentBody, implicit, safety],  Symbols USING [    CBTIndex, CBTNull, codeANY, ContextLevel, CTXNull, SERecord, SEIndex,     ISEIndex, CSEIndex, CTXIndex, lG, lZ, RecordSEIndex, SENull, ISENull, typeANY],  SymbolOps USING [    FromInt, MakeNonCtxSe, NormalType, RCType, ReferentType, ToTreeIndex,     TypeForm, UnderType, XferMode],  SymbolTable USING [Handle],  Tree USING [Index, Link, Null, NullIndex],  TreeOps USING [    EncodeSei, FreeNode, GetNode, IdentityMap, ListLength, NthSon, OpName, PopTree,    PushSe, PushTree, PushNode, SetAttr, SetInfo, UpdateList],  Types USING [Assignable, Equivalent];Pass3Xc: PROGRAM    IMPORTS      Copier, Log: CLog, P3, P3S, SymbolOps, TreeOps, Types,       dataPtr: ComData    EXPORTS P3 = {  OPEN SymbolOps, Symbols, TreeOps, P3;    syms: SymbolTable.Handle ¬ NIL;    Pass3XcInit: PUBLIC PROC [h: SymbolTable.Handle] = { syms ¬ h }; -- parameter reference bookkeeping  phraseNP: PUBLIC NPUse; -- tree manipulation utilities  InterfaceVar: PROC [t: Tree.Link] RETURNS [BOOLEAN] = INLINE {    RETURN [WITH t SELECT FROM      symbol => syms.ctxb[syms.seb[index].idCtx].ctxType = imported,      ENDCASE => FALSE]};  WritableRef: PROC [t: Tree.Link] RETURNS [LhsMode] = {    phraseNP ¬ SetNP[phraseNP];    RETURN [AccessMode[CanonicalType[OperandType[t]]]]};  VarLhsMode: ARRAY LhsMode OF LhsMode = [    none: none, uncounted: counted, counted: counted];  OperandLhs: PUBLIC PROC [t: Tree.Link] RETURNS [LhsMode] = {    WITH t SELECT FROM      symbol => {	sei: ISEIndex = index;	ctx: CTXIndex = syms.seb[sei].idCtx;	level: ContextLevel;	IF ctx = CTXNull THEN level ¬ lZ	ELSE {	  syms.ctxb[ctx].varUpdated ¬ TRUE;	  IF (level ¬ syms.ctxb[ctx].level) < P3S.currentBody.level THEN	    phraseNP ¬ SetNP[phraseNP]};	RecordLhs[sei];	RETURN [SELECT TRUE FROM	   syms.seb[sei].immutable => none,	   (level = lG) => counted,	   ENDCASE => uncounted]};      subtree => {	node: Tree.Index = index;	RETURN [IF node = Tree.NullIndex THEN none ELSE	  SELECT syms.tb[node].name FROM	    dot =>	      WITH syms.tb[node].son[2] SELECT FROM		symbol =>		  SELECT TRUE FROM		    syms.seb[index].immutable => none,		    (syms.ctxb[syms.seb[index].idCtx].level = lG) =>		      VarLhsMode[WritableRef[syms.tb[node].son[1]]],		    ENDCASE => WritableRef[syms.tb[node].son[1]],		ENDCASE => none,	    uparrow =>	      IF InterfaceVar[syms.tb[node].son[1]]		THEN VarLhsMode[WritableRef[syms.tb[node].son[1]]]		ELSE WritableRef[syms.tb[node].son[1]],	    dindex => WritableRef[syms.tb[node].son[1]],	    reloc => WritableRef[syms.tb[node].son[2]],	    dollar =>	      WITH syms.tb[node].son[2] SELECT FROM		symbol =>		  IF ~syms.seb[index].immutable		    THEN OperandLhs[syms.tb[node].son[1]]		    ELSE none,		ENDCASE => none,	    index, seqindex, loophole, cast, openx, pad, chop =>	      OperandLhs[syms.tb[node].son[1]],	    base, length => 	      IF ~syms.tb[node].attr1 THEN none 	      ELSE OperandLhs[syms.tb[node].son[1]],	    cdot => OperandLhs[syms.tb[node].son[2]],	    apply => IF ListLength[syms, syms.tb[node].son[1]] = 1 THEN uncounted ELSE none,	    ENDCASE => none]};      ENDCASE => RETURN [none]};  OperandInline: PUBLIC PROC [t: Tree.Link] RETURNS [BOOLEAN] = {    bti: CBTIndex;    RETURN [SELECT XferMode[syms, OperandType[t]] FROM      proc => (bti¬BodyForTree[t]) # CBTNull AND syms.bb[bti].inline,      ENDCASE => FALSE]};  OperandLevel: PUBLIC PROC [t: Tree.Link] RETURNS [level: OpLevel] = {    SELECT OpName[syms, t] FROM      cdot, nil => level ¬ global;      ENDCASE => {	bti: CBTIndex = BodyForTree[t];	level ¬ SELECT TRUE FROM	  (bti = CBTNull) => unknown,	  (syms.bb[bti].level <= lG+1) => global,	  ENDCASE => local};    RETURN};  OperandInternal: PUBLIC PROC [t: Tree.Link] RETURNS [BOOLEAN] = {    WITH t SELECT FROM      symbol => {	bti: CBTIndex = BodyForTree[t];	RETURN [bti # CBTNull AND syms.bb[bti].internal]};      subtree =>	RETURN [SELECT OpName[syms, t] FROM	  dot, cdot, assignx => OperandInternal[NthSon[syms, t, 2]],	  ifx => OperandInternal[NthSon[syms, t, 2]] OR OperandInternal[NthSon[syms, t, 3]],	  ENDCASE => FALSE];	-- should check casex, bindx also      ENDCASE => RETURN [FALSE]}; -- ranges   Range: PUBLIC PROC [t: Tree.Link, type: CSEIndex] RETURNS [val: Tree.Link] = {    subType: CSEIndex;    SELECT OpName[syms, t] FROM      subrangeTC => {        val ¬ RewriteSubrange[GetNode[syms, t]];        Interval[val, IF type # typeANY THEN type ELSE dataPtr.typeINT, FALSE]};      IN [intOO .. intCC] => {        val ¬ t;        Interval[val, IF type # typeANY THEN type ELSE dataPtr.typeINT, FALSE]};      ENDCASE =>        IF TypeForm[syms, type] # long THEN {          val ¬ TypeExp[syms, t];          RPush[TargetType[UnderType[syms, TypeForTree[val]]], fullAttr];  phraseNP ¬ none}        ELSE {          val ¬ MakeEndPoints[t];          Interval[val, type, FALSE]};    subType ¬ RType[];    IF ~OrderedType[subType] AND subType # typeANY THEN Log.Error[nonOrderedType];    RETURN};      RewriteSubrange: PROC [node: Tree.Index] RETURNS [Tree.Link] = {    subNode: Tree.Index = GetNode[syms, syms.tb[node].son[2]];    PushTree[syms, syms.tb[subNode].son[1]];  PushTree[syms, IdentityMap[syms, syms.tb[node].son[1]]];    PushNode[syms, apply, -2];  syms.tb[subNode].son[1] ¬ PopTree[syms];    PushTree[syms, syms.tb[subNode].son[2]];  PushTree[syms, syms.tb[node].son[1]];    PushNode[syms, apply, -2];  syms.tb[subNode].son[2] ¬ PopTree[syms];    syms.tb[node].son[1] ¬ syms.tb[node].son[2] ¬ Tree.Null;  FreeNode[syms, node];    RETURN[[subtree[subNode]]]};  MakeEndPoints: PROC [t: Tree.Link] RETURNS [Tree.Link] = {     PushTree[syms, t];  PushNode[syms, first, 1];     PushTree[syms, IdentityMap[syms, t]];  PushNode[syms, last, 1];     PushNode[syms, intCC, 2];  RETURN [PopTree[syms]]}; -- operations on enumerated types  SEToken: TYPE = Copier.SEToken;  Span: PUBLIC PROC [type: CSEIndex] RETURNS [first, last: SEToken] = {    subType: CSEIndex = TargetType[type];    vCtx: CTXIndex = WITH syms.seb[subType] SELECT FROM			enumerated => valueCtx,			ENDCASE => ERROR;    WITH t: syms.seb[type] SELECT FROM      enumerated => {first ¬ CtxFirst[vCtx]; last ¬ CtxLast[vCtx]};      subrange => {	IF t.mark4 THEN {	  first ¬ Copier.CtxValue[syms, vCtx, FromInt[t.origin]];	  last ¬ Copier.CtxValue[syms, vCtx, FromInt[t.origin + t.range]]}	ELSE {	  node: Tree.Index = LOOPHOLE[t.range];	  subNode: Tree.Index = GetNode[syms, syms.tb[node].son[2]];	  first ¬ EnumeratedValue[syms.tb[subNode].son[1], vCtx];	  last ¬ EnumeratedValue[syms.tb[subNode].son[2], vCtx];	  SELECT syms.tb[subNode].name FROM	    intOO, intOC => first ¬ CtxSucc[vCtx, first];	    ENDCASE;	  SELECT syms.tb[subNode].name FROM	    intOO, intCO => last ¬ CtxPred[vCtx, last];	    ENDCASE}};      ENDCASE => first ¬ last ¬ Copier.NullSEToken;    RETURN};  EnumeratedValue: PROC [t: Tree.Link, vCtx: CTXIndex] RETURNS [SEToken] = {    WITH t SELECT FROM      symbol => {	sei: ISEIndex = index;	RETURN [SELECT TRUE FROM	  ~syms.seb[sei].constant => Copier.NullSEToken,	  (syms.seb[sei].idCtx = vCtx) OR syms.seb[sei].mark4 =>	    Copier.CtxValue[syms, vCtx, syms.seb[sei].idValue],	  ENDCASE => EnumeratedValue[InitTree[sei], vCtx]]};      subtree => {	node: Tree.Index = index;	RETURN [SELECT syms.tb[node].name FROM	  first => Span[UnderType[syms, TypeForTree[syms.tb[node].son[1]]]].first,	  last => Span[UnderType[syms, TypeForTree[syms.tb[node].son[1]]]].last,	  pred => CtxPred[vCtx, EnumeratedValue[syms.tb[node].son[1], vCtx]],	  succ => CtxSucc[vCtx, EnumeratedValue[syms.tb[node].son[1], vCtx]],	  ENDCASE => Copier.NullSEToken]};      ENDCASE => RETURN [Copier.NullSEToken]};  CtxFirst: PROC [ctx: CTXIndex] RETURNS [SEToken] = INLINE {    RETURN[Copier.CtxFirst[syms, ctx]] };  CtxLast: PROC [ctx: CTXIndex] RETURNS [last: SEToken] = {    last ¬ Copier.NullSEToken;    FOR t: SEToken ¬ Copier.CtxFirst[syms, ctx], Copier.CtxNext[syms, ctx, t]       UNTIL t = Copier.NullSEToken DO        last ¬ t       ENDLOOP;    RETURN};  CtxSucc: PROC [ctx: CTXIndex, t: SEToken] RETURNS [SEToken] = INLINE {    RETURN[Copier.CtxNext[syms, ctx, t]] };  CtxPred: PROC [ctx: CTXIndex, t: SEToken] RETURNS [pred: SEToken] = {    next: SEToken;    pred ¬ Copier.NullSEToken;    IF t # Copier.NullSEToken THEN {      next ¬ Copier.CtxFirst[syms, ctx];      UNTIL next = t OR next = Copier.NullSEToken DO	pred ¬ next; next ¬ Copier.CtxNext[syms, ctx, next] ENDLOOP};    RETURN};     InitTree: PROC [sei: ISEIndex] RETURNS [Tree.Link] = INLINE {    RETURN [syms.tb[ToTreeIndex[syms.seb[sei].idValue]].son[3]]}; -- operations on addresses  AddrOp: PUBLIC PROC [node: Tree.Index, target: CSEIndex] = {    SELECT syms.tb[node].name FROM      addr => Addr[node, target];      base => Base[node, target];      length => Length[node];      arraydesc => Desc[node, target];      ENDCASE => ERROR};  Addr: PROC [node: Tree.Index, target: CSEIndex] = {    OPEN syms.tb[node];    type: CSEIndex;    attr: Attr;    subType: CSEIndex = NormalType[syms, target];    var: BOOLEAN = WITH t: syms.seb[subType] SELECT FROM      ref => t.var,      ENDCASE => FALSE;    counted, readOnly: BOOLEAN ¬ FALSE;    IF P3S.safety = checked AND ~var THEN Log.ErrorNode[unsafeOperation, node];    son[1] ¬ Exp[son[1], typeANY];    FOR t: Tree.Link ¬ son[1], NthSon[syms, t, 1] DO      SELECT OpName[syms, t] FROM	uparrow => {	  subType: CSEIndex = NormalType[syms, OperandType[NthSon[syms, t, 1]]];	  WITH p: syms.seb[subType] SELECT FROM	    ref => IF p.counted THEN counted ¬ TRUE;	    ENDCASE;	  EXIT};	cast, openx => NULL;	ENDCASE => EXIT;      ENDLOOP;    SELECT OperandLhs[son[1]] FROM      counted =>        IF var THEN {	  son[1] ¬ SafenRef[son[1]];	  IF RCType[syms, RType[]] # none THEN Log.ErrorTree[unimplemented, son[1]]};      none => readOnly ¬ TRUE; -- Pass4 will complain      ENDCASE;    type ¬ MakeRefType[      cType:RType[], hint:subType, counted:counted AND ~var, var:var,       readOnly: readOnly];    IF var THEN {Log.ErrorNode[unimplemented, node]; attr2 ¬ FALSE}    ELSE IF (attr2 ¬ LongPath[son[1]]) THEN type ¬ MakeLongType[type, target];    attr ¬ RAttr[];  RPop[];  RPush[type, attr]};  SafenRef: PROC [t: Tree.Link] RETURNS [v: Tree.Link] = {    WITH t SELECT FROM      subtree => {        node: Tree.Index = index;	SELECT syms.tb[node].name FROM	  dot, uparrow, dindex, reloc => {	    PushTree[syms, syms.tb[node].son[1]];	    PushNode[syms, safen, 1]; 	    SetInfo[syms, EncodeSei[OperandType[syms.tb[node].son[1]]]];	    syms.tb[node].son[1] ¬ PopTree[syms];  v ¬ t};	  dollar, index, seqindex, loophole, cast, openx, pad, chop => {	    syms.tb[node].son[1] ¬ SafenRef[syms.tb[node].son[1]]; v ¬ t};	  cdot => {	    syms.tb[node].son[2] ¬ SafenRef[syms.tb[node].son[2]]; v ¬ t};	  apply, safen => v ¬ t;	  ENDCASE => ERROR};      ENDCASE => v ¬ t;    RETURN};      StripRelative: PROC [rType: CSEIndex] RETURNS [type: CSEIndex, bType: SEIndex] = {    WITH syms.seb[rType] SELECT FROM      relative => {type ¬ UnderType[syms, offsetType]; bType ¬ baseType};      ENDCASE => {type ¬ rType; bType ¬ SENull};    RETURN};  MakeRelativeType: PROC [type: CSEIndex, bType: SEIndex, hint: CSEIndex]      RETURNS [CSEIndex] = {    rType, tType: CSEIndex;    WITH syms.seb[hint] SELECT FROM      relative =>	IF offsetType = type AND UnderType[syms, baseType] = UnderType[syms, bType] THEN RETURN [hint];      ENDCASE;    tType ¬ IF TypeForm[syms, bType] = long OR TypeForm[syms, type] = long		THEN MakeLongType[NormalType[syms, type], type]		ELSE type;    rType ¬ MakeNonCtxSe[syms, SIZE[relative cons SERecord]];    syms.seb[rType].typeInfo ¬ relative[		baseType: bType,		offsetType: type,		resultType: tType];    syms.seb[rType].mark3 ¬ syms.seb[rType].mark4 ¬ TRUE;    RETURN [rType]};  Base: PROC [node: Tree.Index, target: CSEIndex] = {    OPEN syms.tb[node];    type, aType, nType, subTarget: CSEIndex;    bType: SEIndex;    attr: Attr;    long: BOOLEAN;    IF P3S.safety = checked THEN Log.ErrorNode[unsafeOperation, node];    IF ListLength[syms, son[1]] = 1 THEN {      son[1] ¬ Exp[son[1], typeANY];      [aType, bType] ¬ StripRelative[CanonicalType[RType[]]];      attr ¬ RAttr[];  RPop[];      nType ¬ NormalType[syms, aType];  [subTarget, ] ¬ StripRelative[target];      WITH syms.seb[nType] SELECT FROM	array => {	  name ¬ addr;	  IF OperandLhs[son[1]] = none THEN Log.ErrorTree[nonAddressable, son[1]];	  long ¬ LongPath[son[1]]};	arraydesc => {long ¬ syms.seb[aType].typeTag = long; nType ¬ UnderType[syms, describedType]; attr1 ¬ TRUE};	ENDCASE => IF nType # typeANY THEN Log.ErrorTree[typeClash, son[1]]}    ELSE {      Log.ErrorN[listLong, ListLength[syms, son[1]]-1];      son[1] ¬ UpdateList[syms, son[1], VoidExp];  long ¬ FALSE};    type ¬ MakeRefType[nType, NormalType[syms, subTarget]];    IF (attr2 ¬ long) THEN type ¬ MakeLongType[type, subTarget];    IF bType # SENull THEN type ¬ MakeRelativeType[type, bType, target];    attr.const ¬ FALSE;  RPush[type, attr];  RETURN};  Length: PROC [node: Tree.Index] = {    OPEN syms.tb[node];    type, subType: CSEIndex;    attr: Attr;    IF ListLength[syms, son[1]] = 1 THEN {      son[1] ¬ Exp[son[1], typeANY];      type ¬ RType[];  attr ¬ RAttr[];  RPop[];      subType ¬ IF syms.seb[type].mark3	       THEN NormalType[syms, StripRelative[CanonicalType[type]].type]	       ELSE typeANY;      WITH syms.seb[subType] SELECT FROM	array => {	  IF subType # type THEN son[1] ¬ ForceType[son[1], subType];	  attr.const ¬ TRUE};	arraydesc => {attr.const ¬ FALSE; attr1 ¬ TRUE};	ENDCASE => {	  attr.const ¬ TRUE;	  IF type # typeANY THEN Log.ErrorTree[typeClash, son[1]]}}    ELSE {      attr.const ¬ TRUE;      Log.ErrorN[listLong, ListLength[syms, son[1]]-1];      son[1] ¬ UpdateList[syms, son[1], VoidExp]};    RPush[dataPtr.typeINT, attr];  RETURN};  Desc: PROC [node: Tree.Index, target: CSEIndex] = {    OPEN syms.tb[node];    type, subType: CSEIndex;    attr: Attr;    saveNP: NPUse;    aType, bType: SEIndex ¬ SENull;    cType, iType: SEIndex;    fixed: {none, range, both} ¬ none;    packed: BOOLEAN ¬ FALSE;    long: BOOLEAN;    subTarget: CSEIndex = StripRelative[target].type;    nTarget: CSEIndex = NormalType[syms, subTarget];    IF P3S.safety = checked THEN Log.ErrorNode[unsafeOperation, node];    SELECT ListLength[syms, son[1]] FROM      1 => {	rType: SEIndex;	nType: CSEIndex;	nDerefs: CARDINAL ¬ 0;	son[1] ¬ Exp[son[1], typeANY];	IF OperandLhs[son[1]] = none THEN Log.ErrorTree[nonAddressable, son[1]];	long ¬ LongPath[son[1]];	subType ¬ CanonicalType[RType[]];  attr ¬ RAttr[];	IF subType # RType[] THEN son[1] ¬ ForceType[son[1], subType];  RPop[];	nType ¬ NormalType[syms, subType];	WHILE syms.seb[nType].typeTag = ref AND (nDerefs ¬ nDerefs+1) < 64 DO	  long ¬ syms.seb[subType].typeTag = long;	  subType ¬ CanonicalType[ReferentType[syms, nType]];	  PushTree[syms, son[1]];  PushNode[syms, uparrow, 1];	  SetInfo[syms, EncodeSei[subType]];  	  SetAttr[syms, 2, long];  SetAttr[syms, 3, FALSE];	  son[1] ¬ PopTree[syms];	  nType ¬ NormalType[syms, subType];	  ENDLOOP;	PushTree[syms, son[1]];	IF syms.seb[subType].typeTag = record THEN {	  sei: ISEIndex = SequenceField[LOOPHOLE[subType]];	  SELECT TRUE FROM	    (sei # ISENull) => {	      subType ¬ UnderType[syms, syms.seb[sei].idType];	      WITH s: syms.seb[subType] SELECT FROM		sequence => {		  PushSe[syms, sei]; PushNode[syms, dollar, 2]; 		  SetInfo[syms, EncodeSei[subType]]; SetAttr[syms, 2, long]};		ENDCASE => ERROR};	    (subType = dataPtr.typeStringBody) => NULL;	-- fake sequence	    ENDCASE => {Log.ErrorTree[typeClash, son[1]]; subType ¬ typeANY}};	WITH t: syms.seb[subType] SELECT FROM	  array => {rType ¬ aType ¬ OperandType[son[1]]; fixed ¬ both};	  sequence => {	    rType ¬ cType ¬ t.componentType;  packed ¬ t.packed;	    iType ¬ syms.seb[t.tagSei].idType;  fixed ¬ both;	    IF ~t.controlled THEN Log.ErrorTree[typeClash, son[1]]};	  record => { -- StringBody	    rType ¬ cType ¬ dataPtr.typeCHAR;  packed ¬ TRUE;	    iType ¬ dataPtr.idCARDINAL;  fixed ¬ both};	  ENDCASE => {	    rType ¬ cType ¬ typeANY;	    IF subType # typeANY THEN Log.ErrorTree[typeClash, son[1]]};	subType ¬ MakeRefType[rType, typeANY];	IF long THEN subType ¬ MakeLongType[subType, typeANY];	PushNode[syms, addr, 1];  SetInfo[syms, EncodeSei[subType]];  	SetAttr[syms, 2, long];  son[1] ¬ PopTree[syms]};      3 => {	subNode: Tree.Index = GetNode[syms, son[1]];	syms.tb[subNode].son[1] ¬ Exp[syms.tb[subNode].son[1], typeANY];	[subType,bType] ¬ StripRelative[CanonicalType[RType[]]];	attr ¬ RAttr[];  RPop[];  saveNP ¬ phraseNP;	SELECT syms.seb[NormalType[syms, subType]].typeTag FROM	  basic, ref => NULL;	  ENDCASE => Log.ErrorTree[typeClash, syms.tb[subNode].son[1]];	long ¬ syms.seb[subType].typeTag = long;	syms.tb[subNode].son[2] ¬ Rhs[syms.tb[subNode].son[2], dataPtr.typeINT];	attr ¬ And[RAttr[], attr];  RPop[];	phraseNP ¬ MergeNP[saveNP][phraseNP];	IF syms.tb[subNode].son[3] # Tree.Null THEN {	  syms.tb[subNode].son[3] ¬ TypeExp[syms, syms.tb[subNode].son[3]];	  cType ¬ TypeForTree[syms.tb[subNode].son[3]];  fixed ¬ range}};      ENDCASE;    IF aType = SENull THEN {      WITH syms.seb[nTarget] SELECT FROM	arraydesc => {	  subType ¬ UnderType[syms, describedType];	  WITH t: syms.seb[subType] SELECT FROM	    array =>	      IF fixed = none	       OR (fixed = range AND UnderType[syms, t.componentType] = UnderType[syms, cType]) THEN {		aType ¬ describedType; GO TO old};	    ENDCASE};	ENDCASE;      GO TO new;      EXITS	  old => NULL;	  new => {	    aType ¬ MakeNonCtxSe[syms, SIZE[array cons SERecord]];	    syms.seb[aType] ¬ [mark3: TRUE, mark4: TRUE,		body: cons[array[		  packed: packed,		  indexType: IF fixed < both THEN dataPtr.idCARDINAL ELSE iType,		  componentType: IF fixed > none THEN cType ELSE typeANY]]]}};    -- make type description      BEGIN      WITH t: syms.seb[nTarget] SELECT FROM  	arraydesc =>  	  IF UnderType[syms, t.describedType] = UnderType[syms, aType] THEN GO TO old;	ENDCASE =>	  IF fixed = none AND target = typeANY THEN Log.ErrorNode[noTarget, node];      GO TO new;      EXITS	old => type ¬ nTarget;	new => {	  type ¬ MakeNonCtxSe[syms, SIZE[arraydesc cons SERecord]];	  syms.seb[type].typeInfo ¬ arraydesc[	    readOnly:FALSE, var: FALSE, describedType:aType];	  syms.seb[type].mark3 ¬ syms.seb[type].mark4 ¬ TRUE};      END;    IF (attr2 ¬ long) THEN type ¬ MakeLongType[type, subTarget];    IF bType # SENull THEN type ¬ MakeRelativeType[type, bType, target];    attr.const ¬ FALSE;  RPush[type, attr];  RETURN};  BoolOp: PUBLIC PROC [node: Tree.Index] = {    OPEN syms.tb[node];    attr: Attr;    saveNP: NPUse;    SealRefStack[];    son[1] ¬ Rhs[son[1], dataPtr.typeBOOL]; attr ¬ RAttr[]; saveNP ¬ phraseNP;     ClearRefStack[];    son[2] ¬ Rhs[son[2], dataPtr.typeBOOL];     UnsealRefStack[];    attr ¬ And[attr, RAttr[]];    RPop[];  RPop[];    RPush[dataPtr.typeBOOL, attr]; phraseNP ¬ SequenceNP[saveNP][phraseNP]};    Unspec: PROC [type: CSEIndex] RETURNS [BOOLEAN] = {    RETURN [WITH t: syms.seb[type] SELECT FROM      basic => t.code = codeANY,      ENDCASE => FALSE]};        SafeForUnspec: PROC [target: CSEIndex] RETURNS [BOOLEAN] = {    RETURN [P3S.safety # checked OR RCType[syms, target] = none]};    Rhs: PUBLIC PROC [exp: Tree.Link, lhsType: CSEIndex] RETURNS [val: Tree.Link] = {    RETURN [RhsPrime[exp, lhsType, FALSE]]};      RhsPrime: PUBLIC PROC [exp: Tree.Link, lhsType: CSEIndex, shortenOK: BOOLEAN]      RETURNS [val: Tree.Link] = {    rhsType: CSEIndex;    val ¬ Exp[exp, lhsType];    rhsType ¬ rStack[rI].type;    SELECT TRUE FROM      (lhsType = rhsType), Unspec[lhsType] => NULL;      ENDCASE => {  -- immediate matching is inconclusive	UNTIL Types.Assignable[[syms, lhsType], [syms, rhsType]] DO	  WITH t: syms.seb[rhsType] SELECT FROM	    subrange => rhsType ¬ UnderType[syms, t.rangeType];	    record => {	      IF Bundling[rhsType] = 0 THEN GO TO nomatch;	      rhsType ¬ Unbundle[LOOPHOLE[rhsType, RecordSEIndex]];	      val ¬ ForceType[val, IF Unspec[rhsType] THEN typeANY ELSE rhsType]};	    ref, arraydesc => {	      SELECT syms.seb[lhsType].typeTag FROM		long => {		  IF ~Types.Assignable[[syms, NormalType[syms, lhsType]], [syms, rhsType]] THEN		    GO TO nomatch;		  val ¬ Lengthen[val, lhsType]};		ENDCASE => GO TO nomatch;	      rhsType ¬ lhsType};	    basic => {	      IF Unspec[rhsType] AND SafeForUnspec[lhsType] THEN		SELECT syms.seb[lhsType].typeTag FROM		  long => val ¬ Lengthen[val, MakeLongType[typeANY, lhsType]];		  ENDCASE	      ELSE SELECT syms.seb[lhsType].typeTag FROM		long => {		  IF ~Types.Assignable[[syms, NormalType[syms, lhsType]], [syms, rhsType]] THEN		    GO TO nomatch;		  val ¬ Lengthen[val, lhsType]};		real =>		  IF rhsType = dataPtr.typeINT THEN {		    val ¬ Float[val, rhsType, lhsType]; rStack[rI].attr.const ¬ FALSE} 		  ELSE GO TO nomatch;		ENDCASE => GO TO nomatch;	      rhsType ¬ lhsType};	    long => {	      subType: CSEIndex = NormalType[syms, rhsType];	      SELECT syms.seb[lhsType].typeTag FROM		long =>		  SELECT TRUE FROM		    Unspec[NormalType[syms, lhsType]] => lhsType ¬ rhsType;		    Unspec[subType] AND SafeForUnspec[lhsType] =>		      rhsType ¬ lhsType;		    ENDCASE => GO TO nomatch;		real =>		  IF subType = dataPtr.typeINT THEN {		    val ¬ Float[val, rhsType, lhsType];  rStack[rI].attr.const ¬ FALSE;		    rhsType ¬ lhsType} 		  ELSE GO TO nomatch;		basic, subrange => {		  IF ~Types.Assignable[[syms, subType], [syms, lhsType]] THEN		    GO TO nomatch;		  rhsType ¬ UnderType[syms, t.rangeType]; 		  IF ~shortenOK THEN Log.WarningTree[autoShorten, val];		  val ¬ Shorten[val, rhsType]};		enumerated =>		  IF Types.Equivalent[[syms, rhsType], [syms, dataPtr.typeATOM]] THEN {		    Log.ErrorTree[missingCoercion, val];  rhsType ¬ lhsType}		  ELSE GOTO nomatch;		ENDCASE => GO TO nomatch};	    ENDCASE => GO TO nomatch;	  REPEAT	    nomatch => {	-- no coercion is possible	      Log.ErrorTree[typeClash,		IF exp = Tree.Null THEN P3S.implicit.tree ELSE val];	      rhsType ¬ lhsType};	  ENDLOOP;	rStack[rI].type ¬ rhsType};    IF syms.seb[rhsType].typeTag = transfer AND OperandInline[val] THEN      Log.ErrorTree[misusedInline, val];    RETURN};  GenericRhs: PUBLIC PROC [exp: Tree.Link, target: CSEIndex] RETURNS [val: Tree.Link] = {    type: CSEIndex;    val ¬ Exp[exp, target];  type ¬ rStack[rI].type;    -- put value in canonical form    DO      WITH syms.seb[type] SELECT FROM	subrange => type ¬ UnderType[syms, rangeType];	record => {	  IF Bundling[type] = 0 THEN EXIT;	  type ¬ Unbundle[LOOPHOLE[type, RecordSEIndex]];	  val ¬ ForceType[val, type]};	ENDCASE => EXIT;      rStack[rI].type ¬ type;      ENDLOOP;    SELECT syms.seb[target].typeTag FROM      enumerated =>        IF Types.Equivalent[[syms, type], [syms, dataPtr.typeATOM]] THEN {          Log.ErrorTree[missingCoercion, val];  rStack[rI].type ¬ target};      ENDCASE;    RETURN};  BalancedRhs: PUBLIC PROC [exp: Tree.Link, target: CSEIndex] RETURNS [val: Tree.Link] = {    type: CSEIndex;    val ¬ Exp[exp, target];    SELECT syms.seb[target].typeTag FROM      long, real => {	type ¬ CanonicalType[rStack[rI].type];	IF type # typeANY AND syms.seb[target].typeTag # syms.seb[type].typeTag	 AND Types.Equivalent[[syms, NormalType[syms, target]], [syms, type]] THEN {	  SELECT syms.seb[target].typeTag FROM	    long => IF syms.seb[type].typeTag # real THEN val ¬ Lengthen[val, target];	    real => {val ¬ Float[val, type, target]; rStack[rI].attr.const ¬ FALSE};	    ENDCASE;	  rStack[rI].type ¬ target}};      enumerated =>        IF Types.Equivalent[[syms, rStack[rI].type], [syms, dataPtr.typeATOM]] THEN {          Log.ErrorTree[missingCoercion, val];  rStack[rI].type ¬ target};      ENDCASE;    RETURN};  }.
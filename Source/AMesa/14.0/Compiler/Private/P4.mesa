-- Copyright (C) 1983, 1986  by Xerox Corporation. All rights reserved. -- file P4.Mesa--   Satterthwaite,	September 30, 1982 9:18 am--   Sweet,		11-Jun-83 23:21:36--   Wagner,		22-Aug-86 11:06:19DIRECTORY  Inline USING [BITAND],  LiteralOps USING [ValueDescriptor],  Literals USING [LitDescriptor],  Symbols,  SymbolTable USING [Handle],  Tree USING [Index, Link, NodeName],  TreeOps USING [Map, Scan];P4: DEFINITIONS IMPORTS Inline = {  OPEN Symbols;  mark: BOOLEAN = FALSE;  ownGfi: CARDINAL = 1; -- representations (interim)  Repr: TYPE = [none..all];    signed: CARDINAL = 1;    unsigned: CARDINAL = 2;    long: CARDINAL = 4;    other: CARDINAL = 8;    none: CARDINAL = 0;    both: CARDINAL = signed+unsigned;    all: CARDINAL = other+long+both;  CommonRep: PROC [Repr, Repr] RETURNS [Repr] = LOOPHOLE[Inline.BITAND]; -- properties (synthesized)   Prop: TYPE = RECORD [    noAssign: BOOLEAN,    noXfer: BOOLEAN,    noSelect: BOOLEAN,    noFreeVar: BOOLEAN];      fullProp: Prop = [noAssign:TRUE, noXfer:TRUE, noSelect:TRUE, noFreeVar:TRUE];  emptyProp: Prop = [noAssign:FALSE, noXfer:FALSE, noSelect:FALSE, noFreeVar:FALSE];  voidProp: Prop = fullProp;    CommonProp: PROC [Prop, Prop] RETURNS [Prop] = LOOPHOLE[Inline.BITAND]; -- attributes   Attr: TYPE = RECORD [prop: Prop, rep: Repr];      voidAttr: Attr = [prop: voidProp, rep: none];    CommonAttr: PROC [Attr, Attr] RETURNS [Attr] = LOOPHOLE[Inline.BITAND];    -- intermediate result bookkeeping  ValueDescriptor: TYPE = RECORD[    bias: INTEGER,		-- bias in representation (scalars only)    nRegs: RegCount,	-- estimate of register requirement    attr: Attr];		-- synthesized attributes  VStack: TYPE = RECORD [SEQUENCE length: NAT OF ValueDescriptor];         -- register counts  RegCount: TYPE = [0..32);  maxRegs: RegCount = LAST[RegCount];    -- Overflow checking     CheckOver: PROC [lc: LONG CARDINAL] RETURNS [CARDINAL] = INLINE {    RETURN[IF lc > LAST[CARDINAL] THEN ERROR ELSE CARDINAL[lc]] }; -- exported by Pass4B  Pass4BInit: PROC [SymbolTable.Handle];  AssignImports: TreeOps.Scan;  InitBCD: PROC [Tree.Link, UNCOUNTED ZONE];  FinishBCD: PROC [ids: Tree.Link];  MatchBCD: PROC RETURNS [BOOLEAN];  ProcessDirectory: TreeOps.Scan;  ProcessExports: TreeOps.Map;  ProcessImports: TreeOps.Scan;  ProcessSymLiterals: PROC; -- exported by Pass4D  Pass4DInit: PROC [SymbolTable.Handle];    BiasForType: PROC [CSEIndex] RETURNS [INTEGER];  CanonicalType: PROC [CSEIndex] RETURNS [CSEIndex];  ComparableType: PROC [CSEIndex] RETURNS [BOOLEAN];  DeclItem: TreeOps.Scan;  DeclUpdate: TreeOps.Map;  DefaultBasicOps: PROC [SEIndex, CARDINAL] RETURNS [BOOLEAN];  RepForType: PROC [CSEIndex] RETURNS [Repr];  SparseRep: PROC [CSEIndex] RETURNS [BOOLEAN];  TypeExp: PROC [typeExp: Tree.Link, body, indirect: BOOLEAN ¬ FALSE];  TypeForTree: PROC [Tree.Link] RETURNS [SEIndex];  WordsForType: PROC [CSEIndex] RETURNS [CARDINAL];  VarInit: SIGNAL RETURNS [BOOLEAN]; -- exported by Pass4L  Pass4LInit: PROC [SymbolTable.Handle];  AssignEntries: PROC [BTIndex];  BitsForType: PROC [SEIndex] RETURNS [LONG CARDINAL];  CheckBlock: PROC [BTIndex];  CheckFields: PROC [RecordSEIndex, CARDINAL];  LayoutArgs: PROC [RecordSEIndex, CARDINAL, BOOLEAN] RETURNS [CARDINAL];  LayoutBlock: PROC [BTIndex, CARDINAL] RETURNS [CARDINAL];  LayoutFields: PROC [RecordSEIndex, CARDINAL];  LayoutGlobals: PROC [bti: CBTIndex, stopping, fragments: BOOLEAN] RETURNS [CARDINAL];  LayoutInterface: PROC [CBTIndex] RETURNS [CARDINAL];  LayoutLocals: PROC [CBTIndex] RETURNS [CARDINAL]; -- exported by Pass4S  currentLevel: ContextLevel;  checked: BOOLEAN;  Pass4SInit: PROC [SymbolTable.Handle];  BindCase: PROC [      Tree.Index, Tree.NodeName, PROC [Tree.Link, INTEGER] RETURNS [Tree.Link]]    RETURNS [Tree.Link];  BindType: PROC [Tree.Index, TreeOps.Map] RETURNS [Tree.Link];  Body: PROC [CBTIndex];  CaseDriver: PROC [Tree.Index, TreeOps.Map, INTEGER] RETURNS [Tree.Link];  CatchNest: PROC [Tree.Link];  MarkString: PROC [local: BOOLEAN ¬ TRUE];  Subst: PROC [Tree.Index] RETURNS [Tree.Link]; -- exported by Pass4Ops  RelOp: TYPE = Tree.NodeName [relE .. relLE];  Pass4OpsInit: PROC [SymbolTable.Handle];  FoldExpr: PROC [Tree.Index, Repr] RETURNS [Tree.Link];  IntervalTest: PROC [l,r: Tree.Link, rep: Repr] RETURNS [BOOLEAN];  IntToReal: PROC [Tree.Index] RETURNS [Tree.Link];  LiteralRep: PROC [Tree.Link, Repr] RETURNS [Repr];  LongToShort: PROC [Tree.Index, Repr] RETURNS [Tree.Link];  MakeTreeLiteral: PROC [WORD] RETURNS [Tree.Link];  RelTest: PROC [l,r: Tree.Link, op: RelOp, rep: Repr] RETURNS [BOOLEAN];  ShortToLong: PROC [Tree.Index, Repr] RETURNS [Tree.Link];  StructuredLiteral: PROC [Tree.Link] RETURNS [BOOLEAN];  TreeLiteral: PROC [Tree.Link] RETURNS [BOOLEAN];  TreeLiteralDesc: PROC [Tree.Link] RETURNS [Literals.LitDescriptor];  TreeLiteralValue: PROC [Tree.Link] RETURNS [WORD];  ZeroP: PROC [Tree.Link] RETURNS [BOOLEAN]; -- exported by Pass4Xa  Covering: TYPE = {none, partial, full};  Pass4XaInit: PROC [SymbolTable.Handle];  All: PROC [Tree.Index] RETURNS [Tree.Link];  Assignment: PROC [Tree.Index] RETURNS [Tree.Link];  Call: PROC [Tree.Index] RETURNS [Tree.Link];  CheckRange: PROC [Tree.Link, CARDINAL, CSEIndex] RETURNS [Tree.Link];  Construct: PROC [Tree.Index] RETURNS [Tree.Link];  Cover: PROC [lType: CSEIndex, lRep: Repr, rType: CSEIndex, rRep: Repr]    RETURNS [Covering];  Dollar: PROC [Tree.Index] RETURNS [Tree.Link];  Extract: PROC [Tree.Index] RETURNS [Tree.Link];  Index: PROC [Tree.Index] RETURNS [Tree.Link];  MakeArgRecord: PROC [RecordSEIndex, Tree.Link] RETURNS [Tree.Link];  Narrow: PROC [Tree.Index] RETURNS [Tree.Link];  New: PROC [Tree.Index] RETURNS [Tree.Link];  PadRecord: PROC [t: Tree.Link, lType: CSEIndex] RETURNS [Tree.Link];  RewriteAssign: PROC [Tree.Index, CSEIndex] RETURNS [Tree.Link];  Reloc: PROC [Tree.Index] RETURNS [Tree.Link];  Rhs: PROC [exp: Tree.Link, lType: CSEIndex, voidOK: BOOLEAN ¬ FALSE]    RETURNS [Tree.Link];  RowConstruct: PROC [Tree.Index] RETURNS [Tree.Link];  SeqIndex: PROC [Tree.Index] RETURNS [Tree.Link];  Substx: PROC [Tree.Index] RETURNS [Tree.Link];  Union: PROC [Tree.Index] RETURNS [Tree.Link]; -- exported by Pass4Xb   vStack: LONG POINTER TO VStack;  vI: INTEGER;		-- index into vStack  Pass4XbInit: PROC [SymbolTable.Handle, UNCOUNTED ZONE];  ExpReset: PROC;  AdjustBias: PROC [Tree.Link, INTEGER] RETURNS [Tree.Link];  AdjustRegs: PROC [node: Tree.Index, commuteOp: Tree.NodeName] RETURNS [RegCount];  ArithRep: PROC [rep, target: Repr] RETURNS [Repr];  BiasedFold: PROC [node: Tree.Index, rep: Repr] RETURNS [Tree.Link];  BinaryAttr: PROC RETURNS [Attr];  BoolValue: PROC [t: Tree.Link] RETURNS [Tree.Link] = INLINE {    RETURN [RValue[t, 0, unsigned]]};  ComputeIndexRegs: PROC [Tree.Index] RETURNS [RegCount];  ComputeRegs: PROC [node: Tree.Index] RETURNS [RegCount];  Exp: PROC [Tree.Link, Repr] RETURNS [Tree.Link];  FillMultiWord: PROC [    words: LiteralOps.ValueDescriptor, origin: CARDINAL, t: Tree.Link];  Fold: PROC [node: Tree.Index, rep: Repr] RETURNS [Tree.Link];  FoldedAttr: PROC [val: Tree.Link, rep: Repr] RETURNS [Attr];  ForceType: PROC [Tree.Link, CSEIndex] RETURNS [Tree.Link];  LiteralAttr: PROC [Repr] RETURNS [Attr];  MakeStructuredLiteral: PROC [val: WORD, type: CSEIndex] RETURNS [Tree.Link];  NeutralExp: TreeOps.Map;  OperandType: PROC [Tree.Link] RETURNS [CSEIndex];  RegsForType: PROC [CSEIndex] RETURNS [RegCount];  RValue: PROC [exp: Tree.Link, bias: INTEGER, target: Repr] RETURNS [Tree.Link];  VAttr: PROC RETURNS [Attr];  VBias: PROC RETURNS [INTEGER];  VPop: PROC;  VProp: PROC RETURNS [Prop];  VPush: PROC [bias: INTEGER, attr: Attr, nRegs: RegCount];  VRegs: PROC RETURNS [RegCount];  VRep: PROC RETURNS [Repr]; -- exported by Pass4Xc  Pass4XcInit: PROC [SymbolTable.Handle];    AddOp: PROC [node: Tree.Index, target: Repr] RETURNS [val: Tree.Link];  AddrOp: PROC [Tree.Index] RETURNS [Tree.Link];  ConstantInterval: PROC [Tree.Index] RETURNS [origin, range: INTEGER];  DivMod: PROC [node: Tree.Index, target: Repr] RETURNS [val: Tree.Link];  Interval: PROC [Tree.Index, INTEGER, Repr] RETURNS [const: BOOLEAN];  Lengthen: PROC [Tree.Index, Repr] RETURNS [Tree.Link];  NormalizeRange: PROC [Tree.Link] RETURNS [Tree.Link];  MiscXfer: PROC [Tree.Index] RETURNS [Tree.Link];  Mult: PROC [node: Tree.Index, target: Repr] RETURNS [val: Tree.Link];  TypeOp: PROC [Tree.Index] RETURNS [Tree.Link];  EmptyInterval: SIGNAL;  }.
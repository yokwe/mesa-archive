-- Copyright (C) 1983, 1986  by Xerox Corporation. All rights reserved. -- file Debug.mesa--   Satterthwaite,	June 22, 1982 3:48 pm--   Sweet,		12-Jun-83  0:43:09--   Wagner		22-Aug-86 11:03:36DIRECTORY  Alloc USING [Base, Handle, Notifier, AddNotify, DropNotify, Top],  BcdDefs USING [VersionStamp],  ComData USING [ownSymbols],  CompilerUtil USING [    AcquireStream, AcquireTable, ReleaseStream, ReleaseTable],  DebugTable USING [CSRptr],  Format USING [Date, Decimal, Octal, StringProc],  Literals USING [LitDescriptor],  LiteralOps USING [DescriptorValue, MasterString, StringValue],  String USING [SubString, SubStringDescriptor],  Stream USING [Handle, PutChar, PutString],  Symbols USING [    BitAddress, ctxType, CTXRecord, TransferMode, TypeClass,    HTIndex, SEIndex, ISEIndex, CSEIndex, CTXIndex, BTIndex,    HTNull, SENull, CTXNull, lG, lZ, RootBti, typeTYPE,    DummyLink],  SymbolOps USING [    EnumerateBodies, FindExtension, HashForSe, NextSe,    SubStringForHash, ToBitAddr, ToCard, ToLink, ToSei, TypeLink, XferMode],  SymbolTable USING [Handle],  Tree USING [Index, Link, NodeName, NullIndex],  TreeOps USING [DecodeCard, GetNode, Scan, ScanSons];Debug: PROGRAM    IMPORTS      Alloc, dataPtr: ComData, CompilerUtil, Format, LiteralOps, Stream,       SymbolOps, TreeOps    EXPORTS CompilerUtil = {  OPEN Symbols;  syms: SymbolTable.Handle ¬ NIL;    definitionsOnly: BOOLEAN;    DebugNotify: Alloc.Notifier = {    syms ¬ dataPtr.ownSymbols };  SubString: TYPE = String.SubString; -- basic io  errorStream: Stream.Handle ¬ NIL;    errPut: Format.StringProc = {errorStream.PutString[s]};  WriteChar: PROC [c: CHARACTER] = {errorStream.PutChar[c]};  WriteString: PROC [s: STRING] = {errorStream.PutString[s]};  WriteDecimal: PROC [n: INTEGER] = {Format.Decimal[errPut, n]};  WriteOctal: PROC [n: INTEGER] = {Format.Octal[errPut, n]};  NewLine: PROC = INLINE {WriteChar['\n]};  Indent: PROC [n: CARDINAL] = {    NewLine[];    THROUGH [1..n/8] DO WriteChar['\t] ENDLOOP;    THROUGH [1..n MOD 8] DO WriteChar[' ] ENDLOOP};  -- errorStream, csrP and desc.base are set by Enter  csrP: DebugTable.CSRptr;  desc: String.SubStringDescriptor;  ss: SubString = @desc;  LockStringTable: PROC = INLINE {    csrP ¬ CompilerUtil.AcquireTable[debug];    ss.base ¬ @csrP[csrP.stringOffset]};  UnlockStringTable: PROC = INLINE {CompilerUtil.ReleaseTable[debug]; csrP ¬ NIL};  Enter: PROC [table: Alloc.Handle] = {    table.AddNotify[DebugNotify, NIL];    errorStream ¬ CompilerUtil.AcquireStream[log];  LockStringTable[]};  Exit: PROC [table: Alloc.Handle] = {    UnlockStringTable[];  CompilerUtil.ReleaseStream[log]; errorStream ¬ NIL;    table.DropNotify[DebugNotify, NIL]};  WriteSubString: PROC [ss: SubString] = {    FOR i: CARDINAL IN [ss.offset..ss.offset+ss.length) DO      WriteChar[ss.base[i]] ENDLOOP};  -- tree printing  PrintLiteral: PROC [t: literal Tree.Link] = {    WITH t.info SELECT FROM      string => {	s: LONG STRING = LiteralOps.StringValue[syms, index];	WriteChar['"];	FOR i: CARDINAL IN [0..s.length) DO WriteChar[s[i]] ENDLOOP;	WriteChar['"];	IF index # LiteralOps.MasterString[syms, index] THEN WriteChar['L]};      word => {	desc: Literals.LitDescriptor = LiteralOps.DescriptorValue[syms, index];	v: WORD;	IF desc.length # 1 THEN WriteChar['[];	FOR i: CARDINAL IN [0 .. desc.length) DO	  IF (v ¬ syms.ltb[desc.offset][i]) < 1000 THEN WriteDecimal[v]	  ELSE WriteOctal[v];	  IF i+1 # desc.length THEN WriteChar[',];	  ENDLOOP;	IF desc.length # 1 THEN WriteChar[']]};      ENDCASE};  WriteNodeName: PROC [n: Tree.NodeName] = {    ss.offset ¬ csrP.NodePrintName[n].offset; ss.length ¬ csrP.NodePrintName[n].length;    WriteSubString[ss]};  PrintSubTree: PROC [t: Tree.Link, nBlanks: CARDINAL] = {    OPEN Tree;    Printer: TreeOps.Scan = {      Indent[nBlanks];      WITH s: t SELECT FROM	hash => PrintHti[s.index];	symbol => {PrintSei[s.index]; WriteChar['[]; PrintIndex[s.index]; WriteChar[']]};	literal => PrintLiteral[s];	subtree => {	  node: Tree.Index = s.index;	  IF node = Tree.NullIndex THEN WriteString["<empty>"L]	  ELSE {	    OPEN syms.tb[node];	    WriteNodeName[name];	    WriteChar['[];  PrintIndex[node];  WriteString["] "L];	    IF TreeOps.DecodeCard[info] # 0 THEN {	      WriteString["  info="L]; 	      PrintIndex[TreeOps.DecodeCard[info]]};	    IF attr1 OR attr2 OR attr3 THEN {	      IF TreeOps.DecodeCard[info] = 0 THEN WriteChar[' ];	      WriteChar['(];	      IF attr1 THEN WriteChar['1];	      IF attr2 THEN WriteChar['2];	      IF attr3 THEN WriteChar['3];	      WriteChar[')]};	    nBlanks ¬ nBlanks + 2;	    IF name # thread THEN TreeOps.ScanSons[syms, s, Printer]	    ELSE {	      WriteString[" link="L]; PrintIndex[TreeOps.GetNode[syms, son[2]]];	      Printer[syms, son[1]]};	    nBlanks ¬ nBlanks - 2}};	ENDCASE};    Printer[syms, t]};  PrintTree: PUBLIC PROC [table: Alloc.Handle, root: Tree.Link] = {    Enter[table];    PrintSubTree[root, 0];  NewLine[];  NewLine[];    Exit[table]};  PrintBodies: PUBLIC PROC [table: Alloc.Handle] = {    Enter[table];    [] ¬ SymbolOps.EnumerateBodies[syms, RootBti, PrintBody];  NewLine[];    Exit[table]};  PrintBody: PROC [h: SymbolTable.Handle, bti: BTIndex] RETURNS [BOOLEAN] = {    OPEN body: syms.bb[bti];    WriteString["Body: "L];    WITH b: body SELECT FROM      Callable => {	PrintSei[b.id];	IF b.inline THEN WriteString[" [inline]"L]	ELSE {	  WriteString[", ep: "L];  WriteDecimal[b.entryIndex];	  WITH b SELECT FROM	    Inner => {WriteString[", frame addr: "L]; WriteDecimal[frameOffset]};	    ENDCASE};	WriteString[", attrs: "L];	WriteChar[IF ~b.noXfers THEN 'x ELSE '-];	WriteChar[IF b.hints.safe THEN 's ELSE '-];	WriteChar[IF b.hints.nameSafe THEN 'n ELSE '-];	IF ~b.hints.needsFixup THEN {Indent[2]; WriteString["needs fixup"L]}};      ENDCASE => WriteString["(anon)"L];    Indent[2];    WriteString["context: "L];  PrintIndex[body.localCtx];    WriteString[", level: "L];  WriteDecimal[body.level];    WITH body.info SELECT FROM      Internal => {	WriteString[", frame size: "L];  WriteDecimal[frameSize];	IF body.kind = Callable THEN PrintSubTree[[subtree[index: bodyTree]], 0]	ELSE {WriteString[", tree root: "L]; PrintIndex[bodyTree]}};      ENDCASE;    NewLine[];  NewLine[];  RETURN [FALSE]};  PrintSymbols: PUBLIC PROC [table: Alloc.Handle, definitions: BOOLEAN] = {    ctx: CTXIndex;    limit: CTXIndex;    Enter[table];    definitionsOnly ¬ definitions;    limit ¬ table.Top[Symbols.ctxType];    ctx ¬ FIRST[CTXIndex] + SIZE [nil CTXRecord];    UNTIL ctx = limit DO      PrintContext[ctx];  NewLine[];  NewLine[];      ctx ¬ ctx + (WITH syms.ctxb[ctx] SELECT FROM	included => SIZE [included CTXRecord],	imported => SIZE [imported CTXRecord],	ENDCASE => SIZE [simple CTXRecord]);      ENDLOOP;    NewLine[];    Exit[table]};  PrintContext: PROC [ctx: CTXIndex] = {    sei, root: ISEIndex;    WriteString["Context: "L];  PrintIndex[ctx];    IF syms.ctxb[ctx].level # lZ THEN {WriteString[", level: "L]; WriteDecimal[syms.ctxb[ctx].level]};    WITH c: syms.ctxb[ctx] SELECT FROM      included => {	WriteString[", copied from: "L]; PrintHti[syms.mdb[c.module].moduleId];	WriteString[" ["L]; PrintHti[syms.mdb[c.module].fileId];	WriteString[", "L]; PrintVersion[syms.mdb[c.module].stamp];	WriteString["], context: "L];  PrintIndex[c.map]};      imported => {	WriteString[", imported from: "L]; PrintHti[syms.mdb[syms.ctxb[c.includeLink].module].moduleId]};      ENDCASE;    root ¬ sei ¬ syms.ctxb[ctx].seList;    DO      IF sei = SENull THEN EXIT;      PrintSE[sei, 2];      IF (sei ¬ SymbolOps.NextSe[syms, sei]) = root THEN EXIT;      ENDLOOP};  PrintSE: PROC [sei: ISEIndex, nBlanks: CARDINAL] = {    OPEN syms.seb[sei];    typeSei: SEIndex;    Indent[nBlanks];    PrintSei[sei];    WriteString[" ["L];  PrintIndex[sei];  WriteChar[']];    IF public THEN WriteString[" [public]"L];    IF mark3 THEN {      WriteString[", type = "L];      IF idType = typeTYPE THEN {	typeSei ¬ SymbolOps.ToSei[idInfo];	WriteString["TYPE, equated to: "L];	PrintType[typeSei];	IF syms.ctxb[idCtx].level = lZ AND SymbolOps.TypeLink[syms, sei] # SENull THEN {	  WriteString[", tag code: "L]; WriteDecimal[SymbolOps.ToCard[idValue]]}}	ELSE {	  typeSei ¬ idType;  PrintType[typeSei];	  SELECT TRUE FROM	    constant => WriteString[" [const]"L];	    immutable => WriteString[" [init only]"L];	    ENDCASE;	  IF ~mark4 THEN {	    WriteString[", # refs: "L]; 	    WriteDecimal[SymbolOps.ToCard[idInfo]]}	  ELSE	    SELECT TRUE FROM	      constant =>		IF ~ extended THEN {		  WriteString[", value: "L];		  SELECT SymbolOps.XferMode[syms, typeSei] FROM		    proc, program, signal, error => PrintLink[SymbolOps.ToLink[idValue]];		    ENDCASE =>		      IF LOOPHOLE[idValue, CARDINAL] < 1000 THEN 		        WriteDecimal[SymbolOps.ToCard[idValue]]		      ELSE WriteOctal[SymbolOps.ToCard[idValue]]};	      (definitionsOnly AND syms.ctxb[idCtx].level = lG) => {		WriteString[", index: "L]; WriteDecimal[SymbolOps.ToCard[idValue]]};	      ENDCASE => {		addr: BitAddress = SymbolOps.ToBitAddr[idValue];		WriteString[", address: "L];		WriteDecimal[addr.wd];  WriteChar[' ];		WriteChar['[];  WriteDecimal[addr.bd];		WriteChar[':];  WriteDecimal[SymbolOps.ToCard[idInfo]];  WriteChar[']];		IF linkSpace THEN WriteChar['*]}};	PrintTypeInfo[typeSei, nBlanks+2];	IF extended THEN PrintSubTree[SymbolOps.FindExtension[syms, sei].tree, nBlanks+4]}};  PrintHti: PROC [hti: HTIndex] = {    desc: String.SubStringDescriptor;    s: SubString = @desc;    IF hti = HTNull THEN WriteString["(anon)"L]    ELSE {SymbolOps.SubStringForHash[syms, s, hti]; WriteSubString[s]}};  PrintSei: PROC [sei: ISEIndex] = {PrintHti[SymbolOps.HashForSe[syms, sei]]};  WriteTypeName: PROC [n: TypeClass] = {    ss.offset ¬ csrP.TypePrintName[n].offset;  ss.length ¬ csrP.TypePrintName[n].length;    WriteSubString[ss]};  WriteModeName: PROC [n: TransferMode] = {    ss.offset ¬ csrP.ModePrintName[n].offset;  ss.length ¬ csrP.ModePrintName[n].length;    WriteSubString[ss]};  PrintType: PROC [sei: SEIndex] = {    tSei: SEIndex;    IF sei = SENull THEN WriteChar['?]    ELSE      WITH t: syms.seb[sei] SELECT FROM	cons =>	  WITH t SELECT FROM	    transfer => WriteModeName[mode];	    ENDCASE => WriteTypeName[t.typeTag];	id =>	  FOR tSei ¬ sei, SymbolOps.TypeLink[syms, tSei] UNTIL tSei = SENull DO	    WITH syms.seb[tSei] SELECT FROM	      id => {		IF sei # tSei THEN WriteChar[' ];		PrintSei[LOOPHOLE[tSei, ISEIndex]];		IF ~mark3 OR syms.ctxb[idCtx].level # lZ THEN EXIT};	      ENDCASE;	    ENDLOOP;	ENDCASE;    WriteString[" ["L];  PrintIndex[sei];  WriteChar[']]};  PrintTypeInfo: PROC [sei: SEIndex, nBlanks: CARDINAL] = {    IF sei # SENull THEN      WITH s: syms.seb[sei] SELECT FROM	cons => {	  Indent[nBlanks];	  WriteChar['[];  PrintIndex[sei];  WriteString["] "L];	  WITH s SELECT FROM	    transfer => WriteModeName[mode];	    ENDCASE => WriteTypeName[s.typeTag];	  WITH t: s SELECT FROM	    basic => NULL;	    enumerated => {	      IF t.machineDep THEN WriteString[" (md)"L]	      ELSE IF t.unpainted THEN WriteString[" (~painted)"L];	      WriteString[", value ctx: "L];  PrintIndex[t.valueCtx]};	    record => {	      IF t.machineDep THEN WriteString[" (md)"L];	      IF t.monitored THEN WriteString[" (monitored)"L];	      IF t.hints.variant THEN WriteString[" (variant)"L];	      OutCtx[", field"L, t.fieldCtx];	      WITH syms.ctxb[t.fieldCtx] SELECT FROM		included => IF ~complete THEN WriteString[" [partial]"L];		imported => WriteString[" [partial]"L];		ENDCASE;	      WITH t SELECT FROM		linked => {WriteString[", link: "L]; PrintType[linkType]};		ENDCASE};	    ref => {	      SELECT TRUE FROM		t.counted => WriteString[" (counted)"L];		t.var => WriteString[" (var)"L];		ENDCASE;	      IF t.ordered THEN WriteString[" (ordered)"L];	      IF t.basing THEN WriteString[" (base)"L];	      WriteString[", to: "L]; PrintType[t.refType];	      IF t.readOnly THEN WriteString[" (readonly)"L];	      PrintTypeInfo[t.refType, nBlanks+2]};	    array => {	      IF t.packed THEN WriteString[" (packed)"L];	      WriteString[", index type: "L]; PrintType[t.indexType];	      WriteString[", component type: "L]; PrintType[t.componentType];	      PrintTypeInfo[t.indexType, nBlanks+2];	      PrintTypeInfo[t.componentType, nBlanks+2]};	    arraydesc => {	      WriteString[", described type: "L]; PrintType[t.describedType];	      IF t.readOnly THEN WriteString[" (readonly)"L];	      PrintTypeInfo[t.describedType, nBlanks+2]};	    transfer => {	      IF t.safe THEN WriteString[" (safe)"L];	      OutArgType[", input"L, t.typeIn];	      OutArgType[", output"L, t.typeOut]};	    definition => {	      WriteString[", ctx: "L];  PrintIndex[t.defCtx]};	    union => {	      IF t.overlaid THEN WriteString[" (overlaid)"L];	      IF t.controlled THEN {WriteString[", tag: "L]; PrintSei[t.tagSei]};	      WriteString[", tag type: "L];	      PrintType[syms.seb[t.tagSei].idType];	      WriteString[", case ctx: "L];  PrintIndex[t.caseCtx];	      IF t.controlled THEN PrintSE[t.tagSei, nBlanks+2]};	    sequence => {	      IF t.packed THEN WriteString[" (packed)"L];	      IF t.controlled THEN {WriteString[", tag: "L]; PrintSei[t.tagSei]}	      ELSE {WriteString[", index type: "L];  PrintType[syms.seb[t.tagSei].idType]};	      WriteString[", component type: "L]; PrintType[t.componentType];	      IF t.controlled THEN PrintSE[t.tagSei, nBlanks+2]	      ELSE PrintTypeInfo[syms.seb[t.tagSei].idType, nBlanks+2];	      PrintTypeInfo[t.componentType, nBlanks+2]};	    relative => {	      WriteString[", base type: "L]; PrintType[t.baseType];	      WriteString[", offset type: "L]; PrintType[t.offsetType];	      PrintTypeInfo[t.baseType, nBlanks+2];	      PrintTypeInfo[t.offsetType, nBlanks+2]};	    opaque => {	      WriteString[", id: "L]; PrintSei[t.id];	      IF t.lengthKnown THEN {WriteString[", size: "L]; WriteDecimal[t.length]}};	    zone => {	      IF t.counted THEN WriteString[" (counted)"L];	      IF t.mds THEN WriteString[" (mds)"L]};	    subrange => {	      WriteString[" of: "L];  PrintType[t.rangeType];	      IF t.filled THEN {		WriteString[" origin: "L];  WriteDecimal[t.origin];		WriteString[", range: "L];  WriteDecimal[t.range]};	      PrintTypeInfo[t.rangeType, nBlanks+2]};	    long, real => {	      WriteString[" of: "L];  PrintType[t.rangeType];	      PrintTypeInfo[t.rangeType, nBlanks+2]};	    ENDCASE};	ENDCASE};  OutCtx: PROC [message: STRING, ctx: CTXIndex] = {    WriteString[message]; WriteString[" ctx: "L];    IF ctx = CTXNull THEN WriteString["NIL"L] ELSE PrintIndex[ctx]};  OutArgType: PROC [message: STRING, sei: CSEIndex] = {    IF sei = SENull THEN {WriteString[message]; WriteString[": NIL"L]}    ELSE      WITH t: syms.seb[sei] SELECT FROM        record => OutCtx[message, t.fieldCtx];	any => {WriteString[message]; WriteString[": ANY"L]};	ENDCASE};  PrintIndex: PROC [v: UNSPECIFIED] = LOOPHOLE[WriteDecimal];  PrintLink: PROC [link: Symbols.DummyLink] = {    WriteString["[gfi: "L]; WriteDecimal[link.gfi];    WriteString[", ep: "L]; WriteDecimal[link.ep];    WriteChar[']]};  PrintVersion: PROC [stamp: BcdDefs.VersionStamp] = {    WriteChar['[];    Format.Date[errPut, [stamp.time], full];    WriteString[" on "L];    WriteOctal[stamp.net]; WriteChar['#];    WriteOctal[stamp.host]; WriteString["#]"L]};  }.
-- Copyright (C) 1981, 1983, 1986  by Xerox Corporation. All rights reserved. -- file Pass3S.mesa-- last modified by Satterthwaite, October 22, 1982 4:20 pm-- last modified by Donahue, 10-Dec-81 11:28:15-- last modified by Sweet,  3-May-83 14:09:50-- Wagner		25-Aug-86 10:08:01DIRECTORY  ComData USING [bodyIndex, idANY, monitored, textIndex, typeBOOL],  CLog USING [Error, ErrorSei, ErrorTree, Warning, WarningTree],  Pass3 USING [checkedANY, lockNode],  P3 USING [    Attr, LhsMode, NPUse, Safety, phraseNP, BoundNP, SequenceNP, voidAttr,    And, Apply, Assignment, BumpCount, CanonicalType, CheckDisjoint, CloseBase,    ClearRefStack, CopyLock, DeclList, DefaultInit, Discrimination,    EnterComposite, EnterType, Exp, Extract, FieldDefault, FindLockParams,    FirstId, IdentifiedType, LockVar, MatchFields, MiscStmt, OpenBase,    OperandLhs, PopCtx, PushCtx, Range, RAttr, RecordMention, Rhs, RPop,    RPush, RType, SealRefStack, TargetType, UnsealRefStack, UpdateTreeAttr,    Voidable, InsertCatchLabel],  P3S USING [BodyData, ImplicitInfo, implicit],  SymLiteralOps USING [DescribeRefLits],  Symbols USING [    ContextLevel,     SEIndex, ISEIndex, CSEIndex, RecordSEIndex, CTXIndex, BTIndex, CBTIndex,    HTNull, SENull, ISENull, CSENull, RecordSENull, CTXNull, BTNull,    lG, RootBti, typeANY],  SymbolOps USING [    CopyBasicType, FirstCtxSe, NextSe, RCType, TransferTypes, UnderType,    FromCard, FromSei, FromTreeIndex],  SymbolTable USING [Handle],  Tree USING [Index, Link, Null, NullId, NullIndex],  TreeOps USING [    FreeNode, GetNode, MakeList, Map, OpName, NthSon, PopTree, PushTree, PushNode,    ReverseScanList, Scan, ScanList, SetAttr, SetInfo, UpdateList,     DecodeBti, DecodeCard, EncodeCard, EncodeSei],  Types USING [Assignable];Pass3S: PROGRAM    IMPORTS      Log: CLog, P3, P3S, SymLiteralOps, SymbolOps, TreeOps, Types,      dataPtr: ComData, passPtr: Pass3    EXPORTS P3, P3S = {  OPEN SymbolOps, Symbols, P3, TreeOps;  syms: SymbolTable.Handle ¬ NIL;    Pass3SInit: PUBLIC PROC [h: SymbolTable.Handle] = { syms ¬ h }; -- parameter usage  pathNP: PUBLIC NPUse ¬ none; -- bodies and blocks  currentBody: PUBLIC P3S.BodyData;  current: LONG POINTER TO P3S.BodyData = @currentBody;  currentScope: PUBLIC BTIndex;  safety: PUBLIC Safety ¬ none;  exits: BOOLEAN;  BodyList: PUBLIC PROC [firstBti: BTIndex] = {    bti: BTIndex ¬ firstBti;    IF bti # BTNull THEN      DO	WITH syms.bb[bti] SELECT FROM	  Callable => IF nesting # Catch THEN Body[LOOPHOLE[bti, CBTIndex]];	  ENDCASE => NULL;	IF syms.bb[bti].link.which = parent THEN EXIT;	bti ¬ syms.bb[bti].link.index;	ENDLOOP};  Body: PROC [bti: CBTIndex] = {    saved: P3S.BodyData = current­;    saveIndex: CARDINAL = dataPtr.textIndex;    saveBodyIndex: CBTIndex = dataPtr.bodyIndex;    saveScope: BTIndex = currentScope;    saveSafety: Safety = safety;    node: Tree.Index;    lockVar: ISEIndex;    lockBit: BOOLEAN;    inRecord, outRecord: RecordSEIndex;    argLevel: ContextLevel;    dataPtr.bodyIndex ¬ currentScope ¬ bti;    dataPtr.textIndex ¬ syms.bb[bti].sourceIndex;    current.bodyNode ¬ node ¬ WITH syms.bb[bti].info SELECT FROM      Internal => bodyTree,      ENDCASE => ERROR;    current.level ¬ syms.bb[bti].level;  current.entry ¬ syms.bb[bti].entry;    SetSafety[SafetyAttr[node]];    syms.bb[bti].resident ¬ FALSE;    current.lockHeld ¬ syms.bb[bti].entry OR syms.bb[bti].internal;    argLevel ¬ IF bti = RootBti THEN lG ELSE current.level;    IF syms.bb[bti].ioType # typeANY THEN syms.seb[syms.bb[bti].ioType].mark4 ¬ FALSE;    [inRecord, outRecord] ¬ TransferTypes[syms, syms.bb[bti].ioType];    IF inRecord = SENull THEN current.argCtx ¬ CTXNull    ELSE {      current.argCtx ¬ syms.seb[inRecord].fieldCtx;      syms.ctxb[current.argCtx].level ¬ argLevel;      IF argLevel = lG THEN EnterTypes[current.argCtx]};    IF outRecord # SENull THEN syms.ctxb[syms.seb[outRecord].fieldCtx].level ¬ argLevel;    PushArgCtx[current.inputRecord ¬ inRecord];  SetArgRefs[inRecord, 1];    PushArgCtx[current.returnRecord ¬ outRecord];  SetArgRefs[outRecord, 0];    ClearRefStack[];    -- initialize computed attributes      current.labelList ¬ Tree.Null;  current.loopDepth ¬ 0;      current.catchDepth ¬ 0;  current.unwindEnabled ¬ FALSE;      current.resumeRecord ¬ RecordSENull;  current.resumeFlag ¬ FALSE;    IF ~current.entry THEN pathNP ¬ none    ELSE {      IF (lockVar ¬ FindLockParams[].actual) # SENull THEN {        lockBit ¬ syms.seb[lockVar].immutable; syms.seb[lockVar].immutable ¬ TRUE};      syms.tb[node].son[4] ¬ CopyLock[];  pathNP ¬ phraseNP};    BEGIN    ENABLE      InsertCatchLabel => {Log.Error[catchLabel]; RESUME};    outInit: Tree.Link ¬ Tree.Null;    ScanList[syms, syms.tb[node].son[1], OpenItem];    current.noXfers ¬ TRUE;    IF inRecord # SENull THEN CheckDisjoint[current.argCtx, syms.bb[bti].localCtx];    IF outRecord # SENull THEN {      CheckDisjoint[syms.seb[outRecord].fieldCtx, syms.bb[bti].localCtx];      outInit ¬ AssignDefaults[syms.seb[outRecord].fieldCtx]};    PushCtx[syms.bb[bti].localCtx];    IF bti = RootBti AND dataPtr.monitored THEN {      ctx: CTXIndex = LOOPHOLE[syms.tb[passPtr.lockNode].info];      PushCtx[ctx];      DeclList[syms, syms.tb[passPtr.lockNode].son[1]];      IF (lockVar ¬ FirstCtxSe[syms, ctx]) # SENull THEN BumpCount[lockVar];      syms.tb[passPtr.lockNode].son[2] ¬ LockVar[syms.tb[passPtr.lockNode].son[2]];      PopCtx[];  ClearRefStack[]};    DeclList[syms, syms.tb[node].son[2]];    IF outInit # Tree.Null THEN {      PushTree[syms, outInit];  PushTree[syms, syms.tb[node].son[2]];      PushNode[syms, initlist, 2];  SetInfo[syms, EncodeCard[dataPtr.textIndex]];      syms.tb[node].son[2] ¬ PopTree[syms]};    END;     IF syms.bb[bti].type # RecordSENull THEN {      IF bti = RootBti THEN SetBodyAttrs[syms.bb[bti].type];      syms.seb[syms.bb[bti].type].mark3 ¬ TRUE};    current.reachable ¬ TRUE;    syms.tb[node].son[3] ¬ UpdateList[syms, syms.tb[node].son[3], Stmt	! InsertCatchLabel => {IF ~catchSeen THEN Log.Error[catchLabel]; RESUME}];    IF current.reachable THEN       syms.tb[node].son[3] ¬ ImpliedReturn[syms, syms.tb[node].son[3]];    BodyList[syms.bb[bti].firstSon];    PopCtx[];    ReverseScanList[syms, syms.tb[node].son[1], CloseItem];    syms.bb[bti].noXfers ¬ current.noXfers;    syms.bb[bti].hints ¬ [	safe: pathNP <= ref,	argUpdated: inRecord # SENull AND syms.ctxb[syms.seb[inRecord].fieldCtx].varUpdated,	nameSafe: pathNP # unsafe,	needsFixup: ];    PopArgCtx[outRecord];  PopArgCtx[inRecord];    IF bti = RootBti AND SymLiteralOps.DescribeRefLits[].length # 0 THEN {      rSei: RecordSEIndex = syms.bb[bti].type;      syms.seb[rSei].hints.refField ¬ TRUE; EnterType[rSei]};    IF current.entry AND lockVar # SENull THEN syms.seb[lockVar].immutable ¬ lockBit;    current­ ¬ saved;  currentScope ¬ saveScope;    SetSafety[saveSafety];    dataPtr.bodyIndex ¬ saveBodyIndex;  dataPtr.textIndex ¬ saveIndex};  Scope: PUBLIC PROC [node: Tree.Index, body: TreeOps.Map] = {    bti: BTIndex = DecodeBti[syms.tb[node].info];    saveIndex: CARDINAL = dataPtr.textIndex;    saveScope: BTIndex = currentScope;    dataPtr.textIndex ¬ syms.bb[bti].sourceIndex;    currentScope ¬ bti;    PushCtx[syms.bb[bti].localCtx];    DeclList[syms, syms.tb[node].son[1] ! InsertCatchLabel => {Log.Error[catchLabel]; RESUME}];    IF syms.bb[bti].type # RecordSENull THEN syms.seb[syms.bb[bti].type].mark3 ¬ TRUE;    syms.tb[node].son[2] ¬ body[syms, syms.tb[node].son[2]];    BodyList[syms.bb[bti].firstSon];    PopCtx[];    currentScope ¬ saveScope;  dataPtr.textIndex ¬ saveIndex};  PushArgCtx: PROC [rSei: RecordSEIndex] = {    IF rSei # SENull THEN PushCtx[syms.seb[rSei].fieldCtx]};  PopArgCtx: PROC [rSei: RecordSEIndex] = {IF rSei # SENull THEN PopCtx[]};  SetArgRefs: PROC [rSei: RecordSEIndex, nRefs: CARDINAL] = {    IF rSei # SENull THEN {      syms.seb[rSei].mark4 ¬ FALSE;      FOR sei: ISEIndex ¬ FirstCtxSe[syms, syms.seb[rSei].fieldCtx], NextSe[syms, sei] UNTIL sei = ISENull DO	IF syms.seb[sei].mark4 THEN {syms.seb[sei].idValue ¬ FromTreeIndex[Tree.NullIndex]; syms.seb[sei].mark4 ¬ FALSE};	syms.seb[sei].idInfo ¬ FromCard[nRefs];	ENDLOOP}};  EnterTypes: PROC [ctx: CTXIndex] = {    FOR sei: ISEIndex ¬ FirstCtxSe[syms, ctx], NextSe[syms, sei] UNTIL sei = ISENull DO      IF RCType[syms, UnderType[syms, syms.seb[sei].idType]] = composite THEN        EnterType[UnderType[syms, syms.seb[sei].idType]];      ENDLOOP};  AssignDefault: PROC [sei: ISEIndex] RETURNS [v: Tree.Link] = {    IF syms.seb[sei].hash = Symbols.HTNull AND ~syms.seb[sei].extended THEN v ¬ Tree.Null    ELSE {      t: Tree.Link =	IF syms.seb[sei].extended THEN FieldDefault[sei] ELSE DefaultInit[syms.seb[sei].idType];      IF t = Tree.Null THEN {	IF ~Voidable[syms.seb[sei].idType] THEN Log.ErrorSei[missingInit, sei];	v ¬ Tree.Null}      ELSE {	lhs: Tree.Link = [symbol[sei]];	mode: LhsMode;	RecordMention[sei];  mode ¬ OperandLhs[lhs];	PushTree[syms, lhs];  PushTree[syms, t];  PushNode[syms, assign, 2];	SetInfo[syms, EncodeCard[dataPtr.textIndex]];  SetAttr[syms, 1, TRUE];	IF mode # counted THEN SetAttr[syms, 2, FALSE]	ELSE {	  type: CSEIndex = UnderType[syms, syms.seb[sei].idType];	  SELECT RCType[syms, type] FROM	    simple => {SetAttr[syms, 2, OpName[syms, t] # nil]; SetAttr[syms, 3, FALSE]};	    composite => {	      SetAttr[syms, 2, TRUE];  SetAttr[syms, 3, TRUE]; EnterComposite[type, t, TRUE]};	    ENDCASE => SetAttr[syms, 2, FALSE]};	v ¬ PopTree[syms]};      RPop[]};    RETURN};  AssignDefaults: PROC [ctx: CTXIndex] RETURNS [Tree.Link] = {    n: INTEGER ¬ 0;    FOR sei: ISEIndex ¬ FirstCtxSe[syms, ctx], NextSe[syms, sei] UNTIL sei = ISENull DO      IF syms.seb[sei].hash # HTNull OR syms.seb[sei].extended THEN {	t: Tree.Link = AssignDefault[sei];	IF t # Tree.Null THEN {	  PushTree[syms, t]; n ¬ n+1; pathNP ¬ SequenceNP[pathNP][phraseNP]; ClearRefStack[]}};      ENDLOOP;    RETURN [MakeList[syms, n]]};  SetBodyAttrs: PROC [rSei: RecordSEIndex] = {    FOR sei: ISEIndex ¬ FirstCtxSe[syms, syms.seb[rSei].fieldCtx], NextSe[syms, sei] UNTIL sei = ISENull DO      IF ~syms.seb[sei].constant AND RCType[syms, UnderType[syms, syms.seb[sei].idType]] # none THEN {	syms.seb[rSei].hints.refField ¬ TRUE; EnterType[rSei]; EXIT}      ENDLOOP};  SafetyAttr: PUBLIC PROC [node: Tree.Index] RETURNS [Safety] = {    RETURN [SELECT TRUE FROM      syms.tb[node].attr1 => checked,      syms.tb[node].attr2 => asserted,      ENDCASE => none]};        SetSafety: PUBLIC PROC [new: Safety] = {    IF safety # new THEN {      SELECT new FROM        checked => {          IF passPtr.checkedANY = CSENull THEN	    passPtr.checkedANY ¬ CopyBasicType[syms, typeANY];	  syms.seb[dataPtr.idANY].idInfo ¬ FromSei[passPtr.checkedANY]};        ENDCASE => syms.seb[dataPtr.idANY].idInfo ¬ FromSei[typeANY];      safety ¬ new}};              -- statements  continued: PUBLIC BOOLEAN;  markCatch: PUBLIC BOOLEAN;    Stmt: PUBLIC PROC [h: SymbolTable.Handle, t: Tree.Link] RETURNS [v: Tree.Link] = {    node: Tree.Index;    saveIndex: CARDINAL = dataPtr.textIndex;    saveMark: BOOLEAN = markCatch;    saveContinued: BOOLEAN = continued;    IF t = Tree.Null THEN RETURN [Tree.Null];    WITH t SELECT FROM      subtree => {	node ¬ index;	dataPtr.textIndex ¬ DecodeCard[syms.tb[node].info];	IF ~current.reachable AND syms.tb[node].name # list THEN {	  Log.Warning[unreachable]; current.reachable ¬ TRUE};	v ¬ t;		-- the default	markCatch ¬ continued ¬ FALSE;	SELECT syms.tb[node].name FROM	  assign => {	    Assignment[node];  RPop[];  pathNP ¬ SequenceNP[pathNP][phraseNP]};	  extract => {	    Extract[node];  RPop[];  pathNP ¬ SequenceNP[pathNP][phraseNP]};	  apply => {	    node ¬ Apply[node, typeANY, TRUE];  v ¬ [subtree[node]];	    SELECT syms.tb[node].name FROM	      wait => Log.ErrorTree[typeClash, syms.tb[node].son[1]];	      error => current.reachable ¬ FALSE;	      ENDCASE;	    SELECT RType[] FROM	      CSENull, typeANY => NULL;	      ENDCASE => Log.Error[nonVoidStmt];	    RPop[];   pathNP ¬ SequenceNP[pathNP][phraseNP]};	  block => {	    saveSafety: Safety = safety;	    SetSafety[SafetyAttr[node]];	    IF saveSafety = checked AND safety = none THEN Log.Error[unsafeBlock];	    Scope[node, Stmt];	    SetSafety[SafetyAttr[node]]};	  if => {	    saveReachable: BOOLEAN;	    entryNP, saveNP: NPUse;	    syms.tb[node].son[1] ¬ Rhs[syms.tb[node].son[1], dataPtr.typeBOOL];  RPop[]; 	    pathNP ¬ entryNP ¬ SequenceNP[pathNP][phraseNP];  ClearRefStack[];	    syms.tb[node].son[2] ¬ UpdateList[syms, syms.tb[node].son[2], Stmt];	    saveReachable ¬ current.reachable;  saveNP ¬ pathNP;	    current.reachable ¬ TRUE;  pathNP ¬ entryNP;	    syms.tb[node].son[3] ¬ UpdateList[syms, syms.tb[node].son[3], Stmt];	    IF saveReachable THEN current.reachable ¬ TRUE;	    pathNP ¬ BoundNP[saveNP][pathNP]};	  case => SelectStmt[node, Case];	  bind => SelectStmt[node, Discrimination];	  do => DoStmt[node];	  label => {	    InsertLabels[syms.tb[node].son[2]];	    syms.tb[node].son[1] ¬ UpdateList[syms, syms.tb[node].son[1], Stmt];	    DeleteLabels[syms.tb[node].son[2]];	    LabelList[syms.tb[node].son[2]]};	  goto => {ValidateLabel[syms.tb[node].son[1]]; current.reachable ¬ FALSE};	  return => Return[node];	  exit, loop => {	    IF syms.tb[node].name = exit THEN exits ¬ TRUE;	    IF current.loopDepth = 0 THEN Log.Error[exit];	    current.reachable ¬ FALSE};	  null => NULL;	  syserror => current.reachable ¬ FALSE;	  open => {	    ScanList[syms, syms.tb[node].son[1], OpenItem];	    syms.tb[node].son[2] ¬ UpdateList[syms, syms.tb[node].son[2], Stmt];	    ReverseScanList[syms, syms.tb[node].son[1], CloseItem]};	  checked => { 	    saveSafety: Safety = safety;	    SetSafety[SafetyAttr[node]];	    IF saveSafety = checked AND safety = none THEN Log.Error[unsafeBlock];	    syms.tb[node].son[1] ¬ Stmt[syms, syms.tb[node].son[1]];	    SetSafety[saveSafety]};          list => v ¬ UpdateList[syms, v, Stmt];          ENDCASE => v ¬ MiscStmt[node]};      ENDCASE => ERROR;    IF markCatch THEN {      PushTree[syms, v];  PushNode[syms, catchmark,1];      SetInfo[syms, EncodeCard[dataPtr.textIndex]];  v ¬ PopTree[syms];      IF continued THEN current.reachable ¬ TRUE;      pathNP ¬ unsafe};    markCatch ¬ saveMark;  continued ¬ saveContinued;    ClearRefStack[];    dataPtr.textIndex ¬ saveIndex;  RETURN}; -- case driver  Case: PUBLIC PROC [node: Tree.Index, selection: TreeOps.Map] = {    OPEN syms.tb[node];    saveImplicit: P3S.ImplicitInfo = P3S.implicit;    entryNP: NPUse;    attr: Attr;    eqTests: BOOLEAN;    CaseItem: TreeOps.Scan = {      switchable: BOOLEAN;      saveIndex: CARDINAL = dataPtr.textIndex;      CaseTest: TreeOps.Map = {	node: Tree.Index = GetNode[syms, t];	  BEGIN  OPEN syms.tb[node];	  SELECT name FROM	    relE => {	      type: CSEIndex;	      son[2] ¬ Rhs[son[2], TargetType[P3S.implicit.type]];	      type ¬ RType[];	      info ¬ EncodeSei[dataPtr.typeBOOL];	      SELECT syms.seb[type].typeTag FROM		long => {attr1 ¬ FALSE; attr2 ¬ TRUE};		real => {attr1 ¬ TRUE; attr2 ¬ FALSE};		ENDCASE => {		  IF OpName[syms, son[2]] = shorten THEN		    Log.ErrorTree[typeClash, NthSon[syms, son[2], 1]];		  attr1 ¬ attr2 ¬ FALSE};	      switchable ¬ switchable AND RAttr[].const;  v ¬ t};	    ENDCASE => {	      v ¬ Rhs[t, dataPtr.typeBOOL]; eqTests ¬ switchable ¬ FALSE};	  attr ¬ And[RAttr[], attr];  RPop[];	  entryNP ¬ SequenceNP[entryNP][phraseNP];	  END;	RETURN};      node: Tree.Index = GetNode[syms, t];      IF OpName[syms, syms.tb[node].son[1]] = decl THEN {	bti: BTIndex = DecodeBti[syms.tb[node].info];	Item: TreeOps.Map = {phraseNP ¬ entryNP; v ¬ selection[syms, t]};	dataPtr.textIndex ¬ syms.bb[bti].sourceIndex;	Log.Error[other];  switchable ¬ FALSE;	Scope[node, Item]}      ELSE {	dataPtr.textIndex ¬ DecodeCard[syms.tb[node].info];	switchable ¬ TRUE;	syms.tb[node].son[1] ¬ UpdateList[syms, syms.tb[node].son[1], CaseTest];	syms.tb[node].attr1 ¬ switchable;	phraseNP ¬ entryNP;  syms.tb[node].son[2] ¬ selection[syms, syms.tb[node].son[2]]};      dataPtr.textIndex ¬ saveIndex};    SealRefStack[];    son[1] ¬ Exp[son[1], typeANY];    P3S.implicit.type ¬ CanonicalType[RType[]];     P3S.implicit.attr ¬ attr ¬ RAttr[];  RPop[];    entryNP ¬ phraseNP;    IF ~IdentifiedType[P3S.implicit.type] THEN Log.ErrorTree[relationType, son[1]];    P3S.implicit.tree ¬ son[1];  eqTests ¬ TRUE;    UnsealRefStack[];    ScanList[syms, son[2], CaseItem];  attr1 ¬ eqTests; attr2 ¬ attr.const;    phraseNP ¬ entryNP;  son[3] ¬ selection[syms, son[3]];    RPush[CSENull, attr];    P3S.implicit ¬ saveImplicit}; -- selection  SelectStmt: PROC [node: Tree.Index, driver: PROC [Tree.Index, TreeOps.Map]] = {    newReachable: BOOLEAN;    newNP: NPUse;    saveNP: NPUse = pathNP;    Selection: TreeOps.Map = {      current.reachable ¬ TRUE;  pathNP ¬ SequenceNP[saveNP][phraseNP];      v ¬ Stmt[syms, t];      IF current.reachable THEN newReachable ¬ TRUE;      newNP ¬ BoundNP[newNP][pathNP]};    newReachable ¬ FALSE;  newNP ¬ none;    driver[node, Selection];  RPop[];    current.reachable ¬ newReachable;  pathNP ¬ newNP}; -- iteration  DoStmt: PROC [node: Tree.Index] = {    OPEN syms.tb[node];    forNode: Tree.Index;    cvType: CSEIndex;    controlled, block, cvUpdate, newReachable, saveExits: BOOLEAN;    saveNP, exitNP: NPUse;    saveScope: BTIndex = currentScope;    newReachable ¬ controlled ¬ block ¬ cvUpdate ¬ FALSE;    IF son[1] # Tree.Null THEN {      sei: ISEIndex;      mode: LhsMode;      forNode ¬ GetNode[syms, son[1]];      IF syms.tb[forNode].son[1] = Tree.Null THEN {        sei ¬ ISENull;  mode ¬ uncounted;  cvType ¬ typeANY}      ELSE {	IF OpName[syms, syms.tb[forNode].son[1]] # decl THEN {	  syms.tb[forNode].son[1] ¬ Exp[syms.tb[forNode].son[1], typeANY];	  IF (mode ¬ OperandLhs[syms.tb[forNode].son[1]]) = none THEN	    Log.ErrorTree[nonLHS, syms.tb[forNode].son[1]];	  sei ¬ WITH syms.tb[forNode].son[1] SELECT FROM symbol => index, ENDCASE => ISENull}	ELSE {	  bti: BTIndex = DecodeBti[syms.tb[forNode].info];	  declNode: Tree.Index = GetNode[syms, syms.tb[forNode].son[1]];	  block ¬ TRUE;  currentScope ¬ bti;	  PushCtx[syms.bb[bti].localCtx];	  DeclList[syms, syms.tb[forNode].son[1]];	  sei ¬ FirstId[declNode];  syms.seb[sei].immutable ¬ TRUE;	  RPush[UnderType[syms, syms.seb[sei].idType], voidAttr];	  mode ¬ IF syms.ctxb[syms.seb[sei].idCtx].level = lG THEN counted ELSE uncounted};	IF sei # ISENull THEN {BumpCount[sei]; BumpCount[sei]}	-- account for implicit refs	ELSE Log.ErrorTree[controlId, syms.tb[forNode].son[1]];	cvType ¬ TargetType[RType[]];  RPop[]};      SELECT mode FROM	counted =>	  SELECT RCType[syms, cvType] FROM	    simple => {syms.tb[forNode].attr2 ¬ TRUE; syms.tb[forNode].attr3 ¬ FALSE};	    composite => syms.tb[forNode].attr2 ¬ syms.tb[forNode].attr3 ¬ TRUE;	    ENDCASE => syms.tb[forNode].attr2 ¬ FALSE;	ENDCASE => syms.tb[forNode].attr2 ¬ FALSE;      SELECT syms.tb[forNode].name FROM	forseq => {	  OPEN seq: syms.tb[forNode];	  seq.son[2] ¬ Rhs[seq.son[2], cvType];  RPop[];	  IF seq.attr2 AND seq.attr3 THEN	    EnterComposite[cvType, seq.son[2], OpName[syms, seq.son[1]] = decl];	  cvUpdate ¬ TRUE};	upthru, downthru => {	  controlled ¬ TRUE;	  syms.tb[forNode].son[2] ¬ Range[syms.tb[forNode].son[2], cvType];	  IF ~Types.Assignable[[syms, cvType], [syms, RType[]]] THEN	    Log.ErrorTree[typeClash, syms.tb[forNode].son[2]];	  RPop[]};	ENDCASE => ERROR;      pathNP ¬ SequenceNP[pathNP][phraseNP];  ClearRefStack[]};    saveNP ¬ pathNP;  pathNP ¬ none;    IF son[2] # Tree.Null THEN {      controlled ¬ TRUE; son[2] ¬ Rhs[son[2], dataPtr.typeBOOL]; RPop[];      pathNP ¬ SequenceNP[pathNP][phraseNP];  ClearRefStack[]};    ScanList[syms, son[3], OpenItem];    InsertLabels[son[5]];    current.loopDepth ¬ current.loopDepth + 1;    saveExits ¬ exits;  exits ¬ FALSE;      son[4] ¬ UpdateList[syms, son[4], Stmt];    IF exits THEN newReachable ¬ TRUE;  exits ¬ saveExits;    DeleteLabels[son[5]];    current.loopDepth ¬ current.loopDepth - 1;    IF cvUpdate THEN {      OPEN seq: syms.tb[forNode];      seq.son[3] ¬ Rhs[seq.son[3], cvType];  RPop[];      IF seq.attr2 AND seq.attr3 THEN EnterComposite[cvType, seq.son[3], FALSE];      pathNP ¬ SequenceNP[pathNP][phraseNP];  ClearRefStack[]};    IF pathNP = refset THEN pathNP ¬ unsafe;    saveNP ¬ pathNP ¬ SequenceNP[saveNP][pathNP];    IF son[5] # Tree.Null THEN {      current.reachable ¬ FALSE;      LabelList[son[5]];  IF current.reachable THEN newReachable ¬ TRUE};    exitNP ¬ pathNP;    IF son[6] # Tree.Null THEN {      current.reachable ¬ controlled;  pathNP ¬ saveNP;      son[6] ¬ UpdateList[syms, son[6], Stmt];      IF current.reachable THEN newReachable ¬ TRUE;      exitNP ¬ BoundNP[exitNP][pathNP]}    ELSE IF controlled THEN newReachable ¬ TRUE;    ReverseScanList[syms, son[3], CloseItem];    current.reachable ¬ newReachable;  pathNP ¬ exitNP;    IF block THEN PopCtx[];    currentScope ¬ saveScope}; -- labels  LabelList: PROC [t: Tree.Link] = {    newReachable: BOOLEAN;    saveNP, newNP: NPUse;    LabelItem: PROC [h: SymbolTable.Handle, t: Tree.Link] = {      node: Tree.Index = GetNode[syms, t];      current.reachable ¬ syms.tb[node].attr1;  pathNP ¬ saveNP;      syms.tb[node].son[2] ¬ UpdateList[syms, syms.tb[node].son[2], Stmt];      IF current.reachable THEN newReachable ¬ TRUE;      newNP ¬ BoundNP[newNP][pathNP]};    newReachable ¬ current.reachable;  saveNP ¬ pathNP;  newNP ¬ none;    ScanList[syms, t, LabelItem];    current.reachable ¬ newReachable;  pathNP ¬ newNP};  InsertLabels: PROC [tree: Tree.Link] = {    labelMark: Tree.Link = current.labelList;    InsertLabel: PROC [h: SymbolTable.Handle, t: Tree.Link] = {      node: Tree.Index = GetNode[syms, t];      saveIndex: CARDINAL = dataPtr.textIndex;      dataPtr.textIndex ¬ DecodeCard[syms.tb[node].info];      ScanList[syms, syms.tb[node].son[1], StackLabel];      dataPtr.textIndex ¬ saveIndex};    StackLabel: PROC [h: SymbolTable.Handle, t: Tree.Link] = {      node: Tree.Index;      FOR tt: Tree.Link ¬ current.labelList, syms.tb[node].son[2] UNTIL tt = labelMark DO	node ¬ GetNode[syms, tt];	IF syms.tb[node].son[1] = t AND t # Tree.NullId THEN 	  Log.ErrorTree[duplicateLabel, t];	ENDLOOP;      PushTree[syms, t];  PushTree[syms, current.labelList];      PushNode[syms, item, 2];  SetAttr[syms, 1, FALSE];        current.labelList ¬ PopTree[syms]};    ScanList[syms, tree, InsertLabel]};  ValidateLabel: PROC [id: Tree.Link] = {    node: Tree.Index;    FOR t: Tree.Link ¬ current.labelList, syms.tb[node].son[2] UNTIL t = Tree.Null DO      node ¬ GetNode[syms, t];      IF syms.tb[node].son[1] = id THEN {syms.tb[node].attr1 ¬ TRUE; RETURN};      ENDLOOP;    Log.ErrorTree[unknownLabel, id]};  DeleteLabels: PROC [t: Tree.Link] = {    anyReachable: BOOLEAN;    DeleteLabel: PROC [h: SymbolTable.Handle, t: Tree.Link] = {      node: Tree.Index = GetNode[syms, t];      saveIndex: CARDINAL = dataPtr.textIndex;      dataPtr.textIndex ¬ DecodeCard[syms.tb[node].info];  anyReachable ¬ FALSE;      ReverseScanList[syms, syms.tb[node].son[1], UnstackLabel];      syms.tb[node].attr1 ¬ anyReachable;      dataPtr.textIndex ¬ saveIndex};    UnstackLabel: PROC [h: SymbolTable.Handle, t: Tree.Link] = {      node: Tree.Index;      node ¬ GetNode[syms, current.labelList];      IF syms.tb[node].attr1 THEN anyReachable ¬ TRUE      ELSE Log.WarningTree[unusedId, syms.tb[node].son[1]];      current.labelList ¬ syms.tb[node].son[2];      syms.tb[node].son[2] ¬ Tree.Null;  FreeNode[syms, node]};    ReverseScanList[syms, t, DeleteLabel]}; -- control transfers  BumpArgRefs: PUBLIC PROC [record: RecordSEIndex, write: BOOLEAN] = {    IF record # SENull THEN      FOR sei: ISEIndex ¬ FirstCtxSe[syms, syms.seb[record].fieldCtx], NextSe[syms, sei] UNTIL sei = SENull DO	IF write THEN BumpCount[sei] ELSE RecordMention[sei];	ENDLOOP};  CheckLocals: PUBLIC PROC [t: Tree.Link] RETURNS [localsOnly: BOOLEAN] = {    level: ContextLevel = syms.bb[dataPtr.bodyIndex].level;    CheckElement: TreeOps.Scan = {      WITH t SELECT FROM	literal => NULL;	symbol => {	  sei: ISEIndex = index;	  IF ~syms.seb[sei].constant AND syms.ctxb[syms.seb[sei].idCtx].level # level THEN localsOnly ¬ FALSE};	ENDCASE => localsOnly ¬ FALSE};    localsOnly ¬ TRUE;  ScanList[syms, t, CheckElement];  RETURN};  Return: PROC [node: Tree.Index] = {    OPEN syms.tb[node];    rSei: RecordSEIndex = current.returnRecord;    IF current.catchDepth # 0 OR (dataPtr.bodyIndex = RootBti AND rSei = SENull) THEN      Log.Error[misplacedReturn];    IF rSei # SENull AND son[1] = Tree.Null THEN {      BumpArgRefs[rSei, FALSE];      FOR sei: ISEIndex ¬ FirstCtxSe[syms, syms.seb[rSei].fieldCtx], NextSe[syms, sei] UNTIL sei = ISENull DO	IF syms.seb[sei].hash = HTNull AND ~syms.seb[sei].extended THEN {Log.Error[illDefinedReturn]; EXIT};	ENDLOOP;      attr2 ¬ TRUE}    ELSE {      son[1] ¬ IF attr3 AND rSei # SENull        THEN Rhs[son[1], rSei]        ELSE MatchFields[rSei, son[1]];      RPop[];      pathNP ¬ SequenceNP[pathNP][phraseNP];      IF current.entry THEN attr2 ¬ CheckLocals[son[1]]};    IF (attr1 ¬ current.entry) THEN {      [] ¬ UpdateTreeAttr[syms.tb[current.bodyNode].son[4]];      pathNP ¬ SequenceNP[pathNP][phraseNP]};    current.reachable ¬ FALSE};  ImpliedReturn: TreeOps.Map = {    IF current.returnRecord # SENull OR current.entry THEN {      PushTree[syms, Tree.Null]; PushNode[syms, return, 1];      SetInfo[syms, EncodeCard[dataPtr.textIndex]];  SetAttr[syms, 3,  FALSE];      PushTree[syms, Stmt[syms, PopTree[syms]]];      PushTree[syms, t];  v ¬ MakeList[syms, -2]}    ELSE v ¬ t;    RETURN}; -- basing  OpenItem: TreeOps.Scan = {    node: Tree.Index = GetNode[syms, t];    saveIndex: CARDINAL = dataPtr.textIndex;    dataPtr.textIndex ¬ DecodeCard[syms.tb[node].info];    WITH syms.tb[node].son[1] SELECT FROM      hash =>	syms.tb[node].son[2] ¬ OpenBase[syms.tb[node].son[2], index	 ! InsertCatchLabel => {Log.Error[catchLabel]; RESUME}];      ENDCASE => ERROR;    ClearRefStack[];    dataPtr.textIndex ¬ saveIndex};  CloseItem: TreeOps.Scan = {    node: Tree.Index = GetNode[syms, t];    WITH syms.tb[node].son[1] SELECT FROM      hash => CloseBase[syms.tb[node].son[2], index];      ENDCASE => ERROR};  }.
-- Copyright (C) 1981, 1984, 1986  by Xerox Corporation. All rights reserved. -- Constructor.mesa-- last modified by Sweet  30-May-84 15:58:53-- last modified by JGS, 19-Nov-81  8:46:02-- last modified by Satterthwaite, September 2, 1982 8:44 am-- MEW		22-Aug-86 10:33:52-- NFS		21-Jan-87 12:52:08DIRECTORY  Alloc USING [Notifier],  Code USING [CodeNotImplemented, curctxlvl],  CodeDefs USING [    BoVarIndex, BYTE, codeType, ConsDestination, LabelCCIndex, Lexeme,    MaxParmsInStack, NullLex, StackLocRec, StoreOptions,    VarComponent, VarIndex, VarNull, wordlength],  ComData USING [ownSymbols, switches, tC0],  Environment USING [bitsPerCharacter],  FOpCodes USING [    qADD, qAF, qBLT, qBLTL, qDSUB, qDUP, qGA, qIOR, qLA,    qLCO, qLI, qLP, qMUL, qREC, qREC2, qSHIFT, qSUB, qWS,    qWSD, qWSDL, qWSF, qWSL, qWSLF],  Inline USING [BITOR, BITSHIFT, LowHalf],  LiteralOps USING [MasterString],  Literals USING [MSTIndex],  P5 USING [    ConstructOnStack, Exp, GenTempLex, MoveToCodeWord,    P5Error, PushRhs, StoreMod, SysCall, WriteCodeWord, ZoneOp],  P5L USING [    AdjustComponent, ComponentForLex, ComponentForSE, CopyToTemp,    CopyVarItem, EasilyLoadable, FieldOfComponent, GenAdd, GenVarItem,     LoadComponent, LoadVar, MakeBo, ModComponent,    OVarItem, ReleaseVarItem,ReusableCopies, TOSAddrLex, TOSLex,    VarForLex, VarVarAssign, Words],  P5U USING [    ComputeFrameSize, FieldAddress, InsertLabel, MakeTreeLiteral, NextVar,    LabelAlloc, OperandType, Out0, Out1, Out2, OutJump, PushLitVal,     RecordConstant, TreeLiteral,    TreeLiteralValue, TypeForTree, WordAligned, WordsForOperand],  PrincOps USING [AVHeapSize, FieldDescriptor, LocalOverhead],  SDDefs USING [sStringInit],  Stack USING [    Also, ComponentForBackup, Decr, Dump, Forget, Incr, Loc, Mark, Pop,    TempStore, Top],  Symbols USING [    Base, ArraySEIndex, BitAddress, ContextLevel, CSEIndex, CTXIndex,     ISEIndex, ISENull, lG, lZ, RecordSEIndex, SEIndex, typeANY],  SymbolOps USING [    BitsPerElement, Cardinality, FirstCtxSe, FnField, NextSe, RecordRoot,    ToBitAddr, ToCard, UnderType, VariantField, WordsForType],  SymbolTable USING [Handle],  Tree USING [Index, Link, NodeName, Null],  TreeOps USING [    DecodeCSei, DecodeSei, FreeNode, GetNode, GetSe, Map, NthSon, OpName,     Scan, ScanList, UpdateList];Constructor: PROGRAM    IMPORTS       MPtr: ComData, CPtr: Code, Inline, LiteralOps,      P5, P5L, P5U, Stack, SymbolOps, TreeOps    EXPORTS CodeDefs, P5 =  BEGIN  OPEN CodeDefs, SymbolOps;  -- imported definitions  ArraySEIndex: TYPE = Symbols.ArraySEIndex;  BitAddress: TYPE = Symbols.BitAddress;  CSEIndex: TYPE = Symbols.CSEIndex;  ISEIndex: TYPE = Symbols.ISEIndex;  ISENull: ISEIndex = Symbols.ISENull;  lG: Symbols.ContextLevel = Symbols.lG;  RecordSEIndex: TYPE = Symbols.RecordSEIndex;  typeANY: CSEIndex = Symbols.typeANY;	-- don't-care type for ConsAssign  cb: Symbols.Base;            -- code base (local copy)  syms: SymbolTable.Handle ¬ NIL;  ConstructorNotify: PUBLIC Alloc.Notifier =    BEGIN  -- called by allocator whenever table area is repacked    syms ¬ MPtr.ownSymbols;    cb ¬ base[codeType];    END;  -- state data and common code for construction  OffsetRef: TYPE = POINTER TO READONLY frame VarComponent;  ConstructionError: SIGNAL = CODE;    CheckOver: PROCEDURE [lc: LONG CARDINAL] RETURNS [CARDINAL] = {    RETURN[IF lc > LAST[CARDINAL] THEN ERROR ELSE CARDINAL[lc]] };  cd: PUBLIC ConsDestination;  SetConsDest: PROC [r: VarIndex, exp: BOOLEAN ¬ FALSE]      RETURNS [rVal: VarIndex ¬ VarNull] =    BEGIN    bor: BoVarIndex;    base: VarComponent;    cd.pGlobAddr ¬ FALSE;    WITH cb[r] SELECT FROM      o => WITH vv: var SELECT FROM	frame =>	  IF vv.level = lG OR vv.level = CPtr.curctxlvl THEN	    BEGIN	    cd.bd ¬ vv.bd;  cd.fOffset ¬ vv.wd;  cd.fLevel ¬ vv.level;	    cd.inFrame ¬ TRUE; cd.pGlobAddr ¬ vv.level = lG AND ~MPtr.switches['o];	    cd.wSize ¬ vv.wSize;  cd.bSize ¬ vv.bSize;	    IF exp THEN rVal ¬ r ELSE P5L.ReleaseVarItem[r];	    RETURN	    END;	frameup, linkup => NULL;	ENDCASE => ERROR;      bo, bdo, ind => NULL;      ENDCASE => ERROR;    bor ¬ P5L.MakeBo[r];    IF bor = VarNull THEN SIGNAL ConstructionError; -- should be caught above    IF exp THEN       BEGIN      r1: VarIndex;      [first: r1, next: rVal] ¬ P5L.ReusableCopies[bor, store, FALSE];      bor ¬ P5L.MakeBo[r1];      END;    BEGIN    offset: VarComponent = cb[bor].offset;    WITH vv: offset SELECT FROM      frame =>	BEGIN	cd.bd ¬ vv.bd;	cd.pDelta ¬ -INTEGER[vv.wd];	cd.wSize ¬ vv.wSize;  cd.bSize ¬ vv.bSize;	END;      ENDCASE => ERROR;    base ¬ cb[bor].base;    P5L.ReleaseVarItem[bor]; -- we're finished with it now    WITH vv: base SELECT FROM      frame =>	BEGIN	IF vv.bSize # 0 OR ~(vv.level = lG OR vv.level = CPtr.curctxlvl) THEN	  GO TO loadIt;	cd.pBackup ¬ [frame[tOffset: vv.wd, tLevel: vv.level]];	cd.pLength ¬ vv.wSize;	END;      faddr =>	BEGIN	IF ~((vv.level = lG AND MPtr.switches['o]) OR vv.level = CPtr.curctxlvl) THEN	  GO TO loadIt;	cd.pBackup ¬ [faddr[tOffset: vv.wd, tLevel: vv.level]];	cd.pLength ¬ vv.wSize;	END;    <<  link => {cd.pBackup ¬ [link[vv.wd]]; cd.pLength ¬ 2}; >>      const => IF vv.wSize # 1 THEN GO TO loadIt         ELSE {cd.pBackup ¬ [const[vv.d1]]; cd.pLength ¬ 1};      ENDCASE => GO TO loadIt;    EXITS      loadIt =>	BEGIN	wS: CARDINAL = P5L.Words[base.wSize, base.bSize];	P5L.LoadComponent[base];	cd.pSti ¬ Stack.Top[wS];	Stack.Also[n: wS, place: [none[]]]; --forget	cd.pLoaded ¬ TRUE;  cd.pLength ¬ wS;	END;    END;    END;        GetPointer: PROC [owd: CARDINAL]       RETURNS [aVar: VarComponent, newOwd: CARDINAL] =    BEGIN -- exit invariant: cd.pLoaded => newOwd + cd.pDelta = owd    SELECT TRUE FROM      cd.pLoaded => 	IF cd.inFrame AND INTEGER[owd] < cd.pDelta AND (cd.fOffset+owd) IN BYTE THEN	  BEGIN	  PopPointer[];	  cd.pBackup ¬ [none[]];	  cd.pDelta ¬ owd; newOwd ¬ 0;	  aVar ¬ IF cd.pGlobAddr THEN	      [wSize: 2, space: lfaddr[wd: cd.fOffset+owd, level: cd.fLevel, op: lengthen]]	    ELSE	      [wSize: 1, space: faddr[wd: cd.fOffset+owd, level: cd.fLevel]];	  END	ELSE aVar ¬ [wSize: cd.pLength, space: stack[sti: cd.pSti]];      cd.inFrame AND cd.pGlobAddr AND ~MPtr.switches['o] =>         BEGIN        aVar ¬ [wSize: 2, space: 	  lfaddr[wd: cd.fOffset+owd, level: cd.fLevel, op: pad «ignored»]];        cd.pLength ¬ 2;  cd.pDelta ¬ owd; -- to be right if loaded	newOwd ¬ 0;	cd.pBackup ¬ [faddr[tOffset: cd.fOffset+owd, tLevel: cd.fLevel]];	RETURN        END;      cd.inFrame =>         BEGIN        aVar ¬ [wSize: 1, space: faddr[wd: cd.fOffset+owd, level: cd.fLevel]];        cd.pLength ¬ 1;  cd.pDelta ¬ owd; -- to be right if loaded	newOwd ¬ 0;	cd.pBackup ¬ [faddr[tOffset: cd.fOffset+owd, tLevel: cd.fLevel]];	RETURN        END;      ENDCASE => {        -- guaranteed not to be long gf address        aVar ¬ Stack.ComponentForBackup[cd.pBackup];	aVar.wSize ¬ cd.pLength};    IF INTEGER[owd] IN [cd.pDelta .. cd.pDelta + LAST[BYTE]] THEN      newOwd ¬ CARDINAL[INTEGER[owd] - cd.pDelta]    ELSE      BEGIN      P5L.LoadComponent[aVar];      IF INTEGER[owd] > cd.pDelta THEN	P5L.GenAdd[INTEGER[owd] - cd.pDelta, cd.pLength # 1]      ELSE	BEGIN	P5U.Out1[FOpCodes.qLI, CARDINAL[cd.pDelta] - owd];	IF cd.pLength # 1 THEN	  {P5U.Out1[FOpCodes.qLI, 0]; P5U.Out0[FOpCodes.qDSUB]}	ELSE P5U.Out0[FOpCodes.qSUB];	END;      cd.pDelta ¬ owd;      cd.pSti ¬ Stack.Top[cd.pLength];      newOwd ¬ 0; cd.pBackup ¬ [none[]];      aVar ¬ [wSize: cd.pLength, space: stack[sti: cd.pSti]];      cd.pLoaded ¬ TRUE;      END;    END;    LoadPointer: PROC [owd: CARDINAL] RETURNS [newOwd: CARDINAL] =    BEGIN    aVar: VarComponent;    [aVar, newOwd] ¬ GetPointer[owd];    P5L.LoadComponent[aVar];    cd.pSti ¬ Stack.Top[cd.pLength];    cd.pLoaded ¬ TRUE;    END;      DumpPointer: PROC =    BEGIN    IF cd.pLoaded THEN      BEGIN      IF cd.pBackup.where # none OR cd.inFrame THEN Stack.Pop[cd.pLength]      ELSE	BEGIN	aVar: VarComponent = Stack.TempStore[cd.pLength];	SetCDBackup[aVar];	END;      cd.pLoaded ¬ FALSE;      END;    END;  SavePointer: PROC =    BEGIN    IF cd.pLoaded AND cd.remaining # 0 AND cd.pBackup.where = none THEN      BEGIN      aVar: VarComponent = Stack.TempStore[cd.pLength];      SetCDBackup[aVar];      P5L.LoadComponent[aVar];      END;    END;        PopPointer: PROC =    BEGIN    IF cd.pLoaded THEN Stack.Pop[cd.pLength];    cd.pLoaded ¬ FALSE;    END;      ConsAssign: PROC [type: CSEIndex, atO: OffsetRef, t: Tree.Link, l: Lexeme ¬ NullLex] =    BEGIN    dest: VarIndex;    source: VarIndex;    offset: frame VarComponent ¬ atO­;    useFrame: BOOLEAN = cd.inFrame AND offset.wSize IN [1..2] AND      offset.bSize = 0 AND (cd.fOffset+offset.wd) IN BYTE;    useSwapped: BOOLEAN = ~useFrame  AND      (offset.wSize = 0 OR (offset.bSize = 0 AND offset.wSize IN [1..2]));    offset.bd ¬ offset.bd + cd.bd;    IF cd.pLoaded THEN      SELECT TRUE FROM	useFrame => PopPointer[];	~useSwapped => DumpPointer[];	ENDCASE;    IF useSwapped THEN offset.wd ¬ LoadPointer[offset.wd];    source ¬ P5L.VarForLex[IF l # NullLex      THEN l      ELSE P5.Exp[IF offset.wSize = 0 AND TreeOps.OpName[syms, t] = mod 	THEN P5.StoreMod[t, offset.bSize] ELSE t]];    IF useSwapped THEN      BEGIN      base: VarComponent;      loc: StackLocRec;      P5L.LoadVar[source];      loc ¬ Stack.Loc[cd.pSti];      WITH ll: loc SELECT FROM	onStack =>	  BEGIN	  WSOp: ARRAY [1..2] OF ARRAY [1..2] OF BYTE = [	    [FOpCodes.qWS, FOpCodes.qWSD], [FOpCodes.qWSL, FOpCodes.qWSDL]];	  WSFOp: ARRAY [1..2] OF BYTE = [FOpCodes.qWSF, FOpCodes.qWSLF]; 	  RecOp: ARRAY [1..2] OF BYTE = [FOpCodes.qREC, FOpCodes.qREC2];	  IF offset.bSize = 0 THEN	    P5U.Out1[WSOp[cd.pLength][offset.wSize], offset.wd]	  ELSE P5U.Out2[WSFOp[cd.pLength], offset.wd,	    LOOPHOLE[ PrincOps.FieldDescriptor[	      offset: 0, posn: offset.bd, size: offset.bSize]]];	  IF cd.remaining # 0 THEN	    BEGIN	    P5U.Out0[RecOp[cd.pLength]];	    cd.pSti ¬ Stack.Top[cd.pLength];	     IF ~cd.pGlobAddr OR MPtr.switches['o] THEN	       Stack.Also[n: cd.pLength, place: cd.pBackup];	    END	  ELSE cd.pLoaded ¬ FALSE;	  RETURN	  END;	contig =>	  BEGIN	  cd.pBackup ¬ ll.place;	  WITH bb: ll.place SELECT FROM	    frame => base ¬ [wSize: cd.pLength, space: 	      frame[wd: bb.tOffset, level: bb.tLevel, immutable: TRUE]];	  <<  link => base ¬ [wSize: 2, space: link[bb.link]]; >>	    const => base ¬ [wSize: 1, space: const[bb.value]];	    faddr => base ¬ [wSize: cd.pLength, space: 	      faddr[wd: bb.tOffset, level: bb.tLevel]];	    ENDCASE => ERROR;	  END;	ENDCASE => ERROR;      -- would have used swap but pointer got dumped when evaluating field      Stack.Forget[cd.pSti, cd.pLength];      cd.pLoaded ¬ FALSE;      source ¬ P5L.VarForLex[P5L.TOSLex[P5L.Words[offset.wSize, offset.bSize]]];      dest ¬ P5L.GenVarItem[bo];      cb[dest] ¬ [body: bo[base: base, offset: offset]];      END    ELSE IF useFrame THEN      BEGIN      offset.wd ¬ offset.wd + cd.fOffset;      offset.level ¬ cd.fLevel;      dest ¬ P5L.OVarItem[offset];      END    ELSE      BEGIN      base: VarComponent;      [base, offset.wd] ¬ GetPointer[offset.wd];      IF cd.pLoaded AND cd.remaining # 0 THEN {        DumpPointer[];	-- guaranteed not to be a long gf address	base ¬ Stack.ComponentForBackup[cd.pBackup, cd.pLength]};      dest ¬ P5L.GenVarItem[bo];      cb[dest] ¬ [body: bo[base: base, offset: offset]];      END;    [] ¬ P5L.VarVarAssign[to: dest, from: source, isexp: FALSE];    cd.pLoaded ¬ FALSE;    END;  VanillaCons: PROC [t: Tree.Link] RETURNS [vanilla: BOOLEAN ¬ TRUE] =    BEGIN    CheckItem: TreeOps.Scan =      BEGIN      SELECT TreeOps.OpName[syms, t] FROM	rowcons, construct, all, union => vanilla ¬ FALSE;	cast, pad => CheckItem[syms, TreeOps.NthSon[syms, t, 1]];	ENDCASE => NULL;      END;    TreeOps.ScanList[syms, t, CheckItem];  RETURN    END;  CountDups: TreeOps.Map =    BEGIN    v ¬ t;	-- normal case (see safen)    IF t # Tree.Null THEN WITH t SELECT FROM      subtree =>        BEGIN        node: Tree.Index = index;        SELECT syms.tb[node].name FROM          rowcons, construct =>	    -- NFS: test for 'o switch matches test in procedure Row.	    IF syms.tb[node].name = rowcons AND syms.tb[node].attr1 AND	      MPtr.switches['o] THEN	        cd.remaining ¬ cd.remaining+1	    ELSE syms.tb[node].son[2] ¬ 	      TreeOps.UpdateList[syms, syms.tb[node].son[2], CountDups];	  all =>            BEGIN	    aSei: Symbols.ArraySEIndex = LOOPHOLE[syms.tb[node].info];	    IF BitsPerElement[syms, syms.seb[aSei].componentType, syms.seb[aSei].packed] < wordlength	     AND syms.tb[node].son[1] # Tree.Null THEN	      cd.remaining ¬ cd.remaining+1            ELSE syms.tb[node].son[1] ¬ CountDups[syms, syms.tb[node].son[1]];            END;          union =>            BEGIN            IF syms.tb[node].attr2 THEN cd.remaining ¬ cd.remaining+1;            syms.tb[node].son[2] ¬ TreeOps.UpdateList[syms, syms.tb[node].son[2], CountDups];            END;          cast, pad =>            syms.tb[node].son[1] ¬ CountDups[syms, syms.tb[node].son[1]];	  safen => 	    IF cd.ignoreSafen THEN              BEGIN              v ¬ CountDups[syms, syms.tb[node].son[1]];              syms.tb[node].son[1] ¬ Tree.Null;  TreeOps.FreeNode[syms, node];              END            ELSE              BEGIN	      r: VarIndex = P5L.VarForLex[P5.Exp[syms.tb[node].son[1]]];	      sei: ISEIndex = P5L.CopyToTemp[r].sei;	      syms.seb[sei].idType ¬ TreeOps.DecodeSei[syms.tb[node].info];	      v ¬ [symbol[sei]];	      cd.remaining ¬ cd.remaining+1;	      TreeOps.FreeNode[syms, node];              END;          ENDCASE => cd.remaining ¬ cd.remaining+1;        END;      ENDCASE => cd.remaining ¬ cd.remaining+1;    RETURN    END;  ConstructCountDown: PROC =    BEGIN    IF cd.remaining = 0 THEN SIGNAL ConstructionError;    cd.remaining ¬ cd.remaining - 1;    END;  ConstantFill: PROC [type: CSEIndex, atO: OffsetRef, t: Tree.Link] =    BEGIN    ConstructCountDown[]; --   SELECT TRUE FROM  --    MPtr.switches['m] AND cd.pLength = 2 AND  --     P5.MultiZero[t] AND ~CountedAssign[type, TRUE] =>--	FillZeros[atO, P5L.Words[atO.wSize, atO.bSize]];      -- test for other special cases here  --    ENDCASE =>         ConsAssign[type, atO, t];    END;      FillZeros: PROC [atO: OffsetRef, nwords: CARDINAL] =    BEGIN    offset: frame VarComponent ¬ atO­;    loc: StackLocRec;--    [] ¬ LoadPointer[offset.wd, 0];    loc ¬ Stack.Loc[cd.pSti];    WITH ll: loc SELECT FROM      onStack =>	BEGIN	IF cd.pLength # 2 THEN	  BEGIN	  SavePointer[];	  P5U.Out0[FOpCodes.qLP];	  END;	P5U.PushLitVal[nwords];--	P5U.Out0[FOpCodes.qBLZL];	IF cd.remaining # 0 AND cd.pLength = 2 THEN	  BEGIN	  cd.pSti ¬ Stack.Top[cd.pLength];	  IF ~cd.pGlobAddr OR MPtr.switches['o] THEN	    Stack.Also[n: cd.pLength, place: cd.pBackup];	  END	ELSE {Stack.Pop[2]; cd.pLoaded ¬ FALSE};	END;      ENDCASE => ERROR;    END;     -- main drivers  MainConstruct: PROC [	maint: Tree.Link,	rSei: CSEIndex,        fa: PROC [SymbolTable.Handle, ISEIndex] RETURNS [BitAddress, CARDINAL],	atO: OffsetRef,        fieldSei: ISEIndex ¬ ISENull] =    BEGIN -- workhorse subroutine for construction in memory    tOffset: frame VarComponent = atO­;    totalBits: CARDINAL = tOffset.wSize*wordlength + tOffset.bSize;    rcSei: RecordSEIndex;    AssignField: PROC [h: SymbolTable.Handle, t: Tree.Link] =      BEGIN      offset: frame VarComponent;      rep: BitAddress;      res: CARDINAL;      fieldType: CSEIndex = UnderType[syms, syms.seb[fieldSei].idType];      IF t # Tree.Null THEN        BEGIN        [rep, res] ¬ fa[syms, fieldSei];        offset ¬ tOffset;        P5L.FieldOfComponent[var: @offset, wd: rep.wd, bd: rep.bd,          wSize: res/wordlength, bSize: res MOD wordlength];        IF fa # FnField AND totalBits <= wordlength THEN          P5L.AdjustComponent[            var: @offset, rSei: rcSei, fSei: fieldSei, tBits: totalBits];        DO -- until we get to something interesting          SELECT TreeOps.OpName[syms, t] FROM	    pad =>	      BEGIN	      t ¬ TreeOps.NthSon[syms, t, 1];	      offset.wSize ¬ P5U.WordsForOperand[t]; offset.bSize ¬ 0;	      END;	    cast => t ¬ TreeOps.NthSon[syms, t, 1];	    ENDCASE => EXIT;          ENDLOOP;        SELECT TreeOps.OpName[syms, t] FROM          construct =>	    MainConstruct[	      TreeOps.NthSon[syms, t, 2], P5U.OperandType[t], P5U.FieldAddress, @offset];          union => UnionConstruct[TreeOps.GetNode[syms, t], rcSei, atO];          rowcons => Row[TreeOps.GetNode[syms, t], @offset];          all => [] ¬ AllConstruct[TreeOps.GetNode[syms, t], @offset];          mwconst => ConstantFill[fieldType, @offset, t];          ENDCASE => {ConstructCountDown[]; ConsAssign[fieldType, @offset, t]};	END; -- IF t # Tree.Null      fieldSei ¬ P5U.NextVar[NextSe[syms, fieldSei]];      END; -- of AssignField    IF fieldSei = ISENull THEN      WITH syms.seb[rSei] SELECT FROM        record =>          BEGIN          rcSei ¬ RecordRoot[syms, LOOPHOLE[rSei]];          fieldSei ¬ P5U.NextVar[FirstCtxSe[syms, syms.seb[rcSei].fieldCtx]];          END;        ENDCASE => P5.P5Error[589]    ELSE rcSei ¬ LOOPHOLE[rSei];    TreeOps.ScanList[syms, maint, AssignField];    END; -- of MainConstruct  Row: PROC [node: Tree.Index, atO: OffsetRef] =    BEGIN  -- handles ARRAY construction    aSei: ArraySEIndex = LOOPHOLE[syms.tb[node].info];    IF syms.seb[aSei].typeTag # array THEN P5.P5Error[580];    IF syms.tb[node].attr1 AND MPtr.switches['o] THEN      BEGIN	-- row of string literals      c: CARDINAL = P5.MoveToCodeWord[];      n: CARDINAL ¬ 0;      localText, globalText: BOOLEAN ¬ FALSE;      delta: CARDINAL;      TextItem: PROC [h: SymbolTable.Handle, t: Tree.Link] =        BEGIN        WITH e:t SELECT FROM          literal =>            WITH e.info SELECT FROM              string =>                BEGIN                msti: Literals.MSTIndex = LiteralOps.MasterString[syms, index];                IF syms.stb[msti].local THEN localText ¬ TRUE ELSE globalText ¬ TRUE;                P5.WriteCodeWord[syms.stb[msti].info];                END;              ENDCASE => P5.P5Error[577];          ENDCASE => P5.P5Error[578];        n ¬ n+1;        END;      IF cd.pLoaded THEN {SavePointer[]; PopPointer[]};      TreeOps.ScanList[syms, syms.tb[node].son[2], TextItem];      ConstructCountDown[];      Stack.Dump[]; Stack.Mark[];      P5U.Out1[FOpCodes.qLCO, c];  P5U.PushLitVal[n];      P5U.RecordConstant[c, n];      IF localText AND globalText OR cd.remaining # 0 AND ~cd.inFrame THEN	SIGNAL CPtr.CodeNotImplemented;      P5U.Out1[IF localText THEN FOpCodes.qLA ELSE FOpCodes.qGA, 0];      delta ¬ LoadPointer[atO.wd];      IF cd.pLength # 1 THEN -- does a long pointer to array of short strings        SIGNAL CPtr.CodeNotImplemented; -- make any sense?      IF delta # 0 THEN P5L.GenAdd[delta];      P5.SysCall[SDDefs.sStringInit];      cd.pLoaded ¬ FALSE;      END    ELSE      BEGIN  -- not all string literals      offset: frame VarComponent ¬ atO­;      eWSize: CARDINAL;      eBSize: [0..wordlength);      cSei: CSEIndex = UnderType[syms, syms.seb[aSei].componentType];      AssignElement: PROC [h: SymbolTable.Handle, t: Tree.Link] =	BEGIN	DO -- until we get to something interesting	  SELECT TreeOps.OpName[syms, t] FROM	    pad =>	      BEGIN	      t ¬ TreeOps.NthSon[syms, t, 1];	      offset.wSize ¬ P5U.WordsForOperand[t]; offset.bSize ¬ 0;	      END;	    cast => t ¬ TreeOps.NthSon[syms, t, 1];	    ENDCASE => EXIT;          ENDLOOP;	SELECT TreeOps.OpName[syms, t] FROM          rowcons => Row[TreeOps.GetNode[syms, t], @offset];          construct =>	    MainConstruct[	      TreeOps.NthSon[syms, t, 2], P5U.OperandType[t], P5U.FieldAddress, @offset];          all => -- convert this later	    [] ¬ AllConstruct[TreeOps.GetNode[syms, t], @offset];          mwconst => ConstantFill[cSei, @offset, t];          ENDCASE =>	    IF t # Tree.Null THEN {ConstructCountDown[]; ConsAssign[cSei, @offset, t]};	P5L.ModComponent[var: @offset, wd: eWSize, bd: offset.bSize];	offset.wSize ¬ eWSize;  offset.bSize ¬ eBSize;	END; -- of AssignElement      totalBits: CARDINAL = atO.wSize*wordlength + atO.bSize;        -- totalBits could overflow, but that would be a very large constructor      grain: CARDINAL = CheckOver[        BitsPerElement[syms, syms.seb[aSei].componentType, syms.seb[aSei].packed]];      packed: BOOLEAN;      fillBits: CARDINAL;      IF grain >= wordlength THEN	BEGIN	packed ¬ FALSE;  fillBits ¬ 0;	eBSize ¬ 0; eWSize ¬ CheckOver[WordsForType[syms, syms.seb[aSei].componentType]];	END      ELSE	BEGIN	packed ¬ TRUE;	fillBits ¬ totalBits - CheckOver[	  Cardinality[syms, UnderType[syms, syms.seb[aSei].indexType]]*grain];	IF fillBits # 0 AND totalBits > wordlength THEN 	  cd.remaining ¬ cd.remaining+1;	eWSize ¬ 0; eBSize ¬ grain;	END;      IF fillBits # 0 AND totalBits <= wordlength THEN 	BEGIN	bs: CARDINAL = eBSize + fillBits;	offset.wSize ¬ bs / wordlength;	offset.bSize ¬ bs MOD wordlength;	fillBits ¬ 0;	END      ELSE {offset.wSize ¬ eWSize; offset.bSize ¬ eBSize};      TreeOps.ScanList[syms, syms.tb[node].son[2], AssignElement];      IF fillBits # 0 THEN	BEGIN	offset.wSize ¬ 0;  offset.bSize ¬ fillBits;	ConstructCountDown[];  ConsAssign[typeANY, @offset, MPtr.tC0];	END;      END;    END;  UnionConstruct: PROC [node: Tree.Index, rootSei: RecordSEIndex, atO: OffsetRef] =    BEGIN -- construct a union part, atO­ is offset of beginning of record    tOffset: frame VarComponent = atO­;    offset: frame VarComponent ¬ atO­;    fieldSei: ISEIndex;    vCtx: Symbols.CTXIndex;    uSei: CSEIndex = TreeOps.DecodeCSei[syms.tb[node].info];    rcSei: RecordSEIndex;    tSei: ISEIndex;    tagged: BOOLEAN;    tagValue: CARDINAL;    tBits: CARDINAL = tOffset.wSize*wordlength + tOffset.bSize;    WITH u: syms.seb[uSei] SELECT FROM      union =>	BEGIN	tagged ¬ u.controlled;	IF tagged THEN          BEGIN	  tagAddr: BitAddress = ToBitAddr[syms.seb[u.tagSei].idValue];	  tagSize: [0..wordlength] = ToCard[syms.seb[u.tagSei].idInfo];	  P5L.FieldOfComponent[	    var: @offset, wd: tagAddr.wd, bd: tagAddr.bd,	    wSize: tagSize/wordlength, bSize: tagSize MOD wordlength];          IF tBits <= wordlength THEN            P5L.AdjustComponent[var: @offset, rSei: rootSei, fSei: u.tagSei, tBits: tBits];	  END;	END;      ENDCASE => ERROR;    tSei ¬ TreeOps.GetSe[syms, syms.tb[node].son[1]];    tagValue ¬ ToCard[syms.seb[tSei].idValue];    rcSei ¬ LOOPHOLE[UnderType[syms, tSei], RecordSEIndex];    vCtx ¬ syms.seb[rcSei].fieldCtx;    fieldSei ¬ P5U.NextVar[FirstCtxSe[syms, vCtx]];    IF tagged THEN      BEGIN      IF fieldSei # ISENull AND syms.seb[fieldSei].idCtx # vCtx THEN        BEGIN -- a dummy fill field        fillSize: [0..wordlength) = ToCard[syms.seb[fieldSei].idInfo];	b: CARDINAL = offset.bSize + fillSize;        tagValue ¬ Inline.BITSHIFT[tagValue, fillSize];        offset.bSize ¬ b MOD wordlength;  offset.wSize ¬ b/wordlength;        fieldSei ¬ P5U.NextVar[NextSe[syms, fieldSei]];        END;      ConstructCountDown[];      ConsAssign[typeANY, @offset, P5U.MakeTreeLiteral[tagValue]];      END    ELSE IF fieldSei # ISENull AND syms.seb[fieldSei].idCtx # vCtx THEN      BEGIN -- no tag, but a fill field anyway      fillSize: [0..wordlength) = ToCard[syms.seb[fieldSei].idInfo];      fillAddr: BitAddress = ToBitAddr[syms.seb[fieldSei].idValue]; -- can't be full word      P5L.FieldOfComponent[	var: @offset, wd: fillAddr.wd, bd: fillAddr.bd, bSize: fillSize];      IF tBits <= wordlength THEN	P5L.AdjustComponent[var: @offset, rSei: rootSei, fSei: fieldSei, tBits: tBits];      ConsAssign[typeANY, @offset, MPtr.tC0];      fieldSei ¬ P5U.NextVar[NextSe[syms, fieldSei]];      END;    IF fieldSei # ISENull THEN      MainConstruct[syms.tb[node].son[2], rootSei, P5U.FieldAddress, atO, fieldSei];    END;  AllConstruct: PROC [node: Tree.Index, atO: OffsetRef, replCount: CARDINAL ¬ 1]       RETURNS [wordsFilled: CARDINAL] =    BEGIN	-- reexamine when packed arrays of packed arrays    aSei: ArraySEIndex = LOOPHOLE[syms.tb[node].info];    tOffset: frame VarComponent = atO­;    offset: frame VarComponent ¬ atO­;    csei: CSEIndex = UnderType[syms, syms.seb[aSei].componentType];    eWSize: CARDINAL;    eBSize: [0..wordlength);    t1: Tree.Link ¬ syms.tb[node].son[1];    totalBits: LONG CARDINAL = tOffset.wSize*wordlength + tOffset.bSize;      -- totalBits could overflow, should probably use LONG CARD    grain: CARDINAL = CheckOver[      BitsPerElement[syms, syms.seb[aSei].componentType, syms.seb[aSei].packed]];    packed: BOOLEAN;    fillBits, eCount: CARDINAL;    e2Offset: CARDINAL;    wordsFilled ¬ P5L.Words[tOffset.wSize, tOffset.bSize];    IF grain >= wordlength THEN      BEGIN      packed ¬ FALSE;  fillBits ¬ 0;      eBSize ¬ 0; eWSize ¬ CheckOver[WordsForType[syms, syms.seb[aSei].componentType]];      END    ELSE      BEGIN      packed ¬ TRUE;      eCount ¬ CheckOver[Cardinality[syms, UnderType[syms, syms.seb[aSei].indexType]]];      fillBits ¬ Inline.LowHalf[totalBits - eCount*grain];      IF fillBits # 0 AND totalBits > wordlength THEN	cd.remaining ¬ cd.remaining+1;      eWSize ¬ 0; eBSize ¬ grain;      END;    offset.wSize ¬ eWSize; offset.bSize ¬ eBSize;    IF fillBits # 0 AND totalBits <= wordlength THEN       BEGIN      bs: CARDINAL = eBSize + fillBits;      offset.wSize ¬ bs / wordlength;      offset.bSize ¬ bs MOD wordlength;      fillBits ¬ 0;      END;    IF fillBits = 0 THEN wordsFilled ¬ wordsFilled * replCount;    IF t1 = Tree.Null THEN RETURN;    DO -- until we get to something interesting      SELECT TreeOps.OpName[syms, t1] FROM	pad =>	  BEGIN	  t1 ¬ TreeOps.NthSon[syms, t1, 1];	  offset.wSize ¬ P5U.WordsForOperand[t1]; offset.bSize ¬ 0;	  END;	cast => t1 ¬ TreeOps.NthSon[syms, t1, 1];	ENDCASE => EXIT;      ENDLOOP;    IF packed THEN      BEGIN      ePerWord: CARDINAL = wordlength/grain;      fold: BOOLEAN = P5U.TreeLiteral[t1];      v: WORD;      IF cd.pLoaded AND ~fold THEN DumpPointer[];      SELECT TRUE FROM	fold => v ¬ P5U.TreeLiteralValue[t1];	(grain = 1) => {v ¬ 1; P5.PushRhs[syms, t1]};	ENDCASE => P5.PushRhs[syms, t1];      THROUGH (0..MIN[ePerWord, eCount]) DO        IF fold OR grain = 1 THEN v ¬ Inline.BITOR[Inline.BITSHIFT[v, grain], v]        ELSE	  BEGIN	  P5U.Out0[FOpCodes.qDUP];	  P5U.PushLitVal[grain];  P5U.Out0[FOpCodes.qSHIFT];	  P5U.Out0[FOpCodes.qIOR];	  END;     	ENDLOOP;      SELECT TRUE FROM	fold => NULL;	(grain = 1) =>	  BEGIN	  tlabel: LabelCCIndex = P5U.LabelAlloc[];	  elabel: LabelCCIndex = P5U.LabelAlloc[];	  P5U.PushLitVal[0];  P5U.OutJump[JumpE, tlabel];	  P5U.PushLitVal[v];  P5U.OutJump[Jump, elabel];	  P5U.InsertLabel[tlabel];	  Stack.Decr[1];  P5U.Out0[FOpCodes.qREC];	  P5U.InsertLabel[elabel];	  END;	ENDCASE => NULL;      IF totalBits < wordlength THEN {        offset.wSize ¬ 0; offset.bSize ¬ Inline.LowHalf[totalBits]}      ELSE {offset.wSize ¬ 1; offset.bSize ¬ 0};      IF fold THEN ConsAssign[typeANY, @offset, P5U.MakeTreeLiteral[v]]       ELSE ConsAssign[typeANY, @offset, Tree.Null, P5L.TOSLex[1]];      P5L.ModComponent[var: @offset,	bd: IF eCount > ePerWord THEN wordlength ELSE offset.bSize];      IF wordsFilled <= 1 THEN -- all in one word case	BEGIN	ConstructCountDown[];	IF cd.remaining = 0 THEN PopPointer[];	END;      e2Offset ¬ 1;      END    ELSE IF TreeOps.OpName[syms, t1] = all THEN      BEGIN  -- ~packed, set all elements in recursive call      eCount ¬ CheckOver[Cardinality[syms, UnderType[syms, syms.seb[aSei].indexType]]];      e2Offset ¬ AllConstruct[TreeOps.GetNode[syms, t1], @offset, replCount*eCount];      -- wordsFilled > e2Offset => cd.remaining has been incremented      END    ELSE      BEGIN -- ~packed      IF wordsFilled > eWSize THEN	cd.remaining ¬ cd.remaining + 1; -- so only pointer isn't lost      SELECT TreeOps.OpName[syms, t1] FROM -- set first element	construct =>	  MainConstruct[TreeOps.NthSon[syms, t1, 2], P5U.OperandType[t1],	    P5U.FieldAddress, @offset];	rowcons => Row[TreeOps.GetNode[syms, t1], @offset];	ENDCASE => {ConstructCountDown[]; ConsAssign[csei, @offset, t1]};      e2Offset ¬ eWSize;      END;    IF wordsFilled > e2Offset THEN      BEGIN      bWords: CARDINAL = wordsFilled - e2Offset;      offset ¬ tOffset;	BEGIN	BltOp: ARRAY [1..2] OF BYTE = [FOpCodes.qBLT, FOpCodes.qBLTL];	owd: CARDINAL ¬ LoadPointer[tOffset.wd]; -- load address of first	SavePointer[];	ConstructCountDown[];	cd.pLoaded ¬ FALSE;	IF owd # 0 THEN P5L.GenAdd[owd, cd.pLength # 1];	P5U.Out1[FOpCodes.qLI, bWords];	owd ¬ LoadPointer[tOffset.wd + e2Offset]; -- load address of second	cd.pLoaded ¬ FALSE;	IF owd # 0 THEN P5L.GenAdd[owd, cd.pLength # 1];	P5U.Out0[BltOp[cd.pLength]];	END;      IF fillBits # 0 THEN	BEGIN	usedBits: CARDINAL = eCount * grain;	offset ¬ tOffset;	P5L.FieldOfComponent[var: @offset, wd: usedBits/wordlength,	  bd: usedBits MOD wordlength, bSize: fillBits];	offset.bSize ¬ fillBits; -- FieldOfComponent won't make bigger	  -- in case more than half of word is filled	IF replCount > 1 THEN cd.remaining ¬ cd.remaining + 1;  -- caller replicates	ConstructCountDown[];  ConsAssign[typeANY, @offset, MPtr.tC0];	END;      END;    RETURN    END;      SetCDBackup: PROC [tvar: VarComponent] =    BEGIN    WITH vv: tvar SELECT FROM      frame => cd.pBackup ¬ [frame[tLevel: vv.level, tOffset: vv.wd]];    <<  link => cd.pBackup ¬ [link[vv.wd]]; >>      faddr => cd.pBackup ¬ [faddr[tLevel: vv.level, tOffset: vv.wd]];      const => cd.pBackup ¬ [const[vv.d1]];      ENDCASE => ERROR;    END; -- public entries  All: PUBLIC PROC [t: Tree.Link, node: Tree.Index, options: StoreOptions]      RETURNS [Lexeme] =    BEGIN    r, rr: VarIndex;    saveCd: ConsDestination = cd;    offset: frame VarComponent;    aSei: Symbols.ArraySEIndex = LOOPHOLE[syms.tb[node].info];    aWords: CARDINAL = CheckOver[WordsForType[syms, aSei]];    cd ¬ [options: options, ignoreSafen: t = Tree.Null OR t.tag = symbol]; -- + defaults    IF BitsPerElement[syms, syms.seb[aSei].componentType, syms.seb[aSei].packed] < wordlength THEN      cd.remaining ¬ 1    ELSE syms.tb[node].son[1] ¬ CountDups[syms, syms.tb[node].son[1]];    r ¬ P5L.VarForLex[IF t = Tree.Null THEN P5.GenTempLex[aWords]	ELSE P5.Exp[t]];    rr ¬ SetConsDest[r, options.expr];    offset ¬ [wSize: cd.wSize, bSize: cd.bSize, space: frame[]];    [] ¬ AllConstruct[node, @offset];    IF cd.remaining # 0 THEN SIGNAL ConstructionError;    cd ¬ saveCd;    RETURN [[bdo[rr]]]    END;  Construct: PUBLIC PROC [t: Tree.Link, node: Tree.Index, options: StoreOptions] =    BEGIN    tsei: RecordSEIndex = LOOPHOLE[syms.tb[node].info];    r, rr: VarIndex;    saveCd: ConsDestination = cd;    offset: frame VarComponent;    fa: PROC [SymbolTable.Handle, ISEIndex] RETURNS [BitAddress, CARDINAL] =      IF syms.seb[tsei].argument THEN FnField ELSE P5U.FieldAddress;    packedDest: VarIndex ¬ VarNull;    cd ¬ [options: options, ignoreSafen: t.tag = symbol]; -- + many defaults    syms.tb[node].son[2] ¬ TreeOps.UpdateList[syms, syms.tb[node].son[2], CountDups];    IF cd.remaining # 0 THEN      BEGIN      r ¬ P5L.VarForLex[P5.Exp[t]];      WITH cc: cb[r] SELECT FROM	ind => WITH cc SELECT FROM	  packed =>	    BEGIN	    var: VarComponent = P5L.ComponentForLex[P5.GenTempLex[1]];	    packedDest ¬ r;  r ¬ P5L.OVarItem[var];	    END;	  ENDCASE;	ENDCASE;      rr ¬ SetConsDest[r, packedDest # VarNull];      offset ¬ [wSize: cd.wSize, bSize: cd.bSize, space: frame[]];      MainConstruct[syms.tb[node].son[2], tsei, fa, @offset];      END;    IF cd.remaining # 0 THEN SIGNAL ConstructionError;    IF packedDest # VarNull THEN	-- not RC      [] ¬ P5L.VarVarAssign[packedDest, rr, FALSE];    cd ¬ saveCd;    END;  ConstructExp: PUBLIC PROC [t: Tree.Link, node: Tree.Index, options: StoreOptions]      RETURNS [Lexeme] =    BEGIN  -- generate code for constructor expression    r, rr: VarIndex;    tsei: RecordSEIndex = LOOPHOLE[syms.tb[node].info];    nwords: CARDINAL = CheckOver[WordsForType[syms, tsei]];    wa: BOOLEAN = P5U.WordAligned[tsei];    fa: PROC [SymbolTable.Handle, ISEIndex] RETURNS [BitAddress, CARDINAL] =      IF syms.seb[tsei].argument THEN FnField ELSE P5U.FieldAddress;    saveCd: ConsDestination = cd;    offset: frame VarComponent;    packedDest: VarIndex ¬ VarNull;    IF t = Tree.Null AND wa AND nwords <= MaxParmsInStack AND	VanillaCons[syms.tb[node].son[2]] THEN      BEGIN -- can build in stack      P5.ConstructOnStack[syms.tb[node].son[2], tsei];      RETURN [P5L.TOSLex[nwords]]      END;    cd ¬ [options: options, ignoreSafen: t = Tree.Null OR t.tag = symbol]; -- + defaults    syms.tb[node].son[2] ¬ TreeOps.UpdateList[syms, syms.tb[node].son[2], CountDups];    r ¬ P5L.VarForLex[IF t = Tree.Null THEN P5.GenTempLex[nwords]	ELSE P5.Exp[t]];    WITH cc: cb[r] SELECT FROM      ind => WITH cc SELECT FROM	packed =>	  BEGIN	  var: VarComponent = P5L.ComponentForLex[P5.GenTempLex[1]];	  packedDest ¬ r;  r ¬ P5L.OVarItem[var];	  END;	ENDCASE;      ENDCASE;    rr ¬ SetConsDest[r, TRUE];    offset ¬ [wSize: cd.wSize, bSize: cd.bSize, space: frame[]];    MainConstruct[syms.tb[node].son[2], tsei, fa, @offset];    IF cd.remaining # 0 THEN SIGNAL ConstructionError;    IF packedDest # VarNull THEN	-- not RC      [] ¬ P5L.VarVarAssign[packedDest, P5L.CopyVarItem[rr], FALSE];    cd ¬ saveCd;    RETURN [[bdo[rr]]]    END;  RowCons: PUBLIC PROC [t: Tree.Link, node: Tree.Index, options: StoreOptions]      RETURNS [Lexeme] =    BEGIN -- array (expression) construction    r, rr: VarIndex;    aSei: ArraySEIndex = LOOPHOLE[syms.tb[node].info];    aWords: CARDINAL = CheckOver[WordsForType[syms, aSei]];    saveCd: ConsDestination = cd;    offset: frame VarComponent;    cd ¬ [options: options, ignoreSafen: t = Tree.Null OR t.tag = symbol]; -- + many defaults    IF syms.tb[node].attr1 AND MPtr.switches['o] THEN cd.remaining ¬ 1    ELSE syms.tb[node].son[2] ¬ TreeOps.UpdateList[syms, syms.tb[node].son[2], CountDups];    r ¬ P5L.VarForLex[IF t = Tree.Null THEN P5.GenTempLex[aWords]	ELSE P5.Exp[t]];    rr ¬ SetConsDest[r, options.expr];    offset ¬ [wSize: cd.wSize, bSize: cd.bSize, space: frame[]];    Row[node, @offset];    IF cd.remaining # 0 THEN SIGNAL ConstructionError;    cd ¬ saveCd;    RETURN [[bdo[rr]]]    END;  TransferConstruct: PUBLIC PROC [      nparms: CARDINAL, resident: BOOLEAN, t: Tree.Link, tsei: CSEIndex] =    BEGIN -- generate code for construct statement    lex: Lexeme;    saveCd: ConsDestination = cd;    offset: frame VarComponent;    fs: CARDINAL ¬ P5U.ComputeFrameSize[nparms + SIZE[PrincOps.LocalOverhead]];    cd ¬ [ignoreSafen: FALSE]; -- + many defaults    IF TreeOps.OpName[syms, t] = safen THEN      BEGIN  -- CountDups would free t      node: Tree.Index = TreeOps.GetNode[syms, t];      r: VarIndex = P5L.VarForLex[P5.Exp[syms.tb[node].son[1]]];      sei: ISEIndex = P5L.CopyToTemp[r].sei;      syms.seb[sei].idType ¬ TreeOps.DecodeSei[syms.tb[node].info];      t ¬ [symbol[sei]];      END;    t ¬ TreeOps.UpdateList[syms, t, CountDups];    IF resident THEN fs ¬ fs + PrincOps.AVHeapSize;    P5U.PushLitVal[fs];  P5U.Out0[FOpCodes.qAF];    cd.remaining ¬ cd.remaining + 1;    IF cd.remaining # 1 THEN      BEGIN      lex ¬ P5L.TOSAddrLex[nparms];      [] ¬ SetConsDest[P5L.VarForLex[lex], FALSE];      offset ¬ [wSize: cd.wSize, bSize: cd.bSize, space: frame[]];      MainConstruct[t, tsei, FnField, @offset];      [] ¬ LoadPointer[0];      END;    IF cd.remaining # 1 THEN SIGNAL ConstructionError;    cd ¬ saveCd;    END;  VariantConstruct: PUBLIC PROC [t1, t2: Tree.Link, options: StoreOptions] =    BEGIN    r: VarIndex;    saveCd: ConsDestination = cd;    offset: frame VarComponent;    rootSei: RecordSEIndex;    t1 ¬ TreeOps.NthSon[syms, t1, 1];    cd ¬ [options: options, ignoreSafen: t1.tag = symbol]; -- + many defaults    t2 ¬ TreeOps.UpdateList[syms, t2, CountDups];    IF cd.remaining # 0 THEN      BEGIN      rootSei ¬ RecordRoot[syms, LOOPHOLE[P5U.OperandType[t1]]];      r ¬ P5L.VarForLex[P5.Exp[t1]];      WITH cc: cb[r] SELECT FROM	ind => WITH cc SELECT FROM	  packed => SIGNAL CPtr.CodeNotImplemented;	  ENDCASE;	ENDCASE;      [] ¬ SetConsDest[r, FALSE];      offset ¬ [wSize: cd.wSize, bSize: cd.bSize, space: frame[]];      UnionConstruct[TreeOps.GetNode[syms, t2], rootSei, @offset];      END;    IF cd.remaining # 0 THEN SIGNAL ConstructionError;    cd ¬ saveCd;    END;  New: PUBLIC PROC [node: Tree.Index] RETURNS [Lexeme] =    BEGIN    long: BOOLEAN = syms.tb[node].attr2;    pLength: CARDINAL = CheckOver[WordsForType[syms, TreeOps.DecodeSei[syms.tb[node].info]]];    typeTree: Tree.Link = syms.tb[node].son[2];    overType: Symbols.SEIndex = P5U.TypeForTree[typeTree];    type: CSEIndex = UnderType[syms, overType];    catchTree: Tree.Link = IF syms.tb[node].nSons = 4 THEN syms.tb[node].son[4] ELSE Tree.Null;    tag: ISEIndex ¬ ISENull;    seqLength: VarComponent;    computedType: BOOLEAN = (TreeOps.OpName[syms, typeTree] = apply);    sizePusher: PROC = IF computedType THEN PushNewSize ELSE NIL;    PushNewSize: PROC =      BEGIN      nw: CARDINAL = CheckOver[WordsForType[syms, type]];      IF computedType THEN	BEGIN	subNode: Tree.Index = TreeOps.GetNode[syms, typeTree];	vSei: ISEIndex = VariantField[syms, type];	bitsPerItem, n: CARDINAL;	IF vSei # ISENull THEN	  BEGIN	  vType: CSEIndex = UnderType[syms, syms.seb[vSei].idType];	  WITH v: syms.seb[vType] SELECT FROM	    sequence =>	      BEGIN	      tag ¬ IF v.controlled THEN v.tagSei ELSE ISENull;	      bitsPerItem ¬ CheckOver[BitsPerElement[syms, v.componentType, v.packed]];	      END;	    ENDCASE => ERROR;	  END	ELSE	  BEGIN  -- must be StringBody, fudge it	  tag ¬ NextSe[syms, FirstCtxSe[syms, syms.seb[LOOPHOLE[type, RecordSEIndex]].fieldCtx]];	  bitsPerItem ¬ Environment.bitsPerCharacter;	  END;	seqLength ¬ P5L.ComponentForLex[P5.Exp[syms.tb[subNode].son[2]]];	IF tag # ISENull THEN seqLength ¬ P5L.EasilyLoadable[	  seqLength, 	  IF syms.tb[node].son[3] # Tree.Null THEN store ELSE load];	IF bitsPerItem >= wordlength THEN	  BEGIN	  n ¬ bitsPerItem/wordlength;	  WITH s: seqLength SELECT FROM	    const => P5U.PushLitVal[nw + n*s.d1];	    ENDCASE =>	      BEGIN	      P5L.LoadComponent[seqLength];	      IF n # 1 THEN {P5U.PushLitVal[n];  P5U.Out0[FOpCodes.qMUL]};	      P5U.PushLitVal[nw];  P5U.Out0[FOpCodes.qADD];	      END;	  END	ELSE	  BEGIN	  n ¬ wordlength/bitsPerItem;	  WITH s: seqLength SELECT FROM	    const => P5U.PushLitVal[nw + ((s.d1+(n-1))/n)];	    ENDCASE =>	      BEGIN	      P5L.LoadComponent[seqLength];	      P5U.PushLitVal[n-1];  P5U.Out0[FOpCodes.qADD];	      P5U.PushLitVal[SELECT n FROM 2 => -1, 4 => -2, 8 => -3, ENDCASE => -4];	      P5U.Out0[FOpCodes.qSHIFT];	      P5U.PushLitVal[nw];  P5U.Out0[FOpCodes.qADD];	      END;	  END;	END      ELSE P5U.PushLitVal[nw];      END;    zoneTree: Tree.Link = syms.tb[node].son[1];    initTree: Tree.Link;    saveCd: ConsDestination = cd;    cd ¬ [options: [init: TRUE, counted: FALSE], ignoreSafen: FALSE];  -- + defaults    cd.remaining ¬ 1;    syms.tb[node].son[3] ¬ CountDups[syms, syms.tb[node].son[3]];          BEGIN      P5.ZoneOp[zone: zoneTree, index: 0, pushArg: PushNewSize, catch: catchTree, long: long];      Stack.Incr[pLength];      END;    IF tag # ISENull OR syms.tb[node].son[3] # Tree.Null THEN      BEGIN      ptrVar: VarIndex;      ptrVar ¬ P5L.TOSAddrLex[size: CheckOver[WordsForType[syms, type]], long: long].lexbdoi;      [] ¬ SetConsDest[ptrVar];      IF tag # ISENull THEN	BEGIN	offset:  VarComponent ¬ P5L.ComponentForSE[tag];	WITH o: offset SELECT FROM	  frame => ConsAssign[typeANY, @o, Tree.Null, [bdo[P5L.OVarItem[seqLength]]]];	  ENDCASE => ERROR;	END;      IF syms.tb[node].son[3] # Tree.Null THEN	BEGIN	offset:  frame VarComponent ¬ [wSize: cd.wSize, bSize: cd.bSize, space: frame[]];	initTree ¬ syms.tb[node].son[3];	DO	  SELECT TreeOps.OpName[syms, initTree] FROM	    pad =>	      BEGIN	      initTree ¬ TreeOps.NthSon[syms, initTree, 1];	      offset.wSize ¬ P5U.WordsForOperand[initTree];  offset.bSize ¬ 0;	      END;	    cast => initTree ¬ TreeOps.NthSon[syms, initTree, 1];	    ENDCASE => EXIT;	  ENDLOOP;	SELECT TreeOps.OpName[syms, initTree] FROM	  construct =>	    MainConstruct[TreeOps.NthSon[syms, initTree, 2], P5U.OperandType[initTree],		P5U.FieldAddress, @offset];	  rowcons => Row[TreeOps.GetNode[syms, initTree], @offset];	  all => [] ¬ AllConstruct[TreeOps.GetNode[syms, initTree], @offset];	  mwconst => ConstantFill[type, @offset, initTree];	  ENDCASE => {ConstructCountDown[]; ConsAssign[type, @offset, initTree]};	END;      IF cd.remaining # 1 THEN SIGNAL ConstructionError;      [] ¬ LoadPointer[0];      END;    cd ¬ saveCd;    RETURN [P5L.TOSLex[pLength]]    END;      END.
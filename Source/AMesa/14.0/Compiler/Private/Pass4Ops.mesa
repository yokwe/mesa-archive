-- Copyright (C) 1982, 1986  by Xerox Corporation. All rights reserved. -- file Pass4Ops.mesa-- last written by Satterthwaite, September 23, 1982 12:12 pm-- last written by Sweet, 19-Oct-82 11:37:55-- Wagner	20-Aug-86 10:39:34DIRECTORY  Literals USING [LitDescriptor],  LiteralOps USING [DescriptorValue, Find, FindDescriptor, Value],  CLog USING [ErrorTree, WarningTree],  P4 USING [RelOp, Repr, none, unsigned, both, other, CommonRep],  Pass4 USING [tFALSE, tTRUE],  Real: FROM "IeeeFloat" USING [Abs, RealException, Negate, PairToReal],  Symbols USING [CSEIndex],  SymbolTable USING [Handle],  Tree USING [Index, Link, NodeName, Null],  TreeOps USING [    DecodeCSei, EncodeSei, FreeNode, GetNode, Map, PopTree, PushLit, PushNode,    Scan, ScanList, SetInfo, UpdateList];Pass4Ops: PROGRAM    IMPORTS LiteralOps, Log: CLog, P4, Real, TreeOps, passPtr: Pass4    EXPORTS P4 = {  OPEN TreeOps;  RelOp: TYPE = P4.RelOp;  Repr: TYPE = P4.Repr;    syms: SymbolTable.Handle ¬ NIL;  Pass4OpsInit: PUBLIC PROC [h: SymbolTable.Handle] = { syms ¬ h }; -- literals  TreeLiteral: PUBLIC PROC [t: Tree.Link] RETURNS [BOOLEAN] = {    RETURN [WITH t SELECT FROM      literal => info.litTag = word,      subtree =>	SELECT syms.tb[index].name FROM	  cast => TreeLiteral[syms.tb[index].son[1]],	  ENDCASE => FALSE,      ENDCASE => FALSE]};  TreeLiteralValue: PUBLIC PROC [t: Tree.Link] RETURNS [WORD] = {    WITH e:t SELECT FROM      literal =>	WITH e.info SELECT FROM	  word => RETURN [LiteralOps.Value[syms, index]];	  ENDCASE;      subtree => {	node: Tree.Index = e.index;	SELECT syms.tb[node].name FROM	  cast => RETURN [TreeLiteralValue[syms.tb[node].son[1]]];	  ENDCASE};      ENDCASE;    ERROR};  MakeTreeLiteral: PUBLIC PROC [val: WORD] RETURNS [Tree.Link] = {    RETURN [[literal[info: [word[index: LiteralOps.Find[syms, val]]]]]]};  StructuredLiteral: PUBLIC PROC [t: Tree.Link] RETURNS [BOOLEAN] = {    RETURN [WITH t SELECT FROM      literal => info.litTag = word,      subtree =>	SELECT syms.tb[index].name FROM	  mwconst => TRUE,	  cast => StructuredLiteral[syms.tb[index].son[1]],	  ENDCASE => FALSE,      ENDCASE => FALSE]};  TreeLiteralDesc: PUBLIC PROC [t: Tree.Link] RETURNS [Literals.LitDescriptor] = {    WITH t SELECT FROM      literal =>	WITH info SELECT FROM	  word => RETURN [LiteralOps.DescriptorValue[syms, index]];	  ENDCASE;      subtree => {	node: Tree.Index = index;	SELECT syms.tb[node].name FROM	  mwconst, cast => RETURN [TreeLiteralDesc[syms.tb[node].son[1]]];	  ENDCASE};      ENDCASE;    ERROR};  LongLiteralValue: PROC [t: Tree.Link] RETURNS [LONG UNSPECIFIED] = {    w: ARRAY [0..1] OF WORD;    desc: Literals.LitDescriptor = TreeLiteralDesc[t];    IF desc.length # 2 THEN ERROR;    w[0] ¬ syms.ltb[desc.offset][0];  w[1] ¬ syms.ltb[desc.offset][1];    RETURN [LOOPHOLE[w]]};  MakeLongLiteral: PROC [val: LONG UNSPECIFIED, type: Symbols.CSEIndex]      RETURNS [Tree.Link] = {    w: ARRAY [0..1] OF WORD ¬ LOOPHOLE[val];    PushLit[syms, LiteralOps.FindDescriptor[syms, DESCRIPTOR[w]]];    PushNode[syms, mwconst, 1];  SetInfo[syms, EncodeSei[type]];    RETURN [PopTree[syms]]};  LiteralRep: PUBLIC PROC [t: Tree.Link, rep: Repr] RETURNS [Repr] = {    desc: Literals.LitDescriptor;    RETURN [SELECT TRUE FROM      rep = P4.other, rep = P4.none => rep,      TreeLiteral[t] => 	IF TreeLiteralValue[t] > 77777b	  THEN IF rep = P4.both THEN P4.unsigned ELSE rep	  ELSE P4.both,      StructuredLiteral[t] =>	IF (desc¬TreeLiteralDesc[t]).length = 2	  THEN	    IF syms.ltb[desc.offset][1] > 77777b	      THEN IF rep = P4.both THEN P4.unsigned ELSE rep	      ELSE P4.both	  ELSE P4.other,      ENDCASE => rep]};  IntToReal: PUBLIC PROC [node: Tree.Index] RETURNS [val: Tree.Link] = {    v: LONG INTEGER = LongLiteralValue[syms.tb[node].son[1]];    overflow: BOOLEAN ¬ FALSE;    r: REAL = Real.PairToReal[v, 0		! Real.RealException => {overflow ¬ TRUE; RESUME}];    IF overflow THEN {val ¬ [subtree[node]]; Log.ErrorTree[overflow, val]}    ELSE {val ¬ MakeLongLiteral[r, DecodeCSei[syms.tb[node].info]]; FreeNode[syms, node]};    RETURN};  SignWord: WORD = LAST[CARDINAL];    ShortToLong: PUBLIC PROC [node: Tree.Index, rep: Repr] RETURNS [val: Tree.Link] = {    w: ARRAY [0..1] OF WORD ¬ [      TreeLiteralValue[syms.tb[node].son[1]],      IF P4.CommonRep[rep, P4.unsigned] # P4.none OR w[0] <= MaxSS THEN 0 ELSE SignWord];    PushLit[syms, LiteralOps.FindDescriptor[syms, DESCRIPTOR[w]]];    PushNode[syms, mwconst, 1];  SetInfo[syms, syms.tb[node].info];  FreeNode[syms, node];    RETURN [PopTree[syms]]};      LongToShort: PUBLIC PROC [node: Tree.Index, rep: Repr] RETURNS [val: Tree.Link] = {    v, w: WORD;    desc: Literals.LitDescriptor = TreeLiteralDesc[syms.tb[node].son[1]];    IF desc.length # 2 THEN ERROR;    v ¬ syms.ltb[desc.offset][0];  w ¬ syms.ltb[desc.offset][1];    IF P4.CommonRep[rep, P4.unsigned] # P4.none THEN {      IF w # 0 THEN GO TO Overflow}    ELSE      IF (v <= MaxSS AND w # 0)       OR (v > MaxSS AND w # SignWord) THEN GO TO Overflow;    val ¬ MakeTreeLiteral[v];  FreeNode[syms, node];    EXITS      Overflow => {        val ¬ [subtree[node]]; Log.ErrorTree[boundsFault, syms.tb[node].son[1]]}};  ZeroP: PUBLIC PROC [t: Tree.Link] RETURNS [zero: BOOLEAN] = {    IF ~StructuredLiteral[t] THEN zero ¬ FALSE    ELSE {      desc: Literals.LitDescriptor = TreeLiteralDesc[t];      zero ¬ TRUE;      FOR i: CARDINAL IN [0..desc.length) WHILE (zero¬(syms.ltb[desc.offset][i] = 0)) DO	NULL ENDLOOP};    RETURN}; -- dispatch  Mode: TYPE = {ss, su, ls, lu, other};  ModeMap: ARRAY Repr OF Mode = [    ss, ss, su, ss, ls, ls, lu, ls,    other, ss, su, ss, other, ls, lu, ls];  InOp: TYPE = Tree.NodeName [in .. notin];  IntOp: TYPE = Tree.NodeName [intOO .. intCC];  Test: ARRAY Mode OF PROC [t1, t2: Tree.Link, op: RelOp] RETURNS [BOOLEAN] = [    TestSS, TestSU, TestLS, TestLU, TestOther];  UnaryOp: ARRAY Mode OF PROC [node: Tree.Index] RETURNS [Tree.Link] = [    UnarySS, UnarySU, UnaryLS, UnaryLU, UnaryOther];  BinaryOp: ARRAY Mode OF PROC [node: Tree.Index] RETURNS [Tree.Link] = [    BinarySS, BinarySU, BinaryLS, BinaryLU, OpError];  FoldExpr: PUBLIC PROC [node: Tree.Index, rep: Repr] RETURNS [val: Tree.Link] = {    SELECT syms.tb[node].name FROM      plus, minus, times, div, mod => val ¬ BinaryOp[ModeMap[rep]][node];      abs, uminus => val ¬ UnaryOp[ModeMap[rep]][node];      relE, relN, relL, relGE, relG, relLE => {	val ¬ IF RelTest [		l: syms.tb[node].son[1], r: syms.tb[node].son[2],		op: syms.tb[node].name,		rep: rep]	  THEN passPtr.tTRUE	  ELSE passPtr.tFALSE;	FreeNode[syms, node]};      in, notin => {	val ¬ IF	     IntervalTest [l: syms.tb[node].son[1], r: syms.tb[node].son[2], rep: rep]	      =	     (syms.tb[node].name = in)	  THEN passPtr.tTRUE	  ELSE passPtr.tFALSE;	FreeNode[syms, node]};      min, max => {	VoidItem: TreeOps.Map = {RETURN[IF t=val THEN Tree.Null ELSE t]};	val ¬ Choose[		list: syms.tb[node].son[1],		test: IF syms.tb[node].name = min THEN relL ELSE relG,		rep: rep];	syms.tb[node].son[1] ¬ UpdateList[syms, syms.tb[node].son[1], VoidItem];	FreeNode[syms, node]};      ENDCASE => ERROR};  RelTest: PUBLIC PROC [l, r: Tree.Link, op: RelOp, rep: Repr] RETURNS [BOOLEAN] = {    OpMap: ARRAY RelOp OF RECORD [map: RelOp, sense: BOOLEAN] = [      [relE, TRUE], [relE, FALSE], [relL, TRUE], [relL, FALSE],      [relG, TRUE], [relG, FALSE]];    RETURN [Test[ModeMap[rep]][l, r, OpMap[op].map] = OpMap[op].sense]};  IntervalTest: PUBLIC PROC [l, r: Tree.Link, rep: Repr] RETURNS [BOOLEAN] = {    InTest: ARRAY IntOp OF RECORD [lb, ub: RelOp] = [      [relG, relL], [relG, relLE], [relGE, relL], [relGE, relLE]];    subNode: Tree.Index = GetNode[syms, r];    op: IntOp = syms.tb[subNode].name;    RETURN [	RelTest[l, syms.tb[subNode].son[1], InTest[op].lb, rep]	  AND	RelTest[l, syms.tb[subNode].son[2], InTest[op].ub, rep] ]};  Choose: PROC [list: Tree.Link, test: RelOp, rep: Repr] RETURNS [val: Tree.Link] = {    started: BOOLEAN ¬ FALSE;    Item: TreeOps.Scan = {      SELECT TRUE FROM	~started => {started ¬ TRUE; val ¬ t};	RelTest[t, val, test, rep] => val ¬ t;	ENDCASE};    ScanList[syms, list, Item];  RETURN}; -- operations  MinSS: INTEGER = FIRST[INTEGER];  MaxSS: INTEGER = LAST[INTEGER];  TestSS: PROC [t1, t2: Tree.Link, op: RelOp] RETURNS [BOOLEAN] = {    v1: INTEGER = TreeLiteralValue[t1];    v2: INTEGER = TreeLiteralValue[t2];    RETURN [SELECT op FROM      relE => v1 = v2,      relL => v1 < v2,      relG => v1 > v2,      ENDCASE => ERROR]};  UnarySS: PROC [node: Tree.Index] RETURNS [t: Tree.Link] = {    v: INTEGER;    v1: INTEGER = TreeLiteralValue[syms.tb[node].son[1]];    SELECT syms.tb[node].name FROM      uminus => IF v1 # MinSS THEN v ¬ -v1 ELSE GO TO Overflow;      abs => IF v1 # MinSS THEN v ¬ IF v1 < 0 THEN -v1 ELSE v1 ELSE GO TO Overflow;      ENDCASE => ERROR;    t ¬ MakeTreeLiteral[v];  FreeNode[syms, node];    EXITS      Overflow => {	syms.tb[node].attr3 ¬ TRUE; t ¬ [subtree[node]]; Log.ErrorTree[overflow, t]}};  BinarySS: PROC [node: Tree.Index] RETURNS [t: Tree.Link] = {    v: INTEGER;    v1: INTEGER = TreeLiteralValue[syms.tb[node].son[1]];    v2: INTEGER = TreeLiteralValue[syms.tb[node].son[2]];    SELECT syms.tb[node].name FROM      plus =>	IF (IF v1 >= 0 THEN v2 <= MaxSS-v1 ELSE v2 >= MinSS-v1) THEN v ¬ v1 + v2	ELSE GO TO Overflow;      minus =>	IF (IF v1 >= 0 THEN v1-MaxSS <= v2 ELSE v1-MinSS >= v2) THEN v ¬ v1 - v2	ELSE GO TO Overflow;      times =>	IF (SELECT TRUE FROM	    (v1 > 0) AND (v2 > 0) => v2 <= MaxSS / v1,	    (v1 > 0) AND (v2 < 0) => v2 >= MinSS / v1,	    (v1 < 0) AND (v2 > 0) => v1 >= MinSS / v2,	    (v1 < 0) AND (v2 < 0) =>		v1 # MinSS AND v2 # MinSS AND v2 >= MaxSS / v1,	    ENDCASE => TRUE) THEN	     v ¬ v1 * v2	ELSE GO TO Overflow;      div =>	IF v2 # 0 AND (v2 # -1 OR v1 # MinSS) THEN v ¬ v1 / v2	ELSE GO TO Overflow;      mod => IF v2 # 0 THEN v ¬ v1 MOD v2 ELSE GO TO Overflow;      ENDCASE => ERROR;    t ¬ MakeTreeLiteral[v];  FreeNode[syms, node];    EXITS      Overflow => {	syms.tb[node].attr3 ¬ TRUE; t ¬ [subtree[node]]; Log.ErrorTree[overflow, t]}};  MaxSU: CARDINAL = LAST[CARDINAL];  TestSU: PROC [t1, t2: Tree.Link, op: RelOp] RETURNS [BOOLEAN] = {    v1: CARDINAL = TreeLiteralValue[t1];    v2: CARDINAL = TreeLiteralValue[t2];    RETURN [SELECT op FROM      relE => v1 = v2,      relL => v1 < v2,      relG => v1 > v2,      ENDCASE => ERROR]};  UnarySU: PROC [node: Tree.Index] RETURNS [t: Tree.Link] = {    v1: CARDINAL = TreeLiteralValue[syms.tb[node].son[1]];    SELECT syms.tb[node].name FROM      uminus => IF v1 # 0 THEN GO TO Overflow;      abs => NULL;      ENDCASE => ERROR;    t ¬ MakeTreeLiteral[v1];  FreeNode[syms, node];    EXITS      Overflow => {	syms.tb[node].attr3 ¬ FALSE; t ¬ [subtree[node]]; Log.ErrorTree[overflow, t]}};  BinarySU: PROC [node: Tree.Index] RETURNS [t: Tree.Link] = {    v: CARDINAL;    v1: CARDINAL = TreeLiteralValue[syms.tb[node].son[1]];    v2: CARDINAL = TreeLiteralValue[syms.tb[node].son[2]];    SELECT syms.tb[node].name FROM      plus => IF v2 <= MaxSU-v1 THEN v ¬ v1 + v2 ELSE GO TO Overflow;      minus => IF v1 >= v2 THEN v ¬ v1 - v2 ELSE GO TO Overflow;      times => IF v1 = 0 OR v2 <= MaxSU/v1 THEN v ¬ v1 * v2 ELSE GO TO Overflow;      div => IF v2 # 0 THEN v ¬ v1 / v2 ELSE GO TO Overflow;      mod => IF v2 # 0 THEN v ¬ v1 MOD v2 ELSE GO TO Overflow;      ENDCASE => ERROR;    t ¬ MakeTreeLiteral[v];  FreeNode[syms, node];    EXITS      Overflow => {	syms.tb[node].attr3 ¬ FALSE; t ¬ [subtree[node]]; Log.ErrorTree[overflow, t]}};  MinLS: LONG INTEGER = FIRST[LONG INTEGER];  MaxLS: LONG INTEGER = LAST[LONG INTEGER];  TestLS: PROC [t1, t2: Tree.Link, op: RelOp] RETURNS [BOOLEAN] = {    v1: LONG INTEGER = LongLiteralValue[t1];    v2: LONG INTEGER = LongLiteralValue[t2];    RETURN [SELECT op FROM      relE => v1 = v2,      relL => v1 < v2,      relG => v1 > v2,      ENDCASE => ERROR]};  UnaryLS: PROC [node: Tree.Index] RETURNS [t: Tree.Link] = {    v: LONG INTEGER;    v1: LONG INTEGER = LongLiteralValue[syms.tb[node].son[1]];    SELECT syms.tb[node].name FROM      uminus => IF v1 # MinLS THEN v ¬ -v1 ELSE GO TO Overflow;      abs => IF v1 # MinLS THEN v ¬ IF v1 < 0 THEN -v1 ELSE v1 ELSE GO TO Overflow;      ENDCASE => ERROR;    t ¬ MakeLongLiteral[v, DecodeCSei[syms.tb[node].info]];  FreeNode[syms, node];    EXITS      Overflow => {	syms.tb[node].attr3 ¬ TRUE; t ¬ [subtree[node]]; Log.ErrorTree[overflow, t]}};  BinaryLS: PROC [node: Tree.Index] RETURNS [t: Tree.Link] = {    v: LONG INTEGER;    v1: LONG INTEGER = LongLiteralValue[syms.tb[node].son[1]];    v2: LONG INTEGER = LongLiteralValue[syms.tb[node].son[2]];    SELECT syms.tb[node].name FROM      plus =>	IF (IF v1 >= 0 THEN v2 <= MaxLS-v1 ELSE v2 >= MinLS-v1) THEN v ¬ v1 + v2	ELSE GO TO Overflow;      minus =>	IF (IF v1 >= 0 THEN v1-MaxLS <= v2 ELSE v1-MinLS >= v2) THEN v ¬ v1 - v2	ELSE GO TO Overflow;      times =>	IF (SELECT TRUE FROM	    (v1 > 0) AND (v2 > 0) => v2 <= MaxLS / v1,	    (v1 > 0) AND (v2 < 0) => v2 >= MinLS / v1,	    (v1 < 0) AND (v2 > 0) => v1 >= MinLS / v2,	    (v1 < 0) AND (v2 < 0) =>		v1 # MinLS AND v2 # MinLS AND v2 >= MaxLS / v1,	    ENDCASE => TRUE) THEN	 v ¬ v1 * v2	ELSE GO TO Overflow;      div =>	IF v2 # 0 AND (v2 # -1 OR v1 # MinLS) THEN v ¬ v1 / v2	ELSE GO TO Overflow;      mod => IF v2 # 0 THEN v ¬ v1 MOD v2 ELSE GO TO Overflow;      ENDCASE => ERROR;    t ¬ MakeLongLiteral[v, DecodeCSei[syms.tb[node].info]];  FreeNode[syms, node];    EXITS      Overflow => {	syms.tb[node].attr3 ¬ TRUE; t ¬ [subtree[node]]; Log.ErrorTree[overflow, t]}};  MaxLU: LONG CARDINAL = LAST[LONG CARDINAL];  TestLU: PROC [t1, t2: Tree.Link, op: RelOp] RETURNS [BOOLEAN] = {    v1: LONG CARDINAL = LongLiteralValue[t1];    v2: LONG CARDINAL = LongLiteralValue[t2];    RETURN [SELECT op FROM      relE => v1 = v2,      relL => v1 < v2,      relG => v1 > v2,      ENDCASE => ERROR]};  UnaryLU: PROC [node: Tree.Index] RETURNS [t: Tree.Link] = {    v1: LONG CARDINAL = LongLiteralValue[syms.tb[node].son[1]];    SELECT syms.tb[node].name FROM      uminus => IF v1 # 0 THEN GO TO Overflow;      abs => NULL;      ENDCASE => ERROR;    t ¬ MakeLongLiteral[v1, DecodeCSei[syms.tb[node].info]];  FreeNode[syms, node];    EXITS      Overflow => {	syms.tb[node].attr3 ¬ FALSE; t ¬ [subtree[node]]; Log.ErrorTree[overflow, t]}};  BinaryLU: PROC [node: Tree.Index] RETURNS [t: Tree.Link] = {    v: LONG CARDINAL;    v1: LONG CARDINAL = LongLiteralValue[syms.tb[node].son[1]];    v2: LONG CARDINAL = LongLiteralValue[syms.tb[node].son[2]];    SELECT syms.tb[node].name FROM      plus => IF v2 <= MaxLU-v1 THEN v ¬ v1 + v2 ELSE GO TO Overflow;      minus => IF v1 >= v2 THEN v ¬ v1 - v2 ELSE GO TO Overflow;      times => IF v1 = 0 OR v2 <= MaxLU/v1 THEN v ¬ v1 * v2 ELSE GO TO Overflow;      div => IF v2 # 0 THEN v ¬ v1 / v2 ELSE GO TO Overflow;      mod => IF v2 # 0 THEN v ¬ v1 MOD v2 ELSE GO TO Overflow;      ENDCASE => ERROR;    t ¬ MakeLongLiteral[v, DecodeCSei[syms.tb[node].info]];  FreeNode[syms, node];    EXITS      Overflow => {	syms.tb[node].attr3 ¬ FALSE; t ¬ [subtree[node]]; Log.ErrorTree[overflow, t]}};  TestOther: PROC [t1, t2: Tree.Link, op: RelOp] RETURNS [BOOLEAN] = {    RETURN [SELECT op FROM      relE => TreeLiteralDesc[t1] = TreeLiteralDesc[t2],      ENDCASE => ERROR]};  UnaryOther: PROC [node: Tree.Index] RETURNS [t: Tree.Link] = {    fail: BOOLEAN ¬ FALSE;    IF syms.tb[node].attr1	-- REAL      THEN {	ENABLE Real.RealException => {fail ¬ TRUE; RESUME};	v: REAL;	v1: REAL = LongLiteralValue[syms.tb[node].son[1]];	SELECT syms.tb[node].name FROM	  uminus => v ¬ Real.Negate[v1];	  abs => v ¬ Real.Abs[v1];	  ENDCASE => ERROR;	IF fail THEN GO TO Overflow;	t ¬ MakeLongLiteral[v, DecodeCSei[syms.tb[node].info]];  FreeNode[syms, node];	EXITS	  Overflow => {	    syms.tb[node].attr3 ¬ TRUE; t ¬ [subtree[node]]; Log.WarningTree[overflow, t]}}      ELSE ERROR};  OpError: PROC [node: Tree.Index] RETURNS [t: Tree.Link] = {ERROR};  }.
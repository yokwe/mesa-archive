-- Copyright (C) 1983, 1986  by Xerox Corporation. All rights reserved. -- file Pass3Xa.mesa--   Satterthwaite,	October 22, 1982 11:20 am--   Sweet,		14-Oct-83 11:14:04--   Wagner		19-Aug-86  8:33:39DIRECTORY  ComData USING [    interface, mainCtx, seAnon, textIndex,    typeCONDITION, typeStringBody],  Copier USING [SEToken, NullSEToken, CtxNext, TokenHash, TokenValue],  CLog USING [Error, ErrorHti, ErrorN, ErrorNode, ErrorSei, ErrorTree],  P3 USING [    Attr, emptyAttr, fullAttr, voidAttr, LhsMode, NPUse, MergeNP, SetNP,    And, ArrangeKeys, AssignableType, BodyForTree, Bundling,    CanonicalType, CatchPhrase, ClusterId, CompleteRecord, CopyTree,    Default, DefaultInit, DiscriminatedType, EnterComposite, Exp, FieldId, ForceType,    InterfaceId, LongPath, MainIncludedCtx, MiscXfer, OperandInternal,     OperandLevel, OperandLhs, OperandType, phraseNP, PopCtx, PushCtx,    RAttr, Rhs, RhsPrime, RPop, RPush, RType, Shared, Span, SearchCtxList,    SelectVariantType, SequenceField, TargetType, TypeForTree, Unbundle,    UpdateTreeAttr, VariantUnionType, Voidable, VoidExp, VoidItem, XferForFrame],  P3S USING [    ImplicitInfo, SelfInfo, currentBody, currentScope, implicit, safety],  Symbols USING [    HTIndex, SEIndex, ISEIndex, CSEIndex, ArraySEIndex, RecordSEIndex,    ContextLevel, CTXIndex, CBTIndex, TransferMode,    HTNull, ISENull, CSENull, RecordSENull, CTXNull, CBTNull,    lG, typeANY, typeTYPE],  SymbolOps USING [    ArgCtx, ConstantId, FindExtension, FirstCtxSe, FirstVisibleSe, NextSe,    NextVisibleSe, NormalType, RCType, ReferentType, TransferTypes,     TypeForm, TypeRoot, UnderType, VisibleCtxEntries, XferMode],  SymbolTable USING [Handle],  Tree USING [    Index, Link, NodeName, Null],  TreeOps USING [    EncodeBti, EncodeCard, EncodeSei, FreeNode, FreeTree, GetHash, GetNode,     ListHead, ListLength, ListTail, MakeList, MakeNode, Map, NthSon, OpName,     PopTree, PushHash, PushList, PushNode, PushProperList, PushSe, PushTree,     Scan, ScanList, SetAttr, SetInfo, SetShared, UpdateList],  Types USING [Assignable];Pass3Xa: PROGRAM    IMPORTS      Copier, Log: CLog, P3, P3S, SymbolOps, TreeOps, Types,      dataPtr: ComData    EXPORTS P3, P3S = {  OPEN SymbolOps, Symbols, TreeOps, P3;  syms: SymbolTable.Handle;    Pass3XaInit: PUBLIC PROC [h: SymbolTable.Handle] = { syms ¬ h }; -- expression list manipulation  KeyedList: PROC [t: Tree.Link] RETURNS [BOOLEAN] = {    RETURN [OpName[syms, ListHead[syms, t]] = item]};  PopKeyList: PROC [nItems: CARDINAL] RETURNS [t: Tree.Link] = {    t ¬ MakeList[syms, nItems];    IF t = Tree.Null AND nItems # 0 THEN {PushTree[syms, t]; PushProperList[syms, 1]; t ¬ PopTree[syms]};    RETURN};  CheckLength: PROC [t: Tree.Link, length: INTEGER] = {    n: INTEGER = ListLength[syms, t];    SELECT n FROM      = length => NULL;      > length => Log.ErrorN[listLong, n-length];      < length => Log.ErrorN[listShort, length-n];      ENDCASE};  ContextComplete: PROC [ctx: CTXIndex] RETURNS [BOOLEAN] = {    RETURN [WITH syms.ctxb[ctx] SELECT FROM      simple => TRUE,      included => complete,      ENDCASE => FALSE]};  CheckScope: PUBLIC PROC [t: Tree.Link, type: CSEIndex] RETURNS [v: Tree.Link] = {    SELECT XferMode[syms, type] FROM      proc, signal, error =>	SELECT OperandLevel[t] FROM	  global => v ¬ t;	  local => {Log.ErrorTree[scopeFault, t]; v ¬ t};	  ENDCASE => {	    PushTree[syms, t]; PushNode[syms, proccheck, 1]; 	    SetInfo[syms, EncodeSei[type]];	    v ¬ PopTree[syms]};      ENDCASE => v ¬ t;    RETURN};        KeyForHash: PROC [hti: HTIndex] RETURNS [HTIndex] = {    RETURN [IF hti = HTNull THEN syms.seb[dataPtr.seAnon].hash ELSE hti]};  HashForSe: PROC [sei: ISEIndex] RETURNS [HTIndex] = {    RETURN [IF sei = ISENull THEN HTNull ELSE KeyForHash[syms.seb[sei].hash]]};  PadList: PROC [record: RecordSEIndex, expList: Tree.Link] RETURNS [Tree.Link] = {    ctx: CTXIndex = syms.seb[record].fieldCtx;    sei: ISEIndex ¬ FirstVisibleSe[syms, ctx];    added: BOOLEAN ¬ FALSE;    nFields: CARDINAL ¬ 0;    PushField: TreeOps.Map = {      PushTree[syms, t]; nFields ¬ nFields + 1; sei ¬ NextSe[syms, sei];      RETURN [Tree.Null]};    [] ¬ FreeTree[syms, UpdateList[syms, expList, PushField]];    UNTIL sei = ISENull DO      IF ~syms.seb[sei].extended AND (syms.seb[record].argument OR Default[syms.seb[sei].idType] = none) THEN        EXIT;      PushTree[syms, Tree.Null];  added ¬ TRUE;  nFields ¬ nFields + 1;      sei ¬ NextSe[syms, sei];      ENDLOOP;    IF added THEN PushProperList[syms, nFields] ELSE PushList[syms, nFields];    RETURN [PopTree[syms]]};  FieldDefault: PUBLIC PROC [sei: ISEIndex] RETURNS [v: Tree.Link] = {    CheckOption: TreeOps.Scan = {IF OpName[syms, t] # void THEN v ¬ CopyTree[syms, t]};    v ¬ Tree.Null;  ScanList[syms, FindExtension[syms, sei].tree, CheckOption];    RPush[UnderType[syms, syms.seb[sei].idType],      IF v=Tree.Null THEN voidAttr ELSE UpdateTreeAttr[v]];    RETURN};  FieldVoid: PROC [t: Tree.Link] RETURNS [Tree.Link] = {    [] ¬ FreeTree[syms, t];  phraseNP ¬ none;  RPush[typeANY, voidAttr];    RETURN [Tree.Null]};  MatchFields: PUBLIC PROC [        record: RecordSEIndex, expList: Tree.Link,	init: BOOLEAN ¬ FALSE, scopeCheck: BOOLEAN ¬ TRUE]      RETURNS [val: Tree.Link] = {    nFields: CARDINAL;    ctx: CTXIndex;    sei: ISEIndex;    attr: Attr ¬ fullAttr;    exitNP: NPUse ¬ none;    EvaluateField: TreeOps.Map = {      subAttr: Attr;      type: CSEIndex;      IF sei # ISENull AND ~(syms.seb[sei].public OR init OR Shared[ctx]) THEN        Log.ErrorSei[noAccess, sei];      SELECT TRUE FROM	(t = Tree.Null) =>	  v ¬ SELECT TRUE FROM	    (sei = ISENull) => FieldVoid[t],	    (syms.seb[sei].extended) => FieldDefault[sei],	    (syms.seb[record].argument) => FieldVoid[t],	    ENDCASE => DefaultInit[syms.seb[sei].idType];	(OpName[syms, t] = void) => v ¬ FieldVoid[t];	ENDCASE => {	  target: CSEIndex =	    TargetType[IF sei=ISENull THEN typeANY ELSE UnderType[syms, syms.seb[sei].idType]];	  v ¬ IF init THEN Initialization[target, t] ELSE Rhs[t, target]};      subAttr ¬ RAttr[];  type ¬ RType[];  RPop[];      IF v = Tree.Null AND	  ~(IF syms.seb[sei].extended	      THEN VoidItem[FindExtension[syms, sei].tree]	      ELSE Voidable[syms.seb[sei].idType]) THEN Log.ErrorSei[elision, sei];      IF scopeCheck AND P3S.safety = checked THEN        IF TypeForm[syms, type] = transfer THEN v ¬ CheckScope[v, type];      attr ¬ And[attr, subAttr];  exitNP ¬ MergeNP[exitNP][phraseNP];      sei ¬ NextSe[syms, sei];      RETURN};    IF record = CSENull THEN {CheckLength[expList, 0]; sei ¬ ISENull}    ELSE {      CompleteRecord[record];      IF ~ContextComplete[syms.seb[record].fieldCtx] THEN {	IF syms.seb[record].hints.privateFields THEN Log.Error[noAccess];	sei ¬ ISENull}      ELSE {	ctx ¬ syms.seb[record].fieldCtx;	IF KeyedList[expList] THEN {	  sei: ISEIndex;	  started: BOOLEAN ¬ FALSE;	  NextKey: PROC RETURNS [HTIndex] = {	    SELECT TRUE FROM	      ~started => {sei ¬ FirstVisibleSe[syms, ctx]; started ¬ TRUE};	      (sei # ISENull) => sei ¬ NextVisibleSe[syms, sei];	      ENDCASE;	    RETURN [HashForSe[sei]]};	  OmittedValue: PROC RETURNS [t: Tree.Link] = {	    IF ~syms.seb[sei].extended AND (syms.seb[record].argument OR Default[syms.seb[sei].idType] = none)	     THEN {	      Log.ErrorHti[omittedKey, syms.seb[sei].hash];	      t ¬ [symbol[dataPtr.seAnon]]}	    ELSE t ¬ Tree.Null;	    RETURN};	  nFields ¬ ArrangeKeys[expList, NextKey, OmittedValue];	  expList ¬ PopKeyList[nFields]}	ELSE {	  nFields ¬ VisibleCtxEntries[syms, ctx];	  IF ListLength[syms, expList] < nFields THEN expList ¬ PadList[record, expList];	  CheckLength[expList, nFields]};	sei ¬ FirstVisibleSe[syms, ctx]}};    val ¬ UpdateList[syms, expList, EvaluateField];    RPush[record, attr];  phraseNP ¬ exitNP;  RETURN};  Dereference: PROC [t: Tree.Link, type: CSEIndex, long: BOOLEAN] RETURNS [Tree.Link] = {    PushTree[syms, t];  PushNode[syms, uparrow, 1];      SetInfo[syms, EncodeSei[type]];  SetAttr[syms, 2, long];    RETURN[PopTree[syms]]};  ClusterForType: PROC [type: CSEIndex] RETURNS [ctx: CTXIndex ¬ CTXNull] = {    WITH t: syms.seb[type] SELECT FROM      opaque => ctx ¬ syms.seb[t.id].idCtx;      record =>        IF ~t.argument THEN {	  rCtx: CTXIndex = t.fieldCtx;	  WITH c: syms.ctxb[rCtx] SELECT FROM	    simple => IF dataPtr.interface THEN ctx ¬ dataPtr.mainCtx;	    included => ctx ¬ MainIncludedCtx[c.module];	    ENDCASE};      ENDCASE;    RETURN};     -- operators  Initialization: PUBLIC PROC [type: CSEIndex, t: Tree.Link] RETURNS [v: Tree.Link] = {    WITH syms.seb[type] SELECT FROM      record =>        IF OpName[syms, t] = apply THEN {Construct[GetNode[syms, t], LOOPHOLE[type], TRUE]; v ¬ t}	ELSE v ¬ Rhs[t, type];      union =>        IF OpName[syms, t] = apply THEN {	  subType: CSEIndex = UnderType[syms, TypeForTree[NthSon[syms, t, 1]]];	  WITH syms.seb[subType] SELECT FROM	    record => {Construct[GetNode[syms, t], LOOPHOLE[subType], TRUE]; v ¬ t};	    ENDCASE => v ¬ Rhs[t, type]}	ELSE v ¬ Rhs[t, type];      array =>        IF OpName[syms, t] = all THEN {All[GetNode[syms, t], type, TRUE]; v ¬ t}	ELSE v ¬ Rhs[t, type];      ENDCASE => v ¬ Rhs[t, type];    RETURN};        Assignment: PUBLIC PROC [node: Tree.Index] = {    OPEN syms.tb[node];    lhsType, rhsType: CSEIndex;    attr: Attr;    saveNP: NPUse;    son[1] ¬ Exp[son[1], typeANY];  saveNP ¬ phraseNP;     lhsType ¬ RType[];  attr ¬ RAttr[];  RPop[];    son[2] ¬ Rhs[son[2], TargetType[lhsType]];     rhsType ¬ RType[];  attr ¬ And[RAttr[], attr];  RPop[];    attr.noAssign ¬ FALSE;  phraseNP ¬ MergeNP[phraseNP][saveNP];    RPush[rhsType, attr];    IF ~AssignableType[lhsType, P3S.safety=checked] THEN      Log.ErrorTree[nonLHS, son[1]];    SELECT syms.seb[lhsType].typeTag FROM      transfer => IF P3S.safety = checked THEN son[2] ¬ CheckScope[son[2], rhsType];      union =>	IF ~Types.Assignable[	 [syms, DiscriminatedType[typeANY, son[1]]],	 [syms, DiscriminatedType[typeANY, son[2]]]] THEN Log.ErrorTree[typeClash, son[2]];      sequence => Log.ErrorTree[typeClash, son[2]];      ENDCASE;    syms.tb[node].attr1 ¬ FALSE;    SELECT OperandLhs[son[1]] FROM      counted =>	SELECT RCType[syms, lhsType] FROM	  simple => {syms.tb[node].attr2 ¬ TRUE; syms.tb[node].attr3 ¬ FALSE};	  composite => {	    syms.tb[node].attr2 ¬ syms.tb[node].attr3 ¬ TRUE;	    EnterComposite[lhsType, son[2], FALSE]};	  ENDCASE => syms.tb[node].attr2 ¬ FALSE;      none => Log.ErrorTree[nonLHS, son[1]];      ENDCASE => syms.tb[node].attr2 ¬ FALSE};  implicitRecord: PUBLIC RecordSEIndex;    Extract: PUBLIC PROC [node: Tree.Index] = {    OPEN syms.tb[node];    type: CSEIndex;    attr: Attr;    ctx: CTXIndex;    sei: ISEIndex;    nL, nR: CARDINAL;    saveImplicit: P3S.ImplicitInfo = P3S.implicit;    saveRecord: RecordSEIndex = implicitRecord;    saveNP: NPUse;    PushItem: TreeOps.Map = {PushTree[syms, t]; RETURN [Tree.Null]};    Extractor: PROC [t: Tree.Link] RETURNS [BOOLEAN] = INLINE {      RETURN [OpName[syms, t] = apply AND NthSon[syms, t, 1] = Tree.Null]};    AssignItem: TreeOps.Map = {      saveType: CSEIndex = P3S.implicit.type;      IF sei # ISENull AND ~syms.seb[sei].public AND ~Shared[ctx] THEN        Log.ErrorSei[noAccess, sei];      IF t = Tree.Null THEN v ¬ Tree.Null      ELSE {	P3S.implicit.type ¬ IF sei = ISENull THEN typeANY ELSE UnderType[syms, syms.seb[sei].idType];	IF Extractor[t] THEN {	  subNode: Tree.Index = GetNode[syms, t];	  PushTree[syms, syms.tb[subNode].son[2]];	  syms.tb[subNode].son[2] ¬ Tree.Null;  FreeNode[syms, subNode];	  PushTree[syms, Tree.Null];  v ¬ MakeNode[syms, extract, 2];	  Extract[GetNode[syms, v]]}	ELSE {	  PushTree[syms, t];  PushTree[syms, Tree.Null];  v ¬ MakeNode[syms, assign, 2];	  Assignment[GetNode[syms, v]]};	attr ¬ And[RAttr[], attr];  saveNP ¬ MergeNP[saveNP][phraseNP];  RPop[]};      sei ¬ NextSe[syms, sei];      P3S.implicit.type ¬ saveType;  RETURN};    P3S.implicit.tree ¬ son[2] ¬ ExtractorRhs[son[2]];    type ¬ RType[];  P3S.implicit.attr ¬ attr ¬ RAttr[];  RPop[];    saveNP ¬ phraseNP;    IF type = CSENull THEN {nR ¬ 0;  sei ¬ ISENull}    ELSE {      type ¬ UnderType[syms, TypeRoot[syms, type]];      WITH syms.seb[type] SELECT FROM	record => {	  CompleteRecord[LOOPHOLE[type, RecordSEIndex]];	  IF ContextComplete[fieldCtx] THEN {	    implicitRecord ¬ LOOPHOLE[type, RecordSEIndex];	    ctx ¬ fieldCtx;  sei ¬ FirstVisibleSe[syms, ctx];	    nR ¬ VisibleCtxEntries[syms, ctx]}	  ELSE {Log.Error[noAccess]; type ¬ typeANY; nR ¬ 0; sei ¬ ISENull}};	ENDCASE => {	  Log.ErrorTree[typeClash, son[2]];	  type ¬ typeANY;  nR ¬ 0;  sei ¬ ISENull}};    IF KeyedList[son[1]] AND nR # 0 THEN {      sei: ISEIndex;      started: BOOLEAN ¬ FALSE;      NextKey: PROC RETURNS [HTIndex] = {	SELECT TRUE FROM	  ~started => {sei ¬ FirstVisibleSe[syms, ctx]; started ¬ TRUE};	  (sei # ISENull) => sei ¬ NextVisibleSe[syms, sei];	  ENDCASE;	RETURN [HashForSe[sei]]};      FillNull: PROC RETURNS [Tree.Link] = {RETURN [Tree.Null]};      nL ¬ ArrangeKeys[son[1], NextKey, FillNull]}    ELSE {      nL ¬ ListLength[syms, son[1]];      son[1] ¬ FreeTree[syms, UpdateList[syms, son[1], PushItem]];      IF nL > nR AND type # typeANY THEN Log.ErrorN[listLong, nL-nR];      THROUGH (nL .. nR] DO PushTree[syms, Tree.Null] ENDLOOP;      nL ¬ MAX[nL, nR]};    PushTree[syms, UpdateList[syms, MakeList[syms, nR], AssignItem]];    PushNode[syms, exlist, 1];  SetInfo[syms, EncodeSei[type]];      son[1] ¬ PopTree[syms];    RPush[type, attr];  phraseNP ¬ saveNP;    P3S.implicit ¬ saveImplicit; implicitRecord ¬ saveRecord};    ExtractorRhs: PROC [t: Tree.Link] RETURNS [v: Tree.Link] = INLINE {      SELECT OpName[syms, t] FROM	apply => {	  node: Tree.Index = Apply[GetNode[syms, t], typeANY, FALSE];	  syms.tb[node].info ¬ EncodeSei[RType[]];  v ¬ [subtree[node]]};	signalx, errorx, joinx, startx => {	  PushTree[syms, MiscXfer[GetNode[syms, t], typeANY]];  	  SetInfo[syms, EncodeSei[RType[]]];  v ¬ PopTree[syms]};	ENDCASE => v ¬ Exp[t, typeANY];      RETURN};  self: PUBLIC P3S.SelfInfo;    Dot: PUBLIC PROC [node: Tree.Index, target: CSEIndex] RETURNS [Tree.Index] = {    IF DotExpr[node].selfAppl THEN {      saveSelf: P3S.SelfInfo = self;      v: Tree.Link = syms.tb[node].son[2];      self ¬ [tree: syms.tb[node].son[1], type: RType[], attr: RAttr[], np: phraseNP];      RPop[];  syms.tb[node].son[1] ¬ syms.tb[node].son[2] ¬ Tree.Null;  FreeNode[syms, node];      node ¬ GetNode[syms, Exp[ApplyToSelf[v, Tree.Null, Tree.Null], target]];      self ¬ saveSelf};    RETURN [node]};  DotExpr: PROC [node: Tree.Index] RETURNS [selfAppl: BOOLEAN ¬ FALSE] = {    OPEN syms.tb[node];    type, lType, rType: CSEIndex;    sei: ISEIndex;    fieldHti: HTIndex = GetHash[syms, son[2]];    attr: Attr;    nDerefs: CARDINAL ¬ 0;    son[1] ¬ Exp[son[1], typeANY];  type ¬ lType ¬ RType[]; attr ¬ RAttr[]; RPop[];    -- N.B. failure is avoided only by EXITing the following loop    DO      nType: CSEIndex = NormalType[syms, type];      WITH t: syms.seb[nType] SELECT FROM	record => {	  nHits: CARDINAL;	  [nHits, sei] ¬ FieldId[fieldHti, LOOPHOLE[nType, RecordSEIndex]];	  SELECT nHits FROM	    0 => {	      matched: BOOLEAN;	      [matched, sei] ¬ ClusterId[fieldHti, ClusterForType[nType]];	      IF matched AND XferMode[syms, syms.seb[sei].idType] # none THEN {		name ¬ cdot;  selfAppl ¬ TRUE;  attr2 ¬ FALSE;		son[2] ¬ [symbol[sei]];  rType ¬ lType;		attr.const ¬ ConstantId[syms, sei];		EXIT};	      IF Bundling[nType] = 0 THEN GO TO nomatch};	    1 => {	      long: BOOLEAN ¬ LongPath[son[1]];	      counted: BOOLEAN ¬ TRUE;	      WHILE lType # type DO	-- rederive path, update tree		subType: CSEIndex = NormalType[syms, lType];		WITH s: syms.seb[subType] SELECT FROM		  ref => {		    long ¬ syms.seb[lType].typeTag = long;		    lType ¬ UnderType[syms, s.refType];		    IF ~s.counted THEN counted ¬ FALSE;		    IF nDerefs > 1 OR lType # type THEN {		      son[1] ¬ Dereference[son[1], lType, long]; nDerefs ¬ nDerefs-1}};		  record => {		    lType ¬ Unbundle[LOOPHOLE[subType, RecordSEIndex]];		    son[1] ¬ ForceType[son[1], lType]};		  ENDCASE;		ENDLOOP;	      IF nDerefs = 0 THEN name ¬ dollar;	      attr2 ¬ long;	      IF ~attr.const AND ConstantId[syms, sei] THEN {name ¬ cdot; attr.const ¬ TRUE};	      IF P3S.safety = checked AND ~counted THEN	        Log.ErrorNode[unsafeOperation, node];	      son[2] ¬ [symbol[sei]];  rType ¬ UnderType[syms, syms.seb[sei].idType];	      EXIT};	    ENDCASE => GO TO ambiguous;	  type ¬ Unbundle[LOOPHOLE[nType, RecordSEIndex]]};	opaque => {	  matched: BOOLEAN;	  [matched, sei] ¬ ClusterId[fieldHti, ClusterForType[nType]];	  IF matched AND XferMode[syms, syms.seb[sei].idType] # none THEN {	    name ¬ cdot;  selfAppl ¬ TRUE;  attr2 ¬ FALSE;	    son[2] ¬ [symbol[sei]];  rType ¬ lType;	    attr.const ¬ ConstantId[syms, sei];	    EXIT};	  GO TO nomatch};	ref => {	  IF (nDerefs ¬ nDerefs+1) > 63 THEN GO TO nomatch;	  type ¬ UnderType[syms, t.refType];  attr.const ¬ FALSE};	definition, transfer =>	  IF ([sei: sei]¬InterfaceId[fieldHti, InterfaceCtx[nType, son[1]]]).found THEN {	    name ¬ cdot;  son[2] ¬ [symbol[sei]];  attr2 ¬ FALSE;	    rType ¬ type ¬ UnderType[syms, syms.seb[sei].idType];	    attr.const ¬ ConstantId[syms, sei];	    IF VarType[type] OR 	     (syms.ctxb[syms.seb[sei].idCtx].ctxType = imported AND	      ~dataPtr.interface AND TypeForm[syms, NormalType[syms, type]] = ref) THEN {	      rType ¬ UnderType[syms, ReferentType[syms, type]]; 	      son[2] ¬ Dereference[son[2], rType, TRUE]};	    EXIT}	  ELSE GOTO nomatch;	mode => {	  rType ¬ NormalType[syms, UnderType[syms, TypeForTree[syms.tb[node].son[1]]]];	  WITH t: syms.seb[rType] SELECT FROM	    enumerated =>	      IF ([sei: sei]¬SearchCtxList[fieldHti, t.valueCtx]).found THEN	        name ¬ cdot	      ELSE GOTO nomatch;	    record => {	      sei ¬ SelectVariantType[rType,  fieldHti];	      rType ¬ typeTYPE;  name ¬ discrimTC};	    ENDCASE => GO TO nomatch;	  son[2] ¬ [symbol[sei]];  attr2 ¬ FALSE;  attr.const ¬ TRUE;  EXIT};	ENDCASE => GO TO nomatch;      REPEAT	nomatch => {	  son[2] ¬ [symbol[dataPtr.seAnon]];	  IF son[1] # son[2] AND fieldHti # HTNull THEN	    Log.ErrorHti[unknownField, fieldHti];	  rType ¬ typeANY;  attr ¬ emptyAttr};	ambiguous => {	  Log.ErrorHti[ambiguousId, fieldHti];	  son[2] ¬ [symbol[dataPtr.seAnon]];	  rType ¬ typeANY;  attr ¬ emptyAttr};      ENDLOOP;    syms.tb[node].info ¬ EncodeSei[rType];  RPush[rType, attr];  RETURN};  -- copied from Pass3I, should move to P3 if room  VarType: PROC [type: CSEIndex] RETURNS [BOOLEAN] = INLINE {    subType: CSEIndex = NormalType[syms, type];    RETURN [WITH t: syms.seb[subType] SELECT FROM      ref => t.var,      ENDCASE => FALSE]};        Apply: PUBLIC PROC [node: Tree.Index, target: CSEIndex, mustXfer: BOOLEAN]       RETURNS [Tree.Index] = {    opType, type: CSEIndex;    attr: Attr;    leftNP: NPUse;    long: BOOLEAN;    nDerefs: CARDINAL ¬ 0;    indirect: BOOLEAN ¬ FALSE;    string, desc: BOOLEAN ¬ FALSE;    saveSelf: P3S.SelfInfo = self;    ForceDirect: PROC = {      IF indirect THEN {        syms.tb[node].son[1] ¬ Dereference[syms.tb[node].son[1], opType, long];	attr.const ¬ FALSE};      indirect ¬ FALSE};	    IF syms.tb[node].son[1] # Tree.Null THEN {      IF OpName[syms, syms.tb[node].son[1]] = dot AND ~syms.tb[node].attr1 THEN node ¬ DotApply[node]      ELSE	WITH t: syms.seb[target] SELECT FROM	  union => {	    PushCtx[t.caseCtx]; syms.tb[node].son[1] ¬ Exp[syms.tb[node].son[1], typeANY]; PopCtx[]};	  ENDCASE => syms.tb[node].son[1] ¬ Exp[syms.tb[node].son[1], typeANY];       opType ¬ RType[];  attr ¬ RAttr[];  leftNP ¬ phraseNP;  RPop[];      IF opType = typeTYPE THEN type ¬ UnderType[syms, TypeForTree[syms.tb[node].son[1]]]}    ELSE {      opType ¬ typeTYPE;      SELECT syms.seb[target].typeTag FROM	record => type ¬ UnderType[syms, TypeRoot[syms, target]];	array => type ¬ target;	ENDCASE => {type ¬ CSENull; Log.ErrorNode[noTarget, node]}};    long ¬ LongPath[syms.tb[node].son[1]];    -- dereferencing/deproceduring loop    DO      OPEN syms.tb[node];      nType: CSEIndex = NormalType[syms, opType];      WITH t: syms.seb[nType] SELECT FROM	mode => {	  ForceDirect[];	  SELECT TypeForm[syms, NormalType[syms, type]] FROM	    record => Construct[node, LOOPHOLE[type, RecordSEIndex]];	    array => RowCons[node, LOOPHOLE[type, ArraySEIndex]];	    enumerated, basic => {	      temp: Tree.Link = son[1];	      IF UniOperand[node] THEN 	        son[2] ¬ RhsPrime[son[2], TargetType[type], TRUE];	      attr ¬ And[RAttr[], attr];  phraseNP ¬ MergeNP[leftNP][phraseNP];  RPop[];	      son[1] ¬ son[2];  son[2] ¬ temp;	      name ¬ check;  RPush[type, attr]};	    ENDCASE => ApplyError[node, type # CSENull];	  EXIT};	transfer => {	  mode: TransferMode = t.mode;	  OpName: ARRAY TransferMode OF Tree.NodeName = [	    proc: callx, port: portcallx, signal: signalx, error: errorx,	    process: joinx, program: startx, none: apply];	  ForceDirect[];	  SELECT mode FROM	    proc =>	      IF ~P3S.currentBody.lockHeld AND OperandInternal[son[1]] THEN	        Log.ErrorTree[internalCall, son[1]];	    program =>	      IF BodyForTree[son[1]] # CBTNull THEN Log.ErrorTree[typeClash, son[1]];	    port => IF long THEN Log.ErrorTree[long, son[1]];	    ENDCASE;	  IF t.typeIn = CSENull THEN	    son[2] ¬ MatchFields[RecordSENull, son[2], FALSE, FALSE]	  ELSE	    WITH in: syms.seb[t.typeIn] SELECT FROM	      record =>	        son[2] ¬ IF attr1		  THEN Rhs[son[2], t.typeIn]		  ELSE MatchFields[LOOPHOLE[t.typeIn], son[2], FALSE, mode=program];	      ENDCASE => {	        Log.ErrorTree[typeClash, son[1]];		son[2] ¬ MatchFields[RecordSENull, son[2], FALSE, FALSE]}; 	  name ¬ OpName[mode];	  attr ¬ And[RAttr[], attr];  phraseNP ¬ MergeNP[leftNP][phraseNP];	  RPop[];	  IF P3S.safety = checked THEN	    IF ~(t.safe OR mode = error) OR mode = port OR mode = process THEN	      Log.ErrorNode[unsafeOperation, node];	  IF mode = proc THEN attr ¬ CheckInline[node, attr]	  ELSE {attr.noXfer ¬ attr.noAssign ¬ FALSE;  phraseNP ¬ SetNP[phraseNP]};	  attr.const ¬ FALSE;  RPush[t.typeOut, attr];	  EXIT};	array => {	  ForceDirect[];	  IF UniOperand[node] THEN	    syms.tb[node].son[2] ¬ Rhs[syms.tb[node].son[2], TargetType[UnderType[syms, t.indexType]]];	  attr ¬ And[RAttr[], attr];  phraseNP ¬ MergeNP[leftNP][phraseNP];  RPop[];	  RPush[UnderType[syms, t.componentType], attr];	  name ¬ SELECT TRUE FROM string => seqindex, desc => dindex, ENDCASE => index;	  attr2 ¬ long;	  IF mustXfer THEN {opType ¬ ForceXfer[node];  mustXfer ¬ FALSE}  -- to avoid looping	  ELSE EXIT};	sequence => {	  ForceDirect[];	  IF UniOperand[node] THEN	    syms.tb[node].son[2] ¬ Rhs[syms.tb[node].son[2], TargetType[UnderType[syms, syms.seb[t.tagSei].idType]]];	  attr ¬ And[RAttr[], attr];  phraseNP ¬ MergeNP[leftNP][phraseNP];  RPop[];	  RPush[UnderType[syms, t.componentType], attr];	  name ¬ seqindex;  attr2 ¬ long;	  IF mustXfer THEN {opType ¬ ForceXfer[node];  mustXfer ¬ FALSE}  -- to avoid looping	  ELSE EXIT};	arraydesc => {	  ForceDirect[];	  long ¬ syms.seb[opType].typeTag = long;	  opType ¬ UnderType[syms, t.describedType]; attr.const ¬ FALSE;  desc ¬ TRUE;	  IF P3S.safety = checked THEN Log.ErrorNode[unsafeOperation, node]};	ref => {	  subType: CSEIndex;	  SELECT TRUE FROM	    t.basing => {	      ForceDirect[];	      IF UniOperand[node] THEN syms.tb[node].son[2] ¬ Rhs[syms.tb[node].son[2], typeANY];	      attr ¬ And[RAttr[], attr];  phraseNP ¬ MergeNP[leftNP][phraseNP];	      subType ¬ CanonicalType[RType[]];  RPop[];	      WITH r: syms.seb[subType] SELECT FROM		relative => {		  IF ~Types.Assignable[[syms, UnderType[syms, r.baseType]], [syms, opType]] THEN		    Log.ErrorTree[typeClash, son[1]];		  type ¬ UnderType[syms, r.resultType]};		ENDCASE => {		  type ¬ typeANY;		  IF subType # typeANY THEN Log.ErrorTree[typeClash, son[2]]};	      subType ¬ NormalType[syms, type];	      attr1 ¬ TypeForm[syms, subType] = arraydesc;	      attr2 ¬ TypeForm[syms, opType] = long OR TypeForm[syms, type] = long;	      WITH r: syms.seb[subType] SELECT FROM		ref => type ¬ UnderType[syms, r.refType];		arraydesc => type ¬ UnderType[syms, r.describedType];		ENDCASE;	      attr.const ¬ FALSE;  RPush[type, attr];  name ¬ reloc;	      IF P3S.safety = checked THEN Log.ErrorNode[unsafeOperation, node];	      IF mustXfer THEN {opType ¬ ForceXfer[node];  mustXfer ¬ FALSE}  -- to avoid looping	      ELSE EXIT};	    ENDCASE => {	      subType ¬ UnderType[syms, t.refType];  attr.const ¬ FALSE;	      WITH r: syms.seb[subType] SELECT FROM		record =>		  IF syms.ctxb[r.fieldCtx].level = lG THEN {		    ForceDirect[];		    opType ¬ XferForFrame[r.fieldCtx];		    IF opType = CSENull THEN GO TO fail;		    son[1] ¬ ForceType[son[1], opType]}		  ELSE GO TO deRef;		ENDCASE => GO TO deRef;	      EXITS		deRef => {		  IF (nDerefs ¬ nDerefs+1) > 63 THEN GO TO fail;		  IF indirect THEN ForceDirect[];		  IF P3S.safety = checked AND ~t.counted THEN		    Log.ErrorNode[unsafeOperation, node];		  indirect ¬ TRUE;  long ¬ syms.seb[opType].typeTag = long;		  opType ¬ subType}}};	record => {	  rSei: RecordSEIndex = LOOPHOLE[nType];	  sei: ISEIndex = SequenceField[rSei];	  SELECT TRUE FROM	    (sei # ISENull) => {	      PushSe[syms, sei];	      opType ¬ UnderType[syms, syms.seb[sei].idType];	      PushTree[syms, son[1]];	      PushNode[syms, IF indirect THEN dot ELSE dollar, -2];	      SetInfo[syms, EncodeSei[opType]];  SetAttr[syms, 2, long];	      son[1] ¬ PopTree[syms];  indirect ¬ FALSE};	    (rSei = dataPtr.typeStringBody) => {	      textSei: ISEIndex = NextSe[syms, NextSe[syms, FirstVisibleSe[syms, syms.seb[rSei].fieldCtx]]];	      PushSe[syms, textSei];	      attr.const ¬ FALSE; string ¬ TRUE;  opType ¬ UnderType[syms, syms.seb[textSei].idType];	      PushTree[syms, son[1]];	      PushNode[syms, IF indirect THEN dot ELSE dollar, -2]; 	      SetInfo[syms, EncodeSei[opType]];  SetAttr[syms, 2, long];	      son[1] ¬ PopTree[syms];  indirect ¬ FALSE};	    (rSei = dataPtr.typeCONDITION) => {	      ForceDirect[];	      IF son[2] # Tree.Null THEN Log.ErrorN[listLong, ListLength[syms, son[2]]];	      RPush[CSENull, attr];	      name ¬ wait;  phraseNP ¬ SetNP[phraseNP];	      EXIT};	    (Bundling[rSei] # 0) => {	      ForceDirect[]; opType ¬ Unbundle[rSei]; son[1] ¬ ForceType[son[1], opType]};	    ENDCASE => GO TO fail};	ENDCASE => GO TO fail;      REPEAT	fail => ApplyError[node, opType#typeANY OR nDerefs#0];      ENDLOOP;    IF syms.tb[node].nSons > 2 THEN {      saveNP: NPUse = phraseNP;      SELECT syms.tb[node].name FROM	callx, portcallx, signalx, errorx, startx, fork, joinx, wait, apply => NULL;	ENDCASE => Log.Error[misplacedCatch];      [] ¬ CatchPhrase[syms.tb[node].son[3]];  phraseNP ¬ MergeNP[saveNP][phraseNP]};    IF syms.tb[node].attr1 THEN      SELECT syms.tb[node].name FROM	callx, portcallx, signalx, errorx, startx, fork, joinx, apply => NULL;	reloc => NULL;	ENDCASE => Log.ErrorTree[typeClash, syms.tb[node].son[1]];    IF RType[] = CSENull THEN      syms.tb[node].name ¬ SELECT syms.tb[node].name FROM	callx => call,	portcallx => portcall,	signalx => signal,	errorx => error,	startx => start,	joinx => join,	ENDCASE => syms.tb[node].name;    self ¬ saveSelf;    RETURN [node]};    UniOperand: PROC [node: Tree.Index] RETURNS [unit: BOOLEAN] = {      unit ¬ (ListLength[syms, syms.tb[node].son[2]] = 1);      IF ~unit THEN {	CheckLength[syms.tb[node].son[2], 1];	syms.tb[node].son[2] ¬ UpdateList[syms, syms.tb[node].son[2], VoidExp];	RPush[typeANY, emptyAttr]}      ELSE IF KeyedList[syms.tb[node].son[2]] THEN Log.Error[keys]};	    ApplyError: PROC [node: Tree.Index, warn: BOOLEAN] = {      IF warn THEN Log.ErrorTree[noApplication, syms.tb[node].son[1]];      syms.tb[node].son[2] ¬ UpdateList[syms, syms.tb[node].son[2], VoidExp];      RPush[typeANY, emptyAttr]};    ForceXfer: PROC [node: Tree.Index] RETURNS [opType: CSEIndex] = {      opType ¬ RType[];  RPop[];      IF syms.tb[node].nSons > 2 THEN Log.Error[misplacedCatch];      PushTree[syms, syms.tb[node].son[1]];  PushTree[syms, syms.tb[node].son[2]];      PushNode[syms, syms.tb[node].name, 2];        SetInfo[syms, EncodeSei[opType]];  SetAttr[syms, 2, syms.tb[node].attr2];      SetAttr[syms, 1, syms.tb[node].attr1];  syms.tb[node].attr1 ¬ FALSE;      syms.tb[node].son[1] ¬ PopTree[syms];  syms.tb[node].son[2] ¬ Tree.Null;      syms.tb[node].name ¬ apply;  RETURN};  DotApply: PROC [node: Tree.Index] RETURNS [Tree.Index] = {    subNode: Tree.Index = GetNode[syms, syms.tb[node].son[1]];    IF DotExpr[subNode].selfAppl THEN {      op: Tree.Link = syms.tb[subNode].son[2];      args: Tree.Link = syms.tb[node].son[2];      catch: Tree.Link;      syms.tb[node].son[2] ¬ Tree.Null;      IF syms.tb[node].nSons > 2 THEN {catch ¬ syms.tb[node].son[3]; syms.tb[node].son[3] ¬ Tree.Null}      ELSE catch ¬ Tree.Null;      self ¬ [tree:syms.tb[subNode].son[1], type:RType[], attr:RAttr[], np:phraseNP];      syms.tb[subNode].son[1] ¬ syms.tb[subNode].son[2] ¬ Tree.Null;      RPop[];  FreeNode[syms, node];      node ¬ GetNode[syms, ApplyToSelf[op, args, catch]];      syms.tb[node].son[1] ¬ Exp[syms.tb[node].son[1], typeANY]};    RETURN [node]};	  ApplyToSelf: PROC [op, args, catch: Tree.Link] RETURNS [Tree.Link] = {    n: CARDINAL ¬ 1;    PushArg: TreeOps.Map = {PushTree[syms, t]; n ¬ n+1; RETURN [Tree.Null]};    PushTree[syms, op];    IF KeyedList[args] THEN {      sei: ISEIndex = FirstCtxSe[syms, ArgCtx[syms, TransferTypes[syms, OperandType[op]].typeIn]];      PushHash[syms, IF sei # ISENull THEN syms.seb[sei].hash ELSE HTNull];      PushNode[syms, self, 0];  PushNode[syms, item, 2]}    ELSE PushNode[syms, self, 0];    args ¬ FreeTree[syms, UpdateList[syms, args, PushArg]];    PushList[syms, n];    IF catch = Tree.Null THEN PushNode[syms, apply, 2]    ELSE {PushTree[syms, catch]; PushNode[syms, apply, 3]};    SetInfo[syms, EncodeCard[dataPtr.textIndex]];  SetAttr[syms, 1, FALSE];    RETURN [PopTree[syms]]};  Construct: PROC [node: Tree.Index, type: RecordSEIndex, init: BOOLEAN ¬ FALSE] = {    OPEN syms.tb[node];    cType: CSEIndex ¬ type;    attr: Attr;    t: Tree.Link;    son[2] ¬ MatchFields[type, son[2], init];  attr ¬ RAttr[];  RPop[];    WITH r: syms.seb[type] SELECT FROM      linked => {name ¬ union; cType ¬ VariantUnionType[r.linkType]};      ENDCASE => {	name ¬ construct;	IF r.hints.variant AND (t¬ListTail[syms, son[2]]) # Tree.Null THEN	  cType ¬ DiscriminatedType[type, t]};    info ¬ EncodeSei[cType];  RPush[cType, attr]};  RowCons: PROC [node: Tree.Index, aType: ArraySEIndex] = {    OPEN syms.tb[node];    componentType: SEIndex = syms.seb[aType].componentType;    iType: CSEIndex = UnderType[syms, syms.seb[aType].indexType];    cType: CSEIndex = TargetType[UnderType[syms, componentType]];    attr: Attr ¬ fullAttr;    exitNP: NPUse ¬ none;    MapValue: TreeOps.Map = {      type: CSEIndex;      subAttr: Attr;      v ¬ SELECT TRUE FROM	(t = Tree.Null) => DefaultInit[componentType],	(OpName[syms, t] = void) => FieldVoid[t],	ENDCASE => Rhs[t, cType];      subAttr ¬ RAttr[];  type ¬ RType[];  RPop[];      IF v = Tree.Null THEN VoidComponent[componentType];      IF P3S.safety = checked AND TypeForm[syms, type] = transfer THEN        v ¬ CheckScope[v, type];      exitNP ¬ MergeNP[exitNP][phraseNP];  attr ¬ And[attr, subAttr];  RETURN};    IF KeyedList[son[2]] OR (son[2] = Tree.Null AND TypeForm[syms, TargetType[iType]] = enumerated)     THEN {      keyType: CSEIndex = TargetType[iType];      vCtx: CTXIndex;      first, last, i: Copier.SEToken;      hti: HTIndex;      NextKey: PROC RETURNS [HTIndex] = {	IF i = last THEN hti ¬ HTNull	ELSE {	  i ¬ IF i = Copier.NullSEToken THEN first ELSE Copier.CtxNext[syms, vCtx, i];	  hti ¬ KeyForHash[Copier.TokenHash[syms, vCtx, i]]};	RETURN [hti]};      OmittedValue: PROC RETURNS [t: Tree.Link] = {	IF Default[componentType] # none THEN t ¬ Tree.Null	ELSE {Log.ErrorHti[omittedKey, hti]; t ¬ [symbol[dataPtr.seAnon]]};	RETURN};      WITH t: syms.seb[keyType] SELECT FROM	enumerated => {	  vCtx ¬ t.valueCtx;	  [first, last] ¬ Span[iType];	  IF first # Copier.NullSEToken AND last # Copier.NullSEToken	   AND Copier.TokenValue[syms, vCtx, first] <= Copier.TokenValue[syms, vCtx, last] THEN {	    i ¬ Copier.NullSEToken;	    son[2] ¬ PopKeyList[ArrangeKeys[son[2], NextKey, OmittedValue]]}	  ELSE Log.Error[keys]};	ENDCASE => Log.Error[keys]};    son[2] ¬ UpdateList[syms, son[2], MapValue];    name ¬ rowcons;  info ¬ EncodeSei[aType];  RPush[aType, attr];  phraseNP ¬ exitNP};  All: PUBLIC PROC [node: Tree.Index, target: CSEIndex, init: BOOLEAN ¬ FALSE] = {    OPEN syms.tb[node];    t: Tree.Link = son[1];    l: CARDINAL = ListLength[syms, t];    attr: Attr;    SELECT l FROM      0, 1 => {	WITH syms.seb[target] SELECT FROM	  array => {	    cType: CSEIndex = TargetType[UnderType[syms, componentType]];	    type: CSEIndex;	    son[1] ¬ SELECT TRUE FROM	      (t = Tree.Null) => --IF init THEN-- DefaultInit[componentType],	      (OpName[syms, t] = void) => FieldVoid[t],	      ENDCASE => Rhs[t, cType];	    type ¬ RType[];  attr ¬ RAttr[];  RPop[];	    IF son[1] = Tree.Null THEN VoidComponent[componentType];	    IF P3S.safety = checked AND TypeForm[syms, type] = transfer THEN	      son[1] ¬ CheckScope[son[1], type];	    attr.const ¬ FALSE};	  ENDCASE => {	    Log.ErrorNode[noTarget, node]; 	    son[1] ¬ VoidExp[syms, son[1]]; 	    attr ¬ emptyAttr}};      ENDCASE => {	Log.ErrorN[listLong, l-1]; son[1] ¬ UpdateList[syms, son[1], VoidExp]; attr ¬ emptyAttr};    info ¬ EncodeSei[target];  RPush[target, attr]};  VoidComponent: PROC [type: SEIndex] = {    IF ~Voidable[type] THEN      Log.ErrorSei[elision, IF syms.seb[type].seTag = id THEN LOOPHOLE[type] ELSE dataPtr.seAnon]};          CheckInline: PROC [node: Tree.Index, attr: Attr] RETURNS [Attr] = {    bti: CBTIndex = BodyForTree[syms.tb[node].son[1]];    IF bti = CBTNull THEN {      P3S.currentBody.noXfers ¬ attr.noXfer ¬ FALSE;      attr.noAssign ¬ FALSE; phraseNP ¬ SetNP[phraseNP]}    ELSE {      IF ~syms.bb[bti].inline THEN P3S.currentBody.noXfers ¬ attr.noXfer ¬ FALSE      ELSE	WITH body: syms.bb[bti].info SELECT FROM	  Internal => {	    SELECT OpName[syms, syms.tb[node].son[1]] FROM	      dot, dollar => Log.ErrorTree[misusedInline, syms.tb[node].son[1]];	      ENDCASE;	    PushTree[syms, syms.tb[node].son[1]];	    PushTree[syms, [subtree[index: body.thread]]];	    PushNode[syms, thread, 2]; SetAttr[syms, 1, FALSE]; 	    SetInfo[syms, EncodeBti[P3S.currentScope]];	    syms.tb[node].son[1] ¬ PopTree[syms];	    body.thread ¬ node;  SetShared[syms, [subtree[node]], TRUE];	    syms.tb[node].attr3 ¬ --attr.noXfer AND-- attr.noAssign;	    IF ~syms.bb[bti].noXfers THEN	      P3S.currentBody.noXfers ¬ attr.noXfer ¬ FALSE};	  ENDCASE => ERROR;      IF ~syms.bb[bti].hints.safe THEN {        attr.noAssign ¬ FALSE; phraseNP ¬ SetNP[phraseNP]}};    RETURN [attr]};  InterfaceCtx: PUBLIC PROC [type: CSEIndex, v: Tree.Link] RETURNS [ctx: CTXIndex] = {    WITH t: syms.seb[type] SELECT FROM      definition => ctx ¬ t.defCtx;      transfer => {        bti: CBTIndex = BodyForTree[v];	ctx ¬ IF bti = CBTNull OR t.mode # program	  THEN CTXNull ELSE syms.bb[bti].localCtx};      ENDCASE => ctx ¬ CTXNull;    RETURN};      }.
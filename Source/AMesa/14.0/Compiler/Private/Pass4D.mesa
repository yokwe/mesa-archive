-- Copyright (C) 1983, 1984, 1986, 1987  by Xerox Corporation. All rights reserved. -- file Pass4D.mesa--   Satterthwaite,	October 11, 1982 8:56 am--   Sweet,		 3-Jan-84 15:51:28--   Johnsson,		11-Jun-83 14:14:58--   Wagner		22-Aug-86 11:07:55--   Saxe		17-Apr-87 11:35:45DIRECTORY  ComData USING [interface, mainCtx, textIndex, typeCARDINAL],  PrincOps USING [globalbase, localbase],  CLog USING [Error, ErrorSei, ErrorTree, Warning],  MDRDefs USING [    defaultBitOption, defaultMD, FromTreeInfo, MDStatus],  P4 USING [    Repr, none, signed, unsigned, both, other, mark, ownGfi,    currentLevel, CheckOver,    AdjustBias, BitsForType, CheckFields, ConstantInterval, EmptyInterval,    ForceType, Interval, LayoutArgs, LayoutFields, NeutralExp,    RewriteAssign, Rhs, StructuredLiteral, TreeLiteral, TreeLiteralValue,    VPop, VProp, VRep],  Symbols USING [    ExtensionType, SEIndex, ISEIndex, CSEIndex, RecordSEIndex,    CTXIndex, CBTIndex, BitAddress, WordLength,    SENull, CBTNull, codeANY, codeCHAR, codeINT, lG, lZ, RootBti,    typeANY, typeTYPE, DummyLink],  SymbolOps USING [    ArgRecord, Cardinality, ConstantId, CtxEntries, EnterExtension,    FindExtension, FirstCtxSe, FromBitAddr, FromBti, FromCard, FromSei, LinkMode,     NextSe, NormalType, RCType, SearchContext, ToBti, ToCard, ToSei, ToTreeIndex, TypeLink,     UnderType, WordsForType],  SymbolTable USING [Handle],  Tree USING [Index, Link, NodeName, Null],  TreeOps USING [    DecodeBti, DecodeCard, DecodeCSei, DecodeSei, EncodeBti, EncodeSei,     CopyTree, FreeNode, FreeTree, GetNode, IdentityMap, ListHead, ListLength,    Map, NthSon, OpName, PopTree, PushList, PushNode, PushTree,    Scan, ScanList, SetAttr, SetInfo, UpdateList];Pass4D: PROGRAM    IMPORTS      Log: CLog, P4, MDRDefs, SymbolOps, TreeOps,      dataPtr: ComData    EXPORTS P4 = {  OPEN TreeOps, SymbolOps, Symbols;  syms: SymbolTable.Handle;    Pass4DInit: PUBLIC PROC [h: SymbolTable.Handle] = { syms ¬ h };  VarInit: PUBLIC SIGNAL RETURNS [BOOLEAN] = CODE;  ownGfi: CARDINAL = P4.ownGfi;  ItemId: PROC [t: Tree.Link] RETURNS [ISEIndex] = {    RETURN [WITH t SELECT FROM      symbol => index,      subtree => ItemId[syms.tb[index].son[1]],      ENDCASE => ERROR]};  FirstId: PROC [node: Tree.Index] RETURNS [ISEIndex] = {    RETURN [ItemId[ListHead[syms, syms.tb[node].son[1]]]]};  DeclItem: PUBLIC PROC [h: SymbolTable.Handle, t: Tree.Link] = {    node: Tree.Index = GetNode[syms, t];    initFlag, eqFlag: BOOLEAN;    ExpInit: PROC = INLINE {      OPEN syms.tb[node];      type: CSEIndex = UnderType[syms, TypeForDecl[node]];      son[3] ¬ P4.Rhs[son[3], type];      IF eqFlag THEN {	t: Tree.Link ¬ son[3];	WHILE OpName[syms, t] = cast DO t ¬ NthSon[syms, t, 1] ENDLOOP;	IF P4.TreeLiteral[t] THEN {	  DefineSEValue[ids:son[1], value:P4.TreeLiteralValue[t]]; GO TO defined};	IF P4.VProp[].noFreeVar THEN {	  DefineSEValue[ids:son[1]];	  AugmentSEValue[son[1], value, son[3]]; son[3] ¬ Tree.Null; GO TO defined};	IF syms.seb[type].typeTag = transfer THEN	  WITH t SELECT FROM	    symbol => {	      sei: ISEIndex = index;	      IF syms.seb[sei].constant THEN {		DefineSEValue[		  ids:son[1], 		  value: syms.seb[sei].idValue, 		  info:ToBti[syms.seb[sei].idInfo]];		IF syms.seb[sei].extended THEN		  AugmentSEValue[son[1], form, FindExtension[syms, sei].tree, TRUE];		GO TO defined}};	    ENDCASE;	DefineSEVar[ids:son[1]];	EXITS	  defined => son[3] ¬ FreeTree[syms, son[3]]};      SELECT syms.seb[NormalType[syms, type]].typeTag FROM	ref, arraydesc, relative =>	  IF ListLength[syms, son[1]] # 1 AND son[3] # Tree.Null	   AND ~P4.StructuredLiteral[son[3]] THEN	    Log.Warning[pointerInit];	ENDCASE;      P4.VPop[]};    BodyInit: PROC = INLINE {      expNode: Tree.Index = GetNode[syms, syms.tb[node].son[3]];      bti: CBTIndex = DecodeBti[syms.tb[expNode].info];      IF eqFlag THEN {	IF syms.tb[expNode].attr3 THEN {  -- inline	  DefineSEValue[ids:syms.tb[node].son[1], info:bti];	  AugmentSEValue[syms.tb[node].son[1], form,	      IF dataPtr.interface THEN TrimTree[syms, syms.tb[node].son[3]] ELSE Tree.Null]}	ELSE DefineSEValue[	      ids: syms.tb[node].son[1],	      value: Symbols.DummyLink[ep: syms.bb[bti].entryIndex, gfi: P4.ownGfi], 	      info: bti];	syms.tb[node].son[3] ¬ Tree.Null}      ELSE {        PushNode[syms, body, 0]; SetInfo[syms, EncodeBti[bti]];         syms.tb[node].son[3] ¬ PopTree[syms]}};    saveIndex: CARDINAL = dataPtr.textIndex;    IF syms.tb[node].attr3 = P4.mark THEN RETURN;	-- already processed    syms.tb[node].attr3 ¬ P4.mark;    dataPtr.textIndex ¬ DecodeCard[syms.tb[node].info];    initFlag ¬ (syms.tb[node].son[3] # Tree.Null);    IF syms.tb[node].name = typedecl THEN {      ENABLE VarInit => {RESUME [FALSE]};      TypeExp[syms.tb[node].son[2]];  CheckDefaults[t]}    ELSE {      OPEN syms.tb[node];      op: Tree.NodeName = OpName[syms, son[3]];      IF son[2] # Tree.Null THEN TypeExp[son[2], op = body];      IF initFlag THEN {	eqFlag ¬ attr1;	SELECT op FROM	  body, procinit => BodyInit[];	  signalinit =>	    IF eqFlag THEN {	      expNode: Tree.Index = GetNode[syms, son[3]];	      DefineSEValue[	        son[1], 		Symbols.DummyLink[gfi: P4.ownGfi, ep: DecodeCard[syms.tb[expNode].info]], 		RootBti]; 	      son[3] ¬ FreeTree[syms, son[3]]};	  inline => {	    expNode: Tree.Index = GetNode[syms, son[3]];	    syms.tb[expNode].son[1] ¬ UpdateList[syms, syms.tb[expNode].son[1], InlineOp];	    DefineSEValue[ids:son[1]];	    AugmentSEValue[son[1], value, son[3]];  son[3] ¬ Tree.Null};	  ENDCASE => ExpInit[]}};    MarkAndCheckSE[syms.tb[node].son[1], initFlag];    dataPtr.textIndex ¬ saveIndex};  TypeForDecl: PROC [node: Tree.Index] RETURNS [SEIndex] = {    RETURN [IF syms.tb[node].son[2] # Tree.Null      THEN TypeForTree[syms.tb[node].son[2]]      ELSE syms.seb[FirstId[node]].idType]};  ConstInit: PROC [t: Tree.Link] RETURNS [BOOLEAN] = {    RETURN [IF OpName[syms, t] # all      THEN P4.StructuredLiteral[t]      ELSE ConstInit[NthSon[syms, t, 1]]]};  InlineOp: TreeOps.Map = {RETURN [UpdateList[syms, t, P4.NeutralExp]]};  DefineSEVar: PROC [ids: Tree.Link] = {    UpdateSE: TreeOps.Scan = {      sei: ISEIndex = ItemId[t];      syms.seb[sei].constant ¬ FALSE};    ScanList[syms, ids, UpdateSE]};  DefineSEValue: PROC [ids: Tree.Link, value: UNSPECIFIED¬0, info: CBTIndex¬CBTNull] = {    UpdateSE: TreeOps.Scan = {      sei: ISEIndex = ItemId[t];      syms.seb[sei].constant ¬ TRUE;      syms.seb[sei].idValue ¬ LOOPHOLE[value];  syms.seb[sei].idInfo ¬ FromBti[info]};    ScanList[syms, ids, UpdateSE]};  AugmentSEValue: PROC [	ids: Tree.Link,	type: ExtensionType, extension: Tree.Link,	copy: BOOLEAN¬FALSE] = {    UpdateSE: TreeOps.Scan = {      sei: ISEIndex = ItemId[t];      EnterExtension[syms, sei, type, IF copy THEN IdentityMap[syms, extension] ELSE extension];      copy ¬ TRUE};    ScanList[syms, ids, UpdateSE]};  MarkAndCheckSE: PROC [ids: Tree.Link, initialized: BOOLEAN] = {    UpdateSE: TreeOps.Scan = {      sei: ISEIndex = ItemId[t];      syms.seb[sei].mark4 ¬ TRUE;      IF dataPtr.interface THEN CheckDefinition[sei, initialized];      IF syms.seb[sei].idType = typeTYPE AND syms.ctxb[syms.seb[sei].idCtx].level # lZ THEN	syms.seb[sei].idValue ¬ FromSei[sei« - FIRST[ISEIndex]»]};    ScanList[syms, ids, UpdateSE]};  CheckDefinition: PROC [sei: ISEIndex, initialized: BOOLEAN] = {    SELECT syms.seb[sei].idCtx FROM      dataPtr.mainCtx =>	SELECT LinkMode[syms, sei] FROM	  val => IF ~initialized OR syms.seb[sei].extended THEN RETURN;	  ref => IF ~initialized THEN RETURN;	  manifest, type => IF ConstantId[syms, sei] THEN RETURN;	  ENDCASE;      ENDCASE => RETURN;    Log.ErrorSei[nonDefinition, sei]};  CheckDefaults: PROC [t: Tree.Link] = {    TestDefaults: TreeOps.Scan = {      node: Tree.Index = GetNode[syms, t];      saveIndex: CARDINAL = dataPtr.textIndex;      sei: ISEIndex = FirstId[node];      dataPtr.textIndex ¬ DecodeCard[syms.tb[node].info];      IF syms.seb[sei].extended THEN {        type: CSEIndex =	  UnderType[syms, IF syms.seb[sei].idType = typeTYPE THEN sei ELSE syms.seb[sei].idType];	nType: CSEIndex = NormalType[syms, type];		TestDefault: TreeOps.Map = {	  IF OpName[syms, t] = void THEN v ¬ t	  ELSE {	    v ¬ P4.AdjustBias[P4.Rhs[t, type], -BiasForType[type]];	    IF P4.TreeLiteral[v] AND (	     WITH n: syms.seb[nType] SELECT FROM		  basic => n.code # codeINT OR P4.VRep[] = P4.signed,		  ENDCASE => TRUE) THEN	      v ¬ P4.ForceType[v, type];	    IF ~(P4.VProp[].noFreeVar OR (SIGNAL VarInit[])) THEN	      Log.ErrorTree[nonConstant, v];	    P4.VPop[]};          RETURN};        t: Tree.Link ¬ FindExtension[syms, sei].tree;	v: Tree.Link ¬ UpdateList[syms, IdentityMap[syms, t], TestDefault];	IF t.tag # symbol AND P4.StructuredLiteral[v] THEN	  UpdateDefaults[syms.tb[node].son[1], v]	ELSE v ¬ FreeTree[syms, v]};      dataPtr.textIndex ¬ saveIndex};    IF dataPtr.interface THEN ScanList[syms, t, TestDefaults]};  UpdateDefaults: PROC [ids: Tree.Link, v: Tree.Link] = {    copy: BOOLEAN ¬ FALSE;          UpdateDefault: TreeOps.Scan = {      sei: ISEIndex = ItemId[t];      old: Tree.Link ¬ FindExtension[syms, sei].tree;      EnterExtension[syms, sei, default, IF copy THEN IdentityMap[syms, v] ELSE v];      copy ¬ TRUE;      [] ¬ FreeTree[syms, old]};	    ScanList[syms, ids, UpdateDefault]};      TrimTree: TreeOps.Map = {    WITH t SELECT FROM      subtree => {	node: Tree.Index = index;	SELECT syms.tb[node].name FROM	  body => {	    OPEN syms.tb[node];	    PushTree[syms, TrimTree[syms, son[1]]];	    PushTrimDecls[son[2]];	    PushTree[syms, TrimTree[syms, son[3]]];  	    PushTree[syms, TrimTree[syms, son[4]]];	    PushNode[syms, body, 4];  SetInfo[syms, info];	    SetAttr[syms, 1, attr1]; SetAttr[syms, 2, attr2]; SetAttr[syms, 3, attr3];	    v ¬ PopTree[syms]};	  block => {	    OPEN syms.tb[node];	    PushTrimDecls[son[1]];  PushTree[syms, TrimTree[syms, son[2]]];	    PushNode[syms, block, 2];  SetInfo[syms, info];	    SetAttr[syms, 1, attr1]; SetAttr[syms, 2, attr2]; SetAttr[syms, 3, attr3];	    v ¬ PopTree[syms]};	  cdot => v ¬ TrimTree[syms, syms.tb[node].son[2]];	  ENDCASE => v ¬ CopyTree[syms, [@syms.tb, t], TrimTree]};      ENDCASE => v ¬ t;    RETURN};  PushTrimDecls: PROC [t: Tree.Link] = {    IF OpName[syms, t] = initlist THEN {      node: Tree.Index = GetNode[syms, t];      PushTree[syms, TrimTree[syms, syms.tb[node].son[1]]];        PushTrimDecls[syms.tb[node].son[2]];      PushNode[syms, initlist, 2];  SetInfo[syms, syms.tb[node].info]}    ELSE {      n: CARDINAL ¬ 0;      PushDecl: TreeOps.Scan = {	node: Tree.Index = GetNode[syms, t];	SELECT syms.tb[node].name FROM	  typedecl => NULL;	  decl =>	    IF syms.tb[node].son[3] # Tree.Null THEN {	      OPEN  syms.tb[node];	      PushTree[syms, TrimTree[syms, son[1]]];  PushTree[syms, Tree.Null];	      PushTree[syms, TrimTree[syms, son[3]]];	      PushNode[syms, decl, 3];  SetInfo[syms, info];	      SetAttr[syms, 1, attr1]; SetAttr[syms, 2, attr2]; SetAttr[syms, 3, ~P4.mark];	      n ¬ n+1};	  ENDCASE => ERROR};      ScanList[syms, t, PushDecl];  PushList[syms, n]}};  DeclUpdate: PUBLIC PROC [h: SymbolTable.Handle, t: Tree.Link]    RETURNS [update: Tree.Link] = {    node: Tree.Index = GetNode[syms, t];    IF syms.tb[node].name = typedecl OR syms.tb[node].son[3] = Tree.Null THEN      update ¬ Tree.Null    ELSE {      OPEN syms.tb[node];      type: CSEIndex = UnderType[syms, TypeForDecl[node]];      rewrite: BOOLEAN = SELECT OpName[syms, syms.tb[node].son[3]] FROM			body, signalinit => FALSE,			ENDCASE => TRUE;      n: CARDINAL = ListLength[syms, syms.tb[node].son[1]];      ScanList[syms, syms.tb[node].son[1], LOOPHOLE[PushTree]];      PushTree[syms, syms.tb[node].son[3]];      FOR i: CARDINAL IN [1 .. n] DO	IF i = n THEN PushNode[syms, assign, 2]	ELSE {PushNode[syms, assignx, 2]; SetInfo[syms, EncodeSei[type]]};	SetInitAttr[type, ConstInit[syms.tb[node].son[3]]];	IF rewrite THEN PushTree[syms, P4.RewriteAssign[GetNode[syms, PopTree[syms]], type]];	ENDLOOP;      SetInfo[syms, info];  update ¬ PopTree[syms];  syms.tb[node].son[3] ¬ Tree.Null};    FreeNode[syms, node];    RETURN};  SetInitAttr: PROC [type: CSEIndex, const: BOOLEAN] = {    SetAttr[syms, 1, TRUE];    IF P4.currentLevel = lG AND ~const THEN      SELECT RCType[syms, type] FROM	simple => {SetAttr[syms, 2, TRUE]; SetAttr[syms, 3, FALSE]};	composite => {SetAttr[syms, 2, TRUE]; SetAttr[syms, 3, TRUE]};	ENDCASE => SetAttr[syms, 2, FALSE]    ELSE SetAttr[syms, 2, FALSE]};  mdStatus: MDRDefs.MDStatus ¬ MDRDefs.defaultMD;  splitFields: BOOLEAN;  TypeExp: PUBLIC PROC [typeExp: Tree.Link, body, indirect: BOOLEAN ¬ FALSE] = {    -- body => arg records subsumed by frame    WITH typeExp SELECT FROM      symbol =>	IF ~indirect THEN {	  iSei: ISEIndex = index;	  IF ~syms.seb[iSei].mark4 THEN 	    DeclItem[syms, [subtree[index: ToTreeIndex[syms.seb[iSei].idValue]]]]};      subtree => {	node: Tree.Index = index;	SELECT syms.tb[node].name FROM	  discrimTC => TypeExp[syms.tb[node].son[1], FALSE, indirect];	  cdot => TypeExp[syms.tb[node].son[2], body, indirect];	  implicitTC, linkTC => NULL;	  frameTC => NULL;	  ENDCASE => {	    OPEN syms.tb[node];	    sei: CSEIndex = DecodeCSei[info];	    IF ~syms.seb[sei].mark4 THEN	     WITH type: syms.seb[sei] SELECT FROM	      enumerated =>		IF type.machineDep THEN		  [nValues:type.nValues, sparse:type.sparse] ¬		    LayoutEnum[son[1], type.valueCtx];	      record => {		ENABLE VarInit => {RESUME [FALSE]};		IF attr1 THEN {		  saveMDStatus: MDRDefs.MDStatus ¬ mdStatus;		  WITH type SELECT FROM		    notLinked => mdStatus ¬ GetMDStatus[son[2]];		    ENDCASE;		  IF ~mdStatus.machineDep THEN ERROR;		  ScanList[syms, son[1], DeclItem];		  splitFields ¬ FALSE;		  ScanList[syms, son[1], AssignPositions];		  mdStatus ¬ saveMDStatus;}		ELSE ScanList[syms, son[1], DeclItem];		WITH type SELECT FROM		  notLinked =>		    IF attr1 THEN {		      IF ~splitFields THEN		        P4.CheckFields[LOOPHOLE[sei, RecordSEIndex], 0];}		    ELSE P4.LayoutFields[LOOPHOLE[sei, RecordSEIndex], 0];		  ENDCASE;		ExtractFieldAttributes[LOOPHOLE[sei, RecordSEIndex]];		CheckDefaults[son[1]]};	      ref => TypeExp[son[1], FALSE, TRUE];	      array => {		IF son[1] # Tree.Null THEN TypeExp[son[1]];		TypeExp[son[2], FALSE, indirect]};	      arraydesc => TypeExp[son[1], FALSE, TRUE];	      transfer => {		origin, newOrigin: CARDINAL;		rSei: RecordSEIndex;		origin ¬ SELECT type.mode FROM		  program => PrincOps.globalbase,		  signal, error => PrincOps.localbase+4,		  proc => PrincOps.localbase,		  ENDCASE => 0;		IF OpName[syms, son[1]] # anyTC THEN {		  ScanList[syms, son[1], DeclItem];  CheckDefaults[son[1]]};		rSei ¬ ArgRecord[syms, type.typeIn];		IF rSei # SENull THEN {		  syms.seb[rSei].hints.comparable ¬ TRUE;	-- for now		  newOrigin ¬ P4.LayoutArgs[rSei, origin, body];		  syms.seb[rSei].length ¬ (newOrigin - origin)*WordLength;		  syms.seb[rSei].mark4 ¬ TRUE;		  origin ¬ newOrigin};		IF OpName[syms, son[2]] # anyTC THEN {		  ScanList[syms, son[2], DeclItem];  CheckDefaults[son[2]]};		rSei ¬ ArgRecord[syms, type.typeOut];		IF rSei # SENull THEN {		  syms.seb[rSei].hints.comparable ¬ TRUE;	-- for now		  syms.seb[rSei].length ¬ (P4.LayoutArgs[rSei, origin, body]-origin)*WordLength;		  syms.seb[rSei].mark4 ¬ TRUE}};	      definition => NULL;	      union => {		DeclItem[syms, son[1]];		IF attr1 AND type.controlled THEN AssignPositions[syms, son[1]];		ProcessVariants[UnderType[syms, syms.seb[type.tagSei].idType], son[2]]};	      sequence => {		DeclItem[syms, son[1]];		IF attr1 AND type.controlled THEN AssignPositions[syms, son[1]];		TypeExp[son[2], FALSE, indirect]};	      relative => {TypeExp[son[1], FALSE, TRUE];  TypeExp[son[2], FALSE, TRUE]};	      opaque =>		IF son[1] # Tree.Null THEN {		  son[1] ¬ P4.Rhs[son[1], dataPtr.typeCARDINAL];  P4.VPop[];		  IF P4.TreeLiteral[son[1]] THEN		    type.length ¬ P4.TreeLiteralValue[son[1]]*WordLength};	      zone => NULL;	      subrange => {		subNode: Tree.Index;		tSei: CSEIndex = UnderType[syms, type.rangeType];		TypeExp[son[1], FALSE, indirect];		subNode ¬ GetNode[syms, son[2]];		IF P4.Interval[subNode, 0, P4.both] THEN		  [type.origin, type.range] ¬ P4.ConstantInterval[subNode		    ! P4.EmptyInterval => {type.empty ¬ TRUE; RESUME}]		ELSE type.origin ¬ type.range ¬ 0;		type.filled ¬ TRUE;		SELECT P4.VRep[] FROM		  P4.none => Log.ErrorTree[mixedRepresentation, son[2]];		  P4.unsigned => IF type.origin < 0 THEN Log.Error[subrangeNesting];		  ENDCASE;		P4.VPop[];		WITH cover: syms.seb[tSei] SELECT FROM		  subrange =>	-- incomplete test		    IF  type.origin < cover.origin		     OR (~type.empty AND type.range > cover.range) THEN		      Log.Error[subrangeNesting];		  ENDCASE => NULL;		son[2] ¬ FreeTree[syms, son[2]]};	      long => TypeExp[son[1], FALSE, indirect];	      any => NULL;	      ENDCASE => ERROR;	    syms.seb[sei].mark4 ¬ TRUE}};      ENDCASE => ERROR};    GetMDStatus: PROCEDURE [t: Tree.Link] RETURNS[MDRDefs.MDStatus] = {    -- For machine-dependent records the recordTC or monitoredTC has an    -- initlist node (arbitrary choice until new node created) whose info    -- field contains the mdstatus.    node: Tree.Index = TreeOps.GetNode[syms, t];    RETURN[MDRDefs.FromTreeInfo[syms.tb[node].info]];    }; -- machine dependent representations  EvalUnsigned: PROC [t: Tree.Link, default: CARDINAL]      RETURNS [v: Tree.Link, n: CARDINAL] = {    v ¬ P4.Rhs[t, dataPtr.typeCARDINAL];  P4.VPop[];    n ¬ IF P4.TreeLiteral[v] THEN P4.TreeLiteralValue[v] ELSE default; RETURN};  LayoutEnum: PROC [t: Tree.Link, ctx: CTXIndex]      RETURNS [sparse: BOOLEAN, nValues: CARDINAL] = {    sei: ISEIndex;    started: BOOLEAN;    last: CARDINAL;    AssignElement: TreeOps.Scan = {      val: CARDINAL;      WITH t SELECT FROM	subtree => {	  node: Tree.Index = index;	  [syms.tb[node].son[2], val] ¬	    EvalUnsigned[syms.tb[node].son[2], IF started THEN last+1 ELSE 0]};	ENDCASE => val ¬ IF started THEN last+1 ELSE 0;      IF ~started THEN {sparse ¬ (val#0); started ¬ TRUE}      ELSE {	IF val <= last THEN Log.ErrorSei[enumOrder, sei];	IF val # last+1 THEN sparse ¬ TRUE};      last ¬ ToCard[syms.seb[sei].idValue ¬ FromCard[val]];  sei ¬ NextSe[syms, sei]};    started ¬ sparse ¬ FALSE; sei ¬ FirstCtxSe[syms, ctx];    ScanList[syms, t, AssignElement];    nValues ¬ IF ~started THEN 0 ELSE last+1;  RETURN};  AssignPositions: PROC [h: SymbolTable.Handle, t: Tree.Link] = {    node: Tree.Index = GetNode[syms, t];    saveIndex: CARDINAL = dataPtr.textIndex;    type: SEIndex = TypeForTree[syms.tb[node].son[2]];    nB, nW: CARDINAL;    mdUnitSize: CARDINAL =      SELECT mdStatus.unitOption FROM        word8 => 8,	word16 => 16,	word32 => 32,	ENDCASE => ERROR;    AssignPosition: TreeOps.Scan = {          TranslateBitOption: PROCEDURE = {        -- bL and wd already adjusted so that 0 <= bL < mdUnitSize.        fieldSize: CARDINAL = (bR - bL) + 1;	IF fieldSize >= mdUnitSize THEN {	  IF (fieldSize MOD mdUnitSize # 0) OR (bL # 0) THEN {	    Log.ErrorSei[splitField, sei];	    splitFields ¬ TRUE;}	  ELSE RETURN;}	ELSE {	  saveBL: CARDINAL = bL;	  IF (bL +  fieldSize) > mdUnitSize THEN {	    Log.ErrorSei[splitField, sei];	    splitFields ¬ TRUE;};	  -- Field fits entirely within a word of size mdUnitSize.	  -- Reverse bit numbering.	  bL ¬ (mdUnitSize - 1) - bR;	  bR ¬ (mdUnitSize - 1) - saveBL;};	};          wd, bL, bR: CARDINAL;      dB: CARDINAL = IF nB=0 THEN 0 ELSE nB-1;      sei: ISEIndex = ItemId[t];      offset: CARDINAL;      node: Tree.Index = GetNode[syms, NthSon[syms, t, 2]];      [syms.tb[node].son[1], wd] ¬ EvalUnsigned[syms.tb[node].son[1], 0];      IF syms.tb[node].son[2] = Tree.Null THEN {        bL ¬ 0;  bR ¬ IF nB = 0 THEN 0 ELSE nW*mdUnitSize - 1}      ELSE {	subNode: Tree.Index = GetNode[syms, syms.tb[node].son[2]];	[syms.tb[subNode].son[1], bL] ¬ EvalUnsigned[syms.tb[subNode].son[1], 0];	[syms.tb[subNode].son[2], bR] ¬ EvalUnsigned[syms.tb[subNode].son[2], dB];       -- Following line allows reverse notation, e.g., (0:7..0) --	IF bL > bR THEN {	  temp: CARDINAL ¬ bR;	  bR ¬ bL; bL ¬ temp }};      wd ¬ wd + bL/mdUnitSize;      IF bR >= bL THEN bR ¬ bR - (bL/mdUnitSize)*mdUnitSize;      bL ¬ bL MOD mdUnitSize;      IF (SELECT TRUE FROM	    (nB = 0) => bR < bL,	    (nB >= WordLength) => (bL MOD WordLength) # 0 OR bR # bL + dB,	    ENDCASE =>	      CARDINAL[(bR - (bL/WordLength)*WordLength)] > WordLength OR	      bR < bL + dB) THEN {	        Log.ErrorSei[fieldPosition, sei]; bR ¬ bL + dB};      IF (mdStatus.bitOption # MDRDefs.defaultBitOption) AND (nB # 0) THEN        TranslateBitOption[];      offset ¬ (wd * mdUnitSize) + bL;      syms.seb[sei].idValue ¬ FromBitAddr[        BitAddress[	  wd: offset / WordLength,	  bd: offset MOD WordLength]];      syms.seb[sei].idInfo ¬         FromCard[IF nB=0 AND syms.tb[node].son[2] = Tree.Null THEN 0 ELSE bR-bL + 1]};    dataPtr.textIndex ¬ DecodeCard[syms.tb[node].info];    nB ¬ P4.CheckOver[P4.BitsForType[type]];  nW ¬ (nB+(mdUnitSize-1))/mdUnitSize;    ScanList[syms, syms.tb[node].son[1], AssignPosition];    dataPtr.textIndex ¬ saveIndex};  ExtractFieldAttributes: PROC [rType: RecordSEIndex] = {    -- compatibility version    type: CSEIndex;    comparable, privateFields: BOOLEAN;    comparable ¬ TRUE;   privateFields ¬ FALSE;    FOR sei: ISEIndex ¬ FirstCtxSe[syms, syms.seb[rType].fieldCtx], NextSe[syms, sei] UNTIL sei = SENull DO      IF ~syms.seb[sei].public THEN privateFields ¬ TRUE;      type ¬ UnderType[syms, syms.seb[sei].idType];      WITH t: syms.seb[type] SELECT FROM	record =>	  IF ~t.hints.comparable AND ~ComparableType[type] THEN comparable ¬ FALSE;	array => IF ~ComparableType[type] THEN comparable ¬ FALSE;	union => IF ~t.hints.equalLengths THEN comparable ¬ FALSE;	sequence => comparable ¬ FALSE;	ENDCASE;      ENDLOOP;    syms.seb[rType].hints.comparable ¬ comparable;    syms.seb[rType].hints.privateFields ¬ privateFields};  ProcessVariants: PROC [tagType: CSEIndex, list: Tree.Link] = {    lb, ub: CARDINAL;      MapTag: PROC [vSei: ISEIndex] RETURNS [CARDINAL] = {      WITH t: syms.seb[tagType] SELECT FROM	enumerated =>	  IF t.machineDep THEN {	    sei: ISEIndex = SearchContext[syms, syms.seb[vSei].hash, t.valueCtx];	    IF sei # SENull THEN RETURN [ToCard[syms.seb[sei].idValue]]};	ENDCASE;      RETURN [ToCard[syms.seb[vSei].idValue]]};    CheckTag: TreeOps.Scan = {      sei: ISEIndex = ItemId[t];      tag: CARDINAL = MapTag[sei];      IF tag NOT IN [lb .. ub) THEN Log.ErrorSei[boundsFault, sei];      syms.seb[sei].idValue ¬ FromCard[tag - lb]};    ProcessVariant: TreeOps.Scan = {      saveIndex: CARDINAL = dataPtr.textIndex;      node: Tree.Index = GetNode[syms, t];      dataPtr.textIndex ¬ DecodeCard[syms.tb[node].info];      ScanList[syms, syms.tb[node].son[1], CheckTag];      DeclItem[syms, t];      dataPtr.textIndex ¬ saveIndex};    lb ¬ BiasForType[tagType];  ub ¬ P4.CheckOver[lb + Cardinality[syms, tagType]];    ScanList[syms, list, ProcessVariant]};  TypeForTree: PUBLIC PROC [t: Tree.Link] RETURNS [SEIndex] = {    RETURN [WITH t SELECT FROM      symbol => index,      subtree => DecodeSei[syms.tb[index].info],      ENDCASE => typeANY]};  CanonicalType: PUBLIC PROC [type: CSEIndex] RETURNS [CSEIndex] = {    RETURN [WITH t: syms.seb[type] SELECT FROM      subrange => CanonicalType[UnderType[syms, t.rangeType]],      record =>	IF t.hints.unifield AND CtxEntries[syms, t.fieldCtx] = 1	  THEN CanonicalType[UnderType[syms, syms.seb[syms.ctxb[t.fieldCtx].seList].idType]]	  ELSE type,      ENDCASE => type]};  BiasForType: PUBLIC PROC [type: CSEIndex] RETURNS [INTEGER] = {    RETURN [IF type = SENull      THEN 0      ELSE	WITH t: syms.seb[type] SELECT FROM	  subrange => t.origin,	  record =>	    IF t.hints.unifield AND CtxEntries[syms, t.fieldCtx] = 1	      THEN BiasForType[UnderType[syms, syms.seb[syms.ctxb[t.fieldCtx].seList].idType]]	      ELSE 0,	  ENDCASE => 0]};  RepForType: PUBLIC PROC [type: CSEIndex] RETURNS [P4.Repr] = {    RETURN [IF type = SENull      THEN P4.none      ELSE        WITH t: syms.seb[type] SELECT FROM	  basic =>	    SELECT t.code FROM	      codeANY => P4.both + P4.other,	      codeINT => P4.signed,	      codeCHAR => P4.both,	      ENDCASE => P4.other,	  enumerated => P4.both,	  ref => P4.unsigned,	  record =>	    IF t.hints.unifield AND CtxEntries[syms, t.fieldCtx] = 1	      THEN RepForType[UnderType[syms, syms.seb[syms.ctxb[t.fieldCtx].seList].idType]]	      ELSE P4.other,	  relative => RepForType[UnderType[syms, t.offsetType]],	  subrange =>	    IF t.origin >= 0	      THEN (IF P4.CheckOver[t.origin] + t.range > 77777b THEN P4.unsigned ELSE P4.both)	      ELSE (IF t.range <= 77777b THEN P4.signed ELSE P4.none),	  long => RepForType[UnderType[syms, t.rangeType]],	  opaque => IF t.lengthKnown THEN P4.other ELSE P4.none,	  ENDCASE => P4.other]};  SparseRep: PUBLIC PROC [type: CSEIndex] RETURNS [BOOLEAN] = {    nType: CSEIndex = NormalType[syms, type];    RETURN [WITH syms.seb[nType] SELECT FROM      enumerated => sparse,      ENDCASE => FALSE]};  WordsForType: PUBLIC PROC [type: CSEIndex] RETURNS [CARDINAL] = {    RETURN [CARDINAL[ IF ~syms.seb[type].mark4      THEN (P4.BitsForType[type]+(WordLength-1))/WordLength      ELSE SymbolOps.WordsForType[syms, type] ]]};  ComparableType: PUBLIC PROC [type: CSEIndex] RETURNS [BOOLEAN] = {    -- compatibility version    RETURN [WITH t: syms.seb[type] SELECT FROM      record => t.hints.comparable OR t.argument,	-- for now      array => ~SparseRep[UnderType[syms, t.indexType]]		  AND ComparableType[UnderType[syms, t.componentType]],      opaque => t.lengthKnown,      any => FALSE,      ENDCASE => TRUE]};  DefaultBasicOps: PUBLIC PROC [type: SEIndex, size: CARDINAL] RETURNS [BOOLEAN] = {    uType: CSEIndex = UnderType[syms, type];    next: SEIndex;    FOR s: SEIndex ¬ type, next DO      WITH se: syms.seb[s] SELECT FROM	id => {	  sei: ISEIndex = LOOPHOLE[s];	  IF syms.seb[sei].extended THEN {	    IF OpName[syms, FindExtension[syms, sei].tree] # void THEN RETURN [FALSE] ELSE EXIT};	  next ¬ ToSei[syms.seb[sei].idInfo]};	cons =>	  WITH t: se SELECT FROM	    ref => IF t.counted THEN RETURN [FALSE] ELSE EXIT;	    array => next ¬ t.componentType;	    record => IF t.hints.default THEN RETURN [FALSE] ELSE EXIT;	    transfer => IF t.mode = port THEN RETURN [FALSE] ELSE EXIT;	    long => next ¬ t.rangeType;	    zone => IF t.counted THEN RETURN [FALSE] ELSE EXIT;	    ENDCASE => EXIT;	ENDCASE;      ENDLOOP;    RETURN [WordsForType[uType]*WordLength = size        AND ComparableType[uType] AND TypeLink[syms, uType] = SENull]};  }.
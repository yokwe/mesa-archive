-- Copyright (C) 1981, 1983, 1986  by Xerox Corporation. All rights reserved. -- file Pass4S.mesa-- Satterthwaite,	October 11, 1982 9:10 am-- Sweet,		16-Aug-83 11:57:46-- Donahue,		10-Dec-81  9:14:17-- Johnsson,		11-Jun-83 14:36:42-- Wagner		20-Aug-86  9:32:34DIRECTORY--  CatchFormat: TYPE USING [CatchFrame],  ComData USING [    bodyIndex, catchIndex, globalFrameSize, interface, monitored, stopping,    switches, textIndex, typeBOOL, typeINT, typeLOCK],  CLog USING [Error, ErrorSei, ErrorTree],  LiteralOps USING [Find, ResetLocalStrings],  P4 USING [    Attr, voidAttr, Repr, none, unsigned, both, other,    AdjustBias, Assignment, BiasForType, BoolValue, Call, CheckBlock, CheckOver,    CommonProp, CommonRep, ConstantInterval, Cover, DeclItem, DeclUpdate,    Exp, Extract, Interval, LayoutBlock, LayoutGlobals, LayoutInterface, LayoutLocals,    MakeArgRecord, MakeTreeLiteral, NeutralExp, NormalizeRange,    OperandType, ProcessSymLiterals, RelTest, RepForType, Rhs, RValue,    TreeLiteral, TreeLiteralValue, VAttr, VBias, VPop, VProp, VRep, WordsForType,    EmptyInterval],  Pass4 USING [    implicitAttr, implicitBias, implicitType, lockNode, resident,    resumeRecord, returnRecord],  PrincOps USING [ControlLink, StateVector, localbase],  Symbols USING [    ISEIndex, CSEIndex, RecordSEIndex, CTXIndex, BTIndex, CBTIndex, CCBTIndex,    ContextLevel, SENull, RecordSENull, CTXNull, RootBti, BTNull, lG, lL, typeANY,    WordLength],  SymbolOps USING [    ArgRecord, Cardinality, ContextVariant, DelinkBti, NormalType, TransferTypes,    TypeLink, UnderType],  SymbolTable USING [Handle],  SymLiteralOps USING [DescribeRefLits, DescribeTypes],  Tree USING [Index, Link, NodeName, Null, NullIndex],  TreeOps USING [    FreeNode, FreeTree, GetNode, GetSe, IdentityMap, ListHead, ListLength, MakeList,    MakeNode, Map, NthSon, OpName, PopTree, PushProperList, PushList, PushLit, PushNode,    PushTree, ReverseScanList, ReverseUpdateList, Scan, ScanList, SearchList,    SetAttr, SetInfo, SetShared, Test, UpdateList,    DecodeBti, DecodeCard, DecodeCSei, EncodeBti, EncodeSei];Pass4S: PROGRAM    IMPORTS      Log: CLog, LiteralOps, P4, SymbolOps, SymLiteralOps, TreeOps,      dataPtr: ComData, passPtr: Pass4    EXPORTS P4 = {  OPEN SymbolOps, Symbols, P4, TreeOps;  syms: SymbolTable.Handle ¬ NIL;    Pass4SInit: PUBLIC PROC [h: SymbolTable.Handle] = { syms ¬ h };  Repr: TYPE = P4.Repr;    none: Repr = P4.none; -- bodies and blocks  currentLevel: PUBLIC ContextLevel;  currentBody: BTIndex;  checked: PUBLIC BOOLEAN;  BodyList: PROC [firstBti: BTIndex] = {    nextBti: BTIndex;    FOR bti: BTIndex ¬ firstBti, nextBti UNTIL bti = BTNull DO      nextBti ¬ IF syms.bb[bti].link.which = parent THEN BTNull ELSE syms.bb[bti].link.index;      WITH syms.bb[bti] SELECT FROM	Callable =>	  IF ~inline OR (dataPtr.interface AND LocalBody[LOOPHOLE[bti]]) THEN {	    IF nesting = Catch THEN BodyList[syms.bb[bti].firstSon]	    ELSE Body[LOOPHOLE[bti, CBTIndex]]}	  ELSE DelinkBti[syms, bti];	ENDCASE => BodyList[syms.bb[bti].firstSon];      ENDLOOP};  LocalBody: PROC [bti: CBTIndex] RETURNS [BOOLEAN] = INLINE {    sei: ISEIndex = syms.bb[bti].id;    RETURN [sei = SENull OR syms.ctxb[syms.seb[sei].idCtx].ctxType = simple]};  Body: PUBLIC PROC [bti: CBTIndex] = {    oldBodyIndex: CBTIndex = dataPtr.bodyIndex;    oldLevel: ContextLevel = currentLevel;    saveChecked: BOOLEAN = checked;    saveIndex: CARDINAL = dataPtr.textIndex;    saveCatchScope: BOOLEAN = catchScope;    saveRecord: RecordSEIndex = passPtr.returnRecord;    node: Tree.Index = WITH syms.bb[bti].info SELECT FROM	Internal => bodyTree,	ENDCASE => ERROR;    sei: CSEIndex = syms.bb[bti].ioType;    base, bound: CARDINAL;    initTree: Tree.Link;    catchScope ¬ FALSE;    dataPtr.bodyIndex ¬ currentBody ¬ bti;  dataPtr.textIndex ¬ syms.bb[bti].sourceIndex;    currentLevel ¬ IF bti = RootBti THEN lG ELSE syms.bb[bti].level;    checked ¬ syms.tb[node].attr1;    IF dataPtr.interface AND syms.bb[bti].level > lL      THEN Log.ErrorSei[nonDefinition, syms.bb[bti].id];    passPtr.returnRecord ¬ TransferTypes[syms, syms.bb[bti].ioType].typeOut;    [] ¬ LiteralOps.ResetLocalStrings[syms];    IF syms.tb[node].son[4] # Tree.Null THEN {      syms.tb[node].son[4] ¬ Exp[syms.tb[node].son[4], none]; VPop[]};    syms.tb[node].son[1] ¬ UpdateList[syms, syms.tb[node].son[1], OpenItem];    [init: initTree, decls: syms.tb[node].son[2]] ¬ ScanDecls[syms.tb[node].son[2]];    IF bti = RootBti THEN {      fragments: BOOLEAN ¬        (SymLiteralOps.DescribeTypes[].length + SymLiteralOps.DescribeRefLits[].length) # 0;      dataPtr.globalFrameSize ¬        (LayoutGlobals[bti, dataPtr.stopping, fragments] + (WordLength-1))/WordLength;      IF syms.bb[bti].type # RecordSENull THEN        syms.seb[syms.bb[bti].type].length ¬ dataPtr.globalFrameSize*WordLength;      ProcessSymLiterals[];      base ¬ PrincOps.localbase*WordLength;      IF dataPtr.monitored AND syms.tb[passPtr.lockNode].attr1 THEN {	PushTree[syms, syms.tb[passPtr.lockNode].son[2]];	PushLit[syms, LiteralOps.Find[syms, 100000b]];  PushNode[syms, cast, 1];	SetInfo[syms, EncodeSei[dataPtr.typeLOCK]];	PushNode[syms, assign, 2];  SetAttr[syms, 1, TRUE];	initTree ¬ Prefix[PopTree[syms], initTree]}}    ELSE {      base ¬ LayoutLocals[bti];      IF syms.bb[bti].type # RecordSENull THEN syms.seb[syms.bb[bti].type].length ¬ base;      IF syms.bb[bti].firstSon # BTNull THEN        initTree ¬ Prefix[BodyInitList[syms.bb[bti].firstSon], initTree]};    IF syms.bb[bti].type # RecordSENull THEN syms.seb[syms.bb[bti].type].mark4 ¬ TRUE;    syms.tb[node].son[3] ¬ UpdateList[syms, syms.tb[node].son[3], Stmt];    bound ¬ AssignSubBlocks[bti, base];    WITH syms.bb[bti].info SELECT FROM      Internal => {	frameSize ¬ (bound + (WordLength-1))/WordLength;	thread ¬ LiteralOps.ResetLocalStrings[syms]};      ENDCASE;    syms.bb[bti].resident ¬ passPtr.resident;    IF syms.bb[bti].firstSon # BTNull THEN BodyList[syms.bb[bti].firstSon];    syms.tb[node].son[1] ¬ ReverseUpdateList[syms, syms.tb[node].son[1], CloseItem];    syms.tb[node].son[2] ¬ Prefix[initTree, UpdateList[syms, syms.tb[node].son[2], DeclUpdate]];    IF dataPtr.interface AND bti = RootBti THEN [] ¬ LayoutInterface[bti];    catchScope ¬ saveCatchScope;    currentBody ¬ dataPtr.bodyIndex ¬ oldBodyIndex;    currentLevel ¬ oldLevel;  checked ¬ saveChecked;    dataPtr.textIndex ¬ saveIndex;  passPtr.returnRecord ¬ saveRecord};  MarkString: PUBLIC PROC [local: BOOLEAN] = {};            ScanDecls: PROC [t: Tree.Link] RETURNS [init, decls: Tree.Link] = {    IF OpName[syms, t] = initlist THEN {      node: Tree.Index = GetNode[syms, t];      init ¬ UpdateList[syms, syms.tb[node].son[1], Stmt];  syms.tb[node].son[1] ¬ Tree.Null;      decls ¬ syms.tb[node].son[2];  syms.tb[node].son[2] ¬ Tree.Null;      FreeNode[syms, node]}    ELSE {init ¬ Tree.Null; decls ¬ t};    ScanList[syms, decls, DeclItem]; RETURN};  Prefix: PROC [first, rest: Tree.Link] RETURNS [Tree.Link] = {    SELECT TRUE FROM      (first = Tree.Null) => RETURN [rest];      (rest = Tree.Null) => RETURN [first];      ENDCASE => {PushTree[syms, first]; PushTree[syms, rest]; RETURN [MakeList[syms, 2]]}};  BodyInitList: PROC [firstBti: BTIndex] RETURNS [Tree.Link] = {    bti: BTIndex ¬ firstBti;    n: CARDINAL ¬ 0;    IF bti # BTNull THEN      DO	WITH body: syms.bb[bti] SELECT FROM	  Callable =>	    IF ~body.inline AND body.nesting # Catch THEN {	      PushNode[syms, procinit, 0]; SetInfo[syms, EncodeBti[bti]]; n ¬ n+1};	  ENDCASE => NULL;	IF syms.bb[bti].link.which = parent THEN EXIT;	bti ¬ syms.bb[bti].link.index;	ENDLOOP;    RETURN [MakeList[syms, n]]};  AssignSubBlocks: PROC [rootBti: BTIndex, base: CARDINAL] RETURNS [bound: CARDINAL] = {    level: ContextLevel = syms.bb[rootBti].level;    bti: BTIndex;    bound ¬ base;    IF (bti ¬ syms.bb[rootBti].firstSon) # BTNull THEN      DO	SELECT syms.bb[bti].kind FROM	  Other =>	    IF syms.bb[bti].level = level THEN {	      length: CARDINAL = AssignBlock[bti, base];	      bound ¬ MAX[length, bound]};	  ENDCASE => NULL;	IF syms.bb[bti].link.which = parent THEN EXIT;	bti ¬ syms.bb[bti].link.index;	ENDLOOP;    RETURN};  Subst: PUBLIC PROC [node: Tree.Index] RETURNS [Tree.Link] = {    OPEN syms.tb[node];    saveRecord: RecordSEIndex = passPtr.returnRecord;    saveChecked: BOOLEAN = checked;    son[1] ¬ NeutralExp[syms, son[1]];    passPtr.returnRecord ¬ TransferTypes[syms, OperandType[son[1]]].typeOut;    IF ~attr3 THEN checked ¬ attr1;    son[2] ¬ UpdateList[syms, son[2], Stmt];    checked ¬ saveChecked;  passPtr.returnRecord ¬ saveRecord;    RETURN [[subtree[index: node]]]};  Scope: PROC [node: Tree.Index, item: TreeOps.Map] RETURNS [Tree.Link] = {    OPEN syms.tb[node];    bti: BTIndex = DecodeBti[info];    saveIndex: CARDINAL = dataPtr.textIndex;    oldBodyIndex: BTIndex = currentBody;    oldLevel: ContextLevel = currentLevel;    initTree: Tree.Link;    dataPtr.textIndex ¬ syms.bb[bti].sourceIndex;    currentBody ¬ bti;  currentLevel ¬ syms.bb[bti].level;    [init: initTree, decls: son[1]] ¬ ScanDecls[son[1]];    IF syms.bb[bti].type # RecordSENull THEN syms.seb[syms.bb[bti].type].mark4 ¬ TRUE;    CheckBlock[bti];    son[2] ¬ UpdateList[syms, son[2], item];    son[1] ¬ Prefix[initTree, UpdateList[syms, son[1], DeclUpdate]];    IF catchScope THEN catchBound ¬ MAX[AssignBlock[bti, catchBase], catchBound];    currentBody ¬ oldBodyIndex;  currentLevel ¬ oldLevel;    dataPtr.textIndex ¬ saveIndex;    RETURN [[subtree[index: node]]]};  AssignBlock: PROC [bti: BTIndex, base: CARDINAL] RETURNS [bound: CARDINAL] = {    node: Tree.Index;    newBase: CARDINAL = LayoutBlock[bti, base];    initTree: Tree.Link = IF syms.bb[bti].firstSon # BTNull	THEN BodyInitList[syms.bb[bti].firstSon]	ELSE Tree.Null;    IF syms.bb[bti].type # RecordSENull THEN syms.seb[syms.bb[bti].type].length ¬ newBase;    bound ¬ AssignSubBlocks[bti, newBase];    WITH syms.bb[bti].info SELECT FROM      Internal => {frameSize ¬ (bound + (WordLength-1))/WordLength; node ¬ bodyTree};      ENDCASE => NULL;    IF initTree # Tree.Null THEN syms.tb[node].son[1] ¬ Prefix[initTree, syms.tb[node].son[1]];    RETURN}; -- main dispatch  Stmt: PROC [h: SymbolTable.Handle, t: Tree.Link] RETURNS [v: Tree.Link] = {    node: Tree.Index;    saveIndex: CARDINAL = dataPtr.textIndex;    v ¬ t;		-- the default case    WITH t SELECT FROM      subtree => {	node ¬ index;	IF node # Tree.NullIndex THEN {	  OPEN syms.tb[node];	  dataPtr.textIndex ¬ DecodeCard[info];	  SELECT name FROM	    assign => {v ¬ Assignment[node]; VPop[]};	    extract => v ¬ ExtractStmt[node];	    call, portcall, signal, error, xerror, start, join => {v ¬ Call[node]; VPop[]};	    subst => v ¬ Subst[node];	    block => {	      saveChecked: BOOLEAN = checked;	      checked ¬ syms.tb[node].attr1;  v ¬ Scope[node, Stmt];	      checked ¬ saveChecked};	    if => v ¬ IfStmt[node];	    case => v ¬ CaseDriver[node, Stmt, 0];	    bind =>	      v ¬ IF attr3 THEN BindType[node, Stmt] ELSE BindCase[node, case, BindStmt];	    do => v ¬ DoStmt[node];	    return, result => Return[node, passPtr.returnRecord];	    resume => Return[node, passPtr.resumeRecord];	    label => {	      son[1] ¬ Stmt[syms, son[1]]; 	      son[2] ¬ UpdateList[syms, son[2], Stmt]};	    open => {	      son[1] ¬ UpdateList[syms, son[1], OpenItem];	      son[2] ¬ UpdateList[syms, son[2], Stmt];	      son[1] ¬ ReverseUpdateList[syms, son[1], CloseItem]};	    checked => {	      saveChecked: BOOLEAN = checked;	      checked ¬ attr1;  son[1] ¬ Stmt[syms, son[1]];	      checked ¬ saveChecked};	    enable => {CatchPhrase[son[1]]; son[2] ¬ Stmt[syms, son[2]]};	    catchmark => son[1] ¬ Stmt[syms, son[1]];	    lock => {son[1] ¬ UpdateList[syms, son[1], Stmt]; son[2] ¬ Exp[son[2], none]; VPop[]};	    notify, broadcast, unlock => {son[1] ¬ Exp[son[1], none]; VPop[]};	    wait => {	      son[1] ¬ Exp[son[1], none];  VPop[];	      son[2] ¬ Exp[son[2], none];  VPop[];	      IF nSons > 2 THEN CatchNest[son[3]]};	    restart => {	      son[1] ¬ NeutralExp[syms, son[1]]; 	      IF nSons > 2 THEN CatchNest[son[3]]};	    dsk, lsk => {	      son[1] ¬ Exp[son[1], none];	      IF WordsForType[OperandType[son[1]]] < 	          SIZE[PrincOps.StateVector.dst] THEN	        Log.ErrorTree[sizeClash, son[1]];	      VPop[]};	    xe, xf => {	      son[1] ¬ Exp[son[1], none];	      IF WordsForType[OperandType[son[1]]] < 2 * SIZE[PrincOps.ControlLink] THEN	        Log.ErrorTree[sizeClash, son[1]];	      VPop[]};	    goto, exit, loop, syserror, reject, continue, retry, stop, null => NULL;	    free => v ¬ Free[node];	    apply => NULL;	    item => son[2] ¬ Stmt[syms, son[2]];	    list => v ¬ UpdateList[syms, t, Stmt];	    ENDCASE => Log.Error[unimplemented]}};      ENDCASE => ERROR;    dataPtr.textIndex ¬ saveIndex;  RETURN}; -- extraction  ExtractStmt: PROC [node: Tree.Index] RETURNS [val: Tree.Link] = {    subNode: Tree.Index = GetNode[syms, syms.tb[node].son[1]];    rType: RecordSEIndex = LOOPHOLE[syms.tb[subNode].info];    IF rType # Symbols.RecordSENull THEN {val ¬ Extract[node]; VPop[]}    ELSE {      val ¬ Stmt[syms, syms.tb[node].son[2]];  syms.tb[node].son[2] ¬ Tree.Null;      WITH val SELECT FROM subtree => syms.tb[index].info ¬ syms.tb[node].info ENDCASE;      FreeNode[syms, node]};    RETURN}; -- return   Return: PROC [node: Tree.Index, type: RecordSEIndex] = {    syms.tb[node].son[1] ¬ IF syms.tb[node].attr3 AND type # RecordSENull      THEN Rhs[syms.tb[node].son[1], type]      ELSE MakeArgRecord[type, syms.tb[node].son[1]];    VPop[]};       -- conditionals  IfStmt: PROC [node: Tree.Index] RETURNS [val: Tree.Link] = {    OPEN syms.tb[node];    son[1] ¬ BoolValue[son[1]];  VPop[];    son[2] ¬ Stmt[syms, son[2]];  son[3] ¬ Stmt[syms, son[3]];    IF ~TreeLiteral[son[1]] THEN val ¬ Tree.Link[subtree[index: node]]    ELSE {      IF TreeLiteralValue[son[1]] # 0 THEN {val ¬ son[2]; son[2] ¬ Tree.Null}      ELSE {val ¬ son[3]; son[3] ¬ Tree.Null};      FreeNode[syms, node]};    RETURN};   BindStmt: PROC [t: Tree.Link, labelBias: INTEGER] RETURNS [Tree.Link] = {    node: Tree.Index = GetNode[syms, t];    RETURN [CaseDriver[GetNode[syms, t], Stmt, labelBias]]};  -- drivers for processing selections  BindType: PUBLIC PROC [node: Tree.Index, eval: TreeOps.Map] RETURNS [Tree.Link] = {    OPEN syms.tb[node];    saveType: CSEIndex = passPtr.implicitType;    saveBias: INTEGER = passPtr.implicitBias;    saveAttr: Attr = passPtr.implicitAttr;    Item: TreeOps.Map = {RETURN [Scope[GetNode[syms, t], eval]]};    subNode: Tree.Index ¬ GetNode[syms, son[1]];    type: CSEIndex = OperandType[syms.tb[subNode].son[2]];    PushTree[syms, RValue[syms.tb[subNode].son[2], BiasForType[type], RepForType[type]]];    passPtr.implicitType ¬ type;    passPtr.implicitAttr ¬ VAttr[];  passPtr.implicitBias ¬ VBias[];  VPop[];    syms.tb[subNode].son[2] ¬ Tree.Null;    PushTree[syms, UpdateList[syms, son[3], Item]];  son[3] ¬ Tree.Null;    PushTree[syms, eval[syms, son[4]]];  son[4] ¬ Tree.Null;    PushNode[syms, name, 3];  SetInfo[syms, info];      SetAttr[syms, 1, attr1];  SetAttr[syms, 2, attr2];    FreeNode[syms, node];    passPtr.implicitAttr ¬ saveAttr;  passPtr.implicitBias ¬ saveBias;    passPtr.implicitType ¬ saveType;    RETURN [PopTree[syms]]};  BindCase: PUBLIC PROC [	node: Tree.Index,	op: Tree.NodeName,	eval: PROC [Tree.Link, INTEGER] RETURNS [Tree.Link]]      RETURNS [val: Tree.Link] = {    OPEN syms.tb[node];    labelBias: INTEGER = TagBias[BoundType[son[1]], TestCtx[ListHead[syms, son[3]]]];    subNode: Tree.Index;    PushTree[syms, son[2]];  son[2] ¬ Tree.Null;    PushTree[syms, son[3]];  son[3] ¬ Tree.Null;    PushTree[syms, son[4]];  son[4] ¬ Tree.Null;    PushTree[syms, OpenItem[syms, son[1]]];  son[1] ¬ Tree.Null;    PushNode[syms, op, 4];  SetInfo[syms, info];    SetAttr[syms, 1, FALSE];  SetAttr[syms, 2, FALSE];  SetAttr[syms, 3, attr3];    val ¬ eval[PopTree[syms], labelBias];  subNode ¬ GetNode[syms, val];    syms.tb[subNode].son[4] ¬ CloseItem[syms, syms.tb[subNode].son[4]];    FreeNode[syms, node];    RETURN};  BoundType: PROC [base: Tree.Link] RETURNS [CSEIndex] = INLINE {    RETURN [DerefType[OperandType[NthSon[syms, base, 2]]]]};  TestCtx: PROC [item: Tree.Link] RETURNS [CTXIndex] = INLINE {    RETURN [IF item = Tree.Null      THEN CTXNull      ELSE syms.seb[GetSe[syms, NthSon[syms, ListHead[syms, NthSon[syms, item, 1]], 2]]].idCtx]};      TagBias: PROC [rType: CSEIndex, testCtx: CTXIndex] RETURNS [INTEGER] = {    FOR subType: CSEIndex ¬ rType, UnderType[syms, TypeLink[syms, subType]]     WHILE subType # SENull DO      WITH t: syms.seb[subType] SELECT FROM        record =>	  IF t.hints.variant THEN {	    sei: ISEIndex = ContextVariant[syms, t.fieldCtx];	    uType: CSEIndex = UnderType[syms, syms.seb[sei].idType];	    WITH u: syms.seb[uType] SELECT FROM	      union =>		IF u.caseCtx = testCtx OR testCtx = CTXNull THEN		  RETURN [BiasForType[UnderType[syms, syms.seb[u.tagSei].idType]]];	      ENDCASE};	ENDCASE => EXIT;      ENDLOOP;    ERROR};  CaseDriver: PUBLIC PROC [node: Tree.Index, selection: TreeOps.Map, labelBias: INTEGER]      RETURNS [val: Tree.Link] = {    OPEN syms.tb[node];    saveType: CSEIndex = passPtr.implicitType;    saveBias: INTEGER = passPtr.implicitBias;    saveAttr: Attr = passPtr.implicitAttr;    type: CSEIndex = OperandType[son[1]];    son[1] ¬ Exp[son[1], none];    IF attr2 THEN {				-- not bind/bindx      found: BOOLEAN ¬ FALSE;            EvalTest: TreeOps.Map = {        subNode: Tree.Index = GetNode[syms, t];        IF syms.tb[subNode].son[1] # Tree.Null THEN ERROR;        syms.tb[subNode].son[1] ¬ IdentityMap[syms, syms.tb[node].son[1]];        v ¬ BoolValue[t];  VPop[];        IF TreeLiteral[v] AND TreeLiteralValue[v] # 0 THEN found ¬ TRUE;        RETURN};              TestItem: TreeOps.Test = {        subNode: Tree.Index = GetNode[syms, t];        syms.tb[subNode].son[1] ¬ UpdateList[syms, syms.tb[subNode].son[1], EvalTest];        IF found THEN {val ¬ syms.tb[subNode].son[2]; syms.tb[subNode].son[2] ¬ Tree.Null};        RETURN [found]};              SearchList[syms, son[2], TestItem];      IF ~found THEN {val ¬ son[3]; son[3] ¬ Tree.Null};      FreeNode[syms, node];      val ¬ selection[syms, val]}    ELSE IF type = dataPtr.typeBOOL AND attr1 AND TreeLiteral[son[1]] THEN {      CaseItem: TreeOps.Scan = {	subNode: Tree.Index = GetNode[syms, t];	started: BOOLEAN;	PushTest: TreeOps.Scan = {	  tNode: Tree.Index = GetNode[syms, t];	  PushTree[syms, syms.tb[tNode].son[2]];  syms.tb[tNode].son[2] ¬ Tree.Null;	  IF TreeLiteral[son[1]] AND TreeLiteralValue[son[1]] = 0 THEN 	    PushNode[syms, not, 1];	  IF started THEN PushNode[syms, or, 2];	  started ¬ TRUE;  RETURN};	PushTree[syms, syms.tb[subNode].son[2]];  syms.tb[subNode].son[2] ¬ Tree.Null;	started ¬ FALSE;  ScanList[syms, syms.tb[subNode].son[1], PushTest];	IF selection = Stmt THEN {	  PushNode[syms, if, -3]; 	  SetInfo[syms, syms.tb[subNode].info]}	ELSE {PushNode[syms, ifx, -3]; SetInfo[syms, syms.tb[node].info]};	RETURN};      son[1] ¬ AdjustBias[son[1], -VBias[]];  VPop[];      PushTree[syms, son[3]];  son[3] ¬ Tree.Null;      ReverseScanList[syms, son[2], CaseItem];      FreeNode[syms, node];      passPtr.implicitAttr ¬ voidAttr;      val ¬ selection[syms, PopTree[syms]]}    ELSE {      nSons: CARDINAL = ListLength[syms, son[2]];      i, j, first, last, next, newSons: CARDINAL;      min, max: INTEGER;      minTree, maxTree: Tree.Link;      rep: Repr;      subNode, listNode: Tree.Index;      switchable, copying: BOOLEAN;      multiword: BOOLEAN = WordsForType[type] # 1;      count: CARDINAL;      TestExp: TreeOps.Map = {        v ¬ RValue[t, 0, none];        passPtr.implicitAttr.prop ¬ CommonProp[passPtr.implicitAttr.prop, VProp[]];        VPop[]};              SwitchValue: TreeOps.Map = {	val: Tree.Link;	tNode: Tree.Index = GetNode[syms, t];	val ¬ syms.tb[tNode].son[2] ¬ RValue[syms.tb[tNode].son[2], passPtr.implicitBias, rep];        passPtr.implicitAttr.prop ¬ CommonProp[passPtr.implicitAttr.prop, VProp[]];        VPop[];	IF count = 0 THEN {first ¬ i; minTree ¬ maxTree ¬ val}	ELSE {	  subRep: Repr = (SELECT rep FROM other, none => unsigned, ENDCASE => rep);	  IF RelTest[val, minTree, relL, subRep] THEN minTree ¬ val;	  IF RelTest[val, maxTree, relG, subRep] THEN maxTree ¬ val};	count ¬ count + 1;	RETURN [t]};      passPtr.implicitType ¬ type;      passPtr.implicitBias ¬ VBias[] - labelBias;      passPtr.implicitAttr ¬ VAttr[];  rep ¬ passPtr.implicitAttr.rep;  VPop[];      newSons ¬ nSons;      i ¬ next ¬ 1;  copying ¬ FALSE;  listNode ¬ GetNode[syms, son[2]];      UNTIL i > nSons DO	WHILE i <= nSons DO	  subNode ¬ GetNode[syms, syms.tb[listNode].son[i]];	  IF syms.tb[subNode].attr1 AND ~multiword THEN EXIT;	  syms.tb[subNode].son[1] ¬ UpdateList[syms, syms.tb[subNode].son[1], TestExp];	  syms.tb[subNode].son[2] ¬ selection[syms, syms.tb[subNode].son[2]];	  i ¬ i+1;	  ENDLOOP;	switchable ¬ FALSE;  count ¬ 0;	WHILE i <= nSons DO  -- N.B. implicisyms.tbias is never changed by this loop	  subNode ¬ GetNode[syms, syms.tb[listNode].son[i]];	  IF ~syms.tb[subNode].attr1 OR multiword THEN EXIT;	  syms.tb[subNode].son[1] ¬ UpdateList[syms, syms.tb[subNode].son[1], SwitchValue];	  syms.tb[subNode].son[2] ¬ selection[syms, syms.tb[subNode].son[2]];	  switchable ¬ TRUE;  last ¬ i;  i ¬ i+1;	  ENDLOOP;	IF switchable	 AND SwitchWorthy[count,	      (max¬TreeLiteralValue[maxTree])-(min¬TreeLiteralValue[minTree])] THEN {	  copying ¬ TRUE;	  FOR j IN [next .. first) DO PushTree[syms, syms.tb[listNode].son[j]] ENDLOOP;	  PushTree[syms, AdjustBias[Tree.Null, min]];	  PushTree[syms, MakeTreeLiteral[max-min+1]];	  FOR j IN [first .. last] DO PushTree[syms, SwitchTree[syms.tb[listNode].son[j], min]] ENDLOOP;	  PushProperList[syms, last-first+1];	  PushNode[syms, caseswitch, 3];	   next ¬ last+1;  newSons ¬ newSons - (last-first)};	ENDLOOP;      IF copying THEN {	FOR j IN [next .. nSons] DO PushTree[syms, syms.tb[listNode].son[j]] ENDLOOP;	PushProperList[syms, newSons];  son[2] ¬ PopTree[syms]};      son[3] ¬ selection[syms, son[3]];      val ¬ Tree.Link[subtree[index: node]]};    passPtr.implicitAttr ¬ saveAttr;  passPtr.implicitBias ¬ saveBias;    passPtr.implicitType ¬ saveType;    RETURN};  -- auxiliary routines for CaseDriver    SwitchWorthy: PROC [entries, delta: CARDINAL] RETURNS [BOOLEAN] = {      -- the decision function for using a switch      RETURN [delta < 77777b AND delta+6 < 3*entries]};    SwitchTree: PROC [t: Tree.Link, offset: INTEGER] RETURNS [Tree.Link] = {      node: Tree.Index = GetNode[syms, t];      count: CARDINAL;      PushSwitchEntry: TreeOps.Scan = {	subNode: Tree.Index = GetNode[syms, t];	count ¬ count+1;	PushTree[syms, MakeTreeLiteral[TreeLiteralValue[syms.tb[subNode].son[2]]-offset]]};      count ¬ 0;  ScanList[syms, syms.tb[node].son[1], PushSwitchEntry];      PushList[syms, count];  PushTree[syms, syms.tb[node].son[2]];      syms.tb[node].son[2] ¬ Tree.Null;  FreeNode[syms, node];      RETURN [MakeNode[syms, casetest, 2]]}; -- iterative statements  DoStmt: PROC [node: Tree.Index] RETURNS [val: Tree.Link] = {    OPEN syms.tb[node];    void: BOOLEAN ¬ FALSE;    bti: BTIndex ¬ BTNull;    IF son[1] # Tree.Null THEN [bti, void] ¬ ForClause[GetNode[syms, son[1]]];    IF son[2] # Tree.Null THEN {      son[2] ¬ BoolValue[son[2]];  VPop[];      IF TreeLiteral[son[2]] THEN SELECT TreeLiteralValue[son[2]] FROM	1 => son[2] ¬ FreeTree[syms, son[2]];	0 => void ¬ TRUE;	ENDCASE};    son[3] ¬ UpdateList[syms, son[3], OpenItem];    son[4] ¬ UpdateList[syms, son[4], Stmt];    son[5] ¬ UpdateList[syms, son[5], Stmt];    son[6] ¬ UpdateList[syms, son[6], Stmt];    son[3] ¬ ReverseUpdateList[syms, son[3], CloseItem];    IF catchScope AND bti # BTNull THEN      catchBound ¬ MAX[AssignBlock[bti, catchBase], catchBound];    IF ~void THEN val ¬ [subtree[index: node]]    ELSE {val ¬ son[6]; son[6] ¬ Tree.Null; FreeNode[syms, node]};    RETURN};  ForClause: PROC [node: Tree.Index] RETURNS [bti: BTIndex, void: BOOLEAN] = {    idBias: INTEGER;    idRep, rep: Repr;    idType, type1, type2: CSEIndex;    iNode: Tree.Index;    range: CARDINAL;    void ¬ FALSE;  bti ¬ DecodeBti[syms.tb[node].info];    IF syms.tb[node].son[1] = Tree.Null THEN {      idType ¬ dataPtr.typeINT; idBias ¬ 0; idRep ¬ both}    ELSE {      IF OpName[syms, syms.tb[node].son[1]] = decl THEN {	subNode: Tree.Index ¬ GetNode[syms, syms.tb[node].son[1]];	ScanList[syms, syms.tb[node].son[1], DeclItem];	syms.tb[node].son[1] ¬ syms.tb[subNode].son[1];	syms.tb[subNode].son[1] ¬ Tree.Null;  FreeNode[syms, subNode]};      idType ¬ OperandType[syms.tb[node].son[1]];      syms.tb[node].son[1] ¬ Exp[syms.tb[node].son[1], none];      idBias ¬ VBias[];  idRep ¬ VRep[]; VPop[]};    SELECT syms.tb[node].name FROM      forseq => {	syms.tb[node].son[2] ¬ Rhs[syms.tb[node].son[2], idType];  VPop[];	syms.tb[node].son[3] ¬ Rhs[syms.tb[node].son[3], idType];  VPop[]};      upthru, downthru => {	syms.tb[node].son[2] ¬ NormalizeRange[syms.tb[node].son[2]];	iNode ¬ GetNode[syms, syms.tb[node].son[2]];	type1 ¬ OperandType[syms.tb[iNode].son[1]];	type2 ¬ OperandType[syms.tb[iNode].son[2]];	syms.tb[node].attr1 ¬ Interval[iNode, idBias, idRep].const AND syms.seb[idType].typeTag # long;	IF syms.tb[node].attr1 AND ~syms.tb[iNode].attr2 THEN	  [] ¬ ConstantInterval[iNode ! EmptyInterval => {void ¬ TRUE; RESUME}];	rep ¬ CommonRep[VRep[], idRep];	syms.tb[iNode].attr3 ¬ rep # unsigned;  VPop[];	IF rep = none OR (rep = unsigned AND idBias > 0) THEN	  Log.ErrorTree[mixedRepresentation, syms.tb[node].son[2]];	SELECT TRUE FROM	  void => NULL;	  (WordsForType[idType] = 0) => Log.ErrorTree[sizeClash, syms.tb[node].son[1]];	  (idType # dataPtr.typeINT) AND (idType # typeANY) => {	    OPEN syms.tb[iNode];	    range ¬ P4.CheckOver[Cardinality[syms, idType]];	    IF (checked OR dataPtr.switches['b]) AND range # 0 THEN	      IF (Cover[idType, idRep, type1, rep] # full AND RangeTest[son[1], range] # in)	       OR		 (Cover[idType, idRep, type2, rep] # full AND RangeTest[son[2], range] # in) THEN		syms.tb[node].son[3] ¬ MakeTreeLiteral[range];	    IF name = intCC AND type2 # dataPtr.typeINT THEN	      IF TreeLiteral[son[1]] AND	       INTEGER[TreeLiteralValue[son[1]]]+idBias <= BiasForType[type2] THEN	        syms.tb[node].attr1 ¬ TRUE;	    IF syms.tb[node].attr1 AND range # 0 THEN {	-- nonvoid interval	      IF (name=intCC OR name=intCO) AND RangeTest[son[1], range] = out THEN	        Log.ErrorTree[boundsFault, son[1]];	      IF (name=intCC OR name=intOC) AND RangeTest[son[2], range] = out THEN	        Log.ErrorTree[boundsFault, son[2]]}};	  ENDCASE};      ENDCASE => ERROR;    RETURN};  RangeTest: PROC [t: Tree.Link, range: CARDINAL] RETURNS [{in, out, unknown}] = {    RETURN [IF TreeLiteral[t]	THEN IF TreeLiteralValue[t] < range THEN in ELSE out	ELSE unknown]}; -- free  Free: PROC [node: Tree.Index] RETURNS [Tree.Link] = {    OPEN syms.tb[node];    vType, pType: CSEIndex;    IF son[1] # Tree.Null THEN {son[1] ¬ Exp[son[1], none]; VPop[]};    son[2] ¬ NeutralExp[syms, son[2]];    vType ¬ OperandType[son[2]];  pType ¬ DerefType[vType];    IF OpName[syms, son[2]] = addr THEN {      subNode: Tree.Index = GetNode[syms, son[2]];      son[2] ¬ syms.tb[subNode].son[1];  syms.tb[subNode].son[1] ¬ Tree.Null;  FreeNode[syms, subNode]}    ELSE {      PushTree[syms, son[2]];  PushNode[syms, uparrow, 1];        SetInfo[syms, EncodeSei[pType]];      SetAttr[syms, 1, checked OR dataPtr.switches['n]];      SetAttr[syms, 2, syms.seb[vType].typeTag = long];      son[2] ¬ PopTree[syms]};    syms.tb[node].son[3] ¬ MakeTreeLiteral[WordsForType[DerefType[pType]]];    IF nSons > 3 THEN CatchNest[son[4]];    RETURN [[subtree[index: node]]]}; -- basing  DerefType: PROC [type: CSEIndex] RETURNS [CSEIndex] = {    subType: CSEIndex = NormalType[syms, type];    RETURN [WITH syms.seb[subType] SELECT FROM      ref => UnderType[syms, refType],      ENDCASE => type]};  OpenItem: TreeOps.Map = {    node: Tree.Index = GetNode[syms, t];    IF OpName[syms, syms.tb[node].son[2]] # openx THEN v ¬ Tree.Null    ELSE {v ¬ NeutralExp[syms, syms.tb[node].son[2]]; syms.tb[node].son[2] ¬ Tree.Null};    FreeNode[syms, node];    RETURN};  CloseItem: TreeOps.Map = {    node: Tree.Index;    IF syms.bb[currentBody].firstSon # BTNull OR OpName[syms, t] # openx THEN v ¬ t    ELSE {      SetShared[syms, t, FALSE];  node ¬ GetNode[syms, t];      v ¬ syms.tb[node].son[1];  syms.tb[node].son[1] ¬ Tree.Null;  FreeNode[syms, node]};    RETURN}; -- catch phrases  CatchFrameBase: CARDINAL = 4--SIZE[CatchFormat.CatchFrame]-- * WordLength;  catchScope: BOOLEAN;  catchBase: CARDINAL;  catchBound: CARDINAL;  CatchNest: PUBLIC PROC [t: Tree.Link] = {    IF t # Tree.Null THEN CatchPhrase[t]};  CatchPhrase: PROC [t: Tree.Link] = {    node: Tree.Index = GetNode[syms, t];    saveCatchScope: BOOLEAN = catchScope;    saveCatchBase: CARDINAL = catchBase;    saveCatchBound: CARDINAL = catchBound;    saveLevel: CARDINAL = currentLevel;    bound: CARDINAL;    CatchTest: TreeOps.Map = {      PushTree[syms, Tree.Null];  PushTree[syms, Exp[t, none]];  VPop[];      PushNode[syms, relE, 2];  SetInfo[syms, EncodeSei[dataPtr.typeBOOL]];      RETURN [PopTree[syms]]};    CatchItem: TreeOps.Scan = {      node: Tree.Index = GetNode[syms, t];      type: CSEIndex = DecodeCSei[syms.tb[node].info];      saveRecord: RecordSEIndex = passPtr.resumeRecord;      syms.tb[node].son[1] ¬ UpdateList[syms, syms.tb[node].son[1], CatchTest];      catchBase ¬ CatchFrameBase;      IF type = SENull THEN passPtr.resumeRecord ¬ RecordSENull      ELSE	WITH t: syms.seb[type] SELECT FROM	  transfer => {	    passPtr.resumeRecord ¬ ArgRecord[syms, t.typeOut];	    catchBase ¬ catchBase +	      ArgLength[ArgRecord[syms, t.typeIn]] + ArgLength[passPtr.resumeRecord]};	  ENDCASE => ERROR;      catchBound ¬ catchBase;      syms.tb[node].son[2] ¬ Stmt[syms, syms.tb[node].son[2]];      bound ¬ MAX[bound, catchBound];      passPtr.resumeRecord ¬ saveRecord};    bti: CCBTIndex = LOOPHOLE[syms.tb[node].info];    syms.bb[bti].index ¬ dataPtr.catchIndex;  dataPtr.catchIndex ¬ dataPtr.catchIndex + 1;    catchScope ¬ TRUE;     currentLevel ¬ syms.bb[bti].level;    bound ¬ CatchFrameBase + WordLength;    ScanList[syms, syms.tb[node].son[1], CatchItem];    IF syms.tb[node].nSons > 1 THEN {      catchBound ¬ catchBase ¬ CatchFrameBase;      syms.tb[node].son[2] ¬ Stmt[syms, syms.tb[node].son[2]];      bound ¬ MAX[bound, catchBound]};    WITH body: syms.bb[bti].info SELECT FROM      Internal => body.frameSize ¬ (bound + (WordLength-1))/WordLength;      ENDCASE => ERROR;    catchBase ¬ saveCatchBase;  catchBound ¬ saveCatchBound;    currentLevel ¬ saveLevel;  catchScope ¬ saveCatchScope};  ArgLength: PROC [rSei: RecordSEIndex] RETURNS [CARDINAL] = {    RETURN [IF rSei = SENull THEN 0 ELSE syms.seb[rSei].length]};  }.
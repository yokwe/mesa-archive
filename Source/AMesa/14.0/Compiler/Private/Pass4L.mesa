-- Copyright (C) 1984, 1986  by Xerox Corporation. All rights reserved. -- file Pass4L.Mesa--   Satterthwaite,	October 8, 1982 3:42 pm--   Sweet,		 9-Jan-84 14:38:15--   Wagner		28-Aug-86  9:24:49--   Saxe		24-Apr-87 14:21:11DIRECTORY  BcdDefs USING [Link],  ComData USING [    idANY, importCtx, interface, linkCount, nBodies, nSigCodes, switches,    textIndex, zone],  CompilerUtil USING [AppendBCDWord, AppendBCDWords],  CLog USING [Error, ErrorN, ErrorSei, WarningSei],  P4 USING [CheckOver],  PrincOps USING [    ControlLink, globalbase, localbase, LocalOverhead, MaxFrameSize],  Symbols USING [    BitAddress, ByteLength, WordLength,    SEIndex, ISEIndex, CSEIndex, RecordSEIndex, CTXIndex, BTIndex, CBTIndex,    HTNull, SENull, ISENull, CTXNull, BTNull, lL, RootBti, DummyLink],  SymbolOps USING [    ArgCtx, ArgRecord, BitsForRange, Cardinality, FirstCtxSe, LinkMode,    MakeCtxSe, NextSe, PackedSize, TypeForm, UnderType, XferMode,    FromBitAddr, FromCard, ToBitAddr, ToCard, ToLink, ToSei, ToTreeIndex],  SymbolTable USING [Handle],  Tree USING [Index, NullIndex],  TreeOps USING [DecodeCard, Scan, ScanList];Pass4L: PROGRAM    IMPORTS      CompilerUtil, Log: CLog, P4, SymbolOps, TreeOps,      dataPtr: ComData    EXPORTS P4 = {  OPEN SymbolOps, Symbols;  syms: SymbolTable.Handle ¬ NIL;    Pass4LInit: PUBLIC PROC [h: SymbolTable.Handle] = { syms ¬ h }; -- address assignment (machine sensitive and subject to change)  WordFill: CARDINAL = WordLength-1;  BytesPerWord: CARDINAL = WordLength/ByteLength;  LocalOrigin: CARDINAL = PrincOps.localbase*WordLength;  LocalSlots: CARDINAL = 8;  GlobalOrigin: CARDINAL = PrincOps.globalbase*WordLength;  FrameLimit: CARDINAL = (PrincOps.MaxFrameSize-SIZE[PrincOps.LocalOverhead])*WordLength;  EntryLimit: CARDINAL = 256;	-- fix this for Whitney    BitsForType: PUBLIC PROC [type: SEIndex] RETURNS [nBits: LONG CARDINAL] = {    -- assumes (an attempt at) prior processing by P4.DeclItem    sei: CSEIndex = UnderType[syms, type];    WITH syms.seb[sei] SELECT FROM      basic => nBits ¬ length;      enumerated => nBits ¬ BitsForRange[Cardinality[syms, sei]-1];      ref => nBits ¬ WordLength;      transfer => nBits ¬ WordLength*(SELECT mode FROM        port => 4, process => 1, ENDCASE => 2);      arraydesc => nBits ¬ 2*WordLength;      relative => nBits ¬ BitsForType[offsetType];      zone => nBits ¬ (IF mds THEN 1 ELSE 2)*WordLength;      long => nBits ¬ ((BitsForType[rangeType] + WordFill)/WordLength + 1)*WordLength;      real => nBits ¬ 2*WordLength;      ENDCASE => {  -- processing of se entry must be complete	IF ~mark4 THEN {	-- P4declitem has not been able to complete	  Log.ErrorSei[typeLength,		IF syms.seb[type].seTag = id THEN LOOPHOLE[type, ISEIndex] ELSE ISENull];	  RETURN [0]};	WITH syms.seb[sei] SELECT FROM	  record => nBits ¬ length;	  array => {	    n: CARDINAL = P4.CheckOver[Cardinality[syms, indexType]];	    b: CARDINAL ¬ P4.CheckOver[BitsForType[componentType]];	    IF packed AND b <= ByteLength THEN {	      b ¬ PackedSize[b];	      nBits ¬ IF n <= WordLength/b			THEN n*b			ELSE ((n+(WordLength/b-1))/(WordLength/b))*WordLength}	    ELSE {	      b ¬ ((b + WordFill)/WordLength)*WordLength;	      IF n > LAST[CARDINAL]/b THEN Log.Error[fieldSize];	      nBits ¬ n*b}};	  opaque => nBits ¬ length;	  subrange => nBits ¬ IF empty THEN 0 ELSE BitsForRange[Cardinality[syms, sei]-1];	  ENDCASE => nBits ¬ 0};    RETURN}; -- profile utilities  VarLink: TYPE = RECORD [    SELECT kind: * FROM      symbol => [index: ISEIndex],      body => [index: CBTIndex],      empty => NULL,      ENDCASE];  VarInfo: TYPE = RECORD [link: VarLink, key: CARDINAL];  VarInfoList: TYPE = RECORD [SEQUENCE length: NAT OF VarInfo];  Profile: TYPE = LONG POINTER TO VarInfoList;    AllocateProfile: PROC [n: CARDINAL] RETURNS [profile: Profile] = {    profile ¬ (dataPtr.zone).NEW[VarInfoList[n]];    FOR k: CARDINAL IN [0 .. n) DO profile[k].link ¬ [empty[]] ENDLOOP;    RETURN};  ReleaseProfile: PROC [profile: Profile] = {(dataPtr.zone).FREE[@profile]};  SortProfile: PROC [v: Profile] = {  -- Shell sort --    i, j: INTEGER;    h, k: CARDINAL;    t: VarInfo;    h ¬ v.length;    DO      h ¬ h/2;      FOR j IN [INTEGER[h] .. v.length) DO	i ¬ j-h;  k ¬ v[j].key;  t ¬ v[j];	WHILE k > v[i].key DO	  v[i+h] ¬ v[i];	  IF (i ¬ i-h) < 0 THEN EXIT;	  ENDLOOP;	v[i+h] ¬ t;	ENDLOOP;      IF h <= 1 THEN EXIT;      ENDLOOP}; -- entry point assignment  GenBodies: PROC [root: BTIndex, proc: PROC [CBTIndex]] = {    bti, next: BTIndex;    FOR bti ¬ root, next UNTIL bti = BTNull DO      WITH syms.bb[bti] SELECT FROM	Callable => IF nesting # Catch THEN proc[LOOPHOLE[bti]];	ENDCASE => NULL;      IF syms.bb[bti].firstSon # BTNull THEN next ¬ syms.bb[bti].firstSon      ELSE	DO	  next ¬ syms.bb[bti].link.index;	  IF next = BTNull OR syms.bb[bti].link.which # parent THEN EXIT;	  bti ¬ next;	  ENDLOOP;      ENDLOOP};  BodyRefs: PROC [bti: CBTIndex] RETURNS [count: CARDINAL¬0] = {    sei: ISEIndex = syms.bb[bti].id;    CountRefs: TreeOps.Scan = {      count ¬ WITH t SELECT FROM	symbol => count + ToCard[syms.seb[index].idInfo],	ENDCASE => ERROR};    IF sei # ISENull THEN {      node: Tree.Index = ToTreeIndex[syms.seb[sei].idValue];      TreeOps.ScanList[syms, syms.tb[node].son[1], CountRefs]};    RETURN};  AssignEntries: PUBLIC PROC [rootBti: BTIndex] = {    i, k: INTEGER;    profile: Profile;    bti: CBTIndex;    AssignSlot: PROC [bti: CBTIndex] = {      IF ~syms.bb[bti].inline AND syms.bb[bti].info.mark = Internal  THEN {	n: CARDINAL = BodyRefs[bti];	profile[k].link ¬ [body[index: bti]];	WITH body: syms.bb[bti] SELECT FROM	  Inner => {body.frameOffset ¬ n; profile[k].key ¬ 0};	  ENDCASE => profile[k].key ¬ n;	k ¬ k+1}};    nEntries: CARDINAL = MAX[dataPtr.nBodies, dataPtr.nSigCodes];    IF nEntries > EntryLimit THEN Log.ErrorN[bodyEntries, nEntries-EntryLimit];    profile ¬ AllocateProfile[dataPtr.nBodies];    k ¬ 0;  GenBodies[rootBti, AssignSlot];    IF dataPtr.switches['s] THEN SortProfile[profile];    i ¬ 1;    FOR j: INTEGER IN [0..profile.length) DO      bti ¬ WITH profile[j].link SELECT FROM body => index, ENDCASE => ERROR;      IF bti = RootBti THEN syms.bb[bti].entryIndex ¬ 0      ELSE {syms.bb[bti].entryIndex ¬ i; i ¬ i+1};      ENDLOOP;    ReleaseProfile[profile]}; -- frame layout  VarScan: TYPE = PROC [sei: ISEIndex, output: BOOLEAN];  GenCtxVars: PROC [ctx: CTXIndex, p: VarScan, output: BOOLEAN] = {    FOR sei: ISEIndex ¬ FirstCtxSe[syms, ctx], NextSe[syms, sei] UNTIL sei = ISENull DO      IF ~syms.seb[sei].constant THEN p[sei, output] ENDLOOP};  GenBodyVars: PROC [bti: CBTIndex, p: VarScan] = {    type: SEIndex = syms.bb[bti].ioType;    WITH se: syms.seb[type] SELECT FROM      cons =>	WITH t: se SELECT FROM	  transfer => {	    GenCtxVars[ArgCtx[syms, t.typeIn], p, FALSE];	    GenCtxVars[ArgCtx[syms, t.typeOut], p, TRUE]};	  ENDCASE;      ENDCASE;    GenCtxVars[syms.bb[bti].localCtx, p, FALSE]};  GenBodyProcs: PROC [bti: BTIndex, proc: PROC [CBTIndex]] = {    sonBti: BTIndex;    IF (sonBti ¬ syms.bb[bti].firstSon) # BTNull THEN      DO	WITH body: syms.bb[sonBti] SELECT FROM	  Callable =>	    IF ~body.inline AND body.nesting # Catch THEN proc[LOOPHOLE[sonBti]];	  ENDCASE => NULL;	IF syms.bb[sonBti].link.which = parent THEN EXIT;	sonBti ¬ syms.bb[sonBti].link.index;	ENDLOOP};  GenImportedVars: PROC [p: VarScan] = {    ctx: CTXIndex = dataPtr.importCtx;    FOR sei: ISEIndex ¬ FirstCtxSe[syms, ctx], NextSe[syms, sei] UNTIL sei = ISENull DO      IF ~syms.seb[sei].constant THEN p[sei, FALSE]      ELSE {	type: CSEIndex = UnderType[syms, syms.seb[sei].idType];	WITH syms.seb[type] SELECT FROM definition => GenCtxVars[defCtx, p, FALSE] ENDCASE};      ENDLOOP};  MarkArg: VarScan = {syms.seb[sei].mark4 ¬ TRUE};  MarkArgs: PROC [sei: SEIndex] = {    type: CSEIndex = UnderType[syms, sei];    rSei: RecordSEIndex;    WITH t: syms.seb[type] SELECT FROM      transfer => {	IF (rSei ¬ ArgRecord[syms, t.typeIn]) # SENull THEN {	  GenCtxVars[syms.seb[rSei].fieldCtx, MarkArg, FALSE];	  syms.seb[rSei].length ¬ LayoutArgs[rSei, 0, TRUE]*WordLength;	  syms.seb[rSei].mark4 ¬ TRUE};	IF (rSei ¬ ArgRecord[syms, t.typeOut]) # SENull THEN {	  GenCtxVars[syms.seb[rSei].fieldCtx, MarkArg, TRUE];	  syms.seb[rSei].length ¬ LayoutArgs[rSei, 0, TRUE]*WordLength;	  syms.seb[rSei].mark4 ¬ TRUE};	t.mark4 ¬ TRUE};      ENDCASE};  LayoutLocals: PUBLIC PROC [bti: CBTIndex] RETURNS [length: CARDINAL] = {    vProfile: Profile;    vI: CARDINAL;        CountVar: VarScan = {      IF syms.seb[sei].hash # HTNull OR syms.seb[sei].extended OR ~output THEN vI ¬ vI + 1};    CountProc: PROC [bti: CBTIndex] = {      IF syms.bb[bti].info.mark = Internal THEN vI ¬ vI + 1};    InsertVar: VarScan = {      saveIndex: CARDINAL = dataPtr.textIndex;      node: Tree.Index = ToTreeIndex[syms.seb[sei].idValue];      nW: CARDINAL;      IF node # Tree.NullIndex THEN         dataPtr.textIndex ¬ TreeOps.DecodeCard[syms.tb[node].info];      IF syms.seb[sei].hash # HTNull OR syms.seb[sei].extended OR ~output THEN {        vProfile[vI] ¬ [link: [symbol[sei]], key: ToCard[syms.seb[sei].idInfo]]; 	vI ¬ vI+1};      IF ToCard[syms.seb[sei].idInfo] = 0 AND syms.seb[sei].hash # HTNull       AND ~output	-- suppress message for return record       AND node # Tree.NullIndex THEN Log.WarningSei[unusedId, sei];      nW ¬ P4.CheckOver[(BitsForType[syms.seb[sei].idType] + WordFill)/WordLength];      syms.seb[sei].idInfo ¬ FromCard[nW*WordLength];        syms.seb[sei].idValue ¬ FromCard[0];      dataPtr.textIndex ¬ saveIndex};    InsertProc: PROC [bti: CBTIndex] = {      IF syms.bb[bti].info.mark = Internal THEN {	vProfile[vI] ¬ VarInfo[	    link: [body[bti]],	    key: WITH syms.bb[bti] SELECT FROM Inner=>frameOffset, ENDCASE=>0];	vI ¬ vI+1}};    bodyType: SEIndex = syms.bb[bti].ioType;    origin: CARDINAL ¬ IF syms.bb[bti].level = lL THEN LocalOrigin ELSE LocalOrigin+WordLength;    IF ~syms.seb[bodyType].mark4 THEN MarkArgs[bodyType];    vI ¬ 0;  GenBodyVars[bti, CountVar];  GenBodyProcs[bti, CountProc];    vProfile ¬ AllocateProfile[vI];    vI ¬ 0;  GenBodyVars[bti, InsertVar];  GenBodyProcs[bti, InsertProc];    SortProfile[vProfile];    origin ¬ AssignVars[vProfile, origin, LocalOrigin + LocalSlots*WordLength];    length ¬ AssignVars[vProfile, origin, FrameLimit];    CheckFrameOverflow[vProfile];  ReleaseProfile[vProfile];    RETURN};  LayoutGlobals: PUBLIC PROC [bti: CBTIndex, stopping, fragments: BOOLEAN]      RETURNS [length: CARDINAL] = {    vProfile, xProfile: Profile;    vI, xI: CARDINAL;    CountVar: VarScan = {      ctx: CTXIndex = syms.seb[sei].idCtx;      IF syms.ctxb[ctx].ctxType = imported OR ctx = dataPtr.importCtx THEN xI ¬ xI + 1      ELSE IF syms.seb[sei].hash # HTNull OR syms.seb[sei].extended OR ~output THEN vI ¬ vI + 1};    InsertVar: VarScan = {      ctx: CTXIndex = syms.seb[sei].idCtx;      IF syms.ctxb[ctx].ctxType = imported OR ctx = dataPtr.importCtx THEN {	xProfile[xI] ¬ [link: [symbol[sei]], key: ToCard[syms.seb[sei].idInfo]];	xI ¬ xI+1;	IF ToCard[syms.seb[sei].idInfo] = 0 AND ~syms.seb[sei].public THEN	  Log.WarningSei[unusedId, sei];	syms.seb[sei].idInfo ¬ FromCard[P4.CheckOver[	  ((BitsForType[syms.seb[sei].idType]+WordFill)/WordLength)*WordLength]]}      ELSE {	saveIndex: CARDINAL = dataPtr.textIndex;	node: Tree.Index = ToTreeIndex[syms.seb[sei].idValue];	nW: CARDINAL;	IF node # Tree.NullIndex THEN 	  dataPtr.textIndex ¬ TreeOps.DecodeCard[syms.tb[node].info];	IF syms.seb[sei].hash # HTNull OR syms.seb[sei].extended OR ~output THEN {	  vProfile[vI] ¬ [link: [symbol[sei]], key: ToCard[syms.seb[sei].idInfo]]; 	  vI ¬ vI + 1};	IF ToCard[syms.seb[sei].idInfo] = 0 AND ~dataPtr.interface	 AND ~syms.seb[sei].public AND syms.seb[sei].hash # HTNull	 AND node # Tree.NullIndex THEN Log.WarningSei[unusedId, sei];	nW ¬ P4.CheckOver[(BitsForType[syms.seb[sei].idType] + WordFill)/WordLength];	syms.seb[sei].idInfo ¬ FromCard[nW*WordLength];  	syms.seb[sei].idValue ¬ FromCard[0];	dataPtr.textIndex ¬ saveIndex}};    origin: CARDINAL ¬ GlobalOrigin;    IF ~syms.seb[syms.bb[bti].ioType].mark4 THEN ERROR;    vI ¬ xI ¬ 0;  GenBodyVars[bti, CountVar];  GenImportedVars[CountVar];    vProfile ¬ AllocateProfile[vI];  xProfile ¬ AllocateProfile[xI];    vI ¬ xI ¬ 0;  GenBodyVars[bti, InsertVar];  GenImportedVars[InsertVar];    IF dataPtr.switches['s] THEN {SortProfile[vProfile]; SortProfile[xProfile]};    AssignImports[xProfile, 0, 256*WordLength*linkLength];    SELECT TRUE FROM	-- adjust for system uses of global 0      stopping => origin ¬ origin + WordLength;      fragments =>	-- avoid fragment (length >= 2*WordLength) overlay of global 0 (used for start traps)	origin ¬ MAX[	  AssignVars[vProfile, origin, GlobalOrigin+WordLength],	  GlobalOrigin+WordLength];      ENDCASE;    origin ¬ AssignVars[vProfile, origin, FrameLimit];    length ¬ MAX[origin, GlobalOrigin+WordLength];    CheckFrameOverflow[vProfile];  ReleaseProfile[vProfile];    CheckFrameOverflow[xProfile];  ReleaseProfile[xProfile];    RETURN};  CheckBlock: PUBLIC PROC [bti: BTIndex] = {    CheckVar: VarScan = {      saveIndex: CARDINAL = dataPtr.textIndex;      node: Tree.Index = ToTreeIndex[syms.seb[sei].idValue];      IF node # Tree.NullIndex THEN {	dataPtr.textIndex ¬ TreeOps.DecodeCard[syms.tb[node].info];	IF ToCard[syms.seb[sei].idInfo] = 0 THEN Log.WarningSei[unusedId, sei]};      dataPtr.textIndex ¬ saveIndex};    GenCtxVars[syms.bb[bti].localCtx, CheckVar, FALSE]};  LayoutBlock: PUBLIC PROC [bti: BTIndex, origin: CARDINAL]      RETURNS [length: CARDINAL] = {    vProfile: Profile;    vI: CARDINAL;    CountVar: VarScan = {vI ¬ vI + 1};    CountProc: PROC [bti: CBTIndex] = {      IF syms.bb[bti].info.mark = Internal THEN vI ¬ vI + 1};    InsertVar: VarScan = {      nW: CARDINAL;      vProfile[vI] ¬ [link: [symbol[sei]], key: ToCard[syms.seb[sei].idInfo]];       vI ¬ vI+1;      nW ¬ P4.CheckOver[(BitsForType[syms.seb[sei].idType] + WordFill)/WordLength];      syms.seb[sei].idInfo ¬ FromCard[nW*WordLength];        syms.seb[sei].idValue ¬ FromCard[0]};    InsertProc: PROC [bti: CBTIndex] = {      IF syms.bb[bti].info.mark = Internal THEN {	vProfile[vI] ¬ VarInfo[	    link: [body[bti]],	    key: WITH syms.bb[bti] SELECT FROM Inner=>frameOffset, ENDCASE=>0];	vI ¬ vI+1}};    vI ¬ 0;  GenCtxVars[syms.bb[bti].localCtx, CountVar, FALSE];  GenBodyProcs[bti, CountProc];    vProfile ¬ AllocateProfile[vI];    vI ¬ 0;  GenCtxVars[syms.bb[bti].localCtx, InsertVar, FALSE];  GenBodyProcs[bti, InsertProc];    SortProfile[vProfile];    length ¬ AssignVars[vProfile, origin, FrameLimit];    CheckFrameOverflow[vProfile];  ReleaseProfile[vProfile];    RETURN};  LayoutInterface: PUBLIC PROC [bti: CBTIndex] RETURNS [nEntries: CARDINAL] = {    epN: CARDINAL ¬ 0;    FOR sei: ISEIndex ¬ FirstCtxSe[syms, syms.bb[bti].localCtx], NextSe[syms, sei] UNTIL sei = ISENull DO      SELECT LinkMode[syms, sei] FROM	val, ref => {	  syms.seb[sei].linkSpace ¬ TRUE; 	  syms.seb[sei].idValue ¬ FromCard[epN]; 	  epN ¬ epN + 1};	type => {syms.seb[sei].idValue ¬ FromCard[epN]; epN ¬ epN + 1};	ENDCASE;      ENDLOOP;    IF (nEntries¬epN) > EntryLimit THEN Log.ErrorN[interfaceEntries, nEntries-EntryLimit];    RETURN};  CheckFrameOverflow: PROC [profile: Profile] = {    FOR i: INTEGER IN [0 .. profile.length) DO      WITH profile[i].link SELECT FROM	symbol => Log.ErrorSei[addressOverflow, index];	body => Log.ErrorSei[addressOverflow, syms.bb[index].id];	ENDCASE;      ENDLOOP};  Align: PROC [offset: CARDINAL, item: VarLink] RETURNS [CARDINAL] = {    RETURN [WITH item SELECT FROM      body => (offset+WordLength)/(4*WordLength)*(4*WordLength) + (2*WordLength),      symbol =>	SELECT XferMode[syms, syms.seb[index].idType] FROM	  port => (offset+WordLength)/(4*WordLength)*(4*WordLength) + (2*WordLength),	  ENDCASE => offset,      ENDCASE => offset]};  BitWidth: PROC [item: VarLink] RETURNS [CARDINAL] = {    RETURN [WITH item SELECT FROM      symbol => ToCard[syms.seb[index].idInfo],      body => WordLength*2,      ENDCASE => 0]};  AssignBase: PROC [item: VarLink, base: CARDINAL] = {    WITH item SELECT FROM      symbol => {	sei: ISEIndex = index;        syms.seb[sei].idValue ¬ FromBitAddr[[wd:base/WordLength, bd:0]];        syms.seb[sei].mark4 ¬ TRUE};      body => {	bti: CBTIndex = index;	WITH syms.bb[bti] SELECT FROM Inner => frameOffset ¬ base/WordLength ENDCASE => ERROR};      ENDCASE};  AssignVars: PROC [profile: Profile, origin, limit: CARDINAL] RETURNS [CARDINAL] = {    start, base, length, remainder, delta: CARDINAL;    i, j, next: INTEGER;    t: VarLink;    found, skips: BOOLEAN;    next ¬ 0;  start ¬ origin;    remainder ¬ IF origin < limit THEN limit - origin ELSE 0;    WHILE next < profile.length DO      i ¬ next;  found ¬ skips ¬ FALSE;      WHILE ~found AND i < profile.length DO	IF (t ¬ profile[i].link) # [empty[]] THEN {	  base ¬ Align[start, t];  length ¬ BitWidth[t];	  delta ¬ base - start;	  IF length + delta <= remainder THEN {	    limit: CARDINAL = base + length;	    subBase: CARDINAL ¬ start;	    nRefs: CARDINAL ¬ 0;	    FOR j ¬ i+1, j+1 WHILE j < profile.length AND subBase < limit DO	      IF profile[j].link # [empty[]] THEN {		subLength: CARDINAL = BitWidth[profile[j].link];		subDelta: CARDINAL = Align[subBase, profile[j].link] - subBase;		IF  (subDelta + subLength) > (limit - subBase) THEN EXIT;		subBase ¬ subBase + (subDelta + subLength);		nRefs ¬ nRefs + profile[j].key};	      ENDLOOP;	    IF nRefs <= profile[i].key OR ~dataPtr.switches['s] THEN {	      found ¬ TRUE;	      AssignBase[t, base];  profile[i].link ¬ [empty[]];	      IF base # start AND dataPtr.switches['s] THEN	        [] ¬ AssignVars[profile, start, base];	      start ¬ limit;	      remainder ¬ remainder - (length+delta)}	    ELSE IF ~skips THEN {skips ¬ TRUE; next ¬ i}}};	i ¬ i+1;	IF ~skips THEN next ¬ i;	ENDLOOP;      ENDLOOP;    RETURN [start]};  linkLength: CARDINAL = SIZE[PrincOps.ControlLink];    AssignImports: PROC [profile: Profile, origin, limit: CARDINAL] = {    i, nProcs: CARDINAL ¬ profile.length;    next: CARDINAL;    t: VarLink;    v: VarInfo;    UNTIL i = 0 DO      i ¬ i-1;  t ¬ profile[i].link;      WITH t SELECT FROM	symbol =>	  IF XferMode[syms, syms.seb[index].idType] # proc THEN {	    nProcs ¬ nProcs-1;  v ¬ profile[i];	    FOR j: CARDINAL IN [i..nProcs) DO profile[j] ¬ profile[j+1] ENDLOOP;	    profile[nProcs] ¬ v};	ENDCASE;      ENDLOOP;    -- the frame link fragment begins at origin      dataPtr.linkCount ¬ profile.length;      IF ~dataPtr.interface THEN CompilerUtil.AppendBCDWord[profile.length];    i ¬ profile.length;    next ¬ MIN[origin + profile.length*WordLength*linkLength, limit];    UNTIL i = 0 OR next = origin DO      i ¬ i-1;  t ¬ profile[i].link;  profile[i].link ¬ [empty[]];      IF ~dataPtr.interface THEN	WITH t SELECT FROM	  symbol => {	    sei: ISEIndex = index;	    dlink: Symbols.DummyLink = ToLink[syms.seb[sei].idValue];	    link: BcdDefs.Link;	    IF ToCard[syms.seb[sei].idInfo] # linkLength * WordLength THEN ERROR;	    link ¬ [procedure[gfi: dlink.gfi, ep: dlink.ep]];	    next ¬ next - linkLength * WordLength;	    CompilerUtil.AppendBCDWords[@link, SIZE[BcdDefs.Link]];	    syms.seb[sei].idValue ¬ FromBitAddr[[wd: next/WordLength, bd: 0]];	    syms.seb[sei].linkSpace ¬ TRUE};	  ENDCASE;      ENDLOOP}; -- parameter record  layout  LayoutArgs: PUBLIC PROC [argRecord: RecordSEIndex, origin: CARDINAL, body: BOOLEAN]      RETURNS [CARDINAL] = {    w: CARDINAL ¬ origin;    IF argRecord # SENull THEN {      ctx: CTXIndex = syms.seb[argRecord].fieldCtx;      FOR sei: ISEIndex ¬ FirstCtxSe[syms, ctx], NextSe[syms, sei] UNTIL sei = ISENull DO	nW: CARDINAL = 	  P4.CheckOver[(BitsForType[syms.seb[sei].idType] + WordFill)/WordLength];	IF nW = 0 THEN Log.ErrorSei[sizeClash, sei];	IF ~body THEN {	  syms.seb[sei].idInfo ¬ FromCard[nW*WordLength];	  syms.seb[sei].idValue ¬ FromBitAddr[[wd:w, bd:0]]};	w ¬ w + nW;	ENDLOOP};    RETURN [w]}; -- record layout  BitOffset: PROC [sei: ISEIndex] RETURNS [CARDINAL] = {    t: BitAddress = ToBitAddr[syms.seb[sei].idValue];     RETURN [t.wd*WordLength + t.bd]};  ScanVariants: PROC [caseCtx: CTXIndex, proc: PROC [RecordSEIndex] RETURNS [BOOLEAN]]      RETURNS [BOOLEAN] = {    FOR sei: ISEIndex ¬ FirstCtxSe[syms, caseCtx], NextSe[syms, sei] UNTIL sei = ISENull DO      rSei: SEIndex = ToSei[syms.seb[sei].idInfo];      WITH variant: syms.seb[rSei] SELECT FROM	cons =>	  WITH variant SELECT FROM	    record => IF proc[LOOPHOLE[rSei]] THEN RETURN [TRUE];	    ENDCASE => ERROR;	ENDCASE => NULL;	-- skip multiple identifiers      ENDLOOP;    RETURN [FALSE]};  LayoutFields: PUBLIC PROC [rSei: RecordSEIndex, offset: CARDINAL] = {    MaxRecordSize: CARDINAL = LAST[CARDINAL]/WordLength + 1;    w, b: CARDINAL;    lastFillable: BOOLEAN;    lastSei: ISEIndex;    AssignField: PROC [sei: ISEIndex] = {      OPEN id: syms.seb[sei];      n, nW, nB: CARDINAL;      saveIndex: CARDINAL = dataPtr.textIndex;      dataPtr.textIndex ¬ TreeOps.DecodeCard[syms.tb[ToTreeIndex[id.idValue]].info];      n ¬ P4.CheckOver[BitsForType[id.idType]];      nW ¬ n/WordLength;  nB ¬ n MOD WordLength;      IF nW > 0 AND nB # 0 THEN {nW ¬ nW+1; nB ¬ 0};      IF (nW > 0 OR b+nB > WordLength OR n = 0) AND b # 0 THEN {w ¬ w+1; b ¬ 0};      dataPtr.textIndex ¬ saveIndex;      IF b = 0 AND lastFillable THEN FillWord[lastSei];      IF w >= MaxRecordSize THEN Log.ErrorSei[addressOverflow, sei];      id.idInfo ¬ FromCard[nW*WordLength + nB];      id.idValue ¬ FromBitAddr[[wd:w, bd:b]];      lastSei ¬ sei;  lastFillable ¬ (nW = 0 AND n # 0);      w ¬ w + nW;  b ¬ b + nB;      IF b >= WordLength THEN {w ¬ w+1; b ¬ b - WordLength};      -- IF (IF b=0 THEN w ELSE w+1) >= MaxRecordSize THEN   	--  Log.ErrorSei[addressOverflow, sei];      };    FillWord: PROC [sei: ISEIndex] = {      t: BitAddress = ToBitAddr[syms.seb[sei].idValue];      width: CARDINAL = WordLength - t.bd;      IF syms.seb[rSei].machineDep AND width # ToCard[syms.seb[sei].idInfo] THEN	Log.WarningSei[recordGap, sei];      syms.seb[sei].idInfo ¬ FromCard[width]};    FindFit: PROC [vSei: RecordSEIndex] RETURNS [BOOLEAN] = {      sei: ISEIndex ¬ FirstCtxSe[syms, syms.seb[vSei].fieldCtx];      type: CSEIndex;      IF sei = ISENull THEN RETURN [FALSE];      type ¬ UnderType[syms, syms.seb[sei].idType];      WITH syms.seb[type] SELECT FROM	union =>	  IF controlled THEN sei ¬ tagSei	  ELSE RETURN [ScanVariants[caseCtx, FindFit]];	sequence => IF controlled THEN sei ¬ tagSei ELSE RETURN [FALSE];	ENDCASE => NULL;      RETURN [BitsForType[syms.seb[sei].idType] + b <= WordLength]};    vOrigin: CARDINAL;    maxLength: CARDINAL;    AssignVariant: PROC [vSei: RecordSEIndex] RETURNS [BOOLEAN] = {      LayoutFields[vSei, vOrigin];      maxLength ¬ MAX[syms.seb[vSei].length, maxLength];      RETURN [FALSE]};    eqLengths: BOOLEAN;    padEnd: CARDINAL;    PadVariant: PROC [vSei: RecordSEIndex] RETURNS [BOOLEAN] = {      fillSei: ISEIndex ¬ ISENull;      type: CSEIndex;      fillOrigin, currentEnd: CARDINAL;      ctx: CTXIndex = syms.seb[vSei].fieldCtx;      FOR sei: ISEIndex ¬ FirstCtxSe[syms, ctx], NextSe[syms, sei] UNTIL sei = ISENull DO	IF ToBitAddr[syms.seb[sei].idValue].wd # w THEN EXIT;	fillSei ¬ sei;	ENDLOOP;      IF fillSei # ISENull THEN {	fillOrigin ¬ BitOffset[fillSei];	currentEnd ¬ fillOrigin + ToCard[syms.seb[fillSei].idInfo];	IF currentEnd < padEnd AND (currentEnd # 0 OR padEnd < WordLength) THEN {	  type ¬ UnderType[syms, syms.seb[fillSei].idType];	  WITH syms.seb[type] SELECT FROM	    union => {	      saveLastSei: ISEIndex = lastSei;	      IF controlled THEN lastSei ¬ tagSei;	-- for messages only	      [] ¬ ScanVariants[caseCtx, PadVariant];	      lastSei ¬ saveLastSei};	    ENDCASE => IF syms.seb[rSei].machineDep THEN Log.WarningSei[recordGap, fillSei];	  syms.seb[fillSei].idInfo ¬  FromCard[padEnd - fillOrigin]}}      ELSE IF vOrigin < padEnd AND (vOrigin # 0 OR padEnd < WordLength) THEN {	IF syms.seb[rSei].machineDep THEN Log.WarningSei[recordGap, lastSei];	fillSei ¬ MakeCtxSe[syms, HTNull, CTXNull];	syms.seb[fillSei].public ¬ TRUE;  syms.seb[fillSei].extended ¬ FALSE;	syms.seb[fillSei].constant ¬ syms.seb[fillSei].immutable ¬ FALSE;	syms.seb[fillSei].linkSpace ¬ FALSE;	syms.seb[fillSei].idType ¬ dataPtr.idANY;	syms.seb[fillSei].idValue ¬ FromBitAddr[[wd:w, bd:b]];	syms.seb[fillSei].idInfo ¬ FromCard[padEnd - vOrigin];	syms.seb[fillSei].mark3 ¬ syms.seb[fillSei].mark4 ¬ TRUE;	WITH syms.seb[fillSei] SELECT FROM linked => link ¬ syms.ctxb[ctx].seList ENDCASE => ERROR;	syms.ctxb[ctx].seList ¬ fillSei};      syms.seb[vSei].length ¬ MIN[		maxLength,		(syms.seb[vSei].length + WordFill)/WordLength * WordLength];      IF syms.seb[vSei].length # maxLength THEN eqLengths ¬ FALSE;      RETURN [FALSE]};    type: CSEIndex;    ctx: CTXIndex = syms.seb[rSei].fieldCtx;    w ¬ offset/WordLength;  b ¬ offset MOD WordLength;    lastFillable ¬ FALSE;  lastSei ¬ ISENull;    FOR sei: ISEIndex ¬ FirstCtxSe[syms, ctx], NextSe[syms, sei] UNTIL sei = ISENull DO      IF ~syms.seb[sei].constant THEN {	type ¬ UnderType[syms, syms.seb[sei].idType];	WITH syms.seb[type] SELECT FROM	  union => {	    IF ~controlled THEN 	      syms.seb[sei].idValue ¬ FromBitAddr[[wd:w, bd:b]]	    ELSE {	      AssignField[tagSei]; 	      syms.seb[sei].idValue ¬ syms.seb[tagSei].idValue};	    IF lastFillable AND b # 0 AND ~ScanVariants[caseCtx, FindFit] THEN {	      FillWord[lastSei]; w ¬ w+1; b ¬ 0};	    maxLength ¬ vOrigin ¬ w*WordLength + b;	    [] ¬ ScanVariants[caseCtx, AssignVariant];	    padEnd ¬ IF maxLength < WordLength		THEN maxLength		ELSE MAX[(vOrigin + WordFill)/WordLength, 1]*WordLength;	    eqLengths ¬ TRUE;	    [] ¬ ScanVariants[caseCtx, PadVariant];	    hints.equalLengths ¬ eqLengths;	    syms.seb[sei].idInfo ¬ FromCard[(maxLength - vOrigin) + 	      (IF controlled THEN ToCard[syms.seb[tagSei].idInfo] ELSE 0)];	    w ¬ maxLength/WordLength;  b ¬ maxLength MOD WordLength;	    lastFillable ¬ FALSE};	  sequence => {	    IF ~controlled THEN syms.seb[sei].idValue ¬ FromBitAddr[[wd:w, bd:b]]	    ELSE {AssignField[tagSei]; syms.seb[sei].idValue ¬ syms.seb[tagSei].idValue};	    IF lastFillable AND b # 0 THEN {FillWord[lastSei]; w ¬ w+1; b ¬ 0};	    syms.seb[sei].idInfo ¬ FromCard[(w*WordLength+b) - BitOffset[sei]];	    lastFillable ¬ FALSE};	  ENDCASE => AssignField[sei]};      ENDLOOP;    IF lastFillable AND b # 0 AND w > 0 THEN {FillWord[lastSei]; b ¬ 0; w ¬ w+1};    syms.seb[rSei].length ¬ w*WordLength + b};  CheckFields: PUBLIC PROC [rSei: RecordSEIndex, origin: CARDINAL] = {    vProfile: Profile;    vI: CARDINAL;    CountVar: VarScan = {vI ¬ vI + 1};    InsertVar: VarScan = {      vProfile[vI] ¬ [link:[symbol[sei]], key:BitOffset[sei]]; vI ¬ vI+1};    b, newB: CARDINAL;    sei, lastSei: ISEIndex;    vI ¬ 0;  GenCtxVars[syms.seb[rSei].fieldCtx, CountVar, FALSE];    vProfile ¬ AllocateProfile[vI];    vI ¬ 0;  GenCtxVars[syms.seb[rSei].fieldCtx, InsertVar, FALSE];    SortProfile[vProfile];    b ¬ origin;  lastSei ¬ ISENull;    FOR vI DECREASING IN [0 .. vProfile.length) DO      sei ¬ WITH vProfile[vI].link SELECT FROM symbol=>index, ENDCASE=>ERROR;      SELECT TypeForm[syms, syms.seb[sei].idType] FROM	union => CheckVariants[sei];	sequence => {	  IF vI # 0 THEN Log.ErrorSei[recordOverlap, sei];	  CheckSequence[sei]};	ENDCASE;      SELECT (newB ¬ vProfile[vI].key) FROM	> b => Log.ErrorSei[recordGap, lastSei];	< b => Log.ErrorSei[recordOverlap, sei];	ENDCASE;      b ¬ newB + ToCard[syms.seb[sei].idInfo];  lastSei ¬ sei;      ENDLOOP;    ReleaseProfile[vProfile];    IF b > WordLength AND b MOD WordLength # 0      THEN {	Log.ErrorSei[recordGap, lastSei];	b ¬ ((b+WordFill)/WordLength) * WordLength};    syms.seb[rSei].length ¬ b};  CheckVariants: PROC [sei: ISEIndex] = {    type: CSEIndex = UnderType[syms, syms.seb[sei].idType];    started: BOOLEAN ¬ FALSE;    eqLengths: BOOLEAN ¬ TRUE;    gaps: BOOLEAN ¬ FALSE;    origin, maxLength, size: CARDINAL;    CheckVariant: PROC [rSei: RecordSEIndex] RETURNS [BOOLEAN] = {      length: CARDINAL;      CheckFields[rSei, origin];  length ¬ syms.seb[rSei].length;      IF ~started THEN {maxLength ¬ length; started ¬ TRUE}      ELSE {	IF length MOD WordLength # 0 OR maxLength MOD WordLength # 0 THEN gaps ¬ TRUE;	IF length # maxLength THEN {maxLength ¬ MAX[length, maxLength]; eqLengths ¬ FALSE}};      RETURN [FALSE]};    origin ¬ BitOffset[sei];    WITH union: syms.seb[type] SELECT FROM      union => {	IF union.controlled THEN {	  newOrigin: CARDINAL = BitOffset[union.tagSei];	  IF origin # newOrigin THEN {	    Log.ErrorSei[fieldPosition, union.tagSei];	    -- Don't attempt checking the variants if tag not	    -- at beginning of union.	    RETURN;};	  origin ¬ newOrigin + ToCard[syms.seb[union.tagSei].idInfo]};	[] ¬ ScanVariants[union.caseCtx, CheckVariant];	size ¬ maxLength - BitOffset[sei];  union.hints.equalLengths ¬ eqLengths;	IF gaps THEN Log.ErrorSei[recordGap, sei];	SELECT TRUE FROM	  (ToCard[syms.seb[sei].idInfo] = 0) => 	    syms.seb[sei].idInfo ¬ FromCard[size];	  (size # ToCard[syms.seb[sei].idInfo]) => Log.ErrorSei[fieldPosition, sei];	  ENDCASE};      ENDCASE => ERROR};  CheckSequence: PROC [sei: ISEIndex] = {    type: CSEIndex = UnderType[syms, syms.seb[sei].idType];    origin, length: CARDINAL;    origin ¬ BitOffset[sei];    WITH seq: syms.seb[type] SELECT FROM      sequence => {	IF seq.controlled THEN {	  newOrigin: CARDINAL = BitOffset[seq.tagSei];	  IF origin # newOrigin THEN {	    Log.ErrorSei[fieldPosition, seq.tagSei];	    -- Don't attempt checking the variants if tag not	    -- at beginning of union.	    RETURN;};	  origin ¬ newOrigin + ToCard[syms.seb[seq.tagSei].idInfo]};	IF origin MOD WordLength # 0 THEN Log.ErrorSei[fieldPosition, sei];	length ¬ origin - BitOffset[sei];	SELECT ToCard[syms.seb[sei].idInfo] FROM	  0 => syms.seb[sei].idInfo ¬ FromCard[length];	  length => NULL;	  ENDCASE => Log.ErrorSei[fieldPosition, sei]};      ENDCASE => ERROR};  }.
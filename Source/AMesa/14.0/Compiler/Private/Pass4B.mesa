-- Copyright (C) 1983, 1986  by Xerox Corporation. All rights reserved. -- file Pass4B.Mesa--   Satterthwaite,	October 11, 1982 9:32 am--   Sweet,		 4-Aug-83  9:58:10--   Johnsson,		14-Jun-83  9:03:22--   MEW		19-Aug-86 17:51:16DIRECTORY  Alloc USING [Top],  BcdDefs USING [    ATNull, BCD, CodeDesc, ENIndex, ENNull, EXPRecord, FTIndex, FTRecord,    IMPIndex, IMPRecord, Link, LFIndex, MTRecord, Namee, NameRecord,    NTRecord, PackedString, SGIndex, SGRecord, TMRecord,    TYPIndex, TYPRecord, VersionID,    CTNull, FTSelf, FTNull, LFNull, NullLink, NullName],  BcdDefsExtras,  BcdOps USING [BcdBase, NameString],  ComData USING [    codeSeg, compilerVersion, entryVector, fixupLoc, importCtx, interface,    linkCount, mainCtx, moduleCtx, mtRoot, mtRootSize, nBodies,    objectVersion, sourceFile, sourceVersion, switches, symSeg,    table, textIndex],  CompilerUtil USING [    AppendBCDString, AppendBCDWord, AppendBCDWords, EndBCD,    ReadBCDIndex, ReadBCDOffset, StartBCD, UpdateBCDWords],  Copier USING [FreeSymbolTable, GetSymbolTable],  Environment USING [wordsPerPage],  Heap USING [MakeNode],  CLog USING [ErrorN, ErrorSei, WarningSei],  OSMiscOps USING [StampToTime],  P4 USING [ownGfi, DefaultBasicOps, OperandType],  Pass4 USING [resident],  PrincOps USING [BytePC],  String USING [    SubString, SubStringDescriptor,    AppendChar, AppendString, EqualSubStrings, EquivalentSubStrings],  Symbols USING [    mdType, HTIndex, SEIndex, ISEIndex, CSEIndex, RecordSEIndex, CTXIndex,    IncludedCTXIndex, BitAddress, Linkage, MDRecord, MDIndex, BTIndex,    HTNull, ISENull, CTXNull, BTNull, NullFileIndex,    OwnMdi, RootBti, typeTYPE, DummyLink],  SymbolOps USING [    FindString, FirstCtxSe, FromCard, FromLink, LinkMode, NextSe, NormalType,     SearchContext, SubStringForHash, ToBitAddr, ToBti, ToCard, ToLink,     ToSei, ToTreeIndex, TypeForm, UnderType, XferMode],  SymbolTable USING [Handle],  Tree USING [Index, Link, NullIndex],  TreeOps USING [DecodeCard, GetNode, GetSe, ListLength, Map, Scan, ScanList],  Types USING [Assignable, Equivalent];  Pass4B: PROGRAM    IMPORTS      Alloc, CompilerUtil, Copier, Heap, Log: CLog, OSMiscOps, P4, String,      SymbolOps, TreeOps, Types,      dataPtr: ComData, passPtr: Pass4    EXPORTS P4 = {  OPEN SymbolOps, Symbols;    syms: SymbolTable.Handle ¬ NIL;      zone: UNCOUNTED ZONE ¬ NIL;    Pass4BInit: PUBLIC PROC [h: SymbolTable.Handle] = { syms ¬ h };    -- shared variables  bcdHeader: BcdOps.BcdBase;  BcdHeaderPage: CARDINAL = 1;		-- page 0 is reserved  bcdOffset, mtOffset: CARDINAL;    nString: BcdOps.NameString;    firstPorted: MDIndex = FIRST[MDIndex] + SIZE[MDRecord];  lastPorted: MDIndex;	-- im/exported files in [firstPorted..lastPorted)  -- service routines  DummyLink: TYPE = Symbols.DummyLink;    ownGfi: CARDINAL = P4.ownGfi;      MakeDummyLink: PUBLIC PROC [ep: CARDINAL, gfi: CARDINAL] RETURNS [DummyLink] = {    RETURN [[ep: ep, gfi: gfi]]};      MakeFrameLink: PROC [offset: CARDINAL, gfi: CARDINAL] RETURNS [BcdDefs.Link] = {    RETURN [[variable[gfi: gfi, offset: offset]]]};      MakeTypeLink: PROC [index: BcdDefs.TYPIndex] RETURNS [BcdDefs.Link] = INLINE {   -- throws away top two bits of index    RETURN [[type[typeID: index, fill: 0]]]};          MdiForCtx: PROC [ctx: CTXIndex] RETURNS [MDIndex] = {    RETURN [WITH c: syms.ctxb[ctx] SELECT FROM      included => c.module,      imported => syms.ctxb[c.includeLink].module,      ENDCASE => OwnMdi]};        PortedCtx: PROC [ctx: CTXIndex] RETURNS [BcdDefs.FTIndex] = {    RETURN [PortedFile[MdiForCtx[ctx]]]};        PortedFile: PROC [mdi: MDIndex] RETURNS [fti: BcdDefs.FTIndex] = {    n: CARDINAL;    IF mdi = OwnMdi THEN fti ¬ BcdDefs.FTSelf    ELSE {      IF mdi IN [firstPorted .. lastPorted) THEN        n ¬ LOOPHOLE[mdi-firstPorted, CARDINAL]/SIZE[MDRecord]      ELSE {	n ¬ LOOPHOLE[lastPorted-firstPorted, CARDINAL]/SIZE[MDRecord];	SwapMdi[mdi, lastPorted];	lastPorted ¬ lastPorted + SIZE[MDRecord]};      fti ¬ LOOPHOLE[n*SIZE[BcdDefs.FTRecord]]};    RETURN};      SwapMdi: PROC [mdi1, mdi2: MDIndex] = {    IF mdi1 # mdi2 THEN {      ctx: IncludedCTXIndex;      t: MDRecord;      FOR ctx ¬ syms.mdb[mdi1].ctx, syms.ctxb[ctx].chain UNTIL ctx = CTXNull DO	syms.ctxb[ctx].module ¬ mdi2 ENDLOOP;      FOR ctx ¬ syms.mdb[mdi2].ctx, syms.ctxb[ctx].chain UNTIL ctx = CTXNull DO	syms.ctxb[ctx].module ¬ mdi1 ENDLOOP;      t ¬ syms.mdb[mdi1];  syms.mdb[mdi1] ¬ syms.mdb[mdi2];  syms.mdb[mdi2] ¬ t}};		  SubString: TYPE = String.SubString;  SubStringDescriptor: TYPE = String.SubStringDescriptor;    EnterId: PROC [id: SubString, ignoreCase: BOOLEAN] RETURNS [BcdDefs.NameRecord] = {    i: CARDINAL;    desc: SubStringDescriptor;    s: SubString = @desc;    i ¬ 0;  s.base ¬ @nString.string;    UNTIL i = nString.string.length DO      s.offset ¬ i ¬ i+1;  s.length ¬ nString.size[i];      IF (IF ignoreCase	    THEN String.EquivalentSubStrings[id, s]	    ELSE String.EqualSubStrings[id, s]) THEN EXIT;      i ¬ i + s.length;      REPEAT	FINISHED => {	  IF nString.string.length + (id.length+1) > nString.string.maxlength THEN {	    -- rewrite if nString is in table area	    t: BcdOps.NameString ¬ LOOPHOLE[	      zone.NEW[StringBody[nString.string.maxlength + MAX[(id.length+1), 32]]]];	    String.AppendString[@t.string, @nString.string];	    zone.FREE[@nString];  nString ¬ t};	  i ¬ nString.string.length ¬ nString.string.length + 1;	  nString.size[i] ¬ id.length;	  FOR j: CARDINAL IN [0..id.length) DO	    String.AppendChar[@nString.string, id.base[id.offset+j]] ENDLOOP};      ENDLOOP;    RETURN [[i]]};      EnterSymbolId: PROC [sei: ISEIndex] RETURNS [BcdDefs.NameRecord] = {    s: String.SubStringDescriptor;    SubStringForHash[syms, @s, syms.seb[sei].hash];    RETURN [EnterId[@s, FALSE]]};      EnterFileId: PROC [mdi: MDIndex] RETURNS [BcdDefs.NameRecord] = {    s: String.SubStringDescriptor;    extLength: CARDINAL = (".bcd"L).length;    SubStringForHash[syms, @s, syms.mdb[mdi].fileId];    IF s.base[s.offset+s.length-1] = '. THEN s.length ¬ s.length - 1;    IF s.length > extLength THEN {      t: String.SubStringDescriptor ¬ [        base: s.base, offset: s.offset+s.length-extLength, length: extLength];      ext: String.SubStringDescriptor ¬ [base:".bcd"L, offset:0, length:extLength];      IF String.EquivalentSubStrings[@t, @ext] THEN s.length ¬ s.length - extLength};    RETURN [EnterId[@s, TRUE]]};        -- processing directory entries (to file table)  ProcessDirectory: PUBLIC TreeOps.Scan = {    DirectoryItem: TreeOps.Scan = {      node: Tree.Index = TreeOps.GetNode[syms, t];      sei: ISEIndex = TreeOps.GetSe[syms, syms.tb[node].son[1]];      type: CSEIndex = UnderType[syms, syms.seb[sei].idType];      WITH t: syms.seb[type] SELECT FROM	definition => [] ¬ PortedCtx[t.defCtx];	transfer => {	  bti: BTIndex = ToBti[syms.seb[sei].idInfo];	  IF bti # BTNull THEN [] ¬ PortedCtx[syms.bb[bti].localCtx]};	ENDCASE};        TreeOps.ScanList[syms, t, DirectoryItem]};        -- relocating imported control links  ScanImports: PROC [action: PROC [ISEIndex]] = {    FOR sei: ISEIndex ¬ FirstCtxSe[syms, dataPtr.importCtx], NextSe[syms, sei] UNTIL sei = ISENull DO      action[sei] ENDLOOP};        RelocateImports: PROC [ctx: CTXIndex, gfi: CARDINAL] = {    FOR sei: ISEIndex ¬ FirstCtxSe[syms, ctx], NextSe[syms, sei] UNTIL sei = ISENull DO      IF ~syms.seb[sei].constant THEN {	epN: CARDINAL = ToCard[syms.seb[sei].idValue];	syms.seb[sei].idValue ¬ FromLink[MakeDummyLink[epN, gfi]]};      ENDLOOP;    RETURN};      AssignImports: PUBLIC TreeOps.Scan = {    gfi: CARDINAL;    saveIndex: CARDINAL = dataPtr.textIndex;        ImportItem: PROC [sei: ISEIndex] = {      node: Tree.Index = ToTreeIndex[syms.seb[sei].idValue];      type: CSEIndex = NormalType[syms, UnderType[syms, syms.seb[sei].idType]];      IF node # Tree.NullIndex THEN         dataPtr.textIndex ¬ TreeOps.DecodeCard[syms.tb[node].info];      WITH t: syms.seb[type] SELECT FROM	definition => {	  IF syms.ctxb[t.defCtx].seList = ISENull THEN	    Log.WarningSei[unusedImport, sei];	  RelocateImports[t.defCtx, gfi];	  gfi ¬ gfi + 1};	ref => {	  syms.seb[sei].idValue ¬ FromLink[MakeDummyLink[ep:0, gfi:gfi]]; 	  gfi ¬ gfi + 1};	ENDCASE;      syms.seb[sei].mark4 ¬ TRUE};          gfi ¬ bcdHeader.firstdummy ¬ 2;    IF ~dataPtr.interface THEN ScanImports[ImportItem];    bcdHeader.nDummies ¬ gfi - bcdHeader.firstdummy;    dataPtr.textIndex ¬ saveIndex};        -- writing frame fragments (link fragment written by Pass4L)  ProcessSymLiterals: PUBLIC PROC = {    offset: CARDINAL = CompilerUtil.ReadBCDOffset[];    bcdHeader.lfLimit ¬ LOOPHOLE[offset - bcdHeader.lfOffset]};    -- writing import records  ProcessImports: PUBLIC TreeOps.Scan = {    -- N.B. nextGfi must be regenerated to match AssignImports    nImports: CARDINAL;    impi: BcdDefs.IMPIndex;    nextGfi: CARDINAL;    anyNamed: BOOLEAN;        ProcessSei: PROC [sei, tSei: ISEIndex] = {      type: CSEIndex = NormalType[syms, UnderType[syms, syms.seb[sei].idType]];      entry: BcdDefs.IMPRecord ¬ [		name: EnterSymbolId[tSei],		port: interface,		namedInstance: syms.seb[sei].hash # syms.seb[tSei].hash,		file: ,		gfi: nextGfi];      WITH t: syms.seb[type] SELECT FROM	definition => {	  entry.file ¬ PortedCtx[t.defCtx];	  nextGfi ¬ ToCard[(syms.seb[sei].idValue ¬ FromCard[nextGfi])] + 1};	ref => {	  rType: RecordSEIndex = LOOPHOLE[UnderType[syms, t.refType]];	  entry.port ¬ module;	  entry.file ¬ PortedCtx[syms.seb[rType].fieldCtx];	  nextGfi ¬ nextGfi + 1};	ENDCASE;      nImports ¬ nImports + 1;      IF entry.namedInstance THEN anyNamed ¬ TRUE;      CompilerUtil.AppendBCDWords[@entry, SIZE[BcdDefs.IMPRecord]]};          sei: ISEIndex;	-- updated by ImportItem        ImportItem: TreeOps.Scan = {      node: Tree.Index = TreeOps.GetNode[syms, t];      ProcessSei[sei, TreeOps.GetSe[syms, syms.tb[node].son[2]]];      sei ¬ NextSe[syms, sei]};          NameItem: TreeOps.Scan = {      node: Tree.Index = TreeOps.GetNode[syms, t];      sei: ISEIndex = TreeOps.GetSe[syms, syms.tb[node].son[1]];      tSei: ISEIndex = TreeOps.GetSe[syms, syms.tb[node].son[2]];      entry: BcdDefs.NTRecord;      IF  syms.seb[sei].hash # syms.seb[tSei].hash THEN {	entry ¬ [name: EnterSymbolId[sei], item: BcdDefs.Namee[import[impi]]];	CompilerUtil.AppendBCDWords[@entry, SIZE[BcdDefs.NTRecord]]};      impi ¬ impi + SIZE[BcdDefs.IMPRecord]};          offset: CARDINAL;    bcdHeader.impOffset ¬ offset ¬ CompilerUtil.ReadBCDOffset[];    nImports ¬ 0;  impi ¬ FIRST[BcdDefs.IMPIndex];    nextGfi ¬ bcdHeader.firstdummy;  anyNamed ¬ FALSE;    IF ~dataPtr.interface THEN {      sei ¬ FirstCtxSe[syms, dataPtr.importCtx];      TreeOps.ScanList[syms, t, ImportItem];      UNTIL sei = ISENull DO ProcessSei[sei, sei]; sei ¬ NextSe[syms, sei] ENDLOOP};    bcdHeader.nImports ¬ nImports;    bcdHeader.impLimit ¬ LOOPHOLE[CompilerUtil.ReadBCDOffset[]-offset];    bcdHeader.ntOffset ¬ offset ¬ CompilerUtil.ReadBCDOffset[];    IF anyNamed THEN TreeOps.ScanList[syms, t, NameItem];	-- matches importCtx prefix    bcdHeader.ntLimit ¬ LOOPHOLE[CompilerUtil.ReadBCDOffset[]-offset]};          TypeMap: TYPE = RECORD [SEQUENCE length: CARDINAL OF    RECORD [opaque: BcdDefs.TMRecord, concrete: BcdDefs.TYPRecord]];  typeMap: LONG POINTER TO TypeMap;  mapIndex: CARDINAL;  typeIndex: BcdDefs.TYPIndex;    EnterType: PROC [mdi: MDIndex, offset: CARDINAL, sei: ISEIndex]      RETURNS [typeId: BcdDefs.TYPIndex] = {    entry: BcdDefs.TYPRecord = MakeTypeId[sei];    IF typeMap = NIL OR mapIndex >= typeMap.length THEN AdjustTypeMap[8];    FOR i: CARDINAL IN [0..mapIndex) DO      IF typeMap[i].concrete = entry THEN GO TO matched;      REPEAT	matched => typeId ¬ typeMap[i].opaque.map;	FINISHED => {typeId ¬ typeIndex; typeIndex ¬ typeIndex + SIZE[BcdDefs.TYPRecord]};      ENDLOOP;    typeMap[mapIndex] ¬ [	opaque: [version: syms.mdb[mdi].stamp, offset: offset, map: typeId],	concrete: entry];    mapIndex ¬ mapIndex + 1;    RETURN};      MakeTypeId: PROC [id: ISEIndex] RETURNS [BcdDefs.TYPRecord] = {    sei: ISEIndex ¬ id;    next: SEIndex;    mdi: MDIndex;    DO      next ¬ ToSei[syms.seb[sei].idInfo];      WITH syms.seb[next] SELECT FROM	id => sei ¬ LOOPHOLE[next];	ENDCASE => EXIT;      ENDLOOP;    mdi ¬ MdiForCtx[syms.seb[sei].idCtx];    RETURN [[id: [ToCard[syms.seb[sei].idValue]], version: syms.mdb[mdi].stamp]]};      AdjustTypeMap: PROC [delta: CARDINAL] = {    oldN: CARDINAL = IF typeMap = NIL THEN 0 ELSE typeMap.length;    newMap: LONG POINTER TO TypeMap = zone.NEW[TypeMap[oldN+delta]];    FOR i: CARDINAL IN [0 .. oldN) DO newMap[i] ¬ typeMap[i] ENDLOOP;    IF typeMap # NIL THEN zone.FREE[@typeMap];    typeMap ¬ newMap};      WriteTypeTable: PROC = {    i, offset: CARDINAL;    bcdHeader.typOffset ¬ offset ¬ CompilerUtil.ReadBCDOffset[];    FOR i IN [0 .. mapIndex) DO      FOR j: CARDINAL IN [0..i) DO	IF typeMap[i].opaque.map = typeMap[j].opaque.map THEN EXIT	REPEAT	  FINISHED => CompilerUtil.AppendBCDWords[	    @typeMap[i].concrete, SIZE[BcdDefs.TYPRecord]];	ENDLOOP;      ENDLOOP;    bcdHeader.typLimit ¬ LOOPHOLE[CompilerUtil.ReadBCDOffset[]-offset];    bcdHeader.tmOffset ¬ offset ¬ CompilerUtil.ReadBCDOffset[];    FOR i IN [0 .. mapIndex) DO      CompilerUtil.AppendBCDWords[@typeMap[i].opaque, SIZE[BcdDefs.TMRecord]];      ENDLOOP;    bcdHeader.tmLimit ¬ LOOPHOLE[CompilerUtil.ReadBCDOffset[]-offset]};          ExportId: TreeOps.Map = {    expType: CSEIndex = P4.OperandType[t];    ctx: IncludedCTXIndex;    iBase: SymbolTable.Handle;    id, sei, iSei: ISEIndex;    epN: CARDINAL;    used: BOOLEAN;    id ¬ TreeOps.GetSe[syms, t];    WITH v: syms.seb[expType] SELECT FROM      definition => {	ctx ¬ LOOPHOLE[v.defCtx];	iBase ¬ Copier.GetSymbolTable[syms, syms.ctxb[ctx].module];	IF iBase # NIL THEN {	  BEGIN	  header: BcdDefs.EXPRecord ¬ [		  name: EnterSymbolId[id],		  size: 0,		  port: interface,		  namedInstance: FALSE,		  typeExported: FALSE,		  file: PortedCtx[v.defCtx],		  links: ];	  FOR iSei ¬ FirstCtxSe[iBase, syms.ctxb[ctx].map], 	      NextSe[iBase, iSei] UNTIL iSei = ISENull DO	    SELECT LinkMode[iBase, iSei] FROM	      val, ref => header.size ¬ header.size + 1;	      type => {header.typeExported ¬ TRUE; header.size ¬ header.size + 1};	      ENDCASE;	    ENDLOOP;	  CompilerUtil.AppendBCDWords[@header, SIZE[BcdDefs.EXPRecord]];	  END;	  used ¬ FALSE;  epN ¬ 0;	  FOR iSei ¬ FirstCtxSe[iBase, syms.ctxb[ctx].map], 	      NextSe[iBase, iSei] UNTIL iSei = ISENull DO	    mode: Linkage = LinkMode[iBase, iSei];	    link: BcdDefs.Link ¬ BcdDefs.NullLink;	      BEGIN	      ss: SubStringDescriptor;	      hti: HTIndex;	      SubStringForHash[iBase, @ss, iBase.seb[iSei].hash];	      hti ¬ FindString[syms, @ss];	      IF hti = HTNull THEN sei ¬ ISENull	      ELSE {		sei ¬ SearchContext[syms, hti, dataPtr.mainCtx];		IF sei = ISENull THEN sei ¬ SearchContext[syms, hti, dataPtr.moduleCtx]};	      END;	    IF sei # ISENull THEN {	      public: BOOLEAN = syms.seb[sei].public;	      iType: CSEIndex = UnderType[iBase, iBase.seb[iSei].idType];	      SELECT mode FROM		val => {		  IF ~Types.Assignable[			[iBase, iType], [syms, UnderType[syms, syms.seb[sei].idType]]] THEN {		    IF public THEN Log.ErrorSei[exportClash,sei]}		  ELSE IF ~public AND syms.seb[sei].idCtx = dataPtr.mainCtx THEN		    Log.WarningSei[privateExport, sei];		  IF public THEN {		    IF ~syms.seb[sei].constant OR syms.seb[sei].extended THEN Log.ErrorSei[varExport, sei];		    SELECT XferMode[syms, syms.seb[sei].idType] FROM		      program => link ¬ MakeFrameLink[offset: 0, gfi:ownGfi];		      proc => link ¬		        [procedure[gfi: ownGfi, 			ep: ToLink[syms.seb[sei].idValue].ep]];		      signal, error => link ¬		        [signal[gfi: ownGfi, 			index: ToLink[syms.seb[sei].idValue].ep]];		      ENDCASE}};		ref => {		  iTarget: CSEIndex ¬ iType;		  iConst: BOOLEAN ¬ iBase.seb[iSei].immutable;		  WITH lt: iBase.seb[iType] SELECT FROM		    long => {		      rType: CSEIndex =		        UnderType[iBase, lt.rangeType];		      WITH t: iBase.seb[rType] SELECT FROM		        ref =>		          IF t.var THEN {			    iTarget ¬ UnderType[iBase, t.refType]; 			    iConst ¬ t.readOnly}; 		        ENDCASE};		    ENDCASE;		  IF ~Types.Equivalent[			[iBase, iTarget], [syms, UnderType[syms, syms.seb[sei].idType]]] THEN {		    IF public THEN Log.ErrorSei[exportClash,sei]}		  ELSE IF ~public AND syms.seb[sei].idCtx = dataPtr.mainCtx THEN		    Log.WarningSei[privateExport, sei];		  IF public THEN {		    SELECT TRUE FROM		      syms.seb[sei].constant => Log.ErrorSei[varExport, sei];		      syms.seb[sei].immutable AND ~iConst => Log.ErrorSei[exportClash, sei];		      ENDCASE;		  link ¬ MakeFrameLink[			   offset: ToBitAddr[syms.seb[sei].idValue].wd,			   gfi: ownGfi]}};		type =>		  IF syms.seb[sei].idType # typeTYPE OR TypeForm[syms, sei] = opaque THEN {		    IF public THEN Log.ErrorSei[exportClash, sei]}		  ELSE {		    iValue: CSEIndex = UnderType[iBase, iSei];		    IF (~public AND syms.seb[sei].idCtx = dataPtr.mainCtx) THEN		      Log.WarningSei[privateExport, sei]		    ELSE		      WITH it: iBase.seb[iValue] SELECT FROM			opaque =>			  IF it.lengthKnown AND ~P4.DefaultBasicOps[sei, it.length] THEN			    Log.ErrorSei[exportAttr, sei];			ENDCASE => ERROR;		    IF public THEN {		      link ¬ MakeTypeLink[EnterType[syms.ctxb[ctx].module, epN, sei]];		      bcdHeader.typeExported ¬ TRUE}};		manifest =>		  IF public		    AND (syms.seb[sei].idType # typeTYPE OR iBase.seb[iSei].idType # typeTYPE) THEN		     Log.WarningSei[voidExport, sei];		ENDCASE};	    IF link # BcdDefs.NullLink THEN used ¬ TRUE;	    IF mode # manifest THEN {	      CompilerUtil.AppendBCDWords[@link, SIZE[BcdDefs.Link]]; 	      epN ¬ epN + 1};	    ENDLOOP;	Copier.FreeSymbolTable[iBase];	IF ~used THEN Log.WarningSei[unusedExport, id]}};      ENDCASE;    RETURN [t]};      ExportItem: TreeOps.Scan = {    node: Tree.Index = TreeOps.GetNode[syms, t];    saveIndex: CARDINAL = dataPtr.textIndex;    dataPtr.textIndex ¬ TreeOps.DecodeCard[syms.tb[node].info];    syms.tb[node].son[2] ¬ ExportId[syms, syms.tb[node].son[2]];    dataPtr.textIndex ¬ saveIndex};      ProcessExports: PUBLIC TreeOps.Map = {    offset: CARDINAL;    bcdHeader.nExports ¬ TreeOps.ListLength[syms, t];    bcdHeader.expOffset ¬ offset ¬ CompilerUtil.ReadBCDOffset[];    typeIndex ¬ FIRST[BcdDefs.TYPIndex];  mapIndex ¬ 0;  typeMap ¬ NIL;    TreeOps.ScanList[syms, t, ExportItem];    bcdHeader.expLimit ¬ LOOPHOLE[CompilerUtil.ReadBCDOffset[]-offset];    WriteTypeTable[];    IF typeMap # NIL THEN zone.FREE[@typeMap];    RETURN [t]};    -- initialization/finalization  ProcessFiles: PROC = {    ftEntry: BcdDefs.FTRecord;    mdi: MDIndex;    limit: MDIndex = (dataPtr.table).Top[mdType];    desc: String.SubStringDescriptor ¬ [      base: dataPtr.sourceFile, offset: 0, length: dataPtr.sourceFile.length];    offset: CARDINAL = CompilerUtil.ReadBCDOffset[];    FOR mdi ¬ lastPorted, mdi + SIZE[MDRecord] UNTIL mdi = limit DO      IF syms.mdb[mdi].file # NullFileIndex THEN        [] ¬ PortedFile[mdi];	-- add any files opened during compilation      ENDLOOP;    bcdHeader.ftOffset ¬ offset;    FOR mdi ¬ firstPorted, mdi + SIZE[MDRecord] UNTIL mdi = lastPorted DO      ftEntry ¬ [name: EnterFileId[mdi], version: syms.mdb[mdi].stamp];      CompilerUtil.AppendBCDWords[@ftEntry, SIZE[BcdDefs.FTRecord]];      ENDLOOP;    ftEntry ¬ [      name: EnterId[@desc, TRUE],       version: OSMiscOps.StampToTime[dataPtr.sourceVersion]];    bcdHeader.sourceFile ¬ LOOPHOLE[CompilerUtil.ReadBCDOffset[] - offset];    CompilerUtil.AppendBCDWords[@ftEntry, SIZE[BcdDefs.FTRecord]];    bcdHeader.ftLimit ¬ LOOPHOLE[CompilerUtil.ReadBCDOffset[] - offset]};      InitBCD: PUBLIC PROC [ids: Tree.Link, scratchZone: UNCOUNTED ZONE] = {    OPEN BcdDefs;    nIds: CARDINAL;    zone ¬ scratchZone;    nIds ¬ TreeOps.ListLength[syms, ids];    IF nIds > 1 AND ~dataPtr.interface THEN {Log.ErrorN[listLong, nIds-1]; nIds ¬ 1};    lastPorted ¬ firstPorted;    nString ¬ LOOPHOLE[zone.NEW[StringBody[64]]];    -- allocate the null name      nString.string.length ¬ BcdDefs.NullName;      nString.size[BcdDefs.NullName] ¬ 0;    syms.mdb[OwnMdi].stamp ¬ dataPtr.objectVersion;	-- update from DIRECTORY processing    CompilerUtil.StartBCD[];    bcdHeader ¬ zone.NEW[BCD];      bcdHeader.versionIdent ¬ VersionID;      bcdHeader.version ¬ dataPtr.objectVersion;      bcdHeader.creator ¬ dataPtr.compilerVersion;      bcdHeader.unpackagedFile ¬ BcdDefs.FTNull;      bcdHeader.nConfigs ¬ 0;      bcdHeader.nModules ¬ nIds;      bcdHeader.nImports ¬ bcdHeader.nExports ¬ 0;      bcdHeader.definitions ¬ dataPtr.interface;      bcdHeader.typeExported ¬ FALSE;      bcdHeader.repackaged ¬ bcdHeader.tableCompiled ¬ FALSE;      bcdHeader.spare ¬ ALL[FALSE];      bcdHeader.ctOffset ¬ 0;  bcdHeader.ctLimit ¬ LOOPHOLE[0];      bcdHeader.spOffset ¬ 0;  bcdHeader.spLimit ¬ LOOPHOLE[0];      bcdHeader.fpOffset ¬ 0;  bcdHeader.fpLimit ¬ LOOPHOLE[0];      bcdHeader.atOffset ¬ 0;  bcdHeader.atLimit ¬ LOOPHOLE[0];      bcdHeader.apOffset ¬ 0;  bcdHeader.apLimit ¬ 0;    bcdOffset ¬ CompilerUtil.ReadBCDOffset[];    CompilerUtil.AppendBCDWords[bcdHeader, SIZE[BCD]];    dataPtr.fixupLoc ¬ CompilerUtil.ReadBCDIndex[];    bcdHeader.sgOffset ¬ CompilerUtil.ReadBCDOffset[];    CompilerUtil.AppendBCDWords[@dataPtr.codeSeg, SIZE[SGRecord]];    CompilerUtil.AppendBCDWords[@dataPtr.symSeg, SIZE[SGRecord]];    bcdHeader.mtOffset ¬ mtOffset ¬ CompilerUtil.ReadBCDOffset[];    bcdHeader.sgLimit ¬ LOOPHOLE[mtOffset - bcdHeader.sgOffset];    dataPtr.mtRootSize ¬ SIZE[BcdDefs.MTRecord];    dataPtr.mtRoot ¬ Heap.MakeNode[zone, SIZE[BcdDefs.MTRecord]];    dataPtr.mtRoot.links ¬      IF dataPtr.interface THEN BcdDefs.LFNull ELSE FIRST[BcdDefs.LFIndex];    FOR i: CARDINAL IN [0..nIds) DO      CompilerUtil.AppendBCDWords[dataPtr.mtRoot, dataPtr.mtRootSize]      ENDLOOP;    bcdHeader.enOffset ¬ CompilerUtil.ReadBCDOffset[];    bcdHeader.mtLimit ¬ LOOPHOLE[bcdHeader.enOffset-bcdHeader.mtOffset];    IF ~dataPtr.interface THEN {      dataPtr.entryVector ¬ DESCRIPTOR[        Heap.MakeNode[zone, dataPtr.nBodies*SIZE[PrincOps.BytePC]],        dataPtr.nBodies];      CompilerUtil.AppendBCDWord[dataPtr.nBodies];      CompilerUtil.AppendBCDWords[ -- garbage for now, will be fixed up        BASE[dataPtr.entryVector], dataPtr.nBodies * SIZE[PrincOps.BytePC]]};    bcdHeader.lfOffset ¬ CompilerUtil.ReadBCDOffset[];    bcdHeader.enLimit ¬ LOOPHOLE[bcdHeader.lfOffset-bcdHeader.enOffset]};        FinishBCD: PUBLIC PROC [ids: Tree.Link] = {    OPEN BcdDefs;    PageSize: CARDINAL = Environment.wordsPerPage;    Alignment: CARDINAL = 4;  -- Code Segments must start at 0 MOD Alignment    nLinks: CARDINAL = dataPtr.linkCount;    gfType: RecordSEIndex = syms.bb[RootBti].type;    -- fill MTRecord      IF TreeOps.ListLength[syms, ids] > 1 THEN {	-- complete nString now	EnterId: TreeOps.Scan = {[] ¬ EnterSymbolId[TreeOps.GetSe[syms, t]]};	TreeOps.ScanList[syms, ids, EnterId]};      dataPtr.mtRoot.name ¬ EnterSymbolId[syms.bb[RootBti].id];      dataPtr.mtRoot.namedInstance ¬ FALSE;      dataPtr.mtRoot.initial ¬ ~dataPtr.switches['s];      dataPtr.mtRoot.file ¬ dataPtr.codeSeg.file ¬ dataPtr.symSeg.file ¬         PortedCtx[dataPtr.mainCtx];      dataPtr.mtRoot.linkLoc ¬ dontcare;      dataPtr.mtRoot.config ¬ CTNull;      dataPtr.mtRoot.linkspace ¬ FALSE;      dataPtr.mtRoot.packed ¬ FALSE;      dataPtr.mtRoot.code ¬ CodeDesc[	sgi: FIRST[SGIndex], offset: 0, length: 0];	-- will be updated      dataPtr.mtRoot.sseg ¬ FIRST[SGIndex] + SIZE[SGRecord];      dataPtr.mtRoot.spare ¬  IF dataPtr.switches['o] THEN         BcdDefsExtras.OldMesaModule ELSE BcdDefsExtras.NewMesaModule;      dataPtr.mtRoot.framesize ¬ 0;	-- will be updated      dataPtr.mtRoot.tableCompiled ¬ FALSE;      dataPtr.mtRoot.residentFrame ¬ passPtr.resident;      dataPtr.mtRoot.boundsChecks ¬ dataPtr.switches['b];      dataPtr.mtRoot.nilChecks ¬ dataPtr.switches['n];      dataPtr.mtRoot.crossJumped ¬ dataPtr.switches['j];      dataPtr.mtRoot.packageable ¬ TRUE;      dataPtr.mtRoot.entries ¬        IF dataPtr.interface THEN ENNull ELSE FIRST[ENIndex];      dataPtr.mtRoot.atoms ¬ ATNull;    ProcessFiles[];    bcdHeader.ssOffset ¬ CompilerUtil.ReadBCDOffset[];    CompilerUtil.AppendBCDString[@nString.string];    bcdHeader.ssLimit ¬       LOOPHOLE[CompilerUtil.ReadBCDOffset[]-bcdHeader.ssOffset];    bcdHeader.nPages ¬ (CompilerUtil.ReadBCDOffset[] + (PageSize-1))/PageSize;    CompilerUtil.UpdateBCDWords[bcdOffset, bcdHeader, SIZE[BCD]];    IF dataPtr.interface AND TreeOps.ListLength[syms, ids] > 1 THEN {      offset: CARDINAL ¬ mtOffset;      saveName: BcdDefs.NameRecord = dataPtr.mtRoot.name;	      UpdateMDEntry: TreeOps.Scan = {	dataPtr.mtRoot.name ¬ EnterSymbolId[TreeOps.GetSe[syms, t]];	CompilerUtil.UpdateBCDWords[offset, dataPtr.mtRoot, dataPtr.mtRootSize];	offset ¬ offset + dataPtr.mtRootSize};	        offset ¬ mtOffset;  TreeOps.ScanList[syms, ids, UpdateMDEntry];      dataPtr.mtRoot.name ¬ saveName};    CompilerUtil.EndBCD[];    zone.FREE[@nString]; zone.FREE[@bcdHeader]; zone ¬ NIL};      MatchBCD: PUBLIC PROC RETURNS [matched: BOOLEAN] = {RETURN[FALSE]};  }.
-- Copyright (C) 1982, 1986  by Xerox Corporation. All rights reserved. -- file SymLiteralPack.Mesa-- last modified by Satterthwaite, September 21, 1982 2:23 pm-- last modified by Sweet, 22-Oct-82 23:37:02-- Wagner		22-Aug-86 11:36:50DIRECTORY  Alloc USING [Handle, Notifier, AddNotify, DropNotify],  ComData USING [ownSymbols],  Literals USING [STIndex],  Symbols USING [    Base, SERecord,    HTIndex, SEIndex, ISEIndex, CTXIndex, MDIndex,    SENull, CTXNull, StandardContext, lZ, OwnMdi, MDNull],  SymbolOps USING [ClusterSe, ToSei],  SymbolSegment USING [atType],  SymbolTable USING [Handle],  SymLiteralOps USING [RefLitItem],  Table USING [Selector],  Tree USING [Link];SymLiteralPack: PROGRAM    IMPORTS Alloc, dataPtr: ComData, SymbolOps    EXPORTS SymLiteralOps = {  OPEN Symbols;    RefLitItem: TYPE = SymLiteralOps.RefLitItem; -- bases  table: Alloc.Handle;    syms: SymbolTable.Handle ¬ NIL;    atType: Table.Selector = SymbolSegment.atType;  UpdateBases: Alloc.Notifier = {syms ¬ dataPtr.ownSymbols}; -- universal type fingers  UTypeId: PUBLIC PROC [type: SEIndex] RETURNS [mdi: MDIndex, index: SEIndex] = {    sei: SEIndex = SymbolOps.ClusterSe[syms, type];    WITH se: syms.seb[sei] SELECT FROM      id => {	ctx: CTXIndex = se.idCtx;	WITH c: syms.ctxb[ctx] SELECT FROM	  included =>	    IF c.level = lZ THEN {index ¬ sei; mdi ¬ OwnMdi}	    ELSE {index ¬ SymbolOps.ToSei[se.idValue]; mdi ¬ c.module};	  ENDCASE => {	    index ¬ sei;	    mdi ¬ IF Predeclared[sei] THEN MDNull ELSE OwnMdi}};      cons => {        index ¬ sei;	mdi ¬ WITH t: se SELECT FROM	    basic => MDNull,	    enumerated => IF t.valueCtx IN StandardContext THEN MDNull ELSE OwnMdi,	    record => IF t.fieldCtx IN StandardContext THEN MDNull ELSE OwnMdi,	    opaque => IF Predeclared[t.id] THEN MDNull ELSE OwnMdi,	    ENDCASE => OwnMdi};      ENDCASE;    RETURN};      Predeclared: PROC [sei: SEIndex] RETURNS [BOOLEAN] = {    RETURN [sei = SENull OR (      WITH se: syms.seb[sei] SELECT FROM        id => se.idCtx IN (CTXNull .. LAST[StandardContext]],	ENDCASE => FALSE)]};	        -- typeIds  EnterType: PUBLIC PROC [type: SEIndex, canonical: BOOLEAN] = {ERROR};  TypeIndex: PUBLIC PROC [type: SEIndex, canonical: BOOLEAN] RETURNS [UNSPECIFIED] = {ERROR};  TypeRef: PUBLIC PROC [type: SEIndex, canonical: BOOLEAN] RETURNS [Tree.Link] = {    ERROR};  DescribeTypes: PUBLIC PROC RETURNS [offset, length: CARDINAL] = {    RETURN [offset: 0, length: 0]};  EnumerateTypes: PUBLIC PROC [scan: PROC [canonical: BOOLEAN, type: SEIndex]] = {}; -- atoms and REFs to literals  EnterAtom: PUBLIC PROC [name: HTIndex] = {ERROR};  AtomIndex: PUBLIC PROC [name: HTIndex] RETURNS [UNSPECIFIED] = {ERROR};  AtomRef: PUBLIC PROC [name: HTIndex] RETURNS [Tree.Link] = {ERROR};  EnterText: PUBLIC PROC [sti: Literals.STIndex] = {ERROR};  TextIndex: PUBLIC PROC [sti: Literals.STIndex] RETURNS [UNSPECIFIED] = {ERROR};  TextRef: PUBLIC PROC [sti: Literals.STIndex] RETURNS [Tree.Link] = {ERROR};  DescribeRefLits: PUBLIC PROC RETURNS [offset, length: CARDINAL] = {    RETURN [offset: 0, length: 0]};  EnumerateRefLits: PUBLIC PROC [scan: PROC [RefLitItem]] = {}; -- state transitions  Initialize: PUBLIC PROC [ownTable: Alloc.Handle] = {    table ¬ ownTable; table.AddNotify[UpdateBases, NIL]};  Reset: PUBLIC PROC = {};  Finalize: PUBLIC PROC = {table.DropNotify[UpdateBases, NIL]; table ¬ NIL};  }.
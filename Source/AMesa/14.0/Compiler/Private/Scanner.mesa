-- Copyright (C) 1982, 1983, 1984, 1986  by Xerox Corporation. All rights reserved. -- file Scanner.mesa - last modified by-- Satterthwaite,	June 10, 1982 12:42 pm-- Sweet,		14-Dec-83 14:39:25-- Karlton,		16-Sep-82 15:41:58-- Daniels,		27-Apr-84 14:00:23-- Wagner		21-Aug-86 10:01:19-- Saxe			 8-Apr-87 14:57:51DIRECTORY  Ascii USING [BS, ControlZ, CR, FF, LF, NUL, TAB],  CharIO USING [PutChar, PutNumber, PutString],  ComData USING [formatting, outerCtx, ownSymbols],  CompilerUtil USING [    AcquireStream, AcquireZone, ReleaseStream, ReleaseZone],  Environment USING [charsPerWord, charsPerPage, Word, wordsPerPage],  LiteralOps USING [FindDescriptor, Find, LitFindString],  MStream USING [EndOf],  P1 USING [Token, Value, NullValue],  ParseTable USING [    HashIndex, HashTableRef, IndexTableRef, ScanTableRef, TableRef,    TSymbol, VocabularyRef, EndMarker, tokenARROW, tokenCHAR, tokenDOT,     tokenDOTS, tokenEQUAL, tokenGE, tokenGREATER, tokenID, tokenLE, tokenLESS,    tokenFLNUM, tokenLNUM, tokenLSTR, tokenMINUS, tokenNUM,    tokenSTR],  Real: FROM "IeeeFloat" USING [RealException, PairToReal],  Stream USING [    GetBlock, GetChar, GetPosition, Handle, Position, SetPosition],  String USING [SubStringDescriptor, AppendString],  Style USING [    Comment, CRCount, EnqueueItem, ItemQueueInit, ItemQueueReset,    ItemHandleToStreamIndex],  SymbolOps USING [EnterString, FindString, SearchContext],  Symbols USING [HTIndex, HTNull, ISENull],  SymbolTable USING [Handle];Scanner: PROGRAM    IMPORTS      CharIO, dataPtr: ComData, CompilerUtil, LiteralOps, MStream, Real, Stream, String, Style, SymbolOps     EXPORTS P1 = {  OPEN ParseTable;    syms: SymbolTable.Handle ¬ NIL;  zone: UNCOUNTED ZONE ¬ NIL;    hashTab: HashTableRef;  scanTab: ScanTableRef;  vocab: VocabularyRef;  vocabIndex: IndexTableRef;  stream: Stream.Handle ¬ NIL;	-- the input stream  streamOrigin: Stream.Position;  TextPages: CARDINAL = 6;  TextWords: CARDINAL = TextPages*Environment.wordsPerPage;  TextChars: CARDINAL = TextWords*Environment.charsPerWord;  TextBuffer: TYPE = PACKED ARRAY [0..TextChars) OF CHARACTER;    tB: LONG POINTER TO TextBuffer;  tI, tMax: [0..TextChars];  tOrigin, tLimit: CARDINAL;  tEnded: BOOLEAN;  FillBuffer: PROC = {    tOrigin ¬ tLimit;    IF tEnded THEN tMax ¬ 0    ELSE {      tMax ¬ stream.GetBlock[[LOOPHOLE[tB], 0, TextChars]].bytesTransferred;      IF tMax < TextChars THEN tEnded ¬ TRUE;      tLimit ¬ tOrigin + tMax};    IF tMax = 0 THEN {tB[0] ¬ Ascii.NUL; tMax ¬ 1};    tI ¬ 0};  crCount: CARDINAL;    buffer: LONG STRING ¬ NIL;		-- token assembly area  iMax: CARDINAL;			-- iMax = buffer.maxlength  desc: String.SubStringDescriptor;	-- initial buffer segment  nLines: CARDINAL;			-- line count  nErrors: CARDINAL;			-- lexical errors  hadErrors: BOOLEAN;  BufferOverflow: ERROR = CODE;  ExpandBuffer: PROC = {    oldBuffer: LONG STRING ¬ buffer;    IF oldBuffer.length > 2000 THEN ERROR BufferOverflow;    buffer ¬ zone.NEW[StringBody[2*oldBuffer.length]];    String.AppendString[buffer, oldBuffer];    iMax ¬ buffer.length ¬ buffer.maxlength;    zone.FREE[@oldBuffer];    desc.base ¬ buffer};  char: CHARACTER;	-- current (most recently scanned) character  qDot: BOOLEAN;	-- used to resolved decimal point vs. interval  NextChar: PROC = {	-- also expanded inline within Atom    IF (tI¬tI+1) = tMax THEN FillBuffer[]; char ¬ tB[tI]};  Atom: PUBLIC PROC RETURNS [token: P1.Token] = {    OPEN token;    preDeclared: BOOLEAN ¬ FALSE;    DO      WHILE char IN [Ascii.NUL..' ] DO	SELECT char FROM	  Ascii.NUL => {		-- ­@­@ is Tioga escape seq	    IF (tI¬tI+1) = tMax THEN {IF tEnded THEN GO TO EndFile; FillBuffer[]};	    char ¬ tB[tI];	    IF char = Ascii.NUL THEN GO TO EndFile};	  Ascii.CR => {	    nLines ¬ nLines + 1;	    IF crCount < LAST[Style.CRCount] - 1 THEN crCount ¬ crCount + 1;	    IF (tI¬tI+1) = tMax THEN {	      IF tEnded THEN GO TO EndFile; FillBuffer[]};	    char ¬ tB[tI]};	  Ascii.FF => {	    crCount ¬ LAST[Style.CRCount];	    IF (tI¬tI+1) = tMax THEN {	      IF tEnded THEN GO TO EndFile; FillBuffer[]};	    char ¬ tB[tI]};	  ENDCASE => {	    IF (tI¬tI+1) = tMax THEN {	      IF tEnded THEN GO TO EndFile; FillBuffer[]};	    char ¬ tB[tI]};	ENDLOOP;      index ¬ tOrigin + tI;  value ¬ P1.NullValue;      BEGIN      SELECT char FROM	'a, 'b, 'c, 'd, 'e, 'f, 'g, 'h, 'i, 'j, 'k, 'l, 'm,	'n, 'o, 'p, 'q, 'r, 's, 't, 'u, 'v, 'w, 'x, 'y, 'z  => {	  i: CARDINAL ¬ 0;	  DO	    buffer[i] ¬ char;	    IF (tI¬tI+1) = tMax THEN FillBuffer[];	    char ¬ tB[tI];	    SELECT char FROM	      IN ['a..'z], IN ['A..'Z], IN ['0..'9] =>		IF (i ¬ i+1) >= iMax THEN ExpandBuffer[];	      ENDCASE => EXIT;	    ENDLOOP;	  desc.length ¬ i+1;	  class ¬ tokenID;  	  IF ~dataPtr.formatting THEN value.r ¬ SymbolOps.EnterString[syms, @desc];	  GO TO GotNext};	'A, 'B, 'C, 'D, 'E, 'F, 'G, 'H, 'I, 'J, 'K, 'L, 'M,	'N, 'O, 'P, 'Q, 'R, 'S, 'T, 'U, 'V, 'W, 'X, 'Y, 'Z  => {	  i: CARDINAL ¬ 0;	  uId: BOOLEAN ¬ TRUE;	  first, last: CARDINAL ¬ char-0c;	  DO	    buffer[i] ¬ char;	    IF (tI¬tI+1) = tMax THEN FillBuffer[];	    char ¬ tB[tI];	    SELECT char FROM	      IN ['A..'Z], IN ['0..'9] => { -- digits are in keywords (ie WORD8)		last ¬ char-0c; IF (i ¬ i+1) >= iMax THEN ExpandBuffer[]};	      IN ['a..'z], IN ['0..'9] => {		uId ¬ FALSE; IF (i ¬ i+1) >= iMax THEN ExpandBuffer[]};	      ENDCASE => EXIT;	    ENDLOOP;	  i ¬ i+1;	  desc.length ¬ i;	  IF uId THEN {	  hti: Symbols.HTIndex;	    h: HashIndex ¬ ((first*128-first) + last) MOD LAST[HashIndex] + 1;	    j, s1, s2: CARDINAL;	    WHILE (j ¬ hashTab[h].symbol) # 0 DO	      IF vocabIndex[j]-(s2¬vocabIndex[j-1]) = i THEN		FOR s1 IN [0 .. i) DO		  IF buffer[s1] # vocab.text[s2] THEN EXIT;		  s2 ¬ s2+1;		  REPEAT		    FINISHED => {class ¬ j; GO TO GotNext};		  ENDLOOP;	      IF (h ¬ hashTab[h].link) = 0 THEN EXIT;	      ENDLOOP;	      IF dataPtr.formatting AND		(hti ¬ SymbolOps.FindString[syms, @desc]) # Symbols.HTNull AND		SymbolOps.SearchContext[syms, hti, dataPtr.outerCtx] # Symbols.ISENull THEN 		  preDeclared ¬ TRUE};	  class ¬ tokenID;  	  IF ~dataPtr.formatting THEN value.r ¬ SymbolOps.EnterString[syms, @desc];	  GO TO GotNext};	'0, '1, '2, '3, '4, '5, '6, '7, '8, '9  => {	  valid: BOOLEAN;	  [class, value, valid] ¬ CollectNumber[i: 0];	  IF ~valid THEN ScanError[number, index];	  GO TO GotNext};		',, ';, ':, '_, '#, '+, '*, '/, '^, '@, '!,	'(, '), '[, '], '{, '}  => {	  class ¬ scanTab[char]; GO TO GetNext};	'' => {	  c: CHARACTER;	  valid, advance: BOOLEAN;	  NextChar[];	  [c, valid, advance] ¬ Escape[];	  IF ~valid THEN ScanError[escape, index + 1];	  class ¬ tokenCHAR;  	  IF ~dataPtr.formatting THEN value.r ¬ LiteralOps.Find[syms, c-0c];	  IF advance THEN GO TO GetNext ELSE GO TO GotNext};	'" => {	  i: CARDINAL ¬ 0;	  valid: BOOLEAN;	  advance: BOOLEAN ¬ TRUE;	  DO 	    IF advance THEN {	      IF (tI¬tI+1) = tMax THEN {IF tEnded THEN GO TO EOFEnd; FillBuffer[]};	      char ¬ tB[tI]};	    SELECT char FROM	      '" => {		IF (tI¬tI+1) = tMax THEN FillBuffer[];		char ¬ tB[tI];		IF char # '" THEN GO TO QuoteEnd};	      ENDCASE;	    IF i >= iMax THEN ExpandBuffer[	        ! BufferOverflow => {ScanError[string, index]; i ¬ 0; CONTINUE}];	    [buffer[i], valid, advance] ¬ Escape[];  i ¬ i+1;	    IF ~valid THEN ScanError[escape, tOrigin + tI];	    REPEAT	      QuoteEnd => NULL;	      EOFEnd => {ScanError[string, index]; FillBuffer[]; char ¬ tB[tI]};	    ENDLOOP;	  desc.length ¬ i;	  IF ~dataPtr.formatting THEN value.r ¬ LiteralOps.LitFindString[syms, @desc];	  IF char = 'l OR char = 'L THEN {class ¬ tokenLSTR; GO TO GetNext}	  ELSE {	    class ¬ tokenSTR; 	    IF char = 'g OR char = 'G THEN GO TO GetNext	    ELSE GO TO GotNext}};	'- => {	  comment: Style.Comment;	  dashCrlf: BOOLEAN ¬ FALSE;	  NextChar[];	  IF char # '- THEN {class ¬ tokenMINUS; GO TO GotNext};	  char ¬ Ascii.NUL;	  DO	    pChar: CHARACTER = char;	    IF (tI¬tI+1) = tMax THEN {IF tEnded THEN GO TO EndFile; FillBuffer[]};	    char ¬ tB[tI];	    SELECT char FROM	      '- => IF pChar = '- THEN {comment ¬ dash; EXIT};	      Ascii.CR => {comment ¬ crlf; nLines ¬ nLines + 1; EXIT};	      ENDCASE;	    ENDLOOP;	  NextChar[];	  IF comment = dash AND char = Ascii.CR THEN dashCrlf ¬ TRUE;	  IF dataPtr.formatting THEN [] ¬ Style.EnqueueItem[	    index: index,	    length: tOrigin + tI - index -		(IF comment = crlf THEN 1 ELSE 0),	    crCount: crCount,	    small: FALSE, 	    comment: IF dashCrlf THEN crlf ELSE comment];	  crCount ¬ IF comment = crlf THEN 1 ELSE 0};	'. => {	  IF qDot THEN {	    qDot ¬ FALSE; index ¬ index-1; class ¬ tokenDOTS; GO TO GetNext};	  NextChar[];	  SELECT char FROM	    '. => {class ¬ tokenDOTS; GO TO GetNext};	    IN ['0..'9] => {	      valid: BOOLEAN;	      buffer[0] ¬ '.;	      [class, value, valid] ¬ CollectNumber[i: 1, float: TRUE];	      IF ~valid THEN ScanError[number, index];	      GO TO GotNext};	    ENDCASE => {class ¬ tokenDOT; GO TO GotNext}};	'= => {	  NextChar[];	  IF char = '> THEN {class ¬ tokenARROW; GO TO GetNext}	  ELSE {class ¬ tokenEQUAL; GO TO GotNext}};	'< => {	  NextChar[];	  SELECT char FROM	    '= => {class ¬ tokenLE; GO TO GetNext};	    '< => GO TO ScanComment;	    ENDCASE => {class ¬ tokenLESS; GO TO GotNext}};		253c => GO TO ScanComment;	'> => {	  NextChar[];	  IF char = '= THEN {class ¬ tokenGE; GO TO GetNext}	  ELSE {class ¬ tokenGREATER; GO TO GotNext}};		-- Character mappings from right set to left	<<  This one should be included when ATOM is implemented.	244c => { -- dollar	  class ¬ scanTab['$]; GO TO GetNext};>>	254c => { -- left arrow	  class ¬ scanTab['_]; GO TO GetNext};	255c => { -- up arrow	  class ¬ scanTab['^]; GO TO GetNext};	264c => { -- times	  class ¬ scanTab['*]; GO TO GetNext};	270c => { -- divide	  class ¬ scanTab['/]; GO TO GetNext};	ENDCASE => {	  class ¬ scanTab[char];	  IF class # 0 THEN GO TO GetNext;	  NextChar[];	  ScanError[char, index]};	        EXITS ScanComment => {	state: {plain, leftBrocket, rightBrocket} ¬ plain;	nest: CARDINAL ¬ 1;	DO	  IF (tI¬tI+1) = tMax THEN {	    IF tEnded THEN GO TO EndFile; FillBuffer[]};	  char ¬ tB[tI];	  SELECT char FROM	    '> => SELECT state FROM	      plain, leftBrocket => state ¬ rightBrocket;	      rightBrocket => {		state ¬ plain; nest ¬ nest - 1; IF nest = 0 THEN EXIT};	      ENDCASE;	    '< => SELECT state FROM	      plain, rightBrocket => state ¬ leftBrocket;	      leftBrocket => {state ¬ plain; nest ¬ nest + 1};	      ENDCASE;	    253c => {state ¬ plain; nest ¬ nest + 1};	    273c => {state ¬ plain; nest ¬ nest - 1; IF nest = 0 THEN EXIT};	    -- Ascii.CR purposely don't count lines here	    ENDCASE => state ¬ plain;	  ENDLOOP;	NextChar[];	IF dataPtr.formatting THEN [] ¬ Style.EnqueueItem[	  index: index,	  length: tOrigin + tI - index,	  crCount: crCount,	  small: FALSE,	  comment: IF char = Ascii.CR THEN crlf ELSE dash];	crCount ¬ 0};      END;            REPEAT	GetNext => {IF (tI¬tI+1) = tMax THEN FillBuffer[]; char ¬ tB[tI]};	GotNext => NULL;	EndFile => {	  class ¬ EndMarker;  index ¬ tOrigin + (tI-1);  value ¬ P1.NullValue;	  UNTIL tEnded DO FillBuffer[] ENDLOOP;		-- flush stream	  FillBuffer[];  char ¬ tB[tI]};      ENDLOOP;    IF dataPtr.formatting THEN index ¬ Style.EnqueueItem[      index, tOrigin + tI - index - (IF qDot THEN 1 ELSE 0), crCount, preDeclared];    crCount ¬ 0;    RETURN}; -- numerical conversion  LongLit: TYPE = LONG UNSPECIFIED;  endMark: CHARACTER = Ascii.NUL;    CollectNumber: PROC [i: CARDINAL, float: BOOLEAN¬FALSE]      RETURNS [class: TSymbol, value: P1.Value, valid: BOOLEAN] = {    hexCount: CARDINAL ¬ 0;    hexSig: PACKED ARRAY CHARACTER['a..'h] OF {F, T} ¬ ALL[F];    v: LongLit;    Accept: PROC = INLINE {      buffer[i] ¬ char;      IF (i ¬ i+1) >= iMax THEN ExpandBuffer[];      NextChar[]};     maxWord: LONG CARDINAL = LAST[Environment.Word];    class ¬ tokenLNUM;    DO      SELECT char FROM	IN ['0..'9] => Accept[];	'e, 'E => {	  hexSig['e] ¬ T; hexCount ¬ hexCount + 1;  Accept[];	  IF hexCount = 1 AND char = '+ OR char = '- THEN {	    float ¬ TRUE; Accept[]}};	IN ['a..'f] => {hexSig[char] ¬ T; hexCount ¬ hexCount+1;  Accept[]};	IN ['A..'F] => {	  hexSig[char+('a-'A)] ¬ T; hexCount ¬ hexCount+1;  Accept[]};	'h, 'H => {hexSig['h] ¬ T; hexCount ¬ hexCount+1;  Accept[]};	'. => {	  IF hexCount # 0 OR float THEN EXIT;	  NextChar[];	  IF char = '. THEN {qDot ¬ TRUE; EXIT};	  float ¬ TRUE;	  buffer[i] ¬ '.;	  IF (i ¬ i+1) >= iMax THEN ExpandBuffer[]};	ENDCASE => EXIT;      ENDLOOP;    buffer[i] ¬ endMark;    SELECT TRUE FROM      float => {class ¬ tokenFLNUM; [v, valid] ¬ ScanFloating[buffer]};      (hexSig['h] = T) => [v, valid] ¬ ScanHex[buffer];      ENDCASE =>	SELECT hexCount FROM	  0 => [v, valid] ¬ ScanDecimal[buffer];	  1 =>	    SELECT hexSig FROM	      [F,T,F,F,F,F,F,F] => [v, valid] ¬ ScanOctal[buffer];	      [F,F,T,F,F,F,F,F] => {		class ¬ tokenCHAR;		[v, valid] ¬ ScanOctalChar[buffer]};	      [F,F,F,T,F,F,F,F] => [v, valid] ¬ ScanDecimal[buffer];	      [F,F,F,F,T,F,F,F] => {		class ¬ tokenFLNUM;		[v, valid] ¬ ScanFloating[buffer]};	    ENDCASE => [v, valid] ¬ ScanHex[buffer];	  ENDCASE => [v, valid] ¬ ScanHex[buffer];    SELECT class FROM      tokenCHAR => IF ~dataPtr.formatting THEN value ¬ EnterLit[v, FALSE];      tokenFLNUM => IF ~dataPtr.formatting THEN value ¬ EnterLit[v];      ENDCASE =>	IF LOOPHOLE[v, LONG CARDINAL] > maxWord THEN	  {IF ~dataPtr.formatting THEN value ¬ EnterLit[v]}	ELSE {class ¬ tokenNUM; value ¬ EnterLit[v, FALSE]};    RETURN};      Digit: ARRAY CHARACTER ['0..'9] OF CARDINAL = [0,1,2,3,4,5,6,7,8,9];  HexDigit: ARRAY CHARACTER ['A..'F] OF CARDINAL = [10,11,12,13,14,15];    AppendDecimal: PROC [v: LONG CARDINAL, digit: CHARACTER ['0..'9]]      RETURNS [newV: LONG CARDINAL, valid: BOOLEAN] = {    maxV: LONG CARDINAL = 429496729;	-- (2**32-1)/10    maxD: CARDINAL = 5;			-- (2**32-1) MOD 10    d: [0..9] = Digit[digit];    valid ¬ v < maxV OR (v = maxV AND d <= maxD);    newV ¬ 10*v + d;    RETURN};  AppendOctal: PROC [v: LONG CARDINAL, digit: CHARACTER ['0..'7]]      RETURNS [newV: LONG CARDINAL, valid: BOOLEAN] = {    maxV: LONG CARDINAL = 3777777777b;	-- (2**32-1)/8    d: [0..7] = Digit[digit];    valid ¬ (v <= maxV);    newV ¬ 8*v + d;    RETURN};  AppendHex: PROC [v: LONG CARDINAL, digit: CHARACTER ['0..'F]]      RETURNS [newV: LONG CARDINAL, valid: BOOLEAN] = {    maxV: LONG CARDINAL = 1777777777b;	-- (2**32-1)/16    d: [0..15] = IF digit IN ['0..'9] THEN Digit[digit] ELSE HexDigit[digit];    valid ¬ (v <= maxV);    newV ¬ 16*v + d;    RETURN};  AppendToScale: PROC [v: CARDINAL, digit: CHARACTER ['0..'9]]      RETURNS [newV: CARDINAL, valid: BOOLEAN] = {    maxV: CARDINAL = 6553;		-- (2**16-1)/10    maxD: CARDINAL = 5;			-- (2**16-1) MOD 10    d: [0..9] = Digit[digit];    valid ¬ v < maxV OR (v = maxV AND d <= maxD);    newV ¬ 10*v + d;    RETURN};      ValidFraction: PROC [v: LONG CARDINAL, digit: CHARACTER ['0..'9]] RETURNS [BOOLEAN] = {    maxV: LONG CARDINAL = 214748364;	-- (2**31-1)/10    maxD: CARDINAL = 7;			-- (2**31-1) MOD 10    RETURN [v < maxV OR (v = maxV AND Digit[digit] <= maxD)]};   ScanDecimal: PROC [s: LONG STRING] RETURNS [value: LongLit, valid: BOOLEAN¬TRUE] = {    c: CHARACTER;    i: CARDINAL ¬ 0;    v: LONG CARDINAL ¬ 0;    IF s[i] NOT IN ['0..'9] THEN valid ¬ FALSE;    WHILE (c ¬ s[i]) IN ['0..'9] DO      IF valid THEN [v, valid] ¬ AppendDecimal[v, c];      i ¬ i+1;      ENDLOOP;    IF c = 'd OR c = 'D THEN {      scale: CARDINAL ¬ 0;      WHILE (c ¬ s[i¬i+1]) IN ['0..'9] DO	IF valid THEN [scale, valid] ¬ AppendToScale[scale, c];	ENDLOOP;      THROUGH [1 .. scale] WHILE valid DO	[v, valid] ¬ AppendDecimal[v, '0] ENDLOOP};     IF c # endMark THEN valid ¬ FALSE;     value ¬ v;     RETURN};          ScanOctal: PROC [s: LONG STRING] RETURNS [value: LongLit, valid: BOOLEAN¬TRUE] = {    c: CHARACTER;    i: CARDINAL ¬ 0;    v: LONG CARDINAL ¬ 0;    IF s[i] NOT IN ['0..'7] THEN valid ¬ FALSE;    WHILE (c ¬ s[i]) IN ['0..'7] DO      IF valid THEN [v, valid] ¬ AppendOctal[v, c];      i ¬ i+1;      ENDLOOP;    IF c = 'b OR c = 'B THEN {      scale: CARDINAL ¬ 0;      WHILE (c ¬ s[i¬i+1]) IN ['0..'9] DO	IF valid THEN [scale, valid] ¬ AppendToScale[scale, c];	ENDLOOP;      THROUGH [1 .. scale] WHILE valid DO	[v, valid] ¬ AppendOctal[v, '0] ENDLOOP};    IF c # endMark THEN valid ¬ FALSE;    value ¬ v;    RETURN};  ScanOctalChar: PROC [s: LONG STRING] RETURNS [value: LongLit, valid: BOOLEAN¬TRUE] = {    c: CHARACTER;    maxChar: CARDINAL = 377b;    i: CARDINAL ¬ 0;    v: LONG CARDINAL ¬ 0;    IF s[i] NOT IN ['0..'7] THEN valid ¬ FALSE;    WHILE (c ¬ s[i]) IN ['0..'7] DO      IF valid THEN [v, valid] ¬ AppendOctal[v, c];      i ¬ i+1;      ENDLOOP;    IF c = 'c OR c = 'C THEN c ¬ s[i¬i+1] ELSE valid ¬ FALSE;    IF c # endMark OR v NOT IN [0 .. maxChar] THEN valid ¬ FALSE;    value ¬ v;    RETURN};  ScanHex: PROC [s: LONG STRING] RETURNS [value: LongLit, valid: BOOLEAN¬TRUE] = {    c: CHARACTER;    i: CARDINAL ¬ 0;    v: LONG CARDINAL ¬ 0;    IF s[i] NOT IN ['0..'9] THEN valid ¬ FALSE;    DO      SELECT (c ¬ s[i]) FROM	IN ['0..'9], IN ['A..'F] =>          IF valid THEN [v, valid] ¬ AppendHex[v, c];	IN ['a..'f] =>          IF valid THEN [v, valid] ¬ AppendHex[v, c-('a-'A)];        ENDCASE => EXIT;      i ¬ i + 1;      ENDLOOP;    IF c = 'h OR c = 'H THEN {      scale: CARDINAL ¬ 0;      WHILE (c ¬ s[i¬i+1]) IN ['0..'9] DO        IF valid THEN [scale, valid] ¬ AppendToScale[scale, c];        ENDLOOP;      THROUGH [1 .. scale] WHILE valid DO	[v, valid] ¬ AppendHex[v, '0] ENDLOOP};    IF c # endMark THEN valid ¬ FALSE;    value ¬ v;    RETURN};  ScanFloating: PROC [s: LONG STRING] RETURNS [value: LongLit, valid: BOOLEAN¬TRUE] = {    c: CHARACTER;    i: CARDINAL ¬ 0;    v: LONG CARDINAL ¬ 0;    exp: INTEGER ¬ 0;    WHILE (c ¬ s[i]) IN ['0..'9] DO      valid ¬ valid AND ValidFraction[v, c];      IF valid THEN v ¬ AppendDecimal[v, c].newV      ELSE exp ¬ exp + 1;	-- should round      i ¬ i+1;      ENDLOOP;    IF c = '. THEN {      i ¬ i+1;      IF s[i] NOT IN ['0..'9] THEN valid ¬ FALSE;      WHILE (c ¬ s[i]) IN ['0..'9] DO	valid ¬ valid AND ValidFraction[v, c];	IF valid THEN {[v, valid] ¬ AppendDecimal[v, c]; exp ¬ exp-1}	ELSE NULL;	-- should round	i ¬ i+1;	ENDLOOP};    valid ¬ TRUE;    IF c = 'e OR c = 'E THEN {      scale: INTEGER ¬ 0;      op: {plus, minus} ¬ plus;      i ¬ i + 1;      SELECT s[i] FROM        '+ => i ¬ i+1;        '- => {op ¬ minus; i ¬ i+1};        ENDCASE;      IF s[i] NOT IN ['0..'9] THEN valid ¬ FALSE;      WHILE (c ¬ s[i]) IN ['0..'9] DO	IF valid THEN [scale, valid] ¬ AppendToScale[scale, c];	i ¬ i+1;	ENDLOOP;      exp ¬ IF op = plus THEN exp + scale ELSE exp - scale};	-- need overflow check    IF c # endMark THEN valid ¬ FALSE;    value ¬ Real.PairToReal[v, exp		! Real.RealException => {valid ¬ FALSE; RESUME}];    RETURN};      EnterLit: PROC [v: LongLit, long: BOOLEAN¬TRUE] RETURNS [P1.Value] = {    vRep: ARRAY [0..SIZE[LongLit]) OF WORD ¬ LOOPHOLE[v];    RETURN [[ref[IF long      THEN LiteralOps.FindDescriptor[syms, DESCRIPTOR[vRep]]      ELSE LiteralOps.Find[syms, vRep[0]]]]]};     -- character and string constants   EscapeMark: CHARACTER = 134c;		-- '\    Escape: PROC RETURNS [c: CHARACTER, valid, advance: BOOLEAN ¬ TRUE] = {    c ¬ char;    IF c = EscapeMark THEN {      NextChar[];      SELECT char FROM	'n, 'N => c ¬ Ascii.CR;	'r, 'R => c ¬ Ascii.CR;	'l, 'L => c ¬ Ascii.LF;	't, 'T => c ¬ Ascii.TAB;	'b, 'B => c ¬ Ascii.BS;	'f, 'F => c ¬ Ascii.FF;	'', '", EscapeMark => c ¬ char;	IN ['0 .. '7] => {          nc, v: CARDINAL ¬ 0;	  DO	    IF ~(char IN ['0..'7]) THEN {valid ¬ advance ¬ FALSE; EXIT};	    v ¬ 8*v + (char - '0);	    IF (nc ¬ nc+1) = 3 THEN EXIT;	    NextChar[];	    ENDLOOP;	  IF v > 377b THEN {valid ¬ FALSE; v ¬ 0};	  c ¬ v + 0c};        ENDCASE => valid ¬ advance ¬ FALSE};    RETURN};          -- initialization/finalization  ScanInit: PUBLIC PROC [table: ParseTable.TableRef] = {    zone ¬ CompilerUtil.AcquireZone[];    syms ¬ dataPtr.ownSymbols;    stream ¬ CompilerUtil.AcquireStream[source];    hashTab ¬ @table[table.scanTable.hashTab];    scanTab ¬ @table[table.scanTable.scanTab];    vocab ¬ LOOPHOLE[@table[table.scanTable.vocabBody]];    vocabIndex ¬ @table[table.scanTable.vocabIndex];    IF buffer = NIL THEN buffer ¬ zone.NEW[StringBody[256]];    iMax ¬ buffer.length ¬ buffer.maxlength;    desc.base ¬ buffer;  desc.offset ¬ 0;    streamOrigin ¬ stream.GetPosition[];    tB ¬ zone.NEW[TextBuffer];    tOrigin ¬ tLimit ¬ 0;  tMax ¬ 0;  tEnded ¬ FALSE;    FillBuffer[];  char ¬ tB[tI];  qDot ¬ FALSE;    nLines ¬ nErrors ¬ 0; hadErrors ¬ FALSE;    IF dataPtr.formatting THEN {Style.ItemQueueInit[]; crCount ¬ 0}};  ScanReset: PUBLIC PROC = {    IF dataPtr.formatting THEN Style.ItemQueueReset[hadErrors];    CompilerUtil.ReleaseStream[source];    zone.FREE[@tB];    IF buffer # NIL THEN zone.FREE[@buffer];    CompilerUtil.ReleaseZone[zone]; zone ¬ NIL;    syms ¬ NIL };  ScanStats: PUBLIC PROC RETURNS [CARDINAL, CARDINAL] = {    RETURN [nLines, nErrors]}; -- error handling  ResetScanIndex: PUBLIC PROC [index: CARDINAL] RETURNS [success: BOOLEAN] = {    IF dataPtr.formatting THEN {      hadErrors ¬ TRUE; index ¬ Style.ItemHandleToStreamIndex[index]};    IF ~(index IN [tOrigin .. tLimit)) THEN {      page: CARDINAL = index/Environment.charsPerPage;      tOrigin ¬ tLimit ¬ page*Environment.charsPerPage;      tMax ¬ 0;  tEnded ¬ FALSE;      stream.SetPosition[streamOrigin + tOrigin];      FillBuffer[]};    tI ¬ index - tOrigin;    IF tI >= tMax THEN FillBuffer[];  char ¬ tB[tI]; RETURN [TRUE]};  ErrorCode: TYPE = {number, string, char, atom, escape};    ScanError: PROC [code: ErrorCode, tokenIndex: CARDINAL] = {    errorStream: Stream.Handle ¬ CompilerUtil.AcquireStream[log];    nErrors ¬ nErrors + 1;    ErrorContext[errorStream,      SELECT code FROM	number => "invalid number"L,	string => "string unterminated or too long"L,	char => "invalid character"L,	atom => "invalid atom"L,	escape => "invalid escape sequence"L,	ENDCASE => NIL,      tokenIndex];    CharIO.PutChar[errorStream, Ascii.CR];    CompilerUtil.ReleaseStream[log]};  ItemHandleToStreamIndex: PROC [i: CARDINAL] RETURNS [CARDINAL] = {    hadErrors ¬ TRUE; RETURN[Style.ItemHandleToStreamIndex[i]]};        ErrorContext: PUBLIC PROC [      to: Stream.Handle, message: LONG STRING, tokenIndex: CARDINAL] = {    OPEN CharIO;    saveIndex: Stream.Position = stream.GetPosition[];    origin: Stream.Position =       IF dataPtr.formatting THEN ItemHandleToStreamIndex[tokenIndex]      ELSE streamOrigin + tokenIndex;    start, lineIndex: Stream.Position ¬ origin;    char: CHARACTER;    n: [1..100];    FOR n IN [1..100] UNTIL lineIndex = 0 DO      lineIndex ¬ lineIndex - 1;      stream.SetPosition[lineIndex];      IF stream.GetChar[] = Ascii.CR THEN EXIT;      start ¬ lineIndex;      ENDLOOP;    stream.SetPosition[start];    FOR n IN [1..100] UNTIL MStream.EndOf[stream] DO      char ¬ stream.GetChar[];      SELECT char FROM	Ascii.CR, Ascii.ControlZ => EXIT;	ENDCASE => PutChar[to, char];      ENDLOOP;    CharIO.PutChar[to, Ascii.CR];    stream.SetPosition[start];    UNTIL stream.GetPosition[] = origin OR MStream.EndOf[stream] DO      char ¬ stream.GetChar[];      PutChar[to, IF char = Ascii.TAB THEN Ascii.TAB ELSE ' ];      ENDLOOP;    PutString[to, "­ "L];  PutString[to, message];  PutString[to, " ["L];    PutNumber[      to, CARDINAL[origin], [base:10, zerofill:FALSE, unsigned:TRUE, columns:0]];    PutChar[to, ']];   CharIO.PutChar[to, Ascii.CR];    stream.SetPosition[saveIndex]};  }.
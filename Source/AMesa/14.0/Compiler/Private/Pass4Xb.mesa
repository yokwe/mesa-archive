-- Copyright (C) 1983, 1986  by Xerox Corporation. All rights reserved. -- file Pass4Xb.mesa--  Satterthwaite,	October 22, 1982 12:34 pm--  Sweet,		14-Oct-83 11:37:03--  Johnsson,		11-Jun-83 14:21:39--  Wagner		22-Aug-86 11:11:30--  Saxe		10-Apr-87 17:45:52DIRECTORY  ComData USING [    switches, typeCARDINAL, typeINT, typeLONGSTRING, typeSTRING],  Literals USING [STIndex],  LiteralOps USING [    FindLocalString, MasterString, ValueDescriptor, FindDescriptor],  CLog USING [ErrorSei, ErrorTree, WarningTree],  OSMiscOps USING [FreeWords, Words],  P4 USING [    Attr, voidAttr, Prop, emptyProp, fullProp, voidProp, Lengthen, VStack, ValueDescriptor,    Repr, none, signed, unsigned, both, long, other, RegCount, maxRegs, checked,    AddOp, AddrOp, All, Assignment, BiasForType, BindCase, BindType, BoolValue, Call,    CaseDriver, CheckOver, CheckRange, CommonAttr, CommonProp,    CommonRep, ComparableType,ConstantInterval, Construct, currentLevel, DeclItem, Dollar,    DivMod, EmptyInterval, Extract, FoldExpr, Index, Interval, IntToReal, LiteralRep,    LongToShort, MakeTreeLiteral, MarkString, MiscXfer, Mult, Narrow, New, NormalizeRange,    PadRecord, Reloc, RepForType, Rhs, RowConstruct, SeqIndex,    StructuredLiteral, Substx, TreeLiteral, TreeLiteralValue, TypeExp, TypeOp,    Union, WordsForType],  Pass4 USING [implicitAttr, implicitBias, implicitType, tFALSE, tTRUE],  Symbols USING [    SEIndex, ISEIndex, CSEIndex, lG, typeANY],  SymbolOps USING [    Cardinality, FindExtension, NormalType, RCType, TypeForm,    ToTreeIndex, UnderType, WordsForType, XferMode],  SymbolTable USING [Handle],  Tree USING [Index, Link, NodeName, Null],  TreeOps USING [    FreeNode, GetNode, GetSe, IdentityMap, ListLength, Map, OpName, PopTree,    PushLit, PushNode, PushTree, SetAttr, SetInfo, SetShared, Shared, UpdateList,    DecodeCSei, EncodeSei];Pass4Xb: PROGRAM    IMPORTS      Log: CLog, LiteralOps, OSMiscOps, P4, SymbolOps, TreeOps,      dataPtr: ComData, passPtr: Pass4    EXPORTS P4 = {  OPEN SymbolOps, P4, TreeOps; -- pervasive definitions from Symbols  ISEIndex: TYPE = Symbols.ISEIndex;  CSEIndex: TYPE = Symbols.CSEIndex;  zone: UNCOUNTED ZONE ¬ NIL;    syms: SymbolTable.Handle ¬ NIL;    Pass4XbInit: PUBLIC PROC [h: SymbolTable.Handle, scratchZone: UNCOUNTED ZONE] = {    zone ¬ scratchZone;    syms ¬ h;    vStack ¬ zone.NEW[VStack[32]];    vI ¬ -1};  ExpReset: PUBLIC PROC = {    IF vStack # NIL THEN zone.FREE[@vStack];    syms ¬ NIL;    zone ¬ NIL}; -- intermediate result bookkeeping  vStack: PUBLIC LONG POINTER TO VStack ¬ NIL;  vI: PUBLIC INTEGER;			-- index into vStack  VPush: PUBLIC PROC [bias: INTEGER, attr: Attr, nRegs: RegCount] = {    vI ¬ vI + 1;    WHILE vI >= vStack.length DO      newLength: NAT = vStack.length + 16;      newStack: LONG POINTER TO VStack = zone.NEW[VStack[newLength]];      FOR i: INTEGER IN [0 .. vI) DO newStack[i] ¬ vStack[i] ENDLOOP;      zone.FREE[@vStack];      vStack ¬ newStack;      ENDLOOP;    vStack[vI] ¬ [bias:bias, attr:attr, nRegs:nRegs]};  VPop: PUBLIC PROC = {IF vI < 0 THEN ERROR; vI ¬ vI-1};  VBias: PUBLIC PROC RETURNS [INTEGER] = {RETURN [vStack[vI].bias]};  VAttr: PUBLIC PROC RETURNS [Attr] = {RETURN [vStack[vI].attr]};  VProp: PUBLIC PROC RETURNS [Prop] = {RETURN [vStack[vI].attr.prop]};  VRep: PUBLIC PROC RETURNS [Repr] = {RETURN [vStack[vI].attr.rep]};  VRegs: PUBLIC PROC RETURNS [RegCount] = {RETURN [vStack[vI].nRegs]};  TypeForString: PROCEDURE [sti: Literals.STIndex] RETURNS [CSEIndex] = {    IF dataPtr.switches['o] THEN RETURN[dataPtr.typeSTRING]    ELSE IF currentLevel = Symbols.lG THEN RETURN[dataPtr.typeLONGSTRING]    ELSE IF syms.stb[LiteralOps.MasterString[syms, sti]].info # 0 THEN       RETURN[dataPtr.typeLONGSTRING];    RETURN[dataPtr.typeSTRING];    };  OperandType: PUBLIC PROC [t: Tree.Link] RETURNS [CSEIndex] = {    RETURN [WITH t SELECT FROM      symbol => UnderType[syms, syms.seb[index].idType],      literal => WITH info SELECT FROM	  string => TypeForString[index],	  ENDCASE => dataPtr.typeINT,      subtree =>         IF t = Tree.Null THEN passPtr.implicitType 	ELSE DecodeCSei[syms.tb[index].info],      ENDCASE => Symbols.typeANY]};  ForceType: PUBLIC PROC [t: Tree.Link, type: CSEIndex] RETURNS [Tree.Link] = {    PushTree[syms, t];    IF (OpName[syms, t] # mwconst AND OpName[syms, t] # cast) OR Shared[syms, t] THEN PushNode[syms, cast, 1];    SetInfo[syms, EncodeSei[type]];  RETURN [PopTree[syms]]};  ChopType: PROC [t: Tree.Link, type: CSEIndex] RETURNS [Tree.Link] = {    PushTree[syms, t]; PushNode[syms, chop, 1];     SetInfo[syms, EncodeSei[type]]; RETURN [PopTree[syms]]}; -- literals  MakeStructuredLiteral: PUBLIC PROC [val: WORD, type: CSEIndex]      RETURNS [t: Tree.Link] = {    t ¬ MakeTreeLiteral[val];    SELECT TypeForm[syms, type] FROM      basic, enumerated, subrange, mode => NULL;      ENDCASE => t ¬ ForceType[t, type];    RETURN};      LiteralAttr: PUBLIC PROC [rep: Repr] RETURNS [Attr] = {    RETURN [[prop: fullProp, rep: rep]]}; -- attribute accounting   BinaryAttr: PUBLIC PROC RETURNS [Attr] = {     RETURN [CommonAttr[vStack[vI-1].attr, vStack[vI].attr]]};       MergeAttr: PROC [old: Attr] RETURNS [Attr] = {    RETURN [CommonAttr[old, vStack[vI].attr]]};          -- register accounting  RegsForType: PUBLIC PROC [type: CSEIndex] RETURNS [RegCount] = {    n: RegCount =       IF syms.seb[type].mark4 THEN RegCount[SymbolOps.WordsForType[syms, type]] ELSE 0;    RETURN [IF n = 2 THEN 2 ELSE 1]};  ComputeRegs: PUBLIC PROC [node: Tree.Index] RETURNS [RegCount] = {    n1: RegCount = vStack[vI-1].nRegs;    n2: RegCount = vStack[vI].nRegs;    k: RegCount = RegsForType[DecodeCSei[syms.tb[node].info]];    RETURN [MIN[MAX[n1, n2+k], maxRegs]]};  ComputeIndexRegs: PUBLIC PROC [node: Tree.Index] RETURNS [RegCount] = {    n1: RegCount = vStack[vI-1].nRegs;    n2: RegCount = vStack[vI].nRegs;    k: RegCount = RegsForType[OperandType[syms.tb[node].son[1]]];    RETURN [MIN[MAX[RegsForType[DecodeCSei[syms.tb[node].info]], n1, n2+k], maxRegs]]};  AdjustRegs: PUBLIC PROC [node: Tree.Index, commuteOp: Tree.NodeName]      RETURNS [RegCount] = {    n1: RegCount = vStack[vI-1].nRegs;    n2: RegCount = vStack[vI].nRegs;    k: RegCount = RegsForType[DecodeCSei[syms.tb[node].info]];    n: CARDINAL;    IF n1 >= n2 THEN n ¬ n2 + k    ELSE {      v: ValueDescriptor;      t: Tree.Link ¬ syms.tb[node].son[1];      syms.tb[node].son[1] ¬ syms.tb[node].son[2]; syms.tb[node].son[2] ¬ t;      syms.tb[node].name ¬ commuteOp;      v ¬ vStack[vI]; vStack[vI] ¬ vStack[vI-1]; vStack[vI-1] ¬ v;      n ¬ n1 + k};    RETURN [MIN[MAX[n1, n2, n], maxRegs]]}; -- constant folding  Fold: PUBLIC PROC [node: Tree.Index, rep: Repr] RETURNS [Tree.Link] = {    fullRep: Repr = IF syms.tb[node].attr2 THEN long + rep ELSE rep;    RETURN [FoldExpr[node, fullRep]]};      FoldedAttr: PUBLIC PROC [val: Tree.Link, rep: Repr] RETURNS [Attr] = {    RETURN [LiteralAttr[LiteralRep[val, rep]]]}; -- operators  UMinus: PROC [node: Tree.Index] RETURNS [val: Tree.Link] = {    rep: Repr;    syms.tb[node].son[1] ¬ Exp[syms.tb[node].son[1], signed];  rep ¬ vStack[vI].attr.rep;    SELECT rep FROM      both => rep ¬ signed;      none => {Log.WarningTree[mixedRepresentation, val]; rep ¬ signed};      ENDCASE => NULL;    IF ~StructuredLiteral[syms.tb[node].son[1]] THEN {      syms.tb[node].attr3 ¬ TRUE; val ¬ [subtree[index: node]]}    ELSE val ¬ Fold[node, rep];    IF rep = unsigned THEN rep ¬ signed;    vStack[vI].attr.rep ¬ rep;  vStack[vI].bias ¬ -VBias[];    RETURN};  Abs: PROC [node: Tree.Index] RETURNS [val: Tree.Link] = {    rep: Repr;    syms.tb[node].son[1] ¬ RValue[syms.tb[node].son[1], 0, signed];    val ¬ [subtree[index: node]];  rep ¬ vStack[vI].attr.rep;    SELECT rep FROM      unsigned, both => {	Log.WarningTree[unsignedCompare, val];	val ¬ syms.tb[node].son[1];  syms.tb[node].son[1] ¬ Tree.Null;  FreeNode[syms, node]};      none => {Log.ErrorTree[mixedRepresentation, val]; rep ¬ both};      ENDCASE => {	syms.tb[node].attr3 ¬ TRUE;	IF StructuredLiteral[syms.tb[node].son[1]] THEN val ¬ Fold[node, rep];	IF rep # other THEN rep ¬ both};    vStack[vI].attr.rep ¬ rep;    RETURN};  EnumOp: PROC [node: Tree.Index, target: Repr] RETURNS [Tree.Link] = {    t: Tree.Link;    type: CSEIndex = DecodeCSei[syms.tb[node].info];    nType: CSEIndex = NormalType[syms, type];    long: BOOLEAN = (TypeForm[syms, type] = long);    d: INTEGER ¬ 0;    DO      d ¬ IF syms.tb[node].name = pred THEN d-1 ELSE d+1;      t ¬ syms.tb[node].son[1];  syms.tb[node].son[1] ¬ Tree.Null; FreeNode[syms, node];      SELECT OpName[syms, t] FROM	pred, succ => NULL;	ENDCASE => EXIT;      node ¬ GetNode[syms, t];      ENDLOOP;    PushTree[syms, t];  PushTree[syms, MakeTreeLiteral[ABS[d]]];    IF long THEN {PushNode[syms, lengthen, 1];     SetInfo[syms, EncodeSei[type]]};    PushNode[syms, IF d < 0 THEN minus ELSE plus, 2];    SetInfo[syms, EncodeSei[type]]; SetAttr[syms, 1, FALSE]; SetAttr[syms, 2, long];    RETURN [IF TypeForm[syms, nType] = enumerated      THEN CheckRange[	RValue[PopTree[syms], 	BiasForType[nType], target], 	P4.CheckOver[Cardinality[syms, nType]], nType]      ELSE AddOp[GetNode[syms, PopTree[syms]], target]]};  ArithRep: PUBLIC PROC [rep, target: Repr] RETURNS [Repr] = {    RETURN [SELECT rep FROM      both, none =>        SELECT target FROM both, none, other => signed, ENDCASE => target,      ENDCASE => rep]};        BiasedFold: PUBLIC PROC [node: Tree.Index, rep: Repr] RETURNS [Tree.Link] = {    fullRep: Repr = IF syms.tb[node].attr2 THEN long + rep ELSE rep;    syms.tb[node].son[1] ¬ AdjustBias[syms.tb[node].son[1], -vStack[vI-1].bias];    syms.tb[node].son[2] ¬ AdjustBias[syms.tb[node].son[2], -vStack[vI].bias];    RETURN [FoldExpr[node, fullRep]]};  RelOp: PROC [node: Tree.Index] RETURNS [val: Tree.Link] = {    OPEN syms.tb[node];    attr: Attr;    rep1, rep2: Repr;    nRegs: RegCount;    d1, d2: INTEGER;    uc: BOOLEAN;    ZeroWarning: ARRAY Tree.NodeName [relE..relLE] OF [0..2] = [0, 0, 2, 2, 1, 1];    CommutedOp: ARRAY Tree.NodeName [relE..relLE] OF Tree.NodeName = [      relE, relN, relG, relLE, relL, relGE];    son[1] ¬ Exp[son[1], none];  rep1 ¬ VRep[];  d1 ¬ VBias[];    son[2] ¬ Exp[son[2], none];  rep2 ¬ VRep[];  d2 ¬ VBias[];    IF ~ComparableSons[node] THEN Log.ErrorTree[sizeClash, son[2]];    val ¬ [subtree[index: node]];    attr ¬ BinaryAttr[];    IF attr.rep = none THEN      SELECT name FROM	relE, relN => Log.WarningTree[mixedRepresentation, val];	ENDCASE => Log.ErrorTree[mixedRepresentation, val];    SELECT name FROM      relE, relN => uc ¬ FALSE;      ENDCASE => {	IF rep1 = unsigned OR rep2 = unsigned THEN {	  son[1] ¬ AdjustBias[son[1], -d1];  d1 ¬ 0;	  son[2] ¬ AdjustBias[son[2], -d2];  d2 ¬ 0};	uc ¬ CommonRep[attr.rep, unsigned] # none};    IF d1 # d2 THEN      IF (~uc AND TreeLiteral[son[2]]) OR (uc AND d2 > d1) THEN        son[2] ¬ AdjustBias[son[2], d1-d2]      ELSE son[1] ¬ AdjustBias[son[1], d2-d1];    IF CommonRep[attr.rep, signed+other] = none THEN {      SELECT ZeroWarning[name] FROM	1 => IF TreeLiteral[son[1]] AND TreeLiteralValue[son[1]] = 0 THEN GO TO warn;	2 => IF TreeLiteral[son[2]] AND TreeLiteralValue[son[2]] = 0 THEN GO TO warn;	ENDCASE;      EXITS	warn => Log.WarningTree[unsignedCompare, val]};    IF StructuredLiteral[son[1]] AND StructuredLiteral[son[2]] AND ~attr1 THEN {      val ¬ Fold[node, attr.rep];  nRegs ¬ 1}    ELSE {nRegs ¬ AdjustRegs[node, CommutedOp[name]]; attr3 ¬ attr.rep # unsigned};    VPop[];  VPop[];    attr.rep ¬ both;  VPush[0, attr, nRegs];    RETURN};  ComparableSons: PROC [node: Tree.Index] RETURNS [BOOLEAN] = {    OPEN syms.tb[node];    -- compatibility version    type1: CSEIndex = OperandType[son[1]];    n1: CARDINAL = P4.CheckOver[P4.WordsForType[type1]];    type2: CSEIndex = OperandType[son[2]];    n2: CARDINAL = P4.CheckOver[P4.WordsForType[type2]];    IF n1 = 0 OR n2 = 0 THEN RETURN [FALSE];    SELECT TRUE FROM      (n1 = n2) => NULL;      (TypeForm[syms, type1] = record AND TypeForm[syms, type2] = record) =>	IF n1 < n2 THEN 	-- account for lost discrimination	  son[2] ¬ ChopType[son[2], type1]	ELSE son[1] ¬ ChopType[son[1], type2];      ENDCASE => RETURN [FALSE];    RETURN [ComparableType[type1] OR ComparableType[type2]]};  In: PROC [node: Tree.Index] RETURNS [val: Tree.Link] = {    OPEN syms.tb[node];    bias: INTEGER;    attr: Attr;    nRegs: RegCount;    void, const: BOOLEAN;    subNode: Tree.Index;    son[1] ¬ Exp[son[1], none];  bias ¬ VBias[];  attr ¬ VAttr[];--  IF attr.rep = unsigned  THEN      {son[1] ¬ AdjustBias[son[1], -bias]; bias ¬ 0};    void ¬ FALSE;  val ¬ [subtree[index: node]];    son[2] ¬ NormalizeRange[son[2]];  subNode ¬ GetNode[syms, son[2]];    IF (const ¬ Interval[subNode, bias, none].const) AND ~syms.tb[node].attr2 THEN      [] ¬ ConstantInterval[subNode ! EmptyInterval => {void ¬ TRUE; RESUME}];    attr ¬ MergeAttr[attr];    IF attr.rep = none THEN Log.ErrorTree[mixedRepresentation, val];    syms.tb[subNode].attr3 ¬ attr3 ¬ (attr.rep # unsigned);    SELECT TRUE FROM      void AND son[1] # Tree.Null => {	FreeNode[syms, node]; val ¬ passPtr.tFALSE; nRegs ¬ 1};      const AND StructuredLiteral[son[1]] AND ~attr1 => {	val ¬ Fold[node, attr.rep]; nRegs ¬ 1};      ENDCASE => nRegs ¬ ComputeRegs[node];    VPop[];  VPop[];  VPush[0, attr, nRegs];  RETURN};  BoolOp: PROC [node: Tree.Index] RETURNS [val: Tree.Link] = {    OPEN syms.tb[node];    b: Tree.Link = IF (name = and) THEN passPtr.tTRUE ELSE passPtr.tFALSE;    n1, n2, nRegs: RegCount;    attr: Attr;    son[1] ¬ BoolValue[son[1]];  n1 ¬ VRegs[];    son[2] ¬ BoolValue[son[2]];  n2 ¬ VRegs[];    IF TreeLiteral[son[1]] THEN {      IF son[1] = b THEN {        val ¬ son[2]; son[2] ¬ Tree.Null; attr ¬ vStack[vI-1].attr; nRegs ¬ n2}      ELSE {	val ¬ IF (name = and) THEN passPtr.tFALSE ELSE passPtr.tTRUE;	attr ¬ LiteralAttr[both];  nRegs ¬ 1};       FreeNode[syms, node]}    ELSE {      attr ¬ BinaryAttr[];      IF son[2] # b THEN {val ¬ [subtree[index: node]]; nRegs ¬ MAX[n1, n2]}      ELSE {val ¬ son[1]; son[1] ¬ Tree.Null; nRegs ¬ n1; FreeNode[syms, node]}};    VPop[];  VPop[];    attr.rep ¬ both;  VPush[0, attr, nRegs];    RETURN};  CheckAlt: PROC [t: Tree.Link, target: CSEIndex] RETURNS [Tree.Link] = {    type: CSEIndex = OperandType[t];    IF P4.WordsForType[type] # P4.WordsForType[target] THEN      IF TypeForm[syms, type] = record AND TypeForm[syms, target] = record THEN	t ¬ PadRecord[t, target]      ELSE Log.ErrorTree[sizeClash, t];    RETURN [t]};  IfExp: PROC [node: Tree.Index, target: Repr] RETURNS [val: Tree.Link] = {    OPEN syms.tb[node];    select: Tree.Link;    prop: Prop;    attr: Attr;    nRegs: RegCount;    bias: INTEGER = BiasForType[DecodeCSei[info]];    son[1] ¬ BoolValue[son[1]];  prop ¬ VProp[];  nRegs ¬ VRegs[];  VPop[];    IF TreeLiteral[son[1]] THEN {      IF TreeLiteralValue[son[1]] # 0 THEN {select ¬ son[2]; son[2] ¬ Tree.Null}      ELSE {select ¬ son[3]; son[3] ¬ Tree.Null};      FreeNode[syms, node];      val ¬ Exp[select, target]}    ELSE {      son[2] ¬ CheckAlt[RValue[son[2], bias, target], DecodeCSei[info]];      attr ¬ VAttr[]; nRegs ¬ MAX[VRegs[], nRegs];  VPop[];      son[3] ¬ CheckAlt[RValue[son[3], bias, target], DecodeCSei[info]];      val ¬ [subtree[index: node]];      attr ¬ MergeAttr[attr];      IF attr.rep = none  THEN	IF target = none THEN {Log.WarningTree[mixedRepresentation, val]; attr.rep ¬ both}	ELSE attr.rep ¬ target;      vStack[vI].attr ¬ attr;      val ¬ [subtree[index: node]]};    vStack[vI].attr.prop ¬ CommonProp[VProp[], prop];    vStack[vI].nRegs ¬ MAX[VRegs[], nRegs];    RETURN};  CaseExp: PROC [node: Tree.Index, target: Repr, caseBias: INTEGER] RETURNS [val: Tree.Link] = {    op: Tree.NodeName = syms.tb[node].name;    type: CSEIndex = DecodeCSei[syms.tb[node].info];    bias: INTEGER = BiasForType[type];    attr: Attr ¬ [prop: voidProp, rep: both+other];    const: BOOLEAN ¬ TRUE;    Selection: TreeOps.Map = {      attr.prop ¬ CommonProp[attr.prop, passPtr.implicitAttr.prop];      v ¬ CheckAlt[RValue[t, bias, target], type];      attr ¬ MergeAttr[attr];  VPop[];      const ¬ const AND StructuredLiteral[v];      RETURN};    val ¬ CaseDriver[node, Selection, caseBias];    IF OpName[syms, val] = op THEN {PushTree[syms, val]; SetAttr[syms, 1, const]; val ¬ PopTree[syms]};    IF attr.rep = none THEN      IF target = none THEN {Log.WarningTree[mixedRepresentation, val]; attr.rep ¬ both}      ELSE attr.rep ¬ target;    VPush[bias, attr, maxRegs];    RETURN};  BindCaseExp: PROC [node: Tree.Index, target: Repr] RETURNS [Tree.Link] = {    BoundExp: PROC [t: Tree.Link, labelBias: INTEGER] RETURNS [Tree.Link] = {      RETURN [CaseExp[GetNode[syms, t], target, labelBias]]};    RETURN [BindCase[node, casex, BoundExp]]};  BindTypeExp: PROC [node: Tree.Index, target: Repr] RETURNS [val: Tree.Link] = {    type: CSEIndex = DecodeCSei[syms.tb[node].info];    bias: INTEGER = BiasForType[type];    attr: Attr ¬ [prop: voidProp, rep: both+other];    const: BOOLEAN ¬ TRUE;    Selection: TreeOps.Map = {      attr.prop ¬ CommonProp[attr.prop, passPtr.implicitAttr.prop];      v ¬ CheckAlt[RValue[t, bias, target], type];      attr ¬ MergeAttr[attr];  VPop[];      const ¬ const AND StructuredLiteral[v];      RETURN};    val ¬ BindType[node, Selection];    IF attr.rep = none THEN      IF target = none THEN {Log.WarningTree[mixedRepresentation, val]; attr.rep ¬ both}      ELSE attr.rep ¬ target;    VPush[bias, attr, maxRegs];    RETURN};  MinMax: PROC [node: Tree.Index, target: Repr] RETURNS [val: Tree.Link] = {    OPEN syms.tb[node];    const: BOOLEAN ¬ TRUE;    zeroTest: BOOLEAN ¬ FALSE;    attr: Attr ¬ [prop: voidProp, rep: both+other];    nRegs: RegCount ¬ 0;    k: RegCount = RegsForType[DecodeCSei[info]];    Item: TreeOps.Map = {      v ¬ RValue[t, 0, target];      IF ~StructuredLiteral[v] THEN const ¬ FALSE      ELSE IF TreeLiteral[v] AND TreeLiteralValue[v] = 0 THEN zeroTest ¬ TRUE;      attr ¬ MergeAttr[attr];      nRegs ¬ MIN[MAX[nRegs, VRegs[]+k], maxRegs];  VPop[];  RETURN};    IF ListLength[syms, son[1]] = 1 THEN {      val ¬ Exp[son[1], target]; son[1] ¬ Tree.Null; FreeNode[syms, node]}    ELSE {      son[1] ¬ UpdateList[syms, son[1], Item];  val ¬ [subtree[index: node]];      IF zeroTest AND CommonRep[attr.rep, unsigned] # none THEN        Log.WarningTree[unsignedCompare, val];      SELECT attr.rep FROM	both => attr.rep ¬ IF target = none THEN both ELSE target;	none =>	  IF target = none THEN {Log.ErrorTree[mixedRepresentation, val]; attr.rep ¬ both}	  ELSE attr.rep ¬ target;  	ENDCASE => NULL;      IF const AND ~attr1 THEN {        val ¬ Fold[node, attr.rep]; attr ¬ FoldedAttr[val, attr.rep]; nRegs ¬ k}      ELSE attr3 ¬ attr.rep # unsigned;      VPush[0, attr, nRegs]};    RETURN};  OptTypeExp: PROC [t: Tree.Link] = {    IF t # Tree.Null THEN TypeExp[t]};      Nil: PROC [node: Tree.Index] RETURNS [Tree.Link] = {    type: CSEIndex = DecodeCSei[syms.tb[node].info];    n: CARDINAL;    d: LiteralOps.ValueDescriptor;    OptTypeExp[syms.tb[node].son[1]];    n ¬ P4.WordsForType[type];    d ¬ DESCRIPTOR[OSMiscOps.Words[n], n];    FOR i: CARDINAL IN [0..n) DO d[i] ¬ 0 ENDLOOP;    PushLit[syms, LiteralOps.FindDescriptor[syms, d]];    IF n > 1 THEN {PushNode[syms, mwconst, 1]; SetInfo[syms, EncodeSei[type]]};    FreeNode[syms, node];  OSMiscOps.FreeWords[BASE[d]];    VPush[BiasForType[type], LiteralAttr[RepForType[type]], RegsForType[type]];    RETURN [ForceType[PopTree[syms], type]]};  Shorten: PROC [node: Tree.Index, target: Repr] RETURNS [val: Tree.Link] = {    OPEN syms.tb[node];    attr: Attr;    nRegs: RegCount;    son[1] ¬ RValue[son[1], 0, IF target=both THEN unsigned ELSE target];      nRegs ¬ VRegs[];  attr ¬ VAttr[];  VPop[];    IF CommonRep[target, unsigned] # none THEN attr.rep ¬ unsigned;    attr1 ¬ checked OR dataPtr.switches['b];    IF CommonRep[attr.rep, unsigned] = none THEN attr3 ¬ TRUE    ELSE {attr3 ¬ FALSE; info ¬ EncodeSei[dataPtr.typeCARDINAL]};    IF ~StructuredLiteral[son[1]] THEN val ¬ [subtree[index: node]]    ELSE {val ¬ LongToShort[node, attr.rep]; attr.rep ¬ LiteralRep[val, attr.rep]};    VPush[0, attr, nRegs];  RETURN};  Loophole: PROC [node: Tree.Index, target: Repr] RETURNS [val: Tree.Link] = {    OPEN syms.tb[node];    type: CSEIndex = DecodeCSei[info];    rep: Repr = IF syms.tb[node].son[2] # Tree.Null OR target = none      THEN RepForType[type]      ELSE target;    son[1] ¬ Exp[son[1], rep];    OptTypeExp[son[2]];    IF P4.WordsForType[OperandType[son[1]]] # P4.WordsForType[type] THEN      Log.ErrorTree[sizeClash, son[1]];    IF RCType[syms, type] # none THEN val ¬ [subtree[index: node]]    ELSE {      val ¬ ForceType[son[1], type];      son[1] ¬ Tree.Null;  FreeNode[syms, node]};    vStack[vI].attr.rep ¬ rep;  RETURN};      UnaryCast: PROC [node: Tree.Index] RETURNS [val: Tree.Link] = {    OPEN syms.tb[node];    IF StructuredLiteral[son[1]] THEN {      val ¬ ForceType[son[1], DecodeCSei[info]]; son[1] ¬ Tree.Null; FreeNode[syms, node]}    ELSE val ¬ [subtree[index: node]];    RETURN};   AdjustBias: PUBLIC PROC [t: Tree.Link, delta: INTEGER] RETURNS [Tree.Link] = {    op: Tree.NodeName;    type: CSEIndex;    IF delta = 0 THEN RETURN [t];    IF t = Tree.Null THEN passPtr.implicitBias ¬ passPtr.implicitBias + delta;    type ¬ OperandType[t];    IF TreeLiteral[t] THEN RETURN [MakeStructuredLiteral[TreeLiteralValue[t]-delta, type]];    IF delta > 0 THEN op ¬ minus ELSE {op ¬ plus; delta ¬ -delta};    PushTree[syms, t];  PushTree[syms, MakeTreeLiteral[delta]];    PushNode[syms, op, 2];  SetInfo[syms, EncodeSei[type]];      SetAttr[syms, 1, FALSE];  SetAttr[syms, 2, FALSE];    RETURN [PopTree[syms]]};  RValue: PUBLIC PROC [exp: Tree.Link, bias: INTEGER, target: Repr]      RETURNS [val: Tree.Link] = {    d: INTEGER;    val ¬ Exp[exp, target];  d ¬ bias - vStack[vI].bias;    IF d # 0 THEN {val ¬ AdjustBias[val, d]; vStack[vI].bias ¬ bias};    RETURN};  Exp: PUBLIC PROC [exp: Tree.Link, target: Repr] RETURNS [val: Tree.Link] = {    attr: Attr;    WITH expr: exp SELECT FROM      symbol => {	sei: ISEIndex = expr.index;	type: CSEIndex;	IF ~syms.seb[sei].mark4 THEN 	  DeclItem[syms, Tree.Link[subtree[index: ToTreeIndex[syms.seb[sei].idValue]]]];	type ¬ UnderType[syms, syms.seb[sei].idType];  attr ¬ [prop: fullProp, rep: RepForType[type]];	IF ~syms.seb[sei].constant THEN {attr.prop.noFreeVar ¬ FALSE; val ¬ expr}	ELSE	  SELECT XferMode[syms, type] FROM	    proc, signal, error, program =>	      <<IF ConstantId[sei] AND ~syms.seb[sei].extended THEN	        val ¬ MakeStructuredLiteral[LOOPHOLE[syms.seb[sei].idValue], type]	      ELSE >> -- let code generators deal with it	      {attr.prop.noFreeVar ¬ FALSE; val ¬ expr};	    ENDCASE =>	      IF syms.seb[sei].extended THEN {		val ¬ IdentityMap[syms, FindExtension[syms, sei].tree];		WITH val SELECT FROM		  subtree => syms.tb[index].info ¬ EncodeSei[type];		  ENDCASE}	      ELSE {		val ¬ MakeStructuredLiteral[LOOPHOLE[syms.seb[sei].idValue], type];		attr ¬ FoldedAttr[val, attr.rep]};	VPush[BiasForType[type], attr, RegsForType[type]]};      literal => {	WITH expr.info SELECT FROM	  word => attr ¬ FoldedAttr[expr, unsigned];	  string => {	    MarkString[local: index # LiteralOps.MasterString[syms, index]];	    attr ¬ LiteralAttr[	      IF index # LiteralOps.MasterString[syms, index] OR dataPtr.switches['o] THEN		unsigned ELSE long+unsigned]};	  ENDCASE => attr ¬ voidAttr;	VPush[0, attr, 1];  val ¬ expr};      subtree =>	IF expr = Tree.Null THEN {	  val ¬ Tree.Null; VPush[passPtr.implicitBias, passPtr.implicitAttr, maxRegs]}	ELSE {	  node: Tree.Index = expr.index;	  SELECT syms.tb[node].name FROM	    dot => {	      OPEN syms.tb[node];	      prop: Prop;	      nRegs: RegCount;	      sei: ISEIndex;	      son[1] ¬ RValue[son[1], 0, unsigned];	      prop ¬ VProp[];  	      prop.noSelect ¬ FALSE; attr.prop.noFreeVar ¬ FALSE;	      nRegs ¬ MAX[RegsForType[DecodeCSei[info]], VRegs[]];  VPop[];	      son[2] ¬ Exp[son[2], target];	      sei ¬ TreeOps.GetSe[syms, son[2]];	      IF syms.seb[sei].constant THEN Log.ErrorSei[noFrameProcs, sei];	      vStack[vI].nRegs ¬ nRegs;	      vStack[vI].attr.prop ¬ CommonProp[vStack[vI].attr.prop, prop];	      attr1 ¬ ~attr3 AND (checked OR dataPtr.switches['n]);	      val ¬ expr};	    dollar => val ¬ Dollar[node];	    cdot => {	      val ¬ Exp[syms.tb[node].son[2], target];	      syms.tb[node].son[2] ¬ Tree.Null;  FreeNode[syms, node]};	    uparrow => {	      OPEN syms.tb[node];	      attr: Attr;	      nRegs: RegCount;	      son[1] ¬ RValue[son[1], 0, unsigned];	      attr ¬ [prop: VProp[], rep: RepForType[DecodeCSei[info]]];  	      attr.prop.noSelect ¬ FALSE; attr.prop.noFreeVar ¬ FALSE;	      nRegs ¬ MAX[RegsForType[DecodeCSei[info]], VRegs[]];  VPop[];	      VPush[BiasForType[DecodeCSei[info]], attr, nRegs];	      attr1 ¬ ~attr3 AND (checked OR dataPtr.switches['n]);	      val ¬ expr};	    callx, portcallx, signalx, errorx, startx, joinx => val ¬ Call[node];	    substx => val ¬ Substx[node];	    index, dindex => val ¬ Index[node];	    seqindex => val ¬ SeqIndex[node];	    reloc => val ¬ Reloc[node];	    construct => val ¬ Construct[node];	    union => val ¬ Union[node];	    rowcons => val ¬ RowConstruct[node];	    all => val ¬ All[node];	    uminus => val ¬ UMinus[node];	    abs => val ¬ Abs[node];	    pred, succ => val ¬ EnumOp[node, target];	    plus, minus => val ¬ AddOp[node, target];	    times => val ¬ Mult[node, target];	    div, mod => val ¬ DivMod[node, target];	    relE, relN, relL, relGE, relG, relLE => val ¬ RelOp[node];	    in, notin => val ¬ In[node];	    not => {	      syms.tb[node].son[1] ¬ BoolValue[syms.tb[node].son[1]];	      IF ~TreeLiteral[syms.tb[node].son[1]] THEN val ¬ expr	      ELSE {		val ¬ IF TreeLiteralValue[syms.tb[node].son[1]] # 0		      THEN passPtr.tFALSE		      ELSE passPtr.tTRUE;		FreeNode[syms, node];  vStack[vI].nRegs ¬ 1}};	    or, and => val ¬ BoolOp[node];	    ifx => val ¬ IfExp[node, target];	    casex => val ¬ CaseExp[node, target, 0];	    bindx => val ¬ IF syms.tb[node].attr3				THEN BindTypeExp[node, target]				ELSE BindCaseExp[node, target];	    assignx => val ¬ Assignment[node];	    extractx => val ¬ Extract[node];	    min, max => val ¬ MinMax[node, target];	    mwconst => {	      VPush[0, 	        FoldedAttr[expr, 		  RepForType[DecodeCSei[syms.tb[node].info]]], 		  RegsForType[DecodeCSei[syms.tb[node].info]]];	      val ¬ expr};	    clit => {	      val ¬ syms.tb[node].son[1]; 	      FreeNode[syms, node]; 	      VPush[0, LiteralAttr[both], 1]};	    llit => {	      IF currentLevel > Symbols.lG THEN		WITH e: syms.tb[node].son[1] SELECT FROM		  literal =>		    WITH e.info SELECT FROM		      string => index ¬ LiteralOps.FindLocalString[syms, index];		      ENDCASE;		  ENDCASE;	      val ¬ Exp[syms.tb[node].son[1], none];	      vStack[vI].attr.prop.noFreeVar ¬ FALSE;	      syms.tb[node].son[1] ¬ Tree.Null;  FreeNode[syms, node]};	    new => val ¬ New[node];	    nil => val ¬ Nil[node];	    create, fork => val ¬ MiscXfer[node];	    syserrorx => {	      VPush[0, [prop: emptyProp, 	        rep: RepForType[DecodeCSei[syms.tb[node].info]]], maxRegs];	      val ¬ expr};	    lengthen => val ¬ Lengthen[node, target];	    shorten => val ¬ Shorten[node, target];	    float => {	      syms.tb[node].son[1] ¬ RValue[syms.tb[node].son[1], 0, signed];	      IF StructuredLiteral[syms.tb[node].son[1]] AND vStack[vI].attr.rep # unsigned THEN		val ¬ IntToReal[node]	      ELSE {val ¬ expr; vStack[vI].nRegs ¬ maxRegs};	      vStack[vI].attr.rep ¬ other};	    safen => {	      syms.tb[node].son[1] ¬ Exp[syms.tb[node].son[1], target]; val ¬ expr};	    loophole => val ¬ Loophole[node, target];	    cast => {	      OPEN syms.tb[node];	      rep: Repr = RepForType[DecodeCSei[info]];	      nw: CARDINAL = P4.WordsForType[DecodeCSei[info]];	      son[1] ¬ Exp[son[1], rep];  vStack[vI].attr.rep ¬ rep;	      SELECT P4.WordsForType[OperandType[son[1]]] FROM	        < nw => name ¬ pad;	        > nw => name  ¬ chop;	        ENDCASE;	      val ¬ expr};	    ord => {	      syms.tb[node].son[1] ¬ Exp[syms.tb[node].son[1], target];	      val ¬ UnaryCast[node]};	    val => {	      OPEN syms.tb[node];	      rep: Repr = RepForType[DecodeCSei[info]];	      subType: CSEIndex = OperandType[son[1]];	      son[1] ¬ CheckRange[	        RValue[son[1], 		  BiasForType[DecodeCSei[info]], rep], 		  P4.CheckOver[Cardinality[syms, DecodeCSei[info]]], subType];	      IF P4.WordsForType[subType] # 	        P4.WordsForType[DecodeCSei[info]] THEN	          Log.ErrorTree[sizeClash, son[1]];	      vStack[vI].attr.rep ¬ rep;	      val ¬ UnaryCast[node]};	    check => {	      OptTypeExp[syms.tb[node].son[2]];	      val ¬ Rhs[syms.tb[node].son[1], DecodeCSei[syms.tb[node].info]];	      vStack[vI].attr.rep ¬ RepForType[DecodeCSei[syms.tb[node].info]];	      syms.tb[node].son[1] ¬ Tree.Null;  FreeNode[syms, node]};	    narrow => val ¬ Narrow[node];	    istype => {	      OPEN syms.tb[node];	      attr: Attr;	      son[1] ¬ RValue[son[1], 0, RepForType[OperandType[son[1]]]];	      attr ¬ [prop: VProp[], rep: both];  VPop[];	      TypeExp[son[2]];	      IF attr2 OR attr3 THEN {val ¬ expr; VPush[0, attr, maxRegs]}	      ELSE {FreeNode[syms, node]; val ¬ passPtr.tTRUE; VPush[0, attr, 1]}};	    openx => {	      OPEN syms.tb[node];	      type: CSEIndex = OperandType[son[1]];	      prop: Prop ¬ voidProp;	      IF attr1 THEN {prop.noFreeVar ¬ FALSE; val ¬ son[1]}	      ELSE {		son[1] ¬ RValue[son[1], 0, none]; prop ¬ VProp[]; VPop[];		IF Shared[syms, son[1]] THEN	-- must generate an unshared node		  son[1] ¬ ForceType[son[1], type];		SetShared[syms, son[1], TRUE];  attr1 ¬ TRUE;		val ¬ expr};	      VPush[0, [prop: prop, rep: other], RegsForType[type]]};	    stringinit => {	      attr: Attr;	      MarkString[];	      syms.tb[node].son[2] ¬ P4.Rhs[syms.tb[node].son[2], dataPtr.typeCARDINAL];  	      attr ¬ [prop: VProp[], rep: unsigned];  VPop[];  attr.prop.noFreeVar ¬ FALSE;	      VPush[0, attr, maxRegs];  val ¬ expr};	    size, first, last, typecode => val ¬ TypeOp[node];	    apply => {VPush[0, voidAttr, 0]; val ¬ expr};	    ENDCASE => val ¬ AddrOp[node]};      ENDCASE => ERROR;    RETURN};  }.
-- Copyright (C) 1980, 1983, 1984, 1986  by Xerox Corporation. All rights reserved. -- Final.mesa, modified by--   Sweet		18-Apr-84 10:29:04--   Satterthwaite	December 5, 1980  12:46 PM --   Russ Atkinson (RRA), 30-Oct-80 12:24:40 added CCNull checking--   Johnsson		12-Jun-83 12:49:18--   MEW		13-Jun-86 14:30:48DIRECTORY  Alloc USING [Base, Notifier],  Code USING [bodyRecurLabel, initialLabel, CodePassInconsistency, codeptr, tailJumpOK],  CodeDefs USING [    CCIndex, CCInfoType, CCNull, codeType, JumpCCIndex, JumpCCNull,     LabelCCIndex, LabelCCNull, RelativePC, TableCodeBytes],  ComData USING [bodyIndex, switches],  FOpCodes USING [qADD, qDIS, qLI, qLL, qRET, qSELFC, qSFC],  OpTableDefs USING [InstLength],  P5 USING [C0, C1, PeepHole],  P5F USING [BindJumpDStar, CodeJumpDStar, CPass5, FillInPCEstimatesDStar],  P5U USING [DeleteCell, OutJump, OutLocalCall],  PeepholeDefs USING [    CJump, NextInteresting, PrevInteresting, RemoveThisPop, SetRealInst],  PrincOps USING [framelink],  Symbols USING [Base, BTIndex, CBTIndex],  SymbolSegment USING [bodyType],  Table USING [Base];Final: PROGRAM    IMPORTS CPtr: Code, MPtr: ComData, OpTableDefs, P5U, P5, P5F, PeepholeDefs     EXPORTS CodeDefs, P5, P5F =  BEGIN  OPEN PeepholeDefs, CodeDefs;  cb: Table.Base;		-- code base (local copy)  bb: Symbols.Base;  FinalNotify: PUBLIC Alloc.Notifier =    BEGIN  -- called by allocator whenever table area is repacked    cb ¬ base[codeType];    bb ¬ base[SymbolSegment.bodyType];    END;  DidSomething: PUBLIC BOOLEAN;  StartIndex, EndIndex: PUBLIC CCIndex;  SeenSwitch: BOOLEAN;  JumpCellCount: CARDINAL;    ccInfo: PUBLIC CCInfoType ¬ generating;  CCInfoMeaning: PUBLIC PROCEDURE RETURNS [CCInfoType] =    BEGIN    RETURN[ccInfo]    END;  Fixup: PUBLIC PROCEDURE [start: CCIndex, ownEntry: CARDINAL] =    BEGIN -- a final pass over the code to fix up jumps    jumpsbefore, jumpsafter, totalJumps: CARDINAL;    crossJump: BOOLEAN ¬ MPtr.switches['j];    ccInfo ¬ generating;    DidSomething ¬ TRUE;    SeenSwitch ¬ TRUE;    StartIndex ¬ start;    PeepholeDefs.SetRealInst[FALSE];    TailJump[crossJump AND CPtr.tailJumpOK];    CPtr.bodyRecurLabel ¬ LabelCCNull;	-- avoid dangling ref if deleted    DO      -- pass 0: distinguish forward and backward jumps      CPass0[];      IF ~DidSomething THEN EXIT;      DidSomething ¬ FALSE;      SeenSwitch ¬ ~SeenSwitch;      -- pass 1: eliminate multiple labels      CPass1[];      -- pass 2: eliminate jump to jumps      CPass2[];      -- pass 3: eliminate unreachable code      CPass3[];      -- pass 4: replace cj-j seq. with ccj      CPass4[];      -- pass 5: cross jumping      IF crossJump THEN P5F.CPass5[];      ENDLOOP; -- end of the meta-pass consisting of passes 0-5    -- pass 6: do some peephole optimization: load-store, EXCH-commutative op.    P5.PeepHole[StartIndex];    -- jump threads are now pc's, debug output take note    ccInfo ¬ binding;    -- pass 7: set length and alignment, count jumps    totalJumps ¬ jumpsafter ¬ CPass7[];    jumpsbefore ¬ jumpsafter+1;    -- pass 8: resolve (most) jump instructions    THROUGH [1..3] WHILE jumpsafter # 0 AND jumpsafter < jumpsbefore DO      jumpsbefore ¬ jumpsafter;      jumpsafter ¬ CPass8[];      ENDLOOP;    -- pass 9: resolve (remaining) jump instructions    IF jumpsafter # 0 THEN CPass9[];    -- pass 10: code jumps    ccInfo ¬ coding;    IF totalJumps # 0 THEN CPass10[];    -- pass 11: Remove extra source chunks    CPass11[];    RETURN    END;  TailJump: PROC [jumpOK: BOOLEAN] =    BEGIN  -- remove simple tail recursion    enableLevel: CARDINAL ¬ 0;    next: CCIndex;    FOR c: CCIndex ¬ cb[StartIndex].flink, next WHILE c # CCNull DO      next ¬ cb[c].flink;      WITH cc: cb[c] SELECT FROM	code =>	  IF ~cc.realinst AND cc.inst = FOpCodes.qSELFC THEN {	    CPtr.codeptr ¬ cb[c].blink;	    IF jumpOK AND enableLevel = 0 AND UCreturn[next] THEN	      BEGIN	      P5U.OutJump[Jump, CPtr.bodyRecurLabel];	      P5U.DeleteCell[c]	      END	    ELSE	      BEGIN	      bti: Symbols.CBTIndex = MPtr.bodyIndex;	      WITH bb[bti] SELECT FROM	        Outer => {		  P5U.OutLocalCall[CPtr.initialLabel[entryIndex]]; 		  P5U.DeleteCell[c]};		Inner => {		  P5.C1[FOpCodes.qLL, PrincOps.framelink];		  P5.C1[FOpCodes.qLI, frameOffset];		  P5.C0[FOpCodes.qADD];		  P5.C1[FOpCodes.qLI, 0];		  P5.C0[FOpCodes.qSFC];		  P5U.DeleteCell[c]};		ENDCASE => ERROR;	      END};	other => WITH oc: cc SELECT FROM	  markbody => {	    index: Symbols.BTIndex = oc.index;	    WITH bb[index] SELECT FROM 	      Callable => jumpOK ¬ FALSE; -- hereafter in catch code.	      ENDCASE};	  markEnable => 	    IF oc.start THEN enableLevel ¬ enableLevel + 1	    ELSE enableLevel¬ enableLevel - 1;	  ENDCASE;	ENDCASE;      ENDLOOP;    END;  UCreturn: PROC [start: CCIndex] RETURNS [BOOLEAN] =    BEGIN  -- find (unconditional) path to RET    next: CCIndex;    FOR c: CCIndex ¬ start, next WHILE c # CCNull DO      WITH cc: cb[c] SELECT FROM	code => RETURN [~cc.realinst AND cc.inst = FOpCodes.qRET];	label => next ¬ cc.flink;	jump =>	  BEGIN	  IF ~UCjump[c] THEN EXIT;	  next ¬ cc.destlabel;	  END;	other => WITH cc SELECT FROM	  table, localCall, markEnable => EXIT;	  ENDCASE => next ¬ cc.flink;	ENDCASE => EXIT;      ENDLOOP;    RETURN [FALSE]    END;  CPass0: PROCEDURE =    BEGIN  -- pass 0: distinguish forward and backward jumps    c: CCIndex;    JumpCellCount ¬ 0;    FOR c ¬ cb[StartIndex].flink, cb[c].flink WHILE c # CCNull DO      EndIndex ¬ c;      WITH cb[c] SELECT FROM	label => labelseen ¬ SeenSwitch;	jump =>	  BEGIN	  forward ¬	    IF destlabel = LabelCCNull THEN TRUE	    ELSE ~(cb[destlabel].labelseen = SeenSwitch);	  JumpCellCount ¬ JumpCellCount + 1;	  END;	ENDCASE;      ENDLOOP;    RETURN    END;  CPass1: PROCEDURE =    BEGIN   -- pass 1: eliminate multiple labels, unreferenced labels,	    --         and jumps to .+1    nextc, c: CCIndex;    FOR c ¬ cb[StartIndex].flink, nextc WHILE c # CCNull DO      nextc ¬ NextInteresting[c];      WITH cc:cb[c] SELECT FROM	jump =>	  IF DotPlusOneJump[LOOPHOLE[c]] AND 	    (UCjump[c] OR cc.jtype IN [JumpE..UJumpLE]) THEN	    DeleteJump[LOOPHOLE[c]];	label =>	  IF cc.jumplist = JumpCCNull AND ~cc.catch AND ~cc.offsetLoaded THEN	    BEGIN	    unreferencedlabel: LabelCCIndex ¬ LOOPHOLE[c, LabelCCIndex];	    DidSomething ¬ TRUE; P5U.DeleteCell[unreferencedlabel];	    END	  ELSE 	    BEGIN	    duplabel: LabelCCIndex ¬ LOOPHOLE[c, LabelCCIndex];	    IF nextc = CCNull THEN RETURN;	    WITH cb[nextc] SELECT FROM	      label => IF ~cb[duplabel].procEntry THEN 		BEGIN		DeleteLabel[duplabel, LOOPHOLE[nextc, LabelCCIndex]];		DidSomething ¬ TRUE;		END;	      ENDCASE;	    END;	ENDCASE;      ENDLOOP;   RETURN   END;  DotPlusOneJump: PROCEDURE [jc: JumpCCIndex] RETURNS [BOOLEAN] =    BEGIN    c: CCIndex;    target: CCIndex ¬ cb[jc].destlabel;    c ¬ NextInteresting[jc];    IF c = CCNull THEN RETURN [FALSE]; -- RRA fix    WITH cb[c] SELECT FROM      label => RETURN [c = target];      ENDCASE => RETURN[FALSE];    END;  DeleteJump: PROC [jc: JumpCCIndex] =    BEGIN    IF cb[jc].jtype IN [JumpE..UJumpLE] THEN      THROUGH [0..2) DO	CPtr.codeptr ¬ cb[jc].blink;	P5.C0[FOpCodes.qDIS];	[] ¬ PeepholeDefs.RemoveThisPop[CPtr.codeptr];	ENDLOOP;    UnthreadJump[jc];    DidSomething ¬ TRUE; P5U.DeleteCell[jc];    END;  CPass2: PROCEDURE =    BEGIN   -- pass 2: eliminate jump to jumps    c, cc: CCIndex;    jc: JumpCCIndex;    jtojexists: BOOLEAN;    jclabel: LabelCCIndex;    jccount: CARDINAL;    FOR c ¬ cb[StartIndex].flink, cb[c].flink WHILE c # CCNull DO      WITH jj: cb[c] SELECT FROM	jump =>	  IF jj.destlabel # LabelCCNull THEN	    BEGIN	    jtojexists ¬ FALSE;	    jccount ¬ 0;	    jc ¬ LOOPHOLE[c, JumpCCIndex];	    DO	      jclabel ¬ cb[jc].destlabel;	      IF (cc ¬ NextInteresting[jclabel]) = CCNull THEN EXIT;	      IF ~UCjump[cc] THEN EXIT;	      jc ¬ LOOPHOLE[cc, JumpCCIndex];	      IF jc = c THEN BEGIN jtojexists ¬ FALSE; EXIT END;	      jccount ¬ jccount +1;	      IF jccount > JumpCellCount THEN		BEGIN jtojexists ¬ FALSE; EXIT END;	      jtojexists ¬ TRUE;	      ENDLOOP;	    IF jtojexists THEN	      BEGIN	      DidSomething ¬ TRUE;	      UnthreadJump[LOOPHOLE[c, JumpCCIndex]];	      jj.thread ¬ cb[jclabel].jumplist;	      cb[jclabel].jumplist ¬ LOOPHOLE[c, JumpCCIndex];	      jj.destlabel ¬ jclabel;	      IF jj.jtype = JumpLIO OR jj.jtype = JumpDESC THEN 	        cb[jclabel].offsetLoaded ¬ TRUE;	      END;	    END;	ENDCASE      ENDLOOP;    RETURN    END;  CPass3: PROCEDURE =    BEGIN   -- pass 3: eliminate unreachable code    c, cc, oldc: CCIndex;    FOR c ¬ cb[StartIndex].flink, cb[c].flink WHILE c # CCNull DO      WITH cb[c] SELECT FROM	jump =>	  IF UCjump[c] OR jtype = JumpRet OR jtype = JumpCA THEN	    BEGIN	    cc ¬ flink;	    DO	      IF (oldc ¬ cc) = CCNull THEN RETURN;	      cc ¬ cb[cc].flink;	      WITH cb[oldc] SELECT FROM		label => IF jumplist # JumpCCNull OR catch THEN EXIT;		jump => UnthreadJump[LOOPHOLE[oldc, JumpCCIndex]];		other => SELECT otag FROM		  table, localCall => NULL;		  ENDCASE => LOOP; --body start/stop, source		ENDCASE;	      P5U.DeleteCell[oldc];	      DidSomething ¬ TRUE;	      ENDLOOP;	    END;	ENDCASE;      ENDLOOP;    RETURN    END;  CPass4: PROCEDURE =    BEGIN   -- pass 4: replace cj-j seq. with ccj    c, nextc: CCIndex;    FOR c ¬ cb[StartIndex].flink, nextc WHILE c # CCNull DO      WITH oldc:cb[c] SELECT FROM	jump =>	  BEGIN	  nextc ¬ IF MPtr.switches['j] THEN NextInteresting[c]	    ELSE cb[c].flink; -- don't ignore source chunks here	  IF oldc.jtype IN [JumpE..ZJumpN] THEN	    BEGIN	    IF nextc = CCNull THEN RETURN;	    WITH nc:cb[nextc] SELECT FROM	      jump =>	        IF UCjump[nextc] THEN  --it's hard to imagine a situation where nextc is not		                           --an unconditional jump.		  IF oldc.destlabel = nc.destlabel AND		    (UCjump[c] OR oldc.jtype IN [JumpE..UJumpLE]) THEN		    DeleteJump[LOOPHOLE[c]]		  ELSE IF (PrevInteresting[oldc.destlabel] = nextc) THEN		    BEGIN		      newLbl: LabelCCIndex = nc.destlabel;		      nxt: CCIndex;		      UnthreadJump[LOOPHOLE[nextc, JumpCCIndex]];		      UnthreadJump[LOOPHOLE[c, JumpCCIndex]];		      oldc.destlabel ¬ newLbl;		      oldc.thread ¬ cb[newLbl].jumplist;		      cb[newLbl].jumplist ¬ LOOPHOLE[c, JumpCCIndex];		      oldc.jtype ¬ CJump[oldc.jtype];		      oldc.forward ¬ nc.forward;		      nxt ¬ nc.flink;		      P5U.DeleteCell[nextc];		      nextc ¬ nxt;		    END;	      ENDCASE;	    END;	  END;	ENDCASE => nextc ¬ cb[c].flink;      ENDLOOP;    RETURN    END;  CPass7: PROCEDURE RETURNS [unboundJumps: CARDINAL] =    BEGIN -- pass 7: set length, count jumps    c, next: CCIndex;    -- look for body starting with a loop    IF ~MPtr.switches['j] THEN      BEGIN      c ¬ NextInteresting[cb[StartIndex].flink];      IF c # CCNull THEN  -- RRA fix        WITH cb[c] SELECT FROM	 label => IF jumplist # JumpCCNull THEN	  BEGIN	  CPtr.codeptr ¬ cb[c].blink;	  P5U.OutJump[Jump, LOOPHOLE[c]];	  cb[LOOPHOLE[CPtr.codeptr, JumpCCIndex]].forward ¬ TRUE;	  END;	ENDCASE;      END;    unboundJumps ¬ 0;    FOR c ¬ cb[StartIndex].flink, next WHILE c # CCNull DO      next ¬ cb[c].flink;      WITH cb[c] SELECT FROM	code => IF isize = 0 THEN isize ¬ OpTableDefs.InstLength[inst];	jump =>	  IF jtype = JumpRet THEN P5U.DeleteCell[c]	  ELSE unboundJumps ¬ unboundJumps+1;	ENDCASE;      ENDLOOP;    END;  CPass8: PROCEDURE RETURNS [unboundJumps: CARDINAL] =    BEGIN -- pass 8: resolve easy jumps    c: CCIndex;    min, max: CARDINAL;    unboundJumps ¬ 0;    P5F.FillInPCEstimatesDStar[];    FOR c ¬ cb[StartIndex].flink, cb[c].flink WHILE c # CCNull DO      WITH cb[c] SELECT FROM	jump => IF ~fixedup THEN	  BEGIN	  target: LabelCCIndex ¬ destlabel;	  IF forward THEN 	    BEGIN 	    min ¬ cb[target].minPC - minPC;	    max ¬ cb[target].maxPC - maxPC;	    END	  ELSE	    BEGIN 	    min ¬ minPC - cb[target].minPC;	    max ¬ maxPC - cb[target].maxPC;	    END;	  IF ~P5F.BindJumpDStar[min, max, LOOPHOLE[c, JumpCCIndex]]	      THEN unboundJumps ¬ unboundJumps+1;	  END;	ENDCASE;      ENDLOOP;    END;  CPass9: PROCEDURE =    BEGIN   -- pass 9: resolve (remaining) jump instructions    c: CCIndex;    nbytes: CARDINAL;    P5F.FillInPCEstimatesDStar[];    FOR c ¬ cb[StartIndex].flink, cb[c].flink WHILE c # CCNull DO      WITH cc: cb[c] SELECT FROM	jump =>	  IF ~cc.fixedup THEN	      BEGIN	      IF cc.forward THEN 	        BEGIN		nbytes ¬ cb[cc.destlabel].maxPC - cc.maxPC;	        END	      ELSE	        BEGIN 	        nbytes ¬ cc.maxPC - cb[cc.destlabel].maxPC;	        END;	      [] ¬ P5F.BindJumpDStar[nbytes, nbytes, LOOPHOLE[c, JumpCCIndex]];	      END;	ENDCASE;      ENDLOOP;    RETURN    END;  CPass10: PROCEDURE =    BEGIN   -- pass 10: code jumps    c: CCIndex;    FillInPC[];    FOR c ¬ cb[StartIndex].flink, cb[c].flink WHILE c # CCNull DO      WITH cb[c] SELECT FROM	jump =>	  BEGIN	  IF ~fixedup THEN SIGNAL CPtr.CodePassInconsistency 	  ELSE P5F.CodeJumpDStar[(IF forward THEN cb[destlabel].pc - pc	    ELSE pc - cb[destlabel].pc), LOOPHOLE[c, JumpCCIndex]];	  END;	ENDCASE;      ENDLOOP;    RETURN    END;  DeleteLabel: PROCEDURE [oldc, c: LabelCCIndex] =    BEGIN -- removes extra label from code stream    lq, q: JumpCCIndex;    IF cb[c].jumplist = JumpCCNull THEN cb[c].jumplist ¬ cb[oldc].jumplist    ELSE      BEGIN      q ¬ cb[c].jumplist;      UNTIL q = JumpCCNull DO	lq ¬ q;	q ¬ cb[q].thread;	ENDLOOP;      cb[lq].thread ¬ cb[oldc].jumplist;      END;    FOR q ¬ cb[oldc].jumplist, cb[q].thread UNTIL q = JumpCCNull      DO cb[q].destlabel ¬ c ENDLOOP;    IF cb[oldc].offsetLoaded THEN cb[c].offsetLoaded ¬ TRUE;    P5U.DeleteCell[oldc];    RETURN    END;  UnthreadJump: PUBLIC PROCEDURE [c: JumpCCIndex] =    BEGIN -- pull jump cell out of thread from label    l: LabelCCIndex ¬ cb[c].destlabel;    jc: JumpCCIndex;    IF l = LabelCCNull THEN RETURN;    jc ¬ cb[l].jumplist;    IF jc = c THEN cb[l].jumplist ¬ cb[jc].thread    ELSE      BEGIN      UNTIL cb[jc].thread = c DO jc ¬ cb[jc].thread ENDLOOP;      cb[jc].thread ¬ cb[c].thread;      END;    RETURN    END;  UCjump: PUBLIC PROCEDURE [c: CCIndex] RETURNS [BOOLEAN] =    BEGIN -- predicate testing if c is an unconditonal jump    WITH cb[c] SELECT FROM      jump => RETURN[jtype = Jump];      ENDCASE =>  RETURN[FALSE]    END;  Removeablejump: PROCEDURE [c: CCIndex] RETURNS [BOOLEAN] =    BEGIN -- predicate testing if c is an unconditonal jump    WITH cb[c] SELECT FROM      jump => RETURN[(jtype = Jump OR jtype = JumpA OR jtype = JumpCA)];      ENDCASE =>  RETURN[FALSE]    END;  FillInPC: PROCEDURE =    BEGIN -- fills in relative PC of all labels and jumps.    -- all jump lengths have been resolved and pad values set    -- PC of forward jump is end of instruction    -- PC of backward jump is start of pad (if any)    k: CCIndex;    rpc: RelativePC;    nbytes: CARDINAL;    rpc ¬ 0;    FOR k ¬ StartIndex, cb[k].flink UNTIL k = CCNull DO      nbytes ¬ (WITH cc:cb[k] SELECT FROM	code => cc.isize,	jump => IF cc.completed THEN 0 ELSE cc.jsize,	other => (WITH cc SELECT FROM	  table => TableCodeBytes,	  localCall => 3,	  ENDCASE => 0),	ENDCASE => 0);      WITH cc:cb[k] SELECT FROM	jump => 	  IF cc.forward THEN BEGIN rpc ¬ rpc+nbytes; cc.pc ¬ rpc; LOOP END	  ELSE BEGIN cc.pc ¬ rpc; END;	label => cc.pc ¬ rpc;	ENDCASE;      rpc ¬ rpc+nbytes;      ENDLOOP;    RETURN    END;  CPass11: PROCEDURE =    BEGIN  -- pass 11: Remove extra source chunks    c: CCIndex;    prev: CCIndex ¬ CCNull;    FOR c ¬ cb[StartIndex].flink, cb[c].flink WHILE c # CCNull DO      WITH cc: cb[c] SELECT FROM	code => prev ¬ CCNull;	jump => SELECT cc.jtype FROM	  JumpLIO, JumpDESC => prev ¬ CCNull;	  ENDCASE;	other => WITH cc SELECT FROM	  table, localCall => prev ¬ CCNull;	  source => {	    IF prev # CCNull THEN P5U.DeleteCell[prev];	    prev ¬ c};	  ENDCASE;	ENDCASE;      ENDLOOP;    RETURN    END;  END...
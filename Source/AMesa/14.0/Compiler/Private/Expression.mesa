-- Copyright (C) 1983, 1986  by Xerox Corporation. All rights reserved. -- Expression.mesa--   Sweet,		 5-Dec-83 15:26:49--   Satterthwaite,	November 24, 1980  3:27 PM--   Johnsson,		12-Jun-83 12:46:33--   Wagner		22-Aug-86 10:42:42DIRECTORY  Alloc USING [Notifier],  Code USING [caseCVState, CodeNotImplemented, mwCaseCV, tailJumpOK, xtracting, xtractlex],  CodeDefs USING [BYTE, codeType, Lexeme, NullLex, StoreOptions, VarComponent, VarIndex, wordlength],  ComData USING [bodyIndex, ownSymbols, switches],  FOpCodes USING [    qADD, qAND, qBNDCK, qDADD, qDDIV, qUDIV, qDMOD, qDMUL,     qDSUB, qDUDIV, qDUMOD, qEXDIS, qFADD, qFDIV, qFLOAT, qFMUL, qFF, qFSUB,    qMUL, qNEG, qDIS, qREC, qSDIV, qSUB],  Inline USING [BITAND, BITSHIFT, LongNumber],  LiteralOps USING [Value],  Literals USING [LTIndex],  CLog USING [Warning],  OpCodeParams USING [GlobalHB, LocalHB],  P5 USING [    All, CaseStmtExp, Construct, ConstructExp, FlowExp,    GenTempLex, LogHeapFree, MoveToCodeWord, New, P5Error,    RowCons, TTAssign, WriteCodeWord],  P5L USING [    AddrForVar, AdjustComponent, ComponentForLex, ComponentForSE, CopyLex,     CopyToTemp, FieldOfVarOnly, GenVarItem, LoadBoth, LoadComponent, LoadVar,    MakeComponent, OVarItem, TOSComponent, TOSLex, VarAlignment, VarForLex,    Words],  P5S USING [    AssignExp, BodyInit, CallExp, Create, DIndex, ErrExp, ExtractExp, ForkExp, Index,    JoinExp, NarrowExp, SeqIndex, SigExp, StartExp, StringInit, SubstExp, SysErrExp],  P5U USING [    OperandType, Out0, PushLitVal, RecordConstant, TreeLiteral,         TreeLiteralValue, WordsForOperand, WordsForSei],  Stack USING [Dump, RoomFor],  SymbolOps USING [FnField, NormalType, UnderType, WordsForType],  Symbols USING [    Base, BitAddress, CBTIndex, CBTNull, ContextLevel,     CSEIndex, ISEIndex, lZ, RecordSEIndex],  SymbolTable USING [Handle],  Tree USING [Index, Link, Null],  TreeOps USING [DecodeCard, DecodeCSei, DecodeSei, GetNode, GetSe, OpName];Expression: PROGRAM    IMPORTS CPtr: Code, MPtr: ComData,      Inline, CLog, LiteralOps, P5, P5L, P5S, P5U, Stack, SymbolOps, TreeOps     EXPORTS CodeDefs, P5 =  BEGIN  OPEN FOpCodes, CodeDefs;  -- imported definitions  LocalHB: TYPE = OpCodeParams.LocalHB;  GlobalHB: TYPE = OpCodeParams.GlobalHB;  ExprOptions: CodeDefs.StoreOptions = [expr: TRUE, init: TRUE];  BitAddress: TYPE = Symbols.BitAddress;  CBTIndex: TYPE = Symbols.CBTIndex;  CBTNull: CBTIndex = Symbols.CBTNull;  ContextLevel: TYPE = Symbols.ContextLevel;  CSEIndex: TYPE = Symbols.CSEIndex;  RecordSEIndex: TYPE = Symbols.RecordSEIndex;  ISEIndex: TYPE = Symbols.ISEIndex;  lZ: ContextLevel = Symbols.lZ;  LTIndex: TYPE = Literals.LTIndex;  syms: SymbolTable.Handle ¬ NIL;  cb: Symbols.Base;		-- code base (local copy)  ExpressionNotify: PUBLIC Alloc.Notifier =    BEGIN  -- called by allocator whenever table area is repacked    syms ¬ MPtr.ownSymbols;    cb ¬ base[codeType];    END;    CheckOver: PROC [lc: LONG CARDINAL] RETURNS [CARDINAL] = INLINE {    RETURN[IF lc > LAST[CARDINAL] THEN ERROR ELSE CARDINAL[lc]] };  recentExp: PUBLIC Tree.Link; -- for debugging  Exp: PUBLIC PROC [t: Tree.Link] RETURNS [l: Lexeme] =    BEGIN -- generates code for an expression    node: Tree.Index;    WITH e: t SELECT FROM      literal =>	WITH e.info SELECT FROM	  word => RETURN [Lexeme[literal[word[index]]]];	  string => RETURN [Lexeme[literal[string[index]]]];	  ENDCASE;      symbol => RETURN [Lexeme[se[e.index]]];      subtree =>	BEGIN	recentExp ¬ t;	IF e = Tree.Null THEN	  IF CPtr.xtracting THEN RETURN [CPtr.xtractlex]	  ELSE	    BEGIN	    SELECT CPtr.caseCVState FROM	      single => P5U.Out0[qREC];	      singleLoaded => CPtr.caseCVState ¬ single;	      multi => RETURN [P5L.CopyLex[CPtr.mwCaseCV]];	      ENDCASE => ERROR;	    RETURN [P5L.TOSLex[1]];	    END;	node ¬ e.index;	SELECT syms.tb[node].name FROM	  casex => l ¬ P5.CaseStmtExp[node, TRUE];	  assignx => l ¬ P5S.AssignExp[node];	  extractx => l ¬ P5S.ExtractExp[node];	  plus => l ¬ Plus[node];	  minus => l ¬ Minus[node];	  div => l ¬ Div[node];	  mod => l ¬ Mod[node];	  times => l ¬ Times[node];	  dot, uparrow => l ¬ DotOrUparrow[node];	  reloc => l ¬ Reloc[node];	  dollar => l ¬ Dollar[node];	  uminus => l ¬ UMinus[node];	  addr => l ¬ Addr[node];	  index => l ¬ P5S.Index[node];	  dindex => l ¬ P5S.DIndex[node];	  construct => l ¬ P5.ConstructExp[Tree.Null, node, ExprOptions];	  arraydesc => l ¬ ArrayDesc[node];	  length => l ¬ Length[node];	  base => l ¬ Base[node];	  body => l ¬ P5S.BodyInit[node];	  rowcons => l ¬ P5.RowCons[Tree.Null, node, ExprOptions];	  stringinit => l ¬ P5S.StringInit[node];	  pad => 	    BEGIN	    psei: CSEIndex = TreeOps.DecodeCSei[syms.tb[node].info];	    tlex: se Lexeme = P5.GenTempLex[CheckOver[SymbolOps.WordsForType[syms, psei]]];	    P5.TTAssign[[symbol[tlex.lexsei]], t];	    l ¬ tlex;	    END;	  mergecons =>	    BEGIN	    psei: CSEIndex = TreeOps.DecodeCSei[syms.tb[node].info];	    tlex: se Lexeme = P5.GenTempLex[CheckOver[SymbolOps.WordsForType[syms, psei]]];	    P5.TTAssign[[symbol[tlex.lexsei]], syms.tb[node].son[1]];	    WITH syms.tb[node].son[2] SELECT FROM	      subtree =>		BEGIN		node2: Tree.Index = index;		SELECT syms.tb[node2].name FROM		  construct => P5.Construct[[symbol[tlex.lexsei]], node2, ExprOptions];		  rowcons => [] ¬ P5.RowCons[[symbol[tlex.lexsei]], node2, ExprOptions];		  ENDCASE => ERROR;		END;	      ENDCASE => ERROR;	    l ¬ tlex;	    END;	  cast, safen, textlit, ord, val => l ¬ Exp[syms.tb[node].son[1]];	  seqindex => l ¬ P5S.SeqIndex[node];	  item => l ¬ Exp[syms.tb[node].son[2]];	  callx, portcallx => l ¬ P5S.CallExp[node];	  substx => l ¬ P5S.SubstExp[node];	  signalx => l ¬ P5S.SigExp[node];	  errorx => l ¬ P5S.ErrExp[node];	  syserrorx => l ¬ P5S.SysErrExp[node];	  startx => l ¬ P5S.StartExp[node];	  new => l ¬ P5.New[node];	  create => l ¬ P5S.Create[node];	  mwconst => l ¬ MwConst[node];	  signalinit => l ¬ SignalInit[node];	  fork => l ¬ P5S.ForkExp[node];	  joinx => l ¬ P5S.JoinExp[node];	  float => l ¬ Float[node];	  narrow => l ¬ P5S.NarrowExp[node];          check =>	    BEGIN	    PushRhs[syms, syms.tb[node].son[1]];  PushRhs[syms, syms.tb[node].son[2]];	    P5U.Out0[FOpCodes.qBNDCK];	    l ¬ P5L.TOSLex[1];	    END;	  chop =>	    BEGIN	    len: CARDINAL = P5U.WordsForSei[TreeOps.DecodeSei[syms.tb[node].info]];	    r: VarIndex = P5L.VarForLex[Exp[syms.tb[node].son[1]]];	    P5L.FieldOfVarOnly[r: r, wSize: len];	    l ¬ [bdo[r]];	    END;	  all => l ¬ P5.All[Tree.Null, node, ExprOptions];	  ENDCASE => l ¬ P5.FlowExp[node];	END;      ENDCASE;    RETURN    END;  ConstOperand: PROC [t: Tree.Link] RETURNS [BOOLEAN, INTEGER] =    BEGIN -- if t is a literal node, return [TRUE,val(t)]    IF P5U.TreeLiteral[t] THEN      RETURN [TRUE, P5U.TreeLiteralValue[t]]    ELSE RETURN [FALSE, 0]    END;  Plus: PROC [node: Tree.Index] RETURNS [Lexeme] =    BEGIN -- generate code for +    op: BYTE;    nw: [1..2];    op1, op2: VarComponent;    t1: Tree.Link ¬ syms.tb[node].son[1];    t2: Tree.Link ¬ syms.tb[node].son[2];    IF SmallConst[t1].yes THEN {tt: Tree.Link = t1; t1 ¬ t2; t2 ¬ tt};    SELECT TRUE FROM      syms.tb[node].attr1 => {IF ~MPtr.switches['f] THEN Stack.Dump[]; nw ¬ 2; op ¬ qFADD};      syms.tb[node].attr2 => {nw ¬ 2; op ¬ qDADD};      ENDCASE => {nw ¬ 1; op ¬ qADD};    op1 ¬ P5L.ComponentForLex[Exp[t1]];    op2 ¬ P5L.ComponentForLex[Exp[t2]];    P5L.LoadBoth[@op1, @op2, TRUE];    P5U.Out0[op];    RETURN [P5L.TOSLex[nw]]    END;  Minus: PROC [node: Tree.Index] RETURNS [Lexeme] =    BEGIN -- generate code for (binary) -    op: BYTE;    nw: [1..2];    SELECT TRUE FROM      syms.tb[node].attr1 =>	{IF ~MPtr.switches['f] THEN Stack.Dump[]; nw ¬ 2; op ¬ qFSUB};      syms.tb[node].attr2 => {nw ¬ 2; op ¬ qDSUB};      ENDCASE => {nw ¬ 1; op ¬ qSUB};    IF ~Stack.RoomFor[2*nw] THEN {      Stack.Dump[];      IF MPtr.switches['l] THEN CLog.Warning[awfulCode]};    PushRhs[syms, syms.tb[node].son[1]];    PushRhs[syms, syms.tb[node].son[2]];    P5U.Out0[op];    RETURN [P5L.TOSLex[nw]]    END;  UMinus: PROC [node: Tree.Index] RETURNS [Lexeme] =    BEGIN -- generate code for (unary) -    tt: Tree.Link = syms.tb[node].son[1];    real: BOOLEAN = syms.tb[node].attr1;    nw: [1..2] =  IF real OR syms.tb[node].attr2 THEN 2 ELSE 1;    IF TreeOps.OpName[syms, tt] = uminus THEN      BEGIN      subNode: Tree.Index = TreeOps.GetNode[syms, tt];      PushRhs[syms, syms.tb[subNode].son[1]];      END    ELSE      BEGIN      IF nw = 2 THEN	BEGIN	IF  real AND ~MPtr.switches['f] THEN Stack.Dump[]; 	P5U.PushLitVal[0]; P5U.PushLitVal[0];	END;      PushRhs[syms, tt];      P5U.Out0[IF nw = 2 THEN (IF real THEN qFSUB ELSE qDSUB) ELSE qNEG];      END;    RETURN [P5L.TOSLex[nw]]    END;  Times: PROC [node: Tree.Index] RETURNS [Lexeme] =    BEGIN -- generates code for *    op: BYTE;    nw: [1..2];    t1: Tree.Link ¬ syms.tb[node].son[1];    t2: Tree.Link ¬ syms.tb[node].son[2];    op1, op2: VarComponent;    IF SmallConst[t1].yes THEN {tt: Tree.Link = t1; t1 ¬ t2; t2 ¬ tt};    SELECT TRUE FROM      syms.tb[node].attr1 =>	{IF ~MPtr.switches['f] THEN Stack.Dump[]; 	 nw ¬ 2; op ¬ qFMUL};      syms.tb[node].attr2 => {nw ¬ 2; op ¬ qDMUL};      ENDCASE => {nw ¬ 1; op ¬ qMUL};    op1 ¬ P5L.ComponentForLex[Exp[t1]];    op2 ¬ P5L.ComponentForLex[Exp[t2]];    P5L.LoadBoth[@op1, @op2, TRUE];    P5U.Out0[op];    RETURN [P5L.TOSLex[nw]]    END;  Log2: PROC [i: CARDINAL] RETURNS [BOOLEAN, [0..16]] =    BEGIN OPEN Inline;    shift: [0..16];    IF i = 0 THEN RETURN [FALSE, 0];    IF BITAND[i, i-1] # 0 THEN RETURN [FALSE, 0];    FOR shift IN [0..16) DO      IF BITAND[i,1] = 1 THEN RETURN [TRUE, shift];      i ¬ BITSHIFT[i, -1];      ENDLOOP;    ERROR; -- can't get here, but it makes the compiler happy    END;  StoreMod: PUBLIC PROC [t: Tree.Link, bSize: [0..wordlength)] RETURNS [Tree.Link] =    BEGIN  -- see if store into field with width bSize performs the MOD operation    IF TreeOps.OpName[syms, t] # mod THEN RETURN [t]    ELSE      BEGIN      node: Tree.Index = TreeOps.GetNode[syms, t];      t2: Tree.Link = syms.tb[node].son[2];      powerof2: BOOLEAN ¬ FALSE;      log: [0..16];      IF P5U.TreeLiteral[t2] THEN [powerof2, log] ¬ Log2[P5U.TreeLiteralValue[t2]];      RETURN [IF ~syms.tb[node].attr3 AND powerof2 AND log = bSize        THEN syms.tb[node].son[1]	ELSE t]      END;    END;              Div: PROC [node: Tree.Index] RETURNS [Lexeme] =    BEGIN -- generate code for /    signed: BOOLEAN = syms.tb[node].attr3 ;    op: BYTE;    nw: [1..2];    SELECT TRUE FROM      syms.tb[node].attr1 =>	{IF ~MPtr.switches['f] THEN Stack.Dump[]; nw ¬ 2; op ¬ qFDIV};      syms.tb[node].attr2 =>	{nw ¬ 2; op ¬ IF signed THEN qDDIV ELSE qDUDIV};      ENDCASE => {nw ¬ 1; op ¬ IF signed THEN qSDIV ELSE qUDIV};    IF ~Stack.RoomFor[2*nw] THEN {      Stack.Dump[];      IF MPtr.switches['l] THEN CLog.Warning[awfulCode]};    PushRhs[syms, syms.tb[node].son[1]];    PushRhs[syms, syms.tb[node].son[2]];    P5U.Out0[op];    RETURN [P5L.TOSLex[nw]];    END;  Mod: PROC [node: Tree.Index] RETURNS [Lexeme] =    BEGIN -- generate code for MOD    real: BOOLEAN = syms.tb[node].attr1;    double: BOOLEAN =  real OR syms.tb[node].attr2;    signed: BOOLEAN = syms.tb[node].attr3;    rand2lit: BOOLEAN;    powerof2: BOOLEAN ¬ FALSE;    rand2val: INTEGER;    IF double THEN       BEGIN       IF real THEN SIGNAL CPtr.CodeNotImplemented;      Stack.Dump[];      END;    PushRhs[syms, syms.tb[node].son[1]];    IF ~double AND ~signed THEN      BEGIN      [rand2lit, rand2val] ¬ ConstOperand[syms.tb[node].son[2]];      IF rand2lit THEN	BEGIN	[powerof2, ] ¬ Log2[rand2val];	IF powerof2 THEN	  BEGIN	  P5U.PushLitVal[rand2val-1]; P5U.Out0[qAND];	  RETURN [P5L.TOSLex[1]];	  END;	END;      END;    IF double THEN      BEGIN       IF ~signed THEN        BEGIN        yes: BOOLEAN;	[yes, rand2val] ¬ SmallConst[syms.tb[node].son[2]];	IF yes THEN [powerof2,] ¬ Log2[rand2val]	ELSE {	  [yes, rand2val] ¬ LargePowerOf2[syms.tb[node].son[2]];	  IF yes THEN {	    IF rand2val = 1 THEN {	      P5U.Out0[qDIS]; P5U.PushLitVal[0]}	    ELSE {	      P5U.PushLitVal[rand2val - 1];	      P5U.Out0[qAND]};	    RETURN[P5L.TOSLex[2]]}};	END;      IF powerof2  THEN        BEGIN	P5U.Out0[qDIS];	P5U.PushLitVal[rand2val-1]; P5U.Out0[qAND];	P5U.PushLitVal[0];	END      ELSE {PushRhs[syms, syms.tb[node].son[2]]; P5U.Out0[IF signed THEN qDMOD ELSE qDUMOD]};      RETURN [P5L.TOSLex[2]];      END;    PushRhs[syms, syms.tb[node].son[2]];    P5U.Out0[IF signed THEN qSDIV ELSE qUDIV];    P5U.Out0[qREC];    P5U.Out0[qEXDIS];    RETURN [P5L.TOSLex[1]];    END;  Float: PROC [node: Tree.Index] RETURNS [Lexeme] =    BEGIN    IF ~MPtr.switches['f] THEN Stack.Dump[];    PushRhs[syms, syms.tb[node].son[1]];    P5U.Out0[qFLOAT];    RETURN [P5L.TOSLex[2]];    END;  Addr: PROC [node: Tree.Index] RETURNS [Lexeme] =    BEGIN -- generates code for "@"    r: VarIndex = P5L.VarForLex[Exp[syms.tb[node].son[1]]];    avar: VarComponent = P5L.AddrForVar[r];    WITH vv: avar SELECT FROM      frame, caddr, link => NULL;      faddr => IF vv.level = syms.bb[MPtr.bodyIndex].level THEN         CPtr.tailJumpOK ¬ FALSE;      ENDCASE => CPtr.tailJumpOK ¬ FALSE; -- some day make this test smarter.       -- Only a problem if you are taking the addr of a local variable      -- current test will set FALSE for any expr that loads addr onto stack    RETURN [[bdo[P5L.OVarItem[avar]]]]    END;  ArrayDesc: PROC [node: Tree.Index] RETURNS [Lexeme] =    BEGIN -- pushes two components of an array descriptor onto stack    subNode: Tree.Index = TreeOps.GetNode[syms, syms.tb[node].son[1]];    size: CARDINAL;    size ¬ SPushRhs[syms.tb[subNode].son[1]];    size ¬ SPushRhs[syms.tb[subNode].son[2]] + size;    RETURN [P5L.TOSLex[size]]    END;  Length: PROC [node: Tree.Index] RETURNS [Lexeme] =    BEGIN -- generates code to extract length from array descriptor    -- relocs need not apply    t1: Tree.Link = syms.tb[node].son[1];    pW: CARDINAL = P5U.WordsForOperand[t1] - 1;    r: VarIndex = P5L.VarForLex[Exp[t1]];    P5L.FieldOfVarOnly[r: r, wd: pW, wSize: 1];    RETURN [[bdo[r]]]    END;  Base: PROC [node: Tree.Index] RETURNS [Lexeme] =    BEGIN -- generates code to extract base from array descriptor    -- relocs get converted to addr    t1: Tree.Link = syms.tb[node].son[1];    pW: CARDINAL = P5U.WordsForOperand[t1] - 1;    r: VarIndex = P5L.VarForLex[Exp[t1]];    P5L.FieldOfVarOnly[r: r, wSize: pW];    RETURN [[bdo[r]]]    END;  DotOrUparrow: PROC [mainnode: Tree.Index]  RETURNS [Lexeme] =    BEGIN    -- generate code for "exp.field"    t1: Tree.Link = syms.tb[mainnode].son[1];    r: VarIndex;    long: BOOLEAN = syms.tb[mainnode].attr2;    nilCheck: BOOLEAN = FALSE; -- syms.tb[mainnode].attr1;    base: VarComponent;    offset: VarComponent;    SELECT TRUE FROM      nilCheck =>	BEGIN	PushRhs[syms, t1];	-- P5U.Out0[IF long THEN FOpCodes.qNILCKL ELSE FOpCodes.qNILCK];	base ¬ P5L.TOSComponent[IF long THEN 2 ELSE 1];	r ¬ P5L.GenVarItem[bo];	cb[r] ¬ [body: bo[base: base, offset: NULL]];	END;      (TreeOps.OpName[syms, t1] = plus) =>	BEGIN	subNode: Tree.Index = TreeOps.GetNode[syms, t1];	disp: VarComponent;	base ¬ P5L.ComponentForLex[Exp[syms.tb[subNode].son[1]]];	disp ¬ P5L.ComponentForLex[Exp[syms.tb[subNode].son[2]]];	r ¬ P5L.GenVarItem[bdo];	cb[r] ¬ [body: bdo[base: base, disp: disp, offset: NULL]];	END;      ENDCASE =>	BEGIN	base ¬ P5L.ComponentForLex[Exp[t1]];	r ¬ P5L.GenVarItem[bo];	cb[r] ¬ [body: bo[base: base, offset: NULL]];	END;    IF syms.tb[mainnode].name = uparrow THEN      offset ¬ [        wSize: P5U.WordsForSei[TreeOps.DecodeSei[syms.tb[mainnode].info]], 	space: frame[wd: 0]]    ELSE      BEGIN      sei: ISEIndex = TreeOps.GetSe[syms, syms.tb[mainnode].son[2]];      IF syms.seb[sei].constant THEN ERROR -- disallowed by pass 4      ELSE	BEGIN	psei: CSEIndex = SymbolOps.NormalType[syms, P5U.OperandType[syms.tb[mainnode].son[1]]];	offset ¬ P5L.ComponentForSE[sei];	WITH offset SELECT FROM	  frame => level ¬ lZ; -- to take care of pointer to frame	  ENDCASE => ERROR; -- fields of code data are dollar nodes	WITH syms.seb[psei] SELECT FROM	  ref =>	    BEGIN OPEN SymbolOps;	    rcsei: CSEIndex = UnderType[syms, refType];	    -- if we point to a type, it fills a number of full words	    WITH syms.seb[rcsei] SELECT FROM	      record =>		P5L.AdjustComponent[var: @offset, rSei: LOOPHOLE[rcsei],		  fSei: sei, tBits: CheckOver[WordsForType[syms, rcsei]*wordlength]];	      ENDCASE;	    END;	  ENDCASE => P5.P5Error[642];	END;      END;    WITH cc: cb[r] SELECT FROM      bo => cc.offset ¬ offset;      bdo => cc.offset ¬ offset;      ENDCASE => ERROR;    RETURN [[bdo[r]]]    END;  Reloc: PUBLIC PROC [node: Tree.Index] RETURNS [Lexeme] =    BEGIN -- generates code for "baseptr[relptr]"    rd, rr: VarIndex;    base: VarComponent ¬ P5L.ComponentForLex[Exp[syms.tb[node].son[1]]];    disp: VarComponent;    rd ¬ P5L.VarForLex[Exp[syms.tb[node].son[2]]];    IF syms.tb[node].attr1 THEN      BEGIN -- reloc of an array descriptor      dsize: CARDINAL = P5U.WordsForOperand[syms.tb[node].son[2]] - 1;      P5L.FieldOfVarOnly[r: rd, wSize: dsize];      END;    disp ¬ P5L.MakeComponent[rd];    rr ¬ P5L.GenVarItem[bdo];    cb[rr] ¬ [body: bdo[base: base, disp: disp, offset: [      wSize: CheckOver[SymbolOps.WordsForType[syms, TreeOps.DecodeSei[syms.tb[node].info]]],       space: frame[]]]];    RETURN [[bdo[rr]]]    END;  Dollar: PROC [node: Tree.Index] RETURNS [Lexeme] =    BEGIN -- generates code for "exp$field"    sei: ISEIndex = TreeOps.GetSe[syms, syms.tb[node].son[2]];    r: VarIndex;    l: Lexeme;    recsei: RecordSEIndex = LOOPHOLE[P5U.OperandType[syms.tb[node].son[1]]];    functionCall: BOOLEAN = syms.seb[recsei].argument;    tBits, twSize: CARDINAL;    tbSize: [0..wordlength);    foffset: frame VarComponent;    hlex: se Lexeme ¬ NullLex;    IF syms.seb[sei].constant THEN ERROR; -- disallowed by Pass 4    l ¬ Exp[syms.tb[node].son[1] ! P5.LogHeapFree =>      IF calltree = syms.tb[node].son[1] THEN	BEGIN	logged: BOOLEAN; lex: se Lexeme;	[logged, lex] ¬ SIGNAL P5.LogHeapFree[calltree];	IF logged THEN RESUME [TRUE, lex];	hlex ¬ P5.GenTempLex[1];	RESUME [TRUE, hlex]	END];    r ¬ P5L.VarForLex[l];    WITH cc: cb[r] SELECT FROM -- special case links      o => {        var: VarComponent ¬ cc.var;	WITH var SELECT FROM	  link => {	    P5L.LoadComponent[var];	    r ¬ P5L.OVarItem[P5L.TOSComponent[var.wSize]]};	  ENDCASE};      ENDCASE;    [wSize: twSize, bSize: tbSize] ¬ P5L.VarAlignment[r, load];    tBits ¬ twSize*wordlength + tbSize;    IF functionCall THEN      BEGIN      fSize: CARDINAL;      fAddr: BitAddress;      [fAddr,fSize] ¬ SymbolOps.FnField[syms, sei];      foffset ¬ [wSize: fSize / wordlength, bSize: fSize MOD wordlength,	space: frame[wd: fAddr.wd, bd: fAddr.bd]];      END    ELSE foffset ¬ LOOPHOLE[P5L.ComponentForSE[sei]];    IF tBits <= wordlength THEN	  P5L.AdjustComponent[var: @foffset,	    rSei: recsei, fSei: sei, tBits: tBits];    P5L.FieldOfVarOnly[r: r, wSize: foffset.wSize,	  bSize: foffset.bSize, wd: foffset.wd, bd: foffset.bd];    IF hlex # NullLex THEN      BEGIN      r ¬ P5L.OVarItem[P5L.CopyToTemp[r].var];      PushLex[hlex];  P5U.Out0[FOpCodes.qFF];      END;    RETURN [[bdo[r]]]    END;  MwConst: PROC [node: Tree.Index] RETURNS [l: Lexeme] =    BEGIN -- puts multi-word constant out to code stream    lti: LTIndex;    WITH syms.tb[node].son[1] SELECT FROM      literal => WITH info SELECT FROM	word => lti ¬ index;        ENDCASE => P5.P5Error[647];      ENDCASE => P5.P5Error[648];    WITH ll: syms.ltb[lti] SELECT FROM      short => RETURN [[literal[word[lti]]]];      long => 	BEGIN	var: VarComponent;	SELECT ll.length FROM	  0 => P5.P5Error[649];	  1 => var ¬ [wSize: 1, space: const[d1: ll.value[0]]];	  2 => var ¬ [wSize: 2, space: const[d1: ll.value[0], d2: ll.value[1]]];	  ENDCASE =>	    BEGIN	    nwords: CARDINAL = ll.length;	    IF ll.codeIndex = 0 THEN 	      BEGIN	      ll.codeIndex ¬ P5.MoveToCodeWord[];	      FOR i: CARDINAL IN [0..nwords) DO P5.WriteCodeWord[ll.value[i]] ENDLOOP;	      P5U.RecordConstant[ll.codeIndex, nwords];	      END;	    var ¬ [wSize: nwords, space: code[wd: ll.codeIndex, lti: lti]];	    END;	RETURN [[bdo[P5L.OVarItem[var]]]];        END;      ENDCASE => ERROR; -- to keep the compiler happy    END;  DoubleZero: PUBLIC PROC [t: Tree.Link] RETURNS [BOOLEAN] =    BEGIN    yes: BOOLEAN;    val: CARDINAL;    [yes, val] ¬ SmallConst[t];    RETURN [yes AND (val=0)];    END;  SmallConst: PUBLIC PROC [t: Tree.Link] RETURNS [yes: BOOLEAN, val: CARDINAL] =    BEGIN    node: Tree.Index;    lti: LTIndex;    WITH e: t SELECT FROM      subtree => node ¬ e.index;      literal =>  WITH e.info SELECT FROM	word => RETURN [TRUE, LiteralOps.Value[syms, index]];	ENDCASE => RETURN [FALSE, 0];      ENDCASE => GO TO retFalse;    IF syms.tb[node].name # mwconst THEN GO TO retFalse;    WITH syms.tb[node].son[1] SELECT FROM      literal => WITH info SELECT FROM	word => lti ¬ index;        ENDCASE => GO TO retFalse;      ENDCASE => GO TO retFalse;    WITH ll:syms.ltb[lti] SELECT FROM      long => 	SELECT ll.length FROM	  2 => {	    n: Inline.LongNumber = 	      [num[lowbits: ll.value[0], highbits: ll.value[1]]];	    IF n.lc <= CARDINAL.LAST THEN RETURN [TRUE, CARDINAL[n.lc]]};	  ENDCASE;      ENDCASE;    GO TO retFalse;    EXITS      retFalse => RETURN [FALSE, 0]    END;	  	    LargePowerOf2: PUBLIC PROC [t: Tree.Link]       RETURNS [yes: BOOLEAN ¬ FALSE, val: CARDINAL] =    BEGIN    node: Tree.Index;    lti: LTIndex;    WITH e: t SELECT FROM      subtree => node ¬ e.index;      ENDCASE => GO TO retFalse;    IF syms.tb[node].name # mwconst THEN GO TO retFalse;    WITH syms.tb[node].son[1] SELECT FROM      literal => WITH info SELECT FROM	word => lti ¬ index;        ENDCASE => GO TO retFalse;      ENDCASE => GO TO retFalse;    WITH ll:syms.ltb[lti] SELECT FROM      long => 	SELECT ll.length FROM	  2 => {	    n: Inline.LongNumber = 	      [num[lowbits: ll.value[0], highbits: ll.value[1]]]; 	    IF n.lowbits = 0 AND n.highbits # 0 AND 	      Inline.BITAND[n.highbits, n.highbits-1] = 0 THEN	      RETURN[TRUE, n.highbits];	    };	  ENDCASE;      ENDCASE;    GO TO retFalse;    EXITS      retFalse => RETURN [FALSE, 0]    END;	  	    LPushRhs: PUBLIC PROC [t: Tree.Link] RETURNS [Lexeme] =    BEGIN -- forces a value onto the stack    wSize: CARDINAL = SPushRhs[t];    RETURN [P5L.TOSLex[wSize]]    END;  PushRhs: PUBLIC PROC [h: SymbolTable.Handle, t: Tree.Link] =    BEGIN -- forces a value onto the stack    [] ¬ SPushRhs[t];    END;  SPushRhs: PROC [t: Tree.Link] RETURNS [wSize: CARDINAL] =    BEGIN -- forces a value onto the stack    RETURN [SPushLex[Exp[t]]]    END;  SPushLex: PROC [l: Lexeme] RETURNS [wSize: CARDINAL] =    BEGIN -- forces a lexeme onto the stack    r: VarIndex = P5L.VarForLex[l];    ws, bs: CARDINAL;    [wSize: ws, bSize: bs] ¬ P5L.VarAlignment[r,load];    wSize ¬ P5L.Words[ws, bs];    P5L.LoadVar[r];    RETURN    END;  PushLex: PUBLIC PROC [l: Lexeme] =    {[] ¬ SPushLex[l]};  LPushLex: PUBLIC PROC [l: Lexeme] RETURNS [Lexeme] =    BEGIN    wSize: CARDINAL = SPushLex[l];    RETURN [P5L.TOSLex[wSize]];    END;  PushLProcDesc: PUBLIC PROC [bti: CBTIndex] =    BEGIN -- pushes a descriptor for local procedure on stack    WITH body: syms.bb[bti] SELECT FROM      Inner => PushNestedProcDesc[bti];      Outer => P5L.LoadComponent[[wSize: 2, space: pdesc[ep: body.entryIndex, part: all]]];      ENDCASE;    END;  PushNestedProcDesc: PUBLIC PROC [bti: CBTIndex] =    BEGIN -- pushes a descriptor for nested local procedure on stack    WITH body: syms.bb[bti] SELECT FROM      Inner =>	BEGIN	avar: VarComponent = [	   wSize: 2, 	   space: lfaddr[wd: body.frameOffset, level: body.level-1, op: pad]];	P5L.LoadComponent[avar];	END;      ENDCASE    END;  SignalInit: PROC [node: Tree.Index] RETURNS [Lexeme] =    BEGIN    P5L.LoadComponent[[wSize: 2, space: sigdesc[TreeOps.DecodeCard[syms.tb[node].info]]]];    RETURN [P5L.TOSLex[2]]    END;  END.
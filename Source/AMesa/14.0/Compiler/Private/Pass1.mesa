-- Copyright (C) 1982, 1983, 1986  by Xerox Corporation. All rights reserved. -- file Pass1.mesa; last modified by-- Satterthwaite,	12-Jan-82 17:06:27-- Sweet,		12-Jun-83  0:59:36-- Johnsson,		11-Jun-83 14:05:44-- MEW			21-Aug-86  9:40:50DIRECTORY  ComData USING [    bodyIndex,    idANY, idATOM, idBOOL, idCARDINAL, idCHAR, idINT,    idLOCK, idREAL, idSTRING, idTEXT, idUNWIND,    nErrors, outerCtx, ownSymbols, seAnon, sourceLines, textIndex, tC0, tC1,    typeATOM, typeAtomRecord, typeBOOL, typeCARDINAL, typeCHAR,    typeCONDITION, typeINT, typeLOCK, typeLONGSTRING, typeREAL, typeRefANY, typeListANY,    typeSTRING, typeStringBody, zone],  CompilerUtil USING [],  LiteralOps USING [Find],  P1 USING [Parse],  String USING [SubStringDescriptor],  Symbols USING [    BitAddress, ByteLength, WordLength, SERecord,    HTIndex, SEIndex, ISEIndex, CSEIndex, RecordSEIndex, CTXIndex,    codeANY, codeINT, codeCHAR, typeANY, typeTYPE,    HTNull, ISENull, RecordSENull, CTXNull, CBTNull, lZ, DummyLink],  SymbolOps USING [    EnterExtension, EnterString, FillCtxSe, FromBitAddr, FromBti, FromCard, FromLink,     FromSei, FromTreeIndex, NewCtx, MakeNonCtxSe, MakeSeChain, NextSe, SetSeLink],  SymbolTable USING [Handle],  Tree USING [Link, NullIndex];Pass1: PROGRAM    IMPORTS      LiteralOps, P1, SymbolOps,      dataPtr: ComData    EXPORTS CompilerUtil, P1, SymbolOps = {  OPEN SymbolOps, Symbols; -- construction of predeclared symbols  SubStringDescriptor: TYPE = String.SubStringDescriptor;  MakeBasicType: PROC [syms: SymbolTable.Handle, code: [0..16), ordered: BOOLEAN, nBits: CARDINAL]      RETURNS [sei: CSEIndex] = {    sei ¬ MakeNonCtxSe[syms, SIZE[basic cons SERecord]];    syms.seb[sei] ¬ [mark3: TRUE, mark4: TRUE,	body: cons[basic[ordered:ordered, code:code, length:nBits]]];    RETURN};  MakeRecordType: PROC [syms: SymbolTable.Handle, nBits: CARDINAL, default, refField: BOOLEAN ¬ FALSE]      RETURNS [rSei: RecordSEIndex] = {    rSei ¬ LOOPHOLE[MakeNonCtxSe[syms, SIZE[notLinked record cons SERecord]]];    syms.seb[rSei] ¬ [mark3: TRUE, mark4: TRUE,	body: cons[record[		machineDep: TRUE,		argument: FALSE,  monitored: FALSE, painted: TRUE,		hints: [		  comparable: FALSE, assignable: FALSE,		  variant: FALSE, unifield: FALSE, privateFields: FALSE,		  refField: refField, default: default, voidable: ~refField AND ~default],		fieldCtx: NewCtx[syms, lZ],		length: nBits,		linkPart: notLinked[]]]];    RETURN};  MakeRefType: PROC [syms: SymbolTable.Handle, refType: SEIndex, counted, list: BOOLEAN ¬ FALSE]      RETURNS [sei: CSEIndex] = {    sei ¬ MakeNonCtxSe[syms, SIZE[ref cons SERecord]];    syms.seb[sei] ¬ [mark3: TRUE, mark4: TRUE,	body: cons[ref[		counted: counted,		var: FALSE,		readOnly: FALSE, ordered: FALSE, list: list, basing: FALSE,		refType: refType]]];    RETURN};  MakeLongType: PROC [syms: SymbolTable.Handle, rangeType: SEIndex] RETURNS [sei: CSEIndex] = {    sei ¬ MakeNonCtxSe[syms, SIZE[long cons SERecord]];    syms.seb[sei] ¬ [mark3: TRUE, mark4: TRUE, body: cons[long[rangeType: rangeType]]];    RETURN};  MakeSubrangeType: PROC [syms: SymbolTable.Handle, origin: INTEGER, range: CARDINAL, empty: BOOLEAN]      RETURNS [sei: CSEIndex] = {    sei ¬ MakeNonCtxSe[syms, SIZE[subrange cons SERecord]];    syms.seb[sei] ¬ [mark3: TRUE, mark4: TRUE,	body: cons[subrange[		filled: TRUE, empty: empty,		rangeType: dataPtr.idINT,		origin: origin,  range: range]]];    RETURN};  SetIdAttr: PROC [syms: SymbolTable.Handle, sei: ISEIndex, const: BOOLEAN] = {    syms.seb[sei].immutable ¬ syms.seb[sei].constant ¬ const;    syms.seb[sei].extended ¬ syms.seb[sei].public ¬ syms.seb[sei].linkSpace ¬ FALSE;    syms.seb[sei].mark3 ¬ syms.seb[sei].mark4 ¬ TRUE};  FillVariable: PROC [syms: SymbolTable.Handle,       sei: ISEIndex, name: STRING, type: SEIndex, offset: BitAddress, nBits: CARDINAL] = {    desc: SubStringDescriptor;    hti: HTIndex;    IF name # NIL THEN {      desc ¬ [base:name, offset:0, length:name.length]; hti ¬ EnterString[syms, @desc]}    ELSE hti ¬ HTNull;    FillCtxSe[syms, sei, hti, FALSE];    syms.seb[sei].idType ¬ type;  syms.seb[sei].idValue ¬ FromBitAddr[offset];      syms.seb[sei].idInfo ¬ FromCard[nBits];    SetIdAttr[syms, sei, FALSE]};  FillConstant: PROC [syms: SymbolTable.Handle, sei: ISEIndex, name: STRING, type: SEIndex, value: WORD] = {    desc: SubStringDescriptor ¬ [base:name, offset:0, length:name.length];    FillCtxSe[syms, sei, EnterString[syms, @desc], FALSE];    syms.seb[sei].idType ¬ type;  syms.seb[sei].idInfo ¬ FromCard[0];      syms.seb[sei].idValue ¬ LOOPHOLE[value];    SetIdAttr[syms, sei, TRUE]};  FillXferConstant: PROC [syms: SymbolTable.Handle, sei: ISEIndex,    name: STRING, type: SEIndex, epN: CARDINAL] = {    desc: SubStringDescriptor ¬ [base:name, offset:0, length:name.length];    FillCtxSe[syms, sei, EnterString[syms, @desc], FALSE];    syms.seb[sei].idType ¬ type;  syms.seb[sei].idInfo ¬ FromBti[CBTNull];    syms.seb[sei].idValue ¬ FromLink[Symbols.DummyLink[gfi:0, ep:epN]];    SetIdAttr[syms, sei, TRUE]};  FillNamedType: PROC [syms: SymbolTable.Handle, sei: ISEIndex, s: STRING, type: SEIndex] = {    desc: SubStringDescriptor ¬ [base:s, offset:0, length:s.length];    FillCtxSe[syms, sei, EnterString[syms, @desc], FALSE];  SetIdAttr[syms, sei, TRUE];    syms.seb[sei].idType ¬ typeTYPE;  syms.seb[sei].idInfo ¬ FromSei[type];      syms.seb[sei].idValue ¬ FromTreeIndex[Tree.NullIndex];    SetIdAttr[syms, sei, TRUE]};  MakeTreeLiteral: PROC [syms: SymbolTable.Handle, val: WORD] RETURNS [Tree.Link] = {    RETURN [[literal[info:[word[LiteralOps.Find[syms, val]]]]]]};  NOuterSymbols: CARDINAL = 20;	-- number of predeclared ids (outer level only)  NExtraSymbols: CARDINAL = 4;	-- number of new predeclared ids  PrefillMesaSymbols: PUBLIC PROC [syms: SymbolTable.Handle]     RETURNS [oct: CTXIndex --outer context--] = {         OPEN dataPtr;    tSei: CSEIndex;    rSei: RecordSEIndex;    tCtx: CTXIndex;    sei, seChain: ISEIndex;    outerChain: ISEIndex;    NextOuterSe: PROC RETURNS [next: ISEIndex] = {      IF outerChain = ISENull THEN ERROR;      next ¬ outerChain;  outerChain ¬ NextSe[syms, outerChain];  RETURN};    idNAT: ISEIndex;    syms ¬ dataPtr.ownSymbols;    tSei ¬ MakeBasicType[syms, codeANY, TRUE, WordLength];	-- guaranteed position    outerCtx ¬ NewCtx[syms, lZ];    oct ¬ outerCtx;    outerChain ¬ syms.ctxb[outerCtx].seList ¬       MakeSeChain[syms, outerCtx, NOuterSymbols, FALSE];    -- make some constants      {tC0 ¬ MakeTreeLiteral[syms, 0]; tC1 ¬ MakeTreeLiteral[syms, 1]};    idANY ¬ NextOuterSe[];      FillNamedType[syms, idANY, "UNSPECIFIED"L, tSei];      IF tSei # typeANY THEN ERROR;    idINT ¬ NextOuterSe[];  typeINT ¬ MakeBasicType[syms, codeINT, TRUE, WordLength];      FillNamedType[syms, idINT, "INTEGER"L, typeINT];    idCHAR ¬ NextOuterSe[];  typeCHAR ¬ MakeBasicType[syms, codeCHAR, TRUE, ByteLength];      FillNamedType[syms, idCHAR, "CHARACTER"L, typeCHAR];    idBOOL ¬ NextOuterSe[];      typeBOOL ¬ MakeNonCtxSe[syms, SIZE[enumerated cons SERecord]];      tCtx ¬ NewCtx[syms, lZ];      syms.seb[typeBOOL] ¬ [mark3: TRUE, mark4: TRUE,	body: cons[enumerated[		ordered: TRUE, machineDep: TRUE, sparse: FALSE, unpainted: FALSE,		valueCtx: tCtx, nValues: 2]]];      syms.ctxb[tCtx].seList ¬ seChain ¬ MakeSeChain[syms, tCtx, 2, FALSE];      FillConstant[syms, seChain, "FALSE"L, idBOOL, 0];  seChain ¬ NextSe[syms, seChain];      FillConstant[syms, seChain, "TRUE"L, idBOOL, 1];      FillNamedType[syms, idBOOL, "BOOLEAN"L, typeBOOL];    idCARDINAL ¬ NextOuterSe[];      typeCARDINAL ¬ MakeSubrangeType[syms, 0, 177777b, FALSE];      FillNamedType[syms, idCARDINAL, "CARDINAL"L, typeCARDINAL];    FillNamedType[syms, NextOuterSe[], "WORD"L, typeCARDINAL];    idREAL ¬ NextOuterSe[];      typeREAL ¬ MakeNonCtxSe[syms, SIZE[real cons SERecord]];      syms.seb[typeREAL] ¬ [mark3:TRUE, mark4:TRUE, body:cons[real[rangeType:idINT]]];      FillNamedType[syms, idREAL, "REAL"L, typeREAL];    idNAT ¬ sei ¬ NextOuterSe[];	-- NAT      FillNamedType[syms, sei, "NAT"L, MakeSubrangeType[syms, 0, 77777b, FALSE]];    idTEXT ¬ NextOuterSe[];      rSei ¬ MakeRecordType[syms: syms, nBits:2*WordLength, default:TRUE];      syms.seb[rSei].hints.variant ¬ TRUE;      tCtx ¬ syms.seb[rSei].fieldCtx; syms.ctxb[tCtx].seList ¬ seChain ¬ MakeSeChain[syms, tCtx, 2, FALSE];      FillVariable[syms, seChain, "length"L, idNAT, [wd:0, bd:0], WordLength];        EnterExtension[syms, seChain, default, tC0];      seChain ¬ NextSe[syms, seChain];	BEGIN	tag: ISEIndex = MakeSeChain[syms, CTXNull, 1, FALSE];	seqSei: CSEIndex = MakeNonCtxSe[syms, SIZE[sequence cons SERecord]];	FillVariable[syms, tag, "maxLength"L, idNAT, [wd:1, bd:0], WordLength];	  syms.seb[tag].immutable ¬ TRUE;	syms.seb[seqSei] ¬ [mark3: TRUE, mark4: TRUE,	    body: cons[sequence[		packed: TRUE, machineDep: TRUE,		controlled: TRUE, tagSei: tag,		componentType: idCHAR]]];	FillVariable[syms, seChain, "text"L, seqSei, [wd:1, bd:0], WordLength];	END;      FillNamedType[syms, idTEXT, "TEXT"L, rSei];    idSTRING ¬ NextOuterSe[];    sei ¬ NextOuterSe[];	-- StringBody      typeStringBody ¬ rSei ¬ MakeRecordType[syms: syms, nBits:2*WordLength, default:TRUE];      syms.seb[rSei].hints.assignable ¬ syms.seb[rSei].hints.voidable ¬ TRUE;   -- compatibility      tCtx ¬ syms.seb[rSei].fieldCtx;       syms.ctxb[tCtx].seList ¬ seChain ¬ MakeSeChain[syms, tCtx, 3, FALSE];      FillVariable[syms, seChain, "length"L, idCARDINAL, [wd:0, bd:0], WordLength];        EnterExtension[syms, seChain, default, tC0];      seChain ¬ NextSe[syms, seChain];      FillVariable[syms, seChain, "maxlength"L, idCARDINAL, [wd:1, bd:0], WordLength];        syms.seb[seChain].immutable ¬ TRUE;      seChain ¬ NextSe[syms, seChain];      tSei ¬ MakeNonCtxSe[syms, SIZE[array cons SERecord]];      syms.seb[tSei] ¬ [mark3: TRUE, mark4: TRUE,	body: cons[array[		packed: TRUE,		indexType: MakeSubrangeType[syms, 0, 0, TRUE],		componentType: idCHAR]]];      FillVariable[syms, seChain, "text"L, tSei, [wd:2, bd:0], 0];      FillNamedType[syms, sei, "StringBody"L, rSei];       typeSTRING ¬ MakeRefType[syms, sei];      typeLONGSTRING ¬ MakeLongType[syms, typeSTRING];      FillNamedType[syms, idSTRING, "STRING"L, typeSTRING];    idLOCK ¬ NextOuterSe[];      rSei ¬ MakeRecordType[syms: syms, nBits:WordLength, default:TRUE];      tCtx ¬ syms.seb[rSei].fieldCtx; syms.ctxb[tCtx].seList ¬ seChain ¬ MakeSeChain[syms, tCtx, 1, FALSE];      FillVariable[syms, seChain, NIL, idANY, [wd:0, bd:0], WordLength];        EnterExtension[syms, seChain, default, MakeTreeLiteral[syms, 100000b]];      FillNamedType[syms, idLOCK, "MONITORLOCK"L, rSei];  typeLOCK ¬ rSei;    sei ¬ NextOuterSe[];	-- CONDITION      rSei ¬ MakeRecordType[syms: syms, nBits:2*WordLength, default:TRUE];      typeCONDITION ¬ rSei;      tCtx ¬ syms.seb[rSei].fieldCtx; syms.ctxb[tCtx].seList ¬ seChain ¬ MakeSeChain[syms, tCtx, 2, FALSE];      FillVariable[syms, seChain, "timeout"L, idCARDINAL, [wd:1, bd:0], WordLength];        EnterExtension[syms, seChain, default, tC0];      seChain ¬ NextSe[syms, seChain];      FillVariable[syms, seChain, NIL, idANY, [wd:0, bd:0], WordLength];        EnterExtension[syms, seChain, default, tC0];      FillNamedType[syms, sei, "CONDITION"L, rSei];  typeCONDITION ¬ rSei;    sei ¬ NextOuterSe[];	-- MDSZone      tSei ¬ MakeNonCtxSe[syms, SIZE[zone cons SERecord]];      syms.seb[tSei] ¬ [mark3:TRUE, mark4:TRUE, body:cons[zone[counted:FALSE, mds:TRUE]]];      FillNamedType[syms, sei, "MDSZone"L, tSei];    idATOM ¬ sei ¬ NextOuterSe[];      typeAtomRecord ¬ tSei ¬ MakeNonCtxSe[syms, SIZE[opaque cons SERecord]];      syms.seb[tSei] ¬ [mark3: TRUE, mark4: TRUE,	body: cons[opaque[	  id: NextSe[syms, sei],	  length: 0, lengthKnown: FALSE]]];      tSei ¬ MakeRefType[syms: syms, refType: tSei, counted: TRUE];      typeATOM ¬ MakeLongType[syms, tSei];      FillNamedType[syms, idATOM, "ATOM"L, typeATOM];    seAnon ¬ NextOuterSe[];      FillVariable[syms, seAnon, "?"L,  typeANY, [wd:0, bd:0], WordLength];    FillConstant[syms, NextOuterSe[], "TRUE"L, idBOOL, 1];	-- TRUE    FillConstant[syms, NextOuterSe[], "FALSE"L, idBOOL, 0];	-- FALSE    idUNWIND ¬ NextOuterSe[];      tSei ¬ MakeNonCtxSe[syms, SIZE[transfer cons SERecord]];      syms.seb[tSei] ¬ [mark3: TRUE, mark4: TRUE,	body: cons[transfer[	  mode: error, safe: FALSE,	  typeIn: RecordSENull, typeOut: RecordSENull]]];      FillXferConstant[syms, idUNWIND, "UNWIND"L, tSei, 1];    FillXferConstant[syms, NextOuterSe[], "ABORTED"L, tSei, 2];    IF outerChain # ISENull THEN ERROR;    -- REF ANY      tSei ¬ MakeNonCtxSe[syms, SIZE[any cons SERecord]];      syms.seb[tSei] ¬ [mark3: TRUE, mark4: TRUE, body: cons[any[]]];      typeRefANY ¬ MakeLongType[syms,          MakeRefType[syms: syms, refType: tSei, counted: TRUE]];    -- LIST OF REF ANY      rSei ¬ MakeRecordType[syms: syms, nBits: 2*(2*WordLength), refField: TRUE, default: TRUE];      typeListANY ¬ MakeLongType[syms, MakeRefType[syms: syms, refType: rSei, counted: TRUE, list: TRUE]];      syms.seb[rSei].painted ¬ FALSE;      syms.seb[rSei].hints.comparable ¬ syms.seb[rSei].hints.assignable ¬ TRUE;      syms.seb[rSei].hints.refField ¬ TRUE;      tCtx ¬ syms.seb[rSei].fieldCtx; syms.ctxb[tCtx].seList ¬ seChain ¬ MakeSeChain[syms, tCtx, 2, FALSE];      FillVariable[syms, seChain, "first"L, typeRefANY, [wd:0, bd:0], 2*WordLength];      seChain ¬ NextSe[syms, seChain];      FillVariable[syms, seChain, "rest"L, typeListANY, [wd:2, bd:0], 2*WordLength];   -- predeclared types added for Cedar    outerChain ¬ syms.ctxb[outerCtx].seList ¬ MakeSeChain[syms, outerCtx, NExtraSymbols, TRUE];    FillNamedType[syms, NextOuterSe[], "BOOL"L, idBOOL];    FillNamedType[syms, NextOuterSe[], "CHAR"L, idCHAR];    sei ¬ NextOuterSe[];	-- INT      tSei ¬ MakeLongType[syms, idINT];      FillNamedType[syms, sei, "INT"L, tSei];    sei ¬ NextOuterSe[];		-- NATURAL (for SDD Trinity)      FillNamedType[syms, sei, "NATURAL"L, idNAT];    SetSeLink[syms, sei, idANY];    IF outerChain # ISENull THEN ERROR;  };     IdOfFirst: PUBLIC PROC RETURNS [HTIndex] = {RETURN [HashForId["first"L]]};  IdOfLock: PUBLIC PROC RETURNS [HTIndex] = {RETURN [HashForId["LOCK"L]]};  IdOfRest: PUBLIC PROC RETURNS [HTIndex] = {RETURN [HashForId["rest"L]]};  HashForId: PROC [id: STRING] RETURNS [HTIndex] = {    desc: SubStringDescriptor ¬ [base:id, offset:0, length:id.length];    RETURN [EnterString[dataPtr.ownSymbols, @desc]]}; -- pass 1 control  P1Unit: PUBLIC PROC RETURNS [success: BOOLEAN] = {    dataPtr.textIndex ¬ 0;  dataPtr.bodyIndex ¬ CBTNull;    [complete:success, nLines :dataPtr.sourceLines, nErrors:dataPtr.nErrors] ¬ P1.Parse[dataPtr.zone];    EnterHashMark[];};  EnterHashMark: PROC = INLINE {    -- marks end of symbols from source file in hash table    desc: SubStringDescriptor ¬ [base:"  "L, offset:1, length:0];    [] ¬ EnterString[dataPtr.ownSymbols, @desc]};  }.
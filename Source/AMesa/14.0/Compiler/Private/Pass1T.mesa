-- file Pass1T.mesa rewritten by PGS, 24-Apr-87 15:35-- file Pass1T.mesa rewritten by PGS, 24-Apr-87 15:32-- file Pass1T.mesa rewritten by PGS,  8-Apr-87 14:35-- file Pass1T.mesa rewritten by PGS,  7-Jan-87  3:57-- file Pass1T.mesa rewritten by PGS, 21-Aug-86 10:23-- file Pass1T.mesa rewritten by PGS, 21-Aug-86 10:11-- file Pass1T.mesa rewritten by PGS, 24-Sep-84 10:35-- file Pass1T.mesa rewritten by PGS,  7-Sep-83 10:25-- file Pass1T.mesa rewritten by PGS,  7-Sep-83 10:21-- file Pass1T.mesa rewritten by PGS,  7-Sep-83 10:10-- file Pass1T.mesa rewritten by PGS,  9-Aug-83 10:54-- file Pass1T.mesa rewritten by PGS, 10-Jun-83 18:00-- file Pass1T.mesa rewritten by PGS,  8-Dec-82 14:03--   Satterthwaite,	October 14, 1982 5:15 pm--   Donahue,		 9-Dec-81 10:48:31--   Sweet,		 7-Sep-83  9:31:00--   Wagner		21-Aug-86 10:10:40--   Saxe		24-Apr-87 15:29:54DIRECTORY  ComData USING [idANY, idINT, idLOCK, ownSymbols],  MDRDefs,  ParseTable USING [ActionEntry, ProdDataRef, TSymbol],  P1 USING [    ActionStack, LinkStack, Value, ValueStack, NullValue,    InputLoc, IdOfLock],  Symbols USING [HTIndex, HTNull],  SymbolTable USING [Handle],  Tree USING [AttrId, Index, Link, NodeName, Null],  TreeOps USING [    EncodeCard, FreeTree, GetNode, ListLength, MakeNode, ExtractTree,    InsertTree, Map, OpName,    PopTree, PushTree, PushHash, PushList, PushLit, PushProperList, PushSe,    PushNode, PushStringLit, SetAttr, SetInfo, UpdateList];Pass1T: PROGRAM    IMPORTS P1, TreeOps, dataPtr: ComData, MDRDefs    EXPORTS P1 = {  -- parse tree building  OPEN TreeOps;    syms: SymbolTable.Handle ¬ NIL;  Op: TYPE = Tree.NodeName; -- local data base (supplied by parser)  v: P1.ValueStack;  l: P1.LinkStack;  q: P1.ActionStack;  prodData: ParseTable.ProdDataRef; -- initialization/termination  AssignDescriptors: PUBLIC PROC [      qd: P1.ActionStack, vd: P1.ValueStack, ld: P1.LinkStack,      pp: ParseTable.ProdDataRef] = {    q ¬ qd; v ¬ vd; l ¬ ld; prodData ¬ pp; syms ¬ dataPtr.ownSymbols }; -- error recovery (only)  TokenValue: PUBLIC PROC [s: ParseTable.TSymbol] RETURNS [P1.Value] = {    RETURN [P1.NullValue]}; -- stack manipulation -- note that r and s may be overlaid in some parameterizations  PushHashV: PROC [k: NAT] = {PushHash[syms, v[k].r]};  PushLitV: PROC [k: NAT] = {PushLit[syms, v[k].r]};  PushStringLitV: PROC [k: NAT] = {PushStringLit[syms, v[k].r]};  PushNodeV: PROC [k: NAT, count: INTEGER] = {PushNode[syms, v[k].s, count]};  PushListV: PROC [k: NAT] = {PushList[syms, v[k].s]};  PushProperListV: PROC [k: NAT] = {PushProperList[syms, v[k].s]};  SetAttrV: PROC [attr: Tree.AttrId, k: NAT] = {SetAttr[syms, attr, v[k].s]};  SetAttrs: PROC [attr1, attr2, attr3: BOOLEAN ¬ FALSE] = {    SetAttr[syms, 1,attr1];  SetAttr[syms, 2,attr2];  SetAttr[syms, 3,attr3]};   -- value manipulation  BoolV: PROC [k: NAT] RETURNS [BOOLEAN] = {RETURN [v[k].s]};  SetBoolV: PROC [k: NAT, b: BOOLEAN] = {v[k].s ¬ b};    MDStatusV: PROCEDURE [k: NAT] RETURNS [MDRDefs.MDStatus] = {RETURN [v[k].s]};  SetMDStatusV: PROCEDURE [k: NAT, mdStatus: MDRDefs.MDStatus] = {    v[k].s ¬ mdStatus};   OpV: PROC [k: NAT] RETURNS [Op] = {RETURN [v[k].s]};  SetOpV: PROC [k: NAT, op: Op] = {v[k].s ¬ op};  NegatedV: PROC [k: NAT] RETURNS [Op] = {    op: Op = v[k].s;    RETURN [SELECT op FROM      relE => relN,   relN => relE,      relL => relGE,  relGE => relL,      relG => relLE,  relLE => relG,      in => notin,    notin => in,      ENDCASE => op]}; -- shared processing routines  DetachItem: TreeOps.Map = {PushTree[syms, t]; RETURN [Tree.Null]};  AnonField: PROC [type, default: Tree.Link, top: CARDINAL] = {    PushField[Symbols.HTNull, type, default, top]};  PushField: PROC [id: Symbols.HTIndex, type, default: Tree.Link, top: CARDINAL] = {    PushHash[syms, id];  PushTree[syms, type];  PushTree[syms, default];    PushNode[syms, decl,3];  LinkToSource[top];    SetAttrs[FALSE,public,FALSE]}; -- the interpretation rules  LinkToSource: PROC [index: CARDINAL] = {SetInfo[syms, EncodeCard[l[index]]]}; -- propagated attributes  public: BOOLEAN;  machineDep: BOOLEAN; -- for enumerated types  trusted, checked: BOOLEAN;  safety: BOOLEAN;  mdStatus: MDRDefs.MDStatus; -- for record types            ProcessQueue: PUBLIC PROC [qI, top: CARDINAL] = {    t1, t2: Tree.Link;    rule: CARDINAL;    FOR i: CARDINAL IN [0..qI) DO      top ¬ top-q[i].tag.pLength+1;      SELECT rule ¬ prodData[q[i].transition].rule FROM       -- basic tree building        0  => -- TABLE: MesaTab  TYPE: ParseTable  EXPORTS: SELF	      -- GOAL:  goal	      --TERMINALS:	      --  id  num  lnum  flnum  string  lstring  char atom	      --  ,  ;  :  ..  =>  _	      --  =  #  <  >  <=  >=  ~	      --  +  -  *  /  ^  .  @  !  '|	      --  RECORD  POINTER  VAR	      --  ARRAY  SEQUENCE  DESCRIPTOR	      --  PROCEDURE  PROC  PORT  SIGNAL  ERROR  PROCESS	      --  PROGRAM  MONITOR  DEFINITIONS  ZONE  RELATIVE  LONG	      --  TYPE  FRAME  TO  ORDERED  UNCOUNTED	      --  BASE  OF  PACKED  RETURNS RESIDENT	      --  MONITORED  OVERLAID  COMPUTED  MACHINE  DEPENDENT	      --  DIRECTORY  IMPORTS  EXPORTS  SHARES  LOCKS  USING	      --  PUBLIC  PRIVATE	      --  ENTRY  INTERNAL  INLINE  READONLY  CODE	      --  ABS  ALL  AND  APPLY  MAX  MIN  MOD	      --  NOT  OR  ORD  PRED  LENGTH  NEW  START  SUCC  VAL	      --  FORK  JOIN  LOOPHOLE  NARROW  ISTYPE   SIZE	      --  FIRST  LAST  NIL  TRASH  NULL  IF  THEN  ELSE	      --  WITH  FROM  FOR  DECREASING  IN	      --  THROUGH  UNTIL  WHILE  REPEAT  FINISHED	      --  RETURN  EXIT  LOOP  GOTO  GO	      --  FREE  WAIT  RESTART  NOTIFY  BROADCAST  STOP	      --  RESUME  REJECT  CONTINUE  RETRY  TRANSFER  STATE	      --  OPEN  ENABLE  ANY  EXITS	      --  )  ]  }  END  ENDLOOP  ENDCASE	      --  (  [  {  BEGIN  DO  SELECT	      --  MSBIT LSBIT NATIVE WORD8 WORD16 WORD32	      --ALIASES:	      --  id       tokenID	      --  num      tokenNUM	      --  lnum     tokenLNUM	      --  flnum    tokenFLNUM	      --  string   tokenSTR	      --  lstring  tokenLSTR	      --  char     tokenCHAR	      --  atom     tokenATOM	      --  -        tokenMINUS	      --  .        tokenDOT	      --  ..       tokenDOTS	      --  =        tokenEQUAL	      --  =>       tokenARROW	      --  <        tokenLESS	      --  <=       tokenLE	      --  >        tokenGREATER	      --  >=       tokenGE	      --  #        tokenNE	      --  .        InitialSymbol	      --PRODUCTIONS:              -- goal           ::= . module . 	      -- goal           ::= . module .. 	  NULL;        1  => -- module         ::= directory identlist cedar proghead trusted checked block	  BEGIN	  IF ~BoolV[top+6] THEN InsertTree[syms, Tree.Null,2];	  PushTree[syms, Tree.Null];	  t1 ¬ MakeNode[syms, body,4];	  t2 ¬ ExtractTree[syms, 2];	  PushTree[syms, ExtractTree[syms, 5]];  PushTree[syms, t2];	  PushTree[syms, t1]; SetAttr[syms, 1,checked]; SetAttr[syms, 2,trusted];	  trusted ¬ BoolV[top+4];  checked ¬ BoolV[top+5];	  PushNode[syms, decl,3];  LinkToSource[top+1];	  SetAttrs[TRUE,TRUE,FALSE];	  PushNode[syms, module,6];  LinkToSource[top];  SetAttrV[1,top+3];	  END;       2  => -- module         ::= directory identlist cedar defhead defbody 	  BEGIN	  IF ~BoolV[top+4] THEN InsertTree[syms, Tree.Null,2];	  PushTree[syms, Tree.Null];	  t1 ¬ MakeNode[syms, body,4];  t2 ¬ ExtractTree[syms, 2];	  PushTree[syms, ExtractTree[syms, 5]];  PushTree[syms, t2];  PushTree[syms, t1];	  PushNode[syms, decl,3];  LinkToSource[top+1];	  SetAttrs[TRUE,TRUE,FALSE];	  PushNode[syms, module,6];  LinkToSource[top];  SetAttrV[1,top+3];	  END;        3  => -- includeitem    ::= id : FROM string using	  BEGIN	  PushStringLitV[top+3];  PushHashV[top];	  PushNode[syms, diritem,-3];  LinkToSource[top];	  END;        4  => -- includeitem    ::= id : TYPE using	      -- includeitem    ::= id using	  BEGIN	  PushTree[syms, Tree.Null];  PushHashV[top];	  PushNode[syms, diritem,-3];  LinkToSource[top];	  END;        5  => -- includeitem    ::= id : TYPE id using	  BEGIN	  PushHashV[top+3];  PushHashV[top];	  PushNode[syms, diritem,-3];  LinkToSource[top];	  END;        6  => -- cedar          ::=	  safety ¬ trusted ¬ checked ¬ FALSE;        7  => -- proghead       ::= resident safe class arguments locks interface = public 	  BEGIN	  t1 ¬ ExtractTree[syms, 4];	  PushTree[syms, ExtractTree[syms, 5]];  PushTree[syms, ExtractTree[syms, 5]];	  PushNode[syms, programTC,2]; SetAttrV[1,top+2]; SetAttrV[3,top+1];	  IF ~BoolV[top+2] OR t1 # Tree.Null THEN PushTree[syms, t1]	  ELSE {	    PushHash[syms, P1.IdOfLock[]];  PushTree[syms, Tree.Null];	    PushNode[syms, lambda,-2];  SetAttr[syms, 1,TRUE];  SetAttr[syms, 2,public]};	  machineDep ¬ FALSE;	  mdStatus ¬ MDRDefs.notMD;	  END;	<< Combine productions to keep within PGS limit.>>        8  => -- resident       ::=	      -- resident       ::= RESIDENT	  SELECT q[i].tag.pLength FROM	    0 => { 	      public ¬ FALSE; SetBoolV[top,FALSE]; l[top] ¬ P1.InputLoc[]};	    1 => {public ¬ FALSE; SetBoolV[top,TRUE]};	    ENDCASE => ERROR;        9  => -- defhead        ::= definitions locks imports shares = public 	  BEGIN	  t1 ¬ ExtractTree[syms, 3];	  t2 ¬ PopTree[syms];  PushTree[syms, Tree.Null];  PushTree[syms, t2];	  PushNode[syms, definitionTC,0];  PushTree[syms, t1];	  SetBoolV[top,FALSE];  machineDep ¬ FALSE;	  mdStatus ¬ MDRDefs.notMD;	  END;       10  => -- definitions    ::= DEFINITIONS 	  public ¬ TRUE;       11  => -- defbody        ::= BEGIN open declist END               -- defbody        ::= BEGIN open declist ; END               -- defbody        ::= { open declist }               -- defbody        ::= { open declist ; } 	  {PushListV[top+2]; PushTree[syms, Tree.Null]; SetBoolV[top,TRUE]};       12  => -- locks          ::= LOCKS primary lambda	  {PushNode[syms, lambda,-2]; SetAttr[syms, 1,FALSE]; SetAttr[syms, 2,FALSE]};       13  => -- lambda         ::= USING ident typeexp	  BEGIN	  PushTree[syms, Tree.Null];  PushNode[syms, decl,3];  LinkToSource[top+1];	  SetAttrs[FALSE,FALSE,FALSE];	  END;	  <<Combine productions to 1 rule to keep in PGS limit.>>       14  => -- moduleitem     ::= id              -- moduleitem     ::= id : id	    	  SELECT q[i].tag.pLength FROM	  1 =>	    BEGIN	    PushHashV[top];  PushHashV[top];	    PushNode[syms, item,2];  SetAttr[syms, 1,FALSE];  LinkToSource[top];	    END;          3 =>	    BEGIN	    PushHashV[top];  PushHashV[top+2];	    PushNode[syms, item,2];  SetAttr[syms, 1,TRUE];  LinkToSource[top];	    END;	  ENDCASE => ERROR;       15  => -- declaration    ::= identlist public entry readonly typeexp initialization 	  BEGIN	  IF BoolV[top+3] THEN {	    t1 ¬ PopTree[syms];	    PushNode[syms, varTC,1]; SetAttrs[FALSE,FALSE,TRUE]; PushNode[syms, longTC,1];	    PushTree[syms, t1]};	  IF OpV[top+2] # none THEN PushNodeV[top+2,1];	  PushNode[syms, decl,3];  LinkToSource[top];	  SetAttrV[1,top+5]; SetAttr[syms, 2,public]; public ¬ BoolV[top+1];	  END;       16  => -- declaration    ::= identlist public TYPE = public typeexp default           BEGIN	  public ¬ BoolV[top+4];	  PushNode[syms, typedecl,3];  LinkToSource[top];	  SetAttrs[TRUE,public,FALSE];  public ¬ BoolV[top+1];	  END;       17  => -- declaration    ::= identlist public TYPE optsize           BEGIN	  PushNode[syms, opaqueTC,1];  PushTree[syms, Tree.Null];	  PushNode[syms, typedecl,3];  LinkToSource[top];	  SetAttrs[TRUE,public,FALSE];  public ¬ BoolV[top+1];	  END;       18  => -- public         ::= PUBLIC	  {SetBoolV[top,public]; public ¬ TRUE};       19  => -- public         ::= PRIVATE              -- procaccess     ::=	  {SetBoolV[top, public]; public ¬ FALSE};       20  => -- public         ::=	  SetBoolV[top,public];       21  => -- entry          ::= ENTRY	  SetOpV[top,entry];       22  => -- entry          ::= INTERNAL	  SetOpV[top,internal];       23  => -- entry          ::=	  {SetOpV[top,none]; l[top] ¬ P1.InputLoc[]};       24  => -- idlist'        ::= id 	      -- identlist'     ::= id : 	  {PushHashV[top]; v[top].s ¬ -1};       25  => -- identlist'     ::= id position : 	  {PushHashV[top]; PushNode[syms, item,-2]; v[top].s ¬ -1};       26  => -- idlist'        ::= id , idlist' 	      -- identlist'     ::= id , identlist' 	  {PushHashV[top]; v[top].s ¬ v[top+2].s-1};       27  => -- identlist'     ::= id position , identlist' 	  BEGIN	  PushTree[syms, ExtractTree[syms, -(v[top+3].s-1)]];	  PushHashV[top];  PushNode[syms, item,-2];  v[top].s ¬ v[top+3].s-1;	  END;       28  => -- position       ::= ( exp optbits ) 	  PushNode[syms, item,2];       29  => -- optbits        ::= : bounds 	      -- interval       ::= [ bounds ]           PushNode[syms, intCC,2];       30  => -- interval       ::= [ bounds )           PushNode[syms, intCO,2];       31  => -- interval       ::= ( bounds ]           PushNode[syms, intOC,2];       32  => -- interval       ::= ( bounds )           PushNode[syms, intOO,2];       33  => -- typeexp        ::= id 	      -- range          ::= id	  PushHashV[top];       34  => -- typeid'        ::= id . id 	  {PushHashV[top]; PushHashV[top+2]; PushNode[syms, dot,2]};       35  => -- typeid'        ::= typeid' . id               -- typeappl       ::= typeappl . id 	  {PushHashV[top+2]; PushNode[syms, dot,2]};       36  => -- typeid         ::= id id 	  {PushHashV[top+1]; PushHashV[top]; PushNode[syms, discrimTC,2]};       37  => -- typeid         ::= id typeid 	  {PushHashV[top]; PushNode[syms, discrimTC,2]};       38  => -- typeappl       ::= id length 	  {PushHashV[top]; PushNode[syms, apply,-2]};       39  => -- typeappl       ::= typeid length               -- typeappl       ::= typeappl length 	  PushNode[syms, apply,2];       40  => -- typecons       ::= interval 	  {PushSe[syms, dataPtr.idINT]; PushNode[syms, subrangeTC,-2]};       41  => -- typecons       ::= id interval 	      -- range          ::= id interval	  {PushHashV[top]; PushNode[syms, subrangeTC,-2]};       42  => -- typecons       ::= typeid interval 	      -- range          ::= typeid interval	  PushNode[syms, subrangeTC,2];       43  => -- typecons       ::= dependent { elementlist }	  BEGIN	  PushListV[top+2];	  PushNode[syms, enumeratedTC,1];  SetAttr[syms, 1,public]; SetAttr[syms, 2,machineDep];	  machineDep ¬ BoolV[top];	  END;       44  => -- ident     	::= id position :              -- element        ::= id ( exp ) 	  {PushHashV[top]; PushNode[syms, item,-2]};       45  => -- element        ::= ( exp )	  {PushHash[syms, Symbols.HTNull]; PushNode[syms, item,-2]};       46  => -- typecons       ::= dependentRec monitored RECORD reclist	  BEGIN	  mdStatusTree: Tree.Link = MakeNode[syms, initlist, 0];	  mdStatusNode: Tree.Index = GetNode[syms, mdStatusTree];	  syms.tb[mdStatusNode].info ¬ MDRDefs.ToTreeInfo[mdStatus];	  IF ~BoolV[top+1] THEN {	    PushTree[syms, mdStatusTree];	    PushNode[syms, recordTC,2];}	  ELSE {	    t1 ¬ PopTree[syms];  v[top+2].s ¬ ListLength[syms, t1];	    t1 ¬ UpdateList[syms, t1,DetachItem];  t1 ¬ FreeTree[syms, t1];	    PushList[syms, v[top+2].s+1]; 	    PushTree[syms, mdStatusTree]; PushNode[syms, monitoredTC,2]};	  SetAttr[syms, 1,mdStatus.machineDep]; SetAttrV[2,top+3];	  mdStatus ¬ MDStatusV[top];	  SetAttr[syms, 3,TRUE];	  END;       47  => -- typecons       ::= ordered base pointertype	  BEGIN	  t2 ¬ MakeNode[syms, pointerTC,1];	  t1 ¬ PopTree[syms];	  PushTree[syms, t2];	  SetAttrV[1,top];  SetAttrV[2,top+1];  SetAttrV[3,top+2];	  IF t1 # Tree.Null THEN {PushTree[syms, t1]; PushNode[syms, subrangeTC,2]};	  END;       48  => -- typecons       ::= VAR typeexp	  {PushNode[syms, varTC,1]; SetAttrs[FALSE,FALSE,FALSE]; PushNode[syms, longTC,1]};       49  => -- typecons       ::= packed ARRAY indextype OF typeexp	  {PushNode[syms, arrayTC,2]; SetAttrV[3,top]};       50  => -- typecons       ::= DESCRIPTOR FOR readonly typeexp	  {PushNode[syms, arraydescTC,1]; SetAttrV[3,top+2]};       51  => -- typecons       ::= safe transfermode arguments	  {PushNodeV[top+1,2]; SetAttrV[3,top]};       52  => -- safe           ::=	  {SetBoolV[top,safety]; l[top] ¬ P1.InputLoc[]};       53  => -- typecons       ::= id RELATIVE typeexp	  {PushHashV[top]; PushNode[syms, relativeTC,-2]};       54  => -- typecons       ::= typeid RELATIVE typeexp	  PushNode[syms, relativeTC,2];       55  => -- typecons       ::= heap ZONE	  {PushNode[syms, zoneTC,0]; SetAttrV[1,top]; SetAttr[syms, 2,FALSE]};       56  => -- typecons       ::= LONG typeexp	  PushNode[syms, longTC,1];       57  => -- typecons       ::= FRAME [ id ]	  {PushHashV[top+2]; PushNode[syms, frameTC,1]};       58  => -- monitored      ::= MONITORED	  BEGIN	  PushSe[syms, dataPtr.idLOCK];	  PushField[P1.IdOfLock[], PopTree[syms], Tree.Null, top];	  SetBoolV[top,TRUE];	  END;      59  => -- dependentRec	::= bitNumOption unitOption MACHINE DEPENDENT           {saveMDStatus: MDRDefs.MDStatus = mdStatus;	    mdStatus.machineDep ¬ TRUE;	    mdStatus.bitOption ¬ MDStatusV[top].bitOption;	    mdStatus.unitOption ¬ MDStatusV[top+1].unitOption;	    SetMDStatusV[top,saveMDStatus];};      60  => -- dependentRec	::= unitOption bitNumOption MACHINE DEPENDENT           {saveMDStatus: MDRDefs.MDStatus = mdStatus;	    mdStatus.machineDep ¬ TRUE;	    mdStatus.bitOption ¬ MDStatusV[top+1].bitOption;	    mdStatus.unitOption ¬ MDStatusV[top].unitOption;	    SetMDStatusV[top,saveMDStatus];};      61  => -- dependentRec	::= bitNumOption MACHINE DEPENDENT           {saveMDStatus: MDRDefs.MDStatus = mdStatus;	    mdStatus.machineDep ¬ TRUE;	    mdStatus.bitOption ¬ MDStatusV[top].bitOption;	    mdStatus.unitOption ¬ MDRDefs.defaultUnitOption;	    SetMDStatusV[top,saveMDStatus];};      62  => -- dependentRec	::= unitOption MACHINE DEPENDENT           {saveMDStatus: MDRDefs.MDStatus = mdStatus;	    mdStatus.machineDep ¬ TRUE;	    mdStatus.bitOption ¬ MDRDefs.defaultBitOption;	    mdStatus.unitOption ¬ MDStatusV[top].unitOption;	    SetMDStatusV[top,saveMDStatus];};      63  => -- dependentRec	::= MACHINE DEPENDENT	   {SetMDStatusV[top,mdStatus]; mdStatus ¬ MDRDefs.defaultMD};      64  => -- dependentRec	::=	  {SetMDStatusV[top,mdStatus];	   IF mdStatus #  MDRDefs.notMD THEN mdStatus ¬ MDRDefs.defaultMD;};       65  => --  bitNumOption	::= MSBIT              --  bitNumOption	::= NATIVE	  SetMDStatusV[top, [TRUE, msBit, NULL, 0]];      66  => -- bitNumOption	::= LSBIT	  SetMDStatusV[top, [TRUE, lsBit, NULL, 0]];      67  => -- unitOption	::= WORD8	  SetMDStatusV[top, [TRUE, NULL, word8, 0]];      68  => -- unitOption	::= WORD16	  SetMDStatusV[top, [TRUE, NULL, word16, 0]];       69  => -- unitOption	::= WORD32	  SetMDStatusV[top, [TRUE, NULL, word32, 0]];       70  => -- dependent      ::= MACHINE DEPENDENT	  {SetBoolV[top,machineDep]; machineDep ¬ TRUE};       71  => -- dependent      ::=	  SetBoolV[top,machineDep];       72  => -- reclist        ::= [ ]              -- reclist        ::= NULL	  {PushList[syms, 0]; SetBoolV[top,FALSE]};       73  => -- reclist        ::= [ pairlist ]	      -- reclist        ::= [ typelist ]	  {PushListV[top+1]; SetBoolV[top,FALSE]};       74  => -- reclist        ::= [ pairlist , variantpair ]	  {PushList[syms, v[top+1].s+1]; SetBoolV[top,TRUE]};       75  => -- reclist        ::= [ variantpart default ]	  {t1 ¬ PopTree[syms]; AnonField[PopTree[syms], t1, top]; SetBoolV[top,TRUE]};       76  => -- pairitem       ::= identlist public typeexp default              -- variantpair    ::= identlist public variantpart default	  BEGIN	  PushNode[syms, decl,3];  LinkToSource[top];	  SetAttrs[FALSE,public,FALSE]; public ¬ BoolV[top+1];	  END;       77  => -- defaultopt     ::= TRASH              -- defaultopt     ::= NULL	  PushNode[syms, void,0];       78  => -- defaultopt     ::= exp '| TRASH              -- defaultopt     ::= exp '| NULL	  {PushNode[syms, void,0]; PushList[syms, 2]};       79  => -- variantpart    ::= SELECT vcasehead FROM variantlist ENDCASE              -- variantpart    ::= SELECT vcasehead FROM variantlist , ENDCASE	  BEGIN	  PushListV[top+3];	  PushNode[syms, unionTC,2]; SetAttr[syms, 1,machineDep]; SetAttrV[2,top+1];	  END;       80  => -- variantpart    ::= packed SEQUENCE vcasehead OF typeexp	  BEGIN	  PushNode[syms, sequenceTC,2];	  SetAttr[syms, 1,machineDep]; SetAttrV[2,top+2]; SetAttrV[3,top];	  END;       81  => -- vcasehead      ::= ident public tagtype	  BEGIN	  PushTree[syms, Tree.Null];  PushNode[syms, decl,3];  LinkToSource[top];	  SetAttrs[FALSE,public,FALSE]; public ¬ BoolV[top+1];	  SetBoolV[top,FALSE];	  END;       82  => -- vcasehead      ::= COMPUTED tagtype	  {AnonField[PopTree[syms], Tree.Null, top]; SetBoolV[top,FALSE]};       83  => -- vcasehead      ::= OVERLAID tagtype	  {AnonField[PopTree[syms], Tree.Null, top]; SetBoolV[top,TRUE]};       84  => -- tagtype        ::= *	  PushNode[syms, implicitTC,0];       85  => -- variantitem    ::= idlist => reclist	  BEGIN	  PushNode[syms, variantTC,1];	  SetAttr[syms, 1,machineDep];  SetAttrV[2,top+2];  SetAttr[syms, 3,TRUE];	  PushTree[syms, Tree.Null];  PushNode[syms, typedecl,3];  LinkToSource[top];	  SetAttrs[TRUE,public,FALSE];	  END;       86  => -- typelist       ::= typecons default	      -- typelist       ::= typeid default	  {t1 ¬ PopTree[syms]; AnonField[PopTree[syms], t1, top]; v[top].s ¬ -1};       87  => -- typelist       ::= id	  {PushHashV[top]; AnonField[PopTree[syms], Tree.Null, top]; v[top].s ¬ -1};       88  => -- typelist       ::= id _ defaultopt	  {t1 ¬ PopTree[syms]; PushHashV[top]; AnonField[PopTree[syms], t1, top]; v[top].s ¬ -1};       89  => -- typelist       ::= typecons default , typelist	      -- typelist       ::= typeid default , typelist	  BEGIN	  t1 ¬ ExtractTree[syms, -(v[top+3].s-1)]; AnonField[ExtractTree[syms, -(v[top+3].s-1)], t1, top];	  v[top].s ¬ v[top+3].s-1;	  END;       90  => -- typelist       ::= id , typelist	  {PushHashV[top]; AnonField[PopTree[syms], Tree.Null, top]; v[top].s ¬ v[top+2].s-1};       91  => -- typelist       ::= id _ defaultopt , typelist	  BEGIN	  t1 ¬ ExtractTree[syms, -(v[top+4].s-1)]; PushHashV[top]; AnonField[PopTree[syms], t1, top];	  v[top].s ¬ v[top+4].s-1;	  END;       92  => -- pointertype    ::= pointerprefix	  {PushSe[syms, dataPtr.idANY]; SetBoolV[top,FALSE]};       93  => -- pointertype    ::= pointerprefix TO readonly typeexp	  SetBoolV[top, BoolV[top+2]];       94  => -- transfermode   ::= PROCEDURE              -- transfermode   ::= PROC	  SetOpV[top,procTC];       95  => -- transfermode   ::= PORT	  SetOpV[top,portTC];       96  => -- transfermode   ::= SIGNAL	  SetOpV[top,signalTC];       97  => -- transfermode   ::= ERROR	  SetOpV[top,errorTC];       98  => -- transfermode   ::= PROCESS	  SetOpV[top,processTC];       99  => -- transfermode   ::= PROGRAM	  SetOpV[top,programTC];      100  => -- initialization ::=	  {PushTree[syms, Tree.Null]; SetBoolV[top,FALSE]};      101  => -- initvalue      ::= procaccess trusted checked inline block	  BEGIN	  IF ~BoolV[top+4] THEN InsertTree[syms, Tree.Null,2];	  PushTree[syms, Tree.Null];	  PushNode[syms, body,4];  SetAttrV[3,top+3];	  SetAttr[syms, 1,checked]; SetAttr[syms, 2,trusted];	  trusted ¬ BoolV[top+1]; checked ¬ BoolV[top+2];  public ¬ BoolV[top];	  END;      102  => -- initvalue      ::= CODE	  PushNode[syms, signalinit,0];      103  => -- initvalue      ::= procaccess trusted checked MACHINE CODE BEGIN codelist END              -- initvalue      ::= procaccess trusted checked MACHINE CODE { codelist }	  BEGIN	  PushProperListV[top+6]; PushNode[syms, inline,1];	  SetAttr[syms, 1,checked]; SetAttr[syms, 2,trusted];	  trusted ¬ BoolV[top+1]; checked ¬ BoolV[top+2];  public ¬ BoolV[top];	  END;      104  => -- trusted        ::=	  SetBoolV[top,trusted];      105  => -- codelist       ::= orderlist	  {PushListV[top]; v[top].s ¬ 1};      106  => -- codelist       ::= codelist ; orderlist	  {PushListV[top+2]; v[top].s ¬ v[top].s+1};      107  => -- statement      ::= IF exp THEN statement 	  {PushTree[syms, Tree.Null]; PushNode[syms, if,3]; LinkToSource[top]};      108  => -- statement      ::= IF exp THEN balstmt ELSE statement               -- balstmt        ::= IF exp THEN balstmt ELSE balstmt 	  {PushNode[syms, if,3]; LinkToSource[top]};      109  => -- statement      ::= casehead casestmtlist ENDCASE => statement              -- balstmt        ::= casehead casestmtlist ENDCASE => balstmt	  BEGIN	  t1 ¬ PopTree[syms];  PushProperListV[top+1];  PushTree[syms, t1];	  IF BoolV[top] THEN PushNode[syms, bind,4] ELSE PushNode[syms, case,3];	  LinkToSource[top];	  END;      110  => -- basicstmt      ::= lhs	  BEGIN	  t1 ¬ PopTree[syms];  PushTree[syms, t1];	  IF OpName[syms, t1] # apply THEN {	    PushTree[syms, Tree.Null]; PushNode[syms, apply,2]; SetAttr[syms, 1, FALSE]};	  LinkToSource[top];	  END;      111  => -- basicstmt      ::= lhs _ exp 	  {PushNode[syms, assign,2]; LinkToSource[top]};      112  => -- basicstmt      ::= [ explist ] _ exp 	  {PushNode[syms, extract,2]; LinkToSource[top]};      113  => -- basicstmt      ::= trusted checked block 	  BEGIN	  IF BoolV[top+2] THEN {	    PushNode[syms, block,2];	    SetAttr[syms, 1,checked]; SetAttr[syms, 2,trusted];  LinkToSource[top+2]}	  ELSE IF checked # BoolV[top+1] OR (~checked AND trusted) THEN {	    PushNode[syms, checked,1]; 	    SetAttr[syms, 1,checked]; SetAttr[syms, 2,trusted];  LinkToSource[top+2]};	  trusted ¬ BoolV[top]; checked ¬ BoolV[top+1];	  t1 ¬ ExtractTree[syms, 2];	  IF t1 # Tree.Null THEN {	    PushTree[syms, t1]; PushNode[syms, open,-2]; LinkToSource[top+2]};	  END;      114  => -- basicstmt      ::= casehead casestmtlist ENDCASE	  BEGIN	  PushProperListV[top+1];  PushTree[syms, Tree.Null];	  IF BoolV[top] THEN PushNode[syms, bind,4] ELSE PushNode[syms, case,3];	  LinkToSource[top];	  END;      115  => -- basicstmt      ::= forclause dotest DO scope doexit ENDLOOP 	  BEGIN	  IF BoolV[top+3] THEN {	    t1 ¬ PopTree[syms];  t2 ¬ PopTree[syms];	    PushNode[syms, block,2]; SetAttr[syms, 1,checked]; SetAttr[syms, 2,trusted]; LinkToSource[top+2];	    PushTree[syms, t2];  PushTree[syms, t1]};	  PushNode[syms, do,6];  LinkToSource[top];	  END;      116  => -- basicstmt      ::= EXIT 	  {PushNode[syms, exit,0]; LinkToSource[top]};      117  => -- basicstmt      ::= LOOP 	  {PushNode[syms, loop,0]; LinkToSource[top]};      118  => -- basicstmt      ::= GOTO id 	  {PushHashV[top+1]; PushNode[syms, goto,1]; LinkToSource[top]};      119  => -- basicstmt      ::= GO TO id 	  {PushHashV[top+2]; PushNode[syms, goto,1]; LinkToSource[top]};      120  => -- basicstmt      ::= RETURN optargs	  {PushNode[syms, return,1]; SetAttrV[3,top+1]; LinkToSource[top]};      121  => -- basicstmt      ::= transfer lhs	  {PushNodeV[top,1]; LinkToSource[top]};      122  => -- basicstmt      ::= free [ exp optcatch ]	  BEGIN	  IF BoolV[top+3] THEN {	    t1 ¬ PopTree[syms]; PushTree[syms, Tree.Null]; PushTree[syms, t1]; PushNode[syms, free,4]}	  ELSE  {PushTree[syms, Tree.Null]; PushNode[syms, free,3]};	  LinkToSource[top];	  END;      123  => -- basicstmt      ::= WAIT lhs	  {PushNode[syms, wait,1]; LinkToSource[top]};      124  => -- basicstmt      ::= ERROR	  {PushNode[syms, syserror,0]; LinkToSource[top]};      125  => -- basicstmt      ::= STOP	  {PushNode[syms, stop,0]; LinkToSource[top]};      126  => -- basicstmt      ::= NULL	  {PushNode[syms, null,0]; LinkToSource[top]};      127  => -- basicstmt      ::= RESUME optargs	  {PushNode[syms, resume,1]; SetAttrV[3,top+1]; LinkToSource[top]};      128  => -- basicstmt      ::= REJECT	  {PushNode[syms, reject,0]; LinkToSource[top]};      129  => -- basicstmt      ::= CONTINUE	  {PushNode[syms, continue,0]; LinkToSource[top]};      130  => -- basicstmt      ::= RETRY	  {PushNode[syms, retry,0]; LinkToSource[top]};      131  => -- basicstmt      ::= lhs _ STATE	  {PushNode[syms, dsk,1]; LinkToSource[top]};      132  => -- basicstmt      ::= STATE _ lhs	  {PushNode[syms, lsk,1]; LinkToSource[top]};      133  => -- block          ::= BEGIN scope exits END              -- block          ::= { scope exits }	  IF BoolV[top+2] THEN {  -- an exits clause is present; build a label node	    IF BoolV[top+1] THEN { 	      t1 ¬ PopTree[syms];	      PushNode[syms, block,2]; SetAttr[syms, 1,checked]; SetAttr[syms, 2,trusted]; LinkToSource[top+1];	      PushTree[syms, t1]};	    SetBoolV[top,FALSE];  PushNode[syms, label,2];  LinkToSource[top]}	  ELSE -- things are unchanged; propogate the "block needs to be made" bit	    SetBoolV[top,BoolV[top+1]];     134  => -- scope          ::= open enables statementlist	  BEGIN	  PushListV[top+2];	  SetBoolV[top,FALSE];	  IF BoolV[top+1] THEN {PushNode[syms, enable,2]; LinkToSource[top+1]};	  END;     135  => -- scope          ::= open enables declist ; statementlist	  BEGIN	  PushListV[top+4];	  t1 ¬ PopTree[syms]; PushListV[top+2]; PushTree[syms, t1];	  IF BoolV[top+1] THEN {	    PushNode[syms, block,2]; SetAttr[syms, 1,checked]; SetAttr[syms, 2,checked]; LinkToSource[top+2];	    PushNode[syms, enable,2];  LinkToSource[top+1];  SetBoolV[top,FALSE]}	  ELSE SetBoolV[top,TRUE];	  END;      136  => -- binditem       ::= exp	  {PushHash[syms, Symbols.HTNull]; PushNode[syms, item,-2]; LinkToSource[top]};      137  => -- binditem       ::= id : exp	  {PushHashV[top]; PushNode[syms, item,-2]; LinkToSource[top]};      138  => -- exits          ::= EXITS exitlist	  {PushListV[top+1]; SetBoolV[top,TRUE]};      139  => -- casestmtitem   ::= caselabel => statement	      -- caseexpitem    ::= caselabel => exp	      -- exititem       ::= idlist => statement	  {PushNode[syms, item,2]; LinkToSource[top]};      140  => -- casetest       ::= optrelation 	  {PushTree[syms, Tree.Null]; PushNodeV[top,-2]};      141  => -- casetest       ::= exp 	  {PushTree[syms, Tree.Null]; PushNode[syms, relE,-2]};      142  => -- caselabel      ::= ident typeexp	      -- controlid      ::= ident typeexp 	  BEGIN	  PushTree[syms, Tree.Null]; PushNode[syms, cast,1];  PushNode[syms, decl,3];  LinkToSource[top];	  SetAttrs[FALSE,public,FALSE];	  END;      143  => -- forclause      ::= FOR controlid _ exp , exp 	  PushNode[syms, forseq,3];      144  => -- forclause      ::= FOR controlid direction IN range 	  {PushTree[syms, Tree.Null]; PushNodeV[top+2,3]};      145  => -- forclause      ::= THROUGH range	  {InsertTree[syms, Tree.Null,2]; PushTree[syms, Tree.Null]; PushNode[syms, upthru,-3]};      146  => -- direction      ::= DECREASING 	  SetOpV[top,downthru];      147  => -- direction      ::=  	  SetOpV[top,upthru];      148  => -- dotest         ::= UNTIL exp 	  PushNode[syms, not,1];      149  => -- doexit         ::=	  {PushTree[syms, Tree.Null]; PushTree[syms, Tree.Null]};      150  => -- doexit         ::= REPEAT exitlist	  {PushListV[top+1]; PushTree[syms, Tree.Null]};      151  => -- doexit         ::= REPEAT exitlist FINISHED => statement	      -- doexit         ::= REPEAT exitlist FINISHED => statement ;	  {t1 ¬ PopTree[syms]; PushListV[top+1]; PushTree[syms, t1]};       -- error or unimplemented	ENDCASE =>  ProcessQueueCont[rule: rule, top: top];      ENDLOOP};        ProcessQueueCont: PROC [rule, top: CARDINAL] = {    t1: Tree.Link;    SELECT rule FROM      152  => -- enables        ::= ENABLE catchcase ;	  {PushTree[syms, Tree.Null]; PushNode[syms, catch,2]; SetBoolV[top,TRUE]};      153  => -- enables        ::= ENABLE catchany ;	  {PushTree[syms, Tree.Null]; PushNode[syms, catch,-2]; SetBoolV[top,TRUE]};      154  => -- enables        ::= ENABLE BEGIN catchlist END ;              -- enables        ::= ENABLE { catchlist } ;	  BEGIN	  t1 ¬ PopTree[syms];	  PushListV[top+2];  PushTree[syms, t1];  PushNode[syms, catch,2];	  SetBoolV[top,TRUE];	  END;      155  => -- catchlist      ::= catchhead	  PushTree[syms, Tree.Null];      156  => -- catchlist      ::= catchhead catchcase	  {v[top].s ¬ v[top].s + 1; PushTree[syms, Tree.Null]};      157  => -- catchcase      ::= lhslist => statement	  BEGIN	  t1 ¬ PopTree[syms];  PushListV[top];  PushTree[syms, t1];	  PushNode[syms, item,2];  LinkToSource[top];	  END;      158  => -- optargs        ::= [ explist ]	  BEGIN	  t1 ¬ PopTree[syms];	  IF t1 = Tree.Null THEN PushProperList[syms, 0] ELSE PushTree[syms, t1];	  SetBoolV[top,FALSE];	  END;      159  => -- optargs        ::= 	  {PushTree[syms, Tree.Null]; l[top] ¬ P1.InputLoc[]; SetBoolV[top,FALSE]};      160  => -- transfer       ::= SIGNAL	  SetOpV[top,signal];      161  => -- transfer       ::= ERROR	  SetOpV[top,error];      162  => -- transfer       ::= RETURN WITH ERROR	  SetOpV[top,xerror];      163  => -- transfer       ::= START	  SetOpV[top,start];      164  => -- transfer       ::= RESTART	  SetOpV[top,restart];      165  => -- transfer       ::= JOIN	  SetOpV[top,join];      166  => -- transfer       ::= NOTIFY	  SetOpV[top,notify];      167  => -- transfer       ::= BROADCAST	  SetOpV[top,broadcast];      168  => -- transfer       ::= TRANSFER WITH	  SetOpV[top,xe];      169  => -- transfer       ::= RETURN WITH	  SetOpV[top,xf];       -- expression processing      170  => -- keyitem        ::= id : optexp	  {PushHashV[top]; PushNode[syms, item,-2]};       171  => -- optexp         ::= TRASH              -- optexp         ::= NULL              -- initvalue      ::= TRASH              -- initvalue      ::= NULL	  PushNode[syms, void,0];      172  => -- exp            ::= transferop lhs           PushNodeV[top,1];      173  => -- exp            ::= IF exp THEN exp ELSE exp           PushNode[syms, ifx,3];      174  => -- exp            ::= casehead caseexplist ENDCASE => exp 	  BEGIN	  t1 ¬ PopTree[syms];	  PushProperListV[top+1];  PushTree[syms, t1];	  IF BoolV[top] THEN PushNode[syms, bindx,4] ELSE PushNode[syms, casex,3];	  LinkToSource[top];	  END;      175  => -- exp            ::= lhs _ exp           PushNode[syms, assignx,2];      176  => -- exp            ::= [ explist ] _ exp 	  PushNode[syms, extractx,2];      177  => -- exp            ::= ERROR           PushNode[syms, syserrorx,0];      178  => -- disjunct       ::= disjunct OR conjunct           PushNode[syms, or,2];      179  => -- conjunct       ::= conjunct AND negation           PushNode[syms, and,2];      180  => -- negation       ::= not relation         PushNode[syms, not,1];      181  => -- relation       ::= sum optrelation               -- sum            ::= sum addop product               -- product        ::= product multop factor           PushNodeV[top+1,2];      182  => -- optrelation    ::= not relationtail           SetOpV[top, NegatedV[top+1]];      183  => -- relationtail   ::= IN range           SetOpV[top,in];      184  => -- relop          ::= =           SetOpV[top,relE];      185  => -- relop          ::= #           SetOpV[top,relN];      186  => -- relop          ::= <           SetOpV[top,relL];      187  => -- relop          ::= <=           SetOpV[top,relLE];      188  => -- relop          ::= >           SetOpV[top,relG];      189  => -- relop          ::= >=           SetOpV[top,relGE];      190  => -- addop          ::= +           SetOpV[top,plus];      191  => -- addop          ::= -           SetOpV[top,minus];      192  => -- multop         ::= *           SetOpV[top,times];      193  => -- multop         ::= /           SetOpV[top,div];      194  => -- multop         ::= MOD           SetOpV[top,mod];      195  => -- factor         ::= addop primary           IF OpV[top] = minus THEN PushNode[syms, uminus,1];      196  => -- primary        ::= num 	  PushLitV[top];      197  => -- primary        ::= lnum 	  {PushLitV[top]; PushNode[syms, mwconst,1]; SetAttr[syms, 1,FALSE]};      198  => -- primary        ::= flnum 	  {PushLitV[top]; PushNode[syms, mwconst,1]; SetAttr[syms, 1,TRUE]};      199  => -- primary        ::= string 	  PushStringLitV[top];      200  => -- primary        ::= lstring 	  {PushStringLitV[top]; PushNode[syms, llit,1]};      201  => -- primary        ::= atom 	  {PushHashV[top]; PushNode[syms, atom,1]};      202  => -- primary        ::= NIL 	  {PushTree[syms, Tree.Null]; PushNode[syms, nil,1]};      203  => -- primary 	::= [ explist ]	  {PushTree[syms, Tree.Null]; PushNode[syms, apply,-2]; SetAttr[syms, 1, FALSE]};      204  => -- primary        ::= prefixop [ orderlist ]	  {PushListV[top+2]; PushNodeV[top,1]};      205  => -- primary        ::= VAL [ orderlist ]	  {PushListV[top+2]; PushNode[syms, val,1]};      206  => -- primary        ::= ALL [ orderlist ]	  {PushListV[top+2]; PushNode[syms, all,1]};      207  => -- primary        ::= new [ typeexp initialization optcatch ]          {PushNode[syms, new, IF BoolV[top+4] THEN 4 ELSE 3]; SetAttrV[1,top+3]};      208  => -- primary        ::= typeop [ typeexp ]          PushNodeV[top,1];      209  => -- qualifier      ::= . prefixop               -- qualifier      ::= . typeop	  PushNodeV[top+1,1];      210  => -- primary        ::= SIZE [ typeexp ]              -- qualifier      ::= . SIZE          {PushTree[syms, Tree.Null];  PushNode[syms, size,2]};      211  => -- primary        ::= SIZE [ typeexp , exp ]          PushNode[syms, size,2];      212  => -- primary        ::= ISTYPE [ exp , typeexp ]           PushNode[syms, istype,2];      213  => -- primary        ::= @ lhs	  PushNode[syms, addr,1];      214  => -- primary        ::= DESCRIPTOR [ desclist ]	  PushNode[syms, arraydesc,1];      215  => -- lhs            ::= id               -- element        ::= id	      -- ident          ::= id :               -- controlid      ::= id 	  PushHashV[top];      216  => -- lhs            ::= char 	  {PushLitV[top]; PushNode[syms, clit,1]};      217  => -- lhs            ::= NARROW [ exp opttype optcatch ]	  PushNode[syms, narrow, IF BoolV[top+4] THEN 3 ELSE 2];      218  => -- lhs            ::= LOOPHOLE [ exp opttype ]	  PushNode[syms, loophole,2];      219  => -- lhs            ::= APPLY [ exp , exp optcatch ] 	  {PushNode[syms, apply, IF BoolV[top+5] THEN 3 ELSE 2]; SetAttr[syms, 1,TRUE]};      220  => -- qualifier      ::= [ explist optcatch ]	  {PushNode[syms, apply, IF BoolV[top+2] THEN 3 ELSE 2]; SetAttr[syms, 1,FALSE]};      221  => -- qualifier      ::= . id	  {PushHashV[top+1]; PushNode[syms, dot,2]};      222  => -- qualifier      ::= ^	  PushNode[syms, uparrow,1];      223  => -- optcatch       ::= ! catchlist	  BEGIN	  t1 ¬ PopTree[syms];	  PushListV[top+1];  PushTree[syms, t1];  PushNode[syms, catch,2];	  SetBoolV[top,TRUE];	  END;      224  => -- transferop     ::= SIGNAL	  SetOpV[top,signalx];      225  => -- transferop     ::= ERROR	  SetOpV[top,errorx];      226  => -- transferop     ::= START	  SetOpV[top,startx];      227  => -- transferop     ::= JOIN	  SetOpV[top,joinx];      228  => -- transferop     ::= NEW           SetOpV[top,create];      229  => -- transferop     ::= FORK	  SetOpV[top,fork];      230  => -- prefixop       ::= LONG           SetOpV[top,lengthen];      231  => -- prefixop       ::= ABS           SetOpV[top,abs];      232  => -- prefixop       ::= PRED           SetOpV[top,pred];      233  => -- prefixop       ::= SUCC           SetOpV[top,succ];      234  => -- prefixop       ::= ORD           SetOpV[top,ord];      235  => -- prefixop       ::= MIN           SetOpV[top,min];      236  => -- prefixop       ::= MAX           SetOpV[top,max];      237  => -- prefixop       ::= BASE	  SetOpV[top,base];      238  => -- prefixop       ::= LENGTH	  SetOpV[top,length];      239  => -- typeop         ::= FIRST	  SetOpV[top,first];      240  => -- typeop         ::= LAST	  SetOpV[top,last];      241  => -- typeop         ::= NIL	  SetOpV[top,nil];      242  => -- desclist       ::= exp , exp opttype	  PushList[syms, 3];      243  => -- directory      ::= DIRECTORY ;	      -- imports        ::= IMPORTS	      -- exports        ::= EXPORTS 	      -- fieldlist      ::= [ ]              -- pointerprefix  ::= POINTER	  PushTree[syms, Tree.Null];      244  => -- using          ::= USING [ ]              -- defaultopt     ::=	  PushProperList[syms, 0];      245  => -- elementlist    ::=              -- statementlist  ::= 	      -- casestmtlist   ::=              -- exitlist       ::= 	      -- catchhead      ::=	      -- caseexplist    ::=	  v[top].s ¬ 0;      246  => -- includelist    ::= includeitem	      -- modulelist     ::= moduleitem              -- declist        ::=  declaration	      -- pairlist       ::= pairitem	      -- elementlist'   ::= element	      -- variantlist    ::= variantitem	      -- bindlist       ::= binditem	      -- statementlist' ::= statement 	      -- casestmtlist'  ::= casestmtitem	      -- caselabel'     ::= casetest 	      -- exitlist'      ::= exititem	      -- lhslist        ::= lhs	      -- orderlist      ::= optexp 	      -- keylist        ::= keyitem 	      -- caseexplist'   ::= caseexpitem	  v[top].s ¬ 1;      247  => -- includelist    ::= includelist , includeitem	      -- modulelist     ::= modulelist , moduleitem	      -- declist        ::= declist ; declaration 	      -- pairlist       ::= pairlist , pairitem	      -- elementlist'   ::= elementlist' , element	      -- variantlist    ::= variantlist , variantitem	      -- bindlist       ::= bindlist , binditem	      -- statementlist' ::= statementlist' ;  statement 	      -- casestmtlist'  ::= casestmtlist' ; casestmtitem	      -- caselabel'     ::= caselabel' , casetest 	      -- exitlist'      ::= exitlist' ; exititem	      -- catchhead      ::= catchhead  catchcase ;	      -- lhslist        ::= lhslist , lhs	      -- orderlist      ::= orderlist , optexp 	      -- keylist        ::= keylist , keyitem 	      -- caseexplist'   ::= caseexplist' , caseexpitem	  v[top].s ¬ v[top].s+1;      248  => -- idlist         ::= idlist'	      -- identlist      ::= identlist'	      -- explist        ::= orderlist	      -- explist        ::= keylist	      -- caselabel      ::= caselabel' 	  PushListV[top];      249  => -- directory      ::= DIRECTORY includelist ;              -- imports        ::= IMPORTS modulelist	      -- exports        ::= EXPORTS modulelist               -- open           ::= OPEN bindlist ;	      -- fieldlist      ::= [ pairlist ]	      -- fieldlist      ::= [ typelist ]	  PushListV[top+1];      250  => -- class          ::= PROGRAM 	      -- initialization ::= _ initvalue	      -- casehead       ::= SELECT exp FROM	  SetBoolV[top,FALSE];      251  => -- class          ::= MONITOR               -- packed		::= PACKED	      -- readonly       ::= READONLY	      -- reclist        ::= [ variantpair ]	      -- ordered        ::= ORDERED	      -- base           ::= BASE	      -- heap           ::= UNCOUNTED	      -- initialization ::= = initvalue	      -- inline		::= INLINE	      -- optargs        ::= lhs	      -- casehead       ::= WITH binditem SELECT optexp FROM	  SetBoolV[top,TRUE];      252  => -- packed		::=	      -- readonly       ::=	      -- monitored      ::=	      -- ordered        ::=	      -- base           ::=	      -- inline		::=	      -- enables        ::=	      -- exits          ::=	      -- optcatch       ::=	  {SetBoolV[top,FALSE]; l[top] ¬ P1.InputLoc[]};      253  => -- using          ::= USING [ idlist ]	      -- interface      ::= imports exports shares	      -- shares         ::= SHARES idlist 	      -- typeid         ::= typeid'	      -- typeexp        ::= typeid 	      -- typeexp        ::= typecons 	      -- typecons       ::= typeappl 	      -- optsize        ::= [ exp ] 	      -- elementlist    ::= elementlist' 	      -- length         ::= [ exp ] 	      -- default        ::= _ defaultopt 	      -- defaultopt     ::= exp 	      -- tagtype        ::= typeexp 	      -- pointerprefix  ::= POINTER interval 	      -- indextype      ::= typeexp 	      -- arguments      ::= arglist returnlist 	      -- arglist        ::= fieldlist 	      -- returnlist     ::= RETURNS fieldlist 	      -- initvalue      ::= exp 	      -- statement      ::= basicstmt 	      -- balstmt        ::= basicstmt 	      -- dotest         ::= WHILE exp 	      -- catchany       ::= ANY => statement	      -- catchlist      ::= catchhead catchany 	      -- catchlist      ::= catchhead catchany ; 	      -- statementlist  ::= statementlist' 	      -- statementlist  ::= statementlist' ; 	      -- casestmtlist   ::= casestmtlist' 	      -- casestmtlist   ::= casestmtlist' ; 	      -- exitlist	::= exitlist'	      -- exitlist       ::= exitlist' ;	      -- caseexplist    ::= caseexplist' 	      -- caseexplist    ::= caseexplist' , 	      -- optexp         ::= exp 	      -- exp            ::= disjunct 	      -- disjunct       ::=C conjunct 	      -- conjunct       ::=C negation 	      -- negation       ::=C relation 	      -- not            ::= ~ 	      -- not            ::= NOT 	      -- relation       ::= sum 	      -- optrelation    ::= relationtail 	      -- relationtail   ::= relop sum 	      -- range          ::= interval 	      -- range          ::= typeid 	      -- bounds         ::= exp .. exp 	      -- sum            ::=C product 	      -- product        ::=C factor 	      -- factor         ::=C primary 	      -- primary        ::= lhs 	      -- desclist       ::= exp 	      -- lhs            ::= ( exp ) 	      -- lhs            ::= lhs qualifier               -- new            ::= lhs . NEW              -- free           ::= lhs . FREE              -- opttype        ::= , typeexp	  NULL;      254  => -- directory      ::= 	      -- using          ::= 	      -- locks          ::= 	      -- lambda         ::= 	      -- imports        ::= 	      -- exports        ::= 	      -- shares         ::= 	      -- optsize        ::= 	      -- optbits        ::= 	      -- default        ::= 	      -- open           ::=	      -- arglist        ::= 	      -- returnlist     ::= 	      -- indextype      ::=	      -- forclause      ::= 	      -- dotest         ::= 	      -- optexp         ::=	      -- opttype        ::=	  {PushTree[syms, Tree.Null]; l[top] ¬ P1.InputLoc[]};     255  => -- checked         ::=	  {SetBoolV[top,checked];  trusted ¬ checked};      ENDCASE => ERROR};  }.
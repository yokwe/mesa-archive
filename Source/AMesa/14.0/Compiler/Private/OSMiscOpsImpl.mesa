-- Copyright (C) 1981, 1983  by Xerox Corporation. All rights reserved. -- file OSMiscOpsImpl.Mesa (Pilot version)-- Satterthwaite,	 2-Oct-81 16:46:09-- Sweet,	 2-Feb-83 14:01:05-- Lewis,	12-Oct-81 14:31:47-- Haynes,	13-Apr-83 14:57:39DIRECTORY  ComData: TYPE USING [zone],  Inline: TYPE USING [LongNumber, BITXOR],  OSMiscOps: TYPE USING [],  ProcessorFace: TYPE USING [processorID],  Runtime: TYPE USING [GetBcdTime],  Space: TYPE USING [Interval, PageCount, ScratchMap, unknownUsage, Unmap],  SpecialRuntime: TYPE USING [GetCurrentSignal],  Time: TYPE USING [Current],  TimeStamp: TYPE USING [Stamp];OSMiscOpsImpl: PROGRAM    IMPORTS       Inline, ProcessorFace, Runtime, Space, SpecialRuntime, Time,      dataPtr: ComData    EXPORTS OSMiscOps     SHARES ProcessorFace = {  -- bulk free storage management   Pages: PUBLIC PROC [n: Space.PageCount] RETURNS [base: LONG POINTER] = {    base ¬ Space.ScratchMap[count: n, usage: --compiler-- Space.unknownUsage]};  FreePages: PUBLIC PROC [base: LONG POINTER] = {    IF base # NIL THEN [] ¬ Space.Unmap[base]};  -- other free storage management    WordSeq: TYPE = RECORD [SEQUENCE COMPUTED CARDINAL OF CARDINAL];   Words: PUBLIC PROC [nWords: CARDINAL] RETURNS [base: LONG POINTER] = {    RETURN[dataPtr.zone.NEW[WordSeq[nWords]]]};  FreeWords: PUBLIC PROC [base: LONG POINTER] = {    IF base # NIL THEN dataPtr.zone.FREE[@base]};        -- version stamp management  GetNetAndHost: PROC RETURNS [net, host: CARDINAL] = {     sum: WORD = Inline.BITXOR[        ProcessorFace.processorID.a,        Inline.BITXOR[ProcessorFace.processorID.b, ProcessorFace.processorID.c]];    net ¬ sum/256;  host ¬ sum MOD 256};  lastTime: LONG CARDINAL ¬ 0;  GenerateUniqueId: PUBLIC PROC RETURNS [TimeStamp.Stamp] = {    net, host: CARDINAL;    time: LONG CARDINAL;    [net, host] ¬ GetNetAndHost[];    DO      time ¬ Time.Current[];      IF lastTime = 0 OR time # lastTime THEN EXIT;      ENDLOOP;    lastTime ¬ time;    RETURN [TimeStamp.Stamp[net: net, host: host, time: time]]};  ImageId: PUBLIC PROC RETURNS [TimeStamp.Stamp] = {    RETURN [TimeStamp.Stamp[0, 0, Runtime.GetBcdTime[]]]}; -- new version stamp operations   StampSize: NAT = 3;  Stamp: PUBLIC TYPE = RECORD [word: ARRAY [0..StampSize) OF CARDINAL];    AddStamps: PROC [s1, s2: Stamp] RETURNS [sum: Stamp] = {    carry: [0..1] ¬ 0;    i: NAT;    FOR i DECREASING IN [0..StampSize) DO      t: Inline.LongNumber ¬ [lc[LONG[s1.word[i]] + LONG[s2.word[i]] + LONG[carry]]];      sum.word[i] ¬ t.lowbits;  carry ¬ t.highbits;      ENDLOOP;    FOR i DECREASING IN [0..StampSize) WHILE carry # 0 DO      t: Inline.LongNumber ¬ [lc[LONG[sum.word[i]] + LONG[carry]]];      sum.word[i] ¬ t.lowbits;  carry ¬ t.highbits;      ENDLOOP};      RotateStamp: PROC [s: Stamp] RETURNS [Stamp] = INLINE {RETURN [AddStamps[s, s]]};    MergeStamps: PUBLIC PROC [sum, item: Stamp] RETURNS [Stamp] = {    RETURN [AddStamps[RotateStamp[sum], item]]};     -- exception processing  SignalArgs: PUBLIC PROC RETURNS [signal: SIGNAL, message: UNSPECIFIED] = {    [signal, message] ¬ SIGNAL SpecialRuntime.GetCurrentSignal[]};  }.
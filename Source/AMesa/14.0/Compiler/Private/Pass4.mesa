-- Copyright (C) 1982, 1986  by Xerox Corporation. All rights reserved. -- file Pass4.Mesa-- last modified by Satterthwaite, October 4, 1982 10:24 am-- last modified by Sweet, 19-Oct-82 11:47:44-- Wagner		19-Aug-86 14:01:54DIRECTORY  ComData USING [monitored, ownSymbols, tC0, tC1, textIndex, zone],  CompilerUtil USING [],  P4 USING [    Attr, voidAttr,    AssignEntries, AssignImports, Body, DeclItem, ExpReset,    FinishBCD, InitBCD, ProcessDirectory, ProcessExports,     ProcessImports, VarInit,    Pass4BInit, Pass4DInit, Pass4LInit, Pass4SInit, Pass4OpsInit, Pass4XaInit,     Pass4XcInit, Pass4XbInit],  Symbols USING [    Base, CSEIndex, RecordSEIndex, RecordSENull, RootBti, typeANY],  SymbolTable USING [Handle],  Tree USING [Index, Link, NullIndex],  TreeOps USING [DecodeCard, FreeNode, GetNode];Pass4: PROGRAM    IMPORTS TreeOps, P4, dataPtr: ComData    EXPORTS CompilerUtil = {  OPEN TreeOps, Symbols;  tTRUE: PUBLIC Tree.Link;  tFALSE: PUBLIC Tree.Link;  syms: SymbolTable.Handle ¬ NIL; -- intermediate result bookkeeping  returnRecord, resumeRecord: PUBLIC RecordSEIndex;  implicitType: PUBLIC CSEIndex;	-- assumed type of empty  implicitBias: PUBLIC INTEGER;		-- assumed bias of empty  implicitAttr: PUBLIC P4.Attr;		-- assumed attributes of empty  lockNode: PUBLIC Tree.Index;  resident: PUBLIC BOOLEAN; -- overall control  P4Unit: PUBLIC PROC [h: SymbolTable.Handle, t: Tree.Link] = {    node: Tree.Index;    syms ¬ dataPtr.ownSymbols;    tTRUE ¬ dataPtr.tC1;  tFALSE ¬ dataPtr.tC0;    implicitType ¬ typeANY;  implicitBias ¬ 0;  implicitAttr ¬ P4.voidAttr;    resumeRecord ¬ RecordSENull;    P4.Pass4BInit[syms];   P4.Pass4DInit[syms];     P4.Pass4LInit[syms];    P4.Pass4SInit[syms];   P4.Pass4OpsInit[syms];    P4.Pass4XaInit[syms];  P4.Pass4XcInit[syms];      P4.Pass4XbInit[syms, dataPtr.zone];    node ¬ GetNode[syms, t];    Module[node ! P4.VarInit => {RESUME [TRUE]}];    P4.ExpReset[];    FreeNode[syms, node] };  Module: PROC [node: Tree.Index] = {    subNode: Tree.Index = GetNode[syms, syms.tb[node].son[6]];    saveIndex: CARDINAL = dataPtr.textIndex;    dataPtr.textIndex ¬ DecodeCard[syms.tb[subNode].info];    P4.InitBCD[syms.tb[subNode].son[1], dataPtr.zone];    dataPtr.textIndex ¬ DecodeCard[syms.tb[node].info];    lockNode ¬ IF ~dataPtr.monitored THEN Tree.NullIndex       ELSE GetNode[syms, syms.tb[node].son[5]];    resident ¬ syms.tb[node].attr1;    P4.AssignEntries[Symbols.RootBti];    P4.AssignImports[syms, syms.tb[node].son[2]];    P4.DeclItem[syms, syms.tb[node].son[6]];    P4.Body[Symbols.RootBti];    P4.ProcessDirectory[syms, syms.tb[node].son[1]];    P4.ProcessImports[syms, syms.tb[node].son[2]];    syms.tb[node].son[3] ¬ P4.ProcessExports[syms, syms.tb[node].son[3]];    P4.FinishBCD[syms.tb[subNode].son[1]];    dataPtr.textIndex ¬ saveIndex};  }.
-- Copyright (C) 1982, 1986  by Xerox Corporation. All rights reserved. -- file Pass3V.Mesa-- last modified by Satterthwaite, September 17, 1982 2:19 pm-- last modified by Sweet, 19-Oct-82 11:31:01-- Wagner		18-Aug-86 16:36:59DIRECTORY  ComData USING [seAnon, textIndex, typeBOOL],  Copier USING [CopyUnion],  CLog USING [Error, ErrorHti, ErrorSei, ErrorTree, Warning],  P3 USING [    Attr, NarrowOp, NPUse, phraseNP,    BaseTree, CanonicalType, EnterType, Exp, FindSe, FirstId, ForceType, LongPath,    MarkedType, Narrowing, OpenPointer, OperandType, PopCtx,    PushCtx, PushHtCtx, PushRecordCtx, RAttr, Rhs, RPop, RPush, RType, Scope,    SealRefStack, SearchCtxList, TargetType, TopCtx, TypeForTree, UnsealRefStack,    UpdateTreeAttr, VoidExp],  P3S USING [ImplicitInfo, implicit, implicitRecord, safety],  Symbols USING [    HTIndex, SEIndex, ISEIndex, CSEIndex, RecordSEIndex, CTXIndex,    HTNull, SENull, ISENull, CSENull, CTXNull, typeANY, typeTYPE],  SymbolOps USING [    NextSe, NormalType, RCType, ReferentType, TypeForm, UnderType, ToSei, ToTreeIndex],  SymbolTable USING [Handle],  Tree USING [Index, Link, Null],  TreeOps USING [    GetHash, GetNode, ListHead, ListTail, Map, OpName, PopTree, PushTree, PushNode, PushSe,    Scan, ScanList, SetAttr, SetInfo, UpdateList, DecodeCard, DecodeSei, EncodeSei];Pass3V: PROGRAM    IMPORTS      Copier, Log: CLog, P3, P3S, SymbolOps, TreeOps,       dataPtr: ComData    EXPORTS P3 = {   OPEN SymbolOps, P3, Symbols, TreeOps;  syms: SymbolTable.Handle ¬ NIL;    Pass3VInit: PUBLIC PROC [h: SymbolTable.Handle] = { syms ¬ h };-- finding union and discriminated types-- N. B. the following two entries cannot assume well-formed type links  VariantUnionType: PUBLIC PROC [type: SEIndex] RETURNS [CSEIndex] = {    rType: CSEIndex = ConsType[type];    RETURN [WITH syms.seb[rType] SELECT FROM      record =>	IF hints.variant	  THEN ConsType[TypeForSe[UnionField[LOOPHOLE[rType, RecordSEIndex]]]]	  ELSE typeANY,      ENDCASE => typeANY]};  SelectVariantType: PUBLIC PROC [type: SEIndex, tag: HTIndex] RETURNS [sei: ISEIndex] = {    matched: BOOLEAN;    vType: CSEIndex = VariantUnionType[type];    WITH syms.seb[vType] SELECT FROM      union => [matched, sei] ¬ SearchCtxList[tag, caseCtx];      ENDCASE => matched ¬ FALSE;    IF ~matched THEN sei ¬ ISENull;    RETURN};  SequenceField: PUBLIC PROC [rSei: RecordSEIndex] RETURNS [ISEIndex] = {    sei: ISEIndex = UnionField[rSei];    RETURN [IF TypeForm[syms, syms.seb[sei].idType] = sequence THEN sei ELSE ISENull]}; -- auxiliary procedures (for avoiding UnderType when potentially unsafe)  UnionField: PROC [rSei: RecordSEIndex] RETURNS [ISEIndex] = {    sei, root, next: ISEIndex;    ctx: CTXIndex = syms.seb[rSei].fieldCtx;    IF syms.ctxb[ctx].ctxType = simple THEN      FOR sei ¬ syms.ctxb[ctx].seList, next UNTIL sei = ISENull DO	next ¬ NextSe[syms, sei];	IF next = ISENull THEN RETURN [sei];	ENDLOOP    ELSE {	-- defined in another module, UnderType is safe      repeated: BOOLEAN ¬ FALSE;      DO	sei ¬ root ¬ syms.ctxb[ctx].seList;	DO	  IF sei = ISENull THEN EXIT;	  SELECT TypeForm[syms, syms.seb[sei].idType] FROM	    union, sequence => RETURN [sei];	    ENDCASE;	  IF (sei ¬ NextSe[syms, sei]) = root THEN EXIT;	  ENDLOOP;	IF repeated THEN EXIT;	Copier.CopyUnion[syms, syms.seb[rSei].fieldCtx];  repeated ¬ TRUE;	ENDLOOP};    RETURN [dataPtr.seAnon]};  ResolveId: PROC [hti: HTIndex, ctx: CTXIndex] RETURNS [sei: ISEIndex] = {    currentCtx: CTXIndex = TopCtx[];    IF ctx = currentCtx THEN sei ¬ FindSe[hti].symbol    ELSE {PopCtx[]; sei ¬ ResolveId[hti, ctx]; PushCtx[currentCtx]};    RETURN};  TypeForSe: PROC [sei: ISEIndex] RETURNS [type: SEIndex] = INLINE {    node: Tree.Index;    t: Tree.Link;    IF syms.seb[sei].mark3 THEN RETURN [syms.seb[sei].idType];    node ¬ ToTreeIndex[syms.seb[sei].idValue];    IF syms.tb[node].name # decl THEN RETURN [typeTYPE];    t ¬ syms.tb[node].son[2];    type ¬ WITH t SELECT FROM      hash => ResolveId[index, syms.seb[sei].idCtx],      symbol => index,      subtree => DecodeSei[syms.tb[index].info],      ENDCASE => typeANY;    RETURN};  ConsType: PROC [type: SEIndex] RETURNS [CSEIndex] = {    WITH se: syms.seb[type] SELECT FROM      id =>	IF se.mark3 THEN	  RETURN [IF se.idType # typeTYPE THEN typeANY ELSE ConsType[ToSei[se.idInfo]]]	ELSE {	  node: Tree.Index = ToTreeIndex[se.idValue];	  RETURN [IF syms.tb[node].name # typedecl	    THEN typeANY	    ELSE ConsType[ResolveTreeType[syms.tb[node].son[2], se.idCtx]]]};      cons => RETURN [LOOPHOLE[type, CSEIndex]];      ENDCASE => ERROR};  ResolveTreeType: PROC [t: Tree.Link, ctx: CTXIndex] RETURNS [type: SEIndex] = {    WITH t SELECT FROM      hash => type ¬ ResolveId[index, ctx];      symbol => type ¬ index;      subtree => {	node: Tree.Index = index;	type ¬ IF DecodeSei[syms.tb[node].info] # SENull	  THEN DecodeSei[syms.tb[node].info]	  ELSE	    SELECT syms.tb[node].name FROM	      discrimTC =>		WITH syms.tb[node].son[2] SELECT FROM		  hash => SelectVariantType[ResolveTreeType[syms.tb[node].son[1], ctx], index],		  ENDCASE => ERROR,	      ENDCASE => ERROR};      ENDCASE => ERROR;    RETURN}; -- type discrimination  DiscriminatedType: PUBLIC PROC [baseType: CSEIndex, t: Tree.Link]      RETURNS [type: CSEIndex] = {    IF t = Tree.Null THEN type ¬ P3S.implicitRecord    ELSE      WITH t SELECT FROM	subtree => {	  node: Tree.Index = index;	  temp: Tree.Link;	  SELECT syms.tb[node].name FROM	    union => {	      type ¬ WITH syms.tb[node].son[1] SELECT FROM symbol => UnderType[syms, index], ENDCASE => ERROR;	      WITH syms.seb[type] SELECT FROM		record =>		  IF hints.variant AND syms.tb[node].son[2] # Tree.Null		   AND (temp¬ListTail[syms, syms.tb[node].son[2]]) # Tree.Null THEN		    type ¬ DiscriminatedType[type, temp];		ENDCASE => ERROR};	    dollar => type ¬ OperandType[syms.tb[node].son[1]];	    dot => {	      subType: CSEIndex = NormalType[syms, OperandType[syms.tb[node].son[1]]];	      type ¬ WITH syms.seb[subType] SELECT FROM ref => UnderType[syms, refType], ENDCASE => ERROR};	    assignx => type ¬ DiscriminatedType[baseType, syms.tb[node].son[2]];	    ENDCASE => type ¬ baseType};	ENDCASE => type ¬ baseType;    RETURN};-- binding of variant records  Discrimination: PUBLIC PROC [node: Tree.Index, selection: TreeOps.Map] = {    OPEN syms.tb[node];    copy: BOOLEAN = (OpName[syms, ListHead[syms, son[3]]] = ditem);    type, subType: CSEIndex;    vCtx: CTXIndex;    base, discBase: Tree.Link;    attr: Attr;    entryNP: NPUse ¬ none;    unreachable: BOOLEAN ¬ FALSE;    BindError: PROC = {      IF son[2] # Tree.Null THEN son[2] ¬ VoidExp[syms, son[2]]; vCtx ¬ CTXNull};    PushCommonCtx: PROC = {      SELECT TRUE FROM	copy OR (syms.seb[type].typeTag # record) => PushCtx[CTXNull];	(baseId = HTNull) => PushRecordCtx[LOOPHOLE[type], base, indirect];	ENDCASE => PushHtCtx[baseId, base, indirect]};    BindItem: TreeOps.Scan = {      subNode: Tree.Index = GetNode[syms, t];      saveIndex: CARDINAL = dataPtr.textIndex;      IF syms.tb[subNode].name = ditem THEN {	declNode: Tree.Index = GetNode[syms, syms.tb[subNode].son[1]];	declType: CSEIndex;	Item: TreeOps.Map = {phraseNP ¬ entryNP; v ¬ selection[syms, t]};	op: NarrowOp;	dataPtr.textIndex ¬ DecodeCard[syms.tb[declNode].info];	IF unreachable THEN {Log.Warning[unreachable]; unreachable ¬ FALSE};	Scope[subNode, Item];	declType ¬ UnderType[syms, TypeForTree[syms.tb[declNode].son[2]]];	op ¬ Narrowing[subType, declType];	SELECT TRUE FROM	  ~copy => Log.Error[discrimForm];	  op.error => Log.ErrorSei[typeClash, FirstId[declNode]];	  op.computed => Log.ErrorTree[missingBinding, base];	  op.unImpl => Log.Warning[unimplemented];	  ~(op.rtTest OR op.tagTest) => unreachable ¬ TRUE;	  ENDCASE;	syms.tb[subNode].attr1 ¬ op.indirect;	IF (syms.tb[subNode].attr2 ¬ op.rtTest) THEN EnterType[MarkedType[declType]];	syms.tb[subNode].attr3 ¬ op.tagTest}      ELSE {	vType: CSEIndex;	dataPtr.textIndex ¬ DecodeCard[syms.tb[subNode].info];	IF copy THEN {Log.Error[discrimForm]; attr3 ¬ FALSE};	[syms.tb[subNode].son[1], vType] ¬ BindTest[syms.tb[subNode].son[1], vCtx];	IF vType = typeANY THEN PushCommonCtx[]	ELSE {	  WITH discBase SELECT FROM	    subtree => syms.tb[index].info ¬ EncodeSei[vType];	    ENDCASE => ERROR;	  IF baseId = HTNull THEN PushRecordCtx[LOOPHOLE[vType], discBase, FALSE]	  ELSE PushHtCtx[baseId, discBase, FALSE]};	phraseNP ¬ entryNP;	syms.tb[subNode].son[2] ¬ selection[syms, syms.tb[subNode].son[2]];	PopCtx[];	syms.tb[subNode].attr1 ¬ TRUE};      dataPtr.textIndex ¬ saveIndex};    saveImplicit: P3S.ImplicitInfo = P3S.implicit;    idNode: Tree.Index = GetNode[syms, son[1]];    baseId: HTIndex = GetHash[syms, syms.tb[idNode].son[1]];    indirect: BOOLEAN;    SealRefStack[];    base ¬ syms.tb[idNode].son[2] ¬ Exp[syms.tb[idNode].son[2], typeANY];    type ¬ RType[];  attr ¬ RAttr[];  RPop[];    UnsealRefStack[];    subType ¬ CanonicalType[type];    IF subType # type THEN syms.tb[idNode].son[2] ¬ ForceType[syms.tb[idNode].son[2], subType];    type ¬ NormalType[syms, subType];    P3S.implicit ¬ [tree: base, type: subType, attr: attr];    IF (attr3 ¬ copy) THEN {      P3S.implicit.attr.noAssign ¬ P3S.implicit.attr.noXfer ¬ TRUE;      SELECT TypeForm[syms, type] FROM        ref => {	  attr2 ¬ (TypeForm[syms, ReferentType[syms, type]] = any);	  indirect ¬ TRUE};	transfer => {attr2 ¬ TRUE; indirect ¬ FALSE};	ENDCASE => {attr2 ¬ FALSE; indirect ¬ FALSE};      IF baseId # HTNull THEN Log.Error[discrimForm]}    ELSE {      long: BOOLEAN;      WITH t: syms.seb[type] SELECT FROM	ref => {	  indirect ¬ TRUE;	  [base, type] ¬ OpenPointer[base, subType];	  subType ¬ OperandType[base];  long ¬ syms.seb[subType].typeTag = long};	ENDCASE => {indirect ¬ FALSE; long ¬ LongPath[base]};      IF P3S.safety = checked AND RCType[syms, type] # none THEN        Log.ErrorTree[unsafeSelection, base];      WITH syms.seb[type] SELECT FROM	record => {	  syms.tb[idNode].son[2] ¬ base ¬ BaseTree[base, subType];	  IF hints.variant THEN {	    uType: CSEIndex = VariantUnionType[type];	    WITH u: syms.seb[uType] SELECT FROM	      union => {		tagType: CSEIndex = UnderType[syms, syms.seb[u.tagSei].idType];		vCtx ¬ u.caseCtx;		IF son[2] = Tree.Null THEN {		  IF ~u.controlled THEN Log.ErrorTree[missingBinding, base];		  [] ¬ UpdateTreeAttr[base];  entryNP ¬ phraseNP;		  PushTree[syms, base];  PushSe[syms, u.tagSei];		  PushNode[syms, IF indirect THEN dot ELSE dollar, 2];		  SetInfo[syms, EncodeSei[tagType]]; 		  SetAttr[syms, 2, long]; son[2] ¬ PopTree[syms]}		ELSE {		  IF u.controlled THEN Log.ErrorTree[spuriousBinding, son[2]];		  PushCommonCtx[];		  son[2] ¬ Rhs[son[2], TargetType[tagType]];		  entryNP ¬ phraseNP;  RPop[];		  PopCtx[]}};	      ENDCASE => {Log.Error[noAccess]; BindError[]}}	  ELSE {Log.ErrorTree[noVariants, syms.tb[idNode].son[2]]; BindError[]};	  PushTree[syms, base];	  IF indirect THEN {PushNode[syms, uparrow, 1]; SetAttr[syms, 2, long]}	  ELSE PushNode[syms, cast, 1];	  discBase ¬ PopTree[syms]};	ENDCASE => {	  Log.ErrorTree[noVariants, syms.tb[idNode].son[2]];  BindError[];	  discBase ¬ Tree.Null}};    attr1 ¬ indirect;    ScanList[syms, son[3], BindItem];    PushCommonCtx[]; phraseNP ¬ entryNP; son[4] ¬ selection[syms, son[4]]; PopCtx[];    RPush[CSENull, attr];    P3S.implicit ¬ saveImplicit};  BindTest: PROC [t: Tree.Link, vCtx: CTXIndex]      RETURNS [val: Tree.Link, vType: CSEIndex] = {    mixed: BOOLEAN ¬ FALSE;    TestItem: TreeOps.Map = {      WITH t SELECT FROM	subtree => {	  subNode: Tree.Index = index;	  SELECT syms.tb[subNode].name FROM	    relE =>	      WITH syms.tb[subNode].son[2] SELECT FROM		hash => {		  iType: ISEIndex;		  uType: CSEIndex;		  found: BOOLEAN;		  [found, iType] ¬ SearchCtxList[index, vCtx];		  IF found THEN {		    uType ¬ UnderType[syms, iType];		    syms.tb[subNode].son[2] ¬ [symbol[index: iType]];		    SELECT vType FROM		      uType => NULL;		      typeANY => vType ¬ uType;		      ENDCASE => mixed ¬ TRUE}		  ELSE IF vCtx # CTXNull THEN Log.ErrorHti[unknownVariant, index];		  syms.tb[subNode].info ¬ EncodeSei[dataPtr.typeBOOL];		  syms.tb[subNode].attr1 ¬ syms.tb[subNode].attr2 ¬ FALSE;		  v ¬ t};		ENDCASE => {		  v ¬ Rhs[t, dataPtr.typeBOOL];  RPop[];		  Log.ErrorTree[nonVariantLabel, t]};	    ENDCASE => {	      v ¬ Rhs[t, dataPtr.typeBOOL];  RPop[];	      Log.ErrorTree[nonVariantLabel, t]}};	ENDCASE => ERROR;      RETURN};    vType ¬ typeANY;  val ¬ UpdateList[syms, t, TestItem];    IF mixed THEN vType ¬ typeANY;    RETURN};  }.
-- Copyright (C) 1983, 1986  by Xerox Corporation. All rights reserved. -- file Pass4Xc.mesa-- last written by Satterthwaite, September 30, 1982 8:51 am-- last written by Sweet,  8-Aug-83 14:36:55-- MEW		 2-Sep-86  9:24:36DIRECTORY  ComData USING [    interface, typeCARDINAL, typeINT, typeLONGSTRING, typeStringBody],  Environment USING [maxCARDINAL, maxINTEGER],  Literals USING [MSTIndex],  LiteralOps USING [    ValueDescriptor, FindDescriptor, MasterString, StringReference],  CLog USING [Error, ErrorTree, WarningTree],  OSMiscOps USING [FreeWords, Words],  P4 USING [    Attr, voidAttr, Prop, Repr, none, signed, unsigned, both, other, RegCount, maxRegs, vStack, vI,    AdjustBias, AdjustRegs, ArithRep, BiasedFold, BiasForType, BinaryAttr,     BitsForType, CanonicalType, CatchNest, CheckOver, CommonAttr,     CommonRep, CommonProp, ComputeRegs, Exp,    FillMultiWord, Fold, FoldedAttr, ForceType, LiteralAttr, LiteralRep, MakeArgRecord, MakeStructuredLiteral,    MakeTreeLiteral, OperandType, PadRecord, RegsForType, RelTest, RepForType,    Rhs, RValue, ShortToLong, StructuredLiteral, TreeLiteral, TreeLiteralValue, TypeExp,    TypeForTree, VAttr, VPop, VProp, VPush, VRegs, VRep, WordsForType, ZeroP],  Symbols USING [    BitAddress, ByteLength, WordLength,    SEIndex, ISEIndex, CSEIndex, ISENull, codeCHAR, codeINT, lZ],  SymbolOps USING [    ArgRecord, BitsPerElement, Cardinality, FirstCtxSe, NormalType, NextSe,    PackedSize, TypeForm, VariantField, UnderType],  SymbolTable USING [Handle],  SymLiteralOps USING [TypeRef],  Tree USING [Index, Link, NodeName, Null],  TreeOps USING [    FreeNode, FreeTree, GetNode, IdentityMap, MakeNode, OpName, PopTree,    PushSe, PushTree, PushLit, PushNode, SetAttr, SetInfo,    DecodeCSei, EncodeSei];Pass4Xc: PROGRAM    IMPORTS      Log: CLog, LiteralOps, OSMiscOps, P4, SymbolOps, SymLiteralOps, TreeOps,      dataPtr: ComData    EXPORTS P4 = {  OPEN SymbolOps, TreeOps, P4;  CSEIndex: TYPE = Symbols.CSEIndex;  WordLength: CARDINAL = Symbols.WordLength;  syms: SymbolTable.Handle ¬ NIL;    Pass4XcInit: PUBLIC PROC [h: SymbolTable.Handle] = { syms ¬ h };  NeutralExp: PUBLIC PROC [h: SymbolTable.Handle, t: Tree.Link] RETURNS [v: Tree.Link] = {    v ¬ RValue[t, 0, none]; VPop[]; RETURN}; -- interval utilities    NormalizeRange: PUBLIC PROC [t: Tree.Link] RETURNS [val: Tree.Link] = {    next: Tree.Link;    FOR val ¬ t, next DO      WITH val SELECT FROM	symbol => {	  lBound: INTEGER = BiasForType[UnderType[syms, index]];	  THROUGH [1..2] DO	    PushTree[syms, MakeTreeLiteral[ABS[lBound]]];	    IF lBound < 0 THEN PushNode[syms, uminus, 1];	    ENDLOOP;	  PushTree[syms, MakeTreeLiteral[P4.CheckOver[Cardinality[syms, index]] - 1]];	  PushNode[syms, plus, 2];  SetInfo[syms, EncodeSei[dataPtr.typeINT]];	  next ¬ MakeNode[syms, intCC, 2]};	subtree => {	  node: Tree.Index = index;	  SELECT syms.tb[node].name FROM	    subrangeTC, cdot => {	      next ¬ syms.tb[node].son[2]; syms.tb[node].son[2] ¬ Tree.Null; FreeNode[syms, node]};	    IN [intOO .. intCC] => EXIT;	    ENDCASE => ERROR};	ENDCASE => ERROR;      ENDLOOP;    RETURN};  Interval: PUBLIC PROC [node: Tree.Index, bias: INTEGER, target: Repr]      RETURNS [const: BOOLEAN] = {    OPEN syms.tb[node];    attr: Attr;    nRegs: RegCount;    son[1] ¬ RValue[son[1], bias, target];    attr ¬ VAttr[]; nRegs ¬ VRegs[];    son[2] ¬ RValue[son[2], bias, target];    nRegs ¬ MAX[VRegs[], nRegs];  attr ¬ CommonAttr[attr, VAttr[]];    VPop[];  VPop[];  VPush[bias, attr, nRegs];    const ¬ StructuredLiteral[son[1]] AND StructuredLiteral[son[2]] AND ~attr1;    RETURN};  EmptyInterval: PUBLIC SIGNAL = CODE;  ConstantInterval: PUBLIC PROC [node: Tree.Index] RETURNS [origin, range: INTEGER] = {    OPEN syms.tb[node];    uBound: INTEGER;    rep: Repr ¬ VRep[];    empty: BOOLEAN ¬ FALSE;    origin ¬ TreeLiteralValue[son[1]];  uBound ¬ TreeLiteralValue[son[2]];    SELECT name FROM      intOO, intOC => {	IF RelTest[son[1], son[2], relGE, rep] THEN empty ¬ TRUE;	origin ¬ origin + 1;	son[1] ¬ FreeTree[syms, son[1]];	name ¬ IF name = intOO THEN intCO ELSE intCC;	son[1] ¬ MakeTreeLiteral[origin]};      ENDCASE;    SELECT name FROM      intCC => IF RelTest[son[1], son[2], relG, rep] THEN empty ¬ TRUE;      intCO => {	IF RelTest[son[1], son[2], relGE, rep] THEN empty ¬ TRUE;	uBound ¬ uBound - 1;	son[2] ¬ FreeTree[syms, son[2]];	name ¬ intCC;  son[2] ¬ MakeTreeLiteral[uBound]};      ENDCASE => ERROR;    IF ~empty THEN range ¬ uBound - origin ELSE {SIGNAL EmptyInterval; range ¬ 0};    RETURN}; -- type utilities (move?) -- operators on types  TypeOp: PUBLIC PROC [node: Tree.Index] RETURNS [val: Tree.Link] = {    SELECT syms.tb[node].name FROM      size => val ¬ Size[node];      first, last => val ¬ EndPoint[node];      typecode => val ¬ TypeCode[node];      ENDCASE => {	Log.Error[unimplemented]; VPush[0, voidAttr, 0]; val ¬ [subtree[node]]};    RETURN};  Size: PROC [node: Tree.Index] RETURNS [val: Tree.Link] = {    type: CSEIndex;    ApplyLit: PROC [op: Tree.NodeName, val: WORD] = {      PushTree[syms, MakeTreeLiteral[val]];  PushNode[syms, op, 2];      SetInfo[syms, EncodeSei[dataPtr.typeINT]];        SetAttr[syms, 1, FALSE];  SetAttr[syms, 2, FALSE]};    IF OpName[syms, syms.tb[node].son[1]] = apply THEN {      subNode: Tree.Index = GetNode[syms, syms.tb[node].son[1]];      sei: Symbols.ISEIndex;      bitsPerItem: CARDINAL;      TypeExp[syms.tb[subNode].son[1]];  type ¬ UnderType[syms, TypeForTree[syms.tb[subNode].son[1]]];      SELECT TRUE FROM	(type = dataPtr.typeStringBody) => bitsPerItem ¬ Symbols.ByteLength;	((sei ¬ VariantField[syms, type]) # Symbols.ISENull) => {	  subType: CSEIndex = UnderType[syms, syms.seb[sei].idType];	  bitsPerItem ¬ WITH t: syms.seb[subType] SELECT FROM	    sequence => P4.CheckOver[BitsPerElement[syms, t.componentType, t.packed]],	    ENDCASE => ERROR};	ENDCASE => ERROR;      PushTree[syms, syms.tb[subNode].son[2]];  syms.tb[subNode].son[2] ¬ Tree.Null;      IF bitsPerItem < WordLength THEN {	itemsPerWord: CARDINAL = WordLength/bitsPerItem;	ApplyLit[plus, itemsPerWord-1];  ApplyLit[div, itemsPerWord]}      ELSE ApplyLit[times, bitsPerItem/WordLength];      ApplyLit[plus, P4.WordsForType[type]];      IF syms.tb[node].son[2] # Tree.Null THEN {	PushTree[syms, syms.tb[node].son[2]];  syms.tb[node].son[2] ¬ Tree.Null;	PushNode[syms, times, 2]; 	SetInfo[syms, EncodeSei[dataPtr.typeINT]];  	SetAttr[syms, 1, FALSE];  SetAttr[syms, 2, FALSE]}}    ELSE {      TypeExp[syms.tb[node].son[1]];  type ¬ UnderType[syms, TypeForTree[syms.tb[node].son[1]]];      IF syms.tb[node].son[2] = Tree.Null THEN PushTree[syms, MakeTreeLiteral[P4.WordsForType[type]]]      ELSE {	nBits: CARDINAL = P4.CheckOver[P4.BitsForType[type]];	PushTree[syms, syms.tb[node].son[2]];  syms.tb[node].son[2] ¬ Tree.Null;	IF nBits <= Symbols.ByteLength THEN {	  n: CARDINAL = WordLength/PackedSize[nBits];	  ApplyLit[plus, n-1];  ApplyLit[div, n]}	ELSE  ApplyLit[times, P4.WordsForType[type]]}};    val ¬ Rhs[PopTree[syms], dataPtr.typeCARDINAL];  FreeNode[syms, node]};  EndPoint: PROC [node: Tree.Index] RETURNS [val: Tree.Link] = {    OPEN syms.tb[node];    type, next: CSEIndex;    first: BOOLEAN = (name=first);    MaxInteger: WORD = Environment.maxINTEGER;    MaxWord: WORD = Environment.maxCARDINAL;    v: WORD;    vv: ARRAY [0..2) OF WORD;    TypeExp[son[1]];    FOR type ¬ UnderType[syms, TypeForTree[son[1]]], next DO      WITH syms.seb[type] SELECT FROM	basic => {	  v ¬ SELECT code FROM	    Symbols.codeINT => IF first THEN MaxInteger+1 ELSE MaxInteger,	    Symbols.codeCHAR => IF first THEN 0 ELSE P4.CheckOver[Cardinality[syms, type]-1],	    ENDCASE => IF first THEN 0 ELSE MaxWord;	  GO TO short};	enumerated => {	  v ¬ IF first THEN 0 ELSE P4.CheckOver[Cardinality[syms, type]]-1; GO TO short};	relative => next ¬ UnderType[syms, offsetType];	subrange => {v ¬ IF first THEN origin ELSE origin+range; GO TO short};	long => {	  vv ¬ IF UnderType[syms, rangeType] = dataPtr.typeINT	    THEN IF first THEN [0, MaxInteger+1] ELSE [MaxWord, MaxInteger]	    ELSE IF first THEN [0, 0] ELSE [MaxWord, MaxWord];	  GO TO long};	ENDCASE => ERROR;      REPEAT	short => val ¬ MakeTreeLiteral[v];	long => {	  PushLit[syms, LiteralOps.FindDescriptor[syms, DESCRIPTOR[vv]]];	  PushNode[syms, mwconst, 1];  SetInfo[syms, EncodeSei[type]];  	  val ¬ PopTree[syms]};      ENDLOOP;    FreeNode[syms, node];    VPush[0, LiteralAttr[RepForType[type]], RegsForType[type]]; RETURN};  TypeCode: PROC [node: Tree.Index] RETURNS [val: Tree.Link] = {    TypeExp[syms.tb[node].son[1]];    IF dataPtr.interface THEN val ¬ [subtree[index: node]]     ELSE {      val ¬ SymLiteralOps.TypeRef[TypeForTree[syms.tb[node].son[1]], FALSE];      FreeNode[syms, node]};    VPush[0, LiteralAttr[both], 1];  RETURN}; -- misc transfer operators  MiscXfer: PUBLIC PROC [node: Tree.Index] RETURNS [Tree.Link] = {    type: CSEIndex;    attr: Attr;    SELECT syms.tb[node].name FROM      create => {	syms.tb[node].son[1] ¬ RValue[syms.tb[node].son[1], 0, none];	attr ¬ [prop: VProp[], rep: unsigned];  VPop[]};      fork => {	OPEN syms.tb[node];	son[1] ¬ Exp[son[1], none];	attr.prop ¬ VProp[]; VPop[];  type ¬ OperandType[son[1]];	WITH t: syms.seb[type] SELECT FROM	  transfer => {	    son[2] ¬ MakeArgRecord[ArgRecord[syms, t.typeIn], son[2]];	    attr.prop ¬ CommonProp[attr.prop, VProp[]]; attr.rep ¬ other;  VPop[]};	  ENDCASE => ERROR};      ENDCASE => {Log.Error[unimplemented]; attr ¬ voidAttr};    attr.prop.noXfer ¬ FALSE;  VPush[0, attr, maxRegs];    IF syms.tb[node].nSons > 2 THEN CatchNest[syms.tb[node].son[3]];    RETURN [[subtree[index: node]]]}; -- misc addressing operators  AddrOp: PUBLIC PROC [node: Tree.Index] RETURNS [val: Tree.Link] = {    attr: Attr;    nRegs: RegCount;    SELECT syms.tb[node].name FROM      addr => val ¬ Addr[node];      base => {	syms.tb[node].son[1] ¬ Exp[syms.tb[node].son[1], none];	nRegs ¬ VRegs[]; attr ¬ [prop: VProp[], rep: unsigned];  VPop[];	VPush[0, attr, nRegs];  val ¬ [subtree[index: node]]};      length => {	type: CSEIndex;	syms.tb[node].son[1] ¬ Exp[syms.tb[node].son[1], none];	type ¬ OperandType[syms.tb[node].son[1]];	WITH syms.seb[type] SELECT FROM	  array => {	    val ¬ MakeTreeLiteral[P4.CheckOver[Cardinality[syms, indexType]]];	    FreeNode[syms, node];  attr ¬ LiteralAttr[both];  nRegs ¬ 1};	  ENDCASE => {	    val ¬ [subtree[index: node]]; attr ¬ [prop: VProp[], rep: both]; nRegs ¬ VRegs[]};	VPop[];  VPush[0, attr, nRegs]};      arraydesc =>	val ¬ IF OpName[syms, syms.tb[node].son[1]] # list THEN Desc[node] ELSE DescList[node];      ENDCASE => {	Log.Error[unimplemented]; VPush[0, voidAttr, 0]; val ¬ [subtree[node]]};    RETURN};  Addr: PROC [node: Tree.Index] RETURNS [val: Tree.Link] = {    OPEN syms.tb[node];    v: Tree.Link;    subNode: Tree.Index;    type, next: CSEIndex;    prop: Prop;    nRegs: RegCount;    son[1] ¬ Exp[son[1], none];    nRegs ¬ MAX[VRegs[], RegsForType[DecodeCSei[info]]];  prop ¬ VProp[];    FOR t: Tree.Link ¬ son[1], v DO      WITH t SELECT FROM	symbol => {	  sei: Symbols.ISEIndex = index;	  IF syms.seb[sei].constant THEN GO TO fail;	  IF syms.ctxb[syms.seb[sei].idCtx].level = Symbols.lZ AND	     (LOOPHOLE[syms.seb[sei].idValue, Symbols.BitAddress].bd # 0 OR	      LOOPHOLE[syms.seb[sei].idInfo, CARDINAL] MOD WordLength # 0) THEN GO TO fail;	  GO TO pass};	subtree => {	  subNode ¬ index;	  SELECT syms.tb[subNode].name FROM	    dot, dollar =>  v ¬ syms.tb[subNode].son[2];	    index, dindex, seqindex =>	      FOR  type ¬ NormalType[syms, OperandType[syms.tb[subNode].son[1]]], next DO		WITH t: syms.seb[type] SELECT FROM		  array => IF t.packed THEN GO TO fail ELSE GO TO pass;		  sequence => IF t.packed THEN GO TO fail ELSE GO TO pass;		  arraydesc => next ¬ UnderType[syms, t.describedType];		  ENDCASE => ERROR;		ENDLOOP;	    apply => GO TO fail;	    uparrow, reloc => GO TO pass;	    cast, chop => v ¬ syms.tb[subNode].son[1];	    base, length => GO TO pass;	    ENDCASE => GO TO fail};	ENDCASE => GO TO fail;      REPEAT	pass => NULL;	fail => Log.ErrorTree[nonAddressable, son[1]];       ENDLOOP;    val ¬ [subtree[index: node]];    IF OpName[syms, son[1]] = dot THEN {      subNode ¬ GetNode[syms, son[1]];      IF TreeLiteral[syms.tb[subNode].son[1]] THEN	WITH syms.tb[subNode].son[2] SELECT FROM	  symbol => {	    val ¬ MakeStructuredLiteral[		       TreeLiteralValue[syms.tb[subNode].son[1]] +			LOOPHOLE[syms.seb[index].idValue, Symbols.BitAddress].wd,		      DecodeCSei[info]];	    FreeNode[syms, node]};	  ENDCASE => ERROR};    VPop[];    VPush[0, [prop: prop, rep: unsigned], nRegs];  RETURN};  Desc: PROC [node: Tree.Index] RETURNS [Tree.Link] = {    subNode: Tree.Index = GetNode[syms, syms.tb[node].son[1]];    long: BOOLEAN = syms.tb[subNode].attr2;    prop: Prop;    nRegs: RegCount;    subType: CSEIndex;    syms.tb[subNode].son[1] ¬ Exp[syms.tb[subNode].son[1], none];    nRegs ¬ VRegs[];  prop ¬ VProp[];  VPop[];    subType ¬ OperandType[syms.tb[subNode].son[1]];    WITH t: syms.seb[subType] SELECT FROM      array => {	n: CARDINAL = P4.CheckOver[Cardinality[syms, t.indexType]];	IF n = 0 THEN Log.WarningTree[sizeClash, syms.tb[subNode].son[1]];	IF t.packed AND (BitsForType[subType] MOD WordLength # 0) THEN	  Log.ErrorTree[nonAddressable, syms.tb[subNode].son[1]];	PushTree[syms, [subtree[subNode]]];  PushTree[syms, MakeTreeLiteral[n]]};      sequence => {	copy: Tree.Link = IdentityMap[syms, syms.tb[subNode].son[1]];	PushTree[syms, syms.tb[subNode].son[1]];  PushTree[syms, MakeTreeLiteral[0]];	PushNode[syms, seqindex, 2];  	SetInfo[syms, EncodeSei[UnderType[syms, t.componentType]]];	SetAttr[syms, 2, long];  SetAttr[syms, 3, FALSE];	syms.tb[subNode].son[1] ¬ PopTree[syms];  PushTree[syms, [subtree[subNode]]];	WITH copy SELECT FROM	  subtree => {	    cNode: Tree.Index = index;	    syms.tb[cNode].son[2] ¬ FreeTree[syms, syms.tb[cNode].son[2]];	    syms.tb[cNode].son[2] ¬ [symbol[index: t.tagSei]];	    syms.tb[cNode].info ¬ EncodeSei[dataPtr.typeCARDINAL]};	  ENDCASE => ERROR;	PushTree[syms, copy]};      record => {  -- StringBody only (compatibility glitch)	copy: Tree.Link = IdentityMap[syms, syms.tb[subNode].son[1]];	sei: Symbols.ISEIndex = NextSe[syms, NextSe[syms, FirstCtxSe[syms, t.fieldCtx]]];	PushTree[syms, syms.tb[subNode].son[1]];  	PushSe[syms, sei];  PushNode[syms, dollar, 2];	SetInfo[syms, EncodeSei[UnderType[syms, syms.seb[sei].idType]]];  	SetAttr[syms, 2, long];	syms.tb[subNode].son[1] ¬ PopTree[syms];  	PushTree[syms, [subtree[subNode]]];	PushTree[syms, copy];  	PushSe[syms, NextSe[syms, FirstCtxSe[syms, t.fieldCtx]]];  	PushNode[syms, dollar, 2];	SetInfo[syms, EncodeSei[dataPtr.typeCARDINAL]]; SetAttr[syms, 2, long]};      ENDCASE => {	Log.ErrorTree[typeClash, syms.tb[subNode].son[1]];	PushTree[syms, [subtree[subNode]]];  PushTree[syms, Tree.Null]};    PushTree[syms, Tree.Null];  PushNode[syms, list, 3];      syms.tb[node].son[1] ¬ PopTree[syms];    VPush[0, [prop: prop, rep: other], MAX[RegsForType[DecodeCSei[syms.tb[node].info]], nRegs]];    RETURN [[subtree[index: node]]]};  DescList: PROC [node: Tree.Index] RETURNS [val: Tree.Link] = {    subNode: Tree.Index = GetNode[syms, syms.tb[node].son[1]];    type: CSEIndex = DecodeCSei[syms.tb[node].info];    subType: CSEIndex;    prop: Prop;    nRegs: RegCount;    syms.tb[subNode].son[1] ¬ RValue[syms.tb[subNode].son[1], 0, unsigned];    nRegs ¬ VRegs[];  prop ¬ VProp[];  subType ¬ OperandType[syms.tb[subNode].son[1]];    WITH syms.seb[subType] SELECT FROM      ref =>	IF BitsForType[refType] MOD WordLength # 0 THEN	  Log.ErrorTree[nonAddressable, syms.tb[subNode].son[1]];      ENDCASE;    syms.tb[subNode].son[2] ¬ RValue[syms.tb[subNode].son[2], 0, none];    nRegs ¬ MAX[VRegs[], nRegs];  prop ¬ CommonProp[VProp[], prop];    IF syms.tb[subNode].son[3] # Tree.Null THEN TypeExp[syms.tb[subNode].son[3]];    VPop[]; VPop[];    IF StructuredLiteral[syms.tb[subNode].son[1]] AND TreeLiteral[syms.tb[subNode].son[2]] THEN {      n: CARDINAL = WordsForType[type];      words: LiteralOps.ValueDescriptor ¬ DESCRIPTOR[OSMiscOps.Words[n], n];      FillMultiWord[words, 0, syms.tb[subNode].son[1]];      words[n-1] ¬ TreeLiteralValue[syms.tb[subNode].son[2]];      PushLit[syms, LiteralOps.FindDescriptor[syms, words]];      PushNode[syms, mwconst, 1];  SetInfo[syms, EncodeSei[type]];      OSMiscOps.FreeWords[BASE[words]];      val ¬ PopTree[syms];  FreeNode[syms, node]}    ELSE val ¬ [subtree[index: node]];    VPush[0, [prop: prop, rep: other], MAX[RegsForType[type], nRegs]];  RETURN};  Lengthen: PUBLIC PROC [node: Tree.Index, target: Repr] RETURNS [val: Tree.Link] = {    OPEN syms.tb[node];    attr: Attr;    addr: BOOLEAN;    nRegs: RegCount;    localLit: BOOLEAN ¬ FALSE;        son[1] ¬ RValue[son[1], 0, IF target=both THEN unsigned ELSE target];    -- Need to check for string literals to see if the lengthen is necessary    -- Pass 3 doesn't have enough info to get it right all the time    WITH son[1] SELECT FROM      literal => WITH info SELECT FROM        string => {	  IF OperandType[son[1]] = dataPtr.typeLONGSTRING THEN {	    val ¬ son[1];	    LiteralOps.StringReference[syms, LiteralOps.MasterString[syms, index]];	    nSons ¬ 0; FreeNode[syms, node];	    RETURN[val] };	  attr1 ¬ TRUE; attr2 ¬ attr3 ¬ FALSE;	  attr ¬ VAttr[]; VPop[]; 	  VPush[0, attr, RegsForType[dataPtr.typeLONGSTRING]];	  RETURN[[subtree[node]]] }	ENDCASE;      subtree => {        lnode: Tree.Index = index;	IF syms.tb[lnode].name = llit THEN {	  localLit ¬ TRUE;	  WITH syms.tb[lnode].son[1] SELECT FROM            literal => WITH info SELECT FROM	      string => 	        IF OperandType[syms.tb[lnode].son[1]] = dataPtr.typeLONGSTRING THEN {		  msti: Literals.MSTIndex = LiteralOps.MasterString[syms, index];		  val ¬ [literal[info: [string[index: msti]]]];		  LiteralOps.StringReference[syms, msti];		  FreeNode[syms, node];		  attr ¬ VAttr[]; VPop[]; 		  VPush[0, attr, RegsForType[dataPtr.typeLONGSTRING]];		  RETURN[val] };	      ENDCASE	    ENDCASE; } }      ENDCASE;    addr ¬ localLit OR (SELECT TypeForm[syms, CanonicalType[OperandType[son[1]]]] FROM	ref, arraydesc => TRUE,	ENDCASE => FALSE);    IF (attr ¬ VAttr[]).rep = none THEN {      Log.ErrorTree[mixedRepresentation, son[1]]; attr.rep ¬ both};    attr3 ¬ CommonRep[attr.rep, unsigned] = none;    nRegs ¬ MAX[VRegs[], RegsForType[DecodeCSei[info]]];    IF TreeLiteral[son[1]] AND       (~addr OR TreeLiteralValue[son[1]] = 0--NIL--) THEN {      val ¬ ShortToLong[node, attr.rep]; attr.rep ¬ LiteralRep[val, attr.rep]}    ELSE IF ZeroP[son[1]] THEN      {val ¬ PadRecord[son[1], DecodeCSei[info]]; son[1] ¬ Tree.Null;      FreeNode[syms, node]; attr.rep ¬ LiteralRep[val, attr.rep]}    ELSE {val ¬ [subtree[index: node]]; attr1 ¬ addr};    VPop[];    IF attr.rep = unsigned AND ~addr THEN attr.rep ¬ both;  VPush[0, attr, nRegs];    RETURN};    AddOp: PUBLIC PROC [node: Tree.Index, target: Repr] RETURNS [val: Tree.Link] = {    OPEN syms.tb[node];    op: Tree.NodeName = syms.tb[node].name;    type: CSEIndex = DecodeCSei[syms.tb[node].info];    bias, shift: INTEGER;    attr: Attr;    nRegs: RegCount;    son[1] ¬ Exp[son[1], target];  son[2] ¬ Exp[son[2], target];    val ¬ [subtree[index: node]];     attr ¬ BinaryAttr[];    SELECT attr.rep FROM      both => attr.rep ¬ ArithRep[attr.rep, target];      none =>	IF target = none THEN {Log.WarningTree[mixedRepresentation, val]; attr.rep ¬ both}	ELSE attr.rep ¬ IF target = both THEN signed ELSE target;      ENDCASE => NULL;    IF StructuredLiteral[son[1]] AND StructuredLiteral[son[2]] AND ~attr1 THEN {      val ¬ BiasedFold[node, attr.rep];      attr ¬ FoldedAttr[val, attr.rep];  bias ¬ 0;  nRegs ¬ RegsForType[type]}    ELSE {      nRegs ¬ IF op=plus THEN AdjustRegs[node, plus] ELSE ComputeRegs[node];      bias ¬ vStack[vI-1].bias;  shift ¬ vStack[vI].bias;      attr3 ¬ attr.rep # unsigned;      SELECT TRUE FROM	TreeLiteral[son[2]] => {	  val ¬ son[1];  shift ¬ shift + TreeLiteralValue[son[2]];	  son[1] ¬ Tree.Null;  FreeNode[syms, node]};	(op = plus AND TreeLiteral[son[1]]) => {	  val ¬ son[2];  shift ¬ shift + TreeLiteralValue[son[1]];	  son[2] ¬ Tree.Null;  FreeNode[syms, node]};	ENDCASE;      bias ¬ bias + (IF op=plus THEN shift ELSE -shift)};    VPop[];  VPop[];  VPush[bias, attr, nRegs];    IF type # dataPtr.typeINT AND OperandType[val] # type THEN val ¬ ForceType[val, type];    RETURN};  Mult: PUBLIC PROC [node: Tree.Index, target: Repr] RETURNS [val: Tree.Link] = {    OPEN syms.tb[node];    attr: Attr;    const1, const2: BOOLEAN;    v1, v2: WORD;    bias: INTEGER;    nRegs: RegCount;    t: Tree.Link;    son[1] ¬ Exp[son[1], target];  son[2] ¬ Exp[son[2], target];    val ¬ [subtree[index: node]];    attr ¬ BinaryAttr[];    SELECT attr.rep FROM      both => attr.rep ¬ ArithRep[attr.rep, target];      none =>	IF target = none THEN {Log.WarningTree[mixedRepresentation, val]; attr.rep ¬ both}	ELSE attr.rep ¬ IF target = both THEN signed ELSE target;      ENDCASE => NULL;    IF StructuredLiteral[son[1]] AND StructuredLiteral[son[2]] AND ~attr1 THEN {      nRegs ¬ RegsForType[DecodeCSei[info]];      val ¬ BiasedFold[node, attr.rep];  attr ¬ FoldedAttr[val, attr.rep];  bias ¬ 0}    ELSE {      nRegs ¬ AdjustRegs[node, times];      const1 ¬ TreeLiteral[son[1]];  const2 ¬ TreeLiteral[son[2]];      IF const1 OR ~const2 THEN son[1] ¬ AdjustBias[son[1], -vStack[vI-1].bias];      IF ~const1 OR const2 THEN son[2] ¬ AdjustBias[son[2], -vStack[vI].bias];      IF const1 THEN v1 ¬ TreeLiteralValue[son[1]];      IF const2 THEN v2 ¬ TreeLiteralValue[son[2]];      attr3 ¬ attr.rep # unsigned;      bias ¬ SELECT TRUE FROM	const1 => v1*vStack[vI].bias,	const2 => vStack[vI-1].bias*v2,	ENDCASE => 0;      IF StructuredLiteral[son[1]] -- AND ~const2 -- THEN {        t ¬ son[2]; son[2] ¬ son[1]; son[1] ¬ t};      IF const1 OR const2 THEN	SELECT (IF const1 THEN v1 ELSE v2) FROM	  0 => {val ¬ son[2]; son[2] ¬ Tree.Null; FreeNode[syms, node]; attr.rep ¬ both};	  1 => {	    val ¬ son[1];  son[1] ¬ Tree.Null;  FreeNode[syms, node];	    attr ¬ vStack[IF const1 THEN vI ELSE vI-1].attr};	  -1 => {	    PushTree[syms, son[1]];  son[1] ¬ Tree.Null;  FreeNode[syms, node];	    PushNode[syms, uminus, 1];  SetInfo[syms, EncodeSei[dataPtr.typeINT]];	    SetAttr[syms, 1, FALSE]; SetAttr[syms, 2, FALSE]; SetAttr[syms, 3, TRUE];	    val ¬ PopTree[syms]};	  ENDCASE};    VPop[];  VPop[];  VPush[bias, attr, nRegs];    RETURN};  DivMod: PUBLIC PROC [node: Tree.Index, target: Repr] RETURNS [val: Tree.Link] = {    OPEN syms.tb[node];    attr: Attr;    nRegs: RegCount;    son[1] ¬ RValue[son[1], 0, target];  son[2] ¬ RValue[son[2], 0, target];    val ¬ [subtree[index: node]];  attr ¬ BinaryAttr[];    SELECT attr.rep FROM      both => NULL;	-- preserved by div and mod      none =>	IF target = none THEN {Log.ErrorTree[mixedRepresentation, val]; attr.rep ¬ both}	ELSE attr.rep ¬ target;      ENDCASE => NULL;    IF StructuredLiteral[son[1]] AND StructuredLiteral[son[2]] AND ~attr1 THEN {      nRegs ¬ RegsForType[DecodeCSei[info]];       val ¬ Fold[node, attr.rep]; attr ¬ FoldedAttr[val, attr.rep]}    ELSE {      nRegs ¬ ComputeRegs[node];      attr3 ¬ CommonRep[attr.rep, unsigned] = none;      IF name = div AND TreeLiteral[son[2]] THEN	SELECT TreeLiteralValue[son[2]] FROM	  = 1 => {val ¬ son[1]; son[1] ¬ Tree.Null; FreeNode[syms, node]};	  >=2 => IF attr.rep = unsigned THEN attr.rep ¬ both;	  ENDCASE};    VPop[];  VPop[];  VPush[0, attr, nRegs];  RETURN};  }.
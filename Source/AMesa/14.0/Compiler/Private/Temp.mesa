-- Copyright (C) 1981, 1982, 1986  by Xerox Corporation. All rights reserved. -- file Temp.mesa-- last modified by Sweet, 9-Oct-81 11:38:06-- last modified by Satterthwaite, December 30, 1980  9:13 AM-- Wagner		22-Aug-86  8:55:49DIRECTORY  Alloc USING [Notifier],  Code USING [    bodyComRetLabel, bodyOutRecord, bodyRetLabel, curctxlvl, fileindex,     firstTemp, framesz, inlineFileIndex, mainBody, tempcontext, tempstart],  CodeDefs USING [    codeType, Lexeme, StackIndex, StatementStateRecord, TempStateRecord],  ComData USING [bodyIndex, globalFrameSize, mainCtx, ownSymbols],  FOpCodes USING [qFF],  CLog USING [Error, ErrorSei],  P5 USING [PushLex],  P5U USING [LabelAlloc, Out0],  PrincOps USING [MaxFrameSize],  Stack USING [Dump, New, Prefix],  String USING [WordsForString],  SymbolOps USING [FromBitAddr, FromCard, MakeCtxSe, NewCtx, NextSe, SetSeLink,    ToBitAddr],  Symbols USING [    Base, BitAddress, CTXNull, HTNull, ISEIndex, ISENull, lZ, typeANY, WordLength],  SymbolTable USING [Handle];Temp: PROGRAM    IMPORTS MPtr: ComData, CPtr: Code, P5U, CLog, P5, Stack, String, SymbolOps     EXPORTS CodeDefs, P5 =  BEGIN  OPEN CodeDefs;  -- imported definitions  BitAddress: TYPE = Symbols.BitAddress;  ISEIndex: TYPE = Symbols.ISEIndex;  ISENull: ISEIndex = Symbols.ISENull;  WordLength: CARDINAL = Symbols.WordLength;  InvalidHeapRelease: SIGNAL = CODE;  InvalidTempRelease: SIGNAL = CODE;  syms: SymbolTable.Handle ¬ NIL;  cb: Symbols.Base;		-- code base (local copy)  TempNotify:  PUBLIC Alloc.Notifier =    BEGIN  -- called by allocator whenever table area is repacked    syms ¬ MPtr.ownSymbols;    cb ¬ base[codeType];    END;  pendTempList, tempListPool, heapList: ISEIndex;  TempInit: PUBLIC PROC =    BEGIN -- called at beginning of MODULE to init stack stuff    pendTempList ¬ tempListPool ¬ heapList ¬ ISENull;    CPtr.tempcontext ¬ SymbolOps.NewCtx[syms, Symbols.lZ];    END;  PushTempState: PUBLIC PROC [p: POINTER TO TempStateRecord, newfs: CARDINAL] =    BEGIN    p­ ¬ [pendtemplist: pendTempList, templist: ISENull,	    heaplist: heapList, tempctxlvl: syms.ctxb[CPtr.tempcontext].level,	    firstTemp: CPtr.firstTemp, tempstart: CPtr.tempstart,	    framesz: CPtr.framesz];    pendTempList ¬ heapList ¬ ISENull;    syms.ctxb[CPtr.tempcontext].level ¬ CPtr.curctxlvl;    CPtr.firstTemp ¬ CPtr.tempstart ¬ CPtr.framesz ¬ newfs;    END;  PopTempState:  PUBLIC PROC [p: POINTER TO TempStateRecord] =    BEGIN    PurgePendTempList[];    [pendtemplist: pendTempList, templist: ,      heaplist: heapList, tempctxlvl: syms.ctxb[CPtr.tempcontext].level,      tempstart: CPtr.tempstart, firstTemp: CPtr.firstTemp,      framesz: CPtr.framesz] ¬ p­;    END;  PushStatementState: PUBLIC PROC [p: POINTER TO StatementStateRecord] =    BEGIN    Stack.Dump[];    p­ ¬ [retLabel: CPtr.bodyRetLabel,	    comRetLabel: CPtr.bodyComRetLabel,	    outRecord: CPtr.bodyOutRecord,	    pendtemplist: pendTempList, 	    stkPtr: Stack.New[], 	    inlineFileIndex: CPtr.inlineFileIndex];    CPtr.bodyRetLabel ¬ P5U.LabelAlloc[];    CPtr.bodyComRetLabel ¬ P5U.LabelAlloc[];    pendTempList ¬ ISENull;    CPtr.inlineFileIndex ¬ CPtr.fileindex;    END;  PopStatementState:  PUBLIC PROC [p: POINTER TO StatementStateRecord] =    BEGIN    sp: StackIndex;    PurgePendTempList[];    [retLabel: CPtr.bodyRetLabel,      comRetLabel: CPtr.bodyComRetLabel,      pendtemplist: pendTempList,      outRecord: CPtr.bodyOutRecord,      stkPtr: sp,      inlineFileIndex: CPtr.inlineFileIndex] ¬ p­;    Stack.Prefix[sp];    END;  GenTempLex:  PUBLIC PROC [nwords: CARDINAL] RETURNS [l: se Lexeme] =    BEGIN    l ¬ CreateTempLex[CPtr.tempstart, nwords];    ReleaseTempLex[l];    BumpTemps[nwords];    RETURN    END;  GenAnonLex:  PUBLIC PROC [nwords: CARDINAL] RETURNS [l: se Lexeme] =    BEGIN    l ¬ CreateTempLex[CPtr.tempstart, nwords];    BumpTemps[nwords];    RETURN    END;  GenStringBodyLex:  PUBLIC PROC [nchars: CARDINAL] RETURNS [l: se Lexeme] =    BEGIN    nwords: CARDINAL = String.WordsForString[nchars];    IF ~CPtr.mainBody THEN l ¬ GenAnonLex[nwords]    ELSE      BEGIN      l ¬ CreateTempLex[MPtr.globalFrameSize, nwords];      syms.seb[l.lexsei].idCtx ¬ MPtr.mainCtx;      MPtr.globalFrameSize ¬ MPtr.globalFrameSize + nwords;      IF MPtr.globalFrameSize > PrincOps.MaxFrameSize THEN	CLog.Error[addressOverflow];      END;    RETURN    END;  BumpTemps: PROC [n: CARDINAL] =    BEGIN -- updates CPtr.tempstart (and CPtr.framesz, if necessary)    CPtr.framesz ¬ MAX[CPtr.tempstart ¬ CPtr.tempstart+n, CPtr.framesz];    IF CPtr.framesz > PrincOps.MaxFrameSize THEN      CLog.ErrorSei[addressOverflow, syms.bb[MPtr.bodyIndex].id];    END;  PurgePendTempList:  PUBLIC PROC =    BEGIN -- after each statment the temp sei's are released    sei: ISEIndex ¬ pendTempList;    nSei: ISEIndex;    WHILE sei # ISENull DO      nSei ¬ SymbolOps.NextSe[syms, sei];      ReleaseTempSei[sei];      sei ¬ nSei;      ENDLOOP;    pendTempList ¬ ISENull;    END;  PurgeHeapList: PUBLIC PROC [oldheaplist: ISEIndex] =    BEGIN -- after each statment the heap chunks are freed    sei: ISEIndex ¬ heapList;    nSei: ISEIndex;    l: se Lexeme ¬ Lexeme[se[NULL]];    WHILE sei # ISENull DO      nSei ¬ SymbolOps.NextSe[syms, sei];      l.lexsei ¬ sei;      FreeHeapLex[l];      sei ¬ nSei;      ENDLOOP;    heapList ¬ oldheaplist;    END;  FreeHeapLex: PUBLIC PROC [l: se Lexeme] =    BEGIN    P5.PushLex[l];    P5U.Out0[FOpCodes.qFF];    ReleaseTempSei[l.lexsei];    END;  PushHeapList: PUBLIC PROC RETURNS [oldheaplist: ISEIndex] =    BEGIN    oldheaplist ¬ heapList;    heapList ¬ ISENull;    RETURN    END;  GenHeapLex: PUBLIC PROC RETURNS [l: se Lexeme] =    BEGIN    l ¬ GenAnonLex[1];    SymbolOps.SetSeLink[syms, l.lexsei, heapList];    heapList ¬ l.lexsei;    RETURN    END;  FreeTempSei: PUBLIC PROC [sei: ISEIndex] =    BEGIN -- de-links a temp sei from its chain    SymbolOps.SetSeLink[syms, sei, tempListPool];    tempListPool ¬ sei;    END;  ReleaseTempSei:  PROC [sei: ISEIndex] =    BEGIN -- puts a temp sei on the templist    a: BitAddress = SymbolOps.ToBitAddr[syms.seb[sei].idValue];    CPtr.tempstart ¬ MIN[CPtr.tempstart, a.wd];    FreeTempSei[sei];    END;  CreateTempLex: PUBLIC PROC [wdoffset, nwords: INTEGER] RETURNS [se Lexeme] =    BEGIN -- inits (if nec) a new temp sei cell    sei: ISEIndex;    IF tempListPool # ISENull THEN      BEGIN      sei ¬ tempListPool;      tempListPool ¬ SymbolOps.NextSe[syms, sei];      syms.seb[sei].idCtx ¬ CPtr.tempcontext;      END    ELSE      BEGIN      sei ¬ SymbolOps.MakeCtxSe[syms, Symbols.HTNull, Symbols.CTXNull];      syms.seb[sei].constant ¬ syms.seb[sei].extended ¬ syms.seb[sei].linkSpace ¬ FALSE;      syms.seb[sei].immutable ¬ TRUE;      syms.seb[sei].idCtx ¬ CPtr.tempcontext;      syms.seb[sei].idType ¬ Symbols.typeANY;      END;    SymbolOps.SetSeLink[syms, sei, ISENull];    syms.seb[sei].idValue ¬ SymbolOps.FromBitAddr[[wd: wdoffset, bd: 0]];    syms.seb[sei].idInfo ¬ SymbolOps.FromCard[nwords*WordLength];    RETURN [[se[lexsei: sei]]]    END;  ReleaseTempLex: PUBLIC PROC [l: se Lexeme] =    BEGIN -- releases a cell of temporary storage    IF SymbolOps.NextSe[syms, l.lexsei] = ISENull THEN      BEGIN      SymbolOps.SetSeLink[syms, l.lexsei, pendTempList];      pendTempList ¬ l.lexsei;      END;    END;  END.
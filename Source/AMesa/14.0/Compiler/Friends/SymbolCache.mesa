-- Copyright (C) 1981, 1983, 1985, 1986  by Xerox Corporation. All rights reserved. -- file SymbolCache.Mesa--  Satterthwaite,	October 15, 1980  12:30 PM--  JGS,		1-Sep-81 16:36:52--  Sweet,		 2-Aug-83 14:58:33--  Johnsson,		11-Jun-83 21:36:31--  Wagner		16-Aug-86 11:51:05DIRECTORY  Environment USING [wordsPerPage],  Heap USING [Create],  MSegment USING [Address, ForceOut, Handle, Pages],  Symbols USING [HTIndex, HTRecord, MDIndex],  SymbolSegment USING [ExtIndex, FGHeader, STHeader],  SymbolTable,  Table USING [Base];SymbolCache: MONITOR    IMPORTS Heap, MSegment    EXPORTS SymbolTable =  BEGIN    Handle: TYPE = SymbolTable.Handle;    zone: UNCOUNTED ZONE ¬ Heap.Create[initial: 4];  -- public interface  SymSegHandle: PUBLIC TYPE = MSegment.Handle;  Missing: PUBLIC ERROR [SymSegHandle] = CODE;  IllegalBase: PUBLIC ERROR [h: Handle] = CODE;  Acquire: PUBLIC ENTRY PROC [handle: SymSegHandle] RETURNS [symtab: Handle] = {    node: CachePointer;    IF handle = NIL THEN RETURN[NIL];    IF freeTables = NIL      THEN {symtab ¬ zone.NEW[SymbolTable.Object ¬ [zone: zone]];}      ELSE {symtab ¬ freeTables; freeTables ¬ freeTables.link};    node ¬ MakeCacheEntry[handle];    symtab.link ¬ busyTables;  busyTables ¬ symtab;    InstallTable[symtab, node]};  Release: PUBLIC ENTRY PROC [h: Handle] = {    node: CachePointer;    cacheNode: CachePointer = h.cacheInfo;    prev: Handle;    FOR node ¬ header.next, node.next UNTIL node = cacheNode      DO  IF node = free THEN ERROR IllegalBase[h]  ENDLOOP;    prev ¬ NIL;    FOR table: Handle ¬ busyTables, table.link UNTIL table = NIL      DO      IF table = h	THEN {	  IF prev # NIL THEN prev.link ¬ table.link ELSE busyTables ¬ table.link;	  prev ¬ table;	  EXIT};      prev ¬ table;      REPEAT        FINISHED => ERROR IllegalBase[h];      ENDLOOP;    FreeCacheEntry[cacheNode];    h.link ¬ freeTables;  freeTables ¬ h};      busyTables: Handle ¬ NIL;  freeTables: Handle ¬ NIL;  cachePageLimit: CARDINAL ¬ 0;  CacheSize: PUBLIC ENTRY PROC RETURNS [pages: CARDINAL] = {RETURN [cachePageLimit]};  SetCacheSize: PUBLIC ENTRY PROC [pages: CARDINAL] = {    cachePageLimit ¬ pages;  TrimCache[cachePageLimit]};  suspended: BOOLEAN;  SuspendCache: PUBLIC ENTRY PROC = {    WHILE unused # free DO ClearNode[unused ¬ unused.prev] ENDLOOP;    suspended ¬ TRUE;    FOR node: CachePointer ¬ header.next, node.next UNTIL node = free      DO  MSegment.ForceOut[node.table]  ENDLOOP};  RestartCache: PUBLIC ENTRY PROC = {    IF ~suspended THEN ERROR;    FOR h: Handle ¬ busyTables, h.link UNTIL h = NIL      DO SetBases[h, h.cacheInfo] ENDLOOP;    suspended ¬ FALSE};-- internal cache management  CacheNodes: CARDINAL = 15;  MaxCacheNodes: CARDINAL = 255;  LockTime: CARDINAL = 1;  CacheNode: TYPE = RECORD[    prev, next: CachePointer,    table: SymSegHandle,    locked: BOOLEAN,    refCount: [0..MaxCacheNodes]];  CachePointer: TYPE = LONG POINTER TO CacheNode;  header, free, unused: CachePointer;  lockedPages: CARDINAL;  --    C A C H E   O R G A N I Z A T I O N  -- The cache keeps track of segments in CacheNodes.  The CacheNodes are  -- kept in a doubly-linked list and organized in three groups, separated  -- by three pointers: header, free, and unused.  Ordered by the link  -- next, the list is organized as follows:  --   (header .. free)		nodes attached to frames,  --   [free .. unused)		nodes with segment but no frame,  --   [unused .. header)	empty and available,  MakeCacheEntry: PROC [handle: SymSegHandle] RETURNS [node: CachePointer] = {    FOR node ¬ header.next, node.next UNTIL node = free      DO      IF node.table = handle THEN GO TO allocated;      REPEAT        allocated =>  NULL;        FINISHED => {          FOR node ¬ free, node.next UNTIL node = unused	    DO            IF node.table = handle THEN GO TO unflushed;            REPEAT              unflushed => Detach[node];              FINISHED => {node ¬ GetEmptyNode[];  node.table ¬ handle};	    ENDLOOP;	  IF ~node.locked	    THEN {	      pages: CARDINAL = CARDINAL[MSegment.Pages[handle]];	      retried: BOOLEAN ¬ FALSE;	      TrimCache[MAX[cachePageLimit, pages] - pages];	      node.locked ¬ TRUE;	      lockedPages ¬ lockedPages + pages};          Insert[node, free]};      ENDLOOP;    node.refCount ¬ node.refCount+1;  RETURN};  FreeCacheEntry: PROC [node: CachePointer] = {    IF (node.refCount ¬ node.refCount-1) = 0      THEN {	Detach[node];  ReleaseLock[node];	Insert[node, free];  free ¬ node}};  GetEmptyNode: PROC RETURNS [node: CachePointer] = {    IF free = header      THEN node ¬ zone.NEW[CacheNode]      ELSE {	IF unused = header THEN ClearNode[unused ¬ unused.prev];	node ¬ unused;  Detach[node]};    node.refCount ¬ 0;  node.locked ¬ FALSE;    RETURN};  Detach: PROC [node: CachePointer] = {    IF node = free THEN free ¬ free.next;    IF node = unused THEN unused ¬ unused.next;    node.prev.next ¬ node.next;  node.next.prev ¬ node.prev};  Insert: PROC [node, position: CachePointer] = {    node.prev ¬ position.prev;  node.prev.next ¬ node;    node.next ¬ position;  position.prev ¬ node};  TrimCache: PROC [size: CARDINAL] = {    WHILE (lockedPages > size OR size = 0) AND unused # free      DO ReleaseLock[unused ¬ unused.prev] ENDLOOP};  ReleaseLock: PROC [node: CachePointer] = {    IF node.locked      THEN {	node.locked ¬ FALSE;	lockedPages ¬ lockedPages - CARDINAL[MSegment.Pages[node.table]]}};  ClearNode: PROC [node: CachePointer] = {ReleaseLock[node]};-- symbol table setup  InstallTable: PROC [h: Handle, node: CachePointer] = {    SetBases[h, node]};  SetBases: PROC [h: Handle, node: CachePointer] = {    b: LONG POINTER = MSegment.Address[node.table];    tB: Table.Base = LOOPHOLE[b];    p: LONG POINTER TO SymbolSegment.STHeader = b;    q: LONG POINTER TO SymbolSegment.FGHeader;    h.cacheInfo ¬ node;    h.hashVec ¬ b+p.hvBlock.offset;    h.ht ¬ DESCRIPTOR[b+p.htBlock.offset, p.htBlock.size/SIZE[Symbols.HTRecord]];    h.ssb ¬ b + p.ssBlock.offset;    h.seb ¬ tB + p.seBlock.offset;    h.ctxb ¬ tB + p.ctxBlock.offset;    h.mdb ¬ tB + p.mdBlock.offset;    h.bb ¬ tB + p.bodyBlock.offset;    h.tb ¬ tB + p.treeBlock.offset;    h.ltb ¬ tB + p.litBlock.offset;    h.extb ¬ tB + p.extBlock.offset;    h.mdLimit ¬ FIRST[Symbols.MDIndex] + p.mdBlock.size;    h.extLimit ¬ FIRST[SymbolSegment.ExtIndex] + p.extBlock.size;    h.mainCtx ¬ p.outerCtx;  h.stHandle ¬ p;    IF p.fgRelPgBase = 0 OR MSegment.Pages[node.table] <= p.fgRelPgBase      THEN {h.sourceFile ¬ NIL; h.fgTable ¬ NIL}      ELSE {	offset: CARDINAL = LOOPHOLE[	  @(NIL[POINTER TO SymbolSegment.FGHeader]).sourceFile];	q ¬ b + p.fgRelPgBase*Environment.wordsPerPage;	h.sourceFile ¬ (b + p.fgRelPgBase*Environment.wordsPerPage) + offset;	h.fgTable ¬ DESCRIPTOR[	    b + p.fgRelPgBase*Environment.wordsPerPage + q.offset, q.length]}};-- initialization  CacheEntries: ARRAY [0..CacheNodes] OF CacheNode;  Init: PROC = {    FOR j: INTEGER [0..CacheNodes] IN [0..CacheNodes]      DO      CacheEntries[j].next ¬ @CacheEntries[IF j=CacheNodes THEN 0 ELSE j+1];      CacheEntries[j].prev ¬ @CacheEntries[IF j=0 THEN CacheNodes ELSE j-1];      ENDLOOP;    header ¬ @CacheEntries[0];    free ¬ unused ¬ header.next;    lockedPages ¬ 0;  suspended ¬ FALSE};  Init[];  END.
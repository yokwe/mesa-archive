-- Copyright (C) 1982, 1985, 1986  by Xerox Corporation. All rights reserved. -- file LiteralPack.Mesa-- last modified by Satterthwaite,  9-Feb-82  9:48:21-- last modified by Sweet, 18-Oct-82 11:53:50-- last modified by Wagner, 16-Aug-86 11:28:48DIRECTORY  Alloc USING [OrderedIndex, Bounds, Failure, Top, Words],  Literals,  LiteralOps,  String USING [    SubString, SubStringDescriptor,    AppendChar, AppendSubString, EqualSubStrings],  Symbols USING [SEIndex],  SymbolTable USING [Handle];LiteralPack: PROGRAM    IMPORTS Alloc, String    EXPORTS LiteralOps    SHARES Literals = PUBLIC {  OPEN Literals;    Handle: TYPE = SymbolTable.Handle;  LTMax: Alloc.OrderedIndex = FIRST[Alloc.OrderedIndex] + (LAST[LTIndex]-FIRST[LTIndex]);  STMax: Alloc.OrderedIndex = FIRST[Alloc.OrderedIndex] + (LAST[STIndex]-FIRST[STIndex]);  LitInitialize: PROC [h: Handle] = {     -- called to set up the compiler's literal table     IF h.litHashVec # NIL THEN LitFinalize[h];    h.litHashVec ¬ h.zone.NEW[ARRAY LitHVIndex OF LTIndex];    h.litSHashVec ¬ h.zone.NEW[ARRAY SLitHVIndex OF MSTIndex];    [] ¬ ForgetEntries[h];  h.litSHashVec­ ¬ ALL[MSTNull];    h.stLimit ¬ h.localStart ¬ FIRST[STIndex];  h.localStrings ¬ h.stringsMarkBit ¬ FALSE};     LitFinalize: PROC [h: Handle] = {    h.zone.FREE[@h.litSHashVec];  h.zone.FREE[@h.litHashVec]};    -- literal table management  LitHVLength: PRIVATE INTEGER = Literals.LitHVLength;  LitHVIndex: PRIVATE TYPE = Literals.LitHVIndex;  Find: PROC [h: Handle, v: WORD] RETURNS [lti: LTIndex] = {    hvi: LitHVIndex = v MOD LitHVLength;    FOR lti ¬ h.litHashVec[hvi], h.ltb[lti].link UNTIL lti = LTNull DO      WITH entry: h.ltb[lti] SELECT FROM	short => IF entry.value = v THEN EXIT;	ENDCASE;      REPEAT	FINISHED => {	  ti: Alloc.OrderedIndex = h.table.Words[ltType, SIZE[short LTRecord]];	  IF ti >= LTMax THEN ERROR h.table.Failure[ltType];	  lti ¬ ti;  h.ltb[lti] ¬ LTRecord[datum: short[value: v], link: h.litHashVec[hvi]];	  h.litHashVec[hvi] ¬ lti};      ENDLOOP;    RETURN};  FindMultiWord: PRIVATE PROC [h: Handle, baseP: Literals.Finger, desc: LitDescriptor]      RETURNS [lti: LTIndex] = {    v: WORD ¬ 0;    hvi: LitHVIndex;    lLti: Literals.Base RELATIVE POINTER [0..Literals.Limit) TO long LTRecord;    FOR i: CARDINAL IN [0 .. desc.length) DO v ¬ v + baseP­[desc.offset][i] ENDLOOP;    hvi ¬ v MOD LitHVLength;    FOR lti ¬ h.litHashVec[hvi], h.ltb[lti].link UNTIL lti = LTNull DO      WITH entry: h.ltb[lti] SELECT FROM	long =>	  IF desc.length = entry.length THEN	    FOR i: CARDINAL IN [0 .. desc.length) DO	      IF entry.value[i] # baseP­[desc.offset][i] THEN EXIT;	      REPEAT	        FINISHED => GO TO found;	      ENDLOOP;	ENDCASE;      REPEAT	found => NULL;	FINISHED => {	  ti: Alloc.OrderedIndex = h.table.Words[ltType, SIZE[long LTRecord] + desc.length];	  IF ti >= LTMax THEN ERROR h.table.Failure[ltType];	  lLti ¬ ti;	  h.ltb[lLti] ¬ LTRecord[		link: h.litHashVec[hvi],		datum: long[codeIndex: 0, length: desc.length, value: ]];	  FOR i: CARDINAL IN [0 .. desc.length) DO	    h.ltb[lLti].value[i] ¬ baseP­[desc.offset][i] ENDLOOP;	  h.litHashVec[hvi] ¬ lti ¬ lLti};      ENDLOOP;    RETURN};  Value: PROC [h: Handle, lti: LTIndex] RETURNS [WORD] = {    WITH entry: h.ltb[lti] SELECT FROM	short => RETURN [entry.value];	long => IF entry.length = 1 THEN RETURN [entry.value[0]];      ENDCASE;    ERROR};  FindDescriptor: PROC [h: Handle, desc: LiteralOps.ValueDescriptor] RETURNS [LTIndex] = {    base: Literals.Base ¬ LOOPHOLE[BASE[desc]];    RETURN [IF LENGTH[desc] = 1      THEN Find[h, desc[0]]      ELSE FindMultiWord[h, @base, [offset:LOOPHOLE[0], length:LENGTH[desc]]]]};  deltaShort: CARDINAL = LOOPHOLE[@(NIL[POINTER TO short LTRecord]).value];  deltaLong: CARDINAL = LOOPHOLE[@(NIL[POINTER TO long LTRecord]).value];  DescriptorValue: PROC [h: Handle, lti: LTIndex] RETURNS [LitDescriptor] = {    RETURN [WITH entry: h.ltb[lti] SELECT FROM      short => [offset: LOOPHOLE[lti + deltaShort], length: 1],      long => [offset: LOOPHOLE[lti + deltaLong], length: entry.length],      ENDCASE => ERROR]};  CopyLiteral: PROC [h: Handle, literal: LTId] RETURNS [lti: LTIndex] = {    desc: LitDescriptor;    WITH entry: literal.baseP­[literal.index] SELECT FROM      short => lti ¬ Find[h, entry.value];      long => {	desc ¬ [offset: LOOPHOLE[literal.index + deltaLong], length: entry.length];	lti ¬ FindMultiWord[h, literal.baseP, desc]};      ENDCASE => ERROR;    RETURN};  ForgetEntries: PROC [h: Handle] RETURNS [currentSize: CARDINAL] = {    h.litHashVec­ ¬ ALL[LTNull]; RETURN [h.table.Bounds[ltType].size]}; -- string literal table management  MSTNull: PRIVATE MSTIndex = LOOPHOLE[STNull];  SLitHVLength: PRIVATE INTEGER = Literals.SLitHVLength;  SLitHVIndex: PRIVATE TYPE = Literals.SLitHVIndex;  LitFindString: PROC [h: Handle, s: String.SubString] RETURNS [STIndex] = {    CpW: CARDINAL = 2;	-- String.CharsPerWord    hash: WORD ¬ 0;    hvi: SLitHVIndex;    sti: MSTIndex;    FOR i: CARDINAL IN [s.offset .. s.offset+s.length) DO      hash ¬ hash + LOOPHOLE[s.base[i], CARDINAL] ENDLOOP;    hvi ¬ hash MOD SLitHVLength;    FOR sti ¬ h.litSHashVec[hvi], h.stb[sti].link UNTIL sti = MSTNull DO      v: LONG STRING = StringValue[h, sti];      desc: String.SubStringDescriptor ¬ [base:v, offset:0, length:v.length];      IF String.EqualSubStrings[s, @desc] THEN EXIT;      REPEAT	FINISHED => {	  nw: CARDINAL = SIZE[StringBody[s.length]];	  ti: Alloc.OrderedIndex = h.table.Words[stType, SizeSTPrefix + nw];	  IF ti >= STMax THEN ERROR h.table.Failure[stType];	  sti ¬ ti;	  h.stb[sti] ¬ STRecord[master[	      info: 0,	      codeIndex: 0,	      local: FALSE,	      link: h.litSHashVec[hvi],	      string: [		length: 0,		maxlength: ((s.length + (CpW-1))/CpW) * CpW,		text: ]]];	  String.AppendSubString[@h.stb[sti].string, s];	  FOR i: CARDINAL IN [s.length .. h.stb[sti].string.maxlength) DO	    String.AppendChar[@h.stb[sti].string, 0C] ENDLOOP;	  h.stb[sti].string.length ¬ s.length;	  h.stLimit ¬ h.stLimit + (SizeSTPrefix + nw);	  h.litSHashVec[hvi] ¬ sti};      ENDLOOP;    RETURN [sti]};  MasterString: PROC [h: Handle, sti: STIndex] RETURNS [MSTIndex] = {    RETURN [WITH s: h.stb[sti] SELECT FROM      master => LOOPHOLE[sti],      copy => s.link,      heap => s.link,      ENDCASE => MSTNull]};  StringReference: PROC [h: Handle, sti: STIndex] = {    WITH s: h.stb[sti] SELECT FROM      master => s.info ¬ s.info + 1;      ENDCASE => NULL};  StringValue: PROC [h: Handle, sti: STIndex] RETURNS [LONG STRING] = {    RETURN [@h.stb[MasterString[h, sti]].string]};  TextType: PROC [h: Handle, sti: STIndex] RETURNS [Symbols.SEIndex] = {    RETURN [WITH s: h.stb[sti] SELECT FROM heap => s.type, ENDCASE => ERROR]};  ResetLocalStrings: PROC [h: Handle] RETURNS [key: STIndex] = {    IF ~h.localStrings THEN key ¬ STNull    ELSE {key ¬ h.localStart; h.stringsMarkBit ¬ ~h.stringsMarkBit};    h.localStrings ¬ FALSE; h.localStart ¬ h.table.Top[stType];    RETURN};  FindHeapString: PROC [h: Handle, key: STIndex, type: Symbols.SEIndex] RETURNS [sti: STIndex] = {    next: STIndex;    master: MSTIndex = MasterString[h, key];    FOR sti ¬ FIRST[STIndex], next UNTIL sti = h.stLimit DO      WITH s: h.stb[sti] SELECT FROM	master => next ¬ sti + SizeSTPrefix + SIZE[StringBody[s.string.maxlength]];	copy => next ¬ sti + SIZE[copy STRecord];	heap => {	  IF s.type = type AND s.link = master THEN EXIT;	  next ¬ sti + SIZE[heap STRecord]};	ENDCASE;      REPEAT	FINISHED => {	  ti: Alloc.OrderedIndex = h.table.Words[stType, SIZE[heap STRecord]];	  IF ti >= STMax THEN ERROR h.table.Failure[stType];	  sti ¬ ti;	  h.stb[sti] ¬ STRecord[heap[type: type, info: 0, link: master]];	  h.stLimit ¬ h.stLimit + SIZE[heap STRecord]};      ENDLOOP;    RETURN};  FindLocalString: PROC [h: Handle, key: STIndex] RETURNS [sti: STIndex] = {    next: STIndex;    master: MSTIndex = MasterString[h, key];    FOR sti ¬ h.localStart, next UNTIL sti = h.stLimit DO      WITH s: h.stb[sti] SELECT FROM	master =>	  next ¬ sti + SizeSTPrefix + SIZE[StringBody[s.string.maxlength]];	copy => {	  IF s.link = master THEN EXIT;	  next ¬ sti + SIZE[copy STRecord]};	heap => next ¬ sti + SIZE[heap STRecord];	ENDCASE;      REPEAT	FINISHED => {	  ti: Alloc.OrderedIndex = h.table.Words[stType, SIZE[copy STRecord]];	  IF ti >= STMax THEN ERROR h.table.Failure[stType];	  sti ¬ ti;  h.stb[sti] ¬ STRecord[copy[mark: h.stringsMarkBit, link: master]];	  h.stLimit ¬ h.stLimit + SIZE[copy STRecord];	  h.localStrings ¬ TRUE};      ENDLOOP;    RETURN};  EnumerateHeapStrings: PROC [h: Handle, proc: PROC [STIndex]] = {    next: STIndex;    FOR sti: STIndex ¬ FIRST[STIndex], next UNTIL sti = h.stLimit DO      WITH s: h.stb[sti] SELECT FROM	master => next ¬ sti + SizeSTPrefix + SIZE[StringBody[s.string.maxlength]];	copy => next ¬ sti + SIZE[copy STRecord];	heap => {proc[sti]; next ¬ sti + SIZE[heap STRecord]};	ENDCASE => ERROR;      ENDLOOP};  EnumerateLocalStrings: PROC [h: Handle, key: STIndex, proc: PROC [MSTIndex]] = {    next: STIndex;    started, mark: BOOLEAN;    IF key = STNull THEN RETURN;    started ¬ FALSE;    FOR sti: STIndex ¬ key, next UNTIL sti = h.stLimit DO      WITH s: h.stb[sti] SELECT FROM	master => next ¬ sti + SizeSTPrefix + SIZE[StringBody[s.string.maxlength]];	copy => {	  IF ~started THEN {mark ¬ s.mark;  started ¬ TRUE};	  IF s.mark # mark THEN EXIT;	  proc[s.link];	  next ¬ sti + SIZE[copy STRecord]};	heap => next ¬ sti + SIZE[heap STRecord];	ENDCASE => ERROR;      ENDLOOP};  EnumerateMasterStrings: PROC [h: Handle, proc: PROC [MSTIndex]] = {    next: STIndex;    FOR sti: STIndex ¬ FIRST[STIndex], next UNTIL sti = h.stLimit DO      WITH s: h.stb[sti] SELECT FROM	master => {	  proc[LOOPHOLE[sti]];	  next ¬ sti + SizeSTPrefix + SIZE[StringBody[s.string.maxlength]]};	copy => next ¬ sti + SIZE[copy STRecord];	heap => next ¬ sti + SIZE[heap STRecord];	ENDCASE => ERROR;      ENDLOOP};  }.
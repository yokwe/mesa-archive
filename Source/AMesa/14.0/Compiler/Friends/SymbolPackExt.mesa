-- Copyright (C) 1982, 1984, 1985, 1986  by Xerox Corporation. All rights reserved. -- file SymbolPackExt.mesa-- last modified by Satterthwaite,  9-Feb-82 10:03:22-- last modified by Sweet, 10-May-84 14:44:48-- last modified by Wagner, 16-Aug-86 11:48:32DIRECTORY  Alloc USING [    Handle, Index, Notifier, AddNotify, Bounds, DropNotify, Top, Words],  LiteralOps: TYPE USING [LitInitialize, LitFinalize],  String USING [    SubString, SubStringDescriptor, AppendSubString, EqualSubStrings],  Symbols USING [    Base, ExtensionType, HashVector, HVIndex, HTRecord, HTIndex,    SERecord, ISEIndex, CSEIndex,    ContextLevel, CTXIndex, CTXRecord, MDIndex, BTIndex,    HTNull, SENull, ISENull, CSENull, CTXNull, BTNull,    ByteLength, lG, lL, lZ, typeANY, typeTYPE, WordLength,    htType, ssType, seType, ctxType, mdType, bodyType],  SymbolOps USING [    CtxEntries, FindExtension, FirstCtxSe, FromBti, HashValue, NextSe, ParentBti,    SubStringForHash, TypeForm, XferMode],  SymbolSegment USING [    Base, ExtIndex, ExtRecord, extType, ltType, stType, treeType],  SymbolTable USING [Handle, Object],  Tree USING [Base, Link, Null],  TreeOps USING [IdentityMap, TreeInitialize, TreeFinalize];SymbolPackExt: MONITOR LOCKS h USING h: Handle    IMPORTS Alloc, LiteralOps, String, SymbolOps, TreeOps    EXPORTS SymbolOps = PUBLIC {  OPEN SymbolOps, Symbols;    Handle: TYPE = SymbolTable.Handle;  CharsPerWord: PRIVATE CARDINAL = Symbols.WordLength/Symbols.ByteLength;  SubString: PRIVATE TYPE = String.SubString;  UpdateBases: PRIVATE Alloc.Notifier = {    -- called whenever a symbol table is repacked    h: Handle = clientData;    h.ssb ¬ LOOPHOLE[base[ssType], LONG STRING];    h.ht.BASE ¬ base[htType];    h.seb ¬ base[seType];    h.ctxb ¬ base[ctxType];      h.mdb ¬ base[mdType];    h.bb ¬ base[bodyType];    h.tb ¬ base[SymbolSegment.treeType];    h.ltb ¬ base[SymbolSegment.ltType];    h.stb ¬ base[SymbolSegment.stType];    h.extb ¬ base[SymbolSegment.extType]};  Create: PROC [ownTable: Alloc.Handle, scratchZone: UNCOUNTED ZONE]     RETURNS [h: Handle] = {     -- called to set up the symbol table     h ¬ scratchZone.NEW[SymbolTable.Object];    h.zone ¬ scratchZone;    h.hashVec ¬ scratchZone.NEW[HashVector ¬ ALL[HTNull]];    h.mdLimit ¬ FIRST[MDIndex];    h.extLimit ¬ FIRST[SymbolSegment.ExtIndex];    h.mainCtx ¬ CTXNull;  h.stHandle ¬ NIL;  h.sourceFile ¬ NIL;    h.table ¬ ownTable;      h.table.AddNotify[UpdateBases, h]; -- sets bases    h.ssw ¬ ownTable.Words[ssType, SIZE[StringBody[0]]] + SIZE[StringBody[0]];    h.ssb­ ¬ StringBody[length:0, maxlength:0, text:];    IF AllocateHash[h] # HTNull THEN ERROR;    IF MakeNonCtxSe[h, SIZE[nil cons SERecord]] # SENull THEN ERROR;    h.seb[CSENull] ¬ SERecord[mark3: FALSE, mark4: FALSE, body: cons[nil[]]];    IF MakeNonCtxSe[h, SIZE[mode cons SERecord]] # typeTYPE THEN ERROR;    h.seb[typeTYPE] ¬ SERecord[mark3: TRUE, mark4: TRUE, body: cons[mode[]]];    IF ownTable.Words[ctxType, SIZE [nil CTXRecord]] # CTXNull THEN ERROR;    h.ctxb[CTXNull] ¬ CTXRecord[FALSE, FALSE, ISENull, lZ, nil[]];    LiteralOps.LitInitialize[h];    TreeOps.TreeInitialize[h]};     Reset: ENTRY PROC [h: Handle] = {     -- called only from debugger as far as I know    ENABLE UNWIND => NULL;    nC: CARDINAL = (h.table.Bounds[ssType].size - SIZE[StringBody[0]]) *       CharsPerWord;    desc: String.SubStringDescriptor;    hvi: HVIndex;    htLimit: HTIndex = h.table.Bounds[htType].size/SIZE[HTRecord];    h.ht.LENGTH ¬ htLimit;    h.hashVec­ ¬ ALL[HTNull];    IF htLimit = 0     THEN {      h.ssw ¬ h.table.Words[ssType, SIZE[StringBody[0]]] + SIZE[StringBody[0]];      h.ssb­ ¬ StringBody[length: 0, maxlength: 0, text:];      IF AllocateHash[h] # HTNull THEN ERROR }    ELSE {      h.ssw ¬ h.table.Top[ssType];      h.ssb­ ¬ [length: h.ht[htLimit-1].ssIndex, maxlength: nC, text:];      FOR hti: HTIndex IN (HTNull..htLimit) DO	SymbolOps.SubStringForHash[h, @desc, hti];  hvi ¬ HashValue[@desc];	h.ht[hti].link ¬ h.hashVec[hvi];  h.hashVec[hvi] ¬ hti;	h.ht[hti].anyInternal ¬ h.ht[hti].anyPublic ¬ FALSE;	ENDLOOP };    h.mdLimit ¬ h.table.Top[mdType];    h.extLimit ¬ h.table.Top[SymbolSegment.extType];    -- Assume se and ct are zero    IF MakeNonCtxSe[h, SIZE[nil cons SERecord]] # SENull THEN ERROR;    h.seb[CSENull] ¬ SERecord[mark3: FALSE, mark4: FALSE, body: cons[nil[]]];    IF MakeNonCtxSe[h, SIZE[mode cons SERecord]] # typeTYPE THEN ERROR;    h.seb[typeTYPE] ¬ SERecord[mark3: TRUE, mark4: TRUE, body: cons[mode[]]];    IF h.table.Words[ctxType, SIZE [nil CTXRecord]] # CTXNull THEN ERROR;    h.ctxb[CTXNull] ¬ CTXRecord[FALSE, FALSE, ISENull, lZ, nil[]];    LiteralOps.LitInitialize[h];    TreeOps.TreeInitialize[h]};  Delete, Finalize: PUBLIC PROC [h: Handle] = {    z: UNCOUNTED ZONE = h.zone;    h.table.DropNotify[UpdateBases, h];    z.FREE[@h.hashVec];      LiteralOps.LitFinalize[h];    TreeOps.TreeFinalize[h];    z.FREE[@h]};    -- hash entry creation  EnterString: ENTRY PROC [h: Handle, s: SubString] RETURNS [hti: HTIndex] = {    ENABLE UNWIND => NULL;    hvi: HVIndex = HashValue[s];    desc: String.SubStringDescriptor;    offset, length, nw: CARDINAL;    ssi: Alloc.Index;    FOR hti ¬ h.hashVec[hvi], h.ht[hti].link UNTIL hti = HTNull DO      SymbolOps.SubStringForHash[h, @desc, hti];      IF String.EqualSubStrings[s, @desc] THEN RETURN [hti];      ENDLOOP;    offset ¬ h.ssb.length;  length ¬ s.length;    nw ¬ (offset+length+(CharsPerWord-1) - h.ssb.maxlength)/CharsPerWord;    IF nw # 0 THEN {      IF (ssi ¬ h.table.Words[ssType, nw]) # h.ssw THEN ERROR;      h.ssw ¬ h.ssw + nw;      h.ssb­ ¬ StringBody[		length: h.ssb.length,		maxlength: h.ssb.maxlength + nw*CharsPerWord,		text: ]};    String.AppendSubString[h.ssb, s];    hti ¬ AllocateHash[h];  h.ht[hti].link ¬ h.hashVec[hvi];      h.hashVec[hvi] ¬ hti;    RETURN};  AllocateHash: PRIVATE PROC [h: Handle] RETURNS [hti: HTIndex] = {    hti ¬ h.ht.LENGTH;    [] ¬ h.table.Words[htType, SIZE[HTRecord]];    h.ht.LENGTH ¬ h.ht.LENGTH+1;    h.ht[hti] ¬ HTRecord[	anyInternal: FALSE, anyPublic: FALSE,	link: HTNull,	ssIndex: h.ssb.length];    RETURN [hti]};  HashBlock: PROC [h: Handle] RETURNS [LONG POINTER TO HashVector] = {    RETURN [h.hashVec]}; -- lexical level accounting  StaticNestError: SIGNAL = CODE;  NextLevel: PROC [h: Handle, cl: ContextLevel] RETURNS [nl: ContextLevel] = {    IF cl < LAST[ContextLevel] THEN nl ¬ cl+1    ELSE {SIGNAL StaticNestError; nl ¬ cl};    RETURN};  BlockLevel: PROC [cl: ContextLevel] RETURNS [nl: ContextLevel] = {    RETURN [IF cl = lG THEN lL ELSE cl]}; -- context table manipulation  Circular: PRIVATE PROC [h: Handle, ctx: CTXIndex] RETURNS [BOOLEAN] = INLINE {    RETURN [WITH c: h.ctxb[ctx] SELECT FROM       included=> ~c.reset,      ENDCASE=> FALSE]};  NewCtx: PROC [h: Handle, level: ContextLevel] RETURNS [ctx: CTXIndex] = {    -- makes a non-include context entry    ctx ¬ h.table.Words[ctxType, SIZE[simple CTXRecord]];    h.ctxb[ctx] ¬ [	mark: FALSE, varUpdated: FALSE,	seList: ISENull,	level: level,	extension: simple[ctxNew: CTXNull]];    RETURN};  SetMainCtx: PROC [h: Handle, ctx: CTXIndex] = {h.mainCtx ¬ ctx};  ResetCtxList: PROC [h: Handle, ctx: CTXIndex] = {    -- change the list for ctx to a proper chain    sei: ISEIndex = h.ctxb[ctx].seList;    IF sei # ISENull THEN {      h.ctxb[ctx].seList ¬ NextSe[h, sei]; SetSeLink[h, sei, ISENull]}};  FirstVisibleSe: PROC [h: Handle, ctx: CTXIndex] RETURNS [sei: ISEIndex] = {    sei ¬ h.ctxb[ctx].seList;    WHILE sei # ISENull AND h.seb[sei].idCtx # ctx DO       sei ¬ NextSe[h, sei];      ENDLOOP;    RETURN};  NextVisibleSe: PROC [h: Handle, sei: ISEIndex] RETURNS [next: ISEIndex] = {    IF (next ¬ sei) # ISENull THEN      UNTIL (next ¬ NextSe[h, next]) = ISENull OR h.seb[next].idCtx = h.seb[sei].idCtx DO	NULL ENDLOOP;    RETURN};  VisibleCtxEntries: PROC [h: Handle, ctx: CTXIndex] RETURNS [n: CARDINAL ¬ 0] = {    IF ctx = CTXNull OR Circular[h, ctx] THEN RETURN;    FOR sei: ISEIndex ¬ FirstCtxSe[h, ctx], NextSe[h, sei] UNTIL sei = ISENull DO      IF h.seb[sei].idCtx = ctx THEN n ¬ n+1 ENDLOOP;    RETURN};  ContextVariant: PROC [h: Handle, ctx: CTXIndex] RETURNS [sei: ISEIndex] = {    FOR sei ¬ FirstCtxSe[h, ctx], NextSe[h, sei] UNTIL sei = ISENull DO       IF TypeForm[h, h.seb[sei].idType] = union THEN RETURN ENDLOOP;    RETURN [ISENull]}; -- semantic entry creation  MakeSeChain: PROC [h: Handle, ctx: CTXIndex, n: CARDINAL, linked: BOOLEAN]      RETURNS [seChain: ISEIndex] = {    sei: ISEIndex;    IF n = 0 THEN RETURN [ISENull];    seChain ¬ h.table.Words[seType,		  (n-1)*SIZE[sequential id SERecord] + 		   (IF linked THEN SIZE[linked id SERecord] ELSE SIZE[terminal id SERecord])];    sei ¬ seChain;    THROUGH [1..n) DO      h.seb[sei] ¬ [mark3:FALSE, mark4:FALSE, body:id[,,ctx,,,,,,HTNull,,sequential[]]];      sei ¬ sei + SIZE[sequential id SERecord];      ENDLOOP;    IF linked      THEN h.seb[sei] ¬ [mark3:FALSE, mark4:FALSE, body:id[,,ctx,,,,,,HTNull,,linked[ISENull]]]      ELSE h.seb[sei] ¬ [mark3:FALSE, mark4:FALSE, body:id[,,ctx,,,,,,HTNull,,terminal[]]];    RETURN};  MakeCtxSe: PROC [h: Handle, hti: HTIndex, ctx: CTXIndex] RETURNS [sei: ISEIndex] = {    next, pSei: ISEIndex;    sei ¬ h.table.Words[seType, SIZE[linked id SERecord]];    SELECT TRUE FROM      (ctx = CTXNull) => next ¬ ISENull;      Circular[h, ctx] => {	pSei ¬ h.ctxb[ctx].seList;	IF pSei = ISENull THEN next ¬ sei	ELSE {next ¬ NextSe[h, pSei]; SetSeLink[h, pSei, sei]};	h.ctxb[ctx].seList ¬ sei};      ENDCASE => {	pSei ¬ h.ctxb[ctx].seList;	IF pSei = ISENull THEN {next ¬ ISENull; h.ctxb[ctx].seList ¬ sei}	ELSE {	  UNTIL (next ¬ NextSe[h, pSei]) = ISENull DO pSei ¬ next ENDLOOP;	  SetSeLink[h, pSei, sei]}};    h.seb[sei] ¬ [mark3:FALSE, mark4:FALSE, body:id[,,ctx,,,,,,hti,,linked[link: next]]];    RETURN};  NameClash: SIGNAL [h: Handle, hti: HTIndex] = CODE;  FillCtxSe: PROC [h: Handle, sei: ISEIndex, hti: HTIndex, public: BOOLEAN] = {    ctx: CTXIndex = h.seb[sei].idCtx;    h.seb[sei].hash ¬ hti;    IF hti # HTNull THEN {      IF h.ht[hti].anyInternal AND ctx # CTXNull THEN	FOR pSei: ISEIndex ¬ FirstCtxSe[h, ctx], NextSe[h, pSei] UNTIL pSei = sei DO	  IF h.seb[pSei].hash = hti THEN {SIGNAL NameClash[h, hti]; EXIT};	  ENDLOOP;      h.ht[hti].anyInternal ¬ TRUE;      IF public THEN h.ht[hti].anyPublic ¬ TRUE}};  EnterExtension: PROC [h: Handle, sei: ISEIndex, type: ExtensionType, tree: Tree.Link] = {    OPEN SymbolSegment;    exti: ExtIndex;    extLimit: ExtIndex = h.extLimit;    FOR exti ¬ FIRST[ExtIndex], exti + SIZE[ExtRecord] UNTIL exti = extLimit DO      IF h.extb[exti].sei = sei THEN GO TO Update;      REPEAT        Update => h.extb[exti] ¬ ExtRecord[sei:sei, type:type, tree:tree];        FINISHED =>	  IF tree # Tree.Null THEN {	    exti ¬ h.table.Words[extType, SIZE[ExtRecord]];	    h.extLimit ¬ h.extLimit + SIZE[ExtRecord];	    h.extb[exti] ¬ ExtRecord[sei:sei, type:type, tree:tree]};      ENDLOOP;    h.seb[sei].extended ¬ TRUE};  SetSeLink: PROC [h: Handle, sei, next: ISEIndex] = {    WITH h.seb[sei] SELECT FROM linked => link ¬ next; ENDCASE => ERROR};  MakeNonCtxSe: PROC [h: Handle, size: CARDINAL] RETURNS [sei: CSEIndex] = {    sei ¬ h.table.Words[seType, size];    h.seb[sei] ¬ [mark3: FALSE, mark4: FALSE, body: cons[typeInfo: ]];    RETURN}; -- copying within current table  CopyBasicType: PUBLIC PROC [h: Handle, type: CSEIndex] RETURNS [copy: CSEIndex] = {    WITH master: h.seb[type] SELECT FROM      basic => {	copy ¬ MakeNonCtxSe[h, SIZE[basic cons SERecord]];	h.seb[copy] ¬ SERecord[	    mark3: master.mark3, mark4: master.mark4,	    body: cons[basic[		code: master.code, ordered: master.ordered,		length: master.length]]]}      ENDCASE => copy ¬ typeANY;    RETURN};  CopyXferType: PUBLIC PROC [h: Handle, type: CSEIndex] RETURNS [copy: CSEIndex] = {    WITH master: h.seb[type] SELECT FROM      transfer => {	copy ¬ MakeNonCtxSe[h, SIZE[transfer cons SERecord]];	h.seb[copy] ¬ SERecord[	    mark3: master.mark3, mark4: master.mark4,	    body: cons[transfer[		mode: master.mode, safe: master.safe,		typeIn: CopyArgs[h, master.typeIn, FALSE],		typeOut: CopyArgs[h, master.typeOut, TRUE]]]]};      ENDCASE => copy ¬ typeANY;    RETURN};  CopyArgSe: PUBLIC PROC [h: Handle, copy, master: ISEIndex] = {    CopyArg[h, copy, master, FALSE]};  CopyArgs: PROC [h: Handle, argSei: CSEIndex, copyExt: BOOLEAN] RETURNS [copy: CSEIndex] = {    IF argSei = CSENull THEN copy ¬ CSENull    ELSE      WITH t: h.seb[argSei] SELECT FROM        record => {	  ctx1: CTXIndex = t.fieldCtx;	  ctx2: CTXIndex = NewCtx[h, h.ctxb[ctx1].level];	  seChain: ISEIndex = MakeSeChain[h, ctx2, CtxEntries[h, ctx1], FALSE];	  sei1: ISEIndex ¬ h.ctxb[ctx1].seList;	  sei2: ISEIndex ¬ h.ctxb[ctx2].seList ¬ seChain;	  UNTIL sei1 = ISENull DO	    CopyArg[h, sei2, sei1, copyExt];	    sei1 ¬ NextSe[h, sei1]; sei2 ¬ NextSe[h, sei2];	    ENDLOOP;	  copy ¬ MakeNonCtxSe[h, SIZE[notLinked record cons SERecord]];	  h.seb[copy] ¬ SERecord[mark3: t.mark3, mark4: t.mark4,		body: cons[		  record[		    machineDep: FALSE,		    painted: t.painted, argument: TRUE,		    hints: t.hints,		    fieldCtx: ctx2,		    length: t.length,		    monitored: FALSE,		    linkPart: notLinked[]]]]};        any => {	  copy ¬ MakeNonCtxSe[h, SIZE[any cons SERecord]];	  h.seb[copy] ¬ SERecord[mark3: t.mark3, mark4: t.mark4,		body: cons[any[]]]};	ENDCASE => ERROR;    RETURN};  CopyArg: PROC [h: Handle, copy, master: ISEIndex, copyExt: BOOLEAN] = {    h.seb[copy].hash ¬ h.seb[master].hash;    h.seb[copy].public ¬ h.seb[master].public;    h.seb[copy].immutable ¬ h.seb[master].immutable;    h.seb[copy].constant ¬ h.seb[master].constant;    h.seb[copy].idType ¬ h.seb[master].idType;    h.seb[copy].idInfo ¬  h.seb[master].idInfo;    h.seb[copy].idValue ¬ h.seb[master].idValue;    h.seb[copy].linkSpace ¬ FALSE;    h.seb[copy].mark3 ¬ h.seb[master].mark3; h.seb[copy].mark4 ¬ h.seb[master].mark4;    IF copyExt AND h.seb[master].extended THEN {      type: ExtensionType;      t: Tree.Link;      [type, t] ¬ FindExtension[h, master];      EnterExtension[h, copy, type, TreeOps.IdentityMap[h, t]]}    ELSE h.seb[copy].extended ¬ FALSE}; -- body table utilities  LinkBti: PROC [h: Handle, bti, parent: BTIndex] = {    prev: BTIndex;    IF parent # BTNull THEN {      IF (prev ¬ h.bb[parent].firstSon) = BTNull THEN h.bb[parent].firstSon ¬ bti      ELSE {	UNTIL h.bb[prev].link.which = parent DO prev ¬ h.bb[prev].link.index ENDLOOP;	h.bb[prev].link ¬ [which:sibling, index:bti]}};    h.bb[bti].link ¬ [which:parent, index:parent]};  DelinkBti: PROC [h: Handle, bti: BTIndex] = {    prev, next: BTIndex;    parent: BTIndex = ParentBti[h, bti];    IF parent # BTNull THEN {      prev ¬ h.bb[parent].firstSon;      IF prev = bti THEN        h.bb[parent].firstSon ¬	  IF h.bb[bti].link.which = parent THEN BTNull ELSE h.bb[bti].link.index      ELSE {	UNTIL (next ¬ h.bb[prev].link.index) = bti DO prev ¬ next ENDLOOP;	h.bb[prev].link ¬ h.bb[next].link}};    h.bb[bti].link ¬ [which:parent, index:BTNull]}; -- attribute extraction  ConstantId: PROC [h: Handle, sei: ISEIndex] RETURNS [BOOLEAN] = {    RETURN [IF ~h.seb[sei].constant      THEN FALSE      ELSE	SELECT XferMode[h, h.seb[sei].idType] FROM	  proc, signal, error, program => 	    h.seb[sei].mark4 AND h.seb[sei].idInfo = SymbolOps.FromBti[BTNull],	  ENDCASE => TRUE]};	  	    SetSource: PROC[h: Handle, sourceFile: LONG STRING] = {    ss: String.SubStringDescriptor ¬ [sourceFile, 0, sourceFile.length];    [] ¬ EnterString[h, @ss];    h.sourceFile ¬ sourceFile;  };  }.
-- Copyright (C) 1980, 1981, 1982, 1983, 1985, 1986  by Xerox Corporation. All rights reserved. -- file FilePack.Mesa-- last modified by Satterthwaite, November 18, 1980  3:20 PM-- Russ Atkinson,	21-Nov-80 10:10:57, made LONG-- JGS,		25-Aug-81 14:19:39-- Sweet,	18-Oct-82 13:55:15-- Bruce,	19-Jan-82 10:44:24-- Lewis,	 8-Oct-81 10:31:09-- Haynes,	12-Apr-83 14:29:49-- Wagner	22-Aug-86 13:51:30DIRECTORY  Alloc USING [Handle, Top, Words],  BcdDefs USING [    MTIndex, MTRecord, NameRecord, PackedString, SGIndex, VersionStamp,    FTSelf, SGNull, VersionID],  BcdDefsExtras USING [GFTVersionID],  BcdOps USING [BcdBase, NameString],  Copier USING [],  Environment USING [PageCount],  File USING [File],  MFile USING [    AddNotifyProc, Error, Handle, maxNameLength, NotifyProc,     PleaseReleaseProc, ReadOnly, Release, RemoveNotifyProc],  MSegment USING [    Address, CopyIn, Create, Delete, GetFile, GetFileBase, Handle,     Pages, PleaseReleaseProc, SetReleaseData],  SpecialMFile USING [GetCapaWithAccess],  String USING [    AppendChar, AppendString, AppendSubString, SubString,     SubStringDescriptor, EqualSubStrings],  SymbolOps USING [EnterString, SubStringForHash],  Symbols USING [    Base, mdType, HTIndex, MDRecord, MDIndex, FileIndex,    HTNull, CTXNull, IncludedCTXNull, OwnMdi, MDNull, NullFileIndex],  SymbolSegment USING [VersionID],  SymbolTable USING [    Handle, Acquire, CacheSize, Release, SetCacheSize, FileTable],  Table USING [Base],  TimeStamp USING [Stamp];FilePack: MONITOR    IMPORTS Alloc, MFile, MSegment, SpecialMFile, String, SymbolTable, SymbolOps    EXPORTS Copier, SymbolTable =   BEGIN  OPEN Symbols;    MSegHandle: PUBLIC TYPE = MSegment.Handle;  altoBias: CARDINAL = 1;  Handle: TYPE = SymbolTable.Handle;    EquivalentSegments: PUBLIC PROC [seg1, seg2: MSegment.Handle] RETURNS [BOOLEAN] = {    SELECT TRUE FROM      seg1 = NIL => RETURN[seg2 = NIL];      seg2 = NIL => RETURN[FALSE];      MSegment.GetFileBase[seg1] # MSegment.GetFileBase[seg2] => RETURN[FALSE];      MSegment.Pages[seg1] # MSegment.Pages[seg2] => RETURN[FALSE];      ENDCASE;    RETURN[EquivalentFiles[MSegment.GetFile[seg1], MSegment.GetFile[seg2]]]};      EquivalentFiles: PUBLIC PROC [file1, file2: MFile.Handle] RETURNS [BOOLEAN] = {    cap1: File.File = SpecialMFile.GetCapaWithAccess[file1];    cap2: File.File = SpecialMFile.GetCapaWithAccess[file2];    RETURN[cap1 = cap2]};    -- included module accounting  VersionStamp: TYPE = BcdDefs.VersionStamp;  FileProblem: PUBLIC SIGNAL [Handle, HTIndex] RETURNS [BOOLEAN] = CODE;  FileVersion: PUBLIC SIGNAL [    h: Handle, hti: HTIndex, have, want: TimeStamp.Stamp] RETURNS [BOOLEAN] = CODE;  FileVersionMix: PUBLIC SIGNAL [Handle, HTIndex] = CODE;  AnyVersion: VersionStamp = [net:0, host:0, time:0];  EnterFile: PUBLIC PROC [     h: Handle, id: HTIndex, name: String.SubString] RETURNS [MDIndex] = {    RETURN [FindMdEntry[h, id, AnyVersion, NormalizeFileName[h, name]]]};  NormalizeFileName: PROC [h: Handle, name: String.SubString] RETURNS [hti: HTIndex] = {    char: CHARACTER;    dot: BOOLEAN ¬ FALSE;    s: LONG STRING ¬ h.zone.NEW[StringBody[name.length+(".bcd"L).length+1]];    desc: String.SubStringDescriptor;    first: CARDINAL ¬ name.offset;    FOR i: CARDINAL DECREASING IN [name.offset .. name.offset+name.length) DO      SELECT (char ¬ name.base[i]) FROM	'], '> => {first ¬ i+1; EXIT};	ENDCASE;      ENDLOOP;    FOR i: CARDINAL IN [first..name.offset+name.length)      DO      SELECT (char ¬ name.base[i]) FROM	'. =>  dot ¬ TRUE;	ENDCASE;      String.AppendChar[s, char];      ENDLOOP;    IF ~dot THEN String.AppendString[s, ".bcd"L];    desc ¬ [base:s, offset:0, length: s.length];    hti ¬ SymbolOps.EnterString[h, @desc];    h.zone.FREE[@s];  RETURN};  HtiToMdi: PUBLIC PROC [h: Handle, hti: HTIndex] RETURNS [mdi: MDIndex] = {    IF hti # HTNull THEN {      limit: MDIndex = h.table.Top[mdType];      FOR mdi ¬ FIRST[MDIndex], mdi + SIZE[MDRecord] UNTIL mdi = limit DO	IF hti = h.mdb[mdi].moduleId THEN RETURN ENDLOOP};    RETURN [MDNull]};  FindMdEntry: PUBLIC PROC [h: Handle, id: HTIndex, version: VersionStamp, file: HTIndex]      RETURNS [mdi: MDIndex] = {    limit: MDIndex = h.table.Top[mdType];    duplicate: BOOLEAN ¬ FALSE;    FOR mdi ¬ FIRST[MDIndex], mdi + SIZE[MDRecord] UNTIL mdi = limit DO      IF h.mdb[mdi].moduleId = id THEN {	  IF h.mdb[mdi].stamp = version THEN RETURN;	  IF h.mdb[mdi].stamp = AnyVersion THEN {	      OpenSymbols[h, mdi ! FileProblem => RESUME [FALSE]];	      IF h.mdb[mdi].stamp = version THEN RETURN};	  IF h.mdb[mdi].stamp # AnyVersion AND	    version # AnyVersion THEN duplicate ¬ TRUE};      ENDLOOP;    IF duplicate THEN SIGNAL FileVersionMix[h, id];    mdi ¬ h.table.Words[mdType, SIZE[MDRecord]];    h.mdb[mdi] ¬ MDRecord[	stamp: version,	moduleId: id,	fileId: file,	ctx: IncludedCTXNull,	shared: FALSE, exported: FALSE,	defaultImport: CTXNull,	file: NullFileIndex];    h.mdLimit ¬ h.mdLimit + SIZE[MDRecord];    RETURN};  EnterFileSegment: PUBLIC PROC [	h: Handle, id: HTIndex, version: VersionStamp, fileSeg: MSegment.Handle,	file: MFile.Handle ¬ NIL]      RETURNS [mdi: MDIndex] = {    limit: MDIndex = h.table.Top[mdType];    IF file # NIL THEN ERROR;    FOR mdi ¬ FIRST[MDIndex], mdi + SIZE[MDRecord] UNTIL mdi = limit DO      IF h.mdb[mdi].stamp = version AND (id = HTNull OR id = h.mdb[mdi].moduleId)	THEN GO TO Found;      REPEAT	Found => NULL;	FINISHED => {	  mdi ¬ h.table.Words[mdType, SIZE[MDRecord]];	  h.mdb[mdi] ¬ MDRecord[	    stamp: version,	    moduleId: id,	    fileId: HTNull,	    ctx: IncludedCTXNull,	    shared: FALSE, exported: FALSE,	    defaultImport: CTXNull,	    file: ];	  h.mdLimit ¬ h.mdLimit + SIZE[MDRecord]};      ENDLOOP;    FOR i: FileIndex IN [0..h.lastFile] DO      IF ~EquivalentSegments[F[h.fileTable][i].seg, fileSeg] THEN LOOP;      MSegment.Delete[fileSeg];      h.mdb[mdi].file ¬ i;      RETURN;      ENDLOOP;    EnterSegment[h, mdi, fileSeg];     RETURN};    SegmentReleaseRec: TYPE = RECORD [h: Handle, lastFile: INTEGER];  SegmentReleasePtr: TYPE = LONG POINTER TO SegmentReleaseRec;  EnterSegment: PROC [h: Handle, mdi: MDIndex, fileSeg: MSegment.Handle] = {    h.lastFile ¬ h.lastFile + 1;    UNTIL h.lastFile < F[h.fileTable].length DO ExpandFileTable[h] ENDLOOP;    F[h.fileTable][h.lastFile] ¬ [fileSeg];  -- this may actually be NullFileRecord!    IF h.purgeProc # NIL AND fileSeg # NIL THEN  -- CoPilot      {data: SegmentReleasePtr = h.zone.NEW[SegmentReleaseRec ¬ [h, h.lastFile]];      MSegment.SetReleaseData[fileSeg, [FreeSegment, data]]};    h.mdb[mdi].file ¬ h.lastFile};     GetSymbolTable: PUBLIC PROC [h: Handle, mdi: MDIndex] RETURNS [newH: Handle] = {    index: FileIndex;    OpenSymbols[h, mdi];    index ¬ h.mdb[mdi].file;    IF index = NullFileIndex OR F[h.fileTable][index].seg = NIL THEN newH ¬ NIL    ELSE {	newH ¬ SymbolTable.Acquire[LOOPHOLE[F[h.fileTable][index].seg]];	IF newH.stHandle.versionIdent # SymbolSegment.VersionID	  THEN {	    SymbolTable.Release[newH];  newH ¬ NIL;	    IF SIGNAL FileProblem[h, h.mdb[mdi].fileId]	      THEN {		size: CARDINAL = SymbolTable.CacheSize[];		SymbolTable.SetCacheSize[0];	-- clear cache		MSegment.Delete[F[h.fileTable][index].seg];		F[h.fileTable][index] ¬ NullFileRecord;		SymbolTable.SetCacheSize[size]}}};    RETURN};  FreeSymbolTable: PUBLIC PROC [h: Handle] = {    SymbolTable.Release[h]};  -- low-level file manipulation  FileTable: PUBLIC TYPE = RECORD[SEQUENCE length: NAT OF FileRecord];  FileRecord: TYPE = RECORD[seg: MSegHandle];  NullFileRecord: FileRecord = FileRecord[NIL];  F: PROC[f: LONG POINTER TO SymbolTable.FileTable] RETURNS[LONG POINTER TO FileTable] =     INLINE {RETURN[LOOPHOLE[f]]};  -- file table management  FileInit: PUBLIC PROC [      h: Handle, self: LONG STRING, version: VersionStamp,      purgeProc: PROC [data: LONG POINTER, mdi: MDIndex] ¬ NIL,       purgeData: LONG POINTER ¬ NIL] = {    ss: String.SubStringDescriptor ¬ [base:self, offset:0, length:self.length];    moduleId: HTIndex ¬ SymbolOps.EnterString[h, @ss];    fileId: HTIndex ¬ NormalizeFileName[h, @ss];    IF FindMdEntry[h, moduleId, version, fileId] # Symbols.OwnMdi THEN ERROR;    IF h.purgeProc = NIL AND purgeProc # NIL THEN {-- only on CoPilot's first call      h.purgeProc ¬ purgeProc;      h.purgeData ¬ purgeData;      MFile.AddNotifyProc[FilesAvailable, ["*.bcd"L, binary, readOnly], h]};    h.fileTable ¬ NIL; h.lastFile ¬ -1};      FileQuit: PUBLIC PROC [h: Handle] = {    FileReset[h];    MFile.RemoveNotifyProc[FilesAvailable, ["*.bcd"L, binary, readOnly], h]};  CreateFileTable: PUBLIC PROC [h: Handle, size: CARDINAL] = {    n: CARDINAL = size+1;	-- allow for ownMdi    h.fileTable ¬ h.zone.NEW[FileTable[n]];    FOR i: FileIndex IN [0..n) DO F[h.fileTable][i] ¬ NullFileRecord ENDLOOP;    h.lastFile ¬ -1};  ExpandFileTable: PROC [h: Handle] = {    newTable: LONG POINTER TO FileTable;    i: FileIndex;    size: CARDINAL = F[h.fileTable].length + 2;    newTable ¬ h.zone.NEW[FileTable[size]];    FOR i IN [0..F[h.fileTable].length) DO newTable[i] ¬ F[h.fileTable][i] ENDLOOP;    FOR i IN [F[h.fileTable].length..size) DO newTable[i] ¬ NullFileRecord ENDLOOP;    h.zone.FREE[@h.fileTable];    h.fileTable ¬ newTable};  FileReset: PUBLIC PROC [h: Handle] = {    SymbolTable.SetCacheSize[0];    FOR i: INTEGER IN [0..h.lastFile] DO      seg: MSegment.Handle = F[h.fileTable][i].seg;      IF seg # NIL THEN MSegment.Delete[seg];      F[h.fileTable][i] ¬ NullFileRecord;      ENDLOOP;    h.zone.FREE[@h.fileTable]};  FilesAvailable: MFile.NotifyProc = {    h: Handle = LOOPHOLE[clientInstanceData, Handle];    limit: MDIndex = h.table.Top[mdType];    IF h.fileTable = NIL THEN RETURN;    FOR mdi: MDIndex ¬ OwnMdi, mdi + SIZE[MDRecord] UNTIL mdi = limit DO      index: INTEGER = h.mdb[mdi].file;      IF index # NullFileIndex AND F[h.fileTable][index] = NullFileRecord THEN 	h.mdb[mdi].file ¬ NullFileIndex;      ENDLOOP};      FreeSegment: MSegment.PleaseReleaseProc = {    h: Handle = LOOPHOLE[instanceData, SegmentReleasePtr].h;    limit: MDIndex = h.table.Top[mdType];    i: INTEGER = LOOPHOLE[instanceData, SegmentReleasePtr].lastFile;    FOR mdi: MDIndex ¬ OwnMdi, mdi + SIZE[MDRecord] UNTIL mdi = limit DO      IF h.mdb[mdi].file # i THEN LOOP;      h.mdb[mdi].file ¬ NullFileIndex;      h.purgeProc[h.purgeData, mdi];      ENDLOOP;    F[h.fileTable][i] ¬ NullFileRecord;    RETURN[goAhead]};        -- file setup  FilePack1: MFile.PleaseReleaseProc = {RETURN[no]};	-- FillFile  FilePack2: MSegment.PleaseReleaseProc = {RETURN[no]};	-- OpenSymbols  FillFile: PROC [h: Handle, mdi: MDIndex] RETURNS [file: MFile.Handle ¬ NIL] = {    desc: String.SubStringDescriptor;    filename: STRING ¬ [MFile.maxNameLength];    fileHti: HTIndex = h.mdb[mdi].fileId;    IF fileHti = HTNull THEN RETURN[NIL];    SymbolOps.SubStringForHash[h, @desc, fileHti];    String.AppendSubString[filename, @desc];    file ¬  MFile.ReadOnly[filename, [FilePack1, h] ! MFile.Error =>       SELECT code FROM        noSuchFile, conflictingAccess, protectionFault => CONTINUE;	ENDCASE]};  OpenSymbols: ENTRY PROC [h: Handle, mdi: MDIndex] =     BEGIN ENABLE UNWIND => NULL;    file: MFile.Handle;    IF h.mdb[mdi].file # NullFileIndex THEN RETURN;    file ¬ FillFile[h, mdi];    IF file # NIL THEN       BEGIN ENABLE UNWIND => MFile.Release[file];      symbolSeg: MSegment.Handle;      mtb, ftb, sgb: Table.Base;      mti: BcdDefs.MTIndex;      sSeg: BcdDefs.SGIndex;      nString: BcdOps.NameString;      d1, d2: String.SubStringDescriptor;      version: VersionStamp;      OpenBcd[file];      IF bcd.versionIdent # BcdDefs.VersionID AND         bcd.versionIdent # BcdDefsExtras.GFTVersionID THEN GO TO badFile;      IF bcd.nConfigs # 0 THEN GO TO badFile;      SymbolOps.SubStringForHash[h, @d1, h.mdb[mdi].moduleId];      nString ¬ LOOPHOLE[bcd + bcd.ssOffset];      d2.base ¬ @nString.string;      ftb ¬ LOOPHOLE[bcd + bcd.ftOffset, Table.Base];      mtb ¬ LOOPHOLE[bcd + bcd.mtOffset, Table.Base];      FOR mti ¬ FIRST[BcdDefs.MTIndex], mti + SIZE[BcdDefs.MTRecord]       UNTIL mti = bcd.mtLimit DO	d2.offset ¬ mtb[mti].name;	d2.length ¬ nString.size[mtb[mti].name];	IF String.EqualSubStrings[@d1, @d2] THEN EXIT;	REPEAT	  FINISHED =>	    IF bcd.nModules = 1 THEN mti ¬ FIRST[BcdDefs.MTIndex] 	    ELSE GOTO badFile;	ENDLOOP;      ftb ¬ LOOPHOLE[bcd + bcd.ftOffset, Table.Base];      version ¬ 	IF mtb[mti].file = BcdDefs.FTSelf THEN bcd.version	ELSE ftb[mtb[mti].file].version;      sgb ¬ LOOPHOLE[bcd + bcd.sgOffset, Table.Base];  sSeg ¬ mtb[mti].sseg;      IF sSeg = BcdDefs.SGNull OR sgb[sSeg].pages = 0 	OR sgb[sSeg].file # BcdDefs.FTSelf THEN GO TO badFile;      IF h.mdb[mdi].stamp # AnyVersion AND h.mdb[mdi].stamp # version THEN {	[] ¬ SIGNAL FileVersion[	  h: h, hti: h.mdb[mdi].moduleId, have: version, want: h.mdb[mdi].stamp];	MFile.Release[file];	RETURN};      h.mdb[mdi].stamp ¬ version;      symbolSeg ¬ MSegment.Create[	file: file, release: [FilePack2,h], fileBase: sgb[sSeg].base-altoBias, 	pages: sgb[sSeg].pages, swapInfo: [uniform[4]]];      EnterSegment[h, mdi, symbolSeg];       EXITS        badFile => {{ENABLE UNWIND => MFile.Release[file];	  EnterSegment[h, mdi, NIL]; 	  [] ¬ SIGNAL FileProblem[h, h.mdb[mdi].moduleId]};	  MFile.Release[file]};      END    ELSE {      EnterSegment[h, mdi, NIL];      [] ¬ SIGNAL FileProblem[h, h.mdb[mdi].moduleId]};    END;    TableForModule: PUBLIC PROC [h: Handle, mdi: MDIndex] RETURNS [MSegHandle] = {    RETURN[      IF h.mdb[mdi].file = NullFileIndex THEN NIL      ELSE F[h.fileTable][h.mdb[mdi].file].seg]};  bcdPages: Environment.PageCount ¬ 4;  bcdSeg: MSegment.Handle ¬ MSegment.Create[    release: [], pages: bcdPages, swapInfo: [uniform[1]]];  bcd: BcdOps.BcdBase ¬ MSegment.Address[bcdSeg];    OpenBcd: INTERNAL PROC [file: MFile.Handle] = {    MSegment.CopyIn[bcdSeg, file, 0, bcdPages];    IF bcd.nPages > bcdPages THEN {      bcdPages ¬ bcd.nPages;      MSegment.Delete[bcdSeg];      bcdSeg ¬ MSegment.Create[        release: [], pages: bcdPages, swapInfo: [uniform[1]]];      bcd ¬ MSegment.Address[bcdSeg];      MSegment.CopyIn[bcdSeg, file, 0, bcdPages]}};              END.
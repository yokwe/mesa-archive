-- Copyright (C) 1982, 1985, 1986  by Xerox Corporation. All rights reserved. -- file Copier.Mesa-- last modified by Satterthwaite, May 21, 1982 2:04 pm-- last modified by Sweet,   5-Nov-82 14:20:06-- last modified by Wagner, 	16-Aug-86 11:54:33-- Litman        5-Mar-85 18:19:25    DIRECTORY  MFile USING [Handle],  MSegment USING [Handle],  String USING [SubString],  Symbols,  SymbolTable USING [Handle],  TimeStamp USING [Stamp];Copier: DEFINITIONS =  {  OPEN Symbols;  SEToken: TYPE = PRIVATE RECORD [ISEIndex];  NullSEToken: SEToken = [ISENull];  Handle: TYPE = SymbolTable.Handle;  -- IMPLEMENTED by FilePack  FileInit: PROC [    h: Handle, self: LONG STRING, version: TimeStamp.Stamp,    purgeProc: PROC [data: LONG POINTER, mdi: MDIndex] ¬ NIL,     purgeData: LONG POINTER ¬ NIL];      FileReset: PROC [h: Handle];    FileQuit: PROC [h: Handle];  CreateFileTable: PROC [Handle, CARDINAL];    -- EnterFile puts the thing in the module table with null contexts   EnterFile: PROC [h: Handle, id: HTIndex, name: String.SubString]    RETURNS [MDIndex];      -- same as EnterFile but symbols are already mapped  EnterFileSegment: PROC [    h: Handle, id: HTIndex, version: TimeStamp.Stamp,    fileSeg: MSegment.Handle, file: MFile.Handle ¬ NIL]    RETURNS [MDIndex];      -- creates mdi if it doesn't exist  FindMdEntry: PROC [    h: Handle, id: HTIndex, version: TimeStamp.Stamp, file: HTIndex]    RETURNS [MDIndex];      FreeSymbolTable: PROC [Handle];    -- maps the symbol table of MDIndex and returns it  GetSymbolTable: PROC [Handle, MDIndex] RETURNS [Handle];    -- converts name of module into MDIndex  HtiToMdi: PROC [Handle, HTIndex] RETURNS [MDIndex];    FileProblem: SIGNAL [h: Handle, hti: HTIndex] RETURNS [BOOLEAN];  FileVersion: SIGNAL [    h: Handle, hti: HTIndex, have, want: TimeStamp.Stamp]    RETURNS [BOOLEAN];  FileVersionMix: SIGNAL [h: Handle, hti: HTIndex];  -- IMPLEMENTED by SymbolCopier  CopierInit: PROC [h: Handle, coPilot: BOOLEAN ¬ FALSE];  CopierReset: PROC [h: Handle];      AugmentContext: PROC [Handle, IncludedCTXIndex, MDIndex];  CompleteContext: PROC [    h: Handle, ctx: IncludedCTXIndex, depth: Closure ¬ unit];    -- copies bti and sei  CopyExternalBody: PROC [Handle, MDIndex, CBTIndex]    RETURNS [CBTIndex];      -- copy his sei and its type, returns my sei  CopySymbol: PROC [    h: Handle, mdi: MDIndex, iSei: SEIndex, depth: Closure ¬ full]    RETURNS [sei: SEIndex];        CopyUnion: PROC [h: Handle, ctx: CTXIndex, depth: Closure ¬ none];    -- CTXIndex is mine. It is mapped and his sei returned.  CtxFirst: PROC [Handle, CTXIndex] RETURNS [SEToken];  CtxNext: PROC [Handle, CTXIndex, SEToken] RETURNS [SEToken];    -- CTXIndex is mine. His sei returned that has idValue = CARDINAL  CtxValue: PROC [Handle, CTXIndex, Unspec] RETURNS [SEToken];    -- rips the ISEIndex out of its context  Delink: PROC [Handle, ISEIndex];    -- sei is the sei in my directory context for this mdi.  -- copy his sei from his directory context into it  FillModule: PROC [    h: Handle, sei: ISEIndex, typeId: HTIndex, mdi: MDIndex];      -- CTXIndex is his. Find the ctx it maps to in mine, creating it if necessary.   FindExternalCtx: PROC [Handle, MDIndex, CTXIndex]    RETURNS [IncludedCTXIndex];    -- MDIndex is mine. Call inner with the symbol table for it.     Outer: PROC [h: Handle, mdi: MDIndex, inner: PROC [Handle]];      -- IncludedCTXIndex is mine. Map it, search around in his context for HTIndex  -- Copy it into ISEIndex   SearchFileCtx: PROC [Handle, HTIndex, IncludedCTXIndex]    RETURNS [BOOLEAN, ISEIndex];      -- the SEToken is his, the CTXIndex is mine. Puts HTIndex into me.   TokenHash: PROC [Handle, CTXIndex, SEToken] RETURNS [HTIndex];    -- the SEToken is his, the CTXIndex is mine. Puts ISEIndex into me.  TokenSymbol: PROC [Handle, CTXIndex, SEToken] RETURNS [ISEIndex];    -- the SEToken is his, the CTXIndex is mine. Returns his idValue.  TokenValue: PROC [Handle, CTXIndex, SEToken] RETURNS [CARDINAL];  TableRelocated: SIGNAL;  UnknownModule: SIGNAL [hti: HTIndex];  CopyingInline: SIGNAL;    MSegHandle: TYPE = MSegment.Handle;    TableForModule: PUBLIC PROC [h: Handle, mdi: MDIndex] RETURNS [MSegHandle];  }.
-- Copyright (C) 1982, 1983, 1984, 1985, 1986  by Xerox Corporation. All rights reserved. -- file SymbolPack.Mesa--   Satterthwaite,	 9-Feb-82  9:56:48--   Sweet,		10-May-84 15:06:15--   Johnsson,		20-Jun-83 16:03:34--   Wagner		16-Aug-86 11:41:25DIRECTORY  Inline USING [BITAND, BITXOR],  String USING [SubString, SubStringDescriptor, EqualSubStrings],  Symbols,  SymbolOps USING [PackedSize, ToBitAddr, ToCard, ToSei],  SymbolSegment USING [Base, ExtIndex, ExtRecord],  SymbolTable USING [Handle],  TimeStamp USING [Stamp],  Tree USING [Link, Null];SymbolPack: MONITOR    IMPORTS Inline, String, SymbolOps    EXPORTS SymbolOps    SHARES Symbols = PUBLIC {  OPEN Symbols;    Handle: TYPE = SymbolTable.Handle; -- hash manipulation  SubString: TYPE = String.SubString;  FindString: ENTRY PROC [h: Handle, s: SubString] RETURNS [hti: HTIndex] = {    ENABLE UNWIND => NULL;    desc: String.SubStringDescriptor;    ss: SubString = @desc;    hti ¬ h.hashVec[HashValue[s]];    WHILE hti # HTNull DO      SubStringForHash[h, ss, hti];      IF String.EqualSubStrings[s,ss] THEN EXIT;      hti ¬ h.ht[hti].link;      ENDLOOP;    RETURN};  HashValue: PROC [s: SubString] RETURNS [HVIndex] = {    CharBits: PROC [CHARACTER, WORD] RETURNS [WORD] = LOOPHOLE[Inline.BITAND];    Mask: WORD = 337b;		-- masks out ASCII case shifts    n: CARDINAL = s.length;    b: LONG STRING = s.base;    v: WORD;    v ¬ CharBits[b[s.offset], Mask]*177b + CharBits[b[s.offset+(n-1)], Mask];    RETURN [Inline.BITXOR[v, n*17b] MOD Symbols.HVLength]};  SubStringForHash: PROC [h: Handle, s: SubString, hti: HTIndex] = {    s.base ¬ h.ssb;    IF hti = HTNull      THEN s.offset ¬ s.length ¬ 0      ELSE s.length ¬ h.ht[hti].ssIndex - (s.offset ¬ h.ht[hti-1].ssIndex)}; -- context management  CtxEntries: PROC [h: Handle, ctx: CTXIndex] RETURNS [n: CARDINAL] = {    n ¬ 0;    IF ctx = CTXNull THEN RETURN;    WITH c: h.ctxb[ctx] SELECT FROM      included => IF ~c.reset THEN RETURN;      ENDCASE;    FOR sei: ISEIndex ¬ FirstCtxSe[h, ctx], NextSe[h, sei] UNTIL sei = SENull DO n ¬ n+1 ENDLOOP;    RETURN};  FirstCtxSe: PROC [h: Handle, ctx: CTXIndex] RETURNS [ISEIndex] = {    RETURN [IF ctx = CTXNull THEN ISENull ELSE h.ctxb[ctx].seList]};  NextSe: PROC [h: Handle, sei: ISEIndex] RETURNS [ISEIndex] = {    RETURN [      IF sei = SENull	THEN ISENull	ELSE	  WITH id: h.seb[sei] SELECT FROM	    terminal => ISENull,	    sequential => sei + SIZE[sequential id SERecord],	    linked => id.link,	    ENDCASE => ISENull]};  SearchContext: PROC [h: Handle, hti: HTIndex, ctx: CTXIndex] RETURNS [ISEIndex] = {    sei, root: ISEIndex;    IF ctx # CTXNull AND hti # HTNull      THEN {	sei ¬ root ¬ h.ctxb[ctx].seList;	DO	  IF sei = SENull THEN EXIT;	  IF h.seb[sei].hash = hti THEN RETURN [sei];	  WITH id: h.seb[sei] SELECT FROM	    sequential => sei ¬ sei + SIZE[sequential id SERecord];	    linked => IF (sei ¬ id.link) = root THEN EXIT;	    ENDCASE => EXIT;	  ENDLOOP};    RETURN [ISENull]};  SeiForValue: PROC [h: Handle, value: Unspec, ctx: CTXIndex] RETURNS [ISEIndex] = {    FOR sei: ISEIndex ¬ FirstCtxSe[h, ctx], NextSe[h, sei] UNTIL sei = ISENull DO      IF h.seb[sei].idValue = value THEN RETURN [sei] ENDLOOP;    RETURN [ISENull]}; -- module management  FindMdi: PROC [h: Handle, stamp: TimeStamp.Stamp] RETURNS [MDIndex] = {    FOR mdi: MDIndex ¬ FIRST[MDIndex], mdi + SIZE[MDRecord]       UNTIL mdi = h.mdLimit DO      IF h.mdb[mdi].stamp = stamp THEN RETURN [mdi] ENDLOOP;    RETURN [MDNull]}; -- type manipulation  ArgCtx: PROC [h: Handle, type: CSEIndex] RETURNS [CTXIndex] = {    sei: RecordSEIndex = ArgRecord[h, type];    RETURN [IF sei = RecordSENull THEN CTXNull ELSE h.seb[sei].fieldCtx]};	  ArgRecord: PROC [h: Handle, type: CSEIndex] RETURNS [RecordSEIndex] = {    RETURN [IF type = SENull      THEN RecordSENull      ELSE WITH h.seb[type] SELECT FROM        record => LOOPHOLE[type, RecordSEIndex],	ENDCASE => RecordSENull]};	  ClusterSe: PROC [h: Handle, type: SEIndex] RETURNS [SEIndex] = {    WITH t: h.seb[type] SELECT FROM      id => {        next: SEIndex = SymbolOps.ToSei[t.idInfo];	RETURN [IF t.extended	  THEN type	  ELSE WITH u: h.seb[next] SELECT FROM	    id => IF t.hash = u.hash THEN ClusterSe[h, next] ELSE type,	    ENDCASE => type]};      ENDCASE => RETURN [type]};  NormalType: PROC [h: Handle, type: CSEIndex] RETURNS [nType: CSEIndex] = {    RETURN [WITH t: h.seb[type] SELECT FROM      subrange => NormalType[h, UnderType[h, t.rangeType]],      long, real => NormalType[h, UnderType[h, t.rangeType]],      ENDCASE => type]};  RecordLink: PROC [h: Handle, type: RecordSEIndex] RETURNS [RecordSEIndex] = {    RETURN [WITH t: h.seb[type] SELECT FROM      linked => LOOPHOLE[UnderType[h, t.linkType], RecordSEIndex],      ENDCASE => RecordSENull]};  RecordRoot: PROC [h: Handle, type: RecordSEIndex] RETURNS [root: RecordSEIndex] = {    next: RecordSEIndex;    root ¬ type;    WHILE (next ¬ RecordLink[h, root]) # SENull DO root ¬ next ENDLOOP;    RETURN};  ReferentType: PROC [h: Handle, type: CSEIndex] RETURNS [CSEIndex] = {    sei: CSEIndex = NormalType[h, type];    RETURN [WITH t: h.seb[sei] SELECT FROM      ref => UnderType[h, t.refType],      ENDCASE => typeANY]};  TransferTypes: PROC [h: Handle, type: SEIndex] RETURNS [typeIn, typeOut: RecordSEIndex] = {    sei: CSEIndex = UnderType[h, type];    WITH t: h.seb[sei] SELECT FROM      transfer =>        RETURN [typeIn: ArgRecord[h, t.typeIn], typeOut: ArgRecord[h, t.typeOut]];      ENDCASE;    RETURN [RecordSENull, RecordSENull]};  TypeForm: PROC [h: Handle, type: SEIndex] RETURNS [TypeClass] = {    RETURN [IF type = SENull THEN nil ELSE h.seb[UnderType[h, type]].typeTag]};  TypeLink: PROC [h: Handle, type: SEIndex] RETURNS [SEIndex] = {    sei: CSEIndex = UnderType[h, type];    RETURN [WITH se: h.seb[sei] SELECT FROM      record => WITH se SELECT FROM linked => linkType, ENDCASE => SENull,      ENDCASE => SENull]};  TypeRoot: PROC [h: Handle, type: SEIndex] RETURNS [root: SEIndex] = {    next: SEIndex;    root ¬ type;    WHILE (next ¬ TypeLink[h, root]) # SENull DO root ¬ next ENDLOOP;    RETURN};  UnderType: PROC [h: Handle, type: SEIndex] RETURNS [CSEIndex] = {    sei: SEIndex ¬ type;    WHILE sei # SENull DO      WITH se: h.seb[sei] SELECT FROM	id => {IF se.idType # typeTYPE THEN ERROR; sei ¬ SymbolOps.ToSei[se.idInfo]};	ENDCASE => EXIT;      ENDLOOP;    RETURN [LOOPHOLE[sei, CSEIndex]]};  XferMode: PROC [h: Handle, type: SEIndex] RETURNS [TransferMode] = {    sei: CSEIndex = UnderType[h, type];    RETURN [WITH t: h.seb[sei] SELECT FROM transfer => t.mode, ENDCASE => none]}; -- information returning procedures  WordFill: CARDINAL = WordLength-1;  BytesPerWord: CARDINAL = WordLength/ByteLength;  BitsForType: PROC [h: Handle, type: SEIndex] RETURNS [LONG CARDINAL] = {    n: LONG CARDINAL;    sei: CSEIndex = UnderType[h, type];    RETURN [IF sei = SENull      THEN 0      ELSE	WITH t: h.seb[sei] SELECT FROM	  basic => t.length,	  enumerated => BitsForRange[Cardinality[h, sei]-1],	  record => t.length,	  array =>	    IF (n¬BitsPerElement[h, t.componentType, t.packed]*Cardinality[h, t.indexType]) >	     WordLength	      THEN ((n + (WordLength-1))/WordLength)*WordLength	      ELSE n,	  opaque => t.length,	  subrange => IF t.empty THEN 0 ELSE BitsForRange[Cardinality[h, sei]-1],	  ENDCASE => WordsForType[h, sei]*WordLength]};  BitsForRange: PROC [maxValue: LONG CARDINAL] RETURNS [nBits: CARDINAL] = {    fieldMax: CARDINAL;    nBits ¬ 1;  fieldMax ¬ 1;    WHILE nBits < WordLength AND fieldMax < maxValue DO      nBits ¬ nBits + 1;  fieldMax ¬ 2*fieldMax + 1 ENDLOOP;    RETURN};  BitsPerElement: PROC [h: Handle, type: SEIndex, packed: BOOLEAN] RETURNS [BitCount] = {    nBits: BitCount = BitsForType[h, type];    RETURN [IF packed AND nBits <= ByteLength      THEN SymbolOps.PackedSize[CARDINAL[nBits]]      ELSE (nBits+WordFill)/WordLength * WordLength]};  Cardinality: PROC [h: Handle, type: SEIndex] RETURNS [LONG CARDINAL] = {    sei: CSEIndex = UnderType[h, type];    RETURN [WITH t: h.seb[sei] SELECT FROM      enumerated => t.nValues,      subrange => IF t.empty THEN 0 ELSE t.range+1,      basic => IF t.code = codeCHAR THEN 256 ELSE 0,      relative => Cardinality[h, t.offsetType],      ENDCASE => 0]};  FindExtension: PROC [h: Handle, sei: ISEIndex] RETURNS [type: ExtensionType, tree: Tree.Link] = {    OPEN SymbolSegment;    FOR exti: ExtIndex ¬ FIRST[ExtIndex], exti + SIZE[ExtRecord] UNTIL exti = h.extLimit DO      IF h.extb[exti].sei = sei THEN         RETURN [h.extb[exti].type, h.extb[exti].tree];      ENDLOOP;    RETURN [none, Tree.Null]};  FnField: PROC [h: Handle, field: ISEIndex]     RETURNS [offset: BitAddress, size: CARDINAL] = {    word, nW: CARDINAL;    word ¬ 0;    FOR sei: ISEIndex ¬ FirstCtxSe[h, h.seb[field].idCtx], NextSe[h, sei] DO      nW ¬ CARDINAL[WordsForType[h, h.seb[sei].idType]];      IF sei = field THEN EXIT;      word ¬ word + nW;      ENDLOOP;    RETURN [offset: BitAddress[wd:word, bd:0], size: nW * WordLength]};  RecField: PROC [h: Handle, field: ISEIndex]     RETURNS [offset: BitAddress, size: CARDINAL] = {    offset ¬ SymbolOps.ToBitAddr[h.seb[field].idValue];    size ¬ SymbolOps.ToCard[h.seb[field].idInfo]};      HashForSe: PROC [h: Handle, sei: ISEIndex] RETURNS [HTIndex] = {    RETURN [IF sei = ISENull THEN HTNull ELSE h.seb[sei].hash]};  LinkMode: PROC [h: Handle, sei: ISEIndex] RETURNS [Linkage] = {    RETURN [IF h.seb[sei].idType = typeTYPE      THEN (        IF TypeForm[h, SymbolOps.ToSei[h.seb[sei].idInfo]] = opaque THEN type ELSE manifest)      ELSE	SELECT XferMode[h, h.seb[sei].idType] FROM	  proc, program =>	    IF h.seb[sei].constant	      THEN (IF h.seb[sei].extended THEN val ELSE manifest)	      ELSE val,	  signal, error => IF h.seb[sei].constant THEN manifest ELSE val,	  ENDCASE => IF h.seb[sei].constant THEN manifest ELSE ref]};  RCType: PROC [h: Handle, type: CSEIndex] RETURNS [RefClass] = {    next: SEIndex;    struc: RefClass ¬ simple;    FOR sei: CSEIndex ¬ type, UnderType[h, next] DO      WITH t: h.seb[sei] SELECT FROM	record =>	  SELECT TRUE FROM	    ~t.hints.refField => RETURN [none];	    t.hints.unifield => next ¬ h.seb[h.ctxb[t.fieldCtx].seList].idType;	    ENDCASE => RETURN [composite];	ref => RETURN [IF t.counted THEN struc ELSE none];	array => {struc ¬ composite; next ¬ t.componentType};	relative => next ¬ t.offsetType;	subrange => next ¬ t.rangeType;	long => next ¬ t.rangeType;	union => RETURN [IF t.hints.refField THEN composite ELSE none];	sequence => {struc ¬ composite; next ¬ t.componentType};	zone => RETURN [IF t.counted THEN struc ELSE none];	ENDCASE => RETURN [none];      ENDLOOP};  VariantField: PROC [h: Handle, type: CSEIndex] RETURNS [sei: ISEIndex] = {    WITH t: h.seb[type] SELECT FROM      record => {        root: ISEIndex = FirstCtxSe[h, t.fieldCtx];	sei ¬ root;	WHILE sei # ISENull DO	  SELECT TypeForm[h, h.seb[sei].idType] FROM	    sequence, union => RETURN;	    ENDCASE;	  sei ¬ NextSe[h, sei];	  IF sei = root THEN RETURN [ISENull];	  ENDLOOP};      ENDCASE => RETURN[ISENull]};  WordsForType: PROC [h: Handle, type: SEIndex] RETURNS [WordCount] = {    sei: CSEIndex = UnderType[h, type];    b: WordCount;    RETURN [IF sei = SENull      THEN 0      ELSE	WITH t: h.seb[sei] SELECT FROM	  mode => 1,	-- fudge for compiler (Pass4:Binding)	  basic => (t.length + WordFill)/WordLength,	  enumerated => 1,	  record => (t.length + WordFill)/WordLength,	  ref => 1,	  array =>	    IF 	     (b¬BitsPerElement[h, t.componentType, t.packed]) <	     WordLength	      THEN (Cardinality[h, t.indexType]+(WordLength/b-1))/(WordLength/b)	      ELSE Cardinality[h, t.indexType] * ((b+WordFill)/WordLength),	  arraydesc => 2,	  transfer => (SELECT t.mode FROM	    proc, signal, error, program => 2,	    port => 4,	    process => 1,	    ENDCASE => ERROR),	  relative => WordsForType[h, t.offsetType],	  opaque => (t.length + WordFill)/WordLength,	  zone => (IF t.mds THEN 1 ELSE 2),	  subrange => IF t.empty THEN 0 ELSE 1,	  long => WordsForType[h, t.rangeType] + 1,	  real => 2,	  ENDCASE => 0]}; -- body table management  ParentBti: PROC [h: Handle, bti: BTIndex] RETURNS [BTIndex] = {    UNTIL h.bb[bti].link.which = parent DO bti ¬ h.bb[bti].link.index ENDLOOP;    RETURN [h.bb[bti].link.index]};  SiblingBti: PROC [h: Handle, bti: BTIndex] RETURNS [BTIndex] = {    RETURN [IF h.bb[bti].link.which = sibling THEN h.bb[bti].link.index ELSE BTNull]};  SonBti: PROC [h: Handle, bti: BTIndex] RETURNS [BTIndex] = {RETURN [h.bb[bti].firstSon]};  EnumerateBodies: PROC [h: Handle, root: BTIndex, proc: PROC [Handle, BTIndex] RETURNS [stop: BOOLEAN]]      RETURNS [bti: BTIndex] = {    prev: BTIndex;    bti ¬ root;    UNTIL bti = BTNull DO      IF proc[h, bti] THEN GO TO Stopped;      IF h.bb[bti].firstSon # BTNull	THEN bti ¬ h.bb[bti].firstSon	ELSE	  DO	    IF bti = root THEN GO TO Done;	    prev ¬ bti;  bti ¬ h.bb[bti].link.index;	    IF h.bb[prev].link.which # parent THEN EXIT;	    ENDLOOP;      REPEAT	Stopped => NULL;	Done => bti ¬ BTNull;      ENDLOOP;    RETURN};  }.
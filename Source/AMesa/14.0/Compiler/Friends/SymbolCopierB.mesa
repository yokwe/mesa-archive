-- Copyright (C) 1984, 1985, 1986  by Xerox Corporation. All rights reserved. -- file SymbolCopierB.mesa-- last modified by Wagner, 16-Aug-86 12:22:54DIRECTORY  Alloc USING [Words],  Copier USING [NullSEToken, SEToken],  CopierPrivateDefs,  LiteralOps USING [CopyLiteral],  Symbols,  SymbolOps,  SymbolTable USING [Handle],  Tree USING [Base, Index, Link, Null, NullIndex],  TreeOps USING [    CopyTree, DecodeBti, DecodeCSei, DecodeSei, EncodeBti, EncodeCard,     EncodeSei, FreeTree, GetNode, Map, OpName, PopTree, PushNode, PushTree,     Scan, ScanList, SetAttr, SetInfo];SymbolCopierB: PROGRAM  IMPORTS    Alloc, CopierPrivateDefs, LiteralOps, SymbolOps, TreeOps  EXPORTS Copier, CopierPrivateDefs  SHARES Copier =  {  OPEN Copier, CopierPrivateDefs, SymbolOps, Symbols;  SEToken: TYPE = Copier.SEToken;  NullSEToken: SEToken = Copier.NullSEToken;  Handle: TYPE = SymbolTable.Handle;  CopyingInline: PUBLIC SIGNAL = CODE;  CopyExtension: PUBLIC PROC [h: Handle, sei, iSei: ISEIndex, mdi: MDIndex] = {    iType: ExtensionType;    iTree: Tree.Link;    saveCurrentBody: BTIndex = h.currentBody;    h.currentBody ¬ BTNull;    [iType, iTree] ¬ SymbolOps.FindExtension[h.iHandle, iSei];    IF iType = form THEN SIGNAL CopyingInline[];    WITH iTree SELECT FROM      subtree =>        IF h.iHandle.tb[index].name = body THEN h.currentBody ¬ ToBti[h.seb[sei].idInfo];      ENDCASE;    EnterExtension[h, sei, iType, InputExtension[h, iTree, mdi]];    h.currentBody ¬ saveCurrentBody};  InputExtension: PROC [h: CopierPrivateDefs.Handle, t: Tree.Link, mdi: MDIndex] RETURNS [Tree.Link] = {    InputTree: TreeOps.Map = {      hdle: Handle = LOOPHOLE[h];      WITH link: t SELECT FROM        hash => v ¬ [hash[index: MapHti[h, link.index]]];        symbol =>          v ¬ [symbol[index: LOOPHOLE[CopyIncludedSymbol[h, link.index, mdi]]]];        literal => v ¬ InputLiteral[h, link];        subtree => {          iNode: Tree.Index = link.index;          v ¬            SELECT h.iHandle.tb[iNode].name FROM              block, ditem => InputBlock[h, iNode],              catch => InputCatch[h, iNode],              IN [forseq..downthru] => InputBlock[h, iNode],              openx => TreeOps.CopyTree[h,                [baseP: @h.iHandle.tb, link: h.iHandle.tb[iNode].son[1]], InputTree],              ENDCASE => TreeOps.CopyTree[h,                [baseP: @h.iHandle.tb, link: link], InputTree];          WITH v SELECT FROM            subtree => {              node: Tree.Index = index;              SELECT hdle.tb[node].name FROM                body => hdle.tb[node].info ¬ TreeOps.EncodeBti[h.currentBody];                block, ditem => ExitBlock[h, node];                IN [basicTC..discrimTC], cdot, IN [apply..typecode], exlist => {                  hdle.tb[node].info ¬ TreeOps.EncodeSei[		    CopyIncludedSymbol[h, TreeOps.DecodeSei[h.iHandle.tb[iNode].info], mdi]];                  SELECT hdle.tb[node].name FROM                    construct, exlist => 		      CompleteRecord[h, TreeOps.DecodeCSei[hdle.tb[node].info], mdi, TRUE];                    dollar => UpdateDollar[h, node];                    union =>                      WITH hdle.tb[node].son[1] SELECT FROM                        symbol => CompleteRecord[h, SymbolOps.UnderType[h, index], mdi, FALSE];                        ENDCASE => ERROR;                    apply => FillUnion[h, 		      SymbolOps.UnderType[h, TreeOps.DecodeSei[hdle.tb[node].info]], mdi];                    bindx => FillBinding[h, node, mdi];                    ENDCASE};                IN [forseq..downthru] => NULL;		safen => {		  v ¬ hdle.tb[node].son[1]; -- pass 4 will put in safens		  hdle.tb[node].son[1] ¬ Tree.Null;		  [] ¬ TreeOps.FreeTree[h, v]};                do => {                  IF TreeOps.OpName[h, hdle.tb[node].son[1]] IN [forseq..downthru] THEN                    ExitBlock[h, TreeOps.GetNode[h, hdle.tb[node].son[1]]];                  hdle.tb[node].info ¬ TreeOps.EncodeCard[LAST[CARDINAL]]};                bind => FillBinding[h, node, mdi];                catch => {                  TreeOps.ScanList[h, hdle.tb[node].son[1], UpdateType];		  ExitBlock[h, node]};                IN [assign..join], decl, typedecl =>                  hdle.tb[node].info ¬ TreeOps.EncodeCard[LAST[CARDINAL]];                ENDCASE => NULL};            ENDCASE => NULL};        ENDCASE => ERROR;      RETURN};    UpdateDollar: PROC [h: Handle, node: Tree.Index] = INLINE {      WITH h.tb[node].son[1] SELECT FROM        subtree => {          sei: CSEIndex = TreeOps.DecodeCSei[h.tb[index].info];          WITH type: h.seb[sei] SELECT FROM            record =>              IF type.argument THEN                WITH h.tb[node].son[2] SELECT FROM                  symbol => index ¬ SearchContext[h, h.seb[index].hash, type.fieldCtx];                  ENDCASE => ERROR;            ENDCASE};        ENDCASE};    UpdateType: TreeOps.Scan = {      hdle: Handle = LOOPHOLE[h];      WITH t SELECT FROM        subtree => hdle.tb[index].info ¬ 	  TreeOps.EncodeSei[CopyIncludedSymbol[h, TreeOps.DecodeSei[hdle.tb[index].info], mdi]];        ENDCASE};    FillBinding: PROC [h: Handle, node: Tree.Index, mdi: MDIndex] = {      WITH h.tb[node].son[1] SELECT FROM        subtree => {          subNode: Tree.Index = index;          rType: CSEIndex =            WITH h.tb[subNode].son[2] SELECT FROM              symbol => UnderType[h, h.seb[index].idType],              subtree => TreeOps.DecodeCSei[h.tb[index].info],              ENDCASE => ERROR;          CompleteRecord[h, rType, mdi, FALSE]};        ENDCASE => ERROR};    InputLiteral: PROC [h: Handle, t: literal Tree.Link] RETURNS [Tree.Link] = {      WITH t.info SELECT FROM        word => index ¬ LiteralOps.CopyLiteral[h, [baseP: @h.iHandle.ltb, index: index]];        string => NULL; -- for now all have STNull as their index	ENDCASE;      RETURN[t]};    InputBlock: PROC [h: Handle, iNode: Tree.Index] RETURNS [v: Tree.Link] = {      OPEN TreeOps;      iBti: BTIndex = TreeOps.DecodeBti[h.iHandle.tb[iNode].info];      n: CARDINAL = h.iHandle.tb[iNode].nSons;      bti: BTIndex;      IF iBti = BTNull THEN bti ¬ BTNull      ELSE {        ctx: IncludedCTXIndex = MapCtx[h, mdi, h.iHandle.bb[iBti].localCtx];        bti ¬ h.table.Words[bodyType, SIZE[Other BodyRecord]];        h.bb[bti] ¬ BodyRecord[          link:, firstSon: BTNull,          type: LOOPHOLE[CopyIncludedSymbol[h, h.iHandle.bb[iBti].type, mdi]],          localCtx: ctx, level: h.iHandle.bb[iBti].level, sourceIndex: LAST[CARDINAL],          info:, extension: Other[relOffset:]];        LinkBti[h: h, bti: bti, parent: h.currentBody];        h.currentBody ¬ bti};      FOR i: CARDINAL IN [1..n] DO        PushTree[h, InputTree[h, h.iHandle.tb[iNode].son[i]]] ENDLOOP;      PushNode[h, h.iHandle.tb[iNode].name, n];      SetAttr[h, 1, h.iHandle.tb[iNode].attr1];      SetAttr[h, 2, h.iHandle.tb[iNode].attr2];      SetAttr[h, 3, h.iHandle.tb[iNode].attr3];      SetInfo[h, TreeOps.EncodeBti[bti]];      v ¬ PopTree[h];      IF bti # BTNull THEN        h.bb[bti].info ¬ [          Internal[bodyTree: GetNode[h, v], thread: Tree.NullIndex, frameSize:]];      RETURN};    InputCatch: PROC [h: Handle, iNode: Tree.Index] RETURNS [v: Tree.Link] = {      OPEN TreeOps;      iBti: CBTIndex = TreeOps.DecodeBti[h.iHandle.tb[iNode].info];      bti: CBTIndex;      IF iBti = CBTNull THEN bti ¬ CBTNull      ELSE {        bti ¬ CopyIncludedBody[h,           iBti, LOOPHOLE[CopyIncludedSymbol[h, h.iHandle.bb[iBti].id, mdi]], mdi];        LinkBti[h: h, bti: bti, parent: h.currentBody];        h.currentBody ¬ bti};      PushTree[h, InputTree[h, h.iHandle.tb[iNode].son[1]]];      PushTree[h, InputTree[h, h.iHandle.tb[iNode].son[2]]];      PushNode[h, catch, 2];      SetInfo[h, TreeOps.EncodeBti[bti]];      v ¬ PopTree[h];      IF bti # BTNull THEN        h.bb[bti].info ¬ [          Internal[bodyTree: GetNode[h, v], thread: Tree.NullIndex, frameSize:]];      RETURN};           ExitBlock: PROC [h: Handle, node: Tree.Index] = INLINE {      IF h.tb[node].info # TreeOps.EncodeBti[BTNull] THEN         h.currentBody ¬ ParentBti[h, TreeOps.DecodeBti[h.tb[node].info]]};    RETURN[InputTree[h, t]]};}..
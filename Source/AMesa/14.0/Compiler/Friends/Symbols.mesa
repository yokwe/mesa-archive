-- Copyright (C) 1982, 1984, 1985, 1986  by Xerox Corporation. All rights reserved. -- file Symbols.Mesa--   Satterthwaite,	 9-Feb-82  9:57:07--   Sweet,		26-Mar-84 16:01:08--   Wagner		16-Aug-86  9:53:01DIRECTORY  PrincOps USING [MaxFrameSize],  Table USING [Base, Selector, Limit],  TimeStamp USING [Stamp];Symbols: DEFINITIONS = {  ByteLength: CARDINAL = 8;  WordLength: CARDINAL = 16;  Base: TYPE = Table.Base;  Limit: CARDINAL = Table.Limit;     -- hash table declarations  HVLength: PRIVATE CARDINAL = 71;  HVIndex: TYPE = CARDINAL [0..HVLength);    HTRecord: TYPE = RECORD [    anyInternal, anyPublic: BOOLEAN,    link: HTIndex,    ssIndex: CARDINAL];  HTIndex: TYPE = CARDINAL [0..Limit/2);  HTNull: HTIndex = FIRST[HTIndex];  HashVector: TYPE = ARRAY HVIndex OF HTIndex; -- semantic entry table declarations  TypeClass: TYPE = {    mode,    basic,    enumerated,    record,    ref,    array,    arraydesc,    transfer,    definition,    union,    sequence,    relative,    subrange,    long,    real,    opaque,    zone,    any,    nil,    bits,    fixedSequence};  TransferMode: TYPE = {proc, port, signal, error, process, program, none};    Unspec: TYPE [SIZE[CARDINAL]];  SERecord: TYPE = RECORD [    mark3, mark4: BOOLEAN,    body: SELECT seTag: * FROM      id => [	extended: BOOLEAN,	public: BOOLEAN,	idCtx: CTXIndex,	immutable, constant: BOOLEAN,	idType: SEIndex,	idInfo: Unspec,	idValue: Unspec,	hash: HTIndex,	linkSpace: BOOLEAN,	ctxLink: SELECT linkTag: * FROM	  terminal => [],	  sequential => [],	  linked => [link: ISEIndex]	  ENDCASE],      cons => [	typeInfo: SELECT typeTag: TypeClass FROM	  mode => [],	  basic => [	    ordered: BOOLEAN,	    code: [0..16),	    length: BitLength],	  enumerated => [	    ordered, machineDep: BOOLEAN,	    unpainted: BOOLEAN,		-- un- for backward compatiblity	    sparse: BOOLEAN,	    valueCtx: CTXIndex,	    nValues: CARDINAL],	  record => [	    hints: RECORD [	      comparable, assignable: BOOLEAN,	      unifield, variant, privateFields: BOOLEAN,	      refField, default, voidable: BOOLEAN],	    length: BitLength,	    argument, monitored, machineDep: BOOLEAN,	    painted: BOOLEAN,	    fieldCtx: CTXIndex,	    linkPart: SELECT linkTag: * FROM	      notLinked => [],	      linked => [linkType: SEIndex]	      ENDCASE],	  ref => [	    counted, ordered, readOnly, list, var, basing: BOOLEAN,	    refType: SEIndex],	  array => [	    packed: BOOLEAN,	    indexType: SEIndex,	    componentType: SEIndex],	  arraydesc => [	    var, readOnly: BOOLEAN,	    describedType: SEIndex],	  transfer => [	    safe: BOOLEAN,	    mode: TransferMode,	    typeIn, typeOut: CSEIndex],	  definition => [	    named: BOOLEAN,	    defCtx: CTXIndex],	  union => [	    hints: RECORD [	      equalLengths: BOOLEAN,	      refField, default, voidable: BOOLEAN],	    overlaid, controlled, machineDep: BOOLEAN,	    caseCtx: CTXIndex,	    tagSei: ISEIndex],	  sequence => [	    packed: BOOLEAN,	    controlled, machineDep: BOOLEAN,	    tagSei: ISEIndex,	    componentType: SEIndex],	  relative => [	    baseType: SEIndex,	    offsetType: SEIndex,	    resultType: SEIndex],	  subrange => [	    filled, empty: BOOLEAN,	    rangeType: SEIndex,	    origin: INTEGER,	    range: CARDINAL],	  long, real => [rangeType: SEIndex],	  opaque => [	    lengthKnown: BOOLEAN,	    length: BitLength,	    id: ISEIndex],	  zone => [counted, mds: BOOLEAN],	  any => [],	  nil => [],	  bits => [length: BitCount],	-- placed here to avoid	  ENDCASE],			-- changing symbol version id's      ENDCASE];  SEIndex: TYPE = Base RELATIVE POINTER [0..Limit) TO SERecord;  ISEIndex: TYPE = Base RELATIVE POINTER [0..Limit) TO id SERecord;  CSEIndex: TYPE = Base RELATIVE POINTER [0..Limit) TO cons SERecord;  RecordSEIndex: TYPE = Base RELATIVE POINTER [0..Limit) TO record cons SERecord;  RefSEIndex: TYPE = Base RELATIVE POINTER [0..Limit) TO ref cons SERecord;  ArraySEIndex: TYPE = Base RELATIVE POINTER [0..Limit) TO array cons SERecord;  SENull: SEIndex = FIRST[SEIndex];  ISENull: ISEIndex = LOOPHOLE[SENull];  CSENull: CSEIndex = LOOPHOLE[SENull];    RecordSENull: RecordSEIndex = LOOPHOLE[SENull];    RefSENull: RefSEIndex = LOOPHOLE[SENull];    ArraySENull: ArraySEIndex = LOOPHOLE[SENull]; -- the following two values are guaranteed by the compiler  typeTYPE: CSEIndex = FIRST[CSEIndex] + SIZE[nil cons SERecord];  typeANY: CSEIndex = typeTYPE + SIZE[mode cons SERecord]; -- codes identifying the basic types (extensible)  codeANY: CARDINAL = 0;  codeINT: CARDINAL = 1;  codeCHAR: CARDINAL = 2;  WordCount: TYPE = LONG CARDINAL;	-- sizes in words  BitLength: TYPE = CARDINAL;  BitCount: TYPE = LONG CARDINAL;		-- sizes in bits  FieldBitCount: TYPE = CARDINAL;  PackedBitCount: TYPE = [1..ByteLength];    BitAddress: TYPE = RECORD[    wd: [0..LAST[CARDINAL]/WordLength],	-- word displacement    bd: [0..WordLength)];   			-- bit displacement    ExtensionType: TYPE = {value, form, default, none};  Linkage: TYPE = {val, ref, type, manifest, none};	-- for import/export  RefClass: TYPE = {none, simple, composite}; -- context table declarations  ContextLevel: TYPE = [0..7];    lZ: ContextLevel = 0;	-- context level of non-frame records    lG: ContextLevel = 1;	-- context level of global frame    lL: ContextLevel = lG+1;	-- context level of outer procedures  Closure: TYPE = {none, unit, rc, full};  -- completeness of copied contexts    CTXRecord: TYPE = RECORD [    mark, varUpdated: BOOLEAN,    seList: ISEIndex,    level: ContextLevel,    extension: SELECT ctxType: * FROM      simple => [ctxNew: CTXIndex],	-- for DeSoto      included => [	chain: IncludedCTXIndex,	copied: Closure ¬ none,	module: MDIndex,	map: CTXIndex,	closed, complete, restricted: BOOLEAN,	reset: BOOLEAN],      imported => [includeLink: IncludedCTXIndex],      nil => []      ENDCASE];  CTXIndex: TYPE = Base RELATIVE ORDERED POINTER [0..3777B] TO CTXRecord;   IncludedCTXIndex: TYPE = Base RELATIVE ORDERED POINTER [0..3777B] TO included CTXRecord;  CTXNull: CTXIndex = FIRST[CTXIndex];    IncludedCTXNull: IncludedCTXIndex = LOOPHOLE[CTXNull];  StandardContext: TYPE = CTXIndex[CTXNull+SIZE[simple CTXRecord]..CTXNull+6*SIZE[simple CTXRecord]]; -- module table declarations  FileIndex: TYPE = [0..77777B];	-- internal file handle  NullFileIndex: FileIndex = LAST[FileIndex];  MDRecord: TYPE = RECORD [    stamp: TimeStamp.Stamp,    moduleId: HTIndex,		-- hash entry for module name    fileId: HTIndex,		-- hash entry for file name    shared: BOOLEAN,		-- overrides PRIVATE, etc.    exported: BOOLEAN,    ctx: IncludedCTXIndex,	-- context of copied entries    defaultImport: CTXIndex,	-- unnamed imported instance    file: FileIndex];		-- associated file  MDIndex: TYPE = Base RELATIVE ORDERED POINTER [0..Limit) TO MDRecord;  MDNull: MDIndex = LAST[MDIndex];  OwnMdi: MDIndex = FIRST[MDIndex]; -- body table declarations  BodyLink: TYPE = RECORD [which: {sibling, parent}, index: BTIndex];  CatchIndex: TYPE = NATURAL;  BodyRecord: TYPE = RECORD [    link: BodyLink,    firstSon: BTIndex,    type: RecordSEIndex,    localCtx: CTXIndex,    level: ContextLevel,    sourceIndex: CARDINAL,    info: BodyInfo,    extension: SELECT kind: * FROM      Callable => [	inline: BOOLEAN,	id: ISEIndex,	ioType: CSEIndex,	monitored, noXfers, resident: BOOLEAN,	entry, internal: BOOLEAN,	entryIndex: [0..256),	hints: RECORD [safe, argUpdated, nameSafe, needsFixup: BOOLEAN],	closure: SELECT nesting: * FROM	  Outer => [],	  Inner => [frameOffset: [0..PrincOps.MaxFrameSize)],	  Catch => [index: CatchIndex]	  ENDCASE],      Other => [relOffset: [0..LAST[CARDINAL]/2]]      ENDCASE];    BodyInfo: TYPE = RECORD [      SELECT mark: * FROM	Internal => [	  bodyTree: Base RELATIVE POINTER [0..Limit),	    --Tree.Index-- 	  thread: Base RELATIVE POINTER [0..Limit),	    --Tree.Index / LitDefs.STIndex-- 	  frameSize: [0..PrincOps.MaxFrameSize]],	External => [	  bytes: [0..LAST[CARDINAL]/2],	  startIndex, indexLength: CARDINAL]	ENDCASE];  BTIndex: TYPE = Base RELATIVE POINTER [0..Limit) TO BodyRecord;    CBTIndex: TYPE = Base RELATIVE POINTER [0..Limit) TO Callable BodyRecord;      ICBTIndex: TYPE = Base RELATIVE POINTER [0..Limit) TO Inner Callable BodyRecord;      OCBTIndex: TYPE = Base RELATIVE POINTER [0..Limit) TO Outer Callable BodyRecord;      CCBTIndex: TYPE = Base RELATIVE POINTER [0..Limit) TO Catch Callable BodyRecord;  BTNull: BTIndex = LAST[BTIndex];    CBTNull: CBTIndex = LOOPHOLE[BTNull];    CCBTNull: CCBTIndex = LOOPHOLE[BTNull];  RootBti: CBTIndex = FIRST[CBTIndex];   -- until idValue big enough to hold a BcdDefs.Link   LinkTag: TYPE = {variable, procedure, type};  VarTag: TYPE = MACHINE DEPENDENT {var(0), proc0(1), type(2), proc1(3)};  DummyLink: TYPE = RECORD [gfi, ep: [0..377B]];       -- allocation codes for table components  seType: Table.Selector = 1;  htType: Table.Selector = 2;  ssType: Table.Selector = 3;  ctxType: Table.Selector = 4;  mdType: Table.Selector = 5;  bodyType: Table.Selector = 6;  }.
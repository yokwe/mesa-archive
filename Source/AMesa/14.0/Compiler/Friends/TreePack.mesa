-- Copyright (C) 1982, 1985, 1986  by Xerox Corporation. All rights reserved. -- file TreePack.Mesa-- last modified by Satterthwaite, May 21, 1982 1:34 pm-- Wagner	16-Aug-86 11:32:27DIRECTORY  Alloc USING [FreeChunk, GetChunk],  Literals USING [LTIndex, STIndex],  Symbols USING [HTIndex, ISEIndex],  SymbolTable USING [Handle],  Tree USING [    AttrId, Base, Finger, Index, Info, Link, LinkSeq, LinkStack, Node, NodeName,    MaxNSons, Null, NullIndex, treeType],  TreeOps USING [EncodeCard, Id, Map, Scan, Test]; TreePack: PROGRAM    IMPORTS Alloc, TreeOps     EXPORTS TreeOps    SHARES Tree = PUBLIC {    Handle: TYPE = SymbolTable.Handle;  EndIndex: Tree.Index = LAST[Tree.Index];  EndMark: Tree.Link = [subtree[index: EndIndex]];  LinkSeq: PRIVATE TYPE = Tree.LinkSeq;  LinkStack: PRIVATE TYPE = Tree.LinkStack;  TreeInitialize: PROC [h: Handle] = {    IF h.treeStack # NIL THEN TreeFinalize[h];    h.treeStack ¬ h.zone.NEW[LinkSeq[250]];  h.stackIndex ¬ 0;    IF MakeNode[h, none,0] # Tree.Null THEN ERROR;	-- reserve null   };  TreeReset: PROC [h: Handle] = {    IF h.treeStack # NIL AND h.treeStack.length > 250 THEN {      h.zone.FREE[@h.treeStack]; h.treeStack ¬ h.zone.NEW[LinkSeq[250]]}};  TreeFinalize: PROC [h: Handle] = {    h.zone.FREE[@h.treeStack]};  ExpandStack: PRIVATE PROC [h: Handle] = {    newStack: LinkStack = h.zone.NEW[LinkSeq[h.treeStack.length + 256]];    FOR i: CARDINAL IN [0 .. h.treeStack.length) DO newStack[i] ¬ h.treeStack[i] ENDLOOP;    h.zone.FREE[@h.treeStack];  h.treeStack ¬ newStack};  PushTree: PROC [h: Handle, v: Tree.Link] = {    IF h.stackIndex >= h.treeStack.length THEN ExpandStack[h];    h.treeStack[h.stackIndex] ¬ v;  h.stackIndex ¬ h.stackIndex+1};  PopTree: PROC [h: Handle] RETURNS [Tree.Link] = {RETURN [h.treeStack[h.stackIndex¬h.stackIndex-1]]};  InsertTree: PROC [h: Handle, v: Tree.Link, n: CARDINAL] = {    i: CARDINAL;    IF h.stackIndex >= h.treeStack.length THEN ExpandStack[h];    i ¬ h.stackIndex;  h.stackIndex ¬ h.stackIndex+1;    THROUGH [1 .. n) DO h.treeStack[i] ¬ h.treeStack[i-1]; i ¬ i-1 ENDLOOP;    h.treeStack[i] ¬ v};  ExtractTree: PROC [h: Handle, n: CARDINAL] RETURNS [v: Tree.Link] = {    i: CARDINAL;    i ¬ h.stackIndex - n;  v ¬ h.treeStack[i];    THROUGH [1 .. n) DO h.treeStack[i] ¬ h.treeStack[i+1]; i ¬ i+1 ENDLOOP;    h.stackIndex ¬ h.stackIndex - 1;    RETURN [v]};  MakeNode: PROC [h: Handle, name: Tree.NodeName, count: INTEGER] RETURNS [Tree.Link] = {    PushNode[h, name, count];  RETURN [PopTree[h]]};  MakeList: PROC [h: Handle, size: INTEGER] RETURNS [Tree.Link] = {    PushList[h, size];  RETURN [PopTree[h]]};  PushNode: PROC [h: Handle, name: Tree.NodeName, count: INTEGER] = {    nSons: CARDINAL = ABS[count];    node: Tree.Index = h.table.GetChunk[SIZE[Tree.Node]+nSons, Tree.treeType];    i: CARDINAL;    h.tb[node].name ¬ name;  h.tb[node].nSons ¬ nSons;    h.tb[node].info ¬ TreeOps.EncodeCard[0];  h.tb[node].shared ¬ FALSE;    h.tb[node].attr1 ¬ h.tb[node].attr2 ¬ h.tb[node].attr3 ¬ FALSE;    IF count >= 0 THEN      FOR i ¬ nSons, i-1 WHILE i >= 1 DO h.tb[node].son[i] ¬ h.treeStack[h.stackIndex¬h.stackIndex-1] ENDLOOP    ELSE      FOR i ¬ 1, i+1 WHILE i <= nSons DO h.tb[node].son[i] ¬ h.treeStack[h.stackIndex¬h.stackIndex-1] ENDLOOP;    IF h.stackIndex >= h.treeStack.length THEN ExpandStack[h];    h.treeStack[h.stackIndex] ¬ [subtree[index: node]];  h.stackIndex ¬ h.stackIndex+1};  PushList: PROC [h: Handle, size: INTEGER] = {    nSons: CARDINAL = ABS[size];    node: Tree.Index;    i: CARDINAL;    SELECT nSons FROM      1 => NULL;      0 => PushTree[h, Tree.Null];      ENDCASE => {	IF nSons IN (0..Tree.MaxNSons] THEN	  node ¬ h.table.GetChunk[SIZE[Tree.Node]+nSons, Tree.treeType]	ELSE {	  node ¬ h.table.GetChunk[SIZE[Tree.Node]+(nSons+1), Tree.treeType];	  h.tb[node].son[nSons+1] ¬ EndMark};	h.tb[node].name ¬ list;	h.tb[node].info ¬ TreeOps.EncodeCard[0];  h.tb[node].shared ¬ FALSE;	h.tb[node].attr1 ¬ h.tb[node].attr2 ¬ h.tb[node].attr3 ¬ FALSE;	h.tb[node].nSons ¬ IF nSons IN (0..Tree.MaxNSons] THEN nSons ELSE 0;	IF size > 0 THEN	  FOR i ¬ nSons, i-1 WHILE i >= 1 DO h.tb[node].son[i] ¬ h.treeStack[h.stackIndex¬h.stackIndex-1] ENDLOOP	ELSE	  FOR i ¬ 1, i+1 WHILE i <= nSons DO h.tb[node].son[i] ¬ h.treeStack[h.stackIndex¬h.stackIndex-1] ENDLOOP;	IF h.stackIndex >= h.treeStack.length THEN ExpandStack[h];	h.treeStack[h.stackIndex] ¬ [subtree[index: node]];  h.stackIndex ¬ h.stackIndex+1}};  PushProperList: PROC [h: Handle, size: INTEGER] = {    IF size IN [-1..1] THEN {      node: Tree.Index = h.table.GetChunk[SIZE[Tree.Node] + 1, Tree.treeType];      h.tb[node].name ¬ list;      h.tb[node].info ¬ TreeOps.EncodeCard[0];  h.tb[node].shared ¬ FALSE;      h.tb[node].attr1 ¬ h.tb[node].attr2 ¬ h.tb[node].attr3 ¬ FALSE;      h.tb[node].nSons ¬ ABS[size];      h.tb[node].son[1] ¬ IF size = 0 THEN EndMark ELSE PopTree[h];      PushTree[h, [subtree[index: node]]]}    ELSE PushList[h, size]};  PushHash: PROC [h: Handle, hti: Symbols.HTIndex] = {PushTree[h, [hash[index: hti]]]};  PushSe: PROC [h: Handle, sei: Symbols.ISEIndex] = {PushTree[h, [symbol[index: sei]]]};  PushLit: PROC [h: Handle, lti: Literals.LTIndex] = {PushTree[h, [literal[info: [word[lti]]]]]};  PushStringLit: PROC [h: Handle, sti: Literals.STIndex] = {PushTree[h, [literal[info: [string[sti]]]]]};  SetInfo: PROC [h: Handle, info: Tree.Info] = {    v: Tree.Link = h.treeStack[h.stackIndex-1];    IF v # Tree.Null THEN      WITH v SELECT FROM subtree => h.tb[index].info ¬ info ENDCASE};  SetAttr: PROC [h: Handle, attr: Tree.AttrId, value: BOOLEAN] = {    v: Tree.Link = h.treeStack[h.stackIndex-1];    IF v = Tree.Null THEN ERROR    ELSE      WITH v SELECT FROM	subtree => {	  node: Tree.Index = index;	  SELECT attr FROM	    1 => h.tb[node].attr1 ¬ value;	    2 => h.tb[node].attr2 ¬ value;	    3 => h.tb[node].attr3 ¬ value;	    ENDCASE};	ENDCASE => ERROR};  FreeNode: PROC [h: Handle, node: Tree.Index] = {    IF node # Tree.NullIndex AND ~h.tb[node].shared THEN {      i, n: CARDINAL;      t: Tree.Link;      n ¬ h.tb[node].nSons;      IF h.tb[node].name # list OR n # 0 THEN	FOR i ¬ 1, i+1 WHILE i <= n DO	  t ¬ h.tb[node].son[i];	  WITH t SELECT FROM subtree => FreeNode[h, index] ENDCASE;	  ENDLOOP      ELSE {	n ¬ 1;	FOR i ¬ 1, i+1 UNTIL (t¬h.tb[node].son[i]) = EndMark DO	  WITH t SELECT FROM subtree => FreeNode[h, index] ENDCASE;	  n ¬ n+1;	  ENDLOOP};      h.table.FreeChunk[node, SIZE[Tree.Node]+n, Tree.treeType]}};  FreeTree: PROC [h: Handle, t: Tree.Link] RETURNS [Tree.Link] = {    WITH t SELECT FROM  subtree => FreeNode[h, index];  ENDCASE;    RETURN [Tree.Null]};  -- procedures for tree testing  GetHash: PROC [h: Handle, t: Tree.Link] RETURNS [Symbols.HTIndex] = {    RETURN [WITH t SELECT FROM hash => index, ENDCASE => ERROR]};  GetNode: PROC [h: Handle, t: Tree.Link] RETURNS [Tree.Index] = {    RETURN [WITH t SELECT FROM subtree => index, ENDCASE => ERROR]};  GetSe: PROC [h: Handle, t: Tree.Link] RETURNS [Symbols.ISEIndex] = {    RETURN [WITH t SELECT FROM symbol => index, ENDCASE => ERROR]};  NthSon: PROC [h: Handle, t: Tree.Link, n: CARDINAL] RETURNS [Tree.Link] = {    RETURN [IF t = Tree.Null      THEN ERROR      ELSE WITH t SELECT FROM subtree => h.tb[index].son[n], ENDCASE => ERROR]};  OpName: PROC [h: Handle, t: Tree.Link] RETURNS [Tree.NodeName] = {    RETURN [IF t = Tree.Null      THEN none      ELSE WITH t SELECT FROM subtree => h.tb[index].name, ENDCASE => none]};  Shared: PROC [h: Handle, t: Tree.Link] RETURNS [BOOLEAN] = {    RETURN [WITH t SELECT FROM      subtree => IF index = Tree.NullIndex THEN FALSE ELSE h.tb[index].shared,      ENDCASE => FALSE]};  SetShared: PROC [h: Handle, t: Tree.Link, shared: BOOLEAN] = {    WITH t SELECT FROM      subtree => IF index # Tree.NullIndex THEN h.tb[index].shared ¬ shared;      ENDCASE};  SonCount: PRIVATE PROC [h: Handle, node: Tree.Index] RETURNS [CARDINAL] = INLINE {    RETURN [SELECT node FROM      Tree.NullIndex, EndIndex => 0,      ENDCASE => IF h.tb[node].name = list AND h.tb[node].nSons = 0	THEN ListLength[h, [subtree[index: node]]]	ELSE h.tb[node].nSons]};  -- procedures for tree traversal  ScanSons: PROC [h: Handle, root: Tree.Link, action: TreeOps.Scan] = {    IF root # Tree.Null THEN      WITH root SELECT FROM	subtree => {	  node: Tree.Index = index;	  FOR i: CARDINAL IN [1 .. SonCount[h, node]] DO	    action[h, h.tb[node].son[i]] ENDLOOP};	ENDCASE;    RETURN};  UpdateLeaves: PROC [h: Handle, root: Tree.Link, map: TreeOps.Map] RETURNS [v: Tree.Link] = {    IF root = Tree.Null THEN v ¬ Tree.Null    ELSE      WITH root SELECT FROM	subtree => {	  node: Tree.Index = index;	  FOR i: CARDINAL IN [1 .. SonCount[h, node]] DO	    h.tb[node].son[i] ¬ map[h, h.tb[node].son[i]];	    ENDLOOP;	  v ¬ root};	ENDCASE => v ¬ map[h, root];    RETURN};  -- procedures for list testing  ListLength: PROC [h: Handle, t: Tree.Link] RETURNS [CARDINAL] = {    IF t = Tree.Null THEN RETURN [0];    WITH t SELECT FROM      subtree => {	node: Tree.Index = index;	n: CARDINAL;	IF h.tb[node].name # list THEN RETURN [1];	n ¬ h.tb[node].nSons;	IF n # 0 THEN RETURN [n];	FOR i: CARDINAL ¬ 1, i+1 UNTIL h.tb[node].son[i] = EndMark DO n ¬ n+1 ENDLOOP;	RETURN [n]};      ENDCASE => RETURN [1]};  ListHead: PROC [h: Handle, t: Tree.Link] RETURNS [Tree.Link] = {    IF t = Tree.Null THEN RETURN [Tree.Null];    WITH t SELECT FROM      subtree => {	node: Tree.Index = index;	RETURN [SELECT TRUE FROM	  (h.tb[node].name # list) => t,	  (h.tb[node].son[1] # EndMark) => h.tb[node].son[1],	  ENDCASE => Tree.Null]};      ENDCASE => RETURN [t]};  ListTail: PROC [h: Handle, t: Tree.Link] RETURNS [Tree.Link] = {    IF t = Tree.Null THEN RETURN [Tree.Null];    WITH t SELECT FROM      subtree => {	node: Tree.Index = index;	RETURN [SELECT TRUE FROM	  (h.tb[node].name # list) => t,	  (h.tb[node].son[1] # EndMark) => h.tb[node].son[ListLength[h, t]],	  ENDCASE => Tree.Null]};      ENDCASE => RETURN [t]};  -- procedures for list traversal  ScanList: PROC [h: Handle, root: Tree.Link, action: TreeOps.Scan] = {    IF root # Tree.Null THEN      WITH root SELECT FROM	subtree => {	  node: Tree.Index = index;	  i, n: CARDINAL;	  t: Tree.Link;	  IF h.tb[node].name # list THEN action[h, root]	  ELSE IF (n ¬ h.tb[node].nSons) # 0 THEN	    FOR i ¬ 1, i+1 WHILE i <= n DO action[h, h.tb[node].son[i]] ENDLOOP	  ELSE	    FOR i ¬ 1, i+1 UNTIL (t¬h.tb[node].son[i]) = EndMark DO action[h, t] ENDLOOP};	ENDCASE => action[h, root]};  ReverseScanList: PROC [h: Handle, root: Tree.Link, action: TreeOps.Scan] = {    IF root # Tree.Null THEN      WITH root SELECT FROM	subtree => {	  node: Tree.Index = index;	  IF h.tb[node].name # list THEN action[h, root]	  ELSE	    FOR i: CARDINAL DECREASING IN [1 .. ListLength[h, root]] DO	      action[h, h.tb[node].son[i]] ENDLOOP};	ENDCASE => action[h, root]};  SearchList: PROC [h: Handle, root: Tree.Link, test: TreeOps.Test] = {    IF root # Tree.Null THEN      WITH root SELECT FROM	subtree => {	  node: Tree.Index = index;	  i, n: CARDINAL;	  t: Tree.Link;	  IF h.tb[node].name # list THEN [] ¬ test[h, root]	  ELSE IF (n ¬ h.tb[node].nSons) # 0 THEN	    FOR i ¬ 1, i+1 WHILE i <= n DO IF test[h, h.tb[node].son[i]] THEN EXIT ENDLOOP	  ELSE	    FOR i ¬ 1, i+1 UNTIL (t¬h.tb[node].son[i]) = EndMark DO IF test[h, t] THEN EXIT ENDLOOP};	ENDCASE => [] ¬ test[h, root]};  UpdateList: PROC [h: Handle, root: Tree.Link, map: TreeOps.Map] RETURNS [Tree.Link] = {    IF root = Tree.Null THEN RETURN [Tree.Null];    WITH root SELECT FROM      subtree => {	node: Tree.Index = index;	i, n: CARDINAL;	t: Tree.Link;	IF h.tb[node].name # list THEN RETURN [map[h, root]];	IF (n ¬ h.tb[node].nSons) # 0 THEN	  FOR i ¬ 1, i+1 WHILE i <= n DO h.tb[node].son[i] ¬ map[h, h.tb[node].son[i]] ENDLOOP	ELSE	  FOR i ¬ 1, i+1 UNTIL (t¬h.tb[node].son[i]) = EndMark DO h.tb[node].son[i] ¬ map[h, t] ENDLOOP;	RETURN [root]};      ENDCASE => RETURN [map[h, root]]};  ReverseUpdateList: PROC [h: Handle, root: Tree.Link, map: TreeOps.Map] RETURNS [Tree.Link] = {    IF root = Tree.Null THEN RETURN [Tree.Null];    WITH root SELECT FROM      subtree => {	node: Tree.Index = index;	IF h.tb[node].name # list THEN RETURN [map[h, root]];	FOR i: CARDINAL DECREASING IN [1..ListLength[h, root]] DO	  h.tb[node].son[i] ¬ map[h, h.tb[node].son[i]] ENDLOOP;	RETURN [root]};      ENDCASE => RETURN [map[h, root]]}; -- cross-table tree manipulation  CopyTree: PROC [h: Handle, root: TreeOps.Id, map: TreeOps.Map] RETURNS [v: Tree.Link] = {    WITH root.link SELECT FROM      subtree => {	sNode: Tree.Index = index;	IF sNode = Tree.NullIndex THEN v ¬ Tree.Null	ELSE {	  size: CARDINAL = NodeSize[h, root.baseP, sNode];	  dNode: Tree.Index = h.table.GetChunk[size, Tree.treeType];	  t: Tree.Link;	  h.tb[dNode].name ¬ root.baseP­[sNode].name;	  h.tb[dNode].shared ¬ FALSE;	  h.tb[dNode].nSons ¬ root.baseP­[sNode].nSons;	  h.tb[dNode].info ¬ root.baseP­[sNode].info;	  h.tb[dNode].attr1 ¬ root.baseP­[sNode].attr1;	  h.tb[dNode].attr2 ¬ root.baseP­[sNode].attr2;	  h.tb[dNode].attr3 ¬ root.baseP­[sNode].attr3;	  FOR i: CARDINAL IN [1..size-SIZE[Tree.Node]] DO	    h.tb[dNode].son[i] ¬ IF (t¬root.baseP­[sNode].son[i]) = EndMark				    THEN EndMark				    ELSE map[h, t];	    ENDLOOP;	  v ¬ [subtree[index: dNode]]}};      ENDCASE => v ¬ map[h, root.link];    RETURN};  IdentityMap: TreeOps.Map = {    RETURN [IF t.tag = subtree AND ~Shared[h, t]	THEN CopyTree[h, [baseP:@(LOOPHOLE[h, Handle].tb), link:t], IdentityMap]	ELSE t]};  NodeSize: PROC [h: Handle, baseP: Tree.Finger, node: Tree.Index] RETURNS [size: CARDINAL] = {    IF node = Tree.NullIndex THEN size ¬ 0    ELSE IF baseP­[node].name # list OR baseP­[node].nSons # 0 THEN      size ¬ SIZE[Tree.Node] + baseP­[node].nSons    ELSE {      size ¬ SIZE[Tree.Node] + 1;      FOR i: CARDINAL ¬ 1, i+1 UNTIL baseP­[node].son[i] = EndMark DO size ¬ size + 1 ENDLOOP};    RETURN};  }.
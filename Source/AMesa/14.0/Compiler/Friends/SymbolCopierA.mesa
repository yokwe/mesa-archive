-- Copyright (C) 1984, 1985, 1986  by Xerox Corporation. All rights reserved. -- file SymbolCopierA.mesa-- last modified by Satterthwaite, May 21, 1982 2:04 pm-- last modified by Sweet, 25-Jan-84 16:10:50-- last modified by Wagner, 16-Aug-86 12:00:46DIRECTORY  Alloc USING [Failure, Top, Words],  Copier USING [    FindMdEntry, FreeSymbolTable, GetSymbolTable, NullSEToken, SEToken],  CopierPrivateDefs,  Inline USING [LongDivMod, LongMult],  String USING [SubString, SubStringDescriptor],  Symbols,  SymbolOps,  SymbolTable USING [Handle, CopierSearchCache, TypeCache],  Tree USING [NullIndex];SymbolCopierA: PROGRAM  IMPORTS    Alloc, Copier, CopierPrivateDefs, Inline, SymbolOps  EXPORTS Copier, CopierPrivateDefs, SymbolTable  SHARES Copier =  {  OPEN Copier, SymbolOps, Symbols;  SEToken: TYPE = Copier.SEToken;  NullSEToken: SEToken = Copier.NullSEToken;  Handle: TYPE = SymbolTable.Handle;  CopierSearchCache: PUBLIC TYPE = CopierPrivateDefs.SearchCache;  M: PROC[m: LONG POINTER TO SymbolTable.CopierSearchCache]     RETURNS[LONG POINTER TO CopierSearchCache] = INLINE {RETURN[LOOPHOLE[m]]};  -- initialization/finalization  CopierInit: PUBLIC PROC [h: Handle, coPilot: BOOLEAN ¬ FALSE] = {    h.iHandle ¬ NIL;    h.inDebugger ¬ coPilot;    IF h.useMemo THEN {      h.memoCache ¬ h.zone.NEW[CopierPrivateDefs.SearchCache ¬ ALL[[hti: HTNull, ctx: CTXNull]]];      h.typeCache ¬ h.zone.NEW[        TypeCache ¬ ALL[[mdi: MDNull, iSei: SENull, sei: SENull]]]}    ELSE {h.memoCache ¬ NIL; h.typeCache ¬ NIL}};  ResetCaches: PROC [h: Handle] = {  -- see ResetIncludeContexts    IF h.typeCache # NIL THEN h.zone.FREE[@h.typeCache];    IF h.memoCache # NIL THEN h.zone.FREE[@h.memoCache]};  CopierReset: PUBLIC PROC [h: Handle] = {    ResetIncludeContexts[h];    IF h.inDebugger AND h.iHandle # NIL THEN CloseIncludedTable[h]};  -- manipulation of symbol tokens (without copying)  CtxValue: PUBLIC PROC [h: Handle, ctx: CTXIndex, value: Unspec] RETURNS [t: SEToken] = {    mdi: MDIndex;    iCtx: CTXIndex;    [mdi, iCtx] ¬ InverseMapCtx[h, ctx];    IF OpenIncludedTable[h, mdi] THEN {      t ¬ [SymbolOps.SeiForValue[h.iHandle, value, iCtx]]; CloseIncludedTable[h]}    ELSE t ¬ NullSEToken;    RETURN};  CtxFirst: PUBLIC PROC [h: Handle, ctx: CTXIndex] RETURNS [t: SEToken] = {    mdi: MDIndex;    iCtx: CTXIndex;    [mdi, iCtx] ¬ InverseMapCtx[h, ctx];    IF OpenIncludedTable[h, mdi] THEN {      t ¬ [SymbolOps.FirstCtxSe[h.iHandle, iCtx]]; CloseIncludedTable[h]}    ELSE t ¬ NullSEToken;    RETURN};  CtxNext: PUBLIC PROC [h: Handle, ctx: CTXIndex, t: SEToken] RETURNS [next: SEToken] = {    mdi: MDIndex;    iCtx: CTXIndex;    [mdi, iCtx] ¬ InverseMapCtx[h, ctx];    IF t # NullSEToken AND OpenIncludedTable[h, mdi] THEN {      next ¬ [SymbolOps.NextSe[h.iHandle, t]]; CloseIncludedTable[h]}    ELSE next ¬ NullSEToken;    RETURN};  TokenHash: PUBLIC PROC [h: Handle, ctx: CTXIndex, t: SEToken] RETURNS [hti: HTIndex] = {    mdi: MDIndex = InverseMapCtx[h, ctx].mdi;    IF t # NullSEToken AND OpenIncludedTable[h, mdi] THEN {      hti ¬ MapHti[h, h.iHandle.seb[t].hash]; CloseIncludedTable[h]}    ELSE hti ¬ HTNull;    RETURN};  TokenValue: PUBLIC PROC [h: Handle, ctx: CTXIndex, t: SEToken] RETURNS [v: WORD] = {    mdi: MDIndex = InverseMapCtx[h, ctx].mdi;    IF t # NullSEToken AND OpenIncludedTable[h, mdi] THEN {      v ¬ ToCard[h.iHandle.seb[t].idValue]; CloseIncludedTable[h]}    ELSE v ¬ 0;    RETURN};  TokenSymbol: PUBLIC PROC [h: Handle, ctx: CTXIndex, t: SEToken] RETURNS [sei: ISEIndex] = {    mdi: MDIndex = InverseMapCtx[h, ctx].mdi;    SELECT TRUE FROM      (mdi = OwnMdi) => sei ¬ t;      OpenIncludedTable[h, mdi] => {        sei ¬ LOOPHOLE[CopyIncludedSymbol[h, t, mdi]]; CloseIncludedTable[h]};      ENDCASE => sei ¬ ISENull;    RETURN};  -- copying across table boundaries  SubString: TYPE = String.SubString;  SubStringDescriptor: TYPE = String.SubStringDescriptor;  SearchFileCtx: PUBLIC PROC [h: Handle, hti: HTIndex, ctx: IncludedCTXIndex]    RETURNS [found: BOOLEAN, sei: ISEIndex] = {    desc: SubStringDescriptor;    s: SubString = @desc;    hash: [0..CopierPrivateDefs.MemoCacheSize);    iHti: HTIndex;    iSei: ISEIndex;    mdi: MDIndex = h.ctxb[ctx].module;    SubStringForHash[h, s, hti];    hash ¬ Inline.LongDivMod[      Inline.LongMult[LOOPHOLE[hti], LOOPHOLE[ctx]], CopierPrivateDefs.MemoCacheSize].remainder;    IF h.memoCache # NIL AND M[h.memoCache][hash].hti = hti AND M[h.memoCache][hash].ctx = ctx      THEN RETURN[FALSE, ISENull];    IF OpenIncludedTable[h, mdi] THEN {      iHti ¬ SymbolOps.FindString[h.iHandle, s];      IF iHti # HTNull        AND (h.iHandle.ht[iHti].anyPublic OR h.inDebugger OR h.iHandle.ht[iHti].anyInternal) THEN {        iSei ¬ SymbolOps.SearchContext[h.iHandle, iHti, h.ctxb[ctx].map];        IF (found ¬ iSei # SENull) THEN sei ¬ CopyCtxSe[h, iSei, hti, ctx, mdi]}      ELSE {found ¬ FALSE; sei ¬ ISENull};      CloseIncludedTable[h]}    ELSE {found ¬ FALSE; sei ¬ ISENull};    IF ~found AND h.memoCache # NIL THEN M[h.memoCache][hash] ¬ [hti: hti, ctx: ctx];    RETURN};  Delink: PUBLIC PROC [h: Handle, sei: ISEIndex] = {    prev, next: ISEIndex;    ctx: CTXIndex = h.seb[sei].idCtx;  -- assumed not reset    prev ¬ h.ctxb[ctx].seList;    DO      next ¬ SymbolOps.NextSe[h, prev];      SELECT next FROM        sei => EXIT;        h.ctxb[ctx].seList, ISENull => ERROR;        ENDCASE => prev ¬ next;      ENDLOOP;    IF SymbolOps.NextSe[h, sei] = sei THEN h.ctxb[ctx].seList ¬ ISENull    ELSE {      IF sei = h.ctxb[ctx].seList THEN h.ctxb[ctx].seList ¬ prev;      SymbolOps.SetSeLink[h, prev, SymbolOps.NextSe[h, sei]]};    SymbolOps.SetSeLink[h, sei, ISENull]};  CopySymbol: PUBLIC PROC [h: Handle, mdi: MDIndex, iSei: SEIndex, depth: Closure]    RETURNS [sei: SEIndex] = {    SELECT TRUE FROM      (mdi = OwnMdi) => sei ¬ iSei;      OpenIncludedTable[h, mdi] => {        sei ¬ CopyIncludedSymbol[h, iSei, mdi];        WITH s: h.seb[sei] SELECT FROM          id => {            CompleteType[h, s.idType, mdi, depth];            IF s.idType = typeTYPE THEN CompleteType[h, ToSei[s.idInfo], mdi, depth]}          ENDCASE => CompleteType[h, sei, mdi, depth];        CloseIncludedTable[h]};      ENDCASE => sei ¬ SENull;    RETURN};  -- context completion  CompleteContext: PUBLIC PROC [h: Handle, ctx: IncludedCTXIndex, depth: Closure ¬ unit] = {    IF h.ctxb[ctx].copied < depth AND OpenIncludedTable[h, h.ctxb[ctx].module] THEN {      FillContext[h, ctx, depth]; CloseIncludedTable[h]}};  AugmentContext: PUBLIC PROC [h: Handle, ctx: IncludedCTXIndex, mdi: MDIndex] = {    mdRoot: MDIndex;    target: CTXIndex;    [mdRoot, target] ¬ InverseMapCtx[h, ctx];    IF ~h.ctxb[ctx].reset AND OpenIncludedTable[h, mdi] THEN {      newMdi: MDIndex = SymbolOps.FindMdi[h.iHandle, h.mdb[mdRoot].stamp];      IF newMdi # MDNull THEN        FOR iCtx: IncludedCTXIndex ¬ h.iHandle.mdb[newMdi].ctx, h.iHandle.ctxb[iCtx].chain          UNTIL iCtx = CTXNull DO          IF h.iHandle.ctxb[iCtx].map = target THEN {            CopyCtxEntries[h, ctx, iCtx, mdi, unit];            IF ~h.iHandle.ctxb[iCtx].complete THEN {	      h.ctxb[ctx].complete ¬ FALSE; h.ctxb[ctx].copied ¬ none};            IF h.ctxb[ctx].complete THEN ResetCtx[h, ctx];            EXIT};          ENDLOOP;      CloseIncludedTable[h]}};  FillContext: PROC [h: Handle, ctx: IncludedCTXIndex, depth: Closure] = {    mdi: MDIndex = h.ctxb[ctx].module;    CopyCtxEntries[h, ctx, h.ctxb[ctx].map, mdi, depth];    ResetCtx[h, ctx]};  CopyContext: PROC [h: Handle, ctx, iCtx: CTXIndex, mdi: MDIndex, depth: Closure] = {    WITH h.ctxb[ctx] SELECT FROM      included => {        tCtx: IncludedCTXIndex = LOOPHOLE[ctx];        IF h.ctxb[tCtx].copied < depth AND (~h.ctxb[tCtx].closed OR depth > unit) THEN          {          h.ctxb[tCtx].closed ¬ TRUE;          CopyCtxEntries[h, tCtx, iCtx, mdi, depth];          ResetCtx[h, tCtx]}};      ENDCASE => NULL};  CopyCtxEntries: PROC [ h: Handle,    ctx: IncludedCTXIndex, iCtx: CTXIndex, mdi: MDIndex, depth: Closure] = {    IF h.ctxb[ctx].copied < depth THEN {      pSei: ISEIndex ¬ ISENull;      h.ctxb[ctx].copied ¬ depth;      FOR iSei: ISEIndex ¬ SymbolOps.FirstCtxSe[h.iHandle, iCtx], SymbolOps.NextSe[h.iHandle, iSei] UNTIL iSei =        SENull DO        hti: HTIndex = MapHti[h, h.iHandle.seb[iSei].hash];        sei: ISEIndex ¬          IF hti = HTNull AND h.ctxb[ctx].reset THEN SymbolOps.FirstCtxSe[h, ctx]          ELSE SymbolOps.SearchContext[h, hti, ctx];        IF ~h.ctxb[ctx].reset THEN {          IF sei = SENull THEN sei ¬ CopyCtxSe[h, iSei, hti, ctx, mdi];          IF pSei # SENull AND SymbolOps.NextSe[h, pSei] # sei THEN {            Delink[h, sei]; 	    SymbolOps.SetSeLink[h, sei, SymbolOps.NextSe[h, pSei]]; 	    SymbolOps.SetSeLink[h, pSei, sei]};          h.ctxb[ctx].seList ¬ pSei ¬ sei};        IF depth > unit AND sei # SENull THEN {          subType: CSEIndex = SymbolOps.UnderType[h,            IF h.seb[sei].idType = typeTYPE THEN sei ELSE h.seb[sei].idType];          IF (depth = rc AND SymbolOps.RCType[h, subType] # none) OR depth > rc THEN            IF h.seb[sei].idType = typeTYPE THEN CompleteVariant[h, sei, mdi, depth]            ELSE CompleteType[h, subType, mdi, depth]};        ENDLOOP;      h.ctxb[ctx].complete ¬ TRUE}};  -- recursive type completion  CompleteType: PROC [h: Handle, sei: SEIndex, mdi: MDIndex, depth: Closure] = {    -- N.B.  still incomplete if depth > rc    type: CSEIndex = SymbolOps.UnderType[h, sei];    WITH t: h.seb[type] SELECT FROM      enumerated => IF depth > rc THEN CompleteEnumeration[h, type, mdi, depth];      record => CompleteRecord[h, type, mdi, TRUE, depth];      ref => IF depth > rc THEN CompleteType[h, t.refType, mdi, depth];      array => {        CompleteType[h, t.indexType, mdi, depth];        CompleteType[h, t.componentType, mdi, depth]};      arraydesc => IF depth > rc THEN CompleteType[h, t.describedType, mdi, depth];      transfer, definition => NULL;  -- *** temporary ***      union => CompleteUnion[h, type, mdi, depth];      sequence => {        CompleteType[h, h.seb[t.tagSei].idType, mdi, depth];        CompleteType[h, t.componentType, mdi, depth]};      relative => {        CompleteType[h, t.baseType, mdi, depth];        CompleteType[h, t.offsetType, mdi, depth]};      subrange => CompleteType[h, t.rangeType, mdi, depth];      long, real => CompleteType[h, t.rangeType, mdi, depth];      ENDCASE => NULL};  CompleteEnumeration: PROC [h: Handle, sei: CSEIndex, mdi: MDIndex, depth: Closure] = {    WITH type: h.seb[sei] SELECT FROM      enumerated => {        WITH c: h.ctxb[type.valueCtx] SELECT FROM          included =>            IF c.copied < depth THEN {              IF c.module = mdi THEN FillContext[h, LOOPHOLE[type.valueCtx], depth]              ELSE {                CloseIncludedTable[h];                CompleteContext[h, LOOPHOLE[type.valueCtx], depth];                [] ¬ OpenIncludedTable[h, mdi]}};          ENDCASE => NULL};      ENDCASE => NULL};  CompleteRecord: PUBLIC PROC [h: Handle,     sei: CSEIndex, mdi: MDIndex, doLink: BOOLEAN, depth: Closure ¬ unit] = {    WITH type: h.seb[sei] SELECT FROM      record => {        WITH type SELECT FROM          linked =>            IF doLink THEN CompleteRecord[h, SymbolOps.UnderType[h, linkType], mdi, TRUE, depth];          ENDCASE => NULL;        WITH c: h.ctxb[type.fieldCtx] SELECT FROM          included =>            IF c.copied < depth THEN {              IF c.module = mdi THEN FillContext[h, LOOPHOLE[type.fieldCtx], depth]              ELSE {                CloseIncludedTable[h];                CompleteContext[h, LOOPHOLE[type.fieldCtx], depth];                [] ¬ OpenIncludedTable[h, mdi]}};          ENDCASE => NULL};      ENDCASE => NULL};  CompleteUnion: PROC [h: Handle, sei: CSEIndex, mdi: MDIndex, depth: Closure] = {    WITH type: h.seb[sei] SELECT FROM      union => {        CompleteType[h, h.seb[type.tagSei].idType, mdi, depth];        WITH c: h.ctxb[type.caseCtx] SELECT FROM          included =>            IF c.copied < depth THEN {              IF c.module = mdi THEN FillContext[h, LOOPHOLE[type.caseCtx], depth]              ELSE {                CloseIncludedTable[h];                CompleteContext[h, LOOPHOLE[type.caseCtx], depth];                [] ¬ OpenIncludedTable[h, mdi]}};          ENDCASE => NULL};      ENDCASE => NULL};  CompleteVariant: PROC [h: Handle, sei: ISEIndex, mdi: MDIndex, depth: Closure] = {    type: CSEIndex = SymbolOps.UnderType[h, sei];    WITH h.seb[type] SELECT FROM      record => CompleteRecord[h, type, mdi, FALSE, depth];      ENDCASE => NULL};  -- variant copying  CopyUnion: PUBLIC PROC [h: Handle, ctx: CTXIndex, depth: Closure ¬ none] = {    WITH c: h.ctxb[ctx] SELECT FROM      included =>        IF ~c.reset AND OpenIncludedTable[h, c.module] THEN {          FillUnionPart[h, LOOPHOLE[ctx], depth]; CloseIncludedTable[h]};      ENDCASE};  FillUnionPart: PROC [h: Handle, ctx: IncludedCTXIndex, depth: Closure ¬ none] = {    iRoot: ISEIndex = h.iHandle.ctxb[h.ctxb[ctx].map].seList;    iSei: ISEIndex ¬ iRoot;    DO      IF iSei = SENull THEN EXIT;      SELECT SymbolOps.TypeForm[h.iHandle, h.iHandle.seb[iSei].idType] FROM        union, sequence => {          IF h.iHandle.seb[iSei].hash # HTNull THEN            [] ¬ CopyIncludedSymbol[h, iSei, h.ctxb[ctx].module]          ELSE FillContext[h, LOOPHOLE[ctx], MAX[unit, depth]];          EXIT};        ENDCASE;      IF (iSei ¬ SymbolOps.NextSe[h.iHandle, iSei]) = iRoot THEN EXIT;      ENDLOOP};  FillUnion: PUBLIC PROC [h: Handle, sei: CSEIndex, mdi: MDIndex] = {    WITH type: h.seb[sei] SELECT FROM      record => {        WITH c: h.ctxb[type.fieldCtx] SELECT FROM          included =>            IF ~c.reset THEN {              IF c.module = mdi THEN FillUnionPart[h, LOOPHOLE[type.fieldCtx]]              ELSE {                CloseIncludedTable[h];                CopyUnion[h, type.fieldCtx];                [] ¬ OpenIncludedTable[h, mdi]}};          ENDCASE => NULL};      ENDCASE => NULL};  -- mappings  MapHti: PUBLIC PROC [h: Handle, iHti: HTIndex] RETURNS [hti: HTIndex] = {    desc: SubStringDescriptor;    s: SubString = @desc;    IF iHti = HTNull THEN hti ¬ HTNull    ELSE {      SymbolOps.SubStringForHash[h.iHandle, s, iHti];      hti ¬ SymbolOps.EnterString[h, s ! TableRelocated => {s.base ¬ h.iHandle.ssb}]};    RETURN};  MissingHti: ERROR = CODE;  InverseMapHti: PROC [h: Handle, hti: HTIndex] RETURNS [iHti: HTIndex] = {    desc: SubStringDescriptor;    s: SubString = @desc;    IF hti = HTNull THEN iHti ¬ HTNull    ELSE {      SymbolOps.SubStringForHash[h, s, hti];      iHti ¬ SymbolOps.FindString[h.iHandle, s];      IF iHti = HTNull THEN ERROR MissingHti};    RETURN};  FindExternalCtx: PUBLIC PROC [h: Handle, mdi: MDIndex, iCtx: CTXIndex]    RETURNS [ctx: IncludedCTXIndex] = {    IF mdi # MDNull AND OpenIncludedTable[h, mdi] THEN {      ctx ¬ MapCtx[h, mdi, iCtx]; CloseIncludedTable[h]}    ELSE ctx ¬ IncludedCTXNull;    RETURN};  MapCtx: PUBLIC PROC [h: Handle, mdi: MDIndex, iCtx: CTXIndex] RETURNS [IncludedCTXIndex] = {    ctx, last: IncludedCTXIndex;    target: CTXIndex;    mdRoot: MDIndex;    IF iCtx = CTXNull THEN {mdRoot ¬ mdi; target ¬ CTXNull}    ELSE {      WITH h.iHandle.ctxb[iCtx] SELECT FROM        included => [mdRoot, target] ¬ IncludedTargets[h, LOOPHOLE[iCtx]];        imported => {          IF h.inDebugger THEN {mdRoot ¬ mdi; target ¬ iCtx}          ELSE {            IF h.iHandle.mdb[h.iHandle.ctxb[includeLink].module].defaultImport # iCtx THEN              ERROR;  -- need a signal to raise            [mdRoot, target] ¬ IncludedTargets[h, includeLink]}};        ENDCASE => {mdRoot ¬ mdi; target ¬ iCtx}};    last ¬ IncludedCTXNull;    FOR ctx ¬ h.mdb[mdRoot].ctx, h.ctxb[ctx].chain UNTIL ctx = CTXNull DO      IF h.ctxb[ctx].map = target AND target # CTXNull THEN RETURN[ctx];      last ¬ ctx;      ENDLOOP;    ctx ¬ h.table.Words[ctxType, SIZE[included CTXRecord]];    IF ctx > LAST[CTXIndex] THEN ERROR Alloc.Failure[h.table, ctxType];    h.ctxb[ctx] ¬ CTXRecord[      mark: FALSE, varUpdated: FALSE, seList: ISENull,      level: IF iCtx = CTXNull THEN lZ ELSE h.iHandle.ctxb[iCtx].level,      extension: included[      chain: IncludedCTXNull, module: mdRoot, map: target, restricted: FALSE,      complete: FALSE, closed: FALSE, reset: FALSE]];    IF last = IncludedCTXNull THEN h.mdb[mdRoot].ctx ¬ ctx    ELSE h.ctxb[last].chain ¬ ctx;    RETURN[ctx]};  InverseMapCtx: PROC [h: Handle, ctx: CTXIndex] RETURNS [mdi: MDIndex, iCtx: CTXIndex] = {    WITH h.ctxb[ctx] SELECT FROM      included => {mdi ¬ module; iCtx ¬ map};      imported => [mdi, iCtx] ¬ InverseMapCtx[h, includeLink];      ENDCASE => {mdi ¬ OwnMdi; iCtx ¬ ctx};    RETURN};  IncludedTargets: PROC [h: Handle, iCtx: IncludedCTXIndex]    RETURNS [mdi: MDIndex, ctx: CTXIndex] = {    oldMdi: MDIndex = h.iHandle.ctxb[iCtx].module;    desc: SubStringDescriptor;    s: SubString = @desc;    SymbolOps.SubStringForHash[h.iHandle, s, h.iHandle.mdb[oldMdi].fileId];    mdi ¬ Copier.FindMdEntry[h: h, id: MapHti[h, h.iHandle.mdb[oldMdi].moduleId],      version: h.iHandle.mdb[oldMdi].stamp, file: MapHti[h, h.iHandle.mdb[oldMdi].fileId]];    ctx ¬ h.iHandle.ctxb[iCtx].map;    RETURN};  UnknownModule: PUBLIC SIGNAL [HTIndex] = CODE;  FillModule: PUBLIC PROC [h: Handle, sei: ISEIndex, typeId: HTIndex, mdi: MDIndex] = {    iHti: HTIndex;    iSei: ISEIndex;    IF mdi = MDNull OR ~OpenIncludedTable[h, mdi] THEN DummyCtxSe[h, sei]    ELSE {      -- allow failure exit      BEGIN      iHti ¬ InverseMapHti[h, typeId ! MissingHti => {GO TO failed}];      IF h.iHandle.stHandle = NIL THEN GO TO failed;      iSei ¬ SymbolOps.SearchContext[h.iHandle, iHti, h.iHandle.stHandle.directoryCtx];      IF iSei = ISENull OR ~h.iHandle.seb[iSei].public THEN GO TO failed;      CopyCtxSeInfo[h, sei, iSei, mdi];      h.seb[sei].public ¬ FALSE;      EXITS failed => {SIGNAL UnknownModule[h.seb[sei].hash]; DummyCtxSe[h, sei]};      END;      CloseIncludedTable[h]}};  DummyCtxSe: PROC [h: Handle, sei: ISEIndex] = {    h.seb[sei].idType ¬ typeANY;    h.seb[sei].idInfo ¬ h.seb[sei].idValue ¬ FromCard[0];    h.seb[sei].extended ¬ h.seb[sei].public ¬ h.seb[sei].linkSpace ¬ FALSE;    h.seb[sei].immutable ¬ h.seb[sei].constant ¬ TRUE;    h.seb[sei].mark3 ¬ h.seb[sei].mark4 ¬ TRUE};  -- caching of (cons) types  TypeCacheSize: CARDINAL = 83;  -- prime < 256/3  TypeCacheIndex: TYPE = [0..TypeCacheSize);  TypeCache: PUBLIC TYPE = ARRAY TypeCacheIndex OF RECORD [    mdi: MDIndex,    iSei: SEIndex,  -- the search keys    sei: SEIndex];  -- the result  T: PROC[t: LONG POINTER TO SymbolTable.TypeCache]    RETURNS[LONG POINTER TO TypeCache] = INLINE {RETURN[LOOPHOLE[t]]};  TypeHash: PROC [mdi: MDIndex, iSei: SEIndex] RETURNS [TypeCacheIndex] = INLINE {    RETURN[(LOOPHOLE[mdi, CARDINAL]*LOOPHOLE[iSei, CARDINAL]) MOD TypeCacheSize]};  CacheType: PROC [h: Handle, mdi: MDIndex, iSei, sei: SEIndex] = {    IF h.typeCache # NIL THEN      T[h.typeCache][TypeHash[mdi, iSei]] ¬ [mdi: mdi, iSei: iSei, sei: sei]};  -- copying symbols  CopyIncludedSymbol: PUBLIC PROC [h: Handle, iSei: SEIndex, mdi: MDIndex] RETURNS [sei: SEIndex] =    {    IF iSei = SENull THEN RETURN[SENull];    WITH iSe: h.iHandle.seb[iSei] SELECT FROM      id => {        hti: HTIndex = MapHti[h, iSe.hash];        IF iSe.idCtx IN StandardContext THEN {          sei ¬ SearchContext[h, hti, iSe.idCtx]; IF sei = SENull THEN ERROR}        ELSE {          ctx: IncludedCTXIndex = MapCtx[h, mdi, iSe.idCtx];          tSei: ISEIndex = SearchContext[h, hti, ctx];          sei ¬ tSei;          IF sei # SENull THEN h.seb[tSei].idCtx ¬ ctx          ELSE {            iMdi: MDIndex ¬ h.ctxb[ctx].module;            IF iMdi = mdi OR h.inDebugger              OR                ((~iSe.extended OR h.iHandle.stHandle.definitionsFile)                AND ~h.mdb[iMdi].shared) THEN              sei ¬ CopyCtxSe[h, LOOPHOLE[iSei, ISEIndex], hti, ctx, mdi]            ELSE {              CloseIncludedTable[h];              IF OpenIncludedTable[h, iMdi] THEN                iSei ¬ SymbolOps.SearchContext[h.iHandle, InverseMapHti[h, hti], h.ctxb[ctx].map]              ELSE [] ¬ OpenIncludedTable[h, iMdi ¬ mdi];              sei ¬ CopyCtxSe[h, LOOPHOLE[iSei, ISEIndex], hti, ctx, iMdi];              CloseIncludedTable[h];              [] ¬ OpenIncludedTable[h, mdi]}}}};      cons =>        WITH iType: iSe SELECT FROM          mode => sei ¬ typeTYPE;          basic => sei ¬ MapBasicType[h, iType.code];          ENDCASE => {            i: TypeCacheIndex = TypeHash[mdi, iSei];            IF h.typeCache # NIL AND T[h.typeCache][i].iSei = iSei              AND T[h.typeCache][i].mdi = mdi THEN sei ¬ T[h.typeCache][i].sei            ELSE sei ¬ CopyNonCtxSe[h, LOOPHOLE[iSei, CSEIndex], mdi]};      ENDCASE;    RETURN};  CopyCtxSe: PROC [h: Handle, iSei: ISEIndex, hti: HTIndex, ctx: CTXIndex, mdi: MDIndex]    RETURNS [sei: ISEIndex] = {    sei ¬ MakeCtxSe[h, hti, ctx]; CopyCtxSeInfo[h, sei, iSei, mdi]; RETURN};  CopyCtxSeInfo: PROC [h: Handle, sei, iSei: ISEIndex, mdi: MDIndex] = {    OPEN id: h.seb[sei];    IF h.iHandle.seb[iSei].idCtx = CTXNull THEN id.idCtx ¬ CTXNull;    id.extended ¬ h.iHandle.seb[iSei].extended;    id.public ¬ h.iHandle.seb[iSei].public;    id.immutable ¬ h.iHandle.seb[iSei].immutable;    id.constant ¬ h.iHandle.seb[iSei].constant;    id.linkSpace ¬ h.iHandle.seb[iSei].linkSpace;    id.idType ¬ CopyIncludedSymbol[h, h.iHandle.seb[iSei].idType, mdi];    IF h.iHandle.seb[iSei].idType = typeTYPE THEN      id.idInfo ¬ FromSei[CopyIncludedSymbol[h, ToSei[h.iHandle.seb[iSei].idInfo], mdi]]    ELSE      IF h.iHandle.seb[iSei].constant        AND          (SELECT SymbolOps.XferMode[h.iHandle, h.iHandle.seb[iSei].idType] FROM             proc, program => TRUE,             ENDCASE => FALSE) THEN        id.idInfo ¬ FromBti[CopyIncludedBody[h, ToBti[h.iHandle.seb[iSei].idInfo], sei, mdi]]      ELSE id.idInfo ¬ h.iHandle.seb[iSei].idInfo;    id.idValue ¬ h.iHandle.seb[iSei].idValue;    id.mark3 ¬ id.mark4 ¬ TRUE;    IF id.extended THEN CopierPrivateDefs.CopyExtension[h, sei, iSei, mdi]    ELSE IF id.linkSpace AND ~h.inDebugger THEN id.idInfo ¬ FromCard[0]};      CopyExternalBody: PUBLIC PROC [h: Handle, mdi: MDIndex, iBti: CBTIndex]    RETURNS [bti: CBTIndex] = {    IF iBti # CBTNull AND mdi # MDNull AND OpenIncludedTable[h, mdi] THEN {      sei: ISEIndex;      iSei: ISEIndex = h.iHandle.bb[iBti].id;      IF iSei # ISENull THEN {        sei ¬ LOOPHOLE[CopyIncludedSymbol[h, iSei, mdi]]; 	IF h.iHandle.bb[iBti].nesting = Catch THEN	  bti ¬ CopyIncludedBody[h, iBti, sei, mdi]	ELSE bti ¬ ToBti[h.seb[sei].idInfo]}      ELSE bti ¬ CopyIncludedBody[h, iBti, ISENull, mdi];      CloseIncludedTable[h]}    ELSE bti ¬ CBTNull;    RETURN};  CopyIncludedBody: PUBLIC PROC [h: Handle, iBti: CBTIndex, sei: ISEIndex, mdi: MDIndex]    RETURNS [bti: CBTIndex] = {    catch: BOOLEAN ¬ FALSE;    iCtx: CTXIndex;    IF iBti = BTNull THEN bti ¬ CBTNull    ELSE {      iCtx ¬ h.iHandle.bb[iBti].localCtx;      WITH body: h.iHandle.bb[iBti] SELECT FROM        Outer => {          bti ¬ h.table.Words[bodyType, SIZE[Outer Callable BodyRecord]];          h.bb[LOOPHOLE[bti, OCBTIndex]] ¬ body};        Inner => {          bti ¬ h.table.Words[bodyType, SIZE[Inner Callable BodyRecord]];          h.bb[LOOPHOLE[bti, ICBTIndex]] ¬ body};        Catch => {          catch ¬ TRUE;          bti ¬ h.table.Words[bodyType, SIZE[Catch Callable BodyRecord]];          h.bb[LOOPHOLE[bti, CCBTIndex]] ¬ body};        ENDCASE => ERROR;      h.bb[bti].link ¬ [parent, BTNull];      h.bb[bti].firstSon ¬ BTNull;      h.bb[bti].id ¬ sei;      IF iCtx = CTXNull THEN {        h.bb[bti].localCtx ¬ CTXNull; h.bb[bti].type ¬ RecordSENull}      ELSE {        h.bb[bti].localCtx ¬ MapCtx[h, mdi, iCtx];        h.bb[bti].type ¬ LOOPHOLE[CopyIncludedSymbol[h, h.iHandle.bb[iBti].type, mdi]]};      SELECT TRUE FROM        catch => h.bb[bti].ioType ¬ CSENull;        h.iHandle.bb[iBti].inline => {          h.bb[bti].ioType ¬ CopyBodyType[h, h.iHandle.bb[iBti].ioType, mdi];          WITH body: h.bb[bti].info SELECT FROM            Internal => body.thread ¬ body.bodyTree ¬ Tree.NullIndex;            ENDCASE};        ENDCASE =>          h.bb[bti].ioType ¬            IF sei = ISENull OR h.seb[h.seb[sei].idType].seTag = id THEN 	      CopyBodyType[h, h.iHandle.bb[iBti].ioType, mdi]	      ELSE SymbolOps.UnderType[h, h.seb[sei].idType]};    RETURN};  MapBasicType: PROC [h: Handle, code: CARDINAL] RETURNS [CSEIndex] = {    FOR sei: ISEIndex ¬ SymbolOps.FirstCtxSe[h, FIRST[StandardContext]],       SymbolOps.NextSe[h, sei] UNTIL sei = ISENull DO      IF h.seb[sei].idType = typeTYPE THEN {        tSei: CSEIndex = SymbolOps.UnderType[h, sei];        WITH t: h.seb[tSei] SELECT FROM          basic => IF t.code = code THEN RETURN[tSei];          ENDCASE};      ENDLOOP;    ERROR};  CopyNonCtxSe: PROC [h: Handle, iSei: CSEIndex, mdi: MDIndex] RETURNS [sei: CSEIndex] = {    tSei1, tSei2: SEIndex;    WITH iType: h.iHandle.seb[iSei] SELECT FROM      enumerated => {        tCtx: CTXIndex;        sei ¬ SymbolOps.MakeNonCtxSe[h, SIZE[enumerated cons SERecord]];        tCtx ¬          IF iType.valueCtx IN StandardContext THEN iType.valueCtx          ELSE CopyIncludedValues[h, iType.unpainted, iType.valueCtx, mdi, sei];        h.seb[sei].typeInfo ¬ enumerated[          ordered: iType.ordered, machineDep: iType.machineDep,          unpainted: iType.unpainted, sparse: iType.sparse, valueCtx: tCtx,          nValues: iType.nValues];        CacheType[h, mdi, iSei, sei]};      record => {        tCtx: CTXIndex =          IF iType.fieldCtx IN StandardContext THEN iType.fieldCtx          ELSE MapCtx[h, mdi, iType.fieldCtx];        WITH iType SELECT FROM          notLinked => {            sei ¬ SymbolOps.MakeNonCtxSe[h, SIZE[notLinked record cons SERecord]];            CacheType[h, mdi, iSei, sei];            h.seb[sei].typeInfo ¬ record[              machineDep: iType.machineDep, painted: iType.painted,              argument: iType.argument, hints: iType.hints, fieldCtx: tCtx,              length: iType.length, monitored: iType.monitored,              linkPart: notLinked[]]};          linked => {            sei ¬ SymbolOps.MakeNonCtxSe[h, SIZE[linked record cons SERecord]];            CacheType[h, mdi, iSei, sei];            tSei1 ¬ CopyIncludedSymbol[h, linkType, mdi];            h.seb[sei].typeInfo ¬ record[              machineDep: iType.machineDep, painted: iType.painted,              argument: iType.argument, hints: iType.hints, fieldCtx: tCtx,              length: iType.length, monitored: iType.monitored,              linkPart: linked[linkType: tSei1]]};          ENDCASE;        IF ~iType.painted OR (iType.hints.refField AND iType.hints.unifield) THEN          CopyContext[h, tCtx, iType.fieldCtx, mdi, unit]};      ref => {        sei ¬ SymbolOps.MakeNonCtxSe[h, SIZE[ref cons SERecord]];        CacheType[h, mdi, iSei, sei];        tSei1 ¬ CopyIncludedSymbol[h, iType.refType, mdi];        h.seb[sei].typeInfo ¬ ref[          refType: tSei1, counted: iType.counted, var: iType.var,          readOnly: iType.readOnly, ordered: iType.ordered, list: iType.list,          basing: iType.basing]};      array => {        sei ¬ SymbolOps.MakeNonCtxSe[h, SIZE[array cons SERecord]];        CacheType[h, mdi, iSei, sei];        tSei1 ¬ CopyIncludedSymbol[h, iType.indexType, mdi];        tSei2 ¬ CopyIncludedSymbol[h, iType.componentType, mdi];        h.seb[sei].typeInfo ¬ array[          packed: iType.packed, indexType: tSei1, componentType: tSei2]};      arraydesc => {        sei ¬  SymbolOps.MakeNonCtxSe[h, SIZE[arraydesc cons SERecord]];        CacheType[h, mdi, iSei, sei];        tSei1 ¬ CopyIncludedSymbol[h, iType.describedType, mdi];        h.seb[sei].typeInfo ¬ arraydesc[          readOnly: iType.readOnly, var: iType.var, describedType: tSei1]};      transfer => {  -- do not use cache (in case of importing)        argSei1, argSei2: CSEIndex;        sei ¬  SymbolOps.MakeNonCtxSe[h, SIZE[transfer cons SERecord]];        argSei1 ¬ CopyArgs[h, iType.typeIn, mdi, FALSE];        argSei2 ¬ CopyArgs[h, iType.typeOut, mdi, FALSE];        h.seb[sei].typeInfo ¬ transfer[          mode: iType.mode, safe: iType.safe, typeIn: argSei1, typeOut: argSei2]};      definition => {        sei ¬  SymbolOps.MakeNonCtxSe[h, SIZE[definition cons SERecord]];        h.seb[sei].typeInfo ¬ definition[          named: iType.named,          defCtx: MapCtx[h, mdi, iType.defCtx]]};      union => {        tag: ISEIndex;        tCtx: CTXIndex;        sei ¬  SymbolOps.MakeNonCtxSe[h, SIZE[union cons SERecord]];        CacheType[h, mdi, iSei, sei];        tCtx ¬ MapCtx[h, mdi, iType.caseCtx];        tag ¬ CopyCtxSe[h, iType.tagSei, MapHti[h, h.iHandle.seb[iType.tagSei].hash], CTXNull, mdi];        h.seb[sei].typeInfo ¬ union[          caseCtx: tCtx, machineDep: iType.machineDep, overlaid: iType.overlaid,          controlled: iType.controlled, tagSei: tag, hints: iType.hints]};      sequence => {        tag: ISEIndex;        sei ¬  SymbolOps.MakeNonCtxSe[h, SIZE[sequence cons SERecord]];        CacheType[h, mdi, iSei, sei];        tSei1 ¬ CopyIncludedSymbol[h, iType.componentType, mdi];        tag ¬ CopyCtxSe[h, iType.tagSei, MapHti[h, h.iHandle.seb[iType.tagSei].hash], CTXNull, mdi];        h.seb[sei].typeInfo ¬ sequence[          packed: iType.packed, controlled: iType.controlled,          machineDep: iType.machineDep, tagSei: tag, componentType: tSei1]};      relative => {        tSei3: SEIndex;        sei ¬  SymbolOps.MakeNonCtxSe[h, SIZE[relative cons SERecord]];        CacheType[h, mdi, iSei, sei];        tSei1 ¬ CopyIncludedSymbol[h, iType.baseType, mdi];        tSei2 ¬ CopyIncludedSymbol[h, iType.offsetType, mdi];        tSei3 ¬          IF iType.resultType = iType.offsetType THEN tSei2          ELSE CopyIncludedSymbol[h, iType.resultType, mdi];        h.seb[sei].typeInfo ¬ relative[          baseType: tSei1, offsetType: tSei2, resultType: tSei3]};      opaque => {        sei ¬  SymbolOps.MakeNonCtxSe[h, SIZE[opaque cons SERecord]];        CacheType[h, mdi, iSei, sei];        tSei1 ¬ CopyIncludedSymbol[h, iType.id, mdi];        h.seb[sei].typeInfo ¬ opaque[          lengthKnown: iType.lengthKnown, length: iType.length,          id: LOOPHOLE[tSei1]]};      zone => {        sei ¬  SymbolOps.MakeNonCtxSe[h, SIZE[zone cons SERecord]];        h.seb[sei].typeInfo ¬ zone[mds: iType.mds, counted: iType.counted];        CacheType[h, mdi, iSei, sei]};      subrange => {        sei ¬  SymbolOps.MakeNonCtxSe[h, SIZE[subrange cons SERecord]];        tSei1 ¬ CopyIncludedSymbol[h, iType.rangeType, mdi];        h.seb[sei].typeInfo ¬ subrange[          filled: iType.filled, empty: iType.empty, rangeType: tSei1,          origin: iType.origin, range: iType.range];        CacheType[h, mdi, iSei, sei]};      long => {        sei ¬  SymbolOps.MakeNonCtxSe[h, SIZE[long cons SERecord]];        CacheType[h, mdi, iSei, sei];        tSei1 ¬ CopyIncludedSymbol[h, iType.rangeType, mdi];        h.seb[sei].typeInfo ¬ long[rangeType: tSei1]};      real => {        sei ¬  SymbolOps.MakeNonCtxSe[h, SIZE[real cons SERecord]];        CacheType[h, mdi, iSei, sei];        tSei1 ¬ CopyIncludedSymbol[h, iType.rangeType, mdi];        h.seb[sei].typeInfo ¬ real[rangeType: tSei1]};      any => {        sei ¬  SymbolOps.MakeNonCtxSe[h, SIZE[any cons SERecord]];        h.seb[sei].typeInfo ¬ any[];        CacheType[h, mdi, iSei, sei]};      ENDCASE => ERROR;    h.seb[sei].mark3 ¬ h.seb[sei].mark4 ¬ TRUE;    RETURN};  CopyBodyType: PROC [h: Handle, iSei: CSEIndex, mdi: MDIndex]     RETURNS [sei: CSEIndex] = {    argSei1, argSei2: CSEIndex;    WITH iType: h.iHandle.seb[iSei] SELECT FROM      transfer => {        sei ¬  SymbolOps.MakeNonCtxSe[h, SIZE[transfer cons SERecord]];        argSei1 ¬ CopyArgs[h, iType.typeIn, mdi, TRUE];        argSei2 ¬ CopyArgs[h, iType.typeOut, mdi, TRUE];        h.seb[sei].typeInfo ¬ transfer[          mode: iType.mode, safe: iType.safe, typeIn: argSei1, typeOut: argSei2]};      ENDCASE => ERROR;    h.seb[sei].mark3 ¬ h.seb[sei].mark4 ¬ TRUE;    RETURN};  CopyArgs: PROC [h: Handle, iargSei: CSEIndex, mdi: MDIndex, mapped: BOOLEAN]    RETURNS [argSei: CSEIndex] = {    IF iargSei = CSENull THEN argSei ¬ CSENull    ELSE      WITH t: h.iHandle.seb[iargSei] SELECT FROM        record => {          iCtx: CTXIndex = t.fieldCtx;          ctx: CTXIndex;          argSei ¬  SymbolOps.MakeNonCtxSe[h, SIZE[notLinked record cons SERecord]];          IF ~mapped THEN ctx ¬ SymbolOps.NewCtx[h, h.iHandle.ctxb[iCtx].level]          ELSE {            tCtx: IncludedCTXIndex = MapCtx[h, mdi, iCtx];            h.ctxb[tCtx].complete ¬ TRUE;            ResetCtx[h, tCtx];            ctx ¬ tCtx};          IF h.ctxb[ctx].seList = ISENull THEN {            seChain: ISEIndex ¬ SymbolOps.MakeSeChain[h, ctx, SymbolOps.CtxEntries[h.iHandle, iCtx], FALSE];            sei, iSei: ISEIndex;            h.ctxb[ctx].seList ¬ seChain;            FOR iSei ¬ h.iHandle.ctxb[iCtx].seList, SymbolOps.NextSe[h.iHandle, iSei] UNTIL iSei = ISENull              DO              sei ¬ seChain;              seChain ¬ SymbolOps.NextSe[h, seChain];              h.seb[sei].hash ¬ MapHti[h, h.iHandle.seb[iSei].hash];              CopyCtxSeInfo[h, sei, iSei, mdi];              ENDLOOP};          h.seb[argSei] ¬ SERecord[            mark3: TRUE, mark4: TRUE,            body: cons[            record[            machineDep: FALSE, painted: FALSE, argument: TRUE, hints: t.hints,            fieldCtx: ctx, length: t.length, monitored: FALSE,            linkPart: notLinked[]]]];          IF h.typeCache # NIL THEN {            i: TypeCacheIndex = TypeHash[mdi, iargSei];            T[h.typeCache][i] ¬ [mdi: mdi, iSei: iargSei, sei: argSei]}};        ENDCASE => argSei ¬ CopyNonCtxSe[h, iargSei, mdi];    RETURN};  CopyIncludedValues: PROC [    h: Handle, full: BOOLEAN, iCtx: CTXIndex, mdi: MDIndex, type: SEIndex]    RETURNS [ctx: IncludedCTXIndex] = {    iSei, sei, seChain: ISEIndex;    ctx ¬ MapCtx[h, mdi, iCtx];    iSei ¬ h.iHandle.ctxb[iCtx].seList;    IF full OR (iSei # SENull AND h.iHandle.seb[h.iHandle.seb[iSei].idType].seTag # id) THEN {      seChain ¬ SymbolOps.MakeSeChain[h, ctx, SymbolOps.CtxEntries[h.iHandle, iCtx], FALSE];      h.ctxb[ctx].seList ¬ seChain;      h.ctxb[ctx].closed ¬ h.ctxb[ctx].reset ¬ TRUE;      UNTIL iSei = SENull DO        sei ¬ seChain;        seChain ¬ SymbolOps.NextSe[h, seChain];        h.seb[sei].hash ¬ MapHti[h, h.iHandle.seb[iSei].hash];        h.seb[sei].extended ¬ h.seb[sei].linkSpace ¬ FALSE;        h.seb[sei].immutable ¬ h.seb[sei].constant ¬ TRUE;        h.seb[sei].public ¬ h.iHandle.seb[iSei].public;        h.seb[sei].idType ¬ type;        h.seb[sei].idInfo ¬ FromCard[0];        h.seb[sei].idValue ¬ h.iHandle.seb[iSei].idValue;        h.seb[sei].mark3 ¬ h.seb[sei].mark4 ¬ TRUE;        iSei ¬ SymbolOps.NextSe[h.iHandle, iSei];        ENDLOOP;      h.ctxb[ctx].copied ¬ full;      h.ctxb[ctx].complete ¬ TRUE};    RETURN};  -- included module accounting  ResetCtx: PROC [h: Handle, ctx: IncludedCTXIndex] = {    IF ~h.ctxb[ctx].reset THEN {      ResetCtxList[h, ctx]; h.ctxb[ctx].closed ¬ h.ctxb[ctx].reset ¬ TRUE}};  ResetIncludeContexts: PROC [h: Handle] = {    mdi: MDIndex;    limit: MDIndex = h.table.Top[mdType];    ctx: IncludedCTXIndex;    FOR mdi ¬ FIRST[MDIndex], mdi + SIZE[MDRecord] UNTIL mdi = limit DO      FOR ctx ¬ h.mdb[mdi].ctx, h.ctxb[ctx].chain UNTIL ctx = CTXNull DO        h.ctxb[ctx].copied ¬ none;  -- clear bits (**** until bootstrap ****)        ResetCtx[h, ctx]        ENDLOOP;      ENDLOOP;    ResetCaches[h]};  WrongTable: ERROR = CODE;  Outer: PUBLIC PROC [h: Handle, mdi: MDIndex, inner: PROC [Handle]] = {    IF h.inDebugger AND mdi = OwnMdi THEN ERROR WrongTable;    IF mdi # MDNull AND OpenIncludedTable[h, mdi] THEN {      inner[h.iHandle ! UNWIND => {CloseIncludedTable[h]}]; CloseIncludedTable[h]}};  TableRelocated: PUBLIC SIGNAL = CODE;  OpenIncludedTable: PROC [h: Handle, mdi: MDIndex] RETURNS [success: BOOLEAN] = {    handle: Handle =      IF mdi = OwnMdi THEN h ELSE Copier.GetSymbolTable[h, mdi];    IF success ¬ (handle # NIL) THEN       h.iHandle ¬ handle;    RETURN};  CloseIncludedTable: PROC [h: Handle] = {    IF h.iHandle # h THEN {      Copier.FreeSymbolTable[h.iHandle]};    h.iHandle ¬ NIL};  }.
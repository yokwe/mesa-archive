-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.-- AccessFloppyTape.mesa              21-Jul-87 15:20:26 by RSV<< Overview    This interface provides device and file access to cartridge tapes      for software distribution and installation.    This interface is intended to meet the known requirements      of the BWS Installer and SCS.    This interface will not be used by File Service Backup and Restore      [but see item on common attributes in leader pages].       Design Considerations    BWS Installer deals with buffers rather than files.    Different clients have different run-time environments;      all communication with clients is with SIGNALS and clients are      responsible for formatting and displaying the corresponding error message.    Clients must be prepared to deal with errors reported by FloppyTape.    Clients are responsible for handling files which span volumes.    AttributesRecord cannot have fields which are LONG STRINGs;      StringBodys must be constructed.    A subset of the attributes in the leader page will be common between      installation and Backup/Restore. This would allow, for example,      tapes created by Backup to be listed by SCS.   >>DIRECTORY  AccessFloppy USING [    leaderLength, LengthInBytes, maxNameLength, sealValue, Time,    tFloppyLeaderPage],  Environment USING [Byte, wordsPerPage],  File USING [Type, File, PageNumber],  Floppy USING [PageCount, PageNumber],  FloppyTape USING [    Drive, FileHandle, localDrive, maxBytesInName, NotifyClientProc, VolumeHandle,    VolumeName, FileID],  NSString USING [String];AccessFloppyTape: DEFINITIONS  =  BEGIN  --  -- Definitions using TYPEs from the interfaces Floppy and AccessFloppy  -- serve primarily to document the intended similarities between  -- those interfaces and the FloppyTape and AccessFloppyTape interfaces  --  -- Remove some dependencies on Network Services interfaces  NSFileType: TYPE = LONG CARDINAL;  -- NSFile USING [Type]  Drive: TYPE = FloppyTape.Drive;  localDrive: Drive = FloppyTape.localDrive;  nullDrive: Drive = LAST[CARDINAL];  -- for "stateless" enumeration  ClientWord: TYPE = UNSPECIFIED;  Label: TYPE = FloppyTape.VolumeName;  maxLabelLength: CARDINAL = MIN[FloppyTape.maxBytesInName, 100];  -- volume name  Access: TYPE = {shared, exclusive};  VolumeHandle: TYPE = FloppyTape.VolumeHandle;  nullVolumeHandle: READONLY VolumeHandle;  -- FloppyTape.nullVolumeHandle  Attributes: TYPE = LONG POINTER TO AttributesRecord;  FileHandle: TYPE = FloppyTape.FileHandle;  nullFileHandle: READONLY FileHandle;  FileTypes: TYPE = DESCRIPTOR FOR ARRAY OF NSFileType;  anyType: FileTypes = DESCRIPTOR[NIL, 0];  NameOrPattern: TYPE = NSString.String;  anyName: READONLY NameOrPattern;  PageCount: TYPE = Floppy.PageCount;  PageNumber: TYPE = Floppy.PageNumber;  VMBuffer: TYPE = RECORD [count: PageCount, vm: LONG POINTER];  ByteCount: TYPE = AccessFloppy.LengthInBytes;  currentAttributeVersion: CARDINAL = 1;  DateAndTime: TYPE = AccessFloppy.Time;  fileTypeForLeaderPage: File.Type = AccessFloppy.tFloppyLeaderPage;  leaderPages: CARDINAL = MIN[AccessFloppy.leaderLength, 1];  -- The number of leader pages and the page size of the device  --   determines the amount of storage available for the AttributesRecord.  -- (leaderPages * Environment.wordsPerPage) must be greater than  --   SIZE[AttributesRecord]  ClientDataLength: TYPE = CARDINAL;  maxClientDataWords: ClientDataLength =    leaderPages * Environment.wordsPerPage - SIZE[AttributesRecord];  Creator: TYPE = MACHINE DEPENDENT{  -- environment of file writer    bws(0), fs(1), scs(2), tajo(3), other1(4), other2(5), other3(6), unknown(7)};  NameLength: TYPE = CARDINAL;  -- file name  maxNameLength: NameLength = MIN[AccessFloppy.maxNameLength, 100];  -- file name  sealValue: WORD = AccessFloppy.sealValue;  -- 1010101010101010 bits pattern  Flags: TYPE = MACHINE DEPENDENT RECORD [    serialized(0:0..0): BOOLEAN ¬ FALSE,    obsolete(0:1..1): BOOLEAN ¬ FALSE,    creator(0:2..4): Creator ¬ unknown,    reserved(0:5..15): BOOLEAN ¬ FALSE];  << The Common attributes define the common part of a leader page     and are the result of an agreement between SCS and FS >>  Common: TYPE = MACHINE DEPENDENT RECORD [    seal(0): WORD ¬ sealValue,  -- for consistency checking    attributeVersion(1): CARDINAL ¬ currentAttributeVersion,    -- to allow AttributesRecord format change    type(2): NSFileType,    version(4): CARDINAL ¬ 0,  -- for original disk file    flags(5): Flags,    created(6): DateAndTime,  -- from rigid disk MFile or NSFile file    modified(8): DateAndTime,  -- from rigid disk NSFile file;    -- same as "created" for MFile file    copied(10): DateAndTime,  -- when written to floppy disk or floppy tape    -- start of constructed StringBody    nameLength(12): NameLength ¬ 0,    nameLengthMax(13): NameLength ¬ maxNameLength,    name(14): PACKED ARRAY [0..maxNameLength) OF Environment.Byte,    -- end of constructed StringBody    fid(14 + (maxNameLength + 1) / 2): FloppyTape.FileID, -- place holder    reserved(16 + (maxNameLength + 1) / 2): PACKED ARRAY [0..8) OF      CARDINAL ¬ ALL[0]  -- for future use    ];  commonSize: CARDINAL = SIZE[Common];  AttributesRecord: TYPE = MACHINE DEPENDENT RECORD [    common(0): Common,    segmentOffset(commonSize): PageNumber ¬ 0,    -- page number in disk file of first page in this file segment    segmentPages(commonSize + 2): PageCount ¬ 0,    -- number of pages in this file segment    totalPages(commonSize + 4): PageCount ¬ 0, -- number of pages in disk file    totalBytes(commonSize + 6): ByteCount ¬ 0, -- number of bytes in disk file    -- client attributes    clientDataLength(commonSize + 8): ClientDataLength ¬ 0,    -- number of components in client private data    clientData(commonSize + 9):      SEQUENCE maxlength(commonSize + 9): ClientDataLength OF UNSPECIFIED    ];  Append: PROCEDURE [    file: FileHandle, buffer: VMBuffer, endOfFile: BOOLEAN ¬ TRUE];  AppendFromPilotFile: PROCEDURE [    pilotFile: File.File, tapeFile: FileHandle, firstPilotPage: File.PageNumber,    pageCount: PageCount, updateEndOfFile: BOOLEAN];  ChangeMedia: PROCEDURE [volume: VolumeHandle, writable: BOOLEAN]    RETURNS [newVolume: VolumeHandle];  << For files crossing media boundaries;     waits for device to go notReady then Ready.     Will not return until write-enabled if requested.     Does not release access lock (EXCEPT THAT I CANNOT CONTROL THIS) >>  Close: PROCEDURE [volume: VolumeHandle];  CopyFromPilotFile: PROCEDURE [    pilotFile: File.File, volume: FloppyTape.VolumeHandle,    firstPilotPage: File.PageNumber, pageCount: PageCount, type: File.Type,    attributes: Attributes] RETURNS [tapeFile: FloppyTape.FileID];  CopyToPilotFile: PROCEDURE [    floppyTapeFile: FileHandle, pilotFile: File.File,    firstFloppyTapePage: PageNumber, firstPilotPage: File.PageNumber,    pageCount: PageCount, attributes: Attributes];  DeviceReady: PROCEDURE [drive: Drive ¬ localDrive] RETURNS [ready: BOOLEAN];  << Accelerator for xxx[ready] >>  Enumerate: PROCEDURE [    volume: VolumeHandle, names: NameOrPattern ¬ anyName,    types: FileTypes ¬ anyType, startFrom: FileHandle ¬ nullFileHandle,    proc: EnumProc];  EnumProc: TYPE = PROCEDURE [file: FileHandle, attributes: Attributes]    RETURNS [continue: BOOLEAN ¬ TRUE];  GetAttributes: PROCEDURE [file: FileHandle, attributes: Attributes];  GetNextDrive: PROCEDURE [drive: Drive ¬ nullDrive] RETURNS [next: Drive];  << Enumeration of all drives attatched      starts with drive = nullDrive      and terminates when next = nullDrive.     Horizon Phase I will return one and only one cartridge tape device >>  GetNextFile: PROCEDURE [file: FileHandle] RETURNS [next: FileHandle];      GetVolumeAttributes: PROCEDURE [volume: VolumeHandle, label: Label]    RETURNS [      freeSpace: ByteCount, usedSpace: ByteCount, rootFile: FloppyTape.FileID,      clientWord: ClientWord, drive:Drive, numberOfBadSectors: CARDINAL];  Open: PROCEDURE [    drive: Drive ¬ localDrive, readOnly: BOOLEAN ¬ TRUE,    access: Access ¬ exclusive,    notifyClientOnRetention: FloppyTape.NotifyClientProc]    RETURNS [volume: VolumeHandle];  OverWriteFromPilotFile: PROCEDURE [    pilotFile: File.File, tapefile: FileHandle, firstPilotPage: File.PageNumber,    pageCount: PageCount, attributes: Attributes];  Read: PROCEDURE [file: FileHandle, first: PageNumber, buffer: VMBuffer]    RETURNS [transferred: PageCount ¬ 0, endOfFile: BOOLEAN ¬ TRUE];  << If this procedure returns with transferred=0 and endOfFile=FALSE,        a media change is indicated. >>  SetAttributes: PROCEDURE [file: FileHandle, attributes: Attributes];  SpaceAvailable: PROCEDURE [volume: VolumeHandle] RETURNS [freeSpace: PageCount];  << Accelerator for GetVolumeAttributes[freeSpace] >>  Writable: PROCEDURE [drive: Drive ¬ localDrive] RETURNS [writeEnable: BOOLEAN];  << Accelerator for xxx[inhibitWrite] >>  Write: PROCEDURE [volume: VolumeHandle, attributes: Attributes, buffer: VMBuffer]    RETURNS [fileId: FloppyTape.FileID];  --  -- Signals and Errors  --  NoDirReason: TYPE = {notPresent, ioError};  NoDirectory: SIGNAL [reason: NoDirReason];  NoLeaderPage: SIGNAL[file: FloppyTape.FileID];  Error: ERROR [error: ErrorType];  -- The error incompatibleSizes is raised when the file size supplied by client is bigger  -- than actual file size. The error invalidPageNumber is raised when the first page number  -- supplied by client falls outside the file size. The error noAttributesRecord is raised   -- file type in marker page is not fileTypeForLeaderPage.  ErrorType: TYPE = {    fileNotFound, incompatibleSizes, invalidParameter, invalidPageNumber,    noAttributesRecord, operationNotSupported, parameterNotSupported,    procedureNotImplemented};  InconsistentFile: SIGNAL [file: FileHandle];  InvalidVersion: SIGNAL [file: FileHandle, version: CARDINAL];  NoRoomForClientData: ERROR [wordsNeeded: CARDINAL];  -- Raised by GetAttributes, cannot be RESUMEd.  END.  Log [Time - Person - Action]14-Nov-86 16:51:35 - DWC - Created.26-Nov-86 12:34:57 - DDM - Fix compilation errors. 5-Dec-86 18:36:05 - DDM - More cleanup and re-structuring. Added procedures ChangeMedia, DeviceReady, Writable, and GetAttributes. Added file types parameter and changed pattern parameter for Enumerate. Added return parameters to Read. Added parameters to Write. Add some constants for leader pages and finished the leader page definition. 7-Dec-86 12:13:36 - DDM - Fixed ErrorType to match NSDeviceAccess. Changed parameters for procedures Read and Write; added procedure Append.12-Dec-86 13:14:42 - DDM - Respond to DWC comments. Initialize nullDrive. Change names of some types and constants in Leader Page Definition: LengthInBytes ¬ ByteCount, maxClientData ¬ maxClientDataWords, timeStamp ¬ copied; new types: ClientDataLength, Flags, NameLength.12-Jan-87 19:49:42 - DDM - Name shortened from NSFloppyTapeAccess to NSFloppyTape. Copyright 1987. Changes for new FloppyTape: add localDrive and use as default for Open, DeviceReady, Writable; use new TYPE VolumeName; add clientWord as return parameter to GetVolumeAttributes.13-Jan-87 13:23:42 - DDM - Add nullVolumeHandle 4-Feb-87 21:55:34 - DDM - Add enumeration for creator environment in Flags. Reformat leader page by defining the TYPE Common for attributes to be shared by SCS and FS per agreement with Heidi and okay by Dave. Change NoDirectory and NoLeaderPage to be SIGNALs rather than ERRORs. 4-Feb-87 15:05:25 - PKM - renamed NSFloppyTape.mesa to AccessFloppyTape.mesaadded File and PageNumber to the USING list of Fileadded ByteCount, ByteOffset, FileID to the USING list of Fileadded the procedures SetAttributes, AppendFromPilotFile, CopyToPilotFile, CopyFromPilotFileadded volumeNotOpen, fileNotFound, nameInUse, invalidParameter to ErrorTypeadded the SIGNALs InconsistentFile, InvalidVersion, NoRoomForClientData13-Feb-87  9:12:31- PKM renamed CopyToPilotFile parameter tapeFile to floppyTapeFilerenamed CopyToPilotFile parameter tapeOffset to firstFloppyTapePage and changed the type from ByteOffset to PageNumber.Changed the type of count parameter in CopyToPilotFile and CopyFromPilotFile from ByteCount to PageCount .Removed nameInUse and volumeNotOpen from ErrorType.Reinstated the procedure ChangeMedia.Removed ByteOffset from FloppyTape Using list.27-Feb-87  9:30:01- PKMAdded the procedure OverWriteFromPilotFile to the interface.Removed FileHandle from Floppy Using list.Removed ByteCount from FloppyTape Using list.Renamed Enumerate to EnumerateFloppyTapeFiles.renamed the parameter count to pageCount in AppendFromPilotFile, CopyFromPilotFile, CopyToPilotFileprocedure call parameter list.Moved all constants and declarations to the beginning of the file.Arranged all procedure definitions in the file in an alphabetical order.7-Mar-87 16:22:27- PKMAdded a comment in the file header cooments saying "file to file copying is available".16-Mar-87 14:46:13- PKMModified the Xerox Copyright notice to standard format, deleted out of date preamble sections25-Mar-87 11:23:15- PKMAdded the parameter "notifyClientOnRetention: PROCEDURE[]" to Open; added the parameter "usedSpace: PageCount" to those returned by GetVolumeAttributes and changed the parameter "rootFile" returned by GetVolumeAttributes from Type FileHandle to Type FileID; deleted errors endOfFile, fileNotFound, insufficientSpace, invalidVolumeHandle, volumeNotOpen, writeInhibited from ErrorType; renamed the procedure EnumerateFloppyTapeFiles to Enumerate; deleted all header comments; added nullFileHandle to the interface; abbreviated names of developers in this log to three initials at RRP's request.    8-May-87 16:04:22  MAT  Added new procedure GetNextFile. added parameter startFrom to Enumerate proc so new startfrom can be set if ERROR is raised21-May-87 11:53:06 - PKM   27-May-87 22:23:23 - DDMChanged  "anyName" to be READONLY of wildcard character, added parameters "drive" and "numberOfBadSectors" to GetVolumeAttributes. Leave "startFrom" parameter in Enumerate (SDD AccessFloppyTape defines it as "fileId: FloppyTape.FileID").12-Jul-87 10:32:36  DDM  Remove some dependencies on Network Services interfaces by locally defining NSFileType.12-Jul-87 10:32:36  DDM  [NS AR 6266] Handle IOError on Open by defining NoDirReason for SIGNAL NoDirectory.21-Jul-87 15:20:26  RSV  Back to standard header.
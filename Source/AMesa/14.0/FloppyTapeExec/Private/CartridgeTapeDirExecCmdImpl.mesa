-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.-- File: CartridgeTapeDirExecCmdImpl.mesa - last edit: 29-Oct-87 16:01:57 RSVDIRECTORY  AccessFloppyTape USING [    DeviceReady, Drive, Error, ErrorType, GetNextDrive, InconsistentFile,    InvalidVersion, leaderPages, NoRoomForClientData],  Ascii USING [CR, SP],  Exec USING [    AddCommand, Confirm, ExecProc, FreeTokenString, GetToken, GetTTY, Handle,    Outcome, OutputProc, ReleaseTTY],  FloppyTape USING [    ByteCount, CloseVolume, Error, ErrorType, FileID, GetVolumeAttributes,    IOError, --localDrive,-- maxBytesInName, OpenVolume, VolumeHandle,    VolumeName],  CartridgeTapeDirectory USING [    Bug, Create, Close, Entry, Error, ErrorType, GetEntry, Handle, Index,    NoLeaderPage, NumberOfEntries, Open, Write],  Format USING [Char, Date, Line, LongNumber, StringProc],  StringLookUp USING [InTable, noMatch],  TTY USING [GetChar, Handle],  Volume USING [InsufficientSpace];CartridgeTapeDirExecCmdImpl: PROGRAM  IMPORTS    AccessFloppyTape, Exec, FloppyTape, CartridgeTapeDirectory, Format,    StringLookUp, TTY, Volume =  BEGIN  v: FloppyTape.VolumeHandle;  localDrive: AccessFloppyTape.Drive;  Abort: ERROR [s: STRING] = CODE;  SetOutcome: SIGNAL [value: Exec.Outcome] = CODE;  Msg: PROCEDURE [key: {notReady, notSupported, loadingDir, noDir, buildDir, done, fID, noLeader, skipped, oldCount, newCount, files, qWriteDir, writeDir, comparing, oldDirBug, newDirBug, dirBug, invalid, oldEntry, copied, inconsistent, period, dirValid, listFID, listType, listBytes, listPages, listCreate, listWrite, invalidSwitch, labelIs, noName, listDir, qQuit, aborted, dash, qSkip, userAbort, notSandA, filesInDir}]  RETURNS [s: STRING] =    BEGIN    s ¬ SELECT key FROM      labelIs => "Cartridge tape is labelled: "L,      noName => "<NoName>"L,      notReady => "Cartridge tape is not ready"L,      notSupported => "  This command is not currently supported."L,      loadingDir => "Loading directory from tape ..."L,      noDir => "No directory on tape."L,      buildDir => "Building new directory ..."L,      done => "\nCartridge tape directory operation complete."L,      fID => " File (ID: "L,      noLeader => ") has no leader page"L,      skipped => " - skipped"L,      oldCount => "Directory on tape contains "L,      newCount => " files; new directory contains "L,      files => " files."L,      qWriteDir => "Do you wish to write the new directory on tape?"L,      writeDir => "Directory written to tape as root file"L,      comparing => "Comparing files ..."L,      oldDirBug => " old directory entry #"L,      newDirBug => " new directory entry #"L,      dirBug => "Directory entry #"L,      invalid => "is invalid"L,      oldEntry => " Old entry "L,      copied => ", copied "L,      inconsistent => " is inconsistent with "L,      period => "."L,      dirValid => "Directory on tape is valid."L,      listFID => " FileID: "L,      listType => " Type: "L,      listBytes => " bytes "L,      listPages => " pages"L,      listCreate => "  create: "L,      listWrite => "  write: "L,      invalidSwitch => " is an invalid switch..."L,      listDir => "Listing directory ..."L,      qQuit => "\nType q to Quit. Type any other key to continue:"L,      aborted => " - aborted"L,      dash => " -"L,      qSkip => " Type space to Skip. Type any other key to abort:"L,      userAbort => "Terminated by user"L,      notSandA => "Use either skip OR abort switch -- not both"L,      filesInDir => " files in the directory."L      ENDCASE => "?"L;    END; -- Msg  -- Allocate empty directory  AllocateDir: PROCEDURE [h: Exec.Handle] =    BEGIN    Write: Format.StringProc = Exec.OutputProc[h];    Format.Line[Write, Msg[notSupported]];    END; -- AllocateDir-- Verify the directory  VerifyDir: PROCEDURE [h: Exec.Handle] =    BEGIN    Write: Format.StringProc = Exec.OutputProc[h];    ready: BOOLEAN ¬ FALSE;    oldDirectory, newDirectory: CartridgeTapeDirectory.Handle;    oldNumber, newNumber: CartridgeTapeDirectory.NumberOfEntries ¬ 0;    oldEntry, newEntry: CartridgeTapeDirectory.Entry;    myFileId: FloppyTape.FileID;    inconsistent: BOOLEAN ¬ FALSE;        BEGIN      ENABLE UNWIND => FloppyTape.CloseVolume [volume: v];      ready ¬ AccessFloppyTape.DeviceReady[localDrive];      IF NOT (ready) THEN ERROR Abort[Msg[notReady]];      v ¬ FloppyTape.OpenVolume[localDrive, FALSE,	! FloppyTape.Error => ERROR Abort[ConvertFloppyTapeError[error]]];      WriteLabel[Write];      Format.Line[Write, Msg[loadingDir]];      [oldDirectory, oldNumber] ¬ CartridgeTapeDirectory.Open[v	!FloppyTape.Error => IF error = fileNotFound THEN {	  Format.Line[Write, Msg[noDir]];	  GOTO exit;}];      BEGIN        ENABLE UNWIND => CartridgeTapeDirectory.Close[oldDirectory];        Format.Line[Write, Msg[buildDir]];        [newDirectory, newNumber] ¬ CartridgeTapeDirectory.Create[          volume: v	  !CartridgeTapeDirectory.NoLeaderPage => {	    Write[Msg[fID]];	    Format.LongNumber[Write, LOOPHOLE[fileId], [10, FALSE, TRUE, 0]];	    Write[Msg[noLeader]];	    Format.Line[Write, Msg[skipped]];	    RESUME[answer:skip];}];	BEGIN	  ENABLE UNWIND => CartridgeTapeDirectory.Close[newDirectory];	  IF oldNumber # newNumber THEN	    BEGIN	    Format.Char[Write, Ascii.CR];	    Write[Msg[oldCount]];	    Format.LongNumber[Write, oldNumber, [10, FALSE, TRUE, 0]];	    Write[Msg[newCount]];	    Format.LongNumber[Write, newNumber, [10, FALSE, TRUE, 0]];	    Format.Line[Write, Msg[files]];	    Write[Msg[qWriteDir]];	    IF Exec.Confirm[h] THEN {	      myFileId ¬ CartridgeTapeDirectory.Write[volume: v, dH: newDirectory];	      Format.Line[Write, Msg[writeDir]];	      GOTO terminated;}	      ELSE GOTO terminated;	    END;	  Format.Line[Write, Msg[comparing]];	  FOR index: CartridgeTapeDirectory.Index IN [0..newNumber) DO	    oldEntry ¬ CartridgeTapeDirectory.GetEntry[	      oldDirectory, index	      ! CartridgeTapeDirectory.Bug => {	        Format.Char[Write, Ascii.CR];	        WriteDirBug[Write, Msg[oldDirBug], index];	        LOOP}].entry;	    newEntry ¬ CartridgeTapeDirectory.GetEntry[	      newDirectory, index	      ! CartridgeTapeDirectory.Bug => {	        inconsistent ¬ TRUE;	        Format.Char[Write, Ascii.CR];		WriteDirBug[Write, Msg[newDirBug], index];	        LOOP}].entry;	    IF oldEntry.common.copied # newEntry.common.copied THEN {	      inconsistent ¬ TRUE;	      Format.Char[Write, Ascii.CR];	      Write[Msg[oldEntry]];	      FOR i: CARDINAL IN [0..oldEntry.common.nameLength) DO	        Format.Char[Write, LOOPHOLE[oldEntry.common.name[i]]]; ENDLOOP;	      Write[Msg[copied]];	      Format.Date[Write, oldEntry.common.copied, full];	      Write[Msg[inconsistent]];	      FOR j: CARDINAL IN [0..newEntry.common.nameLength) DO	        Format.Char[Write, LOOPHOLE[newEntry.common.name[j]]]; ENDLOOP;	      Write[Msg[copied]];	      Format.Date[Write, newEntry.common.copied, full];	      Format.Char[Write, Ascii.CR]}	      ELSE Write[Msg[period]];	    ENDLOOP;	  CartridgeTapeDirectory.Close[oldDirectory];	  Format.Char[Write, Ascii.SP];	  IF ~inconsistent	    THEN Format.Line[Write, Msg[dirValid]]	    ELSE {	      Write[Msg[qWriteDir]];	      IF Exec.Confirm[h] THEN {	        Format.Char[Write, Ascii.SP];	        myFileId ¬ CartridgeTapeDirectory.Write[volume: v, dH: newDirectory];	        Format.Line[Write, Msg[writeDir]]};};	  END;	END;      CartridgeTapeDirectory.Close[newDirectory];      Format.Line[Write, Msg[done]];      EXITS	exit => NULL;	terminated => {	  CartridgeTapeDirectory.Close[oldDirectory];	  CartridgeTapeDirectory.Close[newDirectory]};      END;    FloppyTape.CloseVolume [volume: v];    Format.Char[Write, Ascii.CR];    END;-- List directory  ListDir: PROCEDURE [gSwitches: LONG STRING, h: Exec.Handle] =    BEGIN    Write: Format.StringProc = Exec.OutputProc[h];    arg, switches: LONG STRING ¬ NIL;    ready: BOOLEAN ¬ FALSE;    directory: CartridgeTapeDirectory.Handle;    number: CartridgeTapeDirectory.NumberOfEntries ¬ 0;    myEntry: CartridgeTapeDirectory.Entry;    Item: TYPE = {id, type, length, pages, create, write};    show: PACKED ARRAY Item OF BOOLEAN ¬ ALL[FALSE];    ttyhandle:TTY.Handle ¬ Exec.GetTTY[h];    char: CHARACTER;        ListOne: PROCEDURE =      BEGIN      Write[LOOPHOLE[@myEntry.common.nameLength]];      FOR i: CARDINAL IN [myEntry.common.nameLength..25) DO	Format.Char[Write, Ascii.SP];	ENDLOOP;      IF show[id] THEN {        Write[Msg[listFID]];	Format.LongNumber[Write, LOOPHOLE[myEntry.common.fid], [10, FALSE, TRUE, 0]];        };      IF show[type] THEN {        Write[Msg[listType]];        Format.LongNumber[Write, myEntry.common.type, [10, FALSE, TRUE, 6]];	};      IF show[length] THEN {        Format.LongNumber[Write, myEntry.totalBytes, [10, FALSE, TRUE, 9]];	Write[Msg[listBytes]]};      IF show[pages] THEN {        Format.LongNumber[	  Write,	  myEntry.totalPages + AccessFloppyTape.leaderPages,	  [10, FALSE, TRUE, 6]];	Write[Msg[listPages]]};      IF show[create] THEN {        Write[Msg[listCreate]];        Format.Date[Write, myEntry.common.created, full]};      IF show[write] THEN {        Write[Msg[listWrite]];        Format.Date[Write, myEntry.common.copied, full]};      Format.Char[Write, Ascii.CR];      END; -- ListOne        BEGIN      ENABLE        UNWIND => FloppyTape.CloseVolume [volume: v];            -- select switches      IF gSwitches # NIL THEN        FOR i: CARDINAL IN [0..gSwitches.length) DO          SELECT gSwitches[i] FROM	    'i => show[id] ¬ TRUE;	    't => show[type] ¬ TRUE;	    'l => show[length] ¬ TRUE;	    'p => show[pages] ¬ TRUE;	    'd => show[create] ¬ TRUE;	    'w => show[write] ¬ TRUE;	    'v => show ¬ ALL[TRUE];	    ENDCASE  => {	      Format.Char[Write, gSwitches[i]];	      Format.Line[Write, Msg[invalidSwitch]];};	ENDLOOP;      ready ¬ AccessFloppyTape.DeviceReady[localDrive];      IF NOT (ready) THEN ERROR Abort[Msg[notReady]];      v ¬ FloppyTape.OpenVolume[localDrive, FALSE,        ! FloppyTape.Error => ERROR Abort[ConvertFloppyTapeError[error]]];      -- write header message      WriteLabel[Write];      Format.Line[Write, Msg[listDir]];      [directory, number] ¬ CartridgeTapeDirectory.Open[v        !FloppyTape.Error => IF error = fileNotFound THEN {    	  Format.Line[Write, Msg[noDir]];	  GOTO exit;}];      -- list files      FOR index: CartridgeTapeDirectory.Index IN [0..number) DO        ENABLE UNWIND => {          CartridgeTapeDirectory.Close[directory]; FloppyTape.CloseVolume[v]};        myEntry ¬ CartridgeTapeDirectory.GetEntry[          directory, index	  ! CartridgeTapeDirectory.Bug => {	    WriteDirBug[Write, Msg[dirBug], index];	    LOOP}].entry;        ListOne[];        IF index MOD 20 = 19 THEN {	  Write[Msg[qQuit]];	  [char] ¬ TTY.GetChar[ttyhandle];	  Exec.ReleaseTTY[ttyhandle];	  IF char = 'q OR char = 'Q THEN GOTO quitt;};        REPEAT          quitt => NULL;        ENDLOOP;      CartridgeTapeDirectory.Close[directory];      Format.Line[Write, Msg[done]];      FloppyTape.CloseVolume[v];      EXITS        exit => {	  FloppyTape.CloseVolume [volume: v];	  Format.Char[Write, Ascii.CR];};      END; --enable    END; --List-- Write directory  WriteDir: PROCEDURE [gSwitches: LONG STRING, h: Exec.Handle] =    BEGIN    Write: Format.StringProc = Exec.OutputProc[h];    ready: BOOLEAN ¬ FALSE;    arg, switches: LONG STRING ¬ NIL;    Item: TYPE = {list, skip, abort};    show: PACKED ARRAY Item OF BOOLEAN ¬ ALL[FALSE];    directory: CartridgeTapeDirectory.Handle;    number: CartridgeTapeDirectory.NumberOfEntries ¬ 0;    myFileId: FloppyTape.FileID;    myEntry: CartridgeTapeDirectory.Entry;    ttyhandle:TTY.Handle ¬ Exec.GetTTY[h];    char: CHARACTER;    keyAbort: BOOLEAN ¬ FALSE;        BEGIN      ENABLE        BEGIN        UNWIND => FloppyTape.CloseVolume [volume: v];	CartridgeTapeDirectory.NoLeaderPage => {	  Write[Msg[fID]];	  Format.LongNumber[Write, LOOPHOLE[fileId], [10, FALSE, TRUE, 0]];	  Write[Msg[noLeader]];	  IF show[skip] THEN {	    Format.Line[Write, Msg[skipped]];	    RESUME[answer:skip]};	  IF show[abort] THEN {	    Format.Line[Write, Msg[aborted]];	    keyAbort ¬ TRUE;	    RESUME[answer:abort]}	  ELSE {	    Format.Line[Write, Msg[dash]];	    Write[Msg[qSkip]];	    [char] ¬ TTY.GetChar[ttyhandle];	    Exec.ReleaseTTY[ttyhandle];	    IF char = Ascii.SP THEN {	      Format.Line[Write, Msg[skipped]];	      RESUME[answer: skip]}  	    ELSE {	       Format.Line[Write, Msg[userAbort]];	       keyAbort ¬ TRUE;	       RESUME[answer: abort];	  }}};	END;      -- select switches      IF gSwitches # NIL THEN        FOR i: CARDINAL IN [0..gSwitches.length) DO          SELECT gSwitches[i] FROM	    'l => show[list] ¬ TRUE;	    's => show[skip] ¬ TRUE;	    'a => show[abort] ¬ TRUE;	    ENDCASE  => {	      Format.Char[Write, gSwitches[i]];	      Format.Line[Write, Msg[invalidSwitch]];};	ENDLOOP;      IF show[skip] AND show[abort] THEN	ERROR Abort[Msg[notSandA]];      ready ¬ AccessFloppyTape.DeviceReady[localDrive];      IF NOT (ready) THEN ERROR Abort[Msg[notReady]];      v ¬ FloppyTape.OpenVolume[localDrive, FALSE,        ! FloppyTape.Error => ERROR Abort[ConvertFloppyTapeError[error]]];      -- write header message      WriteLabel[Write];      Format.Line[Write, Msg[buildDir]];      [directory, number] ¬ CartridgeTapeDirectory.Create[volume: v];      IF keyAbort THEN GOTO abort;      BEGIN        ENABLE UNWIND => CartridgeTapeDirectory.Close[dH: directory];        IF show[list] THEN          BEGIN	  Format.Line[Write, Msg[listDir]];	  FOR index: CartridgeTapeDirectory.Index IN [0..number) DO	    Format.Char[Write, Ascii.SP];	    myEntry ¬ CartridgeTapeDirectory.GetEntry[	      directory, index	      ! CartridgeTapeDirectory.Bug => {	        WriteDirBug[Write, Msg[dirBug], index];	        LOOP}].entry;	    Format.Line[Write, LOOPHOLE[@myEntry.common.nameLength]];	    ENDLOOP;	  END;        Format.LongNumber[Write, number, [10, FALSE, TRUE, 0]];        Format.Line[Write, Msg[filesInDir]];        myFileId ¬ CartridgeTapeDirectory.Write[volume: v, dH: directory];        Format.Line[Write, Msg[writeDir]];        FloppyTape.CloseVolume [volume: v];      END;      CartridgeTapeDirectory.Close[dH: directory];      Format.Line[Write, Msg[done]];    EXITS      abort => FloppyTape.CloseVolume [volume: v];    END;    END; -- WriteDir  WriteLabel: PROCEDURE [Write: Format.StringProc] =    BEGIN    volumeName: FloppyTape.VolumeName ¬ [FloppyTape.maxBytesInName];    [] ¬ FloppyTape.GetVolumeAttributes[v, volumeName];    Write[Msg[labelIs]];    Format.Line[Write, IF volumeName # NIL THEN volumeName ELSE Msg[noName]];    END; -- WriteLabel  WriteDirBug: PROCEDURE [    Write: Format.StringProc, s: STRING, index: CartridgeTapeDirectory.Index] =    BEGIN    Write[s];    Format.LongNumber[Write, index, [10, FALSE, TRUE, 4]];    Format.Line[Write, Msg[invalid]];    END; -- WriteDirBug-- Write errors  WriteAccessFloppyTapeError: PROCEDURE [    Write: Format.StringProc, error: AccessFloppyTape.ErrorType] =    BEGIN    Write["AccessFloppyTape.Error["L];    Write[      SELECT error FROM        incompatibleSizes => " Incompatible Sizes"L,        invalidParameter => "Invalid Parameter"L,        invalidPageNumber => " Invalid Page Number"L,        operationNotSupported => "Operation Not Supported"L,        parameterNotSupported => "Parameter Not Supported"L,        procedureNotImplemented => "Procedure Not Implemented"L,        ENDCASE => "?"L];    Format.Char[Write, ']];    END; -- WriteAccessFloppyTapeError      WriteFloppyTapeError: PROCEDURE [    Write: Format.StringProc, error: FloppyTape.ErrorType] =    BEGIN    Write["FloppyTape.Error["L];    Write[ConvertFloppyTapeError[error]];    Format.Char[Write, ']];    END; -- WriteFloppyTapeError      ConvertFloppyTapeError: PROCEDURE [error: FloppyTape.ErrorType]    RETURNS [s: STRING] =    BEGIN    s ¬ SELECT error FROM        badTape => "badTape"L,        badSectors => "badSectors"L,        fileNotFound => "fileNotFound"L,        hardwareError => "hardwareError"L,        invalidByteOffset => "invalidByteOffset"L,        invalidVolumeHandle => "invalidVolumeHandle"L,        insufficientSpace => "insufficientSpace"L,        needsScavenging => "needsScavenging"L,        noSuchDrive => "noSuchDrive"L,        notFormatted => "notFormatted"L,        notReady => "notReady"L,        volumeOpen => "volumeOpen"L,        writeInhibited => "writeInhibited"L,        ENDCASE => "?"L;    END; -- ConvertFloppyTapeError  WriteCartridgeTapeDirectoryError: PROCEDURE [    Write: Format.StringProc, error: CartridgeTapeDirectory.ErrorType] =    BEGIN    Write["CartridgeTapeDirectory.Error["L];    Write[      SELECT error FROM        noFiles => "noFiles"L,        noDirectory => "noDirectory"L,        invalidIndex => "invalidIndex",        insufficientSpace => "insufficientSpace"L,        ENDCASE => "?"L];    Format.Char[Write, ']];    END; -- WriteCartridgeTapeDirectoryError-- print out help information to the Executive  Help: Exec.ExecProc =    BEGIN       Write: Format.StringProc = Exec.OutputProc[h];    Write[      "CartridgeTapeDir.~ AllocateDir <number>  Creates an empty directory file to hold <number> entries.CartridgeTapeDir.~ ListDir/itlpdwv <wildList>  Displays the contents of the directory file; switches show:   i => FileID,   t => type,    l => length in bytes,    p => length in pages,   d => create date,   w => write date,   v => everything.    <wildList> is not currently supported.CartridgeTapeDir.~ WriteDir/lsa  Creates a directory file which matches the current contents of the tape.  Switches show:    l => file listing after creation,   s => skips files without leader pages,   a => aborts when a file without leader page is detected.CartridgeTapeDir.~ VerifyDir  Compares the contents of the directory file with the contents of the tape."L];    END; -- Help-- control procedure  CommandProcessor: Exec.ExecProc =    BEGIN    MyCommands: TYPE = MACHINE DEPENDENT {      allocate(0), list, write, verify, noMatch(StringLookUp.noMatch)};    DefinedOptions: TYPE = MyCommands [allocate..verify];    commandTable: ARRAY DefinedOptions OF LONG STRING ¬ [      allocate: "AllocateDir"L, list: "ListDir"L, write: "WriteDir"L,      verify: "VerifyDir"L];    index: MyCommands;    Write: Format.StringProc = Exec.OutputProc[h];    command, switches: LONG STRING ¬ NIL;       WHILE outcome = normal DO      ENABLE        UNWIND => {          command ¬ Exec.FreeTokenString[command];          switches ¬ Exec.FreeTokenString[switches]};      [command, switches] ¬ Exec.GetToken[h];      IF command = NIL AND switches = NIL THEN EXIT;      BEGIN        ENABLE {          Abort => {Format.Line[Write, s]; GOTO abort};          AccessFloppyTape.Error => {            Write["unexpected "L];            WriteAccessFloppyTapeError[Write, error];            Format.Char[Write, Ascii.CR];            GOTO abort};          AccessFloppyTape.InconsistentFile => {            Format.Line[Write, "AccessFloppyTape.InconsistentFile"L];	    GOTO abort};          AccessFloppyTape.InvalidVersion => {            Format.Line[Write, "AccessFloppyTape.InvalidVersion"L];	    GOTO abort};          AccessFloppyTape.NoRoomForClientData => {            Format.Line[Write, "AccessFloppyTape.NoRoomForClientData"L];	    GOTO abort};          FloppyTape.Error => {	      Write["unexpected "L]; WriteFloppyTapeError[Write, error];	      Format.Char[Write, Ascii.CR]; GOTO abort};          FloppyTape.IOError => {            Format.Line[Write, "IOError"L]; GOTO abort};	  CartridgeTapeDirectory.Error => {	    WriteCartridgeTapeDirectoryError[Write, type];	    GOTO abort};          SetOutcome => {            IF outcome < value THEN outcome ¬ value;	    IF outcome = abort THEN CONTINUE ELSE RESUME};          Volume.InsufficientSpace => {            Format.Line[	      Write, 	      "Insufficient (rigid) disk space to complete that operation"L];	    GOTO abort}          };        index ¬ LOOPHOLE[StringLookUp.InTable[          key: command,          table: DESCRIPTOR[BASE[commandTable], LENGTH[commandTable]]]];        SELECT index FROM          allocate => AllocateDir[h];          list => ListDir[switches, h];          write => WriteDir[switches, h];          verify => VerifyDir[h];          ENDCASE => {Write["Unknown command"L]; GOTO abort};        EXITS          abort => outcome ¬ abort;        END;      command ¬ Exec.FreeTokenString[command];      switches ¬ Exec.FreeTokenString[switches];      ENDLOOP;    END; -- CommandProcessor  --Begin ServicesDirectory  Exec.AddCommand["CartridgeTapeDir.~"L, CommandProcessor, Help];  localDrive ¬ AccessFloppyTape.GetNextDrive[];  END.    LOG25-Mar-87 18:23:49   Schmelz   CreatedFile, based on FloppyTapeExec.mesa.26-Mar-87 19:55:35   Schmelz   WriteDir added.27-Mar-87 18:53:07   Schmelz   VerifyDir added.31-Mar-87 19:41:26   Schmelz   Layout of messages streamlined, VerifyDir closes volume, Error NoLeaderPage from FloppyTapeDirectory.Create leads to abort if user "key-aborts". 5-May-87 15:35:39   Thatcher   Changed registered command to TapeDirectory from ServicesDirectory. 7-May-87  8:01:10   Thatcher19-May-87 17:05:42   Muirhead   Changed name from TapeDirectoryImpl to CartridgeTapeDirExecCmdImpl. Changed command name from "TapeDirectory.~" to "CartridgeTapeDir.~".29-May-87 14:52:50   Muirhead   Re-work messages for consistency.14-Jul-87 13:44:52   Muirhead29-Oct-87 16:01:57   RSV        off of drive 0.
-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.-- AccessFloppyTapeImpl.mesa          29-Oct-87 12:32:28 by JAC/RSVDIRECTORY  AccessFloppyTape USING [    anyType, Access, Attributes, AttributesRecord, ByteCount, ClientWord,    currentAttributeVersion, Drive, EnumProc, Error, ErrorType, FileHandle,    fileTypeForLeaderPage, FileTypes, Label, leaderPages, --localDrive,--    maxClientDataWords, maxNameLength, NameOrPattern, NoDirReason,    NoRoomForClientData, nullDrive, PageCount, PageNumber, sealValue,    VolumeHandle, VMBuffer],  CartridgeTapeDirectory USING [    Close, Entry, Error, GetEntry, Handle, nullHandle, NumberOfEntries, Open],  Environment USING [bytesPerPage],  File USING [File, GetSize, nullFile, PageNumber, Type],  FloppyChannel USING [     Context, Error, GetContext, GetDeviceAttributes, GetHandle, Handle],  FloppyTape USING [    AppendFile, ByteCount, ByteOffset, CloseVolume, Drive, Error, ErrorType,    FileID, GetFileAttributes, GetNextFile, GetVolumeAttributes, IOError,    NotifyClientProc, nullFileID, nullVolumeHandle, OpenVolume, ReadFile,    RewriteFile, ScatteredVM, ScatteredVMSeq, VMBuffer, WriteFile],  FloppyTapeExtras USING [GetNextFloppyTapeDrive],  Heap USING [systemZone],  Inline USING [LongCOPY],  NSString USING [    Character, Characters, ExpandString, FreeCharacters, LowerCase, nullString,    String, StringFromMesaString, ValidAsMesaString],  Space USING [    CopyIn, CopyOut, Error, InsufficientSpace, Interval, nullInterval, Kill, Map,    PageCount, ScratchMap, SwapUnitOption, SwapUnitSize, Unmap],  System USING [isUtilityPilot];AccessFloppyTapeImpl: PROGRAM  IMPORTS    AccessFloppyTape, CartridgeTapeDirectory, File, FloppyChannel, FloppyTape,    FloppyTapeExtras, Heap, Inline, NSString, Space, System  EXPORTS AccessFloppyTape =  BEGIN  -- Signals and errors  NoDirectory: PUBLIC SIGNAL [reason: AccessFloppyTape.NoDirReason] = CODE;  NoLeaderPage: PUBLIC SIGNAL [file: FloppyTape.FileID] = CODE;  Error: PUBLIC ERROR [error: AccessFloppyTape.ErrorType] = CODE;  InconsistentFile: PUBLIC SIGNAL [file: AccessFloppyTape.FileHandle] = CODE;  InvalidVersion: PUBLIC SIGNAL [    file: AccessFloppyTape.FileHandle, version: CARDINAL] = CODE;  NoRoomForClientData: PUBLIC ERROR [wordsNeeded: CARDINAL] = CODE;  -- Variables and Constants    z: UNCOUNTED ZONE ¬ Heap.systemZone;  directory: CartridgeTapeDirectory.Handle ¬ CartridgeTapeDirectory.nullHandle;  numberOfFiles: CartridgeTapeDirectory.NumberOfEntries ¬ 0;  --these are magic numbers that work for the floppytape    nullFileHandle: PUBLIC AccessFloppyTape.FileHandle ¬ [    FloppyTape.nullVolumeHandle, FloppyTape.nullFileID];  wildCardChar: LONG STRING ¬ "*";  anyName: PUBLIC AccessFloppyTape.NameOrPattern ¬ NSString.StringFromMesaString[wildCardChar];  MaxBufferSize: Space.PageCount ¬ IF System.isUtilityPilot THEN 16 ELSE 100;  UniformSwapUnitSize: Space.SwapUnitSize = 2;  Append: PUBLIC PROCEDURE [    file: AccessFloppyTape.FileHandle, buffer: AccessFloppyTape.VMBuffer,    endOfFile: BOOLEAN] =    BEGIN    scatteredVMPtr: FloppyTape.ScatteredVM ¬ z.NEW[FloppyTape .ScatteredVMSeq[1]];        scatteredVMPtr[0].vm ¬ buffer.vm;    scatteredVMPtr[0].count ¬ buffer.count * Environment.bytesPerPage;    BEGIN      ENABLE UNWIND => z.FREE[@scatteredVMPtr];      FloppyTape.AppendFile[	file: file, scatteredVM: scatteredVMPtr, updateEndOfFile: endOfFile];      z.FREE[@scatteredVMPtr];    END; -- enable    END; -- Append  AppendFromPilotFile: PUBLIC PROCEDURE [    pilotFile: File.File, tapeFile: AccessFloppyTape.FileHandle,    firstPilotPage: File.PageNumber, pageCount: AccessFloppyTape.PageCount,    updateEndOfFile: BOOLEAN] =    BEGIN    -- allocate scatteredVMPtr record.       scatteredVMPtr: FloppyTape.ScatteredVM ¬ z.NEW[FloppyTape .ScatteredVMSeq[1]];    buffer: Space.Interval ¬ Space.nullInterval;    pilotFileSize: AccessFloppyTape.PageCount;    pagesCopied: AccessFloppyTape.PageCount;    count, bytesCopied: FloppyTape.ByteCount;        pilotFileSize ¬ File.GetSize[pilotFile];    BEGIN      ENABLE	UNWIND => {	  buffer.pointer ¬ Space.Unmap[buffer.pointer ! Space.Error => CONTINUE];	  z.FREE[@scatteredVMPtr];	  };        IF (firstPilotPage >= pilotFileSize) THEN	ERROR AccessFloppyTape.Error[invalidPageNumber];      count ¬ pageCount * Environment.bytesPerPage;      IF (pageCount > pilotFileSize - firstPilotPage) THEN	ERROR AccessFloppyTape.Error[incompatibleSizes];      buffer ¬ CreateBuffer[MIN[pageCount, MaxBufferSize]];      IF buffer.count = 0 THEN ERROR;  -- insufficient VM to operate      FOR filePageNumber: File.PageNumber ¬ 0,	filePageNumber + CARDINAL[buffer.count] WHILE count > 0 DO	Space.Kill[buffer];	pagesCopied ¬ Space.CopyIn[	  buffer.pointer, [	  pilotFile, firstPilotPage + filePageNumber, buffer.count]];	bytesCopied ¬ pagesCopied * Environment.bytesPerPage;	IF bytesCopied > count THEN bytesCopied ¬ count;	scatteredVMPtr[0] ¬ [count: bytesCopied, vm: buffer.pointer];	FloppyTape.AppendFile[	  file: tapeFile, scatteredVM: scatteredVMPtr,	  updateEndOfFile: IF count = bytesCopied THEN updateEndOfFile ELSE FALSE];	count ¬ count - bytesCopied;      -- This case should never happen, but provided for robustness of code.      IF bytesCopied = 0 THEN EXIT;      ENDLOOP;    END; -- enable    buffer.pointer ¬ Space.Unmap[buffer.pointer ! Space.Error => CONTINUE];    z.FREE[@scatteredVMPtr];    END; -- AppendFromPilotFile  ChangeMedia: PUBLIC PROCEDURE [    volume: AccessFloppyTape.VolumeHandle, writable: BOOLEAN]    RETURNS [newVolume: AccessFloppyTape.VolumeHandle] =    BEGIN     AccessFloppyTape.Error[procedureNotImplemented];    END; -- ChangeMedia  Close: PUBLIC PROCEDURE [volume: AccessFloppyTape.VolumeHandle] =    -- Call before floppytape is removed from the drive.    BEGIN      IF directory # CartridgeTapeDirectory.nullHandle        THEN CartridgeTapeDirectory.Close[directory];      FloppyTape.CloseVolume[volume];      directory ¬ CartridgeTapeDirectory.nullHandle; numberOfFiles ¬ 0;    END;  -- Close.  CopyFromPilotFile: PUBLIC PROCEDURE [    pilotFile: File.File, volume: AccessFloppyTape.VolumeHandle,    firstPilotPage: File.PageNumber, pageCount: AccessFloppyTape.PageCount,    type: File.Type, attributes: AccessFloppyTape.Attributes]    RETURNS [tapeFileId: FloppyTape.FileID] =    BEGIN    buffer: Space.Interval ¬ Space.nullInterval;    pagesCopied: AccessFloppyTape.PageCount;    count, bytesCopied: FloppyTape.ByteCount;    firstPass: BOOLEAN;    -- allocate scatteredVMPtr record.    scatteredVMPtr: FloppyTape.ScatteredVM ¬ z.NEW[FloppyTape .ScatteredVMSeq[2]];    pilotFileSize: AccessFloppyTape.PageCount;    scratchPtr: LONG POINTER ¬ Space.ScratchMap[      count: AccessFloppyTape.leaderPages];    BEGIN    ENABLE      UNWIND => {        buffer.pointer ¬ Space.Unmap[buffer.pointer ! Space.Error => CONTINUE];        scratchPtr ¬ Space.Unmap[scratchPtr ! Space.Error => CONTINUE];        z.FREE[@scatteredVMPtr];        };    PageAlignAttributes[to: scratchPtr, from: attributes];    scatteredVMPtr[0] ¬ [      count: AccessFloppyTape.leaderPages * Environment.bytesPerPage,      vm: scratchPtr];    pilotFileSize ¬ File.GetSize[pilotFile];    IF (firstPilotPage >= pilotFileSize) THEN      ERROR AccessFloppyTape.Error[invalidPageNumber];    count ¬ pageCount * Environment.bytesPerPage;    IF pageCount > (pilotFileSize - firstPilotPage) THEN      ERROR AccessFloppyTape.Error[incompatibleSizes];    buffer ¬ CreateBuffer[MIN[pageCount, MaxBufferSize]];    IF buffer.count = 0 THEN ERROR;  -- insufficient VM to operate    firstPass ¬ TRUE;    FOR filePageNumber: File.PageNumber ¬ 0,      filePageNumber + CARDINAL[buffer.count] WHILE count > 0 DO      Space.Kill[buffer];      pagesCopied ¬ Space.CopyIn[        buffer.pointer, [        pilotFile, firstPilotPage + filePageNumber, buffer.count]];      bytesCopied ¬ pagesCopied * Environment.bytesPerPage;      IF bytesCopied > count THEN bytesCopied ¬ count;      scatteredVMPtr[1] ¬ [count: bytesCopied, vm: buffer.pointer];      IF firstPass THEN        BEGIN        [tapeFileId] ¬ FloppyTape.WriteFile[volume, type, scatteredVMPtr];        firstPass ¬ FALSE;        scatteredVMPtr[0] ¬ [count: 0, vm: NIL];        END      ELSE        BEGIN        IF (count = bytesCopied) THEN          FloppyTape.AppendFile[            [volume: volume, file: tapeFileId], scatteredVMPtr, TRUE]        ELSE          FloppyTape.AppendFile[            [volume: volume, file: tapeFileId], scatteredVMPtr, FALSE];        END;      count ¬ count - bytesCopied;      -- This case should never happen, but provided for robustness of code.      IF bytesCopied = 0 THEN EXIT;      ENDLOOP;    z.FREE[@scatteredVMPtr];    scratchPtr ¬ Space.Unmap[scratchPtr ! Space.Error => CONTINUE];    buffer.pointer ¬ Space.Unmap[buffer.pointer ! Space.Error => CONTINUE];    END; -- enable    END; -- CopyFromPilotFile  CopyToPilotFile: PUBLIC PROCEDURE [    floppyTapeFile: AccessFloppyTape.FileHandle, pilotFile: File.File,    firstFloppyTapePage: AccessFloppyTape.PageNumber,    firstPilotPage: File.PageNumber, pageCount: AccessFloppyTape.PageCount,    attributes: AccessFloppyTape.Attributes] =    BEGIN    scatteredVMPtr: FloppyTape.ScatteredVM ¬ z.NEW[FloppyTape .ScatteredVMSeq[2]];    leaderPagePointer: AccessFloppyTape.Attributes;    scratchPtr: LONG POINTER ¬ Space.ScratchMap[      count: AccessFloppyTape.leaderPages];    buffer: Space.Interval ¬ Space.nullInterval;    pilotFileSize: AccessFloppyTape.PageCount;    floppyTapeFileSize: AccessFloppyTape.PageCount;    byteOffset: FloppyTape.ByteOffset;    count, bytesToCopy: FloppyTape.ByteCount;    BEGIN    ENABLE      UNWIND => {        buffer.pointer ¬ Space.Unmap[buffer.pointer ! Space.Error => CONTINUE];        scratchPtr ¬ Space.Unmap[scratchPtr ! Space.Error => CONTINUE];        z.FREE[@scatteredVMPtr];        };    floppyTapeFileSize ¬ attributes.totalPages;    pilotFileSize ¬ File.GetSize[pilotFile];    IF (firstFloppyTapePage > floppyTapeFileSize)      OR (firstPilotPage >= pilotFileSize) THEN      ERROR AccessFloppyTape.Error[invalidPageNumber];    count ¬ pageCount * Environment.bytesPerPage;    IF (pageCount > pilotFileSize - firstPilotPage) THEN      ERROR AccessFloppyTape.Error[incompatibleSizes];    buffer ¬ CreateBuffer[MIN[pageCount, MaxBufferSize]];    IF buffer.count = 0 THEN ERROR;  -- insufficient VM to operate    byteOffset ¬ 0;    scatteredVMPtr[0] ¬ [      count: AccessFloppyTape.leaderPages * Environment.bytesPerPage,      vm: scratchPtr];    leaderPagePointer ¬ LOOPHOLE[scratchPtr];    FOR filePageNumber: AccessFloppyTape.PageCount ¬ 0,      filePageNumber + CARDINAL[buffer.count] WHILE count > 0 DO      pagesToCopy: CARDINAL = MIN[        CARDINAL[buffer.count], CARDINAL[pageCount - filePageNumber]];      bytesToCopy ¬ pagesToCopy * Environment.bytesPerPage;      IF bytesToCopy > count THEN bytesToCopy ¬ count;      Space.Kill[buffer];      scatteredVMPtr[1] ¬ [count: bytesToCopy, vm: buffer.pointer];      FloppyTape.ReadFile[        file: floppyTapeFile, first: byteOffset, scatteredVM: scatteredVMPtr];      [] ¬ Space.CopyOut[        buffer.pointer, [pilotFile, firstPilotPage + filePageNumber, pagesToCopy]];      IF scatteredVMPtr[0].count # 0 THEN        BEGIN        ptrToMaxlength: LONG POINTER ¬ LOOPHOLE[@leaderPagePointer.maxlength];        byteOffset ¬          byteOffset + AccessFloppyTape.leaderPages * Environment.bytesPerPage;        IF leaderPagePointer.clientDataLength > attributes.maxlength THEN          AccessFloppyTape.NoRoomForClientData[            leaderPagePointer.clientDataLength - attributes.maxlength];        -- Before copying, move the original value of maxlength in attributes record to maxlength field  pointed to by leaderPagePointer.            ptrToMaxlength­ ¬ attributes.maxlength;        PageAlignAttributes[to: attributes, from: leaderPagePointer];        scatteredVMPtr[0] ¬ [count: 0, vm: NIL];        END;      count ¬ count - bytesToCopy;      byteOffset ¬ byteOffset + bytesToCopy      ENDLOOP;    scratchPtr ¬ Space.Unmap[scratchPtr ! Space.Error => CONTINUE];    z.FREE[@scatteredVMPtr];    buffer.pointer ¬ Space.Unmap[buffer.pointer ! Space.Error => CONTINUE];    END; -- enable    END; -- CopyToPilotFile  CreateBuffer: PROCEDURE [size: Space.PageCount]    RETURNS [buffer: Space.Interval] =    BEGIN    uniformSize: Space.SwapUnitOption ¬ [uniform[UniformSwapUnitSize]];    buffer ¬ Space.nullInterval;    IF size = 0 THEN RETURN;    buffer ¬ Space.Map[      window: [File.nullFile, 0, size], swapUnits: uniformSize !      Space.InsufficientSpace => IF (size ¬ size - 1) > 0 THEN RETRY;      Space.Error => CONTINUE];    END; -- CreateBuffer  DeviceReady: PUBLIC PROCEDURE [drive: AccessFloppyTape.Drive]    RETURNS [ready: BOOLEAN] =    << Accelerator for xxx[ready] >>    BEGIN    handle: FloppyChannel.Handle ¬ FloppyChannel.GetHandle[      drive: drive ! FloppyChannel.Error => FloppyTape.Error[noSuchDrive]];    ready ¬ FloppyChannel.GetDeviceAttributes[      handle: handle !      FloppyChannel.Error => FloppyTape.Error[invalidVolumeHandle]].ready;    END; -- DeviceReady  -- File operation    Enumerate: PUBLIC PROCEDURE [    volume: AccessFloppyTape.VolumeHandle,    names: AccessFloppyTape.NameOrPattern,    types: AccessFloppyTape.FileTypes,    startFrom: AccessFloppyTape.FileHandle,    proc: AccessFloppyTape.EnumProc] =    BEGIN    nullFile: AccessFloppyTape.FileHandle = [      volume: volume, file: FloppyTape.nullFileID];    current: AccessFloppyTape.FileHandle;    attributes: AccessFloppyTape.Attributes;    matched: BOOLEAN;    Match: PROCEDURE [      string: NSString.String, stringIndex: CARDINAL ¬ 0, pattern: NSString.String,      patternIndex: CARDINAL ¬ 0] RETURNS [outcome: BOOLEAN] =      BEGIN      << Code stolen from ContainedFileDImpl of the FileService code. >>      wildString: NSString.Character = [0, 52B];  -- '* , the asterisk;      wildChar: NSString.Character = [0, 43B];  -- '# , the pound sign;      stringChars, patternChars: NSString.Characters;      MatchInternal: PROC [        string: NSString.Characters, stringIndex: CARDINAL ¬ 0,        pattern: NSString.Characters, patternIndex: CARDINAL ¬ 0]        RETURNS [outcome: BOOLEAN] =        BEGIN        -- local variables        i, j, k: CARDINAL;        -- process each character in pattern        FOR i IN [patternIndex..LENGTH[pattern]) DO          SELECT pattern[i] FROM            wildString =>              BEGIN  -- matches any string of zero or more characters              FOR k IN [(i + 1)..LENGTH[pattern]) WHILE pattern[k] = wildString DO                i ¬ i + 1;  -- skip duplicate wildString patterns                ENDLOOP;              FOR j IN [stringIndex..LENGTH[string]] DO                IF MatchInternal[string, j, pattern, i + 1].outcome THEN                  RETURN[TRUE];                ENDLOOP;              RETURN[FALSE];              END;            wildChar =>  -- matches any single character              IF stringIndex = LENGTH[string] THEN RETURN[FALSE]              ELSE stringIndex ¬ stringIndex + 1;            ENDCASE => {  -- temp chars              IF stringIndex = LENGTH[string]                OR NSString.LowerCase[string[stringIndex]] # NSString.LowerCase[                  pattern[i]] THEN RETURN[FALSE]              ELSE stringIndex ¬ stringIndex + 1};          ENDLOOP;        -- string passes pattern if entire string has been consumed        outcome ¬ stringIndex = LENGTH[string];        END;  -- of MatchInternal      stringChars ¬ NSString.ExpandString[z, string];      patternChars ¬ NSString.ExpandString[z, pattern];      outcome ¬ MatchInternal[        stringChars, stringIndex, patternChars, patternIndex];      NSString.FreeCharacters[z, stringChars];      NSString.FreeCharacters[z, patternChars];      END;  -- of Match          CheckTypeAndName: PROC RETURNS [match: BOOLEAN ¬ FALSE] =       BEGIN      nsname: AccessFloppyTape.NameOrPattern;            IF types = AccessFloppyTape.anyType THEN match ¬ TRUE      ELSE {	FOR index: CARDINAL IN [0..types.LENGTH - 1] WHILE NOT (matched) DO	  IF types[index] = attributes.common.type THEN match ¬ TRUE;	ENDLOOP};      IF match THEN {	nsname ¬ NSString.StringFromMesaString[	  LOOPHOLE[@attributes.common.nameLength]];	match ¬ Match[	  string: nsname, stringIndex: 0, pattern: names, patternIndex: 0];	};      END;--CheckTypeAndName        --begin Enumerate      IF names = NSString.nullString THEN RETURN;    IF NOT NSString.ValidAsMesaString[names] THEN      AccessFloppyTape.Error[invalidParameter];    IF directory # CartridgeTapeDirectory.nullHandle THEN {      last: CARDINAL;      fileID: FloppyTape.FileID;      IF startFrom.file = FloppyTape.nullFileID THEN        last ¬ 0      ELSE        FOR last IN [0..numberOfFiles) DO          IF startFrom.file = 	    CartridgeTapeDirectory.GetEntry[directory, last].fileId	    THEN { last ¬ last+1--GetNextFile[].nextFile--; EXIT };        REPEAT	FINISHED => ERROR FloppyTape.Error[fileNotFound];        ENDLOOP;      FOR last IN [last..numberOfFiles) DO	[attributes, fileID] ¬ CartridgeTapeDirectory.GetEntry[directory, last];	matched ¬ CheckTypeAndName[];	IF matched AND NOT (proc[[volume, fileID], attributes]) THEN EXIT;      ENDLOOP;      }    ELSE {      attributes ¬ z.NEW[AccessFloppyTape.AttributesRecord[	AccessFloppyTape.maxClientDataWords]];      startFrom.volume ¬ volume;  -- in case startfrom = nullFileHandle      FOR current ¬ FloppyTape.GetNextFile[startFrom].nextFile,	FloppyTape.GetNextFile[current].nextFile        WHILE current # nullFile DO	ENABLE UNWIND => Heap.systemZone.FREE[@attributes];	IF FloppyTape.GetFileAttributes[current].type #	  AccessFloppyTape.fileTypeForLeaderPage THEN {	  SIGNAL NoLeaderPage[current.file]; LOOP};	GetAttributes[current, attributes];	matched ¬ CheckTypeAndName[];	IF matched AND NOT (proc[current, attributes]) THEN EXIT;	ENDLOOP;      Heap.systemZone.FREE[@attributes];      };    END; -- Enumerate  GetAttributes: PUBLIC PROCEDURE [    file: AccessFloppyTape.FileHandle, attributes: AccessFloppyTape.Attributes] =    BEGIN    size: AccessFloppyTape.PageCount;    type: File.Type;    IF attributes = NIL THEN ERROR AccessFloppyTape.Error[invalidParameter];    IF directory # CartridgeTapeDirectory.nullHandle THEN {      entry: AccessFloppyTape.Attributes;      fileID: FloppyTape.FileID;      FOR i: CARDINAL IN [0..numberOfFiles) DO        [entry, fileID] ¬ CartridgeTapeDirectory.GetEntry[directory, i];	IF fileID = file.file THEN EXIT;      ENDLOOP;      PageAlignAttributes[to: attributes, from: entry];      }    ELSE {      [size, type] ¬ FloppyTape.GetFileAttributes[file];      IF type # AccessFloppyTape.fileTypeForLeaderPage THEN	SIGNAL NoLeaderPage[file.file]      ELSE ReadLeaderPage[file, attributes ! UNWIND => NULL];      };    END;  -- GetAttributes.  GetNextDrive: PUBLIC PROCEDURE [    drive: AccessFloppyTape.Drive ¬ AccessFloppyTape.nullDrive]    RETURNS [next: AccessFloppyTape.Drive] =    << Enumeration of all drives attatched     starts with drive = nullDrive     and terminates when next = nullDrive.     Horizon Phase I will return one and only one cartridge tape device >>    <<assume only one floppy tape drive.  JAC>>    BEGIN    next ¬  FloppyTapeExtras.GetNextFloppyTapeDrive[drive];    <<IF drive = AccessFloppyTape.nullDrive THEN RETURN[AccessFloppyTape.localDrive]    ELSE RETURN[AccessFloppyTape.nullDrive];>>    END; -- GetNextDrive  GetNextFile: PUBLIC PROCEDURE [file: AccessFloppyTape.FileHandle]    RETURNS [next: AccessFloppyTape.FileHandle] =    BEGIN      ENABLE UNWIND => NULL;      IF directory # CartridgeTapeDirectory.nullHandle THEN         SELECT TRUE FROM	  file.file = FloppyTape.nullFileID => 	    next ¬ [volume: file.volume,	      file: CartridgeTapeDirectory.GetEntry[directory, 0].fileId];	  file.file = CartridgeTapeDirectory.GetEntry[	    directory, numberOfFiles-1].fileId => 	    next ¬ [volume: file.volume, file: FloppyTape.nullFileID];	  ENDCASE => {	     FOR last: CARDINAL IN [0..numberOfFiles-1) DO 	      IF CartridgeTapeDirectory.GetEntry[directory, last].fileId = file.file	      THEN RETURN [next ¬ [volume:file.volume, 		file: CartridgeTapeDirectory.GetEntry[directory, last+1].fileId]];	    ENDLOOP;	    ERROR Error[fileNotFound];	   }      ELSE {        next ¬ FloppyTape.GetNextFile[file];        IF next.file = FloppyTape.nullFileID OR	  FloppyTape.GetFileAttributes[next].type = 	  AccessFloppyTape.fileTypeForLeaderPage        THEN NULL        ELSE SIGNAL NoLeaderPage[next.file];	};    END; -- GetNextFile    GetVolumeAttributes: PUBLIC PROCEDURE [    volume: AccessFloppyTape.VolumeHandle, label: AccessFloppyTape.Label]    RETURNS [      freeSpace: AccessFloppyTape.ByteCount, usedSpace: AccessFloppyTape.ByteCount,      rootFile: FloppyTape.FileID, clientWord: AccessFloppyTape.ClientWord,      drive: AccessFloppyTape.Drive, numberOfBadSectors: CARDINAL] =    BEGIN    -- GetVolumeAttributes does not handle FloppyTape.Error[ volumeNotOpen ] and it just     -- passes it up.    ENABLE UNWIND => NULL;    [freeSpace, usedSpace, rootFile, clientWord, drive, numberOfBadSectors] ¬       FloppyTape.GetVolumeAttributes[volume: volume, name: label];        END; -- GetVolumeAttributes  Open: PUBLIC PROCEDURE [    drive: AccessFloppyTape.Drive, readOnly: BOOLEAN ¬ TRUE,    access: AccessFloppyTape.Access,    notifyClientOnRetention: FloppyTape.NotifyClientProc]    RETURNS [volume: AccessFloppyTape.VolumeHandle] =    -- Call FloppyTape.Open, remember VolumeHandle of active floppytape.    BEGIN    ENABLE UNWIND => NULL;    IF access # exclusive THEN AccessFloppyTape.Error[parameterNotSupported];    volume ¬ FloppyTape.OpenVolume[      drive: drive, readOnly: readOnly,      notifyClientOnRetention: notifyClientOnRetention];    [directory, numberOfFiles] ¬ CartridgeTapeDirectory.Open[volume !      CartridgeTapeDirectory.Error =>        IF type = noDirectory THEN {	  directory ¬ CartridgeTapeDirectory.nullHandle;	  SIGNAL NoDirectory[reason: notPresent]; CONTINUE;};      FloppyTape.IOError =>        { directory ¬ CartridgeTapeDirectory.nullHandle;	  SIGNAL NoDirectory[reason: ioError]; CONTINUE;}];    END;  -- Open.  OverWriteFromPilotFile: PUBLIC PROCEDURE [    pilotFile: File.File, tapefile: AccessFloppyTape.FileHandle,    firstPilotPage: File.PageNumber, pageCount: AccessFloppyTape.PageCount,    attributes: AccessFloppyTape.Attributes] =    BEGIN    buffer: Space.Interval ¬ Space.nullInterval;    pagesCopied: AccessFloppyTape.PageCount;    count, bytesCopied: FloppyTape.ByteCount;    scratchPtr: LONG POINTER ¬ Space.ScratchMap[      count: AccessFloppyTape.leaderPages];    -- allocate scatteredVMPtr record.    scatteredVMPtr: FloppyTape.ScatteredVM ¬ z.NEW[FloppyTape .ScatteredVMSeq[2]];    pilotFileSize: AccessFloppyTape.PageCount;    byteOffset: FloppyTape.ByteOffset;    BEGIN    ENABLE      UNWIND => {        buffer.pointer ¬ Space.Unmap[buffer.pointer ! Space.Error => CONTINUE];        z.FREE[@scatteredVMPtr];        scratchPtr ¬ Space.Unmap[scratchPtr ! Space.Error => CONTINUE];        };    PageAlignAttributes[to: scratchPtr, from: attributes];    scatteredVMPtr[0] ¬ [      count: AccessFloppyTape.leaderPages * Environment.bytesPerPage,      vm: scratchPtr];    pilotFileSize ¬ File.GetSize[pilotFile];    IF (firstPilotPage >= pilotFileSize) THEN      ERROR AccessFloppyTape.Error[invalidPageNumber];    count ¬ pageCount * Environment.bytesPerPage;    IF pageCount > (pilotFileSize - firstPilotPage) THEN      ERROR AccessFloppyTape.Error[incompatibleSizes];    buffer ¬ CreateBuffer[MIN[pageCount, MaxBufferSize]];    IF buffer.count = 0 THEN ERROR;  -- insufficient VM to operate    byteOffset ¬ 0;    FOR filePageNumber: File.PageNumber ¬ 0,      filePageNumber + CARDINAL[buffer.count] WHILE count > 0 DO      Space.Kill[buffer];      pagesCopied ¬ Space.CopyIn[        buffer.pointer, [        pilotFile, firstPilotPage + filePageNumber, buffer.count]];      bytesCopied ¬ pagesCopied * Environment.bytesPerPage;      IF bytesCopied > count THEN bytesCopied ¬ count;      scatteredVMPtr[1] ¬ [count: bytesCopied, vm: buffer.pointer];      FloppyTape.RewriteFile[tapefile, byteOffset, scatteredVMPtr];      IF scatteredVMPtr[0].count # 0 THEN        BEGIN        scatteredVMPtr[0] ¬ [count: 0, vm: NIL];        byteOffset ¬          byteOffset + AccessFloppyTape.leaderPages * Environment.bytesPerPage;        END;      byteOffset ¬ byteOffset + bytesCopied;      count ¬ count - bytesCopied;      -- This case should never happen, but provided for robustness of code.      IF bytesCopied = 0 THEN EXIT;           ENDLOOP;    scratchPtr ¬ Space.Unmap[scratchPtr ! Space.Error => CONTINUE];    z.FREE[@scatteredVMPtr];    buffer.pointer ¬ Space.Unmap[buffer.pointer ! Space.Error => CONTINUE];    END; -- enable    END; -- OverWriteFromPilotFile  PageAlignAttributes: PROC [    from, to: LONG POINTER TO AccessFloppyTape.AttributesRecord] =    BEGIN    length: CARDINAL ¬ SIZE[      AccessFloppyTape.AttributesRecord[0]] + from.clientDataLength;    [] ¬ Inline.LongCOPY[to: to, nwords: length, from: from];    END; -- PageAlignAttributes  Read: PUBLIC PROCEDURE [    file: AccessFloppyTape.FileHandle, first: File.PageNumber,    buffer: AccessFloppyTape.VMBuffer]    RETURNS [transferred: AccessFloppyTape.PageCount, endOfFile: BOOLEAN] =    << If this procedure returns with transferred=0 and endOfFile=FALSE,        a media change is indicated. >>    -- Setting first = 0, starts reading with leader page    BEGIN    scatteredVMPtr: FloppyTape.ScatteredVM ¬ z.NEW[FloppyTape .ScatteredVMSeq[1]];    floppyTapeFileSize: AccessFloppyTape.PageCount;    byteOffset: FloppyTape.ByteOffset;    size: FloppyTape.ByteCount;    type: File.Type;    maxBytesCopied, bytesCopied: FloppyTape.ByteCount;        endOfFile ¬ FALSE;    [size: size, type: type] ¬ FloppyTape.GetFileAttributes[file];    floppyTapeFileSize ¬      (size + Environment.bytesPerPage - 1) / Environment.bytesPerPage;    IF first > floppyTapeFileSize THEN      ERROR AccessFloppyTape.Error[invalidParameter];    byteOffset ¬ first * Environment.bytesPerPage;    scatteredVMPtr[0].vm ¬ buffer.vm;    scatteredVMPtr[0].count ¬ buffer.count * Environment.bytesPerPage;    FloppyTape.ReadFile[      file: file, first: byteOffset, scatteredVM: scatteredVMPtr !      UNWIND => {z.FREE[@scatteredVMPtr]; }];    maxBytesCopied ¬ size - byteOffset;    IF maxBytesCopied <= buffer.count * Environment.bytesPerPage THEN      BEGIN      endOfFile ¬ TRUE;      bytesCopied ¬ maxBytesCopied;      transferred ¬        (bytesCopied + Environment.bytesPerPage - 1) / Environment.bytesPerPage;      END    ELSE transferred ¬ buffer.count;    z.FREE[@scatteredVMPtr];    RETURN[transferred, endOfFile];    END; -- Read  ReadLeaderPage: PROC [    file: AccessFloppyTape.FileHandle, attributes: AccessFloppyTape.Attributes] =    BEGIN    -- make the buffer for the AttributesRecord in full pages.      scratchPtr: LONG POINTER ¬ Space.ScratchMap[      count: AccessFloppyTape.leaderPages];    leaderPagePointer: LONG POINTER TO AccessFloppyTape.AttributesRecord ¬      LOOPHOLE[scratchPtr];    scatteredVMPtr: FloppyTape.ScatteredVM ¬ z.NEW[FloppyTape .ScatteredVMSeq[1]];    ptrToMaxlength: LONG POINTER ¬ LOOPHOLE[@leaderPagePointer.maxlength];    BEGIN ENABLE      UNWIND => scratchPtr ¬ Space.Unmap[scratchPtr ! Space.Error => CONTINUE];     scatteredVMPtr[0] ¬ [      count: AccessFloppyTape.leaderPages * Environment.bytesPerPage,      vm: scratchPtr];    FloppyTape.ReadFile[      file: file, first: 0, scatteredVM: scatteredVMPtr ! UNWIND => NULL];       -- Now copy the local attributes record into the one passed in.    -- If all of the ClientData won't fit, then don't copy any of it.    IF leaderPagePointer.clientDataLength > attributes.maxlength THEN {      z.FREE[@scatteredVMPtr];      AccessFloppyTape.NoRoomForClientData[        leaderPagePointer.clientDataLength - attributes.maxlength];      };    -- Before copying, move the original value of maxlength in attributes record to maxlength field  pointed to by leaderPagePointer.    ptrToMaxlength­ ¬ attributes.maxlength;    PageAlignAttributes[to: attributes, from: leaderPagePointer];    scratchPtr ¬ Space.Unmap[scratchPtr ! Space.Error => CONTINUE];    z.FREE[@scatteredVMPtr];    END; -- enable    END; -- ReadLeaderPage.      SetAttributes: PUBLIC PROCEDURE [    file: AccessFloppyTape.FileHandle, attributes: AccessFloppyTape.Attributes] =    BEGIN    size: AccessFloppyTape.PageCount;    type: File.Type;    [size, type] ¬ FloppyTape.GetFileAttributes[file ! UNWIND => NULL];    IF attributes = NIL THEN ERROR AccessFloppyTape.Error[invalidParameter];    IF type # AccessFloppyTape.fileTypeForLeaderPage THEN      AccessFloppyTape.Error[noAttributesRecord];    WriteLeaderPage[file, attributes];    END; -- SetAttributes.  SpaceAvailable: PUBLIC PROCEDURE [volume: AccessFloppyTape.VolumeHandle]    RETURNS [freeSpace: AccessFloppyTape.PageCount] =    BEGIN    freeSpace ¬ FloppyTape.GetVolumeAttributes[      volume: volume, name: NIL].freeSpace;    END; -- SpaceAvailable  Writable: PUBLIC PROCEDURE [drive: AccessFloppyTape.Drive]    RETURNS [writeEnable: BOOLEAN] =    << Accelerator for xxx[inhibitWrite] >>    BEGIN    handle: FloppyChannel.Handle;    handle ¬ FloppyChannel.GetHandle[      drive: drive ! FloppyChannel.Error => FloppyTape.Error[noSuchDrive]];    writeEnable ¬ NOT      (FloppyChannel.GetContext[        handle: handle !        FloppyChannel.Error => FloppyTape.Error[invalidVolumeHandle]].protect);    END; -- Writable  Write: PUBLIC PROCEDURE [    volume: AccessFloppyTape.VolumeHandle, attributes: AccessFloppyTape.Attributes,    buffer: AccessFloppyTape.VMBuffer] RETURNS [fileId: FloppyTape.FileID] =    BEGIN    -- make the buffer for the AttributesRecord in full pages.    leaderPagePointer: LONG POINTER TO AccessFloppyTape.AttributesRecord;    scratchPtr: LONG POINTER ¬ Space.ScratchMap[      count: AccessFloppyTape.leaderPages];    scatteredVMPtr: FloppyTape.ScatteredVM ¬ z.NEW[FloppyTape .ScatteredVMSeq[2]];    leaderByteCount: FloppyTape.ByteCount;        leaderByteCount ¬ AccessFloppyTape.leaderPages * Environment.bytesPerPage;    leaderPagePointer ¬ LOOPHOLE[scratchPtr];    PageAlignAttributes[to: leaderPagePointer, from: attributes];    scatteredVMPtr[0] ¬ [count: leaderByteCount, vm: leaderPagePointer];    scatteredVMPtr[1].vm ¬ buffer.vm;    scatteredVMPtr[1].count ¬ buffer.count * Environment.bytesPerPage;    BEGIN      ENABLE	UNWIND => {	  z.FREE[@scatteredVMPtr];	  scratchPtr ¬ Space.Unmap[scratchPtr ! Space.Error => CONTINUE];	  };      [fileId] ¬ FloppyTape.WriteFile[	volume: volume, type: AccessFloppyTape.fileTypeForLeaderPage,	scatteredVM: scatteredVMPtr];    END;    z.FREE[@scatteredVMPtr];    scratchPtr ¬ Space.Unmap[scratchPtr ! Space.Error => CONTINUE];    END; -- Write  WriteLeaderPage: PROC [    file: AccessFloppyTape.FileHandle, attributes: AccessFloppyTape.Attributes] =    BEGIN    -- make the buffer for the AttributesRecord in full pages.    leaderPagePointer: LONG POINTER TO AccessFloppyTape.AttributesRecord;    scratchPtr: LONG POINTER ¬ Space.ScratchMap[      count: AccessFloppyTape.leaderPages];    scatteredVMPtr: FloppyTape.ScatteredVM ¬ z.NEW[FloppyTape .ScatteredVMSeq[1]];    leaderPagePointer ¬ LOOPHOLE[scratchPtr];    attributes.common.seal ¬ AccessFloppyTape.sealValue;    PageAlignAttributes[to: leaderPagePointer, from: attributes];    scatteredVMPtr[0] ¬ [      count: AccessFloppyTape.leaderPages * Environment.bytesPerPage,      vm: leaderPagePointer];    FloppyTape.RewriteFile[      file: file, first: 0, scatteredVM: scatteredVMPtr !      UNWIND => {        scratchPtr ¬ Space.Unmap[scratchPtr ! Space.Error => CONTINUE];        z.FREE[@scatteredVMPtr];        }];    scratchPtr ¬ Space.Unmap[scratchPtr ! Space.Error => CONTINUE];    z.FREE[@scatteredVMPtr];    END; -- WriteLeaderPage.  END.LOG 16-Feb-87 11:55:15  PKM  Created File 16-Mar-87 14:49:52  PKM  Changed Xerox copyright notice to standard format 16-Mar-87 14:49:52  PKM  Changed for the the new AccessFloppyTape interface  4-May-87 13:18:08  MAT  Added use of FloppyTapeDirectory to appropriate procedures. 8-May-87 15:17:27  MAT  Added GetNextFile procedure, parameter startFrom added to Enumerate.13-May-87 11:47:49  MAT  Fixed Enumerate to use startFrom in directory.19-May-87 17:14:21  DDM  Directory package name change. 21-May-87 11:52:32  PKM  Changed for the the new AccessFloppyTape interface, took out the bear traps. 27-May-87 22:57:27  DDM  Merge SDD AccessFloppyTape with NSD version for Directory package. 2-Jun-87 17:15:03  DDM  Enumerate with Directory and startFrom # nullFileID was geginning search with "startFrom" entry but should use "startFrom+1".26-Jun-87 00:00:00  MRY  STRING => LONG STRING for Pilot 14.12-Jul-87 10:51:34  DDM  STRING => LONG STRING for Pilot 14. [NS AR 6266] Handle IOError on Open by defining NoDirReason for SIGNAL NoDirectory.21-Jul-87 15:19:23  RSV  Back to standard header. 2-Oct-87 16:14:30  JAC  change GetNextDrive for mirror13-Oct-87 14:06:01  JAC/RSV  use FloppyTapeExtras.GetNextFloppyTapeDrive
-- Copyright (C) 1987  by Xerox Corporation. All rights reserved. -- FBStompToolDLight.mesa	 3-Dec-87 13:46:26	by ET---- Tool to make bootable tapes.DIRECTORY  AccessFloppyTape	USING 	[Attributes, AttributesRecord, CopyFromPilotFile,  				 currentAttributeVersion, Drive, Error,				 fileTypeForLeaderPage, Flags, GetAttributes,				 GetNextDrive, leaderPages, maxClientDataWords,				 maxNameLength, NameLength,				 OverWriteFromPilotFile, sealValue],   Boot 			USING 	[DiskFileID, inLoad, Request],  ClientFloppyData	USING 	[dataVersion],  DeviceTypesExtras4	USING 	[fad5000],  DLionInputOutput 	USING 	[firstMapPage, ioPageNumber, mapPagesCount],--  DLionInputOutputExtraExtras--  			USING 	[mapPagesCountVM22, mapPagesCountVM23,--			         mapPagesCountVM24],  Environment 		USING	[bytesPerPage, bytesPerWord, Byte, PageCount,                                 PageNumber, wordsPerPage],  Exec			USING 	[CheckForAbort, ExecProc, GetToken, Handle,  				 FreeTokenString, OutputProc],    File 			USING 	[File, nullFile, nullID, PageCount, PageNumber,  				 Type],  FloppyTape		USING	[ByteCount, ByteOffset, CloseVolume, Drive, Error,  				 ErrorType, FileHandle, FileID, GetFileAttributes,				 IOError, localDrive, NotifyClientProc,			         nullFileID, 				 nullVolumeHandle, OpenVolume, ReadFile,				 ScatteredVM, ScatteredVMSeq, VMBuffer,				 VolumeHandle],  FileTypes		USING 	[tUntypedFile],				   FloppyChannel		USING 	[DiskAddress],  Heap			USING 	[systemZone],  Inline		USING 	[HighHalf, LongCOPY, LowHalf],  Format 		USING 	[Date, DecimalFormat, LongNumber, StringProc],  MakeBootTape		USING 	[],  MFile 		USING	[Acquire, ByteCount, Error, GetCreateDate,  				 GetLength, GetProperties, Handle, Release],  MStream		USING	[Error, Handle, ReadOnly, WriteOnly],  Process		USING	[Abort, Detach, GetCurrent, Pause,  				 SecondsToTicks],   Space			USING	[Interval, Map, ScratchMap, Unmap],  SpecialFloppyTape	USING   [BootFilePointer, CheckBootFile,                                 CreateInitialMicrocodeFile,  				 GetBootFiles, GetDiskAddress,				 nullBootFilePointer, ReserveDiagnosticArea,				 SetBootFiles],  SpecialMFile 		USING	[GetCapaWithAccess, LeaderPages],  Stream		USING	[Handle],  String		USING 	[AppendChar, Copy, CopyToNewString, Empty,  				 Equivalent],  Time			USING 	[Current],  UserTerminal		USING 	[BlinkDisplay];  FBStompToolDLight: PROGRAM  IMPORTS    AccessFloppyTape, Exec, FloppyTape, Format, Heap, Inline, MFile, MStream,     Process, SpecialFloppyTape, String, Space, SpecialMFile, Time, UserTerminal  EXPORTS    MakeBootTape =  BEGIN  -- Types & Constants      FileName: 		TYPE = {initUCode, diagUCode, boot, germ, pilotUCode, altBoot1, altBoot2, altBoot3, altBoot4, altBoot5, altBoot6, altBoot7, altBoot8, altBoot9, altBoot10, altBoot11, altBoot12, altBoot13, altBoot14, altBoot15, altBoot16, altBoot17, altBoot18, altBoot19, altBoot20};    wdsPerPage:		CARDINAL = Environment.wordsPerPage;  bytesPerPage:		CARDINAL = Environment.bytesPerPage;    leaderPages:		LONG CARDINAL = AccessFloppyTape.leaderPages;   -- Variable declarations  z:			UNCOUNTED ZONE ¬ Heap.systemZone;     bootStrings:	 	ARRAY FileName OF LONG STRING ¬ ALL[NIL];   bootInfo:		ARRAY FileName OF SpecialFloppyTape.BootFilePointer;   bootFilesRead: 	BOOLEAN ¬ FALSE;  -- this will be set to TRUE in proc GetFloppyFSDope   					  -- after it gets the boot file information from a tape  localDrive:		FloppyTape.Drive ¬ FloppyTape.localDrive;     localDriveValid:      BOOLEAN ¬ FALSE;  maxNameLength:	AccessFloppyTape.NameLength ¬ AccessFloppyTape.maxNameLength;    -- Errors  NoFile:		ERROR [s: LONG STRING] = CODE;  Error: 		ERROR [s1: LONG STRING, s2: LONG STRING ¬ NIL] = CODE;      floppyErrors: 	ARRAY FloppyTape.ErrorType OF LONG STRING = [      "Bad Tape"L, "Bad Sectors"L, "File Not Found"L,"Hardware Error"L, "inUse"L,       "Invalid Byte Offset"L, "Invalid Volume Handle"L, "Volume Full"L,       "Needs Scavenging"L, "No Such Drive"L, "Tape needs to be formatted"L,       "Drive Not Ready"L, "A volume is opened already"L, "Write Protected"L];        ioError: LONG STRING = "IO Error"L;    -- Procs    WriteMsgProc: Format.StringProc;  NotifyRetention: FloppyTape.NotifyClientProc = {  -- NotifyClientProc: TYPE = PROCEDURE [drive: Drive, which: {start, stop}];      SELECT TRUE FROM      which = start => Write["\nTape needs retention...retentioning..."L];       which = stop  => Write["done."L];      ENDCASE;    };      UnmapVM: PROCEDURE [ptr: LONG POINTER] = INLINE {ptr ¬ Space.Unmap[ptr]};      Write: PROCEDURE [s1, s2, s3: LONG STRING ¬ NIL] =    BEGIN        WriteMsgProc[s1]; WriteMsgProc[s2]; WriteMsgProc[s3];    END;             CreateLeaderPage: PROCEDURE [which: FileName, attr: AccessFloppyTape.Attributes] =           BEGIN    OPEN attr.common;        fH:		MFile.Handle;    flag:	AccessFloppyTape.Flags ¬ [serialized:TRUE, obsolete: FALSE,      					  creator: tajo, reserved:FALSE];        seal ¬ AccessFloppyTape.sealValue;    attributeVersion ¬ AccessFloppyTape.currentAttributeVersion;      type ¬ FileTypes.tUntypedFile;    version ¬ 0;    flags ¬ flag;    fH ¬ MFile.Acquire[bootStrings[which], readOnly, []       ! MFile.Error => ERROR NoFile[bootStrings[which]]];        modified ¬ MFile.GetCreateDate[fH];    copied ¬ Time.Current[];    [length: attr.totalBytes, create: created,       type: attr.clientData[1]] ¬ MFile.GetProperties[fH, bootStrings[which]];    -- if the germ, then strip off $ and use that as modified and create dates.    IF which = germ THEN      BEGIN      realGermHandle: MFile.Handle;      realGermName: LONG STRING;      realGermName ¬ String.CopyToNewString[bootStrings[which], z, 0];      realGermName.length ¬ realGermName.length - 1;      realGermHandle ¬ MFile.Acquire[realGermName, readOnly, []         ! MFile.Error => BEGIN	                 MFile.Release[fH];	                 ERROR NoFile[realGermName];			 END];      created ¬ modified ¬ MFile.GetCreateDate[realGermHandle         ! MFile.Error => MFile.Release[fH]];      MFile.Release[realGermHandle ! MFile.Error => MFile.Release[fH]];      END;    attr.totalPages ¬       (attr.totalBytes + Environment.bytesPerPage - 1) / Environment.bytesPerPage;          nameLength ¬ bootStrings[which].length;    nameLengthMax ¬ maxNameLength;        FOR i: CARDINAL IN [0..bootStrings[which].length) DO        name[i] ¬ LOOPHOLE[bootStrings[which].text[i]];	ENDLOOP;    attr.clientDataLength ¬ 2;    attr.clientData[0] ¬ ClientFloppyData.dataVersion;    attr.segmentOffset ¬ attr.segmentPages ¬ leaderPages;        MFile.Release[fH];        END;              --*********************************************************************  --  -- Display Boot File Information   --  --********************************************************************* DisplayBootFileInfo: PUBLIC Exec.ExecProc =   BEGIN       attributes:  AccessFloppyTape.Attributes;   fileHandle:	FloppyTape.FileHandle;   found:	BOOLEAN ¬ FALSE;    vol: 	FloppyTape.VolumeHandle ¬ FloppyTape.nullVolumeHandle;     		        Cleanup: PROC =  INLINE {     FloppyTape.CloseVolume[vol];     Heap.systemZone.FREE[@attributes]};		          BEGIN   ENABLE      BEGIN     FloppyTape.Error => {Write["\n", floppyErrors[error]]; GOTO exit};      Error =>  {Write[s1, s2]; GOTO exit};     ANY => {Write["Unknown Error"L]; GOTO exit};     END;          bootFilesRead ¬ FALSE;	     WriteMsgProc ¬ Exec.OutputProc[h];   IF ~localDriveValid THEN {    localDrive ¬ AccessFloppyTape.GetNextDrive[]; -- Horizon Phase I GetNextDrive will return    localDriveValid ¬ TRUE;    			  -- one and only one cartridge tape device.    };   vol ¬ FloppyTape.OpenVolume[localDrive, TRUE, NotifyRetention];    	   attributes ¬ Heap.systemZone.NEW[   AccessFloppyTape.AttributesRecord[AccessFloppyTape.maxClientDataWords]];     FOR s: FileName IN [diagUCode..pilotUCode] DO     ENABLE        BEGIN       FloppyTape.Error => {Write[floppyErrors[error]]; LOOP};       FloppyTape.IOError => {Write[ioError]; LOOP};       END;     IF Exec.CheckForAbort[h] THEN {outcome ¬ abort; GOTO exit};     fileHandle ¬ [volume: vol, file:GetFloppyFSDope[s, vol].file];          IF fileHandle.file # FloppyTape.nullFileID THEN        BEGIN                  	 AccessFloppyTape.GetAttributes[file: fileHandle, attributes: attributes];	 DisplayInfo[which: s, id: fileHandle.file, attrPtr: attributes];	 IF ~found THEN found ¬ TRUE;       END;     ENDLOOP;       IF ~found THEN Write["No Boot File Found."L];     Cleanup[];      EXITS exit => Cleanup[];   END;                END;          DisplayInfo: PROCEDURE [which: FileName, id: FloppyTape.FileID, attrPtr: AccessFloppyTape.Attributes] =    BEGIN  OPEN attrPtr.common;      name: LONG STRING ¬ LOOPHOLE[@nameLength];        IF seal # AccessFloppyTape.sealValue THEN {      Write["\nWrong LeaderPage Format."L]; RETURN[]};             SELECT which FROM       boot =>		Write["Pilot boot file: "L];       germ =>	 	Write["Germ: "L];       diagUCode => 	Write["Diagnostic uCode: "L];       pilotUCode =>	Write["Pilot uCode: "L];       ENDCASE => NULL;              Write[name, "  FileID: "L];     Format.LongNumber[WriteMsgProc, LOOPHOLE[id], [10, FALSE, TRUE, 0]];    Write[",  "L];         Format.LongNumber[      proc: WriteMsgProc, n:attrPtr.totalBytes, format: Format.DecimalFormat];        Write[" bytes  "L];    Format.LongNumber[      proc: WriteMsgProc, n:attrPtr.totalPages + leaderPages,      format: Format.DecimalFormat];    Write[" pages\ncreate: "L];    Format.Date[proc: WriteMsgProc, pt: created,  format: dateTime];    Write["  write: "L];    Format.Date[proc: WriteMsgProc, pt: copied,  format: dateTime];    Write["\n"L];       END;        -- gets the pointer to all of the boot files using track zero's volume structures.    GetFloppyFSDope: PROCEDURE [which: FileName, vol: FloppyTape.VolumeHandle]    RETURNS [SpecialFloppyTape.BootFilePointer] =    BEGIN    IF which IN [altBoot1..altBoot20] THEN       -- forget about finding an altBootfile on the tape.  Need to use tape dir, later.       bootInfo[which] ¬ [FloppyTape.nullFileID, 0];    IF ~bootFilesRead THEN {         [initialMicrocode: bootInfo[initUCode], pilotMicrocode: bootInfo[pilotUCode],       diagnosticMicrocode: bootInfo[diagUCode], germ: bootInfo[germ],       pilotBootFile: bootInfo[boot]] ¬ SpecialFloppyTape.GetBootFiles[vol];       bootFilesRead ¬ TRUE};    RETURN[bootInfo[which]];    END;  -- GetFloppyFSDope        -- get Pilot file's information     GetPilotFSDope: PROCEDURE [s: LONG STRING]    RETURNS [file: File.File, leaderSize, fileSize: File.PageCount] = {        fH: MFile.Handle ¬ MFile.Acquire[s, readOnly, [] ! MFile.Error => NoFile[s]];    file ¬ SpecialMFile.GetCapaWithAccess[fH];    leaderSize ¬ SpecialMFile.LeaderPages[];    fileSize ¬ (MFile.GetLength[fH] + Environment.bytesPerPage - 1) / Environment.bytesPerPage;    MFile.Release[fH];    };         InstallFile: PROCEDURE [which: FileName, vol: FloppyTape.VolumeHandle] =    BEGIN            fileID:		 FloppyTape.FileID;    file:		 File.File;    leaderSize:		 File.PageNumber ¬ 0;    fileSize:		 File.PageCount;    flopHandle: 	 FloppyTape.FileHandle;    bootFilePtr: 	 SpecialFloppyTape.BootFilePointer;    fileAttr:		 AccessFloppyTape.Attributes;    done: 		 BOOLEAN ¬ FALSE;    tried:	 	 BOOLEAN ¬ FALSE;    UpdateFloppyFSDope:  PROCEDURE[bootFilePtr: SpecialFloppyTape.BootFilePointer]      = INLINE {bootInfo[which] ¬ bootFilePtr};              IF bootStrings[which] = NIL OR bootStrings[which].length = 0 THEN RETURN;    Write["\nInstalling "L, bootStrings[which], "..."L];        IF which = germ AND ~CreateGermFile[vol, boot] THEN RETURN;            bootFilePtr ¬ GetFloppyFSDope[which, vol];   -- AR 11762              [file, leaderSize, fileSize] ¬ GetPilotFSDope[bootStrings[which]];        flopHandle ¬ [volume: vol, file: bootFilePtr.file];    fileID ¬ bootFilePtr.file;         IF which # initUCode THEN {      fileAttr ¬ Heap.systemZone.NEW[         AccessFloppyTape.AttributesRecord[AccessFloppyTape.maxClientDataWords]];      CreateLeaderPage[which, fileAttr]};           -- what if a file exists on a floppy tape already ?    BEGIN    ptr:	LONG POINTER ¬ Space.ScratchMap[count: leaderPages];    attrPtr:	AccessFloppyTape.Attributes;    name:	LONG STRING;    vmPtr:	FloppyTape.ScatteredVM ¬ z.NEW[FloppyTape.ScatteredVMSeq[1]];    IF fileID # FloppyTape.nullFileID AND which # initUCode AND      (FloppyTape.GetFileAttributes[flopHandle].size/bytesPerPage) = (fileSize + leaderSize) THEN      BEGIN      vmPtr[0] ¬ [count: bytesPerPage, vm: ptr];          FloppyTape.ReadFile[file: flopHandle, first: 0, scatteredVM: vmPtr !        ANY => {UnmapVM[ptr]; z.FREE[@vmPtr]}];      attrPtr ¬ LOOPHOLE[ptr];      name ¬ LOOPHOLE[@attrPtr.common.nameLength];      IF String.Equivalent[name, bootStrings[which]] THEN       {        done ¬ TRUE;        Write["(rewriting to the existing file)..."L];        AccessFloppyTape.OverWriteFromPilotFile[file, flopHandle, leaderSize, fileSize, fileAttr !          AccessFloppyTape.Error => {Write["(can not rewrite to the existing file)..."L];			 	     done ¬ FALSE; CONTINUE}]      };      UnmapVM[ptr];       z.FREE[@vmPtr];      END;    END;        IF ~done THEN {      done ¬ TRUE;      Write["(writing file)..."L];      IF which = initUCode THEN        SpecialFloppyTape.CreateInitialMicrocodeFile[         	   volume: vol, 		   initial: file, 		   size: (fileSize + leaderSize) * bytesPerPage, -- include leaderPage size   		   type: FileTypes.tUntypedFile,		   startingOffset: leaderSize * bytesPerPage]      ELSE       	fileID ¬ AccessFloppyTape.CopyFromPilotFile[	           pilotFile: file,		   volume: vol, 		   firstPilotPage: leaderSize,		   pageCount: fileSize, 		   type: AccessFloppyTape.fileTypeForLeaderPage, 		   attributes: fileAttr]      };      	    IF which # initUCode THEN {      UpdateFloppyFSDope[[fileID, leaderPages*bytesPerPage]];      Heap.systemZone.FREE[@fileAttr]};    Write["done."L];          END;             --*********************************************************************  --  -- Install the various files for a bootable floppy  --  --*********************************************************************  MakeBootableTape: PUBLIC Exec.ExecProc =    BEGIN        vol: FloppyTape.VolumeHandle ¬ FloppyTape.nullVolumeHandle;        SetFloppyBootFiles: PROCEDURE [] =      BEGIN       -- set the pointers to the boot related files in the volume data structures.      -- also check for disallowed bad pages in the just-written file.      Write["\nChecking for bad pages..."L];      FOR i: FileName IN [altBoot1..altBoot20] DO        IF String.Empty[bootStrings[i]] THEN EXIT; -- no more alternate bootfiles.        SpecialFloppyTape.CheckBootFile[[vol, bootInfo[i].file]];	ENDLOOP;      SpecialFloppyTape.SetBootFiles[        volume: vol, pilotMicrocode: bootInfo[pilotUCode],        diagnosticMicrocode: bootInfo[diagUCode], germ: bootInfo[germ],        pilotBootFile: bootInfo[boot]];      Write["no bad pages found... done."L];      END; -- internal SetFloppyBootFiles  	    Cleanup: PROC = INLINE {      FOR i: FileName IN FileName DO z.FREE[@bootStrings[i]]; ENDLOOP};                BEGIN    ENABLE {      FloppyTape.Error =>  {Write["\n"L, floppyErrors[error]]; GOTO cleanup};      FloppyTape.IOError=> {Write[ioError]; GOTO cleanup};      Error => 	{Write[s1, s2]; GOTO cleanup};      NoFile => {Write[s, " not found"L]; GOTO cleanup};      ANY =>	{Write["Unknown Error"L]; GOTO cleanup}};            bootFilesRead ¬ FALSE;     WriteMsgProc ¬ Exec.OutputProc[h];    IF ~localDriveValid THEN    {      localDrive ¬ AccessFloppyTape.GetNextDrive[]; -- Horizon Phase I GetNextDrive will return        localDriveValid ¬ TRUE;  		    	    -- one and only one cartridge tape device.    };    FOR i: FileName IN FileName DO      bootStrings[i] ¬ z.NEW[StringBody[maxNameLength]]; ENDLOOP;    IF ~ParseCommand[h] THEN {outcome ¬ error; GOTO cleanup};     Write["Making bootable tape..."L];        -- The following line enforces a workaround for a bug in FloppyInitial.db.    -- Because the floppy initial does not create the inload request for the    -- germ but rather relies on ProcessGerm to do it (here)  we end up    -- with the Germ on the floppy containing a cross-pointer to the bootfile.    -- Therefore if ever we write a new bootfile, we must write a new germ as     -- well.        IF ~String.Empty[bootStrings[boot]] AND String.Empty[bootStrings[germ]] THEN        GOTO mustQuoteGerm;    vol ¬ FloppyTape.OpenVolume[localDrive, FALSE, NotifyRetention];        FOR s: FileName IN FileName DO      IF Exec.CheckForAbort[h] THEN {        outcome ¬ abort;	SetFloppyBootFiles[! UNWIND => FloppyTape.CloseVolume[vol]];	FloppyTape.CloseVolume[vol];	GOTO cleanup};      InstallFile[s, vol !         UNWIND => {SetFloppyBootFiles[! UNWIND => FloppyTape.CloseVolume[vol]];       		   FloppyTape.CloseVolume[vol]}];      ENDLOOP;    SetFloppyBootFiles[! UNWIND => FloppyTape.CloseVolume[vol]];    FloppyTape.CloseVolume[vol];    Cleanup[];        EXITS      cleanup   => Cleanup[];      mustQuoteGerm => {         Write["\nYou must provide a germ if you want to write a boot file."L];	UserTerminal.BlinkDisplay[];        Cleanup[]};    END;            END;          ParseCommand : PROC [h:Exec.Handle] RETURNS [success : BOOLEAN ¬ TRUE] = {     token, switches: LONG STRING ¬ NIL;     string: FileName;     altBootCounter: CARDINAL ¬ 1; -- counts /a switches as they happen...     mapPages ¬ 128;     << mapPages ¬ DLionInputOutputExtraExtras.mapPagesCountVM23; >>     DO      [token, switches] ¬ Exec.GetToken[h];      SELECT TRUE FROM        token = NIL AND switches = NIL => EXIT;        token # NIL AND switches # NIL =>        {          SELECT TRUE FROM            String.Equivalent[switches, "i"L] => string ¬ initUCode;            String.Equivalent[switches, "d"L] => string ¬ diagUCode;            String.Equivalent[switches, "p"L] => string ¬ pilotUCode;            String.Equivalent[switches, "g"L] => string ¬ germ;            String.Equivalent[switches, "b"L] => string ¬ boot;            String.Equivalent[switches, "a"L] AND (altBootCounter = 1)  =>	      {string ¬ altBoot1; altBootCounter ¬ altBootCounter + 1};            String.Equivalent[switches, "a"L] AND (altBootCounter = 2)  =>	      {string ¬ altBoot2; altBootCounter ¬ altBootCounter + 1};            String.Equivalent[switches, "a"L] AND (altBootCounter = 3)  =>	      {string ¬ altBoot3; altBootCounter ¬ altBootCounter + 1};            String.Equivalent[switches, "a"L] AND (altBootCounter = 4)  =>	      {string ¬ altBoot4; altBootCounter ¬ altBootCounter + 1};            String.Equivalent[switches, "a"L] AND (altBootCounter = 5)  =>	      {string ¬ altBoot5; altBootCounter ¬ altBootCounter + 1};            String.Equivalent[switches, "a"L] AND (altBootCounter = 6)  =>	      {string ¬ altBoot6; altBootCounter ¬ altBootCounter + 1};            String.Equivalent[switches, "a"L] AND (altBootCounter = 7)  =>	      {string ¬ altBoot7; altBootCounter ¬ altBootCounter + 1};            String.Equivalent[switches, "a"L] AND (altBootCounter = 8)  =>	      {string ¬ altBoot8; altBootCounter ¬ altBootCounter + 1};            String.Equivalent[switches, "a"L] AND (altBootCounter = 9)  =>	      {string ¬ altBoot9; altBootCounter ¬ altBootCounter + 1};            String.Equivalent[switches, "a"L] AND (altBootCounter = 10) =>	      {string ¬ altBoot10; altBootCounter ¬ altBootCounter + 1};            String.Equivalent[switches, "a"L] AND (altBootCounter = 11) =>	      {string ¬ altBoot11; altBootCounter ¬ altBootCounter + 1};            String.Equivalent[switches, "a"L] AND (altBootCounter = 12) =>	      {string ¬ altBoot12; altBootCounter ¬ altBootCounter + 1};            String.Equivalent[switches, "a"L] AND (altBootCounter = 13) =>	      {string ¬ altBoot13; altBootCounter ¬ altBootCounter + 1};            String.Equivalent[switches, "a"L] AND (altBootCounter = 14) =>	      {string ¬ altBoot14; altBootCounter ¬ altBootCounter + 1};            String.Equivalent[switches, "a"L] AND (altBootCounter = 15) =>	      {string ¬ altBoot15; altBootCounter ¬ altBootCounter + 1};            String.Equivalent[switches, "a"L] AND (altBootCounter = 16) =>	      {string ¬ altBoot16; altBootCounter ¬ altBootCounter + 1};            String.Equivalent[switches, "a"L] AND (altBootCounter = 17) =>	      {string ¬ altBoot17; altBootCounter ¬ altBootCounter + 1};            String.Equivalent[switches, "a"L] AND (altBootCounter = 18) =>	      {string ¬ altBoot18; altBootCounter ¬ altBootCounter + 1};            String.Equivalent[switches, "a"L] AND (altBootCounter = 19) =>	      {string ¬ altBoot19; altBootCounter ¬ altBootCounter + 1};            String.Equivalent[switches, "a"L] AND (altBootCounter = 20) =>	      {string ¬ altBoot20; altBootCounter ¬ altBootCounter + 1};	    String.Equivalent[switches, "a"L] AND (altBootCounter > 20) => 	      {Write["Too many alternate bootfiles! Limit = 20."L]; GOTO Skip};	    String.Equivalent[switches, "v"L],	    String.Equivalent[switches, "vm"L] => 	      mapPages ¬ 	        SELECT TRUE FROM    		  String.Equivalent[token, "22"L] => DLionInputOutput.mapPagesCount <<DLionInputOutputExtraExtras.mapPagesCountVM22>>,		  String.Equivalent[token, "23"L] => 128 <<DLionInputOutputExtraExtras.mapPagesCountVM23>>,		  String.Equivalent[token, "24"L] => 256 <<DLionInputOutputExtraExtras.mapPagesCountVM24>>,		  		  ENDCASE => Error["Bad /v switch, must be 22, 23, or 24."L,];            ENDCASE => {              Write["Unknown switch: "L, switches];	      token ¬ Exec.FreeTokenString[token];      	      switches ¬ Exec.FreeTokenString[switches];	      GOTO Skip};	    IF ~String.Equivalent[switches, "vm"L] AND ~String.Equivalent[switches, "v"L]	    THEN String.Copy[bootStrings[string], token]	};        ENDCASE => NULL;      ENDLOOP;         IF mapPages = 0 THEN {        Write["Unknown VM Size"L];	GOTO Skip};         firstForPilotPage ¬ DLionInputOutput.firstMapPage + CARDINAL[mapPages]; --**      mapIndexSizeMinus1 ¬ CARDINAL[mapPages * wdsPerPage - 1];	--**            EXITS Skip => success ¬ FALSE;  };  -- end of ParseCommand.        --*********************************************************************  --  -- Reserve Last Cylinder for Diagnostics  --  --*********************************************************************     ReserveDiagnosticTrack : PUBLIC Exec.ExecProc =    BEGIN        stopWatching: BOOLEAN ¬ FALSE;        WatchUserAbort: PROCEDURE [procID: PROCESS] =       BEGIN      WHILE ~stopWatching DO        IF Exec.CheckForAbort[h] THEN {	  Write["Abort requested..."L];	  Process.Abort[procID]; 	  EXIT};        Process.Pause[Process.SecondsToTicks[1]];        ENDLOOP;      END;          BEGIN    ENABLE       BEGIN      FloppyTape.Error => {Write["\n"L, floppyErrors[error]]; GOTO exit};      FloppyTape.IOError => {Write[ioError]; GOTO exit};      ABORTED => {Write["Aborted."L]; GOTO exit};      ANY => 	{Write["\nUnknown Error"L]; GOTO exit};            END;        WriteMsgProc ¬ Exec.OutputProc[h];    IF ~localDriveValid THEN    {      localDrive ¬ AccessFloppyTape.GetNextDrive[]; -- Horizon Phase I GetNextDrive will return      localDriveValid ¬ TRUE;    		    -- one and only one cartridge tape device.      };    Write["Reserving diagnostic tracks..."L];    Process.Detach[FORK WatchUserAbort[Process.GetCurrent[]]];    IF ~SpecialFloppyTape.ReserveDiagnosticArea[localDrive].ableToReserve      THEN Write["\nAnother file occupies the required space."L]      ELSE Write["done."L];     stopWatching ¬ TRUE;            EXITS exit => stopWatching ¬ TRUE;        END;        END;             --*********************************************************************  --  -- Dandelion real memory image maker  --  --*********************************************************************    CreateGermFile: PROCEDURE [volume: FloppyTape.VolumeHandle, bf: FileName]    RETURNS [success: BOOLEAN ¬ FALSE] =        BEGIN        file       : LONG STRING = bootStrings[germ];    fileHandle : FloppyTape.FileHandle;    bootFilePtr: SpecialFloppyTape.BootFilePointer;    location   : Boot.DiskFileID;    diskAddress: FloppyChannel.DiskAddress;        bootFilePtr ¬ GetFloppyFSDope[bf, volume];    fileHandle ¬ [volume: volume, file: bootFilePtr.file];    location.firstPage ¬ 0;    location.fID ¬ [volumeRelative[File.nullID]];    IF bootFilePtr.file = FloppyTape.nullFileID THEN {      Write["\nYou must provide a boot file if you want to write a germ."L];      success ¬ FALSE;      RETURN}     ELSE diskAddress ¬ SpecialFloppyTape.GetDiskAddress[fileHandle, bootFilePtr.offset !    	                 FloppyTape.Error => IF error = fileNotFound THEN NoFile["Boot file "L]];    location.da ¬ LOOPHOLE[diskAddress];    IF MakeRMFile[file, location] THEN success ¬ TRUE;            END;      RealPageNumber: TYPE = CARDINAL;  IOPhysPage: RealPageNumber = DLionInputOutput.ioPageNumber;  IOVirtPage: CARDINAL = 377B;  GermMDSPage: TYPE = CARDINAL [0..377B);  -- page  germMDSMapPage: RealPageNumber = DLionInputOutput.firstMapPage;  firstForPilotPage: RealPageNumber;  -- there are two memory boards in the DLion:  -- memControl (standard 64K, option 256K)  -- storage    (standard 128K, option: 512K or fraction)  last192kMachineForPilotPage: RealPageNumber = 3 * 256 - 1;  last256kMachineForPilotPage: RealPageNumber = 4 * 256 - 1;  last384kMachineForPilotPage: RealPageNumber = 6 * 256 - 1;  last512kMachineForPilotPage: RealPageNumber = 8 * 256 - 1;  lastForPilotPage: RealPageNumber ¬ last512kMachineForPilotPage;  pRequest: POINTER = LOOPHOLE[1000B + 640B];    -- DLight memory map  mapPages: Environment.PageCount;  -- NOTE: MapIndex-es ARE ALWAYS REDUCED TO A CARDINAL  -- ALTHOUGH A PAGE NUMBER IS POTENTIALLY 24 BITS LONG.  HOWEVER,   -- DANDELIONS ONLY HAVE 16 BIT PAGE NUMBERS.  mapIndexSizeMinus1: CARDINAL;  RealMapEntry: TYPE = MACHINE DEPENDENT RECORD [    lo: [0..256), logSingle: BOOLEAN ¬ FALSE, flg: [0..8), addrHi: [0..16)];  vacant: RealMapEntry = [0, FALSE, 6, 0];  UnmappedMemory: ERROR = CODE;    InitMap: PROCEDURE [map: LONG POINTER] = {    -- set the local map to be the same as that set up by the initial ucode        SetMap: PROCEDURE [      virtual: Environment.PageNumber, realPage: RealPageNumber,      map: LONG POINTER TO RealMapEntry] =             BEGIN        mapPtr: LONG POINTER TO RealMapEntry;       IF virtual > mapIndexSizeMinus1 THEN ERROR;      mapPtr ¬ LOOPHOLE[LOOPHOLE[map, Environment.PageNumber] + virtual,      	LONG POINTER TO RealMapEntry];      mapPtr­ ¬ [flg: 0, addrHi: realPage / 400B, lo: realPage MOD 400B]            END;    rp: RealPageNumber ¬ firstForPilotPage;    vp: Environment.PageNumber ¬ 0;        mapPtr: LONG POINTER TO RealMapEntry = LOOPHOLE[map];    mapPtr­ ¬ vacant;    Inline.LongCOPY[      from: mapPtr,       to:   mapPtr + 1,      nwords: mapIndexSizeMinus1];      DO      SELECT TRUE FROM        vp = IOVirtPage => {SetMap[vp, IOPhysPage, map]; vp ¬ vp + 1};        rp = IOPhysPage => {rp ¬ rp + 1};        ENDCASE => {SetMap[vp, rp, map]; rp ¬ rp + 1; vp ¬ vp + 1};      IF rp = lastForPilotPage + 1 THEN EXIT;      ENDLOOP};  OutData: PROCEDURE [    realAddr: LONG POINTER, myAddr: LONG POINTER, out: Stream.Handle,    count: CARDINAL [0..wdsPerPage] ¬ wdsPerPage] = {        RMHeader: TYPE = MACHINE DEPENDENT RECORD [      count(0), realHi(1), realLo(2): CARDINAL];    rmHeader: RMHeader ¬ [      count: count, realHi: Inline.HighHalf[realAddr],      realLo: Inline.LowHalf[realAddr]];    out.put[      out, [      LOOPHOLE[LONG[@rmHeader]], 0, Environment.bytesPerWord * SIZE[RMHeader]],      FALSE];    out.put[out, [myAddr, 0, count * Environment.bytesPerWord], FALSE]};          GetRealAddr: PROCEDURE [    virtPageNumber: Environment.PageNumber, map: LONG POINTER]    RETURNS [realAddr: LONG POINTER] =        BEGIN    me: LONG POINTER TO RealMapEntry = LOOPHOLE[        LOOPHOLE[map, Environment.PageNumber] + virtPageNumber,	LONG POINTER TO RealMapEntry];    IF me.flg = vacant.flg THEN ERROR UnmappedMemory;    RETURN[LOOPHOLE[LONG[me.lo + (me.addrHi * 400B)] * wdsPerPage]]    END;      ReadPage: PROCEDURE [in: Stream.Handle, p: LONG POINTER, filename: LONG STRING]    RETURNS [eof: BOOLEAN] =    BEGIN    SELECT in.get[in, [p, 0, bytesPerPage], in.options].bytesTransferred FROM      bytesPerPage => RETURN[eof: FALSE];      0 => RETURN[eof: TRUE];      ENDCASE => Error["Unexpected end of "L, filename]    END;      ProcessGerm: PROCEDURE [    germName: LONG STRING, bootFileLocation: Boot.DiskFileID, map: LONG POINTER,    out: Stream.Handle] =    BEGIN    in: Stream.Handle = MStream.ReadOnly[      germName, [] ! MStream.Error => NoFile[germName]];    FOR vp: GermMDSPage ¬ FIRST[GermMDSPage] + 1, vp + 1 DO      data: ARRAY [0..wdsPerPage) OF WORD;      IF ReadPage[in, @data, germName ! UNWIND => in.delete[in]].eof THEN EXIT;      -- THE FOLLOWING OUGHT TO BE DONE BY THE INITIAL FLOPPY MICROCODE.      -- INSTEAD, IT LEAVES A POINTER TO THE BOOTFILE WRITTEN INTO THE GERM!!!      -- want to smash data the fourth page of the germ, where I assume      -- the buffer here contains pages 1,2,3,4 of the germ.      -- Specifically, I want to smash word numbers 264B and 265B.      IF vp = GermMDSPage.FIRST + 4 THEN       {        myPRequest: POINTER TO Boot.Request = LOOPHOLE[@data[          LOOPHOLE[pRequest - 1400B, CARDINAL]]];        myPRequest­ ¬ [          action: Boot.inLoad,          location: [deviceType: DeviceTypesExtras4.fad5000,	    	     deviceOrdinal: 0,	    	     vp: NULL],          pStartListHeader: NIL,	  inLoadMode: load, 	  session: NULL];        myPRequest.location.diskFileID ¬ bootFileLocation      };      OutData[realAddr: GetRealAddr[vp, map], myAddr: @data, out: out];      ENDLOOP;    in.delete[in]    END;  MakeRMFile: PROCEDURE [germName: LONG STRING, bootFileLocation: Boot.DiskFileID]    RETURNS [success: BOOLEAN ¬ TRUE] =    BEGIN    c:	CHARACTER ¬ '$;    tempFilename: LONG STRING ¬ z.NEW[StringBody[maxNameLength]];            IF String.Empty[germName] THEN RETURN[FALSE];        String.Copy[tempFilename, germName];    String.AppendChar[tempFilename, '$];    Write["converting germ file to real memory image..."L, tempFilename, "..."L];        BEGIN        out: Stream.Handle = MStream.WriteOnly[tempFilename, [], binary];    mapSpace: LONG POINTER = Space.ScratchMap[mapPages];        InitMap[map: mapSpace];    ProcessGerm[      germName: germName, bootFileLocation: bootFileLocation, map: mapSpace, out: out !         UnmappedMemory => {success ¬ FALSE; CONTINUE};         UNWIND => {out.delete[out]; [] ¬ Space.Unmap[mapSpace]}    ];    [] ¬ Space.Unmap[mapSpace];    -- end stream    THROUGH [0..3) DO out.putWord[out, 0] ENDLOOP;    out.delete[out];        END;    IF success THEN String.Copy[bootStrings[germ], tempFilename]    ELSE Write["aborted: boot file too big"L];    z.FREE[@tempFilename];    END;  END.  LOG  9-Mar-87  9:31:30 	MRY 	Created from FBStompTool.mesa 15-Mar-87 11:53:08	ET	Make it compile with latest FloppyTape.mesa.  				  - Took out return parameter of CreateInitialMicrocodeFile 				  - Also took out Error MissingPages 16-Mar-87 11:36:36	MRY	- Changed the copyright notice. 				- Corrected Proc MakeBootableTape to close volume before being aborted by a user request.				- Changed to open volume with readOnly in proc DisplayBootFileInfo. 21-May-87 18:22:38	MRY	- Fixed AR 10914; In GetPilotFSDope, used proc MFile.GetLength(instead of File.GetSize) to get the size of a file, and use that size to call AccessFloppyTape.CopyFromPilotFile in proc InstallFile.	 			        - Removed extra reads and writes of the root page from proc InstallFile.				- Changed proc CreateLeaderPage to store the original file name in case a user mix up with upper and lower case character when they type filename(s).   15-Jun-87 11:34:54	MRY	- Fixed AR 11098: mds relieved version of FBStomptoolDLight must process germ a bit different 				- Fixed AR 11062: support 23, 24 bit vm when it process germ file.  19-Jun-87 14:41:26 	MRY	- Edited for new floppytape.mesa 26-Jun-87 13:49:09	MRY	- made SpecialFloppyTape.ReserveDiagnosticArea user abortable. 21-Jul-87 15:23:54     RSV     - Changed sa800 to fad5000 12-Aug-87 14:40:04	MRY	- Changed the default VM size from 22 bit to 23 bit (AR 11346). 				- support 22, 23 and 24 bit VM in MakeBootTape (AR 11062)  24-Aug-87  8:53:32	MRY	- Fixed AR 11697			 30-Sep-87 13:49:10     RSV     - Fixed AR 12027 (changed CopyToNewString to Copy) 24-Oct-87 12:00:01	MRY	- Fixed AR 11762: incorrect notFormatted from FBStompToolDLight (see PROC InstallFile. 26-Oct-87 16:02:04	MRY	- Call AccessFloppyTape.GetNextDrive to get local drive. 30-Oct-87 14:20:05     RSV     - data of germ$ file should be same as germ file, to aid in debugging. 23-Nov-87 18:27:42	KEK	- added /a switch to support multiple bootfiles on a floppy tape: in new FileName items, new altBoot check in SetFloppyBootFiles, new altBootCounter in ParseCommand.  Thank you. 3-Dec-87 13:46:37	ET	 - changed ordering of files written. Diag ucode follows initucode in FileName. DisplayBootFileInfo edited to start at diagUCode instead boot.  4-Mar-88 17:50:49	JWF	- Removed references to DLionInputOutputExtraExtras for 14.0
-- FloppyTapeChecksumImpl.mesa-- JWF	28-Jan-88 18:36:53DIRECTORY  Checksum,  Exec,  Format,  QuickSort,  String,  Space,  Environment,  FloppyChannel,  FloppyDiskFace,  FloppyTape,  FloppyTapeFormat,  FloppyTapeExtras,  SpecialFloppyChannel,  SpecialFloppyChannelExtras,  Inline,  VM,  VerifyRead,  Zone,  ResidentHeap;FloppyTapeChecksumImpl: PROGRAM  IMPORTS    Checksum, Exec, Environment, QuickSort, String, Space, FloppyChannel, FloppyDiskFace, FloppyTapeExtras, SpecialFloppyChannel, SpecialFloppyChannelExtras, Inline, VM, ResidentHeap =      BEGIN<<	#########################################################	Types	######################################################### >>Status: TYPE = {Normal, NoDevice, CantGetHandle, BadRootPage, UnmarkedBadPage, Null};<<	#########################################################	Constants	######################################################### >>		bufferSize: Space.PageCount = 320;	<<	#########################################################	Variables	######################################################### >>	execHandle: Exec.Handle ¬ NIL;rootPage: FloppyTapeFormat.RootPage; -- made global for development onlygsp: Environment.Base RELATIVE POINTER;VRError: PUBLIC ERROR[error: VerifyRead.VRErrorType] = CODE;<<	#########################################################	Signals	######################################################### >>	<<	#########################################################	Procedures	######################################################### >>Write: Format.StringProc;WriteNumber: PUBLIC PROC[n: CARDINAL] =     BEGIN     s: LONG STRING ¬ [20];     String.AppendNumber[s, n, 10];     Write[s];     END;WriteLongNumber: PUBLIC PROC[n: LONG CARDINAL] =     BEGIN     s: LONG STRING ¬ [20];     String.AppendLongNumber[s, n, 10];     Write[s];     END;	PrintResult: PROC[checksum: CARDINAL] =   BEGIN   Write["\nFloppy Tape Checksum = "L];   WriteNumber[checksum];   Write["\n"L];   END;PrintError: PROC[error: FloppyDiskFace.Status] =   BEGIN      SELECT error FROM      inProgress => Write["Read Error - inProgress\n"L];      goodCompletion => Write["Read Error - goodCompletion\n"L];      diskChange => Write["Read Error - diskChange\n"L];      notReady => Write["Read Error - notReady\n"L];      cylinderError => Write["Read Error - cylinderError\n"L];      deletedData => Write["Read Error - deletedData\n"L];      recordNotFound => Write["Read Error - recordNotFound\n"L];      headerError => Write["Read Error - headerError\n"L];      dataError => Write["Read Error - dataError\n"L];      dataLost => Write["Read Error - dataLost\n"L];      writeFault => Write["Read Error - writeFault\n"L];      memoryError => Write["Read Error - memoryError\n"L];      invalidOperation => Write["Read Error - invalidOperation\n"L];      invalidOperation => Write["Read Error - aborted\n"L];      otherError => Write["Read Error - otherError\n"L];      ENDCASE => Write["Read Error - Unknown Error\n"L];         END;ChannelStatusToFaceStatus: PROC[status: FloppyChannel.Status]   RETURNS[FloppyDiskFace.Status] =   BEGIN      SELECT status FROM      goodCompletion => RETURN[goodCompletion];      diskChange => RETURN[diskChange];      notReady => RETURN[notReady];      cylinderError => RETURN[cylinderError];      deletedData => RETURN[deletedData];      recordNotFound => RETURN[recordNotFound];      headerError => RETURN[headerError];      dataError => RETURN[dataError];      dataLost => RETURN[dataLost];      writeFault => RETURN[writeFault];      otherError => RETURN[otherError];      ENDCASE => RETURN[otherError];         END;GetChecksum: Exec.ExecProc =   BEGIN   status: FloppyDiskFace.Status;   drive: FloppyTape.Drive;   handle: FloppyChannel.Handle;   checksum: CARDINAL;	    << -------------------------------------	       Set Up Exec Output	       ------------------------------------- >>      		      Write ¬ Exec.OutputProc[h];               << -------------------------------------	       Get Floppy Tape Handle	       ------------------------------------- >>         drive ¬ FloppyTapeExtras.GetNextFloppyTapeDrive[FloppyTapeExtras.nullDrive];      IF drive = FloppyChannel.nullDrive THEN      BEGIN      Write["Error -- There is no floppy tape device."L];      RETURN[];      END;         handle ¬ FloppyChannel.GetHandle[drive];            << -------------------------------------	       Calculate Checksum	       ------------------------------------- >>      [checksum, status] ¬ ComputeFloppyTapeCheckSum[handle];               << -------------------------------------	       For debugging	       ------------------------------------- >><<   Write["\nnumberOfStreams = "L];   WriteNumber[rootPage.numberOfStreams];   Write["\nnumberOfTracks = "L];   WriteNumber[rootPage.numberOfTracks];   Write["\nsectorsPerTrack = "L];   WriteNumber[rootPage.sectorsPerTrack];   Write["\nnumberOfBadPages = "L];   WriteNumber[rootPage.numberOfBadPages];   Write["\ncurrentEOT = "L];   WriteLongNumber[rootPage.currentEOT];>>	                      << -------------------------------------	       Print Result	       ------------------------------------- >>	          SELECT status FROM      goodCompletion => PrintResult[checksum];      ENDCASE => PrintError[status];      END;      SortBadPageTable: PROC[badPageTable: LONG POINTER TO   FloppyTapeFormat.BadSectorListArray,   numberOfBadPages: CARDINAL] =   BEGIN   dummy: QuickSort.ClientData ¬ NIL;      Swap: PROC [one, two: INTEGER, data: QuickSort.ClientData] = {         temp: FloppyTapeFormat.BadSectorEntry ¬ badPageTable[one];         badPageTable[one] ¬ badPageTable[two];         badPageTable[two] ¬ temp;         };	    Compare: PROC [one, two: INTEGER, data: QuickSort.ClientData]         RETURNS [QuickSort.Comparison] = 	 BEGIN	 IF PackBadSectorNumber[badPageTable[one].badSectorLow,	    badPageTable[one].badSectorHigh] <	    PackBadSectorNumber[badPageTable[two].badSectorLow,	    badPageTable[two].badSectorHigh] THEN	    RETURN[smaller]	 ELSE IF PackBadSectorNumber[badPageTable[one].badSectorLow,	    badPageTable[one].badSectorHigh] >	    PackBadSectorNumber[badPageTable[two].badSectorLow,	    badPageTable[two].badSectorHigh] THEN	    RETURN[bigger]	 ELSE	    RETURN[same];	 END;      QuickSort.Sort[0, numberOfBadPages - 1, Compare, Swap, dummy];   END;      SectorToDiskAddress: PROCEDURE [  -- IS THIS STILL CORRECT? --     sector: FloppyTape.SectorNumber, tracksPerStream: CARDINAL,    sectorsPerTrack: CARDINAL]    RETURNS [diskAddress: FloppyChannel.DiskAddress] = << INLINE >>    BEGIN    temp: CARDINAL;    [quotient: temp, remainder: diskAddress.sector] ¬ Inline.LongDivMod[       sector-1, sectorsPerTrack];    diskAddress.sector ¬ diskAddress.sector + 1; -- sectors begin at 1 --    [quotient: diskAddress.cylinder, remainder: diskAddress.head] ¬       Inline.DIVMOD[temp, tracksPerStream];    END;    DiskAddressToSector: PROCEDURE [      diskAddress: FloppyChannel.DiskAddress, streams: CARDINAL,    tracksPerStream: CARDINAL, sectorsPerTrack: CARDINAL]    RETURNS [sector: FloppyTape.SectorNumber] = INLINE {    sector ¬       diskAddress.sector +      Inline.LongMult[        sectorsPerTrack,	(diskAddress.head + tracksPerStream * diskAddress.cylinder)]};	     PackBadSectorNumber: PROCEDURE [low: FloppyTapeFormat.FilePageLow, high: FloppyTapeFormat.FilePageHigh]    RETURNS [page: FloppyTape.SectorNumber] = INLINE {    RETURN[      LOOPHOLE[Environment.LongNumber[num[lowbits: low, highbits: high]]]]};        UnpackBadSectorNumber: PROCEDURE [sector: FloppyTape.SectorNumber]    RETURNS [low: FloppyTapeFormat.FilePageLow, high: FloppyTapeFormat.FilePageHigh] = INLINE {    RETURN[low: Inline.LowHalf[sector], high: Inline.HighHalf[sector]]};LongChecksum: PROC[cs: CARDINAL ¬ 0, nWords: LONG CARDINAL, p: LONG POINTER]   RETURNS[checksum: CARDINAL] =   BEGIN      checksum ¬ cs;      WHILE nWords > LAST[CARDINAL]      DO      checksum ¬ Checksum.ComputeChecksum[checksum, LAST[CARDINAL], p];      p ¬ p + LAST[CARDINAL];      nWords ¬ nWords -  LAST[CARDINAL];      ENDLOOP;      IF nWords > 0 THEN      checksum ¬ Checksum.ComputeChecksum[checksum, CARDINAL[nWords], p];      END;ComputeFloppyTapeCheckSum: PROC[handle: FloppyChannel.Handle] RETURNS[   checksum: CARDINAL ¬ 0, status: FloppyDiskFace.Status ¬ goodCompletion] =   BEGIN      -- Constants      nullChecksum: CARDINAL = 0;   rootPageSize: CARDINAL = 1;	-- pages   badPageTableDiskAddress: FloppyChannel.DiskAddress = [0,0,2];   badPageTableSize: CARDINAL = 2;	-- pages   pageSize: CARDINAL = 256;	-- Words per sector   diagnosticAreaSize: CARDINAL = 245 * 32 * 2;	-- pages            -- Variables      buffer: Space.Interval;--   rootPage: FloppyTapeFormat.RootPage;   badPageTable: FloppyTapeFormat.BadSectorListArray;   endOfTape: FloppyTape.SectorNumber;   blockReadStartPage, blockReadEndPage: FloppyTape.SectorNumber;--   endOfDiagnostics: FloppyTape.SectorNumber;   currentBadPageEntry: CARDINAL;   iocb: FloppyDiskFace.OperationPtr;   <<     =========================================================================     Procedures     =========================================================================>>   <<     =========================================================================     This procedure skips over an arbitrary number of contiguous bad pages.     In order for it to work correctly the bad page table must be sorted and     if "pageNumber" points to a bad page then "badPageIndex" must point to     its entry in the bad page table. If the passed in page number is not a     bad page then it will be returned unchanged.     =========================================================================>>   SkipBadPages: PROC[pageNumber: FloppyTape.SectorNumber, badPageIndex: CARDINAL]      RETURNS[newPageNumber: FloppyTape.SectorNumber, newBadPageIndex: CARDINAL] =      BEGIN            newPageNumber ¬ pageNumber;      newBadPageIndex ¬ badPageIndex;            WHILE newBadPageIndex < rootPage.numberOfBadPages AND         newPageNumber = PackBadSectorNumber[	 badPageTable[newBadPageIndex].badSectorLow,	 badPageTable[newBadPageIndex].badSectorHigh]	 DO	 newPageNumber ¬ newPageNumber + 1;	 newBadPageIndex ¬ newBadPageIndex + 1;	 ENDLOOP;	       END;      <<     =========================================================================     This procedure converts a bad page table index into the page number     which it points to.     =========================================================================>>   BadPage: PROC[badPageIndex: CARDINAL]      RETURNS[newPageNumber: FloppyTape.SectorNumber]=      BEGIN            newPageNumber ¬ PackBadSectorNumber[	 badPageTable[badPageIndex].badSectorLow,	 badPageTable[badPageIndex].badSectorHigh];            END;<<     =========================================================================     This procedure duplicates the FloppyChannel.ReadSectors command using     SpecialFloppyChannel.DoDirectIO for increased performance.     =========================================================================>>   ReadSectors: PROCEDURE [handle: FloppyChannel.Handle,      address: FloppyChannel.DiskAddress,       buffer: LONG POINTER, count: CARDINAL ¬ 1,      iocb: FloppyDiskFace.OperationPtr]      RETURNS [status: FloppyDiskFace.Status] =          BEGIN            << -------------------------------------	       Set Up IOCB	       ------------------------------------- >>            iocb.device ¬ SpecialFloppyChannelExtras.GetDeviceHandle[handle];      iocb.function ¬ readSector;             iocb.address ¬ LOOPHOLE[address, FloppyDiskFace.DiskAddress];      iocb.dataPtr ¬ buffer;      iocb.incrementDataPointer ¬ TRUE;      iocb.tries ¬ FloppyDiskFace.SuggestedTries[         SpecialFloppyChannelExtras.GetDeviceHandle[handle]];      iocb.count ¬ count;                  << -------------------------------------	       Do Read Operation	       ------------------------------------- >>                  [status,,] ¬ SpecialFloppyChannel.DoDirectIO[iocb];            END;      <<     =========================================================================     These procedures allocate storage which is in real memory.     =========================================================================>>  AllocIOCB: PROCEDURE [wds: CARDINAL] RETURNS [p: LONG POINTER] =    BEGIN     status: Zone.Status;    IF wds = 0 THEN RETURN[NIL];    [gsp, status] ¬ ResidentHeap.MakeNode[      n: wds, alignment: FloppyDiskFace.operationAlignment];    IF status # okay THEN VRError[allocBug];    RETURN[@Environment.first64K[gsp]];    END;  --AllocIOCB    CreateResidentBuffer: PROCEDURE [size: Space.PageCount]    RETURNS [buffer: Space.Interval]  =    BEGIN    buffer ¬ Space.Allocate[size ! 	  Space.InsufficientSpace => GO TO return;  	  Space.Error => GO TO return]; 		     VM.ScratchMap[	[Environment.PageFromLongPointer[buffer.pointer], buffer.count]];      EXITS      return => RETURN[Space.nullInterval];    END;  --CreateResidentBuffer<<     =========================================================================     These procedures deallocate storage.     =========================================================================>>    DeAllocIOCB: PROCEDURE [p: LONG POINTER] =     BEGIN    status: Zone.Status ¬ ResidentHeap.FreeNode[gsp];    IF status # okay THEN VRError[deAllocBug];  --call debug?    END;  --DeAllocIOCB      DestroyResidentBuffer: PROCEDURE [buffer: Space.Interval] =     BEGIN    VM.Unmap[Environment.PageFromLongPointer[buffer.pointer]];    Space.Deallocate[buffer !	    Space.Error => CONTINUE];	     END;  --DestroyResidentBuffer<<     =========================================================================     Start Of Code     =========================================================================>>               << -------------------------------------	       Set Context	       ------------------------------------- >>	          FloppyDiskFace.DiskChangeClear[   SpecialFloppyChannelExtras.GetDeviceHandle[handle]];   IF NOT FloppyChannel.SetContext[handle,      FloppyTapeFormat.floppyTapeContext] THEN      BEGIN      RETURN[nullChecksum, otherError];      END;             << -------------------------------------	       Allocate Space For Tape Data And IOCB	       ------------------------------------- >>	          iocb ¬ AllocIOCB[FloppyDiskFace.operationBlockLength];              buffer ¬ CreateResidentBuffer[bufferSize];                      << -------------------------------------	       Read Root Page	       ------------------------------------- >>                [status] ¬ ChannelStatusToFaceStatus[       FloppyChannel.ReadSectors[handle,       FloppyTapeFormat.rootPageDiskAddress, @rootPage, rootPageSize].status];      IF status # goodCompletion THEN      BEGIN      DeAllocIOCB[iocb];      DestroyResidentBuffer[buffer];      RETURN[nullChecksum, status];      END;                  << -------------------------------------	       Read Bad Page Table	       ------------------------------------- >>         [status] ¬ ChannelStatusToFaceStatus[      FloppyChannel.ReadSectors[handle,      badPageTableDiskAddress, @badPageTable, badPageTableSize].status];         IF status # goodCompletion THEN      BEGIN      DeAllocIOCB[iocb];      DestroyResidentBuffer[buffer];      RETURN[nullChecksum, status]      END;            << -------------------------------------	       Sort Bad Page Table	       ------------------------------------- >>	          SortBadPageTable[@badPageTable, rootPage.numberOfBadPages];                  << -------------------------------------	       Calculate Last Used Sector On Tape	       ------------------------------------- >>	          endOfTape ¬ rootPage.currentEOT - 1;      FOR badSectorLoopIndex: CARDINAL IN [0..rootPage.numberOfBadPages)      DO      IF badPageTable[badSectorLoopIndex].typeOfBadPage = beforeFileWritten THEN         endOfTape ¬ endOfTape + 1;      ENDLOOP;               << -------------------------------------	       Initialize Loop Variables	       ------------------------------------- >>      blockReadStartPage ¬ blockReadEndPage ¬ 1;   currentBadPageEntry ¬ 0;   checksum ¬ 0;      [blockReadStartPage, currentBadPageEntry] ¬ SkipBadPages[blockReadStartPage,    currentBadPageEntry];               << -------------------------------------	       Calculate Checksum	       ------------------------------------- >>	          WHILE blockReadStartPage <= endOfTape      DO            blockReadEndPage ¬ blockReadStartPage + bufferSize - 1;            IF currentBadPageEntry < rootPage.numberOfBadPages AND	 BadPage[currentBadPageEntry] <= blockReadEndPage THEN	 BEGIN	 blockReadEndPage ¬ BadPage[currentBadPageEntry] - 1;	 END;            IF blockReadEndPage > endOfTape THEN         BEGIN	 blockReadEndPage ¬ endOfTape;	 END;	       [status] ¬ ReadSectors[handle,         SectorToDiskAddress[blockReadStartPage, rootPage.numberOfTracks,	 rootPage.sectorsPerTrack],         buffer.pointer, CARDINAL[blockReadEndPage - blockReadStartPage + 1], iocb];            IF status # goodCompletion THEN         BEGIN	 DeAllocIOCB[iocb];         DestroyResidentBuffer[buffer];	 RETURN[nullChecksum, status];	 END;	       checksum ¬ LongChecksum[checksum, 	 (blockReadEndPage - blockReadStartPage + 1) * pageSize, buffer.pointer];            [blockReadStartPage, currentBadPageEntry] ¬ SkipBadPages[         blockReadEndPage + 1, currentBadPageEntry];            ENDLOOP; <<     =========================================================================     This code was removed because it was decided that the diagnostic     streams should not be included in the checksum. JWF 17-Dec-87 16:12:10     =========================================================================	                 << -------------------------------------	       If diagnostic tape then add	       streams 6 & 7 to checksum	       ------------------------------------- >>   IF rootPage.numberOfStreams <      FloppyTapeFormat.firstDiagnosticCylinder.cylinder THEN      BEGIN            blockReadStartPage ¬         DiskAddressToSector[FloppyTapeFormat.firstDiagnosticCylinder,	 rootPage.numberOfStreams, rootPage.numberOfTracks, 	 rootPage.sectorsPerTrack];	       endOfDiagnostics ¬ blockReadStartPage + diagnosticAreaSize - 1;	       currentBadPageEntry ¬ 0;            WHILE currentBadPageEntry < rootPage.numberOfBadPages AND         BadPage[currentBadPageEntry] < blockReadStartPage	 DO	 currentBadPageEntry ¬ currentBadPageEntry + 1;	 ENDLOOP;	       [blockReadStartPage, currentBadPageEntry] ¬ SkipBadPages[blockReadStartPage,    currentBadPageEntry];                << -------------------------------------	       Calculate Checksum	       ------------------------------------- >>	          WHILE blockReadStartPage <= endOfDiagnostics      DO            blockReadEndPage ¬ blockReadStartPage + bufferSize - 1;            IF currentBadPageEntry < rootPage.numberOfBadPages AND	 BadPage[currentBadPageEntry] <= blockReadEndPage THEN	 BEGIN	 blockReadEndPage ¬ BadPage[currentBadPageEntry] - 1;	 END;            IF blockReadEndPage > endOfDiagnostics THEN         BEGIN	 blockReadEndPage ¬ endOfDiagnostics;	 END;	       [status] ¬ ReadSectors[handle,         SectorToDiskAddress[blockReadStartPage, rootPage.numberOfTracks,	 rootPage.sectorsPerTrack],         buffer.pointer, CARDINAL[blockReadEndPage - blockReadStartPage + 1], iocb];            IF status # goodCompletion THEN         BEGIN	 DeAllocIOCB[iocb];         DestroyResidentBuffer[buffer];	 RETURN[nullChecksum, status];	 END;	       checksum ¬ LongChecksum[checksum, 	 (blockReadEndPage - blockReadStartPage + 1) * pageSize, buffer];            [blockReadStartPage, currentBadPageEntry] ¬ SkipBadPages[         blockReadEndPage + 1, currentBadPageEntry];            ENDLOOP;	 	       END;     =========================================================================         End of commented out section     =========================================================================     >>         DeAllocIOCB[iocb];   DestroyResidentBuffer[buffer];         END;           Help: Exec.ExecProc =    BEGIN    OutputProc: Format.StringProc ¬ Exec.OutputProc[h];    h.OutputProc[][    "FTChecksum computes the checksum of the tape currently in the floppy tape drive.\n"L]    END;    Exec.AddCommand["FTChecksum"L, GetChecksum, Help];   END...
-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.-- FloppyTapeExec.mesa                23-Nov-87 18:57:59 by KEKDIRECTORY  AccessFloppyTape USING [    anyName, anyType, Attributes, AttributesRecord, ClientWord, Close,    CopyFromPilotFile, CopyToPilotFile, currentAttributeVersion, DeviceReady,    Drive, Enumerate, EnumProc, Error, ErrorType, FileHandle,    fileTypeForLeaderPage, GetAttributes, GetNextDrive, GetNextFile,    GetVolumeAttributes, InconsistentFile, InvalidVersion, Label,    leaderPages, --localDrive,-- maxClientDataWords, maxNameLength, NoDirectory,    NoLeaderPage, NoRoomForClientData, Open, OverWriteFromPilotFile,    VolumeHandle, Writable],  Ascii USING [CR],  ClientFloppyData USING [dataVersion],  Environment USING [bytesPerPage],  Exec USING [    AddCommand, CheckForAbort, Confirm, ExecProc, FreeTokenString, GetToken,    GetTTY, ReleaseTTY, Handle, Outcome, OutputProc],  File USING [Type],  FileTypes USING [tUntypedFile],  FloppyTape USING [    AlreadyFormatted, Erase, Error, ErrorType, FileHandleFromID,    FileID, FeedBack, FeedBackPtr, Format, IOError, maxBytesInName,    nullFileID, Retention, Scavenge],  Format USING [    Char, Date, Decimal, Line, LongDecimal, LongNumber, Number, StringProc],  Heap USING [systemZone],  MakeBootTape USING [    MakeBootableTape, DisplayBootFileInfo, ReserveDiagnosticTrack],  MFile USING [    Error, ErrorCode, GetProperties, Handle, ReadOnly, Release, SetProperties,    Type, WriteOnly],  NSString USING [String, StringFromMesaString],  Process USING [Abort, Detach, GetCurrent, MsecToTicks, Pause],  SpecialMFile USING [GetCapaWithAccess, LeaderPages],  String USING [    AppendString, Equivalent, InvalidNumber, StringToNumber, StringToLongNumber],  StringLookUp USING [InTable, noMatch],  Time USING [Current],  TTY USING [GetChar, Handle],  Volume USING [InsufficientSpace];FloppyTapeExec: PROGRAM  IMPORTS    AccessFloppyTape, Exec, FloppyTape, Format, Heap, MFile, MakeBootTape,    NSString, Process, SpecialMFile, String, StringLookUp, Time, TTY, Volume =  BEGIN  label: AccessFloppyTape.Label ¬ [FloppyTape.maxBytesInName];  clientWord: AccessFloppyTape.ClientWord;  localDrive: AccessFloppyTape.Drive;  Abort: ERROR [s: LONG STRING] = CODE;  SetOutcome: SIGNAL [value: Exec.Outcome] = CODE;  EraseFloppyTape: PROCEDURE [h: Exec.Handle] =    BEGIN    ENABLE UNWIND => NULL;    Write: Format.StringProc = Exec.OutputProc[h];    arg, switches: LONG STRING ¬ NIL;    writeEnable: BOOLEAN;    label.length ¬ 0;    clientWord ¬ 0;    writeEnable ¬ AccessFloppyTape.Writable[drive: localDrive];    IF NOT (writeEnable) THEN {      Format.Line[Write, "Cannot Erase... FloppyTape Write-Disabled."L];      SetOutcome[abort]};    DO      arg ¬ Exec.FreeTokenString[arg];      switches ¬ Exec.FreeTokenString[switches];      [arg, switches] ¬ Exec.GetToken[h];      IF arg = NIL AND switches = NIL THEN EXIT;      IF switches = NIL THEN LOOP;      FOR i: CARDINAL IN [0..switches.length) DO        SELECT switches[i] FROM          'n => {            label.length ¬ 0;            FOR j: CARDINAL IN [0..label.length ¬ MIN[arg.length, label.maxlength])              DO label[j] ¬ arg[j]; ENDLOOP};          'c => clientWord ¬ String.StringToNumber[arg];          ENDCASE => {            Format.Char[Write, switches[i]];            Format.Line[Write, " ..an Invalid Switch"L];            SetOutcome[abort]};        ENDLOOP;      ENDLOOP;    arg ¬ Exec.FreeTokenString[arg];    switches ¬ Exec.FreeTokenString[switches];    Write["Erasing will destroy previous contents."L];    IF ~Exec.Confirm[h] THEN ERROR Abort[NIL];    Write["Erasing can take up to 90 seconds.  "L];    Write["Erasing... "L];    FloppyTape.Erase[      localDrive, IF label.length = 0 THEN NIL ELSE label,      clientWord ! UNWIND => {Write["Cannot Erase..."L]}];    Format.Line[Write, "...done"L];    Write["Do you wish to reserve diagnostic tracks?"L];    IF Exec.Confirm[h] THEN {      IF MakeBootTape.ReserveDiagnosticTrack[h].outcome = abort THEN        SetOutcome[abort];      }    END;  FormatFloppyTape: PROCEDURE [h: Exec.Handle] =    BEGIN    ENABLE UNWIND => NULL;    Write: Format.StringProc = Exec.OutputProc[h];    arg, switches: LONG STRING ¬ NIL;    writeEnable: BOOLEAN;    feedBack: FloppyTape.FeedBack;    feedBackPtr: FloppyTape.FeedBackPtr ¬ @feedBack;    abortFeedBack: BOOLEAN ¬ FALSE;        DisplayFeedback: PROCEDURE [procID: PROCESS] =     BEGIN    oldFeedBack: FloppyTape.FeedBack ¬ none;    WHILE ~abortFeedBack DO      IF Exec.CheckForAbort[h] THEN {        Write["abort requested... "L]; 	Process.Abort[procID];	EXIT};      IF oldFeedBack # feedBackPtr­ THEN	BEGIN	oldFeedBack ¬ feedBackPtr­;	SELECT oldFeedBack FROM	  retentionPass  => Write["retention pass... "L];	  formatPass     => Write["format pass... "L];	  verifyPass     => Write["verifyFormat pass... "L];	  ENDCASE;	END;      Process.Pause[Process.MsecToTicks[1000]];      ENDLOOP;    END;    label.length ¬ 0;    String.AppendString[label, "UnnamedFloppyTape"L];    clientWord ¬ 0;    writeEnable ¬ AccessFloppyTape.Writable[drive: localDrive];    IF NOT (writeEnable) THEN {      Format.Line[Write, "Cannot Format... FloppyTape Write-Disabled."L];      SetOutcome[abort]};    DO      arg ¬ Exec.FreeTokenString[arg];      switches ¬ Exec.FreeTokenString[switches];      [arg, switches] ¬ Exec.GetToken[h];      IF arg = NIL AND switches = NIL THEN EXIT;      IF switches = NIL THEN LOOP;      FOR i: CARDINAL IN [0..switches.length) DO        SELECT switches[i] FROM          'n => {            label.length ¬ 0;            FOR j: CARDINAL IN [0..label.length ¬ MIN[arg.length, label.maxlength])              DO label[j] ¬ arg[j]; ENDLOOP};          'c => clientWord ¬ String.StringToNumber[arg];          ENDCASE => {            Format.Char[Write, switches[i]];            Format.Line[Write, " ..an Invalid Switch"L];            SetOutcome[abort];            };        ENDLOOP;      ENDLOOP;    arg ¬ Exec.FreeTokenString[arg];    switches ¬ Exec.FreeTokenString[switches];    Write["Formatting can take up to 40 minutes. "L];    IF ~Exec.Confirm[h] THEN ERROR Abort[NIL];    Format.Line[Write, " yes"L];    Write["Formatting begins... "L];        BEGIN    ENABLE ABORTED => {Write["Aborted."L]; abortFeedBack ¬ TRUE; GOTO exit};    Process.Detach[FORK DisplayFeedback[Process.GetCurrent[]]];    FloppyTape.Format[      localDrive, label, clientWord, feedBackPtr !      FloppyTape.Error => {        abortFeedBack ¬ TRUE;        IF error = badTape THEN          ERROR Abort["Can't format this floppytape; may be a bad Tape"L]};      FloppyTape.AlreadyFormatted => {        Write["FloppyTape already formatted; formatting will destroy previous contents"L];        IF ~Exec.Confirm[h] THEN {abortFeedBack ¬ TRUE; ERROR Abort[NIL]}	ELSE RESUME[]}       ];        END;        abortFeedBack ¬ TRUE;    Format.Line[Write, "done"L];    InfoFloppyTape[h];    Write["Do you wish to reserve diagnostic tracks?"L];    IF Exec.Confirm[h] THEN {      IF MakeBootTape.ReserveDiagnosticTrack[h].outcome = abort THEN        SetOutcome[abort];      }    EXITS exit => NULL;    END;  Help: Exec.ExecProc =    BEGIN    Write: Format.StringProc = Exec.OutputProc[h];    ttyhandle: TTY.Handle ¬ Exec.GetTTY[h];    Format.Char[Write, Ascii.CR];    Format.Line[Write, "FloppyTape.~ <command> <args>"L];    Format.Line[Write, "<args>:"L];    Format.Line[      Write,      "    <fileList>: list of file names; /s on a name uses next name as destination"L];    Format.Line[Write, "    <wildList>: names may contain * and #"L];    Format.Line[Write, "<command>:"L];    Format.Line[      Write, "   Read <fileList> | <wildList> - copies files from floppytape."L];    Format.Line[      Write, "   Write number/t <fileList> - copies files to floppytape."L];    Format.Line[      Write,      "      number/t sets File.Type for following files (default tUntypedFile)"L];    Format.Line[      Write,      "   Overwrite number/t <fileId>/i <file> - overwrites the floppytape file "L];    Format.Line[      Write,      "      identified by <fileId> only if floppytape file length >= rigid disk file"L];    Format.Line[Write, "      length. number/t sets the File.Type."L];    Format.Line[Write, "   List/lptidwv <wildList> - shows files on floppytape"L];    Format.Line[Write, "      switches show:"L];    Format.Line[      Write,      "         l => length in bytes, p => length in pages, t => type, i => FileID"L];    Format.Line[      Write, "         d => create date, w => write date, v => everything"L];    Format.Line[Write, "   Info - gives information about the floppytape volume"L];    Format.Line[Write, "   Retention - retentions the floppytape."L];    Format.Line[Write, "   Scavenge -  scavenges the floppytape."L];    Format.Char[Write, Ascii.CR];    Format.Line[Write, "Type any key to proceed ...."L];    [] ¬ TTY.GetChar[ttyhandle];    Exec.ReleaseTTY[ttyhandle];    Format.Line[      Write,      "   Erase <name>/n <clientWord>/c - removes contents of floppytape without "L];    Format.Line[Write, "      reformatting. args: "L];    Format.Line[      Write,      "      name: gives the volume a name (quote names with special characters)."L];    Format.Line[      Write, "      If name is not specified, the existing name is retained."L];    Format.Line[      Write, "      clientWord: is a client specified word of information"L];    Format.Line[      Write,      "   Format <name>/n <clientWord>/c - formats floppytape, destroying previous"L];    Format.Line[Write, "      contents. args:"L];    Format.Line[      Write,      "      name: gives the volume a name (quote names with special characters). "L];    Format.Line[      Write, "      clientWord: is a client specified word of information."L];    Format.Line[      Write,      "   BootInfo - gives information about the boot files on the cartridge tape"L];    Format.Line[      Write, "   MakeBootTape <filename1>/<switch> <filename2>/<switch>....<vm size>/v "L];    Format.Line[      Write,      "      - create a bootable tape with the files supplied; switches indicate: "L];    Format.Line[      Write, "      i - initial uCode, p - pilot uCode, g - germ file,"L];    Format.Line[Write, "      b - physical boot file, d - diagnostic uCode,"L];    Format.Line[Write, "      a - alternate boot file."L];    Format.Line[Write, "      <vm size>/v sets the size of the virtual memory."L];    Format.Line[Write, "      <vm size> can be 22, 23 or 24 bit; default is 23."L];    END;  InfoFloppyTape: PROCEDURE [h: Exec.Handle] =    BEGIN    ENABLE UNWIND => NULL;    rootFile: FloppyTape.FileID;    freeSpace: LONG CARDINAL;    usedSpace: LONG CARDINAL;    drive: AccessFloppyTape.Drive;    numberOfBadSectors: CARDINAL;    writeEnable, ready: BOOLEAN;    Write: Format.StringProc = Exec.OutputProc[h];    v: AccessFloppyTape.VolumeHandle;    ready ¬ AccessFloppyTape.DeviceReady[drive: localDrive];    IF NOT (ready) THEN Format.Line[Write, " Drive NOT Ready "]    ELSE      BEGIN      v ¬ AccessFloppyTape.Open[        localDrive, TRUE, exclusive, NIL !        AccessFloppyTape.Error => ERROR Abort["Can't open floppytape"L];        AccessFloppyTape.NoDirectory => RESUME];      [freeSpace: freeSpace, usedSpace: usedSpace, rootFile: rootFile,        clientWord: clientWord, drive: drive, numberOfBadSectors: numberOfBadSectors] ¬	AccessFloppyTape.GetVolumeAttributes[volume: v, label: label];      Write["FloppyTape """L];      Write[label];      Write[""", "L];      Write["Client Word = "];      Format.Decimal[Write, LOOPHOLE[clientWord]];      Format.Char[Write, Ascii.CR];      Format.LongDecimal[Write, freeSpace];      Write[" bytes free, "];      Format.Decimal[Write, numberOfBadSectors];      Format.Line[Write," bad sectors"L];      writeEnable ¬ AccessFloppyTape.Writable[drive: localDrive];      IF writeEnable THEN Write["FloppyTape Write-Enabled"]      ELSE Write["FloppyTape Write-Disabled"];      AccessFloppyTape.Close[v];      END;    END;  ListFiles: PROCEDURE [gSwitches: LONG STRING, h: Exec.Handle] =    BEGIN    ENABLE UNWIND => NULL;    Item: TYPE = {fileId, lengthInBytes, lengthInPages, create, write, type};    show: PACKED ARRAY Item OF BOOLEAN ¬ ALL[FALSE];    pattern: LONG STRING ¬ NIL;    nsPattern: NSString.String;    Write: Format.StringProc = Exec.OutputProc[h];    v: AccessFloppyTape.VolumeHandle;    ListOne: AccessFloppyTape.EnumProc =      BEGIN      name: LONG STRING = LOOPHOLE[@attributes.common.nameLength];      IF Exec.CheckForAbort[h] THEN SetOutcome[abort];      Write[name];      IF show[fileId] THEN {        Write["	FileID: "L];        Format.LongNumber[Write, LOOPHOLE[file.file], [10, FALSE, TRUE, 0]];        };      IF show[lengthInBytes] THEN {        Format.LongNumber[Write, attributes.totalBytes, [10, FALSE, TRUE, 9]];        Write[" bytes"L];        };      IF show[lengthInPages] THEN {        Format.LongNumber[          Write, attributes.totalPages + AccessFloppyTape.leaderPages, [          10, FALSE, TRUE, 6]];        Write[" pages"L];        };      IF show[type] THEN {        Write[" Type: "L];        Format.LongNumber[Write, attributes.common.type, [10, FALSE, TRUE, 0]];        };      IF show[create] THEN {        Write["  create: "L]; Format.Date[Write, attributes.common.created, full]};      IF show[write] THEN {        Write["  write: "L]; Format.Date[Write, attributes.common.copied, full]};      Format.Char[Write, Ascii.CR];      END; --ListOne    v ¬ AccessFloppyTape.Open[      localDrive, TRUE, exclusive, NIL !      AccessFloppyTape.Error => ERROR Abort["Can't open floppytape"L];      AccessFloppyTape.NoDirectory => RESUME];    IF gSwitches # NIL THEN      FOR i: CARDINAL IN [0..gSwitches.length) DO        SELECT gSwitches[i] FROM          'd => show[create] ¬ TRUE;          'i => show[fileId] ¬ TRUE;          'l => show[lengthInBytes] ¬ TRUE;          'p => show[lengthInPages] ¬ TRUE;          't => show[type] ¬ TRUE;          'w => show[write] ¬ TRUE;          'v => show ¬ ALL[TRUE];          ENDCASE => {            Format.Char[Write, gSwitches[i]];            Format.Line[Write, " ..an Invalid Switch"L];            };        ENDLOOP;    BEGIN    ENABLE      UNWIND => {        pattern ¬ Exec.FreeTokenString[pattern];        AccessFloppyTape.Close[v ! FloppyTape.Error => CONTINUE]};    [pattern, gSwitches] ¬ Exec.GetToken[h];    gSwitches ¬ Exec.FreeTokenString[gSwitches];    nsPattern ¬      IF pattern = NIL THEN AccessFloppyTape.anyName      ELSE NSString.StringFromMesaString[s: pattern];    AccessFloppyTape.Enumerate[      v, nsPattern, AccessFloppyTape.anyType, --allFiles--,ListOne !      AccessFloppyTape.NoLeaderPage => RESUME []];    pattern ¬ Exec.FreeTokenString[pattern];    AccessFloppyTape.Close[v];    END;    END; -- List  MakeAttributes: PROCEDURE [    file: MFile.Handle, name: LONG STRING, attributes: AccessFloppyTape.Attributes,    type: File.Type] =    BEGIN    attributes.common.attributeVersion ¬ AccessFloppyTape.currentAttributeVersion;    attributes.common.type ¬ type;    attributes.common.copied ¬ Time.Current[];    attributes.common.name ¬ ALL[0];    attributes.clientDataLength ¬ 2;    attributes.clientData[0] ¬ ClientFloppyData.dataVersion;    [length: attributes.totalBytes, create: attributes.common.created,      type: attributes.clientData[1]] ¬ MFile.GetProperties[file];    attributes.common.flags.creator ¬ tajo;    attributes.common.modified ¬ attributes.common.created;    attributes.totalPages ¬ PagesFromBytes[attributes.totalBytes];    attributes.segmentPages ¬ attributes.totalPages;    attributes.segmentOffset ¬ 0;    attributes.common.nameLength ¬ MIN[      name.length, AccessFloppyTape.maxNameLength];    FOR i: CARDINAL IN [0..attributes.common.nameLength) DO      attributes.common.name[i] ¬ LOOPHOLE[name[i]]; ENDLOOP    END; -- MakeAttributes  NameFromAttributes: PROCEDURE [attributes: AccessFloppyTape.Attributes]    RETURNS [LONG STRING] = INLINE {    RETURN[LOOPHOLE[@attributes.common.nameLength]]};  PagesFromBytes: PROCEDURE [bytes: LONG CARDINAL] RETURNS [LONG CARDINAL] =    BEGIN    RETURN[(bytes + Environment.bytesPerPage - 1) / Environment.bytesPerPage];    END; -- PagesFromBytes  OverWriteFile: PROCEDURE [h: Exec.Handle] =    BEGIN    ENABLE UNWIND => NULL;    attributes, oldAttributes: AccessFloppyTape.Attributes ¬ NIL;    name, altName, switches: LONG STRING ¬ NIL;    fileType: File.Type ¬ FileTypes.tUntypedFile;    mFile: MFile.Handle;    v: AccessFloppyTape.VolumeHandle;    Write: Format.StringProc = Exec.OutputProc[h];    fileId: FloppyTape.FileID;    v ¬ AccessFloppyTape.Open[      localDrive, FALSE, exclusive, NIL !      AccessFloppyTape.Error => ERROR Abort["Can't open floppytape"L];      AccessFloppyTape.NoDirectory => RESUME];    DO      ENABLE        UNWIND => {          name ¬ Exec.FreeTokenString[name];          switches ¬ Exec.FreeTokenString[switches];          IF mFile # NIL THEN MFile.Release[mFile];          Heap.systemZone.FREE[@attributes];          AccessFloppyTape.Close[v ! FloppyTape.Error => CONTINUE]};	        fFile: AccessFloppyTape.FileHandle ¬ [TRASH, FloppyTape.nullFileID];      mFileError: MFile.ErrorCode;      IF Exec.CheckForAbort[h] THEN SetOutcome[abort];      IF attributes = NIL THEN        attributes ¬ Heap.systemZone.NEW[          AccessFloppyTape.AttributesRecord[	    AccessFloppyTape.maxClientDataWords]];      IF oldAttributes = NIL THEN        oldAttributes ¬ Heap.systemZone.NEW[          AccessFloppyTape.AttributesRecord[	    AccessFloppyTape.maxClientDataWords]];      mFile ¬ NIL;      name ¬ Exec.FreeTokenString[name];      switches ¬ Exec.FreeTokenString[switches];      [name, switches] ¬ Exec.GetToken[h];      IF name = NIL AND switches = NIL THEN {        IF mFile # NIL THEN MFile.Release[mFile]; EXIT};      IF switches # NIL AND switches.length # 0 THEN        SELECT switches[0] FROM          'i => {            fileId ¬ LOOPHOLE[String.StringToLongNumber[              name ! String.InvalidNumber => CONTINUE]];            switches ¬ Exec.FreeTokenString[switches];            LOOP};          't => {            fileType ¬ [              String.StringToNumber[name ! String.InvalidNumber => CONTINUE]];            switches ¬ Exec.FreeTokenString[switches];            LOOP};          ENDCASE => {            Format.Char[Write, switches[0]];            Format.Line[Write, " ..an Invalid Switch"L];            SetOutcome[abort];            };      IF name = NIL THEN {        Format.Line[Write, ".. no filename specified"]; SetOutcome[abort]};      mFile ¬ MFile.ReadOnly[        name, [] ! MFile.Error => {mFileError ¬ code; CONTINUE}];      IF mFile = NIL THEN {        Write[name];        Write["... "L];        SELECT mFileError FROM          noSuchFile => {Format.Line[Write, " Not Found"L]; SetOutcome[abort]};          conflictingAccess => {            Format.Line[Write, " Conflicting Access to this file"L];            SetOutcome[abort]};          illegalName => {            Format.Line[Write, " Illegal File name"L]; SetOutcome[abort]};          insufficientAccess => {            Format.Line[Write, " Insufficient Access to this File"L];            SetOutcome[abort]};          nullAccess => {            Format.Line[Write, " Null Access to this File"L]; SetOutcome[abort]};          protectionFault => {            Format.Line[Write, " Protection Fault in accessing this File"L];            SetOutcome[abort]};          noSuchDirectory => {            Format.Line[              Write,              " You are attempting to access a directory that does not exist"L];            SetOutcome[abort]};          noRootDirectory => {            Format.Line[              Write,              " There is no development environment directory on this Rigid Disk Volume"L];            SetOutcome[abort]};          noRoomOnVolume => {            Format.Line[Write, " There is no room on Rigid Disk Volume"L];            SetOutcome[abort]};          noSuchVolume => {            Format.Line[Write, " There is no such Rigid Disk Volume"L];            SetOutcome[abort]};          volumeNotOpen => {            Format.Line[              Write,              " Rigid Disk Volume opened read only or unopened disk Volume"L];            SetOutcome[abort]};          ENDCASE => ERROR Abort[" unexpected MFile Error"L];        };      MakeAttributes[mFile, name, attributes, fileType];      Write[name];      Write["... "L];      Write["overwriting tapefile with fileId "L];      Format.LongNumber[Write, LOOPHOLE[fileId], [10, FALSE, TRUE, 0]];      Write["... "L];      fFile ¬ FloppyTape.FileHandleFromID[fileId, v];      AccessFloppyTape.GetAttributes[        fFile, oldAttributes !        AccessFloppyTape.NoLeaderPage =>          ERROR Abort["No Leader Page of existing FloppyTape file"L];        AccessFloppyTape.Error => ERROR Abort["FloppyTape file not found"L]];      IF attributes.totalPages <= oldAttributes.totalPages THEN        AccessFloppyTape.OverWriteFromPilotFile[          pilotFile: SpecialMFile.GetCapaWithAccess[mFile], tapefile: fFile,          firstPilotPage: SpecialMFile.LeaderPages[],          pageCount: attributes.totalPages, attributes: attributes]      ELSE ERROR Abort["Disk File too big, Can't overwrite floppytape file"L];      Format.Line[Write, "overwritten"L];      MFile.Release[mFile];      mFile ¬ NIL;      ENDLOOP;    Heap.systemZone.FREE[@attributes];    AccessFloppyTape.Close[v];    END;-- OverWriteFile  ReadFiles: PROCEDURE [h: Exec.Handle] =    BEGIN    ENABLE UNWIND => NULL;    attributes: AccessFloppyTape.Attributes ¬ NIL;    name, altName, switches: LONG STRING ¬ NIL;    nsPattern: NSString.String;    Write: Format.StringProc = Exec.OutputProc[h];    v: AccessFloppyTape.VolumeHandle ¬ AccessFloppyTape.Open[      localDrive, TRUE, exclusive, NIL !      AccessFloppyTape.Error => ERROR Abort["Can't open floppytape"L];      AccessFloppyTape.NoDirectory => RESUME];    nullFile: AccessFloppyTape.FileHandle = [      volume: v, file: FloppyTape.nullFileID];    ReadOneFile: AccessFloppyTape.EnumProc =      BEGIN      name: LONG STRING = LOOPHOLE[@attributes.common.nameLength];      mFile: MFile.Handle;      type: MFile.Type ¬ unknown;      destName: LONG STRING = IF altName = NIL THEN name ELSE altName;      IF Exec.CheckForAbort[h] THEN SetOutcome[abort];      Write[name];      Write["... "L];      IF attributes.clientDataLength = 2        AND attributes.clientData[0] = ClientFloppyData.dataVersion THEN        type ¬ attributes.clientData[1];      Write["copying to "L];      Write[destName];      Write["... "L];      mFile ¬ MFile.WriteOnly[        destName, [], type, attributes.totalBytes !        MFile.Error => {          Write[name];          Write["... "L];          SELECT code FROM            conflictingAccess => {              Format.Line[Write, " Conflicting Access to this file"L];              SetOutcome[error];              GOTO return};            illegalName => {              Format.Line[Write, " Illegal File name"L];              SetOutcome[error];              GOTO return};            insufficientAccess => {              Format.Line[Write, " Insufficient Access to this File"L];              SetOutcome[error];              GOTO return};            nullAccess => {              Format.Line[Write, " Null Access to this File"L];              SetOutcome[error];              GOTO return};            protectionFault => {              Format.Line[Write, " Protection Fault in accessing this File"L];              SetOutcome[error];              GOTO return};            directoryFull => {              Format.Line[Write, " There is no more room in the directory"L];              SetOutcome[error];              GOTO return};            noRootDirectory => {              Format.Line[                Write,                " There is no development environment directory on this Rigid Disk Volume"L];              SetOutcome[abort]};            noRoomOnVolume => {              Format.Line[Write, " There is no room on Rigid Disk Volume"L];              SetOutcome[abort]};            noSuchVolume => {              Format.Line[Write, " There is no such Rigid Disk Volume"L];              SetOutcome[abort]};            volumeNotOpen => {              Format.Line[                Write,                " Rigid Disk Volume opened read only or unopened disk Volume"L];              SetOutcome[abort]};            ENDCASE => ERROR Abort[" unexpected MFile Error"L];          }];      MFile.SetProperties[        file: mFile, type: type, length: attributes.totalBytes,        create: attributes.common.created];      IF (attributes.totalPages) # 0 THEN        AccessFloppyTape.CopyToPilotFile[          floppyTapeFile: file, pilotFile: SpecialMFile.GetCapaWithAccess[mFile],          firstFloppyTapePage: AccessFloppyTape.leaderPages,          firstPilotPage: SpecialMFile.LeaderPages[],          pageCount: attributes.totalPages, attributes: attributes];      Format.Line[Write, "copied"L];      MFile.Release[mFile];      EXITS return => NULL;      END; -- ReadOneFile  -- begin ReadFiles    DO      ENABLE        UNWIND => {          altName ¬ Exec.FreeTokenString[altName];          name ¬ Exec.FreeTokenString[name];          switches ¬ Exec.FreeTokenString[switches];          Heap.systemZone.FREE[@attributes];          AccessFloppyTape.Close[v ! FloppyTape.Error => CONTINUE]};      failed, leaderPage: BOOLEAN ¬ TRUE;      current: AccessFloppyTape.FileHandle;      IF attributes = NIL THEN        attributes ¬ Heap.systemZone.NEW[          AccessFloppyTape .AttributesRecord[AccessFloppyTape.maxClientDataWords]];      altName ¬ Exec.FreeTokenString[altName];      name ¬ Exec.FreeTokenString[name];      switches ¬ Exec.FreeTokenString[switches];      [name, switches] ¬ Exec.GetToken[h];      IF name = NIL AND switches = NIL THEN EXIT;      IF Exec.CheckForAbort[h] THEN SetOutcome[abort];      nsPattern ¬        IF name = NIL THEN AccessFloppyTape.anyName        ELSE NSString.StringFromMesaString[s: name];      IF WildCards[name] THEN {        AccessFloppyTape.Enumerate[          v, nsPattern, AccessFloppyTape.anyType, --allFiles--,ReadOneFile !          AccessFloppyTape.NoLeaderPage => RESUME ];        LOOP};      IF switches # NIL AND switches.length # 0 AND switches[0] = 's THEN {        switches ¬ Exec.FreeTokenString[switches];        [altName, switches] ¬ Exec.GetToken[h]};      FOR current ¬ AccessFloppyTape.GetNextFile[nullFile        ! AccessFloppyTape.NoLeaderPage => {	  leaderPage ¬ FALSE; RESUME}].next,        AccessFloppyTape.GetNextFile[current        ! AccessFloppyTape.NoLeaderPage => {	  leaderPage ¬ FALSE; RESUME}].next        WHILE current # nullFile DO        ENABLE UNWIND => Heap.systemZone.FREE[@attributes];        IF Exec.CheckForAbort[h] THEN SetOutcome[abort];        IF ~leaderPage THEN {leaderPage ¬ TRUE; LOOP;};        AccessFloppyTape.GetAttributes[current, attributes];        IF String.Equivalent[name, NameFromAttributes[attributes]] THEN {          failed ¬ FALSE; EXIT}        ELSE failed ¬ TRUE;        ENDLOOP;      IF failed THEN {        Write[name]; Format.Line[Write, " not found"L]; SetOutcome[error]; LOOP}      ELSE [] ¬ ReadOneFile[current, attributes];      ENDLOOP;    Heap.systemZone.FREE[@attributes];    AccessFloppyTape.Close[v];    END; -- ReadFiles  WriteAccessFloppyTapeError: PROCEDURE [    Write: Format.StringProc, error: AccessFloppyTape.ErrorType] =    BEGIN    Write["AccessFloppyTape.Error["L];    Write[      SELECT error FROM        incompatibleSizes => " Incompatible Sizes"L,        invalidParameter => "Invalid Parameter"L,        invalidPageNumber => " Invalid Page Number"L,        operationNotSupported => "Operation Not Supported"L,        parameterNotSupported => "Parameter Not Supported"L,        procedureNotImplemented => "Procedure Not Implemented"L,        ENDCASE => "?"L];    Format.Char[Write, ']];    END; -- WriteAccessFloppyTapeError  WriteFloppyTapeError: PROCEDURE [    Write: Format.StringProc, error: FloppyTape.ErrorType] =    BEGIN    Write["FloppyTape.Error["L];    Write[      SELECT error FROM        badTape => "badTape"L,        badSectors => "badSectors"L,        fileNotFound => "fileNotFound",        hardwareError => "hardwareError"L,        invalidByteOffset => "invalidByteOffset"L,        invalidVolumeHandle => "invalidVolumeHandle"L,        insufficientSpace => "insufficientSpace"L,        needsScavenging => "needsScavenging"L,        noSuchDrive => "noSuchDrive"L,        notFormatted => "notFormatted",        notReady => "notReady"L,        volumeOpen => "volumeOpen"L,        writeInhibited => "writeInhibited"L,        ENDCASE => "?"L];    Format.Char[Write, ']];    END; -- WriteFloppyTapeError  WriteFiles: PROCEDURE [h: Exec.Handle] =    BEGIN    ENABLE UNWIND => NULL;    attributes: AccessFloppyTape.Attributes ¬ NIL;    name, altName, switches: LONG STRING ¬ NIL;    fileType: File.Type ¬ FileTypes.tUntypedFile;    mFile: MFile.Handle;    writeEnable: BOOLEAN;    v: AccessFloppyTape.VolumeHandle;    Write: Format.StringProc = Exec.OutputProc[h];    v ¬ AccessFloppyTape.Open[      localDrive, FALSE, exclusive, NIL !      AccessFloppyTape.Error => ERROR Abort["Can't open floppytape"L];      AccessFloppyTape.NoDirectory => RESUME];    writeEnable ¬ AccessFloppyTape.Writable[drive: localDrive];    IF NOT (writeEnable) THEN {      Format.Line[        Write, "Cannot Write File to FloppyTape... FloppyTape Write-Disabled."L];      SetOutcome[abort]};    DO      ENABLE        UNWIND => {          IF altName # name THEN altName ¬ Exec.FreeTokenString[altName];          name ¬ Exec.FreeTokenString[name];          switches ¬ Exec.FreeTokenString[switches];          IF mFile # NIL THEN MFile.Release[mFile];          Heap.systemZone.FREE[@attributes];          AccessFloppyTape.Close[v ! FloppyTape.Error => CONTINUE]};      fFile: AccessFloppyTape.FileHandle ¬ [TRASH, FloppyTape.nullFileID];      mFileError: MFile.ErrorCode;      IF Exec.CheckForAbort[h] THEN SetOutcome[abort];      IF attributes = NIL THEN        attributes ¬ Heap.systemZone.NEW[          AccessFloppyTape .AttributesRecord[AccessFloppyTape.maxClientDataWords]];      mFile ¬ NIL;      IF altName # name THEN altName ¬ Exec.FreeTokenString[altName];      name ¬ Exec.FreeTokenString[name];      switches ¬ Exec.FreeTokenString[switches];      [name, switches] ¬ Exec.GetToken[h];      IF name = NIL AND switches = NIL THEN {        IF mFile # NIL THEN MFile.Release[mFile]; EXIT};      IF switches # NIL AND switches.length # 0 THEN        SELECT switches[0] FROM          's => {            switches ¬ Exec.FreeTokenString[switches];            [altName, switches] ¬ Exec.GetToken[h]};          't => {            fileType ¬ String.StringToNumber[              name ! String.InvalidNumber => CONTINUE];            switches ¬ Exec.FreeTokenString[switches];            LOOP};          ENDCASE => {            Format.Char[Write, switches[0]];            Format.Line[Write, " ..an Invalid Switch"L];            SetOutcome[abort];            }      ELSE altName ¬ name;      mFile ¬ MFile.ReadOnly[        name, [] ! MFile.Error => {mFileError ¬ code; CONTINUE}];      IF mFile = NIL THEN {        Write[name];        Write["... "L];        SELECT mFileError FROM          noSuchFile => {            Write[name];            Format.Line[Write, " not found"L];            SetOutcome[error];            LOOP};          conflictingAccess => {            Format.Line[Write, " conflicting access"L]; SetOutcome[error]; LOOP};          illegalName => {            Format.Line[Write, " Illegal File name"L]; SetOutcome[error]; LOOP};          insufficientAccess => {            Format.Line[Write, " Insufficient Access to this File"L];            SetOutcome[error];            LOOP};          nullAccess => {            Format.Line[Write, " Null Access to this File"L];            SetOutcome[error];            LOOP};          protectionFault => {            Format.Line[Write, " Protection Fault in accessing this File"L];            SetOutcome[error];            LOOP};          noSuchDirectory => {            Format.Line[              Write,              " You are attempting to access a directory that does not exist"L];            SetOutcome[error];            LOOP};          noRootDirectory => {            Format.Line[              Write,              " There is no development environment directory on this Rigid Disk Volume"L];            SetOutcome[abort]};          noRoomOnVolume => {            Format.Line[Write, " There is no room on Rigid Disk Volume"L];            SetOutcome[abort]};          noSuchVolume => {            Format.Line[Write, " There is no such Rigid Disk Volume"L];            SetOutcome[abort]};          volumeNotOpen => {            Format.Line[              Write,              " Rigid Disk Volume opened read only or unopened disk Volume"L];            SetOutcome[abort]};          ENDCASE => ERROR Abort[" unexpected MFile Error"L];        };      MakeAttributes[mFile, altName, attributes, fileType];      Write[name];      Write["... "L];      Write["copying to "L];      Write[altName];      Write["... "L];      [] ¬ AccessFloppyTape.CopyFromPilotFile[        pilotFile: SpecialMFile.GetCapaWithAccess[mFile], volume: v,        firstPilotPage: SpecialMFile.LeaderPages[],        pageCount: attributes.totalPages,        type: AccessFloppyTape.fileTypeForLeaderPage, attributes: attributes];      Format.Line[Write, "copied"L];      MFile.Release[mFile];      mFile ¬ NIL;      ENDLOOP;    Heap.systemZone.FREE[@attributes];    AccessFloppyTape.Close[v];    END; -- WriteFiles  WildCards: PROCEDURE [pattern: LONG STRING] RETURNS [BOOLEAN] = {    IF pattern # NIL THEN      FOR i: CARDINAL IN [0..pattern.length) DO        SELECT pattern[i] FROM '*, '# => RETURN[TRUE]; ENDCASE; ENDLOOP;    RETURN[FALSE]};  CommandProcessor: Exec.ExecProc =    BEGIN    MyCommands: TYPE = MACHINE DEPENDENT{      bootinfo(0), erase, format, information, list, makeboottape, overwrite, read,      retention, scavenge, write, noMatch(StringLookUp.noMatch)};    DefinedOptions: TYPE = MyCommands [bootinfo..write];    commandTable: ARRAY DefinedOptions OF LONG STRING ¬ [      bootinfo: "BootInfo"L, erase: "Erase"L, format: "Format"L,      information: "Information"L, list: "List"L, makeboottape: "MakeBootTape"L,      overwrite: "Overwrite"L, read: "Read"L, retention: "Retention"L,      scavenge: "Scavenge"L, write: "Write"L];    index: MyCommands;    Write: Format.StringProc = Exec.OutputProc[h];    command, switches: LONG STRING ¬ NIL;    WHILE outcome = normal DO      ENABLE        UNWIND => {          command ¬ Exec.FreeTokenString[command];          switches ¬ Exec.FreeTokenString[switches]};      [command, switches] ¬ Exec.GetToken[h];      IF command = NIL AND switches = NIL THEN EXIT;      BEGIN      ENABLE {        Abort => {Format.Line[Write, s]; GOTO abort};        AccessFloppyTape.Error => {          Write["unexpected "L];          WriteAccessFloppyTapeError[Write, error];          Format.Char[Write, Ascii.CR];          GOTO abort};        AccessFloppyTape.InconsistentFile => {          Format.Line[Write, "AccessFloppyTape.InconsistentFile"L]; GOTO abort};        AccessFloppyTape.InvalidVersion => {          Format.Line[Write, "AccessFloppyTape.InvalidVersion"L]; GOTO abort};        AccessFloppyTape.NoRoomForClientData => {          Format.Line[Write, "AccessFloppyTape.NoRoomForClientData"L]; GOTO abort};        FloppyTape.Error => {          IF error = writeInhibited THEN            Format.Line[Write, "FloppyTape is write protected"L]          ELSE {            Write["unexpected "L];            WriteFloppyTapeError[Write, error];            Format.Char[Write, Ascii.CR]};          GOTO abort};        FloppyTape.IOError => {          Format.Line[Write, "IOError -- The parameters are...."L];          Write["VolumeHandle: "L];          Format.LongNumber[Write, LOOPHOLE[file.volume], [10, FALSE, TRUE, 0]];          Write["   FileID: "L];          Format.LongNumber[Write, LOOPHOLE[file.file], [10, FALSE, TRUE, 0]];          Write["   ByteOffset: "L];          Format.LongNumber[Write, byte, [10, FALSE, TRUE, 0]];          Write["   firstHole: "L];          Format.LongNumber[Write, firstHole, [10, FALSE, TRUE, 0]];          Write["   howManyHoles: "L];          Format.LongNumber[Write, howManyHoles, [10, FALSE, TRUE, 0]];          GOTO abort};        SetOutcome => {          IF outcome < value THEN outcome ¬ value;          IF outcome = abort THEN CONTINUE ELSE RESUME          };        Volume.InsufficientSpace => {          Format.Line[            Write, "Insufficient (rigid) disk space to complete that operation"L];          GOTO abort}};      index ¬ LOOPHOLE[StringLookUp.InTable[        key: command,        table: DESCRIPTOR[BASE[commandTable], LENGTH[commandTable]]]];      SELECT index FROM        bootinfo => outcome ¬ MakeBootTape.DisplayBootFileInfo[h];        erase => EraseFloppyTape[h];        format => FormatFloppyTape[h];        information => InfoFloppyTape[h];        list => ListFiles[switches, h];        makeboottape => outcome ¬ MakeBootTape.MakeBootableTape[h];        overwrite => OverWriteFile[h];        read => ReadFiles[h];        retention =>{ FloppyTape.Retention[localDrive!	       		UNWIND => Write[" Cannot retention..."L];];	              Format.Line[Write,"Floppytape retentioned"];};        scavenge =>{ [] ¬ FloppyTape.Scavenge[localDrive!	      		 UNWIND => Write[" Cannot Scavenge..."L];];		      Format.Line[Write,"Floppytape scavenged"];};        write => WriteFiles[h];        ENDCASE => {Write["Unknown command"L]; GOTO abort};      EXITS abort => outcome ¬ abort;      END;      command ¬ Exec.FreeTokenString[command];      switches ¬ Exec.FreeTokenString[switches];      ENDLOOP;    END; -- CommandProcessor  Exec.AddCommand["FloppyTape.~"L, CommandProcessor, Help];  localDrive ¬ AccessFloppyTape.GetNextDrive[];  END.    -- LOGPKM	16-Feb-87 12:20:23	CreatedFile.ET	15-Mar-87 12:20:34      Edited for new floppytape.mesa.PKM     16-Mar-87 14:54:29      Changed the Xerox Copyright notice to standard formatPKM     25-Mar-87 11:32:27	Edited for new AccessFloppyTape.mesa.MAT	 5-May-87 11:35:42	Added catch of AccessFloppyTape.NoDirectory SignalMAT	 8-May-87 15:15:34	Use AccessFloppyTape.GetNextfile rather than FloppyTape.GetNextfile.PKM     21-May-87 11:55:53	Edited for new AccessFloppyTape.mesa.      PKM	      			Fixed AR 11117  FloppyTapeCommands: Should add progress messages during formatting.MRY	19-Jun-87 13:20:13 	Further fixed AR 11117, it will take care of possible errors while formating.MRY	19-Jun-87 14:10:57	Edited proc FormatFloppyTape to catch user abort.MRY	25-Jun-87 17:00:27	Fixed AR 11289: Eliminated unnecessary Open and Close in the proc FormatFloppyTapeMRY 	26-Jun-87 14:59:03	Put a block before FloppyTape.Format in proc FormatFloppyTape.DDM     12-Jul-87 11:45:34      ????RSV     21-Jul-87 15:14:58      Back to standard header.MRY	24-Aug-87 13:35:52	Changed the Help message for the MakeBoot command.JAC/RSV 29-Oct-87 15:48:41      change localDrive for mirrorKEK	23-Nov-87 18:58:18      add /a switch to help command.
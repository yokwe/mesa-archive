-- File: CartridgeTapeDirectoryImpl.mesa - last edit:-- Muirhead:OSBU North:Xerox   12-Jul-87 12:19:36-- Schmelz.ES          27-Mar-87 18:37:27-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.DIRECTORY  AccessFloppyTape USING [    Attributes, fileTypeForLeaderPage, leaderPages, sealValue],  FloppyTape USING [    VolumeHandle, nullFileID, FileHandle, FileHandleFromID, ByteOffset,     ByteCount, VMBuffer, ScatteredVM, GetNextFile, GetFileAttributes,    ScatteredVMSeq, ReadFile, FileID, WriteFile, ForceOut, SetRootFile,    GetVolumeAttributes, Error, IOError],  File USING [Type],  Environment USING [PageCount, bytesPerPage],  Heap USING [Create, Delete],  Space USING [ScratchMap, Unmap, Error, InsufficientSpace],  CommonSoftwareFileTypes USING [tDirectory],  CartridgeTapeDirectory;    CartridgeTapeDirectoryImpl: PROGRAM  IMPORTS FloppyTape, Heap, Space  EXPORTS CartridgeTapeDirectory =  BEGIN  Directory: TYPE = RECORD [   -- control structure    z: UNCOUNTED ZONE,    number: CartridgeTapeDirectory.NumberOfEntries,    entries: SEQUENCE COMPUTED CartridgeTapeDirectory.NumberOfEntries      OF CartridgeTapeDirectory.Entry];  Handle: PUBLIC TYPE = LONG POINTER TO Directory; -- Directory instance  nullHandle: PUBLIC Handle ¬ NIL;  onePage: Environment.PageCount = AccessFloppyTape.leaderPages;  fileTypeForDirectoryFile: File.Type = CommonSoftwareFileTypes.tDirectory;  directoryZone: UNCOUNTED ZONE;    Error: PUBLIC ERROR [type: CartridgeTapeDirectory.ErrorType] = CODE;  Bug: PUBLIC ERROR [type: CartridgeTapeDirectory.BugType] = CODE;    NoLeaderPage: PUBLIC SIGNAL [fileId:FloppyTape.FileID]    RETURNS [answer: CartridgeTapeDirectory.Answer] = CODE;    Create: PUBLIC PROCEDURE [volume: FloppyTape.VolumeHandle]    RETURNS [dH: Handle, number: CartridgeTapeDirectory.NumberOfEntries ¬ 0] =    BEGIN    myFileHandle: FloppyTape.FileHandle ¬      FloppyTape.FileHandleFromID[fileId: FloppyTape.nullFileID, volume: volume];    tempZone: UNCOUNTED ZONE;    myFileType: File.Type;    Element: TYPE = RECORD [      fid: FloppyTape.FileID,      map: LONG POINTER TO UNSPECIFIED,      next: ElementPtr];    ElementPtr: TYPE = LONG POINTER TO Element ¬ NIL;    tempElement, linkedList, currentElement: ElementPtr;    nullOffset: FloppyTape.ByteOffset = 0;    myByteCount: FloppyTape.ByteCount = onePage * Environment.bytesPerPage;    myVMBuffer: FloppyTape.VMBuffer ¬ [count: myByteCount, vm: NIL];    myScatteredVM: FloppyTape.ScatteredVM ¬ NIL;    moveElement: ElementPtr;    moved: CARDINAL ¬ 0;        myFileHandle ¬ FloppyTape.GetNextFile[myFileHandle]; -- get 1st file on tape    tempZone ¬ Heap.Create[initial: 1];  -- temporary zone for linked list    UNTIL myFileHandle.file = FloppyTape.nullFileID DO -- collect leader pages      ENABLE UNWIND => BEGIN        IF linkedList # NIL THEN {          currentElement ¬ linkedList;          UNTIL currentElement = NIL DO            currentElement.map ¬	    Space.Unmap [	      pointer:currentElement.map !Space.Error => CONTINUE];	    currentElement ¬ currentElement.next;            ENDLOOP;	  linkedList ¬ NIL};        Heap.Delete [z: tempZone];        END;      myFileType ¬ FloppyTape.GetFileAttributes [myFileHandle].type;      IF myFileType # AccessFloppyTape.fileTypeForLeaderPage THEN  -- signal        SELECT SIGNAL NoLeaderPage [myFileHandle.file] FROM	  skip  => {myFileHandle ¬ FloppyTape.GetNextFile [myFileHandle];	  	    LOOP};	  abort => GOTO Abort;  -- discard allocated storage	  ENDCASE => GOTO Abort;      tempElement ¬ tempZone.NEW [Element];  -- create next element instance      IF linkedList = NIL THEN  -- first loop        BEGIN  -- allocate ScatteredVMSeq and save address of 1st element	myScatteredVM ¬ tempZone.NEW [FloppyTape.ScatteredVMSeq[1]];	linkedList ¬ tempElement;	currentElement ¬ tempElement;	END      ELSE  -- normal loop        BEGIN  -- link next element and point to it	currentElement.next ¬ tempElement;	currentElement ¬ currentElement.next	END;      currentElement.map ¬ Space.ScratchMap [        count:onePage !Space.InsufficientSpace => GOTO NoSpace];      myVMBuffer.vm ¬ currentElement.map;      myScatteredVM[0] ¬ myVMBuffer;      FloppyTape.ReadFile [        file: myFileHandle, first: nullOffset, scatteredVM: myScatteredVM];      currentElement.fid ¬ myFileHandle.file;      number ¬ number + 1;      myFileHandle ¬ FloppyTape.GetNextFile [myFileHandle];      REPEAT        Abort => {	  IF linkedList # NIL THEN	    BEGIN	    currentElement ¬ linkedList;	    UNTIL currentElement = NIL DO	      currentElement.map ¬ Space.Unmap [	        pointer: currentElement.map !Space.Error => CONTINUE];	      currentElement ¬ currentElement.next;	      ENDLOOP;	    linkedList ¬ NIL;	    END;	  Heap.Delete[z: tempZone];	  GOTO Terminate};	NoSpace => {	  IF linkedList # NIL THEN	    BEGIN	    currentElement ¬ linkedList;	    UNTIL currentElement = NIL DO	      currentElement.map ¬ Space.Unmap [	        pointer: currentElement.map !Space.Error => CONTINUE];	      currentElement ¬ currentElement.next;	      ENDLOOP;	    linkedList ¬ NIL;	    END;	  Heap.Delete[z: tempZone];	  ERROR Error[insufficientSpace]};      ENDLOOP;    IF number = 0 THEN ERROR Error [noFiles];    dH ¬ CreateDirectory [number];    moveElement ¬ linkedList;    UNTIL moveElement = NIL DO  -- save temporary pointers in control structure      dH.entries[moved] ¬ moveElement.map;      dH.entries[moved].common.fid ¬ moveElement.fid;      moveElement ¬ moveElement.next;      moved ¬ moved + 1;      ENDLOOP;    Heap.Delete[z: tempZone];    linkedList ¬ NIL;    EXITS      Terminate => NULL;    END; -- Create      Write: PUBLIC PROCEDURE [volume: FloppyTape.VolumeHandle, dH: Handle]    RETURNS [fileId: FloppyTape.FileID] =    BEGIN    myScatteredVM: FloppyTape.ScatteredVM ¬ NIL;    myScatteredVMZone: UNCOUNTED ZONE;        FOR invalid: CARDINAL IN [0..dH.number) DO      Validate[object: dH.entries[invalid]];      ENDLOOP;    [myScatteredVM, myScatteredVMZone] ¬ Convert[dH: dH];      BEGIN      ENABLE  -- error during Write destroys myScatteredVM and falls off end	FloppyTape.Error, FloppyTape.IOError =>	  Heap.Delete[z: myScatteredVMZone];      fileId ¬ FloppyTape.WriteFile [  -- actually writes the file        volume: volume,        type: fileTypeForDirectoryFile,        scatteredVM: myScatteredVM];      FloppyTape.ForceOut[volume: volume];      END;    FloppyTape.SetRootFile [fileID: fileId, volumeHandle: volume];    Heap.Delete[z: myScatteredVMZone];    END; -- Write          Open: PUBLIC PROCEDURE [volume: FloppyTape.VolumeHandle]    RETURNS [dH: Handle, number: CartridgeTapeDirectory.NumberOfEntries ¬ 0] =    BEGIN    rootFileHandle: FloppyTape.FileHandle;    mySize: FloppyTape.ByteCount;    myFileType: File.Type;    created: CartridgeTapeDirectory.NumberOfEntries ¬ 0;    myScatteredVM: FloppyTape.ScatteredVM ¬ NIL;    myScatteredVMZone: UNCOUNTED ZONE;    nullOffset: FloppyTape.ByteOffset = 0;        dH ¬ NIL;    rootFileHandle.volume ¬ volume;    IF (rootFileHandle.file ¬ FloppyTape.GetVolumeAttributes[  -- gets file handle      volume: volume, name: NIL].rootFile) = FloppyTape.nullFileID    THEN RETURN WITH ERROR Error[noDirectory];    [mySize, myFileType] ¬ FloppyTape.GetFileAttributes[rootFileHandle];    IF myFileType # fileTypeForDirectoryFile THEN       RETURN WITH ERROR Error[noDirectory];    number ¬ mySize / Environment.bytesPerPage;    dH ¬ CreateDirectory [number: number];    FOR created: CartridgeTapeDirectory.NumberOfEntries IN [0..number) DO      -- create scratchmaps      dH.entries[created] ¬ Space.ScratchMap[        count:onePage	!Space.InsufficientSpace => GOTO Resolve];      REPEAT        Resolve => FOR resolved: CartridgeTapeDirectory.NumberOfEntries	  IN [0..created) DO	    BEGIN  -- unmap already mapped ScratchMaps and raise error	    IF created = 0 THEN	      ERROR Error[insufficientSpace]	      ELSE	      {dH.entries[resolved] ¬ Space.Unmap [	        pointer: dH.entries[resolved]	        !Space.Error => CONTINUE]};  -- unmap the other ScratchMaps	    END;	    ERROR Error[insufficientSpace];	    ENDLOOP;      ENDLOOP;    [myScatteredVM, myScatteredVMZone] ¬ Convert[dH: dH];    BEGIN ENABLE UNWIND => --IOError-- { Close[dH: dH]; dH ¬ NIL; number ¬ 0; };    FloppyTape.ReadFile [      file: rootFileHandle, first: nullOffset, scatteredVM: myScatteredVM];    END; -- of Enable    Heap.Delete[z: myScatteredVMZone];    END; -- Open          Close: PUBLIC PROCEDURE [dH: Handle] =    BEGIN    directoryZone ¬ dH.z;    FOR unmap: CartridgeTapeDirectory.NumberOfEntries IN [0..dH.number) DO      -- unmap the ScratchMaps      dH.entries[unmap] ¬ Space.Unmap[        dH.entries[unmap] !Space.Error => CONTINUE];      ENDLOOP;    Heap.Delete[z: directoryZone];    END; -- Close          GetEntry: PUBLIC PROCEDURE [dH: Handle, index: CartridgeTapeDirectory.Index]    RETURNS [entry: CartridgeTapeDirectory.Entry, fileId: FloppyTape.FileID] =    BEGIN    IF index NOT IN [0..dH.number) THEN      ERROR Error [invalidIndex];    entry ¬ dH.entries[index];    fileId ¬ entry.common.fid ; -- entry."FileID from AttributesRecord" tbd.    Validate[object: entry];    END; -- GetEntry-- private procedures  CreateDirectory: PRIVATE PROCEDURE [    number: CartridgeTapeDirectory.NumberOfEntries]    RETURNS [dH: Handle] =    BEGIN    directoryZone ¬ Heap.Create[initial: 1];    dH ¬ directoryZone.NEW[Directory[number]];    dH.z ¬ directoryZone;    dH.number ¬ number;    END; -- CreateDirectory  Convert: PRIVATE PROCEDURE [dH: Handle]    RETURNS [      myScatteredVM: FloppyTape.ScatteredVM,      myScatteredVMZone: UNCOUNTED ZONE] =    BEGIN    bufferNumber: CARDINAL = dH.number;    myByteCount: FloppyTape.ByteCount = onePage * Environment.bytesPerPage;    myVMBuffer: FloppyTape.VMBuffer ¬ [count: myByteCount, vm: NIL];        myScatteredVMZone ¬ Heap.Create[initial: bufferNumber];  -- allocate scatteredVMSeq    myScatteredVM ¬ myScatteredVMZone.NEW[      FloppyTape.ScatteredVMSeq[bufferNumber]];    FOR convert: CARDINAL IN [0..bufferNumber) DO  -- built scatteredVM      myVMBuffer.vm ¬ dH.entries[convert];      myScatteredVM[convert] ¬ myVMBuffer;      ENDLOOP;    END; -- Convert  Validate: PRIVATE PROCEDURE [object: CartridgeTapeDirectory.Entry] =    BEGIN    IF object.common.seal # AccessFloppyTape.sealValue THEN      ERROR Bug[invalidEntry];    END; -- Validate  END..-- FloppyTapeDirectoryImplLOG.27-Mar-87 18:37:27   Schmelz   Created file. 4-May-87 14:56:24   Thatcher   Added nilHandle definition.19-May-87 13:16:44   Muirhead   Changed name from FloppyTapeDirectoryImpl to CartridgeTapeDirectoryImpl.12-Jul-87 12:18:21   Muirhead   [NS AR 6266] Treat IOError on Open same as NoDirectory.
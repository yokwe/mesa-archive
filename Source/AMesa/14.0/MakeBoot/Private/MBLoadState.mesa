-- Copyright (C) 1981, 1982, 1983, 1986, 1987  by Xerox Corporation. All rights reserved. -- MBLoadState.mesa  --   JGS	20-Jul-82 10:53:10    --   BTL	21-Sep-81 17:08:04    --   BJD	26-Aug-83  9:55:18    --   RKJ	22-Sep-83 12:25:36    --   BGY	17-Jun-86  9:51:13   --   MEW	 2-Jul-86 13:07:42 --   ET		19-Nov-87  9:14:09DIRECTORY  BcdOps USING [BcdBase],  Environment USING [wordsPerPage],  Inline USING [LongCOPY],  PrincOpsExtras2,  MB USING [BHandle, Handle],  MBLoaderOps,  MBVM,  MFile,  MSegment,  LoadedMem,  LoadState,  LoadStateFormat USING [    BcdInfo, BcdInfoIndex, Index, Handle, Object, ModuleInfo, ModuleInfoIndex,    oldNullModule, newNullModule, nullIndex, VersionID],  MBStorage USING [FreePages, Pages, PagesForWords];MBLoadState: PROGRAM    IMPORTS Inline, LoadedMem, MBVM, MBStorage, MFile, MSegment    EXPORTS MBLoaderOps =   BEGIN OPEN MB;    initialModules: CARDINAL = 400;  initialBcds: CARDINAL = 20;  extraLoadStatePages: CARDINAL = 1;  data: MB.Handle ¬ NIL;  loadstate: LoadStateFormat.Handle ¬ NIL;  modules: LONG POINTER TO ARRAY OF LoadStateFormat.ModuleInfo ¬ NIL;  bcds: LONG POINTER TO ARRAY OF LoadStateFormat.BcdInfo ¬ NIL;    InitLoadState: PUBLIC PROC [h: MB.Handle] = {    data ¬ h};   FinishLoadState: PUBLIC PROC = {    IF loadstate # NIL THEN {data.z.FREE[@loadstate]};    IF modules # NIL THEN {MBStorage.FreePages[modules];  modules ¬ NIL};    IF bcds # NIL THEN {MBStorage.FreePages[bcds];  bcds ¬ NIL};    data ¬ NIL};  GrowLoadState: PUBLIC PROC [nModules, nBcds: CARDINAL ¬ 0] = {    OPEN LoadStateFormat;    IF loadstate = NIL THEN {      loadstate ¬ data.z.NEW[Object ¬ [        versionident: VersionID, nBcds: 0, nextID: 0,	nModules: 0, maxModules: 0,         maxBcds: 0,        moduleInfo: LOOPHOLE[0],        bcdInfo: LOOPHOLE[0]]]};    IF nModules # 0 THEN {      pages: CARDINAL =         MBStorage.PagesForWords[nModules*SIZE[ModuleInfo]]+extraLoadStatePages;      new: LONG POINTER TO ARRAY OF LoadStateFormat.ModuleInfo ¬        MBStorage.Pages[pages];      Inline.LongCOPY[        from: modules, to: new, nwords: loadstate.nModules*SIZE[ModuleInfo]];      loadstate.maxModules ¬ (Environment.wordsPerPage*pages)/SIZE[ModuleInfo];      MBStorage.FreePages[modules];      modules ¬ new};    IF nBcds # 0 THEN {      pages: CARDINAL = MBStorage.PagesForWords[nBcds*SIZE[BcdInfo]];      new: LONG POINTER TO ARRAY OF LoadStateFormat.BcdInfo ¬        MBStorage.Pages[pages];      Inline.LongCOPY[        from: bcds, to: new, nwords: loadstate.nBcds*SIZE[BcdInfo]];      loadstate.maxBcds ¬ (Environment.wordsPerPage*pages)/SIZE[BcdInfo];      MBStorage.FreePages[bcds];      bcds ¬ new}};  InputLoadState: PUBLIC PROC RETURNS [nbcds: LoadStateFormat.Index] = {    <<IF data.germ THEN RETURN[LoadStateFormat.Index.FIRST];>>    IF loadstate = NIL THEN      GrowLoadState[nModules: initialModules, nBcds: initialBcds];    RETURN[loadstate.nBcds]};  UpdateLoadState: PUBLIC PROC [      config: LoadStateFormat.Index, handle: MB.BHandle] = {    bcd: BcdOps.BcdBase = handle.bcd;    <<IF data.germ THEN RETURN;>>    IF config >= loadstate.maxBcds THEN GrowLoadState[      nBcds: loadstate.maxBcds +        Environment.wordsPerPage/SIZE[LoadStateFormat.BcdInfo]];    bcds[config] ¬ LoadStateFormat.BcdInfo[      id: loadstate.nextID,      typeExported: bcd.typeExported, exports: (bcd.nExports # 0),       pages: CARDINAL[handle.bcdSeg.pages],      base: MBVM.LongPointerFromSeg[handle.bcdSeg]];    loadstate.nextID ¬ loadstate.nextID + 1;    IF config >= loadstate.nBcds THEN loadstate.nBcds ¬ loadstate.nBcds + 1};  WriteLoadState: PUBLIC PROC = {    OPEN LoadStateFormat;    lsWords, lsPages, maxModules, maxBcds, extraWords: CARDINAL;    vmLoadstate: LoadStateFormat.Handle;    object: LoadStateFormat.Object;    IF data.germ THEN RETURN;    maxModules ¬ loadstate.nModules + MAX[10, data.lsModules];    maxBcds ¬ loadstate.nBcds + MAX[1, data.lsBcds];    lsWords ¬ SIZE[Object] + maxModules*SIZE[ModuleInfo] + maxBcds*SIZE[BcdInfo];    lsPages ¬ MBStorage.PagesForWords[lsWords];    extraWords ¬ lsPages*Environment.wordsPerPage - lsWords;    maxModules ¬ maxModules + (extraWords/2)/SIZE[ModuleInfo];    maxBcds ¬ maxBcds + (extraWords/2)/SIZE[BcdInfo];    data.lsseg ¬ MBVM.AllocData[base: MBVM.HyperSpace, pages: lsPages, dir: up];    data.lsseg.info.readOnly ¬ FALSE;    data.lsseg.bootLoaded ¬ TRUE;    vmLoadstate ¬ MBVM.LongPointerFromSeg[data.lsseg];    FixupBcdInfo[loadstate.nBcds];    object ¬ [      versionident: VersionID, nBcds: loadstate.nBcds, nextID: loadstate.nextID,      nModules: loadstate.nModules, maxModules:  maxModules,       maxBcds: maxBcds,      moduleInfo: LOOPHOLE[SIZE[Object], ModuleInfoIndex],      bcdInfo: 	LOOPHOLE[SIZE[Object] + maxModules*SIZE[ModuleInfo], BcdInfoIndex]];    MBVM.LongCopyWrite[from: @object, to: vmLoadstate, nwords: SIZE[Object]];    MBVM.LongCopyWrite[      from: modules,      to: @vmLoadstate[object.moduleInfo],      nwords: loadstate.nModules * SIZE[ModuleInfo]];    MBVM.LongCopyWrite[      from: bcds,      to: @vmLoadstate[object.bcdInfo],      nwords: loadstate.nBcds * SIZE[BcdInfo]]};  FixupBcdInfo: PROC[count: CARDINAL] = {    -- take bcds in makeboot's address space, and map them to the     -- bcds in the bootfile's address space.    mfile: MFile.Handle;    fileseg: MBVM.Seg;    GetFileSegment: PROC[s: MBVM.Seg] RETURNS [BOOLEAN] = {      WITH seg: s­ SELECT FROM        file => IF MFile.SameFile[mfile, seg.file] THEN RETURN[TRUE];	ENDCASE;      RETURN[FALSE];      };    FOR i: CARDINAL IN [0..count) DO      mfile ¬ MSegment.GetFile[MSegment.AddresstoSegment[bcds[i].base]];      fileseg ¬ MBVM.EnumerateSegs[GetFileSegment];      bcds[i].base ¬ MBVM.LongPointerFromSeg[fileseg];      ENDLOOP;    };    FrameLess: PROCEDURE [a, b: PrincOpsExtras2.GFTHandle] RETURNS [BOOLEAN] =    INLINE {    RETURN[LOOPHOLE[a, CARDINAL] < LOOPHOLE[b, CARDINAL]]};    EnterModule: PUBLIC PROC [module: LoadStateFormat.ModuleInfo] = {    entry: CARDINAL;    <<IF data.germ THEN RETURN;>>    IF loadstate.nModules >= loadstate.maxModules THEN GrowLoadState[      nModules: loadstate.maxModules +        Environment.wordsPerPage/SIZE[LoadStateFormat.ModuleInfo]];    entry ¬ loadstate.nModules;    -- this loop may be slow but it is almost never executed    WHILE entry # 0 AND      FrameLess[module.gfi, modules[entry-1].gfi] DO      modules[entry] ¬ modules[entry-1];      entry ¬ entry - 1;      ENDLOOP;    modules[entry] ¬ module;    loadstate.nModules ¬ loadstate.nModules + 1};  GetModule: PUBLIC PROC [gfi: PrincOpsExtras2.GFTHandle]     RETURNS [module: LoadStateFormat.ModuleInfo] = {    <<IF data.germ THEN RETURN[LoadStateFormat.nullModule];>>    FOR mi: CARDINAL IN [0..loadstate.nModules) DO      IF gfi = modules[mi].gfi THEN         RETURN[modules[mi]];      ENDLOOP};      SetResolved: PUBLIC PROC [gf: PrincOpsExtras2.LongGlobalFrameHandle, resolved: BOOLEAN] = {    <<IF data.germ THEN RETURN;>>    gfi: PrincOpsExtras2.GFTHandle ¬ LoadedMem.GFTHandleFromGlobalFrame[gf];    FOR mi: CARDINAL IN [0..loadstate.nModules) DO      IF gfi = modules[mi].gfi THEN         modules[mi].resolved ¬ resolved;      ENDLOOP};      AcquireBcd: PUBLIC PROC [    config: LoadStateFormat.Index] RETURNS [handle: MB.BHandle] = {    RETURN[data.inputBCDs.bcds[config]]};      ReleaseBcd: PUBLIC PROC [handle: MB.BHandle] = {};      InitBinding: PUBLIC PROC [      bcd: BcdOps.BcdBase] RETURNS [binding: MBLoaderOps.Binding] = {    BindingSequence: TYPE =      RECORD[SEQUENCE COMPUTED CARDINAL OF MBLoaderOps.BindLink];    p: LONG POINTER ¬ data.z.NEW[BindingSequence[bcd.nDummies]];    binding ¬ DESCRIPTOR[  -- BASE[binding] is biased by bcd.firstdummy      (p - CARDINAL[bcd.firstdummy * SIZE[MBLoaderOps.BindLink]]),       bcd.nDummies];    FOR i: CARDINAL IN [bcd.firstdummy..bcd.firstdummy + bcd.nDummies) DO      binding[i] ¬ MBLoaderOps.BindLink[body: notbound[]];       ENDLOOP};        ReleaseBinding: PUBLIC PROC [        bcd: BcdOps.BcdBase, binding: MBLoaderOps.Binding]      RETURNS [null: MBLoaderOps.Binding] = {    IF BASE[binding] # NIL THEN      BEGIN  -- avoid compiler warning message      p: LONG POINTER ¬ BASE[binding] + bcd.firstdummy*SIZE[MBLoaderOps.BindLink];      data.z.FREE[@p];      END;    RETURN[DESCRIPTOR[NIL, 0]]};      BcdUnresolved: PUBLIC PROC [bcd: LoadStateFormat.Index] RETURNS [BOOLEAN] = {    OPEN LoadStateFormat;    <<IF data.germ THEN RETURN[FALSE];>>    FOR i: CARDINAL IN [0..loadstate.nModules) DO      IF bcd = modules[i].index AND ~modules[i].resolved THEN        RETURN[TRUE];      ENDLOOP;    RETURN[FALSE]};      BcdExports: PUBLIC PROC [bcd: LoadStateFormat.Index] RETURNS [BOOLEAN] = {    RETURN[      «IF data.germ THEN FALSE ELSE» bcds[bcd].exports]};      BcdExportsTypes: PUBLIC PROC [bcd: LoadStateFormat.Index] RETURNS [BOOLEAN] = {    RETURN[      «IF data.germ THEN FALSE      ELSE» bcds[bcd].typeExported]};      EnumerateModules: PUBLIC PROC [    proc: PROC [module: LoadStateFormat.ModuleInfo] RETURNS [BOOLEAN]]    RETURNS [PrincOpsExtras2.LongGlobalFrameHandle] = {    «IF data.germ THEN RETURN[PrincOpsExtras2.nullGlobalFrame];»    FOR i: CARDINAL IN [0..loadstate.nModules) DO      IF modules[i] ~= LoadStateFormat.newNullModule        AND modules[i] ~= LoadStateFormat.oldNullModule AND proc[modules[i]] THEN 	RETURN[LoadedMem.GlobalFrameFromGFTHandle[modules[i].gfi]];      ENDLOOP;    RETURN[PrincOpsExtras2.nullGlobalFrame]};  EnumerateBcds: PUBLIC PROC [    dir: MBLoaderOps.EnumerationDirection,    proc: PROC [LoadStateFormat.Index] RETURNS [BOOLEAN]]    RETURNS [config: LoadStateFormat.Index] = {    «IF data.germ THEN RETURN[LoadStateFormat.nullIndex];»    SELECT dir FROM      recentfirst =>        FOR config DECREASING IN [0..loadstate.nBcds) DO          IF proc[config] THEN RETURN;          ENDLOOP;      recentlast =>        FOR config IN [0..loadstate.nBcds) DO          IF proc[config] THEN RETURN;          ENDLOOP;      ENDCASE;    RETURN[LoadStateFormat.nullIndex]};      GetLoadState: PUBLIC PROC RETURNS [LoadStateFormat.Handle] = {    IF loadstate = NIL THEN [] ¬ InputLoadState[];    RETURN[loadstate]};      GetModules: PUBLIC PROC     RETURNS [LONG POINTER TO ARRAY OF LoadStateFormat.ModuleInfo] = {    IF loadstate = NIL THEN [] ¬ InputLoadState[];    RETURN[modules]};    GetBcds: PUBLIC PROC     RETURNS [LONG POINTER TO ARRAY OF LoadStateFormat.BcdInfo] = {    IF loadstate = NIL THEN [] ¬ InputLoadState[];    RETURN[bcds]};    END.
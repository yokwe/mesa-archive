-- Copyright (C) 1984, 1986  by Xerox Corporation. All rights reserved. -- MBLoaderImpl.mesa      2-Jul-86 17:51:30 by MEW      -- This module provides public access to loading and unloading programs.DIRECTORY  BcdDefs USING [VersionID],  BcdDefsExtras,  BcdOps USING [BcdBase],  Environment USING [wordsPerPage],  Heap USING [Create, Delete, Error],  LoaderCore USING [CreateModulesAndBind, WrongVersion],  PrincOpsExtras2 USING [LongGlobalFrameHandle],  Runtime USING [ConfigError, ConfigErrorType, VersionMismatch],  Space USING [InsufficientSpace, Interval],  SpecialLoader USING [MapProcType, UnmapProcType],  SpecialLoaderInternal USING [],  SpecialRuntimeExtras USING [ProgramFromGlobalFrame];MBLoaderImpl: MONITOR  IMPORTS    Heap, LoaderCore, Runtime, Space, SpecialRuntimeExtras  EXPORTS SpecialLoader, SpecialLoaderInternal  =  BEGIN   -- Local stuff:  Bug: ERROR [type: BugType] = CODE;  BugType: TYPE = {funnyHeapError};    -- SpecialLoaderInternal stuff:    MapProc: PUBLIC SpecialLoader.MapProcType;      UnmapProc: PUBLIC SpecialLoader.UnmapProcType;  --==============================  -- Loader Implementation:  --==============================  -- PUBLIC PROCS:  LoadConfig: PUBLIC --SpecialLoader.-- ENTRY PROC [    mapProc: SpecialLoader.MapProcType, unmapProc: SpecialLoader.UnmapProcType,    codeLinks: BOOLEAN]    RETURNS [control: PROGRAM] =    BEGIN    bcd: BcdOps.BcdBase ¬ NIL;    controlGF: PrincOpsExtras2.LongGlobalFrameHandle;    scratchForLoaderCore: UNCOUNTED ZONE ¬ Heap.Create[      initial: 5, increment: 10, swapUnitSize: 20,      largeNodeThreshold: 50 * Environment.wordsPerPage];    BEGIN    ENABLE      UNWIND => {        IF bcd # NIL THEN bcd ¬ unmapProc[bcd].pointer;        Heap.Delete[z: scratchForLoaderCore, checkEmpty: FALSE]};    -- store the clients mapping/unmapping procedures in global state    MapProc ¬ mapProc;    UnmapProc ¬ unmapProc;    -- Map the bcd, verify current version module or config:    bcd ¬ mapProc[      pageOffset: 0, pageCount: 1, swapUnits: [unitary[]], access: readOnly];    IF bcd.nPages > 1 THEN     BEGIN      bcdPages: CARDINAL ¬ bcd.nPages;  -- save before we unmap.      bcd ¬ unmapProc[bcd].pointer;      bcd ¬ mapProc[        pageOffset: 0, pageCount: bcdPages, swapUnits: [unitary[]], 	access: readOnly];      END;    IF (bcd.versionIdent # BcdDefs.VersionID AND bcd.versionIdent # BcdDefsExtras.GFTVersionID) OR bcd.definitions THEN      ERROR Runtime.ConfigError[invalidConfig];          -- Load the code, create module instances:    controlGF ¬ LoaderCore.CreateModulesAndBind[  -- may raise error or signal.      bcdBase: bcd, linkLoc: IF codeLinks THEN codeIfPossible ELSE frame,      scratchDuringLoading: scratchForLoaderCore,      makeboot: TRUE !      Heap.Error --[type]-- =>        IF type = insufficientSpace THEN          ERROR Space.InsufficientSpace[available: 0]        ELSE Bug[funnyHeapError];      LoaderCore.WrongVersion --[module]]-- => {  -- translate to public signal.        SIGNAL Runtime.VersionMismatch[module]; RESUME }];    END;  --scope of UNWIND--    Heap.Delete[z: scratchForLoaderCore, checkEmpty: FALSE];    RETURN SpecialRuntimeExtras.ProgramFromGlobalFrame[controlGF];    END;    END.LOG 30-Jul-84 13:55:29	EKN          Created file from pieces of RuntimeLoaderImpl.mesa.21-Dec-84 13:41:45	AWL              Initialize bcd in LoadConfig to NIL. 2-Jul-86 17:52:58      MEW    Updated to newest princops.
-- Copyright (C) 1981, 1982, 1983  by Xerox Corporation. All rights reserved. -- MBMain.mesa  --   JGS	14-Oct-82 13:35:54--   Lewis	 1-Dec-81 17:34:26--   Davirro	20-Jul-83 17:15:33--   Johnsson	22-Sep-83  9:15:07--   BGY	 3-Jul-86 15:09:46DIRECTORY  BcdDefs USING [Base],  BcdOps USING [MTHandle],  Environment USING [wordsPerPage],  LoadedMem,  MB,  MBOut USING [Char, CR, Decimal, Line, Number, Text],  MBVM USING [    AllocData, AllocMDSData, Base, CopyWrite, DataSeg, LongPointerFromSeg,    LongWrite, MDS, PointerFromSeg, Read, SetBusy, Write],  PrincOps USING [    AV, ControlLink, ESCTrapTable,    FrameSizeIndex, GlobalCodebase, frameSizeMap,     LargeReturnSlot, LastAVHeapSlot, LocalOverhead],  PrincOpsExtras2,  PSB USING [ProcessDataArea, ProcessStateBlock],  SDDefs USING [sBoot, sSystemDate, SD],  Space,  StartList USING [StateVectorCounts],  Time USING [Packed],  MBStorage USING [PagesForWords];MBMain: PROGRAM  IMPORTS LoadedMem, MB, MBOut, MBVM, MBStorage, PrincOpsExtras2, Space   EXPORTS MB   SHARES PrincOps =BEGIN OPEN PrincOps;BYTE: TYPE = [0..256);data: MB.Handle ¬ NIL;values: LONG POINTER TO Values ¬ NIL;Values: TYPE = RECORD [  frameWeights: PACKED ARRAY [0..LastAVHeapSlot] OF BYTE ¬ ALL[LAST[BYTE]],  frameListEnds: PACKED ARRAY [0..LastAVHeapSlot] OF BYTE ¬ ALL[LAST[BYTE]]];DefaultValues: Values = [  frameWeights: [9,13,9,8,7,6,4,2,2,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],  frameListEnds:     [6B,12B,16B,22B,26B,32B,36B,42B,46B,52B,56B,1,66B,72B,76B,102B,106B,112B,    1,1,1,1,1,1,1,1,1,1,1,1,1]];  heapFrames, extraFrames: FrameCounts ¬ NIL;FrameCounts: TYPE = LONG POINTER TO FrameCountTable;FrameCountTable: TYPE = ARRAY FrameSizeIndex OF CARDINAL;GetData: PUBLIC PROC RETURNS [h: MB.Handle] = {RETURN[data]};InitMain: PUBLIC PROC [h: MB.Handle] = {  IF data # NIL THEN FinishMain[];  data ¬ h;  values ¬ data.z.NEW[Values ¬ []];  heapFrames ¬ data.z.NEW[FrameCountTable ¬ ALL[0]];  extraFrames ¬ data.z.NEW[FrameCountTable ¬ ALL[0]];  FOR i: CARDINAL IN [0..8) DO    h.stateVectorCounts[i] ¬ LAST[CARDINAL];    ENDLOOP;  h.nProcesses ¬ LAST[CARDINAL];  h.framePages ¬ LAST[CARDINAL];  h.pdaPages ¬ LAST[CARDINAL];  h.svSize ¬ LAST[CARDINAL];  h.lsModules ¬ LAST[CARDINAL];  h.lsBcds ¬ LAST[CARDINAL];  h.mdsBase ¬ LAST[CARDINAL];  h.codeBase ¬ LAST[CARDINAL]};FinishMain: PUBLIC PROC = {  IF heapFrames # NIL THEN data.z.FREE[@heapFrames];   IF extraFrames # NIL THEN data.z.FREE[@extraFrames];   IF values # NIL THEN data.z.FREE[@values];   IF data.gft # NIL THEN data.gft ¬ Space.Unmap[data.gft];  data ¬ NIL};  -- Memory initializationInitMemory: PUBLIC PROC = {  AssignDefaults[];  MB.EnumerateReservedMemory[MBVM.SetBusy];  IF ~data.germ THEN InitPDA[];  InitializeMDS[];  AllocateLocalFrames[];  InitializeGFT[]};WPP: CARDINAL = Environment.wordsPerPage;InitializeGFT: PROC = {  gftpages, gftwords, firstentry, lastentry, base: CARDINAL;  gftitem: PrincOpsExtras2.GFTItem;  gftBase: CARDINAL ¬ CARDINAL[data.gftBase];  baseptr: LONG POINTER ¬ LOOPHOLE[LONG[gftBase] * WPP];  gft: MB.GFTSequenceHandle;  seg: MBVM.DataSeg;  IF data.germ THEN {    gftpages ¬ 1;    firstentry ¬ 1; lastentry ¬ PrincOpsExtras2.GermUseOnly.LAST;    base ¬ gftBase;    }  ELSE {    entries: CARDINAL ¬ data.nGFTs +       PrincOpsExtras2.Reserved.LAST - PrincOpsExtras2.Reserved.FIRST + 1;    -- must have 1st page of GFT alloced, though not used    seg ¬ MBVM.AllocData[base: gftBase, pages: 1, dir: up];    seg.bootLoaded ¬ TRUE; seg.info ¬ [readOnly: FALSE, state: resident];    gftwords ¬ entries * SIZE[PrincOpsExtras2.GFTItem];    gftpages ¬ (gftwords + WPP - 1) / WPP;    base ¬ gftBase + 1;    firstentry ¬ PrincOpsExtras2.Reserved.LAST + 1;    lastentry ¬ firstentry + data.nGFTs - 1;    };  data.lastgfti ¬ firstentry;  seg ¬ MBVM.AllocData[base: base, pages: gftpages, dir: up];  seg.info.readOnly ¬ FALSE;  seg.bootLoaded ¬ TRUE;  IF data.germ THEN {    seg.info ¬ [readOnly: FALSE, state: resident];    };  gft ¬ data.gft ¬ Space.ScratchMap[gftpages+1];  -- set up the linked list data structure  FOR i: PrincOpsExtras2.GFTIndex IN [firstentry..lastentry] DO    thisGFTH: PrincOpsExtras2.GFTHandle ¬ PrincOpsExtras2.GFTIndexToHandle[i];     nextGFTH: PrincOpsExtras2.GFTHandle ¬       IF i = lastentry THEN PrincOpsExtras2.nullGFH ELSE       LOOPHOLE[thisGFTH + SIZE[PrincOpsExtras2.GFTItem],       PrincOpsExtras2.GFTHandle];    gft[i] ¬ [free[next: nextGFTH]];    ENDLOOP;  -- initialize the first few entries  gftitem ¬ [free[next: PrincOpsExtras2.nullGFH]];  IF data.germ THEN gft[0] ¬ gftitem  ELSE {    FOR i: PrincOpsExtras2.GFTIndex IN PrincOpsExtras2.Reserved DO      gft[i] ¬ gftitem;      ENDLOOP;    };  };AssignDefaults: PROC = {  i: CARDINAL;  FOR i IN [0..8) DO    IF data.stateVectorCounts[i] = LAST[CARDINAL] THEN      data.stateVectorCounts[i] ¬ SimpleDefaults.stateVectorCounts[i];    ENDLOOP;  FOR i IN [0..LastAVHeapSlot] DO    IF values.frameWeights[i] = LAST[BYTE] THEN       values.frameWeights[i] ¬ DefaultValues.frameWeights[i];    IF values.frameListEnds[i] = LAST[BYTE] THEN       values.frameListEnds[i] ¬ DefaultValues.frameListEnds[i];    ENDLOOP;  IF data.lsModules = LAST[CARDINAL] THEN     data.lsModules ¬ SimpleDefaults.lsModules;  IF data.lsBcds = LAST[CARDINAL] THEN     data.lsBcds ¬ SimpleDefaults.lsBcds;  IF data.mdsBase = LAST[CARDINAL] THEN     data.mdsBase ¬ SimpleDefaults.mdsBase;  IF data.codeBase = LAST[CARDINAL] THEN     data.codeBase ¬ SimpleDefaults.codeBase;  IF data.pdaPages = LAST[CARDINAL] THEN     data.pdaPages ¬ SimpleDefaults.pdaPages;  IF data.nProcesses = LAST[CARDINAL] THEN     data.nProcesses ¬ SimpleDefaults.nProcesses;  IF data.framePages = LAST[CARDINAL] THEN     data.framePages ¬ SimpleDefaults.framePages};SetReservedSegBits: PROC [s: MBVM.DataSeg] = {  s.info ¬ [FALSE, resident];  s.bootLoaded ¬ TRUE};InitPDA: PROC = {  seg: MBVM.DataSeg;  pda: LONG POINTER;  i: CARDINAL;  words: CARDINAL ¬ 0;  FOR i IN [0..8) DO     words ¬ words + data.stateVectorCounts[i]*data.svSize;    ENDLOOP;  data.pdaPages ¬ MAX[    MBStorage.PagesForWords[      data.nProcesses*(SIZE[PSB.ProcessStateBlock]+1) +      words + SIZE[PSB.ProcessDataArea]],    data.pdaPages];  seg ¬ MBVM.AllocData[base: 256, pages: data.pdaPages, dir: up];  SetReservedSegBits[seg];  pda ¬ MBVM.LongPointerFromSeg[seg];  FOR i IN [0..CARDINAL[data.pdaPages*Environment.wordsPerPage]) DO     MBVM.LongWrite[pda+i, 0];    ENDLOOP};    AVPages: CARDINAL = 1;AVPage: CARDINAL = LOOPHOLE[PrincOps.AV, CARDINAL]/256;SDPages: CARDINAL = 2;SDPage: CARDINAL = LOOPHOLE[SDDefs.SD, CARDINAL]/256;ESCTrapPages: CARDINAL = 2;ESCTrapPage: CARDINAL = LOOPHOLE[PrincOps.ESCTrapTable, CARDINAL]/256;InitializeMDS: PROC = {  seg: MBVM.DataSeg;  p: POINTER;  -- av  p ¬ PrincOps.AV;  SetReservedSegBits[seg ¬ MBVM.AllocMDSData[base: AVPage, pages: AVPages]];  FOR i: CARDINAL IN [0..Environment.wordsPerPage*AVPages) DO    MBVM.Write[p+i, 0] ENDLOOP;  InitAV[p];  -- ESCTrapTable  p ¬ PrincOps.ESCTrapTable;  SetReservedSegBits[seg ¬ MBVM.AllocMDSData[    base: ESCTrapPage, pages: ESCTrapPages]];  FOR i: CARDINAL IN [0..Environment.wordsPerPage*ESCTrapPages) DO    MBVM.Write[p+i, 0] ENDLOOP;  -- sd  p ¬ SDDefs.SD;  SetReservedSegBits[seg ¬ MBVM.AllocMDSData[base: SDPage, pages: SDPages]];  FOR i: CARDINAL IN [0..Environment.wordsPerPage*SDPages) DO    MBVM.Write[p+i, 0] ENDLOOP;  MBVM.CopyWrite[    to: @SDDefs.SD[SDDefs.sSystemDate], from: @data.buildTime,    nwords: SIZE[Time.Packed]];  };InitAV: PROC [av: POINTER] = {  i: CARDINAL;  FOR i IN [0..LastAVHeapSlot] DO    MBVM.Write[av+i, values.frameListEnds[i]]; ENDLOOP;  MBVM.Write[av+LargeReturnSlot, 1]};  TurnOffStartTrap: PUBLIC PROC = {  DoIt: PROC [bh: MB.BHandle, mth: BcdOps.MTHandle] RETURNS [BOOLEAN] = {    f: PrincOpsExtras2.LongGlobalFrameHandle = bh.mt[MB.FindGFI[bh, mth]].frame;    fcb: PrincOps.GlobalCodebase;    fcb ¬ LoadedMem.ReadCodebase[f];    fcb.out ¬ FALSE;    LoadedMem.WriteCodebase[gf: LoadedMem.GFTHandleFromGlobalFrame[f], gcb: fcb];    RETURN[FALSE]};  proc: PrincOpsExtras2.ControlLink ¬ StartControlLink[];  MB.EnumerateNoTrapModules[DoIt];  MBVM.CopyWrite[    to: @SDDefs.SD[SDDefs.sBoot], from: @proc, nwords: SIZE[PrincOpsExtras2.ControlLink]]};StartControlLink: PUBLIC PROC RETURNS [proc: PrincOpsExtras2.ControlLink] = {  mth: BcdOps.MTHandle;  bh: MB.BHandle;  start: PrincOpsExtras2.LongGlobalFrameHandle;  fw: PrincOpsExtras2.ExtraGlobalWord;  enb: BcdDefs.Base;  [bh, mth] ¬ MB.WartMTH[];  start ¬ bh.mt[MB.FindGFI[bh, mth]].frame;  fw ¬ LoadedMem.ReadExtraGlobalWord[start];  enb ¬ LOOPHOLE[bh.bcd + bh.bcd.enOffset];  proc ¬ [longProc[gfi:     LoadedMem.GFTHandleFromGlobalFrame[start]+    ORD[PrincOpsExtras2.ControlLinkTag.longProc],     pc: enb[mth.entries].initialPC[0]]];  fw.started ¬ TRUE;  LoadedMem.WriteExtraGlobalWord[gf: start, xgw: fw]};-- Frame AllocationSimpleValues: TYPE = RECORD [  mdsBase, codeBase: MBVM.Base,  nProcesses: CARDINAL,  framePages: CARDINAL,  pdaPages: CARDINAL,  lsModules: CARDINAL,  lsBcds: CARDINAL,  svSize: CARDINAL,  stateVectorCounts: StartList.StateVectorCounts];SimpleDefaults: SimpleValues = [  mdsBase: 512,  codeBase: 768,  nProcesses: 50,  framePages: 10,  pdaPages: 1,  lsModules: 10,  lsBcds: 1,  svSize: 20B,  stateVectorCounts: [1,1,3,1,1,3,1,1]];  GetFrameWeight: PUBLIC PROC [index: CARDINAL] RETURNS [weight: CARDINAL] = {  RETURN[values.frameWeights[index]]};SetFrameWeight: PUBLIC PROC [index, weight: CARDINAL] = {  values.frameWeights[index] ¬ weight};GetFrameListEnd: PUBLIC PROC [index: CARDINAL] RETURNS [end: CARDINAL] = {  RETURN[values.frameListEnds[index]]};SetFrameListEnd: PUBLIC PROC [index, end: CARDINAL] = {  values.frameListEnds[index] ¬ end};AllocateFrames: PUBLIC PROC [size: CARDINAL, single, resident: BOOLEAN]  RETURNS [frames: POINTER, inFrameHeap: BOOLEAN] = {  pages: CARDINAL;  seg: MBVM.DataSeg;  IF single THEN  -- allocate from frame heap    RETURN[MB.Alloc[MakeFsi[size]], TRUE];  pages ¬ MBStorage.PagesForWords[size];  seg ¬ MBVM.AllocData[base: MBVM.MDS, pages: pages, dir: up];  frames ¬ MBVM.PointerFromSeg[seg];  seg.info.readOnly ¬ FALSE;  IF resident THEN {    seg.bootLoaded ¬ TRUE;    seg.info.state ¬ resident;    DivideAllocationArea[frames+size, pages*Environment.wordsPerPage - size, extraFrames]};  RETURN[frames, FALSE]};    AllocateLocalFrames: PUBLIC PROC = {  pages: CARDINAL;  seg: MBVM.DataSeg;  localHeapSize: CARDINAL ¬ 0;  FOR i: CARDINAL IN [0..LastAVHeapSlot] DO    localHeapSize ¬ localHeapSize + values.frameWeights[i]*frameSizeMap[i];    ENDLOOP;  pages ¬ MAX[MBStorage.PagesForWords[localHeapSize], CARDINAL[data.framePages]];  seg ¬ MBVM.AllocData[base: MBVM.MDS, pages: pages, dir: up];  seg.bootLoaded ¬ TRUE;    seg.info ¬ [FALSE, resident];  DivideAllocationArea[MBVM.PointerFromSeg[seg], pages*Environment.wordsPerPage, heapFrames]};MakeFsi: PUBLIC PROC [nwords: CARDINAL] RETURNS [fsi: CARDINAL] = {  FOR fsi IN [0..LENGTH[frameSizeMap]) DO    IF frameSizeMap[fsi] >= nwords + SIZE[LocalOverhead] THEN      RETURN[fsi];    ENDLOOP;  MB.Error["Can't make frame size"L];  RETURN[0]};DivideAllocationArea: PROC [base: POINTER, size: CARDINAL, counts: FrameCounts] = {  p: POINTER ¬ base+4;	-- allow initial dead space  i, s, c, sum, z: CARDINAL;  fw: ARRAY [0..LastAVHeapSlot] OF CARDINAL;  IF size < frameSizeMap[0]+4 THEN RETURN;  FOR i IN [0..LENGTH[fw]) DO fw[i] ¬ values.frameWeights[i] ENDLOOP;  size ¬ size-4;  sum ¬ 0;  FOR i IN [0..LENGTH[fw]) DO sum ¬ sum + frameSizeMap[i]*fw[i] ENDLOOP;  c ¬ MAX[size/sum, 1];  WHILE size > frameSizeMap[0] DO    FOR i IN [0..LENGTH[frameSizeMap]) DO      s ¬ frameSizeMap[i];      FOR j: CARDINAL IN[1..fw[i]*c] DO	z ¬ LOOPHOLE[p, CARDINAL] MOD 256;	IF size < s THEN EXIT;	IF z = 252 THEN {p ¬ p + 4;  size ¬ size - 4};	-- add to alloc vector	IF size < s THEN EXIT;	MBVM.Write[p, i];	  -- hidden link word	MBVM.Write[p+SIZE[PrincOps.LocalOverhead], MBVM.Read[PrincOps.AV+i]];	MBVM.Write[PrincOps.AV+i, p+SIZE[PrincOps.LocalOverhead]];        counts[i] ¬ counts[i] + 1;	p¬p+s;  size¬size-s;	ENDLOOP;      ENDLOOP;    FOR i IN [0..LENGTH[fw]-1) DO fw[i] ¬ MAX[fw[i]/3, 1] ENDLOOP;    c ¬ 1;    ENDLOOP};ReportFrameAllocation: PUBLIC PROC = {  OPEN MBOut;  CR[];  Line["LOCAL FRAMES ALLOCATED (total (=heap+serendipity)):"L];  CR[];  FOR i: PrincOps.FrameSizeIndex IN PrincOps.FrameSizeIndex DO    Number[i, [10, FALSE, FALSE, 4]]; Text[":  "L];    IF extraFrames[i] = 0 THEN Decimal[heapFrames[i]]    ELSE {      Decimal[heapFrames[i]+extraFrames[i]]; Text[" (="L];      Decimal[heapFrames[i]]; Char['+];      Decimal[extraFrames[i]]; Char[')]};    CR[];    ENDLOOP};END.
-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- MBOutput.mesa   --   JGS	15-Oct-82 17:32:39--   Lewis	19-Apr-83 10:27:25--   Davirro	19-Aug-83 11:52:57--   Johnsson	18-Sep-83 17:32:26 --   BGY	19-Feb-87 11:43:48 DIRECTORY  BootFile USING [    MapEntry, Header, maxEntriesPerHeader, maxEntriesPerTrailer, Trailer,    currentVersion],  Checksum USING [ComputeChecksum],  Environment USING [bytesPerWord, wordsPerPage],  File USING [File],  Inline USING [LongMult, LowHalf],  MB USING [Error, Handle, Zero, AltoSegmentStart],  MBOut USING [CR, NumberFormat, Char, Line, LongNumber, Number, Text],  MBVM USING [    Base, CodePiece, CodeSeg, DataSeg, FileSeg, GetPage,    ReleaseCodeSegs, Seg, SortSegs, Write],  MFile USING [Acquire, Error, CopyFileHandle, GetLength, Handle, Release, SetTimes],  MSegment USING [Address, Create, Delete, Handle],  MStream USING [GetFile, GetLength, Handle, ReadWrite, SetLength],  PageMap USING [Flags, flagsClean, flagsReadonly],  PrincOpsExtras2 USING [ControlLink],  SDDefs USING [SD, sGermChecksum, sGermCount],  StartList USING [Base, Entry, Index, StartIndex, SwapUnitIndex, SwapUnitInfo],  SpecialMFile USING [GetCapaWithAccess],  MBStorage USING [Pages, FreePages],  Stream USING [Delete, Handle, GetPosition, SetPosition, PutBlock, PutWord],  MBTTY USING [Handle, PutLine, PutString],  TemporaryBooting USING [MakeUnbootable];MBOutput: PROGRAM  IMPORTS    Checksum, Inline, MB, MBOut, MBVM, MFile, MStream, MSegment, MBStorage,    SpecialMFile, Stream, MBTTY, TemporaryBooting  EXPORTS MB =BEGIN OPEN MBVM;bytesPerWord: CARDINAL = Environment.bytesPerWord;wordsPerPage: CARDINAL = Environment.wordsPerPage;data: MB.Handle ¬ NIL;header: LONG POINTER TO BootFile.Header ¬ NIL;trailer: LONG POINTER TO BootFile.Trailer ¬ NIL;nEntries, currentEntry: CARDINAL;filePage, trailerIndex: LONG CARDINAL;InitOutput: PUBLIC PROC [h: MB.Handle] = {  IF data # NIL THEN FinishOutput[];   data ¬ h};FinishOutput: PUBLIC PROC = {  IF header # NIL THEN {MBStorage.FreePages[header]; header ¬ NIL};  IF trailer # NIL THEN {MBStorage.FreePages[trailer]; trailer ¬ NIL};  IF data.bootStream # NIL THEN {    Stream.Delete[data.bootStream];    data.bootStream ¬ NIL};  data ¬ NIL};  -- Boot file (not germ) outputWriteBootFile: PUBLIC PROC = {  tty: MBTTY.Handle = data.ttyHandle;  segs: LONG DESCRIPTOR FOR ARRAY OF MBVM.Seg ¬ MBVM.SortSegs[];  MBTTY.PutString[tty, "Writing boot file..."L];  InitBootStream[];  WriteVM[data.bootStream, segs ! UNWIND => MBStorage.FreePages[BASE[segs]]];  MBStorage.FreePages[BASE[segs]];  Stream.SetPosition[data.bootStream, 0];  PutBlock[data.bootStream, header, 0, wordsPerPage];  MStream.SetLength[data.bootStream, MStream.GetLength[data.bootStream]];  Stream.Delete[data.bootStream];  data.bootStream ¬ NIL;  MBVM.ReleaseCodeSegs[];  MBTTY.PutLine[tty, "finished writing."L]};OpenFile: PROC[name: LONG STRING] RETURNS [stream: Stream.Handle] = {  mfile: MFile.Handle ¬ NIL;  file: File.File;  stream ¬ NIL;  mfile ¬ MFile.Acquire[name, anchor, []!MFile.Error => CONTINUE];  IF mfile # NIL THEN {    file ¬ SpecialMFile.GetCapaWithAccess[mfile];    TemporaryBooting.MakeUnbootable[file, 1];    mfile.Release[];    mfile ¬ NIL;    };  stream ¬ MStream.ReadWrite[name, [], binary];  };InitBootStream: PROC = {  stream: MStream.Handle ¬ OpenFile[data.output];  MStream.SetLength[stream, Inline.LongMult[    CARDINAL[data.nFilePages], wordsPerPage*2]];  stream.Delete[];  stream ¬ MStream.ReadWrite[data.output, [], binary];  MFile.SetTimes[file: MStream.GetFile[stream], create: data.buildTime];  stream.SetPosition[wordsPerPage*2];  -- skip over header page  data.bootStream ¬ stream;  data.bootHeader ¬ header ¬ MBStorage.Pages[1];  MB.Zero[header, wordsPerPage];  header­ ¬ BootFile.Header[    creationDate: data.buildTime, pStartListHeader: data.header.table,    inLoadMode: load, mds: CARDINAL[data.mdsBase]/256,     countData: data.nBootPages, entries: NULL, switches: LOOPHOLE[data.switches]];  nEntries ¬ BootFile.maxEntriesPerHeader;  currentEntry ¬ 0;  filePage ¬ 2;  trailer ¬ NIL};realGFTBase: CARDINAL;WriteVM: PROC [    stream: Stream.Handle, segs: LONG DESCRIPTOR FOR ARRAY OF MBVM.Seg] = {  tty: MBTTY.Handle = data.ttyHandle;  i: CARDINAL;  seg: MBVM.Seg;  scriptBase: StartList.Base = data.scriptBase;  index: StartList.Index ¬ StartList.StartIndex;  gftBase: MBVM.Base ¬ data.gftBase;  MBOut.CR[];  MBOut.Line["  Boot File"L];  MBOut.Line["File   VM       Map    Type"L];  MBOut.Line["Base   Address  Flags"L];  MBOut.Number[1, [8,FALSE,FALSE,4]];  -- header page  MBOut.Line["   Header Page"L];  MBTTY.PutString[tty, "bootloaded memory..."L];  realGFTBase ¬ CARDINAL[data.gftBase] +(IF data.germ THEN 0 ELSE 1);  FOR i IN [0..LENGTH[segs]) DO    seg ¬ segs[i];    IF ~seg.bootLoaded THEN LOOP;    WITH s: seg SELECT FROM      data =>        IF s.base # gftBase OR data.germ THEN WriteDataSeg[stream, @s]	ELSE {--data.bootHeader.countData ¬ data.bootHeader.countData-1--};      code => WriteCodeSeg[stream, @s];      file => WriteFileSeg[stream, @s];      ENDCASE;    ENDLOOP;  IF trailer # NIL THEN [] ¬ WriteTrailerPage[stream];  MBOut.CR[];  MBOut.Line["  Nonresident Memory"L];  MBOut.Line["File  Pages  VM       Type [base,pages]"L];  MBOut.Line["Base         Address"L];  MBTTY.PutString[tty, "nonresident memory..."L];  FOR i IN [0..LENGTH[segs]) DO    info: StartList.SwapUnitInfo;    seg ¬ segs[i];    info ¬ scriptBase[seg.index].info;    WITH s: seg SELECT FROM      data =>         IF info.state # resident THEN {	  IF ~data.utilityPilot THEN AppendDataSeg[stream, @s]}	ELSE data.nResidentPages ¬ data.nResidentPages + s.pages;      code => IF ~data.utilityPilot THEN AppendCodeSeg[stream, @s];      file =>        IF info.state # resident THEN {	  IF ~data.utilityPilot THEN AppendFileSeg[stream, @s]}	ELSE data.nResidentPages ¬ data.nResidentPages + s.pages;      ENDCASE;    ENDLOOP};WriteDataSeg: PROC [stream: Stream.Handle, seg: MBVM.DataSeg] = {  lp: LONG POINTER;  flags: PageMap.Flags ¬ MapFlagsForSeg[seg];  FOR page: LONG CARDINAL IN [seg.base..seg.base+seg.pages) DO    EnterPage[page: page, flags: flags, stream: stream];    BootPageToLoadmap[      filePage: filePage, vmPage: page, flags: flags, type: "data"L];    lp ¬ MBVM.GetPage[page, FALSE];    IF lp = NIL THEN WriteEmptyPage[stream] ELSE WritePage[stream, lp];    ENDLOOP};WriteCodeSeg: PROC [stream: Stream.Handle, seg: MBVM.CodeSeg] = {  page: LONG CARDINAL ¬ seg.base;  nUnits: CARDINAL ¬ IF seg.sph = NIL THEN 1 ELSE seg.sph.length;  index: StartList.SwapUnitIndex ¬ seg.index;  flags: PageMap.Flags ¬ MapFlagsForSeg[seg];  scriptBase: StartList.Base = data.scriptBase;  mSeg: MSegment.Handle ¬ MSegment.Create[    file: MFile.CopyFileHandle[file: seg.file, access: readOnly, release: []],    release: [], fileBase: (seg.fileBase - MB.AltoSegmentStart), pages: seg.pages];  base: LONG POINTER = MSegment.Address[mSeg];  piece: MBVM.CodePiece ¬ seg.codePiece;  su: LONG POINTER TO swapUnit StartList.Entry;  offset: CARDINAL ¬ 0;  FOR i: CARDINAL IN [0..nUnits) DO    ENABLE UNWIND => MSegment.Delete[mSeg];    su ¬ @scriptBase[index];    FOR j: LONG CARDINAL IN [0..su.pages) DO      IF scriptBase[su.parent].bootLoaded THEN {	EnterPage[page: page, flags: flags, stream: stream];	BootPageToLoadmap[	  filePage: filePage, vmPage: page, flags: flags, type: "code"L];        filePage ¬ filePage + 1;	piece ¬ WriteCodeWords[stream, base, offset, wordsPerPage, piece]};      page ¬ page + 1;      offset ¬ offset + wordsPerPage;      ENDLOOP;    index ¬ index + SIZE[swapUnit StartList.Entry];    ENDLOOP;  MSegment.Delete[mSeg]};WriteFileSeg: PROC [stream: Stream.Handle, seg: MBVM.FileSeg] = {  flags: PageMap.Flags ¬ MapFlagsForSeg[seg];  lp: LONG POINTER ¬ MSegment.Address[seg.segment];  FOR page: LONG CARDINAL IN [seg.base..seg.base+seg.pages) DO    EnterPage[page: page, flags: flags, stream: stream];    BootPageToLoadmap[      filePage: filePage, vmPage: page, flags: flags, type: "file"L];    WritePage[stream, lp];    lp ¬ lp + wordsPerPage;    ENDLOOP};AppendDataSeg: PROC [stream: Stream.Handle, seg: MBVM.DataSeg] = {  lp: LONG POINTER;  index: StartList.SwapUnitIndex ¬ seg.index;  base: StartList.Base = data.scriptBase;  IF base[base[index].parent].backingPage < data.lastBootLoadedFilePage THEN    RETURN;  IF seg.base = realGFTBase THEN RETURN;  SegToLoadmap[seg, filePage];  FOR page: LONG CARDINAL IN [seg.base..seg.base+seg.pages) DO    lp ¬ MBVM.GetPage[page, FALSE];    IF lp = NIL THEN WriteEmptyPage[stream] ELSE WritePage[stream, lp];    ENDLOOP};AppendCodeSeg: PROC [stream: Stream.Handle, seg: MBVM.CodeSeg] = {  nUnits: CARDINAL ¬ IF seg.sph = NIL THEN 1 ELSE seg.sph.length;  index: StartList.SwapUnitIndex ¬ seg.index;  scriptBase: StartList.Base = data.scriptBase;  mSeg: MSegment.Handle ¬ MSegment.Create[    file: MFile.CopyFileHandle[file: seg.file, access: readOnly, release: []],    release: [], fileBase: (seg.fileBase - MB.AltoSegmentStart), pages: seg.pages];  base: LONG POINTER = MSegment.Address[mSeg];  piece: MBVM.CodePiece ¬ seg.codePiece;  su: LONG POINTER TO swapUnit StartList.Entry;  offset: CARDINAL ¬ 0;  FOR i: CARDINAL IN [0..nUnits) DO    ENABLE UNWIND => MSegment.Delete[mSeg];    su ¬ @scriptBase[index];    IF su.info.state # resident THEN {      IF scriptBase[su.parent].backingPage >= data.lastBootLoadedFilePage THEN {        filePage ¬ filePage + su.pages;        piece ¬	  WriteCodeWords[	    stream, base, offset, CARDINAL[su.pages*wordsPerPage], piece]}}    ELSE data.nResidentPages ¬ data.nResidentPages + su.pages;    offset ¬ offset + CARDINAL[su.pages*wordsPerPage];    index ¬ index + SIZE[swapUnit StartList.Entry];    ENDLOOP;  MSegment.Delete[mSeg]};AppendFileSeg: PROC [stream: Stream.Handle, seg: MBVM.FileSeg] = {  lp: LONG POINTER;  index: StartList.SwapUnitIndex ¬ seg.index;  base: StartList.Base = data.scriptBase;  IF base[base[index].parent].backingPage < data.lastBootLoadedFilePage THEN    RETURN;  SegToLoadmap[seg, filePage];  lp ¬ MSegment.Address[seg.segment];  FOR i: LONG CARDINAL IN [0..seg.pages) DO    WritePage[stream, lp];  lp ¬ lp + wordsPerPage;    ENDLOOP};    -- Germ file outputWriteGermFile: PUBLIC PROC = {  tty: MBTTY.Handle = data.ttyHandle;  segs: LONG DESCRIPTOR FOR ARRAY OF MBVM.Seg ¬ MBVM.SortSegs[];  bootFileLength: LONG CARDINAL;  fileCopy: MFile.Handle;  MBTTY.PutString[tty, "Writing germ..."L];  data.bootStream ¬ InitGermFile[];  WriteGerm[data.bootStream, segs ! UNWIND => MBStorage.FreePages[BASE[segs]]];  MBStorage.FreePages[BASE[segs]];  bootFileLength ¬ MStream.GetLength[data.bootStream];  MStream.SetLength[data.bootStream, bootFileLength];  -- compute checksum for germ file  fileCopy ¬ MFile.CopyFileHandle[    file: MStream.GetFile[data.bootStream], release: [], access: readWrite];  Stream.Delete[data.bootStream];  data.bootStream ¬ NIL;  SetGermChecksum[    file: fileCopy,    checksumOffset: LOOPHOLE[@SDDefs.SD[SDDefs.sGermChecksum], CARDINAL]];  MBVM.ReleaseCodeSegs[];  MBTTY.PutLine[tty, "finished writing."L];  data.nFilePages ¬ filePage-1};InitGermFile: PROC RETURNS [bootStream: Stream.Handle] = {  bootStream ¬ MStream.ReadWrite[data.output, [], binary];  MFile.SetTimes[file: MStream.GetFile[bootStream], create: data.buildTime];  MBOut.CR[];  MBOut.Line["  Germ File"L];  MBOut.Line["Base  Address   Flags"L];  filePage ¬ 1};WriteGerm: PROC [    stream: Stream.Handle, segs: LONG DESCRIPTOR FOR ARRAY OF MBVM.Seg] = {  germPages: LONG CARDINAL ¬ 0;  gftEntry: CARDINAL ¬ LENGTH[segs]-1;  FOR i: CARDINAL IN [0..LENGTH[segs]) DO    WITH s: segs[i] SELECT FROM      data => IF @s # data.lsseg THEN germPages ¬ germPages + s.pages;      code => germPages ¬ germPages + s.pages;      file => NULL;      ENDCASE;    ENDLOOP;  MBVM.Write[p: @SDDefs.SD[SDDefs.sGermCount], v: CARDINAL[germPages]];  -- the last segment better be the GFT table  WITH s: segs[gftEntry] SELECT FROM    data => IF @s # data.lsseg THEN WriteGermData[stream, @s];    ENDCASE => ERROR;  -- expecting last segment to be gft;  FOR i: CARDINAL IN [0..LENGTH[segs]-1) DO    WITH s: segs[i] SELECT FROM      data => IF @s # data.lsseg THEN WriteGermData[stream, @s];      code => WriteGermCode[stream, @s];      file => NULL;      ENDCASE;    ENDLOOP};WriteGermData: PROC [stream: Stream.Handle, seg: MBVM.DataSeg] = {  lp: LONG POINTER;  flags: PageMap.Flags ¬ MapFlagsForSeg[seg];  FOR page: LONG CARDINAL IN [seg.base..seg.base+seg.pages) DO    BootPageToLoadmap[      filePage: filePage, vmPage: page, flags: flags, type: "data"L];    lp ¬ MBVM.GetPage[page, FALSE];    IF lp = NIL THEN WriteEmptyPage[stream] ELSE WritePage[stream, lp];    ENDLOOP};WriteGermCode: PROC [stream: Stream.Handle, seg: MBVM.CodeSeg] = {  flags: PageMap.Flags ¬ MapFlagsForSeg[seg];  mSeg: MSegment.Handle ¬ MSegment.Create[    file: MFile.CopyFileHandle[file: seg.file, access: readOnly, release: []],    release: [], fileBase: (seg.fileBase - MB.AltoSegmentStart), pages: seg.pages];  base: LONG POINTER = MSegment.Address[mSeg];  piece: MBVM.CodePiece ¬ seg.codePiece;  offset: CARDINAL ¬ 0;  FOR page: LONG CARDINAL IN [seg.base..seg.base+seg.pages) DO    ENABLE UNWIND => MSegment.Delete[mSeg];    BootPageToLoadmap[      filePage: filePage, vmPage: page, flags: flags, type: "code"L];    filePage ¬ filePage + 1;    piece ¬ WriteCodeWords[stream, base, offset, wordsPerPage, piece];    offset ¬ offset + wordsPerPage;    ENDLOOP;  MSegment.Delete[mSeg]};    SetGermChecksum: PROC [file: MFile.Handle, checksumOffset: CARDINAL] = {  seg: MSegment.Handle;  words: LONG CARDINAL;  buffer: LONG POINTER;  words ¬ (MFile.GetLength[file]+1)/2;  seg ¬ MSegment.Create[file: file, release: [], fileBase: 0];  buffer ¬ MSegment.Address[seg];  IF words > 64000 THEN MB.Error["Can't fixup Checksum on Germs > 64K"L];   BEGIN  loc: LONG POINTER ¬ (buffer + checksumOffset);  oldCS: WORD = Checksum.ComputeChecksum[    cs: 0, nWords: Inline.LowHalf[words], p: buffer];  loc­ ¬ NewValueToMakeChecksumZero[    oldChecksum: oldCS,    oldValue: loc­, offsetOfOldValue: checksumOffset,    length: words];  END;  MSegment.Delete[seg]};  NewValueToMakeChecksumZero: PROC [      oldChecksum: WORD,      oldValue: WORD, offsetOfOldValue: LONG CARDINAL,  -- (word offset)      length: LONG CARDINAL]    RETURNS [newValue: WORD] = {  newValue ¬ OnesAdd[    LeftCycle[OnesSub[0, oldChecksum], offsetOfOldValue - length],    oldValue]};    OnesAdd: PROC [a, b: CARDINAL] RETURNS [c: CARDINAL] = {  c ¬ a + b;  IF c < a THEN c ¬ c + 1;  IF c = 177777B THEN c ¬ 0};  OnesSub: PROC [a, b: CARDINAL] RETURNS [c: CARDINAL] = {  c ¬ a + (-b - 1);  IF c < a THEN c ¬ c + 1;  IF c = 177777B THEN c ¬ 0};LeftCycle: PROC [a: WORD, b: LONG INTEGER] RETURNS [c: CARDINAL] = {  n: LONG INTEGER ¬ b MOD 16;  c ¬ a;  IF b < 0 THEN n ¬ n + 16;  UNTIL n = 0 DO    IF c < 100000B THEN c ¬ c*2 ELSE c ¬ c*2 + 1;    n ¬ n - 1;    ENDLOOP};  -- SubroutinesMapFlagsForSeg: PROC [seg: MBVM.Seg] RETURNS [PageMap.Flags] = {  RETURN[IF ~seg.info.readOnly     THEN PageMap.flagsClean ELSE PageMap.flagsReadonly]};EnterPage: PROC [page: MBVM.Base, flags: PageMap.Flags, stream: Stream.Handle] = {  entries: LONG POINTER TO ARRAY [0..0) OF BootFile.MapEntry;  IF currentEntry = nEntries THEN AddTrailerPage[stream];  entries ¬     (IF nEntries = BootFile.maxEntriesPerTrailer       THEN @trailer.entries       ELSE @header.entries);  entries[currentEntry] ¬ [virtual: page, flags: flags, real: 0];  currentEntry ¬ currentEntry + 1};AddTrailerPage: PROC [stream: Stream.Handle] = {  IF trailer # NIL THEN trailerIndex ¬ WriteTrailerPage[stream]  ELSE {  -- create trailer page    trailer ¬ MBStorage.Pages[1]; trailerIndex ¬ stream.GetPosition[]};  stream.SetPosition[trailerIndex+wordsPerPage*2];  MB.Zero[trailer, wordsPerPage];  trailer.version ¬ BootFile.currentVersion;  nEntries ¬ BootFile.maxEntriesPerTrailer;  currentEntry ¬ 0;  MBOut.LongNumber[filePage, [8,FALSE,FALSE,4]];  MBOut.Line["  Trailer Page"L];  filePage ¬ filePage + 1};WriteTrailerPage: PROC [stream: Stream.Handle] RETURNS [index: LONG CARDINAL] = {  index ¬ stream.GetPosition[];  stream.SetPosition[trailerIndex];  PutBlock[stream, trailer, 0, wordsPerPage];  stream.SetPosition[index]};WritePage: PROC [s: Stream.Handle, p: LONG POINTER] = {  filePage ¬ filePage + 1;  PutBlock[s, p, 0, wordsPerPage]};PutBlock: PROC [  s: Stream.Handle, p: LONG POINTER, startWord, stopWord: CARDINAL] = {  MaxBytesPerBlock: CARDINAL = (LAST[CARDINAL]/bytesPerWord)*bytesPerWord;  MaxWordsPerBlock: CARDINAL = MaxBytesPerBlock/bytesPerWord;  p ¬ p + startWord;  stopWord ¬ stopWord - startWord;  IF stopWord > MaxWordsPerBlock THEN {    [] ¬ s.PutBlock[[p, 0, MaxBytesPerBlock]];    stopWord ¬ stopWord - MaxWordsPerBlock;    p ¬ p + MaxWordsPerBlock};  [] ¬ s.PutBlock[[p, 0, stopWord*bytesPerWord]]};WriteEmptyPage: PROC [s: Stream.Handle] = {  filePage ¬ filePage + 1;  THROUGH [0..wordsPerPage) DO s.PutWord[0] ENDLOOP};WriteCodeWords: PROC [      s: Stream.Handle, base: LONG POINTER, offset: CARDINAL, count: CARDINAL,      piece: MBVM.CodePiece]     RETURNS [MBVM.CodePiece] = {  pieceOffset, pieceLength: CARDINAL;  data: LONG POINTER;  DO    pieceOffset ¬ piece.offset;    WITH p: piece SELECT FROM      code => {        pieceLength ¬ p.length;	data ¬ base + pieceOffset};      link => {        pieceLength ¬ p.links.length*SIZE[PrincOpsExtras2.ControlLink];	data ¬ @p.links[0]};      ENDCASE => Bug[];    IF offset IN [pieceOffset..pieceOffset+pieceLength) THEN {      offsetInPiece: CARDINAL = offset - pieceOffset;      nWords: CARDINAL = MIN[count, pieceLength - offsetInPiece];      PutBlock[s, data, offsetInPiece, offsetInPiece+nWords];      offset ¬ offset + nWords;      count ¬ count - nWords};    IF count = 0 THEN RETURN[piece];    piece ¬ piece.next;    IF piece = NIL THEN Bug[];    ENDLOOP};  Bug: PROC = {MB.Error["Bug in MBOutput"L]}; BootPageToLoadmap: PROC [    filePage, vmPage: LONG CARDINAL, flags: PageMap.Flags, type: STRING] = {  MBOut.LongNumber[filePage, [8,FALSE,FALSE,4]];  MBOut.LongNumber[(vmPage * wordsPerPage), [8,FALSE,FALSE,10]];  MBOut.Text["  "L];  IF flags.readonly THEN MBOut.Char['W] ELSE MBOut.Char[' ];  IF flags.dirty THEN MBOut.Char['D] ELSE MBOut.Char[' ];  IF flags.referenced THEN MBOut.Char['R] ELSE MBOut.Char[' ];  MBOut.Text[type];  MBOut.CR[]};SegToLoadmap: PROC [s: MBVM.Seg, backingPage: LONG CARDINAL] = {  octal: MBOut.NumberFormat = MBOut.NumberFormat[8,FALSE,FALSE,1];  base: MBOut.NumberFormat = MBOut.NumberFormat[8,FALSE,FALSE,4];  pages: MBOut.NumberFormat = MBOut.NumberFormat[8,FALSE,FALSE,6];  MBOut.LongNumber[backingPage, base];  MBOut.LongNumber[s.pages, pages];  MBOut.LongNumber[s.base*wordsPerPage, [8,FALSE,FALSE,10]];  MBOut.Text["  "L];  WITH seg: s SELECT FROM    data => MBOut.Text["data"L];    code => {      MBOut.Text["code ["L];  MBOut.Number[seg.fileBase, octal];      MBOut.Char[',];  MBOut.LongNumber[s.pages, octal];  MBOut.Char[']]};    file => {      MBOut.Text["file ["L];  MBOut.Number[seg.fileBase, octal];      MBOut.Char[',];  MBOut.LongNumber[s.pages, octal];  MBOut.Char[']]};    ENDCASE;  MBOut.CR[]};END.LOGBGY	19-Feb-87 11:44:28	  Added Temporary.MakeUnbootable for when a bootfile already exists
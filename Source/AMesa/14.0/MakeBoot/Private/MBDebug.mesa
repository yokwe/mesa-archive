-- Copyright (C) 1981, 1982, 1983  by Xerox Corporation. All rights reserved. -- MBDebug.mesa  --   Sandman	20-Jul-82 11:31:43--   Lewis	25-Sep-81 15:33:42--   Levin	June 3, 1982 6:28 pm--   Davirro	20-Jul-83 14:21:23--   Johnsson	29-Jul-83 11:41:13DIRECTORY  BcdDefs,  BcdOps,  BootFile,  String,  LoadedMem,  MB,  MBOut,  MBVM,  PrincOps,  PrincOpsExtras2,  MFile,  StartList;MBDebug: PROGRAM    IMPORTS BcdOps, LoadedMem, MB, MBOut, MFile, String, MBVM     EXPORTS MB =  BEGIN  octal: MBOut.NumberFormat =    MBOut.NumberFormat[base: 8, unsigned: TRUE, zerofill: FALSE, columns: 1];  data: MB.Handle ¬ NIL;  InitDebug: PUBLIC PROC [h: MB.Handle] = {    IF data # NIL THEN FinishDebug[];     data ¬ h};    FinishDebug: PUBLIC PROC = {data ¬ NIL};  DumpSegs: PUBLIC PROC = {    OPEN MBOut;    FileName: PROC [f: MFile.Handle] = {      name: STRING ¬ [100];      nss: String.SubStringDescriptor ¬ [base: name, offset: , length: 4];      bcdss: String.SubStringDescriptor ¬ [base: ".bcd"L, offset: 0, length: 4];      MFile.GetFullName[file: f, name: name];      IF name[name.length-1] = '. THEN name.length ¬ name.length - 1;      IF name.length > 4 THEN {        nss.offset ¬ name.length - 4;        IF String.EquivalentSubStrings[@nss, @bcdss] THEN          name.length ¬ name.length - 4};      Text[name]};    DumpSeg: PROC [s: MBVM.Seg] RETURNS [BOOLEAN] = {      Text["Seg["L];      LongNumber[s, octal];      Text["]  type: "L];      WITH seg: s SELECT FROM        data => Text["data"L];        code => Text["code"L];        file => Text["file"L];        ENDCASE;      Text[", vmpage: "L];      LongNumber[s.base, octal];      Text[", info: "L];      DumpSwapUnitInfo[s.info];      Text[", scriptIndex: "L];      Number[s.index, octal];      Text[", booted: "L];      Boolean[s.bootLoaded];      CR[];      WITH seg: s SELECT FROM        data => NULL;        code => {          Text["  location: "L];          FileName[seg.file]; Char['(]; LongNumber[seg.file, octal]; Char[')];          Char['[]; Number[seg.fileBase, octal]; Char[',];          LongNumber[s.pages, octal]; Char[']]; CR[]};        file => {          Text["  location: "L];          FileName[seg.file]; Char['(]; LongNumber[seg.file, octal]; Char[')];          Char['[]; Number[seg.fileBase, octal]; Char[',];          LongNumber[s.pages, octal]; Char[']]; CR[]};        ENDCASE;      RETURN[FALSE]};          CR[];    Line["SEGMENT TABLE JUST BEFORE SCRIPT CONSTRUCTION:"L];    CR[];    [] ¬ MBVM.EnumerateSegs[DumpSeg]};  DumpSwapUnitInfo: PROC [info: StartList.SwapUnitInfo] = {    OPEN MBOut;    Char['[];    Text["readOnly: "L];    Boolean[info.readOnly];    Text[", "L];    MBOut.Text[SELECT info.state FROM      resident => "resident"L,      residentDescriptor => "residentDescriptor"L,      ENDCASE => "swappable"L];    Char[']]};      DumpInputBcds: PUBLIC PROC = {    OPEN BcdDefs, BcdOps, MBOut;    CR[];    Line["INPUT BCDS:"L];    CR[];    FOR i: MB.BIndex IN [0..data.inputBCDs.nBcds) DO      bcd: BcdBase = data.inputBCDs.bcds[i].bcd;      ctb: Base = LOOPHOLE[bcd + bcd.ctOffset];      mtb: Base = LOOPHOLE[bcd + bcd.mtOffset];      ftb: Base = LOOPHOLE[bcd + bcd.ftOffset];      ssb: NameString = LOOPHOLE[bcd + bcd.ssOffset];      level: CARDINAL ¬ 2;      DumpName: PROC [name: NameRecord] = {        FOR i: CARDINAL IN [name..name+ssb.size[name]) DO          Char[ssb.string[i]];           ENDLOOP};      DumpCTName: PROC [cti: CTIndex] = {        cth: CTHandle = @ctb[cti];        IF cth.namedInstance THEN {          FindConfigInstanceName: PROC [nth: NTHandle, nti: NTIndex] RETURNS [BOOLEAN] = {            WITH namee: nth.item SELECT FROM              config => IF namee.cti = cti THEN {DumpName[nth.name]; RETURN[TRUE]};              ENDCASE;            RETURN[FALSE]};          [] ¬ ProcessNames[bcd, FindConfigInstanceName];          Text[": "L]};        DumpName[cth.name]};      DumpMTName: PROC [mti: MTIndex] = {        mth: MTHandle = @mtb[mti];        IF mth.namedInstance THEN {          FindModuleInstanceName: PROC [nth: NTHandle, nti: NTIndex] RETURNS [BOOLEAN] = {            WITH namee: nth.item SELECT FROM              module => IF namee.mti = mti THEN {DumpName[nth.name]; RETURN[TRUE]};              ENDCASE;            RETURN[FALSE]};          [] ¬ ProcessNames[bcd, FindModuleInstanceName];          Text[": "L]};        DumpName[mth.name]};      DumpConfigsWithParent: PROC [parentConfig: CTIndex] = {        DumpConfigsWithinParent: PROC [cth: CTHandle, cti: CTIndex] RETURNS [BOOLEAN] = {          IF cth.config = parentConfig THEN {            Spaces[level];            DumpCTName[cti];            IF cth.nControls > 0 THEN {              Text["  control list:"L];              FOR i: CARDINAL IN [0..cth.nControls) DO                Spaces[1];                WITH cItem: cth.controls[i] SELECT FROM                  module => DumpMTName[cItem.mti];                  config => DumpCTName[cItem.cti];                  ENDCASE;                ENDLOOP};            CR[];            level ¬ level + 2;            DumpConfigsWithParent[cti];            level ¬ level - 2};          RETURN[FALSE]};        DumpModulesWithinParent: PROC [mth: MTHandle, mti: MTIndex] RETURNS [BOOLEAN] = {          IF mth.config = parentConfig THEN {            Spaces[level];            DumpMTName[mti];            Text["  links: "L];            Text[SELECT mth.linkLoc FROM frame => "frame"L, ENDCASE => "code"L];            Text[", framesize: "L];            Number[mth.framesize, octal];            Text[", residentFrame: "L];            Boolean[mth.residentFrame];            Text[", packageable: "L];            Boolean[mth.packageable];            Text[", code: ["L];            Text["sgi: "L];            Number[mth.code.sgi, octal];            Text[", linkspace: "L];            Boolean[mth.linkspace];            Text[", packed: "L];            Boolean[mth.packed];            Text[", offset: "L];            Number[mth.code.offset, octal];            IF mth.packageable THEN {              Text[", length: "L];              Number[mth.code.length, octal]};            Text["]"L];            CR[]};          RETURN[FALSE]};        [] ¬ ProcessModules[bcd, DumpModulesWithinParent];        [] ¬ ProcessConfigs[bcd, DumpConfigsWithinParent]};      DumpSegment: PROC [sgh: SGHandle, sgi: SGIndex] RETURNS [BOOLEAN] = {        IF sgh.class = code THEN {          DumpCodePacksInSegment: PROC [sph: SPHandle, spi: SPIndex] RETURNS [BOOLEAN] = {            IF sph.seg = sgi THEN {              FOR i: CARDINAL IN [0..sph.length) DO                space: SpaceID = sph.spaces[i];                Spaces[4];                DumpName[space.name];                Text["  resident: "L]; Boolean[space.resident];                Text[", relative location: ["L]; Number[space.offset, octal];                Char[',]; Number[space.pages, octal]; Char[']];                CR[];                ENDLOOP};            RETURN[FALSE]};          Text["  Code Segment [sgi: "L]; Number[sgi, octal];          Text["], location: "L];          IF sgh.file = FTSelf THEN Text["(self)"L] ELSE DumpName[ftb[sgh.file].name];          Char['[]; Number[sgh.base, octal]; Char[',]; Number[sgh.pages, octal];          Char['+]; Number[sgh.extraPages, octal]; Char[']];          CR[];          [] ¬ ProcessSpaces[bcd, DumpCodePacksInSegment]};        RETURN[FALSE]};      DumpFramePack: PROC [fph: FPHandle] RETURNS [BOOLEAN] = {        Text["  Frame Pack "L]; DumpName[fph.name]; CR[];        FOR i: CARDINAL IN [0..fph.length) DO          Spaces[4]; DumpMTName[fph.modules[i]]; CR[];          ENDLOOP;        RETURN[FALSE]};      Text["Configurations and Modules in "L];      Text[data.inputBCDs.bcds[i].name]; Char[':]; CR[];      DumpConfigsWithParent[CTNull];      CR[];      Text["Code Segments, Code Packs, and Frame Packs in "L];      Text[data.inputBCDs.bcds[i].name]; Char[':]; CR[];      [] ¬ ProcessSegs[bcd, DumpSegment];      [] ¬ MB.ProcessFramePacks[bcd, DumpFramePack];      CR[];      ENDLOOP};  DumpStartList: PUBLIC PROC = {    OPEN MBOut;    base: StartList.Base ¬ data.scriptBase;    p: StartList.Index ¬ StartList.StartIndex;    CR[];    Line["START LIST:"L];    CR[];    DumpStartListHeader[];    Line["Script"L];    DO      WITH e: base[p] SELECT FROM        space => {          OPEN e;          Text["  Space["L];          Number[p, octal];          Text["]  type: "L];          DumpSpaceType[type];          Text[", backingStore: "L];          Text[IF backingStore = self THEN "self"L ELSE "null"L];          Text[", booted: "L];          Boolean[bootLoaded];          CR[];          Spaces[14];          Text["vmpage: "L];          LongNumber[vmpage, octal];          Text[", pages: "L];          LongNumber[pages, octal];          IF backingStore = self THEN {            Text[", backingPage: "L];            LongNumber[backingPage, octal]};          CR[];          p ¬ p + SIZE[space StartList.Entry]};        swapUnit => {          OPEN e;          Text["  SwapUnit["L];          Number[p, octal];          Text["]  parent: "L];          Number[parent, octal];          Text[", base: "L];          LongNumber[base, octal];          Text[", pages: "L];          LongNumber[pages, octal];          Text[", info: "L];          DumpSwapUnitInfo[info];          CR[];          p ¬ p + SIZE[swapUnit StartList.Entry]};        stop => {Line["  Stop"L];  EXIT};        ENDCASE => {Line["**Unknown BootScript Type"L];  EXIT};      ENDLOOP;    CR[]};  DumpSpaceType: PROC [type: StartList.SpaceType] = {    OPEN MBOut;    Char['[];    WITH type SELECT FROM      empty => Text["empty[]"L];      unitary => {        Text["unitary[swapUnit: "L]; Number[swapUnit, octal]; Char[']]};      family => {        Text["family[resDescChildren: "L];        Boolean[anyResidentDescriptorChildren];        Char[']]};      ENDCASE;    Char[']]};      DumpStartListHeader: PROC = {    OPEN MBOut;    h: LONG POINTER TO StartList.Header ¬ data.header;    Line["Header"L];    Text["  version: "L];    Number[h.version, octal];    CR[];    Text["  table: "L];    LongNumber[h.table, octal];    CR[];    Text["  initLoadState: "L];    Number[h.initLoadState, octal];    CR[];    Text["  mdsBase: "L];    LongNumber[h.mdsBase, octal];    CR[];    Text["  pdaPages: "L];    LongNumber[h.pdaPages, octal];    CR[];    Text["  lastVMPage: "L];    LongNumber[h.lastVMPage, octal];    CR[];    Text["  lastBootLoadedPage: "L];    LongNumber[h.lastBootLoadedPage, octal];    CR[];    Text["  stateVectorCounts: "L];    DumpStateVectorCount[@h.stateVectorCounts];    CR[];    Text["  switches: "L];    DumpSwitches[@h.switches];    CR[];    Text["  locDebuggerMicrocode: "L];    DumpBootLocation[@h.locDebuggerMicrocode];    CR[];    Text["  locDebuggerGerm: "L];    DumpBootLocation[@h.locDebuggerGerm];    CR[];    Text["  locDebugger: "L];    DumpBootLocation[@h.locDebugger];    CR[];    Text["  locDebuggee: "L];    DumpBootLocation[@h.locDebuggee];    CR[]};  DumpStateVectorCount: PROC [svc: LONG POINTER TO StartList.StateVectorCounts] = {    OPEN MBOut;    Char['[];    FOR i: CARDINAL IN [0..SIZE[StartList.StateVectorCounts]) DO      IF i # 0 THEN Text[", "L];      Number[svc[i], octal];      ENDLOOP;    Char[']]};  DumpSwitches: PROC [s: LONG POINTER TO StartList.Switches] = {    OPEN MBOut;    first: BOOLEAN ¬ TRUE;    FOR c: CHARACTER IN CHARACTER DO      IF s[c] THEN {        IF ~first THEN Text[", "L] ELSE first ¬ FALSE;	Char[c]};      ENDLOOP};  DumpBootLocation: PROC [bl: LONG POINTER TO StartList.BootLocation] = {    OPEN MBOut;    Char['[];    FOR i: CARDINAL IN [0..SIZE[StartList.BootLocation]) DO      IF i # 0 THEN Text[", "L];      Number[bl[i], octal];      ENDLOOP;    Char[']]};      DumpBootHeader: PUBLIC PROC = {    OPEN MBOut;    h: LONG POINTER TO BootFile.Header ¬ data.bootHeader;    CR[];    CR[];    Line["BOOTFILE HEADER:"L];    Text["  version: "L];    LongNumber[h.version, octal];    CR[];    Text["  creationDate: "L];    Time[h.creationDate];    Text["  pStartListHeader: "L];    LongNumber[h.pStartListHeader, octal];    CR[];    Text["  inLoadMode: "L];    Text[      (SELECT h.inLoadMode FROM        load => "load"L,         ENDCASE => "restore"L)];    CR[];    Text["  mds: "L];    Number[h.mds, octal];    CR[];    Text["  countData: "L];    LongNumber[h.countData, octal];    CR[];    CR[]};  Boolean: PROC [b: BOOLEAN] = {MBOut.Char[IF b THEN 'T ELSE 'F]};    DumpFrames: PUBLIC PROC = {    OPEN MBOut;    CR[];    Line["GLOBAL FRAMES AT COMPLETION OF LOADING:"L];    CR[];    FOR i: MB.BIndex IN [0..data.inputBCDs.nBcds) DO      mt: MB.MT = data.inputBCDs.bcds[i].mt;      Text[data.inputBCDs.bcds[i].name]; CR[];      FOR gfi: CARDINAL IN [1..mt.length) DO        frame: PrincOpsExtras2.LongGlobalFrameHandle ¬ mt[gfi].frame;	codebase: PrincOps.GlobalCodebase ¬ LoadedMem.ReadCodebase[frame];	gw: PrincOpsExtras2.GlobalWord ¬ LoadedMem.ReadGlobalWord[frame];        Text["  gf["L];        LongNumber[frame, octal];        Text["] sh: "L];        Boolean[MB.VirtualGlobalFrame[frame].extra.shared];        Text[", al: "L];        Boolean[MB.VirtualGlobalFrame[frame].extra.alloced];        Text[", cl: "L];        Boolean[MB.VirtualGlobalFrame[frame].word.codelinks];        Text[", cb: "L];        LongNumber[codebase.codebase, octal];        Text[", gfi: "L];        Number[gw.gfi, octal];        CR[];        ENDLOOP;      CR[];      ENDLOOP};  END.
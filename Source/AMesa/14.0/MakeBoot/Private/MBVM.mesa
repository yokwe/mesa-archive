-- Copyright (C) 1981, 1982, 1983  by Xerox Corporation. All rights reserved. -- MBVM.mesa  --   Sandman	23-Jul-82 15:06:58--   Lewis	 2-Dec-81 11:49:57--   Davirro	20-Jul-83 11:34:33--   Johnsson	18-Sep-83 16:56:41DIRECTORY  BcdOps USING [SPHandle],  MFile USING [Handle],  MSegment USING [Handle],  PrincOpsExtras2 USING [ControlLink],  StartList USING [SwapUnitIndex, SwapUnitInfo];MBVM: DEFINITIONS =  BEGIN  DefaultFile: MFile.Handle = NIL;  Base: TYPE = LONG CARDINAL;  -- VM page number  Pages: TYPE = LONG CARDINAL;  MaxBase: Base = 8191;  DefaultBase: Base = LAST[Base];  Code: Base = LAST[Base]-1;  First64K: Base = LAST[Base]-2;  MDS: Base = LAST[Base]-3;  HyperSpace: Base = LAST[Base]-4;    Seg: TYPE = LONG POINTER TO Object;  DataSeg: TYPE = LONG POINTER TO data Object;  CodeSeg: TYPE = LONG POINTER TO code Object;  FileSeg: TYPE = LONG POINTER TO file Object;    Object: TYPE = RECORD [    link: Seg,    seal: [0..1777B] ¬ ObjectSeal,    bootLoaded: BOOLEAN ¬ FALSE,    index: StartList.SwapUnitIndex,    info: StartList.SwapUnitInfo ¬ [readOnly: TRUE, state: swappable],    base: Base,    pages: Pages,    body: SELECT objType: ObjectType FROM      data => [],      code => [	shared: BOOLEAN ¬ FALSE,	sph: BcdOps.SPHandle,	file: MFile.Handle,	fileBase: CARDINAL,	segment: MSegment.Handle,	codePiece: CodePiece],      file => [	file: MFile.Handle,	fileBase: CARDINAL,	segment: MSegment.Handle],      ENDCASE];  ObjectType: TYPE = {data, code, file};  ObjectSeal: [0..1777B] = 1235B;  CodeState: TYPE = {resident, cached, out};  CacheData: TYPE = LONG POINTER;      CodePiece: TYPE = LONG POINTER TO CodeItem;  CodeItem: TYPE = RECORD [    next: CodePiece,  -- pieces are chained    offset: CARDINAL,    body: SELECT tag: * FROM      code => [length: CARDINAL],      link => [links: Links],      ENDCASE];        Links: TYPE = LONG POINTER TO LinkObject;  LinkObject: TYPE = RECORD [    SEQUENCE length: NAT OF PrincOpsExtras2.ControlLink];      vmMap: BitArray;  -- marks busy VM pages  BitArray:     TYPE = LONG POINTER TO PACKED ARRAY [0..CARDINAL[MaxBase]] OF BOOLEAN;  lastVMPage: Base;     -- Signals and Errors   Fault: SIGNAL;  TooManySegs: SIGNAL;  InvalidSeg: ERROR [s: UNSPECIFIED];  NoVM: SIGNAL [needed: Pages];  VMBusy: SIGNAL [base: Base, pages: Pages];  NotInMDS: SIGNAL [s: Seg];     -- From MBVMemory  Direction: TYPE = {up, down};  AllocData: PROC [    base: Base, pages: Pages, dir: Direction ¬ down] RETURNS [s: DataSeg];  AllocMDSData: PROC [    base: Base, pages: Pages, dir: Direction ¬ down] RETURNS [s: DataSeg];  AllocCode: PROC [      file: MFile.Handle, base: Base, pages: Pages,      fileBase: CARDINAL, sph: BcdOps.SPHandle]     RETURNS [s: CodeSeg];  AllocFile: PROC [      file: MFile.Handle, base: Base, pages: Pages, fileBase: CARDINAL]    RETURNS [s: FileSeg];    AllocVM: PROC [    base: Base, pages: Pages, dir: Direction, low, high: Base] RETURNS [Base];  Free: PROC [seg: Seg];  EnumerateSegs: PROC [proc: PROC [Seg] RETURNS [BOOLEAN]] RETURNS [Seg];  SortSegs: PROC RETURNS [LONG DESCRIPTOR FOR ARRAY OF Seg];  ReleaseCodeSegs: PUBLIC PROC;  PointerFromSeg: PROC [s: Seg] RETURNS [p: POINTER];  LongPointerFromSeg: PROC [s: Seg] RETURNS [p: LONG POINTER];  SegFromPointer: PROC [p: POINTER] RETURNS [s: Seg];  SegFromLongPointer: PROC [p: LONG POINTER] RETURNS [s: Seg];  SetBusy: PROC [base: Base, pages: Pages] RETURNS [BOOLEAN];  SetFree: PROC [base: Base, pages: Pages] RETURNS [BOOLEAN];  EnumerateVM: PROC [      proc: PROC [Base, BOOLEAN] RETURNS [BOOLEAN]]    RETURNS [page: Base, state: BOOLEAN];     -- From MBCache   GetPage: PROC [page: Base, create: BOOLEAN ¬ TRUE] RETURNS [p: LONG POINTER];  -- MDS-relative reads and writes  Read: PROC [p: POINTER] RETURNS [v: UNSPECIFIED];  Write: PROC [p: POINTER, v: UNSPECIFIED];  CopyRead: PROC [from: POINTER, to: LONG POINTER, nwords: CARDINAL];  CopyWrite: PROC [from: LONG POINTER, to: POINTER, nwords: CARDINAL];    -- VM-relative reads and writes  LongRead: PROC [p: LONG POINTER] RETURNS [v: UNSPECIFIED];  LongWrite: PROC [p: LONG POINTER, v: UNSPECIFIED];  LongCopyRead: PROC [from: LONG POINTER, to: LONG POINTER, nwords: CARDINAL];  LongCopyWrite: PROC [from: LONG POINTER, to: LONG POINTER, nwords: CARDINAL];  END.
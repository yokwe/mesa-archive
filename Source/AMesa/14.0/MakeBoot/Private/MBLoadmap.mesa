-- Copyright (C) 1981, 1982, 1983  by Xerox Corporation. All rights reserved. -- MBLoadmap.mesa --   Sandman	20-Jul-82 11:10:06--   Lewis	 1-Dec-81 14:37:49--   Johnsson	29-Jul-83 12:05:56DIRECTORY  Format USING [NumberFormat],  MB USING [Handle, MakeBootVersion],  MBOut USING [CR, SP, Spaces, Tab, Text, Time],  MFile USING [maxNameLength],  MStream USING [Log],  Stream USING [Delete, Handle, PutBlock, PutChar],  String USING [AppendLongNumber, AppendNumber, AppendString],  Time USING [Append, Unpack];MBLoadmap: PROGRAM  IMPORTS MBOut, MB, String, MStream, Stream, time: Time  EXPORTS MB, MBOut =BEGINdata: MB.Handle ¬ NIL;disabled: BOOLEAN;loadmap: Stream.Handle ¬ NIL;InitLoadmap: PUBLIC PROC [h: MB.Handle] = {  IF data # NIL THEN FinishLoadmap[];  data ¬ h;  disabled ¬ FALSE};FinishLoadmap: PUBLIC PROC = {  IF loadmap # NIL THEN {Stream.Delete[loadmap];  loadmap ¬ NIL};  data ¬ NIL};  OpenLoadmap: PUBLIC PROC = {  name: STRING ¬ [MFile.maxNameLength];  String.AppendString[name, data.output];  StripExtension[name];  String.AppendString[name, ".loadmap"L];  loadmap ¬ MStream.Log[name, []];  MBOut.Text["Loadmap for boot file: "L]; MBOut.Text[data.output]; MBOut.Spaces[3];  MBOut.Time[data.buildTime]; MBOut.CR[];  MB.MakeBootVersion[name];  MBOut.Text["Built by: "L]; MBOut.Text[name]; MBOut.CR[];  MBOut.CR[]};    StripExtension: PROC [s: LONG STRING] = {  FOR i: CARDINAL IN [0..s.length) DO    IF s[i] = '. THEN {s.length ¬ i;  RETURN};    ENDLOOP};Disable: PUBLIC PROC = {disabled ¬ TRUE};Char: PUBLIC PROC [c: CHARACTER] = {  IF ~disabled THEN Stream.PutChar[loadmap, c]};Text: PUBLIC PROC [s: LONG STRING, columns: CARDINAL ¬ 0] = {  i: CARDINAL;  IF disabled THEN RETURN;  Stream.PutBlock[loadmap, [LOOPHOLE[@s.text], 0, s.length]];  FOR i IN [s.length..columns) DO MBOut.SP[] ENDLOOP};Line: PUBLIC PROC [s: LONG STRING] = {  IF disabled THEN RETURN;  Stream.PutBlock[loadmap, [LOOPHOLE[@s.text], 0, s.length]];  MBOut.CR[]};Spaces: PUBLIC PROC [n: CARDINAL] = {  IF disabled THEN RETURN;  THROUGH [0..n/8) DO MBOut.Tab[] ENDLOOP;  THROUGH [0..n MOD 8) DO MBOut.SP[] ENDLOOP};Level: PUBLIC PROC [level: CARDINAL] = {  IF disabled THEN RETURN;  MBOut.CR[];  MBOut.Spaces[level*2]};Time: PUBLIC PROC [t: LONG CARDINAL] = {  s: STRING ¬ [20];  IF disabled THEN RETURN;  time.Append[s, time.Unpack[LOOPHOLE[t]]];  Text[s]};LongNumber: PUBLIC PROC [val: LONG CARDINAL, format: Format.NumberFormat] = {  neg: BOOLEAN ¬ FALSE;  flag: CHARACTER ¬ 0C;  fill: CHARACTER = (IF format.zerofill THEN '0 ELSE ' );  s: STRING ¬ [20];  i: CARDINAL;  base: CARDINAL ¬ format.base;  IF disabled THEN RETURN;  IF base = 8 AND data.hexLoadmap THEN base ¬ 16;  IF LOOPHOLE[val, LONG INTEGER] < 0 AND ~format.unsigned THEN    {val ¬ -LOOPHOLE[val, LONG INTEGER];  neg ¬ TRUE};  String.AppendLongNumber[s, val, base];  i ¬ s.length;  IF neg THEN {    i ¬ i + 1;    IF format.zerofill THEN {Stream.PutChar[loadmap, '-]; neg ¬ FALSE}};  SELECT base FROM    8 => IF val > 7 THEN {flag ¬ 'B; i ¬ i + 1};    16 => IF val > 9 THEN {flag ¬ 'H; i ¬ i + 1};    ENDCASE;  IF s[0] ~IN['0..'9] THEN i ¬ i + 1;  THROUGH (i..format.columns] DO Stream.PutChar[loadmap,fill] ENDLOOP;  IF neg THEN Stream.PutChar[loadmap,'-];  IF s[0] ~IN['0..'9] THEN Char['0];  Text[s];  IF flag # 0C THEN Char[flag]};Number: PUBLIC PROC [val: CARDINAL, format: Format.NumberFormat] = {  neg: BOOLEAN ¬ FALSE;  flag: CHARACTER ¬ 0C;  fill: CHARACTER = (IF format.zerofill THEN '0 ELSE ' );  s: STRING ¬ [10];  i: CARDINAL;  base: CARDINAL ¬ format.base;  IF disabled THEN RETURN;  IF base = 8 AND data.hexLoadmap THEN base ¬ 16;  IF INTEGER[val] < 0 AND ~format.unsigned THEN    {val ¬ -INTEGER[val];  neg ¬ TRUE};  String.AppendNumber[s, val, base];  i ¬ s.length;  IF neg THEN {    i ¬ i + 1;    IF format.zerofill THEN {Stream.PutChar[loadmap, '-];  neg ¬ FALSE}};  SELECT base FROM    8 => IF val > 7 THEN {flag ¬ 'B; i ¬ i + 1};    16 => IF val > 9 THEN {flag ¬ 'H; i ¬ i + 1};    ENDCASE;  IF s[0] ~IN['0..'9] THEN i ¬ i + 1;  THROUGH (i..format.columns] DO Stream.PutChar[loadmap,fill] ENDLOOP;  IF neg THEN Stream.PutChar[loadmap,'-];  IF s[0] ~IN['0..'9] THEN Char['0];  Text[s];  IF flag # 0C THEN Char[flag]};Decimal: PUBLIC PROC [val: CARDINAL] = {  Number[val, [10,FALSE,FALSE,1]]};Octal: PUBLIC PROC [val: UNSPECIFIED] = {  Number[val, [8,FALSE,TRUE,1]]};END.
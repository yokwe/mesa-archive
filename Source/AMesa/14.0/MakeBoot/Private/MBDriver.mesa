-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- MBDriver.mesa   --   JGS	14-Dec-82  9:21:14--   Lewis	16-Mar-82 12:50:54--   Davirro	21-Jul-83 11:24:33--   Johnsson	22-Sep-83  9:18:37--   BGY	 2-Jul-86 14:47:57DIRECTORY  Ascii USING [BS, CR, FF, LF, NUL, TAB],  CommandUtil USING [    CommandObject, CommandPtr, CopyString, Create, Destroy, Failed,    FreePairList, FreeString, GetNthPair, ListLength, PairList, Parse,    SetExtension],  Environment,  Exec USING [AddCommand, ExecProc, GetChar, GetTTY, Handle, Outcome],  Inline USING [LongCOPY],  Heap USING [Create, Delete],  LoaderCore,  MB,  MBOut,  MBVM,  MFile USING [Acquire, Handle, GetTimes, Error, NameForError, Release],  MStream USING [Error],  PrincOpsExtras2,  Runtime USING [CallDebugger, GetBcdTime],  SDDefs,  SDDefsExtras,  String USING [    AppendString, EquivalentString, InvalidNumber, StringToDecimal, StringToOctal],  System USING [defaultSwitches, Switches],  Time USING [Append, Current, Packed, Unpack],  MBTTY USING [    Handle, PutChar, PutCR, PutDecimal, PutLine, PutLongDecimal,    PutLongNumber, PutString, UserAbort],  Version USING [Append];MBDriver: MONITOR    IMPORTS       CommandUtil, Exec, Heap, Inline,       LoaderCore, MB, MBOut, MBVM, MFile, MStream, Runtime,      PrincOpsExtras2, String, Time, MBTTY, Version    EXPORTS MB =  BEGIN  data: MB.Handle ¬ NIL;  exec: Exec.Handle;  tty: MBTTY.Handle;        Run: ENTRY Exec.ExecProc = {    start: LONG CARDINAL;    nFilePages, nResidentPages, nBootLoadedPages: LONG CARDINAL;    nModules, nGFIs: CARDINAL;    exec ¬ h;    tty ¬ Exec.GetTTY[h];    WriteHerald[Time.Current[]];    DO  -- until no commands remain      outcome ¬ abort;      start ¬ Time.Current[];      Initialize[];      outcome ¬ DoWork[          ! UNWIND => Finalize[];	  MB.Abort => CONTINUE;	  MFile.Error => {	    IF file = NIL THEN {	      fileName: LONG STRING = (SIGNAL MFile.NameForError);	      MBTTY.PutString[tty, "!Can't find file "L]; MBTTY.PutLine[tty, fileName]}	    ELSE IF code = noRoomOnVolume THEN	      MBTTY.PutLine[tty, "!Disk full "L]	    ELSE MBTTY.PutLine[tty, "!Unexpected file error "L];	    CONTINUE};	  MStream.Error => {	    MBTTY.PutLine[tty, "!Unexpected file error "L];	    CONTINUE}];      SELECT outcome FROM        normal => {          nFilePages ¬ data.nFilePages;          nModules ¬ data.nModules;          nGFIs ¬ data.nGFIs;          nResidentPages ¬ data.nResidentPages;          nBootLoadedPages ¬ data.nBootPages};	abort => {	  MBTTY.PutLine[tty, "...MakeBoot aborted"L];  EXIT};	spare1  --no commands remain-- => {outcome ¬ normal; EXIT};	ENDCASE --warning or error-- => EXIT;      Finalize[];      ReportStats[        nFilePages: nFilePages, nModules: nModules, nGFIs: nGFIs,        nResidentPages: nResidentPages, nBootLoadedPages: nBootLoadedPages,        elapsedTime: (LOOPHOLE[Time.Current[], LONG CARDINAL] - start)];      ENDLOOP;    Finalize[]};  WriteHerald: PROC [now: Time.Packed] = {    herald: STRING ¬ [80];    MakeBootVersion[herald];    MBTTY.PutLine[tty, herald];    herald.length ¬ 0;    Time.Append[herald, Time.Unpack[[now]]];    herald.length ¬ herald.length-3;  -- remove seconds    MBTTY.PutLine[tty, herald]};    MakeBootVersion: PUBLIC PROC [s: LONG STRING] = {    s.length ¬ 0;    String.AppendString[s, "MakeBoot "L];    Version.Append[s];    String.AppendString[s, " of "L];    Time.Append[s, Time.Unpack[Runtime.GetBcdTime[]]];    s.length ¬ s.length-3};  -- remove seconds    Initialize: PROC = {    -- the following must be first    InitDriver[];    -- The order of the following is arbitrary    MB.InitDebug[data];    MB.InitLoadmap[data];    MB.InitMain[data];    MB.InitOutput[data];    MB.InitParse[data];    MB.InitScript[data];    MB.InitLoadedMem[data];    -- The ordering of the following is significant    MB.InitVM[data];    MB.InitCache[data];    MB.InitLoader[data]};      Finalize: PROC = {    -- The ordering of the following is significant    MB.FinishOutput[];    MB.FinishLoader[];    MB.FinishCache[];    MB.FinishVM[];    -- The ordering of the following is arbitrary    MB.FinishLoadedMem[];    MB.FinishScript[];    MB.FinishParse[];    MB.FinishMain[];    MB.FinishLoadmap[];    MB.FinishDebug[];    LoaderCore.FreeGlobals[];    -- the following must be last    FinishDriver[];};      InitDriver: PROC = {    z: UNCOUNTED ZONE;    z ¬ Heap.Create[      initial: 32, increment: 8, swapUnitSize: 4, largeNodeThreshold: 2000];    data ¬ z.NEW[MB.Object];    Zero[data, SIZE[MB.Object]];    data.z ¬ z;    data.buildTime ¬ Time.Current[];    data.ttyHandle ¬ tty;    -- create BObject describing main input Bcd    data.inputBCDs ¬ data.z.NEW[MB.InputBCDs[10] ¬ [nBcds: 1]];    data.inputBCDs.bcds[0] ¬ data.z.NEW[MB.BObject ¬ [      name: NIL, bcd: NIL, bcdSeg: NIL, mt: NIL, gfiOffset: 0, files: NIL]];    data.localFramePages ¬ 50;  -- pre 13.0 pilot default    };      FinishDriver: PROC = {    [] ¬ CommandUtil.FreeString[data.input];    [] ¬ CommandUtil.FreeString[data.output];    FOR i: MB.BIndex IN [0..data.inputBCDs.nBcds) DO      IF data.inputBCDs.bcds[i] ~= NIL THEN        [] ¬ CommandUtil.FreeString[data.inputBCDs.bcds[i].name];      ENDLOOP;    Heap.Delete[data.z];    data ¬ NIL};  DoWork: PROC RETURNS [outcome: Exec.Outcome] = {    IF MBTTY.UserAbort[tty] THEN RETURN[abort];    IF (outcome ¬ ProcessCmds[]) # normal THEN RETURN[outcome];    MBOut.OpenLoadmap[];    MB.InitMemory[];    IF MBTTY.UserAbort[tty] THEN RETURN[abort];    EchoBCDs[];    MB.EchoInput[];    IF MBTTY.UserAbort[tty] THEN RETURN[abort];    MB.Load[];    IF MBTTY.UserAbort[tty] THEN RETURN[abort];    MB.TurnOffStartTrap[];    IF data.debug THEN {      MB.ReportFrameAllocation[]; MB.DumpInputBcds[]; MB.DumpFrames[];      DumpGFT[]};    WriteGFT[];    IF data.germ THEN MB.WriteGermFile[]    ELSE {      WriteGFTInfo[];      IF ~data.debug THEN MBOut.Disable[];      IF MBTTY.UserAbort[tty] THEN RETURN[abort];      MB.MakeScript[];      IF MBTTY.UserAbort[tty] THEN RETURN[abort];      MB.WriteBootFile[]};    IF MBTTY.UserAbort[tty] THEN RETURN[abort];    IF data.debug AND ~data.germ THEN {      MB.DumpBootHeader[];  MB.DumpStartList[]};    RETURN[normal]};    octal: MBOut.NumberFormat =    MBOut.NumberFormat[base: 8, unsigned: TRUE, zerofill: FALSE, columns: 1];  DumpGFT: PROC = {    gfi: PrincOpsExtras2.GFTIndex;    firstentry: CARDINAL;    gft: MB.GFTSequenceHandle ¬ data.gft;    IF data.germ THEN firstentry ¬ 1    ELSE firstentry ¬ PrincOpsExtras2.Reserved.LAST + 1;    MBOut.CR[];    MBOut.Text["GLOBAL FRAME TABLE"L];    MBOut.CR[];    FOR gfi IN [firstentry..data.lastgfti) DO      MBOut.Text["  gfi: "L];      MBOut.Number[gfi, octal];      MBOut.Text[": [gf: "L];      MBOut.LongNumber[gft[gfi].globalFrame, octal];      MBOut.Text[", cb: "L];      MBOut.LongNumber[gft[gfi].codebase.codebase, octal];      MBOut.Text["]\n"L];      ENDLOOP;    MBOut.CR[];    };    WriteGFTInfo: PROC = {    lastgfti: LONG CARDINAL ¬ LONG[LOOPHOLE[      PrincOpsExtras2.GFTIndexToHandle[data.lastgfti], CARDINAL]];    nentries: LONG CARDINAL ¬ data.nGFTs;    MBVM.CopyWrite[      to: @SDDefs.SD[SDDefsExtras.sEmptyGFTHandle],       from: @lastgfti,      nwords: SIZE[LONG CARDINAL]];    MBVM.CopyWrite[      to: @SDDefs.SD[SDDefsExtras.sLocalFramePages],       from: @data.localFramePages,      nwords: SIZE[LONG CARDINAL]];    MBVM.CopyWrite[      to: @SDDefs.SD[SDDefsExtras.sGFTSize],       from: @nentries,      nwords: SIZE[LONG CARDINAL]];    };      WriteGFT: PROC = {    gftbase: LONG POINTER ¬ LOOPHOLE[data.gftBase * Environment.wordsPerPage];    IF data.germ THEN       MBVM.LongCopyWrite[        from: @data.gft[0], to: gftbase, nwords: Environment.wordsPerPage]    ELSE     -- normal bootfile case    MBVM.LongCopyWrite[      from: @data.gft[PrincOpsExtras2.Reserved.FIRST],      to: gftbase + Environment.wordsPerPage,      nwords: data.nGFTs * SIZE[PrincOpsExtras2.GFTItem]];    };    ProcessCmds: PROC RETURNS [outcome: Exec.Outcome] = {    args, results: CommandUtil.PairList;    switches, sourceName: LONG STRING ¬ NIL;    commandPtr: CommandUtil.CommandPtr ¬ CommandUtil.Create[GetChar];        GetChar: PROC RETURNS [char: CHARACTER] = {RETURN[Exec.GetChar[exec]]};    CleanupParse: PROC = {      IF sourceName ~= NIL THEN {        [] ¬ CommandUtil.FreeString[sourceName];        [] ¬ CommandUtil.FreePairList[args];        [] ¬ CommandUtil.FreePairList[results];        [] ¬ CommandUtil.FreeString[switches]};      CommandUtil.Destroy[commandPtr]};        BEGIN    [sourceName, args, results, switches] ¬ CommandUtil.Parse[      cmd: commandPtr, opX: 2+("bcd"L).length, resultX: 2+("boot"L).length,      allowNoTagParm: TRUE ! CommandUtil.Failed => GOTO badCommands];    IF sourceName = NIL THEN {CleanupParse[]; RETURN[outcome: spare1]};  -- no commands remain    IF CommandUtil.ListLength[results] > 1 THEN GOTO badCommands;    EXITS       badCommands => {        MBTTY.PutLine[tty, "!Bad MakeBoot command line"L];        CleanupParse[];        RETURN[outcome: error]}    END;    IF switches # NIL THEN {      sense: BOOLEAN ¬ TRUE;      FOR i: CARDINAL IN [0..switches.length) DO        SELECT switches[i] FROM          '-, '~ => sense ¬ ~sense;          'c, 'C => {data.codeLinks ¬ sense;  sense ¬ TRUE};          'd, 'D => {data.debug ¬ sense;  sense ¬ TRUE};          'g, 'G => {data.germ ¬ sense;  sense ¬ TRUE};          'h, 'H => {data.hexLoadmap ¬ sense;  sense ¬ TRUE};          'u, 'U => {data.utilityPilot ¬ sense;  sense ¬ TRUE};          '! => Runtime.CallDebugger["Called from MakeBoot"L];          ENDCASE;        ENDLOOP};    data.input ¬ CommandUtil.CopyString[s: sourceName, extra: (".bcd"L).length];    data.input ¬ CommandUtil.SetExtension[root: data.input, defaultExt: "bcd"L];    data.inputBCDs.bcds[0].name ¬ CommandUtil.CopyString[data.input];    IF CommandUtil.ListLength[results] # 0 THEN      data.output ¬ CommandUtil.GetNthPair[list: results, n: 0, delete: TRUE].value    ELSE {      data.output ¬ CommandUtil.CopyString[sourceName];      StripExtension[data.output]};    data.output ¬ CommandUtil.SetExtension[      root: data.output,      defaultExt: (IF data.germ THEN "germ"L ELSE "boot"L)];    EchoCommand[];    ProcessArgs[args ! UNWIND => CleanupParse[]];    CleanupParse[];    RETURN[outcome: normal]};      StripExtension: PROC [s: LONG STRING] = {    FOR i: CARDINAL IN [0..s.length) DO      IF s[i] = '. THEN {s.length ¬ i;  RETURN};      ENDLOOP};    EchoCommand: PROC = {    MBTTY.PutString[tty, "Building "L];  MBTTY.PutString[tty, data.output]};      EchoBCDs: PROC = {    MBOut.Text["Input BCD"L];    IF data.inputBCDs.nBcds ~= 0 THEN MBOut.Char['s];    MBOut.Char[':]; MBOut.CR[]; MBOut.CR[];    FOR i: CARDINAL IN [0..data.inputBCDs.nBcds) DO      MBOut.Spaces[2];      MBOut.Text[data.inputBCDs.bcds[i].name, 39];      MBOut.Spaces[2];      {ENABLE MFile.Error => CONTINUE;       fH: MFile.Handle ¬ MFile.Acquire[         name: data.inputBCDs.bcds[i].name, access: anchor, release: []];       MBOut.Time[MFile.GetTimes[fH].create];       MFile.Release[fH]};      MBOut.CR[];      ENDLOOP;    MBOut.CR[]};         ProcessArgs: PROC [args: CommandUtil.PairList] = {    key, value: LONG STRING;    nProcesses, lsModules, lsBcds: CARDINAL ¬ LAST[CARDINAL];    switches: System.Switches ¬ System.defaultSwitches;    MBTTY.PutCR[tty];    FOR i: CARDINAL IN [0..CommandUtil.ListLength[args]) DO      [key: key, value: value] ¬ CommandUtil.GetNthPair[args, i];      SELECT TRUE FROM        key = NIL OR key.length = 0 OR String.EquivalentString["parm"L, key] => {          parmFile: LONG STRING ¬             CommandUtil.CopyString[s: value, extra: (".bootmesa"L).length];          parmFile ¬ CommandUtil.SetExtension[            root: parmFile, defaultExt: "bootmesa"L];          MBTTY.PutString[tty, "Processing parameter file "L];          MBTTY.PutString[tty, parmFile];          MB.ProcessInput[parmFile ! UNWIND => [] ¬ CommandUtil.FreeString[parmFile]];          parmFile ¬ CommandUtil.FreeString[parmFile];          MBTTY.PutCR[tty]};        String.EquivalentString["bcd"L, key] => {          bH: MB.BHandle;          IF data.inputBCDs.nBcds = LAST[MB.BCount] - 1 --save slot for NullConfig-- THEN            MB.Error["Too many input BCDs"L];          IF data.inputBCDs.nBcds = data.inputBCDs.length THEN {            newLength: MB.BCount = MIN[2*data.inputBCDs.length, LAST[MB.BCount]];            newInputBCDs: LONG POINTER TO MB.InputBCDs ¬              data.z.NEW[MB.InputBCDs[newLength] ¬ [nBcds: data.inputBCDs.nBcds]];            Inline.LongCOPY[              from: @data.inputBCDs.bcds[0], to: @newInputBCDs.bcds[0],              nwords: data.inputBCDs.nBcds*SIZE[MB.BHandle]];            data.z.FREE[@data.inputBCDs];            data.inputBCDs ¬ newInputBCDs};          bH ¬ data.z.NEW[MB.BObject ¬ [            name: NIL, bcd: NIL, bcdSeg: NIL, mt: NIL, gfiOffset: 0, files: NIL]];          bH.name ¬ CommandUtil.CopyString[s: value, extra: (".bcd"L).length];          bH.name ¬ CommandUtil.SetExtension[root: bH.name, defaultExt: "bcd"L];          data.inputBCDs.bcds[data.inputBCDs.nBcds] ¬ bH;          data.inputBCDs.nBcds ¬ data.inputBCDs.nBcds+1};        String.EquivalentString["nProcesses"L, key] =>          nProcesses ¬ String.StringToDecimal[value             ! String.InvalidNumber => MB.Error["Invalid nProcesses"L]];        String.EquivalentString["lsModules"L, key] =>          lsModules ¬ String.StringToDecimal[value             ! String.InvalidNumber => MB.Error["Invalid lsModules"L]];        String.EquivalentString["lsBcds"L, key] =>          lsBcds ¬ String.StringToDecimal[value             ! String.InvalidNumber => MB.Error["Invalid lsBcds"L]];        String.EquivalentString["switches"L, key] =>          ParseBootSwitches[value, @switches            ! InvalidSwitches => MB.Error["Invalid boot switches"L]];        ENDCASE;      ENDLOOP;    IF nProcesses ~= LAST[CARDINAL] THEN {      data.nProcesses ¬ nProcesses;      MBTTY.PutString[tty, "Number of processes set to "L];      MBTTY.PutDecimal[tty, nProcesses];      MBTTY.PutCR[tty]};    IF lsModules ~= LAST[CARDINAL] THEN {       data.lsModules ¬ lsModules;      MBTTY.PutString[tty, "LoadState modules set to "L];      MBTTY.PutDecimal[tty, lsModules];      MBTTY.PutCR[tty]};    IF lsBcds ~= LAST[CARDINAL] THEN {       data.lsBcds ¬ lsBcds;      MBTTY.PutString[tty, "LoadState bcds set to "L];      MBTTY.PutDecimal[tty, lsBcds];      MBTTY.PutCR[tty]};    IF switches ~= System.defaultSwitches THEN {       data.switches ¬ switches;      MBTTY.PutString[tty, "Boot file switches set to "L];      PutSwitches[tty, @switches];      MBTTY.PutCR[tty]}};  InvalidSwitches: ERROR = CODE;    ParseBootSwitches: PROC [s: LONG STRING, switches: POINTER TO System.Switches] = {    c: CHARACTER;    index: CARDINAL ¬ 0;    Get: PROC RETURNS [c: CHARACTER] = {      IF index = s.length THEN c ¬ Ascii.NUL      ELSE {c ¬ s[index]; index ¬ index + 1}};    UNTIL (c ¬ Get[]) = Ascii.NUL DO      SELECT c FROM        '\\ => 	  SELECT (c ¬ Get[]) FROM	    IN ['0..'3] => {	      OctDig: TYPE = CHARACTER['0..'7];	      esc: STRING ¬ [3];	      esc.length ¬ 3;	      esc[0] ¬ c;	      IF (esc[1] ¬ Get[]) IN OctDig AND (esc[2] ¬ Get[]) IN OctDig THEN	        switches[String.StringToOctal[esc]] ¬ down	      ELSE ERROR InvalidSwitches};	    'n, 'N, 'r, 'R => switches[Ascii.CR] ¬ down;	    't, 'T => switches[Ascii.TAB] ¬ down;	    'b, 'B => switches[Ascii.BS] ¬ down;	    'f, 'F => switches[Ascii.FF] ¬ down;	    'l, 'L => switches[Ascii.LF] ¬ down;	    '', '", '\\ => switches[c] ¬ down;	    ENDCASE => ERROR InvalidSwitches;	ENDCASE => switches[c] ¬ down;	ENDLOOP};        PutSwitches: PROC [tty: MBTTY.Handle, switches: POINTER TO System.Switches] = {    OPEN MBTTY;    FOR c: CHARACTER IN CHARACTER DO      IF switches[c] = up THEN LOOP;      SELECT c FROM        '', '", '\\ => {PutChar[tty, '\\]; PutChar[tty, c]};	IN ['a..'z], IN ['A..'Z], IN (' ..'@], IN ['[..'¬], IN ['{..'~] =>	  MBTTY.PutChar[tty, c];        Ascii.CR => {PutChar[tty, '\\]; PutChar[tty, 'N]};        Ascii.TAB => {PutChar[tty, '\\]; PutChar[tty, 'T]};        Ascii.BS => {PutChar[tty, '\\]; PutChar[tty, 'B]};        Ascii.FF => {PutChar[tty, '\\]; PutChar[tty, 'F]};        Ascii.LF => {PutChar[tty, '\\]; PutChar[tty, 'L]};        ENDCASE => {	  PutChar[tty, '\\]; PutLongNumber[tty, c-0C, [base: 8, columns: 3]]};      ENDLOOP};        ReportStats: PROC [      nFilePages, nResidentPages, nBootLoadedPages, elapsedTime: LONG CARDINAL,      nModules, nGFIs: CARDINAL] = {    OPEN MBTTY;    PutString[tty, "Boot file pages: "L];    PutLongDecimal[tty, nFilePages];    PutString[tty, " ("L];    PutLongDecimal[tty, nBootLoadedPages];    PutString[tty, " bootloaded, of which "L];    PutLongDecimal[tty, nResidentPages];    PutLine[tty, " are resident)"L];    PutString[tty, "Modules: "L];    PutDecimal[tty, nModules];    PutString[tty, "\nTime: "L];    IF elapsedTime > 60 THEN {      PutLongDecimal[tty, elapsedTime/60]; PutChar[tty, ':];       elapsedTime ¬ elapsedTime MOD 60};    PutLongNumber[      tty, elapsedTime,      [base: 10, zerofill: TRUE, unsigned: TRUE, columns: 2]];    PutCR[tty]};        Abort: PUBLIC SIGNAL = CODE;  Error:  PUBLIC PROC [msg: STRING] = {    MBTTY.PutCR[data.ttyHandle];    MBTTY.PutString[data.ttyHandle, "MakeBoot Error: "L];    MBTTY.PutLine[data.ttyHandle, msg];    SIGNAL MB.Abort};  Zero: PUBLIC PROC [p: LONG POINTER, n: CARDINAL] = {    IF n # 0 THEN {      p­ ¬ 0;  Inline.LongCOPY[from: p, to: p+1, nwords: n-1]}};  Copy: PUBLIC PROC [from, to: LONG POINTER, n: CARDINAL] = {    Inline.LongCOPY[from: from, to: to, nwords: n]};          Init: PROC = {Exec.AddCommand["MakeBoot.~"L, Run]};    Init[];    END.  
-- Copyright (C) 1981, 1982, 1983  by Xerox Corporation. All rights reserved. -- MBVMemory.mesa   -- Last edited by Sandman on 19-Oct-82  8:50:55-- Last edited by Lewis on  1-Dec-81 16:11:51-- Last edited by Davirro on 21-Jul-83 13:03:42DIRECTORY  Environment USING [wordsPerPage],  BcdOps USING [SPHandle],  Inline USING [LongDiv, LongMult],  MFile USING [Release, Handle],  MB USING [Error, Handle, Zero],  StartList USING [NullSwapUnitIndex],  MBStorage USING [FreeWords, Words],  MBVM USING [    Base, BitArray, Code, CodeItem, CodeSeg, DataSeg, DefaultBase,    Direction, FileSeg, First64K, HyperSpace, MaxBase, MDS, Object,    ObjectSeal, Pages, Seg];MBVMemory: PROGRAM    IMPORTS Inline, MFile, MBStorage, MB     EXPORTS MB, MBVM     SHARES MBVM =  BEGIN OPEN MBVM;  PageSize: CARDINAL = Environment.wordsPerPage;    data: MB.Handle ¬ NIL;  lastBase: Base ¬ 0;  InitVM: PUBLIC PROC [h: MB.Handle] = {    IF data # NIL THEN FinishVM[];    lastBase ¬ 0;    data ¬ h;    vmMap ¬ MBStorage.Words[      SIZE[PACKED ARRAY [0..CARDINAL[MBVM.MaxBase]] OF BOOLEAN]];    MB.Zero[vmMap, SIZE[PACKED ARRAY [0..CARDINAL[MBVM.MaxBase]] OF BOOLEAN]];    data.lastVMPage ¬ 0;    segList ¬ NIL};  FinishVM: PUBLIC PROC = {    ReleaseCodeSegs[];    IF vmMap # NIL THEN {MBStorage.FreeWords[vmMap]; vmMap ¬ NIL};    data ¬ NIL};     -- Segment Routines  segList: Seg ¬ NIL;  AllocMDSData: PUBLIC PROC [      base: Base, pages: Pages, dir: Direction ¬ down] RETURNS [s: DataSeg] = {    SELECT base FROM      MDS, DefaultBase => NULL;      First64K, HyperSpace, Code => MB.Error["Internal Error"L];      ENDCASE => base ¬ (data.mdsBase + base);    RETURN[AllocData[base: base, pages: pages, dir: dir]]};  AllocData: PUBLIC PROC [      base: Base, pages: Pages, dir: Direction ¬ down] RETURNS [s: DataSeg] = {    low, high: Base;    SELECT base FROM      MDS => {low ¬ data.mdsBase;  high ¬ data.mdsBase+255;  base ¬ DefaultBase};      First64K => {low ¬ 0;  high ¬ 255;  base ¬ DefaultBase};      HyperSpace => {low ¬ data.mdsBase+256;  high ¬ MaxBase;  base ¬ DefaultBase};      ENDCASE => {low ¬ 0;  high ¬ MaxBase};    base ¬ AllocVM[base: base, pages: pages, dir: dir, high: high, low: low];    s ¬ data.z.NEW[data Object ¬ Object[      index: StartList.NullSwapUnitIndex, base: base, pages: pages, link: segList,      body: data[]]];    IF data.utilityPilot THEN {      s.bootLoaded ¬ TRUE;      s.info ¬ [FALSE, resident];      };    segList ¬ s};  AllocCode: PUBLIC PROC [      file: MFile.Handle, base: Base, pages: Pages,      fileBase: CARDINAL, sph: BcdOps.SPHandle]    RETURNS [s: CodeSeg] = {    code: BOOLEAN ¬ FALSE;    low, high: Base;    -- all code will be montonically increasing    SELECT base FROM      Code => {low ¬ data.codeBase; high ¬ MaxBase;  base ¬ DefaultBase};      ENDCASE => {low ¬ 0;  high ¬ MaxBase};    base ¬ AllocVM[base: base, pages: pages, dir: up, high: high, low: low];    s ¬ data.z.NEW[code Object ¬ [      link: segList,      index: StartList.NullSwapUnitIndex,      base: base, pages: pages,       body: code[        shared: FALSE, 	sph: sph, file: file, fileBase: fileBase, segment: NIL,	codePiece: NIL]]];    s.codePiece ¬ data.z.NEW[code CodeItem ¬ [      next: NIL, offset: 0, body: code[length: CARDINAL[pages*PageSize]]]];    segList ¬ s};  AllocFile: PUBLIC PROC [      file: MFile.Handle, base: Base, pages: Pages, fileBase: CARDINAL]    RETURNS [s: FileSeg] = {    low, high: Base;    SELECT base FROM      MDS => {low ¬ data.mdsBase;  high ¬ data.mdsBase+255;  base ¬ DefaultBase};      First64K => {low ¬ 0;  high ¬ 255;  base ¬ DefaultBase};      HyperSpace => {low ¬ data.mdsBase+256;  high ¬ MaxBase;  base ¬ DefaultBase};      ENDCASE => {low ¬ 0;  high ¬ MaxBase};    base ¬ AllocVM[base: base, pages: pages, dir: up, high: high, low: low];    s ¬ data.z.NEW[file Object ¬ Object[      index: StartList.NullSwapUnitIndex, base: base, pages: pages, link: segList,      body: file[file: file, fileBase: fileBase, segment: NIL]]];    segList ¬ s};  Free: PUBLIC PROC [s:Seg] = {    ValidateSeg[s];    ReleaseVM[base: s.base, pages: s.pages];    s.seal ¬ 0;    data.z.FREE[@s]};  EnumerateSegs: PUBLIC PROC [      proc: PROC [Seg] RETURNS [BOOLEAN]] RETURNS [seg: Seg] = {    FOR seg ¬ segList, seg.link UNTIL seg = NIL DO      IF proc[seg] THEN RETURN[seg];      ENDLOOP;    RETURN[NIL]};  SortSegs: PUBLIC PROC RETURNS [segs: LONG DESCRIPTOR FOR ARRAY OF MBVM.Seg] = {    i, nSegs: CARDINAL;    seg: MBVM.Seg;        SiftUp: PROC [low, high: CARDINAL] = {      k, son: CARDINAL;      k ¬ low;      DO        IF k*2 > high THEN EXIT;        IF k*2+1 > high OR segs[k*2+1-1].base < segs[k*2-1].base THEN son ¬ k*2        ELSE son ¬ k*2+1;        IF segs[son-1].base < segs[k-1].base THEN EXIT;	 Exchange[son-1, k-1];        k ¬ son;        ENDLOOP};	    Exchange: PROC [a, b: CARDINAL] = {      temp: MBVM.Seg ¬ segs[a];      segs[a] ¬ segs[b];  segs[b] ¬ temp};	    nSegs ¬ 0;    FOR seg ¬ segList, seg.link UNTIL seg = NIL DO nSegs ¬ nSegs + 1 ENDLOOP;    segs ¬ DESCRIPTOR[MBStorage.Words[nSegs*SIZE[MBVM.Seg]], nSegs];    i ¬ 0;    FOR seg ¬ segList, seg.link UNTIL seg = NIL DO      segs[i] ¬ seg;  i ¬ i + 1;       ENDLOOP;    FOR i DECREASING IN [1..nSegs/2] DO SiftUp[i, nSegs] ENDLOOP;    FOR i DECREASING IN [1..nSegs) DO Exchange[0, i];  SiftUp[1, i] ENDLOOP};    ReleaseCodeSegs: PUBLIC PROC = {    FreeOneCodeSegment: PROC [s: Seg] RETURNS [stop: BOOLEAN] = {      WITH s SELECT FROM        code => IF file # NIL THEN {MFile.Release[file]; file ¬ NIL};	ENDCASE;      RETURN[FALSE]};    [] ¬ EnumerateSegs[FreeOneCodeSegment]};  ValidateSeg: PUBLIC PROC [s:Seg] = {    IF s.seal # ObjectSeal THEN MB.Error["Internal Error"L]};  NotInMDS: PUBLIC SIGNAL [s: Seg] = CODE;  PointerFromSeg: PUBLIC PROC [s: Seg] RETURNS [p: POINTER] = {    IF s.base ~IN [data.mdsBase..data.mdsBase+255] THEN      MB.Error["Internal Error"L];    RETURN[      LOOPHOLE[CARDINAL[(s.base-data.mdsBase)*PageSize]]]};  LongPointerFromSeg: PUBLIC PROC [s: Seg] RETURNS [p: LONG POINTER] = {    RETURN[LOOPHOLE[Inline.LongMult[CARDINAL[s.base], CARDINAL[PageSize]]]]};  SegFromPointer: PUBLIC PROC [p: POINTER] RETURNS [s: Seg] = {    base: Base ¬ LOOPHOLE[p, CARDINAL]/PageSize;    FindSeg: PROC [seg: Seg] RETURNS [BOOLEAN] = {RETURN[seg.base = base]};    RETURN[EnumerateSegs[FindSeg]]};  SegFromLongPointer: PUBLIC PROC [p: LONG POINTER] RETURNS [s: Seg] = {    base: Base ¬ Inline.LongDiv[LOOPHOLE[p], PageSize];    FindSeg: PROC [seg: Seg] RETURNS [BOOLEAN] = {RETURN[seg.base = base]};    RETURN[EnumerateSegs[FindSeg]]}; -- VM Routines  PageID: TYPE = WORD;  vmMap: PUBLIC BitArray ¬ NIL;  -- marks busy VM pages  AllocVM: PUBLIC PROC [    base: Base, pages: Pages, dir: Direction, low, high: Base] RETURNS [Base] = {    incr: INTEGER;    vm: Base;    n: CARDINAL;  -- count of contiguous free pages    IF ~data.germ THEN low ¬ MAX[low, 256];    SELECT dir FROM      up => {incr ¬ 1;  vm ¬ low};      ENDCASE => {incr ¬ -1;  vm ¬ high};    IF base = DefaultBase THEN       DO -- until sufficient VM is found        n ¬ 0;        FOR vm ¬ vm, vm+incr UNTIL (IF dir = up THEN vm > high ELSE vm < low) DO          IF vmMap[CARDINAL[vm]] OR vm = 0 OR vm = data.mdsBase THEN 	     n ¬ 0  -- page in use; reset free count          ELSE IF (n ¬ n+1) = pages THEN {            base ¬ IF dir = up THEN vm-n+1 ELSE vm;            IF Spans64KBoundary[base, pages] THEN  -- try again on next 64K boundary	       IF dir = up THEN {n ¬ 1;  vm ¬ 256*((base+255)/256)}	       ELSE {n ¬ 1;  vm ¬ 256*((base+255)/256)-1}	     ELSE {ReserveVM[base, pages];  RETURN[base]};            n ¬ 0};          ENDLOOP;	MB.Error["Memory Full"L];       ENDLOOP    ELSE      DO -- repeat if VM busy        FOR vm IN [base..base+pages) DO         IF vmMap[CARDINAL[vm]] OR vm = 0 OR vm = data.mdsBase THEN EXIT;	  REPEAT	    FINISHED => {ReserveVM[base, pages];  RETURN[base]};	  ENDLOOP;        MB.Error["Memory Busy"L];        ENDLOOP};  Spans64KBoundary: PROC [base: Base, pages: Pages] RETURNS [BOOLEAN] = {    RETURN[(base+pages-1)/256 # base/256]};  ReserveVM: PUBLIC PROC [base: Base, pages: Pages] = {    data.lastVMPage ¬ MAX[base+pages-1, data.lastVMPage];    FOR base IN [base..base+pages) DO vmMap[CARDINAL[base]] ¬ TRUE ENDLOOP};  SetBusy: PUBLIC PROC [base: Base, pages: Pages] RETURNS [BOOLEAN] = {    FOR base IN [base..base+pages) DO vmMap[CARDINAL[base]] ¬ TRUE ENDLOOP;    RETURN[FALSE]};  SetFree: PUBLIC PROC [base: Base, pages: Pages] RETURNS [BOOLEAN] = {    FOR base IN [base..base+pages) DO vmMap[CARDINAL[base]] ¬ FALSE ENDLOOP;    RETURN[FALSE]};  ReleaseVM: PROC [base: Base, pages: Pages] = {    IF data.lastVMPage = base+pages-1 THEN      FOR lastPage: MBVM.Base DECREASING IN [0..data.lastVMPage) DO	IF vmMap[CARDINAL[lastPage]] THEN {data.lastVMPage ¬ lastPage; EXIT};	ENDLOOP;    FOR base IN [base..base+pages) DO vmMap[CARDINAL[base]] ¬ FALSE ENDLOOP};  EnumerateVM: PUBLIC PROC [      proc: PROC [Base, BOOLEAN] RETURNS [BOOLEAN]]    RETURNS [page: Base, state: BOOLEAN] = {    FOR page IN [0..MaxBase] DO      IF proc[page, vmMap[CARDINAL[page]]] THEN RETURN;      ENDLOOP;    RETURN[0, FALSE]};  END.
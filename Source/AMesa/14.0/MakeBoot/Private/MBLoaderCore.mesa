-- Copyright (C) 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- MBLoaderCore.mesa, last modified by--   JGS on	 5-Jan-83 15:39:35    --   BTL	16-Mar-82 13:16:53--   BJD	13-Jan-84 16:49:31--   AMD	22-Jul-83 18:35:34--   RKJ	 9-Feb-84 15:40:35--   BGY	19-Feb-87 10:47:51DIRECTORY  BcdDefs,  BcdOps,  BcdOpsExtras,  ControlModuleFormat,  Environment,  Heap,  LoaderCore,  LoadStateFormat,  LoadState,  LoadedMem,  MB,  MBLoaderOps,  MBOut,  MBVM,  MFile,  MSegment,  PilotSwitchesExtra6,  PrincOps,  PrincOpsExtras2,  Runtime,  MBStorage,  MBTTY,  QuickSort,  Space,  SpecialLoader,  System,  Table;MBLoaderCore: PROGRAM    IMPORTS       BcdOps, Heap, LoaderCore, LoadedMem, LoadState,       MB, MBLoaderOps, MBOut, MBVM, MFile, MSegment,      MBTTY, Runtime, SpecialLoader, QuickSort     EXPORTS MB, MBLoaderOps, System =   BEGIN OPEN MB;  LongGlobalFrameHandle: TYPE = PrincOpsExtras2.LongGlobalFrameHandle;  GlobalOverhead: TYPE = PrincOpsExtras2.GlobalOverhead;    PageSize: CARDINAL = Environment.wordsPerPage;  nextGFI: CARDINAL ¬ 1;  -- gfi 0 is never used  data: MB.Handle ¬ NIL;    -- private zone just for code link pieces  linkZone: UNCOUNTED ZONE ¬ NIL;  InitLoaderCore: PUBLIC PROC [h: MB.Handle] = {    IF data # NIL THEN FinishLoaderCore[];     data ¬ h;      nextGFI ¬ 1;    linkZone ¬ Heap.Create[      initial: 32, increment: 8, swapUnitSize: 4, largeNodeThreshold: 2000]};  FinishLoaderCore: PUBLIC PROC = {    Heap.Delete[linkZone];    linkZone ¬ NIL;    FOR i: CARDINAL IN [0..data.inputBCDs.nBcds) DO       loadee: MB.BHandle = data.inputBCDs.bcds[i];      ReleaseModuleTable[loadee];      IF loadee.bcdSeg # NIL THEN MSegment.Delete[loadee.bcdSeg.segment];      ENDLOOP;    data ¬ NIL};      switches: PUBLIC System.Switches ¬ ALL[up];  Load: PUBLIC PROC = {    mainBcd: MB.BHandle = data.inputBCDs.bcds[0];    tty: MBTTY.Handle = data.ttyHandle;    i: MB.BIndex;    bcdInfo: LoadState.BcdInfoIndex;    errors: CARDINAL ¬ 0;    MapIt: SpecialLoader.MapProcType = {RETURN[DoMap[        pageOffset, pageCount, swapUnits, access, data.inputBCDs.bcds[i]]];      };    UnmapIt: SpecialLoader.UnmapProcType = {      RETURN[DoUnmap[targetAddress, data.inputBCDs.bcds[i]]];      };    IF data.germ AND data.inputBCDs.nBcds > 1 THEN      MB.Error["Multiple bcds not supported for germ"L];    MB.InitializeUtilities[data];    LoaderCore.InitGlobals[];    data.nModules ¬ 0;    FOR i IN [0..data.inputBCDs.nBcds) DO      loadee: MB.BHandle = data.inputBCDs.bcds[i];      missingCodeFile: BOOLEAN ¬ FALSE;      MBTTY.PutString[tty, "Loading "];      MBTTY.PutString[tty, loadee.name];      MBTTY.PutString[tty, "..."L];      MBOut.Text["Global Frames for Modules in "L];      MBOut.Text[loadee.name];      MBOut.Char[':]; MBOut.CR[];      MBOut.Spaces[26];      MBOut.Text["  Frame      Code (* = code links)\n"L];      -- do load      bcdInfo ¬ LoadState.LockBcdInfo[].loadState.nBcds;      [] ¬ SpecialLoader.LoadConfig[MapIt, UnmapIt, data.codeLinks!        Runtime.ConfigError => {	  MBTTY.PutString[tty, "\nLoading error: "L];	  MBTTY.PutLine[tty, SELECT type FROM	    badCode => "badCode",	    exportedTypeClash => "exportedTypeClash",	    invalidConfig => "invalidConfig",	    missingCode => "missingCode",	    ENDCASE => "unknown"];	  MB.Abort[];	  };	Runtime.VersionMismatch => {	  MBTTY.PutString[tty, "\nVersion mismatch in "L];	  MBTTY.PutString[tty, module];	  MBTTY.PutCR[tty];	  errors ¬ errors + 1;	  RESUME;}];      ModulesToLoadmap[loadee, bcdInfo];      MBOut.CR[];      MBTTY.PutLine[tty, "done"L];      ENDLOOP;    MBLoaderOps.WriteLoadState[];    MBOut.CR[]; MBOut.Text["Total of "L];    data.nModules ¬ LoadState.LockBcdInfo[].loadState.nModules;    MBOut.Decimal[data.nModules]; MBOut.Line[" modules"L];    MBLoaderOps.ProcessUnboundImports[];    MBTTY.PutLine[tty, "Finished loading."L];    IF errors > 0 THEN {      MBTTY.PutDecimal[tty, errors];      MBTTY.PutLine[tty, " version mismatch errors."L];      };    };  lastSeg: MSegment.Handle;  DoMap: PROC[    pageOffset, pageCount: CARDINAL, swapUnits: Space.SwapUnitOption,     access: Space.Access, bh: MB.BHandle]     RETURNS [mapUnitPtr: LONG POINTER] = {    seg: MSegment.Handle ¬ NIL;    IF pageOffset = 0 AND pageCount = 1 THEN {      mfile: MFile.Handle ¬ NIL;      mfile ¬ MFile.Acquire[bh.name, IF access = readWrite THEN readWrite        ELSE readOnly, []];      lastSeg ¬ seg ¬ MSegment.Create[mfile, [], pageOffset, pageCount, swapUnits];      bh.bcd ¬ seg.Address[];      IF ~data.germ THEN {	bh.bcdSeg ¬ MBVM.AllocFile[	  file: mfile,	  fileBase: CARDINAL[MSegment.GetFileBase[seg]],	  base: IF data.germ THEN MBVM.MDS ELSE MBVM.HyperSpace,	  pages: bh.bcd.nPages];	bh.bcdSeg.segment ¬ seg;	};      }    ELSE {      seg ¬ lastSeg;      MSegment.Reset[segment: seg, pages: pageCount];      bh.bcd ¬ seg.Address[];      lastSeg ¬ NIL;      };    RETURN[bh.bcd];    };      DoUnmap: PROC[    targetAddress: LONG POINTER, bh: MB.BHandle]     RETURNS [mapUnit: Space.Interval] = {RETURN[[targetAddress, 1]];};      ReleaseModuleTable: PUBLIC PROC [loadee: MB.BHandle] = {    IF loadee.mt # NIL THEN data.z.FREE[@loadee.mt]};  Alloc: PUBLIC PROC [fsi: CARDINAL] RETURNS [p: POINTER] = {    avItem: data PrincOps.AVItem;    DO      p ¬ MBVM.Read[PrincOps.AV + fsi];      avItem ¬ LOOPHOLE[p];      SELECT avItem.tag FROM        frame => EXIT;  -- a free frame	empty => fsi ¬ fsi+1;        ENDCASE =>  -- indirect, unused	  fsi ¬ avItem.fsi;  -- use an fsi for larger frames      ENDLOOP;    MBVM.Write[PrincOps.AV + fsi, MBVM.Read[p]];    RETURN[p]};  InitLoader: PUBLIC PROC [h: MB.Handle] = {    IF data # NIL THEN FinishLoader[];    MBLoaderOps.InitLoaderCore[h];    MBLoaderOps.InitLoadState[h];    };  FinishLoader: PUBLIC PROC = {    MBLoaderOps.FinishLoadState[];    MBLoaderOps.FinishLoaderCore[];    };  ls: LONG POINTER TO PrincOpsExtras2.ControlLink;  codeLinks: MBVM.Links ¬ NIL;    ProcessUnboundImports: PUBLIC PROC = {    tty: MBTTY.Handle = data.ttyHandle;    anyUnbound, anyUnboundCodeLinks: BOOLEAN ¬ FALSE;    CheckIfUnresolved: PROC [module: MBLoaderOps.ModuleInfo] RETURNS [BOOLEAN] = {      IF ~module.resolved THEN {        bh: MB.BHandle = MBLoaderOps.AcquireBcd[module.index];        vgf: PrincOpsExtras2.GlobalFrameBase =	  MB.VirtualGlobalFrame[LoadedMem.GlobalFrameFromGFTHandle[module.gfi]];        IF TRUE THEN {          codeLinks: BOOLEAN = vgf.word.codelinks;          bcd: BcdOps.BcdBase = bh.bcd;          mth: BcdOps.MTHandle = bh.mt[module.cgfi-1].mth;          cseg: MBVM.CodeSeg = bh.mt[module.cgfi-1].code;          vLinks: MBLoaderOps.VirtualLinks = MBLoaderOps.GetVirtualLinks[bh, mth];          linkStart: LONG POINTER ¬	    MBVM.LongPointerFromSeg[cseg] + mth.code.offset - LENGTH[vLinks];          first: BOOLEAN ¬ TRUE;          MapDummy: PROC [gfi: CARDINAL, ep: CARDINAL]            RETURNS [imp: BcdOps.IMPHandle, offset: CARDINAL] = {	    CheckImport: PROC [imph: BcdOps.IMPHandle, impi: BcdDefs.IMPIndex]              RETURNS [BOOLEAN] = {              IF gfi = imph.gfi THEN {imp ¬ imph; offset ¬ ep; RETURN[TRUE]};              RETURN[FALSE]};            imp ¬ NIL;	    offset ¬ 0;            [] ¬ BcdOps.ProcessImports[bcd, CheckImport]};          OpenLinkSpace[bh, mth];          FOR i: CARDINAL IN [0..LENGTH[vLinks]) DO              << Things are quite confusing here.  An unbound imported procedure	       or variable will show up as a virtual link of type 'proc0' or	       'proc1'.  An unbound imported program module will show up as a	       virtual link  of type 'var'.  An unbound imported type will show	       up as a virtual link of type 'proc0' or 'proc1', while a bound,	       imported type will have type 'type'.>>            SELECT ReadLink[i] FROM              PrincOpsExtras2.NullLink, PrincOpsExtras2.UnboundLink => {                imp: BcdOps.IMPHandle;                offset: CARDINAL;                WITH l: vLinks[i] SELECT FROM                  type => LOOP;                  variable =>                    [imp, offset] ¬ MapDummy[l.gfi, l.offset --should be 0--];                  signal =>                    [imp, offset] ¬ MapDummy[l.gfi, l.index];                  procedure =>                    [imp, offset] ¬ MapDummy[l.gfi, l.ep];		  ENDCASE;                IF ~anyUnbound THEN {                  MBOut.CR[];                  MBOut.Line["Unbound Imports (* = module has code links):"L]; MBOut.CR[];                  anyUnbound ¬ TRUE};                IF ~anyUnboundCodeLinks AND codeLinks THEN {                  MBTTY.PutLine[tty, "!Warning: the following modules have code links and unbound imports:"L];                  anyUnboundCodeLinks ¬ TRUE};                IF first THEN {                  MBOut.SP[];                  IF codeLinks THEN MBOut.Char['*] ELSE MBOut.SP[];                  OutNameToLoadmap[mth.name, bcd];                  MBOut.Char[':];                  IF codeLinks THEN {                    MBTTY.PutString[tty, "  "L];                    OutName[mth.name, bcd];                    MBTTY.PutChar[tty, ':]};                  first ¬ FALSE}                ELSE {                  MBOut.Char[',];                  IF codeLinks THEN MBTTY.PutChar[tty, ',]};                MBOut.Char[' ];		IF imp = NIL THEN MBOut.Text["Unknown"L]		ELSE OutNameToLoadmap[imp.name, bcd];                MBOut.Char['[]; MBOut.Decimal[offset]; MBOut.Char[']];                IF codeLinks THEN {                  MBTTY.PutChar[tty, ' ];		  IF imp = NIL THEN MBTTY.PutString[tty, "Unknown"L]		  ELSE OutName[imp.name, bcd];                  MBTTY.PutChar[tty, '[]; MBTTY.PutDecimal[tty, offset]; MBTTY.PutChar[tty, ']]}};              ENDCASE;            ENDLOOP;          IF ~first THEN {            MBOut.CR[];            IF codeLinks THEN MBTTY.PutCR[tty]};          CloseLinkSpace[]};        MBLoaderOps.ReleaseBcd[bh]};      RETURN[FALSE]};    [] ¬ MBLoaderOps.EnumerateModules[CheckIfUnresolved]};  GetVirtualLinks: PUBLIC PROC [loadee: MB.BHandle, mth: BcdOps.MTHandle]    RETURNS [virtualLinks: MBLoaderOps.VirtualLinks] =    BEGIN    bcd: BcdOps.BcdBase = loadee.bcd;    linkFrag: LONG POINTER TO BcdDefs.LinkFrag;    lfTable: BcdDefs.Base = LOOPHOLE[bcd + bcd.lfOffset];    linkFrag ¬ @lfTable[mth.links];    RETURN[DESCRIPTOR[linkFrag.frag]]    END;  OpenLinkSpace: PUBLIC PROC [loadee: MB.BHandle, mth: BcdOps.MTHandle] = {    frame: PrincOpsExtras2.LongGlobalFrameHandle;    nLinks: CARDINAL =      LOOPHOLE[loadee.bcd + loadee.bcd.lfOffset, BcdDefs.Base][mth.links].length;    [frame: frame, codeLinks: codeLinks] ¬ loadee.mt[MB.FindGFI[loadee, mth]];    IF codeLinks = NIL THEN {  -- frame links      ls ¬ LOOPHOLE[        frame - nLinks*SIZE[PrincOpsExtras2.ControlLink] -	SIZE[PrincOpsExtras2.GlobalOverhead], LONG POINTER]}};  CloseLinkSpace: PUBLIC PROC = {};  ReadLink: PUBLIC PROC [offset: CARDINAL] RETURNS [link: PrincOpsExtras2.ControlLink] = {    IF codeLinks = NIL THEN MBVM.LongCopyRead[      from: ls+(offset*SIZE[PrincOpsExtras2.ControlLink]),      to: @link,      nwords: SIZE[PrincOpsExtras2.ControlLink]]    ELSE RETURN[codeLinks[offset]]};  OutName: PROC [name: BcdDefs.NameRecord, bcd: BcdOps.BcdBase] = {    ssb: BcdOps.NameString = LOOPHOLE[bcd + bcd.ssOffset];    FOR i: CARDINAL IN [name..name+ssb.size[name]) DO      MBTTY.PutChar[data.ttyHandle, ssb.string[i]];       ENDLOOP};  OutNameToLoadmap: PROC [name: BcdDefs.NameRecord, bcd: BcdOps.BcdBase] = {    ssb: BcdOps.NameString = LOOPHOLE[bcd + bcd.ssOffset];    FOR i: CARDINAL IN [name..name+ssb.size[name]) DO      MBOut.Char[ssb.string[i]];       ENDLOOP};  ProcessFramePacks: PUBLIC PROC [        bcd: BcdOps.BcdBase, 	userProc: PROC [BcdOps.FPHandle] RETURNS [BOOLEAN]]       RETURNS [BcdOps.FPHandle] = {    fpb: BcdDefs.Base = LOOPHOLE[bcd + bcd.fpOffset];    fph: BcdOps.FPHandle;    FOR fpi: BcdDefs.FPIndex ¬ FIRST[BcdDefs.FPIndex],     fpi + SIZE[BcdDefs.FPRecord] + fph.length*SIZE[BcdDefs.MTIndex]    UNTIL fpi = bcd.fpLimit DO      fph ¬ @fpb[fpi];      IF userProc[fph] THEN RETURN[fph];      ENDLOOP;    RETURN[NIL]};  ModulesToLoadmap: PROC [loadee: MB.BHandle, bcdInfo: LoadState.BcdInfoIndex] = {    bcd: BcdOps.BcdBase = loadee.bcd;    moduleSeq: LoadState.ModuleInfoSequenceHandle;    ssb: BcdOps.NameString ¬ LOOPHOLE[bcd + bcd.ssOffset];    DoOneModule: PROC [      mth: BcdOps.MTHandle, mti: BcdDefs.MTIndex] RETURNS [BOOLEAN] = {      frame: PrincOpsExtras2.LongGlobalFrameHandle =         LoadedMem.GlobalFrameFromGFTHandle[moduleSeq[IndexFromMTI[mti]].gfi];      gfb: PrincOpsExtras2.GlobalFrameBase ¬ MB.VirtualGlobalFrame[frame];      codebase: PrincOps.GlobalCodebase ¬ LoadedMem.ReadCodebase[frame];      MBOut.Spaces[2];      FOR i: CARDINAL IN [mth.name .. mth.name+ssb.size[mth.name]) DO        MBOut.Char[ssb.string.text[i]];        ENDLOOP;      FOR i: CARDINAL IN [ssb.size[mth.name]..24) DO MBOut.SP[] ENDLOOP;      MBOut.SP[];       MBOut.LongNumber[frame, [8,FALSE,TRUE,6]];      MBOut.SP[];       MBOut.LongNumber[codebase.codebase, [8,FALSE,TRUE,8]];      IF gfb.word.codelinks THEN MBOut.Char['*] ELSE MBOut.Char[' ];      MBOut.SP[];      MBOut.Number[moduleSeq[IndexFromMTI[mti]].gfi, [8,FALSE,TRUE,6]];      MBOut.CR[];      RETURN[FALSE]};          moduleSeq ¬ LoadState.ModuleInfosOfBcd[bcdInfo, data.z];    SortModuleSequence[moduleSeq];    IF loadee.mt = NIL THEN CreateMT[loadee, moduleSeq];    [] ¬ BcdOps.ProcessModules[bcd, DoOneModule];    data.z.FREE[@moduleSeq];    };      SortModuleSequence: PROC[moduleSeq: LoadState.ModuleInfoSequenceHandle] = {    CompareIt: QuickSort.CompareProc = {      IF moduleSeq[one].cgfi < moduleSeq[two].cgfi THEN RETURN[smaller]      ELSE IF moduleSeq[one].cgfi > moduleSeq[two].cgfi THEN RETURN[bigger]      ELSE RETURN[same];      };    SwapIt: QuickSort.SwapProc = {      temp: LoadStateFormat.ModuleInfo;      temp ¬ moduleSeq[one];      moduleSeq[one] ¬ moduleSeq[two];      moduleSeq[two] ¬ temp;      };    QuickSort.Sort[0, moduleSeq.maxLength-1, CompareIt, SwapIt, NIL];    };    IndexFromMTI: PROC[mti: BcdDefs.MTIndex] RETURNS [CARDINAL] = {    RETURN[LOOPHOLE[mti, CARDINAL]/SIZE[BcdDefs.MTRecord]]};    CreateMT: PROC[    loadee: MB.BHandle, moduleSeq: LoadState.ModuleInfoSequenceHandle] = {    msi: CARDINAL ¬ 0;    base: CARDINAL;    mfile: MFile.Handle ¬ MSegment.GetFile[MSegment.AddresstoSegment[loadee.bcd]];    sgb: Table.Base ¬ LOOPHOLE[loadee.bcd + loadee.bcd.sgOffset];    CodeSegForModule: PROC[s: MBVM.Seg] RETURNS [BOOLEAN] = {      WITH seg: s­ SELECT FROM        code => {	  IF MFile.SameFile[mfile, seg.file] THEN {	    IF seg.fileBase = base THEN RETURN[TRUE];	    };	  };	ENDCASE;      RETURN [FALSE];      };    DoOneModule: PROC [      mth: BcdOps.MTHandle, mti: BcdDefs.MTIndex] RETURNS [BOOLEAN] = {      sgi: BcdDefs.SGIndex ¬ mth.code.sgi;      gfth: PrincOpsExtras2.GFTHandle ¬ moduleSeq[IndexFromMTI[mti]].gfi;      frame: PrincOpsExtras2.LongGlobalFrameHandle ¬          LoadedMem.GlobalFrameFromGFTHandle[gfth];      base ¬ sgb[sgi].base;      loadee.mt[msi] ¬ [        mth, frame, gfth,	NARROW[MBVM.EnumerateSegs[CodeSegForModule]], 	MB.FetchLinks[mth]];      msi ¬ msi + 1;      RETURN[FALSE]};    loadee.mt ¬ data.z.NEW[MB.ModuleSeq[moduleSeq.maxLength]];    [] ¬ BcdOps.ProcessModules[loadee.bcd, DoOneModule];    };      Init: PROC = {    switches[PilotSwitchesExtra6.useHeapForSmallGlobalFrames] ¬ down;    };    Init[];    END.LogBY	19-Feb-87 10:48:32 	  added call to LoaderCore.InitGlobals to free links from last run 
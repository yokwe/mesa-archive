-- MBLoadedMemImpl.mesa-- BYG	12-Aug-86 13:32:23-- Copyright (C) 1981, 1982, 1983, 1986  by Xerox Corporation. All rights reserved. <<Implementation of LoadedMem using Makeboot's virtual memory mechanism.TO DO:  >>DIRECTORY  BcdDefs,  BcdOps,  BcdOpsExtras,  Environment,  Inline,  LoadedMem,  MB,  MBVM,  MBTTY,  MFile,  MSegment,  PrincOps,  PrincOpsExtras,  PrincOpsExtras2;MBLoadedMemImpl: PROGRAM  IMPORTS     BcdOps, BcdOpsExtras, Inline,     MB, MBVM, MBTTY, MFile, MSegment, PrincOpsExtras2  EXPORTS LoadedMem, MB = {    data: MB.Handle ¬ NIL;    PageSize: CARDINAL = Environment.wordsPerPage;  PagesForWords: PROC[word: CARDINAL] RETURNS [pages: CARDINAL] = INLINE    {RETURN[(word + PageSize -1 )/ PageSize]};    AllocateMDSPages: PUBLIC PROC[size: CARDINAL, content: LoadedMem.Content]    RETURNS[targetAddress: LoadedMem.TargetAddress] = {    seg: MBVM.DataSeg;     seg ¬ MBVM.AllocMDSData[MBVM.MDS, PagesForWords[size], up];    targetAddress ¬ seg.PointerFromSeg[];    seg.info.readOnly ¬ FALSE;    };      Node: TYPE = RECORD[    next: NodeHandle,     buffer: POINTER,    offset: CARDINAL,    maxsize: CARDINAL];      NodeHandle: TYPE = LONG POINTER TO Node;  node: NodeHandle ¬ NIL;    AllocatePages, AllocateWords: PUBLIC PROCEDURE [    size: CARDINAL, content: LoadedMem.Content]    RETURNS [targetAddress: LoadedMem.TargetLongAddress] = {    seg: MBVM.DataSeg;     pages: CARDINAL;    pages ¬ PagesForWords[size];    seg ¬ MBVM.AllocData[MBVM.HyperSpace, pages, up];    targetAddress ¬ seg.LongPointerFromSeg[];    seg.info.readOnly ¬ FALSE;    };      AllocateMDSWords: PUBLIC PROC[size: CARDINAL, content: LoadedMem.Content]    RETURNS[targetAddress: LoadedMem.TargetAddress] = {    seg: MBVM.DataSeg;     pages: CARDINAL;    FOR n: NodeHandle ¬ node, n.next UNTIL n = NIL DO      IF size > (n.maxsize - n.offset) THEN LOOP;      targetAddress ¬ n.buffer + n.offset;      n.offset ¬ n.offset + size;      RETURN[targetAddress];      ENDLOOP;    pages ¬ PagesForWords[size];    seg ¬ MBVM.AllocMDSData[MBVM.MDS, pages, up];    targetAddress ¬ seg.PointerFromSeg[];    seg.info.readOnly ¬ FALSE;    node ¬ data.z.NEW[Node ¬ [      next: node, buffer: targetAddress, offset: size, maxsize: pages*PageSize]];    };      FreeMDSPages: PUBLIC PROC[targetAddress: LoadedMem.TargetAddress]     RETURNS [nil: LoadedMem.TargetAddress] = {    seg: MBVM.Seg;    IF targetAddress = NIL THEN RETURN [NIL];     seg ¬ MBVM.SegFromPointer[targetAddress];    IF seg # NIL THEN seg.Free[];    nil ¬ NIL    };    FreePages: PUBLIC PROC[targetAddress: LoadedMem.TargetLongAddress]     RETURNS [nil: LoadedMem.TargetLongAddress] = {    seg: MBVM.Seg;    IF targetAddress = NIL THEN RETURN [NIL];     seg ¬ MBVM.SegFromLongPointer[targetAddress];    IF seg # NIL THEN seg.Free[];    nil ¬ NIL    };      FreeWords: PUBLIC PROC[targetAddress: LoadedMem.TargetLongAddress]     RETURNS [nil: LoadedMem.TargetLongAddress] = {    nil ¬ NIL    };      FreeMDSWords: PUBLIC PROC[targetAddress: LoadedMem.TargetAddress]     RETURNS [nil: LoadedMem.TargetAddress] = {    nil ¬ NIL;    };      LinkHandle: TYPE = LONG POINTER TO LinkRecord;  LinkRecord: TYPE = RECORD[    next: LinkHandle,    links: MBVM.Links,    mth: BcdOps.MTHandle];      maxTab: CARDINAL = 71;  HashTab: TYPE = ARRAY [0..maxTab) OF LinkHandle;  hashTab: LONG POINTER TO HashTab ¬ NIL;  tty: MBTTY.Handle;    InitLoadedMem: PUBLIC PROC[h: MB.Handle] = {    data ¬ h;    node ¬ NIL;    hashTab ¬ data.z.NEW[HashTab];    FOR i: CARDINAL IN [0..maxTab) DO hashTab[i] ¬ NIL ENDLOOP;    tty ¬ data.ttyHandle;    };      FinishLoadedMem: PUBLIC PROC = {    FOR i: CARDINAL IN [0..maxTab) DO      next, link: LinkHandle ¬ NIL;      FOR link ¬ hashTab[i], next UNTIL link = NIL DO        next ¬ link.next;	data.z.FREE[@link];        ENDLOOP;      ENDLOOP;    data.z.FREE[@hashTab];    };      EnterLinks: PUBLIC PROC[mth: BcdOps.MTHandle, links: MBVM.Links] = {    hash: CARDINAL ¬ Hash[mth];    hashTab[hash] ¬ data.z.NEW[LinkRecord ¬ [      next: hashTab[hash], links: links, mth: mth]];    };      Hash: PROC[mth: BcdOps.MTHandle] RETURNS [hash: CARDINAL] =  {    longhash: LONG CARDINAL ¬ LOOPHOLE[mth, LONG CARDINAL] MOD maxTab;    hash ¬ CARDINAL[longhash];    };      FetchLinks: PUBLIC PROC[mth: BcdOps.MTHandle] RETURNS [links: MBVM.Links] = {    hash: CARDINAL ¬ Hash[mth];    FOR link: LinkHandle ¬ hashTab[hash], link.next UNTIL link = NIL DO      IF link.mth = mth THEN RETURN[link.links];      ENDLOOP;    RETURN[NIL];    };    MapCode: PUBLIC PROC[    bcd: BcdOps.BcdBase, pageOffset, pageCount: CARDINAL,     swapUnits: LoadedMem.SwapUnits, access: LoadedMem.Access]    RETURNS [targetAddress: LoadedMem.TargetLongAddress] = {    seg: MBVM.CodeSeg;    sph: BcdOps.SPHandle ¬ NIL;    mseg: MSegment.Handle ¬ NIL;    mfile: MFile.Handle ¬ NIL;    lastPlusOne: CARDINAL = pageOffset+pageCount;    FindSeg: PROC [sg: BcdOps.SGHandle, sgi: BcdDefs.SGIndex]       RETURNS [BOOLEAN] = {      IF sg.class = code THEN {        base: CARDINAL = sg.base - BcdOpsExtras.segmentBaseOrigin;        IF base = pageOffset THEN {          sph ¬ BcdOpsExtras.SPHandleFromSGHandle[bcd, sg];	  mfile ¬ mfile.CopyFileHandle[[], readOnly];	  seg ¬ MBVM.AllocCode[	    mfile, MBVM.Code, sg.pages+sg.extraPages, sg.base, sph];	  IF targetAddress = NIL THEN targetAddress ¬ seg.LongPointerFromSeg[];	  RETURN[TRUE];	  };        };      RETURN[FALSE];      };    targetAddress ¬ NIL;    mseg ¬ MSegment.AddresstoSegment[bcd];    mfile ¬ mseg.GetFile[];    [] ¬ BcdOps.ProcessSegs[bcd, FindSeg];    };      MakeCodeReadOnly: PUBLIC PROC[targetAddress: LoadedMem.TargetLongAddress] = {    };      UnmapCode: PUBLIC PROC[targetAddress: LoadedMem.TargetLongAddress]    RETURNS [unmapped: LoadedMem.Interval] = {    seg: MBVM.Seg;    IF targetAddress = NIL THEN RETURN [LoadedMem.nullInterval];    seg ¬ MBVM.SegFromLongPointer[targetAddress];    unmapped ¬ [targetAddress, CARDINAL[seg.pages]];    IF seg # NIL THEN seg.Free[];    };      Long: PUBLIC PROC[targetAddress: LoadedMem.TargetAddress]     RETURNS [LoadedMem.TargetLongAddress] = {    lc: LONG CARDINAL ¬ Inline.LongMult[CARDINAL[data.mdsBase], PageSize] +       LOOPHOLE[targetAddress, CARDINAL];    RETURN[LOOPHOLE[lc, LoadedMem.TargetLongAddress]];    };  Short: PUBLIC PROCEDURE [targetAddress: LoadedMem.TargetLongAddress]     RETURNS [LoadedMem.TargetAddress] = {    RETURN[Inline.LowHalf[targetAddress]];    };  ReadMDSWord: PUBLIC PROC[targetAddress: LoadedMem.TargetAddress]     RETURNS [UNSPECIFIED] = {    RETURN[MBVM.Read[targetAddress]];    };      ReadMDSBlock: PUBLIC PROC[    targetAddress: LoadedMem.TargetAddress, localAddress: LONG POINTER,     size: CARDINAL] = {    MBVM.CopyRead[from: targetAddress, to: localAddress, nwords: size];    };  ReadBlock: PUBLIC PROC[    targetAddress: LoadedMem.TargetLongAddress, localAddress: LONG POINTER,     size: CARDINAL] = {    MBVM.LongCopyRead[from: targetAddress, to: localAddress, nwords: size];    };      WriteMDSWord: PUBLIC PROC[    targetAddress: LoadedMem.TargetAddress, word: UNSPECIFIED,     access: LoadedMem.Access] = {    MBVM.Write[p: targetAddress, v: word];    };  WriteWord: PUBLIC PROC[    targetAddress: LoadedMem.TargetLongAddress, word: UNSPECIFIED,     access: LoadedMem.Access] = {    MBVM.LongWrite[p: targetAddress, v: word];    };  WriteMDSBlock: PUBLIC PROC[    targetAddress: LoadedMem.TargetAddress,    localAddress: LONG POINTER, size: CARDINAL, access: LoadedMem.Access] = {    MBVM.CopyWrite[from: localAddress, to: targetAddress, nwords: size];    };      WriteBlock: PUBLIC PROC[    targetAddress: LoadedMem.TargetLongAddress,    localAddress: LONG POINTER, size: CARDINAL, access: LoadedMem.Access] = {    MBVM.LongCopyWrite[from: localAddress, to: targetAddress, nwords: size]    };      SegFromPointer: PUBLIC PROC [p: LONG POINTER] RETURNS [s: MBVM.Seg] = {    base: MBVM.Base ¬ Inline.LongDiv[LOOPHOLE[p], PageSize];    FindSeg: PROC [seg: MBVM.Seg] RETURNS [BOOLEAN] = {      RETURN[base >= seg.base AND base < seg.base + seg.pages]};    RETURN[MBVM.EnumerateSegs[FindSeg]]};  WeirdError: SIGNAL [s: LONG STRING] = CODE;    ReadCodeLinks: PUBLIC PROCEDURE [    targetAddress: LoadedMem.TargetLongAddress,    mth: BcdOps.MTHandle,     localAddress: LONG DESCRIPTOR FOR ARRAY OF PrincOpsExtras2.ImportLink] ={    seg: MBVM.Seg ¬ NIL;    seg ¬ SegFromPointer[targetAddress];    IF seg = NIL THEN WeirdError["Can't find code segment in ReadCodeLinks.\n"L];    WITH s: seg­ SELECT FROM      code => {        longoffset: LONG CARDINAL ¬ LOOPHOLE[targetAddress];	offset: CARDINAL ¬ CARDINAL[	  longoffset - (s.base * Environment.wordsPerPage)];	FOR piece: MBVM.CodePiece ¬ s.codePiece, piece.next UNTIL piece = NIL DO	  WITH p: piece SELECT FROM	    link => IF p.offset = offset THEN {	      IF p.links.length # localAddress.LENGTH THEN {		MBTTY.PutString[tty, "Code link inconsistency in ReadCodeLinks.\n"L];		SIGNAL MB.Abort[];		};	      FOR i: CARDINAL IN [0..localAddress.LENGTH) DO	        localAddress[i] ¬ LOOPHOLE[p.links[i]];	        ENDLOOP;	      };	    ENDCASE;	  ENDLOOP;	};      ENDCASE => WeirdError["Segment no a code segment"L];    };      WriteCodeLinks: PUBLIC PROC[    targetAddress: LoadedMem.TargetLongAddress,    mth: BcdOps.MTHandle,     localAddress: LONG DESCRIPTOR FOR ARRAY OF PrincOpsExtras2.ImportLink,    access: LoadedMem.Access] = {    links: MBVM.Links ¬ NIL;    seg: MBVM.Seg ¬ NIL;    seg ¬ SegFromPointer[targetAddress];    IF seg = NIL THEN RETURN;    IF (links ¬ FetchLinks[mth]) = NIL THEN      links ¬ data.z.NEW[MBVM.LinkObject[localAddress.LENGTH]];    IF links.length # localAddress.LENGTH THEN {      tty.PutString["Code link inconsistency in WriteCodeLinks.\n"L];      SIGNAL MB.Abort[];      };    FOR i: CARDINAL IN [0..links.length) DO       links[i] ¬ LOOPHOLE[localAddress[i]];      ENDLOOP;    WITH s: seg­ SELECT FROM      code => {	longoffset: LONG CARDINAL ¬ LOOPHOLE[targetAddress];        AddLinksToSeg[	  seg: @s, links: links, 	  offset: CARDINAL [longoffset - (s.base * Environment.wordsPerPage)]];	CheckPieces[@s];	EnterLinks[mth, links];	};      ENDCASE  => WeirdError["Segment no a code segment"L];          };    ReadGlobalExtra: PUBLIC PROCEDURE [gf: PrincOps.GlobalFrameHandle]    RETURNS [WORD] = {    RETURN[MBVM.Read[gf - PrincOpsExtras.globalExtraOffset]];    };      ReadGlobal: PUBLIC PROCEDURE [gf: PrincOpsExtras2.LongGlobalFrameHandle]    RETURNS [PrincOpsExtras2.GFTIndex] = {    gw: PrincOpsExtras2.GlobalWord ¬ LOOPHOLE[      MBVM.LongRead[gf - PrincOpsExtras2.globalWordOffset],       PrincOpsExtras2.GlobalWord];    RETURN[gw.gfi];    };  ReadGlobalWord: PUBLIC PROCEDURE [gf: PrincOpsExtras2.LongGlobalFrameHandle]    RETURNS [PrincOpsExtras2.GlobalWord] = {    RETURN[LOOPHOLE[      MBVM.LongRead[gf - PrincOpsExtras2.globalWordOffset],       PrincOpsExtras2.GlobalWord]];    };  ReadExtraGlobalWord: PUBLIC PROCEDURE [    gf: PrincOpsExtras2.LongGlobalFrameHandle]    RETURNS [PrincOpsExtras2.ExtraGlobalWord] = {    RETURN[LOOPHOLE[      MBVM.LongRead[gf - PrincOpsExtras2.extraGlobalWordOffset],       PrincOpsExtras2.ExtraGlobalWord]];    };  ReadCodebase: PUBLIC PROCEDURE [gf: PrincOpsExtras2.LongGlobalFrameHandle]    RETURNS [gcb: PrincOps.GlobalCodebase] = {    gfi: PrincOpsExtras2.GFTIndex ¬ ReadGlobal[gf];    gcb ¬ data.gft[gfi].codebase;    };  WriteGlobalIndex: PUBLIC PROCEDURE [    gfi: PrincOpsExtras2.GFTIndex, gf: PrincOpsExtras2.LongGlobalFrameHandle] = {    gw: PrincOpsExtras2.GlobalWord ¬ ReadGlobalWord[gf];    gw.gfi ¬ gfi;    WriteGlobalWord[gw, gf];    };  WriteGlobalWord: PUBLIC PROCEDURE [    gw: PrincOpsExtras2.GlobalWord, gf: PrincOpsExtras2.LongGlobalFrameHandle] = {    MBVM.LongWrite[      gf - PrincOpsExtras2.globalWordOffset, LOOPHOLE[gw, UNSPECIFIED]]};  WriteExtraGlobalWord: PUBLIC PROCEDURE [    xgw: PrincOpsExtras2.ExtraGlobalWord,     gf: PrincOpsExtras2.LongGlobalFrameHandle] = {    MBVM.LongWrite[gf - PrincOpsExtras2.extraGlobalWordOffset,     LOOPHOLE[xgw, UNSPECIFIED]]};  WriteCodebase: PUBLIC PROCEDURE [    gcb: PrincOps.GlobalCodebase, gf: PrincOpsExtras2.GFTHandle] = {    gfi: PrincOpsExtras2.GFTIndex ¬ PrincOpsExtras2.GFTHandleToIndex[gf];    data.gft[gfi].codebase ¬ gcb;    };      GlobalFrameFromGFTHandle: PUBLIC PROC[gfth: PrincOpsExtras2.GFTHandle]     RETURNS[gf: PrincOpsExtras2.LongGlobalFrameHandle] = {    gfi: PrincOpsExtras2.GFTIndex ¬ PrincOpsExtras2.GFTHandleToIndex[gfth];    gf ¬ data.gft[gfi].globalFrame;    };  GFTHandleFromGlobalFrame: PUBLIC PROC[    gf: PrincOpsExtras2.LongGlobalFrameHandle]     RETURNS[gfth: PrincOpsExtras2.GFTHandle] = {    gfi: PrincOpsExtras2.GFTIndex ¬ ReadGlobal[gf];    gfth ¬ PrincOpsExtras2.GFTIndexToHandle[gfi];    };  Bug: PROC = {MB.Error["Bug in MBLoader"L]};   AddLinksToSeg: PROC [seg: MBVM.CodeSeg, offset: CARDINAL, links: MBVM.Links] = {    piece: MBVM.CodePiece ¬ seg.codePiece;    linkPiece: MBVM.CodePiece ¬ data.z.NEW[link MBVM.CodeItem ¬ [      next: NIL, offset: offset, body: link[links: links]]];    prev: MBVM.CodePiece ¬ NIL;    nLinks: CARDINAL = links.length;    linkWords: CARDINAL = nLinks * SIZE[PrincOpsExtras2.ImportLink];    DO      WITH p: piece SELECT FROM        code =>	  SELECT p.offset FROM	    < offset => {	      pieceEnd: CARDINAL = p.offset+p.length;	      IF pieceEnd > offset THEN {	        -- first part of old piece ("p"), then links ("linkPiece"),		-- then rest (less link space) of old piece ("newCodePiece")		firstPartLength: CARDINAL = (offset - p.offset);		newPartOffset: CARDINAL = (offset + linkWords);		newPartLength: CARDINAL = 		  (p.length - (firstPartLength + linkWords));	        newCodePiece: MBVM.CodePiece ¬ data.z.NEW[code MBVM.CodeItem ¬ [                  next: p.next, offset: newPartOffset,		  body: code[length: newPartLength]]];	        IF newPartOffset > pieceEnd THEN Bug[];		IF (newPartOffset+newPartLength) # (p.offset+p.length) THEN Bug[];		p.next ¬ linkPiece;  linkPiece.next ¬ newCodePiece;		p.length ¬ firstPartLength;		RETURN}};	    = offset => {	      linkPiece.next ¬ @p;	      IF prev = NIL THEN seg.codePiece ¬ linkPiece	      ELSE prev.next ¬ linkPiece;	      p.offset ¬ p.offset + linkWords;	      p.length ¬ p.length - linkWords;	      RETURN};	    ENDCASE => Bug[];        link =>	  IF p.offset = offset THEN {	    IF p.links.length # links.length THEN Bug[];	    data.z.FREE[@linkPiece];	    RETURN};        ENDCASE => Bug[];      prev ¬ piece;      piece ¬ piece.next;      IF piece = NIL THEN Bug[];      ENDLOOP;    };     CheckPieces: PROC [seg: MBVM.CodeSeg] = {    piece: MBVM.CodePiece ¬ seg.codePiece;    offset: CARDINAL ¬ 0;    DO      IF piece.offset # offset THEN Bug[];      WITH p: piece SELECT FROM        code => offset ¬ offset + p.length;        link => offset ¬ offset + p.links.length*SIZE[PrincOpsExtras2.ImportLink];        ENDCASE => Bug[];      piece ¬ piece.next;      IF piece = NIL THEN {        IF offset # seg.pages * Environment.wordsPerPage THEN Bug[];	EXIT};      ENDLOOP;    RETURN};      }.    
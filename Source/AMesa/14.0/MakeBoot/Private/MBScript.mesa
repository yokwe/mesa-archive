-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- MBScript.mesa  --   JGS	27-Jul-82 16:48:28--   BTL	19-Apr-83 11:19:59--   RKJ	19-Sep-83  8:20:43--   BJD	21-Jul-83 13:06:02--   BGY	29-Aug-86 13:05:35DIRECTORY  BcdDefs USING [Base, MTIndex],  BcdOps USING [BcdBase, FPHandle, MTHandle, SPHandle, ProcessModules],  BootFile USING [MemorySizeToFileSize],  Environment USING [wordsPerPage],  Inline USING [LongCOPY],  MB USING [    BHandle, Copy, Handle, EnumerateFramePacks, EnumerateCode,    EnumerateGlobalFrames, EnumerateBCDs, FindGFI, VirtualGlobalFrame,    EnumerateSpaces, EnumerateReservedMemory, Zero],  MBVM USING [    AllocData, Base, BitArray, CodeSeg, LongCopyWrite, DataSeg, FileSeg,    MaxBase, HyperSpace, Pages, LongPointerFromSeg, Seg, SortSegs, vmMap,    SetBusy, SetFree],  MBOut,   PrincOpsExtras2 USING [GFTHandle, LongGlobalFrameHandle],  StartList USING [    BackingLocation, Entry, Header, Index, NullSpaceIndex,    SpaceIndex, SpaceType, StartIndex, SwapUnitIndex, SwapUnitInfo,    SwapUnitState, Base, VersionID],  MBStorage USING [FreePages, FreeWords, Pages, PagesForWords, Words];MBScript: PROGRAM  IMPORTS BcdOps, BootFile, Inline, MB, MBVM, MBOut, MBStorage  EXPORTS MB =BEGIN OPEN StartList;PageSize: CARDINAL = Environment.wordsPerPage;PageState: TYPE = RECORD [busy, resident, in, readOnly, mds, first64K: BOOLEAN];data: MB.Handle ¬ NIL;segs: LONG DESCRIPTOR FOR ARRAY OF MBVM.Seg;residentTable, resDescTable, inTable, readOnlyTable: PUBLIC MBVM.BitArray;suIndex: SwapUnitIndex;startSpaceIndex: SpaceIndex;nSpaces: CARDINAL;gftBase, gftEnd: CARDINAL ¬ 0;gftSeg: MBVM.DataSeg;-- Wart Script ManagementscriptIndex: PUBLIC Index;tablePages: CARDINAL;scriptBase: PUBLIC StartList.Base;header: LONG POINTER TO Header;InitScript: PUBLIC PROC [h: MB.Handle] = {  nWords: CARDINAL = SIZE[PACKED ARRAY [0..CARDINAL[MBVM.MaxBase]] OF BOOLEAN];  IF data # NIL THEN FinishScript[];  data ¬ h;  header ¬ data.z.NEW[Header];  MB.Zero[header, SIZE[Header]];  data.header ¬ header;  header.version ¬ VersionID;  residentTable ¬ MBStorage.Words[nWords];  resDescTable ¬ MBStorage.Words[nWords];  inTable ¬ MBStorage.Words[nWords];  readOnlyTable ¬ MBStorage.Words[nWords];  MB.Zero[residentTable, nWords];  MB.Zero[resDescTable, nWords];  MB.Zero[inTable, nWords];  MB.Zero[readOnlyTable, nWords];  scriptIndex ¬ StartList.StartIndex;  tablePages ¬ 0;  nSpaces ¬ 0;  scriptBase ¬ NIL;  gftSeg ¬ NIL;  gftBase ¬ gftEnd ¬ 0;};FinishScript: PUBLIC PROC = {  IF residentTable # NIL THEN {    MBStorage.FreeWords[residentTable]; residentTable ¬ NIL};  IF resDescTable # NIL THEN {    MBStorage.FreeWords[resDescTable]; resDescTable ¬ NIL};  IF inTable # NIL THEN {    MBStorage.FreeWords[inTable]; inTable ¬ NIL};  IF readOnlyTable # NIL THEN {    MBStorage.FreeWords[readOnlyTable]; readOnlyTable ¬ NIL};  IF header # NIL THEN data.z.FREE[@header];  IF scriptBase # NIL THEN {    MBStorage.FreePages[scriptBase]; scriptBase ¬ NIL};  data ¬ NIL};  MakeScript: PUBLIC PROC = {  r: stop Entry ¬ Entry[stop[]];  Empty: PageState = [FALSE, FALSE, FALSE, FALSE, FALSE, FALSE];  state: PageState ¬ Empty;  inMDS, inFirst64K: BOOLEAN;  mdsBase: CARDINAL = CARDINAL[data.mdsBase];  newState: PageState;  i, nwords, start: CARDINAL;  tableSeg: MBVM.DataSeg;  gftBase ¬ CARDINAL[data.gftBase] +(IF data.germ THEN 0 ELSE 1);  segs ¬ MBVM.SortSegs[];  FOR i IN [0..LENGTH[segs]) DO AddToBitTables[segs[i]] ENDLOOP;  FOR i IN [0..LENGTH[segs]) DO     IF segs[i].base # gftBase THEN LOOP;    gftSeg ¬ NARROW[segs[i]];    gftEnd ¬ gftBase + CARDINAL[segs[i].pages];    EXIT;    ENDLOOP;  ClassifyPages[];  IF data.germ THEN RETURN;  MB.EnumerateReservedMemory[MBVM.SetFree];  state ¬ [    busy: MBVM.vmMap[0], resident: residentTable[0], in: inTable[0],    readOnly: readOnlyTable[0], mds: mdsBase = 0, first64K: TRUE];  FOR i IN [1..CARDINAL[data.lastVMPage]] DO    inMDS ¬ (i IN [mdsBase..mdsBase+255]);    inFirst64K ¬ (i IN [0..255]);    IF i = gftBase THEN {      nSpaces ¬ nSpaces + 1 + (gftEnd - gftBase);      i ¬ gftEnd;      inMDS ¬ (i IN [mdsBase..mdsBase+255]);      inFirst64K ¬ (i IN [0..255]);      state ¬ [	busy: MBVM.vmMap[i], resident: residentTable[i], in: inTable[i],	readOnly: readOnlyTable[i], mds: inMDS, first64K: inFirst64K];      };    newState ¬ [      busy: MBVM.vmMap[i], resident: residentTable[i], in: inTable[i],      readOnly: readOnlyTable[i], mds: inMDS, first64K: inFirst64K];    IF newState # state THEN {      state ¬ newState;  nSpaces ¬ nSpaces + 1};    ENDLOOP;  nSpaces ¬ nSpaces + 1;  nwords ¬ 0;  FOR i IN [0..LENGTH[segs]) DO    nwords ¬ nwords + (WITH s: segs[i] SELECT FROM      code => (IF s.sph # NIL        THEN s.sph.length*SIZE[swapUnit Entry] ELSE SIZE[swapUnit Entry]),      data => (IF segs[i] # gftSeg THEN SIZE[swapUnit Entry]        ELSE ((gftEnd-gftBase) * SIZE[swapUnit Entry])),      ENDCASE => SIZE[swapUnit Entry]);    ENDLOOP;  nwords ¬ (nwords + SIZE[Header] + 64 + (nSpaces*SIZE[space Entry]) +    SIZE[stop Entry] );  AddScriptWords[nwords];  MB.EnumerateReservedMemory[MBVM.SetBusy];  tableSeg ¬ MBVM.AllocData[base: MBVM.HyperSpace, pages: tablePages, dir: up];  tableSeg.bootLoaded ¬ TRUE;  tableSeg.info ¬ [readOnly: FALSE, state: swappable];  AddToBitTables[tableSeg];  MB.EnumerateReservedMemory[MBVM.SetFree];  header.table ¬ MBVM.LongPointerFromSeg[tableSeg];  MBStorage.FreePages[BASE[segs]];  segs ¬ MBVM.SortSegs[];  FOR i IN [0..LENGTH[segs]) DO EnterSegment[segs[i]] ENDLOOP;  startSpaceIndex ¬ LOOPHOLE[scriptIndex];  state ¬ [    busy: MBVM.vmMap[0], resident: residentTable[0], in: inTable[0],    readOnly: readOnlyTable[0], mds: mdsBase = 0, first64K: TRUE];  nSpaces ¬ start ¬ 0;  suIndex ¬ LOOPHOLE[StartIndex];  MBOut.Text["spaces:\nstart	pages	offset\n"L];  FOR i IN [1..CARDINAL[data.lastVMPage]] DO    inMDS ¬ i IN [mdsBase..mdsBase+255];    inFirst64K ¬ i IN [0..255];    IF i = gftBase THEN {      AddSpace[state, start, i-1];  start ¬ i;      FOR i IN [gftBase+1..gftEnd] DO        state ¬ [busy: TRUE, resident: residentTable[i-1], in: TRUE,	readOnly: readOnlyTable[i-1], mds: inMDS, first64K: inFirst64K];	AddSpace[state, start, i-1];  	start ¬ i;        ENDLOOP;      i ¬ gftEnd;      inMDS ¬ i IN [mdsBase..mdsBase+255];      inFirst64K ¬ i IN [0..255];      state ¬ [	busy: MBVM.vmMap[i], resident: residentTable[i], in: inTable[i],	readOnly: readOnlyTable[i], mds: inMDS, first64K: inFirst64K];      };    newState ¬ [      busy: MBVM.vmMap[i], resident: residentTable[i], in: inTable[i],      readOnly: readOnlyTable[i], mds: inMDS, first64K: inFirst64K];    IF newState # state THEN {      AddSpace[state, start, i-1];  start ¬ i;  state ¬ newState};    ENDLOOP;  AddSpace[state, start, CARDINAL[data.lastVMPage]];  AppendBootWords[@r, SIZE[stop Entry]];  [lastBootedPage: header.lastBootLoadedPage] ¬ CalculateBackingPages[];  MBStorage.FreePages[BASE[segs]];  header.mdsBase ¬ data.mdsBase;  header.pdaPages ¬ data.pdaPages;  header.initLoadState ¬ data.lsseg.index;  header.lastVMPage ¬ data.lastVMPage;  header.stateVectorCounts ¬ data.stateVectorCounts;  header.stateVectorSize ¬ data.svSize;  header.nProcesses ¬ data.nProcesses;  header.buildDate ¬ data.buildTime;  header.expirationDate ¬ data.buildTime + SecondsInTwoYears;  header.switches ¬ LOOPHOLE[data.switches];  scriptBase­ ¬ header­;  MBVM.LongCopyWrite[    from: scriptBase, to: header.table, nwords: PageSize*tablePages]};SecondsInTwoYears: LONG CARDINAL = LONG[365]*24*60*60;AddToBitTables: PROC [seg: MBVM.Seg] = {  resDesc: BOOLEAN = (seg.info.state = residentDescriptor);  resident: BOOLEAN = (seg.info.state = resident);  FOR i: CARDINAL IN [CARDINAL[seg.base]..CARDINAL[seg.base+seg.pages]) DO    readOnlyTable[i] ¬ seg.info.readOnly;    inTable[i] ¬ seg.bootLoaded;    resDescTable[i] ¬ resDesc;    residentTable[i] ¬ resident;    ENDLOOP};ClassifyPages: PROC = {  MB.EnumerateCode[in, BootLoadCode];  MB.EnumerateSpaces[in, BootLoadSpaces];  MB.EnumerateFramePacks[in, BootLoadFramePacks];  MB.EnumerateGlobalFrames[in, BootLoadGlobalFrames];  MB.EnumerateBCDs[in, BootLoadBCDs];  MB.EnumerateCode[resDesc, ResDescCode];  MB.EnumerateSpaces[resDesc, ResDescSpaces];  MB.EnumerateFramePacks[resDesc, ResDescFramePacks];  MB.EnumerateGlobalFrames[resDesc, ResDescGlobalFrames];  MB.EnumerateBCDs[resDesc, ResDescBCDs];  MB.EnumerateCode[resident, ResidentCode];  MB.EnumerateSpaces[resident, ResidentSpaces];  -- resident FramePacks and GlobalFrames were done during loading--  MB.EnumerateFramePacks[resident, ResidentFramePacks];  MB.EnumerateGlobalFrames[resident, ResidentGlobalFrames];  MB.EnumerateBCDs[resident, ResidentBCDs]};MTHandle: TYPE = BcdOps.MTHandle;MTIndex: TYPE = BcdDefs.MTIndex;BcdBase: TYPE = BcdOps.BcdBase; ProcessUnpackagedModules: PROCEDURE [  bh: MB.BHandle, proc: PROC [bh: MB.BHandle, mth: BcdOps.MTHandle] RETURNS [BOOLEAN]]  RETURNS [mth: MTHandle, mti: MTIndex] = {  OneModule: PROCEDURE [mth: MTHandle, mti: MTIndex] RETURNS [BOOLEAN] = {    RETURN[IF mth.packageable THEN proc[bh, mth] ELSE FALSE]};  [mth, mti] ¬ BcdOps.ProcessModules[bh.bcd, OneModule]};BootLoadCode: PROC [bh: MB.BHandle, mth: BcdOps.MTHandle] RETURNS [BOOLEAN] = {  cseg: MBVM.CodeSeg = bh.mt[MB.FindGFI[bh, mth]].code;  cseg.bootLoaded ¬ TRUE; -- duplicates EnterSegment unless data.germ  MarkSegPages[cseg, @inTable];  RETURN[FALSE]};BootLoadSpaces: PROC [bh: MB.BHandle, sph: BcdOps.SPHandle, index: CARDINAL]  RETURNS [BOOLEAN] = {  MarkSpacePages[sph, index, @inTable];  RETURN[FALSE]};BootLoadFramePacks: PROC [bh: MB.BHandle, fph: BcdOps.FPHandle] RETURNS [BOOLEAN] = {  mtb: BcdDefs.Base = LOOPHOLE[bh.bcd + bh.bcd.mtOffset];  RETURN[BootLoadGlobalFrame[bh, @mtb[fph.modules[0]]]]};BootLoadGlobalFrame: PROC [bh: MB.BHandle, mth: BcdOps.MTHandle] RETURNS [BOOLEAN] = {  frame: PrincOpsExtras2.LongGlobalFrameHandle = bh.mt[MB.FindGFI[bh, mth]].frame;  IF ~MB.VirtualGlobalFrame[frame].extra.alloced THEN    MarkSegPages[      SegForBase[PageFromAddress[frame]], @inTable];  RETURN[FALSE]};BootLoadGlobalFrames: PROC [bh: MB.BHandle, mth: BcdOps.MTHandle] RETURNS [BOOLEAN] = {  [] ¬ ProcessUnpackagedModules[bh, BootLoadGlobalFrame];  RETURN[FALSE]};ResidentFramePacks: PROC [bh: MB.BHandle, fph: BcdOps.FPHandle] RETURNS [BOOLEAN] = {  mtb: BcdDefs.Base = LOOPHOLE[bh.bcd + bh.bcd.mtOffset];  [] ¬ ResidentGlobalFrame[bh, @mtb[fph.modules[0]]];  FOR i: CARDINAL IN [1..fph.length) DO    mth: BcdOps.MTHandle ¬ @mtb[fph.modules[i]];    gfi: CARDINAL ¬ MB.FindGFI[bh, mth];    gfth: PrincOpsExtras2.GFTHandle ¬ bh.mt[gfi].gfth;    gfiPage: CARDINAL ¬       CARDINAL[data.gftBase] + (LOOPHOLE[gfth, CARDINAL])/PageSize;    residentTable[gfiPage] ¬ TRUE;    inTable[gfiPage] ¬ TRUE;    ENDLOOP;  RETURN[FALSE];  };ResidentGlobalFrame: PROC [bh: MB.BHandle, mth: BcdOps.MTHandle]   RETURNS [BOOLEAN] = {  gfi: CARDINAL ¬ MB.FindGFI[bh, mth];  gfth: PrincOpsExtras2.GFTHandle ¬ bh.mt[gfi].gfth;  frame: PrincOpsExtras2.LongGlobalFrameHandle = bh.mt[gfi].frame;  seg: MBVM.Seg ¬ SegForBase[PageFromAddress[frame]];  gfiPage: CARDINAL ¬     CARDINAL[data.gftBase] + (LOOPHOLE[gfth, CARDINAL])/PageSize;  MarkSegPages[seg, @residentTable];  MarkSegPages[seg, @inTable];  residentTable[gfiPage] ¬ TRUE;  inTable[gfiPage] ¬ TRUE;  RETURN[FALSE]};ResidentGlobalFrames: PROC [bh: MB.BHandle, mth: BcdOps.MTHandle]   RETURNS [BOOLEAN] = {  [] ¬ ProcessUnpackagedModules[bh, ResidentGlobalFrame];  RETURN[FALSE]};BootLoadBCDs: PROC [bh: MB.BHandle] RETURNS [BOOLEAN] = {  bcdSeg: MBVM.FileSeg = bh.bcdSeg;  bcdSeg.bootLoaded ¬ TRUE; -- duplicates EnterSegment unless data.germ  MarkSegPages[bcdSeg, @inTable];  RETURN[FALSE]};ResDescCode: PROC [bh: MB.BHandle, mth: BcdOps.MTHandle] RETURNS [BOOLEAN] = {  cseg: MBVM.CodeSeg = bh.mt[MB.FindGFI[bh, mth]].code;  cseg.info.state ¬ residentDescriptor;  MarkSegPages[cseg, @resDescTable];  RETURN[FALSE]};ResDescSpaces: PROC [bh: MB.BHandle, sph: BcdOps.SPHandle, index: CARDINAL]  RETURNS [BOOLEAN] = {  MarkSpacePages[sph, index, @resDescTable];  RETURN[FALSE]};ResDescFramePacks: PROC [bh: MB.BHandle, fph: BcdOps.FPHandle] RETURNS [BOOLEAN] = {  mtb: BcdDefs.Base = LOOPHOLE[bh.bcd + bh.bcd.mtOffset];  RETURN[ResDescGlobalFrame[bh, @mtb[fph.modules[0]]]]};ResDescGlobalFrame: PROC [bh: MB.BHandle, mth: BcdOps.MTHandle] RETURNS [BOOLEAN] = {  frame: PrincOpsExtras2.LongGlobalFrameHandle = bh.mt[MB.FindGFI[bh, mth]].frame;  IF ~MB.VirtualGlobalFrame[frame].extra.alloced THEN    MarkSegPages[     SegForBase[PageFromAddress[frame]], @resDescTable];  RETURN[FALSE]};ResDescGlobalFrames: PROC [bh: MB.BHandle, mth: BcdOps.MTHandle] RETURNS [BOOLEAN] = {  [] ¬ ProcessUnpackagedModules[bh, ResDescGlobalFrame];  RETURN[FALSE]};ResDescBCDs: PROC [bh: MB.BHandle] RETURNS [BOOLEAN] = {  bcdSeg: MBVM.FileSeg = bh.bcdSeg;  bcdSeg.info.state ¬ residentDescriptor;  MarkSegPages[bcdSeg, @resDescTable];  RETURN[FALSE]};ResidentCode: PROC [bh: MB.BHandle, mth: BcdOps.MTHandle] RETURNS [BOOLEAN] = {  cseg: MBVM.CodeSeg = bh.mt[MB.FindGFI[bh, mth]].code;  cseg.info.state ¬ resident;  cseg.bootLoaded ¬ TRUE; -- duplicates EnterSegment unless data.germ  MarkSegPages[cseg, @residentTable];  MarkSegPages[cseg, @inTable];  RETURN[FALSE]};ResidentSpaces: PROC [bh: MB.BHandle, sph: BcdOps.SPHandle, index: CARDINAL]  RETURNS [BOOLEAN] = {  cseg: MBVM.CodeSeg = SegForSpace[sph];  first: CARDINAL = CARDINAL[cseg.base+sph.spaces[index].offset];  count: CARDINAL = sph.spaces[index].pages;  MarkTablePages[@residentTable, first, count];  MarkTablePages[@inTable, first, count];  RETURN[FALSE]};ResidentBCDs: PROC [bh: MB.BHandle] RETURNS [BOOLEAN] = {  bcdSeg: MBVM.FileSeg = bh.bcdSeg;  bcdSeg.info.state ¬ resident;  bcdSeg.bootLoaded ¬ TRUE; -- duplicates EnterSegment unless data.germ  MarkSegPages[bcdSeg, @residentTable];  MarkSegPages[bcdSeg, @inTable];  RETURN[FALSE]};MarkSegPages: PROC [seg: MBVM.Seg, table: LONG POINTER TO MBVM.BitArray] =  INLINE {  MarkTablePages[table, CARDINAL[seg.base], CARDINAL[seg.pages]]};MarkSpacePages: PROC [  sph: BcdOps.SPHandle, index: CARDINAL, table: LONG POINTER TO MBVM.BitArray] = {  cseg: MBVM.CodeSeg = SegForSpace[sph];  MarkTablePages[    table, CARDINAL[cseg.base + sph.spaces[index].offset],    CARDINAL[sph.spaces[index].pages]] };MarkTablePages: PROC [table: LONG POINTER TO MBVM.BitArray, first, count: CARDINAL] = {  FOR i: CARDINAL IN [first..first+count) DO    table­[i] ¬ TRUE;    ENDLOOP};SegForBase: PROC [base: CARDINAL] RETURNS [seg: MBVM.Seg] = {  FOR i: CARDINAL IN [0..LENGTH[segs]) DO    seg ¬ segs[i];    IF base IN [seg.base..seg.base+seg.pages) THEN EXIT;    REPEAT      FINISHED => ERROR;    ENDLOOP};SegForSpace: PROC [sph: BcdOps.SPHandle] RETURNS [cseg: MBVM.CodeSeg] = {  FOR i: CARDINAL IN [0..LENGTH[segs]) DO    WITH s: segs[i] SELECT FROM      code => IF s.sph = sph THEN {cseg ¬ @s;  EXIT};      ENDCASE;    REPEAT      FINISHED => ERROR;    ENDLOOP};AddScriptWords: PROC [nwords: CARDINAL] = {  newPages: CARDINAL ¬ (tablePages + MBStorage.PagesForWords[nwords]);  newbase: LONG POINTER ¬ MBStorage.Pages[newPages];  IF scriptBase # NIL THEN {    MB.Copy[from: scriptBase, to: newbase, n: tablePages*PageSize];    MBStorage.FreePages[scriptBase]};  tablePages ¬ newPages;  data.scriptBase ¬ scriptBase ¬ newbase};EnterSegment: PROC [seg: MBVM.Seg] = {  WITH s: seg SELECT FROM    data => IF seg = gftSeg THEN EnterGFTSeg[seg]             ELSE EnterSimpleSegment[seg];    code => {      IF s.sph = NIL THEN EnterSimpleSegment[seg]      ELSE {        r: swapUnit Entry;	first: BOOLEAN ¬ TRUE;	s.bootLoaded ¬ FALSE;	FOR i: CARDINAL IN [0..s.sph.length) DO	  base: CARDINAL = CARDINAL[s.base+s.sph.spaces[i].offset];	  state: SwapUnitState = SELECT TRUE FROM	    residentTable[base] => resident,	    resDescTable[base] => residentDescriptor,	    ENDCASE => swappable;	  IF residentTable[base] OR inTable[base] THEN s.bootLoaded ¬ TRUE;	  r ¬ Entry[swapUnit[info: [s.info.readOnly, state],	    pages: s.sph.spaces[i].pages, base: s.sph.spaces[i].offset,	    parent: NullSpaceIndex]];	  IF first THEN {first ¬ FALSE; s.index ¬ LOOPHOLE[scriptIndex]};	  AppendBootWords[@r, SIZE[swapUnit Entry]];	  ENDLOOP}};    file => EnterSimpleSegment[seg];    ENDCASE};EnterGFTSeg: PROC [seg: MBVM.Seg] = {  r: swapUnit Entry;  seg.index ¬ LOOPHOLE[scriptIndex];  FOR i: CARDINAL IN [gftBase..gftEnd) DO    swapstate: SwapUnitState ¬       IF residentTable[i] THEN resident      ELSE IF resDescTable[i] THEN residentDescriptor      ELSE swappable;    r ¬ Entry[swapUnit[info: [FALSE, swapstate], pages: 1,      base: 0, parent: NullSpaceIndex]];    AppendBootWords[@r, SIZE[swapUnit Entry]];    ENDLOOP;  };  EnterSimpleSegment: PROC [seg: MBVM.Seg] = {  r: swapUnit Entry;  state: SwapUnitState =    IF seg.info.state = resident THEN resident ELSE      SELECT TRUE FROM        residentTable[CARDINAL[seg.base]] => resident,        resDescTable[CARDINAL[seg.base]] => residentDescriptor,        ENDCASE => swappable;  IF ~seg.bootLoaded THEN    seg.bootLoaded ¬       residentTable[CARDINAL[seg.base]] OR inTable[CARDINAL[seg.base]]  ELSE {t: MBVM.Seg ¬ seg;};  r ¬ Entry[swapUnit[info: [seg.info.readOnly, state], pages: seg.pages,    base: 0, parent: NullSpaceIndex]];  seg.index ¬ LOOPHOLE[scriptIndex];  AppendBootWords[@r, SIZE[swapUnit Entry]]};  AppendBootWords: PROC [addr: POINTER, count: CARDINAL] = {  IF LOOPHOLE[scriptIndex,CARDINAL]+count > tablePages*PageSize OR    count = 0 THEN ERROR;  Inline.LongCOPY[from: addr, to: @scriptBase[scriptIndex], nwords: count];  scriptIndex ¬ scriptIndex + count};AddSpace: PROC [state: PageState, start, end: CARDINAL] = {  r: space Entry;  single: BOOLEAN ¬ TRUE;  resident: BOOLEAN ¬ residentTable[start];  anyResDesc, anyReadOnly: BOOLEAN ¬ FALSE;  allResDesc, allReadOnly: BOOLEAN ¬ TRUE;  offset: CARDINAL;  pages: CARDINAL = end-start+1;  space: SpaceIndex ¬ LOOPHOLE[scriptIndex];  nSpaces ¬ nSpaces + 1;  IF ~state.busy THEN {AddEmptySpace[start, pages]; RETURN};  r ¬ Entry[space[    readOnly: state.readOnly,    bootLoaded: (state.resident OR state.in), reserved:, type:,    pages: pages, vmpage: start, backingPage: 0,    backingStore: (IF state.resident THEN null ELSE self)]];  AppendBootWords[@r, SIZE[space Entry]];  FOR i: CARDINAL IN [start..end] DO    anyResDesc ¬ anyResDesc OR resDescTable[i];    allResDesc ¬ allResDesc AND resDescTable[i];    anyReadOnly ¬ anyReadOnly OR readOnlyTable[i];    allReadOnly ¬ allReadOnly AND readOnlyTable[i];    ENDLOOP;  offset ¬ 0;  DO    scriptBase[suIndex].parent ¬ space;    scriptBase[suIndex].base ¬ offset;    offset ¬ CARDINAL[scriptBase[suIndex].pages] + offset;    MBOut.Octal[start];    MBOut.Text["	"L];    MBOut.Octal[pages];    MBOut.Text["	"L];    MBOut.Octal[offset];    MBOut.Text["	"L];    MBOut.Text[IF LOOPHOLE[suIndex, CARDINAL] < LOOPHOLE[startSpaceIndex, CARDINAL] THEN "OK" ELSE "Overflow"];    MBOut.Text["\n"L];    IF offset >= pages THEN EXIT;    suIndex ¬ suIndex + SIZE[swapUnit Entry];    single ¬ FALSE;    ENDLOOP;  scriptBase[space].type ¬ IF ~single    THEN [family[      anyReadOnlyChildren: anyReadOnly,      anyResidentChildren: resident,      anyResidentDescriptorChildren: anyResDesc,       anySwappableChildren: ~resident,       allReadOnlyChildren: allReadOnly,      allResidentChildren: resident,      allResidentDescriptorChildren: allResDesc,       allSwappableChildren: ~resident]]    ELSE [unitary[suIndex]];  suIndex ¬ suIndex + SIZE[swapUnit Entry]};AddEmptySpace: PROC [start, pages: CARDINAL] = {  r: space Entry;  space: SpaceIndex ¬ LOOPHOLE[scriptIndex];  r ¬ Entry[space[bootLoaded: FALSE, backingStore: null, type: [empty[]],    readOnly: FALSE, pages: pages, vmpage: start, reserved:, backingPage: 0]];  AppendBootWords[@r, SIZE[space Entry]]};PageFromAddress: PROC [p: LONG POINTER] RETURNS [CARDINAL] = {  RETURN[CARDINAL[LOOPHOLE[p, LONG CARDINAL]/256]]};CalculateBackingPages: PROC RETURNS [lastBootedPage: LONG CARDINAL] = {  space: LONG POINTER TO space Entry ¬ @scriptBase[startSpaceIndex];  nBootPages: LONG CARDINAL ¬ 0;  nFilePages: LONG CARDINAL ¬ 0;  THROUGH [0..nSpaces) DO    IF space.type.class # empty AND space.bootLoaded THEN {      pages: MBVM.Pages = space.pages;      nfp: LONG CARDINAL = BootFile.MemorySizeToFileSize[nBootPages];      lastBootedPage ¬ space.vmpage + pages - 1;      IF space.backingStore # null AND	nfp + pages = BootFile.MemorySizeToFileSize[nBootPages + pages] THEN	  IF data.germ THEN space.backingPage ¬ nfp	  ELSE space.backingPage ¬ nfp - 1;      nBootPages ¬ nBootPages + pages};    space ¬ space + SIZE[space Entry];    ENDLOOP;      IF ~data.germ THEN nBootPages ¬ nBootPages - 1; -- see AHL for details    space ¬ @scriptBase[startSpaceIndex];  data.lastBootLoadedFilePage ¬ nFilePages ¬    BootFile.MemorySizeToFileSize[nBootPages];  data.nBootPages ¬ nBootPages;  IF ~data.utilityPilot THEN THROUGH [0..nSpaces) DO    IF space.backingStore # null AND space.backingPage = 0 THEN {      space.backingPage ¬ nFilePages;       nFilePages ¬ nFilePages + space.pages};    space ¬ space + SIZE[space Entry];    ENDLOOP;  data.nFilePages ¬ nFilePages};  END.
-- Copyright (C) 1981, 1982, 1983  by Xerox Corporation. All rights reserved. -- MBParse.mesa  --   Sandman	26-Jul-82 11:31:03--   Lewis	 1-Dec-81 15:44:02--   Daniels	23-Jun-83 16:24:16--   Davirro	21-Jul-83 11:47:54--   Johnsson	22-Sep-83 12:19:19DIRECTORY  Ascii USING [ControlZ, CR, NUL],  BcdOps USING [FPHandle, MTHandle, SPHandle],  Environment USING [wordsPerPage],  Inline USING [BITAND, BITXOR, LongCOPY],  MB USING [    Abort, BHandle, DoAllFramePacks, DoAllSpaces, DoAllBCDs, Error, Handle, InstanceToMTHandle, ListType,    GetFrameWeight, NameToFPHandle, NameToMTHandle, DoAllModules,    NameToCTHandle, NameToSPHandle, ResetConfig, SetConfig, SetFrameWeight,    GetFrameListEnd, SetFrameListEnd],  MBVM USING [Base, Pages],  MBOut USING [    Char, CR, Decimal, Line, LongNumber, Number, NumberFormat, SP, Text, Spaces,    Time],  MFile USING [GetTimes],  MStream USING [Error, GetFile, ReadOnly],  PrincOps USING [FrameSizeIndex, frameSizeMap],  MBStorage USING [FreePages, Pages, PagesForWords],  String USING [    AppendChar, AppendString, EqualString, InvalidNumber, StringToDecimal],  Stream USING [Delete, EndOfStream, GetChar, Handle],  Time USING [Packed],  MBTTY USING [PutChar, PutCR, PutDecimal, PutString];MBParse: PROGRAM    IMPORTS Inline, MB, MBOut, MFile, MStream, MBStorage, String, Stream, MBTTY    EXPORTS MB = PUBLIC  BEGIN OPEN MB;  -- Syntax for RESIDENT, RESIDENTDESCRIPTOR, IN, and NOTRAP:  --  Resident			::=	RESIDENT : list ;  --  ResidentDescriptor	::=	RESIDENTDESCRIPTOR : list ;  --  In			::=	IN : list ;  --  NoTrap			::=	NOTRAP : moduleList ;  --  list			::=	listItem | list , listItem  --  listItem			::=	configPart | CODE [ configPartList ]  --					GLOBALFRAME [ configPartList ]  --					SPACE [ nameList ] | CODEPACK [ nameList ] |  --					FRAME [ nameList ] | FRAMEPACK [ nameList ] |  --					BCD [ nameList ] |  --  configPartList		::=	configPart | configPartList , configPart  --  configPart		::=	module | configName [ moduleList ]  --  moduleList		::=	module | moduleList , module  --  module			::=	name | name . instance  --  nameList			::=	name | nameList , name    -- Syntax for RESERVEDVM:  --  Reserved			::=	RESERVEDVM : pageGroupList ;  --  pageGroupList		::=	pageGroupList , pageGroup ;  --  pageGroup			::=	[ number , number ]    -- Syntax for FRAMEWEIGHT:  --  Weight			::=	FRAMEWEIGHT : frameWeightValue ;  --  frameWeightValue		::=	number , number ; | number , number , END ;  --					number , number, INDIRECT [ number ] ;    NUL: CHARACTER = Ascii.NUL;  CR: CHARACTER = Ascii.CR;  decimal: MBOut.NumberFormat =    MBOut.NumberFormat[base: 10, unsigned: TRUE, zerofill: FALSE, columns: 1];  data: MB.Handle ¬ NIL;  source: Stream.Handle;  z: UNCOUNTED ZONE ¬ NIL;    noTrapList, vmList: Node;  stateLists: ARRAY ListType OF Node;  -- circularly linked, pointer is to last element  wartConfig, wartModule: Hash;  DoneParsing: SIGNAL = CODE;    Node: TYPE = LONG POINTER TO Item;  Item: TYPE = RECORD [    link: Node,    body: SELECT type: * FROM      name => [name: Hash],      dot => [module, instance: Hash],      config => [name: Hash, list: Node],      space => [list: Node],      frame => [list: Node],      globalframe => [list: Node],      code => [list: Node],      bcd => [list: Node],      vm => [base: MBVM.Base, pages: MBVM.Pages],      ENDCASE];    keywords: ARRAY Keyword OF Symbol;  Keyword: TYPE = {    resident, resDesc, in, frame, framepack, space, codepack, globalFrame, code,    bcd, wart, noTrap, weight, lsModules, lsBcds, mdsbase, codebase,    pdabase, pdapages, framePages, processes, svSize, nSV, all, reservedvm,    end, indirect, gftbase, gft, localFramePages};  Symbol: TYPE = RECORD [    SELECT type: * FROM      hash => [hash: Hash],      sep => [sep: CHARACTER],      ENDCASE];  SemiColon: Symbol = [sep[';]];  Colon: Symbol = [sep[':]];  Comma: Symbol = [sep[',]];  CloseBracket: Symbol = [sep[']]];  OpenBracket: Symbol = [sep['[]];  Dot: Symbol = [sep['.]];  NullSymbol: Symbol = [sep[NUL]];  InputFile: TYPE = LONG POINTER TO InputFileNode;  InputFileNode: TYPE = RECORD [    next: InputFile,    name: LONG STRING,    create: Time.Packed];  inputFiles: InputFile;   -- Bootmesa file parsing   InitParse: PUBLIC PROC [h: MB.Handle] = {    IF data # NIL THEN FinishParse[];    data ¬ h;    CreateHash[2];    EnterKeywords[];    noTrapList ¬ vmList ¬ NIL;    stateLists ¬ ALL[NIL];    wartConfig ¬ wartModule ¬ NullHash;    source ¬ NIL;    inputFiles ¬ NIL;    z ¬ data.z};  FinishParse: PUBLIC PROC = {    DestroyHash[];    data ¬ NIL};      EnterKeywords: PROC = {    names: ARRAY Keyword OF STRING = [      resident: "RESIDENT"L,      resDesc: "RESIDENTDESCRIPTOR"L,      in: "IN"L,      frame: "FRAME"L,      framepack: "FRAMEPACK"L,      space: "SPACE"L,      codepack: "CODEPACK"L,      globalFrame: "GLOBALFRAME"L,      code: "CODE"L,      bcd: "BCD"L,      wart: "WART"L,      noTrap: "NOTRAP"L,      weight: "FRAMEWEIGHT"L,      lsModules: "LOADSTATEMODULES"L,      lsBcds: "LOADSTATEBCDS"L,      mdsbase: "MDSBASE"L,      codebase: "CODEBASE"L,      pdabase: "PDABASE"L,      pdapages: "PDAPAGES"L,      framePages: "FRAMEPAGES"L,      processes: "PROCESSES"L,      svSize: "STATEVECTORSIZE"L,      nSV: "STATEVECTORCOUNT"L,      all: "ALL"L,      reservedvm: "RESERVEDVM"L,      end: "END"L,      indirect: "INDIRECT"L,      gftbase: "GFTBASE"L,      gft: "GFT"L,      localFramePages: "LOCALFRAMEPAGES"L];    FOR key: Keyword IN Keyword DO      keywords[key] ¬ [hash[Lookup[s: names[key], insert: TRUE].h]];      ENDLOOP};        ProcessInput: PUBLIC PROC [file: LONG STRING] = {    ENABLE UNWIND => IF source # NIL THEN {Stream.Delete[source]; source ¬ NIL};    inputFile: InputFile = data.z.NEW[InputFileNode];    inputFile.name ¬ data.z.NEW[StringBody[file.length]];    String.AppendString[inputFile.name, file];    source ¬ MStream.ReadOnly[file, [] !      MStream.Error => Error["Parameter file not found!"L]];    inputFile.create ¬ MFile.GetTimes[MStream.GetFile[source]].create;    indexInSource ¬ 0;    currentChar ¬ Get[];    currentSymbol ¬ NullSymbol;    ParseInput[];    Stream.Delete[source];    source ¬ NIL;    -- put at end of list for printing by EchoInput    IF inputFiles = NIL THEN inputFile.next ¬ inputFile    ELSE {inputFile.next ¬ inputFiles.next; inputFiles.next ¬ inputFile};    inputFiles ¬ inputFile};      EchoInput: PUBLIC PROC = {    OPEN MBOut;    LongOctal: PROC [val: LONG UNSPECIFIED] = INLINE {      LongNumber[val, [8, FALSE, TRUE, 0]]};    EchoList: PROC [tail: Node, topLevel: BOOLEAN ¬ TRUE] = {      KeyToString: PROC [key: Keyword] RETURNS [LONG STRING] = {        WITH keywords[key] SELECT FROM          hash => RETURN[TempString[hash]];          ENDCASE => ERROR};      p: Node ¬ tail;      IF ~topLevel THEN Char['[];      IF p ~= NIL THEN        DO          IF topLevel THEN Spaces[4];          p ¬ p.link;          WITH p SELECT FROM            name => Text[TempString[name]];            dot => {Text[TempString[module]]; Char['.]; Text[TempString[instance]]};            config => {Text[TempString[name]]; EchoList[list, FALSE]};            space => {Text[KeyToString[codepack]]; EchoList[list, FALSE]};            frame => {Text[KeyToString[framepack]]; EchoList[list, FALSE]};            globalframe => {Text[KeyToString[globalFrame]]; EchoList[list, FALSE]};            code => {Text[KeyToString[code]]; EchoList[list, FALSE]};            bcd => {Text[KeyToString[bcd]]; EchoList[list, FALSE]};            vm => {	      Char['[]; LongOctal[base]; Char[',]; SP[]; LongOctal[pages]; Char[']]};	    ENDCASE;          IF p = tail THEN EXIT;          Char[',]; IF topLevel THEN CR[] ELSE SP[];          ENDLOOP;      IF topLevel THEN {Char[';]; CR[]}      ELSE Char[']]};    IF inputFiles ~= NIL THEN {      inputFile: InputFile ¬ inputFiles.next;      Text["Parameter File"L];      IF inputFile ~= inputFiles THEN Char['s];      Char[':]; CR[]; CR[];      DO        Spaces[2]; Text[inputFile.name, 39]; Spaces[2]; 	MBOut.Time[inputFile.create]; CR[];        IF inputFile = inputFiles THEN EXIT;        inputFile ¬ inputFile.next;        ENDLOOP;      CR[]};    Line["Input Parameters:"L]; CR[];    Text["  LoadState modules = "L]; Decimal[data.lsModules]; CR[];    Text["  LoadState bcds = "L]; Decimal[data.lsBcds]; CR[];    Text["  PDA pages = "L]; LongNumber[data.pdaPages, decimal]; CR[];    Text["  Processes = "L]; Decimal[data.nProcesses]; CR[];    Text["  MDS base = page "L]; LongNumber[data.mdsBase, decimal];      Text[" ["L]; LongOctal[data.mdsBase*Environment.wordsPerPage]; Char[']]; CR[];    Text["  Code base = page "L]; LongNumber[data.codeBase, decimal];      Text[" ["L]; LongOctal[data.codeBase*Environment.wordsPerPage]; Char[']]; CR[];    CR[];    Text["  Statevector length = "L]; Decimal[data.svSize]; CR[];    Line["  Statevector counts:"L];    FOR i: CARDINAL IN [0..8) -- Process.Priority-- DO      Number[i, [10, FALSE, FALSE, 6]]; Text[":  "L];      Decimal[data.stateVectorCounts[i]]; CR[];      ENDLOOP;    CR[];    Text["  Frame heap pages = "L]; LongNumber[data.framePages, decimal]; CR[];    Line["  Frame weights:"L];    FOR i: PrincOps.FrameSizeIndex IN PrincOps.FrameSizeIndex DO      listEnd: CARDINAL;      Number[i, [10, FALSE, FALSE, 6]]; Text[" ("L];      Number[PrincOps.frameSizeMap[i], [10,FALSE, FALSE, 4]]; Text[" words):  "L];      Decimal[MB.GetFrameWeight[i]]; Text[", "L];      listEnd ¬ MB.GetFrameListEnd[i];      IF listEnd = 1 THEN Line["end of list"L]      ELSE {        Text["indirect["L]; Decimal[listEnd/4]; Char[']]; CR[]};      ENDLOOP;    CR[];    Text["  Wart: "L]; Text[TempString[wartModule]];    IF wartConfig ~= NullHash THEN {      Text[" in configuration "L]; Text[TempString[wartConfig]]};    CR[]; CR[];    Line["  Resident:"L]; EchoList[stateLists[resident]]; CR[];    Line["  Resident Descriptor:"L]; EchoList[stateLists[resDesc]]; CR[];    Line["  Initially In:"L]; EchoList[stateLists[in], TRUE]; CR[];    Line["  No Trap:"L]; EchoList[noTrapList, TRUE]; CR[];    Line["  Reserved VM:"L]; EchoList[vmList, TRUE]; CR[];    CR[]};  ParseInput: PROC = {    DO      SELECT GetKeyword[ ! DoneParsing => EXIT] FROM        gft => {	  gft: CARDINAL ¬ GetNumber[];	  IF Scan[] # SemiColon THEN BadNumber[gft];	  data.nGFTs ¬ gft;	  };        gftbase => {	  gftBase: CARDINAL ¬ GetNumber[];	  IF Scan[] # SemiColon THEN BadNumber[gft];	  data.gftBase ¬ gftBase;	  };	lsModules => {	  count: CARDINAL ¬ GetNumber[];	  IF Scan[] # SemiColon THEN BadNumber[lsModules];	  IF data.lsModules = LAST[CARDINAL] THEN data.lsModules ¬ count};	lsBcds => {	  count: CARDINAL ¬ GetNumber[];	  IF Scan[] # SemiColon THEN BadNumber[lsBcds];	  IF data.lsBcds = LAST[CARDINAL] THEN data.lsBcds ¬ count};	mdsbase => {	  base: CARDINAL ¬ GetNumber[];	  IF Scan[] # SemiColon THEN BadNumber[mdsbase];	  data.mdsBase ¬ base};	codebase => {	  base: CARDINAL ¬ GetNumber[];	  IF Scan[] # SemiColon THEN BadNumber[codebase];	  data.codeBase ¬ base};	framePages => {	  pages: CARDINAL ¬ GetNumber[];	  IF Scan[] # SemiColon THEN BadNumber[framePages];	  data.framePages ¬ pages};	localFramePages => {	  pages: CARDINAL ¬ GetNumber[];	  IF Scan[] # SemiColon THEN BadNumber[localFramePages];	  data.localFramePages ¬ pages};	pdabase => {  -- unused	  pages: CARDINAL ¬ GetNumber[];	  IF Scan[] # SemiColon THEN BadNumber[pdabase]};	pdapages => {	  pages: CARDINAL ¬ GetNumber[];	  IF Scan[] # SemiColon THEN BadNumber[pdapages];	  data.pdaPages ¬ pages};	processes => {	  number: CARDINAL ¬ GetNumber[];	  IF Scan[] # SemiColon THEN BadNumber[processes];	  IF data.nProcesses = LAST[CARDINAL] THEN data.nProcesses ¬ number};	nSV => {	  count: CARDINAL;	  svIndex: CARDINAL ¬ GetNumber[];	  GetRequiredSep[Comma];      	  count ¬ GetNumber[];          GetRequiredSep[SemiColon];	  data.stateVectorCounts[svIndex] ¬ count};	svSize => {	  number: CARDINAL ¬ GetNumber[];	  IF GetSep[] # SemiColon THEN BadNumber[svSize];	  data.svSize ¬ number};	weight => {	  weight: CARDINAL;	  frameIndex: CARDINAL ¬ GetNumber[];          sep: Symbol;	  GetRequiredSep[Comma];	  weight ¬ GetNumber[];          sep ¬ GetSep[];	  SELECT sep FROM	    SemiColon => NULL;	    Comma => {	      end: CARDINAL;	      sep ¬ GetSym[];	      SELECT sep FROM	        keywords[end] => end ¬ 1;		keywords[indirect] => {		  GetRequiredSep[OpenBracket];		  end ¬ GetNumber[]*4+2;		  GetRequiredSep[CloseBracket]};	        ENDCASE => ErrorMsg["Unexpected keyword '%' found"L, sep];	      GetRequiredSep[SemiColon];	      MB.SetFrameListEnd[index: frameIndex, end: end]};	    ENDCASE => ErrorMsg["Expected separator '%' not found"L, sep];	  MB.SetFrameWeight[index: frameIndex, weight: weight]};	reservedvm => {	  vmList ¬ GetVMList[vmList];          GetRequiredSep[SemiColon]};	wart => {	  id: hash Symbol ¬ GetSym[];          sep: Symbol = GetSep[];          SELECT sep FROM	    SemiColon => {wartConfig ¬ NullHash; wartModule ¬ id.hash};	    OpenBracket => {	      wartConfig ¬ id.hash;	      id ¬ GetSym[];              GetRequiredSep[CloseBracket];              GetRequiredSep[SemiColon];	      wartModule ¬ id.hash};	    ENDCASE => SyntaxError[wart]};	resident => {          stateLists[resident] ¬ GetGeneralList[stateLists[resident]];          GetRequiredSep[SemiColon]};        resDesc => {          stateLists[resDesc] ¬ GetGeneralList[stateLists[resDesc]];          GetRequiredSep[SemiColon]};        in => {          stateLists[in] ¬ GetGeneralList[stateLists[in]];          GetRequiredSep[SemiColon]};        noTrap => {          noTrapList ¬ GetModuleList[noTrapList];          GetRequiredSep[SemiColon]};	ENDCASE;      ENDLOOP};  GetKeyword: PROC RETURNS [key: Keyword] = {    sym: Symbol ¬ Scan[];    IF sym = [sep[NUL]] THEN SIGNAL DoneParsing;    IF GetSep[] # Colon THEN ErrorMsg["No colon following keyword '%'"L, sym];    FOR key IN Keyword DO IF sym = keywords[key] THEN RETURN[key]; ENDLOOP;    ErrorMsg["Unrecognizable keyword '%'"L, sym]};  GetNumber: PROC RETURNS [number: CARDINAL] = {    sym: hash Symbol ¬ GetSym[];    number ¬ String.StringToDecimal[TempString[sym.hash] !      String.InvalidNumber => ErrorMsg["'%' should be numeric"L, sym]]};        GetRequiredSep: PROC [esep: Symbol] = {    sep: Symbol = GetSep[];    IF sep ~= esep THEN ErrorMsg["Expected separator '%' not found"L, esep]};  GetSym: PROC RETURNS [h: hash Symbol] = {    sym: Symbol ¬ Scan[];    WITH s: sym SELECT FROM       hash => RETURN[s];       ENDCASE => ErrorMsg["Separator '%' not permitted"L, sym]};  GetSep: PROC RETURNS [sep: sep Symbol] = {    sym: Symbol ¬ Scan[];    WITH s: sym SELECT FROM       sep => RETURN[s];       ENDCASE => ErrorMsg["Missing separator preceding '%'"L, sym]};  GetGeneralList: PROC [oldList: Node] RETURNS [list: Node] = {    list ¬ oldList;    DO      sep: sep Symbol;      list ¬ AppendNode[list, GetListItem[]];      IF (sep ¬ GetSep[]) ~= Comma THEN {BackupScan[sep]; EXIT};      ENDLOOP};  GetListItem: PROC RETURNS [item: Node] = {    sym: Symbol = GetSym[];    SELECT sym FROM      keywords[space], keywords[codepack] =>        item ¬ z.NEW[Item ¬ [link: NIL, body: space[list: GetBracketedNameList[]]]];      keywords[frame], keywords[framepack] =>        item ¬ z.NEW[Item ¬ [link: NIL, body: frame[list: GetBracketedNameList[]]]];      keywords[bcd] =>        item ¬ z.NEW[Item ¬ [link: NIL, body: bcd[list: GetBracketedNameList[]]]];      keywords[globalFrame] =>        item ¬ z.NEW[Item ¬ [link: NIL, body: globalframe[list: GetBracketedConfigPartList[]]]];      keywords[code] =>        item ¬ z.NEW[Item ¬ [link: NIL, body: code[list: GetBracketedConfigPartList[]]]];      ENDCASE => {BackupScan[sym]; item ¬ GetConfigPart[]}};        GetBracketedConfigPartList: PROC RETURNS [list: Node] = {    GetRequiredSep[OpenBracket];    list ¬ GetConfigPartList[];    GetRequiredSep[CloseBracket]};        GetConfigPartList: PROC RETURNS [list: Node] = {    list ¬ NIL;    DO      sep: sep Symbol;      list ¬ AppendNode[list, GetConfigPart[]];      IF (sep ¬ GetSep[]) ~= Comma THEN {BackupScan[sep]; EXIT};      ENDLOOP};        GetConfigPart: PROC RETURNS [item: Node] = {    sym: hash Symbol = GetSym[];    sep: Symbol = GetSep[];    IF sep = OpenBracket THEN {      item ¬ z.NEW[Item ¬ [link: NIL, body: config[name: sym.hash, list: GetModuleList[]]]];      GetRequiredSep[CloseBracket]}    ELSE {BackupScan[sep]; item ¬ GetModule[first: sym]}};      GetModuleList: PROC [oldList: Node ¬ NIL] RETURNS [list: Node] = {    list ¬ oldList;    DO      sep: sep Symbol;      list ¬ AppendNode[list, GetModule[]];      IF (sep ¬ GetSep[]) ~= Comma THEN {BackupScan[sep]; EXIT};      ENDLOOP};      GetModule: PROC [first: Symbol ¬ NullSymbol] RETURNS [node: Node] = {    sep: sep Symbol;    IF first = NullSymbol THEN first ¬ GetSym[];    WITH module: first SELECT FROM      hash =>        IF (sep ¬ GetSep[]) = Dot THEN          node ¬ z.NEW[Item ¬ [	    link: NIL, body: dot[module: module.hash, instance: GetSym[].hash]]]        ELSE {	  BackupScan[sep];	  node ¬ z.NEW[Item ¬ [link: NIL, body: name[name: module.hash]]]};      ENDCASE => ERROR};    GetBracketedNameList: PROC RETURNS [list: Node] = {    GetRequiredSep[OpenBracket];    list ¬ GetNameList[];    GetRequiredSep[CloseBracket]};      GetNameList: PROC RETURNS [list: Node] = {    list ¬ NIL;    DO      sep: sep Symbol;      list ¬ AppendNode[list, GetName[]];      IF (sep ¬ GetSep[]) ~= Comma THEN {BackupScan[sep]; EXIT};      ENDLOOP};      GetName: PROC RETURNS [Node] = {      RETURN[z.NEW[Item ¬ [link: NIL, body: name[name: GetSym[].hash]]]]};      AppendNode: PROC [list: Node, node: Node] RETURNS [newList: Node] = {    IF list = NIL THEN node.link ¬ node    ELSE {node.link ¬ list.link; list.link ¬ node};    RETURN[node]};      GetVMList: PROC [oldList: Node] RETURNS [list: Node] = {    list ¬ oldList;    DO      sep: sep Symbol;      list ¬ AppendNode[list, GetVMItem[]];      IF (sep ¬ GetSep[]) ~= Comma THEN {BackupScan[sep]; EXIT};      ENDLOOP};  GetVMItem: PROC RETURNS [item: Node] = {    base: MBVM.Base;    pages: MBVM.Pages;    GetRequiredSep[OpenBracket];    base ¬ GetNumber[];    GetRequiredSep[Comma];    pages ¬ GetNumber[];    GetRequiredSep[CloseBracket];    RETURN[z.NEW[Item ¬ [link: NIL, body: vm[base: base, pages: pages]]]]};        -- Lexical Analysis  indexInSource: CARDINAL;  currentChar: CHARACTER;  currentSymbol: Symbol;  Scan: PROC RETURNS [sym: Symbol] = {    char: CHARACTER ¬ currentChar;    s: STRING ¬ [100];    IF currentSymbol ~= NullSymbol THEN {      sym ¬ currentSymbol; currentSymbol ¬ NullSymbol; RETURN};    DO      WHILE char IN [NUL..' ] DO	SELECT char FROM	  Ascii.ControlZ =>	    DO SELECT Get[] FROM NUL => GOTO eof; CR => EXIT; ENDCASE ENDLOOP;	  NUL => GOTO eof;	  ENDCASE;	char ¬ Get[];	ENDLOOP;      SELECT char FROM	IN ['a..'z], IN ['A..'Z], IN ['0..'9] => {	  s.length ¬ 0;	  String.AppendChar[s, char];	  DO	    char ¬ Get[];	    SELECT char FROM	      IN ['a..'z], IN ['A..'Z], IN ['0..'9] =>		String.AppendChar[s, char];	      ENDCASE => EXIT;	    ENDLOOP;	  sym ¬ [hash[Lookup[s: s, insert: TRUE].h]];	  EXIT};	'., '[, '], ':, ';, ', => {sym ¬ [sep[char]]; char ¬ Get[]; EXIT};	'- => {	  IF (char ¬ Get[]) # '- THEN InvalidCharacter[char];	  DO	    SELECT char ¬ Get[] FROM	      NUL => GOTO eof;	      '- => IF (char ¬ Get[]) = '- THEN EXIT;	      CR => EXIT;	      ENDCASE;	    ENDLOOP;	  char ¬ Get[]};	ENDCASE => InvalidCharacter[char];      REPEAT eof => sym ¬ [sep[NUL]];      ENDLOOP;    currentChar ¬ char};  BackupScan: PROC [sym: Symbol] = {    IF currentSymbol ~= NullSymbol THEN ERROR;    currentSymbol ¬ sym};  Get: PROC RETURNS [c: CHARACTER] = {    c ¬ Stream.GetChar[source ! Stream.EndOfStream => GO TO fakeIt];    indexInSource ¬ indexInSource + 1;    EXITS      fakeIt => RETURN[NUL]}; -- Symbol management  parseTable: PRIVATE Base ¬ NIL;  Base: TYPE = LONG BASE POINTER TO HashRegion;  HashRegion: TYPE = RECORD [    hVec: ARRAY [0..HVSize) OF Hash,    nPages: CARDINAL,    caseHeed: BOOLEAN,    nextAvail: Hash,    firstAvail: HashBlock    -- as many more HashBlocks as will fit in nPages    ];    Hash: TYPE = Base RELATIVE ORDERED POINTER [0..37777B] TO HashBlock;  HashBlock: TYPE = RECORD [    next: Hash,    string: StringBody];      NullHash: Hash = LOOPHOLE[0];  FirstAvailSlot: Hash = LOOPHOLE[HVSize + 3];  --@firstAvail  HVSize: CARDINAL = 71;    Lookup: PROC [s: STRING, insert: BOOLEAN] RETURNS [h: Hash, old: BOOLEAN] = {    i: [0..HVSize) ¬ HashFn[s];    h ¬ parseTable.hVec[i];    WHILE h # NullHash DO      IF String.EqualString[s, @parseTable[h].string] THEN RETURN [h, TRUE];      h ¬ parseTable[h].next;      ENDLOOP;    IF insert THEN parseTable.hVec[i] ¬ h ¬ NewEntry[s, parseTable.hVec[i]]    ELSE h ¬ NullHash;    RETURN[h, FALSE]};      HashFn: PROC [s: STRING] RETURNS [[0..HVSize)] = {    CharBits: PROC [CHARACTER, WORD] RETURNS [WORD] = LOOPHOLE[Inline.BITAND];    Mask: WORD = 337B;                -- masks out ASCII case shifts    n: CARDINAL = s.length;    v: WORD  ¬ CharBits[s[0], Mask]*177B + CharBits[s[n-1], Mask];    RETURN[Inline.BITXOR[v, n*17B] MOD HVSize]};      NewEntry: PROC [s: STRING, next: Hash] RETURNS [h: Hash] = {    w: CARDINAL = SIZE[HashBlock] + (s.length+1)/2;    IF LOOPHOLE[parseTable.nextAvail+w, CARDINAL] >     parseTable.nPages*Environment.wordsPerPage THEN {  -- make more space      np, nw: CARDINAL;      oldData: Base ¬ parseTable;      np ¬ oldData.nPages + MAX[MBStorage.PagesForWords[w], 2];      nw ¬ LOOPHOLE[oldData.nextAvail];      parseTable.nPages ¬ np; -- so the COPY doesn't smash new value      parseTable ¬ NIL; -- so Create doesn't throw away old      CreateHash[np];      Inline.LongCOPY[from: oldData, to: parseTable, nwords: nw];      MBStorage.FreePages[oldData]};    h ¬ parseTable.nextAvail; parseTable.nextAvail ¬ parseTable.nextAvail+w;    parseTable[h] ¬ [next: next, string: [length: 0, maxlength: s.length, text:]];    String.AppendString[@parseTable[h].string, s]};        CreateHash: PROC [nPages: CARDINAL] = {    IF parseTable # NIL THEN DestroyHash[];    parseTable ¬ MBStorage.Pages[nPages];    parseTable.nPages ¬ nPages;    FOR i: CARDINAL IN [0..HVSize) DO parseTable.hVec[i] ¬ NullHash; ENDLOOP;    parseTable.nextAvail ¬ FirstAvailSlot};      DestroyHash: PROC = {    MBStorage.FreePages[parseTable];    parseTable ¬ NIL};      TempString: PROC [h: Hash] RETURNS [LONG STRING] = {    RETURN[@parseTable[h].string]};         -- Error processing  SyntaxError: PROC [key: Keyword] = {    ErrorMsg["Bad specification for '%'"L, keywords[key]]};  BadNumber: PROC [key: Keyword] = {    ErrorMsg["Bad numeric value for '%'"L, keywords[key]]};  InvalidCharacter: PROC [c: CHARACTER] = {    ErrorMsg["'%' is an invalid character"L, [sep[c]]]};  ErrorMsg: PROC [msg: STRING, sym: Symbol] = {    Opening[];    FOR i: CARDINAL IN [0..msg.length) DO      c: CHARACTER = msg[i];      SELECT c FROM        '% =>          WITH sym SELECT FROM            hash => PutHash[hash];            sep => MBTTY.PutChar[h: data.ttyHandle, c: sep];            ENDCASE;        ENDCASE => MBTTY.PutChar[h: data.ttyHandle, c: c];      ENDLOOP;    Closing[]};  Opening: PROC = {    MBTTY.PutString[h: data.ttyHandle, s: "\n!Syntax Error ["L];    MBTTY.PutDecimal[h: data.ttyHandle, n: indexInSource];    MBTTY.PutString[h: data.ttyHandle, s: "]: "L]};      Closing: PROC = {    MBTTY.PutCR[h: data.ttyHandle];    SIGNAL MB.Abort};      PutHash: PROC [hash: Hash] = {    MBTTY.PutString[      h: data.ttyHandle, s: IF hash ~= NullHash THEN TempString[hash] ELSE "???"L]};             -- Bootmesa file interrogation   WartMTH: PUBLIC PROC RETURNS [bh: MB.BHandle, mth: BcdOps.MTHandle] = {    IF wartConfig # NullHash THEN MB.SetConfig[TempString[wartConfig]];    [bh, mth] ¬ MB.NameToMTHandle[TempString[wartModule]];    MB.ResetConfig[]};  EnumerateCode: PUBLIC PROC [      state: ListType,       proc: PROC [bh: BHandle, mth: BcdOps.MTHandle] RETURNS [BOOLEAN]] = {    PackageableOnly: PROC [bh: BHandle, mth: BcdOps.MTHandle] RETURNS [BOOLEAN] = {      RETURN[IF mth.packageable THEN proc[bh, mth] ELSE FALSE]};    [] ¬ DoModules[stateLists[state], PackageableOnly]};  EnumerateGlobalFrames: PUBLIC PROC [      state: ListType,       proc: PROC [bh: BHandle, mth: BcdOps.MTHandle] RETURNS [BOOLEAN]] = {    PackageableOnly: PROC [bh: BHandle, mth: BcdOps.MTHandle] RETURNS [BOOLEAN] = {      RETURN[IF mth.packageable THEN proc[bh, mth] ELSE FALSE]};    p: Node ¬ stateLists[state];    IF p ~= NIL THEN      DO        p ¬ p.link;        WITH p SELECT FROM          globalframe => IF DoModules[list, PackageableOnly] THEN EXIT;          ENDCASE;        IF p = stateLists[state] THEN EXIT;        ENDLOOP};      EnumerateFramePacks: PUBLIC PROC [      state: ListType,       proc: PROC [bh: BHandle, fph: BcdOps.FPHandle] RETURNS [BOOLEAN]] = {    p: Node ¬ stateLists[state];    IF p ~= NIL THEN      DO        p ¬ p.link;        WITH p SELECT FROM          frame => {            PassItOn: PROC [name: LONG STRING] RETURNS [BOOLEAN] = {              bh: BHandle;              fph: BcdOps.FPHandle;              IF String.EqualString[name, "ALL"L] THEN {                [] ¬ DoAllFramePacks[proc]; RETURN[TRUE]};              [bh: bh, fph: fph] ¬ NameToFPHandle[name];              RETURN[proc[bh, fph]]};            IF DoNames[list, PassItOn] THEN EXIT};          ENDCASE;        IF p = stateLists[state] THEN EXIT;        ENDLOOP};	        EnumerateSpaces: PUBLIC PROC [      state: ListType,       proc: PROC [bh: BHandle, sph: BcdOps.SPHandle, index: CARDINAL] RETURNS [BOOLEAN]] = {    p: Node ¬ stateLists[state];    IF p ~= NIL THEN      DO        p ¬ p.link;        WITH p SELECT FROM          space => {            PassItOn: PROC [name: LONG STRING] RETURNS [BOOLEAN] = {              bh: BHandle;              sph: BcdOps.SPHandle;              index: CARDINAL;              IF String.EqualString[name, "ALL"L] THEN {                [] ¬ DoAllSpaces[proc]; RETURN[TRUE]};              [bh: bh, sph: sph, index: index] ¬ NameToSPHandle[name];              RETURN[proc[bh, sph, index]]};            IF DoNames[list, PassItOn] THEN EXIT};           ENDCASE;         IF p = stateLists[state] THEN EXIT;         ENDLOOP};	        EnumerateBCDs: PUBLIC PROC [      state: ListType,       proc: PROC [bh: BHandle] RETURNS [BOOLEAN]] = {    p: Node ¬ stateLists[state];    IF p ~= NIL THEN      DO        p ¬ p.link;        WITH p SELECT FROM          bcd => {            PassItOn: PROC [name: LONG STRING] RETURNS [BOOLEAN] = {              IF String.EqualString[name, "ALL"L] THEN {                [] ¬ DoAllBCDs[proc]; RETURN[TRUE]};              RETURN[proc[NameToCTHandle[name].bh]]};            IF DoNames[list, PassItOn] THEN EXIT};          ENDCASE;        IF p = stateLists[state] THEN EXIT;        ENDLOOP};	  EnumerateNoTrapModules: PUBLIC PROC [      proc: PROC [bh: BHandle, mth: BcdOps.MTHandle] RETURNS [BOOLEAN]] = {    [] ¬ DoModules[noTrapList, proc]};      DoModules: PROC [      tail: Node,       proc: PROC [bh: BHandle, mth: BcdOps.MTHandle] RETURNS [BOOLEAN]]    RETURNS [stopped: BOOLEAN] = {    p: Node ¬ tail;    stopped ¬ TRUE;    IF p = NIL THEN RETURN[FALSE];    DO      bh: MB.BHandle;      mth: BcdOps.MTHandle;      p ¬ p.link;      WITH p SELECT FROM        name =>          IF Symbol[hash[name]] = keywords[all] THEN {            IF MB.DoAllModules[proc] THEN RETURN}          ELSE {            [bh: bh, mth: mth] ¬ NameToMTHandle[TempString[name]];            IF proc[bh, mth] THEN RETURN};        dot => {          [bh: bh, mth: mth] ¬ InstanceToMTHandle[            module: TempString[module], instance: TempString[instance]];          IF proc[bh, mth] THEN RETURN};        config => {          done: BOOLEAN;          MB.SetConfig[TempString[name]];          -- The syntax equations ensure that we will not recur under the          -- following call of DoModules.  This is important since SetConfig          -- and ResetConfig do not follow a stack discipline.          done ¬ DoModules[list, proc];          MB.ResetConfig[];          IF done THEN RETURN};        code =>          IF DoModules[list, proc] THEN RETURN;        ENDCASE;  -- skip over space, frame, globalframe, bcd      IF p = tail THEN EXIT;      ENDLOOP;    RETURN[FALSE]};        DoNames: PROC [tail: Node, proc: PROC [name: LONG STRING] RETURNS [BOOLEAN]]    RETURNS [BOOLEAN] = {    p: Node ¬ tail;    IF p ~= NIL THEN      DO        p ¬ p.link;        WITH p SELECT FROM          name => IF proc[TempString[name]] THEN RETURN[TRUE];          ENDCASE => ERROR;        IF p = tail THEN EXIT;        ENDLOOP;    RETURN[FALSE]};        EnumerateReservedMemory: PUBLIC PROC [      proc: PROC [base: MBVM.Base, pages: MBVM.Pages] RETURNS [BOOLEAN]] = {    p: Node ¬ vmList;    IF p ~= NIL THEN      DO        p ¬ p.link;        WITH p SELECT FROM          vm => IF proc[base: base, pages: pages] THEN RETURN;          ENDCASE => ERROR;        IF p = vmList THEN EXIT;        ENDLOOP};      END.
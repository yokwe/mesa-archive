-- Copyright (C) 1981, 1982, 1983  by Xerox Corporation. All rights reserved. -- MBCache.mesa   --   Sandman	20-Jul-82  9:24:46--   Lewis	17-Sep-81 11:50:33--   Davirro	20-Jul-83 16:57:18--   Johnsson	18-Sep-83 16:57:03DIRECTORY  Environment USING [wordsPerPage],  Inline USING [LongCOPY, LongDivMod, LongMult],  MB USING [Handle, Zero],  MBVM USING [Base],  MBStorage USING [FreeWords, Words];MBCache: PROGRAM    IMPORTS Inline, MBStorage, MB    EXPORTS MB, MBVM =  BEGIN    PageSize: CARDINAL = Environment.wordsPerPage;  Increment: CARDINAL = PageSize/SIZE[CSElement];  csArray: CSArray;  CSArray: TYPE = LONG DESCRIPTOR FOR ARRAY OF CSElement;  CSElement: TYPE = RECORD [    lp: LONG POINTER,    page: LONG CARDINAL];  data: MB.Handle ¬ NIL;  csElements: CARDINAL;  cachePage: LONG CARDINAL;  cacheLP: LONG POINTER;    InitCache: PUBLIC PROC [h: MB.Handle] = {    IF data # NIL THEN FinishCache[];    data ¬ h;    csArray ¬ DESCRIPTOR[MBStorage.Words[Increment*SIZE[CSElement]], Increment];    csArray[0] ¬ [page: 0, lp: MBStorage.Words[PageSize]];    csArray[1] ¬ [page: LAST[CARDINAL], lp: NIL];    csElements ¬ 2;    cachePage ¬ LAST[LONG CARDINAL];    cacheLP ¬ NIL};  FinishCache: PUBLIC PROC = {    FOR i: CARDINAL IN [0..csElements) DO      MBStorage.FreeWords[csArray[i].lp] ENDLOOP;    MBStorage.FreeWords[BASE[csArray]];    data ¬ NIL};      GetPage: PUBLIC PROC [    page: MBVM.Base, create: BOOLEAN ¬ TRUE] RETURNS [LONG POINTER] = {    i, j, h: CARDINAL;    IF page = cachePage THEN RETURN[cacheLP];    IF page = 0 THEN {cachePage ¬ page;  RETURN[cacheLP ¬ csArray[0].lp]};    i ¬ 0;  j ¬ csElements-1;    UNTIL i + 1 = j DO      h ¬ (i+j)/2;      SELECT csArray[h].page FROM        < page => i ¬ h;	> page => j ¬ h;	ENDCASE => {  -- found at h	  cachePage ¬ page;  	  cacheLP ¬ csArray[h].lp;	  RETURN[cacheLP]};      ENDLOOP;    IF ~create THEN RETURN[NIL];    IF csElements = LENGTH[csArray] THEN ExpandArray[];    FOR k: CARDINAL DECREASING IN [i+1..csElements) DO      csArray[k+1] ¬ csArray[k];      ENDLOOP;    cachePage ¬ page;    MB.Zero[p: cacheLP ¬ MBStorage.Words[PageSize], n: PageSize];    csArray[i+1] ¬ [lp: cacheLP, page: cachePage];    csElements ¬ csElements+1;    RETURN[cacheLP]};  ExpandArray: PROC = {    newLength: CARDINAL = (LENGTH[csArray] + Increment);    newArray: CSArray ¬       DESCRIPTOR[MBStorage.Words[newLength*SIZE[CSElement]], newLength];    Inline.LongCOPY[      from: BASE[csArray], to: BASE[newArray],       nwords: LENGTH[csArray]*SIZE[CSElement]];    MBStorage.FreeWords[BASE[csArray]];    csArray ¬ newArray};      Read: PUBLIC PROC [p: POINTER] RETURNS [UNSPECIFIED] = {    RETURN[      LongRead[        Inline.LongMult[	  CARDINAL[data.mdsBase], PageSize] + LOOPHOLE[p, CARDINAL]]]};    Write: PUBLIC PROC [p: POINTER, v: UNSPECIFIED] = {    LongWrite[      Inline.LongMult[        CARDINAL[data.mdsBase], PageSize] + LOOPHOLE[p, CARDINAL], v]};  CopyRead: PUBLIC PROC [from: POINTER, to: LONG POINTER, nwords: CARDINAL] = {    FOR i: CARDINAL IN [0..nwords) DO (to+i)­ ¬ Read[from+i] ENDLOOP};  CopyWrite: PUBLIC PROC [from: LONG POINTER, to: POINTER, nwords: CARDINAL] = {    FOR i: CARDINAL IN [0..nwords) DO Write[to+i, (from+i)­] ENDLOOP};      LongRead: PUBLIC PROC [p: LONG UNSPECIFIED] RETURNS [UNSPECIFIED] = {    memPage: MBVM.Base;    offset: CARDINAL;    [quotient: memPage, remainder: offset] ¬ Inline.LongDivMod[      LOOPHOLE[p], PageSize];    RETURN[(GetPage[memPage]+offset)­]};  LongWrite: PUBLIC PROC [p: LONG UNSPECIFIED, v: UNSPECIFIED] = {    memPage: MBVM.Base;    offset: CARDINAL;    [quotient: memPage, remainder: offset] ¬ Inline.LongDivMod[      LOOPHOLE[p], PageSize];    (GetPage[memPage]+offset)­ ¬ v};      LongCopyRead: PUBLIC PROC [      from: LONG POINTER, to: LONG POINTER, nwords: CARDINAL] = {    FOR i: CARDINAL IN [0..nwords) DO (to+i)­ ¬ LongRead[from+i] ENDLOOP};  LongCopyWrite: PUBLIC PROC [      from: LONG POINTER, to: LONG POINTER, nwords: CARDINAL] = {    FOR i: CARDINAL IN [0..nwords) DO LongWrite[to+i, (from+i)­] ENDLOOP};  END.
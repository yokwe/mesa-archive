-- MBLoadStateImpl.mesa-- BGY 	24-Jul-86 13:26:42-- Copyright (C) 1986  by Xerox Corporation. All rights reserved. DIRECTORY  LoadStateFormat,  LoadState,  LoadedMem,  MB,  MBLoaderOps,  PrincOps,  PrincOpsExtras2;MBLoadStateImpl: PROGRAM  IMPORTS LoadedMem, MB, MBLoaderOps, PrincOpsExtras2  EXPORTS LoadState = {    TablesFull: PUBLIC --LoadState.-- ERROR [    totalBcdsNeeded, totalModulesNeeded: CARDINAL] = CODE;  countModuleInfoPad: CARDINAL = 1;  NoGlobalFrameSlots: PUBLIC ERROR = CODE;    EnterGlobalFrame: PUBLIC PROC[    frame: PrincOpsExtras2.LongGlobalFrameHandle,     codebase: PrincOps.GlobalCodebase]    RETURNS [gfi: PrincOpsExtras2.GFTHandle] = {    data: MB.Handle ¬ MB.GetData[];    index: PrincOpsExtras2.GFTIndex ¬ data.lastgfti;    gfi ¬ PrincOpsExtras2.GFTIndexToHandle[data.lastgfti];    IF index = PrincOpsExtras2.nullGFI THEN NoGlobalFrameSlots;    data.lastgfti ¬ PrincOpsExtras2.GFTHandleToIndex[data.gft[index].next];    data.gft[index] ¬ [inuse[globalFrame: frame, codebase: codebase]];    };      RemoveGlobalFrame: PUBLIC PROC[    frame: PrincOpsExtras2.LongGlobalFrameHandle] = {    };      LockBcdInfo: PUBLIC PROC    RETURNS [loadState: LoadStateFormat.Handle, bcdInfo: LoadState.LPBcdInfoTable]={    --  locking for makeboot not necessary    [loadState, bcdInfo] ¬ GetBcdInfo[];     };      GetBcdInfo:  PROC    RETURNS [loadState: LoadStateFormat.Handle, bcdInfo: LoadState.LPBcdInfoTable]={    loadState ¬ MBLoaderOps.GetLoadState[];    bcdInfo ¬ LOOPHOLE[MBLoaderOps.GetBcds[]];    };      UnlockBcdInfo: PUBLIC PROCEDURE  = {-- no locking -- };    ExpandTablesInternal: PUBLIC PROC[totalBcdsNeeded, totalModulesNeeded: CARDINAL]    RETURNS [loadState: LoadStateFormat.Handle,       bcdInfo: LoadState.LPBcdInfoTable] = {    MBLoaderOps.GrowLoadState[      nModules: totalModulesNeeded, nBcds: totalBcdsNeeded];    [loadState, bcdInfo] ¬ GetBcdInfo[];    };      EnterModuleInfos: PUBLIC PROC[    moduleInfoSeq: LoadState.ModuleInfoSequenceHandle] = {    loadState: LoadStateFormat.Handle  ¬ MBLoaderOps.GetLoadState[];    IF loadState.nModules + moduleInfoSeq.length + countModuleInfoPad >      loadState.maxModules THEN      RETURN WITH ERROR TablesFull[   -- must end with >= one free slot.        totalBcdsNeeded: loadState.nBcds,	totalModulesNeeded: loadState.nModules + moduleInfoSeq.length];    FOR i: CARDINAL IN [0..moduleInfoSeq.length) DO      MBLoaderOps.EnterModule[moduleInfoSeq[i]];      ENDLOOP;    };      GetModuleInfo: PUBLIC PROC[gfi: PrincOpsExtras2.GFTHandle]    RETURNS [info: LoadStateFormat.ModuleInfo] = {    info ¬ MBLoaderOps.GetModule[gfi];    };      GFFromBcdInfo: PUBLIC PROC[    cgfi: NATURAL, bcdIndex: LoadState.BcdInfoIndex]     RETURNS [gfi: PrincOpsExtras2.GFTHandle] = {    gf: PrincOpsExtras2.LongGlobalFrameHandle;    CompareBcdInfo: PROC [mi: LoadStateFormat.ModuleInfo] RETURNS [BOOLEAN] = {      IF mi.index = bcdIndex AND mi.cgfi = cgfi THEN RETURN[TRUE];      RETURN[FALSE];      };    gf ¬ MBLoaderOps.EnumerateModules[CompareBcdInfo];    gfi ¬ LoadedMem.GFTHandleFromGlobalFrame[gf];    };      MarkModuleResolved: PUBLIC PROC[    gfi: PrincOpsExtras2.GFTHandle, value: BOOLEAN] = {    gf: PrincOpsExtras2.LongGlobalFrameHandle ¬       LoadedMem.GlobalFrameFromGFTHandle[gfi];    MBLoaderOps.SetResolved[gf, value];    };  OriginalModule: PUBLIC PROC[gfi: PrincOpsExtras2.GFTHandle]    RETURNS [originalGFI: PrincOpsExtras2.GFTHandle] = {    -- can't NEW here    RETURN[gfi];    };      RemoveModuleInfos: PUBLIC PROC[bcdIndex: LoadState.BcdInfoIndex] = {    -- shouldn't be called during MakeBoot time    };      UnresolvedModuleInfosOfBcd: PUBLIC PROC[    bcdIndex: LoadState.BcdInfoIndex, zone: UNCOUNTED ZONE]    RETURNS [moduleInfoSeq: LoadState.ModuleInfoSequenceHandle] = {    count: CARDINAL ¬ 0;    i: CARDINAL ¬ 0;    CountThem: PROC [mi: LoadStateFormat.ModuleInfo] RETURNS [BOOLEAN] = {      IF mi.index = bcdIndex AND ~ mi.resolved THEN count ¬ count + 1;      RETURN[FALSE];      };    FillThem: PROC [mi: LoadStateFormat.ModuleInfo] RETURNS [BOOLEAN] = {      IF mi.index = bcdIndex AND ~ mi.resolved THEN {        moduleInfoSeq[i] ¬ mi;	i ¬ i + 1};      RETURN[FALSE];      };    [] ¬ MBLoaderOps.EnumerateModules[CountThem];    IF count = 0 THEN RETURN [NIL];    moduleInfoSeq ¬ zone.NEW[LoadState.ModuleInfoSequence[count]];    [] ¬ MBLoaderOps.EnumerateModules[FillThem];    moduleInfoSeq.length ¬ count;    };      ModuleInfosOfBcd: PUBLIC PROC[    bcdIndex: LoadState.BcdInfoIndex, zone: UNCOUNTED ZONE]    RETURNS [moduleInfoSeq: LoadState.ModuleInfoSequenceHandle] = {    count: CARDINAL ¬ 0;    i: CARDINAL ¬ 0;    CountThem: PROC [mi: LoadStateFormat.ModuleInfo] RETURNS [BOOLEAN] = {      IF mi.index = bcdIndex THEN count ¬ count + 1;      RETURN[FALSE];      };    FillThem: PROC [mi: LoadStateFormat.ModuleInfo] RETURNS [BOOLEAN] = {      IF mi.index = bcdIndex THEN {        moduleInfoSeq[i] ¬ mi;	i ¬ i + 1};      RETURN[FALSE];      };    [] ¬ MBLoaderOps.EnumerateModules[CountThem];    IF count = 0 THEN RETURN [NIL];    moduleInfoSeq ¬ zone.NEW[LoadState.ModuleInfoSequence[count]];    [] ¬ MBLoaderOps.EnumerateModules[FillThem];    moduleInfoSeq.length ¬ count;    };  }.    
--SymToolPkg.mesa--  Sweet, 30-Apr-84  9:10:04DIRECTORY  PackageSymbols,  RESOut,  STDebugDefs,  Symbols,  SymbolSegment,  SymToolDefs;  SymToolPkg: PROGRAM  IMPORTS RESOut, STDebugDefs  EXPORTS SymToolDefs =   BEGIN OPEN PackageSymbols, RESOut;  IPIndex: TYPE = PackageSymbols.IPIndex;  IPNull: IPIndex = PackageSymbols.IPNull;  OPIndex: TYPE = PackageSymbols.OPIndex;  OPNull: OPIndex = PackageSymbols.OPNull;  lastInner: IPIndex _ IPNull;  lastOuter: OPIndex _ IPNull;    OPDesc: TYPE = LONG DESCRIPTOR FOR ARRAY OF OuterPackRecord;  IPDesc: TYPE = LONG DESCRIPTOR FOR ARRAY OF InnerPackRecord;    PU: PROC [UNSPECIFIED] = LOOPHOLE[RESOut.PUnsigned];    SetupOpb: PRIVATE PROC RETURNS [opb: OPDesc] =     BEGIN ENABLE UNWIND => STDebugDefs.UnlockSymbols[];    STDebugDefs.LockSymbols[];    opb.BASE _ STDebugDefs.TableBase[SymToolDefs.opType];    opb.LENGTH _ STDebugDefs.TableSize[SymToolDefs.opType] /      SIZE[PackageSymbols.OuterPackRecord];    END;    SetupIpb: PRIVATE PROC RETURNS [ipb: IPDesc] =     BEGIN ENABLE UNWIND => STDebugDefs.UnlockSymbols[];    STDebugDefs.LockSymbols[];    ipb.BASE _ STDebugDefs.TableBase[SymToolDefs.ipType];    ipb.LENGTH _ STDebugDefs.TableSize[SymToolDefs.ipType] /      SIZE[PackageSymbols.InnerPackRecord];    END;    PutAsOpi: PUBLIC PROC [opi: PackageSymbols.OPIndex] =    BEGIN ENABLE UNWIND => STDebugDefs.UnlockSymbols[];    opr: PackageSymbols.OuterPackRecord;    opb: OPDesc _ SetupOpb[];    IF opi >= opb.LENGTH THEN {      Complain["not a valid opi"L];      ERROR cancelAction};    opr _ opb[opi]; lastOuter _ opi;    PCr[]; PString["opb["L]; PU[opi]; PString["] = hti: "L];    PNull[opr.hti, Symbols.HTNull];    PNextUnsigned["entry"L, opr.entryIndex];    PNextUnsigned["length"L, opr.length];    IF opr.firstSon # IPNull THEN PNextUnsigned["firstSon"L, opr.firstSon];    IF opr.resident THEN PNext["resident"L];    IF opr.needsFixup THEN PNext["needsFixup"L];    IF opr.placed THEN PNext["placed"L];    STDebugDefs.UnlockSymbols[];    END;  PrintNxOpi: PUBLIC PROC =    BEGIN ENABLE UNWIND => STDebugDefs.UnlockSymbols[];    opb: OPDesc _ SetupOpb[];    IF lastOuter+1 >= opb.LENGTH THEN {      STDebugDefs.UnlockSymbols[]; RETURN};    PutAsOpi[lastOuter+1];    END;  PutAsIpi: PUBLIC PROC [ipi: PackageSymbols.IPIndex] =    BEGIN ENABLE UNWIND => STDebugDefs.UnlockSymbols[];    ipr: PackageSymbols.InnerPackRecord;    ipb: IPDesc _ SetupIpb[];    IF ipi >= ipb.LENGTH THEN {      Complain["not a valid ipi"L];      ERROR cancelAction};    ipr _ ipb[ipi]; lastInner _ ipi;    PCr[]; PString["ipb["L]; PU[ipi]; PString["] = entry: "L];    PUnsigned[ipr.entryIndex];    PNextUnsigned["length"L, ipr.length];    IF ipr.needsFixup THEN PNext["needsFixup"L];    IF ipr.lastSon THEN PNext["lastSon"L];    STDebugDefs.UnlockSymbols[];    END;  PrintNxIpi: PUBLIC PROC =    BEGIN ENABLE UNWIND => STDebugDefs.UnlockSymbols[];    ipb: IPDesc _ SetupIpb[];    IF lastInner+1 >= ipb.LENGTH THEN {      STDebugDefs.UnlockSymbols[]; RETURN};    PutAsIpi[lastInner+1];    END;      ConstSeqBody: TYPE = RECORD [    SEQUENCE count: CARDINAL OF PackageSymbols.ConstRecord];  ConstSeq: TYPE = LONG POINTER TO ConstSeqBody;  PCSeqBody: TYPE = PackageSymbols.PCSeqBody;  PCSeq: TYPE = PackageSymbols.PCSeq;  JISeqBody: TYPE = PackageSymbols.JISeqBody;  JISeq: TYPE = PackageSymbols.JISeq;    SetupConst: PRIVATE PROC RETURNS [      const: ConstSeq, loadOffsetTable: PCSeq,      loadByteOffsetTable: PCSeq, jumpIndirectTable: JISeq] =    BEGIN ENABLE UNWIND => STDebugDefs.UnlockSymbols[];    p: LONG POINTER;    STDebugDefs.LockSymbols[];    p _ STDebugDefs.TableBase[PackageSymbols.constType];    const _ p;    loadOffsetTable _ p + SIZE[ConstSeqBody[const.count]];    loadByteOffsetTable _       loadOffsetTable + SIZE[PCSeqBody[loadOffsetTable.length]];    jumpIndirectTable _       LOOPHOLE[loadByteOffsetTable + SIZE[PCSeqBody[loadByteOffsetTable.length]]];    END;  PrintMwconst: PUBLIC PROC =    BEGIN ENABLE UNWIND => STDebugDefs.UnlockSymbols[];    PNextEntry: PROC [c: PackageSymbols.ConstRecord] = {      ow, lw: CARDINAL;      ow _ Log8[c.offset]; IF ow > 1 THEN ow _ ow + 1;      lw _ Log8[c.length]; IF lw > 1 THEN lw _ lw + 1;      PNext[""L, ow+lw+3];      PChar['[]; POctal[c.offset]; PChar[',]; POctal[c.length]; PChar[']]};    const: ConstSeq;    [const: const] _ SetupConst[];    PCr[]; PString["Constants[offset,length]"L];    FOR i: CARDINAL IN [0..const.count) DO PNextEntry[const[i]]; ENDLOOP;    STDebugDefs.UnlockSymbols[];    END;  PrintLco: PUBLIC PROC =    BEGIN ENABLE UNWIND => STDebugDefs.UnlockSymbols[];    lco: PCSeq;    [loadOffsetTable: lco] _ SetupConst[];    PCr[]; PString["Code word offset[address]"L];    FOR i: CARDINAL IN [0..lco.length) DO      a: CARDINAL = lco[i];      w: CARDINAL _ Log8[a];      IF w > 1 THEN w _ w + 1;      PNext[""L, w]; POctal[a];      ENDLOOP;    STDebugDefs.UnlockSymbols[];    END;  PrintLio: PUBLIC PROC =    BEGIN ENABLE UNWIND => STDebugDefs.UnlockSymbols[];    lio: PCSeq;    [loadByteOffsetTable: lio] _ SetupConst[];    PCr[]; PString["Code byte offset[address]"L];    FOR i: CARDINAL IN [0..lio.length) DO      a: CARDINAL = lio[i];      w: CARDINAL _ Log8[a];      IF w > 1 THEN w _ w + 1;      PNext[""L, w]; POctal[a];      ENDLOOP;    STDebugDefs.UnlockSymbols[];    END;  PrintJibw: PUBLIC PROC =    BEGIN ENABLE UNWIND => STDebugDefs.UnlockSymbols[];    PNextEntry: PROC [c: PackageSymbols.JIData] = {      ow, lw: CARDINAL;      ow _ Log8[c.pc]; IF ow > 1 THEN ow _ ow + 1;      lw _ Log8[c.tableSize]; IF lw > 1 THEN lw _ lw + 1;      PNext[""L, ow+lw+3];      PChar['[]; POctal[c.pc]; PChar[',]; POctal[c.tableSize]; PChar[']]};    jibw: JISeq;    [jumpIndirectTable: jibw] _ SetupConst[];    PCr[]; PString["Dispatch jump tables[addr,size]"L];    FOR i: CARDINAL IN [0..jibw.length) DO PNextEntry[jibw[i]]; ENDLOOP;    STDebugDefs.UnlockSymbols[];    END;  END.  
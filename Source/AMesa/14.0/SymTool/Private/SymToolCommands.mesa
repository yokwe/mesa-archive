-- SymToolCommands.mesa, Edited by:-- Sweet,	 1-Jun-84 11:42:35-- Saxe,	29-Jul-87 10:48:42DIRECTORY  Ascii USING [CR, SP, TAB],  SymToolCommandDefs USING [FormItems],  DebugTab USING [],  FormSW USING [ProcType],  Heap,  Inline USING [LongNumber],  MsgSW USING [Clear, Post],  Put USING [Char, Text],  RESOut USING [PCr, WindowsHandle],  Runtime USING [GetTableBase],  Selection,  STDebugDefs,  String,  SymbolOps,  Symbols,  SymToolDefs,  Table,  UserInput USING [UserAbort],  Window USING [GetBox],  WindowFont USING [CharWidth];  SymToolCommands: PROGRAM   IMPORTS    SymToolDefs, DebugTab, Heap, MsgSW, Put, RESOut, Runtime, Selection,     STDebugDefs, String, SymbolOps, UserInput, Window, WindowFont  EXPORTS RESOut, SymToolDefs =  BEGIN OPEN SymToolDefs, RESOut;    handle: PUBLIC RESOut.WindowsHandle ¬ NIL;  table: LONG POINTER = Runtime.GetTableBase[LOOPHOLE[DebugTab]];    cancelAction: PUBLIC ERROR [endLine: BOOLEAN ¬ FALSE] = CODE;    lastCtx: Symbols.CTXIndex ¬ Symbols.CTXNull;    ValidCtx: PROC [ctx: Symbols.CTXIndex] RETURNS [BOOLEAN] =    BEGIN    ctxb: Table.Base ¬ STDebugDefs.TableBase[Symbols.ctxType];    t: Symbols.CTXIndex;    IF ctx = Symbols.CTXNull OR       LOOPHOLE[ctx, CARDINAL] >= STDebugDefs.TableSize[Symbols.ctxType] THEN      RETURN [FALSE];    t ¬ Symbols.CTXIndex.FIRST;    WHILE LOOPHOLE[t, CARDINAL] <= LOOPHOLE[ctx, CARDINAL] DO      IF t = ctx THEN RETURN[TRUE];      WITH ctxb[t] SELECT FROM        simple => t ¬ t + SIZE[Symbols.CTXRecord.simple];        included => t ¬ t + SIZE[Symbols.CTXRecord.included];        imported => t ¬ t + SIZE[Symbols.CTXRecord.imported];        nil => t ¬ t + SIZE[Symbols.CTXRecord.nil];	ENDCASE;      ENDLOOP;    RETURN[FALSE];    END;      lastBti: Symbols.BTIndex ¬ Symbols.BTNull;      ValidBti: PROC [bti: Symbols.BTIndex] RETURNS [BOOLEAN] =    BEGIN    bb: Table.Base ¬ STDebugDefs.TableBase[Symbols.bodyType];    t: Symbols.BTIndex;    IF bti = Symbols.BTNull OR       LOOPHOLE[bti, CARDINAL] >= STDebugDefs.TableSize[Symbols.bodyType] THEN      RETURN [FALSE];    t ¬ Symbols.BTIndex.FIRST;    WHILE LOOPHOLE[t, CARDINAL] <= LOOPHOLE[bti, CARDINAL] DO      IF t = bti THEN RETURN[TRUE];      WITH bt:  bb[t] SELECT FROM        Callable => WITH bt SELECT FROM	  Outer => t ¬ t + SIZE[Symbols.BodyRecord.Callable.Outer];	  Inner => t ¬ t + SIZE[Symbols.BodyRecord.Callable.Inner];	  Catch => t ¬ t + SIZE[Symbols.BodyRecord.Callable.Catch];	  ENDCASE;        Other => t ¬ t + SIZE[Symbols.BodyRecord.Other];	ENDCASE;      ENDLOOP;    RETURN[FALSE];    END;      lastSei: Symbols.ISEIndex ¬ Symbols.ISENull;      ValidSei: PROC [sei: Symbols.SEIndex] RETURNS [BOOLEAN] =    BEGIN    <<  cseSize: ARRAY Symbols.TypeClass OF CARDINAL = [	  mode: Symbols.SERecord.cons.mode.SIZE,	  basic: Symbols.SERecord.cons.basic.SIZE,	  enumerated: Symbols.SERecord.cons.enumerated.SIZE,	  record: Symbols.SERecord.cons.record.SIZE,	  ref: Symbols.SERecord.cons.ref.SIZE,	  array: Symbols.SERecord.cons.array.SIZE,	  arraydesc: Symbols.SERecord.cons.arraydesc.SIZE,	  transfer: Symbols.SERecord.cons.transfer.SIZE,	  definition: Symbols.SERecord.cons.definition.SIZE,	  union: Symbols.SERecord.cons.union.SIZE,	  sequence: Symbols.SERecord.cons.sequence.SIZE,	  relative: Symbols.SERecord.cons.relative.SIZE,	  subrange: Symbols.SERecord.cons.subrange.SIZE,	  long: Symbols.SERecord.cons.long.SIZE,	  real: Symbols.SERecord.cons.real.SIZE,	  opaque: Symbols.SERecord.cons.opaque.SIZE,	  zone: Symbols.SERecord.cons.zone.SIZE,	  any: Symbols.SERecord.cons.any.SIZE,	  nil: Symbols.SERecord.cons.nil.SIZE];        seb: Table.Base ¬ STDebugDefs.TableBase[Symbols.seType];        t: Symbols.SEIndex;    >>    IF sei = Symbols.SENull OR       LOOPHOLE[sei, CARDINAL] >= STDebugDefs.TableSize[Symbols.seType] THEN      RETURN [FALSE];    <<  t ¬ Symbols.SEIndex.FIRST;        WHILE LOOPHOLE[t, CARDINAL] <= LOOPHOLE[sei, CARDINAL] DO	  IF t = sei THEN RETURN[TRUE];	  WITH se:  seb[t] SELECT FROM	    id => WITH se SELECT FROM	      linked => t ¬ t + SIZE[Symbols.SERecord.id.linked];	      sequential => t ¬ t + SIZE[Symbols.SERecord.id.sequential];	      terminal => t ¬ t + SIZE[Symbols.SERecord.id.terminal];	      ENDCASE;	    cons => t ¬ t + cseSize[se.typeTag];	    ENDCASE;	  ENDLOOP;        RETURN[FALSE];    >>    RETURN [TRUE];     END;      FirstCtxSe: PROC =    BEGIN ENABLE UNWIND => STDebugDefs.UnlockSymbols[];    ctxb: Table.Base;    sei: Symbols.ISEIndex;    STDebugDefs.LockSymbols[];    IF ~ValidCtx[lastCtx] THEN {STDebugDefs.UnlockSymbols[]; RETURN};    ctxb ¬ STDebugDefs.TableBase[Symbols.ctxType];    sei ¬ ctxb[lastCtx].seList;    IF sei = Symbols.SENull THEN {STDebugDefs.UnlockSymbols[]; RETURN};    lastSei ¬ sei;    STDebugDefs.PutAsSei[table, sei];    STDebugDefs.UnlockSymbols[];    END;      PutNextSe: PROC =    BEGIN ENABLE UNWIND => STDebugDefs.UnlockSymbols[];    seb: Table.Base;    sei: Symbols.ISEIndex;    STDebugDefs.LockSymbols[];    IF ~ValidSei[lastSei] THEN {STDebugDefs.UnlockSymbols[]; RETURN};    seb ¬ STDebugDefs.TableBase[Symbols.seType];    WITH seb[lastSei] SELECT FROM      terminal => sei ¬ Symbols.ISENull;      linked => sei ¬ link;      sequential => sei ¬ lastSei+SIZE[Symbols.SERecord.id.sequential];      ENDCASE;    IF sei = Symbols.ISENull THEN {STDebugDefs.UnlockSymbols[]; RETURN};    lastSei ¬ sei;    STDebugDefs.PutAsSei[table, sei];    STDebugDefs.UnlockSymbols[];    END;      Type: PROC =    BEGIN ENABLE UNWIND => STDebugDefs.UnlockSymbols[];    seb: Table.Base;    sei: Symbols.SEIndex;    STDebugDefs.LockSymbols[];    IF ~ValidSei[lastSei] THEN {STDebugDefs.UnlockSymbols[]; RETURN};    seb ¬ STDebugDefs.TableBase[Symbols.seType];    sei ¬ seb[lastSei].idType;    IF sei = Symbols.typeTYPE THEN sei ¬ SymbolOps.ToSei[seb[lastSei].idInfo];    IF seb[sei].seTag = id THEN lastSei ¬ LOOPHOLE[sei];    STDebugDefs.PutAsSei[table, sei];    STDebugDefs.UnlockSymbols[];    END;      SonBti: PROC =    BEGIN ENABLE UNWIND => STDebugDefs.UnlockSymbols[];    bb: Table.Base;    bti: Symbols.BTIndex;    STDebugDefs.LockSymbols[];    IF ~ValidBti[lastBti] THEN {STDebugDefs.UnlockSymbols[]; RETURN};    bb ¬ STDebugDefs.TableBase[Symbols.bodyType];    bti ¬ bb[lastBti].firstSon;    IF bti = Symbols.BTNull THEN {STDebugDefs.UnlockSymbols[]; RETURN};    STDebugDefs.PutAsBti[lastBti ¬ bti];    STDebugDefs.UnlockSymbols[];    END;      BTLink: PROC =    BEGIN ENABLE UNWIND => STDebugDefs.UnlockSymbols[];    bb: Table.Base;    bti: Symbols.BTIndex;    STDebugDefs.LockSymbols[];    IF ~ValidBti[lastBti] THEN {STDebugDefs.UnlockSymbols[]; RETURN};    bb ¬ STDebugDefs.TableBase[Symbols.bodyType];    bti ¬ bb[lastBti].link.index;    IF bti = Symbols.BTNull THEN {STDebugDefs.UnlockSymbols[]; RETURN};    STDebugDefs.PutAsBti[lastBti ¬ bti];    STDebugDefs.UnlockSymbols[];    END;      FindId: PROC = {    id: LONG STRING ¬ Selection.Convert[string];    hti: Symbols.HTIndex;    desc: String.SubStringDescriptor;    BEGIN ENABLE UNWIND => {      Heap.systemZone.FREE[@id];      STDebugDefs.UnlockSymbols[]};    STDebugDefs.LockSymbols[];    IF id = NIL THEN {      Complain["please select an identifier"L];      ERROR cancelAction};    desc ¬ [base: id, offset: 0, length: id.length];    hti ¬ SymToolDefs.FindString[@desc];    Heap.systemZone.FREE[@id];    IF hti = Symbols.HTNull THEN {      Complain["not found"L];      ERROR cancelAction};    STDebugDefs.PutAsHti[hti];    STDebugDefs.UnlockSymbols[];    END};    FindIdInCtx: PROC = {    id: LONG STRING ¬ NIL;    hti: Symbols.HTIndex;    desc: String.SubStringDescriptor;    sei: Symbols.ISEIndex;    IF ~ValidCtx[lastCtx] THEN {      Complain["display a ctx first"L];      ERROR cancelAction};    BEGIN ENABLE UNWIND => {      Heap.systemZone.FREE[@id];      STDebugDefs.UnlockSymbols[]};    STDebugDefs.LockSymbols[];    id ¬ Selection.Convert[string];    IF id = NIL THEN {      Complain["please select an identifier"L];      ERROR cancelAction};    desc ¬ [base: id, offset: 0, length: id.length];    hti ¬ SymToolDefs.FindString[@desc];    Heap.systemZone.FREE[@id];    IF hti = Symbols.HTNull THEN GO TO missing;    sei ¬ SymToolDefs.SearchContext[hti, lastCtx];    IF sei = Symbols.SENull THEN GO TO missing;    lastSei ¬ sei;    STDebugDefs.PutAsSei[table, sei];    STDebugDefs.UnlockSymbols[];    EXITS      missing => {        Complain["not found"L];        ERROR cancelAction};    END};      DoOuterCtx: PROC =     BEGIN ENABLE UNWIND => STDebugDefs.UnlockSymbols[];    STDebugDefs.LockSymbols[];    lastCtx ¬ SymToolDefs.PrintOuterCtx[];    STDebugDefs.UnlockSymbols[];    END;      DoCtx: PROC =     BEGIN ENABLE UNWIND => STDebugDefs.UnlockSymbols[];    ctx: Symbols.CTXIndex;    STDebugDefs.LockSymbols[];    ctx ¬ GetSelectionValue[];    IF ~ValidCtx[ctx] THEN {      Complain["not a valid ctx"L];      ERROR cancelAction};    STDebugDefs.PutAsCti[lastCtx ¬ ctx];    STDebugDefs.UnlockSymbols[];    END;      DoBti: PROC =     BEGIN ENABLE UNWIND => STDebugDefs.UnlockSymbols[];    bti: Symbols.BTIndex;    STDebugDefs.LockSymbols[];    bti ¬ GetSelectionValue[];    IF ~ValidBti[bti] THEN {      Complain["not a valid bti"L];      ERROR cancelAction};    STDebugDefs.PutAsBti[lastBti ¬ bti];    STDebugDefs.UnlockSymbols[];    END;      DoSei: PROC =     BEGIN ENABLE UNWIND => STDebugDefs.UnlockSymbols[];    sei: Symbols.SEIndex;    seb: Table.Base;    STDebugDefs.LockSymbols[];    sei ¬ GetSelectionValue[];    IF ~ValidSei[sei] THEN {      Complain["not a valid sei"L];      ERROR cancelAction};    seb ¬ STDebugDefs.TableBase[Symbols.seType];    IF seb[sei].seTag = id THEN lastSei ¬ LOOPHOLE[sei];    STDebugDefs.PutAsSei[table, sei];    STDebugDefs.UnlockSymbols[];    END;        ParamNotify: PUBLIC FormSW.ProcType =    BEGIN OPEN STDebugDefs;    ENABLE cancelAction =>        BEGIN      IF endLine THEN Put.Text[handle.fileSW, " XXX"L];      GO TO done;      END;    Complain[""L];    SELECT LOOPHOLE[index, SymToolCommandDefs.FormItems] FROM      load => LoadSymbols[];      header => PrintHeader[];      offsets => PrintOffsets[];      outerCtx => DoOuterCtx[];      lti => PutAsLti[GetSelectionValue[]];      tree => PutAsTree[table, GetSelectionValue[]];      sei => DoSei[];      firstse => FirstCtxSe[];      nextse => PutNextSe[];      type => Type[];      hti => PutAsHti[GetSelectionValue[]];      ctx => DoCtx[];      bti => DoBti[];      sonBti => SonBti[];      btLink => BTLink[];      mdi => PutAsMdi[GetSelectionValue[]];      rep => PutAsVariousRep[GetSelectionValue[]];      opi => PutAsOpi[GetSelectionValue[]];      mwconst => PrintMwconst[];      fgtHdr => PrintFgtHdr[];      nxOpi => PrintNxOpi[];      lco => PrintLco[];      fgi => PutAsFgi[GetSelectionValue[]];      ipi => PutAsIpi[GetSelectionValue[]];      lio => PrintLio[];      sLti => PutAsSLti[GetSelectionValue[]];      nxFgi => PrintNxFgi[];      nxIpi => PrintNxIpi[];      jibw => PrintJibw[];      idToHash => FindId[];      idInCtx => FindIdInCtx[];      ENDCASE;    EXITS      done => NULL;    END;      GetSelectionValue: PUBLIC PROCEDURE RETURNS [val: UNSPECIFIED] =    BEGIN    num: Inline.LongNumber;    num.lc ¬ GetLongSelectionValue[];    SELECT num.highbits FROM      0, 177777B => NULL;      ENDCASE => {Complain["number too big"L]; ERROR cancelAction};    RETURN[num.lowbits];    END;      GetLongSelectionValue: PUBLIC PROCEDURE RETURNS [val: LONG UNSPECIFIED] =    BEGIN    val ¬ Selection.LongNumber[radix: 10 !	String.InvalidNumber => GO TO noNumber];    RETURN;    EXITS      noNumber =>	BEGIN	Complain["Select a number first"L];	ERROR cancelAction;	END;    END;      Complain: PUBLIC PROCEDURE [msg: LONG STRING, clear: BOOLEAN ¬ TRUE] =    BEGIN    IF handle.msgSW = NIL THEN RETURN;    IF clear THEN MsgSW.Clear[handle.msgSW];    MsgSW.Post[sw: handle.msgSW, string: msg, endOfMsg: FALSE];    END;    -- log writing procedures  charsOnLine: CARDINAL ¬ 0;  charWidth: CARDINAL = WindowFont.CharWidth[Ascii.SP];    PChar: PUBLIC PROCEDURE [c: CHARACTER] =    BEGIN    IF UserInput.UserAbort[handle.main] THEN ERROR cancelAction[TRUE];    IF handle.fileSW = NIL THEN RETURN;    Put.Char[handle.fileSW, c];    charsOnLine ¬ SELECT c FROM      Ascii.TAB  => ((charsOnLine+8)/8)*8,      Ascii.CR => 0,      ENDCASE => charsOnLine + 1;    END;      MakeRoom: PUBLIC PROCEDURE [chars, indent: CARDINAL]       RETURNS [was: BOOLEAN]=    BEGIN    charsPerLine: CARDINAL = handle.fileSW.GetBox[].dims.w/charWidth-4;    IF charsOnLine + chars <= charsPerLine THEN RETURN [TRUE];    PCr[];    THROUGH [0..indent/8) DO PChar[Ascii.TAB]; ENDLOOP;    THROUGH [0..indent MOD 8) DO PChar[Ascii.SP]; ENDLOOP;    RETURN[FALSE];    END;      END.
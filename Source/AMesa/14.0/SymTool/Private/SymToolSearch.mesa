-- file SymToolSearch.Mesa--   Sweet,		27-Apr-84 11:01:35DIRECTORY  Inline: TYPE USING [BITAND, BITXOR],  STDebugDefs,  String: TYPE USING [SubString, SubStringDescriptor, EqualSubStrings],  Symbols: TYPE,  SymToolDefs,  Table;SymToolSearch: PROGRAM    IMPORTS Inline, STDebugDefs, String    EXPORTS SymToolDefs    SHARES Symbols =  BEGIN  OPEN Symbols;   -- hash manipulation  SubString: TYPE = String.SubString;  FindString: PUBLIC PROC [s: SubString] RETURNS [hti: HTIndex] = {    ENABLE UNWIND => NULL;    desc: String.SubStringDescriptor;    ss: SubString = @desc;    ht: LONG DESCRIPTOR FOR ARRAY HTIndex OF HTRecord _ DESCRIPTOR[      STDebugDefs.TableBase[Symbols.htType],      STDebugDefs.TableSize[Symbols.htType] / SIZE [Symbols.HTRecord]];    hashVec: LONG POINTER TO HashVector _       STDebugDefs.TableBase[SymToolDefs.hvType];    hti _ hashVec[HashValue[s]];    WHILE hti # HTNull DO      SubStringForHash[ss, hti];      IF String.EqualSubStrings[s,ss] THEN EXIT;      hti _ ht[hti].link;      ENDLOOP;    RETURN};  HashValue: PROC [s: SubString] RETURNS [HVIndex] = {    CharBits: PROC [CHARACTER, WORD] RETURNS [WORD] = LOOPHOLE[Inline.BITAND];    Mask: WORD = 337b;		-- masks out ASCII case shifts    n: CARDINAL = s.length;    b: LONG STRING = s.base;    v: WORD;    v _ CharBits[b[s.offset], Mask]*177b + CharBits[b[s.offset+(n-1)], Mask];    RETURN [Inline.BITXOR[v, n*17b] MOD Symbols.HVLength]};  SubStringForHash: PROC [s: SubString, hti: HTIndex] = {    ht: LONG DESCRIPTOR FOR ARRAY HTIndex OF HTRecord _ DESCRIPTOR[      STDebugDefs.TableBase[Symbols.htType],      STDebugDefs.TableSize[Symbols.htType] / SIZE [Symbols.HTRecord]];    s.base _ STDebugDefs.TableBase[Symbols.ssType];    IF hti = HTNull      THEN s.offset _ s.length _ 0      ELSE s.length _ ht[hti].ssIndex - (s.offset _ ht[hti-1].ssIndex)}; -- context management  SearchContext: PUBLIC PROC [hti: HTIndex, ctx: CTXIndex] RETURNS [ISEIndex] = {    sei, root: ISEIndex;    ctxb: Table.Base _ STDebugDefs.TableBase[Symbols.ctxType];    seb: Table.Base _ STDebugDefs.TableBase[Symbols.seType];    IF ctx # CTXNull AND hti # HTNull      THEN {	sei _ root _ ctxb[ctx].seList;	DO	  IF sei = SENull THEN EXIT;	  IF seb[sei].hash = hti THEN RETURN [sei];	  WITH id: seb[sei] SELECT FROM	    sequential => sei _ sei + SIZE[sequential id SERecord];	    linked => IF (sei _ id.link) = root THEN EXIT;	    ENDCASE => EXIT;	  ENDLOOP};    RETURN [ISENull]};  END.
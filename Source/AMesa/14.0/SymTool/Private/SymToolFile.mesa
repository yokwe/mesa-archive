-- SymToolFile.mesa, Edited by:-- Sweet,	 1-Jun-84 10:58:34DIRECTORY  AllocOps,  BcdDefs,  BcdOps,  Environment,  Inline,  Literals,  MFile,  MSegment,  PrincOps,  RESOut,  STDebugDefs,  String,  Symbols,  SymbolSegment,  SymbolTable,  SymToolDefs,  Table;  SymToolFile: MONITOR   IMPORTS    Inline, RESOut, MFile, MSegment,     STDebugDefs, String  EXPORTS STDebugDefs, SymToolDefs  =  BEGIN OPEN RESOut, SymToolDefs;    stFile: PUBLIC LONG STRING _ NIL;    stHandle: MSegment.Handle _ NIL;  stAddr: LONG POINTER TO SymbolSegment.STHeader; -- to actual symbol table bits  STMissing: SIGNAL = CODE;    ClearFileSource: PUBLIC PROC = {    IF stHandle # NIL THEN {      RESOut.PCr[];      RESOut.PString["unloading file"];      stHandle.Delete[]; stHandle _ NIL};    pleaseClear _ FALSE};      LoadSymbols: PUBLIC PROC =    BEGIN    lookupString: STRING _ [90];    RESOut.Complain[""L];    IF stHandle # NIL THEN {      ClearFileSource[];      IF stFile = NIL OR stFile.length = 0 THEN RETURN};    IF stFile = NIL OR stFile.length > lookupString.length-4 THEN GO TO nope;    String.AppendString[lookupString, stFile];    stHandle _ STTableForString[lookupString ! STMissing => GO TO nope];    stAddr _ stHandle.Address[];    PCr[]; PCr[]; PString["From file: "L]; PString[lookupString];    PChar[' ];    STDebugDefs.PutVersion[@stAddr.version];    RETURN;    EXITS      nope => RESOut.Complain["Invalid file"L];    END;      pleaseClear: BOOLEAN _ FALSE;  symbolsLocked: BOOLEAN _ FALSE;    ReleaseSymbols: ENTRY MSegment.PleaseReleaseProc =    BEGIN    ENABLE UNWIND => NULL;    SELECT TRUE FROM      symbolsLocked => {pleaseClear _ TRUE; RETURN[later]};      stHandle = NIL => RETURN [later];      ENDCASE => {        RESOut.PCr[];        RESOut.PString["unloading file"];	stHandle _ NIL;	RETURN[goAhead]};    END;      LockSymbols: PUBLIC ENTRY PROC = {    ENABLE UNWIND => NULL;    IF stHandle = NIL THEN {Complain["please load a file"L]; ERROR cancelAction};    stAddr _ stHandle.Address[];    symbolsLocked _ TRUE};      UnlockSymbols: PUBLIC ENTRY PROC = {    ENABLE UNWIND => NULL;    symbolsLocked _ FALSE;    IF pleaseClear AND stHandle # NIL THEN ClearFileSource[];    pleaseClear _ FALSE};      TableBase: PUBLIC PROC [table: Table.Selector _ Table.chunkType] RETURNS [local: Table.Base] =    BEGIN    IF stHandle = NIL THEN {Complain["please load a file"L]; ERROR cancelAction};    RETURN[FileTableBase[table]];    END;      FileTableBase: PROC [table: Table.Selector] RETURNS [Table.Base] =    BEGIN OPEN SymbolSegment;    delta: CARDINAL;    SELECT table FROM      treeType => delta _ STRead[@stAddr.treeBlock.offset];      seType => delta _ STRead[@stAddr.seBlock.offset];      htType => delta _ STRead[@stAddr.htBlock.offset];      ssType => delta _ STRead[@stAddr.ssBlock.offset];      ctxType => delta _ STRead[@stAddr.ctxBlock.offset];      mdType => delta _ STRead[@stAddr.mdBlock.offset];      bodyType => delta _ STRead[@stAddr.bodyBlock.offset];      ltType => delta _ STRead[@stAddr.litBlock.offset];      stType => delta _ STRead[@stAddr.sLitBlock.offset];      extType => delta _ STRead[@stAddr.extBlock.offset];      SymToolDefs.opType => delta _ STRead[@stAddr.outerPackBlock.offset];      SymToolDefs.ipType => delta _ STRead[@stAddr.innerPackBlock.offset];      SymToolDefs.hvType => delta _ STRead[@stAddr.hvBlock.offset];      constType => delta _ STRead[@stAddr.constBlock.offset];      ENDCASE => ERROR;    RETURN [LOOPHOLE[stAddr+delta]];    END;      TableSize: PUBLIC PROC [table: Table.Selector _ Table.chunkType] RETURNS [CARDINAL] =    BEGIN    IF stHandle = NIL THEN {Complain["please load a file"L]; ERROR cancelAction};    RETURN [FileTableSize[table]];    END;      FileTableSize: PROC [table: Table.Selector] RETURNS [size: CARDINAL] =    BEGIN OPEN SymbolSegment;    SELECT table FROM      treeType => size _ STRead[@stAddr.treeBlock.size];      seType => size _ STRead[@stAddr.seBlock.size];      htType => size _ STRead[@stAddr.htBlock.size];      ssType => size _ STRead[@stAddr.ssBlock.size];      ctxType => size _ STRead[@stAddr.ctxBlock.size];      mdType => size _ STRead[@stAddr.mdBlock.size];      bodyType => size _ STRead[@stAddr.bodyBlock.size];      ltType => size _ STRead[@stAddr.litBlock.size];      stType => size _ STRead[@stAddr.sLitBlock.size];      extType => size _ STRead[@stAddr.extBlock.size];      SymToolDefs.opType => size _ STRead[@stAddr.outerPackBlock.size];      SymToolDefs.ipType => size _ STRead[@stAddr.innerPackBlock.size];      SymToolDefs.hvType => size _ STRead[@stAddr.hvBlock.size];      constType => size _ STRead[@stAddr.constBlock.size];      ENDCASE => ERROR;    RETURN;    END;      STRead: PUBLIC PROC [p: LONG UNSPECIFIED] RETURNS [UNSPECIFIED] =    BEGIN    RETURN [LOOPHOLE[p, LONG POINTER]^]    END;      STCopyRead: PUBLIC PROC [from: LONG POINTER, nwords: CARDINAL, to: LONG POINTER] =    BEGIN    Inline.LongCOPY[from: from, nwords: nwords, to: to];    END;      STTableForString: ENTRY PROC [name: STRING] RETURNS [MSegment.Handle] =    BEGIN    ENABLE UNWIND => NULL;    BEGIN -- to put nofile inside the enable    file: MFile.Handle;    CheckForExtension[name, ".bcd"L];    file _ MFile.Acquire[name, readOnly, [] ! MFile.Error => GOTO nofile];    pleaseClear _ FALSE;    RETURN[CompilerSeg[file]];    EXITS nofile => ERROR STMissing;    END;    END;      CompilerSeg: INTERNAL PROC [file: MFile.Handle]       RETURNS [seg: MSegment.Handle _ NIL] =    BEGIN    sgh: BcdOps.SGHandle;    mth: BcdOps.MTHandle;    sSeg: BcdDefs.SGIndex;    bcdPages: CARDINAL _ 10;    AltoBias: CARDINAL = 1;    bcd: BcdOps.BcdBase;    headerSeg: MSegment.Handle _      MSegment.Create[        file.CopyFileHandle[[]],         [proc: ReleaseSymbols], 0, bcdPages];    BEGIN    DO      bcd _ headerSeg.Address[];      IF bcd.versionIdent # BcdDefs.VersionID THEN GOTO nogood;      IF bcdPages >= bcd.nPages THEN EXIT;      bcdPages _ bcd.nPages;      headerSeg.Reset[pages: bcdPages];      ENDLOOP;    IF bcd.nConfigs # 0 THEN GOTO nogood;    mth _ @LOOPHOLE[bcd+bcd.mtOffset,Table.Base][FIRST[BcdDefs.MTIndex]];    sSeg _ mth.sseg;     sgh _ @LOOPHOLE[bcd+bcd.sgOffset,Table.Base][sSeg];    IF sSeg=BcdDefs.SGNull OR sgh.pages = 0 OR sgh.file # BcdDefs.FTSelf THEN      GOTO nogood;    seg _ MSegment.Create[      file, [proc: ReleaseSymbols], sgh.base-AltoBias, sgh.pages+sgh.extraPages];    headerSeg.Delete[];    EXITS nogood => {      headerSeg.Delete[]; seg _ NIL; file.Release[];      ERROR STMissing};    END;    END;      CheckForExtension: PROC [name, ext: STRING] = {    FOR i: CARDINAL IN [0..name.length) DO      IF name[i] = '. THEN RETURN;      ENDLOOP;    String.AppendString[name, ext]};      PrintOuterCtx: PUBLIC PROC RETURNS [Symbols.CTXIndex] =     BEGIN    hdr: LONG POINTER TO SymbolSegment.STHeader = LOOPHOLE[stAddr];    STDebugDefs.PutAsCti[hdr.outerCtx];    RETURN [hdr.outerCtx];    END;      PrintHeader: PUBLIC PROC =     BEGIN OPEN RESOut;    ENABLE UNWIND => UnlockSymbols[];    hdr: LONG POINTER TO SymbolSegment.STHeader = LOOPHOLE[stAddr];    IF hdr = NIL THEN {      Complain["please load file"L];      ERROR cancelAction};    LockSymbols[];    PCr[];    PString["STHeader: VersionId: "L]; POctal[hdr.versionIdent];    PCr[]; PString["  version: "L]; STDebugDefs.PutVersion[@hdr.version];    PCr[]; PString["  creator: "L]; STDebugDefs.PutVersion[@hdr.creator];    PCr[]; PString["  source: "L]; STDebugDefs.PutVersion[@hdr.sourceVersion];    PCr[]; PString["  dirCtx: "L]; PNull[hdr.directoryCtx, Symbols.CTXNull];    PNextNull["impCtx"L, hdr.importCtx, Symbols.CTXNull];    PNextNull["outerCtx"L, hdr.outerCtx, Symbols.CTXNull];    IF hdr.definitionsFile THEN PNext["definitions"L];    UnlockSymbols[];    END;    PrintOffsets: PUBLIC PROC =     BEGIN OPEN RESOut;    ENABLE UNWIND => UnlockSymbols[];        PNextBlock: PROC [name: STRING, blk: SymbolSegment.BlockDescriptor] = {      ow, sw: CARDINAL;      ow _ Log8[blk.offset]; IF ow > 1 THEN ow _ ow + 1;      sw _ Log8[blk.size]; IF sw > 1 THEN sw _ sw + 1;      PNext[name, 3+ow+1+sw+1];      PString[": ["L]; POctal[blk.offset]; PChar[',];      POctal[blk.size]; PChar[']]};    hdr: LONG POINTER TO SymbolSegment.STHeader = LOOPHOLE[stAddr];    IF hdr = NIL THEN {      Complain["please load file"L];      ERROR cancelAction};    LockSymbols[];    PCr[];    PString["Tables[offset, length]"L];    PNextBlock["hv"L, hdr.hvBlock];    PNextBlock["ht"L, hdr.htBlock];    PNextBlock["ss"L, hdr.ssBlock];    PNextBlock["outerPk"L, hdr.outerPackBlock];    PNextBlock["innerPk"L, hdr.innerPackBlock];    PNextBlock["const"L, hdr.constBlock];    PNextBlock["se"L, hdr.seBlock];    PNextBlock["ctx"L, hdr.ctxBlock];    PNextBlock["md"L, hdr.mdBlock];    PNextBlock["body"L, hdr.bodyBlock];    PNextBlock["ext"L, hdr.extBlock];    PNextBlock["tree"L, hdr.treeBlock];    PNextBlock["lit"L, hdr.litBlock];    PNextBlock["sLit"L, hdr.sLitBlock];    PNextOctal["fgRelBase"L, hdr.fgRelPgBase];    PNextOctal["fgCount"L, hdr.fgPgCount];    UnlockSymbols[];    END;      FGDesc: TYPE = LONG DESCRIPTOR FOR ARRAY OF SymbolSegment.FGTEntry;      FindFGT: PRIVATE PROC RETURNS [      entries: FGDesc,       sourcefile: LONG STRING] =    BEGIN    hdr: LONG POINTER TO SymbolSegment.STHeader = LOOPHOLE[stAddr];    fgHdr: LONG POINTER TO SymbolSegment.FGHeader;    IF hdr = NIL THEN {      Complain["please load file"L];      ERROR cancelAction};    IF hdr.fgPgCount = 0 THEN {      Complain["No fine grain table"L];       ERROR cancelAction};    fgHdr _ LOOPHOLE[hdr + hdr.fgRelPgBase * Environment.wordsPerPage];    RETURN [DESCRIPTOR[fgHdr+fgHdr.offset, fgHdr.length], @fgHdr.sourceFile];    END;      PrintFgtHdr: PUBLIC PROC =     BEGIN OPEN RESOut;    ENABLE UNWIND => UnlockSymbols[];        fg: FGDesc;    s: LONG STRING;    LockSymbols[];    [fg, s] _ FindFGT[];    PCr[];    PString["FGTable"L];     IF s.length > 100 THEN {      Complain["source looks bogus"L];      ERROR cancelAction[TRUE]};    PNext["source: "L, s.length]; PString[s];    PNextUnsigned["length"L, fg.LENGTH];    UnlockSymbols[];    END;      lastFgi: CARDINAL _ 0;    PutAsFgi: PUBLIC PROC [n: CARDINAL] =    BEGIN OPEN RESOut;    ENABLE UNWIND => UnlockSymbols[];    fg: FGDesc;    entry: SymbolSegment.FGTEntry;    LockSymbols[];    [entries: fg] _ FindFGT[];    IF n >= fg.LENGTH THEN {      Complain["index too big"L];      ERROR cancelAction};    PCr[];    PString["fgt["L]; PUnsigned[n]; PString["] = ["L];    entry _ fg[n]; lastFgi _ n;    WITH e: entry SELECT FROM      normal => {        PString["dObj: "L]; PUnsigned[e.deltaObject];	PNextUnsigned["dSrc"L, e.deltaSource]};      step => {        PString[IF e.which = source THEN "dSrc: "L ELSE "dObj: "L];	PUnsigned[e.delta]};      ENDCASE;    PChar[']];    UnlockSymbols[];    END;      PrintNxFgi: PUBLIC PROC =    BEGIN OPEN RESOut;    ENABLE UNWIND => UnlockSymbols[];     fg: FGDesc;    n: CARDINAL _ lastFgi + 1;    LockSymbols[];    [entries: fg] _ FindFGT[];    IF n >= fg.LENGTH THEN RETURN;    PutAsFgi[n];    END;      PU: PROC [UNSPECIFIED] = LOOPHOLE[RESOut.PUnsigned];    PutAsSLti: PUBLIC PROC [sti: Literals.STIndex] =    BEGIN OPEN RESOut, STDebugDefs;    ENABLE UNWIND => UnlockSymbols[];     stb: Table.Base;    LockSymbols[];    stb _ TableBase[Literals.stType]; -- doesn't return if no symbols loaded    PCr[];    PString["stb["]; PU[sti];    PString["] = "L];    WITH ss: stb[sti] SELECT FROM      copy => {        PString["copy of stb["L]; PU[ss.link]; PChar[']];	IF ss.mark THEN PNext["mark"L]};      master => {        PChar['"];        PString[@ss.string];        PChar['"];	IF ss.local THEN PNext["local"L];	PNextUnsigned["codeIndex"L, ss.codeIndex];	PNextNull["link"L, ss.link, Literals.STNull];	PNextUnsigned["info"L, ss.info]};      ENDCASE;    UnlockSymbols[];    END;      END.
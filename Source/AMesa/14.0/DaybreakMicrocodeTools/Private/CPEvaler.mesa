-- Copyright (C) 1985  by Xerox Corporation. All rights reserved.-- Last edit by JAC	 7-Jun-85 12:26:52	copyrighted -- CPEvaler.mesa, JoM    , 25-Jan-85 16:37:33DIRECTORY  Ascii USING [CR, LF, FF, SP, TAB],  Inline USING [LowHalf],  String USING [AppendString, Equivalent, SubString, SubStringDescriptor],    CP USING [    Cycle, IOReg, Link, Map, OtherReg, RealCS, RealMemory, RReg,    UReg, VirturalMemory],  CPMI USING [MI],  CPSymbols USING [    Error, LookupInCSTable, LookupInRRegTable, LookupInRHTable, LookupInURegTable,    nullRealCS, nullVirturalCS, RealToVirturalCS, Symbol, Type, VirturalCS, VirturalToRealCS],  Evaluate USING [Error, EvaluateSubString, Type, unspecified, Value],  StringExtras USING [StringToLongCardinal];CPEvaler: PROGRAM  IMPORTS Inline, String, CPSymbols, Evaluate, StringExtras  EXPORTS CPSymbols =  BEGIN    GetPcAndCycle: PUBLIC PROCEDURE [s: LONG STRING]    RETURNS [pc: CP.RealCS, cycle: CP.Cycle] =    BEGIN    symbol: CPSymbols.Symbol _ Eval[s];    WITH symbol SELECT FROM      number =>        BEGIN	virt: CPSymbols.VirturalCS;	pc _ Inline.LowHalf[n];	[virt, cycle] _ CPSymbols.RealToVirturalCS[pc];	IF virt = CPSymbols.nullVirturalCS THEN ERROR CPSymbols.Error["Can't find task info"L];	END;      realCS =>        BEGIN	virt: CPSymbols.VirturalCS;	pc _ real;	[virt, cycle] _ CPSymbols.RealToVirturalCS[pc];	IF virt = CPSymbols.nullVirturalCS THEN ERROR CPSymbols.Error["Can't find task info"L];	END;      virtCS =>        BEGIN	[pc, cycle] _ CPSymbols.VirturalToRealCS[virt];	IF pc = CPSymbols.nullRealCS THEN ERROR CPSymbols.Error["Can't translate to a real CS address"L];	END;      ENDCASE => ERROR CPSymbols.Error["CP ControlStore address required"L];    END;	  GetPc: PUBLIC PROCEDURE [s: LONG STRING] RETURNS [pc: CP.RealCS] =    BEGIN    symbol: CPSymbols.Symbol _ Eval[s];    WITH symbol SELECT FROM      number => pc _ Inline.LowHalf[n];      realCS => pc _ real;      virtCS =>        BEGIN	[pc, ] _ CPSymbols.VirturalToRealCS[virt];	IF pc = CPSymbols.nullRealCS THEN ERROR CPSymbols.Error["Can't translate to a real CS address"L];	END;      ENDCASE => ERROR CPSymbols.Error["CP ControlStore address required"L];    END;	  Eval: PUBLIC PROCEDURE [s: LONG STRING] RETURNS [CPSymbols.Symbol] =    BEGIN    type: Evaluate.Type;    val: Evaluate.Value;    shortVal: ARRAY [0..SIZE[CPMI.MI]) OF CARDINAL;    numberFound: CARDINAL _ 0;    pointer: LONG POINTER;    t: CPSymbols.Type;    rAndRH: BOOLEAN _ FALSE;    ss: String.SubStringDescriptor _ [base: s, offset: 0, length: s.length];    Lookup: PROCEDURE [s: LONG STRING] RETURNS [type: Evaluate.Type, value: Evaluate.Value] =      BEGIN      ok: BOOLEAN;      virt: CPSymbols.VirturalCS;      r: CP.RReg;      u: CP.UReg;      symbol: CPSymbols.Symbol;      [ok, virt] _ CPSymbols.LookupInCSTable[s];      IF ok THEN RETURN[LOOPHOLE[CPSymbols.Type[virtCS]], LONG[virt]];      [ok, r] _ CPSymbols.LookupInRRegTable[s];      IF ok THEN RETURN[LOOPHOLE[CPSymbols.Type[rReg]], LONG[r]];      [ok, r] _ CPSymbols.LookupInRHTable[s];      IF ok THEN RETURN[LOOPHOLE[CPSymbols.Type[rH]], LONG[r]];      [ok, u] _ CPSymbols.LookupInURegTable[s];      IF ok THEN RETURN[LOOPHOLE[CPSymbols.Type[uReg]], LONG[u]];      [ok, symbol] _ StringAsSpecial[s];      IF ok THEN        BEGIN        type _ LOOPHOLE[symbol.type];        WITH symbol SELECT FROM          number => value _ n;          link => value _ link;          mi =>	    BEGIN	    shortVal _ LOOPHOLE[mi];	    value _ shortVal[0];	    END;	  realCS => value _ real;          virtCS => value _ virt;          rReg, rH => value _ r;          uReg => value _ u;          ioIn, ioOut => value _ io;          map => value _ map;          real => value _ LOOPHOLE[real];          virt => value _ LOOPHOLE[virt];          other => value _ LONG[LOOPHOLE[other]];	  pc => value _ 0;          ENDCASE => ERROR;        RETURN;        END;      [ok, value] _ StringExtras.StringToLongCardinal[s];      IF NOT ok THEN        BEGIN        temp: LONG STRING = [100];        String.AppendString[temp, "Undefined Symbol: "L];        String.AppendString[temp, s];        ERROR CPSymbols.Error[temp];        END;      shortVal[numberFound] _ Inline.LowHalf[value];      numberFound _ numberFound + 1;      RETURN[Evaluate.unspecified, value];      END;    TrimSubString[@ss];    SELECT TRUE FROM      ss.base[ss.offset] = '$ =>        BEGIN        ss _ [base: ss.base, offset: ss.offset + 1, length: ss.length - 1];	rAndRH _ TRUE;        END;      ENDCASE => NULL;    [type, val] _ Evaluate.EvaluateSubString[@ss, Lookup !        Evaluate.Error => ERROR CPSymbols.Error[reason] ];    pointer _ LOOPHOLE[val];    t _ IF type = Evaluate.unspecified THEN number ELSE LOOPHOLE[type];    IF rAndRH THEN      BEGIN      IF t = rReg OR t = rH THEN t _ rAndRh      ELSE InconsistentExpression[];      END;    IF numberFound # 3 OR t # number      THEN shortVal[0] _ Inline.LowHalf[val]      ELSE t _ mi;    SELECT t FROM      number => RETURN[[number[val]]];      link =>        BEGIN	IF val ~IN CP.Link THEN AddressOutOfRange[];        RETURN[[link[shortVal[0]]]];	END;      mi => RETURN[[mi[LOOPHOLE[shortVal]]]];      realCS => RETURN[[realCS[shortVal[0]]]];      virtCS => RETURN[[virtCS[shortVal[0]]]];      rReg =>        BEGIN	IF val ~IN CP.RReg THEN AddressOutOfRange[];	RETURN[[rReg[shortVal[0]]]];	END;      rH =>        BEGIN	IF val ~IN CP.RReg THEN AddressOutOfRange[];	RETURN[[rH[shortVal[0]]]];	END;      rAndRh =>        BEGIN	IF val ~IN CP.RReg THEN AddressOutOfRange[];	RETURN[[rAndRh[shortVal[0]]]];	END;      uReg =>        BEGIN	IF val ~IN CP.UReg THEN AddressOutOfRange[];	RETURN[[uReg[shortVal[0]]]];	END;      ioIn => RETURN[[ioIn[shortVal[0]]]];      ioOut => RETURN[[ioOut[shortVal[0]]]];      map =>        BEGIN	IF val ~IN CP.Map THEN AddressOutOfRange[];	RETURN[[map[shortVal[0]]]];	END;      real => RETURN[[real[pointer]]];      virt => RETURN[[virt[pointer]]];      other => RETURN[[other[LOOPHOLE[shortVal[0]]]]];      pc => RETURN[[pc[]]];      ENDCASE => ERROR;    END;          StringAsSpecial: PROCEDURE [s: LONG STRING] RETURNS [BOOLEAN, CPSymbols.Symbol] =    BEGIN    SELECT TRUE FROM      String.Equivalent[s, ".CR"L] => RETURN[TRUE, [realCS[0]]];      String.Equivalent[s, ".CV"L] => RETURN[TRUE, [virtCS[0]]];      String.Equivalent[s, ".RH"L] => RETURN[TRUE, [rH[0]]];      String.Equivalent[s, ".R"L] => RETURN[TRUE, [rReg[0]]];      String.Equivalent[s, ".U"L] => RETURN[TRUE, [uReg[0]]];      String.Equivalent[s, ".LINK"L] => RETURN[TRUE, [link[0]]];      String.Equivalent[s, ".MAP"L] => RETURN[TRUE, [map[0]]];      String.Equivalent[s, ".MR"L] => RETURN[TRUE, [real[NIL]]];      String.Equivalent[s, ".MV"L] => RETURN[TRUE, [virt[NIL]]];      String.Equivalent[s, ".IOIN"L] => RETURN[TRUE, [ioIn[0]]];      String.Equivalent[s, ".IOXIN"L] => RETURN[TRUE, [ioIn[0]]];      String.Equivalent[s, ".IOOUT"L] => RETURN[TRUE, [ioOut[0]]];      String.Equivalent[s, "Q"L] => RETURN[TRUE, [other[q]]];      String.Equivalent[s, ".Q"L] => RETURN[TRUE, [other[q]]];      String.Equivalent[s, ".IB"L] => RETURN[TRUE, [other[ib]]];      String.Equivalent[s, ".PC16"L] => RETURN[TRUE, [other[pc16]]];      String.Equivalent[s, ".STACKP"L] => RETURN[TRUE, [other[stackP]]];      String.Equivalent[s, ".IBPTR"L] => RETURN[TRUE, [other[ibPtr]]];      String.Equivalent[s, ".MINT"L] => RETURN[TRUE, [other[mInt]]];      String.Equivalent[s, ".EKERR"L] => RETURN[TRUE, [other[ekErr]]];      String.Equivalent[s, "L0"L] => RETURN[TRUE, [link[0]]];      String.Equivalent[s, "L1"L] => RETURN[TRUE, [link[1]]];      String.Equivalent[s, "L2"L] => RETURN[TRUE, [link[2]]];      String.Equivalent[s, "L3"L] => RETURN[TRUE, [link[3]]];      String.Equivalent[s, "L4"L] => RETURN[TRUE, [link[4]]];      String.Equivalent[s, "L5"L] => RETURN[TRUE, [link[5]]];      String.Equivalent[s, "L6"L] => RETURN[TRUE, [link[6]]];      String.Equivalent[s, "L7"L] => RETURN[TRUE, [link[7]]];      String.Equivalent[s, ".PC"L] => RETURN[TRUE, [pc[]]];      ENDCASE => RETURN[FALSE, ];    END;        InconsistentExpression: PROCEDURE =    BEGIN    foo: BOOLEAN _ TRUE;    IF foo THEN ERROR CPSymbols.Error["Inconsistent expression"L];    END;      AddressOutOfRange: PROCEDURE =    BEGIN    foo: BOOLEAN _ TRUE;    IF foo THEN ERROR CPSymbols.Error["Address out of range"L];    END;      TrimSubString: PROCEDURE [ss: String.SubString] =    BEGIN    FOR i: CARDINAL IN [ss.offset..ss.offset + ss.length) DO      IF ~BlankCharacter[ss.base[i]] THEN        BEGIN  --  remove leading blanks        ss.length _ ss.length - (i - ss.offset);        ss.offset _ i;	EXIT;	END;      REPEAT FINISHED =>        BEGIN  --all blanks	ss.length _ 0;        RETURN;	END;      ENDLOOP;    FOR i: CARDINAL DECREASING IN [ss.offset..ss.offset + ss.length) DO      IF ~BlankCharacter[ss.base[i]] THEN        BEGIN  --  remove trailing blanks        ss.length _ ss.length - (ss.offset + ss.length - 1 - i);	EXIT;	END;      ENDLOOP;    END;      BlankCharacter: PROCEDURE [c: CHARACTER] RETURNS [BOOLEAN] =    BEGIN    SELECT c FROM      Ascii.FF, Ascii.SP, Ascii.CR, Ascii.LF, Ascii.TAB => RETURN[TRUE];      ENDCASE => RETURN[FALSE];    END;    END.
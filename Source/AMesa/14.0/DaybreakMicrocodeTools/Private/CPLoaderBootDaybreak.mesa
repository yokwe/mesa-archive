-- Copyright (C) 1983, 1984, 1985  by Xerox Corporation. All rights reserved. -- Last edit by JAC	 7-Jun-85 11:47:27	CPCommand became CPCommands-- CPLoaderBootDaybreak.mesa, JGS    , 6-Feb-85 14:13:36DIRECTORY  Boot USING [bootPhysicalVolume, countGermVM, pageGerm, pRequest, Request],  BootFile USING [    currentVersion, MapEntry, Header, maxEntriesPerHeader, maxEntriesPerTrailer,    Trailer],  DeviceTypes USING [anyPilotDisk],  Environment USING [bytesPerPage, PageCount, PageNumber, wordsPerPage],  Format USING [CR, Line, LongDecimal, StringProc, Text],  Heap USING [systemZone],  Inline USING [LowByte, LowHalf],  MStream USING [EndOf, Error, ReadOnly],  PageMap USING [],  PilotSwitches USING [hang],  Stream USING [Delete, EndOfStream, GetBlock, Handle],  String USING [AppendExtensionIfNeeded, CopyToNewString],  System USING [GetClockPulses, Pulses, PulsesToMicroseconds],  Space USING [LongPointerFromPage, PageFromLongPointer],    CP USING [RealMemory, VirturalMemory],  CPCommands USING [Error, RefreshWindow],  CPKernel USING [    Error, machine, mapOffset, ResetMap, WriteMemoryBlock,    WriteNextMemoryBlock, WriteRealMemory]; CPLoaderBootDaybreak: PROGRAM  IMPORTS    Format, Heap, Inline, MStream, Stream, String, System,    CPCommands, CPKernel, Space  EXPORTS CPCommands =  BEGIN  z: UNCOUNTED ZONE = Heap.systemZone;  -- DLion physical memory layout  -- func	octal		decimal  -- display	[0..400)	[0..256)  -- map	[400..500)	[256..320)  -- IO Page	500		320  -- free	[501..1400)	[321..768)     ++ 192K DLion  -- Dicentra physical memory layout  -- func	octal		decimal  -- free	[0..400)	[0..256)  -- map	[400..500)	[256..320)  -- free	[500..2000)	[320..1024)     ++ 512K Dicentra    -- Daybreak physical memory layout  -- func	octal		decimal  -- display	[0..400)	[0..256)  -- nothing	[400..2000)	[256..1024)  -- map	[2000..2400)	[1024..1280)  -- free	[2400..2440)	[1280..1312)  -- IORegion	[2440..2540)	[1312..1376)  -- free	[2540..)	[1376..)    ++512K word + 64K word Daybreak    -- For all machines, the germ goes into virtural [1..n).  -- The rest of free memory is mapped behind the germ.  -- After the germ loads a boot file, free memory is behind the boot file.  RealPageNumber: TYPE = CARDINAL;  firstMapPage: RealPageNumber =    CARDINAL[CPKernel.mapOffset/Environment.wordsPerPage];  mapPagesCount:  CARDINAL = 256;  ioRegionPageNumber:  RealPageNumber = 1312;  ioRegionPagesCount:  CARDINAL = 64;  ioRegionRealAddr:  LONG POINTER = LOOPHOLE[52000H];    firstFreePage:  RealPageNumber = 1280;  ioRegionVirtPage:  CARDINAL = 0C0H;  countRealPages: CARDINAL = 2048;    tempCountGermVM: CARDINAL = Inline.LowHalf[Boot.countGermVM];  realMapLoc: LONG POINTER = LOOPHOLE[CPKernel.mapOffset];  realPageForGerm: CARDINAL = firstFreePage+(256-tempCountGermVM);  virtualPageForGerm: LONG CARDINAL = Boot.pageGerm;  virtualPageForPRequest: LONG CARDINAL = Space.PageFromLongPointer[Boot.pRequest];  realPageForPRequest: CARDINAL = realPageForGerm + Inline.LowHalf[virtualPageForPRequest - virtualPageForGerm];  LoadGerm: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, file: LONG STRING] =    BEGIN    filename: LONG STRING;    stream: Stream.Handle;    filename _ String.CopyToNewString[file, z];    [] _ String.AppendExtensionIfNeeded[@filename, "germ"L, z];    Format.Text[log, "Loading Germ from "L, arg];    Format.Text[log, filename, arg];    Format.Line[log, "."L, arg];    stream _ MStream.ReadOnly[filename, [] ! MStream.Error =>      ERROR CPCommands.Error["Can't read that file"] ];    LoadGermFromStream[log, arg, stream !      UNWIND => BEGIN Stream.Delete[stream]; z.FREE[@filename]; END ];    Stream.Delete[stream];    z.FREE[@filename];    CPCommands.RefreshWindow[];    END;   LoadGermFromStream: PROCEDURE [log: Format.StringProc, arg: LONG POINTER, stream: Stream.Handle] =    BEGIN ENABLE      BEGIN      Stream.EndOfStream => ERROR CPCommands.Error["Truncated germ file"L];      CPKernel.Error => ERROR CPCommands.Error[reason];      END;    buffer: ARRAY [0..Environment.wordsPerPage) OF WORD;    start, stop: System.Pulses;    ms: LONG CARDINAL;    words: LONG CARDINAL _ 0;    pages: CARDINAL _ countRealPages-mapPagesCount-ioRegionPagesCount-256; -- map, ioregion, display    blocks: CARDINAL _ 0;    page: CARDINAL _ Inline.LowHalf[virtualPageForGerm];    from: CP.VirturalMemory _ LOOPHOLE[Boot.pageGerm*Environment.wordsPerPage];    me: MapEntry;    rp: CARDINAL;    WriteMem: PROCEDURE [ra: LONG POINTER, p: LONG POINTER, nwords: CARDINAL] =      BEGIN      CPKernel.WriteMemoryBlock[to: ra, count: nwords, data: p];      blocks _ blocks + 1;      words _ words + nwords;      END;    CPKernel.ResetMap[];    MapIORegion[log, arg];    start _ System.GetClockPulses[];    DO      bytes: CARDINAL;      to: CP.RealMemory;      IF MStream.EndOf[stream] THEN EXIT;      [bytes, , ] _ Stream.GetBlock[        sH: stream,        block: [	  blockPointer: LOOPHOLE[LONG[@buffer]],	  startIndex: 0,          stopIndexPlusOne: Environment.bytesPerPage]];      IF bytes # Environment.bytesPerPage THEN        ERROR CPCommands.Error["Truncated Germ File"L];      to _ MapGermPage[from];      rp _ CARDINAL[Space.PageFromLongPointer[to]];      me _ [entry[          rpLow: CARDINAL[rp MOD 400B], rpHigh: CARDINAL[rp/400B],          w: FALSE, d: FALSE, r: FALSE]];      CPKernel.WriteRealMemory[realMapLoc + page, me.word];      WriteMem[ra: to, p: @buffer, nwords: Environment.wordsPerPage];      pages _ pages - 1;      page _ page + 1;      from _ from + Environment.wordsPerPage;      ENDLOOP;    stop _ System.GetClockPulses[];    ms _ System.PulsesToMicroseconds[[stop - start]]/1000;    Info[log, arg, ms, words, blocks];    MapRemainingPages[log, arg, page, pages];    END;	  LoadBootFile: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, file: LONG STRING, pagesOrbanks: CARDINAL] =    BEGIN    filename: LONG STRING;    stream: Stream.Handle;    pages: Environment.PageCount;    filename _ String.CopyToNewString[file, z];    [] _ String.AppendExtensionIfNeeded[@filename, "boot"L, z];    Format.Text[log, "Loading CP boot file from "L, arg];    Format.Text[log, filename, arg];    Format.Line[log, "."L, arg];    stream _ MStream.ReadOnly[filename, [] ! MStream.Error =>      ERROR CPCommands.Error["Can't read that file"] ];          pages _ countRealPages;  --ignore display memory        LoadBootFileFromStream[log, arg, stream, pages !      UNWIND => BEGIN Stream.Delete[stream]; z.FREE[@filename]; END ];    Stream.Delete[stream];    z.FREE[@filename];    CPCommands.RefreshWindow[];    END;      LoadBootFileFromStream: PROCEDURE [log: Format.StringProc, arg: LONG POINTER, stream: Stream.Handle, pages: Environment.PageCount] =    BEGIN ENABLE      BEGIN      Stream.EndOfStream => ERROR CPCommands.Error["Truncated germ file"L];      CPKernel.Error => ERROR CPCommands.Error[reason];      END;    headerStorage: ARRAY [0..Environment.wordsPerPage) OF WORD;    header: LONG POINTER TO BootFile.Header = LOOPHOLE[LONG[@headerStorage]];    bufferStorage: ARRAY [0..Environment.wordsPerPage) OF WORD;    buffer: LONG POINTER = @bufferStorage;    realPage: Environment.PageCount _ FirstUsablePage[];    WriteMem: PROCEDURE [ra: LONG POINTER, p: LONG POINTER, nwords: CARDINAL] =      BEGIN      CPKernel.WriteNextMemoryBlock[to: ra, count: nwords, data: p];      blocks _ blocks + 1;      words _ words + nwords;      END;    GetRealPage: PROCEDURE [vp: Environment.PageCount] RETURNS [rp: Environment.PageCount] =      BEGIN      IF pages = 0 THEN ERROR CPCommands.Error["Oops, ran out of pages"L];      rp _ realPage;      realPage _ realPage + 1;      SELECT realPage FROM        firstMapPage => realPage _ realPage + mapPagesCount;        ioRegionPageNumber => realPage _ realPage + ioRegionPagesCount;        realPageForGerm => realPage _ realPage + tempCountGermVM;	ENDCASE => NULL;      pages _ pages - 1;      END;    start, stop: System.Pulses;    ms: LONG CARDINAL;    words, blocks: LONG CARDINAL _ 0;    thisRealPage: Environment.PageCount;    lastUsedVMPage: Environment.PageCount _ 0;    countData, countGroup: LONG CARDINAL;    entries: LONG POINTER TO ARRAY [0..0) OF BootFile.MapEntry;        start _ System.GetClockPulses[];        CPKernel.ResetMap[];        IF pages <= (mapPagesCount + tempCountGermVM + ioRegionPagesCount) THEN      ERROR CPCommands.Error["Not enough pages for map (and such)"L];    pages _ pages - mapPagesCount - ioRegionPagesCount - tempCountGermVM;  -- Map, IORegion, Germ    MapIORegion[log, arg];    --pages _ pages - 256;  my page count doesn't include the display bank    [] _ Stream.GetBlock[       sH: stream,       block: [         blockPointer: LOOPHOLE[header], startIndex: 0,         stopIndexPlusOne: Environment.bytesPerPage]];    IF header.version # BootFile.currentVersion THEN      ERROR CPCommands.Error["not (current) bootfile"L];    FOR rp: CARDINAL IN [realPageForGerm..realPageForPRequest] DO  -- initialize the germ's SD vector pages      me: MapEntry;      me _ [entry[  -- Germ's SD        rpLow: rp MOD 400B, rpHigh: rp/400B,        r: TRUE, d: TRUE, w: FALSE]];      CPKernel.WriteRealMemory[realMapLoc + virtualPageForGerm + (rp - realPageForGerm), me.word];    ENDLOOP;    BEGIN  -- write pRequest    pRequestOffset: WORD = Inline.LowByte[Inline.LowHalf[Boot.pRequest]];    pRequest: LONG POINTER TO Boot.Request =       Space.LongPointerFromPage[realPageForPRequest] + pRequestOffset;    request: Boot.Request;    request _ [      action: Boot.bootPhysicalVolume,      location: [deviceType: DeviceTypes.anyPilotDisk, deviceOrdinal: 0, vp: ],      pStartListHeader: header.pStartListHeader,      inLoadMode: ,      session: ];    request.switches[PilotSwitches.hang] _ down;    WriteMem[ra: pRequest, p: @request, nwords: SIZE[Boot.Request]];    END;    IF (countData _ header.countData) > pages THEN      ERROR CPCommands.Error["Not enough pages for Boot file"L];    countGroup _ MIN[countData, BootFile.maxEntriesPerHeader];    entries _ LOOPHOLE[@header.entries];    DO      trailer: LONG POINTER TO BootFile.Trailer = LOOPHOLE[header];      FOR i: LONG CARDINAL IN [0..countGroup) DO        OPEN bfe: entries[IF i > LAST[CARDINAL] THEN ERROR ELSE CARDINAL[i]];        me: MapEntry;        [] _ Stream.GetBlock[          sH: stream,          block: [            blockPointer: buffer,	    startIndex: 0,            stopIndexPlusOne: Environment.bytesPerPage]];        thisRealPage _ GetRealPage[bfe.virtual];        << Perhaps a check should be placed in here for a large "thisRealPage">>        me _ [entry[          rpLow: CARDINAL[thisRealPage MOD 400B], rpHigh: CARDINAL[thisRealPage/400B],          w: bfe.flags.readonly,          d: bfe.flags.dirty, r: bfe.flags.referenced]];        CPKernel.WriteRealMemory[realMapLoc + bfe.virtual, me.word];        WriteMem[          ra: Space.LongPointerFromPage[thisRealPage],          p: buffer, nwords: Environment.wordsPerPage];        lastUsedVMPage _ MAX[lastUsedVMPage, bfe.virtual];        ENDLOOP;      IF (countData _ countData - countGroup) = 0 THEN EXIT;      countGroup _ MIN[countData, BootFile.maxEntriesPerTrailer];      [] _ Stream.GetBlock[        sH: stream,        block: [          blockPointer: LOOPHOLE[trailer],	  startIndex: 0,          stopIndexPlusOne: Environment.bytesPerPage]];      IF header.version # BootFile.currentVersion THEN        ERROR CPCommands.Error["bad trailer version?"L];      entries _ LOOPHOLE[@trailer.entries];      ENDLOOP;    -- Put any extra memory in map following last used mapped VM    WHILE pages > 0 DO      me: MapEntry;      lastUsedVMPage _ lastUsedVMPage + 1;      thisRealPage _ GetRealPage[lastUsedVMPage];      << Perhaps a check should be placed in here for a large "thisRealPage">>      me _ [entry[        rpLow: CARDINAL[thisRealPage MOD 400B], rpHigh: CARDINAL[thisRealPage/400B],        w: FALSE, d: FALSE, r: FALSE]];      CPKernel.WriteRealMemory[realMapLoc + lastUsedVMPage, me.word];      ENDLOOP;    stop _ System.GetClockPulses[];    ms _ System.PulsesToMicroseconds[[stop - start]]/1000;    Info[log, arg, ms, words, blocks];    END;  MapIORegion: PROCEDURE [log: Format.StringProc, arg: LONG POINTER]  =    BEGIN    MapEntryArray: TYPE = ARRAY [0..ioRegionPagesCount) OF MapEntry;    meArray: MapEntryArray;    start, stop: System.Pulses;    ms: LONG CARDINAL;    start _ System.GetClockPulses[];    FOR i: CARDINAL IN [0..ioRegionPagesCount) DO  --map the IORegion      meArray[i] _ [entry[        rpLow: ioRegionPageNumber MOD 400B + i,	rpHigh: ioRegionPageNumber/400B,        r: TRUE, d: TRUE, w: FALSE]];      ENDLOOP;    CPKernel.WriteMemoryBlock[      to: LOOPHOLE[CPKernel.mapOffset+ioRegionVirtPage],      count: SIZE[MapEntryArray], data: @meArray];    stop _ System.GetClockPulses[];    ms _ System.PulsesToMicroseconds[[stop - start]]/1000;    Info[log, arg, ms, SIZE[MapEntryArray], 1];    END;  MapSequence: TYPE = RECORD [    SEQUENCE length: CARDINAL OF MapEntry];    MapRemainingPages: PROCEDURE [log: Format.StringProc, arg: LONG POINTER, page, pages: CARDINAL]  =    BEGIN    rp: CARDINAL _ CARDINAL[      Space.PageFromLongPointer[        MapGermPage[LOOPHOLE[LONG[page]*Environment.wordsPerPage]]]];    me: LONG POINTER TO MapSequence _ Heap.systemZone.NEW[MapSequence[pages]];    index: CARDINAL _ 0;    startPage: CARDINAL;    start, stop: System.Pulses;    ms: LONG CARDINAL;    words, blocks: LONG CARDINAL _ 0;    start _ System.GetClockPulses[];    IF page = ioRegionVirtPage THEN page _ page + ioRegionPagesCount;    startPage _ page;    THROUGH [0..pages) DO       me[index] _ [entry[          rpLow: rp MOD 400B, rpHigh: rp/400B, r: FALSE, d: FALSE, w: FALSE]];      words _ words + SIZE[MapEntry];      index _ index + 1;      page _ page + 1;      rp _ rp + 1;      IF page = ioRegionVirtPage THEN {        CPKernel.WriteMemoryBlock[          to: LOOPHOLE[CPKernel.mapOffset+startPage],          count: index*SIZE[MapEntry], data: @me[0]];        page _ page + ioRegionPagesCount;	startPage _ page;	index _ 0};        IF rp = ioRegionPageNumber THEN rp _ rp + ioRegionPagesCount;      ENDLOOP;    IF index # 0 THEN      CPKernel.WriteMemoryBlock[        to: LOOPHOLE[CPKernel.mapOffset+startPage],        count: index*SIZE[MapEntry], data: @me[0]];    stop _ System.GetClockPulses[];    ms _ System.PulsesToMicroseconds[[stop - start]]/1000;    Info[log, arg, ms, words, blocks];    Heap.systemZone.FREE[@me];    END;  MapGermPage: PROCEDURE [virtural: CP.VirturalMemory] RETURNS [real: CP.RealMemory] =    BEGIN    page: Environment.PageCount _ Space.PageFromLongPointer[virtural];    IF page ~IN [Boot.pageGerm..tempCountGermVM) THEN      ERROR CPCommands.Error["Germ doesn't fit in allocated space"L];    RETURN[Space.LongPointerFromPage[realPageForGerm+page-Boot.pageGerm]];<<    SELECT CPKernel.machine FROM      dlion =>        BEGIN        offset: Environment.PageNumber = 256 + mapPagesCount;  -- 64K Display bank, 16K Map        IF page = 0 OR page = 0FFH THEN ERROR CPCommands.Error["MapGermPage confusion"L];        page _ page + offset;        RETURN[Space.LongPointerFromPage[page]];	END;      dicentra =>        BEGIN	RETURN[virtural];	END;      ENDCASE => ERROR;>>    END;   NoWarning: PROC = INLINE {    SELECT CPKernel.machine FROM dlion => {}; ENDCASE};    FirstUsablePage: PROCEDURE RETURNS [Environment.PageCount] =    BEGIN      RETURN[firstFreePage];    END;      MapEntry: TYPE = MACHINE DEPENDENT RECORD [    SELECT OVERLAID * FROM      word => [word: WORD],      entry => [rpLow: [0..0FFH], r, d, w: BOOLEAN, rpHigh: [0..1FH]],      ENDCASE];      Vacant: PROCEDURE [me: MapEntry] RETURNS [BOOLEAN] =    BEGIN    RETURN[me.w AND me.d AND ~ me.r];    END;      Info: PROCEDURE [log: Format.StringProc, arg: LONG POINTER, ms, words, blocks: LONG CARDINAL] =    BEGIN    Format.Text[log, "It took "L, arg];    Format.LongDecimal[log, ms, arg];    Format.Text[log, " ms to load "L, arg];    Format.LongDecimal[log, words, arg];    Format.Text[log, " words in "L, arg];    Format.LongDecimal[log, blocks, arg];    Format.Text[log, " blocks."L, arg];    IF ms # 0 THEN      BEGIN      Format.Text[log, " ("L, arg];      Format.LongDecimal[log, words*16*1000/ms, arg];      Format.Text[log, " bits/sec)"L, arg];      END;    Format.CR[log, arg];    END;    END.    -- HGM, 14-Feb-83 12:51:33  -- Dennis DEG     ,  3-Jun-83 21:43:29 changed all definitions of type *page from CARDINAL to Environment.PageCount  -- Dennis DEG     , 18-Sep-83 19:40:29 Converted to Klamath 11.0b  -- AeF AEF     ,  5-Dec-84 17:38:56 Made into demo Daybreak version  -- CrF   CRF, 14-Dec-84 12:39:32 Replaced countGermVM with tempCountGermVM for special germ-based Othello for demo (to allow loading larger "germ")  -- JoM    , 16-Jan-85 10:08:42 Restored calls to ResetMap (works now)  -- JoM    , 24-Jan-85 13:57:02 Changed map writes to use WriteRealMemory  -- JGS    , 14-Feb-85 11:39:02 Removed DemoInputOutput. Make put unused memory after germ
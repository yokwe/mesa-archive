-- Copyright (C) 1983, 1985  by Xerox Corporation. All rights reserved. -- last edit by JAC 	 9-Oct-85 14:24:49 -- from CPKernelCSDicentra.mesa, HGM, 13-Nov-83  2:21:27DIRECTORY  Bindweed USING [Error, maxMIs, ReadCPControlStore, WriteCPControlStore],  Environment USING [Byte],  Inline USING [BITSHIFT, BITXOR, LongCOPY],  CPDefs USING [bytesPerMI, RealCS, wordsPerBank, wordsPerMI],  CPKernelDefs USING [ContinueCP, CSBlock, DebuggeeReady, Error, OneMI],  CPKernelConst,  CPKernelOp USING [AddressOutOfRange, SetNewState],  CPMIFormat USING [AD, AF, AS, FS01, FS23, FX, FY, FZ, MI];CPKernelCSDybrk: MONITOR   IMPORTS    Inline, Bindweed, CPKernelDefs, CPKernelOp  EXPORTS CPKernelDefs =  BEGIN OPEN CPKernelConst;    bufferSize: CARDINAL = Bindweed.maxMIs * CPDefs.bytesPerMI;    Nibble: TYPE = CARDINAL [0..16);    WriteControlStore: PUBLIC ENTRY PROCEDURE [real: CPDefs.RealCS, mi: CPMIFormat.MI] =    BEGIN ENABLE UNWIND => NULL;    CPKernelDefs.DebuggeeReady[];    WriteCSInternal[real, mi];    CPKernelDefs.ContinueCP[];    END;      WriteCS: PUBLIC ENTRY PROCEDURE [real: CPDefs.RealCS, mi: CPMIFormat.MI] =    BEGIN ENABLE UNWIND => NULL; WriteCSInternal[real, mi] END;  WriteCSInternal: INTERNAL PROCEDURE [real: CPDefs.RealCS, mi: CPMIFormat.MI] =    BEGIN    realMi: MIReal ¬ VirturalToReal[mi];    IF real ~IN CPDefs.RealCS THEN CPKernelOp.AddressOutOfRange[];    FixParity[@realMi];    WriteMIInternal[real, @realMi]    END;  WriteCSBad: PUBLIC ENTRY PROCEDURE [real: CPDefs.RealCS, mi: CPMIFormat.MI] =    BEGIN ENABLE UNWIND => NULL; WriteCSBadInternal[real, mi] END;  WriteCSBadInternal: INTERNAL PROCEDURE [real: CPDefs.RealCS, mi: CPMIFormat.MI] =    BEGIN    realMi: MIReal ¬ VirturalToReal[mi];    IF real ~IN CPDefs.RealCS THEN CPKernelOp.AddressOutOfRange[];    FixParity[@realMi];    realMi.ep ¬ ~realMi.ep;    WriteMIInternal[real, @realMi]    END;  -- Parity better be right  WriteMIInternal: INTERNAL PROCEDURE [real: CPDefs.RealCS, mi: LONG POINTER TO MIReal] =    BEGIN ENABLE      BEGIN      UNWIND => NULL;      Bindweed.Error =>         SELECT code FROM	  timeout => {CPKernelOp.SetNewState[dead]; CPKernelDefs.Error["Timeout"L]};	  badCheckSum => {CPKernelOp.SetNewState[dead]; CPKernelDefs.Error["Bad checksum"L]};	  ENDCASE => {CPKernelOp.SetNewState[dead]; CPKernelDefs.Error["Bindweed problem"L]};      END;    block: PACKED ARRAY [0..bufferSize) OF Environment.Byte ¬ ALL[0];    Inline.LongCOPY[mi, CPDefs.wordsPerMI, @block];    Bindweed.WriteCPControlStore[real, 1, block];    END;  WriteCSBlock: PUBLIC ENTRY PROCEDURE [count: CARDINAL, clump: LONG POINTER TO CPKernelDefs.CSBlock] =    BEGIN ENABLE UNWIND => NULL;    WriteCSBlockInternal[count, @clump[0]];    END;  WriteCSBlockInternal: INTERNAL PROCEDURE [count: CARDINAL, clump: LONG POINTER TO CPKernelDefs.OneMI] =    BEGIN ENABLE       BEGIN       UNWIND => NULL;       Bindweed.Error =>         SELECT code FROM	  timeout => {CPKernelOp.SetNewState[dead]; CPKernelDefs.Error["Timeout"L]};	  badCheckSum => {CPKernelOp.SetNewState[dead]; CPKernelDefs.Error["Bad checksum"L]};	  ENDCASE => {CPKernelOp.SetNewState[dead]; CPKernelDefs.Error["Bindweed problem"L]};      END;    startAddr: CARDINAL ¬ clump.real;    block: PACKED ARRAY [0..bufferSize) OF Environment.Byte ¬ ALL[0];    finger: POINTER ¬ @block;    FOR i: CARDINAL IN [0..count) DO      real: MIReal ¬ VirturalToReal[clump.mi];      FixParity[@real];      Inline.LongCOPY[@real, CPDefs.wordsPerMI, finger];      finger ¬ finger + CPDefs.wordsPerMI;      clump ¬ clump + SIZE[CPKernelDefs.OneMI];      ENDLOOP;    Bindweed.WriteCPControlStore[startAddr, count, block];    END;  FixParity: PROCEDURE [data: LONG POINTER TO MIReal] =    BEGIN    words: LONG POINTER = data;    parity: WORD ¬ 0;    data.ep ¬ FALSE;    FOR i: CARDINAL IN [0..SIZE[MIReal]) DO      parity ¬ Inline.BITXOR[parity, (words+i)­];      ENDLOOP;    parity ¬ Inline.BITXOR[parity, Inline.BITSHIFT[parity, -8]];    parity ¬ Inline.BITXOR[parity, Inline.BITSHIFT[parity, -4]];    parity ¬ Inline.BITXOR[parity, Inline.BITSHIFT[parity, -2]];    parity ¬ Inline.BITXOR[parity, Inline.BITSHIFT[parity, -1]];    data.ep ¬ LOOPHOLE[parity];    END;      ReadControlStore: PUBLIC ENTRY PROCEDURE [real: CPDefs.RealCS] RETURNS [mi: CPMIFormat.MI] =    BEGIN ENABLE UNWIND => NULL;    CPKernelDefs.DebuggeeReady[];    mi ¬ ReadCSInternal[real];    CPKernelDefs.ContinueCP[];    END;  ReadCS: PUBLIC ENTRY PROCEDURE [real: CPDefs.RealCS] RETURNS [CPMIFormat.MI] =    BEGIN ENABLE UNWIND => NULL; RETURN[ReadCSInternal[real]] END;  ReadCSInternal: INTERNAL PROCEDURE [real: CPDefs.RealCS] RETURNS [CPMIFormat.MI] =    BEGIN ENABLE      BEGIN      UNWIND => NULL;      Bindweed.Error =>         SELECT code FROM	  timeout => {CPKernelOp.SetNewState[dead]; CPKernelDefs.Error["Timeout"L]};	  badCheckSum => {CPKernelOp.SetNewState[dead]; CPKernelDefs.Error["Bad checksum"L]};	  ENDCASE => {CPKernelOp.SetNewState[dead]; CPKernelDefs.Error["Bindweed problem"L]};      END;    csData: PACKED ARRAY [0..CPDefs.bytesPerMI) OF Environment.Byte ¬ ALL[0];    IF real ~IN CPDefs.RealCS THEN CPKernelOp.AddressOutOfRange[];    csData ¬ Bindweed.ReadCPControlStore[real];    RETURN[RealToVirtural[LOOPHOLE[csData, MIReal]]];    END;  MIReal: TYPE = MACHINE DEPENDENT RECORD [    rA, rB: Nibble,    aS: CPMIFormat.AS, aF: CPMIFormat.AF,    aD: CPMIFormat.AD,  --word 0    ep, cIn, enSU, mem: BOOLEAN,    fS01: CPMIFormat.FS01, fS23: CPMIFormat.FS23,    fX: CPMIFormat.FX, fY: CPMIFormat.FY,  --word 1    fZ: CPMIFormat.FZ, inia: [0..CPDefs.wordsPerBank)];  --word 2  -- See also FixupMI in MakeControlStoreMB  VirturalToReal: PROCEDURE [virtural: CPMIFormat.MI] RETURNS [real: MIReal] =    BEGIN    mir: POINTER TO MIReal = @real;    miv: POINTER TO CPMIFormat.MI = @virtural;    BEGIN OPEN miv;    mir­ ¬ [      rA, rB, aS, aF, aD, ep, cIn, enSU, mem, fS01, fS23, fX, fY, fZ, Inline.BITXOR[inia,17B]]    END    END;  RealToVirtural: PROCEDURE [real: MIReal] RETURNS [virtural: CPMIFormat.MI] =    BEGIN    mir: POINTER TO MIReal = @real;    miv: POINTER TO CPMIFormat.MI = @virtural;    BEGIN OPEN mir;    miv­ ¬ [      rA, rB, aS, aF, aD, ep, cIn, enSU, mem, fS01, fS23, fX, fY, fZ, Inline.BITXOR[inia,17B]]    END;    END;  END.-- Log of last edits-- JAC	31-May-85  9:50:30	CP renamed to CPDefs; CPKernel renamed to CPKernelDefs-- JAC	31-May-85 10:08:10	CPKernelConstants renamed to CPKernelConst; rename this module; CPMI renamed to CPMIFormat; CPKernelOps renamed to CPKernelOp-- JAC	10-Jun-85 15:48:21	for new Bindweed-- JAC	 9-Oct-85 14:25:03	import CPKernelConst for change in mailbox
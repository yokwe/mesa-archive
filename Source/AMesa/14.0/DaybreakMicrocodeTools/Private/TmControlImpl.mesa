-- Copyright (C) 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- File: TmControlImpl.mesa-- Last edit: 26-Sep-84 20:38:56 DIRECTORY  Exec USING [AddCommand, DefaultUnloadProc, Handle, Outcome, OutputProc],  Format USING [CR, Decimal, Line, StringProc, Text],  Heap USING [systemZone],    Runtime USING [CallDebugger, GetBcdTime],      String USING [AppendLongNumber, AppendString],  System USING [GetGreenwichMeanTime, GreenwichMeanTime],  Time USING [Append, Unpack],  TmAssembler USING [CreatePassSegment, DeletePassSegment, DeleteStmtSegment, FreePassSpace, Statement, maxArgLength, sizeArgArray, version],  TmControl,  TmFile USING [currentFile, defsFileNames, defsFilesCnt, DeleteSIs, Finish, InitBackupFile, LogLine, outFile, ReplaceExt, sourceFileNames, sourceFilesCnt],  TmModule USING [    InitGlobalEncode, InitGlobalExpTables, InitGlobalFile, InitGlobalLabel,    InitGlobalLTHash, InitGlobalMacroTables, InitGlobalMTSpace, InitGlobalP2Hash,    InitMacroTable, InitGlobalTempSpace, Pass1, Pass2, ProcessCallLine, ReleaseMTSpace],  TmP2Hash USING [InitPass2Space];TmControlImpl: PROGRAM  IMPORTS Exec, Format, Heap, Runtime, String, System, Time, TmAssembler, TmControl, TmFile, TmModule, TmP2Hash  EXPORTS  TmAssembler, TmControl =  BEGIN  FatalError: PUBLIC ERROR = CODE;  UserAbort: PUBLIC ERROR = CODE;  argBuf: PUBLIC ARRAY [0..TmAssembler.sizeArgArray] OF LONG STRING;  BeginTime: PUBLIC System.GreenwichMeanTime;  config: PUBLIC INTEGER;  curTime: PUBLIC LONG CARDINAL;  curTask: PUBLIC CARDINAL;  debugStop: PUBLIC BOOLEAN;  endStop: PUBLIC BOOLEAN;  errorsExist: PUBLIC BOOLEAN;  errorsInThisFile: PUBLIC BOOLEAN;  execHandle: PUBLIC Exec.Handle;  FinishTime: PUBLIC System.GreenwichMeanTime;  ifsInThisFile: PUBLIC BOOLEAN;  linkLoad: PUBLIC BOOLEAN;  linkVal: PUBLIC [0..16);      noFinalFiles: PUBLIC BOOLEAN;  noFTfile: PUBLIC BOOLEAN;  numArgs: PUBLIC CARDINAL [0..TmAssembler.sizeArgArray];  statement: PUBLIC TmAssembler.Statement;  tty: Format.StringProc;  version: PUBLIC LONG STRING ¬ [20];   InitGlobal: PROCEDURE [h: Exec.Handle] =    BEGIN    i: CARDINAL;    TmAssembler.version.length ¬ 0;    Time.Append[s: TmAssembler.version, unpacked: Time.Unpack[time: Runtime.GetBcdTime[]], zone: FALSE];    FOR i IN [0..TmAssembler.sizeArgArray] DO      argBuf[i] ¬ Heap.systemZone.NEW [StringBody[TmAssembler.maxArgLength]]; ENDLOOP;    -- argBuf is initialized in BreakPhraseMain when passed NIL. Note curS    config ¬ 0;    curTask ¬ 0;    debugStop ¬ FALSE;    endStop ¬ FALSE;    errorsExist ¬ FALSE;    errorsInThisFile ¬ FALSE;    execHandle ¬ h;    ifsInThisFile ¬ FALSE;    linkLoad ¬ FALSE;            noFinalFiles ¬ FALSE;    noFTfile ¬ FALSE;    statement ¬ TmAssembler.Statement[];    tty ¬ Exec.OutputProc[h];    END;  -- InitGlobal  Finish: PROCEDURE[outcome: Exec.Outcome]  =    BEGIN    i: CARDINAL;    TmFile.Finish[outcome];            FOR i IN [0..TmAssembler.sizeArgArray] DO      Heap.systemZone.FREE[@argBuf[i]]; ENDLOOP;        TmAssembler.DeletePassSegment;    FOR i IN [0..TmFile.defsFilesCnt) DO      Heap.systemZone.FREE[@TmFile.defsFileNames[i]]; ENDLOOP;    FOR i IN [0..TmFile.sourceFilesCnt) DO      Heap.systemZone.FREE[@TmFile.sourceFileNames[i]]; ENDLOOP;    IF outcome # normal THEN {      TmModule.ReleaseMTSpace;       TmAssembler.DeleteStmtSegment};          END;  -- Finish  Driver: PROCEDURE [h: Exec.Handle, clientData: LONG POINTER] RETURNS [    o: Exec.Outcome ¬ normal] =    BEGIN    InitGlobal[h];    Assemble[      ! FatalError => {o ¬ error; CONTINUE};      UserAbort => {o ¬ abort; CONTINUE}; UNWIND => {Finish[o]; REJECT}];    TtyCR[];    IF ~errorsExist AND o = normal THEN {      TmFile.LogLine[" "L]; TmFile.LogLine["Done"L]; TtyLine["Done"L];       TtyLine["No errors"]};    IF errorsExist THEN {      TmFile.LogLine[" "L]; TmFile.LogLine["Errors"L];      TtyLine2["Errors. See File "L, TmFile.ReplaceExt[TmFile.outFile, "er"L]];      IF o = normal THEN o ¬ error};    IF endStop THEN Runtime.CallDebugger["Processing Complete"L];    Finish[o];    END;  -- End of Driver  Assemble: PROCEDURE =    BEGIN        TotalTime: LONG CARDINAL;    str: LONG STRING ¬ [40];    str.length ¬ 0;    String.AppendString[str, "MassDaybreak of "];    String.AppendString[str, TmAssembler.version];          TtyLine[str];                TmModule.InitGlobalTempSpace[];        TmModule.InitGlobalLTHash[];    TmModule.InitGlobalMTSpace[];            TmModule.InitGlobalExpTables[];    TmModule.InitGlobalMacroTables[];    TmModule.InitGlobalEncode[];    TmModule.InitGlobalFile[];    TmModule.InitGlobalLabel[];    TmModule.InitGlobalP2Hash[];    TmModule.ProcessCallLine[];    TmModule.InitMacroTable[]; -- Must follow ProcessCallLine     TmFile.InitBackupFile[];    TmAssembler.CreatePassSegment;       TmFile.LogLine[str];        IF debugStop THEN Runtime.CallDebugger["About to process"L];    TtyLine["Pass 1 ..."L];    TmModule.Pass1[];    TtyLine[" "L];    TmAssembler.FreePassSpace;    TmFile.currentFile.length ¬ 0;  --no longer building si's            IF NOT errorsExist THEN {      TmControl.BeginTime ¬ System.GetGreenwichMeanTime[];      TmP2Hash.InitPass2Space[];      str.length ¬ 0;      TtyText["Pass 2 ... "];              TmModule.Pass2[];          TmControl.FinishTime ¬ System.GetGreenwichMeanTime[];      TotalTime ¬ TmControl.FinishTime - TmControl.BeginTime;      String.AppendLongNumber[str,TotalTime,10];      String.AppendString[str," second(s)"L];      TtyLine[str]}     ELSE TmFile.DeleteSIs;  --Delete .si's with errors and conditional code    END;  TtyCR: PUBLIC PROCEDURE[] = {Format.CR[tty]};  TtyDec: PUBLIC PROCEDURE [i: INTEGER] = {Format.Decimal[tty, i]};  TtyLine: PUBLIC PROCEDURE [s: LONG STRING] = {Format.Line[tty, s]};  TtyLine2: PUBLIC PROCEDURE [s1, s2: LONG STRING] = {    Format.Text[tty, s1]; Format.Line[tty, s2]};  TtyText: PUBLIC PROCEDURE [s: LONG STRING] = {Format.Text[tty, s]};  TtyText2: PUBLIC PROCEDURE [s1, s2: LONG STRING] = {    Format.Text[tty, s1]; Format.Text[tty, s2]};  --main line code  Exec.AddCommand[name: "MassDaybreak.~"L, proc: Driver, unload: Exec.DefaultUnloadProc];  END...  -- Log   -- 17-Jul-82 19:41:37 - ETN        - TrinityMass Version 1   -- 19-Jan-83 14:13:09 - ETN        - Sierra.  Change Heap.MakeString and  --                                   Heap.FreeString to Heap.systemZone.NEW  --                                   and Heap.systemZone.FREE.      --                                   Add clientData: to Driver: PROCEDURE   -- 13-Jul-83 10:12:03 - JAC        - Add pass segments   -- 14-Jul-83 11:02:03 - JAC        - Eliminate use of mySpace and mySpace2  -- 15-Jul-83 11:11:29 - JAC        - Move CreatePassSegment so that   --    InitGlobalLTHash could initialize the hashTable  -- 20-Jul-83  9:53:55- JAC         - Syntax error  -- 22-Jul-83 15:10:57 - JAC        - Move InitGlobalTempSpace before CreatePassSegment because it makes pointer NIL  --  3-Aug-83 14:50:34 - JAC        - Add proc to obtain handles to files to back up pass and stmt space  -- 15-Aug-83  9:34:43 - JAC        - Move CreatePassSegment and clean up to eliminate space leaks and initalize errorsInThisFile and ifsInThisFile  -- 29-Sep-83  0:45:04 - DEG     	- removed call to TmLabel.ReleaseLTSpace since it is not implemented by TmLabelImpl  -- 26-Jan-84 13:52:03 - JAC        - Do not attempt the 2nd pass if the 1st pass has produced errors  -- 29-Mar-84 11:59:48 - JoM        - Add DefaultUnloadProc to call to Exec.AddCommand (so Mass can be unloaded)  -- Time: 26-Sep-84 20:38:51	By: DEG     	Action: Added copyright notice and rebuild for 11.1 release.  -- 27-Oct-87 10:31:48 JWF	change to register MassDaybreak instead of Mass with Exec.
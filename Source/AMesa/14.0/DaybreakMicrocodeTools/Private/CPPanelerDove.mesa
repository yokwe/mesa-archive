-- Copyright (C) 1985  by Xerox Corporation. All rights reserved. -- Last edit by JAC	11-Jun-85 10:17:37	CPPanel became CPPanelSW-- Last edit by JAC	 7-Jun-85 11:31:33	convert to new PanelSW-- CPPanelerDove.mesa, JoM    , 28-Jan-85 15:34:53DIRECTORY  Heap USING [systemZone],  Inline USING [HighHalf, LowHalf],  String USING [AppendLongNumber, AppendNumber, AppendString, CopyToNewString],  Tool USING [AddThisSW],  ToolWindow USING [CreateSubwindow, nullBox],  Window USING [Box, Handle],  WindowFont USING [CharWidth, defaultFont, FontHeight, Handle],  CP USING [Cycle, RealCS, RReg, UReg],  CPMI USING [MI],  CPKernel USING [    Error, InKernel, ReadCS, ReadIOIn, ReadLink, ReadMap, ReadOther, ReadPC, ReadRealMemory,    ReadRAndRH, ReadRH, ReadRReg, ReadUReg, ReadVirturalMemory,    WriteCS, WriteIOOut, WriteLink, WriteMap, WriteOther, WritePC, WriteRAndRH, WriteRealMemory, WriteRH,    WriteRReg, WriteUReg, WriteVirturalMemory],  CPPanelSW USING [],  CPSymbols USING [    AppendMI, AppendSymbol, Error, Eval, nullRealCS,    Symbol, VirturalCS, VirturalToRealCS],  IOPKernel USING [InKernel],  PanelSW USING [    Clear, ClientError, ClientProcsObject, Create, Destroy, FreeRSProcType,    LHTypeInEvalProcType, ModifyTypeInProcType, Handle,    ReadTargetProcType, RegisterSpec,    RHTypeInEvalProcType, SWType, TileLayout, Update];CPPanelerDove: PROGRAM  IMPORTS    Heap, Inline, String,    Tool, ToolWindow, WindowFont,    CPKernel, CPSymbols, IOPKernel, PanelSW  EXPORTS CPPanelSW =  BEGIN    z: UNCOUNTED ZONE = Heap.systemZone;  messages: Window.Handle = NIL;    font: WindowFont.Handle = WindowFont.defaultFont;  fontHeight: INTEGER = WindowFont.FontHeight[font];  digitWidth: INTEGER = WindowFont.CharWidth['0, font];  lineHeight: CARDINAL = fontHeight + 2;  tileHeight: CARDINAL = lineHeight;  tileRows: CARDINAL = 18;  tileColumns: CARDINAL = 3;  tileFlagLength: CARDINAL = digitWidth;  tileLVLength: CARDINAL = 12*digitWidth + 4;  tileRVLength: CARDINAL = 7*digitWidth + 5;  tileLength: CARDINAL = tileFlagLength + tileLVLength + tileRVLength;  tileBoxWidth: CARDINAL = tileColumns*tileLength + 12*digitWidth;  tilesPerRow: CARDINAL = tileBoxWidth/tileLength;  numTiles: CARDINAL = tileRows*tilesPerRow;  rowLayout: ARRAY [0..tileColumns) OF PanelSW.TileLayout _ [    [tileFlagLength, tileLVLength, tileRVLength],    [tileFlagLength, tileLVLength, tileRVLength],    [tileFlagLength, tileLVLength, tileRVLength + 21*digitWidth] ];  panelProcs: PanelSW.ClientProcsObject _ [    FreeRS, LHTypeInEval, NIL, ReadTarget, RHTypeInEval];  panel: PanelSW.Handle _ NIL;  RegisterSpec: TYPE = LONG POINTER TO RegisterSpecObject;  RegisterSpecObject: TYPE = CPSymbols.Symbol;  AbsToRep: PROCEDURE [rs: PanelSW.RegisterSpec] RETURNS [RegisterSpec] = INLINE    BEGIN RETURN[LOOPHOLE[rs, RegisterSpec]] END;  RepToAbs: PROCEDURE [rs: RegisterSpec] RETURNS [PanelSW.RegisterSpec] = INLINE    BEGIN RETURN[LOOPHOLE[rs, PanelSW.RegisterSpec]] END;  FreeRS: PanelSW.FreeRSProcType = BEGIN z.FREE[@rs]; END;  AllocateRegisterSpec: PROCEDURE [value: CPSymbols.Symbol]    RETURNS [PanelSW.RegisterSpec] =    BEGIN    rs: RegisterSpec;    rs _ z.NEW[CPSymbols.Symbol];    rs^ _ value;    RETURN[RepToAbs[rs]];    END;  ReadTarget: PanelSW.ReadTargetProcType =    BEGIN    myrs: RegisterSpec = AbsToRep[rs];    value: LONG CARDINAL;    s _ NIL;    IF rs = NIL THEN RETURN;    IF ~IOPKernel.InKernel[] THEN RETURN;    IF ~CPKernel.InKernel[] THEN RETURN;    BEGIN ENABLE CPKernel.Error => ERROR PanelSW.ClientError[unknown, reason];    WITH myrs SELECT FROM      number => ERROR;      link => value _ CPKernel.ReadLink[link];      realCS =>        BEGIN	mi: CPMI.MI _ CPKernel.ReadCS[real];        s _ z.NEW[StringBody[30]];	CPSymbols.AppendMI[s, mi];	RETURN;	END;      virtCS =>        BEGIN	real: CP.RealCS;	mi: CPMI.MI;	[real, ] _ CPSymbols.VirturalToRealCS[virt];        s _ z.NEW[StringBody[30]];	IF real = CPSymbols.nullRealCS THEN	  BEGIN	  String.AppendString[s, "????"L];	  RETURN;	  END;	mi _ CPKernel.ReadCS[real];	CPSymbols.AppendMI[s, mi];	RETURN;	END;      rReg => value _ CPKernel.ReadRReg[r];      rH => value _ CPKernel.ReadRH[r];      rAndRh => value _ LOOPHOLE[CPKernel.ReadRAndRH[r]];      uReg => value _ CPKernel.ReadUReg[u];      ioIn => value _ CPKernel.ReadIOIn[io];      ioOut => ERROR PanelSW.ClientError[unknown, "Can't read output registers"L];      map => value _ CPKernel.ReadMap[map];      real => value _ CPKernel.ReadRealMemory[real];      virt => value _ CPKernel.ReadVirturalMemory[virt];      other => value _ CPKernel.ReadOther[other];      pc => value _ CPKernel.ReadPC[];      ENDCASE => ERROR;    END;    s _ z.NEW[StringBody[16]];    IF Inline.HighHalf[value] # 0 THEN      BEGIN      low: CARDINAL = Inline.LowHalf[value];      String.AppendNumber[s, Inline.HighHalf[value], 16];      SELECT TRUE FROM        (low > 0FFFH) => NULL;        (low > 0FFH) => String.AppendString[s, "0"L];        (low > 0FH) => String.AppendString[s, "00"L];        ENDCASE => String.AppendString[s, "000"L];      String.AppendLongNumber[s, low, 16];      END    ELSE String.AppendLongNumber[s, value, 16];    END;  RHTypeInEval: PanelSW.RHTypeInEvalProcType =    BEGIN    myrs: RegisterSpec = AbsToRep[rs];    symbol: CPSymbols.Symbol;        display _ NIL;    IF rs = NIL OR typeIn = NIL OR typeIn.length = 0 THEN RETURN;    IF ~IOPKernel.InKernel[] THEN RETURN;    IF ~CPKernel.InKernel[] THEN RETURN;    symbol _ CPSymbols.Eval[typeIn !      CPSymbols.Error => ERROR PanelSW.ClientError[unknown, reason] ];    BEGIN ENABLE CPKernel.Error => ERROR PanelSW.ClientError[unknown, reason];    WITH myrs SELECT FROM      link => CPKernel.WriteLink[link, ExtractNumber[symbol]];      realCS => CPKernel.WriteCS[real, ExtractMi[symbol]];      virtCS =>        BEGIN	real: CP.RealCS;	[real, ] _ CPSymbols.VirturalToRealCS[virt];	IF real # CPSymbols.nullRealCS	  THEN CPKernel.WriteCS[real, ExtractMi[symbol]];	END;      rReg => CPKernel.WriteRReg[r, ExtractNumber[symbol]];      rH => CPKernel.WriteRH[r, ExtractNumber[symbol]];      rAndRh => CPKernel.WriteRAndRH[r, ExtractLongNumber[symbol]];      uReg => CPKernel.WriteUReg[u, ExtractNumber[symbol]];      ioIn => ERROR PanelSW.ClientError[unknown, "Can't write input register"L];      ioOut => CPKernel.WriteIOOut[io, ExtractNumber[symbol]];      map => CPKernel.WriteMap[map, ExtractNumber[symbol]];      real => CPKernel.WriteRealMemory[real, ExtractNumber[symbol]];      virt => CPKernel.WriteVirturalMemory[virt, ExtractNumber[symbol]];      other => CPKernel.WriteOther[other, ExtractNumber[symbol]];      pc => CPKernel.WritePC[ExtractNumber[symbol]];      ENDCASE => ERROR;    END;    display _ ReadTarget[rs, TRUE];    END;    ExtractRealCS: PROCEDURE [symbol: CPSymbols.Symbol] RETURNS [CP.RealCS] =    BEGIN    WITH symbol SELECT FROM      number => RETURN[Inline.LowHalf[n]];      realCS => RETURN[real];      virtCS =>        BEGIN	real: CP.RealCS;	cycle: CP.Cycle;	[real, cycle] _ CPSymbols.VirturalToRealCS[virt];	IF real = CPSymbols.nullRealCS THEN	  ERROR PanelSW.ClientError[unknown, "Can't translate that address to a .CR"L];      	RETURN[real];	END;      ENDCASE;    ERROR PanelSW.ClientError[unknown, "Unreasonable source/dest combination"L];    END;    ExtractNumber: PROCEDURE [symbol: CPSymbols.Symbol] RETURNS [WORD] =    BEGIN    WITH symbol SELECT FROM      number => RETURN[Inline.LowHalf[n]];      real => RETURN[CPKernel.ReadRealMemory[real]];      virt => RETURN[CPKernel.ReadVirturalMemory[virt]];      ENDCASE;    ERROR PanelSW.ClientError[unknown, "Unreasonable source/dest combination"L];    END;    ExtractMi: PROCEDURE [symbol: CPSymbols.Symbol] RETURNS [CPMI.MI] =    BEGIN    WITH symbol SELECT FROM      mi => RETURN[mi];      ENDCASE;    ERROR PanelSW.ClientError[unknown, "Unreasonable source/dest combination"L];    END;  ExtractLongNumber: PROCEDURE [symbol: CPSymbols.Symbol] RETURNS [LONG UNSPECIFIED] =    BEGIN    WITH symbol SELECT FROM      number => RETURN[n];      ENDCASE;    ERROR PanelSW.ClientError[unknown, "Unreasonable source/dest combination"L];    END;  LHTypeInEval: PanelSW.LHTypeInEvalProcType =    BEGIN    value: CPSymbols.Symbol;    display _ NIL;    newRs _ NIL;    IF typeIn = NIL OR typeIn.length = 0 THEN RETURN;    value _ CPSymbols.Eval[typeIn !      CPSymbols.Error => ERROR PanelSW.ClientError[unknown, reason] ];    WITH value SELECT FROM      number => value _ [virt[LOOPHOLE[n]]];      ENDCASE => NULL;    newRs _ AllocateRegisterSpec[value];    IF normalize THEN      BEGIN      temp: STRING _ [200];      CPSymbols.AppendSymbol[temp, value];      display _ String.CopyToNewString[temp, z];      END    ELSE display _ String.CopyToNewString[typeIn, z];    END;    MakePanelSW: PUBLIC PROCEDURE [    parent: Window.Handle,    err: Window.Handle,    modifyTypeIn: PanelSW.ModifyTypeInProcType,    typeIn: LONG POINTER TO LONG STRING] RETURNS [psw: Window.Handle] =    BEGIN    box: Window.Box _ ToolWindow.nullBox;    box.dims.h _ tileRows*tileHeight;    panelProcs.modifyTypeIn _ modifyTypeIn;    psw _ ToolWindow.CreateSubwindow[parent: parent, box: box];    panel _ PanelSW.Create[      psw, err, numTiles, DESCRIPTOR[rowLayout], @panelProcs, typeIn, NIL, , ];    Tool.AddThisSW[window: parent, sw: psw, swType: PanelSW.SWType[]];    END;      Destroy: PUBLIC PROCEDURE =    BEGIN    IF panel # NIL THEN PanelSW.Destroy[panel];    panel _ NIL;    END;      GetPanel: PUBLIC PROCEDURE RETURNS [PanelSW.Handle] = BEGIN RETURN[panel]; END;      Clear: PUBLIC PROCEDURE = BEGIN IF panel # NIL THEN PanelSW.Clear[panel]; END;      Refresh: PUBLIC PROCEDURE = BEGIN IF panel # NIL THEN PanelSW.Update[panel] END;      Initialize: PUBLIC PROCEDURE =    BEGIN    IF panel # NIL THEN PanelSW.Clear[panel];    END;      END.
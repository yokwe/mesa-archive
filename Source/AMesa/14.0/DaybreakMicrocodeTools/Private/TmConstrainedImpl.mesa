-- Copyright (C) 1982, 1984, 1985  by Xerox Corporation. All rights reserved. -- File: TmConstrainedImpl.mesa    -- Last edit: JoM     24-Jan-85 16:52:20DIRECTORY  Ascii USING [CR],  Inline USING [BITAND, BITOR],  String USING [AppendChar, AppendNumber, AppendString],  TmAssembler,  TmFile USING [LogErrLine],  TmLabel,  TmP2Hash USING [    bad, errorLevel, ia7Array, miRtoV, miVtoR, Not, realMI, Reserved];TmConstrainedImpl: PROGRAM  IMPORTS Inline, String, TmFile, TmLabel, TmP2Hash EXPORTS TmLabel =  BEGIN OPEN TmLabel, TmAssembler;  ia70: CARDINAL;  ia71: CARDINAL;  AllocateConstrained: PROCEDURE [ca: LONG POINTER TO ConstraintAttribute] =    BEGIN    anon: MiSeqNum;    anonoff: CARDINAL [0..15];    base: CARDINAL;    blockSize: CARDINAL;    ccCur: LONG POINTER TO ConstraintChain;    ccDone: LONG POINTER TO ConstraintChain ¬ NIL;    ccOld: LONG POINTER TO ConstraintChain;    ccToDo: LONG POINTER TO ConstraintChain;    errorMsgSent: BOOLEAN ¬ FALSE;    i, j, k: CARDINAL;    mapCur: ARRAY [0..16) OF MiSeqNum ¬ ALL[Empty];    mask: INTEGER;    modCur: ModuloIndex;    myia7: ia7Type;    newInx: INTEGER;    stuck: BOOLEAN;    MoveCC: PROCEDURE =      -- this procedure is used to move a constraint chain (ccCur) from the chain of ccToDo to the chain of ccDone.  ccCur and ccOld are also updated.      BEGIN      ccTemp: LONG POINTER TO ConstraintChain ¬ ccCur;      -- now move ccCur from ccToDo to ccDone      IF ccToDo # ccCur THEN        BEGIN ccOld.nextConstraint ¬ ccTemp.nextConstraint; END      ELSE        BEGIN ccToDo ¬ ccTemp.nextConstraint; ccOld ¬ ccTemp.nextConstraint; END;      ccCur ¬ ccTemp.nextConstraint;      ccTemp.nextConstraint ¬ ccDone;      ccDone ¬ ccTemp;      END;  -- end MoveCC    AllocErr: PROCEDURE [type: {ia7, abs, block, no}, mi1, mi2: MiSeqNum] =      BEGIN      Estr: LONG STRING ¬ [120];      Estr.length ¬ 0;      IF TmP2Hash.errorLevel < TmP2Hash.bad THEN        TmFile.LogErrLine["Allocation Errors:"L];      TmP2Hash.errorLevel ¬ 200;      errorMsgSent ¬ TRUE;      SELECT type FROM        abs =>          BEGIN          String.AppendString[Estr, "Allocation Abs Conflict between "L];          AppendSymbolName[Estr, mi1];          String.AppendString[Estr, " and "L];          IF mi2 # TmP2Hash.Reserved THEN AppendSymbolName[Estr, mi2]          ELSE String.AppendString[Estr, "Reserve clause "L];          END;        ia7 =>          BEGIN          String.AppendString[Estr, "ia7 restriction of  "L];          AppendSymbolName[Estr, mi1];          String.AppendString[Estr, " not performed."L];          END;        block =>          BEGIN          String.AppendString[Estr, "Could not allocate block containing "L];          AppendSymbolName[Estr, mi1];          END;        no =>          BEGIN          String.AppendString[Estr, "No place for block containing "L];          AppendSymbolName[Estr, mi1];          END;        ENDCASE;      TmFile.LogErrLine[Estr];      PrintBlockData[ccToDo, ccDone];      END;  -- end AllocErr    UNTIL ca = NIL DO      ccDone ¬ NIL;      BEGIN      ccCur ¬ ca.constraints;      IF ca.maxModulo = maxmaxModulo THEN        BEGIN  -- abs loop        ccToDo ¬ ccCur;        ccOld ¬ ccCur;        modCur ¬ ca.maxModulo;        UNTIL ccCur = NIL DO  -- place first abs          IF ccCur.modulo = modCur THEN            BEGIN            IF TmP2Hash.miRtoV[ccCur.offset] # Empty              AND TmP2Hash.miRtoV[ccCur.offset] # ccCur.miIndex1 THEN              AllocErr[abs, ccCur.miIndex1, TmP2Hash.miRtoV[ccCur.offset]]            ELSE              BEGIN              TmP2Hash.miRtoV[ccCur.offset] ¬ ccCur.miIndex1;              TmP2Hash.miVtoR[ccCur.miIndex1] ¬ ccCur.offset;              END;            MoveCC[];            END          ELSE BEGIN ccOld ¬ ccCur; ccCur ¬ ccCur.nextConstraint; END;          ENDLOOP;  -- end place first abs        -- reprocess original chain, look for labels bound to allocated ones        stuck ¬ FALSE;        UNTIL ccToDo = NIL DO  -- linked to abs outer loop          IF stuck THEN GOTO AllocError1;          ccCur ¬ ccToDo;          ccOld ¬ ccCur;          stuck ¬ TRUE;          UNTIL ccCur = NIL DO  -- linked to abs inner loop            IF TmP2Hash.miVtoR[ccCur.miIndex2] # TmP2Hash.Not THEN              BEGIN              IF TmP2Hash.miVtoR[ccCur.miIndex1] # TmP2Hash.Not THEN                BEGIN                -- both labels already allocated                MoveCC[];                stuck ¬ FALSE;                END              ELSE                BEGIN                -- miIndex2 has been allocated, miIndex 1 has not                mask ¬                  SELECT ccCur.modulo FROM                    1 => -2,                    2 => -4,                    3 => -8,                    4 => -16,                    ENDCASE => 0;                newInx ¬ Inline.BITOR[                  ccCur.offset, Inline.BITAND[                  TmP2Hash.miVtoR[ccCur.miIndex2], mask]];                IF TmP2Hash.miRtoV[newInx] # Empty                  AND TmP2Hash.miRtoV[newInx] # ccCur.miIndex1 THEN                  AllocErr[abs, ccCur.miIndex1, TmP2Hash.miRtoV[newInx]]                ELSE                  BEGIN                  TmP2Hash.miRtoV[newInx] ¬ ccCur.miIndex1;                  TmP2Hash.miVtoR[ccCur.miIndex1] ¬ newInx;                  END;                MoveCC[];                stuck ¬ FALSE;                END;              END            ELSE              BEGIN              -- label 2 has not been allocated              -- it is safe to not look at label 1 in this situation except for some pathological situations with multiple at's per m-i.              ccOld ¬ ccCur;              ccCur ¬ ccCur.nextConstraint;              END;            ENDLOOP;  -- end linked to abs inner loop          ENDLOOP;  -- end linked to abs outer loop        GOTO Verify;  -- absolute chain all allocated        END;  -- end abs loop      ccToDo ¬ ccCur;      ccOld ¬ ccCur;      modCur ¬ ca.maxModulo;      anon ¬ Empty;      FOR j IN [0..16) DO mapCur[j] ¬ Empty ENDLOOP;      UNTIL ccCur = NIL DO  -- init mapCur loop        IF ccCur.modulo = modCur THEN          BEGIN          IF ccCur.miIndex1 < TmP2Hash.realMI THEN            IF (mapCur[ccCur.offset] # Empty) AND (mapCur[ccCur.offset] # ccCur.miIndex1) THEN	      GOTO AllocError5	    ELSE mapCur[ccCur.offset] ¬ ccCur.miIndex1          ELSE {anon ¬ ccCur.miIndex1; anonoff ¬ ccCur.offset; };          MoveCC[];          END        ELSE BEGIN ccOld ¬ ccCur; ccCur ¬ ccCur.nextConstraint; END;        ENDLOOP;  -- end init mapCur loop      -- reprocess original chain, look for labels bound to allocated ones      stuck ¬ FALSE;      UNTIL ccToDo = NIL DO  -- cc outer loop        IF stuck THEN GOTO AllocError2;        ccCur ¬ ccToDo;        ccOld ¬ ccCur;        stuck ¬ TRUE;        UNTIL ccCur = NIL DO  -- cc inner loop          k ¬ 16;          FOR j IN [0..15] DO IF mapCur[j] = ccCur.miIndex2 THEN k ¬ j ENDLOOP;          IF k = 16 THEN            BEGIN            IF ccCur.miIndex2 # anon THEN {              ccOld ¬ ccCur; ccCur ¬ ccCur.nextConstraint; LOOP; }            ELSE k ¬ anonoff;            END;          mask ¬ SELECT ccCur.modulo FROM 1 => -2, 2 => -4, 3 => -8, ENDCASE => 0;          newInx ¬ Inline.BITOR[ccCur.offset, Inline.BITAND[k, mask]];          IF mapCur[newInx] # Empty AND mapCur[newInx] # ccCur.miIndex1 THEN            GOTO AllocError3;          mapCur[newInx] ¬ ccCur.miIndex1;          stuck ¬ FALSE;          MoveCC[];          ENDLOOP;  -- end cc inner loop        ENDLOOP;  -- end cc outer loop      -- mapCur now contains all the indecis from the constraint block      -- now find a place for the block      blockSize ¬        SELECT ca.maxModulo FROM 1 => 2, 2 => 4, 3 => 8, 4 => 16, ENDCASE => 16;      k ¬ 16/blockSize;      j ¬ 0;      myia7 ¬        SELECT ca.ia7 FROM          f => f,          t => t,          ENDCASE => SELECT TRUE FROM ia70 > ia71 => f, ENDCASE => t;      DO  -- block advance loop        IF myia7 = f AND Inline.BITAND[j*blockSize, 16] # 0 THEN j ¬ j + k;        IF myia7 = t AND Inline.BITAND[j*blockSize, 16] = 0 THEN j ¬ j + k;        base ¬ j*blockSize;        IF base >= 4096 THEN          BEGIN          IF ca.ia7 # x THEN GOTO AllocError4;          IF (myia7 = (SELECT TRUE FROM ia70 > ia71 => f, ENDCASE => t)) THEN            BEGIN j ¬ 0; myia7 ¬ SELECT myia7 FROM t => f, ENDCASE => t; LOOP; END          ELSE GOTO AllocError4;          END;        BEGIN        FOR i IN [0..blockSize) DO  -- check loop          IF TmP2Hash.miRtoV[base + i] # Empty AND mapCur[i] # Empty THEN            GOTO NextBlock;          ENDLOOP;  -- end check loop        FOR i IN [0..blockSize) DO  -- place loop          IF mapCur[i] # Empty THEN            BEGIN            IF TmP2Hash.miVtoR[mapCur[i]] # TmP2Hash.Not THEN	    --multiple constraints on this address => allocation error	      GOTO AllocError5	    ELSE TmP2Hash.miVtoR[mapCur[i]] ¬ base + i;            TmP2Hash.miRtoV[base + i] ¬ mapCur[i];            END;          ENDLOOP;  -- end place loop        EXIT;        EXITS NextBlock => BEGIN j ¬ j + 1; LOOP; END;        END;        ENDLOOP;  -- end block advance loop      IF ca.ia7 = x THEN        FOR i IN [0..blockSize) DO          IF mapCur[i] # Empty THEN            SELECT myia7 FROM f => ia70 ¬ ia70 - 1; ENDCASE => ia71 ¬ ia71 - 1;          ENDLOOP;      GOTO Verify;      EXITS        AllocError1 => AllocErr[block, ccToDo.miIndex1, Empty];        AllocError2 => AllocErr[block, ccToDo.miIndex1, Empty];        AllocError3 => AllocErr[block, ccCur.miIndex1, Empty];        AllocError4 => AllocErr[no, ccDone­.miIndex1, Empty];        AllocError5 => AllocErr[block, ccDone­.miIndex1, Empty];        Verify =>          BEGIN  -- verify operatin          ccCur ¬ ccDone;          ccToDo ¬ ccCur;          ccOld ¬ ccCur;          ccDone ¬ NIL;          errorMsgSent ¬ FALSE;          UNTIL (ccCur = NIL) OR errorMsgSent DO  -- verify loop            -- now verify that all constraint and ia7 restrictions are satisfied            mask ¬              SELECT ccCur.modulo FROM                5 => 4095,                4 => 15,                3 => 7,                2 => 3,                1 => 1,                ENDCASE => 1;            IF TmP2Hash.miVtoR[ccCur.miIndex1] = TmP2Hash.Not THEN {              AllocErr[block, ccCur.miIndex1, Empty]; MoveCC; LOOP; };            IF TmP2Hash.miVtoR[ccCur.miIndex2] = TmP2Hash.Not THEN              BEGIN              IF ccCur.miIndex2 >= TmP2Hash.realMI THEN                TmP2Hash.miVtoR[ccCur.miIndex2] ¬ TmP2Hash.miVtoR[ccCur.miIndex1]              ELSE AllocErr[block, ccCur.miIndex2, Empty];              END;            IF (ccCur.miIndex2 < TmP2Hash.realMI)              AND                (Inline.BITAND[TmP2Hash.miVtoR[ccCur.miIndex1], mask] #                  ccCur.offset                  OR Inline.BITOR[TmP2Hash.miVtoR[ccCur.miIndex1], mask] #                    Inline.BITOR[TmP2Hash.miVtoR[ccCur.miIndex2], mask]) THEN              AllocErr[block, ccCur.miIndex1, Empty];            SELECT TmP2Hash.ia7Array[ccCur.miIndex1] FROM              t =>                IF Inline.BITAND[TmP2Hash.miVtoR[ccCur.miIndex1], 16] = 0 THEN                  AllocErr[ia7, ccCur.miIndex1, Empty];              f =>                IF Inline.BITAND[TmP2Hash.miVtoR[ccCur.miIndex1], 16] # 0 THEN                  AllocErr[ia7, ccCur.miIndex1, Empty];              ENDCASE;            SELECT TmP2Hash.ia7Array[ccCur.miIndex2] FROM              t =>                IF Inline.BITAND[TmP2Hash.miVtoR[ccCur.miIndex2], 16] = 0 THEN                  AllocErr[ia7, ccCur.miIndex2, Empty];              f =>                IF Inline.BITAND[TmP2Hash.miVtoR[ccCur.miIndex2], 16] # 0 THEN                  AllocErr[ia7, ccCur.miIndex2, Empty];              ENDCASE;            MoveCC[];            ENDLOOP;  -- end verify loop          END;  -- end verify operation      END;      ca ¬ ca.caChain;      ENDLOOP;    END;  -- end AllocateConstrained  AllocIA7s: PROCEDURE =    BEGIN    v: CARDINAL;    r, r1, r2, val: CARDINAL;    r1 ¬ r2 ¬ 0;    FOR v IN [0..TmP2Hash.realMI) DO      IF TmP2Hash.miVtoR[v] # TmP2Hash.Not THEN LOOP;      SELECT TmP2Hash.ia7Array[v] FROM        t => BEGIN val ¬ 16; r ¬ r1; END;        f => BEGIN val ¬ 0; r ¬ r2; END;        ENDCASE => LOOP;      UNTIL r >= 4096        OR (TmP2Hash.miRtoV[r] = Empty AND Inline.BITAND[r, 16] = val) DO        r ¬ r + 1 ENDLOOP;      IF r >= 4096 THEN        BEGIN        IF TmP2Hash.errorLevel < TmP2Hash.bad THEN          TmFile.LogErrLine["Allocation Errors:"L];        TmFile.LogErrLine["Unable to allocate unconstrained."L];        RETURN;        END;      TmP2Hash.miVtoR[v] ¬ r;      TmP2Hash.miRtoV[r] ¬ v;      IF TmP2Hash.ia7Array[v] = t THEN r1 ¬ r;      IF TmP2Hash.ia7Array[v] = f THEN r2 ¬ r;      ENDLOOP;    END;  ProcessConstraints: PUBLIC PROCEDURE [ca: LONG POINTER TO ConstraintAttribute] =    BEGIN    -- order Constraints from largest to smallest    caList: ARRAY [0..11] OF LONG POINTER TO ConstraintAttribute ¬ ALL[NIL];    caCur: LONG POINTER TO ConstraintAttribute ¬ ca;    caNext: LONG POINTER TO ConstraintAttribute;    cc: LONG POINTER TO ConstraintChain;    i: CARDINAL;    inx: CARDINAL;    UNTIL caCur = NIL DO      inx ¬ (caCur.maxModulo*2) + (IF caCur.ia7 # x THEN 1 ELSE 0);      caNext ¬ caCur.caChain;      caCur.caChain ¬ caList[inx];      caList[inx] ¬ caCur;      cc ¬ caCur.constraints;      UNTIL cc = NIL DO  -- update all ia7 values        IF caCur.ia7 = x THEN EXIT;        TmP2Hash.ia7Array[cc.miIndex1] ¬ TmP2Hash.ia7Array[cc.miIndex2] ¬          caCur.ia7;        cc ¬ cc.nextConstraint;        ENDLOOP;      caCur ¬ caNext;      ENDLOOP;    ia70 ¬ ia71 ¬ 2048;    FOR i IN [0..4096) DO  -- count reserved ia7s      IF TmP2Hash.miRtoV[i] = TmP2Hash.Reserved THEN        SELECT Inline.BITAND[i, 16] FROM          0 => ia70 ¬ ia70 - 1;          ENDCASE => ia71 ¬ ia71 - 1;      ENDLOOP;    FOR i IN [0..TmP2Hash.realMI) DO  -- accumulate constrained ia7s      SELECT TmP2Hash.ia7Array[i] FROM        f => ia70 ¬ ia70 - 1;        t => ia71 ¬ ia71 - 1;        ENDCASE;      ENDLOOP;    FOR i DECREASING IN [2..11] DO AllocateConstrained[caList[i]]; ENDLOOP;    AllocIA7s[];    END;  -- end ProcessConstraints  PrintBlockData: PROCEDURE [cc1, cc2: LONG POINTER TO ConstraintChain] =    BEGIN    Estr: LONG STRING ¬ [150];    ccCur: LONG POINTER TO ConstraintChain;    PrintConsLine: PROCEDURE [cc: LONG POINTER TO ConstraintChain] =      BEGIN      Estr.length ¬ 0;      String.AppendString[Estr, " * "L];      AppendSymbolName[Estr, cc.miIndex1];      String.AppendString[        Estr,        SELECT TmP2Hash.ia7Array[cc.miIndex1] FROM          t => "(1)  "L,          f => "(0)  "L,          ENDCASE => "  "L];      AppendSymbolName[Estr, cc.miIndex2];      String.AppendString[        Estr,        SELECT TmP2Hash.ia7Array[cc.miIndex2] FROM          t => "(1)  "L,          f => "(0)  "L,          ENDCASE => "  "L];      String.AppendNumber[Estr, cc.offset, 16];      String.AppendString[Estr, " mod "L];      String.AppendString[        Estr,        SELECT cc.modulo FROM          1 => "2"L,          2 => "4"L,          3 => "8"L,          4 => "10'x"L,          ENDCASE => "1000'x"L];      TmFile.LogErrLine[Estr];      END;  -- end PrintConsLine    Estr.length ¬ 0;    String.AppendString[Estr, "The Block Constraints are:"];    String.AppendChar[Estr, Ascii.CR];    TmFile.LogErrLine[Estr];    Estr.length ¬ 0;    String.AppendString[Estr, " * Label1(ia7)   Label2(ia7)   offset   modulo"L];    String.AppendChar[Estr, Ascii.CR];    TmFile.LogErrLine[Estr];    ccCur ¬ cc1;    UNTIL ccCur = NIL DO  -- print loop 1      PrintConsLine[ccCur]; ccCur ¬ ccCur.nextConstraint; ENDLOOP;  -- end print loop    ccCur ¬ cc2;    UNTIL ccCur = NIL DO  -- print loop 2      PrintConsLine[ccCur]; ccCur ¬ ccCur.nextConstraint; ENDLOOP;  -- end print loop    Estr.length ¬ 0;    String.AppendChar[Estr, Ascii.CR];    TmFile.LogErrLine[Estr];    END;  -- end PrintBlockData  END...    -- Log  -- 24-Jan-85 16:52:20 - JoM     - Fix bug in AllocateConstrained (got into loop)  -- Time: 26-Sep-84 20:33:12	By: DEG     	Action: Added copyright notice and rebuild for 11.1 release.  And placed in fix for System Software AR 6457 as submitted by JAC   .  -- 16-Jul-82 13:08:45 - ETN        - TrinityMass Version 1
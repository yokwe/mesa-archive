-- Copyright (C) 1983, 1985  by Xerox Corporation. All rights reserved.-- Last edit by JAC	 7-Jun-85 12:26:52	copyrighted -- CPKernelTesterDaybreak.mesa, JoM    , 24-Jan-85 13:38:16-- from CPKernelTester.mesa, HGM, 18-Oct-83 21:15:12DIRECTORY  Environment USING [Byte],  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, CommandItem,    newLine, ProcType],  Inline USING [BITAND],  Process USING [Yield],  Put USING [CR, Line, Number, Text],  Runtime USING [GetBcdTime],  String USING [AppendString],  TextSW USING [ForceOutput],  Time USING [Append, Unpack],  Tool USING [Create, MakeFormSW, MakeFileSW, MakeSWsProc, UnusedLogName],  ToolWindow USING [TransitionProcType],  UserInput USING [UserAbort],  Version USING [Append],  Window USING [Handle],    BurdockControl USING [RegisterBurdockWindow],  CP USING [Bank, RReg, RealCS, UReg, wordsPerBank],  CPKernel USING [    Error, HalfBoot, ReadCS, ReadRReg, ReadUReg,    StartKernel, WriteBank, WriteCS, WriteCSBad, WriteRReg, WriteUReg],  CPKernelOps USING [ReadCPByte],  CPMI USING [MI],  IOPKernelOps USING [lock];CPKernelTesterDaybreak: MONITOR LOCKS IOPKernelOps.lock  IMPORTS    FormSW, Inline, Process, Put, Runtime, String, TextSW, Time, Tool, UserInput,    Version, BurdockControl, CPKernel, CPKernelOps, IOPKernelOps =  BEGIN    form, log: Window.Handle;    Bank0: FormSW.ProcType =    BEGIN ENABLE CPKernel.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostMessage["Switching to Bank 0 ..."L];    CPKernel.WriteBank[0];    TailMessage[" ok"L];    END;        Hickup: SIGNAL [reason: LONG STRING, cs: CP.RealCS, found, expected: CPMI.MI] = CODE;  Three: TYPE = RECORD [a, b, c: WORD];  TestBank0: FormSW.ProcType =    BEGIN ENABLE      BEGIN CPKernel.Error =>        BEGIN        TailMessage[reason];        CONTINUE;        END;      Hickup =>        BEGIN	WriteInfo[reason, cs, found, expected];	IF UserInput.UserAbort[log] THEN CONTINUE;        RESUME;        END;      END;    PostMessage["Testing Bank 0 of control store (! = 64 wds)"L];    BootIOP[];    TailMessage[""L];    error _ FALSE;    FOR cs: CP.RealCS IN [0..CP.wordsPerBank) DO      zeros: CPMI.MI = LOOPHOLE[Three[0, 0, 0]];      ones: CPMI.MI = LOOPHOLE[Three[0FFFFH, 0FFFFH, 0FFFFH]];      address: CPMI.MI = LOOPHOLE[Three[cs, 0, cs]];  -- parity      result: CPMI.MI;      IF UserInput.UserAbort[log] THEN EXIT;      SELECT TRUE FROM        (cs = 0) => NULL;        ((cs MOD 64) = 0) => AppendMessage["!"L];	ENDCASE => NULL;      CPKernel.WriteCS[cs, zeros];      result _ CPKernel.ReadCS[cs];      IF result # zeros THEN SIGNAL Hickup["Didn't get zeros back"L, cs, result, zeros];      CPKernel.WriteCS[cs, ones];      result _ CPKernel.ReadCS[cs];      IF result # ones THEN SIGNAL Hickup["Didn't get ones back"L, cs, result, ones];      CPKernel.WriteCS[cs, address];      result _ CPKernel.ReadCS[cs];      IF result # address THEN SIGNAL Hickup["Didn't get address back"L, cs, result, address];      Process.Yield[];      ENDLOOP;    TailMessage[" ok"L];    IF UserInput.UserAbort[log] THEN RETURN;    NewMessage["Check pass ... (! = 64 wds)"L];    TailMessage[""L];    FOR cs: CP.RealCS IN [0..CP.wordsPerBank) DO      address: CPMI.MI = LOOPHOLE[Three[cs, 0, cs]];      result: CPMI.MI;      IF UserInput.UserAbort[log] THEN EXIT;      SELECT TRUE FROM        (cs = 0) => NULL;        ((cs MOD 64) = 0) => AppendMessage["!"L];	ENDCASE => NULL;      result _ CPKernel.ReadCS[cs];      IF result # address THEN SIGNAL Hickup["Didn't get address back"L, cs, result, address];      ENDLOOP;    TailMessage[" ok"L];    END;    TestMIR: FormSW.ProcType =    BEGIN ENABLE      BEGIN CPKernel.Error =>        BEGIN        TailMessage[reason];        CONTINUE;        END;      Hickup =>        BEGIN	WriteInfo[reason, cs, found, expected];	IF UserInput.UserAbort[log] THEN CONTINUE;        RESUME;        END;      END;    cs: CP.RealCS = 0;    -- 2 bits on at the same time to make parity come out right    low: CPMI.MI _ LOOPHOLE[Three[0, 0, 3]];    high: CPMI.MI _ LOOPHOLE[Three[0FFFFH, 0FFFFH, 177774B]];    PostMessage["Testing for shorted bits in MIR..."L];    BootIOP[];    TailMessage[""L];    error _ FALSE;    FOR i: CARDINAL IN [0..48) DO      result: CPMI.MI;      IF UserInput.UserAbort[log] THEN EXIT;      CPKernel.WriteCS[cs, low];      result _ CPKernel.ReadCS[cs];      IF result # low THEN SIGNAL Hickup["Didn't get zeros back"L, cs, result, low];      CPKernel.WriteCS[cs, high];      result _ CPKernel.ReadCS[cs];      IF result # high THEN SIGNAL Hickup["Didn't get ones back"L, cs, result, high];      Process.Yield[];      low _ Rotate[low];      high _ Rotate[high];      ENDLOOP;    TailMessage[" ok"L];    END;  Rotate: PROCEDURE [in: CPMI.MI] RETURNS [CPMI.MI] =    BEGIN    temp: Three _ LOOPHOLE[in];    out: Three;    out.a _ temp.a * 2;    out.b _ temp.b * 2;    out.c _ temp.c * 2;    IF Inline.BITAND[temp.a, 8000H] # 0 THEN out.c _ out.c + 1;    IF Inline.BITAND[temp.b, 8000H] # 0 THEN out.a _ out.a + 1;    IF Inline.BITAND[temp.c, 8000H] # 0 THEN out.b _ out.b + 1;    RETURN[LOOPHOLE[out]];    END;  error: BOOLEAN;  WriteInfo: PROCEDURE [reason: LONG STRING, cs: CP.RealCS, found, expected: CPMI.MI] =    BEGIN    IF ~error THEN      BEGIN      Put.Line[log, "."L];      Put.Line[log, " loc          found          expected"L];      error _ TRUE;      END;    Put.Number[log, cs, [16, FALSE, TRUE, 4]];    WriteMI[found];    WriteMI[expected];    AppendMessage["  "L];    Put.Line[log, reason];    TextSW.ForceOutput[log];    END;  WriteMI: PROCEDURE [mi: CPMI.MI] =    BEGIN    foo: Three = LOOPHOLE[mi];    Put.Number[log, foo.a, [16, FALSE, TRUE, 7]];    Put.Number[log, foo.b, [16, FALSE, TRUE, 5]];    Put.Number[log, foo.c, [16, FALSE, TRUE, 5]];    END;  WriteBank0: FormSW.ProcType =    BEGIN ENABLE CPKernel.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostMessage["Writing Bank 0 of control store"L];    BootIOP[];    UNTIL UserInput.UserAbort[log] DO      FOR cs: CP.RealCS IN [0..CP.wordsPerBank) DO        zeros: CPMI.MI = LOOPHOLE[Three[0, 0, 0]];        ones: CPMI.MI = LOOPHOLE[Three[0FFFFH, 0FFFFH, 0FFFFH]];        IF UserInput.UserAbort[log] THEN EXIT;        CPKernel.WriteCS[cs, zeros];        CPKernel.WriteCS[cs, ones];        Process.Yield[];        ENDLOOP;      AppendMessage["!"L];      ENDLOOP;    TailMessage[" ok"L];    END;        ReadBank0: FormSW.ProcType =    BEGIN ENABLE CPKernel.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostMessage["Reading Bank 0 of control store"L];    BootIOP[];    TailMessage[""L];    UNTIL UserInput.UserAbort[log] DO      FOR cs: CP.RealCS IN [0..CP.wordsPerBank) DO        IF UserInput.UserAbort[log] THEN EXIT;        [] _ CPKernel.ReadCS[cs];        Process.Yield[];        ENDLOOP;      AppendMessage["!"L];      ENDLOOP;    TailMessage[" ok"L];    END;        WriteReadBank0: FormSW.ProcType =    BEGIN ENABLE CPKernel.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostMessage["Writing and Reading Bank 0 of control store"L];    BootIOP[];    UNTIL UserInput.UserAbort[log] DO      FOR cs: CP.RealCS IN [0..CP.wordsPerBank) DO        zeros: CPMI.MI = LOOPHOLE[Three[0, 0, 0]];        ones: CPMI.MI = LOOPHOLE[Three[0FFFFH, 0FFFFH, 0FFFFH]];        IF UserInput.UserAbort[log] THEN EXIT;        CPKernel.WriteCS[cs, zeros];        [] _ CPKernel.ReadCS[cs];        CPKernel.WriteCS[cs, ones];        [] _ CPKernel.ReadCS[cs];        Process.Yield[];        ENDLOOP;      AppendMessage["!"L];      ENDLOOP;    TailMessage[" ok"L];    END;        FlapNIA: FormSW.ProcType =    BEGIN ENABLE CPKernel.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostMessage["Flapping NIA..."L];    BootIOP[];    UNTIL UserInput.UserAbort[log] DO      FOR i: CARDINAL IN [0..100) DO        [] _ CPKernel.ReadCS[0];        [] _ CPKernel.ReadCS[CP.wordsPerBank-1];        ENDLOOP;      Process.Yield[];      ENDLOOP;    TailMessage[" ok"L];    END;              TestRRegs: FormSW.ProcType =    BEGIN ENABLE CPKernel.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostMessage["Testing RRegs ... "L];    FOR r: CP.RReg IN [0..16B] DO  -- R 17B used by Kernel      found: WORD;      CPKernel.WriteRReg[r, 0];      found _ CPKernel.ReadRReg[r];      IF found # 0 THEN PrintRRegMixup[r, 0, found];      CPKernel.WriteRReg[r, 0FFFFH];      found _ CPKernel.ReadRReg[r];      IF found # 0FFFFH THEN PrintRRegMixup[r, 0FFFFH, found];      CPKernel.WriteRReg[r, r];      found _ CPKernel.ReadRReg[r];      IF found # r THEN PrintRRegMixup[r, r, found];      ENDLOOP;    AppendMessage[", check pass ... "L];    FOR r: CP.RReg IN [0..16B] DO  -- R 17B used by Kernel      found: WORD;      found _ CPKernel.ReadRReg[r];      IF found # r THEN PrintRRegMixup[r, r, found];      ENDLOOP;    TailMessage["ok"L];    END;        FlapRRegs: FormSW.ProcType =    BEGIN ENABLE CPKernel.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostMessage["Flapping RRegs ... "L];    DO      IF UserInput.UserAbort[log] THEN EXIT;      FOR r: CP.RReg IN [0..16B] DO  -- R 17B used by Kernel        IF UserInput.UserAbort[log] THEN EXIT;        CPKernel.WriteRReg[r, 0];        [] _ CPKernel.ReadRReg[r];        CPKernel.WriteRReg[r, 0FFFFH];        [] _ CPKernel.ReadRReg[r];        ENDLOOP;      ENDLOOP;    TailMessage["ok"L];    END;        TestURegs: FormSW.ProcType =    BEGIN ENABLE CPKernel.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostMessage["Testing URegs (! = 8 regs) ... "L];    FOR u: CP.UReg IN [0..256-16-1) DO      found: WORD;      SELECT TRUE FROM        (u = 0) => NULL;        ((u MOD 8) = 0) => AppendMessage["!"L];	ENDCASE => NULL;      IF UserInput.UserAbort[log] THEN BEGIN TailMessage[" aborted"L]; RETURN; END;      CPKernel.WriteUReg[u, 0];      found _ CPKernel.ReadUReg[u];      IF found # 0 THEN PrintURegMixup[u, 0, found];      CPKernel.WriteUReg[u, 0FFFFH];      found _ CPKernel.ReadUReg[u];      IF found # 0FFFFH THEN PrintURegMixup[u, 0FFFFH, found];      CPKernel.WriteUReg[u, u];      found _ CPKernel.ReadUReg[u];      IF found # u THEN PrintURegMixup[u, u, found];      ENDLOOP;    AppendMessage[", check pass ... "L];    FOR u: CP.UReg IN [0..256-16-1) DO      found: WORD;      IF UserInput.UserAbort[log] THEN BEGIN TailMessage[" aborted"L]; RETURN; END;      found _ CPKernel.ReadUReg[u];      IF CPKernel.ReadUReg[u] # u THEN PrintURegMixup[u, u, found];      ENDLOOP;    TailMessage[" ok"L];    END;        FlapURegs: FormSW.ProcType =    BEGIN ENABLE CPKernel.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostMessage["Flapping URegs ... "L];    DO      IF UserInput.UserAbort[log] THEN EXIT;      FOR u: CP.UReg IN [0..256-16-1) DO        IF UserInput.UserAbort[log] THEN EXIT;        CPKernel.WriteUReg[u, 0];        [] _ CPKernel.ReadUReg[u];        CPKernel.WriteUReg[u, 0FFFFH];        [] _ CPKernel.ReadUReg[u];        ENDLOOP;      ENDLOOP;    TailMessage[" ok"L];    END;        ZeroURegs: FormSW.ProcType =    BEGIN ENABLE CPKernel.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostMessage["Zeroing URegs (! = 64 regs) ... "L];    FOR u: CP.UReg IN [0..256-16-1) DO      SELECT TRUE FROM        (u = 0) => NULL;        ((u MOD 64) = 0) => AppendMessage["!"L];	ENDCASE => NULL;      IF UserInput.UserAbort[log] THEN EXIT;      CPKernel.WriteUReg[u, 0];      IF CPKernel.ReadUReg[u] # 0 THEN CPKernel.Error["Didn't get a 0 back"L];      ENDLOOP;    AppendMessage[", check pass ... "L];    FOR u: CP.UReg IN [0..256-16-1) DO      IF UserInput.UserAbort[log] THEN EXIT;      IF CPKernel.ReadUReg[u] # 0 THEN CPKernel.Error["Didn't get a 0 back (check pass)"L];      ENDLOOP;    TailMessage[ "ok"L];    END;        JumpNext: FormSW.ProcType =    BEGIN ENABLE CPKernel.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostMessage["Filling CS with Jump $ ... "L];    BootIOP[];    FOR cs: CP.RealCS IN [0..CP.wordsPerBank-1) DO      CPKernel.WriteCS[cs, CPMI.MI[, , , , , , , , , , , , , , cs+1]];      ENDLOOP;    CPKernel.WriteCS[CP.wordsPerBank-1, CPMI.MI[, , , , , , , , , , , , , , FIRST[CP.RealCS]]];    CPKernel.WriteCS[0, CPMI.MI[      , , , , , , , , , fyNorm, , , [n[clrIntErr]], , 1]];    CPKernel.StartKernel[];    TailMessage[ "ok"L];    END;        GrabCPByte: FormSW.ProcType =    BEGIN ENABLE CPKernel.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    data: WORD;    PostMessage["Grabbing CP Byte ... "L];    data _ ReadCPByte[];    Put.Text[log, "data = "L];    Put.Number[log, data, [16, FALSE, TRUE, 0]];    Put.Text[log, "(16) = "L];    Put.Number[log, data, [8, FALSE, TRUE, 0]];    TailMessage["(8)."L];    END;  ReadCPByte: ENTRY PROCEDURE RETURNS [Environment.Byte] =    BEGIN ENABLE UNWIND => NULL;    RETURN[CPKernelOps.ReadCPByte[]];    END;    HalfBoot: FormSW.ProcType =    BEGIN ENABLE CPKernel.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostMessage["Booting IOP and HalfBooting CP (Not loading Kernel) ... "L];    BootIOP[];    TailMessage["OK."L];    END;     FillBadParity: FormSW.ProcType =    BEGIN ENABLE CPKernel.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostMessage["Filling CS with Jump Bad Parity ... "L];    BootIOP[];    FOR cs: CP.RealCS IN [0..CP.wordsPerBank-1) DO      CPKernel.WriteCSBad[cs, CPMI.MI[, , , , , , , , , , , , , , cs]];      ENDLOOP;    TailMessage[ "ok"L];    END;        BootIOP: PROCEDURE =    BEGIN    CPKernel.HalfBoot[];    END;    PostMessage: PROCEDURE [s: LONG STRING, clear: BOOLEAN _ TRUE] =    BEGIN    Put.CR[log];    Put.Text[log, s];    TextSW.ForceOutput[log]    END;  NewMessage: PROCEDURE [s: LONG STRING] =    BEGIN    Put.Text[log, s];    TextSW.ForceOutput[log]    END;  AppendMessage: PROCEDURE [s: LONG STRING] =    BEGIN    Put.Text[log, s];    TextSW.ForceOutput[log]    END;  TailMessage: PROCEDURE [s: LONG STRING] =    BEGIN    Put.Text[log, s];    Put.Line[log, "."L];    TextSW.ForceOutput[log]    END;  PrintRRegMixup: PROCEDURE [r: CP.RReg, expected, found: UNSPECIFIED] =    BEGIN    Put.Text[log, "R "L];    Put.Number[log, r, [16, FALSE, TRUE, 2]];    Put.Text[log, " mixup; expected: "L];    Put.Number[log, expected, [16, FALSE, TRUE, 4]];    Put.Text[log, ", found: "L];    Put.Number[log, found, [16, FALSE, TRUE, 4]];    Put.Line[log, "."L];    END;    PrintURegMixup: PROCEDURE [u: CP.UReg, expected, found: UNSPECIFIED] =    BEGIN    Put.Text[log, "U "L];    Put.Number[log, u, [16, FALSE, TRUE, 2]];    Put.Text[log, " mixup; expected: "L];    Put.Number[log, expected, [16, FALSE, TRUE, 4]];    Put.Text[log, ", found: "L];    Put.Number[log, found, [16, FALSE, TRUE, 4]];    Put.Line[log, "."L];    END;    Initialize: PROCEDURE =    BEGIN    herald: STRING = [100];    String.AppendString[herald, "CPKernel Tester "L];    Version.Append[herald];    String.AppendString[herald, " of "L];    Time.Append[herald, Time.Unpack[Runtime.GetBcdTime[]]];    BurdockControl.RegisterBurdockWindow[Tool.Create[      name: herald,      cmSection: "CPKernel Tester"L,      initialState: inactive,      makeSWsProc: MakeSWs,      clientTransition: ClientTransition]];    END;    MakeSWs: Tool.MakeSWsProc =    BEGIN    logFileName: STRING = [40];    form _ Tool.MakeFormSW[window: window, formProc: MakeForm];    Tool.UnusedLogName[logFileName, "CPKernelTester.log$"L];    log _ Tool.MakeFileSW[window: window, name: logFileName];    END;    MakeForm: FormSW.ClientItemsProcType =    BEGIN    i: INTEGER _ -1;    nParams: CARDINAL = 16;    items _ FormSW.AllocateItemDescriptor[nParams];    items[i_i+1] _ FormSW.CommandItem[tag: "Bank0"L, proc: Bank0, place: FormSW.newLine];    items[i_i+1] _ FormSW.CommandItem[tag: "TestMIR"L, proc: TestMIR];    items[i_i+1] _ FormSW.CommandItem[tag: "TestBank0"L, proc: TestBank0];    items[i_i+1] _ FormSW.CommandItem[tag: "WriteBank0"L, proc: WriteBank0];    items[i_i+1] _ FormSW.CommandItem[tag: "ReadBank0"L, proc: ReadBank0];    items[i_i+1] _ FormSW.CommandItem[tag: "WriteReadBank0"L, proc: WriteReadBank0];    items[i_i+1] _ FormSW.CommandItem[tag: "FlapNIA"L, proc: FlapNIA];    items[i_i+1] _ FormSW.CommandItem[tag: "JumpNext"L, proc: JumpNext, place: FormSW.newLine];    items[i_i+1] _ FormSW.CommandItem[tag: "FillBadParity"L, proc: FillBadParity];    items[i_i+1] _ FormSW.CommandItem[tag: "TestRRegs"L, proc: TestRRegs, place: FormSW.newLine];    items[i_i+1] _ FormSW.CommandItem[tag: "FlapRRegs"L, proc: FlapRRegs];    items[i_i+1] _ FormSW.CommandItem[tag: "TestURegs"L, proc: TestURegs];    items[i_i+1] _ FormSW.CommandItem[tag: "FlapURegs"L, proc: FlapURegs];    items[i_i+1] _ FormSW.CommandItem[tag: "ZeroURegs"L, proc: ZeroURegs];    items[i_i+1] _ FormSW.CommandItem[tag: "GrabCPByte"L, proc: GrabCPByte, place: FormSW.newLine];    items[i_i+1] _ FormSW.CommandItem[tag: "HalfBoot"L, proc: HalfBoot];    IF (i+1) # nParams THEN ERROR;    RETURN[items, TRUE];    END;       ClientTransition: ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      old = inactive =>        BEGIN        END;      new = inactive =>        BEGIN        END;      ENDCASE;    END;	  Initialize[];  END.
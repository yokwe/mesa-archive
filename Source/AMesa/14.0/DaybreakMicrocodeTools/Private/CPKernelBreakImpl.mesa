-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved. -- Last edit by JAC   		    9-Mar-85 17:05:14-- CPKernelBreakImpl.mesa, AYC   , 28-Nov-84 13:49:07-- from CPKernelBreaker.mesa, HGM,  7-Mar-83 17:14:50--  DIRECTORY  Inline USING [BITNOT, BITOR, BITSHIFT],  CPDef USING [IBDspB, NopDspB, RealCS, wordsPerBank],  CPKernel USING [Byte, Nibble, savedBank],  CPKernelDef USING [dKernel, kBuffer, kEntry, kMailBox],  CPKernelOps USING [GetStateInternal, WriteCSInternal, ReadMemoryWordInternal],  CPuFormat;CPKernelBreakImpl: MONITOR  IMPORTS Inline, CPKernel, CPKernelOps, CPuFormat  EXPORTS CPKernel, CPKernelOps =  BEGIN OPEN CPuFormat;    Nibble: TYPE = CPKernel.Nibble;  Byte: TYPE = CPKernel.Byte;  currentBreakID: CARDINAL;  AtBreak: PUBLIC ENTRY PROCEDURE RETURNS [BOOLEAN] =    BEGIN RETURN[CPKernelOps.GetStateInternal[] = cpBreak]; END;    SaveCurrentBreakID: PUBLIC INTERNAL PROCEDURE =    BEGIN    currentBreakID ¬ GetCurrentBreakID[];    END;    GetCurrentBreakID: PROCEDURE RETURNS[WORD] =    BEGIN    RETURN[Inline.BITSHIFT[	CPKernelOps.ReadMemoryWordInternal[CPKernelDef.kMailBox + 3], - 8]];    END;   GetBreakID: PUBLIC ENTRY PROCEDURE RETURNS [CARDINAL] =    BEGIN RETURN[currentBreakID]; END;      SetBreak: PUBLIC ENTRY PROCEDURE [pc: CPDef.RealCS, MI: CPuFormat.MI, id: Byte] =    BEGIN    BreakID: CPuFormat.ByteImmediate ¬ LOOPHOLE[Inline.BITNOT[id]];    BDisp: CPuFormat.Bits4 ¬     	Inline.BITOR[Inline.BITSHIFT[MI.context.common.dspBBits33, 3], 				     MI.context.common.dspBBits20];    IF BDisp = CPDef.IBDspB OR BDisp IN [0..3] THEN BDisp ¬ CPDef.NopDspB;    IF pc ~IN CPDef.RealCS THEN ERROR;    --    -- dKernel ¬ BreakID, [DspB,] Disp4[kEntry];    --    CPKernelOps.WriteCSInternal[pc, CPuFormat.uAlign[3,ZeroA,TRUE,BreakID.imu,        CPKernelDef.dKernel,AorB,,BreakID.iml,noopSp1,BDisp,CPKernelDef.kEntry,]];    END;  PrepareToContinueFromStop: PUBLIC INTERNAL PROCEDURE [mi: CPuFormat.mi] =    BEGIN ENABLE UNWIND => NULL;    MI: CPuFormat.MI ¬ LOOPHOLE[mi, CPuFormat.MI];    --    -- broken instruction, BDisp;    --    BDisp: CPuFormat.Bits4 ¬     	Inline.BITOR[Inline.BITSHIFT[MI.context.common.dspBBits33, 3], 				     MI.context.common.dspBBits20];    IF BDisp # CPDef.IBDspB AND BDisp ~IN [0..3] AND BDisp # CPDef.NopDspB THEN      BEGIN      MI.context.common.dspBBits33 ¬ 1;		-- DspB ¬ BDisp (= 9)      MI.context.common.dspBBits20 ¬ 1;      END;    CPKernelOps.WriteCSInternal[CPKernelDef.kBuffer + CPKernel.savedBank * CPDef.wordsPerBank, MI];    END;	  PrepareToContinueFromBreak: PUBLIC INTERNAL PROCEDURE [mi: CPuFormat.mi] =    BEGIN ENABLE UNWIND => NULL;    MI: CPuFormat.MI ¬ LOOPHOLE[mi, CPuFormat.MI];    --    -- broken instruction, BDisp;    --    BDisp: CPuFormat.Bits4 ¬     	Inline.BITOR[Inline.BITSHIFT[MI.context.common.dspBBits33, 3], 				     MI.context.common.dspBBits20];    IF BDisp # CPDef.IBDspB AND BDisp ~IN [0..3] AND BDisp # CPDef.NopDspB THEN      BEGIN      MI.context.common.dspBBits33 ¬ 1;		-- DspB ¬ BDisp (= 9)      MI.context.common.dspBBits20 ¬ 1;      END;    CPKernelOps.WriteCSInternal[CPKernelDef.kBuffer + CPKernel.savedBank * CPDef.wordsPerBank, MI];    END;	  END.  -- Log-- JAC   	 9-Mar-85 17:04:58	mailbox is no long quadword aligned
-- Copyright (C) 1984, 1985  by Xerox Corporation. All rights reserved. -- Last edit by RDH, 	14-Mar-86 11:13:47 -- from CPKernelDicentra.mesa, HGM, 19-Feb-84 18:03:48DIRECTORY  Bindweed USING [AddressType, Error, maxData, ReadMemoryBlock, ResetCP, Sequence,  StartCP, StopCP, WriteMemoryBlock],  Environment USING [Byte, bytesPerWord],  Format USING [Line, StringProc, Text],  Heap USING [systemZone],  Inline USING [BITAND, BITOR, BITSHIFT, BITXOR, HighByte, HighHalf, LowByte, LowHalf],  Runtime USING [GetTableBase],  String USING [AppendString],  CPDefs USING [    Bank, BankAndWordsPerBank, BanksImplemented, bytesPerMI, Cycle, numberOfBanks, RealCS, RealMemory, Task, wordsPerBank],  CPKernelDefs USING [AtBreak, Error, ReadCS, State, WriteCS],  CPKernelConst,  CPKernelOp USING [    AddressOutOfRange, LoadFromMemory, PrepareToContinueAfterBreak, PrepareToContinueAfterStop, PrepareToStart, SaveCurrentBreakID],  CPMIFormat USING [AD, AF, AS, FS01, FS23, FX, FY, FZ, MI, FYNorm],  CPSymbl USING [AppendRealCS, nullVirturalCS, AppendVirturalCS, RealToVirturalCS,VirturalCS],  --DoveHandlerIDs USING [cpBermuda],  DoveInputOutput USING [OldByteSwap, OpieAddressType],  KernelMicrocode,  KernelOtherBankMicrocode;CPKernelDybrk: MONITOR   IMPORTS    Bindweed, DoveInputOutput, Format, Heap, Inline, Runtime, String,    CPKernelDefs, CPKernelOp, CPSymbl, KernelMicrocode, KernelOtherBankMicrocode  EXPORTS CPKernelConst, CPKernelDefs, CPKernelOp   SHARES DoveInputOutput =  BEGIN OPEN CPKernelConst;    z: UNCOUNTED ZONE = Heap.systemZone;    maxBreaks: PUBLIC CARDINAL ¬ 256;  maxWords: CARDINAL = (Bindweed.maxData-1)/Environment.bytesPerWord;      state: CPKernelDefs.State ¬ dead;  kernelLoaded: BOOLEAN ¬ FALSE;  currentBank, savedBank: CARDINAL ¬ 0;  banksThisMachine: CARDINAL ¬ 0;  savedTpc, kernelTpc: CPDefs.RealCS;  seqptr: LONG POINTER TO Bindweed.Sequence      ¬ z.NEW[Bindweed.Sequence[Bindweed.maxData]];        mailbox: PUBLIC LONG POINTER;    DebuggeeReady: PUBLIC ENTRY PROCEDURE =     BEGIN ENABLE UNWIND => NULL;    DebuggeeReadyInternal[];    END;    DebuggeeReadyInternal: INTERNAL PROCEDURE =  --wait until the debuggee is ready to accept commands    BEGIN ENABLE      BEGIN      UNWIND => NULL;      Bindweed.Error =>         SELECT code FROM	  timeout => {SetNewState[dead]; CPKernelDefs.Error["Timeout"L]};	  badCheckSum => {SetNewState[dead]; CPKernelDefs.Error["Bad checksum"L]};	  ENDCASE => {SetNewState[dead]; CPKernelDefs.Error["Bindweed problem"L]};      END;    ready: RECORD [      SELECT OVERLAID * FROM        word => [word: WORD],	separate => [hiBit: [0..2),	             pad: [0..4096)],	ENDCASE];    ready.word ¬ ReadMemoryWordInternal[mailbox+1];    FOR i: CARDINAL IN [0..10) WHILE ready.hiBit = 1 DO       Pause[];      ready.word ¬ ReadMemoryWordInternal[mailbox+1];      ENDLOOP;    IF ready.hiBit = 1 THEN CPKernelDefs.Error["Kernel confusion.  Please reboot"L]    ELSE [] ¬ Bindweed.StopCP[];    END;  InKernel: PUBLIC ENTRY PROCEDURE RETURNS [BOOLEAN] =    BEGIN ENABLE UNWIND => NULL;    RETURN[SELECT state FROM      dead => FALSE,      halted => TRUE,      running => FALSE,      cpBreak, booted => TRUE,      ENDCASE => ERROR ];    END;        GetState: PUBLIC ENTRY PROCEDURE RETURNS [CPKernelDefs.State] =    BEGIN    RETURN[state];    END;  GetStateInternal: PUBLIC INTERNAL PROCEDURE RETURNS [CPKernelDefs.State] =    BEGIN    RETURN[state];    END;      ProbeForStateChange: PUBLIC ENTRY PROCEDURE [log: Format.StringProc, arg: LONG POINTER] =    BEGIN ENABLE UNWIND => NULL;    IF state = dead THEN RETURN;    IF PollCPInternal[] THEN SetNewState[cpBreak];      END;      PollCP: PUBLIC ENTRY PROCEDURE[log: Format.StringProc, arg: LONG POINTER] RETURNS [BOOLEAN] =    BEGIN ENABLE      BEGIN      UNWIND => NULL;      CPKernelDefs.Error => ERROR CPKernelDefs.Error["Timeout"L];      END;    IF CPKernelDefs.AtBreak[] THEN RETURN WITH ERROR CPKernelDefs.Error["Already at BreakPoint"L];    RETURN[PollCPInternal[]];    END;       PollCPInternal: INTERNAL PROCEDURE  RETURNS [BOOLEAN] =    BEGIN ENABLE       BEGIN      Bindweed.Error =>         SELECT code FROM	  timeout => {SetNewState[dead]; CPKernelDefs.Error["Timeout"L]};	  badCheckSum => {SetNewState[dead]; CPKernelDefs.Error["Bad checksum"L]};	  ENDCASE => {SetNewState[dead]; CPKernelDefs.Error["Bindweed problem"L]};      END;    <<pc: RECORD [      SELECT OVERLAID * FROM        daisy => [shiftRegister: PACKED ARRAY [0..CPDefs.bytesPerMI) OF Environment.Byte],	daybreak =>  [pad1: WORD, pad2: WORD, pad3: [0..16), inia: [0..4096)],	ENDCASE];>>    ready: RECORD [      SELECT OVERLAID * FROM        word => [word: WORD],	separate => [hiBit: [0..2),	             pad: [0..4096)],	ENDCASE];    SELECT state FROM      booted => RETURN[FALSE];      dead => RETURN[FALSE];      halted => RETURN[FALSE];      running => NULL;      cpBreak => RETURN[FALSE];      ENDCASE => ERROR;    <<pc.shiftRegister ¬ Bindweed.StopCP[];--  Format.Text[log, "PollCP: Stop <= "L, arg];--  DebugLog[log, arg, ShiftRegister];    IF pc.inia NOT IN InKernelAddresses THEN      BEGIN      Pause[200];--    Format.Text[log, "PollCP: Start => "L, arg];--    DebugLog[log, arg, pc];      ContinueCPInternal[];      Pause[250];      RETURN[FALSE];      END;>>    ready.word ¬ ReadMemoryWordInternal[mailbox+1];    IF ready.hiBit = 1 THEN RETURN[FALSE];    CPKernelOp.SaveCurrentBreakID[];    ContinueCPInternal[];    RETURN[TRUE];    END;    --This proc sets state, currentBank, savedBank, and resets the CP.  Boot: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE      BEGIN      Bindweed.Error =>         SELECT code FROM	  timeout => {SetNewState[dead]; CPKernelDefs.Error["Timeout"L]};	  badCheckSum => {SetNewState[dead]; CPKernelDefs.Error["Bad checksum"L]};	  ENDCASE => {SetNewState[dead]; CPKernelDefs.Error["Bindweed problem"L]};      UNWIND => NULL;      END;    SetNewState[dead];    kernelLoaded ¬ FALSE;    currentBank ¬ savedBank ¬ 0;    Bindweed.ResetCP[];    SetNewState[booted];    END;    <<HalfBoot: PUBLIC ENTRY PROCEDURE =  -- WHAT IS THIS USED FOR??? JAC--    BEGIN ENABLE      BEGIN      Bindweed.Error =>         SELECT code FROM	  timeout => {SetNewState[dead]; CPKernelDefs.Error["Timeout"L]};	  badCheckSum => {SetNewState[dead]; CPKernelDefs.Error["Bad checksum"L]};	  ENDCASE => {SetNewState[dead]; CPKernelDefs.Error["Bindweed problem"L]};      UNWIND => NULL;      END;    SetNewState[dead];    kernelLoaded ¬ FALSE;    currentBank ¬ savedBank ¬ 0;    banksThisMachine ¬ 1;    Bindweed.ResetCP[];    SetNewState[booted];    END;>>    FindBanks: PUBLIC ENTRY PROCEDURE RETURNS [CPDefs.Bank] =  <<--THIS NEED LOTS OF HELP@!!!!!!!!! JAC  8-Feb-85 12:44:18    BEGIN ENABLE UNWIND => NULL;    banksThisMachine ¬ CPDefs.numberOfBanks;  -- Bypass error trap    FOR bank: CPDefs.Bank IN [1..CPDefs.numberOfBanks) DO      cs: CPDefs.RealCS = bank * CPDefs.wordsPerBank + kBuffer + 2;  -- SetNewBank uses kBuffer[0..1]      Three: TYPE = RECORD [a, b, c: WORD];      address: CPMIFormat.MI = LOOPHOLE[Three[cs, 0, cs]];  -- parity      CPKernelDefs.WriteControlStore[cs, address];      IF CPKernelDefs.ReadControlStore[kBuffer + 2] = address THEN        BEGIN	IF bank # 1 THEN ERROR CPKernelDefs.Error["Bank searching mixup - write smashed bank 0"L];	RETURN[banksThisMachine ¬ 1];	END;      IF CPKernelDefs.ReadControlStore[cs] # address THEN        BEGIN	RETURN[banksThisMachine ¬ bank];	END;      ENDLOOP;    RETURN[banksThisMachine ¬ CPDefs.numberOfBanks];>>        BEGIN ENABLE UNWIND => NULL;    RETURN[FindBanksInternal[]];    END;--FindBanks--      FindBanksInternal: INTERNAL PROCEDURE RETURNS [nBanks: CPDefs.Bank ¬ 1] = BEGIN    --Return how many control store banks there are.    --Write a bank and confirm that the same contents read back.     --Smashes kernel at kEntry in any extra banks.    --Sets global variable banksThisMachine.    ENABLE UNWIND => NULL;    testMI: CPMIFormat.MI = [rA: 5, rB: 2, aF: rMinusS, fX: loadRH, inia: 0FA3H];  --nonsense just for reading and writing.    testBankLocOffset: CARDINAL = CPKernelConst.kEntry;        FOR i: CARDINAL IN [1..CPDefs.numberOfBanks) DO      readMI: CPMIFormat.MI;      bankOffset: CARDINAL ¬ CPDefs.wordsPerBank * i;      CPKernelDefs.WriteCS[testBankLocOffset + bankOffset, testMI];      readMI ¬ CPKernelDefs.ReadCS[testBankLocOffset + bankOffset];      readMI.ep ¬ FALSE;  --WriteCS may change parity bit.      IF readMI # testMI THEN EXIT;      nBanks ¬ nBanks + 1;      ENDLOOP;    banksThisMachine ¬ nBanks;    END;--FindBanksInternal--    Reset: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE UNWIND => NULL;    SetNewState[dead];    savedBank ¬ 0;    WriteTpcInternal[0, kEntry];  -- GOTO[kEntry]    SetNewState[halted];    END;    --Initialize mailbox, and load main kernel  LoadKernel: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE UNWIND => NULL;    iopZero: LONG CARDINAL ¬ 50000H;    segmentTablePtr: LONG CARDINAL ¬ 52002H;    cpBermudaHandlerID: LONG CARDINAL ¬ 11;    segmentGranularity: LONG CARDINAL ¬ 2;  --words    ioRegionSegment: WORD;    SetNewBank[0];     --mailbox ¬ LOOPHOLE[52948H];    <<This returns a paragraph offset from what the IOP considers to be      location 0 which corresponds to 50000H in the Mesa world.>>    ioRegionSegment ¬ ReadMemoryWordInternal[      LOOPHOLE[segmentTablePtr + (cpBermudaHandlerID*segmentGranularity)]];    ioRegionSegment ¬ DoveInputOutput.OldByteSwap[ioRegionSegment];    <<Now take that number and shift it left by 4 to turn it from a       paragraph to a byte offset.  Then shift it right by 1 to turn      the byte offset into a word offset.>>    mailbox ¬ LOOPHOLE[LONG[(ioRegionSegment * 8)] + iopZero];    <<What we would really like to do is the following which is done by each         handler's head in Dove to find its IORegion:        mailbox ¬ DoveInputOutput.GetHandlerIORegionPtr[          DoveHandlerIDs.cpBermuda];       I believe that this returns a virtual address.      Unfortunately, this assumes that ProcessorHeadDove has run and has set      up a pointer to the IORegion appropriately.  Of course, not only has       ProcessorHeadDove not run when we do a CP boot, but this runs on a       DLion where ProcessorHeadDove does not run.  Putting those lines in       causes an address fault.>>      CPKernelOp.LoadFromMemory[Runtime.GetTableBase[      KernelMicrocode.DaybreakKernel], 0];    END;--LoadKernel--          --Load alternate bank kernel--   LoadKernelHigh: PUBLIC ENTRY PROCEDURE[bank: CPDefs.Bank] =    BEGIN ENABLE UNWIND => NULL;     CPKernelOp.LoadFromMemory[Runtime.GetTableBase[      KernelOtherBankMicrocode.DaybreakOtherBankKernel], bank];    END;--LoadKernelHigh--            StartKernel: PUBLIC ENTRY PROCEDURE =  -- remember that the kernel has an instruction at location 0.  if this procedure is used other that at boot time there could be trouble    BEGIN ENABLE      BEGIN      Bindweed.Error =>         SELECT code FROM	  timeout => {SetNewState[dead]; CPKernelDefs.Error["Timeout"L]};	  badCheckSum => {SetNewState[dead]; CPKernelDefs.Error["Bad checksum"L]};	  ENDCASE => {SetNewState[dead]; CPKernelDefs.Error["Bindweed problem"L]};      UNWIND => NULL;      END;    shiftRegister: PACKED ARRAY [0..CPDefs.bytesPerMI) OF Environment.Byte ¬ ALL[0];    Bindweed.StartCP[shiftRegister];    kernelLoaded ¬ TRUE;    END;    Start: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE UNWIND => NULL;    DebuggeeReadyInternal[];    SetNewBank[savedBank];    CPKernelOp.PrepareToStart[savedTpc];    SetNewState[running];    ContinueCPInternal[];    END;    ContinueAfterBreak: PUBLIC ENTRY PROCEDURE [log: Format.StringProc, arg: LONG POINTER, mi: CPMIFormat.MI, cycle: CPDefs.Cycle, task: CPDefs.Task] =    BEGIN ENABLE UNWIND => NULL;    DebuggeeReadyInternal[];    SetNewBank[savedBank];    CPKernelOp.PrepareToContinueAfterBreak[log, arg, mi, cycle, task, savedBank];    SetNewState[running];    ContinueCPInternal[];    END;      ContinueAfterStop: PUBLIC ENTRY PROCEDURE [log: Format.StringProc, arg: LONG POINTER] =    BEGIN ENABLE UNWIND => NULL;    DebuggeeReadyInternal[];    SetNewBank[savedBank];    CPKernelOp.PrepareToContinueAfterStop[log, arg, savedBank, savedTpc];    SetNewState[running];    ContinueCPInternal[];    END;      ContinueCP: PUBLIC ENTRY PROCEDURE =     BEGIN ENABLE UNWIND => NULL;    ContinueCPInternal[];    END;      StopCP: PUBLIC ENTRY PROCEDURE =     BEGIN  ENABLE      BEGIN      Bindweed.Error =>         SELECT code FROM	  timeout => {SetNewState[dead]; CPKernelDefs.Error["Timeout"L]};	  badCheckSum => {SetNewState[dead]; CPKernelDefs.Error["Bad checksum"L]};	  ENDCASE => {SetNewState[dead]; CPKernelDefs.Error["Bindweed problem"L]};      UNWIND => NULL;      END;    [] ¬ Bindweed.StopCP[];    END;    ContinueCPInternal: INTERNAL PROCEDURE =    BEGIN ENABLE      BEGIN      Bindweed.Error =>         SELECT code FROM	  timeout => {SetNewState[dead]; CPKernelDefs.Error["Timeout"L]};	  badCheckSum => {SetNewState[dead]; CPKernelDefs.Error["Bad checksum"L]};	  ENDCASE => {SetNewState[dead]; CPKernelDefs.Error["Bindweed problem"L]};      UNWIND => NULL;      END;    shiftRegister: PACKED ARRAY [0..CPDefs.bytesPerMI) OF Environment.Byte ¬ ALL[0];    Bindweed.StartCP[shiftRegister];  --really needs a continue    END;  Stop: PUBLIC ENTRY PROCEDURE [log: Format.StringProc, arg: LONG POINTER] =    BEGIN ENABLE      BEGIN      Bindweed.Error =>         SELECT code FROM	  timeout => {SetNewState[dead]; CPKernelDefs.Error["Timeout"L]};	  badCheckSum => {SetNewState[dead]; CPKernelDefs.Error["Bad checksum"L]};	  ENDCASE => {SetNewState[dead]; CPKernelDefs.Error["Bindweed problem"L]};      UNWIND => NULL;      END;    maxStopAttempts: CARDINAL = 1000;  --Times to look for a safe stopping point.    stopAttemptCount: CARDINAL;    stopBank: WORD;  -- Temp for combining bank info from breakID with address.    savedMIs: ARRAY CPDefs.BanksImplemented OF ARRAY [0..16) OF CPMIFormat.MI;    shiftRegister: PACKED ARRAY [0..CPDefs.bytesPerMI) OF Environment.Byte ¬ ALL[0];    stopInfo: RECORD [      SELECT OVERLAID * FROM        shiftRegister => [bogus: PACKED ARRAY [0..CPDefs.bytesPerMI) OF Environment.Byte],        microInstr => [mi: CPMIFormat.MI],	ENDCASE];    disp: CARDINAL ¬ 0;    SELECT state FROM      dead => ERROR CPKernelDefs.Error["CP/IOP is dead"L];      booted => RETURN;      halted => ERROR CPKernelDefs.Error["already stopped"L];      running => NULL;      cpBreak => ERROR CPKernelDefs.Error["already at break"L];      ENDCASE => ERROR;    stopAttemptCount ¬ 0;    stopInfo.bogus ¬ Bindweed.StopCP[];    --Find a place to stop where there are no dispatch bits set in the previous instruction and no Bank¬.    WHILE (stopInfo.mi.fS01 = dispBr) OR 					--Doing a Dispatch or      ((stopInfo.mi.fS01 = fyNorm) AND (stopInfo.mi.fY = [n[ibDisp]])) OR 	--Doing an IBDisp or      ((stopInfo.mi.fS01 = fyNorm) AND (stopInfo.mi.fY = [n[bank]])) 		--Doing a bank switch      DO      stopAttemptCount ¬ stopAttemptCount + 1;      --Avoid hanging forever when trying to stop in a tight loop with dispatch conditions.      IF stopAttemptCount > maxStopAttempts THEN BEGIN        Format.Line[log, "Unable to stop gracefully because the microcode is in a loop without a safe stopping place.  The given stopped location may not be true."L, arg];	EXIT;        END;      Bindweed.StartCP[shiftRegister];    --really needs a continue      stopInfo.bogus ¬ Bindweed.StopCP[];      ENDLOOP;    stopInfo.mi.inia ¬ Inline.BITXOR[stopInfo.mi.inia,17B];    IF stopInfo.mi.inia IN InKernelAddresses THEN {      CPKernelOp.SaveCurrentBreakID[];      SetNewState[cpBreak];      RETURN WITH ERROR CPKernelDefs.Error["CP at break.  Already stopped."L]};    savedTpc ¬ Inline.BITAND[stopInfo.mi.inia, 0FFF0H];    FOR bank: CARDINAL IN CPDefs.BanksImplemented DO      bankOffset: CARDINAL ¬ bank * CPDefs.wordsPerBank;      FOR i: CARDINAL IN [0..16) DO	savedMIs[bank][i] ¬ CPKernelDefs.ReadCS[bankOffset + savedTpc + i];	CPKernelDefs.WriteCS[bankOffset + savedTpc + i, CPMIFormat.MI[	, rHrK, , , , , , , , byte, nibble, loadRH, [d[0FH]], [d[0FH]], kEntry + i]];	ENDLOOP;      ENDLOOP;    Bindweed.StartCP[shiftRegister];    --really needs a continue    Pause[2000];      [] ¬ Bindweed.StopCP[];    FOR bank: CARDINAL IN CPDefs.BanksImplemented DO      bankOffset: CARDINAL ¬ bank * CPDefs.wordsPerBank;      FOR i: CARDINAL IN [0..16) DO	CPKernelDefs.WriteCS[bankOffset + savedTpc + i, savedMIs[bank][i]];	ENDLOOP;      ENDLOOP;    Bindweed.StartCP[shiftRegister];  --really needs a continue     --What this code needs is some types and constants.     disp ¬ Inline.BITAND[ReadMemoryWordInternal[mailbox+3], 0FH];    savedTpc ¬ Inline.BITOR[savedTpc, disp];     stopBank ¬ Inline.BITAND[ReadMemoryWordInternal[mailbox+2], 0C00H];    savedBank ¬ Inline.BITSHIFT[stopBank, 2];    savedTpc ¬ Inline.BITOR[savedTpc, savedBank];    savedBank ¬ Inline.BITSHIFT[savedBank, -12];    PrintStopState[log, arg, savedTpc];    --SetNewBank[0];    SetNewState[halted];    END;    MaybeSetNewState: INTERNAL PROCEDURE [new: CPKernelDefs.State] =    BEGIN    IF state = new THEN RETURN;    SetNewState[new];    END;    SetNewState: PUBLIC INTERNAL PROCEDURE [new: CPKernelDefs.State] =    BEGIN    state ¬ new;    END;  WriteBank: PUBLIC ENTRY PROCEDURE [bank: CPDefs.Bank] =      BEGIN ENABLE UNWIND => NULL;    SetNewBank[bank];  -- Validity check    savedBank ¬ bank;    END;  RawWriteBank: PUBLIC ENTRY PROCEDURE [bank: CPDefs.Bank] = --NEEDS HELP    BEGIN ENABLE UNWIND => NULL;    -- Yetch, copy all this code to avoid error trap<<     IF (kBuffer + 11) # 0FFFH THEN ERROR;  -- Catch dangling branch    IF ~kernelLoaded THEN ERROR CPKernelDefs.Error["Can't switch banks until Kernel has been loaded"L];    IF currentBank # 0 THEN      BEGIN      currentBank ¬ 0;      ExecuteCPBuffer[];  -- The instruction we left behind      END;    IF bank = 0 THEN RETURN;    CPKernelDefs.WriteCS[      kBuffer + 0, CPMIFormat.MI[      , , dz, rOrS, , , , , , , nibble, , [n[bank]], [d[0]], kWait]];    CPKernelDefs.WriteCS[      kBuffer + 1, CPMIFormat.MI[      , , dz, rOrS, , , , , , , nibble, , [n[bank]], [d[bank]], kBuffer + 11]];    CPKernelDefs.WriteCS[      kBuffer + 11, CPMIFormat.MI[      , , , , , , , , , , , , , , kWait]];    WriteTpcInternal[7, kBuffer + 1];    currentBank ¬ bank;>>    END;  SetNewBank: PUBLIC INTERNAL PROCEDURE [bank: CPDefs.Bank] =  --NEEDS HELP <<   BEGIN ENABLE      BEGIN      Teather.Error => BEGIN SetNewState[dead]; CPKernelDefs.Error[reason]; END;      UNWIND => NULL;      END;    locOfTemp: CPDefs.RealCS = kBuffer + 11;    IF bank = currentBank THEN RETURN;    IF bank >= banksThisMachine THEN ERROR CPKernelDefs.Error["Bank number too big"L];    CPKernelDefs.WriteCS[      locOfTemp, CPMIFormat.MI[ , , dz, rOrS, , , , , , fyNorm, nibble, , [n[bank]], [d[bank]] , kWait]];    Teather.WriteWord[csaMsb, locOfTemp];    Teather.SingleCycleFromCSA[];    currentBank ¬ bank;  >>    BEGIN    END;       ReadTpc: PUBLIC ENTRY PROCEDURE [task: CPDefs.Task] RETURNS [CPDefs.RealCS] =    BEGIN ENABLE UNWIND => NULL;    SELECT task FROM      0 => RETURN[savedTpc];      7 => RETURN[kernelTpc];      ENDCASE => ERROR CPKernelDefs.Error["Can't read strange TPC"L];     END;   ReadBank: PUBLIC ENTRY PROCEDURE RETURNS [CPDefs.Bank] =    BEGIN ENABLE UNWIND => NULL;    RETURN[savedBank];    END;   RawReadBank: PUBLIC ENTRY PROCEDURE RETURNS [CPDefs.Bank] =    BEGIN ENABLE UNWIND => NULL;    RETURN[RawReadBankInternal[]];    END;   RawReadBankInternal: INTERNAL PROCEDURE RETURNS [CPDefs.Bank] =  --NEEDS HELP <<   BEGIN ENABLE      Teather.Error => BEGIN SetNewState[dead]; CPKernelDefs.Error[reason]; END;    nia: CPDefs.BankAndWordsPerBank;    nia ¬ LOOPHOLE[Teather.ReadWord[niaMsb]];    RETURN[nia.bank];>>    BEGIN    RETURN[1];    END;   WriteTpc: PUBLIC ENTRY PROCEDURE [task: CPDefs.Task, pc: CPDefs.RealCS] =    BEGIN ENABLE UNWIND => NULL;    WriteTpcInternal[task, pc];    END;   WriteTpcInternal: PUBLIC INTERNAL PROCEDURE [task: CPDefs.Task, pc: CPDefs.RealCS] =    BEGIN    data: CPDefs.BankAndWordsPerBank = LOOPHOLE[pc];    SELECT task FROM      0 =>        BEGIN	savedTpc ¬ pc;        IF banksThisMachine > 1 THEN savedBank ¬ data.bank;	END;      7 => kernelTpc ¬ pc;      ENDCASE => ERROR CPKernelDefs.Error["Can't write strange TPC"L];     END;   WriteRealMemory: PUBLIC ENTRY PROCEDURE [realA: CPDefs.RealMemory, data: WORD] =    BEGIN ENABLE UNWIND => NULL;    sequence: LONG POINTER TO Bindweed.Sequence ¬ z.NEW[Bindweed.Sequence[Environment.bytesPerWord]];    IF Inline.HighHalf[realA] ~IN [0..1FH] THEN        CPKernelOp.AddressOutOfRange[];    sequence.length ¬ Environment.bytesPerWord;    sequence[0] ¬ LOOPHOLE[Inline.HighByte[data]];    sequence[1] ¬ LOOPHOLE[Inline.LowByte[data]];    WriteMemoryInternal[LOOPHOLE[realA], real, sequence];    END;      WriteRealMemoryInternal:PUBLIC INTERNAL PROCEDURE [realA: CPDefs.RealMemory, data: WORD] =    BEGIN ENABLE UNWIND => NULL;    sequence: LONG POINTER TO Bindweed.Sequence ¬ z.NEW[Bindweed.Sequence[Environment.bytesPerWord]];    IF Inline.HighHalf[realA] ~IN [0..1FH] THEN       CPKernelOp.AddressOutOfRange[];    sequence.length ¬ Environment.bytesPerWord;    sequence[0] ¬ LOOPHOLE[Inline.HighByte[data]];    sequence[1] ¬ LOOPHOLE[Inline.LowByte[data]];    WriteMemoryInternal[LOOPHOLE[realA], real, sequence];    END;        WriteMemoryBlock: PUBLIC ENTRY PROCEDURE [    to: LONG POINTER, count: CARDINAL, data: LONG POINTER] =    BEGIN ENABLE UNWIND => NULL;    WriteMemoryBlockInternal[LOOPHOLE[to], count, data];    END;      WriteMemoryBlockInternal: INTERNAL PROCEDURE [    to: LONG CARDINAL, count: CARDINAL, data: LONG POINTER] =    BEGIN     send: CARDINAL;    sequence: LONG POINTER TO Bindweed.Sequence;    IF Inline.HighHalf[to] ~IN [0..1FH] THEN CPKernelOp.AddressOutOfRange[];    sequence ¬ z.NEW[Bindweed.Sequence[Bindweed.maxData-1]];    WHILE count > 0 DO      send ¬ MIN[count, maxWords];      FOR i: NATURAL IN [0..send) DO	sequence[i*Environment.bytesPerWord] ¬ LOOPHOLE[Inline.HighByte[(data+i)­]];	sequence[i*Environment.bytesPerWord+1] ¬ LOOPHOLE[Inline.LowByte[(data+i)­]];	ENDLOOP;      sequence.length ¬ send * Environment.bytesPerWord;      WriteMemoryInternal[to, real, sequence];      count ¬ count - send;      data ¬ data + send;      to ¬ to + send;      ENDLOOP;    z.FREE[@sequence];    END;      WriteMemoryInternal: INTERNAL PROCEDURE [address: LONG CARDINAL, addressType: Bindweed.AddressType, sequence: LONG POINTER TO Bindweed.Sequence] =    BEGIN ENABLE       BEGIN       UNWIND => NULL;       Bindweed.Error =>         SELECT code FROM	  timeout => {SetNewState[dead]; CPKernelDefs.Error["Timeout"L]};	  badCheckSum => {SetNewState[dead]; CPKernelDefs.Error["Bad checksum"L]};	  ENDCASE => {SetNewState[dead]; CPKernelDefs.Error["Bindweed problem"L]};      END;    addr: DoveInputOutput.OpieAddressType = extendedBus;    bindweedAddress: RECORD  [      SELECT OVERLAID * FROM        one => [address: LONG CARDINAL],	many => [highHigh: Environment.Byte,	       highLow: Environment.Byte,	       lowHigh: Environment.Byte,	       lowLow: Environment.Byte],	ENDCASE];    address ¬ address * Environment.bytesPerWord;    bindweedAddress.highHigh ¬ Inline.LowByte[Inline.LowHalf[address]];    bindweedAddress.highLow ¬ Inline.HighByte[Inline.LowHalf[address]];      bindweedAddress.lowHigh ¬ Inline.LowByte[Inline.HighHalf[address]];    bindweedAddress.lowLow ¬ ORD[addr];     Bindweed.WriteMemoryBlock[bindweedAddress.address, addressType, sequence];    END;      ReadRealMemory: PUBLIC ENTRY PROCEDURE [real: CPDefs.RealMemory] RETURNS [WORD] =    BEGIN ENABLE UNWIND => NULL;    RETURN[ReadMemoryWordInternal[real]];    END;      ReadRealMemoryInternal: PUBLIC INTERNAL PROCEDURE [real: CPDefs.RealMemory] RETURNS [WORD] =    BEGIN ENABLE UNWIND => NULL;    RETURN[ReadMemoryWordInternal[real]];    END;  ReadMemoryWordInternal: INTERNAL PROCEDURE [address: CPDefs.RealMemory] RETURNS [WORD] =    BEGIN ENABLE UNWIND => NULL;    sequence: LONG POINTER TO Bindweed.Sequence;    IF Inline.HighHalf[address] ~IN [0..1FH] THEN         CPKernelOp.AddressOutOfRange[];    sequence ¬ ReadMemoryInternal[LOOPHOLE[address, LONG CARDINAL], real];     RETURN[Inline.BITOR[Inline.BITSHIFT[sequence[0], 8], sequence[1]]];    END;  ReadMemory: PUBLIC ENTRY PROCEDURE [address: LONG POINTER, addresstype: Bindweed.AddressType, words: NATURAL ¬ 1] RETURNS [LONG POINTER TO Bindweed.Sequence] =  -- this needs work but I don't believe that anyone calls it    BEGIN ENABLE UNWIND => NULL;    IF Inline.HighHalf[address] ~IN [0..1FH] THEN        CPKernelOp.AddressOutOfRange[];    RETURN[ReadMemoryInternal[LOOPHOLE[address, LONG CARDINAL], addresstype, words]];    END;      ReadMemoryInternal: INTERNAL PROCEDURE [address: LONG CARDINAL, addresstype: Bindweed.AddressType, words: NATURAL ¬ 1] RETURNS [LONG POINTER TO Bindweed.Sequence] =    BEGIN ENABLE       BEGIN       UNWIND => NULL;       Bindweed.Error =>         SELECT code FROM	  timeout => {SetNewState[dead]; CPKernelDefs.Error["Timeout"L]};	  badCheckSum => {SetNewState[dead]; CPKernelDefs.Error["Bad checksum"L]};	  ENDCASE => {SetNewState[dead]; CPKernelDefs.Error["Bindweed problem"L]};      END;      addr: DoveInputOutput.OpieAddressType = extendedBus;    bindweedAddress: RECORD  [      SELECT OVERLAID * FROM        one => [address: LONG CARDINAL],	many => [highHigh: Environment.Byte,	       highLow: Environment.Byte,	       lowHigh: Environment.Byte,	       lowLow: Environment.Byte],	ENDCASE];    address ¬ address * Environment.bytesPerWord;    bindweedAddress.highHigh ¬ Inline.LowByte[Inline.LowHalf[address]];      bindweedAddress.highLow ¬ Inline.HighByte[Inline.LowHalf[address]];    bindweedAddress.lowHigh ¬ Inline.LowByte[Inline.HighHalf[address]];      bindweedAddress.lowLow ¬ ORD[addr];    seqptr.length ¬ words*Environment.bytesPerWord;    Bindweed.ReadMemoryBlock[bindweedAddress.address, addresstype, seqptr];    RETURN[seqptr];    END;  SwapBytes: PROCEDURE [blockPtr: LONG POINTER TO Bindweed.Sequence] =    BEGIN   temp: Environment.Byte ¬ 0;    i: CARDINAL ¬ 0;    UNTIL i >= blockPtr.length DO      temp ¬ blockPtr[i];      blockPtr[i] ¬ blockPtr[i + 1];      blockPtr[i+1] ¬ temp;      i ¬ i + 2;      ENDLOOP;    END;      PrintStopState: PROCEDURE [log: Format.StringProc, arg: LONG POINTER, pc: CPDefs.RealCS] =    BEGIN    temp: STRING = [200];    virt: CPSymbl.VirturalCS;    [virt, , ] ¬ CPSymbl.RealToVirturalCS[pc];    Format.Text[log, "CP halted at "L, arg];    CPSymbl.AppendRealCS[temp, pc];    IF virt # CPSymbl.nullVirturalCS THEN      BEGIN      String.AppendString[temp, ", ("L];      CPSymbl.AppendVirturalCS[temp, virt];      String.AppendString[temp, ")"L];      END;    Format.Text[log, temp, arg];    Format.Line[log, "."L, arg];    END;      Pause: PUBLIC PROCEDURE [msec: CARDINAL ¬ 50]		-- min pause time  	= {msec ¬ 0};  --just spend some time in local frame    END.-- Log of last edits-- JAC	30-May-85 16:42:36	CP renamed to CPDefs-- JAC	31-May-85  9:46:06	CPKernel renamed to CPKernelDefs; CPKernelConstants renamed to CPKernelConst; rename module; CPSymbols renamed to CPSymbl; CPKernelOps renamed to CPKernelOp; CPMI becomes CPMIFormat-- JAC	10-Jun-85 15:52:25	new Bindweed-- JAC	20-Jun-85 10:36:40	make sure disp is only 4 bits during Stop[]-- JAC	24-Jun-85  9:57:18	change Stop to or in dispatch bits in savedTpc-- JAC	29-Oct-85 15:37:00	define mailbox-- RDH	 4-Dec-85 14:59:17	Fix bug in Stop-- RDH	 9-Dec-85 14:36:07	Change LoadKernelHigh, FindBanksInternal, FindBanks for 8K control store.-- RDH	26-Dec-85 18:36:27	Change Stop for 8K.-- RDH	 3-Feb-86 17:42:42	Fix FindBanksInternal.-- RDH	12-Mar-86 13:58:26	Set savedBank in Stop.-- RDH	14-Mar-86 11:13:47	Added recovery from no safe stopping point and checking for Bank¬ in Stop.
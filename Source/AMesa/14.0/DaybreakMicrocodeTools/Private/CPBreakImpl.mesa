-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved. -- Last edit by JAC   	     24-Mar-86 18:54:52-- CPBreakImpl.mesa, AYC   , 22-Aug-84 16:00:05-- from CPBreaker.mesa, HGM,  7-Nov-83 17:12:44--DIRECTORY  Heap USING [systemZone],  String USING [AppendNumber, AppendString],    CPDef USING [Bank, BankAndWordsPerBank, IBDisp, MDR, RealCS, wordsPerBank],  CPuFormat USING [MI, mi],  CPBreak USING [],  CPKernel USING [    AtBreak, Error, GetBreakID, InKernel, maxBreaks, ReadCS, SetBreak, WriteCS],    CPKernelOps USING [GetShiftRegflags];CPBreakImpl: MONITOR  IMPORTS Heap, String, CPKernel, CPKernelOps  EXPORTS CPBreak =  BEGIN    z: UNCOUNTED ZONE = Heap.systemZone;    head: Breakpoint ¬ NIL;  breaksInstalled: BOOLEAN ¬ FALSE;    WordInBank: TYPE = [0..CPDef.wordsPerBank);    lastBreakInfo: RECORD [location: CPDef.RealCS, ibdisp: CPDef.IBDisp, mdr: CPDef.MDR, mi: CPuFormat.mi];    Error: PUBLIC ERROR [reason: LONG STRING] = CODE;    Breakpoint: TYPE = LONG POINTER TO  BreakpointInfo;  BreakpointInfo: TYPE = RECORD [    location: CPDef.RealCS,    mi: CPuFormat.mi,    ibdisp: CPDef.IBDisp,    mdr: CPDef.MDR,    next: Breakpoint];    Break: PUBLIC ENTRY PROCEDURE [location: CPDef.RealCS, ibdisp: CPDef.IBDisp, mdr: CPDef.MDR] RETURNS[CPuFormat.mi] =    BEGIN ENABLE      BEGIN      CPKernel.Error => ERROR Error[reason];      UNWIND => NULL;      END;    new: Breakpoint;    id: CARDINAL ¬ 1;  -- The one we want to add    BeSureInKernel[];    RemoveBreaksInternal[];    FOR finger: Breakpoint ¬ head, finger.next UNTIL finger = NIL DO      IF finger.location = location THEN ERROR Error["Breakpoint already set there"L];      id ¬ id + 1;      ENDLOOP;    IF id >= CPKernel.maxBreaks THEN ERROR Error["Too many breakpoints"L];    new ¬ z.NEW[BreakpointInfo];    new­ ¬ [location, LOOPHOLE[CPKernel.ReadCS[location], CPuFormat.mi], ibdisp, mdr, head];    head ¬ new;    RETURN[new.mi];    END;	    Unbreak: PUBLIC ENTRY PROCEDURE [location: CPDef.RealCS, ibdisp: CPDef.IBDisp, mdr: CPDef.MDR] =    BEGIN ENABLE      BEGIN      CPKernel.Error => ERROR Error[reason];      UNWIND => NULL;      END;    previous: Breakpoint ¬ NIL;    BeSureInKernel[];    RemoveBreaksInternal[];    FOR finger: Breakpoint ¬ head, finger.next UNTIL finger = NIL DO      IF finger.location = location THEN        BEGIN	temp: Breakpoint ¬ finger;  -- Rats, can't smash LOOP control variable	IF ibdisp # finger.ibdisp OR mdr # finger.mdr THEN	  ERROR Error["IBDisp/MDR flag(s) confusion"L];	IF previous = NIL THEN head ¬ finger.next	ELSE previous.next ¬ finger.next;	z.FREE[@temp];	RETURN;	END;      previous ¬ finger;      ENDLOOP;    ERROR Error["Breakpoint not found"L];    END;    ClearAllBreaks: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE UNWIND => NULL;    BeSureInKernel[];    Smash[];    END;  EnumerateBreaks: PUBLIC ENTRY PROCEDURE [proc: PROCEDURE[CPDef.RealCS]] =    BEGIN ENABLE UNWIND => NULL;    FOR finger: Breakpoint ¬ head, finger.next UNTIL finger = NIL DO      proc[finger.location];      ENDLOOP;    END;    Reset: PUBLIC ENTRY PROCEDURE =    BEGIN    Smash[];    END;    Smash: INTERNAL PROCEDURE =    BEGIN    breaksInstalled ¬ FALSE;    UNTIL head = NIL DO      temp: Breakpoint ¬ head;      head ¬ head.next;      z.FREE[@temp];      ENDLOOP;    END;      FindBreak: PUBLIC ENTRY PROCEDURE [break: CARDINAL] RETURNS [pc: CPDef.RealCS] =    BEGIN    currentBreak: CARDINAL ¬ 1;    FOR finger: Breakpoint ¬ head, finger.next UNTIL finger = NIL DO      IF currentBreak = break THEN RETURN[finger.location];      currentBreak ¬ currentBreak + 1;      ENDLOOP;    END;  InstallBreaks: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE      BEGIN      CPKernel.Error => ERROR Error[reason];      UNWIND => NULL;      END;    id: CARDINAL ¬ 0;    BeSureInKernel[];    IF breaksInstalled THEN RETURN;    breaksInstalled ¬ TRUE;    FOR finger: Breakpoint ¬ head, finger.next UNTIL finger = NIL DO      MI: CPuFormat.MI ¬ CPKernel.ReadCS[finger.location];      finger.mi ¬ LOOPHOLE[MI, CPuFormat.mi];      CPKernel.SetBreak[finger.location, MI, id];      id ¬ id + 1;      ENDLOOP;    IF id >= CPKernel.maxBreaks THEN ERROR;    END;    RemoveBreaks: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE UNWIND => NULL;    RemoveBreaksInternal[];    END;    RemoveBreaksInternal: INTERNAL PROCEDURE =    BEGIN ENABLE CPKernel.Error => ERROR Error[reason];    id: CARDINAL ¬ 0;    currentBreakID: CARDINAL ¬ nullBreakID;    nullBreakID: CARDINAL = LAST[CARDINAL];    BeSureInKernel[];    IF ~breaksInstalled THEN RETURN;    breaksInstalled ¬ FALSE;    IF CPKernel.AtBreak[] THEN currentBreakID ¬ CPKernel.GetBreakID[];    FOR finger: Breakpoint ¬ head, finger.next UNTIL finger = NIL DO      IF id = currentBreakID THEN        BEGIN  -- In case it gets deleted	lastBreakInfo ¬ [finger.location, finger.ibdisp, finger.mdr, finger.mi];	currentBreakID ¬ nullBreakID;	END;      CPKernel.WriteCS[finger.location, LOOPHOLE[finger.mi, CPuFormat.MI]];      id ¬ id + 1;      ENDLOOP;    IF currentBreakID # nullBreakID THEN      BEGIN      text: STRING = [200];      String.AppendString[text, "Breakpoint confusion -- Mark 1. ID = "L];      String.AppendNumber[text, currentBreakID, 16];      ERROR Error[text];      END;    END;    GetLastBreakInfo: PUBLIC PROCEDURE RETURNS [CPDef.RealCS, CPDef.IBDisp, CPDef.MDR, CPuFormat.mi] =    BEGIN    RemoveBreaks[];    RETURN[lastBreakInfo.location, lastBreakInfo.ibdisp, lastBreakInfo.mdr, lastBreakInfo.mi];    END;    GetBreakInfo: PUBLIC PROCEDURE RETURNS [CPDef.RealCS, CPDef.RealCS, BOOLEAN, BOOLEAN, BOOLEAN, CPuFormat.mi] =    BEGIN    MI: CPuFormat.MI ¬ LOOPHOLE[lastBreakInfo.mi];    flags: RECORD [       EOPTrap: BOOLEAN, EXTInt: BOOLEAN, CSParity: BOOLEAN];    [flags.EOPTrap, flags.EXTInt, flags.CSParity] ¬       CPKernelOps.GetShiftRegflags[];        RETURN[lastBreakInfo.location,            MI.context.common.inia +	      SplitReal[lastBreakInfo.location].bank * CPDef.wordsPerBank, 	   flags.EOPTrap, 	   flags.EXTInt, 	   flags.CSParity, 	   lastBreakInfo.mi];    END;  SplitReal: PROCEDURE [real: CPDef.RealCS] RETURNS [bank: CPDef.Bank, wordInBank: WordInBank] =    BEGIN    temp: CPDef.BankAndWordsPerBank = LOOPHOLE[real];    RETURN[temp.bank, temp.wordInBank];    END;    BeSureInKernel: INTERNAL PROCEDURE =    BEGIN    IF ~CPKernel.InKernel[] THEN ERROR Error["Can't adjust breaks while running (or crashed)"L];    END;    END.  -- Log:-- JAC   	 9-Jan-85 18:21:44	added FindBreak-- JAC   	13-Mar-85 14:45:18	added RETURN from Break-- JAC   	24-Mar-86 18:55:03	fix GetBreakInfo
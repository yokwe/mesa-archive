-- Copyright (C) 1983, 1985  by Xerox Corporation. All rights reserved. -- Last edit by JAC 	 7-Jun-85 10:15:24	to use in BurdockDaybreak-- CPLoaderExtra.mesa, HGM, 26-Dec-83 20:32:36DIRECTORY  Environment USING [bytesPerWord, bytesPerPage, wordsPerPage],  Format USING [CR, Line, LongDecimal, StringProc, Text],  Heap USING [systemZone],  Inline USING [BITAND, BITSHIFT, BITXOR],  MStream USING [Error, ReadOnly],  Stream USING [Delete, EndOfStream, GetBlock, Handle],  String USING [AppendChar, AppendExtensionIfNeeded, AppendString, CopyToNewString],  System USING [GetClockPulses, Pulses, PulsesToMicroseconds],  UserInput USING [UserAbort],  CP USING [Bank, RealCS, sizeOfCS, wordsPerBank],  CPMI USING [MI],  CPCommands USING [Error, RefreshWindow],  CPKernel USING [    Error, ReadCS, ReadBank, WriteMemoryBlock, WriteNextMemoryBlock],  CPSymbols USING [    AppendRealCS, AppendMI, AppendVirturalCS, nullVirturalCS, RealToVirturalCS, VirturalCS],  MassFileFormat USING [FinalBinaryRec];CPLoaderExtra: PROGRAM  IMPORTS    Format, Heap, Inline, MStream, Stream, String, System, UserInput,    CPCommands, CPKernel, CPSymbols  EXPORTS CPCommands =  BEGIN    z: UNCOUNTED ZONE = Heap.systemZone;  LoadAIS: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, file: LONG STRING] =    BEGIN    filename: LONG STRING;    stream: Stream.Handle;    filename ¬ String.CopyToNewString[file, z];    [] ¬ String.AppendExtensionIfNeeded[@filename, "ais"L, z];    Format.Text[log, "Loading real memory from "L, arg];    Format.Text[log, filename, arg];    Format.Line[log, "."L, arg];    stream ¬ MStream.ReadOnly[filename, [] ! MStream.Error =>      ERROR CPCommands.Error["Can't read that file"] ];    LoadAISFromStream[log, arg, stream !      UNWIND => BEGIN Stream.Delete[stream]; z.FREE[@filename]; END ];    Stream.Delete[stream];    z.FREE[@filename];    CPCommands.RefreshWindow[];    END;  LoadAISFromStream: PROCEDURE [log: Format.StringProc, arg: LONG POINTER, stream: Stream.Handle] =    BEGIN ENABLE      Stream.EndOfStream => ERROR CPCommands.Error["Truncated cpr file"L];    buffer: ARRAY [0..Environment.wordsPerPage) OF WORD;    start, stop: System.Pulses;    ms: LONG CARDINAL;    where: LONG POINTER ¬ LOOPHOLE[LONG[0]];  -- Start at 0 in Memory!!!    wordsStored, blocks: LONG CARDINAL ¬ 0;    start ¬ System.GetClockPulses[];    DO      bytes, words: CARDINAL;      [bytes, , ] ¬ Stream.GetBlock[        sH: stream,        block: [	  blockPointer: LOOPHOLE[LONG[@buffer]],	  startIndex: 0,          stopIndexPlusOne: Environment.bytesPerPage]];      words ¬ bytes / Environment.bytesPerWord;      IF blocks = 0 THEN        BEGIN        CPKernel.WriteMemoryBlock[where, words, @buffer          ! CPKernel.Error => ERROR CPCommands.Error[reason] ];        END      ELSE        CPKernel.WriteNextMemoryBlock[where, words, @buffer          ! CPKernel.Error => ERROR CPCommands.Error[reason] ];      blocks ¬ blocks + 1;      wordsStored ¬ wordsStored + words;      where ¬ where + words;      IF bytes # Environment.bytesPerPage THEN EXIT;      ENDLOOP;    stop ¬ System.GetClockPulses[];    ms ¬ System.PulsesToMicroseconds[[stop - start]]/1000;    InfoReal[log, arg, ms, wordsStored, blocks];    END;	  InfoReal: PROCEDURE [log: Format.StringProc, arg: LONG POINTER, ms, words, blocks: LONG CARDINAL] =    BEGIN    Format.Text[log, "It took "L, arg];    Format.LongDecimal[log, ms, arg];    Format.Text[log, " ms to load "L, arg];    Format.LongDecimal[log, words, arg];    Format.Text[log, " words in "L, arg];    Format.LongDecimal[log, blocks, arg];    Format.Text[log, " blocks."L, arg];    IF ms # 0 THEN      BEGIN      Format.Text[log, " ("L, arg];      Format.LongDecimal[log, words*16*1000/ms, arg];      Format.Text[log, " bits/sec)"L, arg];      END;    Format.CR[log, arg];    END;  Compare: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, file: LONG STRING] =    BEGIN    filename: LONG STRING;    stream: Stream.Handle;    filename ¬ String.CopyToNewString[file, z];    [] ¬ String.AppendExtensionIfNeeded[@filename, "fb"L, z];    Format.Text[log, "Comparing CP with "L, arg];    Format.Text[log, filename, arg];    Format.Line[log, "."L, arg];    stream ¬ MStream.ReadOnly[filename, [] ! MStream.Error =>      ERROR CPCommands.Error["Can't read that file"] ];    CompareFromStream[log, arg, stream !      UNWIND => BEGIN Stream.Delete[stream]; z.FREE[@filename]; END ];    Stream.Delete[stream];    z.FREE[@filename];    CPCommands.RefreshWindow[];    END;  CompareFromStream: PROCEDURE [log: Format.StringProc, arg: LONG POINTER, stream: Stream.Handle] =    BEGIN ENABLE      BEGIN      Stream.EndOfStream => ERROR CPCommands.Error["Truncated fb file"L];      CPKernel.Error => ERROR CPCommands.Error[reason];      END;    start, stop: System.Pulses;    ms: LONG CARDINAL;    instructions, mismatches: CARDINAL ¬ 0;    fbrBytes: CARDINAL = Environment.bytesPerWord*SIZE[MassFileFormat.FinalBinaryRec];    b: POINTER = @fbr;    fbr: MassFileFormat.FinalBinaryRec ¬ TRASH;    pb: POINTER TO CPMI.MI = LOOPHOLE[@fbr.partialBinary];    offset: CARDINAL = CPKernel.ReadBank[] * CP.wordsPerBank;  -- ***  Hack until Mass is smarter    start ¬ System.GetClockPulses[];    DO      bytes: CARDINAL;      [bytes, , ] ¬ Stream.GetBlock[          sH: stream,          block: [            blockPointer: b,	    startIndex: 0,            stopIndexPlusOne: fbrBytes]];      IF bytes # fbrBytes THEN ERROR CPCommands.Error["Truncated fb"];      IF fbr.addr >= CP.sizeOfCS THEN EXIT;      fbr.addr ¬ fbr.addr + offset;      IF fbr.miNum = 0FFFFH THEN        BEGIN	NULL; -- This slot initializes a TPC        END      ELSE        BEGIN	addr: CP.RealCS ¬ fbr.addr;	expected: CPMI.MI ¬ pb­;	found: CPMI.MI ¬ CPKernel.ReadCS[addr];	badParity: BOOLEAN ¬ BadParity[found];	instructions ¬ instructions + 1;	IF found # expected OR badParity THEN	  BEGIN	  xor: CPMI.MI;	  text: STRING = [200];	  FOR i: CARDINAL IN [0..SIZE[CPMI.MI]) DO	    a: POINTER = LOOPHOLE[@expected+i];	    b: POINTER = LOOPHOLE[@found+i];	    c: POINTER = LOOPHOLE[@xor+i];	    c­ ¬ Inline.BITXOR[a­, b­];	    ENDLOOP;	  IF mismatches = 0 THEN	    Format.Line[log, "    Addr         expected            found              xor"L, arg];	  mismatches ¬ mismatches + 1;	  CPSymbols.AppendRealCS[text, addr];	  FOR i: CARDINAL IN [text.length..8) DO String.AppendChar[text, ' ]; ENDLOOP;	  String.AppendString[text, "   "L];	  CPSymbols.AppendMI[text, expected];	  String.AppendString[text, "   "L];	  CPSymbols.AppendMI[text, found];	  IF badParity THEN String.AppendString[text, "*  "L]	  ELSE String.AppendString[text, "   "L];	  CPSymbols.AppendMI[text, xor];	  Format.Line[log, text, arg];	  END;        END;      IF UserInput.UserAbort[NIL] THEN EXIT;  -- Better than nothing...      ENDLOOP;    stop ¬ System.GetClockPulses[];    ms ¬ System.PulsesToMicroseconds[[stop - start]]/1000;    InfoCompare[log, arg, ms, instructions, mismatches];    END;      BadParity: PROCEDURE [data: CPMI.MI] RETURNS [BOOLEAN] =    BEGIN    words: LONG POINTER = @data;    parity: WORD ¬ 0;    FOR i: CARDINAL IN [0..SIZE[CPMI.MI]) DO      parity ¬ Inline.BITXOR[parity, (words+i)­];      ENDLOOP;    parity ¬ Inline.BITXOR[parity, Inline.BITSHIFT[parity, -8]];    parity ¬ Inline.BITXOR[parity, Inline.BITSHIFT[parity, -4]];    parity ¬ Inline.BITXOR[parity, Inline.BITSHIFT[parity, -2]];    parity ¬ Inline.BITXOR[parity, Inline.BITSHIFT[parity, -1]];    RETURN[Inline.BITAND[parity, 1] # 0];    END;  InfoCompare: PROCEDURE [    log: Format.StringProc, arg: LONG POINTER, ms, instructions, mismatches: LONG CARDINAL] =    BEGIN    Format.Text[log, "It took "L, arg];    Format.LongDecimal[log, ms, arg];    Format.Text[log, " ms to compare "L, arg];    Format.LongDecimal[log, instructions, arg];    Format.Text[log, " instructions."L, arg];    IF ms # 0 THEN      BEGIN      Format.Text[log, " ("L, arg];      Format.LongDecimal[log, instructions*16*SIZE[CPMI.MI]*1000/ms, arg];      Format.Text[log, " bits/sec)"L, arg];      END;    Format.CR[log, arg];    IF mismatches # 0 THEN      BEGIN      Format.Text[log, "There were "L, arg];      Format.LongDecimal[log, mismatches, arg];      Format.Line[log, " mismatches."L, arg];      END;    END;  CrossJump: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, file: LONG STRING] =    BEGIN    filename: LONG STRING;    stream: Stream.Handle;    filename ¬ String.CopyToNewString[file, z];    [] ¬ String.AppendExtensionIfNeeded[@filename, "fb"L, z];    Format.Text[log, "Scanning "L, arg];    Format.Text[log, filename, arg];    Format.Line[log, " for Cross Jump opportunities."L, arg];    stream ¬ MStream.ReadOnly[filename, [] ! MStream.Error =>      ERROR CPCommands.Error["Can't read that file"] ];    CrossJumpFromStream[log, arg, stream !      UNWIND => BEGIN Stream.Delete[stream]; z.FREE[@filename]; END ];    Stream.Delete[stream];    z.FREE[@filename];    CPCommands.RefreshWindow[];    END;  CrossJumpFromStream: PROCEDURE [    log: Format.StringProc, arg: LONG POINTER, stream: Stream.Handle] =    BEGIN ENABLE      BEGIN      Stream.EndOfStream => ERROR CPCommands.Error["Truncated fb file"L];      CPKernel.Error => ERROR CPCommands.Error[reason];      END;    Info: TYPE = ARRAY [0..CP.wordsPerBank) OF RECORD [mi: CPMI.MI, exists: BOOLEAN];    start, stop: System.Pulses;    ms: LONG CARDINAL;    instructions: CARDINAL ¬ 0;    fbrBytes: CARDINAL = Environment.bytesPerWord*SIZE[MassFileFormat.FinalBinaryRec];    b: POINTER = @fbr;    fbr: MassFileFormat.FinalBinaryRec ¬ TRASH;    pb: POINTER TO CPMI.MI = LOOPHOLE[@fbr.partialBinary];    info: LONG POINTER TO Info ¬ NIL;    start ¬ System.GetClockPulses[];    info ¬ z.NEW[Info];    info­ ¬ ALL[[TRASH, FALSE]];    DO      bytes: CARDINAL;      [bytes, , ] ¬ Stream.GetBlock[          sH: stream,          block: [            blockPointer: b,	    startIndex: 0,            stopIndexPlusOne: fbrBytes]];      IF bytes # fbrBytes THEN ERROR CPCommands.Error["Truncated fb"];      IF fbr.addr >= CP.sizeOfCS THEN EXIT;      IF fbr.miNum = 0FFFFH THEN        BEGIN	NULL; -- This slot initializes a TPC        END      ELSE        BEGIN	info[fbr.addr] ¬ [pb­, TRUE];	instructions ¬ instructions + 1;        END;      IF UserInput.UserAbort[NIL] THEN EXIT;  -- Better than nothing...      ENDLOOP;    FOR i: CARDINAL IN [0..CP.wordsPerBank) DO      hit: BOOLEAN ¬ FALSE;      IF ~info[i].exists THEN LOOP;      FOR j: CARDINAL IN [i+1..CP.wordsPerBank) DO        IF ~info[j].exists THEN LOOP;	IF info[i].mi = info[j].mi THEN	  BEGIN	  temp: STRING = [200];	  virt: CPSymbols.VirturalCS;	  IF ~hit THEN	    BEGIN	    hit ¬ TRUE;	    [virt, ] ¬ CPSymbols.RealToVirturalCS[i];	    IF virt # CPSymbols.nullVirturalCS THEN	      CPSymbols.AppendVirturalCS[temp, virt]	    ELSE CPSymbols.AppendRealCS[temp, i];	    END;	  String.AppendString[temp, " = "L];	  [virt, ] ¬ CPSymbols.RealToVirturalCS[j];	  IF virt # CPSymbols.nullVirturalCS THEN	    CPSymbols.AppendVirturalCS[temp, virt]	  ELSE CPSymbols.AppendRealCS[temp, j];          Format.Text[log, temp, arg];	  info[j].exists ¬ FALSE;	  END;        ENDLOOP;      IF hit THEN Format.CR[log, arg];      IF UserInput.UserAbort[NIL] THEN EXIT;  -- Better than nothing...      ENDLOOP;    z.FREE[@info];    stop ¬ System.GetClockPulses[];    ms ¬ System.PulsesToMicroseconds[[stop - start]]/1000;    InfoCrossJump[log, arg, ms, instructions];    END;      InfoCrossJump: PROCEDURE [    log: Format.StringProc, arg: LONG POINTER, ms, instructions: LONG CARDINAL] =    BEGIN    Format.Text[log, "It took "L, arg];    Format.LongDecimal[log, ms, arg];    Format.Text[log, " ms to Cross Jump "L, arg];    Format.LongDecimal[log, instructions, arg];    Format.Text[log, " instructions."L, arg];    IF ms # 0 THEN      BEGIN      Format.Text[log, " ("L, arg];      Format.LongDecimal[log, instructions*16*SIZE[CPMI.MI]*1000/ms, arg];      Format.Text[log, " bits/sec)"L, arg];      END;    Format.CR[log, arg];    END;  END.
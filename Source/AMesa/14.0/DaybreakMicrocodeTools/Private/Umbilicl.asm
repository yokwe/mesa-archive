$MOD186$PAGELENGTH	(72)$PAGEWIDTH	(136); Umbilical Send and Receive Handlers; Last edit by FXB 17-Aug-84 15:20:03; FXB.PA, 17-Jul-84 15:44:33, action: added WaitForCondition (OFFSET umbilicalSendAvail;--	JAC	15-Oct-85 10:48:30	:updated to reconfigurable Opie;--	JAC	23-Jul-85 16:08:23	:added Enable after ThisTaskServices for Opie20;--	FXB.PA	13-Mar-85 11:38:17	:changed WaitForInterrupt for OPIE19;--	FXB.PA	14-Feb-85 17:48:27	:added blockAddrA;--	FXB.PA	 3-Dec-84 18:41:25	:made independent of RHTestHandler;--	FXB.PA	 3-Dec-84 15:17:24	:move task initilization;--	FXB.PA	30-Nov-84  9:53:33	:updated to OPIE!16;--	FXB.PA	29-Nov-84 13:06:31	:removed reinitialization of umbilical input interrupt;--	FXB.PA	27-Nov-84 16:25:26	:fixes for RAM based debugger;--	FXB.PA	26-Nov-84 13:52:38	:included debugger int vector init;--	FXB.PA	15-Oct-84 11:05:06;--	FXB.PA	 4-Oct-84 16:23:45	:made badInterrupts be FAR PROCs;--	FXB.PA	 4-Oct-84  8:33:37	:omitted initialization of test task;--	FXB.PA	 1-Oct-84 13:28:22	:commented out bad interrupt handling;--	FXB.PA	28-Sep-84 11:59:48	:separated out test handler;--	FXB.PA	28-Sep-84 10:56:17	:fixed RET to IRET in DownNotify;--	FXB.PA	27-Sep-84 16:06:24	:made Down Notify a software int;--	FXB.PA	26-Sep-84 14:59:45	:made umbilical send code more compact;--	FXB.PA	21-Sep-84 15:00:06	:SAVE ES on Stack before Waits;--	FXB.PA	11-Sep-84 14:10:39	:made changed Bindweed to a procedure call;--	FXB.PA	11-Sep-84 10:19:23	:added NotifyClientCondition for version 13 of OPIE ;--	FXB.PA	24-Aug-84 14:10:12;--	FXB.PA	21-Aug-84 14:12:59	:made Bindweed EXTRN;--	FXB.PA	20-Aug-84  9:37:38	:fixes for Umbilical Send;--	FXB.PA	 9-Aug-84 11:59:58	:made compatible with Song Bord	NAME	UMBILICL$	TITLE(Umbilical Send and Receive Handlers)$	NOLIST			$	INCLUDE(IOPDefs.asm)$	INCLUDE(IOPMacro.asm)$	INCLUDE(OpieDefs.asm)$	INCLUDE(UmbDefs.asm)$	INCLUDE(HARDDEFS.ASM)$	LIST		asynchNotifyBuffer	EQU	0F00H ;???currently conficts with Enet testing regionEXTRN	umbilicalHandlerID: 	ABSEXTRN	umbilicalRecInterrupt: 	ABSEXTRN	umbilicalSendInterrupt: ABSEXTRN	BreakIntrHandler: 	NEAR EXTRN	SSIntrHandler: 		NEAR EXTRN	DebuggerIntrHandler: 	NEAR EXTRN	Bindweed: 		NEAR;Bindweed is a label in ROM,;DebugStatus is a variable in low RAM duplicated in the IORegion;temporarily using ES segment override to access low RAM;this code assumes that ES = 0 and that no one will change it!;would prefer that SS = 0 so wouldn't need overrideUmbilicalIOR		SEGMENT	COMMON 			;ORG OFFSET umbilicalIOR			ASSUME DS: UmbilicalIOR;PUBLIC umbilicalTask, upNotifyMask, upNotifyCond EXTRN	umbilicalFCB:		NEAREXTRN	umbilicalTask:		TaskContextBlockEXTRN	umbilicalSendTask:	TaskContextBlockEXTRN	umbilicalSendCond:	ConditionEXTRN	umbilicalSendAvail:	ConditionEXTRN	urBufferIndex:		WORDEXTRN	urCount:		BYTEEXTRN	usBufferIndex:		WORDEXTRN	usCount:		BYTEEXTRN	DebugStatus:		WORDEXTRN	upNotifyMask:		WORD;UmbilicalIOR		ENDS;BindweedIOR		SEGMENT	COMMON EXTRN	bindweedFCB: 		NEAREXTRN	bindweedTask: 		TaskContextBlockEXTRN	upNotifyTask: 		TaskContextBlockEXTRN	remHeadsTestTask: 	TaskContextBlockEXTRN	remHeadsTestCond: 	ConditionEXTRN	rhClientCondition: 	ClientConditionEXTRN	upNotifyCond: 		ConditionEXTRN	bindweedCond: 		ConditionEXTRN	remHeadsDownNotifyMask: WORDEXTRN	blockAddrA: 		OpieAddress;BindweedIOR		ENDSUmbilicalIOR		ENDSOpieIOR			SEGMENT	COMMONEXTRN			workNotifierBits: WORDEXTRN			workNotifierCondition: ConditionOpieIOR			ENDSIOPELocalRAM		SEGMENT AT 0EXTRN			i186NMI: SegmentAndOffsetEXTRN			i186SingleStep: SegmentAndOffsetEXTRN			i186BreakPoint: SegmentAndOffsetEXTRN			BindweedBuffer: BYTEEXTRN			BurdockSavedRegisters: WORDIOPELocalRAM		ENDSUmbilicalSTK		SEGMENT COMMONEXTRN			UmbilicalStack: WORDEXTRN			UmbilicalSendStack: WORDEXTRN			UpNotifyStack: WORDEXTRN			BindweedStack: WORDUmbilicalSTK		ENDSPUBLIC	UmbilicalInitIOPEInROM 		SEGMENT	WORD PUBLIC			ASSUME CS: IOPEInROM	;-------------------------------------------------------------------; SUBROUTINE : SetNMIDebugIntrVectors;SetNMIDebugIntrVectors:	MOV	AX, OFFSET DebuggerIntrHandler		;Set BX,AX to	MOV	BX, SEG DebuggerIntrHandler	;the CS:IP to be stored	MOV	SI, OFFSET i186NMI		;	MOV	ES:[SI], AX		;Store the new IP	MOV	ES:[SI+2], BX 		;and the new CS	RET;;-------------------------------------------------------------------------; SUBROUTINE : SetSingleStepIntrVectors;SetSingleStepIntrVectors:	MOV	AX, OFFSET SSIntrHandler	;Set BX,AX to	MOV	BX, SEG SSIntrHandler	;the CS:IP to be stored	MOV	SI, OFFSET  i186SingleStep		;Interrupt Type #01h	MOV	ES:[SI], AX		;Store the new IP	MOV	ES:[SI+2], BX 		;and the new CS	RET;;-------------------------------------------------------------------------; SUBROUTINE : SetBreakIntrVectors;SetBreakIntrVectors:	MOV	AX, OFFSET BreakIntrHandler	;Set BX,AX to	MOV	BX, SEG BreakIntrHandler	;the CS:IP to be stored	MOV	SI, OFFSET i186BreakPoint		;Interrupt Type #03h	MOV	ES:[SI], AX		;Store the new IP	MOV	ES:[SI+2], BX 		;and the new CS	RET;;-------------------------------------------------------------------------;UmbilicalInit	PROC	FAR	;initialization	%InitializeTask(umbilicalHandlerID, OFFSET umbilicalTask, UmbilicalStart, OFFSET UmbilicalStack)	%InitializeTask(umbilicalHandlerID, OFFSET umbilicalSendTask, usInit, OFFSET UmbilicalSendStack)	%InitializeTask(umbilicalHandlerID, OFFSET bindweedTask, BindweedHandler, OFFSET BindweedStack)	%InitializeTask(umbilicalHandlerID, OFFSET upNotifyTask, UpNotifyHandler, OFFSET UpNotifyStack)	RETUmbilicalInit	ENDPUmbilicalStart:	XOR	AX, AX	MOV	ES, AX		;zero ES for accessing low RAM	%DisableInterruptsTillNextWait	CALL SetNMIDebugIntrVectors	CALL SetSingleStepIntrVectors	CALL SetBreakIntrVectors	%ThisTaskServices(umbilicalRecInterrupt, UmbilicalRecBadInterrupt)	%Enable(umbilicalRecInterrupt)	;ThisTaskServices no longer does this	;prenotify umbilicalSendAvail 	%NotifyCondition (OFFSET umbilicalSendAvail)	XOR	AX, AX	MOV	ES, AX		;zero ES for accessing low RAMurSetUp: 	MOV	urBufferIndex, OFFSET BindweedBuffer	%WaitForInterrupt (1)	JC	urSetUp	CALL	UmbGetInByte		;AL _ inputByte;; 			Does not return if "Bad Data"	MOV	urCount, AL		;initCount		%WaitForInterrupt (1)	JC	urSetUp		CALL	UmbGetInByte		; AL _ inputByte; 			Does not return for "Bad Data"	CMP	urCount, AL		;is count correct?	JNE	urBadCount		;bad count	urLoop:	%WaitForInterrupt (1)	JC	urSetUp       	CALL	UmbGetInByte		;AL _ inputByte	DEC 	urCount	JZ	urDone			;IF count = 0 THEN EXIT		JMP	urLoop 	urDone:			%NotifyCondition (OFFSET bindweedCond)	JMP	urSetUp 	;We can notify bindweed and wait more input because the debugger will not send ;any more data until it receives a reply or times out;If the debugger sends 2 consecutive packets without waiting for replies ;obviously the replies will be smashed since there is only one buffer			UmbGetInByte:				;Byte returned in Al	IN	Al, i8255portC		;(portC is the status port!)	TEST	Al, i8255inReady	;Check for a byte ready	JZ	urBadDataPop		;wait until there is one ready					;	IN	Al, i8255portB		;get the byte and place it in memory	MOV	BP, urBufferIndex	MOV	ES:[BP], AL		;put count in buffer	INC	urBufferIndex		RETurBadDataPop:	POP	AX	MOV	AX, urBadIntrMask	JMP	urBadDataurBadCount:	MOV	AX, urBadCountMaskurBadData:	MOV	BP, OFFSET DebugStatus	OR	ES:[BP], AX	;set badData maskurFlushLoop:	%WaitForInterrupt (1)	;Eventually we will get a watchDog Timeout	JC	urSetUp	MOV	urBufferIndex, OFFSET BindweedBuffer	CALL	UmbGetInByte		;AL ¬ inputByte	JMP	urFlushLoop ;Come here for watchDog-Timeout or unexpectedInterrupt	UmbilicalRecBadInterrupt PROC FAR	RETUmbilicalRecBadInterrupt ENDPurQuit:;	OR	ES:[BP], AX	;set badData mask	JMP	urSetUp ;============================================================================BindweedHandler:	%WaitForCondition (OFFSET bindweedCond,noTimeout)	XOR	AX, AX	MOV	ES, AX		;zero ES for accessing low RAM	PUSH	DS	MOV	DS, AX		;Bindweed assumes this is set for low RAM	MOV	BX, OFFSET BurdockSavedRegisters	MOV	DI, OFFSET BindweedBuffer	;CPBermDb assumes this has been set	CLI	CALL Bindweed	POP	DS	STI	%WaitForCondition (OFFSET umbilicalSendAvail,noTimeout)	; set buffer address	MOV	usBufferIndex, OFFSET BindweedBuffer	%NotifyCondition (OFFSET umbilicalSendCond)	JMP	BindweedHandler;	;============================================================================;	UMBILICAL SEND HANDLER;  CX = bytes to send;  BX = index into buffer    usInit:  ;initialization    	%DisableInterruptsTillNextWait	%ThisTaskServices(umbilicalSendInterrupt, UmbilicalSendBadInterrupt)	%Enable(umbilicalSendInterrupt)	;ThisTaskServices doesn't do this anymoreusStart:	    	%WaitForCondition (OFFSET umbilicalSendCond,noTimeout)	XOR	AX, AX	MOV	ES, AX		;zero ES for accessing low RAM	MOV	BX, usBufferIndex	XOR	CX, CX		;clear CX	MOV	CL, ES:[BX]	ADD	CL, 2	;usCount ¬ count + 2 (size of entire buffer)    usLoop:	MOV	DL, ES:[BX]		;Get a byte from the send buffer	CALL	DebPutOutByte		;Send the byte to the debugger	PUSH	BX	PUSH	CX	%WaitForInterrupt (1) 	JC	usStart       	POP	CX	POP	BX	INC	BX	LOOP	usLoop  	  usDone:	%NotifyCondition (OFFSET umbilicalSendAvail)	JMP  usStart 	UmbilicalSendBadInterrupt PROC FAR;	MOV	BP, OFFSET DebugStatus;	MOV	AX, usWatchDogTimeoutMask;	OR	ES:[BP], AX	RETUmbilicalSendBadInterrupt ENDPDebPutOutByte:	IN	Al, i8255portC		;(portC is the status port!)	TEST	Al, i8255outReady		;Check for "ok to put byte"	JZ	DebPutOutByte		;wait	MOV	Al, Dl			;Get the argument	OUT	i8255portA, Al		;       	RET		;==============================================================================	BindweedDownNotify:	PUSH 	ES	MOV	AX, OpieIOR	MOV	ES, AX		OR	ES:workNotifierBits, AX   	%NotifyCondition (OFFSET workNotifierCondition)	POP	ES	IRET 	;============================================================================UpNotifyHandler:BindweedDownNotifyInt	EQU	16BindweedDownNotifyVec	EQU	BindweedDownNotifyInt*4	;set up vector for  Down Notify	XOR	AX, AX	MOV	ES, AX				;make ES point to low RAM	MOV	AX, OFFSET BindweedDownNotify	;Set BX,AX to	MOV	BX, SEG BindweedDownNotify	;the CS:IP to be stored	MOV	SI, BindweedDownNotifyVec	MOV	ES:[SI], AX			;Store the new IP	MOV	ES:[SI + 2], BX			;and the new CS	%WaitForCondition (OFFSET upNotifyCond,noTimeout)	CALL	UpNotify	JMP	UpNotifyHandler;;=============================================================================UpNotify:	%WaitForCondition (OFFSET umbilicalSendAvail,noTimeout)	MOV	AX, upNotifyMask	MOV 	debugStatus, AX	MOV	upNotifyMask, 0	CALL	PrepareAsynchNotifyBuffer	MOV	usBufferIndex, asynchNotifyBuffer	%NotifyCondition(OFFSET umbilicalSendCond)	RET	PrepareAsynchNotifyBuffer:;	AH checksum;	assume that ES=0;AsynchNotifyBuffer must be in low RAM since the umbilical send handler only sends from low RAMbwMinReply	EQU	3	XOR	AX, AX	MOV	ES, AX	MOV	CL, bwMinReply	MOV	BX, asynchNotifyBuffer	MOV	ES:[BX], CL	INC	BX	MOV	ES:[BX], CL	INC	BX	MOV	DX, DebugStatus	MOV	ES:WORD PTR [BX], DX ;insert status word	MOV	BX, asynchNotifyBuffer	XOR	AH, AH	; clear checksum	ADD	CL, 1 	;include  2 count bytes - checksum byte	XOR	CH, CH	;clear high byte of loop counterchecksumLoop:	ADD	AH, ES:[BX]	;add buffer byte to checksum	INC	BX		;increment bindweed buffer index	LOOP	checksumLoop	MOV	AL, 0	SUB	AL, AH	MOV	ES:[BX], AL 	;insert checksum				;buffer is now ready to send	RET		IOPEInROM ENDS 	END	
-- Copyright (C) 1985  by Xerox Corporation. All rights reserved. -- Last edit by JAC	 7-Jun-85 11:46:41	CPCommand became CPCommands-- CPLoader.mesa, JoM    , 6-Feb-85 15:51:33DIRECTORY  Environment USING [bytesPerWord, LongNumber, wordsPerPage],  Format USING [CR, Line, LongDecimal, StringProc, Text],  Heap USING [systemZone],  MStream USING [Error, ReadOnly],  Stream USING [Delete, EndOfStream, GetBlock, GetWord, Handle],  String USING [AppendExtensionIfNeeded, CopyToNewString],  System USING [GetClockPulses, Pulses, PulsesToMicroseconds],  CP USING [Bank, Cycle, RealCS, sizeOfCS, wordsPerBank],  CPMI USING [MI],  CPCommands USING [Error, RefreshWindow],  CPKernel USING [    Error, OneMI, ReadBank,    WriteMemoryBlock, WriteNextMemoryBlock, WriteCSBlock],  CPKernelOps USING [WriteCSBlockInternal],  CPStop USING [SetContinueInfo],  CPSymbols USING [    AddCSSymbol, AddRHSymbol, AddRRegSymbol, AddToMap, AddURegSymbol,    Error, VirturalCS],  MassFileFormat USING [FinalBinaryRec, LabelSymbolRec];CPLoader: PROGRAM  IMPORTS    Format, Heap, MStream, Stream, String, System,    CPCommands, CPKernel, CPKernelOps, CPStop, CPSymbols  EXPORTS CPCommands, CPKernelOps =  BEGIN    z: UNCOUNTED ZONE = Heap.systemZone;  Load: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, file: LONG STRING, mapOnly: BOOLEAN] =    BEGIN    filename: LONG STRING;    stream: Stream.Handle;    filename _ String.CopyToNewString[file, z];    [] _ String.AppendExtensionIfNeeded[@filename, "fb"L, z];    Format.Text[log, "Loading CP from "L, arg];    Format.Text[log, filename, arg];    Format.Line[log, "."L, arg];    stream _ MStream.ReadOnly[filename, [] ! MStream.Error =>      ERROR CPCommands.Error["Can't read that file"] ];    LoadFromStream[log, arg, stream, mapOnly !      UNWIND => BEGIN Stream.Delete[stream]; z.FREE[@filename]; END ];    Stream.Delete[stream];    z.FREE[@filename];    CPCommands.RefreshWindow[];    END;  LoadFromStream: PROCEDURE [log: Format.StringProc, arg: LONG POINTER, stream: Stream.Handle, mapOnly: BOOLEAN] =    BEGIN ENABLE      BEGIN      Stream.EndOfStream => ERROR CPCommands.Error["Truncated fb file"L];      CPKernel.Error => ERROR CPCommands.Error[reason];      END;    start, stop: System.Pulses;    ms: LONG CARDINAL;    instructions: CARDINAL _ 0;    fbrBytes: CARDINAL = Environment.bytesPerWord*SIZE[MassFileFormat.FinalBinaryRec];    b: POINTER = @fbr;    fbr: MassFileFormat.FinalBinaryRec _ TRASH;    pb: POINTER TO CPMI.MI = LOOPHOLE[@fbr.partialBinary];    maxMiInClump: CARDINAL = 20;    miInClump: CARDINAL _ 0;    clump: ARRAY [0..maxMiInClump) OF CPKernel.OneMI;    offset: CARDINAL = CPKernel.ReadBank[] * CP.wordsPerBank;  -- ***  Hack until Mass is smarter    start _ System.GetClockPulses[];    DO      bytes: CARDINAL;      cycle: CP.Cycle;      [bytes, , ] _ Stream.GetBlock[          sH: stream,          block: [            blockPointer: b,	    startIndex: 0,            stopIndexPlusOne: fbrBytes]];      IF bytes # fbrBytes THEN ERROR CPCommands.Error["Truncated fb"];      IF fbr.addr >= CP.sizeOfCS THEN EXIT;      fbr.addr _ fbr.addr + offset;      cycle _ SELECT fbr.partialBinary.cycle FROM	    0 => any,            1 => c1,            2 => c2,            3 => c3,	    ENDCASE => ERROR;      IF fbr.miNum = 0FFFFH THEN        BEGIN        CPStop.SetContinueInfo[fbr.addr, (IF cycle = any THEN c1 ELSE cycle)];	END ELSE	BEGIN	IF offset # 0 AND fbr.partialBinary.task # 0 THEN	  CPCommands.Error["IO microcode won't run in extra Banks"];	IF miInClump = maxMiInClump THEN	  BEGIN          IF ~mapOnly THEN CPKernel.WriteCSBlock[miInClump, @clump];	  miInClump _ 0;	  END;	clump[miInClump] _ [fbr.addr, pb^];	miInClump _ miInClump + 1;	instructions _ instructions + 1;        IF TRUE THEN	  BEGIN	  fbr.miNum _ fbr.miNum + offset;	  CPSymbols.AddToMap[fbr.addr, fbr.miNum, cycle];	  END;        END      ENDLOOP;    IF ~mapOnly AND miInClump # 0 THEN CPKernel.WriteCSBlock[miInClump, @clump];    stop _ System.GetClockPulses[];    ms _ System.PulsesToMicroseconds[[stop - start]]/1000;    Info[log, arg, ms, instructions];    END;      LoadFromMemory: PUBLIC PROCEDURE [fbFile: LONG POINTER, bank: CP.Bank] =    BEGIN    fbr: LONG POINTER TO MassFileFormat.FinalBinaryRec _ fbFile;    maxMiInClump: CARDINAL = 20;    miInClump: CARDINAL _ 0;    clump: ARRAY [0..maxMiInClump) OF CPKernel.OneMI;    offset: CARDINAL = bank * CP.wordsPerBank;  -- ***  Hack until Mass is smarter    DO      IF fbr.addr >= CP.sizeOfCS THEN EXIT;      -- (WriteProtected) fbr.addr _ fbr.addr + offset;      IF fbr.miNum = 0FFFFH THEN        BEGIN        cycle: CP.Cycle _ SELECT fbr.partialBinary.cycle FROM	    0, 1 => c1,            2 => c2,            3 => c3,	    ENDCASE => ERROR;        CPStop.SetContinueInfo[fbr.addr + offset, cycle];	END ELSE	BEGIN        pb: LONG POINTER TO CPMI.MI = LOOPHOLE[@fbr.partialBinary];	IF miInClump = maxMiInClump THEN	  BEGIN          CPKernelOps.WriteCSBlockInternal[miInClump, @clump[0]];	  miInClump _ 0;	  END;	clump[miInClump] _ [fbr.addr + offset, pb^];	miInClump _ miInClump + 1;        END;      fbr _ fbr + SIZE[MassFileFormat.FinalBinaryRec];      ENDLOOP;    IF miInClump # 0 THEN CPKernelOps.WriteCSBlockInternal[miInClump, @clump[0]];    END;      LoadOverlay: PUBLIC PROCEDURE [fbFile: LONG POINTER] =    BEGIN ENABLE      BEGIN      CPKernel.Error => ERROR CPCommands.Error[reason];      END;    fbr: LONG POINTER TO MassFileFormat.FinalBinaryRec _ fbFile;    maxMiInClump: CARDINAL = 20;    miInClump: CARDINAL _ 0;    clump: ARRAY [0..maxMiInClump) OF CPKernel.OneMI;    DO      IF fbr.addr >= CP.sizeOfCS THEN EXIT;      IF fbr.miNum = 0FFFFH THEN  ERROR CPKernel.Error["Can't set TPC in Overlay"L]      ELSE        BEGIN        pb: LONG POINTER TO CPMI.MI = LOOPHOLE[@fbr.partialBinary];	IF miInClump = maxMiInClump THEN CPKernel.Error["Overlay too big"L];      	clump[miInClump] _ [fbr.addr, pb^];	miInClump _ miInClump + 1;        END;      fbr _ fbr + SIZE[MassFileFormat.FinalBinaryRec];      ENDLOOP;    IF miInClump # 0 THEN CPKernelOps.WriteCSBlockInternal[miInClump, @clump[0]];    END;      Info: PROCEDURE [log: Format.StringProc, arg: LONG POINTER, ms, instructions: LONG CARDINAL] =    BEGIN    Format.Text[log, "It took "L, arg];    Format.LongDecimal[log, ms, arg];    Format.Text[log, " ms to load "L, arg];    Format.LongDecimal[log, instructions, arg];    Format.Text[log, " instructions."L, arg];    IF ms # 0 THEN      BEGIN      Format.Text[log, " ("L, arg];      Format.LongDecimal[log, instructions*16*SIZE[CPMI.MI]*1000/ms, arg];      Format.Text[log, " bits/sec)"L, arg];      END;    Format.CR[log, arg];    END;   LoadSymbols: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, file: LONG STRING] =    BEGIN    filename: LONG STRING;    stream: Stream.Handle;    filename _ String.CopyToNewString[file, z];    [] _ String.AppendExtensionIfNeeded[@filename, "st"L, z];    Format.Text[log, "Loading CP symbols from "L, arg];    Format.Text[log, filename, arg];    Format.Line[log, "."L, arg];    stream _ MStream.ReadOnly[filename, [] ! MStream.Error =>      ERROR CPCommands.Error["Can't read that file"] ];    LoadSymbolsFromStream[log, arg, stream !      UNWIND => BEGIN Stream.Delete[stream]; z.FREE[@filename]; END ];    Stream.Delete[stream];    z.FREE[@filename];    END;      LoadSymbolsFromStream: PROCEDURE [log: Format.StringProc, arg: LONG POINTER, stream: Stream.Handle] =    BEGIN    start, stop: System.Pulses;    ms: LONG CARDINAL;    tags, rReg, rH, uReg: CARDINAL _ 0;    lsr: MassFileFormat.LabelSymbolRec _ TRASH;    bytesPerRec: CARDINAL = Environment.bytesPerWord*SIZE[MassFileFormat.LabelSymbolRec];    sym: LONG STRING = [100];    offset: CARDINAL = CPKernel.ReadBank[] * CP.wordsPerBank;  -- ***  Hack until Mass is smarter    start _ System.GetClockPulses[];    DO      bytes, wordsExpected: CARDINAL;      [bytes, , ] _ Stream.GetBlock[        sH: stream,        block: [          blockPointer: LOOPHOLE[LONG[@lsr]],	  startIndex: 0,          stopIndexPlusOne: bytesPerRec]];      IF bytes = 0 THEN EXIT;      IF bytes # bytesPerRec THEN ERROR CPCommands.Error["Symbol file truncated"L];      IF lsr.length = 0 THEN ERROR CPCommands.Error["Zero length tag"L];      IF lsr.length > sym.maxlength THEN ERROR CPCommands.Error["Huge label string"L];      wordsExpected _ (lsr.length + (Environment.bytesPerWord - 1))/Environment.bytesPerWord;      [bytes, , ] _  Stream.GetBlock[        sH: stream,        block: [          blockPointer: LOOPHOLE[@sym.text],	  startIndex: 0,          stopIndexPlusOne: Environment.bytesPerWord*wordsExpected]];      sym.length _ lsr.length;      BEGIN ENABLE CPSymbols.Error =>        BEGIN	Format.Text[log, "Troubles adding "L, arg];	Format.Text[log, sym, arg];	Format.Text[log, " to symbol table: "L, arg];	Format.Text[log, reason, arg];	Format.CR[log, arg];	CONTINUE;	END;      WITH lsr SELECT FROM        label =>	  BEGIN	  virt: CPSymbols.VirturalCS;	  IF miIndex >= 4096 THEN ERROR;	  virt _ miIndex + offset;	  CPSymbols.AddCSSymbol[sym, virt];	  tags _ tags + 1;	  END;        regR =>	  BEGIN	  CPSymbols.AddRRegSymbol[sym, addr];	  rReg _ rReg + 1;	  END;        regRH =>	  BEGIN	  CPSymbols.AddRHSymbol[sym, addr];	  rH _ rH + 1;	  END;        regU =>	  BEGIN	  CPSymbols.AddURegSymbol[sym, addr];	  uReg _ uReg + 1;	  END;        ENDCASE => ERROR CPSymbols.Error["Unrecognized type in symbol record"L];       END;      ENDLOOP;    stop _ System.GetClockPulses[];    ms _ System.PulsesToMicroseconds[[stop - start]]/1000;    InfoSymbols[log, arg, ms, tags, rReg, rH, uReg];    END;    InfoSymbols: PROCEDURE [    log: Format.StringProc, arg: LONG POINTER, ms: LONG CARDINAL, tags, rReg, rH, uReg: CARDINAL] =    BEGIN    Format.Text[log, "It took "L, arg];    Format.LongDecimal[log, ms, arg];    Format.Text[log, " ms to load "L, arg];    Format.LongDecimal[log, tags, arg];    Format.Text[log, " tags, "L, arg];    Format.LongDecimal[log, rReg, arg];    Format.Text[log, " R, "L, arg];    Format.LongDecimal[log, rH, arg];    Format.Text[log, " RH, and "L, arg];    Format.LongDecimal[log, uReg, arg];    Format.Line[log, " U Reg symbols."L, arg];    END;  LoadReal: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, file: LONG STRING] =    BEGIN    filename: LONG STRING;    stream: Stream.Handle;    filename _ String.CopyToNewString[file, z];    [] _ String.AppendExtensionIfNeeded[@filename, "cpr"L, z];    Format.Text[log, "Loading real memory from "L, arg];    Format.Text[log, filename, arg];    Format.Line[log, "."L, arg];    stream _ MStream.ReadOnly[filename, [] ! MStream.Error =>      ERROR CPCommands.Error["Can't read that file"] ];    LoadRealFromStream[log, arg, stream !      UNWIND => BEGIN Stream.Delete[stream]; z.FREE[@filename]; END ];    Stream.Delete[stream];    z.FREE[@filename];    CPCommands.RefreshWindow[];    END;  LoadRealFromStream: PROCEDURE [log: Format.StringProc, arg: LONG POINTER, stream: Stream.Handle] =    BEGIN ENABLE      Stream.EndOfStream => ERROR CPCommands.Error["Truncated cpr file"L];    buffer: ARRAY [0..Environment.wordsPerPage) OF WORD;    start, stop: System.Pulses;    ms: LONG CARDINAL;    wordsStored, blocks: LONG CARDINAL _ 0;    start _ System.GetClockPulses[];    DO      words, bytes: CARDINAL _ 0;      where: Environment.LongNumber;      words _ Stream.GetWord[stream];      IF words = 0 THEN EXIT;      IF words > Environment.wordsPerPage THEN        ERROR CPCommands.Error["CPR Block larger than a page"L];      where.highbits _ Stream.GetWord[stream];      where.lowbits _ Stream.GetWord[stream];      [bytes, , ] _ Stream.GetBlock[        sH: stream,        block: [	  blockPointer: LOOPHOLE[LONG[@buffer]],	  startIndex: 0,          stopIndexPlusOne: Environment.bytesPerWord*words]];      IF bytes # Environment.bytesPerWord * words THEN ERROR CPCommands.Error["Truncated CPR"L];      IF blocks = 0 THEN        BEGIN        CPKernel.WriteMemoryBlock[where.lp, words, @buffer          ! CPKernel.Error => ERROR CPCommands.Error[reason] ];        END      ELSE        CPKernel.WriteNextMemoryBlock[where.lp, words, @buffer          ! CPKernel.Error => ERROR CPCommands.Error[reason] ];      blocks _ blocks + 1;      wordsStored _ wordsStored + words;      ENDLOOP;    stop _ System.GetClockPulses[];    ms _ System.PulsesToMicroseconds[[stop - start]]/1000;    InfoReal[log, arg, ms, wordsStored, blocks];    END;	  InfoReal: PROCEDURE [log: Format.StringProc, arg: LONG POINTER, ms, words, blocks: LONG CARDINAL] =    BEGIN    Format.Text[log, "It took "L, arg];    Format.LongDecimal[log, ms, arg];    Format.Text[log, " ms to load "L, arg];    Format.LongDecimal[log, words, arg];    Format.Text[log, " words in "L, arg];    Format.LongDecimal[log, blocks, arg];    Format.Text[log, " blocks."L, arg];    IF ms # 0 THEN      BEGIN      Format.Text[log, " ("L, arg];      Format.LongDecimal[log, words*16*1000/ms, arg];      Format.Text[log, " bits/sec)"L, arg];      END;    Format.CR[log, arg];    END;  END.
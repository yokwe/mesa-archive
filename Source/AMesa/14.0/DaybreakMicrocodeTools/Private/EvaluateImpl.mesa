-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved. -- Last edit by JAC   	      25-Apr-85 10:55:33-- EvaluateImpl.mesa, AYC   ,  9-Aug-84 14:00:39-- from Evaluater.mesa,  HGM, 10-Feb-83 20:19:28--DIRECTORY  Ascii USING [SP],  Heap USING [systemZone],  String USING [AppendSubString, SubString, SubStringDescriptor],    Evaluate USING [LookupProcType, Type, unspecified, Value],  StringExtras USING [NextToken, TrimSubString];EvaluateImpl: PROGRAM  IMPORTS Heap, String, StringExtras  EXPORTS Evaluate =  BEGIN    z: UNCOUNTED ZONE = Heap.systemZone;  Error: PUBLIC ERROR [reason: LONG STRING] = CODE;    Type: TYPE = Evaluate.Type;  Value: TYPE = Evaluate.Value;  OperatorDomain: TYPE = {    plus, minus, space, star, slash, backSlash, open, close};  OperatorProc: TYPE = PROCEDURE [a, b: Value] RETURNS [Value];  Operator: PROCEDURE [c: CHARACTER] RETURNS [op: OperatorDomain] =    BEGIN    op ¬      SELECT c FROM        '+ => plus,        '- => minus,        Ascii.SP => space,        '* => star,        '/ => slash,        '\\ => backSlash,        '( => open,        ') => close,        ENDCASE => ERROR Error["Unrecognized operator"L];    END;  Tables: ARRAY OperatorDomain OF RECORD [    c: CHARACTER, precedence: CARDINAL, proc: OperatorProc] = [      plus: ['+, 1, Plus],      minus: ['-, 1, Minus],      space: [Ascii.SP, 1, Plus],      star: ['*, 2, Times],      slash: ['/, 2, Divide],      backSlash: ['\\, 2, Mod],      open: ['(, LAST[CARDINAL], IllegalOp],      close: ['), LAST[CARDINAL], IllegalOp]];  EvaluateString: PUBLIC PROCEDURE [s: LONG STRING, lookup: Evaluate.LookupProcType]    RETURNS [type: Type, value: Value] =    BEGIN    ss: String.SubStringDescriptor;    IF s = NIL THEN ERROR Error["NIL string"L];    ss ¬ [base: s, offset: 0, length: s.length];    IF StringExtras.TrimSubString[@ss] = 0 THEN ERROR Error["Empty string"L];    RETURN EvaluateSubString[@ss, lookup];    END;  EvaluateSubString: PUBLIC PROCEDURE [ss: String.SubString, lookup: Evaluate.LookupProcType]    RETURNS [type: Type, value: Value] =    BEGIN    token: String.SubString = @tssd;    tssd: String.SubStringDescriptor;    rest: String.SubString = @rssd;    rssd: String.SubStringDescriptor;    IF StringExtras.TrimSubString[ss] = 0 THEN ERROR Error["Empty string"L];    FOR i: CARDINAL IN [ss.offset..ss.offset + ss.length) DO      IF BreakCharacter[ss.base[i]] THEN        BEGIN        IF i = ss.offset THEN ERROR Error["Leading break character"L];        token­ ¬ [base: ss.base, offset: ss.offset, length: i - ss.offset];        rest­ ¬ [base: ss.base, offset: i, length: ss.length - token.length];	EXIT;	END;      REPEAT FINISHED => RETURN EvaluateToken[ss, lookup];      ENDLOOP;    [type, value] ¬ EvaluateToken[token, lookup];    DO      op: CHARACTER;      rightType: Type;      rightValue: Value;      NextToken[rest, token];  --operator--      op ¬ token.base[token.offset];      NextToken[rest, token];  --argument--      IF token.length = 0 THEN ERROR Error["Invalid string"L];      [rightType, rightValue] ¬ EvaluateToken[token, lookup];      type ¬ CombineTypes[type, rightType];      value ¬ Tables[Operator[op]].proc[value, rightValue];      IF rest.length = 0 THEN EXIT;      ENDLOOP;    END;  EvaluateToken: PUBLIC PROCEDURE [ss: String.SubString, lookup: Evaluate.LookupProcType]    RETURNS [type: Type, value: Value] =    BEGIN    s: LONG STRING ¬ z.NEW[StringBody[ss.length]];    String.AppendSubString[s, ss];    [type, value] ¬ lookup[s ! UNWIND => z.FREE[@s]];    z.FREE[@s];    RETURN[type, value]    END;      BreakCharacter: PROCEDURE [c: CHARACTER] RETURNS [BOOLEAN] =    BEGIN    SELECT c FROM      IN ['0..'9], IN ['A..'Z], IN ['a..'z], '., '@, '', '~, '(, '), ': => RETURN[FALSE];      ENDCASE => RETURN[TRUE];    END;  Plus: OperatorProc = BEGIN RETURN[a + b]; END;  Minus: OperatorProc = BEGIN RETURN[a - b]; END;  Times: OperatorProc = BEGIN RETURN[a*b]; END;  Divide: OperatorProc = BEGIN RETURN[a/b]; END;  Mod: OperatorProc = BEGIN RETURN[a MOD b]; END;  IllegalOp: OperatorProc = BEGIN ERROR Error["Illegal Operator"L]; END;  Precedence: PROCEDURE [c: CHARACTER] RETURNS [prec: CARDINAL] =    BEGIN RETURN[Tables[Operator[c]].precedence]; END;  CombineTypes: PROCEDURE [left, right: Type] RETURNS [Type] =    BEGIN    IF left = right OR right = Evaluate.unspecified THEN RETURN[left];    IF left = Evaluate.unspecified THEN RETURN[right];    ERROR Error["Can't combine mixed types"L];    END;  NextToken: PROCEDURE [rest, token: String.SubString] =    BEGIN    StringExtras.NextToken[rest, token, BreakCharacter];    END;  END.  -- Log:-- JAC   	10-Jan-85 17:30:44	stk uses ( instead of [-- JAC   	13-Mar-85 13:57:27	added ': to list in BreakCharacter-- JAC   	25-Apr-85 10:55:48	added test in EvaluateSubString for 0 length substring
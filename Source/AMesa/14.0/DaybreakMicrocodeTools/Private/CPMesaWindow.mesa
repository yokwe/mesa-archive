-- Copyright (C) 1983, 1985  by Xerox Corporation. All rights reserved. -- Last edit by JAC	 7-Jun-85 12:26:52	copyrighted-- CPMesaWindow.mesa, JGS, 12-Feb-85 12:20:36-- Please don't forget to update the herald...DIRECTORY  Environment USING [Long],  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, CommandItem, GetTypeIn, newLine,    NumberItem, ProcType, StringItem],  Heap USING [systemZone],  Inline USING [BITAND, HighByte, HighHalf, LowByte, LowHalf],  Put USING [Blank, CR, Line, LongNumber, Number, Text],  Selection USING [Convert, ConvertInsertion],  String USING [Empty, InvalidNumber],  TextSW USING [ForceOutput],  Tool USING [Create, MakeFormSW, MakeFileSW, MakeSWsProc, UnusedLogName],  ToolWindow USING [TransitionProcType],  UserInput USING [UserAbort],  Window USING [Handle],    CP USING [UReg],  CPKernel USING [Error, InKernel, ReadUReg, ReadVirturalMemory],  CPSymbols USING [Error, Eval, Symbol];CPMesaWindow: PROGRAM  IMPORTS    FormSW, Inline, Heap, Put, Selection, String, TextSW, Tool, UserInput,    CPKernel, CPSymbols =  BEGIN    z: UNCOUNTED ZONE = Heap.systemZone;    log, form: Window.Handle ¬ NIL;  localFrame: LONG STRING ¬ z.NEW[StringBody[20]];  address: LONG STRING ¬ z.NEW[StringBody[20]];  count: CARDINAL;   DispStack: FormSW.ProcType =    BEGIN ENABLE      BEGIN      CPKernel.Error =>        BEGIN        PostMessage["Oops, "L];        TailMessage[reason];        CONTINUE;        END;      CPSymbols.Error => CONTINUE;      END;    uMDS, uPSB, uGF: CP.UReg;    mds: WORD;    psb, gf, lf: ORDERED POINTER;    IF ~CPKernel.InKernel[] THEN      ERROR CPKernel.Error["Can't poke around while CP not in Kernel"L];    Put.CR[log];    Put.Text[log, "Display Stack: "L];    uMDS ¬ FindUReg["UvMDS"L];    uPSB ¬ FindUReg["uPSB"L];    uGF ¬ FindUReg["UvG"L];    mds ¬ ReadUReg[uMDS];    psb ¬ ReadUReg[uPSB];    gf ¬ ReadUReg[uGF];    IF UseDefaultFrame[@lf] THEN {      Put.Text[log, "MDS="L];      Put.Number[log, mds, [16,FALSE,TRUE,0]];      Put.Text[log, ", PSB="L];      Put.Number[log, psb, [16,FALSE,TRUE,0]];      Put.Text[log, ", GF="L];      Put.Number[log, gf, [16,FALSE,TRUE,0]];      Put.Text[log, ", LF="L];      Put.Number[log, lf, [16,FALSE,TRUE,0]]};    Put.CR[log];    Put.Line[log, "LF-4/  FSI  RET   GF   PC"L];    FOR i: CARDINAL IN [0..100) UNTIL UserInput.UserAbort[log] DO      IF lf = NIL OR Inline.BITAND[lf, 3] # 0 THEN EXIT;      Put.Number[log, lf-4, [16,FALSE,TRUE,4]];      Put.Text[log, "/"L];      FOR p: ORDERED POINTER ¬ lf - 4, p + 1 UNTIL p > lf + 3 DO        Put.Number[log, ReadMemory[p, mds], [16,FALSE,TRUE,5]];        ENDLOOP;      lf ¬ ReadMemory[lf-3, mds];      Put.CR[log];      ENDLOOP;    END;   UseDefaultFrame: PROC [    lf: POINTER TO ORDERED POINTER] RETURNS [BOOLEAN] = {    lf^ ¬ NIL;    IF Selection.ConvertInsertion[subwindow] = form AND      FormSW.GetTypeIn[form].index = 2 AND ~String.Empty[localFrame] THEN        lf^ ¬ StringToHex[localFrame ! String.InvalidNumber => CONTINUE]    ELSE {      s: LONG STRING _ Selection.Convert[string];      lf^ ¬ StringToHex[s ! String.InvalidNumber => CONTINUE];      z.FREE[@s]};    IF lf^ = NIL THEN {      uLF: CP.UReg ¬ FindUReg["UvL"L];      lf^ ¬ ReadUReg[uLF];      RETURN[TRUE]}    ELSE RETURN[FALSE]};      StringToHex: PROCEDURE [s: LONG STRING] RETURNS [v: UNSPECIFIED _ 0] =    BEGIN    char: CHARACTER;    cp: CARDINAL _ 0;    getchar: PROCEDURE =      BEGIN char _ IF cp >= s.length THEN 0C ELSE s[cp]; cp _ cp + 1; END;    IF s = NIL THEN String.InvalidNumber;    getchar[];    WHILE char <= '  DO      IF char = 0C THEN SIGNAL String.InvalidNumber; getchar[]; ENDLOOP;    DO      SELECT char FROM        IN ['0..'9] => v _ v*16 + (char - '0);	IN ['a..'f] => v _ v*16 + (char - 'a) + 10;	IN ['A..'F] => v _ v*16 + (char - 'A) + 10;	0C => EXIT;	ENDCASE => String.InvalidNumber;      getchar[];      ENDLOOP;    END;  LongStringToHex: PROCEDURE [s: LONG STRING] RETURNS [v: LONG UNSPECIFIED _ 0] =    BEGIN    char: CHARACTER;    cp: CARDINAL _ 0;    getchar: PROCEDURE =      BEGIN char _ IF cp >= s.length THEN 0C ELSE s[cp]; cp _ cp + 1; END;    IF s = NIL THEN String.InvalidNumber;    getchar[];    WHILE char <= '  DO      IF char = 0C THEN SIGNAL String.InvalidNumber; getchar[]; ENDLOOP;    DO      SELECT char FROM        IN ['0..'9] => v _ v*16 + (char - '0);	IN ['a..'f] => v _ v*16 + (char - 'a) + 10;	IN ['A..'F] => v _ v*16 + (char - 'A) + 10;	0C => EXIT;	ENDCASE => String.InvalidNumber;      getchar[];      ENDLOOP;    END;  ListProc: FormSW.ProcType =    BEGIN ENABLE      BEGIN      CPKernel.Error =>        BEGIN        PostMessage["Oops, "L];        TailMessage[reason];        CONTINUE;        END;      END;    uPTC: CP.UReg;    pdaMds: CARDINAL = 1;    firstProcess: CARDINAL = 10B;    pdaReady: POINTER = LOOPHOLE[0];    pdaCount: POINTER = LOOPHOLE[1];    stateVectors: POINTER = LOOPHOLE[8];    faultQueues: POINTER = LOOPHOLE[60B];    count: CARDINAL;    now: CARDINAL;    psb: ORDERED POINTER ¬ LOOPHOLE[firstProcess*8];    IF ~CPKernel.InKernel[] THEN      ERROR CPKernel.Error["Can't poke around while CP not in Kernel"L];    Put.CR[log];    Put.Text[log, "List Processes: "L];    uPTC ¬ FindUReg["uPTC"L];    now ¬ ReadUReg[uPTC];    count ¬ ReadMemory[pdaCount, pdaMds];    Put.Text[log, "uPTC="L];    Put.Number[log, now, [16,FALSE,TRUE,0]];    Put.Text[log, ", Count="L];    Put.Number[log, count, [16,FALSE,TRUE,0]];    Put.Text[log, ", Ready="L];    Put.Number[log, ReadMemory[pdaReady, pdaMds], [16,FALSE,TRUE,0]];    Put.CR[log];    Put.Text[log, "SV="L];    FOR i: CARDINAL IN [0..8) DO      Put.Number[log, ReadMemory[stateVectors+i, pdaMds], [16,FALSE,TRUE,5]];      ENDLOOP;    Put.CR[log];    Put.Text[log, "Fault="L];    FOR i: CARDINAL IN [0..16) DO      Put.Number[log, ReadMemory[faultQueues+i, pdaMds], [16,FALSE,TRUE,4]];      ENDLOOP;    Put.CR[log];    Put.Line[log, " PSB link flag CTX Time MDS"L];    FOR i: CARDINAL IN [0..count) UNTIL UserInput.UserAbort[log] DO      l, g, pc: POINTER;      link, flags, time, mds: WORD;      context: POINTER ¬ ReadMemory[psb+2, pdaMds];      IF context = NIL THEN BEGIN psb ¬ psb + 8; LOOP; END;      flags ¬ ReadMemory[psb+1, pdaMds];      IF Inline.BITAND[flags, 0C000H] # 0C000H THEN {psb ¬ psb + 8; LOOP};      Put.Number[log, psb, [16,FALSE,TRUE,4]];      link ¬ ReadMemory[psb+0, pdaMds];      flags ¬ ReadMemory[psb+1, pdaMds];      time ¬ ReadMemory[psb+3, pdaMds];      mds ¬ ReadMemory[psb+4, pdaMds];      Put.Number[log, link, [16,FALSE,TRUE,5]];      Put.Number[log, flags, [16,FALSE,TRUE,5]];      Put.Number[log, context, [16,FALSE,TRUE,5]];      IF time = 0 THEN Put.Text[log, "    "L]      ELSE Put.Number[log, time-now, [16,FALSE,TRUE,4]];      Put.Number[log, mds, [16,FALSE,TRUE,3]];      IF Inline.BITAND[link, 1] # 0 THEN l _ ReadMemory[context+15, pdaMds]      ELSE l _ context;      g _ ReadMemory[l-2, mds];      pc _ ReadMemory[l-1, mds];      Put.Text[log, "  L:"L];      Put.Number[log, l, [16,FALSE,TRUE,5]];      Put.Text[log, ", G:"L];      Put.Number[log, g, [16,FALSE,TRUE,5]];      Put.Text[log, ", PC:"L];      Put.Number[log, pc, [16,FALSE,TRUE,5]];      IF Inline.BITAND[link, 1] # 0 THEN        BEGIN  -- context is a state vector	insAndStackP: WORD = ReadMemory[context+14, pdaMds];	instByte: WORD = Inline.HighByte[insAndStackP];	stackP: WORD = Inline.LowByte[insAndStackP];	IF instByte # 0 THEN	  BEGIN          Put.Text[log, "  InstByte="L];          Put.Number[log, instByte, [16,FALSE,TRUE,0]];	  END;	IF stackP # 0 THEN	  BEGIN          Put.Text[log, ", StackP="L];          Put.Number[log, stackP, [16,FALSE,TRUE,0]];	  END;        Put.CR[log];        Put.Text[log, "      "L];	FOR i: CARDINAL IN [0..14) DO          Put.Number[log, ReadMemory[context+i, pdaMds], [16,FALSE,TRUE,5]];	  ENDLOOP;        Put.CR[log];        Put.Text[log, "      "L];	FOR i: CARDINAL IN [14..17) DO          Put.Number[log, ReadMemory[context+i, pdaMds], [16,FALSE,TRUE,5]];	  ENDLOOP;	END;      psb ¬ psb + 8;      Put.CR[log];      ENDLOOP;    END;  ReadProc: FormSW.ProcType =    BEGIN ENABLE      BEGIN      CPKernel.Error =>        BEGIN        PostMessage["Oops, "L];        TailMessage[reason];        CONTINUE;        END;      END;    lp: LONG POINTER _ NIL;    IF ~CPKernel.InKernel[] THEN      ERROR CPKernel.Error["Can't poke around while CP not in Kernel"L];    lp _ LongStringToHex[address ! String.InvalidNumber => CONTINUE];    IF lp = NIL THEN RETURN;    Put.CR[log];    Put.Text[log, "Read at "L];    Put.Text[log, address];    Put.Text[log, " for "L];    Put.Number[log, count, [10,FALSE,TRUE,0]];    Put.CR[log];    FOR i: CARDINAL IN [0..count) UNTIL UserInput.UserAbort[log] DO      val: WORD = ReadMemory[Inline.LowHalf[lp], Inline.HighHalf[lp]];      IF i MOD 8 = 0 THEN {        Put.LongNumber[log, lp, [16,FALSE,TRUE,8]];	Put.Text[log, "/ "L]};      Put.Number[log, val, [16,FALSE,TRUE,5]];      IF i MOD 8 = 7 THEN Put.CR[log] ELSE Put.Blank[log];      lp _ lp+1;      ENDLOOP;    Put.CR[log];    END;   FindUReg: PROCEDURE [s: LONG STRING] RETURNS [u: CP.UReg] =    BEGIN    value: CPSymbols.Symbol;    value ¬ CPSymbols.Eval[s !      CPSymbols.Error =>        BEGIN        PostMessage["Can't find "L];        PostMessage[s];        PostMessage[" in symbol table: "L];        TailMessage[reason];	-- Let Error go up the stack        END];    WITH value SELECT FROM      uReg => RETURN[u];      ENDCASE =>        BEGIN        PostMessage[s];        PostMessage[" isn't a U Register"L];	ERROR CPSymbols.Error[NIL];	END;    END;  ReadUReg: PROCEDURE [u: CP.UReg] RETURNS [UNSPECIFIED] =    BEGIN    RETURN[CPKernel.ReadUReg[u]];    END;    ReadMemory: PROCEDURE [where: POINTER, mds: CARDINAL] RETURNS [UNSPECIFIED] =    BEGIN    long: Environment.Long ¬ [any[low: where, high: mds]];    RETURN[CPKernel.ReadVirturalMemory[long.lp]];    END;  PostMessage: PROCEDURE [s: LONG STRING] =    BEGIN    Put.CR[log];    Put.Text[log, s];    TextSW.ForceOutput[log]    END;  AppendMessage: PROCEDURE [s: LONG STRING] =    BEGIN    Put.Text[log, s];    TextSW.ForceOutput[log]    END;  TailMessage: PROCEDURE [s: LONG STRING] =    BEGIN    Put.Text[log, s];    Put.Line[log, "."L];    TextSW.ForceOutput[log]    END;    Initialize: PROCEDURE =    BEGIN    herald: STRING = "CP Mesa of  7-Jun-85 12:32:53"L;    [] ¬ Tool.Create[      name: herald,      cmSection: "CP Mesa"L,      makeSWsProc: MakeSWs,      clientTransition: ClientTransition];    END;    MakeSWs: Tool.MakeSWsProc =    BEGIN    logFileName: STRING = [40];    Tool.UnusedLogName[logFileName, "CPMesa.log$"L];    form ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    log ¬ Tool.MakeFileSW[window: window, name: logFileName, h: 100];    END;    MakeForm: FormSW.ClientItemsProcType =    BEGIN    nParams: CARDINAL = 6;    items ¬ FormSW.AllocateItemDescriptor[nParams];    items[0] ¬ FormSW.CommandItem[      tag: "ListProc"L, proc: ListProc, place: FormSW.newLine];    items[1] ¬ FormSW.CommandItem[tag: "DispStack"L, proc: DispStack];    items[2] ¬ FormSW.StringItem[      tag: "Local Frame"L, inHeap: FALSE, string: @localFrame];    items[3] ¬ FormSW.CommandItem[      tag: "Read"L, proc: ReadProc, place: FormSW.newLine];    items[4] ¬ FormSW.StringItem[      tag: "Address"L, inHeap: TRUE, string: @address, boxWidth: 100];    items[5] ¬ FormSW.NumberItem[      tag: "Count"L, value: @count, notNegative: TRUE];    RETURN[items, TRUE];    END;       ClientTransition: ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      old = inactive =>        BEGIN        END;      new = inactive =>        BEGIN        END;      ENDCASE;    END;	  Initialize[];  END.
-- Copyright (C) 1985  by Xerox Corporation. All rights reserved. -- Last edit by JAC	 7-Jun-85 11:58:32	CPPanel became CPPanelSW-- Last edit by JAC	 7-Jun-85 11:48:45	CPCommand became CPCommands-- CPWindower.mesa, JoM    , 6-Feb-85 15:54:00DIRECTORY  Format USING [StringProc],  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, CommandItem,    DisplayItem, Enumerated, EnumeratedItem, newLine, ProcType,    StringItem, ToggleVisibility],  Heap USING [systemZone],  Process USING [Detach, MsecToTicks, Pause],  Put USING [CR, Date, Decimal, Line, Text],  Runtime USING [GetBcdTime],  Selection USING [Convert],  String USING [    AppendLongDecimal, AppendLongNumber, AppendString,    AppendStringAndGrow, CopyToNewString, Empty],  System USING [GetGreenwichMeanTime],  TextSW USING [ForceOutput],  Time USING [Append, Unpack],  Tool USING [Create, MakeFormSW, MakeFileSW, MakeSWsProc, UnusedLogName],  ToolWindow USING [TransitionProcType],  UserInput USING [    CancelPeriodicNotify, CreatePeriodicNotify, PeriodicNotifyHandle, PeriodicProcType,    UserAbort],  Version USING [Append],  Window USING [Handle],    BurdockControl USING [RegisterBurdockWindow],  CommandFile USING [CommandsFromFile, Error, SomebodyRunning],  CP USING [Cycle, RealCS],  CPBreak USING [ClearAllBreaks, EnumerateBreaks, Error, RemoveBreaks],  CPCommands USING [    Boot, Break, Error, Compare, Continue, CrossJump, Load, LoadBootFile, LoadGerm,    LoadRaw, LoadReal, LoadSymbols, PrintState, Reset, Start, Stop, Unbreak],  CPKernel USING [    Error, GetBootSeq, GetState, GetStateSeq,    InKernel, ProbeForStateChange, State],  CPPanelSW USING [Destroy, MakePanelSW, Refresh],  CPSymbols USING [    AppendAllRH, AppendAllRReg, AppendAllUReg, AppendNumber, AppendAllVirturalCS,    AppendIOIn, AppendIOOut, AppendLink, AppendMap, AppendOther,    AppendReal, AppendRealCS, AppendVirtural, AppendVirturalCS,    Error, Eval, nullRealCS, nullVirturalCS,    RealToVirturalCS, Symbol, VirturalCS, VirturalToRealCS];CPWindower: PROGRAM  IMPORTS    FormSW, Heap, Process, Put, Runtime, Selection, String, System,    TextSW, Time, Tool, UserInput, Version,    BurdockControl, CommandFile, CPBreak, CPCommands, CPKernel, CPPanelSW, CPSymbols  EXPORTS CPCommands =  BEGIN    z: UNCOUNTED ZONE = Heap.systemZone;    typeIn, run: LONG STRING _ NIL;  log, form, panel: Window.Handle _ NIL;  state: CPKernel.State;  onOff: BOOLEAN _ TRUE;  seq, boot: CARDINAL;  refreshNeeded, flushDuplicates, flushStateChange: BOOLEAN _ FALSE;  notifier: UserInput.PeriodicNotifyHandle;  clumpSize: CARDINAL _ 10;  Boot: FormSW.ProcType =    BEGIN ENABLE CPCommands.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostDate[];    CPCommands.Boot[LogString, log];    END;  Load: FormSW.ProcType =    BEGIN ENABLE CPCommands.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    filename: LONG STRING _ Selection.Convert[string];    PostDate[];    BEGIN ENABLE UNWIND => z.FREE[@filename];    CPCommands.Reset[LogString, log];    CPCommands.Load[LogString, log, filename];    CPCommands.LoadSymbols[LogString, log, filename];    z.FREE[@filename];    END;    END;  LoadMore: FormSW.ProcType =    BEGIN ENABLE CPCommands.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    filename: LONG STRING _ Selection.Convert[string];    PostDate[];    BEGIN ENABLE UNWIND => z.FREE[@filename];    CPCommands.Load[LogString, log, filename];    CPCommands.LoadSymbols[LogString, log, filename];    z.FREE[@filename];    END;    END;  Compare: FormSW.ProcType =    BEGIN ENABLE CPCommands.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    filename: LONG STRING _ Selection.Convert[string];    PostDate[];    BEGIN ENABLE UNWIND => z.FREE[@filename];    CPCommands.Compare[LogString, log, filename];    z.FREE[@filename];    END;    END;  CrossJump: FormSW.ProcType =    BEGIN ENABLE CPCommands.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    filename: LONG STRING _ Selection.Convert[string];    PostDate[];    BEGIN ENABLE UNWIND => z.FREE[@filename];    CPCommands.CrossJump[LogString, log, filename];    z.FREE[@filename];    END;    END;  Start: FormSW.ProcType =    BEGIN ENABLE CPCommands.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    pc: LONG STRING _ Selection.Convert[string];    BEGIN ENABLE UNWIND => z.FREE[@pc];    PostDate[];    CPCommands.Start[LogString, log, pc];    z.FREE[@pc];    END;    END;  Continue: FormSW.ProcType =    BEGIN ENABLE CPCommands.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostDate[];    CPCommands.Continue[LogString, log];    END;  Stop: FormSW.ProcType =    BEGIN ENABLE CPCommands.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostDate[];    CPCommands.Stop[LogString, log];    END;  Run: FormSW.ProcType =    BEGIN    filename: LONG STRING _ String.CopyToNewString[run, z];    IF String.Empty[filename] THEN filename _ Selection.Convert[string];    Put.CR[log];    flushStateChange _ TRUE;    FormSW.ToggleVisibility[form, runIx];    Process.Detach[FORK Runner[filename]];    -- Dally so Watcher can't sneak in and reset flushStateChange before     --  the process we just forked gets started.    FOR i: CARDINAL IN [0..10) DO      IF CommandFile.SomebodyRunning[] THEN EXIT;      Process.Pause[Process.MsecToTicks[100]];      ENDLOOP;    END;    Runner: PROCEDURE [filename: LONG STRING] =    BEGIN    BEGIN ENABLE CommandFile.Error =>      BEGIN      temp: STRING = [200];      String.AppendString[temp, "Error in command file at position "L];      String.AppendLongDecimal[temp, position];      String.AppendString[temp, ": "L];      String.AppendString[temp, reason];      TailMessage[temp];      CONTINUE;      END;    CommandFile.CommandsFromFile[LogString, log, Abort, filename];    END;    z.FREE[@filename];    FormSW.ToggleVisibility[form, runIx];    END;  LoadRaw: FormSW.ProcType =    BEGIN ENABLE CPCommands.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    filename: LONG STRING _ Selection.Convert[string];    PostDate[];    BEGIN ENABLE UNWIND => z.FREE[@filename];    CPCommands.LoadRaw[LogString, log, filename];    CPCommands.LoadSymbols[LogString, log, filename];    z.FREE[@filename];    END;    END;  LoadNoSyms: FormSW.ProcType =    BEGIN ENABLE CPCommands.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    filename: LONG STRING _ Selection.Convert[string];    PostDate[];    BEGIN ENABLE UNWIND => z.FREE[@filename];    CPCommands.Load[LogString, log, filename];    z.FREE[@filename];    END;    END;  LoadSymbols: FormSW.ProcType =    BEGIN ENABLE CPCommands.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    filename: LONG STRING _ Selection.Convert[string];    BEGIN ENABLE UNWIND => z.FREE[@filename];    CPCommands.Load[LogString, log, filename, TRUE];    CPCommands.LoadSymbols[LogString, log, filename];    z.FREE[@filename];    END;    END;  LoadGerm: FormSW.ProcType =    BEGIN ENABLE CPCommands.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    filename: LONG STRING _ Selection.Convert[string];    PostDate[];    BEGIN ENABLE UNWIND => z.FREE[@filename];    CPCommands.LoadGerm[LogString, log, filename];    z.FREE[@filename];    END;    END;  LoadReal: FormSW.ProcType =    BEGIN ENABLE CPCommands.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    filename: LONG STRING _ Selection.Convert[string];    PostDate[];    BEGIN ENABLE UNWIND => z.FREE[@filename];    CPCommands.LoadReal[LogString, log, filename];    z.FREE[@filename];    END;    END;  LoadBoot: FormSW.ProcType =    BEGIN ENABLE CPCommands.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    filename: LONG STRING _ Selection.Convert[string];    PostDate[];    BEGIN ENABLE UNWIND => z.FREE[@filename];    CPCommands.LoadBootFile[LogString, log, filename, 0];    z.FREE[@filename];    END;    END;  Refresh: FormSW.ProcType =    BEGIN    refreshNeeded _ flushStateChange _ TRUE;    END;    What: FormSW.ProcType =    BEGIN ENABLE      CPSymbols.Error => BEGIN TailMessage[reason]; CONTINUE; END;    string: LONG STRING _ Selection.Convert[string];    temp: LONG STRING = [200];    value: CPSymbols.Symbol;    BEGIN ENABLE UNWIND => z.FREE[@string];    PostMessage["Decoding "L];    IF string = NIL THEN      BEGIN      TailMessage["  Selection required"L];      RETURN;      END;    TailMessage[string];    value _ CPSymbols.Eval[string];    WITH value SELECT FROM      number =>        BEGIN	String.AppendString[temp, "Number: "L];	AppendLotsOfModes[temp, n];	END;      link =>        BEGIN        CPSymbols.AppendLink[temp, link];	AppendLotsOfModes[temp, link];	END;      realCS =>        BEGIN	virt: CPSymbols.VirturalCS;	cycle: CP.Cycle;	String.AppendString[temp, "RealCS: "L];        CPSymbols.AppendRealCS[temp, real];	AppendLotsOfModes[temp, real];	[virt, cycle] _ CPSymbols.RealToVirturalCS[real];	IF virt # CPSymbols.nullVirturalCS THEN	  BEGIN	  String.AppendString[temp, ", (VirturalCS = .CV "L];          CPSymbols.AppendNumber[temp, virt];          String.AppendString[temp, " = "L];          CPSymbols.AppendVirturalCS[temp, virt];	  String.AppendString[temp, ", "L];          AppendCycle[temp, cycle];	  String.AppendString[temp, ")"L];	  END;	END;      virtCS =>        BEGIN	real: CP.RealCS;	cycle: CP.Cycle;	String.AppendString[temp, "VirturalCS: "L];	String.AppendString[temp, ".CV "L];	CPSymbols.AppendNumber[temp, virt];        String.AppendString[temp, " = "L];        CPSymbols.AppendAllVirturalCS[temp, virt];	AppendLotsOfModes[temp, virt];	[real, cycle] _ CPSymbols.VirturalToRealCS[virt];	IF real # CPSymbols.nullRealCS THEN	  BEGIN	  String.AppendString[temp, ", (RealCS = "L];          CPSymbols.AppendRealCS[temp, real];	  String.AppendString[temp, ", "L];          AppendCycle[temp, cycle];	  String.AppendString[temp, ")"L];	  END;	END;      rReg, rAndRh =>        BEGIN	IF value.type = rAndRh THEN	  String.AppendString[temp, "(R+RH mode)"L];	String.AppendString[temp, "RReg: "L];	String.AppendString[temp, ".R "L];	CPSymbols.AppendNumber[temp, r];        String.AppendString[temp, " = "L];        CPSymbols.AppendAllRReg[temp, r];	AppendLotsOfModes[temp, r];	END;      rH =>        BEGIN	String.AppendString[temp, "RH: "L];	String.AppendString[temp, ".RH "L];	CPSymbols.AppendNumber[temp, r];        String.AppendString[temp, " = "L];        CPSymbols.AppendAllRH[temp, r];	AppendLotsOfModes[temp, r];	END;      uReg =>        BEGIN	String.AppendString[temp, "UReg: "L];	String.AppendString[temp, ".U "L];	CPSymbols.AppendNumber[temp, u];        String.AppendString[temp, " = "L];        CPSymbols.AppendAllUReg[temp, u];	AppendLotsOfModes[temp, u];	END;      ioIn =>        BEGIN        CPSymbols.AppendIOIn[temp, io];	AppendLotsOfModes[temp, io];	END;      ioOut =>        BEGIN        CPSymbols.AppendIOOut[temp, io];	AppendLotsOfModes[temp, io];	END;      map =>        BEGIN        CPSymbols.AppendMap[temp, map];	AppendLotsOfModes[temp, map];	END;      real =>        BEGIN        CPSymbols.AppendReal[temp, real];	AppendLotsOfModes[temp, LOOPHOLE[real]];	END;      virt =>        BEGIN        CPSymbols.AppendVirtural[temp, virt];	AppendLotsOfModes[temp, LOOPHOLE[virt]];	END;      other =>        BEGIN        CPSymbols.AppendOther[temp, other];	END;      pc =>        BEGIN        String.AppendString[temp, ".PC (a Pseudo Register)"L];	END;      ENDCASE => ERROR;    TailMessage[temp];    z.FREE[@string];    END;    END;    AppendLotsOfModes: PROCEDURE [s: LONG STRING, d: LONG CARDINAL] =    BEGIN    String.AppendString[s, " = "L];    String.AppendLongNumber[s, d, 16];    String.AppendString[s, "'X = "L];    String.AppendLongNumber[s, d, 10];    String.AppendString[s, "'D = "L];    String.AppendLongNumber[s, d, 8];    String.AppendString[s, "'B"L];    END;    AppendCycle: PROCEDURE [s: LONG STRING, cycle: CP.Cycle] =    BEGIN    SELECT cycle FROM      c1 => String.AppendString[s, "c1"L];      c2 => String.AppendString[s, "c2"L];      c3 => String.AppendString[s, "c3"L];      any => String.AppendString[s, "c*"L];      ENDCASE => ERROR;    END;   Break: FormSW.ProcType =    BEGIN ENABLE CPCommands.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    where: LONG STRING _ Selection.Convert[string];    BEGIN ENABLE UNWIND => z.FREE[@where];    IF where = NIL THEN where _ String.CopyToNewString[typeIn, z];    IF where = NIL THEN      BEGIN      TailMessage["  Selection/Typein required"L];      RETURN;      END;    CPCommands.Break[LogString, log, where];    z.FREE[@where];    END;    END;   Unbreak: FormSW.ProcType =    BEGIN ENABLE CPCommands.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    where: LONG STRING _ Selection.Convert[string];    BEGIN ENABLE UNWIND => z.FREE[@where];    CPCommands.Unbreak[LogString, log, where];    z.FREE[@where];    END;    END;   ClearAllBreaks: FormSW.ProcType =    BEGIN ENABLE CPBreak.Error =>      BEGIN      PostMessage["Oops, "L];      TailMessage[reason];      CONTINUE;      END;    PostMessage["Clearing All CP Breaks "L];    AppendMessage[" ... "L];    CPBreak.ClearAllBreaks[];    TailMessage["ok"L];    END;  ListBreaks: FormSW.ProcType =    BEGIN ENABLE CPBreak.Error =>      BEGIN      PostMessage["Oops, "L];      TailMessage[reason];      CONTINUE;      END;    i: CARDINAL _ 0;    PrintOne: PROCEDURE [pc: CP.RealCS, cycle: CP.Cycle] =      BEGIN      temp: STRING = [200];      virt: CPSymbols.VirturalCS;      i _ i + 1;      Put.Text[log, "CP Break #"L];      Put.Decimal[log, i];      Put.Text[log, " is located at "L];      CPSymbols.AppendRealCS[temp, pc];      [virt, ] _ CPSymbols.RealToVirturalCS[pc];      IF virt # CPSymbols.nullVirturalCS THEN        BEGIN        String.AppendString[temp, ", (VirturalCS = "L];        CPSymbols.AppendVirturalCS[temp, virt];        String.AppendString[temp, ")"L];        END;      String.AppendString[temp, ", "L];      AppendCycle[temp, cycle];      Put.Line[log, temp];      END;    Put.CR[log];    Put.Line[log, "CP Breakpoints:"L];    CPBreak.EnumerateBreaks[PrintOne];    Put.Line[log, "Done"L];    END;   RefreshWindow: PUBLIC PROCEDURE =    BEGIN    seq _ CPKernel.GetStateSeq[];    boot _ CPKernel.GetBootSeq[];    state _ CPKernel.GetState[];    refreshNeeded _ TRUE;    END;      Watcher: UserInput.PeriodicProcType =    BEGIN    IF CommandFile.SomebodyRunning[] OR ~onOff THEN RETURN;    ProbeForStateChange[];    IF ~refreshNeeded AND seq = CPKernel.GetStateSeq[] AND boot = CPKernel.GetBootSeq[] THEN      BEGIN      refreshNeeded _ flushDuplicates _ flushStateChange _ FALSE;      RETURN;      END;    IF state # CPKernel.GetState[] THEN flushDuplicates _ FALSE;    seq _ CPKernel.GetStateSeq[];    boot _ CPKernel.GetBootSeq[];    state _ CPKernel.GetState[];    IF ~flushDuplicates THEN      BEGIN      PostDate[];      IF ~flushStateChange THEN AppendMessage["State changed: "L];      IF CPKernel.InKernel[] THEN RemoveBreaks[];      PrintState[];      END;    IF CPKernel.InKernel[] THEN BEGIN RemoveBreaks[]; CPPanelSW.Refresh[]; END;    FormSW.DisplayItem[form, stateIx];    refreshNeeded _ flushDuplicates _ flushStateChange _ FALSE;    END;      ProbeForStateChange: PROCEDURE =    BEGIN ENABLE CPKernel.Error =>      BEGIN      PostMessage["Humm, "L];      TailMessage[reason];      CONTINUE;      END;    CPKernel.ProbeForStateChange[];    END;      RemoveBreaks: PROCEDURE =    BEGIN ENABLE CPBreak.Error =>      BEGIN      PostMessage["Humm, "L];      TailMessage[reason];      CONTINUE;      END;    CPBreak.RemoveBreaks[];    END;      PrintState: PROCEDURE =    BEGIN ENABLE CPCommands.Error =>      BEGIN      PostMessage["Humm, "L];      TailMessage[reason];      CONTINUE;      END;    CPCommands.PrintState[LogString, log];    END;      PostDate: PROCEDURE =    BEGIN    Put.CR[log];    Put.Date[log, System.GetGreenwichMeanTime[], dateTime];    Put.Text[log, "  "L];    TextSW.ForceOutput[log];    flushDuplicates _ TRUE;    END;  PostMessage: PROCEDURE [s: LONG STRING] =    BEGIN    Put.CR[log];    Put.Text[log, s];    TextSW.ForceOutput[log];    END;  AppendMessage: PROCEDURE [s: LONG STRING] =    BEGIN    Put.Text[log, s];    TextSW.ForceOutput[log];    END;  TailMessage: PROCEDURE [s: LONG STRING] =    BEGIN    Put.Text[log, s];    Put.Line[log, "."L];    TextSW.ForceOutput[log];    END;    LogString: Format.StringProc =    BEGIN    Put.Text[clientData, s];    END;  Abort: PROCEDURE RETURNS [BOOLEAN] =    BEGIN    RETURN[UserInput.UserAbort[log]];    END;  Initialize: PROCEDURE =    BEGIN    herald: STRING = [100];    String.AppendString[herald, "CP Panel "L];    Version.Append[herald];    String.AppendString[herald, " of "L];    Time.Append[herald, Time.Unpack[Runtime.GetBcdTime[]]];    BurdockControl.RegisterBurdockWindow[Tool.Create[      name: herald,      cmSection: "CP Panel"L,      makeSWsProc: MakeSWs,      clientTransition: ClientTransition]];    END;    MakeSWs: Tool.MakeSWsProc =    BEGIN    logFileName: STRING = [40];    Tool.UnusedLogName[logFileName, "CP.log$"L];    log _ Tool.MakeFileSW[window: window, name: logFileName, h: 100];    form _ Tool.MakeFormSW[window: window, formProc: MakeForm];    panel _ CPPanelSW.MakePanelSW[window, log, ModifyTypeIn, @typeIn];    END;    stateChoices: ARRAY CPKernel.State OF FormSW.Enumerated _ [    dead: ["Dead", CPKernel.State[dead]],    halted: ["Halted", CPKernel.State[halted]],    running: ["Running", CPKernel.State[running]],    cpBreak: ["CPBreak", CPKernel.State[cpBreak]],    iopStopped: ["IOP Stopped", CPKernel.State[iopStopped]]];    runIx: CARDINAL = 6;  stateIx: CARDINAL = 15;  typeInIx: CARDINAL = 18;  MakeForm: FormSW.ClientItemsProcType =    BEGIN    nParams: CARDINAL = 25;    onOffChoices: ARRAY [0..2) OF FormSW.Enumerated _ [    ["on"L, BOOLEAN[TRUE] ],    ["off"L, BOOLEAN[FALSE] ] ];    items _ FormSW.AllocateItemDescriptor[nParams];    items[0] _ FormSW.CommandItem[tag: "Boot"L, proc: Boot, place: FormSW.newLine];    items[1] _ FormSW.CommandItem[tag: "Load"L, proc: Load];    items[2] _ FormSW.CommandItem[tag: "LoadMore"L, proc: LoadMore];    items[3] _ FormSW.CommandItem[tag: "Start"L, proc: Start];    items[4] _ FormSW.CommandItem[tag: "Continue"L, proc: Continue];    items[5] _ FormSW.CommandItem[tag: "Stop"L, proc: Stop];    items[runIx] _ FormSW.CommandItem[tag: "Run"L, proc: Run];    items[7] _ FormSW.StringItem[tag: "File"L, string: @run, inHeap: TRUE];    items[8] _ FormSW.CommandItem[tag: "LoadRaw"L, proc: LoadRaw, place: FormSW.newLine];    items[9] _ FormSW.CommandItem[tag: "LoadNoSyms"L, proc: LoadNoSyms];    items[10] _ FormSW.CommandItem[tag: "LoadSymbols"L, proc: LoadSymbols];    items[11] _ FormSW.CommandItem[tag: "LoadGerm"L, proc: LoadGerm];    items[12] _ FormSW.CommandItem[tag: "LoadReal"L, proc: LoadReal];    items[13] _ FormSW.CommandItem[tag: "LoadBoot"L, proc: LoadBoot];    items[14] _ FormSW.EnumeratedItem[      tag: ":"L, value: @onOff, feedback: all,      copyChoices: TRUE, choices: DESCRIPTOR[onOffChoices]];    items[stateIx] _ FormSW.EnumeratedItem[      tag: "State"L, value: @state, readOnly: TRUE, place: FormSW.newLine,      choices: LOOPHOLE[LONG[DESCRIPTOR[stateChoices]]]];    items[16] _ FormSW.CommandItem[tag: "Refresh"L, proc: Refresh];    items[17] _ FormSW.CommandItem[tag: "What"L, proc: What];    items[typeInIx] _ FormSW.StringItem[tag: "TypeIn"L, string: @typeIn, inHeap: TRUE];    items[19] _ FormSW.CommandItem[tag: "ListBreaks"L, proc: ListBreaks, place: FormSW.newLine];    items[20] _ FormSW.CommandItem[tag: "ClearAllBreaks"L, proc: ClearAllBreaks];    items[21] _ FormSW.CommandItem[tag: "Unbreak"L, proc: Unbreak];    items[22] _ FormSW.CommandItem[tag: "Break"L, proc: Break];    items[23] _ FormSW.CommandItem[tag: "Compare"L, proc: Compare];    items[24] _ FormSW.CommandItem[tag: "CrossJump"L, proc: CrossJump];    RETURN[items, TRUE];    END;       ModifyTypeIn: PROCEDURE [newTypeIn: LONG STRING, replace: BOOLEAN] =    BEGIN    IF newTypeIn = NIL OR replace THEN typeIn.length _ 0;    IF newTypeIn # NIL THEN String.AppendStringAndGrow[@typeIn, newTypeIn, z];    FormSW.DisplayItem[form, typeInIx];    END;        ClientTransition: ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      old = inactive =>        BEGIN	typeIn _ z.NEW[StringBody[20]];	run _ z.NEW[StringBody[20]];	state _ CPKernel.GetState[];	seq _ 0;	boot _ 0;	notifier _ UserInput.CreatePeriodicNotify[Watcher, window, Process.MsecToTicks[500]];        END;      new = inactive =>        BEGIN	notifier _ UserInput.CancelPeriodicNotify[notifier];	CPPanelSW.Destroy[];	z.FREE[@typeIn];	z.FREE[@run];        END;      ENDCASE;    END;	  Initialize[];  END.
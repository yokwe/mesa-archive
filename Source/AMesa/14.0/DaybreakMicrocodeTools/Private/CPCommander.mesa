-- Copyright (C) 1985  by Xerox Corporation. All rights reserved. -- Last edit by JAC 	 7-Jun-85 11:56:05	CPPanel became CPPanelSW-- Last edit by JAC 	 7-Jun-85 11:45:14	CPCommand became CPCommands-- CPCommander.mesa, JoM    , 6-Feb-85 15:34:54DIRECTORY  Format USING [Decimal, Line, Number, StringProc, Text],  Process USING [MsecToTicks, Pause],  String USING [AppendString, InvalidNumber, StringToNumber],  System USING [AdjustGreenwichMeanTime, GetGreenwichMeanTime, GreenwichMeanTime],    CommandFile USING [AbortProc],  CP USING [Bank, Cycle, RealCS],  CPMI USING [MI],  CPCommands USING [Load, RefreshWindow],  CPBreak USING [    Break, Error, GetLastBreakInfo, InstallBreaks, RemoveBreaks, Reset, Unbreak],  CPKernel USING [    AtBreak, Boot, Continue, ContinueAfterBreak, Error, FindBanks, GetBreakCycle,    GetState, LoadKernel, LoadKernelHigh, ProbeForStateChange,    Reset, Start, StartKernel, State, Stop, WriteBank],  CPPanelSW USING [Initialize],  CPStop USING [GetStopCS],  CPSymbols USING [    AppendRealCS, AppendVirturalCS, ClearSymbolTable, Error, GetPcAndCycle,    nullVirturalCS, RealToVirturalCS, VirturalCS],  IOPCommand USING [Boot, Continue, Error, Stop],  IOPKernel USING [GetState];CPCommander: PROGRAM  IMPORTS    Format, Process, String, System,    CPBreak, CPCommands, CPKernel, CPPanelSW, CPStop, CPSymbols, IOPCommand, IOPKernel  EXPORTS CPCommands =  BEGIN  Error: PUBLIC ERROR [reason: LONG STRING] = CODE;    Boot: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER] =    BEGIN ENABLE      BEGIN      CPBreak.Error => ERROR Error[reason];      CPKernel.Error => ERROR Error[reason];      END;    banks: CP.Bank;    IOPCommand.Boot[log, arg, TRUE ! IOPCommand.Error => ERROR Error[reason] ];    Format.Text[log, "Booting CP ... "L, arg];    CPSymbols.ClearSymbolTable[];    CPBreak.Reset[];    CPKernel.Boot[];    Format.Text[log, "Loading Kernel ... "L, arg];    CPKernel.LoadKernel[];    CPKernel.StartKernel[];    CPPanelSW.Initialize[];    banks _ CPKernel.FindBanks[];    IF banks # 1 THEN      BEGIN      Format.Line[log, "ok."L, arg];      Format.Text[log, "This machine has "L, arg];      Format.Decimal[log, banks, arg];      Format.Text[log, " banks of control store.  Loading extra Kernels ... "L, arg];      FOR bank: CP.Bank IN [1..banks) DO        CPKernel.LoadKernelHigh[bank];        ENDLOOP;      CPKernel.WriteBank[0];      END;    PrintState[log, arg];    END;  SetBank: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, s: LONG STRING] =    BEGIN ENABLE      BEGIN      CPKernel.Error => ERROR Error[reason];      String.InvalidNumber => ERROR Error["Can't parse bank string"L];      END;    bank: CP.Bank _ String.StringToNumber[s];    CPKernel.WriteBank[bank];    Format.Text[log, "Now using bank "L, arg];    Format.Decimal[log, bank, arg];    Format.Line[log, "."L, arg];    END;  LoadRaw: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, filename: LONG STRING] =    BEGIN ENABLE      BEGIN      CPBreak.Error => ERROR Error[reason];      CPKernel.Error => ERROR Error[reason];      END;    CPSymbols.ClearSymbolTable[];    CPBreak.Reset[];    IOPCommand.Boot[log, arg ! IOPCommand.Error => ERROR Error[reason] ];    CPKernel.Boot[];    CPCommands.Load[log, arg, filename];    CPKernel.StartKernel[];    CPPanelSW.Initialize[];    END;  Reset: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER] =    BEGIN ENABLE      BEGIN      CPBreak.Error => ERROR Error[reason];      CPKernel.Error => ERROR Error[reason];      END;    CPSymbols.ClearSymbolTable[];    CPBreak.Reset[];    CPKernel.Reset[];    CPPanelSW.Initialize[];    END;  Start: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, s: LONG STRING] =    BEGIN ENABLE CPKernel.Error => ERROR Error[reason];    pc: CP.RealCS;    cycle: CP.Cycle;    Format.Text[log, "Starting at "L, arg];    Format.Text[log, s, arg];    BeSureIOPHalted[log, arg];    CPBreak.RemoveBreaks[];    [pc, cycle] _ CPSymbols.GetPcAndCycle[s ! CPSymbols.Error => ERROR Error[reason] ];    Format.Text[log, ", .CR "L, arg];    Format.Number[log, pc, [16, FALSE, TRUE, 0], arg];    SELECT cycle FROM     c1 => Format.Text[log, ", c1"L, arg];     c2 => Format.Text[log, ", c2"L, arg];     c3 => Format.Text[log, ", c3"L, arg];     any => Format.Text[log, ", c*"L, arg];     ENDCASE => ERROR;    CPBreak.InstallBreaks[];    CPKernel.Start[pc, cycle];    Format.Line[log, "."L, arg];    END;     Continue: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, silent: BOOLEAN] =    BEGIN ENABLE      BEGIN      CPBreak.Error => ERROR Error[reason];      CPKernel.Error => ERROR Error[reason];      END;    Format.Text[log, "Continuing CP ... "L, arg];    CPKernel.ProbeForStateChange[];    BeSureIOPHalted[log, arg];    CPBreak.RemoveBreaks[];    IF CPKernel.AtBreak[] THEN      BEGIN      location: CP.RealCS;      cycle: CP.Cycle;      mi: CPMI.MI;      [location, cycle, mi] _ CPBreak.GetLastBreakInfo[];      Format.Text[log, "(from Break) "L, arg];      CPBreak.InstallBreaks[];      CPKernel.ContinueAfterBreak[mi, cycle];      END    ELSE      BEGIN      CPBreak.InstallBreaks[];      CPKernel.Continue[];      END;    IF IOPKernel.GetState[] # booted THEN      IOPCommand.Continue[log, arg, ~silent ! IOPCommand.Error => ERROR Error[reason] ];    -- Give easy breaks time to take => avoid double state change printout    Process.Pause[Process.MsecToTicks[250]];    IF ~silent THEN PrintState[log, arg];    CPCommands.RefreshWindow[];    END;    StartAndWait: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, s: LONG STRING, abort: CommandFile.AbortProc, ms: LONG CARDINAL] =    BEGIN ENABLE      BEGIN      CPBreak.Error => ERROR Error[reason];      CPKernel.Error => ERROR Error[reason];      END;    start: System.GreenwichMeanTime = System.GetGreenwichMeanTime[];    stop: System.GreenwichMeanTime = System.AdjustGreenwichMeanTime[start, (ms+999)/1000];    Start[log, arg, s];    DO      CPKernel.ProbeForStateChange[];      IF CPKernel.GetState[] # running THEN EXIT;      Process.Pause[Process.MsecToTicks[500]];      IF abort[] THEN ERROR Error["UserAborted (STOP)"L];      IF ms = 0 THEN LOOP;  -- Forever case      IF System.GetGreenwichMeanTime[] > stop THEN ERROR Error["Didn't stop in time"L];      ENDLOOP;    CPBreak.RemoveBreaks[];    PrintState[log, arg];    CPCommands.RefreshWindow[];    END;    ContinueAndWait: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, abort: CommandFile.AbortProc, ms: LONG CARDINAL] =    BEGIN ENABLE      BEGIN      CPBreak.Error => ERROR Error[reason];      CPKernel.Error => ERROR Error[reason];      END;    start: System.GreenwichMeanTime = System.GetGreenwichMeanTime[];    stop: System.GreenwichMeanTime = System.AdjustGreenwichMeanTime[start, (ms+999)/1000];    Continue[log, arg, FALSE];    DO      CPKernel.ProbeForStateChange[];      IF CPKernel.GetState[] # running THEN EXIT;      Process.Pause[Process.MsecToTicks[500]];      IF abort[] THEN ERROR Error["UserAborted (STOP)"L];      IF ms = 0 THEN LOOP;  -- Forever case      IF System.GetGreenwichMeanTime[] > stop THEN ERROR Error["Didn't stop in time"L];      ENDLOOP;    CPBreak.RemoveBreaks[];    PrintState[log, arg];    CPCommands.RefreshWindow[];    END;    Stop: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER] =    BEGIN ENABLE CPKernel.Error => ERROR Error[reason];    Format.Text[log, "Stopping CP ... "L, arg];    CPKernel.Stop[];    PrintState[log, arg];    CPCommands.RefreshWindow[];    END;    Break: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, s: LONG STRING] =    BEGIN    pc: CP.RealCS;    cycle: CP.Cycle;    Format.Text[log, "Setting CP Break at "L, arg];    Format.Text[log, s, arg];    Format.Text[log, " = "L, arg];    [pc, cycle] _ CPSymbols.GetPcAndCycle[s ! CPSymbols.Error => ERROR Error[reason] ];    Format.Text[log, ".CR "L, arg];    Format.Number[log, pc, [16, FALSE, TRUE, 0], arg];    CPBreak.Break[pc, cycle ! CPBreak.Error => ERROR Error[reason] ];    Format.Line[log, " ok."L, arg];    END;    Unbreak: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, s: LONG STRING] =    BEGIN    pc: CP.RealCS;    cycle: CP.Cycle;    Format.Text[log, "Clearing CP Break at "L, arg];    IF s # NIL THEN Format.Text[log, s, arg]    ELSE      BEGIN      Format.Text[log, "current break"L, arg];      IF ~CPKernel.AtBreak[] THEN ERROR Error["Not at Break"L];      END;    Format.Text[log, " = "L, arg];    IF s = NIL THEN      BEGIN      [pc, cycle, ] _ CPBreak.GetLastBreakInfo[];      END    ELSE [pc, cycle] _ CPSymbols.GetPcAndCycle[s ! CPSymbols.Error => ERROR Error[reason] ];    Format.Text[log, ".CR "L, arg];    Format.Number[log, pc, [16, FALSE, TRUE, 0], arg];    CPBreak.Unbreak[pc, cycle ! CPBreak.Error => ERROR Error[reason] ];    Format.Line[log, " ok."L, arg];    END;      PrintState: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER] =    BEGIN    state: CPKernel.State = CPKernel.GetState[];    SELECT state FROM      dead => Format.Text[log, "CP and/or IOP is dead"L, arg];      halted =>        BEGIN	temp: STRING = [200];	location: CP.RealCS;        cycle: CP.Cycle;	virt: CPSymbols.VirturalCS;        location _ CPStop.GetStopCS[];	cycle _ CPKernel.GetBreakCycle[];	[virt, ] _ CPSymbols.RealToVirturalCS[location];	Format.Text[log, "CP halted at "L, arg];        CPSymbols.AppendRealCS[temp, location];	IF virt # CPSymbols.nullVirturalCS THEN	  BEGIN	  String.AppendString[temp, ", ("L];          CPSymbols.AppendVirturalCS[temp, virt];	  String.AppendString[temp, ")"L];	  END;	String.AppendString[temp, ", "L];        AppendCycle[temp, cycle];	Format.Text[log, temp, arg];	END;      running => Format.Text[log, "CP is running"L, arg];      cpBreak =>        BEGIN	temp: STRING = [200];	location: CP.RealCS;        cycle: CP.Cycle;	virt: CPSymbols.VirturalCS;        CPBreak.RemoveBreaks[ ! CPBreak.Error => ERROR Error[reason] ];        [location, cycle, ] _ CPBreak.GetLastBreakInfo[];	[virt, ] _ CPSymbols.RealToVirturalCS[location];	Format.Text[log, "CP Break at "L, arg];        CPSymbols.AppendRealCS[temp, location];	IF virt # CPSymbols.nullVirturalCS THEN	  BEGIN	  String.AppendString[temp, ", ("L];          CPSymbols.AppendVirturalCS[temp, virt];	  String.AppendString[temp, ")"L];	  END;	String.AppendString[temp, ", "L];        AppendCycle[temp, cycle];	Format.Text[log, temp, arg];	END;      iopStopped => Format.Text[log, "IOP stopped"L, arg];      ENDCASE => ERROR;    Format.Line[log, "."L, arg];    END;      AppendCycle: PROCEDURE [s: LONG STRING, cycle: CP.Cycle] =    BEGIN    SELECT cycle FROM      c1 => String.AppendString[s, "c1"L];      c2 => String.AppendString[s, "c2"L];      c3 => String.AppendString[s, "c3"L];      any => String.AppendString[s, "c*"L];      ENDCASE => ERROR;    END;   BeSureIOPHalted: PROCEDURE [log: Format.StringProc, arg: LONG POINTER] =    BEGIN    SELECT IOPKernel.GetState[] FROM      dead => ERROR Error["IOP dead"L];      booted, halted, iopBreak, cpStop => RETURN;      running => IOPCommand.Stop[log, arg ! IOPCommand.Error => ERROR Error[reason] ];      ENDCASE => ERROR;    END;      END.
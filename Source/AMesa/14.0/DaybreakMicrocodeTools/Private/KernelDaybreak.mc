{<DawnWS>Microcode>Diags>KernelDayBreak.mc, JoM    , 29-Jan-85 10:08:55}	{Based on HGM's KernelDicentra of March 1983 and	HGM's KernelDLion of October 1982}Reserve[1, 0F6F];{------------------------------------------------------Overview:Locations Burdock knows about in the kernel rK, RHrK; U-registers: uKernMD, uBreakID, uIOPData, uKTemp; microinstructions:  KBuffer, KBufferExtension, KWait, KEntry, and the breakpoint ID's.The Kernel can be entered by one of two ways:  Either via a breakpoint or the IOP asynchronously interrupting the CP via the IOPWait line.  If entry is via a breakpoint, the kernel can be entered in any cycle (and inter-cycle state information must be preserved).  IOPWait caused entry always occurs between clicks (so all state information is already saved by the CP and there is no memory state across clicks which can be lost, saved or restored).Upon entering the kernel, it interrupts the IOP and waits for a command byte.  There are several possible commands that the IOP can specify.  Most of these commands read or write specific registers or memory, but ExecuteBuffer causes instructions which the IOP wrote in the buffer area to be executed.Currently, the kernel is written assuming it can always use rK, so this register is lost in breakpoint or IOPWait caused entries.  (rK is used in the wait loop and in the overlay code which Burdock uses to read and write some registers.)	 Register Usage:rK		Used as a temporary.RHrK		Used by burdock memory overlay code, and temporarily holds breakID for breakpoints.  Holds IOPStatus at KEntry.  Burdock should read value before overlay used.UKernMD		Holds click's captured memory data and used in memory write overlay (should be read by Burdock before the overlay is used).UBreakID	Temporarly holds breakpoint identification number.UKTemp		Temporary used in register write overlays.  (Same as UBreakID, i.e., UBreakID should be read by Burdock before it uses an overlay which uses UKTemp.)UKSaveDisp	Holds condition bits.------------------------------------------------------}{------------------------------------------------------	Breakpoint code------------------------------------------------------}{There is one entry point to the kernel corresponding to breakpoints set in any cycle.  The following code must be written into the control store in order to cause the respective breakpoint.There are currently 255 breakpoints available of any sort.  c2 & c3 breakpoints lose any pending memory data.  BreakID=255 is the mouse halt breakpoint.UBreakID MOD 256 is the "actual" Breakpoint identification; UBreakID / 256 is the cycle number of the breakpointed instruction (as detected by XC2npcDisp tests -- it may not agreee with the expected cycle number).}{Breakpoint:	RHrK ¬ BreakID, DISP4[KEntry],				c1;}{------------------------------------------------------	Kernel Entry------------------------------------------------------}{The 16 way branches at KEntry are necessary in order to preserve the branch conditions in UKSaveDisp, i.e. the entry point can not be "at[0F,10]" since this would cancel all pending branch conditions.  This table (IA.7=0) is also used by the Write Link overlay: location KE is overwritten and restored.  Burdock knows the address of KEntry & KE}{Breakpoint entry: at break cycle + 1}KEntry:	rK ¬ 0, GOTO[KE],					c*, at[KEntryLoc];	rK ¬ 1, GOTO[KE],					c*, at[1,10,KEntry];	rK ¬ 2, GOTO[KE],					c*, at[2,10,KEntry];	rK ¬ 3, GOTO[KE],					c*, at[3,10,KEntry];	rK ¬ 4, GOTO[KE],					c*, at[4,10,KEntry];	rK ¬ 5, GOTO[KE],					c*, at[5,10,KEntry];	rK ¬ 6, GOTO[KE],					c*, at[6,10,KEntry];	rK ¬ 7, GOTO[KE],					c*, at[7,10,KEntry];	rK ¬ 8, GOTO[KE],					c*, at[8,10,KEntry];	rK ¬ 9, GOTO[KE],					c*, at[9,10,KEntry];	rK ¬ 0A, GOTO[KE],					c*, at[0A,10,KEntry];	rK ¬ 0B, GOTO[KE],					c*, at[0B,10,KEntry];	rK ¬ 0C, GOTO[KE],					c*, at[0C,10,KEntry];	rK ¬ 0D, GOTO[KE],					c*, at[0D,10,KEntry];	rK ¬ 0E, GOTO[KE],					c*, at[0E,10,KEntry];	rK ¬ 0F, GOTO[KE],					c*, at[0F,10,KEntry];KE:	Noop,							c*, at[KELoc];{Kernel Breakpoint Entry:  Control comes here after computing branch conditions.  First count cycles: keep cycling until the cycle number is good.}KBEntry:	UKSaveDisp ¬ rK,					c*, at[KBELoc];	rK ¬ RHrK, XC2npcDisp,					c*;{If breakpoint occurred in cycle 1, the previous instruction will happen on c2 and the following branch will occur.}CountCycle:	rK ¬ rK + 0FF + 1, BRANCH[$,FoundBkptCycle,0D],		c*;{If breakpoint occurred in cycle 2, this instruction will happen on c2 the first time; otherwise, it will happen the second time through.}	XC2npcDisp, GOTO[CountCycle],				c*;FoundBkptCycle:	UBreakID ¬ rK,						c1;	DebA ¬ rK LRot0,					c2;{Kernel Wait Loop: wait for command.  So that the commands execute in the correct cycles, cycle synchronization must be checked on exit from the Wait loop.  The Kernel inner loop gets out of sync on DLions so some of this krockery may be historical.  The overlay code may also return to KWait out of sync.}KWait:	rK ¬ 1, CALL[GetIOPByte],				c*, at[KWaitLoc];	Xbus ¬ 0, XC2npcDisp,					c*, at[1,10,KWait];SyncCycle:	Xbus ¬ 0, XC2npcDisp, BRANCH[SyncCycle,FoundCmdCycle,1], c*;FoundCmdCycle:	CANCELBR[$,1],						c1;	Ybus ¬ rK and 7, YDisp,					c2;	DISP3[KTable],				      	 	c3;{Get IOP Byte subroutine: wait for IOP byte. The subroutine takes an integral number of clicks to complete and may be executed at any cycle.On entry, rK holds the return point dispatch code; on exit, rK contains the IOP byte.}GetIOPByte:	Xbus ¬ ExtStat, XLDisp,					c*, at[GetIOPByteLoc];	Ybus ¬ rK, YDisp, BRANCH[$,ByteReady,2],		c*;	CANCELBR[GetIOPByte, 0F],				c*;ByteReady:	rK ¬ DebB, DISP4[KWait],				c*;{Command Dispatch: Entries of the dispatch table are on the following pages at each command.  All but the low-order 3 bits are ignored.}{------------------------------------------------------	Command = 0, ReadU [one byte]------------------------------------------------------}{Data sent: (1) reg number, (2) byte flag;data returned: (1) appropriate byte of Ureg.byte flag 0 = high byte, 1 = low byte.}KReadU:	uKSaveQ ¬ Q,						c1, at[0,8,KTable];	rK ¬ 2, CALL[GetIOPByte],				c2;	Xbus ¬ rK LRot12, XDisp,				c3, at[2,10,KWait];	Ybus ¬ rK, AltUaddr, DISP4[KReadUxx],			c1;	Q ¬ uBlock0, GOTO[KReadUHighOrLow],			c2, at[0,10,KReadUxx];	Q ¬ uBlock1, GOTO[KReadUHighOrLow],			c2, at[1,10,KReadUxx];	Q ¬ uBlock2, GOTO[KReadUHighOrLow],			c2, at[2,10,KReadUxx];	Q ¬ uBlock3, GOTO[KReadUHighOrLow],			c2, at[3,10,KReadUxx];	Q ¬ uBlock4, GOTO[KReadUHighOrLow],			c2, at[4,10,KReadUxx];	Q ¬ uBlock5, GOTO[KReadUHighOrLow],			c2, at[5,10,KReadUxx];	Q ¬ uBlock6, GOTO[KReadUHighOrLow],			c2, at[6,10,KReadUxx];	Q ¬ uBlock7, GOTO[KReadUHighOrLow],			c2, at[7,10,KReadUxx];	Q ¬ uBlock8, GOTO[KReadUHighOrLow],			c2, at[8,10,KReadUxx];	Q ¬ uBlock9, GOTO[KReadUHighOrLow],			c2, at[9,10,KReadUxx];	Q ¬ uBlockA, GOTO[KReadUHighOrLow],			c2, at[0A,10,KReadUxx];	Q ¬ uBlockB, GOTO[KReadUHighOrLow],			c2, at[0B,10,KReadUxx];	Q ¬ uBlockC, GOTO[KReadUHighOrLow],			c2, at[0C,10,KReadUxx];	Q ¬ uBlockD, GOTO[KReadUHighOrLow],			c2, at[0D,10,KReadUxx];	Q ¬ uBlockE, GOTO[KReadUHighOrLow],			c2, at[0E,10,KReadUxx];	Q ¬ uBlockF, GOTO[KReadUHighOrLow],			c2, at[0F,10,KReadUxx];KReadUHighOrLow:	rK ¬ 3, CALL[GetIOPByte],				c3;	[] ¬ rK, NZeroBr,					c1, at[3,10,KWait];	rK ¬ Q, BRANCH[KReadUHigh,KReadULow],			c2;KReadUHigh:	DebA ¬ rK LRot8, GOTO[KRestoreQ],			c*;KReadULow:	DebA ¬ rK LRot0, GOTO[KRestoreQ],			c*;{------------------------------------------------------	Command = 1, WriteU------------------------------------------------------}{Data sent: (1) high data byte, (2) low data byte, (3) reg number.}KWriteU:	uKSaveQ ¬ Q,						c1, at[1,8,KTable];	rK ¬ 4, CALL[GetIOPByte],				c2;	rK ¬ rK LRot8,						c3, at[4,10,KWait];	Q ¬ rK,  {high data byte}				c1;	rK ¬ 5, CALL[GetIOPByte],				c2;	Q ¬ rK or Q, {low data byte}				c3, at[5,10,KWait];	rK ¬ 6, CALL[GetIOPByte],				c1;	Xbus ¬ rK LRot12, XDisp,				c2, at[6,10,KWait];	Ybus ¬ rK, AltUaddr, DISP4[KWriteUxx],			c3;	uBlock0 ¬ Q, GOTO[KRestoreQ],				c1, at[0,10,KWriteUxx];	uBlock1 ¬ Q, GOTO[KRestoreQ],				c1, at[1,10,KWriteUxx];	uBlock2 ¬ Q, GOTO[KRestoreQ],				c1, at[2,10,KWriteUxx];	uBlock3 ¬ Q, GOTO[KRestoreQ],				c1, at[3,10,KWriteUxx];	uBlock4 ¬ Q, GOTO[KRestoreQ],				c1, at[4,10,KWriteUxx];	uBlock5 ¬ Q, GOTO[KRestoreQ],				c1, at[5,10,KWriteUxx];	uBlock6 ¬ Q, GOTO[KRestoreQ],				c1, at[6,10,KWriteUxx];	uBlock7 ¬ Q, GOTO[KRestoreQ],				c1, at[7,10,KWriteUxx];	uBlock8 ¬ Q, GOTO[KRestoreQ],				c1, at[8,10,KWriteUxx];	uBlock9 ¬ Q, GOTO[KRestoreQ],				c1, at[9,10,KWriteUxx];	uBlockA ¬ Q, GOTO[KRestoreQ],				c1, at[0A,10,KWriteUxx];	uBlockB ¬ Q, GOTO[KRestoreQ],				c1, at[0B,10,KWriteUxx];	uBlockC ¬ Q, GOTO[KRestoreQ],				c1, at[0C,10,KWriteUxx];	uBlockD ¬ Q, GOTO[KRestoreQ],				c1, at[0D,10,KWriteUxx];	uBlockE ¬ Q, GOTO[KRestoreQ],				c1, at[0E,10,KWriteUxx];	uBlockF ¬ Q, GOTO[KRestoreQ],				c1, at[0F,10,KWriteUxx];KRestoreQ:	Q ¬ uKSaveQ, GOTO[KWait],				c*;{------------------------------------------------------	Command = 2, Write RHrK------------------------------------------------------}{Data sent (1) data byte. 	}KWriteRHrK:	rK ¬ 7, CALL[GetIOPByte],				c1, at[2,8,KTable];	RHrK ¬ rK LRot0, GOTO[KWait],				c*, at[7,10,KWait];{------------------------------------------------------	Command = 3, Execute Buffer------------------------------------------------------}{This command executes the instructions placed into KBuffer by Burdock.  Burdock uses this mechanism to read and write all of Dandelions registers: It creates the instructions necessary to address the particular register (as outlined below), writes them into the control store beginning at location KBuffer, and then executes a command 3.}{KBuffer is an 18 word area which must be written by the IOP before executing an ExecuteBuffer command.  Microinstructions in KBuffer must have ia.7=1 for the pRet's of the read link overlay and the breakpoint restart overlays.}KExecuteBuffer:	Noop,							c1, at[3,8,KTable];	Noop,							c2;	GOTO[KBuffer],						c3;KBuffer:	Noop,							c*, at[KBufferLoc];	Noop,							c*, at[5,10,KBuffer];	Noop,							c*, at[6,10,KBuffer];	Noop,							c1, at[7,10,KBuffer];	Noop,							c*, at[8,10,KBuffer];	Noop,							c*, at[9,10,KBuffer];	Noop,							c1, at[0A,10,KBuffer];	Noop,							c*, at[0B,10,KBuffer];	Noop,							c*, at[0C,10,KBuffer];	Noop,							c1, at[0D,10,KBuffer];	GOTO[KWait],						c*, at[0E,10,KBuffer];KStart1:	rK ¬ 1F, GOTO[KBufferExt],				c*, at[0F,10,KBuffer];KBufferExt:	u1F ¬ rK,						c*, at[KBufferExtenLoc];	Xbus ¬ DebB, {Discard any lingering trash}		c*, at[9,10,KBufferExt];	UKSaveDisp ¬ 0,						c*, at[0A,10,KBufferExt];	rK ¬ 0FF,						c*, at[0B,10,KBufferExt];	UBreakID ¬ rK,						c*, at[0C,10,KBufferExt];	DebA ¬ rK LRot0, GOTO[KWait],				c*, at[0D,10,KBufferExt];{------------------------------------------------------	Command = 4, Read memory------------------------------------------------------}{	Burdock should first do:		RHrK ¬ <address0-7>,		uKAddr ¬ <address8-23>.	UKernMD loaded for later retrieval of data.}KReadMem:	rK ¬ uKAddr,						c1, at[4,8,KTable];	Noop,							c2;	Noop,							c3;	MAR ¬ [RHrK, rK+0],					c1;	Noop,							c2;	rK ¬ MD,						c3;	UKernMD ¬ rK, GOTO[KWait],				c*;{------------------------------------------------------	Command = 5, Write memory------------------------------------------------------}{	Burdock should first do:		RHrK ¬ <address0-7>,		uKAddr ¬ <address8-23>,		UKernMD ¬ <data0-15>. 	}KWriteMem:	rK ¬ uKAddr,						c1, at[5,8,KTable];	Noop,							c2;	Noop,							c3;	MAR ¬ [RHrK, rK+0],					c1;	MDR ¬ UKernMD,						c2;	GOTO[KWait],						c*;{------------------------------------------------------	Command = 6, Write CP memory block------------------------------------------------------}{	Burdock should first do:		RHrK ¬ <address0-7>,		uKAddr ¬ <address8-23>,		uKCount ¬ <count>. 	Data sent: 2*count bytes of data to be written into consecutive memory locations.}KWriteBlock:	rK ¬ 0E, CALL[GetIOPByte],				c1, at[6,8,KTable];	rK ¬ rK LRot8,						c2, at[0E,10,KWait];	UKernMD ¬ rK,						c3;	rK ¬ 0F, CALL[GetIOPByte],				c1;	rK ¬ rK or UKernMD,					c2, at[0F,10,KWait];	UKernMD ¬ rK,						c3;	rK ¬ uKAddr,						c1;	Noop,							c2;	Noop,							c3;	MAR ¬ [RHrK, rK+0],					c1;	MDR ¬ UKernMD,						c2;	rK ¬ rK + 1, CarryBr,					c3;	uKAddr ¬ rK, BRANCH[$,BankCrossed],			c1;	rK ¬ RHrK, GOTO[StoreRHrK],				c2;BankCrossed:	rK ¬ RHrK + 1, LOOPHOLE[byteTiming],			c2;StoreRHrK:	RHrK ¬ rK LRot0,					c3;	rK ¬ uKCount,						c1;	rK ¬ rK - 1, ZeroBr,					c2;	uKCount ¬ rK, BRANCH[KWriteBlock,DoneBlock],		c3;DoneBlock:	GOTO[KWait],						c*;{Kernel Start location:  Burdock begins the kernel executing at KStart after it has been loaded into the control store.  Note that KStart will actualy be exected twice.Also note that KStart is at location 0, so if a trap occurs while the kernel is running, it will be restarted.Second instruction executed by Kernel must be at[0F,10], to cancel random branch conditions at start up.}KStart:	ClrIntErr, CANCELBR[KStart1,0F],			c1, at[0];{KBuffer OverLays:  Only byte sized data chunks are transfered from the CP to the IOP.  For example, in order to read an R register, first the code to transfer the high byte is overlayed & executed, then the code to transfer the low byte is writen into KBuffer and executed.Some of the operations imply that UKTemp must be written first.Each overlay must return to KWait after completing its operations (except when continuing from a breakpoint or mouse stop).Following is the template code which Burdock should use to read and write CP registers.  These instructions are contained in Burdock.}{  Read R [0-7]	KBuffer:	DebA ¬ R<addr> LRot8, GOTO[KWait],	c1;  Read R [8-15]	KBuffer:	DebA ¬ R<addr> LRot0, GOTO[KWait],	c1;}{  Write R		Burdock should first do:		UKTemp ¬ <data0-15>,KBuffer:	R<addr> ¬ UKTemp, GOTO[KWait],	c1;}{  Read RH		KBuffer:	DebA ¬ RH<addr>, GOTO[KWait],	c1;}{  Write RH		KBuffer:	RH<addr> ¬ data, GOTO[KWait],	c1;}{  Read Q [0-7]	KBuffer:	DebA ¬ Q LRot8, GOTO[KWait],	c1;  Read Q [8-15]	KBuffer:	DebA ¬ Q LRot0, GOTO[KWait],	c1;}{  Write Q		Burdock should first do:		UKTemp ¬ <data0-15>,KBuffer:	Q ¬ UKTemp, GOTO[KWait],	c1;}{  Read U [0-7]	KBuffer:	rK ¬ U<addr>,	c1;		DebA ¬ rK LRot8, GOTO[KWait],	c2;  Read U [8-15]	KBuffer:	DebA ¬ U<addr>, GOTO[KWait],	c1;}{  Write U	KBuffer:	rK ¬ <data0-7>,	c1;		rK ¬ rK LRot8,	c2;		rK ¬ rK or <data8-15>,	c3;		U<addr> ¬ rK, GOTO[KWait],	c1;}{  Read IO	Burdock should first do:			UKAddr ¬ <address8-23>, 	KBuffer:	RHrK ¬ <address0-7>,	c1;		rK ¬ UKAddr,	c2;		Noop,	c3;		IO ¬ [RHrK, rK+0],	c1;		Noop,	c2;		rK ¬ MD,	c3;  Read IO [0-7]KBuffer+6:	DebA ¬ rK LRot8, GOTO[KWait],	c1;  Read IO [8-15]KBuffer+6:	DebA ¬ rK LRot0, GOTO[KWait],	c1;}{  Write IO	Burdock should first do:		UKAddr ¬ <address8-23>,		UKernMD ¬ <data0-15>. 	KBuffer:	RHrK ¬ <address0-7>,	c1;		rK ¬ UKAddr,	c2;		Noop,	c3;		IO ¬ [RHrK, rK+0],	c1;		MDR ¬ UKernMD, GOTO[KWait],	c2;}{  Read IOXIn	KBuffer:	DebA ¬ IOXIn<addr>, GOTO[KWait],	c1;}{  Read LinkKBuffer:	L<addr>Disp,	c1;  Read Link [2-3]	KBuffer+2:	DISP2[KLinkC],	c2;  Read Link [0]	KBuffer+2:	BRANCH[KLink7, KLinkF,7],	c2;  Read Link [1]	KBuffer+2:	BRANCH[KLinkB, KLinkF,0B],	c2;KLink7:		DebA ¬ 0, GOTO[KWait],	c*, at[0FF7];KLinkB:		DebA ¬ 0, GOTO[KWait],	c*, at[0FFB];KLinkC:		DebA ¬ 0, GOTO[KWait],	c*, at[0FFC];KLinkD:		DebA ¬ 1, GOTO[KWait],	c*, at[0FFD];KLinkE:		DebA ¬ 2, GOTO[KWait],	c*, at[0FFE];KLinkF:		DebA ¬ 3, GOTO[KWait],	c*, at[0FFF];}{  Write Link	Location KE is overwriten & restored.	KBuffer:	Xbus ¬ <data>, XDisp,	c1;		L<addr> ¬ 0, DISP4[KEntry],	c2;}{  Read pc16	KBuffer:	rK ¬ 0+pc16,	c1;		DebA ¬ rK LRot0, Cin¬pc16, GOTO[KWait],	c2;}{  Write pc16	KBuffer:	rK ¬ <data>+pc16, YDisp,	c1;		BRANCH[KFlip,KNoFlip,0E],	c2;KFlip:		Cin¬pc16, GOTO[KWait],	c3, at[0FFE];KNoFlip:	GOTO[KWait],		c3, at[0FFF];}{  Read ~stackP : Use Read IOXin}{  Write stackP	KBuffer:	stackP ¬ <data>, GOTO[KWait],	c1;}{  Read IBKBuffer:	rK ¬ 30,	c1;		rK ¬ rK and ~ErrnIBStkp, ZeroBr,	c2;		BRANCH[KIBOK,KIBEmpty],	c3;KIBOK:		DebA ¬ ibNA, GOTO[KWait],	c1, at[0FFE];KIBEmpty:	DebA ¬ 0, GOTO[KWait],		c1, at[0FFF];}{  Write IB		Burdock should first do:		UKTemp ¬ <data0-7>,KBuffer:	rK ¬ 30,	c1;		rK ¬ rK and ~ErrnIBStkp,	c2;		Xbus ¬ rK LRot12, XDisp,	c3;		DISP2[KIBCt],	c1;KIBCt0:		IB ¬ UKTemp, GOTO[SetIB1],	c2, at[0,4,KIBCt];KIBCt1:		IB ¬ UKTemp,			c2, at[1,4,KIBCt];SetIB1:		IBPtr ¬ 1, GOTOABS[KWaitLoc],	c3;KIBCt2:		Xbus ¬ ib,			c2, at[2,4,KIBCt];		rK ¬ UKTemp,	c3;		rK ¬ rK LRot8,	c1;		rK ¬ rK or ib, GOTO[FinishMerge],	c*;KIBCt3:		Xbus ¬ ib,			c2, at[3,4,KIBCt];		rK ¬ ib,	c3;		rK ¬ rK LRot8,	c1;		rK ¬ rK or ib,	c2;		IB ¬ UKTemp,	c3;		IBPtr ¬ 1,	c*;FinishMerge:	IB ¬ rK LRot0, GOTO[KWait], c*;}{  Read IBPtr : Use Read IOXin}{  Write IBPtr	KBuffer:	IBPtr ¬ <data>, GOTO[KWait],	c1;}{  Read MesaIntKBuffer:	MesaIntBr,	c1;	BRANCH[MIZero, MIOne],	c2;MIZero:	IOPOData ¬ 0, GOTO[KWait],	c3;MIOne:	IOPOData ¬ 1, GOTO[KWait],	c3;}{  Write MesaInt	KBuffer:	ClrIntErr, GOTO[KWait],	c1;KBuffer:	MesaIntRq, GOTO[KWait],	c1;}{  Read EKErr : Use Read IOXin}	{END [KStart];}
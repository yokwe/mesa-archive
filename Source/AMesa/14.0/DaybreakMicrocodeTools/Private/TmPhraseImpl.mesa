-- Copyright (C) 1982  by Xerox Corporation. All rights reserved. -- File: TmPhraseImpl.mesa   -- Last edit: JAC    	  3-Nov-84 15:23:12 -- Last edit: DEG        26-Sep-84 21:00:00-- Last edit: ETN     	 16-Jul-82 13:47:57DIRECTORY  Ascii USING [CR],  String USING [AppendChar, AppendString, EqualString],  TmAssembler USING [EofChar, Flagword, MyString, MyStringPtr, sizeArgArray],  TmControl USING [argBuf, numArgs],  TmFile USING [LogErrAndSrcLines, LogErrArgAndSrcLines, LogLine],  TmModule USING [GetNextProcessChar];TmPhraseImpl: PROGRAM IMPORTS String, TmControl, TmFile, TmModule EXPORTS TmModule  =  BEGIN OPEN TmAssembler;  AdvanceargBuffer: PROCEDURE [    argInxP: LONG POINTER TO CARDINAL [0..TmAssembler.sizeArgArray],    curSP: LONG POINTER TO LONG STRING] =    BEGIN    IF argInxP­ = TmAssembler.sizeArgArray THEN {      TmFile.LogErrArgAndSrcLines[        "Macro has Too many args"L, TmControl.argBuf[0]]}    ELSE      BEGIN      TmControl.numArgs ¬ argInxP­ ¬ argInxP­ + 1;      curSP­ ¬ TmControl.argBuf[argInxP­];      curSP­.length ¬ 0;      END;    END;  -- end AdvanceargBuffer  AppendStr: PROCEDURE [curS: LONG STRING, char: CHARACTER] RETURNS [BOOLEAN] =    INLINE    BEGIN    IF curS.length >= curS.maxlength THEN {      TmFile.LogErrArgAndSrcLines["String too long"L, curS]; RETURN[TRUE]}    ELSE String.AppendChar[curS, char];    RETURN[FALSE];    END;  -- end AppendStr  BreakPhraseArg: PUBLIC PROCEDURE [myS: MyStringPtr] RETURNS [flags: Flagword] =    BEGIN    char: CHARACTER;    argInx: CARDINAL [0..TmAssembler.sizeArgArray] ¬ 0;    bCount, pCount: CARDINAL ¬ 0;    curS: LONG STRING ¬ TmControl.argBuf[0];    flags ¬ Flagword[];    TmControl.numArgs ¬ 0;    curS.length ¬ 0;    DO      BEGIN      SELECT char ¬ Nextch[myS] FROM        EofChar => RETURN;        ', =>          IF pCount = 0 AND bCount = 1 THEN AdvanceargBuffer[@argInx, @curS]          ELSE GOTO Out;        IN ['0..'9] =>          BEGIN          IF flags.FirstChar THEN flags.LeadDigit ¬ TRUE;          flags.FirstChar ¬ FALSE;          GOTO Out;          END;        '[ =>          BEGIN          IF flags.FirstChar THEN            BEGIN flags.LeadBrkt ¬ TRUE; flags.FirstChar ¬ FALSE; GOTO Out; END          ELSE            BEGIN            bCount ¬ bCount + 1;            IF bCount # 1 THEN GOTO Out            ELSE              BEGIN flags.HasArgs ¬ TRUE; AdvanceargBuffer[@argInx, @curS]; END;            END;          END;        '] =>          BEGIN          IF flags.LeadBrkt THEN BEGIN flags.LeadBrkt ¬ FALSE; GOTO Out; END;          IF bCount = 1 THEN RETURN ELSE BEGIN bCount ¬ bCount - 1; GOTO Out; END;          END;        '( => BEGIN pCount ¬ pCount + 1; IF pCount # 0 THEN GOTO Out; END;        ') => BEGIN IF pCount # 1 THEN GOTO Out ELSE pCount ¬ pCount - 1; END;        ENDCASE => GOTO Out;      EXITS        Out =>          BEGIN          flags.FirstChar ¬ FALSE;          IF AppendStr[curS, char] THEN flags.Error ¬ TRUE;          IF flags.Error THEN EXIT;          END;      END;      ENDLOOP;    END;  -- end BreakPhraseArg  BreakPhraseMain: PUBLIC PROCEDURE [myS: MyStringPtr] RETURNS [flags: Flagword] =    BEGIN    char: CHARACTER;    argInx: CARDINAL [0..TmAssembler.sizeArgArray] ¬ 0;    bCount, pCount: CARDINAL ¬ 0;    curS: LONG STRING ¬ TmControl.argBuf[0];    flags ¬ Flagword[];    TmControl.numArgs ¬ 0;    curS.length ¬ 0;    DO      BEGIN      IF myS = NIL THEN char ¬ TmModule.GetNextProcessChar[]      ELSE {char ¬ Nextch[myS]; IF char = EofChar THEN RETURN};      SELECT char FROM  -- character handling same in arrow clause or not        Ascii.CR => LOOP;        EofChar =>          BEGIN          IF pCount # 0 OR bCount # 0 THEN {            TmFile.LogErrAndSrcLines["Unexpected EOF"L]; flags.Error ¬ TRUE};          flags.Eof ¬ TRUE;          RETURN;          END;        ', =>          BEGIN          IF flags.FirstChar THEN LOOP;          IF pCount = 0 AND bCount = 0 THEN {            IF curS.length = 0 THEN TmControl.numArgs ¬ TmControl.numArgs - 1;            RETURN};          IF pCount = 0 AND bCount = 1 THEN            BEGIN            IF NOT flags.ArrowClause OR curS.length # 0 THEN              AdvanceargBuffer[@argInx, @curS];            END          ELSE GOTO Out;          END;        '; =>          IF pCount # 0 OR bCount # 0 THEN            BEGIN            TmFile.LogErrAndSrcLines["Unexepcted semicolon"L];            flags.Error ¬ TRUE;            RETURN;            END          ELSE BEGIN flags.Semi ¬ TRUE; RETURN; END;        ': =>          BEGIN IF pCount = 0 AND bCount = 0 THEN flags.Label ¬ TRUE; RETURN; END;        '! => BEGIN curS.length ¬ 0; flags ¬ Flagword[]; LOOP; END;        IN ['0..'9] =>          BEGIN          IF flags.FirstChar THEN flags.LeadDigit ¬ TRUE;          flags.FirstChar ¬ FALSE;          GOTO Out;          END;        '[ =>          BEGIN          IF flags.FirstChar THEN            BEGIN flags.LeadBrkt ¬ TRUE; flags.FirstChar ¬ FALSE; GOTO Out; END          ELSE            BEGIN            IF bCount = 0 THEN              BEGIN              flags.HasArgs ¬ TRUE;              IF NOT flags.ArrowClause THEN AdvanceargBuffer[@argInx, @curS];              END;            bCount ¬ bCount + 1;            IF bCount # 1 THEN GOTO Out;            END;          END;        '] =>          BEGIN          IF flags.LeadBrkt THEN BEGIN flags.LeadBrkt ¬ FALSE; GOTO Out; END;          IF bCount = 1 THEN RETURN          ELSE            BEGIN            IF bCount = 0 THEN              BEGIN              TmFile.LogErrArgAndSrcLines[                "Unbalanced brackets"L, TmControl.argBuf[0]];              flags.Error ¬ TRUE;              END            ELSE BEGIN bCount ¬ bCount - 1; GOTO Out; END;            END;          END;        '¬ =>          IF pCount = 0 AND bCount = 0 THEN            BEGIN            flags.ArrowClause ¬ TRUE;            IF curS.length # 0 THEN AdvanceargBuffer[@argInx, @curS];            IF AppendStr[curS, '¬] THEN flags.Error ¬ TRUE;            AdvanceargBuffer[@argInx, @curS];            END          ELSE GOTO Out;	137C =>  --pre-11.1 backarrows          IF pCount = 0 AND bCount = 0 THEN            BEGIN            flags.ArrowClause ¬ TRUE;            IF curS.length # 0 THEN AdvanceargBuffer[@argInx, @curS];            IF AppendStr[curS, '¬] THEN flags.Error ¬ TRUE;            AdvanceargBuffer[@argInx, @curS];            END          ELSE GOTO Out;        ENDCASE =>          BEGIN  -- process remaining characters          IF flags.ArrowClause THEN            SELECT char FROM  -- chars in arrow clauses              '+, '-, '&, '~, ' =>                BEGIN                IF curS.length # 0 THEN AdvanceargBuffer[@argInx, @curS];                IF AppendStr[curS, char] THEN flags.Error ¬ TRUE;                AdvanceargBuffer[@argInx, @curS];                END;              < 041C, '(, ') =>                BEGIN                IF curS.length = 0 THEN LOOP;                AdvanceargBuffer[@argInx, @curS];                END;              ENDCASE => GOTO Out          ELSE            SELECT char FROM  -- chars not in arrow clauses              < 041C => LOOP;              '( => BEGIN pCount ¬ pCount + 1; IF pCount # 1 THEN GOTO Out; END;              ') =>                BEGIN                IF pCount = 0 THEN                  BEGIN                  TmFile.LogErrArgAndSrcLines[                    "Unbalanced parenthesis"L, TmControl.argBuf[0]];                  flags.Error ¬ TRUE;                  pCount ¬ 1;                  END;                pCount ¬ pCount - 1;                IF pCount # 0 THEN GOTO Out;                END;              --  ENDCASE   feed char thru              ENDCASE => BEGIN flags.FirstChar ¬ FALSE; GOTO Out; END;          END;      EXITS        Out =>          BEGIN          IF AppendStr[curS, char] THEN flags.Error ¬ TRUE;          IF flags.Error THEN EXIT;          END;      END;      ENDLOOP;    END;  -- end BreakPhraseMain  Nextch: PROCEDURE [myS: MyStringPtr] RETURNS [char: CHARACTER] = INLINE    BEGIN    IF myS.NextChar >= myS.String.length THEN RETURN[EofChar];    char ¬ myS.String[myS.NextChar];    myS.NextChar ¬ myS.NextChar + 1;    END;  -- end Nextch  SkipUntil: PUBLIC PROCEDURE [str: LONG STRING] =    BEGIN    char: CHARACTER;    msg: LONG STRING ¬ [150];    s: LONG STRING ¬ [100];    String.AppendString[msg, "Skipping until  "L];    String.AppendString[msg, str];    TmFile.LogLine[msg];    DO      char ¬ TmModule.GetNextProcessChar[];      SELECT char FROM        EofChar => {TmFile.LogErrAndSrcLines["EOF while skipping"L]; RETURN};        ';, < 041C => s.length ¬ 0;        '! => IF String.EqualString[s, str] THEN EXIT;        ENDCASE => IF s.length < 100 THEN String.AppendChar[s, char];      ENDLOOP;    msg.length ¬ 0;    String.AppendString[msg, str];    String.AppendString[msg, "  Found"L];    TmFile.LogLine[msg];    END;  -- end SkipUntil  END... -- end MassPhrase.mesa    -- Log:  -- 16-Jul-82 13:48:27 - ETN        - TrinityMass Version 1  -- Time: 26-Sep-84 20:59:55	By: DEG     	Action: Added copyright notice and rebuild for 11.1 release.  --  3-Nov-84 15:23:34		JAC   	make backwards compatible with pre-11.1 releases regarding backarrows
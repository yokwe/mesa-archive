-- File: TmLabelDaybreak.mesa  *** Daybreak: Flush MDR/MD warnings for IO¬; prohibit memory read/write in same click-- Last edit: JoM     28-Mar-84 16:43:51-- Last edit: JAC    22-Jul-83 19:14:15-- Last edit: HGM  26-May-83 14:57:05-- Last edit: ETN    28-Oct-82 10:35:32DIRECTORY  Ascii USING [CR],  Environment USING [Byte, bytesPerWord, Block],  Heap USING [MakeNode],  Inline USING [BITSHIFT, BITAND],  MassBurdockInterface,  Stream USING [PutBlock, PutWord],  String USING [    AppendChar, AppendDecimal, AppendString, EqualString, WordsForString],  TmAssembler USING [    aS0A, aS0B, aS0Q, aSD0, aFrPlusS, BuiltinMacroType, Encoding, EncodingPtr,    fS01dispBr, fS01fYNorm, fS2stackP, fS2fZNorm, fS2IOIn, fS3fZNorm, fS3IOIn, fXcinpc16, fXMap,    fYIBDisp, fYMap, fYstackP, fZcinpc16, fZIgnorePgCr, GetStmtSpace],  TmControl USING [curTask, linkLoad, linkVal, statement],  TmFile USING [    ebStream, LogErrAndSrcLines, LogErrArgAndSrcLines, LogLine, mlStream,    siStream],  TmLabel,  TmModule;TmLabelDaybreak: PROGRAM  IMPORTS Heap, Inline, Stream, String, TmAssembler, TmControl, TmFile, TmLabel, TmModule  EXPORTS TmLabel, TmModule =  BEGIN OPEN MassBurdockInterface, TmAssembler, TmControl, TmLabel, String;  adjMI: BOOLEAN;  atLabel: HashEntryPtr;  curLabelSeqNum: CARDINAL;  curMI: CurrentMI;  curMISeqNum: CARDINAL;  curMILabelSeqNum: CARDINAL;  errgcb: BOOLEAN;  errgst: BOOLEAN;  errcy: BOOLEAN;  errgcy: BOOLEAN;  extCurDestField: BOOLEAN;  fromMI: LabelEntry;  hasLabel: BOOLEAN;  immCurDestField: BOOLEAN;  immLastDestField: BOOLEAN;  MiRes: TYPE = PACKED ARRAY [0..4096) OF BOOLEAN;  miRes: LONG POINTER TO MiRes;  miResUsed: BOOLEAN;  none: CARDINAL = 4096;  taskSA: ARRAY [0..8) OF INTEGER;  thisLabel: LONG POINTER TO LabelList;  thisMI: LabelEntry;  toLabel: LONG POINTER TO LabelList;  byteTiming: PUBLIC BOOLEAN;  canceledBr: PUBLIC BOOLEAN;  canceledBr2: PUBLIC BOOLEAN;  curLineLab: PUBLIC LONG STRING ¬ [64];  curLineNum: PUBLIC CARDINAL;  masked: PUBLIC CARDINAL [0..3];  mdok: PUBLIC BOOLEAN;  mdrok: PUBLIC BOOLEAN;  natc: PUBLIC BOOLEAN;  niblTiming: PUBLIC BOOLEAN;  pci: PUBLIC BOOLEAN;  stw: PUBLIC BOOLEAN;  wok: PUBLIC BOOLEAN;  InitGlobalLabel: PUBLIC PROC =    BEGIN    i: CARDINAL;    miRes ¬ TmModule.MTtempHeap.NEW[MiRes];    FOR i IN [0..4096) DO miRes[i] ¬ FALSE; ENDLOOP;    FOR i IN [0..8) DO taskSA[i] ¬ -1; ENDLOOP;    thisLabel ¬ NIL;    toLabel ¬ NIL;    LabelInit[];    END;  -- end InitGlobalLabel  AppendLabel: PUBLIC PROC [    list: LONG POINTER TO LONG POINTER TO LabelList, hep: HashEntryPtr] = {    mum: LONG POINTER TO LabelList;    mum ¬ GetStmtSpace[SIZE[LabelList]];    mum­ ¬ [next: list­, label: hep];    list­ ¬ mum;    };  -- end AppendLabel    BuildEarlyBinary: PUBLIC PROC [encodingPtr: EncodingPtr] = {    earlyBinaryRec: EarlyBinaryRec ¬ [      partialBinary: BuildPartialBinary[encodingPtr], destMI: curMI, last: FALSE,      sa: FALSE];    ebrBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[LONG[@earlyBinaryRec]], startIndex: 0,      stopIndexPlusOne: Environment.bytesPerWord*SIZE[EarlyBinaryRec]];    [] ¬ Stream.PutBlock[TmFile.ebStream, ebrBlock];    };  -- end BuildEarlyBinary  BuildPartialBinary: PROC [encodingPtr: EncodingPtr]    RETURNS [partialBinary: PartialBinary] = {    constraintRec: ConstraintRec;    crBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[LONG[@constraintRec]], startIndex: 0,      stopIndexPlusOne: Environment.bytesPerWord*SIZE[ConstraintRec]];    enil: Encoding ¬ Encoding[];    labelRec: LabelRec;    IF encodingPtr = NIL THEN encodingPtr ¬ @enil;    IF encodingPtr­.ia7.assignment.type # null THEN {      labelRec ¬ curMI.dest;      constraintRec ¬ [labelRec, labelRec, encodingPtr­.ia7.value, 0];      [] ¬ Stream.PutBlock[TmFile.mlStream, crBlock];      };    partialBinary ¬ PartialBinary[      rA: encodingPtr­.rA.value, rB: encodingPtr­.rB.value,      aS: encodingPtr­.aS.value, aF: encodingPtr­.aF.value,      aD: encodingPtr­.aD.value, parity: 0, cin: encodingPtr­.cin.value,      enSU: encodingPtr­.enSU.value, mem: encodingPtr­.mem.value,      fS01: encodingPtr­.fS01.value, fS2: encodingPtr­.fS2.value,      fS3: encodingPtr­.fS3.value, fX: encodingPtr­.fX.value,      fY: encodingPtr­.fY.value, fZ: encodingPtr­.fZ.value, addr: 0,      cycle: encodingPtr­.cy.value MOD 4, task: TmControl.curTask,      withinIndex: 0];    };  -- end BuildPartialBinary  BrConstrain: PUBLIC PROC [    lab1, lab2: LONG STRING, offset: CARDINAL, modulo: ModuloIndex] = {    constraintRec: ConstraintRec;    crBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[LONG[@constraintRec]], startIndex: 0,      stopIndexPlusOne: Environment.bytesPerWord*SIZE[ConstraintRec]];    lab1rec, lab2rec: LabelRec;    eP: HashEntryPtr;    IF NOT EqualString[lab1, "$"L] THEN {      eP ¬ ProcessDestLabel[lab1];      lab1rec ¬ LabelRec[labeled[eP­.ptr­.labelseqnum]];      curMI.dest ¬ LabelRec[labeled[eP­.ptr­.labelseqnum]];      }    ELSE {      lab1rec ¬ LabelRec[unlabeled[curMISeqNum + 1]]; immCurDestField ¬ TRUE; };    IF NOT EqualString[lab2, "$"L] THEN {      eP ¬ ProcessDestLabel[lab2];      lab2rec ¬ LabelRec[labeled[eP­.ptr­.labelseqnum]];      }    ELSE {      lab2rec ¬ LabelRec[unlabeled[curMISeqNum + 1]]; immCurDestField ¬ TRUE; };    curMI.andMask ¬ maxNumMI - 1;    curMI.orMask ¬ 0;    constraintRec ¬ ConstraintRec[lab1rec, lab2rec, offset, modulo];    [] ¬ Stream.PutBlock[TmFile.mlStream, crBlock];    offset ¬ Inline.BITAND[37B, Inline.BITSHIFT[1, modulo]] - 1;    constraintRec ¬ ConstraintRec[lab2rec, lab1rec, offset, modulo];    [] ¬ Stream.PutBlock[TmFile.mlStream, crBlock];    };  -- end BrConstrain  Constrain: PUBLIC PROC [    lab1, lab2: LONG STRING, offset: CARDINAL, modulo: ModuloIndex] = {    constraintRec: ConstraintRec;    crBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[LONG[@constraintRec]], startIndex: 0,      stopIndexPlusOne: Environment.bytesPerWord*SIZE[ConstraintRec]];    lab1rec, lab2rec: LabelRec;    eP: HashEntryPtr;    IF NOT EqualString[lab1, "$"L] THEN {      eP ¬ ProcessDestLabel[lab1];      lab1rec ¬ LabelRec[labeled[eP­.ptr­.labelseqnum]];      }    ELSE {      lab1rec ¬ LabelRec[unlabeled[curMISeqNum + 1]]; immCurDestField ¬ TRUE; };    IF NOT EqualString[lab2, "$"L] THEN {      IF EqualString[lab2, lab1] THEN lab2rec ¬ lab1rec      ELSE {        eP ¬ ProcessDestLabel[lab2];        lab2rec ¬ LabelRec[labeled[eP­.ptr­.labelseqnum]];        };      }    ELSE {      lab2rec ¬ LabelRec[unlabeled[curMISeqNum + 1]]; immCurDestField ¬ TRUE; };    constraintRec ¬ ConstraintRec[lab1rec, lab2rec, offset, modulo];    [] ¬ Stream.PutBlock[TmFile.mlStream, crBlock];    };  -- end Constrain  CycleTest: PROC [code: {fromto, herehere, toto}, needs: Cycle, is: Cycle]    RETURNS [cy: Cycle] = {    SELECT code FROM      fromto => {        IF is = x OR is = cX THEN RETURN[needs]        ELSE {          cy ¬ SELECT is FROM c1 => c2, c2 => c3, c3 => c1, ENDCASE => x;          IF cy = needs OR needs = x THEN RETURN[cy] ELSE RETURN[cX];          };        };      ENDCASE => {        IF is = x OR needs = x THEN RETURN[x];        IF is = cX THEN RETURN[cX];        IF needs # cX THEN IF needs = is THEN RETURN[is];        };    SELECT code FROM      herehere => {        IF NOT errcy THEN          TmFile.LogErrAndSrcLines[            "Cycle Conflict: wrong cycle comes to this MI "L];        errcy ¬ TRUE;        };      toto => {        IF NOT errgcy THEN          TmFile.LogErrAndSrcLines[            "Cycle Conflict: this MI goes to wrong cycle "L];        errgcy ¬ TRUE;        };      ENDCASE;    };  -- end CycleTest  EndOfStatementProc: PUBLIC PROC = {    constraintRec: ConstraintRec;    crBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[LONG[@constraintRec]], startIndex: 0,      stopIndexPlusOne: Environment.bytesPerWord*SIZE[ConstraintRec]];    enil: Encoding ¬ Encoding[];    eP: EncodingPtr ¬ TmControl.statement.encoding;    ptr: LONG POINTER TO LabelList;    IF NOT natc AND atLabel # NIL THEN AppendLabel[@thisLabel, atLabel];    IF TmControl.linkLoad THEN {      constraintRec ¬ ConstraintRec[curMI.dest, curMI.dest, TmControl.linkVal, 4];      [] ¬ Stream.PutBlock[TmFile.mlStream, crBlock];      linkLoad ¬ FALSE;      };    IF eP = NIL THEN eP ¬ @enil;    thisMI.pBr ¬ SELECT eP.fS01.value FROM fS01dispBr => TRUE, ENDCASE => FALSE;    thisMI.isBr ¬ canceledBr;    thisMI.isCB2 ¬ (Inline.BITAND[masked, 2] # 0);    thisMI.isCycle ¬      SELECT eP­.cy.value FROM 1 => c1, 2 => c2, 3 => c3, 4 => cX, ENDCASE => x;    IF thisMI.isCycle = x THEN      TmFile.LogErrAndSrcLines["Cycle Error: no cycle for this MI "L];    IF NOT hasLabel AND atLabel = NIL AND NOT immLastDestField THEN      TmFile.LogErrAndSrcLines["This MI cannot be gotten to "L];    thisMI.ldStkp ¬ (eP.fS01.value = fS01fYNorm) AND (eP.fY.value = fYstackP);    thisMI.isstk ¬ (eP.enSU.value = 1) AND (eP.fS2.value = fS2stackP);    thisMI.isIBDisp ¬ (eP.fS01.value = fS01fYNorm) AND (eP.fY.value = fYIBDisp);    IF eP.mem.value = 1 AND thisMI.isCycle = c2 THEN {      IF canceledBr2 AND NOT wok THEN        TmFile.LogErrAndSrcLines[          "Illegal CANCELBR on memory write - - write may abort"L];      thisMI.hasW ¬ NOT mdrok;      };    IF eP.mem.value = 1 AND thisMI.isCycle = c3 THEN thisMI.hasR ¬ NOT mdok;    thisMI.c1noM ¬ TRUE;    IF  -- Dicentra: IO¬      ((eP.fS01.value = fS01fYNorm) AND (eP.fY.value = 12))  -- Need additions to TmAssembler      OR ((eP.fS2.value = fS2IOIn) AND (eP.fS3.value = fS3IOIn) AND (eP.fZ.value = 7)) THEN      thisMI.c1noM ¬ FALSE;    IF      ((eP.fX.value = fXMap)        OR ((eP.fS01.value = fS01fYNorm) AND (eP.fY.value = fYMap))) THEN      thisMI.c1noM ¬ FALSE;    IF eP.mem.value = 1 AND thisMI.isCycle = c1 THEN {      thisMI.c1noM ¬ FALSE;      IF eP.aF.value NOT IN [0..3] THEN        TmFile.LogErrAndSrcLines["Error --   MAR ¬ with illegal aF field "L];      IF eP.aF.value = 2 AND NOT pci THEN        TmFile.LogErrAndSrcLines["WARNING: sense of PageCross is inverted"L];      IF eP.fS2.value = fS2fZNorm AND eP.fS3.value = fS3fZNorm        AND eP.fZ.value = fZIgnorePgCr THEN thisMI.pBr ¬ FALSE      ELSE        IF          (eP.cin.value = 1 OR eP.fX.value = fXcinpc16            OR              (eP.fZ.value = fZcinpc16 AND eP.fS2.value = fS2fZNorm                AND eP.fS3.value = fS3fZNorm) OR eP.aF.value # aFrPlusS            OR              (eP.aS.value # aS0A AND eP.aS.value # aS0B AND eP.aS.value # aSD0                AND eP.aS.value # aS0Q)) THEN thisMI.pBr ¬ thisMI.pCB2 ¬ TRUE;      };    IF eP.fX.value < 8 AND eP.ia7.value = 3 THEN thisMI.pBr ¬ TRUE;  -- LnDisp's    adjMI ¬ immCurDestField OR NOT extCurDestField;    IF fromMI.c1noM THEN thisMI.c2noM ¬ TRUE;    IF fromMI.c2noM THEN thisMI.c3noM ¬ TRUE;    IF fromMI.hasW THEN thisMI.fromW ¬ TRUE;    IF fromMI.pBr THEN thisMI.needsBr ¬ TRUE;    IF fromMI.pCB2 THEN thisMI.needsCB2 ¬ TRUE;    IF fromMI.ldStkp THEN thisMI.stknok ¬ TRUE;    IF fromMI.isIBDisp THEN thisMI.ldStkpnok ¬ TRUE;    thisMI.needsCycle ¬ CycleTest[fromto, thisMI.needsCycle, fromMI.isCycle];    ptr ¬ thisLabel;    UNTIL ptr = NIL DO      thisMI.needsBr ¬ thisMI.needsBr OR ptr.label.ptr.needsBr;      thisMI.needsCB2 ¬ thisMI.needsCB2 OR ptr.label.ptr.needsCB2;      thisMI.c2noM ¬ thisMI.c2noM OR ptr.label.ptr.c2noM;      thisMI.c3noM ¬ thisMI.c3noM OR ptr.label.ptr.c3noM;      thisMI.fromW ¬ thisMI.fromW OR ptr.label.ptr.fromW;      thisMI.stknok ¬ thisMI.stknok OR ptr.label.ptr.stknok;      thisMI.ldStkpnok ¬ thisMI.ldStkpnok OR ptr.label.ptr.ldStkpnok;      IF ptr.label.ptr.isCycle # x AND ptr.label.ptr.isCycle # thisMI.isCycle THEN        IF ptr.label.ptr.needsCycle = x THEN ptr.label.ptr.needsfromcX ¬ TRUE        ELSE [] ¬ CycleTest[herehere, ptr.label.ptr.needsCycle, thisMI.isCycle]      ELSE {        ptr.label.ptr.isCycle ¬ thisMI.isCycle;        [] ¬ CycleTest[herehere, ptr.label.ptr.needsCycle, thisMI.isCycle];        [] ¬ CycleTest[herehere, ptr.label.ptr.isCycle, thisMI.isCycle];        };      ptr ¬ ptr.next;      ENDLOOP;    ptr ¬ toLabel;    UNTIL ptr = NIL DO      thisMI.toR ¬ thisMI.toR OR ptr.label.ptr.hasR;      ptr.label.ptr.fromW ¬ ptr.label.ptr.fromW OR thisMI.hasW;      ptr ¬ ptr.next;      ENDLOOP;    ptr ¬ thisLabel;    UNTIL ptr = NIL DO      ptr.label.ptr.isBr ¬ ptr.label.ptr.isBr AND thisMI.isBr;      ptr.label.ptr.isCB2 ¬ ptr.label.ptr.isCB2 AND thisMI.isCB2;      ptr.label.ptr.isstk ¬ ptr.label.ptr.isstk OR thisMI.isstk;      ptr.label.ptr.needsBr ¬ ptr.label.ptr.needsBr OR thisMI.needsBr;      ptr.label.ptr.needsCB2 ¬ ptr.label.ptr.needsCB2 OR thisMI.needsCB2;      ptr.label.ptr.c2noM ¬ ptr.label.ptr.c2noM AND thisMI.c2noM;      ptr.label.ptr.c3noM ¬ ptr.label.ptr.c3noM AND thisMI.c3noM;      ptr.label.ptr.hasW ¬ ptr.label.ptr.hasW OR thisMI.hasW;      ptr.label.ptr.hasR ¬ ptr.label.ptr.hasR OR thisMI.hasR;      ptr.label.ptr.stknok ¬ ptr.label.ptr.stknok OR thisMI.stknok;      ptr.label.ptr.ldStkpnok ¬ ptr.label.ptr.ldStkpnok OR thisMI.ldStkpnok;      ptr.label.ptr.toR ¬ ptr.label.ptr.toR OR thisMI.toR;      ptr.label.ptr.fromW ¬ ptr.label.ptr.fromW OR thisMI.fromW;      ptr ¬ ptr.next;      ENDLOOP;    [] ¬ CycleTest[herehere, thisMI.needsCycle, thisMI.isCycle];    IF thisMI.needsCB2 AND NOT thisMI.isCB2 THEN      TmFile.LogErrAndSrcLines["This MI needs a CANCELBR[ ,2]"L]    ELSE      IF thisMI.needsBr AND NOT thisMI.isBr THEN        TmFile.LogErrAndSrcLines["This MI needs a CANCELBR"L];    IF thisMI.ldStkpnok AND thisMI.ldStkp THEN      TmFile.LogErrAndSrcLines["This MI does stackP¬ and follows IBDisp"L];    IF thisMI.stknok AND thisMI.isstk THEN      TmFile.LogErrAndSrcLines[        "This MI references the Stk and stackP loaded in previous cycle"L];    IF thisMI.c2noM AND thisMI.hasW THEN      TmFile.LogErrAndSrcLines[        "This MI has an MDR¬ without starting memory in the previous cycle"L];    IF thisMI.c3noM AND thisMI.hasR THEN      TmFile.LogErrAndSrcLines[        "This MI has an ¬MD without starting memory previously"L];    -- next 2 tests for Daybreak: can't read & write memory in same click    IF thisMI.toR AND thisMI.hasW THEN      TmFile.LogErrAndSrcLines[        "This MI has an MDR¬ and goes to a ¬MD"L];    IF thisMI.fromW AND thisMI.hasR THEN      TmFile.LogErrAndSrcLines[        "This MI has an ¬MD and comes from an MDR¬"L];    ptr ¬ toLabel;    UNTIL ptr = NIL DO      IF thisMI.pBr THEN ptr.label.ptr.needsBr ¬ TRUE;      IF thisMI.pCB2 THEN ptr.label.ptr.needsCB2 ¬ TRUE;      IF thisMI.pBr AND NOT ptr.label.ptr.isBr THEN {        IF NOT errgcb THEN          TmFile.LogErrAndSrcLines[            "This MI goes to an MI which needs a CANCELBR"L];        errgcb ¬ TRUE;        };      IF thisMI.pCB2 AND NOT ptr.label.ptr.isCB2 THEN {        IF NOT errgcb THEN          TmFile.LogErrAndSrcLines[            "This MI goes to an MI which needs a CANCELBR[ ,2]"L];        errgcb ¬ TRUE;        };      IF thisMI.c1noM THEN ptr.label.ptr.c2noM ¬ TRUE;      IF thisMI.c1noM AND ptr.label.ptr.hasW THEN        TmFile.LogErrAndSrcLines[          "This MI doesn't start memory and goes to a MDR¬"L];      IF thisMI.c1noM AND ptr.label.ptr.toR THEN        TmFile.LogErrAndSrcLines[          "This MI doesn't start memory and gets to a ¬MD"L];      IF thisMI.c2noM THEN ptr.label.ptr.c3noM ¬ TRUE;      IF thisMI.c2noM AND ptr.label.ptr.hasR THEN        TmFile.LogErrAndSrcLines[          "memory hasn't been started and this mi goes to a ¬MD"L];      IF thisMI.isIBDisp THEN ptr.label.ptr.ldStkpnok ¬ TRUE;      IF thisMI.isIBDisp AND ptr.label.ptr.ldStkp THEN        TmFile.LogErrAndSrcLines["This MI has an IBDisp and goes to a stackP¬"L];      IF thisMI.ldStkp THEN ptr.label.ptr.stknok ¬ TRUE;      IF thisMI.ldStkp AND ptr.label.ptr.isstk THEN {        IF NOT errgst THEN          TmFile.LogErrAndSrcLines[            "This MI goes to an MI which references the Stk and stackP loaded here"L];        errgst ¬ TRUE;        };      IF ptr.label.ptr.needsfromcX AND thisMI.isCycle # cX THEN        TmFile.LogErrAndSrcLines["This MI not a c* and goes to different cycles"L]      ELSE {        ptr.label.ptr.needsCycle ¬ CycleTest[          fromto, ptr.label.ptr.needsCycle, thisMI.isCycle];        [] ¬ CycleTest[toto, ptr.label.ptr.needsCycle, ptr.label.ptr.isCycle];        };      ptr ¬ ptr.next;      ENDLOOP;    atLabel ¬ NIL;    thisLabel ¬ NIL;    toLabel ¬ NIL;    fromMI ¬ IF adjMI THEN thisMI ELSE LabelEntry[];    thisMI ¬ LabelEntry[];    curMISeqNum ¬ curMISeqNum + 1;    curMI ¬ CurrentMI[dest: LabelRec[unlabeled[curMISeqNum + 1]]];    curMILabelSeqNum ¬ none;    immLastDestField ¬ adjMI;    curLineNum ¬ curLineNum + 1;    adjMI ¬ extCurDestField ¬ immCurDestField ¬ FALSE;    hasLabel ¬ canceledBr ¬ canceledBr2 ¬ FALSE;    mdrok ¬ mdok ¬ wok ¬ stw ¬ natc ¬ canceledBr ¬ canceledBr2 ¬ byteTiming ¬      niblTiming ¬ pci ¬ FALSE;    masked ¬ 0;    errgcb ¬ errgst ¬ errcy ¬ errgcy ¬ FALSE;    };  -- end EndOfStatementProc  GetLabelEntry: PUBLIC PROC [name: LONG STRING]    RETURNS [hashEntryPtr: HashEntryPtr] = {    str: LONG STRING;    labelEntryPtr: LabelEntryPtr;    labelEntryPtr ¬ Heap.MakeNode[      LTtempHeap,      SIZE[LabelEntry] + SIZE[HashEntry] + WordsForString[name.length]];    hashEntryPtr ¬ LOOPHOLE[labelEntryPtr + SIZE[LabelEntry]];    str ¬ LOOPHOLE[hashEntryPtr + SIZE[HashEntry]];    str­ ¬ [length: 0, maxlength: name.length, text:];    AppendString[str, name];    labelEntryPtr­ ¬ LabelEntry[];    hashEntryPtr­ ¬ HashEntry[str, labelEntryPtr, NIL];    };  -- end GetLabelEntry  LabelInit: PROC = {    atLabel ¬ NIL;    thisLabel ¬ NIL;    toLabel ¬ NIL;    thisMI ¬ LabelEntry[];    fromMI ¬ LabelEntry[];    curLabelSeqNum ¬ curMISeqNum ¬ 0;    curMILabelSeqNum ¬ none;    immLastDestField ¬ immCurDestField ¬ extCurDestField ¬ FALSE;    adjMI ¬ hasLabel ¬ FALSE;    mdrok ¬ mdok ¬ wok ¬ stw ¬ natc ¬ canceledBr ¬ canceledBr2 ¬ byteTiming ¬      niblTiming ¬ pci ¬ FALSE;    masked ¬ 0;    errgcb ¬ errgst ¬ errcy ¬ errgcy ¬ FALSE;    miResUsed ¬ FALSE;    curMI ¬ CurrentMI[dest: LabelRec[unlabeled[1]]];    curLineLab.length ¬ 0;    AppendString[curLineLab, "beginning m-i"L];    curLineNum ¬ 0;    };  -- end LabelInit  McFileEndProc: PUBLIC PROC = {    constraintRec: ConstraintRec;    crBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[LONG[@constraintRec]], startIndex: 0,      stopIndexPlusOne: Environment.bytesPerWord*SIZE[ConstraintRec]];    earlyBinaryRec: EarlyBinaryRec;    ebrBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[LONG[@earlyBinaryRec]], startIndex: 0,      stopIndexPlusOne: Environment.bytesPerWord*SIZE[EarlyBinaryRec]];    lsr: LabelIntRec;    lsrBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[LONG[@lsr]], startIndex: 0,      stopIndexPlusOne: Environment.bytesPerWord*SIZE[LabelIntRec]];    str: LONG STRING ¬ "  Number of m-i  =  xxxxx"L;    IF immLastDestField THEN      TmFile.LogErrAndSrcLines["The last MI lacks a destination "L];    -- write a final ml record    constraintRec ¬ ConstraintRec[LabelRec[special[]], LabelRec[special[]], 0, 0];    [] ¬ Stream.PutBlock[TmFile.mlStream, crBlock];    -- write a final eb record    earlyBinaryRec ¬ EarlyBinaryRec[      partialBinary: PartialBinary[], destMI: CurrentMI[], last: TRUE];    [] ¬ Stream.PutBlock[TmFile.ebStream, ebrBlock];    -- write the reserves    [] ¬ Stream.PutWord[TmFile.mlStream, LOOPHOLE[miResUsed, WORD]];    IF miResUsed THEN      [] ¬ Stream.PutBlock[        TmFile.mlStream, Environment.Block[        blockPointer: LOOPHOLE[miRes], startIndex: 0,        stopIndexPlusOne: Environment.bytesPerWord*SIZE[MiRes]]];    -- write out symbol table    DisplayLabels[PutOutSymbol];        -- put out the final record    lsr ¬ LabelIntRec[      export: FALSE, import: FALSE, found: FALSE, labIndex: 0, length: 0,      miIndex: Empty];    [] ¬ Stream.PutBlock[TmFile.siStream, lsrBlock];    [] ¬ Stream.PutWord[TmFile.siStream, curMISeqNum];    [] ¬ Stream.PutWord[TmFile.siStream, curLabelSeqNum];    str.length ¬ str.length - 5;    AppendDecimal[str, curMISeqNum];    AppendChar[str, Ascii.CR];    TmFile.LogLine[str];    LabelInit[];    };  -- end McFileEndProc  MakeLabelEntry: PROC [name: LONG STRING] RETURNS [hashEntryPtr: HashEntryPtr] =    {    hashEntryPtr ¬ NIL;    IF name # NIL THEN {      hashEntryPtr ¬ FindLabel[name];      IF hashEntryPtr = NIL THEN {  -- label was not in table        hashEntryPtr ¬ GetLabelEntry[name];        hashEntryPtr­.ptr­.labelseqnum ¬ curLabelSeqNum;        [] ¬ InsertLabel[hashEntryPtr];        curLabelSeqNum ¬ curLabelSeqNum + 1;        };      };    };  -- end MakeLabelEntry  ProcessAt: PUBLIC PROC [    offset: CARDINAL, modulo: ModuloIndex, name: LONG STRING] = {    str: LONG STRING ¬ [100];    labelRec: LabelRec;    constraintRec: ConstraintRec;    crBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[LONG[@constraintRec]], startIndex: 0,      stopIndexPlusOne: Environment.bytesPerWord*SIZE[ConstraintRec]];    hashEntryPtr: HashEntryPtr ¬ MakeLabelEntry[name];    hasLabel ¬ TRUE;    IF name # NIL THEN {hashEntryPtr.ptr.incons ¬ TRUE; atLabel ¬ hashEntryPtr; };    labelRec ¬      IF name = NIL THEN LabelRec[unlabeled[curMISeqNum]]      ELSE        (SELECT TRUE FROM           hashEntryPtr­.ptr­.found => LabelRec[             unlabeled[hashEntryPtr­.ptr­.miseqnum]],           ENDCASE => LabelRec[labeled[hashEntryPtr­.ptr­.labelseqnum]]);    constraintRec ¬ ConstraintRec[      LabelRec[unlabeled[curMISeqNum]], labelRec, offset, modulo];    [] ¬ Stream.PutBlock[TmFile.mlStream, crBlock];    };  -- end ProcessAt  ProcessDestLabel: PUBLIC PROC [name: LONG STRING]    RETURNS [hashEntryPtr: HashEntryPtr] = {    IF EqualString[name, "$"L] THEN RETURN;    extCurDestField ¬ TRUE;    IF name = NIL THEN RETURN[NIL];    hashEntryPtr ¬ MakeLabelEntry[name];    AppendLabel[@toLabel, hashEntryPtr];    };  -- end ProcessDestLabel  ProcessExternal: PUBLIC PROC [type: BuiltinMacroType, name: LONG STRING] = {    hashEntryPtr: HashEntryPtr ¬ MakeLabelEntry[name];    SELECT type FROM      export => hashEntryPtr­.ptr­.export ¬ TRUE;      import => hashEntryPtr­.ptr­.import ¬ TRUE;      ENDCASE;    };  -- end ProcessExternal  ProcessLineLabel: PUBLIC PROC [name: LONG STRING]    RETURNS [hashEntryPtr: HashEntryPtr] = {    curLineLab.length ¬ 0;    AppendString[curLineLab, name];    curLineNum ¬ 0;    hashEntryPtr ¬ MakeLabelEntry[name];    curMILabelSeqNum ¬ curLabelSeqNum;    hashEntryPtr­.ptr­.labeled ¬ TRUE;    hashEntryPtr­.ptr­.found ¬ TRUE;    IF hashEntryPtr­.ptr­.miseqnum # NullIndex THEN      TmFile.LogErrArgAndSrcLines["Label previously defined"L, name];    hashEntryPtr­.ptr­.miseqnum ¬ curMISeqNum;    curMILabelSeqNum ¬ hashEntryPtr­.ptr­.labelseqnum;    hasLabel ¬ TRUE;    AppendLabel[@thisLabel, hashEntryPtr];    };  -- end ProcessLineLabel  ProcessReserve: PUBLIC PROC [lowAddr, highAddr: CARDINAL] = {    i: CARDINAL;    miResUsed ¬ TRUE;    FOR i IN [lowAddr..highAddr] DO miRes[i] ¬ TRUE ENDLOOP;    };  -- end ProcessReserve  ProcSA: PUBLIC PROC [name: LONG STRING, val: INTEGER] = {    earlyBinaryRec: EarlyBinaryRec;    ebrBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[LONG[@earlyBinaryRec]], startIndex: 0,      stopIndexPlusOne: Environment.bytesPerWord*SIZE[EarlyBinaryRec]];    hashEntryPtr: HashEntryPtr;    task: CARDINAL ¬ TmControl.curTask;    IF name = NIL THEN RETURN;    hashEntryPtr ¬ MakeLabelEntry[name];    val ¬ Inline.BITAND[val, 7777B];    IF (taskSA[task] # -1) AND (taskSA[task] # val) THEN      TmFile.LogErrAndSrcLines["Multiple Start Addresses for current task"L];    taskSA[task] ¬ val;    earlyBinaryRec ¬ [      partialBinary: PartialBinary[      task: task, addr: val],      destMI: CurrentMI[dest: LabelRec[labeled[hashEntryPtr.ptr.labelseqnum]]],      last: FALSE, sa: TRUE];    [] ¬ Stream.PutBlock[TmFile.ebStream, ebrBlock];    };  -- end ProcST  PutOutSymbol: PROC [hptr: HashEntryPtr] = {    lsr: LabelIntRec;    lsrBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[LONG[@lsr]], startIndex: 0,      stopIndexPlusOne: Environment.bytesPerWord*SIZE[LabelIntRec]];    lsr ¬ LabelIntRec[      export: hptr­.ptr­.export, import: hptr­.ptr­.import,      incons: hptr­.ptr­.incons, found: hptr­.ptr­.found,      target: hptr­.ptr­.target, needsCycle: hptr­.ptr­.needsCycle,      isCycle: hptr­.ptr­.isCycle, labIndex: hptr­.ptr­.labelseqnum,      length: hptr­.key.length, miIndex: hptr­.ptr­.miseqnum];    IF hptr­.ptr­.needsfromcX THEN lsr.needsCycle ¬ cX;    [] ¬ Stream.PutBlock[TmFile.siStream, lsrBlock];    [] ¬ Stream.PutBlock[      TmFile.siStream, Environment.Block[      blockPointer: LOOPHOLE[@hptr­.key.text], startIndex: 0,      stopIndexPlusOne: hptr­.key.length]];    };  -- end PutOutSymbol  SetDest: PUBLIC PROC [lab: LONG STRING, and: CARDINAL, or: CARDINAL] = {    hP: HashEntryPtr;    curMI.andMask ¬ and;    curMI.orMask ¬ or;    IF lab.length = 0 THEN {      curMI.dest ¬ LabelRec[absolute[and]]; extCurDestField ¬ TRUE; }    ELSE {      IF EqualString[lab, "$"L] THEN RETURN;      hP ¬ ProcessDestLabel[lab];      curMI.dest ¬ LabelRec[labeled[hP­.ptr­.labelseqnum]];      hP­.ptr­.target ¬ TRUE;      };    };  -- end SetDest  END...    -- Log  -- 16-Jul-82 13:25:37 - ETN        - TrinityMass Version 1   -- 28-Oct-82 10:35:41 - ETN        - Add err for multiple SA per task   -- 22-Jul-83 19:18:46 - JAC        - Use GetStmtSpace and Delete ReleaseLTSpace
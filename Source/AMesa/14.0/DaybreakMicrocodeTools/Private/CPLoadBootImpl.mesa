-- Copyright (C) 1985 by Xerox Corporation. All rights reserved.-- CPLoadBootImpl.mesa, JAC, 31-May-85  9:56:27DIRECTORY  Boot USING [bootPhysicalVolume, countGermVM, pageGerm, pRequest, Request],  BootFile USING [    currentVersion, MapEntry, Header, maxEntriesPerHeader, maxEntriesPerTrailer,    Trailer],  DeviceTypes USING [anyPilotDisk],  Environment USING [bytesPerPage, PageCount, PageNumber, wordsPerPage],  Format USING [CR, Line, LongDecimal, StringProc, Text],  Heap USING [systemZone],  Inline USING [LowByte, LowHalf],  MStream USING [EndOf, Error, ReadOnly],  PageMap USING [],  PilotSwitches USING [hang],  Stream USING [Delete, EndOfStream, GetBlock, Handle],  String USING [AppendExtensionIfNeeded, CopyToNewString],  System USING [GetClockPulses, Pulses, PulsesToMicroseconds],  Space USING [LongPointerFromPage, PageFromLongPointer],    CPDefs USING [MapEntry, mapOffset, RealMemory, VirturalMemory],  CPCommand USING [Error, RefreshWindow],  CPKernelDefs USING [Error, WriteMemoryBlock]; CPLoadBootImpl: PROGRAM  IMPORTS    Format, Heap, Inline, MStream, Stream, String, System,    CPCommand, CPKernelDefs, Space  EXPORTS CPCommand =  BEGIN  z: UNCOUNTED ZONE = Heap.systemZone;    -- Daybreak physical memory layout  -- func	octal		decimal		  -- display	[0..400)	[0..256)	  -- nothing	[400..2000)	[256..1024)  -- map	[2000..2400)	[1024..1280)  -- free	[2400..2440)	[1280..1312)  -- IORegion	[2440..2540)	[1312..1376)  -- free	[2540..)	[1376..)        -- The germ goes into virtural [1..n).  -- The rest of free memory is mapped behind the germ.  -- After the germ loads a boot file, free memory is behind the boot file.  RealPageNumber: TYPE = CARDINAL;    maxWords: CARDINAL = 256;  mapPagesCount:  CARDINAL = 256;  ioRegionPageNumber:  RealPageNumber = 1312;  ioRegionPagesCount:  CARDINAL = 64;  firstFreePage:  RealPageNumber = 1280;  ioRegionVirtPage:  CARDINAL = 0C0H;  countRealPages: CARDINAL = 2048;    tempCountGermVM: CARDINAL = Inline.LowHalf[Boot.countGermVM];  firstMapPage: PUBLIC RealPageNumber ¬ 400H;  realMapLoc: LONG POINTER = Space.LongPointerFromPage[firstMapPage];  realPageForGerm: CARDINAL = firstFreePage+(256-tempCountGermVM);  virtualPageForGerm: LONG CARDINAL = Boot.pageGerm;  virtualPageForPRequest: LONG CARDINAL = Space.PageFromLongPointer[Boot.pRequest];  realPageForPRequest: CARDINAL = realPageForGerm + Inline.LowHalf[virtualPageForPRequest - virtualPageForGerm];  LoadGerm: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, file: LONG STRING] =    BEGIN    filename: LONG STRING;    stream: Stream.Handle;    filename ¬ String.CopyToNewString[file, z];    [] ¬ String.AppendExtensionIfNeeded[@filename, "germ"L, z];    Format.Text[log, "Loading Germ from "L, arg];    Format.Text[log, filename, arg];    Format.Line[log, "."L, arg];    stream ¬ MStream.ReadOnly[filename, [] ! MStream.Error =>      ERROR CPCommand.Error["Can't read that file"] ];    LoadGermFromStream[log, arg, stream !      UNWIND => BEGIN Stream.Delete[stream]; z.FREE[@filename]; END ];    Stream.Delete[stream];    z.FREE[@filename];    CPCommand.RefreshWindow[];    END;   LoadGermFromStream: PROCEDURE [log: Format.StringProc, arg: LONG POINTER, stream: Stream.Handle] =    BEGIN ENABLE      BEGIN      Stream.EndOfStream => ERROR CPCommand.Error["Truncated germ file"L];      CPKernelDefs.Error => ERROR CPCommand.Error[reason];      END;    buffer: ARRAY [0..Environment.wordsPerPage) OF WORD;    start, stop: System.Pulses;    ms: LONG CARDINAL;    words: LONG CARDINAL ¬ 0;    pages: CARDINAL ¬ countRealPages-mapPagesCount-ioRegionPagesCount-256; -- map, ioregion, display    blocks: CARDINAL ¬ 0;    page: CARDINAL ¬ Inline.LowHalf[virtualPageForGerm];    from: CPDefs.VirturalMemory ¬ LOOPHOLE[Boot.pageGerm*Environment.wordsPerPage];    me: CPDefs.MapEntry;    rp: CARDINAL;    WriteMem: PROCEDURE [ra: LONG POINTER, p: LONG POINTER, nwords: CARDINAL] =      BEGIN      CPKernelDefs.WriteMemoryBlock[to: ra, count: nwords, data: p];      blocks ¬ blocks + 1;      words ¬ words + nwords;      END;    ResetMap[];    MapIORegion[log, arg];    start ¬ System.GetClockPulses[];    DO      bytes: CARDINAL;      to: CPDefs.RealMemory;      IF MStream.EndOf[stream] THEN EXIT;      [bytes, , ] ¬ Stream.GetBlock[        sH: stream,        block: [	  blockPointer: LOOPHOLE[LONG[@buffer]],	  startIndex: 0,          stopIndexPlusOne: Environment.bytesPerPage]];      IF bytes # Environment.bytesPerPage THEN        ERROR CPCommand.Error["Truncated Germ File"L];      to ¬ MapGermPage[from];      rp ¬ CARDINAL[Space.PageFromLongPointer[to]];      me ¬ CPDefs.MapEntry[          rpLow: CARDINAL[rp MOD 400B], r: FALSE, d: FALSE, w: FALSE, rpHigh: CARDINAL[rp/400B]];      CPKernelDefs.WriteMemoryBlock[realMapLoc + page, SIZE[CPDefs.MapEntry], @me];      WriteMem[ra: to, p: @buffer, nwords: Environment.wordsPerPage];      pages ¬ pages - 1;      page ¬ page + 1;      from ¬ from + Environment.wordsPerPage;      ENDLOOP;    stop ¬ System.GetClockPulses[];    ms ¬ System.PulsesToMicroseconds[[stop - start]]/1000;    Info[log, arg, ms, words, blocks];    MapRemainingPages[log, arg, page, pages];    END;	  LoadBootFile: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, file: LONG STRING, pagesOrbanks: CARDINAL] =    BEGIN    filename: LONG STRING;    stream: Stream.Handle;    pages: Environment.PageCount;    filename ¬ String.CopyToNewString[file, z];    [] ¬ String.AppendExtensionIfNeeded[@filename, "boot"L, z];    Format.Text[log, "Loading CP boot file from "L, arg];    Format.Text[log, filename, arg];    Format.Line[log, "."L, arg];    stream ¬ MStream.ReadOnly[filename, [] ! MStream.Error =>      ERROR CPCommand.Error["Can't read that file"] ];          pages ¬ countRealPages;  --ignore display memory        LoadBootFileFromStream[log, arg, stream, pages !      UNWIND => BEGIN Stream.Delete[stream]; z.FREE[@filename]; END ];    Stream.Delete[stream];    z.FREE[@filename];    CPCommand.RefreshWindow[];    END;      LoadBootFileFromStream: PROCEDURE [log: Format.StringProc, arg: LONG POINTER, stream: Stream.Handle, pages: Environment.PageCount] =    BEGIN ENABLE      BEGIN      Stream.EndOfStream => ERROR CPCommand.Error["Truncated germ file"L];      CPKernelDefs.Error => ERROR CPCommand.Error[reason];      END;    headerStorage: ARRAY [0..Environment.wordsPerPage) OF WORD;    header: LONG POINTER TO BootFile.Header = LOOPHOLE[LONG[@headerStorage]];    bufferStorage: ARRAY [0..Environment.wordsPerPage) OF WORD;    buffer: LONG POINTER = @bufferStorage;    realPage: Environment.PageCount ¬ FirstUsablePage[];    WriteMem: PROCEDURE [ra: LONG POINTER, p: LONG POINTER, nwords: CARDINAL] =      BEGIN      CPKernelDefs.WriteMemoryBlock[to: ra, count: nwords, data: p];      blocks ¬ blocks + 1;      words ¬ words + nwords;      END;    GetRealPage: PROCEDURE [vp: Environment.PageCount] RETURNS [rp: Environment.PageCount] =      BEGIN      IF pages = 0 THEN ERROR CPCommand.Error["Oops, ran out of pages"L];      rp ¬ realPage;      realPage ¬ realPage + 1;      SELECT realPage FROM        firstMapPage => realPage ¬ realPage + mapPagesCount;        ioRegionPageNumber => realPage ¬ realPage + ioRegionPagesCount;        realPageForGerm => realPage ¬ realPage + tempCountGermVM;	ENDCASE => NULL;      pages ¬ pages - 1;      END;    start, stop: System.Pulses;    ms: LONG CARDINAL;    words, blocks: LONG CARDINAL ¬ 0;    thisRealPage: Environment.PageCount;    lastUsedVMPage: Environment.PageCount ¬ 0;    countData, countGroup: LONG CARDINAL;    entries: LONG POINTER TO ARRAY [0..0) OF BootFile.MapEntry;        start ¬ System.GetClockPulses[];        ResetMap[];        IF pages <= (mapPagesCount + tempCountGermVM + ioRegionPagesCount) THEN      ERROR CPCommand.Error["Not enough pages for map (and such)"L];    pages ¬ pages - mapPagesCount - ioRegionPagesCount - tempCountGermVM;  -- Map, IORegion, Germ    MapIORegion[log, arg];    --pages ¬ pages - 256;  my page count doesn't include the display bank    [] ¬ Stream.GetBlock[       sH: stream,       block: [         blockPointer: LOOPHOLE[header], startIndex: 0,         stopIndexPlusOne: Environment.bytesPerPage]];    IF header.version # BootFile.currentVersion THEN      ERROR CPCommand.Error["not (current) bootfile"L];    FOR rp: CARDINAL IN [realPageForGerm..realPageForPRequest] DO  -- initialize the germ's SD vector pages      me: CPDefs.MapEntry;      me ¬ CPDefs.MapEntry[  -- Germ's SD        rpLow: rp MOD 400B, r: TRUE, d: TRUE, w: FALSE, rpHigh: rp/400B];      CPKernelDefs.WriteMemoryBlock[realMapLoc + virtualPageForGerm + (rp - realPageForGerm), SIZE[CPDefs.MapEntry], @me];    ENDLOOP;    BEGIN  -- write pRequest    pRequestOffset: WORD = Inline.LowByte[Inline.LowHalf[Boot.pRequest]];    pRequest: LONG POINTER TO Boot.Request =       Space.LongPointerFromPage[realPageForPRequest] + pRequestOffset;    request: Boot.Request;    request ¬ [      action: Boot.bootPhysicalVolume,      location: [deviceType: DeviceTypes.anyPilotDisk, deviceOrdinal: 0, vp: ],      pStartListHeader: header.pStartListHeader,      inLoadMode: ,      session: ];    request.switches[PilotSwitches.hang] ¬ down;    WriteMem[ra: pRequest, p: @request, nwords: SIZE[Boot.Request]];    END;    IF (countData ¬ header.countData) > pages THEN      ERROR CPCommand.Error["Not enough pages for Boot file"L];    countGroup ¬ MIN[countData, BootFile.maxEntriesPerHeader];    entries ¬ LOOPHOLE[@header.entries];    DO      trailer: LONG POINTER TO BootFile.Trailer = LOOPHOLE[header];      FOR i: LONG CARDINAL IN [0..countGroup) DO        OPEN bfe: entries[IF i > LAST[CARDINAL] THEN ERROR ELSE CARDINAL[i]];        me: CPDefs.MapEntry;        [] ¬ Stream.GetBlock[          sH: stream,          block: [            blockPointer: buffer,	    startIndex: 0,            stopIndexPlusOne: Environment.bytesPerPage]];        thisRealPage ¬ GetRealPage[bfe.virtual];        << Perhaps a check should be placed in here for a large "thisRealPage">>        me ¬ CPDefs.MapEntry[          rpLow: CARDINAL[thisRealPage MOD 400B], r: bfe.flags.referenced,          d: bfe.flags.dirty, w: bfe.flags.readonly, rpHigh: CARDINAL[thisRealPage/400B]];        CPKernelDefs.WriteMemoryBlock[realMapLoc + bfe.virtual, SIZE[CPDefs.MapEntry], @me];        WriteMem[          ra: Space.LongPointerFromPage[thisRealPage],          p: buffer, nwords: Environment.wordsPerPage];        lastUsedVMPage ¬ MAX[lastUsedVMPage, bfe.virtual];        ENDLOOP;      IF (countData ¬ countData - countGroup) = 0 THEN EXIT;      countGroup ¬ MIN[countData, BootFile.maxEntriesPerTrailer];      [] ¬ Stream.GetBlock[        sH: stream,        block: [          blockPointer: LOOPHOLE[trailer],	  startIndex: 0,          stopIndexPlusOne: Environment.bytesPerPage]];      IF header.version # BootFile.currentVersion THEN        ERROR CPCommand.Error["bad trailer version?"L];      entries ¬ LOOPHOLE[@trailer.entries];      ENDLOOP;    -- Put any extra memory in map following last used mapped VM    WHILE pages > 0 DO      me: CPDefs.MapEntry;      lastUsedVMPage ¬ lastUsedVMPage + 1;      thisRealPage ¬ GetRealPage[lastUsedVMPage];      << Perhaps a check should be placed in here for a large "thisRealPage">>      me ¬ CPDefs.MapEntry[        rpLow: CARDINAL[thisRealPage MOD 400B], r: FALSE, d: FALSE,        w: FALSE, rpHigh: CARDINAL[thisRealPage/400B]];      CPKernelDefs.WriteMemoryBlock[realMapLoc + lastUsedVMPage, SIZE[CPDefs.MapEntry], @me];      ENDLOOP;    stop ¬ System.GetClockPulses[];    ms ¬ System.PulsesToMicroseconds[[stop - start]]/1000;    Info[log, arg, ms, words, blocks];    END;  ResetMap: PROCEDURE =    BEGIN ENABLE UNWIND => NULL;    -- not referenced & dirty & write-protect => vacant    from: Environment.PageCount ¬ firstMapPage;    vacantPage: ARRAY [0..Environment.wordsPerPage) OF CPDefs.MapEntry       ¬ ALL[CPDefs.MapEntry[rpLow: 0, r: FALSE, d: TRUE, w: TRUE, rpHigh: 0]];    vacantPagePtr: LONG POINTER ¬ @vacantPage;    FOR offset: LONG CARDINAL IN [0..mapPagesCount) DO      CPKernelDefs.WriteMemoryBlock[realMapLoc + offset*256, Environment.wordsPerPage, vacantPagePtr ! CPKernelDefs.Error => CPCommand.Error[reason] ];      ENDLOOP;    END;  MapIORegion: PROCEDURE [log: Format.StringProc, arg: LONG POINTER]  =    BEGIN    MapEntryArray: TYPE = ARRAY [0..ioRegionPagesCount) OF CPDefs.MapEntry;    meArray: MapEntryArray;    start, stop: System.Pulses;    ms: LONG CARDINAL;    start ¬ System.GetClockPulses[];    FOR i: CARDINAL IN [0..ioRegionPagesCount) DO  --map the IORegion      meArray[i] ¬ CPDefs.MapEntry[        rpLow: ioRegionPageNumber MOD 400B + i,        r: TRUE, d: TRUE, w: FALSE,	rpHigh: ioRegionPageNumber/400B];      ENDLOOP;    CPKernelDefs.WriteMemoryBlock[      to: LOOPHOLE[CPDefs.mapOffset+ioRegionVirtPage],      count: SIZE[MapEntryArray], data: @meArray];    stop ¬ System.GetClockPulses[];    ms ¬ System.PulsesToMicroseconds[[stop - start]]/1000;    Info[log, arg, ms, SIZE[MapEntryArray], 1];    END;  MapEntriesArray: TYPE = RECORD [    ARRAY [0..maxWords) OF CPDefs.MapEntry];    MapRemainingPages: PROCEDURE [log: Format.StringProc, arg: LONG POINTER, page, pages: CARDINAL]  =    BEGIN    rp: CARDINAL ¬ CARDINAL[      Space.PageFromLongPointer[        MapGermPage[LOOPHOLE[LONG[page]*Environment.wordsPerPage]]]];    me: MapEntriesArray;    index: CARDINAL ¬ 0;    startPage: CARDINAL;    start, stop: System.Pulses;    ms: LONG CARDINAL;    words, blocks, wordsStored: LONG CARDINAL ¬ 0;    start ¬ System.GetClockPulses[];    IF page = ioRegionVirtPage THEN page ¬ page + ioRegionPagesCount;    startPage ¬ page;    THROUGH [0..pages) DO       IF index = maxWords THEN {        blocks ¬ blocks + 1;	index ¬ 0;	CPKernelDefs.WriteMemoryBlock[	  to:LOOPHOLE[CPDefs.mapOffset+startPage+wordsStored],	  count:maxWords*SIZE[CPDefs.MapEntry], data: @me[0]];	  wordsStored ¬ wordsStored + maxWords};      me[index] ¬ CPDefs.MapEntry[          rpLow: rp MOD 400B, r: FALSE, d: FALSE, w: FALSE, rpHigh: rp/400B];      words ¬ words + SIZE[CPDefs.MapEntry];      index ¬ index + 1;      page ¬ page + 1;      rp ¬ rp + 1;      IF page = ioRegionVirtPage THEN {        CPKernelDefs.WriteMemoryBlock[          to: LOOPHOLE[CPDefs.mapOffset+startPage+wordsStored],          count: index*SIZE[CPDefs.MapEntry], data: @me[0]];        page ¬ page + ioRegionPagesCount;	blocks ¬ blocks + 1;	startPage ¬ page;	wordsStored ¬ 0;	index ¬ 0};        IF rp = ioRegionPageNumber THEN rp ¬ rp + ioRegionPagesCount;      ENDLOOP;    IF index # 0 THEN      CPKernelDefs.WriteMemoryBlock[        to: LOOPHOLE[CPDefs.mapOffset+startPage+wordsStored],        count: index*SIZE[CPDefs.MapEntry], data: @me[0]];    stop ¬ System.GetClockPulses[];    ms ¬ System.PulsesToMicroseconds[[stop - start]]/1000;    Info[log, arg, ms, words, blocks];    END;  MapGermPage: PROCEDURE [virtural: CPDefs.VirturalMemory] RETURNS [real: CPDefs.RealMemory] =    BEGIN    page: Environment.PageCount ¬ Space.PageFromLongPointer[virtural];    IF page ~IN [Boot.pageGerm..tempCountGermVM) THEN      ERROR CPCommand.Error["Germ doesn't fit in allocated space"L];    RETURN[Space.LongPointerFromPage[realPageForGerm+page-Boot.pageGerm]];    END;     FirstUsablePage: PROCEDURE RETURNS [Environment.PageCount] =    BEGIN      RETURN[firstFreePage];    END;      Info: PROCEDURE [log: Format.StringProc, arg: LONG POINTER, ms, words, blocks: LONG CARDINAL] =    BEGIN    Format.Text[log, "It took "L, arg];    Format.LongDecimal[log, ms, arg];    Format.Text[log, " ms to load "L, arg];    Format.LongDecimal[log, words, arg];    Format.Text[log, " words in "L, arg];    Format.LongDecimal[log, blocks, arg];    Format.Text[log, " blocks."L, arg];    IF ms # 0 THEN      BEGIN      Format.Text[log, " ("L, arg];      Format.LongDecimal[log, words*16*1000/ms, arg];      Format.Text[log, " bits/sec)"L, arg];      END;    Format.CR[log, arg];    END;    END.  -- Log of last edits-- JAC	30-May-85 16:42:36	CP renamed to CPDefs-- JAC	31-May-85  9:46:06	CPKernel renamed to CPKernelDefs
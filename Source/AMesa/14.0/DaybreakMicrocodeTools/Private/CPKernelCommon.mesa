-- Copyright (C) 1985  by Xerox Corporation. All rights reserved.-- Last edit by JAC	 7-Jun-85 12:26:52	copyrighted -- CPKernelCommon.mesa, JoM    , 6-Feb-85 14:40:45DIRECTORY  Environment USING [LongNumber],  Inline USING [BITAND, HighHalf, LowHalf],  CP USING [    Map, RealMemory, RReg, VirturalMemory],  CPKernel USING [machine, mapOffset, ReadRealMemory, ReadRH, ReadRReg, WriteRealMemory, WriteRH, WriteRReg],  CPKernelConstants,  CPKernelOps USING [ReadRealMemoryInternal, WriteRealMemoryInternal],  IOPKernelOps USING [InitializeLock, lock];CPKernelCommon: MONITOR LOCKS IOPKernelOps.lock  IMPORTS    Inline, CPKernel, CPKernelOps, IOPKernelOps  EXPORTS CPKernel, CPKernelOps =  BEGIN OPEN CPKernelConstants;  Error: PUBLIC ERROR [reason: LONG STRING] = CODE;  ReadRAndRH: PUBLIC PROCEDURE [r: CP.RReg] RETURNS [data: LONG POINTER] =    BEGIN    temp: Environment.LongNumber;    temp.high _ CPKernel.ReadRH[r];    temp.low _ CPKernel.ReadRReg[r];    RETURN[temp.lp];    END;  WriteRAndRH: PUBLIC PROCEDURE [r: CP.RReg, data: LONG POINTER] =    BEGIN    CPKernel.WriteRH[r, Inline.HighHalf[data]];    CPKernel.WriteRReg[r, Inline.LowHalf[data]];    END;  ReadMap: PUBLIC ENTRY PROCEDURE [map: CP.Map] RETURNS [WORD] =    BEGIN ENABLE UNWIND => NULL;    RETURN[ReadMapInternal[map]];    END;  ReadMapInternal: INTERNAL PROCEDURE [map: CP.Map] RETURNS [WORD] =    BEGIN    IF map ~IN CP.Map THEN AddressOutOfRange[];    RETURN[CPKernelOps.ReadRealMemoryInternal[LOOPHOLE[map + CPKernel.mapOffset]]];    END;  WriteMap: PUBLIC ENTRY PROCEDURE [map: CP.Map, data: WORD] =    BEGIN ENABLE UNWIND => NULL;    IF map ~IN CP.Map THEN AddressOutOfRange[];    CPKernelOps.WriteRealMemoryInternal[LOOPHOLE[map + CPKernel.mapOffset], data];    END;  ReadRealMemory: PUBLIC ENTRY PROCEDURE [real: CP.RealMemory] RETURNS [data: WORD] =    BEGIN ENABLE UNWIND => NULL;    RETURN[CPKernelOps.ReadRealMemoryInternal[real]];    END;  WriteRealMemory: PUBLIC ENTRY PROCEDURE [real: CP.RealMemory, data: WORD] =    BEGIN ENABLE UNWIND => NULL;    CPKernelOps.WriteRealMemoryInternal[real, data];    END;  ReadVirturalMemory: PUBLIC PROCEDURE [virt: CP.VirturalMemory] RETURNS [WORD] =    BEGIN    RETURN[CPKernel.ReadRealMemory[MapAddress[virt]]];    END;  WriteVirturalMemory: PUBLIC PROCEDURE [virt: CP.VirturalMemory, data: WORD] =    BEGIN    CPKernel.WriteRealMemory[MapAddress[virt], data];    END;  MapAddress: ENTRY PROCEDURE [virt: CP.VirturalMemory] RETURNS [CP.RealMemory] =    BEGIN ENABLE UNWIND => NULL;    a: LONG CARDINAL _ LOOPHOLE[virt];    page: CARDINAL = Inline.LowHalf[a/256];    offset: CARDINAL = Inline.LowHalf[a MOD 256];    mapEntry: MACHINE DEPENDENT RECORD [      pageLow, pageHigh: [0..0FFH]];    mapEntry _ LOOPHOLE[ReadMapInternal[page]];    SELECT CPKernel.machine FROM      dlion => IF Inline.BITAND[mapEntry, 60H] = 60H        THEN ERROR Error["Map entry is marked invalid"L]	ELSE mapEntry _ Inline.BITAND[mapEntry, 0FF0FH];      dicentra => NULL;      daybreak, daisy => IF Inline.BITAND[mapEntry, 60H] = 60H        THEN ERROR Error["Map entry is marked invalid"L]	ELSE mapEntry _ Inline.BITAND[mapEntry, 0FF1FH];      ENDCASE => ERROR;    a _ mapEntry.pageHigh*10000H + mapEntry.pageLow*256 + offset;    RETURN[LOOPHOLE[a]];    END;  AddressOutOfRange: PUBLIC PROCEDURE =    BEGIN    ERROR Error["Address out of Range"L];    END;  DataOutOfRange: PUBLIC PROCEDURE =    BEGIN    ERROR Error["Data out of Range"L];    END;  CantReadThatRegister: PUBLIC PROCEDURE =    BEGIN    ERROR Error["Can't read that register"L];    END;  CantWriteThatRegister: PUBLIC PROCEDURE =    BEGIN    ERROR Error["Can't write that register"L];    END;  IOPKernelOps.InitializeLock[];  END.
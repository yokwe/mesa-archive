-- Copyright (C) 1983, 1985  by Xerox Corporation. All rights reserved. -- Last edit by JAC 31-May-85 10:50:14 -- from CPSymboler.mesa, HGM, 12-Nov-83 22:51:27DIRECTORY  Heap USING [Create],  Inline USING [LowHalf],  String USING [AppendChar, AppendLongNumber, AppendNumber, AppendString],    CPDefs USING [    Bank, BankAndWordsPerBank, Cycle, IOReg, Link, Map, OtherReg,    RealCS, RealMemory, RReg, Task, UReg, VirturalMemory, wordsPerBank],  CPMIFormat USING [MI],  CPSymbl USING [nullRealCS, nullVirturalCS, Symbol, VirturalCS],  SymbolHash USING [    Create, EnumerateEntries, GetInfo, GetString,    Handle, Hash, Insert, Lookup, nullHash, PutInfo, Reset];CPSymbolImpl: MONITOR  IMPORTS Heap, Inline, String, SymbolHash  EXPORTS CPSymbl =  BEGIN    WordInBank: TYPE = [0..CPDefs.wordsPerBank);  z: UNCOUNTED ZONE = Heap.Create[10];    Error: PUBLIC ERROR [reason: LONG STRING] = CODE;    csSymbols: SymbolHash.Handle ¬ SymbolHash.Create[100];  rRegSymbols: SymbolHash.Handle ¬ SymbolHash.Create[2];  rHSymbols: SymbolHash.Handle ¬ SymbolHash.Create[2];  uRegSymbols: SymbolHash.Handle ¬ SymbolHash.Create[10];    csInverse: ARRAY CPDefs.Bank OF LONG POINTER TO ARRAY WordInBank OF SymbolHash.Hash ¬ ALL[NIL];  rRegInverse: LONG POINTER TO ARRAY CPDefs.RReg OF SymbolHash.Hash ¬ z.NEW[ARRAY CPDefs.RReg OF SymbolHash.Hash];  rHInverse: LONG POINTER TO ARRAY CPDefs.RReg OF SymbolHash.Hash ¬ z.NEW[ARRAY CPDefs.RReg OF SymbolHash.Hash];  uRegInverse: LONG POINTER TO ARRAY CPDefs.UReg OF SymbolHash.Hash ¬ z.NEW[ARRAY CPDefs.UReg OF SymbolHash.Hash];    ClearSymbolTable: PUBLIC ENTRY PROCEDURE =    BEGIN    FOR bank: CPDefs.Bank IN CPDefs.Bank DO      IF info[bank] = NIL THEN LOOP;      info[bank]­ ¬ ALL [[FALSE, , , ]];      ENDLOOP;    FOR bank: CPDefs.Bank IN CPDefs.Bank DO      IF csInverse[bank] = NIL THEN LOOP;      csInverse[bank]­ ¬ ALL[SymbolHash.nullHash];      ENDLOOP;    rRegInverse­ ¬ ALL[SymbolHash.nullHash];    rHInverse­ ¬ ALL[SymbolHash.nullHash];    uRegInverse­ ¬ ALL[SymbolHash.nullHash];    SymbolHash.Reset[csSymbols];    SymbolHash.Reset[rRegSymbols];    SymbolHash.Reset[rHSymbols];    SymbolHash.Reset[uRegSymbols];    END;          AddCSSymbol: PUBLIC ENTRY PROCEDURE [tag: LONG STRING, virt: CPSymbl.VirturalCS] =    BEGIN ENABLE UNWIND => NULL;    hash: SymbolHash.Hash ¬ SymbolHash.Lookup[csSymbols, tag];    bank: CPDefs.Bank;    wordInBank: WordInBank;    IF hash # SymbolHash.nullHash THEN      BEGIN      IF virt = SymbolHash.GetInfo[csSymbols, hash] THEN RETURN;  -- Ignore duplicates      ERROR Error["Duplicate CS Symbol"L];      END;    hash ¬ SymbolHash.Insert[csSymbols, tag];    SymbolHash.PutInfo[csSymbols, hash, virt];    [bank, wordInBank] ¬ SplitVirt[virt];    BeSureInverseExists[bank, wordInBank];    csInverse[bank][wordInBank] ¬ hash;    END;      AddRRegSymbol: PUBLIC ENTRY PROCEDURE [tag: LONG STRING, r: CPDefs.RReg] =    BEGIN ENABLE UNWIND => NULL;    hash: SymbolHash.Hash ¬ SymbolHash.Lookup[rRegSymbols, tag];    IF hash # SymbolHash.nullHash THEN      BEGIN      IF r = SymbolHash.GetInfo[rRegSymbols, hash] THEN RETURN;  -- Ignore duplicates      ERROR Error["Duplicate RReg Symbol"L];      END;    hash ¬ SymbolHash.Insert[rRegSymbols, tag];    SymbolHash.PutInfo[rRegSymbols, hash, r];    rRegInverse[r] ¬ hash;    END;      AddRHSymbol: PUBLIC ENTRY PROCEDURE [tag: LONG STRING, r: CPDefs.RReg] =    BEGIN ENABLE UNWIND => NULL;    hash: SymbolHash.Hash ¬ SymbolHash.Lookup[rHSymbols, tag];    IF hash # SymbolHash.nullHash THEN      BEGIN      IF r = SymbolHash.GetInfo[rHSymbols, hash] THEN RETURN;  -- Ignore duplicates      ERROR Error["Duplicate RH Symbol"L];      END;    hash ¬ SymbolHash.Insert[rHSymbols, tag];    SymbolHash.PutInfo[rHSymbols, hash, r];    rHInverse[r] ¬ hash;    END;      AddURegSymbol: PUBLIC ENTRY PROCEDURE [tag: LONG STRING, u: CPDefs.UReg] =    BEGIN ENABLE UNWIND => NULL;    hash: SymbolHash.Hash ¬ SymbolHash.Lookup[uRegSymbols, tag];    IF hash # SymbolHash.nullHash THEN      BEGIN      IF u = SymbolHash.GetInfo[uRegSymbols, hash] THEN RETURN;  -- Ignore duplicates      ERROR Error["Duplicate UReg Symbol"L];      END;    hash ¬ SymbolHash.Insert[uRegSymbols, tag];    SymbolHash.PutInfo[uRegSymbols, hash, u];    uRegInverse[u] ¬ hash;    END;    LookupInCSTable: PUBLIC ENTRY PROCEDURE [tag: LONG STRING] RETURNS [ok: BOOLEAN, virt: CPSymbl.VirturalCS] =    BEGIN    hash: SymbolHash.Hash ¬ SymbolHash.Lookup[csSymbols, tag];    bank: CPDefs.Bank;    wordInBank: WordInBank;    IF hash = SymbolHash.nullHash THEN RETURN[FALSE, ];    ok ¬ TRUE;    virt ¬ Inline.LowHalf[SymbolHash.GetInfo[csSymbols, hash]];    [bank, wordInBank] ¬ SplitVirt[virt];    BeSureInverseExists[bank, wordInBank];    csInverse[bank][wordInBank] ¬ hash;    END;      LookupInRRegTable: PUBLIC ENTRY PROCEDURE [tag: LONG STRING] RETURNS [ok: BOOLEAN, r: CPDefs.RReg] =    BEGIN    hash: SymbolHash.Hash ¬ SymbolHash.Lookup[rRegSymbols, tag];    IF hash = SymbolHash.nullHash THEN RETURN[FALSE, ];    ok ¬ TRUE;    r ¬ Inline.LowHalf[SymbolHash.GetInfo[rRegSymbols, hash]];    rRegInverse[r] ¬ hash;    END;      LookupInRHTable: PUBLIC ENTRY PROCEDURE [tag: LONG STRING] RETURNS [ok: BOOLEAN, r: CPDefs.RReg] =    BEGIN    hash: SymbolHash.Hash ¬ SymbolHash.Lookup[rHSymbols, tag];    IF hash = SymbolHash.nullHash THEN RETURN[FALSE, ];    ok ¬ TRUE;    r ¬ Inline.LowHalf[SymbolHash.GetInfo[rHSymbols, hash]];    rHInverse[r] ¬ hash;    END;      LookupInURegTable: PUBLIC ENTRY PROCEDURE [tag: LONG STRING] RETURNS [ok: BOOLEAN, u: CPDefs.UReg] =    BEGIN    hash: SymbolHash.Hash ¬ SymbolHash.Lookup[uRegSymbols, tag];    IF hash = SymbolHash.nullHash THEN RETURN[FALSE, ];    ok ¬ TRUE;    u ¬ Inline.LowHalf[SymbolHash.GetInfo[uRegSymbols, hash]];    uRegInverse[u] ¬ hash;    END;          AppendAllVirturalCS: PUBLIC PROCEDURE [s: LONG STRING, virturalCS: CPSymbl.VirturalCS] =    BEGIN    hit: BOOLEAN ¬ FALSE;    PrintMatches: PROCEDURE [hash: SymbolHash.Hash] =      BEGIN      IF SymbolHash.GetInfo[csSymbols, hash] # virturalCS THEN RETURN;      IF hit THEN String.AppendString[s, ", "L];      String.AppendString[s, SymbolHash.GetString[csSymbols, hash]];      hit ¬ TRUE;      END;    SymbolHash.EnumerateEntries[csSymbols, PrintMatches];    END;      AppendAllRReg: PUBLIC PROCEDURE [s: LONG STRING, r: CPDefs.RReg] =    BEGIN    hit: BOOLEAN ¬ FALSE;    PrintMatches: PROCEDURE [hash: SymbolHash.Hash] =      BEGIN      IF SymbolHash.GetInfo[rRegSymbols, hash] # r THEN RETURN;      IF hit THEN String.AppendString[s, ", "L];      String.AppendString[s, SymbolHash.GetString[rRegSymbols, hash]];      hit ¬ TRUE;      END;    SymbolHash.EnumerateEntries[rRegSymbols, PrintMatches];    END;  AppendAllRH: PUBLIC PROCEDURE [s: LONG STRING, r: CPDefs.RReg] =    BEGIN    hit: BOOLEAN ¬ FALSE;    PrintMatches: PROCEDURE [hash: SymbolHash.Hash] =      BEGIN      IF SymbolHash.GetInfo[rHSymbols, hash] # r THEN RETURN;      IF hit THEN String.AppendString[s, ", "L];      String.AppendString[s, SymbolHash.GetString[rHSymbols, hash]];      hit ¬ TRUE;      END;    SymbolHash.EnumerateEntries[rHSymbols, PrintMatches];    END;      AppendAllUReg: PUBLIC PROCEDURE [s: LONG STRING, u: CPDefs.UReg] =    BEGIN    hit: BOOLEAN ¬ FALSE;    PrintMatches: PROCEDURE [hash: SymbolHash.Hash] =      BEGIN      IF SymbolHash.GetInfo[uRegSymbols, hash] # u THEN RETURN;      IF hit THEN String.AppendString[s, ", "L];      String.AppendString[s, SymbolHash.GetString[uRegSymbols, hash]];      hit ¬ TRUE;      END;    SymbolHash.EnumerateEntries[uRegSymbols, PrintMatches];    END;      AppendSymbol: PUBLIC PROCEDURE [s: LONG STRING, symbol: CPSymbl.Symbol] =    BEGIN    WITH symbol SELECT FROM      tpc => AppendTpc[s, task];      link => AppendLink[s, link];      realCS => AppendRealCS[s, real];      virtCS => AppendVirturalCS[s, virt];      rReg => AppendRReg[s, r];      rH => AppendRH[s, r];      rAndRh => AppendRAndRh[s, r];      uReg => AppendUReg[s, u];      ioIn => AppendIOIn[s, io];      ioOut => AppendIOOut[s, io];      map => AppendMap[s, map];      real => AppendReal[s, real];      virt => AppendVirtural[s, virt];      other => AppendOther[s, other];      ENDCASE => ERROR;    END;  AppendTpc: PUBLIC PROCEDURE [s: LONG STRING, task: CPDefs.Task] =    BEGIN    String.AppendString[s, ".TPC "L];    AppendNumber[s, task];    END;      AppendLink: PUBLIC PROCEDURE [s: LONG STRING, link: CPDefs.Link] =    BEGIN    String.AppendString[s, "L"L];    String.AppendNumber[s, link, 16];    END;      AppendRealCS: PUBLIC PROCEDURE [s: LONG STRING, realCS: CPDefs.RealCS] =    BEGIN    String.AppendString[s, ".CR "L];    AppendNumber[s, realCS];    END;      AppendVirturalCS: PUBLIC PROCEDURE [s: LONG STRING, virturalCS: CPSymbl.VirturalCS] =    BEGIN    FOR i: CARDINAL IN [0..100) DO      hash: SymbolHash.Hash;      bank: CPDefs.Bank;      wordInBank: WordInBank;      IF virturalCS < i THEN EXIT;      [bank, wordInBank] ¬ SplitVirt[virturalCS - i];      IF csInverse[bank] = NIL THEN LOOP;      hash ¬ csInverse[bank][wordInBank];      IF hash # SymbolHash.nullHash THEN        BEGIN        String.AppendString[s, SymbolHash.GetString[csSymbols, hash]];	IF i > 0 THEN	  BEGIN	  String.AppendChar[s, '+];	  IF i > 9 THEN String.AppendChar[s, '0];	  String.AppendNumber[s, i, 16];	  END;        RETURN;        END;      ENDLOOP;    String.AppendString[s, ".CV "L];    AppendNumber[s, virturalCS];    END;      AppendRReg: PUBLIC PROCEDURE [s: LONG STRING, r: CPDefs.RReg] =    BEGIN    hash: SymbolHash.Hash;    IF r ~IN CPDefs.RReg THEN AddressOutOfRange[];    hash ¬ rRegInverse[r];    IF hash # SymbolHash.nullHash THEN      BEGIN      String.AppendString[s, SymbolHash.GetString[rRegSymbols, hash]];      RETURN;      END;    String.AppendString[s, ".R "L];    AppendNumber[s, r];    END;  AppendRH: PUBLIC PROCEDURE [s: LONG STRING, r: CPDefs.RReg] =    BEGIN    hash: SymbolHash.Hash;    IF r ~IN CPDefs.RReg THEN AddressOutOfRange[];    hash ¬ rHInverse[r];    IF hash # SymbolHash.nullHash THEN      BEGIN      String.AppendString[s, SymbolHash.GetString[rHSymbols, hash]];      RETURN;      END;    String.AppendString[s, ".RH "L];    AppendNumber[s, r];    END;      AppendRAndRh: PUBLIC PROCEDURE [s: LONG STRING, r: CPDefs.RReg] =    BEGIN    hash: SymbolHash.Hash;    IF r ~IN CPDefs.RReg THEN AddressOutOfRange[];    String.AppendChar[s, '$];    hash ¬ rRegInverse[r];    IF hash # SymbolHash.nullHash THEN      BEGIN      String.AppendString[s, SymbolHash.GetString[rRegSymbols, hash]];      RETURN;      END;    String.AppendString[s, ".R "L];    AppendNumber[s, r];    END;  AppendUReg: PUBLIC PROCEDURE [s: LONG STRING, u: CPDefs.UReg] =    BEGIN    hash: SymbolHash.Hash;    IF u ~IN CPDefs.UReg THEN AddressOutOfRange[];    hash ¬ uRegInverse[u];    IF hash # SymbolHash.nullHash THEN      BEGIN      String.AppendString[s, SymbolHash.GetString[uRegSymbols, hash]];      RETURN;      END;    String.AppendString[s, ".U "L];    AppendNumber[s, u];    END;      AppendIOIn: PUBLIC PROCEDURE [s: LONG STRING, io: CPDefs.IOReg] =    BEGIN    String.AppendString[s, ".IOIN "L];    AppendNumber[s, io];    END;      AppendIOOut: PUBLIC PROCEDURE [s: LONG STRING, io: CPDefs.IOReg] =    BEGIN    String.AppendString[s, ".IOOUT "L];    AppendNumber[s, io];    END;      AppendMap: PUBLIC PROCEDURE [s: LONG STRING, map: CPDefs.Map] =    BEGIN    String.AppendString[s, ".MAP "L];    AppendNumber[s, map];    END;      AppendReal: PUBLIC PROCEDURE [s: LONG STRING, real: CPDefs.RealMemory] =    BEGIN    String.AppendString[s, ".MR "L];    AppendLongNumber[s, real];    END;      AppendVirtural: PUBLIC PROCEDURE [s: LONG STRING, virtural: CPDefs.VirturalMemory] =    BEGIN    String.AppendString[s, ".MV "L];    AppendLongNumber[s, virtural];    END;    AppendOther: PUBLIC PROCEDURE [s: LONG STRING, other: CPDefs.OtherReg] =    BEGIN    SELECT other FROM      q => String.AppendString[s, ".Q"L];      ib => String.AppendString[s, ".IB"L];      pc16 => String.AppendString[s, ".PC16"L];      stackP => String.AppendString[s, ".STACKP"L];      ibPtr => String.AppendString[s, ".IBPTR"L];      mInt => String.AppendString[s, ".MINT"L];      ekErr => String.AppendString[s, ".EKERR"L];      ENDCASE => ERROR;    END;    AppendMI: PUBLIC PROCEDURE [s: LONG STRING, mi: CPMIFormat.MI] =    BEGIN    foo: POINTER = @mi;    FOR i: CARDINAL IN [0..SIZE[CPMIFormat.MI]) DO      temp: STRING = [4];      IF i # 0 THEN String.AppendChar[s, ' ];      String.AppendNumber[temp, (foo + i)­, 16];      FOR k: CARDINAL IN [temp.length..4) DO String.AppendChar[s, ' ]; ENDLOOP;      String.AppendString[s, temp];      ENDLOOP;    END;    AppendNumber: PUBLIC PROCEDURE [s: LONG STRING, w: UNSPECIFIED] =    BEGIN    IF w < 1000B THEN String.AppendChar[s, '0];    String.AppendNumber[s, w, 16];    END;   AppendLongNumber: PUBLIC PROCEDURE [s: LONG STRING, w: LONG UNSPECIFIED] =    BEGIN    IF w < 1000B THEN String.AppendChar[s, '0];    String.AppendLongNumber[s, w, 16];    END;          info: ARRAY CPDefs.Bank OF LONG POINTER TO ARRAY WordInBank OF Info ¬ ALL[NIL];  Info: TYPE = RECORD [    valid: BOOLEAN,    cycle: CPDefs.Cycle,    task: CPDefs.Task,    virtural: CPSymbl.VirturalCS];        AddToMap: PUBLIC ENTRY PROCEDURE [real: CPDefs.RealCS, virtural: CPSymbl.VirturalCS, cycle: CPDefs.Cycle, task: CPDefs.Task] =    BEGIN    bank: CPDefs.Bank;    wordInBank: WordInBank;    IF real ~IN CPDefs.RealCS THEN ERROR;    [bank, wordInBank] ¬ SplitReal[real];    BeSureInfoExists[bank, wordInBank];    info[bank][wordInBank] ¬ [TRUE, cycle, task, virtural];    END;    RealToVirturalCS: PUBLIC ENTRY PROCEDURE [real: CPDefs.RealCS]    RETURNS [CPSymbl.VirturalCS, CPDefs.Cycle, CPDefs.Task] =    BEGIN    p: LONG POINTER TO Info;    bank: CPDefs.Bank;    wordInBank: WordInBank;    [bank, wordInBank] ¬ SplitReal[real];    IF info[bank] = NIL THEN RETURN[CPSymbl.nullVirturalCS, , ];    p ¬ @info[bank][wordInBank];    IF ~p.valid THEN RETURN[CPSymbl.nullVirturalCS, , ];    RETURN[p.virtural, p.cycle, p.task];    END;      VirturalToRealCS: PUBLIC ENTRY PROCEDURE [virtural: CPSymbl.VirturalCS]    RETURNS [CPDefs.RealCS, CPDefs.Cycle, CPDefs.Task] =    BEGIN    FOR real: CPDefs.RealCS IN CPDefs.RealCS DO      p: LONG POINTER TO Info;      bank: CPDefs.Bank;      wordInBank: WordInBank;      [bank, wordInBank] ¬ SplitReal[real];      IF info[bank] = NIL THEN LOOP;      p ¬ @info[bank][wordInBank];      IF p.valid AND virtural = p.virtural THEN RETURN[real, p.cycle, p.task];      ENDLOOP;    RETURN[CPSymbl.nullRealCS, , ];    END;  EnumerateCSSymbols: PUBLIC --ENTRY-- PROCEDURE [proc: PROCEDURE [LONG STRING, CPSymbl.VirturalCS]] =    BEGIN ENABLE UNWIND => NULL;    CallHim: PROCEDURE [hash: SymbolHash.Hash] =      BEGIN      virt: CPSymbl.VirturalCS ¬ Inline.LowHalf[SymbolHash.GetInfo[csSymbols, hash]];      proc[SymbolHash.GetString[csSymbols, hash], virt];      END;    SymbolHash.EnumerateEntries[csSymbols, CallHim];    END;      EnumerateRRegSymbols: PUBLIC ENTRY PROCEDURE [proc: PROCEDURE [LONG STRING, CPDefs.RReg]] =    BEGIN ENABLE UNWIND => NULL;    CallHim: PROCEDURE [hash: SymbolHash.Hash] =      BEGIN      r: CPDefs.RReg ¬ Inline.LowHalf[SymbolHash.GetInfo[rRegSymbols, hash]];      proc[SymbolHash.GetString[rRegSymbols, hash], r];      END;    SymbolHash.EnumerateEntries[rRegSymbols, CallHim];    END;      EnumerateRHSymbols: PUBLIC ENTRY PROCEDURE [proc: PROCEDURE [LONG STRING, CPDefs.RReg]] =    BEGIN ENABLE UNWIND => NULL;    CallHim: PROCEDURE [hash: SymbolHash.Hash] =      BEGIN      r: CPDefs.RReg ¬ Inline.LowHalf[SymbolHash.GetInfo[rHSymbols, hash]];      proc[SymbolHash.GetString[rHSymbols, hash], r];      END;    SymbolHash.EnumerateEntries[rHSymbols, CallHim];    END;      EnumerateURegSymbols: PUBLIC ENTRY PROCEDURE [proc: PROCEDURE [LONG STRING, CPDefs.UReg]] =    BEGIN ENABLE UNWIND => NULL;    CallHim: PROCEDURE [hash: SymbolHash.Hash] =      BEGIN      u: CPDefs.UReg ¬ Inline.LowHalf[SymbolHash.GetInfo[uRegSymbols, hash]];      proc[SymbolHash.GetString[uRegSymbols, hash], u];      END;    SymbolHash.EnumerateEntries[uRegSymbols, CallHim];    END;      EnumerateMap: PUBLIC ENTRY PROCEDURE [    proc: PROCEDURE [CPDefs.RealCS, CPSymbl.VirturalCS, CPDefs.Cycle, CPDefs.Task]] =    BEGIN ENABLE UNWIND => NULL;    FOR real: CPDefs.RealCS IN CPDefs.RealCS DO      p: LONG POINTER TO Info;      bank: CPDefs.Bank;      wordInBank: WordInBank;      [bank, wordInBank] ¬ SplitReal[real];      IF info[bank] = NIL THEN LOOP;      p ¬ @info[bank][wordInBank];      IF ~p.valid THEN LOOP;      proc[real, p.virtural, p.cycle, p.task];      ENDLOOP;    END;      SplitReal: PROCEDURE [real: CPDefs.RealCS] RETURNS [bank: CPDefs.Bank, wordInBank: WordInBank] =    BEGIN    temp: CPDefs.BankAndWordsPerBank = LOOPHOLE[real];    RETURN[temp.bank, temp.wordInBank];    END;    BeSureInfoExists: PROCEDURE [bank: CPDefs.Bank, wordInBank: WordInBank] =    BEGIN    IF info[bank] # NIL THEN RETURN;    info[bank] ¬ z.NEW[ARRAY WordInBank OF Info];    info[bank]­ ¬ ALL [[FALSE, , , ]];    END;      SplitVirt: PROCEDURE [virt: CPSymbl.VirturalCS] RETURNS [bank: CPDefs.Bank, wordInBank: WordInBank] =    BEGIN    temp: CPDefs.BankAndWordsPerBank = LOOPHOLE[virt];    RETURN[temp.bank, temp.wordInBank];    END;    BeSureInverseExists: PROCEDURE [bank: CPDefs.Bank, wordInBank: WordInBank] =    BEGIN    IF csInverse[bank] # NIL THEN RETURN;    csInverse[bank] ¬ z.NEW[ARRAY WordInBank OF SymbolHash.Hash];    csInverse[bank]­ ¬ ALL [SymbolHash.nullHash];    END;      AddressOutOfRange: PROCEDURE =    BEGIN    foo: BOOLEAN ¬ TRUE;    IF foo THEN ERROR Error["Address out of range"L];    END;      ClearSymbolTable[];  END.-- Log of last edits-- JAC	30-May-85 16:42:36	CP renamed to CPDefs-- JAC	31-May-85  9:46:06	CPSymbols renamed to CPSymbl; CPMI renamed to CPMIFormat
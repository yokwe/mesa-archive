-- Copyright (C) 1985  by Xerox Corporation. All rights reserved.-- Last edit by JAC	 7-Jun-85 12:26:52	copyrighted -- CPBreaker.mesa, JoM    , 16-Jan-85 9:01:38DIRECTORY  Heap USING [systemZone],  String USING [AppendNumber, AppendString],    CP USING [Cycle, RealCS],  CPMI USING [MI],  CPBreak USING [],  CPKernel USING [    AtBreak, Error, GetBreakCycle, GetBreakID, InKernel, maxBreaks, ReadCS, SetBreak, WriteCS];CPBreaker: MONITOR  IMPORTS Heap, String, CPKernel  EXPORTS CPBreak =  BEGIN    z: UNCOUNTED ZONE = Heap.systemZone;    head: Breakpoint _ NIL;  breaksInstalled: BOOLEAN _ FALSE;    lastBreakInfo: RECORD [location: CP.RealCS, cycle: CP.Cycle, mi: CPMI.MI];    Error: PUBLIC ERROR [reason: LONG STRING] = CODE;    Breakpoint: TYPE = LONG POINTER TO  BreakpointInfo;  BreakpointInfo: TYPE = RECORD [    location: CP.RealCS,    mi: CPMI.MI,    cycle: CP.Cycle,    next: Breakpoint];    Break: PUBLIC ENTRY PROCEDURE [location: CP.RealCS, cycle: CP.Cycle] =    BEGIN ENABLE      BEGIN      CPKernel.Error => ERROR Error[reason];      UNWIND => NULL;      END;    new: Breakpoint;    id: CARDINAL _ 1;  -- The one we want to add    BeSureInKernel[];    RemoveBreaksInternal[];    FOR finger: Breakpoint _ head, finger.next UNTIL finger = NIL DO      IF finger.location = location THEN ERROR Error["Breakpoint already set there"L];      id _ id + 1;      ENDLOOP;    IF id >= CPKernel.maxBreaks THEN ERROR Error["Too many breakpoints"L];    new _ z.NEW[BreakpointInfo];    new^ _ [location, CPKernel.ReadCS[location], cycle, head];    head _ new;    END;	    Unbreak: PUBLIC ENTRY PROCEDURE [location: CP.RealCS, cycle: CP.Cycle] =    BEGIN ENABLE      BEGIN      CPKernel.Error => ERROR Error[reason];      UNWIND => NULL;      END;    previous: Breakpoint _ NIL;    BeSureInKernel[];    RemoveBreaksInternal[];    FOR finger: Breakpoint _ head, finger.next UNTIL finger = NIL DO      IF finger.location = location THEN        BEGIN	temp: Breakpoint _ finger;  -- Rats, can't smash LOOP control variable	IF cycle # finger.cycle THEN	  ERROR Error["Cycle confusion"L];	IF previous = NIL THEN head _ finger.next	ELSE previous.next _ finger.next;	z.FREE[@temp];	RETURN;	END;      previous _ finger;      ENDLOOP;    ERROR Error["Breakpoint not found"L];    END;    Reset: PUBLIC ENTRY PROCEDURE =    BEGIN    Smash[];    END;    ClearAllBreaks: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE UNWIND => NULL;    BeSureInKernel[];    Smash[];    END;  Smash: INTERNAL PROCEDURE =    BEGIN    breaksInstalled _ FALSE;    UNTIL head = NIL DO      temp: Breakpoint _ head;      head _ head.next;      z.FREE[@temp];      ENDLOOP;    END;  EnumerateBreaks: PUBLIC ENTRY PROCEDURE [proc: PROCEDURE[CP.RealCS, CP.Cycle]] =    BEGIN ENABLE UNWIND => NULL;    FOR finger: Breakpoint _ head, finger.next UNTIL finger = NIL DO      proc[finger.location, finger.cycle];      ENDLOOP;    END;    InstallBreaks: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE      BEGIN      CPKernel.Error => ERROR Error[reason];      UNWIND => NULL;      END;    id: CARDINAL _ 0;    BeSureInKernel[];    IF breaksInstalled THEN RETURN;    breaksInstalled _ TRUE;    FOR finger: Breakpoint _ head, finger.next UNTIL finger = NIL DO      finger.mi _ CPKernel.ReadCS[finger.location];      CPKernel.SetBreak[finger.location, finger.cycle, id];      id _ id + 1;      ENDLOOP;    IF id >= CPKernel.maxBreaks THEN ERROR;    END;    BreakStillSet: PUBLIC ENTRY PROCEDURE [    location: CP.RealCS, cycle: CP.Cycle, mi: CPMI.MI] RETURNS [BOOLEAN] =    BEGIN ENABLE      BEGIN      CPKernel.Error => ERROR Error[reason];      UNWIND => NULL;      END;    BeSureInKernel[];    FOR finger: Breakpoint _ head, finger.next UNTIL finger = NIL DO      IF finger.location # location THEN LOOP;      IF finger.cycle # cycle THEN ERROR;      RETURN[TRUE];      ENDLOOP;    RETURN[FALSE];    END;    RemoveBreaks: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE UNWIND => NULL;    RemoveBreaksInternal[];    END;    RemoveBreaksInternal: INTERNAL PROCEDURE =    BEGIN ENABLE CPKernel.Error => ERROR Error[reason];    id: CARDINAL _ 0;    currentBreakID: CARDINAL _ nullBreakID;    nullBreakID: CARDINAL = CPKernel.maxBreaks;    currentCycle: CP.Cycle _ any;    BeSureInKernel[];    IF ~breaksInstalled THEN RETURN;    breaksInstalled _ FALSE;    IF CPKernel.AtBreak[] THEN      BEGIN      currentBreakID _ CPKernel.GetBreakID[];      currentCycle _ CPKernel.GetBreakCycle[]      END;    FOR finger: Breakpoint _ head, finger.next UNTIL finger = NIL DO      IF id = currentBreakID THEN        BEGIN  -- In case it gets deleted	lastBreakInfo _ [finger.location, currentCycle, finger.mi];	currentBreakID _ nullBreakID;	END;      CPKernel.WriteCS[finger.location, finger.mi];      id _ id + 1;      ENDLOOP;    IF currentBreakID # nullBreakID THEN      BEGIN      text: STRING = [200];      String.AppendString[text, "Breakpoint confusion -- ID = "L];      String.AppendNumber[text, currentBreakID, 16];      ERROR Error[text];      END;    END;    GetLastBreakInfo: PUBLIC PROCEDURE RETURNS [CP.RealCS, CP.Cycle, CPMI.MI] =    BEGIN    RemoveBreaks[];    RETURN[lastBreakInfo.location, lastBreakInfo.cycle, lastBreakInfo.mi];    END;    BeSureInKernel: INTERNAL PROCEDURE =    BEGIN    IF ~CPKernel.InKernel[] THEN ERROR Error["Can't adjust breaks while running (or crashed)"L];    END;    END.
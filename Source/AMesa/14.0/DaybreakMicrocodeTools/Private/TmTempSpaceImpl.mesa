-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- File: TmTempSpaceImpl.mesa.-- Last edit: DEG      26-Sep-84 21:03:11-- Last edit: JAC    12-Aug-83 10:16:24-- Last edit: ETN     21-Jan-83 10:51:44-- The purpose of this module is to allocate and free temp storage.      DIRECTORY  Environment USING [bytesPerPage, wordsPerPage],  Heap USING [systemZone],  MFile USING [Acquire, CopyFileHandle, Delete, Handle, Release, SetLength],   MSegment USING [Address, Create, Delete, Error],  String USING [AppendString, WordsForString],  TmAssembler,  TmControl USING [argBuf, FatalError, TtyLine],  TmFile USING [CloseStream, fImc, LogLine, outFile, ReplaceExt, PassFileHandle, siStream, sourceFileNames, StmtFileHandle],  TmModule;  TmTempSpaceImpl: PROGRAM  IMPORTS Heap, MFile, MSegment, String, TmControl, TmFile EXPORTS TmModule, TmAssembler =  BEGIN  OPEN TmAssembler;     -- GLOBAL VARIABLES    CurrStmtPos: LONG POINTER;  CurrPassPos: LONG POINTER;  PassBytes: LONG CARDINAL = PassPages*Environment.bytesPerPage;  PassFileLength: LONG CARDINAL;    PassMultiSegPtr: passMultiSegPtr ¬ NIL;  PassPages: CARDINAL = 10;  PassWordsAllocated: CARDINAL ¬ 0;  StmtBytes: LONG CARDINAL = StmtPages*Environment.bytesPerPage;  StmtFileLength: LONG CARDINAL;   StmtMultiSegPtr: stmtMultiSegPtr ¬ NIL;   StmtPages: CARDINAL = 50;    StmtWordsAllocated: CARDINAL ¬ 0;    stringWords: CARDINAL;    TotalPassWords: CARDINAL = PassPages*Environment.wordsPerPage;  TotalStmtWords: CARDINAL = StmtPages*Environment.wordsPerPage;    --PRIVATE VARIABLES  errorMessage: LONG STRING = "Insufficient space.  Please clean up volume before retrying.";    InitGlobalTempSpace: PUBLIC PROCEDURE =    BEGIN    PassMultiSegPtr ¬ NIL;    StmtMultiSegPtr ¬ NIL;    PassWordsAllocated ¬ 0;    StmtWordsAllocated ¬ 0;    PassFileLength ¬ 0;    StmtFileLength ¬ 0;    stringWords ¬ String.WordsForString[maxArgLength];    END;  --InitGlobalTempSpace        SaveArgs: PUBLIC PROCEDURE [    arrayP: LONG POINTER TO ARRAY [0..sizeArgArray] OF LONG STRING,    num: [0..sizeArgArray]] =    BEGIN    i: CARDINAL;    arrayP­[0] ¬ GetStmtSpace[(num + 1)*stringWords];    arrayP­[0]­ ¬ [length: 0, maxlength: maxArgLength, text:];    String.AppendString[arrayP­[0], TmControl.argBuf[0]];    FOR i IN [1..num] DO      arrayP­[i] ¬ LOOPHOLE[arrayP­[i - 1] + stringWords];      arrayP­[i]­ ¬ [length: 0, maxlength: maxArgLength, text:];      String.AppendString[arrayP­[i], TmControl.argBuf[i]];      ENDLOOP;    END;      CreateStmtSegment: PUBLIC PROCEDURE =     BEGIN        NoRoom: PROCEDURE =      BEGIN      TmControl.TtyLine[errorMessage];      TmFile.LogLine[errorMessage];      IF TmFile.siStream # NIL THEN {  --processing mc's        TmFile.siStream ¬ TmFile.CloseStream[TmFile.siStream];	TmFile.siStream ¬ NIL; --so won't try to reclose when cleaning up	MFile.Delete[MFile.Acquire[ TmFile.ReplaceExt[TmFile.sourceFileNames[TmFile.fImc], "si"],delete, [NIL,NIL]]]};	MFile.Release[TempPtr­.StmtFileHandle];	Heap.systemZone.FREE[@TempPtr];	TmControl.FatalError;	END;  --NoRoom	        TempPtr: stmtMultiSegPtr;            StmtFileLength ¬ StmtFileLength + StmtBytes;    MFile.SetLength[TmFile.StmtFileHandle, StmtFileLength];    TempPtr ¬ Heap.systemZone.NEW[stmtMultiSeg];    TempPtr­.nextSeg ¬ StmtMultiSegPtr;    TempPtr­.StmtFileHandle ¬ MFile.CopyFileHandle[file: TmFile.StmtFileHandle, release: [NIL, NIL]];    StmtMultiSegPtr ¬ TempPtr;    StmtMultiSegPtr­.StmtSeg ¬  MSegment.Create[file:StmtMultiSegPtr­.StmtFileHandle, release: [NIL, NIL], fileBase: (StmtFileLength-StmtBytes)/Environment.bytesPerPage, pages: StmtPages ! MSegment.Error => IF (code = insufficientVM) OR (code = noRoomOnVolume) THEN      NoRoom];    StmtMultiSegPtr­.StmtSegPtr ¬ MSegment.Address[StmtMultiSegPtr­.StmtSeg];     CurrStmtPos ¬ StmtMultiSegPtr­.StmtSegPtr;    END;   --CreateStmtSegment       CreatePassSegment: PUBLIC PROCEDURE =     BEGIN    TempPtr: passMultiSegPtr;    PassFileLength ¬ PassFileLength + PassBytes;    MFile.SetLength[TmFile.PassFileHandle, PassFileLength];    TempPtr ¬ Heap.systemZone.NEW[passMultiSeg];    TempPtr­.nextSeg ¬ PassMultiSegPtr;    TempPtr­.PassFileHandle ¬ MFile.CopyFileHandle[file: TmFile.PassFileHandle, release: [NIL, NIL]];    PassMultiSegPtr ¬ TempPtr;    PassMultiSegPtr­.PassSeg ¬ MSegment.Create[file: PassMultiSegPtr­.PassFileHandle, release: [NIL, NIL], fileBase: (PassFileLength-PassBytes)/Environment.bytesPerPage, pages: PassPages !       MSegment.Error => IF (code = insufficientVM) OR (code = noRoomOnVolume)         THEN {TmControl.TtyLine[errorMessage];        TmFile.LogLine[errorMessage];	MFile.Release[TempPtr­.PassFileHandle];	Heap.systemZone.FREE[@TempPtr];	TmControl.FatalError}];    PassMultiSegPtr­.PassSegPtr ¬ MSegment.Address[PassMultiSegPtr­.PassSeg];    CurrPassPos ¬ PassMultiSegPtr­.PassSegPtr;    END;    DeletePassSegment: PUBLIC PROCEDURE =     BEGIN    TempPtr: passMultiSegPtr;    IF PassMultiSegPtr # NIL THEN {   --no user abort      IF PassMultiSegPtr.nextSeg # NIL THEN FreePassSpace;      TempPtr ¬ PassMultiSegPtr­.nextSeg;      MSegment.Delete[PassMultiSegPtr­.PassSeg];      Heap.systemZone.FREE[@PassMultiSegPtr];      PassMultiSegPtr ¬ TempPtr;      MFile.Release[TmFile.PassFileHandle];           TmFile.PassFileHandle ¬ MFile.Acquire[name: TmFile.ReplaceExt[TmFile.outFile, "pf"], access: delete, release: [NIL,NIL]];      MFile.Delete[TmFile.PassFileHandle];      TmFile.PassFileHandle ¬ NIL}          END;      DeleteStmtSegment: PUBLIC PROCEDURE =     BEGIN    TempPtr: stmtMultiSegPtr;              IF StmtMultiSegPtr # NIL THEN {       --no user abort      IF StmtMultiSegPtr­.nextSeg # NIL THEN FreeStmtSpace;      TempPtr ¬ StmtMultiSegPtr­.nextSeg;            MSegment.Delete[StmtMultiSegPtr­.StmtSeg];      Heap.systemZone.FREE[@StmtMultiSegPtr];      StmtMultiSegPtr ¬ TempPtr;               MFile.Release[TmFile.StmtFileHandle];           TmFile.StmtFileHandle ¬ MFile.Acquire[name: TmFile.ReplaceExt[TmFile.outFile, "sf"], access: delete, release: [NIL,NIL]];      MFile.Delete[TmFile.StmtFileHandle];      TmFile.StmtFileHandle ¬ NIL}       END;    FreePassSpace: PUBLIC PROCEDURE =     BEGIN    TempPtr: passMultiSegPtr;    UNTIL PassMultiSegPtr­.nextSeg = NIL DO      TempPtr ¬ PassMultiSegPtr­.nextSeg;      PassFileLength ¬ PassFileLength - PassBytes;      MFile.SetLength[TmFile.PassFileHandle, PassFileLength];      MSegment.Delete[PassMultiSegPtr­.PassSeg];      Heap.systemZone.FREE[@PassMultiSegPtr];      PassMultiSegPtr ¬ TempPtr;            ENDLOOP;    CurrPassPos ¬ PassMultiSegPtr­.PassSegPtr;    PassWordsAllocated ¬ 0;    END;      FreeStmtSpace: PUBLIC PROCEDURE =     BEGIN    TempPtr: stmtMultiSegPtr;            UNTIL StmtMultiSegPtr­.nextSeg = NIL DO      TempPtr ¬ StmtMultiSegPtr­.nextSeg;      StmtFileLength ¬ StmtFileLength - StmtBytes;      MFile.SetLength[TmFile.StmtFileHandle, StmtFileLength];      MSegment.Delete[StmtMultiSegPtr­.StmtSeg];      Heap.systemZone.FREE[@StmtMultiSegPtr];      StmtMultiSegPtr ¬ TempPtr;             ENDLOOP;    CurrStmtPos ¬ StmtMultiSegPtr­.StmtSegPtr;    StmtWordsAllocated ¬ 0;           END;    GetPassSpace: PUBLIC PROCEDURE[nWords: CARDINAL] RETURNS [LONG POINTER] =    BEGIN    OldPassPos: LONG POINTER;    PassWordsAllocated ¬ PassWordsAllocated + nWords;    IF PassWordsAllocated > TotalPassWords THEN      BEGIN      CreatePassSegment;      PassWordsAllocated ¬ nWords;      END;    OldPassPos ¬ CurrPassPos;    CurrPassPos ¬ CurrPassPos + nWords;    RETURN[OldPassPos];    END;      GetStmtSpace: PUBLIC PROCEDURE[nWords: CARDINAL] RETURNS [LONG POINTER] =     BEGIN    OldStmtPos: LONG POINTER;    StmtWordsAllocated ¬ StmtWordsAllocated + nWords;    IF StmtWordsAllocated > TotalStmtWords THEN      BEGIN      CreateStmtSegment;      StmtWordsAllocated ¬ nWords;      END;    OldStmtPos ¬ CurrStmtPos;            CurrStmtPos ¬ CurrStmtPos + nWords;        RETURN[OldStmtPos];    END;        END...    -- Log    -- 16-Jul-82 13:50:01 - ETN        - TrinityMass Version 1  -- 21-Jan-83 10:51:37 - ETN        - Sierra. Eliminate mySpace as   --                                   Heap.Create.parent  -- 7-Jul-83 11:38:55  - JAC        - Added procs for a statement segment  -- 8-Jul-83 14:11:40  - JAC        - Added mulitsegmenting  -- 12-Jul-83 11:25:32 - JAC        - Eliminate use of ReleaseArgs  -- 13-Jul-83  9:29:44 - JAC        - Added pass segments  -- 14-Jul-83 10:37:08 - JAC        - Eliminate tempHeap  --  3-Aug-83 15:13:20 - JAC        - Added file to backup stmt segment  --  8-Aug-83 17:35:53 - JAC        - Added file to backup pass segment  -- 12-Aug-83 10:27:41 - JAC        - Error handling for insufficient space when getting more space  -- Time: 26-Sep-84 21:03:06	By: DEG     	Action: Added copyright notice and rebuild for 11.1 release.
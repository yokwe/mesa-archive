-- Copyright (C) 1985  by Xerox Corporation. All rights reserved.-- Last edit by JAC	 7-Jun-85 12:26:52	copyrighted -- CPKernelBreakerDaybreak.mesa, JoM    , 21-Jan-85 10:02:19DIRECTORY  Inline USING [BITAND, BITSHIFT],  CP USING [Bank, Cycle, RealCS, UReg, wordsPerBank],  CPKernel USING [Byte, Nibble],  CPKernelConstants ,  CPKernelOps USING [GetStateInternal, ReadUSpecial, WriteCSInternal],  CPMI USING [MI],  IOPKernelOps USING [lock, InitializeLock];CPKernelBreakerDaybreak: MONITOR LOCKS IOPKernelOps.lock  IMPORTS Inline, CPKernelOps, IOPKernelOps  EXPORTS CPKernel, CPKernelOps =  BEGIN OPEN CPKernelConstants;  Nibble: TYPE = CPKernel.Nibble;  Byte: TYPE = CPKernel.Byte;  currentBreakID: CARDINAL;  AtBreak: PUBLIC ENTRY PROCEDURE RETURNS [BOOLEAN] =    {RETURN[CPKernelOps.GetStateInternal[] = cpBreak]};  SaveCurrentBreakID: PUBLIC INTERNAL PROCEDURE =    {currentBreakID _ CPKernelOps.ReadUSpecial[uBreakID]};  GetBreakID: PUBLIC ENTRY PROCEDURE RETURNS [CARDINAL] =    {RETURN[(currentBreakID MOD 256)]};  GetBreakCycle: PUBLIC ENTRY PROCEDURE RETURNS [CP.Cycle] =    {RETURN[(SELECT (currentBreakID / 256) FROM      1 => c1,      2 => c2,      3 => c3,      ENDCASE => any)]};  SetBreak: PUBLIC ENTRY PROCEDURE [pc: CP.RealCS, cycle: CP.Cycle, id: Byte] =    BEGIN    idH: Nibble _ Inline.BITAND[Inline.BITSHIFT[id, -4], 17B];    idL: Nibble _ Inline.BITAND[id, 17B];    IF pc ~IN CP.RealCS THEN ERROR;    --RHrK _ BreakID, DISP4[kEntry], c*;    CPKernelOps.WriteCSInternal[      pc, CPMI.MI[      , rK, , , , , , , , byte, nibble, loadRH, [d[idH]], [d[idL]], kEntry]];    END;  PrepareToContinueAfterBreak: PUBLIC INTERNAL PROCEDURE [    mi: CPMI.MI, cycle: CP.Cycle, bank: CP.Bank] =    BEGIN ENABLE UNWIND => NULL;    offset: CARDINAL _ bank * CP.wordsPerBank;    IF cycle = any THEN SELECT (currentBreakID / 256) FROM      1 => cycle _ c1;      2 => cycle _ c2;      3 => cycle _ c3;      ENDCASE;    SELECT cycle FROM      c1 =>        --kBuffer: Noop, c1;        --         Noop, c2;        --         Xbus _ UKSaveDisp, XDisp, c3;        --         <copy of original c1 inst>, c1;        BEGIN -- 2 Noops here        CPKernelOps.WriteCSInternal[          kBuffer + offset, CPMI.MI[          , , , , , , , , , , , , , , kBuffer + offset + 1]];        CPKernelOps.WriteCSInternal[          kBuffer + offset + 1, CPMI.MI[          , , , , , , , , , , , , , , kBuffer + offset + 2]];	offset _ offset + 2        END;      c2 =>        --kBuffer: Xbus _ UKSaveDisp, XDisp, c1;        --         <copy of original c2 inst>, c2;	NULL; -- 0 Noops here      c3 =>        -- kBuffer: Noop, c1;        --          Xbus _ UKSaveDisp, XDisp, c2;        --          <copy of original c3 inst>, c3;        BEGIN -- 1 Noop here        CPKernelOps.WriteCSInternal[          kBuffer + offset, CPMI.MI[          , , , , , , , , , , , , , , kBuffer + offset + 1]];        offset _ offset + 1	END;      ENDCASE => ERROR;    CPKernelOps.WriteCSInternal[      kBuffer + offset, CPMI.MI[      uKSaveDispH, , , , , , , TRUE, , dispBr, uAddr, , [b[xDisp]], [d[uKSaveDispL]], kBuffer + offset + 1]];    CPKernelOps.WriteCSInternal[kBuffer + offset + 1, mi];    END;  PrepareToContinueAfterStop: PUBLIC INTERNAL PROCEDURE [    realCS: CP.RealCS, bank: CP.Bank] =    {PrepareToContinueAfterBreak[      CPMI.MI[          , , , , , , , , , , , , , , realCS], any, bank]};  PrepareToStart: PUBLIC INTERNAL PROCEDURE [    realCS: CP.RealCS, cycle: CP.Cycle, bank: CP.Bank] =    BEGIN ENABLE UNWIND => NULL;    offset: CARDINAL _ bank * CP.wordsPerBank;    SELECT cycle FROM      c1, any =>        --kBuffer: Noop, c1;        --         Noop, c2;        --         GOTO[realCS], c3;        BEGIN -- 2 Noops here        CPKernelOps.WriteCSInternal[          kBuffer + offset, CPMI.MI[          , , , , , , , , , , , , , , kBuffer + offset + 1]];        CPKernelOps.WriteCSInternal[          kBuffer + offset + 1, CPMI.MI[          , , , , , , , , , , , , , , kBuffer + offset + 2]];	offset _ offset + 2        END;      c2 =>        --kBuffer: GOTO[realCS], c1;	NULL; -- 0 Noops here      c3 =>        -- kBuffer: Noop, c1;        --          GOTO[realCS], c2;        BEGIN -- 1 Noop here        CPKernelOps.WriteCSInternal[          kBuffer + offset, CPMI.MI[          , , , , , , , , , , , , , , kBuffer + offset + 1]];        offset _ offset + 1	END;      ENDCASE => ERROR;    CPKernelOps.WriteCSInternal[      kBuffer + offset, CPMI.MI[      , , , , , , , , , , , , , , realCS]];    END;  [] _ IOPKernelOps.InitializeLock[];  END.
-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. -- Last edit by JAC/JWF   	29-Aug-86 17:38:46-- CPWindowImpl.mesa, AYC   ,   27-Nov-84 11:48:04-- from CPWindower.mesa, HGM,   14-Feb-84  1:13:28--DIRECTORY  Exec USING [AddCommand, ExecProc, GetTTY, Handle, PrependCommands, ReleaseTTY, RemoveCommand],  Format USING [StringProc],  FormSW USING [    BooleanItem, AllocateItemDescriptor, ClientItemsProcType, CommandItem,    DisplayItem, Enumerated, EnumeratedItem, newLine,    nextPlace, NotifyProcType, ProcType, sameLine, StringItem, TagOnlyItem,    ToggleVisibility, line0, line1, line2, line3, line4],  Heap USING [systemZone],  Inline USING [LongCOPY],  MFile USING [Acquire, Error, Handle],  MLoader USING [Run],  Process USING [Detach, MsecToTicks, Pause],  Put USING [CR, Date, Decimal, Line, Text],  Runtime USING [ControlLink, GetBcdTime, IsBound],  Selection USING [Convert],  String USING [    AppendLongDecimal, AppendLongNumber, AppendString, AppendStringAndGrow,    CopyToNewString, Empty],  System USING [GetGreenwichMeanTime],  TextSW USING [ForceOutput],  Time USING [Append, Unpack],  Tool USING [Create, Destroy, MakeFormSW, MakeFileSW, MakeSWsProc, UnusedLogName],  ToolWindow USING [TransitionProcType],  TTY USING [Handle, PutLine, PutString],  UserInput USING [    CancelPeriodicNotify, CreatePeriodicNotify, PeriodicNotifyHandle,    PeriodicProcType, UserAbort],  Version USING [Append],  Window USING [Handle],    Bindweed USING [ReadMemoryBlock],  CommandFile USING [CommandsFromFile, Error, SomebodyRunning],  CPDef USING [RealCS, ROffset],  CPBreak USING [ClearAllBreaks, EnumerateBreaks, Error, GetBreakInfo, RemoveBreaks],  CPCommand USING [    AutoPollCP, Boot, Break, CopyPanel, Error, Compare, Continue, Load,    LoadBootFile, LoadGerm, LoadRaw, LoadReal, LoadSymbols, PollCP, PopIB,    PrintState, Reset, SourceDebugCreate, SourceDebugDestory, Start, Stop,    SymbolDebugCreate, SymbolDebugDestory, ToggleFlags, Unbreak],  CPKernel USING [    AtBreak, Error, GetState, GetStopInfo, InKernel, LoadBankType, OptionsDataType, ProbeForStateChange, State],  CPPanel USING [Clear, Destroy, MakePanelSW, Refresh],  CPSymbol USING [    AppendAllAReg, AppendAllDReg, AppendAllRReg, AppendNumber,    AppendAllVirturalCS, AppendLink, AppendMap, AppendOther, AppendReal,    AppendRealCS, AppendSymbol, AppendVirtural, AppendVirturalCS, Error, Eval,    nullRealCS, nullVirturalCS, RealToVirturalCS, Symbol, VirturalCS,    VirturalToRealCS];CPWindowImpl: PROGRAM  IMPORTS    Exec, FormSW, Heap, Inline, MFile, MLoader, Process, Put, Runtime,    Selection, String, System, TextSW, Time, Tool, TTY, UserInput, Version,    Bindweed, CommandFile, CPBreak, CPCommand, CPKernel, CPPanel, CPSymbol  EXPORTS CPCommand, CPKernel =  BEGIN    -- TYPEs  BurdockWindows: TYPE = LONG POINTER TO BurdockWindowSeq;  BurdockWindowSeq: TYPE = RECORD  [ length: CARDINAL _ 0,    w: SEQUENCE maxlength: CARDINAL OF Window.Handle _ NULL];    FormOptionItems: TYPE = {aChips, apply, abort, banksofMicrocode, aChipAddressSwap, useOpie, setBanksOnBoot};    -- global variables  bw: BurdockWindows _ NIL;  optionsWindowData: CPKernel.OptionsDataType;  optionsData: PUBLIC CPKernel.OptionsDataType;  loadBank: PUBLIC CPKernel.LoadBankType ¬ 0;  optionsHandle: Window.Handle ¬ NIL;  optionsFormHandle: Window.Handle ¬ NIL;  z: UNCOUNTED ZONE = Heap.systemZone;    --  -- Constants Definition  --    typeIn, run: LONG STRING ¬ NIL;  uPCTypeIn, NextuPCTypeIn: LONG STRING ¬ NIL;  EOPInt, EXTInt, CSParity: BOOLEAN ¬ FALSE;  log, upperform, lowerform, panel: Window.Handle ¬ NIL;  state: CPKernel.State;  refreshNeeded, flushDuplicates, flushStateChange: BOOLEAN ¬ FALSE;  initialized: BOOLEAN ¬ FALSE;  notifier: UserInput.PeriodicNotifyHandle;  clumpSize: CARDINAL ¬ 10;  OptionsProc: FormSW.ProcType =    BEGIN    FormSW.ToggleVisibility[lowerform, optionsIx];    optionsWindowData ¬ optionsData;    optionsHandle ¬ Tool.Create[      makeSWsProc: MakeOptionSWs, initialState: default,      initialBox: [place: [x:512, y: 282], dims: [w: 366, h: 110]],      clientTransition: OptionsProcClientTransition, name: "CPBermudaDaisy Options"L,      cmSection: "CPBermudaDaisyOptions"L];    END;OptionsProcClientTransition: ToolWindow.TransitionProcType =    BEGIN    END;      OptionsApply: FormSW.ProcType =    BEGIN    optionsData ¬ optionsWindowData;    Tool.Destroy[optionsHandle];    optionsHandle ¬ NIL;    FormSW.ToggleVisibility[lowerform, optionsIx];    END;         OptionsAbort: FormSW.ProcType =    BEGIN    Tool.Destroy[optionsHandle];    optionsHandle ¬ NIL;    FormSW.ToggleVisibility[lowerform, optionsIx];    END;      MakeOptionSWs: Tool.MakeSWsProc =    BEGIN    optionsFormHandle ¬ Tool.MakeFormSW[window: window, formProc: MakeOptionsForm];    END;  Boot: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostDate[];    IF uPCTypeIn # NIL THEN uPCTypeIn.length ¬ 0;    IF NextuPCTypeIn # NIL THEN NextuPCTypeIn.length ¬ 0;    CPCommand.Boot[LogWrite, log];    END;  ResetLoad: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    filename: LONG STRING ¬ Selection.Convert[string];    PostDate[];    BEGIN ENABLE UNWIND => z.FREE[@filename];    CPCommand.Reset[LogWrite, log];    CPCommand.Load[LogWrite, log, filename, 0];    CPCommand.LoadSymbols[LogWrite, log, filename, 0];    z.FREE[@filename];    END;    END;  Load: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    filename: LONG STRING ¬ Selection.Convert[string];    PostDate[];    BEGIN ENABLE UNWIND => z.FREE[@filename];    IF ~CPKernel.InKernel[] THEN        ERROR CPCommand.Error["Aborted... CP not in Kernel "L];    CPCommand.Load[LogWrite, log, filename, 0];    CPCommand.LoadSymbols[LogWrite, log, filename, 0];    z.FREE[@filename];    END;    END;  Compare: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    filename: LONG STRING ¬ Selection.Convert[string];    PostDate[];    BEGIN ENABLE UNWIND => z.FREE[@filename];    CPCommand.Compare[LogWrite, log, filename];    z.FREE[@filename];    END;    END;  ClearPanel: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    BEGIN ENABLE UNWIND => NULL;    CPPanel.Clear[];    END;    END;  Start: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    BEGIN    PostDate[];    CPCommand.Start[LogWrite, log, uPCTypeIn, NextuPCTypeIn];    END;    END;  Continue: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostDate[];    CPCommand.Continue[LogWrite, log];    END;  Stop: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostDate[];    CPCommand.Stop[LogWrite, log];    END;  ToggleFlags: FormSW.NotifyProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostDate[];    CPCommand.ToggleFlags[LogWrite, log, EOPInt, EXTInt, CSParity];    END;  Run: FormSW.ProcType =    BEGIN    filename: LONG STRING ¬ String.CopyToNewString[run, z];    IF String.Empty[filename] THEN filename ¬ Selection.Convert[string];    Put.CR[log];    flushStateChange ¬ TRUE;    Process.Detach[FORK Runner[filename]];    -- Dally so Watcher can't sneak in and reset flushStateChange before     --  the process we just forked gets started.    FOR i: CARDINAL IN [0..10) DO      IF CommandFile.SomebodyRunning[] THEN EXIT;      Process.Pause[Process.MsecToTicks[100]];      ENDLOOP;    END;    Runner: PROCEDURE [filename: LONG STRING] =    BEGIN    BEGIN ENABLE CommandFile.Error =>      BEGIN      temp: STRING = [200];      String.AppendString[temp, "Error in command file at position "L];      String.AppendLongDecimal[temp, position];      String.AppendString[temp, ": "L];      String.AppendString[temp, reason];      TailMessage[temp];      CONTINUE;      END;    FormSW.ToggleVisibility[upperform, runIx];    CommandFile.CommandsFromFile[LogWrite, log, Abort, filename];    END;    z.FREE[@filename];    FormSW.ToggleVisibility[upperform, runIx];    END;  SymbolDebugCreate: FormSW.ProcType =    BEGIN    FormSW.ToggleVisibility[lowerform, SymbolDebugIx];    CPCommand.SymbolDebugCreate[lowerform, SymbolDebugIx];    END;      SourceDebugCreate: FormSW.ProcType =    BEGIN    FormSW.ToggleVisibility[lowerform, SourceDebugIx];    CPCommand.SourceDebugCreate[lowerform, SourceDebugIx];    END;      LoadRaw: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    filename: LONG STRING ¬ Selection.Convert[string];    PostDate[];    BEGIN ENABLE UNWIND => z.FREE[@filename];    CPCommand.LoadRaw[LogWrite, log, filename, loadBank];    CPCommand.LoadSymbols[LogWrite, log, filename, loadBank];    z.FREE[@filename];    END;    END;  LoadNoSyms: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    filename: LONG STRING ¬ Selection.Convert[string];    PostDate[];    BEGIN ENABLE UNWIND => z.FREE[@filename];    IF ~CPKernel.InKernel[] THEN        ERROR CPCommand.Error["Aborted... CP not in Kernel "L];    CPCommand.Load[LogWrite, log, filename, 0];    z.FREE[@filename];    END;    END;  LoadSymbols: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    filename: LONG STRING ¬ Selection.Convert[string];    BEGIN ENABLE UNWIND => z.FREE[@filename];    CPCommand.LoadSymbols[LogWrite, log, filename, 0];    z.FREE[@filename];    END;    END;  LoadGerm: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    filename: LONG STRING ¬ Selection.Convert[string];    PostDate[];    BEGIN ENABLE UNWIND => z.FREE[@filename];    CPCommand.LoadGerm[LogWrite, log, filename];    z.FREE[@filename];    END;    END;  LoadReal: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    filename: LONG STRING ¬ Selection.Convert[string];    PostDate[];    BEGIN ENABLE UNWIND => z.FREE[@filename];    CPCommand.LoadReal[LogWrite, log, filename];    z.FREE[@filename];    END;    END;  LoadBoot: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    filename: LONG STRING ¬ Selection.Convert[string];    BEGIN ENABLE UNWIND => z.FREE[@filename];    PostDate[];    CPCommand.LoadBootFile[LogWrite, log, filename, 0];    z.FREE[@filename];    END;    END;  PopIB: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostDate[];    CPCommand.PopIB[LogWrite, log];    END;      PollCP: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostDate[];    [] ¬ CPCommand.PollCP[LogWrite, log, TRUE];    END;      AutoPollCP: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostDate[];    CPCommand.AutoPollCP[LogWrite, log];    END;  CopyPanel: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostDate[];    CPCommand.CopyPanel[LogWrite, log];    END;  Refresh: FormSW.ProcType =    BEGIN    refreshNeeded ¬ flushStateChange ¬ TRUE;    END;    What: FormSW.ProcType =    BEGIN ENABLE      CPSymbol.Error => BEGIN TailMessage[reason];      CONTINUE;    END;        string: LONG STRING ¬ Selection.Convert[string];    temp: LONG STRING = [200];    value: CPSymbol.Symbol;        BEGIN ENABLE UNWIND => z.FREE[@string];        PostMessage["Decoding "L];    IF string = NIL THEN      BEGIN      TailMessage["  Selection required"L];      RETURN;      END;    TailMessage[string];    value ¬ CPSymbol.Eval[string];    WITH value SELECT FROM      number =>        BEGIN	String.AppendString[temp, "Number: "L];	AppendBaseEquivalent[temp, n];	END;      link =>        BEGIN        CPSymbol.AppendLink[temp, link];	AppendBaseEquivalent[temp, link];	END;      realCS =>        BEGIN	virt: CPSymbol.VirturalCS;	String.AppendString[temp, "RealCS: "L];        CPSymbol.AppendRealCS[temp, real];	AppendBaseEquivalent[temp, real];	[virt, , ] ¬ CPSymbol.RealToVirturalCS[real];	IF virt # CPSymbol.nullVirturalCS THEN	  BEGIN	  String.AppendString[temp, ", (VirtualCS = .CV "L];          CPSymbol.AppendNumber[temp, virt];          String.AppendString[temp, " = "L];          CPSymbol.AppendVirturalCS[temp, virt];	  String.AppendString[temp, ")"L];	  END;	END;      virtCS =>        BEGIN	real: CPDef.RealCS;	String.AppendString[temp, "VirtualCS: "L];	String.AppendString[temp, ".CV "L];	CPSymbol.AppendNumber[temp, virt];        String.AppendString[temp, " = "L];        CPSymbol.AppendAllVirturalCS[temp, virt];	AppendBaseEquivalent[temp, virt];	[real, , ] ¬ CPSymbol.VirturalToRealCS[virt];	IF real # CPSymbol.nullRealCS THEN	  BEGIN	  String.AppendString[temp, ", (RealCS = "L];          CPSymbol.AppendRealCS[temp, real];	  String.AppendString[temp, ")"L];	  END;	END;      rReg =>        BEGIN	String.AppendString[temp, "RReg: "L];	String.AppendString[temp, ".R "L];	CPSymbol.AppendNumber[temp, r + CPDef.ROffset];        String.AppendString[temp, " = "L];        CPSymbol.AppendAllRReg[temp, r];	AppendBaseEquivalent[temp, r + CPDef.ROffset];	END;      dReg =>        BEGIN	String.AppendString[temp, "DReg: "L];	String.AppendString[temp, ".D "L];	CPSymbol.AppendNumber[temp, d];        String.AppendString[temp, " = "L];        CPSymbol.AppendAllDReg[temp, d];	AppendBaseEquivalent[temp, d];	END;      aReg =>        BEGIN	String.AppendString[temp, "AReg: "L];	String.AppendString[temp, ".A "L];	CPSymbol.AppendNumber[temp, a];        String.AppendString[temp, " = "L];        CPSymbol.AppendAllAReg[temp, a];	AppendBaseEquivalent[temp, a];	END;      map =>        BEGIN        CPSymbol.AppendMap[temp, map];	AppendBaseEquivalent[temp, map];	END;      real =>        BEGIN        CPSymbol.AppendReal[temp, real];	AppendBaseEquivalent[temp, LOOPHOLE[real]];	END;      virt =>        BEGIN        CPSymbol.AppendVirtural[temp, virt];	AppendBaseEquivalent[temp, LOOPHOLE[virt]];	END;      other =>        BEGIN        CPSymbol.AppendOther[temp, other];	END;      ENDCASE => ERROR;    TailMessage[temp];    z.FREE[@string];    END;    END;    AppendBaseEquivalent: PROCEDURE [s: LONG STRING, d: LONG CARDINAL] =    BEGIN    String.AppendString[s, " = "L];    String.AppendLongNumber[s, d, 16];    String.AppendString[s, "'X = "L];    String.AppendLongNumber[s, d, 10];    String.AppendString[s, "'D = "L];    String.AppendLongNumber[s, d, 8];    String.AppendString[s, "'B"L];    END;    Break: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    where: LONG STRING ¬ Selection.Convert[string];    BEGIN ENABLE UNWIND => z.FREE[@where];    IF where = NIL THEN where ¬ String.CopyToNewString[typeIn, z];    IF where = NIL THEN      BEGIN      TailMessage["  Selection/Typein required"L];      RETURN;      END;    CPCommand.Break[LogWrite, log, where];    z.FREE[@where];    END;    END;   UnBreak: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    where: LONG STRING ¬ Selection.Convert[string];    BEGIN ENABLE UNWIND => z.FREE[@where];    CPCommand.Unbreak[LogWrite, log, where];    z.FREE[@where];    END;    END;   ClearAllBreaks: FormSW.ProcType =    BEGIN ENABLE CPBreak.Error =>      BEGIN      PostMessage["Oops, "L];      TailMessage[reason];      CONTINUE;      END;    PostMessage["Clearing All CP Breaks "L];    AppendMessage[" ... "L];    CPBreak.ClearAllBreaks[];    TailMessage["ok"L];    END;  ListBreaks: FormSW.ProcType =    BEGIN ENABLE CPBreak.Error =>      BEGIN      PostMessage["Oops, "L];      TailMessage[reason];      CONTINUE;      END;    breakid: CARDINAL ¬ 0;    PrintOne: PROCEDURE [pc: CPDef.RealCS] =      BEGIN      temp: STRING = [200];      virt: CPSymbol.VirturalCS;      breakid ¬ breakid + 1;      Put.Text[log, "CP Break #"L];      Put.Decimal[log, breakid];      Put.Text[log, " is located at "L];      CPSymbol.AppendRealCS[temp, pc];      [virt, , ] ¬ CPSymbol.RealToVirturalCS[pc];      IF virt # CPSymbol.nullVirturalCS THEN        BEGIN        String.AppendString[temp, ", (VirtualCS = "L];        CPSymbol.AppendVirturalCS[temp, virt];        String.AppendString[temp, ")"L];        END;      Put.Line[log, temp];      END;    Put.CR[log];    Put.Line[log, "CP Breakpoints:"L];    CPBreak.EnumerateBreaks[PrintOne];    Put.Line[log, "Done"L];    END;   RefreshWindow: PUBLIC PROCEDURE =    BEGIN    state ¬ CPKernel.GetState[];    refreshNeeded ¬ TRUE;    END;      Watcher: UserInput.PeriodicProcType =    BEGIN    IF CommandFile.SomebodyRunning[] THEN RETURN;--    ProbeForStateChange[];    IF ~refreshNeeded THEN      BEGIN      refreshNeeded ¬ flushDuplicates ¬ flushStateChange ¬ FALSE;      RETURN;      END;    state ¬ CPKernel.GetState[];    IF ~flushDuplicates THEN      BEGIN      PostDate[];      IF ~flushStateChange THEN AppendMessage["State changed: "L];      IF CPKernel.InKernel[] THEN RemoveBreaks[];      PrintState[];      END;    IF CPKernel.InKernel[] THEN       BEGIN      iniaAndBank, iniaholdAndBank: CPDef.RealCS;      iniaCV, iniaholdCV: CPSymbol.VirturalCS;      RemoveBreaks[];      CPPanel.Refresh[];      [iniaAndBank, iniaholdAndBank, EOPInt, EXTInt, CSParity,] ¬      IF CPKernel.AtBreak[] THEN CPBreak.GetBreakInfo[]	ELSE CPKernel.GetStopInfo[];      [iniaCV, , ] ¬ CPSymbol.RealToVirturalCS[iniaAndBank];      [iniaholdCV, , ] ¬ CPSymbol.RealToVirturalCS[iniaholdAndBank];      IF iniaCV # CPSymbol.nullVirturalCS AND iniaholdCV # CPSymbol.nullVirturalCS THEN        BEGIN	iniaSymbol: STRING ¬ [200];	iniaholdSymbol: STRING ¬ [200];	IF uPCTypeIn # NIL THEN uPCTypeIn.length ¬ 0;	IF NextuPCTypeIn # NIL THEN NextuPCTypeIn.length ¬ 0;	CPSymbol.AppendSymbol[iniaSymbol, [virtCS[iniaCV]]];	String.AppendStringAndGrow[@uPCTypeIn, iniaSymbol, z];	CPSymbol.AppendSymbol[iniaholdSymbol, [virtCS[iniaholdCV]]];	String.AppendStringAndGrow[@NextuPCTypeIn, iniaholdSymbol, z];	END;      FormSW.DisplayItem[upperform, uPCIx];      FormSW.DisplayItem[upperform, NextuPCIx];      FormSW.DisplayItem[upperform, Parityboolean];      FormSW.DisplayItem[upperform, EOPboolean];      FormSW.DisplayItem[upperform, EXTboolean];      END;    FormSW.DisplayItem[upperform, stateIx];    refreshNeeded ¬ flushDuplicates ¬ flushStateChange ¬ FALSE;    END;      ProbeForStateChange: PROCEDURE =    BEGIN ENABLE CPKernel.Error =>      BEGIN      PostMessage["Humm, "L];      TailMessage[reason];      CONTINUE;      END;    CPKernel.ProbeForStateChange[LogWrite, log];    END;      RemoveBreaks: PROCEDURE =    BEGIN ENABLE CPBreak.Error =>      BEGIN      PostMessage["Humm, "L];      TailMessage[reason];      CONTINUE;      END;    CPBreak.RemoveBreaks[];    END;      PrintState: PROCEDURE =    BEGIN ENABLE CPCommand.Error =>      BEGIN      PostMessage["Humm, "L];      TailMessage[reason];      CONTINUE;      END;    CPCommand.PrintState[LogWrite, log];    END;      PostDate: PROCEDURE =    BEGIN    Put.CR[log];    Put.Date[log, System.GetGreenwichMeanTime[], dateTime];    Put.Text[log, "  "L];    TextSW.ForceOutput[log];    flushDuplicates ¬ TRUE;    END;  PostMessage: PROCEDURE [s: LONG STRING] =    BEGIN    Put.CR[log];    Put.Text[log, s];    TextSW.ForceOutput[log];    END;  AppendMessage: PROCEDURE [s: LONG STRING] =    BEGIN    Put.Text[log, s];    TextSW.ForceOutput[log];    END;  TailMessage: PROCEDURE [s: LONG STRING] =    BEGIN    Put.Text[log, s];    Put.Line[log, "."L];    TextSW.ForceOutput[log];    END;    LogWrite: Format.StringProc =    BEGIN    Put.Text[clientData, s];    END;  Abort: PROCEDURE RETURNS [BOOLEAN] =    BEGIN    RETURN[UserInput.UserAbort[log]];    END;UpdateLoadBankItem: PUBLIC PROCEDURE[bank: CPKernel.LoadBankType] =   BEGIN   loadBank ¬ bank;   FormSW.DisplayItem[lowerform, loadBankIx];   END;  Initialize: PROCEDURE[h: Exec.Handle] =    BEGIN    herald: STRING = [100];    bindweedFile: STRING = "BindweedConfig.bcd"L;    msg: STRING ¬ [80];    mfH: MFile.Handle;    ttH: TTY.Handle ¬ Exec.GetTTY[h];    String.AppendString[herald, "Sirius Debugger Using Bindweed "L];    Version.Append[herald];    String.AppendString[herald, " of "L];    Time.Append[herald, Time.Unpack[Runtime.GetBcdTime[]]];    IF initialized THEN ERROR;    IF  ~Runtime.IsBound[LOOPHOLE[Bindweed.ReadMemoryBlock, Runtime.ControlLink]] THEN      BEGIN      mfH ¬ MFile.Acquire[name: bindweedFile, access: readOnly, release: []!        MFile.Error => IF code = noSuchFile THEN GOTO noFile ELSE REJECT];      TTY.PutString[h: ttH, s: "  ... loading "L];      TTY.PutString[h: ttH, s: bindweedFile];      TTY.PutString[h: ttH, s: "..."L];      [] ¬ MLoader.Run[file: mfH];      TTY.PutLine[h: ttH, s: "done."L];      Exec.PrependCommands[h, "BindweedConfig.~"L]; -- start asynchronous notifier    EXITS    noFile =>         BEGIN        String.AppendString[to: msg, from: "  Please retrieve file "L];        String.AppendString[to: msg, from: bindweedFile];        String.AppendString[to: msg, from: " before trying again."L];        TTY.PutLine[h: ttH, s: msg];	Exec.ReleaseTTY[ttH];        RETURN;        END;      END;              RegisterBermudaWindow[Tool.Create[      name: herald,      cmSection: "Sirius Debugger"L,      makeSWsProc: MakeSWs,      clientTransition: ClientTransition]];          initialized ¬ TRUE;    END;    MakeSWs: Tool.MakeSWsProc =    BEGIN    logFileName: STRING = [40];    Tool.UnusedLogName[logFileName, "CPBermudaDaisy.log$"L];    upperform ¬ Tool.MakeFormSW[window: window, formProc: MakeUpperForm];    log ¬ Tool.MakeFileSW[window: window, name: logFileName, h: 100];    lowerform ¬ Tool.MakeFormSW[window: window, formProc: MakeLowerForm];    panel ¬ CPPanel.MakePanelSW[window, log, ModifyTypeIn, @typeIn];    END;    stateChoices: ARRAY CPKernel.State OF FormSW.Enumerated ¬ [    booted: ["Booted", CPKernel.State[booted]],    dead: ["CP/IOP Dead", CPKernel.State[dead]],    stopped: ["Stopped", CPKernel.State[stopped]],    running: ["Running", CPKernel.State[running]],    cpBreak: ["BreakPoint", CPKernel.State[cpBreak]]];    SourceDebugIx: CARDINAL = 6;  SymbolDebugIx: CARDINAL = 7;  optionsIx: CARDINAL = 13;  runIx: CARDINAL = 8;  stateIx: CARDINAL = 5;  typeInIx: CARDINAL = 20;  uPCIx: CARDINAL = 11;  NextuPCIx: CARDINAL = 12;  EOPboolean: CARDINAL = 13;  EXTboolean: CARDINAL = 14;  Parityboolean: CARDINAL = 15;  loadBankIx: CARDINAL = 19;  MakeLowerForm: FormSW.ClientItemsProcType =    BEGIN    bankEnum: ARRAY[0..4) OF FormSW.Enumerated ¬ [      ["Zero"L, 0], ["One"L, 1],      ["Two"L, 2], ["Three"L, 3]];    nParams: CARDINAL = 21;    items ¬ FormSW.AllocateItemDescriptor[nParams];    items[0] ¬ FormSW.CommandItem[tag: "Boot"L, proc: Boot, place: FormSW.newLine];    items[1] ¬ FormSW.CommandItem[tag: "Load"L, proc: ResetLoad];    items[2] ¬ FormSW.CommandItem[tag: "LoadMore"L, proc: Load];    items[3] ¬ FormSW.CommandItem[tag: "LoadSymbols"L, proc: LoadSymbols];    items[4] ¬ FormSW.CommandItem[tag: "Continue"L, proc: Continue];    items[5] ¬ FormSW.CommandItem[tag: "Stop"L, proc: Stop];    items[SourceDebugIx] ¬ FormSW.CommandItem[tag: "SourceDebug"L, proc: SourceDebugCreate];    items[SymbolDebugIx] ¬ FormSW.CommandItem[tag: "SymDebug"L, proc: SymbolDebugCreate];    items[8] ¬ FormSW.CommandItem[tag: "PopIB"L, proc: PopIB, place: FormSW.newLine];    items[9] ¬ FormSW.CommandItem[tag: "PollSirius"L, proc: PollCP];    items[10] ¬ FormSW.CommandItem[tag: "AutoPollSirius"L, proc:  AutoPollCP];    items[11] ¬ FormSW.CommandItem[tag: "Refresh"L, proc: Refresh];    items[12] ¬ FormSW.CommandItem[tag: "WhatIs"L, proc: What];    items[optionsIx] ¬ FormSW.CommandItem[tag: "Options"L, proc: OptionsProc];    items[14] ¬ FormSW.CommandItem[tag: "CopyPanel"L, proc: CopyPanel, place: FormSW.newLine];    items[15] ¬ FormSW.CommandItem[tag: "ListBreaks"L, proc: ListBreaks];    items[16] ¬ FormSW.CommandItem[tag: "ClearAllBreaks"L, proc: ClearAllBreaks];    items[17] ¬ FormSW.CommandItem[tag: "UnBreak"L, proc: UnBreak];    items[18] ¬ FormSW.CommandItem[tag: "SetBreak"L, proc: Break];    items[loadBankIx] ¬ FormSW.EnumeratedItem[tag: "LoadBank"L, choices: DESCRIPTOR[bankEnum], value: @loadBank];    items[typeInIx] ¬ FormSW.StringItem[tag: "TypeIn"L, string: @typeIn, inHeap: TRUE, place: FormSW.newLine];    RETURN[items, TRUE];    END;       MakeUpperForm: FormSW.ClientItemsProcType =    BEGIN    nParams: CARDINAL = 17;    items ¬ FormSW.AllocateItemDescriptor[nParams];    items[0] ¬ FormSW.CommandItem[tag: "LoadRaw"L, proc: LoadRaw, place: FormSW.newLine];    items[1] ¬ FormSW.CommandItem[tag: "LoadNoSymbol"L, proc: LoadNoSyms];    items[2] ¬ FormSW.CommandItem[tag: "LoadGerm"L, proc: LoadGerm];    items[3] ¬ FormSW.CommandItem[tag: "LoadReal"L, proc: LoadReal];    items[4] ¬ FormSW.CommandItem[tag: "LoadBoot"L, proc: LoadBoot];    items[stateIx] ¬ FormSW.EnumeratedItem[      tag: "State"L, value: @state, readOnly: TRUE, place: FormSW.newLine, choices: LOOPHOLE[LONG[DESCRIPTOR[stateChoices]]]];    items[6] ¬ FormSW.CommandItem[tag: "ClearPanel"L, proc: ClearPanel];    items[7] ¬ FormSW.CommandItem[tag: "Compare"L, proc: Compare];    items[runIx] ¬ FormSW.CommandItem[tag: "Run"L, proc: Run];    items[9] ¬ FormSW.StringItem[tag: "File"L, string: @run, inHeap: TRUE];    items[10] ¬ FormSW.TagOnlyItem[tag: "SR ¬"L, place: FormSW.newLine];    items[uPCIx] ¬ FormSW.StringItem[tag: "uPC"L, string: @uPCTypeIn, inHeap: TRUE, place: [35, FormSW.sameLine], drawBox: TRUE];    items[NextuPCIx] ¬ FormSW.StringItem[tag: "NextuPC"L, string: @NextuPCTypeIn, inHeap: TRUE, place: [150, FormSW.sameLine], drawBox: TRUE];    items[EOPboolean] ¬ FormSW.BooleanItem[tag: "EOPInt"L, proc: ToggleFlags, switch: @EOPInt, place: [290, FormSW.sameLine], drawBox: TRUE];    items[EXTboolean] ¬ FormSW.BooleanItem[tag: "EXTInt"L, proc: ToggleFlags, switch: @EXTInt, place: [330, FormSW.sameLine], drawBox: TRUE];    items[Parityboolean] ¬ FormSW.BooleanItem[tag: "CSParity"L, switch: @CSParity, place: [370, FormSW.sameLine], readOnly: TRUE, drawBox: TRUE];    items[16] ¬ FormSW.CommandItem[tag: "Start"L, proc: Start];    RETURN[items, TRUE];    END;  MakeOptionsForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = FormOptionItems.LAST.ORD + 1;    aChips: ARRAY[0..4) OF Enumerated ¬ [      ["One"L, 1], ["Two"L, 2],      ["Three"L, 3], ["Four"L, 4]];    banksofMicrocode: ARRAY[0..4) OF Enumerated ¬ [      ["One"L, 1], ["Two"L, 2],      ["Three"L, 3], ["Four"L, 4]];    aChipAddressSwap: ARRAY[0..2) OF Enumerated ¬ [      ["True"L, ORD[TRUE]], ["False"L, ORD[FALSE]]];    useOpie: ARRAY[0..2) OF Enumerated ¬ [      ["True"L, ORD[TRUE]], ["False"L, ORD[FALSE]]];    items ¬ AllocateItemDescriptor[nItems];    items[FormOptionItems.aChips.ORD] ¬ EnumeratedItem[      tag: "'A' Chips"L, place: [6, line0], choices: DESCRIPTOR[aChips], value: @optionsWindowData.aChips];    items[FormOptionItems.apply.ORD] ¬ CommandItem[      tag: "Apply"L, place: [246, line0], proc: OptionsApply];    items[FormOptionItems.abort.ORD] ¬ CommandItem[      tag: "Abort"L, place: [294, line0], proc: OptionsAbort];    items[FormOptionItems.banksofMicrocode.ORD] ¬ EnumeratedItem[      tag: "Banks of Microcode"L, place: [12, line1], choices: DESCRIPTOR[banksofMicrocode], value: @optionsWindowData.banksofMicrocode];    items[FormOptionItems.aChipAddressSwap.ORD] ¬ EnumeratedItem[      tag: "'A' Chip Swap When Needed"L, place: [6, line2], choices: DESCRIPTOR[aChipAddressSwap], value: @optionsWindowData.aChipAddressSwap];    items[FormOptionItems.useOpie.ORD] ¬ EnumeratedItem[      tag: "Use Opie"L, place: [12, line3], choices: DESCRIPTOR[useOpie], value: @optionsWindowData.useOpie];    items[FormOptionItems.setBanksOnBoot.ORD] ¬ FormSW.BooleanItem[tag: "SetBanksOnBoot"L, switch: @optionsWindowData.setBanksOnBoot, place: [12, line4], readOnly: FALSE, drawBox: FALSE];    RETURN[items: items, freeDesc: TRUE];    };  ModifyTypeIn: PROCEDURE [newTypeIn: LONG STRING, replace: BOOLEAN] =    BEGIN    IF newTypeIn = NIL OR replace THEN typeIn.length ¬ 0;    IF newTypeIn # NIL THEN String.AppendStringAndGrow[@typeIn, newTypeIn, z];    FormSW.DisplayItem[lowerform, typeInIx];    END;        ClientTransition: ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      old = inactive =>        BEGIN	typeIn ¬ z.NEW[StringBody[20]];	run ¬ z.NEW[StringBody[20]];	state ¬ CPKernel.GetState[];	notifier ¬ UserInput.CreatePeriodicNotify[Watcher, window, Process.MsecToTicks[500]];        END;      new = inactive =>        BEGIN	notifier ¬ UserInput.CancelPeriodicNotify[notifier];	CPPanel.Destroy[];	CPCommand.SymbolDebugDestory[];	CPCommand.SourceDebugDestory[];	z.FREE[@typeIn];	z.FREE[@run];	IF uPCTypeIn # NIL THEN z.FREE[@uPCTypeIn];        IF NextuPCTypeIn # NIL THEN z.FREE[@NextuPCTypeIn];	IF optionsHandle # NIL THEN	   BEGIN	   Tool.Destroy[optionsHandle];	   optionsHandle ¬ NIL;	   END;        END;      ENDCASE;    END;          RegisterBermudaWindow: PROCEDURE [window: Window.Handle] =    BEGIN    IF bw = NIL THEN bw ¬ z.NEW[BurdockWindowSeq[10] ¬ []]      ELSE IF bw.length >= bw.maxlength THEN      BEGIN      oldBW: BurdockWindows ¬ bw;      bw ¬ z.NEW[BurdockWindowSeq[oldBW.maxlength + 10] ¬ [oldBW.length]];      Inline.LongCOPY[from: @oldBW[0], to: @bw[0], nwords: SIZE[Window.Handle, oldBW.length]];      z.FREE[@oldBW];      END;    bw[bw.length] ¬ window;    bw.length ¬ bw.length + 1;    END;      UnloadBermuda: Exec.ExecProc =    BEGIN    Exec.RemoveCommand [h, "CPBermudaDaisy.~"L];    IF optionsHandle # NIL THEN	BEGIN	Tool.Destroy[optionsHandle];	optionsHandle ¬ NIL;	END;    IF bw # NIL THEN      BEGIN      FOR i: CARDINAL IN [0..bw.length) DO        Tool.Destroy [bw[i]];      ENDLOOP;      z.FREE[@bw];      END;    END;	  IgnoreCommandLine: Exec.ExecProc =    BEGIN IF NOT initialized THEN Initialize[h]; END;  StartUp: PROCEDURE =    BEGIN Exec.AddCommand[name: "CPBermudaDaisy.~"L, proc: IgnoreCommandLine, unload: UnloadBermuda]; END;    StartUp[];  END.  -- Log:-- JAC   	 10-Jan-85 11:45:09	spell virtual correctly-- JAC   	 28-Jan-85 19:36:05	spell ToggleFlags correctly-- JAC   	 13-Mar-85 16:01:10	fix Run!-- JAC   	 18-Mar-85 12:10:51	unload Bermuda-- JAC   	 11-Jun-85 13:52:07	reanme to CPBermudaDaisy-- JAC   	 16-Jan-86 10:20:10	add memory offset stuff-- JAC/JWF   	 29-Aug-86 17:38:32	for new CPCommand-- JWF		  9-Dec-86 11:18:12	Added options window/ Removed offset
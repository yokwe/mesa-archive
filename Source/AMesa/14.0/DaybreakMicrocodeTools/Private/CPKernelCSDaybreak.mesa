-- Copyright (C) 1983, 1985  by Xerox Corporation. All rights reserved.-- Last edit by JAC	 7-Jun-85 12:26:52	copyrighted -- CPKernelCSDaybreak.mesa, JoM    , 11-Jan-85 14:53:33-- from CPKernelCSDicentra.mesa by HGM, 13-Nov-83  2:21:27DIRECTORY  Environment USING [Block, Byte],  Inline USING [BITXOR, HighByte, LowByte],  CP USING [RealCS, wordsPerBank],  CPKernel USING [CSBlock, Error, OneMI],  CPKernelConstants ,  CPKernelOps USING [AddressOutOfRange, CPMIBlock16, SetNewState, WriteCPWord],  CPMI USING [AD, AF, AS, FS01, FS23, FX, FY, FZ, MI],  IOPKernelOps USING [lock, InitializeLock],  Teather USING [Error, ReadBlock, WriteBlock, WriteWord];CPKernelCSDaybreak: MONITOR LOCKS IOPKernelOps.lock  IMPORTS    Inline, CPKernel, CPKernelOps, IOPKernelOps, Teather  EXPORTS CPKernel, CPKernelOps =  BEGIN OPEN CPKernelConstants;      WriteCS: PUBLIC ENTRY PROCEDURE [real: CP.RealCS, mi: CPMI.MI] =    BEGIN ENABLE UNWIND => NULL; WriteCSInternal[real, mi] END;  WriteCSInternal: PUBLIC INTERNAL PROCEDURE [real: CP.RealCS, mi: CPMI.MI] =    BEGIN    realMi: MIReal _ VirturalToReal[mi];    IF real ~IN CP.RealCS THEN CPKernelOps.AddressOutOfRange[];    WriteMIRealInternal[real, @realMi]    END;  WriteCSBlock16Internal: PUBLIC INTERNAL PROCEDURE [real: CP.RealCS, block: CPKernelOps.CPMIBlock16] =    BEGIN    IF real ~IN CP.RealCS THEN CPKernelOps.AddressOutOfRange[];    FOR i: CARDINAL IN [0..16) DO      realMi: MIReal _ VirturalToReal[block[i]];      WriteMIRealInternal[(real + i), @realMi]    ENDLOOP    END;  WriteCSBad: PUBLIC ENTRY PROCEDURE [real: CP.RealCS, mi: CPMI.MI] =    BEGIN ENABLE UNWIND => NULL; WriteCSBadInternal[real, mi] END;  WriteCSBadInternal: PUBLIC INTERNAL PROCEDURE [real: CP.RealCS, mi: CPMI.MI] =    BEGIN    realMi: MIReal _ VirturalToReal[mi];    IF real ~IN CP.RealCS THEN CPKernelOps.AddressOutOfRange[];    realMi.ep _ ~realMi.ep;    WriteMIRealInternal[real, @realMi]    END;  -- Parity better be right  WriteMIRealInternal: INTERNAL PROCEDURE [real: CP.RealCS, mi: LONG POINTER TO MIReal] =    BEGIN ENABLE      Teather.Error => BEGIN CPKernelOps.SetNewState[dead]; CPKernel.Error[reason]; END;    words: LONG POINTER = mi;    temp: PACKED ARRAY [0..8) OF Environment.Byte;    block: Environment.Block _ [LOOPHOLE[LONG[@temp]], 0, 8];    IF FALSE THEN      BEGIN      CPKernelOps.WriteCPWord[real];        -- Send CSAddr[0-11]      CPKernelOps.WriteCPWord[(words+0)^];  -- Write CS[0-15]      CPKernelOps.WriteCPWord[(words+1)^];  -- Write CS[16-31]      CPKernelOps.WriteCPWord[(words+2)^];  -- Write CS[32-47]      RETURN;      END;    temp[0] _ Inline.HighByte[real];    temp[1] _ Inline.LowByte[real];    temp[2] _ Inline.HighByte[(words+0)^];    temp[3] _ Inline.LowByte[(words+0)^];    temp[4] _ Inline.HighByte[(words+1)^];    temp[5] _ Inline.LowByte[(words+1)^];    temp[6] _ Inline.HighByte[(words+2)^];    temp[7] _ Inline.LowByte[(words+2)^];    Teather.WriteBlock[csaMsb, block];    END;  WriteCSBlock: PUBLIC ENTRY PROCEDURE [count: CARDINAL, clump: LONG POINTER TO CPKernel.CSBlock] =    BEGIN ENABLE UNWIND => NULL;    WriteCSBlockInternal[count, @clump[0]];    END;  WriteCSBlockInternal: PUBLIC INTERNAL PROCEDURE [count: CARDINAL, clump: LONG POINTER TO CPKernel.OneMI] =    BEGIN ENABLE      Teather.Error => BEGIN CPKernelOps.SetNewState[dead]; CPKernel.Error[reason]; END;    finger: CARDINAL _ 0;    bytesPerMi: CARDINAL = 8;    bufferSize: CARDINAL = 10*bytesPerMi;    temp: PACKED ARRAY [0..bufferSize) OF Environment.Byte;    block: Environment.Block _ [LOOPHOLE[LONG[@temp]], 0, bufferSize];    IF FALSE THEN      BEGIN      FOR i: CARDINAL IN [0..count) DO        real: MIReal _ VirturalToReal[clump.mi];	WriteMIRealInternal[clump.real, @real];        clump _ clump + SIZE[CPKernel.OneMI];	ENDLOOP;      RETURN;      END;    FOR i: CARDINAL IN [0..count) DO      real: MIReal _ VirturalToReal[clump.mi];      words: POINTER = @real;      temp[finger + 0] _ Inline.HighByte[clump.real];      temp[finger + 1] _ Inline.LowByte[clump.real];      temp[finger + 2] _ Inline.HighByte[(words+0)^];      temp[finger + 3] _ Inline.LowByte[(words+0)^];      temp[finger + 4] _ Inline.HighByte[(words+1)^];      temp[finger + 5] _ Inline.LowByte[(words+1)^];      temp[finger + 6] _ Inline.HighByte[(words+2)^];      temp[finger + 7] _ Inline.LowByte[(words+2)^];      finger _ finger + bytesPerMi;      IF finger = bufferSize THEN        BEGIN        Teather.WriteBlock[csaMsb, block];	finger _ 0;	END;      clump _ clump + SIZE[CPKernel.OneMI];      ENDLOOP;    IF finger # 0 THEN      BEGIN      block.stopIndexPlusOne _ finger;      Teather.WriteBlock[csaMsb, block];      END;    END;  ReadCS: PUBLIC ENTRY PROCEDURE [real: CP.RealCS] RETURNS [CPMI.MI] =    BEGIN ENABLE UNWIND => NULL; RETURN[ReadCSInternal[real]] END;  ReadCSInternal: PUBLIC INTERNAL PROCEDURE [real: CP.RealCS] RETURNS [CPMI.MI] =    BEGIN    realMi: MIReal;    IF real ~IN CP.RealCS THEN CPKernelOps.AddressOutOfRange[];    ReadMIRealInternal[real, @realMi];    RETURN[RealToVirtual[realMi]];    END;  ReadCSBlock16Internal: PUBLIC INTERNAL PROCEDURE [real: CP.RealCS, block: CPKernelOps.CPMIBlock16] =    BEGIN    IF real ~IN CP.RealCS THEN CPKernelOps.AddressOutOfRange[];    FOR i: CARDINAL IN [0..16) DO      realMi: MIReal;      ReadMIRealInternal[(real + i), @realMi];      block[i] _ RealToVirtual[realMi]    ENDLOOP    END;  ReadMIRealInternal: INTERNAL PROCEDURE [real: CP.RealCS, mi: LONG POINTER TO MIReal] =    BEGIN ENABLE      Teather.Error => BEGIN CPKernelOps.SetNewState[dead]; CPKernel.Error[reason]; END;    block: Environment.Block _ [LOOPHOLE[mi], 0, 2*SIZE[MIReal]];    Teather.WriteWord[csaMsb, real];    Teather.ReadBlock[csData0, block];    END;  MIReal: TYPE = MACHINE DEPENDENT RECORD [    rA, rB: Nibble,    aS: CPMI.AS, aF: CPMI.AF,    aD: CPMI.AD,  --word 0    ep, cIn, enSU, mem: BOOLEAN,    fS01: CPMI.FS01, fS23: CPMI.FS23,    fX: CPMI.FX, fY: CPMI.FY,  --word 1    fZ: CPMI.FZ, inia: [0..CP.wordsPerBank)];  --word 2  -- See also FixupMI in MakeControlStoreMB  VirturalToReal: PROCEDURE [virtural: CPMI.MI] RETURNS [real: MIReal] =    BEGIN    mir: POINTER TO MIReal = @real;    miv: POINTER TO CPMI.MI = @virtural;    BEGIN OPEN miv;    mir^ _ [      rA, rB, aS, aF, aD, ep, cIn, enSU, mem, fS01, fS23, fX, fY, fZ, Inline.BITXOR[inia,17B]]    END    END;  RealToVirtual: PROCEDURE [real: MIReal] RETURNS [virtual: CPMI.MI] =    BEGIN    mir: POINTER TO MIReal = @real;    miv: POINTER TO CPMI.MI = @virtual;    BEGIN OPEN mir;    miv^ _ [      rA, rB, aS, aF, aD, ep, cIn, enSU, mem, fS01, fS23, fX, fY, fZ, Inline.BITXOR[inia,17B]]    END;    END;  [] _ IOPKernelOps.InitializeLock[];  END.
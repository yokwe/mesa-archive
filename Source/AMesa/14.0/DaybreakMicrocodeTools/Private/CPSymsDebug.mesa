-- Copyright (C) 1985  by Xerox Corporation. All rights reserved.-- Last edit by JAC	 7-Jun-85 12:26:52	copyrighted -- CPSymsDebug.mesa, JoM    , 24-Jan-85 13:35:39DIRECTORY  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, CommandItem,    newLine, ProcType],  Put USING [CR, Decimal, Line, Number, Text],  Runtime USING [GetBcdTime],  String USING [AppendString],  Time USING [Append, Unpack],  Tool USING [Create, MakeFormSW, MakeFileSW, MakeSWsProc, UnusedLogName],  ToolWindow USING [TransitionProcType],  UserInput USING [UserAbort],  Version USING [Append],  Window USING [Handle],    BurdockControl USING [RegisterBurdockWindow],  CP USING [Cycle, RealCS, RReg, UReg],  CPSymbols USING [    AppendAllRReg, AppendAllRH, AppendAllUReg, AppendNumber, AppendVirturalCS,    EnumerateCSSymbols, EnumerateRRegSymbols, EnumerateRHSymbols,    EnumerateURegSymbols, EnumerateMap,    LookupInRHTable, LookupInRRegTable, LookupInURegTable, VirturalCS];CPSymsDebug: PROGRAM  IMPORTS    FormSW, Put, Runtime, String, Time, Tool, UserInput, Version,    BurdockControl, CPSymbols =  BEGIN    form, log: Window.Handle;  CS: FormSW.ProcType =    BEGIN    n: CARDINAL _ 0;    PrintOne: PROCEDURE [s: LONG STRING, virt: CPSymbols.VirturalCS] =      BEGIN      n ¬ n + 1;      IF UserInput.UserAbort[log] THEN RETURN;      Put.Number[log, virt, [16, FALSE, TRUE, 4]];      Put.Text[log, "  "L];      Put.Text[log, s];      Put.CR[log];      END;    Put.Line[log, "Control Store symbols"L];    CPSymbols.EnumerateCSSymbols[PrintOne];    Put.Text[log, "There are "L];    Put.Decimal[log, n];    Put.Line[log, " Control Store symbols."L];    Put.CR[log];    END;  Map: FormSW.ProcType =    BEGIN    n: CARDINAL _ 0;    PrintOne: PROCEDURE [real: CP.RealCS, virt: CPSymbols.VirturalCS, cycle: CP.Cycle] =      BEGIN      n ¬ n + 1;      IF UserInput.UserAbort[log] THEN RETURN;      Put.Number[log, real, [16, FALSE, TRUE, 4]];      Put.Number[log, virt, [16, FALSE, TRUE, 5]];      SELECT cycle FROM        c1 => Put.Text[log, " c1"L];        c2 => Put.Text[log, " c2"L];        c3 => Put.Text[log, " c3"L];        any => Put.Text[log, " c*"L];        ENDCASE => ERROR;      Put.CR[log];      END;    Put.Line[log, "Control Storage Map Info"L];    Put.Line[log, "real virt cy"L];    CPSymbols.EnumerateMap[PrintOne];    Put.Text[log, "There are "L];    Put.Decimal[log, n];    Put.Line[log, " active map slots."L];    Put.CR[log];    END;	  Info: FormSW.ProcType =    BEGIN    n: CARDINAL _ 0;    PrintOne: PROCEDURE [real: CP.RealCS, virt: CPSymbols.VirturalCS, cycle: CP.Cycle] =      BEGIN      temp: STRING = [100];      n ¬ n + 1;      IF UserInput.UserAbort[log] THEN RETURN;      Put.Number[log, real, [16, FALSE, TRUE, 4]];      Put.Number[log, virt, [16, FALSE, TRUE, 5]];      SELECT cycle FROM        c1 => Put.Text[log, " c1"L];        c2 => Put.Text[log, " c2"L];        c3 => Put.Text[log, " c3"L];        any => Put.Text[log, " c*"L];        ENDCASE => ERROR;      Put.Text[log, "  "L];      CPSymbols.AppendVirturalCS[temp, virt];      Put.Text[log, temp];      Put.CR[log];      END;    Put.Line[log, "Control Storage Map+Symbol Info"L];    Put.Line[log, "real virt cy   symbol"L];    CPSymbols.EnumerateMap[PrintOne];    Put.Text[log, "There are "L];    Put.Decimal[log, n];    Put.Line[log, " active map slots."L];    Put.CR[log];    END;	  Duplicates: FormSW.ProcType =    BEGIN    PrintDuplicates: PROCEDURE [s: LONG STRING, virt: CPSymbols.VirturalCS] =      BEGIN      ok: BOOLEAN;      r: CP.RReg;      u: CP.UReg;      [ok, r] ¬ CPSymbols.LookupInRRegTable[s];      IF ok THEN        BEGIN	Put.Text[log, "CS symbol "L];	Put.Text[log, s];	Put.Text[log, " clashes with .R "L];        Put.Number[log, r, [16, FALSE, TRUE, 1]];	Put.Line[log, "."L];	END;      [ok, r] _ CPSymbols.LookupInRHTable[s];      IF ok THEN        BEGIN	Put.Text[log, "CS symbol "L];	Put.Text[log, s];	Put.Text[log, " clashes with .RH "L];        Put.Number[log, r, [16, FALSE, TRUE, 1]];	Put.Line[log, "."L];	END;      [ok, u] _ CPSymbols.LookupInURegTable[s];      IF ok THEN        BEGIN	Put.Text[log, "CS symbol "L];	Put.Text[log, s];	Put.Text[log, " clashes with .U "L];        Put.Number[log, u, [16, FALSE, TRUE, 2]];	Put.Line[log, "."L];	END;      END;    Put.Line[log, "Scaning for Duplicate symbols:"L];    CPSymbols.EnumerateCSSymbols[PrintDuplicates];    Put.Line[log, "Done."L];    END;	  RRegs: FormSW.ProcType =    BEGIN    n: CARDINAL _ 0;    PrintOne: PROCEDURE [s: LONG STRING, r: CP.RReg] =      BEGIN      n _ n + 1;      IF UserInput.UserAbort[log] THEN RETURN;      Put.Number[log, r, [16, FALSE, TRUE, 4]];      Put.Text[log, "  "L];      Put.Text[log, s];      Put.CR[log];      END;    Put.Line[log, "R Register symbols"L];    CPSymbols.EnumerateRRegSymbols[PrintOne];    Put.Text[log, "There are "L];    Put.Decimal[log, n];    Put.Line[log, " R register symbols."L];    Put.CR[log];    END;  RRegsTable: FormSW.ProcType =    BEGIN    Put.Line[log, "R Register table"L];    FOR r: CP.RReg IN CP.RReg DO      temp: STRING = [200];      String.AppendString[temp, ".R "L];      CPSymbols.AppendNumber[temp, r];      String.AppendString[temp, " = "L];      CPSymbols.AppendAllRReg[temp, r];      Put.Text[log, temp];      Put.Line[log, "."];      ENDLOOP;    Put.CR[log];    END;      RHRegs: FormSW.ProcType =    BEGIN    n: CARDINAL _ 0;    PrintOne: PROCEDURE [s: LONG STRING, r: CP.RReg] =      BEGIN      n _ n + 1;      IF UserInput.UserAbort[log] THEN RETURN;      Put.Number[log, r, [16, FALSE, TRUE, 4]];      Put.Text[log, "  "L];      Put.Text[log, s];      Put.CR[log];      END;    Put.Line[log, "RH Register symbols"L];    CPSymbols.EnumerateRHSymbols[PrintOne];    Put.Text[log, "There are "L];    Put.Decimal[log, n];    Put.Line[log, " RH register symbols."L];    Put.CR[log];    END;  RHRegsTable: FormSW.ProcType =    BEGIN    Put.Line[log, "RH Register table"L];    FOR r: CP.RReg IN CP.RReg DO      temp: STRING = [200];      String.AppendString[temp, ".RH "L];      CPSymbols.AppendNumber[temp, r];      String.AppendString[temp, " = "L];      CPSymbols.AppendAllRH[temp, r];      Put.Text[log, temp];      Put.Line[log, "."];      ENDLOOP;    Put.CR[log];    END;      URegs: FormSW.ProcType =    BEGIN    n: CARDINAL _ 0;    PrintOne: PROCEDURE [s: LONG STRING, u: CP.UReg] =      BEGIN      n _ n + 1;      IF UserInput.UserAbort[log] THEN RETURN;      Put.Number[log, u, [16, FALSE, TRUE, 4]];      Put.Text[log, "  "L];      Put.Text[log, s];      Put.CR[log];      END;    Put.Line[log, "U Register symbols"L];    CPSymbols.EnumerateURegSymbols[PrintOne];    Put.Text[log, "There are "L];    Put.Decimal[log, n];    Put.Line[log, " U Register symbols."L];    Put.CR[log];    END;  URegsTable: FormSW.ProcType =    BEGIN    Put.Line[log, "U Register table"L];    FOR u: CP.UReg IN CP.UReg DO      temp: STRING = [200];      String.AppendString[temp, ".U "L];      CPSymbols.AppendNumber[temp, u];      String.AppendString[temp, " = "L];      CPSymbols.AppendAllUReg[temp, u];      Put.Text[log, temp];      Put.Line[log, "."];      ENDLOOP;    Put.CR[log];    END;      Initialize: PROCEDURE =    BEGIN    herald: STRING = [100];    String.AppendString[herald, "CPSymbols Debug "L];    Version.Append[herald];    String.AppendString[herald, " of "L];    Time.Append[herald, Time.Unpack[Runtime.GetBcdTime[]]];    BurdockControl.RegisterBurdockWindow[Tool.Create[      name: herald,      cmSection: "CPSyms Debug"L,      initialState: inactive,      makeSWsProc: MakeSWs,      clientTransition: ClientTransition]];    END;    MakeSWs: Tool.MakeSWsProc =    BEGIN    logFileName: STRING = [40];    Tool.UnusedLogName[logFileName, "CPSymsDebug.log$"L];    form _ Tool.MakeFormSW[window: window, formProc: MakeForm];    log _ Tool.MakeFileSW[window: window, name: logFileName];    END;    MakeForm: FormSW.ClientItemsProcType =    BEGIN    nParams: CARDINAL = 10;    items _ FormSW.AllocateItemDescriptor[nParams];    items[0] _ FormSW.CommandItem[tag: "CS"L, proc: CS, place: FormSW.newLine];    items[1] _ FormSW.CommandItem[tag: "Map"L, proc: Map];    items[2] _ FormSW.CommandItem[tag: "Info"L, proc: Info];    items[3] _ FormSW.CommandItem[tag: "Duplicates"L, proc: Duplicates];    items[4] _ FormSW.CommandItem[tag: "RRegs"L, proc: RRegs, place: FormSW.newLine];    items[5] _ FormSW.CommandItem[tag: "RRegsTable"L, proc: RRegsTable];    items[6] _ FormSW.CommandItem[tag: "RHRegs"L, proc: RHRegs, place: FormSW.newLine];    items[7] _ FormSW.CommandItem[tag: "RHRegsTable"L, proc: RHRegsTable];    items[8] _ FormSW.CommandItem[tag: "URegs"L, proc: URegs, place: FormSW.newLine];    items[9] _ FormSW.CommandItem[tag: "URegsTable"L, proc: URegsTable];    RETURN[items, TRUE];    END;       ClientTransition: ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      old = inactive =>        BEGIN        END;      new = inactive =>        BEGIN        END;      ENDCASE;    END;	  Initialize[];  END.
-- Copyright (C) 1984, 1985  by Xerox Corporation. All rights reserved.-- Last edit by JAC	 7-Jun-85 14:45:52	fix microcode names -- CPKernelDaybreak.mesa, JoM    , 6-Feb-85 17:17:18-- from CPKernelDicentra.mesa, HGM, 19-Feb-84 18:03:48DIRECTORY  Environment USING [Block, Byte],  Inline USING [BITAND, BITOR, BITSHIFT, HighByte, HighHalf, LowByte, LowHalf],  Runtime USING [GetTableBase],  BurdockTables USING [    KernelDaybreak, ReadLinkDaybreak, ResetMapDaybreak, WriteIBDaybreak],  CP USING [    Bank, BankAndWordsPerBank, Cycle, Link, numberOfBanks,    RealCS, UReg, wordsPerBank],  CPKernel USING [Error, Machine, State],  CPKernelConstants ,  CPKernelOps USING [    AddressOutOfRange, Command, DataOutOfRange, LoadFromMemory, LoadOverlay,    PrepareToContinueAfterBreak, PrepareToContinueAfterStop, PrepareToStart,    ReadCSBlock16Internal, ReadCSInternal,    SaveCurrentBreakID, WriteCSInternal, WriteCSBlock16Internal],  CPMI USING [AD, AF, AS, FS01, FS23, FX, FY, FYNorm, FZ, MI],  CPStop USING [],  IOPKernelOps USING [lock, InitializeLock],  Teather USING [    Boot, Continue, Error, Initialize,    PokeInit, ReadWord, ReadCPByte, ReadCPReady,    SingleCycleFromCSA, Stop, WriteCPByte,    WriteCPBlock, WriteCPWord, WriteWord];CPKernelDaybreak: MONITOR LOCKS IOPKernelOps.lock  IMPORTS    Inline, Runtime,    BurdockTables, CPKernel, CPKernelOps, IOPKernelOps, Teather  EXPORTS CPKernel, CPKernelOps, CPStop =  BEGIN OPEN CPKernelConstants;  machine: PUBLIC CPKernel.Machine _ daybreak;  maxBreaks: PUBLIC CARDINAL _ 255;  mapOffset: PUBLIC LONG CARDINAL _ 40000H;      state: CPKernel.State _ dead;  seq, boot: CARDINAL _ 0;  kernelLoaded: BOOLEAN _ FALSE;  currentBank, savedBank: CARDINAL _ 0;  banksThisMachine: CARDINAL _ 0;  savedNIA: CP.RealCS _ 0;  savedCycle: CP.Cycle _ any;  InKernel: PUBLIC ENTRY PROCEDURE RETURNS [BOOLEAN] =    BEGIN ENABLE UNWIND => NULL;    RETURN[SELECT state FROM      dead => FALSE,      halted => TRUE,      running => FALSE,      cpBreak, iopStopped => TRUE,      ENDCASE => ERROR ];    END;        GetState: PUBLIC ENTRY PROCEDURE RETURNS [CPKernel.State] =    BEGIN    RETURN[state];    END;  GetStateInternal: PUBLIC INTERNAL PROCEDURE RETURNS [CPKernel.State] =    BEGIN    RETURN[state];    END;  GetStateSeq: PUBLIC ENTRY PROCEDURE RETURNS [CARDINAL] =    BEGIN    RETURN[seq];    END;    GetBootSeq: PUBLIC ENTRY PROCEDURE RETURNS [CARDINAL] =    BEGIN    RETURN[boot];    END;    GetStopCS: PUBLIC ENTRY PROCEDURE RETURNS [CP.RealCS] =    BEGIN    disp: CARDINAL _ IF savedCycle = any THEN ReadUSpecial[uKSaveDisp] ELSE 0;    RETURN [savedNIA + (disp MOD 16)];    END;    SetContinueInfo: PUBLIC ENTRY PROCEDURE [realCS: CP.RealCS, cycle: CP.Cycle] =    BEGIN    savedNIA _ realCS;    savedBank _ LOOPHOLE[savedNIA, CP.BankAndWordsPerBank].bank;    savedCycle _ cycle;    END;  ProbeForStateChange: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE      BEGIN      Teather.Error => IF state = dead THEN GOTO cantProbe ELSE        BEGIN SetNewState[dead]; CPKernel.Error[reason]; END;      UNWIND => NULL;      END;    breakByte: Environment.Byte;    IF state = halted OR state = cpBreak THEN RETURN;    IF ~Teather.ReadCPReady[      ! Teather.Error => GOTO cantProbe ] THEN RETURN;    -- The only reason that it sends us anything is to tell us about a breakpoint    breakByte _ Teather.ReadCPByte[];    kernelLoaded _ TRUE; -- bootloaded, perhaps    IF currentBank # 0 THEN      BEGIN      Teather.Stop[];      SetNewBank[0];      Teather.Continue[];      END;    SetNewState[(IF breakByte = maxBreaks THEN halted ELSE cpBreak)];    CPKernelOps.SaveCurrentBreakID[];    savedNIA _ 0;    savedBank _ 0;    savedCycle _ any;    EXITS      cantProbe => NULL;    END;    Boot: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE      BEGIN      Teather.Error => CPKernel.Error[reason];      UNWIND => NULL;      END;    SetNewState[dead];    boot _ boot + 1;    kernelLoaded _ FALSE;    currentBank _ savedBank _ 0;    banksThisMachine _ 1;    Teather.Initialize[];    Teather.Boot[];    END;    HalfBoot: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE      BEGIN      Teather.Error => CPKernel.Error[reason];      UNWIND => NULL;      END;    SetNewState[dead];    boot _ boot + 1;    kernelLoaded _ FALSE;    currentBank _ savedBank _ 0;    banksThisMachine _ 1;    Teather.Initialize[];    Teather.Boot[];    SetNewState[halted];    END;    FindBanks: PUBLIC ENTRY PROCEDURE RETURNS [CP.Bank] =    BEGIN ENABLE UNWIND => NULL;    Teather.Stop[];  -- Kernel is running..    banksThisMachine _ CP.numberOfBanks;  -- Bypass error trap    FOR bank: CP.Bank IN [1..CP.numberOfBanks) DO      cs: CP.RealCS = bank * CP.wordsPerBank + kBuffer + 2;  -- SetNewBank uses kBuffer[0..1]      Three: TYPE = RECORD [a, b, c: WORD];      address: CPMI.MI = LOOPHOLE[Three[cs, 0, cs]];  -- parity      CPKernelOps.WriteCSInternal[cs, address];      IF CPKernelOps.ReadCSInternal[kBuffer + 2] = address THEN        BEGIN	IF bank # 1 THEN ERROR CPKernel.Error["Bank searching mixup - write smashed bank 0"L];	Teather.Continue[];	RETURN[banksThisMachine _ 1];	END;      IF CPKernelOps.ReadCSInternal[cs] # address THEN        BEGIN	Teather.Continue[];	RETURN[banksThisMachine _ bank];	END;      ENDLOOP;    Teather.Continue[];    RETURN[banksThisMachine _ CP.numberOfBanks];    END;    Reset: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE UNWIND => NULL;    SetNewState[dead];    boot _ boot + 1;    savedBank _ 0;    SetNewState[halted];    END;    LoadKernel: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE UNWIND => NULL;    SetNewBank[0];    CPKernelOps.LoadFromMemory[Runtime.GetTableBase[BurdockTables.KernelDaybreak], 0];    END;    LoadKernelHigh: PUBLIC ENTRY PROCEDURE [bank: CP.Bank] =    BEGIN ENABLE UNWIND => NULL;    SetNewBank[bank];    CPKernelOps.LoadFromMemory[Runtime.GetTableBase[BurdockTables.KernelDaybreak], bank];    SetNewBank[0];    END;    StartKernel: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE      BEGIN      Teather.Error => BEGIN SetNewState[dead]; CPKernel.Error[reason]; END;      UNWIND => NULL;      END;    temp: PACKED ARRAY [0..3) OF Environment.Byte;    block: Environment.Block _ [LOOPHOLE[LONG[@temp]], 0, 3];    Teather.Continue[];    Teather.PokeInit[]; -- Kernel catches all Traps.    IF FALSE THEN      BEGIN      WriteCPCommandInternal[readU];      WriteCPByte[uBreakID];      WriteCPByte[1];      END ELSE      BEGIN      temp _ [        LOOPHOLE[CPKernelOps.Command[readU]],        uBreakID,	1];      Teather.WriteCPBlock[block];      END;    IF Teather.ReadCPByte[] # 0FFH -- will time out if Kernel not started properly      THEN ERROR CPKernel.Error["Kernel not responding"L];    SetNewState[halted];    kernelLoaded _ TRUE;    savedNIA _ 0;    savedBank _ 0;    savedCycle _ c1;    END;    Continue: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE      BEGIN      Teather.Error => BEGIN SetNewState[dead]; CPKernel.Error[reason]; END;      UNWIND => NULL;      END;    Teather.Stop[];    SetNewBank[savedBank];    IF savedCycle = any      THEN CPKernelOps.PrepareToContinueAfterStop[savedNIA, savedBank]      ELSE CPKernelOps.PrepareToStart[savedNIA, savedCycle, savedBank];    SetNewState[running];    Teather.Continue[];    WriteCPCommandInternal[executeBuffer];    END;    ContinueAfterBreak: PUBLIC ENTRY PROCEDURE [    mi: CPMI.MI, cycle: CP.Cycle] =    BEGIN ENABLE      BEGIN      Teather.Error => BEGIN SetNewState[dead]; CPKernel.Error[reason]; END;      UNWIND => NULL;      END;    Teather.Stop[];    SetNewBank[savedBank];    CPKernelOps.PrepareToContinueAfterBreak[mi, cycle, savedBank];    SetNewState[running];    Teather.Continue[];    WriteCPCommandInternal[executeBuffer];    END;  Start: PUBLIC ENTRY PROCEDURE [pc: CP.RealCS, cycle: CP.Cycle] =    BEGIN ENABLE      BEGIN      Teather.Error => BEGIN SetNewState[dead]; CPKernel.Error[reason]; END;      UNWIND => NULL;      END;    Teather.Stop[];    SetNewBank[LOOPHOLE[pc, CP.BankAndWordsPerBank].bank];    CPKernelOps.PrepareToStart[LOOPHOLE[pc, CP.BankAndWordsPerBank].wordInBank, cycle, currentBank];    SetNewState[running];    Teather.Continue[];    WriteCPCommandInternal[executeBuffer];    END;    Stop: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE      BEGIN      Teather.Error => BEGIN SetNewState[dead]; CPKernel.Error[reason]; END;      UNWIND => NULL;      END;    SELECT state FROM      dead => ERROR CPKernel.Error["CP/IOP is dead"L];      halted => RETURN;      running => NULL;      cpBreak, iopStopped => RETURN;      ENDCASE => ERROR;    savedNIA _ GetCleanPCAndStartKernel[];    savedBank _ LOOPHOLE[savedNIA, CP.BankAndWordsPerBank].bank;    savedCycle _ any;    Teather.Stop[];    SetNewBank[0];    Teather.Continue[];    CPKernelOps.SaveCurrentBreakID[];    SetNewState[halted];    END;    MaybeSetNewState: INTERNAL PROCEDURE [new: CPKernel.State] =    BEGIN    IF state = new THEN RETURN;    SetNewState[new];    END;    SetNewState: PUBLIC INTERNAL PROCEDURE [new: CPKernel.State] =    BEGIN    seq _ seq + 1;    state _ new;    END;  WriteCPCommandInternal: PUBLIC INTERNAL PROCEDURE [command: CPKernelOps.Command] =    BEGIN    WriteCPByte[LOOPHOLE[command]];    END;  WriteCPByte: PUBLIC INTERNAL PROCEDURE [data: Environment.Byte] =    BEGIN ENABLE      Teather.Error => BEGIN SetNewState[dead]; CPKernel.Error[reason]; END;    Teather.WriteCPByte[data];    END;      WriteCPWord: PUBLIC INTERNAL PROCEDURE [data: WORD] =    BEGIN ENABLE      Teather.Error => BEGIN SetNewState[dead]; CPKernel.Error[reason]; END;    Teather.WriteCPWord[data];    END;      ReadCPByte: PUBLIC INTERNAL PROCEDURE RETURNS [Environment.Byte] =    BEGIN ENABLE      Teather.Error => BEGIN SetNewState[dead]; CPKernel.Error[reason]; END;    RETURN[Teather.ReadCPByte[]];    END;  WriteBank: PUBLIC ENTRY PROCEDURE [bank: CP.Bank] =    BEGIN ENABLE      BEGIN      Teather.Error => BEGIN SetNewState[dead]; CPKernel.Error[reason]; END;      UNWIND => NULL;      END;    Teather.Stop[];    SetNewBank[bank];  -- Validity check    savedBank _ bank;    SetNewBank[0];    Teather.Continue[];    END;  RawWriteBank: PUBLIC ENTRY PROCEDURE [bank: CP.Bank] =    BEGIN ENABLE UNWIND => NULL;    -- Yetch, copy all this code to avoid error trap    IF (kBuffer + 11) # 0FFFH THEN ERROR;  -- Catch dangling branch    IF ~kernelLoaded THEN ERROR CPKernel.Error["Can't switch banks until Kernel has been loaded"L];    IF currentBank # 0 THEN      BEGIN      currentBank _ 0;      ExecuteCPBuffer[];  -- The instruction we left behind      END;    IF bank = 0 THEN RETURN;    CPKernelOps.WriteCSInternal[      kBuffer + 0, CPMI.MI[      , , dz, rOrS, , , , , , , nibble, , [n[bank]], [d[0]], kWait]];    CPKernelOps.WriteCSInternal[      kBuffer + 1, CPMI.MI[      , , dz, rOrS, , , , , , , nibble, , [n[bank]], [d[bank]], kBuffer + 11]];    CPKernelOps.WriteCSInternal[      kBuffer + 11, CPMI.MI[      , , , , , , , , , , , , , , kWait]];    currentBank _ bank;    END;  SetNewBank: PUBLIC INTERNAL PROCEDURE [bank: CP.Bank] =    BEGIN ENABLE      BEGIN      Teather.Error => BEGIN SetNewState[dead]; CPKernel.Error[reason]; END;      UNWIND => NULL;      END;    locOfTemp: CP.RealCS = kBuffer + 11;    IF bank = currentBank THEN RETURN;    IF bank >= banksThisMachine THEN ERROR CPKernel.Error["Bank number too big"L];    CPKernelOps.WriteCSInternal[      locOfTemp, CPMI.MI[ , , dz, rOrS, , , , , , fyNorm, nibble, , [n[bank]], [d[bank]] , kWait]];    Teather.WriteWord[csaMsb, locOfTemp];    Teather.SingleCycleFromCSA[];    currentBank _ bank;    END;  ExecuteCPBuffer: PUBLIC INTERNAL PROCEDURE =    BEGIN    IF ~kernelLoaded THEN ERROR CPKernel.Error["Can't Execute Buffer before Kernel loaded"L];    WriteCPCommandInternal[executeBuffer];    END;  WriteUSpecial: PUBLIC INTERNAL PROCEDURE [u: CP.UReg, data: WORD] =    BEGIN ENABLE      Teather.Error => BEGIN SetNewState[dead]; CPKernel.Error[reason]; END;    temp: PACKED ARRAY [0..4) OF Environment.Byte;    block: Environment.Block _ [LOOPHOLE[LONG[@temp]], 0, 4];    IF ~kernelLoaded THEN ERROR CPKernel.Error["Can't WriteU before Kernel loaded"L];    IF FALSE THEN      BEGIN      WriteCPCommandInternal[writeU];      WriteCPByte[Inline.HighByte[data]];      WriteCPByte[Inline.LowByte[data]];      WriteCPByte[u];      RETURN;      END;    temp _ [      LOOPHOLE[CPKernelOps.Command[writeU]],      Inline.HighByte[data],      Inline.LowByte[data],      u];    Teather.WriteCPBlock[block];    END;    ReadUSpecial: PUBLIC INTERNAL PROCEDURE [u: CP.UReg] RETURNS [data: WORD] =    BEGIN ENABLE      Teather.Error => BEGIN SetNewState[dead]; CPKernel.Error[reason]; END;    temp: PACKED ARRAY [0..3) OF Environment.Byte;    block: Environment.Block _ [LOOPHOLE[LONG[@temp]], 0, 3];    IF ~kernelLoaded THEN ERROR CPKernel.Error["Can't ReadU before Kernel loaded"L];    IF FALSE THEN      BEGIN      WriteCPCommandInternal[readU];      WriteCPByte[u];      WriteCPByte[0];      END ELSE      BEGIN      temp _ [        LOOPHOLE[CPKernelOps.Command[readU]],        u,	0];      Teather.WriteCPBlock[block];      END;    data _ ReadCPByte[] * 256;    IF FALSE THEN      BEGIN      WriteCPCommandInternal[readU];      WriteCPByte[u];      WriteCPByte[1];      END ELSE      BEGIN      temp _ [        LOOPHOLE[CPKernelOps.Command[readU]],        u,	1];      Teather.WriteCPBlock[block];      END;    data _ data + ReadCPByte[];    END;    WriteRHrK: PUBLIC INTERNAL PROCEDURE [data: WORD] =    BEGIN ENABLE      Teather.Error => BEGIN SetNewState[dead]; CPKernel.Error[reason]; END;    temp: PACKED ARRAY [0..2) OF Environment.Byte;    block: Environment.Block _ [LOOPHOLE[LONG[@temp]], 0, 2];    IF ~kernelLoaded THEN ERROR CPKernel.Error["Can't WriteRHrK before Kernel loaded"L];    IF FALSE THEN      BEGIN      WriteCPCommandInternal[writeRHrK];      WriteCPByte[data];      RETURN;      END;    temp _ [      LOOPHOLE[CPKernelOps.Command[writeRHrK]],      data];    Teather.WriteCPBlock[block];    END;    ReadBank: PUBLIC ENTRY PROCEDURE RETURNS [CP.Bank] =    BEGIN ENABLE UNWIND => NULL;    RETURN[savedBank];    END;   RawReadBank: PUBLIC ENTRY PROCEDURE RETURNS [CP.Bank] =    BEGIN ENABLE UNWIND => NULL;    RETURN[RawReadBankInternal[]];    END;   RawReadBankInternal: INTERNAL PROCEDURE RETURNS [CP.Bank] =    BEGIN ENABLE      Teather.Error => BEGIN SetNewState[dead]; CPKernel.Error[reason]; END;    nia: CP.BankAndWordsPerBank;    nia _ LOOPHOLE[Teather.ReadWord[niaMsb]];    RETURN[nia.bank];    END;   -- We want to stop and save the PC.  -- If we just stop, the instruction in MIR will get lost.  -- So we stop, save NIA, and "breakpoint" all possible branches.  GetCleanPCAndStartKernel: INTERNAL PROCEDURE RETURNS [nia: CP.RealCS] =    BEGIN ENABLE      Teather.Error => BEGIN SetNewState[dead]; CPKernel.Error[reason]; END;    locOfTemp: CP.RealCS = kBuffer + 11;    saved16, temp16: ARRAY [0..16) OF CPMI.MI;    FOR i: CARDINAL IN [0..16) DO      temp16[i] _ CPMI.MI[      , rK, , , , , , , , byte, nibble, loadRH, [d[0FH]], [d[0FH]], kEntry + i];    ENDLOOP;    Teather.Stop[];    nia _ Teather.ReadWord[niaMsb];    nia _ Inline.BITAND[nia, 0FFF0H];    CPKernelOps.ReadCSBlock16Internal[nia, @saved16];    CPKernelOps.WriteCSBlock16Internal[nia, @temp16];    Teather.Continue[];    THROUGH [0 .. 10) DO      IF Teather.ReadCPReady[] THEN EXIT;    REPEAT      FINISHED => ERROR CPKernel.Error["Didn't get to kWait"L];    ENDLOOP;    [] _ Teather.ReadCPByte[];    Teather.Stop[];    CPKernelOps.WriteCSBlock16Internal[nia, @saved16];    Teather.Continue[];    END;  WriteMemoryBlock, WriteNextMemoryBlock: PUBLIC ENTRY PROCEDURE [    to: LONG POINTER, count: CARDINAL, data: LONG POINTER] =    BEGIN ENABLE      BEGIN      Teather.Error => BEGIN SetNewState[dead]; CPKernel.Error[reason]; END;      UNWIND => NULL;      END;    bufferSize: CARDINAL = 1000;    block: Environment.Block;    IF Inline.HighHalf[to] ~IN [0..1FH] THEN CPKernelOps.AddressOutOfRange[];    WriteRHrK[Inline.HighHalf[to]];    WriteUSpecial[uKAddr, Inline.LowHalf[to]];    WriteUSpecial[uKCount, count];    WriteCPCommandInternal[writeBlock];    IF FALSE THEN      BEGIN      FOR i: CARDINAL IN [0..count) DO        WriteCPWord[(data+i)^];        ENDLOOP;      RETURN;      END;    UNTIL count < bufferSize DO      block _ [data, 0, 2*bufferSize];      Teather.WriteCPBlock[block];      data _ data + bufferSize;      count _ count - bufferSize;      ENDLOOP;    IF count # 0 THEN      BEGIN      block _ [data, 0, 2*count];      Teather.WriteCPBlock[block];      END;    END;    ResetMap: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE UNWIND => NULL;    CPKernelOps.LoadOverlay[Runtime.GetTableBase[BurdockTables.ResetMapDaybreak]];    ExecuteCPBuffer[];    --this takes ~5 msec, overlay sends a byte when done to synchronize    [] _ ReadCPByte[]    END;  ReadLink: PUBLIC ENTRY PROCEDURE [link: CP.Link] RETURNS [data: Nibble] =    BEGIN ENABLE UNWIND => NULL;    -- Link is read in three parts: Link[2-3], Link[0], & Link[1].    -- Link[0] & Link[1] are read by 1-inst overlays at kBuffer + 1.    --kBuffer: L0Disp,				c1, at[kBuffer];    --	       DISP2[KLinkC],			c2, at[0FF5x] {+1};    --KLink7:  DebA_ 0, GOTO[kWait],		c3, at[0FF7x] {+3};    --KLinkB:  DebA_ 0, GOTO[kWait],		c3, at[0FFBx] {+7};    --KLinkC:  DebA_ 0, GOTO[kWait],		c3, at[0FFCx] {+8};    --         DebA_ 1, GOTO[kWait],		c3, at[0FFDx] {+9};    --         DebA_ 2, GOTO[kWait],		c3, at[0FFEx] {+A};    --KLinkF:  DebA_ 3, GOTO[kWait],		c3, at[0FFFx] {+B};    --         BRANCH[KLink7, KLinkF, 7], at[0FF5x];   {Get Link[0]}    --         BRANCH[KLinkB, KLinkF, 0B], at[0FF5x];   {Get Link[1]}    IF link ~IN CP.Link THEN CPKernelOps.AddressOutOfRange[];    CPKernelOps.LoadOverlay[Runtime.GetTableBase[BurdockTables.ReadLinkDaybreak]];    CPKernelOps.WriteCSInternal[kBuffer, CPMI.MI[      , , , , , , , , , , , LOOPHOLE[link], , , kBuffer + 1]];    ExecuteCPBuffer[];    data _ ReadCPByte[];  -- Link[2-3]    CPKernelOps.WriteCSInternal[kBuffer + 1, CPMI.MI[      , , , , , , , , , , , , , , kBuffer + 3]];    ExecuteCPBuffer[];    data _ Inline.BITOR[data, Inline.BITSHIFT[Inline.BITAND[ReadCPByte[], 1], 3]];  -- Link[0]    CPKernelOps.WriteCSInternal[kBuffer + 1, CPMI.MI[      , , , , , , , , , , , , , , kBuffer + 7]];    ExecuteCPBuffer[];    data _ Inline.BITOR[data, Inline.BITSHIFT[Inline.BITAND[ReadCPByte[], 1], 2]];  --Link[1]    END;  WriteIBInternal: PUBLIC INTERNAL PROCEDURE [data: WORD] =    BEGIN ENABLE UNWIND => NULL;    IF data ~IN [0..0FFH] THEN CPKernelOps.DataOutOfRange[];    CPKernelOps.LoadOverlay[Runtime.GetTableBase[BurdockTables.WriteIBDaybreak]];    WriteUSpecial[uKTemp, data];    ExecuteCPBuffer[];    END;  [] _ IOPKernelOps.InitializeLock[];  END.
-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. -- Last edit by JAC/JWF        29-Aug-86 17:26:12-- CPCommandImpl.mesa, AYC   , 21-Dec-84 10:56:44-- from CPCommander.mesa, HGM, 21-Jan-84 15:27:03--DIRECTORY  Format USING [Decimal, Line, Number, StringProc, Text],  Inline USING [BITOR, BITSHIFT],  Process USING [MsecToTicks, Pause],  String USING [AppendString, InvalidNumber, StringToNumber],  System USING [AdjustGreenwichMeanTime, GetGreenwichMeanTime, GreenwichMeanTime],    CommandFile USING [AbortProc],  CPCommand USING [Error, Load, RefreshWindow],  CPBreak USING [    Break, Error, FindBreak, GetLastBreakInfo, InstallBreaks, RemoveBreaks, Reset, Unbreak],  CPDef USING [Bank, IBDisp, IBDspB, MDR, RealCS, StartAddr, StartAddrPlusOne, wordsPerBank],  CPKernel USING [    AtBreak, AutoPollSirius, Boot, ContinueAfterBreak, ContinueAfterStop, Error,    FindBanks, GetBreakID, GetState, InKernel, optionsData, ProbeForStateChange, PollSirius, ReadOther,     savedBank, Start, StartSirius, StopSirius, State, Stop, WriteBank],  CPKernelDef USING [kPopIB, kWait],  CPKernelOps USING [SetShiftRegInternal, SetShiftRegflags, SetNewState],  CPPanel USING [Initialize, AppendPanelData],  CPSymbol USING [    AppendRealCS, AppendVirturalCS, ClearSymbolTable, Error, GetPcAndFlags, nullVirturalCS, RealToVirturalCS, VirturalCS],  CPuFormat USING [Bits4, mi, MI, uField];CPCommandImpl: PROGRAM  IMPORTS    Format, Inline, Process, String, System,    CPBreak, CPCommand, CPKernel, CPKernelOps, CPPanel, CPSymbol, CPuFormat  EXPORTS CPCommand =  BEGIN  Error: PUBLIC ERROR [reason: LONG STRING] = CODE;    Boot: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER] =    BEGIN ENABLE      BEGIN      CPBreak.Error => ERROR Error[reason];      CPKernel.Error => ERROR Error[reason];      END;    banks: CPDef.Bank;    Format.Text[log, "Booting CP ... "L, arg];    CPSymbol.ClearSymbolTable[];    CPBreak.Reset[];    CPKernelOps.SetShiftRegflags[FALSE, FALSE, FALSE];    CPKernel.Boot[log, arg];    Format.Text[log, "Loading Overlay Microcode ... "L, arg];    IF CPKernel.optionsData.setBanksOnBoot THEN       CPKernel.optionsData.banksofMicrocode ¬ CPKernel.FindBanks[];       <<    Format.Text[log, "Loading Breakpoint Trap Code ... "L, arg];    CPKernel.LoadKernel[];    CPPanel.Initialize[];    banks ¬ CPKernel.FindBanks[];    IF banks # 1 THEN      BEGIN      Format.Line[log, "ok."L, arg];      Format.Text[log, "This machine has "L, arg];      Format.Decimal[log, banks, arg];      Format.Text[log, " banks of control store.  Loading extra Kernels ... "L, arg];      FOR bank: CPDef.Bank IN [1..banks) DO        CPKernel.LoadKernelHigh[bank];        ENDLOOP;      CPKernel.WriteBank[0];      END;>>    CPCommand.RefreshWindow[];    PrintState[log, arg];    END;  LoadRaw: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, filename: LONG STRING, bank: CARDINAL] =    BEGIN ENABLE      BEGIN      CPBreak.Error => ERROR Error[reason];      CPKernel.Error => ERROR Error[reason];      END;    CPSymbol.ClearSymbolTable[];    CPBreak.Reset[];    CPKernel.Boot[log, arg];    CPCommand.Load[log, arg, filename, bank];    CPPanel.Initialize[];    END;  Reset: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER] =    BEGIN ENABLE      BEGIN      CPBreak.Error => ERROR Error[reason];      CPKernel.Error => ERROR Error[reason];      END;    IF ~CPKernel.InKernel[] THEN        ERROR CPKernel.Error["Aborted... CP not in Kernel"L];--  CPKernelOps.SetShiftRegflags[FALSE, FALSE, FALSE];    CPSymbol.ClearSymbolTable[];    CPBreak.Reset[];--  CPKernel.Reset[];--  CPPanel.Initialize[];		request to remove by DDavies    END;  SetPC: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, uPC, NextuPC: LONG STRING] =    BEGIN ENABLE CPKernel.Error => ERROR Error[reason];    upc, nextupc: CPDef.RealCS;    ibdisp: CPDef.IBDisp;    mdr: CPDef.MDR;    Format.Text[log, "Setting PC to "L, arg];    [upc, ibdisp, mdr] ¬ CPSymbol.GetPcAndFlags[uPC ! CPSymbol.Error => ERROR Error[reason]];    [nextupc, , ] ¬ CPSymbol.GetPcAndFlags[NextuPC ! CPSymbol.Error => ERROR Error[reason]];    Format.Text[log, uPC, arg];    Format.Text[log, " (= .CR "L, arg];    Format.Number[log, upc, [16, FALSE, TRUE, 0], arg];    IF mdr THEN Format.Text[log, " *MD maybe trash*"L, arg];    Format.Line[log, ")."L, arg];    Format.Text[log, "Setting NextuPC to "L, arg];    Format.Text[log, NextuPC, arg];    Format.Text[log, " (= .CR "L, arg];    Format.Number[log, nextupc, [16, FALSE, TRUE, 0], arg];    Format.Line[log, ")."L, arg];    IF ibdisp THEN ERROR Error["Can't set TPC to GOTO[*]"L];    CPKernelOps.SetShiftRegInternal[CPDef.StartAddr, upc];    CPKernelOps.SetShiftRegInternal[CPDef.StartAddrPlusOne, nextupc];    END;     Start: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, uPC, NextuPC: LONG STRING]  =    BEGIN ENABLE      BEGIN      CPBreak.Error => ERROR Error[reason];      CPKernel.Error => ERROR Error[reason];      END;--  CPKernelOps.SetShiftRegflags[FALSE, FALSE, FALSE];    CPBreak.RemoveBreaks[];    CPBreak.InstallBreaks[];    CPKernel.Start[log, arg, uPC, NextuPC];    CPCommand.RefreshWindow[];    END;      StartAndWait: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, uPC, NextuPC: LONG STRING, abort: CommandFile.AbortProc, ms: LONG CARDINAL]  =      BEGIN ENABLE      BEGIN      CPBreak.Error => ERROR Error[reason];      CPKernel.Error => ERROR Error[reason];      END;    start: System.GreenwichMeanTime = System.GetGreenwichMeanTime[];    stop: System.GreenwichMeanTime = System.AdjustGreenwichMeanTime[start, (ms+999)/1000];    Start[log, arg, uPC, NextuPC];    DO      CPKernel.ProbeForStateChange[log, arg];      Process.Pause[Process.MsecToTicks[500]];      IF CPKernel.GetState[] # running THEN EXIT;      IF abort[] THEN ERROR Error["UserAborted (STOP)"L];      IF ms = 0 THEN LOOP;  -- Forever case      IF System.GetGreenwichMeanTime[] > stop THEN ERROR Error["Didn't stop in time"L];      ENDLOOP;    CPBreak.RemoveBreaks[];    PrintState[log, arg];    CPCommand.RefreshWindow[];    END;        Continue: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, silent: BOOLEAN] =    BEGIN ENABLE      BEGIN      CPBreak.Error => ERROR Error[reason];      CPKernel.Error => ERROR Error[reason];      END;    Format.Text[log, "Continuing CP ... "L, arg];    CPKernel.ProbeForStateChange[log, arg];    SELECT CPKernel.GetState[] FROM      booted => ERROR CPKernel.Error["Can't continue CP from Boot"];      dead => ERROR CPKernel.Error["CP and/or IOP is dead"];      stopped => NULL;      running => ERROR CPKernel.Error["CP is running"];      cpBreak => NULL;      ENDCASE => ERROR;    CPBreak.RemoveBreaks[];    IF CPKernel.AtBreak[] THEN      BEGIN      mi: CPuFormat.mi;      [, , , mi] ¬ CPBreak.GetLastBreakInfo[];      Format.Text[log, "(from Break) "L, arg];      CPBreak.InstallBreaks[];      CPKernel.ContinueAfterBreak[log, arg, mi];      END    ELSE      BEGIN      Format.Text[log, "(from Stop) "L, arg];      CPBreak.InstallBreaks[];      CPKernel.ContinueAfterStop[log, arg];      END;    -- Give easy breaks time to take => avoid double state change printout    Process.Pause[Process.MsecToTicks[250]];    IF ~silent THEN PrintState[log, arg];    CPCommand.RefreshWindow[];    END;    ContinueAndWait: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, abort: CommandFile.AbortProc, ms: LONG CARDINAL] =    BEGIN ENABLE      BEGIN      CPBreak.Error => ERROR Error[reason];      CPKernel.Error => ERROR Error[reason];      END;    start: System.GreenwichMeanTime = System.GetGreenwichMeanTime[];    stop: System.GreenwichMeanTime = System.AdjustGreenwichMeanTime[start, (ms+999)/1000];    Continue[log, arg, FALSE];    DO      CPKernel.ProbeForStateChange[log, arg];      Process.Pause[Process.MsecToTicks[500]];      IF CPKernel.GetState[] # running THEN EXIT;      IF abort[] THEN ERROR Error["UserAborted (STOP)"L];      IF ms = 0 THEN LOOP;  -- Forever case      IF System.GetGreenwichMeanTime[] > stop THEN ERROR Error["Didn't stop in time"L];      ENDLOOP;    CPBreak.RemoveBreaks[];    PrintState[log, arg];    CPCommand.RefreshWindow[];    END;    SetBank: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, s: LONG STRING] =    BEGIN ENABLE      BEGIN      CPKernel.Error => ERROR Error[reason];      String.InvalidNumber => ERROR Error["Can't parse bank string"L];      END;    bank: CPDef.Bank ¬ String.StringToNumber[s];    CPKernel.WriteBank[bank];    Format.Text[log, "Now using bank "L, arg];    Format.Decimal[log, bank, arg];    Format.Line[log, "."L, arg];    END;  Stop: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER] =    BEGIN ENABLE CPKernel.Error => ERROR Error[reason];    Format.Text[log, "Stopping CP ... "L, arg];    CPKernel.Stop[log, arg];    PrintState[log, arg];    CPCommand.RefreshWindow[];    END;    ToggleFlags: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, EOPInt: BOOLEAN, EXTInt: BOOLEAN, CSParity: BOOLEAN] =    BEGIN ENABLE CPKernel.Error => ERROR Error[reason];    Format.Text[log, "Setting shiftRegister flags ..."L, arg];    CPKernelOps.SetShiftRegflags[EOPInt, EXTInt, CSParity];    Format.Line[log, "Done"L, arg];    END;      Break: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, s: LONG STRING] =    BEGIN    pc: CPDef.RealCS;    ibdisp: CPDef.IBDisp;    mdr: CPDef.MDR;    mi: CPuFormat.MI;    disp: CPuFormat.Bits4;    Format.Text[log, "Setting CP Break at "L, arg];    Format.Text[log, s, arg];    Format.Text[log, " = "L, arg];    [pc, ibdisp, mdr] ¬ CPSymbol.GetPcAndFlags[s ! CPSymbol.Error => ERROR Error[reason] ];    Format.Text[log, ".CR "L, arg];    Format.Number[log, pc, [16, FALSE, TRUE, 0], arg];    mi ¬ CPuFormat.uField[CPBreak.Break[pc, ibdisp, mdr ! CPBreak.Error => ERROR Error[reason] ]];    Format.Line[log, " ok."L, arg];    disp ¬ Inline.BITOR[Inline.BITSHIFT[mi.context.common.dspBBits33, 3], 				     mi.context.common.dspBBits20];    IF disp = CPDef.IBDspB THEN Format.Line[log, "Warning - IBDisp will not be canceled if a page cross occurs"L, arg];    IF ibdisp THEN Format.Line[log, "Warning - break set after IBDisp"L, arg];    IF mdr THEN Format.Line[log, "Warning - break set bettween memory references"L,arg];    END;    Unbreak: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, s: LONG STRING] =    BEGIN    pc: CPDef.RealCS;    ibdisp: CPDef.IBDisp;    mdr: CPDef.MDR;    Format.Text[log, "Clearing CP Break at "L, arg];    IF s # NIL THEN Format.Text[log, s, arg]    ELSE      BEGIN      Format.Text[log, "current break"L, arg];      IF ~CPKernel.AtBreak[] THEN ERROR Error["Not at Break"L];      END;    Format.Text[log, " = "L, arg];    IF s = NIL THEN      BEGIN      [pc, ibdisp, mdr, ] ¬ CPBreak.GetLastBreakInfo[];      END    ELSE [pc, ibdisp, mdr] ¬ CPSymbol.GetPcAndFlags[s ! CPSymbol.Error => ERROR Error[reason] ];    Format.Text[log, ".CR "L, arg];    Format.Number[log, pc, [16, FALSE, TRUE, 0], arg];    CPBreak.Unbreak[pc, ibdisp, mdr ! CPBreak.Error => ERROR Error[reason] ];    Format.Line[log, " ok."L, arg];    END;      PopIB: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER] =    BEGIN ENABLE CPKernel.Error => ERROR Error[reason];    IbCtr: CARDINAL;    Format.Text[log, " PopIB: "L, arg];    IF ~CPKernel.InKernel[] THEN        ERROR CPCommand.Error["Aborted... CP not in Kernel "L];    IbCtr ¬ CPKernel.ReadOther[IBCtr];    IF IbCtr = 0 THEN ERROR CPKernel.Error["IBEmpty!...PopIB Aborted."L];    CPKernelOps.SetShiftRegInternal[CPDef.StartAddr, CPKernelDef.kPopIB + CPKernel.savedBank * CPDef.wordsPerBank];    CPKernelOps.SetShiftRegInternal[CPDef.StartAddrPlusOne, CPKernelDef.kWait + CPKernel.savedBank * CPDef.wordsPerBank];    CPKernel.StartSirius[];    -- CPKernel.Pause[5*360/1000];    [] ¬ CPKernel.StopSirius[];    CPCommand.RefreshWindow[];    Format.Text[log, " (IBCtr = "L, arg];    Format.Number[log, IbCtr - 1, [16, FALSE, TRUE, 0], arg];    Format.Line[log, ")."L, arg];    END;      PollCP: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, verbose: BOOLEAN] RETURNS [BOOLEAN] =    BEGIN ENABLE CPKernel.Error => ERROR Error[reason];    IF CPKernel.PollSirius[log, arg] THEN      BEGIN      currentBreak: CARDINAL;      pc: CPDef.RealCS;      temp: LONG STRING ¬ [200];      virtualPC: CPSymbol.VirturalCS;      temp.length ¬ 0;      Format.Text[log,"At break point #"L, arg];      currentBreak ¬ CPKernel.GetBreakID[] + 1;      Format.Number[log, currentBreak, [10, FALSE, TRUE, 0], arg];      Format.Text[log,", located at "L,arg];      pc ¬ CPBreak.FindBreak[currentBreak];      CPSymbol.AppendRealCS[temp, pc];      [virtualPC, , ] ¬ CPSymbol.RealToVirturalCS[pc];      String.AppendString[temp, ", (VirtualCS = "L];      CPSymbol.AppendVirturalCS[temp, virtualPC];      String.AppendString[temp, ")"L];      Format.Line[log, temp, arg];      CPKernelOps.SetNewState[cpBreak];      CPCommand.RefreshWindow[];      RETURN[TRUE];      END;    Format.Line[log,"Sirius is not at break!"L,arg];    RETURN[FALSE];    END;  AutoPollCP: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER] =    BEGIN ENABLE CPKernel.Error => ERROR Error[reason];    IF CPKernel.AutoPollSirius[log, arg] THEN      BEGIN      Format.Line[log,"Break Point!"L, arg];      CPKernelOps.SetNewState[cpBreak];      CPCommand.RefreshWindow[];      END    END;  CopyPanel: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER] =    BEGIN    Format.Line[log, " CopyPanel "L, arg];    CPPanel.AppendPanelData[arg];    END;  PrintState: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER] =    BEGIN    state: CPKernel.State = CPKernel.GetState[];    SELECT state FROM      booted => Format.Text[log, "CP is Booted"L, arg];      dead => Format.Text[log, "CP and/or IOP is dead"L, arg];      stopped => Format.Text[log, "CP is stopped"L, arg];      running => Format.Text[log, "CP is running"L, arg];      cpBreak =>        BEGIN	temp: STRING = [200];	location: CPDef.RealCS;        ibdisp: CPDef.IBDisp;        mdr: CPDef.MDR;	virt: CPSymbol.VirturalCS;        CPBreak.RemoveBreaks[ ! CPBreak.Error => ERROR Error[reason] ];        [location, ibdisp, mdr, ] ¬ CPBreak.GetLastBreakInfo[];	[virt, , ] ¬ CPSymbol.RealToVirturalCS[location];	Format.Text[log, "CP Break at "L, arg];        CPSymbol.AppendRealCS[temp, location];	IF virt # CPSymbol.nullVirturalCS THEN	  BEGIN	  String.AppendString[temp, ", ("L];          CPSymbol.AppendVirturalCS[temp, virt];	  String.AppendString[temp, ")"L];	  Format.Text[log, temp, arg];	  END;	END;      ENDCASE => ERROR;    Format.Line[log, "."L, arg];    END;       END.-- Log:-- JAC   	10-Jan-85 11:56:05	when in PollCP an find at break, print break info-- JAC   	11-Jan-85 10:58:57	spell virtual correctly-- JAC   	28-Jan-85 19:34:35	added StartAndWait-- JAC   	13-Mar-85 14:44:20	added warning if set break on IBDisp-- JAC   	25-Mar-86 14:07:30	don't set flags when start but do upon Reset-- JAC   	 7-Apr-86 10:51:58	increase pause in StartAndWait & ContinueAndWait-- JAC   	 9-Apr-86 15:40:21	back out of last change-- JAC   	 2-May-86 17:37:36	set SetShiftRegflags in Boot proc not in Reset proc-- JAC/JWF   	29-Aug-86 17:26:25	fix for new CPCommand
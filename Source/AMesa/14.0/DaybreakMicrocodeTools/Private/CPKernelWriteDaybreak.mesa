-- Copyright (C) 1985  by Xerox Corporation. All rights reserved.-- Last edit by JAC	 7-Jun-85 12:26:52	copyrighted -- CPKernelWriteDaybreak.mesa, JoM    , 29-Jan-85 10:31:56DIRECTORY  Environment USING [LongNumber],  Inline USING [BITAND, BITSHIFT, HighHalf, LowHalf],  CP USING [    IOReg, Link, OtherReg, RealMemory, RReg, UReg],  CPKernel USING [],  CPKernelConstants,  CPKernelOps USING [    AddressOutOfRange, CantWriteThatRegister, DataOutOfRange, ExecuteCPBuffer, WriteCPCommandInternal, WriteCSInternal, WriteIBInternal, WriteRHrK, WriteUSpecial],  CPMI USING [FX, FYNorm, FZNorm, MI],  IOPKernelOps USING [InitializeLock, lock];CPKernelWriteDaybreak: MONITOR LOCKS IOPKernelOps.lock  IMPORTS    Inline, CPKernelOps, IOPKernelOps  EXPORTS CPKernel, CPKernelOps =  BEGIN OPEN CPKernelConstants;    WriteRReg: PUBLIC ENTRY PROCEDURE [r: CP.RReg, data: WORD] =    BEGIN ENABLE UNWIND => NULL;    -- kBuffer: R<addr> _ UKTemp, GOTO[kWait];    -- Write UKTemp with data first    IF r ~IN CP.RReg THEN CPKernelOps.AddressOutOfRange[];    CPKernelOps.WriteUSpecial[uKTemp, data];    CPKernelOps.WriteCSInternal[      kBuffer, CPMI.MI[      uKTempH, r, dz, rOrS, wrB, , , TRUE, , , uAddr, , , [d[uKTempL]], kWait]];    CPKernelOps.ExecuteCPBuffer[];    END;   WriteLink: PUBLIC ENTRY PROCEDURE [link: CP.Link, data: Nibble] =    BEGIN ENABLE UNWIND => NULL;    --kBuffer: []_ data, XDisp, c1;    --	       L<addr> _ 0, DISP4[KEntry], c2;    -- kE is overwritten and restored.    translate: ARRAY CP.Link OF CPMI.FX = [	  pCallRet0, pCallRet1, pCallRet2, pCallRet3,	  pCallRet4, pCallRet5, pCallRet6, pCallRet7];    IF link NOT IN CP.Link THEN CPKernelOps.AddressOutOfRange[];    IF data NOT IN Nibble THEN CPKernelOps.DataOutOfRange[];    CPKernelOps.WriteCSInternal[      kE, CPMI.MI[      , , , , , , , , , , , , , , kWait]];    CPKernelOps.WriteCSInternal[      kBuffer, CPMI.MI[      , , , , , , , , , dispBr, nibble, , [b[xDisp]], [d[data]], kBuffer + 1]];    CPKernelOps.WriteCSInternal[      kBuffer + 1, CPMI.MI[      , , , , , , , , , , , translate[link], , , kEntry]];    CPKernelOps.ExecuteCPBuffer[];    CPKernelOps.WriteCSInternal[      kE, CPMI.MI[      , , , , , , , , , , , , , , kBELoc]];    END;    WriteRH: PUBLIC ENTRY PROCEDURE [rh: CP.RReg, data: WORD] =    BEGIN ENABLE UNWIND => NULL;    dataH: Nibble _ Inline.BITAND[Inline.BITSHIFT[data, -4], 0FH];    dataL: Nibble _ Inline.BITAND[data, 0FH];    --kBuffer:	RH<addr>_ data, GOTO[kWait];    IF rh ~IN CP.RReg THEN CPKernelOps.AddressOutOfRange[];    IF data ~IN [0..0FFH] THEN CPKernelOps.DataOutOfRange[];    CPKernelOps.WriteCSInternal[      kBuffer, CPMI.MI[      , rh, , , , , , , , byte, nibble, loadRH, [d[dataH]], [d[dataL]], kWait]];    CPKernelOps.ExecuteCPBuffer[];    END;   WriteUReg: PUBLIC ENTRY PROCEDURE [u: CP.UReg, data: WORD] =    BEGIN ENABLE UNWIND => NULL;    CPKernelOps.WriteUSpecial[u, data];    END;    WriteRealMemoryInternal: PUBLIC INTERNAL PROCEDURE [real: CP.RealMemory, data: WORD] =    BEGIN    -- first write UKernMD with data and RHrK/UKAddr with real.    IF Inline.HighHalf[real] ~IN [0..31] THEN CPKernelOps.AddressOutOfRange[]; -- 2M    CPKernelOps.WriteUSpecial[uKernMD, data];    CPKernelOps.WriteRHrK[Inline.HighHalf[real]];    CPKernelOps.WriteUSpecial[uKAddr, Inline.LowHalf[real]];    CPKernelOps.WriteCPCommandInternal[writeMem];    END;   WriteIOOut: PUBLIC ENTRY PROCEDURE [io: CP.IOReg, data: WORD] =    BEGIN ENABLE UNWIND => NULL;    -- kBuffer:  IOOut<addr> _ UKTemp, GOTO[kWait], c1;    IF io ~IN [0..0FH] THEN CPKernelOps.AddressOutOfRange[];    CPKernelOps.WriteUSpecial[uKTemp, data];    CPKernelOps.WriteCSInternal[      kBuffer, CPMI.MI[      uKTempH, , dz, rOrS, , , , TRUE, , ioOut, uAddr, , [d[io]], [d[uKTempL]], kWait]];    CPKernelOps.ExecuteCPBuffer[];    END;  WriteOther: PUBLIC ENTRY PROCEDURE [other: CP.OtherReg, data: WORD] =    BEGIN ENABLE UNWIND => NULL;    IF other = ib      THEN CPKernelOps.WriteIBInternal[data]      ELSE WriteOtherInternal[other, data];    END;   WriteOtherInternal: INTERNAL PROCEDURE [other: CP.OtherReg, data: WORD] =    BEGIN    SELECT other FROM      q =>        --kBuffer:  Q _ UKTemp, GOTO[kWait];        --Write UKTemp with data first        BEGIN        CPKernelOps.WriteUSpecial[uKTemp, data];        CPKernelOps.WriteCSInternal[          kBuffer, CPMI.MI[          uKTempH, , dz, rOrS, wrQ, , , TRUE, , , uAddr, , , [d[uKTempL]], kWait]];        END;      pc16 =>        --kBuffer:  rK _ <data>+pc16, YDisp, c1;        --          BRANCH[KFlip, KNoFlip, 0E], c2;        --KFlip:    Cin _ pc16, GOTO[kWait], c3, at[0FFE];        --KNoFlip:  GOTO[kWait], c3, at[0FFF];        BEGIN        IF data ~IN [0..1] THEN CPKernelOps.DataOutOfRange[];        CPKernelOps.WriteCSInternal[          kBuffer, CPMI.MI[          , rK, dz, rPlusS, wrB, , , , , dispBr, nibble, cinPC16, [b[yDisp]], [d[data]], kBuffer + 1]];        CPKernelOps.WriteCSInternal[          kBuffer + 1, CPMI.MI[          , , , , , , , , , , , , , , 0FFEH]];        CPKernelOps.WriteCSInternal[          0FFEH, CPMI.MI[  --KFlip          , , , , , , , , , , , cinPC16, , , kWait]];        CPKernelOps.WriteCSInternal[          0FFFH, CPMI.MI[  --KNoFlip          , , , , , , , , , , , , , , kWait]];        END;	       stackP =>        --kBuffer:	stackP _ <data>, GOTO[kWait], c1;        BEGIN        IF data ~IN [0..0FH] THEN CPKernelOps.DataOutOfRange[];        CPKernelOps.WriteCSInternal[          kBuffer, CPMI.MI[          , , dz, rOrS, , , , , , , nibble, , [n[loadStackP]], [d[data]], kWait]];	        END;	      ibPtr =>        --kBuffer:	IBPtr _ <data>, GOTO[kWait], c1;        BEGIN	foo: CPMI.FZNorm = IF data = 0 THEN iBPtrTo0 ELSE iBPtrTo1;        IF data ~IN [0..1] THEN CPKernelOps.DataOutOfRange[];        CPKernelOps.WriteCSInternal[          kBuffer, CPMI.MI[          , , , , , , , , , , , , , [n[foo]], kWait]];        END;	        mInt =>        --kBuffer:  ClrIntErr, GOTO[kWait], c1;	{if 0}        --kBuffer:  MesaIntRq, GOTO[kWait], c1;	{if 1}        BEGIN	foo: CPMI.FYNorm = IF data = 0 THEN clrIntErr ELSE mesaIntRq;        IF data ~IN [0..1] THEN CPKernelOps.DataOutOfRange[];        CPKernelOps.WriteCSInternal[          kBuffer, CPMI.MI[          , , , , , , , , , , , , [n[foo]], , kWait]];        END;	        ekErr => CPKernelOps.CantWriteThatRegister[];	        ENDCASE => CPKernelOps.CantWriteThatRegister[];    CPKernelOps.ExecuteCPBuffer[];    RETURN;    END;  IOPKernelOps.InitializeLock[];  END.
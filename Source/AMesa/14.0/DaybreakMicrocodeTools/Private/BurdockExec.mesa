-- Copyright (C) 1985  by Xerox Corporation. All rights reserved.-- Last edit by JAC	 7-Jun-85 12:26:52	copyrighted -- BurdockExec.mesa, JoM    , 28-Jan-85 8:55:28DIRECTORY  Exec USING [AddCommand, CheckForAbort, ExecProc, FreeTokenString, GetToken, OutputProc, RemoveCommand],  Heap USING [systemZone],  Inline USING [LongCOPY],  Put USING [CR, Line],  Runtime USING [GetBcdTime],  String USING [AppendLongDecimal, AppendString],  Time USING [Append, Unpack],  Tool USING [Destroy],  Window USING [Handle],  BurdockControl,  CommandFile USING [CommandsFromFile, Error];BurdockExec: MONITOR  IMPORTS    Exec, Heap, Inline, Put, Runtime, String, Time, Tool,    CommandFile  EXPORTS BurdockControl =  BEGIN  -- TYPEs  BurdockWindows: TYPE = LONG POINTER TO BurdockWindowSeq;  BurdockWindowSeq: TYPE = RECORD  [ length: CARDINAL _ 0,    w: SEQUENCE maxlength: CARDINAL OF Window.Handle _ NULL];  -- global variables  bw: BurdockWindows _ NIL;  -- PUBLIC PROC  RegisterBurdockWindow: PUBLIC ENTRY PROC [window: Window.Handle] =    BEGIN    IF bw = NIL THEN bw _ Heap.systemZone.NEW[BurdockWindowSeq[10] _ []]      ELSE IF bw.length >= bw.maxlength THEN      BEGIN      oldBW: BurdockWindows _ bw;      bw _ Heap.systemZone.NEW[BurdockWindowSeq[oldBW.maxlength + 10] _ [oldBW.length]];      Inline.LongCOPY[from: @oldBW[0], to: @bw[0], nwords: SIZE[Window.Handle, oldBW.length]];      Heap.systemZone.FREE[@oldBW];      END;    bw[bw.length] _ window;    bw.length _ bw.length + 1;    END;  -- PRIVATE PROCs  Burdock: Exec.ExecProc =    BEGIN ENABLE CommandFile.Error =>      BEGIN      temp: STRING = [100];      String.AppendString[temp, "Error in command file at position "L];      String.AppendLongDecimal[temp, position];      String.AppendString[temp, ": "L];      String.AppendString[temp, reason];      Exec.OutputProc[h][temp];      outcome _ error;      CONTINUE;      END;    Abort: PROCEDURE RETURNS [BOOLEAN] = BEGIN RETURN[Exec.CheckForAbort[h]]; END;    token, switches: LONG STRING;    DO      [token, switches] _ Exec.GetToken[h];      switches _ Exec.FreeTokenString[switches];      IF token = NIL THEN EXIT;      CommandFile.CommandsFromFile[Exec.OutputProc[h], h, Abort, token !        UNWIND => token _ Exec.FreeTokenString[token]];      token _ Exec.FreeTokenString[token];      ENDLOOP;    END;  Initialize: PROCEDURE =    BEGIN    herald: STRING = [100];    String.AppendString[herald, "Welcome to Burdock of "L];    Time.Append[herald, Time.Unpack[Runtime.GetBcdTime[]]];    Put.CR[NIL];    Put.Line[NIL, herald];    Exec.AddCommand[name: "Burdock.~"L, proc: Burdock, unload: UnloadBurdock];    END;  UnloadBurdock: ENTRY Exec.ExecProc =    BEGIN    Exec.RemoveCommand [h, "Burdock.~"L];    IF bw # NIL THEN      BEGIN      FOR i: CARDINAL IN [0..bw.length) DO        Tool.Destroy [bw[i]];      ENDLOOP;      Heap.systemZone.FREE[@bw];      END;    END;  Initialize[];  END.
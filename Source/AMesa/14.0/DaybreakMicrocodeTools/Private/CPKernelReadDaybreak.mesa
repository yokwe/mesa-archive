-- Copyright (C) 1983, 1985  by Xerox Corporation. All rights reserved.-- Last edit by JAC	 7-Jun-85 12:26:52	copyrighted -- CPKernelReadDaybreak.mesa, JoM    , 29-Jan-85 10:32:24-- from CPKernelRead.mesa, HGM, 13-Jun-83 16:24:25DIRECTORY  Environment USING [Byte],  Inline USING [BITAND, BITNOT, BITSHIFT, HighHalf, LowHalf],  CP USING [IOReg, OtherReg, RealMemory, RReg, UReg],  CPKernel USING [],  CPKernelConstants ,  CPKernelOps USING [AddressOutOfRange, CantReadThatRegister, ExecuteCPBuffer, ReadCPByte, ReadUSpecial, WriteCPCommandInternal, WriteCSInternal, WriteRHrK, WriteUSpecial],  CPMI USING [FX, FYOut, FZNorm, MI],  IOPKernelOps USING [InitializeLock, lock];CPKernelReadDaybreak: MONITOR LOCKS IOPKernelOps.lock  IMPORTS    Inline, CPKernelOps, IOPKernelOps  EXPORTS CPKernel, CPKernelOps =  BEGIN OPEN CPKernelConstants;  debA: CPMI.FYOut = iopOData;  ReadRReg: PUBLIC ENTRY PROCEDURE [r: CP.RReg] RETURNS [WORD] =    BEGIN ENABLE UNWIND => NULL;    -- R is read in two parts: R[0-7] then R[8-15]    --kBuffer:	DebA_ R<addr> lRot8, GOTO[kWait];    --kBuffer:	DebA_ R<addr> lRot0, GOTO[kWait];    dataHigh, dataLow: Environment.Byte;    IF r ~IN CP.RReg THEN CPKernelOps.AddressOutOfRange[];    CPKernelOps.WriteCSInternal[      kBuffer, CPMI.MI[      r, , za, rOrS, , , , , , ioOut, , , [i[debA]], [n[lRot8]], kWait]];    CPKernelOps.ExecuteCPBuffer[];    dataHigh _ CPKernelOps.ReadCPByte[];    CPKernelOps.WriteCSInternal[      kBuffer, CPMI.MI[      r, , za, rOrS, , , , , , ioOut, , , [i[debA]], [n[lRot0]], kWait]];    CPKernelOps.ExecuteCPBuffer[];    dataLow _ CPKernelOps.ReadCPByte[];    RETURN[Inline.BITSHIFT[dataHigh, 8] + dataLow];    END;   ReadRH: PUBLIC ENTRY PROCEDURE [rh: CP.RReg] RETURNS [data: WORD] =    BEGIN ENABLE UNWIND => NULL;    --kBuffer: DebA_ RH<addr>, GOTO[kWait];    IF rh ~IN CP.RReg THEN CPKernelOps.AddressOutOfRange[];    CPKernelOps.WriteCSInternal[      kBuffer, CPMI.MI[      , rh, , , , , , , , ioOut, ioxIn, , [i[debA]], [i[rh]], kWait]];    CPKernelOps.ExecuteCPBuffer[];    data _ CPKernelOps.ReadCPByte[];    END;   ReadUReg: PUBLIC ENTRY PROCEDURE [u: CP.UReg] RETURNS [data: WORD] =    BEGIN ENABLE UNWIND => NULL;    RETURN [CPKernelOps.ReadUSpecial[u]];    END;   ReadRealMemoryInternal: PUBLIC INTERNAL PROCEDURE [real: CP.RealMemory] RETURNS [data: WORD] =    BEGIN    IF Inline.HighHalf[real] ~IN [0..31] THEN CPKernelOps.AddressOutOfRange[]; -- 2M    CPKernelOps.WriteRHrK[Inline.HighHalf[real]];    CPKernelOps.WriteUSpecial[uKAddr, Inline.LowHalf[real]];    CPKernelOps.WriteCPCommandInternal[readMem];    data _ CPKernelOps.ReadUSpecial[uKernMD];    END;   ReadOther: PUBLIC ENTRY PROCEDURE [other: CP.OtherReg] RETURNS [data: WORD] =    BEGIN ENABLE UNWIND => NULL;    SELECT other FROM      q =>  -- Read in two parts: Q[0-7] first, then Q[8-15]        --kBuffer:	DebA_ Q lRot8, GOTO[kWait];        --kBuffer:	DebA_ Q lRot0, GOTO[kWait];        BEGIN        dataHigh, dataLow: Environment.Byte;        CPKernelOps.WriteCSInternal[          kBuffer, CPMI.MI[          , , zq, rOrS, , , , , , ioOut, , , [i[debA]], [n[lRot8]], kWait]];        CPKernelOps.ExecuteCPBuffer[];        dataHigh _ CPKernelOps.ReadCPByte[];        CPKernelOps.WriteCSInternal[          kBuffer, CPMI.MI[          , , zq, rOrS, , , , , , ioOut, , , [i[debA]], [n[lRot0]], kWait]];        CPKernelOps.ExecuteCPBuffer[];        dataLow _ CPKernelOps.ReadCPByte[];        data _ Inline.BITSHIFT[dataHigh, 8] + dataLow;        END;      ib =>  --IOXIn[C'x] _ibNA        BEGIN        --kBuffer:	rK _ 30, c1;        --		rK _ rK and ~ErrnIBStkp, ZeroBr, c2;	--		BRANCH[kBuffer+6,kBuffer+7], c3;	--		DebA_ ibNA, GOTO[kWait], c1, at[kBuffer+6];	--		DebA_ 0, GOTO[kWait], c1, at[kBuffer+7];        CPKernelOps.WriteCSInternal[          kBuffer, CPMI.MI[          , rK, dz, rOrS, wrB, , , , , byte, nibble, , [d[3]], [d[0]], kBuffer + 1]];        CPKernelOps.WriteCSInternal[          kBuffer + 1, CPMI.MI[          rK, rK, da, notRAndS, wrB, , , , , dispBr, ioxIn, , [b[zeroBr]], [i[errNlBnStkp]], kBuffer + 2]];        CPKernelOps.WriteCSInternal[          kBuffer + 2, CPMI.MI[          , , , , , , , , , , , , , , kBuffer + 6]];        CPKernelOps.WriteCSInternal[          kBuffer + 6, CPMI.MI[          , , , , , , , , , ioOut, ioxIn, , [i[debA]], [i[ibNA]], kWait]];        CPKernelOps.WriteCSInternal[          kBuffer + 7, CPMI.MI[          , , , , , , , , , ioOut, nibble, , [i[debA]], [d[0]], kWait]];        CPKernelOps.ExecuteCPBuffer[];        data _ CPKernelOps.ReadCPByte[];        END;      pc16 =>        --kBuffer:	rK _ 0+pc16, c1;        --		IOPOData_ rK lRot0, Cin_pc16 GOTO[kWait], c2;        BEGIN        CPKernelOps.WriteCSInternal[          kBuffer, CPMI.MI[          , rK, dz, rPlusS, wrB, , , , , , nibble, cinPC16, , [d[0]], kBuffer + 1]];        CPKernelOps.WriteCSInternal[          kBuffer + 1, CPMI.MI[          rK, , za, rOrS, , , , , , ioOut, , cinPC16, [i[iopOData]], [n[lRot0]], kWait]];        CPKernelOps.ExecuteCPBuffer[];        data _ CPKernelOps.ReadCPByte[];        END;      mInt =>        --kBuffer: MesaIntBr, c1;        --         BRANCH[MIZero, MIOne], c2;        --MIZero:  DebA _ 0, GOTO[kWait], c3;        --MIOne:   DebA _ 1, GOTO[kWait], c3;        BEGIN        CPKernelOps.WriteCSInternal[          kBuffer, CPMI.MI[          , , , , , , , , , dispBr, , , [b[mesaIntBr]], , kBuffer + 1]];        CPKernelOps.WriteCSInternal[          kBuffer + 1, CPMI.MI[          , , , , , , , , , , , , , , kBuffer + 2]];        CPKernelOps.WriteCSInternal[          kBuffer + 2, CPMI.MI[  --KFlip          , , , , , , , , , ioOut, nibble, , [i[debA]], [d[0]], kWait]];        CPKernelOps.WriteCSInternal[          kBuffer + 3, CPMI.MI[  --KNoFlip          , , , , , , , , , ioOut, nibble, , [i[debA]], [d[1]], kWait]];        CPKernelOps.ExecuteCPBuffer[];        data _ CPKernelOps.ReadCPByte[];        END;      stackP =>  --low 4 bits of ~IOXIn[A'x]        BEGIN        data _ ReadIOInInternal[10];        data _ Inline.BITAND[Inline.BITNOT[data], 17B];        END;      ibPtr =>  --bits [10-11] of ~IOXIn[A'x]        BEGIN        data _ ReadIOInInternal[10];        data _ Inline.BITAND[Inline.BITSHIFT[Inline.BITNOT[data], -4], 3];        END;      ekErr =>  --bits [8-9] of IOXIn[A'x]        BEGIN        data _ ReadIOInInternal[10];        data _ Inline.BITAND[Inline.BITSHIFT[data, -6], 3];        END;      ENDCASE => CPKernelOps.CantReadThatRegister[];    RETURN[data];    END;    ReadIOIn: PUBLIC ENTRY PROCEDURE [io: CP.IOReg] RETURNS [data: WORD] =    BEGIN    RETURN[ReadIOInInternal[io]];    END;  ReadIOInInternal: INTERNAL PROCEDURE [io: CP.IOReg] RETURNS [data: WORD] =    BEGIN    -- Read in two parts: IOXIn[0-7] first, then IOXIn[8-15]    -- kBuffer:  rK _ IOXIn<addr>, c1;    --           DebA _ rK lRot8, GOTO[kWait], c2;    -- kBuffer:  DebA _ IOXIn<addr>, GOTO[kWait], c1;    dataHigh, dataLow: Environment.Byte;    IF io ~IN CP.IOReg THEN CPKernelOps.AddressOutOfRange[];    CPKernelOps.WriteCSInternal[      kBuffer, CPMI.MI[      , rK, dz, rOrS, wrB, , , , , , ioxIn, , , [d[io]], kBuffer + 1]];    CPKernelOps.WriteCSInternal[      kBuffer + 1, CPMI.MI[      rK, , za, rOrS, , , , , , ioOut, , , [i[debA]], [n[lRot8]], kWait]];    CPKernelOps.ExecuteCPBuffer[];    dataHigh _ CPKernelOps.ReadCPByte[];    CPKernelOps.WriteCSInternal[      kBuffer, CPMI.MI[      , , , , , , , , , ioOut, ioxIn, , [i[debA]], [d[io]], kWait]];    CPKernelOps.ExecuteCPBuffer[];    dataLow _ CPKernelOps.ReadCPByte[];    data _ Inline.BITSHIFT[dataHigh, 8] + dataLow;    END;      IOPKernelOps.InitializeLock[];  END.
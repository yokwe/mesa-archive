-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- File: TmCallLineImpl.mesa-- Last edit: DEG      26-Sep-84 20:24:43-- Last edit: JAC    10-Aug-83 11:56:50-- Last edit: JAC    21-Jul-83  9:50:52   -- Last edit: ETN    19-Jan-83 13:50:46DIRECTORY  Environment USING [bytesPerWord],  Exec USING [FreeTokenString, GetToken, Handle],  Heap USING [systemZone],  String USING [AppendChar, AppendString, LowerCase, StringToDecimal],  TmControl USING [    config, endStop, debugStop, execHandle, FatalError, noFinalFiles,    noFTfile, TtyLine2],  TmFile USING [    aFlagSet, CreateLogFile, defsFilesCnt, defsFileNames, importsOnly,    maxNumFiles, outFile, passTwoOnly, siPrologLength, sourceFilesCnt,    sourceFileNames],  TmModule;TmCallLineImpl: PROGRAM  IMPORTS Exec, Heap, String, TmControl, TmFile   EXPORTS TmModule =  BEGIN  ProcessCallLine: PUBLIC PROCEDURE[] =    BEGIN    commandLineError: BOOLEAN ¬ FALSE;    constructedString: LONG STRING ¬ [64];    execName, execSwitch: LONG STRING;    sourceFile: BOOLEAN;    CommandLineError: PROCEDURE [str: LONG STRING] =      BEGIN      commandLineError ¬ TRUE;      TmControl.TtyLine2["Error in Command Line - "L, str];      END;  -- CommandLineError proc    TmFile.defsFilesCnt ¬ 0;    TmFile.sourceFilesCnt ¬ 0;    DO      [execName, execSwitch] ¬ Exec.GetToken[TmControl.execHandle];      IF execName = NIL AND execSwitch = NIL THEN {        IF TmFile.sourceFilesCnt = 0 THEN          CommandLineError["No sources files on command line "L];        EXIT};      sourceFile ¬ TRUE;      IF execSwitch # NIL THEN {        char: CHARACTER;        i: CARDINAL;        FOR i IN [0..execSwitch.length) DO          SELECT (char ¬ String.LowerCase[execSwitch[i]]) FROM            'a => TmFile.aFlagSet ¬ TRUE;            'c => {              sourceFile ¬ FALSE;              TmControl.config ¬ String.StringToDecimal[execName]};            'd => {              sourceFile ¬ FALSE;              IF execName # NIL THEN                IF TmFile.defsFilesCnt IN [0..TmFile.maxNumFiles) THEN {                  TmFile.defsFileNames[TmFile.defsFilesCnt] ¬ CopyString[                    execName, 4];                  String.AppendString[                    TmFile.defsFileNames[TmFile.defsFilesCnt], ".dfn"L];                  TmFile.siPrologLength ¬                    TmFile.siPrologLength +                      Environment.bytesPerWord*(SIZE[CARDINAL] + SIZE[                                                  LONG CARDINAL]) +                      TmFile.defsFileNames[TmFile.defsFilesCnt].length;                  TmFile.defsFilesCnt ¬ TmFile.defsFilesCnt + 1}                ELSE CommandLineError["Too many files on call line."L]              ELSE CommandLineError["d switch requires a file name."L]};            'e => TmControl.endStop ¬ TRUE;            'n => TmControl.noFinalFiles ¬ TRUE;            'o => {              sourceFile ¬ FALSE;              IF execName # NIL THEN                IF TmFile.outFile.length = 0 THEN {                  String.AppendString[TmFile.outFile, execName];                  String.AppendString[TmFile.outFile, ".xx"L]}                ELSE CommandLineError["Only one output file allowed."L]              ELSE CommandLineError["o switch requires a file name."L]};            's => TmControl.debugStop ¬ TRUE;            't => TmControl.noFTfile ¬ TRUE;            'x => TmFile.importsOnly[TmFile.sourceFilesCnt] ¬ TRUE;            '2 => TmFile.passTwoOnly[TmFile.sourceFilesCnt] ¬ TRUE;            ENDCASE => {              constructedString.length ¬ 0;              String.AppendChar[constructedString, char];              String.AppendString[constructedString, " is not a valid switch."L];              CommandLineError[constructedString]};          ENDLOOP;        [] ¬ Exec.FreeTokenString[execSwitch]};      IF sourceFile THEN        IF execName # NIL THEN          IF TmFile.sourceFilesCnt IN [0..TmFile.maxNumFiles) THEN {            TmFile.sourceFileNames[TmFile.sourceFilesCnt] ¬ CopyString[	      execName, 3];            String.AppendString[              TmFile.sourceFileNames[TmFile.sourceFilesCnt], ".mc"L];            TmFile.sourceFilesCnt ¬ TmFile.sourceFilesCnt + 1}          ELSE CommandLineError["Too many files on call line."L]        ELSE          IF TmFile.importsOnly[TmFile.sourceFilesCnt]            OR TmFile.passTwoOnly[TmFile.sourceFilesCnt] THEN            CommandLineError["2 and x switches require a file name."L];      [] ¬ Exec.FreeTokenString[execName];      ENDLOOP;    IF TmFile.outFile.length = 0 THEN       CommandLineError["No output file specified or missing /o."L];    IF commandLineError THEN TmControl.FatalError;    TmFile.CreateLogFile[];    END;  -- end ProcessCallLine  CopyString: PROCEDURE [old: LONG STRING, extra: CARDINAL] RETURNS [new: LONG STRING] =    BEGIN    new ¬ Heap.systemZone.NEW[StringBody[old.length + extra]];    String.AppendString[new, old];    END;  END... -- end MassCallLine.mesa    -- Log:  -- 17-Jul-82 19:37:51 - ETN        - TrinityMass Version 1   -- 26-Oct-82 16:02:03 - ETN        - Added missing /o error   -- 19-Jan-83 13:58:48 - ETN        - Sierra.  Replaced Storage.CopyString[  --                                   with local CopyString using Heap.   -- 21-Jul-83  9:52:05 - JAC        - .df => .dfn  -- 10-Aug-83 12:00:14 - JAC        - outfile no longer allocated from system zone   -- 26-Sep-84 20:24:38 DEG     	Action: Added copyright notice and rebuild for 11.1 release. 
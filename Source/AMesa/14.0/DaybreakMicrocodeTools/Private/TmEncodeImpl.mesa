-- Copyright (C) 1982, 1983, 1986  by Xerox Corporation. All rights reserved. -- File: TmEncodeImpl.mesa.-- Created form TmEncodeDPImpl.mesa JWF 27-Oct-87 11:05:56-- Created form TmEncodeImpl.mesa of 12.0 to add the Daybreak port operations-- by W.D. Evans   16-May-86 11:28:42-- Last edit: WDE      16-May-86 11:29:01-- File: TmEncodeImpl.mesa.-- Last edit: DEG      26-Sep-84 20:40:15-- Last edit: JAC    11-Jul-83 10:07:04 -- Last edit: ETN   16-Jul-82 13:14:37 -- The purpose of this module is to create Encoding records for each Phrase of a microcode statement.-- A microcode statement consists of a list of Phrase records.  A Phrase represents the text in a-- statement between commas.  Each Phrase consists of a list of PhraseElement records and a list of-- Encoding records.  A PhraseElement represents an element of a Phrase such as a U Register, a "+"-- operation, a constant, etc.  The Encoding record represents how the Phrase will be encoded into-- fields of the microinstruction.  There will be more than one Encoding record if the Phrase has-- more than one possible way of being encoded.    DIRECTORY  TmExpressionTablesImpl USING [    patternDSource, patternCin0, patternCin1, patternOpx, patternOpNx,    patternOpor, patternOpand, patternOpNand, patternOpxor, patternOpNxor,    patternOpplus, patternOpminus],  Inline USING [BITSHIFT],  String USING [EqualString],  TmAssembler,  TmModule;TmEncodeImpl: PROGRAM  IMPORTS Inline, String, TmAssembler, ET: TmExpressionTablesImpl  EXPORTS TmAssembler, TmModule =  BEGIN OPEN TmAssembler;  -- GLOBAL VARIABLES  nullExpression: Expression = Expression[    operand1: x, operation: x, operand2: x, dSource: x, carry: x];  patternOpx: LONG DESCRIPTOR FOR ARRAY OF ExpressionPattern;  patternOpNx: LONG DESCRIPTOR FOR ARRAY OF ExpressionPattern;  patternOpor: LONG DESCRIPTOR FOR ARRAY OF ExpressionPattern;  patternOpand: LONG DESCRIPTOR FOR ARRAY OF ExpressionPattern;  patternOpNand: LONG DESCRIPTOR FOR ARRAY OF ExpressionPattern;  patternOpxor: LONG DESCRIPTOR FOR ARRAY OF ExpressionPattern;  patternOpNxor: LONG DESCRIPTOR FOR ARRAY OF ExpressionPattern;  patternOpplus: LONG DESCRIPTOR FOR ARRAY OF ExpressionPattern;  patternOpminus: LONG DESCRIPTOR FOR ARRAY OF ExpressionPattern;  -- SIGNALS AND ERRORS GENERATED  EncodeError: ERROR [    {    unknownPhraseElement, invalidBusType, invalidConstantValue, registerType,    invalidLogicalOperation, invalidExpressionOperand}] = CODE;  InitGlobalEncode: PUBLIC PROCEDURE =    BEGIN    patternOpx ¬ DESCRIPTOR[@ET.patternOpx, LENGTH[ET.patternOpx]];    patternOpNx ¬ DESCRIPTOR[@ET.patternOpNx, LENGTH[ET.patternOpNx]];    patternOpor ¬ DESCRIPTOR[@ET.patternOpor, LENGTH[ET.patternOpor]];    patternOpand ¬ DESCRIPTOR[@ET.patternOpand, LENGTH[ET.patternOpand]];    patternOpNand ¬ DESCRIPTOR[@ET.patternOpNand, LENGTH[ET.patternOpNand]];    patternOpxor ¬ DESCRIPTOR[@ET.patternOpxor, LENGTH[ET.patternOpxor]];    patternOpNxor ¬ DESCRIPTOR[@ET.patternOpNxor, LENGTH[ET.patternOpNxor]];    patternOpplus ¬ DESCRIPTOR[@ET.patternOpplus, LENGTH[ET.patternOpplus]];    patternOpminus ¬ DESCRIPTOR[@ET.patternOpminus, LENGTH[ET.patternOpminus]];    END;  EncodeEnd: PROCEDURE [phrase: PhrasePtr] RETURNS [noSyntaxError: BOOLEAN] =    BEGIN    noSyntaxError ¬ TRUE;    IF (phrase.currentElement ¬ phrase.currentElement.nextElement) = NIL THEN      RETURN;    WITH phrase.currentElement­.elementRec SELECT FROM      LRot =>        BEGIN        phrase.XLRot ¬ TRUE;        EncodeMacro[phrase, macroIndex];        phrase.currentElement ¬ phrase.currentElement.nextElement        END;      ENDCASE => RETURN[FALSE];    END;  EncodeExpression: PROCEDURE [phrase: PhrasePtr] =    BEGIN    -- Try to encode phrase.expression in each existing Encoding record for the given Phrase.  We create a new chain of Encoding records for the Phrase.  There may be more than one possible encoding of the expression that follows the first entry.    encoding: EncodingPtr ¬ phrase.encoding;    expressionFound: BOOLEAN ¬ FALSE;    firstExpression: ExpressionPatternPtr;    lastNextEncodingPtrInNewChain: LONG POINTER TO EncodingPtr ¬ @phrase.encoding;    nextOldEncoding: EncodingPtr;    savearg: CARDINAL;    secondExpression: LONG POINTER TO DSourcePattern;    thirdExpression: LONG POINTER TO Pattern;    trialEncoding: EncodingPtr ¬ AllocateEncodingRecord[];    SearchForPattern: PROCEDURE [      first: ExpressionPatternPtr, second: LONG POINTER TO DSourcePattern,      third: LONG POINTER TO Pattern] =      BEGIN      lastExpression: ExpressionPatternPtr;      nextExpression: ExpressionPatternPtr ¬ first;      UNTIL nextExpression = NIL DO  -- once for each possible encoding of the macro        -- Move the old encoding to trialEncoding so that we can modify it and still have the unmodified version.        trialEncoding­ ¬ nextOldEncoding­;        BEGIN        IF NOT EncodePattern[          phrase, @nextExpression.pattern, trialEncoding, Assignment[          expression[]]] THEN GOTO skip;        IF second # NIL THEN          IF NOT EncodePattern[            phrase, @second.pattern, trialEncoding, Assignment[expression[]]] THEN            GOTO skip;        IF third # NIL THEN          IF NOT EncodePattern[            phrase, third, trialEncoding, Assignment[expression[]]] THEN            GOTO skip;        BEGIN        -- We have an encoding of the expression that works.  Chain it onto the list of encoding records for this phrase.        lastNextEncodingPtrInNewChain­ ¬ trialEncoding;        trialEncoding.nextEncoding ¬ NIL;        lastNextEncodingPtrInNewChain ¬ @trialEncoding.nextEncoding;        trialEncoding ¬ AllocateEncodingRecord[];        expressionFound ¬ TRUE;        END;        EXITS skip => NULL;        END;        lastExpression ¬ nextExpression;        nextExpression ¬ nextExpression + SIZE[ExpressionPattern];        IF lastExpression.expressionArgs # nextExpression.expressionArgs THEN          EXIT;        ENDLOOP;      RETURN;      END;    BEGIN  -- Begin EncodeExpression.    IF phrase.encoding = NIL THEN RETURN;    IF phrase.expression = nullExpression THEN RETURN;    IF phrase.encoding.xbusLoad AND NOT phrase.encoding.ybusLoad      AND phrase.expression.operation = x AND phrase.expression.operand1 = D THEN      phrase.expression.operand1 ¬ x;  -- Xbus can go directly to destination    IF phrase.ALRot AND phrase.encoding.assignB AND phrase.expression.dSource = x      THEN      SELECT phrase.expression.operation FROM        x =>          BEGIN          -- the expression uses a single term through the LRot box          -- can't use Apass if loading RH because of side effect of loading B          phrase.arg2 ¬ phrase.arg1;          EncodeMacro[phrase, apassindex];          phrase.expression.operand1 ¬ D;          phrase.expression.dSource ¬ lrot;          END;        ENDCASE =>          BEGIN          savearg ¬ phrase.arg2;          phrase.arg2 ¬ phrase.arg1;          EncodeMacro[phrase, apassindex];          phrase.expression.operand1 ¬ D;          phrase.expression.dSource ¬ lrot;          phrase.arg2 ¬ savearg;          END;    [firstExpression, secondExpression, thirdExpression] ¬ FindExpression[phrase];    IF firstExpression = NIL THEN      BEGIN SyntaxError[phrase, invalidExpression]; GO TO SyntaxError; END;    -- Save the old list of encoding records.  The old list will be replaced by a new list.    nextOldEncoding ¬ phrase.encoding;    phrase.encoding ¬ NIL;    UNTIL nextOldEncoding = NIL DO  -- once for each encoding in the list      SearchForPattern[firstExpression, secondExpression, thirdExpression];      nextOldEncoding ¬ nextOldEncoding.nextEncoding;      ENDLOOP;    EXITS SyntaxError => NULL;    -- FormatError => NULL;    END;  -- of SyntaxError block    -- If any patterns could not be encoded, error messages are chained onto tempFormatErrorMsgs.  If we found a pattern that works, we delete the temp error messages.  If no pattern could be encoded, we will print all of the error messages.    IF NOT expressionFound THEN MakeTempErrorMsgsPermanent[phrase];    RETURN;    END;  EncodeLHS: PROCEDURE [phrase: PhrasePtr] =    BEGIN    -- Begin with the left hand side of an expression.    BEGIN  -- SyntaxError block    IF phrase.currentElement = NIL THEN RETURN;    WITH phrase.currentElement­.elementRec SELECT FROM      register =>        BEGIN        SELECT registerType FROM          RHm =>            BEGIN            phrase.expression.operand1 ¬ RHm;            phrase.arg1 ¬ regnum;            EncodeExpression[phrase];            RETURN;            END;          ENDCASE => EncodeRegisterLHS[phrase, registerType, regnum];        IF NOT NextElementIsArrow[phrase] THEN          BEGIN          SyntaxError[phrase, arrowMissing];          GO TO SyntaxError;  -- syntax error if next element is not arrow          END;        phrase.currentElement ¬ phrase.currentElement.nextElement;        IF phrase.currentElement.nextElement = NIL THEN          BEGIN          SyntaxError[phrase, noRHS];          GO TO SyntaxError;  -- syntax error if no right hand side          END;        EncodeRHS[phrase];        END;      macro => BEGIN EncodeMacro[phrase, macroIndex]; EncodeRHS[phrase]; END;      ENDCASE => SyntaxError[phrase, unexpectedLHS];    EXITS SyntaxError => NULL;    END;  -- of SyntaxError block    RETURN;    END;  EncodeMacro: PROCEDURE [phrase: PhrasePtr, macroIndex: MacroIndex] =    BEGIN    -- Given a MacroIndex, try to encode the macro in each existing Encoding record for the given Phrase.  We create a new chain of Encoding records for the Phrase.  The MacroIndex points to the first entry in the macro table for the given macro. There may be more than one possible encoding that follows the first entry.    firstMacro: MacroPatternPtr;    lastMacro: MacroPatternPtr;    lastNextEncodingPtrInNewChain: LONG POINTER TO EncodingPtr;    nextMacro: MacroPatternPtr;    nextOldEncoding: EncodingPtr;    oldEncodingList: EncodingPtr;    saveArg1: CARDINAL;    successful: BOOLEAN ¬ FALSE;  -- Assume not successful.    trialEncoding: EncodingPtr;    -- Point to the first entry in the macro table for the given macroIndex. There may be other possible encodings that follow this entry.    firstMacro ¬ @macroTable[macroIndex];    -- Save the old list of encoding records.  The old list will be replaced by a new list.    oldEncodingList ¬ phrase.encoding;    phrase.encoding ¬ NIL;    trialEncoding ¬ AllocateEncodingRecord[];    lastNextEncodingPtrInNewChain ¬ @phrase.encoding;    nextOldEncoding ¬ oldEncodingList;    saveArg1 ¬ phrase.arg1;    UNTIL nextOldEncoding = NIL DO  -- once for each encoding in the list      nextMacro ¬ firstMacro;      DO  -- once for each possible encoding of the macro        -- Move the old encoding to trialEncoding so that we can modify it and still have the unmodified version.        trialEncoding­ ¬ nextOldEncoding­;        phrase.arg1 ¬ nextMacro.macro.value;        IF EncodePattern[          phrase, @nextMacro.pattern, trialEncoding, Assignment[          macro[macroIndex]]] THEN          BEGIN          -- We have an encoding of the macro that works.  Chain it onto the list of encoding records for this phrase.          lastNextEncodingPtrInNewChain­ ¬ trialEncoding;          trialEncoding.nextEncoding ¬ NIL;          lastNextEncodingPtrInNewChain ¬ @trialEncoding.nextEncoding;          trialEncoding ¬ AllocateEncodingRecord[];          successful ¬ TRUE;          END;        lastMacro ¬ nextMacro;        nextMacro ¬ nextMacro + SIZE[MacroPattern];        IF NOT String.EqualString[lastMacro.macro.name, nextMacro.macro.name] THEN          EXIT;        ENDLOOP;      nextOldEncoding ¬ nextOldEncoding.nextEncoding;      ENDLOOP;    phrase.arg1 ¬ saveArg1;    -- If any patterns could not be encoded, error messages are chained onto tempFormatErrorMsgs.  If we found a pattern that works, we delete the temp error messages.  If no pattern could be encoded, we will print all of the error messages.    IF NOT successful THEN MakeTempErrorMsgsPermanent[phrase];        RETURN;    END;  EncodeOperation: PROCEDURE [phrase: PhrasePtr]    RETURNS [noSyntaxError: BOOLEAN] =    BEGIN    -- Called by EncodeRHS when the first operand has been found.  Look for and encode the operation that follows the first operand of an expression. The operation (if any) will be encoded in phrase.expression.operation.    noSyntaxError ¬ TRUE;    IF (phrase.currentElement ¬ phrase.currentElement.nextElement) = NIL THEN      RETURN;  -- no operation follows    WITH phrase.currentElement­.elementRec SELECT FROM      LRot =>        BEGIN        phrase.ALRot ¬ TRUE;        EncodeMacro[phrase, macroIndex];        noSyntaxError ¬ EncodeOperation[phrase];        END;      macro =>        BEGIN        EncodeMacro[phrase, macroIndex];        noSyntaxError ¬ EncodeOperation[phrase];        END;      plus =>        BEGIN        IF phrase.expression.operation = Nx THEN          BEGIN          SyntaxError[phrase, unexpectedLHS];          noSyntaxError ¬ FALSE;          RETURN;          END;        phrase.expression.operation ¬ plus;        phrase.expression.carry ¬ zero;        noSyntaxError ¬ EncodeSecondOperand[phrase];        END;      minus =>        BEGIN        IF phrase.expression.operation = Nx THEN          BEGIN          SyntaxError[phrase, unexpectedLHS];          noSyntaxError ¬ FALSE;          RETURN;          END;        phrase.expression.operation ¬ minus;        phrase.expression.carry ¬ one;        noSyntaxError ¬ EncodeSecondOperand[phrase];        END;      logical =>        BEGIN        SELECT logicalOperation FROM          and =>            phrase.expression.operation ¬              IF phrase.expression.operation = Nx THEN Nand ELSE and;          or =>            IF phrase.expression.operation = Nx THEN              BEGIN              SyntaxError[phrase, unexpectedLHS];              noSyntaxError ¬ FALSE;              RETURN;              END            ELSE phrase.expression.operation ¬ or;          xor =>            phrase.expression.operation ¬              IF phrase.expression.operation = Nx THEN Nxor ELSE xor;          ENDCASE;        noSyntaxError ¬ EncodeSecondOperand[phrase];        END;      ENDCASE =>        BEGIN SyntaxError[phrase, operationMissing]; noSyntaxError ¬ FALSE; END;    RETURN;    END;  EncodePhrase: PROCEDURE [phrase: PhrasePtr] =    BEGIN    phrase.expression ¬ nullExpression;    phrase.encoding ¬ AllocateEncodingRecord[];    phrase.currentElement ¬ phrase.firstElement;    phrase.syntaxError ¬ phrase.formatError ¬ phrase.ALRot ¬ phrase.XLRot ¬ FALSE;    phrase.errorMsgs ¬ phrase.tempErrorMsgs ¬ NIL;    EncodeLHS[phrase];    RETURN;    END;  EncodePlusOrMinusOne: PROCEDURE [phrase: PhrasePtr]    RETURNS [noSyntaxError: BOOLEAN] =  --new    BEGIN    -- This is called by EncodeSecondOperand when a second operand has been encountered.  Look for plus or minus one that may follow expression.    noSyntaxError ¬ TRUE;    BEGIN  -- error block    IF (phrase.currentElement ¬ phrase.currentElement.nextElement) = NIL THEN      RETURN;    WITH phrase.currentElement­.elementRec SELECT FROM      plus =>        BEGIN        IF phrase.expression.operation # plus THEN          BEGIN SyntaxError[phrase, invalidPlus]; GO TO SyntaxError; END;        SELECT NextElementIsOne[phrase] FROM          bad => BEGIN SyntaxError[phrase, oneMissing]; GO TO SyntaxError; END;          one =>            IF NOT (phrase.expression.carry = one) THEN              phrase.expression.carry ¬ one            ELSE              BEGIN              phrase.expression.operand2 ¬ D;              phrase.expression.dSource ¬ nibl;              END;          pc16 =>            IF (phrase.expression.carry = one) THEN              BEGIN              phrase.expression.carry ¬ x;              phrase.expression.operand2 ¬ D;              phrase.expression.dSource ¬ nibl;              phrase.arg2 ¬ 1;              phrase.arg ¬ 1;              END;          ENDCASE;        END;      minus =>        BEGIN        IF phrase.expression.operation # minus THEN          BEGIN SyntaxError[phrase, invalidMinus]; GO TO SyntaxError; END;        SELECT NextElementIsOne[phrase] FROM          bad => BEGIN SyntaxError[phrase, oneMissing]; GO TO SyntaxError; END;          one =>            IF NOT (phrase.expression.carry = zero) THEN              phrase.expression.carry ¬ zero            ELSE              BEGIN              phrase.expression.operand2 ¬ D;              phrase.expression.dSource ¬ nibl;              END;          pc16 =>            IF (phrase.expression.carry = zero) THEN              BEGIN              phrase.expression.carry ¬ x;              phrase.expression.operand2 ¬ D;              phrase.expression.dSource ¬ nibl;              phrase.arg2 ¬ 1;              phrase.arg ¬ 1;              END;          ENDCASE;        END;      macro => EncodeMacro[phrase, macroIndex];      LRot => BEGIN phrase.XLRot ¬ TRUE; EncodeMacro[phrase, macroIndex]; END;      ENDCASE =>        BEGIN SyntaxError[phrase, missingPlusOrMinus]; GO TO SyntaxError; END;    EXITS SyntaxError => BEGIN noSyntaxError ¬ FALSE; RETURN; END;    END;  -- of error block    noSyntaxError ¬ EncodeEnd[phrase];    END;  EncodeRegisterLHS: PROCEDURE [    phrase: PhrasePtr, type: RegisterType, register: CARDINAL] =    BEGIN    assignment: Assignment;  -- used to remember which encoding fields were caused by a register assignment    pattern: PatternPtr;    lastNextEncodingPtrInNewChain: LONG POINTER TO EncodingPtr;    nextOldEncoding: EncodingPtr;    successful: BOOLEAN ¬ FALSE;  -- Assume not successful.    trialEncoding: EncodingPtr;    trialEncoding ¬ AllocateEncodingRecord[];    lastNextEncodingPtrInNewChain ¬ @phrase.encoding;    phrase.arg1 ¬ register;  -- used by EncodePattern    phrase.arg ¬ register;  -- used by EncodePattern    SELECT type FROM      R => BEGIN assignment ¬ [register[R]]; pattern ¬ @patternAssignR; END;      RH => BEGIN assignment ¬ [register[RH]]; pattern ¬ @patternAssignRH; END;      U => BEGIN assignment ¬ [register[U]]; pattern ¬ @patternAssignU; END;      UY =>        BEGIN        assignment ¬ [register[UY]];        pattern ¬ @patternAssignUY;        phrase.arg ¬ Inline.BITSHIFT[phrase.arg, 4];        END;      bus =>  -- [] ¬         -- no need to encode anything for a bus asignment.  We don't know yet what bus to  put it on.  It will fall out in the wash when we see what bus input is needed later.        RETURN;      ENDCASE =>        BEGIN        SyntaxError[phrase, unexpectedLHS];        MakeTempErrorMsgsPermanent[phrase];        RETURN;        END;    -- The old list will be replaced by a new list.    nextOldEncoding ¬ phrase.encoding;    phrase.encoding ¬ NIL;    UNTIL nextOldEncoding = NIL DO  -- once for each encoding in the list      trialEncoding­ ¬ nextOldEncoding­;      IF EncodePattern[phrase, pattern, trialEncoding, assignment] THEN        BEGIN        -- We have an encoding of the register that works.  Chain it onto the list of encoding records for this phrase.        lastNextEncodingPtrInNewChain­ ¬ trialEncoding;        trialEncoding.nextEncoding ¬ NIL;        lastNextEncodingPtrInNewChain ¬ @trialEncoding.nextEncoding;        trialEncoding ¬ AllocateEncodingRecord[];        successful ¬ TRUE;        END;      nextOldEncoding ¬ nextOldEncoding.nextEncoding;      ENDLOOP;    IF NOT successful THEN      BEGIN      SyntaxError[phrase, unexpectedLHS];      MakeTempErrorMsgsPermanent[phrase];      RETURN;      END;    -- If any patterns could not be encoded, error messages are chained onto tempFormatErrorMsgs.  If we found a pattern that works, we delete the temp error messages.  If no pattern could be encoded, we will print all of the error messages.    IF NOT successful THEN MakeTempErrorMsgsPermanent[phrase];    RETURN;    END;  EncodeRHS: PROCEDURE [phrase: PhrasePtr] =    BEGIN    -- Look for and encode the right hand side of an expression.  This is called by EncodeLHS when a register assignment or macro has been found as the first element of a phrase.    BEGIN  -- Error block    dS: DSource ¬ x;    IF (phrase.currentElement ¬ phrase.currentElement.nextElement) = NIL THEN      RETURN;  -- no right hand side    WITH phrase.currentElement­.elementRec SELECT FROM      macro =>        BEGIN EncodeMacro[phrase, macroIndex]; EncodeRHS[phrase]; RETURN; END;      register =>        BEGIN        IF NextElementIsArrow[phrase] THEN          BEGIN          -- We have a multiple assignment statement.          EncodeRegisterLHS[phrase, registerType, regnum];          phrase.currentElement ¬ phrase.currentElement.nextElement;          IF phrase.currentElement.nextElement = NIL THEN            BEGIN            SyntaxError[phrase, noRHS];            GO TO SyntaxError;  -- syntax error if no right hand side            END;          EncodeRHS[phrase];          RETURN;          END  -- of multiple assignment        ELSE          BEGIN  -- simple assignment          phrase.expression.operand1 ¬ D;          SELECT registerType FROM            R => BEGIN phrase.expression.operand1 ¬ AB; phrase.arg1 ¬ regnum; END;            RH =>              BEGIN              phrase.expression.dSource ¬ rh;              phrase.arg ¬ regnum;              phrase.encoding.xbusLoad ¬ TRUE;              END;            U => BEGIN phrase.expression.dSource ¬ u; phrase.arg ¬ regnum; END;            UY =>              BEGIN              phrase.expression.dSource ¬ uy;              phrase.arg ¬ Inline.BITSHIFT[regnum, 4];              END;            RHm =>              BEGIN phrase.expression.operand1 ¬ RHm; phrase.arg1 ¬ regnum; END;            STK => phrase.expression.dSource ¬ stk;            Q => phrase.expression.operand1 ¬ Q;            MD => phrase.expression.dSource ¬ mem;            ENDCASE => ERROR EncodeError[registerType];          IF NOT EncodeOperation[phrase] THEN GO TO SyntaxError;          END;  -- of simple assignment        END;      IOXIn =>        BEGIN        phrase.expression.operand1 ¬ D;        phrase.expression.dSource ¬ (SELECT fField FROM  --  Do the port sources ****DP	          z => ioInZ,		  port => port,		  ports => ports,		  ENDCASE => ioInY);  --  Is y =>        phrase.arg ¬ IOInAddr;        IF NOT EncodeOperation[phrase] THEN GO TO SyntaxError;        END;      minus =>        BEGIN        phrase.expression.operand1 ¬ zero;        phrase.expression.operation ¬ minus;        phrase.expression.carry ¬ one;        IF NOT EncodeSecondOperand[phrase] THEN GO TO SyntaxError;        END;      not =>        BEGIN        IF phrase.expression.operation = Nx THEN          BEGIN SyntaxError[phrase, doubleNot]; GO TO SyntaxError; END;        phrase.expression.operation ¬ Nx;        EncodeRHS[phrase];        RETURN;        END;      constant =>        BEGIN        phrase.expression.operand1 ¬ D;        dS ¬ NibbleOrByte[value];        SELECT dS FROM          zero => phrase.expression.operand1 ¬ zero;          one => phrase.expression.dSource ¬ nibl;          ENDCASE => phrase.expression.dSource ¬ dS;        phrase.arg1 ¬ value;        phrase.arg ¬ value;        IF NOT EncodeOperation[phrase] THEN GO TO SyntaxError;        END;      ENDCASE => BEGIN SyntaxError[phrase, unexpectedRHS]; GO TO SyntaxError; END;    IF phrase.currentElement # NIL THEN      BEGIN SyntaxError[phrase, endOfPhrase]; GO TO SyntaxError; END;    EncodeExpression[phrase];    EXITS SyntaxError => NULL;    END;  -- OF error block    RETURN;    END;  EncodeSecondOperand: PROCEDURE [phrase: PhrasePtr]    RETURNS [noSyntaxError: BOOLEAN] =  --new    BEGIN    dS: DSource ¬ x;    -- Look for and encode the operand that follows the operation.  This is called by EncodeOperation when an operation (plus, minus or logical) has been encountered.    noSyntaxError ¬ TRUE;    BEGIN  -- error block    IF (phrase.currentElement ¬ phrase.currentElement.nextElement) = NIL THEN      BEGIN      SyntaxError[phrase, noOperand];      GO TO SyntaxError;  -- error if operation is not followed by operand      END;    WITH phrase.currentElement­.elementRec SELECT FROM      register =>        BEGIN        phrase.expression.operand2 ¬ D;        SELECT registerType FROM          R => BEGIN phrase.expression.operand2 ¬ AB; phrase.arg2 ¬ regnum; END;          RH => BEGIN phrase.expression.dSource ¬ rh; phrase.arg ¬ regnum; END;          U => BEGIN phrase.expression.dSource ¬ u; phrase.arg ¬ regnum; END;          UY =>            BEGIN            phrase.expression.dSource ¬ uy;            phrase.arg ¬ Inline.BITSHIFT[regnum, 4];            END;          STK => phrase.expression.dSource ¬ stk;          Q => phrase.expression.operand2 ¬ Q;          MD => phrase.expression.dSource ¬ mem;          ENDCASE => ERROR EncodeError[registerType];        noSyntaxError ¬ EncodePlusOrMinusOne[phrase];        END;      IOXIn =>        BEGIN        phrase.expression.operand2 ¬ D;         phrase.expression.dSource ¬ (SELECT fField FROM  --  Do the port sources ****DP	          z => ioInZ,		  port => port,		  ports => ports,		  ENDCASE => ioInY);  --  Is y =>       phrase.arg ¬ IOInAddr;        noSyntaxError ¬ EncodePlusOrMinusOne[phrase];        END;      not =>        SELECT phrase.expression.operation FROM          xor =>            BEGIN            phrase.expression.operation ¬ Nxor;            noSyntaxError ¬ EncodeSecondOperand[phrase];            END;          and =>            BEGIN            phrase.expression.operation ¬ Nand;            noSyntaxError ¬ EncodeSecondOperand[phrase];            ReverseOperands[phrase];            END;          ENDCASE => BEGIN SyntaxError[phrase, doubleNot]; GO TO SyntaxError; END;      pc16 =>        BEGIN        phrase.expression.operand2 ¬ zero;        dS ¬ zero;        phrase.expression.carry ¬ x;        EncodeMacro[phrase, macroIndex];        noSyntaxError ¬ EncodeEnd[phrase];        END;      constant =>        BEGIN        dS ¬ NibbleOrByte[value];        phrase.expression.operand2 ¬ D;        SELECT phrase.expression.operation FROM          plus =>            SELECT dS FROM              zero => phrase.expression.operand2 ¬ zero;              one =>                BEGIN                phrase.expression.operand2 ¬ zero;                phrase.expression.carry ¬ one;                END;              ENDCASE => GOTO normal;          minus =>            SELECT dS FROM              zero => phrase.expression.operand2 ¬ zero;              one =>                BEGIN                phrase.expression.operand2 ¬ zero;                phrase.expression.carry ¬ zero;                END;              ENDCASE => GOTO normal;          ENDCASE =>            SELECT dS FROM              zero => phrase.expression.operand2 ¬ zero;              one =>                BEGIN                phrase.expression.dSource ¬ nibl;                phrase.arg2 ¬ value;                phrase.arg ¬ value;                END;              ENDCASE => GOTO normal;        noSyntaxError ¬ EncodePlusOrMinusOne[phrase];        EXITS          normal =>            BEGIN            phrase.expression.dSource ¬ dS;            phrase.arg2 ¬ value;            phrase.arg ¬ value;            noSyntaxError ¬ EncodePlusOrMinusOne[phrase];            END;        END;      ENDCASE => SyntaxError[phrase, unexpectedRHS];    EXITS SyntaxError => noSyntaxError ¬ FALSE;    END;  -- OF error block    RETURN;    END;  EncodeStatement: PUBLIC PROCEDURE [statement: StatementPtr]    RETURNS [successful: BOOLEAN] =    BEGIN    -- Create one or more Encoding records for each Phrase of the Statement.  Encoding of the Phrase will be aborted if a syntax error is encountered, but encoding will continue if format or timing errors are detected.  If not successful, error messsages are queued on phrase.errorMsgs.      formatError: BOOLEAN ¬ FALSE;    phrase: PhrasePtr ¬ statement.firstPhrase;    syntaxError: BOOLEAN ¬ FALSE;    UNTIL phrase = NIL DO      EncodePhrase[phrase];      syntaxError ¬ syntaxError OR phrase.syntaxError;      formatError ¬ formatError OR phrase.formatError;      phrase ¬ phrase.nextPhrase;      ENDLOOP;    statement.formatError ¬ formatError;    statement.syntaxError ¬ syntaxError;    RETURN[NOT (syntaxError OR formatError)];    END;  FindExpression: PROCEDURE [phrase: PhrasePtr]    RETURNS [      eP: ExpressionPatternPtr, dP: LONG POINTER TO DSourcePattern,      pP: LONG POINTER TO Pattern] =    BEGIN    expressionArgs: ExpressionArgs ¬ [      phrase.expression.operand1, phrase.expression.operand2];    i: CARDINAL;    table: LONG DESCRIPTOR FOR ARRAY OF ExpressionPattern;    table ¬      SELECT phrase.expression.operation FROM        x => patternOpx,        Nx => patternOpNx,        or => patternOpor,        and => patternOpand,        Nand => patternOpNand,        xor => patternOpxor,        Nxor => patternOpNxor,        plus => patternOpplus,        minus => patternOpminus,        ENDCASE => patternOpx;    eP ¬ NIL;    dP ¬ NIL;    FOR i IN [0..LENGTH[table]) DO      IF table[i].expressionArgs = expressionArgs THEN        BEGIN eP ¬ @table[i]; EXIT; END;      ENDLOOP;    IF phrase.expression.dSource # x THEN      BEGIN      FOR i IN [0..LENGTH[ET.patternDSource]) DO        IF ET.patternDSource[i].dSource = phrase.expression.dSource THEN          BEGIN dP ¬ @ET.patternDSource[i]; EXIT; END;        ENDLOOP;      END;    pP ¬      SELECT phrase.expression.carry FROM        zero => @ET.patternCin0,        one => @ET.patternCin1,        ENDCASE => NIL;    END;  NextElementIsArrow: PROCEDURE [phrase: PhrasePtr] RETURNS [true: BOOLEAN] =    BEGIN    IF phrase.currentElement.nextElement = NIL THEN RETURN[FALSE];    IF phrase.currentElement.nextElement­.elementRec.type = arrow THEN      RETURN[TRUE];    RETURN[FALSE];    END;  NextElementIsOne: PROCEDURE [phrase: PhrasePtr] RETURNS [{pc16, one, bad}] =    BEGIN    -- Look to see if one or pc16 follows plus or minus.    IF (phrase.currentElement ¬ phrase.currentElement.nextElement) = NIL THEN      RETURN[bad];    WITH phrase.currentElement­.elementRec SELECT FROM      constant => IF value = 1 THEN RETURN[one];      pc16 => BEGIN EncodeMacro[phrase, macroIndex]; RETURN[pc16]; END;      ENDCASE;    RETURN[bad];    END;  NibbleOrByte: PROCEDURE [value: CARDINAL] RETURNS [DSource] =  --new    BEGIN    SELECT value FROM      = 0 => RETURN[zero];      = 1 => RETURN[one];      < 16 => RETURN[nibl];      < 256 => RETURN[byte];      ENDCASE => ERROR EncodeError[invalidConstantValue];    END;  ReverseOperands: PROCEDURE [phrase: PhrasePtr] =    BEGIN    oldArg1: CARDINAL ¬ phrase.arg1;    oldOperand1: Operand ¬ phrase.expression.operand1;    phrase.arg1 ¬ phrase.arg2;    phrase.arg2 ¬ oldArg1;    phrase.expression.operand1 ¬ phrase.expression.operand2;    phrase.expression.operand2 ¬ oldOperand1;    RETURN;    END;  -- MAIN LINE CODE  END...    -- Log  -- Time: 26-Sep-84 20:40:11	By: DEG     	Action: Added copyright notice and rebuild for 11.1 release.  -- 16-Sep-83 15:30:22 - DEG     	- Converted to Klamath 11.0b  -- 11-Jul-83 10:07:44 - JAC        -Removed call to DeleteTempErrorMsgs in                                     EncodeMacro because of new space allocation  -- 16-Jul-82 13:15:06 - ETN        - TrinityMass Version 1  
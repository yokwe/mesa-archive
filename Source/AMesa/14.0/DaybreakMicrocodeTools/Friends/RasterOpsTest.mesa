-- RasterOpsTest.mesa-- Create by FormSWLayoutTool on 11-Aug-86 12:35-- Last edited by JPM on 9-Sep-86 13:36:31DIRECTORY  BitBlt,  Display,  Exec,  FormSW,  Heap,  Inline,  MSegment,  MsgSW,  RasterOps,  Runtime,  Tool,  ToolWindow,  Window;RasterOpsTest: PROGRAM  IMPORTS    Display, Exec, FormSW, Heap, Inline, MSegment, MsgSW, RasterOps, Runtime, Tool, ToolWindow = {  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = MACHINE DEPENDENT RECORD [    msgSW(0): Window.Handle ¬ NIL,    formSW(2): Window.Handle ¬ NIL,    displaySW(4): Window.Handle ¬ NIL,    bitOffset(6): NATURAL ¬ 0,    count(7): INTEGER ¬ 0,    srcFunc(8): BitBlt.SrcFunc ¬ null,    dstFunc(9): BitBlt.DstFunc ¬ null,    grayWord(10): WORD ¬ 0,    startBit(11): RasterOps.Bit ¬ 0,    chainCount(12): ARRAY [0..4) OF CARDINAL ¬ ALL[0],    dataPtr(16): LONG POINTER ¬ NIL,    useSoftwareProc(18): BOOLEAN ¬ FALSE];  FormItems: TYPE = {useSoftwareProc, bltLineGray, bumpBitAddress, chainBlt, countBitsOff, countBitsOn, bitOffset, count, srcFunc, dstFunc, grayWord, startBit, count0, count1, count2, count3};  data: DataHandle ¬ NIL;  wh: Window.Handle ¬ NIL;  zone: UNCOUNTED ZONE ¬ Heap.systemZone;  BLTLineGray:  FormSW.ProcType = {    IF data.useSoftwareProc AND NOT Runtime.IsBound [LOOPHOLE [RasterOps.SoftwareBLTLineGray] ] THEN {      MsgSW.Post[data.msgSW, "no s/w proc for BLTLineGray"L];      RETURN};    IF data.useSoftwareProc      THEN RasterOps.SoftwareBLTLineGray[MakeBitAddress[], [srcFunc: data.srcFunc, dstFunc: data.dstFunc], data.count, data.grayWord]      ELSE RasterOps.BLTLineGray[MakeBitAddress[], [srcFunc: data.srcFunc, dstFunc: data.dstFunc], data.count, data.grayWord];    MsgSW.Post[data.msgSW, "BLTLineGray completed OK"L];    DisplayData[]};  BumpBitAddress:  FormSW.ProcType = {    addr: RasterOps.BitAddress;    IF data.useSoftwareProc AND NOT Runtime.IsBound [LOOPHOLE [RasterOps.SoftwareBumpBitAddress] ] THEN {      MsgSW.Post[data.msgSW, "no s/w proc for BumpBitAddress"L];      RETURN};    addr ¬ (IF data.useSoftwareProc      THEN RasterOps.SoftwareBumpBitAddress[MakeBitAddress[], data.count]      ELSE RasterOps.BumpBitAddress[MakeBitAddress[], data.count]);    IF LONG[(data.bitOffset + data.count)] # UnmakeBitAddress[addr]      THEN MsgSW.Post[data.msgSW, "BumpBitAddress returned incorrect result"L] ELSE {      MsgSW.Post[data.msgSW, "BumpBitAddress completed OK"L];      data.bitOffset ¬ data.bitOffset + data.count;      FormSW.Display[sw]}};  ChainBLT:  FormSW.ProcType = {    IF data.useSoftwareProc AND NOT Runtime.IsBound [LOOPHOLE [RasterOps.SoftwareChainBLT] ] THEN {      MsgSW.Post[data.msgSW, "no s/w proc for ChainBLT"L];      RETURN};    IF data.useSoftwareProc      THEN RasterOps.SoftwareChainBLT[MakeBitAddress[], data.startBit, DESCRIPTOR[data.chainCount]]      ELSE RasterOps.ChainBLT[MakeBitAddress[], data.startBit, DESCRIPTOR[data.chainCount]];    MsgSW.Post[data.msgSW, "ChainBLT completed OK"L];    DisplayData[]};  CountBitsOff:  FormSW.ProcType = {    stopAddr: RasterOps.BitAddress;    count: NATURAL;    IF data.useSoftwareProc AND NOT Runtime.IsBound [LOOPHOLE [RasterOps.SoftwareCountBitsOff] ] THEN {      MsgSW.Post[data.msgSW, "no s/w proc for CountBitsOff"L];      RETURN};    IF data.useSoftwareProc      THEN [stopAddr, count] ¬ RasterOps.SoftwareCountBitsOff[MakeBitAddress[], LAST[NATURAL], data.count]      ELSE [stopAddr, count] ¬ RasterOps.CountBitsOff[MakeBitAddress[], LAST[NATURAL], data.count];    IF LONG[(count - data.count + data.bitOffset)] # UnmakeBitAddress[stopAddr]      THEN MsgSW.Post[data.msgSW, "CountBitsOff returned inconsistent results"L] ELSE {      MsgSW.Post[data.msgSW, "CountBitsOff completed OK"L];      data.count ¬ count;      FormSW.Display[sw]}};  CountBitsOn:  FormSW.ProcType = {    stopAddr: RasterOps.BitAddress;    count: NATURAL;    IF data.useSoftwareProc AND NOT Runtime.IsBound [LOOPHOLE [RasterOps.SoftwareCountBitsOn] ] THEN {      MsgSW.Post[data.msgSW, "no s/w proc for CountBitsOn"L];      RETURN};    IF data.useSoftwareProc      THEN [stopAddr, count] ¬ RasterOps.SoftwareCountBitsOn[MakeBitAddress[], LAST[NATURAL], data.count]      ELSE [stopAddr, count] ¬ RasterOps.CountBitsOn[MakeBitAddress[], LAST[NATURAL], data.count];    IF LONG[(count - data.count + data.bitOffset)] # UnmakeBitAddress[stopAddr]      THEN MsgSW.Post[data.msgSW, "CountBitsOn returned inconsistent results"L] ELSE {      MsgSW.Post[data.msgSW, "CountBitsOn completed OK"L];      data.count ¬ count;      FormSW.Display[sw]}};  DisplayData: PROC = {    Display.Bitmap[data.displaySW, [[0,0],[256,256]], [data.dataPtr, , 0], 256, Display.replaceFlags]};  MakeBitAddress: PROC RETURNS [RasterOps.BitAddress] = INLINE {    RETURN[[(data.dataPtr + data.bitOffset / 16), , (Inline.LowHalf[data.bitOffset] MOD 16)]]};  UnmakeBitAddress: PROC [addr: RasterOps.BitAddress] RETURNS [LONG INTEGER] = INLINE {    RETURN[(16 * (addr.word - data.dataPtr) + addr.bit)]};  ClientTransition: ToolWindow.TransitionProcType = {    SELECT TRUE FROM      old = inactive =>        IF data = NIL THEN {	  data ¬ zone.NEW[Data ¬ []];	  data.dataPtr ¬ MSegment.GetPages[16]};      new = inactive =>        IF data # NIL THEN {	  IF data.dataPtr # NIL THEN MSegment.FreePages[data.dataPtr];	  zone.FREE[@data]};      ENDCASE;    };  Init: PROCEDURE = {    Exec.AddCommand[name: "RasterOpsTest"L, proc: TestProc, unload: UnloadProc];    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default,      clientTransition: ClientTransition, name: "RasterOpsTest"L,      cmSection: "RasterOpsTest"L];    };  MakeSWs: Tool.MakeSWsProc = {    NullProc: PROC [sw: Window.Handle, clientData: LONG POINTER] = {};    data.msgSW ¬ Tool.MakeMsgSW[window: window];    data.formSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeForm];    data.displaySW ¬ Tool.MakeClientSW[window, NullProc, NIL, vanilla];    };  MakeForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = FormItems.LAST.ORD + 1;    srcFunc: ARRAY[0..2) OF Enumerated ¬ [      ["null"L, 0], ["complement"L, 1]];    dstFunc: ARRAY[0..4) OF Enumerated ¬ [      ["null"L, 0], ["and"L, 1],      ["or"L, 2], ["xor"L, 3]];    startBit: ARRAY[0..2) OF Enumerated ¬ [      ["0"L, 0], ["1"L, 1]];    items ¬ AllocateItemDescriptor[nItems];    items[FormItems.useSoftwareProc.ORD] ¬ BooleanItem[      tag: "s/w"L, place: [6, line0], switch: @data.useSoftwareProc];    items[FormItems.bltLineGray.ORD] ¬ CommandItem[      tag: "BLTLineGray"L, place: [36, line0], proc: BLTLineGray];    items[FormItems.bumpBitAddress.ORD] ¬ CommandItem[      tag: "BumpBitAddress"L, place: [126, line0], proc: BumpBitAddress];    items[FormItems.chainBlt.ORD] ¬ CommandItem[      tag: "ChainBLT"L, place: [234, line0], proc: ChainBLT];    items[FormItems.countBitsOff.ORD] ¬ CommandItem[      tag: "CountBitsOff"L, place: [306, line0], proc: CountBitsOff];    items[FormItems.countBitsOn.ORD] ¬ CommandItem[      tag: "CountBitsOn"L, place: [402, line0], proc: CountBitsOn];    items[FormItems.bitOffset.ORD] ¬ NumberItem[      tag: "bitOffset"L, place: [24, line1], signed: FALSE, notNegative: TRUE, boxWidth: 48, default: 0, value: @data.bitOffset];    items[FormItems.count.ORD] ¬ NumberItem[      tag: "count"L, place: [204, line1], signed: TRUE, notNegative: FALSE, boxWidth: 48, default: 0, value: @data.count];    items[FormItems.srcFunc.ORD] ¬ EnumeratedItem[      tag: "srcFunc"L, place: [24, line2], choices: DESCRIPTOR[srcFunc], value: @data.srcFunc];    items[FormItems.dstFunc.ORD] ¬ EnumeratedItem[      tag: "dstFunc"L, place: [204, line2], choices: DESCRIPTOR[dstFunc], value: @data.dstFunc];    items[FormItems.grayWord.ORD] ¬ NumberItem[      tag: "grayWord"L, place: [342, line2], signed: FALSE, notNegative: TRUE, radix: octal, boxWidth: 48, default: 0, value: @data.grayWord];    items[FormItems.startBit.ORD] ¬ EnumeratedItem[      tag: "startBit"L, place: [24, line3], choices: DESCRIPTOR[startBit], value: @data.startBit];    items[FormItems.count0.ORD] ¬ NumberItem[      tag: "count0"L, place: [114, line3], signed: FALSE, boxWidth: 48, default: 0, value: @data.chainCount[0]];    items[FormItems.count1.ORD] ¬ NumberItem[      tag: "count1"L, place: [204, line3], signed: FALSE, notNegative: TRUE, boxWidth: 48, default: 0, value: @data.chainCount[1]];    items[FormItems.count2.ORD] ¬ NumberItem[      tag: "count2"L, place: [300, line3], signed: FALSE, notNegative: TRUE, boxWidth: 48, default: 0, value: @data.chainCount[2]];    items[FormItems.count3.ORD] ¬ NumberItem[      tag: "count3"L, place: [396, line3], signed: FALSE, notNegative: TRUE, boxWidth: 48, default: 0, value: @data.chainCount[3]];    RETURN[items: items, freeDesc: TRUE];    };  TestProc: Exec.ExecProc = {    ToolWindow.Activate [wh]};  UnloadProc: Exec.ExecProc = {    Tool.Destroy[wh];    Exec.RemoveCommand[h, "RasterOpsTest"L]};  -- Mainline code  Init[];  -- this gets string out of global frame  }...    
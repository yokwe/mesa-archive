-- HalfToneToolImpl.mesa-- originated from JMonahan's GrayBltTest.mesa-- Last edited by MRR         18-Dec-86  8:45:16DIRECTORY  Display, Environment, Exec, Format, FormSW, HalfTone, HalfToneCells, Heap, Inline, MFile, MSegment, MsgSW, Process, Put, System, Tool, ToolWindow, Window;HalfToneToolImpl: MONITOR  IMPORTS    Display, Exec, FormSW, HalfTone, Heap, Inline, MFile, MSegment, MsgSW, Process, Put, System, Tool, ToolWindow = {--BrushRec: TYPE = RECORD [hdr: BrushHeader, bitmap: ARRAY [0..0] OF INTEGER];--BrushHeader: TYPE = RECORD [--  version: [0..256),--  masked: BOOLEAN,--  size: Window.Dims,--  place: Window.Place,--  offset: Window.Place,--  wpl: INTEGER];  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = MACHINE DEPENDENT RECORD [    msgSW(0): Window.Handle ¬ NIL,    formSW(2): Window.Handle ¬ NIL,    displaySW(4): Window.Handle ¬ NIL,    srcPixelsPerLine(6): NATURAL ¬ 0,    srcX(7): NATURAL ¬ 0,    srcY(8): NATURAL ¬ 0,    srcPages(9): NATURAL ¬ 0,    srcFilename(10): LONG STRING ¬ NIL,    destPixelsPerLine(12): NATURAL ¬ 0,    destX(13): NATURAL ¬ 0,    destY(14): NATURAL ¬ 0,    destPages(15): NATURAL ¬ 0,    destFilename(16): LONG STRING ¬ NIL,    invertReq(18): BOOLEAN ¬ FALSE,    swReq(19): BOOLEAN ¬ FALSE,    width(20): NATURAL ¬ 0,    height(21): NATURAL ¬ 0,    srcSeg(22): MSegment.Handle ¬ NIL,    destSeg(24): MSegment.Handle ¬ NIL,    abort(26): BOOLEAN ¬ FALSE,    HTcellType(27): HalfToneCells.HTcellTypes ¬ kod1];  FormItems: TYPE = {source, srcPixelsPerLine, srcX, srcY, srcLoad, srcStore, srcPages, srcFilename, destination, destPixelsPerLine, destX, destY, destLoad, destStore, destPages, destFilename, invertReq, halftonecell, width, height, SW, testloop, testabort, halftone, timehalftone};  busyBit: BOOLEAN ¬ FALSE;  data: DataHandle ¬ NIL;  firstpulse: System.Pulses ¬ [pulses:0];  result: System.Microseconds ¬ 0;  secondpulse: System.Pulses ¬ [pulses:0];  timer: BOOLEAN ¬ FALSE;  wh: Window.Handle ¬ NIL;  zone: UNCOUNTED ZONE ¬ Heap.systemZone;  Busy: ENTRY PROCEDURE RETURNS [isBusy: BOOLEAN] = {    isBusy ¬ busyBit;    busyBit ¬ TRUE };  DestLoad:  FormSW.ProcType = {    file: MFile.Handle;    pages: CARDINAL;    IF data.destFilename = NIL OR data.destFilename.length = 0 THEN {      MsgSW.Post[data.msgSW, "invalid parameters"L];      RETURN};    file ¬ MFile.ReadOnly[data.destFilename, []      ! MFile.Error => {        MsgSW.Post[data.msgSW, "file error"L];	GOTO exit} ];    IF (pages ¬ MIN[Inline.LongDiv [MFile.GetLength [file], Environment.bytesPerPage], data.destPages]) = 0 THEN {      MsgSW.Post[data.msgSW, "can't load 0 pages"L];      MFile.Release [file];      RETURN};    IF data.destSeg # NIL AND MSegment.Pages [data.destSeg] < pages THEN {      MSegment.Delete [data.destSeg];      data.destSeg ¬ NIL};    IF data.destSeg = NIL THEN data.destSeg ¬ MSegment.Create [release: [], pages: pages];    MSegment.CopyIn [data.destSeg, file, 0, pages];    MFile.Release [file];    MsgSW.Post[data.msgSW, "destination loaded OK"L];    EXITS      exit => NULL};  DestStore:  FormSW.ProcType = {    file: MFile.Handle;    pages: CARDINAL;    ptr: LONG POINTER ¬ NIL;    IF data.destFilename = NIL OR data.destFilename.length = 0 THEN {      MsgSW.Post[data.msgSW, "invalid parameters"L];      RETURN};    file ¬ MFile.WriteOnly[data.destFilename, [], binary      ! MFile.Error => {        MsgSW.Post[data.msgSW, "file error"L];	GOTO exit} ];    MFile.SetLength [file, Inline.LongMult [data.destPages, Environment.bytesPerPage]];    ptr ¬ MSegment.Address[data.destSeg];    ptr­ ¬ 0100h;			-- version and masked    ptr ¬ ptr + 1;    ptr­ ¬ data.destPixelsPerLine;		-- size, width    ptr ¬ ptr + 1;    ptr­ ¬ data.height;			-- size, height    ptr ¬ ptr + 1;    ptr­ ¬ 0;				-- place, x    ptr ¬ ptr + 1;    ptr­ ¬ 0;				-- place, y    ptr ¬ ptr + 1;    ptr­ ¬ 0;				-- offset, x    ptr ¬ ptr + 1;    ptr­ ¬ 0;				-- offset, y    ptr ¬ ptr + 1;    ptr­ ¬ data.destPixelsPerLine/16;	-- wpl    IF data.destSeg # NIL THEN {      pages ¬ MIN[data.destPages, Inline.LowHalf[MSegment.Pages [data.destSeg]]];      IF pages > 0 THEN MSegment.CopyOut [data.destSeg, file, 0, pages]};    MFile.Release [file];    MsgSW.Post[data.msgSW, "destination stored OK"L];    EXITS      exit => NULL};  Done: ENTRY PROCEDURE = {    ENABLE UNWIND => NULL;    busyBit ¬ FALSE}; HalfToneProc:  PROCEDURE = {    CellCount: NATURAL ¬ 1;    CurrentHTcell: HalfToneCells.Cell ¬ HTcells[data.HTcellType];    DstLine: HalfTone.BitAddress ¬ [NIL, 0, 0];    HTcellLine: NATURAL ¬ 1;    HTLine: HalfTone.HTtype;    HToffset: CARDINAL ¬ 0;    HTptr: LONG POINTER ¬ @CurrentHTcell.HTCell;    offset: LONG CARDINAL ¬ 0;    ptr: LONG POINTER ¬ NIL;    SrcLine: HalfTone.SLtype;    HTLine.BASE ¬ HTptr;    HTLine.LENGTH ¬ CurrentHTcell.width;    IF data.srcSeg = NIL THEN {      MsgSW.Post[data.msgSW, "no source!"L];      RETURN};    ptr ¬ MSegment.Address[data.srcSeg];    offset ¬ Inline.LongMult[data.srcPixelsPerLine/2, data.srcY] + data.srcX;    SrcLine.SlLength ¬ data.srcPixelsPerLine;    SrcLine.ByteAddr.word ¬ ptr + offset;    SrcLine.ByteAddr.byte ¬ 0;		-- point to high byte    IF data.destSeg = NIL THEN {      IF data.destPages = 0 THEN {        MsgSW.Post[data.msgSW, "can't make destination with 0 pages"L];        RETURN};      data.destSeg ¬ MSegment.Create [release: [], pages: data.destPages]};    ptr ¬ MSegment.Address[data.destSeg];    ptr ¬ ptr + 8;    offset ¬ Inline.LongMult[data.destPixelsPerLine, data.destY] + data.destX;    DstLine ¬ [(ptr + offset / 16), , (Inline.LowHalf[offset] MOD 16)];    firstpulse ¬ System.GetClockPulses[];    Put.Text[data.msgSW, "HalfToning ..."L];    IF data.swReq THEN {     THROUGH [0 .. data.height) DO       HalfTone.SoftwareHalfTone[SrcLine, HTLine, HToffset, DstLine, data.invertReq];       SrcLine.ByteAddr.word ¬ SrcLine.ByteAddr.word + data.srcPixelsPerLine/2;       IF HTcellLine >= CurrentHTcell.height THEN {	 CellCount ¬ CellCount + 1;	-- left in for debugging purposes.	 HToffset ¬ (HToffset+CurrentHTcell.offset) MOD HTLine.LENGTH;	 HTLine.BASE ¬ HTptr;	 HTcellLine ¬ 1; }       ELSE {         HTLine.BASE ¬ HTLine.BASE + HTLine.LENGTH;	 HTcellLine ¬ HTcellLine + 1; };       offset ¬ DstLine.bit + data.destPixelsPerLine;       DstLine ¬ [(DstLine.word + offset / 16), , (Inline.LowHalf[offset] MOD 16)]      ENDLOOP; }    ELSE {      THROUGH [0 .. data.height) DO        HalfTone.HALFTONE[SrcLine, HTLine, HToffset, DstLine, data.invertReq];        SrcLine.ByteAddr.word ¬ SrcLine.ByteAddr.word + data.srcPixelsPerLine/2;        IF HTcellLine >= CurrentHTcell.height THEN {	  CellCount ¬ CellCount + 1;	-- left in for debugging purposes.	  HToffset ¬ (HToffset+CurrentHTcell.offset) MOD HTLine.LENGTH;	  HTLine.BASE ¬ HTptr;	  HTcellLine ¬ 1; }        ELSE {          HTLine.BASE ¬ HTLine.BASE + HTLine.LENGTH;	  HTcellLine ¬ HTcellLine + 1; };        offset ¬ DstLine.bit + data.destPixelsPerLine;        DstLine ¬ [(DstLine.word + offset / 16), , (Inline.LowHalf[offset] MOD 16)]      ENDLOOP; };    secondpulse ¬ System.GetClockPulses[];    firstpulse.pulses ¬ secondpulse.pulses-firstpulse.pulses;    result ¬ System.PulsesToMicroseconds[firstpulse];    IF timer THEN {      Put.Text[data.msgSW, " completed in "];      Put.LongNumber[data.msgSW, result, Format.DecimalFormat];      Put.Line[data.msgSW, " microseconds"]; }    ELSE Put.Line[data.msgSW, " completed OK"L];    Display.Bitmap[data.displaySW, [[0,0],[(data.destX + data.width),(data.destY + data.height)]], [ptr, , 0], data.destPixelsPerLine, Display.replaceFlags] };  HaltTestProc: FormSW.ProcType = {    data.abort ¬ TRUE };  SrcLoad:  FormSW.ProcType = {    file: MFile.Handle;    pages: CARDINAL;    IF data.srcFilename = NIL OR data.srcFilename.length = 0 THEN {      MsgSW.Post[data.msgSW, "invalid parameters"L];      RETURN};    file ¬ MFile.ReadOnly[data.srcFilename, []      ! MFile.Error => {        MsgSW.Post[data.msgSW, "file error"L];	GOTO exit} ];    IF (pages ¬ MIN[Inline.LongDiv [MFile.GetLength [file], Environment.bytesPerPage], data.srcPages]) = 0 THEN {      MsgSW.Post[data.msgSW, "can't load 0 pages"L];      MFile.Release [file];      RETURN};    IF data.srcSeg # NIL AND MSegment.Pages [data.srcSeg] < pages THEN {      MSegment.Delete [data.srcSeg];      data.srcSeg ¬ NIL};    IF data.srcSeg = NIL THEN data.srcSeg ¬ MSegment.Create [release: [], pages: pages];    MSegment.CopyIn [data.srcSeg, file, 0, pages];    MFile.Release [file];    MsgSW.Post[data.msgSW, "source loaded OK"L];    EXITS      exit => NULL};  SrcStore:  FormSW.ProcType = {    file: MFile.Handle;    pages: CARDINAL;    IF data.srcFilename = NIL OR data.srcFilename.length = 0 THEN {      MsgSW.Post[data.msgSW, "invalid parameters"L];      RETURN};    file ¬ MFile.WriteOnly[data.srcFilename, [], binary      ! MFile.Error => {        MsgSW.Post[data.msgSW, "file error"L];	GOTO exit} ];    MFile.SetLength [file, Inline.LongMult [data.srcPages, Environment.bytesPerPage]];    IF data.srcSeg # NIL THEN {      pages ¬ MIN[data.srcPages, Inline.LowHalf[MSegment.Pages [data.srcSeg]]];      IF pages > 0 THEN MSegment.CopyOut [data.srcSeg, file, 0, pages]};    MFile.Release [file];    MsgSW.Post[data.msgSW, "source stored OK"L];    EXITS      exit => NULL};  TimeHalfTone: FormSW.ProcType = {    ENABLE ABORTED => {Done[]; CONTINUE};    SELECT TRUE FROM      Busy[] => MsgSW.Post[data.msgSW, "Tool is busy.\n"L];      ENDCASE => {        timer ¬ TRUE;        HalfToneProc;        timer ¬ FALSE;        Done[] }};  HalfToneLoopProc: PROCEDURE = {    ENABLE ABORTED => {Done[]; CONTINUE};    cellNumber: CARDINAL ¬ 0;    Process.SetPriority[Process.priorityBackground];    FormSW.ToggleVisibility[data.formSW, FormItems.testloop.ORD];    FormSW.ToggleVisibility[data.formSW, FormItems.testabort.ORD];    data.abort ¬ FALSE;    UNTIL data.abort DO      data.HTcellType ¬ VAL[cellNumber MOD 10];      HalfToneProc;      cellNumber ¬ cellNumber + 1;    ENDLOOP;    FormSW.ToggleVisibility[data.formSW, FormItems.testabort.ORD];    FormSW.ToggleVisibility[data.formSW, FormItems.testloop.ORD];    MsgSW.Clear[data.msgSW];    Done[] };  PrepHalfToneProc: PROCEDURE = {    Process.SetPriority[Process.priorityBackground];    HalfToneProc;    Done[]; };  HalfToneIt: FormSW.ProcType = {    ENABLE ABORTED => {Done[]; CONTINUE};    SELECT TRUE FROM      Busy[] => MsgSW.Post[data.msgSW, "Tool is busy.\n"L];      ENDCASE => Process.Detach[FORK PrepHalfToneProc]; };  TestLoopProc: FormSW.ProcType = {    ENABLE ABORTED => {Done[]; CONTINUE};    SELECT TRUE FROM      Busy[] => MsgSW.Post[data.msgSW, "Tool is busy.\n"L];      ENDCASE => Process.Detach[FORK HalfToneLoopProc]; };  Init: PROCEDURE = {    data ¬ MSegment.GetPages[1];    data­ ¬ [];    Exec.AddCommand[name: "HalfToneTool"L, proc: TestProc, unload: UnloadProc];    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default,      name: "HalfToneTool"L,      cmSection: "HalfToneTool"L];    };  MakeSWs: Tool.MakeSWsProc = {    NullProc: PROC [sw: Window.Handle, clientData: LONG POINTER] = {};    data.msgSW ¬ Tool.MakeMsgSW[window: window];    data.formSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeForm];    data.displaySW ¬ Tool.MakeClientSW[window, NullProc, NIL, vanilla];    };  MakeForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = FormItems.LAST.ORD + 1;    halftonecell: ARRAY [0..10) OF Enumerated ¬ [      ["Magic Square"L, HalfToneCells.HTcellTypes[kod1]],      ["Knight Order Dither"L, HalfToneCells.HTcellTypes[kod2]],      ["darkcenter"L, HalfToneCells.HTcellTypes[darkcenter]],      ["lightcenter"L, HalfToneCells.HTcellTypes[lightcenter]],      ["degree45"L, HalfToneCells.HTcellTypes[degree45]],      ["Double Spiral"L, HalfToneCells.HTcellTypes[testcell6]],      ["Holladay60-norm"L, HalfToneCells.HTcellTypes[testcell7]],      ["testcell8"L, HalfToneCells.HTcellTypes[testcell8]],      ["Holladay60-20x4"L, HalfToneCells.HTcellTypes[testcell9]],      ["Holladay45-4x2"L, HalfToneCells.HTcellTypes[testcell10]]];    items ¬ AllocateItemDescriptor[nItems];    items[FormItems.source.ORD] ¬ TagOnlyItem[      tag: "Source"L, place: [6, line0]];    items[FormItems.srcPixelsPerLine.ORD] ¬ NumberItem[      tag: "pixels/line"L, place: [90, line0], boxWidth: 48, signed: FALSE, notNegative: TRUE, value: @data.srcPixelsPerLine];    items[FormItems.srcX.ORD] ¬ NumberItem[      tag: "x"L, place: [246, line0], boxWidth: 48, signed: FALSE, notNegative: TRUE, value: @data.srcX];    items[FormItems.srcY.ORD] ¬ NumberItem[      tag: "y"L, place: [354, line0], boxWidth: 48, signed: FALSE, notNegative: TRUE, value: @data.srcY];    items[FormItems.srcLoad.ORD] ¬ CommandItem[      tag: "Load"L, place: [42, line1], proc: SrcLoad];    items[FormItems.srcStore.ORD] ¬ CommandItem[      tag: "Store"L, place: [90, line1], proc: SrcStore];    items[FormItems.srcPages.ORD] ¬ NumberItem[      tag: "pages"L, place: [150, line1], boxWidth: 48, signed: FALSE, notNegative: TRUE, value: @data.srcPages];    items[FormItems.srcFilename.ORD] ¬ StringItem[      tag: "filename"L, place: [246, line1], inHeap: TRUE, string: @data.srcFilename];    items[FormItems.destination.ORD] ¬ TagOnlyItem[      tag: "Destination"L, place: [6, line2]];    items[FormItems.destPixelsPerLine.ORD] ¬ NumberItem[      tag: "pixels/line"L, place: [90, line2], boxWidth: 48, signed: FALSE, notNegative: TRUE, value: @data.destPixelsPerLine];    items[FormItems.destX.ORD] ¬ NumberItem[      tag: "x"L, place: [246, line2], boxWidth: 48, signed: FALSE, notNegative: TRUE, value: @data.destX];    items[FormItems.destY.ORD] ¬ NumberItem[      tag: "y"L, place: [354, line2], boxWidth: 48, signed: FALSE, notNegative: TRUE, value: @data.destY];    items[FormItems.destLoad.ORD] ¬ CommandItem[      tag: "Load"L, place: [3, line3], proc: DestLoad];    items[FormItems.destStore.ORD] ¬ CommandItem[      tag: "StoreBrush"L, place: [45, line3], proc: DestStore];    items[FormItems.destPages.ORD] ¬ NumberItem[      tag: "pages"L, place: [150, line3], boxWidth: 48, signed: FALSE, notNegative: TRUE, value: @data.destPages];    items[FormItems.destFilename.ORD] ¬ StringItem[      tag: "filename"L, place: [246, line3], inHeap: TRUE, string: @data.destFilename];    items[FormItems.invertReq.ORD] ¬ BooleanItem[      tag: "invert"L, place: [0, line4], switch: @data.invertReq];    items[FormItems.halftonecell.ORD] ¬ EnumeratedItem[      tag: "CellType"L, place: [50, line4], choices: DESCRIPTOR[halftonecell], value:@data.HTcellType];    items[FormItems.width.ORD] ¬ NumberItem[      tag: "pixels/scanline"L, place: [245, line4], boxWidth: 30, signed: FALSE, notNegative: TRUE, value: @data.width];    items[FormItems.height.ORD] ¬ NumberItem[      tag: "# of scanlines"L, place: [375, line4], boxWidth: 30, signed: FALSE, notNegative: TRUE, value: @data.height];    items[FormItems.SW.ORD] ¬ BooleanItem[      tag: "s/w"L, place: [10, line5], switch: @data.swReq];    items[FormItems.testloop.ORD] ¬ CommandItem[      tag: "TestLoop"L, place: [50, line5], proc: TestLoopProc];    items[FormItems.testabort.ORD] ¬ CommandItem[      tag: "HaltTest"L, invisible: TRUE, place: [50, line5], proc: HaltTestProc];    items[FormItems.halftone.ORD] ¬ CommandItem[      tag: "HalfTone"L, place: [150, line5], proc: HalfToneIt];    items[FormItems.timehalftone.ORD] ¬ CommandItem[      tag: "TimeHalfTone"L, place: [250, line5], proc: TimeHalfTone];    RETURN[items: items, freeDesc: TRUE];    };  TestProc: Exec.ExecProc = {    ToolWindow.Activate [wh]};  UnloadProc: Exec.ExecProc = {    Tool.Destroy[wh];    IF data.srcSeg # NIL THEN MSegment.Delete[data.srcSeg];    IF data.destSeg # NIL THEN MSegment.Delete[data.destSeg];    MSegment.FreePages[data];    Exec.RemoveCommand[h, "HalfToneTool"L]};  -- Mainline code  HTcells: HalfToneCells.Cells;  HTcells[kod1] ¬ [width:9, height:9, offset:0,		-- Magic Square    HTCell:[104, 237, 50, 119, 252, 65, 98, 232, 44,            77, 131, 185, 92, 146, 200, 71, 125, 179, 	   212, 23, 158, 226, 38, 173, 206, 17, 152, 	   101, 235, 47, 107, 240, 53, 113, 246, 59, 	   74, 128, 182, 80, 134, 188, 86, 140, 194, 	   209, 20, 155, 215, 26, 161, 220, 32, 167, 	   116, 249, 62, 95, 229, 41, 110, 243, 56, 	   89, 143, 200, 68, 122, 176, 83, 137, 191, 	   223, 35, 170, 203, 14, 149, 217, 29, 164, , , , , , , , , , , , , , , , , , ,]];  HTcells[kod2] ¬ [width:6, height:6, offset:0,		-- Knight Order Dither    HTCell:[142, 234, 78, 158, 247, 94,            47, 3, 174, 63, 15, 190, 	   205, 110, 23, 221, 127, 31, 	   166, 255, 102, 150, 240, 86, 	   70, 19, 197, 55, 7, 182, 	   229, 134, 39, 213, 118, 27, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,]];  HTcells[darkcenter] ¬ [width:3, height:3, offset:0,		-- darkcenter    HTCell:[174, 174, 174,            174, 23, 174, 	   174, 174, 174, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,]];  HTcells[lightcenter] ¬ [width:3, height:3, offset:0,		-- lightcenter    HTCell:[23, 23, 23,            23, 174, 23, 	   23, 23, 23, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,]];  HTcells[degree45] ¬ [width:3, height:3, offset:0,		-- degree45    HTCell:[142, 23, 174,            110, 127, 47, 	   238, 78, 205, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,]];  HTcells[testcell6] ¬ [width:8, height:8, offset:0,		-- Double Spiral    HTCell:[47, 39, 31, 119, 131, 139, 147, 155,            55, 0, 23, 111, 219, 227, 235, 163, 	   63, 7, 15, 103, 211, 251, 243, 171, 	   71, 79, 87, 95, 203, 195, 187, 179, 	   127, 135, 143, 151, 51, 43, 35, 123, 	   215, 223, 231, 159, 59, 3, 27, 115, 	   207, 247, 239, 167, 67, 11, 19, 107, 	   199, 191, 183, 175, 75, 83, 91, 99, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,]];  HTcells[testcell7] ¬ [width:20, height:4, offset:8,		-- Holladay60-norm    HTCell:[14, 74, 77, 80, 83, 86, 89, 92, 95, 98, 101, 194, 197, 200, 203, 206, 209, 212, 215, 217,            23, 26, 104, 107, 110, 113, 116, 119, 122, 125, 128, 131, 220, 223, 226, 229, 232, 235, 17, 20, 	   41, 44, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 237, 240, 243, 246, 29, 32, 35, 38, 	   65, 68, 71, 164, 167, 170, 173, 176, 179, 182, 185, 188, 191, 249, 50, 53, 56, 59, 62, , , , , , , , , , , , , , , , , , , , , ]];  HTcells[testcell8] ¬ [width:10, height:10, offset:0,		-- testcell8    HTCell:[23, 78, 127, 78, 23, 23, 78, 127, 78, 23,            78, 78, 174, 174, 78, 78, 174, 174, 78, 78, 	   127, 78, 127, 78, 127, 127, 78, 127, 78, 127, 	   78, 127, 127, 174, 174, 174, 174, 127, 127, 78, 	   23, 78, 127, 174, 238, 238, 174, 127, 78, 23, 	   127, 47, 110, 142, 205, 205, 142, 110, 47, 127, 	   78, 110, 110, 142, 142, 142, 142, 110, 110, 78, 	   23, 78, 110, 127, 110, 110, 127, 110, 78, 23, 	   78, 47, 127, 127, 47, 47, 127, 127, 47, 78, 	   127, 174, 238, 174, 127, 127, 174, 238, 174, 127]];  HTcells[testcell9] ¬ [width:20, height:4, offset:8,		-- Holladay60    HTCell:[249, 128, 116, 56, 20, 26, 86, 185, 143, 149, 215, 182, 140, 146, 206, 65, 23, 29, 89, 113,            232, 226, 122, 62, 68, 74, 80, 191, 197, 203, 212, 243, 188, 194, 200, 71, 77, 83, 104, 237, 	   167, 161, 223, 170, 164, 158, 217, 53, 47, 41, 101, 125, 229, 235, 240, 107, 44, 38, 98, 173, 	   137, 155, 220, 176, 134, 152, 212, 59, 17, 35, 95, 119, 131, 246, 110, 50, 14, 32, 92, 179, , , , , , , , , , , , , , , , , , , ,]];  HTcells[testcell10] ¬ [width:4, height:2, offset:2,		-- Holladay45    HTCell:[110, 78, 174, 205,            142, 238, 47, 23, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,]];    Init[];  -- this gets string out of global frame  }...  
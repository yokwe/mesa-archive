-- Phase2Test.mesa-- Last edit by JPM 16-Jan-87  9:07:11 - copied Cell def. from HalfToneCells.mesa-- Last edit by JPM 15-Jan-87 16:20:45 - fixed bug in FlipXBitsProc (bad dims passed to Display.Bitmap)-- Last edit by MRR  8-Jan-87 15:22:45 - added scaled halftone capability.DIRECTORY  Display,  Environment,  Exec,  FlipX,  Floyd,  FormSW,  HalfTone,  Heap,  ImageRotation,  Inline,  MFile,  MSegment,  MsgSW,  Runtime,  ScaleBitsToGray,  Tool,  ToolWindow,  Window;Phase2Test: PROGRAM  IMPORTS    Display, Exec, FlipX, Floyd, FormSW, HalfTone, Heap, ImageRotation, Inline, MFile, MSegment, MsgSW, Runtime, ScaleBitsToGray, Tool, ToolWindow = {  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = MACHINE DEPENDENT RECORD [    msgSW(0): Window.Handle ¬ NIL,    formSW(2): Window.Handle ¬ NIL,    displaySW(4): Window.Handle ¬ NIL,    grayPixelsPerLine(6): NATURAL ¬ 0,    grayLines(7): NATURAL ¬ 0,    grayX(8): NATURAL ¬ 0,    grayY(9): NATURAL ¬ 0,    grayFilename(10): LONG STRING ¬ NIL,    bitsPixelsPerLine(12): NATURAL ¬ 0,    bitsLines(13): NATURAL ¬ 0,    bitsX(14): NATURAL ¬ 0,    bitsY(15): NATURAL ¬ 0,    bitsFilename(16): LONG STRING ¬ NIL,    useSoftwareProc(18): BOOLEAN ¬ FALSE,    width(19): NATURAL ¬ 0,    height(20): NATURAL ¬ 0,    rotateMode(21): RotateMode ¬ clockwise,    scaleFactor(22): ScaleBitsToGray.ScaleFactor ¬ fourByFour,    htFilename(23): LONG STRING ¬ NIL,    threshold(25): NATURAL ¬ 0,    maxValue(26): NATURAL ¬ 255,    invert(27): BOOLEAN ¬ FALSE,    scaledHalfToneIsRequested(28): BOOLEAN ¬ FALSE,    graySeg(29): MSegment.Handle ¬ NIL,    bitsSeg(31): MSegment.Handle ¬ NIL,    table(33): SELECT OVERLAID * FROM      floyd => [floydT(33): Floyd.FloydTableSpace],      scale => [scaleT(33): ScaleBitsToGray.SBTGTableSpace],      ENDCASE ¬ NULL ];  FormItems: TYPE = {gray, grayPixelsPerLine, grayLines, grayX, grayY, grayLoad, grayStore, flipXGray, grayFilename, bitmap, bitsPixelsPerLine, bitsLines, bitsX, bitsY, bitsLoad, bitsStore, flipXBits, rotateBits, bitsFilename, useSoftwareProc, floyd, halftone, scale, width, height, rotateMode, scaleFactor, htFilename, threshold, maxValue, invert, scaledHalfToneIsRequested};  RotateMode: TYPE = {clockwise, counterclockwise, mirrorTopLeft, mirrorTopRight};  Cell:TYPE = MACHINE DEPENDENT RECORD [ -- copied from HalfToneCells.mesa     width(0): NATURAL,     height(1): NATURAL,     offset(2): NATURAL,	-- holladay offset     HTCell(3): ARRAY [0..99] OF NATURAL[0..255] ];  bitsPerPage: CARDINAL = Environment.bitsPerByte * Environment.bytesPerPage;  data: DataHandle ¬ NIL;  wh: Window.Handle ¬ NIL;  workingHalfToneLine: ARRAY OF NATURAL[0..255];  zone: UNCOUNTED ZONE ¬ Heap.systemZone;  GrayLoad:  FormSW.ProcType = {    fudge: LONG CARDINAL = Environment.bytesPerPage - 1;    bytes: LONG CARDINAL;    segPages, filePages: CARDINAL;    file: MFile.Handle;    IF (bytes ¬ Inline.LongMult [data.grayPixelsPerLine, data.grayLines]) = 0 THEN {      MsgSW.Post[data.msgSW, "can't load 0 pages"L];      RETURN};    segPages ¬ Inline.LongDiv [(bytes + fudge), Environment.bytesPerPage];    IF data.graySeg # NIL AND MSegment.Pages [data.graySeg] # segPages THEN {      MSegment.Delete [data.graySeg];      data.graySeg ¬ NIL};    IF data.graySeg = NIL THEN data.graySeg ¬ MSegment.Create [release: [], pages: segPages];    IF data.grayFilename = NIL OR data.grayFilename.length = 0 THEN {      MsgSW.Post[data.msgSW, "invalid filename"L];      RETURN};    file ¬ MFile.ReadOnly[data.grayFilename, []      ! MFile.Error => {        MsgSW.Post[data.msgSW, "file error"L];	GOTO exit} ];    IF (filePages ¬ Inline.LongDiv [(MFile.GetLength [file] + fudge), Environment.bytesPerPage]) = 0 THEN {      MsgSW.Post[data.msgSW, "can't load 0 pages"L];      MFile.Release [file];      RETURN};    MSegment.CopyIn [data.graySeg, file, 0, MIN[filePages, segPages]];    MFile.Release [file];    MsgSW.Post[data.msgSW, "gray loaded OK"L];    EXITS      exit => NULL};  GrayStore:  FormSW.ProcType = {    fudge: LONG CARDINAL = Environment.bytesPerPage - 1;    file: MFile.Handle;    bytes: LONG CARDINAL;    segPages: CARDINAL;    IF data.grayFilename = NIL OR data.grayFilename.length = 0 THEN {      MsgSW.Post[data.msgSW, "invalid parameters"L];      RETURN};    file ¬ MFile.WriteOnly[data.grayFilename, [], binary      ! MFile.Error => {        MsgSW.Post[data.msgSW, "file error"L];	GOTO exit} ];    bytes ¬ Inline.LongMult [data.grayPixelsPerLine, data.grayLines];    MFile.SetLength [file, bytes];    segPages ¬ Inline.LongDiv [(bytes + fudge), Environment.bytesPerPage];    IF data.graySeg # NIL THEN {      segPages ¬ MIN[segPages, Inline.LowHalf[MSegment.Pages [data.graySeg]]];      IF segPages > 0 THEN MSegment.CopyOut [data.graySeg, file, 0, segPages]};    MFile.Release [file];    MsgSW.Post[data.msgSW, "gray stored OK"L];    EXITS      exit => NULL};  BitsLoad:  FormSW.ProcType = {    fudge: LONG CARDINAL = bitsPerPage - 1;    bits: LONG CARDINAL;    segPages, filePages: CARDINAL;    file: MFile.Handle;    IF (bits ¬ Inline.LongMult [data.bitsPixelsPerLine, data.bitsLines]) = 0 THEN {      MsgSW.Post[data.msgSW, "can't load 0 pages"L];      RETURN};    segPages ¬ Inline.LongDiv [(bits + fudge), bitsPerPage];    IF data.bitsSeg # NIL AND MSegment.Pages [data.bitsSeg] # segPages THEN {      MSegment.Delete [data.bitsSeg];      data.bitsSeg ¬ NIL};    IF data.bitsSeg = NIL THEN data.bitsSeg ¬ MSegment.Create [release: [], pages: segPages];    IF data.bitsFilename = NIL OR data.bitsFilename.length = 0 THEN {      MsgSW.Post[data.msgSW, "invalid filename"L];      RETURN};    file ¬ MFile.ReadOnly[data.bitsFilename, []      ! MFile.Error => {        MsgSW.Post[data.msgSW, "file error"L];	GOTO exit} ];    IF (filePages ¬ Inline.LongDiv [(MFile.GetLength [file] + fudge), Environment.bytesPerPage]) = 0 THEN {      MsgSW.Post[data.msgSW, "can't load 0 pages"L];      MFile.Release [file];      RETURN};    MSegment.CopyIn [data.bitsSeg, file, 0, MIN[filePages, segPages]];    MFile.Release [file];    MsgSW.Post[data.msgSW, "bitmap loaded OK"L];    Display.Bitmap[data.displaySW, [[0,0],[data.bitsPixelsPerLine,data.bitsLines]], [MSegment.Address[data.bitsSeg], , 0], data.bitsPixelsPerLine, Display.replaceFlags];    EXITS      exit => NULL};  BitsStore:  FormSW.ProcType = {    fudge: LONG CARDINAL = bitsPerPage - 1;    littleFudge: LONG CARDINAL = Environment.bitsPerByte - 1;    file: MFile.Handle;    bits: LONG CARDINAL;    segPages: CARDINAL;    IF data.bitsFilename = NIL OR data.bitsFilename.length = 0 THEN {      MsgSW.Post[data.msgSW, "invalid parameters"L];      RETURN};    file ¬ MFile.WriteOnly[data.bitsFilename, [], binary      ! MFile.Error => {        MsgSW.Post[data.msgSW, "file error"L];	GOTO exit} ];    bits ¬ Inline.LongMult [data.bitsPixelsPerLine, data.bitsLines];    MFile.SetLength [file, ((bits + littleFudge) / Environment.bitsPerByte)];    segPages ¬ Inline.LongDiv [(bits + fudge), bitsPerPage];    IF data.bitsSeg # NIL THEN {      segPages ¬ MIN[segPages, Inline.LowHalf[MSegment.Pages [data.bitsSeg]]];      IF segPages > 0 THEN MSegment.CopyOut [data.bitsSeg, file, 0, segPages]};    MFile.Release [file];    MsgSW.Post[data.msgSW, "bitmap stored OK"L];    EXITS      exit => NULL};  FlipXBitsProc:  FormSW.ProcType = {    ptr, base: LONG POINTER;    offset: LONG CARDINAL;    width: CARDINAL = data.width / 16;    IF data.useSoftwareProc AND NOT Runtime.IsBound [LOOPHOLE [FlipX.SoftwareFlipXBits] ] THEN {      MsgSW.Post[data.msgSW, "no s/w proc for FlipXBits"L];      RETURN};    IF data.bitsSeg = NIL THEN {      MsgSW.Post[data.msgSW, "no bitmap!"L];      RETURN};    ptr ¬ MSegment.Address[data.bitsSeg];    offset ¬ Inline.LongMult[data.bitsPixelsPerLine, data.bitsY] + data.bitsX;    base ¬ ptr + (offset / 16);    IF data.bitsPixelsPerLine MOD 16 # 0 OR data.bitsX MOD 16 # 0 OR      data.width MOD 16 # 0 THEN {      MsgSW.Post[data.msgSW, "bitmap must be word-aligned"L];      RETURN};    offset ¬ data.bitsPixelsPerLine / 16;    THROUGH [0 .. data.height) DO      IF data.useSoftwareProc        THEN FlipX.SoftwareFlipXBits[base, width]	ELSE FlipX.FlipXBits[base, width];      base ¬ base + offset    ENDLOOP;    MsgSW.Post[data.msgSW, "FlipXBits completed OK"L];    Display.Bitmap[data.displaySW, [[0,0],[(data.bitsX + data.width),(data.bitsY + data.height)]], [ptr, , 0], data.bitsPixelsPerLine, Display.replaceFlags]};  FlipXGrayProc:  FormSW.ProcType = {    ptr, base: LONG POINTER;    offset: LONG CARDINAL;    width: CARDINAL = data.width / 2;    IF data.useSoftwareProc AND NOT Runtime.IsBound [LOOPHOLE [FlipX.SoftwareFlipXGray] ] THEN {      MsgSW.Post[data.msgSW, "no s/w proc for FlipXGray"L];      RETURN};    IF data.graySeg = NIL THEN {      MsgSW.Post[data.msgSW, "no gray!"L];      RETURN};    ptr ¬ MSegment.Address[data.graySeg];    offset ¬ Inline.LongMult[data.grayPixelsPerLine, data.grayY] + data.grayX;    base ¬ ptr + (offset / 2);    IF data.grayPixelsPerLine MOD 2 # 0 OR data.grayX MOD 2 # 0 OR      data.width MOD 2 # 0 THEN {      MsgSW.Post[data.msgSW, "gray must be word-aligned"L];      RETURN};    offset ¬ data.grayPixelsPerLine / 2;    THROUGH [0 .. data.height) DO      IF data.useSoftwareProc        THEN FlipX.SoftwareFlipXGray[base, width]	ELSE FlipX.FlipXGray[base, width];      base ¬ base + offset    ENDLOOP;    MsgSW.Post[data.msgSW, "FlipXGray completed OK"L]};  RotateProc:  FormSW.ProcType = {    fudge: LONG CARDINAL = Environment.wordsPerPage - 1;    srcBase, dstBase, ptr: LONG POINTER;    offset: LONG CARDINAL;    srcWPL, dstWPL: INTEGER;    dstWords: LONG CARDINAL;    dstSeg: MSegment.Handle;    countXtoY, countYtoX: NATURAL;    IF data.useSoftwareProc AND NOT Runtime.IsBound [LOOPHOLE [ImageRotation.SoftwareRotateBits] ] THEN {      MsgSW.Post[data.msgSW, "no s/w proc for Rotate"L];      RETURN};    IF data.bitsSeg = NIL THEN {      MsgSW.Post[data.msgSW, "no bitmap!"L];      RETURN};    srcBase ¬ MSegment.Address[data.bitsSeg];    offset ¬ Inline.LongMult[data.bitsPixelsPerLine, data.bitsY] + data.bitsX;    srcBase ¬ srcBase + (offset / 16);    IF data.bitsPixelsPerLine MOD 16 # 0 OR data.bitsX MOD 16 # 0 OR      data.width MOD 16 # 0 OR data.height MOD 16 # 0 THEN {      MsgSW.Post[data.msgSW, "bitmap must be word-aligned"L];      RETURN};    srcWPL ¬ data.bitsPixelsPerLine / 16;    dstWPL ¬ countYtoX ¬ data.height / 16;    dstWords ¬ Inline.LongMult [dstWPL, data.width];    dstSeg ¬ MSegment.Create [release: [], pages: ((dstWords + fudge) / Environment.wordsPerPage)];    dstBase ¬ ptr ¬ MSegment.Address[dstSeg];    countXtoY ¬ data.width / 16;    SELECT data.rotateMode FROM      counterclockwise =>        BEGIN	srcBase ¬ srcBase + Inline.LongMult[srcWPL, 15];	dstBase ¬ dstBase + Inline.LongMult[dstWPL, (data.height - 1)];	srcWPL ¬ -srcWPL;	dstWPL ¬ -dstWPL	END;      mirrorTopLeft =>        BEGIN	srcBase ¬ srcBase + Inline.LongMult[srcWPL, 15];	srcWPL ¬ -srcWPL	END;      mirrorTopRight =>        BEGIN	dstBase ¬ dstBase + Inline.LongMult[dstWPL, (data.height - 1)];	dstWPL ¬ -dstWPL	END;      ENDCASE;    FOR i: CARDINAL IN [0 .. countYtoX) DO      ENABLE ABORTED => MSegment.Delete[dstSeg];      srcPtr: LONG POINTER ¬ srcBase + Inline.LongMult[data.bitsPixelsPerLine, i];      dstPtr: LONG POINTER ¬ dstBase + (IF srcWPL < 0 THEN i ELSE (countYtoX - 1 - i));      FOR j: CARDINAL IN [0 .. countXtoY) DO        IF data.useSoftwareProc          THEN ImageRotation.SoftwareRotateBits[srcPtr, srcWPL, dstPtr, dstWPL]	  ELSE ImageRotation.RotateBits[srcPtr, srcWPL, dstPtr, dstWPL];	srcPtr ¬ srcPtr + 1;	dstPtr ¬ dstPtr + 16 * dstWPL      ENDLOOP    ENDLOOP;    MsgSW.Post[data.msgSW, "Rotate completed OK"L];    MSegment.Delete [data.bitsSeg];    data.bitsSeg ¬ dstSeg;    data.bitsPixelsPerLine ¬ data.height;    data.bitsLines ¬ data.width;    data.bitsX ¬ data.bitsY ¬ 0;    data.width ¬ data.bitsPixelsPerLine;    data.height ¬ data.bitsLines;    FormSW.Display [sw];    Display.Bitmap[data.displaySW, [[0,0],[data.bitsPixelsPerLine,data.bitsLines]], [ptr, , 0], data.bitsPixelsPerLine, Display.replaceFlags]};  FloydProc:  FormSW.ProcType = {    floydPtr: Floyd.FTptr = Floyd.AlignedFloydTable[@data.floydT];    fudge: LONG CARDINAL = bitsPerPage - 1;    bits: LONG CARDINAL;    segPages: CARDINAL;    ptr: LONG POINTER;    offset: LONG CARDINAL;    errBufSeg: MSegment.Handle;    IF data.useSoftwareProc AND NOT Runtime.IsBound [LOOPHOLE [Floyd.SoftwareFloyd] ] THEN {      MsgSW.Post[data.msgSW, "no s/w proc for Floyd"L];      RETURN};    IF data.graySeg = NIL THEN {      MsgSW.Post[data.msgSW, "no gray!"L];      RETURN};    ptr ¬ MSegment.Address[data.graySeg];    offset ¬ Inline.LongMult[data.grayPixelsPerLine, data.grayY] + data.grayX;    floydPtr.inBuffAddress ¬ [(ptr + offset / 2), , (Inline.LowHalf[offset] MOD 2)];    IF (bits ¬ Inline.LongMult [data.bitsPixelsPerLine, data.bitsLines]) = 0 THEN {      MsgSW.Post[data.msgSW, "can't make bitmap with 0 pages"L];      RETURN};    segPages ¬ Inline.LongDiv [(bits + fudge), bitsPerPage];    IF data.bitsSeg # NIL AND MSegment.Pages [data.bitsSeg] # segPages THEN {      MSegment.Delete [data.bitsSeg];      data.bitsSeg ¬ NIL};    IF data.bitsSeg = NIL THEN data.bitsSeg ¬ MSegment.Create [release: [], pages: segPages];    ptr ¬ MSegment.Address[data.bitsSeg];    offset ¬ Inline.LongMult[data.bitsPixelsPerLine, data.bitsY] + data.bitsX;    floydPtr.outBuffAddress ¬ [(ptr + offset / 16), , (Inline.LowHalf[offset] MOD 16)];    floydPtr.pixelCount ¬ data.width;    floydPtr.maxValue ¬ data.maxValue;    floydPtr.invert ¬ data.invert;    floydPtr.threshold ¬ data.threshold;    errBufSeg ¬ MSegment.Create [release: [], pages: ((data.width / 256) + 1)];    floydPtr.errorBuff ¬ MSegment.Address[errBufSeg];    FOR i: CARDINAL IN [0 .. data.width] DO      (floydPtr.errorBuff + i)­ ¬ 0    ENDLOOP;    THROUGH [0 .. data.height) DO      ENABLE ABORTED => MSegment.Delete[errBufSeg];      IF data.useSoftwareProc        THEN Floyd.SoftwareFloyd[floydPtr]	ELSE Floyd.Floyd[floydPtr];      offset ¬ floydPtr.inBuffAddress.byte + data.grayPixelsPerLine;      floydPtr.inBuffAddress ¬ [(floydPtr.inBuffAddress.word + offset / 2), , (Inline.LowHalf[offset] MOD 2)];      offset ¬ floydPtr.outBuffAddress.bit + data.bitsPixelsPerLine;      floydPtr.outBuffAddress ¬ [(floydPtr.outBuffAddress.word + offset / 16), , (Inline.LowHalf[offset] MOD 16)]    ENDLOOP;    MsgSW.Post[data.msgSW, "Floyd completed OK"L];    MSegment.Delete[errBufSeg];    Display.Bitmap[data.displaySW, [[0,0],[(data.bitsX + data.width),(data.bitsY + data.height)]], [ptr, , 0], data.bitsPixelsPerLine, Display.replaceFlags]};    HalfToneProc:  FormSW.ProcType = {    fudge: LONG CARDINAL = bitsPerPage - 1;    bits: LONG CARDINAL;    segPages: CARDINAL;    srcBase: HalfTone.ByteAddress;    dstBase: Environment.BitAddress;    ptr: LONG POINTER;    offset: LONG CARDINAL;    htCellFile: MFile.Handle;    htCellSeg: MSegment.Handle;    htCell: LONG POINTER TO Cell;    htBase: LONG POINTER;    htLine: HalfTone.HTtype;    htIndex, htOffset: CARDINAL;    unScaledHTline: LONG POINTER ¬ NIL;        ScaleHalfToneLine: PROCEDURE = INLINE {      HalfToneBase: LONG POINTER ¬ htLine.BASE;      scalefactor: NATURAL ¬ 0;      unScaledHTline ¬ HalfToneBase;      IF data.scaledHalfToneIsRequested AND (data.scaleFactor # sixteenBySixteen) THEN {        scalefactor ¬ SELECT data.scaleFactor FROM          eightByEight => 4,	  fourByFour => 16,	  twoByTwo => 64,	  ENDCASE => 1;      FOR i:CARDINAL IN [0..htLine.LENGTH) DO        workingHalfToneLine[ i ] ¬ ( HalfToneBase + i )­ / scalefactor;      ENDLOOP;      htLine.BASE ¬ @workingHalfToneLine }};    IF data.useSoftwareProc AND NOT Runtime.IsBound [LOOPHOLE [HalfTone.SoftwareHalfTone] ] THEN {      MsgSW.Post[data.msgSW, "no s/w proc for HalfTone"L];      RETURN};    IF data.graySeg = NIL THEN {      MsgSW.Post[data.msgSW, "no gray!"L];      RETURN};    ptr ¬ MSegment.Address[data.graySeg];    offset ¬ Inline.LongMult[data.grayPixelsPerLine, data.grayY] + data.grayX;    srcBase ¬ [(ptr + offset / 2), , (Inline.LowHalf[offset] MOD 2)];    IF (bits ¬ Inline.LongMult[data.bitsPixelsPerLine, data.bitsLines]) = 0 THEN {      MsgSW.Post[data.msgSW, "can't make bitmap with 0 pages"L];      RETURN};    segPages ¬ Inline.LongDiv[(bits + fudge), bitsPerPage];    IF data.bitsSeg # NIL AND MSegment.Pages [data.bitsSeg] # segPages THEN {      MSegment.Delete[data.bitsSeg];      data.bitsSeg ¬ NIL};    IF data.bitsSeg = NIL THEN data.bitsSeg ¬ MSegment.Create[release: [], pages: segPages];    ptr ¬ MSegment.Address[data.bitsSeg];    offset ¬ Inline.LongMult[data.bitsPixelsPerLine, data.bitsY] + data.bitsX;    dstBase ¬ [(ptr + offset / 16), , (Inline.LowHalf[offset] MOD 16)];    IF data.htFilename = NIL OR data.htFilename.length = 0 THEN {      MsgSW.Post[data.msgSW, "invalid ht filename"L];      RETURN};    htCellFile ¬ MFile.ReadOnly[data.htFilename, []      ! MFile.Error => {        MsgSW.Post[data.msgSW, "ht file error"L];	GOTO exit} ];    htCellSeg ¬ MSegment.Create[file: htCellFile, release: [], pages: 1];    htCell ¬ MSegment.Address[htCellSeg];    IF htCell.width = 0 OR htCell.height = 0 THEN {      MsgSW.Post[data.msgSW, "invalid data in ht file"L];      MSegment.Delete[htCellSeg];      RETURN};    htBase ¬ @htCell.HTCell;    htIndex ¬ data.bitsY MOD htCell.height;    htLine.BASE ¬ htBase + htCell.width * htIndex;    htLine.LENGTH ¬ htCell.width;    ScaleHalfToneLine;    htOffset ¬ ((data.bitsY / htCell.height) * htCell.offset + data.bitsX) MOD htCell.width;    THROUGH [0 .. data.height) DO      ENABLE ABORTED => MSegment.Delete[htCellSeg];      IF data.useSoftwareProc        THEN HalfTone.SoftwareHalfTone[[srcBase,data.width], htLine, htOffset, dstBase, data.invert]	ELSE HalfTone.HALFTONE[[srcBase,data.width], htLine, htOffset, dstBase, data.invert];      offset ¬ srcBase.byte + data.grayPixelsPerLine;      srcBase ¬ [(srcBase.word + offset / 2), , (Inline.LowHalf[offset] MOD 2)];      offset ¬ dstBase.bit + data.bitsPixelsPerLine;      dstBase ¬ [(dstBase.word + offset / 16), , (Inline.LowHalf[offset] MOD 16)];      htLine.BASE ¬ unScaledHTline;      IF (htIndex ¬ htIndex + 1) < htCell.height THEN htLine.BASE ¬ htLine.BASE + htCell.width ELSE {	htIndex ¬ 0;	htLine.BASE ¬ htBase;	htOffset ¬ (htOffset + htCell.offset) MOD htCell.width};      ScaleHalfToneLine;    ENDLOOP;    MsgSW.Post[data.msgSW, "HalfTone completed OK"L];    MSegment.Delete[htCellSeg];    Display.Bitmap[data.displaySW, [[0,0],[(data.bitsX + data.width),(data.bitsY + data.height)]], [ptr, , 0], data.bitsPixelsPerLine, Display.replaceFlags];    EXITS      exit => NULL};  ScaleProc:  FormSW.ProcType = {    sbtgPtr: ScaleBitsToGray.SBTGptr = ScaleBitsToGray.AlignedSBTGptr[@data.scaleT];    linesPerPixel: ARRAY ScaleBitsToGray.ScaleFactor OF CARDINAL = [16, 8, 4, 2];    fudge: LONG CARDINAL = Environment.bytesPerPage - 1;    bytes: LONG CARDINAL;    segPages: CARDINAL;    ptr: LONG POINTER;    offset, bitsIncrement: LONG CARDINAL;    IF data.useSoftwareProc AND NOT Runtime.IsBound [LOOPHOLE [ScaleBitsToGray.SoftwareScaleBitsToGray] ] THEN {      MsgSW.Post[data.msgSW, "no s/w proc for Scale"L];      RETURN};    IF data.bitsSeg = NIL THEN {      MsgSW.Post[data.msgSW, "no bitmap!"L];      RETURN};    ptr ¬ MSegment.Address[data.bitsSeg];    offset ¬ Inline.LongMult[data.bitsPixelsPerLine, data.bitsY] + data.bitsX;    sbtgPtr.src ¬ [(ptr + offset / 16), , (Inline.LowHalf[offset] MOD 16)];    sbtgPtr.srcBpl ¬ data.bitsPixelsPerLine;    IF (bytes ¬ Inline.LongMult [data.grayPixelsPerLine, data.grayLines]) = 0 THEN {      MsgSW.Post[data.msgSW, "can't make gray with 0 pages"L];      RETURN};    segPages ¬ Inline.LongDiv [(bytes + fudge), Environment.bytesPerPage];    IF data.graySeg # NIL AND MSegment.Pages [data.graySeg] # segPages THEN {      MSegment.Delete [data.graySeg];      data.graySeg ¬ NIL};    IF data.graySeg = NIL THEN data.graySeg ¬ MSegment.Create [release: [], pages: segPages];    ptr ¬ MSegment.Address[data.graySeg];    offset ¬ Inline.LongMult[data.grayPixelsPerLine, data.grayY] + data.grayX;    sbtgPtr.dst ¬ [(ptr + offset / 2), , (Inline.LowHalf[offset] MOD 2)];    sbtgPtr.pixelCount ¬ data.width;    sbtgPtr.reserved ¬ 0;    sbtgPtr.scale ¬ data.scaleFactor;    bitsIncrement ¬ Inline.LongMult[linesPerPixel[data.scaleFactor], data.bitsPixelsPerLine];    THROUGH [0 .. data.height) DO      IF data.useSoftwareProc        THEN ScaleBitsToGray.SoftwareScaleBitsToGray[sbtgPtr]	ELSE ScaleBitsToGray.ScaleBitsToGray[sbtgPtr];      offset ¬ sbtgPtr.src.bit + bitsIncrement;      sbtgPtr.src ¬ [(sbtgPtr.src.word + offset / 16), , (Inline.LowHalf[offset] MOD 16)];      offset ¬ sbtgPtr.dst.byte + data.grayPixelsPerLine;      sbtgPtr.dst ¬ [(sbtgPtr.dst.word + offset / 2), , (Inline.LowHalf[offset] MOD 2)]    ENDLOOP;    MsgSW.Post[data.msgSW, "Scale completed OK"L]};  Init: PROCEDURE = {    data ¬ MSegment.GetPages[1];    data­ ¬ [];    Exec.AddCommand[name: "Phase2Test"L, proc: TestProc, unload: UnloadProc];    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default,      name: "Phase2Test"L,      cmSection: "Phase2Test"L];    };  MakeSWs: Tool.MakeSWsProc = {    NullProc: PROC [sw: Window.Handle, clientData: LONG POINTER] = {};    data.msgSW ¬ Tool.MakeMsgSW[window: window];    data.formSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeForm];    data.displaySW ¬ Tool.MakeClientSW[window, NullProc, NIL, vanilla];    };  MakeForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = FormItems.LAST.ORD + 1;    rotateMode: ARRAY[0..4) OF Enumerated ¬ [      ["cw"L, RotateMode[clockwise]],      ["ccw"L, RotateMode[counterclockwise]],      ["mtl"L, RotateMode[mirrorTopLeft]],      ["mtr"L, RotateMode[mirrorTopRight]]];    scaleFactor: ARRAY[0..4) OF Enumerated ¬ [      ["2x2"L, ScaleBitsToGray.ScaleFactor[twoByTwo]],      ["4x4"L, ScaleBitsToGray.ScaleFactor[fourByFour]],      ["8x8"L, ScaleBitsToGray.ScaleFactor[eightByEight]],      ["16x16"L, ScaleBitsToGray.ScaleFactor[sixteenBySixteen]]];    items ¬ AllocateItemDescriptor[nItems];    items[FormItems.gray.ORD] ¬ TagOnlyItem[      tag: "Gray"L, place: [6, line0]];    items[FormItems.grayPixelsPerLine.ORD] ¬ NumberItem[      tag: "pixels/line"L, place: [78, line0], boxWidth: 48, signed: FALSE, notNegative: TRUE, value: @data.grayPixelsPerLine];    items[FormItems.grayLines.ORD] ¬ NumberItem[      tag: "lines"L, place: [210, line0], boxWidth: 48, signed: FALSE, notNegative: TRUE, value: @data.grayLines];    items[FormItems.grayX.ORD] ¬ NumberItem[      tag: "x"L, place: [306, line0], boxWidth: 48, signed: FALSE, notNegative: TRUE, value: @data.grayX];    items[FormItems.grayY.ORD] ¬ NumberItem[      tag: "y"L, place: [402, line0], boxWidth: 48, signed: FALSE, notNegative: TRUE, value: @data.grayY];    items[FormItems.grayLoad.ORD] ¬ CommandItem[      tag: "Load"L, place: [42, line1], proc: GrayLoad];    items[FormItems.grayStore.ORD] ¬ CommandItem[      tag: "Store"L, place: [90, line1], proc: GrayStore];    items[FormItems.flipXGray.ORD] ¬ CommandItem[      tag: "FlipX"L, place: [138, line1], proc: FlipXGrayProc];    items[FormItems.grayFilename.ORD] ¬ StringItem[      tag: "filename"L, place: [306, line1], inHeap: TRUE, string: @data.grayFilename];    items[FormItems.bitmap.ORD] ¬ TagOnlyItem[      tag: "Bitmap"L, place: [6, line2]];    items[FormItems.bitsPixelsPerLine.ORD] ¬ NumberItem[      tag: "pixels/line"L, place: [78, line2], boxWidth: 48, signed: FALSE, notNegative: TRUE, value: @data.bitsPixelsPerLine];    items[FormItems.bitsLines.ORD] ¬ NumberItem[      tag: "lines"L, place: [210, line2], boxWidth: 48, signed: FALSE, notNegative: TRUE, value: @data.bitsLines];    items[FormItems.bitsX.ORD] ¬ NumberItem[      tag: "x"L, place: [306, line2], boxWidth: 48, signed: FALSE, notNegative: TRUE, value: @data.bitsX];    items[FormItems.bitsY.ORD] ¬ NumberItem[      tag: "y"L, place: [402, line2], boxWidth: 48, signed: FALSE, notNegative: TRUE, value: @data.bitsY];    items[FormItems.bitsLoad.ORD] ¬ CommandItem[      tag: "Load"L, place: [42, line3], proc: BitsLoad];    items[FormItems.bitsStore.ORD] ¬ CommandItem[      tag: "Store"L, place: [90, line3], proc: BitsStore];    items[FormItems.flipXBits.ORD] ¬ CommandItem[      tag: "FlipX"L, place: [138, line3], proc: FlipXBitsProc];    items[FormItems.rotateBits.ORD] ¬ CommandItem[      tag: "Rotate"L, place: [186, line3], proc: RotateProc];    items[FormItems.bitsFilename.ORD] ¬ StringItem[      tag: "filename"L, place: [306, line3], inHeap: TRUE, string: @data.bitsFilename];    items[FormItems.useSoftwareProc.ORD] ¬ BooleanItem[      tag: "s/w"L, place: [6, line4], switch: @data.useSoftwareProc];    items[FormItems.floyd.ORD] ¬ CommandItem[      tag: "Floyd"L, place: [42, line4], proc: FloydProc];    items[FormItems.halftone.ORD] ¬ CommandItem[      tag: "HalfTone"L, place: [90, line4], proc: HalfToneProc];    items[FormItems.scale.ORD] ¬ CommandItem[      tag: "Scale"L, place: [156, line4], proc: ScaleProc];    items[FormItems.width.ORD] ¬ NumberItem[      tag: "width"L, place: [306, line4], boxWidth: 48, signed: FALSE, notNegative: TRUE, value: @data.width];    items[FormItems.height.ORD] ¬ NumberItem[      tag: "height"L, place: [402, line4], boxWidth: 48, signed: FALSE, notNegative: TRUE, value: @data.height];    items[FormItems.rotateMode.ORD] ¬ EnumeratedItem[      tag: "mode"L, place: [42, line5], choices: DESCRIPTOR[rotateMode], value: @data.rotateMode];    items[FormItems.scaleFactor.ORD] ¬ EnumeratedItem[      tag: "scale"L, place: [156, line5], choices: DESCRIPTOR[scaleFactor], value: @data.scaleFactor];    items[FormItems.htFilename.ORD] ¬ StringItem[      tag: "ht filename"L, place: [306, line5], inHeap: TRUE, string: @data.htFilename];    items[FormItems.threshold.ORD] ¬ NumberItem[      tag: "threshold"L, place: [42, line6], boxWidth: 48, signed: FALSE, notNegative: TRUE, default: 0, value: @data.threshold];    items[FormItems.maxValue.ORD] ¬ NumberItem[      tag: "max value"L, place: [158, line6], boxWidth: 48, signed: FALSE, notNegative: TRUE, default: 255, value: @data.maxValue];    items[FormItems.invert.ORD] ¬ BooleanItem[      tag: "invert"L, place: [274, line6], switch: @data.invert];    items[FormItems.scaledHalfToneIsRequested.ORD] ¬ BooleanItem[      tag: "ScaledHalfTone"L, place: [390, line6], switch: @data.scaledHalfToneIsRequested];    RETURN[items: items, freeDesc: TRUE];    };  TestProc: Exec.ExecProc = {    ToolWindow.Activate [wh]};  UnloadProc: Exec.ExecProc = {    Tool.Destroy[wh];    IF data.graySeg # NIL THEN MSegment.Delete[data.graySeg];    IF data.bitsSeg # NIL THEN MSegment.Delete[data.bitsSeg];    MSegment.FreePages[data];    Exec.RemoveCommand[h, "Phase2Test"L]};  -- Mainline code  Init[];  -- this gets string out of global frame  }...    
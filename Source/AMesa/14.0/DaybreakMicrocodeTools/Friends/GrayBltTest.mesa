-- GrayBltTest.mesa-- Last edit by JPM 19-Dec-86 9:44:50DIRECTORY  Display,  Environment,  Exec,  Floyd,  FormSW,  GrayBlt,  Heap,  Inline,  MFile,  MSegment,  MsgSW,  Runtime,  Tool,  ToolWindow,  Window;GrayBltTest: PROGRAM  IMPORTS    Display, Exec, Floyd, FormSW, GrayBlt, Heap, Inline, MFile, MSegment, MsgSW, Runtime, Tool, ToolWindow = {  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = MACHINE DEPENDENT RECORD [    msgSW(0): Window.Handle ¬ NIL,    formSW(2): Window.Handle ¬ NIL,    displaySW(4): Window.Handle ¬ NIL,    srcPixelsPerLine(6): NATURAL ¬ 0,    srcX(7): NATURAL ¬ 0,    srcY(8): NATURAL ¬ 0,    srcPages(9): NATURAL ¬ 0,    srcFilename(10): LONG STRING ¬ NIL,    destPixelsPerLine(12): NATURAL ¬ 0,    destX(13): NATURAL ¬ 0,    destY(14): NATURAL ¬ 0,    destPages(15): NATURAL ¬ 0,    destFilename(16): LONG STRING ¬ NIL,    useSoftwareProc(18): BOOLEAN ¬ FALSE,    width(19): NATURAL ¬ 0,    height(20): NATURAL ¬ 0,    direction(21): GrayBlt.Direction ¬ forward,    srcFunc(22): GrayBlt.SrcFunc ¬ null,    dstFunc(23): GrayBlt.DstFunc ¬ set,    trcFilename(24): LONG STRING ¬ NIL,    sumVal(26): LONG CARDINAL ¬ 0,    thresholdVal(28): CARDINAL ¬ 0,    invert(29): BOOLEAN ¬ FALSE,    srcSeg(30): MSegment.Handle ¬ NIL,    destSeg(32): MSegment.Handle ¬ NIL,    table(34): SELECT OVERLAID * FROM      blt => [gbT(34): GrayBlt.GBTableSpace],      sum => [sumT(34): GrayBlt.SumTableSpace],      thresh => [threshT(34): GrayBlt.ThresholdTableSpace],      floyd => [floydT(34): Floyd.FloydTableSpace],      ENDCASE ¬ NULL ];  FormItems: TYPE = {source, srcPixelsPerLine, srcX, srcY, srcLoad, srcStore, srcPages, srcFilename, destination, destPixelsPerLine, destX, destY, destLoad, destStore, destPages, destFilename, useSoftwareProc, blt, sum, threshold, floyd, width, height, direction, srcFunc, dstFunc, trc, sumVal, thresholdVal, invert};  data: DataHandle ¬ NIL;  wh: Window.Handle ¬ NIL;  zone: UNCOUNTED ZONE ¬ Heap.systemZone;  SrcLoad:  FormSW.ProcType = {    file: MFile.Handle;    pages: CARDINAL;    IF data.srcFilename = NIL OR data.srcFilename.length = 0 THEN {      MsgSW.Post[data.msgSW, "invalid parameters"L];      RETURN};    file ¬ MFile.ReadOnly[data.srcFilename, []      ! MFile.Error => {        MsgSW.Post[data.msgSW, "file error"L];	GOTO exit} ];    IF (pages ¬ MIN[Inline.LongDiv [MFile.GetLength [file], Environment.bytesPerPage], data.srcPages]) = 0 THEN {      MsgSW.Post[data.msgSW, "can't load 0 pages"L];      MFile.Release [file];      RETURN};    IF data.srcSeg # NIL AND MSegment.Pages [data.srcSeg] < pages THEN {      MSegment.Delete [data.srcSeg];      data.srcSeg ¬ NIL};    IF data.srcSeg = NIL THEN data.srcSeg ¬ MSegment.Create [release: [], pages: pages];    MSegment.CopyIn [data.srcSeg, file, 0, pages];    MFile.Release [file];    MsgSW.Post[data.msgSW, "source loaded OK"L];    EXITS      exit => NULL};  SrcStore:  FormSW.ProcType = {    file: MFile.Handle;    pages: CARDINAL;    IF data.srcFilename = NIL OR data.srcFilename.length = 0 THEN {      MsgSW.Post[data.msgSW, "invalid parameters"L];      RETURN};    file ¬ MFile.WriteOnly[data.srcFilename, [], binary      ! MFile.Error => {        MsgSW.Post[data.msgSW, "file error"L];	GOTO exit} ];    MFile.SetLength [file, Inline.LongMult [data.srcPages, Environment.bytesPerPage]];    IF data.srcSeg # NIL THEN {      pages ¬ MIN[data.srcPages, Inline.LowHalf[MSegment.Pages [data.srcSeg]]];      IF pages > 0 THEN MSegment.CopyOut [data.srcSeg, file, 0, pages]};    MFile.Release [file];    MsgSW.Post[data.msgSW, "source stored OK"L];    EXITS      exit => NULL};  DestLoad:  FormSW.ProcType = {    file: MFile.Handle;    pages: CARDINAL;    IF data.destFilename = NIL OR data.destFilename.length = 0 THEN {      MsgSW.Post[data.msgSW, "invalid parameters"L];      RETURN};    file ¬ MFile.ReadOnly[data.destFilename, []      ! MFile.Error => {        MsgSW.Post[data.msgSW, "file error"L];	GOTO exit} ];    IF (pages ¬ MIN[Inline.LongDiv [MFile.GetLength [file], Environment.bytesPerPage], data.destPages]) = 0 THEN {      MsgSW.Post[data.msgSW, "can't load 0 pages"L];      MFile.Release [file];      RETURN};    IF data.destSeg # NIL AND MSegment.Pages [data.destSeg] < pages THEN {      MSegment.Delete [data.destSeg];      data.destSeg ¬ NIL};    IF data.destSeg = NIL THEN data.destSeg ¬ MSegment.Create [release: [], pages: pages];    MSegment.CopyIn [data.destSeg, file, 0, pages];    MFile.Release [file];    MsgSW.Post[data.msgSW, "destination loaded OK"L];    EXITS      exit => NULL};  DestStore:  FormSW.ProcType = {    file: MFile.Handle;    pages: CARDINAL;    IF data.destFilename = NIL OR data.destFilename.length = 0 THEN {      MsgSW.Post[data.msgSW, "invalid parameters"L];      RETURN};    file ¬ MFile.WriteOnly[data.destFilename, [], binary      ! MFile.Error => {        MsgSW.Post[data.msgSW, "file error"L];	GOTO exit} ];    MFile.SetLength [file, Inline.LongMult [data.destPages, Environment.bytesPerPage]];    IF data.destSeg # NIL THEN {      pages ¬ MIN[data.destPages, Inline.LowHalf[MSegment.Pages [data.destSeg]]];      IF pages > 0 THEN MSegment.CopyOut [data.destSeg, file, 0, pages]};    MFile.Release [file];    MsgSW.Post[data.msgSW, "destination stored OK"L];    EXITS      exit => NULL};  BLTProc:  FormSW.ProcType = {    gbPtr: GrayBlt.GBptr = GrayBlt.AlignedGBTablePtr[@data.gbT];    ptr: LONG POINTER;    offset: LONG CARDINAL;    trcSeg: MSegment.Handle ¬ NIL;    IF data.useSoftwareProc AND NOT Runtime.IsBound [LOOPHOLE [GrayBlt.SoftwareGrayBlt] ] THEN {      MsgSW.Post[data.msgSW, "no s/w proc for GrayBlt"L];      RETURN};    IF data.srcSeg = NIL THEN {      MsgSW.Post[data.msgSW, "no source!"L];      RETURN};    ptr ¬ MSegment.Address[data.srcSeg];    offset ¬ Inline.LongMult[data.srcPixelsPerLine, data.srcY] + data.srcX;    IF data.direction = backward THEN offset ¬ offset + Inline.LongMult[data.srcPixelsPerLine, (data.height - 1)];    gbPtr.src ¬ [(ptr + offset / 2), , (Inline.LowHalf[offset] MOD 2)];    gbPtr.srcBpl ¬ (IF data.direction = backward THEN -data.srcPixelsPerLine ELSE data.srcPixelsPerLine);    IF data.destSeg # NIL AND MSegment.Pages [data.destSeg] < data.destPages THEN {      MSegment.Delete [data.destSeg];      data.destSeg ¬ NIL};    IF data.destSeg = NIL THEN {      IF data.destPages = 0 THEN {        MsgSW.Post[data.msgSW, "can't make destination with 0 pages"L];        RETURN};      data.destSeg ¬ MSegment.Create [release: [], pages: data.destPages]};    ptr ¬ MSegment.Address[data.destSeg];    offset ¬ Inline.LongMult[data.destPixelsPerLine, data.destY] + data.destX;    IF data.direction = backward THEN offset ¬ offset + Inline.LongMult[data.destPixelsPerLine, (data.height - 1)];    gbPtr.dst ¬ [(ptr + offset / 2), , (Inline.LowHalf[offset] MOD 2)];    gbPtr.dstBpl ¬ (IF data.direction = backward THEN -data.destPixelsPerLine ELSE data.destPixelsPerLine);    gbPtr.width ¬ data.width;    gbPtr.height ¬ data.height;    gbPtr.flags ¬ [direction: data.direction, srcFunc: data.srcFunc, dstFunc: data.dstFunc];    IF data.srcFunc # trc THEN gbPtr.trc ¬ NIL ELSE {      file: MFile.Handle;      IF data.trcFilename = NIL OR data.trcFilename.length = 0 THEN {        MsgSW.Post[data.msgSW, "invalid parameters"L];        RETURN};      file ¬ MFile.ReadOnly[data.trcFilename, []        ! MFile.Error => {          MsgSW.Post[data.msgSW, "file error"L];	  GOTO exit} ];      trcSeg ¬ MSegment.Create[file, [] ];      gbPtr.trc ¬ MSegment.Address[trcSeg]};    IF data.useSoftwareProc      THEN GrayBlt.SoftwareGrayBlt[gbPtr]      ELSE GrayBlt.GrayBlt[gbPtr];    MsgSW.Post[data.msgSW, "BLT completed OK"L];    IF trcSeg # NIL THEN MSegment.Delete[trcSeg];    EXITS      exit => NULL};  SumProc:  FormSW.ProcType = {    sumPtr: GrayBlt.Sumptr = GrayBlt.AlignedSumTablePtr[@data.sumT];    ptr: LONG POINTER;    offset: LONG CARDINAL;    IF data.useSoftwareProc AND NOT Runtime.IsBound [LOOPHOLE [GrayBlt.SoftwareSum] ] THEN {      MsgSW.Post[data.msgSW, "no s/w proc for Sum"L];      RETURN};    IF data.srcSeg = NIL THEN {      MsgSW.Post[data.msgSW, "no source!"L];      RETURN};    ptr ¬ MSegment.Address[data.srcSeg];    offset ¬ Inline.LongMult[data.srcPixelsPerLine, data.srcY] + data.srcX;    sumPtr­ ¬ [[(ptr + offset / 2), , (Inline.LowHalf[offset] MOD 2)], data.srcPixelsPerLine, data.width, data.height];    data.sumVal ¬ (IF data.useSoftwareProc      THEN GrayBlt.SoftwareSum[sumPtr]      ELSE GrayBlt.Sum[sumPtr]);    FormSW.DisplayItem[data.formSW, FormItems.sumVal.ORD];    MsgSW.Post[data.msgSW, "Sum completed OK"L]};  ThresholdProc:  FormSW.ProcType = {    threshPtr: GrayBlt.Threshptr = GrayBlt.AlignedThresholdTablePtr[@data.threshT];    ptr: LONG POINTER;    offset: LONG CARDINAL;    IF data.useSoftwareProc AND NOT Runtime.IsBound [LOOPHOLE [GrayBlt.SoftwareThreshold] ] THEN {      MsgSW.Post[data.msgSW, "no s/w proc for Threshold"L];      RETURN};    IF data.srcSeg = NIL THEN {      MsgSW.Post[data.msgSW, "no source!"L];      RETURN};    ptr ¬ MSegment.Address[data.srcSeg];    offset ¬ Inline.LongMult[data.srcPixelsPerLine, data.srcY] + data.srcX;    threshPtr.src ¬ [(ptr + offset / 2), , (Inline.LowHalf[offset] MOD 2)];    threshPtr.srcBpl ¬ data.srcPixelsPerLine;    IF data.destSeg # NIL AND MSegment.Pages [data.destSeg] < data.destPages THEN {      MSegment.Delete [data.destSeg];      data.destSeg ¬ NIL};    IF data.destSeg # NIL AND MSegment.Pages [data.destSeg] < data.destPages THEN {      MSegment.Delete [data.destSeg];      data.destSeg ¬ NIL};    IF data.destSeg = NIL THEN {      IF data.destPages = 0 THEN {        MsgSW.Post[data.msgSW, "can't make destination with 0 pages"L];        RETURN};      data.destSeg ¬ MSegment.Create [release: [], pages: data.destPages]};    ptr ¬ MSegment.Address[data.destSeg];    offset ¬ Inline.LongMult[data.destPixelsPerLine, data.destY] + data.destX;    threshPtr.dst ¬ [(ptr + offset / 16), , (Inline.LowHalf[offset] MOD 16)];    threshPtr.dstBpl ¬ data.destPixelsPerLine;    threshPtr.width ¬ data.width;    threshPtr.height ¬ data.height;    threshPtr.reserved ¬ 0;    threshPtr.srcCuttoffValue ¬ data.thresholdVal;    IF data.useSoftwareProc      THEN GrayBlt.SoftwareThreshold[threshPtr]      ELSE GrayBlt.Threshold[threshPtr];    MsgSW.Post[data.msgSW, "Threshold completed OK"L];    Display.Bitmap[data.displaySW, [[0,0],[(data.destX + data.width),(data.destY + data.height)]], [ptr, , 0], data.destPixelsPerLine, Display.replaceFlags]};  FloydProc:  FormSW.ProcType = {    floydPtr: Floyd.FTptr = Floyd.AlignedFloydTable[@data.floydT];    ptr: LONG POINTER;    offset: LONG CARDINAL;    errBufSeg: MSegment.Handle;    IF data.useSoftwareProc AND NOT Runtime.IsBound [LOOPHOLE [Floyd.SoftwareFloyd] ] THEN {      MsgSW.Post[data.msgSW, "no s/w proc for Floyd"L];      RETURN};    IF data.srcSeg = NIL THEN {      MsgSW.Post[data.msgSW, "no source!"L];      RETURN};    ptr ¬ MSegment.Address[data.srcSeg];    offset ¬ Inline.LongMult[data.srcPixelsPerLine, data.srcY] + data.srcX;    floydPtr.inBuffAddress ¬ [(ptr + offset / 2), , (Inline.LowHalf[offset] MOD 2)];    IF data.destSeg # NIL AND MSegment.Pages [data.destSeg] < data.destPages THEN {      MSegment.Delete [data.destSeg];      data.destSeg ¬ NIL};    IF data.destSeg = NIL THEN {      IF data.destPages = 0 THEN {        MsgSW.Post[data.msgSW, "can't make destination with 0 pages"L];        RETURN};      data.destSeg ¬ MSegment.Create [release: [], pages: data.destPages]};    ptr ¬ MSegment.Address[data.destSeg];    offset ¬ Inline.LongMult[data.destPixelsPerLine, data.destY] + data.destX;    floydPtr.outBuffAddress ¬ [(ptr + offset / 16), , (Inline.LowHalf[offset] MOD 16)];    floydPtr.pixelCount ¬ data.width;    floydPtr.maxValue ¬ 255;    floydPtr.invert ¬ data.invert;    floydPtr.threshold ¬ data.thresholdVal;    errBufSeg ¬ MSegment.Create [release: [], pages: ((data.width / 256) + 1)];    floydPtr.errorBuff ¬ MSegment.Address[errBufSeg];    FOR i: CARDINAL IN [0 .. data.width] DO      (floydPtr.errorBuff + i)­ ¬ 0    ENDLOOP;    THROUGH [0 .. data.height) DO      ENABLE ABORTED => MSegment.Delete[errBufSeg];      IF data.useSoftwareProc        THEN Floyd.SoftwareFloyd[floydPtr]	ELSE Floyd.Floyd[floydPtr];      offset ¬ floydPtr.inBuffAddress.byte + data.srcPixelsPerLine;      floydPtr.inBuffAddress ¬ [(floydPtr.inBuffAddress.word + offset / 2), , (Inline.LowHalf[offset] MOD 2)];      offset ¬ floydPtr.outBuffAddress.bit + data.destPixelsPerLine;      floydPtr.outBuffAddress ¬ [(floydPtr.outBuffAddress.word + offset / 16), , (Inline.LowHalf[offset] MOD 16)]    ENDLOOP;    MsgSW.Post[data.msgSW, "Floyd completed OK"L];    MSegment.Delete[errBufSeg];    Display.Bitmap[data.displaySW, [[0,0],[(data.destX + data.width),(data.destY + data.height)]], [ptr, , 0], data.destPixelsPerLine, Display.replaceFlags]};  Init: PROCEDURE = {    data ¬ MSegment.GetPages[1];    data­ ¬ [];    Exec.AddCommand[name: "GrayBltTest"L, proc: TestProc, unload: UnloadProc];    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default,      name: "GrayBltTest"L,      cmSection: "GrayBltTest"L];    };  MakeSWs: Tool.MakeSWsProc = {    NullProc: PROC [sw: Window.Handle, clientData: LONG POINTER] = {};    data.msgSW ¬ Tool.MakeMsgSW[window: window];    data.formSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeForm];    data.displaySW ¬ Tool.MakeClientSW[window, NullProc, NIL, vanilla];    };  MakeForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = FormItems.LAST.ORD + 1;    direction: ARRAY[0..2) OF Enumerated ¬ [      ["forward"L, GrayBlt.Direction[forward]],      ["reverse"L, GrayBlt.Direction[backward]]];    srcFunc: ARRAY[0..3) OF Enumerated ¬ [      ["null"L, GrayBlt.SrcFunc[null]],      ["invert"L, GrayBlt.SrcFunc[invert]],      ["trc"L, GrayBlt.SrcFunc[trc]]];    dstFunc: ARRAY[0..4) OF Enumerated ¬ [      ["set"L, GrayBlt.DstFunc[set]],      ["add"L, GrayBlt.DstFunc[add]],      ["subtract"L, GrayBlt.DstFunc[subtract]],      ["average"L, GrayBlt.DstFunc[average]]];    items ¬ AllocateItemDescriptor[nItems];    items[FormItems.source.ORD] ¬ TagOnlyItem[      tag: "Source"L, place: [6, line0]];    items[FormItems.srcPixelsPerLine.ORD] ¬ NumberItem[      tag: "pixels/line"L, place: [90, line0], boxWidth: 48, signed: FALSE, notNegative: TRUE, value: @data.srcPixelsPerLine];    items[FormItems.srcX.ORD] ¬ NumberItem[      tag: "x"L, place: [246, line0], boxWidth: 48, signed: FALSE, notNegative: TRUE, value: @data.srcX];    items[FormItems.srcY.ORD] ¬ NumberItem[      tag: "y"L, place: [354, line0], boxWidth: 48, signed: FALSE, notNegative: TRUE, value: @data.srcY];    items[FormItems.srcLoad.ORD] ¬ CommandItem[      tag: "Load"L, place: [42, line1], proc: SrcLoad];    items[FormItems.srcStore.ORD] ¬ CommandItem[      tag: "Store"L, place: [90, line1], proc: SrcStore];    items[FormItems.srcPages.ORD] ¬ NumberItem[      tag: "pages"L, place: [150, line1], boxWidth: 48, signed: FALSE, notNegative: TRUE, value: @data.srcPages];    items[FormItems.srcFilename.ORD] ¬ StringItem[      tag: "filename"L, place: [246, line1], inHeap: TRUE, string: @data.srcFilename];    items[FormItems.destination.ORD] ¬ TagOnlyItem[      tag: "Destination"L, place: [6, line2]];    items[FormItems.destPixelsPerLine.ORD] ¬ NumberItem[      tag: "pixels/line"L, place: [90, line2], boxWidth: 48, signed: FALSE, notNegative: TRUE, value: @data.destPixelsPerLine];    items[FormItems.destX.ORD] ¬ NumberItem[      tag: "x"L, place: [246, line2], boxWidth: 48, signed: FALSE, notNegative: TRUE, value: @data.destX];    items[FormItems.destY.ORD] ¬ NumberItem[      tag: "y"L, place: [354, line2], boxWidth: 48, signed: FALSE, notNegative: TRUE, value: @data.destY];    items[FormItems.destLoad.ORD] ¬ CommandItem[      tag: "Load"L, place: [42, line3], proc: DestLoad];    items[FormItems.destStore.ORD] ¬ CommandItem[      tag: "Store"L, place: [90, line3], proc: DestStore];    items[FormItems.destPages.ORD] ¬ NumberItem[      tag: "pages"L, place: [150, line3], boxWidth: 48, signed: FALSE, notNegative: TRUE, value: @data.destPages];    items[FormItems.destFilename.ORD] ¬ StringItem[      tag: "filename"L, place: [246, line3], inHeap: TRUE, string: @data.destFilename];    items[FormItems.useSoftwareProc.ORD] ¬ BooleanItem[      tag: "s/w"L, place: [6, line4], switch: @data.useSoftwareProc];    items[FormItems.blt.ORD] ¬ CommandItem[      tag: "BLT"L, place: [42, line4], proc: BLTProc];    items[FormItems.sum.ORD] ¬ CommandItem[      tag: "Sum"L, place: [78, line4], proc: SumProc];    items[FormItems.threshold.ORD] ¬ CommandItem[      tag: "Threshold"L, place: [114, line4], proc: ThresholdProc];    items[FormItems.floyd.ORD] ¬ CommandItem[      tag: "Floyd"L, place: [186, line4], proc: FloydProc];    items[FormItems.width.ORD] ¬ NumberItem[      tag: "width"L, place: [246, line4], boxWidth: 48, signed: FALSE, notNegative: TRUE, value: @data.width];    items[FormItems.height.ORD] ¬ NumberItem[      tag: "height"L, place: [354, line4], boxWidth: 48, signed: FALSE, notNegative: TRUE, value: @data.height];    items[FormItems.direction.ORD] ¬ EnumeratedItem[      tag: "direction"L, place: [42, line5], choices: DESCRIPTOR[direction], value: @data.direction];    items[FormItems.srcFunc.ORD] ¬ EnumeratedItem[      tag: "srcFunc"L, place: [168, line5], choices: DESCRIPTOR[srcFunc], value: @data.srcFunc];    items[FormItems.dstFunc.ORD] ¬ EnumeratedItem[      tag: "dstFunc"L, place: [276, line5], choices: DESCRIPTOR[dstFunc], value: @data.dstFunc];    items[FormItems.trc.ORD] ¬ StringItem[      tag: "trc"L, place: [396, line5], inHeap: TRUE, string: @data.trcFilename];    items[FormItems.sumVal.ORD] ¬ LongNumberItem[      tag: "sum"L, place: [42, line6], readOnly: TRUE, signed: FALSE, notNegative: TRUE, value: @data.sumVal];    items[FormItems.thresholdVal.ORD] ¬ NumberItem[      tag: "threshold"L, place: [42, line7], boxWidth: 48, signed: FALSE, notNegative: TRUE, default: 0, value: @data.thresholdVal];    items[FormItems.invert.ORD] ¬ BooleanItem[      tag: "invert"L, place: [158, line7], switch: @data.invert];    RETURN[items: items, freeDesc: TRUE];    };  TestProc: Exec.ExecProc = {    ToolWindow.Activate [wh]};  UnloadProc: Exec.ExecProc = {    Tool.Destroy[wh];    IF data.srcSeg # NIL THEN MSegment.Delete[data.srcSeg];    IF data.destSeg # NIL THEN MSegment.Delete[data.destSeg];    MSegment.FreePages[data];    Exec.RemoveCommand[h, "GrayBltTest"L]};  -- Mainline code  Init[];  -- this gets string out of global frame  }...    
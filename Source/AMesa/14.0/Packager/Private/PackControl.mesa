-- Copyright (C) 1981, 1982, 1983  by Xerox Corporation. All rights reserved. -- PackControl.mesa - Last edited by--   Sweet	 6-Jul-83 14:20:47--   Loretta	 5-Jun-81 16:35:46--   JGS	 6-Oct-82 13:43:16--   Lewis	11-May-83 11:48:58DIRECTORY  Alloc USING [    Chunkify, Create, defaultChunkType, Destroy, Failure, Overflow, Reset,    TableInfo, defaultIndexBits],  BcdDefs USING [VersionStamp],  CharIO USING [CR, PutChar, PutString, SP],  CodePackProcs USING [Determine, Destroy],  CommandUtil USING [    CommandObject, CommandPtr, CopyString, Create, Destroy, Failed, FreePairList,    FreeString, GetNthPair, ListLength, PairList, Parse, SetExtension],  Exec USING [AddCommand, CheckForAbort, ExecProc, GetChar, Handle, OutputProc],  Format USING [Char, CR, Decimal, Line, StringProc],  Heap USING [Create, Delete],  Inline USING [BITXOR, HighByte, LowByte, LowHalf],  MFile USING [    AppendErrorMessage, Delete, Error, GetProperties, GetTimes,    Handle, maxNameLength, ReadOnly, Release, SetAccess, WriteOnly],  MSegment USING [Error, GetFile],  MStream USING [Create, Error, GetFile, WriteOnly],  ModuleSymbols USING [Initialize, Finalize],  PackagerDefs USING [    NullSourceIndex, GlobalData, GlobalDataRecord, PackagerNTables],  PackCode USING [    ComputeCodePlacement, Finalize, PackError, WriteBcdToFile,    WriteCodeToBcdFile],  PackDebug USING [    Initialize, Finalize, PrintConfigTree, PrintSourceBcd, PrintTree,    PrintProcessingOrder],  PackEnviron USING [Zero],  PackParseData,  P1: FROM "PackParseDefs" USING [Parse],  ProcessingOrder USING [Determine, Destroy],  ProcessorFace USING [processorID],  PackList USING [Print],  Runtime USING [CallDebugger, GetBcdTime, GetTableBase],  SemanticEntry USING [BuildSemanticEntries],  SourceBcd USING [    BuildConfigTree, DestroyConfigTree, Load, Unload, BadSourceBcd, moduleCount],  Stream USING [    Delete, DeleteProcedure, Handle, Object, PutBlock, PutByteProcedure, PutByte,    PutProcedure],  String USING [AppendChar, AppendString, Equivalent],  SymTabOps USING [Initialize, Finalize],  Time USING [Append, AppendCurrent, Current, Unpack],  TreeOps: FROM "PackTreeOps" USING [Initialize, Finalize],  Version USING [Append],  Volume USING [InsufficientSpace];PackControl: PROGRAM  IMPORTS    Alloc, CharIO, CommandUtil, CodePackProcs, PackDebug, Exec, Format, Heap,    Inline, MFile, MSegment, MStream, ModuleSymbols, PackCode, PackEnviron,    PackParseData, P1, ProcessingOrder, ProcessorFace, PackList, Runtime,    SemanticEntry, SourceBcd, Stream, String, SymTabOps, Time, TreeOps,    Version, Volume  EXPORTS PackagerDefs  SHARES ProcessorFace =  BEGIN  CR: CHARACTER = CharIO.CR;  SP: CHARACTER = CharIO.SP;  GetNetAndHost: PROC RETURNS [net, host: CARDINAL] = {    sum: UNSPECIFIED = Inline.BITXOR[      ProcessorFace.processorID.a, Inline.BITXOR[      ProcessorFace.processorID.b, ProcessorFace.processorID.c]];    net ¬ LOOPHOLE[Inline.HighByte[sum]];    host ¬ LOOPHOLE[Inline.LowByte[sum]]};  -- Packager log  exec: Exec.Handle;  GetChar: PROC RETURNS [CHARACTER] = {RETURN[Exec.GetChar[exec]]};  Logger: Format.StringProc;  LogString: PROC [s: LONG STRING] = {Logger[s]};  LogLine: PROC [s: LONG STRING] = {Format.Line[Logger, s]};  LogChar: PROC [c: CHARACTER] = {Format.Char[Logger, c]};  NewLine: PROC = INLINE {Format.CR[Logger]};  LogDecimal: PROC [i: CARDINAL] = {Format.Decimal[Logger, i]};  LogHerald: PROC = {    t: STRING ¬ [60];    String.AppendString[t, "Mesa Packager "L];    Version.Append[t];    String.AppendString[t, " of "L];    Time.Append[t, Time.Unpack[LOOPHOLE[gd.packagerVersion.time]]];    t.length ¬ t.length - 3;    LogLine[t];    t.length ¬ 0;    Time.AppendCurrent[t];    t.length ¬ t.length - 3;    LogLine[t]};  LogCommand: PROC = {    NewLine[];    LogString["Packaging "L];    LogString[gd.sourceBcdName];    LogString[" according to "L];    LogLine[gd.packName];    LogString["Output to "L];    LogLine[gd.outputBcdName];    IF listPacks THEN {      LogString["Code and frame pack listing to "L];      LogLine[gd.packListFileName]};    IF gd.printMap THEN {      LogString["Code and frame pack map to "L]; LogLine[gd.mapFileName]};    NewLine[]};  -- Command gathering  args, results: CommandUtil.PairList;  switches: LONG STRING;  globalPause, localPause, listPacks: BOOLEAN;  debugPass: CARDINAL;  GetPackagingCommands: PROC RETURNS [cmd: CommandUtil.CommandPtr] = {    RETURN[CommandUtil.Create[GetChar]]};  -- Error logging  errorStreamObject: Stream.Object;  errorStream: Stream.Handle ¬ NIL;  OpenErrorStream: PROC = {    errorName: LONG STRING ¬ CommandUtil.CopyString[      gd.rootName, 2 + ("errlog"L).length];    errorName ¬ CommandUtil.SetExtension[errorName, "errlog"L];    errorStream ¬ MStream.WriteOnly[errorName, [], text];    WriteHeraldToErrlog[errorName];    WriteCommandToErrlog[];    errorName ¬ CommandUtil.FreeString[errorName]};  WriteHeraldToErrlog: PROC [errorFileName: LONG STRING] = {    OPEN CharIO;    t: STRING ¬ [60];    String.AppendString[t, "Mesa Packager "L];    Version.Append[t];    String.AppendString[t, " of "L];    Time.Append[t, Time.Unpack[LOOPHOLE[gd.packagerVersion.time]]];    t.length ¬ t.length - 3;    PutString[errorStream, t];    PutChar[errorStream, CR];    t.length ¬ 0;    Time.AppendCurrent[t];    t.length ¬ t.length - 3;    PutString[errorStream, errorFileName];    PutString[errorStream, " -- "L];    PutString[errorStream, t];    PutChar[errorStream, CR]};  WriteCommandToErrlog: PROC = {    OPEN CharIO;    PutChar[errorStream, CR];    PutString[errorStream, "Packaging "L];    PutString[errorStream, gd.sourceBcdName];    PutString[errorStream, " according to "L];    PutString[errorStream, gd.packName];    PutChar[errorStream, CR];    PutString[errorStream, "Output to "L];    PutString[errorStream, gd.outputBcdName];    PutChar[errorStream, CR];    IF listPacks THEN {      PutString[errorStream, "Code and frame pack listing to "L];      PutString[errorStream, gd.packListFileName];      PutChar[errorStream, CR]};    IF gd.printMap THEN {      PutString[errorStream, "Code and frame pack map to "L];      PutString[errorStream, gd.mapFileName];      PutChar[errorStream, CR]};    PutChar[errorStream, CR]};  CloseErrorStream: PROC = {    IF errorStream # NIL THEN {errorStream.Delete[]; errorStream ¬ NIL}};  ErrorPut: Stream.PutByteProcedure --[sH: Stream.Handle, byte: Stream.Byte]--  =    {IF errorStream = NIL THEN OpenErrorStream[]; errorStream.PutByte[byte]};  ErrorPutBlock: Stream.PutProcedure    --[sH: Handle, block: Block, endRecord: BOOL]--  = {    IF errorStream = NIL THEN OpenErrorStream[];    errorStream.PutBlock[block, endRecord]};  ErrorDestroy: Stream.DeleteProcedure --[sH: Stream.Handle]--  = {    CloseErrorStream[]};  packFile, packListFile, mapFile: MFile.Handle ¬ NIL;  OpenFiles: PROC = {    packFile ¬ MFile.ReadOnly[gd.packName, []];    gd.sourceBcdFile ¬ MFile.ReadOnly[gd.sourceBcdName, []];    gd.outputBcdFile ¬ MFile.WriteOnly[gd.outputBcdName, [], binary];    IF listPacks THEN      packListFile ¬ MFile.WriteOnly[gd.packListFileName, [], text];    IF gd.printMap THEN mapFile ¬ MFile.WriteOnly[gd.mapFileName, [], text]};  SetRoot: PROC [root, s: LONG STRING] = {    root.length ¬ 0;    FOR i: CARDINAL IN [0..s.length) DO      IF s[i] = '. THEN EXIT; String.AppendChar[root, s[i]]; ENDLOOP};  SetFileName: PROC [fileName, extension: LONG STRING] RETURNS [LONG STRING] = {    root: LONG STRING =      (IF fileName # NIL THEN fileName       ELSE CommandUtil.CopyString[gd.rootName, 2 + extension.length]);    RETURN[CommandUtil.SetExtension[root, extension]]};  TimeSince: PROC [start: LONG CARDINAL] RETURNS [elapsedTime: LONG CARDINAL] = {    RETURN[Time.Current[] - start]};  -- #### THIS MAIN PROCEDURE IS CALLED TO DO PACKAGING ####  DoPackaging: Exec.ExecProc =    BEGIN    ENABLE {      MFile.Error => {	msg: STRING ¬ [100];	MFile.AppendErrorMessage[msg, code, file];        LogString["MFile error: "L];  LogLine[msg];        GOTO error};      MStream.Error => {        name: LONG STRING ¬ [MFile.maxNameLength];        SELECT TRUE FROM	  (stream = NIL) => name ¬ "unknown"L;	  (code = invalidHandle) => name ¬ "unknown"L;	  ENDCASE => [] ¬ MFile.GetProperties[MStream.GetFile[stream], name];        LogString["Problem in accessing stream on file: "L];        LogString[IF name.length > 0 THEN name ELSE "unknown"L];	SELECT code FROM	  invalidHandle    => LogLine[": invalidHandle"L];	  indexOutOfRange  => LogLine[": indexOutOfRange"L];	  invalidOperation => LogLine[": invalidOperation"L];	  fileTooLong      => LogLine[": fileTooLong"L];	  fileNotAvailable => LogLine[": fileNotAvailable"L];	  other            => LogLine[": other"L];	  ENDCASE          => LogLine[": (unknown MStream.Error)"L];        GOTO error};      MSegment.Error => {        name: LONG STRING ¬ [MFile.maxNameLength];        SELECT TRUE FROM	  (segment = NIL) => name ¬ "unknown"L;	  (code = noSuchSegment) => name ¬ "unknown"L;	  ENDCASE => {	    file: MFile.Handle ¬ MSegment.GetFile[segment];	    IF file = NIL THEN name ¬ "unknown"L	    ELSE [] ¬ MFile.GetProperties[file, name]};        LogString["Problem in accessing segment on file: "L];        LogString[IF name.length > 0 THEN name ELSE "unknown"L];	SELECT code FROM	  zeroLength         => LogLine[": zeroLength"L];	  insufficientVM     => LogLine[": insufficientVM"L];	  noSuchSegment      => LogLine[": noSuchSegment"L];	  sharedSegment      => LogLine[": sharedSegment"L];	  baseOutOfRange     => LogLine[": baseOutOfRange"L];	  conflictingAccess  => LogLine[": conflictingAccess"L];	  illegalAccess      => LogLine[": illegalAccess"L];	  other              => LogLine[": other"L];          ENDCASE            => LogLine[": (unknown MSegment.Error)"L];        GOTO error};      Volume.InsufficientSpace => {LogLine["Volume full"L];  GOTO error}};    RETURN[DoPackagingInternal[h]];    EXITS error => RETURN[error];    END;  DoPackagingInternal: Exec.ExecProc =    BEGIN    packCommands: CommandUtil.CommandPtr;    key, value: LONG STRING;    abortRequested: BOOLEAN ¬ FALSE;    globalErrors, globalWarnings: BOOLEAN ¬ FALSE;    parsed, aborted: BOOLEAN;    packagerStartTime: LONG CARDINAL;    Initialize: PROC = {      weights: ARRAY [0..PackagerDefs.PackagerNTables) OF Alloc.TableInfo ¬ [        [Alloc.defaultIndexBits, 16, 32], 	-- treetype	[Alloc.defaultIndexBits, 2, 8], 		-- httype	[Alloc.defaultIndexBits, 4, 12], 	-- sstype	[Alloc.defaultIndexBits, 1, 1],		-- cttype	[Alloc.defaultIndexBits, 2, 8], 		-- mttype	[Alloc.defaultIndexBits, 1, 1], 		-- imptype	[Alloc.defaultIndexBits, 4, 8], 		-- exptype	[Alloc.defaultIndexBits, 4, 12], 	-- sgtype	[Alloc.defaultIndexBits, 4, 12], 	-- fttype	[Alloc.defaultIndexBits, 1, 1], 		-- sttype	[Alloc.defaultIndexBits, 1, 1], 		-- cxtype	[Alloc.defaultIndexBits, 1, 1], 		-- nttype	[Alloc.defaultIndexBits, 4, 12], 	-- entype	[Alloc.defaultIndexBits, 1, 1], 		-- sptype	[Alloc.defaultIndexBits, 1, 1], 		-- fptype	[Alloc.defaultIndexBits, 1, 1], 		-- typtype	[Alloc.defaultIndexBits, 1, 1], 		-- tmtype	[Alloc.defaultIndexBits, 1, 1], 		-- lftype 	[Alloc.defaultIndexBits, 1, 1], 		-- attype	[Alloc.defaultIndexBits, 1, 1], 		-- aptype	[Alloc.defaultIndexBits, 8, 12], 	-- packhttype	[Alloc.defaultIndexBits, 12, 24],	-- packsstype	[Alloc.defaultIndexBits, 12, 24], 	-- packsttype	[Alloc.defaultIndexBits, 4, 8], 		-- packctreetype	[Alloc.defaultIndexBits, 4, 8], 		-- packpotype	[Alloc.defaultIndexBits, 12, 24]];	-- packmdtype      IF gd.ownTable = NIL THEN {        gd.ownTable ¬ Alloc.Create[weights: DESCRIPTOR[weights]];        Alloc.Chunkify[h: gd.ownTable, table: Alloc.defaultChunkType]}      ELSE Alloc.Reset[gd.ownTable];      LogCommand[];      gd.errors ¬ gd.warnings ¬ aborted ¬ FALSE;      gd.nErrors ¬ gd.nWarnings ¬ 0;      gd.textIndex ¬ PackagerDefs.NullSourceIndex;      errorStream ¬ NIL};    Finalize: PROC = {      SymTabOps.Finalize[];      TreeOps.Finalize[];      IF gd.debug THEN PackDebug.Finalize[];      IF abortRequested THEN LogLine["Packaging aborted"L]      ELSE        IF gd.errors THEN LogLine["Errors detected; Bcd not written"L]        ELSE {          LogDecimal[Inline.LowHalf[TimeSince[packagerStartTime]]];          LogLine[" seconds"L]};      IF errorStream # NIL THEN {        LogString["See "L]; LogString[gd.rootName]; LogLine[".errlog"]};      CloseErrorStream[];      Alloc.Reset[gd.ownTable];      Heap.Delete[gd.zone];      gd.zone ¬ NIL};    FinalizeFiles: PROC = {      IF gd.packStream # NIL THEN gd.packStream.Delete[];      IF gd.packListStream # NIL THEN gd.packListStream.Delete[];      IF gd.mapStream # NIL THEN gd.mapStream.Delete[];      IF gd.outputBcdFile # NIL THEN {        IF gd.nErrors # 0 THEN {          MFile.SetAccess[            gd.outputBcdFile, delete ! MFile.Error => GOTO cantDelete];          MFile.Delete[gd.outputBcdFile ! MFile.Error => CONTINUE];          EXITS cantDelete => NULL}        ELSE MFile.Release[gd.outputBcdFile ! MFile.Error => CONTINUE];        gd.outputBcdFile ¬ NIL};      IF gd.sourceBcdFile # NIL THEN {        MFile.Release[gd.sourceBcdFile ! MFile.Error => CONTINUE];        gd.sourceBcdFile ¬ NIL}};    exec ¬ h;    Logger ¬ Exec.OutputProc[h];    packCommands ¬ GetPackagingCommands[];    globalPause ¬ TRUE;    listPacks ¬ FALSE;    debugPass ¬ LAST[CARDINAL];    gd.packagerVersion.time ¬ Runtime.GetBcdTime[];    gd.packagerVersion.net ¬ gd.packagerVersion.host ¬ 0;    [gd.network, gd.host] ¬ GetNetAndHost[];    BEGIN    ENABLE {      UNWIND => {        CommandUtil.Destroy[packCommands];        IF gd.ownTable # NIL THEN {          Alloc.Destroy[gd.ownTable]; gd.ownTable ¬ NIL}};      Alloc.Overflow => RESUME [8]};    LogHerald[];    DO  -- until no more Packager commands      BEGIN      gd.zone ¬ Heap.Create[initial: 50, increment: 10, swapUnitSize: 10];      gd.rootName ¬ gd.zone.NEW[StringBody [MFile.maxNameLength]];      gd.packName ¬ gd.sourceBcdName ¬ NIL;      gd.outputBcdName ¬ gd.packListFileName ¬ NIL;      gd.mapFileName ¬ NIL;      gd.debug ¬ FALSE;      debugPass ¬ LAST[CARDINAL];      gd.printMap ¬ listPacks ¬ FALSE;      localPause ¬ FALSE;      [gd.packName, args, results, switches] ¬ CommandUtil.Parse[        cmd: packCommands, opX: 2 + ("pack").length, resultX: 2 + ("list").length,        allowNoTagParm: TRUE ! CommandUtil.Failed => GO TO BadCommandLineSyntax];      gd.switch ¬ ALL[FALSE];      IF gd.packName = NIL AND switches = NIL THEN EXIT;  -- done packaging      IF gd.packName = NIL THEN GO TO GlobalSwitches;      SetRoot[gd.rootName, gd.packName];      FOR i: CARDINAL IN [0..CommandUtil.ListLength[results]) DO        [key, value] ¬ CommandUtil.GetNthPair[list: results, n: i];        SELECT TRUE FROM          (key = NIL), String.Equivalent[key, "output"] =>            gd.outputBcdName ¬ CommandUtil.CopyString[              s: value, extra: (".bcd").length];          String.Equivalent[key, "list"] => {            listPacks ¬ TRUE;            gd.packListFileName ¬ CommandUtil.CopyString[              s: value, extra: (".list").length]};          String.Equivalent[key, "map"] => {            gd.printMap ¬ TRUE;            gd.mapFileName ¬ CommandUtil.CopyString[              s: value, extra: (".map").length]};          ENDCASE => GO TO BadCommandLineSemantics;        ENDLOOP;      FOR i: CARDINAL IN [0..CommandUtil.ListLength[args]) DO        [key, value] ¬ CommandUtil.GetNthPair[list: args, n: i];        SELECT TRUE FROM          (key = NIL), String.Equivalent[key, "input"] =>            gd.sourceBcdName ¬ CommandUtil.CopyString[              s: value, extra: (".bcd").length];          ENDCASE => GO TO BadCommandLineSemantics;        ENDLOOP;      IF switches # NIL THEN        BEGIN        i: CARDINAL ¬ 0;        sense: BOOLEAN ¬ TRUE;        WHILE i < switches.length DO          c: CHARACTER = switches[i];          SELECT c FROM            '-, '~ => sense ¬ ~sense;            'l, 'L => {listPacks ¬ gd.switch['l] ¬ sense; sense ¬ TRUE};            'm, 'M => {gd.printMap ¬ gd.switch['m] ¬ sense; sense ¬ TRUE};            'p, 'P => {localPause ¬ gd.switch['p] ¬ sense; sense ¬ TRUE};            'd, 'D => {gd.debug ¬ gd.switch['d] ¬ sense; sense ¬ TRUE};            '! => {Runtime.CallDebugger[NIL]; sense ¬ TRUE};            IN ['0..'5] => {debugPass ¬ c - '0; sense ¬ TRUE};	    IN ['A..'Z] => {gd.switch[c + ('a - 'A)] ¬ sense; sense ¬ TRUE};	    IN ['a..'z] => {gd.switch[c] ¬ sense; sense ¬ TRUE};            ENDCASE;          i ¬ i + 1;          ENDLOOP;        switches ¬ CommandUtil.FreeString[switches];        END;      packagerStartTime ¬ Time.Current[];      packFile ¬ packListFile ¬ mapFile ¬ NIL;      gd.sourceBcdFile ¬ gd.outputBcdFile ¬ NIL;      gd.packStream ¬ gd.packListStream ¬ NIL;      gd.mapStream ¬ NIL;      IF gd.sourceBcdName = NIL THEN GOTO NoSourceBcdFileGiven;      gd.packName ¬ SetFileName[gd.packName, "pack"];      gd.sourceBcdName ¬ SetFileName[gd.sourceBcdName, "bcd"];      gd.outputBcdName ¬ SetFileName[gd.outputBcdName, "bcd"];      IF String.Equivalent[gd.sourceBcdName, gd.outputBcdName] THEN        GOTO OutputBcdIsInputBcd;      IF listPacks THEN        gd.packListFileName ¬ SetFileName[gd.packListFileName, "list"];      IF gd.printMap THEN gd.mapFileName ¬ SetFileName[gd.mapFileName, "map"];      OpenFiles[ ! MFile.Error => CONTINUE];      IF packFile = NIL THEN GO TO CantFindPackFile      ELSE {        gd.packStream ¬ MStream.Create[packFile, []];        gd.packVersion ¬ BcdDefs.VersionStamp[          net: 0, host: 0, time: MFile.GetTimes[packFile].create];        packFile ¬ NIL};      IF gd.sourceBcdFile = NIL THEN GO TO CantFindSourceBcdFile;      IF gd.outputBcdFile = NIL THEN GO TO CantOpenObjectBcdFile;      IF listPacks THEN {        IF packListFile = NIL THEN          gd.packListStream ¬ MStream.WriteOnly[gd.packListFileName, [], text]        ELSE {          gd.packListStream ¬ MStream.Create[packListFile, []];          packListFile ¬ NIL}};      IF gd.printMap THEN {        IF mapFile = NIL THEN          gd.mapStream ¬ MStream.WriteOnly[gd.mapFileName, [], text]        ELSE {gd.mapStream ¬ MStream.Create[mapFile, []]; mapFile ¬ NIL}};      gd.logStream ¬ NIL;      errorStream ¬ NIL;      -- install private putByte and destroy procedures       errorStreamObject ¬ Stream.Object[        options: NULL, setSST: NULL, getByte: NULL, putByte: ErrorPut,        getWord: NULL, putWord: NULL, get: NULL, put: ErrorPutBlock,        sendAttention: NULL, waitAttention: NULL, sendNow: NULL,        getPosition: NULL, setPosition: NULL, delete: ErrorDestroy,	clientData: NIL];      gd.errorStream ¬ @errorStreamObject;      Initialize[];      BEGIN      ENABLE {        Alloc.Failure => {          gd.errors ¬ TRUE;          IF ~gd.debug THEN {LogLine["Storage Overflow"]; GOTO StorageOverflow}};        UNWIND => {FinalizeFiles[];  Finalize[]}};      IF gd.debug THEN PackDebug.Initialize[];      SymTabOps.Initialize[];      TreeOps.Initialize[];      IF Exec.CheckForAbort[exec] THEN GO TO Abort;      SourceBcd.Load[ ! SourceBcd.BadSourceBcd => GO TO InvalidSourceBcd];      LogString["Parsing"L];      [complete: parsed, nErrors: gd.nErrors] ¬ P1.Parse[        sourceStream: gd.packStream, messageStream: gd.errorStream,        table: Runtime.GetTableBase[LOOPHOLE[PackParseData]], uz: gd.zone];      IF gd.nErrors # 0 THEN gd.errors ¬ TRUE;      IF debugPass <= 1 THEN PackDebug.PrintTree[];      IF ~parsed THEN GO TO ParseFailed;      IF Exec.CheckForAbort[exec] THEN GO TO Abort;      IF ~gd.errors THEN {        LogString["...Building semantic entries"L];        SourceBcd.BuildConfigTree[];        SemanticEntry.BuildSemanticEntries[];        IF debugPass <= 2 THEN {          PackDebug.PrintSourceBcd[];          PackDebug.PrintConfigTree[];          PackDebug.PrintTree[]};        IF Exec.CheckForAbort[exec] THEN GO TO Abort;        IF ~gd.errors THEN {          LogString["...Determining packs"L];          ProcessingOrder.Determine[];          IF debugPass <= 3 THEN PackDebug.PrintProcessingOrder[];          IF Exec.CheckForAbort[exec] THEN GO TO Abort;          ModuleSymbols.Initialize[SourceBcd.moduleCount];          IF ~gd.errors THEN {            CodePackProcs.Determine[];            IF Exec.CheckForAbort[exec] THEN GO TO Abort;            IF ~gd.errors THEN {              IF listPacks THEN PackList.Print[];	      IF gd.packListStream # NIL THEN {	        gd.packListStream.Delete[];  gd.packListStream ¬ NIL};              LogString["...Computing code placement"L];              PackCode.ComputeCodePlacement[                ! PackCode.PackError => {		    IF reason # SegmentTooBig AND ~gd.debug THEN {		      LogLine["\nPackCode error: "L];		      SELECT reason FROM		        InvalidCodeOffset => LogLine["InvalidCodeOffset"L];		        StrangeJI =>	 LogLine["StrangeJI"L];		        StrangeLIO =>	 LogLine["StrangeLIO"L];		        StrangeCatch =>	 LogLine["StrangeCatch"L];		        NonZeroBase =>	 LogLine["NonZeroBase"L];		        EVNotPlaced =>	 LogLine["EVNotPlaced"L];		        ENDCASE =>	 LogLine["unknown"L]};		    GO TO dont}];              IF Exec.CheckForAbort[exec] THEN GO TO Abort;              LogString["...Writing Bcd"L];              PackCode.WriteBcdToFile[];              PackCode.WriteCodeToBcdFile[];              EXITS dont => PackCode.Finalize[]}}}};      EXITS        StorageOverflow => NULL;        ParseFailed => gd.errors ¬ aborted ¬ TRUE;        InvalidSourceBcd => gd.errors ¬ aborted ¬ TRUE;        Abort => abortRequested ¬ TRUE;      END;      CodePackProcs.Destroy[];      ProcessingOrder.Destroy[];      ModuleSymbols.Finalize[];      SourceBcd.DestroyConfigTree[];      SourceBcd.Unload[];      NewLine[];      Finalize[];      EXITS        NoSourceBcdFileGiven => {          LogChar[CR];          LogLine["No source BCD file given"];          LogChar[CR];          gd.errors ¬ TRUE};        OutputBcdIsInputBcd => {          LogChar[CR];          LogLine["Output BCD file is the same as the input Bcd"];          LogChar[CR];          gd.errors ¬ TRUE};        CantFindPackFile => {          LogChar[CR];          LogLine["Can't find pack file "];          LogLine[gd.packName];          gd.errors ¬ TRUE};        CantFindSourceBcdFile => {          LogChar[CR];          LogString["Can't find source Bcd "];          LogLine[gd.sourceBcdName];          gd.errors ¬ TRUE};        CantOpenObjectBcdFile => {          LogChar[CR];          LogString["Can't open output Bcd "];          LogLine[gd.outputBcdName];          gd.errors ¬ TRUE};        GlobalSwitches => {          sense: BOOLEAN;          results ¬ CommandUtil.FreePairList[results];          args ¬ CommandUtil.FreePairList[args];          sense ¬ TRUE;          FOR i: CARDINAL IN [0..switches.length) DO            c: CHARACTER = switches[i];            SELECT c FROM              '-, '~ => sense ¬ ~sense;              '! => Runtime.CallDebugger["Called from Packager"L];              'b, 'B => sense ¬ TRUE;  -- ignored              'p, 'P => {globalPause ¬ sense; sense ¬ TRUE};              ENDCASE => EXIT;            ENDLOOP;          switches ¬ CommandUtil.FreeString[switches]};        BadCommandLineSemantics => {          results ¬ CommandUtil.FreePairList[results];          args ¬ CommandUtil.FreePairList[args];          LogLine[" -- Illegal Packager command"];          gd.errors ¬ TRUE};      END;      FinalizeFiles[];      gd.packName ¬ CommandUtil.FreeString[gd.packName];      gd.sourceBcdName ¬ CommandUtil.FreeString[gd.sourceBcdName];      gd.outputBcdName ¬ CommandUtil.FreeString[gd.outputBcdName];      IF listPacks THEN        gd.packListFileName ¬ CommandUtil.FreeString[gd.packListFileName];      IF gd.printMap THEN gd.mapFileName ¬ CommandUtil.FreeString[gd.mapFileName];      results ¬ CommandUtil.FreePairList[results];      args ¬ CommandUtil.FreePairList[args];      IF gd.errors THEN globalErrors ¬ TRUE;      IF gd.warnings THEN globalWarnings ¬ TRUE;      IF abortRequested THEN EXIT;  -- stop Packager      IF gd.errors OR gd.warnings THEN {        IF localPause THEN {globalPause ¬ TRUE; EXIT}};      REPEAT        BadCommandLineSyntax => {          NewLine[];          LogLine["-- Illegal Packager command syntax"];          gd.errors ¬ globalErrors ¬ TRUE};      ENDLOOP;    END;    CommandUtil.Destroy[packCommands];    IF gd.ownTable # NIL THEN {Alloc.Destroy[gd.ownTable]; gd.ownTable ¬ NIL};    IF gd.zone # NIL THEN {Heap.Delete[gd.zone]; gd.zone ¬ NIL};    RETURN[      (SELECT TRUE FROM         abortRequested => abort,         globalErrors => error,         globalWarnings => warning,         ENDCASE => normal)];    END;  -- of procedure DoPackagingInternal  -- MAIN BODY CODE  globalData: PUBLIC PackagerDefs.GlobalData ¬ @gd;  gd: PackagerDefs.GlobalDataRecord;  -- local copy of globalData  InitializeSelf: PROC =    BEGIN    PackEnviron.Zero[globalData, SIZE[PackagerDefs.GlobalDataRecord]];    Exec.AddCommand[name: "Packager.~", proc: DoPackaging];    END;  InitializeSelf[];  END.
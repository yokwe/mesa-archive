-- Copyright (C) 1981, 1982  by Xerox Corporation. All rights reserved. -- SemanticEntryImpl.mesa  -- Last edited by Lewis on 16-Nov-81 11:17:07-- Last edited by Sweet on September 16, 1980  12:50 PM-- Last edited by JGS   on 17-Sep-82 14:23:16DIRECTORY  Alloc USING [AddNotify, DropNotify, Handle, Notifier, Words],  BcdDefs USING [MTIndex, MTNull],  Error USING [    Error, ErrorHti, FrameInTwoFramePacks, FrameNotPlaced,    TableCompModuleNotIncAsUnit],  PackagerDefs USING [    globalData, GlobalData, packctreetype, packtreetype, packsttype],  SemanticEntry USING [STIndex, STRecord],  SourceBcd USING [    ComponentKind, CTreeIndex, EnumerateModules, EnumerateModulesInConfig,    FindModuleOrConfig, IsTableCompiled, LookupId, ModuleNum, moduleCount,    ModuleNumForMti, NullCTreeIndex],  SymTabDefs USING [HTIndex, HTNull],  Table USING [Base],  Tree: FROM "PackTree" USING [    Index, Link, Map, Null, NullIndex, root, Scan, Test],  TreeOps: FROM "PackTreeOps" USING [    ListLength, ListHead, ListTail, ScanList, SearchList, UpdateList];SemanticEntryImpl: PROGRAM    IMPORTS Alloc, Error, PackagerDefs, SourceBcd, Tree, TreeOps    EXPORTS SemanticEntry =  BEGIN OPEN SemanticEntry;  SEerror: PROC = {ERROR BuildSEerror};  BuildSEerror: PUBLIC ERROR = CODE;  gd: PackagerDefs.GlobalData ¬ NIL;  table: Alloc.Handle ¬ NIL;  tb, stb, ctreeb: Table.Base;  Notifier: Alloc.Notifier = {    tb     ¬ base[PackagerDefs.packtreetype];      stb    ¬ base[PackagerDefs.packsttype];    ctreeb ¬ base[PackagerDefs.packctreetype]};  NewSemanticEntry: PROC RETURNS [newSE: STIndex] = {    newSE ¬ table.Words[PackagerDefs.packsttype, SIZE[STRecord]];    stb[newSE] ¬ [      hti: SymTabDefs.HTNull,       treeNode: Tree.NullIndex,       kind: unknown[]]}; -- *********************** Build semantic entries ************************  anyMergeSegments, anyMergeFramePacks: BOOLEAN;  BuildSemanticEntries: PUBLIC PROC = {    gd ¬ PackagerDefs.globalData;    table ¬ gd.ownTable;    table.AddNotify[Notifier, NIL];    WITH Tree.root SELECT FROM      subtree =>         BEGIN        anyMergeSegments ¬ anyMergeFramePacks ¬ FALSE;        InitializeFrameArray[];        RecordSegAndFramePackIds[];  -- and set anyMergeSegments, anyMergeFramePacks        ProcessSegAndFramePacks[];	IF anyMergeSegments THEN ProcessMergeSegments[];	IF anyMergeFramePacks THEN ProcessMergeFramePacks[];        VerifyAllFramesPlaced[];        DestroyFrameArray[];        ReleaseSegAndFramePackIds[];        END;      ENDCASE => SEerror[];    table.DropNotify[Notifier, NIL];    table ¬ NIL;  gd ¬ NIL}; -- ************* Verify correct placement of global frames *************  -- parse tree nodes of frame packs containing each global frame  frameArray: LONG POINTER TO FrameMap ¬ NIL;  -- SourceBcd.ModuleNum -> Tree.Index  FrameMap: TYPE = RECORD [SEQUENCE length: CARDINAL OF Tree.Index];  InitializeFrameArray: PROC = {    frameArray ¬ gd.zone.NEW[FrameMap[SourceBcd.moduleCount]];    FOR i: SourceBcd.ModuleNum IN [0..SourceBcd.moduleCount) DO      frameArray[i] ¬ Tree.NullIndex;      ENDLOOP};  DestroyFrameArray: PROC = {gd.zone.FREE[@frameArray]};  MarkFramePlaced: PROC [mti: BcdDefs.MTIndex, fpNode: Tree.Index] = {    mNum: SourceBcd.ModuleNum ¬ SourceBcd.ModuleNumForMti[mti];    IF frameArray[mNum] # Tree.NullIndex THEN      BEGIN      fpId1, fpId2: SymTabDefs.HTIndex;      WITH tb[frameArray[mNum]].son[1] SELECT FROM	hash => fpId1 ¬ index;	ENDCASE => SEerror[];      WITH tb[fpNode].son[1] SELECT FROM	hash => fpId2 ¬ index;	ENDCASE => SEerror[];      Error.FrameInTwoFramePacks[error, mti, fpId1, fpId2];      END    ELSE frameArray[mNum] ¬ fpNode};  VerifyAllFramesPlaced: PROC = {        VerifyOneFramePlaced: PROC [mti: BcdDefs.MTIndex] RETURNS [stop: BOOLEAN] =      BEGIN      mNum: SourceBcd.ModuleNum ¬ SourceBcd.ModuleNumForMti[mti];      IF frameArray[mNum] = Tree.NullIndex THEN	Error.FrameNotPlaced[warning, mti];      RETURN[FALSE];      END;    SourceBcd.EnumerateModules[VerifyOneFramePlaced]}; -- ****** Management of segment and frame pack tree node arrays ******  segArray, fpArray: TreeNodeArray ¬ NIL;  TreeNodeArray: TYPE = LONG POINTER TO TreeNodeMap;  -- # -> Tree.Index  TreeNodeMap: TYPE = RECORD [SEQUENCE length: CARDINAL OF Tree.Index];  segCount, fpCount: CARDINAL;  currentSeg, currentFP: CARDINAL;  RecordSegAndFramePackIds: PROC = {    segCount ¬ fpCount ¬ 0;    TreeOps.ScanList[Tree.root, CountSegOrFPId];    segArray ¬ gd.zone.NEW[TreeNodeMap[segCount]];    fpArray ¬ gd.zone.NEW[TreeNodeMap[fpCount]];    currentSeg ¬ currentFP ¬ 0;    TreeOps.ScanList[Tree.root, NoteSegOrFPId]};  ReleaseSegAndFramePackIds: PROC = {    gd.zone.FREE[@segArray];      gd.zone.FREE[@fpArray];    segCount ¬ fpCount ¬ 0};  CountSegOrFPId: Tree.Scan = {    WITH t SELECT FROM      subtree =>        BEGIN node: Tree.Index = index;        SELECT tb[node].name FROM          codeSeg   => segCount ¬ segCount+1;          framePack => fpCount ¬ fpCount+1;          merge     => {segCount ¬ segCount+1;  anyMergeSegments ¬ TRUE};          mergeFP   => {fpCount ¬ fpCount+1;  anyMergeFramePacks ¬ TRUE};          ENDCASE;        END;      ENDCASE => SEerror[]};  NoteSegOrFPId: Tree.Scan = {    nodeName: SymTabDefs.HTIndex;    i: CARDINAL;    saveIndex: CARDINAL = gd.textIndex;    WITH t SELECT FROM      subtree =>        BEGIN node: Tree.Index = index;        gd.textIndex ¬ tb[node].info;        WITH tb[node].son[1] SELECT FROM          hash => nodeName ¬ index;          ENDCASE => SEerror[];        SELECT tb[node].name FROM          codeSeg, merge => 	    BEGIN            FOR i IN [0..currentSeg) DO              WITH tb[segArray[i]].son[1] SELECT FROM                hash =>         	  IF nodeName = index THEN          	    BEGIN        	    Error.ErrorHti[error, "appears twice as a code segment name"L, nodeName];                    EXIT;        	    END;                ENDCASE => SEerror[];              ENDLOOP;            segArray[currentSeg] ¬ node;  currentSeg ¬ currentSeg+1;	    END;          framePack, mergeFP => 	    BEGIN            FOR i IN [0..currentFP) DO              WITH tb[fpArray[i]].son[1] SELECT FROM                hash =>         	  IF nodeName = index THEN           	    BEGIN        	    Error.ErrorHti[error, "appears twice as a frame pack name"L, nodeName];                    EXIT;        	    END;                ENDCASE => SEerror[];              ENDLOOP;	    fpArray[currentFP] ¬ node;  currentFP ¬ currentFP+1;	    END;          ENDCASE;         END;      ENDCASE => SEerror[];    gd.textIndex ¬ saveIndex};  FindSeg: PROC [      id: SymTabDefs.HTIndex] RETURNS [found: BOOLEAN, segNode: Tree.Index] = {    i: CARDINAL;    FOR i IN [0..segCount) DO      segNode ¬ segArray[i];      WITH tb[segNode].son[1] SELECT FROM        hash => IF id = index THEN RETURN[TRUE, segNode];        ENDCASE => SEerror[];      ENDLOOP;    RETURN[FALSE, Tree.NullIndex]};  FindFramePack: PROC [      id: SymTabDefs.HTIndex] RETURNS [found: BOOLEAN, fpNode: Tree.Index] = {    i: CARDINAL;    FOR i IN [0..fpCount) DO      fpNode ¬ fpArray[i];      WITH tb[fpNode].son[1] SELECT FROM        hash => IF id = index THEN RETURN[TRUE, fpNode];        ENDCASE => SEerror[];      ENDLOOP;    RETURN[FALSE, Tree.NullIndex]}; -- ****** Process the identifiers in code segments and frame packs ******  ProcessSegAndFramePacks: PROC = {    ProcessSegOrFP: Tree.Scan =      BEGIN      WITH t SELECT FROM        subtree =>          BEGIN node: Tree.Index = index;          SELECT tb[node].name FROM            codeSeg   => ProcessOneCodeSeg[node];            framePack => ProcessOneFramePack[node];            ENDCASE;          END;        ENDCASE => SEerror[];      END;    TreeOps.ScanList[Tree.root, ProcessSegOrFP]}; -- ********************** Process a code segment **********************  currentSegId: SymTabDefs.HTIndex;    currentSegNode: Tree.Index;     cpArray: TreeNodeArray ¬ NIL;  -- code pack # -> tree node map  cpCount, currentCP: CARDINAL;  ProcessOneCodeSeg: PROC [segNode: Tree.Index] = {    saveIndex: CARDINAL = gd.textIndex;    gd.textIndex ¬ tb[segNode].info;    currentSegNode ¬ segNode;    WITH tb[segNode].son[1] SELECT FROM      hash => currentSegId ¬ index;      ENDCASE => SEerror[];    RecordCodePackIds[segNode];    ProcessCodePacks[segNode];    ReleaseCodePackIds[];    gd.textIndex ¬ saveIndex};  RecordCodePackIds: PROC [segNode: Tree.Index] = {    cpCount ¬ TreeOps.ListLength[tb[segNode].son[2]];    cpArray ¬ gd.zone.NEW[TreeNodeMap[cpCount]];    currentCP ¬ 0;    TreeOps.ScanList[tb[segNode].son[2], NoteCPId]};  ReleaseCodePackIds: PROC =  {    gd.zone.FREE[@cpArray];    cpCount ¬ 0};  NoteCPId: Tree.Scan = {    cpId: SymTabDefs.HTIndex;    i: CARDINAL;    WITH t SELECT FROM      subtree =>        BEGIN cpNode: Tree.Index = index;        SELECT tb[cpNode].name FROM           codePack, unnamedCodePack, discardCodePack =>	    BEGIN            WITH tb[cpNode].son[1] SELECT FROM              hash => cpId ¬ index;              ENDCASE => SEerror[];            FOR i IN [0..currentCP) DO              WITH tb[cpArray[i]].son[1] SELECT FROM                hash =>         	  IF cpId = index THEN         	    BEGIN        	    Error.ErrorHti[error, "appears twice as a code pack name"L, cpId];                    EXIT;        	    END;                ENDCASE => SEerror[];              ENDLOOP;            cpArray[currentCP] ¬ cpNode;  currentCP ¬ currentCP+1;    	    END;          ENDCASE => SEerror[];        END;      ENDCASE => SEerror[]};  FindCodePack: PROC [      id: SymTabDefs.HTIndex] RETURNS [found: BOOLEAN, cpNode: Tree.Index] = {    i: CARDINAL;    FOR i IN [0..cpCount) DO      cpNode ¬ cpArray[i];      WITH tb[cpNode].son[1] SELECT FROM        hash => IF id = index THEN RETURN[TRUE, cpNode];        ENDCASE => SEerror[];      ENDLOOP;    RETURN[FALSE, Tree.NullIndex]};  ProcessCodePacks: PROC [segNode: Tree.Index] =    {TreeOps.ScanList[tb[segNode].son[2], ProcessOneCodePack]};  currentCpNode: Tree.Index;  ProcessOneCodePack: Tree.Scan = {    WITH t SELECT FROM      subtree =>        BEGIN        currentCpNode ¬ index;        TreeOps.ScanList[tb[currentCpNode].son[2], ProcessOneComponentDesc];        END;      ENDCASE => SEerror[]};  ProcessOneComponentDesc: Tree.Scan = {    saveIndex: CARDINAL = gd.textIndex;    WITH t SELECT FROM      subtree =>        BEGIN cdNode: Tree.Index = index;        gd.textIndex ¬ tb[cdNode].info;	SELECT tb[cdNode].name FROM          allComp          => ProcessAllComp[cdNode];          compItems        => ProcessCompItems[cdNode];          exceptItems      => ProcessExceptItems[cdNode];          exceptPacks      => ProcessExceptPacks[cdNode];          itemsExceptPacks => ProcessItemsExceptPacks[cdNode];          exceptPacksItems => ProcessExceptPacksItems[cdNode];          mainOfPL         => ProcessMainOfPL[cdNode];          evOfPL           => ProcessEvOfPL[cdNode];          catchOfPL        => ProcessCatchOfPL[cdNode];          ENDCASE => SEerror[];         tb[cdNode].cp  ¬ currentCpNode;        tb[cdNode].seg ¬ currentSegNode;        END;      ENDCASE => SEerror[];    gd.textIndex ¬ saveIndex};  ProcessAllComp: PROC [cdNode: Tree.Index] = {    -- ComponentDesc ::= Component    tb[cdNode].son[1] ¬ LookupComponent[tb[cdNode].son[1]]};  ProcessCompItems: PROC [cdNode: Tree.Index] = {    -- ComponentDesc ::= Component [ItemList]    tb[cdNode].son[1] ¬ LookupComponent[tb[cdNode].son[1]];    WITH tb[cdNode].son[1] SELECT FROM      symbol =>         BEGIN componentSE: STIndex = index;	WITH stb[componentSE] SELECT FROM          config =>             IF cNode # SourceBcd.NullCTreeIndex THEN              tb[cdNode].son[2] ¬ LookupComponentItems[cNode, tb[cdNode].son[2]];          module =>             IF mNode # SourceBcd.NullCTreeIndex AND mti # BcdDefs.MTNull THEN              IF SourceBcd.IsTableCompiled[mti] THEN 		Error.TableCompModuleNotIncAsUnit[error, mti];          ENDCASE;        END;      ENDCASE => SEerror[]};  ProcessExceptItems: PROC [cdNode: Tree.Index] = {    -- ComponentDesc ::= Component EXCEPT [ItemList]    tb[cdNode].son[1] ¬ LookupComponent[tb[cdNode].son[1]];    WITH tb[cdNode].son[1] SELECT FROM      symbol =>         BEGIN componentSE: STIndex = index;	WITH stb[componentSE] SELECT FROM          config =>             IF cNode # SourceBcd.NullCTreeIndex THEN              tb[cdNode].son[2] ¬ LookupComponentItems[cNode, tb[cdNode].son[2]];          module =>             IF mNode # SourceBcd.NullCTreeIndex AND mti # BcdDefs.MTNull THEN              IF SourceBcd.IsTableCompiled[mti] THEN 		Error.TableCompModuleNotIncAsUnit[error, mti];          ENDCASE;        END;      ENDCASE => SEerror[]};  ProcessExceptPacks: PROC [cdNode: Tree.Index] = {    -- ComponentDesc ::= Component EXCEPT PackList    tb[cdNode].son[1] ¬ LookupComponent[tb[cdNode].son[1]];    WITH tb[cdNode].son[1] SELECT FROM      symbol =>         BEGIN componentSE: STIndex = index;	WITH stb[componentSE] SELECT FROM          module =>             IF mNode # SourceBcd.NullCTreeIndex AND mti # BcdDefs.MTNull THEN              IF SourceBcd.IsTableCompiled[mti] THEN 		Error.TableCompModuleNotIncAsUnit[error, mti];          ENDCASE;        END;      ENDCASE => SEerror[];    tb[cdNode].son[2] ¬ LookupCodePacks[tb[cdNode].son[2]]};  ProcessItemsExceptPacks: PROC [cdNode: Tree.Index] = {    -- ComponentDesc ::= Component [ItemList] EXCEPT PackList    tb[cdNode].son[1] ¬ LookupComponent[tb[cdNode].son[1]];    WITH tb[cdNode].son[1] SELECT FROM      symbol =>         BEGIN componentSE: STIndex = index;	WITH stb[componentSE] SELECT FROM          module =>            Error.Error[	      error, "The component in this kind of component description must not be a module"L];           config =>  -- process ItemList             IF cNode # SourceBcd.NullCTreeIndex THEN              tb[cdNode].son[2] ¬ LookupComponentItems[cNode, tb[cdNode].son[2]];          ENDCASE;        END;      ENDCASE => SEerror[];    tb[cdNode].son[3] ¬ LookupCodePacks[tb[cdNode].son[3]]};  ProcessExceptPacksItems: PROC [cdNode: Tree.Index] = {    -- ComponentDesc ::= Component EXCEPT PackList, [ItemList]    tb[cdNode].son[1] ¬ LookupComponent[tb[cdNode].son[1]];    tb[cdNode].son[2] ¬ LookupCodePacks[tb[cdNode].son[2]];    WITH tb[cdNode].son[1] SELECT FROM      symbol =>         BEGIN componentSE: STIndex = index;	WITH stb[componentSE] SELECT FROM          config =>             IF cNode # SourceBcd.NullCTreeIndex THEN              tb[cdNode].son[3] ¬ LookupComponentItems[cNode, tb[cdNode].son[3]];          module =>             IF mNode # SourceBcd.NullCTreeIndex AND mti # BcdDefs.MTNull THEN              IF SourceBcd.IsTableCompiled[mti] THEN 		Error.TableCompModuleNotIncAsUnit[error, mti];          ENDCASE;        END;      ENDCASE => SEerror[]};  ProcessMainOfPL: PROC [cdNode: Tree.Index] = {    -- ComponentDesc ::= MAIN OF PackList    IF tb[currentCpNode].name = unnamedCodePack THEN Error.Error[      error, "A MAIN OF component description can not be used to specify an unnamed code pack"L];        DoMiscCodeCompDesc[cdNode]};  ProcessEvOfPL: PROC [cdNode: Tree.Index] = {    -- ComponentDesc ::= ENTRY VECTOR OF PackList    IF tb[currentCpNode].name = unnamedCodePack THEN Error.Error[      error, "An ENTRY VECTOR OF component description can not be used to specify an unnamed code pack"L];        DoMiscCodeCompDesc[cdNode]};  ProcessCatchOfPL: PROC [cdNode: Tree.Index] = {    -- ComponentDesc ::= CATCH CODE OF PackList    IF tb[currentCpNode].name = unnamedCodePack THEN Error.Error[      error, "A CATCH CODE OF component description can not be used to specify an unnamed code pack"L];        DoMiscCodeCompDesc[cdNode]};  DoMiscCodeCompDesc: PROC [cdNode: Tree.Index] = {    -- process MAIN/ENTRY VECTOR/CATCH CODE OF PackList    packList: Tree.Link = tb[cdNode].son[1];    IF TreeOps.ListLength[packList] = 1 THEN { -- name of current code seg?      idLink: Tree.Link ¬ TreeOps.ListHead[packList];      WITH idLink SELECT FROM        hash => {           id: SymTabDefs.HTIndex = index;          IF id = currentSegId THEN {	    segIdSE: STIndex ¬ NewSemanticEntry[];            stb[segIdSE] ¬ [	      hti: currentSegId, treeNode: currentSegNode, kind: segment[]];            tb[cdNode].son[1] ¬ Tree.Link[symbol[index: segIdSE]];            RETURN}};        ENDCASE => SEerror[]};    tb[cdNode].son[1] ¬ LookupCodePacks[packList]};  LookupComponent: PROC [compList: Tree.Link] RETURNS [seLink: Tree.Link] = {    componentSE: STIndex;    WITH compList SELECT FROM       subtree =>        BEGIN node: Tree.Index = index;         saveIndex: CARDINAL = gd.textIndex;        gd.textIndex ¬ tb[node].info;	IF tb[node].name # component THEN SEerror[];        componentSE ¬ FindComponent[prototype, node];        gd.textIndex ¬ saveIndex;        END;      ENDCASE => SEerror[];    RETURN[Tree.Link[symbol[componentSE]]]};  LookupComponentItems: PROC [  -- in a configuration      configNode: SourceBcd.CTreeIndex, itemList: Tree.Link]     RETURNS [itemSElist: Tree.Link] = {    LookupOneComponentItem: Tree.Map = {      itemSE: STIndex;      WITH t SELECT FROM        hash =>          BEGIN id: SymTabDefs.HTIndex = index;	  itemSE ¬ FindConfigItem[prototype, id, configNode];          END;         subtree => {          node: Tree.Index = index;  	  SELECT tb[node].name FROM	    main =>               Error.Error[error, "MAIN is not directly contained in a configuration"L];    	    ev =>               Error.Error[error, "ENTRY VECTOR is not directly contained in a configuration"L];    	    catch =>               Error.Error[error, "CATCH CODE is not directly contained in a configuration"L];    	    ENDCASE => SEerror[];	  itemSE ¬ NewSemanticEntry[];	  stb[itemSE] ¬ [	    hti: SymTabDefs.HTNull, treeNode: Tree.NullIndex, kind: unknown[]]};        ENDCASE => SEerror[];      RETURN[Tree.Link[symbol[itemSE]]]};      RETURN[TreeOps.UpdateList[itemList, LookupOneComponentItem]]};  LookupCodePacks: PROC [idList: Tree.Link] RETURNS [packList: Tree.Link] =    {RETURN[TreeOps.UpdateList[idList, LookupOneCodePack]]};  LookupOneCodePack: Tree.Map = {    newSE: STIndex ¬ NewSemanticEntry[];    cpNode: Tree.Index;    found: BOOLEAN;    WITH t SELECT FROM      hash =>        BEGIN cpId: SymTabDefs.HTIndex = index;        [found, cpNode] ¬ FindCodePack[cpId];        IF found THEN stb[newSE] ¬ [hti: cpId, treeNode: cpNode, kind: codePack[]]        ELSE          BEGIN          Error.ErrorHti[error, "is not a code pack in the current segment"L, cpId];          stb[newSE] ¬ [hti: cpId, treeNode: Tree.NullIndex, kind: unknown[]];          END;        RETURN[Tree.Link[symbol[newSE]]];        END;       ENDCASE => SEerror[]};  FindComponent: PROC [      kind: SourceBcd.ComponentKind, compNode: Tree.Index]       RETURNS [compSE: STIndex] = {    -- pass id stream (most qualified id first) to FindModuleOrConfig    component: SourceBcd.CTreeIndex;    idList: Tree.Link = tb[compNode].son[1];    idListLen: CARDINAL = TreeOps.ListLength[idList];    idListTail: Tree.Link = TreeOps.ListTail[idList];    currentIdNo: CARDINAL;    ResetIdStream: PROC = {currentIdNo ¬ idListLen};    FirstQualId: PROC RETURNS [id: SymTabDefs.HTIndex] =      BEGIN  -- returns the first (i.e. rightmost or most qualified) id      WITH idListTail SELECT FROM        hash => id ¬ index;        ENDCASE => SEerror[];      END;    NextQualId: PROC RETURNS [id: SymTabDefs.HTIndex] =      BEGIN  -- returns next qualifying configuration id      IF (currentIdNo ¬ currentIdNo-1) < 1 THEN RETURN [SymTabDefs.HTNull];      WITH idList SELECT FROM        subtree =>          BEGIN node: Tree.Index = index;          IF tb[node].name = list THEN             WITH tb[node].son[currentIdNo] SELECT FROM              hash => id ¬ index;              ENDCASE => SEerror[]          ELSE SEerror[];          END;        ENDCASE => SEerror[];      END;    IF idList = Tree.Null THEN SEerror[];    component ¬ SourceBcd.FindModuleOrConfig[      kind, ResetIdStream, FirstQualId, NextQualId];    compSE ¬ NewSemanticEntry[];    IF component = SourceBcd.NullCTreeIndex THEN       stb[compSE] ¬ [hti: FirstQualId[], treeNode: compNode, kind: unknown[]]    ELSE       WITH ctreeb[component].index SELECT FROM        config => stb[compSE] ¬ [          hti: FirstQualId[], treeNode: compNode,           kind: config[cti: cti, cNode: component]];        module => stb[compSE] ¬ [          hti: FirstQualId[], treeNode: compNode,           kind: module[mti: mti, mNode: component]];      ENDCASE;    RETURN[compSE]};  FindConfigItem: PROC [        kind: SourceBcd.ComponentKind,         id: SymTabDefs.HTIndex, configNode: SourceBcd.CTreeIndex]       RETURNS [itemSE: STIndex] = {    -- find the directly contained module or config "id" in configNode    item: SourceBcd.CTreeIndex;    itemSE ¬ NewSemanticEntry[];    item ¬ SourceBcd.LookupId[id, kind];    WHILE item # SourceBcd.NullCTreeIndex DO      IF ctreeb[item].father = configNode THEN EXIT;      IF kind = instance THEN  -- are there any alternatives? 	item ¬ ctreeb[item].instancePrev      ELSE         item ¬ ctreeb[item].prototypePrev;      ENDLOOP;    IF item = SourceBcd.NullCTreeIndex THEN       BEGIN      Error.ErrorHti[error, "is not a directly contained item"L, id];      stb[itemSE] ¬ [hti: id, treeNode: Tree.NullIndex, kind: unknown[]]      END    ELSE       WITH ctreeb[item].index SELECT FROM        config => stb[itemSE] ¬ [          hti: id, treeNode: Tree.NullIndex, kind: config[cti: cti, cNode: item]];        module => stb[itemSE] ¬ [          hti: id, treeNode: Tree.NullIndex, kind: module[mti: mti, mNode: item]];      ENDCASE;    RETURN[itemSE]}; -- ********************** Process a frame pack **********************  currentFpNode: Tree.Index;  ProcessOneFramePack: PROC [fpNode: Tree.Index] = {    saveIndex: CARDINAL = gd.textIndex;    gd.textIndex ¬ tb[fpNode].info;    currentFpNode ¬ fpNode;    TreeOps.ScanList[tb[fpNode].son[2], ProcessOneFpCompDesc];    gd.textIndex ¬ saveIndex};  ProcessOneFpCompDesc: Tree.Scan = {    saveIndex: CARDINAL = gd.textIndex;    WITH t SELECT FROM      subtree =>        BEGIN cdNode: Tree.Index = index;        gd.textIndex ¬ tb[cdNode].info;	SELECT tb[cdNode].name FROM          allComp   => AllFramesOfOneComponent[cdNode];          compItems => FramesOfComponentItems[cdNode];          ENDCASE => Error.Error[            error, "Invalid component description for a frame pack"L];         END;      ENDCASE => SEerror[];    gd.textIndex ¬ saveIndex};  AllFramesOfOneComponent: PROC [cdNode: Tree.Index] = {    -- ComponentDesc ::= Component  (all global frames of component)    tb[cdNode].son[1] ¬ LookupFpComponent[tb[cdNode].son[1]]};  FramesOfComponentItems: PROC [cdNode: Tree.Index] = {    -- ComponentDesc ::= Component [ItemList]  (frames of component's items)    componentSE: STIndex;    WITH tb[cdNode].son[1] SELECT FROM    -- process frame pack component      subtree =>        BEGIN node: Tree.Index = index;         saveIndex: CARDINAL = gd.textIndex;        gd.textIndex ¬ tb[node].info;	IF tb[node].name # component THEN SEerror[];        componentSE ¬ FindComponent[instance, node];        tb[cdNode].son[1] ¬ Tree.Link[symbol[componentSE]];        WITH stb[componentSE] SELECT FROM          config =>             IF cNode # SourceBcd.NullCTreeIndex THEN              tb[cdNode].son[2] ¬ LookupFpComponentItems[	          cNode, tb[cdNode].son[2]];          module => Error.Error[	      error, "A component description with an itemlist in a frame pack must name a configuration"L];            ENDCASE;        gd.textIndex ¬ saveIndex;        END;      ENDCASE => SEerror[]};  LookupFpComponent: PROC [compList: Tree.Link] RETURNS [seLink: Tree.Link] = {    componentSE: STIndex;    MarkOneFramePlaced: PROC [mti: BcdDefs.MTIndex] RETURNS [stop: BOOLEAN] = {      MarkFramePlaced[mti, currentFpNode];  RETURN[FALSE]};    WITH compList SELECT FROM       -- process frame pack component      subtree =>        BEGIN node: Tree.Index = index;         saveIndex: CARDINAL = gd.textIndex;        gd.textIndex ¬ tb[node].info;	IF tb[node].name # component THEN SEerror[];        componentSE ¬ FindComponent[instance, node];        WITH stb[componentSE] SELECT FROM          module =>            MarkFramePlaced[mti, currentFpNode];           config =>	    SourceBcd.EnumerateModulesInConfig[	      instance, cNode, MarkOneFramePlaced];          ENDCASE;        gd.textIndex ¬ saveIndex;        END;      ENDCASE => SEerror[];    RETURN[Tree.Link[symbol[componentSE]]]};  LookupFpComponentItems: PROC [      compNode: SourceBcd.CTreeIndex, itemList: Tree.Link]     RETURNS [itemSElist: Tree.Link] = {    LookupOneFpComponentItem: Tree.Map =      BEGIN      itemSE: STIndex ¬ NewSemanticEntry[];      MarkOneFramePlaced: PROC [mti: BcdDefs.MTIndex] RETURNS [stop: BOOLEAN] =        {MarkFramePlaced[mti, currentFpNode];  RETURN[FALSE]};      WITH t SELECT FROM        hash =>          BEGIN id: SymTabDefs.HTIndex = index;	  itemSE ¬ FindConfigItem[instance, id, compNode];          WITH stb[itemSE] SELECT FROM            module =>              MarkFramePlaced[mti, currentFpNode];             config =>  	      SourceBcd.EnumerateModulesInConfig[  	        instance, cNode, MarkOneFramePlaced];            ENDCASE;          END;         subtree =>          BEGIN node: Tree.Index = index;  	  SELECT tb[node].name FROM	    main =>               Error.Error[error, "MAIN procedures do not have global frames"L];    	    ev =>               Error.Error[error, "Entry vectors do not have global frames"L];    	    catch =>               Error.Error[error, "Catch code does not have a global frame"L];                ENDCASE => SEerror[];	  stb[itemSE] ¬ [hti: SymTabDefs.HTNull, treeNode: Tree.NullIndex, kind: unknown[]];          END;        ENDCASE => SEerror[];        RETURN[Tree.Link[symbol[itemSE]]];      END;      RETURN[TreeOps.UpdateList[itemList, LookupOneFpComponentItem]]}; -- ********************** Process merged code segments **********************  ProcessMergeSegments: PROC = {    LookForMergeSeg: Tree.Scan =      BEGIN      WITH t SELECT FROM        subtree =>          BEGIN node: Tree.Index = index;          SELECT tb[node].name FROM            merge => ProcessOneMergeSeg[node];            ENDCASE;          END;        ENDCASE => SEerror[];      END;    TreeOps.ScanList[Tree.root, LookForMergeSeg]};  ProcessOneMergeSeg: PROC [mergeNode: Tree.Index] = {    saveIndex: CARDINAL = gd.textIndex;    gd.textIndex ¬ tb[mergeNode].info;    ProcessIdsOfMergedOldSegs[mergeNode];    RecordCodePackIds[mergeNode];    ProcessMergeCodePacks[mergeNode];    VerifyAllOldCodePacksPlaced[mergeNode];    ReleaseCodePackIds[];    gd.textIndex ¬ saveIndex};  mergedOldSegIdList: Tree.Link;  ProcessIdsOfMergedOldSegs: PROC [mergeNode: Tree.Index] = {    mergedOldSegIdList ¬ tb[mergeNode].son[3] ¬ TreeOps.UpdateList[      tb[mergeNode].son[3], ProcessIdOfOneOldMergedSeg]};  ProcessIdOfOneOldMergedSeg: Tree.Map = {    oldSegSE: STIndex ¬ NewSemanticEntry[];    found: BOOLEAN;    oldSegNode: Tree.Index;    WITH t SELECT FROM      hash =>        BEGIN oldSegId: SymTabDefs.HTIndex = index;	[found, oldSegNode] ¬ FindSeg[oldSegId];	IF found THEN  	  BEGIN	  stb[oldSegSE] ¬ [	    hti: oldSegId, treeNode: oldSegNode, kind: segment[]];	  tb[oldSegNode].superceded ¬ TRUE;  -- mark old segment superceded	  TreeOps.ScanList[tb[oldSegNode].son[2], MarkOldCodePackSuperceded];	  END	ELSE 	  BEGIN	  Error.ErrorHti[error, "is not a known segment"L, oldSegId];	  stb[oldSegSE] ¬ [	    hti: oldSegId, treeNode: Tree.NullIndex, kind: unknown[]];	  END;	RETURN[Tree.Link[symbol[oldSegSE]]];        END;      ENDCASE => SEerror[]};  MarkOldCodePackSuperceded: Tree.Scan = {    WITH t SELECT FROM      subtree =>        BEGIN cpNode: Tree.Index = index;	SELECT tb[cpNode].name FROM	  codePack, unnamedCodePack, discardCodePack =>	    BEGIN	    tb[cpNode].superceded ¬ TRUE;   -- mark old code pack superceded and	    tb[cpNode].placed ¬ FALSE;  -- not yet placed in new merge segment            END;          ENDCASE => SEerror[];        END;      ENDCASE => SEerror[]};  ProcessMergeCodePacks: PROC [mergeNode: Tree.Index] =    {TreeOps.ScanList[tb[mergeNode].son[2], ProcessOneMergeCodePack]};      oldDiscardCodePackFound: BOOLEAN;  ProcessOneMergeCodePack: Tree.Scan = {    WITH t SELECT FROM      subtree =>        BEGIN cpNode: Tree.Index = index;        IF tb[cpNode].exceptMAIN THEN 	  Error.Error[	    error, "A code pack in a merged segment can not contain an EXCEPT [MAIN] clause"L];	IF tb[cpNode].exceptEV THEN 	  Error.Error[	    error, "A code pack in a merged segment can not contain an EXCEPT [ENTRY VECTOR] clause"L];	IF tb[cpNode].exceptCatch THEN       	  Error.Error[	    error, "A code pack in a merged segment can not contain an EXCEPT [CATCH CODE] clause"L];        oldDiscardCodePackFound ¬ FALSE;        tb[cpNode].son[2] ¬ TreeOps.UpdateList[	  tb[cpNode].son[2], ProcessOneMergeCompDesc];	IF oldDiscardCodePackFound	AND tb[cpNode].name = unnamedCodePack	AND (TreeOps.ListLength[tb[cpNode].son[2]] = 1) THEN  	  tb[cpNode].name ¬ discardCodePack;  -- propogate DISCARD attribute        END;      ENDCASE => SEerror[]};  ProcessOneMergeCompDesc: Tree.Map = {    saveIndex: CARDINAL = gd.textIndex;    oldCpId: SymTabDefs.HTIndex;    oldCpNode: Tree.Index;    oldCpSE: STIndex ¬ NewSemanticEntry[];    WITH t SELECT FROM      subtree =>        BEGIN cdNode: Tree.Index = index;        gd.textIndex ¬ tb[cdNode].info;	SELECT tb[cdNode].name FROM  	  allComp =>	    BEGIN            [oldCpId, oldCpNode] ¬ ProcessMergeComponent[tb[cdNode].son[1]];            stb[oldCpSE] ¬ [hti: oldCpId, treeNode: oldCpNode, kind: codePack[]];	    IF tb[oldCpNode].name = discardCodePack THEN	      oldDiscardCodePackFound ¬ TRUE;	    END;          ENDCASE => 	    BEGIN	    Error.Error[error, "A component description in a merged code segment may only be a reference to an old code pack"L];	    stb[oldCpSE] ¬ [	      hti: SymTabDefs.HTNull, treeNode: Tree.NullIndex, kind: unknown[]];	    END;         END;      ENDCASE => SEerror[];    gd.textIndex ¬ saveIndex;    RETURN[Tree.Link[symbol[oldCpSE]]]};  ProcessMergeComponent: PROC [      mergeCompLink: Tree.Link]       RETURNS [oldCpId: SymTabDefs.HTIndex, oldCpNode: Tree.Index] = {    oldCpIdLink: Tree.Link;    WITH mergeCompLink SELECT FROM      subtree =>	BEGIN compNode: Tree.Index = index;	saveIndex: CARDINAL = gd.textIndex;	gd.textIndex ¬ tb[compNode].info;	IF tb[compNode].name # component THEN SEerror[];        oldCpIdLink ¬ TreeOps.ListTail[tb[compNode].son[1]];        WITH oldCpIdLink SELECT FROM          hash => oldCpId ¬ index;          ENDCASE => SEerror[];        oldCpNode ¬ FindOldCodePackNode[tb[compNode].son[1]];        IF oldCpNode # Tree.NullIndex THEN          IF tb[oldCpNode].placed THEN	    Error.ErrorHti[	      error, "was already placed in a merged segment"L, oldCpId]          ELSE tb[oldCpNode].placed ¬ TRUE;  -- mark placed in merged segment        gd.textIndex ¬ saveIndex;        END;      ENDCASE => SEerror[]};  FindOldCodePackNode: PROC [      oldCpIdList: Tree.Link] RETURNS [oldCpNode: Tree.Index] = {    SELECT TreeOps.ListLength[oldCpIdList] FROM      = 1 =>  -- oldCodePackId	RETURN[FindUnQualOldCodePackNode[oldCpIdList]];      = 2 =>  -- oldSegmentId.oldCodePackId	RETURN[FindQualOldCodePackNode[oldCpIdList]];      ENDCASE =>	BEGIN        Error.Error[	  error, "A component description for a merged code segment must be an optionally qualified old code pack name"L];        RETURN[Tree.NullIndex];        END};  FindUnQualOldCodePackNode: PROC [      oldCpIdList: Tree.Link] RETURNS [oldCpNode: Tree.Index] = {    oldCpIdLink: Tree.Link;    oldCpId: SymTabDefs.HTIndex;    oldCpFound: BOOLEAN;    LookForOldCpIdInOldSeg: Tree.Test =      BEGIN      oldSegNode: Tree.Index;      WITH t SELECT FROM        symbol =>          BEGIN oldSegSE: STIndex = index;	  WITH stb[oldSegSE] SELECT FROM	    segment =>	      BEGIN oldSegNode ¬ treeNode;	      [oldCpFound, oldCpNode] ¬ LookupCpInOldSeg[oldCpId, oldSegNode];	      END;	    ENDCASE => SEerror[];          END;        ENDCASE => SEerror[];      RETURN[oldCpFound];  -- continue search until found      END;    oldCpIdLink ¬ TreeOps.ListTail[oldCpIdList];    WITH oldCpIdLink SELECT FROM      hash => oldCpId ¬ index;      ENDCASE => SEerror[];    oldCpFound ¬ FALSE;  oldCpNode ¬ Tree.NullIndex;    TreeOps.SearchList[mergedOldSegIdList, LookForOldCpIdInOldSeg];    IF ~oldCpFound THEN      BEGIN      Error.ErrorHti[error, "is not a known code pack"L, oldCpId];      RETURN[Tree.NullIndex];      END};  FindQualOldCodePackNode: PROC [      oldCpIdList: Tree.Link] RETURNS [oldCpNode: Tree.Index] = {    oldSegIdLink, oldCpIdLink: Tree.Link;    oldSegId, oldCpId: SymTabDefs.HTIndex;    oldSegNode: Tree.Index;    found: BOOLEAN;    oldSegIdLink ¬ TreeOps.ListHead[oldCpIdList];    WITH oldSegIdLink SELECT FROM      hash => oldSegId ¬ index;      ENDCASE => SEerror[];    oldCpIdLink ¬ TreeOps.ListTail[oldCpIdList];    WITH oldCpIdLink SELECT FROM      hash => oldCpId ¬ index;      ENDCASE => SEerror[];    [found, oldSegNode] ¬ FindSeg[oldSegId];    IF ~found THEN      BEGIN      Error.ErrorHti[error, "is not a known segment"L, oldSegId];      RETURN[Tree.NullIndex];      END;    VerifyInMergedSegIdList[oldSegId];    [found, oldCpNode] ¬ LookupCpInOldSeg[oldCpId, oldSegNode];    IF ~found THEN      BEGIN      Error.ErrorHti[error, "is not a known code pack"L, oldCpId];      RETURN[Tree.NullIndex];      END};  VerifyInMergedSegIdList: PROC [oldSegId: SymTabDefs.HTIndex] = {    inMergedSegIdList: BOOLEAN;    LookForOldSegId: Tree.Test =      BEGIN      WITH t SELECT FROM        symbol =>          BEGIN oldSegSE: STIndex = index;	  WITH stb[oldSegSE] SELECT FROM	    segment => IF hti = oldSegId THEN inMergedSegIdList ¬ TRUE;	    ENDCASE;          END;        ENDCASE => SEerror[];      RETURN[inMergedSegIdList];  -- continue search until found      END;    inMergedSegIdList ¬ FALSE;    TreeOps.SearchList[mergedOldSegIdList, LookForOldSegId];    IF ~inMergedSegIdList THEN      Error.ErrorHti[error, "is not a segment being merged"L, oldSegId]};  LookupCpInOldSeg: PROC [      oldCpId: SymTabDefs.HTIndex, oldSegNode: Tree.Index]       RETURNS [found: BOOLEAN, oldCpNode: Tree.Index] = {    LookForOldCpId: Tree.Test =      BEGIN      WITH t SELECT FROM        subtree =>          BEGIN cpNode: Tree.Index = index;	  WITH tb[cpNode].son[1] SELECT FROM	    hash =>	      IF index = oldCpId THEN {found ¬ TRUE;  oldCpNode ¬ cpNode};	    ENDCASE => SEerror[];          END;        ENDCASE => SEerror[];      RETURN[found];  -- continue search until found      END;    found ¬ FALSE;  oldCpNode ¬ Tree.NullIndex;    TreeOps.SearchList[tb[oldSegNode].son[2], LookForOldCpId]};  VerifyAllOldCodePacksPlaced: PROC [mergeNode: Tree.Index] = {    saveIndex: CARDINAL = gd.textIndex;    gd.textIndex ¬ tb[mergeNode].info;    TreeOps.ScanList[mergedOldSegIdList, VerifyOneOldSegsCodePacksPlaced];    gd.textIndex ¬ saveIndex};  VerifyOneOldSegsCodePacksPlaced: Tree.Scan = {    oldSegNode: Tree.Index;    WITH t SELECT FROM      symbol =>        BEGIN oldSegSE: STIndex = index;	WITH stb[oldSegSE] SELECT FROM	  segment =>	    BEGIN oldSegNode ¬ treeNode;	    TreeOps.ScanList[tb[oldSegNode].son[2], VerifyOneOldCodePackPlaced];	    END;          ENDCASE;        END;      ENDCASE => SEerror[]};  VerifyOneOldCodePackPlaced: Tree.Scan = {    WITH t SELECT FROM      subtree =>        BEGIN oldCpNode: Tree.Index = index;	SELECT tb[oldCpNode].name FROM	  codePack, unnamedCodePack, discardCodePack =>	    IF ~tb[oldCpNode].placed THEN -- wasn't placed in new merge segment	      BEGIN	      WITH tb[oldCpNode].son[1] SELECT FROM		hash => 		  BEGIN oldCpId: SymTabDefs.HTIndex ¬ index; 		  Error.ErrorHti[		    error, "was not placed in the merged segment"L, oldCpId];		  END;		ENDCASE => SEerror[];	      END;          ENDCASE => SEerror[];        END;      ENDCASE => SEerror[]}; -- ********************** Process merged frame packs **********************  ProcessMergeFramePacks: PROC = {    LookForMergeFP: Tree.Scan =      BEGIN      WITH t SELECT FROM        subtree =>          BEGIN node: Tree.Index = index;          SELECT tb[node].name FROM            mergeFP => ProcessOneMergeFP[node];            ENDCASE;          END;        ENDCASE => SEerror[];      END;    TreeOps.ScanList[Tree.root, LookForMergeFP]};  ProcessOneMergeFP: PROC [mergeFPNode: Tree.Index] = {    saveIndex: CARDINAL = gd.textIndex;    gd.textIndex ¬ tb[mergeFPNode].info;    ProcessIdsOfMergedOldFPs[mergeFPNode];    gd.textIndex ¬ saveIndex};  mergedOldFPIdList: Tree.Link;  ProcessIdsOfMergedOldFPs: PROC [mergeFPNode: Tree.Index] = {    mergedOldFPIdList ¬ tb[mergeFPNode].son[2] ¬ TreeOps.UpdateList[      tb[mergeFPNode].son[2], ProcessIdOfOneOldMergedFP]};  ProcessIdOfOneOldMergedFP: Tree.Map = {    oldFPSE: STIndex ¬ NewSemanticEntry[];    found: BOOLEAN;    oldFPNode: Tree.Index;    WITH t SELECT FROM      hash =>        BEGIN oldFPId: SymTabDefs.HTIndex = index;	[found, oldFPNode] ¬ FindFramePack[oldFPId];	IF found THEN  	  BEGIN	  stb[oldFPSE] ¬ [	    hti: oldFPId, treeNode: oldFPNode, kind: framePack[]];	  tb[oldFPNode].superceded ¬ TRUE;  -- mark old frame pack superceded	  END	ELSE 	  BEGIN	  Error.ErrorHti[error, "is not a known frame pack"L, oldFPId];	  stb[oldFPSE] ¬ [	    hti: oldFPId, treeNode: Tree.NullIndex, kind: unknown[]];	  END;	RETURN[Tree.Link[symbol[oldFPSE]]];        END;      ENDCASE => SEerror[]};  END.
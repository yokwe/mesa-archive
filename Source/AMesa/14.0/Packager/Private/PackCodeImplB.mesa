-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- File PackCodeImplB.mesa-- Last edited by Sweet on 12-Aug-83 16:06:37-- Last edited by Lewis on  5-Jan-82 11:06:51DIRECTORY  Alloc USING [Handle, Notifier, Words],  BcdDefs,  BcdOps USING [    CTHandle, EXPHandle, IMPHandle, MTHandle, NameString, NTHandle,    ProcessConfigs, ProcessExports, ProcessImports, ProcessModules, ProcessNames],  BcdUtilDefs,  Error USING [ErrorName],  PackagerDefs USING [packctreetype, globalData, GlobalData],  PackCode,  PackEnviron USING [Copy],  SourceBcd USING [bcdBases, bcdHeader],  Table USING [Base, OrderedIndex];  PackCodeImplB: PROGRAM   IMPORTS     Alloc, BcdOps, BcdUtilDefs, Error, PackagerDefs, PackCode,    PackEnviron, SourceBcd   EXPORTS PackCode =  BEGIN OPEN PackCode;    gd: PackagerDefs.GlobalData;  table: Alloc.Handle ¬ NIL;  spb, sgb, fpb, ctreeb: Table.Base;  itb, etb, ctb, mtb, ntb: Table.Base;  enb: Table.Base;  ssb: BcdOps.NameString;  NotifyB: PUBLIC Alloc.Notifier =    BEGIN    ctreeb ¬ base[PackagerDefs.packctreetype];    sgb    ¬ base[BcdDefs.sgtype];    spb    ¬ base[BcdDefs.sptype];    fpb    ¬ base[BcdDefs.fptype];    ssb    ¬ base[BcdDefs.sstype];    itb    ¬ base[BcdDefs.imptype];    etb    ¬ base[BcdDefs.exptype];    ctb    ¬ base[BcdDefs.cttype];    mtb    ¬ base[BcdDefs.mttype];    ntb    ¬ base[BcdDefs.nttype];    enb    ¬ base[BcdDefs.entype];    END;      RemapOldBcd: PUBLIC PROC =    BEGIN    NullIndex: Table.OrderedIndex = LOOPHOLE[0];    gd ¬ PackagerDefs.globalData;    table ¬ gd.ownTable;    BcdUtilDefs.Init[ownTable: gd.ownTable];    gd.sourceFti ¬ BcdUtilDefs.EnterFile[gd.sourceBcdName];    BcdUtilDefs.SetFileVersion[gd.sourceFti, gd.sourceBcdVersion];    gd.packFti ¬ BcdUtilDefs.EnterFile[gd.packName];    BcdUtilDefs.SetFileVersion[gd.packFti, gd.packVersion];    IF table.Words[      table: BcdDefs.imptype,       size: LOOPHOLE[SourceBcd.bcdHeader.impLimit]] # NullIndex THEN       SIGNAL PackError[NonZeroBase];    PackEnviron.Copy[      from: SourceBcd.bcdBases.itb,       nwords: LOOPHOLE[SourceBcd.bcdHeader.impLimit],      to: itb];    IF table.Words[      table: BcdDefs.exptype,        size: LOOPHOLE[SourceBcd.bcdHeader.expLimit]] # NullIndex THEN        SIGNAL PackError[NonZeroBase];    PackEnviron.Copy[      from: SourceBcd.bcdBases.etb,       nwords: LOOPHOLE[SourceBcd.bcdHeader.expLimit],      to: etb];    IF table.Words[      table: BcdDefs.cttype,        size: LOOPHOLE[SourceBcd.bcdHeader.ctLimit]] # NullIndex THEN        SIGNAL PackError[NonZeroBase];    PackEnviron.Copy[      from: SourceBcd.bcdBases.ctb,       nwords: LOOPHOLE[SourceBcd.bcdHeader.ctLimit],      to: ctb];    IF table.Words[      table: BcdDefs.mttype,        size: LOOPHOLE[SourceBcd.bcdHeader.mtLimit]] # NullIndex THEN        SIGNAL PackError[NonZeroBase];    PackEnviron.Copy[      from: SourceBcd.bcdBases.mtb,       nwords: LOOPHOLE[SourceBcd.bcdHeader.mtLimit],      to: mtb];    IF table.Words[      table: BcdDefs.nttype,        size: LOOPHOLE[SourceBcd.bcdHeader.ntLimit]] # NullIndex THEN        SIGNAL PackError[NonZeroBase];    PackEnviron.Copy[      from: SourceBcd.bcdBases.ntb,       nwords: LOOPHOLE[SourceBcd.bcdHeader.ntLimit],      to: ntb];    IF table.Words[      table: BcdDefs.entype,        size: LOOPHOLE[SourceBcd.bcdHeader.enLimit]] # NullIndex THEN        SIGNAL PackError[NonZeroBase];    PackEnviron.Copy[      from: SourceBcd.bcdBases.enb,       nwords: LOOPHOLE[SourceBcd.bcdHeader.enLimit],      to: enb];    [] ¬ BcdOps.ProcessImports[SourceBcd.bcdHeader, RemapImports];    [] ¬ BcdOps.ProcessExports[SourceBcd.bcdHeader, RemapExports];    [] ¬ BcdOps.ProcessConfigs[SourceBcd.bcdHeader, RemapConfigs];    [] ¬ BcdOps.ProcessModules[SourceBcd.bcdHeader, RemapModules];    [] ¬ BcdOps.ProcessNames[SourceBcd.bcdHeader, RemapInstances];    END;      RemapInstances: PROC [nth: BcdOps.NTHandle, nti: BcdDefs.NTIndex]       RETURNS [BOOLEAN] =    BEGIN OPEN nte: ntb[nti];    nte.name ¬ BcdUtilDefs.MapName[SourceBcd.bcdBases, nth.name];    RETURN [FALSE];    END;      MapFile: PROC [fti: BcdDefs.FTIndex] RETURNS [BcdDefs.FTIndex] =    BEGIN    SELECT fti FROM      BcdDefs.FTSelf => RETURN[gd.sourceFti];      BcdDefs.FTNull => RETURN[fti];      ENDCASE => RETURN[BcdUtilDefs.MergeFile[SourceBcd.bcdBases, fti]];    END;      RemapImports: PROC [imph: BcdOps.IMPHandle, impi: BcdDefs.IMPIndex]      RETURNS [BOOLEAN] =    BEGIN OPEN impe: itb[impi];    impe.name ¬ BcdUtilDefs.MapName[SourceBcd.bcdBases, imph.name];    impe.file ¬ MapFile[imph.file];    RETURN [FALSE]    END;      RemapExports: PROC [exph: BcdOps.EXPHandle, expi: BcdDefs.EXPIndex]      RETURNS [BOOLEAN] =    BEGIN OPEN expe: etb[expi];    expe.name ¬ BcdUtilDefs.MapName[SourceBcd.bcdBases, exph.name];    expe.file ¬ MapFile[exph.file];    RETURN [FALSE]    END;      RemapConfigs: PROC [cth: BcdOps.CTHandle, cti: BcdDefs.CTIndex]      RETURNS [BOOLEAN] =    BEGIN OPEN cte: ctb[cti];    cte.name ¬ BcdUtilDefs.MapName[SourceBcd.bcdBases, cth.name];    cte.file ¬ IF cth.config = BcdDefs.CTNull THEN BcdDefs.FTSelf       ELSE MapFile[cth.file];    RETURN [FALSE]    END;      RemapModules: PROC [mth: BcdOps.MTHandle, mti: BcdDefs.MTIndex]      RETURNS [BOOLEAN] =    BEGIN OPEN mte: mtb[mti];    sgr: BcdDefs.SGRecord ¬ SourceBcd.bcdBases.sgb[mth.sseg];    IF ~mth.packageable THEN      Error.ErrorName[error, "has already been packaged!"L, mth.name];    mte.name ¬ BcdUtilDefs.MapName[SourceBcd.bcdBases, mth.name];    mte.file ¬ MapFile[mth.file];    sgr.file ¬ MapFile[sgr.file];    mte.sseg ¬ BcdUtilDefs.EnterSegment[sgr];    mte.packageable ¬ FALSE;    -- mtb[mti].code will be fixed up later    RETURN [FALSE]    END;      END.    
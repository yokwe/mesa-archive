-- Copyright (C) 1981, 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- File PackScanner.mesa-- Satterthwaite	May 30, 1980  11:32 AM-- Schmidt		September 18, 1980  1:59 PM-- Lewis		22-Oct-81 15:54:04-- JGS			 5-Oct-82 17:12:28-- Sweet		18-Aug-83 15:04:42-- Daniels		27-Apr-84 17:33:32-- Wagner		 8-Oct-84  7:59:05-- Derived from Compiler>Scanner.MesaDIRECTORY  CharIO USING [CR, TAB, PutChar, PutNumber, PutString],  Environment USING [charsPerWord, wordsPerPage],  P1: FROM "PackParseDefs" USING [Token],  PackParseTable USING [    HashIndex, TSymbol, VocabHashEntry, TableRef, tokenID, TrueEndOfFile],  MSegment USING [FreePages, GetPages],  Stream: TYPE USING [    EndOfStream, GetBlock, GetChar, GetPosition, Handle, Position, SetPosition],  String USING [AppendString, SubStringDescriptor],  SymTabOps USING [EnterString];Scanner: PROGRAM    IMPORTS CharIO, MSegment, Stream, String, SymTabOps     EXPORTS P1 =  BEGIN  OPEN PackParseTable;  z: UNCOUNTED ZONE ¬ NIL;    hashTab: LONG POINTER TO ARRAY HashIndex OF VocabHashEntry;  scanTab: LONG POINTER TO ARRAY CHARACTER [40C..377C] OF TSymbol;  vocab: LONG STRING;  vocabIndex: LONG POINTER TO ARRAY TSymbol OF CARDINAL;  NUL: CHARACTER = 0C;  CR: CHARACTER = CharIO.CR;  ControlZ: CHARACTER = 32C;		-- Bravo escape char  stream: Stream.Handle;	-- the input stream  streamOrigin: Stream.Position;  errorStream: Stream.Handle;	-- the error stream  TextPages: CARDINAL = 6;  TextWords: CARDINAL = TextPages * Environment.wordsPerPage;  TextChars: CARDINAL = TextWords * Environment.charsPerWord;  tB: LONG POINTER TO PACKED ARRAY [0..TextChars) OF CHARACTER;  tI, tMax: [0..TextChars];  tOrigin, tLimit: CARDINAL;  tEnded: BOOLEAN;  FillBuffer: PROC = {    tOrigin ¬ tLimit;    IF tEnded THEN tMax ¬ 0    ELSE {      tMax ¬ stream.GetBlock[[LOOPHOLE[tB], 0, TextChars]].bytesTransferred;      IF tMax < TextChars THEN tEnded ¬ TRUE;      tLimit ¬ tOrigin + tMax};    IF tMax = 0 THEN {tB[0] ¬ NUL; tMax ¬ 1};    tI ¬ 0};  buffer: LONG STRING ¬ NIL;		-- token assembly area  iMax: CARDINAL;			-- iMax = buffer.maxlength  desc: String.SubStringDescriptor;	-- initial buffer segment  nTokens: CARDINAL;			-- token count  nErrors: CARDINAL;			-- lexical errors  BufferOverflow: ERROR = CODE;  ExpandBuffer: PROC = {    oldBuffer: LONG STRING ¬ buffer;    IF oldBuffer.length > 2000 THEN ERROR BufferOverflow;    buffer ¬ z.NEW[StringBody[2*oldBuffer.length]];    String.AppendString[buffer, oldBuffer];    iMax ¬ buffer.length ¬ buffer.maxlength;    z.FREE[@oldBuffer];    desc.base ¬ buffer};  char: CHARACTER;	-- current (most recently scanned) character  NextChar: PROC = {	-- also expanded inline within Atom    IF (tI¬tI+1) = tMax THEN FillBuffer[]; char ¬ tB[tI]};  Atom: PUBLIC PROC RETURNS [token: P1.Token] = {    OPEN token;    DO      WHILE char IN [NUL..' ] DO	SELECT char FROM	  ControlZ =>	    UNTIL char = CR	      DO	      IF (tI¬tI+1) = tMax THEN {	        IF tEnded THEN GO TO EndFile; FillBuffer[]};	      char ¬ tB[tI];	      ENDLOOP;	  NUL => {		-- ­@­@ is Tioga escape seq	    IF (tI¬tI+1) = tMax THEN {IF tEnded THEN GO TO EndFile; FillBuffer[]};	    char ¬ tB[tI];	    IF char = NUL THEN GO TO EndFile};	  ENDCASE => {	    IF (tI¬tI+1) = tMax THEN {	      IF tEnded THEN GO TO EndFile; FillBuffer[]};	    char ¬ tB[tI]};	ENDLOOP;      index ¬ tOrigin + tI;  value ¬ 0;            BEGIN      SELECT char FROM	'a, 'b, 'c, 'd, 'e, 'f, 'g, 'h, 'i, 'j, 'k, 'l, 'm,	'n, 'o, 'p, 'q, 'r, 's, 't, 'u, 'v, 'w, 'x, 'y, 'z  => {	  i: CARDINAL;	  i ¬ 0;	    DO	    buffer[i] ¬ char;	    IF (tI¬tI+1) = tMax THEN FillBuffer[];	    char ¬ tB[tI];	    SELECT char FROM	      IN ['a..'z], IN ['A..'Z], IN ['0..'9] =>		IF (i ¬ i+1) >= iMax THEN ExpandBuffer[];	      ENDCASE =>  EXIT;	    ENDLOOP;	  desc.length ¬ i+1;	  class ¬ tokenID;  value ¬ SymTabOps.EnterString[@desc];	  GO TO GotNext};	'A, 'B, 'C, 'D, 'E, 'F, 'G, 'H, 'I, 'J, 'K, 'L, 'M,	'N, 'O, 'P, 'Q, 'R, 'S, 'T, 'U, 'V, 'W, 'X, 'Y, 'Z  => {	  first, last: CARDINAL;	  uId: BOOLEAN;	  i, j: CARDINAL;	  h: HashIndex;	  s1, s2: CARDINAL;	  i ¬ 0;  uId ¬ TRUE;  first ¬ last ¬ char-0C;	    DO	    buffer[i] ¬ char;	    IF (tI¬tI+1) = tMax THEN FillBuffer[];	    char ¬ tB[tI];	    SELECT char FROM	      IN ['A..'Z] => {		last ¬ char-0C; IF (i ¬ i+1) >= iMax THEN ExpandBuffer[]};	      IN ['a..'z], IN ['0..'9] => {		uId ¬ FALSE; IF (i ¬ i+1) >= iMax THEN ExpandBuffer[]};	      ENDCASE =>  EXIT;	    ENDLOOP;	  i ¬ i+1;	  IF uId	    THEN {	      h ¬ ((first*128-first) + last) MOD LAST[HashIndex] + 1;	      WHILE (j ¬ hashTab[h].symbol) # 0 		DO		IF vocabIndex[j]-(s2¬vocabIndex[j-1]) = i		  THEN		    FOR s1 IN [0 .. i) 		      DO		      IF buffer[s1] # vocab[s2] THEN EXIT;		      s2 ¬ s2+1;		      REPEAT			FINISHED => {class ¬ j; GO TO GotNext};		      ENDLOOP;		IF (h ¬ hashTab[h].link) = 0 THEN EXIT;		ENDLOOP};	  desc.length ¬ i;	  class ¬ tokenID;  value ¬ SymTabOps.EnterString[@desc];	  GO TO GotNext};	',, ';, ':, '=, '., '[, '], '{, '}  => {	  class ¬ scanTab[char]; GO TO GetNext};	'- => {	  pChar: CHARACTER;	  NextChar[];	  IF char # '- THEN {class ¬ scanTab['-]; GO TO GotNext};	  char ¬ NUL;	    DO	    pChar ¬ char;	    IF (tI¬tI+1) = tMax THEN {IF tEnded THEN GO TO EndFile;  FillBuffer[]};	    char ¬ tB[tI];	    SELECT char FROM	      '- =>  IF pChar = '- THEN EXIT;	      CR =>  EXIT;	      ENDCASE;	    ENDLOOP;	  NextChar[]};	'< => {	  NextChar[];	  IF char = '< THEN GO TO ScanComment ELSE ScanError[char, index]};		253c => GO TO ScanComment;	    	ENDCASE => {	  class ¬ scanTab[char];	  IF class # 0 THEN  GO TO GetNext;	  NextChar[];	  ScanError[char, index]};            EXITS ScanComment => {	state: {plain, leftBrocket, rightBrocket} ¬ plain;	nest: CARDINAL ¬ 1;	DO	  IF (tI¬tI+1) = tMax THEN {	    IF tEnded THEN GO TO EndFile; FillBuffer[]};	  char ¬ tB[tI];	  SELECT char FROM	    '> => SELECT state FROM	      plain, leftBrocket => state ¬ rightBrocket;	      rightBrocket => {		state ¬ plain; nest ¬ nest - 1; IF nest = 0 THEN EXIT};	      ENDCASE;	    '< => SELECT state FROM	      plain, rightBrocket => state ¬ leftBrocket;	      leftBrocket => {state ¬ plain; nest ¬ nest + 1};	      ENDCASE;	    253c => {state ¬ plain; nest ¬ nest + 1};	    273c => {state ¬ plain; nest ¬ nest - 1; IF nest = 0 THEN EXIT};	    ENDCASE => state ¬ plain;	  ENDLOOP;	NextChar[]};      END;      REPEAT	GetNext => {IF (tI¬tI+1) = tMax THEN FillBuffer[]; char ¬ tB[tI]};	GotNext => NULL;	EndFile => {	  FillBuffer[];  char ¬ tB[tI];	  class ¬ TrueEndOfFile;  index ¬ tOrigin;  value ¬ 0};      ENDLOOP;    nTokens ¬ nTokens + 1;    RETURN}; -- initialization/finalization  ScanInit: PUBLIC PROC [    sourceStream, messageStream: Stream.Handle, table: PackParseTable.TableRef,    uz: UNCOUNTED ZONE] = {    z ¬ uz;    hashTab ¬ @table[table.scanTable.hashTab];    scanTab ¬ @table[table.scanTable.scanTab];    vocab ¬ LOOPHOLE[@table[table.scanTable.vocabBody], LONG STRING];    vocabIndex ¬ @table[table.scanTable.vocabIndex];    IF buffer = NIL THEN buffer ¬ z.NEW[StringBody[256]];    iMax ¬ buffer.length ¬ buffer.maxlength;    desc.base ¬ buffer;  desc.offset ¬ 0;    stream ¬ sourceStream;  errorStream ¬ messageStream;    streamOrigin ¬ stream.GetPosition[];    tB ¬ MSegment.GetPages[TextPages];    tOrigin ¬ tLimit ¬ 0;  tMax ¬ 0;  tEnded ¬ FALSE;    FillBuffer[];  char ¬ tB[tI];    nTokens ¬ nErrors ¬ 0};  ScanReset: PUBLIC PROC RETURNS [CARDINAL, CARDINAL] = {    MSegment.FreePages[tB];    IF buffer # NIL THEN z.FREE[@buffer];    RETURN [nTokens, nErrors]}; -- error handling  StreamIndex: TYPE = LONG CARDINAL;  NewLine: PROC = INLINE {CharIO.PutChar[errorStream, CR]};  PrintTextLine: PROC [origin: LONG CARDINAL] RETURNS [start: LONG CARDINAL] = {    OPEN CharIO;    lineIndex: LONG CARDINAL;    char: CHARACTER;    n: [1..100];    start ¬ lineIndex ¬ origin;    FOR n IN [1..100] UNTIL lineIndex = 0      DO      lineIndex ¬ lineIndex - 1;      stream.SetPosition[lineIndex];      IF stream.GetChar[] = CR THEN EXIT;      start ¬ lineIndex;      ENDLOOP;    stream.SetPosition[lineIndex];    FOR n IN [1..100] DO      char ¬ stream.GetChar[ ! Stream.EndOfStream => GOTO out];      SELECT char FROM	CR, ControlZ => EXIT;	ENDCASE => PutChar[errorStream, char];      REPEAT        out => NULL;      ENDLOOP;    NewLine[];  RETURN};  ResetScanIndex: PUBLIC PROC [index: CARDINAL] = {    page: CARDINAL;    IF index ~IN [tOrigin .. tLimit)      THEN {	page ¬ index/(Environment.wordsPerPage * Environment.charsPerWord);	tOrigin ¬ tLimit ¬ page*(Environment.wordsPerPage * Environment.charsPerWord);	tMax ¬ 0;  tEnded ¬ FALSE;	stream.SetPosition[streamOrigin + index];	FillBuffer[]};    tI ¬ index - tOrigin;    IF tI >= tMax THEN FillBuffer[];  char ¬ tB[tI]};  ScanError: PROC [code: {number, string, char, atom}, tokenIndex: CARDINAL] = {    nErrors ¬ nErrors + 1;    ErrorContext[      SELECT code FROM	number => "invalid number"L,	string => "string too long"L,	char => "invalid character"L,	atom => "invalid atom"L,	ENDCASE => NIL,      tokenIndex];    NewLine[]};  ErrorContext: PUBLIC PROC [message: STRING, tokenIndex: CARDINAL] = {    OPEN CharIO;    saveIndex: LONG CARDINAL = stream.GetPosition[];    origin: LONG CARDINAL = streamOrigin+tokenIndex;    char: CHARACTER;    stream.SetPosition[PrintTextLine[origin]];    UNTIL stream.GetPosition[] = origin DO      char ¬ stream.GetChar[ ! Stream.EndOfStream => GOTO out];      PutChar[errorStream, IF char = TAB THEN TAB ELSE ' ];      REPEAT        out => NULL;      ENDLOOP;    PutString[errorStream, "­ "L];  PutString[errorStream, message];    PutString[errorStream, " ["L];    PutNumber[errorStream, tokenIndex,	[base:10, zerofill:FALSE, unsigned:TRUE, columns:0]];    PutChar[errorStream, ']];   NewLine[];    stream.SetPosition[saveIndex]};  END.
-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- FileTableImpl.mesa  --  Last edited by Sweet on 18-Aug-83 11:40:43--  Last edited by Lewis on  6-Jan-82 17:56:02--  Last edited by JGS   on 23-Sep-82 17:18:46DIRECTORY  BcdDefs USING [BCD, FTIndex, FTRecord, FTSelf, NameRecord, VersionStamp],  Error USING [WrongFileVersion],  FileTable,  MFile USING [CopyFileHandle, Error, Handle, maxNameLength, ReadOnly, Release],  MSegment USING [Address, CopyIn, Create, Delete, Handle],  PackagerDefs USING [globalData, NullSourceIndex],  Runtime USING [GetCaller],  SourceBcd USING [bcdBases, bcdLimits, SubStringForName],  String USING [AppendString, AppendSubString, SubString, SubStringDescriptor],  SymTabDefs USING [HTIndex],  SymTabOps USING [EnterString];FileTableImpl: PROGRAM    IMPORTS      Error, MFile, MSegment, PackagerDefs, Runtime, SourceBcd,      String, SymTabOps    EXPORTS FileTable =  BEGIN  FTIndex: TYPE = BcdDefs.FTIndex;  SubStringDescriptor: TYPE = String.SubStringDescriptor;  SubString: TYPE = String.SubString;    UnknownFile: PUBLIC ERROR [fti: FTIndex] = CODE;  fileArray: LONG POINTER TO FileSequence ¬ NIL;  FileSequence: TYPE = RECORD [SEQUENCE length: CARDINAL OF MFile.Handle];    fileStampChecked: LONG POINTER TO BitSequence ¬ NIL;  BitSequence: TYPE = RECORD [PACKED SEQUENCE length: CARDINAL OF BOOLEAN];    headerSeg: MSegment.Handle ¬ NIL;  header: LONG POINTER TO BcdDefs.BCD ¬ NIL;  Build: PUBLIC PROC = {    OPEN BcdDefs;    numFiles: CARDINAL;    fileNameString: STRING ¬ [MFile.maxNameLength];    ftiName: SubString ¬ @ftiNameDesc;      ftiNameDesc: SubStringDescriptor;    saveIndex: CARDINAL = PackagerDefs.globalData.textIndex;    i: CARDINAL;    PackagerDefs.globalData.textIndex ¬ PackagerDefs.NullSourceIndex;    -- allocate file handle array    numFiles ¬ IndexForFti[SourceBcd.bcdLimits.ft];    fileArray ¬ PackagerDefs.globalData.zone.NEW[FileSequence[numFiles]];    fileStampChecked ¬ PackagerDefs.globalData.zone.NEW[BitSequence[numFiles]];    FOR i IN [0..numFiles) DO       fileArray[i] ¬ NIL;  fileStampChecked[i] ¬ FALSE;       ENDLOOP;    -- enter file names into symtab (if not already there) to speed file lookup    i ¬ 0;    FOR fti: FTIndex ¬ FIRST[FTIndex], fti+SIZE[FTRecord]    UNTIL fti = SourceBcd.bcdLimits.ft DO      SourceBcd.SubStringForName[ftiName, SourceBcd.bcdBases.ftb[fti].name];      [] ¬ SymTabOps.EnterString[ftiName];      fileNameString.length ¬ 0;      String.AppendSubString[fileNameString, ftiName];      FOR j: CARDINAL IN [0..fileNameString.length) DO        IF fileNameString[j] = '. THEN EXIT;	REPEAT FINISHED => String.AppendString[fileNameString, ".bcd"L];	ENDLOOP;      fileArray[i] ¬ NIL;      fileArray[i] ¬ MFile.ReadOnly[fileNameString, [] ! MFile.Error => CONTINUE];      i ¬ i + 1;      ENDLOOP;    -- create header segment for version checking    headerSeg ¬ MSegment.Create[      file: NIL, release: [], fileBase: 0, pages: 1];    header ¬ MSegment.Address[headerSeg];    PackagerDefs.globalData.textIndex ¬ saveIndex};  IndexForFti: PROC [fti: FTIndex] RETURNS [CARDINAL] = INLINE {    RETURN[ LOOPHOLE[fti,CARDINAL]/SIZE[BcdDefs.FTRecord] ]};      Destroy: PUBLIC PROC = {    IF fileArray # NIL THEN {      FOR i: CARDINAL IN [0..fileArray.length) DO        IF fileArray[i] # NIL THEN 	  MFile.Release[fileArray[i] ! MFile.Error => CONTINUE];        ENDLOOP;      PackagerDefs.globalData.zone.FREE[@fileArray]};    IF headerSeg # NIL THEN {      MSegment.Delete[headerSeg];  headerSeg ¬ NIL;      header ¬ NIL}};        HandleForFile: PUBLIC PROC [fti: FTIndex] RETURNS [file: MFile.Handle] = {    -- we only pass out copies of the original file handles    f, copy: MFile.Handle;    index: CARDINAL;    IF fti = BcdDefs.FTSelf THEN f ¬ PackagerDefs.globalData.sourceBcdFile    ELSE {      index ¬ IndexForFti[fti];      IF index >= fileArray.length OR (f ¬ fileArray[index]) = NIL THEN         ERROR UnknownFile[fti];      IF ~fileStampChecked[index] THEN {        MSegment.CopyIn[segment: headerSeg, file: f, fileBase: 0, count: 1];        IF header.version # SourceBcd.bcdBases.ftb[fti].version THEN          Error.WrongFileVersion[	    class: error, fti: fti, 	    requiredVersion: SourceBcd.bcdBases.ftb[fti].version,	    actualVersion: header.version];        fileStampChecked[index] ¬ TRUE}};    copy ¬ MFile.CopyFileHandle[      file: f,       release: [proc: NIL, clientInstanceData: NoteCaller[Runtime.GetCaller[]]],       access: readOnly];    RETURN[copy]};      NoteCaller: PUBLIC PROCEDURE [p: PROGRAM] RETURNS [LONG POINTER] = {    RETURN[LOOPHOLE[p]]};  END.
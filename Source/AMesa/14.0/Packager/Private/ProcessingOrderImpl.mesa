-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- ProcessingOrderImpl.mesa  -- Last edited by Lewis on  7-Nov-83 12:19:19DIRECTORY  Alloc USING [AddNotify, DropNotify, Handle, Notifier, Words],  BcdDefs USING [MTRecord, MTIndex, MTNull],  Error USING [ImplicitCDIncludesModule, ModuleInTwoSegments],  PackagerDefs USING [    globalData, GlobalData, packctreetype, packtreetype, packsttype, packpotype],  ProcessingOrder,  SemanticEntry USING [STIndex, STRecord],  SourceBcd USING [    ComponentKind, CTreeIndex, EnumerateModules, EnumerateModulesInConfig,    IsModuleInConfig, IsTableCompiled, moduleCount, ModuleNum,    NullModuleNum, ModuleNumForMti],  SymTabDefs USING [HTIndex],  Table USING [Base, Limit],  Tree: FROM "PackTree" USING [Index, Link, NullIndex, root, Scan, Test],  TreeOps: FROM "PackTreeOps" USING [ListHead, ListLength, ScanList, SearchList];ProcessingOrderImpl: PROGRAM    IMPORTS Alloc, Error, PackagerDefs, SourceBcd, Tree, TreeOps    EXPORTS ProcessingOrder =  BEGIN OPEN ProcessingOrder;  POerror: PROC = {ERROR FindPOerror};  FindPOerror: PUBLIC ERROR = CODE;  gd: PackagerDefs.GlobalData ¬ NIL;  -- set by Determine  table: Alloc.Handle ¬ NIL;    tb, stb, ctreeb, pob: Table.Base;  Notifier: Alloc.Notifier = {    tb     ¬ base[PackagerDefs.packtreetype];      stb    ¬ base[PackagerDefs.packsttype];    ctreeb ¬ base[PackagerDefs.packctreetype];    pob    ¬ base[PackagerDefs.packpotype]}; -- ********************* Global Data Structures *********************** --  orderDetermined: BOOLEAN ¬ FALSE;  -- Head of chain of PORecords for each module  poChainHead: LONG POINTER TO POChainMap ¬ NIL;  POChainMap: TYPE = RECORD [SEQUENCE length: CARDINAL OF POIndex];  POIndex: TYPE = Table.Base RELATIVE POINTER [0..Table.Limit) TO PORecord;    PONull: POIndex = LAST[POIndex];  -- Indicates the next component description to process  PORecord: TYPE = RECORD [    treeNode: Tree.Index, -- component description's parse tree node    link: POIndex];       -- next PORecord in module's chain  InitializeChainHeads: PROC = {    poChainHead ¬ gd.zone.NEW[POChainMap[SourceBcd.moduleCount]];    FOR i: SourceBcd.ModuleNum IN [0..SourceBcd.moduleCount) DO       poChainHead[i] ¬ PONull;       ENDLOOP};  ReleaseChainHeads: PROC = {    IF poChainHead # NIL THEN gd.zone.FREE[@poChainHead]};  InsertInPOChain: PROC [mti: BcdDefs.MTIndex, cdNode: Tree.Index] = {    -- enter component description tree node in mti's p. o. chain    mNum: SourceBcd.ModuleNum;    newPO, last: POIndex;    IF mti # BcdDefs.MTNull THEN {       mNum ¬ SourceBcd.ModuleNumForMti[mti];      IF poChainHead[mNum] = PONull THEN {  -- empty chain        newPO ¬ NewPORecord[];        pob[newPO] ¬ PORecord[treeNode: cdNode, link: PONull];        poChainHead[mNum] ¬ newPO}       ELSE         FOR p: POIndex ¬ poChainHead[mNum], pob[p].link UNTIL p = PONull DO	    IF pob[p].treeNode = cdNode THEN RETURN;  -- already in p.o. chain	    last ¬ p;	  REPEAT	    FINISHED => {               newPO ¬ NewPORecord[];              pob[newPO] ¬ PORecord[treeNode: cdNode, link: PONull];	      pob[last].link ¬ newPO};	  ENDLOOP}};  NewPORecord: PROC RETURNS [newPO: POIndex] = {    newPO ¬ table.Words[PackagerDefs.packpotype, SIZE[PORecord]];    pob[newPO] ¬ PORecord[treeNode: Tree.NullIndex, link: PONull]}; -- ***************** Module Processing Order Determination ******************  Determine: PUBLIC PROC = {    IF orderDetermined THEN POerror[];    gd ¬ PackagerDefs.globalData;    table ¬ gd.ownTable;    table.AddNotify[Notifier, NIL];    InitializeChainHeads[];    WITH Tree.root SELECT FROM      subtree => {         EnterExplicitComponentDescs[];        EnterImplicitComponentDescs[];        EnterRemainingComponentDescs[];  -- main/ev/catchOfPL (implicit also)        orderDetermined ¬ TRUE;        VerifyModulesInOneSegment[]};      ENDCASE => POerror[]};  Destroy: PUBLIC PROC = {    ReleaseChainHeads[];    IF table # NIL THEN {table.DropNotify[Notifier, NIL];  table ¬ NIL};    gd ¬ NIL;    orderDetermined ¬ FALSE};  IsEmpty: PUBLIC PROC [mti: BcdDefs.MTIndex] RETURNS [reply: BOOLEAN] = {    -- return TRUE if no component description nodes to be processed for mti    mNum: SourceBcd.ModuleNum = SourceBcd.ModuleNumForMti[mti];    IF ~orderDetermined THEN POerror[];    IF mNum = SourceBcd.NullModuleNum THEN POerror[];    RETURN[ poChainHead[mNum] = PONull ]};  Enumerate: PUBLIC PROC [      mti: BcdDefs.MTIndex,       userProc: PROC [cdNode: Tree.Index] RETURNS [stop: BOOLEAN]] = {    -- output component description nodes to be processed for mti    mNum: SourceBcd.ModuleNum = SourceBcd.ModuleNumForMti[mti];    IF ~orderDetermined THEN POerror[];    IF mNum = SourceBcd.NullModuleNum THEN POerror[];    FOR i: POIndex ¬ poChainHead[mNum], pob[i].link UNTIL i = PONull DO      IF userProc[pob[i].treeNode] THEN RETURN;      ENDLOOP};--****** Put Explicit Component Descriptions in Processing Order Chains ******  EnterExplicitComponentDescs: PROC = {    TreeOps.ScanList[Tree.root, EnterExplicitCDsInSegments]};  EnterExplicitCDsInSegments: Tree.Scan =    BEGIN    WITH t SELECT FROM      subtree =>        BEGIN segNode: Tree.Index = index;        IF tb[segNode].name = codeSeg THEN EnterExplicitCDsInOneSeg[segNode];        END;      ENDCASE => POerror[];    END;  EnterExplicitCDsInOneSeg: PROC [segNode: Tree.Index] =    BEGIN    saveIndex: CARDINAL = gd.textIndex;    gd.textIndex ¬ tb[segNode].info;    TreeOps.ScanList[tb[segNode].son[2], EnterExplicitCDsInOneCodePack];    gd.textIndex ¬ saveIndex;    END;  EnterExplicitCDsInOneCodePack: Tree.Scan =    BEGIN    ProcessOneCD: Tree.Scan =      BEGIN      WITH t SELECT FROM        subtree =>          BEGIN cdNode: Tree.Index = index;          saveIndex: CARDINAL = gd.textIndex;          gd.textIndex ¬ tb[cdNode].info;          SELECT tb[cdNode].name FROM            allComp     => EnterAllCompCD[cdNode];            compItems   => EnterCompItemsCD[cdNode];            exceptItems => EnterExceptItemsCD[cdNode];            ENDCASE;          gd.textIndex ¬ saveIndex;          END;        ENDCASE => POerror[];      END;      WITH t SELECT FROM      subtree =>        BEGIN cpNode: Tree.Index = index;        TreeOps.ScanList[tb[cpNode].son[2], ProcessOneCD];        END;      ENDCASE => POerror[];    END;  EnterAllCompCD: PROC [cdNode: Tree.Index] =    BEGIN  -- ComponentDesc ::= Component     EnterOneModule: PROC [mti: BcdDefs.MTIndex] RETURNS [stop: BOOLEAN] =      {InsertInPOChain[mti, cdNode];  RETURN[FALSE]};      WITH tb[cdNode].son[1] SELECT FROM      symbol =>         BEGIN componentSE: SemanticEntry.STIndex = index;	WITH stb[componentSE] SELECT FROM          module => InsertInPOChain[mti, cdNode];           config => SourceBcd.EnumerateModulesInConfig[	    kind: prototype, configTreeNode: cNode, userProc: EnterOneModule];           ENDCASE;        END;      ENDCASE => POerror[];    END;  EnterCompItemsCD: PROC [cdNode: Tree.Index] =    BEGIN  -- ComponentDesc ::= Component [ItemList]    EnterOneItem: Tree.Scan =      BEGIN      EnterOneModule: PROC [mti: BcdDefs.MTIndex] RETURNS [stop: BOOLEAN] =        {InsertInPOChain[mti, cdNode];  RETURN[FALSE]};          WITH t SELECT FROM        symbol =>          BEGIN itemSE: SemanticEntry.STIndex = index;	  WITH stb[itemSE] SELECT FROM            module => InsertInPOChain[mti, cdNode];             config => SourceBcd.EnumerateModulesInConfig[	      kind: prototype, configTreeNode: cNode, userProc: EnterOneModule];            ENDCASE;          END;        ENDCASE => POerror[];      END;    WITH tb[cdNode].son[1] SELECT FROM      symbol =>         BEGIN componentSE: SemanticEntry.STIndex = index;	WITH stb[componentSE] SELECT FROM          module => InsertInPOChain[mti, cdNode];           config => TreeOps.ScanList[tb[cdNode].son[2], EnterOneItem];          ENDCASE;        END;      ENDCASE => POerror[];    END;  EnterExceptItemsCD: PROC [cdNode: Tree.Index] =    BEGIN  -- ComponentDesc ::= Component EXCEPT [ItemList]    WITH tb[cdNode].son[1] SELECT FROM      symbol =>         BEGIN componentSE: SemanticEntry.STIndex = index;	WITH stb[componentSE] SELECT FROM          module => InsertInPOChain[mti, cdNode];           config => ExcludeItems[cdNode, tb[cdNode].son[2], cNode];          ENDCASE;        END;      ENDCASE => POerror[];    END;  ExcludeItems: PROC [      cdNode: Tree.Index,       itemList: Tree.Link, configNode: SourceBcd.CTreeIndex] =    BEGIN  -- enter config's modules that are not (in/equal to) any item    EnterModuleIfNotInList: PROC [        module: BcdDefs.MTIndex] RETURNS [stop: BOOLEAN] =      BEGIN      inAnItem: BOOLEAN;      CheckIfModuleInItem: Tree.Test =        BEGIN         SeeIfModuleFound: PROC [mti: BcdDefs.MTIndex] RETURNS [stop: BOOLEAN] =          {IF module = mti THEN inAnItem ¬ TRUE;  RETURN[inAnItem]};        WITH t SELECT FROM          symbol =>  -- item is either a module or a subconfiguration            BEGIN itemSE: SemanticEntry.STIndex = index;    	    WITH stb[itemSE] SELECT FROM              module => IF module = mti THEN inAnItem ¬ TRUE;                config => SourceBcd.EnumerateModulesInConfig[	        kind: prototype, configTreeNode: cNode, userProc: SeeIfModuleFound];    	      ENDCASE;            END;          ENDCASE => POerror[];        RETURN[inAnItem];  -- continue search until found or end of list        END;      inAnItem ¬ FALSE;      TreeOps.SearchList[itemList, CheckIfModuleInItem];      IF ~inAnItem THEN InsertInPOChain[module, cdNode];        RETURN[FALSE];      END;      SourceBcd.EnumerateModulesInConfig[      kind: prototype, configTreeNode: configNode, userProc: EnterModuleIfNotInList];    END;--***** Put Implicit Component Descriptions in Processing Order Chains *****--  EnterImplicitComponentDescs: PROC =    {TreeOps.ScanList[Tree.root, EnterImplicitCDsInSegments]};  EnterImplicitCDsInSegments: Tree.Scan =    BEGIN    WITH t SELECT FROM      subtree =>        BEGIN segNode: Tree.Index = index;        IF tb[segNode].name = codeSeg THEN EnterImplicitCDsInOneSeg[segNode];        END;      ENDCASE => POerror[];    END;  EnterImplicitCDsInOneSeg: PROC [segNode: Tree.Index] =    BEGIN    saveIndex: CARDINAL = gd.textIndex;    gd.textIndex ¬ tb[segNode].info;    TreeOps.ScanList[tb[segNode].son[2], EnterImplicitCDsInOneCodePack];    gd.textIndex ¬ saveIndex;    END;  EnterImplicitCDsInOneCodePack: Tree.Scan =    BEGIN    ProcessOneCD: Tree.Scan =      BEGIN      WITH t SELECT FROM        subtree =>          BEGIN cdNode: Tree.Index = index;          saveIndex: CARDINAL = gd.textIndex;          gd.textIndex ¬ tb[cdNode].info;          SELECT tb[cdNode].name FROM            exceptPacks      => EnterExceptPacksCD[cdNode];            itemsExceptPacks => EnterItemsExceptPacksCD[cdNode];            exceptPacksItems => EnterExceptPacksItemsCD[cdNode];            ENDCASE;          gd.textIndex ¬ saveIndex;          END;        ENDCASE => POerror[];      END;      WITH t SELECT FROM      subtree =>        BEGIN cpNode: Tree.Index = index;        TreeOps.ScanList[tb[cpNode].son[2], ProcessOneCD];        END;      ENDCASE => POerror[];    END;  EnterExceptPacksCD: PROC [cdNode: Tree.Index] =    BEGIN  -- ComponentDesc ::= Component EXCEPT PackList    EnterOneImplicitCDModule: PROC [        mti: BcdDefs.MTIndex] RETURNS [stop: BOOLEAN] =      BEGIN      InsertImplicitCDModuleInPOChain[mti, cdNode, tb[cdNode].son[2]];      RETURN[FALSE];      END;    WITH tb[cdNode].son[1] SELECT FROM      symbol =>         BEGIN componentSE: SemanticEntry.STIndex = index;	WITH stb[componentSE] SELECT FROM          module => InsertImplicitCDModuleInPOChain[              mti, cdNode, tb[cdNode].son[2]];           config => SourceBcd.EnumerateModulesInConfig[              kind: prototype, configTreeNode: cNode, userProc: EnterOneImplicitCDModule];           ENDCASE;        END;      ENDCASE => POerror[];    END;  InsertImplicitCDModuleInPOChain: PROC [      mti: BcdDefs.MTIndex, cdNode: Tree.Index, packList: Tree.Link] =    BEGIN    implicitCDIncludesMti: BOOLEAN ¬ FALSE;    CheckCDsOfOnePack: Tree.Scan =      BEGIN      WITH t SELECT FROM        symbol =>          BEGIN cpSE: SemanticEntry.STIndex = index;	  WITH stb[cpSE] SELECT FROM            codePack => 	      implicitCDIncludesMti ¬ DoesImplicitCDInPackIncludeMti[		cpId: hti, cpNode: treeNode, module: mti];            ENDCASE;          END;        ENDCASE => POerror[];      END;      -- check that CDs in PackList that reference module mti are all explicit    TreeOps.ScanList[packList, CheckCDsOfOnePack];    IF ~implicitCDIncludesMti THEN InsertInPOChain[mti, cdNode];    END;  DoesImplicitCDInPackIncludeMti: PROC [      cpId: SymTabDefs.HTIndex, cpNode: Tree.Index, module: BcdDefs.MTIndex]      RETURNS [reply: BOOLEAN] =    BEGIN    ProcessOneCD: Tree.Scan =      BEGIN      WITH t SELECT FROM        subtree =>          BEGIN cdNode: Tree.Index = index;          SELECT tb[cdNode].name FROM	    exceptPacks, itemsExceptPacks, exceptPacksItems =>	      BEGIN  -- see if component includes/is module 	      WITH tb[cdNode].son[1] SELECT FROM                symbol =>                   BEGIN componentSE: SemanticEntry.STIndex = index;        	  WITH stb[componentSE] SELECT FROM                    module => 		      IF mti = module THEN		        BEGIN 		        Error.ImplicitCDIncludesModule[			  error, hti, cpId, module]; 		        reply ¬ TRUE; 		        END;                     config => 		      IF SourceBcd.IsModuleInConfig[prototype, module, cNode] THEN  		        BEGIN   		        Error.ImplicitCDIncludesModule[  			  error, hti, cpId, module];   		        reply ¬ TRUE;   		        END;                     ENDCASE;                  END;                ENDCASE => POerror[];              END;            ENDCASE;  -- not an implicit component description          END;        ENDCASE => POerror[];      END;      reply ¬ FALSE;    TreeOps.ScanList[tb[cpNode].son[2], ProcessOneCD];    END;  EnterItemsExceptPacksCD: PROC [cdNode: Tree.Index] =    BEGIN  -- ComponentDesc ::= Component [ItemList] EXCEPT PackList    EnterOneItem: Tree.Scan =      BEGIN      EnterOneImplicitCDModule: PROC [          mti: BcdDefs.MTIndex] RETURNS [stop: BOOLEAN] =        BEGIN        InsertImplicitCDModuleInPOChain[mti, cdNode, tb[cdNode].son[3]];        RETURN[FALSE];        END;      WITH t SELECT FROM        symbol =>          BEGIN itemSE: SemanticEntry.STIndex = index;	  WITH stb[itemSE] SELECT FROM            module => InsertImplicitCDModuleInPOChain[                mti, cdNode, tb[cdNode].son[3]];             config => SourceBcd.EnumerateModulesInConfig[                kind: prototype, configTreeNode: cNode, userProc: EnterOneImplicitCDModule];            ENDCASE;          END;        ENDCASE => POerror[];      END;    WITH tb[cdNode].son[1] SELECT FROM      symbol =>         BEGIN componentSE: SemanticEntry.STIndex = index;	WITH stb[componentSE] SELECT FROM          config => TreeOps.ScanList[tb[cdNode].son[2], EnterOneItem];          ENDCASE;        END;      ENDCASE => POerror[];    END;  EnterExceptPacksItemsCD: PROC [cdNode: Tree.Index] =    BEGIN  -- ComponentDesc ::= Component EXCEPT PackList, [ItemList]    WITH tb[cdNode].son[1] SELECT FROM      symbol =>         BEGIN componentSE: SemanticEntry.STIndex = index;	WITH stb[componentSE] SELECT FROM          module => InsertImplicitCDModuleInPOChain[              mti, cdNode, tb[cdNode].son[2]];           config => ExcludeImplicitCDItems[	      cdNode, tb[cdNode].son[3], tb[cdNode].son[3], cNode];          ENDCASE;        END;      ENDCASE => POerror[];    END;  ExcludeImplicitCDItems: PROC [      cdNode: Tree.Index, packList: Tree.Link,       itemList: Tree.Link, configNode: SourceBcd.CTreeIndex] =    BEGIN  -- enter config's modules that are not (in/equal to) any item    EnterModuleIfNotInList: PROC [        module: BcdDefs.MTIndex] RETURNS [stop: BOOLEAN] =      BEGIN      inAnItem: BOOLEAN;      CheckIfModuleInItem: Tree.Test =        BEGIN         SeeIfModuleFound: PROC [mti: BcdDefs.MTIndex] RETURNS [stop: BOOLEAN] =          {IF module = mti THEN inAnItem ¬ TRUE;  RETURN[inAnItem]};        WITH t SELECT FROM          symbol =>  -- item is either a module or a subconfiguration            BEGIN itemSE: SemanticEntry.STIndex = index;    	    WITH stb[itemSE] SELECT FROM              module => IF module = mti THEN inAnItem ¬ TRUE;                config => SourceBcd.EnumerateModulesInConfig[	        kind: prototype, configTreeNode: cNode, userProc: SeeIfModuleFound];    	      ENDCASE;            END;          ENDCASE => POerror[];        RETURN[inAnItem];  -- continue search until found or end of list        END;      inAnItem ¬ FALSE;      TreeOps.SearchList[itemList, CheckIfModuleInItem];      IF ~inAnItem THEN         InsertImplicitCDModuleInPOChain[module, cdNode, packList];        RETURN[FALSE];      END;      SourceBcd.EnumerateModulesInConfig[      kind: prototype, configTreeNode: configNode, userProc: EnterModuleIfNotInList];    END;-- ***** Put MAIN OF Component Descriptions in Processing Order Chains *****  EnterRemainingComponentDescs: PROC = {    TreeOps.ScanList[Tree.root, EnterRemainingCDsInSegments]};  EnterRemainingCDsInSegments: Tree.Scan = {    WITH t SELECT FROM      subtree => {        segNode: Tree.Index = index;        IF tb[segNode].name = codeSeg THEN EnterRemainingCDsInOneSeg[segNode]};      ENDCASE => POerror[]};  EnterRemainingCDsInOneSeg: PROC [segNode: Tree.Index] = {    saveIndex: CARDINAL = gd.textIndex;    gd.textIndex ¬ tb[segNode].info;    TreeOps.ScanList[tb[segNode].son[2], EnterRemainingCDsInOneCodePack];    gd.textIndex ¬ saveIndex};  EnterRemainingCDsInOneCodePack: Tree.Scan = {    ProcessOneCD: Tree.Scan = {      WITH t SELECT FROM        subtree => {          cdNode: Tree.Index = index;          SELECT tb[cdNode].name FROM	    mainOfPL, evOfPL, catchOfPL => EnterOneRemainingCD[cdNode];	    ENDCASE};        ENDCASE => POerror[]};      WITH t SELECT FROM      subtree => {        cpNode: Tree.Index = index;        TreeOps.ScanList[tb[cpNode].son[2], ProcessOneCD]};      ENDCASE => POerror[]};  EnterOneRemainingCD: PROC [cdNode: Tree.Index] = {    -- ComponentDesc ::= MAIN OF PackList    -- ComponentDesc ::= ENTRY VECTOR OF PackList    -- ComponentDesc ::= CATCH CODE OF PackList    saveIndex: CARDINAL = gd.textIndex;    packList: Tree.Link = tb[cdNode].son[1];    EnterModulesOfOneOfSegsPacks: Tree.Scan = {      WITH t SELECT FROM        subtree => {          cpNode: Tree.Index = index;	  InsertModulesOfOnePack[cpNode: cpNode, remainingCdNode: cdNode]};        ENDCASE => POerror[]};    EnterModulesOfOnePack: Tree.Scan = {      WITH t SELECT FROM        symbol => {          cpSE: SemanticEntry.STIndex = index;	  WITH stb[cpSE] SELECT FROM            codePack => 	      InsertModulesOfOnePack[cpNode: treeNode, remainingCdNode: cdNode];            ENDCASE};        ENDCASE => POerror[]};      gd.textIndex ¬ tb[cdNode].info;    IF TreeOps.ListLength[packList] = 1 THEN {      -- packlist might only be name of current code segment      firstInList: Tree.Link = TreeOps.ListHead[packList];      WITH firstInList SELECT FROM        symbol => {           firstSE: SemanticEntry.STIndex = index;	  WITH stb[firstSE] SELECT FROM	    segment => {	      segNode: Tree.Index = treeNode;	      TreeOps.ScanList[tb[segNode].son[2], EnterModulesOfOneOfSegsPacks];	      RETURN};	    ENDCASE};        ENDCASE => POerror[]};    TreeOps.ScanList[packList, EnterModulesOfOnePack];    gd.textIndex ¬ saveIndex};  InsertModulesOfOnePack: PROC [    cpNode: Tree.Index, remainingCdNode: Tree.Index] = {    -- enter all modules in a code pack referenced by MAIN/ENTRY VECTOR/CATCH OF    InsertAModule: PROC [mti: BcdDefs.MTIndex] RETURNS [BOOLEAN] = {      InsertInPOChain[mti, remainingCdNode];  RETURN[FALSE]};    ProcessOneCD: Tree.Scan = {      WITH t SELECT FROM        subtree => {          cdNode: Tree.Index = index;          SELECT tb[cdNode].name FROM	    mainOfPL, evOfPL, catchOfPL => NULL;	    ENDCASE =>  	      WITH tb[cdNode].son[1] SELECT FROM                symbol => {                   componentSE: SemanticEntry.STIndex = index;        	  WITH stb[componentSE] SELECT FROM                    module => 		      IF ~SourceBcd.IsTableCompiled[mti] THEN		        InsertInPOChain[mti, remainingCdNode];                     config => 		      SourceBcd.EnumerateModulesInConfig[                        kind: prototype, configTreeNode: cNode,		        userProc: InsertAModule];                     ENDCASE};              ENDCASE => POerror[]};        ENDCASE => POerror[]};      TreeOps.ScanList[tb[cpNode].son[2], ProcessOneCD]};-- ************ Verify That a Module Appears in Only One Segment ************-  VerifyModulesInOneSegment: PROC = {    SourceBcd.EnumerateModules[VerifyAModuleInOneSegment]};  VerifyAModuleInOneSegment: PROC [mti: BcdDefs.MTIndex] RETURNS [stop: BOOLEAN] =    BEGIN    modulesSeg: Tree.Index;    CheckOneCDNode: PROC [cdNode: Tree.Index] RETURNS [stop: BOOLEAN] =      BEGIN      IF modulesSeg = Tree.NullIndex THEN modulesSeg ¬ tb[cdNode].seg       ELSE IF modulesSeg # tb[cdNode].seg THEN	BEGIN	segId1, segId2: SymTabDefs.HTIndex;	WITH tb[modulesSeg].son[1] SELECT FROM	  hash => segId1 ¬ index;	  ENDCASE => POerror[];	WITH tb[tb[cdNode].seg].son[1] SELECT FROM	  hash => segId2 ¬ index;	  ENDCASE => POerror[];	Error.ModuleInTwoSegments[error, mti, segId1, segId2];        RETURN[TRUE];	END;      RETURN[FALSE];      END;      modulesSeg ¬ Tree.NullIndex;    Enumerate[mti, CheckOneCDNode];    RETURN[FALSE];    END;  END.
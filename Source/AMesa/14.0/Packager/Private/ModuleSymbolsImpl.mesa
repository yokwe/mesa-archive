-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- File ModuleSymbolsImpl.mesa -- Last edited by Sweet on 18-Aug-83 10:48:31-- Last edited by Lewis on  5-Jan-82 19:46:02-- Last edited by JGS   on 27-Oct-82 11:56:07DIRECTORY  BcdDefs USING [FTIndex, FTNull, FTSelf, MTIndex, SGIndex, SGNull, VersionStamp],  Environment USING [PageCount],  Error USING [ErrorFile, WrongSymbolsVersion],  FileTable USING [Build, Destroy, HandleForFile, UnknownFile],  MFile USING [Handle, Release],  MSegment USING [    Address, CopyIn, Create, Delete, Handle, PagesForWords, Reset],  ModuleSymbols USING [KnownSymbolsInfo],  PackageSymbols,  PackagerDefs USING [globalData],  PrincOps USING [BytePC],  SourceBcd USING [    bcdBases, bcdHeader, EnumerateModules, ModuleNum, ModuleNumForMti],  String USING [SubString],  SymbolOps USING [FindString],  Symbols USING [HTIndex, HTNull, HTRecord],  SymbolSegment USING [STHeader, VersionID],  SymbolTable USING [Handle, Object],  Table USING [Base];ModuleSymbolsImpl: PROGRAM    IMPORTS       Error, FileTable, MFile, MSegment, PackagerDefs, SourceBcd, SymbolOps    EXPORTS ModuleSymbols, SymbolTable =  BEGIN  OPEN ModuleSymbols;    ownSymbolPack: PUBLIC SymbolTable.Handle;  SymbolPack: SymbolTable.Object;  SymSegHandle: PUBLIC --SymbolTable-- TYPE = MSegment.Handle;  InvalidSymbols: PUBLIC ERROR = CODE;  SymbolsProblem: PUBLIC SIGNAL = CODE;    symSeg: MSegment.Handle ¬ NIL;  symSegSize: Environment.PageCount ¬ 0;  header: LONG POINTER TO SymbolSegment.STHeader ¬ NIL;  symbolPackStarted: BOOLEAN ¬ FALSE;    knownSymbols: LONG POINTER TO SymbolInfoMap ¬ NIL;  SymbolInfoMap: TYPE = RECORD [    SEQUENCE length: CARDINAL OF ModuleSymbols.KnownSymbolsInfo];      outerPackArray: PUBLIC LONG DESCRIPTOR FOR    ARRAY OF PackageSymbols.OuterPackRecord;  innerPackArray: PUBLIC LONG DESCRIPTOR FOR    ARRAY OF PackageSymbols.InnerPackRecord;  constArray: PUBLIC LONG DESCRIPTOR FOR    ARRAY OF PackageSymbols.ConstRecord;    loadCodeOffsetTable: PUBLIC PackageSymbols.PCSeq;  loadCodeByteOffsetTable: PUBLIC PackageSymbols.PCSeq;  jumpIndirectTable: PUBLIC PackageSymbols.JISeq;  Load: PUBLIC PROC [mti: BcdDefs.MTIndex] = {    ENABLE UNWIND => Unload[];    sgi: BcdDefs.SGIndex = SourceBcd.bcdBases.mtb[mti].sseg;    fti: BcdDefs.FTIndex = SourceBcd.bcdBases.mtb[mti].file;    mNum: SourceBcd.ModuleNum;    -- known information about module mti    loadedBefore: BOOLEAN;    base, pSymPages: CARDINAL;    file: MFile.Handle;    codeVersion: BcdDefs.VersionStamp;        SELECT fti FROM      BcdDefs.FTNull => {SIGNAL SymbolsProblem;  RETURN};      BcdDefs.FTSelf => codeVersion ¬ SourceBcd.bcdHeader.version;      ENDCASE => codeVersion ¬ SourceBcd.bcdBases.ftb[fti].version;     IF sgi = BcdDefs.SGNull THEN {SIGNAL SymbolsProblem;  RETURN};        mNum ¬ SourceBcd.ModuleNumForMti[mti];    [loadedBefore: loadedBefore,       base: base,      pages: pSymPages,      file: file] ¬ knownSymbols[mNum];    IF pSymPages > symSegSize THEN GrowSeg[minPages: pSymPages];    MSegment.CopyIn[      segment: symSeg, file: file, fileBase: (base-1), count: pSymPages];    IF ~loadedBefore THEN {      IF header.version # codeVersion THEN {        Error.WrongSymbolsVersion[          class: error, module: mti, 	  requiredVersion: codeVersion, actualVersion: header.version];	Unload[];	ERROR InvalidSymbols};      pSymPages ¬ MSegment.PagesForWords[	header.constBlock.offset + header.constBlock.size];      IF pSymPages > symSegSize THEN GrowSeg[minPages: pSymPages];      MSegment.CopyIn[        segment: symSeg, file: file, fileBase: (base-1), count: pSymPages];      knownSymbols[mNum].pages ¬ pSymPages;      knownSymbols[mNum].loadedBefore ¬ TRUE};    InstallTable[ownSymbolPack ! ANY => Unload[]]};  Unload: PUBLIC PROC = {    outerPackArray ¬ DESCRIPTOR[NIL, 0];    innerPackArray ¬ DESCRIPTOR[NIL, 0];    constArray ¬ DESCRIPTOR[NIL, 0];    loadCodeOffsetTable ¬ NIL;    loadCodeByteOffsetTable ¬ NIL;    jumpIndirectTable ¬ NIL};      InstallTable: PROC [base: SymbolTable.Handle] = {    b: LONG POINTER = LOOPHOLE[header];    tB: Table.Base = LOOPHOLE[b];    pCard: LONG POINTER TO CARDINAL;    IF header.versionIdent # SymbolSegment.VersionID THEN ERROR InvalidSymbols;    base.cacheInfo ¬ NIL;    base.hashVec ¬ b + header.hvBlock.offset;    base.ht ¬ DESCRIPTOR[      b + header.htBlock.offset,       header.htBlock.size/SIZE[Symbols.HTRecord]];    base.ssb ¬ b + header.ssBlock.offset;    base.stHandle ¬ header;      base.sourceFile ¬ NIL;    outerPackArray ¬ DESCRIPTOR[      b + header.outerPackBlock.offset,      (header.outerPackBlock.size / SIZE[PackageSymbols.OuterPackRecord])];    innerPackArray ¬ DESCRIPTOR[      b + header.innerPackBlock.offset,      (header.innerPackBlock.size / SIZE[PackageSymbols.InnerPackRecord])];    pCard ¬ LOOPHOLE[b + header.constBlock.offset];    constArray ¬ DESCRIPTOR[pCard+1, pCard­];    loadCodeOffsetTable ¬       LOOPHOLE[pCard + 1 + pCard­ * SIZE[PackageSymbols.ConstRecord]];    loadCodeByteOffsetTable ¬ LOOPHOLE[loadCodeOffsetTable + 1 +       loadCodeOffsetTable.length * SIZE[PrincOps.BytePC]];    jumpIndirectTable ¬ LOOPHOLE[loadCodeByteOffsetTable + 1 +       loadCodeByteOffsetTable.length * SIZE[PrincOps.BytePC]]};  FindProc: PUBLIC PROC [      ss: String.SubString] RETURNS [opi: PackageSymbols.OPIndex] = {    hti: Symbols.HTIndex = SymbolOps.FindString[ownSymbolPack, ss];    l, u, i: PackageSymbols.OPIndex;    IF hti = Symbols.HTNull THEN RETURN[PackageSymbols.OPNull];    l ¬ 1;  u ¬ (LENGTH[outerPackArray] - 1);    WHILE l <= u DO      i ¬ CARDINAL[l+u]/2;      SELECT outerPackArray[i].hti FROM	> hti => u ¬ i-1;	< hti => l ¬ i+1;	ENDCASE => RETURN[i];      ENDLOOP;    RETURN[PackageSymbols.OPNull]};  Initialize: PUBLIC PROC [nModules: CARDINAL] = {     FillInKnowledge: PROC [mti: BcdDefs.MTIndex] RETURNS [stop: BOOLEAN] = {      mNum: SourceBcd.ModuleNum = SourceBcd.ModuleNumForMti[mti];      sgi: BcdDefs.SGIndex;      base: CARDINAL;      file: MFile.Handle ¬ NIL;      IF SourceBcd.bcdBases.mtb[mti].tableCompiled THEN  -- ignore any symbols        knownSymbols[mNum] ¬ [loadedBefore: FALSE, file: NIL, base: 0, pages: 0]      ELSE {        sgi ¬ SourceBcd.bcdBases.mtb[mti].sseg;        base ¬ SourceBcd.bcdBases.sgb[sgi].base;        file ¬ FileTable.HandleForFile[SourceBcd.bcdBases.sgb[sgi].file          ! FileTable.UnknownFile => { 	      Error.ErrorFile[	        error, "was needed for symbols but could not be found"L, fti];	      CONTINUE} ];        knownSymbols[mNum] ¬ [	  loadedBefore: FALSE, file: file, base: base, pages: 1]};       RETURN[FALSE]};    FileTable.Build[];    CreateSeg[];    knownSymbols ¬ PackagerDefs.globalData.zone.NEW[SymbolInfoMap[nModules]];    SourceBcd.EnumerateModules[FillInKnowledge];    IF ~symbolPackStarted THEN {ownSymbolPack ¬ @SymbolPack; symbolPackStarted ¬ TRUE}};  Finalize: PUBLIC PROC = {    f: MFile.Handle;     Unload[];    IF knownSymbols # NIL THEN {      FOR i: CARDINAL IN [0..knownSymbols.length) DO        IF (f ¬ knownSymbols[i].file) # NIL THEN MFile.Release[f];	ENDLOOP;      PackagerDefs.globalData.zone.FREE[@knownSymbols]};    FileTable.Destroy[];    DestroySeg[]};         -- Input segment operations    CreateSeg: PROC = {    IF symSeg # NIL THEN ERROR SymbolsProblem;    symSegSize ¬ 30;    symSeg ¬ MSegment.Create[      file: NIL, release: [],      fileBase: 0, pages: symSegSize, swapInfo: [uniform[size: 3]]];    header ¬ MSegment.Address[symSeg]};      GrowSeg: PROC [minPages: Environment.PageCount] = {    symSegSize ¬ ((minPages+2)/3 * 3);    MSegment.Reset[      segment: symSeg, pages: symSegSize, swapInfo: [uniform[size: 4]]];    header ¬ MSegment.Address[symSeg]};        DestroySeg: PROC = {    IF symSeg # NIL THEN {      MSegment.Delete[symSeg];  symSeg ¬ NIL;      symSegSize ¬ 0;  header ¬ NIL}};      END.
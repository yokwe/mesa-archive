-- Copyright (C) 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- File PackCodeImplA.mesa - last edited by--  Sweet	 7-Feb-84  9:10:09--  Lewis	13-Jan-83 12:03:21--  JGS		22-Sep-82 16:54:32DIRECTORY  Alloc USING [AddNotify, Bounds, DropNotify, Handle, Notifier, Top, Words],  Ascii,  BcdDefs,  BcdOps USING [ENHandle, MTHandle, NameString],  BcdUtilDefs,  CatchFormat USING [EnableHandle, EnableItem, EnableTableBody],  CharIO,  CodePackProcs USING [    EnumerateCodePacks, EnumerateModules, EnumerateProcs, EnumerateSegments,     HtiForCodePackNode, IsDiscardCodePack, ModuleIndex, SubStringForCodePackNode,    SubStringForSegmentNode, TreeIndex],  Environment USING [Byte, bytesPerPage, bytesPerWord, wordsPerPage],  Error USING [EmptyCodePack, ErrorFile, SegmentTooLarge],  FileTable USING [HandleForFile, UnknownFile],  FramePackModules USING [    EnumerateFramePacks, EnumerateModules, SubStringForFramePackNode],  Inline USING [LongCOPY, LongDiv, LongDivMod, LongMult, LowHalf],  MFile USING [CopyFileHandle, GetTimes, Handle, Release],  MSegment USING [PagesForWords],  MStream USING [Create],  ModuleSymbols,  Mopcodes USING [zJIB],  PackagerDefs USING [packctreetype, packtreetype, globalData, GlobalData],  PackageSymbols,  PackCode,  PackEnviron USING [SetBlock],  PieceTable USING [    Append, AppendPage, AppendQuadWord, AppendWord, CopyFromFile, Delete,    Finalize, GetByte, GetPlace, GetVPos, GetWord, Initialize, Length,    Move, NullPiece, Place, Position, PutWord, PutZeros, SetVPos, Store],  PrincOps USING [BytePC, ControlLink, PrefixHeader],  SourceBcd USING [    bcdBases, bcdHeader, CTreeIndex, LookupSS, moduleCount, ModuleNum,    ModuleNumForMti, NullCTreeIndex],  Stream USING [Delete, GetPosition, Handle, PutByte, PutBlock],  String,  SymbolOps,  Symbols,  SymTabDefs USING [HTIndex],  Table USING [Base, Limit],  Time USING [Append, Current, Packed, Unpack],  Tree: FROM "PackTree" USING [Index];PackCodeImplA: PROGRAM   IMPORTS     Alloc, BcdUtilDefs, CharIO, CodePackProcs, Error, FileTable,    FramePackModules, Inline, MFile, MSegment, MStream, ModuleSymbols,    PackagerDefs, PackCode, PackEnviron, PieceTable, SourceBcd, Stream, String,    SymbolOps, Time   EXPORTS PackCode =  BEGIN OPEN PackCode;    gd: PackagerDefs.GlobalData;  z: UNCOUNTED ZONE ¬ NIL;    catchEntryOffset: CARDINAL =     LOOPHOLE[@(LOOPHOLE[1, POINTER TO PrincOps.PrefixHeader].catchCode) - 1];  mainBodyPCOffset: CARDINAL =     LOOPHOLE[@(LOOPHOLE[1, POINTER TO PrincOps.PrefixHeader].mainBodyPC) - 1];  table: Alloc.Handle ¬ NIL;  tb, spb, sgb, fpb, ctreeb: Table.Base;  itb, etb, ctb, mtb, ntb: Table.Base;  enb: Table.Base;  ssb: BcdOps.NameString;  NotifyA: Alloc.Notifier =    BEGIN    tb     ¬ base[PackagerDefs.packtreetype];    ctreeb ¬ base[PackagerDefs.packctreetype];    sgb    ¬ base[BcdDefs.sgtype];    spb    ¬ base[BcdDefs.sptype];    fpb    ¬ base[BcdDefs.fptype];    ssb    ¬ base[BcdDefs.sstype];    itb    ¬ base[BcdDefs.imptype];    etb    ¬ base[BcdDefs.exptype];    ctb    ¬ base[BcdDefs.cttype];    mtb    ¬ base[BcdDefs.mttype];    ntb    ¬ base[BcdDefs.nttype];    enb    ¬ base[BcdDefs.entype];    NotifyB[base, clientData];    END;  EntryIndex: TYPE = [0..PackageSymbols.MaxEntries];  PackError: PUBLIC SIGNAL [reason: PackCode.Problem] = CODE;  cstb: LONG DESCRIPTOR FOR ARRAY OF PackageSymbols.ConstRecord;  initialized: BOOLEAN ¬ FALSE;    seenModules: SeenModuleSeq ¬ NIL;  cur: SeenModuleHandle;  newConstants: WordIndexSeq ¬ NIL;  oldCodeFile: PUBLIC MFile.Handle;  oldCodeBasePosition: LONG CARDINAL;  currentModule: BcdDefs.MTIndex;  currentCodePackHti: SymTabDefs.HTIndex;  firstCodeSgi: BcdDefs.SGIndex;  currentCodeSegment: PUBLIC BcdDefs.SGIndex;  currentSpaceIndex: PUBLIC BcdDefs.SPIndex;  segmentPosition: PUBLIC PieceTable.Position;  codePackPosition: PUBLIC PieceTable.Position;  codeBasePosition: PUBLIC PieceTable.Position;  codeBaseOffset: PUBLIC PackCode.Address; -- from start of code segment  procOffset, oldProcOffset: CARDINAL; -- from codeBase  procPosition: PUBLIC PieceTable.Position;  lastProcEnd: PieceTable.Position;  firstCodePack, currentCodePackResident: BOOLEAN;    outStream: Stream.Handle ¬ NIL;  WriteChar: PROC [c: CHARACTER] =     {IF gd.mapStream # NIL THEN CharIO.PutChar[gd.mapStream, c]};  WriteString: PROC [s: LONG STRING] =     {IF gd.mapStream # NIL THEN CharIO.PutString[gd.mapStream, s]};  WriteSubString: PROC [ss: String.SubString] =     BEGIN    FOR i: CARDINAL IN [ss.offset..ss.offset+ss.length) DO      WriteChar[ss.base[i]];      ENDLOOP;    END;  WriteDecimal: PROC [n: CARDINAL] =     {IF gd.mapStream # NIL THEN CharIO.PutDecimal[gd.mapStream, n]};  WriteOctal: PROC [n: CARDINAL] =     {IF gd.mapStream # NIL THEN CharIO.PutOctal[gd.mapStream, n]};  WriteNumber: PROC [n: CARDINAL, fmt: CharIO.NumberFormat] =     {IF gd.mapStream # NIL THEN CharIO.PutNumber[gd.mapStream, n, fmt]};      WriteCR: PROC = INLINE {WriteChar[Ascii.CR]};  WriteTime: PROC [t: Time.Packed] =    BEGIN    s: STRING ¬ [20];    Time.Append[s, Time.Unpack[t]];    WriteString[s];    END;  Initialize: PROCEDURE [nModules: CARDINAL] =    BEGIN    gd ¬ PackagerDefs.globalData;    table ¬ gd.ownTable;    z ¬ gd.zone;    table.AddNotify[NotifyA, NIL];    PackCode.InitBcdTab[];    seenModules ¬ z.NEW[SeenModuleSeqBody[nModules]];    FOR i: CARDINAL IN [0..nModules) DO seenModules[i] ¬ NIL ENDLOOP;    nMods ¬ nModules;    initialized ¬ TRUE;    END;      nMods: CARDINAL;    FixupCodeByteOffset: PROC = {MaybeFixupCodeByteOffset[TRUE]};  MaybeFixupCodeByteOffset: PROC [pendingOk: BOOLEAN] =    BEGIN    loc: LONG CARDINAL = PieceTable.GetVPos[];    target: PrincOps.BytePC = PieceTable.GetWord[];    val: CARDINAL;    FOR ep: CARDINAL IN [0..cur.nBodies) DO      old, new: PrincOps.BytePC;      bytes: CARDINAL;      [oldPC: old, newPC: new, bytes: bytes] ¬ cur[ep];      IF target IN [old..old+bytes) THEN        BEGIN	IF new = 0 THEN 	  IF pendingOk THEN {	    f: FixupHandle = z.NEW[FixupRec ¬ [	      next: cur[ep].pending, loc: loc, target: target]];	    cur[ep].pending ¬ f;	    RETURN}	  ELSE val ¬ CARDINAL.LAST	ELSE val ¬ target - old + new;	PieceTable.Delete[-2];	PieceTable.PutWord[val];	RETURN;	END;      ENDLOOP;    ERROR PackError[StrangeLIO];    END;      NoteNewPC: PROC [ep: CARDINAL, new: PrincOps.BytePC] =    BEGIN    IF cur[ep].pending # NIL THEN       BEGIN      vicinity: PieceTable.Place ¬ PieceTable.GetPlace[];      savePos: LONG CARDINAL = PieceTable.GetVPos[];      old: PrincOps.BytePC;      f: FixupHandle;      [oldPC: old, pending: f] ¬ cur[ep];      WHILE f # NIL DO        fn: FixupHandle = f.next;	PieceTable.SetVPos[f.loc];	PieceTable.Delete[2];	PieceTable.PutWord[f.target - old + new];	z.FREE[@f];	f ¬ fn;	ENDLOOP;      PieceTable.SetVPos[savePos, @vicinity];      cur[ep].pending ¬ NIL;      END;    cur[ep].newPC ¬ new;    IF ep < cur.ev.nEntries THEN cur.ev.initialPC[ep] ¬ new; -- otherwise catch    END;  FixupCodeOffset: PROC =    BEGIN    old: CARDINAL = PieceTable.GetWord[];    new: CARDINAL = NewOffset[old];    PieceTable.Delete[-2];    PieceTable.PutWord[new];    END;      Finalize: PUBLIC PROCEDURE =    BEGIN    IF ~initialized THEN RETURN;    IF table # NIL THEN table.DropNotify[NotifyA, NIL];    IF seenModules = NIL THEN RETURN;    FOR i: CARDINAL IN [0..nMods) DO       cur ¬ seenModules[i];      IF cur = NIL THEN LOOP;      IF cur.newConstants # NIL THEN z.FREE[@cur.newConstants];      IF cur.oldCodeFile # NIL THEN MFile.Release[cur.oldCodeFile];      FOR ep: CARDINAL IN [0..cur.nBodies) DO        IF cur[ep].pending # NIL THEN	  BEGIN	  f: FixupHandle ¬ cur[ep].pending;	  IF ~cur.discarded THEN SIGNAL PackError[StrangeLIO];	  WHILE f # NIL DO	    fn: FixupHandle ¬ f.next;	    z.FREE[@f];  f ¬ fn;	    ENDLOOP;	  END;	ENDLOOP;      z.FREE[@cur];      ENDLOOP;    PackCode.FinalizeBcdTab[];    IF seenModules # NIL THEN z.FREE[@seenModules];    table ¬ NIL;    initialized ¬ FALSE;    END;  FixLoads: PROCEDURE [    lc: PackageSymbols.PCSeq, start: PrincOps.BytePC, bytes: CARDINAL,     FixProc: PROC] =    BEGIN    l, u, i: INTEGER;    stop: PrincOps.BytePC = [start + bytes];    pci: PrincOps.BytePC;    l ¬ 0; u ¬ lc.length-1;    IF u = -1 THEN RETURN;    UNTIL l > u DO      i ¬ (l+u)/2;      SELECT lc[i] FROM        < start => l ¬ i+1;        > start => u ¬ i-1;        ENDCASE => EXIT;      REPEAT	FINISHED => i ¬ l;      ENDLOOP;    -- lc[i] >= start;    WHILE CARDINAL[i] < lc.length AND (pci ¬ lc[i]) < stop DO      IF pci >= start THEN {        PieceTable.SetVPos[procPosition + pci - oldProcOffset + 1];	FixProc[]};      i ¬ i + 1;      ENDLOOP;    END;  FixJumpImmediates: PROCEDURE [    jc: PackageSymbols.JISeq, start: PrincOps.BytePC, bytes: CARDINAL] =    BEGIN    l, u, i: INTEGER;    op: Environment.Byte;    stop: PrincOps.BytePC = [start + bytes];    pci: PrincOps.BytePC;    l ¬ 0; u ¬ jc.length-1;    IF u = -1 THEN RETURN;    UNTIL l > u DO      i ¬ (l+u)/2;      SELECT jc[i].pc FROM        < start => l ¬ i+1;        > start => u ¬ i-1;        ENDCASE => EXIT;      REPEAT	FINISHED => i ¬ l;      ENDLOOP;    -- jc[i].pc >= start;    IF i < 0 THEN ERROR PackError[InvalidCodeOffset];    WHILE CARDINAL[i] < jc.length AND (pci ¬ jc[i].pc) < stop DO      IF pci >= start THEN {        size: CARDINAL ¬ jc[i].tableSize;	savePos: PieceTable.Position;	newTableOffset, oldTableOffset: PackCode.WordIndex;        PieceTable.SetVPos[procPosition + pci - oldProcOffset];	op ¬ PieceTable.GetByte[];	oldTableOffset ¬ PieceTable.GetWord[];	savePos ¬ PieceTable.GetVPos[];	IF op = Mopcodes.zJIB THEN size ¬ (size+1)/2;	newTableOffset ¬ CodeOffset[PieceTable.AppendWord[]];	PieceTable.CopyFromFile[	    file: oldCodeFile,	    position: oldCodeBasePosition+oldTableOffset*2,	    length: size*2];	PieceTable.SetVPos[savePos];	PieceTable.Delete[-2];	PieceTable.PutWord[newTableOffset]};      i ¬ i + 1;      ENDLOOP;    END;  NewOffset: PUBLIC PROCEDURE [old: PackCode.WordIndex]      RETURNS [PackCode.WordIndex] =    BEGIN -- address in new segment of multiword constant a "old" in old    l, u, i: INTEGER;    delta: CARDINAL;    l ¬ 0; u ¬ LENGTH[cstb]-1;    UNTIL l > u DO      i ¬ (l+u)/2;      SELECT cstb[i].offset FROM        < old => l ¬ i+1;        > old => u ¬ i-1;        ENDCASE => EXIT;      REPEAT	FINISHED => i ¬ u;      ENDLOOP;    IF i < 0 THEN ERROR PackError[InvalidCodeOffset];    delta ¬ old - cstb[i].offset;    IF delta > cstb[i].length THEN ERROR PackError[InvalidCodeOffset];    IF newConstants[i] = PackCode.NullWordIndex THEN      BEGIN      savePos: PieceTable.Position = PieceTable.GetVPos[];      newConstants[i] ¬ CodeOffset[PieceTable.AppendWord[]];      PieceTable.CopyFromFile[        file: oldCodeFile,         position: oldCodeBasePosition + cstb[i].offset*2,         length: cstb[i].length*2];      PieceTable.SetVPos[savePos];      END;    RETURN[newConstants[i] + delta];    END;  firstBody: BOOLEAN;    CopyModuleBodies: PROCEDURE [      root: PackageSymbols.OPIndex] RETURNS [stop: BOOLEAN] =    BEGIN OPEN PackageSymbols;    SELECT root FROM      OPEntry => CopyEV[currentModule];      OPCatch => {        length: CARDINAL;        IF cur = NIL THEN ERROR PackError[EVNotPlaced];        length ¬ cur[cur.nBodies-1].bytes;	IF length # 0 	 AND cur[cur.nBodies-1].oldPC # 0	 THEN {          IF gd.printMap THEN DisplayNumbers[	    ep: epCatch, length: length, hti: Symbols.HTNull];          IF firstBody THEN SetupCurrentOffsets[];	  CopyOneBody[ep: cur.nBodies-1, length: length, 	    catch: TRUE, needsFixup: TRUE];	  CopyNestedBodies[LENGTH[ModuleSymbols.outerPackArray]-1]}};      ENDCASE => {        IF firstBody THEN SetupCurrentOffsets[];	CopyBodies[root]};    RETURN[FALSE];    END;      SetupCurrentOffsets: PROC =    BEGIN    IF cur = NIL THEN ERROR PackError[EVNotPlaced];    [newOffset: codeBaseOffset,      newPiece: evPlace.pi,      oldCodeFile: oldCodeFile,      oldCodePosition: oldCodeBasePosition,      newConstants: newConstants] ¬ cur­;    codeBasePosition ¬ segmentPosition + 2*codeBaseOffset;    evPlace.pos ¬ codeBasePosition;    evPlace.filePos ¬ evPlace.pi.position; -- first two words don't get deleted    firstBody ¬ FALSE;    END;  CopyBodies: PROCEDURE [root: PackageSymbols.OPIndex] =    BEGIN -- copy procedure (and any nested below unless main body)    IF gd.printMap THEN DisplayNumbers[      ep: ModuleSymbols.outerPackArray[root].entryIndex,      length: ModuleSymbols.outerPackArray[root].length,      hti: ModuleSymbols.outerPackArray[root].hti];    CopyOneBody[      ep: ModuleSymbols.outerPackArray[root].entryIndex,      length: ModuleSymbols.outerPackArray[root].length,      catch: FALSE,       needsFixup: ModuleSymbols.outerPackArray[root].needsFixup];    CopyNestedBodies[root];    END;      CopyNestedBodies: PROC [root: PackageSymbols.OPIndex] =    BEGIN    i: PackageSymbols.IPIndex ¬ ModuleSymbols.outerPackArray[root].firstSon;    IF i # PackageSymbols.IPNull THEN      DO      IF gd.printMap THEN DisplayNumbers[        ep: ModuleSymbols.innerPackArray[i].entryIndex,         length: ModuleSymbols.innerPackArray[i].length, 	hti: Symbols.HTNull];      CopyOneBody[	  ep: ModuleSymbols.innerPackArray[i].entryIndex, 	  length: ModuleSymbols.innerPackArray[i].length,	  catch: FALSE,	  needsFixup: ModuleSymbols.innerPackArray[i].needsFixup];      IF ModuleSymbols.innerPackArray[i].lastSon THEN EXIT;      i ¬ i+1;      ENDLOOP;    END;  SegmentOffset: PROCEDURE [pos: PieceTable.Position]      RETURNS [PackCode.WordIndex] =    BEGIN    new: LONG CARDINAL = pos - segmentPosition;    IF new > LAST[CARDINAL] THEN SIGNAL PackError[SegmentTooBig];    RETURN [Inline.LowHalf[new]/2];    END;  CodeByteOffset: PROCEDURE [pos: PieceTable.Position]      RETURNS [CARDINAL] =    BEGIN    new: LONG CARDINAL = pos - codeBasePosition;    IF new > LAST[CARDINAL] THEN SIGNAL PackError[SegmentTooBig];    RETURN [Inline.LowHalf[new]];    END;  CodeOffset: PROCEDURE [pos: PieceTable.Position]      RETURNS [PackCode.WordIndex] = INLINE    BEGIN    RETURN [CodeByteOffset[pos]/2];    END;      ProcessEnables: PROC [mod: SeenModuleHandle] =    BEGIN    ep: PieceTable.Place;      cLength: CARDINAL;      alsoNested: BOOLEAN ¬ TRUE;      et: CatchFormat.EnableHandle;      buffer: RECORD [SELECT OVERLAID * FROM        ei => [item: CatchFormat.EnableItem],	aa => [a: ARRAY [0..SIZE[CatchFormat.EnableItem]) OF CARDINAL],	ENDCASE];	    cur ¬ mod;    cur.thisSeg ¬ FALSE;    ep ¬ cur.enablePlace;    IF ep.pi = PieceTable.NullPiece THEN RETURN;    SetupCurrentOffsets[];    PieceTable.SetVPos[ep.pos, @ep];	      WHILE alsoNested DO        cLength ¬ PieceTable.GetWord[];	alsoNested ¬ FALSE;	THROUGH [0..cLength) DO -- assumes SIZE[EnableItem] = 3	  temp: CARDINAL;	  MaybeFixupCodeByteOffset[pendingOk: FALSE];	  [] ¬ PieceTable.GetWord[];	  temp ¬ PieceTable.GetWord[];	  alsoNested ¬ alsoNested OR (temp MOD 2 # 0);	  ENDLOOP;	-- ****** Now sort the damned things *****	IF cLength = 0 THEN EXIT;	PieceTable.Move[-cLength*SIZE[CatchFormat.EnableItem]*2];	et ¬ z.NEW[CatchFormat.EnableTableBody[cLength]];	FOR i: CARDINAL IN [0..cLength) DO 	  FOR j: CARDINAL IN [0..SIZE[CatchFormat.EnableItem]) DO	    buffer.a[j] ¬ PieceTable.GetWord[];	    ENDLOOP;	  IF buffer.item.start = CARDINAL.LAST THEN {	    buffer.item.length ¬ 0;	    buffer.item.alsoNested ¬ FALSE};	  et[i] ¬ buffer.item;	  ENDLOOP;	SortEnables[et];	PieceTable.Delete[-cLength*SIZE[CatchFormat.EnableItem]*2];	FOR i: CARDINAL IN [0..cLength) DO 	  buffer.item ¬ et[i];	  FOR j: CARDINAL IN [0..SIZE[CatchFormat.EnableItem]) DO	    PieceTable.PutWord[buffer.a[j]];	    ENDLOOP;	  ENDLOOP;	z.FREE[@et];	ENDLOOP;    END;      SortEnables: PROC [et: CatchFormat.EnableHandle] =    BEGIN    n: CARDINAL = et.count;    i: CARDINAL;    temp: CatchFormat.EnableItem;    SiftUp: PROC [l, u: CARDINAL] =      BEGIN      s: CARDINAL;      key: CatchFormat.EnableItem ¬ et[l-1];      DO        s ¬ l*2;        IF s > u THEN EXIT;        IF s < u AND et[s+1-1].start > et[s-1].start THEN s ¬ s+1;        IF key.start > et[s-1].start THEN EXIT;        et[l-1] ¬ et[s-1];        l ¬ s;        ENDLOOP;      et[l-1] ¬ key;      END;    FOR i DECREASING IN [2..n/2] DO SiftUp[i, n]; ENDLOOP;    FOR i DECREASING IN [2..n] DO      SiftUp[1, i];      temp ¬ et[1-1];      et[1-1] ¬ et[i-1];      et[i-1] ¬ temp;      ENDLOOP;    END;  CopyOneBody: PROCEDURE [    ep: EntryIndex, length: CARDINAL,     catch, needsFixup: BOOLEAN] =    BEGIN    codeLength: CARDINAL ¬ length;    vicinity: PieceTable.Place;        -- copy code into output file    oldProcOffset ¬ cur[ep].oldPC;    procPosition ¬ IF catch THEN PieceTable.AppendWord[] ELSE PieceTable.Append[];    procOffset ¬ CodeByteOffset[procPosition];    -- fix up entry vector for module    IF catch AND length = 0 THEN procOffset ¬ 0;    IF catch THEN {      vicinity ¬ PieceTable.GetPlace[];      PieceTable.SetVPos[codeBasePosition + 2*catchEntryOffset, @evPlace];      PieceTable.Delete[2];      PieceTable.PutWord[procOffset];      PieceTable.SetVPos[procPosition, @vicinity]}    ELSE IF ep = 0 THEN { -- fix up mainBodyPC in header      vicinity ¬ PieceTable.GetPlace[];      PieceTable.SetVPos[codeBasePosition + 2*mainBodyPCOffset, @evPlace];      PieceTable.Delete[2];      PieceTable.PutWord[procOffset];      PieceTable.SetVPos[procPosition, @vicinity]};    IF catch AND length = 0 THEN RETURN;    PieceTable.CopyFromFile[      file: oldCodeFile,      position: oldProcOffset + oldCodeBasePosition,      length: length];    NoteNewPC[ep: ep, new: [procOffset]];          IF catch THEN      BEGIN      cLength: CARDINAL;      delta: CARDINAL = procOffset - oldProcOffset;      vicinity: PieceTable.Place ¬ PieceTable.GetPlace[];	      -- update entry vector, etc.      PieceTable.SetVPos[procPosition, @vicinity];      -- we are at the catch entry vector      cLength ¬ PieceTable.GetWord[];      THROUGH [0..cLength) DO        cOffset: CARDINAL = PieceTable.GetWord[];	PieceTable.Delete[-2];	PieceTable.PutWord[cOffset + delta]; 	ENDLOOP;      -- wait to do enables until we are sure of no pending fixups      cLength ¬ PieceTable.GetWord[];      IF cLength # 0 THEN cur.enablePlace ¬ PieceTable.GetPlace[];      END;       -- now get ready to look for multiword constants        IF needsFixup THEN {      FixLoads[        lc: ModuleSymbols.loadCodeOffsetTable,        start: [oldProcOffset],        bytes: length,        FixProc: FixupCodeOffset];      FixLoads[        lc: ModuleSymbols.loadCodeByteOffsetTable,        start: [oldProcOffset],        bytes: length,        FixProc: FixupCodeByteOffset];      FixJumpImmediates[        jc: ModuleSymbols.jumpIndirectTable,        start: [oldProcOffset],        bytes: length]};        END;  CreateNewSegment: PROC [segNode: CodePackProcs.TreeIndex] RETURNS [BOOLEAN] =    BEGIN    endPosition: PieceTable.Position;    base, pages: CARDINAL;    desc: String.SubStringDescriptor;    CodePackProcs.SubStringForSegmentNode[@desc, segNode];    IF gd.printMap THEN      BEGIN      WriteChar[Ascii.CR];      WriteString["Segment: "L];  WriteSubString[@desc];      WriteChar[Ascii.CR];      WriteChar[Ascii.CR];      END;    currentCodeSegment ¬ table.Words[BcdDefs.sgtype, SIZE[BcdDefs.SGRecord]];    currentSpaceIndex ¬ table.Words[BcdDefs.sptype, SIZE[BcdDefs.SPRecord]];    spb[currentSpaceIndex] ¬ [      name: BcdUtilDefs.EnterName[@desc], seg: currentCodeSegment,      length: 0, spaces: NULL];    segmentPosition ¬ PieceTable.AppendPage[];    firstCodePack ¬ TRUE;    CodePackProcs.EnumerateCodePacks[segNode, CreateCodePack       ! PackError =>          IF reason = SegmentTooBig THEN Error.SegmentTooLarge[error, @desc]];    IF ~firstCodePack THEN FinishCodePack[];    endPosition ¬ PieceTable.Length[];    base ¬ Inline.LongDiv[segmentPosition, Environment.bytesPerPage];    pages ¬ MSegment.PagesForWords[      (CARDINAL[Inline.LowHalf[endPosition - segmentPosition]]+1)/2];    sgb[currentCodeSegment] ¬ [      class: code,      file: BcdDefs.FTSelf,      base: base,      pages: pages,      extraPages: 0];    FOR i: CARDINAL IN [0..nMods) DO      mod: SeenModuleHandle = seenModules[i];      IF mod # NIL AND mod.thisSeg THEN ProcessEnables[mod];      ENDLOOP;    RETURN[FALSE];    END;  CreateFramePack: PROC [fpNode: CodePackProcs.TreeIndex] RETURNS [BOOLEAN] =    BEGIN    fpi: BcdDefs.FPIndex = table.Words[BcdDefs.fptype, SIZE[BcdDefs.FPRecord]];    desc: String.SubStringDescriptor;    name: BcdDefs.NameRecord;    totalWordsWCodeLinks, totalWordsWFrameLinks, inLastPage: CARDINAL ¬ 0;    AddModToPack: PROC [mti: BcdDefs.MTIndex] RETURNS [BOOLEAN] = {      n: CARDINAL = fpb[fpi].length;      offset: CARDINAL ¬ 0;      [] ¬ table.Words[BcdDefs.fptype, SIZE[BcdDefs.MTIndex]];      fpb[fpi].modules[n] ¬ mti;      fpb[fpi].length ¬ n+1;      IF gd.printMap THEN {	mth: BcdOps.MTHandle = @mtb[mti];	linkArea: CARDINAL =	  (IF mth.links # BcdDefs.LFNull  	     THEN SourceBcd.bcdBases.lfb[mth.links].length *	       SIZE[PrincOps.ControlLink]	     ELSE 0);	-- print frame size and offset assuming codelinks	IF (mth.linkLoc = code AND mth.linkspace) THEN 	  offset ¬ ((totalWordsWCodeLinks+3)/4)*4	ELSE  -- links before frame	 	  offset ¬ ((totalWordsWCodeLinks + linkArea+3)/4)*4;  	WriteNumber[mth.framesize, Decimal6];	WriteNumber[offset, Octal7];  WriteChar['B];	totalWordsWCodeLinks ¬ offset + mth.framesize;	-- now, assuming framelinks only	offset ¬ ((totalWordsWFrameLinks + linkArea+3)/4)*4;	WriteNumber[mth.framesize, Decimal6];	WriteNumber[offset, Octal7];  WriteChar['B];	totalWordsWFrameLinks ¬ (offset + mth.framesize);	WriteString["    "];	[] ¬ WriteName[mth.name];	WriteChar[Ascii.CR]};      RETURN[FALSE]};    FramePackModules.SubStringForFramePackNode[@desc, fpNode];    fpb[fpi].name ¬ name ¬ BcdUtilDefs.EnterName[@desc];    IF gd.printMap THEN {      WriteChar[Ascii.CR];      WriteString["Frame Pack: "L];      [] ¬ WriteName[name];      WriteChar[Ascii.CR];      WriteString["Load description"L];      WriteChar[Ascii.CR];      WriteString["w/ codelinks       framelinks only"L];      WriteChar[Ascii.CR];      WriteString["Length  offset     length  offset   Module"L];      WriteChar[Ascii.CR]};    fpb[fpi].length ¬ 0;    FramePackModules.EnumerateModules[fpNode, AddModToPack];    IF gd.printMap THEN {      inLastPage ¬ totalWordsWCodeLinks MOD Environment.wordsPerPage;      WriteNumber[Environment.wordsPerPage - inLastPage, Decimal6];      WriteString["        "L];      inLastPage ¬ totalWordsWFrameLinks MOD Environment.wordsPerPage;      WriteNumber[Environment.wordsPerPage - inLastPage, Decimal6];      WriteString["            unused"L];      WriteChar[Ascii.CR];      WriteNumber[MSegment.PagesForWords[totalWordsWCodeLinks], Decimal6];      WriteString["        "L];      WriteNumber[MSegment.PagesForWords[totalWordsWFrameLinks], Decimal6];      WriteString["            frame pack pages"L];      WriteChar[Ascii.CR];  WriteChar[Ascii.CR]};    RETURN[FALSE];    END;  StartModule: PUBLIC PROCEDURE [mti: BcdDefs.MTIndex] =    BEGIN    mNum: SourceBcd.ModuleNum = SourceBcd.ModuleNumForMti[mti];    currentModule ¬ mti;    cur ¬ seenModules[mNum];    cstb ¬ ModuleSymbols.constArray;    firstBody ¬ TRUE;    END;      CopyEV: PUBLIC PROCEDURE [mti: BcdDefs.MTIndex] =    BEGIN    mNum: SourceBcd.ModuleNum = SourceBcd.ModuleNumForMti[mti];      mth: BcdOps.MTHandle = @mtb[mti];      cd: BcdDefs.CodeDesc ¬ mth.code;      file: BcdDefs.FTIndex = mth.file;      name: BcdDefs.NameRecord = mth.name;      sgr: BcdDefs.SGRecord = SourceBcd.bcdBases.sgb[cd.sgi];      en: BcdDefs.ENIndex = mth.entries;      entryVector: BcdOps.ENHandle = @enb[en];      nEntries: CARDINAL = LENGTH[ModuleSymbols.outerPackArray] +	LENGTH[ModuleSymbols.innerPackArray];      evWords: CARDINAL = SIZE[PrincOps.PrefixHeader];      oldCodeFile ¬ FileTable.HandleForFile[sgr.file];      oldCodeBasePosition ¬ 2 *        (Inline.LongMult[sgr.base-1, Environment.wordsPerPage] + LONG[cd.offset]);      IF mth.linkLoc = code THEN	BEGIN	pos: LONG CARDINAL ¬ PieceTable.AppendWord[];	lfi: BcdDefs.LFIndex = mth.links;        fLength: CARDINAL = SourceBcd.bcdBases.lfb[lfi].length *	  SIZE[PrincOps.ControlLink];	delta: CARDINAL ¬ (CARDINAL[Inline.LowHalf[pos]] + fLength) MOD 4;        IF delta # 0 THEN delta ¬ 4 - delta;        PieceTable.PutZeros[(fLength + delta)*2];	mth.linkspace ¬ TRUE;	IF gd.printMap THEN	  DisplayNumbers[	    ep: epLinks, length: (fLength + delta)*2, hti: Symbols.HTNull];	END;      codeBasePosition ¬ PieceTable.AppendQuadWord[];      codeBaseOffset ¬ SegmentOffset[codeBasePosition];            IF gd.printMap THEN         DisplayNumbers[ep: epEv, length: evWords*2, hti: Symbols.HTNull];      PieceTable.CopyFromFile[	file: oldCodeFile, 	position: oldCodeBasePosition,        length: evWords*2];      evPlace ¬ PieceTable.GetPlace[];      -- update seenModules array entry      newConstants ¬ IF LENGTH[cstb] = 0 THEN NIL        ELSE z.NEW[WordIndexSeqBody[LENGTH[cstb]]];      IF newConstants # NIL THEN        PackEnviron.SetBlock[          p: newConstants,          v: PackCode.NullWordIndex,          n: LENGTH[cstb] * SIZE[PackCode.WordIndex]];      cur ¬ z.NEW[SeenModuleRecord[nEntries] ¬ [	newOffset: codeBaseOffset,	newPiece: evPlace.pi,	oldCodeFile: oldCodeFile,	ev: entryVector,	oldCodePosition: oldCodeBasePosition,	nConstants: LENGTH[cstb],	newConstants: newConstants]];      FOR ep: NATURAL IN [0..nEntries-1) DO        cur[ep] ¬ [oldPC: entryVector.initialPC[ep], bytes: ];	ENDLOOP;      PieceTable.SetVPos[codeBasePosition + catchEntryOffset*2];      cur[nEntries-1] ¬ [oldPC: PieceTable.GetWord[], bytes: ];      FOR i: NATURAL IN [0..LENGTH[ModuleSymbols.outerPackArray]) DO        ep: EntryIndex;	bytes: CARDINAL;	[entryIndex: ep, length: bytes] ¬ ModuleSymbols.outerPackArray[i];	cur[ep].bytes ¬ bytes;	ENDLOOP;      FOR i: NATURAL IN [0..LENGTH[ModuleSymbols.innerPackArray]) DO        ep: EntryIndex;	bytes: CARDINAL;	[entryIndex: ep, length: bytes] ¬ ModuleSymbols.innerPackArray[i];	cur[ep].bytes ¬ bytes;	ENDLOOP;      seenModules[mNum] ¬ cur;      -- update module table in bcd      cd.offset ¬ codeBaseOffset;      cd.sgi ¬ currentCodeSegment;      cd.length  ¬ 0;      BEGIN -- look for all prototypes of this name      desc: String.SubStringDescriptor ¬ [	base: @ssb.string,	offset: name,	length: ssb.size[name]];      cTreeNode: SourceBcd.CTreeIndex ¬ SourceBcd.LookupSS[@desc, prototype];      WHILE cTreeNode # SourceBcd.NullCTreeIndex DO        WITH ctr: ctreeb[cTreeNode].index SELECT FROM	  module =>	    BEGIN	    pmth: BcdOps.MTHandle = @mtb[ctr.mti];	    IF pmth.file = file THEN  {	      pmth.code ¬ cd;	      pmth.linkspace ¬ mth.linkspace;	      pmth.entries ¬ en};	    END;          ENDCASE;	cTreeNode ¬ ctreeb[cTreeNode].prototypePrev;	ENDLOOP;      END;    END;  evPlace: PieceTable.Place;  CopyFakeModule: PROCEDURE [mti: BcdDefs.MTIndex] =    BEGIN    mth: BcdOps.MTHandle = @mtb[mti];    cd: BcdDefs.CodeDesc ¬ mth.code;    file: BcdDefs.FTIndex = mth.file;    name: BcdDefs.NameRecord = mth.name;    sgr: BcdDefs.SGRecord = SourceBcd.bcdBases.sgb[cd.sgi];    oldCodeFile ¬ FileTable.HandleForFile[sgr.file];    oldCodeBasePosition ¬ 2 *      (Inline.LongMult[sgr.base-1, Environment.wordsPerPage] + LONG[cd.offset]);    codeBasePosition ¬ PieceTable.AppendQuadWord[];    codeBaseOffset ¬ SegmentOffset[codeBasePosition];    cur ¬ z.NEW[SeenModuleRecord[0] ¬ [newOffset: codeBaseOffset,      newPiece: PieceTable.GetPlace[].pi,      oldCodeFile: oldCodeFile,      oldCodePosition: oldCodeBasePosition,      ev: NIL,      nConstants: 0,      newConstants: NIL]];    IF gd.printMap THEN       DisplayNumbers[ep: epEv, length: cd.length, hti: Symbols.HTNull];    PieceTable.CopyFromFile[      file: oldCodeFile,       position: oldCodeBasePosition,      length: cd.length];    IF (codeBaseOffset + cd.length) > LAST[CARDINAL] THEN PackError[SegmentTooBig];    -- update module table in bcd    cd.offset ¬ codeBaseOffset;    cd.sgi ¬ currentCodeSegment;    cd.length  ¬ 0;    BEGIN -- look for all prototypes of this name    desc: String.SubStringDescriptor ¬ [      base: @ssb.string,      offset: name,      length: ssb.size[name]];    cTreeNode: SourceBcd.CTreeIndex ¬ SourceBcd.LookupSS[@desc, prototype];    WHILE cTreeNode # SourceBcd.NullCTreeIndex DO      WITH ctr: ctreeb[cTreeNode].index SELECT FROM        module =>          BEGIN          pmth: BcdOps.MTHandle = @mtb[ctr.mti];          IF pmth.file = file THEN pmth.code ¬ cd;          END;        ENDCASE;      cTreeNode ¬ ctreeb[cTreeNode].prototypePrev;      ENDLOOP;    END;    END;  DiscardAllInPack: PROC [cpNode: CodePackProcs.TreeIndex] =    BEGIN    CodePackProcs.EnumerateModules[cpNode, DiscardThisModule];    END;  DiscardThisModule: PROCEDURE [    mti: BcdDefs.MTIndex, module: CodePackProcs.ModuleIndex]      RETURNS [BOOLEAN] =    BEGIN    StartModule[mti];    SetupCurrentOffsets[]; -- you can't discard the EV, it should be already out    CodePackProcs.EnumerateProcs[module, DiscardModuleProc];    newConstants ¬ NIL;    RETURN[FALSE]    END;  DiscardModuleProc: PROCEDURE [root: PackageSymbols.OPIndex]      RETURNS [stop: BOOLEAN] =    BEGIN     SELECT root FROM      PackageSymbols.OPEntry => ERROR PackError[EVNotPlaced];      PackageSymbols.OPCatch =>         DiscardThisProc[LENGTH[ModuleSymbols.outerPackArray]-1];      ENDCASE => DiscardThisProc[root];    RETURN[FALSE];    END;      DiscardThisProc: PROCEDURE [root: PackageSymbols.OPIndex] =    BEGIN -- copy procedure (and any nested below unless main body)    DiscardOneBody[ModuleSymbols.outerPackArray[root].entryIndex];    DiscardNested[root];    END;      DiscardNested: PROC [root: PackageSymbols.OPIndex] =    BEGIN    i: PackageSymbols.IPIndex ¬  ModuleSymbols.outerPackArray[root].firstSon;    IF i # PackageSymbols.IPNull THEN      DO        DiscardOneBody[ModuleSymbols.innerPackArray[i].entryIndex];        IF ModuleSymbols.innerPackArray[i].lastSon THEN EXIT;	i ¬ i+1;        ENDLOOP;    END;  DiscardOneBody: PROCEDURE [ep: EntryIndex] =    BEGIN    -- fix up entry vector for module (works for catch stuff, too)    IF ep = cur.nBodies-1 THEN { -- catch code      PieceTable.SetVPos[codeBasePosition + 2*catchEntryOffset];       PieceTable.Delete[2];      PieceTable.PutWord[0]}    ELSE NoteNewPC[ep: ep, new: [0]];    cur.discarded ¬ TRUE; -- something is discarded from this module    END;  CreateCodePack: PROCEDURE [cpNode: CodePackProcs.TreeIndex]      RETURNS [BOOLEAN] =    BEGIN    saveIndex: CARDINAL = gd.textIndex;    offset, pages: CARDINAL;    spii: Table.Base RELATIVE POINTER [0..Table.Limit) TO BcdDefs.SpaceID;    name: BcdDefs.NameRecord;    nameCopy: STRING ¬ [80];    desc: String.SubStringDescriptor;    endPosition: PieceTable.Position;    discard: BOOLEAN = CodePackProcs.IsDiscardCodePack[cpNode];    gd.textIndex ¬ tb[LOOPHOLE[cpNode, Tree.Index]].info;    CodePackProcs.SubStringForCodePackNode[@desc, cpNode];    String.AppendSubString[nameCopy, @desc];    desc ¬ [base: nameCopy, offset: 0, length: nameCopy.length];    name ¬ BcdUtilDefs.EnterName[@desc];    IF gd.printMap THEN      BEGIN      IF firstCodePack THEN firstCodePack ¬ FALSE      ELSE FinishCodePack[];      WriteString["Code Pack: "L];      [] ¬ WriteName[name];      WriteChar[Ascii.CR];      PrintHeader[];      END;    currentCodePackHti ¬ CodePackProcs.HtiForCodePackNode[cpNode];    IF discard THEN {DiscardAllInPack[cpNode]; RETURN [FALSE]};    currentCodePackResident ¬ FALSE;  -- set TRUE if any modules resident    lastProcEnd ¬ codePackPosition ¬ PieceTable.AppendPage[];    CodePackProcs.EnumerateModules[cpNode, CopyModuleToPack];    endPosition ¬ PieceTable.Length[];    IF endPosition - segmentPosition > CARDINAL.LAST THEN      ERROR PackError[SegmentTooBig];    offset ¬ Inline.LongDiv[      codePackPosition - segmentPosition, Environment.bytesPerPage];    pages ¬ MSegment.PagesForWords[      (CARDINAL[Inline.LowHalf[endPosition - codePackPosition]]+1)/2];    spii ¬ table.Words[BcdDefs.sptype, SIZE[BcdDefs.SpaceID]];    spb[spii] ¬ [      name: name, resident: currentCodePackResident,       offset: offset, pages: pages];    spb[currentSpaceIndex].length ¬ spb[currentSpaceIndex].length + 1;    gd.textIndex ¬ saveIndex;    IF ~gd.switch['c] AND seenModules # NIL THEN       BEGIN -- constants not shared among code packs      FOR i: CARDINAL IN [0..nMods) DO        sm: SeenModuleHandle ¬ seenModules[i];	IF sm = NIL THEN LOOP;	IF sm.newConstants # NIL THEN 	  PackEnviron.SetBlock[	    p: sm.newConstants,	    v: PackCode.NullWordIndex,	    n: sm.nConstants * SIZE[PackCode.WordIndex]];	ENDLOOP;      END;    RETURN[FALSE]    END;  FinishCodePack: PROC =    BEGIN    endPosition: PieceTable.Position = PieceTable.Append[];    totalBytes: CARDINAL ¬ Inline.LowHalf[endPosition - codePackPosition];    pages: CARDINAL =      (totalBytes + Environment.bytesPerPage-1)/Environment.bytesPerPage;    gap: CARDINAL;    delta: CARDINAL =      CARDINAL[Inline.LowHalf[endPosition]] MOD Environment.bytesPerPage;    IF gd.printMap THEN {      IF lastProcEnd # 0 AND endPosition > lastProcEnd THEN         NoteData[	  offset: SegmentOffset[lastProcEnd]*2,	  length: Inline.LowHalf[endPosition-lastProcEnd]];      WriteString["------------"L]; WriteChar[Ascii.CR];      IF delta # 0 THEN {         gap ¬ Environment.bytesPerPage - delta;        WriteNumber[gap, Octal5];        IF gap > 7 THEN WriteChar['B] ELSE WriteChar[' ];        WriteString["  unused bytes (last page has "L];	WriteOctal[delta]; 	WriteString[" bytes)"];         WriteChar[Ascii.CR]};      WriteString["Code pack pages: "L];      WriteDecimal[pages];      WriteChar[Ascii.CR]; WriteChar[Ascii.CR]};    IF pages = 0 THEN Error.EmptyCodePack[class: error, cpId: currentCodePackHti];    firstCodePack ¬ FALSE;    END;  CopyModuleToPack: PROCEDURE [      mti: BcdDefs.MTIndex, module: CodePackProcs.ModuleIndex]      RETURNS [stop: BOOLEAN] = {    BEGIN    currentModule ¬ mti;    IF mtb[mti].tableCompiled THEN {      mNum: SourceBcd.ModuleNum = SourceBcd.ModuleNumForMti[mti];      CopyFakeModule[mti         ! FileTable.UnknownFile --[fti]-- => { 	    Error.ErrorFile[	      error, "was needed for code but could not be found"L, fti];	    GOTO CodeFileNotFound}];      seenModules[mNum] ¬ cur}    ELSE {       IF mtb[mti].residentFrame THEN currentCodePackResident ¬ TRUE;      StartModule[mti];      CodePackProcs.EnumerateProcs[module, CopyModuleBodies        ! FileTable.UnknownFile --[fti]-- => {	    Error.ErrorFile[	      error, "was needed for code but could not be found"L, fti];	    newConstants ¬ NIL;  	    GOTO CodeFileNotFound}];      newConstants ¬ NIL};    EXITS      CodeFileNotFound => NULL;    END;    RETURN[FALSE]};  ComputeCodePlacement: PUBLIC PROC =    BEGIN ENABLE UNWIND =>       CleanupCodePlacementComputation[ ! PackError => RESUME];    Initialize[SourceBcd.moduleCount];    RemapOldBcd[];    IF gd.errors THEN RETURN;    firstCodeSgi ¬ LOOPHOLE[table.Top[BcdDefs.sgtype]];    PieceTable.Initialize[];    firstCodePack ¬ TRUE;    lastProcEnd ¬ 0;    IF gd.printMap THEN {      WriteCR[];        WriteString["File "L];  WriteString[gd.mapFileName];      WriteString[" created by Packager from "L];  WriteString[gd.packName];       WriteString[" on "L];  WriteTime[Time.Current[]];  WriteCR[]};    CodePackProcs.EnumerateSegments[CreateNewSegment];    FramePackModules.EnumerateFramePacks[CreateFramePack];    IF gd.printMap AND gd.mapStream # NIL THEN {      gd.mapStream.Delete[];  gd.mapStream ¬ NIL};    END;      CleanupCodePlacementComputation: PROC = {    IF gd.printMap AND gd.mapStream # NIL THEN {      gd.mapStream.Delete[];  gd.mapStream ¬ NIL};    PieceTable.Finalize[];  Finalize[]};  WriteBcdToFile: PUBLIC PROC =    BEGIN    limitSgi: BcdDefs.SGIndex;    bcdPages, bcdPos, size: CARDINAL;    byte: CARDINAL;    newHeader: LONG POINTER TO BcdDefs.BCD;    -- open output stream as a byte stream    IF gd.errors THEN RETURN;    outStream ¬ MStream.Create[       file: MFile.CopyFileHandle[gd.outputBcdFile, [], writeOnly], release: []];    -- compute size of new bcd    bcdPos ¬ SIZE[BcdDefs.BCD];    newHeader ¬ z.NEW[BcdDefs.BCD ¬ SourceBcd.bcdHeader­];    newHeader.version ¬ [      time:  MFile.GetTimes[gd.outputBcdFile].create,      net: gd.network,      host: gd.host];    newHeader.creator ¬ gd.packagerVersion;    newHeader.sourceFile ¬ gd.packFti;    newHeader.unpackagedFile ¬ gd.sourceFti;        size ¬ table.Bounds[BcdDefs.sstype].size;    newHeader.ssOffset ¬ bcdPos;     newHeader.ssLimit ¬ LOOPHOLE[size];     bcdPos ¬ bcdPos + size;    newHeader.ctOffset ¬ bcdPos;     bcdPos ¬ bcdPos + LOOPHOLE[newHeader.ctLimit, CARDINAL];     newHeader.mtOffset ¬ bcdPos;     bcdPos ¬ bcdPos + LOOPHOLE[newHeader.mtLimit, CARDINAL];     newHeader.lfOffset ¬ bcdPos;     bcdPos ¬ bcdPos + LOOPHOLE[newHeader.lfLimit, CARDINAL];     newHeader.impOffset ¬ bcdPos;    bcdPos ¬ bcdPos + LOOPHOLE[newHeader.impLimit, CARDINAL];     newHeader.expOffset ¬ bcdPos;    bcdPos ¬ bcdPos + LOOPHOLE[newHeader.expLimit, CARDINAL];     newHeader.enOffset ¬ bcdPos;    bcdPos ¬ bcdPos + LOOPHOLE[newHeader.enLimit, CARDINAL];     size ¬ table.Bounds[BcdDefs.sgtype].size;    newHeader.sgOffset ¬ bcdPos;     newHeader.sgLimit ¬ LOOPHOLE[size];     bcdPos ¬ bcdPos + size;     size ¬ table.Bounds[BcdDefs.fttype].size;    newHeader.ftOffset ¬ bcdPos;     newHeader.ftLimit ¬ LOOPHOLE[size];     bcdPos ¬ bcdPos + size;     size ¬ table.Bounds[BcdDefs.sptype].size;    newHeader.spOffset ¬ bcdPos;     newHeader.spLimit ¬ LOOPHOLE[size];     bcdPos ¬ bcdPos + size;     newHeader.ntOffset ¬ bcdPos;    bcdPos ¬ bcdPos + LOOPHOLE[newHeader.ntLimit, CARDINAL];     newHeader.typOffset ¬ bcdPos;    bcdPos ¬ bcdPos + LOOPHOLE[newHeader.typLimit, CARDINAL];     newHeader.tmOffset ¬ bcdPos;    bcdPos ¬ bcdPos + LOOPHOLE[newHeader.tmLimit, CARDINAL];     newHeader.atOffset ¬ bcdPos;    bcdPos ¬ bcdPos + LOOPHOLE[newHeader.atLimit, CARDINAL];     newHeader.apOffset ¬ bcdPos;    bcdPos ¬ bcdPos + LOOPHOLE[newHeader.apLimit, CARDINAL];     size ¬ table.Bounds[BcdDefs.fptype].size;    newHeader.fpOffset ¬ bcdPos;     newHeader.fpLimit ¬ LOOPHOLE[size];     bcdPos ¬ bcdPos + size;    bcdPages ¬ MSegment.PagesForWords[bcdPos];    newHeader.nPages ¬ bcdPages;    limitSgi ¬ LOOPHOLE[table.Top[BcdDefs.sgtype]];    FOR sgi: BcdDefs.SGIndex ¬ firstCodeSgi, sgi+SIZE[BcdDefs.SGRecord]      UNTIL sgi = limitSgi DO      sgb[sgi].base ¬ sgb[sgi].base + bcdPages + 1;      ENDLOOP;    -- write bcd to stream    [] ¬ PutBlock[      outStream,      newHeader,       SIZE[BcdDefs.BCD]];    [] ¬ PutBlock[      outStream,      table.Bounds[BcdDefs.sstype].base,       LOOPHOLE[newHeader.ssLimit]];    [] ¬ PutBlock[      outStream,      table.Bounds[BcdDefs.cttype].base,       LOOPHOLE[newHeader.ctLimit]];    [] ¬ PutBlock[      outStream,      table.Bounds[BcdDefs.mttype].base,       LOOPHOLE[newHeader.mtLimit]];    [] ¬ PutBlock[      outStream,      SourceBcd.bcdHeader + SourceBcd.bcdHeader.lfOffset,       LOOPHOLE[newHeader.lfLimit]];    [] ¬ PutBlock[      outStream,      table.Bounds[BcdDefs.imptype].base,       LOOPHOLE[newHeader.impLimit]];    [] ¬ PutBlock[      outStream,      table.Bounds[BcdDefs.exptype].base,       LOOPHOLE[newHeader.expLimit]];    [] ¬ PutBlock[      outStream,      table.Bounds[BcdDefs.entype].base,       LOOPHOLE[newHeader.enLimit]];    [] ¬ PutBlock[      outStream,      table.Bounds[BcdDefs.sgtype].base,       LOOPHOLE[newHeader.sgLimit]];    [] ¬ PutBlock[      outStream,      table.Bounds[BcdDefs.fttype].base,       LOOPHOLE[newHeader.ftLimit]];    [] ¬ PutBlock[      outStream,      table.Bounds[BcdDefs.sptype].base,       LOOPHOLE[newHeader.spLimit]];    [] ¬ PutBlock[      outStream,      table.Bounds[BcdDefs.nttype].base,       LOOPHOLE[newHeader.ntLimit]];    [] ¬ PutBlock[      outStream,      SourceBcd.bcdHeader + SourceBcd.bcdHeader.typOffset,       LOOPHOLE[newHeader.typLimit]];    [] ¬ PutBlock[      outStream,      SourceBcd.bcdHeader + SourceBcd.bcdHeader.tmOffset,       LOOPHOLE[newHeader.tmLimit]];    [] ¬ PutBlock[      outStream,      SourceBcd.bcdHeader + SourceBcd.bcdHeader.atOffset,       LOOPHOLE[newHeader.atLimit]];    [] ¬ PutBlock[      outStream,      SourceBcd.bcdHeader + SourceBcd.bcdHeader.apOffset,       LOOPHOLE[newHeader.apLimit]];    [] ¬ PutBlock[      outStream,      table.Bounds[BcdDefs.fptype].base,       LOOPHOLE[newHeader.fpLimit]];    z.FREE[@newHeader];    -- fill out to a page boundary    byte ¬ Inline.LongDivMod[      num: outStream.GetPosition[],      den: Environment.bytesPerPage].remainder;    IF byte # 0 THEN      THROUGH (byte..Environment.bytesPerPage] DO         outStream.PutByte[0];        ENDLOOP;    -- throw out allocator space and source bcd    END;      PutBlock: PROC [stream: Stream.Handle, p: LONG POINTER, n: CARDINAL] = {    stream.PutBlock[[LOOPHOLE[p], 0, n*Environment.bytesPerWord]]};      WriteCodeToBcdFile: PUBLIC PROC =    BEGIN ENABLE UNWIND => {      PieceTable.Finalize[]; Finalize[]};    -- close piece table    IF ~gd.errors THEN PieceTable.Store[outStream]    ELSE PieceTable.Finalize[];    IF outStream # NIL THEN {outStream.Delete[];  outStream ¬ NIL};    Finalize[];    END;-- procedures to create new name, file, and segment tables for output bcd  -- update source bcd in place, creating new tables:  --   name table (ssb), file table, and segment table  -- after this update, the following is true:  --   All "name" fields refer to new NameRecords  --   In module table,  --      "sseg" refers to new segment table  --      "code.sgi" refers to old segment table  --   In new segment table, "file" refers to new file table  --   In old segment table, "file" refers to old file table  PrintHeader: PROC =    BEGIN    -- should print bcd version in file    WriteString["Bytes   EVI  Offset    IPC   Module"L];    THROUGH [("Module"L).length..modCols] DO WriteChar[Ascii.SP] ENDLOOP;    WriteString["Procedure"L];    WriteChar[Ascii.CR];    WriteChar[Ascii.CR];    END;  -- ** Loadmap stuff  modCols: CARDINAL ¬ 20;  Decimal4: CharIO.NumberFormat =    [base: 10, zerofill: FALSE, unsigned: TRUE, columns: 4];  Decimal5: CharIO.NumberFormat =    [base: 10, zerofill: FALSE, unsigned: TRUE, columns: 5];  Decimal6: CharIO.NumberFormat =    [base: 10, zerofill: FALSE, unsigned: TRUE, columns: 6];  Octal5: CharIO.NumberFormat =    [base: 8, zerofill: FALSE, unsigned: TRUE, columns: 5];  Octal7: CharIO.NumberFormat =    [base: 8, zerofill: FALSE, unsigned: TRUE, columns: 7];  NoteData: PROC [offset, length: CARDINAL] =    BEGIN    WriteNumber[length, Octal5];    WriteString["B    -"L];    WriteNumber[offset, Octal7];    WriteChar['B];    WriteString["          <data>"L];    WriteChar[Ascii.CR];    END;      epEv: INTEGER = -1;  epCatch: INTEGER = -2;  epLinks: INTEGER = -3;  DisplayNumbers: PROC [ep: INTEGER, length: CARDINAL, hti: Symbols.HTIndex] =    BEGIN    -- write out module, entry, segOffset, codeOffset    -- called when codeBasePosition and segmentPosition are valid    pos: PieceTable.Position ¬ PieceTable.Append[];    offset, cols: CARDINAL;    IF lastProcEnd # 0 AND pos > lastProcEnd THEN      NoteData[	offset: SegmentOffset[lastProcEnd]*2,	length: Inline.LowHalf[pos-lastProcEnd]];    lastProcEnd ¬ pos + length;    WriteNumber[length, Octal5];    IF length > 7 THEN WriteChar['B] ELSE WriteChar[' ];    SELECT ep FROM      epEv =>    WriteString["   EV"L];      epCatch => WriteString["  Cat"L];      epLinks => WriteString[" LNKS"L];      ENDCASE => WriteNumber[ep, Decimal5];    offset ¬ Inline.LowHalf[pos - segmentPosition];    WriteNumber[offset, Octal7];    WriteChar['B];    IF ep = epEv OR ep = epLinks THEN      WriteString["        "L]    ELSE      BEGIN      offset ¬ CodeByteOffset[pos];      WriteNumber[offset, Octal7];      WriteChar['B];      END;    WriteString["  "L];    cols ¬ WriteName[mtb[currentModule].name];    IF ep >= 0 THEN      BEGIN      THROUGH [cols..modCols) DO WriteChar[Ascii.SP] ENDLOOP;      WriteChar[Ascii.SP];      IF ep = 0 THEN WriteString["MAIN"L]      ELSE IF hti = Symbols.HTNull THEN        WriteString[" <nested>"L]      ELSE [] ¬ WriteProcName[hti]      END;    WriteChar[Ascii.CR];    END;  WriteName: PROC [name: BcdDefs.NameRecord] RETURNS [length: CARDINAL] =    BEGIN    desc: String.SubStringDescriptor;    desc ¬ [base: @ssb.string, offset: name, length: ssb.size[name]];    WriteSubString[@desc];    RETURN [desc.length];    END;  WriteProcName: PROC [hti: Symbols.HTIndex] RETURNS [length: CARDINAL] =    BEGIN    desc: String.SubStringDescriptor;    IF hti = Symbols.HTNull THEN RETURN[0];    SymbolOps.SubStringForHash[ModuleSymbols.ownSymbolPack, @desc, hti];    WriteSubString[@desc];    RETURN [desc.length];    END;  END.
-- file PackTreeBuild.mesa rewritten by PGS,  7-Jan-87  3:18-- file PackTreeBuild.mesa rewritten by PGS, 17-Jun-85 11:54-- file PackTreeBuild.mesa rewritten by PGS, 17-Jun-85 11:40-- file PackTreeBuild.mesa rewritten by PGS,  6-Oct-84 19:37-- Copyright (C) 1981, 1983, 1984  by Xerox Corporation. All rights reserved. -- file PackTreeBuild.mesa rewritten by PGS,  6-Oct-84 18:37-- file PackTreeBuild.mesa rewritten by PGS, 18-Aug-83 10:49-- File PackTreeBuild.mesa-- grammar last edited by Lewis on  4-Nov-81 15:24:11-- rules   last edited by Lewis on  4-Nov-81 15:24:14 DIRECTORY  P1: FROM "PackParseDefs",  SymTabDefs USING [HTIndex, HTNull],  PackParseTable USING [ActionEntry, Production, ProductionInfo, Symbol, tokenID],  Tree: FROM "PackTree" USING [Link, Null, NullProcs],  TreeOps: FROM "PackTreeOps" USING [    PopTree, PushTree, PushHash, PushList, PushNode, SetExceptCatch,    SetExceptEV, SetExceptMAIN, SetInfo];PackTreeBuild: PROGRAM    IMPORTS TreeOps    EXPORTS Tree, P1 =  BEGIN OPEN TreeOps;  root: PUBLIC Tree.Link ¬ Tree.Null;  -- root of packaging description tree  ProdData: TYPE = ARRAY PackParseTable.Production OF PackParseTable.ProductionInfo;  -- local data base (supplied by parser)  v: LONG DESCRIPTOR FOR ARRAY OF UNSPECIFIED;  l: LONG DESCRIPTOR FOR ARRAY OF CARDINAL;  q: LONG DESCRIPTOR FOR ARRAY OF PackParseTable.ActionEntry;  proddata: LONG POINTER TO ProdData;  AssignDescriptors: PUBLIC PROC [	qd: LONG DESCRIPTOR FOR ARRAY OF PackParseTable.ActionEntry,	vd: LONG DESCRIPTOR FOR ARRAY OF UNSPECIFIED,	ld: LONG DESCRIPTOR FOR ARRAY OF CARDINAL,	pp: LONG POINTER TO ProdData] =    {q ¬ qd;  v ¬ vd;  l ¬ ld;  proddata ¬ pp};  -- the interpretation rules  LinkToSource: PROC [index: CARDINAL] = INLINE {SetInfo[l[index]]};  exceptMain, exceptEV, exceptCatch: BOOLEAN;  primaryComponentId: SymTabDefs.HTIndex;  ProcessQueue: PUBLIC PROC [qI, top: CARDINAL] =    BEGIN    reductionRule: [0..377B];    i: CARDINAL;    save, save2: Tree.Link;    vTop: UNSPECIFIED;    FOR i IN [0 .. qI) DO      top ¬ top-q[i].tag.pLength+1;  vTop ¬ v[top];      reductionRule ¬ proddata[q[i].transition].rule;      SELECT reductionRule FROM        0  =>	--	    --TYPE: PackParseTable	    --TABLE: PackParseData    EXPORTS: SELF	    --GOAL:  Goal	    --TERMINALS:	    --    id 	endOfFile     :     =	    --    [	]	;	    --    ,	.       {     }	    --  SEGMENT	BEGIN	END	CODE    PACK    DISCARD	    --  EXCEPT 	MAIN	OF      FRAME   MERGES  CATCH	    --  ENTRY   VECTOR  EV	    --ALIASES:	    --  id         tokenID	    --  .          InitialSymbol	    --  endOfFile  TrueEndOfFile	    --  PRODUCTIONS:		-- Goal		     ::= . PackagingDesc endOfFile          NULL;        1  =>   -- PackagingDesc     ::= DescSeries           {PushList[v[top]];  root ¬ PopTree[];  PushTree[root]};        2  =>	-- DescSeries        ::= DescItem ;             	-- DescSeries        ::= DescItem .          vTop ¬ 1;        3  =>	-- DescSeries        ::= DescSeries DescItem ;             	-- DescSeries        ::= DescSeries DescItem .          vTop ¬ v[top]+1;        4  =>	-- DescItem          ::= CodeSegment                -- DescItem          ::= FramePack                 -- DescItem          ::= Merge                 -- DescItem          ::= MergeFramePack           NULL;        5  =>	-- CodeSegment       ::= id : SEGMENT = SegmentBody           BEGIN          save ¬ PopTree[];	  PushHash[v[top]];  PushTree[save];            PushNode[codeSeg, 2];  LinkToSource[top];          END;        6  =>	-- SegmentBody       ::= { CodePackSeries }              	-- SegmentBody       ::= BEGIN CodePackSeries END          PushList[v[top+1]];        7  =>	-- CodePackSeries    ::= CodePack          vTop ¬ 1;        8  =>	-- CodePackSeries    ::= CodePackSeries ; CodePack          vTop ¬ v[top]+1;        9  =>	-- CodePackSeries    ::= CodePackSeries ;          NULL;          -- allows trailing ;       10  =>   -- CodePack          ::= id : CODE PACK = InitCodePack CodePackBody          BEGIN          save ¬ PopTree[];	  PushHash[v[top]];  PushTree[save];  PushTree[Tree.NullProcs];          PushNode[codePack, 3];  LinkToSource[top];  	  SetExceptMAIN[exceptMain];  SetExceptEV[exceptEV];	  SetExceptCatch[exceptCatch];          END;       11  =>   -- CodePack          ::= ComponentDesc          BEGIN          PushList[1];  save ¬ PopTree[];	  PushHash[primaryComponentId];  PushTree[save];  PushTree[Tree.NullProcs];          PushNode[unnamedCodePack, 3];  LinkToSource[top];  	  SetExceptMAIN[FALSE];  SetExceptEV[FALSE];  SetExceptCatch[FALSE];          END;       12  =>   -- CodePack          ::= id : DISCARD CODE PACK = InitCodePack CodePackBody          BEGIN          save ¬ PopTree[];	  PushHash[v[top]];  PushTree[save];  PushTree[Tree.NullProcs];          PushNode[discardCodePack, 3];  LinkToSource[top];	  SetExceptMAIN[exceptMain];  SetExceptEV[exceptEV];	  SetExceptCatch[exceptCatch];          END;       13  =>   -- InitCodePack     ::=           exceptMain ¬ exceptEV ¬ exceptCatch ¬ FALSE;       14  =>   -- CodePackBody      ::= { Exceptions CompSeries }                -- CodePackBody      ::= BEGIN Exceptions CompSeries END          PushList[v[top+2]];       15  =>   -- Exceptions        ::=           NULL;       16  =>   -- Exceptions        ::= EXCEPT [ ExceptList ] ;          NULL;       17  =>   -- ExceptList        ::= ExceptItem          NULL;       18  =>   -- ExceptList        ::= ExceptList , ExceptItem          NULL;       19  =>   -- ExceptItem        ::= MAIN          exceptMain ¬ TRUE;       20  =>   -- ExceptItem        ::= ENTRY VECTOR          exceptEV ¬ TRUE;       21  =>   -- ExceptItem        ::= EV          exceptEV ¬ TRUE;       22  =>   -- ExceptItem        ::= CATCH CODE          exceptCatch ¬ TRUE;       23  =>   -- ExceptItem        ::= CATCH          exceptCatch ¬ TRUE;       24  =>	-- CompSeries        ::= ComponentDesc           vTop ¬ 1;       25  =>	-- CompSeries        ::= CompSeries ; ComponentDesc           vTop ¬ v[top]+1;       26  =>	-- CompSeries        ::= CompSeries ;          NULL;          -- allows trailing ;       27  =>   -- ComponentDesc     ::= Component          {PushNode[allComp, 1];  LinkToSource[top]};       28  =>   -- ComponentDesc     ::= Component [ ItemList ]          {PushList[v[top+2]];  PushNode[compItems, 2];  LinkToSource[top]};       29  =>   -- ComponentDesc     ::= Component EXCEPT [ ItemList ]          {PushList[v[top+3]];  PushNode[exceptItems, 2];  LinkToSource[top]};       30  =>   -- ComponentDesc     ::= Component EXCEPT PackList          {PushList[v[top+2]];  PushNode[exceptPacks, 2];  LinkToSource[top]};       31  =>   -- ComponentDesc     ::= Component [ ItemList ] EXCEPT PackList          BEGIN          PushList[v[top+5]];  save ¬ PopTree[];          PushList[v[top+2]];  PushTree[save];            PushNode[itemsExceptPacks, 3];  LinkToSource[top];          END;       32  =>   -- ComponentDesc     ::= Component EXCEPT PackList , [ ItemList ]          BEGIN          PushList[v[top+5]];  save ¬ PopTree[];          PushList[v[top+2]];  PushTree[save];            PushNode[exceptPacksItems, 3];  LinkToSource[top]          END;       33  =>   -- ComponentDesc     ::= MAIN OF PackList          {PushList[v[top+2]];  PushNode[mainOfPL, 1];  LinkToSource[top]};       34  =>   -- ComponentDesc     ::= ENTRY VECTOR OF PackList          {PushList[v[top+3]];  PushNode[evOfPL, 1];  LinkToSource[top]};       35  =>   -- ComponentDesc     ::= EV OF PackList          {PushList[v[top+2]];  PushNode[evOfPL, 1];  LinkToSource[top]};       36  =>   -- ComponentDesc     ::= CATCH CODE OF PackList          {PushList[v[top+3]];  PushNode[catchOfPL, 1];  LinkToSource[top]};       37  =>   -- ComponentDesc     ::= CATCH OF PackList          {PushList[v[top+2]];  PushNode[catchOfPL, 1];  LinkToSource[top]};       38  =>   -- Component         ::= OptQualifiedId          {PushList[v[top]];  PushNode[component, 1];  LinkToSource[top]};       39  =>   -- OptQualifiedId    ::= id          {PushHash[v[top]];  vTop ¬ 1;  primaryComponentId ¬ v[top]};       40  =>   -- OptQualifiedId    ::= OptQualifiedId . id          {PushHash[v[top+2]];  vTop ¬ v[top]+1;  primaryComponentId ¬ v[top+2]};       41  =>   -- ItemList          ::= Item          vTop ¬ 1;       42  =>   -- ItemList          ::= ItemList , Item          vTop ¬ v[top]+1;       43  =>	-- Item              ::= MAIN           PushNode[main, 0];       44  =>	-- Item              ::= ENTRY VECTOR           PushNode[ev, 0];       45  =>	-- Item              ::= EV           PushNode[ev, 0];       46  =>	-- Item              ::= CATCH CODE           PushNode[catch, 0];       47  =>	-- Item              ::= CATCH           PushNode[catch, 0];       48  =>	-- Item              ::= id           PushHash[v[top]];       49  =>   -- PackList          ::= id          {PushHash[v[top]];  vTop ¬ 1};       50  =>   -- PackList          ::= PackList , id          {PushHash[v[top+2]];  vTop ¬ v[top]+1};       51  =>	-- FramePack         ::= id : FRAME PACK = FramePackBody           BEGIN          save ¬ PopTree[];	  PushHash[v[top]];  PushTree[save];            PushNode[framePack, 2];  LinkToSource[top];          END;       52  =>	-- FramePackBody     ::= { CompSeries }              	-- FramePackBody     ::= BEGIN CompSeries END          PushList[v[top+1]];       53  =>	-- Merge             ::= id : SEGMENT MERGES SegList = SegmentBody           BEGIN          save ¬ PopTree[];  PushList[v[top+4]];  save2 ¬ PopTree[];	  PushHash[v[top]];  PushTree[save];  PushTree[save2];            PushNode[merge, 3];  LinkToSource[top];  -- N.B. SegList is 3rd son          END;       54  =>	-- MergeFramePack    ::= id : FRAME PACK MERGES FpList           BEGIN          PushList[v[top+5]];  save ¬ PopTree[];	  PushHash[v[top]];  PushTree[save];            PushNode[mergeFP, 2];  LinkToSource[top];          END;       55  =>   -- SegList           ::= id                -- FpList            ::= id          {PushHash[v[top]];  vTop ¬ 1};       56  =>   -- SegList           ::= SegList , id                -- FpList            ::= FpList , id          {PushHash[v[top+2]];  vTop ¬ v[top]+1};       ENDCASE => ERROR;      v[top] ¬ vTop;      ENDLOOP;    END;  TokenValue: PUBLIC PROC [s: PackParseTable.Symbol] RETURNS [UNSPECIFIED] =    BEGIN    RETURN[SELECT s FROM      PackParseTable.tokenID => SymTabDefs.HTNull,      ENDCASE => 0];    END;  END.
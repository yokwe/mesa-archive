-- Copyright (C) 1981, 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- ReduceBenA.mesa, edited by-- AXD    	11-Jan-84 13:57:02-- DCG    	 2-Feb-84 23:12:53DIRECTORY  Alloc: TYPE USING [Base, Bounds, Handle],  Ascii: TYPE USING [CR, SP],  BcdDefs: TYPE USING [    Base, FPIndex, FPRecord, MTIndex, MTRecord, SGIndex, SpaceID,    SPIndex, SPRecord],  BcdOps: TYPE USING [BcdBase, NameString],  BenDefs: TYPE USING [Event, eventSize, versionID],  AMLoadstate,  IP,  DebugUsefulDefsExtras,  DebugUsefulDefs,  Environment: TYPE,  Exec: TYPE USING [    AddCommand, CheckForAbort, EndOfCommandLine, ExecProc, FreeTokenString,    GetToken, GetTTY, Handle, Outcome, OutputProc, ReleaseTTY, RemoveCommand],  File: TYPE,  FileStream: TYPE USING [Create, EndOf],  Format: TYPE USING [NumberFormat, StringProc],  Heap: TYPE USING [systemZone],  Inline: TYPE USING [BITOR],  MStream: TYPE USING [EndOf, Error, Handle, ReadOnly, WriteOnly],  PerformanceToolFileTypes: TYPE USING [tBen],  PrincOps: TYPE USING [    BytePC, GlobalCodebase, GlobalFrameHandle,    PrefixHandle],  PrincOpsExtras2,  Runtime: TYPE USING [GetBcdTime],  Space: TYPE,  SpecialVolume: TYPE USING [OpenVolume],  Stream: TYPE USING [    Block, Delete, EndOfStream, GetWord, Handle, PutBlock, SetPosition],  String: TYPE,  SymbolOps: TYPE USING [SubStringForHash],  Symbols: TYPE USING [bodyType, CBTIndex, CBTNull, lL, seType],  System: TYPE USING [Microseconds, Pulses, PulsesToMicroseconds],  Table: TYPE USING [Base],  Time: TYPE USING [Append, Unpack],  TTY: TYPE USING [    Handle, NumberFormat, PutChar, PutCR, PutLine, PutLongNumber, PutNumber,    PutString],  Version: TYPE USING [Append],  Volume: TYPE USING [    Close, GetLabelString, GetNext, GetStatus, ID, InsufficientSpace,    LookUpRootFile, maxNameLength, nullID, RootDirectoryError, Status, systemID,    TypeSet];ReduceBenA: PROGRAM  IMPORTS    Alloc, DebugUsefulDefs, Environment, DebugUsefulDefsExtras, AMLoadstate, IP, Exec,    FileStream, Heap, Inline, MStream, Runtime, Space,    SpecialVolume, Stream, String, SymbolOps, Time, TTY, Version, Volume, System =  BEGIN  -- Types from BenDefs:  Event: TYPE = BenDefs.Event;  eventSize: CARDINAL = BenDefs.eventSize;  versionID: CARDINAL = BenDefs.versionID;  PageNumber: TYPE = Environment.PageNumber;  editNumParam: TTY.NumberFormat ¬ [10, FALSE, TRUE, 0];  debug: BOOLEAN ¬ FALSE;  listSource: BOOLEAN ¬ FALSE;  exec: Exec.Handle;  feedback: TTY.Handle;  -- The procedures in this module are approximately in top-down order.  -- The main procedure:  Reduction: Exec.ExecProc = {    exec ¬ h;    feedback ¬ exec.GetTTY[];    debug ¬ listSource ¬ FALSE;    WriteGreeting[];    {ENABLE      ABORTED, DebugUsefulDefs.UserAborted, UNWIND => {outcome ¬ abort; CONTINUE};    GetFileNames[];    ReduceLog[]};    Exec.ReleaseTTY[feedback];    CloseVolume[]};  WriteGreeting: PROC = {    greeting: LONG STRING ¬ String.CopyToNewString[      "ReduceBen "L, Heap.systemZone,  30];    Version.Append[greeting];    String.AppendString[greeting, " of "L];    Time.Append[greeting, Time.Unpack[Runtime.GetBcdTime[]]];    feedback.PutLine[greeting];    Heap.systemZone.FREE[@greeting]};  --  *****  File management stuff   *****  --  SetFile: TYPE = PROC [v: LONG STRING];  maxNameLength: CARDINAL = Volume.maxNameLength;  inFileName: LONG STRING ¬ NIL;  inFile: Stream.Handle;  useRootDir: BOOLEAN ¬ TRUE;  outFileName: LONG STRING ¬ NIL;  outFile: MStream.Handle;  volumeName: LONG STRING ¬ NIL;  volume: Volume.ID ¬ Volume.nullID;  volumeOpen: BOOLEAN ¬ FALSE;  --  *****  Command line scanner stuff   *****  --  GetFileNames: PROC = {    ENABLE UNWIND => ReleaseNames[];    SetParamForSwitch: PROC [token, switches: LONG STRING] = {      i: CARDINAL;      IF switches.length # 0 THEN        FOR i IN [0..switches.length) DO  -- only first switch counts          SELECT switches[i] FROM            'd, 'D => {debug ¬ TRUE; EXIT};            'i, 'I => {SetInputFile[token]; EXIT};            'o, 'O => {SetOutputFile[token]; EXIT};            's, 'S => {listSource ¬ TRUE; EXIT};            'v, 'V => {SetVolume[token]; EXIT};            ENDCASE;          ENDLOOP}; -- SetParamForSwitch    Scan: PROC = {      UNTIL exec.EndOfCommandLine DO        token, switches: LONG STRING;        [token, switches] ¬ exec.GetToken[];        SetParamForSwitch[token, switches];        [] ¬ Exec.FreeTokenString[token];        [] ¬ Exec.FreeTokenString[switches];        ENDLOOP}; -- Scan    -- begin code of GetFileNames:    SetVolume["User"L];    SetOutputFile["Swapping.log"L];    SetInputFile[NIL];    Scan[];    OpenVolume[];    OpenInput[];    OpenOutput[];    ReleaseNames[]}; --  GetFileNames  SetVolume: SetFile = {    IF String.EmptyString[v] THEN RETURN;    CloseVolume[];    String.Replace[@volumeName, v, Heap.systemZone]}; --  SetVolume  SetOutputFile: SetFile = {    IF String.EmptyString[v] THEN RETURN;    String.Replace[@outFileName, v, Heap.systemZone]}; -- SetOutputFile  SetInputFile: SetFile = {    String.Replace[@inFileName, v, Heap.systemZone];    useRootDir ¬ String.EmptyString[inFileName]}; -- SetInputFile  OpenVolume: PROC = {    OPEN Volume;    all: TypeSet ¬ ALL[TRUE];    name: LONG STRING = [maxNameLength];    Cough[volumeName, "Swapping data from "L];    IF ~volumeOpen THEN {      FOR volume ¬ GetNext[nullID, all], GetNext[volume, all] UNTIL volume =        nullID DO        name.length ¬ 0;        GetLabelString[volume, name];        IF String.EquivalentString[name, volumeName] THEN EXIT;        ENDLOOP;      IF volume = nullID THEN {	Cough[volumeName, "! Volume not found: "L]; ERROR ABORTED};      IF volume = systemID THEN RETURN;      SELECT GetStatus[volume] FROM        openRead, openReadWrite => RETURN;        ENDCASE => SpecialVolume.OpenVolume[volume: volume, access: read];      volumeOpen ¬ TRUE}};  --  OpenVolume  OpenInput: PROC = {    -- Raises ABORTED if no input file.    success: BOOLEAN ¬ TRUE;    Cough[IF useRootDir THEN "root directory"L ELSE inFileName, "Input from "L];    IF useRootDir THEN {      fcap: File.File = Volume.LookUpRootFile[        volume: volume, type: PerformanceToolFileTypes.tBen !        Volume.RootDirectoryError =>          IF type = rootFileUnknown THEN {            success ¬ FALSE;            Cough["! Input file not found in root directory"L];            GOTO Fail}];      inFile ¬ FileStream.Create[fcap];      EXITS Fail => NULL}    ELSE      inFile ¬ MStream.ReadOnly[        name: inFileName, release: [] !        MStream.Error =>          IF code = fileNotAvailable THEN {            success ¬ FALSE;            Cough[inFileName, "! Input not available: "L];            CONTINUE}];    IF ~success THEN ERROR ABORTED;    inFile.SetPosition[0]}; -- OpenInput  OpenOutput: PROC = {    Cough[outFileName, "Output to "L];    outFile ¬ MStream.WriteOnly[      name: outFileName, type: text, release: [] !      MStream.Error =>        IF code = fileNotAvailable THEN {          Cough[outFileName, "! Output file not available: "L]; GOTO NoFile}];    outFile.SetPosition[0];    EXITS NoFile => ERROR ABORTED}; -- OpenOutput  Cough: PROC [complaint: LONG STRING, prelude: LONG STRING ¬ NIL] = {    IF prelude # NIL THEN feedback.PutString[prelude];    feedback.PutLine[complaint]}; -- Cough  CloseVolume: PROC = {    IF volumeOpen THEN {Volume.Close[volume]; volumeOpen ¬ FALSE}};  ReleaseNames: PROC = {    Heap.systemZone.FREE[@inFileName];    Heap.systemZone.FREE[@outFileName];    Heap.systemZone.FREE[@volumeName]};  --  ***  Procedures to analyze the log ***  --  ReduceLog: PROC = {    heapCreated: BOOLEAN ¬ FALSE;    event: Event;    eventVector: DESCRIPTOR FOR ARRAY OF CARDINAL = DESCRIPTOR[@event, eventSize];    itemCount: LONG CARDINAL ¬ 0;    moduleName: STRING ¬ [maxNameLength];    procName: STRING ¬ [maxNameLength];    t, lastTime: System.Microseconds ¬ 0;    Eof: ERROR = CODE;    EndOf: PROC [Stream.Handle] RETURNS [BOOLEAN] =      IF useRootDir THEN FileStream.EndOf ELSE MStream.EndOf;    NextItem: PROC = INLINE {      i, j: CARDINAL;      IF exec.CheckForAbort THEN ERROR ABORTED;      FOR i IN [0..eventSize) DO        IF EndOf[inFile] THEN ERROR Eof;	        eventVector[i] ¬ inFile.GetWord[ ! Stream.EndOfStream => ERROR Eof];	        ENDLOOP;      j ¬ 0;      FOR i IN [0..eventSize) DO j ¬ Inline.BITOR[j, eventVector[i]]; ENDLOOP;      IF j = 0 THEN ERROR Eof;      itemCount ¬ itemCount + 1};  --  NextItem    EditItem: PROC = {      procType: ProcType;      name: LONG STRING;      type: NameType;      found, noSymbols: BOOLEAN;      line.length ¬ 0;      PutString["dT: "L];      t ¬ System.PulsesToMicroseconds[System.Pulses[event.time]];      IF lastTime = 0 THEN PutString["Start"L] ELSE LongDecimal[t - lastTime];      lastTime ¬ t;      PutString["; Page: "L];      LongOctal[event.page];      PutString["B; "L];      [name, type, found] ¬ Lookup[event.page];      IF found THEN {        SELECT type FROM          pack => PutString["Pack: "L];          frame, anonFrame => PutString["Frame: "L];          module => PutString["Module: "L];          ENDCASE => PutString["?: "L];        IF type = anonFrame THEN PutString["Anonymous"L] ELSE PutString[name]}      ELSE WITH e: event SELECT event.backingStore FROM	file => {	  PutString["File:"L];	  IF e.f.fileID = File.nullID THEN PutString[" NIL"L]	  ELSE {	    FOR i: CARDINAL IN [0..File.File.SIZE) DO	      FileArray: TYPE = ARRAY [0..File.File.SIZE) OF CARDINAL;	      Char[Ascii.SP];	      String.AppendNumber[line, LOOPHOLE[e.f, FileArray][i], 8];	      ENDLOOP;	    PutString[" - type: "L];	    Octal[e.type]; Char['B]}};	volRoot => {	  PutString["Volume root page: "L];	  LongOctal[e.pvPage];	  PutString[" - type: "L];	  Octal[e.type]; Char['B]};	  	unknown => {	  PutString["Unknown backing store, data ="L];	  FOR i: CARDINAL IN [0..7) DO 	    Char[Ascii.SP]; Octal[e.data[i]]; Char['B];	    ENDLOOP};	  ENDCASE => -- exhausted -- ERROR;      PutLine[];      PutString["         Called from module: "L];      [procType, noSymbols] ¬ GatherData[        event.gf, event.pc, moduleName, procName];      PutString[moduleName];      PutString["; Proc: "L];      PutString[procName];      PutString["; pc: "L];      Octal[event.pc];      PutString["B; Type: "L];      PutString[        (SELECT procType FROM           main => "MAIN"L,           toplevel => "normal"L,	   nested => "nested"L,           catch => "catch"L,           ENDCASE => "")];      PutLine[];      IF listSource AND ~noSymbols THEN {        outProc: Format.StringProc = {PutString[s]};        fail: BOOLEAN ¬ FALSE;        DebugUsefulDefsExtras.SpecialDisplay[          out: outProc, gf: DebugUsefulDefsExtras.GFshort[event.gf], pc: event.pc, load: FALSE, msg: NIL,          suppressErrors: TRUE !          IP.FileMissing, IP.MappingFailure => {            fail ¬ TRUE; CONTINUE}];        IF ~fail AND line.length # 0 THEN {	  line.length ¬ line.length - 1; PutLine[]}}}; -- EditItem    Account: PROC [msg: STRING] = {      IF itemCount = 0 THEN {feedback.PutLine["Empty input file"L]; RETURN};      feedback.PutLine[msg];      feedback.PutString["Number of input items: "L];      feedback.PutLongNumber[itemCount, editNumParam];      feedback.PutCR};  --  Account    Retry: PROC = {      feedback.PutString["Dictionary space exhausted at "L];      feedback.PutLongNumber[dBSize, editNumParam];      feedback.PutLine[" words.  Trying again ..."L];      dBSize ¬ dBSize + 100}; -- Retry    -- Begin code of ReduceLog:    aborted: BOOLEAN ¬ FALSE;    {    ENABLE {      Eof => { Account["End of input file"L]; GOTO Exit };      BadClient => {        feedback.PutCR;        feedback.PutLine["Data file and client do not match!"L];        aborted ¬ TRUE;        GOTO Exit};      Volume.InsufficientSpace => {        feedback.PutCR;        feedback.PutLine["Insufficient space on volume"L];        aborted ¬ TRUE;        GOTO Exit};      ABORTED => {aborted ¬ TRUE; GOTO Exit}};  -- enable list    SortConfigs[ ! overflow => {Retry[]; RETRY}];    feedback.PutLine["Reading input data . . ."L];    NextItem[];    itemCount ¬ 0;  -- header doesn't count    IF eventVector[0] # versionID THEN {      feedback.PutLine["** File has wrong version number"L];      feedback.PutString["Program version #: "L];      feedback.PutNumber[versionID, editNumParam];      feedback.PutCR;      feedback.PutString["File version #: "L];      feedback.PutNumber[eventVector[0], editNumParam];      feedback.PutCR}    ELSE      DO  -- Scan and print the log..        NextItem[]; EditItem[]; ENDLOOP;    EXITS Exit => NULL}; -- ENABLE    inFile.Delete;    outFile.Delete;    CloseVolume[];    dB.pointer ¬ Space.Unmap[dB.pointer];    feedback.PutLine[IF aborted THEN "Aborted"L ELSE "Done"L];    debug ¬ FALSE}; --  ReduceLog  --  ***  Build Packet list which relates page number to code pack or module name ***  Pkt: TYPE = RECORD [ -- describes the use of a range of pages in client vm.    p: LONG POINTER TO Pkt,    first, last: PageNumber, -- Pkt descibes use of pages [first..last].    type: NameType,    name: StringBody]; -- name of code pack, global frame, module, etc.  Name: TYPE = CARDINAL; -- index into string table in bcd.  NameType: TYPE = {pack, frame, anonFrame, module, other};  head: LONG POINTER TO Pkt ¬ NIL; -- list is kept in order of increasing page number.  endOfList: LONG POINTER TO Pkt;  endOfSpace: LONG POINTER;  dB: Space.Interval;  -- scratch space for packet list.  dBSize: Space.PageCount ¬ 500;  NoSymbols: ERROR = CODE;  BadClient: ERROR = CODE;  overflow: SIGNAL = CODE;  -- packet list won't fit in available space.  SortConfigs: PROC = {    -- Runs through all configs, remembering what various pages are used for.    dB ¬ Space.Map[      window: [file: File.nullFile, base: TRASH, count: dBSize],      class: data, swapUnits: [uniform[1]]];     endOfList ¬ dB.pointer;    endOfSpace ¬ Environment.LongPointerFromPage[      Environment.PageFromLongPointer[endOfList] + dBSize];    head ¬ NIL;    feedback.PutLine["Building Dictionary . . ."L];    [] ¬ AMLoadstate.EnumerateBcds[l: DebugUsefulDefsExtras.GetLoadstate[], proc: EachConfig, reverse: FALSE];    feedback.PutLine["... dictionary built"L]}; -- SortConfigs  MtiToCgfi: PROC [mti: BcdDefs.MTIndex] RETURNS [NATURAL] = INLINE {    RETURN[LOOPHOLE[mti, CARDINAL]/BcdDefs.MTRecord.SIZE + 1]};      EachConfig: PROC [bcdInfo: AMLoadstate.BcdInfo, index: AMLoadstate.Index] RETURNS [BOOLEAN] = {    -- Stuff for bcd for current root config:    config: AMLoadstate.Index;    bcd: BcdOps.BcdBase;    tb: BcdDefs.Base;    ssb: BcdOps.NameString;  -- StringTable    spb: BcdDefs.Base;  -- space table    fpb: BcdDefs.Base;  -- frame pack table    ctb: BcdDefs.Base;  -- config Table    mtb: BcdDefs.Base;  -- module table    ScanPacks: PROC =  {      spi: BcdDefs.SPIndex;      segBase: PageNumber;      spi ¬ BcdDefs.SPIndex.FIRST;      {OPEN spb[spi];      UNTIL spi = bcd.spLimit DO        IF exec.CheckForAbort[] THEN ERROR ABORTED;        segBase ¬ FindSegPage[seg];        IF segBase # 0 AND length # 0 THEN          FOR i: CARDINAL IN [0..length) DO            AddPkt[              spaces[i].name, pack, segBase + spaces[i].offset,              segBase + spaces[i].offset + spaces[i].pages - 1];            ENDLOOP;        spi ¬          spi + BcdDefs.SPRecord.SIZE + spb[spi].length*BcdDefs.SpaceID.SIZE;        ENDLOOP}};  -- SearchPacks    ScanFrames: PROC = {      FindFramePages: PROC [fpi: BcdDefs.FPIndex]        RETURNS [frameFirst, frameLast: PageNumber] = {        frameFirst ¬ Environment.PageNumber.LAST;        frameLast ¬ Environment.PageNumber.FIRST;        FOR i: CARDINAL IN [0..fpb[fpi].length) DO          mti: BcdDefs.MTIndex = fpb[fpi].modules[i];          gf: PrincOps.GlobalFrameHandle = AMLoadstate.MapConfigToReal[	    l: DebugUsefulDefsExtras.GetLoadstate[],	    index: config, cgfi: MtiToCgfi[mti]];          IF gf = NIL THEN LOOP;          IF DebugUsefulDefs.Valid[gf] THEN {            frameFirst ¬ MIN[              frameFirst, Environment.PageFromLongPointer[              DebugUsefulDefs.Lengthen[gf]]];            frameLast ¬ MAX[              frameLast, Environment.PageFromLongPointer[              DebugUsefulDefs.Lengthen[gf + mtb[mti].framesize - 1]]]};          ENDLOOP}; -- FindFramePages      fpi: BcdDefs.FPIndex ¬ BcdDefs.FPIndex.FIRST;      frameFirst, frameLast: PageNumber;      {OPEN fpb[fpi];      UNTIL fpi = bcd.fpLimit DO        IF exec.CheckForAbort[] THEN ERROR ABORTED;        [frameFirst, frameLast] ¬ FindFramePages[fpi];        AddPkt[name, frame, frameFirst, frameLast];        fpi ¬          fpi + BcdDefs.FPRecord.SIZE + fpb[fpi].length*BcdDefs.MTIndex.SIZE;        ENDLOOP}};  -- ScanFrames    ScanModules: PROC = {      countUnpackedFound: CARDINAL ¬ 0;      maxGf: ORDERED POINTER ¬ LOOPHOLE[CARDINAL.FIRST];      minGf: ORDERED POINTER ¬ LOOPHOLE[CARDINAL.LAST];      mti: BcdDefs.MTIndex ¬ BcdDefs.MTIndex.FIRST;      pagesIn: Environment.PageCount ¬ 0;      wpp: CARDINAL = Environment.wordsPerPage;      minPage, maxPage: PageNumber;      anon: STRING = "Anonymous frame"L;      UNTIL mti = bcd.mtLimit DO        IF mtb[mti].packageable THEN {	  gf: PrincOps.GlobalFrameHandle;          IF exec.CheckForAbort THEN ERROR ABORTED;          gf ¬ AMLoadstate.MapConfigToReal[l: DebugUsefulDefsExtras.GetLoadstate[], index: config, cgfi: MtiToCgfi[mti]];          IF gf # NIL AND DebugUsefulDefs.Valid[gf] THEN {	    cb: PrincOps.PrefixHandle;	    firstPage, lastPage: PageNumber;            maxGf ¬ MAX[maxGf, LOOPHOLE[gf, ORDERED POINTER]];            minGf ¬ MIN[minGf, LOOPHOLE[gf, ORDERED POINTER]];            cb ¬ Codebase[gf].codebase;            firstPage ¬ Environment.PageFromLongPointer[cb];            cb ¬ cb + mtb[mti].code.length;            lastPage ¬ Environment.PageFromLongPointer[cb];            AddPkt[mtb[mti].name, module, firstPage, lastPage]}};        mti ¬ mti + BcdDefs.MTRecord.SIZE;        ENDLOOP;      -- If the config#0 (used to mean not bootfile) display unpacked frame info      IF config # 0 AND countUnpackedFound > 1 THEN {        maxPage ¬ Environment.PageFromLongPointer[	  DebugUsefulDefs.Lengthen[maxGf]] + 1;        minPage ¬ Environment.PageFromLongPointer[	  DebugUsefulDefs.Lengthen[minGf]];        AddPkt[0, anonFrame, minPage, maxPage - 1]}};  -- ScanModules    -- Utilities used by ScanPacks, ScanFrames,ScanModules:    FindSegPage: PROC [want: BcdDefs.SGIndex] RETURNS [PageNumber] = {      mti: BcdDefs.MTIndex ¬ BcdDefs.MTIndex.FIRST;      UNTIL mti = bcd.mtLimit DO        IF mtb[mti].code.sgi = want THEN {          gf: PrincOps.GlobalFrameHandle = AMLoadstate.MapConfigToReal[	    l: DebugUsefulDefsExtras.GetLoadstate[], index: config, cgfi: MtiToCgfi[mti]];          IF gf # NIL AND DebugUsefulDefs.Valid[gf] THEN            RETURN Environment.PageFromLongPointer[              Codebase[gf].codebase - mtb[mti].code.offset]};        mti ¬ mti + BcdDefs.MTRecord.SIZE;        ENDLOOP;      RETURN[0]}; -- FindSegPage    AddPkt: PROC [name: Name, type: NameType, first, last: PageNumber] = {      -- Add a new Packet to the packet list:      nameLENGTH: CARDINAL = MIN[40, ssb.size[name]];  -- in chars      nameSIZE: CARDINAL = (nameLENGTH + 1)/2;      pktSize: CARDINAL = Pkt.SIZE + nameSIZE;      ip: LONG POINTER TO Pkt ¬ head;      previp: LONG POINTER TO Pkt ¬ NIL;      IF LOOPHOLE[endOfList, LONG CARDINAL] + pktSize - 1 >= LOOPHOLE[endOfSpace,        LONG CARDINAL] THEN {	  dB.pointer ¬ Space.Unmap[dB.pointer]; SIGNAL overflow};      IF head = NIL THEN {ip ¬ head ¬ endOfList; ip.p ¬ NIL}      ELSE        DO          IF first <= ip.first THEN {            IF previp = NIL THEN head ¬ endOfList ELSE previp.p ¬ endOfList;            endOfList.p ¬ ip;            ip ¬ endOfList;            EXIT};          IF ip.p = NIL THEN {ip.p ¬ endOfList; ip ¬ ip.p; ip.p ¬ NIL; EXIT};          previp ¬ ip;          ip ¬ ip.p;          ENDLOOP;      endOfList ¬ endOfList + pktSize;      ip­ ¬ [        p: ip.p, first: first, last: last, type: type,        name: [length: nameLENGTH, maxlength: nameLENGTH, text:]];      FOR k: CARDINAL IN [0..nameLENGTH) DO        ip.name.text[k] ¬ ssb.string[name + k] ENDLOOP;      IF debug THEN DumpPkt[ip]}; -- AddPkt    DumpPkt: PROC [ip: LONG POINTER TO Pkt] = {      -- Used only in Debug mode.  Prints a packet.      feedback.PutLongNumber[LOOPHOLE[ip, LONG CARDINAL], [8, FALSE, FALSE, 0]];      feedback.PutString["B  "L];      feedback.PutString[        SELECT ip.type FROM          pack => "pack "L,          frame => "frame "L,          anonFrame => "anonFrame "L,          module => "module "L,          ENDCASE => "other "L];      feedback.PutString["First: "L];      feedback.PutLongNumber[ip.first, editNumParam];      feedback.PutString[" Last: "L];      feedback.PutLongNumber[ip.last, editNumParam];      feedback.PutChar[Ascii.SP];      feedback.PutLine[@ip.name]}; -- DumpPkt    -- Begin code of EachConfig:    config ¬ index;    bcd ¬ AMLoadstate.AcquireBcd[DebugUsefulDefsExtras.GetLoadstate[], config];    tb ¬ LOOPHOLE[bcd];    ssb ¬ LOOPHOLE[bcd + bcd.ssOffset];    spb ¬ tb + bcd.spOffset;  -- space table    fpb ¬ tb + bcd.fpOffset;  -- frame pack table    ctb ¬ tb + bcd.ctOffset;  -- config Table    mtb ¬ tb + bcd.mtOffset;  -- module table    ScanPacks[];    ScanFrames[];    ScanModules[];    RETURN[FALSE]}; -- EachConfig  Codebase: PROC [gf: PrincOps.GlobalFrameHandle]    RETURNS [cb: PrincOps.GlobalCodebase] = {    gft: PrincOpsExtras2.GFTHandle = LOOPHOLE[gf];    DebugUsefulDefs.LongCopyREAD[      from: @PrincOpsExtras2.GFT[gft].codebase, to: @cb,      nwords: PrincOps.GlobalCodebase.SIZE];    cb.out ¬ FALSE};  -- Routines to interpret a [globalFrame, pc]:  ProcType: TYPE = {main, toplevel, nested, catch, null};  GatherData: PROC [    gf: PrincOpsExtras2.LongGlobalFrameHandle, pc: PrincOps.BytePC, mod, proc: STRING]    RETURNS [procType: ProcType ¬ null, noSymbols: BOOLEAN ¬ FALSE] = {    -- Note: mod and proc are outputs.    IF gf = NIL THEN ERROR BadClient;    mod.length ¬ proc.length ¬ 0;    DebugUsefulDefsExtras.Name[      mod, DebugUsefulDefsExtras.GFshort[gf] !      NoSymbols => {        feedback.PutString["No symbols for "L];        feedback.PutLine[mod];        noSymbols ¬ TRUE;        CONTINUE}; DebugUsefulDefs.InvalidFrame => ERROR BadClient];    IF noSymbols THEN RETURN;    procType ¬ Collect[      gf, pc, proc !      NoSymbols => {        feedback.PutString["No symbols for "L];        feedback.PutLine[mod];        noSymbols ¬ TRUE;        CONTINUE}]}; --  GatherData  Collect: PROC [    gf: PrincOpsExtras2.LongGlobalFrameHandle, pc: PrincOps.BytePC, proc: STRING]    RETURNS [procType: ProcType] = {    cbti: Symbols.CBTIndex = DebugUsefulDefsExtras.CBti[pc, DebugUsefulDefsExtras.GFshort[gf]];    bb: Table.Base = Alloc.Bounds[DebugUsefulDefsExtras.GetAlloc[], Symbols.bodyType].base;    seb: Table.Base = Alloc.Bounds[DebugUsefulDefsExtras.GetAlloc[], Symbols.seType].base;    ss: String.SubStringDescriptor;    IF cbti = Symbols.CBTNull THEN ERROR NoSymbols;    WITH b: bb[cbti] SELECT FROM      Outer, Inner =>        IF b.entryIndex = 0 THEN {          String.AppendString[proc, "MAIN"L]; procType ¬ main}        ELSE {          SymbolOps.SubStringForHash[DebugUsefulDefsExtras.GetSym[], @ss, seb[b.id].hash];          String.AppendSubString[proc, @ss];          procType ¬ IF b.level = Symbols.lL THEN toplevel ELSE nested};      Catch => {String.AppendDecimal[proc, b.index]; procType ¬ catch};      ENDCASE}; -- Collect  --  ***** Obtaining information from packet table  ***** --  Lookup: PROC [page: PageNumber]    RETURNS [name: LONG STRING, which: NameType, found: BOOLEAN] = {    -- Finds owner of page in packet table.    ip: LONG POINTER TO Pkt ¬ head;    WHILE ip # NIL DO      IF page IN [ip.first..ip.last] THEN RETURN[@ip.name, ip.type, TRUE];      IF page < ip.first THEN RETURN[NIL, other, FALSE];      ip ¬ ip.p;      ENDLOOP;    RETURN[NIL, other, FALSE]}; -- Lookup  --  ***** Editing stuff  ***** --  line: LONG STRING ¬ [200];  block: Stream.Block ¬ [LOOPHOLE[@line.text], 0, 0];  Char: PROC [c: CHARACTER] = INLINE { String.AppendChar[line, c]; };  PutString: PROC [item: LONG STRING] = INLINE {String.AppendString[line, item]};  Decimal: PROC [n: UNSPECIFIED] = INLINE {String.AppendNumber[line, n, 10]};  LongDecimal: PROC [n: LONG UNSPECIFIED] = INLINE {    String.AppendLongNumber[line, n, 10]};  Octal: PROC [n: UNSPECIFIED] = INLINE {String.AppendNumber[line, n, 8]};  LongOctal: PROC [n: LONG CARDINAL] = INLINE {String.AppendLongNumber[    line, n, 8]};  PutLine: PROC = {    Char[Ascii.CR];    block.stopIndexPlusOne ¬ line.length;    outFile.PutBlock[block, FALSE];    IF debug THEN feedback.PutString[line];    line.length ¬ 0}; -- PutLine  -- User niceness  BenHelp: Exec.ExecProc = {    h.OutputProc[][      "Command line is:  ReduceBen.~ /s volume/v input/i output/oAny parameter may be defaulted.  Output always goes to the system volume, default name is ""Swapping.log"".  Volume name defaults to ""Star"".  If input is unspecified, then the raw data is assumed to be in the source volume's root directory.  The /s, if present, means try to put the source line that caused the page fault into the output."L]};  BenUnload: Exec.ExecProc = {    Heap.systemZone.FREE[@inFileName];    Heap.systemZone.FREE[@outFileName];    Heap.systemZone.FREE[@volumeName];    h.RemoveCommand["ReduceBen.~"L]};  Exec.AddCommand["ReduceBen.~"L, Reduction, BenHelp, BenUnload];  END.-- 11-Jul-81 12:19:24   WDK       Now handles multiple root configs.  GatherData now takes GlobalFrameHandle and catches Frame.Invalid.  Procedures in top-down order.-- 11-Jan-82 15:09:52   AXD       Changes for Trinity: trace file may live in root directory; use public or friends defs as much as possible; new Exec interface - added help procedure.  Name changed so that ReduceBen can be used for config.-- 25-Jan-82 15:06:33   AXD       Use BenDefs instead of POINTER TO FRAME[Ben].--  1-Mar-82 17:15:01   AXD       Always output pc; add /s option.-- 16-Dec-83 13:02:13   AXD       COnvert to 11.0.--  2-Feb-84 14:09:15	DCG       Catch EndOfStream in NextItem.
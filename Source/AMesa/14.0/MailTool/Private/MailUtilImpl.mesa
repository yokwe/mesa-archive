-- MailUtilImpl.mesa-- BGY	22-Mar-86 13:37:15DIRECTORY  Heap,  MailAttributes,  MailTransport,  MailUtil,  NSName,  StartOps;MailUtilImpl:MONITOR   IMPORTS    Heap, NSName  EXPORTS MailUtil, StartOps = {    zone: PUBLIC UNCOUNTED ZONE ¬ Heap.Create[    initial: 130, increment:40, largeNodeThreshold: 20000, ownerChecking: TRUE];      Handle: TYPE = LONG POINTER TO Object;  Object: TYPE = RECORD [    next: Handle,    proc: MailUtil.UnloadProc,    clientData: LONG POINTER];      list: Handle ¬ NIL;  unloading: PUBLIC BOOLEAN ¬ FALSE;        CopyEnvelope: PUBLIC PROCEDURE[old: MailAttributes.Envelope]     RETURNS [new: MailAttributes.Envelope] = {    NameList: TYPE = RECORD[      data: SEQUENCE COMPUTED CARDINAL OF MailTransport.UndeliveredName];    names: LONG POINTER TO NameList;    new ¬ zone.NEW[MailAttributes.EnvelopeRecord ¬ old­];    new.transport.postmark.server ¬ NSName.CopyName[      zone, old.transport.postmark.server];    new.transport.originator ¬ NSName.CopyName[zone, old.transport.originator];    IF old.transport.problem # NIL THEN {      oldlength: CARDINAL ¬ old.transport.problem.undeliverables.LENGTH;      oldUndy, newUndy: MailTransport.Undeliverables;      oldUndy ¬ old.transport.problem.undeliverables;      new.transport.problem ¬ zone.NEW[        MailTransport.ProblemRecord ¬ old.transport.problem­];      names ¬ zone.NEW[NameList[oldlength]];      new.transport.problem.undeliverables ¬ DESCRIPTOR[names, oldlength];      newUndy ¬ new.transport.problem.undeliverables;      FOR i: CARDINAL IN [0..oldlength) DO        newUndy[i].reason ¬ oldUndy[i].reason;	newUndy[i].name ¬ [];	NSName.CopyNameFields[zone, @oldUndy[i].name, @newUndy[i].name];        ENDLOOP;      };    };            FreeEnvelope: PUBLIC PROCEDURE[envelope: MailAttributes.Envelope] = {    NSName.FreeName[zone, envelope.transport.postmark.server];    NSName.FreeName[zone, envelope.transport.originator];    IF envelope.transport.problem # NIL THEN {      length: CARDINAL ¬ envelope.transport.problem.undeliverables.LENGTH;      undy: MailTransport.Undeliverables ¬ envelope.transport.problem.undeliverables;      FOR i: CARDINAL IN [0..length) DO        NSName.FreeNameFields[zone, @undy[i].name];        ENDLOOP;      zone.FREE[@undy.BASE];      };    zone.FREE[@envelope];    };      RegisterUnloadProc: PUBLIC PROC[    proc: MailUtil.UnloadProc, clientData: LONG POINTER] = {    list ¬ zone.NEW[Object ¬ [      next: list,      proc: proc,      clientData: clientData]];    };      Unload: PUBLIC PROC = {    unloading ¬ TRUE;    FOR i: Handle ¬ list, i.next UNTIL i = NIL DO      i.proc[i.clientData];      ENDLOOP;    Heap.Delete[zone];    };    }.      
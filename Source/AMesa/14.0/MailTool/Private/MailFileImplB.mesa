-- File: MailFileImplB.mesa - last edit by-- AlHall,	 30-Jun-84 23:53:42-- Wobber,	 19-Dec-83 16:28:01 -- PXK    ,	 23-Sep-83 15:55:09 -- BGY    	 23-Mar-86 17:27:28 << This module is responsible for dealing with the TOC file when it needs   to be updated or extended. It should be cold most of the time. >>DIRECTORY  Ascii USING [CR, SP],  BodyDefs USING [ItemType],  Date USING [Packed, StringToPacked, Unintelligible],  Format USING [Blanks, Number, NumberFormat, StringProc, Text],  Inline USING [LongCOPY],  MailFile USING [    AddToHeaderData, AttributeIndex, Error, FilterMessage, FieldType, GetFieldType,     HeaderData, MsgNumber, nullMessage,    ResetHeaderData],  MailFileOps,  MailUtil,  MFile USING [Acquire, Error, GetTimes, Handle, Object, SetAccess, WriteOnly],  MStream USING [Create, GetFile, GetLength, Handle, SetAccess, SetLength],  MailParse USING [    endOfInput, endOfList, Error, Finalize, GetFieldBody, GetFieldName,    Handle, Initialize, NameList, ProcessProc, WriteProc],  NSName USING [EquivalentNames, FreeName, maxFullNameLength, Name, NameFromString],  NSString USING [EquivalentStrings, nullString, String,    StringFromMesaString],  Profile USING [GetUser],  Stream USING [    Byte, Delete, GetBlock, GetChar, GetPosition, Handle, PutBlock,    PutString, SendNow, SetPosition],  String USING [AppendString, Equivalent, StringBoundsFault],  System USING [gmtEpoch],  Time USING [Packed, Unpack, Unpacked];  MailFileImplB: PROGRAM  -- monitoring is done by MailFileImplA  IMPORTS    Date, Format, Inline, MailFile, MailFileOps, MailUtil, MFile, MStream,    MailParse, NSName, NSString, Profile, Stream, String, Time  EXPORTS MailFile, MailFileOps =  BEGIN  OPEN MailParse: MailParse, Ops: MailFileOps;    Name: TYPE = NSName.Name;  Handle: TYPE = LONG POINTER TO Object;  Object: PUBLIC TYPE = Ops.Object;  TocHeader: TYPE = Ops.TocHeader;      MsgNumber: TYPE = MailFile.MsgNumber;  nullMessage: MsgNumber = MailFile.nullMessage;    maxNameLength: CARDINAL = NSName.maxFullNameLength;  maxTocLine: CARDINAL = 100;  WriteToc: PUBLIC PROC [h: Handle] = {    MStream.SetAccess[h.tocStream, readWrite]};    ReadOnlyToc: PUBLIC PROC [h: Handle] = {    CleanupToc[h];    MStream.SetAccess[h.tocStream, readOnly]};    DirtyToc: PUBLIC PROC [h: Handle] = {    h.header.dirty ¬ FALSE;    PutHeader[h, h.tocStream]};  CleanupToc: PUBLIC PROC [h: Handle] = {    IF ~h.writeEnabled THEN RETURN;    h.header.parentTime ¬ MFile.GetTimes[MStream.GetFile[h.stream]].create;    h.header.dirty ¬ FALSE;    PutInfo[h, h.tocStream];    PutHeader[h, h.tocStream]};  PutHeader: PROC [h: Handle, s: Stream.Handle] = {    s.SetPosition[h.header.infoStart + h.header.infoBytes];    s.PutBlock[[LOOPHOLE[h.header], 0, Ops.headerBytes]];    MStream.SetLength[      s, h.header.infoStart + h.header.infoBytes + Ops.headerBytes];    s.SendNow[]};    GetHeader: PROC [h: Handle, s: Stream.Handle]     RETURNS [shortFile: BOOLEAN] = {    l: LONG CARDINAL = MStream.GetLength[s];    IF l <= Ops.headerBytes THEN RETURN[TRUE];    s.SetPosition[l - Ops.headerBytes];    [] ¬ s.GetBlock[[LOOPHOLE[h.header], 0, Ops.headerBytes]];    RETURN[FALSE]};    PutInfo: PROC [h: Handle, s: Stream.Handle] = {    s.SetPosition[h.header.infoStart];    s.PutBlock[[LOOPHOLE[h.info], 0, h.header.infoBytes]]};    GetInfo: PROC [h: Handle, s: Stream.Handle] = {    s.SetPosition[h.header.infoStart];    [] ¬ s.GetBlock[[LOOPHOLE[h.info], 0, h.header.infoBytes]]};  -- Toc Handling Procedures - general stuff  GetTocStream: PROC [base: LONG STRING, create: BOOLEAN]    RETURNS[toc: Stream.Handle] = {    tocName: STRING = [200];    tocFile: MFile.Handle;    String.AppendString[tocName, base];    String.AppendString[tocName, "-TOC"L];    tocFile ¬ MFile.Acquire[name: tocName, access: anchor, release: [] !      MFile.Error => {tocFile ¬ NIL; CONTINUE}];    IF tocFile = NIL THEN {      IF ~create THEN RETURN[NIL];      tocFile ¬ MFile.WriteOnly[name: tocName, release: [], type: binary !        MFile.Error => ERROR MailFile.Error[	  IF code = conflictingAccess THEN fileBusy ELSE fileProblem]]};    MFile.SetAccess[tocFile, IF create THEN readWrite ELSE readOnly !      MFile.Error => ERROR MailFile.Error[fileBusy]];    toc ¬ MStream.Create[file: tocFile, release: []]};    AllocateInfo: PROC [h: Handle, maxLength: MsgNumber] =    BEGIN    h.info ¬ Ops.z.NEW[Ops.InfoSequence[maxLength] ¬ [       length: 0, stamp: Ops.infoStamp, info: TRASH]];    h.header.infoMax ¬ maxLength; -- in case we already had one    h.header.infoBytes ¬ SIZE[Ops.InfoSequence[maxLength]]*2;    END;      FreeInfo: PROC [info: LONG POINTER TO Ops.InfoSequence] = {Ops.z.FREE[@info]};      DestroyToc: PUBLIC PROC [h: Handle] = {    Ops.CleanupToc[h];    h.tocStream.Delete[];    Ops.z.FREE[@h.header];    FreeInfo[h.info]};      InitializeToc: PROC [h: Handle, parentTime: Time.Packed] RETURNS [BOOLEAN] =    BEGIN    WriteToc[h];    h.header­ ¬ [parentTime: parentTime, dirty: TRUE];    IF h.info = NIL THEN AllocateInfo[h, h.header.infoMax]    ELSE {      h.header.infoMax ¬ h.info.maxLength;      h.header.infoBytes ¬ SIZE[Ops.InfoSequence[h.header.infoMax]]*2};    PutInfo[h, h.tocStream];    PutHeader[h, h.tocStream];    MStream.SetLength[      h.tocStream, (h.header.infoStart + h.header.infoBytes) + Ops.headerBytes];    RETURN[TRUE];    END;      LoadToc: PUBLIC PROC [h: Handle, bodyName: LONG STRING] =    BEGIN    ENABLE UNWIND => NULL;    parentTime: Time.Packed = MFile.GetTimes[MStream.GetFile[h.stream]].create;    needNew: BOOLEAN ¬ FALSE;    writingToc: BOOLEAN ¬ FALSE;    shouldBeWritingToc: BOOLEAN = h.writeEnabled;    h.tocStream ¬ GetTocStream[bodyName, FALSE];    IF h.tocStream = NIL THEN {      writingToc ¬ needNew ¬ TRUE;      h.tocStream ¬ GetTocStream[h.fileName, TRUE]}    ELSE IF shouldBeWritingToc THEN {writingToc ¬ TRUE; WriteToc[h]};    h.header ¬ Ops.z.NEW[Ops.TocHeaderObject];    IF ~needNew THEN needNew ¬ GetHeader[h, h.tocStream];    IF needNew OR  -- test on reasonbleness of current header         h.header.dirty OR         h.header.parentTime # parentTime OR         h.header.version1 # Ops.tocVersion OR	 h.header.version2 # Ops.tocVersion THEN      writingToc ¬ InitializeToc[h, parentTime]    ELSE {      AllocateInfo[h, h.header.infoMax];      GetInfo[h, h.tocStream];      IF h.info.stamp # Ops.infoStamp THEN        writingToc ¬ InitializeToc[h, parentTime]};    IF h.header.parsedLength < MStream.GetLength[h.stream] THEN {      IF ~writingToc THEN {writingToc ¬ TRUE; WriteToc[h]};      ExtendToc[h, h.info.length ! UNWIND => {        Ops.z.FREE[@h.info]; Ops.z.FREE[@h.header]; h.tocStream.Delete[]}]};    IF writingToc THEN {      h.writeEnabled ¬ TRUE;      IF shouldBeWritingToc THEN CleanupToc[h] ELSE ReadOnlyToc[h];      h.writeEnabled ¬ shouldBeWritingToc};    END;  GrowInfo: PROC [h: Handle, minMessages: CARDINAL] = {    old: LONG POINTER TO Ops.InfoSequence ¬ h.info;    SELECT minMessages FROM      <= old.maxLength => RETURN;      <= old.maxLength + 20 => minMessages ¬ old.maxLength + 20;      ENDCASE;    AllocateInfo[h, minMessages];    h.info.length ¬ old.length;    [] ¬ Inline.LongCOPY[      from: @old[0], to: @h.info[0], nwords: old.length*SIZE[Ops.Info]];    FreeInfo[old]};  -- Toc Handling procedures - parsing and making toc lines  WriteTocEntry: PROC [h: Handle, msg: MsgNumber, user: Name]    RETURNS [packed: Time.Packed] = {    Put: Format.StringProc = {h.tocStream.PutString[s]};    dateL: CARDINAL = 6;    fromL: CARDINAL = 16;    consumed: CARDINAL = 2 + dateL + 2 + fromL + 2 + 1 --CR--;    date: STRING = [dateL];    from: STRING = [fromL];    subject: STRING = [maxTocLine - consumed];    packed ¬ ParseHeader[h, msg, from, subject, user];    FillInDate[packed, date];    Format.Text[Put, date];    Format.Blanks[Put, 2];    Format.Text[Put, from];    Format.Blanks[Put, from.maxlength + 2 - from.length];    Format.Text[Put, subject]};  ExtendToc: PUBLIC PROC [h: Handle, before: MsgNumber] = {    msg: MsgNumber ¬ h.info.length;    length: LONG CARDINAL = MStream.GetLength[h.stream];    tocPos: LONG CARDINAL ¬ h.header.infoStart;    user: Name;    GetLoggedOnUser: PROC RETURNS [user: Name] =      BEGIN      GetCreds: PROCEDURE [name, password: LONG STRING] = {	STR: PROC [s: LONG STRING] RETURNS [NSString.String] = INLINE {	  RETURN[NSString.StringFromMesaString[s]] };	user ¬ NSName.NameFromString[MailUtil.zone, STR[name]] };      Profile.GetUser[GetCreds, clearinghouse];      END;        user ¬ GetLoggedOnUser[];    h.header.dirty ¬ TRUE;    PutHeader[h, h.tocStream];    h.tocStream.SetPosition[tocPos];    MStream.SetLength[h.tocStream, tocPos];    WHILE h.header.parsedLength < length AND msg < 2500 DO      msg ¬ h.info.length;      IF msg >= h.info.maxLength THEN GrowInfo[h, msg + 1];      h.info.length ¬ h.info.length + 1;      h.stream.SetPosition[h.header.parsedLength];      h.info[msg] ¬ [pos: h.header.parsedLength, tocPos: tocPos];<<	.length, .attributes, .flag & .stampLength filled in by ParseStamp	.date & .tocLength fields filled in below>>      ParseStamp[h, msg, length];      h.info[msg].date ¬ WriteTocEntry[h, msg, user];      tocPos ¬ h.tocStream.GetPosition[];      h.info[msg].tocLength ¬ CARDINAL[tocPos - h.info[msg].tocPos];      h.header.parsedLength ¬ h.header.parsedLength + h.info[msg].length;      ENDLOOP;    h.header.infoStart ¬ tocPos;    PutInfo[h, h.tocStream];    NSName.FreeName[MailUtil.zone, user]};  FilterOne: PUBLIC PROCEDURE [mf: Handle, msg: MsgNumber,    headerData: MailFile.HeaderData,    filterFieldBody: LONG STRING] =    BEGIN      ENABLE MailParse.Error => CONTINUE;    fieldName: LONG STRING = [40];    fieldType: MailFile.FieldType;    firstPos: LONG CARDINAL ¬ mf.info[msg].pos + mf.info[msg].stampLength;    lastPosPlusOne: LONG CARDINAL = mf.info[msg].pos + mf.info[msg].length;    nextPos: LONG CARDINAL ¬ firstPos;    parseH: MailParse.Handle;    skipFieldBody: LONG STRING = [0];    Next: PROCEDURE RETURNS [c: CHARACTER] =      BEGIN      IF nextPos >= lastPosPlusOne        THEN c ¬ MailParse.endOfInput        ELSE	  BEGIN	  c ¬ mf.stream.GetChar[];	  nextPos ¬ nextPos + 1;	  END;      END;    BEGIN ENABLE UNWIND => IF parseH # NIL THEN MailParse.Finalize[parseH];    MailFile.ResetHeaderData[headerData];    mf.stream.SetPosition[firstPos];    parseH ¬ MailParse.Initialize[Next];    WHILE MailParse.GetFieldName[parseH, fieldName] DO      -- ASSUME: Want to look at multiple "To:" fields, etc., so      --   can't stop looking until end of header.      fieldType ¬ MailFile.GetFieldType[fieldName];      SELECT fieldType FROM	from, recipients, subject =>	  BEGIN	  [] ¬ MailParse.GetFieldBody[parseH, filterFieldBody];	    -- NOTE: MailParse.GetFieldBody first resets filterFieldBody.length.	  MailFile.AddToHeaderData[headerData, fieldType, filterFieldBody];	  END;	ENDCASE => [] ¬ MailParse.GetFieldBody[parseH, skipFieldBody];      ENDLOOP;    MailFile.FilterMessage[mf, msg, headerData];    END;  -- ENABLE UNWIND    IF parseH # NIL THEN MailParse.Finalize[parseH];    END;  ParseStamp: PROC [h: Handle, msg: MsgNumber, lastPosPlusOne: LONG CARDINAL] = {    CheckFor: PROC [c: CHARACTER] = {      IF h.stream.GetChar[] # c THEN        ERROR Ops.BadFormat[msg, h.stream.GetPosition[] - 1]};    Digit: PROC RETURNS [dig: CARDINAL] = {      c: CHARACTER = h.stream.GetChar[];      RETURN[SELECT c FROM        IN ['0..'9] => c - '0,	ENDCASE => ERROR Ops.BadFormat[msg, h.stream.GetPosition[] - 1]]};    GetTwoNumbers: PROC RETURNS [first, second: CARDINAL] = {      first ¬ second ¬ 0;      THROUGH [0..5) DO first ¬ first*10 + Digit[] ENDLOOP;      CheckFor[Ascii.SP];      THROUGH [0..5) DO second ¬ second*10 + Digit[] ENDLOOP;      CheckFor[Ascii.SP]};    maxRoom: LONG CARDINAL = lastPosPlusOne - h.info[msg].pos;    endStampPos: LONG INTEGER;    IF maxRoom < Ops.standardStampLength THEN      Ops.BadFormat[msg, h.info[msg].pos];    FOR i: CARDINAL IN [0..Ops.starStampStar.length) DO      CheckFor[Ops.starStampStar[i]] ENDLOOP;    [h.info[msg].length, h.info[msg].stampLength] ¬ GetTwoNumbers[];    endStampPos ¬ h.info[msg].pos + h.info[msg].stampLength;    IF maxRoom < h.info[msg].stampLength OR maxRoom < h.info[msg].length THEN      Ops.BadFormat[msg, h.info[msg].pos];    h.info[msg].attributes[noAttributes] ¬ TRUE; -- changed if msgAttributes found    h.info[msg].attributes[deleted] ¬       SELECT h.stream.GetChar[] FROM        Ops.deleteFlag => TRUE,	Ops.undeleteFlag => FALSE,	ENDCASE => ERROR Ops.BadFormat[msg, h.stream.GetPosition[] - 1];    h.info[msg].attributes[examined] ¬      SELECT h.stream.GetChar[] FROM        Ops.examinedFlag => TRUE,	Ops.unexaminedFlag => FALSE,	ENDCASE => ERROR Ops.BadFormat[msg, h.stream.GetPosition[] - 1];    h.info[msg].flag ¬ h.stream.GetChar[];    CheckFor[Ascii.CR];    IF h.info[msg].stampLength = Ops.standardStampLength THEN RETURN;    -- now try for optional part of stamp    CheckFor['@];    DO      IgnoreItem: PROC = {        THROUGH [0..itemLength - Ops.itemOverhead) DO	  [] ¬ h.stream.GetChar[] ENDLOOP};      itemLength, t: CARDINAL;      itemType: BodyDefs.ItemType;      SELECT INT[endStampPos - h.stream.GetPosition[]] FROM        1 => {CheckFor['@]; RETURN};        2 => {CheckFor['@]; CheckFor[Ascii.CR]; RETURN};	< 12 => ERROR Ops.BadFormat[msg, h.stream.GetPosition[] - 1];	ENDCASE;      [itemLength, t] ¬ GetTwoNumbers[];      itemType ¬ VAL[t];      SELECT itemType FROM	Ops.msgAttributes => {	  IF itemLength # Ops.attributesItemLength THEN IgnoreItem[]	  ELSE {	    FOR a: MailFile.AttributeIndex IN MailFile.AttributeIndex DO	      h.info[msg].attributes[a] ¬ (h.stream.GetChar[] = 't);	      ENDLOOP;	    CheckFor[Ascii.CR]}};	Ops.msgClasses => Ops.ParseClasses[h, itemLength];	ENDCASE => IgnoreItem[];      ENDLOOP};      MyNameInList: PROCEDURE [mf: Handle,    inputList, parsedName: LONG STRING, user: Name]    RETURNS [nameInList: BOOLEAN ¬ FALSE] =    BEGIN OPEN S: NSString;    nextPos: CARDINAL ¬ 0;    CheckFromMe: MailParse.ProcessProc = {    << This procedure only picks up the first name in 'inputList' to put into     'parsedName'. However, it checks all of the names in the inputList to see     if it is potentially the user currently running Hardy.>>      IF nameInList THEN RETURN[FALSE]; -- don't bother checking any more      IF NSName.EquivalentNames[name, user] OR        (NSString.EquivalentStrings[name.local, user.local] AND	  name.domain = NSString.nullString AND	  name.org = NSString.nullString) THEN {        nameInList ¬ TRUE; RETURN[FALSE] };      RETURN[TRUE]};    NextChar: PROC RETURNS [c: CHARACTER] = {      IF nextPos >= inputList.length THEN c ¬ MailParse.endOfList      ELSE {c ¬ inputList[nextPos]; nextPos ¬ nextPos + 1}};    WriteIt: MailParse.WriteProc = {      String.AppendString[parsedName, string !        String.StringBoundsFault => RESUME[NIL]] };    mp: MailParse.Handle = MailParse.Initialize[NextChar];    MailParse.NameList[mp,,CheckFromMe, NIL, NIL, WriteIt !      MailParse.Error => {nameInList ¬ FALSE; CONTINUE}];    MailParse.Finalize[mp];    END;      ParseHeader: PROCEDURE [    mf: Handle, msg: MsgNumber, from, subject: LONG STRING, user: Name]    RETURNS [dateTime: Time.Packed] =    BEGIN    nextPos: LONG CARDINAL ¬ mf.info[msg].pos + mf.info[msg].stampLength;    lastPosPlusOne: LONG CARDINAL = mf.info[msg].pos + mf.info[msg].length;    Next: PROC RETURNS [c: CHARACTER] = {      IF nextPos >= lastPosPlusOne THEN c ¬ MailParse.endOfInput      ELSE {c ¬ mf.stream.GetChar[]; nextPos ¬ nextPos + 1}};    fieldName: STRING = [40];    dateString: STRING = [50];    fromString: STRING = [maxNameLength];    fromParsed: STRING = [maxNameLength];    toString: STRING = [maxNameLength];    mp: MailParse.Handle = MailParse.Initialize[Next];    BEGIN ENABLE {    MailParse.Error => GOTO doneWithThisOne;    String.StringBoundsFault => CONTINUE};    WHILE MailParse.GetFieldName[mp, fieldName] DO      SELECT TRUE FROM	String.Equivalent[fieldName, "From"L] => {	 [] ¬ MailParse.GetFieldBody[mp, fromString]};	String.Equivalent[fieldName, "Date"L] =>	 [] ¬  MailParse.GetFieldBody[mp, dateString];	String.Equivalent[fieldName, "Subject"L] =>	 [] ¬  MailParse.GetFieldBody[mp, subject];	String.Equivalent[fieldName, "To"L] =>	 [] ¬  MailParse.GetFieldBody[mp, toString];	ENDCASE => {dummy: STRING = [0]; [] ¬ MailParse.GetFieldBody[mp, dummy]};      IF fromString.length > 0 AND subject.length > 0 AND        toString.length > 0 AND dateString.length > 0 THEN EXIT;      ENDLOOP;    EXITS doneWithThisOne => NULL;    END -- ENABLE --;    MailParse.Finalize[mp];    BEGIN ENABLE String.StringBoundsFault => RESUME[NIL];    IF MyNameInList[mf, fromString, fromParsed, user] THEN {      String.AppendString[from, "To: "L];      String.AppendString[        from, IF toString.length = 0 THEN "  NOBODY"L ELSE toString]}    ELSE String.AppendString[from, fromParsed];    IF from.length = 0 THEN String.AppendString[from, fromString];    END; -- of ENABLE    dateTime ¬ Date.StringToPacked[dateString !       Date.Unintelligible => {dateTime ¬ System.gmtEpoch; CONTINUE}].dt;    IF from.length = 0 THEN String.AppendString[from, "  ANONYMOUS"L];    IF subject.length = 0 THEN String.AppendString[subject, "  <none>"L];    END;  FillInDate: PROC [packed: Time.Packed, date: LONG STRING] = {    IF packed = System.gmtEpoch THEN String.AppendString[date, " ---- "L]    ELSE {      unpacked: Time.Unpacked = Time.Unpack[packed];      twoDig: Format.NumberFormat = [columns: 2];      twoDigZero: Format.NumberFormat = [zerofill: TRUE, columns: 2];      Proc: Format.StringProc = {String.AppendString[date, s]};      months: ARRAY [0..12) OF STRING = [        "Jan "L, "Feb "L, "Mar "L, "Apr "L, "May "L, "Jun "L,        "Jul "L, "Aug "L, "Sep "L, "Oct "L, "Nov "L, "Dec "L];      Format.Text[Proc, months[unpacked.month]];      Format.Number[Proc, unpacked.day, twoDig];<< do we want the time in the TOC      Format.Char[Proc, Ascii.SP];      Format.Number[Proc, unpacked.hour, twoDig];      Format.Char[Proc, ':];      Format.Number[Proc, unpacked.minute, twoDigZero];>>      }};  END...  
-- File: MailParseImpl.mesa - Last edit by-- AlHall:	10-Aug-84 12:18:10-- Wobber:	19-Dec-83 16:26:27-- NS     :	13-Feb-85 14:42:04-- BGY     :	28-Aug-85 19:23:01-- NS     :	19-Sep-85 11:50:25DIRECTORY  Ascii USING [CR, SP, TAB],  FileName USING [AllocVFN, Error ,FreeVFN, VFN],  FileTransfer USING [Connection, Create, Destroy, Error, GetStreamInfo, ReadStream],  MailPost USING [Handle, zone], -- MailUtil,  MailParse USING [endOfInput, endOfList, ErrorCode, ProcessProc, WriteProc],  NSName USING [Error, FreeName, Name, NameFromString],  NSString USING [AppendToMesaString, StringFromMesaString],  Stream USING [Handle, Delete, EndOfStream, GetChar],  String USING [AppendChar, AppendExtensionIfNeeded, AppendString,   FreeString, MakeString, StringBoundsFault];MailParseImpl: PROGRAM  IMPORTS FileName, FileTransfer, --MailUtil,-- MailPost, NSName,  NSString, Stream, String  EXPORTS MailParse =  BEGIN  z: UNCOUNTED ZONE = MailPost.zone;  Handle: TYPE = LONG POINTER TO Object;  Object: PUBLIC TYPE = RECORD [    nextChar: PROCEDURE RETURNS [CHARACTER], peekChar: CHARACTER ¬ noSuchChar];  SpaceState: TYPE = {initial, white, black};  WriteProc: TYPE = MailParse.WriteProc;  ProcessProc: TYPE = MailParse.ProcessProc;  ErrorCode: TYPE = MailParse.ErrorCode;  eoInput: CHARACTER = MailParse.endOfInput;  eoList: CHARACTER = MailParse.endOfList;    noSuchChar: CHARACTER = 377C;    star: CHARACTER = '*;  comma: CHARACTER = ',;  colon: CHARACTER = ':;  at: CHARACTER = '@;  percent: CHARACTER = '%;  Error: PUBLIC ERROR [code: ErrorCode] = CODE;  Initialize: PUBLIC PROCEDURE [next: PROCEDURE RETURNS [CHARACTER]]    RETURNS [h: Handle] = {    h ¬ z.NEW[Object ¬ [nextChar: next, peekChar: next[]]]};  Finalize: PUBLIC PROCEDURE [h: Handle] = {z.FREE[@h]};  ConsumeWhiteSpace: PROCEDURE [h: Handle] = INLINE {    <<	This will not get all the "contiguous" white space if it is wrapped	onto a continutation line. That's OK because the next level up is	discarding the spaces anyway.>>    DO      SELECT h.peekChar FROM Ascii.SP, Ascii.TAB => [] ¬ Get[h]; ENDCASE => EXIT;      ENDLOOP};  DLMode: TYPE = {normal, realOnly, fakeOnly};    NameList: PUBLIC PROC [    h: Handle, m: MailPost.Handle, process: ProcessProc, default: NSName.Name,     fakeProcess: ProcessProc ¬ NIL, write: WriteProc ¬ NIL] =    BEGIN    eol, namesReported, pvtDL: BOOLEAN ¬ FALSE;    tempName: LONG STRING ¬ String.MakeString[z, 100];    printIt: BOOLEAN ¬ FALSE;    ReportName: PROC[state: DLMode] =      BEGIN      ENABLE NSName.Error => ERROR Error[illegalName];      name: NSName.Name;      i: CARDINAL ¬ tempName.length;            UNTIL i = 0 DO        SELECT tempName[i - 1] FROM          Ascii.SP, Ascii.TAB => i ¬ i - 1;          ENDCASE => EXIT;        ENDLOOP;      IF i = 0 THEN RETURN;      tempName.length ¬ i;      name ¬ NSName.NameFromString[        z, NSString.StringFromMesaString[tempName], default];      SELECT state FROM        normal => {	  IF fakeProcess # NIL THEN [] ¬ fakeProcess[h, name]; 	  printIt ¬ process[h, name]};        realOnly => printIt ¬ process[h, name];        fakeOnly => IF fakeProcess # NIL THEN [] ¬ fakeProcess[h, name];	ENDCASE;      IF printIt THEN {        tempName.length ¬ 0;        IF namesReported THEN String.AppendString[tempName, ", "L];        NSString.AppendToMesaString[tempName, name.local];        IF name.domain.length # 0 THEN {          String.AppendChar[tempName, ':];          NSString.AppendToMesaString[tempName, name.domain]};        IF name.org.length # 0 THEN {          String.AppendChar[tempName, ':];          NSString.AppendToMesaString[tempName, name.org]};        namesReported ¬ TRUE;        IF write # NIL THEN write[tempName];        };      NSName.FreeName[z, name];      END;          ParsePvtDL: PROC [h: MailPost.Handle]  = {          dl: FileName.VFN ¬ NIL;     fLength: LONG CARDINAL;     stream: Stream.Handle;     conn: FileTransfer.Connection;     mode: DLMode ¬ IF h.expandPvtDLs THEN normal ELSE realOnly;                    conn ¬ FileTransfer.Create[];     [] ¬ String.AppendExtensionIfNeeded[@tempName,".dl"L,z];     IF ~h.expandPvtDLs THEN ReportName[fakeOnly];     dl ¬ FileName.AllocVFN[tempName ! FileName.Error => {      FileTransfer.Destroy[conn];            GOTO badFile}];     stream ¬ FileTransfer.ReadStream[      conn: conn, files: dl, type: remote ! FileTransfer.Error => {        FileName.FreeVFN[dl]; FileTransfer.Destroy[conn];	GOTO badFile}];     FileName.FreeVFN[dl];     fLength ¬ FileTransfer.GetStreamInfo[stream].size;               tempName.length ¬ 0;     THROUGH [0..fLength] DO            c: CHARACTER = Stream.GetChar[stream ! Stream.EndOfStream =>          {ReportName[mode]; EXIT}];       IF (c = Ascii.CR) THEN {ReportName[mode]; tempName.length ¬ 0}        ELSE [] ¬ AppendChar[tempName,c];            ENDLOOP;     Stream.Delete[stream];     EXITS         badFile => RETURN;            };              UNTIL eol DO      tempName.length ¬ 0;      ConsumeWhiteSpace[h];      DO        char: CHARACTER ¬ Get[h];        SELECT char FROM          comma => EXIT;	  	  « temporary patch: if there's a long message, the gateway	  splits it into multiples, stuffs an * in the header fields,	  and labels it a continuation message.  right 	  now, * denotes private dl, so this generates an address fault.  	  checking if tempName has at least 1 character guarantees we're dealing	  with a file name and not a continuation header.  »	  	  star => {IF (tempName.length > 0 AND m # NIL)	   THEN {pvtDL ¬ TRUE; EXIT} ELSE [] ¬ AppendChar[tempName, char];};          eoInput => ERROR Error[endOfInput];          at => {            char ¬ percent;  -- substitute the percent for Hal            [] ¬ AppendChar[tempName, char]};          eoList, Ascii.CR => {eol ¬ TRUE; EXIT};          ENDCASE => [] ¬ AppendChar[tempName, char];        ENDLOOP;      IF pvtDL THEN {ParsePvtDL[m]; pvtDL ¬ FALSE;} ELSE ReportName[normal];      ENDLOOP;    String.FreeString[z,tempName];    END;  -- END NameList  -- utility procedures  StringForErrorCode: PUBLIC PROC [code: ErrorCode, s: LONG STRING] = {    String.AppendString[      to: s,      from:      SELECT code FROM        illegalName => "Malformed name"L,        fieldsAreAtoms => "Illegal field name"L,        colonExpected => "Colon expected"L,        endOfInput => "Unexpected end of header"L,        ENDCASE => "Syntax error"L ! String.StringBoundsFault => RESUME [NIL]]};  Get: PROCEDURE [h: Handle, checkWrap: BOOLEAN ¬ TRUE]    RETURNS [char: CHARACTER] =    -- obtains next input character and smoothes over a few lexical quirks.  This    -- procedure deals with Arpa-standard line-folding, except that bare CR    -- characters are not permitted.    BEGIN    char ¬ h.peekChar;    h.peekChar ¬ h.nextChar[];    SELECT char FROM      eoInput => NULL;      eoList => NULL;      Ascii.CR =>        IF checkWrap AND (h.peekChar = Ascii.SP OR h.peekChar = Ascii.TAB) THEN {          char ¬ h.peekChar; h.peekChar ¬ h.nextChar[]};      ENDCASE;    END;  -- routines used when not parsing name lists  AppendChar: PROCEDURE [s: LONG STRING, c: CHARACTER] RETURNS [BOOLEAN] = {    IF s.length >= s.maxlength THEN RETURN[TRUE];    s[s.length] ¬ c;    s.length ¬ s.length + 1;    RETURN[FALSE]};    -- eventually smooth out this parsing        GetFieldBody: PUBLIC PROCEDURE [    h: Handle, string: LONG STRING, suppressWhiteSpace: BOOLEAN]    RETURNS [truncated: BOOLEAN ¬ FALSE] = {    spaceState: SpaceState ¬ initial;    consumed: BOOLEAN ¬ FALSE;    c: CHAR;    string.length ¬ 0;    IF string.maxlength > 0 THEN {      DO        SELECT c ¬ Get[h] FROM          Ascii.SP, Ascii.TAB => {            IF spaceState # black THEN LOOP;            IF suppressWhiteSpace THEN {c ¬ Ascii.SP; spaceState ¬ white}};          eoList, Ascii.CR => {consumed ¬ TRUE; EXIT};          eoInput => ERROR Error[endOfInput];          ENDCASE => spaceState ¬ black;        IF (truncated ¬ AppendChar[string, c]) THEN EXIT;	         ENDLOOP;      -- and now remove the trailing white space      WHILE string.length > 0 AND string[string.length - 1] = Ascii.SP DO        string.length ¬ string.length - 1; ENDLOOP;      IF consumed THEN RETURN};    DO  -- faster loop for discarding      SELECT c ¬ Get[h] FROM        Ascii.CR, eoList => EXIT;        eoInput => ERROR Error[endOfInput];        ENDCASE;      ENDLOOP};  GetFieldName: PUBLIC PROC [h: Handle, field: LONG STRING] RETURNS [BOOLEAN] = {    sawSpace: BOOLEAN ¬ FALSE;    c: CHARACTER;    field.length ¬ 0;    DO      SELECT c ¬ Get[h, FALSE] FROM        Ascii.CR, eoInput =>          IF field.length = 0 THEN RETURN[FALSE] ELSE ERROR Error[fieldsAreAtoms];        < 40C => ERROR Error[fieldsAreAtoms];        > 177C => ERROR Error[fieldsAreAtoms];        Ascii.SP => sawSpace ¬ TRUE;        ': => RETURN[TRUE];        ENDCASE => {          IF sawSpace THEN ERROR Error[colonExpected];          IF field.length < field.maxlength THEN String.AppendChar[field, c]};      ENDLOOP};  END.      --log  --NS     : 31-Jan-85 18:52:38 added @-sign conversion to %-sign for GV parsing   --NS       13-Feb-85 14:42:30 implemented private dls  --NS	     19-Sep-85 11:50:57 fixed an address fault in ParsePvtDls
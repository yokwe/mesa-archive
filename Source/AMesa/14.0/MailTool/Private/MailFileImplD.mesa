-- File: MailFileImplD.mesa - last edit by:-- AlHall,	29-May-84 20:33:03-- PXK    ,	24-Jun-83 18:58:56-- BGY    ,	25-Apr-86 13:21:26DIRECTORY  Environment USING [Block, bytesPerPage],  Heap USING [Error],  MailFile USING [Error, MsgNumber, nullMessage],  MailFileOps USING [CleanupToc, DirtyToc, Info, Object, z],  MStream USING [SetLength],  QuickSort USING [CompareProc, Sort, SwapProc],  Stream USING [GetBlock, Handle, PutBlock, SetPosition],  System USING [SecondsSinceEpoch];MailFileImplD: MONITOR LOCKS h USING h: Handle  IMPORTS    Heap, MailFile, MailFileOps, MStream, QuickSort, Stream, System  EXPORTS MailFile =  BEGIN OPEN Ops: MailFileOps;  Handle: TYPE = LONG POINTER TO Object;  Object: PUBLIC TYPE = Ops.Object;    MsgNumber: TYPE = MailFile.MsgNumber;<<	Assert that TOC entries are in the same order as the messages	since that is the order in which they get written and they are	never rearranged. Thus, a single ordering for both files will suffice.	The plan is to move the messages up (closer to index=0) and therefore	the file will never get bigger as a result of doing an expunge.>>  FileOrder: TYPE = RECORD [    pos: LONG CARDINAL,    msg: MsgNumber];  FOSort: TYPE = LONG POINTER TO FileOrderSortSequence;  FileOrderSortSequence: TYPE = RECORD [    items: SEQUENCE length: MsgNumber OF FileOrder];  -- utility routines  MoveChars: PROC [    stream: Stream.Handle, scratch: Environment.Block,    from, to: LONG CARDINAL, length: LONG CARDINAL] = {    room: CARDINAL = scratch.stopIndexPlusOne - scratch.startIndex;    forward: BOOLEAN ¬ from > to;  -- always TRUE!    IF from = to THEN RETURN;    IF ~forward THEN {to ¬ to + length; from ¬ from + length};    WHILE length > 0 DO      bytes: CARDINAL = IF length < room THEN CARDINAL[length] ELSE room;      IF ~forward THEN {to ¬ to - bytes; from ¬ from - bytes};      scratch.stopIndexPlusOne ¬ scratch.startIndex + bytes;      stream.SetPosition[from];      [] ¬ stream.GetBlock[scratch];      stream.SetPosition[to];      stream.PutBlock[scratch];      length ¬ length - bytes;      IF forward THEN {to ¬ to + bytes; from ¬ from + bytes};      ENDLOOP;    RETURN};  -- removing deleted messages  Expunge: PUBLIC ENTRY PROC [h: Handle] =    BEGIN    ENABLE UNWIND => NULL;    NodeBody: TYPE = RECORD[SEQUENCE COMPUTED CARDINAL OF WORD];    bytes: CARDINAL = 20 * Environment.bytesPerPage;    scratchSpace: LONG POINTER;    position: LONG CARDINAL ¬ 0;    tocPosition: LONG CARDINAL ¬ 0;    fo: FOSort;    IF ~h.writeEnabled THEN ERROR MailFile.Error[access];    IF ~RemoveDeleted[h] THEN RETURN;    Ops.DirtyToc[h];    scratchSpace ¬ Ops.z.NEW[NodeBody[bytes/2]];    fo ¬ SortByFileOrder[h ! Heap.Error => {      Ops.z.FREE[@scratchSpace]; GOTO noRoom}];    FOR msg: MsgNumber IN [0..h.info.length) DO      IF fo[msg].msg = MailFile.nullMessage THEN {        MoveChars[	  stream: h.stream, scratch: [scratchSpace, 0, bytes],	  to: position, from: h.header.classPos, length: h.header.classLength];	h.header.classPos ¬ position;	position ¬ position + h.header.classLength}      ELSE {        info: LONG POINTER TO Ops.Info = @h.info[fo[msg].msg];        MoveChars[	  stream: h.stream, scratch: [scratchSpace, 0, bytes],	  to: position, from: info.pos, length: info.length];        info.pos ¬ position;        position ¬ position + info.length;        MoveChars[	  stream: h.tocStream, scratch: [scratchSpace, 0, bytes],	  to: tocPosition, from: info.tocPos, length: info.tocLength];        info.tocPos ¬ tocPosition;	tocPosition ¬ tocPosition + info.tocLength};      ENDLOOP;    MStream.SetLength[h.stream, position];    h.header.parsedLength ¬ position;    h.header.infoStart ¬ tocPosition;    Ops.z.FREE[@fo];    Ops.z.FREE[@scratchSpace];    Ops.CleanupToc[h];    EXITS noRoom => {Ops.CleanupToc[h]; ERROR MailFile.Error[volumeFull]};    END;  SortByFileOrder: PROC [h: Handle] RETURNS [fo: FOSort] = {    hasClass: BOOLEAN = h.header.hasClasses;    fo ¬ Ops.z.NEW[FileOrderSortSequence[      h.info.length + (IF hasClass THEN 1 ELSE 0)]];    FOR m: MsgNumber IN [0..fo.length) DO      fo[m] ¬ [h.info[m].pos, m] ENDLOOP;    IF hasClass THEN fo[fo.length - 1] ¬ [      h.header.classPos, MailFile.nullMessage];    QuickSort.Sort[0, fo.length-1, CompareFileOrder, SwapFileOrder, fo]};    CompareFileOrder: QuickSort.CompareProc = {    fo: FOSort = data;    RETURN[      SELECT fo[one].pos FROM        < fo[two].pos => smaller,        > fo[two].pos => bigger,        ENDCASE => same]};    SwapFileOrder: QuickSort.SwapProc = {    fo: FOSort = data;    temp: FileOrder = fo[one];    fo[one] ¬ fo[two];    fo[two] ¬ temp};    RemoveDeleted: PROC [h: Handle] RETURNS [BOOLEAN] = {    length: MsgNumber ¬ 0;    oldLength: MsgNumber = h.info.length;    FOR i: MsgNumber IN [0..oldLength) DO      IF ~h.info[i].attributes[deleted] OR h.info[i].attributes[attachments] THEN {        IF i # length THEN h.info[length] ¬ h.info[i];	length ¬ length + 1};      ENDLOOP;    h.info.length ¬ length;    RETURN[length # oldLength]};  -- sorting by date  Sort: PUBLIC ENTRY PROC [h: Handle, oldCurrent: MsgNumber]    RETURNS [alreadySorted: BOOLEAN, newCurrent: MsgNumber] =    BEGIN    startPos: LONG CARDINAL;    IF ~h.writeEnabled THEN ERROR MailFile.Error[access];    IF oldCurrent # MailFile.nullMessage THEN      startPos ¬ h.info[oldCurrent].tocPos;    IF SortByDate[h] THEN {      Ops.DirtyToc[h];      newCurrent ¬ MailFile.nullMessage;      IF oldCurrent # MailFile.nullMessage THEN	FOR i: MsgNumber IN [0..h.info.length) DO	  IF h.info[i].tocPos = startPos THEN {newCurrent ¬ i; EXIT};	  ENDLOOP;      RETURN[FALSE, newCurrent]};    RETURN[TRUE, MailFile.nullMessage];    END;  SortByDate: PROC [h: Handle] RETURNS [BOOLEAN] = {    IF h.info.length <= 1 THEN RETURN[FALSE];    FOR m: MsgNumber IN [0..h.info.length-1) DO      IF CompareDate[m, m+1, h] = bigger THEN {        QuickSort.Sort[0, h.info.length - 1, CompareDate, SwapDate, h];	RETURN[TRUE]};      ENDLOOP;    RETURN[FALSE]};    CompareDate: QuickSort.CompareProc = {    h: Handle = data;    l: LONG CARDINAL = System.SecondsSinceEpoch[h.info[one].date];    r: LONG CARDINAL = System.SecondsSinceEpoch[h.info[two].date];    RETURN[SELECT l FROM < r => smaller, > r => bigger, ENDCASE => same]};    SwapDate: QuickSort.SwapProc = {    h: Handle = data;    temp: Ops.Info = h.info[one];    h.info[one] ¬ h.info[two];    h.info[two] ¬ temp};  -- main line code  END...  
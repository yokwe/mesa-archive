-- File: MailTransfersA.mesa - last edit by:-- AH,	30-Sep-85 10:39:17 -- TW,	15-Dec-83 17:13:50-- NS,	17-Dec-85 11:30:34 -- BGY,	25-Apr-86 13:10:22 -- Copyright (C) 1985, 1986 by Xerox Corporation. All rights reserved.DIRECTORY  Auth,  Courier,  Environment,  Format,  Inbasket,  MailAttributes,  MailTransport,  MailUtil,  MFile,  NSAssignedTypes,  NSDataStream,  MailTransfer,  NSName,  NSString,  Process,  Stream,  String,  System,  TransferDefs,  UserInput;MailTransfersA: MONITOR LOCKS h.LOCK USING h: Handle  IMPORTS    Auth, Courier, Format, Inbasket, MailAttributes, MailTransport,    MailUtil, MFile, NSName, NSString, Process,     String, TransferDefs, UserInput  EXPORTS MailTransfer, TransferDefs =  BEGIN OPEN TransferDefs;  -- TYPEs:  Object: PUBLIC TYPE = TransferDefs.Object;  Handle: TYPE = LONG POINTER TO Object;  -- Variables, etc.:   sessionErrorString: PUBLIC LONG STRING ¬ NIL;  -- Initialized in PROC Init.  SkippingAttachment: PUBLIC SIGNAL = CODE;  userLoggedOff: PUBLIC BOOLEAN ¬ TRUE;  zone: PUBLIC UNCOUNTED ZONE ¬ MailUtil.zone;  mailBuffer: Buffer ¬ NIL;  lastType: PUBLIC ServerType ¬ secondary;  -- PUBLIC ENTRY PROCEDUREs:  --(None).  -- PUBLIC PROCEDURES:  AttachmentIDFromString: PUBLIC PROCEDURE [    zone: UNCOUNTED ZONE, string: NSString.String]    RETURNS [attachmentID: AttachmentID ¬ NIL] =    BEGIN    ENABLE      NSName.Error, NSName.NameTooSmall, NSString.StringBoundsFault,        String.InvalidNumber, String.StringBoundsFault => CONTINUE;  -- Bad format.    mailbox: LONG STRING ¬ [NSName.maxFullNameLength];    mesaString: LONG STRING ¬ [maxAttachmentIDStringLength];    messageIDWords: ARRAY [0..5) OF WORD;    offset: CARDINAL ¬ 0;    oneWord: LONG STRING ¬ [maxDigitsPerWord];    BEGIN    ENABLE UNWIND => IF attachmentID # NIL THEN zone.FREE[@attachmentID];    IF string = NSString.nullString THEN RETURN[NIL];    NSString.AppendToMesaString[mesaString, string];    FOR wordCount: CARDINAL IN [0..5) DO      FOR digit: CARDINAL IN [0..maxDigitsPerWord) DO        IF mesaString[offset] = separatorCharacter OR mesaString[offset] = '/ THEN          EXIT;        String.AppendChar[oneWord, mesaString[offset]];        offset ¬ offset + 1;        ENDLOOP;      messageIDWords[wordCount] ¬ String.StringToOctal[oneWord];      oneWord.length ¬ 0;      IF mesaString[offset] # separatorCharacter AND wordCount < 4 THEN        RETURN[NIL];  -- Bad format.      offset ¬ offset + 1;  -- Skip over separatorCharacter.      ENDLOOP;    IF mesaString[offset - 1] # '/ THEN RETURN[NIL];  -- Bad format.    mailbox.length ¬ mesaString.length - offset;    FOR i: CARDINAL IN [offset..mesaString.length) DO      mailbox[i - offset] ¬ mesaString[i]; ENDLOOP;    attachmentID ¬ zone.NEW[AttachmentIDRecord];    attachmentID.messageID ¬ LOOPHOLE[messageIDWords];    attachmentID.mailbox ¬ NSName.NameFromString[zone, STR[mailbox]];    END;  -- ENABLE UNWIND    -- Note: Don't free attachmentID on normal path.    END;  CheckReader: PUBLIC PROCEDURE [h: Handle] = {WakeWatcher[h]; };  CreateRead: PUBLIC PROC [    clientData: LONG POINTER,    stateProc: PROCEDURE [LONG POINTER, MailTransfer.MailboxState, STRING]]    RETURNS [h: Handle] = {    h ¬ zone.NEW[Object ¬ [clientData: clientData, stateProc: stateProc]];    FOR i: ServerType IN ServerType DO      h.servers[i].name ¬ zone.NEW[StringBody [NSName.maxFullNameLength]];       ENDLOOP;    Process.InitializeCondition[      @h.waitForWork, Process.SecondsToTicks[mailPollInterval]];    h.watcherProcess ¬ FORK WatchMailbox[h];    RETURN[h]};  DeleteAttachments: PUBLIC PROCEDURE [    handle: Handle, attachmentIDs: LONG DESCRIPTOR FOR ARRAY OF AttachmentID,    post: PostProc] RETURNS [deleted: BOOLEAN ¬ FALSE] =    BEGIN    pleaseDelete: DeleteSeqPtr;    session: Inbasket.Session;    h: Handle ¬ handle;    Cleanup: PROCEDURE = BEGIN KillSession[session]; END;    BEGIN    ENABLE UNWIND => Cleanup[];    FOR i: ServerType IN [primary..lastType] DO      session ¬ NewSession[h, i];      ReportState[h];      SELECT h.servers[i].state FROM        badName => post["Illegal user name ... "L, FALSE, TRUE];        badPwd => post["Illegal user password ... "L, FALSE, TRUE];        authProblem =>          post["Problem authenticating user or Mail Service ... "L, FALSE, TRUE];        noCH => post["Clearinghouse down ... "L, FALSE, TRUE];        noMailboxes => {«         post["User has no "L, FALSE, TRUE];          SELECT i FROM            primary => post["primary "L, FALSE, TRUE];            secondary => post["secondary "L, FALSE, TRUE];            ENDCASE => post["other "L, FALSE, TRUE];          post["mailbox "L, FALSE, TRUE]»	  };        accessProblem => post["Problem accessing mailbox ... "L, FALSE, TRUE];        down => {          post[h.servers[i].name, FALSE];          post[": didn't respond ... "L, FALSE, TRUE]};        empty, notEmpty =>          BEGIN          ENABLE {            Courier.Error, MailTransport.Error, Inbasket.InvalidIndex =>              BEGIN              post[h.servers[i].name, FALSE];              post[": ", FALSE];              post["failed ... "L, FALSE, TRUE];              CONTINUE;              END;            };          « This is more of a pain than it's worth. So I'm taking it out.	FOR i: CARDINAL IN [0..LENGTH[attachmentIDs]) DO	  IF attachmentIDs[i] # NIL AND	    NOT NSName.EquivalentNames[attachmentIDs[i].mailbox, h.name] THEN	    BEGIN	    post["Wrong user for Attachment-ID ... "L, FALSE, TRUE];	    Cleanup[];	    RETURN [FALSE];	    END; 	  ENDLOOP;  »          IF h.servers[i].lastRead = 0 THEN            -- Mailbox empty, so all attachments are already gone.            BEGIN Cleanup[]; RETURN[TRUE]; END;          pleaseDelete ¬ FindAttachmentIDsOnServer[h, session, i, attachmentIDs];          IF UserInput.UserAbort[NIL] THEN post["Aborted ... "L, FALSE, TRUE]          ELSE            BEGIN	    nDeleted: CARDINAL ¬             ChangeServer[h,              session, pleaseDelete, FALSE ! UNWIND => zone.FREE[@pleaseDelete]];	    h.servers[i].nLeft ¬ h.servers[i].nLeft - nDeleted;            deleted ¬ TRUE;            END;          zone.FREE[@pleaseDelete];          END;        ENDCASE => post["Bug ... "L, FALSE, TRUE];      KillSession[session];      ENDLOOP;    END;  -- ENABLE UNWIND        END;    SetState: PROC[h: Handle, i: ServerType, error: MailTransport.ErrorRecord] = {    h.servers[i].state ¬      WITH e: error SELECT FROM	access =>	  IF e.problem = mailboxNameIndeterminate THEN noCH ELSE accessProblem,	authentication =>	  SELECT e.problem FROM	    badPwdInIdentity => badPwd,	    ENDCASE => authProblem,	location =>	  SELECT e.problem FROM	    noCHAvailable => noCH,	    noSuchName => badName,	    ENDCASE => noMailboxes,	service => IF e.problem = cannotAuthenticate THEN noCH ELSE down,	ENDCASE => down;    IF i = secondary AND h.servers[i].state = noMailboxes THEN      lastType ¬ primary;    IF h.servers[i].state = badPwd THEN {      IF h.identity # NIL THEN Auth.FreeIdentity[@h.identity, zone];       userLoggedOff ¬TRUE};    MaybeZapMbxLocation[h, i];    };      DestroyRead: PUBLIC PROCEDURE [h: Handle] =    -- CODE:  It would be better if this forked a process    --   to do the following in the background so that it    --   doesn't take three minutes to deactivate in the    --   case that the net is down.  However, I tried this    --   at the last minute and there are race conditions that    --   need to be fixed up, so I changed it back.    BEGIN    h.stopping ¬ TRUE;    WakeWatcher[h];    JOIN h.watcherProcess;    FOR i: ServerType IN ServerType DO      IF h.servers[i].name # NIL THEN zone.FREE[@h.servers[i].name]; ENDLOOP;    IF h.name # NIL THEN NSName.FreeName[zone, h.name];    IF h.identity # NIL THEN Auth.FreeIdentity[@h.identity, zone];    zone.FREE[@h];    END;  FreeAttachmentID: PUBLIC PROCEDURE [    zone: UNCOUNTED ZONE, attachmentID: AttachmentID] =    BEGIN    IF attachmentID = NIL THEN RETURN;    IF attachmentID.mailbox # NIL THEN NSName.FreeName[zone, attachmentID.mailbox];    zone.FREE[@attachmentID];    END;  NewUser: PUBLIC PROCEDURE [h: Handle] =    BEGIN    IF h.settingCredentials THEN BEGIN h.setThemAgain ¬ TRUE; RETURN; END;    h.settingCredentials ¬ TRUE;    WakeWatcher[h];    END;  Retrieve: PUBLIC PROCEDURE [    handle: Handle, add: AddProc, post: PostProc, flushRemote,     getEnvelope, allAttachments: BOOLEAN ¬ FALSE] =    BEGIN    h: Handle ¬ handle;    finalOutcome: MessageOutcome;    nMsgs: CARDINAL;    pages: LONG CARDINAL;    session: Inbasket.Session;    PostString: Format.StringProc = {post[s, FALSE]; };    getAllAttachments ¬ allAttachments;    FOR i: ServerType IN [primary..lastType] DO      session ¬ NewSession[h, i];      IF getAllAttachments AND h.servers[i].state = empty THEN         h.servers[i].state ¬ notEmpty;      SELECT h.servers[i].state FROM        badName => post["Illegal user name "L, FALSE, TRUE];        badPwd => post["Illegal user password "L, FALSE, TRUE];        authProblem =>          post["Problem authenticating user or Mail Service "L, FALSE, TRUE];        noCH => post["Clearinghouse down "L, FALSE, TRUE];        noMailboxes => {«         post["User has no "L, FALSE, TRUE];          SELECT i FROM            primary => post["primary "L, FALSE, TRUE];            secondary => post["secondary "L, FALSE, TRUE];            ENDCASE => post["other "L, FALSE, TRUE];          post["mailbox "L, FALSE, TRUE]»	     };        accessProblem => post["Problem accessing mailbox "L, FALSE, TRUE];        down => {          post[h.servers[i].name, FALSE]; post[" ... didn't respond; "L, FALSE]; };        unknown, empty => {          post[h.servers[i].name, FALSE];	  post[" ... "L, FALSE];	  IF h.servers[i].nLeft # 0 THEN {	   Format.Decimal[PostString, h.servers[i].nLeft];	   IF h.servers[i].nLeft > 1 THEN	    post[" attachments.  "L, FALSE] ELSE	    post[" attachment.  "L, FALSE];	   }	  ELSE	   	   post["empty. "L, FALSE]; };        notEmpty =>          BEGIN          post[h.servers[i].name, FALSE];          post[" ... "L, FALSE];          [finalOutcome, nMsgs, h.servers[i].nLeft, pages] ¬ GetMessages[            h: h, i: i, add: add, post: post, 	    flushRemote: flushRemote, session: session];          SELECT finalOutcome FROM            failed => post["failed; "L, FALSE, TRUE];            userAborted => post["some messages skipped; "L, FALSE, TRUE];            ENDCASE => {	      Format.Decimal[PostString, nMsgs]; 	      post[", "L, FALSE];	      IF h.servers[i].nLeft # 0 THEN {	       Format.Decimal[PostString, h.servers[i].nLeft];	       IF h.servers[i].nLeft > 1 THEN	        post[" attachments.  "L, FALSE] ELSE	        post[" attachment.  "L, FALSE];	       };--	      Format.LongDecimal[PostString, pages];--	      post[" pages"L, FALSE];	      };          END;        ENDCASE => post["Bug"L, FALSE, TRUE];      KillSession[session];      ENDLOOP;    ReportState[h];    WakeWatcher[h];    END;  StringFromAttachmentID: PUBLIC PROCEDURE [    zone: UNCOUNTED ZONE, attachmentID: AttachmentID]    RETURNS [string: NSString.String ¬ NSString.nullString] =    BEGIN    messageIDString: LONG STRING ¬ [maxMessageIDStringLength];    messageIDWords: ARRAY [0..5) OF WORD;    IF attachmentID = NIL THEN RETURN;    messageIDWords ¬ LOOPHOLE[attachmentID.messageID];    String.AppendOctal[messageIDString, messageIDWords[0]];    FOR i: CARDINAL IN [1..5) DO      String.AppendChar[messageIDString, separatorCharacter];      String.AppendOctal[messageIDString, messageIDWords[i]];      ENDLOOP;    string ¬ NSString.MakeString[zone, maxAttachmentIDStringLength];    string ¬ NSString.AppendString[string, STR[messageIDString]];    string ¬ NSString.AppendString[string, STR["/"L]];    string ¬ NSName.AppendNameToString[string, attachmentID.mailbox];    END;  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --  GetMailboxInfo: PUBLIC PROC [h: Handle, i: ServerType] =    BEGIN    IF h.servers[i].location # NIL THEN {      MailTransport.FreeLocation[h.servers[i].location];      h.servers[i].location ¬ NIL;      };    h.servers[i].name.length ¬ 0;    IF userLoggedOff OR h.identity = NIL THEN RETURN;    h.servers[i].location ¬ MailTransport.GetLocation[h.identity, h.name, i];    NSString.AppendToMesaString[      h.servers[i].name, h.servers[i].location.serverName.local];    IF NOT      (NSString.EquivalentStrings[        h.servers[i].location.serverName.domain, h.name.domain]        OR NSString.EquivalentStrings[          h.servers[i].location.serverName.org, h.name.org]) THEN      BEGIN      String.AppendChar[h.servers[i].name, ':];      NSString.AppendToMesaString[        h.servers[i].name, h.servers[i].location.serverName.domain];      String.AppendChar[h.servers[i].name, ':];      NSString.AppendToMesaString[        h.servers[i].name, h.servers[i].location.serverName.org];      END;    END;  -- Private ENTRY PROCEDUREs:  CheckMailbox: PUBLIC ENTRY PROC [h: Handle, i: ServerType] =    BEGIN    lastIndex: Inbasket.Index ¬ Inbasket.nullIndex;    BEGIN    ENABLE {      UNWIND => NULL;      Courier.Error, MailTransport.Error => {        h.servers[i].state ¬ down; MaybeZapMbxLocation[h, i]; CONTINUE; }};    IF NOT h.validated OR userLoggedOff OR h.identity = NIL OR      h.servers[i].location = NIL THEN RETURN;    lastIndex ¬ Inbasket.MailPoll[      h.identity, h.name, h.servers[i].location].lastIndex;    IF lastIndex < h.servers[i].lastIndex THEN h.validated ¬ FALSE    ELSE {      h.servers[i].lastIndex ¬ lastIndex;      h.servers[i].state ¬      IF h.servers[i].lastRead = h.servers[i].lastIndex THEN empty ELSE notEmpty;      };    END;    END;  DoneSettingCredentials: PUBLIC ENTRY PROCEDURE [h: Handle] RETURNS [BOOLEAN] =    BEGIN    ENABLE UNWIND => NULL;    IF ~h.setThemAgain THEN {h.settingCredentials ¬ FALSE; RETURN[TRUE]};    h.setThemAgain ¬ FALSE;    RETURN[FALSE];    END;  BPP: CARDINAL = Environment.bytesPerPage;  GetMessages: PUBLIC ENTRY PROCEDURE [    h: Handle, i: ServerType, add: AddProc, post: PostProc, flushRemote: BOOLEAN,    session: Inbasket.Session]    RETURNS [      outcome: MessageOutcome ¬ none, nMsgs, nLeft: CARDINAL ¬ 0,      pages: LONG CARDINAL ¬ 0] =    BEGIN    ENABLE UNWIND => NULL;    bodyType: LONG CARDINAL;    buffer: Buffer ¬ NIL;    -- (Changed to look at messages seen by ITS).    numDeleted: CARDINAL ¬ 0;    pleaseDelete: DeleteSeqPtr ¬ NIL;    msgH: FetchHandle ¬ NIL;    Cleanup: PROCEDURE = {      fH, nextH: FetchHandle ¬ NIL;      FOR fH ¬ fetch, nextH UNTIL fH = NIL DO        nextH ¬ fH.next;	MailUtil.FreeEnvelope[fH.envelope];	zone.FREE[@fH];        ENDLOOP;      fetch ¬ NIL;      IF pleaseDelete # NIL THEN zone.FREE[@pleaseDelete];      };    ListOne: Inbasket.ListProc = {      [bodyType, outcome] ¬ DoListOne[        h: h, currentMsg: msg, props: props, buffer: buffer, 	add: add, post: post, flushRemote: flushRemote, pleaseDelete: pleaseDelete];      SELECT bodyType FROM        NSAssignedTypes.tEmpty, NSAssignedTypes.tText => NULL;	ENDCASE => {	  nLeft ¬ nLeft + 1;	  pages ¬ pages + ((props.env.transport.contentsSize+BPP-1)/LONG[BPP])};      IF UserInput.UserAbort[NIL] THEN outcome ¬ userAborted;      IF pleaseDelete[msg-firstMsg] THEN numDeleted ¬ numDeleted + 1;      IF outcome = stored THEN nMsgs ¬ nMsgs + 1;      continue ¬ SELECT outcome FROM        failed, userAborted, insufficientSpace => FALSE,	ENDCASE => TRUE;      };    BEGIN    ENABLE UNWIND => Cleanup[];    pleaseDelete ¬ zone.NEW[DeleteSeq [h.servers[i].lastIndex + 1 - firstMsg]];    FOR i: CARDINAL IN [0..pleaseDelete.length) DO      pleaseDelete[i] ¬ FALSE; ENDLOOP;    buffer ¬ MakeBuffer[];    IF buffer = NIL THEN {      post["insufficient space on volume.", FALSE]; Cleanup[]; GOTO phooey};    Inbasket.List[      session, [firstMsg, h.servers[i].lastIndex], [      TRUE, [TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE]], ListOne!      Courier.Error => {h.servers[i].state ¬ down; outcome ¬ failed; CONTINUE};      MailTransport.Error => {SetState[h, i, error]; outcome ¬ failed; CONTINUE};      Inbasket.InvalidIndex => {outcome ¬ failed; CONTINUE}];    SELECT outcome FROM      failed, userAborted, insufficientSpace => {Cleanup[]; RETURN};      ENDCASE;    BEGIN    noMore: SIGNAL = CODE;    ProcessEnvelope: INTERNAL PROC[f: FetchHandle] = {      IF f = NIL THEN RETURN      ELSE ProcessEnvelope[f.next];      [bodyType, outcome] ¬ GetOneMessage[        h: h, i: i, currentMsg: f.index, envelope: f.envelope, 	buffer: buffer, add: add, post: post, 	flushRemote: flushRemote, session: session];      SELECT outcome FROM        failed, userAborted, insufficientSpace => GOTO quit;        stored => nMsgs ¬ nMsgs + 1;        ENDCASE;      pleaseDelete[f.index - firstMsg] ¬ TRUE;      numDeleted ¬ numDeleted + 1;      EXITS quit => SIGNAL noMore;      };    ProcessEnvelope[fetch!noMore => GOTO nope];    END;    IF flushRemote THEN {      [] ¬  ChangeServer[h:h,        session: session, pleaseDelete: pleaseDelete, noteOthersWereReceived: TRUE,        firstMsg: firstMsg !        Courier.Error, MailTransport.Error, Inbasket.InvalidIndex => CONTINUE];      h.servers[i].state ¬ empty;      };    h.servers[i].lastRead ¬ h.servers[i].lastIndex ¬      (h.servers[i].lastIndex - numDeleted);    EXITS phooey => RETURN;      nope => NULL;    END;  -- ENABLE UNWIND    Cleanup[];    END;      FetchRecord: TYPE = RECORD[    next: FetchHandle,    envelope:  MailAttributes.Envelope,    index: Inbasket.Index];  FetchHandle: TYPE = LONG POINTER TO FetchRecord;  fetch: FetchHandle ¬ NIL;  DoListOne: PROCEDURE [    h: Handle, currentMsg: Inbasket.Index, props: MailAttributes.MailProperties,    buffer: Buffer, add: AddProc, post: PostProc, flushRemote: BOOLEAN,    pleaseDelete: DeleteSeqPtr]    RETURNS [bodyType: LONG CARDINAL, messageOutcome: MessageOutcome] = {    -- retrieve mailnotes and header of attachments,     -- mark mailnotes for deletion, mark attachments for status change    -- mark text bodies for future retrieval    BEGIN ENABLE {      SkippingAttachment, Courier.Error, MailTransport.Error, Inbasket.InvalidIndex,        Inbasket.ContentsTypeMismatch => CONTINUE;      MFile.Error => {        SELECT code FROM          noRoomOnVolume => {            post["MFile.Error => insufficient space on volume. ", FALSE];            messageOutcome ¬ insufficientSpace};          ENDCASE => NULL;        CONTINUE};      };    messageOutcome ¬ failed;    bodyType ¬ props.attrs.bodyType;    SELECT bodyType FROM      NSAssignedTypes.tEmpty => {        [bodyType, messageOutcome] ¬ InternalStore[	  h: h, envelope: @props.env, attributes: @props.attrs, 	  buffer: buffer, add: add, post: post, flushRemote: flushRemote, 	  serialStream: NIL];	pleaseDelete[currentMsg - firstMsg] ¬ TRUE;	};      NSAssignedTypes.tText => {        fetch ¬ zone.NEW[FetchRecord ¬ [	  next: fetch, 	  envelope: MailUtil.CopyEnvelope[@props.env], 	  index: currentMsg]];	RETURN[bodyType, none];        };      ENDCASE => {        [bodyType, messageOutcome] ¬ InternalStore[	  h: h, envelope: @props.env, attributes: @props.attrs, buffer: buffer, 	  add: add, post: post, flushRemote: flushRemote, serialStream: NIL]};    END;    };  GetOneMessage: INTERNAL PROCEDURE [    h: Handle, i: ServerType, currentMsg: Inbasket.Index,     envelope: MailAttributes.Envelope,     buffer: Buffer, add: AddProc,    post: PostProc, flushRemote: BOOLEAN, session: Inbasket.Session]    RETURNS [bodyType: LONG CARDINAL, messageOutcome: MessageOutcome] =    BEGIN    ENABLE {      MFile.Error =>        BEGIN        SELECT code FROM          noRoomOnVolume => {            post["MFile.Error => insufficient space on volume. ", FALSE];            messageOutcome ¬ insufficientSpace};          ENDCASE => NULL;        CONTINUE;        END;      MailTransport.Error => {        SetState[h, i, error]; messageOutcome ¬ failed; CONTINUE};      Courier.Error, Inbasket.InvalidIndex,        Inbasket.ContentsTypeMismatch => {messageOutcome ¬ failed; CONTINUE};      };    skippingAttachment: BOOLEAN ¬ FALSE;    extraEnvelope: EnvelopeRecord;    Cleanup: PROCEDURE =      BEGIN      IF extraEnvelope # nullEnvelopeRecord THEN        MailAttributes.ClearEnvelope[@extraEnvelope];      extraEnvelope ¬ nullEnvelopeRecord;      END;    GetMsg: INTERNAL PROCEDURE [sourceStream: NSDataStream.SourceStream] =      BEGIN      [bodyType, messageOutcome] ¬ StoreInMailFile[        h: h, sourceStream: sourceStream, envelope: envelope, buffer: buffer, 	add: add, post: post, flushRemote: flushRemote !        SkippingAttachment => {skippingAttachment ¬ TRUE; RESUME ; }; ];      END;    BEGIN    ENABLE UNWIND => Cleanup[];    IF UserInput.UserAbort[NIL] THEN {messageOutcome ¬ userAborted; RETURN; };    Inbasket.Retrieve[      session, currentMsg, MailTransport.ctSerializedFile, [proc[GetMsg]],      @extraEnvelope ! MailTransport.Error => CONTINUE];    END;  -- ENABLE UNWIND    Cleanup[];    END;  WaitForWork: ENTRY PROC [h: Handle] =    BEGIN ENABLE UNWIND => NULL; IF NOT h.stopping THEN WAIT h.waitForWork; END;  WakeWatcher: ENTRY PROC [h: Handle] =    BEGIN ENABLE UNWIND => NULL; NOTIFY h.waitForWork; END;  -- Private PROCEDUREs:  WatchMailbox: PROCEDURE [h: Handle] =    BEGIN    ENABLE ABORTED => CONTINUE;  -- (Since FORKed).    UNTIL h.stopping DO      IF h.settingCredentials THEN lastType ¬ secondary;      FOR i: ServerType IN [primary..lastType] DO        IF NOT h.validated OR h.settingCredentials OR h.servers[i].location = NIL          THEN KillSession[NewSession[h, i]];        IF h.validated AND h.servers[i].location # NIL THEN CheckMailbox[h, i];        ENDLOOP;      ReportState[h];      IF ~DoneSettingCredentials[h] THEN LOOP;      WaitForWork[h];      ENDLOOP;    END;      MakeBuffer: PROC RETURNS [buffer: Buffer] = {    IF mailBuffer # NIL THEN RETURN [mailBuffer];    mailBuffer ¬ zone.NEW[BufferBody];    RETURN[mailBuffer];    };      Unload: MailUtil.UnloadProc = {    IF mailBuffer # NIL THEN {      zone.FREE[@mailBuffer];      };    };  Init: PROCEDURE =     BEGIN     sessionErrorString ¬ String.MakeString[zone, 100];     [] ¬ MakeBuffer[];    MailUtil.RegisterUnloadProc[Unload, NIL];    END;  -- Mainline code  getAllAttachments: PUBLIC BOOLEAN ¬ FALSE;  Init[];  END.-- CHANGE LOG:-- AlHall, 15-Mar-85 12:56:46:  Added HardyVariant.verboseMode.  Cleaned up appearance of code.-- AlHall, 16-Aug-85 11:29:14:  Added ability to abort during retrieve of old attachments.  Fixed verboseMode a bit.  [Actually, I made these changes earlier, but both copies of the source code were lost].-- Nannette, 23-Aug-85 12:47:09: Added insufficientSpace error to MessageOutcome to allow tool to h space problems gracefully.-- AlHall, 30-Sep-85 10:14:10: Removed PROC DoTimedMailPoll rather than convert the whole thing to DoTimedGetLocation at the last minute; won't need to do TimedMumble next release, because the Clearinghouse and Mail Stubs should be able to take Process.Abort.  Corrected mailPollInterval from 200 to 300 seconds.  Kept from doing GetLocation more than once an hour in case of failure, and from doing it at all if the user is logged off.  Fixed a one-liner for verboseMode.-- Nannette, 30-Sep-85 11:40:35 caught malformed attribute from ReceiveAttributes-- Nannette, 17-Dec-85 11:30:58 added support for secondaries 
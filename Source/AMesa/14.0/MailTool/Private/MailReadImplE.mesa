-- MailReadImplE.mesa - last revised by:-- AlHall,	19-Jun-84 20:10:55-- Hamilton.ES,	18-Oct-83 22:24:40-- BGY		25-Apr-86 13:27:23DIRECTORY  Environment USING [Block, Byte, bytesPerPage],  Format USING [LongDecimal, StringProc],  Inline USING [LowHalf],  MailFile USING [    AddMessages, ErrorCode, Handle, MakeWritable, Messages, MsgNumber, nullMessage,    StartAnotherMessage],  MailReadOps USING [Data, FirstTOCMessage, ForceOut, FreeMailFile, GetCurrent],  MailTransfer USING [AddProc, PostProc],  MailUtil,  Selection USING [Convert, Source],  Stream USING [Delete, Handle, PutBlock, SendNow],  String USING [charsPerWord, LowerCase, WordsForString],  TextSource USING [Handle],  TextSW USING [InvalidRegions, ModifySource],  UserInput USING [UserAbort],  Window USING [Handle];MailReadImplE: PROGRAM  IMPORTS    Format, Inline, MailFile, MailReadOps, MailUtil, Selection, Stream,    String, TextSW, UserInput  EXPORTS MailReadOps =  BEGIN OPEN MailReadOps;  -- constants:  bufferPages: CARDINAL = 20;  bufferBytes: CARDINAL =    (bufferPages * Environment.bytesPerPage) -      (String.charsPerWord * String.WordsForString[0]);  Period: CHARACTER = '.;  -- types:  ModifySourceProc: TYPE = PROC [    window: Window.Handle, source: TextSource.Handle, data: MailReadOps.Data]    RETURNS [TextSW.InvalidRegions];  -- exported procs:  AppendMail: PUBLIC PROC [    data: MailReadOps.Data, post: MailTransfer.PostProc,    printError: PROC [MailFile.ErrorCode]]    RETURNS [newFirstTOC: MailFile.MsgNumber, normalFinish: BOOLEAN] =    -- the code that deals with the mail file (and its display) is from MailReadImplB.RetrieveNewMail    BEGIN    msgStream: Stream.Handle;    mf: MailFile.Handle = MailReadOps.GetCurrent[data];    firstRetrievedMsg, messageAtTop: MailFile.MsgNumber ¬ MailFile.nullMessage;    errorCode: MailFile.ErrorCode;    hadError: BOOLEAN ¬ FALSE;    selnLength: LONG POINTER TO LONG CARDINAL;    ExtendTOC: ModifySourceProc = {msgStream.Delete[]; RETURN[NIL]; };    AddMessage: MailTransfer.AddProc =      BEGIN      PutInMessageFile: ModifySourceProc = {        SELECT why FROM          first => {            MailFile.StartAnotherMessage[msgStream, messageLength, FALSE];            msgStream.PutBlock[block]};          continuing => msgStream.PutBlock[block];          done => msgStream.SendNow[];          ENDCASE => --EXHAUSTED-- ERROR;        RETURN[NIL]};      IF firstRetrievedMsg = MailFile.nullMessage THEN MailFile.MakeWritable[mf];      msgStream ¬ MailFile.AddMessages[mf];      firstRetrievedMsg ¬ MailFile.Messages[mf];      TextSW.ModifySource[data.bodySW, PutInMessageFile, data];      RETURN[UserInput.UserAbort[data.toolW]];      END;    selnLength ¬ Selection.Convert[length];    IF selnLength = NIL THEN {post["No selection!"L, TRUE, TRUE]; RETURN; };    SELECT selnLength­ FROM      0 => {post["Zero-length selection!"L, TRUE, TRUE]; RETURN; };      > bufferBytes =>        BEGIN        wn: Window.Handle = Selection.Convert[subwindow];        SELECT wn FROM          data.tocSW, data.bodySW => {            post["Too-long selection in toc or body sw!"L, TRUE, TRUE]; RETURN; };          ENDCASE;        END;      ENDCASE;    ReadText[selnLength­, AddMessage, post];    IF firstRetrievedMsg # MailFile.nullMessage THEN {      TextSW.ModifySource[data.tocSW, ExtendTOC, data];      messageAtTop ¬ MIN[        firstRetrievedMsg, MailReadOps.FirstTOCMessage[mf, data.tocLines]];      IF messageAtTop > 0 THEN messageAtTop ¬ messageAtTop - 1;      data.newMessage ¬ firstRetrievedMsg};    IF hadError THEN printError[errorCode];    MailReadOps.ForceOut[data, mf, mandatory];    MailReadOps.FreeMailFile[data, mf];    RETURN[      messageAtTop, NOT (hadError OR firstRetrievedMsg = MailFile.nullMessage)];    END;  -- of proc AppendMail  FreeString: PUBLIC PROC [form: LONG STRING] = {    MailUtil.zone.FREE[@form];    };      ReadText: PUBLIC PROC [    selnLen: LONG CARDINAL, add: MailTransfer.AddProc,    post: MailTransfer.PostProc] =    -- with thanks to MailTransfers.Retrieve    BEGIN    block: Environment.Block;    continuationHeader: LONG STRING =      "Date: *\nFrom: *\nSubject: Continuation of previous message\n\n"L;    firstChunk: BOOLEAN ¬ TRUE;    -- maxBuffersPerMsg: [0 .. 177777B / bufferBytes) = 177777B / bufferBytes - 2;    maxBytes: CARDINAL = 51200;  -- maxBuffersPerMsg * bufferBytes;	.. try 60K?!    selnLength: LONG CARDINAL = selnLen;  -- a copy, to be used at the end    source: Selection.Source = Selection.Convert[source];    text: LONG STRING ¬ MailUtil.zone.NEW[StringBody[bufferBytes]];    Proc: Format.StringProc = {post[s: s, eol: FALSE]; };    text­ ¬ StringBody[length: 0, maxlength: bufferBytes, text:];    block.blockPointer ¬ LOOPHOLE[@text.text];    block.startIndex ¬ 0;    WHILE selnLen > 0 DO  -- message chunks      ENABLE UNWIND => MailUtil.zone.FREE[@text];      ix: CARDINAL;      length: CARDINAL =        IF selnLen > maxBytes THEN maxBytes ELSE Inline.LowHalf[selnLen];      msgLen: CARDINAL ¬ length;      IF NOT firstChunk THEN        BEGIN        msgLen ¬ msgLen + continuationHeader.length;        [] ¬ add[          why: first,          block: [          LOOPHOLE[@continuationHeader.text], 0, continuationHeader.length],          messageLength: msgLen];        END;      ix ¬ 0;      WHILE ix < length DO  -- next block        source.proc[source.data, text];        block.stopIndexPlusOne ¬ text.length;        [] ¬ add[          IF ix = 0 AND firstChunk THEN first ELSE continuing, block, msgLen];        ix ¬ ix + text.length;        ENDLOOP;  -- next block      selnLen ¬ selnLen - ix;      IF selnLen = 0 THEN source.destroy[source];      block.stopIndexPlusOne ¬ 0;      [] ¬ add[done, block, msgLen];  -- done with message (although it may continue on)      firstChunk ¬ FALSE;      ENDLOOP;  -- message chunk    MailUtil.zone.FREE[@text];    -- [] ¬ add [first, [NIL, 0, 0], 0];    Format.LongDecimal[Proc, selnLength];    post[s: " character message added ... "L, eol: FALSE];    END;  -- of proc ReadText  -- private procs:  CheckForArpaGateway: PROC [name: LONG STRING] =    BEGIN    ArpaGateway: STRING = "arpagateway"L;  -- all lower case!    ix2: CARDINAL;    periodIx: CARDINAL = (name.length - ArpaGateway.length - 1);    IF LOOPHOLE[periodIx, INTEGER] < 2 THEN RETURN;  -- name's too short    IF name[periodIx] # Period THEN RETURN;    ix2 ¬ 0;    FOR ix1: CARDINAL IN (periodIx..name.length) DO      IF String.LowerCase[name[ix1]] # ArpaGateway[ix2] THEN RETURN;      ix2 ¬ ix2 + 1;      ENDLOOP;    name.length ¬ periodIx;  -- remove ".ArpaGateway"    END;  -- of proc CheckForArpaGateway  -- HardyExtrasImpl's mainline code:  -- (none)  END.	-- of program HardyExtrasImpl-- Peter A. Arndt - Created18-Oct-83 22:13:15 - BXM   Hamilton.ES - Convert to Klamath
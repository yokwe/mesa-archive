-- File: MailFile.mesa  - Last edited by-- AlHall	31-May-84 11:25:16-- PXK    	22-Sep-83 17:12:22-- JGS    	20-Mar-81  9:37:25-- RXJ     	15-Dec-81 15:28:53DIRECTORY  Ascii USING [SP],  MFile USING [Handle, ReleaseChoice],  Stream USING [Handle];  MailFile: DEFINITIONS =  BEGIN  -- Types and Constants --  Handle: TYPE = LONG POINTER TO Object;  Object: TYPE;  nullHandle: Handle = NIL;    StreamPiece: TYPE = RECORD [    stream: Stream.Handle,    first, lastPlusOne: LONG CARDINAL];    MsgNumber: TYPE = CARDINAL;  Flag: TYPE = CHARACTER;  nullMessage: MsgNumber = LAST[CARDINAL];    CharProc: TYPE = PROCEDURE RETURNS [CHARACTER];  Enumerator: TYPE = PROCEDURE [msg: MsgNumber] RETURNS [BOOLEAN];  AttributeIndex: TYPE = MACHINE DEPENDENT {    deleted(0), examined(1), classes(2), answered(3), noAttributes(4),    attachments(5), firstClass(8), lastClass(31)};  ClassIndex: TYPE = AttributeIndex[firstClass..lastClass];  Attributes: TYPE = PACKED ARRAY AttributeIndex OF Attribute _ ALL[];  Attribute: TYPE = BOOLEAN _ FALSE;    LetGoChoice: TYPE = MFile.ReleaseChoice;  LetGo: TYPE = PROCEDURE [    handle: Handle, clientData: LONG POINTER TO UNSPECIFIED]    RETURNS [LetGoChoice];  FieldType: TYPE = {from, recipients, subject, other};  HeaderData: TYPE = LONG POINTER TO HeaderDataRecord;  HeaderDataField: TYPE = LONG STRING;  HeaderDataRecord: TYPE = RECORD [    from,    recipients,    subject: HeaderDataField ¬ NIL];        -- Signals --  ErrorCode: TYPE = {    tooManyMessages, messageTooLarge, fileBusy, fileNotFound, fileHasBadFormat,    classIsNotEmpty, classExists, noSuchClass, fileProblem, volumeFull,    access, other};  Error: ERROR [    code: ErrorCode, message: MsgNumber _ 0, position: LONG CARDINAL _ 0];  -- Procedures --  AddToHeaderData: PROCEDURE [data: HeaderData,    fieldType: FieldType, fieldBody: LONG STRING];  AddMessages: PROCEDURE [h: Handle, before: MsgNumber _ nullMessage]    RETURNS [stream: Stream.Handle];      Create: PROCEDURE [    fileName: LONG STRING, createIt: BOOLEAN,    letGo: LetGo _ NIL, data: LONG POINTER _ NIL]    RETURNS [Handle];  -- 'fileName' is not consumed    CreateHeaderData: PROCEDURE RETURNS [data: HeaderData];  Destroy: PROCEDURE [h: Handle];  StartAnotherMessage: PROCEDURE [    stream: Stream.Handle, length: CARDINAL,    attachments: BOOLEAN, examined: BOOLEAN _ FALSE,    flag: Flag _ Ascii.SP];    Delete, UnDelete, MarkExamined, UnMarkExamined,    MarkAttachments, UnMarkAttachments: PROCEDURE [    h: Handle, msg: MsgNumber];  Enumerate: PROCEDURE [    h: Handle, from, to: MsgNumber, enumerator: Enumerator,    mask: Attributes _ ALL[FALSE], filter: Attributes _ ALL[FALSE]];  Expunge: PROCEDURE [h: Handle];  ForceOut: PROCEDURE [h: Handle];  FilterMessage: PROCEDURE [mailFile: Handle,    message: MsgNumber, headerData: HeaderData];    FilterOne: PROCEDURE [    mf: Handle, msg: MsgNumber,    headerData: HeaderData,filterFieldBody: LONG STRING];  FreeHeaderData: PROCEDURE [data: HeaderData];    GetFieldType: PROCEDURE [fieldName: LONG STRING]    RETURNS [fieldType: FieldType];    ResetHeaderData: PROCEDURE [data: HeaderData];    WaitForUpdates: PROCEDURE;    File: PROC [h: Handle] RETURNS [file: MFile.Handle];  Messages: PROCEDURE [h: Handle] RETURNS [CARDINAL];  GetFileAttributes: PROCEDURE [h: Handle, name: LONG STRING _ NIL]    RETURNS [nMessages: CARDINAL, fileLength: LONG CARDINAL];  GetMsgAttributes: PROCEDURE [h: Handle, msg: MsgNumber]    RETURNS [attributes: Attributes, flag: Flag];  MakeReadOnly: PROCEDURE [h: Handle];  MakeWritable: PROCEDURE [h: Handle];  SetMsgAttribute: PROCEDURE [    h: Handle, msg: MsgNumber, attribute: AttributeIndex, value: BOOLEAN];  SetMsgFlag: PROCEDURE [h: Handle, msg: MsgNumber, flag: Flag];      Sort: PROCEDURE [h: Handle, oldCurrent: MsgNumber]    RETURNS [alreadySorted: BOOLEAN, newCurrent: MsgNumber];    TOCEntry: PROCEDURE [h: Handle, msg: MsgNumber]    RETURNS [piece: StreamPiece, attributes: Attributes, flag: Flag];  Message: PROCEDURE [h: Handle, msg: MsgNumber] RETURNS [StreamPiece];  AddClass: PROCEDURE [h: Handle, class: LONG STRING];  RemoveClass: PROCEDURE [h: Handle, class: LONG STRING];  ClassToClassIndex: PROCEDURE [h: Handle, class: LONG STRING]    RETURNS [ClassIndex];     -- string body belongs to client for above 3 procedures  ClassIndexToClass: PROCEDURE [h: Handle, index: ClassIndex, class: LONG STRING];     -- string body is filled in (as much as fits)    END.
-- File: MailParse.mesa -  Last edited by-- Wobber:	19-Dec-83 17:02:23-- PXK    :	18-Aug-83 14:53:39-- NS    :	 6-Oct-85 14:31:14DIRECTORY  Environment USING [Block],  MailPost USING [Handle],  NSName USING [Name];    MailParse: DEFINITIONS =  BEGIN  Handle: TYPE = LONG POINTER TO Object;  Object: TYPE;    ProcessProc: TYPE = PROC [h: Handle, name: NSName.Name]    RETURNS [write: BOOLEAN ¬ TRUE];<<	This type is used exclusively with the NameList procedure, described	below.>>  WriteProc: TYPE = PROC [string: LONG STRING];<<	If the client passes a WriteProc to the NameList procedures, the	parser will build the name up the whole name and pass it to the	client. Commas will be supplied by MailParse if needed for	names written within a single parse.>>    endOfInput: CHARACTER = 203C;<<	this character should be returned by the client's 'next' procedure	(see Initialize) when the end of the input is reached.  The	client's 'backup' procedure may be called after endOfInput has	been returned by the 'next' procedure, and a subsequent call of	'next' should again produce endOfInput. >>  endOfList: CHARACTER = 204C;<<	this character may be used as an "invisible delimiter" terminating a	list of names. It has no other effect. >>  -- Signals --  Error: ERROR [code: ErrorCode];  ErrorCode: TYPE = {    illegalName, endOfInput, fieldsAreAtoms, colonExpected,    mailBoxExpected, noSenderField };  -- Procedures --  Initialize: PROCEDURE [next: PROCEDURE RETURNS [CHARACTER]]    RETURNS [Handle];  Finalize: PROCEDURE [h: Handle];  GetFieldName: PROCEDURE [h: Handle, field: LONG STRING]    RETURNS [found: BOOLEAN];  GetFieldBody: PROCEDURE [    h: Handle, string: LONG STRING, suppressWhiteSpace: BOOLEAN ¬ FALSE]    RETURNS [truncated: BOOLEAN ¬ FALSE];  NameList: PROCEDURE [    h: Handle, m: MailPost.Handle, process: ProcessProc,    default: NSName.Name ¬ NIL, fakeProcess: ProcessProc ¬ NIL,    write: WriteProc ¬ NIL];  StringForErrorCode: PROCEDURE [code: ErrorCode, s: LONG STRING];<<The client is expected to make up the header of the new message from the  Blocks given back to the client by successive calls on the putBlock  procedure.  There will only be a single CR terminating the last Buffer.  If the client wishes to add more lines to the constructed header, this  may be done.>>    MakeAnswerHeader: PROCEDURE [    getChar: PROCEDURE [CARDINAL] RETURNS [CHARACTER], getLength: CARDINAL,    putBlock: PROCEDURE [Environment.Block],    getPages: PROCEDURE [CARDINAL] RETURNS [LONG POINTER],    freePages: PROCEDURE [LONG POINTER], user: NSName.Name]    RETURNS [answerError: BOOLEAN, mpCode: ErrorCode];<< Causes an answering header for a message that the client currently has.   'getChar' procedure is used to get characters from the old message header.   The argument to 'getChar' is which character from the old header is needed.   The same character may be asked for more than once.  'getLength' is the length   of the old message being parsed; 'getChar' will always be called with the   argument in the range [0..getLength).  'putBlock' is called by MakeHeader   successively with pieces of the new header under construction.  (The high half   of block.blockPointer will be zero in the Alto/Mesa world.)  'getPages'   and 'freePages' are called by MakeHeader as it needs temporary storage while   constructing the new header.  If MakeHeader is not unwound, all storage will   be released before it returns.  'userName' may not be NIL.      If the parse of the old message failed, then MakeHeader returns TRUE. If  there is no error, the errorCode and position are undefined.>>      END.
-- File: MailPostImpl.mesa - edited by -- AlHall	 	 20-Dec-84 22:17:32-- Wobber	 	 27-Dec-83 14:10:24-- Brenda Hankins 	 11-Nov-83 17:20:36-- NSG           	  4-Feb-85 17:07:56-- Forked from Hardy 11.0's MailSendImpl of Oct 7, 1983 on 25-Oct-83 11:01:55DIRECTORY  Ascii USING [CR],  Auth USING [IdentityHandle, CopyIdentity, FreeIdentity],  Courier USING [Error],  Cursor USING [Set],  Environment USING [Block, Byte],  Event USING [DoneWithProcess, Handle, Object],  FormSW USING [MenuProcType, NopFreeHintsProc],  Inline USING [LowHalf],  MailAttributes USING [    Attribute, AttributeList, AttributeType, MakeSerializer, SendAttributes,    SerialStream],  MailPost USING [    AppendReplyTo, Handle, IndicateDelivered, MakeTextSWEditable,    MakeTextSWReadOnly, PutError, zone],  MailTransport USING [    ctSerializedFile, Error, FreeUndeliverables, InvalidRecipients, NameList,    Post, Undeliverables],  MFile USING [Acquire, Error, Release],  MStream USING [Copy, Handle, ReadOnly],  NSAssignedTypes USING [    tDirectory, tEmpty, tMail, tSerialized, tText, tUnspecified],  NSDataStream USING [Abort, Aborted, SinkStream],  MailSend USING [ReplyToFlag],  MailParse USING [    endOfInput, endOfList, Error, ErrorCode, Finalize, GetFieldBody, GetFieldName,    Handle, Initialize, NameList, ProcessProc, StringForErrorCode],  NSName USING [    CopyNameFields, Error, FreeName, FreeNameFields, maxDomainLength,    maxLocalLength, maxOrgLength, maxFullNameLength, Name, NameFromString,    NameRecord],  NSString USING [    AppendToMesaString, CopyString, EquivalentStrings, FreeString, nullString,    String, StringBoundsFault, StringFromMesaString],  Process USING [priorityBackground, SetPriority],  Profile USING [GetUser, GetID],  Put USING [LongString, Text],  ScratchSource USING [Info],  Stream USING [Delete, Handle, PutBlock, SendNow],  String USING [    AppendChar, AppendLongDecimal, AppendString, AppendStringAndGrow, Copy,    EquivalentStrings, FreeString, InvalidNumber, Length, MakeString,    StringBoundsFault, StringToDecimal],  TextSource USING [GetLength, Position],  TextSW USING [GetEOF],  UserInput USING [UserAbort, WaitForConfirmation],  Window USING [Handle, Object];MailPostImpl: MONITOR  -- monitoring 3 diff conditions, don't seem to conflict  IMPORTS    Auth, Courier, Cursor, Event, FormSW, Inline, MailAttributes, MailPost, MailTransport,    MFile, MailParse, MStream, NSDataStream, NSName, NSString, Process, Profile,    Put, ScratchSource, String, Stream, TextSource, TextSW, UserInput  EXPORTS MailPost =  BEGIN  -- TYPEs:  AttributeList: TYPE = MailAttributes.AttributeList;  AttributeSeq: TYPE = RECORD [    SEQUENCE COMPUTED CARDINAL OF MailAttributes.Attribute];    FieldType: TYPE = {    cc, date, from, inReplyTo, replyTo, sender, subject, to, userDefined};  GetBlockProc: TYPE = PROCEDURE [firstChar: LONG CARDINAL]    RETURNS [block: Environment.Block];  Handle: TYPE = MailPost.Handle;  NameList: TYPE = MailTransport.NameList;  NameSeq: TYPE = RECORD [SEQUENCE COMPUTED CARDINAL OF NSName.NameRecord];  NextCharProc: TYPE = PROCEDURE RETURNS [char: CHARACTER];  -- Variables, etc.  AbortSend: ERROR [string: LONG STRING ¬ NIL] = CODE;  numberOfPredefinedAttachments: CARDINAL = 7;  predefinedstrings: ARRAY [0..numberOfPredefinedAttachments) OF LONG STRING ¬ [    "NSAssignedTypes.tUnspecified", "NSAssignedTypes.tDirectory",    "NSAssignedTypes.tSerialized", "NSAssignedTypes.tMail", "#0", "#1",    "#2"];  predefinednumbers:     ARRAY [0..numberOfPredefinedAttachments) OF LONG CARDINAL ¬ [      NSAssignedTypes.tUnspecified, NSAssignedTypes.tDirectory,      NSAssignedTypes.tSerialized, NSAssignedTypes.tMail, 0, 1, 2];  Error: ERROR [errorType: ErrorType] = CODE;  ErrorType: TYPE = {    attachmentAsMailNote, attachmentAsText, cannotParseAttachmentType,    mailNoteTooLong, noAttachmentType, noLogon, noSubjectField,    subjectFieldTooLong, unknownAttachmentType};  NeedReplyTo: ERROR = CODE;  ParseError: ERROR [    code: MailParse.ErrorCode, fieldName: LONG STRING, position: LONG CARDINAL,    hackedErrorCode: LONG STRING ¬ NIL] = CODE;  UserAborted: SIGNAL = CODE;  asciiCaret: Environment.Byte = LOOPHOLE[136B];  checkoutCount: CARDINAL ¬ 0;  defaultReplyTo: MailSend.ReplyToFlag ¬ stop;  mailNoteMaxLength: CARDINAL = 8000;  makeNewIdentity: BOOLEAN ¬ FALSE;  maxNameLength: CARDINAL = NSName.maxFullNameLength;  myZone: UNCOUNTED ZONE = MailPost.zone;  nsUpArrow: Environment.Byte = LOOPHOLE[255B];  userAsNameList: NameList ¬ NIL;  userLocalName: LONG STRING ¬ [40];  userDefaultName: NSName.Name ¬ NIL;  userIdentity: Auth.IdentityHandle ¬ NIL;  -- PROCs:  AddAttribute: PROCEDURE [handle: Handle, attribute: MailAttributes.Attribute] =    BEGIN    IF handle.attributes = NIL THEN      handle.attributes.BASE ¬ LOOPHOLE[myZone.NEW[        AttributeSeq [MailAttributes.AttributeType.LAST.ORD + 1]]];    -- Note: Clean up of handle.attributes on UNWIND is handled by PROC CleanUpHandle.    handle.attributes[handle.attributes.LENGTH] ¬ attribute;    handle.attributes.LENGTH ¬ handle.attributes.LENGTH + 1;    END;  AddReplyTo: PROCEDURE [handle: Handle] =    BEGIN    Put.Text[handle.msgSW, "adding Reply-To and retrying ... "L];    MakeReplyTo[handle, appendToHeader];  -- (Feedback to user)    AddAttribute[handle, [mailAnswerTo[CopyNameList[myZone, userAsNameList]]]];    END;  AssertLegalName: PROCEDURE [name: NSName.Name] =    -- (NSName should enforce this itself).    BEGIN    IF name.local.length > NSName.maxLocalLength      OR name.domain.length > NSName.maxDomainLength      OR name.org.length > NSName.maxOrgLength THEN      ERROR MailParse.Error[illegalName];    END;  AttachmentTypeMenuProc: PUBLIC FormSW.MenuProcType =    BEGIN    RETURN[      hints: DESCRIPTOR[predefinedstrings],        freeHintsProc: FormSW.NopFreeHintsProc, replace: TRUE];    END;  GetUserLocalName: PUBLIC ENTRY PROCEDURE [proc: PROCEDURE [name: LONG STRING]] =    BEGIN ENABLE UNWIND => NULL; proc[userLocalName]; END;  MakeReplyTo: PROCEDURE [h: Handle, why: {appendToHeader, putError}] =    BEGIN    string: STRING = [50 + maxNameLength];    IF why = putError THEN      String.AppendString[string, "Add field to message header: "L];    String.AppendString[string, "Reply-To: "L];    String.AppendString[string, userLocalName];    IF why = appendToHeader THEN MailPost.AppendReplyTo[h, string]    ELSE MailPost.PutError[h.msgSW, string];    END;  STR: PROCEDURE [s: LONG STRING] RETURNS [NSString.String] = INLINE {    RETURN[NSString.StringFromMesaString[s]]};  CheckForUserAbort: PROCEDURE [handle: Handle] =    BEGIN IF UserInput.UserAbort[handle.toolWindow] THEN SIGNAL UserAborted; END;  BeginPost: ENTRY PROC [h: Handle] =    BEGIN    ENABLE UNWIND => NULL;    IF userIdentity = NIL THEN ERROR Error[noLogon];    Process.SetPriority[Process.priorityBackground];    IF makeNewIdentity AND checkoutCount = 0 THEN      MakeNewIdentity[        ! MailParse.Error => ERROR AbortSend["Problem parsing user name"L]];    checkoutCount ¬ checkoutCount + 1;    MailPost.MakeTextSWReadOnly[h.textSW];    END;  EndPost: ENTRY PROC [h: Handle, event: Event.Handle] =    BEGIN    ENABLE UNWIND => NULL;    CleanUpHandle[h];    IF checkoutCount # 0 THEN checkoutCount ¬ checkoutCount - 1;    -- (There's a glitch that sometimes leaves checkoutCount = 0).    MailPost.MakeTextSWEditable[h.textSW];    h.busy ¬ FALSE;    NOTIFY h.condition;    Event.DoneWithProcess[event];    END;  FindStartOfMessageBody: PROCEDURE [h: Handle]    RETURNS [startOfMessageBody: TextSource.Position] =    BEGIN    cr: Environment.Byte = LOOPHOLE[Ascii.CR];    block: Environment.Block = ScratchSource.Info[h.scratch].block;    FOR i: CARDINAL IN [block.startIndex..block.stopIndexPlusOne - 1) DO      IF block.blockPointer[i] = cr AND block.blockPointer[i + 1] = cr THEN        RETURN[i + 2];      ENDLOOP;    END;  MakeNewIdentity: INTERNAL PROC =    BEGIN    -- h: MailPost.Handle;      GetID: PROC [id: Auth.IdentityHandle] = {      userIdentity ¬ Auth.CopyIdentity[id, myZone];      };    MakeID: PROCEDURE [name, password: LONG STRING] =      BEGIN      ENABLE {        MailParse.Error, NSName.Error, NSString.StringBoundsFault,          String.StringBoundsFault => ERROR AbortSend["Malformed user name"L];        };      IF String.Length[name] = 0 THEN {        IF userIdentity # NIL THEN Auth.FreeIdentity[@userIdentity, myZone];	userIdentity ¬ NIL;	RETURN};      userDefaultName ¬ NSName.NameFromString[myZone, STR[name]];      NSString.AppendToMesaString[userLocalName, userDefaultName.local];      END;    userLocalName.length ¬ 0;    IF userIdentity # NIL THEN Auth.FreeIdentity[@userIdentity, myZone];    IF userDefaultName # NIL THEN NSName.FreeName[myZone, userDefaultName];    userDefaultName ¬ NIL;    Profile.GetID[strong, GetID];    Profile.GetUser[MakeID, clearinghouse];    IF userAsNameList # NIL THEN FreeNameList[userAsNameList];    userAsNameList ¬ NameListFromString[,      userLocalName ! UNWIND => userAsNameList ¬ NIL];    makeNewIdentity ¬ FALSE;    END;  PostMessage: PUBLIC PROCEDURE [h: Handle, event: Event.Handle] =    BEGIN        ENABLE {      AbortSend =>        BEGIN        IF string # NIL THEN MailPost.PutError[h.msgSW, string];        CONTINUE;        END;      ABORTED => CONTINUE;  -- Since process forked from Tool.      Courier.Error => {MailPost.PutError[h.msgSW, "Courier Error"L]; CONTINUE};      Error =>        BEGIN        SELECT errorType FROM          attachmentAsMailNote =>            MailPost.PutError[h.msgSW, "Cannot send attachment as MailNote"L];          attachmentAsText =>            MailPost.PutError[h.msgSW, "Cannot send attachment as Text"L];          cannotParseAttachmentType =>            MailPost.PutError[h.msgSW, "Cannot parse Attachment Type"L];          mailNoteTooLong =>            MailPost.PutError[              h.msgSW, "Message body too long to send as MailNote"L];          noAttachmentType =>            MailPost.PutError[h.msgSW, "Attachment Type not specified"L];          noLogon => MailPost.PutError[h.msgSW, "Login required"L];          noSubjectField =>            MailPost.PutError[h.msgSW, "Subject field cannot be empty"L];          subjectFieldTooLong =>            MailPost.PutError[h.msgSW, "Subject field too long"L];          unknownAttachmentType =>            MailPost.PutError[h.msgSW, "Unknown Attachment Type"L];          ENDCASE;        CONTINUE;        END;      MailTransport.Error =>        BEGIN        MailPost.PutError[          h.msgSW,          WITH e: error SELECT FROM            authentication => "authentication error"L,            location =>  -- "location error:"L,              SELECT e.problem FROM                noCHAvailable => "no CH Available"L,                noLocationFound => "incorrect/nonexistent CH entry"L,                noMailDropUp => "no MailDrop available"L,                ENDCASE => "undetermined location error. "L,            service =>  -- "service error:"L,              SELECT e.problem FROM                cannotAuthenticate => "can't reach authentication service"L,                serviceFull => "that MS can't accept scv requests"L,                serviceUnavailable => "that MS isn't accepting scv requests"L,                mediumFull => "no room avbl on that MS"L,                ENDCASE => "undetermined location error. "L,            transfer =>              SELECT e.problem FROM                aborted => "transfer aborted"L,                ENDCASE => "undetermined transfer problem"L,            ENDCASE => "unknown mailtransport error"L];        CONTINUE;        END;      NeedReplyTo =>        IF h.replyToFlag = stop THEN          -- Note: The case where h.replyToFlag = add is handled below, and          --   h.replyToFlag = send should not raise this ERROR.          BEGIN MakeReplyTo[h, putError]; CONTINUE; END;      MailParse.Error => BEGIN PutParseError[h, code]; CONTINUE; END;      ParseError =>        BEGIN PutParseError[h, code, fieldName, position]; CONTINUE; END;      UserAborted => {Put.Text[h.msgSW, "delivery cancelled"L]; CONTINUE};      };    positionForBody: TextSource.Position;    -- TextSW position after parsing message header.    GetBlock: GetBlockProc =      BEGIN      block ¬ ScratchSource.Info[h.scratch].block;      block.startIndex ¬ Inline.LowHalf[firstChar];      END;    BEGIN    ENABLE      UNWIND =>        BEGIN        -- Note: This extra feedback was added        --   because EndPost may take a few seconds        --   to free the storage in the Handle.        Put.Text[h.msgSW, " ... "L];        EndPost[h, event];        Put.Text[h.msgSW, "aborted."L];        END;    BeginPost[h];    Put.Text[h.msgSW, "parsing ... "L];    CheckForUserAbort[h];    ParseMessage[h, GetBlock, TextSW.GetEOF[h.textSW]];    -- Puts recipients and header attributes in Handle.    positionForBody ¬ FindStartOfMessageBody[h];    AddExtraAttributes[h, positionForBody];    Put.Text[h.msgSW, "sending ... "L];    CheckForUserAbort[h];        ActualPost[      h, positionForBody !      NeedReplyTo =>        IF h.replyToFlag = add THEN          BEGIN AddReplyTo[h]; h.hasReplyTo ¬ TRUE; RETRY; END;];    END;  -- ENABLE UNWIND    EndPost[h, event];    MailPost.IndicateDelivered[h];    END;  PutParseError: PROCEDURE [    handle: Handle, errorCode: MailParse.ErrorCode,    fieldName: LONG STRING ¬ NIL, position: LONG CARDINAL ¬ LAST[LONG CARDINAL],    hackedErrorCode: LONG STRING ¬ NIL] =    BEGIN    string: LONG STRING ¬ [200];  -- (Length chosen arbitrarily).    IF hackedErrorCode # NIL THEN String.AppendString[string, hackedErrorCode]    ELSE MailParse.StringForErrorCode[errorCode, string];    IF fieldName # NIL THEN      BEGIN      String.AppendString[string, " in \""L];      String.AppendString[string, fieldName];      String.AppendString[string, ":\" field"L];      END;    IF position # LAST[CARDINAL] THEN      BEGIN      String.AppendString[string, " at character "L];      String.AppendLongDecimal[string, position];      END;    MailPost.PutError[handle.msgSW, string];    END;  SetUserNameAndPassword: PUBLIC ENTRY PROCEDURE =    BEGIN        ENABLE UNWIND => NULL;    makeNewIdentity ¬ TRUE;    IF checkoutCount = 0 THEN      MakeNewIdentity[ ! MailParse.Error, AbortSend => CONTINUE];    END;  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  ActualPost: PROCEDURE [h: Handle, startOfMessageBody: TextSource.Position] =    BEGIN    invalidNameList: MailTransport.Undeliverables ¬ NIL;    needReplyTo: BOOLEAN = ~(h.hasReplyTo OR h.replyToFlag = send);    PostCallBack: PROCEDURE [sinkStream: NSDataStream.SinkStream] =      BEGIN      ENABLE {        NSDataStream.Aborted => CONTINUE;        UserAborted => NSDataStream.Abort[sinkStream];        };      -- Abort sinkStream and pass on SIGNAL UserAborted.      stream: MailAttributes.SerialStream ¬ MailAttributes.MakeSerializer[        sinkStream, send];      BEGIN      ENABLE UNWIND => stream.delete[stream ! NSDataStream.Aborted => CONTINUE];      MailAttributes.SendAttributes[stream, h.attributes, NIL];      CheckForUserAbort[h];      SELECT h.sendAs FROM        attachment => MailTransportBodyFromFile[h, stream];        mailNote => NULL;        text => MailTransportBodyFromTextSW[h, stream, startOfMessageBody];        ENDCASE;      CheckForUserAbort[h];      Stream.SendNow[stream];      END;  -- ENABLE UNWIND      Stream.Delete[stream ! NSDataStream.Aborted => CONTINUE];      END;    BEGIN    ENABLE      UNWIND =>        IF invalidNameList # NIL THEN          MailTransport.FreeUndeliverables[invalidNameList];    IF h.sendAs = attachment THEN CheckAttachmentFile[h];    IF needReplyTo AND (LENGTH[h.recipients] > 29 OR HasUpArrow[h.recipients])      THEN ERROR NeedReplyTo;    IF userIdentity = NIL THEN ERROR Error[noLogon];    invalidNameList ¬ MailTransport.Post[      userIdentity, h.recipients, h.ifInvalidRecipients, ~needReplyTo,      MailTransport.ctSerializedFile, [proc[PostCallBack]] !      MailTransport.InvalidRecipients => ProcessInvalidRecipients[h, nameList]; ];    END;  -- ENABLE UNWIND    IF invalidNameList # NIL THEN      MailTransport.FreeUndeliverables[invalidNameList];    END;  CheckAttachmentFile: PROCEDURE [handle: Handle] =    BEGIN    string: LONG STRING ¬ [200];    IF String.Length[handle.attachmentFile] = 0 THEN      ERROR AbortSend["Attachment File not specified"L];    IF ProblemAccessingFile[handle.attachmentFile] THEN      BEGIN      String.AppendString[string, "Problem accessing file \""L];      String.AppendString[string, handle.attachmentFile];      String.AppendString[string, "\""L];      ERROR AbortSend[string];      END;    END;  HasUpArrow: PROCEDURE [nameList: NameList]    RETURNS [hasUpArrow: BOOLEAN ¬ FALSE] =    -- Backward compatibility for Grapevine DL names (local    --   part has an upArrow in it).    BEGIN    FOR i: CARDINAL IN [0..LENGTH[nameList]) DO      FOR j: CARDINAL IN [0..nameList[i].local.length) DO        SELECT nameList[i].local.bytes[j] FROM          nsUpArrow, asciiCaret => hasUpArrow ¬ TRUE;          ENDCASE;        ENDLOOP;      ENDLOOP;    END;    ProblemAccessingFile: PROCEDURE [file: LONG STRING]    RETURNS [problem: BOOLEAN ¬ TRUE] =    BEGIN    ENABLE MFile.Error => CONTINUE;  -- RETURN [TRUE]    MFile.Release[MFile.Acquire[file, anchor, [], FALSE, 0, binary]];    RETURN[FALSE];    END;  ProcessInvalidRecipients: PROCEDURE [    handle: Handle, nameList: MailTransport.Undeliverables] =    BEGIN    FOR i: CARDINAL IN [0..LENGTH[nameList]) DO      IF nameList[i].reason = noDLsAllowed THEN ERROR NeedReplyTo; ENDLOOP;    MailPost.PutError[handle.msgSW, "Invalid recipients: "L];    PrintInvalidNameList[handle.msgSW, nameList, userDefaultName];    ERROR AbortSend[];    END;  MailTransportBodyFromFile: PROCEDURE [    h: Handle, serialStream: MailAttributes.SerialStream] =    BEGIN    mStream: MStream.Handle;    IF String.Length[h.attachmentFile] = 0 THEN RETURN;    mStream ¬ MStream.ReadOnly[h.attachmentFile, []];    [] ¬ MStream.Copy[      from: mStream, to: serialStream, bytes: LAST[LONG CARDINAL] !      NSDataStream.Aborted => CONTINUE];    Stream.Delete[mStream];    END;  MailTransportBodyFromTextSW: PROCEDURE [    h: Handle, serialStream: MailAttributes.SerialStream,    startOfMessageBody: TextSource.Position] =    BEGIN    block: Environment.Block;    bytesRemaining: CARDINAL ¬ Inline.LowHalf[      h.scratch.GetLength[] - startOfMessageBody];    positionInSource: TextSource.Position ¬ startOfMessageBody;    IF String.Length[h.userDefinedHeaderFields] # 0 THEN      Stream.PutBlock[        sH: serialStream,        block: [        LOOPHOLE[STR[h.userDefinedHeaderFields].bytes], 0,        h.userDefinedHeaderFields.length]];    -- NOTE: Extra "\n" already appended to userDefinedHeaderFields.    WHILE bytesRemaining # 0 DO      -- Note: Must use this loop; see TextSource for reason why.      [block, positionInSource] ¬ h.scratch.readText[        source: h.scratch, position: positionInSource, maxLength: bytesRemaining,        class: none];      Stream.PutBlock[serialStream, block];      bytesRemaining ¬        bytesRemaining - (block.stopIndexPlusOne - block.startIndex);      ENDLOOP;    END;  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  AddExtraAttributes: PROCEDURE [    h: Handle, startOfMessageBody: TextSource.Position] =    BEGIN    mailNote: NSString.String ¬ NSString.nullString;    Cleanup: PROCEDURE =      BEGIN      IF mailNote # NSString.nullString THEN        NSString.FreeString[myZone, mailNote];      END;    BEGIN    ENABLE UNWIND => Cleanup[];    IF h.sendAs # text THEN      BEGIN      mailNote ¬ MailNoteFromTextSW[h, startOfMessageBody];      IF mailNote # NSString.nullString THEN        AddAttribute[h, [mailNote[NSString.CopyString[myZone, mailNote]]]];      END;    AddAttribute[      h, [      mailBodyType[      SELECT h.sendAs FROM        attachment => AttachmentTypeFromString[h.attachmentType],        mailNote => NSAssignedTypes.tEmpty,        text => NSAssignedTypes.tText,        ENDCASE => ERROR]]];    END;  -- ENABLE UNWIND    Cleanup[];    END;  GetFieldType: PROCEDURE [fieldName: LONG STRING]    RETURNS [fieldType: FieldType] =    BEGIN    RETURN[      SELECT TRUE FROM        String.EquivalentStrings[fieldName, "cc"L] => cc,        String.EquivalentStrings[fieldName, "Date"L] => date,        String.EquivalentStrings[fieldName, "From"L] => from,        String.EquivalentStrings[fieldName, "In-reply-to"L] => inReplyTo,        String.EquivalentStrings[fieldName, "Reply-To"L] => replyTo,        String.EquivalentStrings[fieldName, "Sender"L] => sender,        String.EquivalentStrings[fieldName, "Subject"L] => subject,        String.EquivalentStrings[fieldName, "To"L] => to,        ENDCASE => userDefined];    END;  ParseNameList: PROCEDURE [    sendH: Handle, parseH: MailParse.Handle, nextCharProc: NextCharProc,    fieldType: FieldType, hasFrom: LONG POINTER TO BOOLEAN] =    BEGIN    nameList, fakeNameList: NameList ¬ DESCRIPTOR[NIL, 0];    [nameList, fakeNameList] ¬ GetNameLists[sendH, parseH, 10];    SELECT fieldType FROM      cc => {        sendH.ccList ¬ MergeNameLists[myZone, sendH.ccList, nameList];        sendH.fakeccList ¬ MergeNameLists[myZone, sendH.fakeccList, fakeNameList];	};      -- Allows for multiple "cc" lists.      from =>        BEGIN        -- NOTE: RFC822 disallows groups from the "from" field.        IF NOT hasFrom­ THEN          AddAttribute[sendH, [mailFrom[CopyNameList[myZone, nameList]]]];        hasFrom­ ¬ TRUE;	FreeNameList[nameList];	FreeNameList[fakeNameList];        END;      replyTo =>        BEGIN        IF NOT sendH.hasReplyTo THEN          AddAttribute[sendH, [mailAnswerTo[CopyNameList[myZone, nameList]]]];        sendH.hasReplyTo ¬ TRUE;	FreeNameList[nameList];	FreeNameList[fakeNameList];        END;      to => {        sendH.toList ¬ MergeNameLists[myZone, sendH.toList, nameList];        sendH.faketoList ¬ MergeNameLists[myZone, sendH.faketoList, fakeNameList];	};      -- Allows for multiple "to" lists.      ENDCASE => ERROR;    --END;  ENABLE UNWIND    END;      Confirmed: PROC RETURNS [confirmed: BOOLEAN ¬ FALSE] =     BEGIN    Cursor.Set[mouseRed];    confirmed ¬ UserInput.WaitForConfirmation[].okay;    Cursor.Set[textPointer];    END;  ParseMessage: PROCEDURE [    sendH: Handle, getBlock: GetBlockProc, messageLength: LONG CARDINAL] =    BEGIN    block: Environment.Block;    blockPos: CARDINAL ¬ 0;    fieldName: STRING = [40];    fieldType: FieldType;    hasFrom, hasInReplyTo, hasSubject: BOOLEAN ¬ FALSE;    firstChar, index: LONG CARDINAL ¬ 0;    inReplyToFieldBody: LONG STRING ¬ [100];  -- NOTE: See "CODE" notation below for inReplyTo.    parseH: MailParse.Handle ¬ NIL;    subjectFieldBody: LONG STRING ¬ [100];    nameList: NameList ¬ NIL;    NewBlock: PROC [from: LONG CARDINAL] = {      block ¬ getBlock[firstChar ¬ from]; blockPos ¬ block.startIndex};    Read: PROC RETURNS [c: CHARACTER] =      BEGIN      IF index >= messageLength THEN c ¬ MailParse.endOfInput      ELSE        BEGIN        IF index < firstChar OR blockPos >= block.stopIndexPlusOne THEN          NewBlock[index];        c ¬ block.blockPointer[blockPos] + 0C;        END;      index ¬ index + 1;      blockPos ¬ blockPos + 1;      END;    BEGIN    ENABLE UNWIND => IF parseH # NIL THEN MailParse.Finalize[parseH];    NewBlock[0];    parseH ¬ MailParse.Initialize[Read];    WHILE MailParse.GetFieldName[parseH, fieldName] DO      ENABLE {        UNWIND => NULL;        MailParse.Error =>          ERROR ParseError[code, fieldName, --index-- LAST[CARDINAL]]};      -- CODE: Can't use index, which is beginning of *next* token; need      --   MailParseImpl to give position of beginning of *this* token.      SELECT (fieldType ¬ GetFieldType[fieldName]) FROM        cc, from, replyTo, to =>  -- Fields which take NameLists          ParseNameList[sendH, parseH, Read, fieldType, @hasFrom];        -- Appends cc and to fields to NameLists in sendH,        --   and creates attributes for the other fields (also stored        --   in sendH).        ENDCASE =>          SELECT fieldType FROM            date => ERROR AbortSend["User-supplied \"Date:\" field not allowed"L];            inReplyTo =>              BEGIN              [] ¬ MailParse.GetFieldBody[parseH, inReplyToFieldBody];                            IF NOT hasInReplyTo THEN                AddAttribute[                  sendH, [                  mailInReplyTo[                  NSString.CopyString[myZone, STR[inReplyToFieldBody]]]]];              hasInReplyTo ¬ TRUE;              END;            sender =>              ERROR AbortSend["User-supplied \"Sender:\" field not allowed"L];            subject =>              BEGIN              IF MailParse.GetFieldBody[parseH, subjectFieldBody] THEN	        ERROR Error[subjectFieldTooLong];              IF String.Length[subjectFieldBody] = 0 THEN                ERROR Error[noSubjectField];                            IF NOT hasSubject THEN                AddAttribute[                  sendH, [                  mailSubject[                  NSString.CopyString[myZone, STR[subjectFieldBody]]]]];              hasSubject ¬ TRUE;              END;            ENDCASE -- userDefined-- =>              SaveUserDefinedField[sendH, parseH, fieldName];      ENDLOOP;    IF NOT hasSubject THEN ERROR Error[noSubjectField];    IF NOT hasFrom THEN      AddAttribute[sendH, [mailFrom[CopyNameList[myZone, userAsNameList]]]];    AddAttribute[sendH, [mailTo[sendH.faketoList]]];    sendH.faketoList ¬ NIL;  -- gets freed when the attributes are freed.    AddAttribute[sendH, [mailCopies[sendH.fakeccList]]];    sendH.fakeccList ¬ NIL;  -- gets freed when the attributes are freed.    sendH.recipients ¬ MergeNameLists[      myZone, sendH.recipients, CopyNameList[myZone, sendH.toList]];    sendH.recipients ¬ MergeNameLists[      myZone, sendH.recipients, CopyNameList[myZone, sendH.ccList]];    String.AppendStringAndGrow[      z: myZone, from: "\n"L, to: @sendH.userDefinedHeaderFields, extra: 1];    -- Append second consecutive "\n" to separate remaining    --   message header from body.    END;  -- ENABLE UNWIND    IF parseH # NIL THEN MailParse.Finalize[parseH];    END;  SaveUserDefinedField: PROCEDURE [    sendH: Handle, parseH: MailParse.Handle, fieldName: LONG STRING] =    BEGIN    fieldBody: LONG STRING ¬ [200];    -- CODE: Allow user-defined field to be of arbitrary length (may     --   require two passes of the parser on each message, or    --   changing MailParseImpl to optionally signal    --   StringBoundsFaults instead of just truncating).    Append: PROCEDURE [string: LONG STRING] =      BEGIN      String.AppendStringAndGrow[        z: myZone, from: string, to: @sendH.userDefinedHeaderFields, extra: 200];      END;    IF sendH.userDefinedHeaderFields = NIL THEN      sendH.userDefinedHeaderFields ¬ String.MakeString[myZone, 200];    Append[fieldName];    Append[": "L];    [] ¬ MailParse.GetFieldBody[parseH, fieldBody];    Append[fieldBody];    Append["\n"L];    END;  MailNoteFromTextSW: PROCEDURE [    h: Handle, startOfMessageBody: TextSource.Position]    RETURNS [mailNote: NSString.String ¬ NSString.nullString] =    BEGIN    block: Environment.Block;    blockLength: CARDINAL;    mesaString: LONG STRING ¬ NIL;    sourceLength: CARDINAL = Inline.LowHalf[      String.Length[h.userDefinedHeaderFields] +        (h.scratch.GetLength[] - startOfMessageBody)];    -- Remaining header fields (those not mapped into    --   attributes) plus message body.    positionInSource: TextSource.Position ¬ startOfMessageBody;    Cleanup: PROCEDURE =      BEGIN IF mesaString # NIL THEN String.FreeString[myZone, mesaString]; END;    BEGIN    ENABLE UNWIND => Cleanup[];    IF sourceLength = 0 THEN RETURN;    IF sourceLength >= mailNoteMaxLength THEN ERROR Error[mailNoteTooLong];    mesaString ¬ String.MakeString[myZone, sourceLength];    IF String.Length[h.userDefinedHeaderFields] # 0 THEN      String.AppendString[mesaString, h.userDefinedHeaderFields];    -- NOTE: Extra "\n" already appended to userDefinedHeaderFields.    WHILE mesaString.length < sourceLength DO      -- Note: Must use this loop; see TextSource for reason why.      [block, positionInSource] ¬ h.scratch.readText[        source: h.scratch, position: positionInSource,        maxLength: sourceLength - mesaString.length, class: none];      blockLength ¬ block.stopIndexPlusOne - block.startIndex;      FOR blockOffset: CARDINAL IN [0..blockLength) DO        mesaString[mesaString.length + blockOffset] ¬ LOOPHOLE[block.blockPointer[          block.startIndex + blockOffset], CHARACTER];        ENDLOOP;      mesaString.length ¬ mesaString.length + blockLength;      ENDLOOP;    mailNote ¬ NSString.CopyString[myZone, STR[mesaString]];    END;    Cleanup[];    END;  AttachmentTypeFromNumber: PROCEDURE [string: LONG STRING]    RETURNS [attachmentType: LONG CARDINAL] =    -- First get rid of leading '#, then convert to decimal.    BEGIN    stringCopy: LONG STRING ¬ [50];    String.Copy[stringCopy, string];    FOR i: CARDINAL IN [1..stringCopy.length) DO      stringCopy[i - 1] ¬ stringCopy[i]; ENDLOOP;    stringCopy.length ¬ stringCopy.length - 1;    attachmentType ¬ String.StringToDecimal[      stringCopy !      String.InvalidNumber => ERROR Error[cannotParseAttachmentType]];    SELECT attachmentType FROM      NSAssignedTypes.tEmpty => ERROR Error[attachmentAsMailNote];      NSAssignedTypes.tText => ERROR Error[attachmentAsText];      ENDCASE;    END;  AttachmentTypeFromString: PROCEDURE [string: LONG STRING]    RETURNS [attachmentType: LONG CARDINAL] =    BEGIN    IF String.Length[string] = 0 THEN ERROR Error[noAttachmentType];    IF string[0] = '# THEN RETURN[AttachmentTypeFromNumber[string]];    FOR i: CARDINAL IN [0..numberOfPredefinedAttachments) DO      IF String.EquivalentStrings[string, predefinedstrings[i]] THEN        RETURN[predefinednumbers[i]];      ENDLOOP;    ERROR Error[unknownAttachmentType];    END;  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  MergeNameLists: PROCEDURE [zone: UNCOUNTED ZONE, nameList1, nameList2: NameList]    RETURNS [result: NameList ¬ NIL] =    -- Note: Both nameList1 and nameList2 are NIL    --   upon returning from this PROC.    BEGIN    BEGIN    ENABLE UNWIND => IF result # NIL THEN zone.FREE[@result.BASE];    result.BASE ¬ LOOPHOLE[zone.NEW[      NameSeq [LENGTH[nameList1] + LENGTH[nameList2]]]];    FOR i: CARDINAL IN [0..LENGTH[nameList1]) DO      result[result.LENGTH] ¬ nameList1[i];      result.LENGTH ¬ result.LENGTH + 1;      ENDLOOP;    FOR i: CARDINAL IN [0..LENGTH[nameList2]) DO      result[result.LENGTH] ¬ nameList2[i];      result.LENGTH ¬ result.LENGTH + 1;      ENDLOOP;    IF nameList1 # NIL THEN zone.FREE[@nameList1.BASE];    IF nameList2 # NIL THEN zone.FREE[@nameList2.BASE];    END;  -- ENABLE UNWIND    -- Note: Don't free NameList "result" for normal case.    END;  CleanUpHandle: PROC [handle: Handle] =    BEGIN    -- CODE: Optimize so that names in NameLists are not    --   copied    IF handle.recipients # NIL THEN      BEGIN FreeNameList[handle.recipients]; handle.recipients ¬ NIL; END;    IF handle.attributes # NIL THEN      -- CODE: Actually, attributes should be an AttributesRecord not and array of Attribute      BEGIN      FOR i: CARDINAL IN [0..LENGTH[handle.attributes]) DO        WITH attrs: handle.attributes[i] SELECT FROM          mailAnswerTo, mailCopies, mailFrom, mailTo => FreeNameList[attrs.value];          -- CODE: Free Strings ?          ENDCASE => NULL;        ENDLOOP;      myZone.FREE[@handle.attributes.BASE];      handle.attributes ¬ NIL;      END;    IF handle.ccList # NIL THEN      BEGIN FreeNameList[handle.ccList]; handle.ccList ¬ NIL; END;    IF handle.toList # NIL THEN      BEGIN FreeNameList[handle.toList]; handle.toList ¬ NIL; END;    IF handle.userDefinedHeaderFields # NIL THEN      BEGIN      String.FreeString[myZone, handle.userDefinedHeaderFields];      handle.userDefinedHeaderFields ¬ NIL;      END;    handle.hasReplyTo ¬ FALSE;    END;  CopyNameList: PROCEDURE [zone: UNCOUNTED ZONE, from: NameList]    RETURNS [to: NameList ¬ NIL] =    BEGIN    IF from = NIL THEN RETURN[NIL];    to.BASE ¬ LOOPHOLE[zone.NEW[NameSeq [LENGTH[from]]]];    FOR i: CARDINAL IN [0..LENGTH[from]) DO      to[to.LENGTH] ¬ [];      NSName.CopyNameFields[myZone, @from[i], @to[to.LENGTH]];      to.LENGTH ¬ to.LENGTH + 1;      ENDLOOP;    END;  FreeNameList: PROC [nameList: NameList] =    BEGIN    FOR n: CARDINAL IN [0..LENGTH[nameList]) DO      NSName.FreeNameFields[myZone, @nameList[n]]; ENDLOOP;    IF nameList.BASE # NIL THEN myZone.FREE[@nameList.BASE];    END;  GetNameLists: PROCEDURE [h: Handle, parseH: MailParse.Handle, blockSize: CARDINAL]    RETURNS [realNameList, fakeNameList: NameList ¬ NIL] =    BEGIN    ENABLE String.StringBoundsFault => ERROR MailParse.Error[illegalName];    realMax: CARDINAL ¬ blockSize;    fakeMax: CARDINAL ¬ blockSize;    tempNameList: NameList ¬ NIL;    AddName: MailParse.ProcessProc =      BEGIN      AssertLegalName[name];      IF realNameList = NIL THEN        realNameList.BASE ¬ LOOPHOLE[myZone.NEW[NameSeq [blockSize]]];      IF LENGTH[realNameList] = realMax THEN        BEGIN	realMax ¬ realMax * 2;        tempNameList.BASE ¬ LOOPHOLE[myZone.NEW[NameSeq [realMax]]];        FOR i: CARDINAL IN [0..LENGTH[realNameList]) DO          tempNameList[i] ¬ realNameList[i]; ENDLOOP;        tempNameList.LENGTH ¬ LENGTH[realNameList];        myZone.FREE[@realNameList.BASE];        realNameList ¬ tempNameList;        END;      realNameList[realNameList.LENGTH] ¬ [];      NSName.CopyNameFields[myZone, name, @realNameList[realNameList.LENGTH]];      realNameList.LENGTH ¬ realNameList.LENGTH + 1;      END;    AddFakeName: MailParse.ProcessProc =      BEGIN      AssertLegalName[name];      IF fakeNameList = NIL THEN        fakeNameList.BASE ¬ LOOPHOLE[myZone.NEW[NameSeq [blockSize]]];      IF LENGTH[fakeNameList] = fakeMax THEN        BEGIN	fakeMax ¬ fakeMax * 2;        tempNameList.BASE ¬ LOOPHOLE[myZone.NEW[NameSeq [fakeMax]]];        FOR i: CARDINAL IN [0..LENGTH[fakeNameList]) DO          tempNameList[i] ¬ fakeNameList[i]; ENDLOOP;        tempNameList.LENGTH ¬ LENGTH[fakeNameList];        myZone.FREE[@fakeNameList.BASE];        fakeNameList ¬ tempNameList;        END;      fakeNameList[fakeNameList.LENGTH] ¬ [];      NSName.CopyNameFields[myZone, name, @fakeNameList[fakeNameList.LENGTH]];      fakeNameList.LENGTH ¬ fakeNameList.LENGTH + 1;      END;    BEGIN    ENABLE UNWIND => {      IF realNameList # NIL THEN FreeNameList[realNameList];      IF fakeNameList # NIL THEN FreeNameList[fakeNameList];      };    MailParse.NameList[parseH, h, AddName, userDefaultName, AddFakeName, NIL];    END;  -- ENABLE UNWIND    -- Note: Don't free nameLists for normal case.    END;  NameListFromString: PROC [h: Handle, s: LONG STRING] RETURNS [nameList: NameList ¬ NIL] =    BEGIN    parseH: MailParse.Handle ¬ NIL;    nextChar: CARDINAL ¬ 0;    fakeNameList: NameList ¬ NIL;    Cleanup: PROCEDURE =      BEGIN      IF parseH # NIL THEN MailParse.Finalize[parseH];      IF nameList # NIL THEN FreeNameList[nameList];      END;    NextChar: PROCEDURE RETURNS [char: CHARACTER] =      BEGIN      IF nextChar = String.Length[s] THEN RETURN[MailParse.endOfList];      char ¬ s.text[nextChar];      nextChar ¬ nextChar + 1;      END;    BEGIN    ENABLE UNWIND => Cleanup[];    parseH ¬ MailParse.Initialize[NextChar];    [nameList, fakeNameList] ¬ GetNameLists[h, parseH, 1];    IF fakeNameList # NIL THEN FreeNameList[fakeNameList];    END;  -- ENABLE UNWIND    IF parseH # NIL THEN MailParse.Finalize[parseH];    -- Note: Don't free nameList for normal case.    END;  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  PrintInvalidNameList: PROC [    swHandle: Window.Handle, list: MailTransport.Undeliverables,    defaultName: NSName.Name] =    BEGIN    -- ASSUME: Integrity of NSNames is garaunteed at this    --   point, so no StringBoundsFaults, etc.    FOR i: CARDINAL IN [0..LENGTH[list]) DO      name: NSName.Name ¬ @list[i].name;      string: LONG STRING ¬ [maxNameLength];      NSString.AppendToMesaString[string, name.local];      IF name.domain # NSString.nullString        AND NOT NSString.EquivalentStrings[name.domain, userDefaultName.domain]        THEN        BEGIN        String.AppendChar[string, ':];        NSString.AppendToMesaString[string, name.domain];        END;      IF name.org # NSString.nullString        AND NOT NSString.EquivalentStrings[name.org, userDefaultName.org] THEN        BEGIN        String.AppendChar[string, ':];        NSString.AppendToMesaString[string, name.org];        END;      IF i # 0 THEN Put.Text[swHandle, ", "L];      Put.LongString[swHandle, string];      <<      SELECT list[counter].reason FROM	noSuchRecipient => Put.Text[swHandle, "-no such recipient, "L];	cantValidateNow => Put.Text[swHandle, "-can't validate now, "L];	illegalName => Put.Text[swHandle, "-illegal name, "L];	refused => Put.Text[swHandle, "-refused at DS, "L];	invalidDL => Put.Text[swHandle, "-invalid mailing DL, "L];	timeout => Put.Text[swHandle, "-Timed-out, "L];	ENDCASE;>>      ENDLOOP;    END;  -- PrintInvalidNameList    END.  -- log:-- NSG      4-Feb-85 17:08:16 fixed Protocol violation that crashes a-- remote mailreading program
-- File: MailReadImplD.mesa - Last Edited:-- AlHall	 2-Jul-84 22:52:49-- Wobber	14-Nov-83 14:37:04-- PXK    	27-Jun-83 13:46:02-- NSG     	14-Jan-85 17:50:30-- BGY     	28-Apr-86 13:06:22DIRECTORY  AsciiSink USING [Create],  ByteBlt USING [ByteBlt],  Display USING [Black, White],  Environment USING [Block, Byte],  Format USING [Number, NumberFormat, StringProc],  Inline USING [LongDiv, LongDivMod, LongMult],  MailFile USING [    Attributes, Delete, Flag, GetMsgAttributes, Handle, MakeWritable,    MarkAttachments, MarkExamined, Messages, MsgNumber, nullMessage, SetMsgFlag, StreamPiece,    TOCEntry, UnDelete, UnMarkAttachments, UnMarkExamined],  MailReadOps USING [    data, Data, ForceOut, FreeMailFile, GetCurrent, MessageState],  Stream USING [Block, GetBlock, Handle, SetPosition],  String USING [AppendString],  TextSink,  TextSource USING [    ActOnProc, AsciiScanText, DoEditActionProc,    Error, GetLengthProc, Handle, Procedures, ProceduresObject, ReadTextProc,    ReplaceTextProc, SetLengthProc],  TextSW USING [GetSelection, SetSelection, Update],  UserInput USING [StringProcType],  UserTerminal USING [BlinkDisplay],  WindowFont USING [defaultFont, Handle];MailReadImplD: PROGRAM  IMPORTS    AsciiSink, ByteBlt, Display, Format, Inline, MailFile, MailReadOps,    Stream, String, TextSink, TextSource, TextSW, UserTerminal, WindowFont  EXPORTS MailReadOps =  BEGIN OPEN MR: MailReadOps;  charsPerLine: NATURAL = 128;  twiddleLength: NATURAL = 16;    flagPos: NATURAL = 0;  firstBlankPos: NATURAL = 1;  attachmentsPos: NATURAL = 2;  numberPos: NATURAL = 3;  secondBlankPos: NATURAL = 7;  markPos: NATURAL = 8;  thirdBlankPos: NATURAL = 9;  tocLinePos: NATURAL = 10;    barWidth: NATURAL = 1;    TOCBuffer: TYPE = LONG POINTER TO TOCBufferObject;  TOCBufferObject: TYPE = RECORD [    deleted: BOOLEAN,    lastPlusOne: NATURAL,  -- a block index, not a char index    variant: SELECT OVERLAID * FROM      chars => [chars: PACKED ARRAY [0..charsPerLine) OF CHARACTER],      null => NULL,      twiddle => [t: PACKED ARRAY [0..twiddleLength) OF CHARACTER],      ENDCASE];    nullBuffer: null TOCBufferObject ¬ [FALSE, 2, null[]];  nullBufferBlock: Environment.Block = [    LOOPHOLE[@nullBuffer], 2, 2];  twiddleBuffer: twiddle TOCBufferObject ¬ [    deleted: FALSE,    lastPlusOne: twiddleLength + 2,    variant: twiddle[t: TRASH]];    twiddleBufferBlock: Environment.Block = [    LOOPHOLE[@twiddleBuffer], 2, 2+twiddleLength];    Source: TYPE = LONG POINTER TO TOCSourceObject;  TOCSourceObject: TYPE = RECORD [    procs: TextSource.Procedures ¬ @tocSourceProcs,    buffer: TOCBuffer,    data: MR.Data,    mf: MailFile.Handle];  tocSourceProcs: TextSource.ProceduresObject ¬ [    actOn: ActOnSource, doEditAction: EditAction, getLength: GetLength,    readText: ReadText, replaceText: ReplaceText,    scanText: TextSource.AsciiScanText, setLength: SetLength];  Sink: TYPE = LONG POINTER TO TOCSinkObject;  TOCSinkObject: TYPE = RECORD [    procs: TextSink.Procedures ¬ @tocSinkProcs,    data: MR.Data,    half: NATURAL ¬ 5,    sink: TextSink.Handle];  tocSinkProcs: TextSink.ProceduresObject ¬ [    actOn: ActOnSink, fontInfo: SinkInfo, positions: CountPositions,    display: DisplayLine, measure: MeasureLine,    measureChar: MeasureChar, resolve: ResolveLine];-- convenient LOOPHOLE  TextBase: PROCEDURE [s: LONG STRING]    RETURNS [LONG POINTER TO PACKED ARRAY INTEGER[0..0) OF Environment.Byte] =    INLINE {RETURN[LOOPHOLE[@s.text]]};-- source implementation routines  SourceToTOCSource: PROCEDURE [h: TextSource.Handle] RETURNS [s: Source] = {    s ¬ LOOPHOLE[h];    IF s.procs # @tocSourceProcs THEN ERROR TextSource.Error[other]};  TOCSourceCreate: PUBLIC PROCEDURE [data: MR.Data, mf: MailFile.Handle]    RETURNS [TextSource.Handle] = {    s: Source;    IF data.tocBuffer = NIL THEN      data.tocBuffer ¬ data.z.NEW[chars TOCBufferObject];    s ¬ data.z.NEW[TOCSourceObject ¬ [      data: data, mf: mf, buffer: data.tocBuffer]];    RETURN[@s.procs]};  ActOnSource: TextSource.ActOnProc = {    s: Source;    data: MR.Data;    IF source = NIL THEN RETURN;    s ¬ SourceToTOCSource[source];    data ¬ s.data;    SELECT action FROM      destroy => data.z.FREE[@source];      sleep, truncate, wakeup => NULL;      ENDCASE => ERROR TextSource.Error[other];    RETURN};  EditAction: TextSource.DoEditActionProc = {RETURN[0]};  GetLength: TextSource.GetLengthProc = {    s: Source = SourceToTOCSource[source];    RETURN[      IF s.data.nilToc THEN 0      ELSE PositionForMessage[MailFile.Messages[s.mf]] + twiddleLength]};  ReadText: TextSource.ReadTextProc =    BEGIN    s: Source = SourceToTOCSource[source];    msg, msgCount: MailFile.MsgNumber;    offset: NATURAL;    IF s.data.nilToc THEN RETURN[nullBufferBlock, 0];    [msg, offset] ¬ Inline.LongDivMod[position, charsPerLine];    SELECT (msgCount ¬ MailFile.Messages[s.mf]) FROM      < msg => {        block ¬ nullBufferBlock;	next ¬ PositionForMessage[msgCount] + twiddleLength};      = msg => {        IF offset > twiddleLength THEN offset ¬ twiddleLength;	block ¬ twiddleBufferBlock;	next ¬ PositionForMessage[msgCount] + twiddleLength};      ENDCASE => {	block ¬ TOCLine[s.data, s.mf, msg];	next ¬ PositionForMessage[msg + 1]};    block.startIndex ¬ MIN[block.startIndex + offset, block.stopIndexPlusOne];    IF block.stopIndexPlusOne - block.startIndex > maxLength THEN {      block.stopIndexPlusOne ¬ block.startIndex + maxLength;      next ¬ position + maxLength};    RETURN;    END;  ReplaceText: TextSource.ReplaceTextProc = {RETURN[from, 0]};  SetLength: TextSource.SetLengthProc = {RETURN[GetLength[source]]};-- sink implementation routines  SinkToTOCSink: PROCEDURE [h: TextSink.Handle] RETURNS [s: Sink] = {    s ¬ LOOPHOLE[h];    IF s.procs # @tocSinkProcs THEN ERROR TextSink.Error[invalidSink]};  oldSink: Sink ¬ NIL;    TOCSinkCreate: PUBLIC PROCEDURE [data: MR.Data, font: WindowFont.Handle]    RETURNS [TextSink.Handle] = {    s: Sink;    IF font = NIL THEN font ¬ WindowFont.defaultFont;    IF oldSink = NIL THEN oldSink ¬ s ¬ data.z.NEW[TOCSinkObject ¬ [      data: data,      sink: AsciiSink.Create[font],      half: 0]]    ELSE {s ¬ oldSink; [] ¬ s.sink.ActOn[destroy]; s­ ¬ [      data: data,      sink: AsciiSink.Create[font],      half: 0];};    s.half ¬ s.sink.FontInfo[].lineHeight/2 - barWidth;    RETURN[@s.procs]};  ActOnSink: TextSink.ActOnProc = {    s: Sink;    data: MR.Data;    IF sink = NIL THEN RETURN[bad];    s ¬ SinkToTOCSink[sink];    data ¬ s.data;    SELECT action FROM      destroy => {[] ¬ sink.ActOn[destroy]; data.z.FREE[@sink]};      sleep, wakeup => NULL;      ENDCASE => ERROR TextSink.Error[other];    RETURN[ok]};  SinkInfo: TextSink.FontInfoProc = {    s: Sink = SinkToTOCSink[sink];    RETURN s.sink.FontInfo[]};  CountPositions: TextSink.PositionsProc = {    RETURN[block.stopIndexPlusOne - block.startIndex]};  MeasureChar: TextSink.MeasureCharProc = {    s: Sink = SinkToTOCSink[sink];    RETURN[s.sink.MeasureChar[char, xOffset]]};  DisplayLine: TextSink.DisplayProc =    BEGIN    s: Sink = SinkToTOCSink[sink];    tocBuffer: TOCBuffer = LOOPHOLE[block.blockPointer];    IF block.startIndex >= tocBuffer.lastPlusOne THEN {      count: CARDINAL = block.stopIndexPlusOne - block.startIndex;      block.startIndex ¬ block.stopIndexPlusOne;      RETURN[place, count, consumed]}    ELSE {      right: NATURAL;      [newPlace, positions, why] ¬        s.sink.Display[block, lineLength, offset, window, place, flags];      right ¬ IF newPlace.x < place.x THEN lineLength ELSE newPlace.x;      IF tocBuffer.deleted THEN        (IF flags.srcFunc = complement THEN Display.White ELSE Display.Black)	  [window, [          [x: place.x, y: place.y + s.half], [w: right - place.x, h: barWidth]]];      RETURN};    END;  MeasureLine: TextSink.MeasureProc = {    s: Sink = SinkToTOCSink[sink];    tocBuffer: TOCBuffer = LOOPHOLE[block.blockPointer];    IF block.startIndex >= tocBuffer.lastPlusOne THEN {      count: CARDINAL = block.stopIndexPlusOne - block.startIndex;      block.startIndex ¬ block.stopIndexPlusOne;      RETURN[place, count, consumed]}    ELSE RETURN s.sink.Measure[block, lineLength, offset, place]};  ResolveLine: TextSink.ResolveProc = {    s: Sink = SinkToTOCSink[sink];    tocBuffer: TOCBuffer = LOOPHOLE[block.blockPointer];    IF block.startIndex >= tocBuffer.lastPlusOne THEN {      count: CARDINAL = block.stopIndexPlusOne - block.startIndex;      block.startIndex ¬ block.stopIndexPlusOne;      RETURN[startX, count, consumed]}    ELSE RETURN s.sink.Resolve[block, startX, xToFind, offset, halfCharResolve]};-- where the real work gets done for the source<<	The format of a toc line is		XnnnnBYBssssssC	X	= the flag char (typically " ")	nnnn	= right four digits of message number	B       = blank	Y	= current => European quote, unexamined => "*", else " "	ssssss	= the text available from the toc file	C	= Ascii.CR>> <<	Life is somewhat complicated here since there is a bug in TextDisplay	that prevents there from being a hole in a source. To counteract this,	the line buffer is being filled with spaces to fill up the rest of	the string before the CR. This is only a temporary measure (I hope).>>  TOCLine: PUBLIC PROCEDURE [    data: MR.Data, mf: MailFile.Handle, msg: MailFile.MsgNumber]    RETURNS [Environment.Block] =    BEGIN    nextMessageInvisible: BOOLEAN ¬      msg + 1 < MailFile.Messages[mf] AND      MessageInvisible[mf, msg + 1];    tocBuffer: TOCBuffer = data.tocBuffer;    flag: MailFile.Flag;    tocLineChars: NATURAL;    attr: MailFile.Attributes;    startIndex: CARDINAL ¬ 0;    p: MailFile.StreamPiece;    AttachmentsChar: PROC RETURNS [CHARACTER] = INLINE {      RETURN[SELECT TRUE FROM	attr[attachments] => 'a,	ENDCASE => ' ]};    MarkChar: PROC RETURNS [CHARACTER] = INLINE {      RETURN[SELECT TRUE FROM	data.currentDisplayed = msg => '»,	~attr[examined] => '*,	ENDCASE => ' ]};    [p, attr, flag] ¬ MailFile.TOCEntry[mf, msg];    tocBuffer.deleted ¬ attr[deleted];    tocLineChars ¬ CARDINAL[p.lastPlusOne - p.first];    IF msg # data.inTocBuffer OR nextMessageInvisible OR      MessageInvisible[mf, msg] THEN {      zeros: Format.NumberFormat = [zerofill: TRUE, columns: 4];      spaces: Format.NumberFormat = [zerofill: FALSE, columns: 4];      format: Format.NumberFormat;      PutInNumber: Format.StringProc = {String.AppendString[numberString, s]};      numberString: STRING = [7];      number: CARDINAL ¬ msg + 1;      tocBuffer.chars ¬ ALL[' ];      tocBuffer.chars[flagPos] ¬ flag;      tocBuffer.chars[firstBlankPos] ¬ ' ;      tocBuffer.chars[attachmentsPos] ¬ AttachmentsChar[];      IF number > 9999 THEN {number ¬ number MOD 1000; format ¬ zeros}      ELSE format ¬ spaces;      Format.Number[PutInNumber, number, format];      tocBuffer.chars[numberPos] ¬ numberString[0];      tocBuffer.chars[numberPos + 1] ¬ numberString[1];      tocBuffer.chars[numberPos + 2] ¬ numberString[2];      tocBuffer.chars[numberPos + 3] ¬ numberString[3];      tocBuffer.chars[secondBlankPos] ¬ ' ;      tocBuffer.chars[markPos] ¬ MarkChar[];      tocBuffer.chars[thirdBlankPos] ¬ ' ;      p.stream.SetPosition[p.first];      tocBuffer.lastPlusOne ¬	tocLinePos + 1 + 2 + --extra 1 is for the CR we are about to put on	p.stream.GetBlock[	  block: [	    blockPointer: data.tocBuffer,	    startIndex: tocLinePos + 2,	    stopIndexPlusOne: tocLineChars + tocLinePos + 2]].bytesTransferred;      IF MessageInvisible[mf, msg] THEN tocBuffer.chars ¬ ALL[' ];      tocBuffer.chars[tocBuffer.lastPlusOne - 3] ¬ 	IF nextMessageInvisible	  THEN '\040	  ELSE '\n;      tocBuffer.chars[tocBuffer.lastPlusOne - 2] ¬ '\000;      [] ¬ ByteBlt.ByteBlt[        from: [data.tocBuffer, tocBuffer.lastPlusOne, charsPerLine+1],	to: [data.tocBuffer, tocBuffer.lastPlusOne+1, charsPerLine+2],	overLap: ripple];      data.inTocBuffer ¬ msg}    ELSE {      tocBuffer.chars[flagPos] ¬ flag;      tocBuffer.chars[attachmentsPos] ¬ AttachmentsChar[];      tocBuffer.chars[markPos] ¬ MarkChar[]};    RETURN[[data.tocBuffer, 2, charsPerLine+2]];    END;-- and the side door routines  MessageInvisible: PUBLIC PROCEDURE [mf: MailFile.Handle, message: MailFile.MsgNumber]    RETURNS [invisible: BOOLEAN] =    BEGIN    RETURN [FALSE --MailFile.TOCEntry[mf, message].flag = 's-- ];    END;  TOCPosition: PUBLIC PROCEDURE [mf: MailFile.Handle, msg: MailFile.MsgNumber]    RETURNS [LONG CARDINAL] = {RETURN[PositionForMessage[msg]]};      TOCPositionToMsg: PUBLIC PROCEDURE [mf: MailFile.Handle, pos: LONG CARDINAL]    RETURNS [MailFile.MsgNumber] = {RETURN[Inline.LongDiv[pos, charsPerLine]]};      PositionForMessage: PROCEDURE [msg: MailFile.MsgNumber]    RETURNS [LONG CARDINAL] =    INLINE {RETURN[Inline.LongMult[charsPerLine, msg]]};  NearestVisibleMessage: PUBLIC PROCEDURE [    mf: MailFile.Handle, msg: MailFile.MsgNumber, firstTryBackward: BOOLEAN ¬ FALSE]    RETURNS [visibleMessage: MailFile.MsgNumber] =    BEGIN    IF NOT MessageInvisible[mf, msg] THEN RETURN [msg];    IF firstTryBackward THEN      FOR m: MailFile.MsgNumber IN (msg..0] DO	IF NOT MessageInvisible[mf, m] THEN RETURN [m];	ENDLOOP;    FOR m: MailFile.MsgNumber IN (msg..MailFile.Messages[mf]) DO      IF NOT MessageInvisible[mf, m] THEN RETURN [m];      ENDLOOP;    RETURN [MailFile.nullMessage];    END;      InitTwiddleBuffer: PROCEDURE =    BEGIN    twiddleBuffer.t[0] ¬ '\040;    twiddleBuffer.t[1] ¬ '\040;    FOR i: NATURAL IN [2..twiddleLength-1) DO      twiddleBuffer.t[i] ¬ '~;      ENDLOOP;    twiddleBuffer.t[twiddleLength - 1] ¬ '\015;    END;      TOCStringProc: PUBLIC UserInput.StringProcType =    BEGIN    left, right: LONG CARDINAL;    msg: MailFile.MsgNumber;    mf: MailFile.Handle;    data: MR.Data ¬ MR.data;    offset: NATURAL;    [left, right] ¬ TextSW.GetSelection[data.tocSW];    IF right - left # 1 THEN GOTO nope;    [msg, offset] ¬ Inline.LongDivMod[left, charsPerLine];    IF offset # 0 THEN GOTO nope;    mf ¬ MR.GetCurrent[data];    MarkMessage[mf, msg, data, newFlag, string[0]];    MR.FreeMailFile[data, mf];    TextSW.SetSelection[data.tocSW, right, right];     IF string.length > 1 THEN GOTO nope;    EXITS nope => UserTerminal.BlinkDisplay[];    END;      MarkMessage: PUBLIC PROCEDURE [    mf: MailFile.Handle, msg: CARDINAL, data: MR.Data,    as: MR.MessageState, char: CHARACTER ¬ NULL] =    BEGIN    index: LONG CARDINAL ¬ PositionForMessage[msg];    attr: MailFile.Attributes;    IF msg # MailFile.nullMessage THEN      attr ¬ MailFile.GetMsgAttributes[mf, msg].attributes;    IF (as = attachments AND attr[attachments]) OR       (as = noAttachments AND ~attr[attachments]) OR       (as = deleted AND attr[deleted]) OR       (as = undeleted AND ~attr[deleted]) OR       (as = notSeen AND ~attr[examined]) OR       (as = seen AND attr[examined]) OR       (as = current AND data.currentDisplayed = msg) THEN RETURN;    IF as # current THEN MailFile.MakeWritable[mf];    SELECT as FROM      attachments => {        -- Not currently used, since initialized in	--   MailFile.StartAnotherMessage.	MailFile.MarkAttachments[mf, msg];	index ¬ index + attachmentsPos};      noAttachments => {	MailFile.UnMarkAttachments[mf, msg];	index ¬ index + attachmentsPos};      current => {        oldCurrent: MailFile.MsgNumber = data.currentDisplayed;	data.currentDisplayed ¬ msg;	IF oldCurrent # MailFile.nullMessage THEN {	  oldIndex: LONG CARDINAL = PositionForMessage[oldCurrent] + markPos;	  TextSW.Update[data.tocSW, oldIndex, oldIndex + 1, FALSE]};	IF msg = MailFile.nullMessage THEN RETURN;	index ¬ index + markPos};      seen => {        -- Not currently used, since initialized in	--   MailFile.StartAnotherMessage.        MailFile.MarkExamined[mf, msg];	index ¬ index + markPos};      deleted =>   MailFile.Delete[mf, msg];      undeleted => MailFile.UnDelete[mf, msg];      notSeen =>   {MailFile.UnMarkExamined[mf, msg]; index ¬ index + markPos};      newFlag => {MailFile.SetMsgFlag[mf, msg, char]; index ¬ index + flagPos};      moved => {        MailFile.SetMsgFlag[mf, msg, 'm];	index ¬ index + flagPos;        MailFile.Delete[mf, msg]};      ENDCASE;    IF as # current THEN MR.ForceOut[data, mf, didSomething];    TextSW.Update[data.tocSW, index, index + 1, FALSE];    END;-- main line code  InitTwiddleBuffer[];    END...  -- NSG   14-Jan-85 17:50:41  changed bullets to European quotes for char set 0
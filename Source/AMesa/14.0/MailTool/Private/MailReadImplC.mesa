-- Copyright (C) 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- File: MailReadImplC.mesa - Last Edited by:-- Sikorski	14-May-82 14:16:31-- PXK    	23-Sep-83 14:27:53-- RXJ     	17-Sep-82 15:25:22<< This module has the hardcopy stuff in it>>DIRECTORY  Ascii USING [CR, FF, NUL],  Environment USING [Block],  Heap USING [systemZone],  Interpress82Maker USING [CreatePresser, CreatePrinter],  MailFile USING [    File, Handle, Message, Messages, MsgNumber, nullMessage, StreamPiece],  MailReadOps USING [    BackgroundProc, Data, FormatType, FreeMailFile, GetCurrent,    HardcopyErrorCode, Post, TOCLine],  MailUtil USING [zone],  MFile USING [    AcquireTemp, Error, GetProperties, Handle, maxNameLength, ReadOnly],  MLoader USING [Error, Handle, Load, Unload, VersionMismatch],  MStream USING [Copy, Create, Error, GetLength, Handle, WriteOnly],  Press USING [FontSlope, FontWeight, Handle, Mica, micasPerInch],  PressPrint USING [Handle],  PressStream USING [    Create, Margins, Parameters, ParametersHandle, SetFont, SetParameters],  PressUtilities USING [NoFontsDotWidths],  Profile USING [GetUser],  Runtime USING [IsBound],  Stream USING [    Delete, GetPosition, Handle, PutBlock, PutChar, PutString, SetPosition],  String USING [    AppendChar, AppendString, AppendDecimal, Copy, CopyToNewString, Empty,    StringBoundsFault],  TajoMisc USING [WaitSecs],  Time USING [Append, Current, Packed, Unpack],  UserInput USING [UserAbort],  UserTerminal USING [BlinkDisplay];MailReadImplC: PROGRAM  IMPORTS    Heap, Interpress82Maker, MailFile, MailReadOps, MailUtil, MFile, MLoader,    MStream, PressStream, PressUtilities, Profile, Runtime,    Stream, String, TajoMisc, Time, UserInput, UserTerminal  EXPORTS MailReadOps =  BEGIN OPEN MR: MailReadOps;  HardcopyError: PUBLIC SIGNAL [code: MR.HardcopyErrorCode] = CODE;  CannotRun: ERROR = CODE;  zone: UNCOUNTED ZONE = MailUtil.zone;  normalFont: CARDINAL = 0;  biggerFont: CARDINAL = 1;  --HardcopyOfMessages prints the selected messages in the current mail file  Hardcopy: PUBLIC MR.BackgroundProc =    BEGIN    ENABLE PressUtilities.NoFontsDotWidths => {      Post["continuing without Fonts.widths ... "L]; RESUME};    inch: Press.Mica = Press.micasPerInch;    lMargins: PressStream.Margins = [      left: inch*3/4, right: inch/2, top: inch/2, bottom: inch/2];    pMargins: PressStream.Margins = [      left: inch*3/4, right: inch*3/4, top: inch*3/4, bottom: inch*3/4];    presser: Press.Handle ¬ NIL;    printer: PressPrint.Handle ¬ NIL;    parameters: PressStream.Parameters;    userName: LONG STRING ¬ NIL;    outputStream: MStream.Handle ¬ NIL;    outputFileName: LONG STRING ¬ NIL;    pressStream: Stream.Handle ¬ NIL;    FinishFile: PROCEDURE [      stream: Stream.Handle, filed: BOOLEAN, name: LONG STRING, count: CARDINAL,      forgetIt: BOOLEAN] =      BEGIN      length: LONG CARDINAL;      pressStream.Delete[ ! MFile.Error => {        forgetIt ¬ TRUE; normalFinish ¬ FALSE; CONTINUE}];      SELECT TRUE FROM        forgetIt => Post[" ran out of room for press file."L];        filed => PostCount[""L, count, " pressed to file "L, name];        UserInput.UserAbort[data.msgSW] => Post[" aborted."L];	ENDCASE => {          length ¬ stream.GetPosition[];          stream.SetPosition[0];          SendStream[stream, "Mail Messages"L, Time.Current[], length]};      stream.Delete[];      END;  --of FinishFile    InitHardcopy: PROCEDURE =      BEGIN      BufferItem: TYPE = RECORD [p: CARDINAL, s: LONG STRING];      Buffer: TYPE = POINTER TO BufferItem;      GetChar: PROCEDURE [b: Buffer] RETURNS [c: CHARACTER] =        BEGIN OPEN b;        c ¬ Ascii.NUL;        IF s # NIL AND p < s.length THEN          BEGIN          c ¬ s[p];          p ¬ p + 1;          IF c IN ['A..'Z] THEN c ¬ LOOPHOLE[LOOPHOLE[c, CARDINAL] + 40B];          END;        END;  --of GetChar      Backup: PROCEDURE [b: Buffer] = BEGIN IF b.p # 0 THEN b.p ¬ b.p - 1; END;      GetNumber: PROCEDURE [b: Buffer, default: CARDINAL] RETURNS [v: CARDINAL] =        BEGIN        c: CHARACTER;        usedefault: BOOLEAN ¬ TRUE;        v ¬ 0;        WHILE (c ¬ GetChar[b]) IN ['0..'9] DO          usedefault ¬ FALSE; v ¬ v*10 + (c - 60C); ENDLOOP;        IF c # Ascii.NUL THEN Backup[b];        IF usedefault THEN RETURN[default];        END;  --of GetNumber      InstallFont: PROCEDURE [f: LONG STRING] =        BEGIN        name: STRING ¬ [40];        b: BufferItem ¬ [0, f];        c: CHARACTER;        weight: Press.FontWeight ¬ medium;        slope: Press.FontSlope ¬ regular;        points: CARDINAL;        PointsToMicas: PROC [p: LONG CARDINAL] RETURNS [Press.Mica] = {          RETURN[(p*Press.micasPerInch + 36)/72]};        DO          c ¬ GetChar[@b];          IF c = Ascii.NUL THEN EXIT;          IF c IN ['0..'9] THEN BEGIN Backup[@b]; EXIT END;          String.AppendChar[name, c];          ENDLOOP;        points ¬ GetNumber[@b, IF data.orientation = landscape THEN 6 ELSE 8];        UNTIL (c ¬ GetChar[@b]) = Ascii.NUL DO          IF c = 'b THEN weight ¬ bold ELSE IF c = 'i THEN slope ¬ italic;          ENDLOOP;        presser.DefineAlias[          h: presser, alias: normalFont, name: name, w: weight, s: slope,          size: PointsToMicas[points]];        presser.DefineAlias[          h: presser, alias: biggerFont, name: name, w: weight, s: slope,          size: PointsToMicas[points + 2]];        END;  --of InstallFont      --      --Mainline code for InitHardcopy      --      IF ~PrintReady[data.format] THEN        TryToRun[          format: data.format,          root: "Print"L !          CannotRun => {            Post["Need Print to get hardcopy."L];            ERROR HardcopyError[needPrint]}];      parameters ¬ [        margins: IF data.orientation = portrait THEN pMargins ELSE lMargins,        columns: IF data.orientation = portrait THEN 1 ELSE 2,        trailers: data.orientation = landscape,	mode: IF data.orientation = portrait THEN portrait ELSE landscape];      presser ¬ Interpress82Maker.CreatePresser[zone];      IF data.fileOutput THEN        outputFileName ¬ String.CopyToNewString[          data.hardcopyOutputFiles, zone];      IF String.Empty[data.fontNames[data.orientation]] THEN        data.fontNames[data.orientation] ¬ String.CopyToNewString[          IF data.orientation = portrait THEN "Gacha8"L ELSE "Gacha6"L, zone];      InstallFont[data.fontNames[data.orientation]];      END;  --of InitHardcopy    StartFile: PROCEDURE =      BEGIN      IF data.fileOutput THEN        outputStream ¬ MStream.WriteOnly[          outputFileName, [], binary !          MStream.Error => {            Post["\nCan't write on file "L, outputFileName];            ERROR HardcopyError[badOutputFileName]}]      ELSE {        temp: MFile.Handle = MFile.AcquireTemp[type: binary];        outputStream ¬ MStream.Create[file: temp, release: []]};      pressStream ¬ PressStream.Create[        press: presser, output: outputStream,        name: IF data.fileOutput THEN outputFileName ELSE "Mail Messages"L];      END;  --of StartFile    SendStream: PROCEDURE [      s: Stream.Handle, fileName: LONG STRING, createTime: Time.Packed,      length: LONG CARDINAL] =      BEGIN      status: {finished, failed, aborted, down} ¬ finished;      printedBy: LONG STRING = [60];      printer: PressPrint.Handle =        Interpress82Maker.CreatePrinter[];      AppendUser: PROCEDURE [name, password: LONG STRING] = {        String.AppendString[printedBy, name]};      FOR i: CARDINAL IN [0..data.hardcopyUserName.length) DO        ENABLE String.StringBoundsFault => EXIT;	c: CHARACTER;	IF (c ¬ data.hardcopyUserName[i]) = '$ THEN Profile.GetUser[	  AppendUser,	  IF data.format = interpress82 THEN clearinghouse ELSE registry]	ELSE String.AppendChar[printedBy, c];        ENDLOOP;      Post["Sending to "L, data.printerNames, " ..."L];      {      avail: BOOLEAN;      msg: LONG STRING;      [avail, msg] ¬ printer.GetStatus[data.printerNames !        printer.Trouble => {	  IF ~String.Empty[message] THEN Post["\n"L, message];	  GOTO printerDown}];      IF ~avail THEN {        IF String.Empty[msg] THEN Post[" unavailable"L]        ELSE {	  IF msg[msg.length-1] = Ascii.CR THEN msg.length ¬ msg.length - 1;	  Post["\n"L, msg];	  Heap.systemZone.FREE[@msg]};	GOTO printerDown};      IF UserInput.UserAbort[data.msgSW] THEN GOTO userAbort;      printer.SendPressStream[        stream: s, bytes: MStream.GetLength[s],        host: data.printerNames, copies: 1, sides: data.sides,        fileName: fileName, userName: printedBy, date: createTime !        printer.Trouble =>          SELECT code FROM            busy => {	      IF Wait[IF message = NIL THEN "busy"L ELSE message, 8] THEN	        GOTO userAbort;	      RESUME};            timeout => {              IF Wait["not responding"L, 0] THEN GOTO userAbort; RESUME };            ENDCASE => {              IF ~String.Empty[message] THEN Post["\n"L, message, "..."L];              status ¬ failed;              CONTINUE}]      EXITS        userAbort => status ¬ aborted;	printerDown => status ¬ down};      printer.Delete[printer];      SELECT status FROM	aborted => {Post[" Aborted"L]; normalFinish ¬ FALSE};  	failed => {Post[" Failed"L]; normalFinish ¬ FALSE};	down => normalFinish ¬ FALSE;  	finished => NULL;          ENDCASE => ERROR;      EXITS      END;    Wait: PROCEDURE [why: LONG STRING, howlong: CARDINAL]      RETURNS [aborted: BOOLEAN] =      BEGIN      start: Time.Packed;      Post["\nServer "L, why, "... will retry"L];      start ¬ Time.Current[];      TajoMisc.WaitSecs[howlong];      Post["... "L];      RETURN[UserInput.UserAbort[data.msgSW]];      END;    mf: MailFile.Handle = MR.GetCurrent[data];    --main body of HardcopyOfMessages    normalFinish ¬ TRUE;    IF data.firstSelect >= MailFile.Messages[mf] THEN UserTerminal.BlinkDisplay[]    ELSE      BEGIN      count: CARDINAL = data.lastSelect - data.firstSelect + 1;      headerString: STRING = [150];      create: Time.Packed = MFile.GetProperties[        MailFile.File[mf], headerString].create;      String.AppendString[headerString, "     "L];      Time.Append[headerString, Time.Unpack[create]];      InitHardcopy[];      parameters.headerString ¬ headerString;      StartFile[];      PrintMailFile[data, count, pressStream, @parameters, mf !        MFile.Error => {normalFinish ¬ FALSE; CONTINUE}];      IF ~normalFinish THEN outputStream.SetPosition[0];      FinishFile[        outputStream, data.fileOutput, outputFileName, count, ~normalFinish];      presser.Delete[presser];      END;    MR.FreeMailFile[data, mf];    RETURN[MailFile.nullMessage, normalFinish]    END;  --of HardcopyOfMessages  PrintMailFile: PROCEDURE [    data: MR.Data, count: CARDINAL, pStream: Stream.Handle,    parms: PressStream.ParametersHandle, mH: MailFile.Handle] =    BEGIN    first: MailFile.MsgNumber = data.firstSelect;    IF count = 1 THEN parms.headers ¬ parms.trailers ¬ FALSE;    PressStream.SetParameters[pStream, parms];    PressStream.SetFont[pStream, normalFont];    PostCount["Pressing "L, count, " ..."L];    IF count > 4 OR (count > 1 AND ~data.separatePages) THEN {  -- show TOC      parms.wrap ¬ FALSE;      PressStream.SetParameters[pStream, parms];      FOR i: MailFile.MsgNumber IN [first..first + count) DO        WriteTOCEntryToStream[pStream, data, mH, i] ENDLOOP;      parms.wrap ¬ TRUE;      PressStream.SetParameters[pStream, parms];      pStream.PutChar[Ascii.FF]};    FOR i: MailFile.MsgNumber IN [first..first + count) DO      IF UserInput.UserAbort[data.msgSW] THEN EXIT;      IF ~data.separatePages THEN {        parms.wrap ¬ FALSE;        PressStream.SetParameters[pStream, parms];        PressStream.SetFont[pStream, biggerFont];        WriteTOCEntryToStream[pStream, data, mH, i];        parms.wrap ¬ TRUE;        PressStream.SetParameters[pStream, parms];        PressStream.SetFont[pStream, normalFont];        pStream.PutChar[Ascii.CR]};      WritePieceToStream[pStream, MailFile.Message[mH, i]];      IF i < first + count - 1 THEN        IF data.separatePages THEN pStream.PutChar[Ascii.FF]        ELSE pStream.PutString["\n\n"L];      ENDLOOP;    END;  --of PrintMailFile  WritePieceToStream: PROC [out: Stream.Handle, from: MailFile.StreamPiece] = {    from.stream.SetPosition[from.first];    [] ¬ MStream.Copy[      to: out, from: from.stream, bytes: from.lastPlusOne - from.first]};  WriteTOCEntryToStream: PROC [    out: Stream.Handle, data: MR.Data, mH: MailFile.Handle,    msg: MailFile.MsgNumber] = {    block: Environment.Block = MR.TOCLine[data, mH, msg];    out.PutBlock[block]};  Post: PROCEDURE [s1, s2, s3, s4: LONG STRING ¬ NIL] = {    IF s1 # NIL THEN MR.Post[s1, FALSE];    IF s2 # NIL THEN MR.Post[s2, FALSE];    IF s3 # NIL THEN MR.Post[s3, FALSE];    IF s4 # NIL THEN MR.Post[s4, FALSE]};  PostCount: PROCEDURE [    s1: LONG STRING, count: INTEGER, s3, s4: LONG STRING ¬ NIL] = {    s2: LONG STRING ¬ [20];    String.AppendDecimal[s2, count];    String.AppendString[s2, IF count = 1 THEN " message"L ELSE " messages"L];    Post[s1, s2, s3, s4]};  -- some utility stuff  PrintReady: PROCEDURE [format: MR.FormatType]    RETURNS [isReady: BOOLEAN] = {    p: PROC ¬ LOOPHOLE[Interpress82Maker.CreatePresser];    RETURN[Runtime.IsBound[LOOPHOLE[p]]]};  RunFile: PROCEDURE [name: LONG STRING]    RETURNS [loaderHandle: MLoader.Handle ¬ NIL] =    BEGIN    ENABLE UNWIND => loaderHandle ¬ NIL;    fileHandle: MFile.Handle ¬ NIL;    fileHandle ¬ MFile.ReadOnly[name, [] ! MFile.Error => ERROR CannotRun];    Post["\nLoading "L, name, " ... "L];    loaderHandle ¬ MLoader.Load[fileHandle, [codeLinks: FALSE] !      MLoader.Error => {        Post["Load Error: ", string, ". Aborted"L]; ERROR CannotRun};      MLoader.VersionMismatch => {        Post["Version Mismatch: ", module, ". Aborted"L]; ERROR CannotRun}];    END;  --of RunFile  TryToRun: PROCEDURE [format: MR.FormatType, root: LONG STRING] =    BEGIN    fileToRun: LONG STRING ¬ [MFile.maxNameLength];    loaderHandle: MLoader.Handle ¬ NIL;    numExt: CARDINAL = 2;    extensions: ARRAY [0..numExt) OF STRING = [".archiveBcd"L, ".bcd"L];    FOR i: CARDINAL IN [0..numExt) DO      String.Copy[fileToRun, root];      String.AppendString[fileToRun, extensions[i]];      loaderHandle ¬ RunFile[        fileToRun ! CannotRun => IF i < numExt - 1 THEN CONTINUE];      IF loaderHandle # NIL THEN EXIT;      ENDLOOP;    IF PrintReady[format] THEN Post["Done\n"L]    ELSE {      Post["Wrong version! UnLoading ... "L];      MLoader.Unload[loaderHandle];      Post["Done\n"L];      ERROR CannotRun};    END;  --of TryToRun  -- Mainline code  END.. -- of MailReadImplC  
-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved. -- File: StreamSourceImpl.mesa - last edited:-- PXK    , 	 9-Dec-83  9:31:19-- Woods, 	83-Jul-14  5:59 pmDIRECTORY  StreamSource USING [Handle, Piece],  Environment USING [charsPerPage],  Heap USING [systemZone],  MStream USING [IsIt, ShareBlock],  Stream USING [GetBlock, SetPosition],  TextSource USING [    Action, ActOnProc, AsciiScanText, Class, DoEditActionProc,    Error, GetLengthProc, Handle, Position, Procedures, ProceduresObject,    ReadTextProc, ReplaceTextProc, SetLengthProc, AsciiTestClass];StreamSourceImpl: PROGRAM  IMPORTS Heap, MStream, Stream, TextSource EXPORTS StreamSource =  BEGIN  -- Stream Sources  Piece: TYPE = StreamSource.Piece;    bufferSize: CARDINAL = 10*Environment.charsPerPage - 20;  Buffer: TYPE = PACKED ARRAY [0..bufferSize) OF CHARACTER;    StreamType: TYPE = {mStream, regular, unknown};  SS: TYPE = LONG POINTER TO StreamSourceObject;  StreamSourceObject: TYPE = RECORD [    procs: TextSource.Procedures ¬ @streamProcs,    piece: Piece,    buffer: LONG POINTER TO Buffer ¬ NIL,    heap: UNCOUNTED ZONE,    type: StreamType];  streamProcs: TextSource.ProceduresObject ¬ [    actOn: ActOn, doEditAction: EditAction, getLength: GetLength,    readText: ReadText, replaceText: ReplaceText,    scanText: TextSource.AsciiScanText, setLength: SetLength];  SourceToStreamSource: PROCEDURE [h: TextSource.Handle] RETURNS [s: SS] = {    s ¬ LOOPHOLE[h];    IF s.procs # @streamProcs THEN ERROR TextSource.Error[other]};  ActOn: TextSource.ActOnProc = {    ss: SS;    IF source = NIL THEN RETURN;    ss ¬ SourceToStreamSource[source];    SELECT action FROM      destroy => {        z: UNCOUNTED ZONE = ss.heap; -- copied because is node about to be FREEd	z.FREE[@ss.buffer];  -- ss.buffer is probably already NIL	z.FREE[@ss]};      sleep, truncate, wakeup => NULL;      ENDCASE => ERROR TextSource.Error[other];    RETURN};  EditAction: TextSource.DoEditActionProc = {RETURN[0]};  Create: PUBLIC PROCEDURE [piece: Piece, zone: UNCOUNTED ZONE]    RETURNS [StreamSource.Handle] = {    ss: SS;    IF zone = NIL THEN zone ¬ Heap.systemZone;    ss ¬ zone.NEW[StreamSourceObject ¬ [      piece: piece,      heap: zone,      type: unknown] ];    RETURN[@ss.procs]};  GetLength: TextSource.GetLengthProc = {    ss: SS = SourceToStreamSource[source];    RETURN[ss.piece.eof - ss.piece.offset]};  ReadText: TextSource.ReadTextProc = {    ss: SS = SourceToStreamSource[source];    offset: LONG CARDINAL = position + ss.piece.offset;    lastIndex: LONG CARDINAL = MIN[offset, ss.piece.eof];    charsToCheck: CARDINAL ¬ CARDINAL[MIN[ss.piece.eof - lastIndex, maxLength]];    IF charsToCheck = 0 THEN RETURN[[NIL, 0, 0], position];         IF ss.type = unknown THEN {      IF MStream.IsIt[ss.piece.stream] THEN {        IF ss.buffer # NIL THEN ss.heap.FREE[@ss.buffer];	ss.type ¬ mStream}      ELSE {        IF ss.buffer = NIL THEN ss.buffer ¬ ss.heap.NEW[Buffer];	ss.type ¬ regular}};    IF ss.type = mStream THEN      block ¬ MStream.ShareBlock[ss.piece.stream, offset, charsToCheck]    ELSE {      IF charsToCheck > bufferSize THEN charsToCheck ¬ bufferSize;      ss.piece.stream.SetPosition[offset];      block ¬ [LOOPHOLE[ss.buffer], 0, charsToCheck];      block.stopIndexPlusOne ¬ ss.piece.stream.GetBlock[block].bytesTransferred};    IF class # none THEN {      chars: LONG POINTER TO PACKED ARRAY [0..0) OF CHARACTER =        LOOPHOLE[block.blockPointer];      FOR i: CARDINAL IN [block.startIndex..block.stopIndexPlusOne) DO        IF TextSource.AsciiTestClass[chars[i], class] THEN {          block.stopIndexPlusOne ¬ i + 1; EXIT};        ENDLOOP};    RETURN[block, position + block.stopIndexPlusOne - block.startIndex]};  ReplaceText: TextSource.ReplaceTextProc = {RETURN[from, 0]};  SetLength: TextSource.SetLengthProc = {RETURN[GetLength[source]]};  Info: PUBLIC PROCEDURE [source: StreamSource.Handle] RETURNS [Piece] = {    ss: SS = SourceToStreamSource[source]; RETURN[ss.piece]};  IsIt: PUBLIC PROCEDURE [source: StreamSource.Handle] RETURNS [BOOLEAN] = {    RETURN[source­ = @streamProcs]};  Set: PUBLIC PROCEDURE [source: StreamSource.Handle, piece: Piece] = {    ss: SS = SourceToStreamSource[source];    ss.piece ¬ piece;    ss.type ¬ unknown};  END. -- of StreamSourceImpl
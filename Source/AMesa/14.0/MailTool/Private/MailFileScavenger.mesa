-- Copyright (C) 1981, 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- MailFileScavenger.mesa - Last edited by-- RXL  :	 5-May-81 12:59:31-- conversion to Pilot by PXK     on  5-May-81 15:26:58, last edited by-- PXK    :	10-Mar-83 14:49:18-- RXJ     :	16-Sep-82 21:30:48DIRECTORY  Ascii USING [CR, ESC, NUL, SP],  Environment USING [bytesPerPage],  Exec USING [    AddCommand, ExecProc, FreeTokenString, GetToken, GetTTY, ReleaseTTY],  Heap USING [systemZone],  Inline USING [DIVMOD, LowHalf],  MFile USING [    Acquire, AcquireTemp, CopyFileHandle, Delete, Error, Handle, Release,    SwapNames],  MStream USING [Copy, Create, Error, GetFile, GetLength, ReadOnly],  Stream USING [    Delete, EndOfStream, GetChar, GetPosition, Handle, PutChar, PutString,    SetPosition],  String USING [    AppendExtensionIfNeeded, AppendStringAndGrow, CopyToNewString, Empty],  Runtime USING [GetBcdTime],  TTY USING [    Handle, GetChar, PutChar, PutCR, PutDate, PutDecimal, PutLine, PutString],  Volume USING [GetAttributes, systemID];MailFileScavenger: MONITOR  IMPORTS    Exec, Inline, Heap, MFile, MStream, Runtime, Stream, String, TTY, Volume =  BEGIN  << Syntax of Messages:   message ::= stamp message-body   stamp ::= fixed-part variable-part   fixed-part ::= sentinel cr counts space flags cr   sentinel ::= <the 7-character ASCII literal *start*>   counts ::= message-length space stamp-length   message-length ::= stamp-number   stamp-length ::= stamp-number   flags ::= deleted-flag examined-flag mark-character   deleted-flag ::= D | U   examined-flag ::= S | U   mark-character ::= <any non-NUL ASCII character>   variable-part ::= <empty> | @ item-list @ optional-cr   item-list ::= <empty> | item-list item   item ::= item-header item-contents   item-header ::= byte-length space item-type space   byte-length ::= stamp-number   item-type ::= stamp-number   optional-cr ::= <empty> | cr   item-contents ::= <sequence of 8-bit bytes>   stamp-number ::= <5-character (leading zeroes) decimal number>   space ::= <the ASCII space character 040C>   cr ::= <the ASCII carriage return character, 015C>   message-body ::= <sequence of 8-bit bytes, not necessarily ASCII>Semantics: Fixed-part:   The message-length is the total number of characters in the stamp and   message-body.  The stamp-length is the total number of characters in the stamp   proper; thus, the number of characters in the message-body is message-length   minus stamp-length.  From the syntax equations it is easy to see that the   stamp-length will be 00024 if the variable-part is <empty>, 00026 or 00027 if   the item-list is <empty>, and at least 00038 otherwise.  The deleted-flag   must be either 'D or 'U (note:  lower case not allowed) and indicates if   the message is logically Deleted or Undeleted.  The examined-flag must be   either 'S or 'U (again, lower case is not permitted) and indicates if the   message has been Seen or is Unseen.  The mark-character can be any non-NUL   ASCII character.   Variable-part:   The byte-length is the total number of characters in the item, including the   item-header of which it is a part.  Thus, this number must always be at least   00012.  The item-type identifies the structure and semantics of the   item-contents. Item types are issued by LaurelSupport and recorded in a   central registry, [Juniper]<Grapevine>ItemRegistry.txt.      3000B is a msgAttribute variable item.   	It consists of 32 't or 'f followed by a CR. Its length is always 45.      3001B is a msgClass variable item.   	It consists of up to 24 pairs of the form (number: name) where number	is in the range 0..23.    >>   msgAttributes: CARDINAL = 3000B;    z: UNCOUNTED ZONE = Heap.systemZone;    GlobalFrame: TYPE = POINTER TO GlobalFrameObject;  GlobalFrameObject: TYPE = RECORD [    mailFile: LONG STRING ¬ NIL,    changesMade: BOOLEAN ¬ FALSE,    inS, outS: Stream.Handle ¬ NIL,    tempFile, inFile: MFile.Handle ¬ NIL];  -- Miscellaneous Constants --  maxPlausibleChars: CARDINAL = 60000;  absoluteLimit: CARDINAL = maxPlausibleChars + 2000;  -- leave room for editing  -- Code --    Initialize: PROCEDURE [tty: TTY.Handle, gf: GlobalFrame]    RETURNS [goAhead: BOOLEAN] =    BEGIN    bpp: CARDINAL = Environment.bytesPerPage;    defaultExtension: STRING = ".mail"L;    safetySlop: CARDINAL = 10 * bpp;    size, available: LONG CARDINAL;    TTY.PutString[tty, "Scavenging mail file: "L];    [] ¬ String.AppendExtensionIfNeeded[@gf.mailFile, defaultExtension, z];    TTY.PutString[tty, gf.mailFile];    gf.inS ¬ MStream.ReadOnly[gf.mailFile, [] ! MStream.Error => {      TTY.PutLine[tty, "...can't be opened!"L]; GOTO quit}];    TTY.PutCR[tty];    size ¬ MStream.GetLength[gf.inS];    available ¬ Volume.GetAttributes[Volume.systemID].freePageCount * bpp;    IF size + safetySlop > available THEN      BEGIN      needed: LONG CARDINAL = size + safetySlop - available;      TTY.PutString[tty, "Sorry, but I will need a minimum of "L];      TTY.PutDecimal[tty, CARDINAL[(needed+bpp)/bpp]];      TTY.PutString[tty, " more free disk pages to scavenge "L];      TTY.PutLine[tty, gf.mailFile];      GOTO quit      END;    gf.inFile ¬ MFile.CopyFileHandle[      MStream.GetFile[gf.inS], [], rename ! MFile.Error => {	TTY.PutString[tty, "Sorry, but I can't replace "L];	TTY.PutLine[tty, gf.mailFile];	GOTO quit}];    gf.tempFile ¬ MFile.AcquireTemp[      type: text, initialLength: MStream.GetLength[gf.inS]];    gf.outS ¬ MStream.Create[gf.tempFile, []];    gf.tempFile ¬ MFile.CopyFileHandle[gf.tempFile, [], rename];    RETURN[TRUE];    EXITS quit => {      IF gf.inS # NIL THEN {gf.inS.Delete[]; gf.inS ¬ NIL}; RETURN[FALSE]};    END;  PutHerald: PROCEDURE [tty: TTY.Handle] =    BEGIN    TTY.PutString[tty, "Mail File Scavenger of "L];    TTY.PutDate[tty, Runtime.GetBcdTime[]];    TTY.PutCR[tty];    TTY.PutCR[tty];    END;  Scavenge: PROCEDURE [tty: TTY.Handle, gf: GlobalFrame] =    BEGIN    inLength: LONG CARDINAL = MStream.GetLength[gf.inS];    stampStart: STRING = "*start*\n"L;    fixedPartLength: CARDINAL = 8 + 2*(5+1) + 3 + 1;    minItemLength: CARDINAL = 2*(5+1);    stampSize, messageSize: CARDINAL;    stampRepair: {none, rebuilt, size, variablePart, bodyLength};    ticksSinceLastMessage: BOOLEAN ¬ FALSE;    messageNumber: CARDINAL ¬ 1;    CheckForInitialStamp: PROCEDURE RETURNS [found: BOOLEAN] =      BEGIN      IF inLength < stampStart.length THEN RETURN[FALSE];      FOR i: CARDINAL IN [0..stampStart.length) DO        IF Stream.GetChar[gf.inS] ~= stampStart[i] THEN EXIT;	REPEAT	  FINISHED => RETURN[TRUE];	ENDLOOP;      Stream.SetPosition[gf.inS, 0];      RETURN[FALSE]      END;    ScanForStartOfStamp: PROCEDURE RETURNS [found, eof: BOOLEAN] =      BEGIN      firstStampChar: CHARACTER = stampStart[0];      charCount: CARDINAL ¬ 0;      found ¬ eof ¬ FALSE;      DO	char: CHARACTER ¬ Stream.GetChar[gf.inS !	  Stream.EndOfStream => {eof ¬ TRUE; EXIT}];	charCount ¬ charCount + 1;	IF char ~= firstStampChar THEN	  BEGIN	  Stream.PutChar[gf.outS, char];	  SELECT charCount FROM	    < maxPlausibleChars => NULL;	    IN [maxPlausibleChars..absoluteLimit) =>	      SELECT char FROM		Ascii.CR, IN [200C..377C] => EXIT;		ENDCASE => NULL;	    ENDCASE => EXIT;	  END	ELSE	  FOR i: CARDINAL IN [1..stampStart.length) DO	    char ¬ Stream.GetChar[gf.inS !	      Stream.EndOfStream => {eof ¬ TRUE; GO TO noMatch}];	    IF char ~= stampStart[i] THEN GO TO noMatch;	    REPEAT	      noMatch =>		BEGIN		FOR j: CARDINAL IN [0..i) DO		  Stream.PutChar[gf.outS, stampStart[j]]; ENDLOOP;		IF eof THEN RETURN;		Stream.PutChar[gf.outS, char];		charCount ¬ charCount + i + 1;		END;	      FINISHED => RETURN[TRUE, FALSE];	    ENDLOOP;	ENDLOOP;      END;    ParseAndOutputStamp: PROCEDURE =      BEGIN      deletedFlag, seenFlag, markChar: CHARACTER;      itemLength, itemType: CARDINAL;      ReadANumber: PROCEDURE RETURNS [ok: BOOLEAN, value: CARDINAL] =	BEGIN	value ¬ 0;	THROUGH [0..5) DO	  char: CHARACTER ¬ Stream.GetChar[gf.inS];	  IF char ~IN ['0..'9] THEN RETURN[FALSE, 0];	  value ¬ value * 10 + (char - '0);	  ENDLOOP;	RETURN[TRUE, value]	END;      TryToReadFixedPart: PROCEDURE RETURNS [BOOLEAN] =	BEGIN	ok: BOOLEAN;	IF Stream.GetPosition[gf.inS] + (fixedPartLength-stampStart.length) >= inLength THEN	  RETURN[FALSE];	[ok, messageSize] ¬ ReadANumber[];	IF ~ok THEN RETURN[FALSE];	IF Stream.GetChar[gf.inS] ~= Ascii.SP THEN RETURN[FALSE];	[ok, stampSize] ¬ ReadANumber[];	IF ~ok THEN RETURN[FALSE];	IF Stream.GetChar[gf.inS] ~= Ascii.SP THEN RETURN[FALSE];	SELECT deletedFlag ¬ Stream.GetChar[gf.inS] FROM	  'D, 'U => NULL;	  ENDCASE => RETURN[FALSE];	SELECT seenFlag ¬ Stream.GetChar[gf.inS] FROM	  'S, 'U => NULL;	  ENDCASE => RETURN[FALSE];	IF (markChar ¬ Stream.GetChar[gf.inS]) = Ascii.NUL THEN RETURN[FALSE];	IF Stream.GetChar[gf.inS] ~= Ascii.CR THEN RETURN[FALSE];	RETURN[TRUE]	END;      OutputFixedPart: PROCEDURE =	BEGIN	gf.outS.PutString[stampStart];	PutNumberInStamp[messageSize]; Stream.PutChar[gf.outS, Ascii.SP];	PutNumberInStamp[stampSize]; Stream.PutChar[gf.outS, Ascii.SP];	Stream.PutChar[gf.outS, deletedFlag];	Stream.PutChar[gf.outS, seenFlag];	Stream.PutChar[gf.outS, markChar];	Stream.PutChar[gf.outS, Ascii.CR];	END;      TryToReadItemHeader: PROCEDURE RETURNS [BOOLEAN] =	BEGIN	ok: BOOLEAN;	IF Stream.GetPosition[gf.inS] + minItemLength >= inLength THEN	  RETURN[FALSE];	[ok, itemLength] ¬ ReadANumber[];	IF ~ok THEN RETURN[FALSE];	IF Stream.GetChar[gf.inS] ~= Ascii.SP THEN RETURN[FALSE];	[ok, itemType] ¬ ReadANumber[];	IF ~ok THEN RETURN[FALSE];	IF Stream.GetChar[gf.inS] ~= Ascii.SP THEN RETURN[FALSE];	RETURN[TRUE]	END;      TryToReadVariablePart: PROCEDURE RETURNS [ok: BOOLEAN] =	BEGIN	probe: LONG CARDINAL ¬ Stream.GetPosition[gf.inS];	DO	  IF Stream.GetChar[gf.inS ! Stream.EndOfStream => EXIT] = '@ THEN {	    IF Stream.GetChar[gf.inS ! Stream.EndOfStream => CONTINUE] ~= Ascii.CR THEN	      Stream.SetPosition[gf.inS, Stream.GetPosition[gf.inS] - 1];	    RETURN[TRUE]};	  Stream.SetPosition[gf.inS, Stream.GetPosition[gf.inS] - 1];	  IF ~TryToReadItemHeader[] OR itemLength < minItemLength THEN EXIT;	  IF probe + itemLength >= inLength THEN EXIT;	  SELECT itemType FROM	    msgAttributes => {	      IF itemLength # 45 THEN EXIT;	      THROUGH [0..32) DO	        SELECT gf.inS.GetChar[] FROM		  't, 'f => NULL;		  ENDCASE => GOTO badEntry;		ENDLOOP;	      IF gf.inS.GetChar[] # Ascii.CR THEN GOTO badEntry};	    ENDCASE;	  gf.inS.SetPosition[probe ¬ probe + itemLength];	  REPEAT badEntry => NULL;	  ENDLOOP;	gf.inS.SetPosition[probe];	RETURN[FALSE]	END;      BEGIN      fixedPartStart: LONG CARDINAL ¬ Stream.GetPosition[gf.inS];      msgStart, variablePartStart: LONG CARDINAL;      newStampSize: CARDINAL;      entireVariablePartIsGood: BOOLEAN;      stampRepair ¬ none;      IF ~TryToReadFixedPart[] THEN {OutputPrototypeStamp[]; RETURN};      variablePartStart ¬ msgStart ¬ Stream.GetPosition[gf.inS];      IF Stream.GetChar[gf.inS! Stream.EndOfStream => GO TO fixedPartOnly] ~= '@ THEN {        Stream.SetPosition[gf.inS, Stream.GetPosition[gf.inS] - 1];	GO TO fixedPartOnly};      entireVariablePartIsGood ¬ TryToReadVariablePart[];      msgStart ¬ Stream.GetPosition[gf.inS];      newStampSize ¬ Inline.LowHalf[        fixedPartLength + msgStart - variablePartStart];      IF ~entireVariablePartIsGood THEN newStampSize ¬ newStampSize + 1;        -- because we are going to write a '@ at the end      IF newStampSize ~= stampSize THEN        {stampSize ¬ newStampSize; stampRepair ¬ size};      OutputFixedPart[];      Stream.SetPosition[gf.inS, variablePartStart];      [] ¬ MStream.Copy[	from: gf.inS, to: gf.outS, bytes: msgStart - variablePartStart];      IF ~entireVariablePartIsGood THEN {	Stream.PutChar[gf.outS, '@]; stampRepair ¬ variablePart};      EXITS	fixedPartOnly =>	  BEGIN	  IF stampSize ~= fixedPartLength THEN	    {stampSize ¬ fixedPartLength; stampRepair ¬ size};	  OutputFixedPart[];	  END;      END;      END;    OutputPrototypeStamp: PROCEDURE =      BEGIN      prototypeFlagsAndMark: STRING = "UUS"L;      gf.outS.PutString[stampStart];      PutNumberInStamp[messageSize ¬ 0]; Stream.PutChar[gf.outS, Ascii.SP];      PutNumberInStamp[stampSize ¬ fixedPartLength]; Stream.PutChar[gf.outS, Ascii.SP];      gf.outS.PutString[prototypeFlagsAndMark];      Stream.PutChar[gf.outS, Ascii.CR];      stampRepair ¬ rebuilt;      END;    PutNumberInStamp: PROCEDURE [n: CARDINAL] =      BEGIN      digits: STRING ¬ "00000"L;      FOR i: CARDINAL DECREASING IN [0..5) UNTIL n = 0 DO	rem: [0..9];	[n, rem] ¬ Inline.DIVMOD[n, 10];	digits[i] ¬ '0 + rem;	ENDLOOP;      gf.outS.PutString[digits];      END;    ReportProgress: PROCEDURE =      BEGIN      IF messageNumber MOD 5 = 0 THEN	BEGIN	IF ticksSinceLastMessage THEN TTY.PutChar[tty, Ascii.SP] ELSE ticksSinceLastMessage ¬ TRUE;	TTY.PutDecimal[tty, messageNumber];	END;     END;    CleanupAfterTicks: PROCEDURE =      BEGIN      IF ticksSinceLastMessage THEN {TTY.PutCR[tty]; ticksSinceLastMessage ¬ FALSE};      END;    Summarize: PROCEDURE =      BEGIN      CleanupAfterTicks[];      TTY.PutDecimal[tty, messageNumber];      TTY.PutString[tty, " message"L];      IF messageNumber ~= 1 THEN TTY.PutChar[tty, 's];      TTY.PutLine[tty, " processed."L];      END;    WriteMessageNumber: PROCEDURE =      BEGIN      TTY.PutString[tty, "Message "L];      TTY.PutDecimal[tty, messageNumber];      TTY.PutString[tty, ": "L];      END;    stampFound: BOOLEAN ¬ CheckForInitialStamp[];    DO      prevStampStart, currentPos: LONG CARDINAL;      charsMoved: CARDINAL;      eof: BOOLEAN;      IF stampFound THEN ParseAndOutputStamp[] ELSE OutputPrototypeStamp[];      prevStampStart ¬ Stream.GetPosition[gf.outS] - stampSize;      [stampFound, eof] ¬ ScanForStartOfStamp[];      currentPos ¬ Stream.GetPosition[gf.outS];      charsMoved ¬ Inline.LowHalf[currentPos - prevStampStart];      IF stampRepair = none AND charsMoved ~= messageSize THEN stampRepair ¬ bodyLength;      IF stampRepair ~= none THEN	BEGIN	gf.changesMade ¬ TRUE;	CleanupAfterTicks[];	WriteMessageNumber[];	SELECT stampRepair FROM	  size => TTY.PutLine[tty, "correcting stamp length."L];	  rebuilt => TTY.PutLine[tty, "reconstructing stamp information."L];	  variablePart => TTY.PutLine[tty, "truncating malformed variable part of stamp."L];	  bodyLength =>	    BEGIN	    difference: CARDINAL =	      IF messageSize > charsMoved THEN messageSize - charsMoved	      ELSE charsMoved - messageSize;	    TTY.PutString[tty, "existing count was "L];	    TTY.PutDecimal[tty, difference];	    TTY.PutString[tty, " byte"L];	    IF difference ~= 1 THEN TTY.PutChar[tty, 's];	    TTY.PutString[tty, " too "L];	    IF messageSize > charsMoved THEN TTY.PutLine[tty, "long."L]	    ELSE TTY.PutLine[tty, "short."L];	    END;	  ENDCASE;	IF charsMoved ~= messageSize THEN	  BEGIN	  Stream.SetPosition[gf.outS, prevStampStart + stampStart.length];	  PutNumberInStamp[charsMoved];	  Stream.SetPosition[gf.outS, currentPos];	  END;	END;      IF eof THEN EXIT;      ReportProgress[];      messageNumber ¬ messageNumber + 1;      ENDLOOP;    Summarize[];    END;  Finalize: PROCEDURE [tty: TTY.Handle, gf: GlobalFrame] =    BEGIN    swapThem: BOOLEAN ¬ FALSE;    gf.inS.Delete[];    gf.outS.Delete[];    gf.inS ¬ gf.outS ¬ NIL;    IF gf.changesMade THEN      BEGIN      char: CHARACTER;      TTY.PutLine[tty, "Scavenging complete into a temporary file."L];      TTY.PutString[tty, "Shall I copy it back to "L];      TTY.PutString[tty, gf.mailFile];      TTY.PutChar[tty, '?];      char ¬ TTY.GetChar[tty];      SELECT char FROM	Ascii.CR, 'Y, 'y, Ascii.ESC => {	  TTY.PutLine[tty, " Yes"L]; swapThem ¬ TRUE};	ENDCASE => TTY.PutLine[tty, " No"L];      END    ELSE {      TTY.PutString[tty, "I couldn't find anything wrong with "L];      TTY.PutLine[tty, gf.mailFile]};    IF swapThem THEN {      tocFile: MFile.Handle ¬ NIL;      MFile.SwapNames[gf.inFile, gf.tempFile];      String.AppendStringAndGrow[to: @gf.mailFile, from: "-TOC"L, z: z];      tocFile ¬ MFile.Acquire[gf.mailFile, delete, [] ! MFile.Error => CONTINUE];      IF tocFile # NIL THEN MFile.Delete[tocFile]};    MFile.Release[gf.inFile];    MFile.Release[gf.tempFile];    TTY.PutCR[tty];    END;    ScavengeMailFile: Exec.ExecProc = {    mf, s: LONG STRING;    tty: TTY.Handle = Exec.GetTTY[h];    gf: GlobalFrameObject;    PutHerald[tty];    DO      gf ¬ [];      [mf, s] ¬ Exec.GetToken[h];      [] ¬ Exec.FreeTokenString[s];      IF String.Empty[mf] THEN {[] ¬ Exec.FreeTokenString[mf]; EXIT};      gf.mailFile ¬ String.CopyToNewString[s: mf, z: z, longer: 12];      [] ¬ Exec.FreeTokenString[mf];      IF Initialize[tty, @gf] THEN {Scavenge[tty, @gf]; Finalize[tty, @gf]};      z.FREE[@gf.mailFile];      ENDLOOP;    TTY.PutCR[tty];    TTY.PutLine[tty, "Done."L];    Exec.ReleaseTTY[tty]};    -- Main program  Init: PROC = { -- get string out of global frame    Exec.AddCommand["MailFileScavenger.~"L, ScavengeMailFile]};  Init[];    END.
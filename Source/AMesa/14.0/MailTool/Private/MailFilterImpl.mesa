-- Copyright (C) 1985  by Xerox Corporation. All rights reserved. -- File: MailFilterImpl.mesa - last edit:-- AlHall	21-Mar-85  3:33:14DIRECTORY  Exec USING [MatchPattern],  Heap USING [systemZone],  MailFile,  MailFilterUI USING [Filter, FreeFilters, GetFilters],  MailReadOps USING [CreateData],  Runtime USING [IsBound],  String USING [AppendString, EquivalentStrings, ExpandString, FreeString, MakeString];MailFilterImpl: MONITOR  IMPORTS Exec, Heap, MailFile, MailFilterUI, MailReadOps, Runtime,  String  EXPORTS MailFile =    BEGIN-- TYPEs:FieldType: TYPE = MailFile.FieldType;Filter: TYPE = MailFilterUI.Filter;Filters: TYPE = Filter;HeaderData: TYPE = MailFile.HeaderData;HeaderDataField: TYPE = MailFile.HeaderDataField;HeaderDataRecord: TYPE = MailFile.HeaderDataRecord;MarkData: TYPE = CHARACTER;UpdateList: TYPE = LONG DESCRIPTOR FOR  ARRAY CARDINAL OF UpdateRecord;UpdateRecord: TYPE = RECORD [  type: UpdateType,  mailFile: MailFile.Handle,  message: MailFile.MsgNumber,  markData: MarkData];UpdateSeq: TYPE = RECORD [  SEQUENCE COMPUTED CARDINAL OF UpdateRecord];UpdateType: TYPE = {delete, mark};-- Variables, etc.:nullMarkData: MarkData = LAST[MarkData];updateList: UpdateList ¬ NIL;updateListBlockSize: CARDINAL = 25;myZone: UNCOUNTED ZONE = Heap.systemZone;-- PUBLIC ENTRY PROCEDUREs:WaitForUpdates: PUBLIC ENTRY PROCEDURE =  BEGIN ENABLE UNWIND => NULL;  -- CODE: Rename to ApplyUpdates.  -- ASSUME: MailFile.Update is done after this PROC is called.    BEGIN ENABLE UNWIND => FreeUpdateList[];  FOR i: CARDINAL IN [0..LENGTH[updateList]) DO    ENABLE ABORTED, MailFile.Error => LOOP;        SELECT updateList[i].type FROM      delete =>        MailFile.Delete[updateList[i].mailFile, updateList[i].message];      mark =>        MailFile.SetMsgFlag[updateList[i].mailFile,	  updateList[i].message, updateList[i].markData];      ENDCASE;    ENDLOOP;  END;  -- ENABLE UNWIND  FreeUpdateList[];  END;-- PUBLIC PROCEDUREs:AddToHeaderData: PUBLIC PROCEDURE [data: HeaderData,  fieldType: FieldType, fieldBody: LONG STRING] =  -- Takes care of multiple "To:" fields, etc.; also saves  --   the field bodies in a minimum amount of space while  --   avoiding unnecessary string allocations in the normal  --   case (assuming the PROC CreateHeaderData defaults  --   maxlengths according to the normal case).  BEGIN  stringPtr: LONG POINTER TO LONG STRING ¬    SELECT fieldType FROM      from => @data.from,      recipients => @data.recipients,      subject => @data.subject,      ENDCASE => ERROR;  newLength: CARDINAL ¬ stringPtr­.length + fieldBody.length;    IF newLength > stringPtr­.maxlength THEN    String.ExpandString[stringPtr, newLength - stringPtr­.maxlength, myZone];  String.AppendString[stringPtr­, fieldBody]  END;CreateHeaderData: PUBLIC PROCEDURE RETURNS [data: HeaderData] =  BEGIN  data ¬ myZone.NEW[HeaderDataRecord];  data.from ¬ String.MakeString[myZone, 100];  data.recipients ¬ String.MakeString[myZone, 1000];  data.subject ¬ String.MakeString[myZone, 200];  END;FilterMessage: PUBLIC PROCEDURE [mailFile: MailFile.Handle,  message: MailFile.MsgNumber, headerData: HeaderData] =  BEGIN  filters: Filters ¬ NIL;  Cleanup: PROCEDURE =    BEGIN    IF filters # NIL THEN      MailFilterUI.FreeFilters[filters];    END;    BEGIN ENABLE UNWIND => Cleanup[];  IF NOT Runtime.IsBound[LOOPHOLE[MailFilterUI.GetFilters]] THEN RETURN;  filters ¬ MailFilterUI.GetFilters[];  FOR filter: Filter ¬ filters, filter.next UNTIL filter = NIL DO    IF PassesMask[headerData.from, filter.from] AND      PassesMask[headerData.recipients, filter.to] AND      PassesMask[headerData.subject, filter.subject] THEN      BEGIN      IF filter.delete THEN	UpdateMailFile[delete, mailFile, message];      IF filter.mark THEN	UpdateMailFile[mark, mailFile, message, filter.char];      EXIT;  -- Stop after first match.      END;    ENDLOOP;  END;  -- ENABLE UNWIND  Cleanup[];  END;FreeHeaderData: PUBLIC PROCEDURE [data: HeaderData] =  BEGIN  IF data = NIL THEN RETURN;  IF data.from # NIL THEN    String.FreeString[myZone, data.from];  IF data.recipients # NIL THEN    String.FreeString[myZone, data.recipients];  IF data.subject # NIL THEN    String.FreeString[myZone, data.subject];  END;GetFieldType: PUBLIC PROCEDURE [fieldName: LONG STRING]  RETURNS [fieldType: FieldType] =  BEGIN  RETURN [    SELECT TRUE FROM      String.EquivalentStrings[fieldName, "cc"L] => recipients,      String.EquivalentStrings[fieldName, "From"L] => from,      String.EquivalentStrings[fieldName, "Subject"L] => subject,      String.EquivalentStrings[fieldName, "To"L] => recipients,      ENDCASE => other];  END;ResetHeaderData: PUBLIC PROCEDURE [data: HeaderData] =  BEGIN  data.from.length ¬ 0;  data.recipients.length ¬ 0;  data.subject.length ¬ 0;  END;-- PRIVATE ENTRY/INTERNAL PROCEDUREs:AppendToUpdateList: INTERNAL PROCEDURE [update: UpdateRecord] =  BEGIN  -- ASSUME: updateList allocated in blocks of updateListBlockSize.  blockSize: CARDINAL = updateListBlockSize;  tempUpdateList: UpdateList ¬ NIL;    IF updateList = NIL THEN    updateList.BASE ¬ LOOPHOLE[myZone.NEW[UpdateSeq[blockSize]]];  IF (LENGTH[updateList] MOD blockSize) = 0 AND    LENGTH[updateList] # 0 THEN    BEGIN  -- Extend updateList by blockSize.    tempUpdateList.BASE ¬ LOOPHOLE[myZone.NEW[      UpdateSeq[LENGTH[updateList] + blockSize]]];    tempUpdateList.LENGTH ¬ LENGTH[updateList];    FOR i: CARDINAL IN [0..LENGTH[updateList]) DO      tempUpdateList[i] ¬ updateList[i];      ENDLOOP;    myZone.FREE[@updateList.BASE];    updateList ¬ tempUpdateList;    END;  updateList.LENGTH ¬ updateList.LENGTH + 1;  updateList[updateList.LENGTH - 1] ¬ update;  END;FreeUpdateList: INTERNAL PROCEDURE =  { myZone.FREE[@updateList.BASE]; updateList ¬ NIL; };UpdateMailFile: ENTRY PROCEDURE [type: UpdateType,  mailFile: MailFile.Handle, message: MailFile.MsgNumber,  markData: MarkData ¬ nullMarkData] =  BEGIN ENABLE UNWIND => NULL;  IF NOT Runtime.IsBound[LOOPHOLE[MailReadOps.CreateData]] THEN    RETURN;  -- Hardy not active.  AppendToUpdateList[update: [type, mailFile, message, markData]];  END;-- PRIVATE PROCEDUREs:  PassesMask: PROCEDURE [string, mask: LONG STRING]  RETURNS [matches: BOOLEAN] =  BEGIN  IF mask = NIL THEN RETURN [TRUE];  -- (Not masking on this field).  RETURN [Exec.MatchPattern[string, mask]];  END;<<PutError: PROCEDURE [s: LONG STRING] =  BEGIN  UserTerminal.BlinkDisplay[];  Put.CR[NIL];  Put.Text[NIL, "MailFilters: "L];  Put.Text[NIL, s];  END;>>-- Mainline Code:-- (None).END.
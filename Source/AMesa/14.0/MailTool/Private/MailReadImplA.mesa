-- File: MailReadImplA.mesa - last edit by:-- AlHall,		 9-Sep-84 18:16:39-- Poskanzer.PA	 9-Apr-84 15:50:19-- Wobber,		17-Nov-83 12:22:51-- Hamilton.ES,	 8-Nov-83 21:28:11-- Arndt,		21-Jul-83 15:48:08-- RXJ     ,		 4-Oct-82 14:43:56 -- Sikorski,		11-May-82 16:21:36-- MXS     ,		 8-Jun-81 14:15:31 -- SXW   ,		29-Apr-81 10:45:54-- PXK    ,		22-Sep-83 19:13:35-- NS     ,		21-Jul-86 15:19:47  -- BGY			22-Apr-86 17:54:29  << This module has the initialization and "cold" routines in it.>>DIRECTORY  AsciiSink USING [Create],  CmFile USING [    Close, Error, FindSection, Handle, NextValue, TableError, UserDotCmOpen],  Event USING [    DoneWithProcess, Handle, primaryCredentials, spare1, StartingProcess,    tajoDefaults],  EventTypes USING [domain, organization, primaryCredentials, registry, spare1],  Exec USING [    AddCommand, ExecProc, FreeTokenString, GetToken, Handle, OutputProc, PutChar,    RemoveCommand ],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType, CommandItem,    DisplayItem, Enumerated, EnumeratedDescriptor, EnumeratedHandle,    EnumeratedItem, EnumeratedNotifyProcType, FindItem, FreeHintsProcType,    ItemDescriptor, ItemHandle, LabelItem, MenuProcType, ModifyEditable, newLine,    nextLine, nextPlace, nullEnumeratedValue, Options, ProcType, sameLine,    SetTagPlaces, StringItem, ToggleVisibility],  Inline USING [BITXOR],  MailEvent USING [DataObject],  MailFile USING [    Attributes, Enumerate, Enumerator, File, GetFileAttributes, Handle,    MakeReadOnly, nullMessage],  MailReadOps USING [    AddExtensionIfNeeded, CheckBusy, CommandProc, Commands, CreateData, data, Data,    DeleteData, DoneWithDataCopy, FirstTOCMessage, FormatType, FreeMailFile,    GetCurrent, GetMailFile, HaveCurrent, MailHints, NewCurrent, Orientation, Post,    Sides, TOCPosition, TOCSinkCreate, TOCSourceCreate, TOCStringProc, Transport],  MailSend USING [ReplyToFlag],  MailTransfer USING [CreateRead, DestroyRead, Handle, MailboxState, NewUser],  MailUtil,  MFile USING [    AddNotifyProc, EnumerateDirectory, EnumerateProc, Error, GetProperties, Handle,    NotifyProc, ReadOnly, Release, RemoveNotifyProc, SameFile],  NSName USING [maxFullNameLength],  Process USING [    Detach, priorityBackground, SecondsToTicks, SetPriority, SetTimeout],  Profile USING [GetUser, Qualification],  Runtime USING [StartFault],  StartOps,  StreamSource USING [Create],  String USING [    AppendChar, AppendDecimal, AppendExtensionIfNeeded, AppendString,    CopyToNewString, Empty, Equivalent, Replace, StringBoundsFault],  StringLookUp USING [noMatch, TableDesc],  Supervisor USING [    AddDependency, AgentProcedure, CreateSubsystem, DeleteSubsystem,    NotifyDirectSubsystems, nullSubsystem, RemoveDependency, SubsystemHandle],  TextSource USING [Handle],  TextSW USING [Adjust, Create, Destroy, Options, SetSource],  Time USING [Unpack, Unpacked],  Token USING [    Boolean, Decimal, FreeTokenString, Handle, Item, MaybeQuoted, NonWhiteSpace,    Quote],  Tool USING [    AddThisSW, Create, Destroy, MakeFormSW, MakeMsgSW, MakeSWsProc, RegisterSWType,    SWType],  ToolDriver USING [Address, NoteSWs, RemoveSWs],  ToolFont USING [Create, Destroy],  ToolWindow USING [    Activate, Box, CreateSubwindow, Deactivate, GetState, Handle, MakeSize,    SetName, SetTinyName, State, TransitionProcType],  UserInput USING [CreateStringInOut],  Window USING [BitmapPlace, Box, GetBox, Handle, ValidateTree],  WindowFont USING [Error, FontHeight, Handle];MailReadImplA: MONITOR  IMPORTS    AsciiSink, StreamSource, CmFile, Event, Exec, FormSW, Inline,    MailFile, MailTransfer, MailReadOps, MailUtil, MFile, Process, Profile,    String, Runtime,  Supervisor, TextSW, Time, Token, Tool,     ToolDriver, ToolFont, ToolWindow,     StartOps, UserInput, Window, WindowFont  EXPORTS MailReadOps =  BEGIN  defaultMailFile: PUBLIC LONG STRING ¬ NIL;  mailFileExtension: PUBLIC LONG STRING ¬ NIL;  mailFilePattern: PUBLIC LONG STRING ¬ NIL;  showEnvelopeString: PUBLIC LONG STRING ¬ NIL;  toolName: PUBLIC LONG STRING ¬ NIL;  mailHintsCondition: CONDITION;  maxNameLength: CARDINAL = NSName.maxFullNameLength;  simpleTextSW: Tool.SWType = Tool.RegisterSWType[adjust: TextSW.Adjust];  toolWindow: Window.Handle ¬ NIL;  -- used when data is deallocated  Commands: TYPE = MailReadOps.Commands;  Options: TYPE = LONG POINTER TO OptionsObject;  OptionsObject: TYPE = MACHINE DEPENDENT RECORD [    autoDisplay(0): BOOLEAN ¬ FALSE,    lFont(1): LONG STRING ¬ NIL,    fileOutput(3): BOOLEAN ¬ FALSE,    pFont(4): LONG STRING ¬ NIL,    mailFileName(6): LONG STRING ¬ NIL,    orientation(8): MailReadOps.Orientation ¬ portrait,    flushRemote(9): BOOLEAN ¬ TRUE,    separatePages(10): BOOLEAN ¬ TRUE,    ipFile(11): LONG STRING ¬ NIL,    displayOnNewMail(13): BOOLEAN ¬ FALSE,    sides(14): MailReadOps.Sides ¬ singleSided,    ipPrinter(15): LONG STRING ¬ NIL,    showEnvelope(17): BOOLEAN ¬ FALSE,    allAttachments(18): BOOLEAN ¬ FALSE,    transport(19): MailReadOps.Transport ¬ NS];  bodyOptions: TextSW.Options = [    access: read, menu: TRUE, split: TRUE, wrap: TRUE, scrollbar: TRUE,    flushTop: TRUE, flushBottom: FALSE];  tocOptions: TextSW.Options = [    access: read, menu: TRUE, split: TRUE, wrap: FALSE, scrollbar: TRUE,    flushTop: TRUE, flushBottom: TRUE];  options: Options ¬ NIL;  initialBox: Window.Box = [[x: 0, y: 30], [w: 548, h: 320]];  zone: UNCOUNTED ZONE ¬ NIL;  -- Option window property sheet stuff  MakeOptions: FormSW.ProcType =    BEGIN    name: STRING = [maxNameLength];    data: MailReadOps.Data = MailReadOps.data;    mailFile: MailFile.Handle;    hisBox: Window.Box = sw.GetBox[];    IF data.optionW # NIL THEN {OptionsAbort[data.optionW, item, index]; RETURN};    mailFile ¬ MailReadOps.GetCurrent[data];    options ¬ data.z.NEW[OptionsObject];    IF mailFile # NIL THEN [] ¬ MailFile.GetFileAttributes[mailFile, name];    options­ ¬ [      flushRemote: data.flushRemote,      mailFileName: String.CopyToNewString[name, data.z],      autoDisplay: data.autoDisplay, separatePages: data.separatePages,      orientation: data.orientation, fileOutput: data.fileOutput,      lFont: String.CopyToNewString[data.fontNames[landscape], data.z],      pFont: String.CopyToNewString[data.fontNames[portrait], data.z],      ipFile: String.CopyToNewString[data.hardcopyOutputFiles, data.z],      ipPrinter: String.CopyToNewString[data.printerNames, data.z],      sides:      SELECT data.sides FROM        0 => printerDefault,        1 => singleSided,        ENDCASE => doubleSided, displayOnNewMail: data.displayOnNewMail,      showEnvelope: data.showEnvelope, transport: data.transport,      allAttachments: data.allAttachments];    data.optionW ¬ Tool.Create[      name: "Mail Options"L, makeSWsProc: MakeOptionWindow, initialState: active,      initialBox: [      place: sw.BitmapPlace[[10, hisBox.dims.h]],      dims: [hisBox.dims.w - 20, 180]]];    MailReadOps.FreeMailFile[data, mailFile];    END;  MakeOptionWindow: Tool.MakeSWsProc = {    [] ¬ Tool.MakeFormSW[window: window, formProc: MakeOptionItems, zone: zone]};  formatDesc: FormSW.Enumerated ¬ [    "Interpress"L, MailReadOps.FormatType[interpress82]];  orientationDesc: ARRAY [0..2) OF FormSW.Enumerated ¬ [    ["Portrait"L, MailReadOps.Orientation[portrait]], [    "Landscape"L, MailReadOps.Orientation[landscape]]];  sidesDesc: ARRAY [0..3) OF FormSW.Enumerated ¬ [    ["PrinterDefault"L, MailReadOps.Sides[printerDefault]], [    "SingleSided"L, MailReadOps.Sides[singleSided]], [    "DoubleSided"L, MailReadOps.Sides[doubleSided]]];  OptionIndex: TYPE = {    apply, abort, flush, autoDisplay, newMailDisplay,     showEnvelope, -- allAttachments, -- mailfile,    hardCopyHeader, multiPage, fileOutput, sides, orientation, lFont, pFont,    iPrinter, iFile};  nOptionItems: CARDINAL = LOOPHOLE[LAST[OptionIndex], CARDINAL] + 1;  MakeOptionItems: FormSW.ClientItemsProcType =    BEGIN OPEN FormSW;    tabsDesc: ARRAY [0..3) OF CARDINAL ¬ [0, 25, 35];    pItems: ItemDescriptor ¬ AllocateItemDescriptor[nOptionItems, zone];    formItems: LONG POINTER TO ARRAY OptionIndex OF ItemHandle = LOOPHOLE[BASE[      pItems]];    formItems­ ¬ [      apply: CommandItem[      tag: "Apply"L, proc: OptionsApply, place: newLine, z: zone],      abort: CommandItem[      tag: "Abort"L, proc: OptionsAbort, place: [-10, sameLine], z: zone],      flush: BooleanItem[      tag: "FlushRemote"L, switch: @options.flushRemote, place: [-10, sameLine],      z: zone],      autoDisplay: BooleanItem[      tag: "AutoDisplay"L, switch: @options.autoDisplay, place: [-10, sameLine],      z: zone],      newMailDisplay: BooleanItem[      tag: "DisplayOnNewMail"L, switch: @options.displayOnNewMail,      place: [-10, sameLine], z: zone],      showEnvelope: BooleanItem[      tag: showEnvelopeString, switch: @options.showEnvelope, place: nextPlace,      z: zone],      mailfile: StringItem[      tag: "MailFile"L, inHeap: TRUE, string: @options.mailFileName,      place: newLine, menuProc: MailHintsProc, z: zone],      hardCopyHeader: LabelItem[      readOnly: TRUE, tag: "--- Hardcopy Options ---"L,      place: [ --1-- 7 * 25, nextLine], z: zone],      multiPage: BooleanItem[      tag: "One per Page"L, switch: @options.separatePages, place: newLine,      z: zone],      fileOutput: BooleanItem[      tag: "Output To File"L, switch: @options.fileOutput, place: [-15, sameLine],      z: zone],      sides: EnumeratedItem[      tag: "Sides"L, feedback: one, value: @options.sides, place: newLine,      choices: DESCRIPTOR[sidesDesc], z: zone],      orientation: EnumeratedItem[      tag: "Orientation"L, feedback: one, value: @options.orientation,      place: [ --2-- 7 * 35, sameLine], choices: DESCRIPTOR[orientationDesc],      z: zone],      lFont: StringItem[      tag: "Landscape Font"L, inHeap: TRUE, string: @options.lFont, place: newLine,      z: zone],      pFont: StringItem[      tag: "Portrait Font"L, inHeap: TRUE, string: @options.pFont,      place: [ --2-- 7 * 35, sameLine], z: zone],      iPrinter: StringItem[      tag: "Printer"L, inHeap: TRUE, string: @options.ipPrinter, place: newLine,      z: zone],      iFile: StringItem[      tag: "File"L, inHeap: TRUE, string: @options.ipFile, place: newLine,      z: zone]];    --FormSW.SetTagPlaces[pItems, DESCRIPTOR[tabsDesc], FALSE];    RETURN[pItems, TRUE]    END;  OptionsAbort: FormSW.ProcType =    BEGIN    data: MailReadOps.Data = MailReadOps.data;    IF options # NIL THEN      BEGIN      Tool.Destroy[data.optionW];      data.z.FREE[@options.lFont];      data.z.FREE[@options.pFont];      data.z.FREE[@options.mailFileName];      data.z.FREE[@options.ipFile];      data.z.FREE[@options.ipPrinter];      data.z.FREE[@options];      data.optionW ¬ NIL;      END;    END;  OptionsApply: FormSW.ProcType =    BEGIN    data: MailReadOps.Data = MailReadOps.data;    IF MailReadOps.CheckBusy[data] THEN RETURN;    data.flushRemote ¬ options.flushRemote;    data.autoDisplay ¬ options.autoDisplay;    data.displayOnNewMail ¬ options.displayOnNewMail;    data.separatePages ¬ options.separatePages;    data.sides ¬      SELECT options.sides FROM        printerDefault => 0,        singleSided => 1,        doubleSided => 2,        ENDCASE => 1;    data.orientation ¬ options.orientation;    data.fileOutput ¬ options.fileOutput;    data.showEnvelope ¬ options.showEnvelope;    data.allAttachments ¬ options.allAttachments;    IF ~String.Equivalent[data.fontNames[landscape], options.lFont] THEN      String.Replace[@data.fontNames[landscape], options.lFont, data.z];    IF ~String.Equivalent[data.fontNames[portrait], options.pFont] THEN      String.Replace[@data.fontNames[portrait], options.pFont, data.z];    IF ~String.Equivalent[data.printerNames, options.ipPrinter] THEN      String.Replace[@data.printerNames, options.ipPrinter, data.z];    IF ~String.Empty[options.ipFile] THEN      MailReadOps.AddExtensionIfNeeded[        @options.ipFile, "interpress"L, sw, OptionIndex.iFile.ORD];    IF ~String.Equivalent[data.hardcopyOutputFiles, options.ipFile] THEN      String.Replace[@data.hardcopyOutputFiles, options.ipFile, data.z];    IF FormSW.FindItem[sw, OptionIndex.mailfile.ORD].flags.modified THEN {      IF String.Empty[options.mailFileName] THEN        FormSW.ModifyEditable[sw, OptionIndex.mailfile.ORD, 0, 0, defaultMailFile]      ELSE        MailReadOps.AddExtensionIfNeeded[          @options.mailFileName, mailFileExtension, sw, OptionIndex.mailfile.ORD];      ChangeMailFile[data, options.mailFileName, TRUE]};    OptionsAbort[sw, item, index];    END;  ChangeMailFile: PROC [    data: MailReadOps.Data, name: LONG STRING, createIt: BOOLEAN,    oldFileChoice: CARDINAL ¬ FormSW.nullEnumeratedValue] = {    current: MailFile.Handle ¬ MailReadOps.GetCurrent[data];    currentFileChoice: CARDINAL = data.fileChoice;    new: MailFile.Handle = MailReadOps.GetMailFile[data, name, createIt];    IF new = NIL AND oldFileChoice # FormSW.nullEnumeratedValue THEN {      data.fileChoice ¬ oldFileChoice;      FormSW.DisplayItem[data.formSW, Commands.file.ORD]}    ELSE      IF new # NIL AND new # current THEN {        tocSource: TextSource.Handle = data.tocSource;  -- HaveNewMail clobbers        bodySource: TextSource.Handle = data.bodySource;        tocPosition: LONG CARDINAL = HaveNewMailFile[data, new];        TextSW.SetSource[data.tocSW, data.tocSource, tocPosition, TRUE];        TextSW.SetSource[data.bodySW, data.bodySource, 0, TRUE];        [] ¬ tocSource.actOn[tocSource, destroy];        [] ¬ bodySource.actOn[bodySource, destroy];        MailReadOps.NewCurrent[data, new];        IF currentFileChoice # data.fileChoice THEN          FormSW.DisplayItem[data.formSW, Commands.file.ORD];	data.inTocBuffer ¬ MailFile.nullMessage;        Window.ValidateTree[data.toolW]};    MailReadOps.FreeMailFile[data, current];    MailReadOps.FreeMailFile[data, new]};  --Transition and setup stuff  newUser: Supervisor.SubsystemHandle ¬ Supervisor.nullSubsystem;  NewUser: Supervisor.AgentProcedure = {    data: MailReadOps.Data = instanceData;    IF data = NIL THEN RETURN;    SELECT event FROM      EventTypes.primaryCredentials => MailTransfer.NewUser[data.rHandle];      EventTypes.registry =>        IF data.transport = GV THEN MailTransfer.NewUser[data.rHandle];      EventTypes.domain, EventTypes.organization =>        IF data.transport = NS THEN MailTransfer.NewUser[data.rHandle];      ENDCASE};  ProcessUserCm: PROCEDURE [window: Window.Handle, data: MailReadOps.Data] =    BEGIN    cmSections: ARRAY [0..2) OF LONG STRING = ["HardCopy"L, "MailTool"L];    -- order matters since Hardy defaults for hardcopy need to override    tocFont, msgFont: MFile.Handle ¬ NIL;    sameFont: BOOLEAN ¬ FALSE;    Option: TYPE = MACHINE DEPENDENT{      flushRemote(0), mailFile, newMailOnActivate, tocLines, bodyFont, tocFont,      autoDisplay, newMailDisplay, needReplyTo, fileOutput, separatePages,      outputFile, sides, interpress, landscapeFont, portraitFont, orientation,      printedBy, showEnvelope, expandPvtDLs, forwardForm, newForm, answerForm,      pioneer, noMatch(StringLookUp.noMatch)};    DefinedOption: TYPE = Option [flushRemote..pioneer];    NotHardCopy: TYPE = Option [flushRemote..sides];    optionTable: ARRAY DefinedOption OF LONG STRING ¬ [      flushRemote: "FlushRemote"L, mailFile: "MailFile"L,      newMailOnActivate: "NewMailOnActivate"L, tocLines: "TOCLines"L,      autoDisplay: "AutoDisplay"L, bodyFont: "MessageFont"L, tocFont: "TOCFont"L,      needReplyTo: "NeedReplyTo"L, newMailDisplay: "DisplayOnNewMail"L,      fileOutput: "OutputToFile"L, separatePages: "SeparatePages"L,      outputFile: "OutputFile"L, sides: "Sides"L, interpress: "Interpress"L,      landscapeFont: "LandscapeFont"L, printedBy: "PrintedBy"L,      portraitFont: "PortraitFont"L, orientation: "Orientation"L,      showEnvelope: showEnvelopeString, expandPvtDLs: "ExpandPvtDLs"L,      forwardForm: "ForwardForm"L, newForm: "NewForm"L, answerForm: "AnswerForm"L,      pioneer: "Pioneer"L];    userCm: CmFile.Handle;    TryForFontFile: PROC RETURNS [file: MFile.Handle ¬ NIL] = {      name: LONG STRING = Token.Item[userCm];      file ¬ MFile.ReadOnly[name, [] ! MFile.Error => CONTINUE];      [] ¬ Token.FreeTokenString[name]};    Update: PROCEDURE [s: LONG POINTER TO LONG STRING, quoted: BOOLEAN] = {      value: LONG STRING =        IF quoted THEN Token.MaybeQuoted[        userCm, NIL, Token.NonWhiteSpace, Token.Quote] ELSE Token.Item[userCm];      String.Replace[s, value, data.z];      [] ¬ Token.FreeTokenString[value]};    CheckType: PROCEDURE [h: CmFile.Handle, table: StringLookUp.TableDesc]      RETURNS [index: CARDINAL] = CmFile.NextValue;    MyNextValue: PROCEDURE [      h: CmFile.Handle,      table: LONG DESCRIPTOR FOR ARRAY DefinedOption OF LONG STRING]      RETURNS [index: Option] = LOOPHOLE[CheckType];    GetMailHints[data, NIL];    userCm ¬ CmFile.UserDotCmOpen[ ! CmFile.Error => GOTO NoUserDotCm];    --Set up data.fontNames, data.format, data.hardcopyUserName,    --and both entries in data.printerNames from the "Hardcopy"    --section of the User.cm.  Initializes data.fontNames    --with the default fonts.    FOR section: CARDINAL IN [0..2) DO      IF CmFile.FindSection[userCm, cmSections[section]] THEN        DO          option: DefinedOption = MyNextValue[            userCm, DESCRIPTOR[optionTable] ! CmFile.TableError => RESUME ];          IF option IN NotHardCopy AND section = 0 THEN LOOP;          SELECT option FROM            noMatch => EXIT;            flushRemote => data.flushRemote ¬ Token.Boolean[userCm, FALSE];            mailFile => Update[@data.mailFileName, FALSE];            needReplyTo => {              t: LONG STRING = Token.Item[userCm];              SELECT TRUE FROM                String.Equivalent[t, "DontSend"L] => data.needReplyTo ¬ stop;                String.Equivalent[t, "SendAnyway"L] => data.needReplyTo ¬ send;                String.Equivalent[t, "AddToForm"L] => data.needReplyTo ¬ add;                ENDCASE;              [] ¬ Token.FreeTokenString[t]};            newMailOnActivate => NULL;            <<          data.newMailOnActivate ¬ Token.Boolean[userCm, FALSE];>>            tocLines => data.tocLines ¬ Token.Decimal[userCm, FALSE];            autoDisplay => data.autoDisplay ¬ Token.Boolean[userCm, FALSE];            newMailDisplay => data.displayOnNewMail ¬ Token.Boolean[userCm, FALSE];            showEnvelope => data.showEnvelope ¬ Token.Boolean[userCm, FALSE];            expandPvtDLs => data.expandPvtDLs ¬ Token.Boolean[userCm, FALSE];            forwardForm => Update[@data.forwardForm, TRUE];            newForm => Update[@data.newForm, TRUE];            answerForm => Update[@data.answerForm, TRUE];            pioneer => data.pioneer ¬ Token.Boolean[userCm, FALSE];            tocFont => tocFont ¬ TryForFontFile[];            bodyFont => msgFont ¬ TryForFontFile[];            fileOutput => data.fileOutput ¬ Token.Boolean[userCm, FALSE];            separatePages => data.separatePages ¬ Token.Boolean[userCm, FALSE];            outputFile =>              BEGIN              t: LONG STRING = Token.Item[userCm];              IF ~String.Empty[t] THEN {                FOR i: NATURAL DECREASING IN [1..t.length) DO                  IF t[i] = '. THEN {t.length ¬ i; EXIT}; ENDLOOP;                data.hardcopyOutputFiles ¬ String.CopyToNewString[t, data.z, 15];                };              [] ¬ Token.FreeTokenString[t];              END;            sides =>              BEGIN              t: LONG STRING = Token.Item[userCm];              SELECT TRUE FROM                String.Equivalent[t, "PrinterDefault"L] => data.sides ¬ 0;                String.Equivalent[t, "SingleSided"L] => data.sides ¬ 1;                String.Equivalent[t, "DoubleSided"L] => data.sides ¬ 2;                ENDCASE;              [] ¬ Token.FreeTokenString[t];              END;            noMatch => EXIT;            interpress => Update[@data.printerNames, TRUE];            landscapeFont => Update[@data.fontNames[landscape], FALSE];            portraitFont => Update[@data.fontNames[portrait], FALSE];            orientation =>              BEGIN              value: LONG STRING = Token.Item[userCm];              SELECT TRUE FROM                String.Equivalent[value, "Landscape"L] =>                  data.orientation ¬ landscape;                String.Equivalent[value, "Portrait"L] =>                  data.orientation ¬ portrait;                ENDCASE;              [] ¬ Token.FreeTokenString[value];              END;            printedBy =>              BEGIN              value: LONG STRING = Token.MaybeQuoted[                userCm, NIL, Token.NonWhiteSpace, Token.Quote];              String.Replace[@data.hardcopyUserName, value, data.z];              [] ¬ Token.FreeTokenString[value];              END;            ENDCASE;          ENDLOOP;      ENDLOOP;    IF String.Empty[data.hardcopyUserName] THEN      String.Replace[@data.hardcopyUserName, "$"L, data.z];    IF String.Empty[data.fontNames[portrait]] THEN      data.fontNames[portrait] ¬ String.CopyToNewString["Gacha8"L, data.z];    IF String.Empty[data.fontNames[landscape]] THEN      data.fontNames[landscape] ¬ String.CopyToNewString["Gacha6"L, data.z];    IF tocFont # NIL AND msgFont # NIL AND MFile.SameFile[tocFont, msgFont] THEN {      MFile.Release[tocFont]; tocFont ¬ NIL; sameFont ¬ TRUE};    IF msgFont # NIL THEN      data.msgFont ¬ ToolFont.Create[        msgFont ! WindowFont.Error => {MFile.Release[msgFont]; CONTINUE}];    IF sameFont THEN data.tocFont ¬ data.msgFont    ELSE      IF tocFont # NIL THEN        data.tocFont ¬ ToolFont.Create[          tocFont ! WindowFont.Error => {MFile.Release[tocFont]; CONTINUE}];    [] ¬ CmFile.Close[userCm];    EXITS NoUserDotCm => NULL;    END;  ThisIsNewOne: ENTRY PROCEDURE [data: MailReadOps.Data, name: LONG STRING]    RETURNS [newOne: BOOLEAN] = {    ENABLE UNWIND => NULL;    IF ~data.mailHintsReady THEN RETURN[TRUE];    IF data.mailHintsBusy THEN RETURN[TRUE];    FOR i: CARDINAL IN [0..data.mailHints.length) DO      IF String.Equivalent[name, data.mailHints[i]] THEN RETURN[FALSE]; ENDLOOP;    RETURN[TRUE]};  GetMailHints: ENTRY PROCEDURE [data: MailReadOps.Data, h: Event.Handle] = {    ENABLE UNWIND => NULL;    maxHints: NATURAL = 50;    count: NATURAL ¬ 0;    temp: LONG POINTER TO MailReadOps.MailHints ¬ data.z.NEW[      MailReadOps .MailHints[maxHints] ¬ [names:]];    PutThemIn: MFile.EnumerateProc = {      temp[count] ¬ String.CopyToNewString[name, data.z];      count ¬ count + 1;      RETURN[count >= maxHints]};    WHILE data.mailHintsBusy DO WAIT mailHintsCondition ENDLOOP;    data.mailHintsReady ¬ FALSE;    IF h # NIL THEN Process.SetPriority[Process.priorityBackground];    IF data.formSW # NIL THEN      FormSW.ToggleVisibility[data.formSW, Commands.file.ORD];    FreeMailHints[data, FALSE];    MFile.EnumerateDirectory[      mailFilePattern, PutThemIn, filesOnly !      MFile.Error => {count ¬ 0; CONTINUE}];    IF count = 0 THEN {      data.mailHints ¬ data.z.NEW[MailReadOps .MailHints[1]];      data.mailHints[0] ¬ String.CopyToNewString["no files"L, data.z]}    ELSE {      data.mailHints ¬ data.z.NEW[MailReadOps .MailHints[count]];      FOR i: NATURAL IN [0..count) DO data.mailHints[i] ¬ temp[i] ENDLOOP};    data.z.FREE[@temp];    data.mailHintsReady ¬ TRUE;    IF data.formSW # NIL THEN {      kludge: LONG POINTER;      enumerated: FormSW.EnumeratedHandle;      enumerated ¬ NARROW[        FormSW.FindItem[data.formSW, Commands.file.ORD], FormSW.EnumeratedHandle];      kludge ¬ enumerated.choices.BASE;      data.z.FREE[@kludge];      enumerated.choices ¬ MakeFileChoices[data];      FormSW.ToggleVisibility[data.formSW, Commands.file.ORD]};    BROADCAST mailHintsCondition;    IF h # NIL THEN Event.DoneWithProcess[h]};  FreeMailHints: PROCEDURE [data: MailReadOps.Data, freeChoice: BOOLEAN ¬ TRUE] =    BEGIN    IF data.mailHints # NIL THEN {      FOR i: CARDINAL IN [0..data.mailHints.length) DO        data.z.FREE[@data.mailHints[i]] ENDLOOP;      data.z.FREE[@data.mailHints]};    IF lastChoice # NIL AND freeChoice THEN {      data.z.FREE[@lastChoice.BASE];      lastChoice ¬ NIL};    END;  lastChoice: FormSW.EnumeratedDescriptor ¬ NIL;  MakeFileChoices: PROCEDURE [data: MailReadOps.Data]    RETURNS [choices: FormSW.EnumeratedDescriptor] =    BEGIN    Kludge: TYPE = RECORD [      kludge: SEQUENCE COMPUTED CARDINAL OF FormSW.Enumerated];    kludge: LONG POINTER TO Kludge = data.z.NEW[Kludge [data.mailHints.length]];    choices ¬ DESCRIPTOR[kludge, data.mailHints.length];    FOR i: NATURAL IN [0..data.mailHints.length) DO      choices[i] ¬ [data.mailHints[i], Hash[data.mailHints[i]]]; ENDLOOP;    lastChoice ¬ choices;    END;  ChangeFile: FormSW.EnumeratedNotifyProcType =    BEGIN    WhereDidItGo: ERROR = CODE;    enumerated: FormSW.EnumeratedHandle = NARROW[item, FormSW.EnumeratedHandle];    FOR i: NATURAL IN [0..enumerated.choices.LENGTH) DO      IF MailReadOps.data.fileChoice = enumerated.choices[i].value THEN {        ChangeMailFile[          MailReadOps.data, enumerated.choices[i].string, FALSE, oldValue];        EXIT};      REPEAT FINISHED => ERROR WhereDidItGo;      ENDLOOP;    END;  Hash: PROC [s: LONG STRING] RETURNS [c: CARDINAL] = {    one, two: CARDINAL ¬ 0;    c ¬ 0;    FOR i: NATURAL IN [0..s.length) DO      one ¬ one * 31 + (s[i] - 0C); two ¬ two + (s[i] - 0C); ENDLOOP;    c ¬ Inline.BITXOR[one, two]};  NewMailFileExists: MFile.NotifyProc = {    IF ThisIsNewOne[clientInstanceData, name] THEN      Process.Detach[        FORK GetMailHints[        clientInstanceData, Event.StartingProcess[        "Enumeration for mail file hints"L]]]};  ClientTransition: ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      old = inactive => {        data: MailReadOps.Data = MailReadOps.CreateData[];        data.transport ¬ NS;        newUser ¬ Supervisor.CreateSubsystem[NewUser, data];        String.Replace[@data.mailFileName, defaultMailFile, data.z];        ProcessUserCm[window, data]};      new = inactive => {        dataCopy: MailReadOps.Data = MailReadOps.data;        OptionsAbort[NIL, NIL, 0];        MailReadOps.DeleteData[];        ToolDriver.RemoveSWs[tool: toolName];        MFile.RemoveNotifyProc[          NewMailFileExists, [mailFilePattern, text, readOnly], dataCopy];        Supervisor.RemoveDependency[          client: newUser, implementor: Event.primaryCredentials];        Supervisor.RemoveDependency[          client: newUser, implementor: Event.tajoDefaults];        Supervisor.DeleteSubsystem[newUser];        newUser ¬ Supervisor.nullSubsystem;        MailTransfer.DestroyRead[dataCopy.rHandle];        TextSW.Destroy[dataCopy.tocSW];        TextSW.Destroy[dataCopy.bodySW];        [] ¬ dataCopy.tocSource.actOn[dataCopy.tocSource, destroy];        [] ¬ dataCopy.bodySource.actOn[dataCopy.bodySource, destroy];        IF dataCopy.msgFont = dataCopy.tocFont THEN dataCopy.tocFont ¬ NIL;        IF dataCopy.tocFont # NIL THEN ToolFont.Destroy[dataCopy.tocFont];        IF dataCopy.msgFont # NIL THEN ToolFont.Destroy[dataCopy.msgFont];        FreeMailHints[dataCopy];        dataCopy.z.FREE[@dataCopy.tocBuffer];        dataCopy.z.FREE[@dataCopy.printerNames];        dataCopy.z.FREE[@dataCopy.hardcopyOutputFiles];        dataCopy.z.FREE[@dataCopy.mailFileName];        dataCopy.z.FREE[@dataCopy.forwardForm];        dataCopy.z.FREE[@dataCopy.newForm];        dataCopy.z.FREE[@dataCopy.answerForm];        FOR o: MailReadOps.Orientation IN [portrait..landscape] DO          dataCopy.z.FREE[@dataCopy.fontNames[o]]; ENDLOOP;        dataCopy.z.FREE[@dataCopy.hardcopyUserName];	IF MailUtil.unloading THEN MailReadOps.DoneWithDataCopy[dataCopy]        ELSE Process.Detach[FORK MailReadOps.DoneWithDataCopy[dataCopy]]};      new = tiny => {        WaitNotBusy: ENTRY PROCEDURE = {          cond: CONDITION;          Process.SetTimeout[@cond, Process.SecondsToTicks[1]];          WHILE MailReadOps.data.busy DO WAIT cond ENDLOOP};        mf: MailFile.Handle = MailReadOps.GetCurrent[MailReadOps.data];        WaitNotBusy[];        IF mf # NIL THEN {          MailFile.MakeReadOnly[mf];          MailReadOps.FreeMailFile[MailReadOps.data, mf]}};      ENDCASE;    END;  ReportChanges: PROCEDURE [    data: MailReadOps.Data, state: MailTransfer.MailboxState,    errorString: STRING] =    BEGIN    s: STRING = [maxNameLength + 45];    String.AppendString[s, toolName];    SELECT state FROM      empty => {        time: Time.Unpacked = Time.Unpack[];        String.AppendString[s, ": Mailbox empty at "L];        IF time.hour < 10 THEN String.AppendChar[s, '0];        String.AppendDecimal[s, time.hour];        String.AppendChar[s, ':];        IF time.minute < 10 THEN String.AppendChar[s, '0];        String.AppendDecimal[s, time.minute];        ToolWindow.SetName[data.toolW, s];        IF ~data.emptyMailBoxes THEN          ToolWindow.SetTinyName[data.toolW, toolName, NIL]};      mail => {        AppendUser: PROCEDURE [name, password: LONG STRING] = {          String.AppendString[s, name]};        String.AppendString[s, ":          »»»»»» New mail for "L];        Profile.GetUser[          AppendUser, IF data.transport = GV THEN registry ELSE clearinghouse];        String.AppendString[s, " ««««««"L];        ToolWindow.SetName[data.toolW, s];        ToolWindow.SetTinyName[data.toolW, toolName, "New Mail"L]};      userAuthenticated => {        String.AppendString[s, ": Name Authenticated"L];        ToolWindow.SetName[data.toolW, s];        ToolWindow.SetTinyName[data.toolW, toolName, NIL]};      serversAllDown => {        String.AppendString[s, ": No inbox server responding"L];        ToolWindow.SetName[data.toolW, s];        ToolWindow.SetTinyName[data.toolW, toolName, "No Server"L]};      noLogin => {        String.AppendString[s, ": "L];        String.AppendString[          s, errorString ! String.StringBoundsFault => RESUME [NIL]];        ToolWindow.SetName[data.toolW, s];        ToolWindow.SetTinyName[data.toolW, toolName, "No Login"L]};      bug => {        MailReadOps.Post[s: "Internal Error"L, eol: TRUE, error: TRUE];        ToolWindow.SetTinyName[data.toolW, toolName, "Error"L]};      ENDCASE => {        MailReadOps.Post[          s: IF errorString # NIL THEN errorString ELSE "Unknown Error"L,          eol: TRUE, error: TRUE];        ToolWindow.SetTinyName[data.toolW, toolName, "Error"L]};    data.emptyMailBoxes ¬ (state = empty);    IF data.newMailPending # (state = mail) THEN      BEGIN      data.newMailPending ¬ (state = mail);      IF ~(data.doingRetrieve AND data.newMailPending) THEN ReportMailEvent[data];      END;    END;  ReportMailEvent: PROCEDURE [data: MailReadOps.Data] =    BEGIN    mailEventData: MailEvent.DataObject ¬ [      newMailPending: data.newMailPending,      transport: SELECT data.transport FROM GV => gv, ENDCASE --NS-- => ns,      userData: data];    Supervisor.NotifyDirectSubsystems[      event: EventTypes.spare1, which: clients, subsystem: Event.spare1,      eventData: @mailEventData];    END;  HardyExec: Exec.ExecProc =    BEGIN    ENABLE UNWIND => NULL;    data: MailReadOps.Data = MailReadOps.data;    token, switches: LONG STRING ¬ NIL;    getNewMail: BOOLEAN ¬ FALSE;    newState: ToolWindow.State ¬ active;    [token, switches] ¬ h.GetToken[];    IF switches # NIL THEN      FOR i: CARDINAL IN [0..switches.length) DO        SELECT switches[i] FROM          'n, 'N => getNewMail ¬ TRUE;          't, 'T => newState ¬ tiny;          'a, 'A => newState ¬ active;          'i, 'I => newState ¬ inactive;          ENDCASE => {            h.OutputProc[]["Unknown switch = "L]; h.PutChar[switches[i]]; EXIT};        ENDLOOP;    switches ¬ Exec.FreeTokenString[switches];    SELECT newState FROM      active => {        ToolWindow.Activate[toolWindow];        IF token # NIL THEN {          newName: LONG STRING ¬ String.CopyToNewString[token, zone, 8];          ChangeFiles: ENTRY PROC = {            ENABLE UNWIND => zone.FREE[@newName];            ChangeMailFile[data, newName, FALSE]};          [] ¬ String.AppendExtensionIfNeeded[@newName, mailFileExtension, zone];          ChangeFiles[];          zone.FREE[@newName]}};      tiny => {        IF ToolWindow.GetState[toolWindow] = inactive THEN          ToolWindow.Activate[toolWindow];        -- get around bug in ToolWindow.MakeSize        ToolWindow.MakeSize[toolWindow, tiny]};      inactive => [] ¬ ToolWindow.Deactivate[toolWindow];      ENDCASE;    token ¬ Exec.FreeTokenString[token];    IF newState = active AND getNewMail THEN      MailReadOps.CommandProc[        sw: MailReadOps.data.formSW, index: Commands.newMail.ORD];    END;  HardyUnload: Exec.ExecProc = {    name: LONG STRING ¬ NIL;    MailUtil.unloading ¬ TRUE;    h.RemoveCommand["SendTool.~"L];    h.RemoveCommand["MailTool.~"L];        Tool.Destroy[toolWindow];    MailUtil.Unload[];    };      HardyHelp: Exec.ExecProc = {    data: MailReadOps.Data = MailReadOps.data;    string: STRING = [300];    String.AppendString[string, "This command activates "L];    String.AppendString[string, toolName];    String.AppendString[string, ", a mail reading and composing tool. "L];    h.OutputProc[][string]};  Init: PROCEDURE = {     BEGIN ENABLE Runtime.StartFault => CONTINUE;    START StartOps.MailUtilImpl;    END; --of ENABLE    zone ¬ MailUtil.zone;    defaultMailFile ¬ String.CopyToNewString["Active.nsMail"L, MailUtil.zone];    mailFileExtension ¬ String.CopyToNewString["nsMail"L, MailUtil.zone];    mailFilePattern ¬ String.CopyToNewString["*.nsMail"L, MailUtil.zone];    showEnvelopeString ¬ String.CopyToNewString[""L, MailUtil.zone];    toolName ¬ String.CopyToNewString["MailTool"L, MailUtil.zone];    BEGIN    toolWindow ¬ Tool.Create[      makeSWsProc: MakeSWs, clientTransition: ClientTransition, name: toolName,      initialBox: initialBox, cmSection: "MailTool",      tinyName1: toolName];    Exec.AddCommand["MailTool.~"L, HardyExec, HardyHelp , HardyUnload];    END;    };  MakeForm: FormSW.ClientItemsProcType =    BEGIN OPEN FormSW;    tabStops: ARRAY [0..6) OF CARDINAL ¬ [0, 12, 24, 36, 48, 60];    cmdItems: LONG POINTER TO ARRAY Commands OF ItemHandle;    items ¬ AllocateItemDescriptor[Commands.LAST.ORD + 1, zone];    cmdItems ¬ LOOPHOLE[BASE[items]];    cmdItems­ ¬ [      display: CommandItem[      tag: "Display"L, proc: MailReadOps.CommandProc, place: newLine, z: zone],      delete: CommandItem[tag: "Delete"L, proc: MailReadOps.CommandProc, z: zone],      answer: CommandItem[tag: "Answer"L, proc: MailReadOps.CommandProc, z: zone],      append: CommandItem[tag: "Append"L, proc: MailReadOps.CommandProc, z: zone],      file: EnumeratedItem[      tag: "File", proc: ChangeFile, value: @MailReadOps.data.fileChoice,      copyChoices: FALSE, feedback: one,      choices: MakeFileChoices[MailReadOps.data], z: zone],      hardcopy: CommandItem[      tag: "Hardcopy"L, proc: MailReadOps.CommandProc, place: newLine, z: zone],      undelete: CommandItem[      tag: "Undelete"L, proc: MailReadOps.CommandProc, z: zone],      forward: CommandItem[      tag: "Forward"L, proc: MailReadOps.CommandProc, z: zone],      options: CommandItem[tag: "Options"L, proc: MakeOptions, z: zone],      sort: CommandItem[tag: "Sort"L, proc: MailReadOps.CommandProc, z: zone],      classes: CommandItem[      tag: "Classes"L, proc: MailReadOps.CommandProc,      invisible: ~MailReadOps.data.pioneer, z: zone],      newMail: CommandItem[      tag: "New Mail"L, proc: MailReadOps.CommandProc, place: newLine, z: zone],      expunge: CommandItem[      tag: "Expunge"L, proc: MailReadOps.CommandProc, z: zone],      newForm: CommandItem[      tag: "New Form"L, proc: MailReadOps.CommandProc, z: zone],      move: CommandItem[tag: "Move"L, proc: MailReadOps.CommandProc, z: zone],      moveTo: StringItem[      tag: "To"L, inHeap: TRUE, string: @MailReadOps.data.moveToFileName,      place: [-5, sameLine], menuProc: MailHintsProc, z: zone]];    SetTagPlaces[items: items, tabStops: DESCRIPTOR[tabStops], bitTabs: FALSE];    RETURN[items: items, freeDesc: TRUE]    END;  MailHintsProc: ENTRY FormSW.MenuProcType = {    WHILE ~MailReadOps.data.mailHintsReady DO WAIT mailHintsCondition ENDLOOP;    MailReadOps.data.mailHintsBusy ¬ TRUE;    RETURN[      hints: DESCRIPTOR[      @MailReadOps.data.mailHints[0], MailReadOps.data.mailHints.length],        freeHintsProc: HintsNoLongerBusy, replace: TRUE]};  HintsNoLongerBusy: ENTRY FormSW.FreeHintsProcType = {    MailReadOps.data.mailHintsBusy ¬ FALSE; BROADCAST mailHintsCondition};  HaveNewMailFile: PROCEDURE [data: MailReadOps.Data, mailFile: MailFile.Handle]    RETURNS [tocPosition: LONG CARDINAL] =    BEGIN    newName: LONG STRING = [80];    mask: MailFile.Attributes ¬ ALL[FALSE];    filter: MailFile.Attributes ¬ ALL[FALSE];    noneFound: BOOLEAN ¬ TRUE;    NotExamined: MailFile.Enumerator =      BEGIN      tocPosition ¬ MailReadOps.TOCPosition[mailFile, msg];      noneFound ¬ FALSE;      RETURN[TRUE];      END;    mask[noAttributes] ¬ TRUE;    mask[examined] ¬ TRUE;    filter[noAttributes] ¬ FALSE;    filter[examined] ¬ FALSE;    MailFile.Enumerate[mailFile, 0, LAST[INTEGER], NotExamined, mask, filter];    IF noneFound THEN      tocPosition ¬ MailReadOps.TOCPosition[        mailFile, MailReadOps.FirstTOCMessage[mailFile, data.tocLines]];    data.tocSource ¬ MailReadOps.TOCSourceCreate[data, mailFile];    data.nilToc ¬ FALSE;    data.currentDisplayed ¬ MailFile.nullMessage;    data.bodySource ¬ StreamSource.Create[[NIL, 0, 0]];    [] ¬ MFile.GetProperties[MailFile.File[mailFile], newName];    data.fileChoice ¬ Hash[newName];    END;  MakeSWs: Tool.MakeSWsProc =    BEGIN  -- at some point make sure file is editable    data: MailReadOps.Data = MailReadOps.data;    addresses: ARRAY [0..4) OF ToolDriver.Address;    tocPosition: LONG CARDINAL ¬ 0;    mailFile: MailFile.Handle;    data.toolW ¬ window;  -- mail notify guys rely on this assignment!    data.msgSW ¬ Tool.MakeMsgSW[window: window];    mailFile ¬ MailReadOps.GetMailFile[data, data.mailFileName, TRUE];    IF mailFile # NIL THEN {      tocPosition ¬ HaveNewMailFile[data, mailFile];      MailReadOps.NewCurrent[data, mailFile];      MailReadOps.FreeMailFile[data, mailFile]}    ELSE {      data.nilToc ¬ TRUE;      data.tocSource ¬ MailReadOps.TOCSourceCreate[data, NIL];      data.bodySource ¬ StreamSource.Create[[NIL, 0, 0]]};    data.rHandle ¬ MailTransfer.CreateRead[      stateProc: ReportChanges, clientData: data];    data.tocSW ¬ ToolWindow.CreateSubwindow[parent: window];    TextSW.Create[      sw: data.tocSW, source: data.tocSource, options: tocOptions,      position: tocPosition, sink: MailReadOps.TOCSinkCreate[data, data.tocFont]];    Tool.AddThisSW[      window: window, sw: data.tocSW, swType: simpleTextSW,      h: data.tocLines * WindowFont.FontHeight[data.tocFont]];    [] ¬ UserInput.CreateStringInOut[      window: data.tocSW, in: MailReadOps.TOCStringProc, out: NIL];    data.formSW ¬ Tool.MakeFormSW[window: window, formProc: MakeForm, zone: zone];    data.bodySW ¬ ToolWindow.CreateSubwindow[parent: window];    TextSW.Create[      sw: data.bodySW, source: data.bodySource, options: bodyOptions,      sink: IF data.msgFont = NIL THEN NIL ELSE AsciiSink.Create[data.msgFont]];    Tool.AddThisSW[window: window, sw: data.bodySW, swType: simpleTextSW];    IF data.newMailOnActivate AND MailReadOps.HaveCurrent[data] THEN      MailReadOps.CommandProc[sw: data.formSW, index: Commands.newMail.ORD];    Supervisor.AddDependency[      client: newUser, implementor: Event.primaryCredentials];    Supervisor.AddDependency[client: newUser, implementor: Event.tajoDefaults];    MFile.AddNotifyProc[      NewMailFileExists, [mailFilePattern, text, readOnly], data];    addresses ¬ [      [name: "MsgSW"L, sw: data.msgSW], [name: "TOCSW"L, sw: data.tocSW], [      name: "FormSW"L, sw: data.formSW], [name: "BodySW"L, sw: data.bodySW]];    ToolDriver.NoteSWs[tool: toolName, subwindows: DESCRIPTOR[addresses]];    END;  -- Mainline code  Init[];  -- this gets strings out of global frame  END.  - NSG 14-Jan-85 10:49:49  changed bullets to Eurpean quotes for character set 0 
-- File: MailTransfersB.mesa - last edit by:-- AH,	30-Sep-85 10:39:17 -- TW,	15-Dec-83 17:13:50-- NS,	17-Dec-85 11:30:34 -- BGY,	21-Apr-86 16:20:10 -- Copyright (C) 1985 by Xerox Corporation. All rights reserved.DIRECTORY  Auth,  Courier,  Environment,  Format,  Inbasket,  MailAttributes,  MailTransport,  MemoryStream,  NSAssignedTypes,  NSDataStream,  NSName,  NSString,  Profile,  Stream,  String,  System,  Time,  TransferDefs;MailTransfersB: MONITOR LOCKS h.LOCK USING h: TransferDefs.Handle  IMPORTS    Auth, Courier, Format, Inbasket, MailAttributes, MailTransport,    MemoryStream, NSDataStream, NSName, NSString, Profile,     Stream, String, TransferDefs  EXPORTS TransferDefs = PUBLIC  BEGIN OPEN TransferDefs;  mailNote: LONG STRING ¬ zone.NEW[StringBody[maxMailNoteLength]];    FormatHeader: PROCEDURE [    sH: Stream.Handle, attributes: MailAttributes.Attributes,    envelope: MailAttributes.Envelope, h: Handle, flushRemote: BOOLEAN]    RETURNS [attachment: BOOLEAN] =    BEGIN    attachmentID: AttachmentIDRecord ¬ [envelope.transport.messageID, h.name];    attachmentIDString: NSString.String ¬ StringFromAttachmentID[      zone, @attachmentID];    Put: PROC [s: LONG STRING] = INLINE {Stream.PutString[sH, s]};    PutC: PROC [c: CHARACTER] = INLINE {Stream.PutChar[sH, c]};    PutNote: PROC [nS: NSString.String] =      BEGIN      mailNote.length ¬ 0;      NSString.AppendToMesaString[        mailNote, nS !        NSString.StringBoundsFault, String.StringBoundsFault => CONTINUE];      Put[mailNote];      END;    PutNS: PROC [nS: NSString.String] =      BEGIN      sBuf: STRING = [150];      NSString.AppendToMesaString[        sBuf, nS !        NSString.StringBoundsFault, String.StringBoundsFault => CONTINUE];      Put[sBuf];      END;    AppendTime: Format.StringProc = {Put[s]};    AppendString: PROC [s: LONG STRING, nS: NSString.String] =      BEGIN IF nS.length = 0 THEN RETURN; Put[s]; PutNS[nS]; END;    AppendName: PROC [s: LONG STRING, name: NSName.Name] =      BEGIN      array: ARRAY [0..1) OF NSName.NameRecord;      array ¬ [name­];      AppendNameList[s, DESCRIPTOR[array]];      END;    AppendNameList: PROC [s: LONG STRING, nL: MailTransport.NameList] =      BEGIN      FOR i: CARDINAL IN [0..LENGTH[nL]) DO        Put[IF i = 0 THEN s ELSE ", "L];        PutNS[nL[i].local];        AppendString[":"L, nL[i].domain];        AppendString[":"L, nL[i].org];        ENDLOOP;      END;    Cleanup: PROCEDURE =      BEGIN      NSString.FreeString[zone, attachmentIDString];      END;    BEGIN    ENABLE UNWIND => Cleanup[];    attachment ¬ FALSE;    mailNote.length ¬ 0;    -- always show sender?? ...    MailAttributes.UnqualifyAttributeNames[      attributes, envelope.transport.originator];    AppendName["Sender: "L, envelope.transport.originator];    Put["\nDate: "L];    Format.Date[AppendTime, envelope.transport.postmark.time, mailDate];    AppendString["\nSubject: "L, attributes.subject];    AppendNameList["\nFrom: "L, attributes.from];    AppendNameList["\nTo: "L, attributes.to];    AppendNameList["\ncc: "L, attributes.copies];    AppendString["\nIn-Reply-to: "L, attributes.inReplyTo];    AppendNameList["\nReply-to: "L, attributes.answerTo];    BEGIN OPEN NSAssignedTypes;    IF attributes.bodyType # tEmpty AND attributes.bodyType # tText THEN      BEGIN      attachment ¬ TRUE;      Put["\nAttachment: "L];      SELECT attributes.bodyType FROM        tUnspecified => Put["Unspecified"L];        tDirectory => Put["Folder"L];        IN [firstStarType..lastStarType] => Put["Star Document"L];        IN [firstWS860Type..lastWS860Type] => Put["860 Document"L];        ENDCASE => Put["Unknown"L];      IF ~flushRemote THEN {        Put[" (not flushed)"L];	attachment ¬ FALSE;	};      AppendString["\nAttachment-ID: "L, attachmentIDString];      END;    END;  -- OPEN    -- encapsulated envelope??    IF envelope.transport.problem # NIL THEN      BEGIN OPEN MailTransport;      undels: Undeliverables ¬ envelope.transport.problem.undeliverables;      FOR reason: UndeliveredNameType IN UndeliveredNameType DO        FOR i: CARDINAL IN [0..LENGTH[undels]) DO          IF reason # undels[i].reason THEN LOOP;          AppendName["\nUndeliverable-to: "L, @undels[i].name];          Put["  (reason = "L];          SELECT reason FROM            noSuchRecipient => Put["noSuchRecipient"L];            illegalName => Put["badName"L];            refused => Put["refused"L];            noAccessToDL => Put["noAccessToDL"L];            timeout => Put["timeout"L];            ENDCASE => Put["unknown"L];          PutC[')];          ENDLOOP;        ENDLOOP;      END;    Put["\n\n"L];  -- End of RFC #822 header.    IF attributes.bodyType = NSAssignedTypes.tText AND attributes.note.length # 0      THEN      BEGIN      Put["Note: "L];      PutNote[attributes.note];      Put["\n\n"L];  -- End of secondary header.      END;    END;  -- ENABLE UNWIND    Cleanup[];    END;  -- entry procs  MyAppendString: PROCEDURE [from: LONG STRING, to: LONG POINTER TO LONG STRING] =    BEGIN    IF from = NIL THEN RETURN;    String.AppendStringAndGrow[z: zone, from: from, to: to, extra: 100];    END;  ChangeServer: PROCEDURE [h:Handle,    session: Inbasket.Session, pleaseDelete: DeleteSeqPtr,    noteOthersWereReceived: BOOLEAN, firstMsg: Inbasket.Index ¬ 1]    RETURNS [nDeleted: CARDINAL ¬ 0] =    BEGIN    i: CARDINAL ¬ 0;    range: Inbasket.IndexRange;    WHILE i < pleaseDelete.length DO      range ¬ [firstMsg + i, NULL];      FOR j: CARDINAL IN [i + 1..pleaseDelete.length) DO        IF pleaseDelete[j] # pleaseDelete[j - 1] THEN EXIT; i ¬ j; ENDLOOP;      range.last ¬ firstMsg + i;      IF pleaseDelete[i] THEN {       Inbasket.Delete[session, range];       nDeleted ¬ nDeleted + 1;       }      ELSE        IF noteOthersWereReceived THEN          Inbasket.ChangeStatus[session, range, received];      i ¬ i + 1;      ENDLOOP;          END;  CreateMSSession: PROCEDURE [h: Handle, i: ServerType]    RETURNS [session: Inbasket.Session] =    BEGIN    IF userLoggedOff OR h.identity = NIL THEN RETURN[nullSession];    session ¬ Inbasket.Logon[      h.identity, h.name, Inbasket.nullCacheVerifier, TRUE, h.servers[      i].location].session;    h.servers[i].lastIndex ¬ Inbasket.MailCheck[session].state.lastIndex;    IF h.servers[i].lastIndex = 0 THEN h.servers[i].lastRead ¬ 0    ELSE      BEGIN      first: Inbasket.Index ¬ Inbasket.Locate[session, new];      h.servers[i].lastRead ¬        IF first = 0 THEN h.servers[i].lastIndex ELSE first - 1;      END;    END;  FindAttachmentIDsOnServer: PROCEDURE [    h: Handle, session: Inbasket.Session, i: ServerType,    attachmentIDs: LONG DESCRIPTOR FOR ARRAY OF AttachmentID]    RETURNS [pleaseDelete: DeleteSeqPtr ¬ NIL] =    BEGIN    ListProc: Inbasket.ListProc =      BEGIN      FOR i: CARDINAL IN [0..LENGTH[attachmentIDs]) DO        IF attachmentIDs[i] = NIL THEN LOOP;        IF attachmentIDs[i].messageID = props.env.transport.messageID THEN          BEGIN pleaseDelete[msg - firstMsg] ¬ TRUE; EXIT; END;        ENDLOOP;      END;    BEGIN    ENABLE UNWIND => IF pleaseDelete # NIL THEN zone.FREE[@pleaseDelete];    pleaseDelete ¬ zone.NEW[DeleteSeq [h.servers[i].lastRead]];    FOR i: CARDINAL IN [0..pleaseDelete.length) DO      pleaseDelete[i] ¬ FALSE; ENDLOOP;    Inbasket.List[session, [1, h.servers[i].lastRead], [envelope: TRUE], ListProc];    END;  -- ENABLE UNWIND    END;  KillSession: PROC [session: Inbasket.Session] = {    IF session # nullSession THEN      [] ¬ Inbasket.Logoff[        session ! MailTransport.Error, Courier.Error => CONTINUE]};  MaybeZapMbxLocation: PROC [h: Handle, i: ServerType] =    -- ASSUME: Only called when a failure occurs.    -- Keeps calls to MailTransport.GetLocation down to    --   a maximum of one per hour (the advantage to calling    --   MailTransport.GetLocation when a failure occurs is that    --   the user doesn't have to deactivate the tool when his    --   mailbox moves).    BEGIN<<    currentTime: System.GreenwichMeanTime ¬ Time.Current[];    IF userLoggedOff OR i > lastType THEN RETURN;    -- No sense bothering the Clearinghouse in this case.    IF currentTime - h.servers[i].lastRecordedFailure > oneHour THEN      BEGIN      h.servers[i].lastRecordedFailure ¬ currentTime;      ZapMbxLocation[h, i];      END;>>          END;  ResetUserInfo: PROCEDURE [h: Handle] =    BEGIN    ENABLE NSName.Error =>  CONTINUE;     identity: Auth.IdentityHandle ¬ NIL;    i: ServerType;    GetID: PROCEDURE [id: Auth.IdentityHandle] = {identity ¬ id};    GetNameAndPassword: PROCEDURE [name, password: LONG STRING] =      BEGIN      h.name ¬ NSName.NameFromString[zone, STR[name]];      userLoggedOff ¬ (String.Length[password] = 0);      IF userLoggedOff THEN {        IF h.identity # NIL THEN Auth.FreeIdentity[@h.identity, zone];        h.identity ¬ NIL;	}      ELSE h.identity ¬ Auth.CopyIdentity[identity, zone];      END;    IF h.name # NIL THEN      BEGIN      NSName.FreeName[zone, h.name];      h.name ¬ NIL;      END;    IF h.identity # NIL THEN {     Auth.FreeIdentity[@h.identity, zone];     h.identity ¬ NIL};        h.validated ¬ FALSE;    lastType ¬ secondary;    FOR i IN ServerType DO ZapMbxLocation[h, i]; ENDLOOP;    Profile.GetID[strong, GetID];    Profile.GetUser[GetNameAndPassword, clearinghouse];    IF userLoggedOff THEN      FOR i IN ServerType DO h.servers[i].state ¬ badPwd ENDLOOP;    END;  ZapMbxLocation: PROC [h: Handle, i: ServerType] =    BEGIN    h.servers[i].state ¬ unknown;    IF h.servers[i].location = NIL THEN RETURN;    MailTransport.FreeLocation[h.servers[i].location];    h.servers[i].location ¬ NIL;    END;  NewSession: ENTRY PROC [h: Handle, i: ServerType]    RETURNS [session: Inbasket.Session ¬ nullSession] =    BEGIN    ENABLE {      Courier.Error =>        BEGIN h.servers[i].state ¬ down; MaybeZapMbxLocation[h, i]; CONTINUE; END;      MailTransport.Error =>        BEGIN        h.servers[i].state ¬          WITH e: error SELECT FROM            access =>              IF e.problem = mailboxNameIndeterminate THEN noCH ELSE accessProblem,            authentication =>              SELECT e.problem FROM                -- badNameInIdentity => badName,                --   NOTE:  A badNameInIdentity is a credentials inconsistency, not                --     a bad user name.  Clearinghouse updates have not fully propagated.                badPwdInIdentity => badPwd,                ENDCASE => authProblem,            location =>              SELECT e.problem FROM                noCHAvailable => noCH,                noSuchName => badName,                ENDCASE => noMailboxes,            service => IF e.problem = cannotAuthenticate THEN noCH ELSE down,            ENDCASE => down;	IF i = secondary AND h.servers[i].state = noMailboxes THEN	  lastType ¬ primary;	IF h.servers[i].state = badPwd THEN {	  IF h.identity # NIL THEN {	  Auth.FreeIdentity[@h.identity, zone]; 	  h.identity ¬ NIL};	  userLoggedOff ¬TRUE};        MaybeZapMbxLocation[h, i];        CONTINUE;        END;      UNWIND => NULL;      };    IF h.settingCredentials AND i = primary THEN {      IF h.setThemAgain THEN h.setThemAgain ¬ FALSE;      ResetUserInfo[h];      };    IF h.servers[i].state = badName OR h.servers[i].state = badPwd THEN RETURN;    IF h.servers[i].state = unknown THEN GetMailboxInfo[h, i];    IF h.servers[i].state = noMailboxes THEN {      IF i = secondary THEN lastType ¬ primary;      RETURN};    session ¬ CreateMSSession[h, i];    h.validated ¬ TRUE;    h.servers[i].state ¬      IF h.servers[i].lastRead = h.servers[i].lastIndex THEN empty ELSE notEmpty;    END;  StoreInMailFile: INTERNAL PROCEDURE [    h: Handle, sourceStream: NSDataStream.SourceStream, envelope: Envelope,    buffer: Buffer, add: AddProc, post: PostProc, flushRemote: BOOLEAN]    RETURNS [      bodyType: LONG CARDINAL, messageOutcome: MessageOutcome ¬ stored] = {    attributes: MailAttributes.AttributesRecord ¬      MailAttributes.nullAttributesRecord;    serialStream: MailAttributes.SerialStream ¬ MailAttributes.MakeSerializer[      sourceStream, receive];    Cleanup: PROCEDURE =      BEGIN      IF attributes # MailAttributes.nullAttributesRecord THEN        MailAttributes.ClearAttributes[@attributes];      Stream.Delete[serialStream ! NSDataStream.Aborted => CONTINUE];      -- NOTE: This also deletes sourceStream.      END;    BEGIN    ENABLE UNWIND => Cleanup[];    MailAttributes.ReceiveAttributes[      serialStream, @attributes !      MailAttributes.MalformedAttribute => {        MailAttributes.ClearAttributes[@attributes];        attributes ¬ MailAttributes.nullAttributesRecord;        CONTINUE}];    bodyType ¬ attributes.bodyType;    [bodyType, messageOutcome] ¬ InternalStore[      h: h, envelope: envelope, attributes: @attributes, buffer: buffer,       add: add, post: post, flushRemote: flushRemote, serialStream: serialStream!        SkippingAttachment => {messageOutcome ¬ skipped; CONTINUE}];    END;  -- ENABLE UNWIND    Cleanup[];    };      InternalStore: INTERNAL PROCEDURE [    h: Handle, envelope: Envelope, attributes: MailAttributes.Attributes,    buffer: Buffer, add: AddProc, post: PostProc, flushRemote: BOOLEAN,    serialStream: MailAttributes.SerialStream ¬ NIL]    RETURNS [bodyType: LONG CARDINAL, messageOutcome: MessageOutcome ¬ stored] =    BEGIN    ENABLE NSDataStream.Aborted => CONTINUE;    attachment: BOOLEAN;    continuationHeader: LONG STRING =      "Date: *\nFrom: *\nSubject: Continuation of previous message\n\n"L;    continuationMessage: BOOLEAN ¬ FALSE;    hdrLength, msgLength: CARDINAL;    messageBodyGetsMailNote: BOOLEAN;    messageBodyGetsText: BOOLEAN;    messageBodySize: CARDINAL;    mS: Stream.Handle ¬ MemoryStream.Create[[LOOPHOLE[buffer], 0, bufferBytes]];    noteBlock: Environment.Block;    userAborted: BOOLEAN;    why: Stream.CompletionCode;    bodyType ¬ attributes.bodyType;    IF ~getAllAttachments AND envelope.inbasket.status = received      AND NOT        (attributes.bodyType = NSAssignedTypes.tEmpty          OR attributes.bodyType = NSAssignedTypes.tText) THEN      -- (Now that we are cooperating with ITS, which also marks messages      --   as "received," this is the only way to identify a message with      --   attachments as already having been seen by NSMailTransfers).      RETURN[bodyType, skipped];     messageBodyGetsText ¬ (attributes.bodyType = NSAssignedTypes.tText);    attachment ¬ FormatHeader[mS, attributes, envelope, h, flushRemote];    messageBodyGetsMailNote ¬ ~messageBodyGetsText AND (attributes.note.length>0);    hdrLength ¬ CARDINAL[Stream.GetPosition[mS]];    Stream.Delete[mS];    SELECT TRUE FROM      messageBodyGetsMailNote =>        BEGIN        msgLength ¬ hdrLength + attributes.note.length;        userAborted ¬ add[	  first, [LOOPHOLE[buffer], 0, hdrLength], msgLength, attachment];        noteBlock ¬ [LOOPHOLE[attributes.note.bytes], 0, attributes.note.length];        userAborted ¬ add[continuing, noteBlock, msgLength, FALSE];        END;      messageBodyGetsText =>        -- (Any additional mailNote was included in header)        BEGIN        DO          serialStream.options.signalEndOfStream ¬ FALSE;          [messageBodySize, why, ] ¬ Stream.GetBlock[            serialStream, [            LOOPHOLE[buffer], 	    IF continuationMessage THEN 0 ELSE hdrLength, bufferBytes]];          IF continuationMessage THEN            BEGIN            msgLength ¬ continuationHeader.length + messageBodySize;            userAborted ¬ add[              first, [              LOOPHOLE[@continuationHeader.text], 0, continuationHeader.length],              msgLength, FALSE];            userAborted ¬ add[	      continuing, [LOOPHOLE[buffer], 0, messageBodySize], msgLength, FALSE];            END          ELSE            BEGIN            msgLength ¬ hdrLength + messageBodySize;            userAborted ¬ add[              first, [LOOPHOLE[buffer], 0, msgLength], msgLength, FALSE];            END;          IF why = endOfStream THEN EXIT          ELSE            BEGIN            continuationMessage ¬ TRUE;            userAborted ¬ add[done, [NIL, 0, 0], msgLength, FALSE];            END;          ENDLOOP;        END;      ENDCASE --headerOnly-- =>        BEGIN        msgLength ¬ hdrLength;        userAborted ¬ add[	  first, [LOOPHOLE[buffer], 0, msgLength], msgLength, attachment];        END;    userAborted ¬ add[done, [NIL, 0, 0], msgLength, FALSE];    IF userAborted THEN messageOutcome ¬ userAborted;    END;  ReportState: ENTRY PROC [h: Handle] =    BEGIN    ENABLE {      ABORTED => CONTINUE;  -- PROC Retrieve may not be able to h ERRORs.      UNWIND => NULL;      };    nameStripe: STRING ¬ [500];    mailSomewhere: BOOLEAN ¬ FALSE;    oneDown: BOOLEAN ¬ FALSE;    Append: PROCEDURE [from: LONG STRING] =      BEGIN      IF from = NIL THEN RETURN;      nameStripe.length ¬ 0;      String.AppendString[from: from, to: nameStripe];      END;    FOR i: ServerType IN [primary..lastType] DO      SELECT h.servers[i].state FROM        accessProblem => {          Append["Access failure "L];          h.stateProc[h.clientData, noLogin, nameStripe]};        down =>          IF oneDown THEN {            Append["Servers all down "L];            h.stateProc[h.clientData, serversAllDown, nameStripe]}          ELSE oneDown ¬ TRUE;        authProblem => {          Append["Authentication problem "L];          h.stateProc[h.clientData, noLogin, nameStripe]};        badName => {          Append["Illegal user name "L];          h.stateProc[h.clientData, noLogin, nameStripe]};        badPwd => {          Append["Illegal user password "L];          h.stateProc[h.clientData, noLogin, nameStripe]};        empty => IF ~mailSomewhere THEN h.stateProc[h.clientData, empty, NIL];        noCH => {          Append["Clearinghouse down "L];          h.stateProc[h.clientData, noLogin, nameStripe]};        noMailboxes => NULL;  « {	  Append["No mailboxes"L];	  h.stateProc[h.clientData, noLogin, nameStripe]}; »        notEmpty => {h.stateProc[h.clientData, mail, NIL]; mailSomewhere ¬ TRUE; };        unknown => NULL;        ENDCASE => h.stateProc[h.clientData, bug, NIL];      h.servers[i].lastReportedState ¬ h.servers[i].state;      ENDLOOP;    END;  END.      
-- File:  AnswerImpl.mesa-- Wobber,	19-Dec-83 16:35:44-- PXK    ,	18-Aug-83 14:55:41-- RXL  ,	 4-Mar-81 10:23:39-- RXJ     ,	16-Sep-82 17:35:53DIRECTORY  Ascii USING [CR, SP],  Environment USING [Block],  Inline USING [LongCOPY],  MailUtil,  MailParse USING [    endOfInput, ErrorCode, Finalize, GetFieldBody, GetFieldName, Initialize,    Error, Handle, NameList, ProcessProc, WriteProc],  NSName USING [Name, NameRecord, CopyName, EquivalentNames, FreeName],  NSString USING [AppendToMesaString, EquivalentStrings],  String USING [AppendChar, AppendString, Equivalent, Length, LowerCase];  AnswerImpl: PROGRAM  IMPORTS Inline, MailParse, NSName, NSString, String, MailUtil  EXPORTS MailParse =    BEGIN    -- Local Data Structures and Types    maxFieldNameSize: CARDINAL = 30;    DuplicateNameHandle: TYPE = LONG POINTER TO DuplicateName;  DuplicateName: TYPE = RECORD [    next: DuplicateNameHandle,    seenOnSecondPass: BOOLEAN,    name: NSName.Name];    Buffer: TYPE = LONG STRING;    z: UNCOUNTED ZONE = MailUtil.zone;    CharIndex: TYPE = CARDINAL;  nullIndex: CharIndex = LAST[CharIndex];    Name: TYPE = NSName.Name;  NameRecord: TYPE = NSName.NameRecord;      -- Exported Procedures    MakeAnswerHeader: PUBLIC PROCEDURE [    getChar: PROCEDURE [CARDINAL] RETURNS [CHARACTER], getLength: CARDINAL,    putBlock: PROCEDURE [Environment.Block],    getPages: PROCEDURE [CARDINAL] RETURNS [LONG POINTER],    freePages: PROCEDURE [LONG POINTER], user: Name]    RETURNS [answerError: BOOLEAN, mpCode: MailParse.ErrorCode] =    BEGIN    getCharIndex, reStart: CharIndex;    pH: MailParse.Handle;    havePH: BOOLEAN ¬ FALSE;    buffer: Buffer ¬ NIL;    idIndex: CharIndex ¬ nullIndex;    dateIndex: CharIndex ¬ nullIndex;    subjectIndex: CharIndex ¬ nullIndex;        PutIndex: TYPE = {subject, inreply, to, cc}; -- order is significant!    FieldIndex: TYPE = { -- order is significant!      id, reply, from, sender, to, cc, c, bcc, date, subject};    knownField: ARRAY FieldIndex OF STRING = [      id: "Message-ID"L, reply: "Reply-to"L, sender: "Sender"L,      from: "From"L, to: "To"L, cc: "cc"L, c: "c"L, bcc: "bcc"L,      date: "Date"L, subject: "Subject"L]; -- order corresponds to FieldIndex    answerTarget: FieldIndex ¬ FieldIndex.LAST;        answerTargetBodyCharIndex: CharIndex ¬ 0;        targetEqualsOrigin: BOOLEAN ¬ TRUE;        origin: Name ¬ NIL;    namesOutput: BOOLEAN ¬ FALSE;    replyerCCed: BOOLEAN ¬ FALSE;    ccCount: CARDINAL ¬ 0;    duplicateHead: DuplicateNameHandle ¬ NIL;        AppendToBuffer: PROCEDURE [b: POINTER TO Buffer, char: CHARACTER] =      BEGIN      IF b.length >= b.maxlength THEN {	pages: CARDINAL = ((b.maxlength + 4)/512) + 1;	temp: Buffer ¬ NewBuffer[pages];	Inline.LongCOPY[from: @b.text, to: @temp.text, nwords: b.maxlength/2];	temp.length ¬ b.length;	freePages[b­];	b­ ¬ temp};      b[b.length] ¬ char;      b.length ¬ b.length + 1;      RETURN      END; -- of AppendToBuffer --          AppendNameToBuffer: PROCEDURE [b: POINTER TO Buffer, name: Name] =      BEGIN OPEN S: NSString;      nameS: STRING = [82];      BEGIN      S.AppendToMesaString[nameS, name.local];      IF S.EquivalentStrings[name.domain, user.domain] THEN GOTO printIt;      String.AppendChar[nameS, ':];      S.AppendToMesaString[nameS, name.domain];      IF S.EquivalentStrings[name.org, user.org] THEN GOTO printIt;      String.AppendChar[nameS, ':];      S.AppendToMesaString[nameS, name.org];      EXITS printIt => NULL;      END;      AppendStringToBuffer[b, nameS];      END; -- of AppendStringToBuffer --          AppendStringToBuffer: PROCEDURE [b: POINTER TO Buffer, s: LONG STRING] =      BEGIN      IF s # NIL THEN FOR i: CARDINAL IN [0..s.length) DO	AppendToBuffer[b, s[i]] ENDLOOP;      END; -- of AppendStringToBuffer --          DeleteRangeInBuffer: PROCEDURE [b: Buffer, from, to: CARDINAL] =      BEGIN      dif: CARDINAL = to - from;      b.length ¬ b.length - dif;      FOR i: CARDINAL IN [from..b.length) DO b[i] ¬ b[i+dif] ENDLOOP;      END; -- of DeleteRangeInBuffer --          NewBuffer: PROCEDURE [pages: CARDINAL] RETURNS [b: Buffer] =      BEGIN      b ¬ getPages[pages];      b­ ¬ [length: 0, maxlength: pages*512 - 4, text: ];      END; -- of NewBuffer --          GetNextChar: PROCEDURE RETURNS [char: CHARACTER] =      BEGIN      char ¬	IF getCharIndex >= getLength THEN MailParse.endOfInput	ELSE getChar[getCharIndex];      getCharIndex ¬ getCharIndex + 1;      END; -- of GetNextChar --          InitParse: PROCEDURE = {	pH ¬ MailParse.Initialize[GetNextChar]; havePH ¬ TRUE};    FinParse: PROCEDURE = {MailParse.Finalize[pH]; havePH ¬ FALSE};    StuffChar: PROCEDURE [char: CHARACTER] =      BEGIN      IF char ~= Ascii.CR THEN [] ¬ AppendToBuffer[@buffer, char];      END; -- of StuffChar --          StuffString: MailParse.WriteProc = {      FOR i: CARDINAL IN [0..String.Length[string]) DO        StuffChar[string[i]] ENDLOOP};          ProcessFields: PROCEDURE [Inner: PROC [index: FieldIndex]] =      BEGIN OPEN MailParse;      discardS: STRING = [0];      fieldName: STRING = [maxFieldNameSize];      getCharIndex ¬ 0;      InitParse[];      DO	IF ~GetFieldName[pH, fieldName] THEN EXIT;	FOR i: FieldIndex IN FieldIndex DO	  IF String.Equivalent[fieldName, knownField[i]] THEN {Inner[i]; EXIT};	  REPEAT FINISHED => [] ¬ GetFieldBody[pH, discardS];	  ENDLOOP;	ENDLOOP;      FinParse[];      END; -- of ProcessFields --          AnalyzeOrigin: PROCEDURE [index: FieldIndex] =      BEGIN      fieldBodyStartIndex: CharIndex = getCharIndex - 1;            ProcessName: MailParse.ProcessProc =	BEGIN	IF index = sender THEN origin ¬ NSName.CopyName[z, name];	IF index < answerTarget THEN {	  answerTarget ¬ index;	  answerTargetBodyCharIndex ¬ fieldBodyStartIndex};	END; -- of ProcessName --	      MailParse.NameList[pH,,ProcessName];      END; -- of AnalyzeOrigin --          FirstPass: PROCEDURE [index: FieldIndex] =      BEGIN      discard: STRING ¬ [0];      SELECT index FROM	id => {idIndex ¬ getCharIndex - 1; [] ¬ MailParse.GetFieldBody[pH, discard]};	IN [to..bcc] => FillNameField[firstPass: TRUE];	date => {	  dateIndex ¬ getCharIndex - 1;[] ¬ MailParse.GetFieldBody[pH, discard]};	subject => {	  subjectIndex ¬ getCharIndex - 1;	  [] ¬ MailParse.GetFieldBody[pH, discard]};	ENDCASE => [] ¬ MailParse.GetFieldBody[pH, discard];      RETURN      END; -- of FirstPass --          GetOrigin: PROCEDURE [index: FieldIndex] =      BEGIN      discard: STRING ¬ [0];      SELECT index FROM	IN [reply..sender] => AnalyzeOrigin[index];	ENDCASE => [] ¬ MailParse.GetFieldBody[pH, discard];      RETURN      END; -- of GetOrigin --          FillField: PROCEDURE =      BEGIN      field: STRING = [124];      InitParse[];      [] ¬  MailParse.GetFieldBody[pH, field];      IF field.length > field.maxlength - 4 THEN	BEGIN	field.length ¬ field.maxlength - 4;	String.AppendString[field, " ..."L];	END;      AppendStringToBuffer[@buffer, field];      FinParse[];      END; -- of FillField --          AddedToDuplicateList: PROCEDURE [name: Name, firstPass: BOOLEAN]      RETURNS [added: BOOLEAN] =      BEGIN      item: DuplicateNameHandle;      FOR item ¬ duplicateHead, item.next UNTIL item = NIL DO	IF NSName.EquivalentNames[item.name, name] THEN	  BEGIN	  IF firstPass THEN RETURN[FALSE];	  added ¬ ~item.seenOnSecondPass;	  item.seenOnSecondPass ¬ TRUE;	  RETURN	  END;	ENDLOOP;      item ¬ z.NEW[DuplicateName];      item.name ¬ NSName.CopyName[z, name];      item.seenOnSecondPass ¬ FALSE;      item.next ¬ duplicateHead;      duplicateHead ¬ item;      RETURN[TRUE]      END; -- of AddedToDuplicateList --          ReleaseDuplicateList: PROCEDURE =      BEGIN      item: DuplicateNameHandle;      UNTIL duplicateHead = NIL DO	item ¬ duplicateHead.next;	NSName.FreeName[z, duplicateHead.name];	z.FREE[@duplicateHead];	duplicateHead ¬ item;	ENDLOOP;      END; -- of ReleaseDuplicateList --          ProcessAnswerTarget: PROCEDURE =      BEGIN      putOne: BOOLEAN ¬ FALSE;      ProcessName: MailParse.ProcessProc =	BEGIN	[] ¬ AddedToDuplicateList[name, FALSE];	IF putOne THEN StuffString[", "L];	AppendNameToBuffer[@buffer, name];	putOne ¬ TRUE;	END; -- of ProcessName --	      getCharIndex ¬ answerTargetBodyCharIndex;      InitParse[];      MailParse.NameList[pH,,ProcessName,origin];      FinParse[];      END; -- of ProcessAnswerTarget --          AnalyzeAnswerTarget: PROCEDURE =      BEGIN            ProcessName: MailParse.ProcessProc =	BEGIN        targetEqualsOrigin ¬ targetEqualsOrigin AND	  NSName.EquivalentNames[name, origin];	IF ~AddedToDuplicateList[name, TRUE] THEN ccCount ¬ ccCount - 1;	END; -- of ProcessName --	      IF answerTargetBodyCharIndex = 0 THEN        ERROR MailParse.Error[mailBoxExpected];      getCharIndex ¬ answerTargetBodyCharIndex;      InitParse[];      MailParse.NameList[pH,,ProcessName, origin];      FinParse[];      END; -- of AnalyzeAnswerTarget --          FillNameField: PROCEDURE [firstPass: BOOLEAN] =      BEGIN      firstOutput: BOOLEAN ¬ TRUE;            ProcessName: MailParse.ProcessProc =	BEGIN	IF ~AddedToDuplicateList[name, firstPass] THEN RETURN[FALSE];	IF firstPass THEN {	  ccCount ¬ ccCount + 1;	  IF ~replyerCCed AND NSName.EquivalentNames[name, user] THEN	    replyerCCed ¬ TRUE;	  RETURN[FALSE]};  -- write procedure is NIL anyway	IF namesOutput THEN StuffString[", "L];	AppendNameToBuffer[@buffer, name];	namesOutput ¬ TRUE;	RETURN[FALSE];	END; -- of ProcessName --	      MailParse.NameList[pH,,ProcessName, origin];      END; -- of FillNameField --          SecondPass: PROCEDURE [index: FieldIndex] =      BEGIN      discard: STRING = [0];      SELECT index FROM	IN [to..bcc] => FillNameField[firstPass: FALSE];	ENDCASE => [] ¬ MailParse.GetFieldBody[pH, discard];      END; -- of SecondPass --          PutBuffer: PROCEDURE =      BEGIN      AppendToBuffer[@buffer, Ascii.CR];      putBlock[[LOOPHOLE[@buffer.text], 0, buffer.length]];      buffer.length ¬ 0;      END; -- of PutBuffer --        -- main body of AnswerCommand      answerError ¬ FALSE;    buffer ¬ NewBuffer[1];        BEGIN        -- find out who it's from and where the interesting indices are    BEGIN    ENABLE MailParse.Error => {mpCode ¬ code; GOTO BadMessage};    ProcessFields[GetOrigin];    IF origin=NIL THEN {mpCode ¬ noSenderField; GOTO BadMessage};    ProcessFields[FirstPass];    AnalyzeAnswerTarget[];    END; -- of ENABLE        -- make Subject field    AppendStringToBuffer[@buffer, "Subject: Re: "L];    IF subjectIndex # nullIndex THEN {      getCharIndex ¬ subjectIndex; FillField[]};    reStart ¬ 13;    WHILE (buffer.length > reStart + 2) AND      (String.LowerCase[buffer[reStart]] = 'r) AND      (String.LowerCase[buffer[reStart+1]] = 'e) AND      (buffer[reStart+2] = ':) DO      DeleteRangeInBuffer[buffer, reStart, reStart + 3];      WHILE buffer.length > reStart AND buffer[reStart] = Ascii.SP DO	DeleteRangeInBuffer[buffer, reStart, reStart + 1]; ENDLOOP;      ENDLOOP;    PutBuffer[];          -- make In-reply-to field    AppendStringToBuffer[@buffer, "In-reply-to: "L];    IF idIndex # nullIndex THEN {      getCharIndex ¬ idIndex; FillField[]}    ELSE {      IF (IF answerTarget = reply THEN targetEqualsOrigin          ELSE (ccCount = 0 OR (replyerCCed AND ccCount = 1))) THEN        AppendStringToBuffer[@buffer, "Your"L]      ELSE        BEGIN        AppendNameToBuffer[@buffer, origin];        AppendStringToBuffer[@buffer, "'s"];        END;      AppendStringToBuffer[@buffer, " message of "L];      IF dateIndex # nullIndex THEN {getCharIndex ¬ dateIndex; FillField[]}};    PutBuffer[];        -- fill in target (To:) field of answer form    AppendStringToBuffer[@buffer, "To: "L];    ProcessAnswerTarget[];    PutBuffer[];        -- fill in cc: field    AppendStringToBuffer[@buffer, "cc: "L];    IF answerTarget = reply THEN AppendNameToBuffer[@buffer, user]    ELSE ProcessFields[SecondPass ! MailParse.Error => {      mpCode ¬ code; GO TO BadMessage}];    PutBuffer[];        EXITS BadMessage => {IF havePH THEN FinParse[]; answerError ¬ TRUE};    END;        IF origin#NIL THEN NSName.FreeName[z, origin];    freePages[buffer];    ReleaseDuplicateList[];        RETURN[answerError, mpCode]    END; -- of MakeHeader --          END.  -- AnswerImpl --
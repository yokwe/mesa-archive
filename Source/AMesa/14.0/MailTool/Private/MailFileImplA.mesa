-- File: MailFileImplA.mesa - last edit by:-- AlHall,	19-Jun-84 13:22:33-- PXK    ,	22-Sep-83 17:33:34 -- JGS    ,	 4-Feb-83 15:31:15 -- RXJ     ,	17-Sep-82 14:48:23 DIRECTORY  Ascii USING [CR, NUL, SP],  BodyDefs USING [ItemType],  Environment USING [bytesPerPage],  Format USING [Char, Number, NumberFormat, StringProc],  Inline USING [DBITAND, DBITXOR],  MailFile USING [    AttributeIndex, Attributes, Enumerator, ErrorCode, Flag, Handle, LetGo,    LetGoChoice, MsgNumber, nullMessage, Object, StreamPiece],  MailFileOps USING [    AttributeSideAffect, attributesLength, CleanupToc, DestroyToc, deleteFlag,    ExtendToc, examinedFlag, Handle, Info, initialAttributes, itemOverhead,    LoadToc, msgAttributes, Object, ReadOnlyToc, standardStampLength,    undeleteFlag, unexaminedFlag, wholeStampLength, WriteToc],  MailUtil,  MFile USING [    Access, Error, ErrorCode, GetFullName, Handle, Object,    ReadOnly, ReadWrite, ReleaseChoice],  MStream USING [    Create, Error, GetFile, GetLength, Handle, PleaseReleaseProc,    SetAccess, SetReleaseData],  Process USING [Detach],  Stream USING [    defaultObject, Delete, DeleteProcedure, Handle, Object, Position, PutBlock,    PutChar, PutProcedure, PutString, SendNow, SendNowProcedure, SetPosition],  String USING [AppendChar, AppendString, CopyToNewString, StringBoundsFault],  Volume USING [GetAttributes, systemID];MailFileImplA: MONITOR LOCKS h USING h: Handle  IMPORTS    Format, Inline, MailFileOps, MailUtil, MFile,    MStream, Process, Stream, String, Volume  EXPORTS MailFile, MailFileOps =  BEGIN  OPEN Ops: MailFileOps;  Handle: TYPE = LONG POINTER TO Object;  Object: PUBLIC TYPE = Ops.Object;  Error: PUBLIC ERROR [    code: MailFile.ErrorCode, message: MsgNumber ¬ 0,    position: LONG CARDINAL ¬ 0] = CODE;  BadFormat: PUBLIC ERROR [msg: MsgNumber, pos: LONG CARDINAL] = CODE;  starStampStar: PUBLIC LONG STRING ¬ "*start*\n"G;  z: PUBLIC UNCOUNTED ZONE ¬ MailUtil.zone;  StreamPiece: TYPE = MailFile.StreamPiece;  MsgNumber: TYPE = MailFile.MsgNumber;  Attributes: TYPE = MailFile.Attributes;  nullMessage: MsgNumber = MailFile.nullMessage;    charsPerPage: CARDINAL = Environment.bytesPerPage;  fiveDig: Format.NumberFormat = [zerofill: TRUE, columns: 5];  AddMsgStream: TYPE = LONG POINTER TO AddMsgStreamObject;  AddMsgStreamObject: TYPE = RECORD [    stream: Stream.Object,    h: Handle,    before: MsgNumber,     messages: CARDINAL ¬ 0,    index: LONG CARDINAL,    room: LONG CARDINAL];-- Body Handling Procedures  AddMessages: PUBLIC ENTRY PROC [h: Handle, before: MsgNumber]    RETURNS [Stream.Handle] = {    ENABLE UNWIND => NULL;    msgStream: AddMsgStream;    extraRoom: LONG CARDINAL = 50*charsPerPage;    room: LONG CARDINAL =      Volume.GetAttributes[Volume.systemID].freePageCount * charsPerPage;    curLength: LONG CARDINAL = MStream.GetLength[h.stream];    IF ~h.writeEnabled THEN ERROR Error[access];    msgStream ¬ z.NEW[AddMsgStreamObject ¬ [      stream: Stream.defaultObject, h: h, index: curLength,      room: IF room < extraRoom THEN 0 ELSE room - extraRoom,      before: IF before = nullMessage THEN h.info.length ELSE before]];    msgStream.stream.put ¬ InsertPut;    msgStream.stream.delete ¬ InsertFinished;    msgStream.stream.sendNow ¬ InsertSendNow;    RETURN[@msgStream.stream]};  AppendStamp: PROC [  -- does not add trailing @ so caller can add extra stuff    stampString: LONG STRING, textLength: CARDINAL, attributes: Attributes,    flag: CHARACTER, extraLength: CARDINAL ¬ 0] = {    AppendProc: Format.StringProc = {String.AppendString[stampString, s]};    stampLength: CARDINAL = Ops.wholeStampLength + extraLength;    String.AppendString[stampString, starStampStar];    Format.Number[AppendProc, textLength + stampLength, fiveDig];    String.AppendChar[stampString, Ascii.SP];    Format.Number[AppendProc, stampLength, fiveDig];    String.AppendString[stampString, " UU"L];    String.AppendChar[stampString, flag];    String.AppendChar[stampString, Ascii.CR];    String.AppendChar[stampString, '@];    ItemFront[      AppendProc, Ops.msgAttributes, Ops.attributesLength];    FOR a: MailFile.AttributeIndex IN MailFile.AttributeIndex DO      String.AppendChar[stampString, IF attributes[a] THEN 't ELSE 'f]      ENDLOOP;    String.AppendChar[stampString, Ascii.CR]};  ItemFront: PROC [    put: Format.StringProc, itemType: BodyDefs.ItemType, itemLength: CARDINAL] = {    Format.Number[put, itemLength + Ops.itemOverhead, fiveDig, NIL];    Format.Char[put, Ascii.SP];    Format.Number[put, ORD[itemType], fiveDig];    Format.Char[put, Ascii.SP]};    <<	The following two procedures should be made robust in the event	of running out of room on the local volume. Unfortunately, if a stream	is UNWINDed in the middle of its SetupBuffer routine, the space in	the stream remains unmapped and any other call on stream procedures	for that stream will result in disaster. Essentially, there is no way	to deal with a stream if it runs out of room on the local volume.>>  StartAnotherMessage: PUBLIC PROC [    stream: Stream.Handle, length: CARDINAL, attachments, examined: BOOLEAN, flag: CHAR] = {    ms: AddMsgStream ¬  LOOPHOLE[stream];    messageLength: CARDINAL = length + Ops.wholeStampLength;    stampString: STRING = [Ops.wholeStampLength + 5];    attr: Attributes ¬ Ops.initialAttributes;    IF ms.room < LONG[length] THEN ERROR Error[volumeFull];    ms.room ¬ ms.room - length;    attr[attachments] ¬ attachments;    attr[examined] ¬ examined;    AppendStamp[stampString, length, attr, flag];    String.AppendChar[stampString, '@];    ms.h.stream.SetPosition[ms.index];    ms.h.stream.PutString[stampString];    ms.index ¬ ms.index + stampString.length};  InsertPut: Stream.PutProcedure = {    ms: AddMsgStream = LOOPHOLE[sH];    ms.h.stream.SetPosition[ms.index];    ms.h.stream.PutBlock[block: block];    ms.index ¬ ms.index + block.stopIndexPlusOne - block.startIndex};  InsertSendNow: Stream.SendNowProcedure = {    ms: AddMsgStream = LOOPHOLE[sH]; ms.h.stream.SendNow[]};  InsertFinished: Stream.DeleteProcedure = {  -- This mapping is done so that record will still exist when MONITOR is exited.    ms: AddMsgStream ¬ LOOPHOLE[sH]; RealFinished[ms.h, ms.before]; z.FREE[@ms]};    RealFinished: ENTRY PROC [h: Handle, before: MsgNumber] = {    ENABLE UNWIND => NULL;    h.stream.SendNow[];    Ops.ExtendToc[h, before];    Ops.CleanupToc[h]};    ReleaseMailStream: PUBLIC MStream.PleaseReleaseProc = {    RETURN[RealRelease[stream, instanceData]]};  RealRelease: ENTRY PROC [stream: Stream.Handle, h: Handle]    RETURNS [MFile.ReleaseChoice] = {    ENABLE UNWIND => NULL;    IF h.writeEnabled OR h.letGo = NIL THEN RETURN[no];    IF h.beingFreed THEN RETURN[later];    SELECT h.letGo[h, h.data] FROM      no => RETURN[no];      later => RETURN[later];      goAhead => {        h.beingFreed ¬ TRUE;	Process.Detach[FORK Destroy[h]];	RETURN[later]};      ENDCASE => ERROR Error[other]};  GetStream: PROC [fileName: LONG STRING, create: BOOLEAN]    RETURNS [stream: Stream.Handle, openedForWrite: BOOLEAN ¬ FALSE] = {    access: MFile.Access = IF create THEN readWrite ELSE readOnly;    fh: MFile.Handle;    fh ¬ MFile.ReadOnly[name: fileName, release: [], mightWrite: TRUE !        MFile.Error =>          SELECT code FROM            noSuchFile =>	      IF create THEN {fh ¬ NIL; CONTINUE}	      ELSE ERROR Error[fileNotFound];	    conflictingAccess => ERROR Error[fileBusy];	    ENDCASE => ERROR Error[fileProblem]];  -- don't get write access unless needed for create!    IF fh = NIL THEN {      openedForWrite ¬ TRUE;      fh ¬ MFile.ReadWrite[name: fileName, release: [], type: text !        MFile.Error => ERROR Error[fileBusy]]};    stream ¬ MStream.Create[file: fh, release: []];    RETURN[stream]};      Create: PUBLIC PROC [    fileName: LONG STRING, createIt: BOOLEAN ¬ FALSE,    letGo: MailFile.LetGo, data: LONG POINTER]    RETURNS [h: Handle] = {    cleanedUp: BOOLEAN ¬ FALSE;    Cleanup: PROCEDURE = {      IF cleanedUp THEN RETURN;      object.stream.Delete[];      z.FREE[@object.fileName];      cleanedUp ¬ TRUE};    wholeName: LONG STRING = [200];    object: Object ¬ [letGo: letGo, data: data];    [object.stream, object.writeEnabled] ¬ GetStream[fileName, createIt];    MFile.GetFullName[MStream.GetFile[object.stream], wholeName];    object.fileName ¬ String.CopyToNewString[wholeName, z];    Ops.LoadToc[@object, fileName !      BadFormat => {Cleanup[]; ERROR Error[fileHasBadFormat, msg, pos]};      UNWIND => Cleanup[]];    h ¬ z.NEW[Object ¬ object];    MStream.SetReleaseData[h.stream, [ReleaseMailStream, h]];    MStream.SetReleaseData[h.tocStream, [ReleaseMailStream, h]]};  Messages: PUBLIC PROCEDURE [h: Handle] RETURNS [CARDINAL] = {    RETURN[h.info.length]};  GetFileAttributes: PUBLIC ENTRY PROC [h: Handle, name: LONG STRING]    RETURNS [nMessages: CARDINAL, fileLength: LONG CARDINAL]= {    IF name # NIL THEN String.AppendString[name, h.fileName !      String.StringBoundsFault => RESUME[NIL]];    nMessages ¬ h.info.length;    fileLength ¬ MStream.GetLength[h.stream]};  WantToFree: ENTRY PROC [h: Handle]= {h.beingFreed ¬ TRUE};  Destroy: PUBLIC PROC [h: Handle] = {    WantToFree[h];    h.stream.Delete[];    Ops.DestroyToc[h];    z.FREE[@h.fileName];    z.FREE[@h]};  Enumerate: PUBLIC PROC [    h: Handle, from, to: MsgNumber, enumerator: MailFile.Enumerator,    mask, filter: Attributes] ={    FixAttr: PROC [Attributes] RETURNS [LONG CARDINAL] =      MACHINE CODE BEGIN END;    FOR msg: MsgNumber IN [from..MIN[to + 1, h.info.length]) DO      IF Inline.DBITAND[        FixAttr[mask],	Inline.DBITXOR[	  FixAttr[filter],	  FixAttr[h.info[msg].attributes]] ] = 0 AND enumerator[msg] THEN EXIT;      ENDLOOP};      Delete: PUBLIC PROC [h: Handle, msg: MsgNumber] = {    SetAttr[h, msg, deleted, TRUE, delete]};  UnDelete: PUBLIC PROC [h: Handle, msg: MsgNumber] = {    SetAttr[h, msg, deleted, FALSE, undelete]};  MarkExamined: PUBLIC PROC [h: Handle, msg: MsgNumber] = {    SetAttr[h, msg, examined, TRUE, mark]};  UnMarkExamined: PUBLIC PROC [h: Handle, msg: MsgNumber] = {    SetAttr[h, msg, examined, FALSE, unmark]};  MarkAttachments: PUBLIC PROC [h: Handle, msg: MsgNumber] = {    SetAttr[h, msg, attachments, TRUE, null]};  UnMarkAttachments: PUBLIC PROC [h: Handle, msg: MsgNumber] = {    SetAttr[h, msg, attachments, FALSE, null]};  SetMsgAttribute: PUBLIC PROC [    h: Handle, msg: MsgNumber, attribute: MailFile.AttributeIndex,    value: BOOLEAN] = {    SetAttr[h, msg, attribute, value, null]};  SetAttr: ENTRY PROC [    h: Handle, msg: MsgNumber, attribute: MailFile.AttributeIndex, value: BOOLEAN,    sideEffect: Ops.AttributeSideAffect] =    BEGIN    ENABLE UNWIND => NULL;    info: LONG POINTER TO Ops.Info = @h.info[msg];    IF info.attributes[attribute] = value THEN RETURN;    IF ~h.writeEnabled THEN ERROR Error[access];    info.attributes[attribute] ¬ value;    IF ~info.attributes[noAttributes] THEN {      PutCharAt[        s: h.stream,        pos: info.pos + Ops.standardStampLength +	     Ops.itemOverhead + 1--the @ sign-- + attribute.ORD,        c: IF value THEN 't ELSE 'f]};    SELECT sideEffect FROM      delete => PutCharAt[h.stream, info.pos + 20, Ops.deleteFlag];      undelete => PutCharAt[h.stream, info.pos + 20, Ops.undeleteFlag];      mark => PutCharAt[h.stream, info.pos + 21, Ops.examinedFlag];      unmark => PutCharAt[h.stream, info.pos + 21, Ops.unexaminedFlag];      ENDCASE;    END;  ForceOut: PUBLIC PROC [h: Handle] = {    IF ~h.writeEnabled THEN RETURN;    h.stream.SendNow[];    Ops.CleanupToc[h]};  Message: PUBLIC PROC [h: Handle, msg: MsgNumber] RETURNS [sp: StreamPiece] = {    info: LONG POINTER TO Ops.Info = @h.info[msg];    RETURN[[      stream: h.stream,      first: info.pos + info.stampLength,      lastPlusOne: info.pos + info.length]]};  PutCharAt: PUBLIC PROC [s: Stream.Handle, pos: LONG CARDINAL, c: CHARACTER] =    INLINE {s.SetPosition[pos]; s.PutChar[c]};    SetMsgFlag: PUBLIC ENTRY PROC [    h: Handle, msg: MsgNumber, flag: MailFile.Flag] = {    ENABLE UNWIND => NULL;    IF ~h.writeEnabled THEN ERROR Error[access];    h.info[msg].flag ¬ flag;    PutCharAt[h.stream, h.info[msg].pos + 22, flag]};  MakeWritable: PUBLIC PROC [h: Handle] = {    ENABLE MFile.Error, MStream.Error => ERROR Error[fileBusy];    IF h.writeEnabled THEN RETURN;    Ops.WriteToc[h];    MStream.SetAccess[h.stream, readWrite];    h.writeEnabled ¬ TRUE};  MakeReadOnly: PUBLIC PROC [h: Handle] = {    IF ~h.writeEnabled THEN RETURN;    Ops.ReadOnlyToc[h];    MStream.SetAccess[h.stream, readOnly];    h.writeEnabled ¬ FALSE};  File: PUBLIC PROC [h: Handle] RETURNS [MFile.Handle] = {    RETURN[MStream.GetFile[h.stream]]};  GetMsgAttributes: PUBLIC PROC [h: Handle, msg: MsgNumber]    RETURNS [Attributes, CHARACTER] = {    info: LONG POINTER TO Ops.Info = @h.info[msg];    RETURN[info.attributes, info.flag]};  TOCEntry: PUBLIC PROC [h: Handle, msg: MsgNumber]    RETURNS [piece: StreamPiece, attributes: Attributes, flag: MailFile.Flag] =    BEGIN    info: LONG POINTER TO Ops.Info = @h.info[msg];    IF msg > h.info.length THEN RETURN[[NIL, 0, 0], ALL[FALSE], Ascii.NUL];    piece ¬ [      stream: h.tocStream,      first: info.tocPos,     lastPlusOne: info.tocPos + info.tocLength];    attributes ¬ info.attributes;    flag ¬ info.flag;    END;      END... -- of MailFileImplA  
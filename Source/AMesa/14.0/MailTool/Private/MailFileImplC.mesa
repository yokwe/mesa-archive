-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved. -- File: MailFileImplC.mesa - last edit by:-- PXK    ,	 3-Feb-83  9:41:39 << This module is responsible for handling the class properties of   mail files. For the most part all these procedures are empty. >>   DIRECTORY  MailFile USING [ClassIndex, Error],  MailFileOps USING [itemOverhead, Object],  Stream USING [GetChar];MailFileImplC: MONITOR  IMPORTS MailFile, Stream  EXPORTS MailFile, MailFileOps =  BEGIN  Handle: TYPE = LONG POINTER TO Object;  Object: PUBLIC TYPE = MailFileOps.Object;    ClassIndex: TYPE = MailFile.ClassIndex;  PutClasses: PUBLIC PROC [h: Handle] = {<< commented out until we can actually parse the classes    length: CARDINAL ¬ 0;    temp: LONG STRING = [wholeStampLength];    Put: Format.StringProc = {h.stream.PutString[s]; length ¬ length + s.length};    attr: Attributes = [classes: TRUE, examined: TRUE];    AllowWriting[h, on];    IF ~h.header.hasClasses THEN {      h.header.hasClasses ¬ TRUE;      h.header.classPos ¬ MStream.GetLength[h.stream];      h.header.classLength ¬ classLength};    h.stream.SetPosition[h.header.classPos];    AppendStamp[temp, 0, attr, classLength];    h.stream.PutString[temp];    ItemFront[Put, msgClasses, classLength];    FOR c: MailFile.ClassIndex IN MailFile.ClassIndex DO      Format.Char[Put, '(];      Format.Block[	proc: Put,	block: [	  blockPointer: LOOPHOLE[@h.header.classChars],	  startIndex: h.header.classes[c].start,	  stopIndexPlusOne: h.header.classes[c].end]];      Format.Char[Put, ':];      Format.Number[Put, c, twoDig];      Format.Text[Put, ") "L];      ENDLOOP;    Format.Char[Put, Ascii.CR];    THROUGH [length..classLength-1) DO h.stream.PutChar['.] ENDLOOP;    h.stream.PutChar[Ascii.CR]and that is all for this procedure>>    };  ParseClasses: PUBLIC PROC [h: Handle, length: CARDINAL] = {    THROUGH [0..length - MailFileOps.itemOverhead) DO      [] ¬ h.stream.GetChar[] ENDLOOP};  AddClass: PUBLIC PROC [h: Handle, class: LONG STRING] = {    ERROR MailFile.Error[other, 0, 0]};  RemoveClass: PUBLIC PROC [h: Handle, class: LONG STRING] = {    ERROR MailFile.Error[other, 0, 0]};  ClassToClassIndex: PUBLIC PROC [h: Handle, class: LONG STRING]    RETURNS [ClassIndex] = {    ERROR MailFile.Error[other, 0, 0]};  ClassIndexToClass: PUBLIC PROC [    h: Handle, index: ClassIndex, class: LONG STRING] = {    ERROR MailFile.Error[other, 0, 0]};  END...  
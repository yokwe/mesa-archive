-- File: MailReadImplB.mesa - Last Edited:-- AlHall	 3-Jan-85 21:39:23-- Wobber	14-Dec-83 12:37:12-- PXK    	22-Sep-83 18:46:19-- NS     	17-Dec-85 11:28:39-- BGY     	23-Apr-86 14:28:12<< This module has the routines that actually do the work.>>DIRECTORY  Ascii,  Cursor,  Environment,  Event,  EventTypes,  FormSW,  HeraldWindow,  MailFile,  MailFilterUI,  MailReadOps,  MailSend,  MailUtil,  MFile,  MStream,  MailTransfer,  MailParse,  NSName,  NSString,  Process,  Profile,  ProfileExtra,  Put,  Runtime,  Selection,  ScratchSource,  Stream,  StreamSource,  String,  Supervisor,  System,  TextSource,  TextSW,  TextSWExtraExtra,  UserInput,  UserTerminal,  Window,  WindowFont;MailReadImplB: MONITOR  IMPORTS    Cursor, Event, FormSW,      HeraldWindow, MailFile, MailFilterUI, MailReadOps,    MailSend, MailTransfer, MailUtil, MFile, MStream, MailParse, NSName,    NSString, Process, Profile, Put, Runtime, Selection,     ScratchSource, String, Stream, StreamSource,    Supervisor, System, TextSource, TextSW, TextSWExtraExtra, UserInput, Window,    WindowFont  EXPORTS MailReadOps =  BEGIN OPEN MR: MailReadOps;  Commands: TYPE = MR.Commands;  ConfirmProc: TYPE = PROCEDURE [data: Data] RETURNS [confirmed: BOOLEAN ¬ TRUE];  data: PUBLIC Data ¬ NIL;  Data: TYPE = MR.Data;  MsgNumber: TYPE = MailFile.MsgNumber;  nullConfirmProc: ConfirmProc = {};  nullMessage: CARDINAL = MailFile.nullMessage;  zone: UNCOUNTED ZONE = MailUtil.zone;  scratch: TextSource.Handle ¬ ScratchSource.Create[];  ModifySourceProc: TYPE = PROC [    window: Window.Handle, source: TextSource.Handle, data: Data]    RETURNS [TextSW.InvalidRegions];  CreateData: PUBLIC PROC RETURNS [Data] = {    RETURN[data ¬ zone.NEW[MR.DataObject ¬ [z: zone]]]};  DeleteData: PUBLIC ENTRY PROC = {    dataCopy: Data ¬ data;    data ¬ NIL;    WHILE dataCopy.busy DO WAIT dataCopy.condition ENDLOOP};  Expunging: Supervisor.AgentProcedure = {    OPEN et: EventTypes;    SELECT event FROM      et.aboutToBoot, et.aboutToBootPhysicalVolume, et.aboutToAbortSession,        et.aboutToResume => {        Put.Text[NIL, MailReadOps.toolName];        Put.Line[NIL, ": expunging a mail file."L];        ERROR Supervisor.EnumerationAborted};      ENDCASE};  ReleaseOne: PROC [data: Data, mf: MailFile.Handle] = {    ENABLE UNWIND => NULL;    expunge: Supervisor.SubsystemHandle = Supervisor.CreateSubsystem[Expunging];    Supervisor.AddDependency[client: expunge, implementor: Event.aboutToSwap];    [] ¬ MaybeExpunge[mf];    MailFile.Destroy[mf];    Supervisor.RemoveDependency[client: expunge, implementor: Event.aboutToSwap];    Supervisor.DeleteSubsystem[expunge]};  STR: PROC [s: LONG STRING] RETURNS [NSString.String] = INLINE {    RETURN[NSString.StringFromMesaString[s]]};  DoneWithDataCopy: PUBLIC PROC [data: Data] = {    ENABLE UNWIND => NULL;    z: UNCOUNTED ZONE = data.z;    FOR i: CARDINAL IN [0..MR.cacheSize) DO      IF data.cache[i].mf # NIL THEN ReleaseOne[data, data.cache[i].mf]; ENDLOOP;    z.FREE[@data]};  Post: PUBLIC MailTransfer.PostProc = {    window: Window.Handle = IF data # NIL THEN data.msgSW ELSE NIL;    IF window = NIL THEN BEGIN Put.Text[NIL, MailReadOps.toolName]; Put.Text[NIL, ": "L]; END;    Put.Text[window, s];    IF eol THEN Put.CR[window];    };  PrintError: PROC [code: MailFile.ErrorCode] = {    string: STRING = [40];    Post["Mail file error: "L, FALSE];    StringForError[code, string];    Post[string]};  StringForError: PROC [code: MailFile.ErrorCode, string: LONG STRING] = {    String.AppendString[      string,      SELECT code FROM        tooManyMessages => "too many messages"L,        messageTooLarge => "message too large"L,        fileBusy => "file busy"L,        fileNotFound => "file not found"L,        fileHasBadFormat => "file has bad format"L,        classIsNotEmpty => "class is not empty"L,        classExists => "class already exists"L,        noSuchClass => "no such class"L,        fileProblem => "file problem"L,        volumeFull => "volume full"L,        access => "implementation bug"L,        ENDCASE => "unknown"L]};  CommandProc: PUBLIC FormSW.ProcType =    BEGIN    ENABLE MailFile.Error => {PrintError[code]; CONTINUE};    command: Commands = VAL[index];    goAhead: BOOLEAN ¬ TRUE;    IF command # newForm AND CheckBusy[data] THEN RETURN;    IF command # newForm AND ~HaveCurrent[data] THEN {      Post[s: "No current mail file"L, error: TRUE]; RETURN};    SELECT command FROM      newForm, newMail, expunge, sort, append => NULL;      ENDCASE => goAhead ¬ FillInMessageRange[data, command = display];    IF goAhead THEN      data.tocLines ¬ MAX[        3, Window.GetBox[data.tocSW].dims.h / WindowFont.FontHeight[data.tocFont]];    SELECT command FROM      answer => CreateNewWindow[data, answer];      append => Append[data];      delete => {Delete[data, TRUE]; MaybeDisplay[data]};      display => Display[data, TRUE];      forward => CreateNewWindow[data, forward];      expunge =>        ExecuteInBackground[Expunge, data, "Expunging ... "L, ConfirmExpunge];      hardcopy => ExecuteInBackground[MR.Hardcopy, data, "Hardcopy ... "L];      move => IF MoveMessage[data] THEN MaybeDisplay[data];      newForm => CreateNewWindow[data, newForm];      newMail => ExecuteInBackground[RetrieveNewMail, data, "Retrieving ... "L];      undelete => Delete[data, FALSE];      sort => Sort[data];      ENDCASE => NULL;    END;  ConfirmExpunge: ConfirmProc =    BEGIN    deletingAttachments: BOOLEAN ¬ FALSE;    mask: MailFile.Attributes ¬ ALL[FALSE];    mf: MailFile.Handle = GetCurrent[data];    DeletingAttachments: MailFile.Enumerator =      { RETURN[deletingAttachments ¬ TRUE]; };        BEGIN  -- scope for EXITS    mask[deleted] ¬ TRUE;    mask[attachments] ¬ TRUE;    MailFile.Enumerate[h: mf, enumerator: DeletingAttachments,      mask: mask, filter: mask, from: 0, to: MailFile.Messages[mf]];    IF NOT deletingAttachments THEN GOTO done;    Post["Deleting attachments [Confirm] "L, FALSE, TRUE];    Cursor.Set[mouseRed];    confirmed ¬ UserInput.WaitForConfirmation[].okay;    Post["... "L, FALSE];    Cursor.Set[textPointer];    FreeMailFile[data, mf];    EXITS       done => FreeMailFile[data, mf]    END  -- scope for EXITS    END;  DisplayOne: UserInput.PeriodicProcType = {    data.selectInTocWindow ¬ FALSE;    data.firstSelect ¬ data.lastSelect ¬ data.newMessage;    data.newMessage ¬ nullMessage;    Display[data, FALSE]};  ExecuteInBackground: PROCEDURE [    proc: MR.BackgroundProc, data: Data, note: STRING,    confirmProc: ConfirmProc ¬ nullConfirmProc] =    BEGIN    h: Event.Handle;    NowBusy[proc, data, note];    h ¬ Event.StartingProcess[MailReadOps.toolName];    IF confirmProc[data].confirmed THEN Process.Detach[FORK Fork[proc, data, h]]    ELSE      BEGIN      Post["Aborted ... done"L, FALSE];      Event.DoneWithProcess[h];      NoLongerBusy[data];      END;    END;  NowBusy: ENTRY PROCEDURE [proc: MR.BackgroundProc, data: Data, note: STRING] =    BEGIN    ENABLE UNWIND => NULL;    data.busy ¬ TRUE;    Post[s: note, eol: FALSE];    FormSW.FindItem[data.formSW, MR.Commands.file.ORD].flags.readOnly ¬ TRUE;    TextSW.ForceOutput[data.msgSW];    END;  Fork: PROC [proc: MR.BackgroundProc, data: Data, h: Event.Handle] = {    newFirstToc: MsgNumber ¬ nullMessage;    ok: BOOLEAN ¬ FALSE;    Process.SetPriority[Process.priorityNormal];    BEGIN    ENABLE {      MailFile.Error => {PrintError[code]; CONTINUE};      ABORTED => {ok ¬ FALSE; CONTINUE};      UNWIND => {Event.DoneWithProcess[h]; NoLongerBusy[data]};      MR.HardcopyError => CONTINUE};    [newFirstToc, ok] ¬ proc[data];    IF newFirstToc # nullMessage THEN {      mf: MailFile.Handle = GetCurrent[data];      TextSW.SetSource[        data.tocSW, data.tocSource, MR.TOCPosition[mf, newFirstToc]];      Window.ValidateTree[data.toolW];      FreeMailFile[data, mf]};    END;  -- of ENABLE    Event.DoneWithProcess[h];    NoLongerBusy[data];    Post[IF ok THEN "done"L ELSE ""L];    IF data.newMessage # nullMessage AND data.displayOnNewMail THEN      [] ¬ UserInput.CreatePeriodicNotify[DisplayOne, data.formSW, 0]};  CheckBusy: PUBLIC ENTRY PROC [data: Data] RETURNS [busy: BOOLEAN] = {    ENABLE UNWIND => NULL;    Post[""L];    busy ¬ data.busy;    IF busy THEN BEGIN Post[MailReadOps.toolName, FALSE, TRUE]; Post[" is busy."L]; END;    };  NoLongerBusy: ENTRY PROCEDURE [data: Data] = {    ENABLE UNWIND => NULL;    data.busy ¬ FALSE;    FormSW.FindItem[data.formSW, MR.Commands.file.ORD].flags.readOnly ¬ FALSE;    NOTIFY data.condition};  AddExtensionIfNeeded: PUBLIC PROC [    s: LONG POINTER TO LONG STRING, ext: LONG STRING, sw: Window.Handle,    index: CARDINAL] =    BEGIN    FOR i: CARDINAL IN [0..s.length) DO IF s[i] = '. THEN RETURN ENDLOOP;    IF ext[0] # '. THEN FormSW.ModifyEditable[sw, index, s­.length, 0, "."L];    FormSW.ModifyEditable[sw, index, s­.length, 0, ext];    END;  --of AddExtensionIfNeeded  Append: PROCEDURE [data: Data] =    BEGIN    newFirstToc: MsgNumber ¬ nullMessage;    ok: BOOLEAN ¬ FALSE;    Post[s: "Appending ... "L, eol: FALSE];    [newFirstToc, ok] ¬ MailReadOps.AppendMail[data, Post, PrintError];    IF newFirstToc # nullMessage THEN      BEGIN      mf: MailFile.Handle = GetCurrent[data];      TextSW.SetSource[        data.tocSW, data.tocSource, MR.TOCPosition[mf, newFirstToc]];      Window.ValidateTree[data.toolW];      FreeMailFile[data, mf];      END;    Post[IF ok THEN "done"L ELSE ""L];    END;  CreateNewWindow: PROCEDURE [data: Data, why: MR.SendReason] =    BEGIN    IF why = answer AND data.currentDisplayed = nullMessage THEN {      Post["No current message."L]; GOTO failed};    SELECT why FROM      answer =>        BEGIN        emptyMessage: STRING = "\n«Message»\n"L;        error: BOOLEAN;        errorCode: MailParse.ErrorCode;        --errorPos: CARDINAL;        handle: Stream.Handle ¬ NIL;        mf: MailFile.Handle = GetCurrent[data];        piece: MailFile.StreamPiece;        userName: NSName.Name;        NodeBody: TYPE = RECORD[SEQUENCE COMPUTED CARDINAL OF WORD];        FreePages: PROCEDURE [p: LONG POINTER] = {zone.FREE[@p]};        GetChar: PROCEDURE [index: CARDINAL] RETURNS [CHARACTER] = {          piece.stream.SetPosition[index + piece.first];          RETURN[piece.stream.GetChar[]]};        GetCreds: PROCEDURE [name, password: LONG STRING] =          BEGIN userName ¬ NSName.NameFromString[zone, STR[name]]; END;        GetPages: PROCEDURE [pages: CARDINAL] RETURNS [LONG POINTER] = {          RETURN[zone.NEW[NodeBody[pages * Environment.wordsPerPage]]]};        PutBlock: PROCEDURE [line: Environment.Block] = {          IF handle = NIL THEN            handle ¬ MailSend.CreateSendWindow[              clientSuppliedText, data.needReplyTo];          handle.PutBlock[line]};        piece ¬ MailFile.Message[mf, data.currentDisplayed];        Profile.GetUser[GetCreds, clearinghouse];        [error, errorCode] ¬ MailParse.MakeAnswerHeader[          GetChar, CARDINAL[piece.lastPlusOne - piece.first], PutBlock, GetPages,          FreePages, userName];        FreeMailFile[data, mf];        NSName.FreeName[zone, userName];        IF error THEN          BEGIN          message: STRING = [60];          MailParse.StringForErrorCode[errorCode, message];          Post["Can't parse message: "L, FALSE, FALSE];          Post[message, FALSE, TRUE]          --Post[" at character "L, FALSE, FALSE];          --message.length ¬ 0;          --String.AppendDecimal[message, errorPos];          --Post[message, TRUE, TRUE]          END        ELSE          BEGIN          handle.PutString[            IF data # NIL AND data.answerForm # NIL THEN data.answerForm            ELSE emptyMessage];          handle.Delete[];          END;        END;      forward => {        dashes: STRING =          "\n----------------------------------------------------------------\n"L;        noneToForward: BOOLEAN ¬ TRUE;        handle: Stream.Handle ¬ NIL;        MakeSureIsOne: MailFile.Enumerator = {noneToForward ¬ FALSE; RETURN[TRUE]};        PutMessageIntoNewMessage: MailFile.Enumerator = {          p: MailFile.StreamPiece = MailFile.Message[mf, msg];          handle.PutString[dashes];          p.stream.SetPosition[p.first];          [] ¬ MStream.Copy[            from: p.stream, to: handle, bytes: p.lastPlusOne - p.first];          RETURN[FALSE]};        mf: MailFile.Handle = GetCurrent[data];        EnumerateMessages[mf, forward, data, MakeSureIsOne];        IF noneToForward THEN {          FreeMailFile[data, mf];          Post[s: "No undeleted messages selected."L, error: TRUE];          GOTO failed};        handle ¬ MailSend.CreateSendWindow[forwardHeader, data.needReplyTo];        EnumerateMessages[mf, forward, data, PutMessageIntoNewMessage];        FreeMailFile[data, mf];        handle.PutString[dashes];        handle.Delete[]};      newForm => [] ¬ MailSend.CreateSendWindow[newForm, data.needReplyTo];      ENDCASE;    EXITS failed => NULL;    END;  --of CreateNewWindow  Sort: PROCEDURE [data: Data] =    BEGIN    tocOK: BOOLEAN;    newDisplayed: MsgNumber;    mf: MailFile.Handle = GetCurrent[data];    MailFile.MakeWritable[mf];    [tocOK, newDisplayed] ¬ MailFile.Sort[mf, data.currentDisplayed];    ForceOut[data, mf, mandatory];    IF ~tocOK THEN {      newFirst: MsgNumber = FirstTOCMessage[mf, data.tocLines];      data.currentDisplayed ¬ newDisplayed;      TextSW.SetSource[data.tocSW, data.tocSource, MR.TOCPosition[mf, newFirst]];      data.newMessage ¬ nullMessage;      Window.Validate[data.tocSW]};    FreeMailFile[data, mf];    END;  Delete: PROCEDURE [data: Data, delete: BOOLEAN] =    BEGIN    DeleteMsg: MailFile.Enumerator = {      MR.MarkMessage[mf, msg, data, IF delete THEN deleted ELSE undeleted];      RETURN[FALSE]};    mf: MailFile.Handle = GetCurrent[data];    EnumerateMessages[mf, IF delete THEN delete ELSE undelete, data, DeleteMsg];    ForceOut[data, mf, ifConvenient];    FreeMailFile[data, mf];    END;  --of Delete  SetSourceFromPiece: PROCEDURE [    source: TextSource.Handle, piece: MailFile.StreamPiece] = {    StreamSource.Set[      source, [      stream: piece.stream, offset: piece.first, eof: piece.lastPlusOne]]};  Display: PROCEDURE [data: Data, complainIfNoneLeft: BOOLEAN] =    BEGIN    mf: MailFile.Handle = GetCurrent[data];    nMessages: CARDINAL = MailFile.Messages[mf];    position: LONG CARDINAL;    top: ProfileExtra.SetPositionBalanceBeamChoice ¬ top;    tryNewCurrent: MsgNumber ¬ data.currentDisplayed;    BEGIN -- scope for EXITS    IF nMessages < 1 THEN {Post["No messages in file"L]; GOTO failed};    IF data.firstSelect >= nMessages THEN GOTO failed;    IF data.firstSelect = data.currentDisplayed THEN {      lastPos: LONG CARDINAL ¬ data.tocSource.GetLength[] - 1;      canSee: BOOLEAN = TextSW.PositionIsVisible[        data.tocSW, MR.TOCPosition[mf, data.currentDisplayed]];      DO        IF tryNewCurrent >= nMessages - 1 THEN {          FreeMailFile[data, mf];          IF complainIfNoneLeft THEN {            Post["No more undeleted messages"L]; GOTO failed};          RETURN};        tryNewCurrent ¬ tryNewCurrent + 1;        IF canSee AND ~TextSW.PositionIsVisible[data.tocSW, lastPos] THEN          TextSWExtraExtra.SetPositionWithOverRide[            data.tocSW, TextSW.GetPosition[data.tocSW, 1], top];        IF ~MailFile.GetMsgAttributes[h: mf, msg: tryNewCurrent].attributes[          deleted] THEN EXIT;        ENDLOOP;      IF data.selectInTocWindow THEN Selection.Clear[];      MR.MarkMessage[mf, tryNewCurrent, data, current]}    ELSE MR.MarkMessage[mf, data.firstSelect, data, current];    position ¬ MR.TOCPosition[mf, data.currentDisplayed] + 2;    IF ~TextSW.PositionIsVisible[data.tocSW, position] THEN      TextSWExtraExtra.SetPositionWithOverRide[data.tocSW, position, top];    MR.MarkMessage[mf, data.currentDisplayed, data, seen];    SetSourceFromPiece[      data.bodySource, MailFile.Message[mf, data.currentDisplayed]];    TextSW.SetSource[data.bodySW, data.bodySource];    Window.Validate[data.bodySW];    ForceOut[data, mf, ifConvenient];    FreeMailFile[data, mf];    EXITS failed => FreeMailFile[data, mf];    END; -- scope for EXITS    END;  EnumerateMessages: PROCEDURE [    mf: MailFile.Handle, why: MR.Operation, data: Data,    proc: MailFile.Enumerator] =    BEGIN    mask, filter: MailFile.Attributes ¬ ALL[FALSE];    IF MailFile.Messages[mf] < 1 THEN {      Post[s: "No messages in file"L, error: TRUE]; RETURN};    IF data.firstSelect = nullMessage THEN RETURN;    SELECT why FROM      none => NULL;      move, delete, forward => {mask[deleted] ¬ TRUE; filter[deleted] ¬ FALSE};      undelete => {mask[deleted] ¬ TRUE; filter[deleted] ¬ TRUE};      ENDCASE;    MailFile.Enumerate[mf, data.firstSelect, data.lastSelect, proc, mask, filter];    END;  RemoveAttachments: PROCEDURE [    data: Data, mf: MailFile.Handle, op: MailReadOps.RiddanceOps] =    -- Remove attachments for those messages marked as deleted.  If    --   the attachments are successfully removed from the Mail    --   Service(s), then the messages in the mail file are marked    --   as no longer having attachments.  MailFile.Expunge will not    --   expunge deleted messages which are marked as still having    --   attachments.    BEGIN    anotherBlock: BOOLEAN ¬ FALSE;    blockSize: CARDINAL = 50;    length: CARDINAL ¬ 0;    firstMessage: MailFile.MsgNumber ¬ 0;    mask: MailFile.Attributes ¬ ALL[FALSE];    attachmentIDs: ARRAY [0..blockSize) OF MailTransfer.AttachmentID;    messageNumbers: ARRAY [0..blockSize) OF MailFile.MsgNumber;    Cleanup: PROCEDURE =      BEGIN      FOR i: CARDINAL IN [0..length) DO        MailTransfer.FreeAttachmentID[zone, attachmentIDs[i]]; ENDLOOP;      END;    GetAttachmentIDsAndMessageNumbers: MailFile.Enumerator =      BEGIN      IF length = blockSize - 1 THEN        BEGIN        anotherBlock ¬ TRUE;        firstMessage ¬ msg;        RETURN[TRUE];  -- Stop enumeration        END;      messageNumbers[length] ¬ msg;      attachmentIDs[length] ¬ ParseForAttachmentID[mf, msg];      length ¬ length + 1;      RETURN[FALSE];      END;    BEGIN    ENABLE UNWIND => Cleanup[];    DO      SELECT op FROM        expunge => {          mask[deleted] ¬ TRUE;          mask[attachments] ¬ TRUE;          MailFile.Enumerate[            h: mf, enumerator: GetAttachmentIDsAndMessageNumbers, mask: mask,            filter: mask, from: firstMessage, to: MailFile.Messages[mf]];          IF length = 0 THEN EXIT};        move => {          mask[attachments] ¬ TRUE;          MailFile.Enumerate[            h: mf, enumerator: GetAttachmentIDsAndMessageNumbers, mask: mask,            filter: mask, from: data.firstSelect, to: data.lastSelect];          IF length = 0 THEN {Post["Problem deleting attachment"L]; EXIT}};        ENDCASE => EXIT;      IF NOT MailTransfer.DeleteAttachments[        data.rHandle, DESCRIPTOR[BASE[attachmentIDs], length], Post].deleted THEN        Post["Problem deleting attachment"L];      FOR i: CARDINAL IN [0..length) DO        MR.MarkMessage[mf, messageNumbers[i], data, noAttachments]; ENDLOOP;      IF NOT anotherBlock THEN EXIT;      anotherBlock ¬ FALSE;      length ¬ 0;      ENDLOOP;    END;  -- ENABLE UNWIND    Cleanup[];    END;  MaybeExpunge: PROCEDURE [mf: MailFile.Handle] RETURNS [expunged: BOOLEAN] =    BEGIN    -- Note: Attempting to call RemoveAttachments from here caused both address    --   faults in Context and monitor lock problems in TextSWs.  I give up;    --   you can take a shot at it if you really want to.    oneToDelete: BOOLEAN ¬ FALSE;    CheckForDeletedWithNoAttachments: MailFile.Enumerator = {      RETURN[oneToDelete ¬ TRUE]};    filter, mask: MailFile.Attributes ¬ ALL[FALSE];    mask[deleted] ¬ TRUE;    mask[attachments] ¬ TRUE;    filter[deleted] ¬ TRUE;    MailFile.Enumerate[      h: mf, enumerator: CheckForDeletedWithNoAttachments, mask: mask,      filter: filter, from: 0, to: MailFile.Messages[mf]];    IF oneToDelete THEN {      MailFile.MakeWritable[mf ! MailFile.Error => GOTO no];      MailFile.Expunge[mf];      EXITS no => NULL};    MailFile.MakeReadOnly[mf];    RETURN[oneToDelete];    END;  ParseForAttachmentID: PROCEDURE [mf: MailFile.Handle, msg: MailFile.MsgNumber]    RETURNS [attachmentID: MailTransfer.AttachmentID ¬ NIL] =    -- Largely copied from PROC NSMailFileImplB$ParseHeader.    BEGIN    ENABLE MailParse.Error => CONTINUE;    fieldName: STRING = [40];    found: BOOLEAN ¬ FALSE;    attachmentIDString: STRING ¬ [MailTransfer.maxAttachmentIDStringLength];    piece: MailFile.StreamPiece ¬ MailFile.Message[mf, msg];    nextPos: LONG CARDINAL ¬ piece.first;    Next: PROC RETURNS [c: CHARACTER] =      BEGIN      IF nextPos >= piece.lastPlusOne THEN c ¬ MailParse.endOfInput      ELSE {        c ¬ piece.stream.GetChar[          ! Stream.EndOfStream => {c ¬ MailParse.endOfInput; CONTINUE}];        nextPos ¬ nextPos + 1};      END;    mp: MailParse.Handle = MailParse.Initialize[Next];    BEGIN    ENABLE UNWIND => MailParse.Finalize[mp];    piece.stream.SetPosition[piece.first];    WHILE MailParse.GetFieldName[mp, fieldName] DO      IF String.Equivalent[fieldName, "Attachment-ID"L] THEN        BEGIN        [] ¬ MailParse.GetFieldBody[mp, attachmentIDString];        found ¬ TRUE;        EXIT;        END      ELSE {dummy: STRING = [0]; [] ¬ MailParse.GetFieldBody[mp, dummy]};      ENDLOOP;    IF found THEN      attachmentID ¬ MailTransfer.AttachmentIDFromString[        zone, STR[attachmentIDString]];    END;  -- ENABLE UNWIND    MailParse.Finalize[mp];    END;  Expunge: MR.BackgroundProc = {    ENABLE UNWIND => NULL;    expunged: BOOLEAN ¬ FALSE;    hadError: BOOLEAN ¬ FALSE;    errorCode: MailFile.ErrorCode;    expunge: Supervisor.SubsystemHandle = Supervisor.CreateSubsystem[Expunging];    DoTheExpunge: PROC = {      oldLength: LONG INTEGER = data.tocSource.GetLength[];      expunged ¬ MaybeExpunge[mf];      IF expunged THEN data.nilToc ¬ TRUE;      };    mf: MailFile.Handle = GetCurrent[data];    MailFile.MakeWritable[mf];    MR.MarkMessage[mf, nullMessage, data, current];    StreamSource.Set[data.bodySource, [NIL, 0, 0]];    TextSW.SetSource[data.bodySW, data.bodySource, 0, TRUE];    Window.Validate[data.bodySW];  -- work around to fix up the line table     RemoveAttachments[data, mf, expunge];    Supervisor.AddDependency[client: expunge, implementor: Event.aboutToSwap];    TextSW.SetSource[data.tocSW, scratch];    DisplaySW[data.tocSW];    expunged ¬ MaybeExpunge[mf!      MailFile.Error => {errorCode ¬ code; hadError ¬ TRUE; CONTINUE}];    IF expunged THEN data.nilToc ¬ TRUE;    TextSW.SetSource[data.tocSW, data.tocSource];    DisplaySW[data.tocSW];    Supervisor.RemoveDependency[client: expunge, implementor: Event.aboutToSwap];    Supervisor.DeleteSubsystem[expunge];    IF expunged THEN {      data.nilToc ¬ FALSE; newFirstTOC ¬ FirstTOCMessage[mf, data.tocLines]}    ELSE newFirstTOC ¬ nullMessage;    IF hadError THEN PrintError[errorCode];    FreeMailFile[data, mf]};  DisplaySW:  PROCEDURE[window: Window.Handle] =    BEGIN    oldBox: Window.Box;    oldBox ¬ window.GetBox[];    TextSW.Adjust[window, [[0,0], [30, 60]], after];    TextSW.Adjust[window, oldBox, after];    window.InvalidateBox[[place: [0,0], dims: oldBox.dims]];    TextSW.SetPosition[window, 0];    Window.Validate[window];    END;      FirstTOCMessage: PUBLIC PROCEDURE [mf: MailFile.Handle, lines: CARDINAL]    RETURNS [MsgNumber] = {RETURN[MAX[MailFile.Messages[mf] + 1, lines] - lines]};  FillInMessageRange: PUBLIC PROCEDURE [data: Data, display: BOOLEAN]    RETURNS [okay: BOOLEAN ¬ TRUE] =    BEGIN    window: Window.Handle ¬ Selection.Convert[subwindow];    mf: MailFile.Handle = GetCurrent[data];    left, right: LONG CARDINAL ¬ 0;    IF window = data.tocSW THEN [left, right] ¬ TextSW.GetSelection[window];    IF right # 0 THEN {      last: MsgNumber = MailFile.Messages[mf];      IF left < right THEN right ¬ right - 1;      data.firstSelect ¬ MR.TOCPositionToMsg[mf, left];      data.lastSelect ¬ MR.TOCPositionToMsg[mf, right];      IF data.lastSelect > data.firstSelect AND data.lastSelect = last THEN        data.lastSelect ¬ data.lastSelect - 1;      data.selectInTocWindow ¬ TRUE}    ELSE {      data.selectInTocWindow ¬ FALSE;      data.firstSelect ¬ data.lastSelect ¬ data.currentDisplayed;      IF display THEN {        SELECT TRUE FROM          data.newMessage # nullMessage =>            data.firstSelect ¬ data.lastSelect ¬ data.newMessage;          data.firstSelect = nullMessage => data.firstSelect ¬ data.lastSelect ¬ 0;          ENDCASE}      ELSE        IF data.currentDisplayed = nullMessage THEN {          Post["No current message"L]; okay ¬ FALSE}};    data.newMessage ¬ nullMessage;    FreeMailFile[data, mf];    END;  MaybeDisplay: PUBLIC PROCEDURE [data: Data] = {    mf: MailFile.Handle = GetCurrent[data];    IF data.autoDisplay AND data.firstSelect = data.lastSelect      AND data.firstSelect = data.currentDisplayed      AND data.currentDisplayed < MailFile.Messages[mf] - 1 THEN      Display[data, FALSE];    FreeMailFile[data, mf]};  MoveMessage: PUBLIC PROCEDURE [data: Data] RETURNS [movedOne: BOOLEAN ¬ FALSE] =    BEGIN    atLeastOne, confirmed, hasAttachments: BOOLEAN ¬ FALSE;    filter, mask: MailFile.Attributes ¬ ALL[FALSE];    CheckForOne: MailFile.Enumerator = {RETURN[atLeastOne ¬ TRUE]};    CheckForAttachments: MailFile.Enumerator =      BEGIN hasAttachments ¬ TRUE; RETURN[ --stop:-- TRUE]; END;    MoveAMsg: MailFile.Enumerator =      BEGIN      piece: MailFile.StreamPiece = MailFile.Message[mf, msg];      bytes: CARDINAL = CARDINAL[piece.lastPlusOne - piece.first];      attr: MailFile.Attributes;      flag: CHARACTER;      [attr, flag] ¬ MailFile.GetMsgAttributes[mf, msg];      piece.stream.SetPosition[piece.first];      MailFile.StartAnotherMessage[        stream: moveToStream, length: bytes, attachments: FALSE,        examined: attr[examined], flag: flag];      [] ¬ MStream.Copy[from: piece.stream, to: moveToStream, bytes: bytes];      MR.MarkMessage[mf, msg, data, moved];      movedOne ¬ TRUE;      RETURN[FALSE]      END;    mf: MailFile.Handle;    moveToStream: Stream.Handle ¬ NIL;    moveToHandle: MailFile.Handle ¬ NIL;    IF data.moveToFileName = NIL THEN      BEGIN Post["No file name given"L]; RETURN; END;    mf ¬ GetCurrent[data];    BEGIN  -- for exit to allow free of mf    AddExtensionIfNeeded[      @data.moveToFileName, MailReadOps.mailFileExtension, data.formSW, Commands.moveTo.ORD];    EnumerateMessages[mf, move, data, CheckForOne];    IF ~atLeastOne THEN {Post["No undeleted messages selected."L]; GOTO noGood};    mask[attachments] ¬ TRUE;    filter[attachments] ¬ TRUE;    MailFile.Enumerate[      mf, data.firstSelect, data.lastSelect, CheckForAttachments, mask, filter];    IF hasAttachments THEN {      Post["Deleting attachments [Confirm] "L, FALSE, TRUE];      Cursor.Set[mouseRed];      confirmed ¬ UserInput.WaitForConfirmation[].okay;      Post["... "L, FALSE];      Cursor.Set[textPointer];      IF confirmed THEN RemoveAttachments[data, mf, move] ELSE GOTO noGood};    moveToHandle ¬ GetMailFile[data, data.moveToFileName, FALSE, TRUE];    IF moveToHandle = NIL THEN {      makeIt: BOOLEAN;      Cursor.Set[mouseRed];      Post[data.moveToFileName, FALSE];      Post[": new file. [Confirm]"L];      makeIt ¬ UserInput.WaitForConfirmation[].okay;      Cursor.Set[textPointer];      IF ~makeIt THEN GOTO noGood};    IF moveToHandle = mf THEN {      Post["Attempting to move to current file."L]; GOTO noGood};    IF moveToHandle = NIL THEN      moveToHandle ¬ GetMailFile[        data: data, name: data.moveToFileName, createIt: TRUE];    IF moveToHandle = NIL THEN GOTO noGood;    EXITS      noGood => {        IF moveToHandle # NIL THEN FreeMailFile[data, moveToHandle];        FreeMailFile[data, mf];        RETURN[FALSE]};    END;  -- EXITable block    MailFile.MakeWritable[moveToHandle];    moveToStream ¬ MailFile.AddMessages[moveToHandle];    EnumerateMessages[mf, move, data, MoveAMsg];    moveToStream.Delete[];    ForceOut[data, mf, ifConvenient];    FreeMailFile[data, mf];    MailFile.MakeReadOnly[moveToHandle];    FreeMailFile[data, moveToHandle];    END;  RetrieveNewMail: MR.BackgroundProc = {    firstRetrievedMsg, messageAtTop: MsgNumber ¬ nullMessage;    mailFileError: BOOLEAN ¬ FALSE;    mailFileErrorCode: MailFile.ErrorCode;    mf: MailFile.Handle = GetCurrent[data];    msgStream: Stream.Handle;    transferError: BOOLEAN ¬ FALSE;    oldPosition: LONG CARDINAL;    slot: HeraldWindow.Slot ¬ NIL;    AddMessage: MailTransfer.AddProc =      BEGIN      IF firstRetrievedMsg = nullMessage THEN MailFile.MakeWritable[mf];  -- to avoid deadlock      IF firstRetrievedMsg = nullMessage THEN {	msgStream ¬ MailFile.AddMessages[mf];	firstRetrievedMsg ¬ MailFile.Messages[mf]};      SELECT why FROM	first => {	  MailFile.StartAnotherMessage[	    stream: msgStream, length: messageLength, 	    attachments: attachment, examined: FALSE, flag: Ascii.SP];	  msgStream.PutBlock[block];	  IF slot # NIL THEN slot.SetCursorState[invert];	  };	continuing => msgStream.PutBlock[block];	done => msgStream.SendNow[];	ENDCASE => --EXHAUSTED-- ERROR;      RETURN[UserInput.UserAbort[data.toolW]];      END;    NoteErrorAndPost: MailTransfer.PostProc =      BEGIN IF error THEN transferError ¬ TRUE; Post[s, eol, error]; END;    data.doingRetrieve ¬ TRUE;    oldPosition ¬ TextSW.GetPosition[data.tocSW, 1];    TextSW.SetSource[data.tocSW, scratch];    DisplaySW[data.tocSW];    TextSW.SetSource[data.bodySW, scratch];    DisplaySW[data.bodySW];    slot ¬ HeraldWindow.GetCursorSlot[];    IF slot # NIL THEN slot.SetCursor[ftpBoxes];    MailTransfer.Retrieve[      handle: data.rHandle, add: AddMessage, post: NoteErrorAndPost,       flushRemote: data.flushRemote, getEnvelope: data.showEnvelope,      allAttachments: data.allAttachments !      MailFile.Error => {        mailFileErrorCode ¬ code; mailFileError ¬ TRUE; CONTINUE};      UNWIND => IF slot # NIL THEN slot ¬ slot.FreeCursorSlot[]];    IF slot # NIL THEN slot ¬ slot.FreeCursorSlot[];    data.doingRetrieve ¬ FALSE;    IF firstRetrievedMsg # nullMessage THEN      BEGIN      msgStream.Delete[];      messageAtTop ¬ MIN[firstRetrievedMsg, FirstTOCMessage[mf, data.tocLines]];      IF messageAtTop > 0 THEN messageAtTop ¬ messageAtTop - 1;      data.newMessage ¬ firstRetrievedMsg;      END;    normalFinish ¬ ~(mailFileError OR firstRetrievedMsg = nullMessage);    IF ~normalFinish THEN {      messageAtTop ¬ MR.TOCPositionToMsg[mf, oldPosition];      normalFinish ¬ TRUE;      };    IF mailFileError THEN PrintError[mailFileErrorCode];    IF Runtime.IsBound[LOOPHOLE[MailFilterUI.GetFilters]] THEN      BEGIN      FilterNewMessages[data, mf];      MailFile.WaitForUpdates[];      END;    ForceOut[data, mf, mandatory];    FreeMailFile[data, mf];    TextSW.SetSource[data.bodySW, data.bodySource, 0, FALSE];    DisplaySW[data.bodySW];    TextSW.SetSource[data.tocSW, data.tocSource, 0, FALSE];    RETURN[messageAtTop, normalFinish]};    filterFieldBody: LONG STRING ¬ zone.NEW[StringBody[1024]];    FilterNewMessages: PROCEDURE [data: Data, mf: MailFile.Handle] =    BEGIN    headerData: MailFile.HeaderData ¬ NIL;    mask: MailFile.Attributes ¬ ALL[FALSE];    slot: HeraldWindow.Slot ¬ NIL;    cursor: UserTerminal.CursorArray ¬ [      000000B, 000000B, 000000B, 162000B, 102000B, 112000B,       102400B, 163646B, 112524B, 112564B, 112504B, 112464B,       000000B, 000000B, 000000B, 000000B];    CallBack: MailFile.Enumerator =      BEGIN      MailFile.FilterOne[mf, msg, headerData, filterFieldBody];      IF slot # NIL THEN slot.SetCursorState[invert];      RETURN [--stop:-- FALSE];      END;    Cleanup: PROCEDURE =      BEGIN      MailFile.FreeHeaderData[headerData];      IF slot # NIL THEN slot ¬ slot.FreeCursorSlot[];      END;    BEGIN ENABLE UNWIND => Cleanup[];    slot ¬ HeraldWindow.GetCursorSlot[];    IF slot # NIL THEN slot.StoreCursor[@cursor];    headerData ¬ MailFile.CreateHeaderData[];    MailFile.Enumerate[h: mf, enumerator: CallBack, mask: mask,      filter: mask, from: data.newMessage, to: MailFile.Messages[mf]];    END;  -- ENABLE UNWIND    Cleanup[];    END;  GetMailFile: PUBLIC PROCEDURE [    data: Data, name: LONG STRING, createIt: BOOLEAN, noWarn: BOOLEAN ¬ FALSE]    RETURNS [h: MailFile.Handle] =    BEGIN    file: MFile.Handle ¬ NIL;    index: CARDINAL ¬ LAST[CARDINAL];    file ¬ MFile.Acquire[name, anchor, [], TRUE ! MFile.Error => CONTINUE];    IF file # NIL THEN index ¬ AlreadyHaveFile[data, file];    IF index = LAST[CARDINAL] THEN {      <<      userName: LONG STRING ¬ [BodyDefs.maxRNameLength];      userReg: LONG STRING ¬ [BodyDefs.maxRNameLength];      GetUser: PROCEDURE [name, password: LONG STRING] = {        String.Copy[from: name, to: userName]};      GetReg: PROCEDURE [r: LONG STRING] = {String.Copy[from: r, to: userReg]};>>      temp: MailFile.Handle ¬ NIL;      <<      Profile.GetUser[GetUser, none];      Profile.GetDefaultRegistry[GetReg];>>      temp ¬ MailFile.Create[        fileName: name, createIt: createIt, letGo: ReleaseFile, data: data !        MailFile.Error => {          IF code = fileNotFound AND noWarn THEN GOTO nope;          Post[name, FALSE];          Post[            SELECT code FROM              fileNotFound => ": illegal name or no such mail file"L,              fileHasBadFormat => ": format failure for message "L,              fileBusy => ": file is busy"L,              ENDCASE => ": unknown error"L, FALSE];          IF code = fileHasBadFormat THEN {            str: STRING = [40];            String.AppendDecimal[str, message + 1];            String.AppendString[str, " at character position "L];            String.AppendLongDecimal[str, position];            Post[str, FALSE]};          GOTO nope}];      [index, temp] ¬ ReplaceOldest[        data, temp ! MailFile.Error => {Post[": unknown error"L]; GOTO nope}; ];      IF temp # NIL THEN Process.Detach[FORK ReleaseOne[data, temp]];      EXITS nope => {IF file # NIL THEN MFile.Release[file]; RETURN[NIL]}};    IF file # NIL THEN MFile.Release[file];    RETURN[data.cache[index].mf]    END;  AlreadyHaveFile: ENTRY PROCEDURE [data: Data, file: MFile.Handle]    RETURNS [CARDINAL] = {    ENABLE UNWIND => NULL;    IF file # NIL THEN      FOR index: CARDINAL IN [0..MR.cacheSize) DO        IF data.cache[index].file # NIL          AND MFile.SameFile[file, data.cache[index].file] THEN {          data.cache[index].refCount ¬ data.cache[index].refCount + 1;          data.cache[index].useTime ¬ Now[];          RETURN[index]};        ENDLOOP;    RETURN[LAST[CARDINAL]]};  Now: PROCEDURE RETURNS [LONG CARDINAL] = {    RETURN[System.SecondsSinceEpoch[System.GetGreenwichMeanTime[]]]};  ReplaceOldest: ENTRY PROCEDURE [data: Data, new: MailFile.Handle]    RETURNS [oldest: CARDINAL, old: MailFile.Handle] = {    ENABLE UNWIND => NULL;    oldTime: LONG CARDINAL ¬ Now[];    foundOne: BOOLEAN ¬ FALSE;    FOR index: CARDINAL IN [0..MR.cacheSize) DO      IF data.cache[index].refCount > 0 THEN LOOP;      foundOne ¬ TRUE;      IF data.cache[index].mf = NIL THEN {oldest ¬ index; EXIT};      IF data.cache[index].useTime < oldTime THEN oldest ¬ index;      ENDLOOP;    IF ~foundOne THEN ERROR MailFile.Error[other, 0, 0];    old ¬ data.cache[oldest].mf;    data.cache[oldest] ¬ [      useTime: Now[], refCount: 1, file: MailFile.File[new], mf: new]};  FreeMailFile: PUBLIC ENTRY PROCEDURE [data: Data, mf: MailFile.Handle] = {    IF mf = NIL THEN RETURN;    FOR i: NATURAL IN [0..MR.cacheSize) DO      IF data.cache[i].mf = mf THEN {        IF data.cache[i].refCount > 0 THEN          data.cache[i].refCount ¬ data.cache[i].refCount - 1;        EXIT};      ENDLOOP};  GetCurrent: PUBLIC ENTRY PROCEDURE [data: Data] RETURNS [MailFile.Handle] = {    FOR i: NATURAL IN [0..MR.cacheSize) DO      IF data.cache[i].current THEN {        data.cache[i].refCount ¬ data.cache[i].refCount + 1;        data.cache[i].useTime ¬ Now[];        RETURN[data.cache[i].mf]};      ENDLOOP;    RETURN[NIL]};  NewCurrent: PUBLIC ENTRY PROCEDURE [data: Data, mf: MailFile.Handle] = {    ENABLE UNWIND => NULL;    FOR i: NATURAL IN [0..MR.cacheSize) DO      IF data.cache[i].current THEN {        data.cache[i].current ¬ FALSE;        data.cache[i].refCount ¬ data.cache[i].refCount - 1;        [] ¬ MaybeExpunge[data.cache[i].mf];        EXIT};      ENDLOOP;    FOR i: NATURAL IN [0..MR.cacheSize) DO      IF data.cache[i].mf = mf THEN {        data.cache[i].current ¬ TRUE;        data.cache[i].refCount ¬ data.cache[i].refCount + 1;        EXIT};      ENDLOOP};  HaveCurrent: PUBLIC ENTRY PROCEDURE [data: Data] RETURNS [BOOLEAN] = {    FOR i: NATURAL IN [0..MR.cacheSize) DO      IF data.cache[i].current THEN RETURN[data.cache[i].mf # NIL]; ENDLOOP;    RETURN[FALSE]};  ReleaseFile: ENTRY MailFile.LetGo = {    hisData: Data = clientData;    IF data = NIL THEN RETURN[later];  -- reference global, not parameter    IF hisData # data THEN RETURN[no];  -- how did this happen?    FOR mf: CARDINAL IN [0..MR.cacheSize) DO      IF handle = hisData.cache[mf].mf THEN {        IF hisData.cache[mf].refCount > 0 THEN RETURN[no];        hisData.cache[mf] ¬ [];        RETURN[goAhead]};      ENDLOOP;    RETURN[later]};  ForceOut: PUBLIC PROC [data: Data, mf: MailFile.Handle, reason: MR.ForceReason] =    BEGIN    IF reason = didSomething THEN data.forceCount ¬ data.forceCount + 1;    IF reason = mandatory OR reason = ifConvenient AND data.forceCount > 10      OR reason = didSomething AND data.forceCount > 100 THEN {      MailFile.ForceOut[mf]; data.forceCount ¬ 0};    END;      Unload: MailUtil.UnloadProc = {scratch.ActOn[destroy]};      MailUtil.RegisterUnloadProc[Unload, NIL];  END.    «  log:       NS  14-Jan-85 10:57:40 changed bullets to Eurpean quotes for character set 0     NS  2-May-85 16:34:07 fixed error in changing mail files => caught an error         in  GetMailFile from ReplaceOldest and added a CONTINUE to Next after          the StringBoundsFault     NS  6-Aug-85 15:49:34 moved Supervisor stuff from DoTheExpunge to fix          monitor locking bug;  placed it on down.      NS  17-Dec-85 11:29:15  removed deadlocking in Retrieve     »
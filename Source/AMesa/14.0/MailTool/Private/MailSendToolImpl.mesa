-- File: MailSendToolImpl.mesa - edited by -- AlHall	 	  9-Aug-84 14:15:17-- Wobber	 	 27-Dec-83 14:10:24-- Brenda Hankins 	 11-Nov-83 17:20:36-- NS      	          3-Oct-85 15:14:26-- taken from MailSendImpl of Oct 7, 1983 on 25-Oct-83 11:01:55DIRECTORY  Ascii USING [CR],  AsciiSink USING [Create],  CmFile USING [    Close, Error, FindSection, Handle, NextValue, TableError, UserDotCmLine,    UserDotCmOpen],  Context USING [Create, Find, Type, UniqueType],  Cursor USING [Set, Type],  Environment USING [Block, Byte],  Event USING [Handle, Object, primaryCredentials, StartingProcess, tajoDefaults, toolWindow],  EventTypes USING [deactivate, primaryCredentials, domain, organization],  Exec USING [AddCommand, ExecProc,    FreeTokenString, GetToken, Handle, Object, OutputProc, PutChar,    RemoveCommand],  FormSW USING [AllocateItemDescriptor, BooleanItem, ClientItemsProcType,    CommandItem, Display, Enumerated, EnumeratedItem, EnumeratedNotifyProcType,    FreeHintsProcType, ItemHandle, MenuProcType,    NeededHeight, newLine, nextPlace, Options, ProcType, SetModifyNotificationProc,    StringItem, TagOnlyItem, ToggleFlag, ToggleVisibility],  Heap USING [Create, Delete, systemZone],  MailPost USING [AttachmentTypeMenuProc, GetUserLocalName,    Handle, Object, PostMessage, SendAs,    SetUserNameAndPassword, Showing],  MFile USING [Error, Handle, ReadOnly, Release],  MailReadOps USING [CreateData, Data, data],  MailSend USING [Reason, ReplyToFlag],		-- export  MailUtil,  MStream USING [Error, GetLength, ReadOnly, ShareBlock, WriteOnly],  NSString USING [String, StringFromMesaString],  Process USING [Detach],  Put USING [CR, Line, Text],  Runtime USING [IsBound, StartFault],  ScratchSource USING [Create, Info],  Scrollbar USING [Adjust], -- StartOps USING [MailUtilImpl],  Stream USING [Block, defaultObject, Delete, DeleteProcedure,    Handle, Object, PutBlock, PutProcedure],  String USING [Empty, EquivalentStrings, Length],  Supervisor USING [AddDependency, nullSubsystem,    AgentProcedure, CreateSubsystem, EnumerationAborted, RemoveDependency, SubsystemHandle],  TajoMisc USING [FindClippingWindow],  TextSource USING [ActOnProc, AsciiDoEditAction, AsciiScanText,     GetLength, GetLengthProc, Handle, Position, Procedures, ProceduresObject,    ReadTextProc, ReplaceText, ReplaceTextProc, SetLengthProc],  TextSW USING [    Create, Destroy, GetOptions, InsertChar, InsertString, Options, SetEOF, SetInsertion, SetOptions],  TextSWExtra USING [BecomeInputFocus],  Token USING [FreeTokenString, Item],  Tool USING [    AddThisSW, Create, DeleteThisSW, Destroy, MakeFormSW, MakeMsgSW, MakeSWsProc, State],  ToolDriver USING [Address, NoteSWs, RemoveSWs],  ToolFont USING [Create],  ToolOps USING [AdjustProc, bdryHeight, context, ContextHandle],  ToolWindow USING [Activate, AdjustProcType, CreateSubwindow, Deactivate, Destroy,    GetState, Handle, MakeSize, State, TransitionProcType, WindowForSubwindow],  UserInput USING [WaitForConfirmation],  Window USING [Box, GetBox, GetParent, Handle, InvalidateBox, Object,    SlideAndSize, ValidateTree],  WindowFont USING [Error, Handle];MailSendToolImpl: MONITOR	  -- monitoring 3 diff conditions, don't seem to conflict  IMPORTS    AsciiSink, CmFile, Context, Cursor, Event, Exec, FormSW, Heap,    MailPost, MailReadOps, MailUtil, MFile, MStream,     NSString, Process, Put, Runtime, ScratchSource, -- StartOps, --    Scrollbar, String, Stream, Supervisor, TajoMisc, TextSource, TextSW,    TextSWExtra, Token, Tool, ToolFont, ToolDriver, ToolOps, ToolWindow,    UserInput, Window, WindowFont  EXPORTS MailPost, MailSend =  BEGIN  CommandSWIndices: TYPE = {another, destroy, reset, sendAs,    expandPvtDLs, put, get, file, invalid, replyTo, deliver,    delivered, attachmentType, attachmentFile};    Problems: TYPE = {none, parsingError, replyToNeeded};  SendAs: TYPE = MailPost.SendAs;  Showing: TYPE = MailPost.Showing;      Handle: TYPE = MailPost.Handle;  Object: TYPE = MailPost.Object;    MailSendStream: TYPE = LONG POINTER TO MailSendStreamObject;  MailSendStreamObject: TYPE = RECORD [    stream: Stream.Object,    h: Handle,    type: MailSend.Reason];  mailSendContext: Context.Type = Context.UniqueType[];  maxFromFile: CARDINAL = LAST[CARDINAL] - 2000;    defaultSendAs: SendAs ¬ mailNote;  -- CODE: Have PROC ProcessUserCm update this.  defaultReplyTo: MailSend.ReplyToFlag ¬ stop;  font: WindowFont.Handle ¬ NIL;  inactiveList: Handle ¬ NIL;  zone: PUBLIC UNCOUNTED ZONE ¬ NIL;  unloading: BOOLEAN ¬ FALSE;  transitReason: MailSend.Reason;    -- Only way to to communicate from PROC CreateOne to PROC Transit.    abortDeactivation: Supervisor.SubsystemHandle ¬    Supervisor.CreateSubsystem[MonitorDeactivations];  updateLogin: Supervisor.SubsystemHandle ¬    Supervisor.CreateSubsystem[CheckLogin];  mySourceProcs: TextSource.ProceduresObject ¬ [    actOn: MyActOn, doEditAction: TextSource.AsciiDoEditAction,    getLength: MyGetLength, readText: MyReadText, replaceText: MyReplaceText,    scanText: TextSource.AsciiScanText, setLength: MySetLength];  PutError: PUBLIC PROCEDURE [msgSW: Window.Handle, string: LONG STRING] =    BEGIN    Put.CR[msgSW];        Put.Text[msgSW, "! "L];    Put.Text[msgSW, string];    END;  STR: PROCEDURE [s: LONG STRING] RETURNS [NSString.String] = INLINE    {RETURN [NSString.StringFromMesaString[s]]};    -- my textsource proces  MyActOn: TextSource.ActOnProc =   BEGIN    handle: Handle = LOOPHOLE[source];    IF action = destroy THEN {      WaitNotBusy[handle];      handle.scratch.actOn[handle.scratch, destroy]};    END;  MyGetLength: TextSource.GetLengthProc = {    handle: Handle = LOOPHOLE[source];      -- ASSUME: TextSource.Procedures is first field of Handle.    RETURN[handle.scratch.getLength[handle.scratch]]};  MyReadText: TextSource.ReadTextProc = {    handle: Handle = LOOPHOLE[source];    [block, next] ¬ handle.scratch.readText[      handle.scratch, position, maxLength, class]};  MySetLength: TextSource.SetLengthProc = {    handle: Handle = LOOPHOLE[source];    RETURN[handle.scratch.setLength[handle.scratch, position]]};  MyReplaceText: TextSource.ReplaceTextProc =    BEGIN    handle: Handle = LOOPHOLE[source];        IF from # to OR block.stopIndexPlusOne > block.startIndex THEN MakeDirty[handle];    [new, delta] ¬ handle.scratch.replaceText[      handle.scratch, block, from, to, deleteToTrashbin];    END;  -- and the rest of the stuff    AppendReplyTo: PUBLIC PROCEDURE [h: Handle, string: LONG STRING] =    BEGIN    cr: Environment.Byte = LOOPHOLE[Ascii.CR];    block: Environment.Block = ScratchSource.Info[h.scratch].block;    insertionPoint: LONG CARDINAL ¬ 0;        FOR i: CARDINAL IN [block.startIndex..block.stopIndexPlusOne - 1) DO      IF block.blockPointer[i] = cr AND	block.blockPointer[i + 1] = cr THEN	BEGIN	insertionPoint ¬ i + 1;	EXIT;	END;      ENDLOOP;    TextSW.SetInsertion[h.textSW, insertionPoint];    TextSW.InsertString[h.textSW, string];    TextSW.InsertChar[h.textSW, Ascii.CR];    END;    CreateSendWindow: PUBLIC PROCEDURE [    reason: MailSend.Reason, replyToFlag: MailSend.ReplyToFlag]    RETURNS [Stream.Handle] = {    RETURN[CreateOne[reason, replyToFlag, active, NIL, TRUE].stream]};  CreateOne: PROC [reason: MailSend.Reason,     replyToFlag: MailSend.ReplyToFlag, initialState: Tool.State,    recipient: LONG STRING, grabInput: BOOLEAN]    RETURNS [stream: Stream.Handle, h: Handle] =    BEGIN    mailSend: MailSendStream;        transitReason ¬ reason;      -- Allows PROC Transit to tailor the Handle slightly before MakeSWs is called.    h ¬ GetHandle[initialState];    IF h = NIL THEN 	-- nothing on the inactive list, need a new tool      BEGIN      tw: Window.Handle = Tool.Create[        makeSWsProc: MakeSWs, clientTransition: Transit,        name: "SendTool"L, cmSection: "SendTool"L, 	initialState: initialState, tinyName1: "Send"L, tinyName2: "Tool"L];      h ¬ FindHandle[tw];      IF h = NIL THEN   -- is initially inactive (else would have executed PROC Transit)        BEGIN	h ¬ zone.NEW[Object ¬ [link: NIL, 	  replyToFlag: replyToFlag, toolWindow: tw, justActivating: TRUE, procs: @mySourceProcs]];        Context.Create[mailSendContext, h, DestroyContext, h.toolWindow];	PutOnInactiveList[h];	RETURN[NIL, h]	END	-- inactive tool      END	-- new tool    ELSE 	-- got an old tool off inactive list:      BEGIN      IF initialState = inactive THEN {RETURN[NIL, h]};      END;    transitReason ¬ newForm;      -- Reset for tools which are activated via the "Inactive" menu.    h.replyToFlag ¬ replyToFlag;    h.grabInput ¬ grabInput;    SELECT reason FROM      clientSuppliedText --i.e. answer-- , forwardHeader =>         BEGIN        IF reason = forwardHeader THEN FillInForwardHeader[h];	mailSend ¬ zone.NEW[MailSendStreamObject ¬ [          h: h, stream: Stream.defaultObject, type: reason]];	mailSend.stream.put ¬ MailStreamInsert;	mailSend.stream.delete ¬ MailStreamDelete;	-- Note: h.initializing is reset within PROC MailStreamDelete.	END;      newForm =>         BEGIN	mailSend ¬ NIL;	FillInNewForm[h, recipient];	PrepTextSWForEditing[h];	h.initializing ¬ FALSE;        END;       ENDCASE => --EXHAUSTED-- ERROR;    FormSW.Display[h.commandSW];  -- Repaint after changing h.replyToFlag, etc.     RETURN[@mailSend.stream, h];    END;  MailStreamDelete: Stream.DeleteProcedure =    BEGIN    mailSend: MailSendStream ¬ LOOPHOLE[sH];        PrepTextSWForEditing[mailSend.h];    mailSend.h.initializing ¬ FALSE;    zone.FREE[@mailSend];    END;  MailStreamInsert: Stream.PutProcedure =     -- sH: Handle, block: Block, endRecord: BOOLEAN --    BEGIN    mailSend: MailSendStream ¬ LOOPHOLE[sH];    scratch: TextSource.Handle = mailSend.h.scratch;    oldLength: LONG CARDINAL ¬ scratch.GetLength[];        [] ¬ scratch.ReplaceText[block, oldLength, oldLength, FALSE];    END;  MakeTextSWEditable: PUBLIC PROCEDURE [textSW: Window.Handle] =    BEGIN    options: TextSW.Options;        options ¬ TextSW.GetOptions[textSW];    options.access ¬ edit;    TextSW.SetOptions[textSW, options];    END;    MakeTextSWReadOnly: PUBLIC PROCEDURE [textSW: Window.Handle] =    BEGIN    options: TextSW.Options;        options ¬ TextSW.GetOptions[textSW];    options.access ¬ read;    TextSW.SetOptions[textSW, options];    END;    PrepTextSWForEditing: PROCEDURE [h: Handle] =    BEGIN    TextSW.SetEOF[h.textSW, h.scratch.GetLength[]];    IF h.grabInput THEN      BEGIN      TextSW.SetInsertion[h.textSW, 0];      TextSWExtra.BecomeInputFocus[h.textSW];      END;    END;      FillInForwardHeader: PROC [h: Handle] =     BEGIN    tailoredForwardForm: LONG STRING =      GetTailoredForwardForm[GetToolData[]];        IF tailoredForwardForm # NIL      THEN FillInString[h, tailoredForwardForm]      ELSE        FillInString[h,          "Subject: «Topic»\nTo: «Recipients»\ncc: «CopiesTo»\n\n«Covering Message»\n"L];    END;  FillInNewForm: PROC [h: Handle, recipient: LONG STRING] =    BEGIN    tailoredNewForm: LONG STRING =      GetTailoredNewForm[GetToolData[]];    FillInWithUserName: PROCEDURE [name: LONG STRING] =      { IF name # NIL THEN FillInString[h, name]; };        IF tailoredNewForm # NIL THEN      BEGIN      FillInString[h, tailoredNewForm];      RETURN;      END;    FillInString[h, "Subject: «Topic»\nTo: "L];    FillInString[h: h,      s: IF String.Length[recipient] = 0 THEN "«Recipients»"L ELSE recipient];    FillInString[h, "\ncc: «CopiesTo», "L];    MailPost.GetUserLocalName[FillInWithUserName];    FillInString[h, "\n\n«Message»\n"L];    END;  FillInString: PROC [h: Handle, s: LONG STRING] =     BEGIN    scratch: TextSource.Handle = h.scratch;    oldLength: LONG CARDINAL ¬ scratch.GetLength[];    [] ¬ scratch.ReplaceText[      [LOOPHOLE[@s.text], 0, s.length], oldLength, oldLength, FALSE];    END;    GetToolData: PROCEDURE RETURNS [data: MailReadOps.Data] =    BEGIN    RETURN [      IF Runtime.IsBound[LOOPHOLE[MailReadOps.CreateData]]	THEN MailReadOps.data	ELSE NIL];    END;    GetTailoredForwardForm: PROCEDURE [data: MailReadOps.Data]    RETURNS [forwardForm: LONG STRING] =    { RETURN[IF data = NIL THEN NIL ELSE data.forwardForm]; };    GetTailoredNewForm: PROCEDURE [data: MailReadOps.Data]    RETURNS [newForm: LONG STRING] =    { RETURN[IF data = NIL THEN NIL ELSE data.newForm]; };    -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~FindHandle: PROCEDURE [window: Window.Handle] RETURNS [Handle] = {    RETURN[Context.Find[mailSendContext, window]]};PutOnInactiveList: ENTRY PROC [handle: Handle] =  BEGIN ENABLE UNWIND => NULL;  handle.link ¬ inactiveList;  inactiveList ¬ handle;  END;RemoveFromInactiveList: ENTRY PROCEDURE [handle: Handle] =    BEGIN ENABLE UNWIND => NULL;    IF handle = inactiveList THEN inactiveList ¬ handle.link    ELSE      FOR prev: Handle ¬ inactiveList, prev.link UNTIL prev = NIL DO	IF prev.link = handle THEN {prev.link ¬ handle.link; EXIT};	ENDLOOP    END;GetHandle: ENTRY PROCEDURE[initialState: Tool.State] RETURNS [handle: Handle] =    BEGIN ENABLE UNWIND => NULL;    IF inactiveList = NIL THEN RETURN[NIL];    FOR handle ¬ inactiveList, handle.link UNTIL handle = NIL DO      IF ToolWindow.GetState[handle.toolWindow] = inactive THEN {	handle.justActivating ¬ FALSE;	IF initialState = inactive THEN RETURN [handle];	ToolWindow.Activate[handle.toolWindow];	IF initialState = tiny THEN ToolWindow.MakeSize[handle.toolWindow, tiny];	RETURN [handle];        };      ENDLOOP;    END;    Destroy: PROCEDURE [handle: Handle] = {  lastOne: BOOLEAN;  lastOne ¬ (inactiveList = NIL OR inactiveList.link = NIL);  IF unloading OR ~lastOne THEN Tool.Destroy[handle.toolWindow]  ELSE [] ¬ ToolWindow.Deactivate[handle.toolWindow]};DestroyContext: PROCEDURE [handle: Handle, w: Window.Handle] =   {RemoveFromInactiveList[handle]; zone.FREE[@handle]};    ProcessUserCm: PROC = {    userCm: CmFile.Handle ¬ NIL;    fontFile: MFile.Handle ¬ NIL;    replyTo, fontName: LONG STRING ¬ NIL;    table: ARRAY [0..2) OF LONG STRING ¬ ["NeedReplyTo"L, "Font"L];    defaultReplyTo ¬ stop;    replyTo ¬ CmFile.UserDotCmLine["MailTool"L, "NeedReplyTo"L !       CmFile.Error => CONTINUE];    SetDefaultReplyTo[replyTo];    Heap.systemZone.FREE[@replyTo];    userCm ¬ CmFile.UserDotCmOpen[ ! CmFile.Error => CONTINUE];    IF userCm = NIL THEN RETURN;    IF CmFile.FindSection[userCm, "SendTool"L] THEN DO      SELECT CmFile.NextValue[userCm, DESCRIPTOR[table] !	  CmFile.TableError => RESUME] FROM	0 => {	  replyTo ¬ Token.Item[userCm];	  SetDefaultReplyTo[replyTo];	  [] ¬ Token.FreeTokenString[replyTo]};	1 => {	  fontName ¬ Token.Item[userCm];	  fontFile ¬ MFile.ReadOnly[fontName, [] ! MFile.Error => CONTINUE];	  [] ¬ Token.FreeTokenString[fontName];	  IF fontFile # NIL THEN font ¬ ToolFont.Create[fontFile !	     WindowFont.Error => {MFile.Release[fontFile]; CONTINUE}]};	ENDCASE => EXIT;      ENDLOOP;    [] ¬ CmFile.Close[userCm]};  SetDefaultReplyTo: PROC [reply: LONG STRING] =     BEGIN    IF String.Length[reply] = 0 THEN RETURN;    SELECT TRUE FROM      String.EquivalentStrings[reply, "DontSend"L] => defaultReplyTo ¬ stop;      String.EquivalentStrings[reply, "SendAnyway"L] => defaultReplyTo ¬ send;      String.EquivalentStrings[reply, "AddToForm"L] => defaultReplyTo ¬ add;      ENDCASE => defaultReplyTo ¬ stop;    END;	-- proc. SetDefaultReplyTo      MonitorDeactivations: Supervisor.AgentProcedure =    BEGIN    toolWindow: Window.Handle = eventData;    IF event = EventTypes.deactivate THEN      BEGIN      h: Handle = FindHandle[toolWindow];       IF h # NIL AND h.dirty THEN {         PutError[h.msgSW, "Delivery not finished."L];         ERROR Supervisor.EnumerationAborted};      END;    END;	-- proc. MonitorDeactivations  CheckLogin: Supervisor.AgentProcedure = {    SELECT event FROM      EventTypes.domain, EventTypes.organization,        EventTypes.primaryCredentials => MailPost.SetUserNameAndPassword[];      ENDCASE};         FormSWChanged:  FormSW.ProcType =    --sw: Window.Handle, item: FormSW.ItemHandle, index: CARDINAL    BEGIN    h: Handle = FindHandle[ToolWindow.WindowForSubwindow[sw]];        IF NOT h.initializing THEN      SELECT sw FROM	--h.commandSW => IF index = CommandSWIndices.mumble.ORD THEN MakeDirty[h];	--h.headerSW => MakeDirty[h];	ENDCASE;    --FormSW.ToggleFlag[sw, index, modified];     END;       -- tool-related procs:     AdjustBoxSize: PROC [sw: Window.Handle, bigger: BOOLEAN]= {    -- Code-copied from EditUtilImplB.mesa (Yamamoto.pa ¬ credit).    clip: Window.Handle ¬ TajoMisc.FindClippingWindow[sw];    tool: Window.Handle ¬ ToolWindow.WindowForSubwindow[sw];    tch: ToolOps.ContextHandle ¬ Context.Find[ToolOps.context,tool];    i: CARDINAL ¬ GetSWIndex[sw,tch];    topsw: Window.Handle ¬ sw;    botsw: Window.Handle ¬ tch.sws[i+1].sw;    newHeight: CARDINAL ¬ FormSW.NeededHeight[sw].min;    newTop: Window.Box ¬ topsw.GetBox[];    newBot: Window.Box ¬ botsw.GetBox[];    delta: CARDINAL;    AdjustSubwindow: PROC [      sw: Window.Handle, adjust: ToolWindow.AdjustProcType, box: Window.Box] = {      -- not optimal, but this is only used on invisible windows      hBox, vBox: Window.Box;      hScroll, vScroll: Window.Handle;      [box, vScroll, vBox, hScroll, hBox] ¬ Scrollbar.Adjust[sw, box];      IF hScroll # NIL THEN hScroll.SlideAndSize[hBox, nw];      IF vScroll # NIL THEN vScroll.SlideAndSize[vBox, nw];      adjust[sw, box, before];      sw.SlideAndSize[box, nw];      adjust[sw, box, after]};    GetSWIndex: PROC[sw: Window.Handle, tch: ToolOps.ContextHandle]       RETURNS[i: CARDINAL] = {      FOR i IN [0..tch.sws.length) DO	IF sw = tch.sws[i].sw THEN EXIT	ENDLOOP;};        IF newHeight <= ABS[newTop.dims.h] AND bigger THEN RETURN;    IF bigger THEN {        delta ¬ newHeight - newTop.dims.h;	newTop ¬ [[x:0, y: newTop.place.y], [w: tch.w, h: newHeight]];        newBot ¬ [	  [x:0, y: newBot.place.y + delta], 	  [w: tch.w, h: newBot.dims.h - delta]];	AdjustSubwindow[botsw, ToolOps.AdjustProc[tch.sws[i+1].type], newBot];	AdjustSubwindow[topsw, ToolOps.AdjustProc[tch.sws[i].type], newTop]}      ELSE {        delta ¬ newTop.dims.h - newHeight;        newTop ¬ [[0,newTop.place.y], [w: tch.w, h: newHeight]];        newBot ¬ [	  [x:0, y: newBot.place.y - delta],	  [w: tch.w, h: newBot.dims.h + delta]];	AdjustSubwindow[topsw, ToolOps.AdjustProc[tch.sws[i].type], newTop];	AdjustSubwindow[botsw, ToolOps.AdjustProc[tch.sws[i+1].type], newBot]};      tch.boxes[i] ¬ [h: newTop.dims.h, y: newTop.place.y];      tch.boxes[i + 1] ¬ [h: newBot.dims.h, y: newBot.place.y];    clip.InvalidateBox[[         place: [x: 0, y: tch.boxes[i + 1].y - ToolOps.bdryHeight],	dims: [h: ToolOps.bdryHeight, w: tch.w]], isDirty];    clip.GetParent.ValidateTree[];    };  Transit: ToolWindow.TransitionProcType =     BEGIN    h: Handle ¬ FindHandle[window];    SELECT TRUE FROM      old = inactive => 	--activating        BEGIN	IF h = NIL THEN {	  h ¬ zone.NEW[Object ¬ [link: NIL,	    justActivating: FALSE, toolWindow: window, grabInput: FALSE, 	    procs: @mySourceProcs]];	  Context.Create[mailSendContext, h, DestroyContext, h.toolWindow];	  PutOnInactiveList[h];	  };	h.dirty ¬ FALSE;	IF NOT h.justActivating THEN h.initializing ¬ TRUE;	h.sendAs ¬ defaultSendAs;	--IF transitReason = clientSuppliedText THEN h.headerSWLinesShowing ¬ 4;	IF h.justActivating THEN h.grabInput ¬ TRUE;        END;      new = inactive => 	-- deactivating        BEGIN        ToolDriver.RemoveSWs[tool: "SendTool"L];        h.dirty ¬ FALSE;	DestroyTextSW[h];        h.msgSW ¬ NIL;        h.justActivating ¬ TRUE;	--h.headerSWLinesShowing ¬ 3;	h.sendAs ¬ defaultSendAs;	h.sendAs ¬ defaultSendAs;	END;		  -- change to a Context.Destroy[mailSendContext, window]; if not last      ENDCASE;    END;	-- proc. Transit    CreateTextSW: PROCEDURE [window: Window.Handle, h: Handle] =    BEGIN    -- Note: The textSW is created using these lower-level    --   routines in order to make it removeable and re-attachable    --   (which *used* to be necessary); I've kept it this    --   way as an example, since it took so long to get    --   it right.    textOptions: TextSW.Options = [      access: edit, menu: TRUE, split: TRUE, wrap: TRUE, scrollbar: TRUE,      flushTop: TRUE, flushBottom: FALSE];        h.scratch ¬ ScratchSource.Create[];    h.textSW ¬ ToolWindow.CreateSubwindow[parent: window];    TextSW.Create[      sw: h.textSW, source: @h.procs, options: textOptions,      sink: IF font = NIL THEN NIL ELSE AsciiSink.Create[font]];    Tool.AddThisSW[window: window, sw: h.textSW];    IF h.justActivating THEN      BEGIN      FillInNewForm[h, NIL];      PrepTextSWForEditing[h];      END;    END;    DestroyTextSW: PROCEDURE [h: Handle] =    BEGIN    TextSW.Destroy[h.textSW];    Tool.DeleteThisSW[h.textSW];    ToolWindow.Destroy[h.textSW];    h.textSW ¬ NIL;    [] ¬ MyActOn[LOOPHOLE[h], destroy];    h.scratch ¬ NIL;    END;  GetFromFile: PROCEDURE [handle: Handle] =    BEGIN    length: LONG CARDINAL;    index: LONG CARDINAL ¬ 0;    from: Stream.Handle ¬ NIL;    IF String.Empty[handle.file] THEN {      Put.Text[handle.msgSW, "No file specified."L]; RETURN};    from ¬ MStream.ReadOnly[handle.file, [] ! MStream.Error => CONTINUE];    IF from = NIL THEN {      Put.Text[handle.msgSW, "Can't read file."L]; RETURN};    TextSW.SetEOF[handle.textSW, 0];    length ¬ MIN[MStream.GetLength[from], maxFromFile];    WHILE index < length DO      askFor: CARDINAL = CARDINAL[MIN[length - index, 10000]];      block: Environment.Block = MStream.ShareBlock[from, index, askFor];      [] ¬ handle.scratch.ReplaceText[block, index, index, FALSE];      index ¬ index + (block.stopIndexPlusOne - block.startIndex);      ENDLOOP;    from.Delete[];    handle.grabInput ¬ TRUE;    PrepTextSWForEditing[handle];    handle.dirty ¬ FALSE;    END;  Init: PROC =     BEGIN    ENABLE Runtime.StartFault => CONTINUE;      --  START StartOps.MailUtilImpl;    zone ¬ Heap.Create [10];    ProcessUserCm[];    MailPost.SetUserNameAndPassword[];    Exec.AddCommand["SendTool.~"L, SendExec, SendHelp, SendUnload];    Supervisor.AddDependency[      client: abortDeactivation, implementor: Event.toolWindow];    Supervisor.AddDependency[      client: updateLogin, implementor: Event.primaryCredentials];    Supervisor.AddDependency[      client: updateLogin, implementor: Event.tajoDefaults];         MailUtil.RegisterUnloadProc[UnloadMe, NIL];    END;	-- proc. Init  SendExec: Exec.ExecProc =    BEGIN    token, switches: LONG STRING ¬ NIL;    newState: Tool.State ¬ default;    ms: Stream.Handle;    handle: Handle;    [token, switches] ¬ h.GetToken[];    IF switches # NIL THEN      FOR i: CARDINAL IN [0..switches.length) DO        SELECT switches[i] FROM	  't, 'T => newState ¬ tiny;	  'a, 'A => newState ¬ active;	  'i, 'I => newState ¬ inactive;	  ENDCASE => {	    h.OutputProc[]["Unknown switch = "L];	    h.PutChar[switches[i]];	    EXIT};        ENDLOOP;    switches ¬ Exec.FreeTokenString[switches];    [ms, handle] ¬ CreateOne[      reason: newForm, replyToFlag: defaultReplyTo,      initialState: newState, recipient: NIL, grabInput: FALSE];    token ¬ Exec.FreeTokenString[token];    END;   SendHelp: Exec.ExecProc =     BEGIN    h.OutputProc[][      "This command activates a tool for composing and sending mail to the product mail servers."L];    END;      MakeCommandSW: FormSW.ClientItemsProcType =    BEGIN OPEN FormSW;    cmdItems: LONG POINTER TO ARRAY CommandSWIndices OF ItemHandle;    h: Handle = FindHandle[ToolWindow.WindowForSubwindow[sw]];    replyChoices: ARRAY [0..3) OF Enumerated ¬ [      ["don't send"L, MailSend.ReplyToFlag.stop],      ["add to form"L, MailSend.ReplyToFlag.add],      ["send anyway"L, MailSend.ReplyToFlag.send]];    sendAsChoices: ARRAY [0..3) OF Enumerated ¬ [      ["Text"L, SendAs.text],      ["MailNote"L, SendAs.mailNote],      ["MailNote with attachment"L, SendAs.attachment]];        items ¬ AllocateItemDescriptor[CommandSWIndices.LAST.ORD + 1, zone];    cmdItems ¬ LOOPHOLE[BASE[items]];    cmdItems­ ¬ [      another:	CommandItem[tag: "Another"L, proc: SendMailCommandProc,        place: newLine, z: zone],      destroy:  CommandItem[        tag: "Destroy"L, proc: SendMailCommandProc, z: zone],      reset:    CommandItem[tag: "Reset"L, proc: SendMailCommandProc, z: zone],      sendAs:  EnumeratedItem[tag: "Send As"L, value: @h.sendAs,	place: nextPlace, choices: DESCRIPTOR[sendAsChoices],	proc: SendAsProc, z: zone],      expandPvtDLs: BooleanItem[tag: "Expand Pvt DLs"L,        switch: @h.expandPvtDLs, place: newLine, z: zone],      put: CommandItem[tag: "Put"L, proc: SendMailCommandProc,        place: nextPlace, z: zone],      get: CommandItem[tag: "Get"L, proc: SendMailCommandProc,        place: nextPlace, z: zone],      file: StringItem[tag: "File"L, inHeap: TRUE, string: @h.file,        place: nextPlace, z: zone],      invalid:  BooleanItem[tag: "Invalid OK"L,        switch: @h.ifInvalidRecipients, place: newLine, z: zone],      replyTo:  EnumeratedItem[tag: "If Need Reply-To"L, value: @h.replyToFlag,        place: nextPlace, choices: DESCRIPTOR[replyChoices], z: zone],      deliver:  CommandItem[tag: "Deliver"L,         proc: SendMailCommandProc, place: nextPlace, invisible: TRUE, z: zone],      delivered: TagOnlyItem[        tag: "delivered"L, place: nextPlace, invisible: TRUE, z: zone],      attachmentType: StringItem[tag: "Attachment Type"L,        string: @h.attachmentType, inHeap: TRUE,	place: newLine, invisible: (h.sendAs # attachment),	menuProc: MailPost.AttachmentTypeMenuProc, z: zone],      attachmentFile: StringItem[tag: "Attachment File"L,        string: @h.attachmentFile, inHeap: TRUE,	place: newLine, invisible: (h.sendAs # attachment), z: zone]];    h.showing ¬ nothing;    RETURN[items: items, freeDesc: TRUE]    END;	-- proc. MakeCommandSW    MakeDirty: PROCEDURE [handle: Handle] =    BEGIN    IF handle.dirty THEN RETURN;    Process.Detach[FORK Put.Line[handle.msgSW, NIL]];       handle.dirty ¬ TRUE;    SELECT handle.showing FROM      nothing => 	FormSW.ToggleVisibility[handle.commandSW, CommandSWIndices.deliver.ORD];      command => NULL;      indicator => {	FormSW.ToggleVisibility[handle.commandSW, CommandSWIndices.delivered.ORD];	FormSW.ToggleVisibility[handle.commandSW, CommandSWIndices.deliver.ORD]};      ENDCASE;    handle.showing ¬ command;    END;    PutToFile: PROCEDURE [handle: Handle] =    BEGIN    to: Stream.Handle ¬ NIL;    IF String.Empty[handle.file] THEN {      Put.Text[handle.msgSW, "No file specified."L]; RETURN};    to ¬ MStream.WriteOnly[handle.file, [], text ! MStream.Error => CONTINUE];    IF to = NIL THEN {      Put.Text[handle.msgSW, "Can't write on file."L]; RETURN};    to.PutBlock[ScratchSource.Info[handle.scratch].block];    to.Delete[];    END;    SendAsProc: FormSW.EnumeratedNotifyProcType =    BEGIN    window: Window.Handle ¬ ToolWindow.WindowForSubwindow[sw];    h: Handle = FindHandle[window];        IF SendAs [oldValue] # attachment AND h.sendAs # attachment THEN RETURN;      -- Note: FormSW will not call this proc if old = new.    FormSW.ToggleVisibility[h.commandSW, CommandSWIndices.attachmentFile.ORD];    FormSW.ToggleVisibility[h.commandSW, CommandSWIndices.attachmentType.ORD];    AdjustBoxSize[sw: h.commandSW, bigger: (h.sendAs = attachment)];    END;    IndicateDelivered: PUBLIC PROCEDURE [h: Handle] =    BEGIN    h.dirty ¬ FALSE;    h.showing ¬ indicator;    FormSW.ToggleVisibility[h.commandSW, CommandSWIndices.deliver.ORD];    FormSW.ToggleVisibility[h.commandSW, CommandSWIndices.delivered.ORD];    Put.Text[h.msgSW, "sent "L];    END;  MakeSWs: Tool.MakeSWsProc =     BEGIN    h: Handle = FindHandle[window];    addresses: ARRAY [0..3) OF ToolDriver.Address;        h.msgSW ¬ Tool.MakeMsgSW[window: window];    h.commandSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeCommandSW, zone: zone];    FormSW.SetModifyNotificationProc[h.commandSW, FormSWChanged];    CreateTextSW[window, h];    addresses ¬ [      [name: "MsgSW"L, sw: h.msgSW], [name: "CmdSW"L, sw: h.commandSW],      [name: "TextSW"L, sw: h.textSW]];    ToolDriver.NoteSWs[tool: "SendTool"L, subwindows: DESCRIPTOR[addresses]];    END;	-- proc. MakeSWs  SendMailCommandProc: FormSW.ProcType =     BEGIN    DoIt: PROCEDURE RETURNS [doIt: BOOLEAN] =       BEGIN      IF ~h.dirty THEN RETURN[TRUE];      Cursor.Set[mouseRed];      doIt ¬ UserInput.WaitForConfirmation[].okay;      Cursor.Set[textPointer];      END;    h: Handle = FindHandle[ToolWindow.WindowForSubwindow[sw]];    command: CommandSWIndices = VAL[index];    Put.Text[h.msgSW, "\n\n"L];  -- Clears msgSW    IF command # another AND h.busy THEN       {PutError[h.msgSW, "Mail Send is busy."L]; RETURN};    SELECT command FROM      another => [] ¬ CreateSendWindow[newForm, h.replyToFlag];      deliver =>         BEGIN	h.busy ¬ TRUE;	Put.Text[h.msgSW, "Deliver: "];	Process.Detach[FORK MailPost.PostMessage[h, Event.StartingProcess["Mail Send"L]]];	END;	-- deliver      destroy => IF DoIt[] THEN {h.dirty ¬ FALSE; Destroy[h]};      get =>                   BEGIN	   h.busy ¬ TRUE;	   TextSW.SetEOF[h.textSW, 0];	   GetFromFile [h];	   Process.Detach [FORK MakeDirty [h]];	   FormSW.ToggleFlag[sw, index, modified];	   h.busy ¬ FALSE;	 END;  -- get      put => PutToFile[h];      reset =>	IF DoIt[] THEN 	  BEGIN	  h.busy ¬ TRUE;	  h.initializing ¬ TRUE;	  TextSW.SetEOF[h.textSW, 0];	    -- Delete contents of textSW	  h.dirty ¬ FALSE;	  FillInNewForm[h, NIL];	  h.grabInput ¬ TRUE;	  PrepTextSWForEditing[h];	  FormSW.ToggleFlag[sw, index, modified];	  SELECT h.showing FROM	    nothing => NULL;	    indicator => 	      FormSW.ToggleVisibility[h.commandSW,	        CommandSWIndices.delivered.ORD];	    command => 	      FormSW.ToggleVisibility[h.commandSW,	        CommandSWIndices.deliver.ORD];	    ENDCASE;	  h.showing ¬ nothing;	  h.initializing ¬ FALSE;	  h.busy ¬ FALSE;	  END;	-- reset      ENDCASE;    END;	-- proc. SendMailCommandProc    SendUnload: Exec.ExecProc =    BEGIN«    IF Runtime.IsBound [LOOPHOLE [MailReadOps.CreateData]] THEN {     h.OutputProc[]["Unload the MailTool first"L];     outcome ¬ abort;     }    ELSE {      h.RemoveCommand["SendTool.~"L];     MailUtil.Unload [];      } »          h.RemoveCommand["SendTool.~"L];     FOR handle: Handle ¬ inactiveList, handle.link UNTIL handle = NIL DO      WaitNotBusy[handle];      Destroy[handle];     ENDLOOP;     Supervisor.RemoveDependency[      client: abortDeactivation, implementor: Event.toolWindow];     abortDeactivation ¬ Supervisor.nullSubsystem;     Supervisor.RemoveDependency[      client: updateLogin, implementor: Event.primaryCredentials];          Supervisor.RemoveDependency[      client: updateLogin, implementor: Event.tajoDefaults];     updateLogin ¬ Supervisor.nullSubsystem;     Heap.Delete [zone];         END;    UnloadMe: MailUtil.UnloadProc =    BEGIN    -- CODE: Need to maintain an activeList in addition to an inactiveList    --   in order to do a Destroy[handle] for the active tool instantiations as    --   is done below for the inactive ones.    unloading ¬ TRUE;    FOR handle: Handle ¬ inactiveList, handle.link UNTIL handle = NIL DO      WaitNotBusy[handle];      Destroy[handle];      ENDLOOP;    Supervisor.RemoveDependency[      client: abortDeactivation, implementor: Event.toolWindow];    Supervisor.RemoveDependency[      client: updateLogin, implementor: Event.primaryCredentials];    Supervisor.RemoveDependency[      client: updateLogin, implementor: Event.tajoDefaults];    Heap.Delete [zone];    END;    WaitNotBusy: ENTRY PROCEDURE [handle: Handle] =    BEGIN    WHILE handle.busy DO      WAIT handle.condition      ENDLOOP;    END;      -- main line code    Init[];    END.    -- log:  -- NSG 14-Jan-85 11:28:17 changed bullets to European quotes for character set 0
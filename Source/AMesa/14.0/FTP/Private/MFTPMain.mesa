-- File: MFTPMain.mesa - last edit:-- bjd                  8-Oct-85 13:53:27-- RKJ	 3-Feb-83 16:55:16  -- BXM	22-Oct-81  9:31:11-- LXR	 6-Oct-82 18:16:02-- RXR	 4-Oct-82 11:47:19 -- CEH	29-Sep-82 16:30:33-- MEW	 6-Sep-84 13:20:03-- DWR 	22-Jul-85 12:54:09-- NS 	29-Jul-86 12:27:30-- Copyright (C) 1981, 1982, 1983, 1984, 1985 by Xerox Corporation. All rights reserved. DIRECTORY  Auth USING [IdentityHandle],  Exec USING [    Abort, AddCommand, CheckForAbort, Confirm, ExecProc, FreeTokenString, GetNameandPassword, GetToken, Handle, Outcome, OutputProc],  FileName USING [Error,    PackFilename, ResetVFN, UnpackFilename, VirtualFilename, VirtualFilenameObject],  FileTransfer USING [    CheckAbortProc, ClientProc, CodeToString, Confirmation, Connection, Copy,    Create, Delete, Destroy, Enumerate, Error, FileInfo,     FileInfoObject, ListProc, MessageProc, ReadStream, Rename,     SetDefaultServerType, SetProcs, SetPrimaryCredentials,    SetSecondaryCredentials, VetoProc],  Format USING [Blanks, Char, CR, Date, Line, LongNumber, LongOctal, StringProc],  Heap USING [systemZone],  MStream USING [EndOf, Error, Handle, Log, ReadOnly],  MFTPDefs USING [    AddCommand, ArgumentProc, Command, CommandMode, CommandProc, Handle,    IsSwitch, Object, PackedTime, ParseTime, WriteTime],  Profile USING [defaultFileServerProtocol, SetUser, GetID, GetUser],  Runtime USING [GetBcdTime],  Stream USING [    Block, Byte, CompletionCode, GetBlock, GetByte, EndOfStream, Handle, PutChar],  String USING [    AppendChar, AppendString, CopyToNewString, Empty,    EquivalentString, FreeString, LowerCase, MakeString, StringBoundsFault],  Time USING [Append, Invalid, Unpack];  MFTPMain: PROGRAM  IMPORTS    Exec, FileName, FileTransfer, Format, Heap, MFTPDefs, MStream, Profile,    Runtime, Stream, String, Time  EXPORTS MFTPDefs =  BEGIN OPEN MFTPDefs;  Handle: TYPE = MFTPDefs.Handle;  PackedTime: TYPE = MFTPDefs.PackedTime;  Abort: ERROR ¬ Exec.Abort[];  nameWidth: CARDINAL = 20;  byteWidth: CARDINAL = 6;  timeWidth: CARDINAL = 18;  z: UNCOUNTED ZONE = Heap.systemZone;     nullVFN: FileName.VirtualFilenameObject ¬ [NIL, NIL, NIL, NIL];  SetTypescript: PROC [h: Handle] = {    logName: STRING = [50];    String.AppendString[logName, "FTP.log"L];    WHILE h.logFile = NIL AND logName.length < logName.maxlength DO      h.logFile ¬ MStream.Log[        logName, [] !        MStream.Error => {String.AppendChar[logName, 'X]; CONTINUE}];      ENDLOOP};  CloseTypeScript: PROCEDURE [h: Handle] = {    IF h.logFile # NIL THEN h.logFile.delete[h.logFile]; h.logFile ¬ NIL};  BadSwitch: PROCEDURE [h: Handle, c: CHARACTER] =    BEGIN    h.write["Bad switch "L];    Format.Char[h.write, c];    h.write[" -- ignoring"L];    h.outcome ¬ warning;    END;  -- commands  OpenCommand: PUBLIC CommandProc =    BEGIN    usePup: BOOLEAN ¬ Profile.defaultFileServerProtocol = pup;    retry: BOOLEAN ¬ TRUE;    sense: BOOLEAN ¬ TRUE;    FOR i: CARDINAL IN [0..switches.length) DO      SELECT switches[i] FROM        'p => usePup ¬ sense;        'n => usePup ¬ ~sense;        'c => NULL;        '-, '~ => {sense ¬ ~sense; LOOP};        ENDCASE => BadSwitch[h, switches[i]];      sense ¬ TRUE;      ENDLOOP;    FileTransfer.SetDefaultServerType[h.conn, IF usePup THEN ifs ELSE ns !      FileTransfer.Error => IF retry THEN {        retry ¬ FALSE; usePup ¬ ~usePup; RETRY}      ELSE {h.write["No FileTransfer code loaded"L]; ERROR Abort}];    h.write["Opening"L];        h.write[" connection to "L];    ReadArgument[h, h.host ! String.StringBoundsFault => {      h.write["Host name too long. Aborting..."L]; ERROR Abort}];    h.write[h.host];    Format.CR[h.write];    RETURN[command, NoArguments];    END;  CloseCommand: CommandProc =    BEGIN h.host.length ¬ 0; RETURN[command, NoArguments]; END;  ConnectCommand: CommandProc =    BEGIN ENABLE String.StringBoundsFault => {      h.write["Name too long. Aborting..."L]; ERROR Abort};    dir: STRING = [100];    password: STRING = [40];    h.write["Connect (to directory) "L];    ReadArgument[h, dir];    Format.Line[h.write, dir];    IF IsSwitch['q, switches] THEN      Exec.GetNameandPassword[        h: h.exec, name: dir, password: password, prompt: "Conn: "L ! String.StringBoundsFault => {      h.write["Name too long. Aborting..."L]; ERROR Abort}]    ELSE GetPassword[h, password, FALSE];    FileTransfer.SetSecondaryCredentials[h.conn, dir, password];    Format.CR[h.write];    RETURN[command, NoArguments]    END;  DirectoryCommand: CommandProc =    BEGIN    ReadArgument[h, h.directory ! String.StringBoundsFault => {      h.write["Directory name too long. Aborting..."L]; ERROR Abort}];    h.write["Directory "L];    h.write[h.directory];    Format.CR[h.write];    RETURN[command, NoArguments]    END;  LocalDirectoryCommand: CommandProc =    BEGIN    ReadArgument[h, h.localdirectory ! String.StringBoundsFault => {      h.write["Directory name too long. Aborting..."L]; ERROR Abort}];    h.write["Local Directory "L];    h.write[h.localdirectory];    Format.CR[h.write];    RETURN[command, NoArguments]    END;  LoginCommand: CommandProc =    BEGIN ENABLE String.StringBoundsFault => {      h.write["Name too long. Aborting..."L]; ERROR Abort};    userName: STRING = [100];    password: STRING = [50];    tempPassword: STRING = [50];    AppendUser: PROCEDURE [name, password: LONG STRING] ={      String.AppendString[userName, name];      String.AppendString[tempPassword, password]};    SetID: PROCEDURE [id: Auth.IdentityHandle] ={      FileTransfer.SetPrimaryCredentials[conn: h.conn, id: id]};    h.write["\nLogIn "L];    Profile.GetUser[AppendUser];    IF ~IsSwitch['i, switches] THEN ReadArgument[h, userName];    IF IsSwitch['q, switches] OR IsSwitch['i, switches] THEN      Exec.GetNameandPassword[h.exec, userName, password]    ELSE GetPassword[h, password, FALSE];    Format.CR[h.write];    IF String.Empty[tempPassword] THEN      Profile.SetUser[name: userName, password: password];    FileTransfer.SetPrimaryCredentials[h.conn, userName, password];    Profile.GetID[proc: SetID];    RETURN[command, NoArguments];    END;  SetUpCommands: PROCEDURE [h: Handle] = {h.reset ¬ FALSE};  BackupCommand: PUBLIC PROC [h: Handle] = {h.reset ¬ TRUE};  ReadCommand: PUBLIC PROCEDURE [h: Handle, name, switches: LONG STRING]    RETURNS [BOOLEAN] =    BEGIN    IF ~h.reset THEN      BEGIN      String.FreeString[z, h.lastName];      String.FreeString[z, h.lastSwitch];      [h.lastName, h.lastSwitch] ¬ Exec.GetToken[h.exec];      IF h.lastSwitch # NIL THEN        FOR i: CARDINAL IN [0..h.lastSwitch.length) DO          h.lastSwitch[i] ¬ String.LowerCase[h.lastSwitch[i]]; ENDLOOP;      END;    name.length ¬ 0;    switches.length ¬ 0;    String.AppendString[name, h.lastName ! String.StringBoundsFault => CONTINUE];    String.AppendString[switches, h.lastSwitch ! String.StringBoundsFault => CONTINUE];    h.reset ¬ FALSE;    RETURN[name.length # 0 OR switches.length # 0];    END;  ReadArgument: PROCEDURE [h: Handle, arg: LONG STRING] =    BEGIN    dummy: STRING ¬ [10];    [] ¬ ReadCommand[h, arg, dummy ! String.StringBoundsFault => CONTINUE];    IF dummy.length # 0 THEN Confusion[h];    END;  Confusion: PROCEDURE [h: Handle] = {SIGNAL FileTransfer.Error[h.conn, unknown]};  DeleteCommand: CommandProc =    BEGIN    i: CARDINAL;    sense: BOOLEAN ¬ TRUE;    h.write["Delete"L];    h.verify ¬ FALSE;    FOR i IN [0..switches.length) DO      SELECT switches[i] FROM        'v =>          BEGIN          h.verify ¬ sense;          IF ~sense THEN h.write[" no "L];          h.write[" verify"L]          END;        'c => NULL;        '-, '~ => {sense ¬ ~sense; LOOP};        ENDCASE => BadSwitch[h, switches[i]];      sense ¬ TRUE;      ENDLOOP;    Format.CR[h.write];    RETURN[argument, DeleteFiles];    END;  DeleteFiles: ArgumentProc =    BEGIN    vfn: FileName.VirtualFilenameObject ¬ [NIL, NIL, NIL, NIL];    IF name = NIL OR name.length = 0 THEN RETURN;    MakeVFN[h, name, @vfn];    FileTransfer.Delete[      h.conn, @vfn, IF h.verify THEN Confirm ELSE NIL !      FileTransfer.Error => CONTINUE];    FreeVFN[@vfn];    END;  RetrieveCommand: CommandProc =    BEGIN    name: STRING ¬ [100];    rename: BOOLEAN ¬ FALSE;    sense: BOOLEAN ¬ TRUE;    i: CARDINAL;    sourceVFN, targetVFN: FileName.VirtualFilenameObject ¬ [      NIL, NIL, NIL, NIL];    h.write["Retrieve"L];    h.anyswitches ¬ h.timeLess ¬ h.timeGreater ¬ h.timeEqual ¬ h.verify ¬ h.always      ¬ FALSE;    FOR i IN [0..switches.length) DO      IF switches[i] = 's THEN {        rename ¬ sense;        IF sense THEN h.write[" rename"L] ELSE h.write[" ignoring ~s switch "L];        sense ¬ TRUE}      ELSE {        SELECT switches[i] FROM          'u, '> =>            BEGIN h.timeGreater ¬ sense; IF ~sense THEN h.write[" update"L] END;          'v =>            BEGIN            h.verify ¬ sense;            IF ~sense THEN h.write[" no "L];            h.write[" verify"L]            END;          'a =>            BEGIN            h.always ¬ sense;            IF ~sense THEN h.write[" no "L];            h.write[" always"L]            END;          '< =>            BEGIN            h.timeLess ¬ sense;            IF ~sense THEN h.write[" no "L];            h.write[" previous"L]            END;          '= =>            BEGIN            h.timeEqual ¬ sense;            IF ~sense THEN h.write[" no "L];            h.write[" equal"L]            END;          '# =>            BEGIN            h.timeLess ¬ h.timeGreater ¬ sense;            IF ~sense THEN h.write[" no "L];            h.write[" different"L]            END;          'c => NULL;          '-, '~ => {sense ¬ ~sense; LOOP};          ENDCASE => {BadSwitch[h, switches[i]]; sense ¬ TRUE; LOOP};        h.anyswitches ¬ TRUE;        sense ¬ TRUE};      ENDLOOP;    Format.CR[h.write];    IF ~rename THEN RETURN[argument, RetrieveFiles];    ReadArgument[h, name];    IF name = NIL OR name.length = 0 THEN RETURN[command, NoArguments];    MakeVFN[h, name, @sourceVFN];    ReadArgument[h, name];    IF name = NIL OR name.length = 0 THEN {      FreeVFN[@sourceVFN]; RETURN[command, NoArguments]};    MakeVFN[h, name, @targetVFN, FALSE];    FileTransfer.Copy[      sourceFile: @sourceVFN, destFile: @targetVFN, sourceConn: h.conn,      veto: IF h.anyswitches THEN FilterProc ELSE NIL,      showDates: h.timeLess OR h.timeGreater OR h.timeEqual !      FileTransfer.Error => CONTINUE];    FreeVFN[@sourceVFN];    FreeVFN[@targetVFN];    RETURN[command, NoArguments];    END;  RetrieveFiles: ArgumentProc =    BEGIN    vfn, lvfn: FileName.VirtualFilenameObject ¬ [NIL, NIL, NIL, NIL];    IF name = NIL OR name.length = 0 THEN RETURN;    MakeVFN[h, name, @vfn];    MakeVFN[h, NIL, @lvfn, FALSE];    FileTransfer.Copy[      sourceFile: @vfn, destFile: @lvfn, sourceConn: h.conn,      veto: IF h.anyswitches THEN FilterProc ELSE NIL,      showDates: h.timeLess OR h.timeGreater OR h.timeEqual !      FileTransfer.Error => CONTINUE];    FreeVFN[@vfn];    FreeVFN[@lvfn];    END;  StoreCommand: CommandProc =    BEGIN    name: STRING ¬ [100];    rename: BOOLEAN ¬ FALSE;    sense: BOOLEAN ¬ TRUE;    i: CARDINAL;    sourceVFN, targetVFN: FileName.VirtualFilenameObject ¬ [      NIL, NIL, NIL, NIL];    h.anyswitches ¬ h.timeLess ¬ h.timeGreater ¬ h.timeEqual ¬ h.always ¬ h.verify      ¬ FALSE;    h.write["Store"L];    FOR i IN [0..switches.length) DO      IF switches[i] = 's THEN {        rename ¬ sense;        IF ~sense THEN h.write[" no "L];        h.write[" rename"L];        sense ¬ TRUE}      ELSE {        SELECT switches[i] FROM          'u, '> =>            BEGIN h.timeGreater ¬ sense; IF ~sense THEN h.write[" update"L] END;          'v =>            BEGIN            h.verify ¬ sense;            IF ~sense THEN h.write[" no "L];            h.write[" verify"L]            END;          'a =>            BEGIN            h.always ¬ sense;            IF ~sense THEN h.write[" no "L];            h.write[" always"L]            END;          '< =>            BEGIN            h.timeLess ¬ sense;            IF ~sense THEN h.write[" no "L];            h.write[" previous"L]            END;          '= =>            BEGIN            h.timeEqual ¬ sense;            IF ~sense THEN h.write[" no "L];            h.write[" equal"L]            END;          '# =>            BEGIN            h.timeLess ¬ h.timeGreater ¬ sense;            IF ~sense THEN h.write[" no "L];            h.write[" different"L]            END;          'c => NULL;          '~, '~ => {sense ¬ ~sense; LOOP};          ENDCASE => {BadSwitch[h, switches[i]]; sense ¬ TRUE; LOOP};        h.anyswitches ¬ TRUE;        sense ¬ TRUE};      ENDLOOP;    Format.CR[h.write];    IF ~rename THEN RETURN[argument, StoreFiles];    ReadArgument[h, name];    IF name = NIL OR name.length = 0 THEN RETURN[command, NoArguments];    MakeVFN[h, name, @sourceVFN, FALSE];    ReadArgument[h, name];    IF name = NIL OR name.length = 0 THEN {      FreeVFN[@sourceVFN]; RETURN[command, NoArguments]};    MakeVFN[h, name, @targetVFN];    FileTransfer.Copy[      sourceFile: @sourceVFN, destFile: @targetVFN, destConn: h.conn,      veto: IF h.anyswitches THEN FilterProc ELSE NIL,      showDates: h.timeLess OR h.timeGreater OR h.timeEqual !      FileTransfer.Error => CONTINUE];    FreeVFN[@sourceVFN];    FreeVFN[@targetVFN];    RETURN[command, NoArguments];    END;  StoreFiles: ArgumentProc =    BEGIN    sourceVFN, targetVFN: FileName.VirtualFilenameObject ¬ [      NIL, NIL, NIL, NIL];    IF name = NIL OR name.length = 0 THEN RETURN;    MakeVFN[h, name, @sourceVFN, FALSE];    MakeVFN[h, sourceVFN.name, @targetVFN];    FileTransfer.Copy[      sourceFile: @sourceVFN, destFile: @targetVFN, destConn: h.conn,      veto: IF h.anyswitches THEN FilterProc ELSE NIL,      showDates: h.timeLess OR h.timeGreater OR h.timeEqual !      FileTransfer.Error => CONTINUE];    FreeVFN[@sourceVFN];    FreeVFN[@targetVFN];    END;  RenameCommand: CommandProc =    BEGIN    oldName: STRING = [100];    newName: STRING = [100];    oldVFN: FileName.VirtualFilenameObject ¬ [NIL, NIL, NIL, NIL];    newVFN: FileName.VirtualFilenameObject ¬ [NIL, NIL, NIL, NIL];    ReadArgument[h, oldName];    ReadArgument[h, newName];    MakeVFN[h, oldName, @oldVFN];    MakeVFN[h, newName, @newVFN];    h.write["Renaming "L];    h.write[oldName];    h.write[" to "L];    h.write[newName];    FileTransfer.Rename[      conn: h.conn, old: @oldVFN, new: @newVFN ! FileTransfer.Error => CONTINUE];    Format.CR[h.write];    FreeVFN[@oldVFN];    FreeVFN[@newVFN];    RETURN[command, NoArguments]    END;  CompareCommand: CommandProc =    BEGIN    name: STRING ¬ [100];    rename: BOOLEAN ¬ FALSE;    sense: BOOLEAN ¬ TRUE;    i: CARDINAL;    localVFN, remoteVFN: FileName.VirtualFilenameObject ¬ [      NIL, NIL, NIL, NIL];    h.write["Compare"L];    h.timeLess ¬ h.timeGreater ¬ h.timeEqual ¬ h.always ¬ h.verify ¬ rename ¬      FALSE;    FOR i IN [0..switches.length) DO      SELECT switches[i] FROM        's =>          BEGIN          rename ¬ sense;          IF sense THEN h.write[" files of different names"L]          ELSE h.write[" ignoring ~s switch "L];          END;        'c => NULL;        '-, '~ => {sense ¬ ~sense; LOOP};        ENDCASE => BadSwitch[h, switches[i]];      sense ¬ TRUE;      ENDLOOP;    Format.CR[h.write];    IF ~rename THEN RETURN[argument, CompareFiles];    ReadArgument[h, name];    IF name = NIL OR name.length = 0 THEN RETURN[command, NoArguments];    MakeVFN[h, name, @remoteVFN];  -- check sense of rename    ReadArgument[h, name];    IF name = NIL OR name.length = 0 THEN {      FreeVFN[@remoteVFN]; RETURN[command, NoArguments]};    MakeVFN[h, name, @localVFN, FALSE];    CompareAgainst[h, @localVFN, @remoteVFN];    FreeVFN[@localVFN];    FreeVFN[@remoteVFN];    RETURN[command, NoArguments];    END;  CompareFiles: ArgumentProc =    BEGIN    vfn, lvfn: FileName.VirtualFilenameObject ¬ [NIL, NIL, NIL, NIL];    IF name = NIL OR name.length = 0 THEN RETURN;    MakeVFN[h, name, @vfn];    MakeVFN[h, vfn.name, @lvfn, FALSE];    CompareAgainst[h, @lvfn, @vfn];    FreeVFN[@lvfn];    FreeVFN[@vfn];    END;  CompareAgainst: PROCEDURE [    h: Handle, local, remote: FileName.VirtualFilename] = {    byte: LONG CARDINAL ¬ 0;    i: CARDINAL ¬ 0;    localName: LONG STRING ¬ FileName.PackFilename[      local, FALSE, TRUE, TRUE, FALSE];    localStream: Stream.Handle ¬ NIL;    remoteStream: Stream.Handle ¬ NIL;    bufferSize: CARDINAL = 100;    Buffer: TYPE = PACKED ARRAY [0..bufferSize) OF Stream.Byte;    remoteBufferSpace: Buffer;    remoteBuffer: POINTER TO Buffer = @remoteBufferSpace;    remoteBlock: Stream.Block ¬ [remoteBuffer, 0, bufferSize];    h.write["Comparing remote file "L];    h.write[remote.name];    h.write[" to local file "L];    h.write[localName];    Format.CR[h.write];    localStream ¬ MStream.ReadOnly[localName, [] ! MStream.Error => CONTINUE];    String.FreeString[z, localName];    IF localStream = NIL THEN {      Format.Line[h.write, "Could not acquire local file."L]; RETURN};    remoteStream ¬ FileTransfer.ReadStream[      conn: h.conn, files: remote ! FileTransfer.Error => CONTINUE];    IF remoteStream = NIL THEN {      Format.Line[h.write, "Could not acquire remote file."L];      localStream.delete[localStream];      RETURN};    h.write["... "L];    DO      count: CARDINAL;      why: Stream.CompletionCode;      [bytesTransferred: count, why: why] ¬ Stream.GetBlock[remoteStream, remoteBlock];      FOR i IN [0..count) DO        IF Stream.GetByte[localStream ! Stream.EndOfStream => GOTO fail] # remoteBuffer[i] THEN GOTO fail	ENDLOOP;      byte ¬ byte + count; i ¬ 0;      IF why = endOfStream THEN        IF MStream.EndOf[localStream] THEN GOTO success	ELSE GOTO fail;      REPEAT        fail => {          h.write["Files differ at byte "L];          Format.LongOctal[h.write, byte+i];          Format.CR[h.write];          localStream.delete[localStream];          remoteStream.delete[remoteStream]};        success => {          h.write["No differences found."L];          Format.CR[h.write];          localStream.delete[localStream];          remoteStream.delete[remoteStream]};      ENDLOOP};  ListCommand: CommandProc =    BEGIN    i: CARDINAL;    sense: BOOLEAN ¬ TRUE;    h.write["List"L];    h.options ¬ ALL[FALSE];    h.filter ¬ 0;    FOR i IN [0..switches.length) DO      SELECT switches[i] FROM        'a =>          BEGIN          h.options[author] ¬ sense;          IF ~sense THEN h.write[" no "L];          h.write[" author"L]          END;        'd =>          BEGIN          h.options[create] ¬ sense;          IF ~sense THEN h.write[" no "L];          h.write[" create"L]          END;        'l =>          BEGIN          h.options[bytes] ¬ sense;          IF ~sense THEN h.write[" no "L];          h.write[" bytes"L]          END;        'r =>          BEGIN          h.options[read] ¬ sense;          IF ~sense THEN h.write[" no "L];          h.write[" read"L]          END;        't =>          BEGIN          h.options[type] ¬ sense;          IF ~sense THEN h.write[" no "L];          h.write[" type"L]          END;        'w =>          BEGIN          h.options[write] ¬ sense;          IF ~sense THEN h.write[" no "L];          h.write[" write"L]          END;        'f, 'b =>          BEGIN          h.filter ¬ ExtractAndParseTime[            h !            Time.Invalid => {              h.write[": bad time format -- ignoring switch "L];              sense ¬ TRUE;              LOOP}];          IF switches[i] = 'f THEN {h.write[" from "L]; h.options[from] ¬ TRUE}          ELSE {h.write[" before "L]; h.options[before] ¬ TRUE};          WriteTime[h, h.filter];          EXIT          END;        'c => {sense ¬ TRUE; LOOP};        ENDCASE => {BadSwitch[h, switches[i]]; sense ¬ TRUE; LOOP};      h.anyswitches ¬ TRUE;      sense ¬ TRUE;      ENDLOOP;    Format.CR[h.write];    DoListHeader[h];    RETURN[argument, ListFiles]    END;  ListFiles: ArgumentProc =    BEGIN    vfn: FileName.VirtualFilenameObject ¬ [NIL, NIL, NIL, NIL];    IF String.Empty[name] OR Exec.CheckForAbort[h.exec] THEN RETURN;    MakeVFN[h, name, @vfn];    FileTransfer.Enumerate[      conn: h.conn, files: @vfn, proc: ListProc ! FileTransfer.Error => CONTINUE];    FreeVFN[@vfn];    END;  -- utilities  Post: FileTransfer.MessageProc =    BEGIN    h: Handle = LOOPHOLE[clientData];    IF s1 # NIL THEN h.write[s1];    IF s2 # NIL THEN h.write[s2];    IF s3 # NIL THEN h.write[s3];    IF s4 # NIL THEN h.write[s4];    END;  LoginProc: FileTransfer.ClientProc = {    [] ¬ LoginCommand[LOOPHOLE[clientData], "i"L]};  Confirm: FileTransfer.VetoProc = {    h: Handle = LOOPHOLE[clientData, Handle];    showDates ¬ showingDates;    IF Exec.Confirm[h.exec] THEN confirm ¬ do ELSE confirm ¬ skip;    IF Exec.CheckForAbort[h.exec] THEN confirm ¬ abort};  CheckAbort: FileTransfer.CheckAbortProc = {    h: Handle = LOOPHOLE[clientData, Handle];    RETURN[Exec.CheckForAbort[h.exec]]};  MakeVFN: PROCEDURE [    h: Handle, name: LONG STRING, vfn: FileName.VirtualFilename,    remoteFile: BOOLEAN ¬ TRUE] =    BEGIN    IF remoteFile THEN {      vfn.host ¬ String.CopyToNewString[h.host, z];      vfn.directory ¬ String.CopyToNewString[h.directory, z]}    ELSE IF ~String.Empty[h.localdirectory] THEN {      vfn.directory ¬ String.MakeString[        z: z, maxlength: h.localdirectory.length+2];      IF h.localdirectory[0] # '< THEN        String.AppendString[vfn.directory, "<>"L];      String.AppendString[vfn.directory, h.localdirectory]};    FileName.UnpackFilename[name, vfn ! FileName.Error =>     CONTINUE;     ];    END;  FreeVFN: PROCEDURE [vfn: FileName.VirtualFilename] = INLINE    BEGIN FileName.ResetVFN[vfn, TRUE, TRUE, TRUE, TRUE] END;  GetPassword: PROCEDURE [    h: Handle, connPassword: LONG STRING, interactive: BOOLEAN] =    BEGIN    dummy: STRING = [10];    [] ¬ ReadCommand[h, connPassword, dummy];    IF dummy.length # 0 THEN      BEGIN  -- this works if conn password is empty as well;      AppendPassword: PROCEDURE [name, password: LONG STRING] ={	String.AppendString[connPassword, password];};      BackupCommand[h];      connPassword.length ¬ 0;      Profile.GetUser[AppendPassword];      END;    END;  ListProc: FileTransfer.ListProc =    BEGIN    fileData: FileTransfer.FileInfoObject ¬ [];    f: FileTransfer.FileInfo ¬ @fileData;    temp: STRING ¬ [100];    i: CARDINAL;    h: Handle = LOOPHOLE[clientData];    IF Exec.CheckForAbort[h.exec] THEN RETURN[abort];    [f] ¬ info[h.conn];    IF ~String.EquivalentString[h.currentDirectory, f.directory] THEN      BEGIN      h.write[f.directory];      Format.CR[h.write];      String.FreeString[z, h.currentDirectory];      h.currentDirectory ¬ String.CopyToNewString[f.directory, z];      END;    String.AppendString[temp, f.body];    IF ~String.Empty[f.version] THEN {      String.AppendChar[temp, '!];      String.AppendString[temp, f.version]};    IF ~f.oldFile THEN {h.write[temp]; h.write[" not found"L]; Format.CR[h.write]}    ELSE IF (h.options[before] AND f.create < h.filter) OR (h.options[from] AND f.create > h.filter) OR (~h.options[before] AND ~h.options[from]) THEN      BEGIN      h.write["  "L];      h.write[temp];      IF h.options # ALL[FALSE] THEN {        FOR i IN [0..25 - MIN[24, temp.length]) DO h.write[" "L]; ENDLOOP;        IF h.options[type] THEN          h.write[            SELECT f.type FROM              text => "text    "L,              binary => "binary  "L,              unknown => "unknown "L,              ENDCASE => ERROR];        IF h.options[bytes] THEN          Format.LongNumber[            h.write, f.size, [            base: 10, zerofill: FALSE, unsigned: TRUE, columns: 8]];        IF h.options[create] THEN {          h.write[" "L]; Format.Date[h.write, f.create, full]};        IF h.options[write] THEN {          h.write[" "L]; Format.Date[h.write, f.write, dateTime]};        IF h.options[read] THEN {          h.write[" "L]; Format.Date[h.write, f.read, full]};        IF h.options[author] AND ~String.Empty[f.author] THEN {          h.write[" "L]; h.write[f.author]};        Format.CR[h.write]};      END;    RETURN[do];    END;  DoListHeader: PROCEDURE [h: Handle] =    BEGIN    IF ~h.anyswitches THEN RETURN;    Format.Blanks[h.write, nameWidth + 2];    IF h.options[bytes] THEN {      Format.Blanks[h.write, byteWidth + 1 + 4]; h.write["length"L]};    IF h.options[create] THEN {      Format.Blanks[h.write, timeWidth + 1]; h.write["create"L]};    IF h.options[write] THEN {      Format.Blanks[h.write, timeWidth + 1]; h.write["write"L]};    IF h.options[read] THEN {      Format.Blanks[h.write, timeWidth + 1]; h.write["read"L]};    IF h.options[author] THEN h.write[" author"L];    Format.CR[h.write];    END;  ExtractAndParseTime: PROCEDURE [h: Handle] RETURNS [time: PackedTime] =    BEGIN    token, switches: LONG STRING;    goodTime: BOOLEAN;    [token, switches] ¬ h.exec.GetToken[];    switches ¬ Exec.FreeTokenString[switches];    [goodTime, time] ¬ ParseTime[token];    token ¬ Exec.FreeTokenString[token];    IF ~goodTime THEN ERROR Time.Invalid;    END;  FilterProc: FileTransfer.VetoProc =    BEGIN    h: Handle = LOOPHOLE[clientData];    source, target: FileTransfer.FileInfo;    unfiltered: BOOLEAN = ~(h.timeLess OR h.timeEqual OR h.timeGreater OR h.options[before] OR h.options[from]);    IF Exec.CheckForAbort[h.exec] THEN RETURN[abort, showingDates];    IF (h.options[from] AND h.options[before]) THEN RETURN[skip, showingDates]; -- what a wimpy way out!  Why didn't you implement a range?  You, sir, are French!    IF unfiltered THEN confirm ¬ do    ELSE {      [source, target] ¬ info[h.conn];      IF ~target.oldFile OR target.readProtect THEN        confirm ¬ IF h.always THEN do ELSE skip      ELSE        confirm ¬          SELECT TRUE FROM            h.options[before] => IF source.create < h.filter THEN do ELSE skip,            h.options[from] => IF source.create > h.filter THEN do ELSE skip,            source.create < target.create => IF h.timeLess THEN do ELSE skip,            source.create = target.create => IF h.timeEqual THEN do ELSE skip,            source.create > target.create => IF h.timeGreater THEN do ELSE skip,            ENDCASE => do};    IF confirm = do AND h.verify THEN      [confirm, showingDates] ¬ Confirm[        conn: h.conn, clientData: clientData, post: post, info: info,        showingDates: showingDates]    ELSE showDates ¬ showingDates;    RETURN[confirm, showDates];    END;  NoArguments: ArgumentProc = BEGIN Confusion[h]; END;  -- main processing  Init: Exec.ExecProc =    BEGIN    s: STRING ¬ [50];    host: LONG STRING ¬ [80];    directory: LONG STRING ¬ [100];    localdirectory: LONG STRING ¬ [100];    object: MFTPDefs.Object ¬ [];    Write: Format.StringProc =      BEGIN      Exec.OutputProc[h][s];      IF object.logFile # NIL THEN        FOR i: CARDINAL IN [0..s.length) DO          Stream.PutChar[object.logFile, s[i]]; ENDLOOP;      END;    CleanUp: PROCEDURE =      BEGIN      [] ¬ CloseCommand[@object, NIL];      String.FreeString[z, object.lastName];      String.FreeString[z, object.lastSwitch];      String.FreeString[z, object.currentDirectory];      FileTransfer.Destroy[object.conn];      CloseTypeScript[@object];      outcome ¬ object.outcome;      END;    object.conn ¬ FileTransfer.Create[];    object.exec ¬ h;    object.write ¬ Write;    object.outcome ¬ normal;    object.host ¬ host;    object.directory ¬ directory;    object.localdirectory ¬ localdirectory;    SetTypescript[@object];    IF object.logFile = NIL THEN      Exec.OutputProc[h]["Could not create FTP.log. Continuing..."L];    FileTransfer.SetProcs[      conn: object.conn, clientData: @object, messages: Post,       login: LoginProc, checkAbort: CheckAbort];    object.write["FTP of "L];    Time.Append[s, Time.Unpack[Runtime.GetBcdTime[]]];    s.length ¬ s.length - 3;    object.write[s];    Format.CR[object.write];    Format.CR[object.write];    SetUpCommands[@object];    MainLoop[      @object !      FileTransfer.Error => {        FileTransfer.CodeToString[code, s]; Write[s]; 	object.outcome ¬ error; CONTINUE};      UNWIND => CleanUp[]];    CleanUp[];    END;  MainLoop: PROCEDURE [h: Handle] =    BEGIN    name: STRING ¬ [100];    switches: STRING ¬ [50];    mode: CommandMode ¬ command;    Argument: ArgumentProc ¬ NoArguments;    WHILE ReadCommand[h, name, switches] DO      IF Exec.CheckForAbort[h.exec] THEN ERROR Abort;      IF name.length = 0 THEN LOOP;  -- ignore global switches      IF switches.length > 0 OR mode = command THEN        BEGIN        IF mode = argument THEN Argument[h, NIL];        Argument ¬ NoArguments;        [mode, Argument] ¬ MFTPDefs.Command[h: h, name: name, switches: switches]        END      ELSE IF mode # argument THEN Confusion[h] ELSE Argument[h, name];      ENDLOOP;    IF mode = argument THEN Argument[h, NIL];    END;  -- main program  InitCommands: PROCEDURE = {    MFTPDefs.AddCommand["Close"L, CloseCommand];    MFTPDefs.AddCommand["Compare"L, CompareCommand];    MFTPDefs.AddCommand["Connect"L, ConnectCommand];    MFTPDefs.AddCommand["Delete"L, DeleteCommand];    MFTPDefs.AddCommand["Directory"L, DirectoryCommand];    MFTPDefs.AddCommand["List"L, ListCommand];    MFTPDefs.AddCommand["LocalDirectory"L, LocalDirectoryCommand];    MFTPDefs.AddCommand["Login"L, LoginCommand];    MFTPDefs.AddCommand["Open"L, OpenCommand];    MFTPDefs.AddCommand["Rename"L, RenameCommand];    MFTPDefs.AddCommand["Retrieve"L, RetrieveCommand];    MFTPDefs.AddCommand["Store"L, StoreCommand];    Exec.AddCommand["FTP.~"L, Init]};    InitCommands[];  END.LOGDWR 	 9-Jan-85 11:31:02  Changed a bunch of grody code in ExtractAndParseTime to be a call to Exec.GetToken[].  I think FTP is full of space leaks.  The number of Exec.GetToken[]'s # the number of Exec.FreeTokenString[]'s + String.FreeString[]'s.  I also added f.create date filtering to ListProc[] & fixed the filtering in the FilterProc, which was backwards.  The /f & /b switches never did work.  They do now.  What a piece of $~%&!DWR 	 9-May-85 15:56:53 put this version into the release  DWR 	22-Jul-85 12:53:34 Fixed a bug in the ListProc.  It wouldn't list unless you used the dates switch.  Heh, heh.  bjd 	19-Sep-85 19:00:03 Changed store to allow wildcards.  Only works with the form:   sto/ua <>dir>*  and not localDir/c <>dir  sto/ua * or anything else.  well its better than before. NS: 29-Jul-86 12:27:49 caught FileName.Error
-- Copyright (C) 1982, 1984  by Xerox Corporation. All rights reserved. -- MFTPCommands.mesa; edited by -- RXJ     ,  July 8, 1980  10:22 AM-- LXR    ,   2-Feb-82 15:50:58-- CXH    ,	29-Sep-82 15:14:37 -- BJD    ,	 4-Jul-84 17:34:46-- MEW   	 6-Sep-84 13:18:51 DIRECTORY  FileTransfer USING [Error],  Format USING [StringProc],  Heap USING [systemZone],  Inline USING [LongCOPY],  MFTPDefs USING [    ArgumentProc, BackupCommand, CommandMode, CommandProc, Handle,    OpenCommand],  String USING [CopyToNewString],  StringLookUp USING [ambiguous, emptyKey, InTable, noMatch];MFTPCommands: PROGRAM  IMPORTS FileTransfer, Heap, Inline, MFTPDefs, String, StringLookUp EXPORTS MFTPDefs =  BEGIN  z: UNCOUNTED ZONE = Heap.systemZone;   initTableSize: CARDINAL = 30;  tableInc: CARDINAL = 10;  tableSize: CARDINAL ¬ initTableSize;  StringSeq: TYPE = RECORD [    commandCount: CARDINAL ¬ 0,    seq: SEQUENCE l: CARDINAL OF LONG STRING];  ProcSeq: TYPE = RECORD [seq: SEQUENCE l: CARDINAL OF MFTPDefs.CommandProc];  procs: LONG POINTER TO ProcSeq ¬ z.NEW[ProcSeq[initTableSize]];  commandSeq: LONG POINTER TO StringSeq ¬    z.NEW[StringSeq[initTableSize]];  AddCommand: PUBLIC PROCEDURE [    name: LONG STRING, proc: MFTPDefs.CommandProc] =    BEGIN    ENABLE UNWIND => NULL;    index: CARDINAL;    index ¬ StringLookUp.InTable[      name, DESCRIPTOR[@commandSeq[0], commandSeq.commandCount]];    IF index < commandSeq.commandCount THEN {      IF commandSeq[index].length = name.length THEN {procs[index] ¬ proc; RETURN}};    IF commandSeq.commandCount = tableSize THEN EnlargeTable[];    commandSeq[commandSeq.commandCount] ¬      String.CopyToNewString[name, z];    procs[commandSeq.commandCount] ¬ proc;    commandSeq.commandCount ¬ commandSeq.commandCount + 1;    END;  Command: PUBLIC PROCEDURE [    h: MFTPDefs.Handle, name, switches: LONG STRING]    RETURNS [mode: MFTPDefs.CommandMode, arg: MFTPDefs.ArgumentProc] =    BEGIN OPEN MFTPDefs;    ENABLE UNWIND => NULL;    index: CARDINAL;    proc: CommandProc ¬ NIL;    badCommand: BOOLEAN ¬ FALSE;    index ¬ StringLookUp.InTable[      name, DESCRIPTOR[@commandSeq[0], commandSeq.commandCount]];    IF index = StringLookUp.ambiguous OR index = StringLookUp.emptyKey THEN      badCommand ¬ TRUE;    IF index = StringLookUp.noMatch THEN {      IF switches.length = 0 AND h.host.length = 0 THEN {        BackupCommand[h]; proc ¬ OpenCommand}      ELSE badCommand ¬ TRUE}    ELSE proc ¬ procs[index];    IF badCommand THEN      BEGIN      h.write[name];      h.write[" ? Unknown Command "L];      ERROR FileTransfer.Error[NIL, unknown];      END    ELSE [mode, arg] ¬ proc[h, switches];    END;  EnlargeTable: PROCEDURE =    BEGIN    newCommands: LONG POINTER TO StringSeq ¬      z.NEW[StringSeq[(tableSize + tableInc)]];    newProcs: LONG POINTER TO ProcSeq ¬      z.NEW[ProcSeq[(tableSize + tableInc)]];    Inline.LongCOPY[      from: @commandSeq[0], nwords: tableSize*SIZE[LONG STRING],      to: @newCommands[0]];    newCommands.commandCount ¬ commandSeq.commandCount;    Inline.LongCOPY[      from: @procs[0], nwords: tableSize*SIZE[MFTPDefs.CommandProc],      to: @newProcs[0]];    z.FREE[@commandSeq];    z.FREE[@procs];    procs ¬ newProcs;    commandSeq ¬ newCommands;    tableSize ¬ tableSize + tableInc;    END;  END...
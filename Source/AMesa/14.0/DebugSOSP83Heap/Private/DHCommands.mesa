-- File: [Igor]<Emerson>DebugHeap>Private>DHCommands.mesa - last edit: -- Karlton,	20-Nov-81 19:54:21-- Smokey,	 9-Feb-81 12:12:10-- Mark,	11-Mar-81  0:57:34-- Bruce,	17-Dec-80 11:48:48-- JGS on	10-Jan-83 10:42:52-- elliott on	20-May-83 11:04:17-- Saaranzin	 3-Aug-84 12:28:44DIRECTORY  Ascii USING [CR, SP, TAB],  DH,  DHTree USING [    CompareProc, Comparison, CopyProc, FreeValueNOOP,     Handle, Insert, Object, Traverse, Tree, treeNil, Value, ValueRec],  DebugUsefulDefs USING [    InvalidFrame, InvalidAddress, Lengthen, StringExpToOctal],  DebugUsefulDefsExtras USING [    GFHandle, Name],  Format USING [NumberFormat],  FormSW USING [    DisplayItem, EnumeratedNotifyProcType, LongNumberNotifyProcType],  Heap USING [Create, Delete, systemZone],  Inline USING [BITAND, LowHalf],  Menu USING [MCRType],  Process USING [Detach],  Put USING [    Blanks, Char, CR, CurrentSelection, Decimal, LongDecimal, LongNumber,    LongOctal, Number, Octal, Text],  Selection USING [Convert, Number, Source],  Space USING [PageNumber, PageFromLongPointer],  String USING [    AppendCharAndGrow, AppendString, InvalidNumber, Empty, StringToLongNumber, StringToNumber,    SubStringDescriptor],  UserInput USING [UserAbort],  UserTerminal USING [BlinkDisplay],  Window USING [Handle];DHCommands: PROGRAM  IMPORTS    DH, DebugUsefulDefs, DebugUsefulDefsExtras, FormSW, Heap, Inline, Process, Put,    Selection, Space, String, DHTree, UserInput, UserTerminal  EXPORTS DH =  BEGIN OPEN DH;  itemsPerLine: CARDINAL = 8;  TwoChars: TYPE = RECORD [lh: CHARACTER, rh: CHARACTER];  DoingDelta: PROCEDURE RETURNS [BOOLEAN] = INLINE {    RETURN[stuff.deltas AND stuff.savedNodeChain # NIL]};  Aborted: PROCEDURE RETURNS [BOOLEAN] = INLINE {    RETURN[UserInput.UserAbort[stuff.logSW]]};  stuff: DH.ToolData ¬ NIL;  z: UNCOUNTED ZONE;  InitDHCommands: PUBLIC PROC [data: DH.ToolData] = {stuff ¬ data; z ¬ data.zone};  FinishDHCommands: PUBLIC PROC = {stuff ¬ NIL; z ¬ NIL};    PutToLog: PROC [s: LONG STRING] = {Put.Text[stuff.logSW, s]};    --  Menu and Form routines  BadAddress: PROCEDURE [address: LONG POINTER] =    BEGIN OPEN stuff;    PutToLog["*** InvalidAddress = "L];    Put.LongOctal[logSW, address];    PutToLog[" ***\n"L];    END;      MCR: PUBLIC Menu.MCRType = {    IF stuff.toolIsBusy THEN {      PutToLog["DebugHeap is busy."L];      UserTerminal.BlinkDisplay[];      RETURN};    stuff.toolIsBusy ¬ TRUE;    Process.Detach[FORK DoMenuCommand[window, menu, index]]};  DoMenuCommand: Menu.MCRType = {    ENABLE {      String.InvalidNumber => {        PutToLog["*** InvalidNumber = "L]; GOTO Error};      DebugUsefulDefs.InvalidAddress => {BadAddress[address];        GOTO Error};      InvalidZone => {        PutToLog["\n*** Error: specified Zone Address is not a ZONE ***\n"L];        GOTO Error};      SuspiciousZone => {        PutToLog[	  "\n*** Warning: specified Zone Address (ZoneHeader) looks suspicious ***\n"L];        IF stuff.warnedHim THEN RESUME        ELSE {stuff.warnedHim ¬ TRUE; GOTO Error};        };      ABORTED => {PutToLog[" XXX\n"L]; GOTO Error}};    SetupPointers[NIL];    SELECT index FROM      MenuCmd.ascii.ORD => DisplayHeapGuys[DisplayHeapString];      MenuCmd.clear.ORD =>        BEGIN        PutToLog["\nClearState..."L];        stuff.savedNodeChain ¬ DestroyNodeChain[stuff.savedNodeChain];        PutToLog["done\n"L];        END;      MenuCmd.client.ORD =>        IF stuff.clientWords = 0 THEN PutToLog["No client words!\n"L]        ELSE DisplayHeapGuys[DisplayHeapClientWords];      MenuCmd.freeNodes.ORD => {        PutToLog["\nFreeNodes "L]; FreeNodes[]; Put.CR[stuff.logSW]};      MenuCmd.nodeOwners.ORD =>        IF stuff.clientWords # 1 THEN PutToLog["Incorrect client words!\n"L]        ELSE DisplayNodeOwners[suppress: FALSE];      MenuCmd.nodes.ORD => {        PutToLog["\nShowNodes "L]; ShowNodes[FALSE]; Put.CR[stuff.logSW]};      MenuCmd.nodesOfSize.ORD =>        BEGIN        size: CARDINAL ¬ Selection.Number[ ! String.InvalidNumber => GOTO Blink];        PutToLog["\nNodesOfSize "L];        Put.CurrentSelection[stuff.logSW];        IF DoingDelta[] THEN PutToLog["(delta's only)"L];        PutToLog[":\n"L];        NodesOfSize[size];        Put.CR[stuff.logSW];        END;      MenuCmd.octal.ORD => DisplayHeapGuys[DisplayHeapItem];      MenuCmd.ownerTotals.ORD => {        PutToLog["\nTotals..."L];        IF stuff.clientWords # 1 THEN PutToLog["Incorrect client words!\n"L]        ELSE DisplayNodeOwners[suppress: TRUE]};      MenuCmd.save.ORD => {        PutToLog["\nSaveState..."L]; ShowNodes[TRUE]; PutToLog["done\n"L]};      MenuCmd.segments.ORD => {        PutToLog["\nShowSegments "L]; ShowSegments[]; Put.CR[stuff.logSW]};      MenuCmd.setGfh.ORD =>        BEGIN        s: LONG STRING;        HeapGFH: CARDINAL;        IF (s ¬ Selection.Convert[string]) = NIL THEN GOTO Blink;        HeapGFH ¬ DebugUsefulDefs.StringExpToOctal[s];        IF DH.CheckGFH[LOOPHOLE[HeapGFH]] THEN {          stuff.lookup ¬ TRUE; SetupHeapImpl[LOOPHOLE[HeapGFH]]};        Heap.systemZone.FREE[@s];        END;      ENDCASE;    stuff.toolIsBusy ¬ FALSE;    EXITS      Blink => {        UserTerminal.BlinkDisplay[]; stuff.toolIsBusy ¬ FALSE};      Error => stuff.toolIsBusy ¬ FALSE};  --  HeapProc support Routines  DestroyNodeChain: PROCEDURE [chain: DH.NodeData] RETURNS [DH.NodeData] =    BEGIN OPEN stuff;    node: DH.NodeData ¬ chain;    UNTIL node = NIL DO      node ¬ node.link; z.FREE[@chain]; chain ¬ node; ENDLOOP;    RETURN[NIL];    END;  GetNodeData: PROCEDURE [    chain: LONG POINTER TO DH.NodeData, length: CARDINAL]    RETURNS [DH.NodeData] =    BEGIN OPEN stuff;    prev: DH.NodeData ¬ NIL;    nodeData: DH.NodeData ¬ chain^;    DO      IF nodeData = NIL OR nodeData.size > length THEN  -- put new guy here        BEGIN        newNode: DH.NodeData ¬ z.NEW[DH.NodeDataObject ¬ [          link: nodeData, size: length, count: 0,          array: z.NEW[DH.NodeSequence[10]]]];        IF prev = NIL THEN chain^ ¬ newNode ELSE prev.link ¬ newNode;        RETURN[newNode];        END;      IF nodeData.size = length THEN RETURN[nodeData];      prev ¬ nodeData;      nodeData ¬ nodeData.link;      ENDLOOP;    END;  GetSavedNodeData: PROCEDURE [nodeSize: CARDINAL]    RETURNS [DH.NodeData] =    BEGIN    nodeData: DH.NodeData ¬ stuff.savedNodeChain;    DO      IF nodeData = NIL OR nodeData.size > nodeSize THEN RETURN[NIL];      IF nodeData.size = nodeSize THEN RETURN[nodeData];      nodeData ¬ nodeData.link;      ENDLOOP;    END;  NodeIsNew: PROCEDURE [node: LONG POINTER, nodeSize: CARDINAL]    RETURNS [BOOLEAN] =    BEGIN    nodeData: DH.NodeData ¬ GetSavedNodeData[nodeSize];    IF nodeData = NIL OR ~DoingDelta[] THEN RETURN[TRUE];    FOR i: CARDINAL IN [0..nodeData.count) DO      IF node = nodeData.array[i] THEN RETURN[FALSE]; ENDLOOP;    RETURN[TRUE];    END;  HeapAddressAltered: PUBLIC FormSW.LongNumberNotifyProcType = {    stuff.warnedHim ¬ FALSE; stuff.lookup ¬ TRUE};  HeapModeAltered: PUBLIC FormSW.EnumeratedNotifyProcType = {    ENABLE {      DebugUsefulDefs.InvalidAddress => {BadAddress[stuff.address]; CONTINUE};      InvalidZone => {PutToLog["*** Invalid Zone specified ***\n"L]; CONTINUE};      InvalidHeap => {PutToLog["*** Invalid Heap specified ***\n"L]; CONTINUE}};    stuff.lookup ¬ TRUE;    PutToLog["*** Mode set to "L];    SELECT stuff.mode FROM      systemMDS => PutToLog["systemMDSZone"L];      system => PutToLog["systemZone"L];      heapMDS => PutToLog["heapMDS"L];      heap => PutToLog["heap"L];      ENDCASE;    PutToLog[" ***\n"L];    SetupPointers[NIL]};  SetupPointers: PUBLIC PROC [address: POINTER] = {    OPEN h: stuff;    IF ~h.lookup THEN RETURN;    h.currentHeap ¬ NIL;    DH.SetupHeapImpl[LOOPHOLE[address]];    IF h.address # NIL THEN h.lookup ¬ FALSE;    NoticeNewState[]};  NoticeNewState: PROC = {    ENABLE {      DebugUsefulDefs.InvalidAddress => {BadAddress[stuff.address]; CONTINUE};      InvalidZone => {PutToLog["*** Invalid Zone specified ***\n"L]; CONTINUE};      InvalidHeap => {PutToLog["*** Invalid Heap specified ***\n"L]; CONTINUE}};    PutToLog["*** Debugging "L];    SELECT stuff.mode FROM      systemMDS => {        vHeap: Handle ¬ VirtualHandle[	  stuff.currentHeap ¬ SetupHeapMDS[LOOPHOLE[stuff.systemMDS]]];        PutToLog["systemMDSZone"L];	PutToLog[", address: "L];	Put.Octal[stuff.logSW, stuff.systemMDS];	stuff.address ¬ DebugUsefulDefs.Lengthen[LOOPHOLE[stuff.systemMDS]];	FormSW.DisplayItem[stuff.formSW, FormIndex.address.ORD];	IF vHeap.ownerChecking THEN {	  stuff.clientWords ¬ 1;	  FormSW.DisplayItem[stuff.formSW, FormIndex.cWords.ORD]}};      system => {        vHeap: Handle ¬ VirtualHandle[	  stuff.currentHeap ¬ SetupHeap[LOOPHOLE[stuff.systemZone]]];        PutToLog["systemZone"L];	PutToLog[", address: "L];	Put.LongOctal[stuff.logSW, LOOPHOLE[stuff.systemZone]];	WITH h: vHeap SELECT FROM	  uniform => {	    PutToLog[", uniform, object size: "L];	    Put.LongOctal[stuff.logSW, h.objectSize]};	  ENDCASE;	stuff.address ¬ LOOPHOLE[stuff.systemZone];	FormSW.DisplayItem[stuff.formSW, FormIndex.address.ORD];	IF vHeap.ownerChecking THEN {	  stuff.clientWords ¬ 1;	  FormSW.DisplayItem[stuff.formSW, FormIndex.cWords.ORD]}};      heapMDS => {        vHeap: Handle ¬ VirtualHandle[	  stuff.currentHeap ¬ SetupHeapMDS[Inline.LowHalf[stuff.address]]];        PutToLog["heapMDS"L];	PutToLog[", address: "L];	Put.LongOctal[stuff.logSW, stuff.address];	IF vHeap.ownerChecking THEN {	  stuff.clientWords ¬ 1;	  FormSW.DisplayItem[stuff.formSW, FormIndex.cWords.ORD]}};      heap => {        vHeap: Handle ¬ VirtualHandle[	  stuff.currentHeap ¬ SetupHeap[stuff.address]];        PutToLog["heap"L];	PutToLog[", address: "L];	Put.LongOctal[stuff.logSW, stuff.address];	WITH h: vHeap SELECT FROM	  uniform => {	    PutToLog[", uniform, object size: "L];	    Put.LongOctal[stuff.logSW, h.objectSize]};	  ENDCASE;	IF vHeap.ownerChecking THEN {	  stuff.clientWords ¬ 1;	  FormSW.DisplayItem[stuff.formSW, FormIndex.cWords.ORD]}};      ENDCASE};  --  Heap (FSP) Display Routines   DisplayHeapGuys: PROCEDURE [proc: PROCEDURE [NodeAddress]] =    BEGIN OPEN stuff;    PerToken: PROCEDURE [string: LONG STRING] RETURNS [BOOLEAN] =      BEGIN      n: LONG CARDINAL = String.StringToLongNumber[        string, 8 !        String.InvalidNumber => {          PutToLog["...InvalidNumber\n"L]; GOTO blink}];      proc[LOOPHOLE[n]];      IF Aborted[] THEN {PutToLog["...aborted\n"L]; GOTO blink};      Put.CR[logSW];      RETURN[FALSE];      EXITS blink => {UserTerminal.BlinkDisplay[]; RETURN[TRUE]};      END;    EnumerateSelectionTokens[PerToken];    END;  EnumerateSelectionTokens: PROCEDURE [    proc: PROCEDURE [LONG STRING] RETURNS [BOOLEAN]] = {    token: LONG STRING ¬ NIL;    string: STRING ¬ [40];    source: Selection.Source ¬ Selection.Convert[source];    IF source # NIL THEN {      ENABLE UNWIND => {source.destroy[source]; z.FREE[@token]};      token ¬ z.NEW[StringBody[100]];      DO        string.length ¬ 0;        source.proc[source.data, string];        IF string.length = 0 THEN EXIT;        FOR i: CARDINAL IN [0..string.length) DO          SELECT string[i] FROM            Ascii.CR, Ascii.SP, Ascii.TAB, ', =>              IF token.length # 0 THEN {	        IF proc[token] THEN {		  z.FREE[@token]; source.destroy[source]; RETURN};		token.length ¬ 0};            ENDCASE => String.AppendCharAndGrow[@token, string[i], z];          ENDLOOP;        ENDLOOP;      IF token.length # 0 THEN [] ¬ proc[token];      z.FREE[@token];      source.destroy[source]};    RETURN};  EnumerateStringTokens: PROCEDURE [    s: LONG STRING, proc: PROCEDURE [LONG STRING] RETURNS [BOOLEAN]] =    BEGIN    temp: LONG STRING ¬ NIL;    IF ~String.Empty[s] THEN {      ENABLE UNWIND => z.FREE[@temp];      ss: String.SubStringDescriptor ¬ [base: s, length: s.length, offset: 0];      temp ¬ z.NEW[StringBody[100]];      DO        IF ss.offset = ss.length THEN EXIT;        temp.length ¬ 0;        FOR i: CARDINAL IN [ss.offset..ss.length) DO          SELECT ss.base[i] FROM            Ascii.SP, Ascii.CR, ',, '. =>              IF temp.length = 0 THEN LOOP ELSE {ss.offset ¬ i + 1; EXIT};            ENDCASE;          String.AppendCharAndGrow[@temp, ss.base[i], z];          REPEAT FINISHED => ss.offset ¬ ss.length;          ENDLOOP;        IF proc[temp] THEN EXIT;        ENDLOOP};    END;  ValuesFromString: PROCEDURE [s: LONG STRING] RETURNS [values: Values] = {    i: CARDINAL ¬ 0;    Count: PROCEDURE [s: LONG STRING] RETURNS [BOOLEAN] = {      i ¬ i + 1;      [] ¬ String.StringToNumber[s, 8];  -- Easy cleanup.  Who cares if it's slow?      RETURN[FALSE]};    Build: PROCEDURE [s: LONG STRING] RETURNS [BOOLEAN] = {      words: Words = z.NEW[WordSeq [1]];      words[0] ¬ String.StringToNumber[s, 8];      values[i] ¬ words;      i ¬ i + 1;      RETURN[FALSE]};    EnumerateStringTokens[stuff.clientValue, Count];    IF i = 0 THEN RETURN[NIL];    values ¬ z.NEW[ValueSeq [i]];    i ¬ 0;    EnumerateStringTokens[stuff.clientValue, Build];    };  FreeValues: PROC [v: Values] = {    IF v = NIL THEN RETURN;    FOR i: CARDINAL IN [0..v.maxlength) DO z.FREE[@v[i]]; ENDLOOP;    z.FREE[@v]};  DisplayHeapClientWords: PUBLIC PROCEDURE [p: NodeAddress] = {    OPEN stuff;    found: BOOLEAN ¬ FALSE;    DisplayNodeContents: NodeEnumProc = {      name: LONG STRING ¬ [50];      IF node = p THEN {        found ¬ TRUE;        FOR i: CARDINAL IN [0..clientWords) DO          IF Aborted[] THEN RETURN[TRUE];          IF i MOD 8 = 0 THEN {            IF i # 0 THEN Put.CR[logSW];            Put.LongOctal[logSW, node + i];            Put.Char[logSW, '/]};          Put.Char[logSW, Ascii.SP];          Put.Octal[logSW, Read[node + i]];	  Put.Text[logSW, " ("];	  name.length ¬ 0;	  DebugUsefulDefsExtras.Name[name, Read[node + i] !	    DebugUsefulDefs.InvalidFrame => {	      name ¬ "Invalid frame!"L; CONTINUE}];	  Put.Text[logSW, name];	  Put.Char[logSW, ')];          ENDLOOP;        RETURN[TRUE]};      RETURN[FALSE]};    IF validate THEN {      [] ¬ EnumerateNodes[heap: stuff.currentHeap, proc: DisplayNodeContents];      IF ~found THEN PutToLog["Not a Heap node\n"L]}    ELSE CallNodeEnumProc[DisplayNodeContents, p]};  DisplayHeapItem: PUBLIC PROCEDURE [p: NodeAddress] = {    OPEN stuff;    i: CARDINAL;    found: BOOLEAN ¬ FALSE;    DisplayNodeContents: NodeEnumProc = {      IF node = p THEN {        found ¬ TRUE;        FOR i IN [clientWords..size) DO          IF Aborted[] THEN RETURN[TRUE];          IF (i - clientWords) MOD 8 = 0 THEN {            IF i - clientWords # 0 THEN Put.CR[logSW];            Put.LongOctal[logSW, node + i];            Put.Char[logSW, '/]};          Put.Char[logSW, Ascii.SP];          Put.Octal[logSW, Read[node + i]];          ENDLOOP;        RETURN[TRUE]};      RETURN[FALSE]};    IF validate THEN {      [] ¬ EnumerateNodes[heap: stuff.currentHeap, proc: DisplayNodeContents];      IF ~found THEN PutToLog["Not a Heap node\n"L]}    ELSE CallNodeEnumProc[DisplayNodeContents, p]};  DisplayHeapNumbers: PROCEDURE =    BEGIN OPEN stuff;    node: DH.NodeData ¬ nodeChain;    i: CARDINAL ¬ 0;    count: INTEGER;    savedNodeData: DH.NodeData;    commaState: DH.CommaState ¬ notGoing;    IF DoingDelta[] THEN PutToLog["(delta's)"L];    PutToLog[" Used: "L];    Put.LongDecimal[      logSW, fspUsedCount - (IF DoingDelta[] THEN savedUsedCount ELSE 0)];    PutToLog[", Free: "L];    Put.LongDecimal[      logSW, fspFreeCount - (IF DoingDelta[] THEN savedFreeCount ELSE 0)];    Put.CR[logSW];    PutToLog["  "L];    UNTIL node = NIL DO      savedNodeData ¬ GetSavedNodeData[node.size];      count ¬        INTEGER[node.count] -          (IF DoingDelta[] AND savedNodeData # NIL THEN savedNodeData.count           ELSE 0);      IF count # 0 THEN        BEGIN        SELECT commaState FROM          notGoing => commaState ¬ sameLine;          sameLine => PutToLog[", "L];          newLine => {            PutToLog[",\n"L]; PutToLog["  "L]; commaState ¬ sameLine};          ENDCASE;        Put.Decimal[logSW, node.size];        Put.Char[logSW, '(];        Put.Decimal[logSW, count];        Put.Char[logSW, ')];        IF i = itemsPerLine THEN {i ¬ 0; commaState ¬ newLine} ELSE i ¬ i + 1;        END;      node ¬ node.link;      ENDLOOP;    END;  DisplayHeapString: PUBLIC PROCEDURE [p: NodeAddress] = {    OPEN stuff;    found: BOOLEAN ¬ FALSE;    DisplayNodeContents: NodeEnumProc = {      IF Aborted[] THEN RETURN[TRUE];      IF node = p THEN {        stringStart: LONG POINTER = node + clientWords;        overhead: CARDINAL = clientWords + SIZE[StringBody[0]];        length, maxLength: CARDINAL;        found ¬ TRUE;        length ¬ Read[stringStart];        maxLength ¬ Read[stringStart + SIZE[CARDINAL]];        Put.LongOctal[logSW, stringStart];        Put.Char[logSW, '/];        PutToLog[" ("L];        Put.Decimal[logSW, length];        Put.Char[logSW, ',];        Put.Decimal[logSW, maxLength];        Put.Char[logSW, ')];        IF validate AND (length > maxLength OR length > 4000 	  OR SIZE[StringBody[maxLength]] > size-(clientWords)) THEN          PutToLog[" STRING length suspicious - Not Printed"L]        ELSE {          word: TwoChars;          Put.Char[logSW, '"];          FOR i: CARDINAL IN [overhead..IF validate THEN overhead+(length+1)/2 ELSE size) DO	  -- print 2*(i-overhead)th byte and maybe the next one            IF Aborted[] THEN RETURN[FALSE];            word ¬ Read[node + i];            Put.Char[logSW, word.lh];            IF ~(validate AND (2*(i-overhead)+1 >= length)) THEN Put.Char[logSW, word.rh];            ENDLOOP;          Put.Char[logSW, '"]};        RETURN[TRUE]};      RETURN[FALSE]};    IF validate THEN {      [] ¬ EnumerateNodes[heap: stuff.currentHeap, proc: DisplayNodeContents];      IF ~found THEN PutToLog["Not a Heap string\n"L]}    ELSE CallNodeEnumProc[DisplayNodeContents, p]};  NodesOfSize: PUBLIC PROCEDURE [size: CARDINAL] = {    OPEN stuff;    filter: FilterObject ¬ [      size, swapStatus, clientWords, LOOPHOLE[@mask, Words],      ValuesFromString[clientValue]];    i: CARDINAL ¬ 0;    commaState: DH.CommaState ¬ notGoing;    foundOne: BOOLEAN ¬ FALSE;    DisplayNodeAddress: NodeEnumProc = {      IF Aborted[] THEN RETURN[TRUE];      IF inUse AND NodeIsNew[node, size] THEN {        foundOne ¬ TRUE;        SELECT commaState FROM          notGoing => commaState ¬ sameLine;          sameLine => PutToLog[", "L];          newLine => {            PutToLog[",\n"L]; PutToLog["  "L]; commaState ¬ sameLine};          ENDCASE;        Put.LongOctal[logSW, node];        IF i = itemsPerLine THEN {i ¬ 0; commaState ¬ newLine} ELSE i ¬ i + 1};      RETURN[FALSE]};    PutToLog["  "L];    [] ¬ EnumerateNodes[heap: stuff.currentHeap, proc: DisplayNodeAddress,      filter: @filter ! UNWIND => FreeValues[filter.values]];    FreeValues[filter.values];    IF ~foundOne THEN PutToLog[" No new nodes of this size"L]};  DisplayNodeOwners: PUBLIC PROCEDURE [suppress: BOOLEAN] =    BEGIN OPEN stuff;    filter: FilterObject ¬ [      0, swapStatus, clientWords, LOOPHOLE[@mask, Words], ValuesFromString[      clientValue]];    valueRec: DHTree.ValueRec;    tree: DHTree.Tree ¬ DHTree.treeNil;    localZone: UNCOUNTED ZONE = Heap.Create[2];    obj: DHTree.Object ¬ [localZone, Copy, Compare, DHTree.FreeValueNOOP];    tH: DHTree.Handle = @obj;    LocalAbort: ERROR = CODE;    Compare: DHTree.CompareProc = {      IF value1.gf = value2.gf THEN {        value1.nodes ¬ value1.nodes + 1;        value1.words ¬ value1.words + value2.words;        RETURN[equal]};      RETURN[        IF LOOPHOLE[value1.gf, CARDINAL] < LOOPHOLE[value2.gf, CARDINAL] THEN less        ELSE greater]};    Copy: DHTree.CopyProc = {RETURN[z.NEW[DHTree.ValueRec ¬ value^]]};    fmt: Format.NumberFormat ¬ [      base: 10, zerofill: FALSE, unsigned: TRUE, columns: 12];    PutTotals: PROC [tree: DHTree.Tree] =      BEGIN      nodeTotal, wordTotal: LONG CARDINAL ¬ 0;      PerFrame: PROC [tree: DHTree.Tree] = {        IF Aborted[] THEN ERROR LocalAbort;        nodeTotal ¬ nodeTotal + tree.value.nodes;        wordTotal ¬ wordTotal + tree.value.words;        PutNumbers[tree.value.nodes, tree.value.words];        Put.Blanks[logSW, 4];        PutGF[tree.value.gf]};      PutToLog[" Total-Nodes Total-Words\n"L];      DHTree.Traverse[tH, tree, PerFrame];      PutToLog["------------------------------------------------\n"L];      PutNumbers[nodeTotal, wordTotal];      PutToLog["    Totals\n"L];      EXITS       END;    gfLast: DebugUsefulDefsExtras.GFHandle ¬ LOOPHOLE[NIL];    name: STRING ¬ [50];    PutGF: PROC [gf: DebugUsefulDefsExtras.GFHandle] = {      IF gf # gfLast THEN {        gfLast ¬ gf;        name.length ¬ 0;        DebugUsefulDefsExtras.Name[name, gf !          DebugUsefulDefs.InvalidFrame => {            String.AppendString[name, "Invalid frame!"L]; CONTINUE}]};      PutToLog[name];      PutToLog[", G: "L];      Put.Octal[logSW, gf];      Put.CR[logSW]};    PutNumbers: PROC [nodes, words: LONG CARDINAL] = {      Put.LongNumber[logSW, nodes, fmt]; Put.LongNumber[logSW, words, fmt]};    lastPage: Space.PageNumber ¬ 0;    DisplayNodeAddress: NodeEnumProc =      BEGIN      IF Aborted[] THEN ERROR LocalAbort;      IF NodeIsNew[node, size] THEN        BEGIN        gf: DebugUsefulDefsExtras.GFHandle;        IF inUse THEN {          gf ¬ Inline.BITAND[Read[node], 177774B];          valueRec ¬ [gf: gf, nodes: 1, words: size, overhead:];          tree ¬ DHTree.Insert[tH, tree, @valueRec]};        IF ~suppress AND (inUse OR filter.values = NIL) THEN {          IF lastPage#Space.PageFromLongPointer[node] THEN {	    lastPage ¬ Space.PageFromLongPointer[node];	    PutToLog["page:"L];	    Put.LongOctal[logSW, lastPage];	    Put.CR[logSW]};	  Put.LongNumber[            logSW, node, Format.NumberFormat[            base: 8, zerofill: FALSE, unsigned: TRUE, columns: 8]];          Put.Char[logSW, 'B];          Put.Number[            logSW, size, Format.NumberFormat[            base: 10, zerofill: FALSE, unsigned: TRUE, columns: 8]];          PutToLog[" 	"L];          IF inUse THEN PutGF[gf] ELSE PutToLog["(free node)\n"L]};        END;      RETURN[FALSE]      END;    CleanUp: PROC = {Heap.Delete[localZone]; FreeValues[filter.values]};    Put.CR[logSW];    IF ~suppress THEN PutToLog["  Node       Length       Module\n"L];    {ENABLE UNWIND => CleanUp[];    [] ¬ EnumerateNodes[heap: stuff.currentHeap, proc: DisplayNodeAddress,      filter: @filter ! LocalAbort => GOTO out];    IF tree = DHTree.treeNil THEN PutToLog[" No new nodes found"L]    ELSE PutTotals[tree ! LocalAbort => GOTO out];    EXITS      out => PutToLog["Aborted ...\n"L];    };    CleanUp[];    END;  FreeNodes: PROCEDURE =    BEGIN OPEN stuff;    i: CARDINAL ¬ 0;    nPerLine: CARDINAL = 6;    commaState: DH.CommaState ¬ notGoing;    PerNode: NodeEnumProc =      BEGIN      IF Aborted[] THEN RETURN[TRUE];      IF ~inUse THEN        BEGIN        SELECT commaState FROM          notGoing => commaState ¬ sameLine;          sameLine => PutToLog[", "L];          newLine => {            PutToLog[",\n"L]; PutToLog["  "L]; commaState ¬ sameLine};          ENDCASE;        Put.LongOctal[logSW, node];        Put.Char[logSW, '(];        Put.Decimal[logSW, size];        Put.Char[logSW, ')];        IF (i ¬ i + 1) = nPerLine THEN {i ¬ 0; commaState ¬ newLine};        END;      RETURN[FALSE];      END;    filter: FilterObject ¬ [      0, swapStatus, clientWords, LOOPHOLE[@mask, Words], ValuesFromString[      clientValue]];    PutToLog["Address(size)\n  "L];    [] ¬ EnumerateNodes[heap: stuff.currentHeap, proc: PerNode, filter: @filter !      UNWIND => FreeValues[filter.values]];    FreeValues[filter.values];    END;  ShowNodes: PUBLIC PROCEDURE [save: BOOLEAN] =    BEGIN OPEN stuff;    ExpandNodeArray: PROCEDURE [node: DH.NodeData] =      BEGIN      oldLength: CARDINAL = node.array.length;      savedArray: LONG POINTER TO DH.NodeSequence ¬ node.array;      node.array ¬ z.NEW[NodeSequence[oldLength + 10]];      FOR i: CARDINAL IN [0..oldLength) DO        node.array[i] ¬ savedArray[i]; ENDLOOP;      IF savedArray # NIL THEN z.FREE[@savedArray];      END;    PerNode: NodeEnumProc =      BEGIN      IF Aborted[] THEN RETURN[TRUE];      SELECT inUse FROM        TRUE =>          BEGIN          nodeT: DH.NodeData ¬ GetNodeData[@nodeChain, size];          IF save THEN            BEGIN            IF nodeT.array.length = nodeT.count THEN ExpandNodeArray[nodeT];            nodeT.array[nodeT.count] ¬ node;            END;          nodeT.count ¬ nodeT.count + 1;          fspUsedCount ¬ fspUsedCount + size;          END;        FALSE => fspFreeCount ¬ fspFreeCount + size;        ENDCASE;      RETURN[FALSE];      END;    filter: FilterObject ¬ [      0, swapStatus, clientWords, LOOPHOLE[@mask, Words], ValuesFromString[      clientValue]];    IF save THEN savedNodeChain ¬ DestroyNodeChain[savedNodeChain];    fspFreeCount ¬ fspUsedCount ¬ 0;    [] ¬ EnumerateNodes[heap: stuff.currentHeap, proc: PerNode, filter: @filter !      UNWIND => FreeValues[filter.values]];    FreeValues[filter.values];    IF save THEN      BEGIN      savedFreeCount ¬ fspFreeCount;      savedUsedCount ¬ fspUsedCount;      savedNodeChain ¬ nodeChain;      nodeChain ¬ NIL;      END    ELSE DisplayHeapNumbers[];    nodeChain ¬ DestroyNodeChain[nodeChain];    END;  ShowSegments: PUBLIC PROCEDURE =    BEGIN OPEN stuff;    DisplayChunks: ChunkEnumProc =      BEGIN      IF Aborted[] THEN RETURN[TRUE];      PutToLog[",\n  "L];      Put.LongOctal[logSW, Space.PageFromLongPointer[chunk]];      PutToLog[": "L];      Put.LongOctal[logSW, chunk];      Put.Char[logSW, '(];      Put.Decimal[logSW, size];      Put.Char[logSW, ')];      RETURN[FALSE];      END;    PutToLog["page: Address(length)"L];    [] ¬ EnumerateChunks[stuff.currentHeap, DisplayChunks];    END;  CallNodeEnumProc: PROC [proc: NodeEnumProc, n: NodeAddress] = {    FindUniformNode: NodeEnumProc = {      IF node = n THEN {[] ¬ proc[node, size, inUse]; RETURN[TRUE]};      RETURN[FALSE]};    IF stuff.currentHeap # NIL      AND VirtualHandle[stuff.currentHeap].tag = uniform THEN       [] ¬ EnumerateNodes[stuff.currentHeap, FindUniformNode]    ELSE {      vnp: NodeHandle = VirtualNodeHandle[LOOPHOLE[n]];      [] ¬ proc[n, vnp.length, NodeInUse[vnp]]};          RETURN};      NodeInUse: PROCEDURE [vnp: NodeHandle] RETURNS [BOOLEAN ¬ TRUE] = {RETURN[TRUE]};  END...
-- Copyright (C) 1984 by Xerox Corporation. All rights reserved.-- OMFTester.mesa  -- last edited by Dennis E. DEG      @ 15-Jan-84 21:53:51-- last edited by Frank FXB    @  3-Dec-84 10:20:09DIRECTORY  Exec USING [ExecProc, OutputProc, GetToken, FreeTokenString, AddCommand],  Format USING [Text, Line, StringProc],  Heap USING [Create, Delete, Error, ErrorType],  MFile USING [Error, ErrorCode],  MSegment USING [Error, ErrorCode],  MStream USING [Error, ErrorCode],  ReportMError,  OMF;OMFTester: PROGRAM  IMPORTS Exec, Format, Heap, MFile, MSegment, MStream, OMF, ReportMError =  BEGIN  handle: OMF.Handle ¬ NIL;  riheap: UNCOUNTED ZONE ¬ NIL;  outputProc: Format.StringProc ¬ {};  outputHandle: OMF.Handle ¬ NIL;  DeleteExtension: PROCEDURE [name: LONG STRING] =    BEGIN    IF name = NIL THEN RETURN;    FOR index: CARDINAL IN [0..name.length) DO      IF name[index] = '. THEN {name.length ¬ index; RETURN}; ENDLOOP;    END;  DisplayOMFError: PROCEDURE [type: OMF.ErrorType, Write: Format.StringProc] = {    SELECT type FROM      endOfFile => Format.Line[Write, "OMFError: endOfFile"L];      invalidChecksum => Format.Line[Write, "OMFError: invalidChecksum"L];      invalidHandle => Format.Line[Write, "OMFError: invalidHandle"L];      invalidRequest => Format.Line[Write, "OMFError: invalidRequest"L];      malformedRecord => Format.Line[Write, "OMFError: malformedRecord"L];      noSuchFile => Format.Line[Write, "OMFError: noSuchFile"L];      ENDCASE => Format.Line[Write, "OMFError: unexpected error type"L];    };  DisplayRecordType: PROCEDURE [    recordType: OMF.RecordType, Write: Format.StringProc] = {    SELECT recordType FROM      blockDefinition => Format.Line[Write, "blockDefinition"];      blockEnd => Format.Line[Write, "blockEnd"];      comment => Format.Line[Write, "comment"];      debugSymbol => Format.Line[Write, "debugSymbol"];      endRecord => Format.Line[Write, "endRecord"];      externalDefinition => Format.Line[Write, "externalDefinition"];      fixUp => Format.Line[Write, "fixUp"];      groupDefinition => Format.Line[Write, "groupDefinition"];      lHeader => Format.Line[Write, "lHeader"];      libraryDictionary => Format.Line[Write, "libraryDictionary"];      libraryHeader => Format.Line[Write, "libraryHeader"];      libraryModuleLocations => Format.Line[Write, "libraryModuleLocations"];      libraryModuleNames => Format.Line[Write, "libraryModuleNames"];      lineNumber => Format.Line[Write, "lineNumber"];      listOfNames => Format.Line[Write, "listOfNames"];      localSymbol => Format.Line[Write, "localSymbol"];      logicalEnumeratedData => Format.Line[Write, "logicalEnumeratedData"];      logicalIteratedData => Format.Line[Write, "logicalIteratedData"];      moduleEnd => Format.Line[Write, "moduleEnd"];      overlayDefinition => Format.Line[Write, "overlayDefinition"];      physicalEnumeratedData => Format.Line[Write, "physicalEnumeratedData"];      physicalIteratedData => Format.Line[Write, "physicalIteratedData"];      publicDefinition => Format.Line[Write, "publicDefinition"];      registerInitialization => Format.Line[Write, "registerInitialization"];      relocatableEnumeratedData => Format.Line[Write, "relocatableEnumeratedData"];      relocatableIteratedData => Format.Line[Write, "relocatableIteratedData"];      rHeader => Format.Line[Write, "rHeader"];      segmentDefinition => Format.Line[Write, "segmentDefinition"];      tHeader => Format.Line[Write, "tHeader"];      typeDefinition => Format.Line[Write, "typeDefinition"];      ENDCASE => Format.Line[Write, "ERROR ILLEGAL RECORD TYPE"];    };  ProcessFile: PROCEDURE [fileName: LONG STRING, Write: Format.StringProc] =    BEGIN    recordType, oldRecordType: OMF.RecordType ¬ null;    endOfInput: BOOLEAN ¬ FALSE;    CleanUp: PROCEDURE =      BEGIN      handle ¬ OMF.ReleaseHandle[handle: handle];      outputHandle ¬ OMF.ReleaseHandle[handle: outputHandle];      IF riheap # NIL THEN {Heap.Delete[z: riheap]; riheap ¬ NIL};      END;    BEGIN    ENABLE      BEGIN      OMF.Error => {DisplayOMFError[type, Write]; GOTO exit};      MSegment.Error => {ReportMError.MSegmentError[code, Write]; GOTO exit};      Heap.Error => {ReportMError.HeapError[type, Write]; GOTO exit};      MFile.Error => {ReportMError.MFileError[code, Write, fileName]; GOTO exit};      MStream.Error => {        ReportMError.MStreamError[code, Write, fileName]; GOTO exit};      END;    riheap ¬ Heap.Create[initial: 8];    handle ¬ OMF.GetHandle[      operation: read, fileName: fileName, extension: "obj"L, heap: riheap];    DeleteExtension[fileName];    outputHandle ¬ OMF.GetHandle[      operation: write, fileName: fileName, extension: "lnk"L, heap: riheap];    UNTIL endOfInput DO      recordType ¬ OMF.GetRecordType[handle: handle];      IF recordType # comment THEN oldRecordType ¬ recordType;      DisplayRecordType[recordType: recordType, Write: Write];      SELECT recordType FROM        blockEnd => {OMF.PutBlockEnd[handle: outputHandle]};        blockDefinition => {          OMF.PutBlockDefinition[            blockPointer: OMF.GetBlockDefinition[handle: handle],            handle: outputHandle]};        comment => {          OMF.PutComment[            commentPtr: OMF.GetComment[handle: handle], handle: outputHandle]};        endRecord => {          OMF.PutEndRecord[            endType: OMF.GetEndRecord[handle], handle: outputHandle]};        debugSymbol => {          OMF.PutDebugSymbols[            debugSymbolsPtr: OMF.GetDebugSymbols[handle], handle: outputHandle]};        externalDefinition => {          OMF.PutExternalNames[            externalNamesPtr: OMF.GetExternalNames[handle], handle: outputHandle]};        fixUp => {          OMF.PutFixup[fixupPtr: OMF.GetFixup[handle], handle: outputHandle]};        groupDefinition => {          OMF.PutGroupDefinition[            groupDefinitionPtr: OMF.GetGroupDefinition[handle],            handle: outputHandle]};        lHeader => {          OMF.PutLModuleName[            lName: OMF.GetLModuleName[handle], handle: outputHandle]};        lineNumber => {          OMF.PutLineNumber[            lineNumberPtr: OMF.GetLineNumber[handle], handle: outputHandle]};        listOfNames => {          OMF.PutListOfNames[            nameList: OMF.GetListOfNames[handle], handle: outputHandle]};        logicalEnumeratedData => {          OMF.PutLogicalEnumeratedData[            logicalEnumeratedDataPtr: OMF.GetLogicalEnumeratedData[handle],            handle: outputHandle]};        logicalIteratedData => {          OMF.PutLogicalIteratedData[            logicalIteratedDataPtr: OMF.GetLogicalIteratedData[handle],            handle: outputHandle]};        moduleEnd => {          OMF.PutModuleEnd[            moduleEndRecordPtr: OMF.GetModuleEnd[handle], handle: outputHandle]};        physicalEnumeratedData => {          OMF.PutPhysicalEnumeratedData[            physicalEnumeratedDataPtr: OMF.GetPhysicalEnumeratedData[handle],            handle: outputHandle]};        physicalIteratedData => {          OMF.PutPhysicalIteratedData[            physicalIteratedDataPtr: OMF.GetPhysicalIteratedData[handle],            handle: outputHandle]};        publicDefinition => {          OMF.PutPublicNames[            publicNamesPtr: OMF.GetPublicNames[handle], handle: outputHandle]};        relocatableEnumeratedData => {          OMF.PutRelocatableEnumeratedData[            relocatableEnumeratedDataPtr: OMF.GetRelocatableEnumeratedData[handle],            handle: outputHandle]};        relocatableIteratedData => {          OMF.PutRelocatableIteratedData[            relocatableIteratedDataPtr: OMF.GetRelocatableIteratedData[handle],            handle: outputHandle]};        registerInitialization => {          OMF.PutRegisterInitialization[            registerInitPtr: OMF.GetRegisterInitialization[handle],            handle: outputHandle]};        segmentDefinition => {          OMF.PutSegmentDefinition[            segmentDefinitionPtr: OMF.GetSegmentDefinition[handle],            handle: outputHandle]};        tHeader => {          OMF.PutTModuleName[            tName: OMF.GetTModuleName[handle], handle: outputHandle]};        typeDefinition => {          OMF.PutTypeDefinition[            typeDefinitionPtr: OMF.GetTypeDefinition[handle],            handle: outputHandle]};        ENDCASE => {Format.Line[Write, "UNIMPLEMENTED TYPE IGNORED"L]};      endOfInput ¬ OMF.AdvanceToNextRecord[handle: handle];      ENDLOOP;    CleanUp[];    EXITS exit => CleanUp[];    END;    END;  Main: Exec.ExecProc = {    token, switches: LONG STRING ¬ NIL;    outputProc ¬ Exec.OutputProc[h];    DO      [token, switches] ¬ Exec.GetToken[h];      IF token = NIL THEN EXIT;      IF switches # NIL THEN switches ¬ Exec.FreeTokenString[switches];      Format.Text[outputProc, "\nProcessing file: "L];      Format.Line[outputProc, token];      ProcessFile[fileName: token, Write: outputProc];      Format.Text[outputProc, "\nDone Processing file: "L];      Format.Line[outputProc, token];      token ¬ Exec.FreeTokenString[token];      ENDLOOP;    IF switches # NIL THEN switches ¬ Exec.FreeTokenString[switches];    };  Init: PROCEDURE = {Exec.AddCommand["OMFTest.~"L, Main]; };  Init[];  END...    LOG  created by Dennis E. DEG      @  3-Nov-83 15:45:59
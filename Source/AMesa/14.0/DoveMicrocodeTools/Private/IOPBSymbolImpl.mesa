-- File: IOPBSymbolImpl.mesa - last edit:-- Bowers.PA           28-Jul-86 16:15:07-- FXB   .PA           20-May-85 11:31:52-- Copyright (C) 1984, 1985, 1986 by Xerox Corporation. All rights reserved.-- after IOPEvaler.mesa, HGM, 10-Feb-83 17:36:16DIRECTORY  Ascii USING [CR, LF, FF, SP, TAB],  Heap USING [systemZone],  Inline USING [LowHalf],  IOPB,  String,  StringExtras USING [StringToLongCardinal],  Evaluate USING [    Error, EvaluateString, EvaluateSubString, Type, unspecified, Value],  I186 USING [Address, Register],  IOPBSymbol USING [Symbol],  IOPBSymbolTable;IOPBSymbolImpl: PROGRAM  IMPORTS    Heap, IOPB, String, StringExtras, Evaluate, Inline, IOPBSymbolTable  EXPORTS IOPBSymbol =  BEGIN    st: ARRAY IOPB.Processor OF IOPBSymbolTable.Handle ¬ ALL [NIL];  AppendAddress: PUBLIC PROC [    s: LONG STRING, addr: I186.Address, processor: IOPB.Processor] = {    offset: LONG CARDINAL;    symbol: LONG STRING;    IF st[processor] = NIL AND processor = pc THEN       ERROR IOPB.Error[pcNotInitialized];    [symbol, offset] ¬ IOPBSymbolTable.GetSymbolForValue[      value: addr, h: st[processor]];    String.AppendString[s, symbol];    IF offset = 0 THEN RETURN;    String.AppendChar[s, '+];    String.AppendLongNumber[s, offset, 16];    };      AppendAddressType: PUBLIC PROC [s: LONG STRING, addrType: IOPB.AddressType] = {    String.AppendString[      s, SELECT addrType FROM            iop => ".I "L,            pc => ".P "L,            real => ".R "L,            vm => ".V "L,            ENDCASE => ERROR]};  AppendRegister: PUBLIC PROC [s: LONG STRING, reg: I186.Register] = {    String.AppendString[      s,      SELECT reg FROM        AX => "AX"L,        BX => "BX"L,        CX => "CX"L,        DX => "DX"L,        SP => "SP"L,        BP => "BP"L,        SI => "SI"L,        DI => "DI"L,        CS => "CS"L,        DS => "DS"L,        SS => "SS"L,        ES => "ES"L,        IP => "IP"L,        FLAGS => "FLAGS"L,        ENDCASE => ERROR];    };  CreateTables: PUBLIC PROC [processor: IOPB.Processor] = {    st[processor] ¬ IOPBSymbolTable.Create[];    };  DestroyTables: PUBLIC PROC [processor: IOPB.Processor] = {    st[processor] ¬ IOPBSymbolTable.Delete[st[processor]];    };  Enter: PUBLIC PROC [    s: LONG STRING, value: I186.Address, processor: IOPB.Processor] = {    invalidIndex: CARDINAL = 0;    new: BOOLEAN ¬ TRUE;    ste: IOPBSymbolTable.STEntry ¬ NIL;    oldIndex: CARDINAL ¬ 0;    IF st[processor] = NIL AND processor = pc THEN       ERROR IOPB.Error[pcNotInitialized];    [new, ste, oldIndex] ¬  IOPBSymbolTable.EnterSymbol[s: s, h: st[processor]];    IF new THEN      IOPBSymbolTable.EnterValue[	value: value, symbol: ste, h: st[processor] !	IOPBSymbolTable.Overflow => ERROR IOPB.Error[code: symbolTableOverflow]]      -- Change the value of an existing symbol if it      -- is not already in the current configuration      -- If the symbol is already in the current configuration,       -- then you may not have the correct addressMap index for it    ELSE       IOPBSymbolTable.ChangeValue[value: value, index: oldIndex, h: st[processor]]	};  Eval: PUBLIC PROC [    s: LONG STRING, dataType: IOPB.DataType, addressType: IOPB.AddressType,    wantNewString: BOOLEAN]    RETURNS [symbol: IOPBSymbol.Symbol, newS: LONG STRING] =    BEGIN    type: Evaluate.Type;    value: Evaluate.Value;    t: IOPB.SymbolType ¬ byte;    prefixLen: CARDINAL = 3;  --Address Type Prefix Length      ssd: String.SubStringDescriptor ¬ [      base: s, offset: prefixLen, length: s.length - prefixLen];    Lookup: PROC [s: LONG STRING]      RETURNS [type: Evaluate.Type, value: Evaluate.Value] =      BEGIN      ok: BOOLEAN;      address: I186.Address;      -- symbols are valid only for IOP and PC addresses      SELECT addressType FROM        iop => {          [ok, address] ¬ LookUpInSymbolTable[s, iop];          IF ok THEN RETURN[Evaluate.unspecified, address]};        pc => {          [ok, address] ¬ LookUpInSymbolTable[s, pc];          IF ok THEN RETURN[Evaluate.unspecified, address]};        ENDCASE => NULL;      [ok, address] ¬ LookUpInRegTable[s];      IF ok THEN RETURN[ORD[IOPB.SymbolType.register], address];      [ok, value] ¬ StringExtras.StringToLongCardinal[s];      IF ok THEN RETURN[Evaluate.unspecified, value];  -- return a LONG CARDINAL      ERROR IOPB.Error[s: s, code: undefinedSymbol];      END;    newS ¬ s;    IF s[0] = '. THEN {      addressType ¬        SELECT s[1] FROM          'I => iop,          'P => pc,          'R => real,          'V => vm,          ENDCASE => ERROR IOPB.Error[s: NIL, code: stringEvalError];      [type, value] ¬ Evaluate.EvaluateSubString[        @ssd, Lookup !        Evaluate.Error => ERROR IOPB.Error[s: reason, code: stringEvalError]]	}    ELSE      [type, value] ¬ Evaluate.EvaluateString[        s, Lookup !        Evaluate.Error => ERROR IOPB.Error[s: reason, code: stringEvalError]];    t ¬ IF type = Evaluate.unspecified THEN dataType ELSE VAL[type];    IF s[0] # '. AND wantNewString AND (t = byte OR t = word) THEN {        newS ¬ Heap.systemZone.NEW[StringBody [s.length + prefixLen]];	AppendAddressType[newS, addressType];        String.AppendString[newS, s]};    SELECT t FROM      register =>        symbol ¬ [          register[Inline.LowHalf[value MOD (I186.Register.LAST.ORD + 1)]]];      byte => symbol ¬ [byte[value, addressType]];      word => symbol ¬ [word[value, addressType]];      ENDCASE => ERROR;    END;  LookUpInSymbolTable: PROC [s: LONG STRING, processor: IOPB.Processor]    RETURNS [ok: BOOLEAN ¬ FALSE, address: I186.Address ¬ 0] = {    index: CARDINAL;    found: BOOLEAN;    IF st[processor] = NIL THEN RETURN;    [found, index] ¬ IOPBSymbolTable.LookUpSymbol[s: s, h: st[processor]];    IF found THEN ok ¬ TRUE ELSE RETURN;    address ¬ IOPBSymbolTable.GetValueAtIndex[index: index, h: st[processor]];    };  LookUpInRegTable: PROC [s: LONG STRING] RETURNS [ok: BOOLEAN, value: CARDINAL] =    {    OPEN I186;    IF (s.length # 2) AND (s.length # 5) THEN RETURN[FALSE, ];    SELECT TRUE FROM      String.Equivalent[s, "AX"L] => RETURN[TRUE, ORD[Register.AX]];      String.Equivalent[s, "BX"L] => RETURN[TRUE, ORD[Register.BX]];      String.Equivalent[s, "CX"L] => RETURN[TRUE, ORD[Register.CX]];      String.Equivalent[s, "DX"L] => RETURN[TRUE, ORD[Register.DX]];      String.Equivalent[s, "SP"L] => RETURN[TRUE, ORD[Register.SP]];      String.Equivalent[s, "BP"L] => RETURN[TRUE, ORD[Register.BP]];      String.Equivalent[s, "SI"L] => RETURN[TRUE, ORD[Register.SI]];      String.Equivalent[s, "DI"L] => RETURN[TRUE, ORD[Register.DI]];      String.Equivalent[s, "CS"L] => RETURN[TRUE, ORD[Register.CS]];      String.Equivalent[s, "DS"L] => RETURN[TRUE, ORD[Register.DS]];      String.Equivalent[s, "SS"L] => RETURN[TRUE, ORD[Register.SS]];      String.Equivalent[s, "ES"L] => RETURN[TRUE, ORD[Register.ES]];      String.Equivalent[s, "IP"L] => RETURN[TRUE, ORD[Register.IP]];      String.Equivalent[s, "FLAGS"L] => RETURN[TRUE, ORD[Register.FLAGS]];      ENDCASE => RETURN[FALSE, ];    };  Sort: PUBLIC PROC [processor: IOPB.Processor] RETURNS [symbols: CARDINAL ¬ 0] =    {    IF st[processor] = NIL AND processor = pc THEN       ERROR IOPB.Error[pcNotInitialized];    symbols ¬ IOPBSymbolTable.Sort[h: st[processor]]};  TrimSubString: PROC [ss: String.SubString] =    BEGIN    FOR i: CARDINAL IN [ss.offset..ss.offset + ss.length) DO      IF ~BlankCharacter[ss.base[i]] THEN        BEGIN  --  remove leading blanks        ss.length ¬ ss.length - (i - ss.offset);        ss.offset ¬ i;        EXIT;        END;      REPEAT        FINISHED =>          BEGIN  --all blanks          ss.length ¬ 0;          RETURN;          END;      ENDLOOP;    FOR i: CARDINAL DECREASING IN [ss.offset..ss.offset + ss.length) DO      IF ~BlankCharacter[ss.base[i]] THEN        BEGIN  --  remove trailing blanks        ss.length ¬ ss.length - (ss.offset + ss.length - 1 - i);        EXIT;        END;      ENDLOOP;    END;  BlankCharacter: PROC [c: CHARACTER] RETURNS [BOOLEAN] =    BEGIN    SELECT c FROM      Ascii.FF, Ascii.SP, Ascii.CR, Ascii.LF, Ascii.TAB => RETURN[TRUE];      ENDCASE => RETURN[FALSE];    END;  END.
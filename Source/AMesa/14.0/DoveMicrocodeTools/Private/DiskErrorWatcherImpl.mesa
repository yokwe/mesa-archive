-- Copyright (C) 1985 by Xerox Corporation.  All rights reserved.-- DiskErrorWatcherImpl.mesa-- Created by BindweedDisplayer on 18-Mar-85 13:34:03-- Last changed by DMP on  1-Oct-85 14:16:06DIRECTORY  Context,  Exec,  FormSW,  Flipper USING [Create, Disable, Enable, Enumerated],  Heap,  MStream USING [Handle, WriteOnly],  PilotDiskFace USING [Status],  PilotDiskFaceStatistics,  Process USING [MsecToTicks, Pause],  Runtime,  Stream USING [Delete, PutChar, PutString],  String,  Time,  Tool,  ToolWindow,  Version,  Window;DiskErrorWatcherImpl: MONITOR  IMPORTS    Context, Exec, Flipper, FormSW, Heap, MStream, PilotDiskFaceStatistics, Process, Runtime, Stream, String, Time, Tool, ToolWindow, Version = {  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = MACHINE DEPENDENT RECORD [    msgSW(0): Window.Handle ¬ NIL,    formSW(2): Window.Handle ¬ NIL,    fileSW(4): Window.Handle ¬ NIL,    flippers(6): BOOLEAN ¬ TRUE,    flipperSW(7): Window.Handle ¬ NIL,    diskErrors(9): ARRAY PilotDiskFace.Status OF LONG CARDINAL ¬ ALL[0],    otherDiskErrors(45): ARRAY PilotDiskFaceStatistics.OtherErrors OF LONG CARDINAL ¬ ALL[0],    operationsInitiated(77): LONG CARDINAL ¬ 0,    pagesRead(79): LONG CARDINAL ¬ 0,    pagesWritten(81): LONG CARDINAL ¬ 0,    running(83): BOOLEAN ¬ TRUE,    ErrorWatcher(84): PROCESS ¬ NIL];  GlobalDataHandle: TYPE = LONG POINTER TO GlobalData;  GlobalData: TYPE = RECORD [    context: Context.Type,--    tinyName1: LONG STRING ¬ NIL,--    tinyName2: LONG STRING ¬ NIL,    rootName: LONG STRING ¬ NIL,    nameStripeName: LONG STRING ¬ NIL,    windows: WindowList ¬ NIL];  WindowList: TYPE = LONG POINTER TO WindowRecord;  WindowRecord: TYPE = RECORD [    wh: Window.Handle ¬ NIL,    link: WindowList ¬ NIL];  FormItems: TYPE = {flippers, saveState};  data: GlobalDataHandle ¬ NIL;  zone: UNCOUNTED ZONE ¬ Heap.systemZone;  << Instance data monitoring. >>  Lock: PROCEDURE [wh: Window.Handle] RETURNS [dataHandle: DataHandle] = INLINE {    RETURN Context.Acquire[type: data.context, window: wh]};  Share: PROCEDURE [wh: Window.Handle] RETURNS [dataHandle: DataHandle] = INLINE {    RETURN Context.Find[type: data.context, window: wh]};  UnLock: PROCEDURE [wh: Window.Handle] = INLINE {    Context.Release[type: data.context, window: wh]};  << Window list management. >>  AddToList: ENTRY PROCEDURE [wh: Window.Handle] = {    ENABLE UNWIND => NULL;    data.windows ¬ zone.NEW[WindowRecord ¬ [wh: wh, link: data.windows]]};  LocateQuiescentTool: ENTRY PROCEDURE RETURNS [wh: Window.Handle] = {    ENABLE UNWIND => NULL;    wh ¬ NIL;    FOR w: WindowList ¬ data.windows, w.link WHILE w # NIL DO      SELECT ToolWindow.GetState[w.wh] FROM	active => NULL;	inactive => {	  ToolWindow.Activate[w.wh];	  wh ¬ w.wh;	  RETURN};	tiny => NULL;      ENDCASE;    ENDLOOP};  RemoveFromList: ENTRY PROCEDURE [wh: Window.Handle] = {    ENABLE UNWIND => NULL;    w: LONG POINTER TO WindowList;    FOR w ¬ @data.windows, @w.link WHILE w­ # NIL DO      IF w.wh = wh THEN {	flush: WindowList ¬ w­;	w­ ¬ w.link;	zone.FREE[@flush];	RETURN};    ENDLOOP};  << Initialization.  >>  Init: PROCEDURE = {    commandName: LONG STRING;    data ¬ zone.NEW[GlobalData ¬ [      context: Context.UniqueType[],      rootName: String.CopyToNewString[s: "DiskErrorWatcher"L, z: zone]]];    commandName ¬ String.CopyToNewString[s: data.rootName, z: zone, longer: 2];    String.AppendString[to: commandName, from: ".~"L];    Exec.AddCommand[name: commandName, proc: RegisterCommand, help: HelpProc, unload: UnloadProc];    String.FreeString[z: zone, s: commandName];    data.nameStripeName ¬ String.CopyToNewString[s: data.rootName, z: zone, longer: 55];    String.AppendString[to: data.nameStripeName, from: " of "];    Time.Append[s: data.nameStripeName, unpacked: Time.Unpack[time: Runtime.GetBcdTime[]], zone: TRUE];    String.AppendString[to: data.nameStripeName, from: " running on Pilot "];    Version.Append[data.nameStripeName];    };  RegisterCommand: Exec.ExecProc = {    wh: Window.Handle;    IF (wh ¬ LocateQuiescentTool[]) = NIL THEN wh ¬ CreateInstance[]};  HelpProc: Exec.ExecProc = {    };  UnloadProc: Exec.ExecProc = {    commandName: LONG STRING;    tempPtr: WindowList;    commandName ¬ String.CopyToNewString[s: data.rootName, z: zone, longer: 2];    String.AppendString[to: commandName, from: ".~"];    h.RemoveCommand[name: commandName];    zone.FREE[@commandName];    WHILE (tempPtr ¬ data.windows) # NIL DO      data.windows ¬ data.windows.link;      Tool.Destroy[window: tempPtr.wh];    ENDLOOP;    zone.FREE[@data]};  << Tool creation/destruction.  >>  AnotherInstance: FormSW.ProcType = {      IF LocateQuiescentTool[] = NIL THEN [] ¬ CreateInstance[]};  CreateInstance: PROCEDURE RETURNS[wh: Window.Handle] = {    tinyName1: LONG STRING = "DiskError"L;    tinyName2: LONG STRING = "Watcher"L;    AddToList[wh: wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default,      clientTransition: ClientTransition, name: data.nameStripeName,      tinyName1: tinyName1, tinyName2: tinyName2,      cmSection: data.rootName]]};  DestroyInstance: FormSW.ProcType ={    wh: Window.Handle = ToolWindow.WindowForSubwindow[sw: sw];    RemoveFromList[wh: wh];    Tool.Destroy[window: wh]};  MakeForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = FormItems.LAST.ORD + 1;    instance: DataHandle = Share[wh: ToolWindow.WindowForSubwindow[sw: sw]];    items ¬ AllocateItemDescriptor[nItems];    items[FormItems.flippers.ORD] ¬ BooleanItem[      tag: "flippers"L, place: [6, line0], switch: @instance.flippers, proc: FlipperEnablerDisabler];    items[FormItems.saveState.ORD] ¬ CommandItem[      tag: "SaveState"L, place: [100, line0], proc: SaveState];    RETURN[items: items, freeDesc: TRUE];    };  MakeSWs: Tool.MakeSWsProc = {  logName: LONG STRING ¬ [23];    instance: DataHandle = Share[wh: window];    flippers: ARRAY [0..37) OF Flipper.Enumerated ¬ [      ["inProgress"L, @instance.diskErrors[inProgress]],      ["Good"L, @instance.diskErrors[goodCompletion]],      ["Not Ready"L, @instance.diskErrors[notReady]],      ["recalError"L, @instance.diskErrors[recalibrateError]],      ["seekTimeout"L, @instance.diskErrors[seekTimeout]],      ["HdrCRC"L, @instance.diskErrors[headerCRCError]],      ["LblCRC"L, @instance.diskErrors[labelCRCError]],      ["DataCRC"L, @instance.diskErrors[dataCRCError]],      ["HdrNotFnd"L, @instance.diskErrors[headerNotFound]],      ["LblVrfy"L, @instance.diskErrors[labelVerifyError]],      ["DataVrfy"L, @instance.diskErrors[dataVerifyError]],      ["Overrun"L, @instance.diskErrors[overrunError]],      ["WrtFlt"L, @instance.diskErrors[writeFault]],      ["MemErr"L, @instance.diskErrors[memoryError]],      ["MemFlt"L, @instance.diskErrors[memoryFault]],      ["ClientErr"L, @instance.diskErrors[clientError]],      ["OpReset"L, @instance.diskErrors[operationReset]],      ["Other"L, @instance.diskErrors[otherError]],            ["Lbl AM"L, @instance.otherDiskErrors[labelAddressMarkError]],      ["Lbl ID"L, @instance.otherDiskErrors[labelIDError]],      ["Data AM"L, @instance.otherDiskErrors[dataAddressMarkError]],      ["Data ID"L, @instance.otherDiskErrors[dataIDError]],      ["Hdr AM"L, @instance.otherDiskErrors[headerAddressMarkNotFound]],      ["Hdr ID"L, @instance.otherDiskErrors[headerIDError]],      ["FIFOMT@GCB"L, @instance.otherDiskErrors[fifoEmptyAtGetCommandBlock]],      ["FIFO~MT"L, @instance.otherDiskErrors[fifoNotEmpty]],      ["FIFO full"L, @instance.otherDiskErrors[fifoFull]],      ["FIFO MT"L, @instance.otherDiskErrors[fifoEmpty]],      ["FIFOMT@LCB"L, @instance.otherDiskErrors[fifoNotEmptyAtLoadCommandBlock]],      ["Cyl2big"L, @instance.otherDiskErrors[cylinderTooBig]],      ["CylUnknown"L, @instance.otherDiskErrors[currentCylinderUnknown]],      ["Protocol"L, @instance.otherDiskErrors[protocolViolation]],      ["IllDiagOp"L, @instance.otherDiskErrors[illegalDiagnosticOperation]],      ["IllOp"L, @instance.otherDiskErrors[illegalOperation]],            ["Ops"L, @instance.operationsInitiated],      ["pgs Read"L, @instance.pagesRead],      ["pgs Written"L, @instance.pagesWritten]];    Tool.UnusedLogName[unused: logName, root: "DiskErrorWatcher.log"L];    instance.msgSW ¬ Tool.MakeMsgSW[window: window];    instance.formSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeForm];    instance.flipperSW ¬ Flipper.Create[parent: window, flippers: DESCRIPTOR[flippers]];    IF ~instance.flippers THEN Flipper.Disable[sw: instance.flipperSW];    instance.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    };<< Transitions. >>  ClientTransition: ToolWindow.TransitionProcType = {    SELECT TRUE FROM      old = inactive =>	{instance: DataHandle = zone.NEW[Data ¬ []];	Context.Create[type: data.context, data: instance, proc: Context.NopDestroyProc, window: window];	instance.ErrorWatcher ¬ FORK UpdateErrorStatistics[instance: instance]};      new = inactive =>	{instance: DataHandle ¬ Share[window];	instance.running ¬ FALSE;	JOIN instance.ErrorWatcher;	instance.ErrorWatcher ¬ NIL;	Context.Destroy[type: data.context, window: window];	zone.FREE[@instance]};      ENDCASE;    };<< FormSW invoked PROCEDURES. >>  -- Supplied PROCEDUREs.    FlipperEnablerDisabler: FormSW.NotifyProcType =    BEGIN      wh: Window.Handle;      instance: DataHandle = Lock[wh: (wh ¬ ToolWindow.WindowForSubwindow[sw: sw])];      IF instance.flippers THEN Flipper.Enable[sw: instance.flipperSW] ELSE Flipper.Disable[sw: instance.flipperSW];      UnLock[wh];    END;        SaveState: FormSW.ProcType = {    saveFile: MStream.Handle ¬ MStream.WriteOnly["DiskErrorWatcher.save"L,[NIL,NIL],text];    svalue: LONG STRING ¬ [20];    wh: Window.Handle;    instance: DataHandle = Lock[wh: (wh ¬ ToolWindow.WindowForSubwindow[sw: sw])];       WriteLine: PROC [title: LONG STRING, value: LONG CARDINAL] = {      Stream.PutString[saveFile, title];      svalue.length ¬ 0;      String.AppendLongDecimal[svalue, value];      Stream.PutString[saveFile, "   "L];      Stream.PutString[saveFile, svalue];      Stream.PutChar[saveFile, '\n];    };        WriteLine["inProgress"L, instance.diskErrors[inProgress]];    WriteLine["Good"L, instance.diskErrors[goodCompletion]];    WriteLine["Not Ready"L, instance.diskErrors[notReady]];    WriteLine["recalError"L, instance.diskErrors[recalibrateError]];    WriteLine["seekTimeout"L, instance.diskErrors[seekTimeout]];    WriteLine["HdrCRC"L, instance.diskErrors[headerCRCError]];    WriteLine["LblCRC"L, instance.diskErrors[labelCRCError]];    WriteLine["DataCRC"L, instance.diskErrors[dataCRCError]];    WriteLine["HdrNotFnd"L, instance.diskErrors[headerNotFound]];    WriteLine["LblVrfy"L, instance.diskErrors[labelVerifyError]];    WriteLine["DataVrfy"L, instance.diskErrors[dataVerifyError]];    WriteLine["Overrun"L, instance.diskErrors[overrunError]];    WriteLine["WrtFlt"L, instance.diskErrors[writeFault]];    WriteLine["MemErr"L, instance.diskErrors[memoryError]];    WriteLine["MemFlt"L, instance.diskErrors[memoryFault]];    WriteLine["ClientErr"L, instance.diskErrors[clientError]];    WriteLine["OpReset"L, instance.diskErrors[operationReset]];    WriteLine["Other"L, instance.diskErrors[otherError]];    WriteLine["Lbl AM"L, instance.otherDiskErrors[labelAddressMarkError]];    WriteLine["Lbl ID"L, instance.otherDiskErrors[labelIDError]];    WriteLine["Data AM"L, instance.otherDiskErrors[dataAddressMarkError]];    WriteLine["Data ID"L, instance.otherDiskErrors[dataIDError]];    WriteLine["Hdr AM"L, instance.otherDiskErrors[headerAddressMarkNotFound]];    WriteLine["Hdr ID"L, instance.otherDiskErrors[headerIDError]];    WriteLine["FIFOMT@GCB"L, instance.otherDiskErrors[fifoEmptyAtGetCommandBlock]];    WriteLine["FIFO~MT"L, instance.otherDiskErrors[fifoNotEmpty]];    WriteLine["FIFO full"L, instance.otherDiskErrors[fifoFull]];    WriteLine["FIFO MT"L, instance.otherDiskErrors[fifoEmpty]];    WriteLine["FIFOMT@LCB"L, instance.otherDiskErrors[fifoNotEmptyAtLoadCommandBlock]];    WriteLine["Cyl2big"L, instance.otherDiskErrors[cylinderTooBig]];    WriteLine["CylUnknown"L, instance.otherDiskErrors[currentCylinderUnknown]];    WriteLine["Protocol"L, instance.otherDiskErrors[protocolViolation]];    WriteLine["IllDiagOp"L, instance.otherDiskErrors[illegalDiagnosticOperation]];    WriteLine["IllOp"L, instance.otherDiskErrors[illegalOperation]];        WriteLine["Ops"L, instance.operationsInitiated];    WriteLine["pgs Read"L, instance.pagesRead];    WriteLine["pgs Written"L, instance.pagesWritten];        Stream.Delete[saveFile];    UnLock[wh];  };    UpdateErrorStatistics: PROCEDURE [instance: DataHandle] =    BEGIN      WHILE instance.running DO              FOR index: PilotDiskFace.Status IN PilotDiskFace.Status DO	  instance.diskErrors[index] ¬ PilotDiskFaceStatistics.pilotDiskErrors[index];	ENDLOOP;		FOR index: PilotDiskFaceStatistics.OtherErrors IN PilotDiskFaceStatistics.OtherErrors DO	  instance.otherDiskErrors[index] ¬ PilotDiskFaceStatistics.pilotDiskOtherErrors[index];	ENDLOOP;		instance.operationsInitiated ¬ PilotDiskFaceStatistics.pilotDiskOperationsInitiated;	instance.pagesRead ¬ PilotDiskFaceStatistics.pilotDiskPagesRead;	instance.pagesWritten ¬ PilotDiskFaceStatistics.pilotDiskPagesWritten;	        Process.Pause[Process.MsecToTicks[50]];      ENDLOOP;    END;  -- Mainline code  Init[];  -- this gets string out of global frame  }...  --Log--DMP,   1-Oct-85 14:16:36  Added SaveState feature    
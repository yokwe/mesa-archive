-- File: DAsmImpl.mesa - last edit:-- FXB   .PA            9-May-85 10:10:51-- Copyright (C) 1985 by Xerox Corporation. All rights reserved.DIRECTORY  DAsm,  Inline,  IOPB,  String,  IOPBKernel;DAsmImpl: PROGRAM IMPORTS Inline, String, IOPBKernel EXPORTS DAsm =  {  PrefixType: TYPE = {    null, segmentES, segmentCS, segmentSS, segmentDS, lock, repe, rep};  SegOverrideType: TYPE = PrefixType [null..segmentDS];  OpCodeType: TYPE = RECORD [    SELECT OVERLAID * FROM    nibbles => [n: Nibble],    modrm => [m: Modrm],    byteWord => [bw: ByteWord],    immediate => [im: MovImm],    ENDCASE];  Nibble: TYPE = MACHINE DEPENDENT RECORD [    trash1(0:0..7): [0..400B),    highNibble(0:8..11): [0..16),    lowNibble(0:12..15): [0..16)];  Modrm: TYPE = MACHINE DEPENDENT RECORD [    trash2(0:0..7): [0..400B),    mod(0:8..9): [0..4),    reg(0:10..12): [0..8),    rm(0:13..15): RM];  RM: TYPE = MACHINE DEPENDENT{    bxsi(0), bxdi(1), bpsi(2), bpdi(3), si(4), di(5), bp(6), bx(7)};  Reg16: TYPE = MACHINE DEPENDENT{    ax(0), cx(1), dx(2), bx(3), sp(4), bp(5), si(6), di(7)};  Reg8: TYPE = MACHINE DEPENDENT{    al(0), cl(1), dl(2), bl(3), ah(4), ch(5), dh(6), bh(7)};  SegType: TYPE = MACHINE DEPENDENT{es(0), cs(1), ss(2), ds(3)};  ByteWord: TYPE = MACHINE DEPENDENT RECORD [    trash2(0:0..13): [0..37777B),    regDest(0:14..14): BOOLEAN,    word(0:15..15): BOOLEAN];  RotateType: TYPE = {null, one, count, cl};  MovImm: TYPE = MACHINE DEPENDENT RECORD [    trash3: [0..7777B),    word: BOOLEAN,    reg: SELECT OVERLAID * FROM      wordWide => [reg16: Reg16], byteWide => [reg8: Reg8], ENDCASE];  segStr: LONG POINTER TO ARRAY SegType OF LONG STRING ¬ NIL;  reg16Str: LONG POINTER TO ARRAY Reg16 OF LONG STRING ¬ NIL;  reg8Str: LONG POINTER TO ARRAY Reg8 OF LONG STRING ¬ NIL;  rmStr: LONG POINTER TO ARRAY RM OF LONG STRING ¬ NIL;    aType: IOPB.AddressType ¬ iop;  DisassembleInstruction: PUBLIC PROCEDURE [    address: LONG CARDINAL, addressType: IOPB.AddressType, s: LONG STRING]     RETURNS [length: CARDINAL ¬ 0] = {    opcode: OpCodeType ¬ VAL[IOPBKernel.ReadMemoryByte[address, addressType]];    prefix: PrefixType ¬ null;    len: CARDINAL ¬ 0;    segOverride: SegOverrideType ¬ null;    segStrArray: ARRAY SegType OF LONG STRING ¬ ["ES"L, "CS"L, "SS"L, "DS"L];    reg16StrArray: ARRAY Reg16 OF LONG STRING ¬ [      "AX"L, "CX"L, "DX"L, "BX"L, "SP"L, "BP"L, "SI"L, "DI"L];    reg8StrArray: ARRAY Reg8 OF LONG STRING ¬ [      "AL"L, "CL"L, "DL"L, "BL"L, "AH"L, "CH"L, "DH"L, "BH"L];    rmStrArray: ARRAY RM OF LONG STRING ¬ [      "[BX + SI"L, "[BX + DI"L, "[BP + SI"L, "[BP + DI"L, "[SI"L, "[DI"L, "[BP"L,      "[BX"L];    segStr ¬ @segStrArray;    reg16Str ¬ @reg16StrArray;    reg8Str ¬ @reg8StrArray;    rmStr ¬ @rmStrArray;    aType ¬ addressType;    DO      prefix ¬ null;      SELECT opcode.n.highNibble FROM        0 => length ¬ length + AddRow[address, s, opcode, segOverride];        1 => length ¬ length + AdcRow[address, s, opcode, segOverride];        2 => {          [len, prefix] ¬ AndRow[address, s, opcode, segOverride];          length ¬ length + len};        3 => {          [len, prefix] ¬ XorRow[address, s, opcode, segOverride];          length ¬ length + len};        4 => length ¬ length + IncRow[address, s, opcode];        5 => length ¬ length + PshRow[address, s, opcode];        6 => length ¬ length + NoRow[address, s, opcode, segOverride];        7 => length ¬ length + JcnRow[address, s, opcode];        8 => length ¬ length + Mov1Row[address, s, opcode, segOverride];        9 => length ¬ length + NopRow[address, s, opcode];        0AH => length ¬ length + MovRow[address, s, opcode, segOverride];        0BH => length ¬ length + ImmRow[address, s, opcode];        0CH => length ¬ length + RetRow[address, s, opcode, segOverride];        0DH => length ¬ length + ShfRow[address, s, opcode, segOverride];        0EH => length ¬ length + LoopRow[address, s, opcode, segOverride];        0FH => {          [len, prefix] ¬ LokRow[address, s, opcode, segOverride];          length ¬ length + len};        ENDCASE => ERROR;      IF prefix = null THEN EXIT;      address ¬ address + length;      opcode ¬ VAL[IOPBKernel.ReadMemoryByte[address, aType]];      segOverride ¬        SELECT prefix FROM          segmentCS => segmentCS,          segmentES => segmentES,          segmentSS => segmentSS,          segmentDS => segmentDS,          ENDCASE => null;      ENDLOOP;    };  AddRow: PROCEDURE [    address: LONG CARDINAL, s: LONG STRING, opcode: OpCodeType,    segOverride: SegOverrideType] RETURNS [length: CARDINAL ¬ 1] = {    String.AppendString[      s,      SELECT opcode.n.lowNibble FROM        0, 1, 2, 3, 4, 5 => "ADD   "L,        6 => "PUSH   ES"L,        7 => "POP   ES"L,        8, 9, 0AH, 0BH, 0CH, 0DH => "OR    "L,        0EH => "PUSH   CS"L,        0FH => "illegal"L,        ENDCASE => ""L];    length ¬ First4Rows[address, s, opcode, segOverride];    };  First4Rows: PROCEDURE [    address: LONG CARDINAL, s: LONG STRING, opcode: OpCodeType,    segOverride: SegOverrideType] RETURNS [length: CARDINAL ¬ 1] = {    SELECT opcode.n.lowNibble FROM      0, 1, 2, 3, 8, 9, 0AH, 0BH => {  -- reg, r/m        op2: OpCodeType ¬ VAL[IOPBKernel.ReadMemoryByte[address + 1, aType]];        length ¬          length + AppendModrm[            s, op2, opcode.bw.regDest, opcode.bw.word, address + 2, segOverride]};      4, 5, 0CH, 0DH => {  --AX or AL, imm        length ¬ ImmToAcc[s, opcode, address + 1];  -- no segment override        };      ENDCASE;    };  AdcRow: PROCEDURE [    address: LONG CARDINAL, s: LONG STRING, opcode: OpCodeType,    segOverride: SegOverrideType] RETURNS [length: CARDINAL ¬ 1] = {    String.AppendString[      s,      SELECT opcode.n.lowNibble FROM        0, 1, 2, 3, 4, 5 => "ADC   "L,        6 => "PUSH   SS"L,        7 => "POP   SS"L,        8, 9, 0AH, 0BH, 0CH, 0DH => "SBB   "L,        0EH => "PUSH   DS"L,        0FH => "POP   DS"L,        ENDCASE => ""L];    length ¬ First4Rows[address, s, opcode, segOverride];    };  AndRow: PROCEDURE [    address: LONG CARDINAL, s: LONG STRING, opcode: OpCodeType,    segOverride: SegOverrideType]    RETURNS [length: CARDINAL ¬ 1, prefix: PrefixType ¬ null] = {    String.AppendString[      s,      SELECT opcode.n.lowNibble FROM        0, 1, 2, 3, 4, 5 => "AND   "L,        7 => "DAA"L,        8, 9, 0AH, 0BH, 0CH, 0DH => "SUB   "L,        0FH => "DAS"L,        ENDCASE => ""L];    prefix ¬      SELECT opcode.n.lowNibble FROM        6 => segmentES,        0EH => segmentCS,        ENDCASE => null;    length ¬ First4Rows[address, s, opcode, segOverride];    };  XorRow: PROCEDURE [    address: LONG CARDINAL, s: LONG STRING, opcode: OpCodeType,    segOverride: SegOverrideType]    RETURNS [length: CARDINAL ¬ 1, prefix: PrefixType ¬ null] = {    String.AppendString[      s,      SELECT opcode.n.lowNibble FROM        0, 1, 2, 3, 4, 5 => "XOR   "L,        7 => "AAA"L,        8, 9, 0AH, 0BH, 0CH, 0DH => "CMP   "L,        0FH => "AAS"L,        ENDCASE => ""L];    prefix ¬      SELECT opcode.n.lowNibble FROM        6 => segmentSS,        0EH => segmentDS,        ENDCASE => null;    length ¬ First4Rows[address, s, opcode, segOverride];    };  IncRow: PROCEDURE [address: LONG CARDINAL, s: LONG STRING, opcode: OpCodeType]    RETURNS [length: CARDINAL ¬ 1] = {  -- 04XH    op: MovImm ¬ VAL[opcode];    String.AppendString[      s, IF opcode.n.lowNibble < 8 THEN "INC   "L ELSE "DEC   "L];    String.AppendString[s, reg16Str[op.reg16]]};  PshRow: PROCEDURE [address: LONG CARDINAL, s: LONG STRING, opcode: OpCodeType]    RETURNS [length: CARDINAL ¬ 1] = {  -- 05XH    op: MovImm ¬ VAL[opcode];    String.AppendString[      s, IF opcode.n.lowNibble < 8 THEN "PUSH  "L ELSE "POP   "L];    String.AppendString[s, reg16Str[op.reg16]]};  NoRow: PROCEDURE [    address: LONG CARDINAL, s: LONG STRING, opcode: OpCodeType,    segOverride: SegOverrideType] RETURNS [length: CARDINAL ¬ 1] = {  --6XH    String.AppendString[      s,      SELECT opcode.n.lowNibble FROM        0 => "PUSHA"L,        1 => "POPA"L,        2 => "BOUND"L,        8, 0AH => "PUSH  "L,        9, 0BH => "IMUL  "L,        0CH => "INSB"L,        0DH => "INS"L,        0EH => "OUTSB"L,        0FH => "OUTS"L,        ENDCASE => "illegal"L];    SELECT opcode.n.lowNibble FROM      2 => {  -- BOUND        length ¬ 2};      8 => {        String.AppendNumber[s, IOPBKernel.ReadMemoryWord[address + 1, aType], 16];        length ¬ 3};      9, 0BH => {        op2: OpCodeType ¬ VAL[IOPBKernel.ReadMemoryByte[address + 1, aType]];	String.AppendString[s, reg16Str[VAL[op2.m.reg]]];	String.AppendString[s, ", "L];        length ¬ length + AppendRM[	      s, op2, TRUE, address + 2, segOverride];	String.AppendString[s, ", "L];	IF opcode.n.lowNibble = 9 THEN { --immediate 16 bit	  String.AppendNumber[s, IOPBKernel.ReadMemoryWord[address + 2, aType], 16];	  length ¬ length + 2}	ELSE {	  String.AppendNumber[s, IOPBKernel.ReadMemoryByte[address + 2, aType], 16];	  length ¬ length + 1};	};        0A => {        String.AppendNumber[s, IOPBKernel.ReadMemoryByte[address + 1, aType], 16];        length ¬ 2};      ENDCASE;    };  JcnRow: PROCEDURE [address: LONG CARDINAL, s: LONG STRING, opcode: OpCodeType]    RETURNS [length: CARDINAL ¬ 2] = {  -- 07XH    jcnStr: ARRAY [0..16) OF LONG STRING ¬ [      "JO"L, "JNO"L, "JC"L, "JNC"L, "JZ"L, "JNZ"L, "JNA"L, "JA"L, "JS"L, "JNS"L,      "JPE"L, "JPO"L, "JL"L, "JGE"L, "JLE"L, "JG"L];    String.AppendString[s, jcnStr[opcode.n.lowNibble]];    AppendDisp[s, address + 1]};  Mov1Row: PROCEDURE [    address: LONG CARDINAL, s: LONG STRING, opcode: OpCodeType,    segOverride: SegOverrideType] RETURNS [length: CARDINAL ¬ 1] = {  -- 08XH    op2: OpCodeType ¬ VAL[IOPBKernel.ReadMemoryByte[address + 1, aType]];    String.AppendString[      s,      SELECT opcode.n.lowNibble FROM        2 => "illegal"L,        4, 5 => "TEST  "L,        6, 7 => "XCHG  "L,        8, 9, 0AH, 0BH, 0CH, 0EH => "MOV   "L,        0DH => "LEA   "L        ENDCASE => ""L];    SELECT opcode.n.lowNibble FROM      0, 1, 3 => {        immOpStr: ARRAY [0..8) OF LONG STRING ¬ [          "ADD"L, "OR"L, "ADC"L, "SBB"L, "AND"L, "SUB"L, "XOR"L, "CMP"L];        IF opcode.n.lowNibble = 3 THEN          SELECT op2.m.reg FROM 1, 4, 6 => {	    String.AppendString[s, "illegal"L]; RETURN};	  ENDCASE => NULL;        String.AppendString[s, immOpStr[op2.m.reg]];        String.AppendString[s, "   "L];        length ¬          length + AppendImmModrm[            s, op2, opcode.bw.word, address + 2, opcode.n.lowNibble = 3,            segOverride]};      2 => NULL;      4, 5 => {  -- TEST  register/memory and register--        length ¬          length + AppendModrm[            s, op2, FALSE, opcode.bw.word, address + 2, segOverride]};      6, 7 => {  -- XCHG register/memory and register --        length ¬          length + AppendModrm[            s, op2, FALSE, opcode.bw.word, address + 2, segOverride]};      8, 9 => {  -- MOV register/memory and register  --        length ¬          length + AppendModrm[            s, op2, FALSE, opcode.bw.word, address + 2, segOverride]};      0AH, 0BH => {  -- MOV register/memory and register (to register) --        length ¬          length + AppendModrm[            s, op2, opcode.bw.regDest, opcode.bw.word, address + 2, segOverride]};      0CH => {  -- MOV	r/m segment --        length ¬          length + AppendModrm[            s, op2, FALSE, TRUE, address + 2, segOverride, TRUE]};      0DH => {  -- LEA reg, r/m --        length ¬          length + AppendModrm[            s, op2, TRUE, opcode.bw.word, address + 2, segOverride]};      0EH => {  -- MOV segment, r/m --        length ¬          length + AppendModrm[            s, op2, TRUE, TRUE, address + 2, segOverride, TRUE]};      0FH => {        SELECT op2.m.reg FROM        0 => {	  String.AppendString[s, "POP   "L];	  length ¬ length + AppendRM[	    s, op2, opcode.bw.word, address + 2, segOverride]};	ENDCASE => String.AppendString[s, "illegal"L];        };      ENDCASE => ERROR;    };  NopRow: PROCEDURE [address: LONG CARDINAL, s: LONG STRING, opcode: OpCodeType]    RETURNS [length: CARDINAL ¬ 1] = {  -- 09XH    nopRowStr: ARRAY [0..8) OF LONG STRING ¬ [      "CBW"L, "CWD"L, "CALL  "L, "WAIT"L, "PUSHF"L, "POPF"L, "SAHF"L, "LAHF"L];        SELECT opcode.n.lowNibble FROM      0 => String.AppendString[s, "NOP"L];      1, 2, 3, 4, 5, 6, 7 => {        op: MovImm ¬ VAL[opcode];        String.AppendString[s, "XCHG  "L];        String.AppendString[s, reg16Str[op.reg16]];        String.AppendString[s, ", AX"L]};      8, 9, 0BH, 0CH, 0DH, 0EH, 0FH =>        String.AppendString[s, nopRowStr[opcode.n.lowNibble - 8]];      0AH => {        offset: CARDINAL ¬ IOPBKernel.ReadMemoryWord[address + 1, aType];        segment: CARDINAL ¬ IOPBKernel.ReadMemoryWord[address + 3, aType];        String.AppendString[s, nopRowStr[opcode.n.lowNibble - 8]];        String.AppendNumber[s, segment, 16];        String.AppendChar[s, ':];        String.AppendNumber[s, offset, 16];        length ¬ 5};      ENDCASE};  MovRow: PROCEDURE [    address: LONG CARDINAL, s: LONG STRING, opcode: OpCodeType,    segOverride: SegOverrideType] RETURNS [length: CARDINAL ¬ 1] = {  -- 0AXH    String.AppendString[      s,      SELECT opcode.n.lowNibble FROM        0, 1, 2, 3 => "MOV   "L,        4 => "MOVSB"L,        5 => "MOVS"L,        6 => "CMPSB"L,        7 => "CMPS"L,        8, 9 => "TEST  "L,        0AH => "STOSB"L,        0BH => "STOS"L,        0CH => "LODSB"L,        0DH => "LODS"L,        0EH => "SCASB"L,        0FH => "SCAS"L,        ENDCASE => ERROR];    SELECT opcode.n.lowNibble FROM      0, 1, 2, 3 => {        accumulator: LONG STRING ¬ [2];        addr: LONG STRING ¬ [30];        -- memory to accumulator or vice versa        accumulator ¬ IF opcode.bw.word -- bit 0 -- THEN "AX"L ELSE "AL"L;        AppendPtr[addr, opcode.bw.word, address + 1, absolute, , segOverride];        IF opcode.bw.regDest THEN Append3Strings[s, addr, ", "L, accumulator]        ELSE Append3Strings[s, accumulator, ", "L, addr];        RETURN[length ¬ 3];        };      8, 9 => {  -- TEST imm        length ¬ ImmToAcc[s, opcode, address + 1]; };      ENDCASE;    };  ImmToAcc: PROC [s: LONG STRING, opcode: OpCodeType, address: LONG CARDINAL]    RETURNS [length: CARDINAL] = {    word: BOOLEAN ¬ opcode.bw.word;    String.AppendString[s, IF word THEN "AX, "L ELSE "AL, "L];    String.AppendNumber[      s,      IF word THEN IOPBKernel.ReadMemoryWord[address, aType]      ELSE IOPBKernel.ReadMemoryByte[address, aType], 16];    length ¬ IF word THEN 3 ELSE 2};  AppendPtr: PROC [    s: LONG STRING, word: BOOLEAN, address: LONG CARDINAL,    mode: {absolute, register}, register: RM, segOverride: SegOverrideType] = {    String.AppendString[s, IF word THEN "WORD PTR "L ELSE "BYTE PTR "L];    AppendSegmentOverride[s, segOverride];    SELECT mode FROM      absolute => {        String.AppendChar[s, '[];        String.AppendNumber[          s: s, n: IOPBKernel.ReadMemoryWord[address, aType], radix: 16];        String.AppendChar[s, ']]};      register => String.AppendString[s, rmStr[register]];      ENDCASE => ERROR};  AppendSegmentOverride: PROC [s: LONG STRING, seg: SegOverrideType] = {    String.AppendString[      s,      SELECT seg FROM        segmentES => "ES:"L,        segmentCS => "CS:"L,        segmentSS => "SS:"L,        segmentDS => "DS:"L,        ENDCASE => ""L]};  Append3Strings: PROC [s, s1, s2, s3: LONG STRING] = {    String.AppendString[s, s1];    String.AppendString[s, s2];    String.AppendString[s, s3]};  ImmRow: PROCEDURE [address: LONG CARDINAL, s: LONG STRING, opcode: OpCodeType]    RETURNS [length: CARDINAL ¬ 1] = {    movImm: MovImm ¬ VAL[opcode];    String.AppendString[s, "MOV   "L];    IF movImm.word THEN {      String.AppendString[s, reg16Str[movImm.reg16]];      String.AppendString[s, ", "L];      String.AppendNumber[s, IOPBKernel.ReadMemoryWord[address + 1, aType], 16];      length ¬ 3;      }    ELSE {      String.AppendString[s, reg8Str[movImm.reg8]];      String.AppendString[s, ", "L];      String.AppendNumber[s, IOPBKernel.ReadMemoryByte[address + 1, aType], 16];      length ¬ 2;      };    };  RetRow: PROCEDURE [    address: LONG CARDINAL, s: LONG STRING, opcode: OpCodeType,    segOverride: SegOverrideType] RETURNS [length: CARDINAL ¬ 1] = {    retStr: ARRAY [0..16) OF LONG STRING ¬ [      NIL, NIL, "RET   (near)"L, "RET   (near) "L, "LES   "L, "LDS   "L,      "MOV   "L, "MOV   "L, "ENTER"L, "LEAVE"L, "RET   (far) "L, "RET   (far) "L,      "INT   3"L, "INT   "L, "INTO"L, "IRET"L];    String.AppendString[s, retStr[opcode.n.lowNibble]];    SELECT opcode.n.lowNibble FROM      0, 1 => {  -- shift and rotate by count        op2: OpCodeType ¬ VAL[IOPBKernel.ReadMemoryByte[address + 1, aType]];        AppendRotOp[s, op2];        IF op2.m.reg # 6 THEN          length ¬            length + AppendImmModrm[              s, op2, opcode.bw.word, address + 2, FALSE, segOverride, count]};      2, 0AH => {  --RET  +         String.AppendNumber[s, IOPBKernel.ReadMemoryWord[address + 1, aType], 16];        length ¬ 3};      4, 5 => {  -- LES, LDS reg, r/m        op2: OpCodeType ¬ VAL[IOPBKernel.ReadMemoryByte[address + 1, aType]];        length ¬          length + AppendModrm[            s, op2, FALSE, opcode.bw.word, address + 2, segOverride]};      6, 7 => {  -- MOV r/m, imm        op2: OpCodeType ¬ VAL[IOPBKernel.ReadMemoryByte[address + 1, aType]];        length ¬          length + AppendImmModrm[            s, op2, opcode.bw.word, address + 2, FALSE, segOverride];        };      8 => {  -- ENTER        length ¬ 3};      0DH => {        String.AppendNumber[s, IOPBKernel.ReadMemoryByte[address + 1, aType], 16];        length ¬ 2};      3, 9, 0BH, 0CH, 0EH, 0FH => NULL;      ENDCASE;    };  AppendRotOp: PROC [s: LONG STRING, op: OpCodeType] = {    String.AppendString[      s,      SELECT op.m.reg FROM        0 => "ROL   "L,        1 => "ROR   "L,        2 => "RCL   "L,        3 => "RCR   "L,        4 => "SHL   "L,        5 => "SHR   "L,        6 => "illegal"L,        7 => "RAR   "L,        ENDCASE => ERROR];    };  ShfRow: PROCEDURE [    address: LONG CARDINAL, s: LONG STRING, opcode: OpCodeType,    segOverride: SegOverrideType] RETURNS [length: CARDINAL ¬ 1] = {    String.AppendString[      s,      SELECT opcode.n.lowNibble FROM        4 => "AAM"L,        5 => "AAD"L,        6 => "illegal"L,        7 => "XLAT"L,        8, 9, 0AH, 0BH, 0CH, 0DH, 0EH, 0FH => "ESC"L,        ENDCASE => ""L];    SELECT opcode.n.lowNibble FROM      0, 1 => {        op2: OpCodeType ¬ VAL[IOPBKernel.ReadMemoryByte[address + 1, aType]];        AppendRotOp[s, op2];        IF op2.m.reg # 6 THEN          length ¬            length + AppendImmModrm[              s, op2, opcode.bw.word, address + 2, FALSE, segOverride, one]};      2, 3 => {        op2: OpCodeType ¬ VAL[IOPBKernel.ReadMemoryByte[address + 1, aType]];        AppendRotOp[s, op2];        IF op2.m.reg # 6 THEN          length ¬            length + AppendImmModrm[              s, op2, opcode.bw.word, address + 2, FALSE, segOverride, cl]};      > 8 => String.AppendNumber[s, opcode.m.rm, 16];      ENDCASE => NULL;    };  LoopRow: PROCEDURE [    address: LONG CARDINAL, s: LONG STRING, opcode: OpCodeType,    segOverride: SegOverrideType] RETURNS [length: CARDINAL ¬ 1] = {  --0EXH    ax: LONG STRING ¬ "AX"L;    al: LONG STRING ¬ "AL"L;    dx: LONG STRING ¬ "DX"L;    comma: LONG STRING ¬ ", "L;    port: LONG STRING ¬ [4];    String.AppendString[      s,      SELECT opcode.n.lowNibble FROM        0 => "LOOPNZ"L,        1 => "LOOPZ"L,        2 => "LOOP"L,        3 => "JCXZ"L,        4, 5, 0CH, 0DH => "IN    "L,        6, 7, 0EH, 0FH => "OUT   "L,        8 => "CALL"L,        9, 0AH, 0BH => "JMP"L,        ENDCASE => ERROR];    SELECT opcode.n.lowNibble FROM      0, 1, 2, 3, 0BH => {  -- short Xfer        AppendDisp[s, address + 1]; length ¬ 2};      4, 5, 6, 7 => {        String.AppendNumber[port, IOPBKernel.ReadMemoryByte[address + 1, aType]];        SELECT opcode.n.lowNibble FROM          4 => Append3Strings[s, al, comma, port];          5 => Append3Strings[s, ax, comma, port];          6 => Append3Strings[s, port, comma, al];          7 => Append3Strings[s, port, comma, ax];          ENDCASE => ERROR;        length ¬ 2};      8, 9 => {        disp: LONG CARDINAL ¬ IOPBKernel.ReadMemoryWord[address + 1, aType];        absDisp: CARDINAL ¬ Inline.LowHalf[          IF disp > LAST[INTEGER] THEN 65536 - disp ELSE disp];        String.AppendString[s, "   $"L];        String.AppendString[s, IF disp > LAST[INTEGER] THEN " - "L ELSE " + "L];        String.AppendNumber[s, absDisp, 16];	String.AppendString[s, " ("L];	String.AppendLongNumber[s, 	  IF disp > LAST[INTEGER] THEN address - absDisp + 3 	  ELSE address + disp + 3, 16];	String.AppendChar[s, ')];        length ¬ 3};      0AH => {        segment: CARDINAL ¬ IOPBKernel.ReadMemoryWord[address + 3, aType];        offset: CARDINAL ¬ IOPBKernel.ReadMemoryWord[address + 1, aType];        String.AppendString[s, "   "L];        String.AppendNumber[s, segment, 16];        String.AppendString[s, ": "L];        String.AppendNumber[s, offset, 16];        length ¬ 5};      0CH => Append3Strings[s, al, comma, dx];      0DH => Append3Strings[s, ax, comma, dx];      0EH => Append3Strings[s, dx, comma, al];      0FH => Append3Strings[s, dx, comma, ax];      ENDCASE => NULL;    };  AppendDisp: PROC [s: LONG STRING, address: LONG CARDINAL] = {    int: INTEGER ¬ IOPBKernel.ReadMemoryByte[address, aType];    disp: INTEGER ¬ IF int > 127 THEN int - 256 ELSE int;    String.AppendString[s, "   $"L];    String.AppendString[s, IF disp >= 0 THEN " + "L ELSE " - "L];    String.AppendNumber[s, ABS[disp], 16];    String.AppendString[s, "  ("L];    String.AppendLongNumber[s, address + 1 + disp, 16];    String.AppendChar[s, ')]};  LokRow: PROCEDURE [    address: LONG CARDINAL, s: LONG STRING, opcode: OpCodeType,    segOverride: SegOverrideType]    RETURNS [length: CARDINAL ¬ 1, prefix: PrefixType ¬ null] = {    ls: LONG STRING ¬ NIL;    SELECT opcode.n.lowNibble FROM      0 => {ls ¬ "LOCK"L; prefix ¬ lock};      1 => ls ¬ "illegal"L;  -- illegal opcode      2 => {ls ¬ "REP"L; prefix ¬ rep};      3 => {ls ¬ "REPE"L; prefix ¬ repe};      4 => ls ¬ "HLT"L;      5 => ls ¬ "CMC"L;      6, 7 =>  -- 2 byte instruction --        {	op2: OpCodeType ¬ VAL[IOPBKernel.ReadMemoryByte[address + 1, aType]];	String.AppendString[s, SELECT op2.m.reg FROM	  0 => "TEST  "L,	  1 => "illegal"L,	  2 => "NOT   "L,	  3 => "NEG   "L,	  4 => "MUL   "L,	  5 => "IMUL  "L,	  6 => "DIV   "L,	  7 => "IDIV  "L,	  ENDCASE => ERROR];	SELECT op2.m.reg FROM	  0 => length ¬            length + AppendImmModrm[              s, op2, opcode.bw.word, address + 2, FALSE, segOverride];	  1 => NULL;	  2, 3, 4, 5, 6, 7 =>	    length ¬ length + AppendRM[	      s, op2, opcode.bw.word, address + 2, segOverride];	ENDCASE => ERROR;        };      8 => ls ¬ "CLC"L;      9 => ls ¬ "STC"L;      0AH => ls ¬ "CLI"L;      0BH => ls ¬ "STI"L;      0CH => ls ¬ "CLD"L;      0DH => ls ¬ "STD"L;      0EH => {  -- 2 byte instruction --        op2: OpCodeType ¬ VAL[IOPBKernel.ReadMemoryByte[address + 1, aType]];        String.AppendString[          s,          SELECT op2.m.reg FROM            0 => "INC   "L,            1 => "DEC   "L,            ENDCASE => "illegal"L];        SELECT op2.m.reg FROM          0, 1 => {  --r/m            length ¬ length + AppendRM[s, op2, FALSE, address + 2, segOverride];            };          ENDCASE => NULL};      0FH => {  -- 2 byte instruction --        op2: OpCodeType ¬ VAL[IOPBKernel.ReadMemoryByte[address + 1, aType]];        String.AppendString[          s,          SELECT op2.m.reg FROM            0 => "INC   "L,            1 => "DEC   "L,            2, 3 => "CALL  "L,            4, 5 => "JMP   "L,            6 => "PUSH  "L,            7 => "illegal"L,            ENDCASE => ERROR];        SELECT op2.m.reg FROM          0, 1, 6 => {  --r/m            length ¬ length + AppendRM[s, op2, TRUE, address + 2, segOverride]; };          2, 4 => {  -- intra            length ¬ length + AppendRM[s, op2, TRUE, address + 2, segOverride]; };          3, 5 => {  -- inter            length ¬ length + AppendRM[s, op2, TRUE, address + 2, segOverride]; };          7 => NULL          ENDCASE => ERROR;        };      ENDCASE;    IF ls # NIL THEN String.AppendString[s, ls];    };  AppendRM: PROC [    s: LONG STRING, opcode: OpCodeType, word: BOOLEAN, address: LONG CARDINAL,    segOverride: SegOverrideType] RETURNS [length: CARDINAL] = {    SELECT opcode.m.mod FROM      0 => {        IF opcode.m.rm = bp THEN {          AppendPtr[s, word, address, absolute, , segOverride]; length ¬ 3}        ELSE {          AppendPtr[s, word, address, register, opcode.m.rm, segOverride];          String.AppendChar[s, ']];          length ¬ 1}};      1 => {        AppendPtr[s, word, address, register, opcode.m.rm, segOverride];        String.AppendString[s, " + "L];        String.AppendNumber[s, IOPBKernel.ReadMemoryByte[address, aType], 16];        String.AppendChar[s, ']];        length ¬ 2};      2 => {        AppendPtr[s, word, address, register, opcode.m.rm, segOverride];        String.AppendString[s, " + "L];        String.AppendNumber[s, IOPBKernel.ReadMemoryWord[address, aType], 16];        String.AppendChar[s, ']];        length ¬ 3};      3 => {        String.AppendString[          s,          IF word THEN reg16Str[VAL[opcode.m.rm]] ELSE reg8Str[VAL[opcode.m.rm]]];        length ¬ 1};      ENDCASE => ERROR;    };  AppendImmModrm: PROC [    s: LONG STRING, opcode: OpCodeType, word: BOOLEAN, address: LONG CARDINAL,    signExtend: BOOLEAN, segOverride: SegOverrideType, rotate: RotateType ¬ null]    RETURNS [length: CARDINAL] = {    immData: CARDINAL ¬ 0;    append: LONG STRING ¬ [30];    length ¬ AppendRM[append, opcode, word, address, segOverride];    String.AppendString[append, ", "L];    SELECT rotate FROM      null => {        SELECT TRUE FROM          signExtend => {            int: INTEGER ¬ IOPBKernel.ReadMemoryByte[address + length - 1, aType];            IF int > 127 THEN int ¬ int - 256;            immData ¬ ABS[int];            IF int < 0 THEN String.AppendChar[append, '-];            length ¬ length + 1};          word => {            immData ¬ IOPBKernel.ReadMemoryWord[address + length - 1, aType];            length ¬ length + 2}          ENDCASE => {            immData ¬ IOPBKernel.ReadMemoryByte[address + length - 1, aType];            length ¬ length + 1};        String.AppendNumber[append, immData, 16]};      count => {        immData ¬ IOPBKernel.ReadMemoryByte[address + length - 1, aType];        length ¬ length + 1;        String.AppendNumber[append, immData, 16]};      one => String.AppendChar[append, '1];      cl => String.AppendString[append, "CL"L];      ENDCASE => ERROR;    String.AppendString[s, append];    };  AppendModrm: PROC [    s: LONG STRING, opcode: OpCodeType, regDest, word: BOOLEAN,    address: LONG CARDINAL, segOverride: SegOverrideType, seg: BOOLEAN ¬ FALSE]    RETURNS [length: CARDINAL] = {    regStr: LONG STRING ¬ [2];    memStr: LONG STRING ¬ [30];    reg: CARDINAL ¬ opcode.m.reg;    IF seg THEN String.AppendString[regStr, segStr[VAL[reg]]]    ELSE      String.AppendString[        regStr, IF word THEN reg16Str[VAL[reg]] ELSE reg8Str[VAL[reg]]];    length ¬ AppendRM[memStr, opcode, word, address, segOverride];    IF regDest THEN Append3Strings[s, regStr, ", "L, memStr]    ELSE Append3Strings[s, memStr, ", "L, regStr];    };  }.        
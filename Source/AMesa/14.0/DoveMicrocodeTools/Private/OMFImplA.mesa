-- File: OMFImplA.mesa - last edit:-- FXB   .PA           11-Apr-85 10:52:59-- Copyright (C) 1984, 1985 by Xerox Corporation. All rights reserved.-- OMFImplA.mesa -- last edited by Dennis E. DEG      @ 17-Mar-84 17:31:09-- last edited by Frank FXB    @  9-Oct-84 11:27:34-- last edited by Frank FXB    @  3-Dec-84 10:17:14DIRECTORY  FileName USING [AllocVFN, Error, FreeVFN, VFN],  InternalOMFDef,  MFile USING [ByteCount, GetCreateDate, GetLength, Handle, ReadOnly],  MSegment USING [Address, Create, Delete, Handle],  MStream USING [Handle, WriteOnly],  Stream USING [Delete],  String USING [    AppendChar, AppendExtensionIfNeeded, CopyToNewString, FreeString, MakeString],  Time USING [Packed, defaultTime],  OMF;OMFImplA: PROGRAM  IMPORTS FileName, MFile, MSegment, MStream, Stream, String EXPORTS OMF =  BEGIN  Error: PUBLIC ERROR [type: OMF.ErrorType] = CODE;  Handle: PUBLIC TYPE = InternalOMFDef.InternalHandle;  Byte: TYPE = OMF.Byte;  InternalFixupDataType: TYPE = MACHINE DEPENDENT RECORD [    fillerByte: Byte ¬ 0,    frameSpecMode: OMF.ThreadOrFixupMethod ¬ explicitly,    frame: [0..8) ¬ 0,    targetSpecMode: OMF.ThreadOrFixupMethod ¬ explicitly,    target: [0..8) ¬ 0];  InternalRecordType: PUBLIC TYPE = InternalOMFDef.InternalRecordType;  InternalRecord: PUBLIC TYPE = InternalOMFDef.InternalRecord;  InternalThreadType: TYPE = MACHINE DEPENDENT RECORD [    fillerByte: Byte ¬ 0,    type: OMF.ThreadOrFixupType ¬ thread,    thredtype: OMF.ThreadType ¬ targetThread,    z: BOOLEAN ¬ FALSE,    method: [0..8) ¬ 0,    thred: [0..4) ¬ 0];  OperationType: TYPE = OMF.OperationType;  Object: PUBLIC TYPE = InternalOMFDef.Object;  RecordType: TYPE = OMF.RecordType;  oneK: LONG CARDINAL = 1024;  sixtyFourK: LONG CARDINAL = 64 * oneK;  AdvanceToNextRecord: PUBLIC PROCEDURE [handle: Handle]    RETURNS [endOfFile: BOOLEAN] =    BEGIN    offset: NATURAL ¬ NATURAL[handle.currentPosition MOD 2];    length: CARDINAL ¬ 0;    IF handle = NIL THEN Error[type: invalidHandle];    IF handle.type = write THEN Error[type: invalidRequest];    IF handle.recordPointer = NIL THEN RETURN[endOfFile: TRUE];    length ¬ GetLength[handle: handle];    IF (length + handle.currentPosition) > handle.fileLength THEN      Error[type: malformedRecord];    handle.recordPointer ¬ handle.recordPointer + (length + offset) / 2;    handle.currentPosition ¬ handle.currentPosition + length;    endOfFile ¬ handle.currentPosition >= handle.fileLength;    END;  GetHandle: PUBLIC PROCEDURE [    operation: OperationType, fileName: LONG STRING, extension: LONG STRING,    heap: UNCOUNTED ZONE]     RETURNS [handle: Handle, create: Time.Packed ¬ Time.defaultTime] =    BEGIN    fileHandle: MFile.Handle ¬ NIL;    sourceFile: LONG STRING ¬ NIL;    sourceFileVFN: FileName.VFN ¬ NIL;    handle ¬ heap.NEW[Object ¬ [type: operation]];    sourceFile ¬ String.CopyToNewString[s: fileName, z: heap, longer: 4];    [] ¬ String.AppendExtensionIfNeeded[      to: @sourceFile, extension: (IF extension = NIL THEN "obj"L ELSE extension),      z: heap];    sourceFileVFN ¬ FileName.AllocVFN[      sourceFile ! FileName.Error => Error[type: noSuchFile]];    SELECT operation FROM      read => {        fileHandle ¬ MFile.ReadOnly[name: sourceFile, release: []];        handle.fileLength ¬ MFile.GetLength[file: fileHandle];        handle.segmentHandle ¬ MSegment.Create[file: fileHandle, release: []];        handle.recordPointer ¬ MSegment.Address[segment: handle.segmentHandle];        handle.heap ¬ heap;	create ¬ MFile.GetCreateDate[fileHandle];	};      write => {        handle.streamHandle ¬ MStream.WriteOnly[          name: sourceFileVFN.name, release: [], type: binary]};      ENDCASE;    String.FreeString[z: heap, s: sourceFile];    FileName.FreeVFN[sourceFileVFN];    sourceFileVFN ¬ NIL;    END;  GetRecordType: PUBLIC PROCEDURE [handle: Handle]    RETURNS [recordType: RecordType] =    BEGIN    bytePtr: LONG POINTER TO InternalOMFDef.InternalRecord;    length: CARDINAL ¬ 0;    checkSum: CARDINAL ¬ 0;    type: InternalRecordType;    offset: NATURAL;    recordType ¬ comment;    IF handle = NIL THEN Error[type: invalidHandle];    IF handle.type # read THEN Error[type: invalidRequest];    offset ¬ NATURAL[handle.currentPosition MOD 2];    type ¬ VAL[handle.recordPointer.bytes[offset]];    length ¬ GetLength[handle: handle];    IF (length + handle.currentPosition) > handle.fileLength THEN      Error[type: malformedRecord];    bytePtr ¬ handle.recordPointer;    FOR index: CARDINAL IN [0..length) DO      checkSum ¬ (checkSum + bytePtr.bytes[index + offset]) MOD 400B;      ENDLOOP;    IF (checkSum ¬ checkSum MOD 400B) # 0 THEN Error[type: invalidChecksum];    SELECT type FROM      debugSymbol => recordType ¬ debugSymbol;      physicalEnumeratedData => recordType ¬ physicalEnumeratedData;      physicalIteratedData => recordType ¬ physicalIteratedData;      externalDefinition => recordType ¬ externalDefinition;      typeDefinition => recordType ¬ typeDefinition;      publicDefinition => recordType ¬ publicDefinition;      listOfNames => recordType ¬ listOfNames;      segmentDefinition => recordType ¬ segmentDefinition;      groupDefinition => recordType ¬ groupDefinition;      fixUp => recordType ¬ fixUp;      logicalEnumeratedData => recordType ¬ logicalEnumeratedData;      logicalIteratedData => recordType ¬ logicalIteratedData;      comment => recordType ¬ comment;      blockDefinition => recordType ¬ blockDefinition;      blockEnd => recordType ¬ blockEnd;      moduleEnd => recordType ¬ moduleEnd;      tHeader => recordType ¬ tHeader;      lHeader => recordType ¬ lHeader;      endRecord => recordType ¬ endRecord;      registerInitialization => recordType ¬ registerInitialization;      localSymbol => recordType ¬ localSymbol;      lineNumber => recordType ¬ lineNumber;      relocatableEnumeratedData => recordType ¬ relocatableEnumeratedData;      relocatableIteratedData => recordType ¬ relocatableIteratedData;      rHeader => recordType ¬ rHeader;      libraryHeader => recordType ¬ libraryHeader;      libraryModuleNames => recordType ¬ libraryModuleNames;      libraryModuleLocations => recordType ¬ libraryModuleLocations;      libraryDictionary => recordType ¬ libraryDictionary;      overlayDefinition => recordType ¬ overlayDefinition;      ENDCASE => Error[type: malformedRecord];    END;  ReleaseHandle: PUBLIC PROCEDURE [handle: Handle] RETURNS [nilHandle: Handle] =    BEGIN    heap: UNCOUNTED ZONE ¬ NIL;    IF handle = NIL THEN RETURN[nilHandle: NIL];    IF handle.segmentHandle # NIL THEN {      MSegment.Delete[segment: handle.segmentHandle]; handle.segmentHandle ¬ NIL};    IF handle.streamHandle # NIL THEN {      Stream.Delete[sH: handle.streamHandle]; handle.streamHandle ¬ NIL};    IF handle.heap # NIL THEN BEGIN heap ¬ handle.heap; heap.FREE[@handle]; END;    nilHandle ¬ NIL;    END;  <<  *******************     PUBLIC Get and Put routines for individual records     *******************  >>  GetBlockDefinition: PUBLIC PROCEDURE [handle: Handle]    RETURNS [blockPointer: LONG POINTER TO OMF.BlockDefinition] =    BEGIN    ProcedureInfo: TYPE = MACHINE DEPENDENT RECORD [      byte(0:0..7): Byte,      procedureDefinition(0:8..8): BOOLEAN,      isLongProcedure(0:9..9): BOOLEAN,      unused(0:10..15): [0..64)];    checksumOffset: NATURAL;    currentPtr: LONG POINTER TO OMF.BlockDefinition ¬ NIL;    offset: NATURAL;    procedureInfo: ProcedureInfo;    tempPtr: LONG POINTER TO OMF.BlockDefinition ¬ NIL;    [offset: offset, checksumOffset: checksumOffset] ¬ CommonGetInformation[      handle: handle, desiredType: blockDefinition];    blockPointer ¬ handle.heap.NEW[OMF.BlockDefinition ¬ []];    GetBase[handle: handle, basePtr: @blockPointer.base, offsetPtr: @offset];    blockPointer.blockInfo.name ¬ GetName[handle: handle, offset: offset];    offset ¬ offset + blockPointer.blockInfo.name.length + 1;    blockPointer.blockInfo.offset ¬ GetCardinal[      handle: handle, offsetPtr: @offset];    blockPointer.blockInfo.length ¬ GetCardinal[      handle: handle, offsetPtr: @offset];    procedureInfo ¬ LOOPHOLE[handle.recordPointer.bytes[offset], ProcedureInfo];    offset ¬ offset + 1;    blockPointer.procedureInfo.procedureDefinition ¬      procedureInfo.procedureDefinition;    blockPointer.procedureInfo.isLongProcedure ¬ procedureInfo.isLongProcedure;    IF procedureInfo.procedureDefinition THEN      BEGIN      IF procedureInfo.isLongProcedure THEN        BEGIN        GetLongCardinal[          handle: handle, offsetPtr: @offset,          longCardinalPtr: @blockPointer.procedureInfo.returnAddress];        END      ELSE        BEGIN        blockPointer.procedureInfo.returnAddress ¬ GetCardinal[          handle: handle, offsetPtr: @offset];        END;      END;    IF blockPointer.blockInfo.name.length > 0 THEN      blockPointer.typeIndex ¬ GetIndex[handle: handle, offsetPtr: @offset];    END;  GetComment: PUBLIC PROCEDURE [handle: Handle]    RETURNS [commentPtr: LONG POINTER TO OMF.CommentData] =    BEGIN    CommentOptions: TYPE = MACHINE DEPENDENT RECORD [      pad(0:0..7): [0..256),      notPurgeable(0:8..8): BOOLEAN,      notListable(0:9..9): BOOLEAN,      zeros(0:10..15): [0..64)];    checksumOffset: NATURAL;    offset: NATURAL;    options: CommentOptions;    stringLength: CARDINAL;    [offset: offset, checksumOffset: checksumOffset] ¬ CommonGetInformation[      handle: handle, desiredType: comment];    commentPtr ¬ handle.heap.NEW[OMF.CommentData];    commentPtr.class ¬ VAL[handle.recordPointer.bytes[offset]];    options ¬ LOOPHOLE[handle.recordPointer.bytes[offset + 1], CommentOptions];    commentPtr.purgeable ¬ ~options.notPurgeable;    commentPtr.list ¬ ~options.notListable;    offset ¬ offset + 2;    stringLength ¬ checksumOffset - offset;    commentPtr.comment ¬ String.MakeString[      z: handle.heap, maxlength: stringLength];    ConvertSimpleStringToLongString[      handle: handle, offset: offset, string: commentPtr.comment];    END;  GetDebugSymbols: PUBLIC PROCEDURE [handle: Handle]    RETURNS [debugSymbolsPtr: LONG POINTER TO OMF.DebugSymbols] =    BEGIN    InternalFrameInfo: TYPE = MACHINE DEPENDENT RECORD [      byte: Byte,      b: OMF.Based,      l: OMF.AddressLength,      pad: [0..8),      frameMethod: [0..8)];    checksumOffset: NATURAL;    offset: NATURAL;    tempPtr, symbolEntriesPtr: LONG POINTER TO OMF.SymbolsRecord ¬ NIL;    frameInfo: InternalFrameInfo;    [offset: offset, checksumOffset: checksumOffset] ¬ CommonGetInformation[      handle: handle, desiredType: debugSymbol];    frameInfo ¬ LOOPHOLE[handle.recordPointer.bytes[offset], InternalFrameInfo];    offset ¬ offset + 1;    SELECT frameInfo.frameMethod FROM      0 => {        debugSymbolsPtr ¬ handle.heap.NEW[          OMF.DebugSymbols ¬ [frameInformation: [method: basedSymbol[]]]]};      1 => {        debugSymbolsPtr ¬ handle.heap.NEW[          OMF.DebugSymbols ¬ [frameInformation: [method: extIndex[]]]]};      2 => {        debugSymbolsPtr ¬ handle.heap.NEW[          OMF.DebugSymbols ¬ [frameInformation: [method: blokIndex[]]]]};      ENDCASE => ERROR;    debugSymbolsPtr.frameInformation.addressLength ¬ frameInfo.l;    debugSymbolsPtr.frameInformation.based ¬ frameInfo.b;    WITH debugSymbolsPtr.frameInformation SELECT FROM      basedSymbol => {GetBase[handle: handle, basePtr: @base, offsetPtr: @offset]};      extIndex => {externalIndex ¬ GetIndex[handle: handle, offsetPtr: @offset]};      blokIndex => {blockIndex ¬ GetIndex[handle: handle, offsetPtr: @offset]};      ENDCASE => ERROR;    UNTIL offset = checksumOffset DO      tempPtr ¬ handle.heap.NEW[OMF.SymbolsRecord ¬ []];      IF debugSymbolsPtr.entries = NIL THEN        BEGIN debugSymbolsPtr.entries ¬ symbolEntriesPtr ¬ tempPtr; END      ELSE        BEGIN        symbolEntriesPtr.next ¬ tempPtr;        symbolEntriesPtr ¬ symbolEntriesPtr.next;        END;      symbolEntriesPtr.symbol ¬ GetName[handle: handle, offset: offset];      offset ¬ offset + symbolEntriesPtr.symbol.length + 1;      symbolEntriesPtr.offset ¬ GetCardinal[handle: handle, offsetPtr: @offset];      symbolEntriesPtr.typeIndex ¬ GetIndex[handle: handle, offsetPtr: @offset];      ENDLOOP;    END;  GetEndRecord: PUBLIC PROCEDURE [handle: Handle] RETURNS [endType: OMF.EndType] =    BEGIN    offset: NATURAL;    [offset: offset] ¬ CommonGetInformation[      handle: handle, desiredType: endRecord];    endType ¬ VAL[handle.recordPointer.bytes[offset]];    END;  GetExternalNames: PUBLIC PROCEDURE [handle: Handle]    RETURNS [externalNamesPtr: OMF.ExternalNamesSeq] =    BEGIN    baseOffset: NATURAL;    checksumOffset: NATURAL;    index: NATURAL;    nameCount: NATURAL ¬ 1;    offset: NATURAL;    [offset: offset, checksumOffset: checksumOffset] ¬ CommonGetInformation[      handle: handle, desiredType: externalDefinition];    baseOffset ¬ offset;    UNTIL offset = checksumOffset DO      offset ¬ ORD[handle.recordPointer.bytes[offset]] + offset + 1;      index ¬ GetIndex[handle: handle, offsetPtr: @offset];      nameCount ¬ nameCount + 1;      ENDLOOP;    externalNamesPtr ¬ handle.heap.NEW[      OMF .ExternalNamesSeqBody[nameCount] ¬ [length: nameCount, seq: NULL]];    offset ¬ baseOffset;    externalNamesPtr.seq[0] ¬ [];    FOR index: NATURAL IN [1..nameCount) DO      externalNamesPtr.seq[index].extName ¬ GetName[        handle: handle, offset: offset];      offset ¬ ORD[handle.recordPointer.bytes[offset]] + offset + 1;      externalNamesPtr.seq[index].typeIndex ¬ GetIndex[        handle: handle, offsetPtr: @offset];      externalNamesPtr.seq[index].resolved ¬ FALSE;      ENDLOOP;    END;  GetFixup: PUBLIC PROCEDURE [handle: Handle]    RETURNS [fixupPtr: LONG POINTER TO OMF.FixupData] =    BEGIN    checksumOffset: NATURAL;    data: InternalFixupDataType;    offset: NATURAL;    currentPtr: LONG POINTER TO OMF.FixupData ¬ NIL;    tempPtr: LONG POINTER TO OMF.FixupData ¬ NIL;    threadType: InternalThreadType;    [offset: offset, checksumOffset: checksumOffset] ¬ CommonGetInformation[      handle: handle, desiredType: fixUp];    fixupPtr ¬ NIL;    UNTIL offset = checksumOffset DO      IF handle.recordPointer.bytes[offset] < 128 THEN        BEGIN        threadType ¬ VAL[handle.recordPointer.bytes[offset]];        offset ¬ offset + 1;        IF threadType.thredtype = targetThread THEN          BEGIN          tempPtr ¬ handle.heap.NEW[            OMF.FixupData ¬ [body: thread[method: targetThread[]]]];          END        ELSE          BEGIN          tempPtr ¬ handle.heap.NEW[            OMF.FixupData ¬ [body: thread[method: frameThread[]]]];          END;        END      ELSE        BEGIN        data ¬ LOOPHOLE[handle.recordPointer.bytes[offset + 2],          InternalFixupDataType];        IF data.frameSpecMode = explicitly THEN          BEGIN          IF data.targetSpecMode = explicitly THEN            BEGIN            tempPtr ¬ handle.heap.NEW[              OMF.FixupData ¬ [              body: fixup[              address: [              frameSpec: [frameTag: explicitly[frameMethod: VAL[data.frame]]],              targetSpec: [              targetTag: explicitly[targetMethod: VAL[data.target]]]]]]];            END          ELSE            BEGIN            tempPtr ¬ handle.heap.NEW[              OMF.FixupData ¬ [              body: fixup[              address: [              frameSpec: [frameTag: explicitly[frameMethod: VAL[data.frame]]],              targetSpec: [              targetTag: byThread[              specification: IF data.target > 3 THEN secondary ELSE primary,              targetThread: data.target MOD 4]]]]]];            END;          END        ELSE          BEGIN          IF data.targetSpecMode = explicitly THEN            BEGIN            tempPtr ¬ handle.heap.NEW[              OMF.FixupData ¬ [              body: fixup[              address: [              frameSpec: [frameTag: byThread[frameThread: data.frame MOD 4]],              targetSpec: [              targetTag: explicitly[targetMethod: VAL[data.target]]]]]]];            END          ELSE            BEGIN            tempPtr ¬ handle.heap.NEW[              OMF.FixupData ¬ [              body: fixup[              address: [              frameSpec: [frameTag: byThread[frameThread: data.frame MOD 4]],              targetSpec: [              targetTag: byThread[              specification: IF data.target > 3 THEN secondary ELSE primary,              targetThread: data.target MOD 4]]]]]];            END;          END;        END;      IF fixupPtr = NIL THEN BEGIN fixupPtr ¬ currentPtr ¬ tempPtr; END      ELSE BEGIN currentPtr.next ¬ tempPtr; currentPtr ¬ currentPtr.next; END;      WITH alias: currentPtr SELECT FROM        thread => {          alias.thred ¬ threadType.thred;          WITH alias SELECT FROM            targetThread => {targetSpec ¬ VAL[threadType.method MOD 4]};            frameThread => {frameSpec ¬ VAL[threadType.method]};            ENDCASE => ERROR;          WITH alias SELECT FROM            targetThread => {              SELECT targetSpec FROM                frameNumber => {                  alias.indexORFrameNumber ¬ GetCardinal[                    handle: handle, offsetPtr: @offset]};                ENDCASE =>                  alias.indexORFrameNumber ¬ GetIndex[                    handle: handle, offsetPtr: @offset]};            frameThread => {              SELECT frameSpec FROM                frameNumber => {                  alias.indexORFrameNumber ¬ GetCardinal[                    handle: handle, offsetPtr: @offset]};                segmentIndex, groupIndex, externalIndex, location, target =>                  alias.indexORFrameNumber ¬ GetIndex[                    handle: handle, offsetPtr: @offset];                ENDCASE => ERROR};            ENDCASE;          };        fixup => {          alias.locat ¬            LOOPHOLE[handle.recordPointer.bytes[offset] * 400B +                       handle.recordPointer.bytes[offset + 1], OMF.LocatType];          offset ¬ offset + 2;          GetLogicalAddress[            handle: handle, addressPtr: @alias.address, offsetPtr: @offset,            targetDispLength:            (IF (alias.locat.targetDispLen = twoBytes) THEN twoBytes             ELSE threeBytes)]};        ENDCASE => ERROR;      ENDLOOP;    END;  GetGroupDefinition: PUBLIC PROCEDURE [handle: Handle]    RETURNS [groupDefinitionPtr: LONG POINTER TO OMF.GroupDefinitionData] =    BEGIN    LTLData: TYPE = MACHINE DEPENDENT RECORD [      unused: [0..16384) ¬ 0,      bigGroupLength: BOOLEAN ¬ FALSE,      bigGroupMaxlength: BOOLEAN ¬ FALSE];    checksumOffset: NATURAL;    componentType: OMF.GroupComponentEnumerated;    ltlByte: LTLData ¬ [];    anOffset: NATURAL;    prevPtr: LONG POINTER TO OMF.GroupComponent ¬ NIL;    tempPtr: LONG POINTER TO OMF.GroupComponent ¬ NIL;    groupDefinitionPtr ¬ handle.heap.NEW[OMF.GroupDefinitionData ¬ []];    [offset: anOffset, checksumOffset: checksumOffset] ¬ CommonGetInformation[      handle: handle, desiredType: groupDefinition];    groupDefinitionPtr.groupNameIndex ¬ GetIndex[      handle: handle, offsetPtr: @anOffset];    UNTIL anOffset = checksumOffset DO      componentType ¬ VAL[handle.recordPointer.bytes[anOffset]];      anOffset ¬ anOffset + 1;      SELECT componentType FROM        segmentIndexDef =>          tempPtr ¬ handle.heap.NEW[            OMF.GroupComponent ¬ [groupComponentDescriptor: segmentIndexDef[]]];        externalIndexDef =>          tempPtr ¬ handle.heap.NEW[            OMF.GroupComponent ¬ [groupComponentDescriptor: externalIndexDef[]]];        segmentClassOverlay =>          tempPtr ¬ handle.heap.NEW[            OMF.GroupComponent ¬ [            groupComponentDescriptor: segmentClassOverlay[]]];        loadTimeLocatableGroup =>          tempPtr ¬ handle.heap.NEW[            OMF.GroupComponent ¬ [            groupComponentDescriptor: loadTimeLocatableGroup[]]];        absoluteGroup =>          tempPtr ¬ handle.heap.NEW[            OMF.GroupComponent ¬ [groupComponentDescriptor: absoluteGroup[]]];        ENDCASE => ERROR;      WITH tempPtr SELECT FROM        segmentIndexDef => {          segmentIndex ¬ GetIndex[handle: handle, offsetPtr: @anOffset]};        externalIndexDef => {          externalIndex ¬ GetIndex[handle: handle, offsetPtr: @anOffset]};        segmentClassOverlay => {          segmentNameIndex ¬ GetIndex[handle: handle, offsetPtr: @anOffset];          classNameIndex ¬ GetIndex[handle: handle, offsetPtr: @anOffset];          overlayNameIndex ¬ GetIndex[handle: handle, offsetPtr: @anOffset]};        loadTimeLocatableGroup => {          ltlByte ¬ LOOPHOLE[handle.recordPointer.bytes[anOffset], LTLData];          anOffset ¬ anOffset + 1;          maxGroupLength ¬ GetCardinal[handle: handle, offsetPtr: @anOffset];          IF ltlByte.bigGroupMaxlength THEN            maxGroupLength ¬ maxGroupLength + sixtyFourK;          groupLength ¬ GetCardinal[handle: handle, offsetPtr: @anOffset];          IF ltlByte.bigGroupLength THEN groupLength ¬ groupLength + sixtyFourK};        absoluteGroup => {          frameNumber ¬ GetCardinal[handle: handle, offsetPtr: @anOffset];          offset ¬ handle.recordPointer.bytes[anOffset];          anOffset ¬ anOffset + 1};        ENDCASE => ERROR;      IF groupDefinitionPtr.componentList = NIL THEN        BEGIN groupDefinitionPtr.componentList ¬ prevPtr ¬ tempPtr; END      ELSE BEGIN prevPtr.next ¬ tempPtr; prevPtr ¬ prevPtr.next; END;      ENDLOOP;    END;  GetLineNumber: PUBLIC PROCEDURE [handle: Handle]    RETURNS [lineNumberPtr: LONG POINTER TO OMF.LineNumberData] =    BEGIN    checksumOffset: NATURAL;    entries: CARDINAL;    offset: NATURAL;    tempBase: OMF.Base;    [offset: offset, checksumOffset: checksumOffset] ¬ CommonGetInformation[      handle: handle, desiredType: lineNumber];    GetBase[handle: handle, basePtr: @tempBase, offsetPtr: @offset];    entries ¬ (checksumOffset - offset) / 4;    lineNumberPtr ¬ handle.heap.NEW[      OMF .LineNumberData[entries] ¬ [      base: tempBase, numberOfEntries: entries, seq: NULL]];    entries ¬ 0;    UNTIL offset = checksumOffset DO      lineNumberPtr.seq[entries].lineNumber ¬ GetCardinal[        handle: handle, offsetPtr: @offset];      lineNumberPtr.seq[entries].lineNumberOffset ¬ GetCardinal[        handle: handle, offsetPtr: @offset];      entries ¬ entries + 1;      ENDLOOP;    END;  GetListOfNames: PUBLIC PROCEDURE [handle: Handle]    RETURNS [nameList: LONG POINTER TO OMF.ListOfNamesData] =    BEGIN    baseOffset: NATURAL;    checksumOffset: NATURAL;    nameCount: NATURAL ¬ 1;    offset: NATURAL;    [offset: offset, checksumOffset: checksumOffset] ¬ CommonGetInformation[      handle: handle, desiredType: listOfNames];    baseOffset ¬ offset;    UNTIL offset = checksumOffset DO      offset ¬ ORD[handle.recordPointer.bytes[offset]] + offset + 1;      nameCount ¬ nameCount + 1;      ENDLOOP;    nameList ¬ handle.heap.NEW[      OMF .ListOfNamesData[nameCount] ¬ [length: nameCount, seq: NULL]];    offset ¬ baseOffset;    nameList.seq[0] ¬ NIL;    FOR index: NATURAL IN [1..nameCount) DO      nameList.seq[index] ¬ GetName[handle: handle, offset: offset];      offset ¬ ORD[handle.recordPointer.bytes[offset]] + offset + 1;      ENDLOOP;    END;  GetLogicalEnumeratedData: PUBLIC PROCEDURE [handle: Handle]    RETURNS [logicalEnumeratedDataPtr: LONG POINTER TO OMF.LogicalEnumeratedData] =    BEGIN    checksumOffset: NATURAL;    dataLength: NATURAL;    offset: NATURAL;    [offset: offset, checksumOffset: checksumOffset] ¬ CommonGetInformation[      handle: handle, desiredType: logicalEnumeratedData];    logicalEnumeratedDataPtr ¬ handle.heap.NEW[OMF.LogicalEnumeratedData ¬ []];    logicalEnumeratedDataPtr.segmentIndex ¬ GetIndex[      handle: handle, offsetPtr: @offset];    logicalEnumeratedDataPtr.enumeratedDataOffset ¬ GetCardinal[      handle: handle, offsetPtr: @offset];    dataLength ¬ checksumOffset - offset;    logicalEnumeratedDataPtr.dataPtr ¬ handle.heap.NEW[      OMF .DataSequence[dataLength] ¬ [length: dataLength, seq: NULL]];    FOR index: NATURAL IN [0..dataLength) DO      logicalEnumeratedDataPtr.dataPtr.seq[index] ¬ handle.recordPointer.bytes[        offset + index];      ENDLOOP;    END;  GetLogicalIteratedData: PUBLIC PROCEDURE [handle: Handle]    RETURNS [logicalIteratedDataPtr: LONG POINTER TO OMF.LogicalIteratedData] =    BEGIN    checksumOffset: NATURAL;    offset: NATURAL;    [offset: offset, checksumOffset: checksumOffset] ¬ CommonGetInformation[      handle: handle, desiredType: logicalIteratedData];    logicalIteratedDataPtr ¬ handle.heap.NEW[OMF.LogicalIteratedData ¬ []];    logicalIteratedDataPtr.segmentIndex ¬ GetIndex[      handle: handle, offsetPtr: @offset];    logicalIteratedDataPtr.iteratedDataOffset ¬ GetCardinal[      handle: handle, offsetPtr: @offset];    GetIteratedData[      handle: handle,      iteratedDataPtrPtr: @logicalIteratedDataPtr.iteratedDataBlockPtr,      offsetPtr: @offset, checksumOffset: checksumOffset];    END;  GetLModuleName: PUBLIC PROCEDURE [handle: Handle] RETURNS [lName: LONG STRING] =    BEGIN    offset: NATURAL;    [offset: offset] ¬ CommonGetInformation[handle: handle, desiredType: lHeader];    lName ¬ GetName[handle: handle, offset: offset];    END;  GetModuleEnd: PUBLIC PROCEDURE [handle: Handle]    RETURNS [moduleEndRecordPtr: LONG POINTER TO OMF.ModuleEndData] =    BEGIN    checksumOffset: NATURAL;    data: InternalFixupDataType;    moduleType: OMF.ModuleType;    anOffset: NATURAL;    [offset: anOffset, checksumOffset: checksumOffset] ¬ CommonGetInformation[      handle: handle, desiredType: moduleEnd];    moduleType ¬ LOOPHOLE[handle.recordPointer.bytes[anOffset], OMF.ModuleType];    IF (moduleType.addressMode = physicalAddr) THEN      BEGIN      moduleEndRecordPtr ¬ handle.heap.NEW[        OMF.ModuleEndData ¬ [startAddress: physicalAddr[]]];      END    ELSE      BEGIN      data ¬ LOOPHOLE[handle.recordPointer.bytes[anOffset + 1],        InternalFixupDataType];      IF data.frameSpecMode = explicitly THEN        BEGIN        IF data.targetSpecMode = explicitly THEN          BEGIN          moduleEndRecordPtr ¬ handle.heap.NEW[            OMF.ModuleEndData ¬ [            startAddress: logicalAddr[            address: [            frameSpec: [frameTag: explicitly[frameMethod: VAL[data.frame]]],            targetSpec: [            targetTag: explicitly[targetMethod: VAL[data.target]]]]]]];          END        ELSE          BEGIN          moduleEndRecordPtr ¬ handle.heap.NEW[            OMF.ModuleEndData ¬ [            startAddress: logicalAddr[            address: [            frameSpec: [frameTag: explicitly[frameMethod: VAL[data.frame]]],            targetSpec: [            targetTag: byThread[            specification: IF data.target > 3 THEN secondary ELSE primary,            targetThread: data.target MOD 4]]]]]];          END;        END      ELSE        BEGIN        IF data.targetSpecMode = explicitly THEN          BEGIN          moduleEndRecordPtr ¬ handle.heap.NEW[            OMF.ModuleEndData ¬ [            startAddress: logicalAddr[            address: [            frameSpec: [frameTag: byThread[frameThread: data.frame MOD 4]],            targetSpec: [            targetTag: explicitly[targetMethod: VAL[data.target]]]]]]];          END        ELSE          BEGIN          moduleEndRecordPtr ¬ handle.heap.NEW[            OMF.ModuleEndData ¬ [            startAddress: logicalAddr[            address: [            frameSpec: [frameTag: byThread[frameThread: data.frame MOD 4]],            targetSpec: [            targetTag: byThread[            specification: IF data.target > 3 THEN secondary ELSE primary,            targetThread: data.target MOD 4]]]]]];          END;        END;      END;    moduleEndRecordPtr.moduleType ¬ moduleType;    anOffset ¬ anOffset + 1;    IF ~moduleType.hasStartAddress THEN RETURN;    WITH moduleEndRecordPtr SELECT FROM      logicalAddr =>        GetLogicalAddress[          handle: handle, addressPtr: @address, offsetPtr: @anOffset];      physicalAddr => {        frameNumber ¬ GetCardinal[handle: handle, offsetPtr: @anOffset];        offset ¬ GetCardinal[handle: handle, offsetPtr: @anOffset]};      ENDCASE => ERROR;    END;  GetPhysicalEnumeratedData: PUBLIC PROCEDURE [handle: Handle]    RETURNS [      physicalEnumeratedDataPtr: LONG POINTER TO OMF.PhysicalEnumeratedData] =    BEGIN    checksumOffset: NATURAL;    dataLength: NATURAL;    offset: NATURAL;    [offset: offset, checksumOffset: checksumOffset] ¬ CommonGetInformation[      handle: handle, desiredType: physicalEnumeratedData];    physicalEnumeratedDataPtr ¬ handle.heap.NEW[OMF.PhysicalEnumeratedData ¬ []];    physicalEnumeratedDataPtr.frameNumber ¬ GetCardinal[      handle: handle, offsetPtr: @offset];    physicalEnumeratedDataPtr.offset ¬ handle.recordPointer.bytes[offset];    offset ¬ offset + 1;    dataLength ¬ checksumOffset - offset;    physicalEnumeratedDataPtr.dataPtr ¬ handle.heap.NEW[      OMF .DataSequence[dataLength] ¬ [length: dataLength, seq: NULL]];    FOR index: NATURAL IN [0..dataLength) DO      physicalEnumeratedDataPtr.dataPtr.seq[index] ¬ handle.recordPointer.bytes[        offset + index];      ENDLOOP;    END;  GetPhysicalIteratedData: PUBLIC PROCEDURE [handle: Handle]    RETURNS [physicalIteratedDataPtr: LONG POINTER TO OMF.PhysicalIteratedData] =    BEGIN    checksumOffset: NATURAL;    offset: NATURAL;    [offset: offset, checksumOffset: checksumOffset] ¬ CommonGetInformation[      handle: handle, desiredType: physicalIteratedData];    physicalIteratedDataPtr ¬ handle.heap.NEW[OMF.PhysicalIteratedData ¬ []];    physicalIteratedDataPtr.frameNumber ¬ GetCardinal[      handle: handle, offsetPtr: @offset];    physicalIteratedDataPtr.offset ¬ handle.recordPointer.bytes[offset];    offset ¬ offset + 1;    GetIteratedData[      handle: handle,      iteratedDataPtrPtr: @physicalIteratedDataPtr.iteratedDataBlockPtr,      offsetPtr: @offset, checksumOffset: checksumOffset];    END;  GetPublicNames: PUBLIC PROCEDURE [handle: Handle]    RETURNS [publicNamesPtr: LONG POINTER TO OMF.PublicNamesData] =    BEGIN    checksumOffset: NATURAL;    currentPtr: LONG POINTER TO OMF.PublicNamesNode ¬ NIL;    offset: NATURAL;    tempPtr: LONG POINTER TO OMF.PublicNamesNode ¬ NIL;    [offset: offset, checksumOffset: checksumOffset] ¬ CommonGetInformation[      handle: handle, desiredType: publicDefinition];    publicNamesPtr ¬ handle.heap.NEW[OMF.PublicNamesData ¬ []];    GetBase[      handle: handle, basePtr: @publicNamesPtr.publicBase, offsetPtr: @offset];    UNTIL offset = checksumOffset DO      tempPtr ¬ handle.heap.NEW[OMF.PublicNamesNode ¬ []];      IF publicNamesPtr.namesList = NIL THEN        BEGIN publicNamesPtr.namesList ¬ currentPtr ¬ tempPtr; END      ELSE BEGIN currentPtr.next ¬ tempPtr; currentPtr ¬ currentPtr.next; END;      currentPtr.publicName ¬ GetName[handle: handle, offset: offset];      offset ¬ ORD[handle.recordPointer.bytes[offset]] + offset + 1;      currentPtr.publicOffset ¬ GetCardinal[handle: handle, offsetPtr: @offset];      currentPtr.typeIndex ¬ GetIndex[handle: handle, offsetPtr: @offset];      ENDLOOP;    END;  GetRegisterInitialization: PUBLIC PROCEDURE [handle: Handle]    RETURNS [registerInitPtr: LONG POINTER TO OMF.RegisterInitializationData] =    BEGIN    checksumOffset: NATURAL;    currentPtr: LONG POINTER TO OMF.RegisterInitializationData ¬ NIL;    data: InternalFixupDataType;    offset: NATURAL;    registerType: OMF.RegisterInit;    tempPtr: LONG POINTER TO OMF.RegisterInitializationData ¬ NIL;    registerInitPtr ¬ NIL;    [offset: offset, checksumOffset: checksumOffset] ¬ CommonGetInformation[      handle: handle, desiredType: registerInitialization];    UNTIL offset = checksumOffset DO      registerType ¬ LOOPHOLE[handle.recordPointer.bytes[offset],        OMF.RegisterInit];      IF LOOPHOLE[registerType.unassigned MOD 2, OMF.RegIntLType] = baseAndOffset        THEN        BEGIN        tempPtr ¬ handle.heap.NEW[          baseAndOffset OMF.RegisterInitializationData ¬ [          registerContents: baseAndOffset[]]];        END      ELSE        BEGIN        data ¬ LOOPHOLE[handle.recordPointer.bytes[offset + 1],          InternalFixupDataType];        IF data.frameSpecMode = explicitly THEN          BEGIN          IF data.targetSpecMode = explicitly THEN            BEGIN            tempPtr ¬ handle.heap.NEW[              logicalAddr OMF.RegisterInitializationData ¬ [              registerContents: logicalAddr[              address: [              frameSpec: [frameTag: explicitly[frameMethod: VAL[data.frame]]],              targetSpec: [              targetTag: explicitly[targetMethod: VAL[data.target]]]]]]];            END          ELSE            BEGIN            tempPtr ¬ handle.heap.NEW[              logicalAddr OMF.RegisterInitializationData ¬ [              registerContents: logicalAddr[              address: [              frameSpec: [frameTag: explicitly[frameMethod: VAL[data.frame]]],              targetSpec: [              targetTag: byThread[              specification: IF data.target > 3 THEN secondary ELSE primary,              targetThread: data.target MOD 4]]]]]];            END;          END        ELSE          BEGIN          IF data.targetSpecMode = explicitly THEN            BEGIN            tempPtr ¬ handle.heap.NEW[              logicalAddr OMF.RegisterInitializationData ¬ [              registerContents: logicalAddr[              address: [              frameSpec: [frameTag: byThread[frameThread: data.frame MOD 4]],              targetSpec: [              targetTag: explicitly[targetMethod: VAL[data.target]]]]]]];            END          ELSE            BEGIN            tempPtr ¬ handle.heap.NEW[              logicalAddr OMF.RegisterInitializationData ¬ [              registerContents: logicalAddr[              address: [              frameSpec: [frameTag: byThread[frameThread: data.frame MOD 4]],              targetSpec: [              targetTag: byThread[              specification: IF data.target > 3 THEN secondary ELSE primary,              targetThread: data.target MOD 4]]]]]];            END;          END;        END;      IF registerInitPtr = NIL THEN        BEGIN registerInitPtr ¬ currentPtr ¬ tempPtr; END      ELSE BEGIN currentPtr.next ¬ tempPtr; currentPtr ¬ currentPtr.next; END;      currentPtr.registerType ¬ registerType;      offset ¬ offset + 1;      WITH currentPtr SELECT FROM        baseAndOffset => {          GetBase[handle: handle, basePtr: @base, offsetPtr: @offset];          SELECT registerType.registerID FROM            CSandIP, SSandSP => {              registerOffset ¬ GetCardinal[handle: handle, offsetPtr: @offset]};            ENDCASE};        logicalAddr => {          GetLogicalAddress[            handle: handle, addressPtr: @address, offsetPtr: @offset]};        ENDCASE => ERROR;      ENDLOOP;    END;  GetRelocatableEnumeratedData: PUBLIC PROCEDURE [handle: Handle]    RETURNS [      relocatableEnumeratedDataPtr: LONG POINTER TO        OMF.RelocatableEnumeratedData] =    BEGIN    checksumOffset: NATURAL;    dataLength: NATURAL;    offset: NATURAL;    [offset: offset, checksumOffset: checksumOffset] ¬ CommonGetInformation[      handle: handle, desiredType: relocatableEnumeratedData];    relocatableEnumeratedDataPtr ¬ handle.heap.NEW[      OMF.RelocatableEnumeratedData ¬ []];    GetBase[      handle: handle, basePtr: @relocatableEnumeratedDataPtr.base,      offsetPtr: @offset];    relocatableEnumeratedDataPtr.enumeratedDataOffset ¬ GetCardinal[      handle: handle, offsetPtr: @offset];    dataLength ¬ checksumOffset - offset;    relocatableEnumeratedDataPtr.iteratedDataBlockPtr ¬ handle.heap.NEW[      OMF .DataSequence[dataLength] ¬ [length: dataLength, seq: NULL]];    FOR index: NATURAL IN [0..dataLength) DO      relocatableEnumeratedDataPtr.iteratedDataBlockPtr.seq[index] ¬        handle.recordPointer.bytes[offset + index];      ENDLOOP;    END;  GetRelocatableIteratedData: PUBLIC PROCEDURE [handle: Handle]    RETURNS [      relocatableIteratedDataPtr: LONG POINTER TO OMF.RelocatableIteratedData] =    BEGIN    checksumOffset: NATURAL;    offset: NATURAL;    [offset: offset, checksumOffset: checksumOffset] ¬ CommonGetInformation[      handle: handle, desiredType: relocatableIteratedData];    relocatableIteratedDataPtr ¬ handle.heap.NEW[OMF.RelocatableIteratedData ¬ []];    GetBase[      handle: handle, basePtr: @relocatableIteratedDataPtr.base,      offsetPtr: @offset];    relocatableIteratedDataPtr.offset ¬ GetCardinal[      handle: handle, offsetPtr: @offset];    GetIteratedData[      handle: handle,      iteratedDataPtrPtr: @relocatableIteratedDataPtr.iteratedDataBlockPtr,      offsetPtr: @offset, checksumOffset: checksumOffset];    END;  GetSegmentDefinition: PUBLIC PROCEDURE [handle: Handle]    RETURNS [segmentDefinitionPtr: LONG POINTER TO OMF.SegmentDefinitionData] =    BEGIN    ACBP: TYPE = MACHINE DEPENDENT RECORD [      filler(0:0..7): Byte,      align(0:8..10): OMF.AlignType,      combin(0:11..13): OMF.CombineType,      exactly64K(0:14..14): BOOLEAN,  -- B      pageResident(0:15..15): BOOLEAN  -- P      ];    acbp: ACBP;    checksumOffset: NATURAL;    indexOffset: NATURAL;    offset: NATURAL;    [offset: offset, checksumOffset: checksumOffset] ¬ CommonGetInformation[      handle: handle, desiredType: segmentDefinition];    segmentDefinitionPtr ¬ handle.heap.NEW[OMF.SegmentDefinitionData ¬ []];    acbp ¬ LOOPHOLE[handle.recordPointer.bytes[offset], ACBP];    segmentDefinitionPtr.ACBP.align ¬ acbp.align;    segmentDefinitionPtr.ACBP.combin ¬ acbp.combin;    segmentDefinitionPtr.ACBP.exactly64K ¬ acbp.exactly64K;    segmentDefinitionPtr.ACBP.pageResident ¬ acbp.pageResident;    indexOffset ¬ offset + 1;    SELECT acbp.align FROM      abs, unNamed => {        segmentDefinitionPtr.frameNumber ¬ GetCardinal[          handle: handle, offsetPtr: @indexOffset];        segmentDefinitionPtr.offset ¬ handle.recordPointer.bytes[indexOffset];        indexOffset ¬ indexOffset + 1};      LTL => {        segmentDefinitionPtr.ltlData ¬ LOOPHOLE[handle.recordPointer.bytes[          indexOffset], OMF.LTLData];        indexOffset ¬ indexOffset + 1;        IF segmentDefinitionPtr.ltlData.bigSegmentMaxlength THEN          BEGIN segmentDefinitionPtr.maxSegmentLength ¬ sixtyFourK; END        ELSE          BEGIN          segmentDefinitionPtr.maxSegmentLength ¬ GetCardinal[            handle: handle, offsetPtr: @indexOffset];          indexOffset ¬ indexOffset - 2;          END;        indexOffset ¬ indexOffset + 2;        segmentDefinitionPtr.groupOffset ¬ GetCardinal[          handle: handle, offsetPtr: @indexOffset]};      ENDCASE;    segmentDefinitionPtr.segmentLength ¬ GetCardinal[      handle: handle, offsetPtr: @indexOffset];    IF acbp.align # unNamed THEN      BEGIN      segmentDefinitionPtr.segmentNameIndex ¬ GetIndex[        handle: handle, offsetPtr: @indexOffset];      segmentDefinitionPtr.classNameIndex ¬ GetIndex[        handle: handle, offsetPtr: @indexOffset];      segmentDefinitionPtr.overlayNameIndex ¬ GetIndex[        handle: handle, offsetPtr: @indexOffset];      END;    IF segmentDefinitionPtr.ACBP.exactly64K THEN      segmentDefinitionPtr.segmentLength ¬        segmentDefinitionPtr.segmentLength + sixtyFourK;    END;  GetTModuleName: PUBLIC PROCEDURE [handle: Handle] RETURNS [tName: LONG STRING] =    BEGIN    offset: NATURAL;    [offset: offset] ¬ CommonGetInformation[handle: handle, desiredType: tHeader];    tName ¬ GetName[handle: handle, offset: offset];    END;  GetTypeDefinition: PUBLIC PROCEDURE [handle: Handle]    RETURNS [typeDefinitionPtr: LONG POINTER TO OMF.TypeDefinition] =    BEGIN    byte: Byte;    checksumOffset: NATURAL;    eldPtr: LONG POINTER TO OMF.EightLeafDescriptor ¬ NIL;    leafDescriptorPtr: LONG POINTER TO OMF.LeafDescriptor;    offset: NATURAL;    tempEldPtr: LONG POINTER TO OMF.EightLeafDescriptor ¬ NIL;    [offset: offset, checksumOffset: checksumOffset] ¬ CommonGetInformation[      handle: handle, desiredType: typeDefinition];    typeDefinitionPtr ¬ handle.heap.NEW[OMF.TypeDefinition ¬ []];    typeDefinitionPtr.name ¬ GetName[handle: handle, offset: offset];    offset ¬ offset + typeDefinitionPtr.name.length + 1;    UNTIL offset = checksumOffset DO      tempEldPtr ¬ handle.heap.NEW[OMF.EightLeafDescriptor ¬ []];      IF eldPtr = NIL THEN        BEGIN typeDefinitionPtr.eightLeafDescriptor ¬ eldPtr ¬ tempEldPtr; END      ELSE BEGIN eldPtr.next ¬ tempEldPtr; eldPtr ¬ eldPtr.next; END;      byte ¬ handle.recordPointer.bytes[offset];      eldPtr.easyNice ¬ LOOPHOLE[byte, PACKED ARRAY [0..8) OF BOOLEAN];      offset ¬ offset + 1;      FOR index: CARDINAL IN [0..8) DO        byte ¬ handle.recordPointer.bytes[offset];        offset ¬ offset + 1;        SELECT byte FROM          IN [0..127] => {            leafDescriptorPtr ¬ handle.heap.NEW[              OMF.LeafDescriptor ¬ [leafTag: numericLeaf[smallByte: byte]]]};          128 => {            leafDescriptorPtr ¬ handle.heap.NEW[              OMF.LeafDescriptor ¬ [leafTag: nullLeaf[]]]};          129 => {            leafDescriptorPtr ¬ handle.heap.NEW[              OMF.LeafDescriptor ¬ [leafTag: cardinal[]]]};          130 => {            leafDescriptorPtr ¬ handle.heap.NEW[              OMF.LeafDescriptor ¬ [leafTag: name[]]]};          131 => {            leafDescriptorPtr ¬ handle.heap.NEW[              OMF.LeafDescriptor ¬ [leafTag: index[]]]};          132 => {            leafDescriptorPtr ¬ handle.heap.NEW[              OMF.LeafDescriptor ¬ [leafTag: threeByte[]]]};          133 => {            leafDescriptorPtr ¬ handle.heap.NEW[              OMF.LeafDescriptor ¬ [leafTag: repeatLeaf[]]]};          134 => {            leafDescriptorPtr ¬ handle.heap.NEW[              OMF.LeafDescriptor ¬ [leafTag: signedByte[]]]};          135 => {            leafDescriptorPtr ¬ handle.heap.NEW[              OMF.LeafDescriptor ¬ [leafTag: integer[]]]};          136 => {            leafDescriptorPtr ¬ handle.heap.NEW[              OMF.LeafDescriptor ¬ [leafTag: longCardinal[]]]};          ENDCASE => ERROR;        WITH leafDescriptorPtr SELECT FROM          nullLeaf, repeatLeaf => NULL;          numericLeaf => {};          cardinal => {            cardinalValue ¬ GetCardinal[handle: handle, offsetPtr: @offset]};          name => {            nameString ¬ GetName[handle: handle, offset: offset];            offset ¬ offset + nameString.length + 1};          index => {indexValue ¬ GetIndex[handle: handle, offsetPtr: @offset]};          threeByte => {            threeByteValue ¬ GetCardinal[handle: handle, offsetPtr: @offset];            threeByteValue ¬              threeByteValue * 256 + handle.recordPointer.bytes[offset];            offset ¬ offset + 1};          signedByte => {            byte ¬ handle.recordPointer.bytes[offset];            offset ¬ offset + 1;            signedByteValue ¬ IF byte < 128 THEN byte ELSE byte - 256};          integer => {            integerValue ¬ LOOPHOLE[GetCardinal[              handle: handle, offsetPtr: @offset], INTEGER]};          longCardinal => {            GetLongCardinal[              handle: handle, offsetPtr: @offset,              longCardinalPtr: @longCardinalValue]};          ENDCASE => ERROR;        eldPtr.leafDescriptors[index] ¬ leafDescriptorPtr;        IF offset = checksumOffset THEN EXIT;        ENDLOOP;      ENDLOOP;    offset ¬ offset;    END;  CommonGetInformation: PROCEDURE [handle: Handle, desiredType: InternalRecordType]    RETURNS [offset, checksumOffset: NATURAL] =    BEGIN    type: InternalRecordType;    IF handle = NIL THEN Error[type: invalidHandle];    IF handle.type # read THEN Error[type: invalidRequest];    offset ¬ NATURAL[handle.currentPosition MOD 2];    type ¬ VAL[handle.recordPointer.bytes[offset]];    checksumOffset ¬ GetLength[handle: handle] + offset - 1;    offset ¬ offset + 3;    IF type # desiredType THEN Error[type: invalidType];    END;  ConvertSimpleStringToLongString: PROCEDURE [    handle: Handle, offset: CARDINAL, string: LONG STRING] =    BEGIN    FOR index: CARDINAL IN [0..string.maxlength) DO      String.AppendChar[        s: string, c: (handle.recordPointer.bytes[offset + index] + 0C)];      ENDLOOP    END;  GetBase: PROCEDURE [    handle: Handle, basePtr: LONG POINTER TO OMF.Base,    offsetPtr: LONG POINTER TO NATURAL] =    BEGIN    basePtr.groupIndex ¬ GetIndex[handle: handle, offsetPtr: offsetPtr];    basePtr.segmentIndex ¬ GetIndex[handle: handle, offsetPtr: offsetPtr];    IF basePtr.segmentIndex = 0 THEN      BEGIN      IF basePtr.groupIndex # 0 THEN ERROR;      basePtr.frameNumber ¬ GetCardinal[handle: handle, offsetPtr: offsetPtr];      END;    END;  GetCardinal: PROCEDURE [handle: Handle, offsetPtr: LONG POINTER TO NATURAL]    RETURNS [cardinal: CARDINAL] =    BEGIN    cardinal ¬      handle.recordPointer.bytes[offsetPtr­] +        handle.recordPointer.bytes[offsetPtr­ + 1] * 400B;    offsetPtr­ ¬ offsetPtr­ + 2;    END;  GetIndex: PROCEDURE [handle: Handle, offsetPtr: LONG POINTER TO NATURAL]    RETURNS [index: NATURAL] =    BEGIN    IF handle.recordPointer.bytes[offsetPtr­] < 128 THEN      BEGIN      index ¬ handle.recordPointer.bytes[offsetPtr­];      offsetPtr­ ¬ offsetPtr­ + 1;      END    ELSE      BEGIN      index ¬        (handle.recordPointer.bytes[offsetPtr­] MOD 128) * 400B +          handle.recordPointer.bytes[offsetPtr­ + 1];      offsetPtr­ ¬ offsetPtr­ + 2;      END;    END;  GetIteratedData: PROCEDURE [    handle: Handle,    iteratedDataPtrPtr: LONG POINTER TO LONG POINTER TO OMF.IteratedBlock,    offsetPtr: LONG POINTER TO NATURAL, checksumOffset: NATURAL] =    BEGIN    currentPtr: LONG POINTER TO OMF.IteratedBlock ¬ NIL;    dataLength: NATURAL;    tempPtr: LONG POINTER TO OMF.IteratedBlock ¬ NIL;    UNTIL offsetPtr­ = checksumOffset DO      tempPtr ¬ handle.heap.NEW[OMF.IteratedBlock ¬ []];      tempPtr.repeatCount ¬ GetCardinal[handle: handle, offsetPtr: offsetPtr];      tempPtr.blockCount ¬ GetCardinal[handle: handle, offsetPtr: offsetPtr];      IF currentPtr = NIL THEN        BEGIN iteratedDataPtrPtr­ ¬ currentPtr ¬ tempPtr; END      ELSE BEGIN currentPtr.next ¬ tempPtr; currentPtr ¬ currentPtr.next; END;      IF currentPtr.blockCount = 0 THEN        BEGIN        dataLength ¬ handle.recordPointer.bytes[offsetPtr­];        offsetPtr­ ¬ offsetPtr­ + 1;        currentPtr.dataPtr ¬ handle.heap.NEW[          OMF .DataSequence[dataLength] ¬ [length: dataLength, seq: NULL]];        FOR index: NATURAL IN [0..dataLength) DO          currentPtr.dataPtr.seq[index] ¬ handle.recordPointer.bytes[offsetPtr­];          offsetPtr­ ¬ offsetPtr­ + 1;          ENDLOOP;        END;      ENDLOOP;    END;  GetLength: PROCEDURE [handle: Handle] RETURNS [length: CARDINAL] = INLINE    BEGIN    offset: NATURAL ¬ NATURAL[handle.currentPosition MOD 2];    length ¬      3 + handle.recordPointer.bytes[offset + 1] +        handle.recordPointer.bytes[offset + 2] * 400B;    END;  GetLogicalAddress: PROCEDURE [    handle: Handle, addressPtr: LONG POINTER TO OMF.LogicalAddress,    offsetPtr: LONG POINTER TO NATURAL,    targetDispLength: {twoBytes, threeBytes} ¬ twoBytes] =    BEGIN    data: InternalFixupDataType;    data ¬ LOOPHOLE[handle.recordPointer.bytes[offsetPtr­], InternalFixupDataType];    offsetPtr­ ¬ offsetPtr­ + 1;    WITH addressPtr.frameSpec SELECT FROM      explicitly => {        SELECT frameMethod FROM          segmentIndex, groupIndex, externalIndex => {            addressPtr.frameDatum ¬ GetIndex[              handle: handle, offsetPtr: offsetPtr]};          frameNumber => {            addressPtr.frameDatum ¬ GetCardinal[              handle: handle, offsetPtr: offsetPtr]};          ENDCASE};      byThread => NULL;      ENDCASE => ERROR;    WITH addressPtr.targetSpec SELECT FROM      explicitly => {        SELECT targetMethod FROM          frameNumberWithDisp, frameNumber => {            addressPtr.targetDatum ¬ GetCardinal[              handle: handle, offsetPtr: offsetPtr]};          ENDCASE =>            addressPtr.targetDatum ¬ GetIndex[              handle: handle, offsetPtr: offsetPtr];        SELECT targetMethod FROM          segmentIndexWithDisp, groupIndexWithDisp, externalIndexWithDisp,            frameNumberWithDisp => {            SELECT targetDispLength FROM              twoBytes => {                addressPtr.targetDisplacement ¬ GetCardinal[                  handle: handle, offsetPtr: offsetPtr]};              threeBytes => {ERROR << this is currently not allowed >> };              ENDCASE};          ENDCASE};      byThread => NULL;      ENDCASE => ERROR;    END;  GetLongCardinal: PROCEDURE [    handle: Handle, offsetPtr: LONG POINTER TO NATURAL,    longCardinalPtr: LONG POINTER TO LONG CARDINAL] =    BEGIN    longCardinalPtr­ ¬ 0;    FOR index: NATURAL IN [0..4) DO      longCardinalPtr­ ¬        longCardinalPtr­ * 256 + handle.recordPointer.bytes[offsetPtr­];      offsetPtr­ ¬ offsetPtr­ + 1;      ENDLOOP;    END;  GetName: PROCEDURE [handle: Handle, offset: CARDINAL]    RETURNS [name: LONG STRING] =    BEGIN    name ¬ String.MakeString[      z: handle.heap, maxlength: handle.recordPointer.bytes[offset]];    ConvertSimpleStringToLongString[      handle: handle, offset: offset + 1, string: name];    END;  END...    LOG  created by Dennis E. DEG      @  3-Nov-83 17:14:16  edited by Dennis E. DEG      @  9-Jan-84 12:05:48: convert to bound variant   records.  edited by Frank FXB    @ 27-Jan-84 18:40:16: fixed address fault in ReleaseHandle when doing handle.heap.FREE[@handle];  Dennis & Frank: Performance tuning (PHASE I): 17-Mar-84 17:31:04  Dennis & Frank:  put MOD 400B in checksum loop  
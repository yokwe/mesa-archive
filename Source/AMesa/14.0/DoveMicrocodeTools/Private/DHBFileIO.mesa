-- DHBFileIO.mesa-- JWF 22-Oct-86 11:23:00DIRECTORY   FormSW,   Ascii,   Window,   Put,   String,   Stream,   MStream,   DHBDefs;   DHBFileIO: PROGRAMIMPORTS   String, Put, Stream, MStreamEXPORTS   DHBDefs = BEGINFileHeaderIdString: LONG STRING = "DHB Saved Settings File"L;FileHeaderIdWord: CARDINAL = 0FFH;OpenInputFile: PUBLIC PROC [fileName: LONG STRING, d: DHBDefs.DataHandle]   RETURNS [s: MStream.Handle _ NIL] =   BEGIN       OPEN MStream;	   s ¬ MStream.ReadOnly[      fileName, [] !      MStream.Error => IF code = fileNotAvailable THEN GO TO notFound];   RETURN[s];	     EXITS      notFound =>         BEGIN	 Put.Line[d.msgSW, "--input file not found"L];	 RETURN[NIL];	 END;   END;		OpenOutputFile: PUBLIC PROC [fileName: LONG STRING, d: DHBDefs.DataHandle]    RETURNS [s: MStream.Handle _ NIL] =   BEGIN   OPEN MStream;	   s ¬ MStream.WriteOnly[      fileName, [] , text !      MStream.Error => IF code = fileNotAvailable THEN GO TO notFound];   RETURN[s];	   EXITS      notFound =>         BEGIN         Put.Line[d.msgSW, "--output file not obtainable"L];	 RETURN[NIL];	 END;   END;<< These routines were replaced with routines which use EOL to destinguish the end of a string rather than appending the string length to the beginning of the string   GetString: PROCEDURE[s: MStream.Handle, string: LONG STRING] =   BEGIN   length: CARDINAL;      string.length ¬ 0;   IF MStream.EndOf[s] THEN RETURN;      length ¬ Stream.GetWord[s];      FOR i: INTEGER IN[0..INTEGER[length] - 1]      DO      IF MStream.EndOf[s] THEN RETURN;      IF i < INTEGER[string.maxlength] THEN         BEGIN         string[i] ¬ Stream.GetChar[s];	 string.length ¬ string.length + 1;	 END;      ENDLOOP;         END;   PutString: PROCEDURE[s: MStream.Handle, string: LONG STRING] =   BEGIN      Stream.PutWord[s, string.length];      FOR i: INTEGER IN[0..INTEGER[string.length] - 1]      DO      Stream.PutChar[s, string[i]];      ENDLOOP;         END;    >>     GetString: PROCEDURE[s: MStream.Handle, string: LONG STRING] =   BEGIN   dummy: CHARACTER;   i: INTEGER;      string.length ¬ 0;   i ¬ 0;      IF MStream.EndOf[s] THEN RETURN;         DO      IF MStream.EndOf[s] THEN RETURN;      dummy ¬ Stream.GetChar[s];      IF dummy = Ascii.CR THEN RETURN;      IF i < INTEGER[string.maxlength] THEN         BEGIN         string[i] ¬ dummy;	 string.length ¬ string.length + 1;	 i ¬ i + 1;	 END;      ENDLOOP;         END;   PutString: PROCEDURE[s: MStream.Handle, string: LONG STRING] =   BEGIN      FOR i: INTEGER IN[0..INTEGER[string.length] - 1]      DO      Stream.PutChar[s, string[i]];      ENDLOOP;      Stream.PutChar[s, Ascii.CR];      END;     GetSettingString: PROC[s: MStream.Handle, setting: LONG STRING] =   BEGIN      IF NOT MStream.EndOf[s] THEN      BEGIN      GetString[s, setting];      END;   END;         LoadSettingsMain: PUBLIC PROC[data: DHBDefs.DataHandle] RETURNS[succeeded: BOOLEAN] =   BEGIN   s: MStream.Handle;   codeWord: CARDINAL;   tempString: LONG STRING ¬ [100];      s ¬ OpenInputFile[data.file, data];   IF s = NIL THEN      BEGIN      RETURN[FALSE];      END;      GetString[s, tempString];   IF NOT String.Equal[tempString, FileHeaderIdString] THEN      BEGIN      Stream.Delete[s];      RETURN[FALSE];      END;         codeWord ¬ Stream.GetWord[s];   IF codeWord # FileHeaderIdWord THEN      BEGIN      Stream.Delete[s];      RETURN[FALSE];      END;         data.sampleType ¬ LOOPHOLE[Stream.GetByte[s]];   data.outputBase ¬ LOOPHOLE[Stream.GetByte[s]];   data.machineType ¬ LOOPHOLE[Stream.GetByte[s]];      GetSettingString[s, data.to];   GetSettingString[s, data.from];   GetSettingString[s, data.data];   GetSettingString[s, data.bank];   GetSettingString[s, data.status];   GetSettingString[s, data.address];   GetSettingString[s, data.nIA];   GetSettingString[s, data.iOPwildCard];   GetSettingString[s, data.cSwildCard];   GetSettingString[s, data.noofWaitCycles];   GetSettingString[s, data.halt];   GetSettingString[s, data.arbitor];   GetSettingString[s, data.multiTRG];   GetSettingString[s, data.postTrigSampleX];      IF MStream.EndOf[s] THEN       BEGIN      Stream.Delete[s];      RETURN[FALSE];      END;      codeWord ¬ Stream.GetWord[s];      IF codeWord # FileHeaderIdWord  OR NOT MStream.EndOf[s] THEN      BEGIN      Stream.Delete[s];      RETURN[FALSE];      END;         Stream.Delete[s];   RETURN[TRUE];      END;   SaveSettingsMain: PUBLIC PROC[data: DHBDefs.DataHandle] RETURNS[succeeded: BOOLEAN] =   BEGIN   s: MStream.Handle;   tempString: LONG STRING ¬ [100];      s ¬ OpenOutputFile[data.file, data];      IF s = NIL THEN      BEGIN      RETURN[FALSE];      END;   PutString[s, FileHeaderIdString];   Stream.PutWord[s, FileHeaderIdWord];       Stream.PutByte[s, LOOPHOLE[data.sampleType]];   Stream.PutByte[s, LOOPHOLE[data.outputBase]];   Stream.PutByte[s, LOOPHOLE[data.machineType]];        PutString[s, data.to];   PutString[s, data.from];   PutString[s, data.data];   PutString[s, data.bank];   PutString[s, data.status];   PutString[s, data.address];   PutString[s, data.nIA];   PutString[s, data.iOPwildCard];   PutString[s, data.cSwildCard];   PutString[s, data.noofWaitCycles];   PutString[s, data.halt];   PutString[s, data.arbitor];   PutString[s, data.multiTRG];   PutString[s, data.postTrigSampleX];      Stream.PutWord[s, FileHeaderIdWord];   Stream.Delete[s];   RETURN[TRUE];      END;      SaveLogMain: PUBLIC PROC[data: DHBDefs.DataHandle] =   BEGIN   Put.CR[data.fileSW];   Put.Line[data.fileSW, " The ""Save Log File"" function is not implemented."];   Put.CR[data.fileSW];   <<   source, dest: FileName.VirtualFilename;      IF data.file = NIL OR data.file.length = 0 THEN       BEGIN      Put.Line[data.fileSW, "Error -- 'File' field is empty"L];      Put.Line[data.fileSW, ""];      RETURN;      END;           dest ¬ FileName.AllocVFN[data.file];     source ¬ FileName.AllocVFN["DHB.log"L];      FileTransfer.Copy[source, dest, FileTransfer.Create[], FileTransfer.Create[]];<<!      FileTransfer.Error =>          BEGIN         FileName.FreeVFN[dest];         FileName.FreeVFN[source];         GO TO FileError         END]; >>      FileName.FreeVFN[dest];   FileName.FreeVFN[source];   <<   EXITS   FileError =>      BEGIN      Put.CR[d.fileSW];      Put.Text[d.fileSW, "Error -- Cannot save log to """];      Put.Text[d.fileSW, data.file];      Put.Line[d.fileSW, """"];      Put.CR[d.fileSW];      END; >>     <<   ok: BOOLEAN;      IF data.file = NIL OR data.file.length = 0 THEN       BEGIN      Put.Line[data.fileSW, "Error -- 'File' field is empty"L];      Put.Line[data.fileSW, ""];      RETURN;      END;         ok ¬ FileSW.PutEditableFile[data.fileSW, data.file];   IF NOT ok THEN      BEGIN      Put.Text[data.fileSW, "Error -- Could not write log file to file name """L];      Put.Text[data.fileSW, data.file];      Put.Line[data.fileSW, """."];      Put.Line[data.fileSW, ""];      END;   >>   >>   END;       LoadLogMain: PUBLIC PROC[data: DHBDefs.DataHandle] =   BEGIN   Put.CR[data.fileSW];   Put.Line[data.fileSW, " The ""Load Log File"" function is not implemented."];   Put.CR[data.fileSW];   <<   IF data.file = NIL OR data.file.length = 0 THEN       BEGIN      Put.Line[data.fileSW, "Error -- 'File' field is empty"L];      Put.Line[data.fileSW, ""];      RETURN;      END;   FileSW.SetFile[data.fileSW, data.file];   >>   END;END.
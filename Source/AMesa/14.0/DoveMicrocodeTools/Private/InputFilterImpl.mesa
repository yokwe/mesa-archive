-- InputFilterImpl.mesa-- JWF 29-Jul-86 15:21:18DIRECTORY   FormSW,   UserTerminal,   Window,   String,   InputFilter;   InputFilterImpl: PROGRAMIMPORTS   FormSW,   UserTerminal,   StringEXPORTS   InputFilter =BEGIN   BackSpace: CHARACTER = 301C;BackSpace2: CHARACTER = 210C;BackWord: CHARACTER = 302C;BackWord2: CHARACTER = 230C;      EditChar: PROC[c: CHARACTER] RETURNS[BOOLEAN] = INLINE   BEGIN   RETURN[      SELECT c FROM      BackSpace, BackSpace2, BackWord, BackWord2  => TRUE,      ENDCASE => FALSE]   END;  InsertChar: PROC[pos: CARDINAL, c: CHARACTER, s: LONG STRING, typeIn: CARDINAL]   RETURNS[newTypeIn: CARDINAL] = INLINE   BEGIN   newTypeIn ¬ typeIn;         IF pos = s.length THEN      BEGIN      s[s.length] ¬ c;      s.length ¬ s.length + 1;      IF typeIn >= pos THEN newTypeIn ¬ typeIn + 1;      END   ELSE IF pos < s.length THEN      BEGIN      FOR i: CARDINAL IN [0..s.length - pos - 1]         DO         s[s.length - i] ¬ s[s.length - i - 1];         ENDLOOP;      s[pos] ¬ c;      s.length ¬ s.length + 1;      IF typeIn >= pos THEN newTypeIn ¬ typeIn + 1;      END;   END;RemoveCharacter: PROC[pos: CARDINAL, s: LONG STRING, typeIn: CARDINAL]   RETURNS[newTypeIn: CARDINAL] = INLINE   BEGIN   newTypeIn ¬ typeIn;   IF s.length = 0 THEN RETURN;      IF pos = s.length - 1  THEN      BEGIN      s.length ¬ s.length  - 1;      IF typeIn >= pos THEN newTypeIn ¬ typeIn - 1;      END   ELSE IF pos < s.length  - 1 THEN      BEGIN      FOR i: CARDINAL IN [pos..s.length - 2]         DO	 s[i] ¬ s[i + 1];	 ENDLOOP;      s.length ¬ s.length  - 1;      IF typeIn >= pos THEN newTypeIn ¬ typeIn - 1;      END;   END;    FilterProc: PUBLIC PROC[   sw:Window.Handle,   item: FormSW.ItemHandle,   typeIn: CARDINAL,   inputString: LONG STRING,   padChar: CHARACTER,   minLength: CARDINAL,   InsertCharDescArray: DESCRIPTOR FOR ARRAY OF InputFilter.InsertCharDescType,   ValidChar:InputFilter.ValidCharProcType] =   BEGIN      markChar: CHARACTER = '*; -- this char is used to mark positions for deletion      workString: LONG STRING ¬ [InputFilter.MaxFieldLength];   maskString: LONG STRING ¬ [InputFilter.MaxFieldLength];   currentString: LONG STRING ¬ NIL;      index: CARDINAL;   maxStringLength: CARDINAL;   charPos: INTEGER;   <<	#########################################################	If nothing to add to string then return.	######################################################### >>          IF inputString = NIL OR inputString.length = 0 THEN RETURN;<<	#########################################################	If single bad character then blink display and return	######################################################### >>	         IF inputString.length = 1 AND        NOT (ValidChar[inputString[0]] OR EditChar[inputString[0]]) THEN        BEGIN	UserTerminal.BlinkDisplay[];	RETURN;	END;<<	#########################################################	Get Form Item index for call to FormSW.ModifyEditable	######################################################### >>            index ¬ FormSW.FindIndex[sw, item];<<	#########################################################	Get pointer to current string. Backing store for string	must be allocated before call to FilterProc.	######################################################### >>             WITH itemDesc: item SELECT FROM      string =>         BEGIN	 currentString ¬ itemDesc.string­;	 END;      ENDCASE => ERROR;<<	#########################################################	Set maxStringLength based on maxlength of currentString	######################################################### >>	   maxStringLength ¬ currentString.maxlength;	<<	#########################################################	Copy currentString to workString	######################################################### >>	   String.Copy[workString, currentString];<<	#########################################################	Initialize mask for removal of insert characters.	######################################################### >>   maskString.length ¬ workString.length;   FOR i: CARDINAL IN [0..maskString.length - 1]      DO      maskString[i] ¬ 0C;      ENDLOOP;<<	#########################################################	Remove Fixed characters from workString.	######################################################### >>		FOR i: INTEGER DECREASING IN[0..LENGTH[InsertCharDescArray] - 1]	   DO	   IF InsertCharDescArray[i].charType = Fixed THEN	      BEGIN	      charPos ¬ InsertCharDescArray[i].pos;	      IF CARDINAL[charPos] < workString.length AND	         (charPos # 0 OR InsertCharDescArray[i].ShowIfFirstChar) AND		 workString[charPos] = InsertCharDescArray[i].c THEN		 BEGIN		 typeIn ¬ RemoveCharacter[charPos, workString, typeIn];		 END;	      END;	   ENDLOOP;<<	#########################################################	Remove Floating characters from workString.	######################################################### >>		FOR i: INTEGER DECREASING IN[0..LENGTH[InsertCharDescArray] - 1]	   DO	   IF InsertCharDescArray[i].charType = Floating THEN	      BEGIN	      charPos ¬ workString.length - InsertCharDescArray[i].pos - 1;	      IF charPos >= 0 AND CARDINAL[charPos] < workString.length AND	         (charPos # 0 OR InsertCharDescArray[i].ShowIfFirstChar) AND		 workString[charPos] = InsertCharDescArray[i].c THEN		 BEGIN		 typeIn ¬ RemoveCharacter[charPos, workString, typeIn];		 END;	      END;	   ENDLOOP;	   <<	#########################################################	Remove Padding Character	######################################################### >>		IF workString.length > 0 THEN	   BEGIN	   FOR i: CARDINAL IN[0..workString.length - 1]	      DO	      IF workString[i] = padChar THEN	         BEGIN	         typeIn ¬ RemoveCharacter[i, workString, typeIn];	         END;	      ENDLOOP;	   END;    <<	#########################################################	IF BackSpace then remove character preceding typeIn	######################################################### >>                  IF inputString[0] = BackSpace OR inputString[0] = BackSpace2 THEN       BEGIN       IF typeIn # 0 THEN -- Can't backspace passed first character.          BEGIN	  typeIn ¬ RemoveCharacter[typeIn - 1, workString, typeIn];	  END;        END	<<	#########################################################	ELSE IF BackWord Then remove characters from typeIn to	begining of field	######################################################### >>  	         ELSE IF inputString[0] = BackWord OR inputString[0] = BackWord2 THEN       BEGIN       WHILE typeIn # 0          DO	  typeIn ¬ RemoveCharacter[typeIn, workString, typeIn];	  ENDLOOP;       END<<	#########################################################	ELSE IF not BackSpace or BackWord then insert inputString	######################################################### >>    ELSE       BEGIN       FOR i: CARDINAL IN[0..inputString.length - 1]          DO           IF (ValidChar[inputString[i]] OR EditChar[inputString[i]]) THEN             BEGIN	     typeIn ¬ InsertChar[typeIn, String.UpperCase[inputString[i]],	        workString, typeIn];	     END;	  ENDLOOP;       END;<<	#########################################################	If string is too long then shorten it.	######################################################### >>   IF workString.length > maxStringLength - LENGTH[InsertCharDescArray] THEN      BEGIN      workString.length ¬ maxStringLength - LENGTH[InsertCharDescArray];      END;<<	#########################################################	Add Padding Characters to fill up to min length	######################################################### >>	   IF workString.length < minLength THEN      BEGIN      FOR i: CARDINAL IN[1..minLength - workString.length]         DO	 typeIn ¬ InsertChar[0, padChar, workString, typeIn];	 ENDLOOP;      END;      <<	#########################################################	Add Floating characters back into workString.	######################################################### >>	            FOR i: INTEGER IN[0..LENGTH[InsertCharDescArray] - 1]       DO       IF InsertCharDescArray[i].charType = Floating THEN          BEGIN          charPos ¬ workString.length - InsertCharDescArray[i].pos;                 IF charPos > 0 OR 	     (charPos = 0 AND InsertCharDescArray[i].ShowIfFirstChar) THEN          typeIn ¬ InsertChar[CARDINAL[charPos], InsertCharDescArray[i].c,             workString, typeIn];	  END;       ENDLOOP;<<	#########################################################	Add Fixed characters back into workString.	######################################################### >>	            FOR i: INTEGER IN[0..LENGTH[InsertCharDescArray] - 1]       DO       IF InsertCharDescArray[i].charType = Fixed THEN          BEGIN          charPos ¬ InsertCharDescArray[i].pos;                 IF CARDINAL[charPos] < workString.length AND	     (charPos # 0 OR InsertCharDescArray[i].ShowIfFirstChar) THEN          typeIn ¬ InsertChar[CARDINAL[charPos], InsertCharDescArray[i].c,             workString, typeIn];	  END;       ENDLOOP;<<	#########################################################	Clip TypeIn position to length of final string.	######################################################### >>           IF typeIn > workString.length THEN typeIn ¬ workString.length;       <<	#########################################################	Display workString and end.	######################################################### >>                FormSW.ModifyEditable[sw: sw, index: index, position: 0,       length: currentString.length, new: workString];           FormSW.SetTypeIn[sw, index, typeIn + item.tag.length + 2];     END;    END.
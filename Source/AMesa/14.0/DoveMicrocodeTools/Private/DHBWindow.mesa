-- DHBWindow.mesa-- JWF	17-Feb-87 18:09:17 initialized "d" in ClientTransition to avoid crashes-- JWF	17-Feb-87 17:58:42 Fixed form subwindow item overlap-- Create by FormSWLayoutTool on 22-Aug-86 16:07DIRECTORY  Ascii,  Exec,  Format,  FormSW,  Time,  Version,  Heap,  Process,  Put,  Tool,  ToolWindow,  TextSW,  String,  TTY,  Runtime,  Bindweed,  InputFilter,  HelpWindow,  DHBHelpDataDefs,  DHBDefs,  Window;DHBWindow: MONITOR  IMPORTS    Exec, FormSW, Time, Version, Heap, Process, Put, Tool, TextSW, String, TTY, Runtime, Bindweed, InputFilter, HelpWindow, DHBHelpDataDefs, DHBDefs  EXPORTS     DHBDefs = {<<     =========================================================================     Constants     =========================================================================>>    StatusMenuDescriptor: FormSW.Hints = DESCRIPTOR[StatusMenuStrings];   IOPWildCardMenuDescriptor: FormSW.Hints = DESCRIPTOR[IOPWildCardMenuStrings];  CSWildCardMenuDescriptor: FormSW.Hints = DESCRIPTOR[CSWildCardMenuStrings];  ArbitorMenuDescriptor: FormSW.Hints = DESCRIPTOR[ArbitorMenuStrings];  WaitsMenuDescriptor: FormSW.Hints = DESCRIPTOR[NumberOfWaitsMenuStrings];  DataMenuDescriptor: FormSW.Hints = DESCRIPTOR[DataMenuStrings];   AddressMenuDescriptor: FormSW.Hints = DESCRIPTOR[AddressMenuStrings];  MultiTRGMenuDescriptor: FormSW.Hints = DESCRIPTOR[MultiTRGMenuStrings];  IOPPostTrigSampleMenuDescriptor: FormSW.Hints = DESCRIPTOR[IOPPostTrigSampleMenuStrings];  CSPostTrigSampleMenuDescriptor: FormSW.Hints = DESCRIPTOR[CSPostTrigSampleMenuStrings];  DayBreakBankMenuDescriptor: FormSW.Hints = DESCRIPTOR[DayBreakBankMenuStrings];   DaisyBankMenuDescriptor: FormSW.Hints = DESCRIPTOR[DaisyBankMenuStrings];  NIAMenuDescriptor: FormSW.Hints = DESCRIPTOR[NIAMenuStrings];  HaltMenuDescriptor: FormSW.Hints = DESCRIPTOR[HaltMenuStrings];<<     =========================================================================     Variables     =========================================================================>>    StatusMenuStrings: ARRAY [1..9] OF LONG STRING ¬ [     "Don't Care      XXX"L,     "Interrupt Ack.  000"L,     "Read I/O        001"L,     "Write I/O       010"L,     "Halt            011"L,     "Instruct. Fetch 100"L,     "Read Memory     101"L,     "Write Memory    110"L,     "Passive         111"L];       IOPWildCardMenuStrings: ARRAY [1..1] OF LONG STRING ¬ [     "Don't Care XXX XXXX"L];       CSWildCardMenuStrings: ARRAY [1..1] OF LONG STRING ¬ [     "Don't Care XXX XXXX XXXX XXXX"L];       ArbitorMenuStrings: ARRAY [1..11] OF LONG STRING ¬ [     "Don't Care   XX XXXX XXXX"L,     "ENetHoldReq  00 0000 0001"L,     "ENetHoldAck  00 0000 0010"L,     "PCEHldaToArb 00 0000 0100"L,     "RDCHoldReq   00 0000 1000"L,     "RDCHoldAck   00 0001 0000"L,     "IOPHldaToArb 00 0010 0000"L,     "ArbHoldPCE   00 0100 0000"L,     "RunRDC       00 1000 0000"L,     "KeepIOPHeld  01 0000 0000"L,     "ArbHoldIOP   10 0000 0000"L];    NumberOfWaitsMenuStrings: ARRAY [1..19] OF LONG STRING ¬ [     "Don't Care XXXX"L,     "Zero       0000"L,     "One        0001"L,     "Two        0010"L,     "Three      0011"L,     "Four       0100"L,     "Five       0101"L,     "Six        0110"L,     "Seven      0111"L,     "Eight      1000"L,     "Nine       1001"L,     "Ten        1010"L,     "Eleven     1011"L,     "Twelve     1100"L,     "Thirteen   1101"L,     "Fourteen   1110"L,     "Fifteen    1111"L,     " > Seven   1XXX"L,     " > Eleven  11XX"L];    DataMenuStrings: ARRAY[1..1] OF LONG STRING ¬ [     "XXXX"L];    AddressMenuStrings: ARRAY[1..1] OF LONG STRING ¬ [     "XXXXXX"L];       MultiTRGMenuStrings: ARRAY[1..16] OF LONG STRING ¬ [     "1"L,     "2"L,     "3"L,     "4"L,     "5"L,     "6"L,     "7"L,     "8"L,     "9"L,     "10"L,     "11"L,     "12"L,     "13"L,     "14"L,     "15"L,     "16"L];       IOPPostTrigSampleMenuStrings: ARRAY[1..8] OF LONG STRING ¬ [     "0"L,     "1"L,     "2"L,     "3"L,     "4"L,     "5"L,     "6"L,     "7"L];       CSPostTrigSampleMenuStrings: ARRAY[1..16] OF LONG STRING ¬ [     "0"L,     "1"L,     "2"L,     "3"L,     "4"L,     "5"L,     "6"L,     "7"L,     "8"L,     "9"L,     "10"L,     "11"L,     "12"L,     "13"L,     "14"L,     "15"L];      DayBreakBankMenuStrings: ARRAY[1..5] OF LONG STRING ¬ [     "Don't Care XXXX"L,     "Zero       0000"L,     "One        1100"L,     "Two        1010"L,     "Three      1001"L];      DaisyBankMenuStrings: ARRAY[1..5] OF LONG STRING ¬ [     "Don't Care XXXX"L,     "Zero       1110"L,     "One        1101"L,     "Two        1011"L,     "Three      0111"L];           NIAMenuStrings: ARRAY[1..1] OF LONG STRING ¬ [     "XXX"L];      HaltMenuStrings: ARRAY[1..3] OF LONG STRING ¬ [     "Don't Care  X"L,     "Running     1"L,     "Not Running 0"L];     <<     =========================================================================     Input Filter Constants and Variables and Procedures     =========================================================================>>   IOPWildCardFixedChars: ARRAY[0..0] OF InputFilter.InsertCharDescType ¬      [[Ascii.SP, Floating, 4, FALSE]];         CSWildCardFixedChars: ARRAY[0..2] OF InputFilter.InsertCharDescType ¬      [[Ascii.SP, Floating, 4, FALSE], [Ascii.SP, Floating, 9, FALSE], [Ascii.SP, Floating, 14, FALSE]];      ArbitorFixedChars: ARRAY[0..1] OF InputFilter.InsertCharDescType ¬      [[Ascii.SP, Floating, 4, FALSE], [Ascii.SP, Floating, 9, FALSE]];         NoFixedChars: ARRAY[0..0] OF InputFilter.InsertCharDescType ¬ [[' , Fixed, 0, FALSE]]; -- dummy array for use when no fixed chars are needed.            IntegerValidCharProc: InputFilter.ValidCharProcType =      BEGIN      RETURN[         SELECT c FROM            IN ['0..'9], '- => TRUE,            ENDCASE => FALSE]      END;         CardinalValidCharProc: InputFilter.ValidCharProcType =      BEGIN      RETURN[         SELECT c FROM            IN ['0..'9] => TRUE,            ENDCASE => FALSE]      END;               BinaryValidCharProc: InputFilter.ValidCharProcType =      BEGIN      RETURN[         SELECT c FROM	    '0, '1  => TRUE,            ENDCASE => FALSE]      END;            HexValidCharProc: InputFilter.ValidCharProcType =      BEGIN      RETURN[         SELECT c FROM            IN ['0..'9] => TRUE,            IN ['a..'f] => TRUE,            IN ['A..'F] => TRUE,            ENDCASE => FALSE]      END;            DecimalDontCareValidCharProc: InputFilter.ValidCharProcType =      BEGIN      RETURN[         SELECT c FROM	    'X, 'x => TRUE,            IN ['0..'9] => TRUE,            ENDCASE => FALSE]      END;               BinaryDontCareValidCharProc: InputFilter.ValidCharProcType =      BEGIN      RETURN[         SELECT c FROM	    '0, '1, 'X, 'x  => TRUE,            ENDCASE => FALSE]      END;            HexDontCareValidCharProc: InputFilter.ValidCharProcType =      BEGIN      RETURN[         SELECT c FROM            IN ['0..'9] => TRUE,            IN ['a..'f] => TRUE,            IN ['A..'F] => TRUE,	    'X, 'x      => TRUE,            ENDCASE => FALSE]      END;        data: DHBDefs.DataHandle ¬ NIL;  wh: Window.Handle ¬ NIL;  zone: UNCOUNTED ZONE ¬ Heap.systemZone;  z: PUBLIC UNCOUNTED ZONE ¬ NIL;  initialized: BOOLEAN ¬ FALSE;  maxHelpItems: CARDINAL = 50;  numberOfHelpItems: CARDINAL ¬ 0;  helpMessageZone: UNCOUNTED ZONE ¬ NIL;  initialBox: Window.Box = [place: [x:0, y: 194], dims: [w: 512, h: 350]];  busyBit: BOOLEAN ¬ FALSE;  Busy: ENTRY PROCEDURE RETURNS [isBusy: BOOLEAN] = {    ENABLE UNWIND => NULL;    isBusy ¬ busyBit;    busyBit ¬ TRUE };  Done: ENTRY PROCEDURE = {    ENABLE UNWIND => NULL;    busyBit ¬ FALSE};  Write: Format.StringProc = {Put.Text[data.fileSW, s]};  Msg: Format.StringProc = {Put.Text[data.msgSW, s]};  ErrorMsg: PROC[message: LONG STRING] =     BEGIN     Put.CR[data.fileSW];     Put.Line[data.fileSW, message];     Put.CR[data.fileSW];     END;MakeItemVisible: PROC[sw: Window.Handle, index: CARDINAL] =   BEGIN   itemHandle: FormSW.ItemHandle = FormSW.FindItem[sw: sw, index: index];   IF itemHandle ~= NIL THEN      BEGIN      itemHandle^.flags.invisible ¬ FALSE;      END;    END;    MakeItemInVisible: PROC[sw: Window.Handle, index: CARDINAL] =   BEGIN   itemHandle: FormSW.ItemHandle = FormSW.FindItem[sw: sw, index: index];   IF itemHandle ~= NIL THEN      BEGIN      itemHandle^.flags.invisible ¬ TRUE;      END;    END;   SetItemVisibility: PROC[] =   BEGIN      FormSW.SetSelection[data.formSW, FormSW.nullIndex, 0, 0]; -- remove selection      IF data.sampleType = IOP THEN      BEGIN      MakeItemVisible[data.formSW, ORD[DHBDefs.FormItems.iOPTRIGGERPARAMETERS]];      MakeItemVisible[data.formSW, ORD[DHBDefs.FormItems.address]];      MakeItemVisible[data.formSW, ORD[DHBDefs.FormItems.data]];      MakeItemVisible[data.formSW, ORD[DHBDefs.FormItems.iOPwildCard]];      MakeItemVisible[data.formSW, ORD[DHBDefs.FormItems.status]];      MakeItemVisible[data.formSW, ORD[DHBDefs.FormItems.noofWaitCycles]];      MakeItemVisible[data.formSW, ORD[DHBDefs.FormItems.arbitor]];         MakeItemInVisible[data.formSW, ORD[DHBDefs.FormItems.cSTRIGGERPARAMETERS]];      MakeItemInVisible[data.formSW, ORD[DHBDefs.FormItems.machineType]];      MakeItemInVisible[data.formSW, ORD[DHBDefs.FormItems.bank]];      MakeItemInVisible[data.formSW, ORD[DHBDefs.FormItems.cSwildCard]];      MakeItemInVisible[data.formSW, ORD[DHBDefs.FormItems.halt]];      MakeItemInVisible[data.formSW, ORD[DHBDefs.FormItems.nIA]];      FormSW.SetTypeIn[data.formSW, ORD[DHBDefs.FormItems.data], 0];      END   ELSE      BEGIN      MakeItemInVisible[data.formSW, ORD[DHBDefs.FormItems.iOPTRIGGERPARAMETERS]];      MakeItemInVisible[data.formSW, ORD[DHBDefs.FormItems.address]];      MakeItemInVisible[data.formSW, ORD[DHBDefs.FormItems.data]];      MakeItemInVisible[data.formSW, ORD[DHBDefs.FormItems.iOPwildCard]];      MakeItemInVisible[data.formSW, ORD[DHBDefs.FormItems.status]];      MakeItemInVisible[data.formSW, ORD[DHBDefs.FormItems.noofWaitCycles]];      MakeItemInVisible[data.formSW, ORD[DHBDefs.FormItems.arbitor]];         MakeItemVisible[data.formSW, ORD[DHBDefs.FormItems.cSTRIGGERPARAMETERS]];      MakeItemVisible[data.formSW, ORD[DHBDefs.FormItems.machineType]];      MakeItemVisible[data.formSW, ORD[DHBDefs.FormItems.bank]];      MakeItemVisible[data.formSW, ORD[DHBDefs.FormItems.cSwildCard]];      MakeItemVisible[data.formSW, ORD[DHBDefs.FormItems.halt]];      MakeItemVisible[data.formSW, ORD[DHBDefs.FormItems.nIA]];      FormSW.SetTypeIn[data.formSW, ORD[DHBDefs.FormItems.bank], 0];      END;   END;   InitializeHelp: PROC[] =   BEGIN   dummy: BOOLEAN;      IF helpMessageZone = NIL THEN      BEGIN      helpMessageZone ¬ Heap.Create[initial: 10];      END;         dummy ¬ HelpWindow.Init[Runtime.GetTableBase[DHBHelpDataDefs.DHBHelpData],              helpMessageZone];         END;  Help: FormSW.ProcType =      BEGIN     FormSW.ToggleVisibility[data.formSW, ORD[DHBDefs.FormItems.help]];          HelpWindow.Create["Dove History Buffer                Help Window"L,	HelpWindowDestroyed];     END;   FreeHelpMessages: PROC[] =   BEGIN   Heap.Delete[helpMessageZone];   helpMessageZone ¬ NIL;   END;HelpWindowDestroyed: HelpWindow.WindowDestroyedNotifyProcType =   BEGIN   IF data # NIL THEN      FormSW.ToggleVisibility[data.formSW, ORD[DHBDefs.FormItems.help]];   END;     SetFileNameField: PUBLIC PROC[fileName: LONG STRING] =     BEGIN     FormSW.ModifyEditable[sw: data.formSW, index: ORD[DHBDefs.FormItems.file],          position: 0, length: fileName.length, new: fileName];     END;  WriteCommentToLogFile: PUBLIC PROC[comment: LONG STRING] =     BEGIN     Put.Line[data.fileSW, comment];     END;       Sample:  PUBLIC FormSW.ProcType =     BEGIN     DHBDefs.SampleMain[data];     END;  Reset:  PUBLIC FormSW.ProcType =      BEGIN     DHBDefs.ResetHistoryBuffer[];     Msg["History Buffer Reset"];     END;  DisplayRemote: PUBLIC PROC[] =      BEGIN     DHBDefs.DisplayMain[data];     END;       DisplayBuffer: PUBLIC FormSW.ProcType = {    ENABLE ABORTED => {Done[]; CONTINUE};    IF Busy[] THEN {      Msg["Tool is busy.\n"L];      RETURN};    Process.Detach[FORK PrintBufferInternal[]]};  PrintBufferInternal: PROCEDURE = {    ENABLE ABORTED => {Done[]; CONTINUE};    DHBDefs.DisplayMain[data];    Done[] };  LoadLog:  PUBLIC FormSW.ProcType =      BEGIN     DHBDefs.LoadLogMain[data];     END;  Redisplay: PROC[] =     BEGIN     Process.Yield;     FormSW.Display[data.formSW];     END;  LoadSettings:  PUBLIC FormSW.ProcType =     BEGIN     IF NOT DHBDefs.LoadSettingsMain[data] THEN         ErrorMsg["Error loading new settings"]      ELSE        BEGIN	Put.CR[data.msgSW]; -- clear message window	Put.CR[data.fileSW];        Put.Text[data.fileSW,"Settings loaded from """];	Put.Text[data.fileSW,data.file];	Put.Line[data.fileSW,""""];	Put.CR[data.fileSW];	END;     Process.Detach[FORK Redisplay[]];     END;  SampleTypeTransition:  FormSW.EnumeratedNotifyProcType =     BEGIN     SetItemVisibility;     FormSW.Display[data.formSW];     END;  SaveLog:  PUBLIC FormSW.ProcType =      BEGIN     DHBDefs.SaveLogMain[data];     END;  SaveSettings:  PUBLIC FormSW.ProcType =      BEGIN     IF NOT DHBDefs.SaveSettingsMain[data] THEN         ErrorMsg["Error saving settings."]     ELSE        BEGIN	Put.CR[data.msgSW]; -- clear message window	Put.CR[data.fileSW];        Put.Text[data.fileSW,"Settings saved to """];	Put.Text[data.fileSW,data.file];	Put.Line[data.fileSW,""""];	Put.CR[data.fileSW];	END;     END;  toFilterProc:  FormSW.FilterProcType =        BEGIN     arrayDesc: DESCRIPTOR FOR ARRAY OF InputFilter.InsertCharDescType;     arrayDesc ¬ DESCRIPTOR[NoFixedChars];     arrayDesc.LENGTH ¬ 0;     InputFilter.FilterProc[ sw: sw, item: item, typeIn: insert,        inputString: string, padChar: '*, minLength:0,        InsertCharDescArray: arrayDesc, ValidChar: IntegerValidCharProc];     END;  fromFilterProc:  FormSW.FilterProcType =        BEGIN     arrayDesc: DESCRIPTOR FOR ARRAY OF InputFilter.InsertCharDescType;     arrayDesc ¬ DESCRIPTOR[NoFixedChars];     arrayDesc.LENGTH ¬ 0;     InputFilter.FilterProc[ sw: sw, item: item, typeIn: insert,        inputString: string, padChar: '*, minLength:0,        InsertCharDescArray: arrayDesc, ValidChar: IntegerValidCharProc];     END;  ClearLog:  PUBLIC FormSW.ProcType = {    ENABLE ABORTED => {Done[]; CONTINUE};    IF Busy[] THEN {      Msg["Tool is busy.\n"L];      RETURN};    Process.Detach[FORK ClearLogInternal[]]};  ClearLogInternal: PROCEDURE = {    ENABLE ABORTED => {Done[]; CONTINUE};    TextSW.SetEOF[data.fileSW,0];    Done[] };  dataFilterProc:  FormSW.FilterProcType =      BEGIN     arrayDesc: DESCRIPTOR FOR ARRAY OF InputFilter.InsertCharDescType;     arrayDesc ¬ DESCRIPTOR[NoFixedChars];     arrayDesc.LENGTH ¬ 0;     InputFilter.FilterProc[ sw: sw, item: item, typeIn: insert,        inputString: string, padChar: '*, minLength:0,        InsertCharDescArray: arrayDesc, ValidChar: HexDontCareValidCharProc];     END;       bankFilterProc: FormSW.FilterProcType =        BEGIN     arrayDesc: DESCRIPTOR FOR ARRAY OF InputFilter.InsertCharDescType;     arrayDesc ¬ DESCRIPTOR[NoFixedChars];     arrayDesc.LENGTH ¬ 0;     InputFilter.FilterProc[ sw: sw, item: item, typeIn: insert,        inputString: string, padChar: '*, minLength:0,        InsertCharDescArray: arrayDesc, ValidChar: BinaryDontCareValidCharProc];     END;    statusFilterProc:  FormSW.FilterProcType =        BEGIN     arrayDesc: DESCRIPTOR FOR ARRAY OF InputFilter.InsertCharDescType;     arrayDesc ¬ DESCRIPTOR[NoFixedChars];     arrayDesc.LENGTH ¬ 0;     InputFilter.FilterProc[ sw: sw, item: item, typeIn: insert,        inputString: string, padChar: '*, minLength:0,        InsertCharDescArray: arrayDesc, ValidChar: BinaryDontCareValidCharProc];     END;   addressFilterProc:  FormSW.FilterProcType =      BEGIN     arrayDesc: DESCRIPTOR FOR ARRAY OF InputFilter.InsertCharDescType;     arrayDesc ¬ DESCRIPTOR[NoFixedChars];     arrayDesc.LENGTH ¬ 0;     InputFilter.FilterProc[ sw: sw, item: item, typeIn: insert,        inputString: string, padChar: '*, minLength:0,        InsertCharDescArray: arrayDesc, ValidChar: HexDontCareValidCharProc];     END;  nIAFilterProc:  FormSW.FilterProcType =      BEGIN     arrayDesc: DESCRIPTOR FOR ARRAY OF InputFilter.InsertCharDescType;     arrayDesc ¬ DESCRIPTOR[NoFixedChars];     arrayDesc.LENGTH ¬ 0;     InputFilter.FilterProc[ sw: sw, item: item, typeIn: insert,        inputString: string, padChar: '*, minLength:0,        InsertCharDescArray: arrayDesc, ValidChar: HexDontCareValidCharProc];     END;  iOPWildCardFilterProc:  FormSW.FilterProcType =      BEGIN     arrayDesc: DESCRIPTOR FOR ARRAY OF InputFilter.InsertCharDescType;     arrayDesc ¬ DESCRIPTOR[IOPWildCardFixedChars];     arrayDesc.LENGTH ¬ 1;     InputFilter.FilterProc[ sw: sw, item: item, typeIn: insert,        inputString: string, padChar: '*, minLength:0,        InsertCharDescArray: arrayDesc, ValidChar: BinaryDontCareValidCharProc];     END;   cSWildCardFilterProc:  FormSW.FilterProcType =      BEGIN     arrayDesc: DESCRIPTOR FOR ARRAY OF InputFilter.InsertCharDescType;     arrayDesc ¬ DESCRIPTOR[CSWildCardFixedChars];     arrayDesc.LENGTH ¬ 3;     InputFilter.FilterProc[ sw: sw, item: item, typeIn: insert,        inputString: string, padChar: '*, minLength:0,        InsertCharDescArray: arrayDesc, ValidChar: BinaryDontCareValidCharProc];     END;   noofWaitCyclesFilterProc:  FormSW.FilterProcType =      BEGIN     arrayDesc: DESCRIPTOR FOR ARRAY OF InputFilter.InsertCharDescType;     arrayDesc ¬ DESCRIPTOR[NoFixedChars];     arrayDesc.LENGTH ¬ 0;     InputFilter.FilterProc[ sw: sw, item: item, typeIn: insert,        inputString: string, padChar: '*, minLength:0,        InsertCharDescArray: arrayDesc, ValidChar: BinaryDontCareValidCharProc];     END;    haltFilterProc:  FormSW.FilterProcType =       BEGIN     arrayDesc: DESCRIPTOR FOR ARRAY OF InputFilter.InsertCharDescType;     arrayDesc ¬ DESCRIPTOR[NoFixedChars];     arrayDesc.LENGTH ¬ 0;     InputFilter.FilterProc[ sw: sw, item: item, typeIn: insert,        inputString: string, padChar: '*, minLength:0,        InsertCharDescArray: arrayDesc, ValidChar: BinaryDontCareValidCharProc];     END;     arbitorFilterProc:  FormSW.FilterProcType =      BEGIN     arrayDesc: DESCRIPTOR FOR ARRAY OF InputFilter.InsertCharDescType;     arrayDesc ¬ DESCRIPTOR[ArbitorFixedChars];     arrayDesc.LENGTH ¬ 2;     InputFilter.FilterProc[ sw: sw, item: item, typeIn: insert,        inputString: string, padChar: '*, minLength:0,        InsertCharDescArray: arrayDesc, ValidChar: BinaryDontCareValidCharProc];     END;    multiTRGFilterProc:  FormSW.FilterProcType =      BEGIN     arrayDesc: DESCRIPTOR FOR ARRAY OF InputFilter.InsertCharDescType;     arrayDesc ¬ DESCRIPTOR[NoFixedChars];     arrayDesc.LENGTH ¬ 0;     InputFilter.FilterProc[ sw: sw, item: item, typeIn: insert,        inputString: string, padChar: '*, minLength:0,        InsertCharDescArray: arrayDesc, ValidChar: CardinalValidCharProc];     END;    postTrigSampleXFilterProc:  FormSW.FilterProcType =      BEGIN     arrayDesc: DESCRIPTOR FOR ARRAY OF InputFilter.InsertCharDescType;     arrayDesc ¬ DESCRIPTOR[NoFixedChars];     arrayDesc.LENGTH ¬ 0;     InputFilter.FilterProc[ sw: sw, item: item, typeIn: insert,        inputString: string, padChar: '*, minLength:0,        InsertCharDescArray: arrayDesc, ValidChar: CardinalValidCharProc];     END;  <<     =========================================================================     Hints Menu Procedures     =========================================================================>>  NullDeallocateMenuProc: FormSW.FreeHintsProcType =     << This is a null procedure. The hints string arrays are taken        from the global frame.     >>     BEGIN     END;     dataMenuProc:  FormSW.MenuProcType =      BEGIN     RETURN[DataMenuDescriptor, NullDeallocateMenuProc, TRUE];     END;  bankMenuProc:  FormSW.MenuProcType =      BEGIN     IF data.machineType = DayBreak THEN        RETURN[DayBreakBankMenuDescriptor, NullDeallocateMenuProc, TRUE]     ELSE        RETURN[DaisyBankMenuDescriptor, NullDeallocateMenuProc, TRUE];     END;   statusMenuProc:  FormSW.MenuProcType =      BEGIN     RETURN[StatusMenuDescriptor, NullDeallocateMenuProc, TRUE];     END;       addressMenuProc:  FormSW.MenuProcType =       BEGIN     RETURN[AddressMenuDescriptor, NullDeallocateMenuProc, TRUE];     END;  nIAMenuProc:  FormSW.MenuProcType =       BEGIN     RETURN[NIAMenuDescriptor, NullDeallocateMenuProc, TRUE];     END;      iOPWildCardMenuProc:  FormSW.MenuProcType =       BEGIN     RETURN[IOPWildCardMenuDescriptor, NullDeallocateMenuProc, TRUE];     END;      cSWildCardMenuProc:  FormSW.MenuProcType =        BEGIN     RETURN[CSWildCardMenuDescriptor, NullDeallocateMenuProc, TRUE];     END;     noofWaitCyclesMenuProc:  FormSW.MenuProcType =        BEGIN     RETURN[WaitsMenuDescriptor, NullDeallocateMenuProc, TRUE];     END;         haltMenuProc:  FormSW.MenuProcType =     BEGIN     RETURN[HaltMenuDescriptor, NullDeallocateMenuProc, TRUE];     END;  arbitorMenuProc:  FormSW.MenuProcType =        BEGIN     RETURN[ArbitorMenuDescriptor, NullDeallocateMenuProc, TRUE];     END;  multiTRGMenuProc:  FormSW.MenuProcType =         BEGIN     RETURN[MultiTRGMenuDescriptor, NullDeallocateMenuProc, TRUE];     END;     postTrigSampleXMenuProc:  FormSW.MenuProcType =      BEGIN     IF data.sampleType = IOP THEN       RETURN[IOPPostTrigSampleMenuDescriptor, NullDeallocateMenuProc, TRUE]     ELSE        RETURN[CSPostTrigSampleMenuDescriptor, NullDeallocateMenuProc, TRUE];     END;  ClientTransition: ToolWindow.TransitionProcType = {    SELECT TRUE FROM      old = inactive =>         BEGIN         IF data = NIL THEN data ¬ zone.NEW[DHBDefs.Data ¬ []];	 z ¬ Heap.Create[initial: 4];	 	 data.to ¬ zone.NEW[StringBody [20]];	 data.from ¬ zone.NEW[StringBody [20]];	 	 data.data ¬ zone.NEW[StringBody [4]];	 data.bank ¬ zone.NEW[StringBody [4]];	 data.status ¬ zone.NEW[StringBody [3]];	 data.address ¬ zone.NEW[StringBody [6]];	 data.nIA ¬ zone.NEW[StringBody [3]];	 data.iOPwildCard ¬ zone.NEW[StringBody [8]];	 data.cSwildCard ¬ zone.NEW[StringBody [18]];	 data.noofWaitCycles ¬ zone.NEW[StringBody [4]];	 data.halt ¬zone.NEW[StringBody [1]];	 data.arbitor ¬ zone.NEW[StringBody [12]];	 data.multiTRG ¬ zone.NEW[StringBody [2]];	 data.postTrigSampleX ¬ zone.NEW[StringBody [2]];	 	 String.Copy[data.from, "-25"];	 String.Copy[data.to, "25"];	 String.Copy[data.data, "XXXX"];	 String.Copy[data.address, "XXXXXX"];	 String.Copy[data.bank, "XXXX"];	 String.Copy[data.status, "XXX"];	 String.Copy[data.nIA, "XXX"];	 String.Copy[data.iOPwildCard, "XXX XXXX"];	 String.Copy[data.cSwildCard, "XXX XXXX XXXX XXXX"];	 String.Copy[data.noofWaitCycles, "XXXX"];	 String.Copy[data.halt, "X"];	 String.Copy[data.arbitor, "XX XXXX XXXX"];	 String.Copy[data.multiTRG, "1"];	 String.Copy[data.postTrigSampleX, "1"];	 InitializeHelp[];	 DHBDefs.d ¬ DHBDefs.emptyDataRecord;	 END;	       new = inactive =>         BEGIN	 HelpWindow.Destroy[];	 Heap.Delete[z];	 zone.FREE[@data.to];	 zone.FREE[@data.from];	 	 zone.FREE[@data.bank];	 zone.FREE[@data.status];	 zone.FREE[@data.address];	 zone.FREE[@data.nIA];	 zone.FREE[@data.iOPwildCard];	 zone.FREE[@data.cSwildCard];	 zone.FREE[@data.noofWaitCycles];	 zone.FREE[@data.halt];	 zone.FREE[@data.arbitor];	 zone.FREE[@data.multiTRG];	 zone.FREE[@data.postTrigSampleX];	 IF data # NIL THEN zone.FREE[@data];	 	 FreeHelpMessages[];	 END;      ENDCASE;    };  Init: PROCEDURE[h: Exec.Handle] =     BEGIN     nameStripe: STRING = [100];         ttH: TTY.Handle _ Exec.GetTTY[h];     bindweedFile: LONG STRING = "BindweedConfig.bcd"L;        IF NOT Runtime.IsBound[LOOPHOLE[Bindweed.ReadMemoryBlock,       Runtime.ControlLink]] THEN       BEGIN       TTY.PutString[h: ttH, s: "IOPBermuda must be running in order to use the Dove history buffer."L];       Exec.ReleaseTTY[ttH];       RETURN;       END;    String.AppendString[nameStripe, "Dove History Buffer Tool "L];    Version.Append[nameStripe];    String.AppendString[nameStripe, " of "L];    Time.Append[nameStripe, Time.Unpack[Runtime.GetBcdTime[]]];        wh ¬ Tool.Create[       makeSWsProc: MakeSWs, initialState: default, initialBox: initialBox,       clientTransition: ClientTransition, name: nameStripe,       cmSection: "DoveHistoryBuffer"L];    initialized ¬ TRUE;    END;        Unload: Exec.ExecProc = {        IF Busy[] THEN {      Exec.OutputProc[h]["Tool is busy. Can not unload.\n"L];      RETURN[error] };    HelpWindow.Destroy[];    Tool.Destroy[wh];    Exec.RemoveCommand[h, "DoveHistoryBuffer.~"L];    Done[] };  MakeSWs: Tool.MakeSWsProc = {    logName: LONG STRING ¬ [50];    Tool.UnusedLogName[unused: logName, root: "DoveHistoryBuffer.log"L];    data.msgSW ¬ Tool.MakeMsgSW[window: window];    data.formSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeForm];    data.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];        << This code makes the hints menus work right. I figured this out through trial and error. I don't Know why it is needed. >>       data.sampleType ¬ CS;  SetItemVisibility;  FormSW.Display[data.formSW];  data.sampleType ¬ IOP;  SetItemVisibility;  FormSW.Display[data.formSW];    };  MakeForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = DHBDefs.FormItems.LAST.ORD + 1;    sampleType: ARRAY[0..2) OF Enumerated ¬ [      ["IOP"L, DHBDefs.SampleTypeType.IOP.ORD], ["CS"L, DHBDefs.SampleTypeType.CS.ORD]];    outputBase: ARRAY[0..2) OF Enumerated ¬ [      ["Binary"L, DHBDefs.BaseType.Binary.ORD], ["Hex"L, DHBDefs.BaseType.Hex.ORD]];    machineType: ARRAY[0..2) OF Enumerated ¬ [      ["DayBreak"L, DHBDefs.MachineTypeType.DayBreak.ORD], ["Daisy"L, DHBDefs.MachineTypeType.Daisy.ORD]];    items ¬ AllocateItemDescriptor[nItems];    items[DHBDefs.FormItems.sample.ORD] ¬ CommandItem[      tag: "Sample"L, place: [12, line0], proc: Sample];    items[DHBDefs.FormItems.reset.ORD] ¬ CommandItem[      tag: "Reset"L, place: [60, line0], proc: Reset];    items[DHBDefs.FormItems.PrintBuffer.ORD] ¬ CommandItem[      tag: "Display"L, place: [108, line0], proc: DisplayBuffer];    items[DHBDefs.FormItems.loadLog.ORD] ¬ CommandItem[      tag: "Load Log"L, place: [180, line0], proc: LoadLog];    items[DHBDefs.FormItems.loadSettings.ORD] ¬ CommandItem[      tag: "Load Settings"L, place: [258, line0], proc: LoadSettings];    items[DHBDefs.FormItems.sampleType.ORD] ¬ EnumeratedItem[      tag: "Sample Type"L, place: [354, line0], feedback: all, proc: SampleTypeTransition, choices: DESCRIPTOR[sampleType], value: @data.sampleType];    items[DHBDefs.FormItems.from.ORD] ¬ StringItem[      tag: "From"L, place: [12, line1], inHeap: TRUE, filterProc: fromFilterProc, string: @data.from];    items[DHBDefs.FormItems.saveLog.ORD] ¬ CommandItem[      tag: "Save Log"L, place: [180, line1], proc: SaveLog];    items[DHBDefs.FormItems.saveSettings.ORD] ¬ CommandItem[      tag: "Save Settings"L, place: [258, line1], proc: SaveSettings];    items[DHBDefs.FormItems.outputBase.ORD] ¬ EnumeratedItem[      tag: "Output Base"L, place: [354, line1], choices: DESCRIPTOR[outputBase], value: @data.outputBase];    items[DHBDefs.FormItems.to.ORD] ¬ StringItem[      tag: "To"L, place: [12, line2], inHeap: TRUE, filterProc: toFilterProc, string: @data.to];    items[DHBDefs.FormItems.clearLog.ORD] ¬ CommandItem[      tag: "Clear Log"L, place: [180, line2], proc: ClearLog];    items[DHBDefs.FormItems.help.ORD] ¬ CommandItem[      tag: "Help"L, place: [258, line2], proc: Help];    items[DHBDefs.FormItems.file.ORD] ¬ StringItem[      tag: "File"L, place: [12, line3], inHeap: TRUE, string: @data.file];    items[DHBDefs.FormItems.iOPTRIGGERPARAMETERS.ORD] ¬ TagOnlyItem[      tag: "============================ IOP TRIGGER PARAMETERS ============================ "L, place: [12, line4]];    items[DHBDefs.FormItems.cSTRIGGERPARAMETERS.ORD] ¬ TagOnlyItem[      tag: "============================ CS  TRIGGER PARAMETERS ============================ "L, place: [12, line4], invisible: FALSE];    items[DHBDefs.FormItems.data.ORD] ¬ StringItem[      tag: "Data"L, place: [12, line5], inHeap: TRUE, filterProc: dataFilterProc, menuProc: dataMenuProc, boxWidth: 100, string: @data.data];    items[DHBDefs.FormItems.bank.ORD] ¬ StringItem[      tag: "Bank"L, place: [12, line5], invisible: FALSE, inHeap: TRUE, filterProc: bankFilterProc, menuProc: bankMenuProc, boxWidth: 100, string: @data.bank];    items[DHBDefs.FormItems.status.ORD] ¬ StringItem[      tag: "Status"L, place: [300, line5], inHeap: TRUE, filterProc: statusFilterProc, menuProc: statusMenuProc, boxWidth: 100, string: @data.status];    items[DHBDefs.FormItems.machineType.ORD] ¬ EnumeratedItem[      tag: "MachineType"L, place: [300, line5], invisible: FALSE, feedback: all, choices: DESCRIPTOR[machineType], value: @data.machineType];    items[DHBDefs.FormItems.address.ORD] ¬ StringItem[      tag: "Address"L, place: [12, line6], inHeap: TRUE, filterProc: addressFilterProc, menuProc: addressMenuProc, boxWidth: 100, string: @data.address];    items[DHBDefs.FormItems.nIA.ORD] ¬ StringItem[      tag: "NIA"L, place: [12, line6], invisible: FALSE, inHeap: TRUE, filterProc: nIAFilterProc, menuProc: nIAMenuProc, boxWidth: 100, string: @data.nIA];    items[DHBDefs.FormItems.iOPwildCard.ORD] ¬ StringItem[      tag: "Wild Card"L, place: [300, line6], inHeap: TRUE, filterProc: iOPWildCardFilterProc, menuProc: iOPWildCardMenuProc, boxWidth: 100, string: @data.iOPwildCard];    items[DHBDefs.FormItems.cSwildCard.ORD] ¬ StringItem[      tag: "Wild Card"L, place: [300, line6], invisible: FALSE, inHeap: TRUE, filterProc: cSWildCardFilterProc, menuProc: cSWildCardMenuProc, boxWidth: 130, string: @data.cSwildCard];    items[DHBDefs.FormItems.noofWaitCycles.ORD] ¬ StringItem[      tag: "No. of Wait Cycles"L, place: [12, line7], inHeap: TRUE, filterProc: noofWaitCyclesFilterProc, menuProc: noofWaitCyclesMenuProc, boxWidth: 100, string: @data.noofWaitCycles];      items[DHBDefs.FormItems.halt.ORD] ¬ StringItem[      tag: "Halt"L, place: [12, line7], invisible: FALSE, inHeap: TRUE, filterProc: haltFilterProc, menuProc: haltMenuProc, boxWidth: 100, string: @data.halt];    items[DHBDefs.FormItems.arbitor.ORD] ¬ StringItem[      tag: "Arbitor"L, place: [300, line7], inHeap: TRUE, filterProc: arbitorFilterProc, menuProc: arbitorMenuProc, boxWidth: 100, string: @data.arbitor];    items[DHBDefs.FormItems.multiTRG.ORD] ¬ StringItem[      tag: "Multi-TRG"L, place: [12, line8], inHeap: TRUE, filterProc: multiTRGFilterProc, menuProc: multiTRGMenuProc, boxWidth: 100, string: @data.multiTRG];    items[DHBDefs.FormItems.postTrigSampleX.ORD] ¬ StringItem[      tag: "Post Trig Sample (X256)"L, place: [300, line8], inHeap: TRUE, filterProc: postTrigSampleXFilterProc, menuProc: postTrigSampleXMenuProc, boxWidth: 100, string: @data.postTrigSampleX];    RETURN[items: items, freeDesc: TRUE];    };  -- Mainline code << Init[];  -- this gets string out of global frame >>  IgnoreCommandLine: Exec.ExecProc =     BEGIN     IF NOT initialized THEN        Init[h]     END;            Register: PROC = {Exec.AddCommand[name: "DoveHistoryBuffer.~"L, proc: IgnoreCommandLine, unload: Unload]};  Register[];    }...    
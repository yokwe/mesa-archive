-- Copyright (C) 1984, 1985  by Xerox Corporation. All rights reserved. -- DisplayerLoadSave.mesa-- DEG       3-Mar-84 18:32:40DIRECTORY  Atom USING [ATOM, MakeAtom],  Format USING [Number, StringProc],  FormSW USING [EnumeratedFeedback, Radix, StringFeedback],  Put USING [CR, Line, LongNumber, Text],  Stream USING [EndOfStream, GetChar, GetPosition, Handle],  String USING [AppendChar, CopyToNewString, Length, StringBoundsFault],  SimpleDisplayer USING [    AddItem, DataHandle, EnumerateItems, FinishBoolean, FinishCommand,    FinishEnumerated, FinishLongNumber, FinishNumber, FinishSource, FinishString,    FinishTagOnly, ItemHandle, ItemObject, OK, Paint, zone],  UserTerminal USING [BlinkDisplay],  Window USING [Handle, Place];DisplayerLoadSave: MONITOR  IMPORTS Atom, Format, SimpleDisplayer, Stream, Put, UserTerminal, String  EXPORTS SimpleDisplayer =  {  TokenPtr: TYPE = LONG POINTER TO TokenRec;  TokenRec: TYPE = RECORD [    booleanItem, commandItem, enumeratedItem, longNumberItem, numberItem,      sourceItem, stringItem, tagOnlyItem, global, tag, enumName, place, word,      startingBitPostion, bitsOccupied, byteFlippedMachine, bitOrderingLowToHigh,      readOnly, invisible, drawBox, hasContext, finished, switch, proc, feedback,      copyChoices, value, choices, choiceName, signed, notNegative, radix,      boxWidth, default, string, bias, source, filterProc, menuProc, inHeap,      otherItem, zone, enumType, handleName, stuffString, alignX, anyFont, useBox,      procName: Atom.ATOM ¬ NIL];  t: TokenPtr ¬ NIL;  buffer: LONG STRING ¬ NIL;  EndOfItem: SIGNAL;  BadInput: SIGNAL;  BadAtom: SIGNAL [atom: Atom.ATOM];  Save: PUBLIC ENTRY PROC [    proc: Format.StringProc, instance: SimpleDisplayer.DataHandle] = {    WriteGlobal[instance: instance, Write: proc];    SimpleDisplayer.EnumerateItems[      proc: BuildItems, Write: proc, instance: instance];    };  Load: PUBLIC ENTRY PROC [instance: SimpleDisplayer.DataHandle] = {    BEGIN    ENABLE {      BadInput => {        Put.Text[instance.msgSW, "Bad input at position "L];        Put.LongNumber[instance.msgSW, instance.stream.GetPosition[], []];        Put.CR[instance.msgSW];        UserTerminal.BlinkDisplay[];        GOTO quit};      BadAtom => {        Put.Text[instance.msgSW, "Bad input at position "L];        Put.LongNumber[instance.msgSW, instance.stream.GetPosition[], []];        Put.Text[instance.msgSW, ", token: "L];        Put.Line[instance.msgSW, atom];        UserTerminal.BlinkDisplay[];        GOTO quit};      String.StringBoundsFault => {        buffer ¬ ns ¬ SimpleDisplayer.zone.NEW[StringBody [s.maxlength * 2]];        ns.length ¬ s.length;        FOR i: CARDINAL IN [0..s.length) DO ns[i] ¬ s[i] ENDLOOP;        SimpleDisplayer.zone.FREE[@s];        RESUME        };      };    token: Atom.ATOM;    item: SimpleDisplayer.ItemHandle;    buffer ¬ SimpleDisplayer.zone.NEW[StringBody [200]];    DO      token ¬ GetToken[stream: instance.stream ! Stream.EndOfStream => GOTO quit];      SELECT token FROM        t.booleanItem => item ¬ LoadBoolean[stream: instance.stream];        t.commandItem => item ¬ LoadCommand[stream: instance.stream];        t.enumeratedItem =>          item ¬ LoadEnumerated[stream: instance.stream, instance: instance];        t.longNumberItem => item ¬ LoadLongNumber[stream: instance.stream];        t.numberItem => item ¬ LoadNumber[stream: instance.stream];        t.sourceItem => item ¬ LoadSource[stream: instance.stream];        t.stringItem => item ¬ LoadString[stream: instance.stream];        t.tagOnlyItem => item ¬ LoadTagOnly[stream: instance.stream];        t.global => {LoadGlobal[instance: instance]; LOOP};        t.finished => EXIT;        ENDCASE => {          Put.Text[instance.msgSW, "Bad input at position "L];          Put.LongNumber[instance.msgSW, instance.stream.GetPosition[], []];          Put.CR[instance.msgSW];          UserTerminal.BlinkDisplay[];          SimpleDisplayer.zone.FREE[@buffer];          RETURN};      IF item.enumName = NIL THEN        item.enumName ¬ String.CopyToNewString[item.tag, SimpleDisplayer.zone];      SimpleDisplayer.AddItem[item, instance];      SimpleDisplayer.Paint[item, instance];      ENDLOOP;    END;    EXITS quit => SimpleDisplayer.zone.FREE[@buffer];    };  WriteGlobal: PROCEDURE [    instance: SimpleDisplayer.DataHandle, Write: Format.StringProc] = {    firstOne: BOOLEAN ¬ TRUE;    PutComma: PROC = {IF firstOne THEN firstOne ¬ FALSE ELSE Write[", "L]};    Write["Global[\n      "L];    IF String.Length[instance.toolZone] # 0 THEN {      PutComma[]; Write["zone: "L]; Write[instance.toolZone]};    IF String.Length[instance.defaults.enumType] # 0 THEN {      PutComma[]; Write["enumType: "L]; Write[instance.defaults.enumType]};    IF String.Length[instance.defaults.handleName] # 0 THEN {      PutComma[]; Write["handleName: "L]; Write[instance.defaults.handleName]};    IF String.Length[instance.defaults.stuffString] # 0 THEN {      PutComma[];      Write["stuffString: \""L];      Write[instance.defaults.stuffString];      Write["\""L]};    IF String.Length[instance.defaults.procName] # 0 THEN {      PutComma[]; Write["procName: "L]; Write[instance.defaults.procName]};    IF instance.alignX THEN {PutComma[]; Write["alignX: TRUE"L]};    IF instance.useBox THEN {PutComma[]; Write["useBox: TRUE"L]};    IF instance.anyFont THEN {PutComma[]; Write["anyFont: TRUE"L]};    Write["];\n"L];    };  BuildItems: PROC [    item: SimpleDisplayer.ItemHandle, Write: Format.StringProc,    instance: SimpleDisplayer.DataHandle ¬ NIL] = {    Write[      SELECT item.type FROM        boolean => "Boolean"L,        command => "Command"L,        enumerated => "Enumerated"L,        longNumber => "LongNumber"L,        number => "Number"L,        source => "Source"L,        string => "String"L,        ENDCASE => "TagOnly"L];    Write["Item[\n      tag: \""L];    Write[item.tag];    Write["\", enumName: "L];    Write[item.enumName];    Write[", place: ["L];    Format.Number[Write, item.box.place.x, []];    Write[", "L];    Format.Number[Write, item.box.place.y, []];    Write["]"L];    WriteBooleanValue[Write, ", byteFlippedMachine"L, item.byteSwappedMachine];    WriteBooleanValue[Write, ", bitOrderingLowToHigh"L, item.bitOrderingLowToHigh];    Write[", word: "L];    Format.Number[Write, item.word, []];    Write[", startingBitPostion: "L];    Format.Number[Write, item.startingBitPostion, []];    Write[", bitsOccupied: "L];    Format.Number[Write, item.bitsOccupied, []];    WriteBooleanValue[Write, ", readOnly"L, item.readOnly];    WriteBooleanValue[Write, ", invisible"L, item.invisible];    WriteBooleanValue[Write, ", drawBox"L, item.drawBox];    WriteBooleanValue[Write, ", hasContext"L, item.hasContext];    WITH vi: item­ SELECT FROM      boolean => SimpleDisplayer.FinishBoolean[@vi, FALSE, Write];      command => SimpleDisplayer.FinishCommand[@vi, Write];      enumerated => {        SimpleDisplayer.FinishEnumerated[@vi, FALSE, Write];        Write["];\n-- "L];        Write[vi.choices];        Write["\n"L];        RETURN};      longNumber => SimpleDisplayer.FinishLongNumber[@vi, FALSE, Write];      number => SimpleDisplayer.FinishNumber[@vi, FALSE, Write];      source => SimpleDisplayer.FinishSource[@vi, Write];      string => SimpleDisplayer.FinishString[@vi, FALSE, Write];      tagOnly => SimpleDisplayer.FinishTagOnly[@vi, Write];      ENDCASE;    Write["];\n"L];    };  ConsumePastDashes: PROCEDURE [stream: Stream.Handle] RETURNS [ch: CHARACTER] = {    WHILE (ch ¬ stream.GetChar[]) # '- DO ENDLOOP;    WHILE (ch ¬ stream.GetChar[]) = '- DO ENDLOOP;    };  ConsumeWhite: PROCEDURE [stream: Stream.Handle] RETURNS [ch: CHARACTER] = {    DO      ch ¬ stream.GetChar[];      IF ch = '  OR ch = '\n OR ch = '\t THEN LOOP;      IF ch = '; THEN SIGNAL EndOfItem;      IF (ch IN ['A..'Z]) OR (ch IN ['a..'z]) THEN EXIT;      ENDLOOP;    };  ConsumeNonNumeric: PROCEDURE [stream: Stream.Handle] RETURNS [ch: CHARACTER] = {    UNTIL ((ch ¬ stream.GetChar[]) IN ['0..'9]) OR (ch = '-) DO ENDLOOP};  ConsumeAlpha: PROCEDURE [stream: Stream.Handle] = {    ch: CHARACTER;    WHILE ((ch ¬ stream.GetChar[]) IN ['A..'Z]) OR (ch IN ['a..'z]) DO ENDLOOP;    };  GetToken: PROCEDURE [stream: Stream.Handle] RETURNS [atom: Atom.ATOM] = {    ch: CHARACTER;    buffer.length ¬ 0;    String.AppendChar[buffer, ConsumeWhite[stream: stream]];    WHILE (ch ¬ stream.GetChar[]) IN ['A..'Z] OR (ch IN ['a..'z]) DO      String.AppendChar[buffer, ch]; ENDLOOP;    atom ¬ Atom.MakeAtom[buffer];    };  LoadBoolean: PROCEDURE [stream: Stream.Handle]    RETURNS [item: LONG POINTER TO SimpleDisplayer.ItemObject.boolean] = {    token: Atom.ATOM;    item ¬ SimpleDisplayer.zone.NEW[      SimpleDisplayer.ItemObject.boolean ¬ [body: boolean[], maxBitsOccupied: 1]];    DO      token ¬ GetToken[stream: stream ! EndOfItem => GOTO quit];      SELECT token FROM        t.tag => item.tag ¬ GetQuoteString[stream: stream];        t.enumName => item.enumName ¬ GetString[stream: stream];        t.place => item.box.place ¬ GetPlace[stream: stream];        t.switch => item.switch ¬ GetString[stream: stream];        t.proc => item.proc ¬ GetString[stream: stream];        t.readOnly => item.readOnly ¬ GetBoolean[stream: stream];        t.invisible => item.invisible ¬ GetBoolean[stream: stream];        t.drawBox => item.drawBox ¬ GetBoolean[stream: stream];        t.hasContext => item.hasContext ¬ GetBoolean[stream: stream];        t.byteFlippedMachine =>          item.byteSwappedMachine ¬ GetBoolean[stream: stream];        t.bitOrderingLowToHigh =>          item.bitOrderingLowToHigh ¬ GetBoolean[stream: stream];        t.word => item.word ¬ GetNumber[stream: stream];        t.startingBitPostion =>          item.startingBitPostion ¬ GetNumber[stream: stream];        t.bitsOccupied => item.bitsOccupied ¬ GetNumber[stream: stream];        ENDCASE => SIGNAL BadAtom[token];      ENDLOOP;    EXITS quit => NULL;    };  LoadCommand: PROCEDURE [stream: Stream.Handle]    RETURNS [item: LONG POINTER TO SimpleDisplayer.ItemObject.command] = {    token: Atom.ATOM;    item ¬ SimpleDisplayer.zone.NEW[      SimpleDisplayer.ItemObject.command ¬ [body: command[]]];    DO      token ¬ GetToken[stream: stream ! EndOfItem => GOTO quit];      SELECT token FROM        t.tag => item.tag ¬ GetQuoteString[stream: stream];        t.enumName => item.enumName ¬ GetString[stream: stream];        t.place => item.box.place ¬ GetPlace[stream: stream];        t.readOnly => item.readOnly ¬ GetBoolean[stream: stream];        t.invisible => item.invisible ¬ GetBoolean[stream: stream];        t.drawBox => item.drawBox ¬ GetBoolean[stream: stream];        t.hasContext => item.hasContext ¬ GetBoolean[stream: stream];        t.proc => item.proc ¬ GetString[stream: stream];        t.byteFlippedMachine =>          item.byteSwappedMachine ¬ GetBoolean[stream: stream];        t.bitOrderingLowToHigh =>          item.bitOrderingLowToHigh ¬ GetBoolean[stream: stream];        t.word => item.word ¬ GetNumber[stream: stream];        t.startingBitPostion =>          item.startingBitPostion ¬ GetNumber[stream: stream];        t.bitsOccupied => item.bitsOccupied ¬ GetNumber[stream: stream];        ENDCASE => SIGNAL BadAtom[token];      ENDLOOP;    EXITS quit => NULL;    };  LoadEnumerated: PROCEDURE [    stream: Stream.Handle, instance: SimpleDisplayer.DataHandle]    RETURNS [item: LONG POINTER TO SimpleDisplayer.ItemObject.enumerated] = {    token: Atom.ATOM;    item ¬ SimpleDisplayer.zone.NEW[      SimpleDisplayer.ItemObject.enumerated ¬ [      body: enumerated[], maxBitsOccupied: 16]];    DO      token ¬ GetToken[stream: stream ! EndOfItem => GOTO quit];      SELECT token FROM        t.tag => item.tag ¬ GetQuoteString[stream: stream];        t.enumName => item.enumName ¬ GetString[stream: stream];        t.place => item.box.place ¬ GetPlace[stream: stream];        t.readOnly => item.readOnly ¬ GetBoolean[stream: stream];        t.invisible => item.invisible ¬ GetBoolean[stream: stream];        t.drawBox => item.drawBox ¬ GetBoolean[stream: stream];        t.hasContext => item.hasContext ¬ GetBoolean[stream: stream];        t.copyChoices => item.copyChoices ¬ GetBoolean[stream: stream];        t.value => item.value ¬ GetString[stream: stream];        t.feedback => item.feedback ¬ GetFeedbackEnum[stream: stream];        t.proc => item.proc ¬ GetString[stream: stream];        t.choices => item.choiceName ¬ GetString[stream: stream];        t.byteFlippedMachine =>          item.byteSwappedMachine ¬ GetBoolean[stream: stream];        t.bitOrderingLowToHigh =>          item.bitOrderingLowToHigh ¬ GetBoolean[stream: stream];        t.word => item.word ¬ GetNumber[stream: stream];        t.startingBitPostion =>          item.startingBitPostion ¬ GetNumber[stream: stream];        t.bitsOccupied => item.bitsOccupied ¬ GetNumber[stream: stream];        ENDCASE => SIGNAL BadAtom[token];      ENDLOOP;    EXITS      quit => {        item.choices ¬ GetCommentedString[stream: stream];        IF ~SimpleDisplayer.OK[item, instance, FALSE] THEN SIGNAL BadInput};    };  LoadLongNumber: PROCEDURE [stream: Stream.Handle]    RETURNS [item: LONG POINTER TO SimpleDisplayer.ItemObject.longNumber] = {    token: Atom.ATOM;    item ¬ SimpleDisplayer.zone.NEW[      SimpleDisplayer.ItemObject.longNumber ¬ [      body: longNumber[], maxBitsOccupied: 32]];    DO      token ¬ GetToken[stream: stream ! EndOfItem => GOTO quit];      SELECT token FROM        t.tag => item.tag ¬ GetQuoteString[stream: stream];        t.enumName => item.enumName ¬ GetString[stream: stream];        t.place => item.box.place ¬ GetPlace[stream: stream];        t.readOnly => item.readOnly ¬ GetBoolean[stream: stream];        t.invisible => item.invisible ¬ GetBoolean[stream: stream];        t.drawBox => item.drawBox ¬ GetBoolean[stream: stream];        t.hasContext => item.hasContext ¬ GetBoolean[stream: stream];        t.value => item.value ¬ GetString[stream: stream];        t.proc => item.proc ¬ GetString[stream: stream];        t.signed => item.signed ¬ GetBoolean[stream: stream];        t.notNegative => item.notNegative ¬ GetBoolean[stream: stream];        t.radix => item.radix ¬ GetRadix[stream: stream];        t.string => item.string ¬ GetString[stream: stream];        t.default => item.default ¬ GetLongNumber[stream: stream];        t.boxWidth => item.boxWidth ¬ GetNumber[stream: stream];        t.bias => item.bias ¬ GetNumber[stream: stream];        t.byteFlippedMachine =>          item.byteSwappedMachine ¬ GetBoolean[stream: stream];        t.bitOrderingLowToHigh =>          item.bitOrderingLowToHigh ¬ GetBoolean[stream: stream];        t.word => item.word ¬ GetNumber[stream: stream];        t.startingBitPostion =>          item.startingBitPostion ¬ GetNumber[stream: stream];        t.bitsOccupied => item.bitsOccupied ¬ GetNumber[stream: stream];        ENDCASE => SIGNAL BadAtom[token];      ENDLOOP;    EXITS quit => NULL;    };  LoadNumber: PROCEDURE [stream: Stream.Handle]    RETURNS [item: LONG POINTER TO SimpleDisplayer.ItemObject.number] = {    token: Atom.ATOM;    item ¬ SimpleDisplayer.zone.NEW[      SimpleDisplayer.ItemObject.number ¬ [body: number[], maxBitsOccupied: 16]];    DO      token ¬ GetToken[stream: stream ! EndOfItem => GOTO quit];      SELECT token FROM        t.tag => item.tag ¬ GetQuoteString[stream: stream];        t.enumName => item.enumName ¬ GetString[stream: stream];        t.place => item.box.place ¬ GetPlace[stream: stream];        t.readOnly => item.readOnly ¬ GetBoolean[stream: stream];        t.invisible => item.invisible ¬ GetBoolean[stream: stream];        t.drawBox => item.drawBox ¬ GetBoolean[stream: stream];        t.hasContext => item.hasContext ¬ GetBoolean[stream: stream];        t.value => item.value ¬ GetString[stream: stream];        t.proc => item.proc ¬ GetString[stream: stream];        t.signed => item.signed ¬ GetBoolean[stream: stream];        t.notNegative => item.notNegative ¬ GetBoolean[stream: stream];        t.radix => item.radix ¬ GetRadix[stream: stream];        t.string => item.string ¬ GetString[stream: stream];        t.default => item.default ¬ GetNumber[stream: stream];        t.boxWidth => item.boxWidth ¬ GetNumber[stream: stream];        t.bias => item.bias ¬ GetNumber[stream: stream];        t.byteFlippedMachine =>          item.byteSwappedMachine ¬ GetBoolean[stream: stream];        t.bitOrderingLowToHigh =>          item.bitOrderingLowToHigh ¬ GetBoolean[stream: stream];        t.word => item.word ¬ GetNumber[stream: stream];        t.startingBitPostion =>          item.startingBitPostion ¬ GetNumber[stream: stream];        t.bitsOccupied => item.bitsOccupied ¬ GetNumber[stream: stream];        ENDCASE => SIGNAL BadAtom[token];      ENDLOOP;    EXITS quit => NULL;    };  LoadSource: PROCEDURE [stream: Stream.Handle]    RETURNS [item: LONG POINTER TO SimpleDisplayer.ItemObject.source] = {    token: Atom.ATOM;    item ¬ SimpleDisplayer.zone.NEW[      SimpleDisplayer.ItemObject.source ¬ [body: source[]]];    DO      token ¬ GetToken[stream: stream ! EndOfItem => GOTO quit];      SELECT token FROM        t.tag => item.tag ¬ GetQuoteString[stream: stream];        t.enumName => item.enumName ¬ GetString[stream: stream];        t.place => item.box.place ¬ GetPlace[stream: stream];        t.readOnly => item.readOnly ¬ GetBoolean[stream: stream];        t.invisible => item.invisible ¬ GetBoolean[stream: stream];        t.drawBox => item.drawBox ¬ GetBoolean[stream: stream];        t.hasContext => item.hasContext ¬ GetBoolean[stream: stream];        t.source => item.source ¬ GetString[stream: stream];        t.boxWidth => item.boxWidth ¬ GetNumber[stream: stream];        t.filterProc => item.filterProc ¬ GetString[stream: stream];        t.menuProc => item.menuProc ¬ GetString[stream: stream];        t.byteFlippedMachine =>          item.byteSwappedMachine ¬ GetBoolean[stream: stream];        t.bitOrderingLowToHigh =>          item.bitOrderingLowToHigh ¬ GetBoolean[stream: stream];        t.word => item.word ¬ GetNumber[stream: stream];        t.startingBitPostion =>          item.startingBitPostion ¬ GetNumber[stream: stream];        t.bitsOccupied => item.bitsOccupied ¬ GetNumber[stream: stream];        ENDCASE => SIGNAL BadAtom[token];      ENDLOOP;    EXITS quit => NULL;    };  LoadString: PROCEDURE [stream: Stream.Handle]    RETURNS [item: LONG POINTER TO SimpleDisplayer.ItemObject.string] = {    token: Atom.ATOM;    item ¬ SimpleDisplayer.zone.NEW[      SimpleDisplayer.ItemObject.string ¬ [body: string[], maxBitsOccupied: 8192]];    DO      token ¬ GetToken[stream: stream ! EndOfItem => GOTO quit];      SELECT token FROM        t.tag => item.tag ¬ GetQuoteString[stream: stream];        t.enumName => item.enumName ¬ GetString[stream: stream];        t.place => item.box.place ¬ GetPlace[stream: stream];        t.readOnly => item.readOnly ¬ GetBoolean[stream: stream];        t.invisible => item.invisible ¬ GetBoolean[stream: stream];        t.drawBox => item.drawBox ¬ GetBoolean[stream: stream];        t.hasContext => item.hasContext ¬ GetBoolean[stream: stream];        t.feedback => item.feedback ¬ GetFeedbackString[stream: stream];        t.inHeap => item.inHeap ¬ GetBoolean[stream: stream];        t.string => item.string ¬ GetString[stream: stream];        t.boxWidth => item.boxWidth ¬ GetNumber[stream: stream];        t.filterProc => item.filterProc ¬ GetString[stream: stream];        t.menuProc => item.menuProc ¬ GetString[stream: stream];        t.byteFlippedMachine =>          item.byteSwappedMachine ¬ GetBoolean[stream: stream];        t.bitOrderingLowToHigh =>          item.bitOrderingLowToHigh ¬ GetBoolean[stream: stream];        t.word => item.word ¬ GetNumber[stream: stream];        t.startingBitPostion =>          item.startingBitPostion ¬ GetNumber[stream: stream];        t.bitsOccupied => item.bitsOccupied ¬ GetNumber[stream: stream];        ENDCASE => SIGNAL BadAtom[token];      ENDLOOP;    EXITS quit => NULL;    };  LoadTagOnly: PROCEDURE [stream: Stream.Handle]    RETURNS [item: LONG POINTER TO SimpleDisplayer.ItemObject.tagOnly] = {    token: Atom.ATOM;    item ¬ SimpleDisplayer.zone.NEW[      SimpleDisplayer.ItemObject.tagOnly ¬ [body: tagOnly[]]];    DO      token ¬ GetToken[stream: stream ! EndOfItem => GOTO quit];      SELECT token FROM        t.tag => item.tag ¬ GetQuoteString[stream: stream];        t.enumName => item.enumName ¬ GetString[stream: stream];        t.place => item.box.place ¬ GetPlace[stream: stream];        t.readOnly => item.readOnly ¬ GetBoolean[stream: stream];        t.invisible => item.invisible ¬ GetBoolean[stream: stream];        t.drawBox => item.drawBox ¬ GetBoolean[stream: stream];        t.hasContext => item.hasContext ¬ GetBoolean[stream: stream];        t.otherItem => item.other ¬ GetNumber[stream: stream];        t.byteFlippedMachine =>          item.byteSwappedMachine ¬ GetBoolean[stream: stream];        t.bitOrderingLowToHigh =>          item.bitOrderingLowToHigh ¬ GetBoolean[stream: stream];        t.word => item.word ¬ GetNumber[stream: stream];        t.startingBitPostion =>          item.startingBitPostion ¬ GetNumber[stream: stream];        t.bitsOccupied => item.bitsOccupied ¬ GetNumber[stream: stream];        ENDCASE => SIGNAL BadAtom[token];      ENDLOOP;    EXITS quit => NULL;    };  LoadGlobal: PROCEDURE [instance: SimpleDisplayer.DataHandle] = {    token: Atom.ATOM;    BEGIN    instance.alignX ¬ instance.anyFont ¬ instance.useBox ¬ FALSE;    DO      token ¬ GetToken[stream: instance.stream ! EndOfItem => GOTO quit];      SELECT token FROM        t.zone => {          SimpleDisplayer.zone.FREE[@instance.toolZone];          instance.toolZone ¬ GetString[stream: instance.stream]};        t.enumType => {          SimpleDisplayer.zone.FREE[@instance.defaults.enumType];          instance.defaults.enumType ¬ GetString[stream: instance.stream]};        t.handleName => {          SimpleDisplayer.zone.FREE[@instance.defaults.handleName];          instance.defaults.handleName ¬ GetString[stream: instance.stream]};        t.stuffString => {          SimpleDisplayer.zone.FREE[@instance.defaults.stuffString];          instance.defaults.stuffString ¬ GetQuoteString[stream: instance.stream]};        t.procName => {          SimpleDisplayer.zone.FREE[@instance.defaults.procName];          instance.defaults.procName ¬ GetString[stream: instance.stream]};        t.alignX => instance.alignX ¬ GetBoolean[stream: instance.stream];        t.anyFont => instance.anyFont ¬ GetBoolean[stream: instance.stream];        t.useBox => instance.useBox ¬ GetBoolean[stream: instance.stream];        ENDCASE => SIGNAL BadAtom[token];      ENDLOOP;    EXITS quit => NULL;    END;    IF instance.defaults.enumType = NIL THEN      instance.defaults.enumType ¬ String.CopyToNewString[        "FormItems"L, SimpleDisplayer.zone];    IF instance.defaults.handleName = NIL THEN      instance.defaults.handleName ¬ String.CopyToNewString[        "data"L, SimpleDisplayer.zone];    };  GetBoolean: PROCEDURE [stream: Stream.Handle] RETURNS [b: BOOLEAN] = {    ch: CHARACTER ¬ ConsumeWhite[stream: stream];    SELECT ch FROM 'T => b ¬ TRUE; 'F => b ¬ FALSE; ENDCASE => SIGNAL BadInput;    ConsumeAlpha[stream: stream];    };  GetCommentedString: PROCEDURE [stream: Stream.Handle]    RETURNS [str: LONG STRING] = {    ch: CHARACTER ¬ ConsumePastDashes[stream: stream];    buffer.length ¬ 0;    String.AppendChar[buffer, ch];    WHILE ((ch ¬ stream.GetChar[]) # '\n) DO      String.AppendChar[buffer, ch]; ENDLOOP;    str ¬ String.CopyToNewString[buffer, SimpleDisplayer.zone];    };  GetFeedbackEnum: PROCEDURE [stream: Stream.Handle]    RETURNS [f: FormSW.EnumeratedFeedback] = {    ch: CHARACTER ¬ ConsumeWhite[stream: stream];    SELECT ch FROM 'o => f ¬ one; 'a => f ¬ all; ENDCASE => SIGNAL BadInput;    ConsumeAlpha[stream: stream];    };  GetFeedbackString: PROCEDURE [stream: Stream.Handle]    RETURNS [f: FormSW.StringFeedback] = {    ch: CHARACTER ¬ ConsumeWhite[stream: stream];    SELECT ch FROM      'n => f ¬ normal;      'p => f ¬ password;      ENDCASE => SIGNAL BadInput;    ConsumeAlpha[stream: stream];    };  GetLongNumber: PROCEDURE [stream: Stream.Handle] RETURNS [n: LONG INTEGER] = {    ch: CHARACTER ¬ ConsumeNonNumeric[stream: stream];    i: INTEGER ¬ IF ch = '- THEN -1 ELSE 1;    n ¬ 0;    IF ch IN ['0..'9] THEN n ¬ ch - '0;    WHILE (ch ¬ stream.GetChar[]) IN ['0..'9] DO n ¬ (10 * n) + ch - '0; ENDLOOP;    n ¬ n * i;    };  GetNumber: PROCEDURE [stream: Stream.Handle] RETURNS [n: INTEGER] = {    ch: CHARACTER ¬ ConsumeNonNumeric[stream: stream];    i: INTEGER ¬ IF ch = '- THEN -1 ELSE 1;    n ¬ 0;    IF ch IN ['0..'9] THEN n ¬ ch - '0;    WHILE (ch ¬ stream.GetChar[]) IN ['0..'9] DO n ¬ (10 * n) + ch - '0; ENDLOOP;    n ¬ n * i;    };  GetPlace: PROCEDURE [stream: Stream.Handle] RETURNS [p: Window.Place] = {    p.x ¬ GetNumber[stream: stream]; p.y ¬ GetNumber[stream: stream]; };  GetQuoteString: PROCEDURE [stream: Stream.Handle] RETURNS [str: LONG STRING] = {    ch: CHARACTER;    buffer.length ¬ 0;    WHILE (ch ¬ stream.GetChar[]) # '" DO ENDLOOP;    WHILE (ch ¬ stream.GetChar[]) # '" DO String.AppendChar[buffer, ch] ENDLOOP;    str ¬ String.CopyToNewString[buffer, SimpleDisplayer.zone];    };  GetRadix: PROCEDURE [stream: Stream.Handle] RETURNS [r: FormSW.Radix] = {    ch: CHARACTER ¬ ConsumeWhite[stream: stream];    SELECT ch FROM 'd => r ¬ decimal; 'o => r ¬ octal; ENDCASE => SIGNAL BadInput;    ConsumeAlpha[stream: stream];    };  GetString: PROCEDURE [stream: Stream.Handle] RETURNS [str: LONG STRING] = {    ch: CHARACTER ¬ ConsumeWhite[stream: stream];    buffer.length ¬ 0;    String.AppendChar[buffer, ch];    WHILE ((ch ¬ stream.GetChar[]) IN ['A..'Z]) OR (ch IN ['a..'z])      OR (ch IN ['0..'9]) OR (ch = '.) DO String.AppendChar[buffer, ch]; ENDLOOP;    str ¬ String.CopyToNewString[buffer, SimpleDisplayer.zone];    };  WriteBooleanValue: PROCEDURE [    Write: Format.StringProc, tag: LONG STRING, value: BOOLEAN] = {    Write[tag]; IF value THEN Write[": TRUE"L] ELSE Write[": FALSE"L]};  Init: PROC = {    t ¬ SimpleDisplayer.zone.NEW[      TokenRec ¬ [      booleanItem: Atom.MakeAtom["BooleanItem"L],      commandItem: Atom.MakeAtom["CommandItem"L],      enumeratedItem: Atom.MakeAtom["EnumeratedItem"L],      longNumberItem: Atom.MakeAtom["LongNumberItem"L],      numberItem: Atom.MakeAtom["NumberItem"L],      sourceItem: Atom.MakeAtom["SourceItem"L],      stringItem: Atom.MakeAtom["StringItem"L],      tagOnlyItem: Atom.MakeAtom["TagOnlyItem"L], global: Atom.MakeAtom["Global"L],      tag: Atom.MakeAtom["tag"L], enumName: Atom.MakeAtom["enumName"L],      place: Atom.MakeAtom["place"L], word: Atom.MakeAtom["word"L],      startingBitPostion: Atom.MakeAtom["startingBitPostion"L],      bitsOccupied: Atom.MakeAtom["bitsOccupied"L],      byteFlippedMachine: Atom.MakeAtom["byteFlippedMachine"L],      bitOrderingLowToHigh: Atom.MakeAtom["bitOrderingLowToHigh"L],      readOnly: Atom.MakeAtom["readOnly"L], invisible: Atom.MakeAtom["invisible"L],      drawBox: Atom.MakeAtom["drawBox"L], hasContext: Atom.MakeAtom["hasContext"L],      finished: Atom.MakeAtom["finished"L], switch: Atom.MakeAtom["switch"L],      proc: Atom.MakeAtom["proc"L], feedback: Atom.MakeAtom["feedback"L],      copyChoices: Atom.MakeAtom["copyChoices"L], value: Atom.MakeAtom["value"L],      choices: Atom.MakeAtom["choices"L], choiceName: Atom.MakeAtom["choiceName"L],      signed: Atom.MakeAtom["signed"L], notNegative: Atom.MakeAtom["notNegative"L],      radix: Atom.MakeAtom["radix"L], boxWidth: Atom.MakeAtom["boxWidth"L],      default: Atom.MakeAtom["default"L], string: Atom.MakeAtom["string"L],      bias: Atom.MakeAtom["bias"L], source: Atom.MakeAtom["source"L],      filterProc: Atom.MakeAtom["filterProc"L],      menuProc: Atom.MakeAtom["menuProc"L], inHeap: Atom.MakeAtom["inHeap"L],      otherItem: Atom.MakeAtom["otherItem"L], zone: Atom.MakeAtom["zone"L],      enumType: Atom.MakeAtom["enumType"L],      handleName: Atom.MakeAtom["handleName"L],      stuffString: Atom.MakeAtom["stuffString"L], alignX: Atom.MakeAtom["alignX"L],      anyFont: Atom.MakeAtom["anyFont"L], useBox: Atom.MakeAtom["useBox"L],      procName: Atom.MakeAtom["procName"L]]];    };  Init[];  }...    LOG  DEG     	 3-Mar-84 16:43:14      
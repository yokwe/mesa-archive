---- SymbolHashImpl.mesa, AYC   , 30-Apr-84 20:58:14-- from SymHasher.mesa,    HGM, 12-Nov-83 22:38:09--DIRECTORY  Heap USING [Create, Delete, systemZone],  Inline USING [BITAND, BITXOR],  String USING [AppendString, Equal],    SymbolHash USING [nullHash];SymbolHashImpl: PROGRAM  IMPORTS Heap, Inline, String  EXPORTS SymbolHash =  BEGIN  Handle: PUBLIC TYPE = LONG POINTER TO HashRegion;  Hash: PUBLIC TYPE = LONG POINTER TO HashBlock;    hVSize: CARDINAL = 71;  HashBlock: TYPE = RECORD [    next, chain: Hash,    info: LONG UNSPECIFIED,    string: LONG STRING];     HashRegion: TYPE = RECORD [    hVec: ARRAY [0..hVSize) OF Hash,    zone: UNCOUNTED ZONE,    pages: CARDINAL,    head, tail: Hash ];      HashFn: PROCEDURE [s: LONG STRING] RETURNS [[0..hVSize)] =    BEGIN  -- computes the hash index for string s    CharBits: PROCEDURE [CHARACTER, WORD] RETURNS [WORD] =      LOOPHOLE[Inline.BITAND];    Mask: WORD = 337B;  -- masks out ASCII case shifts    n: CARDINAL = s.length;    v: WORD;    v _ CharBits[s[0], Mask]*177B + CharBits[s[n - 1], Mask];    RETURN[Inline.BITXOR[v, n*17B] MOD hVSize]    END;  Lookup: PUBLIC PROCEDURE [data: Handle, key: LONG STRING] RETURNS [h: Hash] =    BEGIN    i: [0..hVSize) _ HashFn[key];    h _ data.hVec[i];    WHILE h # NIL DO      IF String.Equal[key, h.string] THEN RETURN[h];      h _ h.chain;      ENDLOOP;    RETURN[SymbolHash.nullHash];    END;---- to insert a hash element:-- IF lookup IS FALSE THEN--	HASH POINTER _ insert--	putinfo[HASH POINTER]-- ELSE error--  Insert: PUBLIC PROCEDURE [handle: Handle, key: LONG STRING] RETURNS [h: Hash] =    BEGIN    i: [0..hVSize) _ HashFn[key];    h _ handle.hVec[i];    WHILE h # NIL DO      IF String.Equal[key, h.string] THEN ERROR;      h _ h.chain;      ENDLOOP;    h _ NewEntry[handle, key, handle.hVec[i]];    handle.hVec[i] _ h;    END;      --  -- this maybe is building a doubly linked hash list(?)  -- 1. top-down: handle.head -> next -> ... -> NIL  -- 2. down-top: handle.hVec[Hashfn[key]] -> chain -> ... -> NIL  --  -- note: the top-down method was never used. (28-Apr-84 12:27:42, AYChen$)  --      NewEntry: PRIVATE PROCEDURE [handle: Handle, key: LONG STRING, chain: Hash]    RETURNS [Hash] =    BEGIN    h: Hash _ handle.zone.NEW[HashBlock];    h^ _ [      next: NIL, chain: chain, info: 0,      string: handle.zone.NEW[StringBody[key.length]] ];    String.AppendString[h.string, key];    IF handle.head = NIL THEN handle.head _ h ELSE handle.tail.next _ h;    handle.tail _ h;    RETURN[h];    END;  GetString: PUBLIC PROCEDURE [data: Handle, h: Hash] RETURNS [LONG STRING] =    BEGIN RETURN[h.string] END;  PutInfo: PUBLIC PROCEDURE [data: Handle, h: Hash, info: LONG UNSPECIFIED] =    BEGIN    h.info _ info;    END;  GetInfo: PUBLIC PROCEDURE [data: Handle, h: Hash] RETURNS [LONG UNSPECIFIED] =    BEGIN    RETURN[h.info];    END;  Create: PUBLIC PROCEDURE [pages: CARDINAL] RETURNS [handle: Handle] =    BEGIN    handle _ Heap.systemZone.NEW[HashRegion];    handle^ _ [      hVec: ALL[SymbolHash.nullHash],      zone: Heap.Create[initial: pages, increment: 10],      pages: pages,      head: NIL,      tail: NIL ];    END;    Reset: PUBLIC PROCEDURE [handle: Handle] =    BEGIN    pages: CARDINAL _ handle.pages;    Heap.Delete[handle.zone];    handle^ _ [      hVec: ALL[SymbolHash.nullHash],      zone: Heap.Create[initial: pages, increment: 10],      pages: pages,      head: NIL,      tail: NIL ];    END;    Destroy: PUBLIC PROCEDURE [handle: Handle] =    BEGIN    Heap.Delete[handle.zone];    Heap.systemZone.FREE[@handle];    END;----  EnumerateStrings is never used. (30-Apr-84 11:15:29, AYChen$).--  EnumerateStrings: PUBLIC PROCEDURE [handle: Handle, action: PROCEDURE [LONG STRING]] =    BEGIN    FOR h: Hash _ handle.head, h.next UNTIL h = NIL DO      action[h.string];      ENDLOOP;    END;  EnumerateEntries: PUBLIC PROCEDURE [handle: Handle, action: PROCEDURE [Hash]] =    BEGIN    FOR h: Hash _ handle.head, h.next UNTIL h = NIL DO      action[h];      ENDLOOP;    END;      END....
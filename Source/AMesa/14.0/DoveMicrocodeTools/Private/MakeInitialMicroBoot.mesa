-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved.--				   AYC   , 13-Nov-84 14:05:15 Mesa11.1a -- MakeInitialMicroBoot.mesa,	  JoM    , 31-Oct-84  9:26:14--				Gellerman,  4-Sep-84 12:25:21-- from MakeDoveMicroBoot.mesa, Gellerman, 17-Aug-84 14:59:10-- from MakeDaisyMicroBoot.mesa,   AYC   , 31-May-84 16:05:11-- from MakeDLionMicroBoot.mesa, DEG     , 30-May-83 19:51:07DIRECTORY  ByteBlt USING [ByteBlt],  Checksum USING [ComputeChecksum],  Environment USING [Byte, bytesPerWord],  Exec USING [AddCommand, FreeTokenString, GetToken, Handle, Outcome, OutputProc],  Format USING [CR, Decimal, Line, Number, Text, StringProc],  Heap USING [Create, Delete, systemZone],  Inline USING [BITNOT, BITSHIFT],  MStream USING [EndOf, Error, ReadOnly, ReleaseData, WriteOnly],  Runtime USING [CallDebugger],  Stream USING [Delete, EndOfStream, GetByte, GetPosition, Handle,   		PutBlock, PutWord, SetPosition],  String USING [AppendExtensionIfNeeded, CopyToNewString, Equivalent];MakeInitialMicroBoot: PROGRAM  IMPORTS ByteBlt, Checksum, Exec, Format, Heap, Inline, MStream, Runtime, Stream, String =  BEGIN  Error: ERROR [mess: STRING] = CODE;  InStuff: TYPE = RECORD [    name: LONG STRING ¬ NIL,    switch: LONG STRING ¬ NIL,    sh: Stream.Handle ¬ NIL];  OutStuff: TYPE = RECORD [    name: LONG STRING ¬ NIL,    switch: LONG STRING ¬ NIL,    sh: Stream.Handle ¬ NIL,    files: CARDINAL ¬ 0,  -- count of input files    checksum: WORD ¬ 0,    lengthOfFile: WORD ¬ 0,    typeIsOfDB: BOOLEAN ¬ FALSE,    byteAddress: CARDINAL ¬ 0];  Driver: PROC [h: Exec.Handle, clientData: LONG POINTER] RETURNS [    o: Exec.Outcome ¬ normal] =    BEGIN    out: POINTER TO OutStuff = @outStuff;    outStuff: OutStuff;    tty: Format.StringProc ¬ Exec.OutputProc[h];    BEGIN  -- EXIT block    InitializeOutAndVerifyArrow[      h, out, tty ! Error => {Format.Line[proc: tty, s: mess]; GOTO problem};      UNWIND => ReleaseOut[out]];    IF FALSE THEN Runtime.CallDebugger["Early CallDebugger"L];    ProcessInputFiles[      h, tty, out ! Error => {Format.Line[proc: tty, s: mess]; GOTO problem};      UNWIND => ReleaseOut[out]];    Format.Decimal[proc: tty, n: out.files];    Format.Line[proc: tty, s: " input files"L];    ReleaseOut[out];    EXITS      problem => {ReleaseOut[out]; RETURN[error]};    END;    END;  -- End of Driver  GetNextInFile: PROCEDURE [h: Exec.Handle, in: POINTER TO InStuff]    RETURNS [gotIt: BOOLEAN] =    BEGIN    [in.name, in.switch] ¬ GetNextName[h];    IF in.name = NIL THEN RETURN[FALSE];    [] ¬ String.AppendExtensionIfNeeded[LONG[@in.name], "loc"L, Heap.systemZone];    in.sh ¬ MStream.ReadOnly[name: in.name, release: -- No -- [NIL, NIL]];    RETURN[TRUE];    END;  -- GetNextInFile proc  GetNextName: PROCEDURE [h: Exec.Handle] RETURNS [name, switch: LONG STRING] =    BEGIN    execName, execSwitch: LONG STRING ¬ NIL;    BEGIN    ENABLE      UNWIND => {        [] ¬ Exec.FreeTokenString[execName]; [] ¬ Exec.FreeTokenString[execSwitch]};    [execName, execSwitch] ¬ Exec.GetToken[h];    name ¬ String.CopyToNewString[execName, Heap.systemZone];    switch ¬ String.CopyToNewString[execSwitch, Heap.systemZone];    END;  -- end unwind block    [] ¬ Exec.FreeTokenString[execName];    [] ¬ Exec.FreeTokenString[execSwitch];    END;  -- end GetNextName proc  GetOutFile: PROCEDURE [h: Exec.Handle, out: POINTER TO OutStuff]    RETURNS [gotIt: BOOLEAN] =    BEGIN    [out.name, out.switch] ¬ GetNextName[h];    IF out.name = NIL THEN RETURN[FALSE];    [] ¬ String.AppendExtensionIfNeeded[LONG[@out.name], "db"L, Heap.systemZone];    out.sh ¬ MStream.WriteOnly[      name: out.name, release: [NIL, NIL], type: binary];    RETURN[TRUE];    END;  -- GetOutFile proc  GetTokenDiscardSwitches: PROC [h: Exec.Handle] RETURNS [token: LONG STRING] = {    temp: LONG STRING;    [token, temp] ¬ Exec.GetToken[h];    [] ¬ Exec.FreeTokenString[temp]};  Init: PROC = {Exec.AddCommand[name: "MakeInitialMicroBoot.~"L, proc: Driver]};  InitializeOutAndVerifyArrow: PROCEDURE [    h: Exec.Handle, out: POINTER TO OutStuff, tty: Format.StringProc] =    BEGIN    IF ~GetOutFile[      h, out !      MStream.Error =>        IF code = fileNotAvailable THEN GOTO notAvailable ELSE REJECT] THEN          GOTO badCommand;    IF ~String.Equivalent[GetTokenDiscardSwitches[h], "¬"L] AND       ~String.Equivalent[GetTokenDiscardSwitches[h], "_"L] THEN      GOTO badCommand;    Format.Text[proc: tty, s: "Writing... "L];    Format.Text[proc: tty, s: out.name];    Format.CR[proc: tty];    EXITS      badCommand => Error[" Usage: output ¬ inputList "L];      notAvailable => Error[" Can't aquire output file "L];    END;  -- end of InitOutAndVerifyArrow proc  ProcessBin: PROCEDURE [    in: POINTER TO InStuff, out: POINTER TO OutStuff, tty: Format.StringProc]    RETURNS   [count: CARDINAL ¬ 0] =    BEGIN        NEWbytesSeq: PROC [lgth: CARDINAL] RETURNS [bsp: LONG POINTER TO bytesSeq] = INLINE      BEGIN      bsp ¬ z.NEW[bytesSeq[lgth]];      FOR i: CARDINAL IN [0..lgth) DO        bsp[i] ¬ 0FFH	ENDLOOP      END;        -- The following procedure checks the address of the incoming record    -- to find out if the new address lies within the boundries of the     -- current block.    -- If not, the old block is copied into a new block allocating the    -- necessary space.    -- It then updates the new high and low boundries.      CheckAddressAndCopy: PROCEDURE =      BEGIN      newBytesSeqPtr: LONG POINTER TO bytesSeq;      IF addr < lowAddr THEN	IF bytesSeqPtr = NIL THEN	  BEGIN -- 2nd IF	  bytesSeqPtr ¬ NEWbytesSeq[recLength];	  lowAddr ¬ addr;	  highAddr ¬ addr + recLength;	  END   	ELSE -- 2nd IF   	  BEGIN 	  newBytesSeqPtr ¬ NEWbytesSeq[highAddr - addr];			  [] ¬ ByteBlt.ByteBlt[to:   [LOOPHOLE[newBytesSeqPtr],	  			      lowAddr - addr,				      highAddr - addr],			       from: [LOOPHOLE[bytesSeqPtr],			       	      0,				      highAddr - lowAddr]];	  lowAddr ¬ addr;	  z.FREE[@bytesSeqPtr];	  bytesSeqPtr ¬ newBytesSeqPtr;	  END      ELSE -- 1st IF	IF addr + recLength >= highAddr THEN	  BEGIN 	  newBytesSeqPtr ¬ NEWbytesSeq[addr + recLength - lowAddr];	  [] ¬ ByteBlt.ByteBlt[to:   [LOOPHOLE[newBytesSeqPtr],				      0,				      highAddr - lowAddr],			       from: [LOOPHOLE[bytesSeqPtr],				      0,				      highAddr - lowAddr]];	  highAddr ¬ addr + recLength;	  z.FREE[@bytesSeqPtr];	  bytesSeqPtr ¬ newBytesSeqPtr;	  END;      END; -- CheckAddressAndCopy        -- The following procedure calculates the address from the two bytes    -- which are picked up in reverse order.     -- It then leaves the Stream Position ready to read the data field.        GetAddress: PROCEDURE RETURNS [addr: CARDINAL] =          BEGIN      Stream.SetPosition[sH:dh, position: addrpos];      RETURN [Inline.BITSHIFT[Stream.GetByte[sH:dh], 4] +        Inline.BITSHIFT[Stream.GetByte[sH:dh], 12] + Stream.GetByte[sH:dh]];      END; -- GetAddress		    -- The following recursive procedure calculates the data field of     -- Iterated Data Type records	    ExpandIteratedBlock: PROCEDURE [startIndex: CARDINAL, write: BOOLEAN]     			 RETURNS [CARDINAL] =      BEGIN      bytesLoaded: CARDINAL;      index: CARDINAL ¬ startIndex;      repeatCnt: CARDINAL ¬ Stream.GetByte[sH:dh] +        Inline.BITSHIFT[Stream.GetByte[sH:dh], 8];      blockCnt: CARDINAL ¬ Stream.GetByte[sH:dh] +        Inline.BITSHIFT[Stream.GetByte[sH:dh], 8];      IF blockCnt = 0      THEN THROUGH [0..Stream.GetByte[sH:dh]) DO	   nextByte: Environment.Byte ¬ Stream.GetByte[sH:dh];	   IF write THEN bytesSeqPtr[index] ¬ nextByte;	   index ¬ index + 1;	   ENDLOOP      ELSE THROUGH [0..blockCnt) DO	   index ¬ ExpandIteratedBlock[index, write];	   ENDLOOP;      bytesLoaded ¬ index - startIndex;      THROUGH (1..repeatCnt] DO	IF write THEN 	  FOR i:CARDINAL IN [0..bytesLoaded) DO	    bytesSeqPtr[index+i] ¬ bytesSeqPtr[startIndex+i];	    ENDLOOP;	index ¬ index + bytesLoaded;      ENDLOOP;      RETURN[index];      END; -- ExpandIteratedBlock		    -- Process 186 files here    bytesSeq: TYPE = RECORD [    		     PACKED SEQUENCE COMPUTED CARDINAL OF Environment.Byte];    bytesSeqPtr: LONG POINTER TO bytesSeq ¬ NIL;    z: UNCOUNTED ZONE = Heap.Create[initial: 1]; -- Allow dynamic alloc of space  	    dh: Stream.Handle ¬ in.sh;    addr, recLength, recType: CARDINAL;    addrpos, startpos: LONG CARDINAL;    lowAddr: CARDINAL ¬ LAST[CARDINAL];    highAddr: CARDINAL ¬ 0;    chkSum: CARDINAL ¬ 0;          -- Begin reading each field in the record one at a time    DO    ENABLE {MStream.Error => Error[" -- bad input file ... Command aborted"L];    	    Stream.EndOfStream => 	    Error[" -- bad input file format ... Command aborted"L]};      startpos ¬ Stream.GetPosition[sH:dh];      recType ¬ Stream.GetByte[sH:dh];      recLength ¬ Stream.GetByte[sH:dh] +        Inline.BITSHIFT[Stream.GetByte[sH:dh], 8];      addrpos ¬ Stream.GetPosition[sH:dh];      Stream.SetPosition[sH:dh, position: startpos];      THROUGH [1..recLength + 3] DO        chkSum ¬ chkSum + Stream.GetByte[sH:dh];      ENDLOOP;      IF (chkSum MOD 256) # 0 THEN Error ["Checksum error"L];      SELECT recType FROM      	   8AH => EXIT;	   84H => BEGIN -- conventional type record	            recLength ¬ recLength - 4;	   	    addr ¬ GetAddress[];		    CheckAddressAndCopy[];		       		      		    FOR i: CARDINAL IN [0..recLength) DO        	      bytesSeqPtr[addr - lowAddr + i] ¬ Stream.GetByte[sH:dh];		    ENDLOOP;      		    		  END; -- 84H	   86H => BEGIN -- iterated type record	            addr ¬ GetAddress[];		    recLength ¬ ExpandIteratedBlock[0, FALSE];		    CheckAddressAndCopy[];		    Stream.SetPosition[sH:dh, position: addrpos + 3];		    [] ¬ ExpandIteratedBlock[addr - lowAddr, TRUE];		  END;		               ENDCASE => LOOP;      [] ¬ Stream.GetByte[sH:dh];	-- skip chkSum byte    ENDLOOP; -- original DO    IF NOT MStream.EndOf[stream: dh] THEN      Error[" Extra garbage at end of loc file"L];    WriteToBoot[out, bytesSeqPtr, (highAddr - lowAddr + 1)/2];    Heap.Delete[z:z];    END; -- ProcessBin       ProcessInputFiles: PROCEDURE [    h: Exec.Handle, tty: Format.StringProc, out: POINTER TO OutStuff] =    BEGIN    fileSize: CARDINAL;    in: POINTER TO InStuff = @inStuff;    inStuff: InStuff;    IF ~GetNextInFile[      h, in !      MStream.Error =>        IF code = fileNotAvailable THEN {ReleaseIn[in]; GOTO notAvailable}        ELSE REJECT; UNWIND => ReleaseIn[in]] THEN GOTO notAvailable;    BEGIN    ENABLE UNWIND => ReleaseIn[in];    Format.Text[proc: tty, s: "Reading... "L];    Format.Text[proc: tty, s: in.name];           fileSize ¬ ProcessBin[in, out, tty];    END;  -- end of ReleaseIn[in] UNWIND block    ReleaseIn[in];    Format.Text[tty, "  ("L];    Format.Decimal[tty, fileSize];    Format.Line[tty, ")"L];           EXITS      notAvailable => Error[" Can't acquire input file "L];    END;  -- End of ProcessInputFiles procedure  ReleaseIn: PROCEDURE [in: POINTER TO InStuff] =    BEGIN    Heap.systemZone.FREE[@in.name];         -- also sets in.name ¬ NIL    IF in.sh # NIL THEN {Stream.Delete[in.sh]; in.sh ¬ NIL};    END;  -- end ReleaseIn proc  ReleaseOut: PROCEDURE [out: POINTER TO OutStuff] =    BEGIN    Heap.systemZone.FREE[@out.name];         -- also sets out.name ¬ NIL    IF out.sh # NIL THEN {Stream.Delete[out.sh]; out.sh ¬ NIL};    END;  -- end ReleaseOut proc      WriteToBoot: PROCEDURE [    out: POINTER TO OutStuff, p: LONG POINTER, c: CARDINAL] =    BEGIN    cs: WORD;    Stream.PutBlock[      sH: out.sh,      block: [blockPointer: p, startIndex: 0,              stopIndexPlusOne: Environment.bytesPerWord*c],      endRecord: FALSE];    cs ¬ Checksum.ComputeChecksum[      nWords: c,      p: p];    Stream.PutWord[      sH: out.sh,      word: Inline.BITNOT[cs]];    END;  --main line code  Init[];  END...
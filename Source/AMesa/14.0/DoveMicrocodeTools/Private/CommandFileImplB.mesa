-- File: CommandFileImplB.mesa - last edit:-- Bowers.PA           30-Sep-86 13:26:34-- RDH            4-Feb-86 12:03:07-- Copyright (C) 1984, 1985, 1986 by Xerox Corporation. All rights reserved. DIRECTORY  Ascii USING [CR],  Format USING [CR, Line, StringProc, Text],  Inline USING [LowHalf],  MStream USING [GetLength, WriteOnly],  ProcessorFace USING [SetMP],  Process,  Runtime USING [UnboundProcedure],  Stream USING [Delete, Handle, Position, PutChar, PutString, SetPosition],  String USING [AppendString, CopyToNewString, Equivalent, SubString,    SubStringDescriptor],  Time USING [AppendCurrent],  CommandFile USING [AbortProc],  CommandFileOps,  CPCommand USING [AutoPollCP, Boot, Break, CopyPanel, Compare, Continue,    ContinueAndWait, Load, LoadBootFile, LoadGerm, LoadRaw, LoadReal, LoadSymbols,    PollCP, PopIB, Reset, SetBank, Start, StartAndWait, Stop, Unbreak],  CPPanel USING [Clear, GetPanel],<<	not in version one, ( 2-Jul-84 14:00:10, AYChen$)  HBCommand USING [Arm, Error],>>  IOPB,  IOPBCommand USING [    Boot, Break, CleanUp, Continue, ContinueAndWait, CopyPanel, DisplayNewState,    Initialize, Load, ReadIOCommand,    SetAddressType, SetDataType, SetNewState, Step, Stop, Unbreak, WriteIOCommand],  IOPBPanel USING [Clear, GetPanel, Initialize],  PanelSW USING [    ClientError, Handle, ModifyLH, nilTileIndex, ReadTile, TileError, TileIndex,    TileIndexFromRowColumn, WriteTile],  StringExtras USING [    CheckHexString, CheckLongHexString, InvalidHexString, TrimString],  SymbolHash USING [    Create, GetInfo, GetString, Handle, Hash, Insert, Lookup, nullHash, PutInfo];CommandFileImplB: PROGRAM  IMPORTS    Format, Inline, MStream, StringExtras, Process, ProcessorFace, Runtime, Stream, String,    Time, CommandFileOps, CPCommand, CPPanel, --HBCommand,-- IOPBCommand,    IOPBPanel, PanelSW, SymbolHash  EXPORTS CommandFileOps =  {  OPEN CommandFileOps;  -- Miscellaneous PROCEDURES  AssignmentLost: PROCEDURE = BEGIN ERROR Trouble["Assignment lost"L]; END;  EvaluateSymbolicInt: PROCEDURE [s: LONG STRING] RETURNS [v: LONG INTEGER] = {    h: SymbolHash.Hash;    sv: LONG POINTER TO Loc CommandFileOps.SymbolValue;    t: LONG STRING;    h ¬ SymbolHash.Lookup[cd.symbols, s];    IF h = SymbolHash.nullHash THEN ERROR Trouble["Undefined symbol"L];    sv ¬ SymbolHash.GetInfo[cd.symbols, h];    IF sv.type # Loc THEN MustBeLocation[];    SELECT sv.panel FROM      CP => t ¬ EvaluateTile[cd.cpHandle, sv.x, sv.y];      IOP => t ¬ EvaluateTile[cd.iopPanel, sv.x, sv.y];      PC => t ¬ EvaluateTile[cd.pcPanel, sv.x, sv.y];      ENDCASE;    v ¬ StringExtras.CheckLongHexString[      t !      StringExtras.InvalidHexString => ERROR Trouble["Can't parse that string"L]];    };  EvaluateSymbolicString: PROCEDURE [s: LONG STRING] RETURNS [t: LONG STRING] = {    h: SymbolHash.Hash;    sv: LONG POINTER TO Loc CommandFileOps.SymbolValue;    h ¬ SymbolHash.Lookup[cd.symbols, s];    IF h = SymbolHash.nullHash THEN ERROR Trouble["Undefined symbol"L];    sv ¬ SymbolHash.GetInfo[cd.symbols, h];    IF sv.type # Loc THEN MustBeLocation[];    SELECT sv.panel FROM      CP => t ¬ EvaluateTile[cd.cpHandle, sv.x, sv.y];      IOP => t ¬ EvaluateTile[cd.iopPanel, sv.x, sv.y];      PC => t ¬ EvaluateTile[cd.pcPanel, sv.x, sv.y];      ENDCASE;    };  GetCardinal: PROCEDURE RETURNS [short: CARDINAL] = {    number: LONG POINTER TO CommandFileOps.StackCell ¬ Pop[];    short ¬ StringExtras.CheckHexString[      number.p ! StringExtras.InvalidHexString => NumberExpected[]];    FreeStackCell[number];    };  GetLongCardinal: PROCEDURE RETURNS [long: LONG CARDINAL] = {    number: LONG POINTER TO CommandFileOps.StackCell ¬ Pop[];    long ¬ StringExtras.CheckLongHexString[      number.p ! StringExtras.InvalidHexString => NumberExpected[]];    FreeStackCell[number];    };  GetParameters: PUBLIC PROCEDURE RETURNS [n: CARDINAL] = {    n ¬ 0;    DO      ReadPhrase[];      SELECT cd.lastBreak FROM        closeBracket => {n ¬ n + ParseList[TRUE]; EXIT};        quote => {n ¬ n + 1 + ParseList[FALSE]; DoQuote; PushString[s: cd.sc]};        ENDCASE => ERROR Trouble["Illegal parameter"L];      ENDLOOP};  LogCR: PROCEDURE = {    IF cd.output = NIL THEN Format.CR[cd.log, cd.arg]    ELSE Stream.PutChar[cd.output, Ascii.CR];    };  LogString: PROCEDURE [s: LONG STRING] = {    IF cd.output = NIL THEN Format.Text[cd.log, s, cd.arg]    ELSE Stream.PutString[cd.output, s];    };  NumberExpected: PROCEDURE = {ERROR Trouble["Number Expected"L]; };  ParseList: PROCEDURE [end: BOOLEAN] RETURNS [n: CARDINAL] = {    --This routine still has problems.  Things which won't work include:    --[ ] and [x ]    n ¬ 0;    DO      [] ¬ NextID[];      IF cd.token.length = 0 THEN        IF n = 0 THEN --null list is okay-- RETURN        ELSE ERROR Trouble["Unexpected end of list"L];      IF IDBreaks[cd.token.base[cd.token.offset]] THEN {        IF end THEN ERROR Trouble["Null ID in list"L] ELSE EXIT};      PushString[s: StringFromSubString[cd.token]];      n ¬ n + 1;      IF cd.rest.length = 0 THEN {        IF ~end THEN ERROR Trouble["Last element null"L] ELSE RETURN}      ELSE        IF cd.rest.base[cd.rest.offset] # ', THEN          ERROR Trouble["Comma must separate list elements"L];      [] ¬ NextID[]  --skip over the break--      ENDLOOP};  WrongNumberArguments: PROCEDURE = {    ERROR Trouble["Wrong number of arguments"L]; };  -- PANELSW PROCEDURES     EvaluateTile: PROCEDURE [h: PanelSW.Handle, x, y: CARDINAL]    RETURNS [s: LONG STRING] = {    ti: PanelSW.TileIndex = PanelSW.TileIndexFromRowColumn[h, x, y];    IF ti = PanelSW.nilTileIndex THEN      ERROR Trouble["No Tile there => Window Reset?"L];    s ¬ PanelSW.ReadTile[      h, [right, ti] ! PanelSW.TileError => ERROR Trouble["Can't do that"L];      PanelSW.ClientError => ERROR Trouble[msg]];    };  VisibleTile: PUBLIC PROCEDURE [h: PanelSW.Handle, x, y: CARDINAL] RETURNS [BOOLEAN] = {    ti: PanelSW.TileIndex = PanelSW.TileIndexFromRowColumn[h, x, y];    RETURN[ti # PanelSW.nilTileIndex]};  HandleForPanel: PROCEDURE [p: CommandFileOps.Panel] RETURNS [PanelSW.Handle] =    INLINE {    RETURN[      SELECT p FROM         IOP => cd.iopPanel, 	CP => cd.cpHandle, 	PC => cd.pcPanel, 	ENDCASE => ERROR]};  DecodeLoc: PROCEDURE [    stack: LONG POINTER TO CommandFileOps.StackCell, pop: BOOLEAN]    RETURNS [h: PanelSW.Handle, ti: PanelSW.TileIndex] = {    sv: LONG POINTER TO Loc CommandFileOps.SymbolValue;    SELECT stack.type FROM      String, StringConstant => {        h: SymbolHash.Hash;        h ¬ SymbolHash.Lookup[cd.symbols, stack.p];        IF h = SymbolHash.nullHash THEN ERROR Trouble["Undefined symbol"L];        sv ¬ SymbolHash.GetInfo[cd.symbols, h];        IF sv.type # Loc THEN MustBeLocation[];        };      Loc => sv ¬ stack.p;      ENDCASE => MustBeLocation[];    h ¬ HandleForPanel[sv.panel];    ti ¬ PanelSW.TileIndexFromRowColumn[h, sv.x, sv.y];    IF ti = PanelSW.nilTileIndex THEN ERROR Trouble["Invisible tile"L];    IF pop THEN RetireTop[];    };  --EvaluateLoc does NextID checks for hex constant or location id.  IF a  --location ID then attempts to read it.  Gives an Error on the slightest  --provocation  EvaluateLoc: PUBLIC PROCEDURE RETURNS [v: LONG INTEGER] = {    s: LONG STRING;    IF ~NextID[] THEN GarbagedConditional[];    s ¬ StringFromSubString[cd.token];    v ¬ StringExtras.CheckLongHexString[      s !      StringExtras.InvalidHexString => {v ¬ EvaluateSymbolicInt[s]; CONTINUE}];    heap.FREE[@s];    };  DisplayContents: PUBLIC PROCEDURE [    target, value: LONG POINTER TO CommandFileOps.StackCell] = {    ti: PanelSW.TileIndex;    h: PanelSW.Handle;    IF ~(value.type = String OR value.type = StringConstant) THEN      ERROR Trouble["Only strings and constants here"L];    [h, ti] ¬ DecodeLoc[target, FALSE];    [] ¬ StringExtras.TrimString[value.p];    PanelSW.WriteTile[      h, [left, ti], value.p, FALSE ! PanelSW.TileError => AssignmentLost[];      PanelSW.ClientError => ERROR Trouble[msg]];    };  --these are different when string variables come along--  WriteContents, Assign: PUBLIC PROCEDURE [    target, value: LONG POINTER TO CommandFileOps.StackCell] = {    h: PanelSW.Handle;    ti: PanelSW.TileIndex;    SELECT target.type FROM      StringConstant => {        s: LONG STRING = LOOPHOLE[target.p];        id: String.SubString ¬ cd.token;        tail: String.SubString ¬ cd.rest;        sv: LONG POINTER TO CommandFileOps.SymbolValue;        old: BOOLEAN;        idD: String.SubStringDescriptor;        tailD: String.SubStringDescriptor ¬ [s, 0, s.length];        cd.token ¬ @idD;        cd.rest ¬ @tailD;        IF ~NextID[] THEN ERROR Trouble["Garbage before back arrow"L];        [old, , sv] ¬ LookupSubString[cd.token, FALSE];        IF ~old THEN ERROR Trouble["Undefined location"L];        heap.FREE[@target­.p];  --before overwriting target­--        WITH sv SELECT FROM          Loc => target­ ¬ [Loc, sv, 0, target.previous];          ENDCASE => MustBeLocation[];        cd.token ¬ id;        cd.rest ¬ tail};      Loc => NULL;      ENDCASE => MustBeLocation[];    [h, ti] ¬ DecodeLoc[target, FALSE];    IF ~(value.type = String OR value.type = StringConstant) THEN      ERROR Trouble["Only strings and constants here"L];    IF value.type = StringConstant THEN [] ¬ StringExtras.TrimString[value.p];    PanelSW.WriteTile[      h, [right, ti], value.p, FALSE ! PanelSW.TileError => AssignmentLost[];      PanelSW.ClientError => ERROR Trouble[msg]];    };  -- CALLS TO CPBERMUDA AND IOPBERMUDA      AlterAddress: PROCEDURE = {    suffix: LONG POINTER TO CommandFileOps.StackCell;    ti: PanelSW.TileIndex;    h: PanelSW.Handle;    IF GetParameters[] # 2 THEN WrongNumberArguments[];    IF (suffix ¬ Pop[]).type # StringConstant THEN      ERROR Trouble["Must be string constant"L];    [h, ti] ¬ DecodeLoc[cd.stack, TRUE];    PanelSW.ModifyLH[      h, [left, ti], suffix.p !      PanelSW.TileError => ERROR Trouble["Can't do that"L];      PanelSW.ClientError => ERROR Trouble[msg]];    FreeStackCell[suffix]};<<--	not in version one,  (2-Jul-84 13:59:01, AYChen$)    Arm: PROCEDURE =      {      IF GetParameters[] # 1 THEN WrongNumberArguments[];      HBCommand.Arm[cd.log, cd.arg, cd.stack.p, 100];      RetireTop[];      };>>  AutoPollSirius: PROCEDURE = {    IF GetParameters[] # 0 THEN WrongNumberArguments[];    CPCommand.AutoPollCP[cd.log, cd.arg];    };  Boot: PROCEDURE = {    IF GetParameters[] # 0 THEN WrongNumberArguments[];    CPCommand.Boot[cd.log, cd.arg];    };  BootIOP: PROCEDURE = {    IF GetParameters[] # 0 THEN WrongNumberArguments[];    IOPBCommand.Boot[log: cd.arg];    IOPBCommand.DisplayNewState[iop];    };  Break: PROCEDURE = {    IF GetParameters[] # 1 THEN WrongNumberArguments[];    CPCommand.Break[cd.log, cd.arg, cd.stack.p];    RetireTop[];    };  BreakIOPB: PROCEDURE [processor: IOPB.Processor] = {    IF GetParameters[] # 1 THEN WrongNumberArguments[];    IOPBCommand.Break[log: cd.arg, s: cd.stack.p, processor: processor];    RetireTop[];    };    BreakIOP: PROCEDURE = {BreakIOPB[processor: iop]};      BreakPC: PROC = {BreakIOPB[processor: pc]};  ClearCPPanel: PROCEDURE = {    IF GetParameters[] # 0 THEN WrongNumberArguments[]; CPPanel.Clear[]};  ClearIOPPanel: PROCEDURE = {    IF GetParameters[] # 0 THEN WrongNumberArguments[]; IOPBPanel.Clear[iop]};      ClearPCPanel: PROC = {    IF GetParameters[] # 0 THEN WrongNumberArguments[]; IOPBPanel.Clear[pc]};  CloseLog: PROCEDURE = {    IF GetParameters[] # 0 THEN WrongNumberArguments[];    IF cd.output # NIL THEN Stream.Delete[cd.output];    cd.output ¬ NIL    };  Compare: PROCEDURE = {    IF GetParameters[] # 1 THEN WrongNumberArguments[];    CPCommand.Compare[cd.log, cd.arg, cd.stack.p];    RetireTop[];    };  Continue: PROCEDURE = {    SELECT GetParameters[] FROM      0 => CPCommand.Continue[cd.log, cd.arg];      1 => {	ms: LONG CARDINAL = GetLongCardinal[];	CPCommand.ContinueAndWait[cd.log, cd.arg, cd.abort, ms]};      ENDCASE => WrongNumberArguments[];    };  ContinueIOP: PROCEDURE = {    SELECT GetParameters[] FROM      0 => {	IOPBCommand.Continue[log: cd.arg];	IOPBCommand.SetNewState[running]};      1 => {	ms: LONG CARDINAL = GetLongCardinal[];	IOPBCommand.ContinueAndWait[cd.arg, cd.abort, ms];	Process.Pause[Process.MsecToTicks[4000]]};      ENDCASE => WrongNumberArguments[];    };  CopyPanel: PROCEDURE = {    IF GetParameters[] # 0 THEN WrongNumberArguments[];    CPCommand.CopyPanel[cd.log, cd.arg];    };      CopyIOPPanel: PROCEDURE = {    IF GetParameters[] # 0 THEN WrongNumberArguments[];    IOPBCommand.CopyPanel[iop];     };      CopyPCPanel: PROC = {    IF GetParameters[] # 0 THEN WrongNumberArguments[];    IOPBCommand.CopyPanel[pc];    };  GoTo: PROCEDURE =    {    target: Stream.Position ¬ 0;      GotLabel: PROCEDURE [s: LONG STRING] RETURNS [old: BOOLEAN] =        {        h: SymbolHash.Hash;        h ¬ SymbolHash.Lookup[cd.symbols, s];        old ¬ h # SymbolHash.nullHash;        IF old THEN          {          sv: LONG POINTER TO CommandFileOps.SymbolValue ¬ SymbolHash.GetInfo[cd.symbols, h];          WITH sv SELECT FROM            Tag => target ¬ si;            ENDCASE => ERROR Trouble["Illegal target"L];          }        };      IF GetParameters[] # 1 THEN WrongNumberArguments[];      IF GotLabel[cd.stack.p] THEN        { RetireTop[]; Stream.SetPosition[cd.stream, target]; RETURN; };      DO        ReadPhrase[];        SELECT cd.lastBreak FROM          comment, quote => cd.breaks[cd.lastBreak].r;          colon => { cd.breaks[cd.lastBreak].r; IF GotLabel[cd.stack.p] THEN EXIT };          ENDCASE        ENDLOOP;      RetireTop[];      };              ResetLoad: PROCEDURE = {    bank: CARDINAL;    SELECT GetParameters[] FROM      1 => bank ¬ 0;      2 => bank ¬ GetCardinal[];      ENDCASE => WrongNumberArguments[];    CPCommand.Reset[cd.log, cd.arg];    CPCommand.Load[cd.log, cd.arg, cd.stack.p, bank];    CPCommand.LoadSymbols[cd.log, cd.arg, cd.stack.p, bank];    RetireTop[];    };  LoadBoot: PROCEDURE =      {      SELECT GetParameters[] FROM        1 => CPCommand.LoadBootFile[cd.log, cd.arg, cd.stack.p, 0];        2 =>          {          pagesOrbanks: CARDINAL ¬ GetCardinal[];          CPCommand.LoadBootFile[cd.log, cd.arg, cd.stack.p, pagesOrbanks];          };        ENDCASE => WrongNumberArguments[];      RetireTop[];      };  InitIOPPanel: PROCEDURE = {    IF GetParameters[] # 0 THEN WrongNumberArguments[];    IOPBPanel.Initialize[iop]};      InitPCPanel: PROC = {    IF GetParameters[] # 0 THEN WrongNumberArguments[]; IOPBPanel.Initialize[pc]};  Load: PROCEDURE = {    bank: CARDINAL;    SELECT GetParameters[] FROM      1 => bank ¬ 0;      2 => bank ¬ GetCardinal[];      ENDCASE => WrongNumberArguments[];    CPCommand.Load[cd.log, cd.arg, cd.stack.p, bank];    CPCommand.LoadSymbols[cd.log, cd.arg, cd.stack.p, bank];    RetireTop[];    };  LoadNoSymbols: PROCEDURE = {    bank: CARDINAL;    SELECT GetParameters[] FROM      1 => bank ¬ 0;      2 => bank ¬ GetCardinal[];      ENDCASE => WrongNumberArguments[];--  CPCommand.Reset[cd.log, cd.arg];    CPCommand.Load[cd.log, cd.arg, cd.stack.p, bank];    RetireTop[];    };  LoadIOP: PROCEDURE = {    IF GetParameters[] # 1 THEN WrongNumberArguments[];    IOPBCommand.Load[      log: cd.arg, fileName: cd.stack.p, symbols: TRUE, code: TRUE,       processor: iop, abort: cd.abort];    RetireTop[];    };      LoadPC: PROC = {IF GetParameters[] # 1 THEN WrongNumberArguments[];    IOPBCommand.Load[      log: cd.arg, fileName: cd.stack.p, symbols: TRUE, code: TRUE,      processor: pc, abort: cd.abort];    RetireTop[];    };  LoadIOPCodeOnly: PROCEDURE = {    IF GetParameters[] # 1 THEN WrongNumberArguments[];    IOPBCommand.Load[      log: cd.arg, fileName: cd.stack.p, symbols: FALSE, code: TRUE,       processor: iop, abort: cd.abort];    RetireTop[];    };      LoadPCCodeOnly: PROCEDURE = {    IF GetParameters[] # 1 THEN WrongNumberArguments[];    IOPBCommand.Load[      log: cd.arg, fileName: cd.stack.p, symbols: FALSE, code: TRUE,       processor: pc, abort: cd.abort];    RetireTop[];    };      LoadIOPSymbols: PROCEDURE = {    IF GetParameters[] # 1 THEN WrongNumberArguments[];    IOPBCommand.Load[      log: cd.arg, fileName: cd.stack.p, symbols: TRUE, code: FALSE,       processor: iop, abort: cd.abort];    RetireTop[];    };       LoadPCSymbols: PROCEDURE = {    IF GetParameters[] # 1 THEN WrongNumberArguments[];    IOPBCommand.Load[      log: cd.arg, fileName: cd.stack.p, symbols: TRUE, code: FALSE,       processor: pc, abort: cd.abort];    RetireTop[];    };          LoadGerm: PROCEDURE =      {      IF GetParameters[] # 1 THEN WrongNumberArguments[];      CPCommand.LoadGerm[cd.log, cd.arg, cd.stack.p];      RetireTop[];  };  LoadReal: PROCEDURE = {    IF GetParameters[] # 1 THEN WrongNumberArguments[];    CPCommand.LoadReal[cd.log, cd.arg, cd.stack.p];    RetireTop[];    };      LoadRaw: PROCEDURE = {    bank: CARDINAL;    SELECT GetParameters[] FROM      1 => bank ¬ 0;      2 => bank ¬ GetCardinal[];      ENDCASE => WrongNumberArguments[];    CPCommand.LoadRaw[cd.log, cd.arg, cd.stack.p, bank];    CPCommand.LoadSymbols[cd.log, cd.arg, cd.stack.p, bank];    RetireTop[];    };  LoadSymbols: PROCEDURE = {    bank: CARDINAL;    SELECT GetParameters[] FROM      1 => bank ¬ 0;      2 => bank ¬ GetCardinal[];      ENDCASE => WrongNumberArguments[];    CPCommand.LoadSymbols[cd.log, cd.arg, cd.stack.p, bank];    RetireTop[];    };  OpenToAppend: PROCEDURE = {    OpenToWrite[]; Stream.SetPosition[cd.output, MStream.GetLength[cd.output]]; };  OpenToWrite: PROCEDURE = {    IF GetParameters[] # 1 THEN WrongNumberArguments[];    IF cd.output # NIL THEN {Stream.Delete[cd.output]; cd.output ¬ NIL; };    cd.output ¬ MStream.WriteOnly[cd.stack.p, [], text];    --        MStream.Error => ERROR Trouble["Can't open output file"L] ];    RetireTop[];    };  PollSirius: PROCEDURE = {    IF GetParameters[] # 0 THEN WrongNumberArguments[];    [] ¬ CPCommand.PollCP[cd.log, cd.arg, TRUE];    };  PopIB: PROCEDURE = {    IF GetParameters[] # 0 THEN WrongNumberArguments[];    [] ¬ CPCommand.PopIB[cd.log, cd.arg];    };      ReadIO: PROCEDURE = {    data: CARDINAL ¬ 0;    IF GetParameters[] # 1 THEN WrongNumberArguments[];    [] ¬ IOPBCommand.ReadIOCommand[port: GetCardinal[]];    RetireTop[];    };  Reset: PROCEDURE = {    IF GetParameters[] # 0 THEN WrongNumberArguments[];    CPCommand.Reset[cd.log, cd.arg];    RetireTop[];    };          ResetIOPSymbols: PROCEDURE = {    IF GetParameters[] # 0 THEN WrongNumberArguments[];    IOPBCommand.CleanUp[iop];    IOPBCommand.Initialize[iop];    };      ResetPCSymbols: PROCEDURE = {    IF GetParameters[] # 0 THEN WrongNumberArguments[];    IOPBCommand.CleanUp[pc];    IOPBCommand.Initialize[pc];    };      SetBank: PROCEDURE = {    IF GetParameters[] # 1 THEN WrongNumberArguments[];    CPCommand.SetBank[cd.log, cd.arg, cd.stack.p];    RetireTop[];    };      SetIOPAddressType: PROC = {SetAddressType[iop]};    SetPCAddressType: PROC = {SetAddressType[pc]};    SetAddressType: PROC [processor: IOPB.Processor] = {    IF GetParameters[] # 1 THEN WrongNumberArguments[];    SELECT TRUE FROM      String.Equivalent["iop", cd.stack.p] =>         IOPBCommand.SetAddressType[processor, iop];      String.Equivalent["pc", cd.stack.p] =>         IOPBCommand.SetAddressType[processor, pc];      String.Equivalent["real", cd.stack.p] =>         IOPBCommand.SetAddressType[processor, real];      String.Equivalent["vm", cd.stack.p] =>         IOPBCommand.SetAddressType[processor, vm];      ENDCASE => ERROR Trouble["Invalid Address Type"L];    RetireTop[];  };      SetPCDataType: PROC = {    IF GetParameters[] # 1 THEN WrongNumberArguments[];    SELECT TRUE FROM      String.Equivalent["byte", cd.stack.p] => IOPBCommand.SetDataType[byte, pc];      String.Equivalent["word", cd.stack.p] => IOPBCommand.SetDataType[word, pc];      ENDCASE => ERROR Trouble["Invalid Data Type"L];    RetireTop[];    };  SetDataType: PROCEDURE = {    IF GetParameters[] # 1 THEN WrongNumberArguments[];    SELECT TRUE FROM      String.Equivalent["byte", cd.stack.p] => IOPBCommand.SetDataType[byte, iop];      String.Equivalent["word", cd.stack.p] => IOPBCommand.SetDataType[word, iop];      ENDCASE => ERROR Trouble["Invalid Data Type"L];    RetireTop[];    };  SetMP: PROCEDURE = {    IF GetParameters[] # 1 THEN WrongNumberArguments[];    ProcessorFace.SetMP[Inline.LowHalf[EvaluateSymbolicInt[cd.stack.p]]];    RetireTop[];    };  Start: PROCEDURE = {    SELECT GetParameters[] FROM      2 => {        arg1ptr: LONG POINTER TO CommandFileOps.StackCell ¬ Pop[]; -- side effect	arg0ptr: LONG POINTER TO CommandFileOps.StackCell ¬ cd.stack;        CPCommand.Start[cd.log, cd.arg, arg0ptr.p, arg1ptr.p];	FreeStackCell[arg1ptr];       };      3 => {        ms: LONG CARDINAL = GetLongCardinal[];	arg1ptr: LONG POINTER TO CommandFileOps.StackCell ¬ Pop[];        CPCommand.StartAndWait[cd.log, cd.arg, cd.stack.p, arg1ptr.p, cd.abort, ms];  	FreeStackCell[arg1ptr];        };      ENDCASE => WrongNumberArguments[];    RetireTop[];    };<<	not in version one,  2-Jul-84 13:59:01, AYChen$    StartIOP: PROCEDURE =      {      SELECT GetParameters[] FROM        1 =>	  {	  IOPBCommand.SetPC[cd.log, cd.arg, cd.stack.p];	  IOPBCommand.Continue[cd.log, cd.arg];	  };        2 =>          {	  ms: LONG CARDINAL = GetLongCardinal[];	  IOPBCommand.SetPC[cd.log, cd.arg, cd.stack.p]; CONTINUE};];	  IOPBCommand.ContinueAndWait[cd.log, cd.arg, cd.abort, ms];          };        ENDCASE => WrongNumberArguments[];      RetireTop[];      };>>  StepIOP: PROCEDURE = {    IF GetParameters[] # 0 THEN WrongNumberArguments[];    IOPBCommand.Step[log: cd.arg, processor: iop];    };  Stop: PROCEDURE = {    IF GetParameters[] # 0 THEN WrongNumberArguments[];    CPCommand.Stop[cd.log, cd.arg];    };  StopIOP: PROCEDURE = {    IF GetParameters[] # 0 THEN WrongNumberArguments[];    IOPBCommand.Stop[log: cd.arg, processor: iop];    Process.Pause[Process.MsecToTicks[4000]];    };      StopPC: PROCEDURE = {    IF GetParameters[] # 0 THEN WrongNumberArguments[];    IOPBCommand.Stop[log: cd.arg, processor: pc];    Process.Pause[Process.MsecToTicks[4000]];    };  Unbreak: PROCEDURE = {    IF GetParameters[] # 1 THEN WrongNumberArguments[];    CPCommand.Unbreak[cd.log, cd.arg, cd.stack.p];    RetireTop[];    };  UnbreakIOP: PROCEDURE = {    IF GetParameters[] # 1 THEN WrongNumberArguments[];    IOPBCommand.Unbreak[log: cd.arg, s: cd.stack.p, processor: iop];    RetireTop[];    };      UnbreakPC: PROCEDURE = {    IF GetParameters[] # 1 THEN WrongNumberArguments[];    IOPBCommand.Unbreak[log: cd.arg, s: cd.stack.p, processor: pc];    RetireTop[];    };      Wait: PROCEDURE = {    ms: LONG CARDINAL;    IF GetParameters[] # 1 THEN WrongNumberArguments[];    ms ¬ GetLongCardinal[];    Process.Pause[Process.MsecToTicks[Inline.LowHalf[ms]]];    };  Write: PROCEDURE = {    SELECT GetParameters[] FROM      0 => NULL;      1 => {LogString[cd.stack.p]; RetireTop[]; };      ENDCASE => WrongNumberArguments[];    };  WriteIO: PROCEDURE = {    data: CARDINAL ¬ 0;    IF GetParameters[] # 2 THEN WrongNumberArguments[];    data ¬ GetCardinal[];    IOPBCommand.WriteIOCommand[port: GetCardinal[], iOData: data];    RetireTop[];    };  WriteLine: PROCEDURE = {Write[]; LogCR[]; };  WriteLoc: PROCEDURE = {    temp: LONG STRING ¬ [50];    SELECT GetParameters[] FROM      1 => String.AppendString[temp, EvaluateSymbolicString[cd.stack.p]];      2 => {        space: LONG STRING = " "L;        width: CARDINAL = GetCardinal[];        String.AppendString[temp, EvaluateSymbolicString[cd.stack.p]];        FOR i: CARDINAL IN [temp.length..width) DO LogString[space]; ENDLOOP;        };      ENDCASE => WrongNumberArguments[];    LogString[temp];    RetireTop[];    };  WriteTime: PROCEDURE = {    s: LONG STRING ¬ [32];    IF GetParameters[] # 0 THEN WrongNumberArguments[];    Time.AppendCurrent[s];    LogString[s]};  NotInThisVersion: PROCEDURE = {    Format.Text[cd.log, "Command not implemented in current version"L, cd.arg];    Format.Line[cd.log, "...Continuiing"L, cd.arg];    };  CreateStructures: PUBLIC PROCEDURE = {    cd ¬ heap.NEW[CommandFileOps.Data ¬ []];    cd.symbols ¬ SymbolHash.Create[10];    cd.in ¬ heap.NEW[StringBody [64]];    cd.sc ¬ heap.NEW[StringBody [32]];    cd.cpHandle ¬ CPPanel.GetPanel[ ! Runtime.UnboundProcedure => CONTINUE];    cd.iopPanel ¬ IOPBPanel.GetPanel[iop ! Runtime.UnboundProcedure => CONTINUE];    cd.pcPanel ¬ IOPBPanel.GetPanel[pc ! Runtime.UnboundProcedure => CONTINUE];    cd.token ¬ @cd.tssd;    cd.rest ¬ @cd.rssd;    cd.keys ¬ heap.NEW[KeyArray];    InitKeys[];    InitKeyStrings[];    InitBreaks[];    cd.relations ¬ heap.NEW[RelationArray];    cd.relations­ ¬      --     <   =  #  >  {       --      [      --<-- [x, le, x, x, lt],      --=-- [le, x, x, ge, eq],      --#-- [x, x, x, x, ne],      -->-- [x, ge, x, x, gt],      --{-- [x, x, x, x, x]];    FOR i: CommandFileOps.KeyDomain IN CommandFileOps.KeyDomain DO      h: SymbolHash.Hash ¬ SymbolHash.Insert[cd.symbols, cd.keys[i].s];      sv: LONG POINTER TO CommandFileOps.SymbolValue ¬ heap.NEW[        CommandFileOps.SymbolValue];      SELECT cd.keys[i].t FROM        Null => sv­ ¬ [Null[]];        Break => sv­ ¬ [Break[]];        String => sv­ ¬ [String[heap.NEW[StringBody [32]]]];        Loc =>          sv­ ¬ [Loc[PanelFromName[SymbolHash.GetString[cd.symbols, h]], 0, 0]];        Function => sv­ ¬ [Function[cd.keys[i].function]];        ENDCASE => ERROR;      SymbolHash.PutInfo[cd.symbols, h, sv]      ENDLOOP;    };  InitKeys: PROCEDURE =  {    cd.keys­ ¬ [      alterAddress: [, Function, AlterAddress],      arm: [, Function, --Arm-- NotInThisVersion],      autopollsirius: [, Function, AutoPollSirius],      boot: [, Function, Boot],      bootIOP: [, Function, BootIOP],      break: [, Function, Break],      breakIOP: [, Function, BreakIOP],      breakPC: [, Function, BreakPC],      buffer: [, String],      clearCPPanel: [, Function, ClearCPPanel],      clearIOPPanel: [, Function, ClearIOPPanel],      clearPCPanel: [, Function, ClearPCPanel],      close: [, Function, CloseLog],      compare: [, Function, Compare],      continue: [, Function, Continue],      continueIOP: [, Function, ContinueIOP],      cp: [, Loc],      copyIOPPanel: [, Function, CopyIOPPanel],      copyPCPanel: [, Function, CopyPCPanel],      copypanel: [, Function, CopyPanel],      goTo: [, Function, GoTo],      if: [, Break],      iop: [, Loc],      initIOPPanel: [, Function, InitIOPPanel],      initPCPanel: [, Function, InitPCPanel],      load: [, Function, ResetLoad],      loadBoot: [, Function, LoadBoot],      loadMore: [, Function, Load],      loadNoSymbols: [, Function, LoadNoSymbols],      loadIOP: [, Function, LoadIOP],      loadIOPCodeOnly: [, Function, LoadIOPCodeOnly],      loadIOPSymbols: [, Function, LoadIOPSymbols],      loadPC: [, Function, LoadPC],      loadPCCodeOnly: [, Function, LoadPCCodeOnly],      loadPCSymbols: [, Function, LoadPCSymbols],      loadGerm: [, Function, LoadGerm],      loadReal: [, Function, LoadReal],      loadRaw: [, Function, LoadRaw],      loadSymbols: [, Function, LoadSymbols],      openToAppend: [, Function, OpenToAppend],      openToWrite: [, Function, OpenToWrite],      pc: [, Loc],      pollsirius: [, Function, PollSirius],      popib: [, Function, PopIB],      readIO: [, Function, ReadIO],      reset: [, Function, Reset],      resetIOPSymbols: [, Function, ResetIOPSymbols],      resetPCSymbols: [, Function, ResetPCSymbols],      setBank: [, Function, SetBank],      setIOPAddressType: [, Function, SetIOPAddressType],      setPCAddressType: [, Function, SetPCAddressType],      setDataType: [, Function, SetDataType],      setPCDataType: [, Function, SetPCDataType],      setMP: [, Function, SetMP],      start: [, Function, Start],      startIOP: [, Function, --StartIOP-- NotInThisVersion],      stepIOP: [, Function, StepIOP],      stop: [, Function, Stop],      stopIOP: [, Function, StopIOP],      stopPC: [, Function, StopPC],      unbreak: [, Function, Unbreak],      unbreakIOP: [, Function, UnbreakIOP],      unbreakPC: [, Function, UnbreakPC],      wait: [, Function, Wait],      write: [, Function, Write],      writeIO: [, Function, WriteIO],      writeLine: [, Function, WriteLine],      writeLoc: [, Function, WriteLoc],      writeTime: [, Function, WriteTime]];    };      InitKeyStrings: PROC = {    OPEN String;    k: LONG POINTER TO KeyArray ¬ cd.keys;          k[alterAddress].s ¬ CopyToNewString["AlterAddress"L, heap];      k[arm].s ¬ CopyToNewString["Arm"L, heap];      k[autopollsirius].s ¬ CopyToNewString["AutoPollSirius"L, heap];      k[boot].s ¬ CopyToNewString["Boot"L, heap];      k[bootIOP].s ¬ CopyToNewString["BootIOP"L, heap];      k[break].s ¬ CopyToNewString["Break"L, heap];      k[breakIOP].s ¬ CopyToNewString["BreakIOP"L, heap];      k[breakPC].s ¬ CopyToNewString["BreakPC"L, heap];      k[buffer].s ¬ CopyToNewString["Buffer"L, heap];      k[clearCPPanel].s ¬ CopyToNewString["ClearCPPanel"L, heap];      k[clearIOPPanel].s ¬ CopyToNewString["ClearIOPPanel"L, heap];      k[clearPCPanel].s ¬ CopyToNewString["ClearPCPanel"L, heap];      k[close].s ¬ CopyToNewString["Close"L, heap];      k[compare].s ¬ CopyToNewString["Compare"L, heap];      k[continue].s ¬ CopyToNewString["Continue"L, heap];      k[continueIOP].s ¬ CopyToNewString["ContinueIOP"L, heap];      k[cp].s ¬ CopyToNewString["CP"L, heap];      k[copyIOPPanel].s ¬ CopyToNewString["CopyIOPPanel"L, heap];      k[copyPCPanel].s ¬ CopyToNewString["CopyPCPanel"L, heap];      k[copypanel].s ¬ CopyToNewString["CopyPanel"L, heap];      k[goTo].s ¬ CopyToNewString["GOTO"L, heap];      k[if].s ¬ CopyToNewString["IF"L, heap];      k[iop].s ¬ CopyToNewString["IOP"L, heap];      k[initIOPPanel].s ¬ CopyToNewString["InitIOPPanel"L, heap];      k[initPCPanel].s ¬ CopyToNewString["InitPCPanel"L, heap];      k[load].s ¬ CopyToNewString["Load"L, heap];      k[loadBoot].s ¬ CopyToNewString["LoadBoot"L, heap];      k[loadMore].s ¬ CopyToNewString["LoadMore"L, heap];      k[loadNoSymbols].s ¬ CopyToNewString["LoadNoSymbols"L, heap];      k[loadIOP].s ¬ CopyToNewString["LoadIOP"L, heap];      k[loadIOPCodeOnly].s ¬ CopyToNewString["LoadIOPCodeOnly"L, heap];      k[loadIOPSymbols].s ¬ CopyToNewString["LoadIOPSymbols"L, heap];      k[loadPC].s ¬ CopyToNewString["LoadPC"L, heap];      k[loadPCCodeOnly].s ¬ CopyToNewString["LoadPCCodeOnly"L, heap];      k[loadPCSymbols].s ¬ CopyToNewString["LoadPCSymbols"L, heap];      k[loadGerm].s ¬ CopyToNewString["LoadGerm"L, heap];      k[loadReal].s ¬ CopyToNewString["LoadReal"L, heap];      k[loadRaw].s ¬ CopyToNewString["LoadRaw"L, heap];      k[loadSymbols].s ¬ CopyToNewString["LoadSymbols"L, heap];      k[openToAppend].s ¬ CopyToNewString["OpenToAppend"L, heap];      k[openToWrite].s ¬ CopyToNewString["OpenToWrite"L, heap];      k[pollsirius].s ¬ CopyToNewString["PollSirius"L, heap];      k[popib].s ¬ CopyToNewString["PopIB"L, heap];      k[pc].s ¬ CopyToNewString["PC"L, heap];      k[readIO].s ¬ CopyToNewString["ReadIO"L, heap];      k[reset].s ¬ CopyToNewString["Reset"L, heap];      k[resetIOPSymbols].s ¬ CopyToNewString["ResetIOPSymbols"L, heap];      k[resetPCSymbols].s ¬ CopyToNewString["ResetPCSymbols"L, heap];      k[setBank].s ¬ CopyToNewString["SetBank"L, heap];      k[setIOPAddressType].s ¬ CopyToNewString["SetIOPAddressType"L, heap];      k[setPCAddressType].s ¬ CopyToNewString["SetPCAddressType"L, heap];      k[setDataType].s ¬ CopyToNewString["SetDataType"L, heap];      k[setPCDataType].s ¬ CopyToNewString["SetPCDataType"L, heap];      k[setMP].s ¬ CopyToNewString["SetMP"L, heap];      k[start].s ¬ CopyToNewString["Start"L, heap];      k[startIOP].s ¬ CopyToNewString["StartIOP"L, heap];      k[stepIOP].s ¬ CopyToNewString["StepIOP"L, heap];      k[stop].s ¬ CopyToNewString["Stop"L, heap];      k[stopIOP].s ¬ CopyToNewString["StopIOP"L, heap];      k[stopPC].s ¬ CopyToNewString["StopPC"L, heap];      k[unbreak].s ¬ CopyToNewString["UnBreak"L, heap];      k[unbreakIOP].s ¬ CopyToNewString["UnbreakIOP"L, heap];      k[unbreakPC].s ¬ CopyToNewString["UnbreakPC"L, heap];      k[wait].s ¬ CopyToNewString["Wait"L, heap];      k[write].s ¬ CopyToNewString["Write"L, heap];      k[writeIO].s ¬ CopyToNewString["WriteIO"L, heap];      k[writeLine].s ¬ CopyToNewString["WriteLine"L, heap];      k[writeLoc].s ¬ CopyToNewString["WriteLoc"L, heap];      k[writeTime].s ¬ CopyToNewString["WriteTime"L, heap];      };                        }.FXB   	10-Oct-84 15:10:14 - Creation--  FXB   , 	16-Oct-84  9:50:38--  FXB   , 	26-Oct-84 13:41:34	restored the GOTO command--  AYC   ,	27-Nov-84  7:51:57	debug CP commands--  FXB   , 	 4-Feb-85 10:38:29	added LoadPC, made InitKeys not INLINE--  JAC   ,	20-Feb-85 20:33:43	added timeouts to the CP Start command--  FXB   , 	 7-Mar-85 14:13:44	added Wait, added Wait to ContinueIOP--  FXB   , 	 7-Mar-85 17:48:55	allocate space for key strings from heap--  RDH   , 	 4-Feb-86 12:01:08	Change Load, LoadRaw, LoadSymbols, LoadNoSymbols procs for 8K.
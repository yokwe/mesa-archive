-- File: RemoteHeadsTestImpl.mesa - last edit:-- FXB   .PA            4-Jun-85 15:21:22-- Create by FormSWLayoutTool on 23-Jul-84 11:23:00-- Copyright (C) 1985 by Xerox Corporation. All rights reserved.DIRECTORY  Bindweed,  Environment,  Exec,  FormSW,  Heap,  Inline,  Process,  Put,  RemoteMemory,  Tool,  ToolWindow,  Window;RemoteHeadsTestImpl: MONITOR  IMPORTS    Bindweed, Exec, FormSW, Heap, Inline, Process, Put, RemoteMemory, Tool, ToolWindow =  {  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = MACHINE DEPENDENT RECORD [    msgSW(0): Window.Handle _ NIL,    formSW(2): Window.Handle _ NIL,    fileSW(4): Window.Handle _ NIL,    repetitions(6): CARDINAL _ 0];  FormItems: TYPE = {start, stop, repetitions};  data: DataHandle _ NIL;  wh: Window.Handle _ NIL;  zone: UNCOUNTED ZONE _ Heap.systemZone;  doveAddr: LONG CARDINAL = 1200H;  words: CARDINAL = 150;  DownNotify: CONDITION;  UpNotify: CONDITION;  dataPtr: LONG POINTER TO ARRAY [0..words) OF CARDINAL;  maskBit: WORD = 15;  mask: LONG POINTER TO WORD _ NIL;  up, main: PROCESS;  StopProcs: BOOLEAN _ FALSE;  gotDownNotify, gotUpNotify, started: BOOLEAN _ FALSE;    SwapBytes: PROCEDURE[    wordPtr: LONG POINTER TO PACKED ARRAY [0..2) OF Environment.Byte] = {    temp: Environment.Byte _ wordPtr[0];    wordPtr[0] _ wordPtr[1];    wordPtr[1] _ temp;    };  MainTest: ENTRY PROCEDURE = {    ENABLE ABORTED => GOTO aborted;    success: BOOLEAN _ TRUE;    val: CARDINAL _ 0;  [mask, success] _ RemoteMemory.RegisterMemory[      3CB4 -- remHeadsDownNotifyMask-- , 1, zone];        IF NOT success THEN {      Put.Line[data.fileSW, "Timeout"L];      Stop;      RETURN};    [dataPtr, success] _ RemoteMemory.RegisterMemory[doveAddr, words, zone];   IF NOT success THEN {      Put.Line[data.fileSW, "Timeout"L];      Stop;      RETURN};   SwapBytes[LOOPHOLE[mask]];      -- init shared memory    FOR i: CARDINAL IN [0..words) DO dataPtr[i] _ i; ENDLOOP;    DO      -- init shared memory      FOR i: CARDINAL IN [0..words) DO dataPtr[i] _ i; ENDLOOP;      gotDownNotify _ TRUE;      NOTIFY DownNotify;      UNTIL gotUpNotify DO        WAIT UpNotify;	ENDLOOP;      gotUpNotify _ FALSE;      -- test to see if memory has correct data      FOR i: CARDINAL IN [0..words) DO        IF dataPtr[i] # Inline.BITNOT[i] THEN GOTO badData ENDLOOP;	data.repetitions _ data.repetitions + 1;	        FormSW.DisplayItem[data.formSW, ORD[FormItems.repetitions]];      ENDLOOP;        EXITS       badData => Put.Line[data.fileSW, "Test Failed (Main process killed)"];      aborted => Put.Line[data.fileSW, "Main Test Process Aborted"L];    };           DownNotifyProc: ENTRY PROCEDURE = {    ENABLE ABORTED => GO TO aborted;    DO       UNTIL gotDownNotify DO        WAIT DownNotify;	ENDLOOP;      gotDownNotify _ FALSE;	      IF ~RemoteMemory.WriteDove[! RemoteMemory.WriteRemoteFailed => GOTO WriteFailed] THEN EXIT;      Bindweed.DownNotify[mask^ ! Bindweed.Error => EXIT];      ENDLOOP;    Put.Line[data.fileSW, "timeout"L];    EXITS      WriteFailed => Put.Line[data.fileSW, "WriteRemoteFailed"L];      aborted => Put.Line[data.fileSW, "DownNotify Aborted"L];        };  UpNotifyProc: Bindweed.NotifyProc = {UpNotifyProcEntry[]; };  UpNotifyProcEntry: ENTRY PROCEDURE = {    IF ~RemoteMemory.ReadDove[! RemoteMemory.WriteRemoteFailed => GOTO WriteFailed] THEN GOTO timeout;    gotUpNotify _ TRUE;    NOTIFY UpNotify    EXITS       timeout => Put.Line[data.fileSW, "timeout"L];      WriteFailed => Put.Line[data.fileSW, "WriteRemoteFailed"L];    };  Start: FormSW.ProcType = {    started _ TRUE;    Put.Line[data.fileSW, "Start called"L];    Process.EnableAborts[@DownNotify];    Process.EnableAborts[@UpNotify];    Bindweed.AddNotify[UpNotifyProc, maskBit];    up _ FORK DownNotifyProc[];    main _ FORK MainTest[];    };  Stop: FormSW.ProcType = {    Put.Line[data.fileSW, "Stop called"L];    Bindweed.RemoveNotify[maskBit, UpNotifyProc];    Process.Abort[up];    Process.Abort[main];    };  ClientTransition: ToolWindow.TransitionProcType = {    SELECT TRUE FROM      old = inactive => IF data = NIL THEN data _ zone.NEW[Data _ []];      new = inactive => IF data # NIL THEN {zone.FREE[@data]};      ENDCASE;    };  FireUpRemoteHeads: PROCEDURE = {    wh _ Tool.Create[      makeSWsProc: MakeSWs, initialState: default,      clientTransition: ClientTransition, name: "RemoteHeadsTestImpl"L,      cmSection: "RemoteHeadsTestImpl"L];    };  MakeSWs: Tool.MakeSWsProc = {    logName: LONG STRING _ [26];    Tool.UnusedLogName[unused: logName, root: "RemoteHeadsTestImpl.log"L];    data.msgSW _ Tool.MakeMsgSW[window: window];    data.formSW _ Tool.MakeFormSW[window: window, formProc: MakeForm];    data.fileSW _ Tool.MakeFileSW[window: window, name: logName];    };  MakeForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = FormItems.LAST.ORD + 1;    items _ AllocateItemDescriptor[nItems];    items[FormItems.start.ORD] _ CommandItem[      tag: "Start"L, place: [7, line0], proc: Start];    items[FormItems.stop.ORD] _ CommandItem[      tag: "Stop"L, place: [58, line0], proc: Stop];    items[FormItems.repetitions.ORD] _ NumberItem[      tag: "repetitions"L, place: [103, line0], signed: FALSE,      value: @data.repetitions];    RETURN[items: items, freeDesc: TRUE];    };    -- command line interface  RHExecCall: Exec.ExecProc = {IF wh # NIL THEN ToolWindow.Activate[wh]};  -- initialization  Init: PROC = {    Exec.AddCommand[      name: "RemoteHeadsTest.~"L, proc: RHExecCall, unload: DestroyRemoteHeads];    FireUpRemoteHeads[]};  DestroyRemoteHeads: Exec.ExecProc = {    IF started THEN Stop;     IF wh # NIL THEN Tool.Destroy[wh];    h.RemoveCommand["RemoteHeadsTest.~"L]; };  -- Mainline code  Init[];  -- this gets string out of global frame  }...    
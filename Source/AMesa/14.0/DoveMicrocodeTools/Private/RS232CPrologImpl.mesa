-- File: RS232CPrologImpl.mesa-- This provides an interface to the Prolog M980 Prom Programmer-- Last Edited by:-- Purves,   27-Aug-85 17:35:32           moved HexSubStringToLongCardinal here, got rid of cursor stuff-- created by Bowers  12-Jan-84 19:19:38-- Copyright (C) 1985 by Xerox Corporation. All rights reserved.DIRECTORY  Ascii USING [CR, LF],  Environment USING [Byte, Block, nullBlock],  Inline USING [BITAND],  Process USING [Pause, MsecToTicks],  Put USING [Line, Text],  String USING [AppendChar, AppendString, AppendStringAndGrow],  RS232CCorrespondents USING [ttyHost],  RS232C USING [    CommParamObject, CommParamHandle, Create, Delete, SetParameter, ChannelHandle,    ChannelSuspended, GetStatus, Parity, DeviceStatus, NoRS232CHardware,    InvalidLineNumber, PhysicalRecord, PhysicalRecordHandle, Put, Get, Suspend,    TransferWait, CompletionHandle, TransferStatus],  RS232CProlog,  Window USING [Handle];RS232CPrologImpl: PROGRAM  IMPORTS Inline, Process, Put, String, RS232C EXPORTS RS232CProlog =  {  channel: RS232C.ChannelHandle;  deviceStatus: RS232C.DeviceStatus;  emptyBlock: Environment.Block = Environment.nullBlock;  responseBlock, sendBlock: Environment.Block ¬ [NIL, 0, 256];  sendRec: RS232C.PhysicalRecord ¬ [emptyBlock, sendBlock, emptyBlock];  responseRec: RS232C.PhysicalRecord ¬ [emptyBlock, responseBlock, emptyBlock];  sendRecHandle: RS232C.PhysicalRecordHandle = @sendRec;  responseRecHandle: RS232C.PhysicalRecordHandle = @responseRec;  dummyChannelOpened, channelOpened, abort, runFlag: BOOLEAN ¬ FALSE;  --completion handles--  responseHandle, sendHandle: RS232C.CompletionHandle;  --status--  sendStatus, responseStatus: RS232C.TransferStatus;  --Processes--  Sender, Receiver: PROCESS;  addressChars: CARDINAL ¬ 4;  debug: PUBLIC BOOLEAN ¬ FALSE;  log: PUBLIC Window.Handle ¬ NIL;  -- S I G N A L S  TransmissionAborted: PUBLIC SIGNAL = CODE;  NegativeResponse: PUBLIC SIGNAL = CODE;  AppendHexNumber: PUBLIC PROCEDURE [s: LONG STRING, n, w: CARDINAL] = {    ls: STRING ¬ [4];    ls.length ¬ 4;    FOR i: CARDINAL DECREASING IN [0..3] DO      m: CARDINAL ¬ n MOD 16;      n ¬ n / 16;      ls[i] ¬ IF m < 10 THEN m + '0 ELSE m + 'A - 10      ENDLOOP;    IF w > 4 THEN {      THROUGH [4..w) DO String.AppendChar[s, '0] ENDLOOP;      String.AppendString[s, ls];      }    ELSE FOR i: CARDINAL IN [4 - w..4) DO String.AppendChar[s, ls[i]] ENDLOOP;    };  IntelFormat: PUBLIC PROCEDURE [    address: CARDINAL, data: LONG STRING, cs: CARDINAL, z: UNCOUNTED ZONE]    RETURNS [intelHex: LONG STRING] = {    intelHex ¬ z.NEW[StringBody [46]];    String.AppendChar[intelHex, ':];    AppendHexNumber[intelHex, data.length / 2, 2];  -- data length    AppendHexNumber[intelHex, address, 4];  -- address    String.AppendString[intelHex, "00"L];  -- record type    String.AppendString[intelHex, data];  -- data    cs ¬ Inline.BITAND[      cs + data.length / 2 + address MOD 256 + address / 256, 377B];    AppendHexNumber[intelHex, 0 - cs, 2];  -- check sum    String.AppendChar[intelHex, Ascii.CR];    };  InitLogHandle: PUBLIC PROCEDURE [logHandle: Window.Handle] = {    log ¬ logHandle; };  SetDebugFlag: PUBLIC PROCEDURE [debugFlag: BOOLEAN] = {debug ¬ debugFlag};  GiveItUp: PUBLIC PROCEDURE = {    RS232C.Suspend[channel, all];    WHILE runFlag DO Process.Pause[Process.MsecToTicks[250]] ENDLOOP;    RS232C.Delete[channel];    channelOpened ¬ FALSE;    RS232CInit;    };  HexSubStringToCardinal: PUBLIC PROCEDURE [    base: LONG STRING, offset: CARDINAL, length: [0..4]]    RETURNS [n: CARDINAL ¬ 0] = {    FOR i: CARDINAL IN [offset..offset + length) DO      SELECT base[i] FROM        '0, '1, '2, '3, '4, '5, '6, '7, '8, '9 => n ¬ n * 16 + base[i] - '0;        'A, 'B, 'C, 'D, 'E, 'F => n ¬ n * 16 + base[i] - 'A + 10;	'a, 'b, 'c, 'd, 'e, 'f => n ¬ n * 16 + base[i] - 'a + 10;        ENDCASE => EXIT;      ENDLOOP;    };  HexSubStringToLongCardinal: PUBLIC PROCEDURE [    base: LONG STRING, offset: CARDINAL, length: [0..8]]    RETURNS [n: LONG CARDINAL ¬ 0] = {    FOR i: CARDINAL IN [offset..offset + length) DO      SELECT base[i] FROM        '0, '1, '2, '3, '4, '5, '6, '7, '8, '9 => n ¬ n * 16 + base[i] - '0;        'A, 'B, 'C, 'D, 'E, 'F => n ¬ n * 16 + base[i] - 'A + 10;	'a, 'b, 'c, 'd, 'e, 'f => n ¬ n * 16 + base[i] - 'a + 10;        ENDCASE => EXIT;      ENDLOOP;    };  ReadBlock: PUBLIC PROCEDURE [startAddress: CARDINAL, block: LONG STRING] = {    command: LONG STRING ¬ [6];    String.AppendChar[command, 'L];    AppendHexNumber[command, startAddress, 4];    DoExchange[command, block];    };  WriteBlock: PUBLIC PROCEDURE [    block: LONG STRING, startAddress, length: CARDINAL] = {    command: LONG STRING ¬ [12];    reply: LONG STRING ¬ [4];    endAddress: CARDINAL ¬ startAddress + length - 1;    String.AppendString[command, "QXDB"L];    AppendHexNumber[command, startAddress, addressChars];    AppendHexNumber[command, endAddress, addressChars];    Send[block];    DoExchange[command, reply];    };  CopyPromToProgrammerBuffer: PUBLIC PROCEDURE = {    command: LONG STRING ¬ "QXDC"L;    block: LONG STRING ¬ [4];    DoExchange[command, block];    };  ProgramWholeProm: PUBLIC PROCEDURE = {RS232CInit; };  InitPromType: PUBLIC PROCEDURE [initCode: CARDINAL, z: UNCOUNTED ZONE] = {    initTypeCommand: LONG STRING ¬ NIL;    initCodeString: LONG STRING ¬ [2];    block: LONG STRING ¬ [4];    IF initCode > 100 THEN {addressChars ¬ initCode - 100; RETURN};    addressChars ¬ 4;    AppendHexNumber[initCodeString, initCode, 2];    DoExchange["QXDME000E000", block];    --Receive[bufferString: NIL, wantReply: FALSE];    DoExchange["QXDM00000000", block];    --Receive[bufferString: NIL, wantReply: FALSE];    initTypeCommand ¬ IntelFormat[      address: 0, data: initCodeString, cs: initCode, z: z];    String.AppendStringAndGrow[@initTypeCommand, "QXDB00000000"L, z];    DoExchange[initTypeCommand, block];    -- Send["QXDB00000000"];    --Receive[bufferString: NIL, wantReply: FALSE];    };  SenderProc: PROCEDURE = {    ENABLE RS232C.ChannelSuspended => GOTO transmissionAborted;    runFlag ¬ TRUE;    sendHandle ¬ RS232C.Put[channel, sendRecHandle];    [, sendStatus] ¬ RS232C.TransferWait[channel, sendHandle];    runFlag ¬ FALSE;    EXITS transmissionAborted => {runFlag ¬ FALSE; abort ¬ TRUE};    };  ReceiverProc: PROCEDURE = {    ENABLE RS232C.ChannelSuspended => GOTO transmissionAborted;    runFlag ¬ TRUE;    responseHandle ¬ RS232C.Get[channel, responseRecHandle];    [, responseStatus] ¬ RS232C.TransferWait[channel, responseHandle];    runFlag ¬ FALSE;    EXITS transmissionAborted => {runFlag ¬ FALSE; abort ¬ TRUE};    };  Send: PROCEDURE [command: LONG STRING] = {    IF debug THEN {      Put.Text[h: log, s: "Command: "L]; Put.Line[h: log, s: command]};    sendRecHandle.body ¬ [LOOPHOLE[@command.text], 0, command.length];    Sender ¬ FORK SenderProc;    JOIN Sender;    IF abort THEN {abort ¬ FALSE; SIGNAL TransmissionAborted};    IF sendStatus # success THEN SIGNAL TransmissionAborted;    };  DoExchange: PROCEDURE [command: LONG STRING, responseBuffer: LONG STRING] = {    IF debug THEN {      Put.Text[h: log, s: "Command: "L]; Put.Line[h: log, s: command]};    sendRecHandle.body ¬ [LOOPHOLE[@command.text], 0, command.length];    responseRecHandle.body ¬ [      LOOPHOLE[@responseBuffer.text], 0, responseBuffer.maxlength];    Sender ¬ FORK SenderProc;    JOIN Sender;    IF sendStatus # success OR abort THEN {      abort ¬ FALSE; SIGNAL TransmissionAborted};    -- since RS232CCorrespondent is ttyHost a Get can complete without retrieving any characters.  Consequently, we must do a Get until data is received. The linefeed character is used as a data flag in this case.     DO      responseRecHandle.body.blockPointer^[responseBuffer.maxlength - 1] ¬ 0;      Receiver ¬ FORK ReceiverProc;      JOIN Receiver;      IF abort THEN {abort ¬ FALSE; SIGNAL TransmissionAborted};      <<hexFormat: Format.NumberFormat ¬ [16, TRUE, TRUE, 2];      Put.Line[log, "response in hex: "L];      FOR i: CARDINAL IN       [responseRecHandle.body.startIndex..responseRecHandle.body.stopIndexPlusOne)       DO        Put.Number[log, responseRecHandle.body.blockPointer^[i], hexFormat];        Put.Char[log, ' ];        ENDLOOP;      Put.CR[log];>>      IF responseRecHandle.body.blockPointer^[responseBuffer.maxlength - 1] =        LOOPHOLE[Ascii.LF] THEN EXIT      ENDLOOP;    -- convert Environment.Block in responseRecHandle.body to a STRING    responseBuffer.length ¬ 0;    FOR i: CARDINAL IN      [responseRecHandle.body.startIndex..responseRecHandle.body.stopIndexPlusOne)      DO      String.AppendChar[        responseBuffer, LOOPHOLE[responseRecHandle.body.blockPointer^[i],        CHARACTER]]      ENDLOOP;    IF debug THEN {      Put.Text[h: log, s: "Response: "L]; Put.Line[h: log, s: responseBuffer]};    SELECT responseStatus FROM      success => NULL;      dataLost => Put.Line[log, "dataLost"L];      deviceError => Put.Line[log, "deviceError"L];      frameTimeout => Put.Line[log, "frameTimeout"L];      checksumError => Put.Line[log, "checksumError"L];      parityError => Put.Line[log, "parityError"L];      asynchFramingError => Put.Line[log, "asynchFramingError"L];      invalidChar => Put.Line[log, "invalidChar"L];      invalidFrame => Put.Line[log, "invalidFrame"L];      aborted => Put.Line[log, "aborted"];      disaster => Put.Line[log, "disaster"L];      ENDCASE => ERROR;    IF responseRecHandle.body.blockPointer^[0] = LOOPHOLE['N] THEN      SIGNAL NegativeResponse;    IF responseStatus # success THEN SIGNAL TransmissionAborted;    };  RS232CInit: PUBLIC PROCEDURE = {    channelParameters: RS232C.CommParamObject ¬ [      half, asynchronous, bps4800, directConn[]];    channelParametersHandle: RS232C.CommParamHandle ¬ @channelParameters;    IF channelOpened THEN RETURN;    channel ¬ RS232C.Create[      lineNumber: 0, commParams: channelParametersHandle,      preemptOthers: preemptInactive, preemptMe: preemptInactive !      RS232C.NoRS232CHardware => {        Put.Line[log, "No RS-232-C Hardware"L]; REJECT; };      RS232C.InvalidLineNumber => {        Put.Line[log, "Invalid Line Number"L]; REJECT; }; ];    --Set other parameters, now that the channel exists    --First, turn off DataTerminal ready    RS232C.SetParameter[channel, [dataTerminalReady[FALSE]]];    RS232C.SetParameter[channel, [requestToSend[FALSE]]];    RS232C.SetParameter[channel, [correspondent[RS232CCorrespondents.ttyHost]]];    RS232C.SetParameter[channel, [charLength[7]]];    RS232C.SetParameter[channel, [frameTimeout[3]]];    RS232C.SetParameter[channel, [parity[even]]];    RS232C.SetParameter[channel, [stopBits[1]]];    RS232C.SetParameter[channel, [lineSpeed[bps4800]]];    RS232C.SetParameter[channel, [dataTerminalReady[TRUE]]];    RS232C.SetParameter[channel, [requestToSend[TRUE]]];    deviceStatus ¬ RS232C.GetStatus[channel];    channelOpened ¬ TRUE;    };  TransitionToInactiveState: PUBLIC PROCEDURE = {    RS232C.Suspend[channel, all];    WHILE runFlag DO Process.Pause[Process.MsecToTicks[250]] ENDLOOP;    RS232C.Delete[channel];    channelOpened ¬ FALSE;    };  }.    
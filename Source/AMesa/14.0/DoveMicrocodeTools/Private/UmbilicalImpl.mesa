-- UmbilicalImpl.mesa-- Last edited by JBinkley 31-Jan-84  9:57:44-- Taken from TestUmbilical.mesa by  HGM  4-Oct-83 23:27:50-- Edited by Frank FXB     2-Aug-84 13:31:35-- This program tests the Burdock umbilical connection between the Dandelion and the-- Daisy IOP.--DIRECTORY  DLionInputOutput USING [IOPage, processorCommandOffset, processorCSBOffset],  Environment USING [Byte],  Inline USING [BITAND, BytePair, HighByte, LowByte, LowHalf, HighHalf],  Process USING [MsecToTicks, Pause],  Umbilical;UmbilicalImpl: PROGRAM  IMPORTS DLionInputOutput, Inline, Process  EXPORTS Umbilical =  BEGIN      ProcessorCommand: TYPE = MACHINE DEPENDENT{    null(0), readIOPByte(5), writeIOPByte(6), readUmbilicalBlock(7),    writeUmbilicalBlock(8)};  pProcessorCommand: LONG POINTER TO ProcessorCommand =    DLionInputOutput.IOPage + DLionInputOutput.processorCommandOffset;  ProcessorCSB: TYPE = MACHINE DEPENDENT RECORD [    data2(0): WORD, data1(1): WORD, data0(2): WORD];  pProcessorCSB: LONG POINTER TO ProcessorCSB =    DLionInputOutput.IOPage + DLionInputOutput.processorCSBOffset;--The equates below assign symbolic names to constant addresses in the Dandelion's IOP page  ppiBase: CARDINAL = 100200B;     -- Hex 8080  ppiA: CARDINAL = ppiBase + 0;    --output Dlion to Daisy  ppiB: CARDINAL = ppiBase + 1;    --input Daisy to Dlion  ppiC: CARDINAL = ppiBase + 2;    --handshaking  ppiCtl: CARDINAL = ppiBase + 3;  --control--hostAddress and miscClocks are used to test the Dlion's own IOP function  hostAddress: CARDINAL = 100260B; -- Hex 80B0  miscClocks: CARDINAL = 100351B;  -- Hex 80E9  --The equates below assign symbolic names to constants used to setup the i8255 ppi umbilical and to poll its operation.   ppiTest: CARDINAL = 82H;     -- Mode 0  ppiInit: CARDINAL = 0A6H;  ppiEnableA: CARDINAL = 0DH;   ppiEnableB: CARDINAL = 05H;  ppiSetBoot: CARDINAL = 09H;  ppiClearBoot: CARDINAL = 08H;    ppiSetNMI: CARDINAL =  0BH;   ppiClearNMI: CARDINAL = 0AH;--Used for polling port A (output) and port B (input)  intAMask: CARDINAL = 08H;   intBMask: CARDINAL = 01H;    Timeout: PUBLIC ERROR = CODE;  UmbilicalNotWorking: PUBLIC ERROR = CODE;  Boot: PUBLIC PROCEDURE =    BEGIN    response: WORD;    Initialize[];    WriteThroughIOP[ppiCtl, ppiSetBoot];    Process.Pause[Process.MsecToTicks[100]];    WriteThroughIOP[ppiCtl, ppiClearBoot];    response _ ReadByteLocal[5000];  -- could display response for debugging purposes    END;--ReadThroughIOP is used to communicate with the host's IOP through the I/O page--(CSB means Control Status Block at the CSB. processorCSB refers to the one --used to communicate between the Mesa processor and the IOP.)--(relevant addresses are assigned symbolic names above)   ReadThroughIOP: PUBLIC PROCEDURE [address: CARDINAL] RETURNS [Environment.Byte] =    BEGIN    UNTIL pProcessorCommand^ = null DO ENDLOOP;    pProcessorCSB.data2 _ address;    pProcessorCommand^ _ readIOPByte;    UNTIL pProcessorCommand^ = null DO ENDLOOP;    RETURN[Inline.LowByte[pProcessorCSB.data1]];    END;--WriteThroughIOP is used to communicate with the host's IOP through the I/O page  WriteThroughIOP: PROCEDURE [address: CARDINAL, data: Environment.Byte] =    BEGIN    UNTIL pProcessorCommand^ = null DO ENDLOOP;    pProcessorCSB.data2 _ address;    pProcessorCSB.data1 _ data;    pProcessorCommand^ _ writeIOPByte;    UNTIL pProcessorCommand^ = null DO ENDLOOP;    END;          ToggleNMI: PUBLIC PROCEDURE = {  WriteThroughIOP[ppiCtl, ppiSetNMI];  WriteThroughIOP[ppiCtl, ppiClearNMI];  };  Initialize: PROCEDURE =    BEGIN    -- Beware, Mode setting clears all FFs which turns on Boot    temp: WORD;    WriteThroughIOP[ppiCtl, ppiTest];    WriteThroughIOP[ppiCtl, ppiClearBoot];    WriteThroughIOP[ppiA, 0];    temp _ ReadThroughIOP[ppiA];    IF temp # 0 THEN ERROR UmbilicalNotWorking;    WriteThroughIOP[ppiA, 0FFH];    temp _ ReadThroughIOP[ppiA];    IF temp # 0FFH THEN ERROR UmbilicalNotWorking;    WriteThroughIOP[ppiCtl, ppiInit];    WriteThroughIOP[ppiCtl, ppiClearBoot];    WriteThroughIOP[ppiCtl, ppiEnableA];    WriteThroughIOP[ppiCtl, ppiEnableB];    [] _ ReadThroughIOP[ppiB];  -- Discard garbage byte (if any)    END;      WriteBlock: PUBLIC PROCEDURE [dataPtr: LONG POINTER TO PACKED ARRAY INTEGER[0..0) OF Environment.Byte,     size: Environment.Byte] =    BEGIN    before, after: ProcessorCSB;    UNTIL pProcessorCommand^ = null DO ENDLOOP;    pProcessorCSB.data2 _ size;    pProcessorCSB.data1 _ Inline.LowHalf[dataPtr];    pProcessorCSB.data0 _ Inline.HighHalf[dataPtr];    before _ pProcessorCSB^;  -- Debugging    pProcessorCommand^ _ writeUmbilicalBlock;    UNTIL pProcessorCommand^ = null DO ENDLOOP;    after _ pProcessorCSB^;  -- Debugging    IF pProcessorCSB.data0 # 0 THEN ERROR Timeout;    END;  WriteWord: PUBLIC PROCEDURE [data: WORD] =    BEGIN    WriteByte[Inline.LowByte[data]];    WriteByte[Inline.HighByte[data]];    END;       WriteByte: PUBLIC PROCEDURE [data: Environment.Byte] =    BEGIN    temp: WORD;    WriteThroughIOP[ppiA, data];    FOR i: CARDINAL IN [0..500) DO  -- ~ 1 second      temp _ ReadThroughIOP[ppiC];      IF Inline.BITAND[temp, intAMask] # 0 THEN EXIT;      REPEAT FINISHED => ERROR Timeout;      ENDLOOP;    END;  ReadBlock: PUBLIC PROCEDURE [dataPtr: LONG POINTER TO PACKED ARRAY[0..0) OF Environment.Byte,    size: Environment.Byte] =    BEGIN    before, after: ProcessorCSB;    UNTIL pProcessorCommand^ = null DO ENDLOOP;    pProcessorCSB.data2 _ size;    pProcessorCSB.data1 _ Inline.LowHalf[dataPtr];    pProcessorCSB.data0 _ Inline.HighHalf[dataPtr];    before _ pProcessorCSB^;  -- Debugging    pProcessorCommand^ _ readUmbilicalBlock;    UNTIL pProcessorCommand^ = null DO ENDLOOP;    after _ pProcessorCSB^;  -- Debugging    IF pProcessorCSB.data0 # 0 THEN ERROR Timeout;    END;      ReadByte: PUBLIC PROCEDURE RETURNS [Environment.Byte] =    {RETURN [ReadByteLocal[]]};      ReadByteLocal: PUBLIC PROCEDURE [delay: CARDINAL ¬ 500] RETURNS [Environment.Byte] =    BEGIN    temp: WORD;    FOR i: CARDINAL IN [0..delay) DO  -- ~ 1 second per 500 delay      temp _ ReadThroughIOP[ppiC];      IF Inline.BITAND[temp, intBMask] # 0 THEN EXIT;      REPEAT FINISHED => ERROR Timeout;      ENDLOOP;    RETURN[ReadThroughIOP[ppiB]];    END;      -- ReadReady returns TRUE if the debuggee wants to send data to the debuggee such as when a breakpoint occurs  ReadReady: PUBLIC PROCEDURE RETURNS[BOOLEAN] =    BEGIN    temp: WORD _ ReadThroughIOP[ppiC];    RETURN[Inline.BITAND[temp, intBMask] # 0];    END;  ReadWord: PUBLIC PROCEDURE RETURNS [WORD] =    BEGIN    bytes: Inline.BytePair;    bytes.low _ ReadByteLocal[];    bytes.high _ ReadByteLocal[];    RETURN[LOOPHOLE[bytes]];    END;END.
-- File: PromBlowToolB.mesa -- Support module for PromBlowTool-- Read/Blow/Verify procedures here-- last edit by:-- Purves,      28-Aug-85 13:51:22      redid status/error messages-- Purves,      27-Aug-85 17:54:57      added start time and % complete-- Purves,      21-Aug-85 18:43:23      extensive changes, new window, split module into two parts-- Purves,      30-Jul-85 14:56:01      cleaned up Exec stuff a bit-- Bowers, 	14-Jan-85 20:51:56	fixed verify to tell whether or not any data was found in the given address range-- Bowers, 	 2-Nov-84 15:58:22	made modifications for Host Address PROMS-- Bowers,	29-Aug-84 14:27:55-- Copyright (C) 1985 by Xerox Corporation. All rights reserved.DIRECTORY  PromBlowToolDefs,  Ascii USING [FF, SP, CR, LF, TAB],  Format USING [CR, DecimalFormat, Number, NumberFormat, StringProc],  FormSW,<< USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType, CommandItem,    Destroy, Display, DisplayItem, Enumerated, EnumeratedItem, ItemHandle, line3,    NotifyProcType, NumberItem, ProcType, StringItem],>>  MStream USING [Error, Handle, GetLength, ReadOnly, ReadWrite],  Put USING [Blank, CR, Decimal, Line, LongString, Number, Text],  String USING [    AppendChar, AppendExtensionIfNeeded, AppendLongNumber, AppendString, AppendStringAndGrow, CopyToNewString, Empty, EqualSubString, Equivalent, FreeString, MakeString, SubStringDescriptor],  Stream USING [    GetChar, GetWord, Delete, EndOfStream, PutChar, PutString, SetPosition],  RS232CProlog,  UserTerminal USING [Beep, BlinkDisplay],  Window USING [Handle];  PromBlowToolB: PROGRAM  IMPORTS    Format, FormSW, MStream, PromBlowToolDefs, Put, Stream, String, RS232CProlog, UserTerminal   EXPORTS    PromBlowToolDefs = {OPEN PromBlowToolDefs;    -- C O N S T A N T S  maxPromSize: CARDINAL = 02000H;  --8K bytes  SixtyFourK: LONG CARDINAL = 65536;  hexFormat: Format.NumberFormat = [16, TRUE, TRUE, 4];  stdLen: CARDINAL = 16;  -- V A R I A B L E S  image: LONG POINTER TO ImageArray ¬ NIL;  ImageArray: TYPE = ARRAY [0..3) OF ARRAY [0..maxPromSize / stdLen) OF LONG    STRING ¬ ALL[ALL[NIL]];  dataPos, dataLength: PUBLIC LONG CARDINAL ¬ 0;  -- S I G N A L S  InvalidMemoryWidth: SIGNAL = CODE;  NonVirginProm:      SIGNAL = CODE;  NoPromSpecs:        SIGNAL = CODE;  ReadBackError:      SIGNAL = CODE;<< PROCEDURES  >>-- General Purpose procedures-- Complain FillBlank GetString GetNumber GetCheckSum  Complain: PUBLIC PROC [msg: LONG STRING] = {    IF data # NIL THEN {      Put.CR[data.msgSW];      UserTerminal.BlinkDisplay[];       Put.Line[data.msgSW, msg];    };  };  FillBlank: PROCEDURE [dataString: LONG STRING, desiredLength: CARDINAL] = {    WHILE dataString.length < desiredLength DO      String.AppendChar[dataString, IF data.virgin = ones THEN 'F ELSE '0];      ENDLOOP;    };  GetString: PROCEDURE [str: MStream.Handle, s: LONG STRING] = {          BlankCharacter: PROCEDURE [c: CHARACTER] RETURNS [BOOLEAN] = {      OPEN Ascii;      RETURN[SELECT c FROM FF, SP, CR, LF, TAB => TRUE, ENDCASE => FALSE]};      GetNonBlank: PROCEDURE [str: MStream.Handle] RETURNS [ch: CHARACTER] = {      WHILE BlankCharacter[ch ¬ Stream.GetChar[str]] DO ENDLOOP};          ch: CHARACTER ¬ GetNonBlank[str];    s.length ¬ 0;    UNTIL BlankCharacter[ch] DO      String.AppendChar[s, ch];      ch ¬ Stream.GetChar[str];    ENDLOOP  };  GetNumber: PROCEDURE [str: MStream.Handle] RETURNS [n: CARDINAL] = {    ch: CHARACTER ¬ Stream.GetChar[str];    n ¬ 0;    WHILE ch ~IN ['0..'9] DO ch ¬ Stream.GetChar[str] ENDLOOP;    WHILE ch IN ['0..'9] DO       n ¬ n * 10 + ch - '0;       ch ¬ Stream.GetChar[str];    ENDLOOP  };    GetCheckSum: PROCEDURE [dataString: LONG STRING] RETURNS [cs: CARDINAL ¬ 0] = {    i: CARDINAL ¬ 0;    WHILE i < dataString.length DO      cs ¬ cs + RS232CProlog.HexSubStringToCardinal[dataString, i, 2];      i ¬ i + 2    ENDLOOP};-- Procedures for dealing with Prom Specs-- GetPromSpec AskForSpec ReadPromSpec WritePromSpec DisplayPromSpecs  GetPromSpec: PROCEDURE [name: LONG STRING, display: BOOLEAN ¬ TRUE] = {    OPEN data;    newData: BOOLEAN ¬ FALSE;    tempString: LONG STRING ¬ [15];    promSpec: PromSpec ¬ [tempString, 0, 0, 1, 0, 0];    specStream: MStream.Handle ¬ MStream.ReadWrite[      name: "Prom.Specs"L, release: [], type: text ! MStream.Error => {          IF code = fileNotAvailable 	    THEN Complain["MFile error acquiring Prom.Specs."L]	    ELSE Complain["MStream error acquiring Prom.Specs."L];	  GOTO AcquireError}];    DO ENABLE UNWIND => IF specStream # NIL THEN {Stream.Delete[specStream]; specStream ¬ NIL};      ReadPromSpec[specStream, @promSpec !         Stream.EndOfStream => GOTO SpecNotFound];      IF String.Equivalent[promSpec.chipType, name] THEN EXIT;    REPEAT      SpecNotFound => {        newData ¬ AskForSpec[specStream];	IF NOT newData THEN {	  Complain[msg: "Error: no Prom specs"L];          Stream.Delete[specStream]; specStream ¬ NIL;          SIGNAL NoPromSpecs};      };    ENDLOOP;    Stream.Delete[specStream]; specStream ¬ NIL;    IF chip.length = 0 THEN {width ¬ memSize ¬ 0; virgin ¬ ones}    ELSE IF NOT newData THEN { -- set data      width ¬ promSpec.wordsize;      memSize ¬ promSpec.memsize;      virgin ¬ IF promSpec.virginvalue = 0 THEN zeroes ELSE ones;      writeTime ¬ promSpec.writeTime;      pMCode ¬ promSpec.pMCode};    IF display THEN FormSW.Display[formSW];  EXITS    AcquireError => SIGNAL NoPromSpecs;  };      AskForSpec: PROC[specStream: MStream.Handle] RETURNS [newData: BOOL ¬ FALSE] = {    Complain[msg: "Unknown chip. Confirm!/Deny! adding it to the directory."L];    IF Confirmed[] THEN {      Put.Line[data.fileSW, "Adding..."L];      newData ¬ TRUE;      WritePromSpec[specStream];      Put.Line[data.fileSW, "Prom Specs added."L]}    ELSE data.chip.length ¬ 0;  };          ReadPromSpec: PROC [specStream:MStream.Handle, ps:LONG POINTER TO PromSpec] = {    GetString[specStream, ps.chipType];    ps.wordsize ¬ GetNumber[specStream];    ps.memsize ¬ GetNumber[specStream];    ps.virginvalue ¬ IF GetNumber[specStream] = 0 THEN 0 ELSE 1;    ps.writeTime ¬ GetNumber[specStream];    ps.pMCode ¬ GetNumber[specStream];  };  WritePromSpec: PROCEDURE [specStream: MStream.Handle] = {    OutProc: Format.StringProc = {Stream.PutString[specStream, s]};    Stream.PutString[specStream, data.chip];    Stream.PutChar[specStream, ' ];    Format.Number[OutProc, data.width, Format.DecimalFormat];    Stream.PutChar[specStream, ' ];    Format.Number[OutProc, data.memSize, Format.DecimalFormat];    Stream.PutChar[specStream, ' ];    Format.Number[      OutProc, IF data.virgin = ones THEN 1 ELSE 0, Format.DecimalFormat];    Stream.PutChar[specStream, ' ];    Format.Number[OutProc, data.writeTime, Format.DecimalFormat];    Stream.PutChar[specStream, ' ];    Format.Number[OutProc, data.pMCode, Format.DecimalFormat];    Format.CR[OutProc];  };    DisplayPromSpecs: PUBLIC PROC = {    s: LONG STRING ¬ [12];    specStream: MStream.Handle ¬ MStream.ReadOnly[      name: "Prom.Specs"L, release: [] ! MStream.Error => {        Complain[msg: "MStream Error -- Is Prom.Specs in your Search Path?"L];        GOTO quit};     ];    DO      ENABLE Stream.EndOfStream => EXIT;      GetString[specStream, s];      Put.Text[data.fileSW, s];      s.length ¬ 0;      Put.Blank[data.fileSW];      Put.Decimal[data.fileSW, GetNumber[specStream]];      Put.Blank[data.fileSW];      Put.Decimal[data.fileSW, GetNumber[specStream]];      Put.Blank[data.fileSW];      Put.LongString[        data.fileSW,        IF GetNumber[specStream] = 0 THEN "zeroes"L ELSE "ones"L];      Put.Blank[data.fileSW];      Put.Decimal[data.fileSW, GetNumber[specStream]];      Put.Blank[data.fileSW];      Put.Decimal[data.fileSW, GetNumber[specStream]];      Put.CR[data.fileSW];    ENDLOOP;    Put.CR[data.fileSW];    Stream.Delete[specStream];  EXITS quit => NULL;  };-- Procedures for dealing with the image-- ListingFormat DisplayImage FreeImage  ListingFormat: PROCEDURE [intelString, listingString: LONG STRING] = {    i: CARDINAL ¬ 0;    listingString.length ¬ 0;    FOR i IN [3..6] DO String.AppendChar[listingString, intelString[i]]; ENDLOOP;    String.AppendString[listingString, ": "L];    FOR i IN [9..40] DO      IF i MOD 2 = 0 THEN {        String.AppendChar[listingString, intelString[i]];        String.AppendChar[listingString, ' ]}      ELSE        IF data.width = 8 THEN          String.AppendChar[listingString, intelString[i]];      ENDLOOP;    String.AppendChar[listingString, Ascii.CR];  };  DisplayImage: PROCEDURE = {    FOR i: CARDINAL IN [0..3) DO      FOR j: CARDINAL IN [0..maxPromSize / stdLen) DO        IF image[i][j] # NIL THEN {          Put.Number[data.fileSW, j * stdLen, hexFormat];          Put.Text[data.fileSW, ":  "L];          Put.Line[data.fileSW, image[i][j]];        };      ENDLOOP;      Put.CR[data.fileSW];    ENDLOOP;  };  FreeImage: PUBLIC PROCEDURE = {    IF image # NIL THEN {      FOR i: CARDINAL IN [0..3) DO        FOR j: CARDINAL IN [0..maxPromSize / stdLen) DO          IF image[i][j] # NIL THEN heap.FREE[@image[i][j]];        ENDLOOP;      ENDLOOP;      heap.FREE[@image];  }};-- Procedures to burn and verify a DotBin file-- ReadDataRecord ReadDotBinFile InitForBlowDotBin DotBinReadBackChecks -- VerifyDotBinSlice DotBinVerify CheckVirginity BlowDotBin  ReadDataRecord: PROCEDURE [length: CARDINAL, drla: CARDINAL, sba: LONG CARDINAL, stream: MStream.Handle, slices: [1..3], low, high: LONG CARDINAL] = {    promSize: CARDINAL ¬ data.memSize;    address: LONG CARDINAL ¬ 0;    i, j, k: CARDINAL ¬ 0;        IF slices = 3 THEN  {      drla ¬ drla * slices; -- Kludge for 8X305 microcode format      high ¬ high * slices};    FOR dri: CARDINAL IN [0..length) DO      address ¬ sba + ((drla + dri) MOD SixtyFourK);      -- from pg. A-12 iAPX 86,88 family utilities user's guide      IF address IN [low..high] THEN {	i ¬ CARDINAL[(address MOD (slices * promSize)) / stdLen / slices];	j ¬ CARDINAL[(address MOD (slices * stdLen)) / slices * 2];	k ¬ CARDINAL[address MOD slices];	IF image[k][i] = NIL THEN  image[k][i] ¬ heap.NEW[StringBody [stdLen * 2]];	IF image[k][i].length < j THEN FillBlank[image[k][i], j];	image[k][i][j] ¬ Stream.GetChar[stream];	image[k][i][j + 1] ¬ Stream.GetChar[stream];	image[k][i].length ¬ MAX[j + 2, image[k][i].length];	}      ELSE {[] ¬ Stream.GetChar[stream]; [] ¬ Stream.GetChar[stream]};    ENDLOOP;  };  ReadDotBinFile: PROCEDURE [stream: MStream.Handle, slices: [1..3], low, high: LONG CARDINAL] = {    ENABLE Stream.EndOfStream => GOTO exit;    str: LONG STRING ¬ [13];    char: CHARACTER ¬ '\n;    recordLength, recordType: CARDINAL ¬ 0;    sba: LONG CARDINAL ¬ 0;    DO      WHILE (char ¬ Stream.GetChar[stream]) # ': DO ENDLOOP;      str.length ¬ 0;      String.AppendChar[str, char];      String.AppendChar[str, Stream.GetChar[stream]];      String.AppendChar[str, Stream.GetChar[stream]];      IF        (recordLength ¬ RS232CProlog.HexSubStringToCardinal[          base: str, offset: 1, length: 2]) = 0 THEN LOOP;      FOR i: CARDINAL IN [0..6) DO        String.AppendChar[str, Stream.GetChar[stream]]; ENDLOOP;      recordType ¬ RS232CProlog.HexSubStringToCardinal[        base: str, offset: 7, length: 2];      SELECT recordType FROM        0 => { -- data record          dataLength ¬ dataLength + recordLength;          ReadDataRecord[            length: recordLength,            drla: RS232CProlog.HexSubStringToCardinal[            base: str, offset: 3, length: 4], sba: sba, stream: stream,            slices: slices, low: low, high: high]};        1 => EXIT;  -- End of File Record        2 => {  -- extended address record          FOR i: CARDINAL IN [0..4) DO            String.AppendChar[str, Stream.GetChar[stream]]; ENDLOOP;          sba ¬ 16 * RS232CProlog.HexSubStringToLongCardinal[base: str, offset: 9, length: 4];          LOOP;        };        3 => NULL;  -- start address record ignored      ENDCASE;    ENDLOOP;  EXITS exit => NULL;  };  InitForBlowDotBin: PROCEDURE [stream: LONG POINTER TO MStream.Handle]    RETURNS[ok: BOOLEAN ¬ TRUE] = {        ENABLE UNWIND => IF stream­ # NIL THEN {Stream.Delete[stream­]; stream­ ¬ NIL};        startAddress, endAddress: LONG CARDINAL ¬ 0;        GetPromSpec[name: data.chip, display: FALSE];        SELECT TRUE FROM      data.start = NIL => startAddress ¬ 0;      data.start.length > 5 => {        Complain["start address out of range"L]; RETURN[FALSE]};      ENDCASE =>         startAddress ¬ RS232CProlog.HexSubStringToLongCardinal[          base: data.start, offset: 0, length: data.start.length];    IF  data.slices = 3 THEN {      endAddress ¬ startAddress + data.memSize - 1;      startAddress ¬         startAddress/data.memSize * data.memSize;}    ELSE{      endAddress ¬ startAddress + (2 * data.memSize) - 1;      startAddress ¬         startAddress/(2 * data.memSize) * data.memSize * 2;};    IF endAddress > 0FFFFFH THEN endAddress ¬ 0FFFFFH;    IF data.start = NIL THEN data.start ¬ heap.NEW[StringBody[5]];    data.start.length ¬ 0;    String.AppendLongNumber[      s: data.start, n: startAddress, radix: 16];    IF data.end = NIL THEN data.end ¬ heap.NEW[StringBody[10]];    data.end.length ¬ 0;    String.AppendLongNumber[s: data.end, n: endAddress, radix: 16];    IF data.slices NOT IN [1..3] THEN {      Complain["slices value out of range; must be 1, 2, or 3."L];      RETURN[FALSE]};    FormSW.Display[data.formSW];    Put.Line[data.fileSW, "Confirm when Programmer is initialized."L];    IF NOT Confirmed[] THEN GOTO done;    Put.Text[data.fileSW, "Initializing..."L];    RS232CProlog.InitPromType[data.pMCode, heap];    image ¬ heap.NEW[ImageArray ¬ ALL[ALL[NIL]]];    ReadDotBinFile[stream: stream­, slices: data.slices, low: startAddress, high: endAddress];    Stream.Delete[stream­]; stream­ ¬ NIL;    IF data.debug THEN DisplayImage;  EXITS    done => {      Put.Line[data.fileSW, "Operation terminated at user's request"L];      ok ¬ FALSE;};  };  DotBinReadBackChecks: PROCEDURE [source, promData: LONG STRING]    RETURNS [ok: BOOLEAN] = {    sourceSSD: String.SubStringDescriptor ¬ [      base: source, offset: 0, length: source.length];    promDataSSD: String.SubStringDescriptor ¬ [      base: promData, offset: 9, length: source.length];    IF String.EqualSubString[@sourceSSD, @promDataSSD] THEN ok ¬ TRUE    ELSE ok ¬ FALSE;  };  VerifyDotBinSlice: PROCEDURE [slice: [0..3)] = {    block: LONG STRING ¬ [45];    ListingBlock: LONG STRING ¬ [60];    dataFound: BOOLEAN ¬ FALSE;    dataPos ¬ 0;    FOR j: CARDINAL IN [0..data.memSize/ stdLen) UNTIL abort DO      IF image[slice][j] # NIL OR data.list THEN {	block.length ¬ 0;	RS232CProlog.ReadBlock[	  startAddress: j*stdLen, block: block];	dataPos ¬ dataPos + RS232CProlog.HexSubStringToCardinal[block, 1, 2];	IF image[slice][j] # NIL AND NOT DotBinReadBackChecks[image[slice][j], block] THEN {	  Complain["Mismatched data"L];	  Put.Text[	    data.fileSW, "Data doesn't match starting in block at address "];	  Put.Number[data.fileSW, j*stdLen, hexFormat];	  Put.CR[data.fileSW];	  SIGNAL ReadBackError	};	IF image[slice][j] # NIL THEN dataFound ¬ TRUE;	IF data.list THEN {	  ListingFormat[block, ListingBlock];	  Put.Text[data.fileSW, ListingBlock]};      };    ENDLOOP;    IF NOT dataFound THEN {      Complain["No data found in specified address range"L];      SIGNAL ReadBackError};  };  DotBinVerify: PROCEDURE[stream: LONG POINTER TO MStream.Handle]  = {    ENABLE {      InvalidMemoryWidth, NonVirginProm, NoPromSpecs,        RS232CProlog.TransmissionAborted => GOTO exit;      ReadBackError => GOTO readBackFailed;      RS232CProlog.NegativeResponse => GOTO negativeResponse};      Put.Line[data.fileSW, "Verifying a DotBin file..."L];    IF NOT InitForBlowDotBin[stream] THEN RETURN;    dataLength ¬ dataLength / data.slices;  --  full when filled up this slice            FOR i: CARDINAL IN [0..data.slices) UNTIL abort DO      Put.Text[        data.fileSW, "Insert a PROM in the Copy socket for slice number "];      Put.Decimal[data.fileSW, i+1];      IF (i + 1) < data.slices THEN         Put.Line[	  data.fileSW, 	  ", Confirm! to verify prom or Deny! to skip to next slice."L]       ELSE Put.Line[data.fileSW, ", Confirm! to verify"L];      UserTerminal.Beep[frequency: 4000, duration: 500];      IF NOT Confirmed[] THEN IF (i + 1) < data.slices THEN LOOP ELSE EXIT;      Put.Text[data.fileSW, "Verifying..."L];      RS232CProlog.CopyPromToProgrammerBuffer;      VerifyDotBinSlice[slice: i];      Put.Line[data.fileSW, "Prom matches slice of image in file."L];    ENDLOOP;    Put.Line[data.fileSW, "Done."L];  EXITS    exit => NULL;    readBackFailed => Complain["Abnormal exit: Read back check failed."];    negativeResponse =>      Complain["Abnormal exit:  Negative response from PROM Programmer."];  };     CheckVirginity: PROCEDURE = {    OPEN RS232CProlog, String;    ENABLE TransmissionAborted => GOTO exit;    startAddress: CARDINAL ¬ 0;    virgin: BOOLEAN ¬ TRUE;    vc: CHAR ¬ '0;    block: LONG STRING ¬ heap.NEW[StringBody [45]];    virginData: SubStringDescriptor ¬ [base: NIL, offset: 0, length: 32];    promData: SubStringDescriptor ¬ [base: NIL, offset: 9, length: 32];    SELECT data.virgin FROM      zeroes => {virginData.base ¬ "00000000000000000000000000000000"L; vc ¬ '0};      ones   => {virginData.base ¬ "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"L; vc ¬ 'F};      ENDCASE => ERROR;    DO      CopyPromToProgrammerBuffer;      WHILE (startAddress < data.memSize) AND (NOT abort) DO        RS232CProlog.ReadBlock[startAddress: startAddress, block: block];        IF data.width = 4 THEN -- have to clear high nibble	  FOR i:CARDINAL ¬ 9,i+2 WHILE i<block.length DO block[i] ¬ vc; ENDLOOP;        promData.base ¬ block;        IF NOT EqualSubString[@virginData, @promData] THEN {          virgin ¬ FALSE; EXIT};        block.length ¬ 0;  -- reInit block buffer        startAddress ¬ startAddress + stdLen;        ENDLOOP;      IF NOT virgin THEN {        Complain["Non virgin PROM"L];        Put.Text[          data.fileSW, "Prom contains data starting in block at address "];        Put.Number[data.fileSW, startAddress, hexFormat];        Put.Line[          data.fileSW,          " If you wish to load another PROM, please do so now, and Confirm!."L];        IF NOT Confirmed[] THEN SIGNAL NonVirginProm;	Put.Text[data.fileSW, "Checking Virginity..."L];        startAddress ¬ 0;        block.length ¬ 0;        }      ELSE EXIT;    ENDLOOP;    heap.FREE[@block];    IF virgin THEN Put.Line[data.fileSW, "PROM is virgin."L];  EXITS    exit =>      Complain["Abnormal exit from CheckVirginity: Transmission Aborted"L];  };  BlowDotBin: PROCEDURE [stream: LONG POINTER TO MStream.Handle] = {    ENABLE {      InvalidMemoryWidth, NonVirginProm, NoPromSpecs,        RS232CProlog.TransmissionAborted => GOTO exit;      ReadBackError => GOTO readBackFailed;      RS232CProlog.NegativeResponse => GOTO negativeResponse};    wroteBlock, ok: BOOLEAN ¬ FALSE;    intelHex: LONG STRING ¬ NIL;        Put.Line[data.fileSW, " Blowing a DotBin file..."L];    IF NOT (ok ¬ InitForBlowDotBin[stream]) THEN RETURN;    dataLength ¬ dataLength / data.slices;  --  full when filled up this slice        FOR i: CARDINAL IN [0..data.slices) UNTIL abort DO      Put.Text[        data.fileSW, "Insert a PROM in the Copy socket for slice number "];      Put.Decimal[data.fileSW, i+1];      IF i + 1 < data.slices THEN         Put.Line[	  data.fileSW, 	  ", Confirm! to burn prom or Deny! to skip to next slice."L]       ELSE Put.Line[data.fileSW, ", Confirm! when prom for last slice is ready."L];      UserTerminal.Beep[frequency: 4000, duration: 500];      IF NOT Confirmed[] THEN IF i + 1 < data.slices THEN LOOP ELSE GOTO done;      IF data.checkVirgin THEN {Put.Text[data.fileSW, "Checking Virginity..."L]; CheckVirginity};      Put.Text[data.fileSW, "Writing..."L];      dataPos ¬ 0;      FOR j: CARDINAL IN [0..maxPromSize/ stdLen) UNTIL abort DO        IF image[i][j] # NIL THEN {          wroteBlock ¬ TRUE;          intelHex ¬ RS232CProlog.IntelFormat[            address: 0, data: image[i][j], cs: GetCheckSum[image[i][j]], z: heap];          RS232CProlog.WriteBlock[              block: intelHex, startAddress: j*stdLen,	      length:image[i][j].length/2];	  dataPos ¬ dataPos + RS232CProlog.HexSubStringToCardinal[intelHex, 1, 2];        };      ENDLOOP;      IF wroteBlock THEN {	Put.Text[data.fileSW, "Verifying..."L];	RS232CProlog.CopyPromToProgrammerBuffer;	VerifyDotBinSlice[slice: i];	Put.Line[data.fileSW, "Slice is complete."L]}      ELSE EXIT;    ENDLOOP;    IF NOT wroteBlock THEN Complain["No data found in specified address range"L];    Put.Line[data.fileSW, "Done."L];    UserTerminal.Beep[frequency: 400, duration: 300];    UserTerminal.Beep[frequency: 500, duration: 450];  EXITS    done => Put.Line[data.fileSW, "Operation terminated at user's request"L];    exit => NULL;    readBackFailed => Complain["Abnormal exit: Read back check failed."];    negativeResponse =>      Complain["Abnormal exit:  Negative response from PROM Programmer."];  };-- Procedures to blow DotProm files-- DotPromToDotBin ReadBackChecks NextField BlowDotProm  DotPromToDotBin: PROCEDURE [    promStream: MStream.Handle, field: Fields, address: CARDINAL]    RETURNS [      intelHex: LONG STRING ¬ NIL, newAddress: CARDINAL ¬ 0,      eof: BOOLEAN ¬ FALSE] = {    maxRecLength: CARDINAL = 32;    DataString: LONG STRING ¬ [maxRecLength];    startAddress: CARDINAL ¬ 0;    MachineWord: TYPE = MACHINE DEPENDENT RECORD [      SELECT OVERLAID * FROM      bytes => [byte: PACKED ARRAY Fields [FirstByte..SecondByte] OF [0..256)],      nibbles => [        nibble: PACKED ARRAY Fields [FirstNibble..FourthNibble] OF [0..16)],      ENDCASE];    checkSum, byte, inWord: CARDINAL ¬ 0;    machineWord: MachineWord;    IF field = AllBits THEN      SELECT data.width FROM        4 => field ¬ FirstNibble;        8 => field ¬ FirstByte;        ENDCASE => GO TO memSizeError;    startAddress ¬ address;    DO      inWord ¬ Stream.GetWord[        promStream ! Stream.EndOfStream => {eof ¬ TRUE; EXIT}];      dataPos ¬ dataPos + 2;      machineWord ¬ LOOPHOLE[inWord];      SELECT field FROM        FirstByte, SecondByte => byte ¬ machineWord.byte[field];        FirstNibble, SecondNibble, ThirdNibble, FourthNibble =>          byte ¬ machineWord.nibble[field];        ENDCASE => ERROR;      address ¬ address + 1;      checkSum ¬ checkSum + byte;      RS232CProlog.AppendHexNumber[DataString, byte, 2];      IF DataString.length = maxRecLength THEN EXIT;      ENDLOOP;    IF DataString.length = 0 THEN RETURN;    intelHex ¬ RS232CProlog.IntelFormat[      address: 0, data: DataString, cs: checkSum, z: heap];    newAddress ¬ address  EXITS    memSizeError => {      Complain[msg: "Error: Memory width must be 4 or 8."L];      SIGNAL InvalidMemoryWidth;      };  };    ReadBackChecks: PROCEDURE [s1, s2: LONG STRING] RETURNS [BOOLEAN] = {    ssd1: String.SubStringDescriptor ¬ [base: s1, offset: 9, length: 32];    ssd2: String.SubStringDescriptor ¬ [base: s2, offset: 9, length: 32];    IF data.width = 4 THEN      FOR i: CARDINAL IN [9..s2.length) DO IF i MOD 2 = 1 THEN s2[i] ¬ '0 ENDLOOP;    RETURN[String.EqualSubString[@ssd1, @ssd2]];  };  NextField: PROCEDURE [field: Fields, imageWidth: CARDINAL] RETURNS [BOOLEAN] = {    IF field = SecondByte OR field = FourthNibble THEN RETURN[FALSE]    ELSE {      field ¬ SUCC[field];      SELECT imageWidth FROM        1, 2, 3, 4 => RETURN[FALSE];        5, 6, 7, 8 => RETURN[field = SecondNibble];        9, 10, 11, 12 =>          SELECT field FROM            SecondNibble, ThirdNibble, SecondByte => RETURN[TRUE];            ENDCASE => RETURN[FALSE];        13, 14, 15, 16 => RETURN[TRUE];      ENDCASE => ERROR;    };  };  BlowDotProm: PROCEDURE [imageStream: LONG POINTER TO MStream.Handle, isVerify: BOOL] = {    OPEN data;    block: LONG STRING ¬ heap.NEW[StringBody [45]];    ListingBlock: LONG STRING ¬ heap.NEW[StringBody [60]];    BEGIN ENABLE {      InvalidMemoryWidth, NonVirginProm, NoPromSpecs => GOTO nullExit;      RS232CProlog.TransmissionAborted => GOTO aborted;      RS232CProlog.NegativeResponse => GOTO negativeResponse;      UNWIND => {        IF imageStream­ # NIL THEN {Stream.Delete[imageStream­]; imageStream­ ¬ NIL};        heap.FREE[@block]; heap.FREE[@ListingBlock]};    };    eof, readBack: BOOLEAN ¬ FALSE;    intelHex: LONG STRING;    address, newAddress: CARDINAL ¬ 0;    imageWidth: CARDINAL ¬ Stream.GetWord[imageStream­];        IF isVerify THEN {Put.Line[fileSW, "Verifying a DotProm file..."L]}    ELSE Put.Line[fileSW, "Blowing a DotProm file..."L];    Put.Line[data.fileSW, "Confirm! when Programmer is initialized."L];    IF NOT Confirmed[] THEN GOTO exit;    Put.Text[data.fileSW, "Initializing..."L];    GetPromSpec[name: chip];    RS232CProlog.InitPromType[data.pMCode, heap];    IF isVerify THEN {RS232CProlog.CopyPromToProgrammerBuffer; readBack ¬ TRUE};    dataLength ¬ dataLength / data.slices;    UNTIL abort DO      IF NOT (readBack OR isVerify) AND checkVirgin THEN {Put.Text[fileSW, "Checking Virginity..."L]; CheckVirginity};      Stream.SetPosition[imageStream­, 4]; dataPos ¬ 0;  -- skip first 2 words      IF readBack OR isVerify         THEN Put.Text[fileSW, "Verifying..."L]         ELSE Put.Text[fileSW, "Burning..."L];      UNTIL abort DO        [intelHex, newAddress, eof] ¬ DotPromToDotBin[          promStream: imageStream­, field: field, address: address];        IF intelHex = NIL THEN EXIT;        IF readBack OR isVerify THEN {          RS232CProlog.ReadBlock[startAddress: address, block: block];          IF NOT ReadBackChecks[intelHex, block] THEN {	    Complain["Mismatched data"L];            Put.Text[              data.fileSW, "Data doesn't match starting in block at address "];            Put.Number[data.fileSW, address, hexFormat];            Put.CR[data.fileSW];            GOTO readBackFailed};          IF list THEN {            ListingFormat[block, ListingBlock]; Put.Text[fileSW, ListingBlock]};          }        ELSE RS232CProlog.WriteBlock[intelHex, address, newAddress - address];        block.length ¬ 0;  -- reInit block buffer        heap.FREE[@intelHex];        IF eof THEN EXIT;        address ¬ newAddress;      ENDLOOP;      IF NOT readBack THEN {        readBack ¬ TRUE;        address ¬ 0;        RS232CProlog.CopyPromToProgrammerBuffer;        LOOP};      IF isVerify THEN Put.Line[fileSW, "Source file and PROM match."L]      ELSE Put.Line[fileSW, "Slice is complete."L];      address ¬ 0;      IF NOT NextField[field, imageWidth] THEN EXIT;      UserTerminal.Beep[frequency: 4000, duration: 500];      Put.Line[fileSW, "Confirm! to blow or verify the next field."];      IF NOT Confirmed[] THEN EXIT;      field ¬ SUCC[field];      FormSW.DisplayItem[formSW, FormItems[field].ORD];    ENDLOOP;    Stream.Delete[imageStream­]; imageStream­ ¬ NIL;    heap.FREE[@block];    heap.FREE[@ListingBlock];    UserTerminal.Beep[frequency: 400, duration: 300];    UserTerminal.Beep[frequency: 500, duration: 450];  EXITS    exit => Complain["Operation terminated at user's request."L];    readBackFailed => Complain["Abnormal exit: Read back check failed."L];    nullExit => NULL;    aborted => Complain["Abnormal exit: Transmission aborted"L];    negativeResponse =>      Complain["Abnormal exit:  Negative response from PROM Programmer."L];  END;  };  BlowDotBinOrDotProm: PUBLIC PROCEDURE [s: LONG STRING, isVerify: BOOL] = {    << This procedure gets a stream handle for the root file name trying first      the .bin extension then the .prom extension, unless they explicitly      specify one or the other.  The appropriate procedure      is then called to program the file's contents into the PROM >>    file,ext: LONG STRING ¬ NIL;    bin: LONG STRING = ".bin"L;    hex: LONG STRING = ".hex"L;    prom: LONG STRING = ".prom"L;    stream: MStream.Handle ¬ NIL;    found: BOOLEAN ¬ FALSE;    DeleteExtension: PROC [name: LONG STRING] RETURNS [ext: LONG STRING] = {      ext ¬ String.MakeString[heap, 0];      IF name = NIL THEN RETURN;      FOR index: CARDINAL IN [0..name.length) DO	IF name[index] = '. THEN {	  String.FreeString[heap,ext];	  ext ¬ String.MakeString[heap, name.length - index];	  ext.length ¬ name.length - index;	  FOR i: CARDINAL IN [index..name.length) DO	    ext[i-index] ¬ name[i];	  ENDLOOP;	  name.length ¬ index; 	  RETURN[ext]};       ENDLOOP;    };          GetStreamHandle: PROC [ext: LONG STRING] RETURNS [found: BOOLEAN ¬ FALSE] =    {      ENABLE UNWIND => heap.FREE[@file];      file ¬ String.CopyToNewString[s, heap];      [] ¬ String.AppendExtensionIfNeeded[@file, ext, heap];      stream ¬ MStream.ReadOnly[name: file, release: []];      data.fileName.length ¬ 0;      String.AppendStringAndGrow[	to: @data.fileName, from: file, z: heap];      found ¬ TRUE;      heap.FREE[@file];    };        BEGIN      IF String.Empty[s] THEN {	Complain["No file name given."L]; isBusy ¬ FALSE; RETURN};      ext ¬ DeleteExtension[s];      IF found ¬ GetStreamHandle[ext ! MStream.Error => CONTINUE] THEN {	SELECT TRUE FROM	  String.Equivalent[ext,bin] => GOTO doBin;	  String.Equivalent[ext,hex] => GOTO doBin;	  String.Equivalent[ext,prom] => GOTO doProm;	ENDCASE => Complain["Unknown filetype."L];	RETURN;      };      IF found ¬ GetStreamHandle[".bin"L ! MStream.Error => CONTINUE]	THEN GOTO doBin;      IF found ¬ GetStreamHandle[".hex"L ! MStream.Error => CONTINUE]	THEN GOTO doBin;      IF found ¬ GetStreamHandle[".prom"L ! MStream.Error => CONTINUE]	THEN GOTO doProm;      Complain["File not found."L];     EXITS      doBin => {        dataPos ¬ 0;	dataLength ¬ 0;	IF isVerify THEN DotBinVerify[stream: @stream] 		    ELSE BlowDotBin[stream: @stream];	FreeImage};      doProm => {        dataPos ¬ 0;	dataLength ¬ MStream.GetLength[stream] - 4;  -- skip first 2 words	BlowDotProm[imageStream: @stream, isVerify: isVerify];	FreeImage};    END;    isBusy ¬ FALSE;  };-- Procedures to read the PROM-- ReadProgrammerBuffer  ReadProgrammerBuffer: PUBLIC PROCEDURE = {    ENABLE {      NoPromSpecs => GOTO error;      RS232CProlog.TransmissionAborted => GOTO aborted;      RS232CProlog.NegativeResponse => GOTO badResponse;    };        block: LONG STRING ¬ heap.NEW[StringBody [45]];    ListingBlock: LONG STRING ¬ heap.NEW[StringBody [60]];    startAddress: CARDINAL ¬ 0;    Put.Line[data.fileSW, "Confirm when Programmer is initialized."L];    IF NOT Confirmed[] THEN GOTO exit;    Put.Text[data.fileSW, "Initializing..."L];    GetPromSpec[name: data.chip];    Put.Text[data.fileSW, "Reading PROM..."L];    RS232CProlog.InitPromType[data.pMCode, heap];    RS232CProlog.CopyPromToProgrammerBuffer;    WHILE startAddress < data.memSize DO      RS232CProlog.ReadBlock[startAddress: startAddress, block: block];      ListingFormat[block, ListingBlock];      Put.Text[data.fileSW, ListingBlock];      block.length ¬ 0;  -- reInit block buffer      startAddress ¬ startAddress + stdLen;    ENDLOOP;    heap.FREE[@block];    heap.FREE[@ListingBlock];    UserTerminal.Beep[frequency: 400, duration: 300];    UserTerminal.Beep[frequency: 500, duration: 450];    Put.Line[data.fileSW, "Done."L];    isBusy ¬ FALSE;  EXITS    error => {Complain["Abnormal exit: no Prom Specs"L]; isBusy ¬ FALSE};    exit => {Complain["READ terminated at user's request"L]; isBusy ¬ FALSE};    aborted => {Complain["Abnormal exit: Transmission Aborted"L]; isBusy ¬ FALSE};    badResponse => {Complain[      "Abnormal exit: negative response from Prom Programmer."L]; isBusy ¬ FALSE};  }; }...  
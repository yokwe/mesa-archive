-- BandBLTTest.mesa-- Created by FormSWLayoutTool on 24-Jul-86 19:33-- Last edited by CRF, 16-Sep-86 17:19:40DIRECTORY  BandBLT,  BandBLTVersion,  BandLists,  Display,  Environment,  Exec,  Format,  FormSW,  Heap,  Inline,  MSegment,  MsgSW,  Process,  Put,  Space,  Tool,  ToolWindow,  VM,  Window,  WindowFont;BandBLTTest: MONITOR  IMPORTS    BandBLT, BandBLTVersion, Display, Exec, FormSW, Heap, Inline, MSegment,    MsgSW, Process, Put, Space, Tool, ToolWindow, VM, Window, WindowFont = {  BandListID: TYPE = MACHINE DEPENDENT {A(0), B, C, D, E, F, G, H};  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = MACHINE DEPENDENT RECORD [    msgSW(0): Window.Handle ¬ NIL,    formSW(2): Window.Handle ¬ NIL,    displaySW(4): Window.Handle ¬ NIL,    bandList(6): BandListID ¬ A,    x(7): CARDINAL ¬ defaultX,    xLength(8): CARDINAL ¬ defaultXLength,    y(9): CARDINAL ¬ defaultY,    yLength(10): CARDINAL ¬ defaultYLength,    bandListLoaded(11): BandListID ¬ A,    bandListBase(12): LONG POINTER ¬ NIL,    stopAuto(14): BOOLEAN ¬ TRUE,    version(15): BandBLTVersion.Version ¬ unknown,    bandBLTTablePtr(16): BandBLT.BandBLTTablePtr ¬ NIL];  FormItems: TYPE = {bandBLT, mesaBandBLT, clearDisplay, setDefaults,    checkTrapezoids, startAuto, stopAuto, portiontobedisplayed, x, xLength, y,    yLength, bandList};  bandBufferPages: CARDINAL = Inline.LowHalf[BandBLT.bandBufferSize];  bandListPages: CARDINAL = 2;  bandListWordSize: CARDINAL = bandListPages * Environment.wordsPerPage;  bbTableSpace: BandBLT.BBTableSpace;  bitsPerScanLine: CARDINAL = Environment.bitsPerWord * wordsPerScanLine;  busyBit: BOOLEAN ¬ FALSE;  charWidth: CARDINAL ¬ WindowFont.CharWidth['0];  data: DataHandle ¬ NIL;  defaultX: CARDINAL = 0;  defaultXLength: CARDINAL = 300;  defaultY: CARDINAL = 0;  defaultYLength: CARDINAL = 500;  initialBox: Window.Box = [place: [x:0, y: 30], dims: [w: 512, h: 624]];  maxX, maxY: CARDINAL = bitsPerScanLine - 1;  scanLinesPerBand: CARDINAL = bandBufferPages;  wh: Window.Handle ¬ NIL;  wordsPerScanLine: CARDINAL = Environment.wordsPerPage;  zone: UNCOUNTED ZONE ¬ Heap.Create[initial: 4];  Activate: Exec.ExecProc = {    IF ToolWindow.GetState[wh] = inactive THEN ToolWindow.Activate[wh]};  AllocateBandBuffer: PROCEDURE RETURNS [ptr: LONG POINTER] = {    Crosses64K: PROCEDURE [ptr: LONG POINTER] RETURNS [result: BOOLEAN] = {      bandBufferWdSize: CARDINAL = bandBufferPages * Environment.wordsPerPage;      maxOffsetIn64KBank: CARDINAL = (LAST[CARDINAL] - bandBufferWdSize) + 1;      RETURN[Inline.LowHalf[ptr] > maxOffsetIn64KBank];      };    ptr ¬ MSegment.GetPages[bandBufferPages];    IF Crosses64K[ptr] THEN {      tempPtr: LONG POINTER ¬ ptr;      ptr ¬ AllocateBandBuffer[];      MSegment.FreePages[tempPtr]};    };  AllocateStorage: PROCEDURE = {    OPEN d: data.bandBLTTablePtr;    IF data = NIL THEN {      data ¬ zone.NEW[Data ¬ []];      data.bandBLTTablePtr ¬ BandBLT.AlignedBandBLTTable[@bbTableSpace];      d.readLO ¬ Inline.LowHalf[        Space.PageFromLongPointer[MSegment.GetPages[bandListPages]]];      d.bandlist ¬ data.bandListBase ¬ MSegment.GetPages[bandListPages];      d.writeLO ¬ Inline.LowHalf[        Space.PageFromLongPointer[MSegment.GetPages[bandListPages]]];      d.bandbuf ¬ AllocateBandBuffer[];      d.fontPtrTbl ¬        Inline.LowHalf[Space.PageFromLongPointer[MSegment.GetPages[1]]];      d.fontRasters ¬        Inline.LowHalf[Space.PageFromLongPointer[MSegment.GetPages[1]]];      d.inkwells ¬        Inline.LowHalf[Space.PageFromLongPointer[MSegment.GetPages[1]]];      VM.MakeResident[VM.FindMapUnit[d.readLO], wait];      VM.MakeResident[        VM.FindMapUnit[Space.PageFromLongPointer[d.bandlist]], wait];      VM.MakeResident[VM.FindMapUnit[d.writeLO], wait];      VM.MakeResident[VM.FindMapUnit[Space.PageFromLongPointer[d.bandbuf]], wait];      VM.MakeResident[VM.FindMapUnit[d.fontPtrTbl], wait];      VM.MakeResident[VM.FindMapUnit[d.fontRasters], wait];      VM.MakeResident[VM.FindMapUnit[d.inkwells], wait]};      LoadBandListA[];    };  BandBLTIt:  FormSW.ProcType = {    ENABLE ABORTED => {Done[]; CONTINUE};    SELECT TRUE FROM      Busy[] => Msg["Tool is busy.\n"L];      (data.version = trapezoidsImplemented) OR      (data.version = trapezoidsSkipped) => {        MsgSW.Clear[data.msgSW];        Process.Detach[FORK BandBLTItInternal[]]};      (data.version = preTrapezoid) => {        Msg["Sorry, can't do that; microcode is pre-trapezoid.\n"L];	Done[] };      (data.version = unknown) => {        Msg["Sorry, can't do that; microcode version unknown!\n"L];	Done[] };      ENDCASE => ERROR;    };  BandBLTItInternal: PROCEDURE [mesaVersion: BOOLEAN ¬ FALSE] = {    ENABLE ABORTED => {Done[]; CONTINUE};    BandBLTItSub[mesaVersion];    Done[] };  BandBLTItSub: PROCEDURE [mesaVersion: BOOLEAN ¬ FALSE] = {    OPEN d: data.bandBLTTablePtr;    ReadLO: TYPE = MACHINE DEPENDENT RECORD [      eob: endOfBand BandBLT.BlItem ¬ [endOfBand[]]];    readLO: ReadLO ¬ [];    xScanNumber: CARDINAL ¬ 0;    CheckXandY[];    ClearDisplaySW[];    Inline.LongCOPY[from: @readLO, nwords: SIZE[ReadLO],      to: Space.LongPointerFromPage[d.readLO]];  -- clear input leftover list    d.bandlist ¬ data.bandListBase;    UNTIL d.bandlist = NIL DO      temp: BandBLT.PageNumber;      ClearBandBuffer[];      d.bandlist ¬        IF mesaVersion THEN BandBLT.SoftwareBandBLT[data.bandBLTTablePtr]        ELSE BandBLT.BandBLT[data.bandBLTTablePtr];      IF d.bandlist # NIL THEN        d.bandlist ¬ d.bandlist + SIZE[endOfBand BandBLT.BlItem];      temp ¬ d.readLO;      d.readLO ¬ d.writeLO;      d.writeLO ¬ temp;      UpdateDisplay[xScanNumber];      xScanNumber ¬ xScanNumber + bandBufferPages;      ENDLOOP;    };  Busy: ENTRY PROCEDURE RETURNS [isBusy: BOOLEAN] = {    ENABLE UNWIND => NULL;    isBusy ¬ busyBit;    busyBit ¬ TRUE };  CharPos: PROC[char: CARDINAL] RETURNS [x: INTEGER] = {    x ¬ charWidth * char};  CheckTrapezoids:  FormSW.ProcType = {    ENABLE ABORTED => {Done[]; CONTINUE};    IF Busy[] THEN {      Msg["Tool is busy.\n"L];      RETURN};    Process.Detach[FORK CheckTrapezoidsInternal[]]};  CheckTrapezoidsInternal: PROCEDURE = {    ENABLE ABORTED => {Done[]; CONTINUE};    data.version ¬ BandBLTVersion.Check[];    Msg["Microcode "L];    SELECT data.version FROM      preTrapezoid => Msg["is pre-trapezoid.\n"L];      trapezoidsImplemented => Msg["implements trapezoids.\n"L];      trapezoidsSkipped => Msg["skips over trapezoid band list entries.\n"L];      unknown => Msg["version unknown!\n"L];      ENDCASE => ERROR;    Done[] };  CheckXandY: PROCEDURE = {    IF data.x > maxX THEN {      data.x ¬ defaultX;      FormSW.DisplayItem[data.formSW, FormItems.x.ORD];      Msg["x too large, reset to default\n"L]};    IF (data.x + data.xLength - 1) > maxX THEN {      data.x ¬ defaultX;      data.xLength ¬ defaultXLength;      FormSW.DisplayItem[data.formSW, FormItems.x.ORD];      FormSW.DisplayItem[data.formSW, FormItems.xLength.ORD];      Msg["x or xLength too large, reset to defaults\n"L]};    IF data.y > maxY THEN {      data.y ¬ defaultY;      FormSW.DisplayItem[data.formSW, FormItems.y.ORD];      Msg["y too large, reset to default\n"L]};    IF (data.y + data.yLength - 1) > maxY THEN {      data.y ¬ defaultY;      data.yLength ¬ defaultYLength;      FormSW.DisplayItem[data.formSW, FormItems.y.ORD];      FormSW.DisplayItem[data.formSW, FormItems.yLength.ORD];      Msg["y or yLength too large, reset to defaults\n"L]};    };  ClearBandBuffer: PROCEDURE = {    OPEN d: data.bandBLTTablePtr;    d.bandbuf­ ¬ 0;    Inline.LongCOPY[      from: d.bandbuf,      nwords: (Environment.wordsPerPage * bandBufferPages) - 1,      to: d.bandbuf + 1];    };  ClearDisplay:  FormSW.ProcType = {    ENABLE ABORTED => {Done[]; CONTINUE};    IF Busy[] THEN {      Msg["Tool is busy.\n"L]; RETURN};    Process.Detach[FORK ClearDisplayInternal[]]};  ClearDisplayInternal: PROCEDURE = {    ENABLE ABORTED => {Done[]; CONTINUE};    MsgSW.Clear[data.msgSW];    ClearDisplaySW[];    Done[] };  ClearDisplaySW: PROCEDURE = {    whiteBrick: ARRAY [0..1) OF CARDINAL ¬ [0];    Display.Gray[data.displaySW, [[0,0], Window.GetBox[data.displaySW].dims],      DESCRIPTOR[whiteBrick], null];    };  ClientTransition: ToolWindow.TransitionProcType = {    SELECT TRUE FROM      old = inactive => {        AllocateStorage[]; data.version ¬ BandBLTVersion.Check[]};      new = inactive => FreeStorage[];      ENDCASE;    };  Done: ENTRY PROCEDURE = {    ENABLE UNWIND => NULL;    busyBit ¬ FALSE};  FreeStorage: PROCEDURE = {    OPEN d: data.bandBLTTablePtr;    IF data # NIL THEN {      VM.MakeSwappable[VM.FindMapUnit[d.readLO]];      VM.MakeSwappable[VM.FindMapUnit[Space.PageFromLongPointer[        data.bandListBase]]];      VM.MakeSwappable[VM.FindMapUnit[d.writeLO]];      VM.MakeSwappable[VM.FindMapUnit[Space.PageFromLongPointer[d.bandbuf]]];      VM.MakeSwappable[VM.FindMapUnit[d.fontPtrTbl]];      VM.MakeSwappable[VM.FindMapUnit[d.fontRasters]];      VM.MakeSwappable[VM.FindMapUnit[d.inkwells]];      MSegment.FreePages[Space.LongPointerFromPage[d.readLO]];      MSegment.FreePages[data.bandListBase];      MSegment.FreePages[Space.LongPointerFromPage[d.writeLO]];      MSegment.FreePages[d.bandbuf];      MSegment.FreePages[Space.LongPointerFromPage[d.fontPtrTbl]];      MSegment.FreePages[Space.LongPointerFromPage[d.fontRasters]];      MSegment.FreePages[Space.LongPointerFromPage[d.inkwells]];      zone.FREE[@data]}    };  Init: PROCEDURE = {    Exec.AddCommand[name: "BandBLTTestTool.~"L, proc: Activate, unload: Unload];    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: inactive, initialBox: initialBox,      clientTransition: ClientTransition, name: "BandBLTTestTool"L,      cmSection: "BandBLTTestTool"L];    };  LoadBandListA: PROCEDURE = {  << Simple case: vanilla trapezoid that crosses band boundaries but the band     list item does not cross a page boundary.>>    OPEN d: data.bandBLTTablePtr;    bandList: BandLists.A ¬ [];    Inkwell: TYPE = ARRAY [0..16) OF CARDINAL;    inkwell: Inkwell ¬ [125252B, 52525B, 125252B, 52525B,      125252B, 52525B, 125252B, 52525B, 125252B, 52525B, 125252B, 52525B,      125252B, 52525B, 125252B, 52525B];    IF SIZE[BandLists.A] > bandListWordSize THEN ERROR;    Inline.LongCOPY[      from: @bandList, nwords: SIZE[BandLists.A], to: data.bandListBase];    Inline.LongCOPY[from: @inkwell, nwords: SIZE[Inkwell],      to: Space.LongPointerFromPage[d.inkwells]];    data.bandListLoaded ¬ A;    };  LoadBandListB: PROCEDURE = {  << Band list A plus some rectangles for regression testing.>>    OPEN d: data.bandBLTTablePtr;    bandList: BandLists.B ¬ [];    Inkwell: TYPE = ARRAY [0..16) OF CARDINAL;    inkwell: Inkwell ¬ [125252B, 52525B, 125252B, 52525B,      125252B, 52525B, 125252B, 52525B, 125252B, 52525B, 125252B, 52525B,      125252B, 52525B, 125252B, 52525B];    IF SIZE[BandLists.B] > bandListWordSize THEN ERROR;    Inline.LongCOPY[      from: @bandList, nwords: SIZE[BandLists.B], to: data.bandListBase];    Inline.LongCOPY[from: @inkwell, nwords: SIZE[Inkwell],      to: Space.LongPointerFromPage[d.inkwells]];    data.bandListLoaded ¬ B;    };  LoadBandListC: PROCEDURE = {  << Trapezoid band list item 0 crosses a page boundary, the first word in one     page and the other nine in the next page.  Trapezoid 1 is a triangle.>>    OPEN d: data.bandBLTTablePtr;    bandList: BandLists.C ¬ [];    Inkwell: TYPE = ARRAY [0..16) OF CARDINAL;    inkwell: Inkwell ¬ [125252B, 52525B, 125252B, 52525B,      125252B, 52525B, 125252B, 52525B, 125252B, 52525B, 125252B, 52525B,      125252B, 52525B, 125252B, 52525B];    IF SIZE[BandLists.C] > bandListWordSize THEN ERROR;    Inline.LongCOPY[      from: @bandList, nwords: SIZE[BandLists.C], to: data.bandListBase];    Inline.LongCOPY[from: @inkwell, nwords: SIZE[Inkwell],      to: Space.LongPointerFromPage[d.inkwells]];    data.bandListLoaded ¬ C;    };  LoadBandListD: PROCEDURE = {  << Trapezoid band list item 0 crosses a page boundary, the first five words in     one page and the other five in the next page.  Trapezoid 1 is a one bit wide     diagonal line with a slope of one half, that is, with non-zero fractional     dVals.  Trapezoids 2 and 3 are triangles, the latter with a black inkwell.>>    OPEN d: data.bandBLTTablePtr;    bandList: BandLists.D ¬ [];    Inkwell: TYPE = ARRAY [0..16) OF CARDINAL;    inkwellCount: CARDINAL = 3;    inkwells: ARRAY [0..inkwellCount) OF Inkwell ¬ [      [104210B, 104210B, 21042B, 21042B, 104210B, 104210B, 21042B, 21042B,      104210B, 104210B, 21042B, 21042B, 104210B, 104210B, 21042B, 21042B],      ALL[177777B],      [125252B, 52525B, 125252B, 52525B, 125252B, 52525B, 125252B, 52525B,      125252B, 52525B, 125252B, 52525B, 125252B, 52525B, 125252B, 52525B]];    IF SIZE[BandLists.D] > bandListWordSize THEN ERROR;    Inline.LongCOPY[      from: @bandList, nwords: SIZE[BandLists.D], to: data.bandListBase];    Inline.LongCOPY[from: @inkwells, nwords: (SIZE[Inkwell] * inkwellCount),      to: Space.LongPointerFromPage[d.inkwells]];    data.bandListLoaded ¬ D;    };  LoadBandListE: PROCEDURE = {  << Butts a rectangle up against a trapezoid to make sure the grays are     aligned.>>    OPEN d: data.bandBLTTablePtr;    bandList: BandLists.E ¬ [];    Inkwell: TYPE = ARRAY [0..16) OF CARDINAL;    inkwell: Inkwell ¬      [170360B, 160741B, 141703B, 103607B, 103607B, 141703B, 160741B, 170360B,      170360B, 160741B, 141703B, 103607B, 103607B, 141703B, 160741B, 170360B];    IF SIZE[BandLists.E] > bandListWordSize THEN ERROR;    Inline.LongCOPY[      from: @bandList, nwords: SIZE[BandLists.E], to: data.bandListBase];    Inline.LongCOPY[from: @inkwell, nwords: SIZE[Inkwell],      to: Space.LongPointerFromPage[d.inkwells]];    data.bandListLoaded ¬ E;    };  LoadBandListF: PROCEDURE = {  << Butts two trapezoids up against each other to make sure the grays are     aligned.>>    OPEN d: data.bandBLTTablePtr;    bandList: BandLists.F ¬ [];    Inkwell: TYPE = ARRAY [0..16) OF CARDINAL;    inkwell: Inkwell ¬       [170360B, 160741B, 141703B, 103607B, 103607B, 141703B, 160741B, 170360B,      170360B, 160741B, 141703B, 103607B, 103607B, 141703B, 160741B, 170360B];    IF SIZE[BandLists.F] > bandListWordSize THEN ERROR;    Inline.LongCOPY[      from: @bandList, nwords: SIZE[BandLists.F], to: data.bandListBase];    Inline.LongCOPY[from: @inkwell, nwords: SIZE[Inkwell],      to: Space.LongPointerFromPage[d.inkwells]];    data.bandListLoaded ¬ F;    };  LoadBandListG: PROCEDURE = {  << Tests all the source and destination functions.>>    OPEN d: data.bandBLTTablePtr;    bandList: BandLists.G ¬ [];    Inkwell: TYPE = ARRAY [0..16) OF CARDINAL;    inkwell: Inkwell ¬ [125252B, 52525B, 125252B, 52525B,      125252B, 52525B, 125252B, 52525B, 125252B, 52525B, 125252B, 52525B,      125252B, 52525B, 125252B, 52525B];    IF SIZE[BandLists.G] > bandListWordSize THEN ERROR;    Inline.LongCOPY[      from: @bandList, nwords: SIZE[BandLists.G], to: data.bandListBase];    Inline.LongCOPY[from: @inkwell, nwords: SIZE[Inkwell],      to: Space.LongPointerFromPage[d.inkwells]];    data.bandListLoaded ¬ G;    };  LoadBandListH: PROCEDURE = {  << Produces a trapezoid leftover item that crosses a page boundary.>>    OPEN d: data.bandBLTTablePtr;    bandListPtr: LONG POINTER ¬ data.bandListBase;    bandListSuffix: BandLists.HSuffix ¬ [];    Inkwell: TYPE = ARRAY [0..16) OF CARDINAL;    inkwell: Inkwell ¬ [125252B, 52525B, 125252B, 52525B,      125252B, 52525B, 125252B, 52525B, 125252B, 52525B, 125252B, 52525B,      125252B, 52525B, 125252B, 52525B];    trapezoidTemplate: trapezoid BandBLT.BlItem ¬ [trapezoid[        xloc: 0, nScans: 65,	yMin:	  [val: [parts[int: 0, frac: 0]], dVal: [parts[int: 1, frac: 0]]],	yMax:	  [val: [parts[int: 1, frac: 0]], dVal: [parts[int: 1, frac: 0]]]]];    spaceForTraps: CARDINAL =       trapezoidsPerPagePlus1 * SIZE[trapezoid BandBLT.BlItem];    trapezoidsPerPagePlus1: CARDINAL =      (Environment.wordsPerPage / SIZE[trapezoid BandBLT.BlItem]) + 1;    IF spaceForTraps + SIZE[BandLists.HSuffix]  > bandListWordSize THEN ERROR;    FOR t: CARDINAL IN [0..trapezoidsPerPagePlus1) DO      Inline.LongCOPY[        from: @trapezoidTemplate, nwords: SIZE[trapezoid BandBLT.BlItem],        to: bandListPtr];      trapezoidTemplate.xloc ¬ (trapezoidTemplate.xloc + 1) MOD scanLinesPerBand;      trapezoidTemplate.yMin.val.int ¬ trapezoidTemplate.yMin.val.int + 5;      trapezoidTemplate.yMax.val.int ¬ trapezoidTemplate.yMax.val.int + 5;      bandListPtr ¬ bandListPtr + SIZE[trapezoid BandBLT.BlItem];      ENDLOOP;    Inline.LongCOPY[      from: @bandListSuffix, nwords: SIZE[BandLists.HSuffix], to: bandListPtr];    Inline.LongCOPY[from: @inkwell, nwords: SIZE[Inkwell],      to: Space.LongPointerFromPage[d.inkwells]];    data.bandListLoaded ¬ H;    };  MakeForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = FormItems.LAST.ORD + 1;    bandList: ARRAY[0..BandListID.LAST.ORD] OF Enumerated ¬ [      ["A"L, BandListID.A], ["B"L, BandListID.B],      ["C"L, BandListID.C], ["D"L, BandListID.D],      ["E"L, BandListID.E], ["F"L, BandListID.F],      ["G"L, BandListID.G], ["H"L, BandListID.H]];    items ¬ AllocateItemDescriptor[nItems, zone];    items[FormItems.bandBLT.ORD] ¬ CommandItem[      tag: "BandBLT"L, place: [CharPos[1], line0], proc: BandBLTIt, z: zone];    items[FormItems.mesaBandBLT.ORD] ¬ CommandItem[      tag: "MesaBandBLT"L, place: [CharPos[11], line0], proc: MesaBandBLTIt,      z: zone];    items[FormItems.clearDisplay.ORD] ¬ CommandItem[      tag: "ClearDisplay"L, place: [CharPos[25], line0], proc: ClearDisplay,      z: zone];    items[FormItems.setDefaults.ORD] ¬ CommandItem[      tag: "SetDefaults"L, place: [CharPos[40], line0], proc: SetDefaults,      z: zone];    items[FormItems.checkTrapezoids.ORD] ¬ CommandItem[      tag: "CheckTrapezoids"L, place: [CharPos[54], line0],      proc: CheckTrapezoids, z: zone];    items[FormItems.startAuto.ORD] ¬ CommandItem[      tag: "StartAuto"L, invisible: FALSE, place: [CharPos[72], line0],      proc: StartAuto, z: zone];    items[FormItems.stopAuto.ORD] ¬ CommandItem[      tag: "StopAuto"L, invisible: TRUE, place: [CharPos[72], line0],      proc: StopAuto, z: zone];    items[FormItems.portiontobedisplayed.ORD] ¬ TagOnlyItem[      tag: "Portion to be displayed:"L, place: [CharPos[1], line1], z: zone];    items[FormItems.x.ORD] ¬ NumberItem[      tag: "x "L, place: [CharPos[27], line1], signed: FALSE, notNegative: TRUE,      boxWidth: defaultBoxWidth, default: defaultX, value: @data.x, z: zone];    items[FormItems.xLength.ORD] ¬ NumberItem[      tag: "xLength "L, place: [CharPos[37], line1], signed: FALSE,      notNegative: TRUE, boxWidth: defaultBoxWidth, default: defaultXLength,      value: @data.xLength, z: zone];    items[FormItems.y.ORD] ¬ NumberItem[      tag: "y "L, place: [CharPos[53], line1], signed: FALSE, notNegative: TRUE,      boxWidth: defaultBoxWidth, default: defaultY, value: @data.y, z: zone];    items[FormItems.yLength.ORD] ¬ NumberItem[      tag: "yLength "L, place: [CharPos[63], line1], signed: FALSE,      notNegative: TRUE, boxWidth: defaultBoxWidth, default: defaultYLength,      value: @data.yLength, z: zone];    items[FormItems.bandList.ORD] ¬ EnumeratedItem[      tag: "BandList"L, place: [CharPos[1], line2], proc: SetBandList,      choices: DESCRIPTOR[bandList], value: @data.bandList, z: zone];    RETURN[items: items, freeDesc: TRUE];    };  MakeSWs: Tool.MakeSWsProc = {    NullProc: PROC [sw: Window.Handle, clientData: LONG POINTER] = {};    data.msgSW ¬ Tool.MakeMsgSW[window: window];    data.formSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeForm, zone: zone];    data.displaySW ¬ Tool.MakeClientSW[window, NullProc, NIL, vanilla];    };  MesaBandBLTIt:  FormSW.ProcType = {    ENABLE ABORTED => {Done[]; CONTINUE};    IF Busy[] THEN {      Msg["Tool is busy.\n"L]; RETURN};    MsgSW.Clear[data.msgSW];    Process.Detach[FORK BandBLTItInternal[TRUE]]};  Msg: Format.StringProc = {Put.Text[data.msgSW, s]};  SetBandList:  FormSW.EnumeratedNotifyProcType = {    ENABLE ABORTED => {Done[]; CONTINUE};    IF Busy[] THEN {      Msg["Tool is busy.\n"L]; RETURN};    MsgSW.Clear[data.msgSW];    Process.Detach[FORK SetBandListInternal[]]};  SetBandListInternal: PROCEDURE = {    ENABLE ABORTED => {Done[]; CONTINUE};    SetBandListSub[];    Done[] };  SetBandListSub: PROCEDURE = {    SELECT data.bandList FROM      A => IF data.bandListLoaded # A THEN LoadBandListA[];      B => IF data.bandListLoaded # B THEN LoadBandListB[];      C => IF data.bandListLoaded # C THEN LoadBandListC[];      D => IF data.bandListLoaded # D THEN LoadBandListD[];      E => IF data.bandListLoaded # E THEN LoadBandListE[];      F => IF data.bandListLoaded # F THEN LoadBandListF[];      G => IF data.bandListLoaded # G THEN LoadBandListG[];      H => IF data.bandListLoaded # H THEN LoadBandListH[];      ENDCASE => ERROR;    };  SetDefaults:  FormSW.ProcType = {    ENABLE ABORTED => {Done[]; CONTINUE};    IF Busy[] THEN {      Msg["Tool is busy.\n"L]; RETURN};    Process.Detach[FORK SetDefaultsInternal[]]};  SetDefaultsInternal: PROCEDURE = {    ENABLE ABORTED => {Done[]; CONTINUE};    MsgSW.Clear[data.msgSW];    data.x ¬ defaultX;    data.xLength ¬ defaultXLength;    data.y ¬ defaultY;    data.yLength ¬ defaultYLength;    data.bandList ¬ A;    IF data.bandListLoaded # A THEN LoadBandListA[];    FormSW.DisplayItem[data.formSW, FormItems.x.ORD];    FormSW.DisplayItem[data.formSW, FormItems.xLength.ORD];    FormSW.DisplayItem[data.formSW, FormItems.y.ORD];    FormSW.DisplayItem[data.formSW, FormItems.yLength.ORD];    FormSW.DisplayItem[data.formSW, FormItems.bandList.ORD];    Done[] };  StartAuto:  FormSW.ProcType <<[sw, item, index]>> = {    ENABLE ABORTED => {Done[]; CONTINUE};    SELECT TRUE FROM      Busy[] => Msg["Tool is busy.\n"L];      (data.version = trapezoidsImplemented) OR      (data.version = trapezoidsSkipped) =>         Process.Detach[FORK StartAutoInternal[sw, index]];      (data.version = preTrapezoid) => {        Msg["Sorry, can't do that; microcode is pre-trapezoid.\n"L];	Done[] };      (data.version = unknown) => {        Msg["Sorry, can't do that; microcode version unknown!\n"L];	Done[] };      ENDCASE => ERROR;    };  StartAutoInternal: PROCEDURE [sw: Window.Handle, index: CARDINAL] = {    ENABLE ABORTED => {Done[]; CONTINUE};    FormSW.ToggleVisibility[sw, index];    FormSW.ToggleVisibility[sw, FormItems.stopAuto.ORD];    data.stopAuto ¬ FALSE;    Msg["Automatic exerciser running; click StopAuto! to stop.\n"L];    WHILE ~data.stopAuto DO      BandBLTItSub[];      data.bandList ¬ (IF data.bandList = LAST[BandListID] THEN FIRST[BandListID]        ELSE SUCC[data.bandList]);      SetBandListSub[];      Process.Pause[Process.MsecToTicks[50]];      ENDLOOP;    FormSW.ToggleVisibility[sw, FormItems.stopAuto.ORD];    FormSW.ToggleVisibility[sw, index];    MsgSW.Clear[data.msgSW];    Done[] };  StopAuto:  FormSW.ProcType = {    data.stopAuto ¬ TRUE};  Unload: Exec.ExecProc = {    IF Busy[] THEN {      Exec.OutputProc[h]["Tool is busy. Sorry.\n"L];      RETURN[error] };    FreeStorage[];    Tool.Destroy[wh];    Exec.RemoveCommand[h, "BandBLTTestTool.~"L];    Done[] };  UpdateDisplay: PROCEDURE [xScanNumber: CARDINAL] = {    OPEN d: data.bandBLTTablePtr;    endingXPlus1: CARDINAL;    startingX: CARDINAL;    IF (data.x >= (xScanNumber + scanLinesPerBand)) OR      ((data.x + data.xLength) <= xScanNumber) THEN RETURN;    startingX ¬ MAX[data.x, xScanNumber];    endingXPlus1 ¬ MIN[xScanNumber + scanLinesPerBand, data.x + data.xLength];    Display.Bitmap[      window: data.displaySW,      box: [[0, startingX - data.x], [data.yLength, (endingXPlus1 - startingX)]],      address: [        word: (d.bandbuf + ((startingX - xScanNumber)*wordsPerScanLine) +	  data.y/Environment.bitsPerWord),        reserved: 0,        bit: (data.y MOD Environment.bitsPerWord)],      bitmapBitWidth: bitsPerScanLine,      flags: Display.replaceFlags];    };  -- Mainline code  Init[];  -- this gets strings out of global frame  }...LOG24Jul86 - CRF - Created file.16Sep86 - CRF - Added Activate procedure and made initialState = inactive so that the tool is not activated before BandBLTImpl is started.  This way the ESCTrapTable is set up before BandBLT is first called.
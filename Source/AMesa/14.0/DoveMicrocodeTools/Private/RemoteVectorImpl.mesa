-- RemoteVectorImpl.mesa-- Created by jAC   CxC    on 10-Jan-85 10:15-- last edit by CxC   	      11-Jun-85 13:30:19-- Copyright (C) Xerox Corporation 1984. All rights reserved.DIRECTORY  Ascii,  Bindweed,  Display,  Exec,  Environment,  Format,  FormSW,  Heap,  MFile,  MLoader,  MStream,  VectorRemoteStream,  Process,  Put,  Runtime,  Stream,  String,  TextSW,  Time,  Tool,  ToolWindow,  TestVectorIO,  TTY,  UserInput,  UserTerminal,  Version,  Window;RemoteVectorImpl: PROGRAM  IMPORTS    Bindweed, Display, Exec, FormSW, Heap, MStream, VectorRemoteStream, Process, Put, Runtime, Stream, String, TextSW,Tool, TestVectorIO, Time, TTY, UserInput, UserTerminal, Version = {  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = MACHINE DEPENDENT RECORD [    msgSW(0): Window.Handle _ NIL,    formSW(2): Window.Handle _ NIL,    fileSW(4): Window.Handle _ NIL,    name(6): LONG STRING _ NIL,    dontCares(8): UNSPECIFIED _ 0,    password(9): LONG STRING _ NIL,    delay(11): WORD _ 1,    filename(12): LONG STRING _ NIL];      Location: TYPE = LONG POINTER TO ASMLoc;  ASMLoc: TYPE = MACHINE DEPENDENT RECORD [    base: WORD _ 0100H,    dataseg: WORD _ 0200H,    start: WORD _ 0000H,    continue: WORD _ 0003H,    ErrFlag: LONG CARDINAL _ 02000H,    number: LONG CARDINAL _ 02001H,    delay: LONG CARDINAL _ 02003H,    count: LONG CARDINAL _ 02005H,    result: LONG CARDINAL _ 0200AH,    original: LONG CARDINAL _ 0201BH,    table: LONG CARDINAL _ 0202CH];  Vector: TYPE = ARRAY [1..17] OF CARDINAL;  FormItems: TYPE = {start, name, dontCares, sTOP, password, delay, filename};  data: DataHandle _ NIL;  wh: Window.Handle _ NIL;  zone: UNCOUNTED ZONE _ Heap.systemZone;  location: Location _ NIL;  Done, Running, Loaded, EOF, initialized, state, first: BOOLEAN _ FALSE;    hexbyte: Format.NumberFormat = [16, TRUE, TRUE, 2];    dim: Window.Dims _ [20,20];  place: Window.Place _ [420,5];  Error: PUBLIC ERROR [reason: LONG STRING] = CODE;    AppendMessage: PROCEDURE [s: LONG STRING] =    BEGIN    Put.Text[data.msgSW, s];    TextSW.ForceOutput[data.msgSW];    END;      BinaryStringToCardinal: PROCEDURE [s: LONG STRING] RETURNS [n: CARDINAL _ 0] =     {    FOR i: CARDINAL IN [0..s.length) DO      SELECT s[i] FROM        '0 => n _ n * 2;	'1, '+ => n _ n * 2 + 1;	'x, 'X => IF data.dontCares = 0 THEN n _ n * 2 ELSE n _ n * 2 + 1;	ENDCASE => EXIT;      ENDLOOP    };         Boot: PROCEDURE = {    temp: MStream.Handle;    IF ~Running THEN     {NewMessage["Booting..."L];      TestVectorIO.Boot[];      temp _ MStream.ReadOnly["TVector.lm"L,[]]; -- See if file exists      Stream.Delete[temp];	      AppendMessage["Downloading file..."L];      TestVectorIO.Load[data.fileSW,"TVector.lm"L];      AppendMessage["Done"L];}    ELSE      NewMessage["Must be stopped before running"L];    };      Convert: PROCEDURE [str: LONG STRING] RETURNS [array: Vector] = {    temp: LONG STRING _ zone.NEW[StringBody[16]];    temp1: LONG STRING _ zone.NEW[StringBody[16]];    numb: CARDINAL;    array[1] _ BinaryStringToCardinal[SubString[str,temp1,0,5]];    numb _ BinaryStringToCardinal[SubString[str,temp1,5,3]];    array[2] _ BinaryStringToCardinal[SubString[str,temp1,8,5]] * 8 + numb;    array[3] _ BinaryStringToCardinal[SubString[str,temp1,13,8]];    numb _ BinaryStringToCardinal[SubString[str,temp1,21,3]];    array[4] _ BinaryStringToCardinal[SubString[str,temp1,24,8]];    array[5] _ BinaryStringToCardinal[SubString[str,temp1,32,8]];    array[6] _ BinaryStringToCardinal[SubString[str,temp1,40,1]] * 8 + numb;    String.Copy[temp,SubString[str,temp1,41,3]];    String.AppendChar[temp,'0];    String.AppendChar[temp,'0];    String.AppendString[temp,SubString[str,temp1,44,2]];    array[7] _ BinaryStringToCardinal[temp];    array[8] _ BinaryStringToCardinal[SubString[str,temp1,46,8]];    array[9] _ BinaryStringToCardinal[SubString[str,temp1,54,8]];    array[10] _ BinaryStringToCardinal[SubString[str,temp1,62,8]];    array[11] _ BinaryStringToCardinal[SubString[str,temp1,70,8]];    array[12] _ BinaryStringToCardinal[SubString[str,temp1,78,8]];    array[13] _ BinaryStringToCardinal[SubString[str,temp1,86,8]];    array[14] _ BinaryStringToCardinal[SubString[str,temp1,94,8]];    array[15] _ BinaryStringToCardinal[SubString[str,temp1,102,8]];    array[16] _ BinaryStringToCardinal[SubString[str,temp1,110,8]];    array[17] _ BinaryStringToCardinal[SubString[str,temp1,118,2]];    zone.FREE[@temp];    zone.FREE[@temp1];     };          DoIt: PROCEDURE = {    Script: MStream.Handle;    char: CHARACTER;    name: LONG STRING _ zone.NEW[StringBody[60]];    WHILE Running DO      Script _ MStream.ReadOnly[data.filename,[]];      UNTIL MStream.EndOf[Script] DO      char _ Stream.GetChar[Script];      IF char = Ascii.CR THEN {        Done _ FALSE;        TestVector[name]; 	UNTIL Done DO          -- Wait for Bindweed Notify to be called	  Process.Pause[Process.MsecToTicks[20]];	  IF UserInput.UserAbort[wh] THEN {Running _ FALSE;};	  ENDLOOP;        name.length _ 0;	IF ~Running THEN EXIT;	}      ELSE        String.AppendChar[name,char];      ENDLOOP;      Stream.Delete[Script];      Script _ NIL;      Running _ FALSE; -- To run continuously get rid of this    ENDLOOP;    zone.FREE[@name];    Put.CR[data.fileSW];    Put.Line[data.fileSW,"STOPPED"L];    };      Flip: PROCEDURE = {    IF ~state THEN {Display.White[data.formSW,[place,dim]];                    Display.Black[data.formSW,[[place.x,place.y+10],[10,10]]];		    Display.Black[data.formSW,[[place.x+10,place.y],[10,10]]];}    ELSE      Display.Invert[data.formSW,[place,dim]];    state _ ~state;    };      Clear: PROCEDURE = {    Display.White[data.formSW,[place,dim]];    state _ FALSE;    };      Continue:  PROCEDURE= {    NewMessage[" "L];    TestVectorIO.ReadSavedRegisters[];    TestVectorIO.WriteRegister[IP,location.continue];    TestVectorIO.WriteRegister[CS,location.base];    TestVectorIO.WriteRegister[DS,location.dataseg];    TestVectorIO.WriteRegister[ES,location.dataseg];    TestVectorIO.WriteSavedRegisters[];    TestVectorIO.Continue[];    Running _ TRUE;    };      Halted: Bindweed.NotifyProc = {    ENABLE {      TestVectorIO.Error => {NewMessage[reason]; CONTINUE};      Runtime.UnboundProcedure => {NewMessage["Bindweed is not loaded"L];             CONTINUE};      Bindweed.Error => {SELECT code FROM                           timeout => NewMessage["Timeout occured"L];			   badCheckSum => NewMessage["Bad checksum"L];			   umbilicalNotWorking => NewMessage["Umbilical not working"L];			   ENDCASE;			 CONTINUE};      };    Flag: Environment.Byte;    count: WORD;    TestVectorIO.Stop[];    Flag _ TestVectorIO.ReadMemoryByte[location.ErrFlag];    IF Flag = 255 THEN {      IF first THEN        Put.Text[data.fileSW," Failed at #"L]      ELSE        Put.Text[data.fileSW,",#"L];      count _ TestVectorIO.ReadMemoryWord[location.count];      Put.Decimal[data.fileSW, count];      first _ FALSE;      Continue[]}    ELSE {      Put.Line[data.fileSW,"OK"L];      Done _ TRUE};     };      LoadFile: PROCEDURE [filename: LONG STRING] RETURNS [loaded: BOOLEAN _ FALSE] =    BEGIN    NewMessage[" "L];    first _ TRUE;    Put.Text[data.fileSW, "Reading "L];    Put.LongString[data.fileSW, filename];    TextSW.ForceOutput[data.fileSW];     Loaded _ FALSE;       VectorRemoteStream.Read[filename, data.name, data.password, LoadFileRemote !     VectorRemoteStream.Error => {Put.Text[data.fileSW," Error..."L];                          Put.LongString[data.fileSW, expl];                         Put.CR[data.fileSW];                         TextSW.ForceOutput[data.fileSW];                         CONTINUE;};];    Clear[];    IF Loaded THEN loaded _ TRUE;    END;      LoadFileRemote: PROCEDURE [filePtr: Stream.Handle] = {    char, prev: CHARACTER;    vector: Vector;    str: LONG STRING _ [122];    loc: LONG CARDINAL;    num, charCount, len: CARDINAL _ 0;    comment, skipCR: BOOLEAN _ FALSE;    loc _ location.table;    len _ 0;    str.length _ 0;    EOF _ FALSE;    prev _ 'x;    UNTIL ~Running DO      char _ Stream.GetChar[filePtr ! Stream.EndOfStream => {EOF _ TRUE;                                       CONTINUE;}];      charCount _ charCount + 1;      IF EOF THEN EXIT;      IF len > 120 THEN char _ Ascii.CR;      SELECT char FROM        '0, '1, 'x, 'X, '+ => {len _ len + 1; 	                      String.AppendChar[str,char];	                      skipCR _ FALSE};	Ascii.CR => {IF skipCR THEN skipCR _ FALSE ELSE { 	               IF len = 120 THEN {		         vector _ Convert[str];                                                             WriteVector[loc,vector];	                 loc _ loc + 17;		         str.length _ 0;		         len _ 0;		         num _ num + 1;			 IF num MOD 10 = 0 THEN Flip[]}		       ELSE {		         Put.Text[data.fileSW, " Invalid vector length at ["L];		         Put.Decimal[data.fileSW, charCount - len - 1];                         Put.Line[data.fileSW, "]"L];		         EXIT}}};	'/      => {IF ~comment THEN	              comment _ TRUE	            ELSE 		      IF prev = '* THEN comment _ FALSE;	            skipCR _ TRUE;		    str.length _ 0;  -- In case comment had 0's, 1's or x's		    len _ 0};	ENDCASE => {IF ~comment THEN {                      Put.Text[data.fileSW, "Invalid character at ["L];		      Put.Decimal[data.fileSW, charCount-1];                      Put.Line[data.fileSW, "]"L];		      EXIT}};      prev _ char;      ENDLOOP;    TestVectorIO.WriteMemoryWord[location.number,num];    Put.Text[data.fileSW,"...Testing..."L];    IF num # 0 THEN Loaded _ TRUE;    };      LoadPreamble: PROCEDURE RETURNS  [Loaded: BOOLEAN _ FALSE] =    BEGIN    ENABLE {TestVectorIO.Error => {NewMessage[reason]; CONTINUE;};            MStream.Error => {IF code = fileNotAvailable THEN {Put.Line[                                data.fileSW,"File not found"L]; UserTerminal.BlinkDisplay[];}             ELSE NewMessage["UnKnown MStream error"L]; CONTINUE};};    filePtr: MStream.Handle;    temp: Stream.Position;    char: CHARACTER;    vector: Vector;    str: LONG STRING _ [122];    loc, len: LONG CARDINAL;    num: CARDINAL _ 0;    comment, skipCR: BOOLEAN _ FALSE;    loc _ location.table;    len _ 0;    str.length _ 0;    filePtr _ MStream.ReadOnly["Preamble.vectors"L,[]];    NewMessage[" "L];    Put.Text[data.fileSW, "Reading Preamble.vectors"L];    UNTIL MStream.EndOf[filePtr] OR ~Running DO      char _ Stream.GetChar[filePtr];      IF len > 120 THEN char _ Ascii.CR;      SELECT char FROM        '0, '1, 'x, 'X, '+ => {len _ len + 1; 	                      String.AppendChar[str,char];	                      skipCR _ FALSE};	Ascii.CR => {IF skipCR THEN skipCR _ FALSE ELSE { 	               IF len = 120 THEN {		         vector _ Convert[str];                                                             WriteVector[loc,vector];	                 loc _ loc + 17;		         str.length _ 0;		         len _ 0;		         num _ num + 1;}		       ELSE {		         Put.Text[data.fileSW, " Invalid vector length at ["L];	                 temp _ Stream.GetPosition[filePtr];		         Put.LongDecimal[data.fileSW, temp - len - 1];                         Put.Line[data.fileSW, "]"L];		         EXIT}}};	'/      => {IF ~comment THEN comment _ TRUE ELSE comment _ FALSE;	            skipCR _ TRUE;		    str.length _ 0;  -- In case comment had 0's, 1's or x's		    len _ 0};	ENDCASE => {IF ~comment THEN {                      Put.Text[data.fileSW, "Invalid character at ["L];	              temp _ Stream.GetPosition[filePtr];		      Put.LongDecimal[data.fileSW, temp-1];                      Put.Line[data.fileSW, "]"L];		      EXIT}};      ENDLOOP;    Stream.Delete[filePtr];    filePtr _ NIL;    TestVectorIO.WriteMemoryWord[location.number,num];    Put.Text[data.fileSW,"...Testing..."L];    IF num # 0 THEN Loaded _ TRUE;    END;      NewMessage: PROCEDURE  [s: LONG STRING] =    BEGIN    Put.CR[data.msgSW];    Put.Text[data.msgSW, s];    TextSW.ForceOutput[data.msgSW];    END;      NoBindweed: PROCEDURE = {    NewMessage["Bindweed is not loaded"L];    UserTerminal.BlinkDisplay[];    };  Start:  FormSW.ProcType = {    ENABLE {MStream.Error => {IF code = fileNotAvailable THEN {NewMessage[                                 "TVector.LM not found"L]; UserTerminal.BlinkDisplay[];}                             ELSE NewMessage["UnKnown MStream error"L]; CONTINUE};    TestVectorIO.Error => {AppendMessage[reason]; CONTINUE;};    Bindweed.Error => { SELECT code FROM                 timeout => { AppendMessage["Failed"L]; Put.Line[data.fileSW,                             "Timeout occured"L];};                 badCheckSum => { AppendMessage["Failed"L]; Put.Line[data.fileSW,                                 "Bad Chack Sum"L];};                 umbilicalNotWorking => {AppendMessage["Failed"L]; Put.Line                                     [data.fileSW, "Umbilical not working"L]; };                 ENDCASE;               CONTINUE;};    Runtime.UnboundProcedure => { AppendMessage["Failed"L]; Put.Line[data.fileSW,                                  "BindweedConfig.bcd not loaded"L]; CONTINUE; };    UNWIND => NULL;    };    Script: MStream.Handle;    IF data.filename = NIL OR data.filename.length = 0 THEN      {NewMessage["No filename entered"L];       RETURN};    Script _ MStream.ReadOnly[data.filename,[]]; -- See if file exists    Stream.Delete[Script];    Boot[];    Running _ TRUE;    Process.Detach[FORK DoIt[]];    };          SendPreamble: PROCEDURE = {    IF ~LoadPreamble[] THEN RETURN;    Done _ FALSE;    Put.CR[data.msgSW];    TestVectorIO.ReadSavedRegisters[];    TestVectorIO.WriteMemoryWord[location.delay,data.delay];    TestVectorIO.WriteRegister[IP,location.start];    TestVectorIO.WriteRegister[CS,location.base];    TestVectorIO.WriteSavedRegisters[];    TestVectorIO.Continue[];    };  stop:  FormSW.ProcType = {    ENABLE {TestVectorIO.Error => {NewMessage[reason]; CONTINUE;};          UNWIND => NULL;};    Running _ FALSE;    Done _ TRUE;    };  SubString: PROCEDURE [s,a: LONG STRING, start,len: CARDINAL] RETURNS                       [a1: LONG STRING] = {    j: CARDINAL _ 0;    a.length _ len;    IF start + len > s.length THEN len _ s.length - start;    FOR i: CARDINAL IN [start..start+len-1] DO      a[j] _ s[i];      j _ j + 1;      ENDLOOP;    RETURN[a];   };      TestVector: PROCEDURE [filename: LONG STRING] = {    ENABLE {    TestVectorIO.Error => {NewMessage[reason]; CONTINUE;};    Bindweed.Error => {SELECT code FROM              timeout => { AppendMessage["Failed"L]; Put.Line[data.fileSW,                             "Timeout occured"L];};              umbilicalNotWorking => {AppendMessage["Failed"L]; Put.Line                                     [data.fileSW, "Umbilical not working"L];};	      ENDCASE;	      CONTINUE};    UNWIND => NULL;    };    SendPreamble[];    UNTIL Done DO          -- Wait for Bindweed Notify to be called      Process.Pause[Process.MsecToTicks[20]];      ENDLOOP;    IF ~LoadFile[filename] THEN RETURN;    Done _ FALSE;    TestVectorIO.ReadSavedRegisters[];    TestVectorIO.WriteMemoryWord[location.delay,data.delay];    TestVectorIO.WriteRegister[IP,location.start];    TestVectorIO.WriteRegister[CS,location.base];    TestVectorIO.WriteSavedRegisters[];    TestVectorIO.Continue[];    };  WriteVector: PROCEDURE [addr:LONG CARDINAL, data: Vector] = {    ENABLE UNWIND => NULL;    dataPtr: LONG POINTER TO Bindweed.Sequence _ Heap.systemZone.NEW[      Bindweed .Sequence[17] _ [length: 17, seq: NULL]];    FOR i:CARDINAL IN [1..17] DO      dataPtr[i-1] _ data[i];      ENDLOOP;    TestVectorIO.WriteMemoryDataSequence[addr,dataPtr];    Heap.systemZone.FREE[@dataPtr];    };  ClientTransition: ToolWindow.TransitionProcType = {    SELECT TRUE FROM      old = inactive => {        IF data = NIL THEN data _ zone.NEW[Data _ []];	IF location = NIL THEN location _ Heap.systemZone.NEW[ASMLoc _ []];	Running _ FALSE;	Bindweed.AddNotify[Halted, 4 	  ! Runtime.UnboundProcedure => {NoBindweed[]; CONTINUE}; ];};      new = inactive => {        IF data # NIL THEN {zone.FREE[@data]};	IF location # NIL THEN Heap.systemZone.FREE[@location];	Bindweed.RemoveNotify[4, Halted  	  ! Runtime.UnboundProcedure => {NoBindweed[]; CONTINUE};];};      ENDCASE;    };  Init: PROCEDURE [h: Exec.Handle] = {    herald: STRING = [100];    ttH: TTY.Handle _ Exec.GetTTY[h];    String.AppendString[herald, "Remote Vector Tool "L];    Version.Append[herald];    String.AppendString[herald, " of "L];    Time.Append[herald, Time.Unpack[Runtime.GetBcdTime[]]];    IF initialized THEN ERROR;    IF  ~Runtime.IsBound[LOOPHOLE[Bindweed.ReadMemoryBlock, Runtime.ControlLink]]       THEN      BEGIN        TTY.PutString[h: ttH, s: "Please run IOPBermuda.bcd before continuing"L];        Exec.ReleaseTTY[ttH];        RETURN;      END;            wh _ Tool.Create[      makeSWsProc: MakeSWs, initialState: default,      clientTransition: ClientTransition, name: herald,      cmSection: "RemoteVectorTool"L];    initialized _ TRUE;    };      Unload: Exec.ExecProc = {    [] _ Exec.RemoveCommand[h, "RemoteVectorTool.~"];    Tool.Destroy[wh];    };  MakeSWs: Tool.MakeSWsProc = {    logName: LONG STRING _ [23];    Tool.UnusedLogName[unused: logName, root: "RemoteVectorTool.log"L];    data.msgSW _ Tool.MakeMsgSW[window: window];    data.formSW _ Tool.MakeFormSW[      window: window, formProc: MakeForm];    data.fileSW _ Tool.MakeFileSW[window: window, name: logName];    };  MakeForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = FormItems.LAST.ORD + 1;    dontCares: ARRAY[0..2) OF Enumerated _ [      ["0"L, 0], ["1"L, 1]];    items _ AllocateItemDescriptor[nItems];    items[FormItems.start.ORD] _ CommandItem[      tag: "Start"L, place: [6, line0], proc: Start];    items[FormItems.name.ORD] _ StringItem[      tag: "Name"L, place: [90, line0], inHeap: TRUE, string: @data.name];    items[FormItems.dontCares.ORD] _ EnumeratedItem[      tag: "Don't Cares"L, place: [276, line0], feedback: all, choices: DESCRIPTOR[dontCares], value: @data.dontCares];    items[FormItems.sTOP.ORD] _ CommandItem[      tag: "STOP"L, place: [6, line1], proc: stop];    items[FormItems.password.ORD] _ StringItem[      tag: "Password"L, place: [90, line1], feedback: password, inHeap: TRUE, string: @data.password];    items[FormItems.delay.ORD] _ NumberItem[      tag: "Delay"L, place: [276, line1], signed: FALSE, value: @data.delay];    items[FormItems.filename.ORD] _ StringItem[      tag: "Filename"L, place: [90, line2], inHeap: TRUE, string: @data.filename];    RETURN[items: items, freeDesc: TRUE];    };  -- Mainline code    IgnoreCommandLine: Exec.ExecProc = BEGIN IF NOT initialized THEN Init[h]; END;    Register: PROC = {Exec.AddCommand[name: "RemoteVectorTool"L, proc:                     IgnoreCommandLine]};  -- Mainline code  Register[];  -- this gets string out of global frame  }...    
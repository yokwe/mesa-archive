-- File: IOPBPanelImpl.mesa - last edit:-- Bowers.PA           30-Sep-86 13:57:48-- FXB   .PA           21-May-85 10:26:46-- Copyright (C) 1984, 1985, 1986 by Xerox Corporation. All rights reserved.-- after IOPPaneler.mesa, HGM, 22-Nov-83  5:57:10DIRECTORY  Bindweed,  Heap USING [systemZone],  Inline,  IOPB,  String,  Tool USING [AddThisSW],  ToolWindow USING [CreateSubwindow, nullBox],  Window USING [Box, Handle],  WindowFont USING [CharWidth, defaultFont, FontHeight, Handle],  I186 USING [Register],  IOPBKernel,  IOPBPanel,  IOPBSymbol USING [AppendAddress, AppendAddressType, AppendRegister, Eval,    Symbol],  PanelSW USING [    AppendPanelData, Clear, ClientError, ClientProcs, ClientProcsObject, Create, Destroy,    FreeRSProcType, LHTypeInEvalProcType, Handle, ModifyTypeInProcType,    ReadTargetProcType, RegisterSpec, RHTypeInEvalProcType, SWType, TileError,    TileLayout, TileSpec, Update, WriteTile];IOPBPanelImpl: PROGRAM  IMPORTS    Bindweed, Heap, Inline, IOPB, String, Tool, ToolWindow, WindowFont,    IOPBKernel, IOPBSymbol, PanelSW  EXPORTS IOPBPanel =  BEGIN  z: UNCOUNTED ZONE = Heap.systemZone;  panel: ARRAY IOPB.Processor OF PanelSW.Handle ¬ ALL [NIL];  dataType: ARRAY IOPB.Processor OF LONG POINTER TO IOPB.DataType ¬ ALL [NIL];  addressType: ARRAY IOPB.Processor OF LONG POINTER TO IOPB.AddressType ¬     ALL [NIL];  leftField: ARRAY IOPB.Processor OF LONG POINTER TO IOPBPanel.NumberOrSymbol ¬    ALL [NIL];  font: WindowFont.Handle = WindowFont.defaultFont;  fontHeight: INTEGER = WindowFont.FontHeight[font];  digitWidth: INTEGER = WindowFont.CharWidth['0, font];  tileHeight: INTEGER = fontHeight;  tileRows: INTEGER = 17;  tileColumns: INTEGER = 4;  tileFlagLength: INTEGER = digitWidth;  tileLVLength: INTEGER = 20 * digitWidth + 4;  tileRVLength: INTEGER = 6 * digitWidth + 4;  tileLength: INTEGER = tileFlagLength + tileLVLength + tileRVLength;  tileBoxWidth: INTEGER = tileColumns * (tileLength);  numTiles: INTEGER = tileRows * tileColumns;  rowLayout: ARRAY [0..tileColumns) OF PanelSW.TileLayout ¬ [    [tileFlagLength, tileLVLength, tileRVLength], [    tileFlagLength, tileLVLength, tileRVLength], [    tileFlagLength, tileLVLength, tileRVLength], [    tileFlagLength, tileLVLength, tileRVLength]];  iopPanelProcs: PanelSW.ClientProcsObject ¬ [    FreeRS, IOPLHTypeInEval, NIL, IOPReadTarget, IOPRHTypeInEval];    pcPanelProcs: PanelSW.ClientProcsObject ¬ [    FreeRS, PCLHTypeInEval, NIL, PCReadTarget, PCRHTypeInEval];  RegisterSpec: TYPE = LONG POINTER TO RegisterSpecObject;  RegisterSpecObject: PUBLIC TYPE = IOPBSymbol.Symbol;  AbsToRep: PROCEDURE [rs: PanelSW.RegisterSpec] RETURNS [RegisterSpec] = INLINE    BEGIN RETURN[LOOPHOLE[rs]] END;  RepToAbs: PROCEDURE [rs: RegisterSpec] RETURNS [PanelSW.RegisterSpec] = INLINE    BEGIN RETURN[LOOPHOLE[rs]] END;  AppendPanelData: PUBLIC PROCEDURE [    processor: IOPB.Processor, textSW: Window.Handle] = {    PanelSW.AppendPanelData[textSW, panel[processor]]; };    IOPLHTypeInEval: PanelSW.LHTypeInEvalProcType = {    [display, newRs] ¬ LHTypeInEval[ts, typeIn, normalize, iop]};      PCLHTypeInEval: PanelSW.LHTypeInEvalProcType = {    [display, newRs] ¬ LHTypeInEval[ts, typeIn, normalize, pc]};      LHTypeInEval: PROCEDURE [    ts: PanelSW.TileSpec, typeIn: LONG STRING, normalize: BOOLEAN,    processor: IOPB.Processor]    RETURNS [display: LONG STRING, newRs: PanelSW.RegisterSpec] =    BEGIN    << LHTypeInEvalProcType: TYPE =  -- converts any string to register spec    PROCEDURE [ts: TileSpec, typeIn: --READONLY-- LONG STRING, normalize: BOOLEAN]    RETURNS [display: LONG STRING, newRs: RegisterSpec];>>    value: IOPBSymbol.Symbol;    str: LONG STRING ¬ [100];    display ¬ NIL;    newRs ¬ NIL;    IF (IOPBKernel.GetState[] = dead) THEN RETURN;    IF String.Empty[typeIn] THEN RETURN;    [value, display] ¬ IOPBSymbol.Eval[      typeIn, dataType[processor]­, addressType[processor]­, TRUE       ! IOPB.Error => {        IOPB.AppendError[code: code, errS: s, s: str]; 	ERROR PanelSW.ClientError[unknown, str]}];      newRs ¬ AllocateRegisterSpec[value];    IF normalize THEN      BEGIN      temp: STRING ¬ [64];      WITH value SELECT FROM        register => IOPBSymbol.AppendRegister[temp, reg];        byte, word => {	  IOPBSymbol.AppendAddressType[temp, addrType];          IF leftField[processor]­ = number OR addrType IN [real..vm] THEN	     String.AppendLongNumber[temp, addr, 16]          ELSE {            IOPBSymbol.AppendAddress[temp, addr, addrType];            IF String.Empty[temp] THEN String.AppendLongNumber[temp, addr, 16];            }};        ENDCASE => ERROR;      display ¬ String.CopyToNewString[temp, z];      END    ELSE display ¬ String.CopyToNewString[display, z];    END;      IOPRHTypeInEval: PanelSW.RHTypeInEvalProcType = {    RETURN[RHTypeInEval[ts, typeIn, rs, iop]]};      PCRHTypeInEval: PanelSW.RHTypeInEvalProcType = {    RETURN[RHTypeInEval[ts, typeIn, rs, pc]]};  RHTypeInEval: PROCEDURE [ts: PanelSW.TileSpec, typeIn: LONG STRING, rs: PanelSW.RegisterSpec, processor: IOPB.Processor]    RETURNS [display: LONG STRING] =    BEGIN    myrs: RegisterSpec = AbsToRep[rs];    symbol: IOPBSymbol.Symbol;    value: CARDINAL;    str: LONG STRING = [100];    <<    RHTypeInEvalProcType: TYPE =  -- converts any string to right hand side    PROCEDURE [ts: TileSpec, typeIn: --READONLY-- LONG STRING, rs: RegisterSpec]    RETURNS [display: LONG STRING];    SIGNALs ClientError if write fails  >>    display ¬ NIL;    IF (IOPBKernel.GetState[] = dead) THEN RETURN;    IF rs = NIL OR String.Empty[typeIn] THEN RETURN;    symbol ¬ IOPBSymbol.Eval[      typeIn, dataType[processor]­, addressType[processor]­       ! IOPB.Error => {        IOPB.AppendError[code: code, errS: s, s: str]; 	ERROR PanelSW.ClientError[unknown, str]}].symbol;    WITH symbol SELECT FROM      register =>        ERROR PanelSW.ClientError[          readOnly, "Don't understand value of registers"L];      byte, word => value ¬ Inline.LowHalf[addr];      ENDCASE => ERROR;    BEGIN    ENABLE {      IOPB.Error => {        IOPB.AppendError[code: code, errS: s, s: str]; 	ERROR PanelSW.ClientError[unknown, str]};      Bindweed.Error => {        IOPB.AppendBWError[code: code, s: str];	ERROR PanelSW.ClientError[unknown, str]}};    WITH myrs SELECT FROM      register => IOPBKernel.WriteRegister[reg, value, processor];      word => IOPBKernel.WriteMemoryWord[addr, addrType, value];      byte => IOPBKernel.WriteMemoryByte[addr, addrType, value MOD 256];      ENDCASE => ERROR;    END;    display ¬ ReadTarget[rs, TRUE, processor];    END;  FreeRS: PanelSW.FreeRSProcType = BEGIN IF rs # NIL THEN z.FREE[@rs] END;  AllocateRegisterSpec: PROCEDURE [value: IOPBSymbol.Symbol]    RETURNS [PanelSW.RegisterSpec] =    BEGIN    rs: RegisterSpec ¬ z.NEW[RegisterSpecObject];    rs­ ¬ value;    RETURN[RepToAbs[rs]]    END;     IOPReadTarget: PanelSW.ReadTargetProcType = {    RETURN[ReadTarget[rs, newLH, iop]]};      PCReadTarget: PanelSW.ReadTargetProcType = {    RETURN[ReadTarget[rs, newLH, pc]]};  ReadTarget: PROCEDURE [    rs: PanelSW.RegisterSpec, newLH: BOOLEAN, processor: IOPB.Processor]    RETURNS [s: LONG STRING] =    BEGIN    <<      ReadTargetProcType: TYPE =  -- reads from hardware    PROCEDURE [rs: RegisterSpec, newLH: BOOLEAN]    RETURNS [s: LONG STRING];   SIGNALs ClientError if read fails.>>    myrs: RegisterSpec = AbsToRep[rs];    value: CARDINAL;    width: CARDINAL;    temp: LONG STRING ¬ [4];    str: LONG STRING ¬ [100];    s ¬ NIL;    IF (IOPBKernel.GetState[] = dead) THEN RETURN;    IF rs = NIL THEN RETURN;    BEGIN    ENABLE {      IOPB.Error => {        IOPB.AppendError[code: code, errS: s, s: str]; 	ERROR PanelSW.ClientError[unknown, str]};      Bindweed.Error => {        IOPB.AppendBWError[code: code, s: str];	ERROR PanelSW.ClientError[unknown, str]}};      WITH myrs SELECT FROM      register => {value ¬ IOPBKernel.ReadRegister[reg, processor]; width ¬ 4};      byte => {value ¬ IOPBKernel.ReadMemoryByte[addr, addrType]; width ¬ 2};      word => {value ¬ IOPBKernel.ReadMemoryWord[addr, addrType]; width ¬ 4};      ENDCASE => ERROR;    END;    s ¬ z.NEW[StringBody [4]];    String.AppendNumber[temp, value, 16];    FOR i: CARDINAL IN [0..(width - temp.length)) DO      String.AppendChar[s, '0]; ENDLOOP;    String.AppendString[to: s, from: temp];    END;  MakePanelSW: PUBLIC PROCEDURE [    parent: Window.Handle, err: Window.Handle,    modifyTypeIn: PanelSW.ModifyTypeInProcType,    typeIn: LONG POINTER TO LONG STRING,    increment: LONG POINTER TO CARDINAL ¬ NIL,    rows: LONG POINTER TO LONG STRING,    dType: LONG POINTER TO IOPB.DataType ¬ NIL,    addrType: LONG POINTER TO IOPB.AddressType ¬ NIL,    leftFieldType: LONG POINTER TO IOPBPanel.NumberOrSymbol,    processor: IOPB.Processor]    RETURNS [psw: Window.Handle] =    BEGIN    box: Window.Box ¬ ToolWindow.nullBox;    panelProcs: PanelSW.ClientProcs ¬ NIL;    SELECT processor FROM      iop => {        panelProcs ¬ @iopPanelProcs;        iopPanelProcs.modifyTypeIn ¬ modifyTypeIn};      pc => {        panelProcs ¬ @pcPanelProcs;        pcPanelProcs.modifyTypeIn ¬ modifyTypeIn};      ENDCASE => ERROR;    box.dims.h ¬ tileRows * tileHeight;    dataType[processor] ¬ dType;    addressType[processor] ¬ addrType;    leftField[processor] ¬ leftFieldType;    psw ¬ ToolWindow.CreateSubwindow[parent: parent, box: box];    panel[processor] ¬ PanelSW.Create[      psw, err, numTiles, DESCRIPTOR[rowLayout], panelProcs, typeIn,      increment, rows];    Tool.AddThisSW[window: parent, sw: psw, swType: PanelSW.SWType[]];    END;  Destroy: PUBLIC PROCEDURE [processor: IOPB.Processor] = {    IF panel[processor] # NIL THEN       PanelSW.Destroy[panel[processor]];     panel[processor] ¬ NIL};  GetPanel: PUBLIC PROCEDURE [processor: IOPB.Processor]    RETURNS [PanelSW.Handle] = {RETURN[panel[processor]]};  Clear: PUBLIC PROCEDURE [processor: IOPB.Processor] = {    IF panel[processor] # NIL THEN PanelSW.Clear[panel[processor]]};  Refresh: PUBLIC PROCEDURE [processor: IOPB.Processor] = {    IF ~IOPBKernel.InKernel[] THEN RETURN;    IF panel[processor] # NIL THEN PanelSW.Update[panel[processor]]};  Initialize: PUBLIC PROCEDURE [processor: IOPB.Processor] = {    tiles: CARDINAL = 14;    columnsDisplayed: CARDINAL = 3;    InitString: ARRAY [0..tiles+(tiles/columnsDisplayed)) OF STRING = [      "AX"L, "CS"L, "IP"L, "", "BX"L, "SS", "SP", "", "CX"L, "DS"L, "BP"L, "", "DX", "ES",      "Flags"L, "", "SI"L, "DI"L];    IF panel[processor] = NIL THEN RETURN;    PanelSW.Clear[panel[processor]];    FOR tile: CARDINAL IN [0..tiles+(tiles/columnsDisplayed)) DO      PanelSW.WriteTile[        panel[processor], [left, tile], InitString[tile], FALSE !        PanelSW.TileError => CONTINUE];      ENDLOOP    };  END.
-- Copyright (C) 1984, 1985  by Xerox Corporation. All rights reserved. -- SimpleBindweedDisplayer.mesa-- Create by FormSWLayoutTool on 13-Feb-84 20:22-- FXB   , 11-Oct-84 17:59:57: changed name stripe version numberDIRECTORY  Atom,  BitSW,  Context,  Cursor,  Environment,  Exec,  Format,  FormSW,  Heap,  MSegment,  MsgSW USING [Clear],  MStream,  Put,  Runtime,  Scrollbar USING [Error],  SimpleDisplayer,  SpecialDisplay,  Stream,  String,  Time,  TIP,  Tool,  ToolWindow,  UserInput,  UserTerminal,  Version,  Window,  WindowFont,  WindowOps;SimpleBindweedDisplayer: MONITOR  IMPORTS    Atom, BitSW, Context, Cursor, Exec, FormSW, Heap, MSegment, MsgSW, MStream,    Put, Runtime, Scrollbar, SimpleDisplayer, Stream, String, Time, TIP, Tool,    ToolWindow, UserInput, UserTerminal, Version, Window, WindowFont  EXPORTS SimpleDisplayer =  {  DataHandle: TYPE = SimpleDisplayer.DataHandle;  Data: TYPE = SimpleDisplayer.Data;  GlobalDataHandle: TYPE = SimpleDisplayer.GlobalDataHandle;  GlobalData: TYPE = SimpleDisplayer.GlobalData;  ItemHandle: TYPE = SimpleDisplayer.ItemHandle;  ItemObject: TYPE = SimpleDisplayer.ItemObject;  WindowList: TYPE = SimpleDisplayer.WindowList;  WindowRecord: TYPE = SimpleDisplayer.WindowRecord;  Items: TYPE = {    formType, tag, zone, setWindows, alignX, usebox, anyfont, root, doIt, clear,    setDefaults, load, save, plagiarize, another, destroy};  DItems: TYPE = {    close, newDefaults, readOnly, invisible, drawBox, hasContext, enumDefaults,    copyChoices, feedbackEnum, numDefaults, radix, notNegative, signed,    boxWidthNum, longDefault, shortDefault, stringDefaults, inHeap, feedbackString,    boxWidthStr, startRecord, startingword, globals, enumType, handleName,    procName, stuffString};  bufDims: Window.Dims = [1024, 12];  bufSize: CARDINAL = ((bufDims.w + 15) / 16) * bufDims.h;  initialBox: Window.Box = [place: [x: 452, y: 61], dims: [w: 512, h: 388]];  adjustUp: Atom.ATOM ¬ NIL;  pointUp: Atom.ATOM ¬ NIL;  drawHeight: CARDINAL = 800;  toolWidth: CARDINAL = 512;  swWidth: CARDINAL = 1024;  swBufsize: CARDINAL = ((swWidth + 15) / 16) * drawHeight;  swPages: CARDINAL =    (swBufsize + Environment.wordsPerPage - 1) / Environment.wordsPerPage;  td: PUBLIC GlobalDataHandle ¬ NIL;  zone: PUBLIC UNCOUNTED ZONE ¬ Heap.Create[initial: 16, increment: 4];  myCursorType: Cursor.Type ¬ Cursor.UniqueType[];  cursor: Cursor.Object ¬ [    info: [myCursorType, 8, 8],    array: [    003740B, 017770B, 037774B, 077776B, 076076B, 161707B, 153753B, 123145B,    113151B, 143743B, 161707B, 076076B, 077776B, 037774B, 017770B, 003740B]];  oldCursor: Cursor.Object;  plagiarizeWh: Window.Handle ¬ NIL;  << Window list management. >>  AddToList: ENTRY PROCEDURE [wh: Window.Handle] = {    ENABLE UNWIND => NULL;    td.windows ¬ zone.NEW[WindowRecord ¬ [wh: wh, link: td.windows]]};  LocateQuiescentTool: ENTRY PROCEDURE RETURNS [wh: Window.Handle] = {    ENABLE UNWIND => NULL;    wh ¬ NIL;    FOR w: WindowList ¬ td.windows, w.link WHILE w # NIL DO      SELECT ToolWindow.GetState[w.wh] FROM        active => NULL;        inactive => {ToolWindow.Activate[w.wh]; wh ¬ w.wh; RETURN};        tiny => NULL;        ENDCASE;      ENDLOOP};  RemoveFromList: ENTRY PROCEDURE [wh: Window.Handle] = {    ENABLE UNWIND => NULL;    w: LONG POINTER TO WindowList;    FOR w ¬ @td.windows, @w.link WHILE w­ # NIL DO      IF w.wh = wh THEN {        flush: WindowList ¬ w­; w­ ¬ w.link; zone.FREE[@flush]; RETURN};      ENDLOOP};  << Initialization.  >>  Init: PROCEDURE = {    commandName: LONG STRING;    td ¬ zone.NEW[      GlobalData ¬ [      context: Context.UniqueType[],      rootName: String.CopyToNewString[s: "RHExerciser"L, z: zone]]];    commandName ¬ String.CopyToNewString[s: td.rootName, z: zone, longer: 2];    String.AppendString[to: commandName, from: ".~"L];    Exec.AddCommand[      name: commandName, proc: RegisterCommand, help: HelpProc,      unload: UnloadProc];    String.FreeString[z: zone, s: commandName];    td.nameStripeName ¬ String.CopyToNewString[      s: td.rootName, z: zone, longer: 55];    String.AppendString[to: td.nameStripeName, from: " of "];    Time.Append[      s: td.nameStripeName, unpacked: Time.Unpack[time: Runtime.GetBcdTime[]],      zone: TRUE];    String.AppendString[to: td.nameStripeName, from: " running on Pilot "];    Version.Append[td.nameStripeName];    adjustUp ¬ Atom.MakeAtom["AdjustUp"L];    pointUp ¬ Atom.MakeAtom["PointUp"L];    };  RegisterCommand: Exec.ExecProc = {    wh: Window.Handle;    IF (wh ¬ LocateQuiescentTool[]) = NIL THEN wh ¬ CreateInstance[]};  HelpProc: Exec.ExecProc = {    Exec.OutputProc[h][      "RHExerciser: Version 1.0\n\nThis version of RHExerciser is the initial cut at providing a more \"User-friendly\" interface to the microcode/assembly code debugging facilities.\n\nThe tool, when it is intially loaded, comes up looking very much like the FormSWLayout tool (upon which it was in part based).\n\nIt is essentially a multiple instance version of the FormSWLayout tool with the command \"Another!\" used to bring up another instance of the tool.\n\nThe command \"Destroy!\" destroys the instance of the tool.\n\nTyping the command RHExerciser.~ is equivalent to selecting \"Another!\" in an active instance of the tool.\n\nThe \"DoIt!\" command of the FormSWLayout tool has been changed to \"BuildMesa!\"\n\nThe \"SetWindows!\" command is used to create the newly laid out formSW and to bring up the formSW allowing interaction with Bindweed.\n\nThe \"Revert!\" command will return the tool to the layout state.\n\n\n"L]};  UnloadProc: Exec.ExecProc = {    commandName: LONG STRING;    tempPtr: WindowList;    commandName ¬ String.CopyToNewString[s: td.rootName, z: zone, longer: 2];    String.AppendString[to: commandName, from: ".~"];    h.RemoveCommand[name: commandName];    zone.FREE[@commandName];    WHILE (tempPtr ¬ td.windows) # NIL DO      td.windows ¬ td.windows.link; Tool.Destroy[window: tempPtr.wh]; ENDLOOP;    zone.FREE[@td];    Heap.Delete[z: zone]};  << Tool creation/destruction.  >>  AnotherInstance: PUBLIC FormSW.ProcType = {    IF LocateQuiescentTool[] = NIL THEN [] ¬ CreateInstance[]};  CreateInstance: PROCEDURE RETURNS [wh: Window.Handle] = {    instance: DataHandle;    AddToList[      wh: wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default,      clientTransition: ClientTransition, name: td.nameStripeName,      tinyName1: td.tinyName1, tinyName2: td.tinyName2, cmSection: td.rootName]];    instance ¬ SimpleDisplayer.Lock[wh: wh];    Put.Text[instance.fileSW, td.rootName];    Put.Line[instance.fileSW, "'s fileSW."L];    SimpleDisplayer.UnLock[wh: wh]};  DestroyInstance: PUBLIC FormSW.ProcType = {    wh: Window.Handle = ToolWindow.WindowForSubwindow[sw: sw];    RemoveFromList[wh: wh];    Tool.Destroy[window: wh]};  MakeDrawSW: PROC [sw: Window.Handle, clientData: LONG POINTER] = {    box: Window.Box ¬ [[0, 0], [w: swWidth, h: drawHeight]];    instance: DataHandle = SimpleDisplayer.Share[      wh: ToolWindow.WindowForSubwindow[sw: sw]];    BitSW.Create[sw, [instance.buffer, 0, 0], swWidth, box, [TRUE, TRUE, 1]];    BitSW.White[sw, box];    };  MakeForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = Items.LAST.ORD + 1;    instance: DataHandle = SimpleDisplayer.Share[      wh: ToolWindow.WindowForSubwindow[sw: sw]];    formType: ARRAY [0..8) OF Enumerated ¬ [      ["bool"L, FormSW.ItemType.boolean], ["command"L, FormSW.ItemType.command], [      "enum"L, FormSW.ItemType.enumerated], [      "longNum"L, FormSW.ItemType.longNumber], ["numb"L, FormSW.ItemType.number], [      "source"L, FormSW.ItemType.source], ["string"L, FormSW.ItemType.string], [      "tag"L, FormSW.ItemType.tagOnly]];    items ¬ AllocateItemDescriptor[nItems, zone];    items[Items.formType.ORD] ¬ EnumeratedItem[      tag: "FormType"L, place: [0, line0], feedback: all,      choices: DESCRIPTOR[formType], value: @instance.formtype, z: zone];    items[Items.tag.ORD] ¬ StringItem[      tag: "Tag"L, place: [0, line1], boxWidth: 300, inHeap: TRUE,      string: @instance.tag, z: zone];    items[Items.zone.ORD] ¬ StringItem[      tag: "Zone"L, place: [340, line1], inHeap: TRUE, string: @instance.toolZone,      z: zone];    items[Items.setWindows.ORD] ¬ CommandItem[      tag: "SetWindows"L, place: [0, line2], proc: SetWindows, z: zone];    items[Items.alignX.ORD] ¬ BooleanItem[      tag: "AlignX"L, place: [72, line2], switch: @instance.alignX, z: zone];    items[Items.usebox.ORD] ¬ BooleanItem[      tag: "Usebox"L, place: [120, line2], switch: @instance.useBox, z: zone];    items[Items.anyfont.ORD] ¬ BooleanItem[      tag: "Anyfont"L, place: [174, line2], switch: @instance.anyFont, z: zone];    items[Items.root.ORD] ¬ StringItem[      tag: "Root"L, place: [228, line2], inHeap: TRUE, string: @instance.root,      z: zone];    items[Items.doIt.ORD] ¬ CommandItem[      tag: "BuildMesa"L, place: [0, line3], proc: BuildMesa, z: zone];    items[Items.clear.ORD] ¬ CommandItem[      tag: "Clear"L, place: [72, line3], proc: Clear, z: zone];    items[Items.setDefaults.ORD] ¬ CommandItem[      tag: "SetDefaults"L, place: [120, line3], proc: SetDefaults, z: zone];    items[Items.load.ORD] ¬ CommandItem[      tag: "Load"L, place: [204, line3], proc: Load, z: zone];    items[Items.save.ORD] ¬ CommandItem[      tag: "Save"L, place: [240, line3], proc: Save, z: zone];    items[Items.plagiarize.ORD] ¬ CommandItem[      tag: "Plagiarize"L, place: [282, line3], proc: Plagiarize, z: zone];    items[Items.another.ORD] ¬ CommandItem[      tag: "Another"L, place: [384, line3], proc: AnotherInstance, z: zone];    items[Items.destroy.ORD] ¬ CommandItem[      tag: "Destroy"L, place: [444, line3], proc: DestroyInstance, z: zone];    RETURN[items: items, freeDesc: TRUE];    };  MakeNode: PROC [length: CARDINAL] RETURNS [p: LONG POINTER] = {    t: TYPE = RECORD [SEQUENCE len: CARDINAL OF WORD]; p ¬ zone.NEW[t [length]]; };  MakeSWs: Tool.MakeSWsProc = {    logName: LONG STRING ¬ [24];    instance: DataHandle = SimpleDisplayer.Share[wh: window];    Tool.UnusedLogName[unused: logName, root: "RHExerciser.log"L];    instance.msgSW ¬ Tool.MakeMsgSW[window: window, lines: 3];    instance.formSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeForm, zone: zone];    instance.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    instance.bitSW ¬ Tool.MakeClientSW[      window: window, clientProc: MakeDrawSW, clientData: NIL,      swType: BitSW.Type[], h: drawHeight];    FormSW.SetModifyNotificationProc[instance.formSW, Modified];    TIP.CreateClient[      instance.bitSW, SimpleDisplayer.GetTip[], SimpleDisplayer.Notify];    };  << Transitions. >>  ClientTransition: ToolWindow.TransitionProcType = {    SELECT TRUE FROM      old = inactive => {        instance: DataHandle = zone.NEW[Data ¬ []];        instance.defaults ¬ zone.NEW[SimpleDisplayer.DefaultRecord ¬ []];        Context.Create[          type: td.context, data: instance, proc: Context.NopDestroyProc,          window: window];        instance.root ¬ String.CopyToNewString["SimpleTool"L, zone];        instance.defaults.enumType ¬ String.CopyToNewString["FormItems"L, zone];        instance.defaults.handleName ¬ String.CopyToNewString["data"L, zone];        instance.defaults.procName ¬ String.CopyToNewString["MakeForm"L, zone];        AllocateBitSWSpace[instance: instance];        instance.small ¬ MakeNode[bufSize];        instance.bufSW ¬ zone.NEW[Window.Object];        instance.bufSW.InitializeWindow[          display: NIL, box: instance.smallBox, parent: NIL,          clearingRequired: FALSE];        LOOPHOLE[instance.bufSW, WindowOps.Handle].inTree ¬ TRUE;        instance.special ¬ zone.NEW[          SpecialDisplay.SpecialContext ¬ [          bmAddress: LOP[instance.small], wpl: 0, bpl: 0, alloc: NIL, free: NIL]];        instance.charWidth ¬ WindowFont.CharWidth['0];        instance.lineHeight ¬ WindowFont.FontHeight[] + 4;        instance.bufStr ¬ zone.NEW[StringBody [100]];        instance.lastBox ¬ Window.nullBox;        };      new = inactive => {        instance: DataHandle ¬ SimpleDisplayer.Share[window];        ToolWindow.SetTinyName[window: window, name: td.rootName, name2: NIL];        IF instance.bitSW # NIL THEN {          TIP.DestroyClient[instance.bitSW];          TIP.NewManager[NIL, NIL, NIL];          IF instance.segment # NIL THEN MSegment.Delete[instance.segment];          IF BitSW.IsIt[instance.bitSW] THEN BitSW.Destroy[instance.bitSW];  << This causes the BitSW to revert to an undifferentiated subwindow. >>          instance.buffer ¬ instance.segment ¬ NIL};        SimpleDisplayer.DestroyAllItems[instance: instance];        IF instance.dataSequence # NIL THEN zone.FREE[@instance.dataSequence];        zone.FREE[@instance.small];        zone.FREE[@instance.bufSW];        zone.FREE[@instance.special];        zone.FREE[@instance.bufStr];        zone.FREE[@instance.defaults.enumType];        zone.FREE[@instance.defaults.handleName];        zone.FREE[@instance.defaults.procName];        zone.FREE[@instance.defaults.stuffString];        zone.FREE[@instance.defaults];        Context.Destroy[type: td.context, window: window];        zone.FREE[@instance]};      ENDCASE;    };  << FormSW invoked PROCEDURES. >>  SetWindows: FormSW.ProcType = {    wh: Window.Handle ¬ ToolWindow.WindowForSubwindow[sw: sw];    instance: DataHandle = SimpleDisplayer.Lock[wh: wh];    SimpleDisplayer.SwapSWs[instance: instance, window: wh, state: use];    SimpleDisplayer.UnLock[wh: wh]};  BuildMesa: FormSW.ProcType = {    wh: Window.Handle ¬ ToolWindow.WindowForSubwindow[sw: sw];    instance: DataHandle = SimpleDisplayer.Lock[wh: wh];    name: LONG STRING ¬ zone.NEW[StringBody [String.Length[instance.root] + 5]];    OutProc: Format.StringProc = {instance.stream.PutString[s]};    MsgSW.Clear[instance.msgSW];    String.AppendString[name, instance.root];    IF String.Length[name] # 0 THEN      BEGIN      String.AppendString[name, ".mesa"L];      instance.stream ¬ MStream.WriteOnly[name, [], text];      SimpleDisplayer.WriteOut[OutProc, instance.anyFont, instance];      instance.stream.Delete[];      instance.stream ¬ NIL;      END    ELSE Put.Line[instance.fileSW, "A file name is required for DoIt! !"L];    zone.FREE[@name];    SimpleDisplayer.UnLock[wh: wh]};  Clear: FormSW.ProcType = {    box: Window.Box ¬ [[0, 0], [w: swWidth, h: drawHeight]];    wh: Window.Handle ¬ ToolWindow.WindowForSubwindow[sw: sw];    instance: DataHandle = SimpleDisplayer.Lock[wh: wh];    MsgSW.Clear[instance.msgSW];    << Here we would deallocate all items. >>    SimpleDisplayer.DestroyAllItems[instance: instance];    BitSW.White[instance.bitSW, box];    instance.bitSW.InvalidateBox[box];    instance.bitSW.Validate[];    instance.selectedItem ¬ instance.brushItem ¬ NIL;    ToolWindow.SetTinyName[window: wh, name: td.rootName, name2: NIL];    SimpleDisplayer.UnLock[wh: wh]};  SetDefaults: FormSW.ProcType = {    wh: Window.Handle ¬ ToolWindow.WindowForSubwindow[sw: sw];    instance: DataHandle = SimpleDisplayer.Lock[wh: wh];    MakeDefaultSWs: Tool.MakeSWsProc = {      instance.defaults.formSW ¬ Tool.MakeFormSW[        window: window, formProc: MakeDefaultForm, zone: zone];      };    MakeDefaultForm: FormSW.ClientItemsProcType = {      OPEN FormSW;      nItems: CARDINAL = DItems.LAST.ORD + 1;      feedbackEnum: ARRAY [0..2) OF Enumerated ¬ [["all"L, 0], ["one"L, 1]];      radix: ARRAY [0..2) OF Enumerated ¬ [["decimal"L, 0], ["octal"L, 1]];      feedbackString: ARRAY [0..2) OF Enumerated ¬ [        ["normal"L, 0], ["password"L, 1]];      items ¬ AllocateItemDescriptor[nItems, zone];      items[DItems.close.ORD] ¬ CommandItem[        tag: "Close"L, place: [0, line0], drawBox: TRUE, proc: Close, z: zone];      items[DItems.newDefaults.ORD] ¬ TagOnlyItem[        tag: "[Defaults for new items]"L, place: [0, line2], z: zone];      items[DItems.readOnly.ORD] ¬ BooleanItem[        tag: "ReadOnly"L, place: [0, line3], switch: @instance.defaults.readOnly,        z: zone];      items[DItems.invisible.ORD] ¬ BooleanItem[        tag: "Invisible"L, place: [126, line3],        switch: @instance.defaults.invisible, z: zone];      items[DItems.drawBox.ORD] ¬ BooleanItem[        tag: "DrawBox"L, place: [246, line3], switch: @instance.defaults.drawBox,        z: zone];      items[DItems.hasContext.ORD] ¬ BooleanItem[        tag: "HasContext"L, place: [354, line3],        switch: @instance.defaults.hasContext, z: zone];      items[DItems.enumDefaults.ORD] ¬ TagOnlyItem[        tag: "[Enumerated defaults]"L, place: [0, line5], z: zone];      items[DItems.copyChoices.ORD] ¬ BooleanItem[        tag: "CopyChoices"L, place: [0, line6],        switch: @instance.defaults.copyChoices, z: zone];      items[DItems.feedbackEnum.ORD] ¬ EnumeratedItem[        tag: "Feedback"L, place: [126, line6], choices: DESCRIPTOR[feedbackEnum],        value: @instance.defaults.feedbackEnum, z: zone];      items[DItems.numDefaults.ORD] ¬ TagOnlyItem[        tag: "[(Long) Number defaults]"L, place: [0, line8], z: zone];      items[DItems.radix.ORD] ¬ EnumeratedItem[        tag: "Radix"L, place: [0, line9], choices: DESCRIPTOR[radix],        value: @instance.defaults.radix, z: zone];      items[DItems.notNegative.ORD] ¬ BooleanItem[        tag: "NotNegative"L, place: [126, line9],        switch: @instance.defaults.notNegative, z: zone];      items[DItems.signed.ORD] ¬ BooleanItem[        tag: "Signed"L, place: [246, line9], switch: @instance.defaults.signed,        z: zone];      items[DItems.boxWidthNum.ORD] ¬ NumberItem[        tag: "BoxWidth"L, place: [354, line9], default: 64,        value: @instance.defaults.boxWidthNumber, z: zone];      items[DItems.longDefault.ORD] ¬ LongNumberItem[        tag: "(Long)Default"L, place: [0, LineN[10]],        value: @instance.defaults.longDefault, z: zone];      items[DItems.shortDefault.ORD] ¬ NumberItem[        tag: "(Short)Default"L, place: [246, LineN[10]],        value: @instance.defaults.shortDefault, z: zone];      items[DItems.stringDefaults.ORD] ¬ TagOnlyItem[        tag: "[String defaults]"L, place: [0, LineN[12]], z: zone];      items[DItems.inHeap.ORD] ¬ BooleanItem[        tag: "InHeap"L, place: [0, LineN[13]], switch: @instance.defaults.inHeap,        z: zone];      items[DItems.feedbackString.ORD] ¬ EnumeratedItem[        tag: "Feedback"L, place: [126, LineN[13]],        choices: DESCRIPTOR[feedbackString],        value: @instance.defaults.feedbackString, z: zone];      items[DItems.boxWidthStr.ORD] ¬ NumberItem[        tag: "BoxWidth"L, place: [354, LineN[13]], default: 0,        value: @instance.defaults.boxWidthString, z: zone];      items[DItems.startRecord.ORD] ¬ TagOnlyItem[        tag: "[MACHINE DEPENDENT RECORD]"L, place: [0, LineN[15]], z: zone];      items[DItems.startingword.ORD] ¬ NumberItem[        tag: "Starting word"L, place: [0, LineN[16]], default: 0,        value: @instance.defaults.startingword, z: zone];      items[DItems.globals.ORD] ¬ TagOnlyItem[        tag: "[Global Things]"L, place: [0, LineN[18]], z: zone];      items[DItems.enumType.ORD] ¬ StringItem[        tag: "EnumType"L, place: [0, LineN[19]], inHeap: TRUE,        string: @instance.defaults.enumType, z: zone];      items[DItems.handleName.ORD] ¬ StringItem[        tag: "HandleName"L, place: [240, LineN[19]], inHeap: TRUE,        string: @instance.defaults.handleName, z: zone];      items[DItems.procName.ORD] ¬ StringItem[        tag: "ProcName"L, place: [0, LineN[20]], inHeap: TRUE,        string: @instance.defaults.procName, z: zone];      items[DItems.stuffString.ORD] ¬ StringItem[        tag: "StuffString"L, place: [0, LineN[21]], inHeap: TRUE,        string: @instance.defaults.stuffString, z: zone];      RETURN[items: items, freeDesc: TRUE];      };    MsgSW.Clear[instance.msgSW];    instance.defaultsToolWh ¬ Tool.Create[      makeSWsProc: MakeDefaultSWs, initialState: default, initialBox: initialBox,      name: "Defaults"L, cmSection: "Defaults"L];    Context.Create[      type: td.context, data: instance, proc: Context.NopDestroyProc,      window: instance.defaultsToolWh];    SimpleDisplayer.UnLock[wh: wh]};  Load: FormSW.ProcType = {    wh: Window.Handle ¬ ToolWindow.WindowForSubwindow[sw: sw];    instance: DataHandle = SimpleDisplayer.Lock[wh: wh];    name: LONG STRING ¬ zone.NEW[StringBody [String.Length[instance.root] + 4]];    BEGIN    MsgSW.Clear[instance.msgSW];    << we should have a check to see if the property sheet is still open.  >>    String.AppendString[name, instance.root];    IF String.Length[name] # 0 THEN      BEGIN      String.AppendString[name, ".bif"L];      instance.stream ¬ MStream.ReadOnly[name, [] ! MStream.Error => GOTO quit];      SimpleDisplayer.Load[instance];      instance.stream.Delete[];      instance.stream ¬ NIL;      name.length ¬ name.length - 4;      IF name.length > 10 THEN name.length ¬ 10;      ToolWindow.SetTinyName[window: wh, name: name, name2: "\\|/"L];      END    ELSE Put.Line[instance.fileSW, "A file name is required for Load! !"L];    zone.FREE[@name];    SimpleDisplayer.UnLock[wh: wh];    [] ¬ UserInput.CreatePeriodicNotify[Redisplay, sw, 0];    EXITS      quit => {        Put.Line[instance.msgSW, "File not found"L];        UserTerminal.BlinkDisplay[];        SimpleDisplayer.UnLock[wh: wh]};    << closeDefaults => {	  Put.Line[instance.msgSW, "Must close Default Option sheet first"L];	  UserTerminal.BlinkDisplay[]; SimpleDisplayer.UnLock[wh: wh]}; >>    END};  Save: FormSW.ProcType = {    wh: Window.Handle ¬ ToolWindow.WindowForSubwindow[sw: sw];    instance: DataHandle = SimpleDisplayer.Lock[wh: wh];    name: LONG STRING ¬ zone.NEW[StringBody [String.Length[instance.root] + 4]];    OutProc: Format.StringProc = {instance.stream.PutString[s]};    MsgSW.Clear[instance.msgSW];    String.AppendString[name, instance.root];    IF String.Length[name] # 0 THEN      BEGIN      String.AppendString[name, ".bif"L];      instance.stream ¬ MStream.WriteOnly[name, [], text];      SimpleDisplayer.Save[OutProc, instance];      instance.stream.Delete[];      instance.stream ¬ NIL;      name.length ¬ name.length - 4;      IF name.length > 10 THEN name.length ¬ 10;      ToolWindow.SetTinyName[window: wh, name: name, name2: "\\|/"L];      END    ELSE Put.Line[instance.fileSW, "A file name is required for Save! !"L];    zone.FREE[@name];    SimpleDisplayer.UnLock[wh: wh]};  Plagiarize: FormSW.ProcType = {    wh: Window.Handle ¬ ToolWindow.WindowForSubwindow[sw: sw];    instance: DataHandle = SimpleDisplayer.Lock[wh: wh];    MsgSW.Clear[instance.msgSW];    Cursor.Fetch[@oldCursor];    Cursor.Store[@cursor];    plagiarizeWh ¬ wh;    TIP.NewManager[Window.rootWindow, TIP.mouseTIP, Interpret];    SimpleDisplayer.UnLock[wh: wh];    };  << Additional PUBLIC procedures. >>  AllocateBitSWSpace: PUBLIC PROCEDURE [instance: DataHandle] = {    box: Window.Box ¬ [[0, 0], [w: swWidth, h: drawHeight]];    window: Window.Handle ¬ NIL;    IF instance.segment # NIL THEN RETURN;    instance.segment ¬ MSegment.Create[      file: NIL, release: [], fileBase: 0, pages: swPages];    instance.buffer ¬ MSegment.Address[instance.segment];    IF instance.fileSW # NIL THEN {      window ¬ ToolWindow.WindowForSubwindow[sw: instance.fileSW];      IF ~BitSW.IsIt[instance.bitSW] THEN        instance.bitSW ¬ Tool.MakeClientSW[          window: window, clientProc: MakeDrawSW, clientData: NIL,          swType: BitSW.Type[] !          Scrollbar.Error => {            SELECT code FROM              alreadyExists => CONTINUE;              doesNotExist, other => REJECT;              ENDCASE => ERROR}];      BitSW.White[instance.bitSW, box];      TIP.CreateClient[        instance.bitSW, SimpleDisplayer.GetTip[], SimpleDisplayer.Notify]};    };  ReclaimBitSWSpace: PUBLIC PROCEDURE [instance: DataHandle] = {    IF ~BitSW.IsIt[instance.bitSW] OR instance.segment = NIL THEN RETURN;    TIP.DestroyClient[instance.bitSW];    Tool.DeleteThisSW[instance.bitSW];    MSegment.Delete[instance.segment];    BitSW.Destroy[instance.bitSW];  << This causes the BitSW to revert to an undifferentiated subwindow. >>    ToolWindow.Destroy[window: instance.bitSW];    instance.bitSW ¬ NIL;    instance.buffer ¬ instance.segment ¬ NIL};  << Additional procedures. >>  Interpret: TIP.NotifyProc = {    coords, bitmapPlace: Window.Place;    FOR input: TIP.Results ¬ results, input.Rest UNTIL input = NIL DO      WITH z: input.First SELECT FROM        coords => coords ¬ z.place;        atom =>          SELECT z.a FROM            adjustUp => {Cursor.Store[@oldCursor]; TIP.NewManager[NIL, NIL, NIL]};            pointUp => {              bitmapPlace ¬ window.BitmapPlace[coords];              SimpleDisplayer.Plagiarize[                Window.BitmapPlaceToWindowAndPlace[bitmapPlace].window,                plagiarizeWh];              Cursor.Store[@oldCursor];              TIP.NewManager[NIL, NIL, NIL]};            ENDCASE;        ENDCASE;      ENDLOOP;    };  LOP: PROCEDURE [LONG POINTER] RETURNS [LONG ORDERED POINTER] = MACHINE CODE {};  Modified: FormSW.ProcType = {    instance: DataHandle = SimpleDisplayer.Share[      wh: ToolWindow.WindowForSubwindow[sw: sw]];    instance.modified ¬ TRUE;    FOR i: Items IN Items DO      item: FormSW.ItemHandle ¬ FormSW.FindItem[instance.formSW, i.ORD];      IF item.flags.modified THEN item.flags.modified ¬ FALSE;      ENDLOOP;    };  Redisplay: UserInput.PeriodicProcType = {FormSW.Display[window]};  << Here we handle the Defaults Tool. >>  Close: FormSW.ProcType = {    wh: Window.Handle = ToolWindow.WindowForSubwindow[sw: sw];    [] ¬ UserInput.CreatePeriodicNotify[Kill, wh, 0]};  Kill: UserInput.PeriodicProcType = {    item: FormSW.ItemHandle ¬ NIL;    instance: DataHandle = SimpleDisplayer.Share[wh: window];    IF window = NIL THEN RETURN;    FOR i: CARDINAL IN [0..DItems.LAST.ORD] DO      item ¬ FormSW.FindItem[instance.defaults.formSW, i];      WITH it: item­ SELECT FROM        string => IF String.Length[it.string­] > 0 THEN it.inHeap ¬ FALSE;        ENDCASE;      ENDLOOP;    Context.Destroy[type: td.context, window: window];    Tool.Destroy[instance.defaultsToolWh];    instance.defaultsToolWh ¬ NIL;    };  -- Mainline code  Init[];  -- this gets string out of global frame  }...  LOG  Created by FormSWLayoutTool on 13-Feb-84 20:22  last edited: Dennis E. DEG      26-Mar-84  3:33:51    
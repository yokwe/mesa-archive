$	DEBUG MOD186; FXB   .PA 	31-May-85 12:48:14	:fixed StopPCE (loaded DS w/ IORegion base; FXB   .PA 	 1-May-85 10:51:15	:fixed StopPCE ; FXB   .PA	11-Apr-85 13:59:28	:added StopPCE; FXB   .PA	22-Feb-85 10:12:26	:added ResetCP; FXB   .PA	15-Feb-85  9:23:55	:moved blockAddrA to Bindweed's IO Region; FXB   .PA	12-Feb-85 12:49:51 	:added CLI on entry to BreakPoint and Single Step handlers; FXB   .PA	 7-Feb-85 16:16:41	:added DebReadHB; FXB   .PA	 6-Feb-85 11:24:23	:added Establish Access for PCE for OPIEAddress conversion; FXB   .PA	18-Dec-84  5:45:19	:added OPIE address conversion; FXB   .PA	18-Dec-84  4:19:58	:load AX with workNotify mask before changing DS to IORegion; FXB   .PA	16-Dec-84 16:34:24	:move SEG IORegion to DS before OPIE calls; FXB   .PA	13-Dec-84 11:22:25	:fixed RemoteMemory so DS points at IORegion during OPIE calls; FXB   .PA	12-Dec-84 17:52:08	:Changes to save boot-time register values; VXS  .PA	 5-Dec-84 20:24:19	:Put conditional RemoteMemory in.; VXS  .PA	 5-Dec-84 18:52:50	:Changed ORG 400H to ORG OFFSET BurdockSavedRegisters; FXB   .PA	 4-Dec-84 10:14:13	:added remoteMemory command; FXB   	30-Nov-84  9:52:39	:OPIE!16 update; FXB   	29-Nov-84 11:23:28	:made Bindweed a NEAR PROC; FXB   	27-Nov-84 10:36:34	:changed code segment name from InitCode to IOPEInROM; FXB   	 6-Nov-84 10:32:46	:added CP commands; FXB   	27-Sep-84 16:30:53	:made Down notify a software interrupt; FXB   	24-Sep-84 14:47:12	:POP DS before DownNotify; FXB   	21-Sep-84 14:56:13	:zero ES on entry to Bindweed; FXB   	18-Sep-84 11:24:27	:reset debugStatus after each reply; FXB   	11-Sep-84 14:30:40	:use IOPDEFS instead of HARDDEFS; FXB   	 4-Sep-84 14:39:00	:included IOPLRAM and IOPDEFS.ASM; FXB   	31-Aug-84 11:28:19	:made changes to use IOPELocalRam; FXB   	30-Aug-84 12:34:39	:fixed resetting of int flag in SingleStep; Last edited by Frank FXB    21-Aug-84 14:16:18;	NAME	bwopie$	TITLE(Debugger Kernel)$	NOLIST		;Next line includes definitions file$	INCLUDE(UMBDEFS.ASM)	$	INCLUDE(IOPDEFS.ASM)$	INCLUDE(HARDDEFS.ASM)$	INCLUDE(IOPLRAM.ASM)$	INCLUDE(IOPMACRO.ASM)$	LIST		;Previous line included definitions file;;;;conditional assembly switches:%SET(RemoteMemory,1);  IOPELocalRam		SEGMENT		COMMON		ORG 	OFFSET BurdockSavedRegisters		PUBLIC	BindweedBufferPUBLIC savedBX, savedCX, savedSP, savedSI, savedDI, savedDS, savedSS, savedES, savedAX, savedDX		BurdockDataSpace	LABEL	FAR		;Data Space for Budock		;			savedRegisters  		LABEL	FARsavedAX	DW	?	;savedBX	DW	?	;savedCX	DW	?	;savedDX	DW	?	;savedSP	DW	?	;savedBP	DW	?	;savedSI	DW	?	;savedDI	DW	?	;savedCS	DW	?	;savedDS	DW	?	;savedSS	DW	?	;savedES	DW	?	;savedIP	DW	?	;savedFLAGS	DW	?	debugStatus		DW	?	;status sent to debuggeriopDebugState		DB	?	;current debugging stateIsABreakPoint		DB	?	;set to YES by the debugger 					;if an INT 3 was executedSingleStepFlags		DW	?	;an extra copy of the Status Word used by 					;the single step handler to save the 					;interrupt flag during a single stepCSOfBreakPoint		DW	?IPOfBreakPoint		DW	?YES			EQU	1BreakPointInstr		EQU	0CCHTrapResetMask		EQU	0FEFFHintFlagMask		EQU	0FDFFHIOPELocalRam		ENDSIOPEInRaM SEGMENT PUBLICEXTRN StopPC: FARIOPEInRaM	ENDS		IORegion		SEGMENT		COMMON 			Assume DS:IORegion			EXTRN workNotifierCondition: ConditionEXTRN blockAddrA: OpieAddress						%IF(%RemoteMemory) THEN (				EXTRN RemoteMemoryAddress: DWORD, wordCount: WORDEXTRN RemoteMemoryStartCond: Condition, RemoteMemoryDoneCond: ConditionEXTRN startOfMaskAndNewDataArray: WORD)FI %' end of %IF(%RemoteMemory)IORegion		ENDSIOPEInROM	SEGMENT	PUBLICASSUME	CS: IOPEInROM, DS: IOPELocalRamPUBLIC	BreakIntrHandler, SSIntrHandler, DebuggerIntrHandler, Bindweed, BindweedDownNotifyVec, DisbleInts		 BindweedDownNotifyInt	EQU	16BindweedDownNotifyVec	EQU	BindweedDownNotifyInt*4		bwMemoryCommandBuffer	STRUC	bwMemFiller	DB 	3	DUP	(?)		addressSegment	DW	?	addressOffset	DW	?	addressType	DB	?	bwLength		DB	?	data		DB	?bwMemoryCommandBuffer	ENDSbwDownNotifyBuffer	STRUC	bwFiller	DB	3	DUP	(?)	downNotifyMask		DW	?bwDownNotifyBuffer	ENDS	bwIOCommandBuffer	STRUC	count		DW	?	command		DB	?	port		DW	?	ioData		DW	?bwIOCommandBuffer	ENDSbwReplyBuffer	STRUC	bwCount1	DB	?	bwCount2	DB	?	status		DW	?	empty		DB	?	replyData	DB	?bwReplyBuffer	ENDS		iopStatusMask	EQU	3000H	;bit 2 and 3 set to notify 					;i186Burdock and BWDisplayeriopSingleStep	EQU	05HiopHalted	EQU	02HiopBreak	EQU	04HbwMinReply		EQU	3	; the minimum length of a reply	TimeOutConst		EQU	500	;needs adjust, want about 1ms;==============================================================================BreakIntrHandler	LABEL 	FAR 	CLI	CALL 	SaveState	MOV	AX, SEG debugStatus	MOV	DS, AX	MOV	BX, OFFSET debugStatus	OR	[BX], iopStatusMask ; set "naked notify" bits	MOV	iopDebugState, iopBreak		MOV	CX, 0		; Let Debugger know that you hit a breakpoint	CALL	CreateReply	CALL	SendReply	JMP 	DisbleInts  	;in DebuggerIntrHandler;===============================================================================SSIntrHandler	LABEL 	FAR	CLI 	CALL 	SaveState	MOV	AX, SEG debugStatus	MOV	DS, AX	MOV	BX, SingleStepFlags	AND	BX, NOT intFlagMask 	;clear all bits but int flag in old FLAGS	OR	savedFLAGS, BX		;restore int flag	MOV	AX, TrapResetMask	AND 	savedFLAGS, AX  	;reset trap flag	CMP	IsABreakPoint, YES	;is this a break point?	JNE	NotABreakPoint	MOV	AL, 0	MOV	IsABreakPoint, AL	;reset IsABreakPoint	MOV	AX, CSOfBreakPoint	;get address of broken instruction	MOV	ES, AX			;ES _ CSOfBreakPoint	MOV	BX, IPOfBreakPoint 	;BX _ IPOfBreakPoint	MOV	ES: BYTE PTR [BX], BreakPointInstr	;put the break instr back	JMP	DebuggerIntrFinish		;RETURNNotABreakPoint:	MOV	BX, OFFSET debugStatus	OR	[BX], iopStatusMask ; set "naked notify" bits	MOV	iopDebugState, iopSingleStep		MOV	CX, 0	;let debugger know you executed a single step	CALL	CreateReply	CALL	SendReply	JMP 	DisbleInts  	;in DebuggerIntrHandler;===============================================================================;;;Subroutine CreateReply;CreateReply:;	on entry: CL = length of data;	AH checksum	MOV	BX, OFFSET BindweedBuffer	ADD	CL, bwMinReply	MOV	[BX].bwCount1, CL	MOV	[BX].bwCount2, CL	MOV	DX, debugStatus	MOV	[BX].status, DX	MOV	AX, 0	MOV	debugStatus, AX	XOR	AH, AH		; clear checksum	ADD	CL, 1 		;include  2 count bytes - checksum byte	XOR	CH, CH		;clear high byte of loop counterchecksumLoop:	ADD	AH, [BX]	;add buffer byte to checksum	INC	BX		;increment bindweed buffer index	LOOP	checksumLoop	MOV	AL, 0	SUB	AL, AH	MOV	[BX], AL 	;insert checksum				;buffer is now ready to send	RET	;===============================================================================;Subroutine: SendReply;	SendReply:	MOV 	CL, BindweedBuffer	;get count	ADD	CL, 2		;include count bytes	XOR	CH, CH	MOV	BX, OFFSET BindweedBufferSendBWBuffer:	MOV	DL, [BX]	CALL	DebPutOutByte	INC	BX	LOOP	SendBWBuffer	RET			;SendAck:	MOV	BX, OFFSET debugStatus	OR	[BX], iopStatusMask ; set "naked notify" bits 	MOV	iopDebugState, iopHalted		MOV	CL, 0	;Let Debugger know that you have halted	JMP	PrepareReplyBuffer	DebWriteMem:	CALL	DebSetMemBlockDesc	;get block descriptor from bwBuffer	MOV	BX, OFFSET BindweedBuffer.data	;BP _ index of start of dataDebWriteMemLoop:	MOV	AL, [BX]		;get data byte from bindweed buffer	MOV	ES:[DI], AL		;and store it	INC	BX	INC	DI	LOOP	DebWriteMemLoop		;Do this loop CX times...;--	MOV	CL, 0			;no data in reply 	JMP	PrepareReplyBuffer 	DebReadMem:	CALL	DebSetMemBlockDesc	MOV	BX, OFFSET BindweedBuffer.replyData	;	MOV	AH, CL 			;save count for reply bufferDebReadMemLoop:	MOV	AL, ES:[DI]		;get data from memory	MOV	[BX], AL		;put it in the bindweed buffer	INC	BX			;increment memory index	INC	DI			;increment bindweed buffer index	LOOP	DebReadMemLoop		;Do this loop CX times...	MOV	CL, AH 			;set length of reply data	ADD	CL, 1	JMP	PrepareReplyBuffer	DebReadIOByte:	MOV	BX, OFFSET BindweedBuffer	MOV	DX, [BX].port 		; DX _ Port number	IN	AL, DX	MOV	[BX].replyData, AL	;put value in bwBuffer	MOV	CL, 2 			;one byte of data in reply	JMP	PrepareReplyBuffer	DebReadIOWord:	MOV	BX, OFFSET BindweedBuffer	MOV	DX, [BX].port 		; DX _ Port number	IN	AX, DX	MOV	WORD PTR [BX].replyData, AX	;put value in bwBuffer	MOV	CL, 3 			;two bytes of data in reply	JMP	PrepareReplyBuffer;DebWriteIOByte:	MOV	BX, OFFSET BindweedBuffer	MOV	DX, [BX].port 		;DX _ Port number	MOV	AL, [BX].replyData	;get value from buffer	OUT	DX, AL	MOV	CL, 0			;no data in reply	JMP	PrepareReplyBuffer;DebWriteIOWord:	MOV	BX, OFFSET BindweedBuffer	MOV	DX, [BX].port ; DX _ Port number	MOV	AX, WORD PTR [BX].replyData ; get value from buffer	OUT	DX, AX	MOV	CL, 0			;no data in reply	JMP	PrepareReplyBufferDebDownNotify:	MOV	AX, WORD PTR BindweedBuffer.downNotifyMask	 	MOV	BX, SEG workNotifierCondition	MOV	DS, BX		;set DS to IORegion for doing OPIE calls	INT	BindweedDownNotifyInt	MOV	AX, 0	;set up DS to point to low RAM	MOV	DS, AX		JMP	PrepareReplyBufferReadCPCS:	INT 17	JMP	PrepareReplyBufferStartCP:	INT 18	JMP	PrepareReplyBufferStopCP:	INT 19	JMP	PrepareReplyBuffer	WriteCPCS:	INT 20		JMP	PrepareReplyBufferRemMemory:%IF(%RemoteMemory) THEN (	CALL	DebSetMemBlockDesc	MOV	BX, ES	;segment of logical address	MOV	DX, DI	;offset of logical address	MOV	AX, SEG RemoteMemoryAddress	MOV	ES, AX	MOV	DI, OFFSET RemoteMemoryAddress	MOV	ES:[DI + 2], BX	;RemoteMemoryAddress.highword ¬ Segment      		MOV	ES:[DI], DX	;RemoteMemoryAddress.lowWord ¬ Offset	SHR	CX, 2  ;divide bytecount by 4 to get length of remote memory block	MOV	DI, OFFSET wordCount	MOV	ES:[DI], CX	MOV	AX, SEG startOfMaskAndNewDataArray	MOV	AX, ES	MOV	DI, OFFSET startOfMaskAndNewDataArray	MOV	BX, OFFSET BindweedBuffer.data	SHL	CX, 1 ;get word count	RemMemoryLoop:		MOV	AX, [BX]	MOV	ES:[DI], AX	ADD	BX, 2	ADD	DI, 2	LOOP	RemMemoryLoop	MOV	AX, SEG RemoteMemoryDoneCond	MOV	DS, AX		;set DS to IORegion for doing OPIE calls		%NotifyCondition (OFFSET RemoteMemoryStartCond)	%WaitForCondition (OFFSET RemoteMemoryDoneCond,noTimeout)	MOV	AX, 0	;set up DS to point to low RAM	MOV	DS, AX		MOV	CL, 0)FI %' end of %IF(%RemoteMemory)	JMP	PrepareReplyBuffer	hbWords	EQU	120HBDataHiReg	EQU	3FECHHBDataLoReg	EQU	3FEEH		DebReadHB:	MOV	CX, hbWords/2	MOV	BX, OFFSET BindweedBuffer.replyData	DebReadHBLoop:	MOV	DX, HBDataHiReg	IN	AX, DX	MOV	[BX], AX	ADD	BX, 2	MOV	DX, HBDataLoReg	IN	AX, DX	MOV	[BX], AX	ADD	BX, 2	LOOP	DebReadHBLoop	MOV	CL, 2 * hbWords + 1	JMP	PrepareReplyBufferResetCP:	INT 21		JMP	PrepareReplyBufferStopPCE:	MOV	AX, SEG workNotifierCondition ; IORegion	MOV	DS, AX	CALL	StopPC	MOV	AX, 0	MOV	DS, AX	MOV	CL, 0			;no data in reply	JMP	PrepareReplyBuffer			;;;;;; Now send an EOI to the i8259A,; and (if it makes sense) an EOI to the internal interrupt controller;DebFinish: 	POP	AX 			;POP bindweed return address (NEAR)	POP	AX			;POP the OPIE DS	MOV	CL, 0	CALL	CreateReply	CALL	SendReply		;send null reply		 				;Send a specific EOI command to the 8259	MOV	AL, i8259MasDebuggerInEOI	;Write an EOI command for the 		OUT	i8259MasAddr0, AL		;debugger InterruptDebuggerIntrFinish:;	---------------------restore state--------------;	MOV	AX, SEG savedRegisters	MOV	DS, AX	MOV	AX, savedAX	MOV	BX, savedBX	MOV	CX, savedCX	MOV	DX, savedDX	MOV	BP, savedBP	MOV	SI, savedSI	MOV	DI, savedDI	MOV	ES, savedES	PUSH	savedFLAGS	PUSH	savedCS	PUSH	savedIP	PUSH	savedDS	POP	DS	IRET 	;--------------------------------------------;--------------------------------------------BWCommandList	DW	DebWriteMem, DebReadMem, SendAck, DebFinish, 			DebReadIOByte, DebWriteIOByte, DebReadIOWord, DebWriteIOWord, DebDownNotify, ReadCPCS, StartCP, StopCP, WriteCPCS, RemMemory, DebReadHB;***************************************************;Subroutine: Bindweed;	 ; BindWeed - processes command in Bindweed buffer and puts reply in same; ;   SELECT command FROM;     WriteBlock;     ReadBlock;     ReadIO;     WriteIO;     ClientDefinedCommand;     ;     at PrepareReplyBuffer, register CL contains the length of the reply data;      	BindWeed 	PROC	NEAR 	PUSH    DS	XOR	AX, AX	MOV	ES, AX	CALL	VerifyChecksum		MOV	AL, BindweedBuffer.command	CMP	AL, 15	JE	JmpResetCP	CMP	AL, 16	JE	JmpStopPCE	JA	DebUnsupportedCmd	XOR	AH, AH	MOV	SI, AX	SHL	SI, 1	MOV	DI, OFFSET BindweedBuffer	JMP	BWCommandList[SI]PrepareReplyBuffer:	CALL	CreateReplyDebUnsupportedCmd:		POP	DS		;restore DS and ES for calls from opie handler	MOV	AX, 0	MOV	ES, AX		RETJmpResetCP:	JMP	ResetCPJmpStopPCE:	JMP	StopPCE	BindWeed	ENDP			VerifyChecksum:	MOV	AX, SEG BindweedBuffer	MOV	DS, AX	MOV	BX, OFFSET BindweedBuffer	MOV	CL, [BX]	; get the count	ADD	CL, 2	XOR	CH, CH	MOV	AH, 0VCSLoop:	ADD	AH, [BX]	INC	BX	LOOP	VCSLoop	CMP	AH, 0	JE	VCSDone	JMP	FlushInputVCSDone:	RET	;;;;--------------------------------------------;---------------------------------------------------------------------DebuggerIntrHandler	LABEL	FAR	CALL 	SaveState;Now, disable interrupts til we finish processing the command;DisbleInts:	CLI		;No interrupts til we finish command processing	;****************************************************************************;NMI Umbilical Receive;; AL: input byte returned; CX: count; AH: checksum; BX: buffer index; DS: segment of Bindweed Buffer;bufferSeg _ SEG[BindWeedBuffer];;DO;  bufferOffset _ OFFSET[BindWeedBuffer];;  byte _ GetByte[];;  count _ byte;;  checksum _ byte;;  bufferSeg[bufferOffset] _ byte;;  bufferOffset _ bufferOffset + 1;;  byte _ GetByte[];;  IF count # byte THEN BadCount;;  checksum _ checksum + byte;;  bufferSeg[bufferOffset] _ byte;;  bufferOffset _ bufferOffset + 1;;  FOR CX: WORD IN [1..count] DO;    byte _ GetByte[];;    bufferSeg[bufferOffset] _ byte;;    bufferOffset _ bufferOffset + 1;;    checksum _ checksum + byte;;    ENDLOOP;;  IF checksum # 0 THEN BadChecksum;;  Bindweed[];;  SendReply[];;  ENDLOOP;;  ;  IF BadCount OR BadChecksum THEN receive bytes until timeout(~1ms) and send ;ERROR messageNMIKernel:	MOV	AX, SEG BindweedBuffer	MOV	DS, AX	MOV	BX, OFFSET BindweedBuffer		CALL 	DebGetInByte	MOV 	CL, AL 		; save first count 	MOV 	[BX], AL	INC 	BX	CALL 	DebGetInByte	CMP 	CL, AL		;are counts the same?	JNE 	FlushInput 	;if not, then flush input and send error msg	MOV 	[BX], AL	INC 	BX	MOV 	CH, 0  		; clear high byte of CXLoadBWBuffer:		CALL	DebGetInByte	MOV	[BX], AL 	;put input byte in buffer	INC	BX  		; update buffer index	LOOP	LoadBWBuffer      	CALL	Bindweed	CALL	SendReply	JMP	NMIKernel	;***************************************************;FlushInput:	MOV	DX, TimeOutConst	;set timeout counterWaitToReadByte:	IN	AL, i8255portC		;(portC is the status port!)	TEST	AL, i8255inReady		;Check for a byte ready	JNZ	ReadByte	DEC	DX			;decrement timeout counter	JNZ	WaitToReadByte	POP	AX	POP	AX	JMP	NMIKernel		;input has been flushedReadByte:	IN	AL, i8255portB		;read the byte	JMP	FlushInput		;***************************************************	;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++;		; Debugger subroutines;------------------------------Save State at absolute addresses-------------SaveState:			;to be called only in interrupt routines	PUSH	DS	PUSH	AX	MOV	AX, SEG savedRegisters	MOV	DS, AX	POP	AX	MOV	savedAX, AX	POP 	AX          ; AX _ DS on stack 	MOV	savedDS, AX   	MOV	savedBX, BX	MOV	savedCX, CX	MOV	savedDX, DX	MOV	savedBP, BP	MOV	savedSI, SI	MOV	savedDI, DI	MOV 	savedES, ES	POP	BX 	    ;POP return address of (NEAR) subroutine - 1 word	POP	AX		; POP IP saved during interrrupt call	MOV	savedIP, AX	POP	AX		;POP CS saved during interrupt call	MOV	savedCS, AX	POP	AX		; POP FLAGS saved during interrupt call	MOV	savedFLAGS, AX	MOV	savedSP, SP	MOV	savedSS, SS	PUSH	BX  	   ;PUSH 1 WORD return address of subroutine	RET;----------------------------------Done saving state-------------------------;;IOPLogicalAddress	EQU	0	DebSetMemBlockDesc:	MOV	BX, OFFSET BindweedBuffer	MOV	AL, [BX].addressType	CMP	AL, IOPLogicalAddress	JNE	ConvertOPIEAddress		MOV	AX, [BX].addressSegment	MOV	ES, AX	MOV	DI, [BX].addressOffset	JMP	SetMemBlockLength	ConvertOPIEAddress:		MOV	AX, SEG workNotifierCondition	MOV	DS, AX	; make DS point to IORegion for OPIE call	ASSUME	DS: IORegion		SetPCMapping:; reinitilize blockAddrA since IORegion is cleared by OPIE at initilization	MOV	blockAddrA.OpieAddressA15toA0, 0	MOV	blockAddrA.OpieAddressA23toA16, 0AH	MOV	blockAddrA.OpieAddressType, extendedBusOpieAddress  	     		%EstablishIOPAccess(daybreakMapRegisterNumberBase+0,WORD PTR blockAddrA)	%EstablishIOPAccess(daybreakMapRegisterNumberBase+1,WORD PTR blockAddrA)	%EstablishIOPAccess(daybreakMapRegisterNumberBase+2,WORD PTR blockAddrA)	%EstablishIOPAccess(daybreakMapRegisterNumberBase+3,WORD PTR blockAddrA)	%EstablishIOPAccess(daybreakMapRegisterNumberBase+4,WORD PTR blockAddrA)	%EstablishIOPAccess(daybreakMapRegisterNumberBase+5,WORD PTR blockAddrA)	%EstablishIOPAccess(daybreakMapRegisterNumberBase+6,WORD PTR blockAddrA)	%EstablishIOPAccess(daybreakMapRegisterNumberBase+7,WORD PTR blockAddrA)	%EstablishIOPAccess(generalMapRegister,WORD PTR blockAddrA)		ASSUME DS: IOPELocalRam		XOR	AX, AX	MOV	DS, AX	;restore DS to point to low RAM	MOV	CX, [BX].addressSegment	;Set the CX to the requested segment	MOV	DX, [BX].addressOffset	;And the DX to the starting offset	MOV	AX, SEG workNotifierCondition	MOV	DS, AX	; make DS point to IORegion for OPIE call		%EstablishIOPAccess(generalMapRegister,CX-DX)	XOR	AX, AX	MOV	DS, AX	;restore DS to point to low RAM			SetMemBlockLength:		MOV	CL, [BX].bwLength		;And CX to the count	XOR	CH, CH	RET;DebGetInByte:				;Byte returned in AL	IN	AL, i8255portC		;(portC is the status port!)	TEST	AL, i8255inReady		;Check for a byte ready	JZ	DebGetInByte		;wait until there is one ready					;	IN	AL, i8255portB		;get the byte and place it in memory	RET;;DebPutOutByte:	IN	AL, i8255portC		;(portC is the status port!)	TEST	AL, i8255outReady		;Check for "ok to put byte"	JZ	DebPutOutByte		;wait	MOV	AL, Dl			;Get the argument	OUT	i8255portA, AL		;	RET	IOPEInROM	ENDSEND
-- ContigSwap.mesa-- Create by FormSWLayoutTool on  9-Sep-85 16:51-- Last edit by DMP 	 7-May-86 12:49:56	added copyright notice-- Copyright (C) 1985, 1986 by Xerox Corporation.  All rights reserved.DIRECTORY  Environment,  File,  FileTypes,  FormSW,  Heap,  Put,  Space,  System,  Tool,  ToolWindow,  VM,  Volume,  Window;ContigSwap: PROGRAM  IMPORTS    Environment, File, FormSW, Heap, Put, Tool, Space, System, VM, Volume = {  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = MACHINE DEPENDENT RECORD [    msgSW(0): Window.Handle _ NIL,    formSW(2): Window.Handle _ NIL,    fileSW(4): Window.Handle _ NIL,    fileSize(6): UNSPECIFIED _ 0,    doWrites(7): BOOLEAN _ TRUE,    showFirstSwaps(8): BOOLEAN _ TRUE,    showAveTimes(9): BOOLEAN _ TRUE,    iterations(10): UNSPECIFIED _ 0,    doReads(11): BOOLEAN _ TRUE,    showLoopSwaps(12): BOOLEAN _ FALSE,    showEquivTimes(13): BOOLEAN _ TRUE];  FormItems: TYPE = {runMix, fileSize, doWrites, showFirstSwaps, showAveTimes, runPure, iterations, doReads, showLoopSwaps, showEquivTimes};  --  fileSize: CARDINAL = 500;--  iterations: CARDINAL = 10;  data: DataHandle _ NIL;  wh: Window.Handle _ NIL;  zone: UNCOUNTED ZONE _ Heap.systemZone;  bigFile: File.File ¬ File.nullFile;  fileType: File.Type = FileTypes.tUntypedFile;  firstPage: Environment.PageNumber ¬ 0;  interval: Space.Interval ¬ Space.nullInterval;  window: Space.Window;    readTime, writeTime, tempms: LONG CARDINAL ¬ 0;      RunMix: FormSW.ProcType = {--    SpecialSpace.MakeProcedureResident[proc: LOOPHOLE[DoRun]];    DoRun[1];--    SpecialSpace.MakeProcedureSwappable[proc: LOOPHOLE[DoRun]];  };    RunPure: FormSW.ProcType = {--    SpecialSpace.MakeProcedureResident[proc: LOOPHOLE[DoRun]];    DoRun[2];--    SpecialSpace.MakeProcedureSwappable[proc: LOOPHOLE[DoRun]];  };         DoRun: PROC [type: CARDINAL] = {    oldPulse, newPulse: LONG CARDINAL;    result: LONG CARDINAL ¬ 0;    bigFile ¬ File.Create[volume: Volume.systemID, initialSize: data.fileSize+1, type: [fileType]];  -- disk    interval ¬ Space.Allocate[count: data.fileSize+1];  -- VM    firstPage ¬ Environment.PageFromLongPointer[interval.pointer];    VM.ScratchMap[interval:[page: firstPage, count: interval.count]];    window ¬ [bigFile, 1, Environment.lastPageCount];        Put.Text[data.fileSW, "Runs with a fileSize of "L];    Put.Decimal[data.fileSW, data.fileSize];    Put.Text[data.fileSW, " and "L];    Put.Decimal[data.fileSW, data.iterations];    Put.Line[data.fileSW, " iterations."L];    IF data.doWrites THEN {      oldPulse ¬ System.GetClockPulses[];      result ¬ Space.CopyOut[interval.pointer, window];      newPulse ¬ System.GetClockPulses[];      IF result # data.fileSize THEN Put.LongDecimal[data.fileSW,result];      IF data.showFirstSwaps THEN {	Put.Text[data.fileSW, "first swap out took "L];	Put.LongDecimal[data.fileSW, System.PulsesToMicroseconds[[newPulse-oldPulse]]/1000];	Put.Line[data.fileSW, " milliseconds."L]}};    IF data.doReads THEN {      oldPulse ¬ System.GetClockPulses[];      result ¬ Space.CopyIn[interval.pointer, window];      newPulse ¬ System.GetClockPulses[];      IF result # data.fileSize THEN Put.LongDecimal[data.fileSW,result];      IF data.showFirstSwaps THEN {	Put.Text[data.fileSW, "first swap in took "L];	Put.LongDecimal[data.fileSW, System.PulsesToMicroseconds[[newPulse-oldPulse]]/1000];	Put.Line[data.fileSW, " milliseconds."L]}};    readTime ¬ writeTime ¬ 0;    SELECT type FROM      1 => {	FOR i: CARDINAL IN [0..data.iterations) DO	  IF data.doWrites THEN {	    oldPulse ¬ System.GetClockPulses[];	    result ¬ Space.CopyOut[interval.pointer, window];	    newPulse ¬ System.GetClockPulses[];	    writeTime ¬ writeTime + (newPulse - oldPulse);	    IF data.showLoopSwaps THEN {	      Put.Text[data.fileSW, "  "L];	      Put.LongDecimal[data.fileSW, newPulse - oldPulse]};	    IF result # data.fileSize THEN Put.Decimal[data.fileSW, i]};    	  IF data.doReads THEN {	    oldPulse ¬ System.GetClockPulses[];	    result ¬ Space.CopyIn[interval.pointer, window];	    newPulse ¬ System.GetClockPulses[];	    readTime ¬ readTime + (newPulse - oldPulse);	    IF data.showLoopSwaps THEN {	      Put.Text[data.fileSW, "  "L];	      Put.LongDecimal[data.fileSW, newPulse - oldPulse]};	    IF result # data.fileSize THEN Put.Decimal[data.fileSW, i]};	ENDLOOP};      2 => {	FOR i: CARDINAL IN [0..data.iterations) DO 	  IF data.doWrites THEN {	    oldPulse ¬ System.GetClockPulses[];	    result ¬ Space.CopyOut[interval.pointer, window];	    newPulse ¬ System.GetClockPulses[];	    writeTime ¬ writeTime + (newPulse - oldPulse);	    IF data.showLoopSwaps THEN {	      Put.Text[data.fileSW, "  "L];	      Put.LongDecimal[data.fileSW, newPulse - oldPulse]};	    IF result # data.fileSize THEN Put.Decimal[data.fileSW, i]};	ENDLOOP;		IF (data.doWrites AND data.showLoopSwaps) THEN Put.CR[data.fileSW];    	FOR i: CARDINAL IN [0..data.iterations) DO	  IF data.doReads THEN {	    oldPulse ¬ System.GetClockPulses[];	    result ¬ Space.CopyIn[interval.pointer, window];	    newPulse ¬ System.GetClockPulses[];	    readTime ¬ readTime + (newPulse - oldPulse);	    IF data.showLoopSwaps THEN {	      Put.Text[data.fileSW, "  "L];	      Put.LongDecimal[data.fileSW, newPulse - oldPulse]};	    IF result # data.fileSize THEN Put.Decimal[data.fileSW, i]};	ENDLOOP;		IF (data.doReads AND data.showLoopSwaps) THEN Put.CR[data.fileSW]};    ENDCASE;    tempms ¬ IF data.iterations = 0       THEN 0       ELSE System.PulsesToMicroseconds[[writeTime]]/1000/data.iterations;    IF (data.doWrites AND data.showAveTimes) THEN {      Put.Text[data.fileSW, "Average write time = "L];      Put.LongDecimal[data.fileSW, tempms];      Put.Line[data.fileSW, " milliseconds."L]};    IF (data.doWrites AND data.showEquivTimes) THEN {      Put.Text[data.fileSW, "write time for 512 pages = "L];      Put.LongDecimal[data.fileSW, tempms*512/data.fileSize];      Put.CR[data.fileSW]};    tempms ¬ IF data.iterations = 0       THEN 0       ELSE System.PulsesToMicroseconds[[readTime]]/1000/data.iterations;    IF (data.doReads AND data.showAveTimes) THEN {      Put.Text[data.fileSW, "Average read time = "L];      Put.LongDecimal[data.fileSW, tempms];      Put.Line[data.fileSW, " milliseconds."L]};    IF (data.doReads AND data.showEquivTimes) THEN {      Put.Text[data.fileSW, "read time for 512 pages = "L];      Put.LongDecimal[data.fileSW, tempms*512/data.fileSize];      Put.CR[data.fileSW]};    Put.CR[data.fileSW];        interval.pointer ¬ Space.Unmap[interval.pointer];    File.Delete[bigFile];    };  ClientTransition: ToolWindow.TransitionProcType = {    SELECT TRUE FROM      old = inactive =>        IF data = NIL THEN data _ zone.NEW[Data _ []];      new = inactive =>        IF data # NIL THEN {	  zone.FREE[@data]};      ENDCASE;    };  Init: PROCEDURE = {    wh _ Tool.Create[      makeSWsProc: MakeSWs, initialState: default,      clientTransition: ClientTransition, name: "ContigSwap"L,      cmSection: "ContigSwap"L];    };  MakeSWs: Tool.MakeSWsProc = {    logName: LONG STRING _ [17];    Tool.UnusedLogName[unused: logName, root: "ContigSwap.log"L];    data.msgSW _ Tool.MakeMsgSW[window: window];    data.formSW _ Tool.MakeFormSW[      window: window, formProc: MakeForm];    data.fileSW _ Tool.MakeFileSW[window: window, name: logName];    };  MakeForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = FormItems.LAST.ORD + 1;    items _ AllocateItemDescriptor[nItems];    items[FormItems.runMix.ORD] _ CommandItem[      tag: "RunMix"L, place: [8, line0], proc: RunMix];    items[FormItems.fileSize.ORD] _ NumberItem[      tag: "FileSize"L, place: [84, line0], signed: FALSE, value: @data.fileSize];    items[FormItems.doWrites.ORD] _ BooleanItem[      tag: "DoWrites"L, place: [210, line0], switch: @data.doWrites];    items[FormItems.showFirstSwaps.ORD] _ BooleanItem[      tag: "ShowFirstSwaps"L, place: [282, line0], switch: @data.showFirstSwaps];    items[FormItems.showAveTimes.ORD] _ BooleanItem[      tag: "ShowAveTimes"L, place: [396, line0], switch: @data.showAveTimes];    items[FormItems.runPure.ORD] _ CommandItem[      tag: "RunPure"L, place: [8, line1], proc: RunPure];    items[FormItems.iterations.ORD] _ NumberItem[      tag: "Iterations"L, place: [84, line1], signed: FALSE, value: @data.iterations];    items[FormItems.doReads.ORD] _ BooleanItem[      tag: "DoReads"L, place: [210, line1], switch: @data.doReads];    items[FormItems.showLoopSwaps.ORD] _ BooleanItem[      tag: "ShowLoopSwaps"L, place: [282, line1], switch: @data.showLoopSwaps];    items[FormItems.showEquivTimes.ORD] _ BooleanItem[      tag: "ShowEquivTimes"L, place: [396, line1], switch: @data.showEquivTimes];    RETURN[items: items, freeDesc: TRUE];    };  -- Mainline code  Init[];  -- this gets string out of global frame  }...    
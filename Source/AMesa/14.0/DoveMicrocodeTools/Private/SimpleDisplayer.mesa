-- Copyright (C) 1984, 1985  by Xerox Corporation. All rights reserved. -- SimpleDisplayer.mesa-- DEG     	 3-Feb-85 17:43:42-- DEG     	 3-Mar-84 16:17:40-- FXB     1-May-84 19:20:03DIRECTORY  Bindweed USING [Address, AddressType,  Sequence, Medium],  Context USING [Acquire, Find, Type, Release],  Format USING [StringProc],  FormSW USING [    EnumeratedFeedback, ItemType, nullIndex, ProcType, Radix, StringFeedback,    Type],  MSegment USING [Handle],  SpecialDisplay USING [Special],  Stream USING [Handle],  TIP USING [NotifyProc, Table],  Window USING [Box, Handle, nullBox, Place],  WindowFont USING [Handle];SimpleDisplayer: DEFINITIONS IMPORTS Context =  {  BorderType: TYPE = LONG POINTER TO SparseArrayBorderObject;  SparseArrayBorderObject: TYPE = RECORD [    next: BorderType ¬ NIL, row: RowType ¬ NIL, line: CARDINAL ¬ 0];  RowType: TYPE = LONG POINTER TO SparseArrayRowObject;  SparseArrayRowObject: TYPE = RECORD [    next: RowType ¬ NIL, item: SimpleDisplayer.ItemHandle ¬ NIL];  GlobalDataHandle: TYPE = LONG POINTER TO GlobalData;  GlobalData: TYPE = RECORD [    context: Context.Type,    tinyName1: LONG STRING ¬ NIL,    tinyName2: LONG STRING ¬ NIL,    rootName: LONG STRING ¬ NIL,    nameStripeName: LONG STRING ¬ NIL,    windows: WindowList ¬ NIL];  WindowList: TYPE = LONG POINTER TO WindowRecord;  WindowRecord: TYPE = RECORD [wh: Window.Handle ¬ NIL, link: WindowList ¬ NIL];  ItemHandle: TYPE = LONG POINTER TO ItemObject;  ItemObject: TYPE = MACHINE DEPENDENT RECORD [    next(0): ItemHandle ¬ NIL,    tag(2): LONG STRING ¬ NIL,    enumName(4): LONG STRING ¬ NIL,    box(6): Window.Box ¬ Window.nullBox,    readOnly(10): BOOLEAN ¬ FALSE,    invisible(11): BOOLEAN ¬ FALSE,    drawBox(12): BOOLEAN ¬ FALSE,    hasContext(13): BOOLEAN ¬ FALSE,    clientOwnsItem(14): BOOLEAN ¬ FALSE,    modified(15): BOOLEAN ¬ FALSE,    word(16): CARDINAL ¬ 0,    startingBitPostion(17): CARDINAL ¬ 0,    bitsOccupied(18): CARDINAL ¬ 0,    maxBitsOccupied(19): CARDINAL ¬ 16,    byteSwappedMachine(20): BOOLEAN ¬ TRUE,    bitOrderingLowToHigh(21): BOOLEAN ¬ TRUE,    body(22): SELECT type(22): FormSW.ItemType FROM      -- short fields are first so that they pack with the type tag      boolean => [        switch(23): LONG STRING ¬ NIL,        proc(25): LONG STRING ¬ NIL,        toyBoolean(27): BOOLEAN ¬ FALSE],      command => [proc(23): LONG STRING ¬ NIL],      enumerated => [        feedback(23): FormSW.EnumeratedFeedback ¬ one,        copyChoices(24): BOOLEAN ¬ TRUE,        value(25): LONG STRING ¬ NIL,        proc(27): LONG STRING ¬ NIL,        choices(29): LONG STRING ¬ NIL,        choiceName(31): LONG STRING ¬ NIL,        choiceList(33): ChoicePtr ¬ NIL,        toyEnumerated(35): UNSPECIFIED ¬ 0],      longNumber => [        signed(23): BOOLEAN ¬ TRUE,        notNegative(24): BOOLEAN ¬ FALSE,        radix(25): FormSW.Radix ¬ decimal,        boxWidth(26): CARDINAL [0..256) ¬ 64,        proc(27): LONG STRING ¬ NIL,        default(29): LONG UNSPECIFIED ¬ LAST[LONG INTEGER],        value(31): LONG STRING ¬ NIL,        string(33): LONG STRING ¬ NIL,        bias(35): INTEGER ¬ 0,        toyLongNumber(36): LONG UNSPECIFIED ¬ 0],      number => [        signed(23): BOOLEAN ¬ TRUE,        notNegative(24): BOOLEAN ¬ FALSE,        radix(25): FormSW.Radix ¬ decimal,        boxWidth(26): CARDINAL [0..256) ¬ 64,        proc(27): LONG STRING ¬ NIL,        default(29): UNSPECIFIED ¬ LAST[INTEGER],        value(30): LONG STRING ¬ NIL,        string(32): LONG STRING ¬ NIL,        bias(34): INTEGER ¬ 0,        toyNumber(35): UNSPECIFIED ¬ 0],      source => [        source(23): LONG STRING ¬ NIL,        boxWidth(25): CARDINAL ¬ 0,        filterProc(26): LONG STRING ¬ NIL,        menuProc(28): LONG STRING ¬ NIL],      string => [        feedback(23): FormSW.StringFeedback ¬ normal,        inHeap(24): BOOLEAN ¬ TRUE,        string(25): LONG STRING ¬ NIL,        boxWidth(27): CARDINAL ¬ 0,        filterProc(28): LONG STRING ¬ NIL,        menuProc(30): LONG STRING ¬ NIL,        toyString(32): LONG STRING ¬ NIL],      tagOnly => [other(23): CARDINAL ¬ FormSW.nullIndex],      ENDCASE];  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = MACHINE DEPENDENT RECORD [    msgSW(0): Window.Handle ¬ NIL,    formSW(2): Window.Handle ¬ NIL,    bitSW(4): Window.Handle ¬ NIL,    bufSW(6): Window.Handle ¬ NIL,    fileSW(8): Window.Handle ¬ NIL,    tag(10): LONG STRING ¬ NIL,    toolZone(12): LONG STRING ¬ NIL,    alignX(14): BOOLEAN ¬ TRUE,    alignY(15): BOOLEAN ¬ TRUE,    useBox(16): BOOLEAN ¬ FALSE,    root(17): LONG STRING ¬ NIL,    stream(19): Stream.Handle ¬ NIL,    segment(21): MSegment.Handle ¬ NIL,    bufStr(23): LONG STRING ¬ NIL,    buffer(25): LONG POINTER ¬ NIL,    small(27): LONG POINTER ¬ NIL,    smallBox(29): Window.Box ¬ Window.nullBox,    lastBox(33): Window.Box ¬ Window.nullBox,    modified(37): BOOLEAN ¬ TRUE,    wpl(38): CARDINAL ¬ 0,    bpl(39): CARDINAL ¬ 0,    charWidth(40): CARDINAL ¬ 0,    lineHeight(41): CARDINAL ¬ 0,    formtype(42): FormSW.ItemType ¬ FormSW.ItemType.FIRST,    anyFont(43): BOOLEAN ¬ FALSE,    selectedItem(44): ItemHandle ¬ NIL,    brushItem(46): ItemHandle ¬ NIL,    special(48): SpecialDisplay.Special ¬ NIL,    defaults(50): DefaultHandle ¬ NIL,    trash(52): ItemHandle ¬ NIL,    head(54): BorderType ¬ NIL,    defaultsToolWh(56): Window.Handle ¬ NIL,    burdockFormSW(58): Window.Handle ¬ NIL,    displayFormSW(60): Window.Handle ¬ NIL,    itemCount(62): CARDINAL ¬ 0,    recordSizeDecimal(63): CARDINAL ¬ 0,    address(64): LONG STRING ¬ NIL,    addressValue(66): Address ¬ 0,    addressType(68): Bindweed.AddressType ¬ iOPLogical,    processor(69): Processor ¬ IOP,    processorState(70): ProcessorState ¬ dead,    debugMedium(71): Bindweed.Medium ¬ umbilical,    dataSequence(72): LONG POINTER TO Bindweed.Sequence ¬ NIL,    writeToLog(74): BOOLEAN ¬ TRUE];  DataSequence: TYPE = Bindweed.Sequence;  << RECORD[length: NATURAL ¬ 0, seq: SEQUENCE maxlength: NATURAL OF Byte]; >>  DefaultHandle: TYPE = LONG POINTER TO DefaultRecord;  DefaultRecord: TYPE = MACHINE DEPENDENT RECORD [    msgSW(0): Window.Handle ¬ NIL,    formSW(2): Window.Handle ¬ NIL,    fileSW(4): Window.Handle ¬ NIL,    readOnly(6): BOOLEAN ¬ FALSE,    invisible(7): BOOLEAN ¬ FALSE,    drawBox(8): BOOLEAN ¬ FALSE,    hasContext(9): BOOLEAN ¬ FALSE,    feedbackEnum(10): FormSW.EnumeratedFeedback ¬ one,    radix(11): FormSW.Radix ¬ decimal,    notNegative(12): BOOLEAN ¬ FALSE,    signed(13): BOOLEAN ¬ FALSE,    boxWidthNumber(14): CARDINAL ¬ 64,    longDefault(15): LONG INTEGER ¬ LAST[LONG INTEGER],    shortDefault(17): INTEGER ¬ LAST[INTEGER],    inHeap(18): BOOLEAN ¬ TRUE,    feedbackString(19): FormSW.StringFeedback ¬ normal,    boxWidthString(20): CARDINAL ¬ 0,    startingword(21): INTEGER ¬ 0,    copyChoices(22): BOOLEAN ¬ TRUE,    formswType(23): FormSW.Type ¬ fixed,    boldTags(24): BOOLEAN ¬ TRUE,    autoScroll(25): BOOLEAN ¬ FALSE,    scrollVertical(26): BOOLEAN ¬ TRUE,    font(27): LONG STRING ¬ NIL,    fontHandle(29): WindowFont.Handle ¬ NIL,    enumType(31): LONG STRING ¬ NIL,    stuffString(33): LONG STRING ¬ NIL,    handleName(35): LONG STRING ¬ NIL,    procName(37): LONG STRING ¬ NIL];  ChoicePtr: TYPE = LONG POINTER TO ChoiceRec;  ChoiceRec: TYPE = RECORD [next: ChoicePtr ¬ NIL, a, b: LONG STRING ¬ NIL];  Error: TYPE = ERROR [reason: ErrorType];  ErrorType: TYPE = {processorBusy, unknown};  Address: TYPE = Bindweed.Address;  Processor: TYPE = {CP, IOP, PC}; --Bindweed.Processor  ProcessorState: TYPE = {dead, booted, halted, atBreakPoint, singleStep, running};--Bindweed.ProcessorState  ChoiceProcType: TYPE = PROC [    s1, s2: LONG STRING, even: BOOLEAN, Write: Format.StringProc, first: BOOLEAN];  EnumerateChoices: PROC [    item: LONG POINTER TO ItemObject.enumerated, proc: ChoiceProcType,    Write: Format.StringProc];  td: GlobalDataHandle;  zone: UNCOUNTED ZONE;  << Instance data monitoring. >>  Lock: PROCEDURE [wh: Window.Handle] RETURNS [dataHandle: DataHandle] = INLINE {    RETURN Context.Acquire[type: td.context, window: wh]};  Share: PROCEDURE [wh: Window.Handle] RETURNS [dataHandle: DataHandle] = INLINE {    RETURN Context.Find[type: td.context, window: wh]};  UnLock: PROCEDURE [wh: Window.Handle] = INLINE {    Context.Release[type: td.context, window: wh]};  GetTip: PROC RETURNS [TIP.Table];  Notify: TIP.NotifyProc;  AnotherInstance: FormSW.ProcType;  AllocateBitSWSpace: PROCEDURE [instance: DataHandle];  CreateItem: PROC [    tag: LONG STRING, box: Window.Box, type: FormSW.ItemType, instance: DataHandle]    RETURNS [item: ItemHandle];  DestroyInstance: FormSW.ProcType;  DestroyItem: PROC [    item: ItemHandle, instance: DataHandle, keepTrash: BOOLEAN ¬ TRUE];  DestroyAllItems: PROCEDURE [instance: DataHandle];  GetTrash: PROCEDURE [instance: DataHandle] RETURNS [item: ItemHandle];  OpenProps: PROC [item: ItemHandle, instance: DataHandle];  AddItem: PROC [item: ItemHandle, instance: DataHandle];  ItemMoved: PROC [item: ItemHandle, newPlace: Window.Place, instance: DataHandle];  ResolveToItem: PROC [coords: Window.Place, instance: DataHandle]    RETURNS [item: ItemHandle];  EnumerateItems: PROC [    proc: PROC [      item: ItemHandle, Write: Format.StringProc, instance: DataHandle ¬ NIL],    Write: Format.StringProc, instance: DataHandle ¬ NIL];  EnumerateInvalidItems: PROC [    item: ItemHandle, proc: PROC [item: ItemHandle, instance: DataHandle],    instance: DataHandle];  WriteOut: PROC [    proc: Format.StringProc, anyFont: BOOLEAN ¬ FALSE, instance: DataHandle];  Paint: PROC [item: ItemHandle, instance: DataHandle];  FinishBoolean: PROC [    item: LONG POINTER TO ItemObject.boolean, mesa: BOOLEAN ¬ TRUE,    write: Format.StringProc];  FinishCommand: PROC [    item: LONG POINTER TO ItemObject.command, write: Format.StringProc];  FinishEnumerated: PROC [    item: LONG POINTER TO ItemObject.enumerated, mesa: BOOLEAN ¬ TRUE,    write: Format.StringProc];  FinishLongNumber: PROC [    item: LONG POINTER TO ItemObject.longNumber, mesa: BOOLEAN ¬ TRUE,    write: Format.StringProc];  FinishNumber: PROC [    item: LONG POINTER TO ItemObject.number, mesa: BOOLEAN ¬ TRUE,    write: Format.StringProc];  FinishSource: PROC [    item: LONG POINTER TO ItemObject.source, write: Format.StringProc];  FinishString: PROC [    item: LONG POINTER TO ItemObject.string, mesa: BOOLEAN ¬ TRUE,    write: Format.StringProc];  FinishTagOnly: PROC [    item: LONG POINTER TO ItemObject.tagOnly, write: Format.StringProc];  ReclaimBitSWSpace: PROCEDURE [instance: DataHandle];  Save: PROC [proc: Format.StringProc, instance: DataHandle];  SwapState: TYPE = {create, use};  SwapSWs: PROCEDURE [    instance: DataHandle, window: Window.Handle, state: SwapState ¬ use];  Load: PROC [instance: DataHandle];  OK: PROC [item: ItemHandle, instance: DataHandle, update: BOOLEAN ¬ TRUE]    RETURNS [ok: BOOLEAN ¬ TRUE];  Plagiarize: PROC [sw: Window.Handle, myWindow: Window.Handle];  }..
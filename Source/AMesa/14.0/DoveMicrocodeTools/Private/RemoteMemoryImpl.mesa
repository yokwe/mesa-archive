-- File: RemoteMemoryImpl.mesa - last edit:-- FXB   .PA            4-Jun-85 15:20:36-- Copyright (C) 1985 by Xerox Corporation. All rights reserved.DIRECTORY  Bindweed,  Environment,  Heap,  Inline,  RemoteMemory;RemoteMemoryImpl: MONITOR IMPORTS Bindweed, Heap, Inline EXPORTS RemoteMemory =  {  RegisteredMemoryPointer: TYPE = LONG POINTER TO RegisteredMemoryNode;  RegisteredMemoryNode: TYPE = RECORD [    doveAddr: LONG CARDINAL _ 0,    link: RegisteredMemoryPointer _ NIL,    sequence: LONG POINTER TO WordSequence _ NIL];  WordSequence: TYPE = RECORD [    length: NATURAL ¬ 0, seq: PACKED SEQUENCE maxlength: NATURAL OF WORD];  working, prev, latest: RegisteredMemoryPointer _ NIL;    maskBuffer: LONG POINTER TO WordSequence ¬ NIL;    WriteRemoteFailed: PUBLIC ERROR = CODE;  UnRegisteredAddress: PUBLIC ERROR = CODE;    Cleanup: PROC = {      IF maskBuffer # NIL THEN Heap.systemZone.FREE[@maskBuffer];       maskBuffer ¬ NIL};  ReadDove: PUBLIC ENTRY PROCEDURE RETURNS [success: BOOLEAN _ TRUE] = {    ENABLE UNWIND => Cleanup[];    l: RegisteredMemoryPointer _ latest;    p: RegisteredMemoryPointer _ prev;    w: RegisteredMemoryPointer _ working;        maskBuffer ¬ Heap.systemZone.NEW[      WordSequence [Bindweed.maxData] _ [length: 0, seq: NULL]];    -- update latest    FOR l _ latest, l.link UNTIL l = NIL DO      Bindweed.ReadMemoryBlock[        address: l.doveAddr, addressType: iOPLogical,        sequence: LOOPHOLE[l.sequence] ! Bindweed.Error => GOTO exit];      ENDLOOP;    l _ latest;    UNTIL l = NIL DO      IF w = NIL OR p = NIL THEN ERROR;      IF ~MakeConsistent[l: l, w: w, p: p, maskBuffer: maskBuffer] THEN {        success ¬ FALSE; EXIT};      l _ l.link;      p _ p.link;      w _ w.link;      ENDLOOP;    Cleanup[];    EXITS      exit => {success ¬ FALSE; Cleanup[]};    };  WriteDove: PUBLIC ENTRY PROCEDURE RETURNS [success: BOOLEAN _ TRUE] = {    ENABLE UNWIND => Cleanup[];    l: RegisteredMemoryPointer _ latest;    p: RegisteredMemoryPointer _ prev;    w: RegisteredMemoryPointer _ working;        maskBuffer ¬ Heap.systemZone.NEW[      WordSequence [Bindweed.maxData] _ [length: 0, seq: NULL]];    l _ latest;    UNTIL l = NIL DO      IF w = NIL OR p = NIL THEN ERROR;      IF ~MakeConsistent[l: l, w: w, p: p, maskBuffer: maskBuffer] THEN {        success ¬ FALSE; EXIT};      l _ l.link;      p _ p.link;      w _ w.link;      ENDLOOP;    Cleanup[];    };  MakeConsistent: INTERNAL PROCEDURE [    l, w, p: RegisteredMemoryPointer, maskBuffer: LONG POINTER TO WordSequence]    RETURNS [success: BOOLEAN ¬ TRUE] = {    i: NATURAL ¬ 0;    fillingBuffer: BOOLEAN ¬ FALSE;    maskEntryLength: CARDINAL = 4;  -- 4 bytes = 2 words    -- latest _ latest with updates from prev to current working    -- also update latest on Dove    FOR i IN [0..w.sequence.length / 2) DO      changedBits: WORD ¬ 0;      IF fillingBuffer OR w.sequence[i] # p.sequence[i] THEN {        fillingBuffer ¬ TRUE;        -- get mask        changedBits _ Inline.BITXOR[w.sequence[i], p.sequence[i]];        l.sequence[i] _ Inline.BITAND[l.sequence[i], Inline.BITNOT[changedBits]];        -- set changed bits        l.sequence[i] _ Inline.BITOR[          l.sequence[i], Inline.BITAND[w.sequence[i], changedBits]];        maskBuffer[maskBuffer.length / 2] ¬ l.sequence[i];        maskBuffer[maskBuffer.length / 2 + 1] ¬ changedBits;        maskBuffer.length ¬ maskBuffer.length + maskEntryLength;        IF maskBuffer.length > maskBuffer.maxlength - maskEntryLength THEN {          Bindweed.WriteMemoryBits[            address: l.doveAddr + (i + 1) * 2 - maskBuffer.length / 2,            addressType: iOPLogical, sequence: LOOPHOLE[maskBuffer] !            Bindweed.Error => ERROR WriteRemoteFailed];          maskBuffer.length ¬ 0;          fillingBuffer ¬ FALSE}};      ENDLOOP;    IF maskBuffer.length > 0 THEN {      Bindweed.WriteMemoryBits[        address: l.doveAddr + (i + 1) * 2 - maskBuffer.length / 2,        addressType: iOPLogical, sequence: LOOPHOLE[maskBuffer] !        Bindweed.Error => ERROR WriteRemoteFailed];      maskBuffer.length ¬ 0;      fillingBuffer ¬ FALSE};    -- working _ previous _ lastest    CopySequence[from: l.sequence, to: p.sequence];    CopySequence[from: l.sequence, to: w.sequence];    };  GetRegisteredMemoryNode: INTERNAL PROCEDURE [workingAddr: LONG POINTER]    RETURNS [l, p, w: RegisteredMemoryPointer] = {    l ¬ latest;    p ¬ prev;    w ¬ working;    -- find Registered Memory Node corresponding to workingAddr    UNTIL l = NIL DO      IF w = NIL OR p = NIL THEN ERROR;      IF workingAddr = w.sequence + SIZE[WordSequence] THEN EXIT;      l _ l.link;      p _ p.link;      w _ w.link;      REPEAT FINISHED => ERROR UnRegisteredAddress;          -- working address not registered      ENDLOOP;    };  ReadRemote: PUBLIC ENTRY PROCEDURE [workingAddr: LONG POINTER]    RETURNS [success: BOOLEAN _ TRUE] = {    ENABLE UNWIND => Cleanup[];    l, p, w: RegisteredMemoryPointer ¬ NIL;        maskBuffer ¬ Heap.systemZone.NEW[      WordSequence [Bindweed.maxData] _ [length: 0, seq: NULL]];        [l: l, p: p, w: w] ¬ GetRegisteredMemoryNode[workingAddr];    Bindweed.ReadMemoryBlock[      address: l.doveAddr, addressType: iOPLogical, sequence: LOOPHOLE[l.sequence]      ! Bindweed.Error => GOTO exit];    IF ~MakeConsistent[l: l, w: w, p: p, maskBuffer: maskBuffer]       THEN success _ FALSE;    Cleanup[];    EXITS      exit => {success ¬ FALSE; Cleanup[]};    };  WriteRemote: PUBLIC ENTRY PROCEDURE [workingAddr: LONG POINTER]    RETURNS [success: BOOLEAN _ TRUE] = {    ENABLE UNWIND => Cleanup[];    l, p, w: RegisteredMemoryPointer ¬ NIL;        maskBuffer: LONG POINTER TO WordSequence ¬ Heap.systemZone.NEW[      WordSequence [Bindweed.maxData] _ [length: 0, seq: NULL]];    [l: l, p: p, w: w] ¬ GetRegisteredMemoryNode[workingAddr];    IF ~MakeConsistent[l: l, w: w, p: p, maskBuffer: maskBuffer] THEN      success ¬ FALSE;    Cleanup[];    };  UnRegisterMemory: PUBLIC ENTRY PROCEDURE [z: UNCOUNTED ZONE] = {    ENABLE UNWIND => NULL;    FreeNodeList: PROCEDURE [l: RegisteredMemoryPointer]      RETURNS [RegisteredMemoryPointer] = {      nodePtr: RegisteredMemoryPointer ¬ NIL;      UNTIL l = NIL DO        z.FREE[@l.sequence]; nodePtr ¬ l; l ¬ l.link; z.FREE[@nodePtr]; ENDLOOP;      RETURN[NIL];      };    latest ¬ FreeNodeList[latest];    prev ¬ FreeNodeList[prev];    working ¬ FreeNodeList[working];    };  RegisterMemory: PUBLIC ENTRY PROCEDURE [    doveAddr: LONG CARDINAL, words: CARDINAL, z: UNCOUNTED ZONE]    RETURNS [workingAddr: LONG POINTER, success: BOOLEAN _ TRUE] = {    ENABLE UNWIND => NULL;    p: RegisteredMemoryPointer _ NIL;    bytes: NATURAL _ words * 2;    p _ z.NEW[RegisteredMemoryNode _ []];    p.sequence _ LOOPHOLE[z.NEW[      Bindweed .Sequence[bytes] _ [length: bytes, seq: NULL]]];    p.doveAddr _ doveAddr;    p.link _ working;    working _ p;    p _ z.NEW[RegisteredMemoryNode _ []];    p.sequence _ LOOPHOLE[z.NEW[      Bindweed .Sequence[bytes] _ [length: bytes, seq: NULL]]];    p.doveAddr _ doveAddr;    p.link _ prev;    prev _ p;    p _ z.NEW[RegisteredMemoryNode _ []];    p.sequence _ LOOPHOLE[z.NEW[      Bindweed .Sequence[bytes] _ [length: bytes, seq: NULL]]];    p.doveAddr _ doveAddr;    p.link _ latest;    latest _ p;    Bindweed.ReadMemoryBlock[      address: doveAddr, addressType: iOPLogical,      sequence: LOOPHOLE[working.sequence] ! Bindweed.Error => GOTO exit];    CopySequence[from: working.sequence, to: prev.sequence];    CopySequence[from: working.sequence, to: latest.sequence];    workingAddr _ working.sequence + SIZE[WordSequence]    EXITS exit => success _ FALSE;    };  CopySequence: PROCEDURE [from, to: LONG POINTER TO WordSequence] = {    IF to = NIL OR from = NIL THEN ERROR;    IF to.maxlength # from.maxlength THEN ERROR;    FOR i: CARDINAL IN [0..from.length / 2) DO to[i] _ from[i]; ENDLOOP;    to.length _ from.length;    };  }.            
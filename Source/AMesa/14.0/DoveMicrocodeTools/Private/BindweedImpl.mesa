-- File: BindweedImpl.mesa - last edit:-- JAC           14-Oct-85 10:29:56-- Copyright (C) 1984, 1985  by Xerox Corporation. All rights reserved. ---- BindweedImpl.mesa-- FHB   , 22-Aug-84 15:05:17-- FHB   , 18-Sep-84 14:20:21 improved reliability of up notify -- FHB   , 16-Oct-84 13:06:28-- FHB   , 19-Oct-84 13:59:05:	Byte Swapping for CP functions-- FHB   , 24-Oct-84  9:40:08:	put CSWords in WriteCPCS-- FHB   , 24-Oct-84 17:44:21	fix allocateNotifyBit mask-- FHB   , 24-Oct-84 18:27:23	fix WriteCPControlStore-- FHB   ,  7-Nov-84 13:54:09	fixed uncontrolled "80186 is dead"-- FHB   ,  8-Nov-84 12:59:35	fixed confusion between up notifies and replies to commands-- FHB   ,  4-Dec-84 14:47:35	added WriteMemoryBits-- FHB   , 13-Dec-84 10:21:57-- FHB   , 26-Dec-84 14:47:49  	added TurnOnWatcher, TurnOffWatcher-- FHB   ,  3-Jan-85 14:59:16-- FHB   ,  4-Jan-85 15:09:17 	added ErrorDuringWriteBits-- FHB   ,  7-Jan-85 12:45:55	changed *Sirius* to *CP *-- FHB   , 25-Jan-85 11:11:46	fixed WriteCPControlStore-- FHB   ,  1-Feb-85 15:34:27   test version with Bindweed.Timeout commented out in one place-- FHB   ,  3-Feb-85 13:56:37   changed InsertOPIEAddress-- FHB   ,  7-Feb-85 16:36:30   added ReadHistoryBuffer-- FHB   , 15-Feb-85  9:57:42	added splitting of buffers at mapRegister boundary-- FHB   , 22-Feb-85  9:33:40	implemented ResetCP-- FHB   , 15-Mar-85  9:30:56  	added ENABLE UNWIND to ReadHistoryBuffer-- FHB   , 18-Mar-85 11:25:09-- RRP   , 27-Aug-85  9:55:32   SHAREd DoveInputOutput as well as IMPORTing it-- JAC   , 14-Oct-85 10:30:37   update to reconfigurable opie-- FHB	 , 12-Aug-86 10:50:45	added retries on timeout and badchecksum-- FHB	 ,  2-Sep-86  9:07:07	changed retryCount to  10DIRECTORY  Bindweed,  DoveInputOutput,  Environment,  Heap,  I186,  Inline,  Process,  Umbilical;BindweedImpl: MONITOR  IMPORTS DoveInputOutput, Heap, Inline, Process, Umbilical EXPORTS Bindweed SHARES DoveInputOutput =  {  Error: PUBLIC ERROR [code: Bindweed.ErrorCode] = CODE;  NotifyProcNode: TYPE = RECORD [    next: NotifyProcNodePtr ¬ NIL,    proc: Bindweed.NotifyProc ¬ NIL,    clientData: LONG POINTER ¬ NIL];  NotifyProcNodePtr: TYPE = LONG POINTER TO NotifyProcNode;    ErrorDuringWriteBits: BOOLEAN ¬ FALSE; -- squirrelly  Command: TYPE = MACHINE DEPENDENT{    WriteMemory(0), ReadMemory(1), Halt(2), Continue(3), ReadIOByte(4),    WriteIOByte(5), ReadIOWord(6), WriteIOWord(7), DownNotify(8),    ReadCPControlStore(9), StartCP(10), Noop(11), StopCP(12),    WriteCPControlStore(13), WriteMemoryBits(14), ReadHistoryBuffer(15),    ResetCP(16), StopPC(17)};  minReplyLength: CARDINAL = 5;  minReplyCount: CARDINAL = minReplyLength - 2;  maxReplyCount: CARDINAL = 253;  memoryCommandLength: CARDINAL = 10;  ioCommandLength: CARDINAL = 6;  mapRegisterRange: LONG CARDINAL = 131072;   -- 128K: range of addresses accessed by a single dove memory map register  notifyVector: ARRAY [0..16) OF NotifyProcNodePtr ¬ ALL[NIL];  medium: Bindweed.Medium ¬ umbilical;  runWatcher: BOOLEAN ¬ FALSE;  allocatedBitArray: PACKED ARRAY [0..16) OF BOOLEAN ¬ ALL[FALSE];  AddNotify: PUBLIC ENTRY PROCEDURE [    notify: Bindweed.NotifyProc, index: [0..16), clientData: LONG POINTER ¬ NIL] =    {    ENABLE UNWIND => NULL;    entry: NotifyProcNodePtr ¬ Heap.systemZone.NEW[      NotifyProcNode ¬ [      next: notifyVector[index], proc: notify, clientData: clientData]];    notifyVector[index] ¬ entry};  RemoveNotify: PUBLIC ENTRY PROCEDURE [    index: [0..16), notify: Bindweed.NotifyProc] = {    ENABLE UNWIND => NULL;    nodePtr: LONG POINTER TO NotifyProcNodePtr ¬ NIL;    FOR nodePtr ¬ @notifyVector[index], @notifyVector[index].next UNTIL nodePtr­ =      NIL DO      IF nodePtr.proc = notify THEN {        next: NotifyProcNodePtr ¬ nodePtr.next;        Heap.systemZone.FREE[nodePtr];        nodePtr­ ¬ next;        EXIT};      ENDLOOP;    -- should also release notify bit     };  Allocate: PUBLIC ENTRY PROCEDURE [count: CARDINAL]    RETURNS [offset: CARDINAL ¬ 0] = {ENABLE UNWIND => NULL; };  --offset is relative to the base of the local RAM on the 80186  AllocateNotifyBit: PUBLIC ENTRY PROCEDURE    RETURNS [mask: WORD, bitIndex: [0..16)] = {    ENABLE UNWIND => NULL;    FOR i: CARDINAL IN [0..16) DO      IF ~allocatedBitArray[i] THEN {        allocatedBitArray[i] ¬ TRUE;        RETURN[Inline.BITSHIFT[value: 1, count: 15 - i], i]};      ENDLOOP;    ERROR;  --all notify bits allocated    };  Boot: PUBLIC ENTRY PROCEDURE = {    ENABLE UNWIND => NULL;    ErrorDuringWriteBits ¬ FALSE;    Umbilical.Boot[      ! Umbilical.UmbilicalNotWorking => ERROR Error[umbilicalNotWorking];      Umbilical.Timeout => ERROR Error[timeout]]};  ChangeMedium: PUBLIC ENTRY PROCEDURE [newMedium: Bindweed.Medium] = {    ENABLE UNWIND => NULL;    medium ¬ newMedium};  Continue: PUBLIC ENTRY PROCEDURE = {    ENABLE UNWIND => NULL;    commandBlock: PACKED ARRAY [0..6) OF Environment.Byte;    count: CARDINAL ¬ 2;    ErrorDuringWriteBits ¬ FALSE;    commandBlock[0] ¬ commandBlock[1] ¬ count;    commandBlock[2] ¬ ORD[Command.Continue];    InsertChecksum[@commandBlock];    Converse[@commandBlock, @commandBlock, 4, minReplyLength];    };  Converse: INTERNAL PROCEDURE [    command, reply: LONG POINTER TO Bindweed.Block,    commandLength, replyLength: Environment.Byte, stop: BOOLEAN ¬ FALSE] = {    status: WORD;    tempReplyBlock: Bindweed.Block;    tempReply: LONG POINTER TO Bindweed.Block ¬ @tempReplyBlock;    retryCount: CARDINAL ¬ 10;    SELECT medium FROM      umbilical, umbilicalNMI => {        DO	  ENABLE Umbilical.Timeout => IF (retryCount¬retryCount-1) = 0 THEN	    ERROR Error[timeout] ELSE LOOP;	  Umbilical.WriteBlock[LOOPHOLE[command], commandLength];	  Umbilical.ReadBlock[LOOPHOLE[reply], minReplyLength];	  IF reply[0] < minReplyCount OR reply[0] > maxReplyCount THEN	    IF (retryCount¬retryCount-1) = 0 THEN	      ERROR Error[badCheckSum] ELSE LOOP;	  IF reply[0] > minReplyCount THEN {	    -- this is a response to a command	    Umbilical.ReadBlock[	      LOOPHOLE[tempReply], reply[0] - minReplyLength + 2];	    FOR i: CARDINAL IN [0..(reply[0] - minReplyLength + 2)) DO	      reply[i + minReplyLength] ¬ tempReply[i]; ENDLOOP;	    }	  ELSE IF replyLength > minReplyLength THEN {	    -- an asynchronous notify was received	    IF (status ¬ (reply[3] * 256) + reply[2]) # 0 AND status # 0FFFFH THEN	      NakedNotify[LOOPHOLE[status]];	    	    Umbilical.ReadBlock[LOOPHOLE[reply], replyLength];	    };	  IF NOT ValidChecksum[reply, replyLength] THEN	    IF (retryCount¬retryCount-1) = 0 THEN	      ERROR Error[badCheckSum] ELSE LOOP;	  EXIT; -- successfull if here	  ENDLOOP;        };      ENDCASE;    -- ValidateChecksum[reply];    IF (status ¬ (reply[3] * 256) + reply[2]) # 0 AND status # 0FFFFH THEN {      NakedNotify[LOOPHOLE[status]];      IF NOT stop THEN {ErrorDuringWriteBits ¬ TRUE; <<ERROR Bindweed.Timeout>>}}; -- if a naked notify occurs here, then there was most likely an error encountered in executing a command so we notify the debugger and halt the client by raising a timeout.     };  NakedNotify: PROCEDURE [nakedNotifyWord: PACKED ARRAY [0..16) OF BOOLEAN] = {    clientNotify: Bindweed.NotifyProc ¬ NIL;    nodePtr: NotifyProcNodePtr ¬ NIL;    FOR i: CARDINAL IN [0..16) DO      IF nakedNotifyWord[i] THEN {        FOR nodePtr ¬ notifyVector[i], nodePtr.next UNTIL nodePtr = NIL DO          clientNotify ¬ nodePtr.proc;          Process.Detach[FORK clientNotify[nodePtr.clientData]];          ENDLOOP;        };      ENDLOOP;    };  ValidChecksum: PROCEDURE [    block: LONG POINTER TO Bindweed.Block, replyLength: CARDINAL]    RETURNS [yes: BOOLEAN ¬ TRUE] = {    checksum: CARDINAL ¬ 0;    count: CARDINAL ¬ block[0];    IF count # replyLength - 2 THEN RETURN[FALSE];    IF (count < minReplyCount) OR (count > maxReplyCount) THEN      RETURN[FALSE];    FOR i: CARDINAL IN [0..count + 2) DO checksum ¬ checksum + block[i]; ENDLOOP;    IF checksum MOD 256 # 0 THEN RETURN[FALSE];    };  Free: PUBLIC ENTRY PROCEDURE [offset, count: CARDINAL] = {    ENABLE UNWIND => NULL; };  Get: PUBLIC ENTRY PROCEDURE [block: Bindweed.Block, length: Bindweed.Byte] = {    ENABLE UNWIND => NULL; };  InsertChecksum: PROCEDURE [block: LONG POINTER TO Bindweed.Block] = {    ENABLE UNWIND => NULL;    checksum, count: WORD;    count ¬ block[0];    checksum ¬ count * 2;    FOR i: CARDINAL IN [2..count] DO checksum ¬ checksum + block[i]; ENDLOOP;    block[count + 1] ¬ (0 - checksum) MOD 256;    };  Jump: PUBLIC ENTRY PROCEDURE [    address: Bindweed.Address, addressType: Bindweed.AddressType] = {    ENABLE UNWIND => NULL; };  PollForAsynchronousNotify: ENTRY PROCEDURE RETURNS [status: WORD ¬ 0] = {    ENABLE UNWIND => NULL;    -- we have not decided if this can be used with media other than umbilical    IF Umbilical.ReadReady[] THEN {      replyBlock: Bindweed.Block;      Umbilical.ReadBlock[        LOOPHOLE[LONG[@replyBlock]], minReplyLength !        Umbilical.Timeout => <<GOTO doBroadcast>> GOTO exit];      status ¬ (replyBlock[3] * 256) + replyBlock[2];      IF replyBlock[0] = 0 OR replyBlock[0] = 0FFH THEN RETURN[0];      IF ~ValidCheckSum[@replyBlock] THEN <<GO TO doBroadcast>> RETURN[0];      };    EXITS exit => NULL;    --doBroadcast => RETURN[LAST[CARDINAL]];    };  ValidCheckSum: PROCEDURE [block: LONG POINTER TO Bindweed.Block]    RETURNS [BOOLEAN] = {    checksum: CARDINAL ¬ 0;    count: CARDINAL ¬ block[0];    IF count > 253 THEN RETURN[FALSE];    FOR i: CARDINAL IN [0..count + 2) DO checksum ¬ checksum + block[i]; ENDLOOP;    RETURN[checksum MOD 256 = 0];    };  DownNotify: PUBLIC ENTRY PROCEDURE [mask: WORD] = {    ENABLE UNWIND => NULL;    replyBlock, commandBlock: Bindweed.Block;    commandBlock[0] ¬ commandBlock[1] ¬ 4;    commandBlock[2] ¬ ORD[Command.DownNotify];    commandBlock[3] ¬ mask MOD 256;    commandBlock[4] ¬ mask / 256;    InsertChecksum[@commandBlock];    Converse[@commandBlock, @replyBlock, 6, minReplyLength];    };  ReadCPControlStore: PUBLIC ENTRY PROCEDURE [    csAddress: [0..Bindweed.sizeOfCS)]    RETURNS [mi: PACKED ARRAY [0..Bindweed.bytesPerMi) OF Environment.Byte] = {    ENABLE UNWIND => NULL;    replyBlock, commandBlock: Bindweed.Block;    commandBlock[0] ¬ commandBlock[1] ¬ 4;    commandBlock[2] ¬ ORD[Command.ReadCPControlStore];    commandBlock[3] ¬ csAddress MOD 256;    commandBlock[4] ¬ csAddress / 256;    InsertChecksum[@commandBlock];    Converse[      @commandBlock, @replyBlock, 6, Bindweed.bytesPerMi + minReplyLength + 1];    FOR i: NATURAL IN [0..Bindweed.bytesPerMi) DO      mi[i] ¬ replyBlock[5 + i]; ENDLOOP;    SwapBytes[LOOPHOLE[LONG[@mi]], Bindweed.bytesPerMi];    };  StartCP: PUBLIC ENTRY PROCEDURE [    shiftRegister: PACKED ARRAY [0..Bindweed.bytesPerMi) OF Bindweed.Byte] = {    ENABLE UNWIND => NULL;    replyBlock, commandBlock: Bindweed.Block;    SwapBytes[LOOPHOLE[LONG[@shiftRegister]], Bindweed.bytesPerMi];    commandBlock[0] ¬ commandBlock[1] ¬ 2 + Bindweed.bytesPerMi;    commandBlock[2] ¬ ORD[Command.StartCP];    FOR i: NATURAL IN [0..Bindweed.bytesPerMi) DO      commandBlock[3 + i] ¬ shiftRegister[i]; ENDLOOP;    InsertChecksum[@commandBlock];    Converse[@commandBlock, @replyBlock, 4 + Bindweed.bytesPerMi, minReplyLength];    };  StopCP: PUBLIC ENTRY PROCEDURE    RETURNS [      shiftRegister: PACKED ARRAY [0..Bindweed.bytesPerMi) OF Bindweed.Byte] = {    ENABLE UNWIND => NULL;    replyBlock, commandBlock: Bindweed.Block;    commandBlock[0] ¬ commandBlock[1] ¬ 2;    commandBlock[2] ¬ ORD[Command.StopCP];    InsertChecksum[@commandBlock];    Converse[      @commandBlock, @replyBlock, 4, Bindweed.bytesPerMi + minReplyLength + 1];    FOR i: NATURAL IN [0..Bindweed.bytesPerMi) DO      shiftRegister[i] ¬ replyBlock[5 + i]; ENDLOOP;    SwapBytes[LOOPHOLE[LONG[@shiftRegister]], Bindweed.bytesPerMi];    };    InsertIOPLogicalAddress: PROCEDURE[    blockRef: LONG POINTER TO Bindweed.Block, address: Bindweed.Address] = {    blockRef[3] ¬ Inline.LowHalf[address / 16 MOD 256];    blockRef[4] ¬ Inline.LowHalf[address / 16 / 256];    blockRef[5] ¬ Inline.LowHalf[address MOD 16];    blockRef[6] ¬ 0    };      InsertOPIEAddress: PROCEDURE[    blockRef: LONG POINTER TO Bindweed.Block, address: Bindweed.Address] = {    byteArray: PACKED ARRAY [0..4) OF Bindweed.Byte ¬ LOOPHOLE[address];    blockRef[3] ¬ byteArray[2];    blockRef[4] ¬ byteArray[3];    blockRef[5] ¬ byteArray[0];    blockRef[6] ¬ byteArray[1];    };  ReadMemoryBlock: PUBLIC ENTRY PROCEDURE [    address: Bindweed.Address, addressType: Bindweed.AddressType,    sequence: LONG POINTER TO Bindweed.Sequence] = {    ENABLE UNWIND => NULL;    start, length: NATURAL ¬ 0;    replyBlock, commandBlock: Bindweed.Block;    count: [1..253];    WHILE start < sequence.length DO      length ¬ MIN[Bindweed.maxData, sequence.length - start];      count ¬ 8;      commandBlock[0] ¬ commandBlock[1] ¬ count;      commandBlock[2] ¬ ORD[Command.ReadMemory];      IF addressType = iOPLogical THEN         InsertIOPLogicalAddress[@commandBlock, address]      ELSE InsertOPIEAddress[@commandBlock, address];      commandBlock[7] ¬ ORD[addressType];      commandBlock[8] ¬ length;      InsertChecksum[@commandBlock];      Converse[        @commandBlock, @replyBlock, memoryCommandLength,        length + minReplyLength + 1];      FOR i: NATURAL IN [start..start + length) DO        sequence[i] ¬ replyBlock[5 + i - start]; ENDLOOP;      start ¬ start + length;      address ¬ address + length;      ENDLOOP;    };      ReadHistoryBuffer: PUBLIC ENTRY PROCEDURE [    hbData: LONG POINTER TO ARRAY [0..Bindweed.hbWords) OF WORD] = {    ENABLE UNWIND => NULL;    replyBlock, commandBlock: Bindweed.Block;    count: [1..253];    commandBlock[0] ¬ commandBlock[1] ¬ count ¬ 4;    commandBlock[2] ¬ ORD[Command.ReadHistoryBuffer];    commandBlock[3] ¬ 0;    commandBlock[4] ¬ 0;    InsertChecksum[@commandBlock];    Converse[@commandBlock, @replyBlock, ioCommandLength, ioCommandLength + Bindweed.hbWords*2];    FOR i: CARDINAL IN [0..Bindweed.hbWords) DO      hbData[i] ¬ replyBlock[5+i*2] + replyBlock[6+i*2] * 256;      ENDLOOP;            };  ReadIOByte: PUBLIC ENTRY PROCEDURE [port: I186.IOPort]    RETURNS [data: Bindweed.Byte] = {    ENABLE UNWIND => NULL;    replyBlock, commandBlock: Bindweed.Block;    count: [1..253];    commandBlock[0] ¬ commandBlock[1] ¬ count ¬ 4;    commandBlock[2] ¬ ORD[Command.ReadIOByte];    commandBlock[3] ¬ Inline.LowHalf[port MOD 256];    commandBlock[4] ¬ Inline.LowHalf[port / 256];    InsertChecksum[@commandBlock];    Converse[@commandBlock, @replyBlock, ioCommandLength, ioCommandLength + 1];    data ¬ replyBlock[5];    };  ReadIOWord: PUBLIC ENTRY PROCEDURE [port: I186.IOPort] RETURNS [data: WORD] = {    ENABLE UNWIND => NULL;    replyBlock, commandBlock: Bindweed.Block;    count: [1..253];    commandBlock[0] ¬ commandBlock[1] ¬ count ¬ 4;    commandBlock[2] ¬ ORD[Command.ReadIOWord];    commandBlock[3] ¬ Inline.LowHalf[port MOD 256];    commandBlock[4] ¬ Inline.LowHalf[port / 256];    InsertChecksum[@commandBlock];    Converse[@commandBlock, @replyBlock, ioCommandLength, ioCommandLength + 2];    data ¬ replyBlock[5] + replyBlock[6] * 256;    };      MapRegister: PROC [address: I186.Address] RETURNS [register: CARDINAL] = {    --RETURN the map register for an OPIE Address    mapRegMask: CARDINAL = 0EH;    opieAddr: DoveInputOutput.OpieAddress ¬ VAL[address];    RETURN[Inline.BITAND[opieAddr.A23toA16, mapRegMask]/2]};      LogicalAddr: PROC [OA: Bindweed.Address]    RETURNS [logAddr: LONG CARDINAL] = {    OPEN DIO: DoveInputOutput;    opieAddr: DIO.OpieAddress ¬ VAL[OA];    opieAddr.A15toA0 ¬ DIO.OldByteSwap[opieAddr.A15toA0];    opieAddr.type ¬ nil;    RETURN[VAL[opieAddr]]};      AddToOpieAddress: PROC [OA: Bindweed.Address, offset: CARDINAL]     RETURNS [address: Bindweed.Address] = {    OPEN DIO: DoveInputOutput;    opieAddr: DIO.OpieAddress ¬ VAL[OA];    lc: LONG UNSPECIFIED;    type: DIO.OpieAddressType ¬ opieAddr.type;    opieAddr.type ¬ nil;    opieAddr.A15toA0 ¬ DIO.OldByteSwap[opieAddr.A15toA0];    lc ¬ VAL[opieAddr];    lc ¬ lc + offset;    opieAddr ¬ VAL[lc];    opieAddr.A15toA0 ¬ DIO.OldByteSwap[opieAddr.A15toA0];    opieAddr.type ¬ type;    RETURN[VAL[opieAddr]]};                 ResetCP: PUBLIC ENTRY PROC = {    ENABLE UNWIND => NULL;    commandBlock: PACKED ARRAY [0..6) OF Environment.Byte;    count: CARDINAL ¬ 2;    commandBlock[0] ¬ commandBlock[1] ¬ count;    commandBlock[2] ¬ ORD[Command.ResetCP];    InsertChecksum[@commandBlock];    Converse[@commandBlock, @commandBlock, 4, minReplyLength, TRUE];    };           WriteMemoryBlock: PUBLIC ENTRY PROCEDURE [    address: Bindweed.Address, addressType: Bindweed.AddressType,    sequence: LONG POINTER TO Bindweed.Sequence] = {    ENABLE UNWIND => NULL;    start, length: NATURAL ¬ 0;    replyBlock, commandBlock: Bindweed.Block;    count: [1..253];    WHILE start < sequence.length DO      length ¬ MIN[Bindweed.maxData, sequence.length - start];      IF addressType # iOPLogical         AND MapRegister[address] # MapRegister[address + length - 1] THEN        length ¬ Inline.LowHalf[	  (MapRegister[address] + 1) * mapRegisterRange - LogicalAddr[address]];      count ¬ 8 + length;      commandBlock[0] ¬ commandBlock[1] ¬ count;      commandBlock[2] ¬ ORD[Command.WriteMemory];      IF addressType = iOPLogical THEN         InsertIOPLogicalAddress[@commandBlock, address]      ELSE InsertOPIEAddress[@commandBlock, address];      commandBlock[7] ¬ ORD[addressType];      commandBlock[8] ¬ length;      FOR i: NATURAL IN [start..start + length) DO        commandBlock[9 + i - start] ¬ sequence[i]; ENDLOOP;      InsertChecksum[@commandBlock];      Converse[        @commandBlock, @replyBlock, memoryCommandLength + length, minReplyLength];      start ¬ start + length;      IF addressType = iOPLogical THEN address ¬ address + length      ELSE         address ¬ AddToOpieAddress[OA: address, offset: length];      ENDLOOP;    };  -- This procedure is exactly the same as WriteMemoryBlock except for the command byte placed in commandBlock  WriteMemoryBits: PUBLIC ENTRY PROCEDURE [ -- for remote heads    address: Bindweed.Address, addressType: Bindweed.AddressType,    sequence: LONG POINTER TO Bindweed.Sequence] = {    ENABLE UNWIND => NULL;    start, length: NATURAL ¬ 0;    replyBlock, commandBlock: Bindweed.Block;    count: [1..253];        IF ErrorDuringWriteBits THEN ERROR Error[timeout];    WHILE start < sequence.length DO      length ¬ MIN[Bindweed.maxData, sequence.length - start];      count ¬ 8 + length;      commandBlock[0] ¬ commandBlock[1] ¬ count;      commandBlock[2] ¬ ORD[Command.WriteMemoryBits];      IF addressType = iOPLogical THEN         InsertIOPLogicalAddress[@commandBlock, address]      ELSE InsertOPIEAddress[@commandBlock, address];      commandBlock[7] ¬ ORD[addressType];      commandBlock[8] ¬ length;      FOR i: NATURAL IN [start..start + length) DO        commandBlock[9 + i - start] ¬ sequence[i]; ENDLOOP;      InsertChecksum[@commandBlock];      Converse[        @commandBlock, @replyBlock, memoryCommandLength + length, minReplyLength];      start ¬ start + length;      address ¬ address + length;      ENDLOOP;    };  WriteIOByte: PUBLIC ENTRY PROCEDURE [port: I186.IOPort, data: Bindweed.Byte] = {    ENABLE UNWIND => NULL;    start, length: NATURAL ¬ 0;    replyBlock, commandBlock: Bindweed.Block;    count: [1..253];    commandBlock[0] ¬ commandBlock[1] ¬ count ¬ 5;    commandBlock[2] ¬ ORD[Command.WriteIOByte];    commandBlock[3] ¬ Inline.LowHalf[port MOD 256];    commandBlock[4] ¬ Inline.LowHalf[port / 256];    commandBlock[5] ¬ data;    InsertChecksum[@commandBlock];    Converse[@commandBlock, @replyBlock, ioCommandLength + 1, minReplyLength];    };  WriteIOWord: PUBLIC ENTRY PROCEDURE [port: I186.IOPort, data: WORD] = {    ENABLE UNWIND => NULL;    start, length: NATURAL ¬ 0;    replyBlock, commandBlock: Bindweed.Block;    count: [1..253];    commandBlock[0] ¬ commandBlock[1] ¬ count ¬ 6;    commandBlock[2] ¬ ORD[Command.WriteIOWord];    commandBlock[3] ¬ Inline.LowHalf[port MOD 256];    commandBlock[4] ¬ Inline.LowHalf[port / 256];    commandBlock[5] ¬ data MOD 256;    commandBlock[6] ¬ data / 256;    InsertChecksum[@commandBlock];    Converse[@commandBlock, @replyBlock, ioCommandLength + 2, minReplyLength];    };  WriteCPControlStore: PUBLIC ENTRY PROCEDURE [    csAddress: [0..Bindweed.sizeOfCS), csWords: [0..Bindweed.maxMIs),    csData: PACKED ARRAY [0..Bindweed.bufferSize) OF Environment.Byte] = {    ENABLE UNWIND => NULL;    replyBlock, commandBlock: Bindweed.Block;    commandBlock[0] ¬ commandBlock[1] ¬ 5 + Bindweed.bytesPerMi * csWords;    commandBlock[2] ¬ ORD[Command.WriteCPControlStore];    commandBlock[3] ¬ csWords;    commandBlock[4] ¬ csAddress MOD 256;    commandBlock[5] ¬ csAddress / 256;    SwapBytes[LOOPHOLE[LONG[@csData]], Bindweed.bufferSize];    FOR i: NATURAL IN [0..Bindweed.bytesPerMi * csWords) DO      commandBlock[6 + i] ¬ csData[i]; ENDLOOP;    InsertChecksum[@commandBlock];    Converse[      @commandBlock, @replyBlock, 7 + Bindweed.bytesPerMi * csWords,      minReplyLength];    };  Put: PUBLIC ENTRY PROCEDURE [block: Bindweed.Block, length: Bindweed.Byte] = {    ENABLE UNWIND => NULL; };  Stop: PUBLIC ENTRY PROCEDURE = {    ENABLE UNWIND => NULL;    commandBlock: PACKED ARRAY [0..6) OF Environment.Byte;    count: CARDINAL ¬ 2;    commandBlock[0] ¬ commandBlock[1] ¬ count;    commandBlock[2] ¬ ORD[Command.Halt];    InsertChecksum[@commandBlock];    Umbilical.ToggleNMI[];    Converse[@commandBlock, @commandBlock, 4, minReplyLength, TRUE];    };      StopIOP: PUBLIC ENTRY PROCEDURE = {    ENABLE UNWIND => NULL;    commandBlock: PACKED ARRAY [0..6) OF Environment.Byte;    count: CARDINAL ¬ 2;    commandBlock[0] ¬ commandBlock[1] ¬ count;    commandBlock[2] ¬ ORD[Command.Halt];    InsertChecksum[@commandBlock];    Umbilical.ToggleNMI[];    Converse[@commandBlock, @commandBlock, 4, minReplyLength, TRUE];    };      StopPC: PUBLIC ENTRY PROCEDURE = {    ENABLE UNWIND => NULL;    commandBlock: PACKED ARRAY [0..6) OF Environment.Byte;    count: CARDINAL ¬ 2;    commandBlock[0] ¬ commandBlock[1] ¬ count;    commandBlock[2] ¬ ORD[Command.StopPC];    InsertChecksum[@commandBlock];    Converse[@commandBlock, @commandBlock, 4, minReplyLength, TRUE];    };      Notify: PUBLIC ENTRY PROCEDURE [    address: Bindweed.Address, addressType: Bindweed.AddressType] = {    ENABLE UNWIND => NULL; };  Watcher: PROCEDURE = {    status: WORD;    WHILE runWatcher DO      Process.Pause[Process.MsecToTicks[50]];      status ¬ PollForAsynchronousNotify[];      IF status # 0 THEN NakedNotify[LOOPHOLE[status]];      ENDLOOP};  SwapBytes: PROCEDURE [    blockPtr: LONG POINTER TO Bindweed.Block, count: Environment.Byte] = {    temp: Environment.Byte ¬ 0;    i: CARDINAL ¬ 0;    UNTIL i >= count DO      temp ¬ blockPtr[i];      blockPtr[i] ¬ blockPtr[i + 1];      blockPtr[i + 1] ¬ temp;      i ¬ i + 2;      ENDLOOP;    };          TurnOnWatcher: PUBLIC ENTRY PROCEDURE = {    IF ~runWatcher THEN {      runWatcher ¬ TRUE;      Process.Detach[FORK Watcher[]]}};      TurnOffWatcher: PUBLIC ENTRY PROCEDURE = {    runWatcher ¬ FALSE};  }.
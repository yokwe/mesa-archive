; Umbilical Send and Receive Handlers; Last edit by FXB    17-Aug-84 15:20:03; FXB   .PA, 17-Jul-84 15:44:33, action: added WaitForCondition (OFFSET umbilicalSendAvail;--	FXB   .PA	13-Mar-85 11:38:17	:changed WaitForInterrupt for OPIE19;--	FXB   .PA	14-Feb-85 17:48:27	:added blockAddrA;--	FXB   .PA	 3-Dec-84 18:41:25	:made independent of RHTestHandler;--	FXB   .PA	 3-Dec-84 15:17:24	:move task initilization;--	FXB   .PA	30-Nov-84  9:53:33	:updated to OPIE!16;--	FXB   .PA	29-Nov-84 13:06:31	:removed reinitialization of umbilical input interrupt;--	FXB   .PA	27-Nov-84 16:25:26	:fixes for RAM based debugger;--	FXB   .PA	26-Nov-84 13:52:38	:included debugger int vector init;--	FXB   .PA	15-Oct-84 11:05:06;--	FXB   .PA	 4-Oct-84 16:23:45	:made badInterrupts be FAR PROCs;--	FXB   .PA	 4-Oct-84  8:33:37	:omitted initialization of test task;--	FXB   .PA	 1-Oct-84 13:28:22	:commented out bad interrupt handling;--	FXB   .PA	28-Sep-84 11:59:48	:separated out test handler;--	FXB   .PA	28-Sep-84 10:56:17	:fixed RET to IRET in DownNotify;--	FXB   .PA	27-Sep-84 16:06:24	:made Down Notify a software int;--	FXB   .PA	26-Sep-84 14:59:45	:made umbilical send code more compact;--	FXB   .PA	21-Sep-84 15:00:06	:SAVE ES on Stack before Waits;--	FXB   .PA	11-Sep-84 14:10:39	:made changed Bindweed to a procedure call;--	FXB   .PA	11-Sep-84 10:19:23	:added NotifyClientCondition for version 13 of OPIE ;--	FXB   .PA	24-Aug-84 14:10:12;--	FXB   .PA	21-Aug-84 14:12:59	:made Bindweed EXTRN;--	FXB   .PA	20-Aug-84  9:37:38	:fixes for Umbilical Send;--	FXB   .PA	 9-Aug-84 11:59:58	:made compatible with Song Bord	NAME	UMBILICL$	TITLE(Umbilical Send and Receive Handlers)$	NOLIST			$	INCLUDE(IOPDefs.asm)$	INCLUDE(IOPMacro.asm)$	INCLUDE(IORegion.asm)	;umbilical data in IORegion$	INCLUDE(UmbDefs.asm)$	INCLUDE(HARDDEFS.ASM)$	INCLUDE(IOPLRam.asm)$	LIST		asynchNotifyBuffer	EQU	0F00H ;???currently conficts with Enet testing region;Bindweed is a label in ROM,;DebugStatus is a variable in low RAM duplicated in the IORegion;temporarily using ES segment override to access low RAM;this code assumes that ES = 0 and that no one will change it!;would prefer that SS = 0 so wouldn't need overrideIORegion		SEGMENT		COMMON 			Assume DS:IORegion						ORG OFFSET umbilicalIORPUBLIC umbilicalTask, upNotifyMask, upNotifyCond umbilicalFCB		LABEL	WORDumbilicalTask		TaskContextBlock	<>umbilicalSendTask	TaskContextBlock	<>umbilicalSendCond	Condition		<>umbilicalSendAvail	Condition		<>urBufferIndex		DW	?urCount			DB	?usBufferIndex		DW	?usCount			DB	?DebugStatus		DW	?upNotifyMask		DW	?			%ENDIOR(umbilical)IORegion		ENDSIORegion		SEGMENT		COMMON 			Assume DS:IORegion			PUBLIC rhClientCondition, remHeadsDownNotifyMask, remHeadsTestCondPUBLIC remHeadsTestTaskPUBLIC blockAddrAEXTRN workNotifierBits: WORD, workNotifierCondition: Condition			ORG OFFSET bindweedIORbindweedFCB		LABEL	WORDbindweedTask		TaskContextBlock	<>upNotifyTask		TaskContextBlock	<>remHeadsTestTask	TaskContextBlock	<>remHeadsTestCond	Condition		<>rhClientCondition	ClientCondition		<>upNotifyCond		Condition		<>bindweedCond		Condition		<>remHeadsDownNotifyMask	DW	?blockAddrA  OpieAddress <0000H, 0AH, extendedBusOpieAddress>													%ENDIOR(bindweed)			IORegion		ENDSEXTRN	BindweedDownNotifyVec: ABSEXTRN	umbilicalSendInterrupt: interruptContextBlock EXTRN	umbilicalRecInterrupt: interruptContextBlockPUBLIC	UmbilicalInit EXTRN   BreakIntrHandler: NEAR, SSIntrHandler: NEAR, DebuggerIntrHandler: NEAR, Bindweed: NEARIOPEInROM 	SEGMENT	PUBLIC	ASSUME CS: IOPEInROM	;-------------------------------------------------------------------; SUBROUTINE : SetNMIDebugIntrVectors;SetNMIDebugIntrVectors:	MOV	AX, OFFSET DebuggerIntrHandler		;Set BX,AX to	MOV	BX, SEG DebuggerIntrHandler	;the CS:IP to be stored	MOV	SI, OFFSET i186NMI		;	MOV	ES:[SI], AX		;Store the new IP	MOV	ES:[SI+2], BX 		;and the new CS	RET;;-------------------------------------------------------------------------; SUBROUTINE : SetSingleStepIntrVectors;SetSingleStepIntrVectors:	MOV	AX, OFFSET SSIntrHandler	;Set BX,AX to	MOV	BX, SEG SSIntrHandler	;the CS:IP to be stored	MOV	SI, OFFSET  i186SingleStep		;Interrupt Type #01h	MOV	ES:[SI], AX		;Store the new IP	MOV	ES:[SI+2], BX 		;and the new CS	RET;;-------------------------------------------------------------------------; SUBROUTINE : SetBreakIntrVectors;SetBreakIntrVectors:	MOV	AX, OFFSET BreakIntrHandler	;Set BX,AX to	MOV	BX, SEG BreakIntrHandler	;the CS:IP to be stored	MOV	SI, OFFSET i186BreakPoint		;Interrupt Type #03h	MOV	ES:[SI], AX		;Store the new IP	MOV	ES:[SI+2], BX 		;and the new CS	RET;;-------------------------------------------------------------------------;UmbilicalInit	PROC	FAR	;initialization	%InitializeTask(OFFSET umbilicalTask, UmbilicalStart)	%InitializeTask(OFFSET umbilicalSendTask, usInit)	%InitializeTask(OFFSET bindweedTask, BindweedHandler)	%InitializeTask(OFFSET upNotifyTask, UpNotifyHandler)	RETUmbilicalInit	ENDPUmbilicalStart:	XOR	AX, AX	MOV	ES, AX		;zero ES for accessing low RAM	%DisableInterruptsTillNextWait	CALL SetNMIDebugIntrVectors	CALL SetSingleStepIntrVectors	CALL SetBreakIntrVectors	%ThisTaskServices(OFFSET umbilicalRecInterrupt, UmbilicalRecBadInterrupt, watchDog)	;prenotify umbilicalSendAvail 	%NotifyCondition (OFFSET umbilicalSendAvail)	XOR	AX, AX	MOV	ES, AX		;zero ES for accessing low RAMurSetUp: 	MOV	urBufferIndex, OFFSET BindweedBuffer	%WaitForInterrupt	CMP	AX, interruptTimeout	JE	urSetUp	CALL	UmbGetInByte		;AL _ inputByte;; 			Does not return if "Bad Data"	MOV	urCount, AL		;initCount		%WaitForInterrupt	CMP	AX, interruptTimeout	JE	urSetUp		CALL	UmbGetInByte		; AL _ inputByte; 			Does not return for "Bad Data"	CMP	urCount, AL		;is count correct?	JNE	urBadCount		;bad count	urLoop:	%WaitForInterrupt	CMP	AX, interruptTimeout	JE	urSetUp       	CALL	UmbGetInByte		;AL _ inputByte	DEC 	urCount	JZ	urDone			;IF count = 0 THEN EXIT		JMP	urLoop 	urDone:			%NotifyCondition (OFFSET bindweedCond)	JMP	urSetUp 	;We can notify bindweed and wait more input because the debugger will not send ;any more data until it receives a reply or times out;If the debugger sends 2 consecutive packets without waiting for replies ;obviously the replies will be smashed since there is only one buffer			UmbGetInByte:				;Byte returned in Al	IN	Al, i8255portC		;(portC is the status port!)	TEST	Al, i8255inReady	;Check for a byte ready	JZ	urBadDataPop		;wait until there is one ready					;	IN	Al, i8255portB		;get the byte and place it in memory	MOV	BP, urBufferIndex	MOV	ES:[BP], AL		;put count in buffer	INC	urBufferIndex		RETurBadDataPop:	POP	AX	MOV	AX, urBadIntrMask	JMP	urBadDataurBadCount:	MOV	AX, urBadCountMaskurBadData:	MOV	BP, OFFSET DebugStatus	OR	ES:[BP], AX	;set badData maskurFlushLoop:	%WaitForInterrupt	;Eventually we will get a watchDog Timeout	CMP	AX, interruptTimeout	JE	urSetUp	MOV	urBufferIndex, OFFSET BindweedBuffer	CALL	UmbGetInByte		;AL _ inputByte	JMP	urFlushLoop ;Come here for watchDog-Timeout or unexpectedInterrupt	UmbilicalRecBadInterrupt PROC FAR	RETUmbilicalRecBadInterrupt ENDPurWatchDogTimeout:;	MOV	AX, urWatchDogTimeoutMaskurQuit:;	OR	ES:[BP], AX	;set badData mask	JMP	urSetUp ;============================================================================BindweedHandler:	%WaitForCondition (OFFSET bindweedCond,noTimeout)	CALL Bindweed	%WaitForCondition (OFFSET umbilicalSendAvail,noTimeout)	; set buffer address	MOV	usBufferIndex, OFFSET BindweedBuffer	%NotifyCondition (OFFSET umbilicalSendCond)	JMP	BindweedHandler;	;============================================================================;	UMBILICAL SEND HANDLER;  CX = bytes to send;  BX = index into buffer    usInit:  ;initialization    	%DisableInterruptsTillNextWait	%ThisTaskServices(OFFSET umbilicalSendInterrupt, UmbilicalSendBadInterrupt, watchDog)usStart:	    	%WaitForCondition (OFFSET umbilicalSendCond,noTimeout)	XOR	AX, AX	MOV	ES, AX		;zero ES for accessing low RAM	MOV	BX, usBufferIndex	XOR	CX, CX		;clear CX	MOV	CL, ES:[BX]	ADD	CL, 2	;usCount _ count + 2 (size of entire buffer)    usLoop:	MOV	DL, ES:[BX]		;Get a byte from the send buffer	CALL	DebPutOutByte		;Send the byte to the debugger	PUSH	BX	PUSH	CX	%WaitForInterrupt 	CMP	AX, interruptTimeout	JE	usStart       	POP	CX	POP	BX	INC	BX	LOOP	usLoop  	  usDone:	%NotifyCondition (OFFSET umbilicalSendAvail)	JMP  usStart 	UmbilicalSendBadInterrupt PROC FAR;	MOV	BP, OFFSET DebugStatus;	MOV	AX, usWatchDogTimeoutMask;	OR	ES:[BP], AX	RETUmbilicalSendBadInterrupt ENDPDebPutOutByte:	IN	Al, i8255portC		;(portC is the status port!)	TEST	Al, i8255outReady		;Check for "ok to put byte"	JZ	DebPutOutByte		;wait	MOV	Al, Dl			;Get the argument	OUT	i8255portA, Al		;       	RET		;==============================================================================	BindweedDownNotify:	OR	workNotifierBits, AX   	%NotifyCondition (OFFSET workNotifierCondition)	IRET 	;============================================================================UpNotifyHandler:;set up vector for  Down Notify	XOR	AX, AX	MOV	ES, AX				;make ES point to low RAM	MOV	AX, OFFSET BindweedDownNotify	;Set BX,AX to	MOV	BX, SEG BindweedDownNotify	;the CS:IP to be stored	MOV	SI, BindweedDownNotifyVec	MOV	ES:[SI], AX			;Store the new IP	MOV	ES:[SI + 2], BX			;and the new CS	%WaitForCondition (OFFSET upNotifyCond,noTimeout)	CALL	UpNotify	JMP	UpNotifyHandler;;=============================================================================UpNotify:	%WaitForCondition (OFFSET umbilicalSendAvail,noTimeout)	MOV	AX, upNotifyMask	MOV 	debugStatus, AX	MOV	upNotifyMask, 0	CALL	PrepareAsynchNotifyBuffer	MOV	usBufferIndex, asynchNotifyBuffer	%NotifyCondition(OFFSET umbilicalSendCond)	RET	PrepareAsynchNotifyBuffer:;	AH checksum;	assume that ES=0;AsynchNotifyBuffer must be in low RAM since the umbilical send handler only sends from low RAMbwMinReply	EQU	3	XOR	AX, AX	MOV	ES, AX	MOV	CL, bwMinReply	MOV	BX, asynchNotifyBuffer	MOV	ES:[BX], CL	INC	BX	MOV	ES:[BX], CL	INC	BX	MOV	DX, DebugStatus	MOV	ES:WORD PTR [BX], DX ;insert status word	MOV	BX, asynchNotifyBuffer	XOR	AH, AH	; clear checksum	ADD	CL, 1 	;include  2 count bytes - checksum byte	XOR	CH, CH	;clear high byte of loop counterchecksumLoop:	ADD	AH, ES:[BX]	;add buffer byte to checksum	INC	BX		;increment bindweed buffer index	LOOP	checksumLoop	MOV	AL, 0	SUB	AL, AH	MOV	ES:[BX], AL 	;insert checksum				;buffer is now ready to send	RET		IOPEInROM ENDS 	END	
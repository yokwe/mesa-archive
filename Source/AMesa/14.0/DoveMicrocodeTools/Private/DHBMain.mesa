-- DHBMain.mesa-- JWF	17-Feb-87 18:08:12 moved emptyDataRecord to DHBDefs-- JWF 23-Jul-86 15:03:27DIRECTORY   FormSW,   Window,   Put,   Ascii,   Bindweed,   I186,   IOPBSymbol,   Inline,   Environment,   String,   UserInput,   Time,   CPSymbol,   CPSymbl,   CPDef,   CPKernelDef,   Runtime,   DHBDefs;   DHBMain: PROGRAMIMPORTS   String, Put, DHBDefs, Inline, Bindweed, IOPBSymbol, Time, UserInput, CPSymbol, CPSymbl, RuntimeEXPORTS   DHBDefs = BEGIN<<     =========================================================================     Constants     =========================================================================>><< Set to true when testing for additional output information >> test: BOOLEAN = FALSE;maxSymLabelDisplayField: CARDINAL = 30;   <<     =========================================================================     Types     =========================================================================>>DirectionType: TYPE = {Forward, Backward};DaisyBermudaKernel: TYPE = [CPKernelDef.kContinue..0FFFH];DayBreakBermudaKernel: TYPE = [0F98..0FFFH];<<     =========================================================================     Signals     =========================================================================>>BadBankSelect: SIGNAL[badBs: CARDINAL] = CODE;   <<     =========================================================================     Variables     =========================================================================>>sampleMade: PUBLIC BOOLEAN ¬ FALSE;d: PUBLIC DHBDefs.Data ¬ DHBDefs.emptyDataRecord;currentData: DHBDefs.DataHandle ¬ NIL;TrigLongWordLow: LONG CARDINAL ¬ 0;TrigLongWordHigh: LONG CARDINAL ¬ 0;MaskLongWordLow: LONG CARDINAL ¬ 0;MaskLongWordHigh: LONG CARDINAL ¬ 0;multiTrig, postTriggerSample: CARDINAL;inputErrors: BOOLEAN;printCPSymbols: BOOLEAN ¬ FALSE;<<     =========================================================================     Procedures     =========================================================================>>ErrorMsg: PROC[msg: LONG STRING] =   BEGIN   Put.Line[d.fileSW, msg];   Put.CR[d.fileSW];   END;SaveFormSubWindowState: PROC[data: DHBDefs.DataHandle] =   BEGIN      d.sampleType ¬ data.sampleType;   d.outputBase ¬ data.outputBase;   d.machineType ¬ data.machineType;   d.msgSW ¬ data.msgSW;   d.formSW ¬ data.formSW;   d.fileSW ¬ data.fileSW;            String.Replace[@d.to, data.to, DHBDefs.z];   String.Replace[@d.from, data.from, DHBDefs.z];   String.Replace[@d.file, data.file, DHBDefs.z];   String.Replace[@d.data, data.data, DHBDefs.z];   String.Replace[@d.data, data.data, DHBDefs.z];   String.Replace[@d.bank, data.bank, DHBDefs.z];   String.Replace[@d.status, data.status, DHBDefs.z];   String.Replace[@d.address, data.address, DHBDefs.z];   String.Replace[@d.nIA, data.nIA, DHBDefs.z];   String.Replace[@d.iOPwildCard, data.iOPwildCard, DHBDefs.z];   String.Replace[@d.cSwildCard, data.cSwildCard, DHBDefs.z];   String.Replace[@d.noofWaitCycles, data.noofWaitCycles, DHBDefs.z];   String.Replace[@d.halt, data.halt, DHBDefs.z];   String.Replace[@d.arbitor, data.arbitor, DHBDefs.z];   String.Replace[@d.multiTRG, data.multiTRG, DHBDefs.z];   String.Replace[@d.postTrigSampleX, data.postTrigSampleX, DHBDefs.z];      END;DecodeBinary: PROC[s: LONG STRING] RETURNS[trig, mask: LONG CARDINAL,   digitCount: INTEGER] =   BEGIN   digitCount ¬ 0;   trig ¬ mask ¬ 0;         IF s = NIL OR s.length < 1 THEN RETURN[0,0,0];            FOR i: CARDINAL IN[0..s.length - 1] DO      IF s[i] = '1 THEN         BEGIN	 trig ¬ trig * 2;	 mask ¬ mask * 2 + 1;	 digitCount ¬ digitCount + 1;	 END      ELSE IF s[i] = '0 THEN         BEGIN	 trig ¬ trig * 2 + 1;	 mask ¬ mask * 2 + 1;	 digitCount ¬ digitCount + 1;	 END      ELSE IF s[i] = 'X OR s[i] = 'x THEN         BEGIN	 trig ¬ trig * 2 + 1;	 mask ¬ mask * 2;	 digitCount ¬ digitCount + 1;	 END      ELSE IF s[i] # Ascii.SP THEN         BEGIN         RETURN[0,0,-1];         END;      ENDLOOP;   END;ValidHexDigit: PROC[ch: CHARACTER] RETURNS[BOOLEAN] =   BEGIN   RETURN[      SELECT ch FROM            IN ['0..'9] => TRUE,            IN ['a..'f] => TRUE,            IN ['A..'F] => TRUE,            ENDCASE => FALSE]   END;      DecodeHexDigit: PROC[ch: CHARACTER] RETURNS[CARDINAL] =   BEGIN   IF ch IN ['a..'f] THEN      RETURN[10 + ORD[ch] - ORD['a]]   ELSE IF ch IN ['A..'F] THEN      RETURN[10 + ORD[ch] - ORD['A]]   ELSE IF ch IN ['0..'9] THEN      RETURN[ORD[ch] - ORD['0]]   ELSE      RETURN[0];   END;         DecodeHex: PROC[s: LONG STRING] RETURNS[trig, mask: LONG CARDINAL,   digitCount: INTEGER] =   BEGIN   digitCount ¬ 0;   trig ¬ mask ¬ 0;         IF s = NIL OR s.length < 1 THEN RETURN[0,0,0];            FOR i: CARDINAL IN[0..s.length - 1] DO      IF ValidHexDigit[s[i]] THEN         BEGIN	 trig ¬ trig * 16 + 15 - DecodeHexDigit[s[i]]; -- trigger get's inverted bits 	 mask ¬ mask * 16 + 15; -- Mask gets all one's	 digitCount ¬ digitCount + 1;	 END      ELSE IF s[i] = 'x OR s[i] = 'X THEN         BEGIN	 trig ¬ trig * 16 + 15; -- trigger gets all one's	 mask ¬ mask * 16;  -- mask gets all zero's	 digitCount ¬ digitCount + 1;	 END      ELSE IF s[i] # Ascii.SP THEN         BEGIN         RETURN[0,0,-1];         END;      ENDLOOP;   END;StringToCardinal: PROC[s: LONG STRING]   RETURNS[number: CARDINAL, validNumber: BOOLEAN] =   BEGIN   number ¬ 0;   validNumber ¬ TRUE;         IF s = NIL OR s.length < 1 THEN RETURN[0, FALSE];            FOR i: CARDINAL IN[0..s.length - 1] DO      IF s[i] IN ['0..'9] THEN         BEGIN	 number ¬ number * 10 + (ORD[s[i]] - ORD['0]); 	 END      ELSE IF s[i] # Ascii.SP THEN         BEGIN         RETURN[0, FALSE];         END;      ENDLOOP;   END;EmptyFieldError: PROC[field: LONG STRING] =   BEGIN   Put.Text[d.fileSW, "Error - Field '"];   Put.Text[d.fileSW, field];   Put.Line[d.fileSW, "' is empty."L];   inputErrors ¬ TRUE;   END;   OutOfRangeError: PROC[field: LONG STRING, low, high: INTEGER] =   BEGIN   Put.Text[d.fileSW, "Error - Number in field '"L];   Put.Text[d.fileSW, field];   Put.Text[d.fileSW, "' must be in the range "L];   Put.Decimal[d.fileSW, low];   Put.Text[d.fileSW, ".."L];   Put.Decimal[d.fileSW, high];   Put.Line[d.fileSW, "."L];      inputErrors ¬ TRUE;   END; MalformedNumberError: PROC[field: LONG STRING] =   BEGIN   Put.Text[d.fileSW, "Error - Malformed number in field '"L];   Put.Text[d.fileSW, field];   Put.Line[d.fileSW, "'."L];   inputErrors ¬ TRUE;   END;    DigitCountError: PROC[field: LONG STRING, count: INTEGER, needed: CARDINAL] =   BEGIN   AmountOff: INTEGER ¬ needed - count;   Put.Text[d.fileSW, "Error - Number in field '"L];   Put.Text[d.fileSW, field];   Put.Text[d.fileSW, "' has "L];   IF AmountOff > 0 THEN      BEGIN      Put.Decimal[d.fileSW, AmountOff];      Put.Line[d.fileSW, " too few digits."L];      END   ELSE      BEGIN      Put.Decimal[d.fileSW, -AmountOff];      Put.Line[d.fileSW, " too many digits."L];      END;   inputErrors ¬ TRUE;   END;   ProcessTriggerSetting: PROC[inString, field: LONG STRING, base: DHBDefs.BaseType,   digitsNeeded: CARDINAL, bitOffset: CARDINAL] =   BEGIN   trigValue, maskValue: LONG CARDINAL;   digitcount: INTEGER;   IF base = Binary THEN      [trigValue, maskValue, digitcount] ¬ DecodeBinary[inString]   ELSE      [trigValue, maskValue, digitcount] ¬ DecodeHex[inString];                    IF digitcount = -1 THEN      MalformedNumberError[field]   ELSE IF digitcount = 0 THEN      EmptyFieldError[field]   ELSE IF CARDINAL[digitcount] # digitsNeeded THEN      DigitCountError[field, digitcount, digitsNeeded]   ELSE      BEGIN      IF bitOffset >= 32 THEN         BEGIN         bitOffset ¬ bitOffset - 32;         TrigLongWordHigh ¬ TrigLongWordHigh +	    Inline.DBITSHIFT[trigValue, bitOffset];         MaskLongWordHigh ¬ MaskLongWordHigh +	    Inline.DBITSHIFT[maskValue, bitOffset];	 END      ELSE         BEGIN         TrigLongWordLow ¬ TrigLongWordLow +	    Inline.DBITSHIFT[trigValue, bitOffset];         MaskLongWordLow ¬ MaskLongWordLow +	    Inline.DBITSHIFT[maskValue, bitOffset];	 END;      END;      END;	        BuildTriggerAndMask: PROC[] =   BEGIN   trigValue, maskValue: LONG CARDINAL;   digitcount: INTEGER;   temp: LONG CARDINAL;   validNumber: BOOLEAN;      inputErrors ¬ FALSE;      TrigLongWordHigh ¬ TrigLongWordLow ¬ 0;   MaskLongWordHigh ¬ MaskLongWordLow ¬ 0;    IF d.sampleType = IOP THEN      BEGIN      ProcessTriggerSetting[d.status, "Status", Binary, 3, 56];      ProcessTriggerSetting[d.arbitor, "Arbitor", Binary, 10, 22];      ProcessTriggerSetting[d.noofWaitCycles,"No. of Wait Cycles", Binary, 4, 16];      ProcessTriggerSetting[d.address, "Address", Hex, 6, 32];      ProcessTriggerSetting[d.data, "Data", Hex, 4, 0];       << IOP Wild Card -- processed here to split 7 bits into two groups of 5 and 2 >>                   [trigValue, maskValue, digitcount] ¬ DecodeBinary[d.iOPwildCard];      IF digitcount = -1 THEN         MalformedNumberError["Wild Card"]      ELSE IF digitcount = 0 THEN         EmptyFieldError["Wild Card"]      ELSE IF digitcount # 7 THEN         DigitCountError["Wild Card", digitcount, 7]      ELSE         BEGIN	 << Do T1 Wild Cards >>	 temp ¬ trigValue MOD 32; -- Mask off all but lower 5 bits	 TrigLongWordHigh ¬ TrigLongWordHigh + Inline.DBITSHIFT[temp, 27];	 temp ¬ maskValue MOD 32; -- Mask off all but lower 5 bits	 MaskLongWordHigh ¬ MaskLongWordHigh + Inline.DBITSHIFT[temp, 27];	 	 << Do T2 Wild Cards >>	 temp ¬ Inline.DBITSHIFT[trigValue, -5]; -- Shift 5 to right 	 TrigLongWordLow ¬ TrigLongWordLow + Inline.DBITSHIFT[temp, 20];	 temp ¬ Inline.DBITSHIFT[maskValue, -5]; -- Shift 5 to right 	 MaskLongWordLow ¬ MaskLongWordLow + Inline.DBITSHIFT[temp, 20];         END;            END   ELSE      BEGIN      ProcessTriggerSetting[d.bank, "Bank", Binary, 4, 12];      ProcessTriggerSetting[d.cSwildCard, "CS Wild Card", Binary, 15, 16];      ProcessTriggerSetting[d.halt,"Halt", Binary, 1, 31];      ProcessTriggerSetting[d.nIA, "NIA", Hex, 3, 0];      END;      [multiTrig, validNumber] ¬ StringToCardinal[d.multiTRG];   IF NOT validNumber THEN      BEGIN      IF d.postTrigSampleX = NIL OR d.postTrigSampleX.length = 0 THEN         BEGIN	 EmptyFieldError["Post Trig Sample"]	 END      ELSE         BEGIN         MalformedNumberError["Multi-TRG"];	 END;      END   ELSE IF multiTrig < 1 OR multiTrig > 16 THEN      BEGIN      OutOfRangeError["Multi-TRG", 1, 16];      END   ELSE      BEGIN      multiTrig ¬ multiTrig - 1; -- Hardware requires range [0..15]      END;         [postTriggerSample, validNumber] ¬ StringToCardinal[d.postTrigSampleX];   IF NOT validNumber THEN      BEGIN      IF d.postTrigSampleX = NIL OR d.postTrigSampleX.length = 0 THEN         BEGIN	 EmptyFieldError["Post Trig Sample"]	 END      ELSE         BEGIN         MalformedNumberError["Post Trig Sample"];	 END;      END   ELSE IF d.sampleType = IOP THEN      BEGIN      IF postTriggerSample > 7 THEN         BEGIN         OutOfRangeError["Post Trig Sample", 0, 7];         END;      END   ELSE      BEGIN      IF postTriggerSample > 15 THEN         BEGIN         OutOfRangeError["Post Trig Sample", 0, 15];         END;      END;   END;      StartSample: PROC[] =   BEGIN   ma3, ma2, ma1, ma0, tr3, tr2, tr1, tr0: UNSPECIFIED;      Put.Char[d.msgSW, Ascii.CR]; -- clear message subwindow    ma3 _ Inline.BITOR[Inline.BITAND[Inline.HighHalf[MaskLongWordHigh],177400B],      Inline.BITSHIFT[Inline.HighHalf[MaskLongWordLow],-8]];    ma2 _ Inline.BITOR[Inline.BITSHIFT[Inline.HighHalf[MaskLongWordHigh],8],      Inline.BITAND[Inline.HighHalf[MaskLongWordLow],377B]];    ma1 _ Inline.BITOR[Inline.BITAND[Inline.LowHalf[MaskLongWordHigh],177400B],      Inline.BITSHIFT[Inline.LowHalf[MaskLongWordLow],-8]];    ma0 _ Inline.BITOR[Inline.BITSHIFT[Inline.LowHalf[MaskLongWordHigh],8],      Inline.BITAND[Inline.LowHalf[MaskLongWordLow],377B]];    tr3 _ Inline.BITOR[Inline.BITAND[Inline.HighHalf[TrigLongWordHigh],177400B],      Inline.BITSHIFT[Inline.HighHalf[TrigLongWordLow],-8]];    tr2 _ Inline.BITOR[Inline.BITSHIFT[Inline.HighHalf[TrigLongWordHigh],8],      Inline.BITAND[Inline.HighHalf[TrigLongWordLow],377B]];    tr1 _ Inline.BITOR[Inline.BITAND[Inline.LowHalf[TrigLongWordHigh],177400B],      Inline.BITSHIFT[Inline.LowHalf[TrigLongWordLow],-8]];    tr0 _ Inline.BITOR[Inline.BITSHIFT[Inline.LowHalf[TrigLongWordHigh],8],      Inline.BITAND[Inline.LowHalf[TrigLongWordLow],377B]];        << Send trigger and mask >>        Bindweed.WriteIOWord[37760B,ma3 !Bindweed.Error => GO TO SBTimeout];    Bindweed.WriteIOWord[37762B,ma2 !Bindweed.Error => GO TO SBTimeout];    Bindweed.WriteIOWord[37764B,ma1 !Bindweed.Error => GO TO SBTimeout];    Bindweed.WriteIOWord[37766B,ma0 !Bindweed.Error => GO TO SBTimeout];    Bindweed.WriteIOWord[37770B,tr3 !Bindweed.Error => GO TO SBTimeout];    Bindweed.WriteIOWord[37772B,tr2 !Bindweed.Error => GO TO SBTimeout];    Bindweed.WriteIOWord[37774B,tr1 !Bindweed.Error => GO TO SBTimeout];    Bindweed.WriteIOWord[37776B,tr0 !Bindweed.Error => GO TO SBTimeout];             << Output For Test Purposes >>  IF test THEN    BEGIN        Put.Number[d.fileSW, ma3, [2, TRUE,TRUE, 16]];    Put.Char[d.fileSW, Ascii.CR];    Put.Number[d.fileSW, ma2, [2, TRUE,TRUE, 16]];    Put.Char[d.fileSW, Ascii.CR];    Put.Number[d.fileSW, ma1, [2, TRUE,TRUE, 16]];    Put.Char[d.fileSW, Ascii.CR];    Put.Number[d.fileSW, ma0, [2, TRUE,TRUE, 16]];    Put.Char[d.fileSW, Ascii.CR];    Put.Number[d.fileSW, tr3, [2, TRUE,TRUE, 16]];    Put.Char[d.fileSW, Ascii.CR];    Put.Number[d.fileSW, tr2, [2, TRUE,TRUE, 16]];    Put.Char[d.fileSW, Ascii.CR];    Put.Number[d.fileSW, tr1, [2, TRUE,TRUE, 16]];    Put.Char[d.fileSW, Ascii.CR];    Put.Number[d.fileSW, tr0, [2, TRUE,TRUE, 16]];    Put.Char[d.fileSW, Ascii.CR];    END;            << Send Command >>        IF d.sampleType = IOP THEN       BEGIN       IF test THEN          BEGIN          Put.Number[d.fileSW, Inline.BITOR[(multiTrig * 256),             Inline.BITOR[(postTriggerSample * 16 * 2), 1]], [2, TRUE,TRUE, 16]];          Put.Char[d.fileSW, Ascii.CR];	  END;	         Bindweed.WriteIOWord[37740B,Inline.BITOR[(multiTrig * 256),          Inline.BITOR[(postTriggerSample * 32), 1]]	  !Bindweed.Error => GO TO SBTimeout];       END    ELSE       BEGIN       IF test THEN          BEGIN          Put.Number[d.fileSW, Inline.BITOR[(multiTrig * 256),          Inline.BITOR[(postTriggerSample * 16),3]], [2, TRUE,TRUE, 16]];          Put.Char[d.fileSW, Ascii.CR];	  END;	         Bindweed.WriteIOWord[37740B,Inline.BITOR[(multiTrig * 256),          Inline.BITOR[(postTriggerSample * 16),3]]          !Bindweed.Error => GO TO SBTimeout];       END;        Bindweed.WriteIOWord[37746B, 0 !Bindweed.Error => GO TO SBTimeout];    Bindweed.WriteIOWord[37742B,0 !Bindweed.Error => GO TO SBTimeout];    sampleMade ¬ TRUE;        EXITS    SBTimeout =>      BEGIN      Put.CR[d.fileSW];      ErrorMsg[" ******** Song Board Time Out ******** "];      Put.CR[d.fileSW];      END;   END;     ResetHistoryBuffer: PUBLIC PROC[] =   BEGIN   Bindweed.WriteIOWord[37746B, 0 !Bindweed.Error => GO TO SBTimeout];      EXITS    SBTimeout =>      BEGIN      Put.CR[d.fileSW];      ErrorMsg[" ******** Song Board Time Out ******** "];      Put.CR[d.fileSW];      END;   END;      AbortSample: PROC[] =   BEGIN   Put.Line[d.msgSW, "-- Process Aborted --"L];   END;     DisplayIOPHeader: PROC[] =    BEGIN    Put.CR[d.fileSW];   IF currentData.outputBase = Binary THEN      BEGIN      Put.Line[d.fileSW,"Trig            Addrs            Stat    Arb      Waits      Data           Wild      Data Type    Symbol"L];      Put.Line[d.fileSW,"----            -----            ----    ---      -----      ----           ----      ---------    ------"L];      Put.CR[d.fileSW];      END   ELSE      BEGIN      Put.Line[d.fileSW," Trig  Addrs  Stat  Arb  Waits  Data  Wild  Data Type  Symbol"L];      Put.Line[d.fileSW," ----  -----  ----  ---  -----  ----  ----  ---------  ------"L];      Put.CR[d.fileSW];      END;    END;DisplayCSHeader: PROC[] =    BEGIN    Put.Line[d.fileSW,""];   IF currentData.outputBase = Binary THEN      BEGIN      Put.Line[d.fileSW,"Trig  Bank Select    NIA      Halt     Wild          State   Symbol"L];      Put.Line[d.fileSW,"----  -----------    ---      ----     ----          -----   ------"L];      Put.CR[d.fileSW];      END   ELSE      BEGIN      Put.Line[d.fileSW,"Trig  Bank Select  NIA  Halt  Wild    State     Symbol"L];      Put.Line[d.fileSW,"----  -----------  ---  ----  ----    -----     ------"L];      Put.CR[d.fileSW];      END;    END;ExtractBits: PROC[number: LONG CARDINAL,		  lowestbit, numberOfBits: CARDINAL]		  RETURNS[result: LONG CARDINAL] =      BEGIN      andMask: ARRAY[1..32] OF LONG CARDINAL = [         00000001H,	 00000003H,	 00000007H,	 0000000FH,	 0000001FH,	 0000003FH,	 0000007FH,	 000000FFH,	 000001FFH,	 000003FFH,	 000007FFH,	 00000FFFH,	 00001FFFH,	 00003FFFH,	 00007FFFH,	 0000FFFFH,	 0001FFFFH,	 0003FFFFH,	 0007FFFFH,	 000FFFFFH,	 001FFFFFH,	 003FFFFFH,	 007FFFFFH,	 00FFFFFFH,	 01FFFFFFH,	 03FFFFFFH,	 07FFFFFFH,	 0FFFFFFFH,	 1FFFFFFFH,	 3FFFFFFFH,	 7FFFFFFFH,	0FFFFFFFFH];	       result ¬ Inline.DBITSHIFT[number, -lowestbit];      result ¬ Inline.DBITAND[result, andMask[numberOfBits]];      END;      DisplayIOPLine: PROC[trigRelativePos: INTEGER] =   BEGIN   symbol: LONG STRING ¬ [50];   high, low: LONG CARDINAL;      high ¬ GetLongWordFromHistoryBuffer[];   low ¬ GetLongWordFromHistoryBuffer[];      << For Testing Purposes >>      IF test THEN      BEGIN      Put.LongNumber[d.fileSW, high, [16, TRUE, TRUE, 8]];      Put.CR[d.fileSW];      Put.LongNumber[d.fileSW, low, [16, TRUE, TRUE, 8]];      Put.CR[d.fileSW];      Put.CR[d.fileSW];      END;         IF trigRelativePos = 0 THEN      BEGIN      Put.Text[d.fileSW, " TRIG"L];      END   ELSE IF trigRelativePos < 0 THEN      BEGIN      Put.LongNumber[d.fileSW, trigRelativePos, [10, TRUE, FALSE, 5]];      END   ELSE      BEGIN      Put.Char[d.fileSW, '+];      Put.LongNumber[d.fileSW, trigRelativePos, [10, TRUE, FALSE, 4]];      END;   Put.Text[d.fileSW,"  "L];      IF currentData.outputBase = Hex THEN      BEGIN            << Address >>      Put.LongNumber[d.fileSW, ExtractBits[high,0, 24], [16, TRUE, TRUE, 6]];      Put.Text[d.fileSW,"  "L];            << Status >>      Put.LongNumber[d.fileSW, ExtractBits[high, 24, 3], [16, TRUE, TRUE, 1]];      Put.Text[d.fileSW,"    "L];            <<Arbitor >>      Put.LongNumber[d.fileSW, ExtractBits[low, 21, 10], [16, TRUE, TRUE, 3]];      Put.Text[d.fileSW,"    "L];            << Number Of Waits >>      Put.LongNumber[d.fileSW, ExtractBits[low, 16, 4], [16, TRUE, TRUE, 1]];      Put.Text[d.fileSW,"    "L];            << Data >>      Put.LongNumber[d.fileSW, ExtractBits[low, 0, 16], [16, TRUE, TRUE, 4]];      Put.Text[d.fileSW,"  "L];            << Wild Cards >>      Put.LongNumber[d.fileSW, ExtractBits[low, 20, 2], [16, TRUE, TRUE, 1]];      Put.Text[d.fileSW," "L];            Put.LongNumber[d.fileSW, ExtractBits[high, 27, 5], [16, TRUE, TRUE, 2]];            SELECT ExtractBits[high, 24, 3] FROM         0 => {Put.Text[d.fileSW, "  Intr. ACK  "L]};	 1 => {Put.Text[d.fileSW, "  Read I/O   "L]};	 2 => {Put.Text[d.fileSW, "  Write I/O  "L]};	 3 => {Put.Text[d.fileSW, "  Halt       "L]};	 4 => {Put.Text[d.fileSW, "  Inst Ftch  "L]};	 5 => {Put.Text[d.fileSW, "  Read Mem   "L]};	 6 => {Put.Text[d.fileSW, "  Write Mem  "L]};	 7 => {Put.Text[d.fileSW, "  Passive    "L]};	 ENDCASE => {ErrorMsg["Internal Error -- Unmatched Case In DisplayIOPLine"]};	 	 IOPBSymbol.AppendAddress[symbol, ExtractBits[high,0, 20], iop];         Put.Text[d.fileSW, symbol];            Put.CR[d.fileSW];	       END   ELSE       BEGIN            << Address >>      Put.LongNumber[d.fileSW, ExtractBits[high,0, 24], [2, TRUE, TRUE, 24]];      Put.Text[d.fileSW,"  "L];            << Status >>      Put.LongNumber[d.fileSW, ExtractBits[high, 24, 3], [2, TRUE, TRUE, 3]];      Put.Text[d.fileSW,"  "L];            <<Arbitor >>      Put.LongNumber[d.fileSW, ExtractBits[low, 21, 10], [2, TRUE, TRUE, 10]];      Put.Text[d.fileSW,"  "L];            << Number Of Waits >>      Put.LongNumber[d.fileSW, ExtractBits[low, 16, 4], [2, TRUE, TRUE, 4]];      Put.Text[d.fileSW,"  "L];            << Data >>      Put.LongNumber[d.fileSW, ExtractBits[low, 0, 16], [2, TRUE, TRUE, 16]];      Put.Text[d.fileSW,"  "L];            << Wild Cards >>      Put.LongNumber[d.fileSW, ExtractBits[low, 20, 2], [2, TRUE, TRUE, 2]];      Put.Text[d.fileSW,"  "L];            Put.LongNumber[d.fileSW, ExtractBits[high, 27, 5], [2, TRUE, TRUE, 5]];            SELECT ExtractBits[high, 24, 3] FROM         0 => {Put.Text[d.fileSW, "  Intr. ACK     "L]};	 1 => {Put.Text[d.fileSW, "  Read I/O      "L]};	 2 => {Put.Text[d.fileSW, "  Write I/O     "L]};	 3 => {Put.Text[d.fileSW, "  Halt          "L]};	 4 => {Put.Text[d.fileSW, "  Instr. Fetch  "L]};	 5 => {Put.Text[d.fileSW, "  Read Memory   "L]};	 6 => {Put.Text[d.fileSW, "  Write Memory  "L]};	 7 => {Put.Text[d.fileSW, "  Passive       "L]};	 ENDCASE => {ErrorMsg["Internal Error -- Unmatched Case In DisplayIOPLine"]};            IOPBSymbol.AppendAddress[symbol, ExtractBits[high,0, 20], iop];      Put.Text[d.fileSW, symbol];       Put.CR[d.fileSW];	       END;   END;   DisplayCSLine: PROC[trigRelativePos: INTEGER] =   BEGIN   word: LONG CARDINAL;      word ¬ GetLongWordFromHistoryBuffer[];      IF trigRelativePos = 0 THEN      BEGIN      Put.Text[d.fileSW, " TRIG"L];      END   ELSE IF trigRelativePos < 0 THEN      BEGIN      Put.LongNumber[d.fileSW, trigRelativePos, [10, TRUE, FALSE, 5]];      END   ELSE      BEGIN      Put.Char[d.fileSW, '+];      Put.LongNumber[d.fileSW, trigRelativePos, [10, TRUE, FALSE, 4]];      END;   Put.Text[d.fileSW,"   "L];        IF currentData.outputBase = Hex THEN      BEGIN            << Bank Select >>      Put.LongNumber[d.fileSW, ExtractBits[word,12, 4], [16, TRUE, TRUE, 1]];            SELECT  ExtractBits[word,12, 4] FROM        14 => {Put.Text[d.fileSW," (0)      "L]};        13 => {Put.Text[d.fileSW," (1)      "L]};        11 => {Put.Text[d.fileSW," (2)      "L]};        7  => {Put.Text[d.fileSW," (3)      "L]};	ENDCASE => {Put.Text[d.fileSW," (?)      "L]};            << NIA >>      Put.LongNumber[d.fileSW, ExtractBits[word, 0, 12], [16, TRUE, TRUE, 3]];      Put.Text[d.fileSW,"   "L];            << Halt >>      Put.LongNumber[d.fileSW, ExtractBits[word, 30, 1], [16, TRUE, TRUE, 1]];      Put.Text[d.fileSW,"    "L];            << Wild Cards >>      Put.LongNumber[d.fileSW, ExtractBits[word, 16,15], [16, TRUE, TRUE, 4]];      Put.Text[d.fileSW,"    "L];                        SELECT ExtractBits[word, 30, 1] FROM         0 => {Put.Text[d.fileSW,"Haulted   "L]};	 1 => {Put.Text[d.fileSW,"Running   "L]};	 ENDCASE => {Put.Text[d.fileSW,"Error -- missed case in DisplayCSLine"L]};	              IF printCPSymbols THEN         BEGIN         IF d.machineType = DayBreak THEN            PrintDayBreakSymbol[CARDINAL[ExtractBits[word,12, 4]],	                        CARDINAL[ExtractBits[word, 0, 12]]]         ELSE            PrintDaisySymbol[CARDINAL[ExtractBits[word,12, 4]],	    		     CARDINAL[ExtractBits[word, 0, 12]]];	 END;      Put.CR[d.fileSW];      END   ELSE       BEGIN            << Bank Select >>      Put.LongNumber[d.fileSW, ExtractBits[word,12, 4], [2, TRUE, TRUE, 4]];            SELECT  ExtractBits[word,12, 4] FROM        14 => {Put.Text[d.fileSW," (0)  "L]};        13 => {Put.Text[d.fileSW," (1)  "L]};        11 => {Put.Text[d.fileSW," (2)  "L]};        7 => {Put.Text[d.fileSW," (3)  "L]};	ENDCASE => {Put.Text[d.fileSW," (?)  "L]};            << NIA >>      Put.LongNumber[d.fileSW, ExtractBits[word, 0, 12], [2, TRUE, TRUE, 12]];      Put.Text[d.fileSW,"  "L];            << Halt >>      Put.LongNumber[d.fileSW, ExtractBits[word, 30, 1], [2, TRUE, TRUE, 1]];      Put.Text[d.fileSW,"  "L];            << Wild Cards >>      Put.LongNumber[d.fileSW, ExtractBits[word, 16,15], [2, TRUE, TRUE, 16]];               SELECT ExtractBits[word, 30, 1] FROM         0 => {Put.Text[d.fileSW,"  Haulted  "L]};	 1 => {Put.Text[d.fileSW,"  Running  "L]};	 ENDCASE => {Put.Text[d.fileSW,"Error -- missed case in DisplayCSLine"L]};	              IF printCPSymbols THEN         BEGIN         IF d.machineType = DayBreak THEN            PrintDayBreakSymbol[CARDINAL[ExtractBits[word,12, 4]],	                        CARDINAL[ExtractBits[word, 0, 12]]]         ELSE            PrintDaisySymbol[CARDINAL[ExtractBits[word,12, 4]],	    		     CARDINAL[ExtractBits[word, 0, 12]]];	 END;	       Put.CR[d.fileSW];      END;   END;   --$$$$$$$$$$$$$$$$$$$$$$$$$$   MakeRealCS   $$$$$$$$$$$$$$$$$$$$$$$$$$$--  --Form a 14 bit CPDef.RealCS from HWBankSelect(4 bits active low) and an address   in a bank.--    MakeRealCS: PROC[bs: CARDINAL, addr: CARDINAL] RETURNS     [realCS: CPDef.RealCS] = BEGIN    realCS ¬ addr + (BankSelectEncode[bs] * CPDef.wordsPerBank);    END;  --MakeRealCS--   --$$$$$$$$$$$$$$$$$$$  BankSelectEncode  $$$$$$$$$$$$$$$$$$$$$$$$$--  -- Convert HWBankSelect to BankNumber --  -- bit 0 = 0 implies bank 0 selected. --  -- If none or more than one bank is selected, raise a signal. --  BankSelectEncode: PROC[bs: CARDINAL] RETURNS [bankNumber: CARDINAL] =    BEGIN    IF d.machineType = DayBreak THEN       BEGIN       SELECT bs FROM         0H => bankNumber ¬ 0;         0CH => bankNumber ¬ 1;         0AH => bankNumber ¬ 2;         9 => bankNumber ¬ 3;         ENDCASE => SIGNAL BadBankSelect[bs];       END    ELSE       BEGIN       SELECT bs FROM         0EH => bankNumber ¬ 0;         0DH => bankNumber ¬ 1;         0BH => bankNumber ¬ 2;         7 => bankNumber ¬ 3;         ENDCASE => SIGNAL BadBankSelect[bs];      END;   END; --BankSelectEncode--       PrintDaisySymbol: PROC[bank, nia: CARDINAL] =    -- Get the symbolic form of the nia.  label + offset.     BEGIN        ENABLE BadBankSelect => { 	  Put.Text[d.fileSW, "Invalid Bank Selection"L];        CONTINUE;};      	ellipsis: LONG STRING ¬ ".."L;	ellipsisLength: CARDINAL = String.Length[ellipsis];	symLabelTailLength: CARDINAL = 5;	symLabelLeaveOutLength: CARDINAL = symLabelTailLength + ellipsisLength;	symLabelFirstPartLength: CARDINAL = maxSymLabelDisplayField -           symLabelLeaveOutLength;	baseSubStr, tailSubStr: String.SubStringDescriptor;	labelPlusOffsetLen: CARDINAL;      virtCS: CPSymbol.VirturalCS;	realCS: CPDef.RealCS;	symbolicCSAddr: LONG STRING ¬ [80];      realCS ¬ MakeRealCS[bs: bank, addr: nia];      [virtCS, , ] ¬ CPSymbol.RealToVirturalCS[realCS];	IF virtCS # CPSymbol.nullVirturalCS THEN BEGIN          CPSymbol.AppendVirturalCS[symbolicCSAddr, virtCS];        END ELSE IF nia IN DaisyBermudaKernel THEN BEGIN	  String.AppendString[symbolicCSAddr, "In Kernel"L];        END ELSE BEGIN	  String.AppendString[symbolicCSAddr, "Invalid CS location"L];        END;            --If the string is too long, print the beginning and the ending.--	labelPlusOffsetLen ¬ String.Length[symbolicCSAddr];	SELECT labelPlusOffsetLen FROM          IN [0..maxSymLabelDisplayField] => BEGIN             Put.Text[d.fileSW, symbolicCSAddr];            Put.Blanks[d.fileSW, maxSymLabelDisplayField -            String.Length[symbolicCSAddr]];              END;          >maxSymLabelDisplayField => BEGIN             baseSubStr ¬ [symbolicCSAddr, 0, symLabelFirstPartLength];            Put.SubString[d.fileSW, @baseSubStr];              Put.Text[d.fileSW, ellipsis];            tailSubStr ¬ [symbolicCSAddr, labelPlusOffsetLen - symLabelTailLength,              symLabelTailLength];            Put.SubString[d.fileSW, @tailSubStr];	    END;        ENDCASE => ErrorMsg["Internal Error -- Negative String Length in PrintDaisySymbol"L];        END;              PrintDayBreakSymbol: PROC[bank, nia: CARDINAL] =    -- Get the symbolic form of the nia.  label + offset.     BEGIN        ENABLE BadBankSelect => { 	  Put.Text[d.fileSW, "Invalid Bank Selection"L];        CONTINUE;};      	ellipsis: LONG STRING ¬ ".."L;	ellipsisLength: CARDINAL = String.Length[ellipsis];	symLabelTailLength: CARDINAL = 5;	symLabelLeaveOutLength: CARDINAL = symLabelTailLength + ellipsisLength;	symLabelFirstPartLength: CARDINAL = maxSymLabelDisplayField -           symLabelLeaveOutLength;	baseSubStr, tailSubStr: String.SubStringDescriptor;	labelPlusOffsetLen: CARDINAL;      virtCS: CPSymbl.VirturalCS;	realCS: CPDef.RealCS;	symbolicCSAddr: LONG STRING ¬ [80];      realCS ¬ MakeRealCS[bs: bank, addr: nia];      [virtCS, , ] ¬ CPSymbl.RealToVirturalCS[realCS];	IF virtCS # CPSymbl.nullVirturalCS THEN BEGIN          CPSymbl.AppendVirturalCS[symbolicCSAddr, virtCS];        END ELSE IF nia IN DayBreakBermudaKernel THEN BEGIN	  String.AppendString[symbolicCSAddr, "In Kernel"L];        END ELSE BEGIN	  String.AppendString[symbolicCSAddr, "Invalid CS location"L];        END;            --If the string is too long, print the beginning and the ending.--	labelPlusOffsetLen ¬ String.Length[symbolicCSAddr];	SELECT labelPlusOffsetLen FROM          IN [0..maxSymLabelDisplayField] => BEGIN             Put.Text[d.fileSW, symbolicCSAddr];            Put.Blanks[d.fileSW, maxSymLabelDisplayField -            String.Length[symbolicCSAddr]];              END;          >maxSymLabelDisplayField => BEGIN             baseSubStr ¬ [symbolicCSAddr, 0, symLabelFirstPartLength];            Put.SubString[d.fileSW, @baseSubStr];              Put.Text[d.fileSW, ellipsis];            tailSubStr ¬ [symbolicCSAddr, labelPlusOffsetLen - symLabelTailLength,              symLabelTailLength];            Put.SubString[d.fileSW, @tailSubStr];	    END;        ENDCASE => ErrorMsg["Internal Error -- Negative String Length in PrintDaisySymbol"L];        END;               SetToTriggerPosition: PROC[direction: DirectionType] =   BEGIN   IF direction = Forward THEN      BEGIN      Bindweed.WriteIOWord[37740B,4 !Bindweed.Error => GO TO SBTimeout];      END   ELSE      BEGIN      Bindweed.WriteIOWord[37740B,0 !Bindweed.Error => GO TO SBTimeout];      END;         Bindweed.WriteIOWord[37742B,0 !Bindweed.Error => GO TO SBTimeout];   EXITS   SBTimeout =>      BEGIN      Put.CR[d.fileSW];      ErrorMsg[" ******** Song Board Time Out ******** "];      Put.CR[d.fileSW];      END;   END;      PositionBufferPointer: PROC[trigOffset: INTEGER] =   BEGIN   IF d.sampleType = IOP THEN      BEGIN      IF trigOffset <= 0 THEN         BEGIN         SetToTriggerPosition[Backward];         FOR i: CARDINAL IN [0..ABS[trigOffset]]            DO	    [] ¬ Bindweed.ReadIOWord[37756B !Bindweed.Error => GO TO SBTimeout];	    IF UserInput.UserAbort[d.fileSW] THEN EXIT;   	    ENDLOOP;         << Set Direction To Forward >>         Bindweed.WriteIOWord[37740B,4 !Bindweed.Error => GO TO SBTimeout];         END      ELSE         BEGIN         SetToTriggerPosition[Forward];         FOR i: CARDINAL IN [0..ABS[trigOffset]]            DO	    [] ¬ Bindweed.ReadIOWord[37756B !Bindweed.Error => GO TO SBTimeout];	    IF UserInput.UserAbort[d.fileSW] THEN EXIT;	    ENDLOOP;         END;      END   ELSE      BEGIN      IF trigOffset <= 0 THEN         BEGIN         SetToTriggerPosition[Backward];         FOR i: CARDINAL IN [1..ABS[trigOffset]]            DO	    [] ¬ Bindweed.ReadIOWord[37756B !Bindweed.Error => GO TO SBTimeout];	    IF UserInput.UserAbort[d.fileSW] THEN EXIT;   	    ENDLOOP;         << Set Direction To Forward >>         Bindweed.WriteIOWord[37740B,4 !Bindweed.Error => GO TO SBTimeout];         END      ELSE         BEGIN         SetToTriggerPosition[Forward];         FOR i: CARDINAL IN [1..ABS[trigOffset]]            DO	    [] ¬ Bindweed.ReadIOWord[37756B !Bindweed.Error => GO TO SBTimeout];	    IF UserInput.UserAbort[d.fileSW] THEN EXIT;	    ENDLOOP;         END;      END;         EXITS   SBTimeout =>      BEGIN      Put.CR[d.fileSW];      ErrorMsg[" ******** Song Board Time Out ******** "];      Put.CR[d.fileSW];      END;         END;      	    GetLongWordFromHistoryBuffer: PROC[] RETURNS[newWord: LONG CARDINAL] =   BEGIN   highWord: CARDINAL;   lowWord: CARDINAL;      highWord ¬ Bindweed.ReadIOWord[37754B !Bindweed.Error => GO TO SBTimeout];   lowWord ¬ Bindweed.ReadIOWord[37756B !Bindweed.Error => GO TO SBTimeout];   newWord ¬ lowWord + Inline.DBITSHIFT[LONG[highWord], 16];   EXITS   SBTimeout =>      BEGIN      Put.CR[d.fileSW];      ErrorMsg[" ******** Song Board Time Out ******** "];      Put.CR[d.fileSW];      END;   END;   DisplayIOPSample: PROC[] =   BEGIN   from, to, postTriggerSample: INTEGER;      from ¬ String.StringToDecimal[currentData.from !String.InvalidNumber =>        BEGIN   	ErrorMsg["""From"" field is not a valid number"];	GO TO NumberError;	END;];      to ¬ String.StringToDecimal[currentData.to !String.InvalidNumber =>        BEGIN   	ErrorMsg["""To"" field is not a valid number"];	GO TO NumberError;	END];	  postTriggerSample ¬ String.StringToDecimal[d.postTrigSampleX !String.InvalidNumber =>        BEGIN   	ErrorMsg["""Post Trigger Sample"" field is not a valid number"];	GO TO NumberError;	END];      IF from < -2048 THEN      BEGIN      ErrorMsg["""From"" field must be larger than or equal to -2048"];      END   ELSE IF from > 2048 THEN      BEGIN      ErrorMsg["""To"" field must be smaller than or equal to 2048"];      END   ELSE IF to < -2048 THEN      BEGIN      ErrorMsg["""From"" field must be larger than or equal to -2048"];      END   ELSE IF to > 2048 THEN      BEGIN      ErrorMsg["""To"" field must be smaller than or equal to 2048"];      END   ELSE IF from > to THEN      BEGIN      ErrorMsg["""To"" field must be larger than ""From"" field"];      END   ELSE IF to - from > 2048 THEN      BEGIN      ErrorMsg["Distance from ""To"" field to ""From"" field must be less than 2048"];      END   ELSE      BEGIN      IF from < (-2048 + postTriggerSample * 256) THEN         BEGIN	 Put.CR[d.fileSW];	 ErrorMsg[" ******* Warning *******  ""From"" field is before buffer begining."];	 from ¬ (-2048 + postTriggerSample * 256);	 IF to < from THEN to ¬ from;	 END;      IF to > postTriggerSample * 256 THEN         BEGIN	 Put.CR[d.fileSW];	 ErrorMsg[" ******* Warning *******  ""To"" field is beyond buffer end."];	 IF from > postTriggerSample * 256 THEN	    from ¬ postTriggerSample * 256 - 1;	 END;	       DisplayIOPHeader;      PositionBufferPointer[from * 2]; --multiply by two because 2 long words per line      IF UserInput.UserAbort[d.fileSW] THEN	    BEGIN	    Put.CR[d.fileSW];	    Put.Line[d.fileSW, "--- User Abort ---"];	    Put.CR[d.fileSW];	    Put.CR[d.msgSW];	    Put.CR[d.msgSW];	    ResetHistoryBuffer[]; 	    RETURN;	    END;	          FOR i: INTEGER IN[from..to]         DO	 DisplayIOPLine[i];	 IF i = postTriggerSample * 256 THEN	    BEGIN	    Put.Line[d.fileSW, "**************************** END BUFFER *****************************"];	    EXIT;	    END;	    	 IF UserInput.UserAbort[d.fileSW] THEN	    BEGIN	    Put.CR[d.fileSW];	    Put.Line[d.fileSW, "--- User Abort ---"];	    Put.CR[d.fileSW];	    Put.CR[d.msgSW];	    Put.CR[d.msgSW];	    ResetHistoryBuffer[]; 	    EXIT;	    END;	    	 ENDLOOP;      ResetHistoryBuffer[];      END;   EXITS    NumberError => RETURN;   END;            DisplayCSSample: PROC[] =   BEGIN   from, to, postTriggerSample: INTEGER;      IF d.machineType = DayBreak THEN       BEGIN       IF NOT Runtime.IsBound[LOOPHOLE[CPSymbl.AppendVirturalCS,       Runtime.ControlLink]] THEN          printCPSymbols ¬ FALSE       ELSE          printCPSymbols ¬ TRUE;       END    ELSE IF d.machineType = Daisy THEN       BEGIN       IF NOT Runtime.IsBound[LOOPHOLE[CPSymbol.AppendVirturalCS,       Runtime.ControlLink]] THEN          printCPSymbols ¬ FALSE       ELSE          printCPSymbols ¬ TRUE;       END;   from ¬ String.StringToDecimal[currentData.from !String.InvalidNumber =>        BEGIN   	ErrorMsg["""From"" field is not a valid number"];	GO TO NumberError;	END;];      to ¬ String.StringToDecimal[currentData.to !String.InvalidNumber =>        BEGIN   	ErrorMsg["""To"" field is not a valid number"];	GO TO NumberError;	END];	  postTriggerSample ¬ String.StringToDecimal[d.postTrigSampleX !String.InvalidNumber =>        BEGIN   	ErrorMsg["""Post Trigger Sample"" field is not a valid number"];	GO TO NumberError;	END];      IF from < -4096 THEN      BEGIN      ErrorMsg["""From"" field must be larger than or equal to -4096"];      END   ELSE IF from > 4096 THEN      BEGIN      ErrorMsg["""To"" field must be smaller than or equal to 4096"];      END   ELSE IF to < -4096 THEN      BEGIN      ErrorMsg["""From"" field must be larger than or equal to -4096"];      END   ELSE IF to > 4096 THEN      BEGIN      ErrorMsg["""To"" field must be smaller than or equal to 4096"];      END   ELSE IF from > to THEN      BEGIN      ErrorMsg["""To"" field must be larger than ""From"" field"];      END   ELSE IF to - from > 4096 THEN      BEGIN      ErrorMsg["Distance from ""To"" field to ""From"" field must be less than 4096"];      END   ELSE      BEGIN      IF from < (-4096 + postTriggerSample * 256) THEN         BEGIN	 Put.CR[d.fileSW];	 ErrorMsg[" ******* Warning *******  ""From"" field is before buffer begining."];	 from ¬ (-4096 + postTriggerSample * 256);	 IF to < from THEN to ¬ from;	 END;      IF to > postTriggerSample * 256 THEN         BEGIN	 Put.CR[d.fileSW];	 ErrorMsg[" ******* Warning *******  ""To"" field is beyond buffer end."];	 IF from > postTriggerSample * 256 THEN	    from ¬ postTriggerSample * 256 - 1;	 END;	       DisplayCSHeader;      PositionBufferPointer[from];            IF UserInput.UserAbort[d.fileSW] THEN	 BEGIN         Put.CR[d.fileSW];         Put.Line[d.fileSW, "--- User Abort ---"];         Put.CR[d.fileSW];         Put.CR[d.msgSW];         Put.CR[d.msgSW];         ResetHistoryBuffer[];          RETURN;         END;	          FOR i: INTEGER IN[from..to]         DO	 DisplayCSLine[i];	 IF i = postTriggerSample * 256 THEN	    BEGIN	    Put.Line[d.fileSW, "****************************** END BUFFER ******************************"];	    EXIT;	    END;	    	 IF UserInput.UserAbort[d.fileSW] THEN	    BEGIN	    Put.CR[d.fileSW];	    Put.Line[d.fileSW, "--- User Abort ---"];	    Put.CR[d.fileSW];	    Put.CR[d.msgSW];	    Put.CR[d.msgSW];	    ResetHistoryBuffer[]; 	    EXIT;	    END;	 ENDLOOP;      ResetHistoryBuffer[];      END;    EXITS    NumberError => RETURN;    END; <<     =========================================================================     Command Item Procedures     =========================================================================>>    SampleMain: PUBLIC PROC[data: DHBDefs.DataHandle] =   BEGIN   timeString: LONG STRING ¬ [30];   Put.CR[d.msgSW]; -- Clear Message Window   Put.CR[d.msgSW];      SaveFormSubWindowState[data];   currentData ¬ data;   BuildTriggerAndMask;      IF NOT inputErrors THEN      BEGIN      StartSample;            IF d.sampleType = IOP THEN         BEGIN	 Time.AppendCurrent[timeString];	 Put.Text[d.fileSW, "IOP Sample Started on "];	 Put.Text[d.fileSW, timeString];	 Put.CR[d.fileSW];	 Put.CR[d.fileSW];	 END      ELSE IF d.sampleType = CS THEN         BEGIN	 Time.AppendCurrent[timeString];	 Put.Text[d.fileSW, "CS Sample Started on "];	 Put.Text[d.fileSW, timeString];	 Put.CR[d.fileSW];	 Put.CR[d.fileSW];	 END;      END   ELSE      BEGIN      AbortSample;      END;         END;      DisplayMain: PUBLIC PROC[data: DHBDefs.DataHandle] =   BEGIN   Put.CR[d.msgSW]; -- Clear Message Window   Put.CR[d.msgSW];   IF sampleMade THEN      BEGIN      currentData ¬ data;      IF d.sampleType = IOP THEN         DisplayIOPSample      ELSE         DisplayCSSample;      END   ELSE      BEGIN      Put.Char[data.fileSW, Ascii.CR];      Put.Line[data.fileSW, "Error -- Can not display. No sample has been made."];      Put.Char[data.fileSW, Ascii.CR];      END   END;END..  
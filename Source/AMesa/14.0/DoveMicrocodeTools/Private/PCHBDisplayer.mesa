-- File: PCHBDisplayer.mesa - last edit:-- FXB   .PA           22-Mar-85 17:42:24-- Create by FormSWLayoutTool on 22-Mar-85 14:24-- Copyright (C) 1985 by Xerox Corporation. All rights reserved.DIRECTORY  Bindweed,  DoveInputOutput,  Exec,  FormSW,  Heap,  PF,  Put,  String,  Time,  Tool,  ToolWindow,  UserTerminal,  Window;PCHBDisplayer: PROGRAM  IMPORTS    Bindweed, DoveInputOutput, Exec, FormSW, Heap, PF, Put, String, Time, Tool,    UserTerminal =  {  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = MACHINE DEPENDENT RECORD [    msgSW(0): Window.Handle _ NIL,    formSW(2): Window.Handle _ NIL,    fileSW(4): Window.Handle _ NIL,    from(6): LONG STRING _ NIL,    to(8): LONG STRING _ NIL];  PCHBAddresses: LONG CARDINAL = 0CC000H;  PCHBData: LONG CARDINAL = 0CD554H;  PCHBTypes: LONG CARDINAL = 0CEAA8H;  FormItems: TYPE = {read, from, to};  WordSequence: TYPE = RECORD [    length: NATURAL ¬ 0, seq: PACKED SEQUENCE maxlength: NATURAL OF WORD];  data: DataHandle _ NIL;  wh: Window.Handle _ NIL;  z: UNCOUNTED ZONE _ Heap.systemZone;  HexStringToCardinal: PROCEDURE [s: LONG STRING] RETURNS [n: CARDINAL ¬ 0] = {    FOR i: CARDINAL IN [0..s.length) DO      SELECT s[i] FROM        '0, '1, '2, '3, '4, '5, '6, '7, '8, '9 => n ¬ n * 16 + s[i] - '0;        'A, 'B, 'C, 'D, 'E, 'F => n ¬ n * 16 + s[i] - 'A + 10;        'a, 'b, 'c, 'd, 'e, 'f => n ¬ n * 16 + s[i] - 'a + 10;        ENDCASE => EXIT;      ENDLOOP;    };  Read: FormSW.ProcType = {    OPEN PF, DoveInputOutput;    from: CARDINAL ¬ HexStringToCardinal[data.from];    to: CARDINAL ¬ HexStringToCardinal[data.to];    byteLength: CARDINAL ¬ 0;    addrSeq, dataSeq, typeSeq: LONG POINTER TO Bindweed.Sequence ¬ NIL;    addrWSeq, dataWSeq, typeWSeq: LONG POINTER TO WordSequence ¬ NIL;    IF from > 0AA9H OR to > 0AA9H OR from > to THEN GOTO badParameters;    byteLength ¬ 2 * (to - from + 1);    PutW[      data.fileSW, "State of PCE History Buffer from: %04x to: %04x at %g:\n\n"L,      [card[from]], [card[to]], [time[Time.Current[]]]];    Put.Line[data.fileSW, "Index      Address      Data       Type\n"L];    addrSeq ¬ z.NEW[      Bindweed .Sequence[byteLength] ¬ [length: byteLength, seq: NULL]];    dataSeq ¬ z.NEW[      Bindweed .Sequence[byteLength] ¬ [length: byteLength, seq: NULL]];    typeSeq ¬ z.NEW[      Bindweed .Sequence[byteLength] ¬ [length: byteLength, seq: NULL]];    Bindweed.ReadMemoryBlock[PCHBAddresses + from * 2, iOPLogical, addrSeq];    Bindweed.ReadMemoryBlock[PCHBData + from * 2, iOPLogical, dataSeq];    Bindweed.ReadMemoryBlock[PCHBTypes + from * 2, iOPLogical, typeSeq];    addrWSeq ¬ LOOPHOLE[addrSeq];    dataWSeq ¬ LOOPHOLE[dataSeq];    typeWSeq ¬ LOOPHOLE[typeSeq];    FOR i: CARDINAL IN [0..byteLength / 2) DO      PutW[        data.fileSW, "%04x        %04x        %04x        %g\n"L, [        card[from + i]], [card[CARDINAL[OldByteSwap[addrWSeq[i]]]]], [        card[CARDINAL[OldByteSwap[dataWSeq[i]]]]], [        str[        SELECT typeWSeq[i] / 256 FROM          0 => "UNUSED"L,          1 => "IN"L,          2 => "OUT"L,          3 => "MINOR"L,          4 => "MAJOR"L,          5 => "FATAL"L,          ENDCASE => "***"L]]];      ENDLOOP;    Put.CR[data.fileSW];    z.FREE[@addrSeq];    z.FREE[@dataSeq];    z.FREE[@typeSeq];    EXITS      badParameters =>        Put.Line[data.fileSW, "Bad Parameters.  The maximum index is 0AA9H.\n"L];    };  HexNumberFilter: FormSW.FilterProcType = {    OPEN String;    BackSpace: CHARACTER = 301C;    BackSpace2: CHARACTER = 210C;    BackWord: CHARACTER = 302C;    BackWord2: CHARACTER = 230C;        CharacterValidHexDigit: PROCEDURE [ch: CHARACTER] RETURNS [valid: BOOLEAN] =      INLINE {      RETURN[        SELECT ch FROM          IN ['0..'9] => TRUE,          IN ['a..'f] => TRUE,          IN ['A..'F] => TRUE,          BackSpace, BackSpace2 => TRUE,          BackWord, BackWord2 => TRUE,          ENDCASE => FALSE]};    index, start: CARDINAL;    tempString, otherTempString, currentString: LONG STRING;    maxlength: CARDINAL ¬ 0;    -- get current string    WITH itemDesc: item SELECT FROM      string => currentString ¬ itemDesc.string­;      ENDCASE => ERROR;    maxlength ¬ currentString.maxlength;    -- assume currentString has already been allocated    tempString ¬ z.NEW[StringBody [currentString.length + string.length]];    otherTempString ¬ z.NEW[StringBody [maxlength]];    IF insert > 0 THEN      FOR i: CARDINAL IN [0..insert) DO        String.AppendChar[tempString, currentString[i]]; ENDLOOP;    index ¬ FormSW.FindIndex[sw, item];    FOR i: CARDINAL IN [0..string.length) DO      IF CharacterValidHexDigit[string[i]] THEN {        SELECT string[i] FROM          BackSpace, BackSpace2 => {            FormSW.ModifyEditable[              sw: sw, index: index, position: insert - 1, length: 1];            z.FREE[@tempString];            RETURN;            };          BackWord, BackWord2 => {            FormSW.ModifyEditable[              sw: sw, index: index, position: 0, length: currentString.length];            z.FREE[@tempString];            RETURN;            };          ENDCASE => String.AppendChar[tempString, UpperCase[string[i]]];        }      ELSE UserTerminal.BlinkDisplay[];      ENDLOOP;    IF currentString.length > insert THEN      FOR i: CARDINAL IN [insert..currentString.length) DO        String.AppendChar[tempString, UpperCase[currentString[i]]]; ENDLOOP;    start ¬      IF tempString.length > maxlength THEN tempString.length - maxlength ELSE 0;    FOR i: CARDINAL IN [start..tempString.length) DO      String.AppendChar[otherTempString, UpperCase[tempString[i]]]; ENDLOOP;    FormSW.ModifyEditable[      sw: sw, index: index, position: 0, length: otherTempString.length,      new: otherTempString];    z.FREE[@tempString];    };  ClientTransition: ToolWindow.TransitionProcType = {    SELECT TRUE FROM      old = inactive =>        IF data = NIL THEN {          data _ z.NEW[Data _ []];          data.from ¬ z.NEW[StringBody [3]];          data.to ¬ z.NEW[StringBody [3]]};      new = inactive =>        IF data # NIL THEN {z.FREE[@data.from]; z.FREE[@data.to]; z.FREE[@data]};      ENDCASE;    };  Unload: Exec.ExecProc = {    [] ¬ Exec.RemoveCommand[h, "PCHBDisplay.~"L]; Tool.Destroy[wh]};  Start: Exec.ExecProc = {    wh _ Tool.Create[      makeSWsProc: MakeSWs, initialState: default,      clientTransition: ClientTransition, name: "PCE History Buffer Displayer"L,      cmSection: "PCHBDisplayer"L];    };  Init: PROC = {    Exec.AddCommand[name: "PCHBDisplay.~"L, proc: Start, unload: Unload]};  MakeSWs: Tool.MakeSWsProc = {    logName: LONG STRING _ [30];    Tool.UnusedLogName[unused: logName, root: "PCHBDisplayer.log"L];    data.msgSW _ Tool.MakeMsgSW[window: window];    data.formSW _ Tool.MakeFormSW[window: window, formProc: MakeForm];    data.fileSW _ Tool.MakeFileSW[window: window, name: logName];    };  MakeForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = FormItems.LAST.ORD + 1;    items _ AllocateItemDescriptor[nItems];    items[FormItems.read.ORD] _ CommandItem[      tag: "Read"L, place: [5, line0], proc: Read];    items[FormItems.from.ORD] _ StringItem[      tag: "From"L, place: [50, line0], inHeap: TRUE, string: @data.from,      filterProc: HexNumberFilter];    items[FormItems.to.ORD] _ StringItem[      tag: "To"L, place: [164, line0], inHeap: TRUE, string: @data.to,      filterProc: HexNumberFilter];    RETURN[items: items, freeDesc: TRUE];    };  -- Mainline code  Init[];  -- this gets string out of global frame  }...    
-- Copyright (C) 1984, 1985  by Xerox Corporation. All rights reserved. -- DisplayerItemHandler.mesa-- DEG      22-Oct-84  1:21:57DIRECTORY  Context USING [    Acquire, Create, Destroy, DestroyProcType, Find, NopDestroyProc, Release, Type,    UniqueType],  Format USING [StringProc],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType, CommandItem,    DisplayItem, Enumerated, EnumeratedItem, FindItem, ItemDescriptor, ItemHandle,    ItemObject, ItemType, line0, line1, line2, line3, newLine, nextPlace,    NumberItem, NumberNotifyProcType, ProcType, StringItem],  FormSWOps USING [FindContext, ItemDescriptor, PContext],  Put USING [Line],  String USING [AppendChar, AppendString, CopyToNewString, Length],  Tool USING [Create, Destroy, MakeFormSW, MakeSWsProc],  ToolWindow USING [WindowForSubwindow],  SimpleDisplayer USING [    BorderType, ChoicePtr, ChoiceRec, DataHandle, ItemHandle, ItemObject, Paint,    RowType, Share, SparseArrayBorderObject, SparseArrayRowObject, td, zone],  UserInput USING [CreatePeriodicNotify, PeriodicProcType],  UserTerminal USING [BlinkDisplay],  Window USING [Box, Handle, Place];DisplayerItemHandler: PROGRAM  IMPORTS    FormSW, FormSWOps, String, Tool, ToolWindow, UserInput, UserTerminal, Context,    SimpleDisplayer, Put  EXPORTS SimpleDisplayer =  {  FormItems: TYPE = {    close, byteFlipped, lowToHigh, word, startingBit, bitsInField, enumName, tag,    readOnly, invisible, drawBox, hasContext};  myContext: Context.Type ¬ Context.UniqueType[];  propsContext: Context.Type ¬ Context.UniqueType[];  lowToHighImplemented: BOOLEAN = FALSE;  ShitForBrains: SIGNAL = CODE;  CreateItem: PUBLIC PROC [    tag: LONG STRING, box: Window.Box, type: FormSW.ItemType,    instance: SimpleDisplayer.DataHandle]    RETURNS [item: SimpleDisplayer.ItemHandle] = {    item ¬ MakeItemObject[type, instance];    item.tag ¬ String.CopyToNewString[tag, SimpleDisplayer.zone];    item.enumName ¬ MakeVar[item.tag];    item.box ¬ box;    WITH i: item­ SELECT FROM      boolean => i.switch ¬ MakeVar[item.tag];      command => i.proc ¬ MakeProc[item.tag];      enumerated => {        i.choiceName ¬ MakeVar[item.tag];        i.value ¬ MakeVar[item.tag];        i.choices ¬ String.CopyToNewString[          "Waitaminnit [buddy, 43] \042fix the enums\042"L, SimpleDisplayer.zone];        IF ~OK[item, instance, FALSE] THEN SIGNAL ShitForBrains;        };      longNumber => i.value ¬ MakeVar[item.tag];      number => i.value ¬ MakeVar[item.tag];      source => i.source ¬ MakeVar[item.tag];      string => i.string ¬ MakeVar[item.tag];      ENDCASE;    };  varcount: CARDINAL ¬ 0;  MakeVar: PROC [tag: LONG STRING] RETURNS [var: LONG STRING] = {    var ¬ SimpleDisplayer.zone.NEW[StringBody [MAX[tag.length, 6]]];    var.length ¬ 0;    FOR i: CARDINAL IN [0..tag.length) DO      IF (tag[i] IN ['A..'Z]) OR (tag[i] IN ['a..'z]) THEN        String.AppendChar[var, tag[i]];      ENDLOOP;    IF var.length = 0 THEN {      String.AppendString[var, "foo"L];      String.AppendChar[var, '0 + ((varcount / 100) MOD 10)];      String.AppendChar[var, '0 + ((varcount / 10) MOD 10)];      String.AppendChar[var, '0 + (varcount MOD 10)];      varcount ¬ (varcount + 1) MOD 1000;      };    IF var[0] IN ['A..'Z] THEN var[0] ¬ var[0] - 'A + 'a;    };  MakeProc: PROC [tag: LONG STRING] RETURNS [proc: LONG STRING] = {    proc ¬ MakeVar[tag];    IF proc[0] IN ['a..'z] THEN proc[0] ¬ proc[0] - 'a + 'A;    };  MakeItemObject: PROC [    type: FormSW.ItemType, instance: SimpleDisplayer.DataHandle]    RETURNS [item: SimpleDisplayer.ItemHandle] = {    item ¬      SELECT type FROM        boolean => SimpleDisplayer.zone.NEW[          SimpleDisplayer.ItemObject.boolean ¬ [body: boolean[]]],        command => SimpleDisplayer.zone.NEW[          SimpleDisplayer.ItemObject.command ¬ [body: command[]]],        enumerated => SimpleDisplayer.zone.NEW[          SimpleDisplayer.ItemObject.enumerated ¬ [          body: enumerated[          copyChoices: instance.defaults.copyChoices,          feedback: instance.defaults.feedbackEnum]]],        longNumber => SimpleDisplayer.zone.NEW[          SimpleDisplayer.ItemObject.longNumber ¬ [          body: longNumber[          signed: instance.defaults.signed,          notNegative: instance.defaults.notNegative,          radix: instance.defaults.radix,          boxWidth: instance.defaults.boxWidthNumber,          default: instance.defaults.longDefault]]],        number => SimpleDisplayer.zone.NEW[          SimpleDisplayer.ItemObject.number ¬ [          body: number[          signed: instance.defaults.signed,          notNegative: instance.defaults.notNegative,          radix: instance.defaults.radix,          boxWidth: instance.defaults.boxWidthNumber,          default: instance.defaults.shortDefault]]],        source => SimpleDisplayer.zone.NEW[          SimpleDisplayer.ItemObject.source ¬ [body: source[]]],        string => SimpleDisplayer.zone.NEW[          SimpleDisplayer.ItemObject.string ¬ [          body: string[          inHeap: instance.defaults.inHeap,          feedback: instance.defaults.feedbackString,          boxWidth: instance.defaults.boxWidthString]]],        ENDCASE => SimpleDisplayer.zone.NEW[          SimpleDisplayer.ItemObject.tagOnly ¬ [body: tagOnly[]]];    item.readOnly ¬ instance.defaults.readOnly;    item.invisible ¬ instance.defaults.invisible;    item.drawBox ¬ instance.defaults.drawBox;    item.hasContext ¬ instance.defaults.hasContext;    };  InitObject: PROC [item: SimpleDisplayer.ItemHandle] = {    WITH i: item­ SELECT FROM      boolean => item­ ¬ SimpleDisplayer.ItemObject[body: boolean[]];      command => item­ ¬ SimpleDisplayer.ItemObject[body: command[]];      enumerated => item­ ¬ SimpleDisplayer.ItemObject[body: enumerated[]];      longNumber => item­ ¬ SimpleDisplayer.ItemObject[body: longNumber[]];      number => item­ ¬ SimpleDisplayer.ItemObject[body: number[]];      source => item­ ¬ SimpleDisplayer.ItemObject[body: source[]];      string => item­ ¬ SimpleDisplayer.ItemObject[body: string[]];      tagOnly => item­ ¬ SimpleDisplayer.ItemObject[body: tagOnly[]];      ENDCASE;    };  OpenProps: PUBLIC PROC [    item: SimpleDisplayer.ItemHandle, instance: SimpleDisplayer.DataHandle] = {    w: Window.Handle ¬ NIL;    name: LONG STRING ¬ SimpleDisplayer.zone.NEW[      StringBody [40 + item.tag.length]];    IF item.modified THEN {UserTerminal.BlinkDisplay[]; RETURN};    item.modified ¬ TRUE;    name.length ¬ 0;    WITH i: item­ SELECT FROM      command => String.AppendString[name, "Command Props"L];      boolean => String.AppendString[name, "Boolean Props"L];      enumerated => String.AppendString[name, "Enumerated Props"L];      longNumber => String.AppendString[name, "LongNumber Props"L];      number => String.AppendString[name, "Number Props"L];      source => String.AppendString[name, "Source Props"L];      string => String.AppendString[name, "String Props"L];      tagOnly => String.AppendString[name, "TagOnly Props"L];      ENDCASE;    String.AppendString[name, "  >> Tag: "L];    String.AppendString[name, item.tag];    String.AppendString[name, " <<"L];    w ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default, name: name, cmSection: name,      initialBox: NextBox[] ! GetItem => {myItem ¬ item; RESUME }];    Context.Create[myContext, item, NullDestroy, w];    Context.Create[      type: SimpleDisplayer.td.context, data: instance,      proc: Context.NopDestroyProc, window: w];    SimpleDisplayer.zone.FREE[@name];    };  NullDestroy: Context.DestroyProcType = {};  MakeSWs: Tool.MakeSWsProc = {    [] ¬ Tool.MakeFormSW[      window: window, formProc: MakeForm, zone: SimpleDisplayer.zone]};  nextbox: Window.Box ¬ [[512, 50], [512, 150]];  NextBox: PROC RETURNS [box: Window.Box] = {    box ¬ nextbox;    nextbox.place ¬ [nextbox.place.x - 20, nextbox.place.y + 20];    IF (nextbox.place.x < 0) OR (nextbox.place.y > 400) THEN      nextbox ¬ [[512, 50], [512, 150]];    };  GetItem: SIGNAL RETURNS [myItem: SimpleDisplayer.ItemHandle] = CODE;  mainBodyItems: CARDINAL = FormItems.LAST.ORD + 1;  NL: Window.Place = FormSW.newLine;  NP: Window.Place = FormSW.nextPlace;  MakeForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    i: SimpleDisplayer.ItemHandle ¬ SIGNAL GetItem[];    Context.Create[      type: propsContext, data: i, proc: Context.NopDestroyProc, window: sw];    WITH vi: i­ SELECT FROM      command => {items ¬ AllocCommand[@vi]; i.maxBitsOccupied ¬ 0};      tagOnly => {items ¬ AllocTagOnly[@vi]; i.maxBitsOccupied ¬ 0};      boolean => {        items ¬ AllocBoolean[@vi]; i.maxBitsOccupied ¬ i.bitsOccupied ¬ 1};      source => {items ¬ AllocSource[@vi]; i.maxBitsOccupied ¬ 0};      enumerated => {        items ¬ AllocEnumerated[@vi];        IF i.bitsOccupied = 0 THEN i.bitsOccupied ¬ 1;        i.maxBitsOccupied ¬ 16};      string => {        items ¬ AllocString[@vi];        i.maxBitsOccupied ¬ 8192;        IF i.bitsOccupied = 0 THEN i.bitsOccupied ¬ 80};      number => {        items ¬ AllocNumber[@vi];        i.maxBitsOccupied ¬ 16;        IF i.bitsOccupied = 0 THEN i.bitsOccupied ¬ i.maxBitsOccupied};      longNumber => {        items ¬ AllocLongNumber[@vi];        i.maxBitsOccupied ¬ 32;        IF i.bitsOccupied = 0 THEN i.bitsOccupied ¬ i.maxBitsOccupied};      ENDCASE;    items[FormItems.close.ORD] ¬ CommandItem[      tag: "Close"L, proc: Close, place: [0, line0], z: SimpleDisplayer.zone];    items[FormItems.byteFlipped.ORD] ¬ BooleanItem[      tag: "byteFlipped"L, place: [114, line0], switch: @i.byteSwappedMachine,      z: SimpleDisplayer.zone];    items[FormItems.lowToHigh.ORD] ¬ BooleanItem[      tag: "lowToHigh"L, place: [294, line0], switch: @i.bitOrderingLowToHigh,      z: SimpleDisplayer.zone, invisible: ~lowToHighImplemented];    items[FormItems.word.ORD] ¬ NumberItem[      tag: "Word "L, place: [0, line1], signed: FALSE, notNegative: TRUE,      default: 0, value: @i.word, z: SimpleDisplayer.zone];    items[FormItems.startingBit.ORD] ¬ NumberItem[      tag: "Starting bit "L, place: [114, line1], signed: FALSE, notNegative: TRUE,      proc: LimitNumberProc1, default: 0, value: @i.startingBitPostion,      z: SimpleDisplayer.zone];    items[FormItems.bitsInField.ORD] ¬ NumberItem[      tag: "Bits in field "L, place: [294, line1], signed: FALSE,      notNegative: TRUE, proc: LimitNumberProc2, default: 1,      value: @i.bitsOccupied, z: SimpleDisplayer.zone];    items[FormItems.enumName.ORD] ¬ StringItem[      tag: "Enum Name"L, string: @i.enumName, boxWidth: 120, inHeap: TRUE,      place: [0, line2], z: SimpleDisplayer.zone];    items[FormItems.tag.ORD] ¬ StringItem[      tag: "Tag"L, string: @i.tag, inHeap: TRUE, place: [216, line2],      z: SimpleDisplayer.zone];    items[FormItems.readOnly.ORD] ¬ BooleanItem[      tag: "readOnly"L, place: [0, line3], switch: @i.readOnly,      z: SimpleDisplayer.zone];    items[FormItems.invisible.ORD] ¬ BooleanItem[      tag: "invisible"L, switch: @i.invisible, place: [72, line3],      z: SimpleDisplayer.zone];    items[FormItems.drawBox.ORD] ¬ BooleanItem[      tag: "drawBox"L, switch: @i.drawBox, place: [150, line3],      z: SimpleDisplayer.zone];    items[FormItems.hasContext.ORD] ¬ BooleanItem[      tag: "hasContext"L, switch: @i.hasContext, place: [216, line3],      z: SimpleDisplayer.zone];    RETURN[items: items, freeDesc: TRUE];    };  AllocCommand: PROC [vi: LONG POINTER TO SimpleDisplayer.ItemObject.command]    RETURNS [items: FormSW.ItemDescriptor] = {    OPEN FormSW;    items ¬ AllocateItemDescriptor[mainBodyItems + 1, SimpleDisplayer.zone];    items[mainBodyItems] ¬ StringItem[      tag: "Proc"L, string: @vi.proc, inHeap: TRUE, place: NL,      z: SimpleDisplayer.zone]};  AllocTagOnly: PROC [vi: LONG POINTER TO SimpleDisplayer.ItemObject.tagOnly]    RETURNS [items: FormSW.ItemDescriptor] = {    OPEN FormSW;    items ¬ AllocateItemDescriptor[mainBodyItems + 1, SimpleDisplayer.zone];    items[mainBodyItems] ¬ NumberItem[      tag: "OtherItem"L, value: @vi.other, place: NL, z: SimpleDisplayer.zone]};  AllocBoolean: PROC [vi: LONG POINTER TO SimpleDisplayer.ItemObject.boolean]    RETURNS [items: FormSW.ItemDescriptor] = {    OPEN FormSW;    items ¬ AllocateItemDescriptor[mainBodyItems + 2, SimpleDisplayer.zone];    items[mainBodyItems] ¬ StringItem[      tag: "Proc"L, string: @vi.proc, inHeap: TRUE, place: NL, boxWidth: 100,      z: SimpleDisplayer.zone];    items[mainBodyItems + 1] ¬ StringItem[      tag: "Switch"L, string: @vi.switch, inHeap: TRUE, z: SimpleDisplayer.zone]};  AllocSource: PROC [vi: LONG POINTER TO SimpleDisplayer.ItemObject.source]    RETURNS [items: FormSW.ItemDescriptor] = {    OPEN FormSW;    items ¬ AllocateItemDescriptor[mainBodyItems + 4, SimpleDisplayer.zone];    items[mainBodyItems] ¬ NumberItem[      tag: "BoxWidth"L, value: @vi.boxWidth, place: NL, z: SimpleDisplayer.zone];    items[mainBodyItems + 1] ¬ StringItem[      tag: "Source"L, string: @vi.source, inHeap: TRUE, z: SimpleDisplayer.zone];    items[mainBodyItems + 2] ¬ StringItem[      tag: "MenuProc"L, string: @vi.menuProc, inHeap: TRUE, place: NL,      boxWidth: 100, z: SimpleDisplayer.zone];    items[mainBodyItems + 3] ¬ StringItem[      tag: "Filter"L, string: @vi.filterProc, inHeap: TRUE,      z: SimpleDisplayer.zone]};  AllocEnumerated: PROC [vi: LONG POINTER TO SimpleDisplayer.ItemObject.enumerated]    RETURNS [items: FormSW.ItemDescriptor] = {    OPEN FormSW;    e1: ARRAY [0..2) OF FormSW.Enumerated ¬ [["all"L, 0], ["one"L, 1]];    items ¬ AllocateItemDescriptor[mainBodyItems + 6, SimpleDisplayer.zone];    items[mainBodyItems] ¬ BooleanItem[      tag: "CopyChoices"L, place: NL, switch: @vi.copyChoices,      z: SimpleDisplayer.zone];    items[mainBodyItems + 1] ¬ EnumeratedItem[      tag: "Feedback"L, value: @vi.feedback, choices: DESCRIPTOR[e1], place: NP,      z: SimpleDisplayer.zone];    items[mainBodyItems + 2] ¬ StringItem[      tag: "Value"L, string: @vi.value, inHeap: TRUE, place: NL, boxWidth: 100,      z: SimpleDisplayer.zone];    items[mainBodyItems + 3] ¬ StringItem[      tag: "Proc"L, string: @vi.proc, inHeap: TRUE, boxWidth: 100,      z: SimpleDisplayer.zone];    items[mainBodyItems + 4] ¬ StringItem[      tag: "ChoiceName"L, string: @vi.choiceName, inHeap: TRUE,      z: SimpleDisplayer.zone];    items[mainBodyItems + 5] ¬ StringItem[      tag: "Choices"L, string: @vi.choices, inHeap: TRUE, place: NL,      z: SimpleDisplayer.zone]};  AllocString: PROC [vi: LONG POINTER TO SimpleDisplayer.ItemObject.string]    RETURNS [items: FormSW.ItemDescriptor] = {    OPEN FormSW;    e1: ARRAY [0..2) OF FormSW.Enumerated ¬ [["normal"L, 0], ["password"L, 1]];    items ¬ AllocateItemDescriptor[mainBodyItems + 6, SimpleDisplayer.zone];    items[mainBodyItems] ¬ BooleanItem[      tag: "InHeap"L, place: NL, switch: @vi.inHeap, z: SimpleDisplayer.zone];    items[mainBodyItems + 1] ¬ EnumeratedItem[      tag: "Feedback"L, value: @vi.feedback, choices: DESCRIPTOR[e1], place: NP,      z: SimpleDisplayer.zone];    items[mainBodyItems + 2] ¬ NumberItem[      tag: "BoxWidth"L, value: @vi.boxWidth, place: NP, z: SimpleDisplayer.zone];    items[mainBodyItems + 3] ¬ StringItem[      tag: "String"L, string: @vi.string, inHeap: TRUE, z: SimpleDisplayer.zone];    items[mainBodyItems + 4] ¬ StringItem[      tag: "FilterProc"L, string: @vi.filterProc, inHeap: TRUE, place: NL,      boxWidth: 100, z: SimpleDisplayer.zone];    items[mainBodyItems + 5] ¬ StringItem[      tag: "MenuProc"L, string: @vi.menuProc, inHeap: TRUE,      z: SimpleDisplayer.zone]};  AllocNumber: PROC [vi: LONG POINTER TO SimpleDisplayer.ItemObject.number]    RETURNS [items: FormSW.ItemDescriptor] = {    OPEN FormSW;    e1: ARRAY [0..2) OF FormSW.Enumerated ¬ [["decimal"L, 0], ["octal"L, 1]];    items ¬ AllocateItemDescriptor[mainBodyItems + 8, SimpleDisplayer.zone];    items[mainBodyItems] ¬ BooleanItem[      tag: "Signed"L, place: NL, switch: @vi.signed, z: SimpleDisplayer.zone];    items[mainBodyItems + 1] ¬ BooleanItem[      tag: "NotNegative"L, switch: @vi.notNegative, place: NP,      z: SimpleDisplayer.zone];    items[mainBodyItems + 2] ¬ NumberItem[      tag: "BoxWidth"L, value: @vi.boxWidth, place: NP, z: SimpleDisplayer.zone];    items[mainBodyItems + 3] ¬ NumberItem[      tag: "Default"L, value: @vi.default, place: NP, z: SimpleDisplayer.zone];    items[mainBodyItems + 4] ¬ EnumeratedItem[      tag: "Radix"L, value: @vi.radix, choices: DESCRIPTOR[e1], place: NP,      z: SimpleDisplayer.zone];    items[mainBodyItems + 5] ¬ NumberItem[      tag: "Bias"L, value: @vi.bias, place: NP, z: SimpleDisplayer.zone];    items[mainBodyItems + 6] ¬ StringItem[      tag: "Proc"L, string: @vi.proc, inHeap: TRUE, place: NL, boxWidth: 100,      z: SimpleDisplayer.zone];    items[mainBodyItems + 7] ¬ StringItem[      tag: "Value"L, string: @vi.value, inHeap: TRUE, z: SimpleDisplayer.zone]};  AllocLongNumber: PROC [vi: LONG POINTER TO SimpleDisplayer.ItemObject.longNumber]    RETURNS [items: FormSW.ItemDescriptor] = {    OPEN FormSW;    e1: ARRAY [0..2) OF FormSW.Enumerated ¬ [["decimal"L, 0], ["octal"L, 1]];    items ¬ AllocateItemDescriptor[mainBodyItems + 8, SimpleDisplayer.zone];    items[mainBodyItems] ¬ BooleanItem[      tag: "Signed"L, place: NL, switch: @vi.signed, z: SimpleDisplayer.zone];    items[mainBodyItems + 1] ¬ BooleanItem[      tag: "NotNegative"L, switch: @vi.notNegative, place: NP,      z: SimpleDisplayer.zone];    items[mainBodyItems + 2] ¬ NumberItem[      tag: "BoxWidth"L, value: @vi.boxWidth, place: NP, z: SimpleDisplayer.zone];    items[mainBodyItems + 3] ¬ NumberItem[      tag: "Default"L, value: @vi.default, place: NP, z: SimpleDisplayer.zone];    items[mainBodyItems + 4] ¬ EnumeratedItem[      tag: "Radix"L, value: @vi.radix, choices: DESCRIPTOR[e1], place: NP,      z: SimpleDisplayer.zone];    items[mainBodyItems + 5] ¬ NumberItem[      tag: "Bias"L, value: @vi.bias, place: NP, z: SimpleDisplayer.zone];    items[mainBodyItems + 6] ¬ StringItem[      tag: "Proc"L, string: @vi.proc, inHeap: TRUE, place: NL, boxWidth: 100,      z: SimpleDisplayer.zone];    items[mainBodyItems + 7] ¬ StringItem[      tag: "Value"L, string: @vi.value, inHeap: TRUE, z: SimpleDisplayer.zone]};  Close: FormSW.ProcType = {    window: Window.Handle ¬ ToolWindow.WindowForSubwindow[sw];    instance: SimpleDisplayer.DataHandle = SimpleDisplayer.Share[wh: window];    itemH: SimpleDisplayer.ItemHandle ¬ Context.Find[myContext, window];    c: FormSWOps.PContext = FormSWOps.FindContext[sw];    Context.Destroy[type: propsContext, window: sw];    FOR i: CARDINAL IN [0..LENGTH[c.items]) DO      WITH variant: c.items[i] SELECT FROM        string => variant.inHeap ¬ FALSE;        ENDCASE;      ENDLOOP;    IF itemH # NIL THEN itemH.modified ¬ FALSE;    IF OK[itemH, instance] THEN      [] ¬ UserInput.CreatePeriodicNotify[Kill, window, 0];    };  Kill: UserInput.PeriodicProcType = {Tool.Destroy[window]; };  OK: PUBLIC PROC [    item: SimpleDisplayer.ItemHandle, instance: SimpleDisplayer.DataHandle,    update: BOOLEAN ¬ TRUE] RETURNS [ok: BOOLEAN ¬ TRUE] = {    WITH i: item­ SELECT FROM      enumerated => {        ENABLE {          BadList => {            UserTerminal.BlinkDisplay[];            Put.Line[NIL, "Malformed choice list"L];            GOTO bad};          MissingQuote => {            UserTerminal.BlinkDisplay[];            Put.Line[NIL, "Missing close quote"L];            GOTO bad}};        ptr: CARDINAL ¬ 0;        tempPtr: SimpleDisplayer.ChoicePtr;        s1, s2: LONG STRING ¬ NIL;        ok ¬ FALSE;        IF String.Length[i.choices] = 0 THEN {          Put.Line[NIL, "Need to fill in enumerated choices"L];          UserTerminal.BlinkDisplay[];          RETURN};        FreeChoices[i.choiceList];        [s1, s2, ptr] ¬ GetTokens[i.choices, ptr];        tempPtr ¬ i.choiceList ¬ SimpleDisplayer.zone.NEW[          SimpleDisplayer.ChoiceRec ¬ [a: s1, b: s2]];        WHILE ptr < (i.choices.length - 1) DO          [s1, s2, ptr] ¬ GetTokens[i.choices, ptr];          IF s1 # NIL THEN {            tempPtr.next ¬ SimpleDisplayer.zone.NEW[              SimpleDisplayer.ChoiceRec ¬ [a: s1, b: s2]];            tempPtr ¬ tempPtr.next};          ENDLOOP;        ok ¬ TRUE;        IF update THEN SimpleDisplayer.Paint[item, instance];        };      ENDCASE => IF update THEN SimpleDisplayer.Paint[item, instance];    EXITS bad => NULL;    };  BadList: SIGNAL = CODE;  MissingQuote: SIGNAL = CODE;  GetTokens: PROC [choices: LONG STRING, ptr: CARDINAL]    RETURNS [s1, s2: LONG STRING ¬ NIL, new: CARDINAL] = {    WHILE White[choices[ptr]] DO      ptr ¬ ptr + 1; IF ptr = choices.length THEN RETURN[NIL, NIL, ptr]; ENDLOOP;    SELECT choices[ptr] FROM      '[ => {        ptr ¬ ptr + 1;        IF ptr = choices.length THEN SIGNAL BadList;        [s1, ptr] ¬ GetOne[choices, ptr];        WHILE White[choices[ptr]] OR choices[ptr] = ', DO          ptr ¬ ptr + 1; IF ptr = choices.length THEN SIGNAL BadList; ENDLOOP;        [s2, ptr] ¬ GetOne[choices, ptr];        WHILE choices[ptr] # '] DO          ptr ¬ ptr + 1; IF ptr = choices.length THEN SIGNAL BadList; ENDLOOP;        ptr ¬ ptr + 1;        };      ENDCASE => [s1, ptr] ¬ GetOne[choices, ptr];    new ¬ ptr;    };  GetOne: PROC [choices: LONG STRING, ptr: CARDINAL]    RETURNS [s: LONG STRING ¬ NIL, new: CARDINAL] = {    len: CARDINAL ¬ 1;    token: BOOLEAN ¬ choices[ptr] # '";    IF token THEN {      DO        IF (ptr + len) >= choices.length THEN EXIT;        IF White[choices[ptr + len]] OR Delimiter[choices[ptr + len]] THEN EXIT;        len ¬ len + 1;      ENDLOOP;      s ¬ SimpleDisplayer.zone.NEW[StringBody [len]];      s.length ¬ 0;      FOR j: CARDINAL IN [0..len) DO        String.AppendChar[s, choices[ptr + j]]; ENDLOOP;      new ¬ ptr + len;      }    ELSE {      DO        IF choices[ptr + len] = '" THEN EXIT;        len ¬ len + 1;        IF (ptr + len) = choices.length THEN SIGNAL MissingQuote;        ENDLOOP;      s ¬ SimpleDisplayer.zone.NEW[StringBody [len - 1]];      s.length ¬ 0;      FOR j: CARDINAL IN [1..len) DO        String.AppendChar[s, choices[ptr + j]]; ENDLOOP;      new ¬ ptr + len + 1;      };    };  White: PROC [c: CHARACTER] RETURNS [yes: BOOLEAN] = INLINE {    yes ¬ (c = ' ) OR (c = '\n) OR (c = '\t); };  Delimiter: PROC [c: CHARACTER] RETURNS [yes: BOOLEAN] = INLINE {    yes ¬ (c = ']) OR (c = '[) OR (c = ',) OR (c = '"); };  FreeChoices: PROC [list: SimpleDisplayer.ChoicePtr] = {    temp: SimpleDisplayer.ChoicePtr ¬ list;    j: SimpleDisplayer.ChoicePtr ¬ list;    FOR j ¬ temp, temp UNTIL j = NIL DO      temp ¬ temp.next;      IF j.a # NIL THEN SimpleDisplayer.zone.FREE[@j.a];      IF j.b # NIL THEN SimpleDisplayer.zone.FREE[@j.b];      SimpleDisplayer.zone.FREE[@j];      ENDLOOP;    };  DestroyItemObject: PROC [item: SimpleDisplayer.ItemHandle] = {    SimpleDisplayer.zone.FREE[@item.tag];    SimpleDisplayer.zone.FREE[@item.enumName];    WITH i: item­ SELECT FROM      boolean => {        IF i.switch # NIL THEN SimpleDisplayer.zone.FREE[@i.switch];        IF i.proc # NIL THEN SimpleDisplayer.zone.FREE[@i.proc]};      command => {IF i.proc # NIL THEN SimpleDisplayer.zone.FREE[@i.proc]; };      enumerated => {        IF i.value # NIL THEN SimpleDisplayer.zone.FREE[@i.value];        IF i.proc # NIL THEN SimpleDisplayer.zone.FREE[@i.proc];        IF i.choiceName # NIL THEN SimpleDisplayer.zone.FREE[@i.choiceName];        IF i.choices # NIL THEN SimpleDisplayer.zone.FREE[@i.choices];        FreeChoices[i.choiceList]};      longNumber => {        IF i.proc # NIL THEN SimpleDisplayer.zone.FREE[@i.proc];        IF i.value # NIL THEN SimpleDisplayer.zone.FREE[@i.value];        IF i.string # NIL THEN SimpleDisplayer.zone.FREE[@i.string]};      number => {        IF i.proc # NIL THEN SimpleDisplayer.zone.FREE[@i.proc];        IF i.value # NIL THEN SimpleDisplayer.zone.FREE[@i.value];        IF i.string # NIL THEN SimpleDisplayer.zone.FREE[@i.string]};      source => {        IF i.filterProc # NIL THEN SimpleDisplayer.zone.FREE[@i.filterProc];        IF i.menuProc # NIL THEN SimpleDisplayer.zone.FREE[@i.menuProc]};      string => {        IF i.string # NIL THEN SimpleDisplayer.zone.FREE[@i.string];        IF i.filterProc # NIL THEN SimpleDisplayer.zone.FREE[@i.filterProc];        IF i.menuProc # NIL THEN SimpleDisplayer.zone.FREE[@i.menuProc]};      ENDCASE;    SimpleDisplayer.zone.FREE[@item];    };  DestroyItem: PUBLIC PROC [    item: SimpleDisplayer.ItemHandle, instance: SimpleDisplayer.DataHandle,    keepTrash: BOOLEAN ¬ TRUE] = {    RemoveFromSparseArray[item: item, instance: instance];    IF keepTrash THEN {      IF instance.trash # NIL THEN DestroyItemObject[instance.trash];      instance.trash ¬ item}    ELSE DestroyItemObject[item];    };  GetTrash: PUBLIC PROCEDURE [instance: SimpleDisplayer.DataHandle]    RETURNS [item: SimpleDisplayer.ItemHandle] = {    item ¬ instance.trash; instance.trash ¬ NIL};  BorderType: TYPE = SimpleDisplayer.BorderType;  SparseArrayBorderObject: TYPE = SimpleDisplayer.SparseArrayBorderObject;  RowType: TYPE = SimpleDisplayer.RowType;  SparseArrayRowObject: TYPE = SimpleDisplayer.SparseArrayRowObject;  EndOfBorder: SIGNAL = CODE;  EndOfRow: SIGNAL = CODE;  ItemNotFound: SIGNAL = CODE;  AddItem: PUBLIC PROC [    item: SimpleDisplayer.ItemHandle, instance: SimpleDisplayer.DataHandle] = {    line: CARDINAL ¬ item.box.place.y / instance.lineHeight;    p: BorderType;    IF instance.head = NIL THEN      instance.head ¬ SimpleDisplayer.zone.NEW[SparseArrayBorderObject ¬ []];    FOR p ¬ instance.head, p.next UNTIL p = NIL DO      IF p.line = line THEN {AddToRow[p, item, instance]; RETURN}      ELSE        IF p.next = NIL THEN {          p.next ¬ SimpleDisplayer.zone.NEW[            SparseArrayBorderObject ¬ [line: line]];          AddToRow[p.next, item, instance];          RETURN}        ELSE          IF line < p.next.line THEN {            p.next ¬ SimpleDisplayer.zone.NEW[              SparseArrayBorderObject ¬ [line: line, next: p.next]];            AddToRow[p.next, item, instance];            RETURN};      ENDLOOP;    SIGNAL EndOfBorder;    };  AddToRow: PROC [    b: BorderType, item: SimpleDisplayer.ItemHandle,    instance: SimpleDisplayer.DataHandle] = {    r: RowType;    x: INTEGER ¬ item.box.place.x;    instance.itemCount ¬ instance.itemCount + 1;  << assume that we can add the item. >>    IF b.row = NIL THEN {      b.row ¬ SimpleDisplayer.zone.NEW[SparseArrayRowObject ¬ [item: item]];      RETURN};    IF x < b.row.item.box.place.x THEN {      b.row ¬ SimpleDisplayer.zone.NEW[        SparseArrayRowObject ¬ [item: item, next: b.row]];      RETURN};    FOR r ¬ b.row, r.next UNTIL r = NIL DO      IF r.next = NIL THEN {        r.next ¬ SimpleDisplayer.zone.NEW[SparseArrayRowObject ¬ [item: item]];        RETURN}      ELSE        IF x < r.next.item.box.place.x THEN {          r.next ¬ SimpleDisplayer.zone.NEW[            SparseArrayRowObject ¬ [item: item, next: r.next]];          RETURN};      ENDLOOP;    instance.itemCount ¬ instance.itemCount - 1;  << we were not able to add the item. >>    SIGNAL EndOfRow;    };  ResolveToItem: PUBLIC PROC [    coords: Window.Place, instance: SimpleDisplayer.DataHandle]    RETURNS [item: SimpleDisplayer.ItemHandle] = {    line: CARDINAL ¬ coords.y / instance.lineHeight;    b: BorderType;    item ¬ NIL;    IF instance.head = NIL THEN RETURN;    b ¬ FindRow[instance.head, line];    IF b = NIL OR b.row = NIL THEN RETURN;    item ¬ FindItem[b.row, coords];    };  FindRow: PROC [b: BorderType, line: CARDINAL] RETURNS [found: BorderType ¬ NIL] =    {    IF b.line = line THEN RETURN[b]    ELSE IF b.next = NIL THEN RETURN[NIL] ELSE found ¬ FindRow[b.next, line];    };  InBox: PROC [box: Window.Box, place: Window.Place] RETURNS [yes: BOOLEAN] =    INLINE {    yes ¬ box.place.x <= place.x AND place.x <= box.place.x + box.dims.w      AND box.place.y <= place.y AND place.y <= box.place.y + box.dims.h;    };  FindItem: PROC [r: RowType, coords: Window.Place]    RETURNS [item: SimpleDisplayer.ItemHandle ¬ NIL] = {    IF InBox[r.item.box, coords] THEN RETURN[r.item]    ELSE      IF r.next = NIL THEN RETURN[NIL]      ELSE        IF coords.x < r.next.item.box.place.x THEN RETURN[NIL]        ELSE item ¬ FindItem[r.next, coords]};  FreeBorders: PROC [b: BorderType, instance: SimpleDisplayer.DataHandle] = {    IF b = NIL THEN RETURN ELSE FreeBorders[b.next, instance];    FreeRows[b.row, instance];    SimpleDisplayer.zone.FREE[@b]};  FreeRows: PROC [r: RowType, instance: SimpleDisplayer.DataHandle] = {    IF r = NIL THEN RETURN ELSE FreeRows[r.next, instance];    DestroyItemObject[r.item];    instance.itemCount ¬ instance.itemCount - 1;    SimpleDisplayer.zone.FREE[@r]};  DestroyAllItems: PUBLIC PROCEDURE [instance: SimpleDisplayer.DataHandle] = {    FreeBorders[instance.head, instance]; instance.head ¬ NIL};  RemoveFromSparseArray: PROC [    item: SimpleDisplayer.ItemHandle, instance: SimpleDisplayer.DataHandle] = {    line: CARDINAL ¬ item.box.place.y / instance.lineHeight;    b: BorderType ¬ NIL;    r, temp: RowType ¬ NIL;    b ¬ FindRow[instance.head, line];    IF b = NIL THEN SIGNAL ItemNotFound;    IF b.row.item = item THEN {      temp ¬ b.row; b.row ¬ b.row.next; SimpleDisplayer.zone.FREE[@temp]; RETURN}    ELSE      FOR r ¬ b.row, r.next UNTIL r = NIL DO        IF r.next # NIL AND r.next.item = item THEN {          temp ¬ r.next;          r.next ¬ r.next.next;          SimpleDisplayer.zone.FREE[@temp];          RETURN};        ENDLOOP;    SIGNAL ItemNotFound;    };  EnumerateItems: PUBLIC PROC [    proc: PROC [      item: SimpleDisplayer.ItemHandle, Write: Format.StringProc,      instance: SimpleDisplayer.DataHandle ¬ NIL], Write: Format.StringProc,    instance: SimpleDisplayer.DataHandle ¬ NIL] = {    b: BorderType;    r: RowType;    FOR b ¬ instance.head, b.next UNTIL b = NIL DO      FOR r ¬ b.row, r.next UNTIL r = NIL DO        proc[r.item, Write, instance]; ENDLOOP;      ENDLOOP;    };  EnumerateInvalidItems: PUBLIC PROC [    item: SimpleDisplayer.ItemHandle,    proc: PROC [      item: SimpleDisplayer.ItemHandle, instance: SimpleDisplayer.DataHandle],    instance: SimpleDisplayer.DataHandle] = {    b: BorderType;    r: RowType;    line: CARDINAL ¬ item.box.place.y / instance.lineHeight;    box: Window.Box ¬ item.box;    FOR b ¬ instance.head, b.next UNTIL b = NIL DO      IF b.line # line THEN LOOP;      FOR r ¬ b.row, r.next UNTIL r = NIL DO        tbox: Window.Box ¬ r.item.box;        IF r.item = item THEN LOOP;        IF ((tbox.place.x + tbox.dims.w) < box.place.x)          OR ((box.place.x + box.dims.w) < tbox.place.x) THEN LOOP;        proc[r.item, instance];        ENDLOOP;      RETURN;      ENDLOOP;    };  ItemMoved: PUBLIC PROC [    item: SimpleDisplayer.ItemHandle, newPlace: Window.Place,    instance: SimpleDisplayer.DataHandle] = {    RemoveFromSparseArray[item: item, instance: instance];    item.box.place ¬ newPlace;    AddItem[item: item, instance: instance];    << AddItem has the side effect of increasing the count of items so we have        to correct for this annoyance. >>    instance.itemCount ¬ instance.itemCount - 1;    };  LimitNumberProc1: FormSW.NumberNotifyProcType = {    itemPtr: SimpleDisplayer.ItemHandle = DILock[wh: sw];    endBitPosition: CARDINAL;    endBitPosition ¬      SELECT itemPtr.maxBitsOccupied FROM        >= 16 => itemPtr.maxBitsOccupied,        ENDCASE => 16;    IF (itemPtr.startingBitPostion + itemPtr.bitsOccupied) > endBitPosition THEN {      itemPtr.startingBitPostion ¬ endBitPosition - itemPtr.bitsOccupied;      FormSW.DisplayItem[sw: sw, index: index]};    IF itemPtr.startingBitPostion = endBitPosition THEN {      itemPtr.startingBitPostion ¬ endBitPosition - 1;      FormSW.DisplayItem[sw: sw, index: index]};    DIUnLock[wh: sw]};  LimitNumberProc2: FormSW.NumberNotifyProcType = {    itemPtr: SimpleDisplayer.ItemHandle = DILock[wh: sw];    startingBitPostion: CARDINAL ¬ itemPtr.startingBitPostion;    IF (itemPtr.bitsOccupied = 0) AND (itemPtr.maxBitsOccupied # 0) THEN {      itemPtr.bitsOccupied ¬ 1; FormSW.DisplayItem[sw: sw, index: index]};    IF itemPtr.bitsOccupied > itemPtr.maxBitsOccupied THEN {      itemPtr.bitsOccupied ¬ itemPtr.maxBitsOccupied;      FormSW.DisplayItem[sw: sw, index: index]};    DIUnLock[wh: sw];    LimitNumberProc1[      sw: sw, item: FormSW.FindItem[sw: sw, index: FormItems.startingBit.ORD],      index: FormItems.startingBit.ORD, oldValue: startingBitPostion]};  DILock: PROCEDURE [wh: Window.Handle]    RETURNS [itemHandle: SimpleDisplayer.ItemHandle] = INLINE {    RETURN Context.Acquire[type: propsContext, window: wh]};  DIShare: PROCEDURE [wh: Window.Handle]    RETURNS [itemHandle: SimpleDisplayer.ItemHandle] = INLINE {    RETURN Context.Find[type: propsContext, window: wh]};  DIUnLock: PROCEDURE [wh: Window.Handle] = INLINE {    Context.Release[type: propsContext, window: wh]};  }...LOGDisplayerItemHandler.mesa:		DEG       3-Mar-84 18:03:51Edited: DEG     : 22-Oct-84  1:21:54, fix bounds error problem.  
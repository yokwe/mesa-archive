-- File: OMF.mesa - last edit:-- FXB   .PA           11-Apr-85 10:12:35-- Copyright (C) 1984, 1985 by Xerox Corporation. All rights reserved.-- OMF.mesa  -- last edited by Dennis E. DEG      @ 10-Jan-84 11:19:44-- last edited by Frank FXB    @  26-Jul-84 16:27:41-- last edited by Frank FXB    @   3-Dec-84 10:16:44DIRECTORY  Environment USING [Byte],  Time USING [Packed];OMF: DEFINITIONS =  BEGIN  Byte: TYPE = Environment.Byte;  Error: ERROR [type: ErrorType];  ErrorType: TYPE = {    endOfFile, invalidChecksum, invalidHandle, invalidIndex, invalidType,    invalidRequest, malformedRecord, nameToLong, noSuchFile};  Handle: TYPE = LONG POINTER TO Object;  Object: TYPE;  OperationType: TYPE = {read, write};  RecordType: TYPE = {    blockDefinition, blockEnd, comment, debugSymbol, endRecord,    externalDefinition, fixUp, groupDefinition, lHeader, libraryDictionary,    libraryHeader, libraryModuleLocations, libraryModuleNames, lineNumber,    listOfNames, localSymbol, logicalEnumeratedData, logicalIteratedData,    moduleEnd, null, overlayDefinition, physicalEnumeratedData,    physicalIteratedData, publicDefinition, registerInitialization,    relocatableEnumeratedData, relocatableIteratedData, rHeader,    segmentDefinition, tHeader, typeDefinition};  --**********************************************************  AddressLength: TYPE = MACHINE DEPENDENT{short(0), long(1)};  AddressMode: TYPE = {physicalAddr, logicalAddr};  AlignType: TYPE = MACHINE DEPENDENT{    abs(0), relocByte(1), relocWord(2), relocPara(3), relocPage(4), unNamed(5),    LTL(6)};  Base: TYPE = RECORD [    groupIndex: NATURAL ¬ 0,    segmentIndex: NATURAL ¬ 0,    frameNumber: CARDINAL ¬ 0];  Based: TYPE = MACHINE DEPENDENT{notBased(0), based(1)};  BlockDefinition: TYPE = RECORD [    base: Base ¬ [],    blockInfo: BlockInformation ¬ [],    procedureInfo: ProcedureInformation ¬ [],    typeIndex: NATURAL ¬ 0];  BlockInformation: TYPE = RECORD [    name: LONG STRING ¬ NIL, offset: CARDINAL ¬ 0, length: CARDINAL ¬ 0];  CombineType: TYPE = MACHINE DEPENDENT{    dontCombin(0), memory(1), public(2), undef(3), type4(4), stack(5), common(6),    type7(7)};  CommentClass: TYPE = MACHINE DEPENDENT{    normal(0), copyright(1), firstIntelReserved(2), lastIntelReserved(155),    (255)};  CommentData: TYPE = RECORD [    purgeable: BOOLEAN ¬ TRUE,    list: BOOLEAN ¬ TRUE,    class: CommentClass ¬ normal,    comment: LONG STRING ¬ NIL];  DataSequence: TYPE = RECORD [    length: NATURAL ¬ 0, seq: PACKED SEQUENCE maxlength: NATURAL OF Byte];  DebugFrameMethod: TYPE = MACHINE DEPENDENT{    basedSymbol(0), extIndex(1), blokIndex(2), (7)};  DebugSymbols: TYPE = RECORD [    frameInformation: FrameInformation ¬ [method: basedSymbol[]],    entries: LONG POINTER TO SymbolsRecord ¬ NIL];  EightLeafDescriptor: TYPE = RECORD [    next: LONG POINTER TO EightLeafDescriptor ¬ NIL,    easyNice: PACKED ARRAY [0..8) OF BOOLEAN ¬ ALL[FALSE],    leafDescriptors: ARRAY [0..8) OF LONG POINTER TO LeafDescriptor ¬ ALL[NIL]];  EndType: TYPE = MACHINE DEPENDENT{    endOverlay(0), endBlock(1), illegal1(2), illegal2(3), firstUnused(4),    lastUnused(255)};  ExternalNamesSeq: TYPE = LONG POINTER TO ExternalNamesSeqBody;  ExternalNamesSeqBody: TYPE = RECORD [    length: NATURAL ¬ 0, seq: SEQUENCE maxlength: NATURAL OF ExternalNamesData];  ExternalNamesData: TYPE = RECORD [    extName: LONG STRING ¬ NIL,    typeIndex: NATURAL ¬ 0,    resolved: BOOLEAN ¬ FALSE];  FixupDataType: TYPE = MACHINE DEPENDENT RECORD [    fillerByte: Byte ¬ 0,    frameSpecMode: ThreadOrFixupMethod ¬ explicitly,    frame: [0..8) ¬ 0,    targetSpecMode: ThreadOrFixupMethod ¬ explicitly,    target: [0..8) ¬ 0];  FixupData: TYPE = RECORD [    next: LONG POINTER TO FixupData ¬ NIL,    body: SELECT fixupType: ThreadOrFixupType FROM      thread => [        indexORFrameNumber: CARDINAL ¬ 0,        thred: [0..4) ¬ 0,        method: SELECT type: ThreadType FROM          targetThread => [targetSpec: ThreadTargetSpecType ¬ segmentIndex],          frameThread => [frameSpec: FrameSpecType ¬ segmentIndex],          ENDCASE],      fixup => [locat: LocatType ¬ [], address: LogicalAddress ¬ []],      ENDCASE];  FrameInformation: TYPE = RECORD [    based: Based ¬ notBased,    addressLength: AddressLength ¬ short,    method: SELECT type: DebugFrameMethod FROM      basedSymbol => [base: Base ¬ []],      extIndex => [externalIndex: CARDINAL ¬ 0],      blokIndex => [blockIndex: CARDINAL ¬ 0],      ENDCASE];  FrameSpecRecord: TYPE = RECORD [    frameTag: SELECT type: ThreadOrFixupMethod FROM      explicitly => [frameMethod: FrameSpecType ¬ segmentIndex],      byThread => [frameThread: [0..4) ¬ 0],      ENDCASE];  FrameSpecType: TYPE = MACHINE DEPENDENT{    segmentIndex(0), groupIndex(1), externalIndex(2), frameNumber(3), location(4),    target(5), (7)};  GroupDefinitionSeq: TYPE = LONG POINTER TO GroupDefinitionSeqBody;  GroupDefinitionSeqBody: TYPE = RECORD [    length: NATURAL ¬ 0,    seq: SEQUENCE maxlength: NATURAL OF LONG POINTER TO GroupDefinitionData];  GroupDefinitionData: TYPE = RECORD [    groupNameIndex: NATURAL ¬ 0,    componentList: LONG POINTER TO GroupComponent ¬ NIL];  GroupComponent: TYPE = RECORD [    next: LONG POINTER TO GroupComponent ¬ NIL,    groupComponentDescriptor: SELECT type: GroupComponentEnumerated FROM      segmentIndexDef => [segmentIndex: NATURAL ¬ 0],      externalIndexDef => [externalIndex: NATURAL ¬ 0],      segmentClassOverlay => [        segmentNameIndex: NATURAL ¬ 0,        classNameIndex: NATURAL ¬ 0,        overlayNameIndex: NATURAL ¬ 0],      loadTimeLocatableGroup => [        maxGroupLength: LONG CARDINAL ¬ 0, groupLength: LONG CARDINAL ¬ 0],      absoluteGroup => [frameNumber: CARDINAL ¬ 0, offset: CARDINAL ¬ 0]      ENDCASE ¬ absoluteGroup[frameNumber: 0, offset: 0]];  GroupComponentEnumerated: TYPE = MACHINE DEPENDENT{    absoluteGroup(250), loadTimeLocatableGroup(251), segmentClassOverlay(253),    externalIndexDef(254), segmentIndexDef(255)};  IteratedBlock: TYPE = RECORD [    next: LONG POINTER TO IteratedBlock ¬ NIL,    repeatCount: NATURAL ¬ 0,    blockCount: NATURAL ¬ 0,    dataPtr: LONG POINTER TO DataSequence ¬ NIL];  LeafDescriptor: TYPE = RECORD [    leafTag: SELECT type: LeafType FROM      nullLeaf, repeatLeaf => NULL,      numericLeaf => [smallByte: Byte ¬ 0],      cardinal => [cardinalValue: CARDINAL ¬ 0],      name => [nameString: LONG STRING ¬ NIL],      index => [indexValue: CARDINAL ¬ 0],      threeByte => [threeByteValue: LONG CARDINAL ¬ 0],      signedByte => [signedByteValue: INTEGER ¬ 0],      integer => [integerValue: INTEGER ¬ 0],      longCardinal => [longCardinalValue: LONG CARDINAL ¬ 0],      ENDCASE];  LeafType: TYPE = {    nullLeaf, numericLeaf, cardinal, name, index, threeByte, repeatLeaf,    signedByte, integer, longCardinal};  LineNumberData: TYPE = RECORD [    base: Base ¬ [],    numberOfEntries: CARDINAL ¬ 0,    seq: SEQUENCE maxlength: NATURAL OF LineNumberEntry];  LineNumberEntry: TYPE = RECORD [    lineNumber: NATURAL ¬ 0, lineNumberOffset: CARDINAL ¬ 0];  ListOfNamesData: TYPE = RECORD [    length: CARDINAL ¬ 0, seq: SEQUENCE maxlength: NATURAL OF LONG STRING];  LocalSymbols: TYPE = RECORD [base: Base ¬ [], entries: SymbolsRecord ¬ []];  LocatType: TYPE = MACHINE DEPENDENT RECORD [    type: ThreadOrFixupType ¬ fixup,    fixupMode: MACHINE DEPENDENT{selfRelative(0), segmentRelative(1)} ¬      selfRelative,    targetDispLen: MACHINE DEPENDENT{twoBytes(0), threeBytes(1)} ¬ twoBytes,    -- 3 byte not used    loc: LocType ¬ lobyte,    dataRecOffset: [0..1024) ¬ 0];  LocType: TYPE = MACHINE DEPENDENT{    lobyte(0), offset(1), base(2), pointer(3), hibyte(4)};  LogicalAddress: TYPE = RECORD [    frameDatum: CARDINAL ¬ 0,    targetDatum: CARDINAL ¬ 0,    targetDisplacement: LONG CARDINAL ¬ 0,    frameSpec: FrameSpecRecord ¬ [frameTag: explicitly[]],    targetSpec: TargetSpecRecord ¬ [targetTag: explicitly[]]];  LogicalEnumeratedData: TYPE = RECORD [    segmentIndex: NATURAL ¬ 0,    enumeratedDataOffset: LONG CARDINAL ¬ 0,    dataPtr: LONG POINTER TO DataSequence ¬ NIL];  LogicalIteratedData: TYPE = RECORD [    segmentIndex: NATURAL ¬ 0,    iteratedDataOffset: LONG CARDINAL ¬ 0,    iteratedDataBlockPtr: LONG POINTER TO IteratedBlock ¬ NIL];  LTLData: TYPE = MACHINE DEPENDENT RECORD [    fillerByte: Byte ¬ 0,    groupMember: BOOLEAN ¬ FALSE,    unassigned: [0..64) ¬ 0,    bigSegmentMaxlength: BOOLEAN ¬ FALSE];  ModuleEndData: TYPE = RECORD [    moduleType: ModuleType ¬ [],    startAddress: SELECT type: AddressMode FROM      logicalAddr => [address: LogicalAddress ¬ []],      physicalAddr => [frameNumber: CARDINAL ¬ 0, offset: LONG CARDINAL ¬ 0]      ENDCASE ¬ logicalAddr[]];  ModuleType: TYPE = MACHINE DEPENDENT RECORD [    fillerByte: Byte ¬ 0,    isMainModule: BOOLEAN ¬ FALSE,    hasStartAddress: BOOLEAN ¬ FALSE,    unassigned: [0..32) ¬ 0,    addressMode: AddressMode ¬ physicalAddr];  OverlayDefinitionSeq: TYPE = LONG POINTER TO OverlayDefinitionSeqBody;  OverlayDefinitionSeqBody: TYPE = RECORD [    length: NATURAL ¬ 0,    seq: SEQUENCE maxlength: NATURAL OF LONG POINTER TO OverlayDefinitionData];  OverlayDefinitionData: TYPE = RECORD [    overlayName: LONG STRING ¬ NIL,    overlayLocation: LONG CARDINAL ¬ 0,    sharedAdjacent: MACHINE DEPENDENT RECORD [      undefined: [0..64) ¬ 0,      shared: BOOLEAN ¬ FALSE,      adjacent: BOOLEAN ¬ FALSE,      fillerByte: Byte ¬ 0],    sharedOverlayIndex: NATURAL ¬ 0,    adjacentOverlayIndex: NATURAL ¬ 0];  PhysicalEnumeratedData: TYPE = RECORD [    frameNumber: CARDINAL ¬ 0,    offset: Byte ¬ 0,    dataPtr: LONG POINTER TO DataSequence ¬ NIL];  PhysicalIteratedData: TYPE = RECORD [    frameNumber: CARDINAL ¬ 0,    offset: Byte ¬ 0,    iteratedDataBlockPtr: LONG POINTER TO IteratedBlock ¬ NIL];  ProcedureInformation: TYPE = RECORD [    procedureDefinition: BOOLEAN ¬ FALSE,    isLongProcedure: BOOLEAN ¬ FALSE,    returnAddress: LONG CARDINAL ¬ 0];  PublicNamesData: TYPE = RECORD [    publicBase: Base ¬ [],    next: LONG POINTER TO PublicNamesData ¬ NIL,    namesList: LONG POINTER TO PublicNamesNode ¬ NIL];  PublicNamesNode: TYPE = RECORD [    publicName: LONG STRING ¬ NIL,    publicOffset: LONG CARDINAL ¬ 0,    typeIndex: NATURAL ¬ 0,    next: LONG POINTER TO PublicNamesNode ¬ NIL];  RegIntLType: TYPE = {baseAndOffset, logicalAddr};  RegisterInitializationData: TYPE = RECORD [    next: LONG POINTER TO RegisterInitializationData ¬ NIL,    registerType: RegisterInit ¬ [],    registerContents: SELECT type: RegIntLType FROM      logicalAddr => [address: LogicalAddress ¬ []],      baseAndOffset => [base: Base ¬ [], registerOffset: CARDINAL ¬ 0]      ENDCASE];  RegisterInit: TYPE = MACHINE DEPENDENT RECORD [    fillerByte: Byte ¬ 0,    registerID: {CSandIP, SSandSP, DS, ES} ¬ CSandIP,    unassigned: [0..64) ¬ 0];  RelocatableEnumeratedData: TYPE = RECORD [    base: Base ¬ [],    enumeratedDataOffset: LONG CARDINAL ¬ 0,    iteratedDataBlockPtr: LONG POINTER TO DataSequence ¬ NIL];  RelocatableIteratedData: TYPE = RECORD [    base: Base ¬ [],    offset: LONG CARDINAL ¬ 0,    iteratedDataBlockPtr: LONG POINTER TO IteratedBlock ¬ NIL];  SegmentDefinitionSeq: TYPE = LONG POINTER TO SegmentDefinitionSeqBody;  SegmentDefinitionSeqBody: TYPE = RECORD [    length: NATURAL ¬ 0,    seq: SEQUENCE maxlength: NATURAL OF LONG POINTER TO SegmentDefinitionData];  SegmentDefinitionData: TYPE = RECORD [    ACBP: MACHINE DEPENDENT RECORD [      align: AlignType ¬ abs,      combin: CombineType ¬ dontCombin,      exactly64K: BOOLEAN ¬ FALSE,  -- B      pageResident: BOOLEAN ¬ FALSE,  -- P      unused: Byte ¬ 0],    offset: CARDINAL ¬ 0,    frameNumber: CARDINAL ¬ 0,    segmentLength: LONG CARDINAL ¬ 0,    segmentNameIndex: NATURAL ¬ 0,    classNameIndex: NATURAL ¬ 0,    overlayNameIndex: NATURAL ¬ 0,    ltlData: LTLData ¬ [],    maxSegmentLength: LONG CARDINAL ¬ 0,    groupOffset: LONG CARDINAL ¬ 0];  Specification: TYPE = MACHINE DEPENDENT{primary(0), secondary(1)};  SymbolsRecord: TYPE = RECORD [    next: LONG POINTER TO SymbolsRecord ¬ NIL,    symbol: LONG STRING ¬ NIL,    offset: CARDINAL ¬ 0,    typeIndex: CARDINAL ¬ 0];  TargetSpecRecord: TYPE = RECORD [    targetTag: SELECT type: ThreadOrFixupMethod FROM      explicitly => [targetMethod: TargetSpecType ¬ segmentIndexWithDisp],      byThread => [        specification: Specification ¬ primary, targetThread: [0..4) ¬ 0],      ENDCASE];  TargetSpecType: TYPE = MACHINE DEPENDENT{    segmentIndexWithDisp(0), groupIndexWithDisp(1), externalIndexWithDisp(2),    frameNumberWithDisp(3), segmentIndex(4), groupIndex(5), externalIndex(6),    frameNumber(7)};  ThreadOrFixupMethod: TYPE = MACHINE DEPENDENT{explicitly(0), byThread(1)};  ThreadOrFixupType: TYPE = MACHINE DEPENDENT{thread(0), fixup(1)};  ThreadTargetSpecType: TYPE = MACHINE DEPENDENT{    segmentIndex(0), groupIndex(1), externalIndex(2), frameNumber(3)};  ThreadType: TYPE = MACHINE DEPENDENT{targetThread(0), frameThread(1)};  TypeDefinitionSeq: TYPE = LONG POINTER TO TypeDefinitionSeqBody;  TypeDefinitionSeqBody: TYPE = RECORD [    length: NATURAL ¬ 0, seq: SEQUENCE maxlength: NATURAL OF TypeDefinition];  TypeDefinition: TYPE = RECORD [    name: LONG STRING ¬ NIL,    eightLeafDescriptor: LONG POINTER TO EightLeafDescriptor ¬ NIL];  --*******************************************************************  << GetXRecord: PROCEDURE[handle: Handle]    RETURNS[LONG POINTER TO xRecord];  PutXRecord: PROCEDURE[LONG POINTER TO xRecord, handle: Handle];  >>  AdvanceToNextRecord: PROCEDURE [handle: Handle] RETURNS [endOfFile: BOOLEAN];  GetHandle: PROCEDURE [    operation: OperationType, fileName: LONG STRING, extension: LONG STRING ¬ NIL,    heap: UNCOUNTED ZONE] RETURNS [handle: Handle, create: Time.Packed];  GetRecordType: PROCEDURE [handle: Handle] RETURNS [recordType: RecordType];  ReleaseHandle: PROCEDURE [handle: Handle] RETURNS [nilHandle: Handle];  GetBlockDefinition: PROCEDURE [handle: Handle]    RETURNS [blockPointer: LONG POINTER TO BlockDefinition];  GetComment: PROCEDURE [handle: Handle]    RETURNS [commentPtr: LONG POINTER TO CommentData];  GetDebugSymbols: PROCEDURE [handle: Handle]    RETURNS [debugSymbolsPtr: LONG POINTER TO DebugSymbols];  GetEndRecord: PROCEDURE [handle: Handle] RETURNS [endType: EndType];  GetExternalNames: PROCEDURE [handle: Handle]    RETURNS [externalNamesPtr: ExternalNamesSeq];  GetFixup: PROCEDURE [handle: Handle]    RETURNS [fixupPtr: LONG POINTER TO FixupData];  GetGroupDefinition: PROCEDURE [handle: Handle]    RETURNS [groupDefinitionPtr: LONG POINTER TO GroupDefinitionData];  GetLineNumber: PROCEDURE [handle: Handle]    RETURNS [lineNumberPtr: LONG POINTER TO LineNumberData];  GetListOfNames: PROCEDURE [handle: Handle]    RETURNS [nameList: LONG POINTER TO ListOfNamesData];  GetLModuleName: PROCEDURE [handle: Handle] RETURNS [lName: LONG STRING];  GetLocalSymbols: PROCEDURE [handle: Handle]    RETURNS [localSymbolsPtr: LONG POINTER TO LocalSymbols];  GetLogicalEnumeratedData: PROCEDURE [handle: Handle]    RETURNS [logicalEnumeratedDataPtr: LONG POINTER TO LogicalEnumeratedData];  GetLogicalIteratedData: PROCEDURE [handle: Handle]    RETURNS [logicalIteratedDataPtr: LONG POINTER TO LogicalIteratedData];  GetModuleEnd: PROCEDURE [handle: Handle]    RETURNS [moduleEndRecordPtr: LONG POINTER TO ModuleEndData];  GetOverlay: PROCEDURE [handle: Handle]    RETURNS [overlayPtr: LONG POINTER TO OverlayDefinitionData];  GetPhysicalEnumeratedData: PROCEDURE [handle: Handle]    RETURNS [physicalEnumeratedDataPtr: LONG POINTER TO PhysicalEnumeratedData];  GetPhysicalIteratedData: PROCEDURE [handle: Handle]    RETURNS [physicalIteratedDataPtr: LONG POINTER TO PhysicalIteratedData];  GetPublicNames: PROCEDURE [handle: Handle]    RETURNS [publicNamesPtr: LONG POINTER TO PublicNamesData];  GetRegisterInitialization: PROCEDURE [handle: Handle]    RETURNS [registerInitPtr: LONG POINTER TO RegisterInitializationData];  GetRelocatableEnumeratedData: PROCEDURE [handle: Handle]    RETURNS [      relocatableEnumeratedDataPtr: LONG POINTER TO RelocatableEnumeratedData];  GetRelocatableIteratedData: PROCEDURE [handle: Handle]    RETURNS [relocatableIteratedDataPtr: LONG POINTER TO RelocatableIteratedData];  GetSegmentDefinition: PROCEDURE [handle: Handle]    RETURNS [segmentDefinitionPtr: LONG POINTER TO SegmentDefinitionData];  GetTModuleName: PROCEDURE [handle: Handle] RETURNS [tName: LONG STRING];  GetTypeDefinition: PROCEDURE [handle: Handle]    RETURNS [typeDefinitionPtr: LONG POINTER TO TypeDefinition];  PutBlockDefinition: PROCEDURE [    handle: Handle, blockPointer: LONG POINTER TO BlockDefinition];  PutBlockEnd: PROCEDURE [handle: Handle];  PutComment: PROCEDURE [commentPtr: LONG POINTER TO CommentData, handle: Handle];  PutDebugSymbols: PROCEDURE [    debugSymbolsPtr: LONG POINTER TO DebugSymbols, handle: Handle];  PutEndRecord: PROCEDURE [endType: EndType, handle: Handle];  PutExternalNames: PROCEDURE [    externalNamesPtr: ExternalNamesSeq, handle: Handle];  PutFixup: PROCEDURE [fixupPtr: LONG POINTER TO FixupData, handle: Handle];  PutGroupDefinition: PROCEDURE [    groupDefinitionPtr: LONG POINTER TO GroupDefinitionData, handle: Handle];  PutLineNumber: PROCEDURE [    lineNumberPtr: LONG POINTER TO LineNumberData, handle: Handle];  PutListOfNames: PROCEDURE [    nameList: LONG POINTER TO ListOfNamesData, handle: Handle];  PutLocalSymbols: PROCEDURE [    localSymbolsPtr: LONG POINTER TO LocalSymbols, handle: Handle];  PutLModuleName: PROCEDURE [handle: Handle, lName: LONG STRING];  PutLogicalEnumeratedData: PROCEDURE [    logicalEnumeratedDataPtr: LONG POINTER TO LogicalEnumeratedData,    handle: Handle];  PutLogicalIteratedData: PROCEDURE [    logicalIteratedDataPtr: LONG POINTER TO LogicalIteratedData, handle: Handle];  PutModuleEnd: PROCEDURE [    handle: Handle, moduleEndRecordPtr: LONG POINTER TO ModuleEndData];  PutOverlay: PROCEDURE [    overlayPtr: LONG POINTER TO OverlayDefinitionData, handle: Handle];  PutPhysicalEnumeratedData: PROCEDURE [    physicalEnumeratedDataPtr: LONG POINTER TO PhysicalEnumeratedData,    handle: Handle];  PutPhysicalIteratedData: PROCEDURE [    physicalIteratedDataPtr: LONG POINTER TO PhysicalIteratedData,    handle: Handle];  PutPublicNames: PROCEDURE [    publicNamesPtr: LONG POINTER TO PublicNamesData, handle: Handle];  PutRegisterInitialization: PROCEDURE [    handle: Handle, registerInitPtr: LONG POINTER TO RegisterInitializationData];  PutRelocatableEnumeratedData: PROCEDURE [    relocatableEnumeratedDataPtr: LONG POINTER TO RelocatableEnumeratedData,    handle: Handle];  PutRelocatableIteratedData: PROCEDURE [    relocatableIteratedDataPtr: LONG POINTER TO RelocatableIteratedData,    handle: Handle];  PutSegmentDefinition: PROCEDURE [    segmentDefinitionPtr: LONG POINTER TO SegmentDefinitionData, handle: Handle];  PutTModuleName: PROCEDURE [handle: Handle, tName: LONG STRING];  PutTypeDefinition: PROCEDURE [    handle: Handle, typeDefinitionPtr: LONG POINTER TO TypeDefinition];  END...    LOG  created by Dennis E. DEG      @  3-Nov-83 14:41:12  edited by Dennis E. DEG      @  9-Jan-84  9:11:07: changes made to switch from OVERLAID records to bound variant records.  edited by Dennis E. DEG      @  9-Jan-84 22:40:18: add more records. 
-- File: IOPBermuda.txt - last edit:-- FXB   .PA            5-Jun-85  8:57:40-- Copyright (C) 1985 by Xerox Corporation. All rights reserved.IOPBermuda consists of MESA code running on a Dandelion and 80186 assembly language running on the Dove IOP.  The two machines communicate through the Song Board parallel port.  This document describes the IOPBermuda tool interface which runs in XDE.1.1 How to use IOPBermuda The 80186 debugger includes both PC and IOP debugger windows each consisting of four subwindows: an upper form subwindow, a file subwindow which acts as a log, a lower form subwindow, and a panel subwindow.  See Figure 1 (Bitmap of IOPBermuda window in not yet complete Star document) for an illustration of the subwindows discussed below. 1.1.1  The Upper Form Subwindow  The upper form subwindow consists of status flags and miscellaneous control functions.  The top row is a symbolic representation of the 80186 Status word and is currently readOnly.   "State" is the current state of the processor, as follows:    - Dead: the debuggee has not been booted or has not responded to a command - Booted: the debuggee has been initialized and is waiting for a command from the debugger - Halted: the debuggee is waiting for a command from the debugger - Running: the debuggee is running test code - Break: the debuggee hit a breakpoint and is waiting for a command - SingleStep: the debuggee has executed a single step and is waiting for a command  If the current state is Dead or Running, then the only possible operations are boot! and STOP!  All other operations are disallowed in these 2 states.   To read the top elements of the stack into the log, file bug "Stack!"  The number of stack elements displayed is given by Length.  "Instructions!" evaluates the current selection as an address for the appropriate processor and displays Length disassembled instructions starting at that address.  To initialize the Panel Subwindow with the values of the 80186 registers bug "InitPanel".To initialize the PC debugger bug "DebugPC!".For CP Debugging: If you want to turn off umbilical polling in order to run CPBermuda with the A/B switched umbilical, select "off" on the "on/off" control.  IOPBermuda debugging is disabled while "off" is selected.  1.1.2  The Log File Subwindow  The log file Subwindow provides a record of the debugging session; its contents are stored in IOPDebugger.log and PCDebugger.log for the IOP debugger and the PC debugger respectively.1.1.3  The Lower Form SubwindowThe lower form subwindow provides the primary debugging commands.  The commands in this window are grouped according to function.  The group's name (Load, Break, Panel, or IO) precedes the group's commands.Before doing anything else, initialize the umbilical by bugging "Boot!". Load: The (Load) "All!" command means LoadAll! (both code and symbols).   To load an object file into the debuggee, select the name of the file and bug (Load) All!.  This will also add any symbols in the object file into the symbol table.   To only load  the code from an object file, bug (Load) Code!.  To only load the symbols from an object file, bug (Load) Symbols!. Break: To set a breakpoint, select a breakpoint address, either as an absolute address or as a symbol + offset and bug (Break) Set!.  To clear a break, select an address and bug (Break) Clear!.  (Break) List! lists the current breaks set and (Break) ClearAll! clears all breakpoints.  Breakpoints are only set while test code is running.  If you read an address where a breakpoint is set you will not find a breakpoint instruction.Panel: (Panel) "Init!" causes the 80186 registers to be displayed at the top of the panel.  (Panel) "Copy!" causes the Panel to be copied into the log.  (Panel) Refresh! causes the Panel subwindow to be updated.  That is, all registers and memory addresses displayed in the Panel are read and the current values are shown in the panel.  IO: To read an I/O port, place the hexadecimal address of the port in the "Port:" entry, select byte or word addressing and bug (IO) "Read!".  The value read is displayed in the "Value:" field.  "What!" evaluates the expression in the current selection and displays its value in the log."Typein:" is used by the panel subwindows discussed below.   1.1.4  The Panel SubwindowThe Panel subwindow is a rectangular array of tiles that display the name of a register or a memory address and its contents.  A tile consists of three fields.  From left to right the fields are flag, left field, and right field.  A tilde, "~", in the flag means the data in the right field is invalid.  An asterisk, "*", means the right field changed since the register or memory address was last read.  When the cursor enters a panel, Burdock inverts the tile field occupied by the cursor.  Most panel operations take the current selection as the argument.  If the current selection is empty, then "Typein:" is used as the argument.  IOPBermuda evaluates arithmetic expressions from left to right using 32 bit arithmetic.  No parentheses, no operator precedence, and no unary operations are allowed.  Legal operators are addition (+), subtraction (-), multiplication(*), division (/),  remainder (\), and segment plus offset (:), x:y => x*16 + y. To display a register, select its name, move the cursor to the left field of a tile, and click POINT.  The register name and its contents will then appear in the tile.  To alter the contents of a register, move the cursor over the right field of a register tile and click POINT.  The current selection or TypeIn will be evaluated as a word value and stored in the register.  When displaying memory in the panel, an address type parameter, "Address", is used if the address type is not already specified in the argument string.  Specify the address type by beginning the argument string with either ".I" (IOPLogical), ".P" (PCLogical) ".R" (real => 24-bit extended bus), or ".V" (vm => Mesa virtual word address).The PC and IOP debuggers have separate symbol tables.  When you look up a symbol, the symbol table corresponding to the address type for that window is searched.  When you look up a PC symbol, the address type in the window must be set to pc.    This was done so that you could have a given label in both address spaces with possibly different values.  You can reset the symbol tables separately; Bugging ResetSymbols! in the PC window only resets the PC's symbol table.You specify word- or byte-wide memory data using the "Data" enumerated parameter.  The data type of a tile is fixed until the left field (address) of the tile is changed.Clicking ADJUST over text in an inverted tile moves the text to the TypeIn. To increment an address, move the cursor over the left field of a tile; hold down the left shift key and click POINT.  If the tile is not empty, IOPBermuda increments the left field of the tile and displays the contents of that register in the right field.  If the tile is empty, IOPBermuda uses the TypeIn rather than the tile. Decremen by clicking ADJUST while holding the left shift key.  Clicking shift-CHORD over an empty left field clears the column below the tile.  If the left field was not clear, Burdock fills the column below by successively incrementing the left field of the original tile.  If the "numbers" BOOLEAN is TRUE, then the column will be filled with numeric addresses; otherwise, the addresses will be shown as symbol plus offset expressions.  When the "rows" parameter is specified, only the indicated number of rows are filled or cleared, rather than the entire column.   Clicking shift-CHORD over a right field copies that right field down the column.  You can alter the size of the panel using the the standard XDE mechanisms.  When you shrink the window, any tiles which disappear are thrown away.  When the window grows, all newly uncovered tiles are blank.  Making the window tiny does not disturb any tile.1.2  Command File ProcessingIOPBermuda can be driven by command files.  To use this facility, select the name of a command file (".bermuda" is the default extension) and bug CommandFile!.A tile definition statement fills a panel tile and has one of two forms 	TileName = PanelLoc! LeftField ¬ RightField			or	TileLoc! LeftField ¬ RightField.TileName is an identifier used to name a tile in conditionals.PanelLocs are an ordered pair of hex constants indicating row and column.  IOP[0, 0] is the upper left tile of the IOP Panel.  PC[11, 2] indicates the lower right hand tile of the PC Panel.  A TileLoc is either a TileName or a PanelLoc.  LeftField and RightField are the initial contents of the tile.  They can be any strings that do not contain the characters left arrow (¬), colon (:), semicolon (;), quote ("), equal (=), sharp (#), greater than (>), less than (<), or open bracket ([).  the left arrow and Rightfield go together and are optional.To read a memory location or register and display it in a tile at a given row and column use the following syntax:	IOP[row, column]! LeftFieldTo write into a memory location or register defined by the string LeftField type:	IOP[row, column]! LeftField _ RightFieldA conditional has the following form:	IF operand relational operand {statements};  The Relationals include less than (<), less than or equal (<=), equal (=), not equal (#), greater than (>), and greater than or equal (>=).  An Operand is either a hex constant or a TileName.  IOPBermuda evaluates relations using integer sixteen bit arithmetic.  If the condition is FALSE then the statements in the curly brackets are skipped.  If the condition is TRUE IOPBermuda executes the statments.  Conditions can be nested to any level.A function call consists of the function name followed by its parameters in square brackets.  A function with no parameters still requires square brackets after the function name.  Use a comma (,) to separate the parameters.  Any parameter which has characters that might confuse the scanner must be enclosed by double quotes (").AlterAddress[TileName, string];	appends string to the left half of the tile and redisplays the tile	BootIOP[];		boots the IOP BreakIOP[string];	sets an IOP breakpoint at the specified locationBreakPC[string];	set a PC breakpoint	ClearIOPPanel[];	clears the IOP PanelClearPCPanel[];		clears the PC PanelContinueIOP[timeout];	continues the IOP, timeout is in milliseconds	If timeout is specified then there is a 4 second wait after the state 	change to   allow for state transition, timeout = 0 => don't stopCopyIOPPanel[];		copies IOP Panel into IOP logCopyPCPanel[];		copies PC Panel into CP logGOTO[label];		goes to label in command fileIF condition {...};	conditional executionIOP[number, number];	IOP tile location row and columnInitIOPPanel[];		initialize the IOP Panel with register values at topInitPCPanel[];		initialize the PC Panel with register values at topLoadIOP[string];	loads IOP code and symbols ( default ".lm" or ".loc" extension)	LoadIOPCodeOnly[string];	loads IOP code, ignores symbolsLoadIOPSymbols[string];	loads IOP symbols without loading the codeLoadPC[string];		loads PC code and symbols ( default ".lm" or ".loc" extension)	LoadPCCodeOnly[string];	loads PC code, ignores symbolsLoadPCSymbols[string];	loads PC symbols without loading the codePC[number, number];	PC tile location row and columnReadIO[port];		reads IOP IO using IOP debugger's data typeResetIOPSymbols[];	clears IOP Debugger's symbol TableResetPCSymbols[];	clears PC Debugger's symbol TableSetIOPAddressType[addressType];  sets IOP Debugger's address type, argument is 		either iop, pc, real, or vmSetPCAddressType[addressType];  sets PC Debugger's address type, argument is 		either iop, pc, real, or vmSetDataType[dataType]; 			sets IOP Debugger's data type where 	dataType is word or byteSetPCDataType[dataType];		sets PC Debugger's data type where 	dataType is word or byteStopIOP[];		stops the IOPStopPC[];		stops the PCUnbreakIOP[string];	clears the specified IOP break pointUnbreakPC[string];	clears the specified PC break pointWait[mSecs];		do Process.Pause for specified number of millisecondsWrite[string];		write string into the log fileWriteIO[data, port];	Write IOP IO using IOP debugger's data typeWriteLine[string];	writes string followed by a CR into log fileWriteLoc[TileName];	writes right half of tile into the log fileWriteTime[];		writes time into the log fileVertical bars are used as comment delimitersThe following is a sample command file which could be used for OPIE testing:|file: sample.bermuda|BootIOP[];InitIOPPanel[];LoadIOP[system.loc];BreakIOP[badnews];IOP[0, 1]! CS _ 1000;	| [0, 1] is the location for CS set by InitIOPPanel |IOP[0, 2]! IP _ 0;ContinueIOP[];1.3  PC Debugger implementationPC breakpointing and Single-stepping are implemented by having the IOTrapper execute an IOP breakpoint.  When a PC debugger event occurs, the IOP will hit a breakpoint.  Whenever the IOP hits a breakpoint, it checks the value of a byte in PC memory to see if a PC event has occurred.  If so, it notifies the PC debugger window, the PC registers are read from PC memory, and the PC Debugger reports a state change.1.4  Caveatso  You cannot Load PC code or use non-IOPLogical addresses until the RAM based debugger contained in RHLink is initialized.  You must first:   1)  Load a configuration which        a) contains RHLink.lnk and OPIE.lnk,       b) initializes the Umbilical Handler; that is,                                  %*DEFINE(HandlersLinked)(%Handler(Umbilical))        c) sets UmbilicalHandlerLoaded to TRUE; for example, PCESysD.loc .          2)  Set CS:IP to the "initialization" label in OPIE, and Continue until        OPIE initialization is complete.  The vectors for the Umbilical Receive       Interrupt (at 84H), Umbilical Send Interrupt (at 88H),        Breakpoint interrupt, SingleStep interrupt, and NMI interrupt        should all point to RAM rather than ROM (0FC00-0FFFFFH)          3)  You must repeat this procedure whenever you boot since booting resets all       of the interrupt vectors.              o While a command file is running, attempting to use any other IOPBermuda functions can lead to unpredictable results. o Continuing from breakpoints at software interrupt instructions doesn't work as it should.  When continuing from a breakpoint, the broken instruction is single stepped, then the break opcode is replaced.  Unfortunately, single-stepping the INT instruction is flakey.  Setting breakpoints on interrupt instructions is not recommended. (Fixing this problem requires a change to the PROMs)o  Under some conditions when executing breakpoints in OPIE code, the breakpoint notification is not received correctly by the debugger. If you bug STOP! you will be at DebGetInByte or DebPutOutByte.  There is only one known case of this happening.  If you have encountered this situation, please describe the circumstances.1.5 Minor Bugs o  Quickly double clicking Step! causes the message "80186 is running" to be displayed several times.  There don't appear to be any adverse effects other than confusing the user.o  Clicking Continue! then Stop! very quickly can cause you to Halt in the debugger IOP code.o  Loading Iterated Data records doesn't work for nested iterations.  Data Declarations such as   	IteratedData      DB  3  DUP (4 DUP (5 DUP (1, 6 DUP (0))))    will not be loaded correctly.o  Bermuda uses all characters in a label whereas the Intel assembler only uses the first 31 characters.o  If you have specified a start address in your source code, then the CS and IP will be initialized to that address when you load your code.
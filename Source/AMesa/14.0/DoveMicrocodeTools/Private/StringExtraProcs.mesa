-- StringExtraProcs.mesa, HGM, 12-Nov-83 17:10:37DIRECTORY  Ascii USING [CR, LF, FF, SP, TAB],  StringExtras USING [BreakProc],  String USING [SubString];StringExtraProcs: PROGRAM  EXPORTS StringExtras =  BEGIN  InvalidHexString: PUBLIC ERROR = CODE;  CheckHexString: PUBLIC PROCEDURE [s: LONG STRING] RETURNS [v: CARDINAL _ 0] =    BEGIN    IF s = NIL THEN ERROR InvalidHexString;    IF s.length > 4 THEN ERROR InvalidHexString;    FOR i: CARDINAL IN [0..s.length) DO      SELECT s[i] FROM        IN ['0..'9] => v _ v*16 + (s[i] - '0);        IN ['A..'F] => v _ v*16 + (s[i] - 'A + 10);        IN ['a..'f] => v _ v*16 + (s[i] - 'a + 10);        ENDCASE => ERROR InvalidHexString;      ENDLOOP    END;  CheckLongHexString: PUBLIC PROCEDURE [s: LONG STRING] RETURNS [v: LONG CARDINAL _ 0] =    BEGIN    IF s = NIL THEN ERROR InvalidHexString;    IF s.length > 8 THEN ERROR InvalidHexString;    FOR i: CARDINAL IN [0..s.length) DO      SELECT s[i] FROM        IN ['0..'9] => v _ v*16 + (s[i] - '0);        IN ['A..'F] => v _ v*16 + (s[i] - 'A + 10);        IN ['a..'f] => v _ v*16 + (s[i] - 'a + 10);        ENDCASE => ERROR InvalidHexString;      ENDLOOP    END;  StringToCardinal: PUBLIC PROCEDURE [s: LONG STRING] RETURNS [ok: BOOLEAN, v: CARDINAL] =    BEGIN    base: CARDINAL _ 16;    length: CARDINAL _ s.length;    ok _ FALSE;    v _ 0;    IF length > 2 AND s[length-2] = '' THEN      BEGIN      SELECT s[length-1] FROM        'b, 'B => base _ 8;	'd, 'D => base _ 10;	'x, 'X => base _ 16;	ENDCASE => RETURN;      length _ length - 2;      END;    FOR i: CARDINAL IN [0..length) DO      IF v*base/base # v THEN RETURN; -- Overflowed      SELECT s[i] FROM        IN ['0..'9] => v _ v*base + (s[i] - '0);        IN ['A..'F] => v _ v*base + (s[i] - 'A + 10);        IN ['a..'f] => v _ v*base + (s[i] - 'a + 10);        ENDCASE => RETURN;      ENDLOOP;    ok _ TRUE;    END;  StringToLongCardinal: PUBLIC PROCEDURE [s: LONG STRING] RETURNS [ok: BOOLEAN, v: LONG CARDINAL] =    BEGIN    base: CARDINAL _ 16;    length: CARDINAL _ s.length;    ok _ FALSE;    v _ 0;    IF length > 2 AND s[length-2] = '' THEN      BEGIN      SELECT s[length-1] FROM        'b, 'B => base _ 8;	'd, 'D => base _ 10;	'x, 'X => base _ 16;	ENDCASE => RETURN;      length _ length - 2;      END;    FOR i: CARDINAL IN [0..length) DO      IF v*base/base # v THEN RETURN; -- Overflowed      SELECT s[i] FROM        IN ['0..'9] => v _ v*base + (s[i] - '0);        IN ['A..'F] => v _ v*base + (s[i] - 'A + 10);        IN ['a..'f] => v _ v*base + (s[i] - 'a + 10);        ENDCASE => RETURN;      ENDLOOP;    ok _ TRUE;    END;  RemoveLeadingBlanks: PUBLIC PROCEDURE [s: LONG STRING] =    BEGIN    i: CARDINAL;    FOR i IN [0..s.length) DO      IF ~BlankCharacter[s[i]] THEN EXIT REPEAT FINISHED => i _ s.length ENDLOOP;    IF i # 0 THEN FOR j: CARDINAL IN [i..s.length) DO s[j - i] _ s[j] ENDLOOP;    s.length _ s.length - i    END;  RemoveTrailingBlanks: PUBLIC PROCEDURE [s: LONG STRING] =    BEGIN    IF s.length = 0 THEN RETURN;    FOR i: CARDINAL DECREASING IN [0..s.length - 1] WHILE BlankCharacter[s[i]] DO      s.length _ s.length - 1 ENDLOOP    END;  BlankCharacter: PUBLIC PROCEDURE [c: CHARACTER] RETURNS [BOOLEAN] =    BEGIN    RETURN[      SELECT c FROM        Ascii.FF, Ascii.SP, Ascii.CR, Ascii.LF, Ascii.TAB => TRUE,        ENDCASE => FALSE]    END;  TrimSubString: PUBLIC PROCEDURE [ss: String.SubString] RETURNS [CARDINAL] =    BEGIN    i: CARDINAL;    IF ss.length = 0 THEN RETURN[0];    --remove leading blanks--    FOR i IN [ss.offset..ss.offset + ss.length) DO      IF ~BlankCharacter[ss.base[i]] THEN EXIT      REPEAT FINISHED => --all blanks-- RETURN[ss.length _ 0]      ENDLOOP;    IF (ss.length _ ss.length - (i - ss.offset)) = 0 THEN RETURN[0];    ss.offset _ i;    --remove trailing blanks--    FOR i DECREASING IN [ss.offset..ss.offset + ss.length) DO      IF ~BlankCharacter[ss.base[i]] THEN EXIT REPEAT FINISHED => ERROR ENDLOOP;    RETURN[ss.length _ ss.length - (ss.offset + ss.length - 1 - i)]    END;  TrimString: PUBLIC PROCEDURE [s: LONG STRING] RETURNS [CARDINAL] =    BEGIN RemoveTrailingBlanks[s]; RemoveLeadingBlanks[s]; RETURN[s.length] END;  NextToken: PUBLIC PROCEDURE [    rest, token: String.SubString, break: StringExtras.BreakProc] =    BEGIN    lop, i: CARDINAL;    punctuation: BOOLEAN;    token^ _ rest^;    IF rest.length = 0 THEN RETURN;    punctuation _ break[rest.base[rest.offset]];    FOR i IN [rest.offset..rest.offset + rest.length - 1] DO      IF break[rest.base[i]] # punctuation THEN GO TO More      REPEAT        More => token.length _ i - rest.offset;        FINISHED => token.length _ rest.length      ENDLOOP;    rest.offset _ i;    rest.length _ rest.length - token.length;    IF ~punctuation THEN RETURN;    --strip off leading spaces--    FOR i IN [token.offset..token.offset + token.length - 1] DO      IF ~BlankCharacter[token.base[i]] THEN EXIT      REPEAT        FINISHED => --token is all spaces-- BEGIN token.length _ 1; RETURN END      ENDLOOP;    token.length _ token.length - (i - token.offset);    token.offset _ i;    --accumulate non-spaces--    FOR i IN [token.offset..token.offset + token.length - 1] DO      IF BlankCharacter[token.base[i]] THEN EXIT      REPEAT FINISHED => --no trailing spaces-- RETURN      ENDLOOP;    lop _ token.length - (i - token.offset);    token.length _ token.length - lop;    --discard tail of token onto beginning of rest--    rest.offset _ rest.offset - lop;    rest.length _ rest.length + lop;    --strip spaces away from beginning of rest--    FOR i IN [rest.offset..rest.offset + rest.length - 1] DO      IF ~BlankCharacter[rest.base[i]] THEN EXIT      REPEAT        FINISHED =>          BEGIN  --rest is all spaces--          rest.offset _ rest.length;          rest.length _ 0;          RETURN          END      ENDLOOP;    rest.length _ rest.length - (i - rest.offset);    rest.offset _ i    END;  END.
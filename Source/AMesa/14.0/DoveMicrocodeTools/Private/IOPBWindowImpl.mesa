-- File: IOPBWindowImpl.mesa - last edit:-- Bowers.PA           15-Dec-86 10:30:52-- Copyright (C) 1984, 1985, 1986 by Xerox Corporation. All rights reserved.-- after IOPWindower.mesa, HGM,  9-Nov-83 18:41:50DIRECTORY  Cursor,  Exec,  Format USING [StringProc],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType, CommandItem,    Display, DisplayItem, Enumerated, EnumeratedItem, EnumeratedNotifyProcType,    FindIndex, FilterProcType, ItemHandle, line0, line1, line2, line3, line4,    ModifyEditable, NotifyProcType, NumberItem, ProcType, StringItem,     TagOnlyItem],  Heap USING [Error, systemZone],  IOPB,  IOPBWindow,  MFile,  MSegment USING [Error],  MStream USING [Error],  Process,  Put,  Runtime,  Selection USING [Convert],  String,  System USING [GetGreenwichMeanTime],  TextSW USING [ForceOutput],  Time USING [Append, Unpack],  Tool USING [    Create, Destroy, MakeFormSW, MakeFileSW, MakeSWsProc, UnusedLogName],  ToolWindow USING [TransitionProcType],  UserInput USING [UserAbort, WaitForConfirmation],  UserTerminal,  Version USING [Append],  Window USING [Handle],  Bindweed,  CommandFile,  I186,  IOPBBreak <<USING [ClearAllBreaks, EnumerateBreaks, Error, RemoveBreaks]>>,  IOPBCommand,  IOPBKernel,  IOPBPanel USING [    AppendPanelData, Destroy, Initialize, MakePanelSW, NumberOrSymbol, Refresh],  IOPBSymbol,  PanelSW,  PF,  ReportMError;IOPBWindowImpl: PROGRAM  IMPORTS    Cursor, Exec, FormSW, Heap, IOPB, MFile, MSegment, MStream, Put,    Process, Runtime, Selection, String, System, TextSW, Time, Tool, UserInput,    UserTerminal, Version, Bindweed, CommandFile, IOPBBreak, IOPBCommand,    IOPBKernel, IOPBPanel, IOPBSymbol, PanelSW, PF, ReportMError  EXPORTS IOPBCommand, IOPBWindow =  { OPEN IOPBWindow;  data: PUBLIC ARRAY IOPB.Processor OF DataHandle ¬ ALL [NIL];  toolWindow: ARRAY IOPB.Processor OF Window.Handle ¬ ALL [NIL];  z: UNCOUNTED ZONE ¬ Heap.systemZone;  initialized: BOOLEAN ¬ FALSE;  pcInitialized: PUBLIC BOOLEAN ¬ FALSE;  busy: BOOLEAN ¬ FALSE;  gettingState: BOOLEAN ¬ FALSE;  initPC: BOOLEAN ¬ FALSE;  DisplayFlags: PROCEDURE [processor: IOPB.Processor] = {    FlagType: TYPE = MACHINE DEPENDENT RECORD[     bits12To15(0: 0..3): [0..16), -- unused: Intel Reserved     overflow(0: 4..4): BOOLEAN,     dir(0: 5..5): Direction,     interrupt(0: 6..6): BOOLEAN,     trap(0: 7..7): BOOLEAN,     sign(0: 8..8): Sign,     zero(0: 9..9): BOOLEAN,     bit5(0: 10..10): BOOLEAN, -- unused: Intel Reserved     auxCarry(0: 11..11): BOOLEAN,     bit3(0: 12..12): BOOLEAN, -- unused: Intel Reserved     parity(0: 13..13): BOOLEAN,     bit1(0: 14..14): BOOLEAN, -- unused: Intel Reserved     carry(0: 15..15): BOOLEAN];         flags: FlagType ¬ VAL[IOPBKernel.ReadRegister[FLAGS, processor]];    h: DataHandle ¬ data[processor];    h.overflow ¬ flags.overflow;    h.dir ¬ flags.dir;    h.interrupt ¬ flags.interrupt;    h.trap ¬ flags.trap;    h.sign ¬ flags.sign;    h.zero ¬ flags.zero;    h.auxCarry ¬ flags.auxCarry;    h.parity ¬ flags.parity;    h.carry ¬ flags.carry;        };  InitPanel: FormSW.ProcType = {    processor: IOPB.Processor = ProcessorFromSW[sw];    IOPBPanel.Initialize[processor      ! PanelSW.ClientError => {TailMessage[msg, processor]; CONTINUE}; ];    };  Boot: FormSW.ProcType = {    ENABLE {      IOPB.Error => {IOPB.PutError[code, s, sw]; CONTINUE};      Bindweed.Error => {IOPB.PutBWError[code, sw]; CONTINUE}      };    PostDate[ProcessorFromSW[sw]];    IOPBCommand.Boot[data[iop].fileSW];    DisplayNewState[iop];    gettingState ¬ FALSE;    IF data[pc] # NIL THEN DisplayNewState[pc];    };      SetDebugState: FormSW.EnumeratedNotifyProcType = {    h: DataHandle  = data[ProcessorFromSW[sw]];    IOPBKernel.SetState[h.state];    };  SetNewState: PUBLIC PROCEDURE [    newState: IOPBKernel.State] = {    stateChanged: LONG STRING ¬ "State changed: "L;    IOPBKernel.SetState[newState];    SELECT newState FROM      dead, booted, running => {        FOR p: IOPB.Processor IN IOPB.Processor DO	  IF data[p] = NIL THEN LOOP;	  IF p = pc AND newState = running AND data[pc].state = running THEN LOOP;	  PostDate[p];	  Put.Text[data[p].fileSW, stateChanged];	  IOPBCommand.PrintState[data[p].fileSW, newState, p];	  data[p].state ¬ newState;	  FormSW.Display[data[p].upperFormSW];	  ENDLOOP};      halted, iopBreak, singleStep => {        PostDate[iop];        Put.Text[data[iop].fileSW, stateChanged];      	IOPBCommand.PrintState[data[iop].fileSW, newState, iop];	data[iop].state ¬ newState;	FormSW.Display[data[iop].upperFormSW]};      ENDCASE => ERROR;    };  SetIncrement: FormSW.EnumeratedNotifyProcType = {    DoSetIncrement[ProcessorFromSW[sw]];      };        DoSetIncrement: PROC [processor: IOPB.Processor] = {    SELECT data[processor].dataType FROM      byte => data[processor].increment ¬ 1;      word => data[processor].increment ¬ 2;      ENDCASE => ERROR;      };         SetColumnFillMode: FormSW.NotifyProcType = {    processor: IOPB.Processor = ProcessorFromSW[sw];    SELECT data[processor].numbers FROM      TRUE => data[processor].leftFieldType ¬ number;      FALSE => data[processor].leftFieldType ¬ symbol;      ENDCASE => ERROR;      };  Load: FormSW.ProcType = {    processor: IOPB.Processor = ProcessorFromSW[sw];    Process.Detach[      FORK LoadImpl[symbols: TRUE, code: TRUE, processor: processor, sw: sw]]; };  LoadImpl: PROCEDURE [    symbols, code: BOOLEAN, processor: IOPB.Processor, sw: Window.Handle] = {    h: Window.Handle ¬ data[ProcessorFromSW[sw]].fileSW;    fileName: LONG STRING ¬ Selection.Convert[string];    {      ENABLE {	UNWIND => z.FREE[@fileName];	IOPB.Error => {IOPB.PutError[code, s, sw]; CONTINUE};        Bindweed.Error => {IOPB.PutBWError[code, sw]; CONTINUE};	Heap.Error => {ReportMError.HeapError[type, h]; CONTINUE};	MFile.Error => {ReportMError.MFileError[code, h, fileName]; CONTINUE};	MSegment.Error => {ReportMError.MSegmentError[code, h]; CONTINUE};	MStream.Error => {	  ReportMError.MStreamError[code, h, fileName]; CONTINUE};	};	      Abort: PROCEDURE RETURNS [BOOLEAN] =        BEGIN RETURN[UserInput.UserAbort[h]]; END;      IF busy THEN {        Put.Line[h, "\nIOPBermuda is busy\n."L];	RETURN};      busy ¬ TRUE;      PostDate[ProcessorFromSW[sw]];        IF fileName = NIL THEN {	SelectionRequired[sw]; RETURN};      IOPBCommand.Load[	log: h, fileName: fileName, symbols: symbols, code: code,	processor: processor, abort: Abort];      z.FREE[@fileName];      PostDate[ProcessorFromSW[sw]];      };    busy ¬ FALSE;    };  LoadCodeOnly: FormSW.ProcType = {    processor: IOPB.Processor = ProcessorFromSW[sw];    Process.Detach[FORK LoadImpl[      symbols: FALSE, code: TRUE, processor: processor, sw: sw]]};  LoadSymbolsOnly: FormSW.ProcType = {    processor: IOPB.Processor = ProcessorFromSW[sw];    Process.Detach[      FORK LoadImpl[symbols: TRUE, code: FALSE, processor: processor, sw: sw]]; };  Continue: FormSW.ProcType = {    ENABLE {      IOPB.Error => {IOPB.PutError[code, s, sw]; CONTINUE};      Bindweed.Error => {IOPB.PutBWError[code, sw]; CONTINUE}      };    PostDate[iop];    IOPBCommand.Continue[data[iop].fileSW];    SetNewState[running];    };  Step: FormSW.ProcType = {    ENABLE {      IOPB.Error => {IOPB.PutError[code, s, sw]; CONTINUE};      Bindweed.Error => {IOPB.PutBWError[code, sw]; CONTINUE}      };    processor: IOPB.Processor = ProcessorFromSW[sw];    IF NOT IOPBKernel.InKernel[] THEN {      TailMessage["Cannot Step unless in Kernel", processor]; RETURN};    PostDate[processor];    IOPBCommand.Step[data[processor].fileSW, processor];    };  Stop: FormSW.ProcType = {    ENABLE {      IOPB.Error => {IOPB.PutError[code, s, sw]; CONTINUE};      Bindweed.Error => {IOPB.PutBWError[code, sw]; CONTINUE}      };    processor: IOPB.Processor = ProcessorFromSW[sw];    IF data[processor].bindweedState = off THEN Put.Line[data[processor].fileSW,      "Cannot stop when Bindweed is off."L]    ELSE {      PostDate[processor];      IOPBCommand.Stop[data[processor].fileSW, processor]};    };  Refresh: FormSW.ProcType = {    processor: IOPB.Processor = ProcessorFromSW[sw];    IF ~IOPBKernel.InKernel[] THEN      TailMessage["Cannot Refresh while running or dead"L, processor]    ELSE IOPBPanel.Refresh[processor];    };  What: FormSW.ProcType = {    ENABLE IOPB.Error => {IOPB.PutError[code, , sw];  CONTINUE};    string: LONG STRING ¬ Selection.Convert[string];    other: LONG STRING = [200];    value: IOPBSymbol.Symbol;    {    ENABLE UNWIND => z.FREE[@string];    processor: IOPB.Processor = ProcessorFromSW[sw];    PostMessage["Decoding "L, processor];    IF string = NIL THEN {SelectionRequired[sw]; RETURN};    TailMessage[string, processor];    value ¬ IOPBSymbol.Eval[string, byte, data[processor].addressType].symbol;    WITH value SELECT FROM      register => {        String.AppendString[other, "IOP 80186 register: "L];        IOPBSymbol.AppendRegister[other, reg];        };      byte, word => {        String.AppendString[other, "IOP 80186 Symbol: "L];        IOPBSymbol.AppendAddress[other, addr, processor];        AppendLotsOfModes[other, addr];        };      ENDCASE => ERROR;    TailMessage[other, processor];    z.FREE[@string];    };    };  AppendLotsOfModes: PROCEDURE [s: LONG STRING, d: LONG CARDINAL] = {    String.AppendString[s, " = "L];    String.AppendLongNumber[s, d, 16];    String.AppendString[s, "'X = "L];    String.AppendLongNumber[s, d, 10];    String.AppendString[s, "'D = "L];    String.AppendLongNumber[s, d, 8];    String.AppendString[s, "'B"L];    };  Break: FormSW.ProcType = {    ENABLE {      IOPB.Error => {IOPB.PutError[code, s, sw]; CONTINUE};      Bindweed.Error => {IOPB.PutBWError[code, sw]; CONTINUE}      };    where: LONG STRING ¬ Selection.Convert[string];    {    ENABLE UNWIND => z.FREE[@where];    processor: IOPB.Processor = ProcessorFromSW[sw];    IF where = NIL THEN where ¬ String.CopyToNewString[data[processor].typeIn, z];    IF String.Empty[where] THEN {SelectionRequired[sw]; RETURN};    IOPBCommand.Break[data[processor].fileSW, where, processor];    z.FREE[@where];    };    };  Unbreak: FormSW.ProcType = {    ENABLE {      IOPB.Error => {IOPB.PutError[code, s, sw]; CONTINUE};      };    where: LONG STRING ¬ Selection.Convert[string];    {    ENABLE UNWIND => z.FREE[@where];    processor: IOPB.Processor = ProcessorFromSW[sw];    IOPBCommand.Unbreak[data[processor].fileSW, where, processor];    z.FREE[@where];    };    };  ClearAllBreaks: FormSW.ProcType = {    ENABLE IOPB.Error => {IOPB.PutError[code, s, sw];CONTINUE};    processor: IOPB.Processor = ProcessorFromSW[sw];    PostMessage["Clearing All 80186 Breaks "L, processor];    AppendMessage[" ... "L];    IOPBBreak.ClearAllBreaks[processor];    TailMessage["ok"L, processor];    };  ListBreaks: FormSW.ProcType = {    ENABLE IOPB.Error => {IOPB.PutError[code, s, sw]; CONTINUE};    processor: IOPB.Processor = ProcessorFromSW[sw];    h: DataHandle = data[processor];    IOPBCommand.AppendBreakpointList[h.fileSW, processor];    };  Stack: FormSW.ProcType = {    ENABLE {      IOPB.Error => {IOPB.PutError[code, s, sw]; CONTINUE};      Bindweed.Error => {IOPB.PutBWError[code, sw]; CONTINUE}      };    processor: IOPB.Processor = ProcessorFromSW[sw];    h: DataHandle = data[processor];    IOPBCommand.AppendStack[h.fileSW, processor, h.clumpSize];    };  Instructions: FormSW.ProcType = {    ENABLE {      IOPB.Error => {IOPB.PutError[code, s, sw]; CONTINUE};      Bindweed.Error => {IOPB.PutBWError[code, sw]; CONTINUE}      };    where: LONG STRING ¬ Selection.Convert[string];    {    ENABLE UNWIND => z.FREE[@where];    processor: IOPB.Processor = ProcessorFromSW[sw];    h: DataHandle = data[processor];    IF String.Empty[where] THEN {SelectionRequired[sw]; RETURN};    IOPBCommand.AppendInstructions[      data[processor].fileSW, where, processor, data[processor].clumpSize];    z.FREE[@where];    };    };  RefreshPanel: PUBLIC PROCEDURE [processor: IOPB.Processor] = {    IF data[processor] = NIL AND processor = pc THEN       ERROR IOPB.Error[pcNotInitialized];    data[processor].state ¬ IOPBKernel.GetState[];    };  CopyPanelSW: PUBLIC FormSW.ProcType = {CopyPanel[ProcessorFromSW[sw]]};      CopyPanel: PUBLIC PROC [processor: IOPB.Processor] = {    IF data[processor] = NIL AND processor = pc THEN       ERROR IOPB.Error[pcNotInitialized];    PostMessage["State of 80186 Panel at "L];    Put.Date[data[processor].fileSW, System.GetGreenwichMeanTime[], dateTime];    Put.CR[data[processor].fileSW];    IOPBPanel.AppendPanelData[processor, data[processor].fileSW];    Put.CR[data[processor].fileSW];    };  ReadIO: FormSW.ProcType = {    ENABLE {      IOPB.Error => {IOPB.PutError[code, s, sw]; CONTINUE};      Bindweed.Error => {IOPB.PutBWError[code, sw]; CONTINUE}      };    value: CARDINAL ¬ 0;    processor: IOPB.Processor = ProcessorFromSW[sw];    h: DataHandle = data[processor];    port: CARDINAL ¬ HexStringToCardinal[h.port];    IF ~IOPBKernel.InKernel[] THEN RETURN;    SELECT h.dataType FROM      byte => value ¬ IOPBKernel.ReadIOByte[port];      word => value ¬ IOPBKernel.ReadIOWord[port];      ENDCASE => ERROR;    h.value.length ¬ 0;    String.AppendNumber[s: h.value, n: value, radix: 16];    FormSW.DisplayItem[h.lowerFormSW, ORD[LowerFormItems.value]];    };  ReadIOCommand: PUBLIC PROC [port: CARDINAL] RETURNS [iOData: CARDINAL ¬ 0] = {    IF ~IOPBKernel.InKernel[] THEN RETURN;    {    OPEN PF;    h: DataHandle = data[iop];    SELECT h.dataType FROM      byte => {        iOData ¬ IOPBKernel.ReadIOByte[port];        PutW2[          h.fileSW, "%02x ¬ ReadIO[port: %04x];\n"L, [card[iOData]], [          card[port]]]};      word => {        iOData ¬ IOPBKernel.ReadIOWord[port];        PutW2[          h.fileSW, "%04x ¬ ReadIO[port: %04x];\n"L, [card[iOData]], [          card[port]]]};      ENDCASE => ERROR;    };    };  WriteIO: FormSW.ProcType = {    ENABLE {      IOPB.Error => {IOPB.PutError[code, s, sw]; CONTINUE};      Bindweed.Error => {IOPB.PutBWError[code, sw]; CONTINUE}      };    processor: IOPB.Processor = ProcessorFromSW[sw];    h: DataHandle = data[processor];    iOData: CARDINAL ¬ HexStringToCardinal[h.value];    port: CARDINAL ¬ HexStringToCardinal[h.port];    IF ~IOPBKernel.InKernel[] THEN RETURN;    SELECT h.dataType FROM      byte => IOPBKernel.WriteIOByte[port: port, data: iOData MOD 256];      word => IOPBKernel.WriteIOWord[port: port, data: iOData];      ENDCASE => ERROR;    };  WriteIOCommand: PUBLIC PROCEDURE [port: CARDINAL, iOData: CARDINAL] = {    {    OPEN PF;    h: DataHandle = data[iop];    IF ~IOPBKernel.InKernel[] THEN RETURN;    SELECT h.dataType FROM      byte => {        IOPBKernel.WriteIOByte[port: port, data: iOData MOD 256];        PutW2[          h.fileSW, "WriteIO[port: %04x, data: %02x];\n"L, [card[port]], [          card[iOData]]]};      word => {        IOPBKernel.WriteIOWord[port: port, data: iOData];        PutW2[          h.fileSW, "WriteIO[port: %04x, data: %04x];\n"L, [card[port]], [          card[iOData]]]};      ENDCASE => ERROR;    };    };  SetDataType: PUBLIC PROCEDURE [type: IOPB.DataType, processor: IOPB.Processor] = {    IF data[processor] = NIL AND processor = pc THEN       ERROR IOPB.Error[pcNotInitialized];    data[processor].dataType ¬ type;    FormSW.DisplayItem[data[processor].lowerFormSW, ORD[LowerFormItems.dataType]];    DoSetIncrement[processor];    };       SetAddressType: PUBLIC PROC [     processor: IOPB.Processor, addressType: IOPB.AddressType] = {     IF data[processor] = NIL AND processor = pc THEN       ERROR IOPB.Error[pcNotInitialized];     data[processor].addressType ¬ addressType;     FormSW.DisplayItem[       data[processor].lowerFormSW, ORD[LowerFormItems.address]]};  ResetSymbols: FormSW.ProcType = {    processor: IOPB.Processor ¬ ProcessorFromSW[sw];    IOPBCommand.CleanUp[processor];    IOPBCommand.Initialize[processor];    PostDate[processor];    PostMessage["The Symbol Table has been reset"L, processor]};  RunCommandFile: FormSW.ProcType = {    filename: LONG STRING ¬ Selection.Convert[string];    h: Window.Handle ¬ data[ProcessorFromSW[sw]].fileSW;    Put.CR[h];    IF String.Empty[filename] THEN {SelectionRequired[sw]; RETURN; };    IF busy THEN      Put.Line[h, "\nIOPBermuda is busy.\n"L]    ELSE {busy ¬ TRUE; Process.Detach[FORK Runner[filename, sw]]};    };  Runner: PROCEDURE [fileName: LONG STRING, sw: Window.Handle] = {    h: Window.Handle ¬ data[ProcessorFromSW[sw]].fileSW;      {      ENABLE {	IOPB.Error => {IOPB.PutError[code, s, sw]; CONTINUE};	Bindweed.Error => {IOPB.PutBWError[code, sw]; CONTINUE};	UNWIND => z.FREE[@fileName];	Heap.Error => {ReportMError.HeapError[type, h]; CONTINUE};	MFile.Error => {ReportMError.MFileError[code, h, fileName]; CONTINUE};	MSegment.Error => {ReportMError.MSegmentError[code, h]; CONTINUE};	MStream.Error => {	  ReportMError.MStreamError[code, h, fileName]; CONTINUE};	Runtime.UnboundProcedure => {	  Put.Line[h, "CPBermuda is not loaded"L]; CONTINUE};	CommandFile.Error =>	  BEGIN OPEN PF;	  PutW2[h, "Error in command file at position %d: %g.\n", 	    [card[position]], [str[reason]]]; 	  CONTINUE;	  END;	};	      Abort: PROCEDURE RETURNS [BOOLEAN] =    -- will need to be inside runner to know processor      BEGIN RETURN[UserInput.UserAbort[h]]; END;                CommandFile.CommandsFromFile[LogString, h, Abort, fileName];      z.FREE[@fileName];      };    busy ¬ FALSE    };    HexStringToCardinal: PROCEDURE [s: LONG STRING] RETURNS [n: CARDINAL ¬ 0] = {    FOR i: CARDINAL IN [0..s.length) DO      SELECT s[i] FROM        '0, '1, '2, '3, '4, '5, '6, '7, '8, '9 => n ¬ n * 16 + s[i] - '0;        'A, 'B, 'C, 'D, 'E, 'F => n ¬ n * 16 + s[i] - 'A + 10;        'a, 'b, 'c, 'd, 'e, 'f => n ¬ n * 16 + s[i] - 'a + 10;        ENDCASE => EXIT;      ENDLOOP;    };  GetNewState: Bindweed.NotifyProc = {    ENABLE {      IOPB.Error => {        IOPB.PutError[code, s, data[iop].lowerFormSW]; gettingState ¬ FALSE;        CONTINUE};      Bindweed.Error => {        IOPB.PutBWError[code, data[iop].lowerFormSW];	gettingState ¬ FALSE; CONTINUE}      };    newState: IOPBKernel.State;    stateValue: CARDINAL;        IF gettingState THEN RETURN;    gettingState ¬ TRUE;    IF IOPBKernel.InKernel[] THEN {gettingState ¬ FALSE; RETURN};    IOPBKernel.SetState[halted];    stateValue ¬ IOPBKernel.ReadMemoryByte[IOPBKernel.i186StateAddress, iop];    -- make sure newState is a legal state    newState ¬      IF stateValue > IOPBKernel.State.LAST.ORD THEN dead ELSE VAL[stateValue];    IOPBKernel.SetState[newState];    DisplayNewState[iop];    IF newState = iopBreak AND data[pc] # NIL THEN GetPCState[];    gettingState ¬ FALSE;    };          PCStateType: TYPE = MACHINE DEPENDENT {null(0), break(1), sstep(2), stop(3)};       GetPCState: PROC = {    ENABLE IOPB.Error => {IOPB.PutError[code, s, data[pc].lowerFormSW]; CONTINUE};    pcStateValue: CARDINAL ¬      IOPBKernel.ReadMemoryByte[IOPBKernel.pcStatusAddress, pc];    pcState:  PCStateType ¬ null;    IF pcStateValue > ABS[VAL[PCStateType.LAST]]       OR (pcState ¬ VAL[pcStateValue]) = null THEN RETURN;    -- reset PC Debug Status    IOPBKernel.WriteMemoryByte[      IOPBKernel.pcStatusAddress, pc, VAL[PCStateType.null]];    IF IOPBKernel.InKernel[] THEN {      IOPBKernel.ReadSavedRegisters[pc];      IOPBBreak.InstallBreaks[]; -- BOGUS, JUST FOR DEBUGGING      IOPBBreak.RemoveBreaks[];      IOPBPanel.Refresh[pc];      DisplayFlags[pc]};    PostDate[pc];    Put.Text[data[pc].fileSW, "State changed: "L];    data[pc].state ¬ SELECT pcState FROM      break => iopBreak,      sstep => singleStep,      stop => halted,      ENDCASE => ERROR;    IOPBCommand.PrintState[data[pc].fileSW, data[pc].state, pc];    FormSW.Display[data[pc].upperFormSW]};  DisplayNewState: PUBLIC PROCEDURE[processor: IOPB.Processor] = {    IF IOPBKernel.InKernel[] THEN {      IOPBKernel.ReadSavedRegisters[processor];      IOPBBreak.RemoveBreaks[];      IOPBPanel.Refresh[processor];      DisplayFlags[processor]};    PostDate[processor];    AppendMessage["State changed: "L];    IOPBCommand.PrintState[      data[processor].fileSW, IOPBKernel.GetState[], processor];    data[processor].state ¬ IOPBKernel.GetState[];    FormSW.Display[data[processor].upperFormSW];    };  SwitchBindweedState: FormSW.EnumeratedNotifyProcType = {    ok: BOOLEAN;    h: DataHandle = data[iop];    oldCursor: Cursor.Object;    Cursor.Fetch[@oldCursor];    Cursor.Set[mouseRed];        SELECT h.bindweedState FROM      on => {        PostMessage["Do you want to turn on the IOP debugger now?\n"L];        [, ok] ¬ UserInput.WaitForConfirmation[];        Cursor.Store[@oldCursor];        IF ok THEN {          Bindweed.TurnOnWatcher[];          PostDate[iop];          PostMessage[	    "IOP debugger turned on.  Please set A/B switch for IOP\n"L]}        ELSE {          PostMessage["IOP debugger is still off\n"L];          h.bindweedState ¬ off;          FormSW.DisplayItem[h.lowerFormSW, ORD[UpperFormItems.onOrOff]]}};      off => {        PostMessage["Do you want to turn off the IOP debugger now?\n"L];        [, ok] ¬ UserInput.WaitForConfirmation[];        Cursor.Store[@oldCursor];        IF ok THEN {          Bindweed.TurnOffWatcher[];          PostDate[iop];          PostMessage["IOP debugger turned off.  Please set A/B switch for CP\n"L]}        ELSE {          PostMessage["IOP debugger is still on\n"L];          h.bindweedState ¬ on;          FormSW.DisplayItem[h.lowerFormSW, ORD[UpperFormItems.onOrOff]]}};      ENDCASE => ERROR};  PostDate: PROCEDURE [processor: IOPB.Processor] = {    OPEN PF;    h: Window.Handle = data[processor].fileSW;    PutW2[h, "\n%g   "L, time[]];    };  PostMessage: PROCEDURE [s: LONG STRING, processor: IOPB.Processor ¬ iop] = {    h: DataHandle = data[processor];    Put.CR[h.fileSW];    Put.Text[h.fileSW, s];    TextSW.ForceOutput[h.fileSW]};  AppendMessage: PROCEDURE [s: LONG STRING] = {    Put.Text[data[iop].fileSW, s]; TextSW.ForceOutput[data[iop].fileSW]};  TailMessage: PROCEDURE [s: LONG STRING, processor: IOPB.Processor ¬ iop] = {    Put.Text[data[processor].fileSW, s];    Put.Line[data[processor].fileSW, "."L];    TextSW.ForceOutput[data[processor].fileSW]};  LogString: Format.StringProc = {Put.Text[clientData, s]; };  ProcessorFromSW: PROC [sw: Window.Handle]    RETURNS [processor: IOPB.Processor ¬ iop] = {    IF data[pc] = NIL THEN processor ¬ iop ELSE    SELECT TRUE FROM      data[iop].lowerFormSW = sw, data[iop].upperFormSW = sw => processor ¬ iop;      data[pc].lowerFormSW = sw, data[pc].upperFormSW = sw => processor ¬ pc;      ENDCASE => ERROR;      };         LogForSW: PUBLIC PROC [sw: Window.Handle] RETURNS [log: Window.Handle] = {     IF data[pc] = NIL THEN log ¬ data[iop].fileSW;     SELECT TRUE FROM      data[iop].lowerFormSW = sw, data[iop].upperFormSW = sw =>         log ¬ data[iop].fileSW;      data[pc].lowerFormSW = sw, data[pc].upperFormSW = sw =>         log ¬ data[pc].fileSW;      ENDCASE => ERROR;      };  SelectionRequired: PROC [sw: Window.Handle] = {    h: Window.Handle ¬ data[ProcessorFromSW[sw]].fileSW;    Put.Line[h, " Selection required"L]};      HexNumberFilter: FormSW.FilterProcType = {    OPEN String;    BackSpace: CHARACTER = 301C;    BackSpace2: CHARACTER = 210C;    BackWord: CHARACTER = 302C;    BackWord2: CHARACTER = 230C;        CharacterValidHexDigit: PROCEDURE [ch: CHARACTER] RETURNS [valid: BOOLEAN] =      INLINE {      RETURN[        SELECT ch FROM          IN ['0..'9] => TRUE,          IN ['a..'f] => TRUE,          IN ['A..'F] => TRUE,          BackSpace, BackSpace2 => TRUE,          BackWord, BackWord2 => TRUE,          ENDCASE => FALSE]};    index, start: CARDINAL;    tempString, otherTempString, currentString: LONG STRING;    maxlength: CARDINAL ¬ 0;    -- get current string    WITH itemDesc: item SELECT FROM      string => currentString ¬ itemDesc.string­;      ENDCASE => ERROR;    maxlength ¬ currentString.maxlength;    -- assume currentString has already been allocated    tempString ¬ z.NEW[StringBody [currentString.length + string.length]];    otherTempString ¬ z.NEW[StringBody [maxlength]];    IF insert > 0 THEN      FOR i: CARDINAL IN [0..insert) DO        String.AppendChar[tempString, currentString[i]]; ENDLOOP;    index ¬ FormSW.FindIndex[sw, item];    FOR i: CARDINAL IN [0..string.length) DO      IF CharacterValidHexDigit[string[i]] THEN {        SELECT string[i] FROM          BackSpace, BackSpace2 => {            FormSW.ModifyEditable[              sw: sw, index: index, position: insert - 1, length: 1];            z.FREE[@tempString];            RETURN;            };          BackWord, BackWord2 => {            FormSW.ModifyEditable[              sw: sw, index: index, position: 0, length: currentString.length];            z.FREE[@tempString];            RETURN;            };          ENDCASE => String.AppendChar[tempString, UpperCase[string[i]]];        }      ELSE UserTerminal.BlinkDisplay[];      ENDLOOP;    IF currentString.length > insert THEN      FOR i: CARDINAL IN [insert..currentString.length) DO        String.AppendChar[tempString, UpperCase[currentString[i]]]; ENDLOOP;    start ¬      IF tempString.length > maxlength THEN tempString.length - maxlength ELSE 0;    FOR i: CARDINAL IN [start..tempString.length) DO      String.AppendChar[otherTempString, UpperCase[tempString[i]]]; ENDLOOP;    FormSW.ModifyEditable[      sw: sw, index: index, position: 0, length: otherTempString.length,      new: otherTempString];    z.FREE[@tempString];    };        Init: PROCEDURE [h: Exec.Handle] = {    herald: STRING = [100];    msg: STRING ¬ [80];    String.AppendString[herald, "IOP Debugger (IOPBermuda) "L];    Version.Append[herald];    String.AppendString[herald, " of "L];    Time.Append[herald, Time.Unpack[Runtime.GetBcdTime[]]];    IF initialized THEN ERROR;    Bindweed.TurnOnWatcher[];    toolWindow[iop] ¬ Tool.Create[      name: herald, cmSection: "80186 Debugger"L, makeSWsProc: MakeIOPSWs,      clientTransition: ClientTransition];    initialized ¬ TRUE;    };  DebugPC:  FormSW.ProcType = {    herald: STRING = [100];    msg: STRING ¬ [80];    IF pcInitialized THEN RETURN; -- should post a message    String.AppendString[herald, "PC Debugger (IOPBermuda) "L];    Version.Append[herald];    String.AppendString[herald, " of "L];    Time.Append[herald, Time.Unpack[Runtime.GetBcdTime[]]];    toolWindow[pc] ¬ Tool.Create[      name: herald, cmSection: "PC Debugger"L, makeSWsProc: MakePCSWs,      clientTransition: PCClientTransition];    pcInitialized ¬ TRUE;    };      PCClientTransition: ToolWindow.TransitionProcType = {    h: DataHandle ¬ data[pc];    SELECT TRUE FROM      old = inactive => {        IF h = NIL THEN data[pc] ¬ h ¬ z.NEW[Data ¬ []];        h.typeIn ¬ z.NEW[StringBody [20]];        h.state ¬ IOPBKernel.GetState[];        h.port ¬ z.NEW[StringBody [4]];        h.value ¬ z.NEW[StringBody [4]];	IOPBCommand.Initialize[pc]        };      new = inactive => {        IOPBPanel.Destroy[pc];        z.FREE[@h.typeIn];        z.FREE[@h.port];        z.FREE[@h.value];        IF h # NIL THEN {z.FREE[@data[pc]]};	IOPBCommand.CleanUp[pc]        };      ENDCASE;    };      Unload: Exec.ExecProc = {    [] ¬ Exec.RemoveCommand[h, "IOPBermuda.~"L];    Bindweed.TurnOffWatcher[];    Tool.Destroy[toolWindow[iop]];    IF toolWindow[pc] # NIL THEN Tool.Destroy[toolWindow[pc]];    };      MakePCSWs: Tool.MakeSWsProc = {    initPC ¬ TRUE;    MakeSWs[window];    initPC ¬ FALSE};      MakeIOPSWs: Tool.MakeSWsProc = {    initPC ¬ FALSE;    MakeSWs[window]};  MakeSWs: Tool.MakeSWsProc = {    fileSWFileName: STRING = [40];    file: LONG STRING ¬ NIL;    processor: IOPB.Processor ¬ IF initPC THEN pc ELSE iop;    h: DataHandle ¬ data[processor];    modifyTypeIn: PanelSW.ModifyTypeInProcType;    file ¬ SELECT processor FROM       iop => "IOPDebugger.log"L,      pc => "PCDebugger.log"L,      ENDCASE => ERROR;    modifyTypeIn ¬ SELECT processor FROM      iop => ModifyIOPTypeIn,      pc => ModifyPCTypeIn,      ENDCASE => ERROR;    Tool.UnusedLogName[fileSWFileName, file];    h.upperFormSW ¬ Tool.MakeFormSW[window: window, formProc: MakeUpperForm];    h.fileSW ¬ Tool.MakeFileSW[window: window, name: fileSWFileName, h: 100];    --h.titleSW ¬ Tool.MakeFormSW[window: window, formProc: MakeTitleForm];    h.lowerFormSW ¬ Tool.MakeFormSW[window: window, formProc: MakeLowerForm];    h.panelSW ¬ IOPBPanel.MakePanelSW[      parent: window, err: h.fileSW, modifyTypeIn: modifyTypeIn,       typeIn: @h.typeIn, increment: @h.increment, rows:  @h.rows,      dType: @h.dataType, addrType: @h.addressType,       leftFieldType: @h.leftFieldType, processor: processor];    };      MakeTitleForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = 1;    title: LONG STRING ¬ IF initPC THEN "PC 80186 Debugger"L ELSE      "IOP 80186 Debugger"L;    items _ AllocateItemDescriptor[nItems];    items[0] _ TagOnlyItem[      tag: title, place: [141, line0]];    RETURN[items: items, freeDesc: TRUE];    };  MakeLowerForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = LowerFormItems.LAST.ORD + 1;    dataType: ARRAY [0..2) OF Enumerated ¬ [["byte"L, 0], ["word"L, 1]];    address: ARRAY [0..4) OF Enumerated _ [      ["iop"L, 0], ["pc"L, 1], ["real"L, 2], ["vm"L, 3]];    processor: IOPB.Processor ¬ IF initPC THEN pc ELSE iop;    h: DataHandle ¬ data[processor];    items _ AllocateItemDescriptor[nItems, z];    items[LowerFormItems.load.ORD] _ TagOnlyItem[      tag: "Load:"L, place: [3, line0]];    items[LowerFormItems.all.ORD] _ CommandItem[      tag: "All"L, place: [40, line0], drawBox: TRUE, proc: Load];    items[LowerFormItems.code.ORD] _ CommandItem[      tag: "Code"L, place: [69, line0], drawBox: TRUE, proc: LoadCodeOnly];    items[LowerFormItems.symbols.ORD] _ CommandItem[      tag: "Symbols"L, place: [104, line0], drawBox: TRUE, proc: LoadSymbolsOnly,      z: z];    items[LowerFormItems.resetSyms.ORD] _ CommandItem[      tag: "ResetSyms"L, place: [160, line0], proc: ResetSymbols];    items[LowerFormItems.commandFile.ORD] _ CommandItem[      tag: "CommandFile"L, place: [226, line0], proc: RunCommandFile];    items[LowerFormItems.boot.ORD] _ CommandItem[      tag: "Boot"L, place: [311, line0], drawBox: TRUE, proc: Boot];    items[LowerFormItems.step.ORD] _ CommandItem[      tag: "Step"L, place: [364, line0], drawBox: TRUE, proc: Step];    items[LowerFormItems.continue.ORD] _ CommandItem[      tag: "Continue"L, place: [397, line0], drawBox: TRUE, proc: Continue];    items[LowerFormItems.sTOP.ORD] _ CommandItem[      tag: "STOP"L, place: [454, line0], drawBox: TRUE, proc: Stop];    items[LowerFormItems.break.ORD] _ TagOnlyItem[      tag: "Break:"L, place: [3, line1]];    items[LowerFormItems.set.ORD] _ CommandItem[      tag: "Set"L, place: [46, line1], drawBox: TRUE, proc: Break];    items[LowerFormItems.list.ORD] _ CommandItem[      tag: "List"L, place: [73, line1], drawBox: TRUE, proc: ListBreaks];    items[LowerFormItems.clear.ORD] _ CommandItem[      tag: "Clear"L, place: [108, line1], drawBox: TRUE, proc: Unbreak];    items[LowerFormItems.clearAll.ORD] _ CommandItem[      tag: "ClearAll"L, place: [147, line1], drawBox: TRUE, proc: ClearAllBreaks,      z: z];    items[LowerFormItems.file.ORD] _ StringItem[      tag: "File"L, place: [206, line1], inHeap: TRUE, string: @h.file];    items[LowerFormItems.address.ORD] _ EnumeratedItem[      tag: "Address"L, place: [4, line2], feedback: all,      choices: DESCRIPTOR[address], value: @h.addressType];    items[LowerFormItems.dataType.ORD] _ EnumeratedItem[      tag: "Data"L, place: [177, line2], feedback: all,      choices: DESCRIPTOR[dataType], value: @h.dataType, proc: SetIncrement];    items[LowerFormItems.numbers.ORD] _ BooleanItem[      tag: "numbers"L, place: [291, line2], switch: @h.numbers,      proc: SetColumnFillMode];    items[LowerFormItems.what.ORD] _ CommandItem[      tag: "What"L, place: [339, line2], proc: What];    items[LowerFormItems.rows.ORD] _ StringItem[      tag: "rows"L, place: [376, line2], inHeap: TRUE, string: @h.rows];    items[LowerFormItems.panel.ORD] _ TagOnlyItem[      tag: "Panel:"L, place: [5, line3]];    items[LowerFormItems.init.ORD] _ CommandItem[      tag: "Init"L, place: [48, line3], drawBox: TRUE, proc: InitPanel];    items[LowerFormItems.copy.ORD] _ CommandItem[      tag: "Copy"L, place: [81, line3], drawBox: TRUE, proc: CopyPanelSW];    items[LowerFormItems.refresh.ORD] _ CommandItem[      tag: "Refresh"L, place: [115, line3], drawBox: TRUE, proc: Refresh];    items[LowerFormItems.iO.ORD] _ TagOnlyItem[      tag: "IO:"L, place: [181, line3]];    items[LowerFormItems.write.ORD] _ CommandItem[      tag: "Write"L, place: [205, line3], drawBox: TRUE, proc: WriteIO];    items[LowerFormItems.read.ORD] _ CommandItem[      tag: "Read"L, place: [244, line3], drawBox: TRUE, proc: ReadIO];    items[LowerFormItems.port.ORD] _ StringItem[      tag: "Port"L, place: [277, line3], drawBox: TRUE, inHeap: TRUE,      string: @h.port, filterProc: HexNumberFilter];    items[LowerFormItems.value.ORD] _ StringItem[      tag: "Value"L, place: [377, line3], drawBox: TRUE, inHeap: TRUE,      string: @h.value, filterProc: HexNumberFilter];    items[LowerFormItems.typeIn.ORD] _ StringItem[      tag: "TypeIn"L, place: [2, line4], inHeap: TRUE, string: @h.typeIn];    RETURN[items: items, freeDesc: TRUE];    };  MakeUpperForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = UpperFormItems.LAST.ORD + 1;    dir: ARRAY [0..2) OF Enumerated ¬ [["forward"L, 0], ["reverse"L, 1]];    sign: ARRAY [0..2) OF Enumerated ¬ [["plus"L, 0], ["minus"L, 1]];    state: ARRAY [0..6) OF Enumerated ¬ [      ["Dead"L, 0], ["Booted"L, 1], ["Halted"L, 2], ["Running"L, 3], [      "Break"L, 4], ["SingleStep"L, 5]];    onOrOff: ARRAY [0..2) OF Enumerated ¬ [["on"L, 0], ["off"L, 1]];    processor: IOPB.Processor ¬ IF initPC THEN pc ELSE iop;    h: DataHandle ¬ data[processor];    items ¬ AllocateItemDescriptor[nItems];    items[UpperFormItems.overflow.ORD] ¬ BooleanItem[      tag: "overflow"L, place: [3, line0], switch: @h.overflow];    items[UpperFormItems.dir.ORD] ¬ EnumeratedItem[      tag: "dir"L, place: [61, line0], choices: DESCRIPTOR[dir],      value: @h.dir];    items[UpperFormItems.interrupt.ORD] ¬ BooleanItem[      tag: "interrupt"L, place: [148, line0], switch: @h.interrupt];    items[UpperFormItems.trap.ORD] ¬ BooleanItem[      tag: "trap"L, place: [207, line0], switch: @h.trap];    items[UpperFormItems.sign.ORD] ¬ EnumeratedItem[      tag: "sign"L, place: [238, line0], choices: DESCRIPTOR[sign],      value: @h.sign];    items[UpperFormItems.zero.ORD] ¬ BooleanItem[      tag: "zero"L, place: [324, line0], switch: @h.zero];    items[UpperFormItems.auxCarry.ORD] ¬ BooleanItem[      tag: "auxCarry"L, place: [359, line0], switch: @h.auxCarry];    items[UpperFormItems.parity.ORD] ¬ BooleanItem[      tag: "parity"L, place: [413, line0], switch: @h.parity];    items[UpperFormItems.carry.ORD] ¬ BooleanItem[      tag: "carry"L, place: [459, line0], switch: @h.carry];    items[UpperFormItems.state.ORD] ¬ EnumeratedItem[      tag: "State"L, place: [4, line1], choices: DESCRIPTOR[state],      value: @h.state, proc: SetDebugState];    items[UpperFormItems.stack.ORD] ¬ CommandItem[      tag: "Stack"L, place: [129, line1], proc: Stack];    items[UpperFormItems.instructions.ORD] ¬ CommandItem[      tag: "Instructions"L, place: [173, line1], proc: Instructions];    items[UpperFormItems.length.ORD] ¬ NumberItem[      tag: "Length"L, place: [261, line1], default: 6, value: @h.clumpSize];    items[UpperFormItems.debugPC.ORD] _ CommandItem[      tag: "DebugPC"L, place: [351, line1], proc: DebugPC, invisible: processor = pc];    items[UpperFormItems.onOrOff.ORD] ¬ EnumeratedItem[      tag: ":"L, place: [410, line1], feedback: all, choices: DESCRIPTOR[onOrOff],      value: @h.bindweedState, proc: SwitchBindweedState, invisible: processor = pc];    RETURN[items: items, freeDesc: TRUE];    };  ModifyIOPTypeIn: PROCEDURE [newTypeIn: LONG STRING, replace: BOOLEAN] = {    IF newTypeIn = NIL OR replace THEN data[iop].typeIn.length ¬ 0;    IF newTypeIn # NIL THEN      String.AppendStringAndGrow[@data[iop].typeIn, newTypeIn, z];    FormSW.DisplayItem[data[iop].lowerFormSW, ORD[LowerFormItems.typeIn]];    };      ModifyPCTypeIn: PROCEDURE [newTypeIn: LONG STRING, replace: BOOLEAN] = {    IF newTypeIn = NIL OR replace THEN data[pc].typeIn.length ¬ 0;    IF newTypeIn # NIL THEN      String.AppendStringAndGrow[@data[pc].typeIn, newTypeIn, z];    FormSW.DisplayItem[data[pc].lowerFormSW, ORD[LowerFormItems.typeIn]];    };  ClientTransition: ToolWindow.TransitionProcType = {    h: DataHandle ¬ data[iop];    SELECT TRUE FROM      old = inactive => {        IF h = NIL THEN data[iop] ¬ h ¬ z.NEW[Data ¬ []];        h.typeIn ¬ z.NEW[StringBody [20]];        h.state ¬ IOPBKernel.GetState[];        h.port ¬ z.NEW[StringBody [4]];        h.value ¬ z.NEW[StringBody [4]];        IOPBCommand.Initialize[iop];        Bindweed.AddNotify[GetNewState, 3  --IOPBermuda naked notify bit--];        };      new = inactive => {        Bindweed.RemoveNotify[          3, GetNewState --IOPBermuda naked notify bit--];        IOPBPanel.Destroy[iop];        z.FREE[@h.typeIn];        z.FREE[@h.port];        z.FREE[@h.value];        IF h # NIL THEN {z.FREE[@data[iop]]};        IOPBCommand.CleanUp[iop];        };      ENDCASE;    };  IgnoreCommandLine: Exec.ExecProc = BEGIN IF NOT initialized THEN Init[h]; END;  Register: PROC = {    Exec.AddCommand[      name: "IOPBermuda.~"L, proc: IgnoreCommandLine, unload: Unload]};  Register[];  }.
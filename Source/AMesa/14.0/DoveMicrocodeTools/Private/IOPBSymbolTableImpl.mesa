-- File: IOPBSymbolTableImpl.mesa - last edit:-- FXB   .PA           10-Apr-85 17:03:23-- Copyright (C) 1984, 1985 by Xerox Corporation. All rights reserved.DIRECTORY  GSort,  Heap,  IOPBSymbolTable,  String;IOPBSymbolTableImpl: MONITOR  IMPORTS GSort, Heap, String EXPORTS IOPBSymbolTable =  {  Handle: TYPE = LONG POINTER TO Object;  Object: PUBLIC TYPE = RECORD [    heap: UNCOUNTED ZONE, aM: AMPtr ¬ NIL, hVec: LONG POINTER TO HashVector];  hVSize: CARDINAL = 4093;  HashVector: TYPE = ARRAY [0..hVSize) OF STEntry;  STEntry: PUBLIC TYPE = LONG POINTER TO STEntryRec;  STEntryRec: TYPE = RECORD [    next: STEntry _ NIL,  -- points to next EntryRec with same hash vector index    index: CARDINAL _ 0,  -- index to Address Map entry corresponding to symbol    s: LONG STRING];  AMEntry: TYPE = RECORD [value: LONG CARDINAL, symbol: STEntry];  AMPtr: TYPE = LONG POINTER TO AddressMapSeqBody;  AddressMapSeqBody: TYPE = RECORD [    length: CARDINAL _ 1, seq: SEQUENCE maxlength: CARDINAL OF AMEntry];  maxAMSize: CARDINAL = LAST[CARDINAL] / SIZE[AMEntry];  aMIndex: CARDINAL ¬ 0;  Overflow: PUBLIC ERROR = CODE;  Hash: INTERNAL PROC [s: LONG STRING] RETURNS [[0..hVSize)] = INLINE {    acc: CARDINAL _ 0;    FOR i: CARDINAL IN [0..MIN[7, s.length]) DO acc _ 7 * acc + VAL[s[i]] ENDLOOP;    RETURN[acc MOD hVSize]};  Equal: PROCEDURE [s1, s2: LONG STRING] RETURNS [BOOLEAN] = INLINE {    i: CARDINAL;    IF s1.length # s2.length THEN RETURN[FALSE];    FOR i IN [0..s1.length) DO IF s1[i] # s2[i] THEN RETURN[FALSE]; ENDLOOP;    RETURN[TRUE]    };  Create: PUBLIC ENTRY PROC RETURNS [h: Handle] = {    ENABLE UNWIND => NULL;    heap: UNCOUNTED ZONE ¬ Heap.Create[initial: 200, increment: 100];    h ¬ heap.NEW[Object ¬ [heap: heap, aM: NIL, hVec: NIL]];    h.hVec ¬ heap.NEW[HashVector ¬ ALL[NIL]]};  Delete: PUBLIC ENTRY PROC [h: Handle] RETURNS [nilH: Handle ¬ NIL] = {    ENABLE UNWIND => NULL;    heap: UNCOUNTED ZONE ¬ h.heap;    IF heap # NIL THEN Heap.Delete[heap]};  ChangeValue: PUBLIC ENTRY PROC [    value: LONG CARDINAL, index: CARDINAL, h: Handle] = {    ENABLE UNWIND => NULL;    IF index >= h.aM.length THEN ERROR;    h.aM[index].value _ value;    };  EnterSymbol: PUBLIC ENTRY PROC [s: LONG STRING, index: CARDINAL ¬ 0, h: Handle]    RETURNS [new: BOOLEAN _ TRUE, symbol: STEntry, oldIndex: CARDINAL] = {    ENABLE UNWIND => NULL;    i: [0..hVSize) ¬ Hash[s];    entry: STEntry ¬ NIL;    -- assume that all symbols are already capitalized so can do String.Equal    FOR entry ¬ h.hVec[i], entry.next UNTIL entry = NIL DO      IF Equal[s, entry.s] THEN {        new ¬ FALSE; symbol ¬ entry; oldIndex ¬ entry.index; RETURN};      ENDLOOP;    entry ¬ h.heap.NEW[STEntryRec ¬ [next: h.hVec[i], index: index, s: NIL]];    entry.s ¬ String.CopyToNewString[s: s, z: h.heap];    h.hVec[i] ¬ entry;    symbol ¬ entry;    };  EnterValue: PUBLIC ENTRY PROC [    value: LONG CARDINAL, symbol: STEntry, h: Handle] = {    ENABLE UNWIND => NULL;    aM: AMPtr ¬ h.aM;    IF aM = NIL THEN      aM ¬ h.heap.NEW[AddressMapSeqBody [3000] _ [length: 1, seq: NULL]];    IF aM.length < aM.maxlength THEN {      aM[aM.length].value _ value;      aM[aM.length].symbol _ symbol;      aM.length _ aM.length + 1;      }    ELSE {      tempAM: AMPtr ¬ NIL;      IF aM.length + 1000 > maxAMSize THEN ERROR Overflow;      tempAM _ h.heap.NEW[        AddressMapSeqBody [aM.length + 1000] _ [length: 1, seq: NULL]];      FOR i: CARDINAL IN [1..aM.length) DO tempAM[i] _ aM[i]; ENDLOOP;      tempAM[aM.length].value _ value;      tempAM[aM.length].symbol _ symbol;      tempAM.length _ aM.length + 1;      h.heap.FREE[@aM];      aM ¬ tempAM;      };    h.aM ¬ aM;    };  GetSymbolForValue: PUBLIC ENTRY PROC [value: LONG CARDINAL, h: Handle]    RETURNS [symbol: LONG STRING ¬ NIL, offset: LONG CARDINAL ¬ 0] = {    ENABLE UNWIND => NULL;    index: CARDINAL;    aM: AMPtr ¬ h.aM;    BinarySearch: PROC [high, low: CARDINAL, value: LONG CARDINAL]      RETURNS [index: CARDINAL] = {      --returns index of value if found and index of nearest lesser value if not      midpoint: CARDINAL _ (high + low) / 2;      SELECT TRUE FROM        high - low = 1 => index _ low;        value > aM[midpoint].value =>          index _ BinarySearch[high: high, low: midpoint, value: value];        value < aM[midpoint].value =>          index _ BinarySearch[high: midpoint, low: low, value: value];        value = aM[midpoint].value => index _ midpoint;        ENDCASE => ERROR;      };    IF aM = NIL THEN RETURN;  -- should be I186Command.Error    -- do binary search    index _ BinarySearch[high: aM.length - 1, low: 1, value: value];    symbol _ aM[index].symbol.s;    offset _ value - aM[index].value;    };  GetValueAtIndex: PUBLIC ENTRY PROC [index: CARDINAL, h: Handle]    RETURNS [value: LONG CARDINAL _ 0] = {    ENABLE UNWIND => NULL;    IF h.aM = NIL THEN RETURN;    RETURN[h.aM[index].value];    };  LookUpSymbol: PUBLIC ENTRY PROC [s: LONG STRING, h: Handle]    RETURNS [found: BOOLEAN ¬ FALSE, index: CARDINAL ¬ 0] = {    i: [0..hVSize) ¬ 0;    FOR j: CARDINAL IN [0..s.length) DO s[j] ¬ String.UpperCase[s[j]]; ENDLOOP;    i ¬ Hash[s];    FOR entry: STEntry ¬ h.hVec[i], entry.next UNTIL entry = NIL DO      IF Equal[s, entry.s] THEN RETURN[TRUE, entry.index]; ENDLOOP;    };  Sort: PUBLIC ENTRY PROC [h: Handle] RETURNS [symbols: CARDINAL ¬ 0] = {    ENABLE UNWIND => NULL;    aM: AMPtr ¬ h.aM;    GetRecord: GSort.GetProcType = {      ep: LONG POINTER TO AMEntry ¬ p;      IF aMIndex < aM.length THEN {        ep­ ¬ aM[aMIndex]; aMIndex ¬ aMIndex + 1; RETURN[SIZE[AMEntry]]}      ELSE {aMIndex ¬ 1; RETURN[0]};      };    PutRecord: GSort.PutProcType = {      ep: LONG POINTER TO AMEntry ¬ p;      IF aMIndex >= aM.length THEN ERROR;      aM[aMIndex] ¬ ep­;      aMIndex ¬ aMIndex + 1;      };    CompareRecords: GSort.CompareProcType = {      ep1: LONG POINTER TO AMEntry ¬ p1;      ep2: LONG POINTER TO AMEntry ¬ p2;      RETURN[        SELECT TRUE FROM          ep1.value > ep2.value => 1,          ep1.value < ep2.value => -1,          ENDCASE => 0];      };    IF aM = NIL THEN RETURN;    aMIndex ¬ 1;    GSort.Sort[      get: GetRecord, put: PutRecord, compare: CompareRecords,      expectedItemSize: SIZE[AMEntry], maxItemSize: SIZE[AMEntry]];    FOR i: CARDINAL IN [1..h.aM.length) DO aM[i].symbol.index ¬ i; ENDLOOP;    symbols ¬ aM.length - 1;    };  }.  LOG     Created by Frank FXB    17-Feb-84 14:05:31   Frank FXB   , 12-Oct-84 15:41:22, added ChangeValue   Frank FXB   ,  5-Feb-85 13:24:00, changed from QuickSort to GSort   Frank FXB   ,  7-Feb-85 14:42:00, fixed address fault if no symbols                              
-- Copyright (C) 1984 by Xerox Corporation. All rights reserved.-- OMFImplB.mesa -- last edited by Dennis E. DEG      @ 15-Jan-84 21:51:53-- last edited by FHB     5-Jan-84 13:02:26-- last edited by FHB     3-Dec-84 10:18:02-- last edited by FHB     9-Sep-86 12:36:30DIRECTORY  InternalOMFDef,  Stream USING [PutByte],  OMF;OMFImplB: PROGRAM IMPORTS OMF, Stream EXPORTS OMF =  BEGIN  Handle: PUBLIC TYPE = InternalOMFDef.InternalHandle;  Byte: TYPE = OMF.Byte;  InternalFixupDataType: TYPE = MACHINE DEPENDENT RECORD [    fillerByte: Byte ¬ 0,    frameSpecMode: OMF.ThreadOrFixupMethod ¬ explicitly,    frame: [0..8) ¬ 0,    targetSpecMode: OMF.ThreadOrFixupMethod ¬ explicitly,    target: [0..8) ¬ 0];  InternalRecordType: TYPE = InternalOMFDef.InternalRecordType;  InternalRecord: TYPE = InternalOMFDef.InternalRecord;  InternalRegisterInit: TYPE = MACHINE DEPENDENT RECORD [    fillerByte: Byte ¬ 0,    registerID: {CSandIP, SSandSP, DS, ES} ¬ CSandIP,    unassigned: [0..32) ¬ 0,    l: OMF.RegIntLType ¬ baseAndOffset];  InternalThreadType: TYPE = MACHINE DEPENDENT RECORD [    fillerByte: Byte ¬ 0,    type: OMF.ThreadOrFixupType ¬ thread,    thredtype: MACHINE DEPENDENT{targetThread(0), frameThread(1)} ¬ targetThread,    z: BOOLEAN ¬ FALSE,    method: [0..8) ¬ 0,    thred: [0..4) ¬ 0];  Object: PUBLIC TYPE = InternalOMFDef.Object;  RecordType: TYPE = OMF.RecordType;  <<  *******************     PUBLIC Put routines for individual records     *******************  >>  PutBlockDefinition: PUBLIC PROCEDURE [    handle: Handle, blockPointer: LONG POINTER TO OMF.BlockDefinition] =    BEGIN    checksum: Byte;    length: CARDINAL;    procedureInfo: Byte ¬ 0;    length ¬      7 + GetBaseLength[handle: handle, basePtr: @blockPointer.base] +        blockPointer.blockInfo.name.length;    IF blockPointer.procedureInfo.procedureDefinition THEN      BEGIN      length ¬        length + (IF blockPointer.procedureInfo.isLongProcedure THEN 4 ELSE 2);      END;    IF blockPointer.blockInfo.name.length > 0 THEN      length ¬        length + GetIndexLength[handle: handle, index: blockPointer.typeIndex];    checksum ¬      (WriteHeaderInfo[handle: handle, type: blockDefinition, length: length] +         PutBase[handle: handle, basePtr: @blockPointer.base] + PutName[         handle: handle, name: blockPointer.blockInfo.name] + PutCardinal[         handle: handle, cardinal: blockPointer.blockInfo.offset] + PutCardinal[         handle: handle, cardinal: blockPointer.blockInfo.length]) MOD 400B;    IF blockPointer.procedureInfo.procedureDefinition THEN procedureInfo ¬ 128;    IF blockPointer.procedureInfo.isLongProcedure THEN      procedureInfo ¬ procedureInfo + 64;    checksum ¬ (checksum + procedureInfo) MOD 400B;    Stream.PutByte[sH: handle.streamHandle, byte: procedureInfo];    IF blockPointer.procedureInfo.procedureDefinition THEN      BEGIN      IF blockPointer.procedureInfo.isLongProcedure THEN        BEGIN        checksum ¬          (checksum + PutLongCardinal[             handle: handle,             longCardinal: blockPointer.procedureInfo.returnAddress]) MOD 400B;        END      ELSE        BEGIN        checksum ¬          (checksum + PutCardinal[             handle: handle,             cardinal: CARDINAL[blockPointer.procedureInfo.returnAddress]]) MOD            400B;        END;      END;    IF blockPointer.blockInfo.name.length > 0 THEN      checksum ¬        (checksum + PutIndex[           handle: handle, index: CARDINAL[blockPointer.typeIndex]]) MOD 400B;    PutChecksum[handle: handle, checksum: checksum];    END;  PutBlockEnd: PUBLIC PROCEDURE [handle: Handle] =    BEGIN    checksum: Byte;    checksum ¬ WriteHeaderInfo[handle: handle, type: blockEnd, length: 1];    PutChecksum[handle: handle, checksum: checksum];    END;  PutComment: PUBLIC PROCEDURE [    commentPtr: LONG POINTER TO OMF.CommentData, handle: Handle] =    BEGIN    CommentOptions: TYPE = MACHINE DEPENDENT RECORD [      pad(0:0..7): [0..256),      notPurgeable(0:8..8): BOOLEAN,      notListable(0:9..9): BOOLEAN,      zeros(0:10..15): [0..64)];    byte: Byte;    checksum: Byte;    options: CommentOptions ¬ [      pad: 0, notPurgeable: ~commentPtr.purgeable, notListable: ~commentPtr.list,      zeros: 0];    checksum ¬ WriteHeaderInfo[      handle: handle, type: comment, length: commentPtr.comment.length + 3];    byte ¬ ORD[commentPtr.class];    checksum ¬ (checksum + byte) MOD 400B;    Stream.PutByte[sH: handle.streamHandle, byte: byte];    byte ¬ LOOPHOLE[options, CARDINAL] MOD 400B;    checksum ¬ (checksum + byte) MOD 400B;    Stream.PutByte[sH: handle.streamHandle, byte: byte];    checksum ¬      (checksum + PutString[handle: handle, string: commentPtr.comment]) MOD 400B;    PutChecksum[handle: handle, checksum: checksum];    END;  PutDebugSymbols: PUBLIC PROCEDURE [    debugSymbolsPtr: LONG POINTER TO OMF.DebugSymbols, handle: Handle] =    BEGIN    checksum: Byte;    byte: Byte ¬ 0;    length: CARDINAL;    tempPtr: LONG POINTER TO OMF.SymbolsRecord ¬ debugSymbolsPtr.entries;    IF debugSymbolsPtr.frameInformation.based = based THEN byte ¬ 128;    IF debugSymbolsPtr.frameInformation.addressLength = long THEN byte ¬ byte + 64;    length ¬ 2;    WITH debugSymbolsPtr.frameInformation SELECT FROM      basedSymbol => {        length ¬ length + GetBaseLength[handle: handle, basePtr: @base]};      extIndex => {        length ¬ length + GetIndexLength[handle: handle, index: externalIndex];        byte ¬ byte + 1};      blokIndex => {        length ¬ length + GetIndexLength[handle: handle, index: blockIndex];        byte ¬ byte + 2};      ENDCASE => ERROR;    UNTIL tempPtr = NIL DO      length ¬        length + tempPtr.symbol.length + 3 + GetIndexLength[          handle: handle, index: tempPtr.typeIndex];      tempPtr ¬ tempPtr.next;      ENDLOOP;    checksum ¬      (WriteHeaderInfo[handle: handle, type: debugSymbol, length: length] + byte)        MOD 400B;    Stream.PutByte[sH: handle.streamHandle, byte: byte];    WITH debugSymbolsPtr.frameInformation SELECT FROM      basedSymbol => {        checksum ¬ (checksum + PutBase[handle: handle, basePtr: @base]) MOD 400B};      extIndex => {        checksum ¬          (checksum + PutIndex[handle: handle, index: externalIndex]) MOD 400B};      blokIndex => {        checksum ¬          (checksum + PutIndex[handle: handle, index: blockIndex]) MOD 400B};      ENDCASE => ERROR;    tempPtr ¬ debugSymbolsPtr.entries;    UNTIL tempPtr = NIL DO      checksum ¬        (checksum + PutName[handle: handle, name: tempPtr.symbol] + PutCardinal[           handle: handle, cardinal: tempPtr.offset] + PutIndex[           handle: handle, index: tempPtr.typeIndex]) MOD 400B;      tempPtr ¬ tempPtr.next;      ENDLOOP;    PutChecksum[handle: handle, checksum: checksum];    END;  PutEndRecord: PUBLIC PROCEDURE [endType: OMF.EndType, handle: Handle] =    BEGIN    checksum: Byte;    byte: Byte;    checksum ¬ WriteHeaderInfo[handle: handle, type: endRecord, length: 2];    Stream.PutByte[sH: handle.streamHandle, byte: (byte ¬ ORD[endType])];    checksum ¬ (checksum + byte) MOD 400B;    PutChecksum[handle: handle, checksum: checksum];    END;  PutExternalNames: PUBLIC PROCEDURE [    externalNamesPtr: OMF.ExternalNamesSeq, handle: Handle] =    BEGIN    checksum: Byte;    length: CARDINAL ¬ 1;    FOR index: CARDINAL IN [1..externalNamesPtr.length) DO      IF externalNamesPtr.seq[index].resolved THEN LOOP;      length ¬        length + 1 + externalNamesPtr.seq[index].extName.length + GetIndexLength[          handle: handle, index: externalNamesPtr.seq[index].typeIndex];      ENDLOOP;    IF length = 1 THEN RETURN;  -- all external names resolved    checksum ¬ WriteHeaderInfo[      handle: handle, type: externalDefinition, length: length];    FOR index: CARDINAL IN [1..externalNamesPtr.length) DO      checksum ¬        (checksum + PutName[           handle: handle, name: externalNamesPtr.seq[index].extName] + PutIndex[           handle: handle, index: externalNamesPtr.seq[index].typeIndex]) MOD 400B;      ENDLOOP;    PutChecksum[handle: handle, checksum: checksum];    END;  PutFixup: PUBLIC PROCEDURE [    fixupPtr: LONG POINTER TO OMF.FixupData, handle: Handle] =    BEGIN    checksum: Byte;    length: CARDINAL ¬ 1;    tempPtr: LONG POINTER TO OMF.FixupData ¬ fixupPtr;    UNTIL tempPtr = NIL DO      WITH alias: tempPtr SELECT FROM        thread => {          length ¬ length + ThreadRecordLength[fixupPtr: @alias, handle: handle]};        fixup => {          length ¬ length + FixupRecordLength[fixupPtr: @alias, handle: handle]};        ENDCASE => ERROR;      tempPtr ¬ tempPtr.next;      ENDLOOP;    checksum ¬ WriteHeaderInfo[handle: handle, type: fixUp, length: length];    tempPtr ¬ fixupPtr;    UNTIL tempPtr = NIL DO      WITH alias: tempPtr SELECT FROM        thread => {          checksum ¬            (checksum + WriteThreadInfo[handle: handle, fixupPtr: @alias]) MOD              400B};        fixup => {          checksum ¬            (checksum + WriteFixupInfo[handle: handle, fixupPtr: @alias]) MOD              400B};        ENDCASE => ERROR;      tempPtr ¬ tempPtr.next;      ENDLOOP;    PutChecksum[handle: handle, checksum: checksum];    END;  PutGroupDefinition: PUBLIC PROCEDURE [    groupDefinitionPtr: LONG POINTER TO OMF.GroupDefinitionData, handle: Handle] =    BEGIN    LTLData: TYPE = MACHINE DEPENDENT RECORD [      unused: [0..16384), bigGroupLength: BOOLEAN, bigGroupMaxlength: BOOLEAN];    byte: Byte;    checksum: Byte;    componentType: OMF.GroupComponentEnumerated;    length: CARDINAL;    ltlByte: LTLData;    tempPtr: LONG POINTER TO OMF.GroupComponent ¬ groupDefinitionPtr.componentList;    length ¬      1 + GetIndexLength[handle: handle, index: groupDefinitionPtr.groupNameIndex];    UNTIL tempPtr = NIL DO      WITH tempPtr SELECT FROM        segmentIndexDef => {          length ¬            length + GetIndexLength[handle: handle, index: segmentIndex] + 1};        externalIndexDef => {          length ¬            length + GetIndexLength[handle: handle, index: externalIndex] + 1};        segmentClassOverlay => {          length ¬            length + GetIndexLength[handle: handle, index: segmentNameIndex] +              GetIndexLength[handle: handle, index: classNameIndex] +              GetIndexLength[handle: handle, index: overlayNameIndex] + 1};        loadTimeLocatableGroup => {length ¬ length + 6};        absoluteGroup => {length ¬ length + 4};        ENDCASE => ERROR;      tempPtr ¬ tempPtr.next;      ENDLOOP;    tempPtr ¬ groupDefinitionPtr.componentList;    checksum ¬      (WriteHeaderInfo[handle: handle, type: groupDefinition, length: length] +         PutIndex[handle: handle, index: groupDefinitionPtr.groupNameIndex]) MOD        400B;    UNTIL tempPtr = NIL DO      WITH tempPtr SELECT FROM        segmentIndexDef => {componentType ¬ segmentIndexDef};        externalIndexDef => {componentType ¬ externalIndexDef};        segmentClassOverlay => {componentType ¬ segmentClassOverlay};        loadTimeLocatableGroup => {componentType ¬ loadTimeLocatableGroup};        absoluteGroup => {componentType ¬ absoluteGroup};        ENDCASE => ERROR;      checksum ¬ (checksum + (byte ¬ ORD[componentType])) MOD 400B;      Stream.PutByte[sH: handle.streamHandle, byte: byte];      WITH tempPtr SELECT FROM        segmentIndexDef => {          checksum ¬            (checksum + PutIndex[handle: handle, index: segmentIndex]) MOD 400B};        externalIndexDef =>          checksum ¬            (checksum + PutIndex[handle: handle, index: externalIndex]) MOD 400B;        segmentClassOverlay =>          checksum ¬            (checksum + PutIndex[handle: handle, index: segmentNameIndex] +               PutIndex[handle: handle, index: classNameIndex] + PutIndex[               handle: handle, index: overlayNameIndex]) MOD 400B;        loadTimeLocatableGroup => {          IF maxGroupLength > LAST[CARDINAL] THEN            BEGIN ltlByte.bigGroupMaxlength ¬ TRUE; maxGroupLength ¬ 0; END;          IF groupLength > LAST[CARDINAL] THEN            BEGIN ltlByte.bigGroupLength ¬ TRUE; groupLength ¬ 0; END;          componentType ¬ loadTimeLocatableGroup;          checksum ¬            (checksum + (byte ¬ LOOPHOLE[componentType, CARDINAL] MOD 400B)) MOD              400B;          Stream.PutByte[sH: handle.streamHandle, byte: byte];          checksum ¬            (checksum + PutCardinal[               handle: handle, cardinal: CARDINAL[maxGroupLength]] + PutCardinal[               handle: handle, cardinal: CARDINAL[groupLength]]) MOD 400B};        absoluteGroup => {          checksum ¬            (checksum + PutCardinal[handle: handle, cardinal: frameNumber] +               (byte ¬ ORD[offset])) MOD 400B;          Stream.PutByte[sH: handle.streamHandle, byte: byte]};        ENDCASE => ERROR;      tempPtr ¬ tempPtr.next;      ENDLOOP;    PutChecksum[handle: handle, checksum: checksum];    END;  PutLineNumber: PUBLIC PROCEDURE [    lineNumberPtr: LONG POINTER TO OMF.LineNumberData, handle: Handle] =    BEGIN    checksum: Byte;    length: CARDINAL;    length ¬      GetBaseLength[handle: handle, basePtr: @lineNumberPtr.base] +        4 * lineNumberPtr.numberOfEntries + 1;    checksum ¬      (WriteHeaderInfo[handle: handle, type: lineNumber, length: length] + PutBase[         handle: handle, basePtr: @lineNumberPtr.base]) MOD 400B;    FOR index: CARDINAL IN [0..lineNumberPtr.numberOfEntries) DO      checksum ¬        (checksum + PutCardinal[           handle: handle, cardinal: lineNumberPtr.seq[index].lineNumber] +           PutCardinal[           handle: handle, cardinal: lineNumberPtr.seq[index].lineNumberOffset])          MOD 400B;      ENDLOOP;    PutChecksum[handle: handle, checksum: checksum];    END;  PutListOfNames: PUBLIC PROCEDURE [    nameList: LONG POINTER TO OMF.ListOfNamesData, handle: Handle] =    BEGIN    checksum: Byte;    length: CARDINAL;    length ¬ nameList.length;    FOR index: CARDINAL IN [1..nameList.length) DO      length ¬ length + nameList.seq[index].length; ENDLOOP;    checksum ¬ WriteHeaderInfo[handle: handle, type: listOfNames, length: length];    FOR index: CARDINAL IN [1..nameList.length) DO      checksum ¬        (checksum + PutName[handle: handle, name: nameList.seq[index]]) MOD 400B;      ENDLOOP;    PutChecksum[handle: handle, checksum: checksum];    END;  PutLogicalEnumeratedData: PUBLIC PROCEDURE [    logicalEnumeratedDataPtr: LONG POINTER TO OMF.LogicalEnumeratedData,    handle: Handle] =    BEGIN    byte: Byte;    checksum: Byte;    length: CARDINAL;    length ¬      3 + GetIndexLength[        handle: handle, index: logicalEnumeratedDataPtr.segmentIndex] +        logicalEnumeratedDataPtr.dataPtr.length;    checksum ¬      (WriteHeaderInfo[handle: handle, type: logicalEnumeratedData, length: length]         + PutIndex[handle: handle, index: logicalEnumeratedDataPtr.segmentIndex] +         PutCardinal[         handle: handle,         cardinal: CARDINAL[logicalEnumeratedDataPtr.enumeratedDataOffset]]) MOD        400B;    FOR index: CARDINAL IN [0..logicalEnumeratedDataPtr.dataPtr.length) DO      checksum ¬        (checksum + (byte ¬ logicalEnumeratedDataPtr.dataPtr.seq[index])) MOD 400B;      Stream.PutByte[sH: handle.streamHandle, byte: byte];      ENDLOOP;    PutChecksum[handle: handle, checksum: checksum];    END;  PutLogicalIteratedData: PUBLIC PROCEDURE [    logicalIteratedDataPtr: LONG POINTER TO OMF.LogicalIteratedData,    handle: Handle] =    BEGIN    checksum: Byte;    length: CARDINAL;    length ¬      3 + GetIndexLength[        handle: handle, index: logicalIteratedDataPtr.segmentIndex] +        GetIteratedDataLength[        handle: handle,        iteratedDataPtr: logicalIteratedDataPtr.iteratedDataBlockPtr];    checksum ¬      (WriteHeaderInfo[handle: handle, type: logicalIteratedData, length: length] +         PutIndex[handle: handle, index: logicalIteratedDataPtr.segmentIndex] +         PutCardinal[         handle: handle,         cardinal: CARDINAL[logicalIteratedDataPtr.iteratedDataOffset]] +         PutIteratedData[         handle: handle,         iteratedDataPtr: logicalIteratedDataPtr.iteratedDataBlockPtr]) MOD 400B;    PutChecksum[handle: handle, checksum: checksum];    END;  PutLModuleName: PUBLIC PROCEDURE [handle: Handle, lName: LONG STRING] =    BEGIN    checksum: Byte;    checksum ¬      (WriteHeaderInfo[handle: handle, type: lHeader, length: lName.length + 2] +         PutName[handle: handle, name: lName]) MOD 400B;    PutChecksum[handle: handle, checksum: checksum];    END;  PutModuleEnd: PUBLIC PROCEDURE [    handle: Handle, moduleEndRecordPtr: LONG POINTER TO OMF.ModuleEndData] =    BEGIN    byte: Byte;    checksum: Byte;    length: NATURAL ¬ 2;    IF moduleEndRecordPtr.moduleType.hasStartAddress THEN      BEGIN      WITH moduleEndRecordPtr SELECT FROM        logicalAddr => {          length ¬            length + GetLogicalAddressLength[              handle: handle, addressPtr: @address]};        physicalAddr => {length ¬ length + 4};        ENDCASE => ERROR;      END;    checksum ¬      (WriteHeaderInfo[handle: handle, type: moduleEnd, length: length] +         (byte ¬ LOOPHOLE[moduleEndRecordPtr.moduleType, CARDINAL] MOD 400B)) MOD        400B;    Stream.PutByte[sH: handle.streamHandle, byte: byte];    IF moduleEndRecordPtr.moduleType.hasStartAddress THEN      BEGIN      WITH moduleEndRecordPtr SELECT FROM        logicalAddr =>          checksum ¬            (checksum + PutLogicalAddress[handle: handle, addressPtr: @address])              MOD 400B;        physicalAddr =>          checksum ¬            (checksum + PutCardinal[handle: handle, cardinal: frameNumber] +               PutCardinal[handle: handle, cardinal: CARDINAL[offset]]) MOD 400B;        ENDCASE => ERROR;      END;    PutChecksum[handle: handle, checksum: checksum];    END;  PutPhysicalEnumeratedData: PUBLIC PROCEDURE [    physicalEnumeratedDataPtr: LONG POINTER TO OMF.PhysicalEnumeratedData,    handle: Handle] =    BEGIN    byte: Byte;    checksum: Byte;    length: CARDINAL;    length ¬ 4 + physicalEnumeratedDataPtr.dataPtr.length;    checksum ¬      (WriteHeaderInfo[         handle: handle, type: physicalEnumeratedData, length: length] +         PutCardinal[         handle: handle, cardinal: physicalEnumeratedDataPtr.frameNumber] +         (byte ¬ physicalEnumeratedDataPtr.offset)) MOD 400B;    Stream.PutByte[sH: handle.streamHandle, byte: byte];    FOR index: CARDINAL IN [0..physicalEnumeratedDataPtr.dataPtr.length) DO      checksum ¬        (checksum + (byte ¬ physicalEnumeratedDataPtr.dataPtr.seq[index])) MOD          400B;      Stream.PutByte[sH: handle.streamHandle, byte: byte];      ENDLOOP;    PutChecksum[handle: handle, checksum: checksum];    END;  PutPhysicalIteratedData: PUBLIC PROCEDURE [    physicalIteratedDataPtr: LONG POINTER TO OMF.PhysicalIteratedData,    handle: Handle] =    BEGIN    byte: Byte;    checksum: Byte;    length: CARDINAL;    length ¬      4 + GetIteratedDataLength[        handle: handle,        iteratedDataPtr: physicalIteratedDataPtr.iteratedDataBlockPtr];    checksum ¬      (WriteHeaderInfo[handle: handle, type: physicalIteratedData, length: length]         + PutCardinal[         handle: handle, cardinal: physicalIteratedDataPtr.frameNumber]) MOD 400B;    byte ¬ physicalIteratedDataPtr.offset;    Stream.PutByte[sH: handle.streamHandle, byte: byte];    checksum ¬      (checksum + PutIteratedData[         handle: handle,         iteratedDataPtr: physicalIteratedDataPtr.iteratedDataBlockPtr]) MOD 400B;    PutChecksum[handle: handle, checksum: checksum];    END;  PutPublicNames: PUBLIC PROCEDURE [    publicNamesPtr: LONG POINTER TO OMF.PublicNamesData, handle: Handle] =    BEGIN    checksum: Byte;    length: CARDINAL;    tempPtr: LONG POINTER TO OMF.PublicNamesNode ¬ publicNamesPtr.namesList;    length ¬      1 + GetBaseLength[handle: handle, basePtr: @publicNamesPtr.publicBase];    UNTIL tempPtr = NIL DO      length ¬        length + 3 + tempPtr.publicName.length + GetIndexLength[          handle: handle, index: tempPtr.typeIndex];      tempPtr ¬ tempPtr.next;      ENDLOOP;    tempPtr ¬ publicNamesPtr.namesList;    checksum ¬      (WriteHeaderInfo[handle: handle, type: publicDefinition, length: length] +         PutBase[handle: handle, basePtr: @publicNamesPtr.publicBase]) MOD 400B;    UNTIL tempPtr = NIL DO      checksum ¬        (checksum + PutName[handle: handle, name: tempPtr.publicName] +           PutCardinal[handle: handle, cardinal: CARDINAL[tempPtr.publicOffset]] +           PutIndex[handle: handle, index: tempPtr.typeIndex]) MOD 400B;      tempPtr ¬ tempPtr.next;      ENDLOOP;    PutChecksum[handle: handle, checksum: checksum];    END;  PutRegisterInitialization: PUBLIC PROCEDURE [    handle: Handle,    registerInitPtr: LONG POINTER TO OMF.RegisterInitializationData] =    BEGIN    byte: Byte;    checksum: Byte ¬ 0;    length: CARDINAL ¬ 1;    tempPtr: LONG POINTER TO OMF.RegisterInitializationData ¬ registerInitPtr;    tempValue: InternalRegisterInit ¬ LOOPHOLE[tempPtr.registerType,      InternalRegisterInit];    UNTIL tempPtr = NIL DO      WITH tempPtr SELECT FROM        baseAndOffset => {          tempValue.l ¬ baseAndOffset;          length ¬            length + GetBaseLength[handle: handle, basePtr: @base] + 1 +              (SELECT registerType.registerID FROM                 CSandIP, SSandSP => 2,                 ENDCASE => 0)};        logicalAddr => {          tempValue.l ¬ logicalAddr;          length ¬            length + GetLogicalAddressLength[handle: handle, addressPtr: @address]              + 1};        ENDCASE => ERROR;      tempPtr ¬ tempPtr.next;      ENDLOOP;    checksum ¬ WriteHeaderInfo[      handle: handle, type: registerInitialization, length: length];    tempPtr ¬ registerInitPtr;    UNTIL tempPtr = NIL DO      byte ¬ LOOPHOLE[tempValue, CARDINAL] MOD 400B;      Stream.PutByte[sH: handle.streamHandle, byte: byte];      checksum ¬ (checksum + byte) MOD 400B;      WITH tempPtr SELECT FROM        baseAndOffset => {          checksum ¬            (checksum + PutBase[handle: handle, basePtr: @base] +               (SELECT registerType.registerID FROM                  CSandIP, SSandSP => PutCardinal[                    handle: handle, cardinal: registerOffset],                  ENDCASE => 0)) MOD 400B;          };        logicalAddr => {          checksum ¬            (checksum + PutLogicalAddress[handle: handle, addressPtr: @address])              MOD 400B};        ENDCASE => ERROR;      tempPtr ¬ tempPtr.next;      ENDLOOP;    PutChecksum[handle: handle, checksum: checksum];    END;  PutRelocatableEnumeratedData: PUBLIC PROCEDURE [    relocatableEnumeratedDataPtr: LONG POINTER TO OMF.RelocatableEnumeratedData,    handle: Handle] =    BEGIN    byte: Byte;    checksum: Byte;    length: CARDINAL;    length ¬      3 + GetBaseLength[        handle: handle, basePtr: @relocatableEnumeratedDataPtr.base] +        relocatableEnumeratedDataPtr.iteratedDataBlockPtr.length;    checksum ¬      (WriteHeaderInfo[         handle: handle, type: relocatableEnumeratedData, length: length] +         PutBase[handle: handle, basePtr: @relocatableEnumeratedDataPtr.base] +         PutCardinal[         handle: handle,         cardinal: CARDINAL[relocatableEnumeratedDataPtr.enumeratedDataOffset]])        MOD 400B;    FOR index: CARDINAL IN      [0..relocatableEnumeratedDataPtr.iteratedDataBlockPtr.length) DO      checksum ¬        (checksum +           (byte ¬ relocatableEnumeratedDataPtr.iteratedDataBlockPtr.seq[index]))          MOD 400B;      Stream.PutByte[sH: handle.streamHandle, byte: byte];      ENDLOOP;    PutChecksum[handle: handle, checksum: checksum];    END;  PutRelocatableIteratedData: PUBLIC PROCEDURE [    relocatableIteratedDataPtr: LONG POINTER TO OMF.RelocatableIteratedData,    handle: Handle] =    BEGIN    checksum: Byte;    length: CARDINAL;    length ¬      3 + GetBaseLength[handle: handle, basePtr: @relocatableIteratedDataPtr.base]        + GetIteratedDataLength[        handle: handle,        iteratedDataPtr: relocatableIteratedDataPtr.iteratedDataBlockPtr];    checksum ¬      (WriteHeaderInfo[         handle: handle, type: relocatableIteratedData, length: length] + PutBase[         handle: handle, basePtr: @relocatableIteratedDataPtr.base] + PutCardinal[         handle: handle, cardinal: CARDINAL[relocatableIteratedDataPtr.offset]] +         PutIteratedData[         handle: handle,         iteratedDataPtr: relocatableIteratedDataPtr.iteratedDataBlockPtr]) MOD        400B;    PutChecksum[handle: handle, checksum: checksum];    END;  PutSegmentDefinition: PUBLIC PROCEDURE [    segmentDefinitionPtr: LONG POINTER TO OMF.SegmentDefinitionData,    handle: Handle] =    BEGIN    checksum: Byte;    length: CARDINAL ¬ 4;    indicesLength: CARDINAL;    byte: Byte;    indicesLength ¬      GetIndexLength[handle: handle, index: segmentDefinitionPtr.segmentNameIndex]        + GetIndexLength[        handle: handle, index: segmentDefinitionPtr.classNameIndex] +        GetIndexLength[        handle: handle, index: segmentDefinitionPtr.overlayNameIndex];    SELECT segmentDefinitionPtr.ACBP.align FROM      abs => length ¬ length + indicesLength + 3;      unNamed => length ¬ length + 3;      LTL => length ¬ length + indicesLength + 5;      ENDCASE => length ¬ length + indicesLength;    IF segmentDefinitionPtr.segmentLength > LAST[CARDINAL] THEN {      segmentDefinitionPtr.ACBP.exactly64K ¬ TRUE;      segmentDefinitionPtr.segmentLength ¬ 0};    checksum ¬ WriteHeaderInfo[      handle: handle, type: segmentDefinition, length: length];    byte ¬ LOOPHOLE[segmentDefinitionPtr.ACBP, CARDINAL] / 400B;    Stream.PutByte[sH: handle.streamHandle, byte: byte];    checksum ¬ (checksum + byte) MOD 400B;    SELECT segmentDefinitionPtr.ACBP.align FROM      abs, unNamed => {        checksum ¬          (checksum + PutCardinal[             handle: handle, cardinal: segmentDefinitionPtr.frameNumber]) MOD 400B;        checksum ¬ (checksum + segmentDefinitionPtr.offset) MOD 400B;        Stream.PutByte[          sH: handle.streamHandle, byte: segmentDefinitionPtr.offset]};      LTL => {        Stream.PutByte[          sH: handle.streamHandle,          byte:          (byte ¬ LOOPHOLE[segmentDefinitionPtr.ltlData, CARDINAL] MOD 400B)];        checksum ¬          (checksum + byte + PutCardinal[             handle: handle,             cardinal: CARDINAL[segmentDefinitionPtr.maxSegmentLength]] +             PutCardinal[             handle: handle, cardinal: CARDINAL[segmentDefinitionPtr.groupOffset]])            MOD 400B};      ENDCASE;    checksum ¬      (checksum + PutCardinal[         handle: handle, cardinal: CARDINAL[segmentDefinitionPtr.segmentLength]])        MOD 400B;    IF segmentDefinitionPtr.ACBP.align # unNamed THEN      checksum ¬        (checksum + PutIndex[           handle: handle, index: segmentDefinitionPtr.segmentNameIndex] +           PutIndex[handle: handle, index: segmentDefinitionPtr.classNameIndex] +           PutIndex[handle: handle, index: segmentDefinitionPtr.overlayNameIndex])          MOD 400B;    PutChecksum[handle: handle, checksum: checksum];    END;  PutTModuleName: PUBLIC PROCEDURE [handle: Handle, tName: LONG STRING] =    BEGIN    checksum: Byte;    checksum ¬      (WriteHeaderInfo[handle: handle, type: tHeader, length: tName.length + 2] +         PutName[handle: handle, name: tName]) MOD 400B;    PutChecksum[handle: handle, checksum: checksum];    END;  PutTypeDefinition: PUBLIC PROCEDURE [    handle: Handle, typeDefinitionPtr: LONG POINTER TO OMF.TypeDefinition] =    BEGIN    checksum: Byte;    length: NATURAL;    tempPtr: LONG POINTER TO OMF.EightLeafDescriptor ¬      typeDefinitionPtr.eightLeafDescriptor;    length ¬ 2 + typeDefinitionPtr.name.length;    UNTIL tempPtr = NIL DO      length ¬        length + GetEightLeafDescLength[handle: handle, eightLeafDescPtr: tempPtr];      tempPtr ¬ tempPtr.next;      ENDLOOP;    checksum ¬ WriteHeaderInfo[      handle: handle, type: typeDefinition, length: length];    checksum ¬      (checksum + PutName[handle: handle, name: typeDefinitionPtr.name]) MOD 400B;    tempPtr ¬ typeDefinitionPtr.eightLeafDescriptor;    UNTIL tempPtr = NIL DO      checksum ¬        (checksum + PutEightLeafDescriptor[           handle: handle, eightLeafDescPtr: tempPtr]) MOD 400B;      tempPtr ¬ tempPtr.next;      ENDLOOP;    PutChecksum[handle: handle, checksum: checksum];    END;  FixupRecordLength: PROCEDURE [    fixupPtr: LONG POINTER TO OMF.FixupData, handle: Handle]    RETURNS [length: CARDINAL] =    BEGIN    WITH fixupPtr SELECT FROM      fixup => {        length ¬          2 + GetLogicalAddressLength[            handle: handle, addressPtr: @address,            targetDispLength:            (IF locat.targetDispLen = twoBytes THEN twoBytes ELSE threeBytes)]};      ENDCASE => ERROR;    END;  GetBaseLength: PROCEDURE [handle: Handle, basePtr: LONG POINTER TO OMF.Base]    RETURNS [baseLength: NATURAL] =    BEGIN    baseLength ¬      GetIndexLength[handle: handle, index: basePtr.groupIndex] + GetIndexLength[        handle: handle, index: basePtr.segmentIndex];    IF (basePtr.segmentIndex = 0) AND (basePtr.groupIndex = 0) THEN      baseLength ¬ baseLength + 2;    END;  GetEightLeafDescLength: PROCEDURE [    handle: Handle, eightLeafDescPtr: LONG POINTER TO OMF.EightLeafDescriptor]    RETURNS [length: NATURAL] =    BEGIN    length ¬ 1;    FOR index: NATURAL IN [0..8) DO      length ¬        length + GetLeafDescLength[          handle: handle, leafDescPtr: eightLeafDescPtr.leafDescriptors[index]];      ENDLOOP;    END;  GetIndexLength: PROCEDURE [handle: Handle, index: NATURAL]    RETURNS [indexLength: NATURAL] =    BEGIN indexLength ¬ IF index < 128 THEN 1 ELSE 2; END;  GetIteratedDataLength: PROCEDURE [    handle: Handle, iteratedDataPtr: LONG POINTER TO OMF.IteratedBlock]    RETURNS [length: NATURAL] =    BEGIN    tempPtr: LONG POINTER TO OMF.IteratedBlock ¬ iteratedDataPtr;    length ¬ 0;    UNTIL tempPtr = NIL DO      length ¬        length + 4 +          (IF tempPtr.dataPtr = NIL THEN 0 ELSE (tempPtr.dataPtr.length + 1));      tempPtr ¬ tempPtr.next;      ENDLOOP;    END;  GetLeafDescLength: PROCEDURE [    handle: Handle, leafDescPtr: LONG POINTER TO OMF.LeafDescriptor]    RETURNS [length: NATURAL] =    BEGIN    length ¬ 0;    IF leafDescPtr = NIL THEN RETURN;    WITH leafDescPtr SELECT FROM      nullLeaf, repeatLeaf => length ¬ 1;      numericLeaf => length ¬ 1;      cardinal => length ¬ 3;      name => length ¬ 2 + nameString.length;      index => length ¬ GetIndexLength[handle: handle, index: indexValue] + 1;      threeByte => length ¬ 4;      signedByte => length ¬ 2;      integer => length ¬ 3;      longCardinal => length ¬ 5;      ENDCASE;    END;  GetLogicalAddressLength: PROCEDURE [    handle: Handle, addressPtr: LONG POINTER TO OMF.LogicalAddress,    targetDispLength: {twoBytes, threeBytes} ¬ twoBytes]    RETURNS [length: NATURAL] =    BEGIN    length ¬ 1;    WITH addressPtr.frameSpec SELECT FROM      explicitly => {        SELECT frameMethod FROM          segmentIndex, groupIndex, externalIndex => {            length ¬              length + GetIndexLength[                handle: handle, index: addressPtr.frameDatum]};          frameNumber => {length ¬ length + 2};          ENDCASE};      byThread => NULL;      ENDCASE;    WITH addressPtr.targetSpec SELECT FROM      explicitly => {        SELECT targetMethod FROM          frameNumberWithDisp, frameNumber => {length ¬ length + 2};          ENDCASE =>            length ¬              length + GetIndexLength[                handle: handle, index: addressPtr.frameDatum];        SELECT targetMethod FROM          segmentIndexWithDisp, groupIndexWithDisp, externalIndexWithDisp,            frameNumberWithDisp => {            SELECT targetDispLength FROM              twoBytes => {length ¬ length + 2};              threeBytes => {ERROR << this is currently not allowed >> };              ENDCASE};          ENDCASE};      byThread => NULL;      ENDCASE;    END;  PutBase: PROCEDURE [handle: Handle, basePtr: LONG POINTER TO OMF.Base]    RETURNS [checksum: Byte] =    BEGIN    checksum ¬      (PutIndex[handle: handle, index: basePtr.groupIndex] + PutIndex[         handle: handle, index: basePtr.segmentIndex]) MOD 400B;    IF (basePtr.segmentIndex = 0) AND (basePtr.groupIndex = 0) THEN      checksum ¬        (checksum + PutCardinal[handle: handle, cardinal: basePtr.frameNumber]) MOD          400B;    END;  PutCardinal: PROCEDURE [handle: Handle, cardinal: CARDINAL]    RETURNS [checksum: Byte] =    BEGIN    checksum ¬ ((cardinal MOD 400B) + (cardinal / 400B)) MOD 400B;    Stream.PutByte[sH: handle.streamHandle, byte: cardinal MOD 400B];    Stream.PutByte[sH: handle.streamHandle, byte: cardinal / 400B]    END;  PutChecksum: PROCEDURE [handle: Handle, checksum: Byte] =    BEGIN    Stream.PutByte[      sH: handle.streamHandle, byte: IF checksum > 0 THEN (400B - checksum)        ELSE 0];      END;  PutEightLeafDescriptor: PROCEDURE [    handle: Handle, eightLeafDescPtr: LONG POINTER TO OMF.EightLeafDescriptor]    RETURNS [checksum: Byte] =    BEGIN    byte: Byte;    byte ¬ LOOPHOLE[eightLeafDescPtr.easyNice, Byte];    checksum ¬ byte;    Stream.PutByte[sH: handle.streamHandle, byte: byte];    FOR index: CARDINAL IN [0..8) DO      checksum ¬        (checksum + PutLeafDescriptor[           handle: handle, leafDescPtr: eightLeafDescPtr.leafDescriptors[index]])          MOD 400B;      ENDLOOP;    END;  PutIndex: PROCEDURE [handle: Handle, index: NATURAL] RETURNS [checksum: Byte] =    BEGIN    byte: Byte;    IF index < 128 THEN      BEGIN      Stream.PutByte[sH: handle.streamHandle, byte: (checksum ¬ index MOD 400B)];      END    ELSE      BEGIN      byte ¬ 128 + ((index / 256) MOD 128);      Stream.PutByte[sH: handle.streamHandle, byte: byte];      Stream.PutByte[sH: handle.streamHandle, byte: index MOD 400B];      checksum ¬ (index MOD 400B + byte) MOD 400B;      END;    END;  PutIteratedData: PROCEDURE [    handle: Handle, iteratedDataPtr: LONG POINTER TO OMF.IteratedBlock]    RETURNS [checksum: Byte] =    BEGIN    byte: Byte;    tempPtr: LONG POINTER TO OMF.IteratedBlock ¬ iteratedDataPtr;    checksum ¬ 0;    UNTIL tempPtr = NIL DO      checksum ¬        (checksum + PutCardinal[handle: handle, cardinal: tempPtr.repeatCount] +           PutCardinal[handle: handle, cardinal: tempPtr.blockCount]) MOD 400B;      IF tempPtr.dataPtr # NIL THEN        BEGIN        checksum ¬ (checksum + (byte ¬ tempPtr.dataPtr.length MOD 400B)) MOD 400B;        Stream.PutByte[sH: handle.streamHandle, byte: byte];        FOR index: NATURAL IN [0..tempPtr.dataPtr.length) DO          checksum ¬ (checksum + (byte ¬ tempPtr.dataPtr.seq[index])) MOD 400B;          Stream.PutByte[sH: handle.streamHandle, byte: byte];          ENDLOOP;        END;      tempPtr ¬ tempPtr.next;      ENDLOOP;    END;  PutLeafDescriptor: PROCEDURE [    handle: Handle, leafDescPtr: LONG POINTER TO OMF.LeafDescriptor]    RETURNS [checksum: Byte] =    BEGIN    byte: Byte;    temp: LONG CARDINAL;    checksum ¬ 0;    IF leafDescPtr = NIL THEN RETURN;    WITH leafDescPtr SELECT FROM      repeatLeaf => {        Stream.PutByte[sH: handle.streamHandle, byte: (checksum ¬ 133)]};      nullLeaf => {        Stream.PutByte[sH: handle.streamHandle, byte: (checksum ¬ 128)]};      numericLeaf => {        Stream.PutByte[sH: handle.streamHandle, byte: (checksum ¬ smallByte)]};      cardinal => {        Stream.PutByte[sH: handle.streamHandle, byte: 129];        checksum ¬          (129 + PutCardinal[handle: handle, cardinal: cardinalValue]) MOD 400B};      name => {        Stream.PutByte[sH: handle.streamHandle, byte: 130];        checksum ¬ (130 + PutName[handle: handle, name: nameString]) MOD 400B};      index => {        Stream.PutByte[sH: handle.streamHandle, byte: 131];        checksum ¬ (131 + PutIndex[handle: handle, index: indexValue]) MOD 400B};      threeByte => {        Stream.PutByte[sH: handle.streamHandle, byte: 132];        temp ¬ threeByteValue;        checksum ¬ 132;        FOR index: NATURAL IN [0..3) DO          byte ¬ CARDINAL[temp] MOD 400B;          temp ¬ temp / 400B;          checksum ¬ (checksum + byte) MOD 400B;          Stream.PutByte[sH: handle.streamHandle, byte: byte]          ENDLOOP};      signedByte => {        byte ¬ LOOPHOLE[signedByteValue, Byte];        Stream.PutByte[sH: handle.streamHandle, byte: 134];        checksum ¬ (134 + byte) MOD 400B};      integer => {        Stream.PutByte[sH: handle.streamHandle, byte: 135];        checksum ¬          (135 + PutCardinal[             handle: handle, cardinal: LOOPHOLE[integerValue, CARDINAL]]) MOD            400B};      longCardinal => {        Stream.PutByte[sH: handle.streamHandle, byte: 136];        checksum ¬          (136 + PutLongCardinal[handle: handle, longCardinal: longCardinalValue])            MOD 400B};      ENDCASE => ERROR;    END;  PutLogicalAddress: PROCEDURE [    handle: Handle, addressPtr: LONG POINTER TO OMF.LogicalAddress,    targetDispLength: {twoBytes, threeBytes} ¬ twoBytes] RETURNS [checksum: Byte] =    BEGIN    byte: Byte;    data: InternalFixupDataType;    WITH addressPtr.frameSpec SELECT FROM      explicitly => {        data.frameSpecMode ¬ explicitly; data.frame ¬ ORD[frameMethod]};      byThread => {data.frameSpecMode ¬ byThread; data.frame ¬ ORD[frameThread]};      ENDCASE => ERROR;    WITH addressPtr.targetSpec SELECT FROM      explicitly => {        data.targetSpecMode ¬ explicitly; data.target ¬ ORD[targetMethod]};      byThread => {        data.targetSpecMode ¬ byThread;        data.target ¬          ORD[targetThread] + (IF specification = secondary THEN 4 ELSE 0)};      ENDCASE => ERROR;    checksum ¬ byte ¬ LOOPHOLE[data, CARDINAL] MOD 400B;    Stream.PutByte[sH: handle.streamHandle, byte: byte];    WITH addressPtr.frameSpec SELECT FROM      explicitly => {        SELECT frameMethod FROM          segmentIndex, groupIndex, externalIndex => {            checksum ¬              (checksum + PutIndex[handle: handle, index: addressPtr.frameDatum])                MOD 400B};          frameNumber => {            checksum ¬              (checksum + PutCardinal[                 handle: handle, cardinal: addressPtr.frameDatum]) MOD 400B};          ENDCASE};      byThread => NULL;      ENDCASE;    WITH addressPtr.targetSpec SELECT FROM      explicitly => {        SELECT targetMethod FROM          frameNumberWithDisp, frameNumber => {            checksum ¬              (checksum + PutCardinal[                 handle: handle, cardinal: addressPtr.targetDatum]) MOD 400B};          ENDCASE =>            checksum ¬              (checksum + PutIndex[handle: handle, index: addressPtr.targetDatum])                MOD 400B;        SELECT targetMethod FROM          segmentIndexWithDisp, groupIndexWithDisp, externalIndexWithDisp,            frameNumberWithDisp => {            SELECT targetDispLength FROM              twoBytes => {                checksum ¬                  (checksum + PutCardinal[                     handle: handle,                     cardinal: CARDINAL[addressPtr.targetDisplacement]]) MOD 400B};              threeBytes => {ERROR << this is currently not allowed >> };              ENDCASE};          ENDCASE};      byThread => NULL;      ENDCASE;    END;  PutLongCardinal: PROCEDURE [handle: Handle, longCardinal: LONG CARDINAL]    RETURNS [checksum: Byte] =    BEGIN    byte: Byte;    checksum ¬ 0;    FOR index: NATURAL IN [0..4) DO      byte ¬ CARDINAL[longCardinal] MOD 400B;      checksum ¬ (checksum + byte) MOD 400B;      Stream.PutByte[sH: handle.streamHandle, byte: byte];      longCardinal ¬ longCardinal / 400B;      ENDLOOP;    END;  PutName: PROCEDURE [handle: Handle, name: LONG STRING] RETURNS [checksum: Byte] =    BEGIN    IF name.length > 40 THEN OMF.Error[type: nameToLong];    checksum ¬ name.length;    Stream.PutByte[sH: handle.streamHandle, byte: name.length];    checksum ¬ (checksum + PutString[handle: handle, string: name]) MOD 400B;    END;  PutString: PROCEDURE [handle: Handle, string: LONG STRING]    RETURNS [checksum: Byte] =    BEGIN    byte: Byte;    checksum ¬ 0;    FOR index: CARDINAL IN [0..string.length) DO      Stream.PutByte[sH: handle.streamHandle, byte: byte ¬ (string[index] - 0C)];      checksum ¬ (checksum + byte) MOD 400B;      ENDLOOP;    END;  ThreadRecordLength: PROCEDURE [    fixupPtr: LONG POINTER TO OMF.FixupData, handle: Handle]    RETURNS [length: CARDINAL] =    BEGIN    WITH alias: fixupPtr SELECT FROM      thread => {        WITH alias SELECT FROM          targetThread => {            SELECT targetSpec FROM              frameNumber => length ¬ 3;              ENDCASE =>                length ¬                  GetIndexLength[handle: handle, index: alias.indexORFrameNumber] +                    1};          frameThread => {            SELECT frameSpec FROM              frameNumber => {length ¬ 3};              segmentIndex, groupIndex, externalIndex, location, target =>                length ¬                  GetIndexLength[handle: handle, index: alias.indexORFrameNumber] +                    1;              ENDCASE => ERROR};          ENDCASE => ERROR};      ENDCASE;    END;  WriteFixupInfo: PROCEDURE [    handle: Handle, fixupPtr: LONG POINTER TO OMF.FixupData]    RETURNS [checksum: Byte] =    BEGIN    byte: Byte;    WITH fixupPtr SELECT FROM      fixup => {        checksum ¬ byte ¬ LOOPHOLE[locat, CARDINAL] / 400B;        Stream.PutByte[sH: handle.streamHandle, byte: byte];        byte ¬ LOOPHOLE[locat, CARDINAL] MOD 400B;        Stream.PutByte[sH: handle.streamHandle, byte: byte];        checksum ¬          (checksum + byte + PutLogicalAddress[             handle: handle, addressPtr: @address,             targetDispLength:             (IF locat.targetDispLen = twoBytes THEN twoBytes ELSE threeBytes)])            MOD 400B};      ENDCASE => ERROR;    END;  WriteHeaderInfo: PROCEDURE [    handle: Handle, type: InternalRecordType, length: CARDINAL]    RETURNS [checksum: Byte] =    BEGIN    checksum ¬ ORD[type];    Stream.PutByte[sH: handle.streamHandle, byte: checksum];    checksum ¬ (checksum + (length MOD 400B) + (length / 400B)) MOD 400B;    Stream.PutByte[sH: handle.streamHandle, byte: length MOD 400B];    Stream.PutByte[sH: handle.streamHandle, byte: length / 400B];    END;  WriteThreadInfo: PROCEDURE [    handle: Handle, fixupPtr: LONG POINTER TO OMF.FixupData]    RETURNS [checksum: Byte] =    BEGIN    byte: Byte;    trdDat: InternalThreadType;    WITH alias: fixupPtr SELECT FROM      thread => {        WITH alias SELECT FROM          targetThread => {            trdDat ¬ [              type: thread, thredtype: targetThread, method: ORD[targetSpec],              thred: alias.thred]};          frameThread => {            trdDat ¬ [              type: thread, thredtype: frameThread, method: ORD[frameSpec],              thred: alias.thred]};          ENDCASE => ERROR};      ENDCASE => ERROR;    byte ¬ LOOPHOLE[trdDat, CARDINAL] MOD 400B;    Stream.PutByte[sH: handle.streamHandle, byte: byte];    WITH alias: fixupPtr SELECT FROM      thread => {        WITH alias SELECT FROM          targetThread => {            SELECT targetSpec FROM              frameNumber =>                checksum ¬ PutCardinal[                  handle: handle, cardinal: alias.indexORFrameNumber];              ENDCASE =>                checksum ¬ PutIndex[                  handle: handle, index: alias.indexORFrameNumber]};          frameThread => {            SELECT frameSpec FROM              frameNumber => {                checksum ¬ PutCardinal[                  handle: handle, cardinal: alias.indexORFrameNumber]};              segmentIndex, groupIndex, externalIndex, location, target =>                checksum ¬ PutIndex[                  handle: handle, index: alias.indexORFrameNumber];              ENDCASE => ERROR};          ENDCASE => ERROR};      ENDCASE;    checksum ¬ (checksum + byte) MOD 400B;    END;  END...    LOG  created by Dennis E. DEG      @  3-Nov-83 17:14:16  Frank FXB    @  8-Dec-83 20:35:08: fixed bug in PutPhysicalIteratedData (was producing LogicalIteratedData)  Frank FXB    @  5-Jan-84 11:24:16: fixed bug in PutRegisterInitialization (the registerOffset field wasn't being included in the output)  Frank FXB    @ 5-Jan-84 13:02:26 : fixed bug in PutModuleEnd (the second form of start address wasn't being outputted)  Dennis DEG      @  9-Jan-84  9:24:09: converted to bound variant records.
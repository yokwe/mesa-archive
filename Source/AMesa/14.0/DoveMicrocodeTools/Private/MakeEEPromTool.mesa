-- MakeEEPromTool.mesa  Last Revised by JoM     13-Jun-85 17:48:44DIRECTORY  Checksum USING [ComputeChecksum],  FormSW USING [AllocateItemDescriptor, BooleanItem, ClientItemsProcType, CommandItem, Display, Enumerated, EnumeratedItem, newLine, NumberItem, ProcType, StringItem],  Heap USING [systemZone],  Inline USING [BITAND, BITNOT, LowByte, LowHalf],  MStream USING [EndOf, Handle, ReadOnly, WriteOnly],  Stream USING [Delete, GetByte, PutByte],  String USING [AppendNumber, ExpandString],  Tool USING [Create, MakeFormSW, MakeSWsProc],  UserTerminal USING [BlinkDisplay];MakeEEPromTool: PROGRAM  IMPORTS Checksum, FormSW, Heap, Inline, MStream, Stream, String, Tool, UserTerminal =BEGIN-- TYPEsByte: TYPE = [0 .. 377B];LocRec: TYPE = MACHINE DEPENDENT RECORD[ SELECT OVERLAID * FROM    rec1 => [rec1: LocRec1 ¬ [] ],    rec2 => [rec2: LocRec2 ¬ [] ],    rec3 => [rec3: LocRec3 ¬ [] ],    lnkRec3 => [lnkRec3: LnkRec3 ¬ [] ],    rec4 => [rec4: LocRec4 ¬ [] ],    rec5 => [rec5: LocRec5 ¬ [] ],    rec6 => [rec6: LocRec6 ¬ [] ],    rec7 => [rec7: LocRec7 ¬ [] ],    buffer => [buffer: PACKED ARRAY [0 .. 258) OF Byte],    ENDCASE ];LocRec1: TYPE = MACHINE DEPENDENT RECORD[ cd1: Byte ¬ code1,  ll1: Byte ¬ 15,  lh1: Byte ¬ 0,  ct1: Byte ¬ 13,  nm1: PACKED ARRAY [0 .. 14) OF CHARACTER ¬ ['E, 'E, 'P, 'R, 'O, 'M, 'S, 'E, 'G, 'M, 'E, 'N, 'T, 0C] ];LocRec2: TYPE = MACHINE DEPENDENT RECORD[ cd2: Byte ¬ code2,  ll2: Byte ¬ 16,  lh2: Byte ¬ 0,  nl2: Byte ¬ 0,  nm2: PACKED ARRAY [0 .. 14) OF CHARACTER ¬ [15C, 'E, 'E, 'P, 'R, 'O, 'M, 'S, 'E, 'G, 'M, 'E, 'N, 'T] ];LocRec3: TYPE = MACHINE DEPENDENT RECORD[ cd3: Byte ¬ code3,  ll3: Byte ¬ 10,  lh3: Byte ¬ 0,  nl3: Byte ¬ 0,  al3: Byte ¬ 0, -- variable  ah3: Byte ¬ 0, -- variable  of3: Byte ¬ 0, -- variable  sl3: Byte ¬ 128,  sh3: Byte ¬ 0,  ix3: Byte ¬ 2,  tp3: Byte ¬ 1,  ec3: Byte ¬ 1 ];LnkRec3: TYPE = MACHINE DEPENDENT RECORD[ cd3: Byte ¬ code3,  ll3: Byte ¬ 7,  lh3: Byte ¬ 0,  nl3: Byte ¬ 78H,  sl3: Byte ¬ 128,  sh3: Byte ¬ 0,  ix3: Byte ¬ 2,  tp3: Byte ¬ 1,  ec3: Byte ¬ 1,  ck3: Byte ¬ 0 ];LocRec4: TYPE = MACHINE DEPENDENT RECORD[ cd4: Byte ¬ code4,  ll4: Byte ¬ 15,  lh4: Byte ¬ 0,  ct4: Byte ¬ 13,  nm4: PACKED ARRAY [0 .. 14) OF CHARACTER ¬ ['E, 'E, 'P, 'R, 'O, 'M, 'S, 'E, 'G, 'M, 'E, 'N, 'T, 0C] ];LocRec5: TYPE = MACHINE DEPENDENT RECORD[ cd5: Byte ¬ code5,  ll5: Byte ¬ 18,  lh5: Byte ¬ 0,  nl5: Byte ¬ 0,  nm5: PACKED ARRAY [0 .. 16) OF CHARACTER ¬ [0C, 'A, 'S, 'M, '8, '6, '., '8, '6, ' , 'V, '2, '., '0, 'V, 'X] ];LocRec6: TYPE = MACHINE DEPENDENT RECORD[ cd6: Byte ¬ code6,  ll6: Byte ¬ 132,  lh6: Byte ¬ 0,  al6: Byte ¬ 1, -- variable  ah6: Byte ¬ 0, -- variable  of6: Byte ¬ 0, -- variable  dt6: PACKED ARRAY [0 .. 128) OF Byte ¬ ALL [0] ]; -- variableLocRec7: TYPE = MACHINE DEPENDENT RECORD[ cd7: Byte ¬ code7,  ll7: Byte ¬ 2,  lh7: Byte ¬ 0,  nl7: Byte ¬ 0 ];-- constantscode1: Byte = 202B;code2: Byte = 226B;code3: Byte = 230B;code4: Byte = 200B;code5: Byte = 210B;code6: Byte = 204B;lnkCode6: Byte = 240B;code7: Byte = 212B;-- globalsparmWord: ARRAY [0 .. 32) OF UNSPECIFIED ¬ ALL [0];filename: LONG STRING ¬ NIL;segAddress: LONG STRING ¬ NIL;-- SIGNALsBadChecksum: SIGNAL = CODE;-- PROCsClientItemsProc: FormSW.ClientItemsProcType =  BEGIN  descBoot: ARRAY [0 .. 4) OF FormSW.Enumerated ¬  [ ["none"L, 0], ["rigid disk"L, 1], ["floppy disk"L, 2], ["ethernet"L, 3] ];  descVMSize: ARRAY [0 .. 4) OF FormSW.Enumerated ¬  [ ["no VM"L, 0], ["4 MW"L, 22], ["8 MW"L, 23], ["16 MW"L, 24] ];  descDisplay: ARRAY [0 .. 7) OF FormSW.Enumerated ¬  [ ["none"L, 0], ["15 inch B/W"L, 1], ["17 inch B/W"L, 2], ["19 inch B/W"L, 3], ["13 inch color"L, 41], ["15 inch color"L, 42], ["non-bitmap"L, 80] ];  descKeyboard: ARRAY [0 .. 11) OF FormSW.Enumerated ¬  [ ["none"L, 0], ["English"L, 1], ["German"L, 2], ["French"L, 3], ["Swedish"L, 4], ["Norwegian"L, 5], ["Danish"L, 6], ["Italian"L, 7], ["Finnish"L, 8], ["Japanese"L, 9], ["Chinese"L, 10] ];  descRigid: ARRAY [0 .. 2) OF FormSW.Enumerated ¬  [ ["none"L, 0], ["standard"L, 1] ];  descLowMemory: ARRAY [0 .. 4) OF FormSW.Enumerated ¬  [ ["none"L, 0], ["128KB at 0"L, 3], ["128KB at 6000H"L, 0C0H], ["512KB"L, 0FFH] ];  descMidMemory: ARRAY [0 .. 3) OF FormSW.Enumerated ¬  [ ["none"L, 0], ["512KB"L, 0FFH], ["1MB"L, 2FFH] ];  descHighMemory: ARRAY [0 .. 6) OF FormSW.Enumerated ¬  [ ["none"L, 0], ["0.5MB"L, 2], ["1.0MB"L, 4], ["1.5MB"L, 6], ["2.0MB"L, 8], ["2.5MB"L, 10] ];  descFloppy: ARRAY [0 .. 5) OF FormSW.Enumerated ¬  [ ["none"L, 0], ["SA800"L, 1], ["SA850"L, 2], ["SA455"L, 3], ["SA465"L, 4] ];  descRS232: ARRAY [0 .. 3) OF FormSW.Enumerated ¬  [ ["none"L, 0], ["DTE"L, 1], ["DCE"L, 2] ];  descOption1: ARRAY [0 .. 3) OF FormSW.Enumerated ¬  [ ["none"L, 0], ["PCE"L, 1], ["TBD"L, 2] ];  descOption: ARRAY [0 .. 2) OF FormSW.Enumerated ¬  [ ["none"L, 0], ["TBD"L, 2] ];  items ¬ FormSW.AllocateItemDescriptor [28];  freeDesc ¬ TRUE;  items[0] ¬ FormSW.CommandItem [tag: "Write"L, place: FormSW.newLine, proc: CommandWrite];  items[1] ¬ FormSW.CommandItem [tag: "Read"L, proc: CommandRead];  items[2] ¬ FormSW.StringItem [tag: "file"L, inHeap: TRUE, string: @filename];  items[3] ¬ FormSW.StringItem [tag: "segment address"L, place: FormSW.newLine, inHeap: TRUE, string: @segAddress];  items[4] ¬ FormSW.EnumeratedItem [tag: "default boot"L, place: FormSW.newLine, choices: DESCRIPTOR [descBoot], copyChoices: TRUE, value: @parmWord[0] ];  items[5] ¬ FormSW.BooleanItem [tag: "fast boot"L, place: FormSW.newLine, switch: @parmWord[1] ];  items[6] ¬ FormSW.BooleanItem [tag: "run diag"L, switch: @parmWord[2] ];  items[7] ¬ FormSW.BooleanItem [tag: "hardware lock"L, switch: @parmWord[3] ];  items[8] ¬ FormSW.BooleanItem [tag: "ethernet"L, switch: @parmWord[4] ];  items[9] ¬ FormSW.EnumeratedItem [tag: "VMM size"L, place: FormSW.newLine, choices: DESCRIPTOR [descVMSize], copyChoices: TRUE, value: @parmWord[5] ];  items[10] ¬ FormSW.EnumeratedItem [tag: "display"L, place: FormSW.newLine, choices: DESCRIPTOR [descDisplay], copyChoices: TRUE, value: @parmWord[6] ];  items[11] ¬ FormSW.NumberItem [tag: "X align"L, value: @parmWord[7] ];  items[12] ¬ FormSW.NumberItem [tag: "Y align"L, value: @parmWord[8] ];  items[13] ¬ FormSW.EnumeratedItem [tag: "keyboard"L, place: FormSW.newLine, choices: DESCRIPTOR [descKeyboard], copyChoices: TRUE, value: @parmWord[9] ];  items[14] ¬ FormSW.EnumeratedItem [tag: "Rigid disk"L, place: FormSW.newLine, choices: DESCRIPTOR [descRigid], copyChoices: TRUE, value: @parmWord[10] ];  items[15] ¬ FormSW.NumberItem [tag: "sectors/track"L, value: @parmWord[11] ];  items[16] ¬ FormSW.NumberItem [tag: "heads/cylinder"L, value: @parmWord[12] ];  items[17] ¬ FormSW.NumberItem [tag: "	number of cylinders"L, place: FormSW.newLine, value: @parmWord[22] ];  items[18] ¬ FormSW.NumberItem [tag: "precomp cylinder"L, value: @parmWord[23] ];  items[19] ¬ FormSW.EnumeratedItem [tag: "Memory - display"L, place: FormSW.newLine, choices: DESCRIPTOR [descLowMemory], copyChoices: TRUE, value: @parmWord[13] ];  items[20] ¬ FormSW.EnumeratedItem [tag: "system"L, choices: DESCRIPTOR [descMidMemory], copyChoices: TRUE, value: @parmWord[14] ];  items[21] ¬ FormSW.EnumeratedItem [tag: "expansion"L, choices: DESCRIPTOR [descHighMemory], copyChoices: TRUE, value: @parmWord[15] ];  items[22] ¬ FormSW.EnumeratedItem [tag: "Floppy disk"L, place: FormSW.newLine, choices: DESCRIPTOR [descFloppy], copyChoices: TRUE, value: @parmWord[16] ];  items[23] ¬ FormSW.EnumeratedItem [tag: "RS232C - A"L, place: FormSW.newLine, choices: DESCRIPTOR [descRS232], copyChoices: TRUE, value: @parmWord[17] ];  items[24] ¬ FormSW.EnumeratedItem [tag: "RS232C - B"L, place: FormSW.newLine, choices: DESCRIPTOR [descRS232], copyChoices: TRUE, value: @parmWord[18] ];  items[25] ¬ FormSW.EnumeratedItem [tag: "Option #1"L, place: FormSW.newLine, choices: DESCRIPTOR [descOption1], copyChoices: TRUE, value: @parmWord[19] ];  items[26] ¬ FormSW.EnumeratedItem [tag: "Option #2"L, place: FormSW.newLine, choices: DESCRIPTOR [descOption], copyChoices: TRUE, value: @parmWord[20] ];  items[27] ¬ FormSW.EnumeratedItem [tag: "Option #3"L, place: FormSW.newLine, choices: DESCRIPTOR [descOption], copyChoices: TRUE, value: @parmWord[21] ];  END;CommandRead: FormSW.ProcType =  BEGIN  rec: LocRec;  stream: MStream.Handle;  checksum: CARDINAL ¬ 0;  ReadByte: PROC RETURNS [byte: Byte] = INLINE    BEGIN    byte ¬ (IF MStream.EndOf [stream] THEN 0 ELSE Stream.GetByte [stream]);    checksum ¬ checksum + byte    END;  ReadRec: PROC =    BEGIN    recLength: Byte;    rec.buffer[0] ¬ ReadByte [];    rec.buffer[1] ¬ recLength ¬ ReadByte [];    FOR i: CARDINAL IN [0 .. recLength) DO      rec.buffer[(i + 2)] ¬ ReadByte []    ENDLOOP;    [] ¬ ReadByte [];    IF (checksum MOD 256) # 0 THEN SIGNAL BadChecksum;    END;  IF filename = NIL OR filename.length = 0 THEN    BEGIN    UserTerminal.BlinkDisplay [];    RETURN    END;  stream ¬ MStream.ReadOnly [filename, []    ! ANY => GOTO badFilename ];  UNTIL MStream.EndOf [stream] DO    ReadRec [ !      BadChecksum =>        BEGIN        UserTerminal.BlinkDisplay [];        RESUME        END ];    SELECT rec.buffer[0] FROM      code3 => IF rec.rec3.nl3 = 0 THEN        BEGIN	IF segAddress = NIL OR segAddress.length < 5	  THEN String.ExpandString [@segAddress, 5, Heap.systemZone];	segAddress.length ¬ 0;	String.AppendNumber [segAddress, rec.rec3.ah3, 16];	String.AppendNumber [segAddress, rec.rec3.al3, 16];	String.AppendNumber [segAddress, rec.rec3.of3, 16]	END	ELSE IF segAddress # NIL THEN segAddress.length ¬ 0;      code6, lnkCode6 =>        BEGIN	parmWord[0] ¬ rec.rec6.dt6[0];	parmWord[1] ¬ (Inline.BITAND [rec.rec6.dt6[2], 1] # 0);	parmWord[2] ¬ (Inline.BITAND [rec.rec6.dt6[2], 2] # 0);	parmWord[3] ¬ (Inline.BITAND [rec.rec6.dt6[3], 1] # 0);	parmWord[4] ¬ (Inline.BITAND [rec.rec6.dt6[3], 80H] # 0);	parmWord[5] ¬ rec.rec6.dt6[4];	parmWord[6] ¬ rec.rec6.dt6[5];	parmWord[7] ¬ rec.rec6.dt6[6];	parmWord[8] ¬ rec.rec6.dt6[7];	parmWord[9] ¬ rec.rec6.dt6[8];	parmWord[10] ¬ rec.rec6.dt6[9];	parmWord[11] ¬ rec.rec6.dt6[10];	parmWord[12] ¬ rec.rec6.dt6[11];	parmWord[22] ¬ rec.rec6.dt6[12] + 256 * rec.rec6.dt6[13];	parmWord[23] ¬ rec.rec6.dt6[16] + 256 * rec.rec6.dt6[17];	parmWord[13] ¬ rec.rec6.dt6[18];	parmWord[14] ¬ rec.rec6.dt6[19];	IF rec.rec6.dt6[20] < 2 THEN parmWord[15] ¬ 0 ELSE	  BEGIN	  parmWord[14] ¬ parmWord[14] + 200H;	  parmWord[15] ¬ rec.rec6.dt6[20] - 2	  END;	parmWord[16] ¬ rec.rec6.dt6[21];	parmWord[17] ¬ rec.rec6.dt6[22];	parmWord[18] ¬ rec.rec6.dt6[24];	parmWord[19] ¬ rec.rec6.dt6[26];	parmWord[20] ¬ rec.rec6.dt6[28];	parmWord[21] ¬ rec.rec6.dt6[30]	END;      ENDCASE  ENDLOOP;  FormSW.Display [sw];  Stream.Delete [stream];  EXITS    badFilename => UserTerminal.BlinkDisplay [];  END;CommandWrite: FormSW.ProcType =  BEGIN  rec: LocRec;  stream: MStream.Handle;  checksum: CARDINAL ¬ 0;  addr: LONG CARDINAL ¬ 0;  useLoc: BOOLEAN ¬ (segAddress # NIL AND segAddress.length > 0);  WriteByte: PROC [byte: Byte] = INLINE    BEGIN    Stream.PutByte [stream, byte];    checksum ¬ checksum + byte    END;  WriteRec: PROC =    BEGIN    recLength: Byte = rec.buffer[1];    FOR i: CARDINAL IN [0 .. (recLength + 2)) DO      WriteByte [rec.buffer[i] ]    ENDLOOP;    WriteByte [Inline.LowByte [(- checksum)] ];    IF (checksum MOD 256) # 0 THEN ERROR BadChecksum;    END;  IF filename = NIL OR filename.length = 0 THEN    BEGIN    UserTerminal.BlinkDisplay [];    RETURN    END;  stream ¬ MStream.WriteOnly [filename, [], binary    ! ANY => GOTO badFilename ];  IF useLoc THEN addr ¬ HexStringToLongNumber [segAddress    ! ANY =>      BEGIN      UserTerminal.BlinkDisplay [];      useLoc ¬ FALSE;      CONTINUE      END ];  IF addr > 0FFFFFH THEN UserTerminal.BlinkDisplay [];  rec ¬ [rec1[] ];  WriteRec [];  rec ¬ [rec2[] ];  WriteRec [];  IF useLoc THEN    BEGIN    rec ¬ [rec3[] ];    rec.rec3.of3 ¬ Inline.LowHalf [addr] MOD 16;    rec.rec3.al3 ¬ Inline.LowHalf [addr / 16] MOD 256;    rec.rec3.ah3 ¬ Inline.LowHalf [addr / 4096] MOD 256    END    ELSE rec ¬ [lnkRec3[] ];  WriteRec [];  rec ¬ [rec4[] ];  WriteRec [];  rec ¬ [rec5[] ];  WriteRec [];  rec ¬ [rec6[] ];  IF useLoc THEN    BEGIN    rec.rec6.of6 ¬ Inline.LowHalf [addr] MOD 16;    rec.rec6.al6 ¬ Inline.LowHalf [addr / 16] MOD 256;    rec.rec6.ah6 ¬ Inline.LowHalf [addr / 4096] MOD 256    END    ELSE rec.rec6.cd6 ¬ lnkCode6;  rec.rec6.dt6[0] ¬ parmWord[0];  rec.rec6.dt6[2] ¬ parmWord[1] + 2 * parmWord[2];  rec.rec6.dt6[3] ¬ parmWord[3] + 80H * parmWord[4];  rec.rec6.dt6[4] ¬ parmWord[5];  rec.rec6.dt6[5] ¬ parmWord[6];  rec.rec6.dt6[6] ¬ parmWord[7];  rec.rec6.dt6[7] ¬ parmWord[8];  rec.rec6.dt6[8] ¬ parmWord[9];  rec.rec6.dt6[9] ¬ parmWord[10];  rec.rec6.dt6[10] ¬ parmWord[11];  rec.rec6.dt6[11] ¬ parmWord[12];  rec.rec6.dt6[12] ¬ parmWord[22] MOD 256;  rec.rec6.dt6[13] ¬ parmWord[22] / 256;  rec.rec6.dt6[14] ¬ rec.rec6.dt6[15] ¬ 0FFH;	-- reduced-write-current cyl  rec.rec6.dt6[16] ¬ parmWord[23] MOD 256;  rec.rec6.dt6[17] ¬ parmWord[23] / 256;  rec.rec6.dt6[18] ¬ parmWord[13];  rec.rec6.dt6[19] ¬ parmWord[14] MOD 256;  rec.rec6.dt6[20] ¬ parmWord[14] / 256 + parmWord[15];  rec.rec6.dt6[21] ¬ parmWord[16];  rec.rec6.dt6[22] ¬ parmWord[17];  rec.rec6.dt6[24] ¬ parmWord[18];  rec.rec6.dt6[26] ¬ parmWord[19];  rec.rec6.dt6[28] ¬ parmWord[20];  rec.rec6.dt6[30] ¬ parmWord[21];  checksum ¬ Checksum.ComputeChecksum [nWords: 62, p: LONG [@rec.rec6.dt6] ];  rec.rec6.dt6[124] ¬ checksum MOD 256;  rec.rec6.dt6[125] ¬ checksum / 256;  checksum ¬ Inline.BITNOT [checksum];  rec.rec6.dt6[126] ¬ checksum MOD 256;  rec.rec6.dt6[127] ¬ checksum / 256;  checksum ¬ 0;  WriteRec [];  rec ¬ [rec7[] ];  WriteRec [];  Stream.Delete [stream];  EXITS    badFilename => UserTerminal.BlinkDisplay [];  END;Init: PROC =  {[] ¬ Tool.Create ["Make EEProm Tool"L, MakeForm]};MakeForm: Tool.MakeSWsProc =  {[] ¬ Tool.MakeFormSW [window, ClientItemsProc]};HexStringToLongNumber: PROC [s: LONG STRING] RETURNS [v: LONG UNSPECIFIED ¬ 0] =  {FOR i: CARDINAL IN [0 .. s.length) DO    v ¬ 16 * v + (SELECT s[i] FROM      IN ['0 .. '9] => s[i] - '0,      IN ['A .. 'F] => s[i] - ('A - 10),      ENDCASE => ERROR)  ENDLOOP};-- main codeInit []END.  -- MakeEEPromToolLOG23-Jul-84 -- JoM     -- Created.17-Oct-84 -- JoM     -- Changed for new EEProm format.15-Nov-84 -- JoM     -- Changed for new EEProm format.29-Nov-84 -- JoM     -- Changed to support link format (rec3 = relocatable, rec6 = type A0 hex)13-Jun-85 -- JoM     -- Added more options for EEProm format.
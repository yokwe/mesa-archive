-- File: PanelSWsZ.mesa - last edit:-- AMD, 21-Dec-82 15:19:10-- HGM, 30-Apr-82 18:23:17-- Mark: Aug 22, 1980 12:34 AM-- creation, destruction, and wholesale redisplay routinesDIRECTORY  Context USING [Type, UniqueType],  Heap: TYPE USING [systemZone],  PanelSW USING [    ClientErrorCode, ErrorCode, FreeRSProcType, Handle, Object, RegisterSpec,    TileErrorCode, TileField, TileIndex, TileSpec],  PanelSWOps USING [    ActOnPanelProcType, context, FindContext, Handle, nilTileSpec, Object, Tile,    TileFromSpec],  Window USING [Dims, GetBox, Handle, Place],  WindowFont USING [FontHeight, Handle];PanelSWsZ: MONITOR LOCKS h.lock USING h: PanelSWOps.Handle  IMPORTS Context, Heap, PanelSWOps, Window, WindowFont  EXPORTS PanelSW, PanelSWOps =  BEGIN  -- Standard preamble to hook up EXPORTed TYPEs  Object: PUBLIC TYPE = PanelSWOps.Object;  -- Global Data and STUFF  context: PUBLIC Context.Type _ Context.UniqueType[];  ClientError: PUBLIC SIGNAL [code: PanelSW.ClientErrorCode, msg: LONG STRING] =    CODE;  Error: PUBLIC SIGNAL [code: PanelSW.ErrorCode] = CODE;  TileError: PUBLIC SIGNAL [code: PanelSW.TileErrorCode, ts: PanelSW.TileSpec] =    CODE;  -- PUBLIC PROCs  HandleFromSubwindow: PUBLIC PROC [sw: Window.Handle]    RETURNS [h: PanelSW.Handle] = {RETURN PanelSWOps.FindContext[sw]};  LineHeight: PUBLIC PROC [h: PanelSWOps.Handle] RETURNS [CARDINAL] = {    RETURN[IF h = NIL THEN 0 ELSE WindowFont.FontHeight[h.font]]};  RegSpecFromTileSpec: PUBLIC PROC [h: PanelSWOps.Handle, ts: PanelSW.TileSpec]    RETURNS [rs: PanelSW.RegisterSpec] = {    tile: PanelSWOps.Tile = PanelSWOps.TileFromSpec[h, ts];    rs _ IF tile = NIL THEN NIL ELSE tile.regSpec};  SubwindowFromHandle: PUBLIC PROC [h: PanelSWOps.Handle]    RETURNS [sw: Window.Handle] = {RETURN[IF h = NIL THEN NIL ELSE h.sw]};  TileCount: PUBLIC PROC [h: PanelSWOps.Handle] RETURNS [count: CARDINAL] = {    count _ (IF h = NIL THEN 0 ELSE h.tiles.length)};  TileIndexFromRowColumn: PUBLIC PROC [    h: PanelSWOps.Handle, row, column: CARDINAL] RETURNS [ti: PanelSW.TileIndex] =    {    SELECT TRUE FROM      h = NIL => NULL;      h.numCols <= column => NULL;      (ti _ row * h.numCols + column) < h.tiles.length => RETURN;      ENDCASE;    ti _ PanelSWOps.nilTileSpec.index};  -- Semi-PUBLIC PROCs  ResolvePlaceToTile: PUBLIC PROC [    h: PanelSWOps.Handle, place: Window.Place, mustResolve: BOOLEAN]    RETURNS [ts: PanelSW.TileSpec] = {    dims: Window.Dims = h.sw.GetBox.dims;    rowIndex: CARDINAL;    tileLayout: LONG POINTER TO CARDINAL;    IF ~(place.x IN [0..dims.w) AND place.y IN [0..dims.h)) THEN      RETURN[PanelSWOps.nilTileSpec];    -- Following grimy code is to avoid double indexing in inner loop    rowIndex _ (place.y / h.lineHeight) * h.numCols;    FOR i: CARDINAL IN [0..h.numCols) DO      tileLayout _ LOOPHOLE[h.rowPlaceDesc[i].BASE, LONG POINTER TO CARDINAL];      FOR tf: PanelSW.TileField IN PanelSW.TileField DO        IF tileLayout^ > CARDINAL[place.x] THEN {          ts.index _ rowIndex + i;          IF tf = PanelSW.TileField.FIRST THEN {            ts.field _ PanelSW.TileField.LAST; ts.index _ ts.index - 1}          ELSE ts.field _ tf.PRED;          RETURN};        tileLayout _ tileLayout + CARDINAL.SIZE;        ENDLOOP;      ENDLOOP;    ts _      IF mustResolve      OR (tileLayout - 1)^ + h.rowDesc[h.numCols - 1][right] > CARDINAL[place.x]      THEN [field: right, index: rowIndex + h.numCols - 1]      ELSE PanelSWOps.nilTileSpec};  ValidateHandle: PUBLIC PanelSWOps.ActOnPanelProcType = {    myContext: PanelSWOps.Handle;    IF h = NIL THEN ERROR Error[notAPanelSW];    myContext _ PanelSWOps.FindContext[h.sw];    IF h # myContext THEN ERROR Error[notAPanelSW]};  -- Private PROCs  FreeTile: PUBLIC PROC [tile: PanelSWOps.Tile, freeRS: PanelSW.FreeRSProcType] =    {    IF tile = NIL THEN RETURN;    Heap.systemZone.FREE[@tile.lh];    Heap.systemZone.FREE[@tile.rh];    freeRS[tile.regSpec];    Heap.systemZone.FREE[@tile]};  END.  -- of PanelSWsZ.mesa
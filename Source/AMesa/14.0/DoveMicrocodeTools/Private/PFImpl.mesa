-- File: PFImpl.mesa - last edit:-- Bowers.PA           13-Dec-85  8:38:27--  Poskanzer	28-Feb-85  9:52:30--  DSC  	26-Feb-85 16:58:00-- Copyright (C) 1985 by Xerox Corporation. All rights reserved.-- Copyright (C) 1985 by Versatec, Inc.  All rights reserved.-- This module implements PutF, which is similar to Unix*'s printf() and Cedar's IO interface.DIRECTORY  Atom USING [GetPName],  Format USING [Blanks, Char, Date, LongNumber, Number, StringProc, Text],  PF USING [Value, nullValue, ErrorCodes],  Put USING [Text],  Real USING [AppendReal, DefaultSinglePrecision, RoundLI],  Stream USING [Handle, PutString],  String USING [AppendChar, AppendString, Copy, Length],  Window USING [Handle];PFImpl: PROGRAM  IMPORTS Atom, Format, Put, Real, Stream, String EXPORTS PF =  BEGIN  Value: TYPE = PF.Value;  nullValue: Value = PF.nullValue;  MAXSTRING: CARDINAL = 200;  -- arbitrary maximum size for formatted value  Error: PUBLIC ERROR [code: PF.ErrorCodes] = CODE;  -- Stream routines.  PutF: PUBLIC PROC [    out: Stream.Handle, format: LONG STRING,    v1, v2, v3, v4, v5, v6, v7, v8, v9, v10: Value _ nullValue] =    BEGIN    fi: CARDINAL _ 0;    IF v1.type # null THEN {      fi _ OneSP[StringProcForStream, out, format, fi, v1];      IF v2.type # null THEN {        fi _ OneSP[StringProcForStream, out, format, fi, v2];	IF v3.type # null THEN {	  fi _ OneSP[StringProcForStream, out, format, fi, v3];	  IF v4.type # null THEN {	    fi _ OneSP[StringProcForStream, out, format, fi, v4];	    IF v5.type # null THEN {	      fi _ OneSP[StringProcForStream, out, format, fi, v5];	      IF v6.type # null THEN {		fi _ OneSP[StringProcForStream, out, format, fi, v6];		IF v7.type # null THEN {		  fi _ OneSP[StringProcForStream, out, format, fi, v7];		  IF v8.type # null THEN {		    fi _ OneSP[StringProcForStream, out, format, fi, v8];		    IF v9.type # null THEN {		      fi _ OneSP[StringProcForStream, out, format, fi, v9];		      IF v10.type # null THEN {			fi _ OneSP[StringProcForStream, out, format, fi, v10];			}}}}}}}}}};    fi _ OneSP[StringProcForStream, out, format, fi, [null[]]];    END;  PutF2: PUBLIC PROC [    out: Stream.Handle, format: LONG STRING, v1, v2: Value _ nullValue] =    BEGIN    fi: CARDINAL _ 0;    IF v1.type # null THEN {      fi _ OneSP[StringProcForStream, out, format, fi, v1];      IF v2.type # null THEN {        fi _ OneSP[StringProcForStream, out, format, fi, v2];	}};    fi _ OneSP[StringProcForStream, out, format, fi, [null[]]];    END;    PutFL: PUBLIC PROC [    out: Stream.Handle, format: LONG STRING,    list: LONG DESCRIPTOR FOR ARRAY OF Value] =    BEGIN    fi: CARDINAL _ 0;    FOR i: CARDINAL IN [0..LENGTH[list]) DO      fi _ OneSP[StringProcForStream, out, format, fi, list[i]];      ENDLOOP;    fi _ OneSP[StringProcForStream, out, format, fi, [null[]]];    END;  StringProcForStream: Format.StringProc =    BEGIN    h: Stream.Handle = clientData;    Stream.PutString[h, s];    END;  -- StringProc routines.  PutSP: PUBLIC PROC [    out: Format.StringProc, clientData: LONG POINTER, format: LONG STRING,    v1, v2, v3, v4, v5, v6, v7, v8, v9, v10: Value _ nullValue] =    BEGIN    fi: CARDINAL _ 0;    IF v1.type # null THEN {      fi _ OneSP[out, clientData, format, fi, v1];      IF v2.type # null THEN {        fi _ OneSP[out, clientData, format, fi, v2];	IF v3.type # null THEN {	  fi _ OneSP[out, clientData, format, fi, v3];	  IF v4.type # null THEN {	    fi _ OneSP[out, clientData, format, fi, v4];	    IF v5.type # null THEN {	      fi _ OneSP[out, clientData, format, fi, v5];	      IF v6.type # null THEN {		fi _ OneSP[out, clientData, format, fi, v6];		IF v7.type # null THEN {		  fi _ OneSP[out, clientData, format, fi, v7];		  IF v8.type # null THEN {		    fi _ OneSP[out, clientData, format, fi, v8];		    IF v9.type # null THEN {		      fi _ OneSP[out, clientData, format, fi, v9];		      IF v10.type # null THEN {			fi _ OneSP[out, clientData, format, fi, v10];			}}}}}}}}}};    fi _ OneSP[out, clientData, format, fi, [null[]]];    END;  PutSP2: PUBLIC PROC [    out: Format.StringProc, clientData: LONG POINTER, format: LONG STRING,    v1, v2: Value _ nullValue] =    BEGIN    fi: CARDINAL _ 0;    IF v1.type # null THEN {      fi _ OneSP[out, clientData, format, fi, v1];      IF v2.type # null THEN {        fi _ OneSP[out, clientData, format, fi, v2];	}};    fi _ OneSP[out, clientData, format, fi, [null[]]];    END;    PutSPL: PUBLIC PROC [    out: Format.StringProc, clientData: LONG POINTER, format: LONG STRING,    list: LONG DESCRIPTOR FOR ARRAY OF Value] =    BEGIN    fi: CARDINAL _ 0;    FOR i: CARDINAL IN [0..LENGTH[list]) DO      fi _ OneSP[out, clientData, format, fi, list[i]];      ENDLOOP;    fi _ OneSP[out, clientData, format, fi, [null[]]];    END;  -- Window routines.  PutW: PUBLIC PROC [    out: Window.Handle, format: LONG STRING,    v1, v2, v3, v4, v5, v6, v7, v8, v9, v10: Value _ nullValue] =    BEGIN    fi: CARDINAL _ 0;    IF v1.type # null THEN {      fi _ OneSP[StringProcForWindow, out, format, fi, v1];      IF v2.type # null THEN {        fi _ OneSP[StringProcForWindow, out, format, fi, v2];	IF v3.type # null THEN {	  fi _ OneSP[StringProcForWindow, out, format, fi, v3];	  IF v4.type # null THEN {	    fi _ OneSP[StringProcForWindow, out, format, fi, v4];	    IF v5.type # null THEN {	      fi _ OneSP[StringProcForWindow, out, format, fi, v5];	      IF v6.type # null THEN {		fi _ OneSP[StringProcForWindow, out, format, fi, v6];		IF v7.type # null THEN {		  fi _ OneSP[StringProcForWindow, out, format, fi, v7];		  IF v8.type # null THEN {		    fi _ OneSP[StringProcForWindow, out, format, fi, v8];		    IF v9.type # null THEN {		      fi _ OneSP[StringProcForWindow, out, format, fi, v9];		      IF v10.type # null THEN {			fi _ OneSP[StringProcForWindow, out, format, fi, v10];			}}}}}}}}}};    fi _ OneSP[StringProcForWindow, out, format, fi, [null[]]];    END;  PutW2: PUBLIC PROC [    out: Window.Handle, format: LONG STRING, v1, v2: Value _ nullValue] =    BEGIN    fi: CARDINAL _ 0;    IF v1.type # null THEN {      fi _ OneSP[StringProcForWindow, out, format, fi, v1];      IF v2.type # null THEN {        fi _ OneSP[StringProcForWindow, out, format, fi, v2];	}};    fi _ OneSP[StringProcForWindow, out, format, fi, [null[]]];    END;    PutWL: PUBLIC PROC [    out: Window.Handle, format: LONG STRING,    list: LONG DESCRIPTOR FOR ARRAY OF Value] =    BEGIN    fi: CARDINAL _ 0;    FOR i: CARDINAL IN [0..LENGTH[list]) DO      fi _ OneSP[StringProcForWindow, out, format, fi, list[i]];      ENDLOOP;    fi _ OneSP[StringProcForWindow, out, format, fi, [null[]]];    END;  StringProcForWindow: Format.StringProc =    BEGIN    h: Window.Handle = clientData;    Put.Text[h, s];    END;  -- STRING routines.  PutS: PUBLIC PROC [    out: LONG STRING, format: LONG STRING,    v1, v2, v3, v4, v5, v6, v7, v8, v9, v10: Value _ nullValue] =    BEGIN    SP: Format.StringProc = {String.AppendString[out, s]};    fi: CARDINAL _ 0;    String.Copy[out, ""L];    IF v1.type # null THEN {      fi _ OneSP[SP, NIL, format, fi, v1];      IF v2.type # null THEN {        fi _ OneSP[SP, NIL, format, fi, v2];	IF v3.type # null THEN {	  fi _ OneSP[SP, NIL, format, fi, v3];	  IF v4.type # null THEN {	    fi _ OneSP[SP, NIL, format, fi, v4];	    IF v5.type # null THEN {	      fi _ OneSP[SP, NIL, format, fi, v5];	      IF v6.type # null THEN {		fi _ OneSP[SP, NIL, format, fi, v6];		IF v7.type # null THEN {		  fi _ OneSP[SP, NIL, format, fi, v7];		  IF v8.type # null THEN {		    fi _ OneSP[SP, NIL, format, fi, v8];		    IF v9.type # null THEN {		      fi _ OneSP[SP, NIL, format, fi, v9];		      IF v10.type # null THEN {			fi _ OneSP[SP, NIL, format, fi, v10];			}}}}}}}}}};    fi _ OneSP[SP, NIL, format, fi, [null[]]];    END;  PutS2: PUBLIC PROC [    out: LONG STRING, format: LONG STRING,    v1, v2: Value _ nullValue] =    BEGIN    SP: Format.StringProc = {String.AppendString[out, s]};    fi: CARDINAL _ 0;    String.Copy[out, ""L];    IF v1.type # null THEN {      fi _ OneSP[SP, NIL, format, fi, v1];      IF v2.type # null THEN {        fi _ OneSP[SP, NIL, format, fi, v2];	}};    fi _ OneSP[SP, NIL, format, fi, [null[]]];    END;    PutSL: PUBLIC PROC [    out: LONG STRING, format: LONG STRING,    list: LONG DESCRIPTOR FOR ARRAY OF Value] =    BEGIN    SP: Format.StringProc = {String.AppendString[out, s]};    fi: CARDINAL _ 0;    String.Copy[out, ""L];    FOR i: CARDINAL IN [0..LENGTH[list]) DO      fi _ OneSP[SP, NIL, format, fi, list[i]];      ENDLOOP;    fi _ OneSP[SP, NIL, format, fi, [null[]]];    END;  -- Internal routines.  OneSP: PROC [    sp: Format.StringProc, cd: LONG POINTER, format: LONG STRING, oldfi: CARDINAL,    val: Value] RETURNS [fi: CARDINAL] =    BEGIN    len: CARDINAL = String.Length[format];    IF len = 0 THEN      BEGIN      OneSPNoFormat[sp, cd, val];      RETURN;      END;    FOR fi _ oldfi, fi + 1 UNTIL fi >= len DO      IF format[fi] # '% OR fi + 1 = len THEN        BEGIN	Format.Char[sp, format[fi], cd];	LOOP;	END      ELSE        BEGIN	-- Found a % - this is some kind of formatting sequence.	zeroFill, leftJustify: BOOLEAN _ FALSE;	fieldWidth: CARDINAL _ 0;	precision: CARDINAL _ Real.DefaultSinglePrecision;	minus: BOOLEAN _ FALSE;	str: LONG STRING _ [MAXSTRING];	StrSP: Format.StringProc = {String.AppendString[str, s]};	fi _ fi + 1;	-- Look for leading 0 or -.	SELECT format[fi] FROM	  '0 => {	    zeroFill _ TRUE;	    fi _ fi + 1};	  '- => {	    leftJustify _ TRUE;	    fi _ fi + 1};	  ENDCASE;	-- Look for a field width specifier.	WHILE format[fi] IN ['0..'9] DO	  fieldWidth _ fieldWidth * 10 + ORD[format[fi]] - ORD['0];	  fi _ fi + 1;	  ENDLOOP;	-- Look for a precision specifier.	IF format[fi] = '. THEN	  BEGIN	  fi _ fi + 1;	  WHILE format[fi] IN ['0..'9] DO	    precision _ precision * 10 + ORD[format[fi]] - ORD['0];	    fi _ fi + 1;	    ENDLOOP;	  END;	-- Now interpret the formatting character, saving the results in str.	SELECT format[fi] FROM	  'g, 'G =>	    BEGIN	    minus _ OneGeneral[str, val, precision];	    END;	  'h, 'H =>	    BEGIN	    WITH v: val SELECT FROM	      atom =>	        AppendVisibleStr[str, Atom.GetPName[v.v]];	      block =>		FOR i: CARDINAL IN [v.v^.startIndex..v.v^.stopIndexPlusOne) DO		  AppendVisibleChar[str, LOOPHOLE[v.v^.blockPointer^[i]]];		  ENDLOOP;	      char =>	        AppendVisibleChar[str, v.v];	      str =>	        AppendVisibleStr[str, v.v];	      null => ERROR Error[tooFewValues];	      ENDCASE => ERROR Error[typeMismatch];	    END;	  'q, 'Q =>	    BEGIN	    WITH v: val SELECT FROM	      atom =>	        AppendLiteralStr[str, Atom.GetPName[v.v]];	      block =>		FOR i: CARDINAL IN [v.v^.startIndex..v.v^.stopIndexPlusOne) DO		  AppendLiteralChar[str, LOOPHOLE[v.v^.blockPointer^[i]]];		  ENDLOOP;	      char =>	        AppendLiteralChar[str, v.v];	      str =>	        AppendLiteralStr[str, v.v];	      null => ERROR Error[tooFewValues];	      ENDCASE => ERROR Error[typeMismatch];	    END;	  'b, 'B, 'o, 'O, 'd, 'D, 'x, 'X =>	    BEGIN	    base: CARDINAL = SELECT format[fi] FROM	      'b, 'B => 2, 'o, 'O => 8, 'd, 'D => 10, 'x, 'X => 16,	      ENDCASE => ERROR;	    n: LONG CARDINAL;	    WITH v: val SELECT FROM	      bool =>		n _ IF v.v THEN 1 ELSE 0;	      char =>		n _ ORD[v.v];	      card =>		n _ v.v;	      int => {		IF v.v < 0 THEN minus _ TRUE;		n _ ABS[v.v]};	      real => {		IF v.v < 0 THEN minus _ TRUE;		n _ RoundLC[ABS[v.v]]};	      null => ERROR Error[tooFewValues];	      ENDCASE => ERROR Error[typeMismatch];	    Format.LongNumber[StrSP, n, [base: base]];	    END;	  'r, 'R =>	    BEGIN	    n: LONG CARDINAL;	    WITH v: val SELECT FROM	      card =>		n _ v.v;	      int => {		IF v.v < 0 THEN minus _ TRUE;		n _ ABS[v.v]};	      real => {		IF v.v < 0 THEN minus _ TRUE;		n _ RoundLC[ABS[v.v]]};	      null => ERROR Error[tooFewValues];	      ENDCASE => ERROR Error[typeMismatch];	    PutS[	      str, "%g:%02g:%02g"L,	      [card[n / 3600]], [card[(n / 60) MOD 60]], [card[n MOD 60]]];	    END;	  'e, 'E =>	    BEGIN	    WITH v: val SELECT FROM	      real => {		IF v.v < 0 THEN minus _ TRUE;		Real.AppendReal[str, ABS[v.v], precision, TRUE]};	      null => ERROR Error[tooFewValues];	      ENDCASE => ERROR Error[typeMismatch];	    END;	  'f, 'F =>	    BEGIN	    WITH v: val SELECT FROM	      real => {		IF v.v < 0 THEN minus _ TRUE;		Real.AppendReal[str, ABS[v.v], precision, FALSE]};	      null => ERROR Error[tooFewValues];	      ENDCASE => ERROR Error[typeMismatch];	    END;	  '% =>	    BEGIN	    Format.Char[sp, '%, cd];	    LOOP;	    END;	  ENDCASE => ERROR Error[unknownFormat];	fi _ fi + 1;	-- It's all over but the shooting - put out str with appropriate filling.	IF minus THEN	  BEGIN	  Format.Char[sp, '-, cd];	  IF fieldWidth > 0 THEN fieldWidth _ fieldWidth - 1;	  END;	IF fieldWidth <= str.length THEN	  Format.Text[sp, str, cd]	ELSE	  IF zeroFill THEN	    BEGIN	    THROUGH [0..fieldWidth-str.length) DO	      Format.Char[sp, '0, cd]; ENDLOOP;	    Format.Text[sp, str, cd];	    END	  ELSE IF leftJustify THEN	    BEGIN	    Format.Text[sp, str, cd];	    Format.Blanks[sp, fieldWidth-str.length, cd];	    END	  ELSE	    BEGIN	    Format.Blanks[sp, fieldWidth-str.length, cd];	    Format.Text[sp, str, cd];	    END;	RETURN;	END;      ENDLOOP;    -- We ran off the end of the format string - the value had better be null.    IF val.type # null THEN ERROR Error[tooManyValues];    END;    OneSPNoFormat: PROC [sp: Format.StringProc, cd: LONG POINTER, val: Value] =    BEGIN    minus: BOOLEAN;    str: LONG STRING _ [MAXSTRING];    IF val.type = null THEN RETURN;    minus _ OneGeneral[str, val, Real.DefaultSinglePrecision];    IF minus THEN Format.Char[sp, '-, cd];    Format.Text[sp, str, cd]    END;  OneGeneral: PROC [str: LONG STRING, val: Value, precision: CARDINAL]    RETURNS [minus: BOOLEAN _ FALSE] =    BEGIN    StrSP: Format.StringProc = {String.AppendString[str, s]};    WITH v: val SELECT FROM      atom =>	String.Copy[str, Atom.GetPName[v.v]];      block =>	FOR i: CARDINAL IN [v.v^.startIndex..v.v^.stopIndexPlusOne) DO	  String.AppendChar[str, LOOPHOLE[v.v^.blockPointer^[i]]];	  ENDLOOP;      bool =>	IF v.v THEN String.Copy[str, "TRUE"L]	ELSE String.Copy[str, "FALSE"L];      char =>	String.AppendChar[str, v.v];      card =>	Format.LongNumber[StrSP, v.v, []];      int => {	IF v.v < 0 THEN minus _ TRUE;	Format.LongNumber[StrSP, ABS[v.v], []]};      real => {	IF v.v < 0 THEN minus _ TRUE;	Real.AppendReal[str, ABS[v.v], precision]};      str =>	String.Copy[str, v.v];      time =>	Format.Date[StrSP, v.v, dateTime, ANSI];      null => ERROR Error[tooFewValues];      ENDCASE => ERROR Error[typeMismatch];    END;  AppendVisibleStr: PROC [to, from: LONG STRING] =    BEGIN    FOR i: CARDINAL IN [0..String.Length[from]) DO      AppendVisibleChar[to, from[i]];      ENDLOOP;    END;  AppendVisibleChar: PROC [to: LONG STRING, from: CHAR] =    BEGIN    SELECT from FROM      IN [000C..037C] => {        String.AppendChar[to, '­];	String.AppendChar[to, VAL[ORD[from] + ORD['@]]]};      177C =>        String.AppendString[to, "^?"L];      >= 200C => {        ToSP: Format.StringProc = {String.AppendString[to, s]};        String.AppendChar[to, '\\];	Format.Number[ToSP, ORD[from], [base: 8, zerofill: TRUE, columns: 3]]};      ENDCASE =>        String.AppendChar[to, from];    END;    AppendLiteralStr: PROC [to, from: LONG STRING] =    BEGIN    FOR i: CARDINAL IN [0..String.Length[from]) DO      AppendLiteralChar[to, from[i]];      ENDLOOP;    END;  AppendLiteralChar: PROC [to: LONG STRING, from: CHAR] =    BEGIN    SELECT from FROM      '\n => String.AppendString[to, "\\n"L];      '\r => String.AppendString[to, "\\r"L]; -- \r = \n for now, so this statement is never reached.  I'll bet the compiler doesn't produce any code for it anyway.      '\t => String.AppendString[to, "\\t"L];      '\b => String.AppendString[to, "\\b"L];      '\f => String.AppendString[to, "\\f"L];      '\l => String.AppendString[to, "\\l"L];      '" => String.AppendString[to, "\\\""L];      <= 037C, >= 200C => {        ToSP: Format.StringProc = {String.AppendString[to, s]};        String.AppendChar[to, '\\];	Format.Number[ToSP, ORD[from], [base: 8, zerofill: TRUE, columns: 3]]};      ENDCASE => String.AppendChar[to, from];    END;    RoundLC: PROCEDURE [r: REAL] RETURNS [lc: LONG CARDINAL] =    -- Because Real.RoundLC does not exist, we have to hack this.    BEGIN    lliR: REAL = LAST[LONG INTEGER];    lliLC: LONG CARDINAL = LAST[LONG INTEGER];    IF r <= lliR THEN      lc _ Real.RoundLI[r]    ELSE      BEGIN      r _ r - lliR;      lc _ Real.RoundLI[r];      lc _ lc + lliLC;      END;    END;  END.*Unix is a trademark of Bell Labs.
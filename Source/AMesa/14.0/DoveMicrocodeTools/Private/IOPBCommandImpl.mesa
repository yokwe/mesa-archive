-- File: IOPBCommandImpl.mesa - last edit:-- Bowers.PA           30-Sep-86 18:26:05-- JAC.PA           27-Aug-85 12:50:11	added SHARES DoveInputOutput-- Copyright (C) 1984, 1985, 1986 by Xerox Corporation. All rights reserved.-- after IOPCommander.mesa, HGM, 10-Nov-83 13:31:46DIRECTORY  Bindweed,  DAsm,  DoveInputOutput,  Format USING [NumberFormat],  Heap USING [Create, Delete],  Inline,  IOPB,  IOPBWindow USING [pcInitialized],  MFile,  Put,  Process USING [MsecToTicks, Pause],  String USING [AppendChar, AppendString, AppendLongNumber, Empty],  System USING [AdjustGreenwichMeanTime, GetGreenwichMeanTime, GreenwichMeanTime],  Time,  CommandFile USING [AbortProc],  I186 USING [Address],  IOPBBreak,  IOPBCommand,  IOPBKernel,  IOPBSymbol,  OMF,  UserInput,  PanelSW;IOPBCommandImpl: PROGRAM  IMPORTS    Bindweed, DAsm, Heap, Inline, IOPB, IOPBWindow, MFile, Process, Put, String, System, IOPBBreak,    IOPBKernel, IOPBSymbol, OMF, PanelSW, UserInput  EXPORTS IOPBCommand, IOPB   SHARES DoveInputOutput =  BEGIN  -- HAVE I186WINDOW DELETE THIS HEAP WHEN IT DEACTIVATES  handle: OMF.Handle ¬ NIL;  z: UNCOUNTED ZONE ¬ NIL;  stepping: BOOLEAN ¬ FALSE;  Error: PUBLIC ERROR [code: IOPB.ErrorCode, s: LONG STRING ¬ NIL] = CODE;    AppendBreakpointList: PUBLIC PROC [    log: LONG POINTER, processor: IOPB.Processor] = {    i: CARDINAL ¬ 0;    PrintOne: PROCEDURE [pc: I186.Address] = {      temp: LONG STRING = [100];      i ¬ i + 1;      Put.Text[log, "80186 Break #"L];      Put.Decimal[log, i];      Put.Text[log, " is located at "L];      String.AppendLongNumber[temp, pc, 16];      String.AppendString[temp, " ("L];      IOPBSymbol.AppendAddress[temp, pc, processor];      String.AppendString[temp, ")."L];      Put.Line[log, temp];      };    Put.CR[log];    Put.Line[log, "80186 Breakpoints:"L];    IOPBBreak.EnumerateBreaks[PrintOne, processor];    Put.Line[log, "Done"L];    };    AppendInstructions: PUBLIC PROC [    log: LONG POINTER, s: LONG STRING, processor: IOPB.Processor,     howMany: CARDINAL] = {    value: IOPBSymbol.Symbol ¬ IOPBSymbol.Eval[s, byte, processor].symbol;    addressType: IOPB.AddressType;    address: I186.Address;    str: LONG STRING ¬ [100];    length: CARDINAL;    WITH value SELECT FROM      register => {Put.Line[log, "Must be a memory location."L]; RETURN};      byte, word => {address ¬ addr; addressType ¬ addrType};      ENDCASE => ERROR;    Put.CR[log];    THROUGH [0..howMany) DO      String.AppendLongNumber[str, address, 16];      String.AppendString[str, "     "L];      length ¬ DAsm.DisassembleInstruction[        address: address, addressType: processor, s: str];      address ¬ address + length;      IF String.Empty[str] THEN Put.Line[log, "Disassembly ERROR"L]       ELSE Put.Line[log, str];      str.length ¬ 0;      ENDLOOP;    };      AppendStack: PUBLIC PROC [    log: LONG POINTER, processor: IOPB.Processor, howDeep: CARDINAL] = {    ss, sp: CARDINAL;    Put.Line[log, "\nScanning 80186 Stack ...\n"L];    ss ¬ IOPBKernel.ReadRegister[SS, processor];    sp ¬ IOPBKernel.ReadRegister[SP, processor];        FOR i: CARDINAL IN [0..howDeep) DO      word: WORD;      IF UserInput.UserAbort[log] THEN EXIT;      word ¬ IOPBKernel.ReadMemoryWord[LONG[ss] * 16 + sp, processor];      Put.Number[log, ss, [16, TRUE, TRUE, 4]];      Put.Char[log, ':];      Put.Number[log, sp, [16, TRUE, TRUE, 4]];      Put.Text[log, " = "L];      Put.Number[log, word, [16, TRUE, TRUE, 4]];      Put.CR[log];      sp ¬ sp + 2;      -- want to get wrap around: if sp = LAST[CARDINAL] => sp + 2 = 1      ENDLOOP;   };  Boot: PUBLIC PROC [log: LONG POINTER] =    BEGIN    ENABLE      BEGIN      PanelSW.ClientError => ERROR IOPB.Error[panelError, msg];      END;    Put.Text[log, "Booting 80186 ... "L];    IOPBBreak.Reset[iop];    IOPBBreak.Reset[pc];    IOPBKernel.Boot[];    PrintState[log, IOPBKernel.GetState[], iop];    END;  Break: PUBLIC PROC [    log: LONG POINTER, s: LONG STRING, processor: IOPB.Processor] =    BEGIN    pc: IOPBSymbol.Symbol;    where: I186.Address;    IF NOT IOPBKernel.InKernel[] THEN ERROR IOPB.Error[runningOrDead];    Put.Text[log, "Setting 80186 Break at "L];    Put.Text[log, s];    pc ¬ IOPBSymbol.Eval[s, byte, processor].symbol;    WITH pc SELECT FROM      byte, word =>        BEGIN        temp: STRING = [20];        where ¬ addr;        String.AppendString[temp, " = "L];        String.AppendLongNumber[temp, where, 16];        String.AppendChar[temp, ' ];        Put.Text[log, temp];        END;      ENDCASE => ERROR IOPB.Error[invalidAddress];    Put.Text[log, " ... "L];    IOPBBreak.Break[where, processor];    Put.Line[log, "ok."L];    END;  CleanUp: PUBLIC PROC [processor: IOPB.Processor] = {    IOPBSymbol.DestroyTables[processor]};  Continue: PUBLIC PROC [log: LONG POINTER] =    BEGIN    IF NOT IOPBKernel.InKernel[] THEN ERROR IOPB.Error[runningOrDead];    Put.Text[log, "Continuing 80186 ... "L];    IOPBBreak.RemoveBreaks[];  -- Backup PC if at Break    IOPBBreak.InstallBreaks[];    IF IOPBBreak.AtBreak[IOPBKernel.ReadPC[iop], iop] THEN {      IOPBKernel.WriteMemoryByte[041FH --IsABreakPoint-- , iop, 01 --YES-- ];      IOPBKernel.WriteMemoryWord[        0422H --CSOfBreakPoint-- , iop, IOPBKernel.ReadRegister[CS, iop]];      IOPBKernel.WriteMemoryWord[        0424H --IPOfBreakPoint-- , iop, IOPBKernel.ReadRegister[IP, iop]];      SetTrapAndClearIntFlags[iop]};  -- single step broken instruction     <<     IF IOPBBreak.AtBreak[IOPBKernel.ReadPC[iop], iop] THEN {      IOPBKernel.WriteMemoryByte[041FH --IsABreakPoint-- , iop, 01 --YES-- ];      IOPBKernel.WriteMemoryWord[        0422H --CSOfBreakPoint-- , iop, IOPBKernel.ReadRegister[CS, iop]];      IOPBKernel.WriteMemoryWord[        0424H --IPOfBreakPoint-- , iop, IOPBKernel.ReadRegister[IP, iop]];      SetTrapAndClearIntFlags[iop]};  -- single step broken instruction      >>    IOPBKernel.WriteSavedRegisters[iop];     -- THIS MUST BE FIXED SO THAT PC REGISTERS ARE ONLY WRITTEN WHEN OPIE ADDRESS MAPPING IS SET UP FOR PCLOGICAL ADDRESSES     IF IOPBWindow.pcInitialized THEN IOPBKernel.WriteSavedRegisters[pc];    IOPBKernel.Continue[];    -- Give easy breaks time to take => avoid double state change printout    <<    IF ~silent THEN PrintState[log];    IOPBCommand.RefreshWindow[];  -- implemented in I186WindowImpl    >>    END;  ContinueAndWait: PUBLIC PROC [    log: LONG POINTER, abort: CommandFile.AbortProc, ms: LONG CARDINAL] = {    start: System.GreenwichMeanTime = System.GetGreenwichMeanTime[];    stop: System.GreenwichMeanTime = System.AdjustGreenwichMeanTime[      start, (ms + 999) / 1000];    Continue[log];    DO      IF IOPBKernel.GetState[] # running THEN EXIT;      Process.Pause[Process.MsecToTicks[500]];      IF abort[] THEN ERROR IOPB.Error[aborted];      IF ms = 0 THEN LOOP;  -- Forever case      IF System.GetGreenwichMeanTime[] > stop THEN ERROR IOPB.Error[didntStop];      ENDLOOP;    --IOPBBreak.RemoveBreaks[];    };  Initialize: PUBLIC PROC [processor: IOPB.Processor] = {    IOPBSymbol.CreateTables[processor]};  ConvertToPCLogical: PROC [address: I186.Address]    RETURNS [convertedAddr: I186.Address] = {    opieAddress: DoveInputOutput.OpieAddress ¬ [      A15toA0: LOOPHOLE[Inline.LowHalf[address]],      A23toA16: Inline.HighHalf[address] MOD 256, type: pcLogical];    convertedAddr ¬ LOOPHOLE[opieAddress]};  LoadPEData: PROC [    pEDataPtr: LONG POINTER TO OMF.PhysicalEnumeratedData, processor: IOPB.Processor] =    {    address: I186.Address ¬ LONG[pEDataPtr.frameNumber] * 16 + pEDataPtr.offset;    IOPBKernel.WriteMemoryDataSequence[      address: address, addressType: processor, data: pEDataPtr.dataPtr];    };  LoadStartAddress: PROC [    modEndPtr: LONG POINTER TO OMF.ModuleEndData, processor: IOPB.Processor] = {    IF NOT modEndPtr.moduleType.hasStartAddress THEN RETURN;    WITH start: modEndPtr SELECT FROM      physicalAddr => {        IOPBKernel.WriteRegister[          reg: CS, data: start.frameNumber, processor: iop];        IOPBKernel.WriteRegister[          reg: IP, data: Inline.LowHalf[start.offset], processor: iop];        <<          Put.Text[log, "StartAddress: "L];          Put.LongNumber[            log, LONG[start.frameNumber] * 16 + start.offset, hexFormat];          Put.CR[log];	  >>        };      ENDCASE => ERROR IOPB.Error[illegalStartAddr];    };  LoadPIData: PROC [    pIDataPtr: LONG POINTER TO OMF.PhysicalIteratedData,    processor: IOPB.Processor] = {    initialSize: NATURAL = 64;    address: I186.Address ¬ 0;    maxBufferSize: NATURAL = Bindweed.maxData;    totalData: LONG POINTER TO OMF.DataSequence ¬ NIL;    <<    ProcessIteratedData: PROC [iBlockPtr: LONG POINTER TO OMF.IteratedBlock] = {      THROUGH [1..iBlockPtr.repeatCount] DO        IF iBlockPtr.blockCount = 0 THEN {	  AppendBlock[iBlockPtr.dataPtr];	  IF totalData.length > maxBufferSize THEN {	    IOPBKernel.WriteMemoryDataSequence[              address: address, addressType: processor, data: totalData];	    address ¬ address + totalData.length;	    totalData.length ¬ 0;	    };	  }        ELSE ProcessIteratedData[iBlockPtr.next];        ENDLOOP;      };    >>                ProcessIteratedData: PROC [iBlockPtr: LONG POINTER TO OMF.IteratedBlock] = {      IF iBlockPtr.blockCount = 1        AND iBlockPtr.next.blockCount = 0	AND iBlockPtr.next.repeatCount = 1 THEN {	data: LONG POINTER TO OMF.DataSequence ¬ iBlockPtr.next.dataPtr;	blockLen: CARDINAL ¬ data.length;	repeatCount: CARDINAL ¬ iBlockPtr.repeatCount;	buffSize: CARDINAL ¬ maxBufferSize/blockLen * blockLen;	-- assume blockLen < maxBuffSize	buffsToSend: CARDINAL ¬ (repeatCount*blockLen+buffSize-1)/buffSize;	totalData ¬ z.NEW[OMF.DataSequence[buffSize] ¬ [length: 0, seq: NULL]];	FOR i: CARDINAL IN [0..buffSize/blockLen) DO	  FOR j: CARDINAL IN [0..blockLen) DO	    totalData[i*blockLen+j] ¬ data[j];	    ENDLOOP;	  ENDLOOP;	totalData.length ¬ buffSize;	FOR i: CARDINAL IN [0..buffsToSend) DO	  IF i = buffsToSend - 1 THEN	    totalData.length ¬ repeatCount*blockLen MOD buffSize;	  IOPBKernel.WriteMemoryDataSequence[              address: address, addressType: processor, data: totalData];	    address ¬ address + totalData.length;	  ENDLOOP;	};      };	                        AppendBlock: PROC [data: LONG POINTER TO OMF.DataSequence] = {      IF totalData.length + data.length < totalData.maxlength THEN {        FOR i: NATURAL IN [0..data.length) DO          totalData[totalData.length + i] ¬ data[i]; ENDLOOP;        totalData.length ¬ totalData.length + data.length}      ELSE {        tempData: LONG POINTER TO OMF.DataSequence ¬ z.NEW[          OMF .DataSequence[2 * (totalData.length + data.length)] ¬ [          length: 0, seq: NULL]];        FOR i: NATURAL IN [0..totalData.length) DO          tempData[i] ¬ totalData[i]; ENDLOOP;        FOR i: NATURAL IN [0..data.length) DO          tempData[totalData.length + i] ¬ data[i];          tempData.length ¬ totalData.length + data.length;          ENDLOOP;        z.FREE[@totalData];        totalData ¬ tempData;        }};	    address ¬ LONG[pIDataPtr.frameNumber] * 16 + pIDataPtr.offset;    ProcessIteratedData[pIDataPtr.iteratedDataBlockPtr];    <<      Put.Text[log, "Physical Iterated Data\nAddress: "L];      Put.LongNumber[        log, LONG[pIDataPtr.frameNumber] * 16 + pIDataPtr.offset, hexFormat];      Put.Line[log, "\nData:"L];      FOR i: CARDINAL IN [0..totalData.length) DO        Put.Number[log, totalData[i], hexFormat];        Put.Blank[log, 1];        ENDLOOP;      Put.CR[log];      Put.CR[log];      >>    <<    IOPBKernel.WriteMemoryDataSequence[      address: address, addressType: processor, data: totalData];      >>    };  Load: PUBLIC PROC [    log: LONG POINTER, fileName: LONG STRING, symbols, code: BOOLEAN,    processor: IOPB.Processor, abort: CommandFile.AbortProc] = {    ENABLE {      UNWIND => {        handle ¬ OMF.ReleaseHandle[handle: handle];        IF z # NIL THEN Heap.Delete[z];        z ¬ NIL};      };    endOfInput: BOOLEAN ¬ FALSE;    symbolsLoaded: CARDINAL ¬ 0;    recordType: OMF.RecordType ¬ null;    hexFormat: Format.NumberFormat = [base: 16];    create: Time.Packed;    aborted: BOOLEAN ¬ FALSE;    -- DIFFICULT TO RECLAIM THE SPACE USED BY THIS PROC,    -- EASIER TO DELETE HEAP ON EXIT    Put.Text[log, "Loading "L];    SELECT TRUE FROM      code AND processor = iop => Put.Text[log, "IOP from "L];      code AND processor = pc => Put.Text[log, "PC from "L];      symbols AND NOT code => Put.Text[log, "symbols from "L];      ENDCASE => ERROR;    Put.Text[log, fileName];    Put.Text[log, "..."L];    z ¬ Heap.Create[initial: 50, increment: 50];    --IF code AND NOT IOPBKernel.InKernel[] THEN ERROR Error["Aborted...not in Kernel"L];    -- Be sure you have booted first or you won't have a symbol table    [handle, create] ¬ OMF.GetHandle[      operation: read, fileName: fileName, extension: "loc"L, heap: z !      MFile.Error => IF code = noSuchFile THEN CONTINUE ELSE REJECT];    IF handle = NIL THEN      [handle, create] ¬ OMF.GetHandle[        operation: read, fileName: fileName, extension: "lm"L, heap: z];    UNTIL endOfInput DO      IF abort[] THEN {aborted ¬ TRUE; EXIT};      recordType ¬ OMF.GetRecordType[handle: handle];      SELECT recordType FROM        debugSymbol =>          IF symbols THEN LoadSymbols[OMF.GetDebugSymbols[handle], processor];        physicalEnumeratedData =>          IF code THEN            LoadPEData[              pEDataPtr: OMF.GetPhysicalEnumeratedData[handle],              processor: processor];        physicalIteratedData =>          IF code THEN            LoadPIData[              pIDataPtr: OMF.GetPhysicalIteratedData[handle],              processor: processor];        publicDefinition =>          IF symbols THEN            LoadPublicSymbols[OMF.GetPublicNames[handle], processor];        registerInitialization =>          IF code THEN            --LoadRegInt[regIntPtr: OMF.GetRegisterInitialization[handle]];            Put.Line[log, "This module has not been located."L];        moduleEnd =>          IF code THEN            LoadStartAddress[              modEndPtr: OMF.GetModuleEnd[handle], processor: processor];        ENDCASE => NULL;      endOfInput ¬ OMF.AdvanceToNextRecord[handle: handle];      ENDLOOP;    handle ¬ OMF.ReleaseHandle[handle: handle];    Heap.Delete[z];    z ¬ NIL;    SELECT TRUE FROM      aborted => Put.Line[log, " Aborted."L];       symbols => {	-- sort address map and do Xreffing with symbol table	symbolsLoaded ¬ IOPBSymbol.Sort[processor];	Put.Text[log, " Total Symbols: "L];	Put.Decimal[log, symbolsLoaded];	Put.Line[log, " Done."L]};      ENDCASE => Put.Line[log, " Done."L];    };  LoadSymbols: PROC [    debugSymPtr: LONG POINTER TO OMF.DebugSymbols, processor: IOPB.Processor] = {    frame: LONG CARDINAL;    WITH debSym: debugSymPtr.frameInformation SELECT FROM      basedSymbol => frame ¬ debSym.base.frameNumber;      ENDCASE => ERROR;    FOR symbols: LONG POINTER TO OMF.SymbolsRecord ¬ debugSymPtr.entries,      symbols.next UNTIL symbols = NIL DO      IOPBSymbol.Enter[        s: symbols.symbol, value: frame * 16 + symbols.offset,        processor: processor];      ENDLOOP;    };  LoadPublicSymbols: PROC [    pubDefPtr: LONG POINTER TO OMF.PublicNamesData, processor: IOPB.Processor] = {    frame: LONG CARDINAL;    IF pubDefPtr.publicBase.groupIndex # 0      OR pubDefPtr.publicBase.segmentIndex # 0 THEN      ERROR IOPB.Error[notLocatedModule];    frame ¬ pubDefPtr.publicBase.frameNumber;    FOR symbols: LONG POINTER TO OMF.PublicNamesNode ¬ pubDefPtr.namesList,      symbols.next UNTIL symbols = NIL DO      IOPBSymbol.Enter[        s: symbols.publicName, value: frame * 16 + symbols.publicOffset,        processor: processor];      ENDLOOP;    };  PrintState: PUBLIC PROC [    log: LONG POINTER, state: IOPBKernel.State, processor: IOPB.Processor] =    BEGIN    temp: LONG STRING  ¬ [100];    String.AppendString[temp, SELECT processor FROM      pc => "PC "L,      iop => "IOP "L,      ENDCASE => ERROR];    String.AppendString[temp, SELECT state FROM      dead => "is dead."L,      booted => "was booted."L,      running => "is running."L,      singleStep => "completed a single step at "L,      halted => "halted at "L,      iopBreak => "Break at "L,      ENDCASE => ERROR];    SELECT state FROM      singleStep, halted, iopBreak => {        csip: I186.Address = IOPBKernel.ReadPC[processor];        String.AppendLongNumber[temp, csip, 16];        String.AppendString[temp, " ("L];        IOPBSymbol.AppendAddress[temp, csip, processor];        String.AppendString[temp, ")."L];        };      ENDCASE => NULL;    Put.Line[log, temp];    END;  SetTrapAndClearIntFlags: PROC [processor: IOPB.Processor]= {    flags: WORD ¬ 0;    setTrapMask: WORD = 0100H;    clearIntMask: WORD = 0FDFFH;    pcSingleStepFlagsAddress: I186.Address = 0D0022H;    iopSingleStepFlagsAddress: I186.Address = 0420H;    singleStepFlagsAddress: I186.Address ¬ SELECT processor FROM      iop => iopSingleStepFlagsAddress,      pc => pcSingleStepFlagsAddress,      ENDCASE => ERROR;    flags ¬ IOPBKernel.ReadRegister[FLAGS, processor];    IOPBKernel.WriteMemoryWord[singleStepFlagsAddress , processor, flags];    flags ¬ Inline.BITOR[flags, setTrapMask];    flags ¬ Inline.BITAND[flags, clearIntMask];    -- set trap flag for hardware single step    IOPBKernel.WriteRegister[reg: FLAGS, data: flags, processor: processor];    };  Step: PUBLIC PROC [log: LONG POINTER, processor: IOPB.Processor] =    BEGIN    ENABLE UNWIND => stepping ¬ FALSE;    --seq: CARDINAL ¬ 0;    IF stepping THEN {Put.Text[log, "Already stepping"L]; RETURN};    stepping ¬ TRUE;    IF NOT IOPBKernel.InKernel[] THEN ERROR IOPB.Error[runningOrDead];    Put.Text[log, "Single Stepping 80186 ... "L];    IOPBBreak.RemoveBreaks[];  -- Backup PC if at Break    SetTrapAndClearIntFlags[processor];    IOPBKernel.WriteSavedRegisters[processor];  -- added for BINDWEED    --seq ¬ IOPBKernel.GetStateSeq[];    IOPBKernel.Continue[];    Process.Pause[Process.MsecToTicks[500]];    SELECT IOPBKernel.GetState[] FROM      dead => ERROR IOPB.Error[dead];      running => ERROR IOPB.Error[didntStop];      iopBreak, singleStep => NULL;      ENDCASE => ERROR;    --IF seq = IOPBKernel.GetStateSeq[] - 1 THEN ERROR IOPB.Error[didntStop];    stepping ¬ FALSE;    END;  Stop: PUBLIC PROC [log: LONG POINTER, processor: IOPB.Processor] =    BEGIN    Put.Text[log, "Stopping 80186 ... "L];    IOPBKernel.Stop[processor];    END;  Unbreak: PUBLIC PROC [    log: LONG POINTER, s: LONG STRING, processor: IOPB.Processor] =    BEGIN    pc: IOPBSymbol.Symbol;    where: I186.Address;    IF NOT IOPBKernel.InKernel[] THEN ERROR IOPB.Error[runningOrDead];    Put.Text[log, "Clearing 80186 Break at "L];    IF s = NIL THEN      BEGIN      temp: STRING = [20];      Put.Text[log, "current PC ... "L];      where ¬ IOPBKernel.ReadPC[iop];      String.AppendString[temp, " = "L];      String.AppendLongNumber[temp, where, 16];      String.AppendChar[temp, ' ];      Put.Text[log, temp];      Put.Text[log, " ... "L];      IOPBBreak.Unbreak[where, processor];      Put.Line[log, "ok."L];      RETURN;      END;    Put.Text[log, s];    pc ¬ IOPBSymbol.Eval[s, byte, IF processor = iop THEN iop ELSE pc].symbol;    WITH pc SELECT FROM      byte, word =>        BEGIN        temp: STRING = [20];        where ¬ addr;        String.AppendString[temp, " = "L];        String.AppendLongNumber[temp, where, 16];        String.AppendChar[temp, ' ];        Put.Text[log, temp];        END;      ENDCASE => ERROR IOPB.Error[invalidAddress];    Put.Text[log, " ... "L];    IOPBBreak.Unbreak[where, processor];    Put.Line[log, "ok."L];    END;  END.
--Program to generate the host address prom for the IOP.--last edited by Roy RXO  on January 28, 1981  3:57 PM--last edited by PXJ    on 4-Feb-81 14:24:36--last edited by Frank FXB     2-Nov-84 16:45:54--File: HostAddressProm.mesa--Stored: --Note:  The Host Number is obtained from a file on the disk, which in turn, was-- obtained from a server under Librarian control.--  Modification history:--     First version with only 16-bit low word in prom (November 6, 1980)--     Added full 48-bit address + checksum (November 6, 1980)DIRECTORY  Ascii USING [CR, SP],  Exec,  Format USING [Number, NumberFormat, StringProc],  Inline USING [BITSHIFT, BITAND, BITOR, BITXOR],  MStream,  PromBlow USING [WritePromData, WritePromList],  Stream,  String USING [AppendChar, AppendString];HostAddressProm: PROGRAM  IMPORTS Exec, Format, Inline, PromBlow, MStream, Stream, String =  BEGIN OPEN Inline;  -- Host address Prom definitions.  memSize: CARDINAL = 32;  --32 X 8 (HM7603 Prom)  addrWidth: CARDINAL = 5;  --number of prom address bits  dataWidth: CARDINAL = 8;  --number of physical data bits  Byte: TYPE = [0..0FFH];  -- 8 bits  hostNumber: TYPE =  --48-bit quantity--    RECORD [    SELECT OVERLAID * FROM    bytes => [bytes: PACKED ARRAY [0..6) OF Byte],    words => [words: ARRAY [0..3) OF CARDINAL],    ENDCASE];  Data: TYPE = MACHINE DEPENDENT RECORD [hAddr: Byte, pad2: Byte];  HostAddrProm: ARRAY [0..memSize] OF Data;  --image of Prom, padded to 16 bits   Error: ERROR [message: LONG STRING] = CODE;  --Set the whole Prom image to all 1's.--  ResetHostAddrProm: PROCEDURE =    BEGIN    i: CARDINAL;    FOR i IN [0..memSize) DO HostAddrProm[i] _ [0FFH, 0FFH] ENDLOOP    END;  --Convert a hex string to a number.--  StringToHex: PROCEDURE [s: LONG STRING] RETURNS [CARDINAL] =    BEGIN    i: CARDINAL;    n: CARDINAL _ 0;    FOR i IN [0..s.length) DO      SELECT s[i] FROM        IN ['0..'9] => n _ n * 16 + s[i] - '0;        IN ['A..'F] => n _ n * 16 + s[i] - 'A + 10;        IN ['a..'f] => n _ n * 16 + s[i] - 'a + 10;        ENDCASE => ERROR Error["Invalid hex number"L]      ENDLOOP;    RETURN[n]    END;  --Get the host number from LastAssignedDove.ID  --  GetHostID: PROCEDURE [fileName: LONG STRING] RETURNS [hostID: hostNumber] =    BEGIN    in: MStream.Handle ¬ MStream.ReadOnly[      fileName, [] ! MStream.Error => GO TO FileNotFound];    stream: MStream.Handle = MStream.ReadWrite["$$"L, [], text];    out: MStream.Handle ¬ NIL;    c: CHARACTER ¬ Ascii.CR;    Reset: PROCEDURE = {      IF in # NIL THEN in.delete[in];      in ¬ NIL;      stream.delete[stream];      IF out # NIL THEN out.delete[out]};    OutProc: Format.StringProc = {Stream.PutString[stream, s]};    BEGIN    ENABLE UNWIND => Reset;    HexFormat: Format.NumberFormat = [      base: 16, zerofill: TRUE, unsigned: TRUE, columns: 4];    FOR i: CARDINAL IN [0..2] DO      n: CARDINAL;      id: LONG STRING _ [8];      id.length ¬ 0;      UNTIL (c ¬ Stream.GetChar[in]) IN [Ascii.CR..Ascii.SP] OR id.length = 8 DO        String.AppendChar[id, c]; ENDLOOP;      IF id.length > 4 THEN Error["Hex String too long!"L];      n _ StringToHex[id];      hostID.words[i] ¬ n;      ENDLOOP;    IF (hostID.words[2] _ hostID.words[2] + 1) = 0 THEN Error["Overflow"L];    Format.Number[OutProc, hostID.words[0], HexFormat];    Stream.PutChar[stream, Ascii.SP];    Format.Number[OutProc, hostID.words[1], HexFormat];    Stream.PutChar[stream, Ascii.SP];    Format.Number[OutProc, hostID.words[2], HexFormat];    Stream.PutChar[stream, Ascii.CR];    DO      c _ Stream.GetChar[in ! Stream.EndOfStream => EXIT];      Stream.PutChar[stream, c];      ENDLOOP;    END;    in.delete[in];    in ¬ NIL;    Stream.SetPosition[stream, 0];    out ¬ MStream.WriteOnly[fileName, [], text];    [] ¬ MStream.Copy[from: stream, to: out, bytes: MStream.GetLength[stream]];    Reset;    RETURN[hostID]    EXITS FileNotFound => Error["File not found: LastAssignedDove.ID"L]    END;  MakeCheckSum: PROCEDURE [host: hostNumber] RETURNS [check, nCheck: Byte] =    BEGIN          MakeCheckByte: PROCEDURE [a, b: CARDINAL] RETURNS [result: CARDINAL] =      BEGIN  --Forms  ByteLRot[(a xor b), 1].--      temp1, temp2: CARDINAL;      temp1 _ BITXOR[a, b];  --Form (a xor b)      temp1 _ BITSHIFT[temp1, 1];  --Form byte rotate      temp2 _ BITAND[temp1, 0100H];  --Isolate bit shifted out      temp1 _ BITAND[temp1, 0FFH];  --Mask byte      result _        SELECT temp2 FROM          0 => temp1,  --bit was zero, do nothing          0100H => BITOR[temp1, 1],  --bit was one, OR in low bit          ENDCASE => temp1;  --can't occur      RETURN[result]      END;    --Form the checksum on successive bytes.    check _ MakeCheckByte[host.bytes[0], host.bytes[1]];    check _ MakeCheckByte[check, host.bytes[2]];    check _ MakeCheckByte[check, host.bytes[3]];    check _ MakeCheckByte[check, host.bytes[4]];    check _ MakeCheckByte[check, host.bytes[5]];    --Complement the checksum.    nCheck _ BITXOR[check, 0FFH];    END;  GenerateHostAddrProm: PROCEDURE RETURNS [error: BOOLEAN] =    BEGIN --Entire prom image has been filled with 1's.-- host: hostNumber;    --Get the next host number.    errorMessage.length _ 0;    host _ GetHostID[      "LastAssignedDove.ID" !      Error =>        BEGIN String.AppendString[errorMessage, message]; GO TO ErrorReturn END;      <<      ANY=> GO TO ErrorReturn      >> ];    FOR i: CARDINAL IN [0..6) DO HostAddrProm[i].hAddr ¬ host.bytes[i]; ENDLOOP;    --Store checksum word.    [HostAddrProm[6].hAddr, HostAddrProm[7].hAddr] _ MakeCheckSum[host];    RETURN[FALSE]    EXITS ErrorReturn => RETURN[TRUE]    END;  PutLine: PROCEDURE [out: MStream.Handle, s: LONG STRING] =    BEGIN Stream.PutString[out, s]; Stream.PutChar[out, Ascii.CR] END;  GoAway: PROCEDURE = {    IF in # NIL THEN in.delete[in];    in ¬ NIL;    IF out # NIL THEN out.delete[out];    out ¬ NIL};  errorMessage: LONG STRING _ [64];  out: MStream.Handle ¬ NIL;  in: MStream.Handle ¬ NIL;  --Main Program.  Main: Exec.ExecProc = {    in ¬ MStream.ReadOnly[      "BlowHostTail.cm", [] ! MStream.Error => GOTO noBlowHostTail];    out ¬ MStream.WriteOnly[      "line.cm", [], text ! MStream.Error => GOTO lineDotCmTrouble];    --IODefs.WriteString["Last assigned . . . "];    ResetHostAddrProm;    IF GenerateHostAddrProm[].error THEN      BEGIN      Stream.PutString[out, "//error - "];      IF errorMessage.length # 0 THEN        BEGIN        Stream.PutString[out, errorMessage];        Stream.PutString[out, " - "]        END;      PutLine[out, "LastAssignedDove.ID unaltered"];      PutLine[out, "type line.cm"];      Exec.OutputProc[h]["Errors...See line.cm.\n"L];      GoAway[];      RETURN;      END;    --IODefs.WriteLine[""];    PromBlow.WritePromData[      "LastAssignedDove",  memSize, dataWidth, @HostAddrProm[0], h];    PromBlow.WritePromList[      "LastAssignedDove",addrWidth, dataWidth, @HostAddrProm[0], h];    DO      c: CHARACTER;      c _ Stream.GetChar[in ! Stream.EndOfStream => EXIT];      Stream.PutChar[out, c]      ENDLOOP;    GoAway;    EXITS      noBlowHostTail => {        Exec.OutputProc[h]["Please retrieve BlowHostTail.cm\n"L]; GoAway};      lineDotCmTrouble => {        Exec.OutputProc[h]["Trouble overwriting line.cm\n"L]; GoAway}};  Exec.AddCommand[name: "BlowHost.~"L, proc: Main];  END.  
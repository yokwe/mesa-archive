-- PromBlowToolA.mesa -- Main module for PromBlowTool-- User interface stuff here (window, exec, etc)-- Last edit by:-- Purves,    28-Aug-85 15:03:52   supports start time and % complete-- created by Purves on 21-Aug-85 18:44:43-- Copyright (C) 1985 by Xerox Corporation. All rights reserved.DIRECTORY  PromBlowToolDefs,  Exec,  Format,  FormSW,  Heap,  Process,  RS232CProlog,  String,  Time,  Tool,  ToolDriver,  ToolWindow,  UserInput,  Window,  WindowFont;  PromBlowToolA: MONITOR   IMPORTS PromBlowToolDefs, Exec, FormSW, Heap, Process, RS232CProlog, String, Time, Tool, ToolDriver, ToolWindow, UserInput, WindowFont  EXPORTS    PromBlowToolDefs = { OPEN PromBlowToolDefs;    -- Private Stuff  answer: CONDITION;  updatePercent: CONDITION;    waitForAction: BOOL ¬ FALSE;  didConfirm: BOOL ¬ FALSE;  -- Public Stuff  data: PUBLIC DataHandle ¬ NIL;  isBusy: PUBLIC BOOL ¬ FALSE;  abort: PUBLIC BOOL ¬ FALSE;  wh: PUBLIC Window.Handle ¬ NIL;  -- Tool's window  heap: PUBLIC UNCOUNTED ZONE ¬ NIL;<<*************************************************************>><<                 Data related routines		       >><<*************************************************************>>  InitHeap: PROCEDURE = INLINE {heap ¬ Heap.Create[initial: 1]; };  KillHeap: PROCEDURE = INLINE {Heap.Delete[heap]; heap ¬ NIL; };<<*************************************************************>><<                 Exec related routines		       >><<*************************************************************>>-- Call back procedures registered with Exec.  Also Init and auxiliaries-- Help Unload Init PromProgrammer ProgramHostAddress  Help: Exec.ExecProc = {    OutputProc: Format.StringProc ¬ Exec.OutputProc[h];    h.OutputProc[][      "This command activates the Prom Programmer Tool window.     The Prom Programmer Tool is used for interfacing with the Prolog M980 Prom Programmer over the RS232C interface.  For more details see the Prom Programming documentation in the Dandelion Development file drawer on Tundra."L];  };  Unload: Exec.ExecProc = {    IF wh # NIL THEN Tool.Destroy[wh];    wh ¬ NIL;    [] ¬ Exec.RemoveCommand[h, "PromProgrammer.~"L];  };  Init: PROCEDURE = {    Process.SetTimeout[@updatePercent, Process.SecondsToTicks[5]];    Exec.AddCommand["PromProgrammer.~"L, PromProgrammer, Help, Unload];     Exec.AddCommand["ProgramHostAddress.~"L, ProgramHostAddress];  };      PromProgrammer: Exec.ExecProc = {    IF heap = NIL THEN InitHeap[];    IF wh = NIL       THEN wh ¬ MakeTool[]      ELSE SELECT ToolWindow.GetState[wh] FROM	inactive => ToolWindow.Activate[wh];	tiny     => ToolWindow.MakeSize[wh,normal];	active   => NULL;	ENDCASE  => ERROR;  };      ProgramHostAddress: Exec.ExecProc = {    token, switches: LONG STRING ¬ NIL;    OutputProc : Format.StringProc ¬ Exec.OutputProc[h];    prompt: LONG STRING = "Please Blow the Host Address Prom then hit return."L;    DO      [token, switches] ¬ Exec.GetToken[h];      IF token = NIL OR switches = NIL THEN EXIT;      SELECT switches[0] FROM        'c => {	  data.chip.length ¬ 0;	  String.AppendStringAndGrow[        to: @data.chip, from: token, z: heap]};	'f => {	  data.fileName.length ¬ 0;          String.AppendStringAndGrow[             to: @data.fileName, from: token, z: heap]};	 ENDCASE => NULL;       switches ¬ Exec.FreeTokenString[switches];       token ¬ Exec.FreeTokenString[token];       ENDLOOP;     switches ¬ Exec.FreeTokenString[switches];     token ¬ Exec.FreeTokenString[token];     data.field ¬ FirstByte;     FormSW.Display[data.formSW];     OutputProc[prompt];     [] ¬ Exec.Confirm[h];   };     <<*************************************************************>><<                 Window related routines		       >><<*************************************************************>>-- call back procedures registered with FormSW to do the work-- Write Verify Read Catalog SetDebug  Write: FormSW.ProcType = {    IF isBusy THEN {Complain["PromProgrammer is already busy."L]; RETURN};    abort ¬ FALSE;    isBusy ¬ TRUE;    Process.Detach[FORK UpdateStatus];    Process.Detach[FORK BlowDotBinOrDotProm[data.fileName, FALSE]];  };  Verify: FormSW.ProcType = {    IF isBusy THEN {Complain["PromProgrammer is already busy."L]; RETURN};    abort ¬ FALSE;    isBusy ¬ TRUE;    Process.Detach[FORK UpdateStatus];    Process.Detach[FORK BlowDotBinOrDotProm[data.fileName, TRUE]];  };  Read: FormSW.ProcType = {    IF isBusy THEN {Complain["PromProgrammer is already busy."L]; RETURN};    abort ¬ FALSE;    isBusy ¬ TRUE;    Process.Detach[FORK UpdateStatus];    Process.Detach[FORK ReadProgrammerBuffer];  };  Catalog: FormSW.ProcType = {    DisplayPromSpecs[];  };  SetDebug: FormSW.NotifyProcType = {    RS232CProlog.SetDebugFlag[data.debug];  };    Confirmed: PUBLIC ENTRY PROC RETURNS [BOOL] = {    waitForAction ¬ TRUE;    WHILE waitForAction DO WAIT answer ENDLOOP;    RETURN[didConfirm];  };  Confirm:  ENTRY FormSW.ProcType = {    IF NOT waitForAction THEN {Complain["Nothing to confirm"L]; RETURN};    abort ¬ FALSE;    didConfirm ¬ TRUE;    waitForAction ¬ FALSE;    NOTIFY answer};  Deny:  ENTRY FormSW.ProcType = {    IF NOT waitForAction THEN {Complain["Nothing to deny"L]; RETURN};    abort ¬ FALSE;    didConfirm ¬ FALSE;    waitForAction ¬ FALSE;    NOTIFY answer};      GetTime: PROC [now: Time.Unpacked] = {    data.time ¬ heap.NEW[StringBody[8]];    IF now.hour < 10 THEN String.AppendChar[data.time, '0];    String.AppendNumber[data.time, now.hour];    String.AppendChar[data.time, ':];    IF now.minute < 10 THEN String.AppendChar[data.time, '0];    String.AppendNumber[data.time, now.minute];    String.AppendChar[data.time, ':];    IF now.second < 10 THEN String.AppendChar[data.time, '0];    String.AppendNumber[data.time, now.second];  };      UpdateStatus: ENTRY PROC = {    GetTime[Time.Unpack[Time.Current[]]];  -- init data.time    data.percent ¬ 0;                      -- init data.percent    FormSW.ToggleVisibility[data.formSW, FormItems.time.ORD];    FormSW.ToggleVisibility[data.formSW, FormItems.percent.ORD];    UNTIL abort OR (~ isBusy) DO      data.percent ¬ IF dataLength = 0        THEN 0	ELSE CARDINAL[(dataPos * 100)/ dataLength];      FormSW.DisplayItem[data.formSW, FormItems.percent.ORD];      WAIT updatePercent;    ENDLOOP;    IF data # NIL THEN {      FormSW.ToggleVisibility[data.formSW, FormItems.percent.ORD];      FormSW.ToggleVisibility[data.formSW, FormItems.time.ORD];      heap.FREE[@data.time];    };  };      -- Window creation procedures-- MakeTool ClientTransition MakeForm MakeSWs Abort  MakeTool: PROCEDURE RETURNS [wh: Window.Handle] = {    RETURN[      Tool.Create[        makeSWsProc: MakeSWs, initialState: default,        clientTransition: ClientTransition, name: "Prom Programmer Tool"L,        cmSection: "Prom Programmer Tool"L, tinyName1: "Prom"L,        tinyName2: "Programmer"L]]};  ClientTransition: ToolWindow.TransitionProcType = {    SELECT TRUE FROM      old = inactive => {        RS232CProlog.RS232CInit[];        IF heap = NIL THEN InitHeap[];        IF data = NIL THEN data ¬ heap.NEW[Data ¬ []];	data.fileName ¬ heap.NEW[StringBody[10]];	data.chip ¬ heap.NEW[StringBody[10]];      };      new = inactive => {  -- potential race condition with dying processes and data accesses if deactivated while isBusy        ToolDriver.RemoveSWs[tool: "Prom Programmer Tool"L];        IF data # NIL THEN {          FormSW.Destroy[data.formSW];	  heap.FREE[@data.fileName];	  heap.FREE[@data.chip];          heap.FREE[@data];          FreeImage;        };        IF heap # NIL THEN KillHeap[];        StopOurselves;        RS232CProlog.TransitionToInactiveState;      };    ENDCASE;  };  charWidth: CARDINAL ¬ WindowFont.CharWidth['0];  CharPos: PROC[char: CARDINAL] RETURNS [x: INTEGER] = {    x ¬ charWidth * char};     MakeForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = FormItems.LAST.ORD + 1;    field: ARRAY[0..7) OF Enumerated ¬ [      ["All Bits"L, 0], ["First Byte"L, 1],      ["Second Byte"L, 2], ["First Nibble"L, 3],      ["Second Nibble"L, 4], ["Third Nibble"L, 5],      ["Fourth Nibble"L, 6]];    virgin: ARRAY[0..2) OF Enumerated ¬ [      ["zeroes"L, 0], ["ones"L, 1]];    String.AppendString[to: data.chip, from: "2716"L];    items ¬ AllocateItemDescriptor[nItems, heap];    items[FormItems.fileName.ORD] ¬ StringItem[tag: "fileName"L,       place: [CharPos[0], line0], inHeap: TRUE, string: @data.fileName, z:heap];    items[FormItems.write.ORD] ¬ CommandItem[tag: "Write"L,       place: [CharPos[0], line1], proc: Write, z:heap];    items[FormItems.list.ORD] ¬ BooleanItem[tag: "List"L,       place: [CharPos[10], line1], switch: @data.list, z:heap];    items[FormItems.checkVirgin.ORD] ¬ BooleanItem[tag: "Blank Check"L,       place: [CharPos[19], line1], drawBox: TRUE, switch: @data.checkVirgin, z:heap];    items[FormItems.verify.ORD] ¬ CommandItem[tag: "Verify"L,       place: [CharPos[35], line1], proc: Verify, z:heap];    items[FormItems.read.ORD] ¬ CommandItem[tag: "Read"L,       place: [CharPos[48], line1], proc: Read, z:heap];    items[FormItems.catalog.ORD] ¬ CommandItem[tag: "Catalog"L,       place: [CharPos[57], line1], proc: Catalog, z:heap];    items[FormItems.field.ORD] ¬ EnumeratedItem[tag: "Field"L,       place: [CharPos[0], line3], choices: DESCRIPTOR[field], value: @data.field, z:heap];    items[FormItems.slices.ORD] ¬ NumberItem[tag: "slices"L,       place: [CharPos[24], line3], signed: FALSE, notNegative: TRUE, value: @data.slices, z:heap];    items[FormItems.start.ORD] ¬ StringItem[tag: "start"L,       place: [CharPos[43], line3], inHeap: TRUE, string: @data.start, z:heap];    items[FormItems.end.ORD] ¬ StringItem[tag: "end"L,       place: [CharPos[63], line3], readOnly: TRUE, inHeap: TRUE, string: @data.end, z:heap];    items[FormItems.chip.ORD] ¬ StringItem[tag: "Chip"L,       place: [CharPos[0], line4], inHeap: TRUE, string: @data.chip, z:heap];    items[FormItems.memSize.ORD] ¬ NumberItem[tag: "memSize"L,       place: [CharPos[0], line5], signed: FALSE, notNegative: TRUE, value: @data.memSize, z:heap];    items[FormItems.width.ORD] ¬ NumberItem[tag: "Width"L,       place: [CharPos[21], line5], signed: FALSE, notNegative: TRUE, value: @data.width, z:heap];    items[FormItems.virgin.ORD] ¬ EnumeratedItem[tag: "Virgin"L,       place: [CharPos[40], line5], choices: DESCRIPTOR[virgin], value: @data.virgin, z:heap];    items[FormItems.writeTime.ORD] ¬ NumberItem[tag: "writeTime"L,       place: [CharPos[59], line5], signed: FALSE, notNegative: TRUE, value: @data.writeTime, z:heap];    items[FormItems.pMCode.ORD] ¬ NumberItem[tag: "PMCode"L,       place: [CharPos[0], line6], signed: FALSE, notNegative: TRUE, value: @data.pMCode, z:heap];    items[FormItems.debug.ORD] ¬ BooleanItem[tag: "debug"L,       place: [CharPos[20], line6], proc: SetDebug, switch: @data.debug, z:heap];    items[FormItems.confirm.ORD] ¬ CommandItem[tag: "Confirm"L,       place: [CharPos[0], LineN[8]], proc: Confirm, z:heap];    items[FormItems.deny.ORD] ¬ CommandItem[tag: "Deny"L,       place: [CharPos[22], LineN[8]], proc: Deny, z:heap];    items[FormItems.percent.ORD] ¬ NumberItem[tag: "% Complete"L,       place: [CharPos[40], LineN[8]], signed: FALSE, notNegative: TRUE, value: @data.percent, readOnly: TRUE, invisible: TRUE, z:heap];    items[FormItems.time.ORD] ¬ StringItem[tag: "Started at"L,       place: [CharPos[40], LineN[7]], readOnly: TRUE, invisible: TRUE, inHeap: TRUE, string: @data.time, z:heap];    RETURN[items: items, freeDesc: TRUE];  };  MakeSWs: Tool.MakeSWsProc = {    logName: STRING ¬ [40];    addresses: ARRAY [0..3) OF ToolDriver.Address;    Tool.UnusedLogName[unused: logName, root: "PromBlow.log"L];    data.msgSW ¬ Tool.MakeMsgSW[window: window, lines: 2];    data.formSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeForm, zone: heap];    UserInput.SetAttention[data.formSW,Abort];    data.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    UserInput.SetAttention[data.fileSW,Abort];    RS232CProlog.InitLogHandle[data.fileSW];-- do the ToolDriver stuff    addresses ¬ [      [name: "msgSW"L, sw: data.msgSW], [      name: "formSW"L, sw: data.formSW], [      name: "fileSW"L, sw: data.fileSW]];    ToolDriver.NoteSWs[      tool: "Prom Programmer Tool"L, subwindows: DESCRIPTOR[addresses]]  };      Abort: UserInput.AttentionProcType = {    StopOurselves;    Complain["Transmission aborted."L];    RS232CProlog.GiveItUp;  };    StopOurselves: ENTRY PROC = {    abort ¬ TRUE;    didConfirm ¬ FALSE;    waitForAction ¬ FALSE;    BROADCAST answer;    BROADCAST updatePercent;  };      -- Mainline code  Init[]; }...
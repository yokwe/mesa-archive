-- File: Bindweed.mesa - last edit:-- FXB   .PA           15-Apr-85 13:02:55-- Copyright (C) 1984 , 1985, 1985, 1985 by Xerox Corporation. All rights reserved. ---- Bindweed.mesa-- FXB   ,  7-Feb-85 14:09:18DIRECTORY  Environment USING [Byte],  I186 USING [IOPort],  OMF USING [DataSequence];Bindweed: DEFINITIONS =  {  -- E R R O R s  Error: ERROR [code: ErrorCode];    ErrorCode: TYPE = {timeout, badCheckSum, umbilicalNotWorking};  -- T Y P E s  Address: TYPE = LONG UNSPECIFIED;  AddressType: TYPE = {iOPLogical, pCLogical, real, virtual};  Block: TYPE = PACKED ARRAY INTEGER [0..256) OF Environment.Byte;  Byte: TYPE = Environment.Byte;  Medium: TYPE = {umbilicalNMI, umbilical, rS232C, ethernet};  Sequence: TYPE = OMF.DataSequence;  NotifyProc: TYPE = PROC [clientData: LONG POINTER];  maxData: Byte = 245;  -- 255 - 10 bytes for protocol overhead    hbWords: CARDINAL = 120; -- size of buffer for reading the history buffer  Bits4: TYPE = [0..16);  Bits5: TYPE = [0..32);  BitsC: TYPE = [0..4096);  wordsPerBank: CARDINAL = 4096;  numberOfBanks: CARDINAL = 4;  sizeOfCS: CARDINAL = numberOfBanks * wordsPerBank;  bytesPerMi: CARDINAL = 6;  bufferSize: CARDINAL = maxMIs * bytesPerMi;  ShiftReg: TYPE = MACHINE DEPENDENT RECORD [    BS(0:0..3): Bits4,    INIA(0:4..15): BitsC,    BSHold(1:0..3): Bits4,    INIAHold(1:4..15): BitsC,    anotherBlank(2:0..4): Bits5,    EOPTrap(2:5..5): BOOLEAN,    ExInt(2:6..6): BOOLEAN,    CSParity(2:7..7): BOOLEAN,    blank(2:8..15): Byte];  maxMIs: CARDINAL = 41;  -- P R O C E D U R E s  AddNotify: PROC [    notify: NotifyProc, index: [0..16), clientData: LONG POINTER ¬ NIL];  Allocate: PROC [count: CARDINAL] RETURNS [offset: CARDINAL];  --offset is relative to the base of the local RAM on the 80186  Boot: PROC;  -- this can only be done over the umbilical  ChangeMedium: PROC [newMedium: Medium];  Continue: PROC;  Free: PROC [offset, count: CARDINAL];  Get: PROC [block: Block, length: Byte];  AllocateNotifyBit: PROC RETURNS [mask: WORD, bitIndex: [0..16)];  Jump: PROC [address: Address, addressType: AddressType];  DownNotify: PROC [mask: WORD];  Put: PROC [block: Block, length: Byte];  ReadCPControlStore: PROC [csAddress: [0..sizeOfCS)]    RETURNS [mi: PACKED ARRAY [0..bytesPerMi) OF Environment.Byte];      ReadHistoryBuffer: PROC [    hbData: LONG POINTER TO ARRAY [0..hbWords) OF WORD];  ReadIOByte: PROC [port: I186.IOPort] RETURNS [data: Byte];  ReadIOWord: PROC [port: I186.IOPort] RETURNS [data: WORD];  ReadMemoryBlock: PROC [    address: Address, addressType: AddressType,    sequence: LONG POINTER TO Sequence];  RemoveNotify: PROC [index: [0..16), notify: NotifyProc];    ResetCP: PROC;  StartCP: PROC [shiftRegister: PACKED ARRAY [0..bytesPerMi) OF Byte];  StopIOP: PROC;    StopPC: PROC;  StopCP: PROC    RETURNS [shiftRegister: PACKED ARRAY [0..bytesPerMi) OF Byte];      TurnOnWatcher: PROC;  -- poll the umbilical for up notifies    TurnOffWatcher: PROC;  -- stop polling the umbilical for up notifies  WriteCPControlStore: PROC [    csAddress: [0..sizeOfCS), csWords: [0..maxMIs),    csData: PACKED ARRAY [0..bufferSize) OF Environment.Byte];  WriteIOByte: PROC [port: I186.IOPort, data: Byte];  WriteIOWord: PROC [port: I186.IOPort, data: WORD];  WriteMemoryBlock: PROC [    address: Address, addressType: AddressType,    sequence: LONG POINTER TO Sequence];      WriteMemoryBits: PROC [    address: Address, addressType: AddressType,    sequence: LONG POINTER TO Sequence];  }.
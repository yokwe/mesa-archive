-- File: CommandFileImplA.mesa - last edit:-- FXB   .PA            8-May-85 16:23:48-- Copyright (C) 1984, 1985 by Xerox Corporation. All rights reserved. -- CommandFileImplA.mesa,-- AYC   ,  9-Aug-84 14:00:06-- FXB     11-Oct-84 15:03:13-- AYC   ,  3-Jan-85 18:39:59	debug CP commands/change (x,y) to [x,y]-- DEG     , 27-Jan-85 10:25:57	make compatible with pre-11.1 arrows-- FXB   .pa 21-Mar-85 17:41:31-- from CommandFiler.mesa,  HGM, 13-Feb-84 19:33:09--DIRECTORY  Ascii USING [NUL],  Format USING [Date, Line, LongDecimal, StringProc, Text],  Heap USING [Create, Delete, systemZone],  IOPB,  MStream USING [Error, ReadOnly],  Process USING [SecondsToTicks, SetTimeout, Yield],  Stream USING [Delete, EndOfStream, GetChar, GetPosition, Handle, Position],  String USING [    AppendExtensionIfNeeded, AppendString, AppendChar, AppendNumber,    AppendSubString, CopyToNewString, Equal, StringBoundsFault, SubString,    SubStringDescriptor],  System USING [    GetClockPulses, GetGreenwichMeanTime, Pulses, PulsesToMicroseconds],  CommandFile USING [AbortProc],  CommandFileOps,  CPCommand USING [Error],  StringExtras USING [    BlankCharacter, CheckHexString, InvalidHexString, NextToken],  SymbolHash USING [    Destroy, GetInfo, GetString, Handle, Hash, Insert, Lookup, nullHash, PutInfo];CommandFileImplA: MONITOR  IMPORTS    Format, Heap, MStream, StringExtras, Process, Stream, String, System,    CommandFileOps, CPCommand, IOPB, SymbolHash  EXPORTS CommandFile, CommandFileOps =  {  z: UNCOUNTED ZONE = Heap.systemZone;  cd: PUBLIC CommandFileOps.DataHandle;  heap: PUBLIC UNCOUNTED ZONE ¬ NIL;  Error: PUBLIC ERROR [reason: LONG STRING, position: Stream.Position] = CODE;  Trouble: PUBLIC ERROR [message: LONG STRING] = CODE;  running: BOOLEAN ¬ FALSE;  waitTillDone: CONDITION;  SomebodyRunning: PUBLIC ENTRY PROCEDURE RETURNS [BOOLEAN] = {RETURN[running]; };  StartRunning: ENTRY PROCEDURE [abort: CommandFile.AbortProc] = {    WHILE running DO      IF abort[] THEN ERROR Trouble["UserAborted"L ! UNWIND => NULL];      WAIT waitTillDone;      ENDLOOP;    running ¬ TRUE;    };  StopRunning: ENTRY PROCEDURE = {running ¬ FALSE; NOTIFY waitTillDone; };  CommandsFromFile: PUBLIC PROCEDURE [    log: Format.StringProc, arg: LONG POINTER, abort: CommandFile.AbortProc,    file: LONG STRING] = {    start, stop: System.Pulses;    ms: LONG CARDINAL;    stream: Stream.Handle;    filename: LONG STRING;    start ¬ System.GetClockPulses[];    filename ¬ String.CopyToNewString[file, z];    [] ¬ String.AppendExtensionIfNeeded[@filename, "bermuda"L, z];    Format.Date[log, System.GetGreenwichMeanTime[], dateTime, ANSI, arg];    Format.Text[log, "  Running commands from "L, arg];    Format.Text[log, filename, arg];    Format.Line[log, "."L, arg];    stream ¬ MStream.ReadOnly[      filename, [] ! MStream.Error => ERROR Error["Can't open input file"L, 0]];    CommandsFromStream[      log, arg, abort, stream !      UNWIND => {Stream.Delete[stream]; z.FREE[@filename]; }];    Stream.Delete[stream];    stop ¬ System.GetClockPulses[];    ms ¬ System.PulsesToMicroseconds[[stop - start]] / 1000;    Format.Text[log, "It took "L, arg];    Format.LongDecimal[log, ms, arg];    Format.Text[log, " ms to run "L, arg];    Format.Text[log, filename, arg];    Format.Line[log, "."L, arg];    z.FREE[@filename];    };  CommandsFromStream: PUBLIC PROCEDURE [    log: Format.StringProc, arg: LONG POINTER, abort: CommandFile.AbortProc,    stream: Stream.Handle] = {    ENABLE UNWIND => {ReleaseStructures[]; StopRunning[]};    cd ¬ NIL;    StartRunning[abort];    heap ¬ Heap.Create[initial: 10];    CommandFileOps.CreateStructures[];    cd.log ¬ log;    cd.arg ¬ arg;    cd.abort ¬ abort;    cd.stream ¬ stream;    CommandLoop[];    ReleaseStructures[];    StopRunning[];    };  InitBreaks: PUBLIC PROCEDURE = {    OPEN CommandFileOps;    cd.breaks ¬ heap.NEW[BreakArray];    cd.breaks­ ¬ [      colon: [':, DoColon], semi: [';, DoSemi], shriek: ['!, DoShriek],      arrow: ['¬, DoBack], oldArrow: ['_, DoBack],      quote: ['", DoQuote], less: ['<, DoLess],      --all relationals are bracketed by < and {      equal: ['=, DoEqual],  --see definition of RelationDomain below      notEqual: ['#, DoNotEqual], greater: ['>, DoGreater],      openBrace: ['{, DoOpenBrace], openBracket: ['[, DoOpenBracket],      closeBracket: ['], DoCloseBracket], closeBrace: ['}, DoCloseBrace],      comment: ['|, DoComment]];    };  symbolSize: CARDINAL = SIZE[CommandFileOps.SymbolValue];  CommandLoop: PROCEDURE = {    str: LONG STRING = [100];    {    ENABLE {      Trouble => ERROR Error[message, Stream.GetPosition[cd.stream]];      Stream.EndOfStream =>        IF cd.stack = NIL THEN CONTINUE        ELSE          ERROR Error["Unexpected end of file"L, Stream.GetPosition[cd.stream]];      CPCommand.Error => {ERROR Error[reason, Stream.GetPosition[cd.stream]]; };--    HBCommand.Error => { ERROR Error[reason, Stream.GetPosition[cd.stream]]; };      IOPB.Error => {        IOPB.AppendError[code: code, errS: s, s: str];        ERROR Error[str, Stream.GetPosition[cd.stream]]};      };    UNTIL cd.stopCommands DO      ReadPhrase[];      cd.breaks[cd.lastBreak].r;      Process.Yield[];      IF cd.abort[] THEN ERROR Trouble["UserAborted"L];      ENDLOOP;    }};  ReadPhrase: PUBLIC PROCEDURE = {    c: CHARACTER;    cd.in.length ¬ 0;    UNTIL GotBreak[c ¬ Read[]] --sets lastBreak-- DO      String.AppendChar[        s: cd.in, c: c !        String.StringBoundsFault => {          ns ¬ heap.NEW[StringBody [s.length * 2]];          String.AppendString[to: ns, from: s];          heap.FREE[@s];          cd.in ¬ ns;          RESUME          }]      ENDLOOP;    cd.token­ ¬ [cd.in, 0, 0];    cd.rest­ ¬ [cd.in, 0, cd.in.length];    };  ReleaseStructures: PROCEDURE = {    IF cd # NIL THEN {      cd.stopCommands ¬ TRUE;      IF cd.output # NIL THEN Stream.Delete[cd.output];      SymbolHash.Destroy[cd.symbols]};    IF heap # NIL THEN Heap.Delete[heap];    heap ¬ NIL;    };  --action routines--  DoQuote: PUBLIC PROCEDURE = {    c: CHARACTER;    cd.sc.length ¬ 0;    IF (c ¬ Read[]) = '" THEN RETURN;    cd.limbo ¬ c;    DO      {      ENABLE        String.StringBoundsFault => {          ns ¬ heap.NEW[StringBody [s.length * 2]];          String.AppendString[to: ns, from: s];          heap.FREE[@s];          cd.sc ¬ ns;          RESUME          };      IF (c ¬ Read[]) # '" THEN {String.AppendChar[s: cd.sc, c: c]; LOOP};      IF (c ¬ Read[]) = '" THEN {String.AppendChar[s: cd.sc, c: c]; LOOP};      cd.limbo ¬ c;      RETURN}      ENDLOOP};  DoComment: PROCEDURE = {    DO      ReadPhrase[];      SELECT cd.lastBreak FROM quote => DoQuote[]; comment => EXIT; ENDCASE;      ENDLOOP;    };  DoColon: PROCEDURE = {    h: SymbolHash.Hash;    here: Stream.Position = Stream.GetPosition[cd.stream];    sv: LONG POINTER TO CommandFileOps.SymbolValue;    id: LONG STRING;    IF ~NextID[] THEN ERROR Trouble["Illegal or Null Tag"L];    id ¬ StringFromSubString[cd.token];    {    ENABLE UNWIND => heap.FREE[@id];    h ¬ SymbolHash.Lookup[cd.symbols, id];    IF h # SymbolHash.nullHash THEN {      sv ¬ SymbolHash.GetInfo[cd.symbols, h];      WITH sv SELECT FROM        Tag => IF si # here THEN MultiplyDefined[] ELSE RETURN;        ENDCASE => MultiplyDefined[];      };    h ¬ SymbolHash.Insert[cd.symbols, id];    sv ¬ heap.NEW[CommandFileOps.SymbolValue ¬ [Tag[here]]];    SymbolHash.PutInfo[cd.symbols, h, sv]};    heap.FREE[@id];    };  DoEqual: PROCEDURE = {    h: SymbolHash.Hash;    sv: LONG POINTER TO CommandFileOps.SymbolValue;    xNew, yNew: CARDINAL;    panelNew: CommandFileOps.Panel;    IF DidCondition[] --does a NextID-- THEN RETURN;    PushSubString[cd.token];    [] ¬ NextID[];    IF cd.token.length # 0 THEN ERROR Trouble["Garbage before equal"L];    ReadPhrase[];    IF cd.lastBreak # openBracket THEN {      Push[Break, NIL, CommandFileOps.BreakDomain[equal]];      cd.breaks[cd.lastBreak].r;      RETURN;      };    DoOpenBracket[];    SELECT cd.stack.type FROM      Loc => {        panelNew ¬ LOOPHOLE[cd.stack.p, LONG POINTER TO Loc          CommandFileOps.SymbolValue].panel;        xNew ¬ LOOPHOLE[cd.stack.p, LONG POINTER TO Loc          CommandFileOps.SymbolValue].x;        yNew ¬ LOOPHOLE[cd.stack.p, LONG POINTER TO Loc          CommandFileOps.SymbolValue].y};      ENDCASE => ERROR Trouble["Loc must follow equal here"L];    RetireTop[];  --loc--    h ¬ SymbolHash.Lookup[cd.symbols, cd.stack.p];    IF h # SymbolHash.nullHash THEN {      sv ¬ SymbolHash.GetInfo[cd.symbols, h];      WITH sv SELECT FROM        Loc =>          IF x # xNew OR y # yNew OR panel # panelNew THEN            ERROR Trouble["Symbol assigned to different loc"L];        ENDCASE => ERROR Trouble["Symbol already defined not loc"L]}    ELSE {      h ¬ SymbolHash.Insert[cd.symbols, cd.stack.p];      sv ¬ heap.NEW[CommandFileOps.SymbolValue ¬ [Loc[panelNew, xNew, yNew]]];      SymbolHash.PutInfo[cd.symbols, h, sv]};    RetireTop[];  --string--    Push[Loc, sv, 0]};  DoSemi: PROCEDURE = {    Legal: TYPE = {semiI, arrowI, shriekI, equalI};    last: Legal ¬ LAST[Legal];    i, item: Legal ¬ FIRST[Legal];    Template: ARRAY Legal OF RECORD [      b: CommandFileOps.BreakDomain,      s: LONG POINTER TO CommandFileOps.StackCell] ¬ [      [semi, NIL], [arrow, NIL], [shriek, NIL], [equal, NIL]];    bit: WORD ¬ 1;    value: CARDINAL ¬ 0;    define, loc, phrase, val: LONG STRING ¬ NIL;    error: BOOLEAN ¬ FALSE;    [] ¬ NextID[];    IF cd.token.length # 0 THEN PushString[s: cd.in];    IF cd.stack = NIL THEN RETURN;    UNTIL cd.stack = NIL DO      IF error THEN {RetireTop[]; LOOP};      SELECT cd.stack.type FROM Tag, Null, Break => {error ¬ TRUE; LOOP}; ENDCASE;      IF Template[item].s # NIL THEN {error ¬ TRUE; LOOP};      Template[item].s ¬ Pop[];      IF cd.stack = NIL THEN EXIT;      IF cd.stack.type # Break THEN {error ¬ TRUE; LOOP};      FOR i IN (item..last] DO        IF LOOPHOLE[cd.stack.v, CommandFileOps.BreakDomain] = Template[i].b THEN          EXIT        REPEAT FINISHED => error ¬ TRUE        ENDLOOP;      item ¬ i;      RetireTop[]      ENDLOOP;    FOR i IN [arrowI..equalI] DO      IF Template[i].s # NIL THEN value ¬ value + bit; bit ¬ bit + bit ENDLOOP;    {    a: LONG POINTER TO CommandFileOps.StackCell = Template[equalI].s;    x: LONG POINTER TO CommandFileOps.StackCell = Template[semiI].s;    y: LONG POINTER TO CommandFileOps.StackCell = Template[arrowI].s;    z: LONG POINTER TO CommandFileOps.StackCell = Template[shriekI].s;    SELECT value FROM      1 => --      y¬ x;-- CommandFileOps.Assign[y, x];      2 => --   z!    x;-- CommandFileOps.DisplayContents[z, x];      3 => --   z! y¬ x;-- {        CommandFileOps.DisplayContents[z, y]; CommandFileOps.WriteContents[z, x]};      4 => --a=       x;-- Equivalence[a, x];      5 => --a=    y¬ x;-- ERROR Trouble["Can't interpret statement"L];      6 => --a= z!    x;-- {        Equivalence[a, z]; CommandFileOps.DisplayContents[z, x]; };      7 =>  --a= z! y¬ x;--        {        Equivalence[a, z];        CommandFileOps.DisplayContents[z, y];        CommandFileOps.WriteContents[z, x]};      ENDCASE => ERROR Trouble["Illegal statement"L]};    FOR i IN Legal DO FreeStackCell[Template[i].s] ENDLOOP;    IF error THEN ERROR Trouble["Can't interpret statement"L];    };  DoShriek: PROCEDURE = {    sv: LONG POINTER TO CommandFileOps.SymbolValue;    idFlag: BOOLEAN ¬ NextID[];    IF (cd.stack # NIL) AND (cd.stack.type = Loc) THEN {      IF cd.token.length # 0 THEN ERROR Trouble["Extra garbage before shriek"L]}    ELSE {      old: BOOLEAN;      IF ~idFlag THEN ERROR Trouble["Can't parse shriek"L];      [old, , sv] ¬ LookupSubString[cd.token, FALSE];      IF ~old OR sv.type # Loc THEN MustBeLocation[];      Push[Loc, sv, 0]};    Push[Break, NIL, CommandFileOps.BreakDomain[shriek]]};  DoOpenBracket: PROCEDURE = {    sv: LONG POINTER TO CommandFileOps.SymbolValue;    h: SymbolHash.Hash;    s: LONG STRING;    panelName: LONG STRING;    old: BOOLEAN;    xNew, yNew: CARDINAL;    p: LONG POINTER TO CommandFileOps.StackCell;    AppendDigits: PROCEDURE [s: LONG STRING, v, n: CARDINAL] = {      t: LONG STRING ¬ [6];      String.AppendNumber[t, v, 16];      THROUGH [t.length..n - 1] DO String.AppendChar[s, '0] ENDLOOP;      String.AppendString[s, t]};    IF ~NextID[] THEN ERROR Trouble["Garbage before open bracket"L];    [old, h, sv] ¬ LookupSubString[cd.token, FALSE];    IF ~old THEN ERROR Trouble["Unknown ID before open bracket"L];    WITH sv SELECT FROM      Function => {p ¬ cd.stack; apply[]; ClearStack[p]};      Loc => {        panel: CommandFileOps.Panel;        panelName ¬ SymbolHash.GetString[cd.symbols, h];        [xNew, yNew] ¬ GetXY[];        IF          ~(SELECT panel ¬ PanelFromName[panelName] FROM              CP => CommandFileOps.VisibleTile[cd.cpHandle, xNew, yNew],              IOP => CommandFileOps.VisibleTile[cd.iopPanel, xNew, yNew],	      PC => CommandFileOps.VisibleTile[cd.pcPanel, xNew, yNew],              ENDCASE => ERROR) THEN ERROR Trouble["Illegal location"L];        --create symbol of form {panelName}xxxyyy--        String.AppendString[          to: s ¬ heap.NEW[StringBody [panelName.length + 6]], from: panelName];        AppendDigits[s, xNew, 3];        AppendDigits[s, yNew, 3];        h ¬ SymbolHash.Lookup[cd.symbols, s];        IF h # SymbolHash.nullHash THEN  --previously used--          sv ¬ SymbolHash.GetInfo[cd.symbols, h]        ELSE {          h ¬ SymbolHash.Insert[cd.symbols, s];          sv ¬ heap.NEW[CommandFileOps.SymbolValue ¬ [Loc[panel, xNew, yNew]]];          SymbolHash.PutInfo[cd.symbols, h, sv]};        Push[Loc, sv, 0]};      ENDCASE => ERROR Trouble["Illegal Type"L]};  DoBack: PROCEDURE = {    [] ¬ NextID[];    IF cd.token.length # 0 THEN PushString[s: cd.in];    Push[Break, NIL, CommandFileOps.BreakDomain[arrow]]};  DoLess: PROCEDURE = {IF ~DidCondition[] THEN WhereIsTheIF[]; };  DoGreater: PROCEDURE = {IF ~DidCondition[] THEN WhereIsTheIF[]; };  DoNotEqual: PROCEDURE = {IF ~DidCondition[] THEN WhereIsTheIF[]; };  DoCloseBracket: PROCEDURE = {ERROR Trouble["Dangling close bracket"L]};  DoOpenBrace: PROCEDURE = {ERROR Trouble["Dangling open brace"L]};  DoCloseBrace: PROCEDURE = {    IF (cd.braces ¬ cd.braces - 1) < 0 THEN      ERROR Trouble["Dangling close brace"L];    DoSemi};  DidCondition: PROCEDURE RETURNS [BOOLEAN] = {    h: SymbolHash.Hash;    old: BOOLEAN;    cc1, cc2: CommandFileOps.BreakDomain ¬ cd.lastBreak;    v1, v2: LONG INTEGER;    r: CommandFileOps.Relation;    [] ¬ NextID[];    IF cd.token.length = 0 THEN GarbagedConditional;    [old, h, ] ¬ LookupSubString[cd.token, FALSE];    IF ~old OR ~String.Equal["IF"L, SymbolHash.GetString[cd.symbols, h]] THEN      RETURN[FALSE];    v1 ¬ CommandFileOps.EvaluateLoc[];    ReadPhrase[];    cc2 ¬ cd.lastBreak;    IF cd.lastBreak IN CommandFileOps.RelationDomain THEN {      IF cd.lastBreak # openBrace THEN {  --compound relation--        [] ¬ NextID[];        IF cd.token.length # 0 OR cd.rest.length # 0 THEN GarbagedConditional;        ReadPhrase[];        IF cd.lastBreak # openBrace THEN GarbagedConditional}}    ELSE GarbagedConditional;    IF (r ¬ cd.relations[cc1][cc2]) = x THEN GarbagedConditional;    v2 ¬ CommandFileOps.EvaluateLoc[];    IF      ~(SELECT r FROM          gt => v1 > v2,          eq => v1 = v2,          ne => v1 # v2,          lt => v1 < v2,          le => v1 <= v2,          ge => v1 >= v2,          ENDCASE => ERROR) THEN {  --skip over stuff until matching closeBrace--      v1 ¬ 1;  --brace level--      WHILE v1 > 0 DO        ReadPhrase[];        SELECT cd.lastBreak FROM          openBrace => v1 ¬ v1 + 1;          closeBrace => v1 ¬ v1 - 1;          quote => cd.breaks[quote].r;          ENDCASE        ENDLOOP;      RETURN[TRUE]};    cd.braces ¬ cd.braces + 1;    RETURN[TRUE]};  GetXY: PROCEDURE RETURNS [x, y: CARDINAL] = {    IllegalLoc: PROCEDURE = {ERROR Trouble["Illegal location"L]};    IF CommandFileOps.GetParameters[] # 2 THEN IllegalLoc[];    y ¬ StringExtras.CheckHexString[      cd.stack.p ! StringExtras.InvalidHexString => IllegalLoc[]];    RetireTop[];    x ¬ StringExtras.CheckHexString[      cd.stack.p ! StringExtras.InvalidHexString => IllegalLoc[]];    RetireTop[];    };  Read: PROCEDURE RETURNS [CHARACTER] = {    c: CHARACTER;    IF (c ¬ cd.limbo) = Ascii.NUL THEN RETURN[Stream.GetChar[cd.stream]];    cd.limbo ¬ Ascii.NUL;    RETURN[c]};  NextID: PUBLIC PROCEDURE RETURNS [BOOLEAN] = {    break, tail: String.SubStringDescriptor;    StringExtras.NextToken[cd.rest, cd.token, IDBreaks];    IF cd.token.length > 0      AND StringExtras.BlankCharacter[cd.token.base[cd.token.offset]] THEN      --skip leading spaces--      StringExtras.NextToken[cd.rest, cd.token, IDBreaks];    IF cd.rest.length # 0 THEN {  --eat trailing spaces--      tail ¬ cd.rest­;      StringExtras.NextToken[@tail, @break, IDBreaks];      IF ~StringExtras.BlankCharacter[break.base[break.offset]] THEN        RETURN[FALSE];      cd.rest­ ¬ tail};    RETURN[cd.token.length # 0 AND cd.rest.length = 0];    };  GotBreak: PROCEDURE [c: CHARACTER] RETURNS [BOOLEAN] = {    i: CommandFileOps.BreakDomain;    FOR i IN CommandFileOps.BreakDomain DO      IF cd.breaks[i].c = c THEN {cd.lastBreak ¬ i; RETURN[TRUE]} ENDLOOP;    RETURN[FALSE]};  StringFromSubString: PUBLIC PROCEDURE [ss: String.SubString] RETURNS [s: LONG STRING] =    {s ¬ heap.NEW[StringBody [ss.length]]; String.AppendSubString[s, ss]};  LookupSubString: PUBLIC PROCEDURE [ss: String.SubString, insert: BOOLEAN]    RETURNS [      old: BOOLEAN, h: SymbolHash.Hash,      sv: LONG POINTER TO CommandFileOps.SymbolValue] = {    s: LONG STRING ¬ heap.NEW[StringBody [ss.length]];    String.AppendSubString[s, ss];    h ¬ SymbolHash.Lookup[cd.symbols, s];    old ¬ h # SymbolHash.nullHash;    IF ~old AND insert THEN h ¬ SymbolHash.Insert[cd.symbols, s];    heap.FREE[@s];    IF ~old THEN {sv ¬ NIL; RETURN};    sv ¬ SymbolHash.GetInfo[cd.symbols, h]};  Push: PROCEDURE [    type: CommandFileOps.Type, p: LONG POINTER, value: UNSPECIFIED] = {    cell: LONG POINTER TO CommandFileOps.StackCell ¬ heap.NEW[      CommandFileOps.StackCell ¬ [type, p, value, cd.stack]];    cd.stack ¬ cell};  PushString: PUBLIC PROCEDURE [s: LONG STRING] = {    c: LONG STRING ¬ heap.NEW[StringBody [s.length]];    String.AppendString[to: c, from: s];    Push[StringConstant, c, 0]};  PushSubString: PROCEDURE [ss: String.SubString] = {    s: LONG STRING ¬ heap.NEW[StringBody [ss.length]];    String.AppendSubString[to: s, from: ss];    Push[StringConstant, s, 0]};  Pop: PUBLIC PROCEDURE RETURNS [p: LONG POINTER TO CommandFileOps.StackCell] = {    IF (p ¬ cd.stack) # NIL THEN cd.stack ¬ p.previous};  FreeStackCell: PUBLIC PROCEDURE [p: LONG POINTER TO CommandFileOps.StackCell] = {    IF p = NIL THEN RETURN;    SELECT p.type FROM      StringConstant => IF p.p # NIL THEN heap.FREE[@p­.p];      ENDCASE;    heap.FREE[@p];    };  RetireTop: PUBLIC PROCEDURE = {FreeStackCell[Pop[]]};  ClearStack: PROCEDURE [p: LONG POINTER TO CommandFileOps.StackCell] = {    UNTIL cd.stack = p DO RetireTop[]; ENDLOOP};  Equivalence: PROCEDURE [    target, value: LONG POINTER TO CommandFileOps.StackCell] = {    old: BOOLEAN;    h: SymbolHash.Hash;    sv: LONG POINTER TO CommandFileOps.SymbolValue;    loc: LONG POINTER TO Loc CommandFileOps.SymbolValue = value.p;    stoken: String.SubString = cd.token;    srest: String.SubString = cd.rest;    td: String.SubStringDescriptor ¬ [target.p, 0, 0];    rd: String.SubStringDescriptor ¬ [      target.p, 0, LOOPHOLE[target.p, LONG STRING].length];    IF value.type # Loc THEN ERROR Trouble["Loc must follow equals"L];    cd.token ¬ @td;    cd.rest ¬ @rd;    IF ~NextID[] THEN ERROR Trouble["ID must preceed equal"L];    [old, h, sv] ¬ LookupSubString[cd.token, TRUE];    IF old THEN      WITH sv SELECT FROM        Loc => IF ~(loc.x = x AND loc.y = y) THEN MultiplyDefined[];        ENDCASE => ERROR Trouble["Loc must preceed equal"L]    ELSE {      sv ¬ heap.NEW[CommandFileOps.SymbolValue ¬ [Loc[loc.panel, loc.x, loc.y]]];      SymbolHash.PutInfo[cd.symbols, h, sv]};    cd.token ¬ stoken;    cd.rest ¬ srest;    };  IDBreaks: PUBLIC PROCEDURE [c: CHARACTER] RETURNS [BOOLEAN] = {    SELECT c FROM      IN ['0..'9], IN ['A..'Z], IN ['a..'z], '@, '. => RETURN[FALSE];      ENDCASE => RETURN[TRUE];    };  PanelFromName: PUBLIC PROCEDURE [panelName: LONG STRING]    RETURNS [CommandFileOps.Panel] = {    SELECT TRUE FROM      String.Equal[panelName, "CP"L] => RETURN[CP];      String.Equal[panelName, "IOP"L] => RETURN[IOP];      String.Equal[panelName, "PC"L] => RETURN[PC];      ENDCASE => ERROR;    };  GarbagedConditional: PUBLIC PROCEDURE = {ERROR Trouble["Garbaged conditional"L]; };  MultiplyDefined: PROCEDURE = {ERROR Trouble["Multiply defined symbol"L]; };  MustBeLocation: PUBLIC PROCEDURE = {ERROR Trouble["Must be location"L]; };  WhereIsTheIF: PROCEDURE = {ERROR Trouble["Where is the IF?"L]; };  Process.SetTimeout[@waitTillDone, Process.SecondsToTicks[1]];  }.
-- PF.mesa - edited by:--  Poskanzer	27-Feb-85 16:54:50--  DSC  	26-Feb-85 16:48:11-- Copyright (C) 1985 by Versatec, Inc.  All rights reserved.DIRECTORY  Atom USING [ATOM],  Environment USING [Block],  Format USING [StringProc],  Stream USING [Handle],  Time USING [Current, Packed],  Window USING [Handle];PF: DEFINITIONS IMPORTS Time =  BEGIN<< PF is a collection of convenient output-formatting routines.  It is similar to Unix* printf(), FORTRAN format statements, and BASIC PRINT statements.  It is \very/ similar to the Cedar IO.PutF routines.All the PF routines take a format string (a string containing text and conversion specifications) and zero or more values.  For each value, the format string must contain a special escape sequence which matches the type of the value.  The escape sequences are:  seq	description			types matched  ---	-----------			-------------  %g	general				all types  %h	visible control chars		str, atom, char, block  %q	Mesa string literal		ditto  %d	decimal				char, card, int, real(rounded), bool(1|0)  %o	octal				ditto  %x	hexidecimal			ditto  %b	binary				ditto  %r	time interval hh:mm:ss		card, int, real(rounded)  %e	exponential notation		real  %f	fixed-point notation		real  %%	does not format a value, just puts out the character %PF replaces each conversion specification in the format with a printed representation of the coresponding Mesa value.  The printed representation chosen for the value is a function of the conversion specification - it may specify alternate styles of conversion, field width, left-justification within the field, etc.  The most commonly used specification by far is %g.  Passing a format of NIL is equivalent to supplying "%g%g%g...", with the number of %g's equal to the number of non-null values passed in.Between the % and the character, you can have a format control string as described by the regular expression (0|-)?nnn(.mmm)?  That is, an optional zero (indicating right-justification with zero fill) or - (indicating left-justification);  a field width; and an optional period and number specifying the significant digits for reals.The %h specification takes non-printing characters ([000C..037C], [177C..377C]) and prints them as a visible sequence.  For example, CR is printed as ­M, DEL as ^?, 200C as \200.%q prints the Mesa literal representation of the string, i.e. the form that would be coded in a program to produce the string.  For instance the character CR in the string is printed as \n, and a double quote in the string prints as \". It does not print the "s surrounding the string, but these can be included in the format string if desired. For instance, PF.PutF["%q"L, str["abc\ndef"L]] = "abc\ndef", while PF.PutF["%g"L,  str["abc\ndf"L]] = "abcdef".Special note for Unix*ites: the baskslash character ('\) has NO special significance within the format - backslash sequences are converted by the Mesa compiler.Some examples:  PF.PutF2[stdout, "The time is %g.\n"L, [time[Time.Current[]]]];  PF.PutF2[stdout, "Routing is %g%% complete after %r.\n"L,    [card[pct]], [card[secs]]];  PF.PutF[stdout, "decimal: %d, octal: %06oB, hex: %04xH, binary: %016b\n"L,    [card[word]], [card[word]], [card[word]], [card[word]]];The syntax is a bit awkward, with all those [[]]s, but it's still easier to use than repeated calls to Format, and it produces much smaller code.For convenience, there are inline procedures to make values shorter to write by eliminating the extra "[]" around the argument.  They are named PF.<type>, where <type> is one of the types defined below.  If you use the PF.time inline procedure, the default value is Time.Current[]. Thus PutF[stdout, "The current time is %g.\n"L, PF.time[]]; works.There are four groups of routines, distinguished by where they write their output: Streams, text Windows, StringProcs, and STRINGs.  Each group has three routines: the vanilla one, which takes up to ten values; the "2" version, which only takes up to two values but is more efficient to call; and the "L" version, which takes a descriptor for an array of values. >>  Value: TYPE = RECORD [SELECT type: * FROM    null => NULL,    atom => [v: Atom.ATOM],    block => [v: LONG POINTER TO Environment.Block],    bool => [v: BOOLEAN],    char => [v: CHARACTER],    card => [v: LONG CARDINAL],    int => [v: LONG INTEGER],    real => [v: REAL],    str => [v: LONG STRING],    time => [v: Time.Packed],    ENDCASE];  -- Inline procs for Value construction.  Some people prefer these - they are terser if you OPEN PF.  atom: PROC [v: Atom.ATOM] RETURNS [Value] = INLINE {RETURN[[atom[v]]]};  block: PROC [v: LONG POINTER TO Environment.Block] RETURNS [Value] = INLINE {RETURN[[block[v]]]};  bool: PROC [v: BOOLEAN] RETURNS [Value] = INLINE {RETURN[[bool[v]]]};  char: PROC [v: CHARACTER] RETURNS [Value] = INLINE {RETURN[[char[v]]]};  card: PROC [v: LONG CARDINAL] RETURNS [Value] = INLINE {RETURN[[card[v]]]};  int: PROC [v: LONG INTEGER] RETURNS [Value] = INLINE {RETURN[[int[v]]]};  real: PROC [v: REAL] RETURNS [Value] = INLINE {RETURN[[real[v]]]};  str: PROC [v: LONG STRING] RETURNS [Value] = INLINE {RETURN[[str[v]]]};  time: PROC [v: Time.Packed _ Time.Current[]] RETURNS [Value] = INLINE {RETURN[[time[v]]]};  nullValue: Value = [null[]];  Error: ERROR [code: ErrorCodes];  ErrorCodes: TYPE = {typeMismatch, tooManyValues, tooFewValues, unknownFormat};  -- Stream routines.  PutF: PROC [    out: Stream.Handle, format: LONG STRING,    v1, v2, v3, v4, v5, v6, v7, v8, v9, v10: Value _ nullValue];  PutF2: PROC [    out: Stream.Handle, format: LONG STRING, v1, v2: Value _ nullValue];  -- PutF2 is more efficient, if you only have one or two values.  PutFL: PROC [    out: Stream.Handle, format: LONG STRING,    list: LONG DESCRIPTOR FOR ARRAY OF Value];  -- You can use PutFL if you have more than 10 values, but it's probably easier to just split your call in two.  -- StringProc routines.  PutSP: PROC [    out: Format.StringProc, clientData: LONG POINTER, format: LONG STRING,    v1, v2, v3, v4, v5, v6, v7, v8, v9, v10: Value _ nullValue];  PutSP2: PROC [    out: Format.StringProc, clientData: LONG POINTER, format: LONG STRING,    v1, v2: Value _ nullValue];  PutSPL: PROC [    out: Format.StringProc, clientData: LONG POINTER, format: LONG STRING,    list: LONG DESCRIPTOR FOR ARRAY OF Value];  -- Window routines.  PutW: PROC [    out: Window.Handle, format: LONG STRING,    v1, v2, v3, v4, v5, v6, v7, v8, v9, v10: Value _ nullValue];  PutW2: PROC [    out: Window.Handle, format: LONG STRING, v1, v2: Value _ nullValue];  PutWL: PROC [    out: Window.Handle, format: LONG STRING,    list: LONG DESCRIPTOR FOR ARRAY OF Value];  -- STRING routines.  PutS: PROC [    out: LONG STRING, format: LONG STRING,    v1, v2, v3, v4, v5, v6, v7, v8, v9, v10: Value _ nullValue];  PutS2: PROC [    out: LONG STRING, format: LONG STRING, v1, v2: Value _ nullValue];  PutSL: PROC [    out: LONG STRING, format: LONG STRING,    list: LONG DESCRIPTOR FOR ARRAY OF Value];  END.*Unix is a trademark of Bell Labs.
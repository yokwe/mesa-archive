-- HelpWindowImpl.mesa-- Create by FormSWLayoutTool on 19-Dec-86 11:12DIRECTORY  Ascii,  FormSW,  Heap,  Tool,  ToolWindow,  TextSW,  TextSource,  Window,  HelpWindow;HelpWindowImpl: PROGRAM  IMPORTS    FormSW, Heap, Tool, TextSW, TextSource  EXPORTS     HelpWindow = {  maxTags: CARDINAL = 52; -- 50 regular tags + 2 preset tags  helpTextTag: LONG STRING = "Help"L;  allTextTag: LONG STRING = "All"L;    DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = MACHINE DEPENDENT RECORD [    formSW(0): Window.Handle ¬ NIL,    stringSW(2): Window.Handle ¬ NIL,    category(4): CARDINAL ¬ 0];    TextBlock: TYPE = RECORD [     startText: CARDINAL,     endText: CARDINAL];  data: DataHandle ¬ NIL;  wh: Window.Handle ¬ NIL;  zone: UNCOUNTED ZONE ¬ Heap.systemZone;  z: UNCOUNTED ZONE ¬ NIL;  windowString: LONG STRING ¬ NIL;  enumTags: ARRAY [0..maxTags - 1] OF FormSW.Enumerated;  enumTagsDescriptor: FormSW.EnumeratedDescriptor;  titleArray: ARRAY[0..maxTags - 1] OF LONG STRING;  tags: LONG DESCRIPTOR FOR ARRAY OF LONG STRING;  textArray: ARRAY[0..maxTags - 1] OF TextBlock;  text: LONG DESCRIPTOR FOR ARRAY OF TextBlock;  textArrayDescriptor: LONG DESCRIPTOR FOR ARRAY OF TextBlock;  helpDataArray: LONG POINTER TO PACKED ARRAY OF CHAR ¬ NIL;  notifyProc: HelpWindow.WindowDestroyedNotifyProcType ¬ NIL;  maxTagLength: CARDINAL = 50;    initialBox: Window.Box = [place: [x:512, y: 29], dims: [w: 512, h: 350]];ClearWindow: PROC[] =   BEGIN   TextSW.SetEOF[data.stringSW, 0];   END;AppendStringToTextSource: PROC[source: TextSource.Handle, s: LONG STRING] =   BEGIN   sourceLength: LONG CARDINAL ¬ TextSource.GetLength[source];      [] ¬ TextSource.ReplaceText[source, [LOOPHOLE[@s.text], 0, s.length],      sourceLength, sourceLength, TRUE];   END;AppendBlockToTextSource: PROC[source: TextSource.Handle, b: TextBlock] =   BEGIN   sourceLength: LONG CARDINAL ¬ TextSource.GetLength[source];   tempString: LONG STRING ¬ z.NEW[StringBody[b.endText - b.startText + 1]];      CopyBlockToString[tempString, b];   [] ¬ TextSource.ReplaceText[source, [LOOPHOLE[@tempString.text], 0,       tempString.length], sourceLength, sourceLength, TRUE];      z.FREE[@tempString];   END;CopyBlockToString: PROC[s: LONG STRING, b: TextBlock] =   BEGIN      FOR i: CARDINAL IN [b.startText..b.endText]      DO      IF s.length < s.maxlength THEN         BEGIN         s[s.length] ¬ helpDataArray[i];         s.length ¬ s.length + 1;	 END;      ENDLOOP;   END;    LoadTextWindow: PROC[source: TextSource.Handle, b: TextBlock] =   BEGIN   ClearWindow[];   AppendBlockToTextSource[source, b];   TextSW.Update[data.stringSW, 0, TextSource.GetLength[source], TRUE];   END;   DisplayHelpMessage: PROC[] =   BEGIN   CRConst: LONG STRING = "\N"L;   HelpMessage: LONG STRING = "\NUse ""Category"" to select the type of help you need.\NClick on ""Done"" to destroy this window."L;   textSource: TextSource.Handle ¬ TextSW.GetSource[data.stringSW];      IF data.category = 0 THEN      BEGIN      ClearWindow[];      AppendStringToTextSource[textSource, HelpMessage];      TextSW.Update[data.stringSW, 0, TextSource.GetLength[textSource], TRUE];      END   ELSE IF data.category = 1 THEN      BEGIN      ClearWindow[];      FOR i: CARDINAL IN [0..LENGTH[enumTagsDescriptor] - 3]         DO	 AppendBlockToTextSource[textSource, textArrayDescriptor[i]];	 AppendStringToTextSource[textSource, CRConst];	 ENDLOOP;      TextSW.Update[data.stringSW, 0, TextSource.GetLength[textSource], TRUE];      END   ELSE      BEGIN      LoadTextWindow[textSource, textArrayDescriptor[data.category - 2]];      END;         END;CategoryChanged: FormSW.EnumeratedNotifyProcType =   BEGIN   DisplayHelpMessage[];   END;FindNextSlash: PROC[i: CARDINAL] RETURNS[CARDINAL] =   BEGIN   s: LONG STRING ¬ [1000];      WHILE helpDataArray[i] # '\\      DO      IF s.length < s.maxlength THEN         BEGIN         s[s.length] ¬ helpDataArray[i];         s.length ¬ s.length + 1;	 END;      i ¬ i + 1;      ENDLOOP;   RETURN[i];   END;   FindNextCR: PROC[i: CARDINAL] RETURNS[CARDINAL] =   BEGIN   WHILE helpDataArray[i] # Ascii.CR      DO      i ¬ i + 1;      ENDLOOP;   RETURN[i];   END;   AtEnd: PROC[i: CARDINAL] RETURNS[BOOLEAN] =   BEGIN   IF helpDataArray[i] = 'E AND      helpDataArray[i+1] = 'N AND      helpDataArray[i+2] = 'D THEN      RETURN[TRUE]   ELSE      RETURN[FALSE];   END;      Init: PUBLIC PROC[array: LONG POINTER TO PACKED ARRAY OF CHAR, zoneIn: UNCOUNTED ZONE] RETURNS[BOOLEAN] =   BEGIN   titleStart, titleEnd, recordEnd: CARDINAL ¬ 0;   i: CARDINAL ¬ 0;      helpDataArray ¬ array;   z ¬ zoneIn;   titleStart ¬ FindNextSlash[titleStart] + 1;      WHILE i < maxTags      DO      IF AtEnd[titleStart] THEN         BEGIN	 tags ¬ DESCRIPTOR[BASE[titleArray], i];	 text ¬ DESCRIPTOR[BASE[textArray], i];         RETURN[TRUE];	 END      ELSE         BEGIN         titleEnd ¬ FindNextCR[titleStart] - 1;         recordEnd ¬ FindNextSlash[titleEnd] - 1;	 textArray[i].startText ¬ titleStart;	 textArray[i].endText ¬ recordEnd;	 CopyBlockToNewString[@titleArray[i], [titleStart, titleEnd], z];	 titleStart ¬ recordEnd + 2;	 END;      i ¬ i + 1;      ENDLOOP;    tags ¬ DESCRIPTOR[BASE[titleArray], i];    text ¬ DESCRIPTOR[BASE[textArray], i];    RETURN[FALSE];         END;    CopyBlockToNewString: PROC[s: LONG POINTER TO LONG STRING, b: TextBlock, z: UNCOUNTED ZONE] =   BEGIN      s­ ¬ z.NEW[StringBody[CARDINAL[b.endText - b.startText + 1]]];   s.length ¬ 0;      FOR i: CARDINAL IN [b.startText..b.endText]      DO      s[s.length] ¬ helpDataArray[i];      s.length ¬ s.length + 1;      ENDLOOP;   END;          Create: PUBLIC PROC[title: LONG STRING,    notify: HelpWindow.WindowDestroyedNotifyProcType] =   BEGIN      <<	#########################################################	Form Enum Descriptor	######################################################### >>   enumTags[0] ¬ [helpTextTag, 0];   enumTags[1] ¬ [allTextTag, 1];      FOR i: CARDINAL IN [0..MIN[LENGTH[tags], maxTags - 3]] DO      enumTags[i + 2] ¬ [tags[i], i + 2];      ENDLOOP;         enumTagsDescriptor ¬ DESCRIPTOR[BASE[enumTags], MIN[LENGTH[tags] + 2, maxTags]];   textArrayDescriptor ¬ text;      wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default, initialBox: initialBox,      clientTransition: ClientTransition, name: title];      notifyProc ¬ notify;   DisplayHelpMessage[];   END;Destroy: PUBLIC PROC[] =   BEGIN   IF wh # NIL THEN      BEGIN      Tool.Destroy[wh];      wh ¬ NIL;      END;   IF notifyProc # NIL THEN      notifyProc[];   END;Done: FormSW.ProcType =   BEGIN   Tool.Destroy[wh];   wh ¬ NIL;   notifyProc[];   END;              ClientTransition: ToolWindow.TransitionProcType = {    SELECT TRUE FROM      old = inactive =>        IF data = NIL THEN data ¬ zone.NEW[Data ¬ []];      new = inactive =>        IF data # NIL THEN {	  zone.FREE[@data]};      ENDCASE;    };  MakeSWs: Tool.MakeSWsProc = {    data.formSW ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    data.stringSW ¬ Tool.MakeStringSW[window: window, s: @windowString, access: read, expandable: TRUE];    };  MakeForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = 2;        items ¬ AllocateItemDescriptor[nItems];        items[0] ¬ EnumeratedItem[      tag: "Category"L, place: [6, line0], choices: enumTagsDescriptor, proc: CategoryChanged, value: @data.category];          items[1] ¬ CommandItem[tag: "Done"L, place: [424, line0], proc: Done];          RETURN[items: items, freeDesc: TRUE];    };  }...    
-- Copyright (C) 1984, 1985  by Xerox Corporation. All rights reserved. -- DisplayerTIPAndPaint.mesa-- DEG     	21-Feb-84 22:28:08DIRECTORY  Atom USING [ATOM, MakeAtom],  BitSW USING [    Bitmap, GetFrame, Gray, Handle, Invert, IsIt, JumpTo, VAdd, VSub, White],  Cursor USING [Defined, GetInfo, Set],  Display USING [Bitmap, textFlags],  Format USING [StringProc],  FormSW USING [ItemType],  SpecialDisplay USING [Handle, SpBlock, SpWhite],  String USING [AppendChar, AppendString, Length, StringBoundsFault],  TIP USING [CreateTable, First, InvalidTable, NotifyProc, Rest, Results, Table],  ToolFont USING [StringWidth],  ToolWindow USING [WindowForSubwindow],  SimpleDisplayer USING [    AddItem, ChoiceProcType, CreateItem, DataHandle, DestroyItem, EnumerateChoices,    EnumerateInvalidItems, GetTrash, ItemHandle, ItemMoved, OpenProps,    ResolveToItem, Share, zone],  UserInput USING [SetInputFocus],  UserTerminal USING [BlinkDisplay],  Window USING [    Box, Dims, GetBox, Handle, InvalidateBox, nullBox, Place, Validate],  WindowOps USING [Handle];DisplayerTIPAndPaint: PROGRAM  IMPORTS    Atom, BitSW, Cursor, Display, SpecialDisplay, String, TIP, ToolFont,    ToolWindow, SimpleDisplayer, UserInput, UserTerminal, Window  EXPORTS SimpleDisplayer =  {  OPEN SimpleDisplayer;  AtomPtr: TYPE = LONG POINTER TO AtomRecord;  AtomRecord: TYPE = RECORD [    enter: Atom.ATOM ¬ NIL,    exit: Atom.ATOM ¬ NIL,    props: Atom.ATOM ¬ NIL,    delete: Atom.ATOM ¬ NIL,    move: Atom.ATOM ¬ NIL,    pointDown: Atom.ATOM ¬ NIL,    undo: Atom.ATOM ¬ NIL,    jfirst: Atom.ATOM ¬ NIL,    abort: Atom.ATOM ¬ NIL,    mouse: Atom.ATOM ¬ NIL];  a: AtomPtr ¬ NIL;  myTip: TIP.Table ¬ NIL;  oldCursor: Cursor.Defined;  moveCopy: BOOLEAN ¬ FALSE;  bufDims: Window.Dims = [1024, 12];  GetTip: PUBLIC PROC RETURNS [TIP.Table] = {RETURN[myTip]};  Notify: PUBLIC TIP.NotifyProc = {    instance: SimpleDisplayer.DataHandle;    coords: Window.Place;    selectMode: BOOLEAN;    BEGIN    ENABLE ABORTED => GOTO aborted;    IF ~BitSW.IsIt[sw: window] THEN RETURN;    instance ¬ SimpleDisplayer.Share[      wh: ToolWindow.WindowForSubwindow[sw: window]];    selectMode ¬ (String.Length[instance.tag] = 0) AND ~moveCopy;    FOR input: TIP.Results ¬ results, input.Rest UNTIL input = NIL DO      WITH z: input.First SELECT FROM        coords => coords ¬ ModifyPlace[z.place, instance];        atom =>          SELECT z.a FROM            a.enter => IF ~selectMode THEN EnterWindow[instance: instance];            a.exit => IF ~selectMode THEN ExitWindow[instance: instance];            a.mouse => IF ~selectMode THEN MouseMove[coords, instance];            a.pointDown =>              IF moveCopy THEN FinishMove[coords, instance]              ELSE                IF selectMode THEN HiLite[coords, instance]                ELSE Draw[coords, instance];            a.props => OpenProps[instance: instance];            a.delete => Delete[instance: instance];            a.move => Move[coords, instance];            a.undo => Undo[instance: instance];            a.abort => Abort[instance: instance];            a.jfirst => JFirst[instance: instance];            ENDCASE;        ENDCASE;      ENDLOOP;    EXITS aborted => NULL;    END};  ModifyPlace: PROC [old: Window.Place, instance: SimpleDisplayer.DataHandle]    RETURNS [new: Window.Place] = {    old ¬ BitSW.VSub[old, BitSW.GetFrame[instance.bitSW].place];    old ¬ [MAX[old.x, 0], MAX[old.y, 0]];    new ¬ [      x: IF instance.alignX THEN old.x - (old.x MOD instance.charWidth) ELSE old.x,      y:      IF instance.alignY THEN old.y - (old.y MOD instance.lineHeight) + 2      ELSE old.y];    };  EnterWindow: PROCEDURE [instance: SimpleDisplayer.DataHandle] = {    oldCursor ¬ Cursor.GetInfo[].type;    Cursor.Set[blank];    IF instance.modified AND ~moveCopy THEN {      instance.brushItem ¬ SimpleDisplayer.CreateItem[        instance.tag, Window.nullBox, instance.formtype, instance];      SetUpBrush[instance.tag, instance.formtype, instance, instance.brushItem]};    };  SetUpBrush: PROC [    tag: LONG STRING, type: FormSW.ItemType, instance: SimpleDisplayer.DataHandle,    item: SimpleDisplayer.ItemHandle ¬ NIL] = {    MakeStringBuf[tag, type, item, instance];    instance.modified ¬ FALSE;    instance.bpl ¬      ToolFont.StringWidth[instance.bufStr, instance.defaults.fontHandle] + 1;    instance.wpl ¬ (instance.bpl + 15) / 16;    instance.smallBox ¬ [[0, 0], [instance.wpl * 16, bufDims.h]];    instance.special.bpl ¬ instance.smallBox.dims.w;    instance.special.wpl ¬ instance.wpl;    LOOPHOLE[instance.bufSW, WindowOps.Handle].box ¬ instance.smallBox;    SpecialDisplay.SpWhite[instance.bufSW, instance.smallBox, instance.special];    Text[instance.bufStr, [0, 0], instance.bufStr.length, instance];    Text[instance.bufStr, [1, 0], tag.length, instance];    instance.lastBox ¬ Window.nullBox;    };  NullNotify: PROC [w: Window.Handle, p: LONG POINTER] = {};  MakeStringBuf: PROC [    tag: LONG STRING, type: FormSW.ItemType, item: SimpleDisplayer.ItemHandle,    instance: SimpleDisplayer.DataHandle] = {    ENABLE      String.StringBoundsFault => {        instance.bufStr ¬ ns ¬ SimpleDisplayer.zone.NEW[          StringBody [s.maxlength * 2]];        ns.length ¬ s.length;        FOR i: CARDINAL IN [0..s.length) DO ns[i] ¬ s[i] ENDLOOP;        SimpleDisplayer.zone.FREE[@s];        RESUME        };    Write: Format.StringProc ¬ NIL;    instance.bufStr.length ¬ 0;    String.AppendString[instance.bufStr, tag];    SELECT type FROM      command => String.AppendChar[instance.bufStr, '!];      string => String.AppendChar[instance.bufStr, ':];      longNumber, number => String.AppendChar[instance.bufStr, '=];      enumerated => {        maxLength: CARDINAL ¬ 0;        max: LONG STRING ¬ NIL;        overflow: BOOLEAN ¬ FALSE;        AddEnum: SimpleDisplayer.ChoiceProcType = {          IF overflow OR ((instance.bufStr.length + s1.length) > 150) THEN {            overflow ¬ TRUE; RETURN};          IF ~first THEN String.AppendString[instance.bufStr, ", "L];          String.AppendString[instance.bufStr, s1]};        AddLargest: SimpleDisplayer.ChoiceProcType = {          len: CARDINAL ¬ String.Length[s1];          IF len > maxLength THEN {maxLength ¬ len; max ¬ s1}};        String.AppendString[instance.bufStr, ": {"L];        IF item # NIL THEN {          WITH vi: item­ SELECT FROM            enumerated =>              IF vi.feedback = all THEN {                SimpleDisplayer.EnumerateChoices[@vi, AddEnum, Write];                IF overflow THEN String.AppendString[instance.bufStr, "..."L]}              ELSE {                SimpleDisplayer.EnumerateChoices[@vi, AddLargest, Write];                IF max # NIL THEN String.AppendString[instance.bufStr, max]};            ENDCASE;          };        String.AppendString[instance.bufStr, "}"L];        };      ENDCASE;    };  ExitWindow: PROCEDURE [instance: SimpleDisplayer.DataHandle] = {    IF instance.lastBox # Window.nullBox THEN {      instance.bitSW.InvalidateBox[FromBitmap[instance.lastBox, instance]];      instance.bitSW.Validate[];      };    Cursor.Set[oldCursor];    };  MouseMove: PROC [coords: Window.Place, instance: SimpleDisplayer.DataHandle] = {    IF instance.lastBox # Window.nullBox THEN {      instance.bitSW.InvalidateBox[FromBitmap[instance.lastBox, instance]];      instance.bitSW.Validate[];      };    instance.lastBox ¬ [coords, instance.smallBox.dims];    Display.Bitmap[      instance.bitSW, FromBitmap[instance.lastBox, instance], [      instance.small, 0, 0], instance.smallBox.dims.w];    };  FinishMove: PROC [coords: Window.Place, instance: SimpleDisplayer.DataHandle] = {    IF instance.selectedItem = NIL THEN RETURN;    moveCopy ¬ FALSE;    BitSW.White[instance.bitSW, instance.selectedItem.box];    RepaintInvalids[instance.selectedItem, instance];    instance.bitSW.InvalidateBox[FromBitmap[instance.selectedItem.box, instance]];    SetUpBrush[      instance.selectedItem.tag, instance.selectedItem.type, instance,      instance.selectedItem];    MouseMove[coords, instance];    BitSW.Bitmap[      instance.bitSW, instance.lastBox, [instance.small, 0, 0],      instance.smallBox.dims.w];    SimpleDisplayer.ItemMoved[instance.selectedItem, coords, instance];    instance.selectedItem ¬ NIL;    instance.bitSW.Validate[];    Cursor.Set[oldCursor];    };  Paint: PUBLIC PROC [    item: SimpleDisplayer.ItemHandle, instance: SimpleDisplayer.DataHandle] = {    BitSW.White[instance.bitSW, item.box];    instance.bitSW.InvalidateBox[FromBitmap[item.box, instance]];    RepaintInvalids[item, instance];    PaintItem[item, instance];    item.box.dims ¬ [instance.bpl, instance.lineHeight - 4];  -- might have new box    instance.bitSW.InvalidateBox[FromBitmap[item.box, instance]];    instance.bitSW.Validate[];    instance.selectedItem ¬ NIL;    };  PaintItem: PROC [    item: SimpleDisplayer.ItemHandle, instance: SimpleDisplayer.DataHandle] = {    SetUpBrush[item.tag, item.type, instance, item];    BitSW.Bitmap[      instance.bitSW, [item.box.place, instance.smallBox.dims], [      instance.small, 0, 0], instance.smallBox.dims.w]};  RepaintInvalids: PROC [    item: SimpleDisplayer.ItemHandle, instance: SimpleDisplayer.DataHandle] = {    SimpleDisplayer.EnumerateInvalidItems[item, PaintItem, instance]};  Draw: PROC [coords: Window.Place, instance: SimpleDisplayer.DataHandle] = {    IF instance.brushItem = NIL THEN      instance.brushItem ¬ SimpleDisplayer.CreateItem[        instance.tag, [        instance.lastBox.place, [instance.bpl, instance.lineHeight - 4]],        instance.formtype, instance]    ELSE      instance.brushItem.box ¬ [        instance.lastBox.place, [instance.bpl, instance.lineHeight - 4]];    SimpleDisplayer.AddItem[instance.brushItem, instance];    MouseMove[coords, instance];    BitSW.Bitmap[      instance.bitSW, instance.lastBox, [instance.small, 0, 0],      instance.smallBox.dims.w];    instance.brushItem ¬ NIL;    };  Text: PROC [    string: LONG STRING, place: Window.Place, length: CARDINAL,    instance: SimpleDisplayer.DataHandle] = {    [] ¬ SpecialDisplay.SpBlock[      instance.bufSW, [LOOPHOLE[@string.text], 0, length], bufDims.w, place,      instance.defaults.fontHandle, Display.textFlags, NIL, instance.special];    };  Abort: PROCEDURE [instance: SimpleDisplayer.DataHandle] = {    IF ~moveCopy THEN RETURN;    IF instance.selectedItem = NIL THEN RETURN;    instance.bitSW.InvalidateBox[FromBitmap[instance.selectedItem.box, instance]];    instance.bitSW.InvalidateBox[FromBitmap[instance.lastBox, instance]];    BitSW.White[instance.bitSW, instance.selectedItem.box];    RepaintInvalids[instance.selectedItem, instance];    PaintItem[instance.selectedItem, instance];    instance.bitSW.Validate[];    Cursor.Set[oldCursor];    moveCopy ¬ FALSE;    instance.selectedItem ¬ NIL;    };  Delete: PROCEDURE [instance: SimpleDisplayer.DataHandle] = {    IF instance.selectedItem = NIL THEN RETURN;    BitSW.White[instance.bitSW, instance.selectedItem.box];    RepaintInvalids[instance.selectedItem, instance];    instance.bitSW.InvalidateBox[FromBitmap[instance.selectedItem.box, instance]];    instance.bitSW.Validate[];    SimpleDisplayer.DestroyItem[instance.selectedItem, instance, TRUE];    instance.itemCount ¬ instance.itemCount - 1;    instance.selectedItem ¬ NIL};  Move: PROC [coords: Window.Place, instance: SimpleDisplayer.DataHandle] = {    IF instance.selectedItem = NIL THEN RETURN;    moveCopy ¬ TRUE;    oldCursor ¬ Cursor.GetInfo[].type;    Cursor.Set[blank];    BitSW.White[window: instance.bitSW, box: instance.selectedItem.box];    RepaintInvalids[instance.selectedItem, instance];    BitSW.Gray[      window: instance.bitSW, box: instance.selectedItem.box, dstFunc: or];    instance.bitSW.InvalidateBox[FromBitmap[instance.selectedItem.box, instance]];    instance.bitSW.Validate[];    SetUpBrush[      instance.selectedItem.tag, instance.selectedItem.type, instance,      instance.selectedItem];    MouseMove[coords, instance];    };  Undo: PROCEDURE [instance: SimpleDisplayer.DataHandle] = {    item: SimpleDisplayer.ItemHandle ¬ SimpleDisplayer.GetTrash[      instance: instance];    IF item = NIL THEN RETURN;    SetUpBrush[item.tag, item.type, instance, item];    SimpleDisplayer.AddItem[item, instance];    MouseMove[item.box.place, instance];    BitSW.Bitmap[      instance.bitSW, instance.lastBox, [instance.small, 0, 0],      instance.smallBox.dims.w];    };  JFirst: PROCEDURE [instance: SimpleDisplayer.DataHandle] = {    instance.bitSW.InvalidateBox[[[0, 0], instance.bitSW.GetBox[].dims]];    BitSW.JumpTo[instance.bitSW, [0, 0]]};  OpenProps: PROCEDURE [instance: SimpleDisplayer.DataHandle] = {    IF instance.selectedItem = NIL THEN RETURN;    SimpleDisplayer.OpenProps[instance.selectedItem, instance];    };  HiLite: PROC [coords: Window.Place, instance: SimpleDisplayer.DataHandle] = {    item: SimpleDisplayer.ItemHandle ¬ SimpleDisplayer.ResolveToItem[      coords, instance];    IF instance.selectedItem = item THEN RETURN;    IF instance.selectedItem # NIL THEN {      BitSW.Invert[instance.bitSW, instance.selectedItem.box];      instance.bitSW.InvalidateBox[        FromBitmap[instance.selectedItem.box, instance]];      instance.bitSW.Validate[];      instance.selectedItem ¬ NIL};    IF item = NIL THEN RETURN;    UserInput.SetInputFocus[instance.bitSW, NullNotify, TRUE, NIL];    instance.selectedItem ¬ item;    BitSW.Invert[instance.bitSW, instance.selectedItem.box];    instance.bitSW.InvalidateBox[FromBitmap[instance.selectedItem.box, instance]];    instance.bitSW.Validate[]};  FromBitmap: PROC [old: Window.Box, instance: SimpleDisplayer.DataHandle]    RETURNS [new: Window.Box] = {    new ¬ [      place: BitSW.VAdd[old.place, BitSW.GetFrame[instance.bitSW].place],      dims: old.dims];    };  Init: PROC = {    firstTime: BOOLEAN ¬ TRUE;    tipContents: STRING =      "-- SimpleBindweedDisplayer.TIP; created by System-- Version of 19-Feb-84 22:12:51OPTIONS  Fast;  -- Top-level trigger select  SELECT TRIGGER FROM    -- Mouse and button actions    MOUSE => COORDS, MouseMotion;    [DEF,ButtonEvents,(    [DEF,ButtonEvent,(      ~1 ~2 => SELECT ENABLE FROM	ENDCASE => { COORDS ~1~2 })]    [ButtonEvent,~1,Down];[ButtonEvent,~1,Up])]    [ButtonEvents,Point];  [ButtonEvents,Menu];  [ButtonEvents,Adjust];    ENTER => Enter;  EXIT => Exit;  CONTROL Down => Props;  DELETE Down => Delete;  MOVE Down => COORDS, Move;  UNDO Down => Undo;  JFIRST Down => JFirst;  USERABORT Down => Abort;      ENDCASE..."L;    myTip ¬ TIP.CreateTable[      file: "SimpleBindweedDisplayer.TIP"L, contents: tipContents !      TIP.InvalidTable =>        IF type # badSyntax THEN CONTINUE        ELSE {          UserTerminal.BlinkDisplay[];          IF firstTime THEN {firstTime ¬ FALSE; RESUME }}];    IF myTip = NIL THEN RETURN;    IF a = NIL THEN a ¬ SimpleDisplayer.zone.NEW[AtomRecord ¬ []];    MakeAtoms[];    };  MakeAtoms: PROC = {    a.enter ¬ Atom.MakeAtom["Enter"L];    a.exit ¬ Atom.MakeAtom["Exit"L];    a.mouse ¬ Atom.MakeAtom["MouseMotion"L];    a.pointDown ¬ Atom.MakeAtom["PointDown"L];    a.props ¬ Atom.MakeAtom["Props"L];    a.delete ¬ Atom.MakeAtom["Delete"L];    a.move ¬ Atom.MakeAtom["Move"L];    a.undo ¬ Atom.MakeAtom["Undo"L];    a.abort ¬ Atom.MakeAtom["Abort"L];    a.jfirst ¬ Atom.MakeAtom["JFirst"L];    };  Init[];  }....  
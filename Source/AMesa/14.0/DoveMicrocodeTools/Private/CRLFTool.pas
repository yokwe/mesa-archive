PROGRAM CrLfTool(INPUT, OUTPUT);{       P R O G R A M   D E S C R I P T I O N       = = = = = = =   = = = = = = = = = = =       This program converts files containing carriage return/line feeds to       files containing just carriage returns and visa versa.  It's primary       use is intended for transporting text files back and forth between       the Xerox Development Environment and MS-DOS.}CONST  CR = #13;                            { Define the needed character const's.}  LF = #10;TYPE  STRING60 = STRING[60];               { File name's maximum length.         }VAR{  j - Used to index through the list of files to work on.  noOfFiles - The number of files to be converted.  crLf - Indicates whether we are converting to CR/LF or just CR files.  problem - Indicates when a file has a problem.  fileNames - An array containing all the file names to be converted.  srcFile - A handle to the source file.  destFile - A handle to the destination file.}  j, noOfFiles: INTEGER;  crLf, problem: BOOLEAN;  fileNames: ARRAY [1..100] OF STRING60;  srcFile, destFile: TEXT;PROCEDURE GetCMDLine;{  This procedure is called to get the file names to be converted from the  command line.  It also processes the switch '/lf', which indicates conversion  to CR/LF files.  The default is to convert to just CR files.}VAR{  i - Used to index through the parameters on the command line.  paramNos - The number of parameters on the command line.  tempStr - Used to acquire the a given command string from the command line.}  i, paramNos: INTEGER;  tempStr: STRING[60];BEGIN  paramNos := ParamCount;              { Determine the number of parameters.  }  i := 1;                              { Initialize parameter index.          }  j := 1;                              { Initialize file name index.          }  crLf := FALSE;                       { Set default conversion direction.    }  WHILE i <= paramNos DO               { While not all parameters processed...}  BEGIN    tempStr := ParamStr(i);            { Get a parameter.                     }    IF (tempStr = '/lf') OR (tempStr = '/LF') OR (tempStr = '/Lf')       OR (tempStr = '/lF')            { Is the parameter the switch /lf?     }    THEN      crLf := TRUE                     { Must be converting to DOS format.    }    ELSE    BEGIN      fileNames[j] := tempStr;         { Must be a file name.  Save it!       }      j := j + 1;                      { Next file index.                     }    END;    i := i + 1;                        { Next parameter index.                }  END;  IF crLf THEN                         { Let the user know type of conversion.}    WRITELN('Converting to a CR/LF text file.')  ELSE    WRITELN('Converting to a CR (only) text file.');  noOfFiles := j - 1;END;PROCEDURE RenameFile(fileName: STRING60);{  This procedure is called to rename a file to filename.bak.  It also  initializes the file handles:  srcFile and destFile.}VAR{  newFile - This string is used to convert the file name to filename.bak.  dotPos - Probably unnecessary, but specifies the postion of '.' within           the file name.}  newFile: STRING60;  dotPos: INTEGER;BEGIN  dotPos := Pos('.', fileName);        { Get the dot position.                }  newFile := Copy(fileName, 1, dotPos);{ Get the back up file name.           }  newFile := Concat(newFile, 'BAK');  Assign(destFile, fileName);          { Assign the destination file name.    }  Assign(srcFile, newFile);            { Assign the source file name. (temp)  }  {$I-}  Rewrite(srcFile);  Close(srcFile);  Erase(srcFile);                      { Erase any already existing backup.   }  {$I+}  Assign(srcFile, fileName);           { Rename to back up file name.         }  {$I-}  Rename(srcFile, newFile);  {$I+}  problem := (IOResult <> 0);          { Check for a problem.                 }END;PROCEDURE ConvertFile;{  This procedure does the conversion to the specified file format.}VAR  ch: CHAR;                            { For reading a character from file.  }BEGIN  {$I-}  Reset(srcFile);                      { Open the source and destination.    }  {$I+}  problem := (IOResult <> 0);  {$I-}  REWRITE(destFile);  {$I+}  problem := problem OR (IOResult <> 0); { Determine if there is a problem.  }  IF NOT problem THEN                  { Convert the file.                   }  BEGIN    WHILE NOT EOF(srcFile) DO    BEGIN      READ(srcFile, ch);      CASE ch OF        CR: IF crLf THEN            BEGIN              WRITE(destFile, ch);              WRITE(destFile, LF);            END            ELSE              WRITE(destFile, ch);        LF: IF crLf THEN              WRITE(destFile, ch);        ELSE          WRITE(destFile, ch);      END;    END;    Close(srcFile);                    { Close the files.                     }    Close(destFile);  END  ELSE    WRITELN('Error with ', fileNames[j], '.  Skipped!');END;BEGIN  GetCMDLine;                          { Process command line.                }  FOR j := 1 TO noOfFiles DO           { Process each file on the specified.  }  BEGIN    problem := FALSE;                  { Initially, no problems.              }    RenameFile(fileNames[j]);          { Rename to back up and set handles.   }    IF NOT problem THEN                { If no problems, then convert the file}      ConvertFile    ELSE                               { Otherwise let user know.             }      WRITELN('Error with ', fileNames[j], '.  Skipped!');  END;END.
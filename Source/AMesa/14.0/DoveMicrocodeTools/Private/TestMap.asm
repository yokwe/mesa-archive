$MOD186$PAGELENGTH (72)$PAGEWIDTH  (136);Copyright (C) 1986 by Xerox Corporation. All rights reserved.;-- File: TestMap.asm;-- last edited by:;--RDH	16-Jun-86 14:28:51	;Create. ;--RDH	17-Jun-86  9:37:05	;Fix loop controls and XOR ¬ AND. ;--RDH	17-Jun-86 13:55:16	;Add CLI. ;--RDH	18-Jun-86 10:52:32	;Put data into separate segment after code. ;--RDH	23-Jun-86 12:22:44	;Change algorithm to not use so much space. NAME			TestMap	TestData		SEGMENT		PUBLIC;VariablesBeginDataArea	LABEL	BYTEErrTableEntry	STRUC  RealPageNumber	DW	?  FirstVirtPage		DW	?  SecondVirtPage	DW	?  Filler		DW	?ErrTableEntry	ENDS MaxErrors	EQU	40HErrorTableSize	EQU	MaxErrors * SIZE ErrTableEntryTotalErrCnt	DW	?	;Number of errs of any typeDupPageErrs	DW	?	;Number of doubly mapped real pagesMaxMappedPg	DW	?	;Highest real page in mapLastVirtPagePtrLo	DW	?	;For comparison with DI.LastVirtPagePtrHi	DW	?	;For comparison with ES.;24Bit => 3000:FFFE, 23Bit => 2000:FFFE, 22Bit => 2000:7FFEErrorTable	DB	ErrorTableSize DUP (?)	;RealMemoryMap	DW	2000H DUP (?)	;Word for each page of real memorySizeOfDataArea	EQU	$ - BeginDataAreaTestData		ENDSTestCode		SEGMENT		PUBLIC	ASSUME	CS:TestCode	ASSUME	ES:NOTHING	;Public symbolsPUBLIC	StartTestMap, TestOver	;Constants and structures	FlagsMask	EQU	0E000HVacantFlags	EQU	6000H		;Begin codeStartTestMap:		PUSHA	PUSH	ES	PUSH	DS	;CS:IP is already smashed and must be saved by user if wanted	;SS will not be changed.		CLI			;IO region is smashed. Allow no interrupts.	;Initialize segment pointers.	MOV	AX, TestData	MOV	DS, AX	 	 	ASSUME	DS:TestData	;Take care of ES when we set up to read VMM	;Zero out data area.	MOV	CX, SizeOfDataArea	XOR	AL, AL	XOR	BX, BXZeroLoop:	MOV	BeginDataArea[BX], AL	INC	BX	LOOP	ZeroLoop		;Get a pointer to VMM	MOV	AX, 2000H	;Map reg 1 already programmed for VMM	MOV	ES, AX		;	XOR	DI, DI		;Start at beginning of map		;The main loop init	XOR	SI, SI		;Zero error table offset	MOV	LastVirtPagePtrLo, 0FFFEH		;Assume a 23 bit, 16 MB VM.	MOV	LastVirtPagePtrHi, 2000H	;Assume a 23 bit, 16 MB VM.ChangeVMSize:	NOP	;Set a break here to change VM size to 24 or 22 bits.			;The outer loopBigLoop:	MOV	AX, ES:[DI]	;Fetch map entry	PUSH	AX		;Save it.	AND	AX, FlagsMask	;Get flags	XOR	AX, VacantFlags	;Check if page entry meaningful	POP	BP		;Get original map entry back	JZ	VacantSkip	;IF vacant go on to next map entry	AND	BP, NOT FlagsMask	;Wipe out flags	CMP	BP, MaxMappedPg		;Keep record of highest mapped real page.	JLE	CheckForDblMap		;	MOV	MaxMappedPg, BP		;New highest mapped real page.	CheckForDblMap:	PUSH	ES		;Save pointer to this word before stepping	PUSH	DI		; through rest of VMM comparing to this one.		CMP	DI, LastVirtPagePtrLo	;Check if we might be done with task.	JNE	InnerLoop		;Skip check of ptr high.	MOV	AX, ES			;Get ptr hi into reg we can work with.	CMP	AX, LastVirtPagePtrHi	;Does ptr hi match also?	JGE	DoneWithMapCheck	;If so we are finished.	ADD	AX, 1000H		;Bump ptr hi.	MOV	ES, AX			;Prepare to use bumped ptr.	InnerLoop:	ADD	DI, 2			;Bump ptr low.  If rollover occurs it will					; already have been propagated above.	MOV	AX, ES:[DI]		;Read next map entry.	AND	AX, NOT FlagsMask	;Zap the flags.	CMP	BP, AX			;Look for equal real page numbers.	JE	MaybeError		;This will be an error if the second page					; is not marked vacant.InnerLoopControl:	CMP	DI, LastVirtPagePtrLo	;Check for need to bump ptr hi or end of					; loop.	JNE	InnerLoop		;Continue on.		MOV	AX, ES			;Get ptr hi into reg we can work with.	CMP	AX, LastVirtPagePtrHi	;Does ptr hi match also?	JGE	DoneWithInnerLoop	;If so we are finished with inner loop.	ADD	AX, 1000H		;Bump ptr hi.	MOV	ES, AX			;Prepare to use bumped ptr.	JMP	InnerLoop		;Continue through inner loop.	DoneWithMapCheck:	JMP	DoneWithMapCheck2	;Relay for long branch.	VacantSkip:	ADD	DI, 2			;Bump ptr low.	JNZ	BigLoop			;If no rollover do next map entry.	MOV	AX, ES			;Get ptr hi into reg we can work with.	CMP	AX, LastVirtPagePtrHi	;Does ptr hi match last value?	JE	FinishedWithVacant	;If so we are done.DoneWithInnerLoop:	POP	DI			;Recover ptr lo.	POP	ES			;Recover ptr hi.	ADD	DI, 2			;Bump ptr lo.	JNZ	BigLoop			;Iterate outer loop.		MOV	AX, ES			;Get ptr hi into reg we can work with.	ADD	AX, 1000H		;Bump ptr hi.	MOV	ES, AX			;Prepare to use bumped ptr.	JMP	BigLoop			;Continue through outer loop.	MaybeError:	MOV	AX, ES:[DI]		;Re-fetch the map entry.	AND	AX, FlagsMask		;Zap the real page number.	CMP	AX, VacantFlags		;Check if flags vacant.	JE	InnerLoopControl	;No error. Continue thru loop.RecordError:	INC	TotalErrCnt	;One more error	INC	DupPageErrs	;Its a duplicate page			MOV	ErrorTable[SI].RealPageNumber, BP	;Record doubly mapped 							; real page.	MOV	AX, DI		;Generate virtual page number from ES and DI 	MOV	BX, ES		; in AX without smashing ES or DI.	SHR	AX, 1		;Byte offset to word.	SHL	BX, 3		;Shift left 4 and right 1, wiping out map reg #.	OR	AX, BX		;This should be virtual page number.	MOV	ErrorTable[SI].SecondVirtPage, AX	;Store in error table.		POP	AX		;Generate virtual page number from top words of 	POP	BX		; stack in AX without smashing stack.	PUSH	BX	PUSH	AX	SHR	AX, 1		;Byte offset to word.	SHL	BX, 3		;Shift left 4 and right 1, wiping out map reg #.	OR	AX, BX		;This should be virtual page number.	MOV	ErrorTable[SI].FirstVirtPage, AX	;Store in error table.BumpErrTablePtr:	ADD	SI, SIZE ErrTableEntry		;Point to next error entry.	CMP	SI, ErrorTableSize		;Check for error table overflow.	JGE	ErrorOverflow			;If overflow stop test.		JMP	InnerLoopControl		;Continue inner loop. ErrorOverflow:	JMP	SHORT DoneWithMapCheck2DoneWithMapCheck2:	POP	AX				;Clear the stack	POP	AX				; of two words.FinishedWithVacant:	TEST	TotalErrCnt, 0FFFFH	JZ	NoErrors		WereErrors:	JMP	SHORT RestoreState	NoErrors:	JMP	SHORT RestoreState		RestoreState:	;Restore state	POP	DS	POP	ES	POPATestOver:	JMP	TestOverTestCode		ENDS			END
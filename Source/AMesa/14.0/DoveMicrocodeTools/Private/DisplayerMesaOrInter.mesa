-- Copyright (C) 1984, 1985  by Xerox Corporation. All rights reserved. -- DisplayerMesaOrInter.mesa-- DEG     	22-Feb-84  0:22:47DIRECTORY  Format USING [Date, LongNumber, Number, StringProc],  FormSW USING [nullIndex],  String,  Time USING [Current],  ToolWindow USING [WindowForSubwindow],  SimpleDisplayer,  Window USING [Box, GetBox];DisplayerMesaOrInter: PROGRAM  IMPORTS Format, String, Time, SimpleDisplayer, ToolWindow, Window  EXPORTS SimpleDisplayer =  {  AnyFont: BOOLEAN ¬ FALSE;  CheckItem: PROC [    item: SimpleDisplayer.ItemHandle, Write: Format.StringProc,    instance: SimpleDisplayer.DataHandle] = {    IF item.enumName = NIL THEN      item.enumName ¬ String.CopyToNewString[item.tag, SimpleDisplayer.zone];    };  CheckItems: PROCEDURE [    instance: SimpleDisplayer.DataHandle, Write: Format.StringProc] = {    SimpleDisplayer.EnumerateItems[CheckItem, Write, instance];    IF instance.defaults.enumType = NIL THEN      instance.defaults.enumType ¬ String.CopyToNewString[        "FormItems"L, SimpleDisplayer.zone];    IF instance.defaults.handleName = NIL THEN      instance.defaults.handleName ¬ String.CopyToNewString[        "data"L, SimpleDisplayer.zone];    };  WriteOut: PUBLIC PROC [    proc: Format.StringProc, anyFont: BOOLEAN ¬ FALSE,    instance: SimpleDisplayer.DataHandle] = {    AnyFont ¬ anyFont;    WriteHeader[instance: instance, Write: proc];    BuildDataRecord[instance: instance, Write: proc];    WriteGlobalDataRecord[instance: instance, Write: proc];    WriteWindowMgmtRecord[Write: proc];    BuildEnumType[instance: instance, Write: proc];    BuildVariables[instance: instance, Write: proc];    WriteMonitoringProcs[instance: instance, Write: proc];    WriteWindowMgmtProcs[instance: instance, Write: proc];    BuildInitialProcs[instance: instance, Write: proc];    BuildFormSW[instance: instance, Write: proc];    BuildProcs[instance: instance, Write: proc];    Finish[Write: proc];    };  WriteHeader: PROCEDURE [    instance: SimpleDisplayer.DataHandle, Write: Format.StringProc] = {    Write["-- "L];    Write[instance.root];    Write[".mesa-- Created by BindweedDisplayer on "L];    Format.Date[Write, Time.Current[], dateTime];    Write["\n\nDIRECTORY\n"L];    Write[      "  Context,\n  Exec,\n  FormSW,\n  Heap,\n  Put,\n  Runtime,\n  String,\n  Time,\n  Tool,\n  ToolWindow,\n  Version,\n  Window"L];    IF ~AnyFont THEN Write[";\n\n"L] ELSE Write[",\n  WindowFont;\n\n"L];    Write[instance.root];    Write[": MONITOR\n  IMPORTS\n    "L];    Write[      "Context, Exec, FormSW, Heap, Put, Runtime, String, Time, Tool, ToolWindow, Version"L];    IF ~AnyFont THEN Write[" = {\n\n"L] ELSE Write[", WindowFont = {\n\n"L];    };  WriteGlobalDataRecord: PROCEDURE [    instance: SimpleDisplayer.DataHandle, Write: Format.StringProc] = {    Write[      "  GlobalDataHandle: TYPE = LONG POINTER TO GlobalData;\n  GlobalData: TYPE = RECORD [\n    context: Context.Type,\n    tinyName1: LONG STRING ¬ NIL,\n    tinyName2: LONG STRING ¬ NIL,\n    rootName: LONG STRING ¬ NIL,\n    nameStripeName: LONG STRING ¬ NIL,\n    "L];    IF instance.useBox THEN {      box: Window.Box ¬ ToolWindow.WindowForSubwindow[instance.bitSW].GetBox[];      Write["initialBox: Window.Box = [place: [x:"L];      Format.Number[Write, box.place.x, []];      Write[", y: "L];      Format.Number[Write, box.place.y, []];      Write["], dims: [w: "L];      Format.Number[Write, box.dims.w, []];      Write[", h: "L];      Format.Number[Write, box.dims.h, []];      Write["]],\n    "L];      };    Write["windows: WindowList ¬ NIL];\n\n"L]};  WriteWindowMgmtRecord: PROCEDURE [Write: Format.StringProc] = {    Write[      "  WindowList: TYPE = LONG POINTER TO WindowRecord;\n  WindowRecord: TYPE = RECORD [\n    wh: Window.Handle ¬ NIL,\n    link: WindowList ¬ NIL];\n\n"L]};  recPtr: INTEGER ¬ 0;  PutRecItem: PROC [    s1, s2: LONG STRING, incr: CARDINAL, Write: Format.StringProc,    first: BOOLEAN ¬ FALSE] = {    IF String.Length[s1] = 0 THEN RETURN;    IF first THEN Write["\n    "L] ELSE Write[",\n    "L];    Write[s1];    Write["("L];    Format.Number[Write, recPtr, [unsigned: FALSE]];    recPtr ¬ recPtr + incr;    Write["): "L];    Write[s2];    };  DoDataRecord: PROC [    item: SimpleDisplayer.ItemHandle, Write: Format.StringProc,    instance: SimpleDisplayer.DataHandle ¬ NIL] = {    WITH i: item­ SELECT FROM      boolean => {PutRecItem[i.switch, "BOOLEAN ¬ FALSE"L, 1, Write]};      enumerated => {PutRecItem[i.value, "UNSPECIFIED ¬ 0"L, 1, Write]};      longNumber => {PutRecItem[i.value, "LONG UNSPECIFIED ¬ 0"L, 2, Write]};      number => {PutRecItem[i.value, "UNSPECIFIED ¬ 0"L, 1, Write]};      source => {PutRecItem[i.source, "TextSource.Handle ¬ NIL"L, 2, Write]};      string => {PutRecItem[i.string, "LONG STRING ¬ NIL"L, 2, Write]};      ENDCASE;    };  BuildDataRecord: PROCEDURE [    instance: SimpleDisplayer.DataHandle, Write: Format.StringProc] = {    recPtr ¬ instance.defaults.startingword;    Write[      "  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = MACHINE DEPENDENT RECORD ["L];    PutRecItem["msgSW"L, "Window.Handle ¬ NIL"L, 2, Write, TRUE];    PutRecItem["formSW"L, "Window.Handle ¬ NIL"L, 2, Write];    PutRecItem["fileSW"L, "Window.Handle ¬ NIL"L, 2, Write];    SimpleDisplayer.EnumerateItems[DoDataRecord, Write, instance];    Write["];\n\n"L];    };  firstEnum: BOOLEAN ¬ TRUE;  DoEnumType: PROC [    item: SimpleDisplayer.ItemHandle, Write: Format.StringProc,    instance: SimpleDisplayer.DataHandle ¬ NIL] = {    IF firstEnum THEN firstEnum ¬ FALSE ELSE Write[", "L]; Write[item.enumName]; };  BuildEnumType: PROCEDURE [    instance: SimpleDisplayer.DataHandle, Write: Format.StringProc] = {    firstEnum ¬ TRUE;    Write["  "L];    IF String.Length[instance.defaults.enumType] = 0 THEN      instance.defaults.enumType ¬ String.CopyToNewString[        "FormItems"L, SimpleDisplayer.zone];    Write[instance.defaults.enumType];    Write[": TYPE = {"L];    SimpleDisplayer.EnumerateItems[DoEnumType, Write, instance];    Write["};\n\n"L];    };  PutNullProc: PROC [s1, s2: LONG STRING, Write: Format.StringProc] = {    IF String.Length[s1] = 0 THEN RETURN;    IF String.EqualString[s1: s1, s2: "AnotherInstance"L] THEN RETURN;    IF String.EqualString[s1: s1, s2: "DestroyInstance"L] THEN RETURN;    Write["  "L];    Write[s1];    Write[":  "L];    Write[s2];    Write[      " = {\n    wh: Window.Handle ¬ ToolWindow.WindowForSubwindow[sw: sw];\n    instance: DataHandle = Lock[wh: wh];\n\n    Put.Line[instance.fileSW, \""L];    Write[s1];    Write[" called\"L];\n    UnLock[wh: wh]};\n\n"L];    };  DoNullProcs: PROC [    item: SimpleDisplayer.ItemHandle, Write: Format.StringProc,    instance: SimpleDisplayer.DataHandle ¬ NIL] = {    WITH i: item­ SELECT FROM      boolean => {PutNullProc[i.proc, "FormSW.NotifyProcType"L, Write]};      command => {PutNullProc[i.proc, "FormSW.ProcType"L, Write]};      enumerated => {        PutNullProc[i.proc, "FormSW.EnumeratedNotifyProcType"L, Write]};      longNumber => {        PutNullProc[i.proc, "FormSW.LongNumberNotifyProcType"L, Write]};      number => {PutNullProc[i.proc, "FormSW.NumberNotifyProcType"L, Write]};      source => {        PutNullProc[i.filterProc, "FormSW.FilterProcType"L, Write];        PutNullProc[i.menuProc, "FormSW.MenuProcType"L, Write]};      string => {        PutNullProc[i.filterProc, "FormSW.FilterProcType"L, Write];        PutNullProc[i.menuProc, "FormSW.MenuProcType"L, Write]};      ENDCASE;    };  WriteMonitoringProcs: PROCEDURE [    instance: SimpleDisplayer.DataHandle, Write: Format.StringProc] = {    Write[      "\n\n  << Instance data monitoring. >>\n\n  Lock: PROCEDURE [wh: Window.Handle] RETURNS [dataHandle: DataHandle] = INLINE {\n    RETURN Context.Acquire[type: "L];    Write[instance.defaults.handleName];    Write[      ".context, window: wh]};\n\n  Share: PROCEDURE [wh: Window.Handle] RETURNS [dataHandle: DataHandle] = INLINE {\n    RETURN Context.Find[type: "L];    Write[instance.defaults.handleName];    Write[      ".context, window: wh]};\n\n  UnLock: PROCEDURE [wh: Window.Handle] = INLINE {\n    Context.Release[type: "L];    Write[instance.defaults.handleName];    Write[".context, window: wh]};\n\n"L]};  WriteWindowMgmtProcs: PROCEDURE [    instance: SimpleDisplayer.DataHandle, Write: Format.StringProc] = {    Write[      "\n\n  << Window list management. >>\n\n  AddToList: ENTRY PROCEDURE [wh: Window.Handle] = {\n    ENABLE UNWIND => NULL;\n\n    "L];    Write[instance.defaults.handleName];    Write[".windows ¬ "L];    IF String.Length[instance.toolZone] = 0 THEN Write["zone"L]    ELSE Write[instance.toolZone];    Write[".NEW[WindowRecord ¬ [wh: wh, link: "L];    Write[instance.defaults.handleName];    Write[      ".windows]]};\n\n  LocateQuiescentTool: ENTRY PROCEDURE RETURNS [wh: Window.Handle] = {\n    ENABLE UNWIND => NULL;\n\n    wh ¬ NIL;\n    FOR w: WindowList ¬ "L];    Write[instance.defaults.handleName];    Write[      ".windows, w.link WHILE w # NIL DO\n      SELECT ToolWindow.GetState[w.wh] FROM\n\tactive => NULL;\n\tinactive => {\n\t  ToolWindow.Activate[w.wh];\n\t  wh ¬ w.wh;\n\t  RETURN};\n\ttiny => NULL;\n      ENDCASE;\n    ENDLOOP};\n\n  RemoveFromList: ENTRY PROCEDURE [wh: Window.Handle] = {\n    ENABLE UNWIND => NULL;\n\n    w: LONG POINTER TO WindowList;\n    FOR w ¬ @"L];    Write[instance.defaults.handleName];    Write[      ".windows, @w.link WHILE w­ # NIL DO\n      IF w.wh = wh THEN {\n\tflush: WindowList ¬ w­;\n\tw­ ¬ w.link;\n\t"L];    IF String.Length[instance.toolZone] = 0 THEN Write["zone"L]    ELSE Write[instance.toolZone];    Write[".FREE[@flush];\n\tRETURN};\n    ENDLOOP};\n\n"L];    };  BuildInitialProcs: PROCEDURE [    instance: SimpleDisplayer.DataHandle, Write: Format.StringProc] = {    Write[      "  << Initialization.  >>\n\n  Init: PROCEDURE = {\n    commandName: LONG STRING;\n\n    "L];    Write[instance.defaults.handleName];    Write[" ¬ "L];    IF String.Length[instance.toolZone] = 0 THEN Write["zone"L]    ELSE Write[instance.toolZone];    Write[      ".NEW[GlobalData ¬ [\n      context: Context.UniqueType[],\n      rootName: String.CopyToNewString[s: \""L];    Write[instance.root];    Write["\"L, z: "L];    IF String.Length[instance.toolZone] = 0 THEN Write["zone"L]    ELSE Write[instance.toolZone];    Write["]]];\n"L];    BuildNewString[      s1: "commandName"L, s2: "rootName"L, instance: instance, prepend2: TRUE,      longer: 2, Write: Write];    BuildAppendString[      s1: "commandName"L, s2: "\".~\"L"L, instance: instance, Write: Write];    Write[      "Exec.AddCommand[name: commandName, proc: RegisterCommand, help: HelpProc, unload: UnloadProc];\n    String.FreeString[z: "L];    IF String.Length[instance.toolZone] = 0 THEN Write["zone"L]    ELSE Write[instance.toolZone];    Write[", s: commandName];\n"L];    BuildNewString[      s1: "nameStripeName"L, s2: "rootName"L, instance: instance, prepend1: TRUE,      prepend2: TRUE, longer: 55, Write: Write];    BuildAppendString[      s1: "nameStripeName"L, s2: "\" of \""L, instance: instance, prepend1: TRUE,      Write: Write];    Write["Time.Append[s: "L];    Write[instance.defaults.handleName];    Write[      ".nameStripeName, unpacked: Time.Unpack[time: Runtime.GetBcdTime[]], zone: TRUE];\n    "L];    BuildAppendString[      s1: "nameStripeName"L, s2: "\" running on Pilot \""L, instance: instance,      prepend1: TRUE, Write: Write];    Write["Version.Append["L];    Write[instance.defaults.handleName];    Write[      ".nameStripeName];\n    };\n\n  RegisterCommand: Exec.ExecProc = {\n    wh: Window.Handle;\n    IF (wh ¬ LocateQuiescentTool[]) = NIL THEN wh ¬ CreateInstance[]};\n\n  HelpProc: Exec.ExecProc = {\n    };\n\n  UnloadProc: Exec.ExecProc = {\n    commandName: LONG STRING;\n    tempPtr: WindowList;\n\n"L];    BuildNewString[      s1: "commandName"L, s2: "rootName"L, instance: instance, prepend2: TRUE,      longer: 2, Write: Write];    BuildAppendString[      s1: "commandName"L, s2: "\".~\""L, instance: instance, Write: Write];    Write["h.RemoveCommand[name: commandName];\n    "L];    IF String.Length[instance.toolZone] = 0 THEN Write["zone"L]    ELSE Write[instance.toolZone];    Write[".FREE[@commandName];\n    WHILE (tempPtr ¬ "L];    Write[instance.defaults.handleName];    Write[".windows) # NIL DO\n      "L];    Write[instance.defaults.handleName];    Write[".windows ¬ "L];    Write[instance.defaults.handleName];    Write[      ".windows.link;\n      Tool.Destroy[window: tempPtr.wh];\n    ENDLOOP;\n    "L];    IF String.Length[instance.toolZone] = 0 THEN Write["zone"L]    ELSE Write[instance.toolZone];    Write[".FREE[@"L];    Write[instance.defaults.handleName];    Write["]"L];    IF String.Length[instance.toolZone] # 0 THEN {      Write[";\n    Heap.Delete[z: "L]; Write[instance.toolZone]; Write["]"L]};    Write["};\n\n"L];    };  BuildAppendString: PROCEDURE [    s1, s2: LONG STRING, instance: SimpleDisplayer.DataHandle,    Write: Format.StringProc, prepend1, prepend2: BOOLEAN ¬ FALSE,    inset: CARDINAL ¬ 4] = {    Write["String.AppendString[to: "L];    IF prepend1 THEN {Write[instance.defaults.handleName]; Write["."L]};    Write[s1];    Write[", from: "L];    IF prepend2 THEN {Write[instance.defaults.handleName]; Write["."L]};    Write[s2];    Write["];\n"L];    FOR count: CARDINAL IN [0..inset) DO Write[" "L] ENDLOOP;    };  BuildNewString: PROCEDURE [    s1, s2: LONG STRING, instance: SimpleDisplayer.DataHandle,    Write: Format.StringProc, prepend1, prepend2: BOOLEAN ¬ FALSE,    longer: CARDINAL ¬ 0, inset: CARDINAL ¬ 4] = {    FOR count: CARDINAL IN [0..inset) DO Write[" "L] ENDLOOP;    IF prepend1 THEN {Write[instance.defaults.handleName]; Write["."L]};    Write[s1];    Write[" ¬ String.CopyToNewString[s: "L];    IF prepend2 THEN {Write[instance.defaults.handleName]; Write["."L]};    Write[s2];    Write[", z: "L];    IF String.Length[instance.toolZone] = 0 THEN Write["zone"L]    ELSE Write[instance.toolZone];    IF longer # 0 THEN {Write[", longer: "L]; Format.Number[Write, longer, []]};    Write["];\n"L];    FOR count: CARDINAL IN [0..inset) DO Write[" "L] ENDLOOP;    };  BuildProcs: PROCEDURE [    instance: SimpleDisplayer.DataHandle, Write: Format.StringProc] = {    Write[      "\n\n<< Transitions. >>\n\n  ClientTransition: ToolWindow.TransitionProcType = {\n    SELECT TRUE FROM\n      old = inactive =>\n\t{instance: DataHandle = "L];    IF String.Length[instance.toolZone] = 0 THEN Write["zone"L]    ELSE Write[instance.toolZone];    Write[".NEW[Data ¬ []];\n\n\tContext.Create[type: "L];    Write[instance.defaults.handleName];    Write[      ".context, data: instance, proc: Context.NopDestroyProc, window: window]};\n      new = inactive =>\n\t{instance: DataHandle ¬ Share[window];\n\n\tContext.Destroy[type: "L];    Write[instance.defaults.handleName];    Write[".context, window: window];\n\t"L];    IF String.Length[instance.toolZone] = 0 THEN Write["zone"L]    ELSE Write[instance.toolZone];    Write[".FREE[@instance]};\n      ENDCASE;\n    };\n\n"L];    Write["\n\n<< FormSW invoked PROCEDURES. >>\n\n"L];    SimpleDisplayer.EnumerateItems[DoNullProcs, Write, instance];    };  BuildVariables: PROCEDURE [    instance: SimpleDisplayer.DataHandle, Write: Format.StringProc] = {    Write["  "L];    Write[instance.defaults.handleName];    Write[": GlobalDataHandle ¬ NIL;\n"L];    IF String.Length[instance.toolZone] = 0 THEN      Write["  zone: UNCOUNTED ZONE ¬ Heap.systemZone;\n\n"L]    ELSE {      Write["  "L];      Write[instance.toolZone];      Write[": UNCOUNTED ZONE ¬ Heap.Create[initial: 4, increment: 4];\n\n"L]};    };  firstArray: BOOLEAN ¬ TRUE;  enumCount: CARDINAL ¬ 0;  enumIndex: CARDINAL ¬ 0;  CountEnums: SimpleDisplayer.ChoiceProcType = {enumCount ¬ enumCount + 1};  WriteEnums: SimpleDisplayer.ChoiceProcType = {    IF first THEN Write["\n      "L]    ELSE IF even THEN Write[",\n      "L] ELSE Write[", "L];    Write["[\""L];    Write[s1];    Write["\"L, "L];    IF s2 = NIL THEN Format.Number[Write, enumIndex, []] ELSE Write[s2];    Write["]"L];    enumIndex ¬ enumIndex + 1;    };  BuildEnumArrays: PROC [    item: SimpleDisplayer.ItemHandle, Write: Format.StringProc,    instance: SimpleDisplayer.DataHandle ¬ NIL] = {    WITH vi: item­ SELECT FROM      enumerated => {        enumCount ¬ 0;        enumIndex ¬ 0;        EnumerateChoices[@vi, CountEnums, Write];        Write["    "L];        Write[vi.choiceName];        Write[": ARRAY[0.."L];        Format.Number[Write, enumCount, []];        Write[") OF Enumerated ¬ ["L];        EnumerateChoices[@vi, WriteEnums, Write];        Write["];\n"L];        };      ENDCASE;    };  BuildItems: PROC [    item: SimpleDisplayer.ItemHandle, Write: Format.StringProc,    instance: SimpleDisplayer.DataHandle] = {    Write["    items["L];    Write[instance.defaults.enumType];    Write["."L];    Write[item.enumName];    Write[".ORD] ¬ "L];    Write[      SELECT item.type FROM        boolean => "Boolean"L,        command => "Command"L,        enumerated => "Enumerated"L,        longNumber => "LongNumber"L,        number => "Number"L,        source => "Source"L,        string => "String"L,        ENDCASE => "TagOnly"L];    Write["Item[\n      tag: \""L];    Write[item.tag];    Write["\"L, place: ["L];    IF AnyFont THEN {      Write["CharPos["L];      Format.Number[Write, item.box.place.x / instance.charWidth, []];      Write["], "L]}    ELSE {Format.Number[Write, item.box.place.x, []]; Write[", "L]};    WriteY[item, instance, Write];    Write["]"L];    IF item.readOnly THEN Write[", readOnly: TRUE"L];    IF item.invisible THEN Write[", invisible: TRUE"L];    IF item.drawBox THEN Write[", drawBox: TRUE"L];    IF item.hasContext THEN Write[", hasContext: TRUE"L];    WITH vi: item­ SELECT FROM      boolean => FinishBoolean[item: @vi, write: Write];      command => FinishCommand[item: @vi, write: Write];      enumerated => FinishEnumerated[item: @vi, write: Write];      longNumber => FinishLongNumber[item: @vi, write: Write];      number => FinishNumber[item: @vi, write: Write];      source => FinishSource[item: @vi, write: Write];      string => FinishString[item: @vi, write: Write];      tagOnly => FinishTagOnly[item: @vi, write: Write];      ENDCASE;    IF String.Length[instance.toolZone] # 0 THEN {      Write[", z: "L]; Write[instance.toolZone]};    Write["];\n"L];    };  WriteY: PROC [    item: SimpleDisplayer.ItemHandle, instance: SimpleDisplayer.DataHandle,    Write: Format.StringProc] = {    line: CARDINAL ¬ item.box.place.y / instance.lineHeight;    IF line < 10 THEN {s: STRING ¬ "line0"L; s[4] ¬ '0 + line; Write[s]; }    ELSE {Write["LineN["L]; Format.Number[Write, line, []]; Write["]"L]; };    };  FinishBoolean: PUBLIC PROC [    item: LONG POINTER TO SimpleDisplayer.ItemObject.boolean, mesa: BOOLEAN ¬ TRUE,    write: Format.StringProc] = {    IF item.proc # NIL THEN {write[", proc: "L]; write[item.proc]};    IF item.switch # NIL THEN {      write[", switch: "L];      IF mesa THEN {write["@instance."L]};      write[item.switch]};    };  FinishCommand: PUBLIC PROC [    item: LONG POINTER TO SimpleDisplayer.ItemObject.command,    write: Format.StringProc] = {    IF item.proc # NIL THEN {write[", proc: "L]; write[item.proc]}; };  FinishEnumerated: PUBLIC PROC [    item: LONG POINTER TO SimpleDisplayer.ItemObject.enumerated,    mesa: BOOLEAN ¬ TRUE, write: Format.StringProc] = {    IF item.feedback = all THEN write[", feedback: all"L];    IF item.proc # NIL THEN {write[", proc: "L]; write[item.proc]};    IF ~item.copyChoices THEN write[", copyChoices: FALSE"L];    IF item.choiceName # NIL THEN      IF mesa THEN {        write[", choices: DESCRIPTOR["L]; write[item.choiceName]; write["]"L]}      ELSE {write[", choices: "L]; write[item.choiceName]};    IF item.value # NIL THEN {      write[", value: "L]; IF mesa THEN {write["@instance."L]}; write[item.value]};    };  FinishLongNumber: PUBLIC PROC [    item: LONG POINTER TO SimpleDisplayer.ItemObject.longNumber,    mesa: BOOLEAN ¬ TRUE, write: Format.StringProc] = {    IF ~item.signed THEN write[", signed: FALSE"L];    IF item.notNegative THEN write[", notNegative: TRUE"L];    IF item.radix = octal THEN write[", radix: octal"L];    IF item.boxWidth # 64 THEN {      write[", boxWidth: "L]; Format.Number[write, item.boxWidth, []]};    IF item.proc # NIL THEN {write[", proc: "L]; write[item.proc]};    IF item.default # LAST[LONG INTEGER] THEN {      write[", default: "L]; Format.LongNumber[write, item.default, []]};    IF item.value # NIL THEN {      write[", value: "L]; IF mesa THEN {write["@instance."L]}; write[item.value]};    IF item.bias # 0 THEN {      write[", bias: "L];      IF mesa THEN {write["@instance."L]};      Format.Number[write, item.bias, []]};    };  FinishNumber: PUBLIC PROC [    item: LONG POINTER TO SimpleDisplayer.ItemObject.number, mesa: BOOLEAN ¬ TRUE,    write: Format.StringProc] = {    IF ~item.signed THEN write[", signed: FALSE"L];    IF item.notNegative THEN write[", notNegative: TRUE"L];    IF item.radix = octal THEN write[", radix: octal"L];    IF item.boxWidth # 64 THEN {      write[", boxWidth: "L]; Format.Number[write, item.boxWidth, []]};    IF item.proc # NIL THEN {write[", proc: "L]; write[item.proc]};    IF item.default # LAST[INTEGER] THEN {      write[", default: "L]; Format.Number[write, item.default, []]};    IF item.value # NIL THEN {      write[", value: "L]; IF mesa THEN {write["@instance."L]}; write[item.value]};    IF item.bias # 0 THEN {      write[", bias: "L];      IF mesa THEN {write["@instance."L]};      Format.Number[write, item.bias, []]};    };  FinishSource: PUBLIC PROC [    item: LONG POINTER TO SimpleDisplayer.ItemObject.source,    write: Format.StringProc] = {    IF item.boxWidth # 0 THEN {      write[", boxWidth: "L]; Format.Number[write, item.boxWidth, []]};    IF item.filterProc # NIL THEN {      write[", filterProc: "L]; write[item.filterProc]};    IF item.menuProc # NIL THEN {write[", menuProc: "L]; write[item.menuProc]};    IF item.source # NIL THEN {write[", source: "L]; write[item.source]};    };  FinishString: PUBLIC PROC [    item: LONG POINTER TO SimpleDisplayer.ItemObject.string, mesa: BOOLEAN ¬ TRUE,    write: Format.StringProc] = {    IF item.feedback # normal THEN write[", feedback: password"L];    IF item.boxWidth # 0 THEN {      write[", boxWidth: "L]; Format.Number[write, item.boxWidth, []]};    IF item.inHeap THEN write[", inHeap: TRUE"L];    IF item.filterProc # NIL THEN {      write[", filterProc: "L]; write[item.filterProc]};    IF item.menuProc # NIL THEN {write[", menuProc: "L]; write[item.menuProc]};    IF item.string # NIL THEN {      write[", string: "L];      IF mesa THEN {write["@instance."L]};      write[item.string]};    };  FinishTagOnly: PUBLIC PROC [    item: LONG POINTER TO SimpleDisplayer.ItemObject.tagOnly,    write: Format.StringProc] = {    IF item.other # FormSW.nullIndex THEN {      write[", otherItem: "L]; Format.Number[write, item.other, []]};    };  BuildFormSW: PROCEDURE [    instance: SimpleDisplayer.DataHandle, Write: Format.StringProc] = {    firstArray ¬ TRUE;    Write[      "  << Tool creation/destruction.  >>\n\n  AnotherInstance: FormSW.ProcType = {\n      IF LocateQuiescentTool[] = NIL THEN [] ¬ CreateInstance[]};\n\n  CreateInstance: PROCEDURE RETURNS[wh: Window.Handle] = {\n    AddToList[wh: wh ¬ Tool.Create[\n      makeSWsProc: MakeSWs, initialState: default,\n      clientTransition: ClientTransition, name: "L];    Write[instance.defaults.handleName];    Write[".nameStripeName,\n      tinyName1: "L];    Write[instance.defaults.handleName];    Write[".tinyName1, tinyName2: "L];    Write[instance.defaults.handleName];    Write[".tinyName2,\n      cmSection: "L];    Write[instance.defaults.handleName];    Write[      ".rootName]]};\n\n  DestroyInstance: FormSW.ProcType ={\n    wh: Window.Handle = ToolWindow.WindowForSubwindow[sw: sw];\n\n    RemoveFromList[wh: wh];\n    Tool.Destroy[window: wh]};\n\n"L];    IF AnyFont THEN      Write[        "  charWidth: CARDINAL ¬ WindowFont.CharWidth['0];  CharPos: PROC[char: CARDINAL] RETURNS [x: INTEGER] = {    x ¬ charWidth * char};\n\n"L];    Write["  "L];    Write[instance.defaults.procName];    Write[      ": FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = "L];    Write[instance.defaults.enumType];    Write[      ".LAST.ORD + 1;\n    instance: DataHandle = Share[wh: ToolWindow.WindowForSubwindow[sw: sw]];\n"L];    SimpleDisplayer.EnumerateItems[BuildEnumArrays, Write, instance];    IF String.Length[instance.defaults.stuffString] # 0 THEN {      Write[instance.defaults.stuffString];      Write[        "\n    instance: DataHandle = Share[wh: ToolWindow.WindowForSubwindow[sw: sw]];\n"L]};    Write["    items ¬ AllocateItemDescriptor[nItems"L];    IF String.Length[instance.toolZone] # 0 THEN {      Write[", "L]; Write[instance.toolZone]};    Write["];\n"L];    SimpleDisplayer.EnumerateItems[BuildItems, Write, instance];    Write["    RETURN[items: items, freeDesc: TRUE];    };\n\n"L];    Write["  MakeSWs: Tool.MakeSWsProc = {\n  logName: LONG STRING ¬ ["L];    Format.Number[Write, instance.root.length + 4 + 3, []];    Write[      "];\n    instance: DataHandle = Share[wh: window];\n\n    Tool.UnusedLogName[unused: logName, root: \""L];    Write[instance.root];    Write[      ".log\"L];\n    instance.msgSW ¬ Tool.MakeMsgSW[window: window];\n    instance.formSW ¬ Tool.MakeFormSW[      window: window, formProc: "L];    Write[instance.defaults.procName];    IF String.Length[instance.toolZone] # 0 THEN {      Write[", zone: "L]; Write[instance.toolZone]};    Write[      "];\n    instance.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    };\n\n"L];    };  Finish: PROCEDURE [Write: Format.StringProc] = {    Write[      "  -- Mainline code  Init[];  -- this gets string out of global frame  }...    "L];    };  EnumerateChoices: PUBLIC PROC [    item: LONG POINTER TO SimpleDisplayer.ItemObject.enumerated,    proc: SimpleDisplayer.ChoiceProcType, Write: Format.StringProc] = {    even: BOOLEAN ¬ TRUE;    first: BOOLEAN ¬ TRUE;    FOR i: SimpleDisplayer.ChoicePtr ¬ item.choiceList, i.next UNTIL i = NIL DO      IF i.a # NIL THEN {        proc[i.a, i.b, even, Write, first];        even ¬ ~even;        IF first THEN first ¬ FALSE};      ENDLOOP;    };  }...    LOG  DEG     	22-Feb-84  0:22:43  
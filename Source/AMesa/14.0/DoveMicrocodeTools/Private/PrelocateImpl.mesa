--PrelocateImpl.mesa--created by: JoM     3-Jul-85 10:10:37-- Copyright (C) 1985 by Xerox Corporation. All rights reserved.DIRECTORY  Ascii USING [CR, NUL, SP, TAB],  Exec USING [AddCommand, CheckForAbort, ExecProc, GetChar, MatchPattern, OutputProc],  Heap USING [Create, Delete],  Format USING [Line, LongNumber, StringProc, Text],  MStream USING [EndOf, Error, Handle, ReadOnly, WriteOnly],  Stream USING [Delete, GetChar, PutChar, PutString],  String USING [AppendCharAndGrow, AppendExtensionIfNeeded, CopyToNewString, Equivalent];PrelocateImpl: PROGRAM IMPORTS Exec, Format, Heap, MStream, Stream, String =BEGIN-- TYPEsAlignment: TYPE = {absolute, byte, word, paragraph, page};CommandPtr: TYPE = LONG POINTER TO CommandRec;CommandRec: TYPE = RECORD[ next: CommandPtr ¬ NIL,  direction: Direction ¬ up,  address: LONG CARDINAL ¬ 0,  list: ListPtr ¬ NIL ];Direction: TYPE = {up, down};ListPtr: TYPE = LONG POINTER TO ListRec;ListRec: TYPE = RECORD[ next: ListPtr ¬ NIL,  colocateNext: BOOLEAN ¬ FALSE,  listEntry: SELECT listType: * FROM    std =>    [ matchName: LONG STRING ¬ NIL ],    group =>    [ firstInGroup: ListPtr ¬ NIL ],    ENDCASE ];SegmentPtr: TYPE = LONG POINTER TO SegmentRec;SegmentRec: TYPE = RECORD[ next: SegmentPtr ¬ NIL,  name: LONG STRING ¬ NIL,  class: LONG STRING ¬ NIL,  alignment: Alignment ¬ byte,  inpage: BOOLEAN ¬ FALSE,  located: BOOLEAN ¬ FALSE,  inList: BOOLEAN ¬ FALSE,  address: LONG CARDINAL ¬ 0,  length: LONG CARDINAL ¬ 0 ];-- constantsalignmentChar: ARRAY Alignment OF CHARACTER =[ 'A, 'B, 'W, 'G, 'P ];alignmentModulus: ARRAY Alignment OF CARDINAL =[ 1, 1, 2, 16, bytesPerPage ];bytesPerPage: CARDINAL = 512;lengthField: CARDINAL = 1;lengthExtent: CARDINAL = 4;addressField: CARDINAL = 7;addressExtent: CARDINAL = 5;addressCheck: CARDINAL = 12;alignmentField: CARDINAL = 17;inpageField: CARDINAL = 18;nameContCheck: CARDINAL = 21;nameField: CARDINAL = 22;classContCheck: CARDINAL = 37;classField: CARDINAL = 38;minimumLineLength: CARDINAL = 53;-- PROCsExecCalling: Exec.ExecProc =   BEGIN  zone: UNCOUNTED ZONE ¬ Heap.Create [4];  BEGIN ENABLE UNWIND => Heap.Delete [zone];  output: Format.StringProc ¬ Exec.OutputProc [h];  token: LONG STRING ¬ zone.NEW [StringBody[40]];  workChar: CHARACTER;  nextChar, delimiter: CHARACTER ¬ Ascii.SP;  inStream, outStream: MStream.Handle;  segmentHead: SegmentPtr ¬ NIL;  segmentTail: LONG POINTER TO SegmentPtr ¬ @segmentHead;  workSegPtr: SegmentPtr ¬ NIL;  commandHead: CommandPtr ¬ NIL;  commandTail: LONG POINTER TO CommandPtr ¬ @commandHead;  workCmdPtr: CommandPtr ¬ NIL;  firstLocate: BOOLEAN ¬ TRUE;  AdjustSizes: PROC =    BEGIN    firstAdjust: BOOLEAN ¬ TRUE;    UNTIL delimiter = ') OR delimiter = Ascii.NUL DO      adjustment: LONG CARDINAL;      adjType: {null, add, subtract, replace} ¬ null;      ParseToken [];      IF token.length = 0 THEN LOOP;      FindSegment [];      SELECT delimiter FROM	'+ =>	  BEGIN	  adjType ¬ add;	  ParseToken []	  END;	'- =>	  BEGIN	  adjType ¬ subtract;	  ParseToken []	  END;	'= =>	  BEGIN	  adjType ¬ replace;	  ParseToken []	  END;	ENDCASE => LOOP;      adjustment ¬ GetHex [0, token.length];      IF workSegPtr # NIL THEN	BEGIN	workSegPtr.length ¬ (SELECT adjType FROM	  add => workSegPtr.length + adjustment,	  subtract => workSegPtr.length - adjustment,	  ENDCASE => adjustment);	IF NOT firstAdjust THEN Stream.PutChar [outStream, ',] ELSE	  BEGIN	  Stream.PutString [outStream, "-SEGSIZE("L];	  firstAdjust ¬ FALSE	  END;	Stream.PutString [outStream, workSegPtr.name];	Stream.PutString [outStream, "(0"L];	Format.LongNumber [PutString, workSegPtr.length, [base: 16] ];	Stream.PutString [outStream, "H)"L];	Format.Text [output, workSegPtr.name];	Format.Text [output, " changed length to "L];	Format.LongNumber [output, workSegPtr.length, [base: 16] ];	Format.Line [output, "H"L]	END;    ENDLOOP;    IF NOT firstAdjust THEN Stream.PutString [outStream, ") "L];    END;  BuildList: PROC RETURNS [listHead: ListPtr ¬ NIL] =    BEGIN    listTail: LONG POINTER TO ListPtr ¬ @listHead;    workListPtr: ListPtr ¬ NIL;    UNTIL delimiter = ') OR delimiter = Ascii.NUL DO      ParseToken [];      IF token.length # 0 THEN        BEGIN	workListPtr ¬ zone.NEW [std ListRec ¬ [NIL, (delimiter = '|), std[String.CopyToNewString [token, zone] ] ] ];	listTail­ ¬ workListPtr;	listTail ¬ @workListPtr.next;	FindSegment [];	IF workSegPtr # NIL THEN workSegPtr.inList ¬ TRUE;	END	ELSE IF delimiter = '| AND workListPtr # NIL	  THEN workListPtr.colocateNext ¬ TRUE;      IF delimiter = '( THEN        BEGIN	workListPtr ¬ zone.NEW [group ListRec ¬ [NIL, FALSE, group[BuildList [] ] ] ];	listTail­ ¬ workListPtr;	listTail ¬ @workListPtr.next	END;    ENDLOOP    END;  FindSegment: PROC =    {FOR workSegPtr ¬ segmentHead, workSegPtr.next      UNTIL workSegPtr = NIL OR String.Equivalent [token, workSegPtr.name] DO    ENDLOOP};  GetHex: PROC [start, extent: CARDINAL] RETURNS [number: LONG CARDINAL ¬ 0] =    {FOR i: CARDINAL IN [start .. (start + extent)) DO      workChar ¬ token[i];      SELECT workChar FROM        IN ['0 .. '9] => number ¬ 16 * number + (workChar - '0);	IN ['A .. 'F] => number ¬ 16 * number + (workChar - 'A + 10);	ENDCASE => EXIT    ENDLOOP};  GetLine: PROC =    BEGIN    token.length ¬ 0;    UNTIL MStream.EndOf [inStream] DO      workChar ¬ Stream.GetChar [inStream];      SELECT workChar FROM        Ascii.CR => RETURN;	012C, 014C => NULL;	ENDCASE => String.AppendCharAndGrow [@token, workChar, zone]    ENDLOOP    END;  LocateSegments: PROC [list: ListPtr, start: LONG CARDINAL, dir: Direction] RETURNS [end: LONG CARDINAL] =    BEGIN    end ¬ start;    UNTIL list = NIL DO      WITH list SELECT FROM        std =>	  BEGIN	  workAddr: LONG CARDINAL ¬ start;	  FOR workSegPtr ¬ segmentHead, workSegPtr.next UNTIL workSegPtr = NIL DO	    IF NOT workSegPtr.located AND	      (IF workSegPtr.inList	        THEN String.Equivalent [workSegPtr.name, matchName]		ELSE (MatchPattern [workSegPtr.name, matchName] OR		  MatchPattern [workSegPtr.class, matchName])) THEN	      BEGIN	      workModulus: CARDINAL = alignmentModulus[workSegPtr.alignment];	      IF dir = up THEN	        BEGIN		workAdj: LONG CARDINAL = (workAddr MOD workModulus);		IF workAdj > 0 THEN workAddr ¬ workAddr + (workModulus - workAdj);		IF workSegPtr.inpage AND		  ((workAddr MOD bytesPerPage) + workSegPtr.length) > bytesPerPage		  THEN workAddr ¬ workAddr + (bytesPerPage - (workAddr MOD bytesPerPage));		workSegPtr.address ¬ workAddr;		workAddr ¬ workAddr + workSegPtr.length		END ELSE		BEGIN		workAddr ¬ workAddr - workSegPtr.length;		workAddr ¬ workAddr - (workAddr MOD workModulus);		IF workSegPtr.inpage AND		  ((workAddr MOD bytesPerPage) + workSegPtr.length) > bytesPerPage		  THEN workAddr ¬ workAddr + (bytesPerPage - (workAddr MOD bytesPerPage) - workSegPtr.length);		workSegPtr.address ¬ workAddr		END;	      workSegPtr.located ¬ TRUE;	      IF firstLocate THEN	        BEGIN		Stream.PutString [outStream, "-ADDRESSES(SEGMENTS("L];		firstLocate ¬ FALSE		END ELSE		BEGIN		Stream.PutString [outStream, ",-"L];		Stream.PutChar [outStream, Ascii.CR]		END;	      Stream.PutString [outStream, workSegPtr.name];              Stream.PutString [outStream, "(0"L];              Format.LongNumber [PutString, workSegPtr.address, [base: 16] ];              Stream.PutString [outStream, "H)"L];              Format.Text [output, workSegPtr.name];              Format.Text [output, " located at "L];              Format.LongNumber [output, workSegPtr.address, [base: 16] ];              Format.Line [output, "H"L]	      END;	  ENDLOOP;	  end ¬ (IF dir = up THEN MAX [end, workAddr] ELSE MIN [end, workAddr])	  END;	group =>	  BEGIN	  workEnd: LONG CARDINAL ¬ LocateSegments [firstInGroup, start, dir];	  end ¬ (IF dir = up THEN MAX [end, workEnd] ELSE MIN [end, workEnd])	  END;	ENDCASE;      IF NOT list.colocateNext THEN start ¬ end;      list ¬ list.next    ENDLOOP    END;  MatchPattern: PROC [s1, s2: LONG STRING] RETURNS [BOOLEAN] = INLINE    {RETURN [(IF s1 = NIL OR s2 = NIL THEN FALSE      ELSE Exec.MatchPattern [s1, s2])]};  ParseToken: PROC =    BEGIN    scanMode: {pre, token, post} ¬ pre;    IF nextChar = Ascii.SP THEN delimiter ¬ Exec.GetChar [h] ELSE      BEGIN      delimiter ¬ nextChar;      nextChar ¬ Ascii.SP      END;    token.length ¬ 0;    DO      SELECT delimiter FROM        IN ['0 .. '9], IN ['A .. 'Z], IN ['a .. 'z], '., '*, '# => IF scanMode # post THEN	  BEGIN	  String.AppendCharAndGrow [@token, delimiter, zone];	  scanMode ¬ token	  END ELSE	  BEGIN	  nextChar ¬ delimiter;	  delimiter ¬ Ascii.SP;	  RETURN	  END;	Ascii.CR, Ascii.SP, Ascii.TAB => IF scanMode # pre THEN scanMode ¬ post;	ENDCASE => RETURN;      delimiter ¬ Exec.GetChar [h]    ENDLOOP    END;  PutString: Format.StringProc = {Stream.PutString [outStream, s]};  ParseToken [];  [] ¬ String.AppendExtensionIfNeeded [@token, "MP1"L, zone];  Format.Text [output, "Examining "L];  Format.Line [output, token];  inStream ¬ MStream.ReadOnly [token, [] !    MStream.Error =>      BEGIN      Format.Line [output, "can't read input file"L];      GOTO errorExit      END ];  FOR i: CARDINAL DECREASING IN [0 .. token.length) DO    IF token[i] = '. THEN      BEGIN      token.length ¬ i;      EXIT      END;  ENDLOOP;  [] ¬ String.AppendExtensionIfNeeded [@token, "COM"L, zone];  Format.Text [output, "Creating "L];  Format.Line [output, token];  outStream ¬ MStream.WriteOnly [token, [], text !    MStream.Error =>      BEGIN      Format.Line [output, "can't write output file"L];      Stream.Delete [inStream];      GOTO errorExit      END ];  token.length ¬ token.length - 3;  Stream.PutString [outStream, "$LOC86 "L];  Stream.PutString [outStream, token];  Stream.PutString [outStream, "LNK "L];  DO    IF Exec.CheckForAbort [h] THEN      BEGIN      Stream.Delete [inStream];      Stream.Delete [outStream];      GOTO abortExit      END;    IF MStream.EndOf [inStream] THEN      BEGIN      Format.Line [output, "input file has bad format"L];      Stream.Delete [inStream];      Stream.Delete [outStream];      GOTO errorExit      END;    GetLine [];    IF String.Equivalent [token, "LENGTH ADDRESS ALIGN  SEGMENT         CLASS           OVERLAY"L] THEN EXIT;  ENDLOOP;  DO    IF Exec.CheckForAbort [h] THEN      BEGIN      Stream.Delete [inStream];      Stream.Delete [outStream];      GOTO abortExit      END;    GetLine [];    IF token.length < minimumLineLength THEN EXIT;    IF workSegPtr = NIL OR      (token[nameContCheck] # '- AND token[classContCheck] # '-) THEN      BEGIN      workSegPtr ¬ zone.NEW [SegmentRec ¬ [] ];      FOR align: Alignment IN Alignment DO	IF alignmentChar[align] = token[alignmentField] THEN	  BEGIN	  workSegPtr.alignment ¬ align;	  EXIT	  END;      ENDLOOP;      workSegPtr.inpage ¬ (token[inpageField] = 'R);      IF token[addressCheck] = 'H THEN	BEGIN	workSegPtr.address ¬ GetHex [addressField, addressExtent];	workSegPtr.located ¬ TRUE	END;      IF (workSegPtr.length ¬ GetHex [lengthField, lengthExtent]) > bytesPerPage        THEN workSegPtr.inpage ¬ FALSE;      segmentTail­ ¬ workSegPtr;      segmentTail ¬ @workSegPtr.next      END;    FOR i: CARDINAL ¬ nameField, i + 1 UNTIL token[i] = Ascii.SP DO      String.AppendCharAndGrow [@workSegPtr.name, token[i], zone]    ENDLOOP;    FOR i: CARDINAL ¬ classField, i + 1 UNTIL token[i] = Ascii.SP DO      String.AppendCharAndGrow [@workSegPtr.class, token[i], zone]    ENDLOOP  ENDLOOP;  Stream.Delete [inStream];  UNTIL delimiter = Ascii.NUL DO    IF Exec.CheckForAbort [h] THEN      BEGIN      Stream.Delete [outStream];      GOTO abortExit      END;    ParseToken [];    SELECT TRUE FROM      String.Equivalent [token, "UP"L] =>        BEGIN	workCmdPtr ¬ zone.NEW [CommandRec ¬ [] ];	ParseToken [];	IF String.Equivalent [token, "FROM"L] THEN ParseToken [];	END;      String.Equivalent [token, "DOWN"L] =>        BEGIN	workCmdPtr ¬ zone.NEW [CommandRec ¬ [direction: down] ];	ParseToken [];	IF String.Equivalent [token, "FROM"L] THEN ParseToken [];	END;      String.Equivalent [token, "AT"L] =>        BEGIN	workCmdPtr ¬ zone.NEW [CommandRec ¬ [] ];	ParseToken [];	END;      String.Equivalent [token, "SIZE"L] =>        BEGIN	IF delimiter = '( THEN AdjustSizes [];	LOOP	END;      ENDCASE =>        BEGIN	Stream.PutString [outStream, token];	IF delimiter # Ascii.NUL THEN Stream.PutChar [outStream, delimiter];	LOOP	END;    commandTail­ ¬ workCmdPtr;    commandTail ¬ @workCmdPtr.next;    IF token.length > 0 AND token[0] IN ['0 .. '9]      THEN workCmdPtr.address ¬ GetHex [0, token.length] ELSE      BEGIN      FindSegment [];      IF workSegPtr # NIL AND workSegPtr.located        THEN workCmdPtr.address ¬ (IF workCmdPtr.direction = up	  THEN (workSegPtr.address + workSegPtr.length)	  ELSE workSegPtr.address);      END;    IF delimiter = '( THEN workCmdPtr.list ¬ BuildList [];  ENDLOOP;  FOR workCmdPtr ¬ commandHead, workCmdPtr.next UNTIL workCmdPtr = NIL DO    [] ¬ LocateSegments [workCmdPtr.list, workCmdPtr.address, workCmdPtr.direction]  ENDLOOP;  IF NOT firstLocate THEN Stream.PutString [outStream, "))"L];  Stream.PutChar [outStream, Ascii.CR];  Stream.Delete [outStream];  FOR workSegPtr ¬ segmentHead, workSegPtr.next UNTIL workSegPtr = NIL DO    IF Exec.CheckForAbort [h] THEN      BEGIN      Stream.Delete [outStream];      GOTO abortExit      END;    IF NOT workSegPtr.located AND workSegPtr.length > 0 THEN      BEGIN      Format.Text [output, "Warning: segment "L];      Format.Text [output, workSegPtr.name];      Format.Line [output, " not located"L]      END;  ENDLOOP;  EXITS    abortExit => outcome ¬ abort;    errorExit => outcome ¬ error;  END;  Heap.Delete [zone]  END; -- of ExecCalling  Register: PROC = {Exec.AddCommand ["Prelocate.~"L, ExecCalling]};-- main code  Register [];  END.  3-Jul-85 -- JoM     -- Created.
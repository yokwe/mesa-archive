-- Module to write and then read state information for Prom Blowing-- File: PromBlowOps.mesa-- Last edited by PaD  DXS : June 5, 1979  12:20 PM-- Last edited by Roy RXO : August 26, 1979  4:47 PM-- Last edited by Frank FXB      11-Aug-83 12:02:54-- Last edited by Frank FXB    30-Oct-84 14:30:18DIRECTORY  Exec USING [ Handle, OutputProc],  Environment USING [Byte],  Format USING [CR, NumberFormat, Number, Line, StringProc],  Heap USING [Create, Delete],  Inline USING [BITSHIFT],  MFile USING [Error],  MStream USING [Handle, WriteOnly, Error],  Stream USING [Block, Delete, PutBlock, PutString, PutWord],  String USING [AppendString, AppendExtensionIfNeeded],  PromBlow USING [];PromBlowImpl: PROGRAM		IMPORTS  Heap, String, Inline, Format, Exec, Stream, MStream, MFile		EXPORTS PromBlow ={ OPEN Format, Heap, Exec;z: UNCOUNTED ZONE _ NIL;CreateStorage: PROC = {z _ Heap.Create[initial: 1]; };DestroyStorage: PROC = {Heap.Delete[z]; z _ NIL; };NoPromFile: PUBLIC SIGNAL = CODE;WritePromData: PUBLIC PROCEDURE			[Name: LONG STRING, memSize, dataWidth: CARDINAL, ptr: LONG POINTER, h: Exec.Handle] =  { OPEN Exec, Stream, String, Inline, MStream, MFile;    Write: Format.StringProc = Exec.OutputProc[h];    OutProc: Format.StringProc = {Stream.PutString[PromStream, s]};      FileName: LONG STRING _ [32];    PromStream: MStream.Handle;    BlockLength: CARDINAL _ 2 * memSize;    PromArray: Stream.Block _ [blockPointer: LOOPHOLE[ptr, LONG POINTER TO PACKED ARRAY [0..0) OF Environment.Byte], startIndex: 0, stopIndexPlusOne: BlockLength];    Write ["Writing Prom data . . . . . ."];    AppendString [FileName, Name];    CreateStorage;    [] _ AppendExtensionIfNeeded [@FileName, ".prom"L, z];    DestroyStorage;    PromStream _ MStream.WriteOnly[name: FileName, release: [], type: text!       MStream.Error => Format.Line[Write, "MStream Error"L];       MFile.Error => Format.Line[Write, "MFile Error"L]];    Stream.PutWord [PromStream, dataWidth];    Stream.PutWord [PromStream,  memSize];    Stream.PutBlock [PromStream, PromArray];    Stream.Delete [PromStream];    Format.Line[Write,"Done."];  };WritePromList: PUBLIC PROCEDURE			[Name: LONG STRING, addressWidth, dataWidth: CARDINAL, ptr: LONG POINTER, h: Exec.Handle] =  { OPEN Format, MStream, Stream, String, Inline;    Write: Format.StringProc = Exec.OutputProc[h];    OutProc: Format.StringProc = {Stream.PutString[ListStream, s]};    FileName:  LONG STRING _ [120];    ListStream: MStream.Handle;    hexNumber: NumberFormat = [16, FALSE, TRUE, 6];    binaryAddress: NumberFormat = [2, TRUE, TRUE, LOOPHOLE[addressWidth]];  -- up to 16 bits)    binaryData: NumberFormat = [2, TRUE, TRUE, LOOPHOLE[dataWidth]];  -- up to 16 bits)    i, data: CARDINAL;        Write ["Writing Prom list . . . . . ."];    AppendString [FileName, Name];    CreateStorage;    [] _ AppendExtensionIfNeeded [@FileName, ".pls"L, z];    DestroyStorage;    ListStream _ MStream.WriteOnly[name: FileName, release: [], type: text!       MStream.Error => Format.Line[Write, "MStream Error"L];       MFile.Error => Format.Line[Write, "MFile Error"L]];    AppendString [FileName, ": Prom listing in hexadecimal and binary"L];    AppendString [FileName, " (Address | data data data data)"L];    PutString [ListStream, FileName];  -- Write header    Format.CR [OutProc];  Format.CR [OutProc];       --  Now write in prom contents.    FOR i IN [0..BITSHIFT[1, addressWidth])  DO      SELECT i MOD 4 FROM  --  Print 4 values to a line        0  =>          {            Number [OutProc, i, hexNumber];  -- address            PutString [ListStream, " ("];            Number [OutProc, i, binaryAddress];            PutString [ListStream, ")  | "];            data _ BITSHIFT [ptr^, -(16 - dataWidth)];  -- right justify data            Number [OutProc, data, hexNumber];            PutString [ListStream, "  ("];            Number [OutProc, data, binaryData];            PutString [ListStream, ")"];            ptr _ ptr + 1;          };        1, 2  =>          {            PutString [ListStream, " "];  -- separate entries            data _ BITSHIFT [ptr^, -(16 - dataWidth)];  -- right justify data            Number [OutProc, data, hexNumber];            PutString [ListStream, " ("];            Number [OutProc, data, binaryData];            PutString [ListStream, ")"];            ptr _ ptr + 1;          };        3  =>          {            PutString [ListStream, " "];  -- separate entries            data _ BITSHIFT [ptr^, -(16 - dataWidth)];  -- right justify data            Number [OutProc, data, hexNumber];            PutString [ListStream, " ("];            Number [OutProc, data, binaryData];            PutString [ListStream, ")"];            Format.CR [OutProc];            ptr _ ptr + 1;          };        ENDCASE;    ENDLOOP;    Format.CR [OutProc];  -- in case there was not 4 entries in last line    Delete[ListStream];    Format.Line[Write,"Done."];  };}.
-- Copyright (C) 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- MakeBermudaGerm.mesa    	  6-Nov-84 15:51:20 by RdH       -- from MakeBurdockGermDove.mesa  5-Oct-84 15:42:22 by RdH       -- from MakeBurdockGerm.mesa     26-Sep-84 16:27:39 by DEG     <<This program produces a real memory image file of a germ, suitable for using with the Bermuda Real Memory Load command.The real memory image contains the initial memory map, the germ, and the unused real memory. Note that the Boot.Request that the invoker of the germ must supply is also written into the germ's memory.This program reads an germ boot file, as produced by MakeBoot, and produces PilotDove128kb.germRM, PilotDove640kb.germRM, PilotDove1152kb.germRM, on through PilotDove4224kb.germRM in 512KByte increments. It runs under the Exec.Command line to the Exec:    >MakeBermudaGerm.~ Dove.germIf no input germ file name is given, Dove.germ is assumed.See RMRecordFormat below for the format of the records in the real memory file. The file is terminated by a record with length=0.>>DIRECTORY  Boot,  DeviceTypes,  DoveInputOutput,  Environment,  Exec,  Heap,  Inline,  MStream,  Stream,  String,  System,  TTY;MakeBermudaGerm: PROGRAM  IMPORTS Environment, Exec, Heap, Inline, MStream, Stream, String, TTY =  BEGIN OPEN DIO: DoveInputOutput;--Types & Parameters for Bermuda'a real memory format.  RMRecordFormat: TYPE = MACHINE DEPENDENT RECORD [    -- The format wanted by Bermuda.    length: CARDINAL,    realAddressHigh: WORD,  -- High order bits of real memory address    realAddressLow: WORD,  -- Low order bits of real memory address    data: ARRAY [0..0) OF WORD];  -- actually [0..length)      eofRecord: RMRecordFormat ¬ [    length: 0, realAddressHigh: 0, realAddressLow: 0, data: NULL];  defRealAddrOffset: LONG INTEGER = 20000H;   -- IOP and Bermuda have an offset view of memory relative to the Mesa world.  -- A constant can be added to the real address fields of the RMRecordFormat  --   to make sense to Bermuda.      RealAddress: TYPE = LONG CARDINAL;  RealPageCount: TYPE = DIO.RealPageNumber;  -- types and constants for the dove memory map.   maxRealMemPages: CARDINAL = 2000H; -- 2 ** 13 --  mapWordRealModulus: CARDINAL = 256;  MapWordLow: TYPE = [0..mapWordRealModulus);  MapWordRealHigh: TYPE = [0..32);  DoveMapWord: TYPE = MACHINE DEPENDENT RECORD [    realLow: MapWordLow,    referenced: BOOLEAN,    dirty: BOOLEAN,    writeProt: BOOLEAN,    realHigh: MapWordRealHigh];  -- Dove memory map entry for a virtual page.  Note that the flags are in a different order than that defined by Pilot in PageMap.  These correspond to Dove hardware.  vacant: DoveMapWord = [    realLow: 0, referenced: FALSE, dirty: TRUE, writeProt: TRUE, realHigh: 0];  -- dirty and writeProtected and not referenced represent vacant.-- types and constants for describing memory configuration    maxRMHoles: CARDINAL = 20;    RMConfig: TYPE = RECORD[    offset: LONG INTEGER,    lowestRealPage, highestRealPage: CARDINAL,    displayReserved: BOOLEAN,    displayStart: DIO.RealPageNumber,    displayLength: RealPageCount,    memMapStart: DIO.RealPageNumber,    memMapLength: RealPageCount,    ioRegionExists: BOOLEAN,    ioRegionVirtStart: Environment.PageNumber,    ioRegionRealStart: DIO.RealPageNumber,    ioRegionLength: RealPageCount,    numberOfHoles: CARDINAL,    rmHoles: ARRAY[0..maxRMHoles) OF RECORD[      holeStart: DIO.RealPageNumber,      holeLength: RealPageCount      ]    ];    FileSpecs: TYPE = RECORD[    rmConfig: RMConfig,    wantBootRequest: BOOLEAN    ];    --Some of these should eventually depend on DoveInputOutput  defRMConfig: RMConfig = [     offset: 0,    lowestRealPage: 0,    highestRealPage: 7FFH,    displayReserved: TRUE,    displayStart: 400H,    displayLength: 200H,    memMapStart: 0,    memMapLength: 100H,    ioRegionExists: TRUE,    ioRegionVirtStart: 1200H,  -- totally arbitrary    ioRegionRealStart: 240H,    ioRegionLength: 20,  -- totally arbitrary    numberOfHoles: 0,    rmHoles: ALL[[holeStart: 0, holeLength: 0]]    ];      defFileSpecs: FileSpecs = [    rmConfig: defRMConfig,    wantBootRequest: TRUE    ];    -- Layout of virtual memory:    pageGermMDS: Environment.PageNumber =    Boot.mdsiGerm * Environment.maxPagesInMDS;  firstGermVirtPage: Environment.PageNumber = pageGermMDS + Boot.pageGerm;  wordsPerPage: CARDINAL = Environment.wordsPerPage;  WordOfPage: TYPE = [0..wordsPerPage);  PageOfData: TYPE = ARRAY WordOfPage OF WORD;    --***************************************************************************--Run: Exec.ExecProc --[h: Exec.Handle, clientData]--  = BEGIN      given, switches: LONG STRING;  actualInputFileName: LONG STRING;  actualOutputFileName: LONG STRING;  tty: TTY.Handle = Exec.GetTTY[h];  defaultInputFileNameEnd: LONG STRING = ".germ"L;  defaultOutputFileNameEnd: LONG STRING = ".germRM"L;  firstNum, secondNum: CARDINAL;  nArgsOnSwitch: CARDINAL;  fileSpec: FileSpecs;      --process switches.  SetDefaults[config: @fileSpec, inFile: @actualInputFileName, outFile: @actualOutputFileName, stringSource: Heap.systemZone];  [given, switches] ¬ Exec.GetToken[h];  BEGIN    ENABLE BEGIN      Error => BEGIN TTY.PutLine[tty, msg]; GOTO paramErr; END;      UNWIND => BEGIN         given ¬ Exec.FreeTokenString[given];	switches ¬ Exec.FreeTokenString[switches];	String.FreeString[z: Heap.systemZone, s: actualInputFileName];	String.FreeString[z: Heap.systemZone, s: actualOutputFileName];	END;      END;    WHILE String.Length[switches] > 0 DO      SELECT switches[0] FROM        'i => BEGIN	  String.FreeString[z:Heap.systemZone, s: actualInputFileName];	  actualInputFileName ¬ String.CopyToNewString[s: given, z: Heap.systemZone];	  String.AppendStringAndGrow[to: @actualInputFileName, z: Heap.systemZone, from: defaultInputFileNameEnd];	  END;	'I => BEGIN	  String.FreeString[z:Heap.systemZone, s: actualInputFileName];	  actualInputFileName ¬ String.CopyToNewString[s: given, z: Heap.systemZone];	  END;	'o => BEGIN	  String.FreeString[z:Heap.systemZone, s: actualOutputFileName];	  actualOutputFileName ¬ String.CopyToNewString[s: given, z: Heap.systemZone];	  String.AppendStringAndGrow[to: @actualOutputFileName, z: Heap.systemZone, from: defaultOutputFileNameEnd];	  END;	'O => BEGIN	  String.FreeString[z:Heap.systemZone, s: actualOutputFileName];	  actualOutputFileName ¬ String.CopyToNewString[s: given, z: Heap.systemZone];	  END;	's,'S => BEGIN --memory Size	  --If there is one arg that is taken to be the highest page number of 	  --real memory and 0 is assumed for the lowest.  If there are two the 	  --first is taken to be the start of real memory while the second is	  --then taken to be the highest page number.	  [firstNum, secondNum, nArgsOnSwitch] ¬ GetNumPair[argPair: given, stringSouce: Heap.systemZone ! ConvError => Error["Bad argument to /s switch"L]];	  IF nArgsOnSwitch = 1 THEN BEGIN	    fileSpec.rmConfig.lowestRealPage ¬ 0;	    fileSpec.rmConfig.highestRealPage ¬ firstNum;	    END ELSE IF nArgsOnSwitch = 2 THEN BEGIN	    fileSpec.rmConfig.lowestRealPage ¬ firstNum;	    fileSpec.rmConfig.highestRealPage ¬ secondNum;	    END ELSE BEGIN	    Error["Bad args on /s switch"L];	    END;	  IF fileSpec.rmConfig.highestRealPage >= maxRealMemPages THEN BEGIN	    Error["Too many real pages."L];	    END;	  END;	'd,'D => BEGIN --Display	  --If there is one arg that is taken to be the start of display.	  --If there are two the second is taken to be the length of display.	  --Otherwise they default to DoveInputOutput.	  fileSpec.rmConfig.displayReserved ¬ TRUE;	  [firstNum, secondNum, nArgsOnSwitch] ¬ GetNumPair[argPair: given, stringSouce: Heap.systemZone ! ConvError => Error["Bad argument to /d switch"L]];	  IF nArgsOnSwitch >= 1 THEN fileSpec.rmConfig.displayStart ¬ firstNum;	  IF nArgsOnSwitch = 2 THEN fileSpec.rmConfig.displayLength ¬ secondNum;	  END;	'h,'H => BEGIN --Holes in real memory	  [fileSpec.rmConfig.rmHoles[fileSpec.rmConfig.numberOfHoles].holeStart, fileSpec.rmConfig.rmHoles[fileSpec.rmConfig.numberOfHoles].holeLength, nArgsOnSwitch] ¬ GetNumPair[argPair: given, stringSouce: Heap.systemZone ! ConvError => Error["Bad argument to /h switch"L]];	  fileSpec.rmConfig.numberOfHoles ¬ fileSpec.rmConfig.numberOfHoles + 1;	  IF nArgsOnSwitch # 2 THEN Error["Bad args on /h switch"L];	  END;	'v,'V => BEGIN --Virtual memory map size	  --If there is one arg that is taken to be the start of VMM.	  --If there are two the second is taken to be the length of VMM.	  --Otherwise they default to DoveInputOutput.	  [firstNum, secondNum, nArgsOnSwitch] ¬ GetNumPair[argPair: given, stringSouce: Heap.systemZone ! ConvError => Error["Bad argument to /v switch"L]];	  IF nArgsOnSwitch >= 1 THEN fileSpec.rmConfig.memMapStart ¬ firstNum;	  IF nArgsOnSwitch = 2 THEN fileSpec.rmConfig.memMapLength ¬ secondNum;	  END;	'r,'R => BEGIN --ioRegion	  --If there is one arg that is taken to be the start of IORegion.	  --If there are two the second is taken to be the length of IORegion.	  --Otherwise they default to DoveInputOutput.	  fileSpec.rmConfig.ioRegionExists ¬ TRUE;	  [firstNum, secondNum, nArgsOnSwitch] ¬ GetNumPair[argPair: given, stringSouce: Heap.systemZone ! ConvError => Error["Bad argument to /r switch"L]];	  IF nArgsOnSwitch >= 1 THEN fileSpec.rmConfig.ioRegionRealStart ¬ firstNum;	  IF nArgsOnSwitch = 2 THEN fileSpec.rmConfig.ioRegionLength ¬ secondNum;	  END;	'f,'F => BEGIN --oFfset	  fileSpec.rmConfig.offset ¬ StringToLongHex[str: given];	  END;	'b,'B => BEGIN --Boot request	  fileSpec.wantBootRequest ¬ TRUE;	  END;	'~,'- => BEGIN	  IF String.Length[switches] # 2 THEN Error["Bad arg: ~ must have object."L];	  SELECT switches[1] FROM	    'd,'D => BEGIN -- ~d	      -- No display memory.	      fileSpec.rmConfig.displayReserved ¬ FALSE;	      END;	    'r, 'R => BEGIN -- ~r	      -- No io region.	      fileSpec.rmConfig.ioRegionExists ¬ FALSE;	      END;	    'b,'B => BEGIN -- ~b	      -- No boot request.	      fileSpec.wantBootRequest ¬ FALSE;	      END;	    'f,'F => BEGIN -- ~f	      -- No offset.	      fileSpec.rmConfig.offset ¬ 0;	      END;	    ENDCASE => Error["Bad ~ switch, Unknown arg."L];	  END;	ENDCASE => Error["Unknown argument."L];      given ¬ Exec.FreeTokenString[given];      switches ¬ Exec.FreeTokenString[switches];      [given, switches] ¬ Exec.GetToken[h];      ENDLOOP;    OutputConfig[fileSpec, actualInputFileName, actualOutputFileName, tty];    IF CheckSense[fileSpec.rmConfig, tty] THEN BEGIN      MakeBermudaRealMemFile[@fileSpec, actualInputFileName,       actualOutputFileName, tty];        TTY.PutLine[tty, " done."L];      END;    String.FreeString[z: Heap.systemZone, s: actualInputFileName];    String.FreeString[z: Heap.systemZone, s: actualOutputFileName];    EXITS      paramErr => BEGIN        String.FreeString[z: Heap.systemZone, s: actualInputFileName];	String.FreeString[z: Heap.systemZone, s: actualOutputFileName];	END;    END;  Exec.ReleaseTTY[tty];  END;--Run--        --***************************************************************************--Help: Exec.ExecProc --[h: Handle]-- = BEGIN  tty: TTY.Handle = Exec.GetTTY[h];    TTY.PutLine[tty, "MakeBermudaGerm.~"L];  TTY.PutLine[tty, "All switches have defaults.  Use switches to make output suit the memory configuration of the target machine.  The specifications are output to the executive after reading any switches.  All input numbers should be given in hex.  The specifications are written back in hex."L];  TTY.PutLine[tty, "switches:  "L];  TTY.PutLine[tty, "f,l/s  Size of real memory.  f is first page number. l is last.  f can be left out.  It defaults to 0."L];    TTY.PutLine[tty, "f,l/v  Virtual memory map.  f is first page number of the memory map. l is its length in pages.  If only 1 number is given it is read as the first page number of the memory map and the length is defaulted."L];  TTY.PutLine[tty, "f,l/d  Display memory.  f is first page number. l is length in pages.  /~d causes no area of memory to be set aside for display.  If only 1 number is given it is read as the first page number of the memory map and the length is defaulted."L];  TTY.PutLine[tty, "f,l/h  Hole in real memory.  f is first page number. l is length in pages. Several of these may be sensibly given."L];  TTY.PutLine[tty, "f,l/r  io Region.  f is first page number. l is length in pages.  /~r causes no area of memory to be set aside for io region."L];  TTY.PutLine[tty, "/b, /~b  Include (b) or don't include (~b) a Boot request.  Default is /b."L];  TTY.PutLine[tty, "x/f, /~f  x is a word oFfset to be added to the real address given to Bermuda specifying where in real memory to put each block of memory image. ~f means the same as 0/f or no f switch at all."L];  TTY.PutLine[tty, "name/i  Input file.  Name.germ is the input file.  Default is Dove."L];  TTY.PutLine[tty, "name/I  Input file.  Name is the input file.  No extension is appended.  Default is Dove.germ."L];  TTY.PutLine[tty, "name/o  Output file.  Name.germRM is the output file.  Default is PilotDove."L];  TTY.PutLine[tty, "name/O  Output file.  Name is the output file.  No extension is appended.  Default is PilotDove.germRM."L];  TTY.PutLine[tty, "Except for the i and o options the case of the switch is unimportant."L];    TTY.PutLine[tty, "If the switches request a nonsense configuration such as the memory map overlapping the io region, MakeBermudaGerm will, after printing the configuration in its usual manner, issue a complaint such as 'Memory map extends into a bad location.'"L];  END;--Help--  --***************************************************************************----MakeBermudaRealMemFile:  Create a memory map and a Boot Request.  Send these along with the contents of the input file to the output file in format suitable for Bermuda.   MakeBermudaRealMemFile: PROC [    fileSpecs: LONG POINTER TO FileSpecs, inputFileName, outputFileName:       LONG STRING, tty: TTY.Handle] =    -- Note that the caller guarantees that inputFileName exists.    BEGIN    inIORegion: BOOLEAN ¬ FALSE;    inputFile, outputFile: Stream.Handle ¬ NIL;    firstGermRealPage: DIO.RealPageNumber;    mapWordsOfGermsMDS: ARRAY WordOfPage OF DoveMapWord;    firstVanillaRealPage: DIO.RealPageNumber = ComputeFirstVanillaRealPage[fileSpecs.rmConfig];    TTY.PutString[tty, "Creating "L];    TTY.PutString[tty, outputFileName];    TTY.PutLine[tty, ".. "L];    BEGIN  --scope of Exit--    ENABLE UNWIND => {      IF inputFile # NIL THEN Stream.Delete[inputFile];      IF outputFile # NIL THEN Stream.Delete[outputFile]};    outputFile ¬ MStream.ReadWrite[outputFileName, [], binary !      MStream.Error --[file, code]-- =>        BEGIN        TTY.PutString[tty, "Trouble acquiring "L];        TTY.PutString[tty, outputFileName];	TTY.PutLine[tty, ". Skipped."L];        GOTO Exit;	END];    inputFile ¬ MStream.ReadOnly[inputFileName, [] !      MStream.Error --[file, code]-- =>        BEGIN        TTY.PutString[tty, "Trouble acquiring "L];        TTY.PutString[tty, inputFileName];	TTY.PutLine[tty, ". Skipped."L];        GOTO Exit;	END];    -- Create and output memory map real pages:    BEGIN    mapWords: ARRAY WordOfPage OF DoveMapWord;    vanillaRealPagesRemaining: RealPageCount ¬      (SELECT fileSpecs.rmConfig.ioRegionExists FROM        TRUE => ComputeRMPageCount[fileSpecs.rmConfig] -	  fileSpecs.rmConfig.ioRegionLength,        ENDCASE => ComputeRMPageCount[fileSpecs.rmConfig]);    virtual: Environment.PageNumber ¬ 0;     realForVirtual: DIO.RealPageNumber ¬ firstVanillaRealPage;        FOR realForMap: DIO.RealPageNumber IN       [fileSpecs.rmConfig.memMapStart..fileSpecs.rmConfig.memMapStart +       fileSpecs.rmConfig.memMapLength) DO      firstVirtualOfMapPage: Environment.PageNumber ¬ virtual;            FOR outputIndex: WordOfPage IN WordOfPage DO        realForThisVirtual: DIO.RealPageNumber;		IF fileSpecs.rmConfig.ioRegionExists AND 	  virtual IN [fileSpecs.rmConfig.ioRegionVirtStart .. 	  fileSpecs.rmConfig.ioRegionVirtStart +           fileSpecs.rmConfig.ioRegionLength) THEN BEGIN	  realForThisVirtual ¬ fileSpecs.rmConfig.ioRegionRealStart + 	    RealPageCount[virtual - fileSpecs.rmConfig.ioRegionVirtStart];	  inIORegion ¬ TRUE;	  END ELSE BEGIN	  inIORegion ¬ FALSE;	  IF InUnmappedRealMem[page: realForVirtual, rmConfig: fileSpecs.rmConfig]	    THEN BEGIN	    -- Skip over the unmapped portion of real memory	    realForVirtual ¬ NextMappedRealMem[page: realForVirtual, rmConfig: fileSpecs.rmConfig];	    END; 	  realForThisVirtual ¬ realForVirtual;	  realForVirtual ¬ realForVirtual.SUCC;	  END;	        mapWords[outputIndex] ¬ (          IF vanillaRealPagesRemaining > 0 OR inIORegion THEN [            realLow: realForThisVirtual MOD mapWordRealModulus,            referenced: FALSE, dirty: FALSE, writeProt: FALSE,            realHigh: realForThisVirtual/mapWordRealModulus]          ELSE vacant);        IF virtual = firstGermVirtPage THEN  --	  firstGermRealPage ¬ realForThisVirtual;  -- save for later.        virtual ¬ virtual.SUCC;        -- realForVirtual has already been bumped.        IF vanillaRealPagesRemaining > 0 THEN          vanillaRealPagesRemaining ¬ vanillaRealPagesRemaining.PRED;        ENDLOOP;      IF firstVirtualOfMapPage = pageGermMDS THEN        mapWordsOfGermsMDS ¬ mapWords;  -- save for later.      OutputPage[        stream: outputFile, realPage: realForMap,        offset: fileSpecs.rmConfig.offset,	data: @LOOPHOLE[mapWords, PageOfData]];      ENDLOOP;    END;  --writing map--    -- Write germ real memory image:    BEGIN    requestVirtPage: Environment.PageNumber =      Environment.PageFromLongPointer[Boot.pRequest];    requestVirtPageStart: LONG POINTER =      Environment.LongPointerFromPage[requestVirtPage];    IF Environment.PageFromLongPointer[Boot.pRequest + Boot.Request.SIZE]      # requestVirtPage THEN ERROR;  -- request crosses page boundary.    FOR germVirtPage: Environment.PageNumber ¬ firstGermVirtPage, germVirtPage + 1 WHILE germVirtPage-pageGermMDS < wordsPerPage DO      data: PageOfData;      offsetInMDS: CARDINAL = CARDINAL[germVirtPage-pageGermMDS];      germRealPage: DIO.RealPageNumber =        mapWordsOfGermsMDS[offsetInMDS].realHigh * mapWordRealModulus        + mapWordsOfGermsMDS[offsetInMDS].realLow;      [] ¬ Stream.GetBlock[inputFile, [LOOPHOLE[LONG[@data]], 0, 512]];      IF germVirtPage = requestVirtPage AND fileSpecs.wantBootRequest THEN        BEGIN  -- write Request into germ's memory        requestInData: LONG POINTER TO Boot.Request =          LOOPHOLE[@data, POINTER TO Boot.Request].LONG            + (Boot.pRequest - requestVirtPageStart);        requestInData­ ¬ [          requestBasicVersion: Boot.currentRequestBasicVersion,          action: Boot.bootPhysicalVolume,          location: [            deviceType: DeviceTypes.anyPilotDisk, deviceOrdinal: 0,            vp: TRASH],          switches: System.defaultSwitches,          requestExtensionVersion: Boot.currentRequestExtensionVersion,	  pStartListHeader: TRASH,	  inLoadMode: TRASH,	  session: TRASH];	  END;      OutputPage[outputFile, germRealPage, fileSpecs.rmConfig.offset, @data];      IF MStream.EndOf[inputFile] THEN EXIT;      ENDLOOP;    -- Output empty block to terminate file:    Stream.PutBlock[        outputFile,	[LOOPHOLE[LONG[@eofRecord]], 0,	  RMRecordFormat.SIZE * Environment.bytesPerWord]];    Stream.Delete[outputFile];    outputFile ¬ NIL;    Stream.Delete[inputFile];    inputFile ¬ NIL;    END;  --writing germ--    EXITS Exit => NULL;    END;  --scope of Exit--    END;  --MakeBermudaRealMemFile----***************************************************************************--  OutputPage: PROC [    stream: Stream.Handle, realPage: DIO.RealPageNumber,    offset: LONG INTEGER,    data: LONG POINTER TO PageOfData] =    -- Writes length, addrHi, addrLo, data.    BEGIN    realAddr: RealAddress = Inline.LongMult[realPage, wordsPerPage] + offset;    Stream.PutWord[stream, wordsPerPage];    Stream.PutWord[stream, Inline.HighHalf[realAddr]];    Stream.PutWord[stream, Inline.LowHalf[realAddr]];    Stream.PutBlock[stream, [LOOPHOLE[data], 0, Environment.bytesPerPage]];    END;  --OutputPage----***************************************************************************--  -- NextMappedRealMem:  page is in an unmapped portion of real memory.  Find   -- the next page which is in mapped real memory and not in the IORegion.  Assume  -- that page is in Real memory.  NextMappedRealMem: PROC[page: DIO.RealPageNumber, rmConfig: RMConfig] RETURNS[next: DIO.RealPageNumber] = BEGIN        displayEnd: DIO.RealPageNumber = rmConfig.displayStart + rmConfig.displayLength;    memMapEnd: DIO.RealPageNumber = rmConfig.memMapStart + rmConfig.memMapLength;    ioRegionEnd: DIO.RealPageNumber = rmConfig.ioRegionRealStart + rmConfig.ioRegionLength;    holeEnd: DIO.RealPageNumber;    holeNum: CARDINAL;              -- Check if page is in Display region.    IF rmConfig.displayReserved AND page IN [rmConfig.displayStart .. displayEnd)      THEN BEGIN      IF InUnmappedRealMem[page: displayEnd, rmConfig: rmConfig] THEN BEGIN        RETURN[NextMappedRealMem[page: displayEnd, rmConfig: rmConfig]];	END ELSE BEGIN	RETURN[displayEnd];	END;      END;        -- Check if page is in memory map.    IF page IN [rmConfig.memMapStart .. memMapEnd)      THEN BEGIN      IF InUnmappedRealMem[page: memMapEnd, rmConfig: rmConfig] THEN BEGIN        RETURN[NextMappedRealMem[page: memMapEnd, rmConfig: rmConfig]];	END ELSE BEGIN	RETURN[memMapEnd];	END;      END;        -- Check if page is in IO region.    IF rmConfig.ioRegionExists AND page IN [rmConfig.ioRegionRealStart .. ioRegionEnd)      THEN BEGIN      IF InUnmappedRealMem[page: ioRegionEnd, rmConfig: rmConfig] THEN BEGIN        RETURN[NextMappedRealMem[page: ioRegionEnd, rmConfig: rmConfig]];	END ELSE BEGIN	RETURN[ioRegionEnd];	END;      END;        -- Check if page is in a hole.    holeNum ¬ 0;    WHILE rmConfig.numberOfHoles > holeNum AND holeNum < maxRMHoles DO        holeEnd ¬ rmConfig.rmHoles[holeNum].holeStart +        rmConfig.rmHoles[holeNum].holeLength;      IF page IN [rmConfig.rmHoles[holeNum].holeStart .. holeEnd) THEN BEGIN        IF InUnmappedRealMem[page: holeEnd, rmConfig: rmConfig] THEN BEGIN          RETURN[NextMappedRealMem[page: holeEnd, rmConfig: rmConfig]];	  END ELSE BEGIN	  RETURN[holeEnd];	  END;        END;      holeNum ¬ holeNum + 1;      ENDLOOP;          --If we get here page is not in unmapped real memory.  Return page.    RETURN[page];    END;--NextMappedRealMem--    --***************************************************************************----InUnmappedRealMem:  Check if the given page is in either the IORegion or an--  unmapped portion of real memory or outside of real memory.       InUnmappedRealMem: PROC[page: DIO.RealPageNumber, rmConfig: RMConfig] RETURNS    [unmapped: BOOLEAN ¬ FALSE] = BEGIN        displayEnd: DIO.RealPageNumber;    memMapEnd: DIO.RealPageNumber;    ioRegionEnd: DIO.RealPageNumber;    holeEnd: DIO.RealPageNumber;    holeNum: CARDINAL;        -- Check if the page is in Real memory.    IF NOT page IN [rmConfig.lowestRealPage .. rmConfig.highestRealPage] THEN       RETURN[unmapped: TRUE];          -- Check if page is in Display region.    displayEnd ¬ rmConfig.displayStart + rmConfig.displayLength;    IF rmConfig.displayReserved AND page IN [rmConfig.displayStart .. displayEnd)      THEN RETURN[unmapped: TRUE];          -- Check if page is in memory map.    memMapEnd ¬ rmConfig.memMapStart + rmConfig.memMapLength;    IF page IN [rmConfig.memMapStart .. memMapEnd)      THEN RETURN[unmapped: TRUE];          -- Check if page is in IO region.    ioRegionEnd ¬ rmConfig.ioRegionRealStart + rmConfig.ioRegionLength;    IF rmConfig.ioRegionExists AND page IN [rmConfig.ioRegionRealStart .. ioRegionEnd)      THEN RETURN[unmapped: TRUE];          -- Check if page is in a hole.    holeNum ¬ 0;    WHILE rmConfig.numberOfHoles > holeNum AND holeNum < maxRMHoles DO        holeEnd ¬ rmConfig.rmHoles[holeNum].holeStart +        rmConfig.rmHoles[holeNum].holeLength;      IF page IN [rmConfig.rmHoles[holeNum].holeStart .. holeEnd) THEN        RETURN[unmapped: TRUE];      holeNum ¬ holeNum + 1;      ENDLOOP;    END;--InUnmappedRealMem----***************************************************************************----ComputeFirstVanillaRealPage:  A vanilla real page is one which exists and is not--  in the virtual memory map, the IO Region, or the Display Bank.  ComputeFirstVanillaRealPage: PROC[rmConfig: RMConfig] RETURNS [first: DIO.RealPageNumber] = BEGIN    RETURN[NextMappedRealMem[rmConfig.lowestRealPage, rmConfig]];    END;    --***************************************************************************----ComputeRMPageCount:  Count the pages of real memory which are available to --  be mapped.  This includes the IO Region.  ComputeRMPageCount: PROC[rmConfig: RMConfig] RETURNS [count: RealPageCount] =     BEGIN    count ¬ (rmConfig.highestRealPage - rmConfig.lowestRealPage) + 1;    IF rmConfig.displayReserved THEN count ¬ count - rmConfig.displayLength;    count ¬ count - rmConfig.memMapLength;    FOR holeNum: CARDINAL IN [0..rmConfig.numberOfHoles) DO      count ¬ count - rmConfig.rmHoles[holeNum].holeLength;      ENDLOOP;    END;--ComputeRMPageCount----***************************************************************************----SetDefaults:  Set the fields of rmConfig to their default values.  Set the default values for the input and output file names.  SetDefaults: PROC[config: LONG POINTER TO FileSpecs, inFile, outFile: LONG POINTER TO LONG STRING, stringSource: UNCOUNTED ZONE] = BEGIN        defaultInputFileName: LONG STRING = "Dove.germ"L;    defaultOutputFileName: LONG STRING  = "PilotDove.germRM"L;    IF config = NIL THEN Error["SetDefaults passed NIL pointer."];    config­ ¬ defFileSpecs;    inFile­ ¬ String.CopyToNewString[s: defaultInputFileName, z: stringSource];    outFile­ ¬ String.CopyToNewString[s: defaultOutputFileName, z: stringSource];    END;--SetDefaults--    --***************************************************************************----GetNumPair:  Read 0,1,or 2 numbers from the given string.  Return the two numbers and the number of valid numbers found.  Numbers must be hex.  GetNumPair: PROC[argPair: LONG STRING, stringSouce: UNCOUNTED ZONE] RETURNS [firstNum: CARDINAL ¬ 0, secondNum: CARDINAL ¬ 0, numbersFound: CARDINAL ¬ 0] = BEGIN    first, second: LONG STRING;    secondSubString: String.SubStringDescriptor;    position: CARDINAL ¬ 0;    IF String.Length[argPair] = 0 THEN RETURN[,,0];    WHILE position < argPair.length AND argPair[position] # ', DO      position ¬ position + 1;      ENDLOOP;    first ¬ String.CopyToNewString[s: argPair, z: stringSouce];    first.length ¬ position;    IF position = argPair.length THEN BEGIN      firstNum ¬ StringToHex[first];      String.FreeString[z: stringSouce, s: first];      numbersFound ¬ 1;      RETURN;      END;    second ¬ String.MakeString[z: stringSouce, maxlength: 20];    secondSubString ¬ String.SubStringDescriptor[base: argPair, offset:      position + 1, length: argPair.length - (position + 1)];    String.AppendSubString[to: second, from: @secondSubString];    firstNum ¬ StringToHex[first];    secondNum ¬ StringToHex[second];    numbersFound ¬ 2;    String.FreeString[z: stringSouce, s: first];    String.FreeString[z: stringSouce, s: second];    RETURN;    END;--GetNumPair--  --***************************************************************************----StringToHex:  Interpret the given string as a hex number.  StringToHex: PROC[str: LONG STRING] RETURNS [value: CARDINAL ¬ 0] = BEGIN    radix: CARDINAL = 16;    IF String.Length[str] = 0 THEN Error["StringToHex given bad string."L];    FOR i: CARDINAL IN [0..String.Length[str]) DO      SELECT str[i] FROM        IN ['0..'9] => value ¬ value * radix + str[i] - '0;	IN ['a..'f] => value ¬ value * radix + str[i] - 'a + 10;	IN ['A..'F] => value ¬ value * radix + str[i] - 'A + 10;	'H,'h,'X,'x => EXIT;	ENDCASE => ConvError["Bad argument to StringToHex"];      ENDLOOP;    END;--StringToHex----***************************************************************************----StringToLongHex:  Interpret the given string as a long hex number.  StringToLongHex: PROC[str: LONG STRING] RETURNS [value: LONG CARDINAL ¬ 0] = BEGIN    radix: CARDINAL = 16;    IF String.Length[str] = 0 THEN Error["StringToLongHex given bad string."L];    FOR i: CARDINAL IN [0..String.Length[str]) DO      SELECT str[i] FROM        IN ['0..'9] => value ¬ value * radix + str[i] - '0;	IN ['a..'f] => value ¬ value * radix + str[i] - 'a + 10;	IN ['A..'F] => value ¬ value * radix + str[i] - 'A + 10;	'H,'h,'X,'x => EXIT;	ENDCASE => ConvError["Bad argument to StringToLongHex"];      ENDLOOP;    END;--StringToLongHex----***************************************************************************--Error: ERROR[msg: LONG STRING] = CODE;ConvError: ERROR[msg: LONG STRING] = CODE;--***************************************************************************----OutputConfig:  Write out the specifications from the switches to the given TTY.  OutputConfig: PROC[fileSpec: FileSpecs, infile, outfile: LONG STRING, tty: TTY.Handle] = BEGIN      numFormat: TTY.NumberFormat = [base: 16, zerofill: FALSE, unsigned: FALSE, columns: 0];        TTY.PutLine[tty, "Specifications:"L];    TTY.PutString[tty, "Input file:  "L];    TTY.PutLine[tty, infile];        TTY.PutString[tty, "Output file:  "L];    TTY.PutLine[tty, outfile];    TTY.PutString[tty, "Real Memory Page Range:  "L];    TTY.PutNumber[h: tty, n: fileSpec.rmConfig.lowestRealPage, format: numFormat];    TTY.PutChar[h: tty, c: ',];    TTY.PutNumber[h:tty, n: fileSpec.rmConfig.highestRealPage, format: numFormat];    TTY.PutCR[h: tty];    TTY.PutString[tty, "Memory map start:  "L];    TTY.PutNumber[h: tty, n: fileSpec.rmConfig.memMapStart, format: numFormat];    TTY.PutCR[h: tty];    TTY.PutString[tty, "Memory map length:  "L];    TTY.PutNumber[h: tty, n: fileSpec.rmConfig.memMapLength, format: numFormat];    TTY.PutCR[h: tty];    IF fileSpec.rmConfig.displayReserved THEN BEGIN      TTY.PutString[tty, "First display page:  "L];      TTY.PutNumber[tty, fileSpec.rmConfig.displayStart, numFormat];       TTY.PutCR[tty];      TTY.PutString[tty, "Display length:  "L];      TTY.PutNumber[tty, fileSpec.rmConfig.displayLength, numFormat];       TTY.PutCR[tty];      END ELSE BEGIN      TTY.PutLine[tty, "No Display."L];      END;    IF fileSpec.rmConfig.ioRegionExists THEN BEGIN      TTY.PutString[tty, "First IO region real page:  "L];      TTY.PutNumber[tty, fileSpec.rmConfig.ioRegionRealStart, numFormat];       TTY.PutCR[tty];      TTY.PutString[tty, "IO region length:  "L];      TTY.PutNumber[tty, fileSpec.rmConfig.ioRegionLength, numFormat];       TTY.PutCR[tty];      TTY.PutString[tty, "First IO region virtual page:  "L];      TTY.PutLongNumber[tty, fileSpec.rmConfig.ioRegionVirtStart, numFormat];       TTY.PutCR[tty];      END ELSE BEGIN      TTY.PutLine[tty, "No IO region."L];      END;    FOR i: CARDINAL IN [0..fileSpec.rmConfig.numberOfHoles) DO      TTY.PutString[tty, "Hole at page "L];      TTY.PutNumber[tty, fileSpec.rmConfig.rmHoles[i].holeStart, numFormat];      TTY.PutString[tty, " extending "L];      TTY.PutNumber[tty, fileSpec.rmConfig.rmHoles[i].holeLength, numFormat];      TTY.PutString[tty, " pages."L];      TTY.PutCR[tty];      ENDLOOP;    IF fileSpec.rmConfig.numberOfHoles = 0 THEN BEGIN      TTY.PutLine[tty, "No holes."L];      END;    TTY.PutString[tty, "Offset:  "L];    TTY.PutLongNumber[tty, fileSpec.rmConfig.offset, numFormat];    TTY.PutCR[tty];    IF fileSpec.wantBootRequest THEN BEGIN      TTY.PutLine[tty, "Boot Request Included."L];      END ELSE BEGIN      TTY.PutLine[tty, "No Boot Request Included."L];      END;    END;--OutputConfig----***************************************************************************----CheckSense:  See if the given configuration makes sense. ie Check that none of the special areas of real memory overlap one another and are in fact inside of real memory.  Print error messages to the executive if there are errors.  --CheckSense: PROC[specs: RMConfig, tty: TTY.Handle] RETURNS [sensible: BOOLEAN ¬ TRUE] = BEGIN  specs2: RMConfig;  numFormat: TTY.NumberFormat = [base: 16, zerofill: FALSE, unsigned: FALSE, columns: 0];    IF specs.lowestRealPage > specs.highestRealPage THEN BEGIN    sensible ¬ FALSE;    TTY.PutLine[tty, "Real memory is given ridiculous bounds."L];    RETURN;    END;  IF specs.displayReserved THEN BEGIN    specs.displayReserved ¬ FALSE;    IF InUnmappedRealMem[page: specs.displayStart, rmConfig: specs]       THEN BEGIN      sensible ¬ FALSE;      TTY.PutLine[tty, "Display memory begins at a bad location."L];      END;    IF InUnmappedRealMem[page: specs.displayStart+specs.displayLength-1, rmConfig:      specs] THEN BEGIN      sensible ¬ FALSE;      TTY.PutLine[tty, "Display memory extends into a bad location."L];      END;    specs.displayReserved ¬ TRUE;    END;  IF specs.ioRegionExists THEN BEGIN    specs.ioRegionExists ¬ FALSE;    IF InUnmappedRealMem[page: specs.ioRegionRealStart, rmConfig: specs]       THEN BEGIN      sensible ¬ FALSE;      TTY.PutLine[tty, "IO region begins at a bad location."L];      END;    IF InUnmappedRealMem[page: specs.ioRegionRealStart+specs.ioRegionLength-1,      rmConfig: specs] THEN BEGIN      sensible ¬ FALSE;      TTY.PutLine[tty, "IO region extends into a bad location."L];      END;    specs.ioRegionExists ¬ TRUE;    END;      specs2 ¬ specs;  specs2.memMapLength ¬ 0;  IF InUnmappedRealMem[page: specs.memMapStart, rmConfig: specs2]     THEN BEGIN    sensible ¬ FALSE;    TTY.PutLine[tty, "Virtual memory map begins at a bad location."L];    END;  IF InUnmappedRealMem[page: specs.memMapStart+specs.memMapLength-1,    rmConfig: specs2] THEN BEGIN    sensible ¬ FALSE;    TTY.PutLine[tty, "Virtual memory map extends into a bad location."L];    END;  FOR i: CARDINAL IN [0 .. specs.numberOfHoles) DO    specs2 ¬ specs;    specs2.rmHoles[i].holeLength ¬ 0;    IF InUnmappedRealMem[page: specs.rmHoles[i].holeStart, rmConfig: specs2] THEN      BEGIN      sensible ¬ FALSE;      TTY.PutString[tty, "Hole in real memory begins at a bad location:  "L];      TTY.PutNumber[tty, specs.rmHoles[i].holeStart, numFormat];      TTY.PutCR[tty];      END;    IF InUnmappedRealMem[page: specs.rmHoles[i].holeStart +       specs.rmHoles[i].holeLength-1, rmConfig: specs2] THEN BEGIN      sensible ¬ FALSE;      TTY.PutLine[tty, "Hole in real memory extends into a bad location:  "L];      TTY.PutNumber[tty, specs.rmHoles[i].holeStart +         specs.rmHoles[i].holeLength-1, numFormat];      TTY.PutCR[tty];      END;    ENDLOOP;  END;--CheckSense--  --***************************************************************************--  -- MAIN  Exec.AddCommand[name: "MakeBermudaGerm.~", proc: Run, help: Help];  END.<<LOG??? 9-Feb-82 20:55:46   JXF        ??? 7-Jun-83  9:50:22   wDK        Converted to Sierra. Now takes germ file name from command line. Documented operation. Added execution feedback and error messages. Ditch blanket OPEN.26-Jul-83 16:28:05   wDK        pRequest changed for 11.0b bootstrap.26-Jul-83 16:28:05   wDK        Rework to use defs files instead of private copies of constants and types. Define lots of types and constants. Redo crufty logic. Use better names. Document. Add logic for ioRealPage not being first vanilla page.16-Sep-83 17:41:46	DEG       Converted to Klamath 11.0b.  On MStream.ReadWrite added the type of file being binary.12-Oct-83 10:42:50   AEF        Move the IOPage for larger VMTime: 26-Sep-84 16:27:36	By: DEG     	Action: Added copyright notice and rebuild for 11.1 release.   Convert to Dove.  File now MakeBurdockGermDove.mesa  2-Oct-84 15:20:24 RdH          Add switch to control output files 16-Oct-84  9:22:57 RdH          Alter for more generality.  Rename MakeBermudaGerm. 13-Nov-84 12:17:02 RdH          >>
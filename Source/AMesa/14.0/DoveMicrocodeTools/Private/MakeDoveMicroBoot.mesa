-- Copyright (C) 1983, 1984, 1985  by Xerox Corporation. All rights reserved.-- JWF   8-May-87 13:45:19  Allowed bank number in swithches to be 0 thru 4-- JWF  27-Oct-86 16:30:37  Fixed bug so that the final checksum is correct (zero)-- JWF  16-Oct-86 11:45:17  Added support for help command and stop key-- JWF  15-Oct-86 15:15:20  Fixed bug that crashed tool for bad file names -- JWF  15-Oct-86 11:48:20  Add ".ts" file support-- RDH,  8-Jan-86 18:11:23  Enhance performance on fb files. -- RDH	 3-Dec-85 12:25:58	Add stuff for overflow to main memory-- RDH, 16-Jul-85 11:03:42  Catch EndOfStream in case of truncated .loc file. -- RDH,  6-Jun-85 13:52:58  Change to word offsets in case of multiple .db's. --  	   		     	RDH, 11-Mar-85 17:32:34 -- MakeDoveMicroBoot.mesa, 	AYC, 13-Nov-84 13:10:21 -- 			  	JOM,  8-Oct-84 17:07:34--				xxG, 30-Aug-84 15:31:48-- from MakeDaisyMicroBoot.mesa,AYC, 31-May-84 16:05:11-- from MakeDLionMicroBoot.mesa, DEG, 30-May-83 19:51:07DIRECTORY  Ascii USING [CR, TAB],  DaybreakuFormat USING [Instruction, FinalBinaryRec],  DoveBoot USING [    Bank, BankConfig, BankType, Block, BlockType, CRC, DaisyCPInitialize, DaisyCPStart,    DaisyCPWrite,    DaisyStartAddresses, DaisyBankMap, DayBreakBankMap, DaybreakCPInitialize,    DaybreakCPStart, DaybreakCPWrite, DayBreakStartAddress, EOF,    IOPInitializeLocal, IOPInitializeMain, IOPStartLocal, IOPStartMain,    IOPWriteLocal, IOPWriteMain, MemorySegment, uAddress],  DsyuFormat USING [Instruction, FinalBinaryRec],  Environment USING [Byte, bytesPerWord],  Exec USING [AddCommand, CheckForAbort, ExecProc, FreeTokenString, GetToken, Handle, Outcome, OutputProc],  Format USING [Char, CR, Decimal, Line, Number, Text, StringProc],  Heap USING [Create, Delete, systemZone],  Inline USING [BITAND, BITNOT, BITOR, BITSHIFT, BITROTATE, LongCOPY, HighByte],  MFile USING [Handle, ReadOnly, GetCreateDate, Error],  MSegment USING [Address, Create, Delete, GetFile, GetFilePages, Handle],  MStream USING [EndOf, Error, ReadOnly, ReleaseData, WriteOnly, Handle, GetFile],  Runtime USING [CallDebugger, GetBcdTime],  Stream USING [    Byte, Delete, EndOfStream, GetByte, GetPosition, GetWord, Handle,    Position, PutBlock, PutWord, SetPosition, Word, PutString, PutChar],  String USING [    AppendChar, AppendCharAndGrow, AppendExtensionIfNeeded, AppendStringAndGrow,    CopyToNewString, Equivalent, StringBoundsFault, Copy, AppendString],  Time USING [Packed, Unpack, Append],  Token USING [FreeStringHandle, FreeTokenString, Handle, Item, StringToHandle],  UserInput USING [UserAbort];MakeDoveMicroBoot: PROGRAM  IMPORTS Exec, Format, Heap, Inline, MFile, MSegment, MStream, Runtime,   	  Stream, String, Time, Token, UserInput  EXPORTS DoveBoot =  BEGIN  uPhysical: PUBLIC TYPE = RECORD [    SELECT OVERLAID * FROM      Daisy => [daisyInstr: DsyuFormat.Instruction],      Daybreak => [daybreakInstr: DaybreakuFormat.Instruction],       ENDCASE];  Error: ERROR [mess: STRING] = CODE;  InMode: TYPE = {fb, loc, db};  InStuff: TYPE = RECORD [    name: LONG STRING ¬ NIL,    switch: LONG STRING ¬ NIL,    mode: InMode,    sh: Stream.Handle ¬ NIL,    seg: MSegment.Handle ¬ NIL];  OutStuff: TYPE = RECORD [    name: LONG STRING ¬ NIL,    switch: LONG STRING ¬ NIL,    sh: Stream.Handle ¬ NIL,    files: CARDINAL ¬ 0,  -- count of input files    checksum: WORD ¬ 0,    lengthOfFile: WORD ¬ 0,    typeIsOfDB: BOOLEAN ¬ FALSE,    byteAddress: CARDINAL ¬ 0];      TsFileStreamHandle: MStream.Handle ¬ NIL;    Driver: PROC [h: Exec.Handle, clientData: LONG POINTER] RETURNS [    o: Exec.Outcome ¬ normal] =    BEGIN    out: POINTER TO OutStuff = @outStuff;    outStuff: OutStuff;    tty: Format.StringProc ¬ Exec.OutputProc[h];    BEGIN  -- EXIT block    InitializeOutAndVerifyArrow[      h, out, tty ! Error => {Format.Line[proc: tty, s: mess]; GOTO problem};      UNWIND => ReleaseOut[out]];    IF FALSE THEN Runtime.CallDebugger["Early CallDebugger"L];    ProcessInputFiles[      h, tty, out ! Error => {Format.Line[proc: tty, s: mess]; GOTO problem};      UNWIND => ReleaseOut[out]];    IF NOT out.typeIsOfDB THEN       FinishOutput[        out, tty ! Error => {Format.Line[proc: tty, s: mess]; GOTO problem};        UNWIND => ReleaseOut[out]];    Format.Decimal[proc: tty, n: out.files];    Format.Line[proc: tty, s: " input files"L];    ReleaseOut[out];    EXITS      problem => {ReleaseOut[out]; RETURN[error]};    END;    END;  -- End of Driver      OpenTsFile: PROCEDURE[outFileName: LONG STRING] =     BEGIN     tsFileName: LONG STRING ¬ [100];     toolVersionString: LONG STRING ¬ [100];     errorMsg: STRING ¬ [100];     String.Copy[tsFileName, outFileName];          << If extension = ".db" then change to ".ts" >>     IF tsFileName.length > 2 AND     	 tsFileName[tsFileName.length - 3] = '.  AND        (tsFileName[tsFileName.length - 2] = 'd  OR	 tsFileName[tsFileName.length - 2] = 'D) AND	(tsFileName[tsFileName.length - 1] = 'b  OR	 tsFileName[tsFileName.length - 1] = 'B) THEN	BEGIN	tsFileName[tsFileName.length - 2]  ¬ 't;	tsFileName[tsFileName.length - 1]  ¬ 's;	END     ELSE << If extension is not ".db" then append ".ts" >>        BEGIN	IF tsFileName.length <= tsFileName.maxlength - 3 THEN	   BEGIN	   tsFileName.length ¬ tsFileName.length + 3;	   tsFileName[tsFileName.length - 3]  ¬ '.;	   tsFileName[tsFileName.length - 2]  ¬ 't;	   tsFileName[tsFileName.length - 1]  ¬ 's;	   END;	END;          TsFileStreamHandle ¬ MStream.WriteOnly[tsFileName, [] , text !        MStream.Error => IF code = fileNotAvailable THEN	   BEGIN	   TsFileStreamHandle ¬ NIL;	   String.Copy[errorMsg, "Error -- """L];	   String.AppendString[errorMsg, tsFileName];	   String.AppendString[errorMsg, """ can not be opened."L];	   Error[errorMsg];	   END];          String.AppendString[toolVersionString, "MakeDoveMicroBoot of "L];     Time.Append[toolVersionString, Time.Unpack[Runtime.GetBcdTime[]]];         Stream.PutString[TsFileStreamHandle, "-- "L];     Stream.PutString[TsFileStreamHandle, tsFileName];     Stream.PutChar[TsFileStreamHandle, Ascii.CR];     Stream.PutString[TsFileStreamHandle, "-- "L];     Stream.PutString[TsFileStreamHandle, "Created By "L];     Stream.PutString[TsFileStreamHandle, toolVersionString];     Stream.PutChar[TsFileStreamHandle, Ascii.CR];     Stream.PutChar[TsFileStreamHandle, Ascii.CR];     Stream.PutString[TsFileStreamHandle, "Input Files:"L];     Stream.PutChar[TsFileStreamHandle, Ascii.CR];     Stream.PutChar[TsFileStreamHandle, Ascii.CR];               END;  CloseTsFile: PROC[out: POINTER TO OutStuff] =     BEGIN     s: Stream.Handle;     errorMsg: STRING ¬ [100];          IF TsFileStreamHandle # NIL THEN        BEGIN	IF out.name # NIL THEN	   BEGIN	   s ¬ MStream.ReadOnly[out.name, [] !           MStream.Error => IF code = fileNotAvailable THEN	      BEGIN	      String.Copy[errorMsg, "Error -- """L];	      String.AppendString[errorMsg, out.name];	      String.AppendString[errorMsg, """ can not be opened to read create date."L];	      Error[errorMsg];	      END];	   Stream.PutChar[TsFileStreamHandle, Ascii.CR];           Stream.PutChar[TsFileStreamHandle, Ascii.CR];           Stream.PutString[TsFileStreamHandle, "Output File:"L];           Stream.PutChar[TsFileStreamHandle, Ascii.CR];           Stream.PutChar[TsFileStreamHandle, Ascii.CR];        	   AddEntryToTsFile[out.name, NIL, 	      MFile.GetCreateDate[MStream.GetFile[s]]];	   Stream.Delete[s];	   s ¬ NIL;	   END	ELSE	   BEGIN	   Error["Error -- No Output file found for reading create date."];	   END;	           Stream.Delete[TsFileStreamHandle];        TsFileStreamHandle ¬ NIL;        END;     END;           AddEntryToTsFile: PROCEDURE[fileName, switches: LONG STRING, timeDateStamp: Time.Packed] =     BEGIN     NumberOfTabsToSwitches: INTEGER = 3;     timeStampString: LONG STRING ¬ [50];          timeStampString.length ¬ 0;     Time.Append[timeStampString, Time.Unpack[timeDateStamp]];          Stream.PutChar[TsFileStreamHandle, Ascii.TAB];     Stream.PutString[TsFileStreamHandle, fileName];     FOR i: INTEGER IN[1..NumberOfTabsToSwitches - fileName.length/8 ]        DO	Stream.PutChar[TsFileStreamHandle, Ascii.TAB];	ENDLOOP;     IF switches # NIL THEN        BEGIN	Stream.PutString[TsFileStreamHandle,"/"];        Stream.PutString[TsFileStreamHandle, switches];	Stream.PutChar[TsFileStreamHandle, Ascii.TAB];	Stream.PutChar[TsFileStreamHandle, Ascii.TAB];	END     ELSE        BEGIN	Stream.PutString[TsFileStreamHandle,"no switches"];	Stream.PutChar[TsFileStreamHandle, Ascii.TAB];	END;     Stream.PutString[TsFileStreamHandle, timeStampString];     Stream.PutChar[TsFileStreamHandle, Ascii.CR];     END;     FinishOutput: PROCEDURE [out: POINTER TO OutStuff, tty: Format.StringProc] =    BEGIN        lastWord: WORD;    crc: DoveBoot.BlockType ¬ DoveBoot.CRC;    eof: DoveBoot.BlockType ¬ DoveBoot.EOF;            WriteToBoot[out, @eof, 1];    WriteToBoot[out, @crc, 1];        lastWord ¬ Inline.BITNOT[out.checksum]; -- Write last word so checksum = zero    WriteToBoot[out, @lastWord, 1];    END;  -- end FinishOutput proc  GetExtension: PROCEDURE [name: LONG STRING, ext: LONG STRING] =    BEGIN    i, j: CARDINAL;    FOR i IN [0..name.length) DO      IF name[i] = '. THEN EXIT      REPEAT FINISHED => ERROR  -- apended       ENDLOOP;    FOR j IN [i..name.length) DO      String.AppendChar[ext, name[j] ! String.StringBoundsFault => GOTO tooBig]      ENDLOOP;    EXITS tooBig => Error[" Illegal extension "L];    END;  -- end GetExtension proc  GetNextInFile: PROCEDURE [h: Exec.Handle, in: POINTER TO InStuff]    RETURNS [gotIt: BOOLEAN] =    BEGIN    [in.name, in.switch] ¬ GetNextName[h];    IF in.name = NIL THEN RETURN[FALSE];    [] ¬ String.AppendExtensionIfNeeded[LONG[@in.name], "fb"L, Heap.systemZone];    SetInMode[in];    SELECT in.mode FROM      fb  =>          BEGIN	 in.seg ¬ MSegment.Create[             file: MFile.ReadOnly[name: in.name, release: -- No -- [NIL, NIL]],             release: -- No -- [NIL, NIL]];	 AddEntryToTsFile[in.name, in.switch , MFile.GetCreateDate[ MSegment.GetFile[in.seg]]];	 END;      loc =>          BEGIN	 in.sh ¬ MStream.ReadOnly[name: in.name, release: -- No -- [NIL, NIL]];	 AddEntryToTsFile[in.name, in.switch, MFile.GetCreateDate[ MStream.GetFile[in.sh]]];	 END;      ENDCASE;    RETURN[TRUE];    END;  -- GetNextInFile proc    GetNextName: PROCEDURE [h: Exec.Handle] RETURNS [name, switch: LONG STRING] =    BEGIN    execName, execSwitch: LONG STRING ¬ NIL;    BEGIN    ENABLE      UNWIND => {        [] ¬ Exec.FreeTokenString[execName]; [] ¬ Exec.FreeTokenString[execSwitch]};    [execName, execSwitch] ¬ Exec.GetToken[h];    name ¬ String.CopyToNewString[execName, Heap.systemZone];    switch ¬ String.CopyToNewString[execSwitch, Heap.systemZone];    END;  -- end unwind block    [] ¬ Exec.FreeTokenString[execName];    [] ¬ Exec.FreeTokenString[execSwitch];    END;  -- end GetNextName proc  GetOutFile: PROCEDURE [h: Exec.Handle, out: POINTER TO OutStuff]    RETURNS [gotIt: BOOLEAN] =    BEGIN    [out.name, out.switch] ¬ GetNextName[h];    IF out.name = NIL THEN RETURN[FALSE];    [] ¬ String.AppendExtensionIfNeeded[LONG[@out.name], "db"L, Heap.systemZone];    out.sh ¬ MStream.WriteOnly[      name: out.name, release: [NIL, NIL], type: binary];    OpenTsFile[out.name];    RETURN[TRUE];    END;  -- GetOutFile proc  GetTokenDiscardSwitches: PROC [h: Exec.Handle] RETURNS [token: LONG STRING] = {    temp: LONG STRING;    [token, temp] ¬ Exec.GetToken[h];    [] ¬ Exec.FreeTokenString[temp]};  Init: PROC = {Exec.AddCommand[name: "MakeDoveMicroBoot.~"L, proc: Driver, help: Help]};  InitializeOutAndVerifyArrow: PROCEDURE [    h: Exec.Handle, out: POINTER TO OutStuff, tty: Format.StringProc] =    BEGIN    IF ~GetOutFile[      h, out !      MStream.Error =>        IF code = fileNotAvailable THEN GOTO notAvailable ELSE REJECT] THEN          GOTO badCommand;    IF ~String.Equivalent[GetTokenDiscardSwitches[h], "¬"L] AND        ~String.Equivalent[GetTokenDiscardSwitches[h], "_"L] -- for Mesa11.1 release -- THEN      GOTO badCommand;    Format.Text[proc: tty, s: "Writing... "L];    Format.Text[proc: tty, s: out.name];    Format.CR[proc: tty];    EXITS      badCommand => Error[" Usage: output ¬ inputList "L];      notAvailable => Error[" Can't aquire output file "L];    END;  -- end of InitOutFileCheckArrow proc  -- Subroutines for Checksum  -- The rule is that the checksum of the whole file is 0.  MoreChecksum: PROCEDURE [cs: WORD, q: LONG POINTER, size: CARDINAL]    RETURNS [WORD] =    BEGIN    p: LONG POINTER TO ARRAY [0..0) OF WORD = q;    FOR i: CARDINAL IN [0..size) DO      t: CARDINAL = cs + p[i];      cs ¬ (IF cs > t THEN t + 1 ELSE t);      cs ¬ (IF cs >= 100000B THEN cs*2 + 1 ELSE cs*2);      ENDLOOP;    IF cs = 177777B THEN cs ¬ 0;    RETURN[cs];    END;  ProcessDB:    PROCEDURE [in: POINTER TO InStuff, out: POINTER TO OutStuff,       	       tty: Format.StringProc]    RETURNS   [count: CARDINAL ¬ 0] =    BEGIN    dbword: Stream.Word;    DO      dbword ¬ Stream.GetWord[in.sh ! Stream.EndOfStream => EXIT];      Stream.PutWord[out.sh, dbword];      out.checksum ¬ MoreChecksum[out.checksum, @dbword, SIZE[Stream.Word]];      count ¬ count + 1;      ENDLOOP;    END;        ProcessFB:    PROCEDURE [in: POINTER TO InStuff, out: POINTER TO OutStuff,       	       tty: Format.StringProc]    RETURNS   [count: CARDINAL ¬ 0] =    BEGIN    block: LONG POINTER TO cpWrite DoveBoot.Block;    buffered: CARDINAL ¬ 0;    last: CARDINAL ¬ 0;    maxNum: CARDINAL ¬ 1000H;    min, max: CARDINAL;    miSize: CARDINAL = 4096;    newuPhysical: uPhysical;    startBlock: cpAddr DoveBoot.Block;    CPStartMode: {none, start, init} ¬ none;    thisaddr: CARDINAL;    thismiNum: CARDINAL;      typeBool: BOOLEAN ¬ TRUE; -- default to Daybreak    daybreakP: TYPE = LONG POINTER TO DaybreakuFormat.FinalBinaryRec;    daisyP: TYPE = LONG POINTER TO DsyuFormat.FinalBinaryRec;    daybreakThis: daybreakP;    daisyThis: daisyP;    typeOfNumber: {bankNumber, configurationOfBanks} ¬ bankNumber;    bankConfig: DoveBoot.BankConfig ¬ 0;        BufferReset: PROCEDURE = INLINE      BEGIN      block.address ¬ thisaddr;      BufferAppend[];      END;    BufferAppend: PROCEDURE = INLINE      BEGIN      block.instructions[buffered] ¬ newuPhysical;      last ¬ thisaddr;      buffered ¬ buffered + 1;      min ¬ MIN[min, last];      max ¬ MAX[max, last];      END;    BufferWrite: PROCEDURE =      BEGIN      block.length ¬ buffered;      WriteToBoot[out, block, SIZE[cpWrite DoveBoot.Block[buffered]]];      buffered ¬ 0;      END;    -- ProcessFB starts here    z: UNCOUNTED ZONE = Heap.Create[initial:1];  -- to allow dynamic allocation of space    StartBank: CARDINAL ¬ 0;    StartAddress: DoveBoot.uAddress ¬ 0;    StartAddressPlusOne: DoveBoot.uAddress ¬ 0;    StartAddr: CARDINAL ¬ 0; -- count to make sure two starting addresses were given    IF in.switch # NIL THEN      FOR i: CARDINAL IN [0..in.switch.length) DO	SELECT in.switch[i] FROM        IN ['0..'4] => SELECT typeOfNumber FROM	  bankNumber => StartBank ¬ in.switch[i] - '0;	  configurationOfBanks => bankConfig ¬ in.switch[i] - '0; 	  ENDCASE => ERROR;	'B, 'b      => typeOfNumber ¬ bankNumber;	'C, 'c      => typeOfNumber ¬ configurationOfBanks;	'K, 'k      => typeBool ¬ TRUE;	'Y, 'y      => typeBool ¬ FALSE;	'I, 'i      => CPStartMode ¬ init;	'S, 's      => CPStartMode ¬ start;        ENDCASE     => Error[" Illegal character(s) encounted on command line. "L];    ENDLOOP;    IF StartBank ~IN DoveBoot.BankType THEN      IF typeBool THEN        Error[" Illegal Bank switch for DayBreak."L]      ELSE Error[" Illegal Bank switch for Daisy."L];    block ¬ z.NEW[cpWrite DoveBoot.Block[maxNum] ¬	[blktype: IF typeBool THEN DoveBoot.DaybreakCPWrite	                      ELSE DoveBoot.DaisyCPWrite,	 data: cpWrite[DaisyBank: IF ~typeBool THEN DoveBoot.DaisyBankMap[StartBank] ELSE 0,		       DayBreakBank: IF typeBool THEN DoveBoot.DayBreakBankMap[StartBank] ELSE 0]]];    block.blktype.bankConfiguration ¬ bankConfig;    IF StartBank >= bankConfig AND bankConfig # 0 THEN       ERROR Error["Bank switch too high for bank configuration."L];	           count ¬ max ¬ 0;    min ¬ miSize;    IF MSegment.GetFilePages[in.seg] = 0 THEN RETURN;    daybreakThis ¬ MSegment.Address[in.seg];    daisyThis ¬ MSegment.Address[in.seg];        DO SELECT typeBool FROM      TRUE  => {        addr, nibble: WORD ¬ 0;	instruction: DaybreakuFormat.FinalBinaryRec;	Inline.LongCOPY[daybreakThis, SIZE[DaybreakuFormat.FinalBinaryRec], @instruction];        thisaddr ¬ daybreakThis.addr;	thismiNum ¬ daybreakThis.miNum;	--	-- daybreak hardware require last nibble to be complemented	--	addr ¬ Inline.BITAND[daybreakThis.partialBinary.instruction.addr, 0FFF0H];	nibble ¬ Inline.BITNOT[Inline.BITAND[daybreakThis.partialBinary.instruction.addr, 0FH]];	instruction.partialBinary.instruction.addr ¬ Inline.BITOR[addr, Inline.BITAND[nibble, 0FH]];	newuPhysical ¬ uPhysical[Daybreak[instruction.partialBinary.instruction]];	daybreakThis ¬ daybreakThis + SIZE[DaybreakuFormat.FinalBinaryRec];};       FALSE => {        thisaddr ¬ daisyThis.addr;        thismiNum ¬ daisyThis.miNum;	newuPhysical ¬ uPhysical[Daisy[daisyThis.partialBinary.instruction]];	daisyThis ¬ daisyThis + SIZE[DsyuFormat.FinalBinaryRec];};       ENDCASE;       IF thisaddr >= miSize THEN EXIT;       IF thismiNum = 177777B THEN         {StartAddr ¬ StartAddr + 1; StartAddress ¬ thisaddr}       ELSE IF thismiNum = 177776B THEN         {StartAddr ¬ StartAddr + 1; StartAddressPlusOne ¬ thisaddr}	 ELSE IF buffered = 0 THEN BufferReset[]	   ELSE IF thisaddr = last + 1 THEN	     BEGIN	     IF buffered >= maxNum THEN {BufferWrite[]; BufferReset[]}	       ELSE BufferAppend[];		<<BEGIN		newBlock: LONG POINTER TO cpWrite DoveBoot.Block ¬ 		   	   z.NEW[cpWrite DoveBoot.Block[maxNum + 10]];		Inline.LongCOPY [block, SIZE[cpWrite DoveBoot.Block[maxNum]], newBlock];		z.FREE[@block];		block ¬ newBlock;		maxNum ¬ maxNum + 10;		END;	     BufferAppend[];>>	     END           ELSE	{BufferWrite[]; BufferReset[]}; -- IF thisaddr = last + 1       count ¬ count + 1;    ENDLOOP;    IF buffered # 0 THEN BufferWrite;     IF CPStartMode # none THEN       BEGIN      IF typeBool THEN	IF StartAddr # DoveBoot.DayBreakStartAddress THEN {	  Format.Line[tty, "  DayBreak Starting Address not found "L];	  Format.Text[tty, "  cp not started... Continuing..."L]}	ELSE BEGIN	  startBlock.blktype ¬	    SELECT CPStartMode FROM			   		init    => DoveBoot.DaybreakCPInitialize,		start   => DoveBoot.DaybreakCPStart,		ENDCASE => ERROR;	  startBlock.address ¬ DoveBoot.DayBreakBankMap[StartBank];	  startBlock.addressPlusOne ¬ StartAddress;	-- only one startaddr for DayBreak          END      ELSE	IF StartAddr # DoveBoot.DaisyStartAddresses THEN {	  Format.Line[tty, "  Daisy Starting Address not found "L];	  Format.Text[tty, "  cp not started... Continuing..."L]}	ELSE BEGIN	  startBlock.blktype ¬	    SELECT CPStartMode FROM		init    => DoveBoot.DaisyCPInitialize,		start   => DoveBoot.DaisyCPStart,		ENDCASE => ERROR;	  startBlock.bank ¬ startBlock.bankPlusOne ¬ Inline.BITSHIFT[DoveBoot.DaisyBankMap[StartBank], -4];	  startBlock.address ¬ StartAddressPlusOne;	-- these are intentionally reversed	  startBlock.addressPlusOne ¬ StartAddress;	  END;      WriteToBoot[out, @startBlock, SIZE[cpAddr DoveBoot.Block]];      END;    IF count = 0 THEN RETURN;    Format.Text[tty, "  ("L];    Format.Number[      proc: tty, n: min,      format: [base: 16, zerofill: FALSE, unsigned: TRUE, columns: 0]];    Format.Char[proc: tty, char: '-];    Format.Number[      proc: tty, n: max,      format: [base: 16, zerofill: FALSE, unsigned: TRUE, columns: 0]];    Format.Text[proc: tty, s: ") "L];    Heap.Delete[z:z];    END;  ProcessInputFiles: PROCEDURE [    h: Exec.Handle, tty: Format.StringProc, out: POINTER TO OutStuff] =    BEGIN    DBcount: CARDINAL ¬ 0;    InputFileTypeLock: CARDINAL ¬ 0; -- to prevent fb/loc mixing with db.    fileSize: CARDINAL;    in: POINTER TO InStuff = @inStuff;    inStuff: InStuff;    multipleDBString: LONG STRING ¬ NIL;     DO      IF UserInput.UserAbort[NIL] OR Exec.CheckForAbort[h] THEN GOTO abortRun;       IF ~GetNextInFile[        h, in !        MStream.Error =>          IF code = fileNotAvailable THEN {ReleaseIn[in]; GOTO notAvailable}          ELSE REJECT;	MFile.Error =>	   IF code = noSuchFile THEN {ReleaseIn[in]; GOTO notAvailable}          ELSE REJECT;        UNWIND => ReleaseIn[in]] THEN EXIT;	      BEGIN      ENABLE UNWIND => ReleaseIn[in];      IF in.mode # db THEN        BEGIN	Format.Text[proc: tty, s: "Reading... "L];        Format.Text[proc: tty, s: in.name];	END;             SELECT in.mode FROM        fb  => IF InputFileTypeLock # 2 THEN {		 InputFileTypeLock ¬ 1;		 fileSize ¬ ProcessFB[in, out, tty]}	       ELSE {	         Format.Line[tty, "  cannot mix DB with fb-file, skipped"L];		 LOOP};        loc => IF InputFileTypeLock # 2 THEN {		InputFileTypeLock ¬ 1;	        fileSize ¬ ProcessLoc[in, out, tty]}	       ELSE {	         Format.Line[tty, "  cannot mix DB with loc-file, skipped"L];		 LOOP};        db  => BEGIN	       IF InputFileTypeLock = 1 THEN {	         Format.Line[tty, "  Mixing DB with other non-DB file(s), skipped"L];		 LOOP};	       InputFileTypeLock ¬ 2;	       out.typeIsOfDB ¬ TRUE;	       DBcount ¬ DBcount + 1;	       String.AppendStringAndGrow[@multipleDBString, in.name, Heap.systemZone];	       String.AppendCharAndGrow[@multipleDBString, ' , Heap.systemZone];	       END;        ENDCASE;      END;  -- end of ReleaseIn[in] UNWIND block      ReleaseIn[in];      IF in.mode # db THEN        BEGIN      	Format.Text[tty, "  ("L];        Format.Decimal[tty, fileSize];        Format.Line[tty, ")"L];        out.files ¬ out.files + 1;	END;      ENDLOOP;      IF multipleDBString # NIL THEN BEGIN        OffsetWord: Stream.Word;        dataPosition, offsetPosition: Stream.Position;	finishedDB: CARDINAL ¬ 0;	in2: Token.Handle ¬ Token.StringToHandle[multipleDBString];        offset: Stream.Word ¬ DBcount + 1;--Word offset	OffsetWord ¬ 0FF00H + DBcount;        Stream.PutWord[out.sh, OffsetWord];	out.checksum ¬ MoreChecksum[out.checksum, @OffsetWord, SIZE[Stream.Word]];	Stream.PutWord[out.sh, offset];	out.checksum ¬ MoreChecksum[out.checksum, @offset, SIZE[Stream.Word]];	offsetPosition ¬ Stream.GetPosition[out.sh];	THROUGH [1..DBcount) DO	  Stream.PutWord[out.sh, offset];	  ENDLOOP;	DO ENABLE MStream.Error =>  -- catch open DB file error		IF code = fileNotAvailable THEN GOTO notAvailable ELSE REJECT;	  finishedDB ¬ finishedDB + 1;	  in.name ¬ Token.Item[in2];	  Format.Text[proc: tty, s: "Copying... "L];          Format.Text[proc: tty, s: in.name];	  in.sh ¬ MStream.ReadOnly[name: in.name, release: -- No -- [NIL, NIL]];	  fileSize ¬ ProcessDB[in, out,tty];--fileSize is in words	  Stream.Delete[in.sh];	  [] ¬ Token.FreeTokenString[in.name];	  Format.Text[tty, "  ("L];          Format.Decimal[tty, fileSize];          Format.Line[tty, ")"L];	  out.files ¬ out.files + 1;	  IF finishedDB = DBcount THEN EXIT;	  dataPosition ¬ Stream.GetPosition[out.sh];	  Stream.SetPosition[out.sh, offsetPosition];	  offset ¬ offset + fileSize;	  Stream.PutWord[out.sh, offset];	  out.checksum ¬ MoreChecksum[out.checksum, @offset, SIZE[Stream.Word]];	  offsetPosition ¬ Stream.GetPosition[out.sh];	  Stream.SetPosition[out.sh, dataPosition];	   	  ENDLOOP;	[] ¬ Token.FreeStringHandle[in2];	Heap.systemZone.FREE[@multipleDBString];	END;           EXITS      notAvailable => Error[" Can't acquire input file "L];      abortRun => Error[" -- User Abort --"];          END;  -- End of ProcessInputFiles procedure        ProcessLoc: PROCEDURE [    in: POINTER TO InStuff, out: POINTER TO OutStuff, tty: Format.StringProc]    RETURNS [count: CARDINAL ¬ 0] =    BEGIN         -- The following procedure calculates the address from the two bytes    -- which are picked up in reverse order.     -- It then leaves the Stream Position ready to read the data field.        GetAddress: PROCEDURE RETURNS [CARDINAL] =        	        BEGIN	        Stream.SetPosition[sH:dh, position: addrpos];	        RETURN [Inline.BITSHIFT[Inline.BITROTATE[			Stream.GetWord[sH:dh], 8], 4] + Stream.GetByte[sH:dh]];	        END;		    -- The following recursive procedure calculates the data field of     -- Iterated Data Type records	    ExpandIteratedBlock: PROCEDURE [startIndex: CARDINAL, write: BOOLEAN]     			 RETURNS [CARDINAL] =    		BEGIN		bytesLoaded: CARDINAL;		index: CARDINAL ¬ startIndex;		repeatCnt: CARDINAL ¬ Inline.BITROTATE[Stream.GetWord[sH:dh], 8];		blockCnt: CARDINAL ¬ Inline.BITROTATE[Stream.GetWord[sH:dh], 8];		IF blockCnt = 0		THEN THROUGH [0..Stream.GetByte[sH:dh]) DO		     nextByte: Environment.Byte ¬ Stream.GetByte[sH:dh];		     IF write THEN bytesSeqPtr[index] ¬ nextByte;		     index ¬ index + 1;		     ENDLOOP		ELSE THROUGH [0..blockCnt) DO		     index ¬ ExpandIteratedBlock[index, write];		     ENDLOOP;		bytesLoaded ¬ index - startIndex;		THROUGH (1..repeatCnt] DO		  IF write THEN 		  FOR i:CARDINAL IN [0..bytesLoaded) DO		      bytesSeqPtr[index+i] ¬ bytesSeqPtr[startIndex+i];		  ENDLOOP;		  index ¬ index + bytesLoaded;		ENDLOOP;		RETURN[index];		END;--ExpandIteratedBlock		    GetStartAddrFromLastRecord: PROCEDURE[] RETURNS[start: CARDINAL ¬ 0,       startGiven: BOOLEAN ¬ FALSE] = BEGIN       Stream.SetPosition[sH:dh, position: addrpos];      SELECT Stream.GetByte[sH:dh] FROM        0 => NULL; -- No start address given	40H, 0C0H => BEGIN -- Next four bytes contain 2 bytes of segment addr and			 -- 2 bytes of offset.	 	  startGiven ¬ TRUE;	  start ¬ Inline.BITSHIFT[Inline.BITROTATE[Stream.GetWord[sH:dh], 8], 4] +	    Inline.BITROTATE[Stream.GetWord[sH:dh], 8];	  END;	ENDCASE => Error[" Unexpected mod type in last block "L];      END;--GetStartAddrFromLastRecord                  		    -- Process 186 files here      addr, recLength, recType: CARDINAL;    addrpos, startpos: LONG CARDINAL;    bytesSeqPtr: LONG POINTER TO iopWrite DoveBoot.Block;    lastword: CARDINAL ¬ 0;    chkSum: CARDINAL ¬ 0;    dh: Stream.Handle ¬ in.sh;    EOF: CARDINAL = 1;    Odd: CARDINAL = 1;    Noop186: CARDINAL = 090H;    iOPstartAddr: CARDINAL ¬ 0;    startAddrGiven: BOOLEAN;--Tell if current file gives a start address.    IOPStartMode: {init, start, none} ¬ none;--Set by /S or /I switches.    IOPstartBlock: iopAddr DoveBoot.Block;    codeSegment: DoveBoot.MemorySegment ¬ LocalRam;    ignoreLocStart: BOOLEAN ¬ FALSE;--Set if a start address is given on command line.    tempStart: CARDINAL ¬ 0;--Holds the start address given on command line.    size: CARDINAL = SIZE[uPhysical];    z: UNCOUNTED ZONE = Heap.Create[initial: 1]; -- Allow dynamic alloc of space        --Process command line switches    -- Switch is a hex IOP start addr, or    --  I,S,L,M    --  I implies it is an initializing file    --  S implies it is a starting file    --  L implies it is to go into the local ram code segment    --  M implies it is to go into the main memory code segment    IF in.switch # NIL THEN     BEGIN    FOR i: CARDINAL IN [0..in.switch.length) DO       SELECT in.switch.text[i] FROM	IN ['0..'9] => BEGIN	  ignoreLocStart ¬ TRUE;	  tempStart ¬ Inline.BITSHIFT[tempStart, 4] + in.switch[i] - '0;	  END;	IN ['A..'F] => BEGIN	  ignoreLocStart ¬ TRUE;	  tempStart ¬ Inline.BITSHIFT[tempStart, 4] + 	    in.switch[i] + 10  - 'A;	  END;	IN ['a..'f] => BEGIN	  ignoreLocStart ¬ TRUE;	  tempStart ¬ Inline.BITSHIFT[tempStart, 4] + 	    in.switch[i] + 10  - 'a;	  END;	'I, 'i      => IOPStartMode ¬ init;	'S, 's      => IOPStartMode ¬ start;	'L, 'l      => codeSegment ¬ LocalRam;	'M, 'm      => codeSegment ¬ MainMemory;	ENDCASE => Error["Unknown switch on .loc file. "L];      ENDLOOP;    END;--of IF in.switch # NIL      -- Begin reading each field in the record one at a time    DO      ENABLE Stream.EndOfStream => {        Format.Line[tty, "Error! Truncated file"L]; EXIT;};      startpos ¬ Stream.GetPosition[sH:dh];      recType ¬ Stream.GetByte[sH:dh];      recLength ¬ Inline.BITROTATE[Stream.GetWord[sH:dh], 8];      addrpos ¬ Stream.GetPosition[sH:dh];      Stream.SetPosition[sH:dh, position: startpos];      THROUGH [1..recLength + 3] DO        chkSum ¬ chkSum + Stream.GetByte[sH:dh];      ENDLOOP;      IF (chkSum MOD 256) # 0 THEN Error ["Checksum error"L];      SELECT recType FROM      	   8AH => BEGIN -- final record --	            [iOPstartAddr, startAddrGiven] ¬ GetStartAddrFromLastRecord[];		    [] ¬ Stream.GetByte[sH:dh]; -- Skip chkSum byte		    EXIT;		  END;	   84H => BEGIN -- conventional type record	            recLength ¬ recLength - 4;	   	    addr ¬ GetAddress[];		    SELECT codeSegment FROM		      LocalRam => bytesSeqPtr ¬  		        z.NEW[iopWrite DoveBoot.Block[recLength] ¬		    	  [blktype: DoveBoot.IOPWriteLocal, data: iopWrite[]]];		      MainMemory => bytesSeqPtr ¬ 			z.NEW[iopWrite DoveBoot.Block[recLength] ¬		    	  [blktype: DoveBoot.IOPWriteMain, data: iopWrite[]]];		      ENDCASE => Error ["Unknown code segment type"L];		    FOR i: CARDINAL IN [0..recLength) DO        	    bytesSeqPtr[i] ¬ Stream.GetByte[sH:dh];		    ENDLOOP;      		    		  END;	   86H => BEGIN -- iterated type record	            addr ¬ GetAddress[];		    recLength ¬ ExpandIteratedBlock[0, FALSE];		    SELECT codeSegment FROM		      LocalRam => bytesSeqPtr ¬  		        z.NEW[iopWrite DoveBoot.Block[recLength] ¬		    	  [blktype: DoveBoot.IOPWriteLocal, data: iopWrite[]]];		      MainMemory => bytesSeqPtr ¬ 			z.NEW[iopWrite DoveBoot.Block[recLength] ¬		    	  [blktype: DoveBoot.IOPWriteMain, data: iopWrite[]]];		      ENDCASE => Error ["Unknown code segment type"L];		    Stream.SetPosition[sH:dh, position: addrpos + 3];		    recLength ¬ ExpandIteratedBlock[0, TRUE];		  END;		               ENDCASE => LOOP;      [] ¬ Stream.GetByte[sH:dh];	-- skip chkSum byte      IF Inline.BITAND[recLength, Odd] = Odd THEN { -- odd byte count        bytesSeqPtr.length ¬ recLength + 1;	lastword ¬ Inline.BITAND[bytesSeqPtr[recLength], 0FF00];	bytesSeqPtr[recLength] ¬ Inline.BITOR[lastword, Noop186]}      ELSE        bytesSeqPtr.length ¬ recLength;      bytesSeqPtr.address ¬ addr;	          IF recLength # 0 THEN WriteToBoot[           out, bytesSeqPtr,           SIZE[iopWrite DoveBoot.Block[recLength]]];      z.FREE[@bytesSeqPtr];      count ¬ count + recLength;    ENDLOOP;    IF NOT MStream.EndOf[stream: dh] THEN      Error[" Extra garbage at end of loc file"L];    IF ignoreLocStart AND startAddrGiven THEN BEGIN      --If there are 2 rival start addresses, one from the loc file and one from the command line, use the one from the command line, but tell about it first.      Format.Line[tty, "Starting address in .loc file ignored."L];      Format.Text[tty, "Using address from command line:  "L];      Format.Number[tty, tempStart, [base: 16, zerofill: TRUE, columns: 4]];      Format.CR[tty];      END;    IF ignoreLocStart THEN BEGIN      iOPstartAddr ¬ tempStart;      END;          SELECT TRUE FROM      (IOPStartMode = init) AND (codeSegment = LocalRam) => BEGIN        IOPstartBlock.blktype ¬ DoveBoot.IOPInitializeLocal;	IOPstartBlock.address ¬ iOPstartAddr;	WriteToBoot[out, @IOPstartBlock, SIZE[iopAddr DoveBoot.Block]];	END;      (IOPStartMode = start) AND (codeSegment = LocalRam) => BEGIN        IOPstartBlock.blktype ¬ DoveBoot.IOPStartLocal;	IOPstartBlock.address ¬ iOPstartAddr;	WriteToBoot[out, @IOPstartBlock, SIZE[iopAddr DoveBoot.Block]]; 	END;      (IOPStartMode = init) AND (codeSegment = MainMemory) => BEGIN        IOPstartBlock.blktype ¬ DoveBoot.IOPInitializeMain;	IOPstartBlock.address ¬ iOPstartAddr;	WriteToBoot[out, @IOPstartBlock, SIZE[iopAddr DoveBoot.Block]];	END;      (IOPStartMode = start) AND (codeSegment = MainMemory) => BEGIN        IOPstartBlock.blktype ¬ DoveBoot.IOPStartMain;	IOPstartBlock.address ¬ iOPstartAddr;	WriteToBoot[out, @IOPstartBlock, SIZE[iopAddr DoveBoot.Block]]; 	END;      (IOPStartMode = none) AND (codeSegment = LocalRam) => BEGIN        IF startAddrGiven OR ignoreLocStart THEN BEGIN	  IOPstartBlock.blktype ¬ DoveBoot.IOPStartLocal;	  IOPstartBlock.address ¬ iOPstartAddr;	  WriteToBoot[out, @IOPstartBlock, SIZE[iopAddr DoveBoot.Block]];	  END;	END;      (IOPStartMode = none) AND (codeSegment = MainMemory) => BEGIN        IF startAddrGiven OR ignoreLocStart THEN BEGIN	  IOPstartBlock.blktype ¬ DoveBoot.IOPStartMain;	  IOPstartBlock.address ¬ iOPstartAddr;	  WriteToBoot[out, @IOPstartBlock, SIZE[iopAddr DoveBoot.Block]];	  END;	END;      ENDCASE => Error["Illegal value for IOPStartMode or codeSegment"L];          Heap.Delete[z:z];  END;--ProcessLoc--  ReleaseIn: PROCEDURE [in: POINTER TO InStuff] =    BEGIN    Heap.systemZone.FREE[@in.name];         -- also sets in.name ¬ NIL    IF in.sh # NIL THEN {Stream.Delete[in.sh]; in.sh ¬ NIL};    IF in.seg # NIL THEN {MSegment.Delete[in.seg]; in.seg ¬ NIL};    END;  -- end ReleaseIn proc  ReleaseOut: PROCEDURE [out: POINTER TO OutStuff] =    BEGIN    IF out.sh # NIL THEN {Stream.Delete[out.sh]; out.sh ¬ NIL};    CloseTsFile[out];    Heap.systemZone.FREE[@out.name];         -- also sets out.name ¬ NIL    END;  -- end ReleaseOut proc  SetInMode: PROCEDURE [in: POINTER TO InStuff] =    BEGIN    mode: InMode;    extNames: ARRAY InMode OF STRING = [".fb", ".loc", ".db"];    ext: LONG STRING ¬ [5];    GetExtension[in.name, ext];    FOR mode IN InMode DO      IF String.Equivalent[ext, extNames[mode]] THEN EXIT      REPEAT FINISHED => Error[" Illegal input file extension "L]      ENDLOOP;    in.mode ¬ mode;    END;  -- end SetInMode proc  SwapBytes: PROCEDURE [p: LONG POINTER] = INLINE {    temp: WORD = Inline.BITSHIFT[p­, 8];    p­ ¬ Inline.BITOR[temp, Inline.HighByte[p­]];    };      WriteToBoot: PROCEDURE [    out: POINTER TO OutStuff, p: LONG POINTER, c: CARDINAL] =    BEGIN            out.checksum ¬ MoreChecksum[out.checksum, p, c];        out.lengthOfFile ¬ out.lengthOfFile + c;        Stream.PutBlock[          sH: out.sh,          block: [          blockPointer: p, startIndex: 0,          stopIndexPlusOne: Environment.bytesPerWord*c], endRecord: FALSE];        out.byteAddress ¬ out.byteAddress + Environment.bytesPerWord*c;    END;              Help:Exec.ExecProc =    BEGIN    OutputProc: Format.StringProc ¬ Exec.OutputProc[h];    h.OutputProc[][    "        MakeDoveMicroBoot -- facilitiesMakeDoveMicroBoot is a Mesa program which combines 80186 object code files and/or microcode object files into a single file whose format is known to the Dove bootloader. It is invoked via the Tajo Executive; the format of a command line isMakeDoveMicroBoot <outfile> _ <infile/sw> [<infile/sw>] ...where <outfile> is the name of the output file (suffixed by "".db"" if no extension is supplied), and <infile/sw> is the name of an input file followed by optional switches. Any number of input files may be supplied, and they are put into the output file in order of appearance. Input file types are identified by the filename extension. Valid types and switches are as follows:"L];h.OutputProc[]["Microcode object files (extension = "".fb""): either Daybreak or Daisy format microcode object files can be loaded. Four classes of switch characters are supported:  A ""B"" indicates that the following number is a bank number.  Thus B0 implies the first bank, and B1 implies the second bank.  A ""C"" indicates that the following number is a bank count.  This is used by booting to detemine if the microcode object file should be loaded or ignored.  Booting will read the EEProm to determine the number of 4K banks of control store it has.  If it has only one bank it will ignore microcode object files that were formatted by MakeDoveMicroBoot with the C2 switch.  It will load microcode object files with the C0 or C2 switches.  Similarly if a machine has 2 banks it will ignore C1 files and load only C2 and C0 files.  C0 is the default and provides backward compatability.  The C switch is used to allow microcode for machines with different numbers of banks to live in the same MesaDove.db file.  A machine identifier (""K"" for Daybreak or ""Y"" for Daisy) tells which microcode format is contained in the file; a start mode character (""I"" for initialization or ""S"" for system) indicates whether the file contains initialization code which will terminate, or operating system code which will continue to run. Defaults are bank 0, C0 (load regarless of EEProm contents), Daybreak format, and no start mode (microcode will be loaded but not executed).  Note that I and S switches on Daybreak microcode will not be handled correctly by booting."L];h.OutputProc[]["80186 object code files (extension = "".loc""): absolute-location 80186 object code files can be loaded. There are 3 kinds of switches for loc files:  a code segment specifier, m or l.  The m switch says the given module should be loaded into main memory.  The l switch which is the default says it should be loaded into local ram.  If a hexadecimal number is present it is taken to be the address where code execution should start.  It will override any start address given in the module.  The S and I switches used for microcode object files have the same meaning for loc files.  Do not use more than one S switch."L];h.OutputProc[]["MicroBoot files (extension = "".db""): files previously created by MakeDoveMicroBoot may be combined into a single file, prefixed by a table of offsets to the starting locations of each db. Switches are ignored. Files with extension "".db"" may not be combined with files of any other type.  While MakeDoveMicroBoot will not have trouble with the recursive application of this feature, booting may well die.  Therefore make sure that any db files you feed to MakeDoveMicroBoot are combinations of loc and fb files not combinations of db files.MakeDoveMicroBoot also creates a file with the same name as the output file but with the extension "".ts"". This file contains the file names and create dates for all of the input files and the output file. It also contains the switches used for each input file.A run can be prematurely aborted by hitting the stop key."L];   END;               --main line code  Init[];  END...
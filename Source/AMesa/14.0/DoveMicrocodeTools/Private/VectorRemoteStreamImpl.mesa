-- VectorRemoteStreamImpl.mesa-- Copyright (C) 1984, Xerox Corporation.  All rights reserved.-- Michael Plass, 	14-Sep-84 14:48:44-- jAC   CxC   		16-Jan-85 11:42:54	 DIRECTORY Stream, STP, VectorRemoteStream, String;	VectorRemoteStreamImpl: PROGRAM  IMPORTS STP, String, Stream  EXPORTS VectorRemoteStream =  BEGIN		    Error: PUBLIC ERROR [expl: LONG STRING, retryable: BOOL] = CODE;		    Retryable: PROC [code: STP.ErrorCode] RETURNS [BOOL] = {	      RETURN [SELECT code FROM connectionTimedOut, connectionRejected, 	                         connectionClosed, noConnection, noNameLookupResponse =>                       TRUE, ENDCASE => FALSE]	};		    Lookup: PUBLIC PROC [fileName: LONG STRING, createDate: LONG STRING,                         name, password: LONG STRING] RETURNS [bytes: INT] = {      bytes _ MyLookup[fileName, createDate, name, password !      STP.Error => {ERROR Error[expl: error, retryable: Retryable[code]]};];      };			  ParseName: PUBLIC PROC [fileName, server, rest: LONG STRING] = {    state: NAT _ 0;    charType: NAT;    server.length _ 0;    rest.length _ 0;    FOR i: NAT IN [0..fileName.length) DO      c: CHAR _ fileName[i];      SELECT c FROM	'[ => charType _ 0;	'/ => charType _ 1;	'] => charType _ 2;	'< => charType _ 3;	'> => charType _ 4;	'! => charType _ 5;	IN ['0..'9], IN ['a..'z], IN ['A..'Z] => charType _ 6;	'-, '+, '$, '., '' => charType _ 6;	ENDCASE => Error[expl: "Illegal character in filename", retryable: FALSE];      SELECT state*7+charType FROM	0*7+0 => state _ 1;	0*7+1 => state _ 7;	1*7+6 => {server[server.length] _ c; server.length _ server.length + 1};	1*7+2 => state _ 2;	2*7+1,	2*7+3,	2*7+6 => {state _ 3; rest[rest.length] _ c;	          rest.length _ rest.length + 1};	3*7+6,	3*7+1,	3*7+4 => {rest[rest.length] _ c; rest.length _ rest.length + 1};	3*7+5 => {state _ 4; rest[rest.length] _ c;	          rest.length _ rest.length + 1};	4*7+6 => {rest[rest.length] _ c;	          rest.length _ rest.length + 1; 		  IF c IN ['0..'9] THEN state _ 5		  ELSE IF c = 'l OR c = 'L OR c = 'h OR c='H THEN state _ 6		  ELSE state _ 9};	5*7+6 => {rest[rest.length] _ c; rest.length _ rest.length + 1;					IF c NOT IN ['0..'9] THEN state _ 9					};	7*7+6 => {server[server.length] _ c; server.length _ server.length + 1};	7*7+1 => {state _ 8; rest[rest.length] _ c; 	          rest.length _ rest.length + 1};	7*8+6 => {rest[rest.length] _ c; rest.length _ rest.length + 1};	7*8+1 => {rest[rest.length] _ c; rest.length _ rest.length + 1};	7*8+5 => {state _ 4; rest[rest.length] _ c; 	          rest.length _ rest.length + 1};	ENDCASE => Error[expl: "Illegal filename", retryable: FALSE];	ENDLOOP;      SELECT state FROM	3, 8 => {rest[rest.length] _ '!;	         rest[rest.length+1] _ 'H;		 rest.length _ rest.length + 2};	5, 6 => NULL;	ENDCASE => Error[expl: "Illegal filename", retryable: FALSE];	};			  MyLookup: PROC [fileName, createDate, name, password: LONG STRING]             RETURNS [bytes: INT _ 0] = {    server: LONG STRING _ [80];    rest: LONG STRING _ [80];    stp: STP.Handle _ NIL;    open: BOOL _ FALSE;    expandedName: LONG STRING _ [80];    success: BOOLEAN _ FALSE;    NoteFileProc: STP.NoteFileProcType = {      fileInfo: STP.FileInfo _ stp.GetFileInfo[];      continue _ no;      success _ TRUE;      String.AppendString[expandedName, file];      bytes _ fileInfo.size;      String.Copy[to: createDate, from: fileInfo.create];      };    ParseName[fileName, server, rest];    stp _ STP.Create[];    BEGIN ENABLE UNWIND => {			-- IF open THEN stp.Close[ ! STP.Error => {CONTINUE}];			stp _ stp.Destroy			};			desiredProps: STP.DesiredProperties _ ALL[FALSE];			desiredProps[directory] _ TRUE;			desiredProps[nameBody] _ TRUE;			desiredProps[version] _ TRUE;			desiredProps[createDate] _ TRUE;			desiredProps[size] _ TRUE;			String.AppendChar[expandedName, '[ ];			String.AppendString[expandedName, server];			String.AppendChar[expandedName, '] ];			[] _ stp.Open[server];			open _ TRUE;			stp.Login[name, password];			stp.SetDesiredProperties[desiredProps];			stp.Enumerate[rest, NoteFileProc];			-- stp.Close[ ! STP.Error => {CONTINUE}];			END;		stp _ stp.Destroy;		IF success THEN {String.Copy[to: fileName, from: expandedName]}		ELSE Error[expl: "File not found", retryable: FALSE];		};			Read: PUBLIC PROC [fileName: LONG STRING, name, password: LONG STRING, action: PROC[Stream.Handle]] = {		MyRead[fileName, name, password, action !			STP.Error => {				ERROR Error[expl: error, retryable: Retryable[code]]				};			];		};			MyRead: PROC [fileName: LONG STRING, name, password: LONG STRING, action: PROC[Stream.Handle]] = {		server: LONG STRING _ [80];		rest: LONG STRING _ [80];		stp: STP.Handle _ NIL;		open: BOOL _ FALSE;		stream: Stream.Handle _ NIL;		ParseName[fileName, server, rest];		stp _ STP.Create[];		BEGIN ENABLE UNWIND => {			-- IF open THEN stp.Close[ ! STP.Error => {CONTINUE}];			IF stream # NIL THEN {stream.Delete; stream _ NIL};			stp _ stp.Destroy;			};			[] _ stp.Open[server];			open _ TRUE;			stp.Login[name, password];			stream _ stp.CreateRemoteStream[rest, read];			action[stream];			-- stp.Close[ ! STP.Error => {CONTINUE}];			END;		stream.Delete;		stream _ NIL;		stp _ stp.Destroy;		};			END.
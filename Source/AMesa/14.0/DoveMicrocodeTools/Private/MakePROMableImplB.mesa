-- MakePROMableImplB.mesa-- created by DEG on 14-Apr-85 20:32:25-- edited by DEG on 16-Apr-85  2:34:06-- Copyright (C) 1985 by Xerox Corporation.  All rights reserved.DIRECTORY  Environment USING [Byte, bytesPerPage],  Format USING [Char, Number, StringProc],  Inline USING [HighByte, LowByte],  MakePROMableDef USING [DataHandle, ROMImagePointer],  MSegment USING [Address, Create, Delete],  MStream USING [Handle, ReadOnly, SetLength, WriteOnly],  Stream USING [Delete, GetChar, GetPosition, PutString];MakePROMableImplB: PROGRAM  IMPORTS Format, Inline, MSegment, MStream, Stream  EXPORTS MakePROMableDef =  BEGIN    RecordType: TYPE = MACHINE DEPENDENT {data(0), endOfFile(1), address(2), last(0FFH)};    bytesPerLine: NATURAL = 16;    ASCIIHexToDecimal: PRIVATE PROCEDURE [char: CHARACTER] RETURNS [digit: [0..16)] =    BEGIN      SELECT char FROM       IN ['a..'f] => digit ¬ (char - 'a) + 10;       IN ['A..'F] => digit ¬ (char - 'A) + 10;       IN ['0..'9] => digit ¬ (char - '0);      ENDCASE => ERROR;    END;    ConvertFile: PUBLIC PROCEDURE [handle: MakePROMableDef.DataHandle] =    BEGIN      oneKBytes: CARDINAL = 1024;      bytesInFile: CARDINAL ¬ handle.numberOfKBytes * oneKBytes;            handle.segment ¬ MSegment.Create[file: NIL, release: [proc: NIL, clientInstanceData: NIL], fileBase: 0, pages: bytesInFile / Environment.bytesPerPage + 1];      handle.imageOfROM ¬ MSegment.Address[segment: handle.segment];            ZeroROMImage[handle: handle, fileSize: bytesInFile];      ReadROMImage[handle: handle];      WriteROMImage[handle: handle, fileSize: bytesInFile];            MSegment.Delete[segment: handle.segment];      handle.segment ¬ NIL;      handle.imageOfROM ¬ NIL;    END;    ReadLineFromStream: PRIVATE PROCEDURE [stream: MStream.Handle, handle: MakePROMableDef.DataHandle] RETURNS[endOfFile: BOOLEAN ¬ FALSE] =    BEGIN      colonCheck: CHARACTER ¬ Stream.GetChar[sH: stream];      byteCount: NATURAL ¬ ASCIIHexToDecimal[char: Stream.GetChar[sH: stream]] * 16 + ASCIIHexToDecimal[char: Stream.GetChar[sH: stream]];      offset: CARDINAL ¬ ((ASCIIHexToDecimal[char: Stream.GetChar[sH: stream]] * 16 + ASCIIHexToDecimal[char: Stream.GetChar[sH: stream]]) * 16 + ASCIIHexToDecimal[char: Stream.GetChar[sH: stream]]) * 16 + ASCIIHexToDecimal[char: Stream.GetChar[sH: stream]];      type: RecordType ¬ VAL[ASCIIHexToDecimal[char: Stream.GetChar[sH: stream]] * 16 + ASCIIHexToDecimal[char: Stream.GetChar[sH: stream]]];      checksum: CARDINAL ¬ byteCount + Inline.HighByte[offset] + Inline.LowByte[offset] + VAL[type];      incomingData: PACKED ARRAY [0..16) OF Environment.Byte;      checksumValue: Environment.Byte;            IF colonCheck # ': THEN ERROR;            FOR index: NATURAL IN [0..byteCount) DO        value: Environment.Byte;        incomingData[index] ¬ value ¬ ASCIIHexToDecimal[char: Stream.GetChar[sH: stream]] * 16 + ASCIIHexToDecimal[char: Stream.GetChar[sH: stream]];	checksum ¬ checksum + value;      ENDLOOP;      checksumValue ¬ ASCIIHexToDecimal[char: Stream.GetChar[sH: stream]] * 16 + ASCIIHexToDecimal[char: Stream.GetChar[sH: stream]];      checksum ¬ checksum + checksumValue;      IF Inline.LowByte[checksum] # 0 THEN ERROR;            SELECT type FROM        data => 	  BEGIN	  base: CARDINAL ¬ handle.offsetInROMImage + offset;	  FOR index: NATURAL IN [0..byteCount) DO	    handle.imageOfROM[base + index] ¬ incomingData[index];	  ENDLOOP;	  END;	address => 	  BEGIN	  address: LONG CARDINAL ¬ (incomingData[0] * 100H + incomingData[1]) * 10H;	  handle.offsetInROMImage ¬ CARDINAL[address - handle.baseOfROMImage];	  END;	endOfFile => endOfFile ¬ TRUE;      ENDCASE => ERROR;                  IF Stream.GetChar[sH: stream] # '\n THEN ERROR;      IF Stream.GetChar[sH: stream] # '\l THEN ERROR;    END;    ReadROMImage: PRIVATE PROCEDURE [handle: MakePROMableDef.DataHandle] =    BEGIN      handle.stream ¬ MStream.ReadOnly[name: handle.inputFile, release: [proc: NIL, clientInstanceData: NIL]];            UNTIL ReadLineFromStream[stream: handle.stream, handle: handle] DO        NULL;      ENDLOOP;            Stream.Delete[sH: handle.stream];      handle.stream ¬ NIL;    END;      WriteHeaderToStream: PRIVATE PROCEDURE [handle: MakePROMableDef.DataHandle] =    BEGIN      address: CARDINAL ¬ CARDINAL[handle.baseOfROMImage/16];      addressPtr: LONG POINTER TO CARDINAL ¬ @address;      WriteLineToStream[stream: handle.stream, byteCount: 2, offset: 0, imagePtr: LOOPHOLE[addressPtr], type: address];    END;    WriteLineToStream: PRIVATE PROCEDURE [stream: MStream.Handle, byteCount: NATURAL, offset: CARDINAL, imagePtr: MakePROMableDef.ROMImagePointer, type: RecordType ¬ data] =    BEGIN      Write: Format.StringProc =        BEGIN	  Stream.PutString[sH: stream, string: s]	END;	      checksum: CARDINAL ¬ byteCount + Inline.HighByte[offset] + Inline.LowByte[offset] + VAL[type];            Format.Char[proc: Write, char: ':, clientData: NIL];      Format.Number[n: byteCount, format: [base: 16, zerofill: TRUE, unsigned: TRUE, columns: 2], proc: Write, clientData: NIL];      Format.Number[n: offset, format: [base: 16, zerofill: TRUE, unsigned: TRUE, columns: 4], proc: Write, clientData: NIL];      Format.Number[n: VAL[type], format: [base: 16, zerofill: TRUE, unsigned: TRUE, columns: 2], proc: Write, clientData: NIL];            FOR index: NATURAL IN [0..byteCount) DO        value: Environment.Byte ¬ imagePtr[index+offset];	        checksum ¬ checksum + value;	Format.Number[n: value, format: [base: 16, zerofill: TRUE, unsigned: TRUE, columns: 2], proc: Write, clientData: NIL];      ENDLOOP;            Format.Number[n: Inline.LowByte[100H - Inline.LowByte[checksum]], format: [base: 16, zerofill: TRUE, unsigned: TRUE, columns: 2], proc: Write, clientData: NIL];      Stream.PutString[sH: stream, string: "\n\l"L];    END;    WriteTrailerToStream: PRIVATE PROCEDURE [handle: MakePROMableDef.DataHandle] =    BEGIN      address: CARDINAL ¬ 0;      addressPtr: LONG POINTER TO CARDINAL ¬ @address;      WriteLineToStream[stream: handle.stream, byteCount: 0, offset: 0, imagePtr: LOOPHOLE[addressPtr], type: endOfFile];    END;    WriteROMImage: PRIVATE PROCEDURE [handle: MakePROMableDef.DataHandle, fileSize: CARDINAL] =    BEGIN      index: CARDINAL ¬ 0;      handle.stream ¬ MStream.WriteOnly[name: handle.outputFile, release: [proc: NIL, clientInstanceData: NIL], type: text];            WriteHeaderToStream[handle: handle];            UNTIL index = fileSize DO        WriteLineToStream[stream: handle.stream, byteCount: bytesPerLine, offset: index, imagePtr: handle.imageOfROM, type: data];        index ¬ index + bytesPerLine;      ENDLOOP;            WriteTrailerToStream[handle: handle];            MStream.SetLength[stream: handle.stream, fileLength: Stream.GetPosition[sH: handle.stream]];      Stream.Delete[sH: handle.stream];      handle.stream ¬ NIL;    END;    ZeroROMImage: PRIVATE PROCEDURE [handle: MakePROMableDef.DataHandle, fileSize: CARDINAL] =    BEGIN      FOR index: CARDINAL IN [0..fileSize) DO        handle.imageOfROM[index] ¬ 0;      ENDLOOP;    END;      END...    created by DEG on 14-Apr-85 20:32:25  edited by DEG on 16-Apr-85  0:27:24
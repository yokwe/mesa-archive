-- File: IOPBKernelImpl.mesa - last edit:-- Bowers.PA            4-Aug-86 12:58:49-- JAC           27-Aug-85 12:51:19	added SHARES DoveInputOutput-- Copyright (C) 1984, 1985, 1986 by Xerox Corporation. All rights reserved.-- after IOPBKerneler.mesa, HGM,  4-Oct-83 23:31:04DIRECTORY  Bindweed,  DoveInputOutput,  Environment USING [Byte],  Heap USING [systemZone],  Inline,  I186 USING [Address, Register, IOPort],  IOPB USING [AddressType, Error, Processor],  IOPBKernel;IOPBKernelImpl: MONITOR   IMPORTS Bindweed, DoveInputOutput, Heap, Inline, IOPB   EXPORTS IOPBKernel   SHARES DoveInputOutput =  BEGIN    RegisterArray: TYPE = ARRAY [0..I186.Register.LAST.ORD] OF WORD ¬ ALL[0];  registers: ARRAY IOPB.Processor OF RegisterArray ¬ ALL [];  maxAddress: LONG CARDINAL = 0FFFFFH;  state: IOPBKernel.State ¬ dead;  sequence: LONG POINTER TO Bindweed.Sequence ¬ NIL;  BeSureInKernel: INTERNAL PROC =    BEGIN    SELECT state FROM      dead => ERROR IOPB.Error[dead];      booted, halted, singleStep => NULL;      running => ERROR IOPB.Error[running];      iopBreak => NULL;      ENDCASE => NULL;  -- ERROR;    END;  Boot: PUBLIC ENTRY PROC = {    ENABLE UNWIND => NULL;    SetNewState[dead];    Bindweed.Boot[];    SetNewState[booted];    };  Continue: PUBLIC ENTRY PROC =    BEGIN    ENABLE { UNWIND => NULL};    BeSureInKernel[];    Bindweed.Continue;    SetNewState[running];    END;  GetState: PUBLIC ENTRY PROC RETURNS [IOPBKernel.State] =    BEGIN ENABLE UNWIND => NULL; RETURN[state]; END;  InKernel: PUBLIC ENTRY PROC RETURNS [BOOLEAN] =    BEGIN    ENABLE UNWIND => NULL;    RETURN[      SELECT state FROM        dead, running => FALSE,        booted, halted, singleStep, iopBreak => TRUE,        ENDCASE => ERROR];    END;  ReadIOByte: PUBLIC ENTRY PROC [port: I186.IOPort]    RETURNS [data: Environment.Byte] = {    ENABLE UNWIND => NULL; BeSureInKernel[]; data ¬ Bindweed.ReadIOByte[port]; };  ReadIOWord: PUBLIC ENTRY PROC [port: I186.IOPort] RETURNS [data: WORD] = {    ENABLE UNWIND => NULL; BeSureInKernel[]; data ¬ Bindweed.ReadIOWord[port]; };  ReadMemoryDataSequence: PUBLIC ENTRY PROC [    address: I186.Address, addressType: IOPB.AddressType,    data: LONG POINTER TO Bindweed.Sequence] = {    ENABLE UNWIND => NULL;    address ¬ ConvertAddress[address, addressType];    Bindweed.ReadMemoryBlock[      address: address,      addressType: IF addressType = iop THEN iOPLogical ELSE pCLogical,      sequence: data];    };  ReadMemoryByte: PUBLIC ENTRY PROC [    address: I186.Address, addressType: IOPB.AddressType]    RETURNS [data: Environment.Byte ¬ 0] =    BEGIN    ENABLE UNWIND => {      IF sequence # NIL THEN Heap.systemZone.FREE[@sequence]};    sequence ¬ Heap.systemZone.NEW[      Bindweed .Sequence[1] ¬ [length: 1, seq: NULL]];    address ¬ ConvertAddress[address, addressType];    BeSureInKernel[];    Bindweed.ReadMemoryBlock[      address: address,      addressType: IF addressType = iop THEN iOPLogical ELSE pCLogical,      sequence: sequence];    data ¬ sequence[0];    Heap.systemZone.FREE[@sequence];    END;  ReadMemoryWord: PUBLIC ENTRY PROC [    address: I186.Address, addressType: IOPB.AddressType]    RETURNS [data: WORD ¬ 0] =    BEGIN    ENABLE UNWIND => {      IF sequence # NIL THEN Heap.systemZone.FREE[@sequence]};    sequence ¬ Heap.systemZone.NEW[      Bindweed .Sequence[2] ¬ [length: 2, seq: NULL]];    address ¬ ConvertAddress[address, addressType];    BeSureInKernel[];    Bindweed.ReadMemoryBlock[      address: address,      addressType: IF addressType = iop THEN iOPLogical ELSE pCLogical,      sequence: sequence];    data ¬ sequence[0] + 256 * sequence[1];    Heap.systemZone.FREE[@sequence];    END;  ReadPC: PUBLIC ENTRY PROC [processor: IOPB.Processor]    RETURNS [pc: I186.Address] = {    ENABLE UNWIND => NULL;    pc ¬      LONG[registers[processor][ORD[I186.Register.CS]]] * 16 +      registers[processor][ORD[I186.Register.IP]];    };  ReadRegister: PUBLIC ENTRY PROC [reg: I186.Register, processor: IOPB.Processor]    RETURNS [data: WORD] = {    ENABLE UNWIND => NULL; BeSureInKernel[];    data ¬ registers[processor][ORD[reg]]};  ReadSavedRegisters: PUBLIC ENTRY PROC [processor: IOPB.Processor] = {    ENABLE UNWIND => NULL;    address: I186.Address;    registerSeq: LONG POINTER TO Bindweed.Sequence ¬ Heap.systemZone.NEW[      Bindweed .Sequence[2 * (I186.Register.LAST.ORD + 1)] ¬ [      length: 2 * (I186.Register.LAST.ORD + 1), seq: NULL]];    address ¬ SELECT processor FROM      iop => IOPBKernel.savedRegistersAddress[iop],      pc => ConvertAddress[IOPBKernel.savedRegistersAddress[pc], pc],      ENDCASE => ERROR;    Bindweed.ReadMemoryBlock[      address: address,      addressType: IF processor = iop THEN iOPLogical ELSE pCLogical,      sequence: registerSeq];    FOR i: CARDINAL IN [0..I186.Register.LAST.ORD] DO      registers[processor][i]         ¬ registerSeq[2 * i] + (registerSeq[2 * i + 1] * 256); ENDLOOP;    Heap.systemZone.FREE[@registerSeq];    };  SetNewState: INTERNAL PROC [newState: IOPBKernel.State] =    BEGIN state ¬ newState; END;  SetState: PUBLIC ENTRY PROC [newState: IOPBKernel.State] = {    ENABLE UNWIND => NULL;    SetNewState[newState]; };  Stop: PUBLIC ENTRY PROC [processor: IOPB.Processor] = {    ENABLE UNWIND => NULL;    SELECT state FROM      booted, halted, iopBreak, singleStep =>        ERROR IOPB.Error[notRunning];      running, dead => NULL;      ENDCASE => ERROR;    <<IF ~Umbilical.ReadReady[] THEN {  -- possible race condition here>>    SELECT processor FROM      iop => Bindweed.StopIOP[];      pc => Bindweed.StopPC[];      ENDCASE => ERROR;    -- should wait until get response to set state to halted     };  WriteIOByte: PUBLIC ENTRY PROC [port: I186.IOPort, data: Environment.Byte] = {    ENABLE UNWIND => NULL; BeSureInKernel[]; Bindweed.WriteIOByte[port, data]; };  WriteIOWord: PUBLIC ENTRY PROC [port: I186.IOPort, data: WORD] = {    ENABLE UNWIND => NULL; BeSureInKernel[]; Bindweed.WriteIOWord[port, data]; };  WriteMemoryByte: PUBLIC ENTRY PROC [    address: I186.Address, addressType: IOPB.AddressType,    data: Environment.Byte] =    BEGIN    ENABLE UNWIND => {      IF sequence # NIL THEN Heap.systemZone.FREE[@sequence]};    sequence ¬ Heap.systemZone.NEW[      Bindweed .Sequence[1] ¬ [length: 1, seq: NULL]];    address ¬ ConvertAddress[address, addressType];    BeSureInKernel[];    sequence[0] ¬ data;    Bindweed.WriteMemoryBlock[      address: address,      addressType: IF addressType = iop THEN iOPLogical ELSE pCLogical,      sequence: sequence];    Heap.systemZone.FREE[@sequence];    END;  WriteMemoryWord: PUBLIC ENTRY PROC [    address: I186.Address, addressType: IOPB.AddressType, data: WORD] =    BEGIN    ENABLE UNWIND => {      IF sequence # NIL THEN Heap.systemZone.FREE[@sequence]};    sequence ¬ Heap.systemZone.NEW[      Bindweed .Sequence[2] ¬ [length: 2, seq: NULL]];    address ¬ ConvertAddress[address, addressType];    BeSureInKernel[];    sequence[0] ¬ data MOD 256;    sequence[1] ¬ data / 256;    Bindweed.WriteMemoryBlock[      address: address,      addressType: IF addressType = iop THEN iOPLogical ELSE pCLogical,      sequence: sequence];    Heap.systemZone.FREE[@sequence];    END;  WriteMemoryDataSequence: PUBLIC ENTRY PROC [    address: I186.Address, addressType: IOPB.AddressType,    data: LONG POINTER TO Bindweed.Sequence] = {    ENABLE UNWIND => NULL;    start, length: NATURAL ¬ 0;    address ¬ ConvertAddress[address, addressType];    Bindweed.WriteMemoryBlock[      address: address,      addressType: IF addressType = iop THEN iOPLogical ELSE pCLogical,      sequence: data];    };  WriteRegister: PUBLIC ENTRY PROC [    reg: I186.Register, data: WORD, processor: IOPB.Processor] = {    ENABLE UNWIND => NULL; BeSureInKernel[];    registers[processor][ORD[reg]] ¬ data};  WriteSavedRegisters: PUBLIC ENTRY PROC [processor: IOPB.Processor] = {    ENABLE UNWIND => NULL;    address: I186.Address;    registerSeq: LONG POINTER TO Bindweed.Sequence ¬ Heap.systemZone.NEW[      Bindweed .Sequence[2 * (I186.Register.LAST.ORD + 1)] ¬ [      length: 2 * (I186.Register.LAST.ORD + 1), seq: NULL]];    regs: LONG POINTER TO RegisterArray ¬ @registers[processor];    FOR i: CARDINAL IN [0..I186.Register.LAST.ORD] DO      registerSeq[2 * i] ¬ regs[i] MOD 256;      registerSeq[2 * i + 1] ¬ regs[i] / 256;      ENDLOOP;    address ¬ SELECT processor FROM      iop => IOPBKernel.savedRegistersAddress[iop],      pc => ConvertAddress[IOPBKernel.savedRegistersAddress[pc], pc],      ENDCASE => ERROR;    Bindweed.WriteMemoryBlock[      address: address,      addressType: IF processor = iop THEN iOPLogical ELSE pCLogical,      sequence: registerSeq];    Heap.systemZone.FREE[@registerSeq];    };  ConvertAddress: PROC [address: I186.Address, addressType: IOPB.AddressType]    RETURNS [convertedAddr: I186.Address] = {    OPEN DIO: DoveInputOutput;    opieAddress: DIO.OpieAddress ¬ [      A15toA0: LOOPHOLE[DIO.OldByteSwap[Inline.LowHalf[address]]],      A23toA16: Inline.HighHalf[address] MOD 256,      type:      SELECT addressType FROM        iop => iopLogical,        pc => pcLogical,        real => extendedBus,        vm => virtualWord,        ENDCASE => ERROR];    SELECT addressType FROM      iop, pc => IF address > 0FFFFFH THEN IOPB.Error[addressOutOfRange];      real, vm => IF address > 0FFFFFFH THEN IOPB.Error[addressOutOfRange];      ENDCASE => ERROR;	    IF addressType = iop THEN convertedAddr ¬ address ELSE    convertedAddr ¬ LOOPHOLE[opieAddress]};  END.
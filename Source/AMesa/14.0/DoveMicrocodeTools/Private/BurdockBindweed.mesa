-- File: BurdockBindweed.mesa - last edit:-- FXB   .PA            4-Jun-85 17:11:22-- Copyright (C) 1984, 1985  by Xerox Corporation. All rights reserved. -- BurdockBindweed.mesa created by Dennis E. DEG      on 20-Feb-84  6:59:30-- last edited by Dennis DEG      on  13-Feb-85  2:39:16DIRECTORY  Bindweed,  << BitSW USING [Type], >>  FileSW USING [GetFile],  Format USING [Char, LongNumber, Number, StringProc],  FormSW,  Inline USING [    BITAND, BITNOT, BITOR, BITSHIFT, DBITAND, DBITSHIFT, HighByte, HighHalf,    LowByte, LowHalf],  MsgSW USING [PostAndLog],  MStream USING [Handle, SetLogReadLength],  SimpleDisplayer USING [    AllocateBitSWSpace, AnotherInstance, ChoicePtr, DataHandle, DataSequence,         EnumerateItems, ItemHandle, Lock, Paint, ReclaimBitSWSpace, Share, SwapState,    UnLock, zone],  Process USING [Detach],  Put USING [Line, LongNumber, Number, Text],  Runtime,  Scrollbar USING [WindowNowEnlinked],  String USING [AppendString, Empty],  TextSW USING [GetEOF, PositionIsVisible, SetPosition],  Time USING [AppendCurrent],  Token USING [    FreeStringHandle, FreeTokenString, Handle, MaybeQuoted, StringToHandle,    SyntaxError],  Tool USING [AddThisSW, DeleteThisSW, MakeFormSW],  ToolWindow USING [ << CreateSubwindow, >> Destroy, WindowForSubwindow],  UserTerminal USING [BlinkDisplay],  Window USING [Box, Handle, nullBox];BurdockBindweed: MONITOR  IMPORTS    Bindweed, << BitSW, >> FileSW, Format, FormSW, Inline, MsgSW, MStream, Process,    Put, Runtime, Scrollbar, SimpleDisplayer, String, TextSW, Time, Token, Tool, ToolWindow, UserTerminal  EXPORTS SimpleDisplayer =  {  MaskArray: ARRAY [0..8) OF CARDINAL = [1, 3, 7, 15, 31, 63, 127, 255];  backSpaceLevelIV: CHARACTER = '\301;  backWordLevelIV: CHARACTER = '\302;  backSpaceADM3a: CHARACTER = '\010;  << Control-h >>    iopUpNotifyIndex: CARDINAL = 3;  junkNumber: LONG UNSPECIFIED ¬ 0;  hexNumberString: LONG STRING ¬ [8];  decimalNumberString: LONG STRING ¬ [11];  octalNumberString: LONG STRING ¬ [11];  FormItems: TYPE = {    refreshDisplay, modifyData, displayRecord, writeToLog, another, revert,    recordSizeDecimal, processor, address, hexValue, decimalValue,    octalValue};  DummyCommandProc: FormSW.ProcType = {    wh: Window.Handle ¬ ToolWindow.WindowForSubwindow[sw: sw];    instance: SimpleDisplayer.DataHandle = SimpleDisplayer.Lock[wh: wh];    WriteErrorMessage[      instance: instance,      msg:      "This is a dummy command PROCEDURE!\nCommand items should not be placed in IOCB formSWs!"L];    SimpleDisplayer.UnLock[wh: wh]};  StringSequence: TYPE = RECORD [seq: SEQUENCE n: CARDINAL OF LONG STRING];  StringsFromString: PROCEDURE [s: LONG STRING, z: UNCOUNTED ZONE]    RETURNS [ss: LONG POINTER TO StringSequence] = {    h: Token.Handle ¬ Token.StringToHandle[s: s, offset: 0];    n: CARDINAL ¬ 0;    DO      temp: LONG STRING ¬ Token.MaybeQuoted[        h: h, data: NIL ! Token.SyntaxError => EXIT];      IF String.Empty[temp] THEN EXIT;      [] ¬ Token.FreeTokenString[temp];      n ¬ n + 1;      ENDLOOP;    ss ¬ z.NEW[StringSequence [n]];    [] ¬ Token.FreeStringHandle[h];    h ¬ Token.StringToHandle[s: s, offset: 0];    FOR i: CARDINAL IN [0..n) DO      ss[i] ¬ Token.MaybeQuoted[h: h, data: NIL]; ENDLOOP;    [] ¬ Token.FreeStringHandle[h];    };  FreeStrings: PROCEDURE [ss: LONG POINTER TO StringSequence, z: UNCOUNTED ZONE] =    {    FOR i: CARDINAL IN [0..ss.n) DO ss[i] ¬ Token.FreeTokenString[ss[i]] ENDLOOP;    z.FREE[@ss];    };  WriteErrorMessage: PROCEDURE [    instance: SimpleDisplayer.DataHandle, msg: LONG STRING] = INLINE {    MsgSW.PostAndLog[sw: instance.msgSW, string: msg, logSW: instance.fileSW]; };  MakeClientForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    wh: Window.Handle ¬ ToolWindow.WindowForSubwindow[sw: sw];    instance: SimpleDisplayer.DataHandle = SimpleDisplayer.Share[wh: wh];    count: CARDINAL ¬ 0;    endWord: CARDINAL;    BuildItemProc: PROCEDURE [      item: SimpleDisplayer.ItemHandle, Write: Format.StringProc,      instance: SimpleDisplayer.DataHandle ¬ NIL] = {      OPEN FormSW;      endWord ¬        item.word + (item.startingBitPostion + item.bitsOccupied + 15) / 16;      IF endWord > instance.recordSizeDecimal THEN        instance.recordSizeDecimal ¬ endWord;      WITH item SELECT FROM        boolean => {          items[count] ¬ BooleanItem[            tag: tag, place: box.place, readOnly: readOnly, invisible: invisible,            drawBox: drawBox, switch: @toyBoolean, z: SimpleDisplayer.zone]};        command => {          items[count] ¬ CommandItem[            tag: tag, place: box.place, readOnly: readOnly, invisible: invisible,            drawBox: drawBox, proc: DummyCommandProc, z: SimpleDisplayer.zone]};        enumerated => {          Choices: TYPE = RECORD [SEQUENCE n: CARDINAL OF Enumerated];          strings: LONG POINTER TO StringSequence ¬ StringsFromString[            choices, SimpleDisplayer.zone];          selections: LONG POINTER TO Choices ¬ SimpleDisplayer.zone.NEW[            Choices [strings.n]];          FOR i: CARDINAL IN [0..strings.n) DO            selections[i] ¬ [strings[i], i]; ENDLOOP;          items[count] ¬ EnumeratedItem[            tag: tag, place: box.place, readOnly: readOnly, invisible: invisible,            drawBox: drawBox, feedback: feedback, copyChoices: copyChoices,            choices: DESCRIPTOR[selections­], value: @toyEnumerated,            z: SimpleDisplayer.zone];          SimpleDisplayer.zone.FREE[@selections];          FreeStrings[strings, SimpleDisplayer.zone]};        longNumber => {          items[count] ¬ LongNumberItem[            tag: tag, place: box.place, readOnly: readOnly, invisible: invisible,            drawBox: drawBox, radix: radix, signed: signed,            notNegative: notNegative, boxWidth: boxWidth, default: default,            bias: bias, value: @toyLongNumber, z: SimpleDisplayer.zone]};        number => {          items[count] ¬ NumberItem[            tag: tag, place: box.place, readOnly: readOnly, invisible: invisible,            drawBox: drawBox, radix: radix, signed: signed,            notNegative: notNegative, boxWidth: boxWidth, default: default,            bias: bias, value: @toyNumber, z: SimpleDisplayer.zone]};        source => {          items[count] ¬ LabelItem[            tag: tag, place: box.place, z: SimpleDisplayer.zone]};        string => {          items[count] ¬ StringItem[            tag: tag, place: box.place, readOnly: readOnly, invisible: invisible,            drawBox: drawBox, inHeap: TRUE, feedback: feedback, boxWidth: boxWidth,            string: @toyString, z: SimpleDisplayer.zone]};        tagOnly => {          items[count] ¬ TagOnlyItem[            tag: tag, place: box.place, readOnly: readOnly, invisible: invisible,            drawBox: drawBox, z: SimpleDisplayer.zone]};        ENDCASE => ERROR;      count ¬ count + 1};    items ¬ AllocateItemDescriptor[instance.itemCount, SimpleDisplayer.zone];    instance.recordSizeDecimal ¬ 0;  << calculations are done as a word count. >>    SimpleDisplayer.EnumerateItems[      proc: BuildItemProc, Write: NIL, instance: instance];    instance.recordSizeDecimal ¬ instance.recordSizeDecimal * 2;  << convert record size from a word count to a byte count. >>    RETURN[items: items, freeDesc: TRUE]};  MakeForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = FormItems.LAST.ORD + 1;    instance: SimpleDisplayer.DataHandle = SimpleDisplayer.Share[      wh: ToolWindow.WindowForSubwindow[sw: sw]];    processor: ARRAY [0..3) OF Enumerated ¬ [["CP"L, 0], ["IOP"L, 1], ["PC"L, 2]];    items ¬ AllocateItemDescriptor[nItems, SimpleDisplayer.zone];    items[FormItems.refreshDisplay.ORD] ¬ CommandItem[      tag: "RefreshDisplay"L, place: [6, line0], proc: RefreshDisplay,      z: SimpleDisplayer.zone];    items[FormItems.modifyData.ORD] ¬ CommandItem[      tag: "ModifyData"L, place: [108, line0], proc: ModifyData,      z: SimpleDisplayer.zone];    items[FormItems.displayRecord.ORD] ¬ CommandItem[      tag: "DisplayRecord"L, place: [186, line0], proc: ModifyData,      z: SimpleDisplayer.zone];    items[FormItems.writeToLog.ORD] ¬ BooleanItem[      tag: "WriteToLog"L, place: [276, line0], switch: @instance.writeToLog,      z: SimpleDisplayer.zone];    items[FormItems.another.ORD] ¬ CommandItem[      tag: "Another"L, place: [366, line0], proc: SimpleDisplayer.AnotherInstance,      z: SimpleDisplayer.zone];    items[FormItems.revert.ORD] ¬ CommandItem[      tag: "Revert"L, place: [440, line0], proc: Revert, z: SimpleDisplayer.zone];    items[FormItems.recordSizeDecimal.ORD] ¬ NumberItem[      tag: "Record size (bytes-decimal) "L, place: [6, line1], signed: FALSE,      value: @instance.recordSizeDecimal, z: SimpleDisplayer.zone, readOnly: TRUE];    items[FormItems.processor.ORD] ¬ EnumeratedItem[      tag: "processor"L, place: [6, line2], feedback: all,      choices: DESCRIPTOR[processor], value: @instance.processor,      z: SimpleDisplayer.zone];    items[FormItems.address.ORD] ¬ StringItem[      tag: "Address"L, place: [6, line3], inHeap: TRUE, string: @instance.address,      filterProc: HexNumberFilter, z: SimpleDisplayer.zone];    items[FormItems.hexValue.ORD] ¬ StringItem[      tag: "Base16"L, place: [6, line4], inHeap: FALSE, string: @hexNumberString,      z: SimpleDisplayer.zone, filterProc: SpecialNumberFilter];    items[FormItems.decimalValue.ORD] ¬ StringItem[      tag: "Base10"L, place: [144, line4], inHeap: FALSE,      string: @decimalNumberString, z: SimpleDisplayer.zone,      filterProc: SpecialNumberFilter];    items[FormItems.octalValue.ORD] ¬ StringItem[      tag: "Base8"L, place: [294, line4], inHeap: FALSE,      string: @octalNumberString, z: SimpleDisplayer.zone,      filterProc: SpecialNumberFilter];    RETURN[items: items, freeDesc: TRUE];    };  SwapSWs: PUBLIC PROCEDURE [    instance: SimpleDisplayer.DataHandle, window: Window.Handle,    state: SimpleDisplayer.SwapState ¬ use] = {    streamHandle: MStream.Handle;    position: LONG CARDINAL;        <<    processorInfo: Bindweed.ProcessorInfoRecord ¬ [ --processorInfo no longer used      processorState: instance.processorState, processor: instance.processor];    >>    PaintEachItem: PROCEDURE [      item: SimpleDisplayer.ItemHandle, Write: Format.StringProc,      instance: SimpleDisplayer.DataHandle ¬ NIL] = {      SimpleDisplayer.Paint[item, instance]};    SELECT state FROM      use => {        IF instance.itemCount = 0 THEN {          WriteErrorMessage[            instance: instance,            msg:            "There are no items in the formSW to be created!\nPlease layout the formSW that you are interested in displaying!"L];          RETURN};        << Here we are taking subwindows out of the display tree. We will also free the        storage being used to hold the bit-map for the bitSW since it takes ~200        pages.        Note that we are taking them out in bottum up order to minimize the        ugliness of redisplaying that is caused by the Tool mechanism. >>        SimpleDisplayer.ReclaimBitSWSpace[instance: instance];        Tool.DeleteThisSW[instance.formSW];        << Now we will build the display formSW. >>        instance.displayFormSW ¬ Tool.MakeFormSW[          window: window, formProc: MakeClientForm, zone: SimpleDisplayer.zone];        << Note, also, that we are temporarily removing the fileSW which we will        momentarily be replacing.  This is done here instead of up above in        order to have Tajo maintain the proper height for the msgSW. >>        Tool.DeleteThisSW[instance.fileSW];        <<  Depending upon whether or not we have created the Bindweed/Burdock        formSW we will either build it now or we will simply place it back	in the list of subwindows to be displayed.  >>        IF instance.burdockFormSW = NIL THEN {          instance.burdockFormSW ¬ Tool.MakeFormSW[            window: window, formProc: MakeForm, zone: SimpleDisplayer.zone]}        ELSE {          Tool.AddThisSW[window: window, sw: instance.burdockFormSW];          Scrollbar.WindowNowEnlinked[instance.burdockFormSW];          FormSW.DisplayItem[            sw: instance.burdockFormSW, index: FormItems.recordSizeDecimal.ORD]};        <<  We will now put the fileSW back in the list to be displayed.  >>        Tool.AddThisSW[window: window, sw: instance.fileSW];        Scrollbar.WindowNowEnlinked[instance.fileSW];        << We will now allocate the data structure into which we will pack/unpack IOCBs       from.  >>        IF instance.dataSequence # NIL THEN {          SimpleDisplayer.zone.FREE[@instance.dataSequence];	  instance.dataSequence ¬ NIL};        instance.dataSequence ¬ SimpleDisplayer.zone.NEW[          SimpleDisplayer .DataSequence[instance.recordSizeDecimal] ¬ [          length: instance.recordSizeDecimal, seq: NULL]];        FOR index: CARDINAL IN [0..instance.recordSizeDecimal) DO          instance.dataSequence.seq[index] ¬ 0; ENDLOOP;        Bindweed.AddNotify[          notify: Notify, index: iopUpNotifyIndex, clientData: instance !	    Runtime.UnboundProcedure => {            Put.Text[instance.fileSW, "Bindweed not loaded"L]; CONTINUE}];        };      create => {        Bindweed.RemoveNotify[          index: iopUpNotifyIndex, notify: Notify !	    Runtime.UnboundProcedure => {            Put.Text[instance.fileSW, "Bindweed not loaded"L]; CONTINUE}];        << Here we will remove the Bindweed/Burdock formSW from the list of subwindows       being displayed. >>        IF instance.dataSequence # NIL THEN {          SimpleDisplayer.zone.FREE[@instance.dataSequence];	  instance.dataSequence ¬ NIL};        Tool.DeleteThisSW[instance.burdockFormSW];        << Now we will destroy the formSW used for displaying IOCBs; including       removing it from the list of subwindows being displayed.  >>        IF FormSW.IsIt[instance.displayFormSW] THEN {          FormSW.FreeAllItems[sw: instance.displayFormSW];          FormSW.Destroy[instance.displayFormSW]};        Tool.DeleteThisSW[instance.displayFormSW];        ToolWindow.Destroy[window: instance.displayFormSW];        instance.displayFormSW ¬ NIL;        << Now we will restore the SWs used for creating the display formSW. >>        Tool.AddThisSW[          window: window, sw: instance.formSW, nextSW: instance.fileSW];        Scrollbar.WindowNowEnlinked[instance.formSW];        SimpleDisplayer.AllocateBitSWSpace[instance: instance];        << Tool.AddThisSW[window: window, swType: BitSW.Type[], sw: instance.bitSW];	Scrollbar.WindowNowEnlinked[instance.bitSW]; >>        SimpleDisplayer.EnumerateItems[          proc: PaintEachItem, Write: NIL, instance: instance];        };      ENDCASE;    [s: streamHandle] ¬ FileSW.GetFile[sw: instance.fileSW];    position ¬ TextSW.GetEOF[sw: instance.fileSW] - 2;    MStream.SetLogReadLength[stream: streamHandle, position: position];    IF ~TextSW.PositionIsVisible[sw: instance.fileSW, position: position] THEN      TextSW.SetPosition[sw: instance.fileSW, position: position];    };  Notify: Bindweed.NotifyProc = {    instance: SimpleDisplayer.DataHandle = clientData;        <<    IF processorInfo.processor # instance.processor THEN RETURN;    instance.processorState ¬ newState;        FormSW.DisplayItem[      sw: instance.burdockFormSW, index: FormItems.processorState.ORD];      >>    Process.Detach[      FORK RefreshDisplay[      sw: instance.burdockFormSW,      item: FormSW.FindItem[      sw: instance.burdockFormSW, index: FormItems.refreshDisplay.ORD],      index: FormItems.refreshDisplay.ORD]];    };  << FormSW invoked PROCEDURES. >>  HexNumberFilter: ENTRY FormSW.FilterProcType = {    ENABLE UNWIND => NULL;    stringLength: CARDINAL ¬ 0;    IF string # NIL THEN {      FOR index1: CARDINAL IN [0..string.length) DO        SELECT string[index1] FROM          IN ['0..'9], IN ['a..'f], IN ['A..'F], backSpaceLevelIV, backWordLevelIV,            backSpaceADM3a => {            IF stringLength # index1 THEN string[stringLength] ¬ string[index1];            stringLength ¬ stringLength + 1};          ENDCASE => {UserTerminal.BlinkDisplay[]};        ENDLOOP};    string.length ¬ stringLength;    FormSW.StringEditProc[sw: sw, item: item, insert: insert, string: string];    SetDataAddress[      sw: sw, item: item, index: FormSW.FindIndex[sw: sw, item: item]];    };  SpecialNumberFilter: ENTRY FormSW.FilterProcType = {        ENABLE UNWIND => NULL;    stringLength: CARDINAL ¬ 0;    index: CARDINAL = FormSW.FindIndex[sw: sw, item: item];    base: CARDINAL;    sourceString: LONG STRING;    whichBase: CARDINAL;    NumberConverter: Format.StringProc = {      SELECT whichBase FROM        8 => {          octalNumberString.length ¬ 0;          String.AppendString[to: octalNumberString, from: s]};        10 => {          decimalNumberString.length ¬ 0;          String.AppendString[to: decimalNumberString, from: s]};        16 => {          hexNumberString.length ¬ 0;          String.AppendString[to: hexNumberString, from: s]};        ENDCASE => ERROR;      };    base ¬      SELECT index FROM        FormItems.hexValue.ORD => 16,        FormItems.octalValue.ORD => 8,        FormItems.decimalValue.ORD => 10,        ENDCASE => 10;    sourceString ¬      SELECT base FROM        8 => octalNumberString,        16 => hexNumberString,        ENDCASE => decimalNumberString;    IF string # NIL THEN {      FOR index1: CARDINAL IN [0..string.length) DO        SELECT string[index1] FROM          IN ['0..'7], backSpaceLevelIV, backWordLevelIV, backSpaceADM3a => {            IF stringLength # index1 THEN string[stringLength] ¬ string[index1];            stringLength ¬ stringLength + 1};          IN ['8..'9] => {            IF base = 8 THEN {UserTerminal.BlinkDisplay[]; LOOP};            IF stringLength # index1 THEN string[stringLength] ¬ string[index1];            stringLength ¬ stringLength + 1};          IN ['a..'f], IN ['A..'F] => {            IF base # 16 THEN {UserTerminal.BlinkDisplay[]; LOOP};            IF stringLength # index1 THEN string[stringLength] ¬ string[index1];            stringLength ¬ stringLength + 1};          ENDCASE => {UserTerminal.BlinkDisplay[]};        ENDLOOP};    string.length ¬ stringLength;    FormSW.StringEditProc[sw: sw, item: item, insert: insert, string: string];    junkNumber ¬ 0;    FOR index1: CARDINAL IN [0..sourceString.length) DO      junkNumber ¬        junkNumber * base +          (SELECT sourceString[index1] FROM             IN ['0..'9] => (sourceString[index1] - '0),             IN ['a..'f] => (sourceString[index1] - 'a) + 10,             IN ['A..'F] => (sourceString[index1] - 'A) + 10,             ENDCASE => 0);      ENDLOOP;    Format.LongNumber[      proc: NumberConverter, n: junkNumber, format: [base: whichBase ¬ 8]];    FormSW.DisplayItem[sw: sw, index: FormItems.octalValue.ORD];    Format.LongNumber[      proc: NumberConverter, n: junkNumber, format: [base: whichBase ¬ 10]];    FormSW.DisplayItem[sw: sw, index: FormItems.decimalValue.ORD];    Format.LongNumber[      proc: NumberConverter, n: junkNumber, format: [base: whichBase ¬ 16]];    FormSW.DisplayItem[sw: sw, index: FormItems.hexValue.ORD];    };  WriteDataBlock: PROCEDURE [instance: SimpleDisplayer.DataHandle] = {    Write: Format.StringProc = {Put.Text[instance.fileSW, s]};    FOR index: CARDINAL IN [0..instance.dataSequence.length) DO      IF index MOD 16 = 0 THEN Format.Char[proc: Write, char: '\n];      Format.Number[        proc: Write, n: instance.dataSequence.seq[index],        format: [base: 16, zerofill: TRUE, columns: 2]];      Format.Char[proc: Write, char: ' ];      ENDLOOP;    Format.Char[proc: Write, char: '\n];    Format.Char[proc: Write, char: '\n]};  Pack: PROCEDURE [    instance: SimpleDisplayer.DataHandle, byte: CARDINAL, bits: CARDINAL [0..8],    value: CARDINAL [0..256), shift: CARDINAL [0..8), clearField: BOOLEAN ¬ TRUE] =    {    mask: CARDINAL;    tempByte: CARDINAL;    IF bits = 0 THEN RETURN;    mask ¬ MaskArray[bits - 1];    value ¬ Inline.BITAND[value, mask];    IF shift # 0 THEN {      mask ¬ Inline.BITSHIFT[value: mask, count: shift];      value ¬ Inline.BITSHIFT[value: value, count: shift]};    mask ¬ Inline.BITNOT[mask];    tempByte ¬ instance.dataSequence.seq[byte];    IF clearField THEN tempByte ¬ Inline.BITAND[mask, tempByte];    instance.dataSequence.seq[byte] ¬ Inline.BITOR[tempByte, value];    };  UnPack: PROCEDURE [    instance: SimpleDisplayer.DataHandle, byte: CARDINAL, bits: CARDINAL [0..8],    shift: CARDINAL [0..8)] RETURNS [value: CARDINAL [0..256)] = {    mask: CARDINAL ¬ MaskArray[bits - 1];    IF shift # 0 THEN mask ¬ Inline.BITSHIFT[value: mask, count: shift];    value ¬ Inline.BITAND[instance.dataSequence.seq[byte], mask];    IF shift # 0 THEN {value ¬ Inline.BITSHIFT[value: value, count: 0 - shift]};    };  UnPackLongNumber: PROCEDURE [    instance: SimpleDisplayer.DataHandle, byte: CARDINAL, bits: CARDINAL (0..32],    shift: CARDINAL [0..32), byteSwappedMachine: BOOLEAN]    RETURNS [longNumber: LONG UNSPECIFIED ¬ 0] = {    byte0: LONG CARDINAL ¬ instance.dataSequence.seq[      byte + (IF byteSwappedMachine THEN 0 ELSE 3)];    byte1: LONG CARDINAL ¬ instance.dataSequence.seq[      byte + (IF byteSwappedMachine THEN 1 ELSE 2)];    byte2: LONG CARDINAL ¬ instance.dataSequence.seq[      byte + (IF byteSwappedMachine THEN 2 ELSE 1)];    byte3: LONG CARDINAL ¬ instance.dataSequence.seq[      byte + (IF byteSwappedMachine THEN 3 ELSE 0)];    mask: LONG CARDINAL ¬ 1;    longNumber ¬ byte0 + (byte1 + (byte2 + byte3 * 256) * 256) * 256;    FOR index: CARDINAL IN [0..bits) DO mask ¬ mask * 2; ENDLOOP;    mask ¬ mask - 1;    IF shift # 0 THEN      longNumber ¬ Inline.DBITSHIFT[value: longNumber, count: 0 - shift];    longNumber ¬ Inline.DBITAND[longNumber, mask];    };  UnPackNumber: PROCEDURE [    instance: SimpleDisplayer.DataHandle, byte: CARDINAL, bits: CARDINAL (0..16],    shift: CARDINAL [0..16), byteSwappedMachine: BOOLEAN]    RETURNS [number: UNSPECIFIED ¬ 0] = {    lowByte: CARDINAL ¬ instance.dataSequence.seq[      byte + 1 - byteSwappedMachine.ORD];    highByte: CARDINAL ¬ instance.dataSequence.seq[byte + byteSwappedMachine.ORD];    mask: CARDINAL;    number ¬ Inline.BITOR[lowByte, Inline.BITSHIFT[value: highByte, count: 8]];    mask ¬      IF bits > 8 THEN Inline.BITOR[      MaskArray[7], Inline.BITSHIFT[value: MaskArray[bits - 9], count: 8]]      ELSE MaskArray[bits - 1];    IF shift # 0 THEN number ¬ Inline.BITSHIFT[value: number, count: 0 - shift];    number ¬ Inline.BITAND[number, mask];    };  PackLongNumber: PROCEDURE [    instance: SimpleDisplayer.DataHandle, byte: CARDINAL, bits: CARDINAL (0..32],    shift: CARDINAL [0..32), byteSwappedMachine: BOOLEAN,    longNumber: LONG UNSPECIFIED] = {    mask: LONG CARDINAL ¬ 1;    bitsInByte0, bitsInByte1, bitsInByte2, bitsInByte3, bitsRemaining: CARDINAL;    shift0, shift1, shift2, shift3: CARDINAL;    shift0 ¬ IF shift > 7 THEN 0 ELSE shift;    shift1 ¬ IF ((shift > 7) AND (shift < 16)) THEN (shift - 8) ELSE 0;    shift2 ¬ IF ((shift > 15) AND (shift < 24)) THEN (shift - 16) ELSE 0;    shift3 ¬ IF shift > 23 THEN (shift - 24) ELSE 0;    bitsInByte0 ¬      SELECT shift FROM        > 7 => 0,        ENDCASE => (IF ((bits + shift0) > 7) THEN (8 - shift0) ELSE bits);    bitsRemaining ¬ bits - bitsInByte0;    bitsInByte1 ¬      SELECT shift FROM        > 15 => 0,        ENDCASE => (IF bitsRemaining > 7 THEN 8 ELSE bitsRemaining);    bitsRemaining ¬ bitsRemaining - bitsInByte1;    bitsInByte2 ¬      SELECT shift FROM        > 23 => 0,        ENDCASE => (IF bitsRemaining > 7 THEN 8 ELSE bitsRemaining);    bitsRemaining ¬ bitsRemaining - bitsInByte2;    bitsInByte3 ¬ SELECT shift FROM > 23 => bits, ENDCASE => bitsRemaining;    FOR index: CARDINAL IN [0..bits) DO mask ¬ mask * 2; ENDLOOP;    mask ¬ mask - 1;    longNumber ¬ Inline.DBITAND[longNumber, mask];    IF shift # 0 THEN      longNumber ¬ Inline.DBITSHIFT[value: longNumber, count: shift];    Pack[      instance: instance, byte: byte + (IF byteSwappedMachine THEN 0 ELSE 3),      value: 0, shift: shift0, bits: bitsInByte0];    Pack[      instance: instance, byte: byte + (IF byteSwappedMachine THEN 1 ELSE 2),      value: 0, shift: shift1, bits: bitsInByte1];    Pack[      instance: instance, byte: byte + (IF byteSwappedMachine THEN 2 ELSE 1),      value: 0, shift: shift2, bits: bitsInByte2];    Pack[      instance: instance, byte: byte + (IF byteSwappedMachine THEN 3 ELSE 0),      value: 0, shift: shift3, bits: bitsInByte3];    Pack[      instance: instance, byte: byte + (IF byteSwappedMachine THEN 0 ELSE 3),      value: Inline.LowByte[Inline.LowHalf[longNumber]], shift: 0,      bits: bitsInByte0 + shift0, clearField: FALSE];    Pack[      instance: instance, byte: byte + (IF byteSwappedMachine THEN 1 ELSE 2),      value: Inline.HighByte[Inline.LowHalf[longNumber]], shift: 0,      bits: bitsInByte1 + shift1, clearField: FALSE];    Pack[      instance: instance, byte: byte + (IF byteSwappedMachine THEN 2 ELSE 1),      value: Inline.LowByte[Inline.HighHalf[longNumber]], shift: 0,      bits: bitsInByte2 + shift2, clearField: FALSE];    Pack[      instance: instance, byte: byte + (IF byteSwappedMachine THEN 3 ELSE 0),      value: Inline.HighByte[Inline.HighHalf[longNumber]], shift: 0,      bits: bitsInByte3 + shift3, clearField: FALSE];    };  PackNumber: PROCEDURE [    instance: SimpleDisplayer.DataHandle, byte: CARDINAL, bits: CARDINAL (0..16],    shift: CARDINAL [0..16), byteSwappedMachine: BOOLEAN, number: UNSPECIFIED] = {    bitsInLowByte: CARDINAL;    bitsInHighByte: CARDINAL;    lowBytePosition: CARDINAL ¬ byte + 1 - byteSwappedMachine.ORD;    mask: CARDINAL;    shift0, shift1: CARDINAL;    shift0 ¬ IF shift > 7 THEN 0 ELSE shift;    shift1 ¬ IF shift > 7 THEN (shift - 8) ELSE 0;    bitsInLowByte ¬      SELECT shift FROM        > 7 => 0,        ENDCASE => (IF ((bits + shift0) > 7) THEN (8 - shift0) ELSE bits);    bitsInHighByte ¬      SELECT shift FROM > 7 => bits, ENDCASE => bits - bitsInLowByte;    mask ¬      IF bits > 8 THEN Inline.BITOR[      MaskArray[7], Inline.BITSHIFT[value: MaskArray[bits - 9], count: 8]]      ELSE MaskArray[bits - 1];    number ¬ Inline.BITAND[number, mask];    IF shift # 0 THEN number ¬ Inline.BITSHIFT[value: number, count: shift];    Pack[      instance: instance, byte: lowBytePosition, value: 0, shift: shift0,      bits: bitsInLowByte];    Pack[      instance: instance, byte: byte + byteSwappedMachine.ORD, value: 0,      shift: shift1, bits: bitsInHighByte];    Pack[      instance: instance, byte: lowBytePosition, value: Inline.LowByte[number],      shift: 0, bits: bitsInLowByte + shift0, clearField: FALSE];    Pack[      instance: instance, byte: byte + byteSwappedMachine.ORD,      value: Inline.HighByte[number], shift: 0, bits: bitsInHighByte + shift1,      clearField: FALSE];    };  RefreshDisplay: ENTRY FormSW.ProcType = {        ENABLE UNWIND => NULL;    wh: Window.Handle ¬ ToolWindow.WindowForSubwindow[sw: sw];    instance: SimpleDisplayer.DataHandle = SimpleDisplayer.Lock[wh: wh];    <<    processorInfo: Bindweed.ProcessorInfoRecord ¬ [      debugMedium: instance.debugMedium, processorState: instance.processorState,      processor: instance.processor];    >>        print: BOOLEAN ¬ instance.writeToLog;    windowBox: Window.Box ¬ Window.nullBox;    UnPackItems: PROCEDURE [      item: SimpleDisplayer.ItemHandle, Write: Format.StringProc,      instance: SimpleDisplayer.DataHandle ¬ NIL] = {      IF print THEN        BEGIN	  IF item­.box.place.y # windowBox.place.y THEN Put.Text[instance.fileSW, "\n"L];	END;      windowBox ¬ item­.box;      WITH item SELECT FROM        boolean => {          toyBoolean ¬ UnPackNumber[            instance: instance, byte: 2 * word, shift: 15 - startingBitPostion,            bits: bitsOccupied, byteSwappedMachine: byteSwappedMachine] = ORD[            TRUE];	  IF print THEN 	    BEGIN	      Put.Text[instance.fileSW, item­.tag];	      IF toyBoolean THEN Put.Text[instance.fileSW, ":TRUE"L] ELSE Put.Text[instance.fileSW, ":FALSE"L];	    END};        command => {	  IF print THEN 	    BEGIN	      Put.Text[instance.fileSW, item­.tag];	    END};        enumerated => {          toyEnumerated ¬ UnPackNumber[            instance: instance, byte: 2 * word,            shift: (maxBitsOccupied - bitsOccupied - startingBitPostion) MOD 16,            bits: bitsOccupied, byteSwappedMachine: byteSwappedMachine];	  IF print THEN 	    BEGIN	      choicePtr: SimpleDisplayer.ChoicePtr ¬ choiceList;	      Put.Text[instance.fileSW, item­.tag];	      FOR index: CARDINAL IN [0..toyEnumerated) DO	        IF choicePtr = NIL THEN GOTO badEnumeratedItem;	        choicePtr ¬ choicePtr.next;	      ENDLOOP;	      IF choicePtr = NIL THEN GOTO badEnumeratedItem;	      Put.Text[instance.fileSW, ": {"L];	      Put.Text[instance.fileSW, choicePtr.a];	      Put.Text[instance.fileSW, "}"L];	      EXITS	        badEnumeratedItem => Put.Text[instance.fileSW, ": {?!@#$&*?}"L];	    END};        longNumber => {          toyLongNumber ¬ UnPackLongNumber[            instance: instance, byte: 2 * word,            shift: (maxBitsOccupied - bitsOccupied - startingBitPostion) MOD 16,            byteSwappedMachine: byteSwappedMachine, bits: bitsOccupied];	    IF print THEN 	    BEGIN	      Put.Text[instance.fileSW, item­.tag];	      Put.Text[instance.fileSW, "= "L];	      Put.LongNumber[h: instance.fileSW, n: toyLongNumber, format: [base:	         (SELECT radix FROM		   decimal => 10,		   octal => 8,		   ENDCASE => 16),	        zerofill: FALSE, unsigned: TRUE, columns: 0]];	    END};        number => {          toyNumber ¬ UnPackNumber[            instance: instance, byte: 2 * word,            shift: ((maxBitsOccupied - bitsOccupied - startingBitPostion) MOD 16),            byteSwappedMachine: byteSwappedMachine, bits: bitsOccupied];	    IF print THEN 	    BEGIN	      Put.Text[instance.fileSW, item­.tag];	      Put.Text[instance.fileSW, "= "L];	      Put.Number[h: instance.fileSW, n: toyNumber, format: [base:	         (SELECT radix FROM		   decimal => 10,		   octal => 8,		   ENDCASE => 16),	        zerofill: FALSE, unsigned: TRUE, columns: 0]];	    END};        source => {	  IF print THEN 	    BEGIN	      Put.Text[instance.fileSW, item­.tag];	    END};        string => {	  IF print THEN 	    BEGIN	      Put.Text[instance.fileSW, item­.tag];	      Put.Text[instance.fileSW, ": "L];	      Put.Text[instance.fileSW, string];	    END};        tagOnly => {	  IF print THEN 	    BEGIN	      Put.Text[instance.fileSW, item­.tag];	    END};        ENDCASE;      IF print THEN        BEGIN	  Put.Text[instance.fileSW, "\t "L];	END};    Put.Text[instance.fileSW, "\nRefreshDisplay called:"L];    Bindweed.ReadMemoryBlock[      address: instance.addressValue,      addressType: iOPLogical,      sequence: instance.dataSequence !        Bindweed.Error => SELECT code FROM 	  timeout => {Put.Text[instance.fileSW, "Timeout"L]; CONTINUE};	  badCheckSum => {Put.Text[instance.fileSW, "Bad CheckSum"L]; CONTINUE};	  ENDCASE => ERROR;        Runtime.UnboundProcedure => {        Put.Text[instance.fileSW, "Bindweed not loaded"L]; CONTINUE}];    Put.Text[instance.fileSW, "\n"L];    IF print THEN      BEGIN        timeString: LONG STRING ¬ [50];	Time.AppendCurrent[s:timeString, zone: TRUE];	Put.Text[instance.fileSW, "time: "L];	Put.Line[instance.fileSW, timeString];      END;    SimpleDisplayer.EnumerateItems[      proc: UnPackItems, Write: NIL, instance: instance];    FormSW.Display[sw: instance.displayFormSW];    IF print THEN Put.Text[instance.fileSW, "\n"L];    WriteDataBlock[instance: instance];    SimpleDisplayer.UnLock[wh: wh]};  ModifyData: ENTRY FormSW.ProcType = {        ENABLE UNWIND => NULL;    wh: Window.Handle ¬ ToolWindow.WindowForSubwindow[sw: sw];    instance: SimpleDisplayer.DataHandle = SimpleDisplayer.Lock[wh: wh];    <<    processorInfo: Bindweed.ProcessorInfoRecord ¬ [      debugMedium: instance.debugMedium, processorState: instance.processorState,      processor: instance.processor];    >>    PackItems: PROCEDURE [      item: SimpleDisplayer.ItemHandle, Write: Format.StringProc,      instance: SimpleDisplayer.DataHandle ¬ NIL] = {      WITH item SELECT FROM        boolean => {          PackNumber[            instance: instance, byte: 2 * word, number: toyBoolean.ORD,            shift: 15 - startingBitPostion, bits: bitsOccupied,            byteSwappedMachine: byteSwappedMachine]};        command => {};        enumerated => {          PackNumber[            instance: instance, byte: 2 * word, number: toyEnumerated,            shift: (maxBitsOccupied - bitsOccupied - startingBitPostion) MOD 16,            bits: bitsOccupied, byteSwappedMachine: byteSwappedMachine]};        longNumber => {          PackLongNumber[            instance: instance, byte: 2 * word, bits: bitsOccupied,            shift: (maxBitsOccupied - bitsOccupied - startingBitPostion) MOD 16,            byteSwappedMachine: byteSwappedMachine, longNumber: toyLongNumber]};        number => {          PackNumber[            instance: instance, byte: 2 * word, bits: bitsOccupied,            shift: (maxBitsOccupied - bitsOccupied - startingBitPostion) MOD 16,            byteSwappedMachine: byteSwappedMachine, number: toyNumber]};        source => {};        string => {};        tagOnly => {};        ENDCASE};    IF index = FormItems.modifyData.ORD THEN      Put.Text[instance.fileSW, "\nModifyData called:"L]    ELSE Put.Text[instance.fileSW, "\nDisplayRecord called:"L];    Bindweed.ReadMemoryBlock[      address: instance.addressValue,      addressType: iOPLogical,      sequence: instance.dataSequence !        Bindweed.Error => SELECT code FROM	  timeout => {Put.Text[instance.fileSW, "Timeout"L]; CONTINUE};	  badCheckSum => {Put.Text[instance.fileSW, "Bad CheckSum"L]; CONTINUE};	  ENDCASE => ERROR;        Runtime.UnboundProcedure => {          Put.Text[instance.fileSW, "Bindweed not loaded"L]; CONTINUE}];    SimpleDisplayer.EnumerateItems[      proc: PackItems, Write: NIL, instance: instance];    WriteDataBlock[instance: instance];    IF index = FormItems.modifyData.ORD THEN {      Bindweed.WriteMemoryBlock[        address: instance.addressValue,	addressType: iOPLogical,        sequence: instance.dataSequence !        Bindweed.Error => SELECT code FROM	  timeout => {Put.Text[instance.fileSW, "Timeout"L]; CONTINUE};	  badCheckSum => {Put.Text[instance.fileSW, "Bad CheckSum"L]; CONTINUE};	  ENDCASE => ERROR;        Runtime.UnboundProcedure => {          Put.Text[instance.fileSW, "Bindweed not loaded"L]; CONTINUE}]};    SimpleDisplayer.UnLock[wh: wh]};        Revert: ENTRY FormSW.ProcType = {        ENABLE UNWIND => NULL;    wh: Window.Handle ¬ ToolWindow.WindowForSubwindow[sw: sw];    instance: SimpleDisplayer.DataHandle = SimpleDisplayer.Lock[wh: wh];    SwapSWs[instance: instance, window: wh, state: create];    SimpleDisplayer.UnLock[wh: wh]};  SetDataAddress: FormSW.ProcType = {    wh: Window.Handle ¬ ToolWindow.WindowForSubwindow[sw: sw];    instance: SimpleDisplayer.DataHandle = SimpleDisplayer.Lock[wh: wh];    addressValue: LONG CARDINAL;    addressValue ¬ 0;    IF instance.address # NIL THEN      FOR index1: CARDINAL IN [0..instance.address.length) DO        addressValue ¬          addressValue * 16 +            (SELECT instance.address[index1] FROM               IN ['0..'9] => (instance.address[index1] - '0),               IN ['a..'f] => (instance.address[index1] - 'a) + 10,               IN ['A..'F] => (instance.address[index1] - 'A) + 10,               ENDCASE => 0);        ENDLOOP;    instance.addressValue ¬ addressValue;    FormSW.DisplayItem[sw: sw, index: index];    SimpleDisplayer.UnLock[wh: wh]};  }...    LOG  created by Dennis E. DEG      on 20-Feb-84  6:59:30  Dennis DEG      on  23-Mar-84 17:52:22  FXB     2-May-84  9:50:04  FXB    17-Aug-84 16:13:01  FXB    22-Aug-84 13:57:10  FXB    (deleted Destroy from "set state" FormSW) 23-Aug-84 10:51:33  FXB   , 11-Oct-84 17:52:01: catch badchecksum ERROR  DEG      22-Oct-84  1:56:25: catch Runtime.UnboundProcedure in Bindweed.AddNotify and Bindweed.RemoveNotify calls.  DEG       3-Feb-85 21:58:22: add stuff to write formSW to the log.   DEG      13-Feb-85  2:39:10: add timestamp to log when writeToLog is selected.  FXB   .PA  4-Jun-85 17:10:44: updated for Bindweed of 15-Apr-85 13:08:02 PST  
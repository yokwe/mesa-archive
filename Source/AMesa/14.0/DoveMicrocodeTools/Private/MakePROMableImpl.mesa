-- MakePROMableImpl.mesa-- Created by BindweedDisplayer on 14-Apr-85 19:01:20-- Copyright (C) 1985 by Xerox Corporation.  All right reserved.DIRECTORY  Context,  Exec,  FormSW,  Heap,  MakePROMableDef USING [ConvertFile, Data, DataHandle],  Put,  Runtime,  String,  Time,  Tool,  ToolWindow,  Version,  Window;MakePROMableImpl: MONITOR  IMPORTS    Context, Exec, FormSW, Heap, MakePROMableDef, Put, Runtime, String, Time, Tool, ToolWindow, Version = {      GlobalDataHandle: TYPE = LONG POINTER TO GlobalData;  GlobalData: TYPE = RECORD [    context: Context.Type,    tinyName1: LONG STRING ¬ NIL,    tinyName2: LONG STRING ¬ NIL,    rootName: LONG STRING ¬ NIL,    nameStripeName: LONG STRING ¬ NIL,    windows: WindowList ¬ NIL];  WindowList: TYPE = LONG POINTER TO WindowRecord;  WindowRecord: TYPE = RECORD [    wh: Window.Handle ¬ NIL,    link: WindowList ¬ NIL];  FormItems: TYPE = {makePROMable, another, destroy, inputFile, outputFile};  data: GlobalDataHandle ¬ NIL;  zone: UNCOUNTED ZONE ¬ Heap.systemZone;  << Instance data monitoring. >>  Lock: PROCEDURE [wh: Window.Handle] RETURNS [dataHandle: MakePROMableDef.DataHandle] = INLINE {    RETURN Context.Acquire[type: data.context, window: wh]};  Share: PROCEDURE [wh: Window.Handle] RETURNS [dataHandle: MakePROMableDef.DataHandle] = INLINE {    RETURN Context.Find[type: data.context, window: wh]};  UnLock: PROCEDURE [wh: Window.Handle] = INLINE {    Context.Release[type: data.context, window: wh]};  << Window list management. >>  AddToList: ENTRY PROCEDURE [wh: Window.Handle] = {    ENABLE UNWIND => NULL;    data.windows ¬ zone.NEW[WindowRecord ¬ [wh: wh, link: data.windows]]};  LocateQuiescentTool: ENTRY PROCEDURE RETURNS [wh: Window.Handle] = {    ENABLE UNWIND => NULL;    wh ¬ NIL;    FOR w: WindowList ¬ data.windows, w.link WHILE w # NIL DO      SELECT ToolWindow.GetState[w.wh] FROM	active => NULL;	inactive => {	  ToolWindow.Activate[w.wh];	  wh ¬ w.wh;	  RETURN};	tiny => NULL;      ENDCASE;    ENDLOOP};  RemoveFromList: ENTRY PROCEDURE [wh: Window.Handle] = {    ENABLE UNWIND => NULL;    w: LONG POINTER TO WindowList;    FOR w ¬ @data.windows, @w.link WHILE w­ # NIL DO      IF w.wh = wh THEN {	flush: WindowList ¬ w­;	w­ ¬ w.link;	zone.FREE[@flush];	RETURN};    ENDLOOP};  << Initialization.  >>  Init: PROCEDURE = {    commandName: LONG STRING;    data ¬ zone.NEW[GlobalData ¬ [      context: Context.UniqueType[],      rootName: String.CopyToNewString[s: "MakePROMable"L, z: zone]]];    commandName ¬ String.CopyToNewString[s: data.rootName, z: zone, longer: 2];    String.AppendString[to: commandName, from: ".~"L];    Exec.AddCommand[name: commandName, proc: RegisterCommand, help: HelpProc, unload: UnloadProc];    String.FreeString[z: zone, s: commandName];    data.nameStripeName ¬ String.CopyToNewString[s: data.rootName, z: zone, longer: 55];    String.AppendString[to: data.nameStripeName, from: " of "];    Time.Append[s: data.nameStripeName, unpacked: Time.Unpack[time: Runtime.GetBcdTime[]], zone: TRUE];    String.AppendString[to: data.nameStripeName, from: " running on Pilot "];    Version.Append[data.nameStripeName];    };  RegisterCommand: Exec.ExecProc = {    wh: Window.Handle;    IF (wh ¬ LocateQuiescentTool[]) = NIL THEN wh ¬ CreateInstance[]};  HelpProc: Exec.ExecProc = {    };  UnloadProc: Exec.ExecProc = {    commandName: LONG STRING;    tempPtr: WindowList;    commandName ¬ String.CopyToNewString[s: data.rootName, z: zone, longer: 2];    String.AppendString[to: commandName, from: ".~"];    h.RemoveCommand[name: commandName];    zone.FREE[@commandName];    WHILE (tempPtr ¬ data.windows) # NIL DO      data.windows ¬ data.windows.link;      Tool.Destroy[window: tempPtr.wh];    ENDLOOP;    zone.FREE[@data]};  << Tool creation/destruction.  >>  AnotherInstance: FormSW.ProcType = {      IF LocateQuiescentTool[] = NIL THEN [] ¬ CreateInstance[]};  CreateInstance: PROCEDURE RETURNS[wh: Window.Handle] = {    AddToList[wh: wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default,      clientTransition: ClientTransition, name: data.nameStripeName,      tinyName1: data.tinyName1, tinyName2: data.tinyName2,      cmSection: data.rootName]]};  DestroyInstance: FormSW.ProcType ={    wh: Window.Handle = ToolWindow.WindowForSubwindow[sw: sw];    RemoveFromList[wh: wh];    Tool.Destroy[window: wh]};  MakeForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = FormItems.LAST.ORD + 1;    instance: MakePROMableDef.DataHandle = Share[wh: ToolWindow.WindowForSubwindow[sw: sw]];    items ¬ AllocateItemDescriptor[nItems];    items[FormItems.makePROMable.ORD] ¬ CommandItem[      tag: "MakePROMable"L, place: [6, line0], proc: MakePROMable];    items[FormItems.another.ORD] ¬ CommandItem[      tag: "Another"L, place: [216, line0], proc: AnotherInstance];    items[FormItems.destroy.ORD] ¬ CommandItem[      tag: "Destroy"L, place: [288, line0], proc: DestroyInstance];    items[FormItems.inputFile.ORD] ¬ StringItem[      tag: "Input File"L, place: [6, line1], inHeap: TRUE, string: @instance.inputFile];    items[FormItems.outputFile.ORD] ¬ StringItem[      tag: "Output File"L, place: [6, line2], inHeap: TRUE, string: @instance.outputFile];    RETURN[items: items, freeDesc: TRUE];    };  MakeSWs: Tool.MakeSWsProc = {  logName: LONG STRING ¬ [19];    instance: MakePROMableDef.DataHandle = Share[wh: window];    Tool.UnusedLogName[unused: logName, root: "MakePROMable.log"L];    instance.msgSW ¬ Tool.MakeMsgSW[window: window];    instance.formSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeForm];    instance.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    };<< Transitions. >>  ClientTransition: ToolWindow.TransitionProcType = {    SELECT TRUE FROM      old = inactive =>	{instance: MakePROMableDef.DataHandle = zone.NEW[MakePROMableDef.Data ¬ []];	Context.Create[type: data.context, data: instance, proc: Context.NopDestroyProc, window: window]};      new = inactive =>	{instance: MakePROMableDef.DataHandle ¬ Share[window];	Context.Destroy[type: data.context, window: window];	zone.FREE[@instance]};      ENDCASE;    };<< FormSW invoked PROCEDURES. >>  MakePROMable:  FormSW.ProcType = {    wh: Window.Handle ¬ ToolWindow.WindowForSubwindow[sw: sw];    instance: MakePROMableDef.DataHandle = Lock[wh: wh];    Put.Line[instance.fileSW, "MakePROMable called"L];    MakePROMableDef.ConvertFile[handle: instance];    UnLock[wh: wh]};  -- Mainline code  Init[];  -- this gets string out of global frame  }...    
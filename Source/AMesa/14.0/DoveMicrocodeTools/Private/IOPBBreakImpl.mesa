-- File: IOPBBreakImpl.mesa - last edit:-- FXB   .PA           11-Apr-85 17:03:05-- Copyright (C) 1984, 1985 by Xerox Corporation. All rights reserved.-- after IOPBreaker.mesa, HGM,  8-Nov-83 19:09:41DIRECTORY  Environment USING [Byte],  Heap USING [systemZone],  I186 USING [Address],  IOPB,  IOPBBreak,  IOPBKernel;IOPBBreakImpl: MONITOR  IMPORTS Heap, IOPB, IOPBKernel  EXPORTS IOPBBreak =  BEGIN    z: UNCOUNTED ZONE = Heap.systemZone;    head: ARRAY IOPB.Processor OF Breakpoint ¬ ALL [NIL];  breaksInstalled: BOOLEAN ¬ FALSE;    breakInstruction:  Environment.Byte = 0CCH;   nopInstruction: Environment.Byte = 90H;    Breakpoint: TYPE = LONG POINTER TO  BreakpointInfo;  BreakpointInfo: TYPE = RECORD [    location: I186.Address,    instruction: Environment.Byte,    next: Breakpoint];    Break: PUBLIC ENTRY PROCEDURE [    address: I186.Address, processor: IOPB.Processor] = {     ENABLE UNWIND => NULL;    new: Breakpoint;    BeSureInKernel[];    FOR finger: Breakpoint ¬ head[processor], finger.next UNTIL finger = NIL DO      IF finger.location = address THEN ERROR IOPB.Error[code: breakAlreadySet];      ENDLOOP;    new ¬ z.NEW[BreakpointInfo];    new­ ¬ [address, IOPBKernel.ReadMemoryByte[address, processor], head[processor]];    head[processor] ¬ new;    };	    Unbreak: PUBLIC ENTRY PROCEDURE [    address: I186.Address, processor: IOPB.Processor] = {    ENABLE UNWIND => NULL;    previous: Breakpoint ¬ NIL;    BeSureInKernel[];    RemoveBreaksInternal[];    FOR finger: Breakpoint ¬ head[processor], finger.next UNTIL finger = NIL DO      IF finger.location = address THEN        BEGIN	temp: Breakpoint ¬ finger;  -- Rats, can't smash LOOP control variable	IF previous = NIL THEN head[processor] ¬ finger.next	ELSE previous.next ¬ finger.next;	z.FREE[@temp];	RETURN;	END;      previous ¬ finger;      ENDLOOP;    IF IOPBKernel.ReadMemoryByte[address, processor] = breakInstruction THEN      BEGIN  -- Deleting a compiled in break      IOPBKernel.WriteMemoryByte[address, processor, nopInstruction];      END;    ERROR IOPB.Error[code: breakNotFound];    };    Reset: PUBLIC ENTRY PROCEDURE [processor: IOPB.Processor] =    BEGIN    Smash[processor];    END;    ClearAllBreaks: PUBLIC ENTRY PROCEDURE [processor: IOPB.Processor] =    BEGIN ENABLE UNWIND => NULL;    BeSureInKernel[];    Smash[processor];    END;  Smash: INTERNAL PROCEDURE [processor: IOPB.Processor] =    BEGIN    breaksInstalled ¬ FALSE;    UNTIL head[processor] = NIL DO      temp: Breakpoint ¬ head[processor];      head[processor] ¬ head[processor].next;      z.FREE[@temp];      ENDLOOP;    END;  EnumerateBreaks: PUBLIC ENTRY PROCEDURE [    proc: PROCEDURE[I186.Address], processor: IOPB.Processor] =    BEGIN ENABLE UNWIND => NULL;    FOR finger: Breakpoint ¬ head[processor], finger.next UNTIL finger = NIL DO      proc[finger.location];      ENDLOOP;    END;    InstallBreaks: PUBLIC ENTRY PROCEDURE = {  -- doesn't install a break at current CS:IP    ENABLE UNWIND => NULL;    pc: I186.Address ¬ 0;    BeSureInKernel[];    IF breaksInstalled THEN RETURN;    breaksInstalled ¬ TRUE;    FOR processor: IOPB.Processor IN IOPB.Processor DO      pc ¬ IOPBKernel.ReadPC[processor];      FOR finger: Breakpoint ¬ head[processor], finger.next UNTIL finger = NIL DO	finger.instruction ¬ IOPBKernel.ReadMemoryByte[	  finger.location, processor];	IF finger.location = pc THEN LOOP;	IOPBKernel.WriteMemoryByte[finger.location, processor, breakInstruction];	ENDLOOP;      ENDLOOP;    };      RemoveBreaks: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE UNWIND => NULL;    RemoveBreaksInternal[];    END;      RemoveBreaksInternal: INTERNAL PROCEDURE = {     pc: I186.Address;    BeSureInKernel[];    IF ~breaksInstalled THEN RETURN;    breaksInstalled ¬ FALSE;    FOR processor: IOPB.Processor IN IOPB.Processor DO      pc ¬ IOPBKernel.ReadPC[processor] ; -- backUp pc if at break      IF AtBreakInternal[pc - 1, processor] THEN {	ip: WORD ¬ IOPBKernel.ReadRegister[IP, processor]; -- decrement IP	IOPBKernel.WriteRegister[reg: IP, data: ip - 1, processor: processor];	};      FOR finger: Breakpoint ¬ head[processor], finger.next UNTIL finger = NIL DO	IOPBKernel.WriteMemoryByte[	  finger.location, processor, finger.instruction];	ENDLOOP;      ENDLOOP;    };          AtBreak: PUBLIC ENTRY PROCEDURE [pc: I186.Address, processor: IOPB.Processor]    RETURNS [yes: BOOLEAN] =    BEGIN ENABLE UNWIND => NULL;    BeSureInKernel[];    RETURN[AtBreakInternal[pc, processor]];    END;    AtBreakInternal: INTERNAL PROCEDURE [    pc: I186.Address, processor: IOPB.Processor] RETURNS [yes: BOOLEAN] =    BEGIN    FOR finger: Breakpoint ¬ head[processor], finger.next UNTIL finger = NIL DO      IF finger.location = pc THEN RETURN[TRUE];      ENDLOOP;    RETURN[FALSE];    END;    BeSureInKernel: INTERNAL PROCEDURE =    BEGIN    IF ~IOPBKernel.InKernel[] THEN ERROR IOPB.Error[code: cantAdjustBreaks];    END;    END.
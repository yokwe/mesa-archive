-- Copyright (C) 1980, 1981, 1982, 1984  by Xerox Corporation. All rights reserved. -- file CommandPack.Mesa, last modified by-- EXS          	September 22, 1980  12:26 PM-- Russ Atkinson	24-Nov-80 14:40:48-- BTL  		24-Aug-81 14:42:07 -- RES  		March 10, 1981  9:58 AM  -- LXR    		24-Aug-81 19:44:10 -- JGS			16-Sep-82 15:04:06 -- AXD    		23-Apr-84 12:27:36 DIRECTORY  Ascii: TYPE USING [CR, NUL],  CommandUtil USING [CommandObject, CommandPtr],  Format: TYPE USING [Char, StringProc, Text],  Heap USING [systemZone],	  String: TYPE USING [    AppendChar, AppendString, EquivalentSubStrings, SubString, SubStringDescriptor];CommandPack: PROGRAM    IMPORTS Format, Heap, String    EXPORTS CommandUtil    SHARES CommandUtil =  BEGIN OPEN CommandUtil, String;    z: UNCOUNTED ZONE = Heap.systemZone;    CR: Char = Ascii.CR;  Char: TYPE = CHARACTER;  Pair: TYPE = RECORD [key, val: LONG STRING, next: PairList];  PairList: PUBLIC TYPE = LONG POINTER TO Pair;  TokenClass: TYPE = Char;    id: TokenClass = 'I;    eom: TokenClass = Ascii.NUL;  State: TYPE = [0..17];    --  0:    --  1:    id    --  2:    id _    --  3:    [ ?{ARG},    --  4:    [ ?{ARG}, id    --  5:    [ ?{ARG}, id :    --  6:    [ ?{ARG}, id : id    --  7:    [ ?{ARG}, ]    --  8:    [ ?{ARG}, ] _    --  9:    LHS _ id    -- 10:    ?(LHS _) id [ ?{ARG},    -- 11:    ?(LHS _) id [ ?{ARG}, id    -- 12:    ?(LHS _) id [ ?{ARG}, id :    -- 13:    ?(LHS _) id [ ?{ARG}, id : id    -- 14:    ?(LHS _) id RHS    -- 15:    ?(LHS _) id ?RHS /    -- 16:    ?(?(LHS _) id ?RHS) / id    -- 17:    ?(?(LHS _) id ?RHS) ?(/ ?id) (;|eom)  |  eom    --            where LHS = id | [ ?{ARG}, ]    --                  RHS = [ ?{ARG}, ]      --                  ARG = id : id  |  id (if allowNoTagParm)   Failed: PUBLIC ERROR = CODE; -- stream-like utilities  Echo: PUBLIC PROC [d: Format.StringProc,              operator: LONG STRING,              argList, resultList: PairList,              switches: LONG STRING] = {    EchoList: PROC [list: PairList] = {       Format.Char[d, '[ ];       WHILE list # NIL DO         next: PairList ¬ list.next;         Format.Text[d, list.key];         Format.Text[d, ": "L];         Format.Text[d, list.val];         IF next # NIL THEN Format.Text[d, ", "L];         list ¬ next;         ENDLOOP;       Format.Char[d, '] ]};     IF resultList # NIL THEN {EchoList[resultList]; Format.Text[d, " ¬ "L]};     Format.Text[d, operator];     IF argList # NIL THEN EchoList[argList];     IF switches # NIL AND switches.length > 0 THEN {       Format.Text[d, "/"L]; Format.Text[d, switches]}};  -- object management  Create: PUBLIC PROC [get: PROCEDURE RETURNS [CHARACTER]] RETURNS [cmd: CommandPtr] = {    cmd ¬ z.NEW[CommandUtil.CommandObject ¬ [get,,]];    cmd.idString ¬ z.NEW[StringBody[100]]};  Destroy: PUBLIC PROC [cmd: CommandPtr] = {    IF cmd = NIL THEN RETURN;    z.FREE[@cmd.idString];    z.FREE[@cmd]};  -- external parsing routine  Parse: PUBLIC PROC [      cmd: CommandUtil.CommandPtr, opX, argX, resultX: CARDINAL, allowNoTagParm: BOOLEAN ¬ FALSE]    RETURNS [operator: LONG STRING, argList, resultList: PairList, switches: LONG STRING] = {    state: State;    RestoreToken: PROC = INLINE {cmd.reset ¬ TRUE};    NextToken: PROC = {      IF cmd.reset THEN {cmd.reset ¬ FALSE; RETURN};      WHILE cmd.c = '  OR cmd.c = CR DO cmd.c ¬ cmd.getChar[] ENDLOOP;      SELECT cmd.c FROM	IN ['a..'z], IN ['A..'Z], IN ['0..'9], '<, '., '+, '-, '~, '!, '$ => {	  cmd.idString.length ¬ 0;	  WHILE TRUE	    DO	    SELECT cmd.c FROM	      IN ['a..'z], IN ['A..'Z], IN ['0..'9],	      '<, '>, '., '+, '-, '~, '!, '$ => {		AppendChar[cmd.idString, cmd.c];  cmd.c ¬ cmd.getChar[]};	      ENDCASE => EXIT;	    ENDLOOP;	  cmd.token ¬ id};	'_, '[, ',, '], ':, '/ => {cmd.token ¬ cmd.c;  cmd.c ¬ cmd.getChar[]};	'" => {	  cmd.idString.length ¬ 0;	  DO	    cmd.c ¬ cmd.getChar[];	    IF cmd.c = '" THEN {cmd.c ¬ cmd.getChar[];  IF cmd.c # '" THEN EXIT};	    String.AppendChar[cmd.idString, cmd.c];	    ENDLOOP;	  cmd.token ¬ id};	';, eom => cmd.token ¬ cmd.c;	254c => {cmd.token ¬ '_; cmd.c ¬ cmd.getChar[]};	ENDCASE => BadCommand[]};    CopyId: PROC [extra: CARDINAL] RETURNS [LONG STRING] = INLINE {      RETURN[CopyString[cmd.idString, extra]]};    pair: ARRAY [0..1] OF LONG STRING;    PushArg: PROC = {argList ¬ AddPair[argList, pair[0], pair[1]]};    PushResult: PROC = {resultList ¬ AddPair[resultList, pair[0], pair[1]]};    BadCommand: PROC = {      operator ¬ FreeString[operator];      resultList ¬ FreePairList[resultList];      argList ¬ FreePairList[argList];      switches ¬ FreeString[switches];      ERROR Failed};    IF ~cmd.reset THEN cmd.c ¬ ' ;    state ¬ 0;  operator ¬ switches ¬ NIL;    argList ¬ resultList ¬ NIL;    UNTIL state = LAST[State] DO      NextToken[];      SELECT cmd.token FROM	id =>	  SELECT state FROM	    0 =>    {operator ¬ CopyId[MAX[resultX, opX]]; state ¬ 1};	    2, 8 => {operator ¬ CopyId[opX]; state ¬ 9};	    3 =>    {pair[0] ¬ CopyId[0]; state ¬ 4};	    5 =>    {pair[1] ¬ CopyId[resultX]; PushResult[]; state ¬ 6};	    10 =>   {pair[0] ¬ CopyId[0]; state ¬ 11};	    12 =>   {pair[1] ¬ CopyId[argX]; PushArg[]; state ¬ 13};	    15 =>   {switches ¬ CopyId[0]; state ¬ 16};	    1, 9, 14, 16 => {RestoreToken[]; state ¬ 17};	    ENDCASE => BadCommand[];	'_ =>	  SELECT state FROM	    1 => {	      pair[0] ¬ NIL; pair[1] ¬ operator;  operator ¬ NIL;	      PushResult[];  state ¬ 2};	    7 => state ¬ 8;	    ENDCASE => BadCommand[];	'[ =>	  SELECT state FROM	    0 => state ¬ 3;	    1, 9 => state ¬ 10;	    14 => {RestoreToken[]; state ¬ 17};	    ENDCASE => BadCommand[];	'] =>	  SELECT state FROM	    3, 6 => state ¬ 7;	    4 => IF allowNoTagParm THEN {	            pair[1] ¬ pair[0];  pair[0] ¬ NIL;		    PushArg[];  state ¬ 7}		  ELSE BadCommand[];	    10, 13 => state ¬ 14;	    11 => IF allowNoTagParm THEN {	            pair[1] ¬ pair[0];  pair[0] ¬ NIL;		    PushArg[];  state ¬ 14}		  ELSE BadCommand[];	    ENDCASE => BadCommand[];	': =>	  SELECT state FROM	    4 => state ¬ 5;	    11 => state ¬ 12;	    ENDCASE => BadCommand[];	', =>	  SELECT state FROM	    4 => IF allowNoTagParm THEN {	            pair[1] ¬ pair[0];  pair[0] ¬ NIL;		    PushArg[];  state ¬ 3}		  ELSE BadCommand[];	    6 => state ¬ 3;	    11 => IF allowNoTagParm THEN {	            pair[1] ¬ pair[0];  pair[0] ¬ NIL;		    PushArg[];  state ¬ 10}		  ELSE BadCommand[];	    13 => state ¬ 10;	    ENDCASE => BadCommand[];	'/ =>	  SELECT state FROM	    0, 1, 9, 14 => state ¬ 15;	    ENDCASE => BadCommand[];	'; =>	  SELECT state FROM	    1, 9, 14, 15, 16 => state ¬ 17;	    ENDCASE => BadCommand[];	eom =>	  SELECT state FROM	    0, 1, 9, 14, 15, 16 => state ¬ 17;	    ENDCASE => BadCommand[];	ENDCASE;      ENDLOOP;    RETURN};  CopyString: PUBLIC PROC [s: LONG STRING, extra: CARDINAL ¬ 0] RETURNS [LONG STRING] = {    copy: LONG STRING = z.NEW[StringBody[IF s=NIL THEN 0 ELSE s.length + extra]];    IF s # NIL THEN AppendString[copy, s];  RETURN [copy]};  FreeString: PUBLIC PROC [s: LONG STRING] RETURNS [LONG STRING] = {    IF s # NIL THEN z.FREE[@s]; RETURN [NIL]}; -- PairList utilities  GetNthPair: PUBLIC PROC [list: PairList, n: CARDINAL, delete: BOOLEAN ¬ FALSE]      RETURNS [key,value: LONG STRING ¬ NIL] = {    i: CARDINAL ¬ 0;    FOR p: PairList ¬ list, p.next UNTIL p = NIL      DO      IF i = n THEN {key ¬ p.key;  value ¬ p.val;  IF delete THEN p.key ¬ p.val ¬ NIL;  EXIT};      i ¬ i+1;      ENDLOOP;    RETURN};  ListLength: PUBLIC PROC [list: PairList] RETURNS [n: CARDINAL ¬ 0] = {    FOR p: PairList ¬ list, p.next UNTIL p = NIL DO n ¬ n+1 ENDLOOP;    RETURN};  KeyValue: PUBLIC PROC [key: String.SubString, list: PairList, delete: BOOLEAN ¬ FALSE]      RETURNS [s: LONG STRING ¬ NIL] = {    FOR p: PairList ¬ list, p.next UNTIL p = NIL      DO      ss: String.SubStringDescriptor ¬ [base: p.key, offset: 0, length: p.key.length];      IF String.EquivalentSubStrings[@ss, key]	THEN {s ¬ p.val; IF delete THEN p.val ¬ NIL; EXIT};      ENDLOOP;    RETURN};  FreePairList: PUBLIC PROC [list: PairList] RETURNS [PairList] = {    next: PairList;    p: PairList ¬ list;    UNTIL p = NIL      DO       next ¬ p.next;      [] ¬ FreeString[p.key]; [] ¬ FreeString[p.val];      z.FREE[@p];  p ¬ next;      ENDLOOP;    RETURN [NIL]};  AddPair: PUBLIC PROC [list: PairList, key,val: LONG STRING] RETURNS [PairList] = {    new: PairList ¬ z.NEW[Pair ¬ [key: key, val: val, next: NIL]];    p: PairList;    IF list = NIL THEN list ¬ new    ELSE {      FOR p ¬ list, p.next UNTIL p.next = NIL DO ENDLOOP;      p.next ¬ new};    RETURN [list]};  SetExtension: PUBLIC PROC [root, defaultExt: LONG STRING] RETURNS [name: LONG STRING] = {    SELECT TRUE FROM      ~Dotted[root] => {	name ¬ AdjustString[root, defaultExt.length + 2];	AppendChar[name, '.];	AppendString[name, defaultExt]};      ENDCASE => name ¬ root;    RETURN}; -- string utilities  Dotted: PROC [s: LONG STRING] RETURNS [BOOLEAN] = INLINE {    FOR i: CARDINAL IN [0..s.length) DO IF s[i] = '. THEN RETURN [TRUE] ENDLOOP;    RETURN [FALSE]}; -- storage allocation  AdjustString: PROC [old: LONG STRING, extra: CARDINAL] RETURNS [new: LONG STRING] = {    IF old.length + extra <= old.maxlength      THEN new ¬ old      ELSE {	new ¬ z.NEW[StringBody[old.length + extra]];	AppendString[new, old];	z.FREE[@old]};    RETURN};  END.
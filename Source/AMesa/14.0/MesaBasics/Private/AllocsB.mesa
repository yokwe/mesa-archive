-- Copyright (C) 1981, 1983, 1984, 1985  by Xerox Corporation. All rights reserved. -- AllocsB.Mesa; edited by:-- Bruce	20-Aug-81 11:37:38-- Sweet	22-Mar-84 13:17:05-- Haynes	13-May-83 17:49:11-- Johnsson	20-May-83 10:41:22DIRECTORY  Alloc USING [    Base, defaultChunkType, defaultIndexBits, defaultTileSize,     Failure, maxForBits, Notifier, Overflow, pagesForBits, Selector, TableInfo],  AllocOps USING [    BaseSeq, BasesHandle, BitsSeq, ChunkHandle, ChunkObject, ChunkSeq, Handle,     InstanceData, NotifyChainHandle,    NotifyNode, NullChunkIndex, SizeSeq, SpaceSeq],  Environment USING [PageCount, PageOffset, wordsPerPage],  File USING [nullFile],  Heap USING [Create, Delete],  Inline USING [LongCOPY, LongDiv],  Space USING [    Allocate, Deallocate, Interval, MapAt, nullInterval, unknownUsage, UnmapAt];AllocsB: MONITOR LOCKS h USING h: Handle  IMPORTS Alloc, Heap, Inline, Space  EXPORTS Alloc, AllocOps =  BEGIN OPEN Alloc, AllocOps;  InstanceData: PUBLIC TYPE = AllocOps.InstanceData;  fileTileSize: CARDINAL = 32; -- must be >= tileSize;    PagesForWords: PROC [words: CARDINAL] RETURNS [CARDINAL] = {    RETURN[      Inline.LongDiv[LONG[words] + Environment.wordsPerPage-1,      Environment.wordsPerPage]]};  -- stack allocation from zones  GrowTable: PUBLIC INTERNAL PROC [h: Handle, table: Selector, newTop: CARDINAL] =    BEGIN    newPages: CARDINAL = PagesForWords[newTop+1];      -- N.B. the last word of the VM for the table is never allocated      -- AllocsA won't call GrowTable if newTop > maxForBits[tableBits]    newTiles: CARDINAL = ((newPages+h.tileSize-1)/h.tileSize) * h.tileSize;    IF newPages > h.vmPages[table] THEN {      extra: CARDINAL = SIGNAL Overflow[h, table];      newVM: CARDINAL = MIN[maxForBits[h.indexBits[table]], newPages + extra];      newSpace: Space.Interval = Space.Allocate[count: newVM];      oldSpace: Space.Interval = h.spaces[table];      tilePages: CARDINAL = MIN[newTiles, newVM];      [] ¬ Space.MapAt[        at: [pointer: newSpace.pointer, count: tilePages], 	window: [file: File.nullFile, base: NULL, count: tilePages],	usage: -- alloc -- Space.unknownUsage, swapUnits: [uniform[h.tileSize]]];      Inline.LongCOPY[        from: oldSpace.pointer, to: newSpace.pointer, nwords: h.top[table]];      DeleteZone[oldSpace, h.limit[table]];      h.spaces[table] ¬ newSpace;      h.base[table] ¬ LOOPHOLE[newSpace.pointer];      h.vmPages[table] ¬ newVM;      h.limit[table] ¬ tilePages*Environment.wordsPerPage - 1;      RunNotifierChain[h]}    ELSE {      deltaPages: CARDINAL =        (MIN[newTiles, h.vmPages[table]]) - PagesForWords[h.limit[table]];      [] ¬ Space.MapAt[        at: [pointer: h.base[table] + h.limit[table]+1, count: deltaPages], 	window: [file: File.nullFile, base: NULL, count: deltaPages],	usage: -- alloc -- Space.unknownUsage, swapUnits: [uniform[h.tileSize]]];	h.limit[table] ¬ h.limit[table] + deltaPages*Environment.wordsPerPage};    END;      -- initialization, expansion and termination  DeleteZone: PROC [s: Space.Interval, tableMax: CARDINAL] = {    ENABLE UNWIND => NULL;    p: LONG ORDERED POINTER ¬ LOOPHOLE[s.pointer];    limit: LONG ORDERED POINTER ¬ p + tableMax;    WHILE p <= limit DO      si: Space.Interval = Space.UnmapAt[p, wait];      p ¬ LOOPHOLE[si.pointer + si.count*Environment.wordsPerPage];      ENDLOOP;    Space.Deallocate[s]};  Create: PUBLIC PROC [      weights: DESCRIPTOR FOR ARRAY OF TableInfo,       tileSize: CARDINAL ¬ defaultTileSize]     RETURNS [h: Handle] = {    az: UNCOUNTED ZONE = Heap.Create[initial: 1];     cnt: CARDINAL = LENGTH[weights];    h ¬ az.NEW[InstanceData ¬ [      nTables: cnt, z: az,      tileSize: tileSize, notifiers: NIL,      indexBits: az.NEW[BitsSeq[cnt]],      base: az.NEW[BaseSeq[cnt]],      spaces: az.NEW[SpaceSeq[cnt]],      chunks: az.NEW[ChunkSeq[cnt]],      top: az.NEW[SizeSeq[cnt]],      limit: az.NEW[SizeSeq[cnt]],      vmPages: az.NEW[SizeSeq[cnt]],      clientData: NIL]];    IF tileSize >= fileTileSize THEN ERROR;    FOR i: CARDINAL IN [0..cnt) DO       InitTable[h, i, weights[i]];      ENDLOOP};  InitTable: PROC [h: Handle, table: Selector, info: TableInfo] = {    max: CARDINAL = info.initialVMemPages;    ipages: CARDINAL = info.initialPages;    IF ipages > max OR max > pagesForBits[info.indexBits] THEN       ERROR Failure[h, table];    h.indexBits[table] ¬ info.indexBits;    h.vmPages[table] ¬ max;    h.spaces[table] ¬ IF max # 0 THEN Space.Allocate[count: max]       ELSE Space.nullInterval;    h.base[table] ¬ LOOPHOLE[h.spaces[table].pointer];    h.top[table] ¬ h.limit[table] ¬ 0;    h.chunks[table] ¬ NIL;    IF ipages # 0 THEN {      [] ¬ Space.MapAt[	at: [pointer: h.spaces[table].pointer, count: ipages], 	window: [file: File.nullFile, base: NULL, count: ipages],	usage: -- alloc -- Space.unknownUsage, swapUnits: [uniform[h.tileSize]]];      h.limit[table] ¬ ipages*Environment.wordsPerPage - 1}};       ResetTable: PUBLIC ENTRY PROC [h: Handle, table: Selector, info: TableInfo] = {    ENABLE UNWIND => NULL;    DeleteZone[h.spaces[table], h.limit[table]];    InitTable[h, table, info];    RunNotifierChain[h]};  Destroy: PUBLIC PROC [h: Handle] = {DestroyEntry[h]; Heap.Delete[h.z]};  DestroyEntry: ENTRY PROC [h: Handle] = {    ENABLE UNWIND => NULL;    i: CARDINAL;    FOR i IN [0..h.nTables) DO      h.base[i] ¬ NIL;      ENDLOOP;    RunNotifierChain[h];    FOR i IN [0..h.nTables) DO DeleteZone[h.spaces[i], h.limit[i]] ENDLOOP};  Reset: PUBLIC ENTRY PROC [h: Handle] = {    ENABLE UNWIND => NULL;    FOR i: CARDINAL IN [0..h.nTables) DO       h.top[i] ¬ 0;      ResetChunkInternal[h, i];      ENDLOOP};  Chunkify: PUBLIC ENTRY PROC [      h: Handle, table: Selector ¬ defaultChunkType,       firstSmall: CARDINAL ¬ 3, nSmall: CARDINAL ¬ 4] = {    ENABLE UNWIND => NULL;    ch: ChunkHandle ¬ h.chunks[table];    IF ch # NIL THEN ERROR Failure[h, table];    ch ¬ h.z.NEW[ChunkObject[nSmall]];    ch.firstSmall ¬ firstSmall;    h.chunks[table] ¬ ch;    ResetChunkInternal[h, table]};  UnChunkify: PUBLIC ENTRY PROC [h: Handle, table: Selector] = {    ENABLE UNWIND => NULL;    IF h.chunks[table] = NIL THEN RETURN;    h.z.FREE[@h.chunks[table]]};  Trim: PUBLIC ENTRY PROC [h: Handle, table: Selector, size: CARDINAL] = {    ENABLE UNWIND => NULL;    IF size <= h.top[table] THEN {h.top[table] ¬ size; ResetChunkInternal[h, table]}    ELSE ERROR Failure[h, table]};  ResetChunk: PUBLIC ENTRY PROC [h: Handle, table: Selector] = {    ResetChunkInternal[h, table ! UNWIND => NULL]};      ResetChunkInternal: INTERNAL PROC [h: Handle, table: Selector] = {    ch: ChunkHandle ¬ h.chunks[table];    IF ch = NIL THEN RETURN;    ch.chunkRover ¬ NullChunkIndex;    FOR i: CARDINAL IN [0..ch.nSmall) DO ch.smallLists[i] ¬ NullChunkIndex ENDLOOP};      --   Notifier stuff    AddNotify: PUBLIC ENTRY PROC [      h: Handle, proc: Alloc.Notifier, clientData: LONG POINTER] = {    ENABLE UNWIND => NULL;    p: NotifyChainHandle = h.z.NEW[NotifyNode ¬ [      notifier: proc, clientData: clientData, link: h.notifiers]];    h.notifiers ¬ p;    proc[DESCRIPTOR[h.base, h.nTables], clientData]};  DropNotify: PUBLIC ENTRY PROC [    h: Handle, proc: Alloc.Notifier, clientData: LONG POINTER] = {    ENABLE UNWIND => NULL;    p, q: NotifyChainHandle;    IF h.notifiers = NIL THEN RETURN;    p ¬ h.notifiers;    IF p.notifier = proc AND p.clientData = clientData THEN      h.notifiers ¬ p.link    ELSE {      WHILE TRUE DO	q ¬ p;	p ¬ p.link;	IF p = NIL THEN RETURN;	IF p.notifier = proc AND p.clientData = clientData THEN EXIT	ENDLOOP;      q.link ¬ p.link};    h.z.FREE[@p]};      RunNotifierChain: INTERNAL PROC [h: Handle] = {    FOR p: NotifyChainHandle ¬ h.notifiers, p.link UNTIL p = NIL DO      p.notifier[DESCRIPTOR[h.base, h.nTables], p.clientData];      ENDLOOP};         -- client data stuff     GetZone: PUBLIC ENTRY PROC [h: Handle] RETURNS [UNCOUNTED ZONE]= {    RETURN[h.z]};  SetClientData: PUBLIC ENTRY PROC [h: Handle, data: LONG POINTER]= {    h.clientData ¬ data};  GetClientData: PUBLIC ENTRY PROC [h: Handle] RETURNS [LONG POINTER]= {    RETURN[h.clientData]};  END.
-- Copyright (C) 1981, 1984, 1986  by Xerox Corporation. All rights reserved. -- file AllocsA.Mesa-- last modified by Sweet, 15-Mar-84 10:25:27-- last modified by Bruce, 20-Aug-81 11:52:50-- last modified by Satterthwaite, July 25, 1980  4:02 PMDIRECTORY  Alloc USING [    Base, Index, maxForBits, OrderedIndex, Selector],  AllocOps USING [    BaseSeq, BasesHandle, Chunk, ChunkHandle, CIndex, GrowTable, Handle,     InstanceData, NullChunkIndex],  Inline USING [LowHalf];AllocsA: MONITOR LOCKS h USING h: Handle IMPORTS AllocOps, Inline EXPORTS Alloc =  BEGIN OPEN Alloc, AllocOps;  Failure: PUBLIC ERROR [h: Handle, table: Selector] = CODE;  Overflow: PUBLIC SIGNAL [h: Handle, table: Selector] RETURNS [extra: CARDINAL] = CODE;    InstanceData: PUBLIC TYPE = AllocOps.InstanceData;  -- stack allocation from subzones  Words: PUBLIC ENTRY PROC [h: Handle, table: Selector, size: CARDINAL] RETURNS [index: OrderedIndex] = {    RETURN[WordsInternal[h, table, size ! UNWIND => NULL]]};  WordsInternal: INTERNAL PROC [h: Handle, table: Selector, size: CARDINAL] RETURNS [OrderedIndex] = INLINE {    index: CARDINAL = h.top[table];    newTop: LONG CARDINAL = LONG[index] + size; -- could overflow for 16 bit pointers    IF newTop > h.limit[table] THEN {      IF newTop > maxForBits[h.indexBits[table]] THEN ERROR Failure[h, table];      AllocOps.GrowTable[h, table, Inline.LowHalf[newTop]]};     h.top[table] ¬ Inline.LowHalf[newTop];    RETURN[LOOPHOLE[index]]};      -- linked list allocation    GetChunk: PUBLIC ENTRY PROC [h: Handle, size: CARDINAL, table: Selector]       RETURNS [Index] = {    ENABLE UNWIND => NULL;    ch: ChunkHandle = h.chunks[table];    cb: Base = h.base[table];    q: CIndex;    IF ch = NIL THEN ERROR Failure[h, table];    size ¬ MAX[size, SIZE[Chunk]];    BEGIN    IF size IN [ch.firstSmall..ch.firstSmall+ch.nSmall) THEN       BEGIN      offset: CARDINAL = size - ch.firstSmall;      q ¬ ch.smallLists[offset];      IF q # NullChunkIndex THEN {ch.smallLists[offset] ¬ cb[q].fLink; GO TO found};      END;    q ¬ GetRoverChunk[h: h, size: size, table: table];    IF q # NullChunkIndex THEN GO TO found;    q ¬ WordsInternal[h: h, table: table, size: size ! Failure => GO TO noneAtEnd];    EXITS      noneAtEnd =>        BEGIN -- none the right size, no space at the end, and no big ones to split	FOR s: CARDINAL IN [ch.firstSmall.. ch.firstSmall+ch.nSmall) DO          offset: CARDINAL = s - ch.firstSmall;          r: CIndex ¬ ch.smallLists[offset];          WHILE r # NullChunkIndex DO            next: CIndex = cb[r].fLink;	    FreeRoverChunk[h: h, index: r, size: s, table: table];	    r ¬ next;	    ENDLOOP;          ch.smallLists[offset] ¬ NullChunkIndex;          ENDLOOP;        -- now all possible merges of free nodes can happen        q ¬ GetRoverChunk[h: h, size: size, table: table];        IF q = NullChunkIndex THEN ERROR Failure[h, table];        END;      found => NULL;    END;    h.base[table][q].free ¬ FALSE;    RETURN[q]};  GetRoverChunk: INTERNAL PROC [h: Handle, size: CARDINAL, table: Selector]       RETURNS [Index] = {    ch: ChunkHandle = h.chunks[table];    cb: Base = h.base[table];    p, q, next: CIndex;    nodeSize: CARDINAL;    n: INTEGER;    BEGIN    IF (p ¬ ch.chunkRover) = NullChunkIndex THEN GO TO notFound;    -- search for a chunk to allocate    DO      nodeSize ¬ cb[p].size;      WHILE (next ¬ p + nodeSize) # LOOPHOLE[h.top[table], CIndex] AND cb[next].free DO	cb[cb[next].bLink].fLink ¬ cb[next].fLink;	cb[cb[next].fLink].bLink ¬ cb[next].bLink;	cb[p].size ¬ nodeSize ¬ nodeSize + cb[next].size;	ch.chunkRover ¬ p; -- in case next = chunkRover	ENDLOOP;      SELECT n ¬ nodeSize - size FROM	= 0 => {	  IF cb[p].fLink = p THEN ch.chunkRover ¬ NullChunkIndex	  ELSE {	    ch.chunkRover ¬ cb[cb[p].bLink].fLink ¬ cb[p].fLink;	    cb[cb[p].fLink].bLink ¬ cb[p].bLink};	  q ¬ p;	  GO TO found};	>= SIZE[Chunk] => {	  cb[p].size ¬ n; ch.chunkRover ¬ p; q ¬ p + n; GO TO found};	ENDCASE;      IF (p ¬ cb[p].fLink) = ch.chunkRover THEN GO TO notFound;      ENDLOOP;    EXITS found => NULL; notFound => q ¬ NullChunkIndex;    END;    RETURN[q]};  FreeChunk: PUBLIC ENTRY PROC [      h: Handle, index: Index, size: CARDINAL, table: Selector] = {    ENABLE UNWIND => NULL;    ch: ChunkHandle = h.chunks[table];    cb: Base = h.base[table];    p: CIndex = LOOPHOLE[index];    IF ch = NIL THEN ERROR Failure[h, table];    cb[p].size ¬ size ¬ MAX[size, SIZE[Chunk]];    IF size IN [ch.firstSmall..ch.firstSmall+ch.nSmall) THEN {      offset: CARDINAL = size - ch.firstSmall;      cb[p].fLink ¬ ch.smallLists[offset];      ch.smallLists[offset] ¬ p;      -- don't set cb[p].free ¬ TRUE; to avoid coalescing nodes      cb[p].bLink ¬ NullChunkIndex; -- note, only singly linked      RETURN};    FreeRoverChunk[h: h, index: index, size: size, table: table]};  FreeRoverChunk: INTERNAL PROC [      h: Handle, index: Index, size: CARDINAL, table: Selector] = {    ch: ChunkHandle = h.chunks[table];    cb: Base = h.base[table];    p: CIndex = LOOPHOLE[index];    IF ch = NIL THEN ERROR Failure[h, table];    cb[p].size ¬ size ¬ MAX[size, SIZE[Chunk]];    IF ch.chunkRover = NullChunkIndex THEN ch.chunkRover ¬ cb[p].fLink ¬ cb[p].bLink ¬ p    ELSE {      rover: CIndex = ch.chunkRover;      cb[p].fLink ¬ cb[rover].fLink;      cb[cb[p].fLink].bLink ¬ p;      cb[p].bLink ¬ rover;      cb[rover].fLink ¬ p};    cb[p].free ¬ TRUE};  -- queries    Bounds: PUBLIC ENTRY PROC [h: Handle, table: Selector] RETURNS     [base: Base, size: CARDINAL] = {    RETURN[h.base[table], h.top[table]]};  Top: PUBLIC ENTRY PROC [h: Handle, table: Selector] RETURNS [OrderedIndex] = {    RETURN[FIRST[OrderedIndex] + h.top[table]]};  END.
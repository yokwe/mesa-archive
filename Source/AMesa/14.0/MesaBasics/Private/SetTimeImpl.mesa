-- File: SetTimeImpl.mesa - last edit:-- AOF                 13-Sep-87 17:09:09-- HGM                 11-Nov-81  2:04:59-- CXH                  9-Apr-83 18:50:36-- AXD                 18-Jul-83 12:06:18-- AOF                 21-Sep-84 16:55:22-- Copyright (C) 1981, 1983, 1986, 1987 by Xerox Corporation. All rights reserved. DIRECTORY  DeviceCleanup USING [Perform],  Environment USING [Block, bytesPerWord],  NSConstants USING [timeServerSocket],  PacketExchange USING [    CreateRequestor, Delete, Error, ExchangeClientType, ExchangeHandle,    ExchWords, SendRequest, Timeout],  Process USING [MsecToTicks, Pause],  ProcessorFace USING [GreenwichMeanTime, SetGreenwichMeanTime],  Router USING [FindDestinationRelativeNetID],  SetTime USING [],  System USING [    broadcastHostNumber, gmtEpoch, GreenwichMeanTime, LocalTimeParameters,    NetworkAddress, nullNetworkNumber, SetLocalTimeParameters, WestEast];SetTimeImpl: PROGRAM  IMPORTS DeviceCleanup, PacketExchange, Process, ProcessorFace, Router, System  EXPORTS SetTime =  BEGIN  bpw: NATURAL = Environment.bytesPerWord;  PacketType: TYPE = MACHINE DEPENDENT{request(1), response(2)};  WireTimeFormat: TYPE = MACHINE DEPENDENT RECORD [    wiretime(0): LONG UNSPECIFIED ¬ System.gmtEpoch,    direction(2): System.WestEast,    zone(3), offsetMinutes(4): WORD,    beginDST(5), endDST(6): WORD,    toleranceSpecified(7): BOOLEAN,    tolerance(8): ARRAY [0..2) OF WORD];  TimeHeader: TYPE = RECORD [    protocolVersion: CARDINAL,    data: SELECT packetType: PacketType FROM      request => [], response => [wtf: WireTimeFormat], ENDCASE];  GetTime: PROC RETURNS [    time: System.GreenwichMeanTime ¬ System.gmtEpoch,    ltp: System.LocalTimeParameters] = {    wt: TimeHeader;    nbytes: NATURAL;    target: System.NetworkAddress;    pex: PacketExchange.ExchangeHandle;    target ¬ [      Router.FindDestinationRelativeNetID[System.nullNetworkNumber],      System.broadcastHostNumber, NSConstants.timeServerSocket];    pex ¬ PacketExchange.CreateRequestor[2500, 700];  --3 times @ 700 msecs    THROUGH[0..3) --OR EXIT-- DO      ENABLE PacketExchange.Timeout, PacketExchange.Error => EXIT;      replyType: PacketExchange.ExchangeClientType;      wt ¬ [protocolVersion: 2, data: request[]];  --reply overwrites data      [nbytes, replyType] ¬ PacketExchange.SendRequest[	h: pex, remote: target, requestType: timeService,	requestBlk: [LOOPHOLE[LONG[@wt]], 0, bpw * SIZE[request TimeHeader]],	replyBlk: [LOOPHOLE[LONG[@wt]], 0, bpw * SIZE[response TimeHeader]]];      SELECT TRUE FROM	(replyType # timeService) => LOOP;  --that wasn't nice	(nbytes < bpw * SIZE[response TimeHeader]) => LOOP;  --neither was that	ENDCASE;  --this one wins      WITH wt SELECT FROM	response =>	  BEGIN	  time ¬ [PacketExchange.ExchWords[wtf.wiretime]];	  ltp ¬ [	    direction: wtf.direction, zone: wtf.zone,	    zoneMinutes: wtf.offsetMinutes,	    beginDST: wtf.beginDST, endDST: wtf.endDST];	  EXIT;	  END;	ENDCASE;  --crude attempt at trickery    ENDLOOP;    Process.Pause[Process.MsecToTicks[100]];  --wait for broadcasting to stop    PacketExchange.Delete[pex]};  --before gunning the socket  Set: PUBLIC PROC RETURNS [BOOLEAN] = {    time: System.GreenwichMeanTime;    ltp: System.LocalTimeParameters;    [time, ltp] ¬ GetTime[];    IF time = System.gmtEpoch THEN RETURN[FALSE];    ProcessorFace.SetGreenwichMeanTime[time];    DeviceCleanup.Perform[turnOff];    DeviceCleanup.Perform[turnOn];    System.SetLocalTimeParameters[ltp];    RETURN[TRUE]};    END...
-- Copyright (C) 1980, 1982  by Xerox Corporation. All rights reserved. -- CharIOImpl.Mesa-- Edited by BXM   on January 8, 1981  4:53 PM-- Edited by Russ Atkinson on 29-Oct-80 10:23:47-- Edited by JGS on 16-Sep-82 14:51:20-- WARNING: must be compiled without bounds checking!DIRECTORY  CharIO USING [CR, Handle, NumberFormat, SP],  Stream USING [GetChar, PutChar, PutString],  String USING [AppendChar, SubString];CharIOImpl: PROGRAM IMPORTS String, Stream EXPORTS CharIO =  BEGIN OPEN CharIO, String;  Char: TYPE = CHARACTER;    -- String i/o    GetChar: PUBLIC PROC [in: Handle] RETURNS [CHARACTER] = {RETURN[in.GetChar[]]};  GetString: PUBLIC PROC [    in: Handle, s: LONG STRING, test: PROC [Char] RETURNS [BOOLEAN]] = {    DO      c: Char ¬ 0C;      c ¬ GetChar[in ! ANY => EXIT];      IF test[c] THEN EXIT;      AppendChar[s, c];      ENDLOOP};      PutChar: PUBLIC PROC [out: Handle, c: CHARACTER] = {out.PutChar[c]};  PutString: PUBLIC PROC [out: Handle, s: LONG STRING] = {    IF s # NIL THEN out.PutString[s]};      PutLine: PUBLIC PROC [out: Handle, s: LONG STRING] = {    PutString[out, s]; PutChar[out, CR]};  PutSubString: PUBLIC PROC [out: Handle, ss: SubString] = {    s: LONG STRING ¬ ss.base;    IF s # NIL THEN      FOR i: CARDINAL IN [ss.offset..ss.offset + ss.length) DO        PutChar[out, s[i]] ENDLOOP};      GetLine: PUBLIC PROC [in: Handle, s: LONG STRING] = {GetString[in, s, IsCR]};      IsCR: PROC [c: Char] RETURNS [BOOLEAN] = {RETURN[c = CR]};      GetId: PUBLIC PROC [in: Handle, s: LONG STRING] = {    c: Char ¬ SP;    DO c ¬ GetChar[in ! ANY => EXIT]; IF c # SP THEN EXIT; ENDLOOP;    DO      IF c = SP OR c = CR THEN EXIT;      AppendChar[s, c];      c ¬ GetChar[in ! ANY => EXIT];      ENDLOOP};      --  Numerical i/o    GetNumber: PUBLIC PROC [in: Handle, radix: CARDINAL] RETURNS [UNSPECIFIED] = {    number: CARDINAL ¬ 0;    negative: BOOLEAN ¬ FALSE;    s: STRING = [10];    last: Char ¬ '0;    pos, len: CARDINAL ¬ 0;    GetId[in, s];    len ¬ s.length;    IF len > 0 THEN last ¬ s[len-1];    IF last = 'B THEN {radix ¬ 8; len ¬ len-1};    IF last = 'D THEN {radix ¬ 10; len ¬ len-1};    IF pos < len AND s[pos] = '- THEN {pos ¬ pos + 1; negative ¬ TRUE};    FOR pos IN [pos..len) DO        number ¬ number * radix + (s[pos] - '0);        ENDLOOP;    IF negative THEN number ¬ -number;    RETURN[number]};      PutNumber: PUBLIC PROC [out: Handle, val: INTEGER, format: NumberFormat] = {    i: CARDINAL ¬ 0;    neg: BOOLEAN ¬ FALSE;    fill: Char = (IF format.zerofill THEN '0 ELSE ' );    s: STRING = [17];    card: CARDINAL ¬ val;    radix: CARDINAL = format.base;    IF radix < 2 OR radix > 36 THEN ERROR;    IF val < 0 AND ~format.unsigned THEN {card ¬ -card; neg ¬ TRUE};    DO      digit: CARDINAL ¬ card MOD radix;      IF digit > 9         THEN digit ¬ digit + LOOPHOLE['A, CARDINAL] - 10         ELSE digit ¬ digit + LOOPHOLE['0, CARDINAL];       s[i] ¬ LOOPHOLE[digit];      i ¬ i + 1;      IF (card ¬ card / radix) = 0 THEN EXIT;      ENDLOOP;    s.length ¬ i;    IF neg THEN {i ¬ i + 1; IF format.zerofill THEN {PutChar[out, '-]; neg ¬ FALSE}};     THROUGH (i..format.columns] DO PutChar[out, fill] ENDLOOP;    IF neg THEN PutChar[out, '-];    i ¬ s.length;    WHILE i > 0 DO PutChar[out, s[i ¬ i - 1]] ENDLOOP;    };      PutDecimal: PUBLIC PROC [out: Handle, n: INTEGER] =    {PutNumber[out, n, NumberFormat[10, FALSE, FALSE, 0]]};      PutOctal: PUBLIC PROC [out: Handle, n: UNSPECIFIED] =    {PutNumber[out, n, NumberFormat[8, FALSE, TRUE, 0]];     IF n ~ IN [0..7] THEN PutChar[out, 'B]};    END.  
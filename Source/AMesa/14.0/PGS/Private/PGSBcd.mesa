-- Copyright (C) 1981, 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- PGSBcd.Mesa--   JGS		 4-Nov-82 12:02:55--   EXS          	March 16, 1981  1:54 PM--   BTL  		29-Oct-81 18:28:28--   RXJ     		 6-Jul-83 22:16:21--   NFS		11-Aug-87 17:34:03DIRECTORY  BcdDefs: TYPE,  BcdDefsExtras USING [NewMesaModule],  BcdOps: TYPE USING [EXPHandle, NameString],  Environment: TYPE USING [bytesPerPage, bytesPerWord],  Inline: TYPE USING [LowHalf],  PGSConDefs: TYPE USING [    objectVersion, outeol, outstring, pgsVersion,    resetoutstream, seterrstream, sourceVersion, warningsLogged, WriteSymbols],  MFile USING [SetTimes],  MSegment: TYPE USING [Handle],  MStream USING [GetFile],  Spaces: TYPE USING [Node, Free, FreeString, PagesForWords, String],  Stream: TYPE USING [Handle, GetPosition, SetPosition, PutByte, PutBlock],  String: TYPE USING [AppendChar, AppendString],  TableCommand: TYPE USING [FindInterface, FindItem, BadInterface];PGSBcd: PROGRAM    IMPORTS      Inline, MFile, MStream, PGSConDefs, Spaces, Stream, String, TableCommand    EXPORTS PGSConDefs = { -- BCD construction  bcdHeader: BcdDefs.BCD;  module: BcdDefs.MTRecord;  export: BcdOps.EXPHandle;  codeSeg, symbolSeg: BcdDefs.SGRecord;  ssb: BcdOps.NameString ¬ NIL;  dName: BcdDefs.NameRecord;  sourceFti: BcdDefs.FTIndex = FIRST[BcdDefs.FTIndex];  defsFti: BcdDefs.FTIndex = sourceFti + SIZE[BcdDefs.FTRecord];  fileTable: MACHINE DEPENDENT RECORD[    sourceFile(LOOPHOLE[sourceFti]): BcdDefs.FTRecord,    defsFile(LOOPHOLE[defsFti]): BcdDefs.FTRecord];  out: Stream.Handle ¬ NIL;  moduleIndex, segIndex: LONG CARDINAL ¬ 0;	-- for fixup    InitializePackedString: PROC = {    ssb ¬ LOOPHOLE[Spaces.String[60]];    ssb.string.length ¬ 1; ssb.size[1] ¬ 0};  AddName: PROC [n: LONG STRING] RETURNS [name: BcdDefs.NameRecord] = {    IF n = NIL      THEN name ¬ BcdDefs.NullName      ELSE {	String.AppendChar[@ssb.string, LOOPHOLE[n.length]];	name ¬ BcdDefs.NameRecord[ssb.string.length];	String.AppendString[@ssb.string, n]};    RETURN};  FillInModule: PROC [name: BcdDefs.NameRecord, segmentSize: CARDINAL] = {    OPEN BcdDefs;    module ¬ MTRecord[      name: name, namedInstance: FALSE, initial: FALSE,      file: FTSelf, linkLoc: frame, config: CTNull,      packed: FALSE, linkspace: FALSE,      code: [	sgi: FIRST[SGIndex], offset: 0, length: 2*segmentSize],      sseg: FIRST[SGIndex]+SIZE[SGRecord], framesize: 4,      tableCompiled: TRUE, spare: BcdDefsExtras.NewMesaModule,      residentFrame: FALSE, crossJumped: FALSE, packageable: TRUE,      links: FIRST[LFIndex],      boundsChecks: FALSE, nilChecks: FALSE,      entries: ENNull, atoms: ATNull];    codeSeg ¬ SGRecord[class: code, file: FTSelf, base: 2,      pages: Spaces.PagesForWords[segmentSize], extraPages: 0];    symbolSeg ¬ SGRecord[class: symbols, file: FTNull, base: 0,      pages: 0, extraPages: 0]};  FillInExport: PROC [name: BcdDefs.NameRecord, size, entry: CARDINAL] = {    export ¬ Spaces.Node[SIZE[BcdDefs.EXPRecord]+size*SIZE[BcdDefs.Link]];    export­ ¬ BcdDefs.EXPRecord[      name: name, size: size, port: interface,      namedInstance: FALSE, typeExported: FALSE,      file: FIRST[BcdDefs.FTIndex], links:];    FOR i: CARDINAL IN [0..size) DO export.links[i] ¬ BcdDefs.NullLink ENDLOOP;    export.links[entry] ¬ BcdDefs.Link[variable[gfi:1, offset:0]]};  FillInHeader: PROC = {    OPEN bcdHeader;    -- clear all fields    LOOPHOLE[bcdHeader, ARRAY [0..SIZE[BcdDefs.BCD]) OF CARDINAL] ¬ ALL[0];    versionIdent ¬ BcdDefs.VersionID;    version ¬ PGSConDefs.objectVersion;    fileTable.sourceFile.version ¬ PGSConDefs.sourceVersion;    sourceFile ¬ sourceFti;    unpackagedFile ¬ BcdDefs.FTNull;    creator ¬ PGSConDefs.pgsVersion;    nPages ¬ 1;    nConfigs ¬ 0;  nModules ¬ 1;    nImports ¬ 0;  nExports ¬ IF export = NIL THEN 0 ELSE 1;    definitions ¬ repackaged ¬ typeExported ¬ FALSE;  tableCompiled ¬ TRUE;    firstdummy ¬ 2;  nDummies ¬ 0;    ctOffset ¬ impOffset ¬ ntOffset ¬ SIZE[BcdDefs.BCD];    ssOffset ¬ SIZE[BcdDefs.BCD];    ssLimit ¬ SIZE[StringBody[ssb.string.length]];    mtOffset ¬ ssOffset + LOOPHOLE[ssLimit, CARDINAL];    mtLimit ¬ LOOPHOLE[SIZE[BcdDefs.MTRecord]];    sgOffset ¬ mtOffset + LOOPHOLE[mtLimit, CARDINAL];    sgLimit ¬ LOOPHOLE[2*SIZE[BcdDefs.SGRecord]];    lfOffset ¬ sgOffset + LOOPHOLE[sgLimit, CARDINAL];    lfLimit ¬ LOOPHOLE[SIZE[BcdDefs.LinkFrag[0]]];    ftOffset ¬ lfOffset + LOOPHOLE[lfLimit, CARDINAL];    ftLimit ¬ LOOPHOLE[SIZE[BcdDefs.FTRecord]];    IF export # NIL      THEN {	ftLimit ¬ ftLimit + LOOPHOLE[SIZE[BcdDefs.FTRecord]];	expOffset ¬ ftOffset + LOOPHOLE[ftLimit, CARDINAL];	expLimit ¬	  LOOPHOLE[SIZE[BcdDefs.EXPRecord]+export.size*SIZE[BcdDefs.Link]]}};  PutBlock: PROC [out: Stream.Handle, p: LONG POINTER, nWords: CARDINAL] = {    [] ¬ out.PutBlock[[p, 0, nWords*Environment.bytesPerWord]]};      WriteBcd: PROC [out: Stream.Handle] = {    linkFrag: ARRAY [0..SIZE[BcdDefs.LinkFrag[0]]) OF CARDINAL ¬ ALL[0];    PutBlock[out, @bcdHeader, SIZE[BcdDefs.BCD]];    PutBlock[out, ssb, SIZE[StringBody[ssb.string.length]]];    Spaces.FreeString[LOOPHOLE[ssb]];  ssb ¬ NIL;    moduleIndex ¬ Stream.GetPosition[out];    PutBlock[out, @module, SIZE[BcdDefs.MTRecord]];    segIndex ¬ Stream.GetPosition[out];    PutBlock[out, @codeSeg, SIZE[BcdDefs.SGRecord]];    PutBlock[out, @symbolSeg, SIZE[BcdDefs.SGRecord]];    PutBlock[out, @linkFrag, SIZE[BcdDefs.LinkFrag[0]]];    PutBlock[      out, @fileTable, (IF export # NIL THEN 2 ELSE 1) * SIZE[BcdDefs.FTRecord]];    IF export # NIL      THEN {	PutBlock[	  out, export, SIZE[BcdDefs.EXPRecord]+export.size*SIZE[BcdDefs.Link]];	Spaces.Free[export]}}; -- overall control  moduleId: LONG STRING ¬ [40];  WriteBcdHeader: PUBLIC PROC [      outStream: Stream.Handle,      tableId, binaryId: LONG STRING,	-- file being written      sourceId: LONG STRING,   -- input file      interfaceId, fileId: LONG STRING] = {    symbolSeg: MSegment.Handle;    out ¬ outStream;  moduleId.length ¬ 0;    IF tableId # NIL      THEN String.AppendString[moduleId, tableId]      ELSE	FOR i: CARDINAL IN [0 .. binaryId.length) DO	  IF binaryId[i] = '. THEN EXIT;	  String.AppendChar[moduleId, binaryId[i]];	  ENDLOOP;    InitializePackedString[];    fileTable.sourceFile.name ¬ AddName[sourceId];    dName ¬ AddName[interfaceId];    FillInModule[AddName[moduleId], 0];    -- fill in interface info    IF interfaceId = NIL      THEN export ¬ NIL      ELSE {	size, entry: CARDINAL;	[fileTable.defsFile.version, symbolSeg] ¬	  TableCommand.FindInterface[interfaceId, fileId	   ! TableCommand.BadInterface => {	      OPEN PGSConDefs;	      seterrstream[];  outeol[1]; 	      outstring[id]; outstring[" cannot be opened"L];	      GO TO fail}];	fileTable.defsFile.name ¬ IF fileId = NIL THEN dName ELSE AddName[fileId];	[size, entry] ¬ TableCommand.FindItem[symbolSeg, moduleId	   ! TableCommand.BadInterface => {	      OPEN PGSConDefs;	      seterrstream[];  outeol[1]; 	      outstring[moduleId]; outstring[" not found"L];	      GO TO fail}];	FillInExport[dName, size, entry];	EXITS	  fail => {	    OPEN PGSConDefs;	    outstring[" -- SELF used"L];	    outeol[2]; resetoutstream[]; warningsLogged ¬ TRUE;	    export ¬ NIL}};    FillInHeader[]; -- Do this after all strings entered    -- Make file time be same as bcd version time.    MFile.SetTimes[      file: MStream.GetFile[outStream], create: [PGSConDefs.objectVersion.time]];    WriteBcd[out];    Stream.SetPosition[out, Environment.bytesPerPage]};  FixupBcdHeader: PUBLIC PROC = {    BytesPerWord: CARDINAL = Environment.bytesPerWord;    BytesPerPage: CARDINAL = Environment.bytesPerPage;    endIndex: LONG CARDINAL ¬ Stream.GetPosition[out];    nBytes: CARDINAL = Inline.LowHalf[endIndex] - BytesPerPage;    module.code.length ¬ nBytes;    codeSeg.pages ¬ Spaces.PagesForWords[(nBytes + (BytesPerWord-1))/BytesPerWord];    IF bcdHeader.nExports = 0      THEN {	startIndex: LONG CARDINAL;	symbolBytes: CARDINAL;	UNTIL (startIndex ¬ Stream.GetPosition[out]) MOD BytesPerPage = 0 DO	  Stream.PutByte[out, 0] ENDLOOP;	symbolSeg ¬ [            class: symbols, file: BcdDefs.FTSelf,            base: codeSeg.base+codeSeg.pages, pages: , extraPages: 0];	PGSConDefs.WriteSymbols[out, moduleId];	endIndex ¬ Stream.GetPosition[out];	symbolBytes ¬ Inline.LowHalf[endIndex-startIndex];	symbolSeg.pages ¬	  Spaces.PagesForWords[(symbolBytes + (BytesPerWord-1))/BytesPerWord]};    Stream.SetPosition[out, moduleIndex];    PutBlock[out, @module, SIZE[BcdDefs.MTRecord]];    Stream.SetPosition[out, segIndex];    PutBlock[out, @codeSeg, SIZE[BcdDefs.SGRecord]];    PutBlock[out, @symbolSeg, SIZE[BcdDefs.SGRecord]];    Stream.SetPosition[out, endIndex]};  }.
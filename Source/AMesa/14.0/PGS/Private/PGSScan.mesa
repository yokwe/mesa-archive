-- file PGSScan.mesa rewritten by PGS, 19-Jan-87  9:12-- file PGSScan.mesa rewritten by PGS,  5-Jan-87 23:32-- file PGSScan.mesa rewritten by PGS,  6-Oct-84 18:24-- file PGSScan.mesa rewritten by PGS,  6-Oct-84 17:54-- file PGSScan.mesa rewritten by PGS,  5-Oct-84 15:39-- file PGSScan.mesa rewritten by PGS, 24-Sep-84 16:27-- Copyright (C) 1980, 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- file PGSScan.mesa rewritten by PGS, 23-Sep-84 15:53-- file PGSScan.mesa rewritten by PGS, 13-Sep-83 11:46-- file PGSScan.mesa rewritten by PGS, 25-Aug-83 16:01-- syntax last modified by EXS          ,  7-Jan-80 11:31 -- code   last modified by EXS          , March 16, 1981  3:49 PM-- code   last modified by JGS,  4-Nov-82 14:09:03-- code   last modified by RES  , 25-Aug-83 16:55:49DIRECTORY  PGS1: TYPE USING [Value, ValueStack, ErrorContext, InputLoc, LocateIndex, Token],  ParseTable: FROM "PGSParseTable" USING [    ActionEntry, EndMarker, HashIndex, HashTableRef, IndexTableRef, ProdDataRef,    ScanTableRef, TableRef, TSymbol, VocabularyRef,    tokenID, tokenNUM, tokenTAB3, tokenTAB4],  PGSConDefs: TYPE USING [    ControlZ, CR,    alternatelim, maxprod, maxrhssymbols, maxrule, outbuflim, psslim, rhslim,    symtabsize, TextChars, tokensize, wordsfortoken,    aliases, eofile, flags, nextAlias, numprod, numrules, prodinfo, rhschar,    syminfo, symtab, tokeninfo, totalTokens, warningsLogged,    AllocateHeapNode, expand, FreeHeapNode, makearray,    nextbuffer, outchar, outeol, outnum, outstring,    resetoutstream, setoutstream, seterrstream],  PGSTypes: TYPE USING [AliasEntry, Options, ProdEntry, SymTabEntry, TokenEntry];Scanner: PROGRAM    IMPORTS PGS1, PGSConDefs     EXPORTS PGS1, PGSConDefs = {  OPEN  PGS1, ParseTable, PGSConDefs;  hashTab: HashTableRef ¬ NIL;  scanTab: ScanTableRef ¬ NIL;  vocab: VocabularyRef ¬ NIL;  vocabIndex: IndexTableRef ¬ NIL;  check: CARDINAL = 3;  warning: CARDINAL = 0;  specErrorCases: CARDINAL = 5;  token, numRhsChars: CARDINAL ¬ 0;  lineWidth: INTEGER ¬ 0;  insertFlag: CARDINAL ¬ 0;  hashChain: LONG POINTER TO ARRAY [1..symtabsize/4] OF CARDINAL ¬ NIL; -- local data base (supplied by parser)  v: PGS1.ValueStack;  l: LONG DESCRIPTOR FOR ARRAY OF CARDINAL ¬ DESCRIPTOR[NIL, 0];  q: LONG DESCRIPTOR FOR ARRAY OF ActionEntry ¬ DESCRIPTOR[NIL, 0];  prodData: ProdDataRef ¬ NIL; -- initialization/termination  AssignDescriptors: PUBLIC PROC [	qd: LONG DESCRIPTOR FOR ARRAY OF ActionEntry,	vd: PGS1.ValueStack,	ld: LONG DESCRIPTOR FOR ARRAY OF CARDINAL,	pp: ProdDataRef] =    {q ¬ qd;  v ¬ vd;  l ¬ ld;  prodData ¬ pp};  OutToken: PUBLIC PROC [symbol: CARDINAL] RETURNS [CARDINAL] = {    IF symbol = 0 THEN {outstring["* * *"L]; RETURN[5]};    FOR i: CARDINAL IN [0..syminfo[symbol].length) DO      outchar[symtab[symbol*tokensize+i],1] ENDLOOP;    RETURN [syminfo[symbol].length]}; -- the interpretation rules  prix, chix: CARDINAL ¬ 0; --indexes into prodinfo and rhschar  rhsFlag: BOOLEAN ¬ FALSE;   lastSymbol, lhsDef: CARDINAL ¬ 0;  ProcessQueue: PUBLIC PROC [qI, top: CARDINAL] = {    i, j, k: CARDINAL ¬ 0;   -- local procedures    PrintTableHead: PROC [c: CHARACTER] = {      IF flags[echo] THEN {outeol[2]; outstring["||TABLE"L]; outchar[c,1]; outeol[1]}};    SetRuleChain: PROC [rule: CARDINAL, chain: BOOLEAN] = {      FixLastProd[];      IF prix=LENGTH[prodinfo] THEN --production table overflow	prodinfo ¬ LOOPHOLE[	  expand[prodinfo,SIZE[PGSTypes.ProdEntry],LENGTH[prodinfo]/8]];      prodinfo[prix].chain ¬ chain;      numrules ¬ MAX[numrules, rule];      IF rule>maxrule THEN Error[check+10,-5,InputLoc[]] ELSE prodinfo[prix].rule ¬ rule};    FixLastProd: PROC = {      prodinfo[prix-1].lhs ¬ lhsDef;      IF prodinfo[prix-1].count=0 THEN tokeninfo[lhsDef-eofile].empty ¬ TRUE;      IF rhsFlag THEN {  -- too many rhschars	rhsFlag ¬ FALSE; Error[check+5, (prix-1+specErrorCases), InputLoc[]]}};    ProdHeader: PROC [new: BOOLEAN] = {      prodinfo[prix].index ¬ chix;      IF lhsDef>eofile THEN {	IF tokeninfo[lhsDef-eofile].count=alternatelim THEN {	  Error[check+1, lhsDef,InputLoc[]];  --too many alternatives	tokeninfo[lhsDef-eofile].count ¬1};	tokeninfo[lhsDef-eofile].count ¬ tokeninfo[lhsDef-eofile].count + 1};      IF flags[echo] THEN {	lineWidth ¬ outbuflim-tokensize-14;         outeol[IF new THEN 2 ELSE 1];outnum[prix,3];	outstring[IF prodinfo[prix].chain THEN " C "L ELSE "   "L];	outnum[prodinfo[prix].rule,3]; outchar[' ,2];	outchar[' ,tokensize-(IF new THEN OutToken[lhsDef] ELSE 0)];	outstring[IF new THEN " ::= "L ELSE "   | "L]};      prix ¬ prix+1};    LhsSymbol: PROC [symbol: CARDINAL] = {      lhsDef ¬ symbol;      IF lhsDef<=eofile THEN Error[check+4,lhsDef,InputLoc[]]	-- undefined or terminal symbol before ::=      ELSE      IF tokeninfo[lhsDef-eofile].index = 0 THEN tokeninfo[lhsDef-eofile].index ¬ prix      ELSE Error[check+2,lhsDef,InputLoc[]]; --multiple definitions      ProdHeader[TRUE]};   -- end of local procedures    FOR qj: CARDINAL IN [0..qI) DO      top ¬ top-q[qj].tag.pLength+1;      SELECT prodData[q[qj].transition].rule FROM       0  => -- TABLE: PGSParseData  TYPE: ParseTable  EXPORTS: SELF	     -- GOAL: grammar	     -- TERMINALS:	     --   symbol num '? '| "::=" 'C "||TABLE1" "||TABLE2" "||TABLE3"	     --   "||TABLE4" "||INPUT" "||CHAIN" "||LISTS" "||PRINTLR"	     --   "||PRINTLALR" "||FIRST" "||IDS" "GOAL"	     -- ALIASES: symbol tokenID  num tokenNUM  '? tokenQUERY	     --   "||TABLE3" tokenTAB3  "||TABLE4" tokenTAB4  '? InitialSymbol	     -- PRODUCTIONS:	     -- grammar        ::= '? head ruleset	  BEGIN FixLastProd[]; numprod ¬ prix-1; numRhsChars ¬ chix-1; i ¬ 1;	  IF flags[echo] THEN outeol[1];	  IF numprod > psslim OR totalTokens > psslim THEN Error[check+6,0,InputLoc[]];	  FreeHeapNode[hashChain];	  WHILE syminfo[i].used AND i<=totalTokens DO	    IF i>eofile AND tokeninfo[i-eofile].index = 0 THEN EXIT; i ¬ i+1;	    ENDLOOP;	  IF i <= totalTokens THEN {	    defflag: BOOLEAN ¬ FALSE;	    lineWidth ¬ 0; Error[warning+3,0,InputLoc[]]; seterrstream[];	    FOR i IN [i..totalTokens] DO	      j ¬ 0; IF ~syminfo[i].used THEN j ¬ j+1;	      IF i > eofile AND tokeninfo[i-eofile].index = 0 THEN j ¬ j+2;	      IF j # 0 THEN {		IF (lineWidth ¬ lineWidth+(k¬(11+j)/2)) > outbuflim THEN {		  outeol[1]; lineWidth ¬ k};		outnum[i,5];		IF j#2 THEN outchar['U,1] ELSE defflag ¬ TRUE;		IF j>1 THEN outchar['D,1]};	      ENDLOOP;	    outeol[1]; resetoutstream[];	    IF defflag THEN	      Error[check+3,-2,InputLoc[]]}; -- nonterminal used but not defined	  FOR i IN [1..numprod] DO	    IF prodinfo[i].chain THEN	      IF prodinfo[i].count # 1 OR rhschar[prodinfo[i].index] <= eofile THEN {		Error[warning+2, -(i+specErrorCases), InputLoc[]];		prodinfo[i].chain ¬ FALSE};	    ENDLOOP;	  END;       1  => -- head           ::= directives terminals nonterminals "||TABLE4"	     -- head           ::= directives terminals nonterminals aliases "||TABLE4"	  BEGIN totalTokens ¬ lastSymbol; PrintTableHead['4];	  tokeninfo ¬ LOOPHOLE[	    makearray[totalTokens-eofile+1,SIZE[PGSTypes.TokenEntry]]];	  numrules ¬ 0;	  prodinfo ¬ LOOPHOLE[makearray[maxprod+1,SIZE[PGSTypes.ProdEntry]]];	  rhschar ¬ LOOPHOLE[makearray[maxrhssymbols+1,SIZE[CARDINAL]]];	  FOR i IN [0..totalTokens-eofile] DO	    tokeninfo[i] ¬ [count:0, empty:FALSE, index:0] ENDLOOP;	  prodinfo[0] ¬ [count:2, rule:0, chain:FALSE, lhs:0, index:0];	  FOR i IN [1..maxprod] DO	    prodinfo[i] ¬ [count:0, rule:0, chain:FALSE, lhs:0, index:0] ENDLOOP;	  IF flags[echo] THEN {	    outeol[1]; outchar[' ,20]; outstring["GOAL ::= "L];	    [] ¬ OutToken[eofile+1]; outchar[' ,1]; [] ¬ OutToken[eofile]};	  rhschar[0] ¬ eofile+1; rhschar[1] ¬ eofile;	  syminfo[eofile+1].used ¬ syminfo[eofile].used ¬ TRUE;	  prix ¬ 1; chix ¬ 2; lhsDef ¬ 0; rhsFlag ¬ FALSE;	  END;       2  => -- directives     ::=	  {flags ¬ ALL[FALSE];  l[top] ¬ InputLoc[]};       3  => -- directive      ::= "||INPUT"	  {flags[echo] ¬ TRUE; setoutstream[".echo"L]};       4  => -- directive      ::= "||CHAIN"	  flags[chain] ¬ TRUE;       5  => -- directive      ::= "||LISTS"	  flags[lists] ¬ TRUE;       6  => -- directive      ::= "||PRINTLR" 	  flags[printlr] ¬ TRUE;       7  => -- directive      ::= "||PRINTLALR"	  flags[printlalr] ¬ TRUE;       8  => -- directive      ::= "||FIRST"	  flags[first] ¬ TRUE;       9  => -- directive      ::= "||IDS"	  flags[ids] ¬ TRUE;      10  => -- terminals      ::= "||TABLE1"	  BEGIN	  IF flags[echo] THEN {	    outeol[1];	    FOR opt: PGSTypes.Options IN PGSTypes.Options DO	      IF flags[opt] THEN outstring[	        SELECT opt FROM	          echo => "||INPUT "L,	          chain => "||CHAIN "L,	          lists => "||LISTS "L,	          printlr => "||PRINTLR "L,	          printlalr => "||PRINTLALR "L,	          first => "||FIRST "L,	          ENDCASE => "||IDS "L];	      ENDLOOP};	  PrintTableHead['1];	  END;      11  => -- terminals      ::= terminals discard symbol	     -- nonterminals   ::= nonterminals discard symbol 	  BEGIN lastSymbol ¬ v[top+2];	  IF flags[echo] THEN {	    outnum[lastSymbol, 3]; outchar[' , 2];	    [] ¬ OutToken[lastSymbol];	    outeol[1]};	  END;      12  => -- nonterminals   ::= "||TABLE2"	  BEGIN PrintTableHead['2]; eofile ¬ lastSymbol;	  nextAlias ¬ 0; -- assert TABLE3 empty in case it is omitted	  END;      13  => -- aliases        ::= "||TABLE3"	  BEGIN PrintTableHead['3];	  aliases ¬ LOOPHOLE[makearray[64,SIZE[PGSTypes.AliasEntry]]];	  END;      14  => -- aliases        ::= aliases symbol symbol	  BEGIN IF v[top+1]>eofile THEN Error[check+7,v[top+1],InputLoc[]];	  IF v[top+2]<=eofile THEN Error[check+8,v[top+2],InputLoc[]];	  IF nextAlias=LENGTH[aliases] THEN	   aliases ¬ LOOPHOLE[expand[aliases,SIZE[PGSTypes.AliasEntry],LENGTH[aliases]/8]];	  aliases[nextAlias] ¬ [v[top+1],v[top+2]]; nextAlias ¬ nextAlias+1;	  IF flags[echo] THEN {	    outchar[' ,tokensize+1-OutToken[v[top+1]]]; outchar[' ,1];	    j ¬ v[top+2]*tokensize;	    FOR i IN [j..j+tokensize) WHILE symtab[i]#0C DO outchar[symtab[i],1] ENDLOOP;	    outeol[1]};	  END;      15  => -- discard        ::=	  l[top] ¬ InputLoc[]; -- keep the parser error recovery happy      16  => -- rulegroup      ::= symbol "::="	  {SetRuleChain[prix, FALSE]; LhsSymbol[v[top]]};      17  => -- rulegroup      ::= prefix symbol "::="	  LhsSymbol[v[top+1]];      18  => -- rulegroup      ::= rulegroup symbol "::="	  {SetRuleChain[prix, FALSE]; LhsSymbol[v[top+1]]};      19  => -- rulegroup      ::= rulegroup prefix symbol "::="	  LhsSymbol[v[top+2]];      20  => -- rulegroup      ::= rulegroup '|	  {SetRuleChain[prix, FALSE]; ProdHeader[FALSE]};      21  => -- rulegroup      ::= rulegroup prefix '|	  ProdHeader[FALSE];      22  => -- rulegroup      ::= rulegroup symbol	  BEGIN i ¬ v[top+1]; syminfo[i].used ¬ TRUE;	  IF i=eofile OR i=eofile+1 THEN Error[check+9,0,InputLoc[]]; --goal symbols	  IF flags[echo] THEN {	    IF lineWidth<syminfo[i].length THEN {	      outeol[1]; outchar[' ,tokensize+18]; lineWidth ¬ outbuflim - tokensize-18};	    IF (lineWidth ¬ (lineWidth-OutToken[i]-1)) > 0 THEN outchar[' , 1]};	  IF chix=LENGTH[rhschar] THEN	    rhschar ¬ LOOPHOLE[expand[rhschar,SIZE[CARDINAL],LENGTH[rhschar]/8]];	  rhschar[chix]¬i; chix ¬ chix +1;	  IF prodinfo[prix-1].count = rhslim THEN {	    prodinfo[prix-1].count ¬ 1; rhsFlag ¬ TRUE};	  prodinfo[prix-1].count ¬ prodinfo[prix-1].count+1;	  END;      23  => -- prefix         ::= num	  SetRuleChain[v[top], FALSE];      24  => -- prefix         ::= num num              -- prefix         ::= '? num	  SetRuleChain[v[top+1], FALSE];      25  => -- prefix         ::= discard 'C	  SetRuleChain[prix, TRUE];      26  => -- prefix         ::= discard 'C num	  SetRuleChain[v[top+2], TRUE];      27  => -- prefix         ::= '?	  SetRuleChain[prix, FALSE];      28  => -- directives     ::= directives directive	     -- discard        ::= num	     -- discard        ::= '?	     -- ruleset        ::=C rulegroup	     -- ruleset        ::= goalrule rulegroup	     -- goalrule       ::= "GOAL" "::=" symbol symbol	  NULL;	ENDCASE => ERROR;       ENDLOOP}; -- the following procedure is called from the ScanReset if no errors  FinishInput: PROC = {    emptyflag: BOOLEAN ¬ TRUE;    j, k: CARDINAL ¬ 0;    -- compute nonterminals deriving empty    WHILE emptyflag DO      emptyflag ¬ FALSE;      FOR i: CARDINAL IN [1..totalTokens-eofile] DO  -- each nonterminal        IF tokeninfo[i].empty THEN LOOP;  --which does not derive empty        j ¬ tokeninfo[i].index;        FOR prix: CARDINAL IN [j..j+tokeninfo[i].count) DO            -- each production of the nonterminal	  k ¬ prodinfo[prix].index;	  FOR chix: CARDINAL IN [k..k+prodinfo[prix].count) DO   -- each rhs character	    IF rhschar[chix]<=eofile OR ~tokeninfo[rhschar[chix]-eofile].empty THEN EXIT;	    REPEAT FINISHED => {tokeninfo[i].empty ¬ emptyflag ¬ TRUE; EXIT};	    ENDLOOP	  ENDLOOP        ENDLOOP      ENDLOOP;    CheckOut[]};    -- the following procedure outputs the data structure contents in the tables:    --          PRODUCTIONINFO            TOKENINFO             SYMINFO    -- num count rule chain lhs index   count empty index   link used length   symbol    --  4 1  3    5    1    4    5   2   3     1     5   2   4   1     3    1  ...  CheckOut: PUBLIC PROC = {    IF flags[ids] THEN {      seterrstream[]; outeol[1];      outstring["       PRODUCTIONINFO     TOKENINFO    SYMINFO"L];      FOR i: CARDINAL IN [0..MAX[numprod,totalTokens]] DO	outeol[1]; outnum[i,4]; outchar[' ,1];	IF i>numprod THEN outchar[' ,20]	ELSE {	  outnum[prodinfo[i].count,3]; outnum[prodinfo[i].rule,5];	  outchar[IF prodinfo[i].chain THEN 'C ELSE ' , 1];	  outnum[prodinfo[i].lhs,4]; outnum[prodinfo[i].index,5]; outchar[' ,2]};	IF i IN (0..totalTokens] THEN {	  IF i<=eofile THEN outchar[' ,11] ELSE {	    outnum[tokeninfo[i-eofile].count,3];	    outchar[IF tokeninfo[i-eofile].empty THEN 'E ELSE ' ,1];	    outnum[tokeninfo[i-eofile].index,5]; outchar[' ,2]};	  outnum[syminfo[i].link,4]; outchar[IF syminfo[i].used THEN 'U ELSE ' ,1];	  outnum[syminfo[i].length,3]; outchar[' ,1]; [] ¬ OutToken[i]}        ENDLOOP;      outeol[1]; outstring["RHSCHAR"L]; lineWidth ¬ outbuflim;      FOR i: CARDINAL IN [0..numRhsChars] DO        lineWidth ¬ lineWidth+tokensize+1;        IF lineWidth > outbuflim THEN {outeol[1]; outnum[i,4]; lineWidth ¬ 4};        outchar[' ,1]; [] ¬ OutToken[rhschar[i]];        ENDLOOP;      outeol[1]; resetoutstream[]}}; -- error recovery  TokenValue: PUBLIC PROC [s: TSymbol] RETURNS [PGS1.Value] = {RETURN [0]};-- text input and error routines  NUL: CHARACTER = 0C;  tB: LONG POINTER TO PACKED ARRAY OF CHARACTER ¬ NIL;  tI, tMax: [0..TextChars] ¬ 0;  tOrigin, tLimit: CARDINAL ¬ 0;  tEnded: BOOLEAN ¬ FALSE;  FillTextBuffer: PROC = {    tOrigin ¬ tLimit;    IF tEnded THEN  tMax ¬ 0    ELSE {[tB, tMax, tEnded] ¬ nextbuffer[]; tLimit ¬ tOrigin + tMax};    IF tMax = 0 THEN {tB[0] ¬ NUL;  tMax ¬ 1};    tI ¬ 0};  buffer: LONG STRING = [tokensize];		-- token assembly area  nTokens: CARDINAL ¬ 0;			-- token count  nErrors: CARDINAL ¬ 0;			-- lexical errors  char: CHARACTER;	-- current (most recently scanned) character  NextChar: PROC = {	-- also expanded inline within Atom    IF (tI¬tI+1) = tMax THEN FillTextBuffer[];    char ¬ tB[tI]};  Atom: PUBLIC PROC RETURNS [t: Token] = {    OPEN t;    LocateToken: PROC [string: LONG STRING] RETURNS [CARDINAL] = {      -- returns token corresponding to string      i, j: CARDINAL;      j ¬ hashChain[(string.length*256+(string[0]-0c)) MOD (symtabsize/4) + 1];      WHILE j # 0 DO        IF syminfo[j].length = string.length THEN {	 i ¬ j*tokensize;	 FOR k: CARDINAL IN [0..string.length) DO	   IF symtab[i+k]#string[k] THEN EXIT	   REPEAT FINISHED => RETURN [j]	   ENDLOOP};        j ¬ syminfo[j].link;        ENDLOOP;      RETURN [0]};    TokenToSymTab: PROC [string: LONG STRING, token: CARDINAL] = {      i, j: CARDINAL ¬ 0;      i ¬ token*tokensize;      FOR j IN [0..string.length) DO symtab[i+j] ¬ string[j] ENDLOOP;      syminfo[token].length ¬ string.length; syminfo[token].used ¬ FALSE;      j ¬ (string.length*256+(string[0]-0c)) MOD (symtabsize/4) + 1;      syminfo[token].link ¬ hashChain[j]; hashChain[j] ¬ token};    TokenOrId: PROC [sub: CARDINAL] = {      j, s1, s2: CARDINAL ¬ 0;      h: HashIndex ¬ 0;      WHILE char ~IN [NUL..' ] DO        IF sub<tokensize THEN buffer[sub] ¬ char;        sub ¬ sub + 1; NextChar[];        ENDLOOP;      IF sub>tokensize THEN {        buffer.length ¬ sub ¬ tokensize; Error[1,-1,index]}; --overlength      IF sub = 1 THEN {	class ¬ scanTab[buffer[0]];        IF class # 0 THEN RETURN};      j ¬ buffer[0] - 0C;      h ¬ ((j*128-j) + CARDINAL[buffer[sub-1]-0C]) MOD LAST[HashIndex] + 1;      WHILE (j ¬ hashTab[h].symbol) # 0 DO         IF vocabIndex[j]-(s2¬vocabIndex[j-1]) = sub THEN          FOR s1 IN [0 .. sub) DO 	   IF buffer[s1] # vocab.text[s2] THEN EXIT;	   s2 ¬ s2+1;	   REPEAT FINISHED => {	     IF j = tokenTAB3 THEN insertFlag ¬ 2 ELSE	       IF j = tokenTAB4 THEN insertFlag ¬ 3;	     IF j<=tokenNUM THEN EXIT;	     class ¬ j; RETURN};	   ENDLOOP;        IF (h ¬ hashTab[h].link) = 0 THEN EXIT;        ENDLOOP;      buffer.length ¬ sub; class ¬ tokenID; value ¬ LocateToken[buffer];      SELECT insertFlag FROM        1 =>	-- reading terminals and nonterminals	  IF value # 0 THEN Error[check+2,value,index]  -- multiply defined symbol	  ELSE {	    IF token=LENGTH[symtab] THEN {	      symtab ¬ LOOPHOLE[expand[LOOPHOLE[symtab],wordsfortoken,			    LENGTH[symtab]/16]];	      syminfo ¬ LOOPHOLE[expand[syminfo,SIZE[PGSTypes.SymTabEntry],			    LENGTH[syminfo]/16]]};	    TokenToSymTab[buffer, token]; value ¬ token; token ¬ token+1};        2 =>	-- processing aliases	IF value=0 THEN {	  s1 ¬ token*tokensize;	  IF token=LENGTH[symtab] THEN	    symtab ¬ LOOPHOLE[expand[LOOPHOLE[symtab],wordsfortoken,			    LENGTH[symtab]/16]];	  FOR j IN [0..buffer.length) DO symtab[s1+j] ¬ buffer[j] ENDLOOP;	  value ¬ token; token ¬ token+1};        3 =>	-- processing productions          IF value = 0 THEN Error[check+3,-3,index];  --symbol not defined        ENDCASE};    DO      WHILE char IN [NUL..' ] DO 	SELECT char FROM	  ControlZ =>	    UNTIL char = CR DO	      IF (tI¬tI+1) = tMax THEN {IF tEnded THEN GO TO EndFile; FillTextBuffer[]};	    char ¬ tB[tI];	    ENDLOOP;	  ENDCASE;	IF (tI¬tI+1) = tMax THEN {IF tEnded THEN GO TO EndFile; FillTextBuffer[]};	char ¬ tB[tI];	ENDLOOP;      index ¬ tOrigin + tI;  value ¬ 0;      SELECT char FROM	IN ['0..'9] => {	  val: CARDINAL; valid: BOOLEAN;	  maxval: CARDINAL = 6553; maxd: CARDINAL = 5;	  valid ¬ TRUE; val ¬ 0;	  WHILE char IN ['0..'9] DO	    IF valid THEN {	      d:[0..9] ¬ char-'0;	      val ¬ 10*val+d;	      valid ¬ val<maxval OR (val=maxval AND d<=maxd)};	    NextChar[];	    ENDLOOP;	  IF ~valid THEN val ¬ maxval*10+maxd;	  class ¬ tokenNUM; value ¬ val; GO TO GotNext};	'- => {	  pChar: CHARACTER;	  NextChar[];	  IF char # '- THEN {buffer[0] ¬ '-; TokenOrId[1]; GO TO GotNext};	  char ¬ NUL;	  DO	    pChar ¬ char;	    IF (tI¬tI+1) = tMax THEN {IF tEnded THEN GO TO EndFile; FillTextBuffer[]};	    char ¬ tB[tI];	    SELECT char FROM	      '- =>  IF pChar = '- THEN EXIT;	      CR =>  EXIT;	      ENDCASE;	    ENDLOOP;	  NextChar[]};	ENDCASE => {TokenOrId[0]; GO TO GotNext};      REPEAT      GotNext =>  NULL;      EndFile => {        FillTextBuffer[];  char ¬ tB[tI];        class ¬ EndMarker;  index ¬ tOrigin;  value ¬ 0};      ENDLOOP;    nTokens ¬ nTokens + 1;    RETURN}; -- initialization/finalization  ScanInit: PUBLIC PROC [tablePtr: ParseTable.TableRef] = {    i: CARDINAL ¬ 0;    hashTab ¬ @tablePtr[tablePtr.scanTable.hashTab];    scanTab ¬ @tablePtr[tablePtr.scanTable.scanTab];    vocab ¬ LOOPHOLE[@tablePtr[tablePtr.scanTable.vocabBody]];    vocabIndex ¬ @tablePtr[tablePtr.scanTable.vocabIndex];    tLimit ¬ 0;  tMax ¬ 0;  tEnded ¬ FALSE;    FillTextBuffer[];  char ¬ tB[tI];    nTokens ¬ nErrors ¬ 0; buffer.length ¬ tokensize;    -- initialise symbol table    token ¬ 1; insertFlag ¬ 1;    symtab ¬ LOOPHOLE[makearray[symtabsize+1,wordsfortoken]];    syminfo ¬ LOOPHOLE[makearray[symtabsize+1,SIZE[PGSTypes.SymTabEntry]]];    FOR i IN [1..symtabsize] DO syminfo[i] ¬ [link:0, length:0, used:FALSE] ENDLOOP;    hashChain ¬ AllocateHeapNode[symtabsize/4*SIZE[CARDINAL]];    hashChain­ ¬ ALL[0]};  ScanReset: PUBLIC PROC [pErrors: CARDINAL] RETURNS [CARDINAL, CARDINAL] = {    IF (pErrors+nErrors)=0 THEN FinishInput[]; RETURN [nTokens, nErrors]}; -- error handling  ResetScanIndex: PUBLIC PROC [index: CARDINAL] = {    IF index = tLimit THEN {FillTextBuffer[]; char ¬ tB[tI]; RETURN};    IF index < tOrigin THEN {      tLimit ¬ LocateIndex[index]; tMax ¬ 0;  tEnded ¬ FALSE;      FillTextBuffer[]};    tI ¬ index - tOrigin; char ¬ tB[tI]};  Error: PROC [code: CARDINAL, control: INTEGER, index: CARDINAL] = {    ErrorContext[ SELECT code FROM      1  => "WARNING - Overlength symbol (increase TOKENSIZE?) truncated to - "L,      2  => "WARNING - Not a chain production - "L,      3  => "WARNING - Unused(U) or undefined(D)symbols (refer to TABLE1 and 2)"L,      4  => "ERROR - Nonterminal with too many rules (increase ALTERNATELIM?) - "L,      5  => "ERROR - Multiple definitions of symbol - "L,      6  => "ERROR - Symbol not defined - "L,      7  => "ERROR - Terminal precedes ::= - "L,      8  => "ERROR - Too many rhs symbols in production (increase RHSLIM?) - "L,      9  => "ERROR - Internal field will overflow - increase PSSLIM"L,      10 => "ERROR - Aliased symbol not a terminal symbol - "L,      11 => "ERROR - Aliases must not be terminal symbols - "L,      12 => "ERROR - Goal symbols used in rhs"L,      13 => "ERROR - Number greater than "L,      ENDCASE => NIL,      index];    IF code>check THEN nErrors ¬ nErrors+1;    SELECT -control FROM      <0 => [] ¬ OutToken[control];       0 => NULL;       1 => outstring[buffer];       2 => outstring["see previous message"L];       3 => {outstring[buffer]; outstring[" not in TABLE1 or 2"L]};       4 => NULL;  -- not used       5 => outstring["MAXRULE"L];       ENDCASE => outnum[-control-specErrorCases, 5];    outeol[2];    IF code<=check THEN warningsLogged ¬ TRUE;    resetoutstream[]};  }.
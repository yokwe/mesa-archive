-- Copyright (C) 1982, 1984  by Xerox Corporation. All rights reserved. -- file PGSFormat.mesa-- last modified by Satterthwaite, March 17, 1981  10:07 AM-- last modified by JGS,  4-Nov-82 12:26:03DIRECTORY  PGSConDefs: TYPE USING [    ControlZ, CR, query, TAB,    cpw, maxprod, maxrhssymbols, symtabsize, TextChars, tokensize,    sourceName,    AllocateSegment, expand, FreeSegment, makearray,    nextbuffer, outchar, outeol, outnum, outstring, outtime, PGSfail],  PGSTypes: TYPE USING [    HashHeads, HashHeadsRef, RhsChar, PInfo, PInfoRec, SymTab, SInfo, SInfoRec];PGSFormat: PROGRAM    IMPORTS PGSConDefs    EXPORTS PGSConDefs = {  OPEN PGSConDefs;  leftIndex, symIndex, nextProd, sinfIndex, nextRhsChar, topSymbol: CARDINAL;  rule, nextRule, aliasIndex, lastTerminal: CARDINAL;  symString, aliasText: PGSTypes.SymTab;  sinfo: PGSTypes.SInfo;  pinfo: PGSTypes.PInfo;  rhsText: PGSTypes.RhsChar;  KeyWord: TYPE = {table, type, export, goal, terminals, aliases, productions};  text: LONG STRING ¬ "TABLETYPEEXPORTSGOALTERMINALSALIASESPRODUCTIONS";  textKeys: ARRAY KeyWord OF RECORD [index, len: CARDINAL] =    [[0,5], [5,4], [9,7], [16,4], [20,9], [29,7], [36,11]];  Error: PROC = {    FreeSegment[hashChain]; FreeSegment[BASE[rhsText]];    FreeSegment[BASE[sinfo]]; FreeSegment[BASE[pinfo]];    FreeSegment[BASE[symString]]; FreeSegment[BASE[aliasText]];    ERROR PGSfail[]};  Directive: PROC [key: KeyWord] RETURNS [BOOLEAN] = {    IF symIndex-leftIndex-1 # textKeys[key].len OR symString[symIndex-1] # ':      THEN RETURN [FALSE];    FOR i: CARDINAL IN [0..textKeys[key].len) DO      IF symString[leftIndex+i] # text[textKeys[key].index+i] THEN RETURN [FALSE]      ENDLOOP;    RETURN [TRUE]};  ExtractKeyItem: PROC [key: KeyWord, value: LONG STRING] RETURNS [BOOLEAN] = {    i,j: CARDINAL ¬ 0;    IF ~Directive[key] THEN RETURN [FALSE] ELSE {      GetText[]; j ¬ 0;      FOR i IN [leftIndex..symIndex) DO value[j] ¬ symString[i]; j ¬ j+1 ENDLOOP};    value.length ¬ j; RETURN [TRUE]};  hashChain: PGSTypes.HashHeadsRef ¬ NIL;  FindText: PROC RETURNS [CARDINAL] = {    h, i, j, k: CARDINAL ¬ 0;    h ¬ (256*(symIndex-leftIndex)+(symString[leftIndex]-0C)) MOD LENGTH[hashChain­];    j ¬ hashChain[h];    WHILE j#0 DO      IF symIndex-leftIndex = sinfo[j+1].symptr-sinfo[j].symptr THEN { -- same length        i ¬ sinfo[j].symptr;        FOR k IN [leftIndex..symIndex) DO          IF symString[k]#symString[i] THEN EXIT;          i ¬ i+1;          REPEAT	    FINISHED => {symIndex ¬ leftIndex; RETURN [j]};          ENDLOOP};      j ¬ sinfo[j].link;      ENDLOOP;    -- new symbol    sinfo[sinfIndex] ¬ [leftIndex,hashChain[h],0];     hashChain[h] ¬ sinfIndex; sinfIndex ¬ sinfIndex+1;    sinfo[sinfIndex].symptr ¬ symIndex;     IF sinfIndex=LENGTH[sinfo] THEN      sinfo ¬ LOOPHOLE[expand[sinfo,SIZE[PGSTypes.SInfoRec],LENGTH[sinfo]/8]];    RETURN [sinfIndex-1]};  Formatter: PROC [tableId, typeId, exportId: LONG STRING] = {    chain: BOOLEAN ¬ FALSE;    outstring["-- file "L];  outstring[sourceName];    outstring[" rewritten by PGS, "L];  outtime[];  outeol[1];    ScanInit[];     DO      GetText[];      SELECT TRUE FROM	ExtractKeyItem[table, tableId] => NULL;	ExtractKeyItem[type, typeId] => NULL;	ExtractKeyItem[export, exportId] => NULL;	ENDCASE => EXIT;      ENDLOOP;    IF ~Directive[goal] THEN Error[] ELSE {      symIndex ¬ 0; GetText[]; sinfIndex ¬ 1; [] ¬ FindText[]};    GetText[];    IF Directive[terminals] THEN {      symIndex ¬ leftIndex;      DO	GetText[];        IF symString[symIndex-1] = ': AND (Directive[aliases] OR Directive[productions])	  THEN EXIT;        [] ¬ FindText[];        ENDLOOP};    lastTerminal ¬ sinfIndex-1;    aliasIndex ¬ 0;    IF Directive[aliases] THEN {      symIndex ¬ leftIndex;      DO        AliasChar: PROC [ch: CHAR] = {	  IF aliasIndex=CARDINAL[cpw]*LENGTH[aliasText] 	  THEN aliasText ¬ LOOPHOLE[expand[LOOPHOLE[aliasText],SIZE[CARDINAL],LENGTH[aliasText]/8]];	  aliasText[aliasIndex] ¬ ch;	  aliasIndex ¬ aliasIndex + 1};	GetText[];	IF Directive[productions] THEN EXIT;	FOR i: CARDINAL IN [leftIndex..symIndex) DO          AliasChar[symString[i]];           ENDLOOP;	AliasChar[' ]; symIndex ¬ leftIndex;	GetText[];	FOR i: CARDINAL IN [leftIndex..symIndex) DO          AliasChar[symString[i]];           ENDLOOP;	AliasChar[' ]; symIndex ¬ leftIndex;	ENDLOOP};    IF ~Directive[productions] THEN Error[];    symIndex ¬ leftIndex; nextProd ¬ 1; nextRhsChar ¬ 0;    GetText[]; topSymbol ¬ FindText[];    DO -- exit from this loop on EndOfFIle, topSymbol distinguishes cases      GetText[];      IF symString[leftIndex] = ': AND symString[leftIndex+1] = ':       AND symString[leftIndex+2] = '= THEN {  	i, oldi: CARDINAL ¬ 0;	IF symIndex-leftIndex=4 AND symString[leftIndex+3]='C THEN chain ¬ TRUE        ELSE IF symIndex-leftIndex=3 THEN chain ¬ FALSE ELSE GOTO notlhs;	symIndex ¬ leftIndex;	pinfo[nextProd] ¬ [rule,chain,0,nextRhsChar];	IF (i ¬ sinfo[topSymbol].lhshead)=0 THEN sinfo[topSymbol].lhshead ¬ nextProd ELSE {	  WHILE i#0 DO oldi ¬ i; i ¬ pinfo[i].link ENDLOOP;	  pinfo[oldi].link ¬ nextProd};	nextProd ¬ nextProd+1;	IF nextProd=LENGTH[pinfo] THEN	  pinfo ¬ LOOPHOLE[expand[pinfo,SIZE[PGSTypes.PInfoRec],LENGTH[pinfo]/8]];	topSymbol ¬ 0; GetText[]; topSymbol ¬ FindText[];	LOOP	EXITS notlhs => NULL};      rhsText[nextRhsChar] ¬ topSymbol; nextRhsChar ¬ nextRhsChar+1;      IF nextRhsChar = LENGTH[rhsText] THEN	rhsText ¬ LOOPHOLE[ expand[rhsText, SIZE[CARDINAL], LENGTH[rhsText]/8] ];      topSymbol ¬ FindText[];      ENDLOOP};  Format: PUBLIC PROC [table, type, export: LONG STRING] = {    nextRule ¬ 0; symIndex ¬ 0;    hashChain ¬ AllocateSegment[SIZE[PGSTypes.HashHeads]];    hashChain­ ¬ ALL[0];    rhsText ¬ LOOPHOLE[makearray[maxrhssymbols+1,SIZE[CARDINAL]]];    sinfo ¬ LOOPHOLE[makearray[symtabsize+1,SIZE[PGSTypes.SInfoRec]]];    pinfo ¬ LOOPHOLE[makearray[maxprod+1,SIZE[PGSTypes.PInfoRec]]];    symString ¬ LOOPHOLE[makearray[500,SIZE[CARDINAL]]];    aliasText ¬ LOOPHOLE[makearray[500,SIZE[CARDINAL]]];    Formatter[table, type, export      ! EndOfFile => CONTINUE]; -- always returns via catchphrase    FreeSegment[hashChain];    IF topSymbol#0 THEN {      rhsText[nextRhsChar] ¬ topSymbol; nextRhsChar ¬ nextRhsChar+1};    sinfo[sinfIndex].symptr ¬ symIndex;    pinfo[nextProd].rhsptr ¬ nextRhsChar};  PrintGrammar: PUBLIC PROC = {    i, p, s, listindex: CARDINAL ¬ 0;    list: PGSTypes.SInfo ¬ DESCRIPTOR[NIL, 0];    rec: PGSTypes.SInfoRec ¬ [0,0,0];    noswap: BOOLEAN ¬ FALSE;    PrintToken: PROC [i: CARDINAL] RETURNS [length: CARDINAL¬0] = {      FOR j: CARDINAL IN [sinfo[i].symptr..sinfo[i+1].symptr) DO	outchar[symString[j],1]; length ¬ length+1 ENDLOOP;      RETURN};    PrintSymbol: PROC [i: CARDINAL] = {      outnum[s, 3]; s ¬ s+1; outchar[' , 2]; [] ¬ PrintToken[i]; outeol[1]};    PrintProd: PROC [i, p: CARDINAL, first: BOOLEAN] = {      outnum[s,3]; s ¬ s+1;      outstring[IF pinfo[p].chain THEN " C "L ELSE "   "L];      outnum[pinfo[p].rule,3]; outchar[' ,2];      outchar[' ,tokensize-(IF first THEN PrintToken[i] ELSE 0)];      outstring[IF first THEN " ::= "L ELSE "   | "L];      FOR j: CARDINAL IN [pinfo[p].rhsptr..pinfo[p+1].rhsptr) DO	[] ¬ PrintToken[rhsText[j]]; outchar[' , 1] ENDLOOP;      outeol[1]};    outstring["-- grammar extracted from "L];  outstring[sourceName];    outstring[" by PGS, "L];  outtime[];  outeol[2];    outstring["||CHAIN ||LISTS"L];  outeol[2];    outstring["||TABLE1"L]; outeol[1]; s ¬ 1;    IF lastTerminal=1 THEN      FOR i IN [2..sinfIndex) DO IF sinfo[i].lhshead=0 THEN PrintSymbol[i] ENDLOOP    ELSE      FOR i IN [2..lastTerminal] DO PrintSymbol[i] ENDLOOP;    outnum[s, 3]; s ¬ s+1; outstring["  eof"L]; outeol[2];    outstring["||TABLE2"L]; outeol[1];    PrintSymbol[1]; p ¬ 1;    FOR i IN (lastTerminal..sinfIndex) DO      IF sinfo[i].lhshead#0 THEN {PrintSymbol[i]; p ¬ p+1} ENDLOOP;    IF aliasIndex # 0 THEN {      state: {init, id1, sp, id2} ¬ init;      nc: CARDINAL ¬ 0;      outeol[2]; outstring["||TABLE3"L]; outeol[1];      FOR i IN [0..aliasIndex) DO	c: CHARACTER = aliasText[i];	IF c # '  THEN {	  outchar[c, 1];  nc ¬ nc+1;	  state ¬ SELECT state FROM	    init => id1, sp => id2, ENDCASE => state}	ELSE SELECT state FROM	  id1 => {outchar[' , tokensize-nc]; nc ¬ 0; state ¬ sp};	  id2 => {outeol[1]; nc ¬ 0; state ¬ init};	  ENDCASE;	ENDLOOP;	IF state # init THEN outeol[1]};    outeol[2]; outstring["||TABLE4"L]; outeol[2];  s ¬ 1;    list ¬ makearray[p,SIZE[PGSTypes.SInfoRec]];    p ¬ sinfo[1].lhshead; list[0] ¬ [1,pinfo[p].rule,p]; listindex ¬ 1;    FOR i IN (lastTerminal..sinfIndex) DO      IF (p ¬ sinfo[i].lhshead)#0 THEN {        list[listindex] ¬ [i,pinfo[p].rule,p]; listindex ¬ listindex+1};      ENDLOOP;    FOR i DECREASING IN [0..LENGTH[list]) DO      noswap ¬ TRUE;      FOR p IN [0..i) DO        IF list[p].link>list[p+1].link THEN {          rec ¬ list[p]; list[p] ¬ list[p+1]; list[p+1] ¬ rec; noswap ¬ FALSE};        ENDLOOP;      IF noswap THEN EXIT;      ENDLOOP;    FOR i IN [0..LENGTH[list]) DO      p ¬ list[i].lhshead; PrintProd[list[i].symptr,p,TRUE]; p ¬ pinfo[p].link;      WHILE p#0 DO PrintProd[0,p,FALSE]; p ¬ pinfo[p].link ENDLOOP;      outeol[1];      ENDLOOP;    FreeSegment[BASE[list]]; FreeSegment[BASE[rhsText]];    FreeSegment[BASE[sinfo]]; FreeSegment[BASE[pinfo]];    FreeSegment[BASE[symString]]; FreeSegment[BASE[aliasText]]};-- text input routines  char: CHARACTER;	-- current (most recently scanned) character  EndOfFile: SIGNAL = CODE;  GetText: PROC = {    c: CHARACTER;    WHILE char IN [0C..' ] DO      IF char=ControlZ THEN        WHILE char#CR DO outchar[char,1]; NextChar[]; ENDLOOP;      outchar[char,1];      IF char=CR THEN {        WHILE char IN [0C..' ] DO NextChar[]; outchar[char,1] ENDLOOP;        c ¬ char; NextChar[]; outchar[char,1];        IF c#char OR c#'- THEN {NextChar[]; FindHeader[]}};      NextChar[];      ENDLOOP;    leftIndex ¬ symIndex;    WHILE char ~IN [0C..' ] DO      outchar[char,1];      IF symIndex=CARDINAL[cpw]*LENGTH[symString] THEN symString ¬ LOOPHOLE[	expand[LOOPHOLE[symString],SIZE[CARDINAL],LENGTH[symString]/8]];      symString[symIndex] ¬ char; symIndex ¬ symIndex+1; NextChar[];      ENDLOOP};  FindHeader: PROC = {    bindex, i, k: CARDINAL ¬ 0;    buffer: STRING = [2000];  -- line assembly area    BufferOverflow: ERROR = CODE;    PutChar: PROC = {      IF bindex = buffer.maxlength THEN ERROR BufferOverflow;      buffer[bindex] ¬ char; bindex ¬ bindex+1; NextChar[]};    DO {      bindex ¬ 0;      WHILE char IN [0C..' ] DO        IF char = CR OR char = ControlZ THEN GOTO copyline; PutChar[];        ENDLOOP;      IF char ~IN ['0..'9] AND char # query THEN GOTO copyline; PutChar[];      WHILE char IN ['0..'9] DO PutChar[] ENDLOOP;      WHILE char IN [0C..' ] DO        IF char = CR OR char = ControlZ THEN GOTO copyline; PutChar[];        ENDLOOP;      IF char # '= THEN GOTO copyline; PutChar[];      IF char # '> THEN GOTO copyline; PutChar[];      WHILE char IN [0C..' ]        DO IF char=CR OR char=ControlZ THEN GOTO copyline; PutChar[];        ENDLOOP;      IF char # '- THEN GOTO copyline; PutChar[];      IF char # '- THEN GOTO copyline;      FOR i ¬ bindex-1, i-1 WHILE buffer[i] # '= DO NULL ENDLOOP;      k ¬ 0;      FOR j: CARDINAL IN [0..i) DO k ¬ IF buffer[j] = TAB THEN k+8 ELSE k+1 ENDLOOP;      outnum[nextRule,k-2]; rule ¬ nextRule; nextRule ¬ nextRule+1;      outchar[' ,2]; FOR j: CARDINAL IN [i..bindex) DO outchar[buffer[j],1] ENDLOOP;      outchar['-,1];      RETURN      EXITS      copyline => {        FOR i: CARDINAL IN [0..bindex) DO outchar[buffer[i],1] ENDLOOP;        outchar[char,1];        WHILE char # CR DO NextChar[]; outchar[char,1] ENDLOOP;        NextChar[]}};      ENDLOOP};  tB: LONG POINTER TO PACKED ARRAY OF CHARACTER ¬ NIL;  tI, tMax: [0..TextChars] ¬ 0;  tOrigin, tLimit: CARDINAL ¬ 0;  tEnded: BOOLEAN ¬ FALSE;  NextChar: PROC = {    IF (tI¬tI+1) = tMax THEN {IF tEnded THEN SIGNAL EndOfFile[]; FillTextBuffer[]};    char ¬ tB[tI]};  ScanInit: PROC = {    tLimit ¬ tMax ¬ 0; tEnded ¬ FALSE; FillTextBuffer[];    char ¬ tB[tI]; FindHeader[]; NextChar[]};  FillTextBuffer: PROC = {    tOrigin ¬ tLimit;    IF tEnded THEN  tMax ¬ 0 ELSE {      [tB, tMax, tEnded] ¬ nextbuffer[]; tLimit ¬ tOrigin + tMax};    IF tMax = 0 THEN {tB[0] ¬ 0C;  tMax ¬ 1};    tI ¬ 0}; }.
-- Copyright (C) 1981, 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- StringCompactor.mesa--   JGS		 4-Nov-82 16:48:50--   LXR    		10-Aug-81 15:13:35--   EXS          	March 24, 1981  9:02 AM--   RES  		12-Jan-83 13:20:24--   RXJ     		 8-Jul-83 14:41:52  DIRECTORY  Ascii: TYPE USING [CR, NUL],  CharIO: TYPE USING [NumberFormat, PutChar, PutNumber, PutString],  Environment: TYPE USING [charsPerWord],  Spaces: TYPE USING [Node, Free],  PGSConDefs: TYPE USING [FixupBcdHeader],  MStream: TYPE USING [ReadOnly, WriteOnly],  Stream: TYPE USING [    Handle, Delete, GetChar, GetPosition, EndOfStream, PutChar, PutWord,    SetPosition],  String: TYPE USING [AppendString],  TableCommand: TYPE USING [CreateBCDStream];  StringCompactor: PROGRAM    IMPORTS      CharIO, Spaces, PGSConDefs, MStream, Stream, String, TableCommand    EXPORTS TableCommand = {    CharsPerWord: CARDINAL = Environment.charsPerWord;  StreamIndex: TYPE = LONG CARDINAL ¬ 0;  SyntaxError: ERROR = CODE;  CompStrDesc: TYPE = RECORD [offset, length: CARDINAL];    nArrays: CARDINAL ¬ 0;  nStrings: CARDINAL ¬ 0;  nChars: CARDINAL ¬ 0;  nWords: CARDINAL ¬ 0;    in: Stream.Handle ¬ NIL;    SLptr: TYPE = LONG POINTER TO SL;    SL: TYPE = RECORD [    link: SLptr,    startIndex: StreamIndex,    length: CARDINAL];    ALptr: TYPE = LONG POINTER TO AL;    AL: TYPE = RECORD [    link: ALptr,    name: NL,    ARRAYindex: StreamIndex,    needsIndexDef: BOOLEAN,    headSL, tailSL: SLptr,    nstrings: CARDINAL];    NL: TYPE = RECORD [startIndex: StreamIndex, length: CARDINAL];    BackUp: PROC [s: Stream.Handle] = {s.SetPosition[s.GetPosition[] - 1]};    NextString: PROC [s: SLptr] RETURNS [found: BOOLEAN ¬ TRUE] = {    nc: CARDINAL ¬ 0;    quoteFound, collectingChars: BOOLEAN ¬ FALSE;    DO      c: CHARACTER;      c ¬ in.GetChar[];      IF c = '; AND ~collectingChars THEN RETURN [FALSE];      IF c = '" THEN	IF quoteFound THEN	  IF collectingChars THEN {quoteFound ¬ FALSE; nc ¬ nc+1} ELSE ERROR	ELSE	  IF collectingChars THEN quoteFound ¬ TRUE	  ELSE {s.startIndex ¬ in.GetPosition[];  collectingChars ¬ TRUE}      ELSE	IF quoteFound	  THEN {s.length ¬ nc; BackUp[in]; EXIT}	  ELSE IF collectingChars THEN nc ¬ nc+1;      ENDLOOP;    nStrings ¬ nStrings+1;    nChars ¬ nChars + nc;  nWords ¬ nWords + SIZE[StringBody[nc]]};    lastCR: StreamIndex ¬ 0;    AllDone: ERROR = CODE;    NextItem: PROC [a: ALptr] = {    nc: CARDINAL ¬ 0;    state: {      start, aRray, arRay, arrAy, arraY,      sTring, stRing, strIng, striNg, strinG, Of, oF, end} ¬ start;    array: BOOLEAN ¬ FALSE;      DO      ENABLE Stream.EndOfStream => ERROR AllDone;      c: CHARACTER;      c ¬ in.GetChar[];  nc ¬ nc+1;      SELECT c FROM	'A =>	  state ¬ SELECT state FROM  		  start => aRray,		  arrAy => arraY,		  stRing => strIng,		  ENDCASE => start;	'R => 	  state ¬ SELECT state FROM		  aRray => arRay,		  arRay => arrAy,		  stRing => strIng,		  ENDCASE => start;	'Y =>	  IF state = arraY	    THEN {array ¬ TRUE; a.ARRAYindex ¬ in.GetPosition[];  state ¬ end}	    ELSE state ¬ start;	'S =>	  IF state = start THEN {a.name.length ¬ nc-1; state ¬ sTring} ELSE state ¬ start;	'T => state ¬ IF state = sTring THEN stRing ELSE start;	'I => state ¬ IF state = strIng THEN striNg ELSE start;	'N => state ¬ IF state = striNg THEN strinG ELSE start;	'G => IF state = strinG THEN {array ¬ FALSE; state ¬ end} ELSE state ¬ start;	Ascii.CR => {	  IF state = end THEN EXIT;	  lastCR ¬ in.GetPosition[];  nc ¬ 0;  state ¬ start};	IN [0c..' ] => IF state = end THEN EXIT ELSE state ¬ start;	ENDCASE => state ¬ start;      ENDLOOP;    a.name.startIndex ¬ lastCR;  a.needsIndexDef ¬ array;    IF array      THEN {	state ¬ Of;	DO	  ENABLE Stream.EndOfStream => ERROR SyntaxError;	  c: CHARACTER;	  c ¬ in.GetChar[];  nc ¬ nc+1;	  SELECT c FROM	    IN [0c..' ] =>	      SELECT state FROM		start => state ¬ Of;		Of => NULL;		end => EXIT;		ENDCASE => state ¬ start;	    'O => state ¬ IF state = Of THEN oF ELSE start;	    'F => state ¬ IF state = oF THEN end ELSE start;	    ENDCASE => {a.needsIndexDef ¬ FALSE; state ¬ start};	  ENDLOOP;	a.name.length ¬ nc};    CollectStrings[a];    IF array THEN nArrays ¬ nArrays + 1};    headAL, tailAL: ALptr ¬ NIL;    CollectStrings: PROC [a: ALptr] = {     s: SLptr ¬ NIL;    oldnStrings: CARDINAL = nStrings;    a.headSL ¬ a.tailSL ¬ NIL;    WHILE NextString[s ¬ AllocateSL[]] DO AppendSL[a, s] ENDLOOP;    Spaces.Free[s];    a.nstrings ¬ nStrings - oldnStrings};      CollectArrays: PROC = {    a: ALptr ¬ NIL;    headAL ¬ tailAL ¬ NIL;    nArrays ¬ nStrings ¬ nChars ¬ nWords ¬ 0;    lastCR ¬ 0;    DO      NextItem[a ¬ AllocateAL[] ! AllDone => {Spaces.Free[a]; EXIT}];      AppendAL[a];      ENDLOOP};      AllocateSL: PROC RETURNS [s: SLptr] = {    s ¬ Spaces.Node[SIZE[SL]]; s.link ¬ NIL; RETURN};    AppendSL: PROC [a: ALptr, s: SLptr] = {    IF a.tailSL = NIL THEN a.headSL ¬ s ELSE a.tailSL.link ¬ s;    a.tailSL ¬ s};      AllocateAL: PROC RETURNS [a: ALptr] = {    a ¬ Spaces.Node[SIZE[AL]]; a.link ¬ NIL; RETURN};    AppendAL: PROC [a: ALptr] = {    IF tailAL = NIL THEN headAL ¬ a ELSE tailAL.link ¬ a;    tailAL ¬ a};      OutStrings: PROC [out: Stream.Handle, compact: BOOLEAN] = {    charPos: CARDINAL;    buffer: PACKED ARRAY [0..CharsPerWord) OF CHARACTER;    byte: [0 .. CharsPerWord] ¬ 0;      FlushBuffer: PROC = {UNTIL byte = 0 DO PutChar[Ascii.NUL] ENDLOOP};      PutChar: PROC [c: CHARACTER] = {      buffer[byte] ¬ c;      IF (byte ¬ byte+1) = CharsPerWord THEN {	FOR i: [0..CharsPerWord) IN [0..CharsPerWord) DO	  out.PutChar[buffer[i]] ENDLOOP;	byte ¬ 0}};      IF compact      THEN {out.PutWord[nStrings*SIZE[CompStrDesc]+1]; charPos ¬ 0}      ELSE {out.PutWord[nStrings]; charPos ¬ (nStrings+1)*CharsPerWord};    FOR a: ALptr ¬ headAL, a.link UNTIL a = NIL DO      FOR s: SLptr ¬ a.headSL, s.link UNTIL s = NIL DO        IF compact	  THEN {	    out.PutWord[charPos]; out.PutWord[s.length];	    charPos ¬ charPos + s.length}	  ELSE {	    out.PutWord[charPos/CharsPerWord];	    charPos ¬ charPos + SIZE[StringBody[s.length]]*CharsPerWord};        ENDLOOP;      ENDLOOP;    IF compact THEN {out.PutWord[nChars]; out.PutWord[nChars]};    FOR a: ALptr ¬ headAL, a.link UNTIL a = NIL DO      s: SLptr ¬ a.headSL;      UNTIL s = NIL	DO	nextS: SLptr = s.link;	IF ~compact THEN {out.PutWord[s.length]; out.PutWord[s.length]};        in.SetPosition[s.startIndex];	FOR i: CARDINAL IN [0 .. s.length) DO	  c: CHARACTER = in.GetChar[];	  PutChar[IF c # '" THEN c ELSE in.GetChar[]];	  ENDLOOP;	IF ~compact THEN FlushBuffer[];        Spaces.Free[s];  s ¬ nextS;        ENDLOOP;      ENDLOOP;    FlushBuffer[]};    OutRecordDecl: PROC [      out: Stream.Handle, formatId: LONG STRING, compact: BOOLEAN] = {    OPEN CharIO;    a: ALptr ¬ headAL;    FOR i: CARDINAL IN [0..formatId.length) DO      IF formatId[i] = '. THEN EXIT; PutChar[out, formatId[i]];      ENDLOOP;    PutString[out, ": DEFINITIONS = {    CSRptr: TYPE = "L];    PutString[out, "LONG BASE POINTER TO CompStrRecord;"L];    PutString[out, IF compact THEN "  CompStrDesc: TYPE = RECORD [offset, length: CARDINAL];    CompStrRecord: TYPE = RECORD [    stringOffset: CSRptr RELATIVE POINTER TO StringBody,"L    ELSE "  StringOffset: TYPE = CSRptr RELATIVE POINTER TO StringBody;    StringRecord: TYPE = RECORD [    nStrings: CARDINAL,"L];    a ¬ headAL;    DO      nextA: ALptr = a.link;      nonBlank: BOOLEAN ¬ FALSE;      in.SetPosition[a.name.startIndex];      PutString[out, "    "L];      FOR i: CARDINAL IN [0..a.name.length) DO        c: CHARACTER;        IF a.needsIndexDef AND in.GetPosition[] = a.ARRAYindex	  THEN {	    PutString[out, " [0.."L];	    PutNumber[out, a.nstrings, NumberFormat[10,FALSE,FALSE,0]];	    PutChar[out, ')]};        c ¬ in.GetChar[];	IF nonBlank OR c # '  THEN {PutChar[out, c]; nonBlank ¬ TRUE};        ENDLOOP;      PutString[out, IF compact THEN "CompStrDesc"L ELSE "StringOffset"L];      Spaces.Free[a];      IF (a ¬ nextA) = NIL THEN EXIT;      PutChar[out, ',];  PutChar[out, Ascii.CR];      ENDLOOP;    PutString[out, "];  }."L]};      CompileStrings: PUBLIC PROC [	inputFile: LONG STRING,		-- the source file	interfaceId: LONG STRING,		-- exported interface or "SELF"	formatId: LONG STRING,		-- ASCII record declaration	moduleId: LONG STRING,		-- output file	compact: BOOLEAN]      RETURNS [CARDINAL, CARDINAL] = {    t: STRING = [40];    sStream, rStream: Stream.Handle ¬ NIL;    t.length ¬ 0;  String.AppendString[t, inputFile];    in ¬ MStream.ReadOnly[t, []];    CollectArrays[];    sStream ¬ TableCommand.CreateBCDStream[	in: in, modId: moduleId,	sourceName: inputFile,	count: 	  1 + nStrings*(IF compact THEN SIZE[CompStrDesc] ELSE 1) +	  (IF compact THEN SIZE[StringBody[nChars]] ELSE nWords),	interfaceId: interfaceId];    OutStrings[sStream, compact];    PGSConDefs.FixupBcdHeader[]; sStream.Delete[];    t.length ¬ 0;  String.AppendString[t, formatId];    rStream ¬ MStream.WriteOnly[t, [], binary];    OutRecordDecl[rStream, formatId, compact];  rStream.Delete[];    in.Delete[];    RETURN [nStrings, nChars]};  }.
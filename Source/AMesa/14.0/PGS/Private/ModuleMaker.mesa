-- Copyright (C) 1981, 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- ModuleMaker.Mesa--   JGS		 4-Nov-82 17:07:56--   EXS          	March 17, 1981  10:27 AM--   BTL  		29-Oct-81 18:29:42--   RES  		 5-Oct-83 16:23:42--   DWE    		10-Jun-83 13:20:12--   RXJ     		 8-Jul-83 16:03:12--   NFS		11-Aug-87 16:53:57DIRECTORY  BcdDefs: TYPE ,  BcdDefsExtras USING [NewMesaModule],  BcdOps: TYPE USING [EXPHandle, NameString],  Environment: TYPE USING [bytesPerPage, bytesPerWord],  Inline: TYPE USING [LowHalf],  PGSConDefs: TYPE USING [WriteSymbols],  Spaces: TYPE USING [Free, FreeString, Node, PagesForWords, String],  MFile USING [SetTimes],  MStream: TYPE USING [    Copy, Error, ErrorCode, GetFile, GetLength, ReadOnly, WriteOnly],  Stream: TYPE USING [    Handle, Delete, GetPosition, PutBlock, PutByte, SetPosition],  String: TYPE USING [    SubStringDescriptor, AppendChar, AppendString, EquivalentSubStrings],  TableCommand: TYPE USING [    CreateTime, FindInterface, FindItem, GenerateVersion, MyBcdVersion];ModuleMaker: PROGRAM    IMPORTS      Inline, PGSConDefs, Spaces, MFile, MStream, Stream, String, TableCommand    EXPORTS PGSConDefs, TableCommand = {  StreamIndex: TYPE = LONG CARDINAL; -- BCD construction  bcdHeader: BcdDefs.BCD;  module: BcdDefs.MTRecord;  export: BcdOps.EXPHandle;  codeSeg, symbolSeg: BcdDefs.SGRecord;  ssb: BcdOps.NameString ¬ NIL;    sourceFti: BcdDefs.FTIndex = FIRST[BcdDefs.FTIndex];  defsFti: BcdDefs.FTIndex = sourceFti + SIZE[BcdDefs.FTRecord];  fileTable: MACHINE DEPENDENT RECORD[    sourceFile(LOOPHOLE[sourceFti]): BcdDefs.FTRecord,    defsFile(LOOPHOLE[defsFti]): BcdDefs.FTRecord];  pgsVersion: PUBLIC BcdDefs.VersionStamp ¬ TableCommand.MyBcdVersion[];  sourceVersion: PUBLIC BcdDefs.VersionStamp ¬ [0, 0, 0];  objectVersion: PUBLIC BcdDefs.VersionStamp ¬ TableCommand.GenerateVersion[];  moduleIndex, segIndex: StreamIndex ¬ 0;	-- for fixup  moduleId: LONG STRING ¬ [40];  out: Stream.Handle ¬ NIL;  InitializePackedString: PROC = {    ssb ¬ LOOPHOLE[Spaces.String[200]];    ssb.string.length ¬ 1;  ssb.size[1] ¬ 0;  moduleId.length ¬ 0};  AddName: PROC [n: LONG STRING] RETURNS [name: BcdDefs.NameRecord] = {    String.AppendChar[@ssb.string, LOOPHOLE[n.length]];    name ¬ BcdDefs.NameRecord[ssb.string.length];    String.AppendString[@ssb.string, n];    RETURN};  FillInModule: PROC [      name: BcdDefs.NameRecord, segmentSize: CARDINAL] = {    OPEN BcdDefs;    module ¬ MTRecord[      name: name, namedInstance: FALSE, initial: FALSE,      file: FTSelf, linkLoc: frame, config: CTNull, packed: FALSE,      linkspace: FALSE,      code: [sgi: FIRST[SGIndex], offset: 0, length: 2*segmentSize],      sseg: FIRST[SGIndex]+SIZE[SGRecord], framesize: 4,      spare: BcdDefsExtras.NewMesaModule, tableCompiled: TRUE,      packageable: TRUE,      residentFrame: FALSE, crossJumped: FALSE, boundsChecks: FALSE, nilChecks: FALSE,      links: FIRST[LFIndex],      entries: ENNull, atoms: ATNull];    codeSeg ¬ SGRecord[class: code, file: FTSelf, base: 2,      pages: Spaces.PagesForWords[segmentSize], extraPages: 0];    symbolSeg ¬ SGRecord[class: symbols, file: FTNull, base: 0,      pages: 0, extraPages: 0]};  FillInExport: PROC [name: BcdDefs.NameRecord, size, entry: CARDINAL] = {    export ¬ Spaces.Node[SIZE[BcdDefs.EXPRecord]+size*SIZE[BcdDefs.Link]];    export­ ¬ BcdDefs.EXPRecord[name: name, size: size, port: interface,      namedInstance: FALSE, typeExported: FALSE,      file: defsFti, links:];    FOR i: CARDINAL IN [0..size) DO export.links[i] ¬ BcdDefs.NullLink ENDLOOP;    export.links[entry] ¬ BcdDefs.Link[variable[gfi:1, offset:0]]};  FillInHeader: PROC = {    OPEN h: bcdHeader;    objectVersion ¬ TableCommand.GenerateVersion[];    -- clear all fields    LOOPHOLE[bcdHeader, ARRAY [0..SIZE[BcdDefs.BCD]) OF CARDINAL] ¬ ALL[0];    h.versionIdent ¬ BcdDefs.VersionID;    h.version ¬ objectVersion;    h.sourceFile ¬ sourceFti;    h.unpackagedFile ¬ BcdDefs.FTNull;    h.creator ¬ pgsVersion;    h.nPages ¬ 1;    h.nConfigs ¬ 0;  h.nModules ¬ 1;    h.nImports ¬ 0;  h.nExports ¬ IF export = NIL THEN 0 ELSE 1;    h.definitions ¬ h.repackaged ¬ h.typeExported ¬ FALSE;    h.tableCompiled ¬ TRUE;    h.firstdummy ¬ 2;  h.nDummies ¬ 0;    h.ssOffset ¬ h.ctOffset ¬ h.impOffset ¬ h.ntOffset ¬ SIZE[BcdDefs.BCD];    h.ssLimit ¬ SIZE[StringBody[ssb.string.length]];    h.mtOffset ¬ h.ssOffset + LOOPHOLE[h.ssLimit, CARDINAL];    h.mtLimit ¬ LOOPHOLE[SIZE[BcdDefs.MTRecord]];    h.sgOffset ¬ h.mtOffset + LOOPHOLE[h.mtLimit, CARDINAL];    h.sgLimit ¬ LOOPHOLE[2*SIZE[BcdDefs.SGRecord]];    h.lfOffset ¬ h.sgOffset + LOOPHOLE[h.sgLimit, CARDINAL];    h.lfLimit ¬ LOOPHOLE[SIZE[BcdDefs.LinkFrag[0]]];    h.ftOffset ¬ h.lfOffset + LOOPHOLE[h.lfLimit, CARDINAL];    h.ftLimit ¬ LOOPHOLE[SIZE[BcdDefs.FTRecord]];    IF export # NIL      THEN {	h.ftLimit ¬ h.ftLimit + LOOPHOLE[SIZE[BcdDefs.FTRecord]];	h.expOffset ¬ h.ftOffset + LOOPHOLE[h.ftLimit, CARDINAL];	h.expLimit ¬ LOOPHOLE[	  SIZE[BcdDefs.EXPRecord]+export.size*SIZE[BcdDefs.Link]]}};  WriteBcd: PROC [out: Stream.Handle] = {    linkFrag: ARRAY [0..SIZE[BcdDefs.LinkFrag[0]]) OF CARDINAL ¬ ALL[0];    PutBlock[out, @bcdHeader, SIZE[BcdDefs.BCD]];    PutBlock[out, ssb, SIZE[StringBody[ssb.string.length]]];    Spaces.FreeString[LOOPHOLE[ssb]];  ssb ¬ NIL;    moduleIndex ¬ out.GetPosition[];    PutBlock[out, @module, SIZE[BcdDefs.MTRecord]];    segIndex ¬ out.GetPosition[];    PutBlock[out, @codeSeg, SIZE[BcdDefs.SGRecord]];    PutBlock[out, @symbolSeg, SIZE[BcdDefs.SGRecord]];    PutBlock[out, @linkFrag, SIZE[BcdDefs.LinkFrag[0]]];    PutBlock[      out, @fileTable, (IF export # NIL THEN 2 ELSE 1) * SIZE[BcdDefs.FTRecord]];    IF export # NIL      THEN {	PutBlock[	  out, export, SIZE[BcdDefs.EXPRecord] + export.size*SIZE[BcdDefs.Link]];	Spaces.Free[export]};    IF out.GetPosition[] > Environment.bytesPerPage THEN ERROR};  PutBlock: PROC [out: Stream.Handle, p: LONG POINTER, nWords: CARDINAL] = {    [] ¬ out.PutBlock[[p, 0, nWords*Environment.bytesPerWord]]};      CreateBCDStream: PUBLIC PROC [	in: Stream.Handle,	modId, interfaceId: LONG STRING,	sourceName: LONG STRING,	count: CARDINAL]      RETURNS [output: Stream.Handle] = {    modRoot: STRING ¬ [40];    interfaceRoot: STRING ¬ [40];    self: String.SubStringDescriptor ¬ ["SELF"L, 0, ("SELF"L).length];    interface: String.SubStringDescriptor;    symbolSeg: MSegment.Handle;    t: STRING = [40];    InitializePackedString[];    fileTable.sourceFile.name ¬ AddName[sourceName];    SetSourceVersion[in];    FOR i: CARDINAL IN [0..modId.length) DO      IF modId[i] = '. THEN EXIT;      String.AppendChar[modRoot, modId[i]];      ENDLOOP;    String.AppendString[t, modId];    out ¬ output ¬ MStream.WriteOnly[t, [], binary];    String.AppendString[moduleId, modRoot];    FillInModule[AddName[modRoot], count];    FOR i: CARDINAL IN [0..interfaceId.length) DO      IF interfaceId[i] = '. THEN EXIT;      String.AppendChar[interfaceRoot, interfaceId[i]];      ENDLOOP;    -- fill in interface info    interface ¬ [interfaceRoot, 0, interfaceRoot.length];    IF String.EquivalentSubStrings[@interface, @self]      THEN export ¬ NIL      ELSE {	dName: BcdDefs.NameRecord ¬ AddName[interfaceRoot];	size, entry: CARDINAL;	[fileTable.defsFile.version, symbolSeg] ¬	  TableCommand.FindInterface[interfaceRoot];	fileTable.defsFile.name ¬ dName;	[size, entry] ¬ TableCommand.FindItem[symbolSeg, modRoot];	FillInExport[dName, size, entry]};    FillInHeader[]; -- Do this after all strings entered    -- Make file time be same as bcd version time.    MFile.SetTimes[      file: MStream.GetFile[output], create: [objectVersion.time]];    WriteBcd[out];    out.SetPosition[Environment.bytesPerPage];    RETURN};    -- input management  BytesPerWord: CARDINAL = Environment.bytesPerWord;  BytesPerPage: CARDINAL = Environment.bytesPerPage;  FixupBcdHeader: PUBLIC PROC = {    endIndex: StreamIndex ¬ out.GetPosition[];    nBytes: CARDINAL = Inline.LowHalf[endIndex] - BytesPerPage;    IF export # NIL THEN RETURN;    module.code.length ¬ nBytes;    codeSeg.pages ¬ Spaces.PagesForWords[(nBytes + (BytesPerWord-1))/BytesPerWord];    IF bcdHeader.nExports = 0      THEN {	startIndex: StreamIndex;	symbolBytes: CARDINAL;	UNTIL (startIndex ¬ out.GetPosition[]) MOD BytesPerPage = 0 DO	  out.PutByte[0] ENDLOOP;	symbolSeg ¬ [            class: symbols, file: BcdDefs.FTSelf,            base: codeSeg.base+codeSeg.pages, pages: , extraPages: 0];	PGSConDefs.WriteSymbols[out, moduleId];	endIndex ¬ out.GetPosition[];	symbolBytes ¬ Inline.LowHalf[endIndex-startIndex];	symbolSeg.pages ¬	  Spaces.PagesForWords[(symbolBytes + (BytesPerWord-1))/BytesPerWord]};    out.SetPosition[moduleIndex];    PutBlock[out, @module, SIZE[BcdDefs.MTRecord]];    out.SetPosition[segIndex];    PutBlock[out, @codeSeg, SIZE[BcdDefs.SGRecord]];    PutBlock[out, @symbolSeg, SIZE[BcdDefs.SGRecord]];    out.SetPosition[endIndex]};  SetSourceVersion: PROC [sh: Stream.Handle] = {    sourceVersion ¬ fileTable.sourceFile.version ¬ [      0, 0, TableCommand.CreateTime[sh]]}; -- overall control  PagesForBytes: PROC [bytes: LONG CARDINAL] RETURNS [pages: CARDINAL] = INLINE {    n: LONG CARDINAL ¬ (bytes + BytesPerPage-1)/BytesPerPage;    RETURN[Inline.LowHalf[n]]};      MakeModule: PUBLIC PROC [      inputFile, moduleId, interfaceId: LONG STRING] = {    output: Stream.Handle ¬ NIL;    in: Stream.Handle ¬ MStream.ReadOnly[inputFile, []];    count: LONG CARDINAL ¬ MStream.GetLength[in];    IF (count+1)/2 > CARDINAL.LAST THEN          ERROR MStream.Error[in, MStream.ErrorCode[fileTooLong]];    output ¬ CreateBCDStream[      in: in, modId: moduleId, interfaceId: interfaceId,      sourceName: inputFile, count: CARDINAL[(count+1)/2]];    [] ¬ MStream.Copy[from: in, to: output, bytes: count];    FixupBcdHeader[];    output.Delete[];    in.Delete[]};  }.
-- Copyright (C) 1981, 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- PGSControl.Mesa--   LXR    		 7-Aug-81 10:35:59--   EXS          	20-Mar-81 15:42:00--   JGS		 2-Dec-82 14:43:30--   RES  		 6-Dec-82 21:49:05--   RXJ     		 6-Jul-83 19:16:38DIRECTORY  Ascii: TYPE USING [CR, ControlZ, TAB],  CharIO: TYPE USING [GetChar, PutChar, PutString],  CommandUtil: TYPE USING [    PairList, CopyString, FreeString, KeyValue, ListLength, SetExtension],  Environment: TYPE USING [bytesPerWord],  Inline: TYPE USING [BITOR, BITXOR, DIVMOD],  MFile,  MStream,  PGS1: TYPE USING [Parse],  PGSConDefs: TYPE USING [    AcquireTable, bitstrsize, cpw, pagesize, TextPages, TextChars,    FixupBcdHeader, Format, LALRGen, OutModule, PrintGrammar,    ReleaseTable, TabGen, WriteBcdHeader],  PGSOps: TYPE USING [PGSPhase],  PGSParseData: TYPE,  PGSTypes: TYPE USING [    Aliases, LongDes, Options, ProdInfo, RhsChar, SymTab, SymInfo, TokenInfo],  ProcessorFace: TYPE USING [processorID],  Runtime: TYPE USING [GetBcdTime],  Spaces: TYPE USING [FreeWords, Words, Free, FreePages, Node, Pages],  Stream: TYPE USING [    Handle, Delete, EndOfStream, GetBlock, GetPosition, GetWord, PutBlock, PutWord,    SendNow, SetPosition],  String: TYPE USING [    SubStringDescriptor, AppendChar, AppendString, EqualSubStrings,    EquivalentSubStrings],  Time: TYPE USING [defaultTime, Packed, Append, Current, Unpack],  TimeStamp: TYPE USING [Null, Stamp];PGSControl: PROGRAM    IMPORTS      CharIO, CommandUtil, Inline, MFile, MStream, PGS1, PGSConDefs,      PGSParseData, ProcessorFace, Runtime, Spaces, Stream, String, Time    EXPORTS PGSConDefs, PGSOps, PGS1 = {  eofile, totalTokens, numprod, numrules, nextAlias: PUBLIC CARDINAL ¬ 0;  warningsLogged: PUBLIC BOOLEAN ¬ FALSE;  flags: PUBLIC ARRAY PGSTypes.Options OF BOOLEAN ¬ ALL [FALSE];  symtab: PUBLIC PGSTypes.SymTab ¬ DESCRIPTOR[NIL, 0];  syminfo: PUBLIC PGSTypes.SymInfo ¬ DESCRIPTOR[NIL, 0];  aliases: PUBLIC PGSTypes.Aliases ¬ DESCRIPTOR[NIL, 0];  tokeninfo: PUBLIC PGSTypes.TokenInfo ¬ DESCRIPTOR[NIL, 0];  prodinfo: PUBLIC PGSTypes.ProdInfo ¬ DESCRIPTOR[NIL, 0];  rhschar: PUBLIC PGSTypes.RhsChar ¬ DESCRIPTOR[NIL, 0];  slim, tentries, ntentries: PUBLIC CARDINAL ¬ 0;  bitstrsize: PUBLIC CARDINAL ¬ 0;  PGSfail: PUBLIC ERROR = CODE;  outStream: Stream.Handle ¬ NIL;  outeol: PUBLIC PROC [n: CARDINAL] = {    THROUGH [1..n] DO CharIO.PutChar[outStream,Ascii.CR] ENDLOOP};  outchar: PUBLIC PROC [c: CHARACTER, n: INTEGER]= {    THROUGH [1..n] DO CharIO.PutChar[outStream,c] ENDLOOP};  outstring: PUBLIC PROC [string: LONG STRING] = {CharIO.PutString[outStream,string]};  outtab: PUBLIC PROC = {CharIO.PutChar[outStream,Ascii.TAB]};  outnum: PUBLIC PROC [val: INTEGER, cols: CARDINAL, signChar: CHARACTER¬'-] = {    i: CARDINAL;    power, digits: CARDINAL ¬ 1;    num: CARDINAL ¬ ABS[val];    sign: CARDINAL = IF val<0 THEN 1 ELSE 0;    WHILE (i¬power*10)<=num DO power ¬ i; digits ¬ digits+1 ENDLOOP;    outchar[' , INTEGER[cols-digits-sign]];    IF sign#0 THEN CharIO.PutChar[outStream,signChar];    UNTIL power < 1 DO      [i,num] ¬ Inline.DIVMOD[num,power]; CharIO.PutChar[outStream,i+'0];      power ¬ power/10;      ENDLOOP};  startTime: Time.Packed ¬ Time.defaultTime;  outtime: PUBLIC PROC = {    time: STRING = [20];    Time.Append[time, Time.Unpack[startTime]];    time.length ¬ time.length-3;    CharIO.PutString[outStream,time]};-- storage allocation for PGSscan, PGSlalr, PGStab  LongDes: TYPE = PGSTypes.LongDes ¬ DESCRIPTOR[NIL, 0];  AllocateSegment: PUBLIC PROC [nwords: CARDINAL] RETURNS [LONG POINTER] = {    RETURN [Spaces.Words[nwords]]};  FreeSegment: PUBLIC PROC [base: LONG POINTER] = {Spaces.FreeWords[base]};  AllocateHeapNode: PUBLIC PROC [nwords: CARDINAL] RETURNS [LONG POINTER] = {    RETURN [Spaces.Node[nwords]]};  FreeHeapNode: PUBLIC PROC [base: LONG POINTER] = {Spaces.Free[base]};    FreeArray: PUBLIC PROC [des: LongDes] = {FreeSegment[BASE[des]]};  makearray: PUBLIC PROC [length, width: CARDINAL] RETURNS [LongDes] = {    n: CARDINAL = length*width;    new: LONG POINTER = AllocateSegment[n];    FOR i: CARDINAL IN [0..n) DO (new+i)­ ¬ 0 ENDLOOP;    RETURN [DESCRIPTOR[new, length]]};  expand: PUBLIC PROC [des: LongDes, width, ext: CARDINAL] RETURNS [LongDes] = {    new, old: LONG POINTER;    i: CARDINAL;    new ¬ AllocateSegment[(LENGTH[des]+ext)*width];    old ¬ BASE[des];    FOR i IN [0..LENGTH[des]*width) DO (new+i)­ ¬ (old+i)­ ENDLOOP;    FOR i IN [LENGTH[des]*width..(LENGTH[des]+ext)*width) DO (new+i)­ ¬ 0 ENDLOOP;    FreeSegment[old];    RETURN [DESCRIPTOR[new, LENGTH[des]+ext]]};  orcount: PUBLIC CARDINAL ¬ 0;  orbits: PUBLIC PROC [source, sink: LONG POINTER] = {    FOR i: CARDINAL IN [0..PGSConDefs.bitstrsize) DO       (sink+i)­ ¬ Inline.BITOR[(sink+i)­,(source+i)­] ENDLOOP;    orcount ¬ orcount+1};-- streams and files  sourcestr, outstr, errstr: Stream.Handle ¬ NIL;  inputFile, tempFile: MFile.Handle ¬ NIL;  sourceName: PUBLIC LONG STRING ¬ NIL;  sourceVersion: PUBLIC TimeStamp.Stamp ¬ TimeStamp.Null;  objectName: LONG STRING ¬ NIL;  objectVersion: PUBLIC TimeStamp.Stamp ¬ TimeStamp.Null;  defsName: LONG STRING ¬ NIL;  gfName: LONG STRING ¬ NIL;  CreateTime: PROC [s: Stream.Handle] RETURNS [time: Time.Packed] = {    RETURN [MFile.GetTimes[MStream.GetFile[s]].create]};  DefaultFileName: PROC [name, defaultExtension: LONG STRING] = {    FOR i: CARDINAL IN [0..name.length) DO IF name[i] = '. THEN RETURN ENDLOOP;    String.AppendString[name, defaultExtension]};  getstream: PROC [dotstring: LONG STRING] RETURNS [Stream.Handle] = {    fileName: STRING ¬ [40];    String.AppendString[fileName, rootName]; String.AppendString[fileName, dotstring];    RETURN [MStream.WriteOnly[fileName, [], binary]]};  seterrstream: PUBLIC PROC = {    IF errstr =  NIL      THEN { 	outStream ¬ errstr ¬ getstream[".errlog"L];	outstring["Mesa PGS of"L];  outtime[];	outstring[" -- "L]; outstring[rootName]; outstring[".pgslog"L];	outeol[2]}      ELSE outStream ¬ errstr};  closeerrstream: PUBLIC PROC = {    IF errstr # NIL THEN {errstr.Delete[]; errstr ¬ NIL}};  setoutstream: PUBLIC PROC [dotstring: LONG STRING] = {    outStream ¬ outstr ¬ getstream[dotstring]};   resetoutstream: PUBLIC PROC = {outStream ¬ outstr};  cleanupstreams: PUBLIC PROC = {   -- used for checkout    IF outstr # NIL THEN outstr.SendNow[];    IF errstr # NIL THEN errstr.SendNow[]};  closeoutstream: PUBLIC PROC = {    IF outstr # NIL THEN {outstr.Delete[]; outstr ¬ NIL}};  openwordstream: PUBLIC PROC [scratch: BOOLEAN] = {    wFile: MFile.Handle ¬ MFile.ReadWrite[objectName, [], binary];    tempFile ¬ IF scratch THEN wFile       ELSE MFile.CopyFileHandle[wFile, [], readOnly];    outstr ¬ MStream.Create[wFile, []]};  closewordstream: PUBLIC PROC = {    file: MFile.Handle = MFile.CopyFileHandle[MStream.GetFile[outstr], [], anchor];    closeoutstream[];     MFile.SetAccess[file, delete];    MFile.Delete[file]};  outword: PUBLIC PROC [n: CARDINAL] = {outstr.PutWord[n]};  inword: PUBLIC PROC RETURNS [CARDINAL] = {RETURN[outstr.GetWord[]]};  outblock: PUBLIC PROC [address: LONG POINTER, words: CARDINAL] = {    outstr.PutBlock[[address, 0, Environment.bytesPerWord*words]]};  tB: LONG POINTER TO PACKED ARRAY OF CHARACTER ¬ NIL;  preprocess:BOOLEAN ¬ FALSE;  nextbuffer: PUBLIC PROC RETURNS [      p: LONG POINTER TO PACKED ARRAY OF CHARACTER, c: CARDINAL, last: BOOLEAN] = {    OPEN PGSConDefs;    c ¬ sourcestr.GetBlock[[LOOPHOLE[tB], 0, TextChars]].bytesTransferred;    IF preprocess THEN errstr.PutBlock[[LOOPHOLE[tB], 0, c]];    RETURN [tB, c, c<TextChars]};  LocateIndex: PUBLIC PROC [index: CARDINAL] RETURNS [base: CARDINAL] = {    OPEN PGSConDefs;    page: CARDINAL;    page ¬ index/(pagesize*cpw);    base ¬ page*(pagesize*cpw);    sourcestr.SetPosition[sourceOrigin+index]};  StreamIndex: TYPE = LONG CARDINAL;    PrintTextLine: PROC [origin: StreamIndex] RETURNS [start: StreamIndex] = {    lineIndex: StreamIndex;    char: CHARACTER;    n: [1..100];    start ¬ lineIndex ¬ origin;    FOR n IN [1..100] UNTIL lineIndex = 0 DO      lineIndex ¬ lineIndex - 1;      sourcestr.SetPosition[lineIndex];      IF CharIO.GetChar[sourcestr] = Ascii.CR THEN EXIT;      start ¬ lineIndex;      ENDLOOP;    sourcestr.SetPosition[start];    FOR n IN [1..100] DO      char ¬ CharIO.GetChar[sourcestr ! Stream.EndOfStream => EXIT];      SELECT char FROM	Ascii.CR, Ascii.ControlZ => EXIT;	ENDCASE => outchar[char,1];      ENDLOOP;    outeol[1];  RETURN};  sourceOrigin: StreamIndex ¬ 0;  ErrorContext: PUBLIC PROC [message: STRING, tokenIndex: CARDINAL] = {    saveIndex: LONG CARDINAL = sourcestr.GetPosition[];    origin: LONG CARDINAL = sourceOrigin + tokenIndex;    char: CHARACTER;    seterrstream[];    sourcestr.SetPosition[PrintTextLine[origin]];    UNTIL sourcestr.GetPosition[] = origin DO      char ¬ CharIO.GetChar[sourcestr ! Stream.EndOfStream => EXIT];      outchar[IF char = Ascii.TAB THEN Ascii.TAB ELSE ' ,1];      ENDLOOP;    outstring["­ ["L]; outnum[tokenIndex,1];    outchar['],1];  outeol[1];  outstring[message];    sourcestr.SetPosition[saveIndex]};-- processing options  printGrammar: BOOLEAN ¬ TRUE;  bcd: BOOLEAN ¬ FALSE;  pause: BOOLEAN ¬ TRUE;  rootName: LONG STRING ¬ [40];  SetRoot: PROC [s: LONG STRING] = {    rootName.length ¬ 0;    FOR i: CARDINAL IN [0..s.length) DO      IF s[i] = '. THEN EXIT;      String.AppendChar[rootName, s[i]]      ENDLOOP};  SetFileName: PROC [fileName, default, extension: LONG STRING]      RETURNS [LONG STRING] = {    root: LONG STRING = IF fileName = NIL      THEN CommandUtil.CopyString[default, 2+extension.length]      ELSE fileName;    RETURN [CommandUtil.SetExtension[root, extension]]};  TestExtension: PROC [fileName, extension: LONG STRING] RETURNS [BOOLEAN] = {    t: STRING ¬ [40];    i: CARDINAL ¬ 0;    ext: String.SubStringDescriptor ¬ [extension, 0, extension.length];    d: String.SubStringDescriptor;    UNTIL i >= fileName.length OR fileName[i] = '. DO i ¬ i+1 ENDLOOP;    i ¬ i+1;    UNTIL i >= fileName.length OR fileName[i] = '. DO      String.AppendChar[t, fileName[i]]; i ¬ i+1 ENDLOOP;    d ¬ [t, 0, t.length];    RETURN [String.EquivalentSubStrings[@d, @ext]]};  KeyVal: PROC [list: CommandUtil.PairList, key: LONG STRING, delete: BOOLEAN ¬ TRUE]      RETURNS [LONG STRING] = {    s: String.SubStringDescriptor ¬ [base: key, offset: 0, length: key.length];    RETURN [CommandUtil.KeyValue[@s, list, delete]]};  pgsVersion: PUBLIC TimeStamp.Stamp ¬ ImageId[];  GetNetAndHost: PROC RETURNS [net, host: CARDINAL] = {     sum: WORD = Inline.BITXOR[        ProcessorFace.processorID.a,        Inline.BITXOR[ProcessorFace.processorID.b, ProcessorFace.processorID.c]];    net ¬ sum/256;  host ¬ sum MOD 256};  lastTime: LONG CARDINAL ¬ 0;  GenerateUniqueId: PUBLIC PROC RETURNS [TimeStamp.Stamp] = {    net, host: CARDINAL;    time: LONG CARDINAL;    [net, host] ¬ GetNetAndHost[];    DO      time ¬ Time.Current[];      IF lastTime = 0 OR time # lastTime THEN EXIT;      ENDLOOP;    lastTime ¬ time;    RETURN [TimeStamp.Stamp[net: net, host: host, time: time]]};  ImageId: PUBLIC PROC RETURNS [TimeStamp.Stamp] = {    RETURN [TimeStamp.Stamp[0, 0, Runtime.GetBcdTime[]]]};-- * * * * * * HERE IT BEGINS * * * * * *  NoSource: PUBLIC ERROR = CODE;  BadSemantics: PUBLIC ERROR = CODE;  Generate: PUBLIC PROC [	source: LONG STRING,	args, results: CommandUtil.PairList,	switches: LONG STRING,	startPhase: PROC [PGSOps.PGSPhase] RETURNS [BOOLEAN]]      RETURNS [success, warnings: BOOLEAN] = {    scratchExists: BOOLEAN ¬ FALSE;    tableBase: LONG POINTER ¬ NIL;    typeId: STRING = [40];    tableId: STRING = [40];    exportId: STRING = [40];    sourceName ¬ CommandUtil.CopyString[source, 2+("mesa"L).length];    objectName ¬ gfName ¬ NIL;    -- collect output specifications      BEGIN      nR: CARDINAL ¬ CommandUtil.ListLength[results];      IF (defsName ¬ KeyVal[results, "defs"L]) # NIL THEN nR ¬ nR - 1;      SELECT TRUE FROM	(objectName ¬ KeyVal[results, "bcd"L]) # NIL => {bcd ¬ TRUE; nR ¬ nR - 1};	(objectName ¬ KeyVal[results, "binary"L]) # NIL => {bcd ¬ FALSE; nR ¬ nR - 1};	ENDCASE;      IF (gfName ¬ KeyVal[results, "grammar"L]) # NIL THEN nR ¬ nR - 1;      IF nR # 0 THEN GO TO badSemantics;      END;    SetRoot[IF objectName # NIL THEN objectName ELSE sourceName];    IF switches # NIL      THEN {	sense: BOOLEAN ¬ TRUE;	FOR i: CARDINAL IN [0 .. switches.length) DO	  SELECT switches[i] FROM	    '-, '~ => sense ¬ ~sense;	    'g, 'G => {printGrammar ¬ sense; sense ¬ TRUE};	    'p, 'P => {pause ¬ sense; sense ¬ TRUE};	    ENDCASE;	  ENDLOOP};    sourceName ¬ CommandUtil.SetExtension[sourceName, "mesa"L];    sourcestr ¬ MStream.ReadOnly[sourceName, [] ! MStream.Error => GO TO noSource];    startTime ¬ Time.Current[];    tB ¬ Spaces.Pages[PGSConDefs.TextPages];    warningsLogged ¬ warnings ¬ FALSE;    IF sourceName[sourceName.length-1] = '.      THEN sourceName.length ¬ sourceName.length-1;	-- strip '.    IF TestExtension[sourceName, "mesa"L] THEN {      copyName: LONG STRING ¬ CommandUtil.CopyString[sourceName, 1];      [] ¬ startPhase[format];      String.AppendChar[copyName, '$];      errstr ¬ MStream.WriteOnly[copyName, [], text];      copyName ¬ CommandUtil.FreeString[copyName];      tempFile ¬ MFile.ReadWrite["pgs.scratch$"L, [], binary];      outstr ¬ MStream.Create[MFile.CopyFileHandle[tempFile, [], writeOnly], []];      preprocess ¬ scratchExists ¬ TRUE;      outStream ¬ outstr;      tableId.length ¬ typeId.length ¬ exportId.length ¬ 0;      PGSConDefs.Format[tableId, typeId, exportId ! PGSfail => GOTO formatFailed];        -- input to sourceName$ (errstr), modified input to pgs.scratch (outstr),        -- sets up data for PrintGrammar      closeoutstream[]; closeerrstream[]; sourcestr.Delete[];     -- since no rename facility, copy pgs.scratch to sourceName      sourcestr ¬ MStream.Create[MFile.CopyFileHandle[tempFile, [], readOnly], []];      errstr ¬ MStream.WriteOnly[sourceName, [], text];      WHILE ~nextbuffer[].last DO NULL ENDLOOP;      sourceVersion ¬ [0, 0, CreateTime[errstr]];      closeerrstream[]; sourcestr.Delete[];     -- output grammar to summary file (or scratch)      IF printGrammar THEN gfName ¬ SetFileName[	gfName, IF tableId.length # 0 THEN tableId ELSE rootName, "grammar"L];      inputFile ¬ IF printGrammar THEN MFile.ReadWrite[gfName, [], binary]        ELSE tempFile;      outstr ¬ MStream.Create[MFile.CopyFileHandle[inputFile, [], writeOnly], []];      outStream ¬ outstr;      PGSConDefs.PrintGrammar[];      closeoutstream[];     -- connect pgs.scratch to input stream and fix sourceNames      sourcestr ¬ MStream.Create[          IF printGrammar THEN inputFile	  ELSE MFile.CopyFileHandle[inputFile, [], readOnly],	[]];     -- derive missing type id (compatibility feature)      IF typeId.length = 0 AND defsName # NIL THEN	FOR i: CARDINAL IN [0..defsName.length) DO	  IF defsName[i] = '. THEN EXIT;	  String.AppendChar[typeId, defsName[i]];	  ENDLOOP;      IF objectName = NIL THEN {	bcd ¬ TRUE;	IF tableId.length # 0 THEN	  objectName ¬ CommandUtil.CopyString[tableId, 2+("bcd"L).length]	ELSE {	  objectName ¬ CommandUtil.CopyString[rootName, ("PGSTable"L).length];	  String.AppendString[objectName, "PGSTable"L]}}      EXITS	formatFailed => {	  closeoutstream[];  closeerrstream[];	  seterrstream[];	  outeol[1]; outstring["Directives incorrect or out of sequence"L]; outeol[1];	  MFile.SetAccess[tempFile, delete];	  MFile.Delete[tempFile];	  GO TO fail}}    ELSE {      sourceVersion ¬ [0, 0, CreateTime[sourcestr]];      IF objectName = NIL THEN	objectName ¬ CommandUtil.CopyString[rootName, 2+("binary"L).length];    -- derive type name      String.AppendString[typeId, rootName];      String.AppendString[typeId, "PGSTableType"L]};    IF defsName = NIL THEN {      IF typeId.length # 0 THEN	defsName ¬ CommandUtil.CopyString[typeId, 2+("mesa"L).length]      ELSE {	defsName ¬ CommandUtil.CopyString[rootName, ("PGSTableType"L).length];	String.AppendString[defsName,"PGSTableType"L]}};    defsName ¬ CommandUtil.SetExtension[defsName, "mesa"L];    objectName ¬ CommandUtil.SetExtension[objectName,       IF bcd THEN "bcd"L ELSE "binary"L];    preprocess ¬ FALSE;    outstr ¬ errstr ¬ NIL;    sourceOrigin ¬ sourcestr.GetPosition[];-- load table and call first pass here    [] ¬ startPhase[lalr];    objectVersion ¬ GenerateUniqueId[];    tableBase ¬ PGSConDefs.AcquireTable[];    success ¬ PGS1.Parse[tableBase].nErrors = 0;    PGSConDefs.ReleaseTable[];  tableBase ¬ NIL;    Spaces.FreePages[tB];    sourcestr.Delete[];  closeoutstream[];    IF scratchExists      THEN {MFile.SetAccess[tempFile, delete]; MFile.Delete[tempFile]};  -- now if no errors generate the tables then package them on request    IF success AND (flags[lists] OR flags[printlalr] OR flags[printlr]) THEN {      success ¬ PGSConDefs.LALRGen[ ! PGSfail => {success ¬ FALSE; CONTINUE}];      IF success AND flags[lists] THEN {	InitBcd: PROC = {	  self: String.SubStringDescriptor ¬ ["SELF"L, 0, ("SELF"L).length];	  export: String.SubStringDescriptor ¬ [exportId, 0, exportId.length];	  PGSConDefs.WriteBcdHeader[	    outStream: outstr,	    tableId: tableId,	    binaryId: objectName,	    sourceId: sourceName,	    interfaceId: IF String.EqualSubStrings[@export,@self] THEN NIL ELSE exportId,	    fileId: KeyVal[args, exportId, FALSE]]};	BEGIN	file: MFile.Handle = MFile.CopyFileHandle[tempFile, [], anchor];        closeoutstream[];    -- flush output from LALRGen	MFile.SetAccess[file, readOnly];        outstr ¬ MStream.Create[file, []];  -- for reinput	END;        success ¬ IF exportId.length # 0		THEN PGSConDefs.TabGen[prefix:InitBcd, suffix:PGSConDefs.FixupBcdHeader]		ELSE PGSConDefs.TabGen[NIL, NIL];        IF ~success THEN closewordstream[]        ELSE {	  closeoutstream[]; -- flush tabgen output	  outstr ¬ MStream.WriteOnly[defsName, [], text];	  outStream ¬ outstr;	  PGSConDefs.OutModule[typeId, defsName, TRUE];	  closeoutstream[]}}};    closeerrstream[];    warnings ¬ warningsLogged;  sourceName ¬ CommandUtil.FreeString[sourceName];    EXITS      badSemantics => ERROR BadSemantics;      noSource => ERROR NoSource;      fail => {	sourceName ¬ CommandUtil.FreeString[sourceName];	closeerrstream[]; success ¬ FALSE}};  }.
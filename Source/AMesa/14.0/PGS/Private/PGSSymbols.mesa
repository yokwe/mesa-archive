-- Copyright (C) 1981, 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- PGSSymbols.mesa--   JGS		 4-Nov-82 11:28:17--   EXS          	 March 16, 1981  2:29 PM--   BTL  		29-Oct-81 18:57:14--   RXJ     		 6-Jul-83 18:27:58DIRECTORY  Alloc USING [defaultIndexBits,    AddNotify, Bounds, Chunkify, Create, defaultChunkType, Handle, Notifier,    Reset, TableInfo, Words],  Environment: TYPE USING [bytesPerWord],  Heap: TYPE USING [systemZone],  PGSConDefs: TYPE USING [objectVersion, pgsVersion, sourceVersion],  Stream: TYPE USING [Handle, PutBlock],  String: TYPE USING [SubStringDescriptor],  Symbols: TYPE USING [    DummyLink, HashVector, SERecord, BodyRecord, StandardContext,    SEIndex, ISEIndex, CSEIndex, RecordSEIndex, CTXIndex, CBTIndex,    ISENull, CSENull, RecordSENull, CTXNull, BTNull, lG, lZ],  SymbolSegment: TYPE USING [    htType, ssType, ctxType, seType, mdType, bodyType, VersionID, STHeader,     Tables, WordOffset],  SymbolTable: TYPE USING [Handle],  SymbolOps: TYPE USING [FromLink, FromBti,    Create, Finalize, EnterString, HashBlock, MakeCtxSe, NewCtx, MakeNonCtxSe],  Table USING [Base, Selector],  TreeOps: TYPE USING [Map];PGSSymbols: PROGRAM    IMPORTS Alloc, Heap, PGSConDefs, Stream, SymbolOps    EXPORTS PGSConDefs, TreeOps = {  OPEN Symbols;  seb: Table.Base;	-- semantic entry base (local copy)  ctxb: Table.Base;	-- context table base  (local copy)  bb: Table.Base;       -- body table base     (local copy)  Notify: Alloc.Notifier = {    OPEN SymbolSegment;    seb ¬ base[seType]; ctxb ¬ base[ctxType]; bb ¬ base[bodyType]};  dirCtx: CTXIndex ¬ CTXNull;  EnterModule: PROC [moduleId: LONG STRING, bodyCtx: CTXIndex] = {     tSei: CSEIndex ¬ CSENull;    sei: ISEIndex ¬ ISENull;    bti: CBTIndex ¬ LOOPHOLE[0];   -- generate a program type    tSei ¬ SymbolOps.MakeNonCtxSe[ownSymbols, SIZE[transfer cons SERecord]];    seb[tSei] ¬ SERecord[	mark3: TRUE, mark4: TRUE,	body: cons[transfer[		mode: program, typeIn: CSENull, typeOut: CSENull, safe: FALSE]]];   -- generate an id    sei ¬ MakeConstant[moduleId, dirCtx, tSei];    seb[sei].public ¬ TRUE;    seb[sei].idValue ¬ SymbolOps.FromLink[Symbols.DummyLink[gfi: 1, ep: 0]];    bti ¬ ownTable.Words[SymbolSegment.bodyType, SIZE[Outer Callable BodyRecord]];    bb[bti] ¬ BodyRecord[	link: [parent, BTNull], firstSon: BTNull,	localCtx: CTXNull, type: RecordSENull, level: lG,	sourceIndex: 0,	info: [External[0, 0, 0]],        extension: Callable[	  inline: FALSE, id: ISENull, ioType: CSENull,	  monitored: FALSE, noXfers: FALSE, resident: FALSE,	  entry: FALSE, internal: FALSE, entryIndex: 0, 	  hints: [FALSE, FALSE, FALSE, FALSE],	  closure: Outer[]]];    bb[bti].id ¬ sei;  bb[bti].ioType ¬ tSei;  bb[bti].localCtx ¬ bodyCtx;    seb[sei].idInfo ¬ SymbolOps.FromBti[bti]};  SubStringDescriptor: TYPE = String.SubStringDescriptor;  MakeConstant: PROC [name: LONG STRING, ctx: CTXIndex, type: SEIndex]      RETURNS [sei: ISEIndex] = {    -- makes an se entry for a built-in constant    desc: SubStringDescriptor ¬ [base:name, offset:0, length:name.length];    sei ¬ SymbolOps.MakeCtxSe[ownSymbols, SymbolOps.EnterString[ownSymbols, @desc], ctx];    seb[sei].idType ¬ type;    seb[sei].immutable ¬ seb[sei].constant ¬ TRUE;    seb[sei].extended ¬ seb[sei].public ¬ seb[sei].linkSpace ¬ FALSE;    seb[sei].mark3 ¬ seb[sei].mark4 ¬ TRUE;    RETURN};  CreateSymbols: PROC [moduleId: LONG STRING] = {    ctx: CTXIndex ¬ CTXNull;    WHILE (ctx ¬ SymbolOps.NewCtx[ownSymbols, lZ]) IN StandardContext DO NULL ENDLOOP;    dirCtx ¬ ctx;    EnterModule[moduleId, SymbolOps.NewCtx[ownSymbols, lG]]};  EnterHashMark: PROC = {    -- marks end of symbols from source file in hash table    desc: SubStringDescriptor ¬ [base:"  "L, offset:1, length:0];    [] ¬ SymbolOps.EnterString[ownSymbols, @desc]};  ownTable: Alloc.Handle ¬ NIL;  symbolPackStarted: BOOLEAN ¬ FALSE;  ownSymbols: SymbolTable.Handle;  WriteSymbols: PUBLIC PROC [s: Stream.Handle, moduleId: LONG STRING] = {    Initialize[];    CreateSymbols[moduleId];    EnterHashMark[];    TableOut[s];    FinalizeStuff[]};  Initialize: PROC = {    nullInfo: Alloc.TableInfo = [Alloc.defaultIndexBits, 1, 1];    info: Alloc.TableInfo = [Alloc.defaultIndexBits, 5, 5];    weights: ARRAY SymbolSegment.Tables OF Alloc.TableInfo ¬        [nullInfo, info, info, info, info, info, info,         nullInfo, nullInfo, nullInfo, nullInfo, nullInfo, nullInfo];    IF ~symbolPackStarted THEN {--START SymbolPack;-- symbolPackStarted ¬ TRUE};    IF ownTable = NIL THEN {      ownTable ¬ Alloc.Create[DESCRIPTOR[weights]];      ownTable.Chunkify[Alloc.defaultChunkType]}    ELSE Alloc.Reset[ownTable];     ownTable.AddNotify[Notify, NIL];    ownSymbols ¬ SymbolOps.Create[ownTable, Heap.systemZone]};  FinalizeStuff: PROC = {    SymbolOps.Finalize[ownSymbols];    ownTable.Reset[]};  TableOut: PROC [s: Stream.Handle] = {    OPEN SymbolSegment;    header: STHeader;    d: WordOffset ¬ 0;    WriteSubTable: PROC [table: Table.Selector] = {      base: Table.Base;      size: CARDINAL ¬ 0;      [base, size] ¬ ownTable.Bounds[table];      [] ¬ s.PutBlock[[LOOPHOLE[base], 0, size*Environment.bytesPerWord]]};      BEGIN      OPEN header;      versionIdent ¬ SymbolSegment.VersionID;      version ¬ LOOPHOLE[PGSConDefs.objectVersion];	-- for bootstrap      sourceVersion ¬ LOOPHOLE[PGSConDefs.sourceVersion];      creator ¬ LOOPHOLE[PGSConDefs.pgsVersion];      definitionsFile ¬ FALSE;      directoryCtx ¬ dirCtx;      importCtx ¬  outerCtx ¬ CTXNull;      d ¬ SIZE[STHeader];      hvBlock.offset ¬ d;	d ¬ d + (hvBlock.size ¬ SIZE[Symbols.HashVector]);      htBlock.offset ¬ d;  d ¬ d + (htBlock.size ¬ ownTable.Bounds[htType].size);      ssBlock.offset ¬ d;  d ¬ d + (ssBlock.size ¬ ownTable.Bounds[ssType].size);      seBlock.offset ¬ d;  d ¬ d + (seBlock.size ¬ ownTable.Bounds[seType].size);      ctxBlock.offset ¬ d;	d ¬ d + (ctxBlock.size ¬ ownTable.Bounds[ctxType].size);        mdBlock.offset ¬ d;  d ¬ d + (mdBlock.size ¬ ownTable.Bounds[mdType].size);      bodyBlock.offset ¬ d;	d ¬ d + (bodyBlock.size ¬ ownTable.Bounds[bodyType].size);      treeBlock ¬ litBlock ¬ sLitBlock ¬ extBlock ¬ [d, 0];      constBlock ¬ [0, 0];      fgRelPgBase ¬ fgPgCount ¬ 0;      END;    [] ¬ s.PutBlock[      [LOOPHOLE[LONG[@header]], 0, Environment.bytesPerWord*SIZE[STHeader]]];    [] ¬ s.PutBlock[[      blockPointer: LOOPHOLE[SymbolOps.HashBlock[ownSymbols]],      startIndex: 0,      stopIndexPlusOne: Environment.bytesPerWord*header.hvBlock.size]];    WriteSubTable[htType];    WriteSubTable[ssType];    WriteSubTable[seType];    WriteSubTable[ctxType];    WriteSubTable[mdType];    WriteSubTable[bodyType]};      IdentityMap: PUBLIC TreeOps.Map = {RETURN[t]};  }.
-- Copyright (C) 1981, 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- TableControl.Mesa--   Loretta		 2-Sep-81 16:08:08--   Satterthwaite	23-Mar-81 16:23:59--   Bruce		 2-Dec-82 18:10:51--   Johnsson		 8-Jul-83 15:33:36--   Daniels		23-Apr-84 16:00:36--   Wagner		10-Jan-85 10:18:06DIRECTORY  Ascii: TYPE USING [CR, NUL, SP],  BcdDefs: TYPE USING [VersionStamp],  CharIO: TYPE USING [PutChar, PutString],  Exec: TYPE USING [AddCommand, ExecProc, GetChar, Handle, PutChar],  Inline: TYPE USING [BITXOR],  ProcessorFace: TYPE USING [processorID],  Runtime USING [GetBcdTime],  MFile: TYPE USING [Error, GetTimes, NameForError],  MStream: TYPE USING [Error, GetFile, WriteOnly],  Stream: TYPE USING [Handle, Delete],  String: TYPE USING [AppendChar, AppendDecimal, AppendString, EquivalentString],  TableCommand: TYPE USING [BadInterface, CompileStrings, MakeModule],  Time: TYPE USING [Append, Current, Unpack],  TimeStamp: TYPE USING [Stamp],  Version: TYPE USING [Append];TableControl: PROGRAM    IMPORTS      CharIO, Exec, Inline, ProcessorFace, Runtime, MFile, MStream, Stream, String,      TableCommand, Time, Version    EXPORTS TableCommand = {  CR: CHARACTER = Ascii.CR; -- cursor control  GetNetAndHost: PROC RETURNS [net, host: CARDINAL] = {     sum: WORD = Inline.BITXOR[        ProcessorFace.processorID.a,        Inline.BITXOR[ProcessorFace.processorID.b, ProcessorFace.processorID.c]];    net ¬ sum/256;  host ¬ sum MOD 256};  lastTime: LONG CARDINAL ¬ 0;  GenerateUniqueId: PUBLIC PROC RETURNS [TimeStamp.Stamp] = {    net, host: CARDINAL;    time: LONG CARDINAL;    [net, host] ¬ GetNetAndHost[];    DO      time ¬ Time.Current[];      IF lastTime = 0 OR time # lastTime THEN EXIT;      ENDLOOP;    lastTime ¬ time;    RETURN [TimeStamp.Stamp[net: net, host: host, time: time]]}; -- command gathering and logging  log: Stream.Handle ¬ NIL;   exec: Exec.Handle;    LogChar: PROC [c: CHARACTER] = {    IF log # NIL THEN CharIO.PutChar[log, c];    Exec.PutChar[exec, c]};      LogString: PROC [s: LONG STRING] = {    IF log # NIL THEN CharIO.PutString[log, s];    FOR i: CARDINAL IN [0..s.length) DO Exec.PutChar[exec, s[i]] ENDLOOP};   LogDecimal: PROC [n: INTEGER] = {    s: STRING = [10];    String.AppendDecimal[s, n];  LogString[s]};          Rubout: ERROR = CODE;    CommandChar: PROC RETURNS [char: CHARACTER] = {RETURN[Exec.GetChar[exec]]};       ReadCommand: PROC [name, switches: LONG STRING] RETURNS [BOOLEAN] = {    input: STRING ¬ [80];    i: CARDINAL;    c: CHARACTER;    activeString: LONG STRING ¬ name;    DO      c ¬ CommandChar[];      SELECT c FROM        Ascii.NUL => EXIT;        Ascii.SP => IF input.length # 0 THEN EXIT;        CR => EXIT;        ENDCASE => String.AppendChar[input, c];      ENDLOOP;    i ¬ name.length ¬ switches.length ¬ 0;    WHILE i < input.length AND input[i] = Ascii.SP DO i ¬ i+1  ENDLOOP;    --parse command--    FOR i IN [i..input.length) DO      SELECT (c¬input[i]) FROM        '/ => activeString ¬ switches;        Ascii.SP, CR => EXIT;        ENDCASE => String.AppendChar[activeString,c];      ENDLOOP;    FOR i IN [0..switches.length) DO -- convert all to lower case      IF (c¬switches[i]) IN ['A..'Z] THEN switches[i] ¬ c + ('a-'A);      ENDLOOP;    RETURN [name.length # 0 OR switches.length # 0]};    DefaultFileName: PROC [name, defaultExtension: LONG STRING] = {    FOR i: CARDINAL IN [0..name.length) DO IF name[i] = '. THEN RETURN ENDLOOP;    String.AppendString[name, defaultExtension]};  ExtensionIs: PROC [name, ext: LONG STRING] RETURNS [BOOLEAN] = {    t: STRING ¬ [40];    IF name.length <= ext.length THEN RETURN[FALSE];    FOR i: CARDINAL IN [name.length-ext.length .. name.length) DO      String.AppendChar[t,name[i]]  ENDLOOP;    RETURN [String.EquivalentString[t,ext]]};  CreateTime: PUBLIC PROC [s: Stream.Handle] RETURNS [time: LONG INTEGER] = {    RETURN [MFile.GetTimes[MStream.GetFile[s]].create]};  MyBcdVersion: PUBLIC PROC RETURNS [version: BcdDefs.VersionStamp] = {    RETURN [[0, 0, Runtime.GetBcdTime[]]]};  GenerateVersion: PUBLIC PROC RETURNS [version: BcdDefs.VersionStamp] = {     RETURN [GenerateUniqueId[]]};  WriteHerald: PROC = {    t: STRING ¬ [20];    LogString["Mesa TableCompiler "L];    Version.Append[t];    LogString[t];    LogString[" of "L];    t.length ¬ 0;    Time.Append[t, Time.Unpack[Runtime.GetBcdTime[]]];    t.length ¬ t.length - 3;    LogString[t]; LogChar[CR];    t.length ¬ 0;    Time.Append[t, Time.Unpack[Time.Current[]]];    t.length ¬ t.length - 3;    LogString["TableCompiler.log"]; LogString[" -- "L];    LogString[t];  LogChar[CR]};  Main: Exec.ExecProc = {  input: {strings, binary};		-- compiling strings  compact: BOOLEAN;    sourceName: STRING ¬ [40];  rootName: STRING ¬ [40];  interfaceName: STRING ¬ [40];  formatName: STRING ¬ [40];  bcdName: STRING ¬ [40];  GetCommand: PROC = {    file: STRING ¬ [40];    sw: STRING ¬ [10];    i: CARDINAL;    c: CHARACTER;    done: BOOLEAN ¬ FALSE;    sense: BOOLEAN;    GetSwitch: PROC RETURNS [c: CHARACTER] = {      sense ¬ TRUE;      WHILE i < sw.length DO        c ¬ sw[i];  i ¬ i + 1;        IF c = '- OR c = '~ THEN sense ¬ ~sense ELSE EXIT;        ENDLOOP;      RETURN};    sourceName.length ¬ bcdName.length ¬ interfaceName.length ¬ formatName.length ¬ 0;    file.length ¬ 0;    IF ~ReadCommand[file, sw] OR file.length = 0 THEN RETURN;    DefaultFileName[file, ".mesa"L];    IF ExtensionIs[file, ".mesa"L]      THEN {input ¬ strings; compact ¬ TRUE}      ELSE input ¬ binary;     i ¬ 0;    WHILE i < sw.length DO      SELECT (c¬GetSwitch[]) FROM        'c => compact ¬ sense;        'm => input ¬ binary;        's => {input ¬ strings; compact ¬ FALSE};        't => {input ¬ strings; compact ¬ TRUE};        'g => done ¬ TRUE;	ENDCASE => GO TO barf;      REPEAT	barf => ERROR Rubout;      ENDLOOP;    String.AppendString[sourceName, file];    WHILE ~done AND ReadCommand[file, sw] DO      i ¬ 0;      WHILE i < sw.length DO        SELECT (c¬GetSwitch[]) FROM          'f => {            DefaultFileName[file, ".format"L];            formatName.length ¬ 0; String.AppendString[formatName, file]};          'i => {            DefaultFileName[file, ".bcd"L];            interfaceName.length ¬ 0; String.AppendString[interfaceName, file]};          'o => {            DefaultFileName[file, ".bcd"L];            bcdName.length ¬ 0; String.AppendString[bcdName, file]};          'g => done ¬ TRUE;          ENDCASE => ERROR Rubout;        ENDLOOP;      ENDLOOP};  LogCommand: PROC = {    LogChar[CR];    SELECT input FROM      strings => {        LogString["Compiling "L]; LogString[sourceName];        LogString[", exporting "L]; LogString[rootName];        LogString[" to "L]; LogString[interfaceName];	IF bcdName.length # 0	  THEN {LogString[", BCD to "L]; LogString[bcdName]};	LogChar[CR];	LogString["Record format on "L]; LogString[formatName]};      binary => {        LogString["Processing "L]; LogString[sourceName];        LogString[", exporting "L]; LogString[rootName];        LogString[" to "L]; LogString[interfaceName];	IF bcdName.length # 0	  THEN {LogString[", BCD to "L]; LogString[bcdName]}};      ENDCASE;    LogChar[CR]};   -- initialization    exec ¬ h;    log ¬ MStream.WriteOnly["TableCompiler.log"L, [], text];    WriteHerald[];   -- main loop    DO      BEGIN      ENABLE {        UNWIND => IF log # NIL THEN log.Delete[];	MFile.Error => {	  SELECT TRUE FROM	    code = noRoomOnVolume => LogString["!Disk full "L];	    file = NIL => {	      fileName: LONG STRING = (SIGNAL MFile.NameForError);	      LogString["!Can't find file "L]; LogString[fileName]};	    ENDCASE => LogString["!Unexpected file error "L];	  GO TO FileFault};	MStream.Error => {	  LogString["!Unexpected file error "L];	  GO TO FileFault};	TableCommand.BadInterface => {	  LogString["!Error in interface (Hint: check capitalization) "L];	  GO TO FileFault}};      GetCommand[ ! Rubout => GOTO Abort];      IF sourceName.length = 0 THEN EXIT;      rootName.length ¬ 0;      FOR i: CARDINAL IN [0..sourceName.length) DO	IF sourceName[i] = '. THEN EXIT;	String.AppendChar[rootName, sourceName[i]];	ENDLOOP;      IF interfaceName.length = 0	THEN String.AppendString[interfaceName, "SELF"L];      IF formatName.length = 0	THEN {	  String.AppendString[formatName, rootName];	  String.AppendString[formatName, "Format."L]};      LogCommand[];      IF bcdName.length = 0	THEN {	  String.AppendString[bcdName, rootName];	  String.AppendString[bcdName, ".bcd"L]};      SELECT input FROM	strings => {          nChars, nStrings: CARDINAL;	  [nStrings, nChars] ¬ TableCommand.CompileStrings[	    inputFile: sourceName,	    interfaceId: interfaceName,	    formatId: formatName,	    moduleId: bcdName,	    compact: compact];	  LogString["Strings: "L];  LogDecimal[nStrings];	  LogString[", characters: "L];  LogDecimal[nChars];	  LogChar[CR]};	binary =>          TableCommand.MakeModule[	    inputFile: sourceName,	    interfaceId: interfaceName,	    moduleId: bcdName];	ENDCASE;      LogChar[CR];      EXITS	FileFault => outcome ¬ error;	Abort => {outcome ¬ error; LogChar['?]};      END;      ENDLOOP;    IF log # NIL THEN log.Delete[]};  Exec.AddCommand["TableCompiler.~"L, Main];    }...
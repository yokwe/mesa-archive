-- Copyright (C) 1981, 1982, 1984  by Xerox Corporation. All rights reserved. -- file PGSInterface.Mesa-- last modified by Loretta,  2-Sep-81 17:07:49-- last modified by Satterthwaite, 25-Mar-81 12:21:35-- last modified by JGS,  4-Nov-82 12:28:01-- last modified by Sweet, 17-Dec-81 12:55:21DIRECTORY  CharIO: TYPE USING [CR, PutChar, PutString],  CommandUtil: TYPE USING [    Create, PairList, Destroy, Echo, Failed, FreePairList, FreeString, Parse, CommandPtr],  Exec: TYPE USING [AddCommand, ExecProc, Handle, GetChar, OutputProc, PutChar],  Format USING [StringProc],  MStream: TYPE USING [WriteOnly],  PGSConDefs: TYPE USING [],  PGSOps: TYPE USING [PGSPhase, Generate, NoSource, BadSemantics],  PGSParseData: TYPE,  Runtime USING [GetBcdTime, GetTableBase],  Stream: TYPE USING [Handle, Delete],  String: TYPE USING [AppendString],  Time: TYPE USING [Append, Unpack],  Version USING [Append];PGSInterface: PROGRAM    IMPORTS      CharIO, CommandUtil, Exec, MStream, PGSOps, PGSParseData,      Runtime, Stream, String, Time, Version    EXPORTS PGSConDefs = { -- command interface  exec: Exec.Handle ¬ NIL;    log: Stream.Handle ¬ NIL;  commandStream: Stream.Handle ¬ NIL;  CR: CHARACTER = CharIO.CR;  LogChar: PROC [c: CHARACTER] = {    IF log # NIL THEN CharIO.PutChar[log, c];    Exec.PutChar[exec, c]};      LogString: PROC [s: LONG STRING] = {    IF log # NIL THEN CharIO.PutString[log, s];    FOR i: CARDINAL IN [0..s.length) DO Exec.PutChar[exec, s[i]] ENDLOOP};    -- parse table management  tableSeg: LONG POINTER = Runtime.GetTableBase[LOOPHOLE[PGSParseData]];  AcquireTable: PUBLIC PROC RETURNS [LONG POINTER] = {    RETURN [tableSeg]};  ReleaseTable: PUBLIC PROC = {}; -- cursor management  StartPhase: PROC [phase: PGSOps.PGSPhase] RETURNS [goOn: BOOLEAN ¬ TRUE] = {    SELECT phase FROM      format => ExecOut[" formatting..."L];      lalr => ExecOut[" lalr processing..."L];      ENDCASE};      -- * * * * * * HERE IT BEGINS * * * * * *    ExecOut: Format.StringProc ¬ NIL;  Main: Exec.ExecProc = {    cmdPtr: CommandUtil.CommandPtr ¬ NIL;    source: LONG STRING ¬ NIL;    args, results: CommandUtil.PairList;    switches: LONG STRING ¬ NIL;    ok, warnings: BOOLEAN ¬ FALSE;    herald: STRING ¬ [50];    LogOut: Format.StringProc = {LogString[s]};    Cleanup: PROC = {      CommandUtil.Destroy[cmdPtr];      [] ¬ CommandUtil.FreeString[source];      [] ¬ CommandUtil.FreePairList[args];      [] ¬ CommandUtil.FreePairList[results];      [] ¬ CommandUtil.FreeString[switches]};    get: PROCEDURE RETURNS [CHARACTER] = {RETURN[Exec.GetChar[h]]};        exec ¬ h;    ExecOut ¬ Exec.OutputProc[h];        String.AppendString[to:herald, from:"Mesa "];    Version.Append[herald];    String.AppendString[to:herald, from:" PGS of "L];    Time.Append[herald, Time.Unpack[Runtime.GetBcdTime[]]];    herald.length ¬ herald.length - 3;      log ¬ MStream.WriteOnly["pgs.log"L, [], text];    LogString[herald]; LogChar[CR];        cmdPtr ¬ CommandUtil.Create[get];   -- set up command stream    BEGIN ENABLE UNWIND => Cleanup[];    [source, args, results, switches] ¬ CommandUtil.Parse[        cmd: cmdPtr, opX: 0, resultX: 2 + ("mesa"L).length !        CommandUtil.Failed => GO TO badSyntax];    IF source = NIL THEN GO TO noOp;    LogChar[CR]; LogString["Command: "L];    CommandUtil.Echo[LogOut, source, args, results, switches];    [ok, warnings] ¬ PGSOps.Generate[source, args, results, switches, StartPhase       ! PGSOps.NoSource => GO TO noSource;         PGSOps.BadSemantics => GO TO badSemantics];    LogChar[CR]; LogString["    "L];        SELECT TRUE FROM      ~ok => {LogString["Errors logged, bad output"L]; outcome ¬ error};      warnings => {LogString["Warnings logged"L]; outcome ¬ warning};      ENDCASE => {LogString["Completed successfully"L]; outcome ¬ normal};    EXITS      noOp => outcome ¬ normal;      noSource => {LogString[" -- Cannot be opened"L]; outcome ¬ error};      badSyntax => {LogString["Unparsable command"L]; outcome ¬ error};      badSemantics => {LogString[" -- Illegal command"L]; outcome ¬ error};    END;    Cleanup[];        LogChar[CR]; LogChar[CR]; log.Delete[];  log ¬ NIL;    ExecOut["done"L]};    Exec.AddCommand["PGS.~"L, Main];    }.
-- Copyright (C) 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- file TableSymbols.mesa-- last edited by Satterthwaite, March 5, 1981  9:11 AM-- last edited by JGS,  4-Nov-82 11:49:08-- last edited by Sweet, 25-Aug-83 17:01:53-- last edited by Saaranzin 25-Aug-83 16:39:30-- last edited by Wagner, 23-Oct-84 15:24:30DIRECTORY  BcdDefs: TYPE,  BcdOps: TYPE USING [BcdBase, MTHandle],  MFile: TYPE USING [Handle, ReadOnly, Error],  MSegment: TYPE USING [Handle, Create, Delete, Address, Reset],  String: TYPE USING [SubStringDescriptor, AppendString],  SymbolOps,  Symbols: TYPE,  SymbolTable: TYPE USING [Handle, Acquire, Release],  Table: TYPE USING [Base],  TableCommand: TYPE;TableSymbols: PROGRAM    IMPORTS MFile, MSegment, String, SymbolTable, SymbolOps    EXPORTS TableCommand, SymbolTable = {  SymSegHandle: PUBLIC TYPE = MSegment.Handle;  -- for SymbolTable, so can call Acquire  -- public interface  BadInterface: PUBLIC ERROR [LONG STRING] = CODE;  AltoBias: CARDINAL = 1;  FindInterface: PUBLIC PROC [id, file: LONG STRING] RETURNS [    version: BcdDefs.VersionStamp, symbolSeg: SymSegHandle ¬ NIL] = {    bcdFile: MFile.Handle ¬ NIL;    bcd: BcdOps.BcdBase;    mtRoot: BcdOps.MTHandle;    sgBase: Table.Base;    sSeg: BcdDefs.SGIndex;    s: STRING ¬ [40];    String.AppendString[s, IF file = NIL THEN id ELSE file];    FOR i: CARDINAL DECREASING IN [0 .. s.length) DO      IF s[i] = '. THEN EXIT;      REPEAT	FINISHED => String.AppendString[s, ".bcd"L];      ENDLOOP;    bcdFile ¬ MFile.ReadOnly[s, [] ! MFile.Error => ERROR BadInterface[s]];    symbolSeg ¬      MSegment.Create[file: bcdFile, release: [], fileBase: 0, pages: 10];    bcd ¬ MSegment.Address[symbolSeg];    version ¬ bcd.version;    mtRoot ¬ LOOPHOLE[bcd + bcd.mtOffset];    sgBase ¬ LOOPHOLE[bcd + bcd.sgOffset];  sSeg ¬ mtRoot.sseg;    IF bcd.versionIdent # BcdDefs.VersionID OR bcd.nConfigs # 0      OR bcd.nModules # 1 OR bcd.nPages > 10 OR mtRoot.sseg = BcdDefs.SGNull      OR sgBase[mtRoot.sseg].pages = 0 OR sgBase[mtRoot.sseg].file # BcdDefs.FTSelf      THEN ERROR BadInterface[s ! UNWIND => {MSegment.Delete[symbolSeg]; symbolSeg ¬ NIL}];    MSegment.Reset[      segment: symbolSeg, fileBase: sgBase[sSeg].base - AltoBias, pages: sgBase[sSeg].pages];    IF ~CheckId[symbolSeg, id] THEN      ERROR BadInterface[id ! UNWIND => {MSegment.Delete[symbolSeg]; symbolSeg ¬ NIL}];    RETURN};  CheckId: PROC [symbolSeg: MSegment.Handle, id: LONG STRING]      RETURNS [found: BOOLEAN] = {    base: SymbolTable.Handle ¬ SymbolTable.Acquire[symbolSeg];      BEGIN      OPEN Symbols;      ss: String.SubStringDescriptor ¬ [base:id, offset:0, length:id.length];      sei: ISEIndex = SymbolOps.SearchContext[base, SymbolOps.FindString[base, @ss], base.stHandle.directoryCtx];      found ¬ sei # ISENull AND base.seb[sei].public;      END;    SymbolTable.Release[base];    RETURN};  FindItem: PUBLIC PROC [symbolSeg: MSegment.Handle, item: LONG STRING]      RETURNS [size, entry: CARDINAL] = {    base: SymbolTable.Handle ¬ SymbolTable.Acquire[symbolSeg];      BEGIN      OPEN Symbols;      itemSei: ISEIndex ¬ ISENull;      ss: String.SubStringDescriptor ¬ [base:item, offset:0, length:item.length];      hti: HTIndex = SymbolOps.FindString[base, @ss];      IF hti = HTNull THEN GO TO fail;      size ¬ 0;      FOR sei: ISEIndex ¬ SymbolOps.FirstCtxSe[base, base.stHandle.outerCtx], SymbolOps.NextSe[base, sei] UNTIL sei = ISENull DO	IF SymbolOps.LinkMode[base, sei] # manifest	  THEN {size ¬ size + 1; IF base.seb[sei].hash = hti THEN itemSei ¬ sei};	ENDLOOP;      IF itemSei = ISENull THEN GO TO fail;      entry ¬ SymbolOps.ToCard[base.seb[itemSei].idValue];      EXITS	fail => ERROR BadInterface[item];      END;    SymbolTable.Release[base];    RETURN};  }.
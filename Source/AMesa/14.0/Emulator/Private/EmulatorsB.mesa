-- EmulatorsB.mesa-- Last Edit:-- BGY	20-Aug-85 16:58:15-- DXW	22-May-84 17:26:26-- Copyright (C) Xerox Corporation 1983, 1984, 1985. All rights reserved.DIRECTORY  Ascii USING [NUL],  Display USING [    BitBltFlags, Bitmap, Black, Character, replaceFlags,     Shift, Text, textFlags, White],  Emulator USING [Error],  EmulatorOps USING [     ActOnCaret, AttrBooleans, AttributeList, AttributeType, Blank,      BotIndex, ColumnIndex, EContext, FindContext, FontArray,      FontType, ForceOutFinished, ForceOutStart, GetPlace,      GetRealPlace, InternalBackTab, InternalClear,      InternalClearLine, InternalClearToBOL, InternalClearToBOS,      InternalClearToEOL, InternalClearToEOS, InternalCR,      InternalDown, InternalGotoXY, InternalLeft, InternalRight,      InternalTab, InternalUp, LineIndex, lock, nullTabs, ParamCnt,      ReleaseContext, TopIndex, zone],  Format USING [Number, StringProc],  Inline USING [LongCOPY],  Selection USING [ActOn],  StateDefs USING [Handle, State],  Stream USING [Handle, PutString],  ToolWindow USING [DisplayProcType],  UserInput USING [StringProcType, StuffCharacter, StuffString],  UserTerminal USING [Beep, SetBackground],  Window USING [Box, EnumerateInvalidBoxes, Handle, Place],  WindowFont USING [Handle];EmulatorsB: MONITOR LOCKS EmulatorOps.lock  IMPORTS     Display, Emulator, EmulatorOps, Format,    Inline, Selection, Stream, UserInput, UserTerminal, Window  EXPORTS Emulator, EmulatorOps =  BEGIN      CursorBits: TYPE = ARRAY[0..16) OF WORD;  CursorPtr: TYPE = LONG POINTER TO CursorBits;  flipper1, flipper2, LEDOn, LEDOff: CursorPtr ¬ NIL;    header: LONG STRING = "DATA   ONLINE LOCAL   L1     L2     L3     L4";  LEDType: TYPE = {data, online, local, l1, l2, l3, l4};  headerOffset: CARDINAL = 3;  cursorOffset: CARDINAL = headerOffset + 2;  nCursors: CARDINAL = 7;  cursorWidth: CARDINAL = 7;      PlaceToY: PROC[c: EmulatorOps.EContext, place: CARDINAL]     RETURNS [y: CARDINAL] = INLINE {    y ¬ (place) / c.fonts[normal].height;    y ¬ MIN[y, c.lines-1];    };    PutChar: PUBLIC PROC [sw:Window.Handle, c:CHARACTER] = {    temp: LONG STRING ¬ [1];    temp.length ¬ 1; temp.text[0] ¬ c;    TypeInProc[window: sw, string: temp]};      PutString: PUBLIC PROC [sw:Window.Handle,s:LONG STRING] = {    TypeInProc[window: sw, string: s]};      TypeInProc: PUBLIC UserInput.StringProcType = {    i: CARDINAL ¬ 0;    c: EmulatorOps.EContext ¬ EmulatorOps.FindContext[window];    eat, tempState: CARDINAL;    IF c = NIL THEN Emulator.Error[notAEmuSW];    BEGIN ENABLE UNWIND => EmulatorOps.ReleaseContext[window];    IF c.data = NIL THEN Emulator.Error[badData];    IF c.ownSelect THEN Selection.ActOn[clear];    EmulatorOps.ActOnCaret[c, clear];    IF c.writeToLog THEN Stream.PutString[c.logfile, string];    c.flipper ¬ ~c.flipper;    PaintCursor[c, GetCursorPlace[c,data],       IF c.flipper THEN flipper1 ELSE flipper2];    WHILE i < string.length DO      tempState ¬ GetNextState[c.data, c.curState, string[i]];      eat ¬ ExecuteState[c, c.data.state[tempState], string[i]];      i ¬ i + eat;      c.curState ¬ c.data.state[tempState].nextState;      ENDLOOP;    END;    EmulatorOps.ReleaseContext[window];    IF c.linesToScroll > 0 THEN SELECT c.refresh FROM      always => DoForceOut[c];      half => IF c.linesToScroll >= c.scrollHeight/2 THEN DoForceOut[c];      full => IF c.linesToScroll >= c.scrollHeight-1 THEN DoForceOut[c];      ENDCASE;    };    GetNextState: PROC[data: StateDefs.Handle,    state: CARDINAL, c: CHARACTER] RETURNS [new: CARDINAL] = INLINE {    ch: CHARACTER = SELECT c FROM      IN ['0..'9] => '0,      '\000 => '\200,      ENDCASE => c;    WHILE data.state[state].char # '\000 AND data.state[state].char # c     AND data.state[state].char # ch DO      state ¬ state + 1;      ENDLOOP;    new ¬ state;    };  ExecuteState: PROC[    c: EmulatorOps.EContext, state: StateDefs.State, char:CHARACTER] RETURNS     [eat: CARDINAL] =  {    SELECT state.action FROM      ANSIOn => SetOther[c];      AddBlankLine => {        old: CARDINAL = c.top;	c.top ¬ c.y;	c.scrollHeight ¬ c.bot - c.top + 1;	ShiftLinesDown[c];	c.top ¬ old;	c.scrollHeight ¬ c.bot - c.top + 1};      AutoRepeatOn => c.autoRepeat ¬ TRUE;      AutoRepeatOff => c.autoRepeat ¬ FALSE;      Bell => UserTerminal.Beep[frequency:1000, duration: 20];      BackTab => EmulatorOps.InternalBackTab[c];      BlinkOn => c.attr[blink] ¬ TRUE;      BlinkOff => c.attr[blink] ¬ FALSE;      CarriageReturn => EmulatorOps.InternalCR[c];      ClearTabOptions => {SELECT c.params[0] FROM        0 => c.tabs[c.y] ¬ FALSE;        3 => c.tabs ¬ EmulatorOps.nullTabs;	ENDCASE;	c.params[0] ¬ 0};      CharAttributeOptions => FOR i: CARDINAL IN [0..c.nParams] DO        SELECT c.params[i] FROM          0 => {temp: BOOLEAN ¬ c.attr[spare1];	    c.attr ¬ ALL[FALSE]; c.attr[spare1] ¬ temp};          1 => c.attr[bold] ¬ TRUE;          4 => c.attr[underline] ¬ TRUE;          5 => c.attr[blink] ¬ TRUE;          7 => c.attr[inverse] ¬ TRUE;	  ENDCASE;	  c.params[i] ¬ 0;	ENDLOOP;      CollectXValue => c.params[EmulatorOps.ColumnIndex] ¬         (char - '0) + (10*c.params[EmulatorOps.ColumnIndex]);      CollectYValue => c.params[EmulatorOps.LineIndex] ¬         (char - '0) + (10*c.params[EmulatorOps.LineIndex]);      CollectParam =>         c.params[c.nParams] ¬ (c.params[c.nParams]*10) + (char - '0);      CursorAddress => {        x: CARDINAL = c.data.num[XDiff];        y: CARDINAL = c.data.num[YDiff];        column: CARDINAL ¬ c.params[EmulatorOps.ColumnIndex];        line: CARDINAL ¬ c.params[EmulatorOps.LineIndex];        IF  column >= x THEN column ¬ MIN[c.columns-1, column - x];        IF line >= y THEN line ¬ MIN[c.lines-1, line - y];        EmulatorOps.InternalGotoXY[c,column, line];	c.params[EmulatorOps.ColumnIndex] ¬ c.params[EmulatorOps.LineIndex] ¬ 0;	};      CursorBackward => EmulatorOps.InternalLeft[c];      CursorDown=> EmulatorOps.InternalDown[c];      CursorForward => EmulatorOps.InternalRight[c];      CursorKeyApplication => c.cursorKey ¬ TRUE;      CursorKeyNormal => c.cursorKey ¬ FALSE;      CursorPositionReport => IF c.cursorStatus # NIL THEN SendCursorPosition[c];      CursorUp => EmulatorOps.InternalUp[c];      DeleteChar => DeleteChar[c];      DeleteLine => {        old: CARDINAL = c.top;	c.top ¬ c.y;	c.scrollHeight ¬ c.bot - c.top + 1;	ShiftUpImmediately[c];	c.top ¬ old;	c.scrollHeight ¬ c.bot - c.top + 1};      Delimiter => c.nParams ¬ MIN[c.nParams + 1, EmulatorOps.ParamCnt-1];      DoubleBottom => RepaintLine[c, bottom];      DoubleTop => RepaintLine[c, top];      DoubleWidth => {         Blank[c.source[c.y], c.columns/2, c.columns/2];	RepaintLine[c, wide]};      EraseLineOptions => {SELECT c.params[0] FROM        0 => EmulatorOps.InternalClearToEOL[c];        1 => EmulatorOps.InternalClearToBOL[c];        2 => EmulatorOps.InternalClearLine[c];	ENDCASE;	c.params[0] ¬ 0};      EraseScreenOptions => {SELECT c.params[0] FROM        0 => EmulatorOps.InternalClearToEOS[c];        1 => EmulatorOps.InternalClearToBOS[c];        2 => EmulatorOps.InternalClear[c];	ENDCASE;	c.params[0] ¬ 0};      EraseToEOL => EmulatorOps.InternalClearToEOL[c];      EraseToEOS => EmulatorOps.InternalClearToEOS[c];      EraseScreen => EmulatorOps.InternalClear[c];      G0GrafCharSet => c.attr[spare1] ¬ TRUE;      G0USCharSet => c.attr[spare1] ¬ FALSE;      HomeCursor => EmulatorOps.InternalGotoXY[c,0,0];      Index => InternalLineFeed[c, FALSE];      InitParams => {        FOR i: CARDINAL IN [0..EmulatorOps.ParamCnt) DO        c.params[i] ¬ 0 ENDLOOP;	c.nParams ¬ 0};      InsertModeOff => c.attr[spare2] ¬ FALSE;      InsertModeOn => c.attr[spare2] ¬ TRUE;      KeyPadApplication => c.keypadApplication ¬ TRUE;      KeyPadNormal => c.keypadApplication ¬ FALSE;      LEDOptions => {        FOR i: CARDINAL IN [0..c.nParams] DO          SELECT c.params[i] FROM	    0 => {	      FOR j: LEDType IN [l1..l4] DO	        PaintCursor[c, GetCursorPlace[c, j], LEDOff] ENDLOOP;	      c.l1 ¬ c.l2 ¬ c.l3 ¬ c.l4 ¬ FALSE};	    1 => {PaintCursor[c, GetCursorPlace[c, l1], LEDOn]; c.l1 ¬ TRUE};	    2 => {PaintCursor[c, GetCursorPlace[c, l2], LEDOn]; c.l2 ¬ TRUE};	    3 => {PaintCursor[c, GetCursorPlace[c, l3], LEDOn]; c.l3 ¬ TRUE};	    4 => {PaintCursor[c, GetCursorPlace[c, l4], LEDOn]; c.l4 ¬ TRUE};	    ENDCASE;	  c.params[i] ¬ 0;	  ENDLOOP;	};      LineFeed => {        c.params[0] ¬ 1;        IF ~(c.origin OR c.y<=c.bot) OR c.dontScroll THEN EmulatorOps.InternalDown[c] 	ELSE InternalLineFeed[c, c.lineFeed];	c.params[0] ¬ 0};      NextLine => {        c.params[0] ¬ 1;        IF ~(c.origin OR c.y<=c.bot) OR c.dontScroll THEN EmulatorOps.InternalDown[c] 	ELSE InternalLineFeed[c, TRUE];	c.params[0] ¬ 0};      Reset => {        c.attr ¬ ALL[FALSE];	c.dontScroll ¬ FALSE;	EmulatorOps.InternalClear[c];	c.tabs ¬ EmulatorOps.nullTabs;	EmulatorOps.InternalGotoXY[c,0,0];	};      ResetMode => FOR i: CARDINAL IN [0..c.nParams] DO	SELECT c.params[i] FROM	  1 => c.cursorKey ¬ FALSE;	  2 => SetOther[c];	  3 => SetColumns[c, 80];	  5 => [] ¬ UserTerminal.SetBackground[white];	  4 => c.smooth ¬ FALSE;	  6 => c.origin ¬ FALSE;	  7 => c.wrap ¬ FALSE;	  8 => c.autoRepeat ¬ FALSE;	  ENDCASE;	c.params[i] ¬ 0;	ENDLOOP;       RestoreCursor => {c.attr ¬ c.oldAttr; c.x ¬ c.oldx; c.y ¬ c.oldy};       ReverseIndex => InternalReverseLineFeed[c];       ScrollOff => c.dontScroll ¬ FALSE;      ScrollOn => c.dontScroll ¬ TRUE;      SaveCursor => {c.oldAttr ¬ c.attr; c.oldx ¬ c.x; c.oldy ¬ c.y};       Set132Column => SetColumns[c, 132];       Set80Column => SetColumns[c, 80];       SetAbsoluteOrigin => c.origin ¬ FALSE;       SetLineFeed => {IF c.params[0] = 20 THEN c.lineFeed¬FALSE; c.params[0] ¬ 0};      SetMode => FOR i: CARDINAL IN [0..c.nParams] DO	SELECT c.params[i] FROM	  1 => c.cursorKey ¬ TRUE;	  3 => SetColumns[c, 132];	  4 => c.smooth ¬ TRUE;	  5 => [] ¬ UserTerminal.SetBackground[black];	  6 => c.origin ¬ TRUE;	  7 => c.wrap ¬ TRUE;	  8 => c.autoRepeat ¬ TRUE;	  ENDCASE;	c.params[i] ¬ 0;	ENDLOOP;       SetNewLine => {IF c.params[0] = 20 THEN c.lineFeed ¬ TRUE; c.params[0]¬0};      SetNormalScreen => [] ¬ UserTerminal.SetBackground[white];       SetRelativeOrigin => c.origin ¬ TRUE;       SetReverseScreen => [] ¬ UserTerminal.SetBackground[black];       SetTab => c.tabs[c.x] ¬ TRUE;       SingleWidth => RepaintLine[c, normal];      StatusReport => IF c.identify # NIL THEN        [] ¬ UserInput.StuffString[c.sw, c.identify];      StuffChar => IF c.attr[spare2] THEN InsertMode[c, char]        ELSE InternalPutChar[c, char];      SubXDiff => c.params[EmulatorOps.ColumnIndex] ¬         char.ORD + c.params[EmulatorOps.ColumnIndex];      SubYDiff => c.params[EmulatorOps.LineIndex] ¬         char.ORD + c.params[EmulatorOps.LineIndex];      ScrollForward => ShiftUpInternal[c];      ScrollReverse => ShiftLinesDown[c];      ScrollingRegion => {        x: CARDINAL = c.data.num[XDiff];        y: CARDINAL = c.data.num[YDiff];        top: CARDINAL ¬ c.params[EmulatorOps.TopIndex];        bot: CARDINAL ¬ c.params[EmulatorOps.BotIndex];	IF (top = bot) AND (top = 0) THEN bot ¬ c.lines-1	ELSE {	  IF top >= x THEN top ¬ MIN[c.lines-1, top - x];	  IF bot >= y THEN bot ¬ MIN[c.lines-1, bot - y]};	ChangeScrollRegion[c,top, bot];	c.params[EmulatorOps.TopIndex] ¬ c.params[EmulatorOps.BotIndex] ¬ 0;	};      StandOutModeOn => c.attr[inverse] ¬ TRUE;      StandOutModeOff => c.attr[inverse] ¬ FALSE;      Tab => EmulatorOps.InternalTab[c];      UnderscoreOn => c.attr[underline] ¬ TRUE;      UnderscoreOff => c.attr[underline] ¬ FALSE;      WrapOff => c.wrap ¬ FALSE;      WrapOn => c.wrap ¬ TRUE;      VT52On => SetOther[c];      ENDCASE;    eat ¬ IF state.eatChars THEN 1 ELSE 0;    };  SetOther: PROC[c: EmulatorOps.EContext] = {    temp: StateDefs.Handle ¬ NIL;    IF c.otherData # NIL THEN {      temp ¬ c.data; c.data ¬ c.otherData; c.otherData ¬ temp;      };    };    SendCursorPosition: PROC[c: EmulatorOps.EContext] = {    i: CARDINAL ¬ 0;    first: BOOLEAN ¬ TRUE;    Send: Format.StringProc = {[] ¬ UserInput.StuffString[c.sw, s]};    FOR i IN [0..c.cursorStatus.length) DO      IF c.cursorStatus[i] # '% THEN        [] ¬ UserInput.StuffCharacter[c.sw, c.cursorStatus[i]]      ELSE {        i ¬ i + 1;	Format.Number[Send, IF first THEN c.y ELSE c.y, []];	first ¬ FALSE;	};      ENDLOOP;    };    Blank: PROC [p: EmulatorOps.AttributeList, start, count: CARDINAL] = INLINE {    p.font ¬ normal;    p.dirty ¬ FALSE;    p[start] ¬ EmulatorOps.Blank;    Inline.LongCOPY[from: @p[start], to: @p[start+1], nwords: count-1]};      charsPerForceOut: PUBLIC CARDINAL ¬ 300;  linesPerForceOut: PUBLIC CARDINAL ¬ 12;    SetColumns: PROC[c: EmulatorOps.EContext, columns: CARDINAL] = {    c.columns ¬ columns;    EmulatorOps.InternalClear[c];    EmulatorOps.InternalGotoXY[c,0,0];    FOR i: CARDINAL IN [0..c.lines) DO      c.source[i].font ¬ normal ENDLOOP;    };    InternalLineFeed: PUBLIC PROC[c: EmulatorOps.EContext,     CR: BOOLEAN ¬ FALSE]  = {    y: CARDINAL ¬ c.y + 1;    IF c.origin THEN {      IF y > (c.scrollHeight-1) THEN {        ShiftUpInternal[c];        y ¬ c.scrollHeight-1}}    ELSE      IF y > c.bot THEN {        ShiftUpInternal[c];        y ¬ c.bot};    EmulatorOps.InternalGotoXY[c, IF CR THEN 0 ELSE c.x, y];    };      InternalPutChar: PROCEDURE [c: EmulatorOps.EContext, char: CHARACTER] = INLINE{    last: CARDINAL ¬ 0;    scroll: BOOLEAN ¬ FALSE;    real: CARDINAL ¬ 0;    columns: CARDINAL ¬       IF c.source[c.y].font # normal THEN c.columns/2 ELSE c.columns;    IF char = Ascii.NUL THEN RETURN;    IF (c.x >= columns) THEN {      IF c.wrap THEN {        InternalLineFeed[c, TRUE];        }      ELSE c.x ¬ columns - 1;      };    c.source[c.y][c.x] ¬ [char,c.attr];    real ¬ c.y + (IF c.origin THEN c.top ELSE 0);    IF c.dontPaint OR c.refresh # always THEN       c.source[real].dirty ¬ TRUE    ELSE      Character[c, char, c.x, real];    c.charCount ¬ c.charCount + 1;    c.x ¬ c.x + 1;    };    DeleteChar: PROCEDURE [c: EmulatorOps.EContext] = {    FOR i: CARDINAL IN [c.x..c.columns-1) DO      c.source[c.y][i] ¬ c.source[c.y][i+1] ENDLOOP;    c.source[c.y].dirty ¬ TRUE;    c.source[c.y][c.columns-1] ¬ EmulatorOps.Blank;    };    InsertMode: PROCEDURE [c: EmulatorOps.EContext, char: CHARACTER] = {    columns: CARDINAL ¬       IF c.source[c.y].font # normal THEN c.columns/2 ELSE c.columns;    IF char = Ascii.NUL THEN RETURN;    IF c.x + 1 >= c.columns THEN RETURN;    FOR i: CARDINAL DECREASING IN [c.x+1..c.columns) DO      c.source[c.y][i] ¬ c.source[c.y][i-1] ENDLOOP;    c.source[c.y][c.x] ¬ [char,c.attr];    c.x ¬ c.x + 1;    c.source[c.y].dirty ¬ TRUE;    };    DoForceOut: ENTRY PROC[c: EmulatorOps.EContext] = {    ENABLE UNWIND => NULL;    c.dirty ¬ TRUE;    WHILE c.dirty DO       BROADCAST EmulatorOps.ForceOutStart;      WAIT EmulatorOps.ForceOutFinished;      ENDLOOP;    };    ChangeScrollRegion: PROC[c: EmulatorOps.EContext,x,y:CARDINAL] ={    IF c.linesToScroll > 0 THEN InternalForceScroll[c];    c.top ¬ MIN[x, y];    c.bot ¬ MAX[x, y, c.top+1];    c.scrollHeight ¬ c.bot - c.top + 1;    EmulatorOps.InternalGotoXY[c, 0,0];    };    InternalReverseLineFeed: PROC[c: EmulatorOps.EContext] = {    IF (c.origin AND c.y=0) OR (~c.origin AND c.y=c.top) THEN ShiftLinesDown[c]    ELSE EmulatorOps.InternalUp[c]};    ShiftLinesDown: PROC[c: EmulatorOps.EContext] = {    box: Window.Box ¬ TRASH;    place: Window.Place ¬ TRASH;    temp: EmulatorOps.AttributeList ¬ NIL;    IF c = NIL THEN RETURN;    place ¬ EmulatorOps.GetPlace[c, 0, c.y];    box ¬ [place:place,      dims:[w:c.frame.dims.w,       h:(c.scrollHeight - 1)*c.fonts[normal].height]];    IF c.ownSelect THEN Selection.ActOn[clear];    temp ¬ c.source[c.bot];    FOR i: CARDINAL DECREASING IN [c.top..c.bot) DO      c.source[i+1] ¬ c.source[i] ENDLOOP;    c.source[c.top] ¬ temp;    Blank[c.source[c.top], 0, c.columns];    Display.Shift[c.sw, box, EmulatorOps.GetPlace[c,0,c.y+1]];    Display.White[c.sw,      [place:place, dims:[h: c.fonts[normal].height,w: box.dims.w]]];    c.charCount ¬ c.charCount +  1;    };      ShiftLinesUp: PUBLIC PROC[    window: Window.Handle, c: EmulatorOps.EContext] = {ShiftUpInternal[c]};        ShiftUpInternal:  PROC[c: EmulatorOps.EContext] = {    temp: EmulatorOps.AttributeList ¬ NIL;    IF c = NIL THEN RETURN;    c.linesToScroll ¬ MIN[(c.scrollHeight), (c.linesToScroll + 1)];    temp ¬ c.source[c.top];    FOR i: CARDINAL IN [c.top..c.bot) DO      c.source[i] ¬ c.source[i+1] ENDLOOP;    c.source[c.bot] ¬ temp;    Blank[c.source[c.bot], 0, c.columns];    c.charCount ¬ c.charCount +  1;    c.dontPaint ¬ TRUE;    };        ShiftUpImmediately:  PROC[c: EmulatorOps.EContext] = {    temp: EmulatorOps.AttributeList ¬ NIL;    IF c = NIL THEN RETURN;    IF c.ownSelect THEN Selection.ActOn[clear];    temp ¬ c.source[c.top];    FOR i: CARDINAL IN [c.top..c.bot) DO      c.source[i] ¬ c.source[i+1] ENDLOOP;    c.source[c.bot] ¬ temp;    Blank[c.source[c.bot], 0, c.columns];    Display.Shift[c.sw, [place: EmulatorOps.GetPlace[c,0,c.y+1],      dims:[w:c.frame.dims.w, h:(c.scrollHeight - 1)*c.fonts[normal].height]],      EmulatorOps.GetPlace[c,0,c.y]];    Display.White[c.sw,      [place:EmulatorOps.GetPlace[c,0,c.bot],       dims:[h: c.fonts[normal].height,w: c.frame.dims.w]]];    c.charCount ¬ c.charCount +  1;    };          DisplayProc: PUBLIC ENTRY ToolWindow.DisplayProcType = {    ENABLE UNWIND => NULL;    c: EmulatorOps.EContext ¬ EmulatorOps.FindContext[window];    invalid: PACKED ARRAY[0..64) OF BOOLEAN ¬ ALL[FALSE];    font: WindowFont.Handle = IF c = NIL THEN NIL ELSE c.fonts[normal];    height: CARDINAL ¬ IF font = NIL THEN 0 ELSE font.height;    place: Window.Place ¬ TRASH;    MarkInvalid: PROC[w: Window.Handle, b: Window.Box] ={      top: CARDINAL ¬ ABS[b.place.y/height];      bot: CARDINAL ¬ MIN[c.lines -1, (b.place.y + b.dims.h)/ height];      FOR i: CARDINAL IN [top..bot] DO invalid[i] ¬ TRUE ENDLOOP;      };    IF c = NIL THEN Emulator.Error[notAEmuSW];    BEGIN ENABLE UNWIND => EmulatorOps.ReleaseContext[window];    window.EnumerateInvalidBoxes[MarkInvalid];    Display.White[window, [[0,0], c.frame.dims]];    FOR i: CARDINAL IN [0..c.lines) DO      IF invalid[i] THEN PaintLine[c,i] ENDLOOP;    place ¬ EmulatorOps.GetRealPlace[c, 0, c.lines + headerOffset];    [] ¬ Display.Text[window, header, place, font];    place ¬ EmulatorOps.GetRealPlace[c, 0, c.lines + cursorOffset];    FOR j: LEDType IN LEDType DO      place ¬ GetCursorPlace[c, j];      SELECT j FROM        data => PaintCursor[c, place, IF c.flipper THEN flipper1 ELSE flipper2];        online => PaintCursor[c, place, IF c.remote THEN LEDOn ELSE LEDOff];        local => PaintCursor[c, place, IF c.remote THEN LEDOff ELSE LEDOn];	l1 => PaintCursor[c, place, IF c.l1 THEN LEDOn ELSE LEDOff];	l2 => PaintCursor[c, place, IF c.l2 THEN LEDOn ELSE LEDOff];	l3 => PaintCursor[c, place, IF c.l3 THEN LEDOn ELSE LEDOff];	l4 => PaintCursor[c, place, IF c.l4 THEN LEDOn ELSE LEDOff];	ENDCASE;      ENDLOOP;    END;    EmulatorOps.ReleaseContext[window];    c.marked ¬ FALSE;    IF c.ownSelect THEN Selection.ActOn[mark];    };    PaintCursor: PROC[c: EmulatorOps.EContext, place: Window.Place,     bitmap: LONG POINTER] = {    Display.Bitmap[c.sw,[place, [16,16]],[bitmap,0,0], 16, Display.replaceFlags];    };      GetCursorPlace: PROC[c: EmulatorOps.EContext, type: LEDType]     RETURNS[place: Window.Place] = {    place ¬ EmulatorOps.GetRealPlace[      c, 1+ (type.ORD * cursorWidth), c.lines + cursorOffset];    };      SetRemote: PUBLIC PROC [sw:Window.Handle, remote: BOOLEAN] = {    c: EmulatorOps.EContext ¬ EmulatorOps.FindContext[sw];    on, off: LEDType;    IF c = NIL THEN Emulator.Error[notAEmuSW];    BEGIN ENABLE UNWIND => EmulatorOps.ReleaseContext[sw];    IF remote = c.remote THEN GOTO nope;    c.remote ¬ remote;    IF remote THEN {on ¬ online; off ¬ local}    ELSE {on ¬ local; off ¬ online};    PaintCursor[c, GetCursorPlace[c,on], LEDOn];    PaintCursor[c, GetCursorPlace[c,off], LEDOff];    EXITS nope => NULL;    END;    EmulatorOps.ReleaseContext[sw];    };      ForceScroll: PUBLIC PROC[window: Window.Handle, c: EmulatorOps.EContext] = {    c ¬ EmulatorOps.FindContext[window];    BEGIN ENABLE UNWIND => EmulatorOps.ReleaseContext[window];    IF c = NIL THEN RETURN;    InternalForceScroll[c];    END;    EmulatorOps.ReleaseContext[window];    };    InternalForceScroll: PROC[c: EmulatorOps.EContext] = {    EmulatorOps.ActOnCaret[c, clear];    IF c.linesToScroll > 0 THEN {      Display.Shift[	c.sw, [EmulatorOps.GetRealPlace[c,0,c.linesToScroll+c.top],	[w: c.frame.dims.w, 	h: (c.scrollHeight-c.linesToScroll)*c.fonts[normal].height]], 	EmulatorOps.GetRealPlace[c,0,c.top]];      Display.White[c.sw, 	[EmulatorOps.GetRealPlace[c,0,c.bot-c.linesToScroll+1],	[w: c.frame.dims.w, h: c.linesToScroll*c.fonts[normal].height]]];      FOR i: CARDINAL DECREASING IN [0..c.linesToScroll) DO	PaintLine[c, (c.bot - i)] ENDLOOP;      };    FOR i: CARDINAL IN [0..c.lines) DO      IF c.source[i].dirty THEN PaintLine[c, i, FALSE];      ENDLOOP;    c.dontPaint ¬ FALSE;    c.linesToScroll ¬ 0;    };    RepaintLine: PROC[c: EmulatorOps.EContext, font: EmulatorOps.FontType] = {    c.source[c.y].font ¬ font;    Display.White[c.sw, [EmulatorOps.GetPlace[c,0,c.y],      [w: c.frame.dims.w, h: c.fonts[normal].height]]];    PaintLine[c, IF c.origin THEN c.y + c.top ELSE c.y];    };    WhiteSP: EmulatorOps.AttributeType ¬ [char: '  ];  Plain: EmulatorOps.AttrBooleans = ALL[FALSE];    PaintLine: PROC[    c: EmulatorOps.EContext, line: CARDINAL, skipSpaces: BOOLEAN ¬ TRUE] =   {    thisLine: EmulatorOps.AttributeList ¬ c.source[line];    sw: Window.Handle ¬ c.sw;    columns: CARDINAL ¬       IF c.source[line].font # normal THEN (c.columns+1)/2 ELSE c.columns;    endChar: CARDINAL ¬ columns;    start: CARDINAL ¬ 0;    IF skipSpaces THEN {      FOR j: CARDINAL DECREASING IN [0..c.columns) DO	IF thisLine[j] = WhiteSP THEN LOOP;	endChar ¬ j + 1;	EXIT;	REPEAT FINISHED => endChar ¬ 0;	ENDLOOP;      FOR j: CARDINAL IN [0..endChar) DO        IF thisLine[j] = WhiteSP THEN LOOP;	start ¬ j;	EXIT;	REPEAT FINISHED => start ¬ endChar;	ENDLOOP;      };    IF endChar > start THEN {      font: EmulatorOps.FontType = c.source[line].font;      fontH: WindowFont.Handle ¬ c.regFonts[font];      place: Window.Place;      delta: INTEGER;      IF font = normal THEN {        place ¬ EmulatorOps.GetRealPlace[c, start, line];	delta ¬ c.fonts[normal].maxWidth}      ELSE {        place ¬ EmulatorOps.GetRealPlace[c, start * 2, line];	delta ¬ c.fonts[normal].maxWidth * 2};      FOR i: CARDINAL IN [start..endChar) DO        IF skipSpaces AND thisLine[i] = WhiteSP THEN {}  -- skip this blank	ELSE {	  IF thisLine[i].ats = Plain THEN {	    [] ¬ Display.Character[	      sw, thisLine[i].char, place, fontH, Display.replaceFlags]}	  ELSE Character[c, thisLine[i].char, i, line];  	  };	place.x ¬ place.x + delta;      ENDLOOP;      };    c.source[line].dirty ¬ FALSE;    };    invertFlags: Display.BitBltFlags = [    direction:forward, disjoint:TRUE, disjointItems:TRUE,     gray:FALSE, srcFunc:complement, dstFunc:null, reserved:0];    invertTextFlags: Display.BitBltFlags = [    direction:forward, disjoint:TRUE, disjointItems:TRUE,     gray:FALSE, srcFunc:complement, dstFunc:and, reserved:0];    Character: PROC[c: EmulatorOps.EContext, char: CHARACTER, x,y: CARDINAL] = {    font: EmulatorOps.FontType = c.source[y].font;    place: Window.Place ¬ EmulatorOps.GetRealPlace[      c, IF font # normal THEN 2*x ELSE x, y];    attr: EmulatorOps.AttrBooleans ¬ c.source[y][x].ats;    fonts:EmulatorOps.FontArray¬ IF attr[spare1] THEN c.graFonts ELSE c.regFonts;    IF ~attr[inverse] THEN {      [] ¬ Display.Character[	c.sw, char, place,	fonts[font], Display.replaceFlags];      IF attr[bold] THEN       [] ¬ Display.Character[	c.sw, char, [place.x+1, place.y],	fonts[font], Display.textFlags];      IF attr[underline] AND font # top THEN 	Display.Black[	  c.sw, [[x: place.x, y: place.y+fonts[font].height-2],	  [w: fonts[font].maxWidth, h: 1]]];      IF attr[strikeout] THEN 	Display.Black[	  c.sw, [[x: place.x, y: place.y+(fonts[font].height/2)],	  [w: fonts[normal].maxWidth, h: 1]]];      }    ELSE {      [] ¬ Display.Character[	c.sw, char, place,	fonts[font], invertFlags];      IF attr[bold] THEN       [] ¬ Display.Character[	c.sw, char, [place.x+1, place.y],	fonts[font], invertTextFlags];      IF attr[underline] AND font # top THEN 	Display.White[	  c.sw, [[x: place.x, y: place.y+fonts[font].height-2],	  [w: fonts[font].maxWidth, h: 1]]];      IF attr[strikeout] THEN 	Display.White[	  c.sw, [[x: place.x, y: place.y+(fonts[font].height/2)],	  [w: fonts[font].maxWidth, h: 1]]];      }    };     debug1: BOOLEAN ¬ FALSE;  debug2: BOOLEAN ¬ FALSE;  debug3: BOOLEAN ¬ FALSE;  Init: PROC = {    flipper1 ¬ EmulatorOps.zone.NEW[CursorBits ¬ [163400B, 122400B, 163400B,       014000B, 014000B, 163400B, 122400B, 163400B, 000347B, 000245B, 000347B,       000030B, 000030B, 000347B, 000245B, 000347B]];    flipper2 ¬ EmulatorOps.zone.NEW[CursorBits ¬ [000347B, 000245B, 000347B,       000030B, 000030B, 000347B, 000245B, 000347B, 163400B, 122400B, 163400B,       014000B, 014000B, 163400B, 122400B, 163400B]];    LEDOn ¬ EmulatorOps.zone.NEW[CursorBits ¬ [003740B, 017770B, 037774B, 077776B,       077776B, 177777B, 177777B, 177777B, 177777B, 177777B, 177777B, 077776B,       077776B, 037774B, 017770B, 003740B]];    LEDOff ¬ EmulatorOps.zone.NEW[CursorBits ¬ [003740B, 014030B, 020004B,       040002B, 040002B, 100001B, 100001B, 100001B, 100001B, 100001B, 100001B,       040002B, 040002B, 020004B, 014030B, 003740B]];    };    Init[];    END.
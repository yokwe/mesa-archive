-- EmulatorsD.mesa-- Last Edit:-- BGY     	28-Jul-85 13:11:23-- Copyright (C) 1984 by Xerox Corporation. All rights reserved.DIRECTORY  Caret USING [MarkProcType, ResetOnMatch, Set],  Context USING [Find],  Display USING [Invert],  EmulatorOps USING [    AttributeList, context, EContext, FindContext, FontType,     GetPlace, GetRealPlace, lock, ReleaseContext],  UserInput USING [CaretProcType],  Window USING [Box, Place];  EmulatorsD: MONITOR LOCKS EmulatorOps.lock  IMPORTS Caret, Context, Display, EmulatorOps  EXPORTS  EmulatorOps=  BEGIN      InvertChar: PROC[c: EmulatorOps.EContext, box: Window.Box] = {    IF ~c.blink THEN RETURN;    Display.Invert[c.sw, box];     InvertBlinkers[c];    c.inverted ¬ ~c.inverted    };      InvertOn: PROC[c: EmulatorOps.EContext, box: Window.Box] = {    IF ~c.blink THEN RETURN;    IF ~c.inverted THEN {      Display.Invert[c.sw, box];       InvertBlinkers[c];      c.inverted ¬ TRUE};    };      InvertOff: PROC[c: EmulatorOps.EContext, box: Window.Box] = {    IF ~c.blink THEN RETURN;    IF c.inverted THEN {      Display.Invert[c.sw, box];       InvertBlinkers[c];      c.inverted ¬ FALSE};    };      GetBlink: PROC[c: EmulatorOps.EContext] RETURNS [BOOLEAN]= {    RETURN [c.blink]};      SetBlink: PROC[c: EmulatorOps.EContext, value: BOOLEAN] = {    c.blink ¬ value};      StopBlink: PROC [c: EmulatorOps.EContext, box: Window.Box] = {    IF c.inverted THEN {      Display.Invert[c.sw, box];       InvertBlinkers[c];      c.inverted ¬ FALSE};    c.blink ¬ FALSE;    };      ActOn: PUBLIC Caret.MarkProcType = {    c: EmulatorOps.EContext ¬ data;    IF c = NIL THEN RETURN;    IF ~c.ownFocus THEN RETURN;    c ¬ EmulatorOps.FindContext[c.sw];    IF c = NIL THEN RETURN;    BEGIN ENABLE UNWIND => EmulatorOps.ReleaseContext[c.sw];    ActOnCaret[c, action];    END;    EmulatorOps.ReleaseContext[c.sw];    };          ActOnCaret: PUBLIC Caret.MarkProcType = {    c: EmulatorOps.EContext ¬ data;    IF c = NIL THEN RETURN;    BEGIN    box: Window.Box ¬ GetCaretBox[c, c.x, c.y];    SELECT action FROM      clear,reset => InvertOff[c,box];      mark => InvertOn [c,box];      start => SetBlink[c,TRUE];      stop => StopBlink[c,box];      invert => InvertChar[c,box];      ENDCASE => InvertOff[c,box];    END;    };      GetCaretBox:PROC[c:EmulatorOps.EContext, x,y: CARDINAL] RETURNS [Window.Box] ={    font: EmulatorOps.FontType = c.source[y].font;    place: Window.Place ¬       EmulatorOps.GetPlace[c,IF font # normal THEN 2*x ELSE x, y];    IF c.cursorFlat THEN place.y ¬ place.y + c.fonts[font].height - 1;    RETURN [     [place: place,     dims: [w:c.fonts[font].maxWidth,      h: IF c.cursorFlat THEN 1 ELSE c.fonts[font].height]]]};      ActivateCaret: PUBLIC UserInput.CaretProcType = {    c: EmulatorOps.EContext ¬ Context.Find[EmulatorOps.context, window];    IF c = NIL THEN RETURN;    IF startStop = start THEN Caret.Set[c, ActOn]    ELSE Caret.ResetOnMatch[c];    };      InvertBlinkers: PROC[c: EmulatorOps.EContext] = {    j: CARDINAL ¬ 0;    FOR i: CARDINAL IN [0..c.lines) DO      FOR j ¬ 0, j+1 UNTIL j >= c.columns DO        j ¬ InvertRun[c, j, i] ENDLOOP;      ENDLOOP;    };      InvertRun: PROC[c:EmulatorOps.EContext, x,y: CARDINAL] RETURNS[new: CARDINAL]={    list: EmulatorOps.AttributeList ¬ c.source[y];    box: Window.Box ¬ TRASH;    WHILE ~list[x].ats[blink] DO       x ¬ x + 1;      IF x = c.columns THEN RETURN[x];      ENDLOOP;    new ¬ x;    WHILE list[new].ats[blink] DO      new ¬ new + 1;      IF new = c.columns THEN EXIT;      ENDLOOP;    box ¬ [EmulatorOps.GetRealPlace[      c, IF list.font = normal THEN x ELSE 2*x, y],       [w: (new-x) * c.fonts[list.font].maxWidth, h: c.fonts[list.font].height]];    Display.Invert[c.sw, box];    };             END.    
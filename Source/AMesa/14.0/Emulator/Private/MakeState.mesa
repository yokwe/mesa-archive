-- MakeState.mesa-- Create by FormSWLayoutTool on  5-Oct-83 12:55:57-- BGY      	 28-Jul-85 14:38:42-- Copyright (C) Xerox Corporation 1983, 1984, 1985. All rights reserved.DIRECTORY  Ascii,  Atom,  DumpsterOps,  Environment,  Format,  FormSW,  Heap,  Inline,  Put,  MFile,  MSegment,  MStream,  RefTab,  StateDefs,  Stream,  String,  TermCap,  Time,  Tool,  ToolWindow,  UserTerminal,  Window,  WindowFont;MakeState: PROGRAM  IMPORTS    Atom, DumpsterOps, Format, FormSW, Heap, Inline, Put, MFile, MSegment,     MStream, RefTab, Stream, String, TermCap, Time,     Tool, UserTerminal, WindowFont = {  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = MACHINE DEPENDENT RECORD [    msgSW(0): Window.Handle ¬ NIL,    formSW(2): Window.Handle ¬ NIL,    fileSW(4): Window.Handle ¬ NIL,    input(6): LONG STRING ¬ NIL,    name(8): LONG STRING ¬ NIL,    buf(10): LONG STRING ¬ NIL];  data: DataHandle ¬ NIL;  wh: Window.Handle ¬ NIL;  z: UNCOUNTED ZONE ¬ Heap.systemZone;  initialBox: Window.Box = [place: [x:512, y: 62], dims: [w: 512, h: 306]];  head: StateDefs.Handle ¬ NIL;  NoMoreState: SIGNAL = CODE;  EndOfState: SIGNAL = CODE;  BadControlChar: SIGNAL = CODE;  BadEscapeChar: SIGNAL = CODE;  BadOctalChar: SIGNAL = CODE;  EndOfStateTable: SIGNAL = CODE;  BadAction: SIGNAL [position: CARDINAL] = CODE;    aList: DumpsterOps.ActionList ¬ NIL;  err: BOOLEAN ¬ FALSE;    StateItemType: TYPE = {label, char, consume, action, next};  StateItem: TYPE = RECORD[    pos: CARDINAL ¬ 0,    body: SELECT type: StateItemType FROM      label => [label: Atom.ATOM ¬ NIL],      char => [char: CHARACTER ¬ Ascii.NUL],      consume => [consume: BOOLEAN ¬ TRUE],      action => [action: StateDefs.Actions ¬ StateDefs.Actions.FIRST],      next => [next: Atom.ATOM ¬ NIL],      ENDCASE];    table: RefTab.Ref ¬ NIL;    MakeTable:  FormSW.ProcType = {    IF String.Length[data.input] = 0 THEN {      UserTerminal.BlinkDisplay[];      Msg["No file in Input: field\n"L];      RETURN};    err ¬ FALSE;    Msg["\n"L];    Write["MakeState -- "L];    Format.Date[Write, Time.Current[]];    Write["\n"L];    OpenInFile[];    Msg[data.input];    Msg[" ."L]; -- first pass load data    head ¬ MakeFile[CountLines[]];    table ¬ RefTab.Create[101, z];    LoadList[];    Msg["."L]; -- second pass fix up list    FixList[];    Msg["."L]; -- third pass write table    WriteData[];    Msg["."L]; -- fourth pass string table    DoStringTable[];    CleanUp[];    Write["----------------------------------------\n\n"L];    };  Write: Format.StringProc = {Put.Text[data.fileSW, s]};  Msg: Format.StringProc = {Put.Text[data.msgSW, s]};    stream: Stream.Handle ¬ NIL;  segment: MSegment.Handle ¬ NIL;  byteSize: CARDINAL ¬ 0;  file: MFile.Handle ¬ NIL;  count: CARDINAL ¬ 0;  list: StatePtr ¬ NIL;    StatePtr: TYPE = LONG POINTER TO StateRecord;  StateRecord: TYPE = RECORD[    next: StatePtr ¬ NIL,    myIndex: CARDINAL ¬ 0,    label: Atom.ATOM ¬ NIL,    labelPos: CARDINAL ¬ 0,    char: CHARACTER ¬ CHARACTER.FIRST,    consume: BOOLEAN ¬ TRUE,    action: StateDefs.Actions ¬ NullState,    nextLabel: Atom.ATOM ¬ NIL,    nextLabelPos: CARDINAL ¬ 0,    nextIndex: CARDINAL ¬ 0];          PrintBadCode: PROC[pos: LONG CARDINAL, s: LONG STRING] = {    Put.Text[data.fileSW,"Warning: Bad entry in position "L];    Put.LongNumber[data.fileSW, pos, []];    Put.Text[data.fileSW, ". Error:=  "L];    Put.Line[data.fileSW, s];    };      PrintSyntax: PROC[pos: LONG CARDINAL, code: TermCap.ErrorCode] = {    Put.Text[data.fileSW,"Syntax error in position "L];    Put.LongNumber[data.fileSW, pos, []];    Put.Text[data.fileSW, ". Error: "L];    Put.Line[data.fileSW, SELECT code FROM      expectingCR => "Expecting a carriage return."L,      expectingEqual => "Expecting an equal sign."L,      badOctal => "Invalid octal digit."L,      cantFollowBS => "Invalid char after a backSlash."L,      badDelimiter => "Bad delimiter"L,      expectingPound => "Expecting a # ."L,      unknownEntry => "Unknown entry."L,      ENDCASE => "Unknown error."L];    };      DoStringTable: PROC = {    ENABLE Stream.EndOfStream => GOTO quit;    i: StateDefs.KeyboardValues;    j: StateDefs.Actions;    key: StateDefs.KeyBoardHandle ¬ z.NEW[StateDefs.KeyBoardTable];    temp: StateDefs.CommandHandle ¬ z.NEW[StateDefs.CommandStrings];    FOR i IN StateDefs.KeyboardValues DO key[i] ¬ NIL ENDLOOP;    FOR j IN StateDefs.Actions DO temp[j] ¬ NIL ENDLOOP;    TermCap.ParseCapas[head, key, temp, stream!       TermCap.SyntaxError => {	PrintSyntax[pos, code];	RESUME};      TermCap.BadCode => {	PrintBadCode[pos,s];      RESUME}];    TermCap.FillKeyStrings[head, @head.state[head.head.numberOfStates],key];    IF key # NIL THEN {      FOR i IN StateDefs.KeyboardValues DO        IF key[i] # NIL THEN z.FREE[@key[i]];        ENDLOOP;      z.FREE[@key]};    IF temp # NIL THEN {        FOR j IN StateDefs.Actions DO        IF temp[j] # NIL THEN z.FREE[@temp[j]];        ENDLOOP;      z.FREE[@temp]};    EXITS quit => Write["Unexpected end of file."L];    };    WriteData: PROC = {    WriteRec: EnumProc = {      head.state[p.myIndex] ¬ [        char: p.char,	nextState: p.nextIndex,	eatChars: p.consume,	action: p.action];      };          head.head.numberOfStates ¬ count;    EnumerateList[WriteRec];    };    FreeList: PROC = {    temp: StatePtr;    i: StatePtr;    FOR i ¬ list, temp UNTIL i = NIL DO      temp ¬ i.next;      z.FREE[@i];      ENDLOOP;    list ¬ NIL;    };    WritePos: PROC[pos: CARDINAL ¬ CARDINAL.LAST] = {    IF pos = CARDINAL.LAST THEN pos ¬ Inline.LowHalf[stream.GetPosition[]];    Format.Number[Write, pos, []];    Write[".\n"L];    err ¬ TRUE;    };    EnumProc: TYPE = PROC[p: StatePtr];  EnumerateList: PROC[proc: EnumProc] = {    Recurse: EnumProc = {      IF p = NIL THEN RETURN;      Recurse[p.next];      proc[p]};    Recurse[list];    };    FixList: PROC = {    cntr: CARDINAL ¬ 0;    SetIndex: EnumProc = {p.myIndex ¬ cntr; cntr ¬ cntr + 1};        SaveLabels: EnumProc = {IF p.label # NIL THEN         IF ~table.Insert[p.label, p] THEN {err ¬ TRUE;	  Write["Twice declared label at "L]; 	  Format.Number[Write, p.labelPos, []]; Write["\n"L]}};	      SaveNextLabels: EnumProc = {      label: StatePtr ¬ NIL;      IF p.nextLabel # NIL THEN {        label ¬ table.Fetch[p.nextLabel].val;	IF label # NIL THEN p.nextIndex ¬ label.myIndex	ELSE {err ¬ TRUE; Write["Undeclared label at "L];	  Format.Number[Write, p.nextLabelPos, []]; Write["\n"L]}}};	      EnumerateList[SetIndex];    EnumerateList[SaveLabels];    EnumerateList[SaveNextLabels];    };    LoadList: PROC = {    ENABLE {      BadControlChar => {Write["Bad Control character at "L]; WritePos[]; RESUME};      BadEscapeChar => {Write["Bad Escape format at "L]; WritePos[]; RESUME};      BadOctalChar => {Write["Bad Octal format at "L]; WritePos[]; RESUME};      BadAction => {Write["Unknown action at "L]; WritePos[position]; RESUME}};    ptr: StatePtr;    count ¬ 0;    IF list # NIL THEN FreeList[];    DO      ptr ¬ GetState[!Stream.EndOfStream => GOTO error;        EndOfStateTable => GOTO quit];      ptr.next ¬ list;      list ¬ ptr;      count ¬ count + 1;      ENDLOOP;    EXITS       quit => NULL;      error => Write["Unexpected end of file.\n\n"L];    };    GetState: PROC RETURNS [state: StatePtr ¬ NIL] = {    ENABLE {      Stream.EndOfStream => {        IF state # NIL THEN z.FREE[@state]; REJECT};      EndOfStateTable => {        IF state # NIL THEN z.FREE[@state]; REJECT}};    done: BOOLEAN ¬ FALSE;    first: BOOLEAN ¬ TRUE;    item: StateItem ¬ [body: char[]];    state ¬ z.NEW[StateRecord ¬ []];    UNTIL done DO      item ¬ GetStateItem[first !        NoMoreState => GOTO quit;	EndOfState => {done ¬ TRUE; RESUME}];      first ¬ FALSE;      WITH vi: item SELECT FROM        label => {state.label ¬ vi.label; state.labelPos ¬ item.pos};        char => state.char ¬ vi.char;        consume => state.consume ¬ vi.consume;        action => state.action ¬ vi.action;        next => {state.nextLabel ¬ vi.next; state.nextLabelPos ¬ item.pos};	ENDCASE;      ENDLOOP;    EXITS quit => NULL};    GetStateItem: PROC [first: BOOLEAN]     RETURNS [item: StateItem ¬ [body: char[]]] = {    s: LONG STRING ¬ NIL;    pos: CARDINAL ¬ 0;    [s,pos] ¬ GetToken[first];    SELECT TRUE FROM      s.length = 1 => item ¬ StateItem[body: char[]];      s[s.length-1] = ': => item ¬ StateItem[body: label[]];      s[s.length-1] = '^ => item ¬ StateItem[body: next[]];      s[s.length-1] = '] AND      s[0] = '[ => item ¬ StateItem[body: consume[]];      ENDCASE => item ¬ StateItem[body: action[]];    WITH vi: item SELECT FROM      char => {vi.char ¬ s[0]; z.FREE[@s]};      label => {        s.length ¬ s.length - 1;        vi.label ¬ Atom.MakeAtom[s];	z.FREE[@s]};      next => {        s.length ¬ s.length - 1;        vi.next ¬ Atom.MakeAtom[s];	z.FREE[@s]};      consume => {vi.consume ¬ FALSE; z.FREE[@s]};      action => {        vi.action ¬ GetAction[s!          BadAction => {SIGNAL BadAction[pos]; z.FREE[@s]; GOTO quit}]; 	z.FREE[@s]};      ENDCASE;    item.pos ¬ pos;    EXITS quit => NULL;    };    GetAction: PROC [s: LONG STRING] RETURNS [a: StateDefs.Actions] = {    ok: BOOLEAN ¬ FALSE;    BinarySearch: PROC[bot,top: StateDefs.Actions]     RETURNS [found: BOOLEAN, action: StateDefs.Actions] = {      middle: StateDefs.Actions;      IF top < bot THEN RETURN[FALSE, bot];      middle ¬ VAL[(bot.ORD + top.ORD)/2];      SELECT String.CompareStrings[s, aList[middle]] FROM        -1 => [found,action] ¬ BinarySearch[bot, middle.PRED];	0 => RETURN[TRUE, middle];	1 => [found, action] ¬ BinarySearch[middle.SUCC, top];	ENDCASE;      };    [ok, a] ¬ BinarySearch[StateDefs.Actions.FIRST, StateDefs.Actions.LAST];    IF ~ok THEN SIGNAL BadAction[0];    };    CleanUp: PROC = {    nChars: CARDINAL ¬ 0;    IF stream # NIL THEN {      stream.Delete[];      stream ¬ NIL};    IF segment # NIL THEN {      nChars ¬ head.head.lengthOfKeyStrings;      segment.Delete[];      segment ¬ NIL};    IF table # NIL THEN {z.FREE[@table]; table ¬ NIL};    IF file # NIL THEN {      file.SetLength[GetByteSize[] + nChars];      file.Release[];      file ¬ NIL};    };    GetByteSize: PROC RETURNS [bs: CARDINAL] = {    words: CARDINAL ¬ SIZE[StateDefs.StateInfo] +(count*StateDefs.StateSize);    bs ¬ 2*words;    };    OpenInFile: PROC = {    data.name.length ¬ 0;    String.AppendString[data.name, data.input];    String.AppendString[data.name, ".sm"L];    stream ¬ MStream.ReadOnly[data.name, []];    };    CountLines: PROC RETURNS [counter: CARDINAL] = {    ENABLE Stream.EndOfStream => GOTO quit;    counter ¬ 0;    stream.SetPosition[0];    DO IF stream.GetChar[] = '\n THEN counter ¬ counter + 1 ENDLOOP;    EXITS quit => stream.SetPosition[0];    };    MakeFile: PROC[guess: CARDINAL] RETURNS [h: StateDefs.Handle] = {    temp: MFile.Handle ¬ NIL;    wordSize: CARDINAL ¬ SIZE[StateDefs.StateInfo] + (guess*StateDefs.StateSize);    pages: CARDINAL ¬       wordSize + (Environment.wordsPerPage - 1)/Environment.wordsPerPage  + 2;    wordSize ¬ pages * Environment.wordsPerPage;    data.name.length ¬ 0;    String.AppendString[data.name, data.input];    String.AppendString[data.name, ".data"L];    temp ¬ MFile.ReadWrite[name: data.name, release: [],       type: binary,initialLength: wordSize*2];    file ¬ MFile.CopyFileHandle[temp, []];    segment ¬ MSegment.Create[file: temp, release: [], pages: pages];    h ¬ MSegment.Address[segment];    };    ClientTransition: ToolWindow.TransitionProcType = {    SELECT TRUE FROM      old = inactive =>        IF data = NIL THEN {	  data ¬ z.NEW[Data ¬ []];	  data.name ¬ z.NEW[StringBody[100]];	  data.buf ¬ z.NEW[StringBody[100]];	  aList ¬ DumpsterOps.GetActionList[];	  };      new = inactive =>        IF data # NIL THEN {	  z.FREE[@data.name];	  z.FREE[@data.buf];	  z.FREE[@data];	  DumpsterOps.FreeActionList[aList];	  aList ¬ NIL;	  };      ENDCASE;    };  Init: PROCEDURE = {    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default, initialBox: initialBox,      clientTransition: ClientTransition, name: "MakeState"L,      cmSection: "MakeState"L];    };  MakeSWs: Tool.MakeSWsProc = {    logName: LONG STRING ¬ [16];    Tool.UnusedLogName[unused: logName, root: "MakeState.log"L];    data.msgSW ¬ Tool.MakeMsgSW[window: window];    data.formSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeForm];    data.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    };  charWidth: CARDINAL ¬ WindowFont.CharWidth['0];  CharPos: PROC[char: CARDINAL] RETURNS [x: INTEGER] = {    x ¬ charWidth * char};  MakeForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = 2;    items ¬ AllocateItemDescriptor[nItems];    items[0] ¬ StringItem[      tag: "Input"L, place: [CharPos[0], line0], inHeap: TRUE, string: @data.input];    items[1] ¬ CommandItem[      tag: "MakeTable"L, place: [CharPos[0], line1], proc: MakeTable];    RETURN[items: items, freeDesc: TRUE];    };  ConsumeAllWhite: PROC RETURNS [ch: CHARACTER] = {    WHILE ((ch ¬ stream.GetChar[]) = ' ) OR (ch = Ascii.TAB) OR     (ch = Ascii.CR) OR (ch = '-) DO      IF ch = '- THEN        UNTIL (ch ¬ stream.GetChar[]) = Ascii.CR DO ENDLOOP;      ENDLOOP;    IF ch = '. THEN SIGNAL EndOfStateTable};    ConsumeWhite: PROC RETURNS [ch: CHARACTER] = {    WHILE ((ch ¬ stream.GetChar[]) = ' ) OR (ch = Ascii.TAB) DO ENDLOOP;    };    ModifyToken: PROC[ s: LONG STRING] = {    IF s[0] = '^ THEN {      IF s.length # 2 THEN {SIGNAL BadControlChar; GOTO quit};      s[0] ¬ s[1] - 100B;      s.length ¬ 1}    ELSE IF s[0] = '\\ THEN {      IF s[1] = 'E THEN {        IF s.length # 2 THEN {SIGNAL BadEscapeChar; GOTO quit};	s[0] ¬ Ascii.ESC; s.length ¬ 1}      ELSE {        val: Environment.Byte ¬ 0;	IF s.length # 4 THEN {SIGNAL BadOctalChar; GOTO quit};	FOR j: CARDINAL IN [1..3] DO val ¬  (8*val) + s[j] - '0 ENDLOOP;	s[0] ¬ LOOPHOLE[val, CHARACTER]; s.length ¬ 1};      };    EXITS quit => NULL;    };    GetToken: PROC [first: BOOLEAN]     RETURNS[token: LONG STRING ¬ NIL, pos: CARDINAL ¬ 0] = {    ch: CHARACTER ¬ IF first THEN ConsumeAllWhite[] ELSE ConsumeWhite[];    IF ch = Ascii.CR THEN SIGNAL NoMoreState;    data.buf.length ¬ 0;    String.AppendChar[data.buf, ch];    pos ¬ Inline.LowHalf[stream.GetPosition[]] - 1;    WHILE ((ch ¬ stream.GetChar[]) # ' ) AND (ch # Ascii.TAB) AND       (ch # Ascii.CR) DO String.AppendChar[data.buf, ch] ENDLOOP;    ModifyToken[data.buf];    IF ch = Ascii.CR THEN SIGNAL EndOfState;    token ¬ String.CopyToNewString[data.buf, z];    };    Copy: PROC[s: LONG STRING, zone: UNCOUNTED ZONE]     RETURNS [new: LONG STRING] = {new ¬ String.CopyToNewString[s,zone]};      -- Mainline code  Init[];  -- this gets string out of global frame  }...    
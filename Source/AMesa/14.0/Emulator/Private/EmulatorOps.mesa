-- EmulatorOps.mesa-- Last Edit:-- BGY     	 9-May-85 13:30:51-- Copyright (C) 1984 by Xerox Corporation. All rights reserved.DIRECTORY  Ascii USING [NUL],  Caret USING [MarkProcType],  Context USING [Acquire, Release, Type],  Emulator USING [RefreshHint],  Environment USING [Block],  MStream USING [Handle],  StateDefs USING [Handle, KeyboardValues],  TIP USING [NotifyProc, Table],  ToolWindow USING [DisplayProcType],  UserInput USING [CaretProcType, PeriodicProcType, StringProcType],  Window USING [Box, Handle, Place],  WindowFont USING [Handle];EmulatorOps: DEFINITIONS   IMPORTS  Context =   BEGIN    LMargin: INTEGER = 12;    Attributes: TYPE = {blink, bold, inverse, strikeout, underline,     spare1, spare2, spare3};      AttrBooleans: TYPE = PACKED ARRAY Attributes OF BOOLEAN;    AttributeType: TYPE = RECORD[    char: CHARACTER ¬ Ascii.NUL,    ats: AttrBooleans ¬ ALL[FALSE]];  AttributeRec: TYPE = RECORD[    font: FontType,    dirty: BOOLEAN,    chars: SEQUENCE length: CARDINAL OF AttributeType];  AttributeList: TYPE = LONG POINTER TO AttributeRec;      Null: AttributeType = AttributeType[];  Blank: AttributeType = AttributeType[char:' ];    ParamCnt: CARDINAL = 10;  TopIndex: CARDINAL = 0;  BotIndex: CARDINAL = 1;  LineIndex: CARDINAL = 0;  ColumnIndex: CARDINAL = 1;    TabArray: TYPE = PACKED ARRAY [0..132) OF BOOLEAN ¬ ALL[FALSE];  nullTabs: TabArray = ALL[FALSE];    TermType: TYPE = {primary, secondary, tertiary, other};  FontType: TYPE = {normal, wide, top, bottom};  FontArray: TYPE = ARRAY FontType OF WindowFont.Handle;    EContext: TYPE = LONG POINTER TO EContextObject;  EContextObject: TYPE = RECORD[    sw: Window.Handle ¬ NIL,    data:StateDefs.Handle ¬ NIL,    type: TermType ¬ primary,    lines, columns, top, bot, x, y, curState, tx, ty,    right, left, maxColumns, tos, charCount, linesPerScroll,    linesToScroll, scrollHeight, oldx, oldy:CARDINAL ¬ 0,    repeaterChar: CHARACTER ¬ Ascii.NUL,    fonts, regFonts, graFonts: FontArray ¬ ALL[NIL],    inverted, blink, ownFocus, ownSelect,marked,     dirty, ownContext, dontPaint, writeToLog, hardTabs, wrap,    flipper, l1, l2, l3, l4, remote, autoRepeat, origin,    cursorKey, cursorFlat, keypadApplication, lineFeed,    marginBell, keyClick, autoXON, smooth, dontScroll: BOOLEAN ¬ FALSE,    refresh: Emulator.RefreshHint ¬ half,    attr, oldAttr: AttrBooleans ¬ ALL[FALSE],    params: ARRAY[0..ParamCnt) OF CARDINAL ¬ ALL[0],    nParams: CARDINAL ¬ 0,    frame: Window.Box ¬ [[0,0],[0,0]],    forceOut: PROCESS ¬ TRASH,    updater: PROCESS ¬ TRASH,    logfile: MStream.Handle ¬ NIL,    otherData: StateDefs.Handle ¬ NIL,    tabs: TabArray ¬ nullTabs,    optionWindow: Window.Handle ¬ NIL,    identify, cursorStatus: LONG STRING ¬ NIL,    selectMode: SelectionMode ¬ char,    source: SEQUENCE nLine: CARDINAL OF AttributeList    ];      SelectionMode: TYPE = {char, word, line, all, other};    zone: UNCOUNTED ZONE;  context: Context.Type;  myTip: TIP.Table;  lock: MONITORLOCK;  UpdateScreenStart: CONDITION;  UpdateScreenFinished: CONDITION;  ForceOutStart: CONDITION;  ForceOutFinished: CONDITION;    charsPerForceOut: CARDINAL;  nLines: CARDINAL;      DisplayProc: ToolWindow.DisplayProcType;    FindContext: PROC[sw:Window.Handle] RETURNS [EContext] = INLINE {    RETURN[Context.Acquire[context, sw]]};      ReleaseContext: PROC[sw:Window.Handle] = INLINE {    Context.Release[context, sw]};      TypeInProc: UserInput.StringProcType;  DisplayBlock: PROC[    window: Window.Handle, b: Environment.Block, place: Window.Place,    context: EContext];  ShiftLinesUp: PROC[window: Window.Handle, c: EContext];  ForceScroll: PROC[window: Window.Handle, c: EContext];      InternalSetFont: PROC[c: EContext, font: WindowFont.Handle];  InternalUp: PROC[c: EContext];  InternalDown: PROC[c: EContext];  InternalLeft: PROC[c: EContext];  InternalRight: PROC[c: EContext];  InternalGotoXY: PROC[c: EContext, x,y: CARDINAL];  InternalClearToEOL: PROC[c:EContext];  InternalClearToEOS: PROC[c:EContext];  InternalClearToBOL: PROC[c:EContext];  InternalClearToBOS: PROC[c:EContext];  InternalClearLine: PROC[c:EContext];  InternalClear: PROC[c:EContext];  InternalCR: PROC[c:EContext];  InternalLineFeed: PROC[c:EContext, CR: BOOLEAN ¬ FALSE];  InternalTab: PROC[c:EContext];  InternalBackTab: PROC[c:EContext];  MoveInsertion: PROC[c: EContext];  TakeInsertion: PROC[c: EContext];  GetCharBox: PROC[c: EContext,x,y: CARDINAL] RETURNS [box: Window.Box];  GetKeyValue: PROC[c: EmulatorOps.EContext,k: StateDefs.KeyboardValues]    RETURNS[value: LONG STRING];    GetPlace: PROC[c: EContext, x,y: CARDINAL]     RETURNS [place: Window.Place] = INLINE {    RETURN [IF c.origin THEN GetRelativePlace[c,x,y]       ELSE GetRealPlace[c,x,y]];    };    GetRelativePlace: PROC[c: EContext, x,y: CARDINAL]     RETURNS [place: Window.Place] = INLINE {    RETURN [[      x: x*c.fonts[normal].maxWidth + LMargin,       y: (y+c.top) * c.fonts[normal].height]];    };    GetRealPlace: PROC[c: EContext, x,y: CARDINAL]     RETURNS [place: Window.Place] = INLINE {    RETURN [[x: x*c.fonts[normal].maxWidth + LMargin,       y: y * c.fonts[normal].height]];    };        ActOnCaret: Caret.MarkProcType;  ActivateCaret: UserInput.CaretProcType;    Notify: TIP.NotifyProc;  KillOptions: UserInput.PeriodicProcType;      END.  
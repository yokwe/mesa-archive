-- File: EmuTest.mesa-- last edit by:-- BGY     	 2-Dec-83 14:19:20DIRECTORY  Emulator,  Format,  FormSW,  Heap,  Inline,  MFile,  MSegment,  MStream,  Process,  Put,  String,  StateDefs,  Stream,  System,  Time,  Tool,  ToolWindow,  UserInput,  UserTerminal,  Window,  WindowFont;EmuTest: PROGRAM   IMPORTS     Emulator, Format, FormSW, Heap, Inline, MFile, MSegment, MStream,     Process, Put, Stream, String, Time, Tool, UserInput, UserTerminal,     WindowFont =  BEGIN  -- TYPEs  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = MACHINE DEPENDENT RECORD [    emuSW(0): Window.Handle _ NIL,    msgSW(2): Window.Handle _ NIL,    formSW(4): Window.Handle _ NIL,    x(6), y(7): CARDINAL _ 5,    buf(8): LONG STRING _ NIL,    write(10): BOOLEAN _ FALSE,    terminal(11): Emulator.TerminalType _ vt100,    refresh(12): Emulator.RefreshHint _ half,    stuff(13): LONG STRING _ NIL,    dataFile(15): LONG STRING _ NIL];  myZone: UNCOUNTED ZONE _ Heap.Create[4];  data: DataHandle _ NIL;  wh: Window.Handle;  -- Tool's window  seg: MSegment.Handle _ NIL;  file: MFile.Handle _ NIL;  state: StateDefs.Handle _ NIL;  stringSeg: MSegment.Handle _ NIL;  bigString: LONG STRING _ NIL;  SetRefresh:  FormSW.EnumeratedNotifyProcType = {    Emulator.SetRefresh[data.emuSW, data.refresh];    };  ChangeTerminal:  FormSW.EnumeratedNotifyProcType = {    [] _ Emulator.SetEmulator[data.emuSW, Emulator.table[data.terminal],       IF data.terminal = vt100 THEN Emulator.table[xvt52] ELSE NIL];    };  Update: PROC = {    [data.x, data.y] _ Emulator.GetInsertion[data.emuSW];    FormSW.DisplayItem[data.formSW, 1];    FormSW.DisplayItem[data.formSW, 2];    };      MyOptions:  FormSW.ProcType = {    Emulator.CreateOptionsSheet[data.emuSW];    };  MyStuff: FormSW.ProcType =    BEGIN    Emulator.PutString[data.emuSW, data.stuff];    Update[];    END;  Jump: FormSW.ProcType =    BEGIN    Emulator.GotoXY[data.emuSW, data.x, data.y];    END;  Clear: FormSW.ProcType =    BEGIN    Emulator.Clear[data.emuSW];    Update[];    END;  Left: FormSW.ProcType =    BEGIN    Emulator.Left[data.emuSW];    Update[];    END;  Right: FormSW.ProcType =    BEGIN    Emulator.Right[data.emuSW];    Update[];    END;  Up: FormSW.ProcType =    BEGIN    Emulator.Up[data.emuSW];    Update[];    END;  Down: FormSW.ProcType =    BEGIN    Emulator.Down[data.emuSW];    Update[];    END;  EOL: FormSW.ProcType =    BEGIN    Emulator.ClearToEOL[data.emuSW];    Update[];    END;  EOS: FormSW.ProcType =    BEGIN    Emulator.ClearToEOS[data.emuSW];    Update[];    END;  CL: FormSW.ProcType =    BEGIN    Emulator.ClearLine[data.emuSW];    Update[];    END;  GetStream: PROC RETURNS [s: Stream.Handle _ NIL] = {    IF String.Length[data.dataFile] = 0 THEN {      Put.Line[data.msgSW, "Need file in DataFile: field"L];      RETURN;      };    s _ MStream.ReadOnly[data.dataFile, []!MStream.Error => CONTINUE];    IF s = NIL THEN {      Put.Text[data.msgSW, "Cant open file "L];      Put.Text[data.msgSW, data.dataFile];      Put.Line[data.msgSW, " for read."L]};    };    Test: FormSW.ProcType = {    stream: Stream.Handle _ NIL;    stream _ GetStream[];    IF stream = NIL THEN RETURN;    Process.Detach[FORK RealTest[stream]];    };  RealTest: PROC[stream: Stream.Handle] = {    ENABLE UNWIND => NULL;    bytes: LONG CARDINAL _ 0;    delta, i: CARDINAL _ 0;    start: System.GreenwichMeanTime _ Time.Current[];    okToStuff _ FALSE;    Process.SetPriority[Process.priorityBackground];    DO      Emulator.PutChar[data.emuSW, stream.GetChar[!Stream.EndOfStream => EXIT]];      bytes _ bytes + 1;      IF UserInput.UserAbort[data.emuSW] THEN EXIT;      IF data.y > 0 THEN FOR i IN [0..data.y) DO        UserTerminal.WaitForScanLine[0];        ENDLOOP;      Process.Yield[];      ENDLOOP;    stream.Delete[];    delta _ Inline.LowHalf[Time.Current[] - start];    Format.Number[Msg, Inline.LowHalf[bytes/delta], []];    Msg[" cps, "L];    Format.Number[Msg, (Inline.LowHalf[bytes/delta]*11), []];    Msg[" baud.\n"L];    okToStuff _ TRUE;    };      Msg: Format.StringProc = {Put.Text[data.msgSW, s]};    Test2: FormSW.ProcType = {    stream: Stream.Handle _ NIL;    stream _ GetStream[];    IF stream = NIL THEN RETURN;    stream.SetInputOptions[[terminateOnEndRecord: TRUE]];    Process.Detach[FORK RealTest2[stream]];    };  RealTest2: PROC[stream: Stream.Handle] = {    ENABLE UNWIND => NULL;    string: LONG STRING _ [200];    bytes: LONG CARDINAL _ 0;    delta: CARDINAL _ 0;    start: System.GreenwichMeanTime _ Time.Current[];    okToStuff _ FALSE;    DO      [string.length,,] _ stream.GetBlock[[LOOPHOLE[@string.text],0,200]];      IF string.length = 0 THEN EXIT;      bytes _ bytes + string.length;      Emulator.PutString[data.emuSW, string];      IF UserInput.UserAbort[data.emuSW] THEN EXIT;      ENDLOOP;    delta _ Inline.LowHalf[Time.Current[] - start];    stream.Delete[];    okToStuff _ TRUE;    Format.Number[Msg, Inline.LowHalf[bytes/delta], []];    Msg[" cps, "L];    Format.Number[Msg, (Inline.LowHalf[bytes/delta]*11), []];    Msg[" baud.\n"L];    };    Test3: FormSW.ProcType =    BEGIN    Process.Detach[FORK RealTest3[]];    END;  RealTest3: PROC = {    ENABLE UNWIND => NULL;    FOR i: CARDINAL IN [1..100] DO      FOR j: CARDINAL IN [0..data.buf.length) DO        Emulator.PutChar[data.emuSW, data.buf[j]];	Process.Pause[Process.MsecToTicks[data.y]];	IF UserInput.UserAbort[data.emuSW] THEN GOTO quit;	ENDLOOP;      ENDLOOP;    EXITS quit => NULL;    };    Write: Format.StringProc = {Put.Text[NIL, s]};    Change: FormSW.ProcType = {    s: LONG STRING _ NIL;    BEGIN    IF String.Length[data.dataFile] = 0 THEN {      Write["Need a data file in formSW!\n"L];      RETURN};    s _ String.CopyToNewString[data.dataFile, myZone, 6];    String.AppendString[s, ".data"L];    IF seg # NIL THEN MSegment.Delete[seg];    file _ MFile.ReadOnly[        name: s, release: [], mightWrite: FALSE! MFile.Error => {	  SELECT code FROM	    noSuchFile => {Write[s]; Write["not found\n"L]};	    ENDCASE => Write["MFile error\n"L];	  GOTO quit}];    seg _ MSegment.Create [        file:file, pages:((file.GetLength[]/256) + 1), 	release:[], fileBase: LONG[0]];    state _ seg.Address[];    [] _ Emulator.SetEmulator[data.emuSW, state];    EXITS quit => NULL;    END;    myZone.FREE[@s];    };  BigArray: TYPE = ARRAY[0..0) OF CARDINAL;  Ptr: TYPE = LONG POINTER TO BigArray;  -- Tool needed routines  ClientTransition: ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      old = inactive => {        ptr: Ptr _ NIL;        IF data = NIL THEN data _ myZone.NEW[Data _ []];	data.buf _ myZone.NEW[StringBody[80]];	data.buf.length _ 80;	FOR i: CARDINAL IN [0..80) DO data.buf[i] _ 'E ENDLOOP;	stringSeg _ MSegment.Create[file: NIL, release:[], pages: 31];	bigString _ stringSeg.Address[];	bigString.length _ 0;	ptr _ LOOPHOLE[bigString];	ptr[1] _ 31*256*2;	};      new = inactive =>        IF data # NIL THEN {	  stringSeg.Delete[];	  stringSeg _ NIL;	  bigString _ NIL;	  myZone.FREE[@data.buf];	  myZone.FREE[@data]};	        ENDCASE;    END;  Init: PROCEDURE =    BEGIN    box: Window.Box = [place: [0, 30], dims: [ w: 512, h: 700]];    wh _ Tool.Create[      makeSWsProc: MakeSWs, initialBox: box, initialState: default,      clientTransition: ClientTransition, name: "EmuTest"L,      cmSection: "EmuTest"L];    END;  charWidth: CARDINAL _ WindowFont.CharWidth['0];  CharPos: PROC[char: CARDINAL] RETURNS [x: INTEGER] = {    x _ charWidth * char};  MakeForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = 22;    terminal: ARRAY[0..22) OF Enumerated _ [      ["addrinfo"L, 0], ["adm3"L, 1],      ["adm3a"L, 2], ["cdc456"L, 3],      ["dm1520"L, 4], ["gt100"L, 5],      ["h1000"L, 6], ["h1420"L, 7],      ["h1500"L, 8], ["h1510"L, 9],      ["h1520"L, 10], ["h2000"L, 11],      ["isc8001"L, 12], ["soroc"L, 13],      ["teletec"L, 14], ["trs80"L, 15],      ["vc303"L, 16], ["vt100"L, 17],      ["vt50"L, 18], ["vt50h"L, 19],      ["vt52"L, 20], ["x820"L, 21]];    refresh: ARRAY[0..4) OF Enumerated _ [      ["always"L, 0], ["never"L, 1],      ["half"L, 2], ["full"L, 3]];    items _ AllocateItemDescriptor[nItems, myZone];    items[0] _ StringItem[      tag: "String"L, place: [CharPos[0], line0], drawBox: TRUE, inHeap: TRUE, string: @data.stuff, z: myZone];    items[1] _ StringItem[      tag: "DataFile"L, place: [CharPos[33], line0], drawBox: TRUE, inHeap: TRUE, string: @data.dataFile, z: myZone];    items[2] _ NumberItem[      tag: "X"L, place: [CharPos[0], line1], value: @data.x, z: myZone,default:0];    items[3] _ NumberItem[      tag: "Y"L, place: [CharPos[33], line1], value: @data.y, z: myZone, default:0];    items[4] _ CommandItem[      tag: "Stuff"L, place: [CharPos[0], line2], proc: MyStuff, z: myZone];    items[5] _ CommandItem[      tag: "Jump"L, place: [CharPos[8], line2], proc: Jump, z: myZone];    items[6] _ CommandItem[      tag: "Clear"L, place: [CharPos[16], line2], proc: Clear, z: myZone];    items[7] _ CommandItem[      tag: "L"L, place: [CharPos[25], line2], proc: Left, z: myZone];    items[8] _ CommandItem[      tag: "R"L, place: [CharPos[30], line2], proc: Right, z: myZone];    items[9] _ CommandItem[      tag: "U"L, place: [CharPos[35], line2], proc: Up, z: myZone];    items[10] _ CommandItem[      tag: "D"L, place: [CharPos[40], line2], proc: Down, z: myZone];    items[11] _ CommandItem[      tag: "EOL"L, place: [CharPos[45], line2], proc: EOL, z: myZone];    items[12] _ CommandItem[      tag: "EOS"L, place: [CharPos[53], line2], proc: EOS, z: myZone];    items[13] _ CommandItem[      tag: "CL"L, place: [CharPos[60], line2], proc: CL, z: myZone];    items[14] _ CommandItem[      tag: "ChangeSW"L, place: [CharPos[0], line3], proc: Change, z: myZone];    items[15] _ CommandItem[      tag: "Test1"L, place: [CharPos[16], line3], proc: Test, z: myZone];    items[16] _ CommandItem[      tag: "Test2"L, place: [CharPos[30], line3], proc: Test2, z: myZone];    items[17] _ BooleanItem[      tag: "WriteToLog"L, place: [CharPos[45], line3], switch: @data.write, z: myZone];    items[18] _ CommandItem[      tag: "Test3"L, place: [CharPos[60], line3], proc: Test3, z: myZone];    items[19] _ EnumeratedItem[      tag: "Terminal"L, place: [CharPos[0], line4], proc: ChangeTerminal, choices: DESCRIPTOR[terminal], value: @data.terminal, z: myZone];    items[20] _ EnumeratedItem[      tag: "Refresh"L, place: [CharPos[30], line4], proc: SetRefresh, choices: DESCRIPTOR[refresh], value: @data.refresh, z: myZone];    items[21] _ CommandItem[      tag: "Options"L, place: [CharPos[60], line4], proc: MyOptions, z: myZone];    RETURN[items: items, freeDesc: TRUE];    };  DoWrite: FormSW.NotifyProcType = {    IF data.write THEN Emulator.StartLog[data.emuSW]     ELSE Emulator.StopLog[data.emuSW]};    CreateSW: PROC[sw: Window.Handle, clientData: LONG POINTER] = {    logName: STRING _ [40];    Tool.UnusedLogName[unused: logName, root: "EmuTest.log"L];    Emulator.Create[      sw:sw, data: Emulator.table[vt100], typeIn: StringProc,       otherData: Emulator.table[xvt52], logfile: logName, writeToLog: FALSE,      refresh: data.refresh];    };      okToStuff: BOOLEAN _ TRUE;    StringProc: UserInput.StringProcType = {    IF okToStuff THEN Emulator.PutString[window, string];    };      MakeSWs: Tool.MakeSWsProc =    BEGIN    logName: STRING _ [40];    Tool.UnusedLogName[unused: logName, root: "Sample.log"L];    data.msgSW _ Tool.MakeMsgSW[window: window];    data.formSW _ Tool.MakeFormSW[window: window, formProc: MakeForm,       zone: myZone];    data.emuSW _ Tool.MakeClientSW[      window, CreateSW, NIL, Emulator.EmuSWType];    END;  Init[];  -- this gets string out of global frame  END...  
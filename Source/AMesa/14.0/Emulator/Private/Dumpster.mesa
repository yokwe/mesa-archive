-- Dumpster.mesa-- Create by FormSWLayoutTool on  7-Dec-83 14:25:08-- BGY	28-Jul-85 14:50:28-- Copyright (C) Xerox Corporation 1983, 1984, 1985. All rights reserved.DIRECTORY  DumpsterOps,  Environment,  Format,  FormSW,  Heap,  MFile,  MSegment,  Put,  StateDefs,  String,  Tool,  ToolWindow,  UserTerminal,  Window;Dumpster: PROGRAM  IMPORTS    Format, FormSW, Heap, MFile, MSegment, Put, String, Tool, UserTerminal  EXPORTS    DumpsterOps = {  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = MACHINE DEPENDENT RECORD [    msgSW(0): Window.Handle ¬ NIL,    formSW(2): Window.Handle ¬ NIL,    fileSW(4): Window.Handle ¬ NIL,    file(6): LONG STRING ¬ NIL,    buf(8): LONG STRING ¬ NIL];  ActionType: TYPE = ARRAY StateDefs.Actions OF LONG STRING;  ActionList: TYPE = LONG POINTER TO ActionType;  BooleanType: TYPE = ARRAY StateDefs.BooleanParameters OF LONG STRING;  BooleanList: TYPE = LONG POINTER TO BooleanType;  NumericType: TYPE = ARRAY StateDefs.NumericParameters OF LONG STRING;  NumericList: TYPE = LONG POINTER TO NumericType;  KeyboardType: TYPE = ARRAY StateDefs.KeyboardValues OF LONG STRING;  KeyboardList: TYPE = LONG POINTER TO KeyboardType;    aList: ActionList ¬ NIL;  bList: BooleanList ¬ NIL;  nList: NumericList ¬ NIL;  kList: KeyboardList ¬ NIL;  data: DataHandle ¬ NIL;  wh: Window.Handle ¬ NIL;  z: PUBLIC UNCOUNTED ZONE ¬ Heap.Create[    initial:10, increment: 10, largeNodeThreshold: 256];  Msg: Format.StringProc = {Put.Text[data.msgSW, s]};  MyWrite: Format.StringProc = {Put.Text[data.fileSW, s]};  Write: Format.StringProc ¬ NIL;    DumpProc:  FormSW.ProcType = {    file: MFile.Handle ¬ NIL;    seg: MSegment.Handle ¬ NIL;    head: StateDefs.Handle ¬ NIL;    fileName: LONG STRING ¬ NIL;    IF String.Length[data.file] = 0 THEN {      Msg["Need a data file"L];      UserTerminal.BlinkDisplay[]};    fileName ¬ String.CopyToNewString[data.file,z,6];    String.AppendString[fileName, ".data"L];    file ¬ MFile.ReadOnly[fileName, []];    seg ¬ MSegment.Create[file: file, release: [],       pages: (file.GetLength/512+1)];    head ¬ seg.Address[];    Write ¬ MyWrite;    BEGIN    IF head.head.version # StateDefs.version THEN {      Write["Invalid data file: "L];      Write[fileName];      Write["\n"L];      GOTO quit;      };    DoDump[head];    EXITS quit => NULL;    END;    seg.Delete[];    z.FREE[@fileName];    Write["\n\n----------------------------------------\n\n"L];    };  Dump: PUBLIC PROC[    states: DumpsterOps.Handle, out: Format.StringProc ¬ NIL] = {    ClientTransition[NIL, inactive, active];    Write ¬ IF out = NIL THEN MyWrite ELSE out;    FOR i: CARDINAL IN [0..states.length) DO DoDump[states[i]] ENDLOOP;    ClientTransition[NIL, active, inactive];    };    AddChar: PROC[s: LONG STRING, c: CHARACTER] = {    String.AppendChar[s,c];    s[s.length] ¬ ' ;    };    AddString: PROC[s,t: LONG STRING] = {    String.AppendString[s,t];    s[s.length] ¬ ' ;    };    GetDigit: PROC[c: CHARACTER, digit: CARDINAL] RETURNS [new: CHARACTER] = {    t: Environment.Byte ¬ LOOPHOLE[c];    SELECT digit FROM      0 => t ¬ t/64;      1 => t ¬ (t/8) MOD 8;      2 => t ¬ t MOD 8;      ENDCASE;    new ¬ '0 + t;    };    PrintState: PROC[state: StateDefs.State, myIndex: CARDINAL] = {OPEN String;    last: CHARACTER ¬ '\177;    FOR i: CARDINAL IN [0..data.buf.maxlength) DO data.buf[i] ¬ '  ENDLOOP;    data.buf.length ¬ 0;    AppendNumber[data.buf, myIndex, 10];    data.buf.length ¬ 20;    SELECT state.char FROM      < '  => {AddChar[data.buf, '^]; AddChar[data.buf, state.char+100B]};      < last => AddChar[data.buf, state.char];      ENDCASE => {        AddChar[data.buf, '\\]; 	AddChar[data.buf, GetDigit[state.char,0]];	AddChar[data.buf, GetDigit[state.char,1]];	AddChar[data.buf, GetDigit[state.char,2]]};    data.buf.length ¬ 30;    IF ~state.eatChars THEN AddString[data.buf, "[]"L];    data.buf.length ¬ 34;    AddString[data.buf, aList[state.action]];    data.buf.length ¬ 74;    AddChar[data.buf, '(];    AppendNumber[data.buf, state.nextState, 10]; AddChar[data.buf,')];    Format.Line[Write, data.buf];    };    DoDump: PROC[head: StateDefs.Handle] = {    i: CARDINAL;    last: CHARACTER ¬ '\177;    chars:StateDefs.StringHeapHandle ¬       LOOPHOLE[@head.state[head.head.numberOfStates]];    FOR i IN [0..head.head.numberOfStates) DO      PrintState[head.state[i], i] ENDLOOP;    Write["\n\nBooleanParameters:\n  :"L];    FOR b: StateDefs.BooleanParameters IN StateDefs.BooleanParameters DO      IF head.bool[b] THEN {        Write[bList[b]]; Write[":"L]};       ENDLOOP;    Write["\n\nNumericParameters:\n  :"L];    FOR n: StateDefs.NumericParameters IN StateDefs.NumericParameters DO      IF head.num[n] # 0 THEN {        Write[nList[n]]; Write["#"L];	Format.Number[Write, head.num[n], []]; Write[":"L]};      ENDLOOP;    Write["\n\nKeyboardValues:\n  :"L];    FOR k: StateDefs.KeyboardValues IN StateDefs.KeyboardValues DO      IF head.key[k] # StateDefs.StringPtr[0,0] THEN {        Write[kList[k]]; Write["="L];	FOR i IN [head.key[k].start..head.key[k].start+head.key[k].length) DO	  SELECT chars[i] FROM	    < '  => {Write["^"L]; Format.Char[Write, chars[i]+100B]};	    < last => Format.Char[Write, chars[i]];	    ENDCASE => {	      Write["\\"L]; 	      Format.Char[Write, GetDigit[chars[i],0]];	      Format.Char[Write, GetDigit[chars[i],1]];	      Format.Char[Write, GetDigit[chars[i],2]]};	  ENDLOOP; 	Write[":"L]};      ENDLOOP;    };    ClientTransition: ToolWindow.TransitionProcType = {    SELECT TRUE FROM      old = inactive => {        IF data = NIL THEN data ¬ z.NEW[Data ¬ []];	InitLists[];	data.buf ¬ z.NEW[StringBody[120]];	};      new = inactive =>        IF data # NIL THEN {	  z.FREE[@data.buf];	  z.FREE[@data];	  FreeLists[];	  };      ENDCASE;    };  Init: PROCEDURE = {    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: inactive,      clientTransition: ClientTransition, name: "Dumpster"L,      cmSection: "Dumpster"L];    };  MakeSWs: Tool.MakeSWsProc = {    logName: LONG STRING ¬ [15];    Tool.UnusedLogName[unused: logName, root: "Dumpster.log"L];    data.msgSW ¬ Tool.MakeMsgSW[window: window];    data.formSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeForm];    data.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    };  MakeForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = 2;    items ¬ AllocateItemDescriptor[nItems];    items[0] ¬ StringItem[      tag: "File"L, place: [0, line0], inHeap: TRUE, string: @data.file];    items[1] ¬ CommandItem[      tag: "Dump"L, place: [0, line1], proc: DumpProc];    RETURN[items: items, freeDesc: TRUE];    };  Copy: PROC[s: LONG STRING, zone: UNCOUNTED ZONE]     RETURNS [new: LONG STRING] = {new ¬ String.CopyToNewString[s,zone]};      FreeActionList: PUBLIC PROC[actionList: ActionList] = {    FOR a: StateDefs.Actions IN StateDefs.Actions DO      IF actionList[a] # NIL THEN z.FREE[@actionList[a]] ENDLOOP;    z.FREE[@actionList];    };      FreeLists: PROC = {    FreeActionList[aList];    aList ¬ NIL;        FOR b: StateDefs.BooleanParameters IN StateDefs.BooleanParameters DO      IF bList[b] # NIL THEN z.FREE[@bList[b]] ENDLOOP;    z.FREE[@bList];    bList ¬ NIL;        FOR n: StateDefs.NumericParameters IN StateDefs.NumericParameters DO      IF nList[n] # NIL THEN z.FREE[@nList[n]] ENDLOOP;    z.FREE[@nList];    nList ¬ NIL;        FOR k: StateDefs.KeyboardValues IN StateDefs.KeyboardValues DO      IF kList[k] # NIL THEN z.FREE[@kList[k]] ENDLOOP;    z.FREE[@kList];    kList ¬ NIL;    };    GetActionList: PUBLIC PROC RETURNS[actionList: ActionList]= {    actionList ¬ z.NEW[ActionType ¬ [AddBlankLine: Copy["AddBlankLine"L, z], ANSIOn: Copy["ANSIOn"L, z], AutoRepeatOff: Copy["AutoRepeatOff"L, z], AutoRepeatOn: Copy["AutoRepeatOn"L, z], BackTab: Copy["BackTab"L, z], Bell: Copy["Bell"L, z], BlinkOff: Copy["BlinkOff"L, z], BlinkOn: Copy["BlinkOn"L, z], BoldOff: Copy["BoldOff"L, z], BoldOn: Copy["BoldOn"L, z], CarriageReturn: Copy["CarriageReturn"L, z], CharAttributeOff: Copy["CharAttributeOff"L, z], CharAttributeOptions: Copy["CharAttributeOptions"L, z], ClearTabOptions: Copy["ClearTabOptions"L, z], CollectFirstParam: Copy["CollectFirstParam"L, z], CollectParam: Copy["CollectParam"L, z], CollectXValue: Copy["CollectXValue"L, z], CollectYValue: Copy["CollectYValue"L, z], CursorAddress: Copy["CursorAddress"L, z], CursorBackward: Copy["CursorBackward"L, z], CursorDown: Copy["CursorDown"L, z], CursorDownHalf: Copy["CursorDownHalf"L, z], CursorForward: Copy["CursorForward"L, z], CursorKeyApplication: Copy["CursorKeyApplication"L, z], CursorKeyNormal: Copy["CursorKeyNormal"L, z], CursorMotionHorizontal: Copy["CursorMotionHorizontal"L, z], CursorMotionVertical: Copy["CursorMotionVertical"L, z], CursorPositionReport: Copy["CursorPositionReport"L, z], CursorUp: Copy["CursorUp"L, z], CursorUpHalf: Copy["CursorUpHalf"L, z], DeleteChar: Copy["DeleteChar"L, z], DeleteLine: Copy["DeleteLine"L, z], DeleteModeOff: Copy["DeleteModeOff"L, z], DeleteModeOn: Copy["DeleteModeOn"L, z], Delimiter: Copy["Delimiter"L, z], DoubleBottom: Copy["DoubleBottom"L, z], DoubleTop: Copy["DoubleTop"L, z], DoubleWidth: Copy["DoubleWidth"L, z], EraseLineOptions: Copy["EraseLineOptions"L, z], EraseScreen: Copy["EraseScreen"L, z], EraseScreenOptions: Copy["EraseScreenOptions"L, z], EraseToEOL: Copy["EraseToEOL"L, z], EraseToEOS: Copy["EraseToEOS"L, z], ErrorState: Copy["ErrorState"L, z], FillWithEs: Copy["FillWithEs"L, z], G0GrafCharSet: Copy["G0GrafCharSet"L, z], G0ROMCharSet: Copy["G0ROMCharSet"L, z], G0ROMsCharSet: Copy["G0ROMsCharSet"L, z], G0UKCharSet: Copy["G0UKCharSet"L, z], G0USCharSet: Copy["G0USCharSet"L, z], G1GrafCharSet: Copy["G1GrafCharSet"L, z], G1ROMCharSet: Copy["G1ROMCharSet"L, z], G1ROMsCharSet: Copy["G1ROMsCharSet"L, z], G1UKCharSet: Copy["G1UKCharSet"L, z], G1USCharSet: Copy["G1USCharSet"L, z], GraphicsOff: Copy["GraphicsOff"L, z], GraphicsOn: Copy["GraphicsOn"L, z], HomeCursor: Copy["HomeCursor"L, z], Index: Copy["Index"L, z], InitBracket: Copy["InitBracket"L, z], InitEscape: Copy["InitEscape"L, z], InitLParen: Copy["InitLParen"L, z], InitParams: Copy["InitParams"L, z], InitRParen: Copy["InitRParen"L, z], InitPound: Copy["InitPound"L, z], InsertChar: Copy["InsertChar"L, z], InsertModeOff: Copy["InsertModeOff"L, z], InsertModeOn: Copy["InsertModeOn"L, z], InterlaceOff: Copy["InterlaceOff"L, z], InterlaceOn: Copy["InterlaceOn"L, z], InvokeTests: Copy["InvokeTests"L, z], JumpLastLine: Copy["JumpLastLine"L, z], KeyPadApplication: Copy["KeyPadApplication"L, z], KeyPadNormal: Copy["KeyPadNormal"L, z], LEDOptions: Copy["LEDOptions"L, z], LineFeed: Copy["LineFeed"L, z], NextLine: Copy["NextLine"L, z], NullState: Copy["NullState"L, z], OpenModeOff: Copy["OpenModeOff"L, z], OpenModeOn: Copy["OpenModeOn"L, z], PadCharacter: Copy["PadCharacter"L, z], Reset: Copy["Reset"L, z], ResetMode: Copy["ResetMode"L, z], RestoreCursor: Copy["RestoreCursor"L, z], ReverseIndex: Copy["ReverseIndex"L, z], ReverseLineFeed: Copy["ReverseLineFeed"L, z], ReverseVideo: Copy["ReverseVideo"L, z], SaveCursor: Copy["SaveCursor"L, z], ScrollForward: Copy["ScrollForward"L, z], ScrollingRegion: Copy["ScrollingRegion"L, z], ScrollOff: Copy["ScrollOff"L, z], ScrollOn: Copy["ScrollOn"L, z], ScrollReverse: Copy["ScrollReverse"L, z], Set132Column: Copy["Set132Column"L, z], Set80Column: Copy["Set80Column"L, z], SetAbsoluteOrigin: Copy["SetAbsoluteOrigin"L, z], SetJumpScroll: Copy["SetJumpScroll"L, z], SetLineFeed: Copy["SetLineFeed"L, z], SetMode: Copy["SetMode"L, z], SetNewLine: Copy["SetNewLine"L, z], SetNormalScreen: Copy["SetNormalScreen"L, z], SetRelativeOrigin: Copy["SetRelativeOrigin"L, z], SetReverseScreen: Copy["SetReverseScreen"L, z], SetSmoothScroll: Copy["SetSmoothScroll"L, z], SetTab: Copy["SetTab"L, z], SingleWidth: Copy["SingleWidth"L, z], StandOutModeOff: Copy["StandOutModeOff"L, z], StandOutModeOn: Copy["StandOutModeOn"L, z], StatusReport: Copy["StatusReport"L, z], StuffChar: Copy["StuffChar"L, z], SubXDiff: Copy["SubXDiff"L, z], SubYDiff: Copy["SubYDiff"L, z], Tab: Copy["Tab"L, z], UnderscoreOff: Copy["UnderscoreOff"L, z], UnderscoreOn: Copy["UnderscoreOn"L, z], VisibleBell: Copy["VisibleBell"L, z], VT52On: Copy["VT52On"L, z], WrapOff: Copy["WrapOff"L, z], WrapOn: Copy["WrapOn"L, z], ZZZZZZZ: Copy["ZZZZZZZ"L, z]]];  };    InitLists: PROC = {    aList ¬ GetActionList[];        bList ¬ z.NEW[BooleanType ¬ [automaticMargins: Copy["automaticMargins"L, z], autoWrap: Copy["autoWrap"L, z], backspaceWraps: Copy["backspaceWraps"L, z], CRTbutNoScroll: Copy["CRTbutNoScroll"L, z], displayMayBeRetainedAbove: Copy["displayMayBeRetainedAbove"L, z], displayMayBeRetainedBelow: Copy["displayMayBeRetainedBelow"L, z], hardwareTabs: Copy["hardwareTabs"L, z], homeOnClear: Copy["homeOnClear"L, z], newlineIgnoredAfterWrap: Copy["newlineIgnoredAfterWrap"L, z], noCarriageReturn: Copy["noCarriageReturn"L, z], overstrike: Copy["overstrike"L, z], standoutNotErasedByOverwrite: Copy["standoutNotErasedByOverwrite"L, z], tabsDestructive: Copy["tabsDestructive"L, z]]];        nList ¬ z.NEW[NumericType ¬ [columnsInLine: Copy["columnsInLine"L, z], linesOnPage: Copy["linesOnPage"L, z], margin: Copy["margin"L, z], maxColumns: Copy["maxColumns"L, z], XDiff: Copy["XDiff"L, z], YDiff: Copy["YDiff"L, z]]];        kList ¬ z.NEW[KeyboardType ¬ [arrowKey: Copy["arrowKey"L, z], backspaceKey: Copy["backspaceKey"L, z], cursorPosition: Copy["cursorPosition"L, z], deleteKey: Copy["deleteKey"L, z], deviceAttributes: Copy["deviceAttributes"L, z], downArrowKey: Copy["downArrowKey"L, z], enterKey: Copy["enterKey"L, z], escapeKey: Copy["escapeKey"L, z], function0: Copy["function0"L, z], function1: Copy["function1"L, z], function2: Copy["function2"L, z], function3: Copy["function3"L, z], function4: Copy["function4"L, z], function5: Copy["function5"L, z], function6: Copy["function6"L, z], function7: Copy["function7"L, z], function8: Copy["function8"L, z], function9: Copy["function9"L, z], homeKey: Copy["homeKey"L, z], identifyTerminal: Copy["identifyTerminal"L, z], keypad0: Copy["keypad0"L, z], keypad1: Copy["keypad1"L, z], keypad2: Copy["keypad2"L, z], keypad3: Copy["keypad3"L, z], keypad4: Copy["keypad4"L, z], keypad5: Copy["keypad5"L, z], keypad6: Copy["keypad6"L, z], keypad7: Copy["keypad7"L, z], keypad8: Copy["keypad8"L, z], keypad9: Copy["keypad9"L, z], keypadComma: Copy["keypadComma"L, z], keypadMinus: Copy["keypadMinus"L, z], keypadPeriod: Copy["keypadPeriod"L, z], leftArrowKey: Copy["leftArrowKey"L, z], linefeedKey: Copy["linefeedKey"L, z], noscrollKey: Copy["noscrollKey"L, z], rightArrowKey: Copy["rightArrowKey"L, z], setupKey: Copy["setupKey"L, z], upArrowKey: Copy["upArrowKey"L, z]]];        };    -- Mainline code  Init[];  -- this gets string out of global frame  }...    
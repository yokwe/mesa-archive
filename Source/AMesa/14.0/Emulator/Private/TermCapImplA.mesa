-- File: TermCapImplA.mesa - last edit by:-- LGR	18-Mar-83 18:24:17-- BGY	28-Jul-85 14:28:58-- Scanning of TermCap entry and simple parsing.-- Copyright (C) Xerox Corporation 1983, 1984, 1985. All rights reserved.DIRECTORY  Ascii,  Heap USING [systemZone],  Stream USING [EndOfStream, GetByte, GetChar, GetPosition, Handle],  String USING [AppendChar, AppendCharAndGrow, StringBoundsFault,     StringToNumber, StringToOctal],  StateDefs,  TermCap;TermCapImplA: PROGRAM   IMPORTS Heap, Stream, String    EXPORTS TermCap=  BEGIN  SyntaxError: PUBLIC SIGNAL[pos: LONG CARDINAL, code: TermCap.ErrorCode] = CODE;BadCode: PUBLIC SIGNAL[pos: LONG CARDINAL, s: LONG STRING] = CODE;z: UNCOUNTED ZONE = Heap.systemZone;  UPARROW: CHAR = 136C;    ParseCapas: PUBLIC PROCEDURE [    data: StateDefs.Handle,     keyboard: StateDefs.KeyBoardHandle,    temp: StateDefs.CommandHandle,    h: Stream.Handle]  = {    OPEN data;    i: StateDefs.Actions;    m: StateDefs.BooleanParameters;    n: StateDefs.NumericParameters;    b,c: CHARACTER;    BEGIN    FOR i IN StateDefs.Actions DO temp[i] ¬ NIL ENDLOOP;    FOR n IN StateDefs.NumericParameters DO num [n] ¬ 0 ENDLOOP;    FOR m IN StateDefs.BooleanParameters DO bool[m] ¬ FALSE ENDLOOP;    data.head.version ¬ StateDefs.version;    WHILE Stream.GetChar[h] # ': DO ENDLOOP; -- clean up titles    DO ENABLE Stream.EndOfStream => EXIT;     SELECT (b ¬ Stream.GetChar[h]) FROM      ': => NULL;      '\\ => IF Stream.GetChar[h] = Ascii.CR THEN {          WHILE Stream.GetChar[h] # ': DO ENDLOOP;	  LOOP}         ELSE {	  SIGNAL SyntaxError[	    LOOPHOLE[h.GetPosition[], LONG CARDINAL]-1, expectingCR];	  WHILE Stream.GetChar[h] # ': DO ENDLOOP};      'a => SELECT (c ¬ Stream.GetChar[h]) FROM        'e => temp[G1ROMCharSet] ¬ GetString[h];	'l => temp[AddBlankLine] ¬ GetString[h];	'm => {bool[automaticMargins] ¬ TRUE; ConsumeDelimiter[h]};	's => temp[G0ROMCharSet] ¬ GetString[h];	'w =>  {bool[autoWrap] ¬ TRUE; ConsumeDelimiter[h]};	ENDCASE => Fix[h,b,c];      'b => SELECT (c ¬ Stream.GetChar[h]) FROM        'c => temp[CursorBackward] ¬ GetString[h];        'l => temp[Bell] ¬ GetString[h];	't => temp[BackTab] ¬ GetString[h];	'w =>  {bool[backspaceWraps] ¬ TRUE; ConsumeDelimiter[h]};	ENDCASE => Fix[h,b,c];      'c => SELECT (c ¬ Stream.GetChar[h]) FROM        'd => temp[EraseToEOS] ¬ GetString[h];	'e => temp[EraseToEOL] ¬ GetString[h];	'h => temp[CursorMotionHorizontal] ¬ GetString[h];	'l => temp[EraseScreen] ¬ GetString[h];	'm => temp[CursorAddress] ¬ GetString[h];	'o => num[columnsInLine] ¬ GetNum[h];	'p => keyboard[cursorPosition] ¬ GetString[h];	'r => temp[CarriageReturn] ¬ GetString[h];	's => temp[ScrollingRegion] ¬ GetString[h];	'v => temp[CursorMotionVertical] ¬ GetString[h];	ENDCASE => Fix[h,b,c];      'd => SELECT (c ¬ Stream.GetChar[h]) FROM        'a =>  {bool[displayMayBeRetainedAbove] ¬ TRUE; ConsumeDelimiter[h]};	'b => {bool[displayMayBeRetainedBelow] ¬ TRUE; ConsumeDelimiter[h]};	'c => temp[DeleteChar] ¬ GetString[h];	'l => temp[DeleteLine] ¬ GetString[h];	'm => temp[DeleteModeOn] ¬ GetString[h];	'o => temp[LineFeed] ¬ GetString[h];	'v => keyboard[deviceAttributes] ¬ GetString[h];	'x => num[XDiff] ¬ GetNum[h];	'y => num[YDiff] ¬ GetNum[h];	ENDCASE => Fix[h,b,c];      'e => SELECT (c ¬ Stream.GetChar[h]) FROM        'd => temp[DeleteModeOff] ¬ GetString[h];	'i => temp[InsertModeOff] ¬ GetString[h];	'k => keyboard[enterKey] ¬ GetString[h];	's => keyboard[escapeKey] ¬ GetString[h];	ENDCASE => Fix[h,b,c];      'h => SELECT (c ¬ Stream.GetChar[h]) FROM	'c => {bool[homeOnClear] ¬ TRUE; ConsumeDelimiter[h]};	'd => temp[CursorDownHalf] ¬ GetString[h];	'o => temp[HomeCursor] ¬ GetString[h];	'u => temp[CursorUpHalf] ¬ GetString[h];	ENDCASE => Fix[h,b,c];      'i => SELECT (c ¬ Stream.GetChar[h]) FROM        'c => temp[InsertChar] ¬ GetString[h];        'd => keyboard[identifyTerminal] ¬ GetString[h];	'm => temp[InsertModeOn] ¬ GetString[h];	ENDCASE => Fix[h,b,c];      'k => SELECT (c ¬ Stream.GetChar[h]) FROM        '0 => keyboard[keypad0] ¬ GetString[h];	'1 => keyboard[keypad1] ¬ GetString[h];	'2 => keyboard[keypad2] ¬ GetString[h];	'3 => keyboard[keypad3] ¬ GetString[h];	'4 => keyboard[keypad4] ¬ GetString[h];	'5 => keyboard[keypad5] ¬ GetString[h];	'6 => keyboard[keypad6] ¬ GetString[h];	'7 => keyboard[keypad7] ¬ GetString[h];	'8 => keyboard[keypad8] ¬ GetString[h];	'9 => keyboard[keypad9] ¬ GetString[h];	'b => keyboard[backspaceKey] ¬ GetString[h];	'c => keyboard[keypadComma] ¬ GetString[h];	'd => keyboard[downArrowKey] ¬ GetString[h];	'e => temp[KeyPadNormal] ¬ GetString[h];	'h => keyboard[homeKey] ¬ GetString[h];	'l => keyboard[leftArrowKey] ¬ GetString[h];	'm => keyboard[keypadMinus] ¬ GetString[h];	'n => keyboard[noscrollKey] ¬ GetString[h];	'p => keyboard[keypadPeriod] ¬ GetString[h];	'r => keyboard[rightArrowKey] ¬ GetString[h];	's => temp[KeyPadApplication] ¬ GetString[h];	'u => keyboard[upArrowKey] ¬ GetString[h];	'x => keyboard[deleteKey] ¬ GetString[h];	ENDCASE => Fix[h,b,c];      'l => SELECT (c ¬ Stream.GetChar[h]) FROM        '0 => keyboard[function0] ¬ GetString[h];	'1 => keyboard[function1] ¬ GetString[h];	'2 => keyboard[function2] ¬ GetString[h];	'3 => keyboard[function3] ¬ GetString[h];	'4 => keyboard[function4] ¬ GetString[h];	'5 => keyboard[function5] ¬ GetString[h];	'6 => keyboard[function6] ¬ GetString[h];	'7 => keyboard[function7] ¬ GetString[h];	'8 => keyboard[function8] ¬ GetString[h];	'9 => keyboard[function9] ¬ GetString[h];	'e => temp[CursorBackward] ¬ GetString[h];	'f => keyboard[linefeedKey] ¬ GetString[h];	'i => num[linesOnPage] ¬ GetNum[h];	'l => temp[JumpLastLine] ¬ GetString[h];	ENDCASE => Fix[h,b,c];      'm => SELECT (c ¬ Stream.GetChar[h]) FROM        'a => keyboard[arrowKey] ¬ GetString[h];        'b => temp[BlinkOn] ¬ GetString[h];	'c => num[maxColumns] ¬ GetNum[h];        'd => temp[BoldOn] ¬ GetString[h];        'e => temp[CharAttributeOff] ¬ GetString[h];	'r => temp[ReverseVideo] ¬ GetString[h];	ENDCASE => Fix[h,b,c];      'n => SELECT (c ¬ Stream.GetChar[h]) FROM        'c => {bool[noCarriageReturn] ¬ TRUE; ConsumeDelimiter[h]};	'd => temp[CursorForward] ¬ GetString[h];	'l => temp[NextLine] ¬ GetString[h];	's => {bool[CRTbutNoScroll] ¬ TRUE; ConsumeDelimiter[h]};	ENDCASE => Fix[h,b,c];      'p => SELECT (c ¬ Stream.GetChar[h]) FROM        'c => temp[PadCharacter] ¬ GetString[h];	't => {bool[hardwareTabs] ¬ TRUE; ConsumeDelimiter[h]};	ENDCASE => Fix[h,b,c];      's => SELECT (c ¬ Stream.GetChar[h]) FROM        'c => temp[SaveCursor] ¬ GetString[h];        'e => temp[StandOutModeOff] ¬ GetString[h];	'f => temp[ScrollForward] ¬ GetString[h];	'o => temp[StandOutModeOn] ¬ GetString[h];	'r => temp[ScrollReverse] ¬ GetString[h];	'u => keyboard[setupKey] ¬ GetString[h];	ENDCASE => Fix[h,b,c];      't => SELECT (c ¬ Stream.GetChar[h]) FROM        'a => temp[Tab] ¬ GetString[h];	ENDCASE => Fix[h,b,c];      'u => SELECT (c ¬ Stream.GetChar[h]) FROM	'e => temp[UnderscoreOff] ¬ GetString[h];	'p => temp[ReverseLineFeed] ¬ GetString[h];	's => temp[UnderscoreOn] ¬ GetString[h];	ENDCASE => Fix[h,b,c];      'v => SELECT (c ¬ Stream.GetChar[h]) FROM	'b => temp[VisibleBell] ¬ GetString[h];	'e => temp[OpenModeOff] ¬ GetString[h];	's => temp[OpenModeOn] ¬ GetString[h];	ENDCASE => Fix[h,b,c];      'x => SELECT (c ¬ Stream.GetChar[h]) FROM	'n => {bool[newlineIgnoredAfterWrap] ¬ TRUE; ConsumeDelimiter[h]};	's => {bool[standoutNotErasedByOverwrite] ¬ TRUE; ConsumeDelimiter[h]};	't => {bool[tabsDestructive] ¬ TRUE; ConsumeDelimiter[h]};	ENDCASE => Fix[h,b,c];      ENDCASE => Fix[h,b,Stream.GetChar[h]];      ENDLOOP;     END;    };Fix: PROC [h: Stream.Handle, b,c : CHARACTER] = {  my: LONG STRING ¬ z.NEW[StringBody[80]];  pos: LONG CARDINAL ¬ LOOPHOLE[h.GetPosition[], LONG CARDINAL] -2;  BEGIN ENABLE String.StringBoundsFault => {    ns ¬ z.NEW[StringBody[2*s.length]];    FOR i:CARDINAL IN [0..s.length) DO ns[i] ¬ s[i]; ENDLOOP;    ns.length ¬ s.length;    z.FREE[@s];    my ¬ ns;    };  String.AppendChar[my, b];  String.AppendChar[my, c];  WHILE (c ¬ Stream.GetChar[h]) # ': DO String.AppendChar[my, c] ENDLOOP;  SIGNAL BadCode[pos, my];  END;  z.FREE[@my];  };  ReadFile: PROCEDURE [h: Stream.Handle] RETURNS [LONG STRING] = {  WHILE Stream.GetChar[h] # ': DO ENDLOOP;  RETURN[NIL]}; GetString: PROCEDURE [h: Stream.Handle] RETURNS [s: LONG STRING] =    BEGIN  c: CHARACTER;  s ¬ z.NEW[StringBody[10]];  IF Stream.GetChar[h] # '= THEN {    SIGNAL SyntaxError[LOOPHOLE[h.GetPosition[], LONG CARDINAL]-1,expectingEqual];    WHILE Stream.GetChar[h] # ': DO ENDLOOP;    RETURN};  DO -- skip delay info    c ¬ Stream.GetChar[h];    SELECT c FROM      IN ['0..'9], '. => LOOP;      '* => {c ¬ Stream.GetChar[h]; EXIT};      ENDCASE => EXIT;    ENDLOOP;  WHILE c # ': DO      SELECT c FROM       '\\ => 	  SELECT (c ¬ Stream.GetChar[h]) FROM	    IN ['0..'3] => {	      OctDig: TYPE = CHARACTER['0..'7];	      esc: STRING ¬ [3];	      esc.length ¬ 3;	      esc[0] ¬ c;	      IF (esc[1] ¬ Stream.GetChar[h]) IN OctDig AND 	         (esc[2] ¬ Stream.GetChar[h]) IN OctDig THEN 		    {c ¬ VAL[String.StringToOctal[esc]];		     IF c = 200C THEN c ¬ Ascii.NUL} -- hack around C kludgery	      ELSE {	        SIGNAL SyntaxError[		  LOOPHOLE[h.GetPosition[], LONG CARDINAL]-1, badOctal];		WHILE Stream.GetChar[h] # ': DO ENDLOOP;		RETURN};	      };	    'n, 'N, 'r, 'R => c ¬ Ascii.CR;	    'E => c ¬ Ascii.ESC;	    't, 'T => c ¬ Ascii.TAB;	    'b, 'B => c ¬ Ascii.BS;	    'f, 'F => c ¬ Ascii.FF;	    'l, 'L => c ¬ Ascii.LF;	    UPARROW, '\\ => NULL;	    Ascii.CR => {c ¬ Stream.GetChar[h]; LOOP};	    ENDCASE => {	      SIGNAL SyntaxError[	        LOOPHOLE[h.GetPosition[], LONG CARDINAL]-1, cantFollowBS];	      WHILE Stream.GetChar[h] # ': DO ENDLOOP;	      RETURN};       UPARROW => c ¬ VAL[Stream.GetByte[h] MOD 40B];	ENDCASE;    String.AppendCharAndGrow[@s, c, z];    c ¬ Stream.GetChar[h];    ENDLOOP;  END;    ConsumeDelimiter: PROCEDURE [h: Stream.Handle] = INLINE   BEGIN  IF Stream.GetChar[h] # ': THEN {    SIGNAL SyntaxError[LOOPHOLE[h.GetPosition[], LONG CARDINAL]-1, badDelimiter];    WHILE Stream.GetChar[h] # ': DO ENDLOOP};  END;    GetNum: PROCEDURE [h: Stream.Handle] RETURNS [n: CARDINAL] =   BEGIN  str: LONG STRING ¬ [20];  c: CHARACTER;  IF Stream.GetChar[h] # '# THEN {    SIGNAL SyntaxError[      LOOPHOLE[h.GetPosition[], LONG CARDINAL]-1, expectingPound];    WHILE Stream.GetChar[h] # ': DO ENDLOOP;    RETURN};  WHILE (c ¬ Stream.GetChar[h]) # ': DO    String.AppendChar[str, c];    ENDLOOP;  n ¬ String.StringToNumber[str];  END;      -- Mainline code  END...  
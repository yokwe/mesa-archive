-- EmulatorsF.mesa-- Create by FormSWLayoutTool on  7-Dec-83 16:38:24-- BGY     	28-Jul-85 13:13:00-- Copyright (C) 1984 by Xerox Corporation. All rights reserved.DIRECTORY  Atom USING [ATOM, MakeAtom],  Context USING [Create, Data, Find, Type, UniqueType],  Display USING [Handle, Invert, replaceFlags, Text, White],  Emulator USING [Error],  EmulatorOps USING [    ActOnCaret, EContext, FindContext, GetRealPlace, LMargin,     ReleaseContext, TabArray, zone],  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, CommandItem,     Enumerated, EnumeratedItem, line0, line1, line2, line3, line5, ProcType],  String USING [AppendString],  TIP USING [CreateClient, First, mouseTIP, NotifyProc, Rest, Results],  Tool USING [    Create, Destroy, MakeClientSW, MakeFormSW, MakeMsgSW,     MakeSWsProc, RegisterSWType, SWType],  ToolWindow USING [TransitionProcType, WindowForSubwindow],  UserInput USING [CreatePeriodicNotify, PeriodicProcType],  Window USING [Box, Dims, GetBox, Handle, Place, SetDisplayProc],  WindowFont USING [CharWidth];EmulatorsF: MONITOR  IMPORTS    Atom, Context, Display, Emulator, EmulatorOps, FormSW, Tool,     String, TIP, ToolWindow, UserInput, Window, WindowFont   EXPORTS Emulator, EmulatorOps = {  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = MACHINE DEPENDENT RECORD [    msgSW(0): Window.Handle ¬ NIL,    formSW(2): Window.Handle ¬ NIL,    fileSW(4): Window.Handle ¬ NIL,    scroll(6): BOOLEAN ¬ FALSE,    marginBell(7): BOOLEAN ¬ FALSE,    wrap(8): BOOLEAN ¬ FALSE,    autoRepeat(9): BOOLEAN ¬ FALSE,    keyClick(10): BOOLEAN ¬ FALSE,    newLine(11): BOOLEAN ¬ FALSE,    screen(12): BOOLEAN ¬ FALSE,    emulate(13): BOOLEAN ¬ FALSE,    columns(14): BOOLEAN ¬ FALSE,    cursor(15): BOOLEAN ¬ FALSE,    autoXON(16): BOOLEAN ¬ FALSE,    apply(17): BOOLEAN ¬ FALSE,    sw(18): Window.Handle ¬ NIL,    tabSW(20): Window.Handle ¬ NIL,    c(22): EmulatorOps.EContext ¬ NIL,    box(24): Window.Box ¬ [[0,0],[0,0]],    tabs(28): EmulatorOps.TabArray ¬ ALL[FALSE]];  myZone: UNCOUNTED ZONE ¬ EmulatorOps.zone;  cntxt: Context.Type ¬ Context.UniqueType[];  tabString, underline: LONG STRING ¬ NIL;  mySWType: Tool.SWType ¬ Tool.RegisterSWType[];  Point, Adjust: Atom.ATOM ¬ NIL;    Init: SIGNAL[stuff: DataHandle] = CODE;    Apply:  FormSW.ProcType = {    data: DataHandle ¬ GetSWContext[sw];    data.apply ¬ TRUE;    [] ¬ UserInput.CreatePeriodicNotify[      KillOptions, ToolWindow.WindowForSubwindow[sw], 0];    };  Abort:  FormSW.ProcType = {    data: DataHandle ¬ GetSWContext[sw];    data.apply ¬ FALSE;    [] ¬ UserInput.CreatePeriodicNotify[      KillOptions, ToolWindow.WindowForSubwindow[sw], 0];    };  KillOptions: PUBLIC ENTRY UserInput.PeriodicProcType = {    ENABLE UNWIND => NULL;    data: DataHandle ¬ GetContext[window];    IF data = NIL THEN RETURN;    Tool.Destroy[window];    };    GetContext: PROC [window: Window.Handle] RETURNS [DataHandle] = INLINE{    RETURN[Context.Find[cntxt, window]]};  GetSWContext: PROC [sw: Window.Handle] RETURNS [DataHandle] = INLINE{    RETURN[Context.Find[cntxt, ToolWindow.WindowForSubwindow[sw]]]};  ClientTransition: ToolWindow.TransitionProcType = {    data: DataHandle ¬ GetContext[window];    SELECT TRUE FROM      old = inactive =>        IF data = NIL THEN {	  data ¬ myZone.NEW[Data ¬ []];	  SIGNAL Init[data];	  Context.Create[cntxt, data, DestroyCntxt, window]};      new = inactive =>        IF data # NIL THEN [] ¬ UserInput.CreatePeriodicNotify[	  KillOptions, window, 0];      ENDCASE;    };  DestroyCntxt: PROCEDURE [data: DataHandle, w: Window.Handle] ={    IF data.apply THEN {      c: EmulatorOps.EContext ¬ EmulatorOps.FindContext[data.sw];      IF c  = NIL THEN RETURN;      BEGIN ENABLE UNWIND => EmulatorOps.ReleaseContext[data.sw];      EmulatorOps.ActOnCaret[c, clear];      c.marginBell ¬ data.marginBell;      c.wrap ¬ data.wrap;      c.autoRepeat ¬ data.autoRepeat;      c.keyClick ¬ data.keyClick;      c.lineFeed ¬ data.newLine;      c.cursorFlat ¬ ~data.cursor;      c.autoXON ¬ data.autoXON;      c.tabs ¬ data.tabs;      c.optionWindow ¬ NIL;      END;      EmulatorOps.ReleaseContext[data.sw];      };    myZone.FREE[@data];    };    SetContext: PROC[data: DataHandle, c: EmulatorOps.EContext] = {    data.marginBell ¬ c.marginBell;    data.wrap ¬ c.wrap;    data.autoRepeat ¬ c.autoRepeat;    data.keyClick ¬ c.keyClick;    data.newLine ¬ c.lineFeed;    data.cursor ¬ ~c.cursorFlat;    data.autoXON ¬ c.autoXON;    data.columns ¬ c.columns = 132;    data.emulate ¬ c.type = primary;    data.tabs ¬ c.tabs;    data.c ¬ c;    data.box ¬ [EmulatorOps.GetRealPlace[c, 0, 3], [      h: c.fonts[normal].height, w: 132 * c.fonts[normal].maxWidth]];    };    CreateOptionsSheet: PUBLIC PROC[sw:Window.Handle] = {    c: EmulatorOps.EContext ¬ EmulatorOps.FindContext[sw];    data: DataHandle ¬ NIL;    IF c = NIL THEN ERROR Emulator.Error[notAEmuSW];    BEGIN ENABLE UNWIND => EmulatorOps.ReleaseContext[sw];    c.optionWindow ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default,      clientTransition: ClientTransition, name: "Options"L,      cmSection: "Options"L! Init => {SetContext[stuff,c]; RESUME}];    data ¬ GetContext[c.optionWindow];    data.sw ¬ c.sw;    END;    EmulatorOps.ReleaseContext[sw];    };  TabDisplay: PROC[sw: Window.Handle] = {    data: DataHandle ¬ GetSWContext[sw];    start: Window.Place;    dims: Window.Dims;    IF data = NIL THEN RETURN;    start ¬ data.box.place;    Display.White[sw, [[0,0], sw.GetBox[].dims]];    [] ¬ Display.Text[window: sw, string: tabString,       place: start, font: data.c.fonts[normal], flags: Display.replaceFlags];    [] ¬ Display.Text[window: sw, string: underline,       place: EmulatorOps.GetRealPlace[data.c, 0, 4],      font: data.c.fonts[normal], flags: Display.replaceFlags];    dims ¬ [w: data.c.fonts[normal].maxWidth, h: data.c.fonts[normal].height];    FOR i: CARDINAL IN [0..132) DO      IF data.tabs[i] THEN         Display.Invert[sw, [EmulatorOps.GetRealPlace[data.c,i,3], dims]];      ENDLOOP;    };    TIPMe: PUBLIC TIP.NotifyProc = {    coords: Window.Place;    FOR input: TIP.Results ¬ results, input.Rest[] UNTIL input = NIL DO      WITH z: input.First[] SELECT FROM        atom => { SELECT z.a FROM	  Point => Select[window, coords];	  Adjust => Clear[window, coords];	  ENDCASE;	  };        coords => coords ¬ z.place;        ENDCASE;      ENDLOOP;    };      Select: PROC[sw: Window.Handle, coords: Window.Place] = {    data: DataHandle ¬ GetSWContext[sw];    i: CARDINAL ¬ 0;    ok: BOOLEAN ¬ FALSE;    [ok, i] ¬ Resolve[data, coords];    IF ~ ok OR data.tabs[i] THEN RETURN;    data.tabs[i] ¬ TRUE;    Display.Invert[sw,[EmulatorOps.GetRealPlace[data.c, i, 3],       [w: data.c.fonts[normal].maxWidth, h: data.c.fonts[normal].height]]];    };    Clear: PROC[sw: Window.Handle, coords: Window.Place] = {    data: DataHandle ¬ GetSWContext[sw];    i: CARDINAL ¬ 0;    ok: BOOLEAN ¬ FALSE;    [ok, i] ¬ Resolve[data, coords];    IF ~ ok OR ~data.tabs[i] THEN RETURN;    data.tabs[i] ¬ FALSE;    Display.Invert[sw,[EmulatorOps.GetRealPlace[data.c, i, 3],       [w: data.c.fonts[normal].maxWidth, h: data.c.fonts[normal].height]]];    };    Resolve: PROC[data: DataHandle, coords: Window.Place]     RETURNS[ok: BOOLEAN ¬ FALSE, index: CARDINAL ¬ 0] ={    IF ~(coords.y IN [data.box.place.y..data.box.place.y+data.box.dims.h])       THEN RETURN;    IF ~(coords.x IN [EmulatorOps.LMargin..EmulatorOps.LMargin+ data.box.dims.w])       THEN RETURN;    index ¬ (coords.x - EmulatorOps.LMargin) / data.c.fonts[normal].maxWidth;    ok ¬ TRUE;    };    CreateSW: PROC[sw: Window.Handle, clientData: LONG POINTER] = {    [] ¬ sw.SetDisplayProc[TabDisplay];    TIP.CreateClient[sw, TIP.mouseTIP, TIPMe];    };    MakeSWs: Tool.MakeSWsProc = {    data: DataHandle ¬ GetContext[window];    data.msgSW ¬ Tool.MakeMsgSW[window: window];    data.formSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeForm];    data.tabSW ¬ Tool.MakeClientSW[      window, CreateSW, NIL, mySWType];    };  charWidth: CARDINAL ¬ WindowFont.CharWidth['0];  CharPos: PROC[char: CARDINAL] RETURNS [x: INTEGER] = {    x ¬ charWidth * char};--    data: DataHandle ¬ GetSWContext[sw];    MakeForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    data: DataHandle ¬ GetSWContext[sw];    nItems: CARDINAL = 13;    scroll: ARRAY[0..2) OF Enumerated ¬ [      ["off"L, 0], ["on"L, 1]];    marginBell: ARRAY[0..2) OF Enumerated ¬ [      ["off"L, 0], ["on"L, 1]];    wrap: ARRAY[0..2) OF Enumerated ¬ [      ["off"L, 0], ["on"L, 1]];    autoRepeat: ARRAY[0..2) OF Enumerated ¬ [      ["off"L, 0], ["on"L, 1]];    keyClick: ARRAY[0..2) OF Enumerated ¬ [      ["off"L, 0], ["on"L, 1]];    newLine: ARRAY[0..2) OF Enumerated ¬ [      ["newline"L, 0], ["linefeed"L, 1]];    screen: ARRAY[0..2) OF Enumerated ¬ [      ["dark"L, 0], ["light"L, 1]];    emulate: ARRAY[0..2) OF Enumerated ¬ [      ["vt52"L, 0], ["ANSI"L, 1]];    columns: ARRAY[0..2) OF Enumerated ¬ [      ["80"L, 0], ["132"L, 1]];    cursor: ARRAY[0..2) OF Enumerated ¬ [      ["underline"L, 0], ["block"L, 1]];    autoXON: ARRAY[0..2) OF Enumerated ¬ [      ["off"L, 0], ["on"L, 1]];    items ¬ AllocateItemDescriptor[nItems];    items[0] ¬ EnumeratedItem[      tag: "Scroll"L, place: [CharPos[0], line0], choices: DESCRIPTOR[scroll], value: @data.scroll];    items[1] ¬ EnumeratedItem[      tag: "Margin Bell"L, place: [CharPos[27], line0], choices: DESCRIPTOR[marginBell], value: @data.marginBell];    items[2] ¬ EnumeratedItem[      tag: "Wrap"L, place: [CharPos[57], line0], choices: DESCRIPTOR[wrap], value: @data.wrap];    items[3] ¬ EnumeratedItem[      tag: "AutoRepeat"L, place: [CharPos[0], line1], choices: DESCRIPTOR[autoRepeat], value: @data.autoRepeat];    items[4] ¬ EnumeratedItem[      tag: "KeyClick"L, place: [CharPos[27], line1], choices: DESCRIPTOR[keyClick], value: @data.keyClick];    items[5] ¬ EnumeratedItem[      tag: "NewLine"L, place: [CharPos[57], line1], choices: DESCRIPTOR[newLine], value: @data.newLine];    items[6] ¬ EnumeratedItem[      tag: "Screen"L, place: [CharPos[0], line2], choices: DESCRIPTOR[screen], value: @data.screen];    items[7] ¬ EnumeratedItem[      tag: "Emulate"L, place: [CharPos[27], line2], choices: DESCRIPTOR[emulate], value: @data.emulate, readOnly: TRUE];    items[8] ¬ EnumeratedItem[      tag: "Columns"L, place: [CharPos[57], line2], choices: DESCRIPTOR[columns], value: @data.columns, readOnly: TRUE];    items[9] ¬ EnumeratedItem[      tag: "Cursor"L, place: [CharPos[0], line3], choices: DESCRIPTOR[cursor], value: @data.cursor];    items[10] ¬ EnumeratedItem[      tag: "Auto XON"L, place: [CharPos[27], line3], choices: DESCRIPTOR[autoXON], value: @data.autoXON];    items[11] ¬ CommandItem[      tag: "Apply"L, place: [CharPos[0], line5], proc: Apply];    items[12] ¬ CommandItem[      tag: "Abort"L, place: [CharPos[27], line5], proc: Abort];    RETURN[items: items, freeDesc: TRUE];    };  Initialize: PROC = {    tabString ¬ myZone.NEW[StringBody[132]];    tabString.length ¬ 0;    String.AppendString[tabString, "123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012"L];    underline ¬ myZone.NEW[StringBody[132]];    underline.length ¬ 0;    String.AppendString[underline, "----------          ----------          ----------          ----------          ----------          ----------          ----------  "L];    Point ¬ Atom.MakeAtom["PointDown"L];    Adjust ¬ Atom.MakeAtom["AdjustDown"L];    };          Initialize[];    }...    
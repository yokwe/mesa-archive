-- TermCapTest.mesa-- BGY      	 28-Jul-85 14:55:29-- Copyright (C) Xerox Corporation 1983, 1984, 1985. All rights reserved.DIRECTORY  Ascii,  Format,  FormSW,  Heap,  MFile,  MSegment,  MStream,  Put,  Stream,  String,  TermCap,  StateDefs,  Token,  Tool,  Window;TermCapTest: PROGRAM   IMPORTS    Format, FormSW, Heap, MFile, MSegment, MStream, Stream,Put,     String, TermCap, Token, Tool = {  StringProc: TYPE = PROCEDURE[name: LONG STRING];  z: UNCOUNTED ZONE ¬ Heap.systemZone;  nameInput: LONG STRING ¬ NIL;  input: LONG STRING ¬ NIL;  seg: MSegment.Handle ¬ NIL;  file: MFile.Handle ¬ NIL;  formSW, fileSW, tool: Window.Handle ¬ NIL;  temp: StateDefs.CommandHandle ¬ NIL;  key: StateDefs.KeyBoardHandle ¬ NIL;  data: StateDefs.Handle ¬ NIL;  h: MStream.Handle ¬ NIL;    PutCommandName: PROC[s: StateDefs.Actions] ={    Write[SELECT s FROM    AddBlankLine =>			"al"L,    BackTab => 				"bt"L,    Bell => 				"bl"L,    BlinkOn => 				"mb"L,    BoldOn => 				"md"L,    CarriageReturn => 			"cr"L,    CharAttributeOff => 		"me"L,    CollectXValue => 			"cXv"L,    CollectYValue => 			"cYv"L,    CursorAddress => 			"cm"L,    CursorBackward => 			"bc"L,    CursorBackward => 			"le"L,    CursorDown => 			"do"L,    CursorDownHalf => 			"hd"L,    CursorForward => 			"nd"L,    CursorMotionHorizontal => 		"ch"L,    CursorMotionVertical => 		"cv"L,    CursorUpHalf => 			"hu"L,    DeleteChar => 			"dc"L,    DeleteLine => 			"dl"L,    DeleteModeOff => 			"ed"L,    DeleteModeOn => 			"dm"L,    EraseScreen => 			"cl"L,    EraseToEOL => 			"ce"L,    EraseToEOS => 			"cd"L,    ErrorState => 			"err"L,    G0ROMCharSet => 			"as"L,    G1ROMCharSet =>			"ae"L,    HomeCursor => 			"ho"L,    InsertChar => 			"ic"L,    InsertModeOff => 			"ei"L,    JumpLastLine => 			"ll"L,    KeyPadApplication => 		"ks"L,    KeyPadNormal => 			"ke"L,    LineFeed => 			"nl"L,    NullState => 			"@@"L,    OpenModeOff => 			"ve"L,    OpenModeOn => 			"im"L,    OpenModeOn => 			"vs"L,    PadCharacter => 			"pc"L,    ReverseLineFeed => 			"up"L,    ReverseVideo => 			"mr"L,    SaveCursor => 			"sc"L,    ScrollForward => 			"sf"L,    ScrollingRegion => 			"cs"L,    ScrollReverse => 			"sr"L,    StandOutModeOff => 			"se"L,    StandOutModeOn => 			"so"L,    StuffChar => 			"stu"L,    SubXDiff => 			"sXd"L,    SubYDiff => 			"sYd"L,    Tab => 				"ta"L,    UnderscoreOff => 			"ue"L,    UnderscoreOn => 			"us"L,    VisibleBell => 			"vb"L,    ENDCASE => "??"L];    };      ErrorMessage: PROC[s1,s2: StateDefs.Actions,warning: BOOLEAN] = {    Write[IF warning THEN "Warning: "L ELSE "Error: "L];    PutCommandName[s1];    Write[" and "L];    PutCommandName[s2];    Write[" are ambiguous.\n"L];    };      PrintSyntax: PROC[pos: LONG CARDINAL, code: TermCap.ErrorCode] = {    Write["Syntax error in position "L];    Put.LongNumber[fileSW, pos, []];    Write[". Error: "L];    Format.Line[Write, SELECT code FROM      expectingCR => "Expecting a carriage return."L,      expectingEqual => "Expecting an equal sign."L,      badOctal => "Invalid octal digit."L,      cantFollowBS => "Invalid char after a backSlash."L,      badDelimiter => "Bad delimiter"L,      expectingPound => "Expecting a # ."L,      unknownEntry => "Unknown entry."L,      ENDCASE => "Unknown error."L];    };      PrintBadCode: PROC[pos: LONG CARDINAL, s: LONG STRING] = {    Put.Text[fileSW,"Warning: Bad entry in position "L];    Put.LongNumber[fileSW, pos, []];    Put.Text[fileSW, ". Error:=  "L];    Put.Line[fileSW, s];    };      TellMSE: PROC[ code: MStream.ErrorCode] = {    Put.Text[fileSW, "MStream error: "L];    Put.Line[fileSW, SELECT code FROM      invalidOperation => "Invalid Operation."L,      fileTooLong => "File too long."L,      fileNotAvailable => "File not available"L,      ENDCASE => "Other MStream error."L];    };      EnumerateString: PROC[proc: StringProc] = {    source: LONG STRING ¬ String.CopyToNewString[nameInput, z];    temp: LONG STRING ¬ NIL;    h: Token.Handle ¬ Token.StringToHandle[source,0];    state: Token.StandardFilterState;    DO      temp ¬ h.Filtered[@state, Token.FileName, whiteSpace, FALSE];      IF temp = NIL THEN EXIT;      proc[temp];      temp ¬ Token.FreeTokenString[temp];      ENDLOOP;    h ¬ h.FreeStringHandle[];    z.FREE[@source];    };    Build: FormSW.ProcType = {      BuildOne: StringProc = {      i: StateDefs.KeyboardValues;      j: StateDefs.Actions;      sorted: StateDefs.SortHandle ¬ NIL;      dataFile: LONG STRING ¬ NIL;      BEGIN ENABLE MSegment.Error => {        Put.Line[fileSW, "MSegment Error!"L];        GOTO nope};      IF data # NIL THEN CleanUp[];      IF String.Length[name] = 0 THEN {        Put.Line[fileSW, "Invalid name in TermCapFile: field"L];        RETURN};      dataFile ¬ String.CopyToNewString[name, z, 5];      String.AppendString[dataFile, ".data"L];      Put.Text[fileSW, "Parsing file: "L];      Put.Line[fileSW, name];      h ¬ MStream.ReadOnly[name, []! MStream.Error => {TellMSE[code]; GOTO nope}];      key ¬ z.NEW[StateDefs.KeyBoardTable];      FOR i IN StateDefs.KeyboardValues DO key[i] ¬ NIL ENDLOOP;      temp ¬ z.NEW[StateDefs.CommandStrings];      FOR j IN StateDefs.Actions DO temp[j] ¬ NIL ENDLOOP;      file ¬ MFile.ReadWrite[name: dataFile, release: [],         type: binary, initialLength: 2048];      seg ¬ MSegment.Create [file: file, release:[], pages: 4];      data ¬ MSegment.Address[segment: seg];      TermCap.ParseCapas[data, key, temp, h!         TermCap.SyntaxError => {          PrintSyntax[pos, code];          RESUME};        TermCap.BadCode => {          PrintBadCode[pos,s];  	RESUME}];      sorted ¬ TermCap.Sort[temp! TermCap.AmbiguousEntry => {        ErrorMessage[s1, s2, TRUE];        RESUME}];      TermCap.MakeTable[data, sorted, key, temp!         TermCap.AmbiguousEntry => {          ErrorMessage[s1, s2, FALSE];          CONTINUE};        TermCap.ParseError => {          Put.Text[fileSW, "Parse Error in expression: "L];          PutCommandName[c];  	  Put.CR[fileSW];	  RESUME}];      EXITS nope => NULL;      END;       IF h # NIL AND (h.delete # NIL) THEN Stream.Delete[h];      SafeClean[];      z.FREE[@dataFile]};  --end of buildone        EnumerateString[BuildOne];    Put.Line[fileSW, "----------------------------------------"L];    Put.CR[fileSW];    };      DisplayChar: PROC [c: CHARACTER] = {    SELECT c FROM      Ascii.NUL => Put.Text[fileSW, "NUL"L];      Ascii.ESC => Put.Text[fileSW, "ESC"L];      Ascii.DEL => Put.Text[fileSW, "DEL"L];      < '  =>{        Put.Char[fileSW, '^]; Put.Char[fileSW, c + 100B]};      ENDCASE => Put.Char[fileSW, c];    };      Write: Format.StringProc = {Put.Text[fileSW, s]};    DumpOneState: PROC[i: CARDINAL] = {    Put.Number[fileSW, i, []];    Put.Text[fileSW, "	"L];    DisplayChar[data.state[i].char];    Put.Text[fileSW, "	"L];    PutCommandName[data.state[i].action];    Put.Text[fileSW, "	"L];    Put.Number[fileSW,data.state[i].eatChars, []];    Put.Text[fileSW, "	"L];    Put.Number[fileSW,data.state[i].nextState, []];    Put.CR[fileSW];    };      DumpState: FormSW.ProcType = {    DumpOne: StringProc = {      dataFile: LONG STRING ¬ String.CopyToNewString[name, z, 5];      String.AppendString[dataFile, ".data"L];      Put.Text[fileSW, "Dump of state table for "L];      Put.Line[fileSW, name];      file ¬ MFile.ReadOnly[          name: dataFile, release: [], mightWrite: FALSE];      seg ¬ MSegment.Create [          file:file, pages:4, release:[], fileBase: LONG[0]];      data ¬ MSegment.Address[segment: seg];      BEGIN      IF data.head.version # StateDefs.version THEN {        Write["Invalid data file: "L];	Write[dataFile];	Write["\n"L];	GOTO quit;	};      FOR i: CARDINAL IN [0..data.head.numberOfStates) DO        DumpOneState[i];        ENDLOOP;      EXITS quit => NULL;      END;      MSegment.Delete[seg];      z.FREE[@dataFile];      seg  ¬ NIL; file ¬ NIL; data ¬ NIL;      }; -- end of DumpOne    EnumerateString[DumpOne];    };      NextState: PROC[state: CARDINAL, c: CHARACTER] RETURNS [new:CARDINAL] = {    j: CARDINAL ¬ state;    WHILE data.state[j].char # Ascii.NUL AND data.state[j].char # c DO      j ¬ j + 1;      ENDLOOP;    DumpOneState[j];    new ¬ data.state[j].nextState;    };      Run: FormSW.ProcType = {<<    state: CARDINAL ¬ 0;    new: CARDINAL ¬ 0;    i: CARDINAL ¬ 0;    IF String.Length[input] = 0 THEN {      Put.Line[fileSW, "No data in Input: field"L];      RETURN};    IF data = NIL THEN {      Put.Line[fileSW, "Need to parse a TermCap first!"L];      RETURN};    DO       new ¬ NextState[state, input.text[i]];      i ¬ i + data.state[state].eatChars;      state ¬ new;      IF i >= input.length THEN EXIT;      ENDLOOP;>>    };      CleanUp: FormSW.ProcType = {    wordSize: CARDINAL;    IF data = NIL THEN {      Put.Line[fileSW, "Files already released"L];      RETURN}    ELSE Put.Line[fileSW, "Closing files."L];    wordSize ¬ SIZE[StateDefs.StateInfo] +      (SIZE[StateDefs.State] * data.head.numberOfStates);    MFile.SetLength[file, wordSize* 2 + data.head.lengthOfKeyStrings];    SafeClean[];    };      SafeClean: PROC = {    i: StateDefs.KeyboardValues;    j: StateDefs.Actions;    wordSize: CARDINAL;    IF data = NIL OR file = NIL THEN {      Put.Line[fileSW, "Files already released"L];      RETURN};    wordSize ¬ SIZE[StateDefs.StateInfo] +      (SIZE[StateDefs.State] * data.head.numberOfStates);    file.SetLength[wordSize* 2 + data.head.lengthOfKeyStrings];    IF seg # NIL THEN MSegment.Delete[seg];    IF key # NIL THEN {      FOR i IN StateDefs.KeyboardValues DO        IF key[i] # NIL THEN z.FREE[@key[i]];        ENDLOOP;      z.FREE[@key]};    IF temp # NIL THEN {        FOR j IN StateDefs.Actions DO        IF temp[j] # NIL THEN z.FREE[@temp[j]];        ENDLOOP;      z.FREE[@temp]};    file ¬ NIL;    seg ¬ NIL;    data ¬ NIL;    };      MakeForm: FormSW.ClientItemsProcType ={    items ¬ FormSW.AllocateItemDescriptor[6];    items[0] ¬  FormSW.StringItem[      tag: "TermCapFile"L, place: [0, FormSW.line0], string: @nameInput,      inHeap: TRUE, drawBox: FALSE];    items[1] ¬  FormSW.StringItem[      tag: "Input"L, place: [400, FormSW.line0], string: @input,      inHeap: TRUE, drawBox: FALSE];    items[2] ¬ FormSW.CommandItem[          tag: "ParseTermCap"L, place: [0, FormSW.line1], proc:Build];    items[3] ¬ FormSW.CommandItem[          tag: "Release"L, place: [100, FormSW.line1], proc:CleanUp];    items[4] ¬ FormSW.CommandItem[          tag: "ReadInput"L, place: [200, FormSW.line1], proc:Run];    items[5] ¬ FormSW.CommandItem[          tag: "Dump"L, place: [300, FormSW.line1], proc:DumpState];    RETURN[items: items, freeDesc: TRUE];    };      MakeSWs: Tool.MakeSWsProc =    BEGIN    logName: STRING ¬ [40];    Tool.UnusedLogName[unused: logName, root: "TestParse.log"L];    formSW ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    END;      Init: PROCEDURE = {    tool ¬ Tool.Create[      makeSWsProc: MakeSWs,      initialState: default, name: "TermCapTest"L,      cmSection: "TermCapTest"L];    };          Init[];    }...
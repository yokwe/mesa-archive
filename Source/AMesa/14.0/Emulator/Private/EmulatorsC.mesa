-- EmulatorsC.mesa-- Last Edit:-- BGY     	 9-May-85 13:36:03-- Copyright (C) 1984 by Xerox Corporation. All rights reserved.DIRECTORY  Cursor USING [Set],  Display USING [White],  Emulator USING [Error],  EmulatorOps USING [    ActOnCaret, AttributeList, Blank, EContext, FindContext,     GetPlace, GetRealPlace, InternalLineFeed, lock, ReleaseContext],  Inline USING [LongCOPY],  UserInput USING [SetInputFocus],  Window USING [Box, Handle, Place];EmulatorsC: MONITOR LOCKS EmulatorOps.lock  IMPORTS Display, Cursor, Emulator, EmulatorOps, Inline, UserInput  EXPORTS Emulator, EmulatorOps =  BEGIN      Up: PUBLIC PROC[sw: Window.Handle]  = {    c: EmulatorOps.EContext ¬ EmulatorOps.FindContext[sw];    IF c = NIL THEN Emulator.Error[notAEmuSW];    BEGIN ENABLE UNWIND => EmulatorOps.ReleaseContext[sw];    InternalUp[c];    END;    EmulatorOps.ReleaseContext[sw];    };      Down: PUBLIC PROC[sw: Window.Handle]  = {    c: EmulatorOps.EContext ¬ EmulatorOps.FindContext[sw];    IF c = NIL THEN Emulator.Error[notAEmuSW];    BEGIN ENABLE UNWIND => EmulatorOps.ReleaseContext[sw];    InternalDown[c];    END;    EmulatorOps.ReleaseContext[sw];    };      Left: PUBLIC PROC[sw: Window.Handle] ={    c: EmulatorOps.EContext ¬ EmulatorOps.FindContext[sw];    IF c = NIL THEN Emulator.Error[notAEmuSW];    BEGIN ENABLE UNWIND => EmulatorOps.ReleaseContext[sw];    InternalLeft[c];    END;    EmulatorOps.ReleaseContext[sw];    };      Right: PUBLIC PROC[sw: Window.Handle] ={    c: EmulatorOps.EContext ¬ EmulatorOps.FindContext[sw];    IF c = NIL THEN Emulator.Error[notAEmuSW];    BEGIN ENABLE UNWIND => EmulatorOps.ReleaseContext[sw];    InternalRight[c];    END;    EmulatorOps.ReleaseContext[sw];    };      InternalUp: PUBLIC PROC[c: EmulatorOps.EContext]  = {    delta: CARDINAL ¬ MIN[MAX[c.params[0], 1], c.y];    c.params[0] ¬ 0;    InternalGotoXY[c, c.x, c.y - delta]};      InternalDown: PUBLIC PROC[c: EmulatorOps.EContext]  = {    y: CARDINAL ¬ c.y;    delta: CARDINAL ¬ MAX[c.params[0], 1];    IF c.y <= c.bot OR c.origin THEN y ¬ MIN[c.scrollHeight-1, y+delta]     ELSE y ¬ MIN[c.lines-1, y+delta];    c.params[0] ¬ 0;    InternalGotoXY[c, c.x, y];    };      InternalLeft: PUBLIC PROC[c: EmulatorOps.EContext] ={    delta: CARDINAL ¬ MIN[MAX[c.params[0], 1], c.x];    c.params[0] ¬ 0;    InternalGotoXY[c, c.x - delta, c.y]};      InternalRight: PUBLIC PROC[c: EmulatorOps.EContext] ={    delta: CARDINAL ¬ MIN[MAX[c.params[0], 1], (c.columns - 1 - c.x)];    c.params[0] ¬ 0;    InternalGotoXY[c, c.x + delta, c.y]};      InternalClearToBOL: PUBLIC PROC[c:EmulatorOps.EContext] = {    start: Window.Place;    FOR i: CARDINAL IN [0..c.x] DO      c.source[c.y][i] ¬ EmulatorOps.Blank;      ENDLOOP;    start ¬ EmulatorOps.GetRealPlace[c, 0, c.y];    Display.White[c.sw, [start,       [w: (c.x+1)*c.fonts[normal].maxWidth,      h: c.fonts[normal].height]]];    c.charCount ¬ c.charCount + 1;    };      Blank: PROC [p: EmulatorOps.AttributeList, start, count: CARDINAL] = INLINE {    p.font ¬ normal;    p.dirty ¬ FALSE;    p[start] ¬ EmulatorOps.Blank;    Inline.LongCOPY[from: @p[start], to: @p[start+1], nwords: count-1]};      InternalClearToEOL: PUBLIC PROC[c:EmulatorOps.EContext] = {    start: Window.Place;    FOR i: CARDINAL IN [c.x..c.columns) DO      c.source[c.y][i] ¬ EmulatorOps.Blank;      ENDLOOP;    start ¬ EmulatorOps.GetRealPlace[c, c.x, c.y];    Display.White[c.sw, [start,       [w: c.columns*c.fonts[normal].maxWidth,      h: c.fonts[normal].height]]];    c.charCount ¬ c.charCount + 1;    };      InternalClearToBOS: PUBLIC PROC[c:EmulatorOps.EContext] ={    FOR i: CARDINAL IN [0..c.y) DO      Blank[c.source[i], 0, c.columns];      ENDLOOP;    InternalClearToBOL[c];    Display.White[      c.sw, [EmulatorOps.GetRealPlace[c,0,0],      [w: c.frame.dims.w,      h: c.fonts[normal].height * c.y]]];    c.charCount ¬ c.charCount + 1;    };      InternalClearToEOS: PUBLIC PROC[c:EmulatorOps.EContext] ={    nextLine: CARDINAL;    nextLine ¬ MIN[c.y + 1, c.scrollHeight];    IF c.x = 0 AND c.y = 0 THEN {      InternalClear[c]; RETURN};    FOR i: CARDINAL IN [nextLine..c.scrollHeight) DO      Blank[c.source[i], 0, c.columns];      ENDLOOP;    InternalClearToEOL[c];    Display.White[      c.sw, [EmulatorOps.GetRealPlace[c, 0, nextLine],      [w: c.frame.dims.w,      h: c.fonts[normal].height * (c.lines - nextLine)]]];    c.charCount ¬ c.charCount + 1;    };      InternalCR: PUBLIC PROC [c:EmulatorOps.EContext] ={    InternalGotoXY[c, 0, c.y];   };      CR: PUBLIC PROC [sw: Window.Handle] ={    c: EmulatorOps.EContext ¬ EmulatorOps.FindContext[sw];    IF c = NIL THEN Emulator.Error[notAEmuSW];    BEGIN ENABLE UNWIND => EmulatorOps.ReleaseContext[sw];    EmulatorOps.InternalLineFeed[c, TRUE];    END;    EmulatorOps.ReleaseContext[sw];    };      InternalClearLine: PUBLIC PROC [c:EmulatorOps.EContext] ={    c.x ¬ 0;    InternalClearToEOL[c];   };      InternalClear: PUBLIC PROC [c:EmulatorOps.EContext] = {    FOR i: CARDINAL IN [0..c.lines) DO      Blank[c.source[i], 0, c.columns];      ENDLOOP;    Display.White[c.sw, [place: EmulatorOps.GetRealPlace[c, 0, 0],       dims: [c.frame.dims.w, c.lines*c.fonts[normal].height]]];    c.charCount ¬ c.charCount + 1;    IF c.data.bool[homeOnClear] THEN InternalGotoXY[c,0,0];    };      ClearToEOL: PUBLIC PROC[sw: Window.Handle] ={    c: EmulatorOps.EContext ¬ EmulatorOps.FindContext[sw];    IF c = NIL THEN Emulator.Error[notAEmuSW];    BEGIN ENABLE UNWIND => EmulatorOps.ReleaseContext[sw];    InternalClearToEOL[c];    END;    EmulatorOps.ReleaseContext[sw];    };      ClearToEOS: PUBLIC PROC[sw: Window.Handle] ={    c: EmulatorOps.EContext ¬ EmulatorOps.FindContext[sw];    IF c = NIL THEN Emulator.Error[notAEmuSW];    BEGIN ENABLE UNWIND => EmulatorOps.ReleaseContext[sw];    InternalClearToEOS[c];    END;    EmulatorOps.ReleaseContext[sw];    c.charCount ¬ c.charCount + 1;    };      ClearLine: PUBLIC PROC [sw:Window.Handle] ={     c: EmulatorOps.EContext ¬ EmulatorOps.FindContext[sw];    IF c = NIL THEN Emulator.Error[notAEmuSW];    BEGIN ENABLE UNWIND => EmulatorOps.ReleaseContext[sw];    c.x ¬ 0;    InternalClearToEOL[c];    END;    EmulatorOps.ReleaseContext[sw];    };      Clear, ClearScreen: PUBLIC PROC [sw:Window.Handle] = {    c: EmulatorOps.EContext ¬ EmulatorOps.FindContext[sw];    IF c = NIL THEN Emulator.Error[notAEmuSW];    BEGIN ENABLE UNWIND => EmulatorOps.ReleaseContext[sw];    InternalClear[c];    END;    EmulatorOps.ReleaseContext[sw];    c.charCount ¬ c.charCount + 1;    };      GotoXY: PUBLIC PROC [sw:Window.Handle, x,y:CARDINAL] = {    c: EmulatorOps.EContext ¬ EmulatorOps.FindContext[sw];    IF c = NIL THEN Emulator.Error[notAEmuSW];    BEGIN ENABLE UNWIND => EmulatorOps.ReleaseContext[sw];    InternalGotoXY[c, x,y];    END;    EmulatorOps.ReleaseContext[sw];    };      Tab: PUBLIC  PROC [sw: Window.Handle] = {    c: EmulatorOps.EContext ¬ EmulatorOps.FindContext[sw];    IF c = NIL THEN Emulator.Error[notAEmuSW];    BEGIN ENABLE UNWIND => EmulatorOps.ReleaseContext[sw];    InternalTab[c];    END;    EmulatorOps.ReleaseContext[sw];    };      InternalTab: PUBLIC  PROC [c: EmulatorOps.EContext] = {    newX, newY: CARDINAL ¬ 0;    [newX, newY] ¬ IF c.data.bool[hardwareTabs] THEN       NextHardTab[c] ELSE NextSoftTab[c];    InternalGotoXY[c, newX, newY];    };      NextHardTab: PROC [c: EmulatorOps.EContext] RETURNS [newX, newY: CARDINAL]= {    newX ¬ ((c.x/8) + 1) * 8;    newY ¬ IF newX < c.columns THEN       c.y ELSE MIN[c.y+1, c.lines-1];    newX ¬ newX MOD c.columns;    };      NextSoftTab: PROC [c: EmulatorOps.EContext] RETURNS [newX, newY: CARDINAL]= {    start: CARDINAL ¬ c.x+1;    line: CARDINAL ¬ c.y;    THROUGH [0..2) DO      FOR i: CARDINAL IN [start..c.columns) DO        IF c.tabs[i] THEN RETURN[i, line] ENDLOOP;      start ¬ 0;      line ¬ MIN[c.y+1, c.lines-1];      ENDLOOP;    RETURN [c.columns - 1, c.y];    };      BackTab: PUBLIC  PROC [sw: Window.Handle] = {    c: EmulatorOps.EContext ¬ EmulatorOps.FindContext[sw];    IF c = NIL THEN Emulator.Error[notAEmuSW];    BEGIN ENABLE UNWIND => EmulatorOps.ReleaseContext[sw];    InternalBackTab[c];    END;    EmulatorOps.ReleaseContext[sw];    };      InternalBackTab: PUBLIC  PROC [c: EmulatorOps.EContext] = {    newX, newY: CARDINAL;    IF c.x = 0 THEN {      newX ¬ c.columns-8;      newY ¬ IF c.y = 0 THEN 0 ELSE c.y-1}    ELSE newX ¬ (c.x/8) * 8;    InternalGotoXY[c,newX,newY];    };      InternalGotoXY: PUBLIC PROC[c: EmulatorOps.EContext, x,y: CARDINAL] = {    bot: CARDINAL ¬ 0;    c.x ¬ MIN[x, c.columns -1];     bot ¬ IF c.origin THEN (c.scrollHeight-1) ELSE c.lines -1;    c.y ¬ IF y > bot THEN bot ELSE y;    MoveInsertion[c];    };      MoveInsertion: PUBLIC PROC[c: EmulatorOps.EContext] = {NULL};      TakeInsertion: PUBLIC PROC[c: EmulatorOps.EContext] = {    c.ownFocus ¬ TRUE;    UserInput.SetInputFocus[c.sw, LoseInputFocus, TRUE,c];    EmulatorOps.ActOnCaret[c, start];    Cursor.Set[textPointer];    };      LoseInputFocus: PROCEDURE [sw: Window.Handle, data: LONG POINTER] = {    c: EmulatorOps.EContext ¬ data;    Cursor.Set[groundedText];    c.ownFocus ¬ FALSE;    };      GetCharBox: PUBLIC PROC[c: EmulatorOps.EContext, x,y: CARDINAL]     RETURNS [box: Window.Box] = {    box ¬ [      place:EmulatorOps.GetPlace[c,x,y],       dims: [w:c.fonts[normal].maxWidth, h: c.fonts[normal].height]];    };      END.
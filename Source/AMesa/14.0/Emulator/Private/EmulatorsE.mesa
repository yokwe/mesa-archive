-- EmulatorsE.mesa-- Last Edit:-- BGY     	22-Aug-85 10:30:17-- Copyright (C) 1984 by Xerox Corporation. All rights reserved.DIRECTORY  Ascii USING [CR],  Atom USING [ATOM, MakeAtom],  Display USING [Invert],  EmulatorOps USING [    ActOnCaret, EContext, FindContext, ForceOutStart, GetRealPlace,     LMargin, lock, ReleaseContext, TakeInsertion, zone],  Heap USING [systemZone],  Selection USING [    ActOn, ActOnProcType, Clear, ConvertProcType, DestroyProc, Set,     Source, SourceObject, SourceProc],  StateDefs USING [Handle, KeyboardValues, StringHeapHandle],  String USING [AppendChar],  System,  TIP USING [    clickTimeout, CreateTable, First, globalTable, InvalidTable,     mouseTIP, NewManager, NotifyProc, PushLocal, Rest, Results, Table],  ToolWindow USING [WindowForSubwindow],  UserInput USING [StuffCharacter, StuffCurrentSelection, StuffString],  UserTerminal USING [Beep, BlinkDisplay],  Window USING [Handle, Place];    EmulatorsE: MONITOR LOCKS EmulatorOps.lock  IMPORTS     Atom, Display, EmulatorOps, Selection, Heap, String, TIP,     ToolWindow, UserInput, UserTerminal  EXPORTS EmulatorOps =  BEGIN    z: UNCOUNTED ZONE ¬  Heap.systemZone;  myTip : PUBLIC TIP.Table ¬ NIL;  AtomList: TYPE = {AdjustDown, CopyDown, CopyUp, InsertToSel, PointDown,     PointMotion, AdjustMotion, PointUp, AdjustUp,    BackArrow, LeftArrow, UpArrow, RightArrow, DownArrow, Stuff, Return,    PF1, PF2, PF3, PF4, KP1, KP2, KP3, KP4, KP5, KP6, KP7, KP8, KP9, KP0,     KComma, KPeriod, KEnter, KMinus};  AtomArray: TYPE = ARRAY AtomList OF Atom.ATOM;  Atoms: TYPE = LONG POINTER TO AtomArray;  atoms: Atoms ¬ NIL;    time, lastTime: System.Pulses ¬ [0];    LineTable: TYPE = LONG POINTER TO LineTableType;  LineTableType: TYPE = ARRAY [0..200) OF CARDINAL ¬ ALL[0];    MySourceType: TYPE = LONG POINTER TO SourceObject;  SourceObject: TYPE = RECORD [    c: EmulatorOps.EContext ¬ NIL,    left, right, index: CARDINAL ¬ 0];      nullIndex: CARDINAL = LAST[CARDINAL];    lt: LineTable ¬ EmulatorOps.zone.NEW[LineTableType];      Notify: PUBLIC TIP.NotifyProc = {    c: EmulatorOps.EContext ¬ EmulatorOps.FindContext[window];    coords: Window.Place;    IF c = NIL THEN RETURN;    IF c.keyClick THEN UserTerminal.Beep[200,40];    EmulatorOps.ReleaseContext[window];    FOR input: TIP.Results ¬ results, input.Rest[] UNTIL input = NIL DO      WITH z: input.First[] SELECT FROM        atom => {	  SELECT z.a FROM	    atoms[AdjustDown] => Adjust[window,coords];	    atoms[CopyDown] => Selection.Clear[];	    atoms[CopyUp] => [] ¬ UserInput.StuffCurrentSelection[window];	    atoms[PointDown] => Point[window, coords];	    atoms[PointMotion] => PointMotion[window, coords, reset];	    atoms[AdjustMotion] => AdjustMotion[window, coords];	    atoms[PointUp] => {PointMotion[window, coords, reset]; ButtonUp[window]};	    atoms[AdjustUp] => {AdjustMotion[window, coords]; ButtonUp[window]};	    atoms[InsertToSel] => InsertToSelect[window];	    atoms[BackArrow] => SendKeys[c, backspaceKey];	    atoms[LeftArrow] => SendKeys[c, leftArrowKey];	    atoms[RightArrow] => SendKeys[c, rightArrowKey];	    atoms[UpArrow] => SendKeys[c, upArrowKey];	    atoms[DownArrow] => SendKeys[c, downArrowKey];	    atoms[Stuff] => [] ¬ UserInput.StuffCurrentSelection[window];	    atoms[Return] => [] ¬ UserInput.StuffString[window, 	      IF c.lineFeed THEN "\015\012"L ELSE "\015"L];	    atoms[KComma] => CheckKey[c, keypadComma, ',];	    atoms[KPeriod] => CheckKey[c, keypadPeriod, '.];	    atoms[KEnter] => CheckKey[c, enterKey, '\n];	    atoms[KMinus] => CheckKey[c, keypadMinus, '-];	    atoms[KP0] => CheckKey[c, keypad0, '0];	    atoms[KP1] => CheckKey[c, keypad1, '1];	    atoms[KP2] => CheckKey[c, keypad2, '2];	    atoms[KP3] => CheckKey[c, keypad3, '3];	    atoms[KP4] => CheckKey[c, keypad4, '4];	    atoms[KP5] => CheckKey[c, keypad5, '5];	    atoms[KP6] => CheckKey[c, keypad6, '6];	    atoms[KP7] => CheckKey[c, keypad7, '7];	    atoms[KP8] => CheckKey[c, keypad8, '8];	    atoms[KP9] => CheckKey[c, keypad9, '9];	    atoms[PF1] => SendKeys[c, function1];	    atoms[PF2] => SendKeys[c, function2];	    atoms[PF3] => SendKeys[c, function3];	    atoms[PF4] => SendKeys[c, function4];	    ENDCASE;	  };	char => {	  IF  ~UserInput.StuffCharacter[window, z.c] THEN	    UserTerminal.BlinkDisplay[]	  ELSE UpDate[c]};        coords => coords ¬ z.place;        time => time ¬ z.time;	string => {	  IF ~UserInput.StuffString[window, z.s] THEN 	    UserTerminal.BlinkDisplay[]	  ELSE UpDate[c]};        ENDCASE;      ENDLOOP;    };      CheckKey: PROC[c: EmulatorOps.EContext, k: StateDefs.KeyboardValues,    ch: CHARACTER] = {    IF c.keypadApplication THEN SendKeys[c, k]    ELSE [] ¬ UserInput.StuffCharacter[c.sw, ch]};    UpDate: ENTRY PROC[c: EmulatorOps.EContext] = {    ENABLE UNWIND => NULL;    c.dirty ¬ TRUE;    NOTIFY EmulatorOps.ForceOutStart};    InitLT: PROC[c: EmulatorOps.EContext] = {    j: CARDINAL;    GetLastChar: PROC[k: CARDINAL] RETURNS [pos: CARDINAL]= {      pos ¬ c.columns - 1;      WHILE c.source[k][pos].char = '  AND pos # 0 DO pos ¬ pos - 1 ENDLOOP;      };    FOR j IN [0..c.lines) DO lt[j] ¬ GetLastChar[j] ENDLOOP;    };    reset: BOOLEAN ¬ TRUE;    Point: PROC[sw: Window.Handle, place: Window.Place] = {    c: EmulatorOps.EContext ¬ EmulatorOps.FindContext[sw];    IF c = NIL THEN RETURN;    BEGIN ENABLE UNWIND => EmulatorOps.ReleaseContext[sw];    IF c.ownFocus THEN EmulatorOps.ActOnCaret[c, stop];    IF ~c.ownSelect THEN {      InitLT[c];      Selection.Set[c, ConvertSelection, ActOnSelect];      c.ownSelect ¬ TRUE;      };    reset ¬ TRUE;    IF (time - lastTime) < TIP.clickTimeout THEN {      pos: CARDINAL ¬ PosFromPlace[c, place];      reset ¬ (pos > c.right OR pos < c.left);      IF pos >= c.left AND pos <= c.right THEN 	c.selectMode ¬ SELECT c.selectMode FROM	  char => word,	  word => line,	  line => all,	  ENDCASE => char      ELSE c.selectMode ¬ char;      }    ELSE c.selectMode ¬ char;    END;    EmulatorOps.ReleaseContext[sw];    PointMotion[sw, place, reset];    TIP.NewManager[sw, TIP.mouseTIP, Notify];    };      ButtonUp: PROC[sw: Window.Handle] = {    c: EmulatorOps.EContext ¬ EmulatorOps.FindContext[sw];    IF c = NIL THEN RETURN;    BEGIN ENABLE UNWIND => EmulatorOps.ReleaseContext[sw];    IF c.ownFocus THEN EmulatorOps.ActOnCaret[c, start];    END;    leftBase ¬ c.left;    rightBase ¬ c.right;    EmulatorOps.ReleaseContext[sw];    TIP.NewManager[NIL,NIL,NIL];    lastTime ¬ time;     reset ¬ TRUE;    };    PointMotion: PROC[    sw: Window.Handle, place: Window.Place, reset: BOOLEAN ¬ TRUE] = {    c: EmulatorOps.EContext ¬ EmulatorOps.FindContext[sw];    oldLeft, oldRight: CARDINAL;    IF c = NIL THEN RETURN;    BEGIN ENABLE UNWIND => EmulatorOps.ReleaseContext[sw];    pos: CARDINAL ¬ PosFromPlace[c, place];    oldLeft ¬ c.left;    oldRight ¬ c.right;    reset ¬ reset OR c.selectMode = char OR (pos > c.right OR pos < c.left);    IF reset THEN c.left ¬ c.right ¬ pos;    SELECT c.selectMode FROM      word => ExpandToWord[c];      line => ExpandToLine[c];      all => ExpandToAll[c];      ENDCASE;    IF c.left # oldLeft OR c.right # oldRight THEN {      Swap[c, @oldLeft, @oldRight];      Selection.ActOn[unmark];      Swap[c, @oldLeft, @oldRight];      Selection.ActOn[mark];      };    END;    EmulatorOps.ReleaseContext[sw];    };      Swap: PROC[c: EmulatorOps.EContext, left, right: POINTER TO CARDINAL] = INLINE {    temp: CARDINAL;    temp ¬ left­;    left­ ¬ c.left;    c.left ¬ temp;    temp ¬ right­;    right­ ¬ c.right;    c.right ¬ temp;    };    leftBase, rightBase: CARDINAL;    Adjust: PROC[sw: Window.Handle, place: Window.Place] = {    c: EmulatorOps.EContext ¬ EmulatorOps.FindContext[sw];    BEGIN ENABLE UNWIND => EmulatorOps.ReleaseContext[sw];    pos: CARDINAL ¬ PosFromPlace[c, place];    IF c.ownFocus THEN EmulatorOps.ActOnCaret[c, stop];    IF pos = c.left OR pos = c.right THEN c.selectMode ¬ char;    END;    EmulatorOps.ReleaseContext[sw];    AdjustMotion[sw, place];    TIP.NewManager[sw, TIP.mouseTIP, Notify];    };      AdjustMotion: PROC[sw: Window.Handle, place: Window.Place] = {    c: EmulatorOps.EContext ¬ EmulatorOps.FindContext[sw];    oldLeft, oldRight: CARDINAL;    IF c = NIL THEN RETURN;    BEGIN ENABLE UNWIND => EmulatorOps.ReleaseContext[sw];    IF c.ownSelect THEN {      pos: CARDINAL ¬ PosFromPlace[c, place];      oldLeft ¬ c.left;      oldRight ¬ c.right;      -- new adjust postion      SELECT TRUE FROM        pos < leftBase => {c.left ¬ pos};        pos > rightBase => {c.right ¬ pos};	ENDCASE => SELECT TRUE FROM	  c.left = leftBase AND c.right = rightBase => 	    IF (pos-leftBase) < (rightBase - pos) THEN c.left ¬ pos	    ELSE c.right ¬ pos;	  c.left = leftBase => c.right ¬ pos;	  c.right = rightBase => c.left ¬ pos;	  ENDCASE;      -- do selection expansion      SELECT c.selectMode FROM	word => ExpandToWord[c];	line => ExpandToLine[c];	all => ExpandToAll[c];	ENDCASE;      -- guarantee rubber base      IF (c.left # leftBase) AND (c.right # rightBase) THEN {        SELECT TRUE FROM	  pos < leftBase => c.right ¬ rightBase;	  pos > rightBase => c.left ¬ leftBase;	  ENDCASE => 	    IF (pos-leftBase) < (rightBase - pos) THEN c.left ¬ leftBase	    ELSE c.right ¬ rightBase;        };      IF oldLeft # c.left THEN         IF oldLeft < c.left THEN InvertRegion[c, oldLeft, Decr[c, c.left]]	ELSE InvertRegion[c, c.left, Decr[c, oldLeft]];      IF oldRight # c.right THEN         IF oldRight < c.right  THEN InvertRegion[c, Incr[c, oldRight], c.right ]	ELSE InvertRegion[c, Incr[c, c.right] , oldRight];      };    END;    EmulatorOps.ReleaseContext[sw];    };      Decr: PROC[c: EmulatorOps.EContext, old: CARDINAL] RETURNS[CARDINAL] = {    x, y: CARDINAL;    IF old = 0 THEN RETURN [0];    [x,y] ¬ PosToCoord[c, old];    IF x # 0 THEN RETURN [old - 1];    RETURN[CoordToPos[c, lt[y-1], y-1]];    };    Incr: PROC[c: EmulatorOps.EContext, old: CARDINAL] RETURNS[new: CARDINAL] = {    x, y: CARDINAL;    [x,y] ¬ PosToCoord[c, old];    IF x # lt[y] THEN RETURN[old + 1];    RETURN[CoordToPos[c, 0, y + 1]];    };    InsertToSelect: PROC[sw: Window.Handle] = {    c: EmulatorOps.EContext ¬ EmulatorOps.FindContext[sw];    IF c = NIL THEN RETURN;    EmulatorOps.ReleaseContext[sw];    EmulatorOps.TakeInsertion[c];    };    CharType: TYPE = {alphaNum, white};    GetCharType: PROC[char: CHARACTER] RETURNS[type: CharType] = INLINE {    RETURN[ SELECT char FROM      IN ['a..'z], IN ['A..'Z], IN ['0..'9] => alphaNum,      ENDCASE => white];    };      ExpandToWord: PROC[c: EmulatorOps.EContext]={    x, y: CARDINAL;    type: CharType;    -- get left side first    [x,y] ¬ PosToCoord[c, c.left];    type ¬ GetCharType[c.source[y][x].char];    WHILE x > 0 AND type = GetCharType[c.source[y][x].char] DO      x ¬ x - 1;      ENDLOOP;    IF x = 0 AND (GetCharType[c.source[y][0].char] = type) THEN       c.left ¬ CoordToPos[c, x, y]    ELSE c.left ¬ CoordToPos[c, x + 1, y];    -- now get right    [x,y] ¬ PosToCoord[c, c.right];    type ¬ GetCharType[c.source[y][x].char];    WHILE x <= lt[y] AND type = GetCharType[c.source[y][x].char] DO      x ¬ x + 1;      ENDLOOP;    c.right ¬ CoordToPos[c, x-1, y];    };    ExpandToLine: PROC[c: EmulatorOps.EContext]={    x, y: CARDINAL;    [x,y] ¬ PosToCoord[c, c.left];    c.left ¬ CoordToPos[c, 0, y];    [x,y] ¬ PosToCoord[c, c.right];    c.right ¬ CoordToPos[c, lt[y], y];    };    ExpandToAll: PROC[c: EmulatorOps.EContext]={    c.left ¬ CoordToPos[c, 0, 0];    c.right ¬ CoordToPos[c, lt[c.lines -1], c.lines - 1];    };    SendKeys: PROC[c: EmulatorOps.EContext,k: StateDefs.KeyboardValues]={    d: StateDefs.Handle ¬ c.data;    chars: StateDefs.StringHeapHandle ¬ LOOPHOLE[@d.state[d.head.numberOfStates]];    IF d.key[k].length # 0 THEN      FOR i: CARDINAL IN [d.key[k].start..d.key[k].start + d.key[k].length) DO        [] ¬ UserInput.StuffCharacter[c.sw, chars[i]];        ENDLOOP;    };      GetKeyValue: PUBLIC PROC[c: EmulatorOps.EContext,k: StateDefs.KeyboardValues]    RETURNS[value: LONG STRING]={    d: StateDefs.Handle ¬ c.data;    chars: StateDefs.StringHeapHandle ¬ LOOPHOLE[@d.state[d.head.numberOfStates]];    IF d.key[k].length = 0 THEN RETURN[NIL];    value ¬ EmulatorOps.zone.NEW[StringBody[d.key[k].length]];    value.length ¬ 0;    IF d.key[k].length # 0 THEN      FOR i: CARDINAL IN [d.key[k].start..d.key[k].start + d.key[k].length) DO        String.AppendChar[value, chars[i]];        ENDLOOP;    };      Init: PROC = { OPEN Atom;    tipContents: STRING ¬"-- Emulator.TIP, created by System-- Version of 28-Mar-83 11:47:18[DEF,ChordTime,(100)][DEF,Chord,(SELECT TRIGGER FROM  ~1 Down BEFORE [ChordTime] => { [TC] Menu };  ENDCASE => ~2)]  [DEF,CopyMove,(COPY Down | MOVE Down)][DEF,TC,(TIME COORDS)]      SELECT TRIGGER FROM  BS Down => SELECT ENABLE FROM    LeftShift Down | RightShift Down => \042\\027\042;    ENDCASE => BackArrow;      DELETE Down => \042\\177\042;    COMPLETE Down => \042\\033\042;  NEXT Down => LeftArrow;  HELP Down => UpArrow;  UNDO Down => RightArrow;  DOIT Down => DownArrow;  MENU Down => PF1;  SCROLLBAR Down => PF2;  JFIRST Down => PF3;  JSELECT Down => PF4;  Point Down => [Chord,Adjust,    SELECT ENABLE FROM      CONTROL Down => { [TC] MoveInsertion };      [CopyMove] => { [TC] PointDown };      ENDCASE => { [TC] Video InsertToSel PointDown }];    Adjust Down => [Chord,Point,    SELECT ENABLE FROM      [CopyMove] => { [TC] AdjustDown };      ENDCASE => { [TC] InsertToSel AdjustDown }];    One Down WHILE COMMAND Down => KP1;  Two Down WHILE COMMAND Down => KP2;  Three Down WHILE COMMAND Down => KP3;  Four Down WHILE COMMAND Down => KP4;  Five Down WHILE COMMAND Down => KP5;  Six Down WHILE COMMAND Down => KP6;  Seven Down WHILE COMMAND Down => KP7;  Eight Down WHILE COMMAND Down => KP8;  Nine Down WHILE COMMAND Down => KP9;  Zero Down WHILE COMMAND Down => KP0;  Comma Down WHILE COMMAND Down => KComma;  Period Down WHILE COMMAND Down => KPeriod;  Return Down WHILE COMMAND Down => KEnter;  Dash Down WHILE COMMAND Down => KMinus;    Return Down => Return;  ENDCASE..."L;    firstTime: BOOLEAN ¬ TRUE;    atoms ¬ EmulatorOps.zone.NEW[AtomArray ¬ [      AdjustDown: MakeAtom["AdjustDown"L], CopyDown: MakeAtom["CopyDown"L],       CopyUp: MakeAtom["CopyUp"L], PointDown: MakeAtom["PointDown"L],       BackArrow: MakeAtom["BackArrow"L], LeftArrow: MakeAtom["LeftArrow"L],       UpArrow: MakeAtom["UpArrow"L], RightArrow: MakeAtom["RightArrow"L],       DownArrow: MakeAtom["DownArrow"L], Stuff: MakeAtom["Stuff"L],       Return: MakeAtom["Return"L], PF1: MakeAtom["PF1"L], PF2: MakeAtom["PF2"L],       PF3: MakeAtom["PF3"L], PF4: MakeAtom["PF4"L], KP1: MakeAtom["KP1"L],       KP2: MakeAtom["KP2"L], KP3: MakeAtom["KP3"L], KP4: MakeAtom["KP4"L],       KP5: MakeAtom["KP5"L], KP6: MakeAtom["KP6"L], KP7: MakeAtom["KP7"L],       KP8: MakeAtom["KP8"L], KP9: MakeAtom["KP9"L], KP0: MakeAtom["KP0"L],       KComma: MakeAtom["KComma"L], KPeriod: MakeAtom["KPeriod"L],       KEnter: MakeAtom["KEnter"L], KMinus: MakeAtom["KMinus"L],      InsertToSel: MakeAtom["InsertToSel"L], PointMotion: MakeAtom["PointMotion"L],       AdjustMotion: MakeAtom["AdjustMotion"L],       PointUp: MakeAtom["PointUp"L], AdjustUp: MakeAtom["AdjustUp"L]]];    myTip ¬ TIP.CreateTable[file: "Emulator.TIP"L, contents: tipContents !      TIP.InvalidTable =>        IF type # badSyntax THEN CONTINUE        ELSE {	  UserTerminal.BlinkDisplay[];	  IF firstTime THEN {firstTime ¬ FALSE; RESUME}}];    IF myTip # NIL THEN TIP.PushLocal[push: myTip, onto: TIP.globalTable[root]];    };      ActOnSelect: Selection.ActOnProcType = {    c: EmulatorOps.EContext ¬ data;    IF ~c.ownSelect THEN RETURN;    SELECT action FROM      clear => IF c.marked THEN {        InvertSelection[c]; c.marked ¬ FALSE; c.ownSelect ¬ FALSE;	c.right ¬ c.left ¬ nullIndex;};      mark => IF ~c.marked THEN {InvertSelection[c]; c.marked ¬ TRUE};      unmark => IF c.marked THEN {InvertSelection[c]; c.marked ¬ FALSE};      ENDCASE;    };      InvertSelection: PROC[c: EmulatorOps.EContext] = INLINE {    InvertRegion[c, c.left, c.right]};      InvertRegion: PROC[c: EmulatorOps.EContext, left, right: CARDINAL] = {    topX, topY, botX, botY: CARDINAL ¬ 0;    [topX, topY] ¬ PosToCoord[c, left];    [botX, botY] ¬ PosToCoord[c, right];    IF topY = botY THEN       Display.Invert[c.sw, [EmulatorOps.GetRealPlace[c, topX, topY],        [w: (botX-topX+1)*c.fonts[normal].maxWidth, h: c.fonts[normal].height]]]    ELSE {      Display.Invert[c.sw, [EmulatorOps.GetRealPlace[c,topX,topY],       [w: (lt[topY]+1-topX)*c.fonts[normal].maxWidth, h: c.fonts[normal].height]]];      IF botY-topY > 1 THEN FOR j:CARDINAL IN [topY+1..botY) DO         Display.Invert[c.sw, [EmulatorOps.GetRealPlace[c,0,j],         [w: (lt[j]+1)*c.fonts[normal].maxWidth, h: c.fonts[normal].height]]];        ENDLOOP;      Display.Invert[c.sw, [EmulatorOps.GetRealPlace[c,0,botY],        [w: (botX+1)*c.fonts[normal].maxWidth, h: c.fonts[normal].height]]];      };    };    ConvertSelection: Selection.ConvertProcType = {    c: EmulatorOps.EContext ¬ data;    p: LONG POINTER ¬ NIL;    IF ~c.ownSelect THEN RETURN[p];    SELECT target FROM      window =>  p ¬ ToolWindow.WindowForSubwindow[c.sw];      subwindow => p ¬ c.sw;      length => {        dummy: LONG POINTER TO LONG CARDINAL ¬ z.NEW[LONG CARDINAL];	dummy^ ¬ c.right - c.left;	p ¬ dummy};      source => {        dummy: MySourceType ¬ EmulatorOps.zone.NEW[SourceObject¬[]];	source: Selection.Source ¬ EmulatorOps.zone.NEW[Selection.SourceObject];	dummy^ ¬ [c, c.left, c.right, c.left];	source^ ¬ [dummy, SourceProc, DestroyProc];	p ¬ source};      string => {        string: LONG STRING ¬ NIL;	count: CARDINAL ¬ CountIt[c, c.left, c.right];	string ¬ Heap.systemZone.NEW[StringBody[count]];	SelectionToString[c, string];	p ¬ string};      ENDCASE;    RETURN[p];    };      PosFromPlace: PROC[c: EmulatorOps.EContext, place: Window.Place]     RETURNS [pos: CARDINAL] = INLINE {    x: CARDINAL ¬ IF place.x < EmulatorOps.LMargin THEN 0 ELSE      (place.x - EmulatorOps.LMargin) / c.fonts[normal].maxWidth;    y: CARDINAL ¬ (MAX[0, place.y]) / c.fonts[normal].height;    y ¬ MIN[y, c.lines-1];    x ¬ MIN[x, lt[y]];    pos ¬ c.columns*y + x;    };      PosToCoord: PROC[c: EmulatorOps.EContext, pos: CARDINAL]     RETURNS [x,y: CARDINAL] = INLINE {    x ¬ pos MOD c.columns;    y ¬ pos  /  c.columns;    };      CoordToPos: PROC[c: EmulatorOps.EContext, x,y: CARDINAL]     RETURNS [pos: CARDINAL] = INLINE {     pos ¬ c.columns*y + x;    };      SourceProc: Selection.SourceProc = {    d: MySourceType ¬ data;    c: EmulatorOps.EContext ¬ d.c;    CR: BOOLEAN ¬ FALSE;    x,y,k,pos:CARDINAL ¬ 0;    IF d.right <= d.index THEN string.length ¬ 0    ELSE {      pos ¬ d.index;      WHILE pos <= d.right AND k < string.maxlength DO        [x,y] ¬ PosToCoord[c, pos];	SELECT TRUE FROM	  CR => {string[k] ¬ Ascii.CR; pos ¬ pos + 1; CR ¬ FALSE};          x > lt[y] => {	    string[k] ¬ Ascii.CR; 	    y ¬ y + 1; x ¬ 0;	    pos ¬ CoordToPos[c,x,y]};	  x = c.columns - 1 => {string[k] ¬ 	    c.source[y][x].char; CR ¬ TRUE};	ENDCASE => {string[k] ¬ 	  c.source[y][x].char; pos ¬ pos + 1};	k ¬ k + 1;	ENDLOOP;      string.length ¬ k;      d.index ¬ pos;      };    };      SelectionToString: PROC[c: EmulatorOps.EContext, string: LONG STRING] = {    CR: BOOLEAN ¬ FALSE;    x,y,k,pos:CARDINAL ¬ 0;    pos ¬ c.left;    WHILE pos <= c.right AND k < string.maxlength DO      [x,y] ¬ PosToCoord[c, pos];      SELECT TRUE FROM	CR => {string[k] ¬ Ascii.CR; pos ¬ pos + 1; CR ¬ FALSE};	x > lt[y] => {	  string[k] ¬ Ascii.CR; 	  y ¬ y + 1; x ¬ 0;	  pos ¬ CoordToPos[c,x,y]};	x = c.columns - 1 => {string[k] ¬ 	  c.source[y][x].char; CR ¬ TRUE};      ENDCASE => {string[k] ¬ c.source[y][x].char; pos ¬ pos + 1};      k ¬ k + 1;      ENDLOOP;    string.length ¬ k;    };      CountIt: PROC[c: EmulatorOps.EContext, left, right: CARDINAL]     RETURNS [length: CARDINAL ¬ 0] = {    CR: BOOLEAN ¬ FALSE;    x,y,k,pos:CARDINAL ¬ 0;    pos ¬ left;    WHILE pos <= right DO      [x,y] ¬ PosToCoord[c, pos];      SELECT TRUE FROM	CR => {pos ¬ pos + 1; CR ¬ FALSE};	x > lt[y] => {	  y ¬ y + 1; x ¬ 0;	  pos ¬ CoordToPos[c,x,y]};	x = c.columns - 1 => {CR ¬ TRUE};      ENDCASE => {pos ¬ pos + 1};      k ¬ k + 1;      ENDLOOP;    length ¬ k;    };      DestroyProc: Selection.DestroyProc = {    EmulatorOps.zone.FREE[@source.data];    EmulatorOps.zone.FREE[@source];    };      Init[];    END.  
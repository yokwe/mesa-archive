-- File: TermCapImplB.mesa - last edit by:-- BGY	28-Jul-85 14:40:35-- Sort proc.-- Copyright (C) Xerox Corporation 1983, 1984, 1985. All rights reserved.DIRECTORY  GSort,  Heap,  String,  TermCap,  StateDefs;TermCapImplB: PROGRAM  IMPORTS  GSort, Heap, String, TermCap  EXPORTS TermCap =  BEGIN    z: UNCOUNTED ZONE = Heap.systemZone;    Sort: PUBLIC PROC[temp:StateDefs.CommandHandle]     RETURNS [sortedTable:StateDefs.SortHandle]={    i:StateDefs.Actions ¬ FIRST[StateDefs.Actions];    size: CARDINAL ¬ 0;    finished: BOOLEAN ¬ FALSE;    firstTime: BOOLEAN ¬ TRUE;    put: CARDINAL ¬ 0;    tempTable: StateDefs.SortHandle;        GetIndex: GSort.GetProcType = {      ptr: StateDefs.TempStateHandle = p;      IF finished THEN RETURN [0];      WHILE i # LAST[StateDefs.Actions] AND temp[i] = NIL DO        i ¬ SUCC[i];	ENDLOOP;      IF i # LAST[StateDefs.Actions] THEN {        ptr.i ¬ i;	size ¬ size + 1;	i ¬ SUCC[i];	RETURN [SIZE[StateDefs.TempStateObject]]}      ELSE {        finished ¬ TRUE;        IF temp[i] = NIL THEN RETURN [0]	ELSE {	  ptr.i ¬ i;	  size ¬ size + 1;	  RETURN [SIZE[StateDefs.TempStateObject]]};        };      };          PutIndex: GSort.PutProcType = {      ptr: StateDefs.TempStateHandle = p;      IF firstTime THEN {        sortedTable ¬ z.NEW[StateDefs.SortedObject[size]];	FOR j: CARDINAL IN [0..size) DO	  sortedTable[j] ¬ StateDefs.TempStateObject[	    i: LAST[StateDefs.Actions],	    end: StateDefs.nullValue, last: StateDefs.nullValue,	    consumed: FALSE];	  ENDLOOP;        firstTime ¬ FALSE;	};      IF put > 0 AND String.CompareStrings[temp[sortedTable[put-1].i],        temp[ptr.i], FALSE] = 0 THEN {	SIGNAL TermCap.AmbiguousEntry[sortedTable[put-1].i, ptr.i];	RETURN};      sortedTable[put].i ¬ ptr.i;      put ¬ put + 1;      };        CompareEntries: GSort.CompareProcType = {      ptr1: StateDefs.TempStateHandle = p1;      ptr2: StateDefs.TempStateHandle = p2;      RETURN [String.CompareStrings[temp[ptr1.i], temp[ptr2.i], FALSE]];      };          GSort.Sort[      get: GetIndex, put: PutIndex, compare: CompareEntries,      expectedItemSize: SIZE[StateDefs.TempStateObject],      maxItemSize: SIZE[StateDefs.TempStateObject]];    tempTable ¬ sortedTable;    sortedTable ¬ z.NEW[StateDefs.SortedObject[put]];    FOR x: CARDINAL IN [0..put) DO sortedTable[x] ¬ tempTable[x] ENDLOOP;    z.FREE[@tempTable];    };      END...  
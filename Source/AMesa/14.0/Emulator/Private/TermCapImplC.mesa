-- File: TermCapImplC.mesa - last edit by:-- BGY	28-Jul-85 14:40:53-- table generator.-- Copyright (C) Xerox Corporation 1983, 1984, 1985. All rights reserved.DIRECTORY  Ascii,  Heap,  String,  TermCap,  StateDefs;TermCapImplC: PROGRAM  IMPORTS Heap, String  EXPORTS TermCap =  BEGIN    z: UNCOUNTED ZONE ¬ Heap.systemZone;    TakesParamType: TYPE = {cm,ch,cv,cs};  -- cursor motion, horiz, vert, scroll  ParamArray: TYPE = ARRAY TakesParamType OF LONG STRING ¬ ALL[NIL];  Parameter: TYPE = LONG POINTER TO ParamArray;  pars: Parameter ¬ z.NEW[ParamArray];  ParameterProc: TYPE = PROCEDURE[p: TakesParamType];    AmbiguousEntry: PUBLIC SIGNAL[    s1,s2: StateDefs.Actions] = CODE;      ParseError: PUBLIC SIGNAL[    c: StateDefs.Actions, code: TermCap.ParseCode] = CODE;    MakeTable: PUBLIC PROC[    data: StateDefs.Handle,    sortedTable:StateDefs.SortHandle,    keys: StateDefs.KeyBoardHandle,    temp: StateDefs.CommandHandle] = {    pos, currentState: CARDINAL ¬ 0;        ParseExpression: PROC[      action: StateDefs.Actions, X: BOOLEAN, params: CARDINAL] = {      s: LONG STRING ¬ temp[action];      c:CHARACTER;      eat: CARDINAL ¬ params;      tempState, oneArg, twoArg: CARDINAL ¬ 0;      i: CARDINAL ¬ 0;      [oneArg, twoArg] ¬ CountParameters[];      DO        tempState ¬ NextState[tempState, s[i]];	IF (data.state[tempState].action = action) OR	  (data.state[tempState].char = '%) THEN EXIT;	i ¬ i + 1;	tempState ¬ data.state[tempState].nextState;	ENDLOOP;      IF s[i] = '% THEN i ¬ i - 1;      data.state[tempState].action ¬ NullState;      data.state[tempState].nextState ¬ pos;      data.state[tempState].eatChars ¬ TRUE;      IF data.state[tempState].char = '% THEN {	  data.state[tempState].char ¬ '0; -- works only for %d type expressions.          data.state[tempState].eatChars ¬ FALSE};      i ¬ i + 1;      WHILE i < s.length DO        SELECT s[i] FROM	  '% => { 	    i ¬ i + 1; 	    SELECT s[i] FROM	    'd => {	      eat ¬ eat - 1;	      SetNextState[	        '0, pos, 1, IF X THEN CollectXValue ELSE CollectYValue];	      i ¬ i + 1;	      c ¬ s[i];	      SELECT eat FROM	        1 => {		  IF pars[cv] # NIL THEN 		    SetNextState[GetEnd[cv], 0, 1, CursorMotionVertical];		  IF pars[ch] # NIL THEN 		    SetNextState[GetEnd[ch], 0, 1, CursorMotionHorizontal];		  SetNextState[c, pos+2, 1, NullState];		  SetNextState[Ascii.NUL, 0, 1, ErrorState];		  };		0 => {		  IF pars[cs] # NIL THEN 		    SetNextState[GetEnd[cs], 0, 1, ScrollingRegion];		  SetNextState[c, 0, 1, CursorAddress];		  SetNextState[Ascii.NUL, 0, 1, ErrorState];		  RETURN;		  };		ENDCASE;	      X ¬ ~X};	    '2 => {	      eat ¬ eat - 1;	      SetNextState[	        '0, pos + 2, 1, IF X THEN CollectXValue ELSE CollectYValue];	      SetNextState[Ascii.NUL, 0, 1, ErrorState];	      SetNextState[	        '0, pos + 2, eat, IF X THEN CollectXValue ELSE CollectYValue];	      SetNextState[Ascii.NUL, 0, 1, ErrorState];	      X ¬ ~X};	    '3 => {	      eat ¬ eat - 1;	      SetNextState[	        '0, pos + 2, 1, IF X THEN CollectXValue ELSE CollectYValue];	      SetNextState[Ascii.NUL, 0, 1, ErrorState];	      SetNextState[	        '0, pos + 2, 1, IF X THEN CollectXValue ELSE CollectYValue];	      SetNextState[Ascii.NUL, 0, 1, ErrorState];	      SetNextState[	        '0, pos + 2, eat, IF X THEN CollectXValue ELSE CollectYValue];	      SetNextState[Ascii.NUL, 0, 1, ErrorState];	      X ¬ ~X};	    '. => {	      eat ¬ eat - 1;	      SetNextState[	        Ascii.NUL, pos+1, eat, IF X THEN SubXDiff ELSE SubYDiff];	      X ¬ ~X};	    '+ => {	      i ¬ i + 1;	      c ¬ s[i];	      eat ¬ eat - 1;	      IF X THEN data.num[XDiff] ¬ data.num[XDiff]  + c.ORD	           ELSE data.num[YDiff] ¬ data.num[YDiff]  + c.ORD;	      SetNextState[	        Ascii.NUL, pos+1, eat, IF X THEN SubXDiff ELSE SubYDiff];	      X ¬ ~X};	    '> => {SIGNAL ParseError[action, notImplemented]; RETURN};	    'r => X ¬ ~X;	    'i => {	      data.num[XDiff] ¬ data.num[XDiff] + 1;	      data.num[YDiff] ¬ data.num[YDiff] + 1;	      };	    '% => {	      SetNextState['%, pos+2, 1, NullState];	      SetNextState[Ascii.NUL, 0, 1, ErrorState];	      };	    'n => {SIGNAL ParseError[action, notImplemented]; RETURN};	    'B => {SIGNAL ParseError[action, notImplemented]; RETURN};	    'D => {SIGNAL ParseError[action, notImplemented]; RETURN};	    ENDCASE => {SIGNAL ParseError[action, badChar]; RETURN};	    };	  ENDCASE => {	    c ¬ s[i];	    SetNextState[c, pos+2,  1, NullState];	    SetNextState[Ascii.NUL, 0, 1, ErrorState];	    };	i ¬ i + 1;        ENDLOOP;	SetNextState[Ascii.NUL, 0, 1, action];      };          NextState: PROC[state: CARDINAL, c: CHARACTER] RETURNS [new:CARDINAL] = {      j: CARDINAL ¬ state;      WHILE data.state[j].char # Ascii.NUL AND data.state[j].char # c DO        j ¬ j + 1;        ENDLOOP;      new ¬ j;     };        GetString: PROC[index: CARDINAL] RETURNS [LONG STRING] =      {RETURN[ temp[sortedTable[index].i]]};          LastSame: PROC[start, end, level: CARDINAL] RETURNS [CARDINAL]= {      s: LONG STRING ¬ GetString[start];      c: CHARACTER;      next: CARDINAL ¬ start + 1;      IF level >= s.length OR start >= end THEN RETURN[start];      c ¬ s[level];      WHILE next <= end DO        s ¬ GetString[next];	IF level >= s.length THEN EXIT;	IF c # s[level] THEN EXIT;	next ¬ next + 1;	ENDLOOP;      RETURN [next - 1];      };                TestState: PROC[start, end, level: CARDINAL]       RETURNS [ok: BOOLEAN, s1,s2: StateDefs.Actions] = {            -- Only one string in the given range can have a size less than      -- the level of string parsing.  If more that one string has a length      -- less than the level, and error should be raised to note ambiguous      -- entries.            index: CARDINAL ¬ start;      ok ¬ TRUE; s1 ¬ s2 ¬ NullState;      WHILE index <= end AND GetString[index].length > level DO        index ¬ index + 1;	ENDLOOP;      IF index > end THEN RETURN;      s1 ¬ sortedTable[index].i;      index ¬ index + 1;      WHILE index <= end AND GetString[index].length > level DO        index ¬ index + 1;	ENDLOOP;      IF index > end THEN RETURN;      ok ¬ FALSE;      s2 ¬ sortedTable[index].i;      };          SetNextState: PROC[      char: CHARACTER, next, eat: CARDINAL,       action: StateDefs.Actions] = {      data.state[pos] ¬ [        char: char, nextState: next, eatChars: eat>0, action: action];      pos ¬ pos + 1;      data.head.numberOfStates ¬ data.head.numberOfStates + 1;      };          BuildOneState: PROC[start, end, level: CARDINAL] = {      s1,s2: StateDefs.Actions;      ok: BOOLEAN;      list: CARDINAL ¬ start;      next, j, nextEnd: CARDINAL ¬ 0;      [ok, s1, s2] ¬ TestState[start, end, level];      IF ~ok THEN ERROR AmbiguousEntry[s1, s2];      sortedTable[start].end ¬ StateDefs.nullValue;      currentState ¬ pos;      IF level > 0 THEN         -- must guarantee then sortedTable[start].last has valid value        data.state[sortedTable[start].last].nextState ¬ currentState;      WHILE list <= end DO        IF sortedTable[list].consumed THEN {list ¬ list + 1; LOOP};	next ¬ LastSame[list, end, level];	IF next = list THEN {	  tString: LONG STRING ¬ GetString[list];	  IF s1 # sortedTable[list].i THEN {	    SetNextState[	      tString[level], 0, tString.length - level, sortedTable[list].i]};	  sortedTable[list].consumed ¬ TRUE;	  }	ELSE {	  sortedTable[list].end ¬ next;	  sortedTable[list].last ¬ pos;	  SetNextState[	    GetString[list][level], StateDefs.nullValue, 1, NullState];	  IF GetString[list][level] = '% THEN -- cursor motion stuff	    FOR ind: CARDINAL IN [list..next] DO 	      sortedTable[ind].consumed ¬ TRUE;	      ENDLOOP;	    };	list ¬ next + 1;	ENDLOOP;      SELECT TRUE FROM        level = 0 =>        SetNextState[Ascii.NUL, 0, 1, StuffChar];	s1 # NullState => SetNextState[Ascii.NUL, 0, 0, s1];	ENDCASE =>          SetNextState[Ascii.NUL, 0, 1, ErrorState];      list ¬ start;      WHILE list < end DO        WHILE list < end AND sortedTable[list].consumed DO	  list ¬ list + 1;	  ENDLOOP;	IF sortedTable[list].consumed THEN RETURN;	nextEnd ¬ sortedTable[list].end;	IF nextEnd = StateDefs.nullValue THEN ERROR;	BuildOneState[list, nextEnd, level+1];	list ¬ nextEnd + 1;	ENDLOOP;      };          data.head.numberOfStates ¬ 0;    BuildOneState[0, sortedTable.length - 1, 0];    FillParameterItems[temp];    IF temp[CursorAddress] # NIL THEN ParseExpression[CursorAddress, FALSE, 2];    FillDefaultKeys[keys, temp];    FillKeyStrings[data, @data.state[data.head.numberOfStates], keys];    };        FillParameterItems: PROC[temp:StateDefs.CommandHandle]={    pars[cm] ¬ temp[CursorAddress];    pars[ch] ¬ temp[CursorMotionHorizontal];    pars[cv] ¬ temp[CursorMotionVertical];    pars[cs] ¬ temp[ScrollingRegion];    };      GetEnd: PROC[i: TakesParamType] RETURNS [c:CHARACTER] = {    j: CARDINAL;    FOR j DECREASING IN [0..pars[i].length) DO      IF pars[i].text[j] = '% THEN {        c ¬ pars[i].text[j + 2];	RETURN;	};      ENDLOOP;    };    EnumerateParameterItems: PROC[proc: ParameterProc] = {    FOR i: TakesParamType IN TakesParamType DO      IF pars[i] # NIL THEN proc[i];      ENDLOOP;    };  CountParameters: PROC RETURNS[oneArg, twoArg: CARDINAL] = {    oneArg ¬ twoArg ¬ 0;    IF pars[ch] # NIL THEN oneArg ¬ oneArg + 1;    IF pars[cv] # NIL THEN oneArg ¬ oneArg + 1;    IF pars[cm] # NIL THEN twoArg ¬ twoArg + 1;    IF pars[cs] # NIL THEN twoArg ¬ twoArg + 1;    };  FillDefaultKeys: PROC[    keys:StateDefs.KeyBoardHandle,    temp:StateDefs.CommandHandle]={    IF keys[backspaceKey] = NIL AND temp[CursorBackward] # NIL THEN      keys[backspaceKey] ¬ String.CopyToNewString[temp[CursorBackward], z];    IF keys[leftArrowKey] = NIL AND temp[CursorBackward] # NIL THEN      keys[leftArrowKey] ¬ String.CopyToNewString[temp[CursorBackward], z];    IF keys[downArrowKey] = NIL AND temp[CursorDown] # NIL THEN      keys[downArrowKey] ¬ String.CopyToNewString[temp[CursorDown], z];    IF keys[upArrowKey] = NIL AND temp[CursorUp] # NIL THEN      keys[upArrowKey] ¬ String.CopyToNewString[temp[CursorUp], z];    IF keys[rightArrowKey] = NIL AND temp[CursorForward] # NIL THEN      keys[rightArrowKey] ¬ String.CopyToNewString[temp[CursorForward], z];    };      FillKeyStrings: PUBLIC PROC[    data:StateDefs.Handle,    ptr: LONG POINTER,     keys:StateDefs.KeyBoardHandle]={    i: StateDefs.KeyboardValues;    last, j: CARDINAL ¬ 0;    chars: StateDefs.StringHeapHandle ¬ ptr;    FOR i IN StateDefs.KeyboardValues DO      IF keys[i] = NIL THEN data.key[i] ¬ StateDefs.StringPtr[0,0]      ELSE {        data.key[i].start ¬ last;	FOR j IN [0..keys[i].length) DO	  chars[last] ¬ keys[i].text[j];	  last ¬ last + 1;	  ENDLOOP;	data.key[i].length ¬ keys[i].length;	};      ENDLOOP;    data.head.lengthOfKeyStrings ¬ last;    };      END...  
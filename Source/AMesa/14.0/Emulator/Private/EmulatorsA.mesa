-- File: EmulatorsA.mesa - last edit:-- Riggle.PA            9-Jan-87 10:34:50-- EmulatorsA.mesa-- Last Edit:-- BGY     	24-Jul-85 13:38:44-- Copyright (C) 1984, 1987 by Xerox Corporation. All rights reserved.DIRECTORY  BitBlt USING [AlignedBBTable, BBptr, BBTableSpace, BITBLT],  CmFile USING [FreeString, UserDotCmLine],  Context USING [Acquire, Create, Destroy, Find, Type, UniqueType],  Display USING [replaceFlags],  Emulator USING [ErrorCode, RefreshHint, TerminalType],  EmulatorOps USING [    ActivateCaret, AttributeRec, Blank, context,     DisplayProc, EContext, EContextObject, FindContext,     FontArray, ForceScroll, GetKeyValue, InternalClear,     KillOptions, LMargin, lock, myTip, Notify, ReleaseContext, TypeInProc],  FontOps USING [Terminal10, VT10],  Heap USING [Create, systemMDSZone],  Inline USING [LongCOPY],  MFile USING [    Acquire, Error, Handle, Object, PleaseReleaseProc],  MStream USING [    Error, Handle, Log, PleaseReleaseProc, SetLogReadLength],  Process USING [    Abort, DisableTimeout, InitializeCondition, MsecToTicks,     priorityNormal, SetPriority],  Runtime USING [ControlLink, GetTableBase, GlobalFrame],  Selection USING [ActOn, Set],  StateDefs USING [Handle, version],  Stream USING [Delete, GetPosition, Object],  String USING [AppendChar, AppendString, Length],  TerminalOps USING [Terminal],  TIP USING [CreateClient],  Tool USING [RegisterSWType, SWType],  ToolFont USING [Create],  ToolWindow USING [AdjustProcType, Box, nullBox],  UserInput USING [    CreateStringInOut, DestroyStringInOut, SetInputFocus, StringProcType],  Window USING [Box, Handle, InvalidateBox, Object, SetDisplayProc, SlideAndSize],  WindowFont USING [defaultFont, Handle, Initialize, Object];    EmulatorsA: MONITOR LOCKS EmulatorOps.lock  IMPORTS     BitBlt, CmFile, Context, EmulatorOps, FontOps, Heap, Inline,    MFile, MStream, Process, Tool, Window,     Selection, String, Stream, Runtime, WindowFont, TerminalOps,     TIP, ToolFont, UserInput   EXPORTS Emulator, EmulatorOps =  BEGIN    HeaderType: TYPE =     ARRAY Emulator.TerminalType OF  CARDINAL ¬ ALL[0];    TableHandle: TYPE = LONG POINTER TO Table;  Table: TYPE =  ARRAY [0..0) OF UNSPECIFIED;    FileHandle: TYPE = LONG POINTER TO FileType;  FileType: TYPE = RECORD [    head: HeaderType,    data: Table];      lock: PUBLIC MONITORLOCK;  zone: PUBLIC UNCOUNTED ZONE ¬ Heap.Create[    initial:60, increment: 10, largeNodeThreshold: 1024];  Error: PUBLIC SIGNAL [code: Emulator.ErrorCode] = CODE;  EmuSWType: PUBLIC Tool.SWType = Tool.RegisterSWType[adjust: MyAdjust];  context: PUBLIC Context.Type;  graFonts, sysFonts: EmulatorOps.FontArray ¬ ALL[NIL];    UpdateScreenStart: PUBLIC CONDITION;  UpdateScreenFinished: PUBLIC CONDITION;  ForceOutStart: PUBLIC CONDITION;  ForceOutFinished: PUBLIC CONDITION;    table: PUBLIC ARRAY Emulator.TerminalType OF StateDefs.Handle;  scrollLines: CARDINAL ¬ 1;    MyAdjust: ToolWindow.AdjustProcType = {    c: EmulatorOps.EContext ¬ EmulatorOps.FindContext[window];    IF c = NIL THEN Error[notAEmuSW];    BEGIN ENABLE UNWIND => EmulatorOps.ReleaseContext[window];    c.frame ¬ box;    window.SlideAndSize[box];    END;    EmulatorOps.ReleaseContext[window];    };    Create: PUBLIC ENTRY PROC[    sw: Window.Handle,     data: StateDefs.Handle,     typeIn: UserInput.StringProcType,    otherData: StateDefs.Handle ¬ NIL,     font: WindowFont.Handle ¬ NIL,    logfile: LONG STRING ¬ NIL,    writeToLog: BOOLEAN ¬ FALSE,    refresh: Emulator.RefreshHint ¬ half,    remote: BOOLEAN ¬ FALSE] ={    ENABLE UNWIND => NULL;    myContext: EmulatorOps.EContext;    box: Window.Box ¬ ToolWindow.nullBox;    fonts: EmulatorOps.FontArray ¬ [NIL, NIL, NIL, NIL];    lines, columns, maxColumns: CARDINAL;    IF sw = NIL THEN ERROR Error[invalidWindow];    IF font = NIL THEN       fonts ¬ sysFonts ELSE fonts ¬ InternalMakeFont[font];    IF data = NIL THEN Error[badData];    IF (myContext ¬ EmulatorOps.FindContext[sw]) # NIL THEN {      EmulatorOps.ReleaseContext[sw]; ERROR Error[alreadyAEmuSW]};    lines ¬ data.num[linesOnPage];    columns ¬ maxColumns ¬ data.num[columnsInLine];    box.dims ¬ [      h: lines * fonts[normal].height,       w: ((columns*fonts[normal].maxWidth + EmulatorOps.LMargin+ 15)/16)*16];    myContext ¬ zone.NEW[EmulatorOps.EContextObject[lines]  ¬ [      sw: sw, lines: lines, columns: columns, top: 0, bot: lines-1,      linesPerScroll: scrollLines, data: data,       fonts: fonts, regFonts: fonts, graFonts: graFonts,      scrollHeight: lines, otherData: otherData, wrap: data.bool[autoWrap],      frame: box, hardTabs: data.bool[hardwareTabs],       source:]];    IF logfile # NIL THEN  {      myContext.logfile ¬ GetLogFile[logfile, myContext];      myContext.writeToLog ¬ writeToLog};    InitBacking[c: myContext, lines: lines, columns: columns];    FOR j: CARDINAL ¬ 8, j+8 UNTIL j > 132 DO myContext.tabs[j] ¬ TRUE ENDLOOP;    myContext.identify ¬ EmulatorOps.GetKeyValue[myContext, identifyTerminal];    myContext.cursorStatus ¬ EmulatorOps.GetKeyValue[myContext, cursorPosition];    Context.Create[context, myContext, DestroyContext, sw];    [] ¬ sw.SetDisplayProc[EmulatorOps.DisplayProc];    sw.InvalidateBox[box];    UserInput.CreateStringInOut[      window: sw, in: typeIn, out: EmulatorOps.TypeInProc,      caretProc: EmulatorOps.ActivateCaret];    TIP.CreateClient[window: sw, table: EmulatorOps.myTip,      notify: EmulatorOps.Notify];    myContext.forceOut ¬ FORK ForceOutProcess[sw];    myContext.updater ¬ FORK UpdaterProcess[sw];    };    GetLogFile: PROC[name: LONG STRING, myContext: EmulatorOps.EContext]     RETURNS [file: MStream.Handle ¬ NIL] = {    newName: LONG STRING ¬ zone.NEW[StringBody[name.length + 30]];    newName.length ¬ 0; String.AppendString[newName, name];    DO      file ¬ MStream.Log[newName, [LogRelease, myContext]!         MStream.Error => CONTINUE];      IF file # NIL THEN EXIT;      String.AppendChar[newName, '$];      ENDLOOP;    };    LogRelease: MStream.PleaseReleaseProc = {    MStream.SetLogReadLength[stream, Stream.GetPosition[stream]];    RETURN[no]};    debug1: BOOLEAN ¬ FALSE;  debug2: BOOLEAN ¬ FALSE;    UpdaterProcess: ENTRY PROC[sw: Window.Handle] = {    ENABLE {ABORTED => GOTO quit; UNWIND => NULL};    c: EmulatorOps.EContext ¬ Context.Find[context,sw];    Process.SetPriority[Process.priorityNormal];    DO      IF c = NIL THEN GOTO quit;      WHILE c.charCount = 0 DO        WAIT UpdateScreenStart;	c  ¬ Context.Find[context,sw];	IF c = NIL THEN GOTO quit;	ENDLOOP;      EmulatorOps.ForceScroll[sw, c];      c.charCount ¬ 0;      BROADCAST UpdateScreenFinished;      ENDLOOP;    EXITS quit => NULL;    };    ForceOutProcess: ENTRY PROC[sw: Window.Handle] = {    ENABLE {ABORTED => GOTO quit; UNWIND => NULL};    c: EmulatorOps.EContext ¬ Context.Find[context,sw];    Process.SetPriority[Process.priorityNormal];    DO      IF c = NIL THEN GOTO quit;      WHILE ~c.dirty DO        WAIT ForceOutStart;	c  ¬ Context.Find[context,sw];	IF c = NIL THEN GOTO quit;	ENDLOOP;      EmulatorOps.ForceScroll[sw, c];      c.dirty ¬ FALSE;      c.charCount ¬ 0;      BROADCAST ForceOutFinished;      ENDLOOP;    EXITS quit => NULL;    };    Destroy: PUBLIC PROC [sw: Window.Handle] = {    myContext: EmulatorOps.EContext ¬ EmulatorOps.FindContext[sw];    IF myContext = NIL THEN ERROR Error[notAEmuSW];    EmulatorOps.ReleaseContext[sw];    UserInput.DestroyStringInOut[sw];    Context.Destroy[context, sw];    };      DestroyContext: PROCEDURE [myContext: EmulatorOps.EContext, sw: Window.Handle] =    BEGIN    IF myContext = NIL THEN RETURN;    IF myContext.forceOut # NIL THEN Process.Abort[myContext.forceOut];    IF myContext.updater # NIL THEN Process.Abort[myContext.updater];    IF myContext.forceOut # NIL THEN JOIN myContext.forceOut;    IF myContext.updater # NIL THEN JOIN myContext.updater;    IF myContext.logfile # NIL THEN Stream.Delete[myContext.logfile];    FOR i: CARDINAL IN [0..myContext.nLine) DO      IF myContext.source[i] # NIL THEN zone.FREE[@myContext.source[i]];      ENDLOOP;    IF myContext.optionWindow # NIL THEN EmulatorOps.KillOptions[      myContext.optionWindow, [0,0]];    IF myContext.ownFocus  THEN {      myContext.ownFocus ¬ FALSE;      UserInput.SetInputFocus[NIL, NIL, FALSE, NIL]};    IF myContext.ownSelect THEN {      myContext.ownSelect ¬ FALSE;      Selection.Set[NIL,NIL,NIL]};    zone.FREE[@myContext];    END;      StartLog: PUBLIC PROC[sw: Window.Handle] = {    c: EmulatorOps.EContext ¬ EmulatorOps.FindContext[sw];    IF c = NIL THEN ERROR Error[notAEmuSW];    c.writeToLog ¬ TRUE;    EmulatorOps.ReleaseContext[sw];    };      StopLog: PUBLIC PROC[sw: Window.Handle] = {    c: EmulatorOps.EContext ¬ EmulatorOps.FindContext[sw];    IF c = NIL THEN ERROR Error[notAEmuSW];    c.writeToLog ¬ FALSE;    EmulatorOps.ReleaseContext[sw];    };    SetRefresh: PUBLIC PROC[sw: Window.Handle, refresh: Emulator.RefreshHint] = {    c: EmulatorOps.EContext ¬ EmulatorOps.FindContext[sw];    IF c = NIL THEN ERROR Error[notAEmuSW];    c.refresh ¬ refresh;    EmulatorOps.ReleaseContext[sw];    };    IsIt: PUBLIC PROC[sw: Window.Handle] RETURNS [BOOLEAN] = {    RETURN [Context.Find[context, sw] # NIL]};        GetInsertion: PUBLIC PROC [sw: Window.Handle] RETURNS [x,y: CARDINAL]={    myContext: EmulatorOps.EContext ¬ EmulatorOps.FindContext[sw];    IF myContext = NIL THEN ERROR Error[notAEmuSW];    EmulatorOps.ReleaseContext[sw];    RETURN[myContext.x, myContext.y];    };      GetLines: PUBLIC PROC[sw: Window.Handle] RETURNS [lines: CARDINAL] = {    myContext: EmulatorOps.EContext ¬ EmulatorOps.FindContext[sw];    IF myContext = NIL THEN ERROR Error[notAEmuSW];    lines ¬ myContext.lines;    EmulatorOps.ReleaseContext[sw]    };      GetColumns: PUBLIC PROC[sw: Window.Handle] RETURNS [columns: CARDINAL] = {    myContext: EmulatorOps.EContext ¬ EmulatorOps.FindContext[sw];    IF myContext = NIL THEN ERROR Error[notAEmuSW];    columns ¬ myContext.columns;    EmulatorOps.ReleaseContext[sw];    };      GetScreenChar: PUBLIC PROC[sw: Window.Handle, x,y: CARDINAL]     RETURNS [char: CHARACTER] = {    myContext: EmulatorOps.EContext ¬ EmulatorOps.FindContext[sw];    IF myContext = NIL THEN ERROR Error[notAEmuSW];    BEGIN ENABLE UNWIND => EmulatorOps.ReleaseContext[sw];    IF ~(x IN [0..myContext.columns)) THEN SIGNAL Error[xOutOfRange];    IF ~(y IN [0..myContext.lines)) THEN SIGNAL Error[yOutOfRange];    char ¬ myContext.source[y][x].char;    END;    EmulatorOps.ReleaseContext[sw];    };      GetEmulator: PUBLIC PROC [sw:Window.Handle]     RETURNS [data:StateDefs.Handle] = {    c: EmulatorOps.EContext ¬ EmulatorOps.FindContext[sw];    IF c = NIL THEN  ERROR Error[notAEmuSW];    data ¬ c.data;    EmulatorOps.ReleaseContext[sw];    };    SetEmulator: PUBLIC PROC [sw:Window.Handle, data:StateDefs.Handle,     otherData:StateDefs.Handle ¬ NIL]    RETURNS [old: StateDefs.Handle] = {    c: EmulatorOps.EContext ¬ EmulatorOps.FindContext[sw];    newContext: EmulatorOps.EContext;    IF c = NIL THEN  ERROR Error[notAEmuSW];    BEGIN ENABLE UNWIND => EmulatorOps.ReleaseContext[sw];    IF data = NIL OR data.head.version # StateDefs.version THEN Error[other];    IF otherData # NIL AND otherData.head.version # StateDefs.version THEN      Error[other];    IF c.ownSelect THEN Selection.ActOn[clear];    EmulatorOps.InternalClear[c];    old ¬ c.data;    zone.FREE[@c.identify];    zone.FREE[@c.cursorStatus];    IF CARDINAL[data.num[linesOnPage]]#c.lines OR       MAX[132, c.columns] < CARDINAL[data.num[columnsInLine]] THEN {      newContext ¬ NewBackingStore[        data.num[linesOnPage], data.num[columnsInLine], c];      EmulatorOps.ReleaseContext[sw];      Context.Destroy[context,sw];      Context.Create[context, newContext, DestroyContext, sw];      c ¬ EmulatorOps.FindContext[sw];      c.forceOut ¬ FORK ForceOutProcess[sw];      c.updater ¬ FORK UpdaterProcess[sw];      };    c.otherData ¬ otherData;    c.data ¬ data;    c.identify ¬ EmulatorOps.GetKeyValue[c, identifyTerminal];    c.cursorStatus ¬ EmulatorOps.GetKeyValue[c, cursorPosition];    END;    EmulatorOps.ReleaseContext[sw];    };      NewBackingStore:PROC[    lines,columns: CARDINAL, c:EmulatorOps.EContext] RETURNS    [new: EmulatorOps.EContext] ={    box: Window.Box ¬ ToolWindow.nullBox;    box.dims ¬ [      h: lines * c.fonts[normal].height,       w: ((columns*c.fonts[normal].maxWidth + EmulatorOps.LMargin+ 15)/16)*16];    new ¬ zone.NEW[EmulatorOps.EContextObject[lines]  ¬ [source:]];    Inline.LongCOPY[      from: c, to: new, nwords: SIZE[EmulatorOps.EContextObject[0]] - 1];    new.frame ¬ box;    new.scrollHeight ¬ new.lines ¬ lines;    new.bot ¬ lines-1;    new.columns ¬ new.maxColumns ¬ columns;    c.logfile ¬ NIL;    InitBacking[c: new, lines: lines, columns: columns];    };    InitBacking: PROC[c:EmulatorOps.EContext, lines,columns: CARDINAL] = {    FOR i:CARDINAL IN [0..lines) DO      c.source[i] ¬ zone.NEW[EmulatorOps.AttributeRec[MAX[columns, 132]]];      FOR j: CARDINAL IN [0..columns) DO        c.source[i][j] ¬ EmulatorOps.Blank;        ENDLOOP;      c.source[i].font ¬ normal;      c.source[i].dirty ¬ FALSE;      ENDLOOP;    };    InternalMakeFont: PROC[font: WindowFont.Handle]    RETURNS [fonts: EmulatorOps.FontArray] = {    top, bottom: WindowFont.Handle ¬ NIL;    [top, bottom] ¬ MakeTallFonts[font];      RETURN[[        normal: font, wide: MakeWideFont[font], top: top, bottom: bottom]]};    FontSize: PROC [font: WindowFont.Handle] RETURNS [size: CARDINAL]= {    number: CARDINAL ¬ LOOPHOLE[font.max - font.min, CARDINAL];    size ¬ font.raster * font.height + number;    };    MakeNode: PROC[size: CARDINAL] RETURNS [LONG POINTER] = {    Node: TYPE = RECORD[SEQUENCE len: CARDINAL OF WORD];    RETURN[zone.NEW[Node[size]]];    };    DIVMOD16: PROC [d: CARDINAL] RETURNS [--q, r:-- CARDINAL, CARDINAL] = INLINE {    RETURN[d/16, d MOD 16]};--  bbTable: BitBlt.BBTableSpace;  bbPtr: PUBLIC BitBlt.BBptr ¬ BitBlt.AlignedBBTable[Heap.systemMDSZone.NEW[BitBlt.BBTableSpace]];    MakeWideFont: PROC[font: WindowFont.Handle]     RETURNS[wide: WindowFont.Handle] = {    size: CARDINAL ¬ 2 * FontSize[font];    node: LONG POINTER ¬ MakeNode[size];    height: CARDINAL = font.height;    srcBpl: CARDINAL = 16 * font.raster;    dstBpl: CARDINAL = 2 * srcBpl;    srcword, srcbit, dstword, dstbit: CARDINAL ¬ 0;    wide ¬ zone.NEW[WindowFont.Object ¬ [      height: font.height, kerned: FALSE, raster: 2*font.raster,      maxWidth: 2*font.maxWidth, min: font.min, max: font.max,      address: node, bitmap: node,       xInSegment: node + (2*font.raster*font.height) -       LOOPHOLE[font.min, INTEGER]]];    FOR c: CHARACTER IN ['\000..'\377] DO      wide.width[c] ¬ 2* font.width[c] ENDLOOP;    FOR c: CHARACTER IN [font.min..font.max] DO      wide.xInSegment[c] ¬ 2* font.xInSegment[c] ENDLOOP;    FOR ch: CHARACTER IN [font.min..font.max] DO      IF font.width[ch] = 0 THEN LOOP;      FOR i: CARDINAL IN [0..font.width[ch]) DO	[srcword, srcbit] ¬ DIVMOD16[font.xInSegment[ch]+i];	FOR j: CARDINAL IN [0..1] DO	  [dstword, dstbit] ¬ DIVMOD16[wide.xInSegment[ch]+(2*i)+j];	  bbPtr^ ¬ [	    dst: [word: wide.bitmap + dstword, bit: dstbit],	    src: [word: font.bitmap + srcword, bit: srcbit], dstBpl: dstBpl,	    height: height, width: 1, srcDesc: [srcBpl[srcBpl]],	    flags: Display.replaceFlags];	  BitBlt.BITBLT[bbPtr];	  ENDLOOP;	ENDLOOP;      ENDLOOP;    };    MakeTallFonts: PROC[font: WindowFont.Handle]     RETURNS[topFont, botFont: WindowFont.Handle] = {    top, bot: WindowFont.Handle ¬ NIL;    size: CARDINAL ¬ FontSize[font];    height: CARDINAL = font.height/2;    srcBpl: CARDINAL = 16 * font.raster;    dstBpl: CARDINAL = 2 * srcBpl;    width: CARDINAL = font.maxWidth;    offWord: CARDINAL ¬ font.raster;    botOffWord: CARDINAL ¬ font.raster * height;    word, bit: CARDINAL ¬ 0;    top ¬ zone.NEW[WindowFont.Object ¬ [address: font.address]];    bot ¬ zone.NEW[WindowFont.Object ¬ [address: font.address]];    WindowFont.Initialize[top];    WindowFont.Initialize[bot];    top.bitmap ¬ MakeNode[size];    bot.bitmap ¬ MakeNode[size];    FOR ch: CHARACTER IN [font.min..font.max] DO      IF font.width[ch] = 0 THEN LOOP;      [word, bit] ¬ DIVMOD16[font.xInSegment[ch]];      bbPtr^ ¬ [        dst: [word: top.bitmap + word, bit: bit],        src: [word: font.bitmap + word, bit: bit], dstBpl: dstBpl,        height: height, width: width, srcDesc: [srcBpl[srcBpl]],        flags: Display.replaceFlags];      BitBlt.BITBLT[bbPtr];      bbPtr^ ¬ [        dst: [word: top.bitmap + word + offWord, bit: bit],        src: [word: font.bitmap + word, bit: bit], dstBpl: dstBpl,        height: height, width: width, srcDesc: [srcBpl[srcBpl]],        flags: Display.replaceFlags];      BitBlt.BITBLT[bbPtr];      bbPtr^ ¬ [        dst: [word: bot.bitmap + word, bit: bit],        src: [word: font.bitmap + word + botOffWord, bit: bit], dstBpl: dstBpl,        height: height, width: width, srcDesc: [srcBpl[srcBpl]],        flags: Display.replaceFlags];      BitBlt.BITBLT[bbPtr];      bbPtr^ ¬ [        dst: [word: bot.bitmap + word + offWord, bit: bit],        src: [word: font.bitmap + word + botOffWord, bit: bit], dstBpl: dstBpl,        height: height, width: width, srcDesc: [srcBpl[srcBpl]],        flags: Display.replaceFlags];      BitBlt.BITBLT[bbPtr];      ENDLOOP;    topFont ¬ MakeWideFont[top];    botFont ¬ MakeWideFont[bot];    zone.FREE[@top.bitmap]; zone.FREE[@top];    zone.FREE[@bot.bitmap]; zone.FREE[@bot];    };    Init: PROC = {    data: FileHandle  ¬ NIL;    i: Emulator.TerminalType;    h: MFile.Handle ¬ NIL;    gFont, sFont: WindowFont.Handle ¬ NIL;    address: LONG POINTER ¬ NIL;    fontName: LONG STRING ¬ CmFile.UserDotCmLine["Emulator"L, "Font"L];    BEGIN ENABLE MFile.Error => GOTO quit;    context ¬ Context.UniqueType[];    address ¬ Runtime.GetTableBase[Runtime.GlobalFrame[LOOPHOLE[      FontOps.VT10]]];    gFont ¬ zone.NEW[WindowFont.Object ¬ [address: address]];    WindowFont.Initialize[gFont];    data ¬ Runtime.GetTableBase[Runtime.GlobalFrame[LOOPHOLE[      TerminalOps.Terminal, Runtime.ControlLink]]];    FOR i IN Emulator.TerminalType DO      table[i] ¬ LOOPHOLE[        @data.data[data.head[i]], StateDefs.Handle];      ENDLOOP;    IF String.Length[fontName] # 0 THEN {      h ¬ MFile.Acquire[ name: fontName, access: readOnly, release: [NIL, NIL]!        MFile.Error => CONTINUE];      IF h # NIL THEN sFont ¬ ToolFont.Create[h]      ELSE sFont ¬ WindowFont.defaultFont;      };    IF sFont = NIL THEN {      address ¬ Runtime.GetTableBase[Runtime.GlobalFrame[LOOPHOLE[        FontOps.Terminal10]]];      sFont ¬ zone.NEW[WindowFont.Object ¬ [address: address]];      WindowFont.Initialize[sFont];      };    sysFonts ¬ InternalMakeFont[sFont];    graFonts ¬ InternalMakeFont[gFont];    EXITS quit => NULL;    END;    IF fontName # NIL THEN fontName ¬ CmFile.FreeString[fontName];    Process.InitializeCondition[@UpdateScreenStart,       Process.MsecToTicks[200]];    Process.DisableTimeout[@UpdateScreenFinished];    Process.DisableTimeout[@ForceOutFinished];    Process.DisableTimeout[@ForceOutStart];    };      Init[];  END.  
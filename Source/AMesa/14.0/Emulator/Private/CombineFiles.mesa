-- CombineFiles.mesa-- BGY     	 28-Jul-85 14:47:44-- Copyright (C) Xerox Corporation 1983, 1984, 1985. All rights reserved.DIRECTORY  Emulator,  Format,  FormSW,  Heap,  Inline,  MFile,  MSegment,  Put,   StateDefs,  String,  Token,  Tool,  ToolWindow,  Window;  CombineFiles: PROGRAM   IMPORTS    Format, FormSW, Heap, Inline, MFile, MSegment, Put,     String, Token, Tool ={    HeaderType: TYPE =     ARRAY Emulator.TerminalType OF CARDINAL;    TableHandle: TYPE = LONG POINTER TO Table;  Table: TYPE =  ARRAY [0..0) OF UNSPECIFIED;    FileHandle: TYPE = LONG POINTER TO FileType;  FileType: TYPE = RECORD [    head: HeaderType,    data: Table];      DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = MACHINE DEPENDENT RECORD [    msgSW(0): Window.Handle ¬ NIL,    fileSW(2): Window.Handle ¬ NIL,    formSW(4): Window.Handle ¬ NIL,    files(6):  LONG STRING ¬ NIL];      td: DataHandle ¬ NIL;  tool: Window.Handle ¬ NIL;  pos:  CARDINAL ¬ 0;  i: Emulator.TerminalType ¬ FIRST[Emulator.TerminalType];  myState: Token.StandardFilterState;  state: Token.FilterState ¬ @myState;    mainSeg: MSegment.Handle ¬ NIL;  mainFile: MFile.Handle ¬ NIL;  table: FileHandle;  z: UNCOUNTED ZONE = Heap.systemZone;    InitFile: PROC = {    Write["Building data file\n"L];    mainFile ¬ MFile.ReadWrite[name: "Terminal.data", release: [],       type: binary, initialLength: 8192];    mainSeg ¬ MSegment.Create [file: mainFile, release:[], pages: 16];    table ¬ MSegment.Address[segment: mainSeg];    pos ¬ 0;    i ¬ FIRST[Emulator.TerminalType];    FOR j: Emulator.TerminalType IN Emulator.TerminalType DO      table.head[i] ¬ LAST[CARDINAL] ENDLOOP;    };      CloseFile: PROC = {    Write["File Size: "L];    Format.Number[Write, pos * 2, []];    Write[" bytes. \n"L];    MFile.SetLength[mainFile, (pos * 2) + (SIZE[FileType] * 2)];    MSegment.Delete[mainSeg];    };      Write: Format.StringProc= {Put.Text[td.fileSW, s]};    AddFile: PROC[s: LONG STRING] = {     file: MFile.Handle ¬ NIL;    seg: MSegment.Handle ¬ NIL;    length: LONG CARDINAL ¬ 0;    words: CARDINAL ¬ 0;    tempTable: TableHandle;    state: StateDefs.Handle;    table.head[i] ¬ pos;    i ¬ SUCC[i];    Write["Copying "L];    Write[s];    Write[". Size: "L];    file ¬ MFile.ReadOnly[name: s, release: []!      MFile.Error => {        Write["Problem with file "L];	Write[s];        Write[", MFile error: "L];	IF eList[code] # NIL THEN Write[eList[code]];	Write["\n"L];	GOTO quit;	}];    seg ¬ MSegment.Create [file: file, release:[],       pages: (file.GetLength[]/256)+1];    tempTable ¬ seg.Address[];    state ¬ LOOPHOLE[tempTable];    IF state.head.version # StateDefs.version THEN {      seg.Delete[];      Write["Invalid data file: "L];      Write[s];      Write["\n"L];      GOTO quit;      };    length ¬ MFile.GetLength[file];    words ¬  Inline.LowHalf[length+1]/2;    Format.Number[Write, words*2, []];    Write[". \n"L];    Inline.LongCOPY[tempTable, words,  @table.data[pos]];    pos ¬ pos + words;    seg.Delete[];    EXITS quit => NULL;    };      Combine: FormSW.ProcType = {    h: Token.Handle ¬ Token.StringToHandle[td.files, 0];    s: LONG STRING;    buf: LONG STRING ¬ z.NEW[StringBody[100]];    InitFile[];    DO      s ¬ h.Filtered[state, Token.FileName, whiteSpace, TRUE];      IF s = NIL THEN EXIT;      buf.length ¬ 0;      String.AppendString[buf,s];      String.AppendString[buf,".data"L];      AddFile[buf];      s ¬ Token.FreeTokenString[s];      ENDLOOP;    h ¬ h.FreeStringHandle[];    CloseFile[];    z.FREE[@buf];    };      Transition: ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      old = inactive => {        IF td = NIL THEN td ¬ z.NEW[Data ¬ []];	InitErrorCodes[]};      new = inactive =>        IF td # NIL THEN {	  z.FREE[@td];	  FreeErrorCodes[]};	        ENDCASE;    END;  MakeForm: FormSW.ClientItemsProcType ={    OPEN FormSW;    nItems: CARDINAL = 2;    items ¬ AllocateItemDescriptor[nItems];    items[0] ¬ CommandItem[      tag: "Combine"L, place: [0, line0], proc: Combine];    items[1] ¬ StringItem[      tag: "Files"L, place: [0, line1], string: @td.files,      inHeap: TRUE];    RETURN[items: items, freeDesc: TRUE];    };  MakeSWs: Tool.MakeSWsProc = {    logName: STRING ¬ [40];    Tool.UnusedLogName[unused: logName, root: "CombineFiles.log"L];    td.msgSW ¬ Tool.MakeMsgSW[window: window];    td.formSW ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    td.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    };  ErrorType: TYPE = ARRAY MFile.ErrorCode OF LONG STRING;  ErrorList: TYPE = LONG POINTER TO ErrorType;  eList: ErrorList ¬ NIL;    Cp: PROC[s: LONG STRING] RETURNS [ns: LONG STRING] = {    ns ¬ String.CopyToNewString[s,z]};    InitErrorCodes: PROC = {    eList ¬ z.NEW[ErrorType];    FOR i: MFile.ErrorCode IN MFile.ErrorCode DO      eList[i] ¬ SELECT i FROM        noSuchFile=> Cp["noSuchFile"L], conflictingAccess=> Cp["conflictingAccess"L], insufficientAccess=> Cp["insufficientAccess"L], directoryFull=> Cp["directoryFull"L], directoryNotEmpty=> Cp["directoryNotEmpty"L], illegalName=> Cp["illegalName"L], noSuchDirectory=> Cp["noSuchDirectory"L], noRootDirectory=> Cp["noRootDirectory"L], nullAccess=> Cp["nullAccess"L], protectionFault=> Cp["protectionFault"L], directoryOnSearchPath=> Cp["directoryOnSearchPath"L], illegalSearchPath=> Cp["illegalSearchPath"L], volumeNotOpen=> Cp["volumeNotOpen"L], volumeReadOnly=> Cp["volumeReadOnly"L], noRoomOnVolume=> Cp["noRoomOnVolume"L], noSuchVolume=> Cp["noSuchVolume"L], crossingVolumes=> Cp["crossingVolumes"L], fileAlreadyExists=> Cp["fileAlreadyExists"L], fileIsRemote=> Cp["fileIsRemote"L], fileIsDirectory=> Cp["fileIsDirectory"L], invalidHandle=> Cp["invalidHandle"L], courierError=> Cp["courierError"L], addressTranslationError=> Cp["addressTranslationError"L], connectionSuspended=> Cp["connectionSuspended"L], other=> Cp["other"L],	ENDCASE => NIL;      ENDLOOP;    };      FreeErrorCodes: PROC = {    FOR i: MFile.ErrorCode IN MFile.ErrorCode DO      IF eList[i] # NIL THEN z.FREE[@eList[i]] ENDLOOP;    z.FREE[@eList];    };      Init: PROCEDURE =    BEGIN    tool ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default,      clientTransition: Transition, name: "CombineFiles"L,      cmSection: "CombineFiles"L];    END;  Init[];  }.
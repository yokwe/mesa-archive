-- NSTerminalInit.mesa-- BGY     	23-Sep-85 17:57:50DIRECTORY  Auth,  CH,  CHEntries,  CHPIDs,  CmFile,  Courier,  Emulator,  ErrMsg,  Format,  FormSW,  Heap,  Menu,  MFile,  MSegment,  MStream,  NSAddr,  NSName,  NSString,  NSTerminalOps,  Profile,  RS232CEnvironment,   Stream,  String,  System,  Token,   ToolWindow,  UserInput,  Window;NSTerminalInit: MONITOR  IMPORTS     CH, CHEntries, CmFile, Courier, ErrMsg, Emulator, FormSW, Heap,     Menu, MFile, MSegment, MStream, NSAddr, NSString, NSTerminalOps, Profile,     Stream, String, Token, ToolWindow, UserInput   EXPORTS NSTerminalOps = {  OPEN ErrMsg, NSTerminalOps;  zone: UNCOUNTED ZONE = Heap.systemZone;    InitPortList:  PUBLIC PROC[Out: Format.StringProc] = {    p: Pointer ¬ NIL;    i: CARDINAL ¬ 0;    IF menu # NIL THEN RETURN;    IF ~ReadCache[Out] THEN Umbrella[DoEnumerate, Out];    strings ¬ zone.NEW[StringSequence[count]];    ports ¬ zone.NEW[PortSequence[count]];    p ¬ head;    FOR i DECREASING IN [0..count) DO      ports[i] ¬ p;      strings[i] ¬ ports[i].name;      p ¬ p.next;      ENDLOOP;    menu ¬ Menu.Make[      "RS232C Ports"L, DESCRIPTOR[strings­], MenuMCR, FALSE, TRUE];    };  ChangeName: PUBLIC PROC[data: DataHandle] = {    s: LONG STRING ¬ [80];    s.length ¬ 0;    String.AppendString[s, "NSTerminal: "L];    String.AppendString[s, SELECT data.realterminal FROM      addrinfo => "addrinfo"L,      adm3 => "adm3"L,      adm3a => "adm3a"L,      cdc456 => "cdc456"L,      dm1520 => "dm1520"L,      gt100 => "gt100"L,      h1000 => "h1000"L,      h1420 => "h1420"L,      h1500 => "h1500"L,      h1510 => "h1510"L,      h1520 => "h1520"L,      h2000 => "h2000"L,      isc8001 => "isc8001"L,      soroc => "soroc"L,      teletec => "teletec"L,      trs80 => "trs80"L,      vc303 => "vc303"L,      vt100 => "vt100"L,      vt50 => "vt50"L,      vt50h => "vt50h"L,      vt52 => "vt52"L,      x820 => "x820"L,      xvt52 => "xvt52"L,      other => IF data.state = NIL THEN "bad data file"L ELSE data.realdataFile,      ENDCASE => "???"L];    ToolWindow.SetName[ToolWindow.WindowForSubwindow[data.formSW], s];    };    ReadCache: PROC[Out: Format.StringProc] RETURNS[ok: BOOLEAN ¬ FALSE]= {    bryan: MStream.Handle ¬ NIL;    host: LONG STRING ¬ [80];    p, next: Pointer ¬ NIL;    BEGIN    count ¬ 0;    Out["Looking for NSTerminal.cache ... "L];    bryan ¬ MStream.ReadOnly["<>NSTerminal.cache"L, []!MStream.Error => CONTINUE];    IF bryan = NIL THEN {      Out["not found.\n"L];      RETURN[FALSE]};    Out["found.\n"L];    DO ENABLE Stream.EndOfStream => EXIT;      GetString[bryan, host! String.StringBoundsFault => CONTINUE];      p ¬ GetElement[bryan! Stream.EndOfStream => {        FOR p ¬ head, next UNTIL p = NIL DO	  next ¬ p.next; zone.FREE[@p.name]; zone.FREE[@p]; ENDLOOP;	head ¬ NIL;	GOTO badFile}];      p.name ¬ String.CopyToNewString[host, zone];      p.next ¬ head;      head ¬ p;      count ¬ count + 1;      ENDLOOP;    ok ¬ TRUE;    EXITS badFile => NULL;    END;    bryan.Delete[];    };    GetString: PROC[stream: Stream.Handle, s: LONG STRING] = {    ch: CHARACTER;    s.length ¬ 0;    WHILE (ch ¬ stream.GetChar[]) # '\n DO String.AppendChar[s, ch] ENDLOOP;    };    GetElement: PROC[stream: Stream.Handle] RETURNS [p: Pointer ¬ NIL] = {    p ¬ zone.NEW[Element];    [] ¬ stream.GetBlock[[LOOPHOLE[p], 0, SIZE[Element] * 2]];    };    ProcType: TYPE = PROC[    id: Auth.IdentityHandle, con: CH.ConversationHandle,     enum: LONG POINTER TO NSName.NameRecord,    Out: Format.StringProc];    Quit: SIGNAL = CODE;  nullCH: CH.ConversationHandle = [NIL, NIL];      strings: Strings ¬ NIL;  ports: Ports ¬ NIL;  count: CARDINAL ¬ 0;  menu: Menu.Handle ¬ NIL;    Umbrella: PROC[proc: ProcType, Out: Format.StringProc] = {    ident: Auth.IdentityHandle ¬ NIL;    con: CH.ConversationHandle ¬ nullCH;    prob: Auth.CallProblem;    org, dom: LONG STRING ¬ NIL;    ok: BOOLEAN ¬ TRUE;    enumRec: NSName.NameRecord;    Get: PROC[id: Auth.IdentityHandle] = {ident ¬ id};    GetOrg: PROC[organization: LONG STRING] = {org ¬ organization};    GetDom: PROC[domain: LONG STRING] = {dom ¬ domain};    BEGIN    Profile.GetID[strong, Get];    Profile.GetDefaultOrganization[GetOrg];    Profile.GetDefaultDomain[GetDom];    Out["Creating NSTerminal.cache\n"L];    Out["Making conversation handle ... "L];    [con, ok, prob] ¬ CH.MakeConversationHandle[ident, zone];    IF ~ok THEN GOTO callProb;    Out["ok\n"L];    enumRec ¬ [      org: NSString.StringFromMesaString[org],      domain: NSString.StringFromMesaString[dom],      local: NSString.StringFromMesaString["*"L]];    Out["Enumerating "L]; Out[dom]; Out[":"L]; Out[org]; Out["\n"L];    proc[ident, con, @enumRec, Out];    EXITS callProb => {        Out["Can't make conversation with CH: "L];        CallProblem[Out, prob];        Out["\n"L];        };    END;    ErrMsg.Done[];    Out["Done\n"L];    IF con # nullCH THEN {CH.FreeConversationHandle[@con, zone]; con ¬ nullCH};    };  LookupAddress: PROCEDURE [    con: CH.ConversationHandle, name: CH.Name, buffer: CH.Buffer]    RETURNS [rc: CH.ReturnCode,       address: System.NetworkAddress ¬ System.nullNetworkAddress,      succeeded: BOOLEAN ¬ FALSE] = {    addressList: CHEntries.AddressList;    rc ¬ CH.LookupValueProperty[      con, name, CHPIDs.nsAddress, buffer, NIL];    IF rc.code # done THEN RETURN;    succeeded ¬ CH.DeserializeFromRhs[      [@addressList, CHEntries.DescribeAddressList], zone, buffer];    IF NOT succeeded THEN RETURN;    address ¬ NSAddr.SelectNearestAddress[addressList];    Courier.Free[[@addressList, CHEntries.DescribeAddressList], zone];    };  head: Pointer ¬ NIL;  DoEnumerate: ProcType = {    pid: CH.PropertyID ¬ CHPIDs.rs232CPort;    rc: CH.ReturnCode;    rs232info: CHEntries.RS232CData;    local: LONG STRING ¬ [50];    addr: System.NetworkAddress;    buffer: CH.Buffer ¬ CH.MakeRhs[CH.maxBufferSize, zone];    MakeMenu: CH.NameStreamProc = {      ret: CH.ReturnCode;      ok: BOOLEAN ¬ FALSE;      local.length ¬ 0;      BEGIN      NSString.AppendToMesaString[local, currentName.local];      Out[local]; Out[" ... "L];      ret ¬ CH.LookupValueProperty[        con, currentName, CHPIDs.rs232CData, buffer, NIL];      IF ret.code # done THEN GOTO noProp;      ok ¬ CH.DeserializeFromRhs[	[@rs232info, CHEntries.DescribeRS232CData], zone, buffer];      IF ~ok THEN GOTO cant;      [ret, addr, ok] ¬ LookupAddress[con, currentName, buffer];      IF ~ok THEN GOTO noAddr;      head ¬ zone.NEW[Element ¬ [        next: head, name: zone.NEW[StringBody[80]], 	lineNumber: rs232info.dialerNumber, addr: addr,	charLength: rs232info.charLength,	parity: rs232info.parity,	stopBits: rs232info.stopBits,	flowControl: rs232info.flowControl,	duplexity: rs232info.duplexity,	lineSpeed: rs232info.lineSpeed	]];      NSString.AppendToMesaString[head.name, currentName.local];      Out["ok\n"L];      count ¬ count + 1;      EXITS         noProp => {Out["no rs232 property: "L]; 	  ReturnCode[Out, ret]; Out["\n"L]};        noAddr => {Out["no noAddr property: "L]; 	  ReturnCode[Out, ret]; Out["\n"L]};        cant => Out["cant deserialize\n"L];       END;      };    BEGIN    rc ¬ CH.Enumerate[con, enum, pid, MakeMenu!      Quit => GOTO quit];    IF rc.code # done THEN {      Out["Enumerate error :"L];      ReturnCode[Out, rc];      Out["\n"L];      };    EXITS quit => Out["aborted\n"L];    END;    CH.FreeRhs[buffer, zone];    WriteCache[];    };    WriteCache: PROC = {    bryan: MStream.Handle ¬ NIL;    bryan ¬ MStream.WriteOnly["<>NSTerminal.cache"L, [], binary!      MStream.Error => GOTO quit];    PutList[bryan, head];    bryan.Delete[];    EXITS quit => NULL;    };    PutList: PROC[stream: Stream.Handle, p: Pointer] = {    IF p = NIL THEN RETURN;    PutList[stream, p.next];    stream.PutString[p.name];    stream.PutString["\n"L];    stream.PutBlock[[LOOPHOLE[p], 0, SIZE[Element] * 2]];    };    AddMenu: PUBLIC PROC[sw: Window.Handle] = {    IF menu # NIL THEN menu.Instantiate[sw];    };    RemoveMenu: PUBLIC PROC[sw: Window.Handle] = {    IF menu # NIL THEN menu.Uninstantiate[sw];    };    MenuMCR: Menu.MCRType = {    data: DataHandle ¬ FindContext[window];    Stuff: Format.StringProc = {[] ¬ UserInput.StuffString[data.ttySW, s]};    IF data = NIL THEN RETURN;    IF ~(index IN [0..count)) THEN RETURN;    data.charLength ¬ ports[index].charLength;    data.parity ¬ ports[index].parity;    data.stopBits ¬ ports[index].stopBits;    data.flowControl ¬ ports[index].flowControl;    data.duplexity ¬ ports[index].duplexity;    data.lineSpeed ¬ ports[index].lineSpeed;    data.lineNumber ¬ ports[index].lineNumber;    String.Replace[@data.host, ports[index].name, zone];    FormSW.Display[data.optformSW];    };        defaultphoneNumber: LONG STRING ¬ NIL;  defaultduplexity: RS232CEnvironment.Duplexity ¬ full;  defaultcharLength: RS232CEnvironment.CharLength ¬ 7;  defaultparity: RS232CEnvironment.Parity ¬ even;  defaultstopBits: RS232CEnvironment.StopBits ¬ 1;  defaultlineSpeed: RS232CEnvironment.LineSpeed ¬ bps1200;  defaultflowControl: RS232CEnvironment.FlowControl ¬ [none, 0, 0];  defaultlineNumber: CARDINAL ¬ 0;  defaultterminal: Emulator.TerminalType ¬ adm3a;  defaultrefresh: Emulator.RefreshHint  ¬ always;  defaulthost: LONG STRING ¬ NIL;  defaultdataFile: LONG STRING ¬ NIL;  defaultfilter: BOOLEAN ¬ TRUE;  defaultlogIn: BOOLEAN ¬ FALSE;  defaultauthenticate: BOOLEAN ¬ FALSE;  ProcessCm: PROCEDURE = {    h: CmFile.Handle = CmFile.UserDotCmOpen[! CmFile.Error => RESUME];    s: LONG STRING ¬ NIL;    state: Token.StandardFilterState;    IF h = NIL THEN RETURN;    BEGIN    Options: TYPE = {      filter, lineNo, phone, host,       refresh, terminal, charlength,      stopbits, linespeed, parity,      duplexity, flowcontrol, xon, xoff, login, authenticate, dataFile,      box, initial, tiny};    a: ARRAY Options OF LONG STRING ¬      [filter: "Filter"L,      lineNo: "LineNo"L,      phone: "PhoneNumber"L,      host: "Host"L,      refresh:"Refresh"L,      terminal:"Terminal"L,      charlength: "CharLength"L,      stopbits: "StopBits"L,      linespeed:"LineSpeed"L,      parity:"Parity"L,      duplexity: "Duplexity"L,      flowcontrol:"FlowControl"L,      xon:"XOn"L,      xoff: "XOff"L,      login:"LogIn"L,      authenticate: "Authenticate"L,      dataFile: "DataFile"L,      box:"WindowBox"L,      initial:"InitialState"L,      tiny:"TinyPlace"L];    IF ~CmFile.FindSection[h, "NSTerminal"L !      CmFile.Error => GOTO exit] THEN GOTO exit;    DO      SELECT CmFile.NextValue[h, LOOPHOLE[LONG[DESCRIPTOR[a]]] !        CmFile.TableError => RESUME] FROM        Options.box.ORD => NULL;        Options.initial.ORD => NULL;        Options.tiny.ORD => NULL;	Options.filter.ORD => defaultfilter ¬ Token.Boolean[h, FALSE];	Options.login.ORD => defaultlogIn ¬ Token.Boolean[h, FALSE];	Options.authenticate.ORD => defaultauthenticate ¬ Token.Boolean[h, FALSE];	Options.lineNo.ORD => defaultlineNumber ¬ Token.Number[h, 10, FALSE];	Options.phone.ORD => defaultphoneNumber ¬ Token.Item[h, FALSE];	Options.host.ORD => defaulthost ¬ Token.MaybeQuoted[	  h: h, data: @state, temporary: FALSE];	Options.dataFile.ORD => defaultdataFile ¬ Token.MaybeQuoted[	  h: h, data: @state, temporary: FALSE];	Options.refresh.ORD => {	  s ¬ Token.Item[h, FALSE]; IF s = NIL THEN LOOP;	  defaultrefresh ¬ GetRefresh[s];	  s ¬ Token.FreeTokenString[s]};	Options.terminal.ORD => {	  s ¬ Token.Item[h, FALSE]; IF s = NIL THEN LOOP;	  defaultterminal ¬ GetTerminal[s];	  s ¬ Token.FreeTokenString[s]};	Options.charlength.ORD => {	  s ¬ Token.Item[h, FALSE]; IF s = NIL THEN LOOP;	  defaultcharLength ¬ GetCharLength[s];	  s ¬ Token.FreeTokenString[s]};	Options.stopbits.ORD => {	  s ¬ Token.Item[h, FALSE]; IF s = NIL THEN LOOP;	  defaultstopBits ¬ GetStopBits[s];	  s ¬ Token.FreeTokenString[s]};	Options.linespeed.ORD => {	  s ¬ Token.Item[h, FALSE]; IF s = NIL THEN LOOP;	  defaultlineSpeed ¬ GetLineSpeed[s];	  s ¬ Token.FreeTokenString[s]};	Options.parity.ORD => {	  s ¬ Token.Item[h, FALSE]; IF s = NIL THEN LOOP;	  defaultparity ¬ GetParity[s];	  s ¬ Token.FreeTokenString[s]};	Options.duplexity.ORD => {	  s ¬ Token.Item[h, FALSE]; IF s = NIL THEN LOOP;	  defaultduplexity ¬ GetDuplexity[s];	  s ¬ Token.FreeTokenString[s]};	Options.flowcontrol.ORD => {	  s ¬ Token.Item[h, FALSE]; IF s = NIL THEN LOOP;	  defaultflowControl.type ¬ GetFlowControl[s];	  s ¬ Token.FreeTokenString[s]};	Options.xon.ORD => defaultflowControl.xOn ¬ Token.Number[h, 8, FALSE];	Options.xoff.ORD => defaultflowControl.xOff ¬ Token.Number[h, 8, FALSE];        ENDCASE => EXIT;      ENDLOOP;    [] ¬ CmFile.Close[h];    EXITS      exit => [] ¬ CmFile.Close[h];    END};      GetRefresh: PROC[s: LONG STRING] RETURNS [p: Emulator.RefreshHint] = {    p ¬ SELECT TRUE FROM      String.Equivalent["always"L, s] => always,      String.Equivalent["never"L, s] => never,      String.Equivalent["half"L, s] => half,      String.Equivalent["full"L, s] => full,      ENDCASE => always;    };      GetTerminal: PROC[s: LONG STRING] RETURNS [p: Emulator.TerminalType] = {    p ¬ SELECT TRUE FROM      String.Equivalent["addrinfo"L, s] => addrinfo,      String.Equivalent["adm3"L, s] => adm3,      String.Equivalent["adm3a"L, s] => adm3a,      String.Equivalent["cdc456"L, s] => cdc456,      String.Equivalent["dm1520"L, s] => dm1520,      String.Equivalent["gt100"L, s] => gt100,      String.Equivalent["h1000"L, s] => h1000,      String.Equivalent["h1420"L, s] => h1420,      String.Equivalent["h1500"L, s] => h1500,      String.Equivalent["h1510"L, s] => h1510,      String.Equivalent["h1520"L, s] => h1520,      String.Equivalent["h2000"L, s] => h2000,      String.Equivalent["isc8001"L, s] => isc8001,      String.Equivalent["soroc"L, s] => soroc,      String.Equivalent["teletec"L, s] => teletec,      String.Equivalent["trs80"L, s] => trs80,      String.Equivalent["vc303"L, s] => vc303,      String.Equivalent["vt100"L, s] => vt100,      String.Equivalent["vt50"L, s] => vt50,      String.Equivalent["vt50h"L, s] => vt50h,      String.Equivalent["vt52"L, s] => vt52,      String.Equivalent["x820"L, s] => x820,      String.Equivalent["xvt52"L, s] => xvt52,      String.Equivalent["other"L, s] => other,      ENDCASE => adm3a;    };      GetCharLength: PROC[s: LONG STRING]     RETURNS [p: RS232CEnvironment.CharLength] = {    p ¬ SELECT TRUE FROM      String.Equivalent["5"L, s] => 5,      String.Equivalent["6"L, s] => 6,      String.Equivalent["7"L, s] => 7,      String.Equivalent["8"L, s] => 8,      ENDCASE => 7;    };      GetStopBits: PROC[s: LONG STRING]     RETURNS [p: RS232CEnvironment.StopBits] = {    p ¬ SELECT TRUE FROM      String.Equivalent["1"L, s] => 1,      String.Equivalent["2"L, s] => 2,      ENDCASE => 1;    };      GetLineSpeed: PROC[s: LONG STRING]     RETURNS [p: RS232CEnvironment.LineSpeed] = {    p ¬ SELECT TRUE FROM      String.Equivalent["bps50"L, s] => bps50,      String.Equivalent["bps75"L, s] => bps75,      String.Equivalent["bps110"L, s] => bps110,      String.Equivalent["bps134p5"L, s] => bps134p5,      String.Equivalent["bps150"L, s] => bps150,      String.Equivalent["bps300"L, s] => bps300,      String.Equivalent["bps600"L, s] => bps600,      String.Equivalent["bps1200"L, s] => bps1200,      String.Equivalent["bps2400"L, s] => bps2400,      String.Equivalent["bps3600"L, s] => bps3600,      String.Equivalent["bps4800"L, s] => bps4800,      String.Equivalent["bps7200"L, s] => bps7200,      String.Equivalent["bps9600"L, s] => bps9600,      String.Equivalent["bps19200"L, s] => bps19200,      String.Equivalent["bps28800"L, s] => bps28800,      String.Equivalent["bps38400"L, s] => bps38400,      String.Equivalent["bps48000"L, s] => bps48000,      String.Equivalent["bps56000"L, s] => bps56000,      String.Equivalent["bps57600"L, s] => bps57600,      ENDCASE => bps1200;    };      GetParity: PROC[s: LONG STRING]     RETURNS [p: RS232CEnvironment.Parity] = {    p ¬ SELECT TRUE FROM      String.Equivalent["none"L, s] => none,      String.Equivalent["odd"L, s] => odd,      String.Equivalent["even"L, s] => even,      String.Equivalent["one"L, s] => one,      String.Equivalent["zero"L, s] => zero,      ENDCASE => even;    };      GetDuplexity: PROC[s: LONG STRING]     RETURNS [p: RS232CEnvironment.Duplexity] = {    p ¬ SELECT TRUE FROM      String.Equivalent["full"L, s] => full,      String.Equivalent["half"L, s] => half,      ENDCASE => full;    };      GetFlowControl: PROC[s: LONG STRING]     RETURNS [p: UNSPECIFIED] = {    p ¬ SELECT TRUE FROM      String.Equivalent["none"L, s] => 0,      String.Equivalent["xOnXOff"L, s] => 1,      ENDCASE => 0;    };      InitUser: PUBLIC PROC = {ProcessCm[]};    GetStateTable: PUBLIC PROC[data: DataHandle] = {    mfile: MFile.Handle ¬ NIL;    count: MFile.ByteCount ¬ 0;    IF data.state # NIL AND String.Equivalent[data.realdataFile, data.dataFile]      THEN RETURN;    IF data.terminal # other THEN RETURN;    String.Replace[@data.realdataFile, data.dataFile, zone];    [] ¬ Emulator.SetEmulator[data.ttySW,Emulator.table[adm3a], NIL];    IF data.state # NIL THEN {      data.segment.Delete[];      data.state ¬ NIL;      data.segment ¬ NIL;      };    mfile ¬ MFile.Acquire[data.realdataFile, readOnly, []!      MFile.Error => GOTO nope];    count ¬ mfile.GetLength[];    data.segment ¬ MSegment.Create[mfile, [], 0, (count + 511)/512!      MSegment.Error => GOTO nope];    data.state ¬ data.segment.Address[!MSegment.Error => GOTO nope];    EXITS nope => data.state ¬ NIL;    };    InitContext: PUBLIC PROC[data: DataHandle] = {      String.Replace[@data.realphoneNumber, defaultphoneNumber, zone];      String.Replace[@data.realhost, defaulthost, zone];      String.Replace[@data.dataFile, defaultdataFile, zone];      String.Replace[@data.realdataFile, ""L, zone];      data.realduplexity ¬ defaultduplexity;      data.realcharLength ¬ defaultcharLength;      data.realparity ¬ defaultparity;      data.realstopBits ¬ defaultstopBits;      data.reallineSpeed ¬ defaultlineSpeed;      data.realflowControl ¬ defaultflowControl;      data.reallineNumber ¬ defaultlineNumber;      data.realterminal ¬ defaultterminal;      data.realrefresh ¬ defaultrefresh;      data.realfilter ¬ defaultfilter;      data.reallogIn ¬ defaultlogIn;      data.realauthenticate ¬ defaultauthenticate;      IF String.Length[data.dataFile] > 0 THEN GetStateTable[data];    };      Go: PUBLIC ENTRY PROC[data: DataHandle] RETURNS [yes: BOOLEAN] = {    ENABLE UNWIND => NULL;    IF data.busy THEN RETURN[FALSE]    ELSE RETURN[data.busy ¬ TRUE];    };    Done: PUBLIC ENTRY PROC[data: DataHandle] = {    ENABLE UNWIND => NULL;    data.busy ¬ FALSE;    };    }.      
-- NSTerminalImpl.mesa-- Create by FormSWLayoutTool on 25-Jul-84 13:36-- BGY     	23-Sep-85 17:57:36-- BJD    	 4-Oct-84 11:16:25-- Copyright (C) 1984 by Xerox Corporation. All rights reserved.DIRECTORY  AddressTranslation,  Ascii,  Auth,  CH,  Context,  Cursor,  Emulator,  EmulatorOps,  Environment,  ErrMsg,  Exec,  Format,  FormSW,  GateStream,  Heap,  Inline,  Process,  Put,  Queue,  MSegment,  NetworkStream,  NSString,  NSName,  NSTerminalOps,  Profile,  Selection,  Stream,  String,  System,  Tool,  ToolWindow,  UserInput,  UserTerminal,  Window;NSTerminalImpl: MONITOR  IMPORTS    Auth, AddressTranslation, CH, Context, Cursor,    Emulator, EmulatorOps, ErrMsg, Exec, FormSW,     GateStream, Heap, Inline, MSegment, NSName, NSString,     NSTerminalOps, Process, Profile, Put,     Queue, Selection, Stream, String,      Tool, ToolWindow, UserInput, UserTerminal,    Window   EXPORTS NSTerminalOps = {  OPEN NSTerminalOps;    zone: UNCOUNTED ZONE ¬ Heap.systemZone;  waiter: CONDITION;  context: Context.Type ¬ Context.UniqueType[];  defaultLogin: BOOLEAN ¬ TRUE;  Write: PUBLIC PROC[data: DataHandle, s: LONG STRING] ={    Emulator.PutString[data.ttySW, s]};  Writeln: PUBLIC PROC[data: DataHandle, s: LONG STRING] ={    Emulator.PutString[data.ttySW, s];    CR[data];    };  Msg: PUBLIC PROC[data: DataHandle, s: LONG STRING] = {Put.Text[data.msgSW, s]};    CR: PROC[data: DataHandle] = {    c: EmulatorOps.EContext ¬ EmulatorOps.FindContext[data.ttySW];    EmulatorOps.InternalLineFeed[c, TRUE];    EmulatorOps.ReleaseContext[data.ttySW];    };    StartChat: PROC[data: DataHandle, host: GetHost] = {    identity: Auth.IdentityHandle ¬ NIL;    auth: Auth.ConversationHandle ¬ NIL;    LocalMsg: Format.StringProc = {Msg[data, s]};    disting: NSName.Name ¬ NIL;    s: LONG STRING ¬ NIL;    GetID: PROCEDURE [id: Auth.IdentityHandle] = {identity ¬ id};    BEGIN    IF host = useSelect AND String.Length[data.realhost] = 0 THEN {      s ¬ Selection.Convert[string];      IF s = NIL THEN {Flash[]; Writeln[data, "No host selected"L]; GOTO quit};      String.Replace[@data.realhost, s, zone];      Heap.systemZone.FREE[@s]};    Profile.GetID[strong, GetID];    Msg[data, data.realhost]; Msg[data, "..."L];    data.service ¬ AddressTranslation.StringToNetworkAddress[      data.realhost, identity, NIL!      AddressTranslation.Error => {        AddressTranslation.PrintError[error: errorRecord, proc: LocalMsg];	LocalMsg["\n"L]; GOTO quit}].addr;    IF data.realauthenticate THEN {      IF ~MakeConversation[LocalMsg] THEN GOTO quit;      disting ¬ GetDisting[data.realhost];      };    data.commParams ¬ [      duplex: data.realduplexity, lineType: asynchronous,       lineSpeed: data.reallineSpeed,      accessDetail: dialConn[        dialMode: auto, dialerNumber: data.reallineNumber, retryCount: 5]];    IF String.Length[data.realphoneNumber] = 0 THEN      data.commParams.accessDetail ¬ directConn[];    data.transport[0] ¬ [      rs232c[      commParams: @data.commParams, preemptOthers: preemptInactive,      preemptMe: preemptInactive, phoneNumber: data.realphoneNumber,      line: [reserveNeeded[lineNumber: data.reallineNumber]]]];    data.transport[1] ¬ [teletype[]];    data.session ¬ [      ttyHost [charLength: data.realcharLength, parity: data.realparity,       stopBits: data.realstopBits, frameTimeout: 100,       flowControl: data.realflowControl]];    IF data.realauthenticate THEN       auth ¬ Auth.Initiate[identity, disting,	data.service.host, zone !	Auth.CallError => CONTINUE];    data.stream ¬ GateStream.Create[      service: data.service, sessionParameterHandle: LOOPHOLE[@data.session],       transportList: DESCRIPTOR[data.transport],      conversation: IF data.realauthenticate THEN auth ELSE NIL!        GateStream.Error => {data.GateError[reason ]; GOTO quit}];    data.stream.SetInputOptions[      [terminateOnEndRecord: TRUE, signalEndOfStream: TRUE]];    data.watcherProcess ¬ FORK AwaitControl[data];    data.putDataProcess ¬ FORK PutChars[data];    data.getDataProcess ¬ FORK GetChars[data];    Msg[data, "opened"L];    IF data.reallogIn THEN Login[data];    EXITS quit => Done[data];    END;    IF auth # NIL THEN Auth.Terminate[@auth, zone];    IF disting # NIL THEN NSName.FreeName[zone, disting];    };    Login: PROC[data: DataHandle] = {    ok: BOOLEAN ¬ FALSE;    Test: PROC[name: LONG STRING, password: LONG STRING] = {      ok ¬ String.Length[password] > 0};    StuffUser: PROC[name: LONG STRING, password: LONG STRING] = {      [] ¬ UserInput.StuffString[data.ttySW, name];      [] ¬ UserInput.StuffString[data.ttySW, "\n"L];      [] ¬ UserInput.StuffString[data.ttySW, password];      [] ¬ UserInput.StuffString[data.ttySW, "\n"L];      };    Profile.GetUser[Test];    IF ~ok THEN RETURN;    [] ¬ UserInput.StuffString[data.ttySW, "Log\n"L];    Profile.GetUser[StuffUser, clearinghouse];    };    FindContext: PUBLIC PROC[sw: Window.Handle]     RETURNS [data: DataHandle] = {    RETURN[Context.Find[      context, ToolWindow.WindowForSubwindow[sw]]]};    GetHost: TYPE = {useSelect, dont};  Connect:  FormSW.ProcType = {DoConnect[sw, useSelect]};  DoConnect:  PROC[sw: Window.Handle, host: GetHost] = {    data: DataHandle ¬ FindContext[sw];    IF data = NIL THEN RETURN;    IF data.stream # NIL THEN {      Msg[data, "Connection already opened.\n"L];      Flash[];      RETURN};    IF ~Go[data] THEN {      Msg[data, "NSTerminal is busy.\n"L];      Flash[];      RETURN};    Process.Detach[data.connectorProcess ¬ FORK ForkedConnect[data, host]];    };      ForkedConnect: PROC[data: DataHandle, host: GetHost] = {    BEGIN ENABLE ABORTED => GOTO quit;    IF data.localMode # NIL THEN Process.Abort[data.localMode];    WHILE data.localMode # NIL DO Pause[]  ENDLOOP;    Msg[data, "Opening connection to "L];    StartChat[data, host];    Msg[data, "\n"L];    -- check to see if connection was successful.    IF data.putDataProcess = NIL AND data.localMode = NIL THEN LocalMode[data]    ELSE Emulator.SetRemote[data.ttySW, TRUE];    EXITS quit => Done[data];    END;    data.connectorProcess ¬ NIL;    };  Disconnect:  FormSW.ProcType = {    data: DataHandle ¬ FindContext[sw];    IF data = NIL THEN RETURN;    IF data.stream = NIL THEN {      Msg[data, "No connection opened.\n"L];      Flash[];      RETURN};    Process.Detach[FORK ForkedDisconnect[data]];    };  ForkedDisconnect: PROC[data: DataHandle] = {    Msg[data, "Closing connection to "L];    Msg[data, data.realhost];    CloseConnection[data];    Msg[data, " ... done\n"L];    };    CloseConnection:  ENTRY PROC[data: DataHandle] = {    ENABLE UNWIND => NULL;    IF data.stream = NIL THEN RETURN;    Cleanup[data];    Emulator.SetRemote[data.ttySW, FALSE];    IF ~data.aborted THEN LocalMode[data];    Writeln[data, " "L];    Writeln[data, "~~~~~~~~ Connection closed ~~~~~~~~"L];    Done[data];    };  Another:  FormSW.ProcType = {    data: DataHandle ¬ FindContext[sw];    IF data = NIL THEN RETURN;    [] ¬ MakeOne[];    };  MyDestroy:  ENTRY FormSW.ProcType = {    ENABLE UNWIND => NULL;    data: DataHandle ¬ FindContext[sw];    IF data = NIL THEN RETURN;    Process.Detach[FORK Destroyer[data, sw]];    };  Destroyer: ENTRY PROC[data: DataHandle, sw: Window.Handle] = {    ENABLE UNWIND => NULL;    Tool.Destroy[ToolWindow.WindowForSubwindow[sw]]};    Pause: ENTRY PROC = {ENABLE UNWIND => NULL; WAIT waiter};    BreakKey:  FormSW.ProcType = {    data: DataHandle ¬ FindContext[sw];    IF data = NIL THEN RETURN;    AbortHit[data.ttySW]};  GetData: SIGNAL RETURNS [DataHandle] = CODE;    MyOptions:  FormSW.ProcType = {    data: DataHandle ¬ FindContext[sw];    myBox: Window.Box;    IF data = NIL THEN RETURN;    IF data.optionW # NIL THEN {      Flash[];      Msg[data, "Option sheet already exits!\n"L];      RETURN};    myBox ¬ [ToolWindow.WindowForSubwindow[sw].GetBox[].place, [500, 124]];    myBox.place.x ¬ myBox.place.x + 50;    myBox.place.y ¬ myBox.place.y + 50;    data.duplexity ¬ data.realduplexity;    data.charLength ¬ data.realcharLength;    data.parity ¬ data.realparity;    data.stopBits ¬ data.realstopBits;    data.lineSpeed ¬ data.reallineSpeed;    data.flowControl ¬ data.realflowControl;    data.lineNumber ¬ data.reallineNumber;    data.terminal ¬ data.realterminal;    data.refresh ¬ data.realrefresh;    data.filter ¬ data.realfilter;    data.logIn ¬ data.reallogIn;    data.authenticate ¬ data.realauthenticate;    String.Replace[@data.phoneNumber, data.realphoneNumber, zone];    String.Replace[@data.host, data.realhost, zone];    String.Replace[@data.dataFile, data.realdataFile, zone];    data.optionW ¬ Tool.Create[      makeSWsProc: MakeOptSWs, initialState: default, initialBox: myBox,      name: "NSTerminal Options"L, cmSection: "NSTerminalOptions"L,      clientTransition: Transition!        GetData => RESUME[data]]};  Transition: ToolWindow.TransitionProcType = {    data: DataHandle ¬ Context.Find[context, window];    SELECT TRUE FROM      old = inactive => IF data = NIL THEN {        data ¬ SIGNAL GetData[];        Context.Create[context, data, NullDestroy, window]};      new = inactive => NULL;      ENDCASE;    };    MakeOptSWs: Tool.MakeSWsProc = {    data: DataHandle ¬ Context.Find[context, window];    IF data = NIL THEN RETURN;    data.optformSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeOption];    AddMenu[data.optformSW];    };  ConnectProc:  ENTRY FormSW.ProcType = {    ENABLE UNWIND => NULL;    data: DataHandle ¬ FindContext[sw];    IF data = NIL THEN RETURN;    TakeDownOptions[sw];    [] ¬ UserInput.CreatePeriodicNotify[Kamikaze, data.formSW, 0];    };  Kamikaze: UserInput.PeriodicProcType= {    old: Cursor.Object;    Cursor.Fetch[@old];    Cursor.Set[hourGlass];    DoConnect[window, dont];    Cursor.Store[@old];    };    Apply: ENTRY FormSW.ProcType = {    ENABLE UNWIND => NULL;    TakeDownOptions[sw]};    TakeDownOptions:  PROC[sw: Window.Handle] = {    data: DataHandle ¬ FindContext[sw];    IF data = NIL THEN RETURN;    data.realduplexity ¬ data.duplexity;    data.realcharLength ¬ data.charLength;    data.realparity ¬ data.parity;    data.realstopBits ¬ data.stopBits;    data.reallineSpeed ¬ data.lineSpeed;    data.realflowControl ¬ data.flowControl;    data.reallineNumber ¬ data.lineNumber;    data.reallogIn ¬ data.logIn;    data.realauthenticate ¬ data.authenticate;    GetStateTable[data];    IF data.realterminal # data.terminal OR data.realterminal = other THEN {      data.realterminal ¬ data.terminal;      BEGIN      IF data.realterminal = other THEN         [] ¬ Emulator.SetEmulator[data.ttySW, 	  IF data.state = NIL THEN Emulator.table[adm3a] ELSE data.state, NIL!	  Emulator.Error => GOTO nope]      ELSE [] ¬ Emulator.SetEmulator[        data.ttySW, Emulator.table[data.realterminal],        IF data.realterminal = vt100 THEN Emulator.table[xvt52] ELSE NIL];      EXITS nope  => {	Msg[data, "Invalid data file: "L];	Msg[data, data.realdataFile];	Msg[data, "\n"L];        data.segment.Delete[];	data.segment ¬ NIL;	data.state ¬ NIL;	[] ¬ Emulator.SetEmulator[data.ttySW,Emulator.table[adm3a], NIL];	};      END;      ChangeName[data];      };    IF data.realrefresh # data.refresh THEN {      data.realrefresh ¬ data.refresh;      Emulator.SetRefresh[data.ttySW, data.realrefresh];      };    data.realfilter ¬ data.filter;    String.Replace[@data.realphoneNumber, data.phoneNumber, zone];    String.Replace[@data.realhost, data.host, zone];    RemoveMenu[data.optformSW];    data.ttySW.InvalidateBox[[[0,0], data.ttySW.GetBox[].dims]];    Process.Detach[FORK Destroyer[data, sw]];    };  Abort:  ENTRY FormSW.ProcType = {    ENABLE UNWIND => NULL;    data: DataHandle ¬ FindContext[sw];    IF data = NIL THEN RETURN;    RemoveMenu[data.optformSW];    Process.Detach[FORK Destroyer[data, sw]];    };  OptionItems: TYPE = {connect, lineNumber, phoneNumber, apply, abort, filter, host, terminalOptions, refresh, terminal, charLength, stopBits, lineSpeed, parity, duplexity, flowControl, xOn, xOff, dataFile, logIn, authenticate};  MakeOption: FormSW.ClientItemsProcType = {    nItems: CARDINAL = OptionItems.LAST.ORD + 1;    refreshes: ARRAY[0..4) OF FormSW.Enumerated ¬ [      ["always"L, 0], ["never"L, 1],      ["half"L, 2], ["full"L, 3]];    terminals: ARRAY[0..23) OF FormSW.Enumerated ¬ [      ["addrinfo"L, 0], ["adm3"L, 1],      ["adm3a"L, 2], ["cdc456"L, 3],      ["dm1520"L, 4], ["gt100"L, 5],      ["h1000"L, 6], ["h1420"L, 7],      ["h1500"L, 8], ["h1510"L, 9],      ["h1520"L, 10], ["h2000"L, 11],      ["isc8001"L, 12], ["soroc"L, 13],      ["teletec"L, 14], ["trs80"L, 15],      ["vc303"L, 16], ["vt100"L, 17],      ["vt50"L, 18], ["vt50h"L, 19],      ["vt52"L, 20], ["x820"L, 21],      ["other"L, 23]];    charLength: ARRAY[0..4) OF FormSW.Enumerated ¬ [      ["5"L, 0], ["6"L, 1],      ["7"L, 2], ["8"L, 3]];    stopBits: ARRAY[0..2) OF FormSW.Enumerated ¬ [      ["1"L, 0], ["2"L, 1]];    lineSpeed: ARRAY[0..19) OF FormSW.Enumerated ¬ [      ["bps50"L, 0], ["bps75"L, 1],      ["bps110"L, 2], ["bps134p5"L, 3],      ["bps150"L, 4], ["bps300"L, 5],      ["bps600"L, 6], ["bps1200"L, 7],      ["bps2400"L, 8], ["bps3600"L, 9],      ["bps4800"L, 10], ["bps7200"L, 11],      ["bps9600"L, 12], ["bps19200"L, 13],      ["bps28800"L, 14], ["bps38400"L, 15],      ["bps48000"L, 16], ["bps56000"L, 17],      ["bps57600"L, 18]];    parity: ARRAY[0..5) OF FormSW.Enumerated ¬ [      ["none"L, 0], ["odd"L, 1],      ["even"L, 2], ["one"L, 3],      ["zero"L, 4]];    duplexity: ARRAY[0..2) OF FormSW.Enumerated ¬ [      ["full"L, 0], ["half"L, 1]];    flowControl: ARRAY[0..2) OF FormSW.Enumerated ¬ [      ["none"L, 0], ["xOnXOff"L, 1]];    data: DataHandle ¬ FindContext[sw];    items ¬ FormSW.AllocateItemDescriptor[nItems];    items[OptionItems.connect.ORD] ¬ FormSW.CommandItem[      tag: "Connect"L, place: [0, FormSW.line0], proc: ConnectProc];    items[OptionItems.lineNumber.ORD] ¬ FormSW.NumberItem[      tag: "LineNo"L, place: [120, FormSW.line0], signed: FALSE, default: 0, value: @data.lineNumber];    items[OptionItems.phoneNumber.ORD] ¬ FormSW.StringItem[      tag: "PhoneNumber"L, place: [246, FormSW.line0], inHeap: TRUE, string: @data.phoneNumber];    items[OptionItems.apply.ORD] ¬ FormSW.CommandItem[      tag: "Apply"L, place: [0, FormSW.line1], proc: Apply];    items[OptionItems.abort.ORD] ¬ FormSW.CommandItem[      tag: "Abort"L, place: [54, FormSW.line1], proc: Abort];    items[OptionItems.filter.ORD] ¬ FormSW.BooleanItem[      tag: "Filter"L, place: [120, FormSW.line1], switch: @data.filter];    items[OptionItems.host.ORD] ¬ FormSW.StringItem[      tag: "Host"L, place: [246, FormSW.line1], inHeap: TRUE, string: @data.host];    items[OptionItems.terminalOptions.ORD] ¬ FormSW.CommandItem[      tag: "TerminalOptions"L, place: [0, FormSW.line2], proc: TerminalOptions];    items[OptionItems.refresh.ORD] ¬ FormSW.EnumeratedItem[      tag: "Refresh"L, place: [120, FormSW.line2], proc: SetRefresh, choices: DESCRIPTOR[refreshes], value: @data.refresh];    items[OptionItems.terminal.ORD] ¬ FormSW.EnumeratedItem[      tag: "Terminal"L, place: [246, FormSW.line2], proc: ChangeTerminal, choices: DESCRIPTOR[terminals], value: @data.terminal];    items[OptionItems.charLength.ORD] ¬ FormSW.EnumeratedItem[      tag: "CharLength"L, place: [0, FormSW.line3], choices: DESCRIPTOR[charLength], value: @data.charLength];    items[OptionItems.stopBits.ORD] ¬ FormSW.EnumeratedItem[      tag: "StopBits"L, place: [120, FormSW.line3], choices: DESCRIPTOR[stopBits], value: @data.stopBits];    items[OptionItems.lineSpeed.ORD] ¬ FormSW.EnumeratedItem[      tag: "LineSpeed"L, place: [246, FormSW.line3], choices: DESCRIPTOR[lineSpeed], value: @data.lineSpeed];    items[OptionItems.parity.ORD] ¬ FormSW.EnumeratedItem[      tag: "Parity"L, place: [0, FormSW.line4], choices: DESCRIPTOR[parity], value: @data.parity];    items[OptionItems.duplexity.ORD] ¬ FormSW.EnumeratedItem[      tag: "Duplexity"L, place: [120, FormSW.line4], choices: DESCRIPTOR[duplexity], value: @data.duplexity];    items[OptionItems.flowControl.ORD] ¬ FormSW.EnumeratedItem[      tag: "FlowControl"L, place: [246, FormSW.line4], choices: DESCRIPTOR[flowControl], value: @data.flowControl];    items[OptionItems.xOn.ORD] ¬ FormSW.NumberItem[      tag: "XOn"L, place: [0, FormSW.line5], signed: FALSE, radix: octal, value: @data.flowControl.xOn];    items[OptionItems.xOff.ORD] ¬ FormSW.NumberItem[      tag: "XOff"L, place: [120, FormSW.line5], signed: FALSE, radix: octal, value: @data.flowControl.xOff];    items[OptionItems.dataFile.ORD] ¬ FormSW.StringItem[      tag: "DataFile"L, place: [246, FormSW.line5], inHeap: TRUE, string: @data.dataFile];    items[OptionItems.logIn.ORD] ¬ FormSW.BooleanItem[      tag: "LogIn"L, place: [0, FormSW.line6], switch: @data.logIn];    items[OptionItems.authenticate.ORD] ¬ FormSW.BooleanItem[      tag: "Authenticate"L, place: [120, FormSW.line6], switch: @data.authenticate];    RETURN[items: items, freeDesc: TRUE];    };  ChangeTerminal: FormSW.EnumeratedNotifyProcType = {    };      SetRefresh: FormSW.EnumeratedNotifyProcType = {    };      TerminalOptions:  FormSW.ProcType = {    data: DataHandle ¬ FindContext[sw];    Emulator.CreateOptionsSheet[data.ttySW];    };  AbortHit: UserInput.AttentionProcType = {    data: DataHandle ¬ FindContext[window];    IF data = NIL THEN RETURN;    IF data.stream = NIL THEN RETURN;    data.stream.SendAttention[GateStream.interrupt];    };    AwaitControl: PROC[data: DataHandle] =    -- Process to wait for generic controls    BEGIN    control: Stream.Byte;    -- this with return a control when attention data is implemented    -- for now, it just means interrupt (BELL)    DO ENABLE {ABORTED => EXIT; Stream.EndOfStream => GOTO remotequit};      IF data.stream = NIL THEN EXIT      ELSE control ¬ Stream.WaitForAttention[data.stream];      SELECT control FROM        GateStream.audibleSignal =>Flash[];        GateStream.interrupt => Msg[data, " Break received\n"L];        GateStream.mediumDown => GOTO remotequit;        ENDCASE;      ENDLOOP;    EXITS remotequit => DoClose[data];    END;  DoClose: PROC[data: DataHandle] = {    Msg[data, " Connection closed by remote host\n"L];    Flash[];    Process.Detach[FORK CloseConnection[data]];    };    GetChars: PROC[data: DataHandle] = {    s: LONG STRING ¬ [128];    why: Stream.CompletionCode;    bytes, i: CARDINAL;    sst: Stream.SubSequenceType;    BEGIN    DO ENABLE {      ABORTED => EXIT;      Stream.EndOfStream => {DoClose[data]; GOTO exit};      Stream.SSTChange => {IF sst # GateStream.none THEN         data.PrintSST[sst]; RESUME};      };      [bytes, why, sst] ¬ data.stream.GetBlock[        [LOOPHOLE[@s.text], 0, s.maxlength]!	  Stream.TimeOut => {bytes ¬ nextIndex; CONTINUE}];      s.length ¬ bytes;      IF why = sstChange AND sst # GateStream.none THEN data.PrintSST[sst];      IF s.length = 0 THEN LOOP;      IF data.realfilter THEN FOR i IN [0..s.length) DO        s[i] ¬ Inline.BITAND[s[i], 177B];	ENDLOOP;      Emulator.PutString[data.ttySW, s];      ENDLOOP    EXITS exit => NULL;    END;    };      PutChars: PROC[data: DataHandle] = {    s: LONG STRING ¬ NIL;    q: Queue.Handle ¬ data.q;    BEGIN    data.stream.SetSST[GateStream.none];    DO ENABLE {      ABORTED => EXIT;      Stream.EndOfStream => {DoClose[data]; GOTO exit};      Stream.SSTChange => {IF sst # GateStream.none THEN         data.PrintSST[sst]; RESUME};      };      s ¬ Queue.GetFromQueue[q];      IF s # NIL THEN data.stream.PutString[s, TRUE];      zone.FREE[@s];      ENDLOOP    EXITS exit => NULL;    END;    };    Cleanup: PROC[data: DataHandle] =    -- perform cleanup    BEGIN    IF data.watcherProcess # NIL THEN {      Process.Abort[data.watcherProcess];      JOIN data.watcherProcess;      data.watcherProcess ¬ NIL};    IF data.getDataProcess # NIL THEN {      Process.Abort[data.getDataProcess];      JOIN data.getDataProcess;      data.getDataProcess ¬ NIL};    IF data.putDataProcess # NIL THEN {      Process.Abort[data.putDataProcess];      JOIN data.putDataProcess;      data.putDataProcess ¬ NIL};    IF data.stream # NIL THEN {      data.stream.Delete[];      data.stream ¬ NIL};    END;    Echo: PROC[data: DataHandle] = {    s: LONG STRING ¬ NIL;    q: Queue.Handle ¬ data.q;    BEGIN    DO ENABLE ABORTED => EXIT;      s ¬ Queue.GetFromQueue[q];      IF s # NIL THEN         FOR i: CARDINAL IN [0..s.length) DO	  IF s[i] = '\n THEN CR[data]	  ELSE Emulator.PutChar[data.ttySW, s[i]];	  ENDLOOP;      zone.FREE[@s];      ENDLOOP;    END;    data.localMode ¬ NIL;    NotifyQuit[];    };  NotifyQuit: ENTRY PROC = {    ENABLE UNWIND => NULL;    BROADCAST waiter};      ClientTransition: ToolWindow.TransitionProcType = {    data: DataHandle ¬ Context.Find[context, window];    SELECT TRUE FROM      old = inactive => {        IF data = NIL THEN {	  data ¬ zone.NEW[Data ¬ []];	  data.q ¬ Queue.Create[];	  InitContext[data];	  Context.Create[context, data, DestroyContext, window];	  };	data.aborted ¬ FALSE;	};      new = inactive => IF data # NIL THEN {         data.aborted ¬ TRUE;	IF data.connectorProcess # NIL THEN Process.Abort[data.connectorProcess];	WHILE data.connectorProcess # NIL DO 	  Process.Pause[Process.MsecToTicks[10]];	  ENDLOOP;	IF data.localMode # NIL THEN Process.Abort[data.localMode];	WHILE data.localMode # NIL DO 	  Process.Pause[Process.MsecToTicks[10]];	  ENDLOOP;        IF data.stream # NIL THEN Cleanup[data];	IF data.optionW # NIL THEN Tool.Destroy[data.optionW];	};      ENDCASE;    };  NullDestroy: PROC[data: DataHandle, window: Window.Handle] = {    data.optionW ¬ NIL;    data.optformSW ¬ NIL};      DestroyContext: PROC[data: DataHandle, window: Window.Handle] = {    IF data.stream # NIL THEN {Disconnect[data.formSW]};    Queue.Destroy[data.q];    zone.FREE[@data];    };    MakeOne: PROC RETURNS [window: Window.Handle] = {    data: DataHandle ¬ NIL;    window ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default,       initialBox: [[0, 30], [512, 440]],      clientTransition: ClientTransition, name: "NSTerminal"L,      cmSection: "NSTerminal"L];    data ¬ Context.Find[context, window];    ChangeName[data];    };  LocalMode: PROC[data: DataHandle] = {    IF data.localMode # NIL THEN RETURN;    Process.Detach[data.localMode ¬ FORK Echo[data]];    };    CreateSW: PROC[sw: Window.Handle, clientData: LONG POINTER] = {    logName: LONG STRING ¬ "NSTerminal.log"L;    data: DataHandle ¬ clientData;    Emulator.Create[      sw: sw, data: Emulator.table[data.realterminal], typeIn: GetTypeIn,      logfile: logName, writeToLog: TRUE, remote: TRUE,      otherData: IF data.realterminal = vt100 THEN         Emulator.table[xvt52] ELSE NIL,      refresh: never];    Emulator.SetRefresh[sw, data.realrefresh];    };      GetTypeIn: UserInput.StringProcType  = {    data: DataHandle ¬ FindContext[window];    IF data = NIL THEN RETURN;    Queue.PutToQueue[data.q, String.CopyToNewString[string, zone]];    };  MakeSWs: Tool.MakeSWsProc = {    data: DataHandle ¬ Context.Find[context, window];    data.msgSW ¬ Tool.MakeMsgSW[window: window];    data.formSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeForm];    data.ttySW ¬ Tool.MakeClientSW[window, CreateSW, data, Emulator.EmuSWType];    UserInput.SetAttention[data.ttySW, AbortHit];    LocalMode[data];    };  MakeForm: FormSW.ClientItemsProcType = {    nItems: CARDINAL = FormItems.LAST.ORD + 1;    data: DataHandle ¬ FindContext[sw];    items ¬ FormSW.AllocateItemDescriptor[nItems];    items[FormItems.connect.ORD] ¬ FormSW.CommandItem[      tag: "Connect"L, place: [0, FormSW.line0], proc: Connect];    items[FormItems.disconnect.ORD] ¬ FormSW.CommandItem[      tag: "Disconnect"L, place: [72, FormSW.line0], proc: Disconnect];    items[FormItems.breakKey.ORD] ¬ FormSW.CommandItem[      tag: "BreakKey"L, place: [162, FormSW.line0], proc: BreakKey];    items[FormItems.another.ORD] ¬ FormSW.CommandItem[      tag: "Another"L, place: [240, FormSW.line0], proc: Another];    items[FormItems.destroy.ORD] ¬ FormSW.CommandItem[      tag: "Destroy"L, place: [312, FormSW.line0], proc: MyDestroy];    items[FormItems.options.ORD] ¬ FormSW.CommandItem[      tag: "Options"L, place: [384, FormSW.line0], proc: MyOptions];    RETURN[items: items, freeDesc: TRUE];    };  nullCH: CH.ConversationHandle = [NIL, NIL];  ch: CH.ConversationHandle ¬ nullCH;    Init: PROC = {    Out: Format.StringProc = {Put.Text[NIL, s]};    Process.SetTimeout[@waiter, Process.MsecToTicks[50]];    Process.EnableAborts[@waiter];    Exec.AddCommand["NSTerminal.~"L, Main];    InitUser[];    [] ¬ MakeConversation[Out];    };  GetDisting: PROC[name: LONG STRING]     RETURNS [nsname: NSName.Name ¬ NIL] = {    alias: NSName.Name ¬ NIL;    string: LONG STRING ¬ NIL;    nsstring: NSString.String ¬ NSString.nullString;     ret: CH.ReturnCode;    FreeStuff: PROC = {      IF alias # NIL THEN {NSName.FreeName[zone, alias]; alias ¬ NIL};      IF string # NIL THEN zone.FREE[@string]};    BEGIN ENABLE UNWIND => FreeStuff[];    string ¬ zone.NEW[StringBody[82]];    Profile.Qualify[name, string, clearinghouse];        BEGIN -- Profile.Qualify doesn't do anything if you feed it A:B    separators: CARDINAL ¬ 0;    GetDefaultOrganization: PROCEDURE [s: LONG STRING] =      BEGIN      String.AppendChar[string, ':];      String.AppendString[string, s];      END;    FOR i: CARDINAL IN [0..string.length) DO      SELECT string[i] FROM        ': => {IF (separators ¬ separators + 1) = 2 THEN EXIT};	ENDCASE;      REPEAT FINISHED => Profile.GetDefaultOrganization[GetDefaultOrganization];      ENDLOOP;    END;        alias ¬ NSName.MakeName[zone];    nsname ¬ NSName.MakeName[zone];    nsstring ¬ NSString.StringFromMesaString[string];    NSName.NameFieldsFromString[      z: zone,  destination: alias, s: nsstring!      NSName.Error => GOTO badName];    ret ¬ CH.LookupDistinguishedName[ch, alias, nsname];    IF ret.code # done THEN GOTO noCH;    EXITS       badName, noCH => {        IF string # NIL THEN zone.FREE[@string];        nsstring ¬ NSString.nullString;        IF nsname # NIL THEN NSName.FreeName[zone, nsname];	nsname ¬ NIL};    END;    FreeStuff[];    };    MakeConversation: PROC[Out: Format.StringProc] RETURNS [ok: BOOLEAN] = {    userID: Auth.IdentityHandle ¬ NIL;    GetID: PROC[id: Auth.IdentityHandle] = {userID ¬ id};    auth: Auth.CallProblem;    Profile.GetID[strong, GetID];    IF ch # nullCH THEN CH.FreeConversationHandle[@ch, zone];    [ch, ok, auth] ¬ CH.MakeConversationHandle[userID, zone];    IF ~ok THEN {      Out["Cant make CH conversation: "L];      ErrMsg.CallProblem[Out, auth];      Out[".  Please log in.\n"L];      };    };    initialized: BOOLEAN ¬ FALSE;  Main: Exec.ExecProc = {    window: Window.Handle ¬ NIL;    switch, name: LONG STRING ¬ NIL;    hostType: CARDINAL;    Out: Format.StringProc ¬ h.OutputProc[];    data: DataHandle ¬ NIL;    IF ~MakeConversation[Out] THEN RETURN;    IF ~initialized THEN {InitPortList[Out]; initialized ¬ TRUE};    window ¬ MakeOne[];    data ¬ Context.Find[context, window];    [name, switch] ¬ h.GetToken[];    IF data # NIL AND String.Length[name] > 0  THEN {      hostType ¬ data.reallineNumber;      IF switch # NIL THEN hostType ¬ SELECT switch[0] FROM	'a => 32000,	's => 32001,	'e => 32002,	'i => 32003,	ENDCASE => GetNumber[switch, hostType];      data.reallineNumber ¬ hostType;      String.Replace[@data.realhost, name, zone];      DoConnect[data.formSW, dont];      };    IF name # NIL THEN name ¬ Exec.FreeTokenString[name];    IF switch # NIL THEN switch ¬ Exec.FreeTokenString[switch];    };    GetNumber: PROC[string: LONG STRING, default: CARDINAL]     RETURNS [lineNumber: CARDINAL] = {    lineNumber ¬ default;    lineNumber ¬ String.StringToNumber[string !String.InvalidNumber => CONTINUE];    };    Flash: PUBLIC PROCEDURE =    BEGIN    ENABLE ABORTED => CONTINUE;    UserTerminal.BlinkDisplay[];    UserTerminal.Beep[262, 75];  -- c    UserTerminal.Beep[392, 75];  -- g    UserTerminal.Beep[659, 75];  -- e    END;  -- Mainline code  Init[];  -- this gets string out of global frame  }...    
-- ErrorMsgImpl.mesa-- BGY     	23-Oct-84 10:41:11-- Copyright (C) 1982, 1984 by Xerox Corporation. All rights reserved.DIRECTORY  Auth,  CH,  ErrMsg,  Format;ErrorMsgImpl: MONITOR   EXPORTS ErrMsg = PUBLIC {    CallProblem: PROC[Write: Format.StringProc, prob: Auth.CallProblem] = {    Write[SELECT prob FROM      tooBusy => "tooBusy"L,      cannotReachAS => "cannotReachAS"L,      keysUnavailable => "keysUnavailable"L,      strongKeyDoesNotExist => "strongKeyDoesNotExist"L,      simpleKeyDoesNotExist => "simpleKeyDoesNotExist"L,      badKey => "badKey"L,      accessRightsInsufficient => "accessRightsInsufficient"L,      strongKeyAlreadyRegistered => "strongKeyAlreadyRegistered"L,      simpleKeyAlreadyRegistered => "simpleKeyAlreadyRegistered"L,      domainForNewKeyUnavailable => "domainForNewKeyUnavailable"L,      domainForNewKeyUnknown => "domainForNewKeyUnknown"L,      badNameForNewKey => "badNameForNewKey"L,      databaseFull => "databaseFull"L,      ENDCASE => "other"L];    };    ReturnCode: PROC[Write: Format.StringProc, rc: CH.ReturnCode] = {    Write[SELECT rc.code FROM      done => "done"L,      notAllowed => "notAllowed"L,      rejectedTooBusy => "rejectedTooBusy"L,      allDown => "allDown"L,      badProtocol => "badProtocol"L,      illegalPropertyID => "illegalPropertyID"L,      illegalOrgName => "illegalOrgName"L,      illegalDomainName => "illegalDomainName"L,      illegalLocalName => "illegalLocalName"L,      noSuchOrg => "noSuchOrg"L,      noSuchDomain => "noSuchDomain"L,      noSuchLocal => "noSuchLocal"L,      propertyIDNotFound => "propertyIDNotFound"L,      wrongPropertyType => "wrongPropertyType"L,      noChange => "noChange"L,      outOfDate => "outOfDate"L,      overflowOfName => "overflowOfName"L,      overflowOfDataBase => "overflowOfDataBase"L,      credentialsInvalid => "credentialsInvalid"L,      credentialsTooWeak => "credentialsTooWeak"L,      wasUpNowDown => "wasUpNowDown"L,      ENDCASE => "other"L];    Write[", "L];    Write[SELECT rc.which FROM      first => "first"L,      second => "second"L,      ENDCASE => "other"L];    };    busy: BOOLEAN ¬ FALSE;    Go: ENTRY PROC RETURNS [BOOLEAN] = {    ENABLE UNWIND => NULL;    IF busy THEN RETURN [FALSE] ELSE RETURN[busy ¬ TRUE];    };    Done: ENTRY PROC = {ENABLE UNWIND => NULL; busy ¬ FALSE};  }.
-- MacroOpsImpl.mesa-- Revised by Gleason:  2-Apr-84 13:36:34-- Overview: Implements all operations on NSFile.Handles that are in NSFile.mesa but not in the protocol.DIRECTORY  Heap USING [systemZone],  NSFile USING [Attribute, AttributeList, Attributes, ChangeAttributes, Close, Controls, Copy, Delete, Error, GetAttributes, GetReference, Handle, ID, lowestVersion, Move, nullID, nullHandle, nullService, Open, Reference, Replace, Retrieve, Selections, Session, Sink, Source, String],  NSFileName USING [Error, FreeVPN, VPN, VPNFromString],  NSString USING [nullString];  MacroOpsImpl: PROGRAM IMPORTS Heap, NSFile, NSFileName EXPORTS NSFile =  BEGIN    OpenByReference: PUBLIC PROCEDURE [    reference: NSFile.Reference, controls: NSFile.Controls, session: NSFile.Session]    RETURNS [file: NSFile.Handle] =    BEGIN    attributes: ARRAY [0..2) OF NSFile.Attribute;    i: CARDINAL[0..2] _ 0;    IF reference.fileID # NSFile.nullID THEN      {attributes [i] _ [fileID [reference.fileID]];      i _ i + 1};    IF reference.service # NSFile.nullService THEN      {attributes [i] _ [service [reference.service]];      i _ i + 1};    RETURN NSFile.Open [DESCRIPTOR [BASE [attributes], i], NSFile.nullHandle, controls, session];     END; -- of OpenByReference      OpenByName: PUBLIC PROC [directory: NSFile.Handle, path: NSFile.String, controls: NSFile.Controls _ [], session: NSFile.Session] RETURNS [NSFile.Handle] =    BEGIN    vpn: NSFileName.VPN _ NSFileName.VPNFromString [      z: Heap.systemZone, s: path      ! NSFileName.Error => IF type = invalidSyntax THEN        ERROR NSFile.Error [[attributeValue[illegal, pathname]]]];    list: ARRAY [0..2) OF NSFile.Attribute;    i: CARDINAL[0..2] _ 0;    file: NSFile.Handle;        IF vpn.service # NSFile.nullService THEN      {IF directory # NSFile.nullHandle THEN {         --directory must be null if fully-qualified path given	 NSFileName.FreeVPN [Heap.systemZone, vpn];	 ERROR NSFile.Error [[handle [nullRequired]]]};      list [i] _ [service [vpn.service]];      i _ i + 1};    IF vpn.pathname # NSString.nullString THEN       {list [i] _ [pathname [vpn.pathname]];      i _ i + 1};    file _ NSFile.Open [      attributes: DESCRIPTOR [@list, i],      directory: directory, controls: controls,      session: session      ! NSFile.Error => NSFileName.FreeVPN [Heap.systemZone, vpn]];    NSFileName.FreeVPN [Heap.systemZone, vpn];    RETURN [file];    END; -- of OpenByName    CopyByName: PUBLIC PROCEDURE [directory: NSFile.Handle, path: NSFile.String, destination: NSFile.Handle, attributes: NSFile.AttributeList, session: NSFile.Session] RETURNS [NSFile.ID] =    BEGIN    refCopy: NSFile.Reference;    file: NSFile.Handle = OpenByName [directory, path,,session];    fileCopy: NSFile.Handle = NSFile.Copy [file: file, destination: destination, attributes: attributes, session: session      ! NSFile.Error => NSFile.Close [file, session]];    NSFile.Close [file, session];    refCopy _ NSFile.GetReference [fileCopy, session];    NSFile.Close [fileCopy, session];    RETURN [refCopy.fileID];    END; -- of CopyByName      MoveByName: PUBLIC PROCEDURE [directory: NSFile.Handle, path: NSFile.String, destination: NSFile.Handle, attributes: NSFile.AttributeList, session: NSFile.Session] =    BEGIN    file: NSFile.Handle = OpenByName [directory, path,,session];    NSFile.Move [file: file, destination: destination, attributes: attributes, session: session      ! NSFile.Error => NSFile.Close [file, session]];    NSFile.Close [file, session];    END; -- of MoveByName      DeleteByName: PUBLIC PROCEDURE [directory: NSFile.Handle, path: NSFile.String, session: NSFile.Session] =    BEGIN    vpn: NSFileName.VPN _ NSFileName.VPNFromString [      z: Heap.systemZone, s: path      ! NSFileName.Error => IF type = invalidSyntax THEN        ERROR NSFile.Error [[attributeValue[illegal, pathname]]]];    list: ARRAY [0..3) OF NSFile.Attribute;    i: CARDINAL[0..3] _ 1;    file: NSFile.Handle;        list[0] _ [version [NSFile.lowestVersion]];    IF vpn.service # NSFile.nullService THEN      {IF directory # NSFile.nullHandle THEN {         --directory must be null if fully-qualified path given	 NSFileName.FreeVPN [Heap.systemZone, vpn];	 ERROR NSFile.Error [[handle [nullRequired]]]};      list [i] _ [service [vpn.service]];      i _ i + 1};    IF vpn.pathname # NSString.nullString THEN       {list [i] _ [pathname [vpn.pathname]];      i _ i + 1};    file _ NSFile.Open [      attributes: DESCRIPTOR [@list, i],       directory: directory, session: session      ! NSFile.Error => NSFileName.FreeVPN [Heap.systemZone, vpn]];    NSFile.Delete [file, session      ! NSFile.Error => {NSFile.Close [file, session];        NSFileName.FreeVPN [Heap.systemZone, vpn]}];    NSFileName.FreeVPN [Heap.systemZone, vpn];    END; -- of DeleteByName      GetAttributesByName: PUBLIC PROCEDURE [directory: NSFile.Handle, path: NSFile.String, selections: NSFile.Selections, attributes: NSFile.Attributes, session: NSFile.Session] =    BEGIN    file: NSFile.Handle = OpenByName [directory, path,,session];    NSFile.GetAttributes [file, selections, attributes, session      ! NSFile.Error => NSFile.Close [file, session]];    NSFile.Close [file, session];    END; -- of GetAttributesByName      ChangeAttributesByName: PUBLIC PROCEDURE [directory: NSFile.Handle, path: NSFile.String, attributes: NSFile.AttributeList, session: NSFile.Session] =    BEGIN    file: NSFile.Handle = OpenByName [directory, path,,session];    NSFile.ChangeAttributes [file, attributes, session      ! NSFile.Error => NSFile.Close [file, session]];    NSFile.Close [file, session];    END; -- of ChangeAttributesByName      ReplaceByName: PUBLIC PROC [directory: NSFile.Handle, path: NSFile.String, source: NSFile.Source, attributes: NSFile.AttributeList, session: NSFile.Session] =    BEGIN    file: NSFile.Handle = OpenByName [directory, path,,session];    NSFile.Replace [file, source, attributes, session      ! NSFile.Error => NSFile.Close [file, session]];    NSFile.Close [file, session];    END; -- of ReplaceByName     RetrieveByName: PUBLIC PROC [directory: NSFile.Handle, path: NSFile.String, sink: NSFile.Sink, session: NSFile.Session] =    BEGIN    file: NSFile.Handle = OpenByName [directory, path,,session];    NSFile.Retrieve [file, sink, session      ! NSFile.Error => NSFile.Close [file, session]];    NSFile.Close [file, session];    END;  -- of RetrieveByName           OpenChild: PUBLIC PROCEDURE [directory: NSFile.Handle, id: NSFile.ID, controls: NSFile.Controls _ [], session: NSFile.Session] RETURNS [NSFile.Handle] =    BEGIN    list: ARRAY [0..1) OF NSFile.Attribute _ [      [fileID [id]]];    RETURN NSFile.Open [DESCRIPTOR [list], directory, controls, session];    END; -- of OpenChild      CopyChild: PUBLIC PROC [directory: NSFile.Handle, id: NSFile.ID, destination: NSFile.Handle, attributes: NSFile.AttributeList, session: NSFile.Session] RETURNS [NSFile.ID] =    BEGIN    refCopy: NSFile.Reference;    child: NSFile.Handle _ OpenChild [directory: directory, id: id, session: session];    childCopy: NSFile.Handle _ NSFile.Copy [file: child, destination: destination, attributes: attributes, session: session      ! NSFile.Error => NSFile.Close [child, session]];    NSFile.Close [child, session];    refCopy _ NSFile.GetReference [childCopy, session];    NSFile.Close [childCopy, session];    RETURN [refCopy.fileID];    END; -- of CopyChild    MoveChild: PUBLIC PROC [directory: NSFile.Handle, id: NSFile.ID, destination: NSFile.Handle, attributes: NSFile.AttributeList, session: NSFile.Session] =    BEGIN    child: NSFile.Handle = OpenChild [directory: directory, id: id, session: session];    NSFile.Move [file: child, destination: destination, attributes: attributes, session: session      ! NSFile.Error => NSFile.Close [child, session]];    NSFile.Close [child, session];    END; -- of MoveChild      DeleteChild: PUBLIC PROCEDURE [directory: NSFile.Handle, id: NSFile.ID, session: NSFile.Session] =    BEGIN    child: NSFile.Handle = OpenChild [directory: directory, id: id, session: session];    NSFile.Delete [file: child, session: session      ! NSFile.Error => NSFile.Close [child, session]];    END; -- of DeleteChild        GetAttributesChild: PUBLIC PROCEDURE [directory: NSFile.Handle, id: NSFile.ID, selections: NSFile.Selections, attributes: NSFile.Attributes, session: NSFile.Session] =    BEGIN    child: NSFile.Handle = OpenChild [directory: directory, id: id, session: session];    NSFile.GetAttributes [file: child, selections: selections, attributes: attributes, session: session      ! NSFile.Error => NSFile.Close [child, session]];    NSFile.Close [child, session];    END; -- of GetAttributesChild    ChangeAttributesChild: PUBLIC PROCEDURE [directory: NSFile.Handle, id: NSFile.ID, attributes: NSFile.AttributeList, session: NSFile.Session] =    BEGIN    child: NSFile.Handle = OpenChild [directory: directory, id: id, session: session];    NSFile.ChangeAttributes [file: child, attributes: attributes, session: session      ! NSFile.Error => NSFile.Close [child, session]];    NSFile.Close [child, session];    END; -- of ChangeAttributesChild      ReplaceChild: PUBLIC PROCEDURE [directory: NSFile.Handle, id: NSFile.ID, source: NSFile.Source, attributes: NSFile.AttributeList, session: NSFile.Session] =    BEGIN    child: NSFile.Handle = OpenChild [directory: directory, id: id, session: session];    NSFile.Replace [child, source, attributes, session      ! NSFile.Error => NSFile.Close [child, session]];    NSFile.Close [child, session];    END;  -- of ReplaceChild   RetrieveChild: PUBLIC PROCEDURE [directory: NSFile.Handle, id: NSFile.ID, sink: NSFile.Sink, session: NSFile.Session] =    BEGIN    child: NSFile.Handle = OpenChild [directory: directory, id: id, session: session];    NSFile.Retrieve [child, sink, session      ! NSFile.Error => NSFile.Close [child, session]];    NSFile.Close [child, session];    END;  -- of ReplaceChild           END. -- of MacroOpsImpl  LOG14-Jun-82 16:36:11 - Newman - Created.15-Jun-82 17:21:07 - Newman - Corrected order of ReplaceChild parameters. 7-Jul-82 21:46:14 - Newman - DeleteByName deletes lowest rather than highest version.-- Services 8.0 -- 3-Nov-83  9:32:29 - Buelow - Convert to new 8.0 NSFile.12-Dec-83 13:06:03 - Gleason - Change *ByName operations to act on pathname attribute instead of name attribute. 2-Apr-84 13:36:56 - Gleason - Make bounds of attribute list counter i be [0..3] instead of [0..2] in DeleteByName since the attr list may have 3 elements.  
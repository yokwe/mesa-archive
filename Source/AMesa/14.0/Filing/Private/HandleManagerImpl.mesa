-- Copyright (C) 1984, 1985 by Xerox Corporation. All rights reserved. --  HandleManagerImpl.mesa--  Last revised by Breisacher: 30-May-86  8:43:42--  Overview:  Management of handles.<< To do:   o Correct per-manager locking by moving manager object's zone ('z') from vector back into object itself.>>DIRECTORY  HandleManager USING [Cache, ErrorType, Handle, HandleProc],  System USING [GetGreenwichMeanTime];HandleManagerImpl: MONITOR LOCKS manager.lock.l USING manager: Manager  IMPORTS System EXPORTS HandleManager =  BEGIN  --   -- --   -- --   --  --   --  -- PRIVATE PACK DATA STRUCTURES :  --   -- --   -- --   --  --   --  -- Private Types :  --   -- --   -- --   --  --   --  -- HANDLE MANAGER DATA STRUCTURES:  Manager: TYPE = LONG POINTER TO Object;  Object: PUBLIC TYPE = RECORD [    lock: LONG POINTER TO Lock,    vector: LONG POINTER TO Vector,    initialSize, growBy: [0..256)];  Vector: TYPE = RECORD [    z: UNCOUNTED ZONE, handles: SEQUENCE count: CARDINAL OF HandleReference];  HandleReference: TYPE = LONG POINTER TO HandleRecord;  HandleRecord: TYPE = RECORD [    stamp: CARDINAL,  -- timestamp    program, key: UNSPECIFIED,  -- debug data    cache: SEQUENCE COMPUTED CARDINAL OF UNSPECIFIED];  -- client's cache  Lock: TYPE = RECORD [l: MONITORLOCK];  -- THE HANDLE ITSELF:  Handle: PUBLIC TYPE = RECORD [    stamp: CARDINAL,  -- timestamp    index: CARDINAL];  -- index into vector  --   -- --   -- --   --  --   --  -- Pack Structure :  --   -- --   -- --   --  --   --  -- CURRENT TIMESTAMP:  currentStamp: CARDINAL ¬ CARDINAL[System.GetGreenwichMeanTime[]];  -- initialized to "random" value  --   -- --   -- --   --  --   --  -- SIGNALS AND ERRORS :  --   -- --   -- --   --  --   --  Error: PUBLIC ERROR [type: HandleManager.ErrorType] = CODE;  --   -- --   -- --   --  --   --  -- PUBLIC OPERATIONS :  --   -- --   -- --   --  --   --  -- OVERALL MANAGEMENT.  --   -- --   -- --   --  --   --  Initialize: PUBLIC PROCEDURE [    initialSize, growBy: CARDINAL, zone: UNCOUNTED ZONE, manager: Manager] =    BEGIN    -- initialize the manager object    manager­ ¬ [      lock: zone.NEW[Lock], vector: NIL, initialSize: initialSize,      growBy: growBy];    GrowVector[manager, zone];    END;  -- of Initialize  --   -- --   -- --   --  --   --  Clear: PUBLIC PROCEDURE [manager: Manager, mustBeEmpty: BOOLEAN ¬ TRUE] =    BEGIN    z: UNCOUNTED ZONE = manager.vector.z;    -- check if empty, or clear all handles    FOR i: CARDINAL IN [0..manager.vector.count) DO      IF manager.vector[i] # NIL THEN {        IF mustBeEmpty THEN ERROR Error[handlesExist]        ELSE --manager.-- z.FREE[@manager.vector[i]]};      ENDLOOP;    -- get rid of the vector    --manager.-- z.FREE[@manager.vector];    z.FREE[@manager.lock];    -- smash the manager object    manager­ ¬ [lock: NIL, vector: NIL, initialSize: 0, growBy: 0];    END;  -- of Clear  --   -- --   -- --   --  --   --  GetZone: PUBLIC ENTRY PROCEDURE [manager: Manager] RETURNS [UNCOUNTED ZONE] =    {ENABLE UNWIND => NULL; RETURN[manager.vector.z]};  --   -- --   -- --   --  --   --  -- HANDLES.  --   -- --   -- --   --  --   --  CreateHandle: PUBLIC ENTRY PROCEDURE [cacheSize: CARDINAL, manager: Manager]    RETURNS [handle: Handle, cache: HandleManager.Cache] =    BEGIN    ENABLE UNWIND => NULL;    -- find an empty index (may grow the manager)    handle ¬ [index: FindEmptyIndex[manager], stamp: NextStamp[]];    -- create the handle record    manager.vector[handle.index] ¬ manager.vector.z.NEW[      HandleRecord [cacheSize] ¬ [      stamp: handle.stamp, program: 0, key: 0, cache:]];    -- set the cache    cache ¬ @manager.vector[handle.index].cache;    END;  -- of CreateHandle  --   -- --   -- --   --  --   --  DestroyHandle: PUBLIC ENTRY PROCEDURE [handle: Handle, manager: Manager] =    BEGIN    ENABLE UNWIND => NULL;    [] ¬ ValidateHandle[handle, manager ! Error => GOTO invalid];    manager.vector.z.FREE[@manager.vector[handle.index]];  -- also clears HandleReference    EXITS invalid => RETURN WITH ERROR Error[invalidHandle];    END;  -- of DestroyHandle  --   -- --   -- --   --  --   --  GetCache: PUBLIC ENTRY PROCEDURE [handle: Handle, manager: Manager]    RETURNS [cache: HandleManager.Cache] = {    ENABLE UNWIND => NULL;    RETURN[@ValidateHandle[handle, manager ! Error => GOTO invalid].cache]    EXITS invalid => RETURN WITH ERROR Error[invalidHandle]};  --   -- --   -- --   --  --   --  SetDebugData: PUBLIC ENTRY PROCEDURE [    handle: Handle, program, key: UNSPECIFIED, manager: Manager] =    BEGIN    ENABLE UNWIND => NULL;    reference: HandleReference ¬ ValidateHandle[      handle, manager ! Error => GOTO invalid];    reference.program ¬ program;    reference.key ¬ key;    EXITS invalid => RETURN WITH ERROR Error[invalidHandle];    END;  -- of SetDebugData  --   -- --   -- --   --  --   --  GetDebugData: PUBLIC ENTRY PROCEDURE [handle: Handle, manager: Manager]    RETURNS [program, key: UNSPECIFIED] =    BEGIN    ENABLE UNWIND => NULL;    reference: HandleReference ¬ ValidateHandle[      handle, manager ! Error => GOTO invalid];    RETURN[reference.program, reference.key];    EXITS invalid => RETURN WITH ERROR Error[invalidHandle];    END;  -- of GetDebugData  --   -- --   -- --   --  --   --  -- ENUMERATION.  --   -- --   -- --   --  --   --  EnumerateHandles: PUBLIC PROCEDURE [    proc: HandleManager.HandleProc, manager: Manager] =    BEGIN    i: CARDINAL ¬ 0;    WHILE i < manager.vector.count DO      IF manager.vector[i] # NIL THEN        proc[Handle[stamp: manager.vector[i].stamp, index: i]];      i ¬ i + 1;      ENDLOOP;    -- not programmed with FOR in case vector size changes during enumeration    END;  -- of EnumerateHandles  --   -- --   -- --   --  --   --  -- PRIVATE OPERATIONS  --   -- --   -- --   --  --   --  -- Find a slot that is unused, growing the vector if necessary.  FindEmptyIndex: PROCEDURE [manager: Manager] RETURNS [i: CARDINAL] =    BEGIN    FOR i IN [0..manager.vector.count) DO      IF manager.vector[i] = NIL THEN RETURN[i]; ENDLOOP;    -- no empty slot; must grow the vector    i ¬ manager.vector.count;    GrowVector[manager, manager.vector.z];    END;  -- of FindEmptyIndex  --   -- --   -- --   --  --   --  -- Make a bigger vector, copying existing entries (if any).  GrowVector: PROCEDURE [manager: Manager, z: UNCOUNTED ZONE] =    BEGIN    oldSize: CARDINAL =      IF manager.vector = NIL THEN 0 ELSE manager.vector.count;    newSize: CARDINAL =      IF oldSize = 0 THEN manager.initialSize ELSE oldSize + manager.growBy;    newVector: LONG POINTER TO Vector ¬ z.NEW[Vector [newSize]];    -- copy over and delete old entries, if any    newVector.z ¬ z;    IF manager.vector # NIL THEN      BEGIN      FOR i: CARDINAL IN [0..oldSize) DO        newVector[i] ¬ manager.vector[i]; ENDLOOP;      z.FREE[@manager.vector];      END;    -- clear all other entries    FOR i: CARDINAL IN [oldSize..newSize) DO newVector[i] ¬ NIL; ENDLOOP;    -- replace the vector    manager.vector ¬ newVector;    END;  -- of GrowVector  --   -- --   -- --   --  --   --  -- Assign a timestamp.  NextStamp: --ENTRY-- PROCEDURE RETURNS [stamp: CARDINAL] =    BEGIN    currentStamp ¬ currentStamp + 1;    IF currentStamp = 0 THEN currentStamp ¬ 1;  -- should never be zero    RETURN[currentStamp];    END;  -- of NextStamp  --   -- --   -- --   --  --   --  -- Validate a handle, returning the handle reference.  ValidateHandle: PROCEDURE [handle: Handle, manager: Manager]    RETURNS [reference: HandleReference] =    BEGIN    -- make sure index is in range, it is occupied, and stamps match    IF handle.index >= manager.vector.count THEN ERROR Error[invalidHandle];    reference ¬ manager.vector[handle.index];    IF reference = NIL OR handle.stamp # reference.stamp THEN      ERROR Error[invalidHandle];    END;  -- of ValidateHandle  --   -- --   -- --   --  --   --  END.  -- of HandleManagerImplLOG  ( date - person - action ) 8-Jun-82 10:09:33 - Kabcenell - Creation. 9-Sep-82 10:32:24 - Kabcenell - Clear was forgetting to delete handles.May 11, 1984 - Hanzel - Converted implementation to object style monitor to satisfy AR 7588 (multi-process clients were not protected against concurrent use of the same manager object).August 28, 1984 - Hanzel - Concurrent clients are not protected if manager.vector must be grown (and monitor lock is in vector record); moved zone to vector record and lock into manager object.  When HandleManager interface can be modified, the manager object's zone ('z') should be moved back to the Object type.  This will increase the size of a manager object.30-May-85 10:55:47 - McManis - Minor change to EnumerateHandle to allow partial enumerations.  Fixes AR #4984.30-May-86 - Breisacher - 8.0 maintenance release.  Back out McManis's fix to match the 8.0 HandleManager.
-- File: NSFileCourierServerImpl.mesa - last edit:-- Hanzel.ES            2-Mar-87 18:33:42-- Copyright (C) 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987 by Xerox Corporation. All rights reserved.<<To do:  o  Eliminate export to NSFileCourierExtra.  >>DIRECTORY  Auth USING [    AuthenticationError, CallError, CopyCredentials, Credentials, FreeVerifier,    Verifier],  ClientOpsInternal USING [LogonInternal],  Courier USING [    Dispatcher, Error, ErrorCode, ExportRemoteProgram, Free,    InvalidArguments, NoSuchProcedureNumber,    Parameters, SignalRemoteError, UnexportRemoteProgram],  Heap USING [FreeNode, systemZone],  NSDataStream USING [    Abort, Aborted, Error,    OpenSink, OpenSource, Sink, SinkStream, Source, SourceStream],  NetworkStream USING [ClassOfService],  NSFile USING [    Attribute, AttributeList, Attributes, AttributesProc,    AttributesRecord, ChangeAttributes,    ChangeControls, Close, Controls, ControlSelections, Copy,    Create, Delete, Deserialize, Direction, Error, ErrorRecord,    Filter, Find, FreeAttributes, FreeWords, GetAttributes, GetControls,    Handle, List, Logoff, MakeReference, Move, nullID, nullSession,    Open, Probe, Replace, Retrieve, Scope, Selections, Serialize, Service,    ServiceRecord, Session, Store, SystemElement, UnifyAccessLists],  NSFileControl USING [allVersions, ErrorType, Version, VersionRange],  NSFileControlInternal,  NSFileCourier,  -- USING almost everything  NSFileCourierExtra,  NSFileCourierStats,  NSFileCourierStatsInternal,  NSFilingGlobal USING [NullifyAttributes],  NSName USING [FreeName, Name],  NSSession USING [    AttributesRef, ClientID, Context, ContextID,    Error, GetAttributes, GetContext, SetContext, TerminationHandler],  NSVolumeControl USING [Error, GetID],  NSVolumeInternal USING [GetVolumeStatus],  Stream USING [Delete, Handle],  System USING [GetGreenwichMeanTime, GreenwichMeanTime, SecondsSinceEpoch],  Volume USING [ID];NSFileCourierServerImpl: PROGRAM  IMPORTS Auth, ClientOpsInternal, Courier, Heap, NSDataStream, NSFile,    NSFileControlInternal, NSFileCourier, NSFilingGlobal, NSName,    NSSession, NSVolumeControl, NSVolumeInternal, Stream, System  EXPORTS    NSFileControl, NSFileControlInternal, NSFileCourier, NSFileCourierExtra,    NSFileCourierStats, NSFileCourierStatsInternal =  BEGIN OPEN NSFileCourier;  --   --   --   --   --   --   --   --  -- TYPES :  --   --   --   --   --   --   --   --    authenticateProc: NSFileControlInternal.AuthenticateProc;  -- see below    Count: TYPE = NSFileCourierStats.Count;    Operation: TYPE = NSFileCourierStats.Operation;    SessionData: TYPE = LONG POINTER TO SessionDataRecord;    SessionDataRecord: TYPE = RECORD [    service: NSFile.Service,  -- which local service    credentials: Auth.Credentials,    startTime: System.GreenwichMeanTime --for stats -- ];  --   --   --   --   --   --   --   --  -- CONSTANTS :  --   --   --   --   --   --   --   --    versionCurrent: CARDINAL = 5;   -- defined for Filing 5 compatibility  -- would normally be equal to NSFileCourier.versionNumber    --   --   --   --   --   --   --   --  -- EXPORTED VARIABLES :  --   --   --   --   --   --   --   --    operationStats: PUBLIC ARRAY Operation OF Count;    sessionStats: PUBLIC NSFileCourierStats.SessionStats;    statisticsEnabled: PUBLIC BOOLEAN _ FALSE;    Error: PUBLIC ERROR [type: NSFileControl.ErrorType] = CODE;  --   --   --   --   --   --   --   --  -- GLOBAL DATA :  --   --   --   --   --   --   --   --    currentDispatcher: Courier.Dispatcher _ Dispatch;    serverStubID: NSSession.ClientID = NSFileControlInternal.clientID;  serverStubContextID: NSSession.ContextID = 80;  -- must not conflict with local    sessionDurationSum: LONG CARDINAL;    Bug: ERROR [type: BugType] = CODE;  BugType: TYPE = {tooManyVersions};    --  Dispatching to Local Procedures  procedureDescriptions: RemoteProcedureDescriptionsHandle =    GetRemoteProcedureDescriptions[];  errorDescriptions: RemoteErrorDescriptionsHandle = GetRemoteErrorDescriptions[];    classOfService: PUBLIC NetworkStream.ClassOfService _ bulk;    ReportError: PROCEDURE [error: RemoteErrorIndex, argumentList: POINTER] =    INLINE {    ERROR Courier.SignalRemoteError[      errorNumber: LOOPHOLE[error],      arguments: [      location: argumentList, description: errorDescriptions^[error].arguments]]};  Dispatch: Courier.Dispatcher    --[cH: Courier.Handle, procedureNumber: CARDINAL,--    -- arguments: Courier.Arguments, results: Courier.Results ]--  =    BEGIN    CleanupArguments: PROCEDURE =      BEGIN Courier.Free[argumentParameters, zone] END;    zone: UNCOUNTED ZONE = cH.zone;    procedure: RemoteProcedureIndex;    argumentList: POINTER TO GenericArgumentRecord = @argumentListRecord;    argumentListRecord: GenericArgumentRecord;    argumentParameters: Courier.Parameters;    resultList: POINTER TO GenericResultRecord = @resultListRecord;    resultListRecord: GenericResultRecord;    resultParameters: Courier.Parameters;    IF procedureNumber > ORD[LAST[RemoteProcedureIndex]] THEN      ERROR Courier.NoSuchProcedureNumber;    procedure _ LOOPHOLE[procedureNumber];    argumentParameters _ [      location: argumentList,      description: procedureDescriptions^[procedure].arguments];    resultParameters _ [      location: resultList,      description: procedureDescriptions^[procedure].results];    arguments[argumentParameters ! Courier.Error => GOTO argumentsError];    BEGIN    ENABLE      BEGIN      Courier.InvalidArguments => REJECT;      Courier.SignalRemoteError => REJECT;      Courier.NoSuchProcedureNumber => REJECT; -- allow Courier to propagate      Courier.Error =>        SELECT errorCode FROM	  callerAborted => CONTINUE;	  parameterInconsistency => GOTO argumentsError;	  ENDCASE => REJECT;  -- allow Courier to propagate      UNWIND => CleanupArguments[];      Auth.AuthenticationError => {        argRecord: AuthenticationErrorArguments _ [reason];	ReportError[AuthenticationError, @argRecord]};      Auth.CallError =>        IF reason = badKey THEN {          argRecord: AuthenticationErrorArguments _ [verifierInvalid];	  ReportError[AuthenticationError, @argRecord]}	ELSE {	  argRecord: ServiceErrorArguments _ [cannotAuthenticate];	  ReportError[ServiceError, @argRecord]};      NSFile.Error =>	WITH e: error SELECT FROM	  access => {	    argRecord: AccessErrorArguments _ [e.problem];	    ReportError[AccessError, @argRecord]};	  attributeType => {	    argRecord: AttributeTypeErrorArguments;	    argRecord.problem _ e.problem;	    argRecord.type _ IF e.type = extended THEN e.extendedType	        ELSE LONG[LOOPHOLE[e.type, CARDINAL]];	    ReportError[AttributeTypeError, @argRecord]};	  attributeValue => {	    argRecord: AttributeValueErrorArguments;	    argRecord.problem _ e.problem;	    argRecord.type _ IF e.type = extended THEN e.extendedType	        ELSE LONG[LOOPHOLE[e.type, CARDINAL]];	    ReportError[AttributeValueError, @argRecord]};	  authentication =>	    SELECT e.problem FROM	      credentialsInvalid => {	        argRecord: AuthenticationErrorArguments;		argRecord.problem _ credentialsInvalid;		ReportError[AuthenticationError, @argRecord]};	      credentialsTooWeak => {	        argRecord: AuthenticationErrorArguments _		  [inappropriateCredentials];	        ReportError[AuthenticationError, @argRecord]};	      ENDCASE => {	        argRecord: ServiceErrorArguments _ [cannotAuthenticate];	        ReportError[ServiceError, @argRecord]};	  connection => {	    argRecord: ConnectionErrorArguments;	    argRecord.problem _ e.problem;	    ReportError[ConnectionError, @argRecord]};	  controlType => {	    argRecord: ControlTypeErrorArguments _	      [problem: e.problem, type: e.type];	    ReportError[ControlTypeError, @argRecord]};	  controlValue => {	    argRecord: ControlValueErrorArguments _	      [problem: e.problem, type: e.type];	    ReportError[ControlValueError, @argRecord]};	  handle => {	    argRecord: HandleErrorArguments _ [problem: e.problem];	    ReportError[HandleError, @argRecord]};	  insertion => {	    argRecord: InsertionErrorArguments _ [problem: e.problem];	    ReportError[InsertionError, @argRecord]};	  scopeType => {	    argRecord: ScopeTypeErrorArguments _	      [problem: e.problem, type: e.type];	    ReportError[ScopeTypeError, @argRecord]};	  scopeValue => {	    argRecord: ScopeValueErrorArguments _	      [problem: e.problem, type: e.type];	    ReportError[ScopeValueError, @argRecord]};	  service => {	    argRecord: ServiceErrorArguments _ [problem: e.problem];	    ReportError[ServiceError, @argRecord]};	  session => {	    argRecord: SessionErrorArguments _ [problem: e.problem];	    ReportError[SessionError, @argRecord]};	  space => {	    argRecord: SpaceErrorArguments _ [problem: e.problem];	    ReportError[SpaceError, @argRecord]};	  transfer => {	    argRecord: TransferErrorArguments _ [problem: e.problem];	    ReportError[TransferError, @argRecord]};	  undefined => {	    argRecord: UndefinedErrorArguments _ [problem: e.problem];	    ReportError[UndefinedError, @argRecord]}; 	  ENDCASE => REJECT;  -- implementation bug      END;  --ENABLE    IF statisticsEnabled AND procedure <= LAST[RemoteProcedureIndex] THEN      operationStats[procedure] _ operationStats[procedure] + 1;          SELECT procedure FROM      Logon => {        OPEN arg: LOOPHOLE[argumentList, POINTER TO LogonArguments],	  res: LOOPHOLE[resultList, POINTER TO LogonResults];	initiator: NSName.Name;	serviceRec: NSFile.ServiceRecord _ [name: arg.service];	service: NSFile.Service _ @serviceRec;               [initiator, res.session.verifier] _ authenticateProc [	  @arg.service, arg.credentials, arg.verifier, Heap.systemZone];	-- authentication has succeeded, so continue initiating local session		BEGIN ENABLE UNWIND => {	  NSName.FreeName[Heap.systemZone, initiator];	  Auth.FreeVerifier[@res.session.verifier, Heap.systemZone]};	volumeID: Volume.ID =	  NSVolumeControl.GetID[@arg.service ! NSVolumeControl.Error =>	    IF type = volumeNotFound THEN NSFile.Error[[service[serviceUnknown]]]	    ELSE REJECT];	IF NSVolumeInternal.GetVolumeStatus [volumeID] # online THEN	  NSFile.Error[[service[serviceUnavailable]]];	service _ NSFile.MakeReference[NSFile.nullID, service].service;	res.session.token _ ClientOpsInternal.LogonInternal[	  service: service, name: initiator, volume: volumeID,	  isPrivileged: FALSE, systemElement: cH.remote];	END;	NSName.FreeName[Heap.systemZone, initiator];	CacheSessionData[res.session.token, service, arg.credentials];		[] _ results[resultParameters, FALSE];	Auth.FreeVerifier[@res.session.verifier, Heap.systemZone];	CleanupArguments[];	RETURN;	};      Logoff => {        OPEN arg: LOOPHOLE[argumentList, POINTER TO LogoffArguments],	  res: LOOPHOLE[resultList, POINTER TO LogoffResults];	CheckSessionAndVerifier[arg.session, cH.remote];	NSFile.Logoff[arg.session.token];	};      Probe => {        OPEN arg: LOOPHOLE[argumentList, POINTER TO ProbeArguments],	  res: LOOPHOLE[resultList, POINTER TO ProbeResults];	CheckSessionAndVerifier[arg.session, cH.remote];	res.probeWithin _ NSFile.Probe[arg.session.token];	};      Create => {        OPEN arg: LOOPHOLE[argumentList, POINTER TO CreateArguments],          res: LOOPHOLE[resultList, POINTER TO CreateResults];	controls: NSFile.Controls;	CheckSessionAndVerifier[arg.session, cH.remote];	controls _ DecodeControls[arg.controls].controls;        [res.file] _ NSFile.Create[	  arg.directory, arg.attributes, controls, arg.session.token];        };      Copy => {        OPEN arg: LOOPHOLE[argumentList, POINTER TO CopyArguments],          res: LOOPHOLE[resultList, POINTER TO CopyResults];	controls: NSFile.Controls;	CheckSessionAndVerifier[arg.session, cH.remote];	controls _ DecodeControls[arg.controls].controls;        [res.newFile] _ NSFile.Copy[          arg.file, arg.destination, arg.attributes, controls, arg.session.token];        };      Move => {        OPEN arg: LOOPHOLE[argumentList, POINTER TO MoveArguments],          res: LOOPHOLE[resultList, POINTER TO MoveResults];	CheckSessionAndVerifier[arg.session, cH.remote];        NSFile.Move[arg.file, arg.destination, arg.attributes, arg.session.token];        };      Delete => {        OPEN arg: LOOPHOLE[argumentList, POINTER TO DeleteArguments],          res: LOOPHOLE[resultList, POINTER TO DeleteResults];	CheckSessionAndVerifier[arg.session, cH.remote];        NSFile.Delete[arg.file, arg.session.token];        };      List => {        OPEN arg: LOOPHOLE[argumentList, POINTER TO ListArguments],          res: LOOPHOLE[resultList, POINTER TO ListResults];        clientAborted, errorRaised: BOOLEAN _ FALSE;	nsFileError: NSFile.ErrorRecord;	scope: NSFile.Scope; 	selections: NSFile.Selections;	sinkDS: NSDataStream.SinkStream;        Cleanup: PROCEDURE =           BEGIN	  header: AttributeSequenceHeader _ [type: lastSegment, lists: 0];	  IF ~clientAborted THEN	    IF errorRaised	      THEN NSDataStream.Abort[sinkDS]	      ELSE SerializeAttributeSequenceHeader[header, sinkDS !	        NSDataStream.Aborted => CONTINUE];          Courier.Free[argumentParameters, zone];	  Stream.Delete[sinkDS ! NSDataStream.Aborted => CONTINUE];          END;   -- of Cleanup        ListProc: NSFile.AttributesProc =          BEGIN	  header: AttributeSequenceHeader _ [type: nextSegment, lists: 1];	  list: NSFile.AttributeList;	  attributes.isTemporary _ FALSE;  -- known positively if listing!	  list _ EncodeAttributes[attributes, arg.selections, zone];	  BEGIN ENABLE	    {NSDataStream.Aborted => {clientAborted _ TRUE; CONTINUE};	    UNWIND => IF BASE [list] # NIL THEN Heap.FreeNode [zone, BASE [list]]};	  SerializeAttributeSequenceHeader[header, sinkDS];	  SerializeAttributes[list, sinkDS];	  END;	  IF BASE [list] # NIL THEN Heap.FreeNode [zone, BASE [list]];          RETURN[continue: NOT clientAborted]          END;   -- of ListProc 	CheckSessionAndVerifier[arg.session, cH.remote];	sinkDS _ NSDataStream.OpenSink[arg.listing, cH !	  NSDataStream.Error => GOTO connectionFailed  -- needs rework! -- ];	scope _ DecodeProtocolScope[arg.scope, zone]; 	selections _ DecodeSelections[arg.selections, zone];	selections.interpreted[isDirectory] _ TRUE;	selections.interpreted[isTemporary] _ FALSE;        NSFile.List[          arg.directory, ListProc, selections, scope, NIL, arg.session.token !          NSFile.Error => {nsFileError _ error; errorRaised _ TRUE; CONTINUE};	  UNWIND => FreeSelections[selections, zone]];        Cleanup[];	FreeSelections[selections, zone];  -- preserve till after cleanup	IF errorRaised THEN ERROR NSFile.Error[nsFileError];	EXITS 	  connectionFailed => ERROR NSFile.Error[[undefined[unimplemented]]]};	      GetAttributes => {        OPEN arg: LOOPHOLE[argumentList, POINTER TO GetAttributesArguments],          res: LOOPHOLE[resultList, POINTER TO GetAttributesResults];        attributes: NSFile.Attributes _ zone.NEW[NSFile.AttributesRecord];	selections: NSFile.Selections;	CheckSessionAndVerifier[arg.session, cH.remote];	selections _ DecodeSelections[arg.selections, zone];	selections.interpreted[isDirectory] _ TRUE;	selections.interpreted[isTemporary] _ TRUE;	NSFilingGlobal.NullifyAttributes[attributes];        NSFile.GetAttributes[          arg.file, selections, attributes, arg.session.token !          UNWIND => {	    zone.FREE[@attributes];	    FreeSelections[selections, zone]}];	[res.attributes] _ EncodeAttributes[attributes, arg.selections, zone];        FreeSelections[selections, zone];	CleanupArguments[];	[] _ results[resultParameters, FALSE ! UNWIND => {	  NSFile.FreeAttributes [attributes];  --frees attached strings and Words	  IF BASE [res.attributes] # NIL 	    THEN Heap.FreeNode [zone, BASE [res.attributes]]}];	NSFile.FreeAttributes [attributes];  --frees attached strings and Words	IF BASE [res.attributes] # NIL 	  THEN Heap.FreeNode [zone, BASE [res.attributes]];	RETURN;        };      ChangeAttributes => {        OPEN arg: LOOPHOLE[argumentList, POINTER TO ChangeAttributesArguments],          res: LOOPHOLE[resultList, POINTER TO ChangeAttributesResults];	CheckSessionAndVerifier[arg.session, cH.remote];        NSFile.ChangeAttributes[arg.file, arg.attributes, arg.session.token];        };      UnifyAccessLists => {        OPEN arg: LOOPHOLE[argumentList, POINTER TO UnifyAccessListsArguments],          res: LOOPHOLE[resultList, POINTER TO UnifyAccessListsResults];	CheckSessionAndVerifier[arg.session, cH.remote];        NSFile.UnifyAccessLists[arg.directory, arg.session.token];        };      Open => {        OPEN arg: LOOPHOLE[argumentList, POINTER TO OpenArguments],          res: LOOPHOLE[resultList, POINTER TO OpenResults];	controls: NSFile.Controls;	CheckSessionAndVerifier[arg.session, cH.remote];	controls _ DecodeControls[arg.controls].controls;        [res.file] _ NSFile.Open[arg.attributes, arg.directory, controls, arg.session.token];        };      Close => {        OPEN arg: LOOPHOLE[argumentList, POINTER TO CloseArguments],          res: LOOPHOLE[resultList, POINTER TO CloseResults];	CheckSessionAndVerifier[arg.session, cH.remote];        NSFile.Close[arg.file, arg.session.token];        };      ChangeControls => {        OPEN arg: LOOPHOLE[argumentList, POINTER TO ChangeControlsArguments],          res: LOOPHOLE[resultList, POINTER TO ChangeControlsResults];	controls: NSFile.Controls;	controlSelections: NSFile.ControlSelections;	CheckSessionAndVerifier[arg.session, cH.remote];	[controls, controlSelections] _ DecodeControls[arg.controls];        NSFile.ChangeControls[          arg.file, controlSelections, controls, arg.session.token];        };      GetControls => {        OPEN arg: LOOPHOLE[argumentList, POINTER TO GetControlsArguments],          res: LOOPHOLE[resultList, POINTER TO GetControlsResults];	controls: NSFile.Controls;	controlSelections: NSFile.ControlSelections;	CheckSessionAndVerifier[arg.session, cH.remote];	controlSelections _ DecodeControlSelections[arg.controlSelections];        controls _ NSFile.GetControls[	  arg.file, controlSelections, arg.session.token];	res.controls _ EncodeControls[controls, controlSelections, zone];	CleanupArguments[];	[] _ results[resultParameters, FALSE ! UNWIND => {	  Courier.Free[resultParameters, zone]}];	Courier.Free[resultParameters, zone];	RETURN;        };      Retrieve => {       OPEN arg: LOOPHOLE[argumentList, POINTER TO RetrieveArguments],         res: LOOPHOLE[resultList, POINTER TO RetrieveResults];       sinkDS: NSDataStream.SinkStream;       CheckSessionAndVerifier[arg.session, cH.remote];       sinkDS _ NSDataStream.OpenSink[arg.content, cH !	  NSDataStream.Error => GOTO connectionFailed  -- needs rework! -- ];       NSFile.Retrieve[         arg.file, NSDataStream.Sink[stream[sinkDS]], arg.session.token];       EXITS 	  connectionFailed => ERROR NSFile.Error[[undefined[unimplemented]]]       };     Replace => {       OPEN arg: LOOPHOLE[argumentList, POINTER TO ReplaceArguments],         res: LOOPHOLE[resultList, POINTER TO ReplaceResults];       sourceDS: NSDataStream.SourceStream;       CheckSessionAndVerifier[arg.session, cH.remote];       sourceDS _ NSDataStream.OpenSource[arg.content, cH !	    NSDataStream.Error => GOTO connectionFailed  -- needs rework! -- ];       NSFile.Replace[         arg.file, NSDataStream.Source[stream[sourceDS]],	 arg.attributes, arg.session.token];       EXITS 	  connectionFailed => ERROR NSFile.Error[[undefined[unimplemented]]]       };     Serialize => {       OPEN arg: LOOPHOLE[argumentList, POINTER TO SerializeArguments],         res: LOOPHOLE[resultList, POINTER TO SerializeResults];       sinkDS: NSDataStream.SinkStream;       CheckSessionAndVerifier[arg.session, cH.remote];       sinkDS _ NSDataStream.OpenSink[arg.serializedFile, cH !	  NSDataStream.Error => GOTO connectionFailed  -- needs rework! -- ];       NSFile.Serialize[         arg.file, NSDataStream.Sink[stream[sinkDS]], arg.session.token];       EXITS 	  connectionFailed => ERROR NSFile.Error[[undefined[unimplemented]]]       };     Store => {       OPEN arg: LOOPHOLE[argumentList, POINTER TO StoreArguments],         res: LOOPHOLE[resultList, POINTER TO StoreResults];       controls: NSFile.Controls _ DecodeControls[arg.controls].controls;       sourceDS: NSDataStream.SourceStream;       CheckSessionAndVerifier[arg.session, cH.remote];       sourceDS _ NSDataStream.OpenSource[arg.content, cH !	  NSDataStream.Error => GOTO connectionFailed  -- needs rework! -- ];       res.file _ NSFile.Store[         arg.directory, NSDataStream.Source[stream[sourceDS]], arg.attributes,	 controls, arg.session.token];       EXITS 	  connectionFailed => ERROR NSFile.Error[[undefined[unimplemented]]]       };     Deserialize => {       OPEN arg: LOOPHOLE[argumentList, POINTER TO DeserializeArguments],         res: LOOPHOLE[resultList, POINTER TO DeserializeResults];       controls: NSFile.Controls _ DecodeControls[arg.controls].controls;       sourceDS: NSDataStream.SourceStream;       CheckSessionAndVerifier[arg.session, cH.remote];       sourceDS _ NSDataStream.OpenSource[arg.serializedFile, cH !	  NSDataStream.Error => GOTO connectionFailed  -- needs rework! -- ];       res.file _ NSFile.Deserialize[         arg.directory, NSDataStream.Source[stream[sourceDS]], arg.attributes,	 controls, arg.session.token];       EXITS 	  connectionFailed => ERROR NSFile.Error[[undefined[unimplemented]]]       };      Find => {        OPEN arg: LOOPHOLE[argumentList, POINTER TO FindArguments],          res: LOOPHOLE[resultList, POINTER TO FindResults];	controls: NSFile.Controls;	scope: NSFile.Scope;	CheckSessionAndVerifier[arg.session, cH.remote];	controls _ DecodeControls[arg.controls].controls;	scope _ DecodeProtocolScope[arg.scope, zone];        [res.fileHandle] _ NSFile.Find[arg.directory, scope, controls, arg.session.token];        };      ENDCASE => ERROR Courier.NoSuchProcedureNumber;    [] _ results[      resultParameters, FALSE !      UNWIND =>        BEGIN        Courier.Free[resultParameters, zone];        END; ];    Courier.Free[resultParameters, zone];    END;  --of ENABLE    CleanupArguments[];    EXITS      argumentsError => ERROR Courier.InvalidArguments;    END;  --Dispatch    FilingDispatch: Courier.Dispatcher = {    currentDispatcher[cH, procedureNumber, arguments, results]};      -- Authentication and verifier checks    Authenticate: PUBLIC PROCEDURE [    serviceName: NSName.Name, credentials: Auth.Credentials,    verifier: Auth.Verifier, z: UNCOUNTED ZONE _ NIL]    RETURNS [initiator: NSName.Name, replyVerifier: Auth.Verifier] = {      [initiator, replyVerifier] _        authenticateProc[serviceName, credentials, verifier, z]};    CacheSessionData: PROC [    localSession: NSFile.Session, service: NSFile.Service,    credentials: Auth.Credentials] =    BEGIN    sessionData: SessionData _ Heap.systemZone.NEW[SessionDataRecord _ [      service: service,      credentials: Auth.CopyCredentials[credentials, Heap.systemZone],      startTime: System.GetGreenwichMeanTime[]]];    NSSession.SetContext[      LOOPHOLE[localSession], serverStubID, sessionData, TerminateSession,      serverStubContextID];    END;  -- of CacheSessionData    TerminateSession: NSSession.TerminationHandler = {    sessionData: SessionData _ context;    NSFile.FreeWords[sessionData.credentials.value];    IF statisticsEnabled THEN AddToSessionCount[sessionData.startTime];    Heap.systemZone.FREE[@sessionData]};    GetCredentials: PROC [localSession: NSFile.Session]    RETURNS [credentials: Auth.Credentials, service: NSFile.Service] =    BEGIN    sessionData: SessionData _ NSSession.GetContext[      LOOPHOLE[localSession], serverStubID, serverStubContextID      ! NSSession.Error => NSFile.Error[[session[sessionInvalid]]]];    RETURN [sessionData.credentials, sessionData.service];    END;  -- of GetCredentials    DefaultAuthenticateProc: NSFileControlInternal.AuthenticateProc = {    NSFile.Error[[service[cannotAuthenticate]]]};    RegisterAuthenticationProc: PUBLIC PROCEDURE [    authProc: NSFileControlInternal.AuthenticateProc] =    BEGIN    authenticateProc _ authProc;    END;  -- of RegisterAuthenticationProc    -- Validate the token and verifier of a session.  An error is raised if the check fails; otherwise this operation returns with no other side-effects.  CheckSessionAndVerifier: PROCEDURE [    session: NSFileCourier.Session, callersSE: NSFile.SystemElement] =    BEGIN    credentials: Auth.Credentials;    service: NSFile.Service;    sessionAttributes: NSSession.AttributesRef;    [credentials, service] _ GetCredentials[session.token];  -- checks validity    sessionAttributes _      NSSession.GetAttributes[LOOPHOLE[session.token], serverStubID];    IF sessionAttributes.systemElement # callersSE THEN      NSFile.Error[[session[sessionInvalid]]];    [] _ Authenticate[@service.name, credentials, session.verifier, NIL];    END;  -- of CheckSessionAndVerifier    -- Program export support    DispatcherRecord: TYPE = RECORD [    version: NSFileControl.Version,    dispatcher: Courier.Dispatcher];    dispatchers: ARRAY [0..maxDispatchers) OF DispatcherRecord _    [ [versionCurrent, FilingDispatch], [0, NIL], [0, NIL] ];  maxDispatchers: CARDINAL = 3;  validDispatchers: CARDINAL _ 1;  -- initially      RegisterDispatcher: PUBLIC PROCEDURE [  -- NSFileCourier    version: CARDINAL, dispatcher: Courier.Dispatcher] =    BEGIN    IF validDispatchers >= maxDispatchers THEN ERROR Bug[tooManyVersions];    SELECT version FROM      < protocolVersions.low => protocolVersions.low _ version;      > protocolVersions.high => protocolVersions.high _ version;      ENDCASE  -- => duplicate export! -- ;    dispatchers[validDispatchers] _ [version, dispatcher];    validDispatchers _ validDispatchers + 1;    END;  -- of RegisterDispatcher    -- NSFileCourierExtra  RegisterAlternateDispatcher: PUBLIC PROCEDURE [dispatcher: Courier.Dispatcher]    RETURNS [old: Courier.Dispatcher] =    BEGIN    old _ currentDispatcher;    currentDispatcher _ dispatcher;    END;  -- of RegisterAlternateDispatcher  -- Exporting the Remote Program (NSFileControl)    protocolVersions: PUBLIC NSFileControl.VersionRange _    [versionCurrent, versionCurrent];    ExportProtocol: PUBLIC PROCEDURE [version: NSFileControl.VersionRange] =    BEGIN    IF version = NSFileControl.allVersions THEN version _ protocolVersions;    FOR v: NSFileControl.Version IN [version.low..version.high] DO      FOR w: CARDINAL IN [0..validDispatchers) DO        IF dispatchers[w].version = v THEN {	  Courier.ExportRemoteProgram[            programNumber: NSFileCourier.programNumber, versionRange: [v, v],            dispatcher: dispatchers[w].dispatcher, serviceName: "Filing"L,            zone: Heap.systemZone, classOfService: classOfService !	      Courier.Error => IF errorCode = duplicateProgramExport		THEN --NSFileControl-- Error[duplicateExport]];	  EXIT};	REPEAT	  FINISHED => ERROR --NSFileControl-- Error[versionInvalid];        ENDLOOP;      ENDLOOP;    END;  UnexportProtocol: PUBLIC PROCEDURE[version: NSFileControl.VersionRange] =    BEGIN    IF version = NSFileControl.allVersions THEN version _ protocolVersions;    FOR v: NSFileControl.Version IN [version.low..version.high] DO      Courier.UnexportRemoteProgram[        programNumber: NSFileCourier.programNumber, versionRange: [v, v] !	      Courier.Error => IF errorCode = noSuchProgramExport		THEN --NSFileControl-- Error[noSuchExport]];      ENDLOOP;    END;    -- Statistics support    On: PUBLIC PROC = {statisticsEnabled _ TRUE};    Off: PUBLIC PROC = {statisticsEnabled _ FALSE};    Reset: PUBLIC PROC = {    operationStats _ ALL[0];    sessionDurationSum _ 0;    sessionStats _ [0, 0, 0, 0]};    -- Exports to NSFileCourierStatsInternal    AddToOperationCount: PUBLIC PROC [operation: Operation] = {    operationStats[operation] _ operationStats[operation] + 1};    AddToSessionCount: PUBLIC PROC [startTime: System.GreenwichMeanTime] = {    duration: LONG CARDINAL =      System.SecondsSinceEpoch[System.GetGreenwichMeanTime[]] -        System.SecondsSinceEpoch[startTime];    IF sessionStats.minimum = 0 OR duration < sessionStats.minimum THEN      sessionStats.minimum _ duration;    IF sessionStats.maximum = 0 OR duration > sessionStats.maximum THEN      sessionStats.maximum _ duration;    sessionStats.count _ sessionStats.count + 1;    sessionDurationSum _ sessionDurationSum + duration;    sessionStats.average _ sessionDurationSum / sessionStats.count};  --  Module Initialization    Init: PROC = {    authenticateProc _ DefaultAuthenticateProc;    Reset[];    };    Init[];  END.LOG (date - person - action)- - - - SERVICES 8.0 - - - -November 16, 1983 - Hanzel - Initial conversion to Services 8.0 and Klamath Courier.November 28, 1983 - Hanzel - Complete first-round accommodation of new authentication and session mechanisms.December 1, 1983 - Hanzel - Piggyback server stub data off local session (import FilingSession.clientID).December 2, 1983 - Hanzel - Call CacheCredentials in Logon! Work around NSSession bug (AR 5060) in CheckSessionAndVerifier.December 6, 1983 - Remove workaround for NSSession bug (AR 5060) in CheckSessionAndVerifier.December 13, 1983 - Hanzel - Support export of old protocol versions; rework export and unexport mechanisms.19-Dec-83 15:05:17 - Ciccone - Revised Authenticate to include serviceName parameter.December 19, 1983 - Hanzel - Cache service to accommodate change to authenticate mechanism.19-Dec-83 15:54:01 - Ciccone - Imported clientID from NSFileControlInternal instead of FilingSession.December 26, 1983 - Hanzel - Elimintate dependency on NSFileCourier5; add implementation for RegisterDispatcher; change classOfService to bulk.December 28, 1983 - Hanzel - Don't request "isTemporary" for client in List since this is known positively to always be false; also don't permit the client to do himself (performance) harm by requesting "isTemporary" in List.December 29, 1983 - Hanzel - Fix CheckSessionAndVerifier so that "invalidSession" is reported correctly.January 5, 1984 - Hanzel - Correct for 8.0d changes.January 6, 1984 - Hanzel - Be prepare for stream abort even within Cleanup in List.January 12, 1984 - Hanzel - Add implementation of statistics-gathering; raise appropriate NSFileControl errors during ExportProgram and UnexportProgram; fix handling of validDispatchers in RegisterDispatcher.January 23, 1984 - Hanzel - Don't FreeVerifier before results are returned in Logon.February 2, 1984 - Hanzel - Correct handling of max/min session duration times (the two stats were exactly reversed).February 16, 1984 - Hanzel - Make session minimum statistic gathering correct.March 5, 1984 - Hanzel - Properly cache service in Logon to maintain valid session attribute (AR 5905).March 12, 1984 - Hanzel - Fix storage leak in TerminateSession (session context data was not freed properly).May 29, 1985 - Hanzel - Catch Auth.AuthenticationError and Auth.CallError directly; fixes AR 8165 for 8.0m.  Validate incoming procedure number properly to fix AR 7949; also fix 7950 while at it.
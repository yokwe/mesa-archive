-- File: NSFileCourierClientImpl.mesa - last edit:-- Hanzel.ES           11-Sep-87  7:58:33-- Mita.ES             11-May-87 18:59:04-- Copyright (C) 1981, 1982, 1983, 1984, 1985, 1986, 1987 by Xerox Corporation. All rights reserved.<<To do:  Remove work-around for AR 9908 in LogonDirect.  Redefine and use ResolveServiceAddress to benefit stub-only clients.>>DIRECTORY  Auth USING [    CallError, CheckOutCredentials, CheckOutNextVerifier, ConversationHandle,    CopyIdentity, Credentials, FreeIdentity, FreeVerifier, Initiate,    ReplyVerifierChecks, Terminate, Verifier],  Courier USING [    Call, Error, ErrorCode, Free, Handle, RemoteErrorSignalled, VersionMismatch],  Environment USING [bytesPerPage],  HandleManager USING [    CreateHandle, DestroyHandle, Error, GetCache, Handle, Initialize, Object],  Heap USING [Create, FreeNode],  Inline USING [LowHalf],  NSAssignedTypes USING [checksum, subtreeSizeLimit],  NSDataStream USING [    Abort, Aborted, AnnounceStream, CancelTicket, OperateOnSink, OperateOnSource,    Register, Sink, SinkStream, SourceStream],  NSFile USING [    Access, Attribute, AttributeList, Attributes, AttributesProc,    AttributesRecord, Controls, ControlSelections, Error, ErrorRecord, ErrorType,    Handle, Identity, Lock, noControlSelections, nullSession, nullSystemElement, Reference, Scope,    Selections, Service, Session, Sink, Source, SystemElement, Timeout, Type],  NSFileCourier,  --USING about everything  NSFilingGlobal USING [CacheService, ResolveServiceAddress, NullifyAttributes];NSFileCourierClientImpl: MONITOR  IMPORTS    Auth, Courier, HandleManager, Heap, Inline, NSDataStream, NSFile,    NSFileCourier, NSFilingGlobal  EXPORTS NSFile  SHARES NSFileCourier =  BEGIN OPEN NSFileCourier;  -- Types  SessionData: TYPE = LONG POINTER TO SessionDataRecord;  SessionDataRecord: TYPE = RECORD [    remoteSession: NSFile.Session,    identity: NSFile.Identity,    service: NSFile.Service,    conversation: Auth.ConversationHandle,    callInProgress, logoffInProgress: BOOLEAN,    connections: Connections];  -- cached list of Courier handles for this session  Connections: TYPE = LONG POINTER TO Connection;  Connection: TYPE = RECORD [    handle: Courier.Handle, inUse: BOOLEAN, next: Connections];  RemoteSession: TYPE = NSFileCourier.Session;  Status: TYPE = {normal, courierError, nsFileError};  -- data transfer status  -- Module data  Bug: ERROR [BugType] = CODE;  BugType: TYPE = {invalidConnection};    sessionRelease: CONDITION;  sessionManagerObject: HandleManager.Object;  sessionZone: UNCOUNTED ZONE;  -- see Init[]    ctVerifierErrors: LONG CARDINAL;  -- see Init[]  --  Remote Procedures  LogonDirect: PUBLIC PROCEDURE [    identity: NSFile.Identity, service: NSFile.Service]    RETURNS [session: NSFile.Session] =    BEGIN    arguments: LogonArguments;    connection: Courier.Handle;    conversation: Auth.ConversationHandle;    idtyCopy: NSFile.Identity _ Auth.CopyIdentity[identity, sessionZone];    results: LogonResults;    -- This operation is unique in that it is the only operation within the client stub which cannot rely on the session-based cache of Courier handles (the session does not yet exist!).    BEGIN    ENABLE UNWIND => Auth.FreeIdentity[@idtyCopy, sessionZone];    conversation _ Auth.Initiate[      idtyCopy, @service.name, service.systemElement.host, sessionZone !      Auth.CallError =>        SELECT reason FROM          badKey => ERROR NSFile.Error[[authentication[credentialsInvalid]]];          tooBusy => ERROR NSFile.Error[[authentication[tooBusy]]];          cannotReachAS => ERROR NSFile.Error[[authentication[cannotReachAS]]];          keysUnavailable =>            ERROR NSFile.Error[[authentication[keysUnavailable]]];          strongKeyDoesNotExist =>            ERROR NSFile.Error[[authentication[strongKeyDoesNotExist]]];          simpleKeyDoesNotExist =>            ERROR NSFile.Error[[authentication[simpleKeyDoesNotExist]]];          ENDCASE =>  -- other --            ERROR NSFile.Error[[authentication[other]]]];    arguments _ [      service.name, Auth.CheckOutCredentials[conversation],      Auth.CheckOutNextVerifier[conversation]];    connection _ CreateCourierHandle[service.systemElement];    BEGIN    ENABLE      UNWIND => {        DeleteCourierHandle[connection];        Auth.Terminate[@conversation, sessionZone]};	    serviceRetried: BOOLEAN _ FALSE;    -- AR4580: ReResolveService is new for this fix.    ReResolveService: PROC = {      serviceRetried ¬ TRUE;      service.systemElement ¬ NSFile.nullSystemElement;  -- nulled in cache      [] ¬ NSFilingGlobal.ResolveServiceAddress[service, identity]; --Note that NSFilingControlBImpl has fixed ResolveAndCacheService      DeleteCourierHandle [connection];      connection ¬ CreateCourierHandle [service.systemElement]};        Call[      RemoteProcedureIndex[Logon], @arguments, @results, NSFile.nullSession,      connection ! -- work-around for AR 9908 --      Courier.Error =>        IF ~serviceRetried THEN {ReResolveService[]; RETRY}        ELSE REJECT;      NSFile.Error => {IF error = [session [sessionInvalid]] THEN        NSFile.Error[[authentication[credentialsInvalid]]];      IF ~serviceRetried THEN {ReResolveService[]; RETRY} ELSE REJECT};];    IF ~Auth.ReplyVerifierChecks[conversation, results.session.verifier]      THEN NSFile.Error[[authentication[other --verifierInvalid?--]]];    END;    END;    session _ CreateSession[      service, results.session.token, idtyCopy, conversation, connection];    Courier.Free[[@results, procedureDescriptions[Logon].results], zone];    END;  -- of LogonDirect  Logoff: PUBLIC PROCEDURE [session: NSFile.Session] =    BEGIN    arguments: LogoffArguments;    results: LogoffResults;    connection: Courier.Handle _ GetCourierHandle[session, TRUE];    sessionData: RemoteSession = GetRemoteSession[session];    arguments _ [sessionData];    BEGIN OPEN sessionData;    ENABLE UNWIND => ReleaseCourierHandle[session, connection, TRUE];    Call[RemoteProcedureIndex[Logoff], @arguments, @results, session, connection];    END;    ReleaseCourierHandle[session, connection, TRUE];    END;  -- of Logoff  Probe: PUBLIC PROCEDURE [session: NSFile.Session] RETURNS [CARDINAL] =    BEGIN    arguments: ProbeArguments;    results: ProbeResults;    sessionData: RemoteSession = GetRemoteSession[session];    arguments _ [sessionData];    Call[RemoteProcedureIndex[Probe], @arguments, @results, session];    RETURN[results.probeWithin];    END;  -- of Probe  Create: PUBLIC PROCEDURE [    directory: NSFile.Handle, attributes: NSFile.AttributeList,    controls: NSFile.Controls, session: NSFile.Session]    RETURNS [file: NSFile.Handle] =    BEGIN    controlsList: ControlsList _ EncodeControls[      controls, NSFile.noControlSelections, zone];    arguments: CreateArguments;    results: CreateResults;    sessionData: RemoteSession = GetRemoteSession[session];    CorrectSizeInPages[attributes];    BEGIN    ENABLE UNWIND => FreeControls[controlsList, zone];    arguments _ [directory, attributes, controlsList, sessionData];    Call[RemoteProcedureIndex[Create], @arguments, @results, session];    END;    FreeControls[controlsList, zone];    RETURN[results.file];    END;  Copy: PUBLIC PROCEDURE [    file: NSFile.Handle, destination: NSFile.Handle,    attributes: NSFile.AttributeList, controls: NSFile.Controls,    session: NSFile.Session] RETURNS [newFile: NSFile.Handle] =    BEGIN    controlsList: ControlsList _ EncodeControls[      controls, NSFile.noControlSelections, zone];    arguments: CopyArguments;    results: CopyResults;    sessionData: RemoteSession = GetRemoteSession[session];    BEGIN    ENABLE UNWIND => FreeControls[controlsList, zone];    arguments _ [file, destination, attributes, controlsList, sessionData];    [] _ Call[RemoteProcedureIndex[Copy], @arguments, @results, session];    END;    FreeControls[controlsList, zone];    RETURN[results.newFile];    END;  Move: PUBLIC PROCEDURE [    file: NSFile.Handle, destination: NSFile.Handle,    attributes: NSFile.AttributeList, session: NSFile.Session] RETURNS [] =    BEGIN    arguments: MoveArguments;    results: MoveResults;    sessionData: RemoteSession = GetRemoteSession[session];    arguments _ [file, destination, attributes, sessionData];    Call[RemoteProcedureIndex[Move], @arguments, @results, session];    END;  Delete: PUBLIC PROCEDURE [file: NSFile.Handle, session: NSFile.Session]    RETURNS [] =    BEGIN    arguments: DeleteArguments;    results: DeleteResults;    sessionData: RemoteSession = GetRemoteSession[session];    arguments _ [file, sessionData];    Call[RemoteProcedureIndex[Delete], @arguments, @results, session];    END;  List: PUBLIC PROCEDURE [    directory: NSFile.Handle, proc: NSFile.AttributesProc,    selections: NSFile.Selections, scope: NSFile.Scope, clientData: LONG POINTER,    session: NSFile.Session] RETURNS [] =    BEGIN    ListProc: PROC [sourceDS: NSDataStream.SourceStream] =      BEGIN      attributes: NSFile.AttributesRecord;      StreamOfAttributeListProc: AttributeListProc        -- [list: NSFile.AttributeList] RETURNS [continue: BOOLEAN _ TRUE] --  =        BEGIN        CleanUp: PROC = {          IF BASE[attributes.extended] # NIL THEN {            Heap.FreeNode[zone, BASE[attributes.extended]];            attributes.extended _ NIL}};        DecodeAttributes[from: list, to: @attributes, zone: zone];	IF selections.interpreted[subtreeSize] AND ~attributes.isDirectory THEN	  attributes.subtreeSize _ attributes.sizeInPages;        IF selections.interpreted[service] THEN  -- not returned remotely          attributes.service _ GetService[session];        IF ~proc[@attributes, clientData ! UNWIND => CleanUp[]] THEN {          continue _ FALSE; NSDataStream.Abort[sourceDS]};        CleanUp[];        END;  -- of StreamOfAttributeListProc      NSFilingGlobal.NullifyAttributes[@attributes];      DeserializeStreamOfAttributeSequence[        StreamOfAttributeListProc, sourceDS !        UNWIND => sourceDS.delete[sourceDS ! NSDataStream.Aborted => CONTINUE]];      sourceDS.delete[sourceDS ! NSDataStream.Aborted => CONTINUE];      END;  -- of ListProc    ListByStream[[proc[ListProc]], directory, proc, selections, scope, session];    END;  -- of List  ListByStream: PROCEDURE [    sink: NSDataStream.Sink, directory: NSFile.Handle,    proc: NSFile.AttributesProc, selections: NSFile.Selections,    scope: NSFile.Scope, session: NSFile.Session] =    BEGIN    arguments: ListArguments;    cleanedUp: BOOLEAN _ FALSE;    connection: Courier.Handle _ GetCourierHandle[session];    results: ListResults;    scopes: ScopeList _ EncodeScope[@scope, zone];    sels: AttributeTypeList;    -- Error reporting    courierErrorCode: Courier.ErrorCode;    nsFileError: NSFile.ErrorRecord;    status: Status _ normal;        CleanUp: PROC = {      IF cleanedUp THEN RETURN;      cleanedUp _ TRUE;      FreeProtocolScope[scopes, zone];      FreeAttributeTypeList[sels, zone];      ReleaseCourierHandle[session, connection]};    ListByStreamProc: PROC [sinkDS: NSDataStream.SinkStream] =      BEGIN      ENABLE {        Courier.Error => {          status _ courierError; courierErrorCode _ errorCode; CONTINUE};        NSFile.Error => {status _ nsFileError; nsFileError _ error; CONTINUE}};      arguments _ [        directory, sels, scopes,        NSDataStream.Register[sinkDS, connection.remote, connection, TRUE],        GetRemoteSession[session]];      Call[        RemoteProcedureIndex[List], @arguments, @results, session, connection !        Courier.Error =>          NSDataStream.CancelTicket[arguments.listing, connection]];      END;  -- of ListByStreamProc    IF selections.interpreted[subtreeSize] THEN  -- handle non-directories      selections.interpreted[isDirectory] _        selections.interpreted[sizeInPages] _ TRUE;    sels _ EncodeSelections[selections, zone];    NSDataStream.OperateOnSink[sink, ListByStreamProc !      NSDataStream.Aborted => {        status _ nsFileError; nsFileError _ [transfer[aborted]]; CONTINUE};      UNWIND => CleanUp[]];    CleanUp[];    IF status # normal THEN      ReportErrorStatus[status, nsFileError, courierErrorCode];    END;  -- ListByStream  GetAttributes: PUBLIC PROCEDURE [    file: NSFile.Handle, selections: NSFile.Selections,    attributes: NSFile.Attributes, session: NSFile.Session] RETURNS [] =    BEGIN    arguments: GetAttributesArguments;    results: GetAttributesResults _ [attributes: NIL];    sels: AttributeTypeList;    sessionData: RemoteSession = GetRemoteSession[session];    IF selections.interpreted[subtreeSize] THEN  -- handle non-directories      selections.interpreted[isDirectory] _        selections.interpreted[sizeInPages] _ TRUE;    sels _ EncodeSelections[selections, zone];    BEGIN    ENABLE      UNWIND => {        FreeAttributeTypeList[sels, zone];        FreeAttributes[results.attributes, zone]};  --if error, free everything    arguments _ [file, sels, sessionData];    Call[RemoteProcedureIndex[GetAttributes], @arguments, @results, session];    NSFilingGlobal.NullifyAttributes[attributes];    DecodeAttributes[from: results.attributes, to: attributes, zone: zone];    IF selections.interpreted[subtreeSize] AND ~attributes.isDirectory THEN      attributes.subtreeSize _ attributes.sizeInPages;    END;    FreeAttributeTypeList[sels, zone];    IF BASE[results.attributes] # NIL THEN      Heap.FreeNode[zone, BASE[results.attributes]];  --DON'T free attached Strings and Words!    IF selections.interpreted[service] THEN      attributes.service _ GetService[session];    END;  GetReference: PUBLIC PROCEDURE [file: NSFile.Handle, session: NSFile.Session]    RETURNS [reference: NSFile.Reference] =    BEGIN    attributes: NSFile.AttributesRecord;    selections: NSFile.Selections _ [[fileID: TRUE]];    GetAttributes[file, selections, @attributes, session];    reference _ [fileID: attributes.fileID, service: GetService[session]];    END;  GetType: PUBLIC PROCEDURE [file: NSFile.Handle, session: NSFile.Session]    RETURNS [type: NSFile.Type] =    BEGIN    attributes: NSFile.Attributes _ zone.NEW[NSFile.AttributesRecord];    selections: NSFile.Selections _ [[type: TRUE]];    BEGIN    ENABLE UNWIND => zone.FREE[@attributes];    GetAttributes[file, selections, attributes, session];    END;    type _ attributes.type;    zone.FREE[@attributes];    END;  ChangeAttributes: PUBLIC PROCEDURE [    file: NSFile.Handle, attributes: NSFile.AttributeList,    session: NSFile.Session] RETURNS [] =    BEGIN    arguments: ChangeAttributesArguments;    results: ChangeAttributesResults;    sessionData: RemoteSession = GetRemoteSession[session];    arguments _ [file, attributes, sessionData];    Call[RemoteProcedureIndex[ChangeAttributes], @arguments, @results, session];    END;  UnifyAccessLists: PUBLIC PROCEDURE [    directory: NSFile.Handle, session: NSFile.Session] =    BEGIN    arguments: UnifyAccessListsArguments;    results: UnifyAccessListsResults;    sessionData: RemoteSession = GetRemoteSession[session];    arguments _ [directory, sessionData];    Call[RemoteProcedureIndex[UnifyAccessLists], @arguments, @results, session];    END;  Open: PUBLIC PROCEDURE [    attributes: NSFile.AttributeList, directory: NSFile.Handle,    controls: NSFile.Controls, session: NSFile.Session]    RETURNS [file: NSFile.Handle] =    BEGIN    controlsList: ControlsList _ EncodeControls[      controls, NSFile.noControlSelections, zone];    arguments: OpenArguments;    results: OpenResults;    sessionData: RemoteSession = GetRemoteSession[session];    BEGIN    ENABLE UNWIND => FreeControls[controlsList, zone];    arguments _ [attributes, directory, controlsList, sessionData];    Call[RemoteProcedureIndex[Open], @arguments, @results, session];    END;    FreeControls[controlsList, zone];    RETURN[results.file];    END;  Close: PUBLIC PROCEDURE [file: NSFile.Handle, session: NSFile.Session]    RETURNS [] =    BEGIN    arguments: CloseArguments;    results: CloseResults;    sessionData: RemoteSession = GetRemoteSession[session];    arguments _ [file, sessionData];    Call[RemoteProcedureIndex[Close], @arguments, @results, session];    END;  ChangeControls: PUBLIC PROCEDURE [    file: NSFile.Handle, controlSelections: NSFile.ControlSelections,    controls: NSFile.Controls, session: NSFile.Session] RETURNS [] =    BEGIN    controlsList: ControlsList _ EncodeControls[      controls, controlSelections, zone];    arguments: ChangeControlsArguments;    results: ChangeControlsResults;    sessionData: RemoteSession = GetRemoteSession[session];    BEGIN    ENABLE UNWIND => FreeControls[controlsList, zone];    arguments _ [file, controlsList, sessionData];    Call[RemoteProcedureIndex[ChangeControls], @arguments, @results, session];    END;    FreeControls[controlsList, zone]    END;  GetControls: PUBLIC PROCEDURE [    file: NSFile.Handle, controlSelections: NSFile.ControlSelections,    session: NSFile.Session] RETURNS [controls: NSFile.Controls] =    BEGIN    arguments: GetControlsArguments;    controlTypeList: ControlTypeList _ EncodeControlSelections[      controlSelections, zone];    results: GetControlsResults;    sessionData: RemoteSession = GetRemoteSession[session];    BEGIN    ENABLE UNWIND => FreeControlSelections[controlTypeList, zone];    arguments _ [file, controlTypeList, sessionData];    Call[RemoteProcedureIndex[GetControls], @arguments, @results, session];    END;    FreeControlSelections[controlTypeList, zone];    controls _ DecodeControls[results.controls].controls;    Courier.Free[[@results, procedureDescriptions[GetControls].results], zone];    END;  Retrieve: PUBLIC PROCEDURE [    file: NSFile.Handle, sink: NSFile.Sink, session: NSFile.Session] RETURNS [] =    BEGIN    arguments: RetrieveArguments;    results: RetrieveResults;    connection: Courier.Handle _ GetCourierHandle[session];    -- Error reporting    courierErrorCode: Courier.ErrorCode;    nsFileError: NSFile.ErrorRecord;    status: Status _ normal;    RetrieveProc: PROC [sinkDS: NSDataStream.SinkStream] =      BEGIN      ENABLE {        Courier.Error => {          status _ courierError; courierErrorCode _ errorCode; CONTINUE};        NSFile.Error => {status _ nsFileError; nsFileError _ error; CONTINUE}};      arguments _ [        file, NSDataStream.Register[        sinkDS, connection.remote, connection, TRUE],        GetRemoteSession[session]];      Call[        RemoteProcedureIndex[Retrieve], @arguments, @results, session, connection        !        Courier.Error =>          NSDataStream.CancelTicket[arguments.content, connection]];      END;  -- of RetrieveProc    NSDataStream.OperateOnSink[      sink, RetrieveProc ! UNWIND => ReleaseCourierHandle[session, connection]];    ReleaseCourierHandle[session, connection];    IF status # normal THEN      ReportErrorStatus[status, nsFileError, courierErrorCode];    END;  Replace: PUBLIC PROCEDURE [    file: NSFile.Handle, source: NSFile.Source, attributes: NSFile.AttributeList,    session: NSFile.Session] RETURNS [] =    BEGIN    arguments: ReplaceArguments;    results: ReplaceResults;    connection: Courier.Handle _ GetCourierHandle[session];    -- Error reporting    courierErrorCode: Courier.ErrorCode;    nsFileError: NSFile.ErrorRecord;    status: Status _ normal;    ReplaceProc: PROC [sourceDS: NSDataStream.SourceStream] =      BEGIN      ENABLE {        Courier.Error => {          status _ courierError; courierErrorCode _ errorCode; CONTINUE};        NSFile.Error => {status _ nsFileError; nsFileError _ error; CONTINUE}};      arguments _ [        file, attributes, NSDataStream.Register[        sourceDS, connection.remote, connection, TRUE],        GetRemoteSession[session]];      Call[        RemoteProcedureIndex[Replace], @arguments, @results, session, connection !        Courier.Error =>          NSDataStream.CancelTicket[arguments.content, connection]];      END;  -- of ReplaceProc    CorrectSizeInPages[attributes];    NSDataStream.OperateOnSource[      source, ReplaceProc ! UNWIND => ReleaseCourierHandle[session, connection]];    ReleaseCourierHandle[session, connection];    IF status # normal THEN      ReportErrorStatus[status, nsFileError, courierErrorCode];    END;  Serialize: PUBLIC PROCEDURE [    file: NSFile.Handle, sink: NSFile.Sink, session: NSFile.Session] =    BEGIN    arguments: SerializeArguments;    results: SerializeResults;    connection: Courier.Handle _ GetCourierHandle[session];    -- Error reporting    courierErrorCode: Courier.ErrorCode;    nsFileError: NSFile.ErrorRecord;    status: Status _ normal;    SerializeProc: PROC [sinkDS: NSDataStream.SinkStream] =      BEGIN      ENABLE {        Courier.Error => {          status _ courierError; courierErrorCode _ errorCode; CONTINUE};        NSFile.Error => {status _ nsFileError; nsFileError _ error; CONTINUE}};      arguments _ [        file, NSDataStream.Register[        sinkDS, connection.remote, connection, TRUE],        GetRemoteSession[session]];      Call[        RemoteProcedureIndex[Serialize], @arguments, @results, session, connection        !        Courier.Error =>          NSDataStream.CancelTicket[arguments.serializedFile, connection]];      END;  -- SerializeProc    NSDataStream.OperateOnSink[      sink, SerializeProc ! UNWIND => ReleaseCourierHandle[session, connection]];    ReleaseCourierHandle[session, connection];    IF status # normal THEN      ReportErrorStatus[status, nsFileError, courierErrorCode];    END;  Store: PUBLIC PROCEDURE [    directory: NSFile.Handle, source: NSFile.Source,    attributes: NSFile.AttributeList, controls: NSFile.Controls,    session: NSFile.Session] RETURNS [file: NSFile.Handle] =    BEGIN    controlsList: ControlsList _ EncodeControls[      controls, NSFile.noControlSelections, zone];    arguments: StoreArguments;    results: StoreResults;    connection: Courier.Handle _ GetCourierHandle[session];    -- Error reporting    courierErrorCode: Courier.ErrorCode;    nsFileError: NSFile.ErrorRecord;    status: Status _ normal;    StoreProc: PROC [sourceDS: NSDataStream.SourceStream] =      BEGIN      ENABLE {        Courier.Error => {          status _ courierError; courierErrorCode _ errorCode; CONTINUE};        NSFile.Error => {status _ nsFileError; nsFileError _ error; CONTINUE}};      arguments _ [        directory, attributes, controlsList, NSDataStream.Register[        sourceDS, connection.remote, connection, TRUE],        GetRemoteSession[session]];      Call[        RemoteProcedureIndex[Store], @arguments, @results, session, connection !        Courier.Error =>          NSDataStream.CancelTicket[arguments.content, connection]];      END;  -- of StoreProc     CorrectSizeInPages[attributes];    NSDataStream.OperateOnSource[      source, StoreProc !      UNWIND => {        FreeControls[controlsList, zone];        ReleaseCourierHandle[session, connection]}];    FreeControls[controlsList, zone];    ReleaseCourierHandle[session, connection];    IF status # normal THEN      ReportErrorStatus[status, nsFileError, courierErrorCode];    RETURN[results.file];    END;  Deserialize: PUBLIC PROCEDURE [    directory: NSFile.Handle, source: NSFile.Source,    attributes: NSFile.AttributeList, controls: NSFile.Controls,    session: NSFile.Session] RETURNS [file: NSFile.Handle] =    BEGIN    controlsList: ControlsList _ EncodeControls[      controls, NSFile.noControlSelections, zone];    arguments: DeserializeArguments;    results: DeserializeResults;    connection: Courier.Handle _ GetCourierHandle[session];    -- Error reporting    courierErrorCode: Courier.ErrorCode;    nsFileError: NSFile.ErrorRecord;    status: Status _ normal;    DeserializeProc: PROC [sourceDS: NSDataStream.SourceStream] =      BEGIN      ENABLE {        Courier.Error => {          status _ courierError; courierErrorCode _ errorCode; CONTINUE};        NSFile.Error => {status _ nsFileError; nsFileError _ error; CONTINUE}};      arguments _ [        directory, attributes, controlsList, NSDataStream.Register[        sourceDS, connection.remote, connection, TRUE],        GetRemoteSession[session]];      Call[        RemoteProcedureIndex[Deserialize], @arguments, @results, session,        connection ! Courier.Error =>	  NSDataStream.CancelTicket[arguments.serializedFile, connection]];      END;  -- DeserializeProc    NSDataStream.OperateOnSource[      source, DeserializeProc !      UNWIND => {        FreeControls[controlsList, zone];        ReleaseCourierHandle[session, connection]}];    FreeControls[controlsList, zone];    ReleaseCourierHandle[session, connection];    IF status # normal THEN      ReportErrorStatus[status, nsFileError, courierErrorCode];    RETURN[results.file];    END;  Find: PUBLIC PROCEDURE [    directory: NSFile.Handle, scope: NSFile.Scope, controls: NSFile.Controls,    session: NSFile.Session] RETURNS [NSFile.Handle] =    BEGIN    controlsList: ControlsList _ EncodeControls[      controls, NSFile.noControlSelections, zone];    arguments: FindArguments;    results: FindResults;    scopes: ScopeList _ EncodeScope[@scope, zone];    sessionData: RemoteSession = GetRemoteSession[session];    BEGIN    ENABLE      UNWIND => {        FreeControls[controlsList, zone]; FreeProtocolScope[scopes, zone]};    arguments _ [directory, scopes, controlsList, sessionData];    Call[RemoteProcedureIndex[Find], @arguments, @results, session];    END;    FreeControls[controlsList, zone];    FreeProtocolScope[scopes, zone];    RETURN[results.fileHandle];    END;  -- Utilities  -- Be nice to the Filing 5 servers (specify dataSize not storedSize)  CorrectSizeInPages: PROC [attributeList: NSFile.AttributeList] =    BEGIN    FOR i: CARDINAL IN [0..LENGTH[attributeList]) DO      WITH size: attributeList[i] SELECT FROM        sizeInPages => {	  attributeList[i] _ [	    sizeInBytes[size.value * Environment.bytesPerPage]];	  EXIT};	ENDCASE;      ENDLOOP;    END;  -- of CorrectSizeInPages  --  Obtain a fresh Courier handle for this session; "logoff" is used to denote an in-progress Logoff operation; any other client invoking this operation before the Logoff operation has completed will receive the error, NSFile.Error[[service[sessionInUse]]].  GetCourierHandle: ENTRY PROC [session: NSFile.Session, logoff: BOOLEAN _ FALSE]    RETURNS [handle: Courier.Handle] =    BEGIN ENABLE UNWIND => NULL;    sData: SessionData _ GetSessionData[session];    IF sData.logoffInProgress THEN NSFile.Error[[service[sessionInUse]]];    sData.logoffInProgress _ logoff;    FOR con: Connections _ sData.connections, con.next WHILE con # NIL DO      IF ~con.inUse THEN {con.inUse _ TRUE; RETURN[con.handle]}; ENDLOOP;    handle _ CreateCourierHandle[sData.service.systemElement];    sData.connections _ sessionZone.NEW[      Connection _ [handle: handle, inUse: TRUE, next: sData.connections]];    END;  -- of GetCourierHandle  -- Relinquish a Courier connection for possible future use by this session.  ReleaseCourierHandle: ENTRY PROC [    session: NSFile.Session, handle: Courier.Handle, logoff: BOOLEAN ¬ FALSE] =    BEGIN ENABLE UNWIND => NULL;    sData: SessionData _ GetSessionData[session];    FOR con: Connections _ sData.connections, con.next WHILE con # NIL DO      IF con.handle = handle THEN {con.inUse _ FALSE; EXIT}      REPEAT FINISHED => ERROR Bug[invalidConnection];      ENDLOOP;    IF logoff THEN DestroySession[session];    END;  -- of ReleaseCourierHandle  -- Session creation/destruction  -- Establish session data for a new client session; "service" is the service with which the new "session" has been established; "conversation" is to be used during interactions with the remote host; "connection" is to be cached for future use; "zone" identifies the zone from which the conversation handle and other data is allocated.  CreateSession: PROCEDURE [    service: NSFile.Service, remoteSession: NSFile.Session,    identity: NSFile.Identity, conversation: Auth.ConversationHandle,    connection: Courier.Handle] RETURNS [NSFile.Session] =    BEGIN    handle: HandleManager.Handle;    sData: SessionData;    [handle, sData] _ HandleManager.CreateHandle[      SIZE[SessionDataRecord], @sessionManagerObject];    sData^ _ [      remoteSession: remoteSession, service: NSFilingGlobal.CacheService[service],      identity: identity, conversation: conversation, callInProgress: FALSE,      logoffInProgress: FALSE, connections: sessionZone.NEW[        Connection _ [handle: connection, inUse: FALSE, next: NIL]]];    RETURN[LOOPHOLE[handle]];    END;  -- of CreateSession  -- Release all resources associated with the given session.  DestroySession: PROCEDURE [session: NSFile.Session] =    BEGIN    connTemp, connNext: Connections;    sData: SessionData _ GetSessionData[session];    -- destroy cached connections    connNext _ sData.connections;    WHILE connNext # NIL DO      connTemp _ connNext;      connNext _ connNext.next;      DeleteCourierHandle[connTemp.handle];      sessionZone.FREE[@connTemp];      ENDLOOP;    Auth.Terminate[@sData.conversation, sessionZone];    Auth.FreeIdentity[@sData.identity, sessionZone];    HandleManager.DestroyHandle[LOOPHOLE[session], @sessionManagerObject];    END;  -- of DestroySession  -- Return session information required to make a remote call (the session from the remote service and an appropriate verifier).  GetRemoteSession: ENTRY PROC [session: NSFile.Session]    RETURNS [remoteSession: RemoteSession] =    BEGIN ENABLE UNWIND => NULL;    sData: SessionData _ GetSessionData[session];    remoteSession.token _ sData.remoteSession;    WHILE sData.callInProgress DO WAIT sessionRelease; ENDLOOP;    remoteSession.verifier _ Auth.CheckOutNextVerifier[sData.conversation];    sData.callInProgress _ TRUE;    END;  -- of GetRemoteSession  CheckReplyVerifier: PROC [session: NSFile.Session, verifier: Auth.Verifier]    RETURNS [BOOLEAN] = INLINE {    RETURN[      TRUE  -- until real auth        --Auth.ReplyVerifierChecks[GetSessionData[session].conversation, verifier]--        ]};  FreeVerifier: PROC [verifier: Auth.Verifier] = INLINE {    Auth.FreeVerifier[@verifier, sessionZone]};  -- Obtain the service with which this session is interacting.  GetService: PROCEDURE [session: NSFile.Session]    RETURNS [service: NSFile.Service] =    BEGIN RETURN[GetSessionData[session].service]; END;  -- of GetService  GetSessionData: PROC [session: NSFile.Session] RETURNS [SessionData] =    BEGIN    RETURN[      HandleManager.GetCache[        LOOPHOLE[session], @sessionManagerObject !        HandleManager.Error => NSFile.Error[[session[sessionInvalid]]]]];    END;  -- of GetSessionData  ReportErrorStatus: PROCEDURE [    s: Status, nsFile: NSFile.ErrorRecord, courierCode: Courier.ErrorCode] =    BEGIN    SELECT s FROM      nsFileError => ERROR NSFile.Error[nsFile];      courierError => ERROR Courier.Error[courierCode];      ENDCASE => ERROR;  -- inappropriate error status    END;  --  Remote Call Handler  procedureDescriptions: RemoteProcedureDescriptionsHandle =    GetRemoteProcedureDescriptions[];  errorDescriptions: RemoteErrorDescriptionsHandle = GetRemoteErrorDescriptions[];  callTimeout: LONG CARDINAL _ LAST[LONG CARDINAL];  GetNSFileErrorArguments: PROCEDURE [    error: RemoteErrorIndex, argumentList: POINTER TO GenericArgumentRecord]    RETURNS [arguments: NSFile.ErrorRecord] =    BEGIN    SELECT error FROM      AccessError => {        OPEN arg: LOOPHOLE[argumentList, POINTER TO AccessErrorArguments];        arguments _ [access[arg.problem]];        };      AttributeTypeError => {        OPEN arg: LOOPHOLE[argumentList, POINTER TO AttributeTypeErrorArguments];        arguments _          IF arg.type IN          [NSAssignedTypes.checksum..NSAssignedTypes.subtreeSizeLimit] THEN [          attributeType[problem: arg.problem, type: Inline.LowHalf[arg.type]]]          ELSE [            attributeType[            problem: arg.problem, type: extended, extendedType: arg.type]];        };      AttributeValueError => {        OPEN arg: LOOPHOLE[argumentList, POINTER TO AttributeValueErrorArguments];        arguments _          IF arg.type IN          [NSAssignedTypes.checksum..NSAssignedTypes.subtreeSizeLimit] THEN [          attributeValue[problem: arg.problem, type: Inline.LowHalf[arg.type]]]          ELSE [            attributeValue[            problem: arg.problem, type: extended, extendedType: arg.type]];        };      AuthenticationError => {        OPEN arg: LOOPHOLE[argumentList, POINTER TO AuthenticationErrorArguments];        SELECT arg.problem FROM          credentialsInvalid => arguments _ [authentication[credentialsInvalid]];          verifierInvalid, verifierExpired, verifierReused => {	    ctVerifierErrors _ ctVerifierErrors + 1;	    arguments _ [session[sessionInvalid]]};	  credentialsExpired =>            arguments _ [session[sessionInvalid]];          inappropriateCredentials =>  -- stub error --            arguments _ [authentication[other]];          ENDCASE => arguments _ [authentication[other]];        };      ConnectionError => {        OPEN arg: LOOPHOLE[argumentList, POINTER TO ConnectionErrorArguments];        arguments _ [connection[arg.problem]];        };      ControlTypeError => {        OPEN arg: LOOPHOLE[argumentList, POINTER TO ControlTypeErrorArguments];        arguments _ [controlType[arg.problem, arg.type]];        };      ControlValueError => {        OPEN arg: LOOPHOLE[argumentList, POINTER TO ControlValueErrorArguments];        arguments _ [controlValue[arg.problem, arg.type]];        };      HandleError => {        OPEN arg: LOOPHOLE[argumentList, POINTER TO HandleErrorArguments];        arguments _ [handle[arg.problem]];        };      InsertionError => {        OPEN arg: LOOPHOLE[argumentList, POINTER TO InsertionErrorArguments];        arguments _ [insertion[arg.problem]];        };      ScopeTypeError => {        OPEN arg: LOOPHOLE[argumentList, POINTER TO ScopeTypeErrorArguments];        arguments _ [scopeType[arg.problem, arg.type]];        };      ScopeValueError => {        OPEN arg: LOOPHOLE[argumentList, POINTER TO ScopeValueErrorArguments];        arguments _ [scopeValue[arg.problem, arg.type]];        };      ServiceError => {        OPEN arg: LOOPHOLE[argumentList, POINTER TO ServiceErrorArguments];        arguments _ [service[arg.problem]];        };      SessionError => {        OPEN arg: LOOPHOLE[argumentList, POINTER TO SessionErrorArguments];        arguments _ [session[arg.problem]];        };      SpaceError => {        OPEN arg: LOOPHOLE[argumentList, POINTER TO SpaceErrorArguments];        arguments _ [space[arg.problem]];        };      TransferError => {        OPEN arg: LOOPHOLE[argumentList, POINTER TO TransferErrorArguments];        arguments _ [transfer[arg.problem]];        };      ENDCASE --UndefinedError-- => {        OPEN arg: LOOPHOLE[argumentList, POINTER TO UndefinedErrorArguments];        arguments _ [undefined[arg.problem]];        };    END;  -- of GetNSFileErrorArguments  Call: PROCEDURE [    procedure: RemoteProcedureIndex, argumentList, resultList: POINTER,    localSession: NSFile.Session, connection: Courier.Handle _ NIL] =    BEGIN    courierErrorCode: Courier.ErrorCode;    nsFileError: NSFile.ErrorRecord;    status: Status _ normal;          gotConnection: BOOLEAN _ FALSE;    sessionLocked: BOOLEAN _ TRUE;        StreamCheckout: PROCEDURE [cH: Courier.Handle] = {      ReleaseSession[];  -- unlock this session's conversation      IF dataStreamUsed[procedure] THEN NSDataStream.AnnounceStream[cH]};        ReleaseSession: ENTRY PROC = {  -- unlock this session's conversation      ENABLE UNWIND => NULL;      sData: SessionData;      IF sessionLocked AND localSession # NSFile.nullSession THEN {        sData _ GetSessionData[localSession];	sData.callInProgress _ FALSE;	sessionLocked _ FALSE;	BROADCAST sessionRelease};      };    IF connection = NIL THEN {      connection _ GetCourierHandle[localSession]; gotConnection _ TRUE};    [] _ Courier.Call[      cH: connection, procedureNumber: LOOPHOLE[procedure],      arguments: [      location: argumentList,      description: procedureDescriptions^[procedure].arguments],      results: [      location: resultList,      description: procedureDescriptions^[procedure].results],      timeoutInSeconds: callTimeout, requestDataStream: FALSE,      streamCheckoutProc: StreamCheckout !      Courier.Error =>        IF errorCode = transportTimeout AND ~dataStreamUsed[procedure] THEN RETRY        ELSE {status _ courierError; courierErrorCode _ errorCode; CONTINUE};      Courier.VersionMismatch => {        status _ courierError; courierErrorCode _ noSuchProgramExport; CONTINUE};      Courier.RemoteErrorSignalled        --[errorNumber: CARDINAL, arguments: Courier.Arguments]-- =>        BEGIN        error: RemoteErrorIndex;        argumentList: POINTER TO GenericArgumentRecord = @argumentListRecord;        argumentListRecord: GenericArgumentRecord;        IF errorNumber > LOOPHOLE[LAST[RemoteErrorIndex], CARDINAL] THEN REJECT;        error _ LOOPHOLE[errorNumber];        arguments[[          location: argumentList,          description: errorDescriptions^[error].arguments]];        status _ nsFileError;        nsFileError _ GetNSFileErrorArguments[error, argumentList];        CONTINUE;        END;      UNWIND => {        ReleaseSession[];        IF gotConnection THEN ReleaseCourierHandle[localSession, connection]}];    ReleaseSession[];  -- guarantee release in error situations    IF gotConnection THEN ReleaseCourierHandle[localSession, connection];    IF status # normal THEN      ReportErrorStatus[status, nsFileError, courierErrorCode];    END;  -- Call  Init: PROC = {    sessionZone _ Heap.Create[initial: 4];    HandleManager.Initialize[      initialSize: 5, growBy: 5, zone: sessionZone,      manager: @sessionManagerObject];    ctVerifierErrors _ 0};  --   Module Initialization  Init[];  END.LOG  ( date - person - action )- - - - SERVICES 8.0 - - - -November 16, 1983 - Hanzel - Initial conversion to Services 8.0 and Klamath Courier.November 30, 1983 - Hanzel - Further work on Logon, conversation management, interaction with Auth.December 1, 1983 - Hanzel - Watch what gets used from Auth until real one available.December 2, 1983 - Hanzel - Never request 'service' attribute in List, GetAttributes; don't free session data twice in DestroySession.December 6, 1983 - Hanzel - Cache client's identity to allow him to free it immediately following LogonDirect. 7-Dec-83 12:46:05 - Gleason - terminate conversations associated with identity before freeing the identity in DestroySession.January 5, 1984 - Hanzel - Update for 8.0d: use Auth.CopyIdentity, add host number argument to call on Auth.Initiate, accommodate change to authentication errors in NSFile.February 7, 1984 - Hanzel - Rework remote error handling so that Call has unwound before local error is raised; this should permit client to Logoff a remote session in a catch phrase (AR 3006); defined GetNSFileErrorArguments.March 28, 1984 - Hanzel - Enable reply verifier check in LogonDirect, move catch phrase for NSDataStream.Aborted from List.ListProc to OperateOnSink call to fix AR 6317; neaten cleanup in ListByStream.April 2, 1984 - Hanzel - Disable reply verifier check in LogonDirect until problem is resolved (between Auth and FS).April 9, 1984 - Hanzel - Use CancelTicket in catch phrase for Courier.Error in DeserializeProc to fix AR 6675.April 27, 1984 - Hanzel - Re-enable reply verifier check in LogonDirect (fixed in Auth) for 8.0k.August 13, 1984 - Hanzel - Work around authentication error handling in LogonDirect to fix AR 9908 for 8.0p; this should eventually be fixed after "verifierInvalid" is added to NSFile.AuthenticationProblem.- - - - SERVICES 8.0.12 - - - -March 3, 1987 - Hanzel - Made GetCourierHandle and ReleaseCourierHandle procs ENTRY to fix AR 5104.March 13, 1987 - Hanzel - Enhancements to avoid duplicate verifier problems: made GetRemoteSession an ENTRY proc; added 'callInProgress' mechanism to session state; added ReleaseSession and local StreamCheckout procs to Call.March 23, 1987 - Hanzel - Return a valid subtreeSize for non-directory files in GetAttributes and List; added CorrectSizeInPages to convert client-specified sizeInPages to sizeInBytes in Create, Replace, and Store.March 26, 1987- Hanzel - Avoid deadlock in 'callInProgress' mechanism in stream operations (Deserialize, Replace, Retrieve, Serialize, Store) by delaying GetRemoteSession calls.March 27, 1987 - Hanzel - Add ReleaseSession call after Courier.Call in Call to ensure that session is properly released; also move GetRemoteSession call in ListByStream to nested proc.11-May-87 17:59:15 - Mita - Pick up fix AR4580: See Service10.0 same name routine.September 11, 1987 - Hanzel - Reproduce fix for AR 6292 by adding 'logoff' BOOLEAN to ReleaseCourierHandle and using it in Logoff.
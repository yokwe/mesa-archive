-- File: RemoteExecImpl.mesa - last edit:-- WD      	13-Jul-84 18:17:51-- LGR    	15-Nov-82 14:53:13-- RKJ     	26-Jul-82 11:19:55-- CEH   	20-Jan-83 12:17:41-- BGY     	 1-Jul-85 19:36:15-- DWR     	21-Aug-85 11:47:37-- MEW		25-Sep-85 12:54:28-- Copyright (C) 1982, 1984, 1985 by Xerox Corporation. All rights reserved.DIRECTORY  Auth USING [CallError, CallProblem, ConversationHandle,     FreeIdentity, IdentityHandle, MakeIdentity],  CH USING [ConversationHandle, FreeConversationHandle,     IsMemberClosure, LookupDistinguishedName, MakeConversationHandle,     ReturnCode],  CHPIDs USING [members],  CmFile USING [Error, UserDotCmLine],  ErrMsg USING [CallProblem],  Exec USING [AddCommand, CheckAbortProc, ExecProc, FreeTokenString,     GetToken, GetTTY, Handle, LookupCommand, Object, OutputProc],  ExecInternal USING [CreateExec],  Format USING [Decimal, StringProc],  Heap USING [systemZone],  HeraldWindow USING [AppendBrokenMessage],  Inline USING [LongNumber],  NSName USING [Error, FreeName, MakeName, Name, NameFieldsFromString, String],  NSString USING [AppendToMesaString, String, StringFromMesaString],  Profile USING [GetUser, Qualify, SetDefaultDomain,     SetDefaultOrganization, SetUser],  Stream USING [DeleteProcedure, GetProcedure, Handle, Object,     PutProcedure, SendAttentionProcedure, SetSSTProcedure],  String USING [AppendString, CopyToNewString, Empty, Equivalent,     EquivalentString, StringBoundsFault],  StringLookUp USING [IsPrefix],  System USING [switches],  TelnetStream USING [AppendHostName, ConnectProc, Disconnected,     Listen, StopListening],  Time USING [AppendCurrent],  Token USING [FreeStringHandle, FreeTokenString, Handle, MaybeQuoted,     StandardFilterState, StringToHandle],  TTY USING [BackingStream, Create, Destroy, GetLine, GetPassword,     Handle, LineOverflow, PutCR, PutString, Rubout],  TTYServiceTypes USING [exec];RemoteExecImpl: PROGRAM  IMPORTS    Auth, CH, CmFile, ErrMsg, Exec, ExecInternal,     Format, Heap, HeraldWindow, NSName, NSString,    Profile, String, StringLookUp, System, Time, TelnetStream, Token,    TTY =  BEGIN   OPEN ErrMsg;      GoAway: ERROR = CODE;     -- So we can figure out that this is a NSRemoteExec TTY      dummyStream: Stream.Object;  otherQuit: Exec.ExecProc;  zone: UNCOUNTED ZONE = Heap.systemZone;  nullCH: CH.ConversationHandle ¬ [NIL, NIL];     RemoteHandle: TYPE = LONG POINTER TO Remote;  Remote: TYPE = RECORD[    machine: LONG STRING ¬ NIL,     count: CARDINAL ¬ 1,     next: RemoteHandle];    RNameList: TYPE = LONG POINTER TO AccessGroups;  AccessGroups: TYPE = RECORD[    group: LONG STRING ¬ NIL,     next: RNameList];    Hash: TYPE = LONG CARDINAL;  nullHash: Hash = 0;    maxEntries: CARDINAL = 10;  Entry: TYPE = RECORD [    name, password: Hash];  entries: ARRAY [0..maxEntries) OF Entry ¬ ALL[[nullHash, nullHash]];    remoteList: RemoteHandle ¬ NIL;  accessList: RNameList ¬ NIL;  freebie: BOOLEAN ¬ FALSE;      ProcessUserCm: PROCEDURE  =     BEGIN    s: Token.StandardFilterState ¬ [0,0];    value: LONG STRING ¬ NIL;    value ¬ CmFile.UserDotCmLine["System"L, "AccessGroups"L !       CmFile.Error => CONTINUE];    IF value # NIL THEN {      h: Token.Handle ¬ Token.StringToHandle[value];      group: LONG STRING ¬ NIL;      FOR group ¬ h.MaybeQuoted[@s], h.MaybeQuoted[@s] UNTIL group = NIL DO	  IF group[group.length-1] = ', THEN group.length ¬ group.length - 1;	  accessList ¬ zone.NEW[AccessGroups ¬ [next: accessList]];	  accessList.group ¬ zone.NEW[StringBody[group.length+42]];	  Profile.Qualify[group, accessList.group, clearinghouse];	  IF String.EquivalentString[group, "*:*:*"L] THEN freebie ¬ TRUE;	  group ¬ Token.FreeTokenString[group];	  ENDLOOP;        h ¬ Token.FreeStringHandle[h];        zone.FREE[@value]};     END;    AddToRemoteList: PROCEDURE [host: LONG STRING] =     BEGIN    FOR r: RemoteHandle ¬ remoteList, r.next UNTIL r = NIL DO      IF String.EquivalentString[host, r.machine] THEN {        r.count ¬ r.count + 1; RETURN};      ENDLOOP;    remoteList ¬ zone.NEW[Remote ¬ [      next: remoteList, machine: String.CopyToNewString[host, zone]]];    END;    RemoveFromRemoteList: PROCEDURE [host: LONG STRING] =     BEGIN    temp: RemoteHandle ¬ remoteList;    IF String.EquivalentString[host, temp.machine] THEN {      IF (temp.count ¬ temp.count - 1) # 0 THEN RETURN;       remoteList ¬ temp.next}    ELSE FOR r: RemoteHandle ¬ remoteList, r.next UNTIL r.next = NIL DO      IF String.EquivalentString[host, r.next.machine] THEN {        IF (r.next.count ¬ r.next.count - 1) # 0 THEN RETURN;        temp ¬ r.next;	r.next ¬ r.next.next;	EXIT};      ENDLOOP;    zone.FREE[@temp.machine];    zone.FREE[@temp];    END;  On: BOOLEAN ¬ FALSE;   ShowAccessList: Exec.ExecProc = {    PrintAccessList[h.OutputProc[]];    };    PrintAccessList: PROC[Write: Format.StringProc] = {    FOR temp: RNameList ¬ accessList, temp.next UNTIL temp = NIL DO      Write["  "L];      Write[temp.group];      Write["\n"L];      ENDLOOP;    Write["\n"L];    };    ChangeState: Exec.ExecProc =     BEGIN    write: Format.StringProc = Exec.OutputProc[h];    newState: BOOLEAN;    str, sw: LONG STRING;    [str, sw] ¬ Exec.GetToken[h];    sw ¬ Exec.FreeTokenString[sw];    SELECT TRUE FROM       String.EquivalentString[str, "on"L] => newState ¬ TRUE;       String.EquivalentString[str, "off"L] => newState ¬ FALSE;       ENDCASE => {         write["RemoteExec  is "L]; 	 write[IF On THEN "on" ELSE "off"L];	 RETURN};      str ¬ Exec.FreeTokenString[str];    IF On # newState THEN SELECT newState FROM      TRUE => TelnetStream.Listen[connect: CreateRemoteExec,         gapID: TTYServiceTypes.exec] ;      FALSE => TelnetStream.StopListening[gapID: TTYServiceTypes.exec];      ENDCASE;    On ¬ newState;    END;     ListConnectedHosts: Exec.ExecProc =     BEGIN    write: Format.StringProc = Exec.OutputProc[h];    write["Currently connected remote machines are:\n"L];    FOR r: RemoteHandle ¬ remoteList, r.next UNTIL r = NIL DO      write[" "L]; write[r.machine];      IF r.count # 1 THEN {        write[" ("L]; Format.Decimal[write, r.count]; write[")"L]};      write["\n"L];      ENDLOOP;    END;   Quit: Exec.ExecProc =     BEGIN    IF TTY.BackingStream[Exec.GetTTY[h]] = @dummyStream THEN ERROR GoAway;    IF otherQuit # NIL THEN outcome ¬ otherQuit[h, clientData];    outcome ¬ error;    END;    ForceLegalLogin: PROCEDURE [tty: TTY.Handle]     RETURNS [saved: LONG STRING ¬ NIL]=     BEGIN    userName: STRING ¬ [90];    userPassword: STRING ¬ [50];    id: Auth.IdentityHandle ¬ NIL;    ch: CH.ConversationHandle ¬ nullCH;    auth: Auth.CallProblem;    Write: Format.StringProc = {tty.PutString[s]};    haveUser, sameUser, ok: BOOLEAN;    HaveUser: PROCEDURE [name, password: LONG STRING] =      BEGIN      IF (haveUser ¬ password # NIL AND password.length # 0) THEN {        sameUser ¬String.EquivalentString[userName, name];	IF ~sameUser THEN {	  userName.length ¬ 0;	  String.AppendString[to: userName, from: name];	};      };      END;    FreeStuff: PROC = {      IF id # NIL THEN Auth.FreeIdentity[@id, zone]; id ¬ NIL;      IF ch # nullCH THEN CH.FreeConversationHandle[@ch, zone]; ch ¬ nullCH};    DO       ENABLE {        TTY.LineOverflow, String.StringBoundsFault => {          Write["\n Too long! "L]; LOOP};        TTY.Rubout => {Write[" XXX\n"L]; LOOP};	UNWIND => FreeStuff[]};      Write["Please Login or Quit\n"L];      userName.length ¬ 0; userPassword.length ¬ 0;      Write[">"L];      TTY.GetLine[tty, userName];      IF userName.length > 0 AND StringLookUp.IsPrefix[userName, "Quit.~"L] THEN 	ERROR ABORTED;      IF userName.length > 0 AND         StringLookUp.IsPrefix[userName, "ShowAccessList.~"L] THEN {	[] ¬ PrintAccessList[Write];	LOOP};      IF userName.length > 2 AND StringLookUp.IsPrefix[userName, "Login.~"L] THEN 	BEGIN	Write[" Name: "L];	userName.length ¬ 0;	TTY.GetLine[tty, userPassword];	Profile.Qualify[	  token: userPassword, newToken: userName, qualification: clearinghouse];	userPassword.length ¬ 0;	Write[" Password: "L];	TTY.GetPassword[tty, userPassword];	TTY.PutCR[tty];	IF freebie THEN EXIT;	IF IsInCache[userName, userPassword] THEN EXIT;	[ok, id] ¬ Authenticate[tty, userName, userPassword]; 	IF ~ok THEN LOOP;	[ch, ok, auth] ¬ CH.MakeConversationHandle[id, zone];	IF ~ok THEN {	  Write["Can't contact clearinghouse, Auth: "L];	  CallProblem[Write, auth]; Write["\n"L]; LOOP};	IF accessList = NIL THEN {PutInCache[userName, userPassword]; EXIT}	ELSE FOR temp: RNameList ¬ accessList, temp.next UNTIL temp = NIL DO	    IF IsMemberClosure[tty, ch, temp.group, userName] THEN GOTO ok;	    REPEAT	      ok => {PutInCache[userName, userPassword]; EXIT};	      FINISHED => Write["Not a member of an authorized group\n"L];	    ENDLOOP;	END;      ENDLOOP;    saved ¬ String.CopyToNewString[userName, zone];    Profile.GetUser[HaveUser, clearinghouse]; -- sets haveUser & possibly clobbers userName    IF ~haveUser THEN SetUser[tty, userName, userPassword]    ELSE  IF ~sameUser THEN {      Write[ "Not logged in because "L];      Write[ userName];      Write[ " already logged in.\n"L]};    FreeStuff[];    END;    SetUser: PROC[tty: TTY.Handle, name, pass: LONG STRING] = {    Write: Format.StringProc = {tty.PutString[s]};    nsname: NSName.Name ¬ NIL;    string: LONG STRING ¬ [50];    ok: BOOLEAN ¬ TRUE;    BEGIN    [nsname, ok] ¬ MakeNSName[Write, name];    IF ~ok THEN GOTO nope;    string.length ¬ 0;    NSString.AppendToMesaString[string, nsname.org];    Profile.SetDefaultOrganization[string];    string.length ¬ 0;    NSString.AppendToMesaString[string, nsname.domain];    Profile.SetDefaultDomain[string];    string.length ¬ 0;    NSString.AppendToMesaString[string, nsname.local];    Profile.SetUser[string, pass];    EXITS       nope => NULL;    END;    IF nsname # NIL THEN NSName.FreeName[zone, nsname];    };      Authenticate: PROC[tty: TTY.Handle, name, pass: LONG STRING]    RETURNS[ok: BOOLEAN ¬ FALSE, id: Auth.IdentityHandle ¬ NIL] = {    password: NSString.String ¬ NSString.StringFromMesaString[pass];    nsname: NSName.Name ¬ NIL;    Write: Format.StringProc = {tty.PutString[s]};    BEGIN    [nsname, ok] ¬ MakeNSName[Write, name];    IF ~ok THEN GOTO nope;    ok ¬ FALSE;    id ¬ Auth.MakeIdentity[nsname, password, zone, simple!      Auth.CallError => {	Write["Invalid login, Auth error: "L];	CallProblem[Write, reason];	Write["\n"L];	GOTO nope}];    ok ¬ TRUE;    EXITS       nope => NULL;    END;    IF nsname # NIL THEN NSName.FreeName[zone, nsname];    };      MakeNSName: PROC[Write: Format.StringProc, string: LONG STRING]    RETURNS[nsname: NSName.Name ¬ NIL, ok: BOOLEAN ¬ FALSE] = {    nsname ¬ NSName.MakeName[zone];    NSName.NameFieldsFromString[      z: zone,  destination: nsname, s: NSString.StringFromMesaString[string]!      NSName.Error => {        Write["Invalid name: "L]; 	Write[string]; Write["\n"L];	GOTO nope}];    ok ¬ TRUE;    EXITS nope => NULL;    };    IsMemberClosure: PROC[    tty: TTY.Handle, ch: CH.ConversationHandle, group, user: LONG STRING]    RETURNS[ok: BOOLEAN ¬ FALSE] = {    Write: Format.StringProc = {tty.PutString[s]};    nsgroup, nsuser, nsname: NSName.Name ¬ NIL;    ret: CH.ReturnCode;    BEGIN    IF String.Equivalent[group, user] THEN RETURN [TRUE];    [nsgroup, ok] ¬ MakeNSName[Write, group];    IF ~ok THEN GOTO nope;    [nsuser, ok] ¬ MakeNSName[Write, user];    IF ~ok THEN GOTO nope;    nsname ¬ NSName.MakeName[zone];    ret ¬ CH.LookupDistinguishedName[ch, nsuser, nsname];    IF ret.code # done THEN GOTO nope;    [ret, ok] ¬ CH.IsMemberClosure[ch, nsname, nsgroup, CHPIDs.members, NIL];    EXITS nope => NULL;    END;    IF nsname # NIL THEN NSName.FreeName[zone, nsname];    IF nsgroup # NIL THEN NSName.FreeName[zone, nsgroup];    IF nsuser # NIL THEN NSName.FreeName[zone, nsuser];    };      ComputeHash: PROCEDURE [string: LONG STRING] RETURNS [Hash] = {    temp: CARDINAL;    dummy: Inline.LongNumber;    dummy.lc ¬ 0;    IF string = NIL OR string.length = 0 THEN RETURN[nullHash];    FOR i: CARDINAL IN [0..string.length) DO      temp ¬ LOOPHOLE[string[i]];      dummy.lowbits ¬ dummy.lowbits*31 + temp;      dummy.highbits ¬ dummy.highbits + temp;      ENDLOOP;    IF dummy.lc = nullHash THEN dummy.lc ¬ nullHash + 1;    RETURN[dummy.lc]};      Promote: PROCEDURE [n: CARDINAL] = {    entry: Entry = entries[n];    FOR i: CARDINAL DECREASING IN [0..n) DO entries[i+1] ¬ entries[i] ENDLOOP;    entries[0] ¬ entry};      IsInCache: PROCEDURE [name, password: LONG STRING] RETURNS [BOOLEAN] = {    nH: Hash = ComputeHash[name];    pH: Hash = ComputeHash[password];    IF String.Empty[name] AND String.Empty[password] THEN RETURN[FALSE];    FOR i: CARDINAL IN [0..maxEntries) DO      IF entries[i].name = nH THEN {        IF entries[i].password = pH THEN {Promote[i]; RETURN[TRUE]}	ELSE RETURN[FALSE]};      ENDLOOP;    RETURN[FALSE]};        PutInCache: PROCEDURE [name, password: LONG STRING] = {    nH: Hash = ComputeHash[name];    pH: Hash = ComputeHash[password];    FOR i: CARDINAL IN [0..maxEntries) DO      IF entries[i].name = nH THEN {entries[i].password ¬ pH; Promote[i]; RETURN};      ENDLOOP;    entries[maxEntries-1] ¬ [nH, pH];    Promote[maxEntries-1]};      CreateRemoteExec: TelnetStream.ConnectProc =     BEGIN    streamClosed: BOOLEAN ¬ FALSE;    host, time, userName: LONG STRING ¬ NIL;    CheckIfDeactivated: Exec.CheckAbortProc =      {RETURN[streamClosed OR TelnetStream.Disconnected[sH]]};    tty: TTY.Handle ¬ TTY.Create[name: "RemoteExec"L, ttyImpl: sH,      backingStream: @dummyStream];    BEGIN    userName ¬ ForceLegalLogin[tty ! ABORTED => GOTO quit];  -- goto to free tty monitor    host ¬ zone.NEW[StringBody[150]];    time ¬ zone.NEW[StringBody[50]];    host.length ¬ time.length ¬ 0;    TelnetStream.AppendHostName[sH, host];    String.AppendString[host,"   "L];    String.AppendString[host, userName];    HeraldWindow.AppendBrokenMessage[      "Creating remote executive for "L, host];    Time.AppendCurrent[time, TRUE];    HeraldWindow.AppendBrokenMessage[      msg1: " at "L, msg2: time, newLine: FALSE, clearOld:FALSE];    AddToRemoteList[host];    ExecInternal.CreateExec[tty: tty, CheckIfDeactivated: CheckIfDeactivated !      GoAway => {streamClosed ¬ TRUE; CONTINUE};      ABORTED => {streamClosed ¬ TRUE; CONTINUE}];    RemoveFromRemoteList[host];    IF remoteList = NIL THEN Profile.SetUser[password: NIL];    HeraldWindow.AppendBrokenMessage[      "Destroying remote executive for "L, host];    time.length ¬ 0;    Time.AppendCurrent[time, TRUE];    HeraldWindow.AppendBrokenMessage[      msg1: " at "L, msg2: time, newLine: FALSE, clearOld:FALSE];    TTY.Destroy[tty];    EXITS quit => TTY.Destroy[tty];    END;    zone.FREE[@userName];    zone.FREE[@host];    zone.FREE[@time];    END;  Init: PROCEDURE =    BEGIN    otherQuit ¬ Exec.LookupCommand["Quit.~"L].proc;    Exec.AddCommand["ListRemoteHosts.~"L, ListConnectedHosts];    Exec.AddCommand["RemoteExec.~"L, ChangeState];    Exec.AddCommand["Quit.~"L, Quit];    Exec.AddCommand["ShowAccessList.~"L, ShowAccessList];    IF System.switches['N] = up THEN ProcessUserCm[];    TelnetStream.Listen[connect: CreateRemoteExec, gapID: TTYServiceTypes.exec];    On ¬ TRUE;    dummyStream.put ¬ DummyPut;    dummyStream.get ¬  DummyGet;    dummyStream.setSST ¬ DummySetSST;    dummyStream.sendAttention ¬ DummySendAttention;    dummyStream.delete ¬ DummyDelete;    END;    DummyPut: Stream.PutProcedure = BEGIN END;  DummyGet: Stream.GetProcedure = BEGIN END;  DummySetSST: Stream.SetSSTProcedure = BEGIN END;  DummySendAttention: Stream.SendAttentionProcedure = BEGIN END;  DummyDelete: Stream.DeleteProcedure = BEGIN END;  Init[]    END...  LOG25-Jun-84 11:26:03 BRD Remove ExportGAP call.13-Jul-84 18:08:26 BRD Fix multiple quit problem.
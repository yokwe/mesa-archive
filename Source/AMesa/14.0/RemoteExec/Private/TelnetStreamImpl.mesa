-- File: TelnetStreamImpl.mesa - last edited:-- WXD      	25-Jun-84 11:34:39-- RXJ     	  7-Oct-82 11:23:15-- LXR    	  7-Oct-82 12:49:23-- BGY     	 13-Feb-85 11:30:49-- Copyright (C) 1982, 1984 by Xerox Corporation. All rights reserved.DIRECTORY  Ascii USING [BS, CR, LF],  Format USING [NetworkAddress, StringProc],  GateStream USING [none, interrupt, mediumUp,    CreateProcedure, ValidateProcedure, Register, UnRegister],  Heap USING [systemZone],  Process USING [    Abort, EnableAborts, MsecToTicks, priorityForeground,     SetPriority, SetTimeout],  Stream USING [    Byte, defaultObject, DeleteProcedure, GetBlock,     GetByte, GetProcedure,     Handle, InvalidOperation, Object, PutBlock,    PutProcedure, SendAttention, SendAttentionProcedure,     SetInputOptions, SetSSTProcedure, SubSequenceType,    SSTChange, TimeOut, WaitAttentionProcedure, WaitForAttention],  String USING [AppendString],  TelnetStream USING [ConnectProc],  TTYConstants USING [normal, removeChars, aborted, notAborted],  System USING [NetworkAddress];TelnetStreamImpl: MONITOR LOCKS LOOPHOLE[sH, CombHandle].object.lock  USING sH: Stream.Handle  IMPORTS GateStream, Format, Heap, Process, Stream, String  EXPORTS TelnetStream =  BEGIN    BS: Stream.Byte = LOOPHOLE[Ascii.BS];  CR: Stream.Byte = LOOPHOLE[Ascii.CR];  LF: Stream.Byte = LOOPHOLE[Ascii.LF];    bufferSize: CARDINAL = 100;  binary: Stream.SubSequenceType = 200B;    Combination: TYPE = MACHINE DEPENDENT RECORD [    so: Stream.Object _ Stream.defaultObject,    object: Object];    CombHandle: TYPE = LONG POINTER TO Combination;    Object: TYPE = RECORD [    lock: MONITORLOCK,    flushing: CONDITION,    index: CARDINAL _ 0,    bs: Stream.Handle,    buffer: PACKED ARRAY [0..bufferSize) OF Stream.Byte _ NULL,    attention: PROCESS _ NIL,    flusher: PROCESS _ NIL,    attentionCount: CARDINAL _ 0,    aborted: BOOLEAN _ FALSE,    closed: BOOLEAN _ FALSE,    sentCleanup: BOOLEAN _ FALSE,    mode: Stream.Byte _ TTYConstants.normal,    modeVal: CARDINAL _ 0,    hostAddr: System.NetworkAddress];    Handle: TYPE = LONG POINTER TO Object;    HandleFromStream: PROCEDURE [sH: Stream.Handle] RETURNS [Handle] = INLINE {    RETURN[LOOPHOLE[sH + SIZE[Stream.Object]]]};    StreamFromHandle: PROCEDURE [h: Handle] RETURNS [Stream.Handle] = INLINE {    RETURN[LOOPHOLE[h - SIZE[Stream.Object]]]};    Connect: TelnetStream.ConnectProc _ NIL;    Listen: PUBLIC PROCEDURE [connect: TelnetStream.ConnectProc,    gapID: LONG CARDINAL] =    BEGIN    -- IF listener # NIL THEN PupStream.DestroyPupListener[listener]    -- ELSE PupStream.PupPackageMake[];    Connect _ connect;    GateStream.Register[gapID, FilterProc, AnswerLink];    END;          StopListening: PUBLIC PROCEDURE [gapID: LONG CARDINAL] =    BEGIN    GateStream.UnRegister[gapID];    Connect _ NIL;    END;    -- Accept any request  FilterProc: GateStream.ValidateProcedure = BEGIN END;          AnswerLink: GateStream.CreateProcedure =    BEGIN    c: CombHandle _ Heap.systemZone.NEW[      Combination _ [object:[bs: sH, hostAddr: systemElement]]];    Stream.SetInputOptions[c.object.bs,       [TRUE, FALSE, FALSE, FALSE, FALSE, FALSE]];    c.so.get _ GetBlock;    c.so.put _ PutBlock;    c.so.delete _ Delete;    c.so.sendAttention _ SendAttention;    c.so.waitAttention _ WaitAttention;    c.so.setSST _ SetSST;    c.object.attention _ FORK GetAttentions[c];    c.object.flusher _ FORK FlusherProcess[@c.so];    Stream.SendAttention[c.object.bs, GateStream.mediumUp];    Connect[@c.so];    END;     GetAttentions: PROCEDURE [c: CombHandle] =    BEGIN    DO ENABLE ABORTED => EXIT;      SELECT Stream.WaitForAttention[c.object.bs] FROM	GateStream.interrupt =>	  BEGIN          c.object.attentionCount _ c.object.attentionCount + 1;          c.object.aborted _ TRUE;	  END;	ENDCASE;      ENDLOOP;    END;  Delete: Stream.DeleteProcedure =    BEGIN    h: Handle = HandleFromStream[sH];    Process.Abort[h.attention];    Process.Abort[h.flusher];    JOIN h.attention;    JOIN h.flusher;    Heap.systemZone.FREE[@sH];    END;  GetBlock: Stream.GetProcedure =    BEGIN    h: Handle = HandleFromStream[sH];    SnarfGarbage: PROCEDURE RETURNS [byte: Stream.Byte]  = {      snarfRetries: CARDINAL _ 0;      byte _ GateStream.none;      byte _ Stream.GetByte[h.bs !          Stream.TimeOut => {	    IF (snarfRetries _ snarfRetries+1)>=10 THEN CONTINUE ELSE RETRY};          Stream.SSTChange => CONTINUE]};    DO      [bytesTransferred, why, sst] _ Stream.GetBlock[h.bs, block !         Stream.TimeOut => LOOP];      SELECT why FROM        attention => 	  IF SnarfGarbage[] = GateStream.interrupt THEN	    BEGIN	    h.attentionCount _ h.attentionCount - 1;	    LOOP;	    END	  ELSE why _ endRecord;        endOfStream =>           BEGIN          h.closed _ TRUE;	  ERROR ABORTED;	  END;	ENDCASE;      SELECT TRUE FROM        bytesTransferred = 0 => NULL;	--h.attentionCount # 0 => NULL;	ENDCASE => EXIT;       ENDLOOP;    IF sst = GateStream.none THEN sst _ 0;      END;    FlushBuffer: INTERNAL PROCEDURE [h: Handle] =    BEGIN    Stream.PutBlock[h.bs, [LOOPHOLE[@h.buffer], 0, h.index], TRUE];    h.index _ 0;    END;    FlusherProcess: ENTRY PROCEDURE [sH: Stream.Handle] =    BEGIN    h: Handle = HandleFromStream[sH];    Process.SetTimeout[@h.flushing, Process.MsecToTicks[100]];    Process.EnableAborts[@h.flushing];    Process.SetPriority[Process.priorityForeground];    DO ENABLE UNWIND => NULL;      WAIT h.flushing [!ABORTED => EXIT];      IF h.index # 0 THEN FlushBuffer[h ! ABORTED => EXIT];      ENDLOOP;    END;    PutByteInternal: INTERNAL PROCEDURE [h: Handle, b: Stream.Byte] =    BEGIN    i: CARDINAL _ h.index;    IF i >= bufferSize-1 THEN {FlushBuffer[h]; i _ 0};    h.buffer[i] _ b;    IF h.mode # binary AND b = CR THEN      {h.buffer[i + 1] _ LF; h.index _ i + 2; FlushBuffer[h]}    ELSE h.index _ i + 1;    END;    PutBlock: ENTRY Stream.PutProcedure =     BEGIN    ENABLE {ABORTED => CONTINUE; UNWIND => NULL};    h: Handle = HandleFromStream[sH];    SELECT h.mode FROM      TTYConstants.normal, binary =>         FOR i: CARDINAL IN [block.startIndex..block.stopIndexPlusOne) DO          PutByteInternal[h, block.blockPointer[i]];          ENDLOOP;      TTYConstants.removeChars =>        BEGIN	FOR i: CARDINAL IN [block.startIndex..block.stopIndexPlusOne) DO	  h.modeVal _ h.modeVal*256 + block.blockPointer[i];	  ENDLOOP;	END;      ENDCASE;    END;    SendAttention: Stream.SendAttentionProcedure = {    ENABLE UNWIND => NULL;    h: Handle = HandleFromStream[sH];    SELECT byte FROM      TTYConstants.aborted => h.aborted _ TRUE;      TTYConstants.notAborted => h.aborted _ FALSE;      ENDCASE};    WaitAttention: Stream.WaitAttentionProcedure = {    ENABLE UNWIND => NULL;    h: Handle = HandleFromStream[sH];    RETURN[IF h.aborted THEN TTYConstants.aborted ELSE TTYConstants.notAborted]};    SetSST: ENTRY Stream.SetSSTProcedure = {   ENABLE {ABORTED => CONTINUE; UNWIND => NULL};    h: Handle = HandleFromStream[sH];    IF h.mode = TTYConstants.removeChars THEN         FOR i: CARDINAL IN [0..h.modeVal) DO          PutByteInternal[h, BS]; ENDLOOP;    h.mode _ sst;    h.modeVal _ 0};    Disconnected: PUBLIC PROCEDURE [sH: Stream.Handle] RETURNS [BOOLEAN] =    BEGIN    h: Handle = HandleFromStream[sH];    IF sH.get # GetBlock THEN ERROR Stream.InvalidOperation;    RETURN[h.closed]    END;          AppendHostName: PUBLIC PROCEDURE [sH: Stream.Handle, str: LONG STRING] =    BEGIN    StringProc: Format.StringProc =      BEGIN String.AppendString[to: str, from: s] END;    h: Handle = HandleFromStream[sH];    IF sH.get # GetBlock THEN ERROR Stream.InvalidOperation;    Format.NetworkAddress[StringProc, h.hostAddr, octal];    END;      END...
-- Copyright (C) 1983, 1984, 1985  by Xerox Corporation. All rights reserved. -- File: ExecsG.mesa - last edited by:-- LGR	29-Nov-83 15:51:41-- BGY	 2-Jul-85 14:27:10DIRECTORY  Exec USING [    AddCommand, CheckForAbort, Confirm, EndOfCommandLine,     ExecProc, FreeTokenString, GetNameandPassword, GetToken,     Handle, LookupCommand, OutputProc],  ExecInternal USING [MapClientVolumeNameToID],  Format USING [CR, Line, LongNumber, StringProc, Text],  Heap USING [systemZone],  HeraldWindow USING [    BootFromFile, BootFromVolumeName, ConfirmProcType,     InvalidSwitches, ScanSwitches, switches],  PhysicalVolume USING [    AssertPilotVolume, Error, GetHandle, GetHints, GetNextDrive,     Handle, ID, maxNameLength, NeedsScavenging, nullDeviceIndex, Offline],  Process USING [Detach, MsecToTicks, Pause],  Profile USING [GetUser, SetUser, String],  Runtime USING [Interrupt],  String USING [    AppendChar, AppendString, EquivalentString, Length, StringBoundsFault],  System USING [defaultSwitches, Switches],  Time USING [AppendCurrent],  TTY USING [Rubout],  Volume USING [    GetAttributes, GetLabelString, GetNext, GetStatus, GetType, ID,     maxNameLength, NeedsScavenging, nullID, PageCount];    ExecsG: MONITOR  IMPORTS    Exec, ExecInternal, Format, Heap, HeraldWindow, PhysicalVolume, Process,     Profile, Runtime, String, Time, TTY, Volume =  BEGIN    CallDebugger: Exec.ExecProc =    BEGIN    Runtime.Interrupt[];    END;      CurrentTime: Exec.ExecProc =    BEGIN    s: STRING = [50];    Time.AppendCurrent[s, TRUE];    Format.Line[Exec.OutputProc[h], s];    END;      VolumeStatus: Exec.ExecProc =    BEGIN    token, switches: LONG STRING ¬ NIL;    volume: Volume.ID ¬ Volume.nullID;    write: Format.StringProc = Exec.OutputProc[h];    IF Exec.EndOfCommandLine[h] THEN -- show all volumes      UNTIL (volume ¬ Volume.GetNext[volume, ALL[TRUE]]) = Volume.nullID DO      ShowStatus[volume, NIL, write ! Volume.NeedsScavenging =>         {Format.Line[write,"Volume needs scavenging."L]; LOOP}];      ENDLOOP    ELSE DO      ENABLE UNWIND => {        Heap.systemZone.FREE[@token]; 	Heap.systemZone.FREE[@switches]};      [token, switches] ¬ Exec.GetToken[h];      IF token = NIL AND switches = NIL THEN EXIT;      Heap.systemZone.FREE[@switches];      IF token = NIL THEN LOOP;      volume ¬ ExecInternal.MapClientVolumeNameToID[token];      IF volume = Volume.nullID THEN {        Format.Text[write, token];	Format.Line[write, " is not a known volume."L]}      ELSE ShowStatus[volume, token, write ! Volume.NeedsScavenging =>        {Format.Text[write, token]; Format.Line[write, " needs scavenging."L];	 CONTINUE}];      Heap.systemZone.FREE[@token];      ENDLOOP;    END;      ShowStatus: PROCEDURE [volume: Volume.ID, name: LONG STRING, write: Format.StringProc] =    BEGIN    freePages, volumeSize: Volume.PageCount;    s: LONG STRING = [Volume.maxNameLength];    IF name = NIL THEN {      Volume.GetLabelString[volume, s];      write[s]}    ELSE write[name];    write[":  "L];    SELECT Volume.GetType[volume] FROM        normal => write["normal, "L];        debugger => write["debugger, "L];        debuggerDebugger => write["debuggerDebugger, "L];	ENDCASE => write["nonPilot type, "L];    SELECT Volume.GetStatus[volume] FROM        openRead => write["open for read, "L];        openReadWrite => write["open for read/write, "L];        closedAndConsistent => write["closed, "L];        closedAndInconsistent => write["closed and inconsistent, "L];        partiallyOnLine => write["partially on line, "L];	ENDCASE => write["unknown status, "L];    [volumeSize: volumeSize, freePageCount: freePages] ¬ Volume.GetAttributes[volume];    Format.LongNumber[write, LOOPHOLE[freePages, LONG CARDINAL], []];    write[" out of "L];    Format.LongNumber[write, LOOPHOLE[volumeSize, LONG CARDINAL], []];    write[" pages free"L];    Format.CR[write];    END;  Online: Exec.ExecProc =    BEGIN    token, switches: LONG STRING ¬ NIL;    label: STRING ¬ [PhysicalVolume.maxNameLength];    write: Format.StringProc = Exec.OutputProc[h];    DO ENABLE UNWIND => {        Heap.systemZone.FREE[@token]; 	Heap.systemZone.FREE[@switches]};      index: CARDINAL ¬ PhysicalVolume.nullDeviceIndex;      volume: PhysicalVolume.Handle;      [token, switches] ¬ Exec.GetToken[h];      IF token = NIL AND switches = NIL THEN EXIT;      Heap.systemZone.FREE[@switches];      IF token = NIL THEN LOOP;      DO         index ¬ PhysicalVolume.GetNextDrive[index];        IF index = PhysicalVolume.nullDeviceIndex THEN {	   write["Could not find physical device "L];	   Format.Line[write, token];	   EXIT};        volume ¬ PhysicalVolume.GetHandle[index];        [] ¬ PhysicalVolume.GetHints[volume, label];        IF String.EquivalentString[token, label] THEN {	  write["Bringing physical volume "L];	  write[label];	  write[" online"L];	  [] ¬ PhysicalVolume.AssertPilotVolume[volume ! 	    PhysicalVolume.Error => {SELECT error FROM	      notReady => write[": failed because volume not ready"L];	      alreadyAsserted => write[": volume not inactive!"L];	      diskReadError => write[": disk read error"L];	      ENDCASE => write[": unexpected error from Pilot"L];	      CONTINUE};	    PhysicalVolume.NeedsScavenging => {write[": needs scavenging"L]; CONTINUE}];	  Format.CR[write];	  EXIT};	ENDLOOP;      Heap.systemZone.FREE[@token];    ENDLOOP;    END;      Offline: Exec.ExecProc =    BEGIN    token, switches: LONG STRING ¬ NIL;    write: Format.StringProc = Exec.OutputProc[h];    label: STRING ¬ [PhysicalVolume.maxNameLength];    DO ENABLE UNWIND => {        Heap.systemZone.FREE[@token]; 	Heap.systemZone.FREE[@switches]};      index: CARDINAL ¬ PhysicalVolume.nullDeviceIndex;      volume: PhysicalVolume.Handle;      pvID: PhysicalVolume.ID;      [token, switches] ¬ Exec.GetToken[h];      IF token = NIL AND switches = NIL THEN EXIT;      Heap.systemZone.FREE[@switches];      IF token = NIL THEN LOOP;      DO         index ¬ PhysicalVolume.GetNextDrive[index];        IF index = PhysicalVolume.nullDeviceIndex THEN {	   write["Could not find physical device "L];	   Format.Line[write, token];	   EXIT};        volume ¬ PhysicalVolume.GetHandle[index];        [pvID, ] ¬ PhysicalVolume.GetHints[volume, label];        IF String.EquivalentString[token, label] THEN {	  write["Bringing physical volume "L];	  write[label];	  write[" offline"L];	  [] ¬ PhysicalVolume.Offline[pvID ! 	    PhysicalVolume.Error => {SELECT error FROM	      physicalVolumeUnknown => write[": volume unknown"L];	      containsOpenVolumes => write[": contains open logical volumes"L];	      ENDCASE => write[": unexpected error from Pilot"L];	      CONTINUE}];	  Format.CR[write];	  EXIT};	ENDLOOP;      Heap.systemZone.FREE[@token];    ENDLOOP;    END;      VolumeBoot: ENTRY Exec.ExecProc =    BEGIN    ENABLE UNWIND => NULL;    bootSwitches: System.Switches ¬ System.defaultSwitches;    token, switches: LONG STRING ¬ NIL;    volume: Volume.ID ¬ Volume.nullID;    write: Format.StringProc = Exec.OutputProc[h];    [token, switches] ¬ Exec.GetToken[h];    IF switches # NIL THEN {      Format.Text[write, "Booting switches: "L];      Format.Line[write, switches];      bootSwitches ¬ HeraldWindow.ScanSwitches[switches];      Heap.systemZone.FREE[@switches]};    IF token = NIL THEN       Format.Line[write, "Booting physical volume"L]    ELSE {      Format.Text[write, "Booting logical volume "L];      Format.Line[write, token]};    IF ~Exec.Confirm[h] OR Exec.CheckForAbort[h] THEN {       Format.Line[write, "Booting aborted by user"L];      Heap.systemZone.FREE[@token]; outcome ¬ abort}    ELSE Process.Detach[FORK ForkedBoot[token, bootSwitches]];    END;      ForkedBoot: ENTRY PROCEDURE [token: LONG STRING, bootSwitches: System.Switches] =    BEGIN    ENABLE UNWIND => NULL;    HeraldWindow.BootFromVolumeName[token, bootSwitches !         UNWIND => Heap.systemZone.FREE[@token]];    Heap.systemZone.FREE[@token];    END;  BootFromFile: Exec.ExecProc = {    Write: Format.StringProc ¬ h.OutputProc[];    Confirm: HeraldWindow.ConfirmProcType = {RETURN[h.Confirm[]]};    name, sw: LONG STRING ¬ NIL;    cmd: LONG STRING ¬ NIL;    len: CARDINAL ¬ 0;    [name,sw] ¬ h.GetToken[];    len ¬ String.Length[name] + String.Length[sw] + 1;    cmd ¬ Heap.systemZone.NEW[StringBody[len]];    String.AppendString[cmd, name];    String.AppendChar[cmd, '/];    String.AppendString[cmd,sw];    HeraldWindow.BootFromFile[name: cmd, postProc: Write, confirmProc: Confirm!      HeraldWindow.InvalidSwitches => {        Write["Invalid switches: "L]; Write[sw]; Write["\n"L];	CONTINUE}];    name ¬ Exec.FreeTokenString[name];    sw ¬ Exec.FreeTokenString[sw];    Heap.systemZone.FREE[@cmd];    };    LoginWatcher: PROC = {    proc, help: Exec.ExecProc ¬ NIL;    DO      [proc: proc, help: help] ¬ Exec.LookupCommand["LogIn.~"L];      IF proc # NIL THEN {        Exec.AddCommand["LogIn.~"L, LogIn, help];	EXIT};      Process.Pause[Process.MsecToTicks[100]]      ENDLOOP;    };    LogIn: Exec.ExecProc = {    GetUserName: PROC [name, password: Profile.String] = {      String.AppendString[to: user, from: name]};    user: LONG STRING ¬ [40];    password: LONG STRING ¬ [40];    Profile.GetUser[GetUserName, none];    h.GetNameandPassword[      user, password ! TTY.Rubout => {outcome ¬ abort; GOTO quit};      String.StringBoundsFault => {        h.OutputProc[]["String too long! "L]; outcome ¬ error; GOTO quit}];    Profile.SetUser[user, password];    EXITS quit => NULL};  HelpBootFrom: Exec.ExecProc = {    h.OutputProc[]["\nSyntax: BootFromFile.~   filename/bootswitches\n\n"L]};    Init: PROC = {    Process.Detach[FORK LoginWatcher[]];    Exec.AddCommand["BootFromFile.~"L, BootFromFile, HelpBootFrom];    Exec.AddCommand["BootVolume.~"L, VolumeBoot];    Exec.AddCommand["CallDebugger.~"L, CallDebugger];    Exec.AddCommand["Online.~"L, Online];    Exec.AddCommand["Offline.~"L, Offline];    Exec.AddCommand["Time.~"L, CurrentTime];    Exec.AddCommand["VolumeStatus.~"L, VolumeStatus]};      Init[];      END.            
-- Copyright (C) 1985  by Xerox Corporation. All rights reserved. -- AdobeServerControlC.mesa-- RSF	26-Sep-85 17:47:36-- JCS	 7-Oct-85 19:14:48-- RLC	 5-Sep-86 15:54:40DIRECTORY  AdobeCourier USING [    DescribeSystemDescription, maxSDByteSize, maxSDPageSize],  AdobeOps USING [ARSystemHandle, FieldList, nilEnum],  AdobeServer USING [ChangeType],  AdobeServerOps USING [    AddField, Bug, data, Data, GetDesiredSystem, ModifyField,    PutVersionIDInternal, RemoveField,    RetrieveSystemDescriptionInternal],  ByteBlt USING [ByteBlt],  Courier USING [Free, SerializeParameters],  Environment USING [wordsPerPage],  MemoryStream USING [Create, Destroy],  NSExec USING [    ExecProc, GetTTY, Handle, PutIndentedMessage, PutMessage],  NSFile USING [Handle],  NSSegment USING [    CopyOut, MakeWritable, Map, Origin, SetSizeInBytes],  NSString USING [    AppendNumber, AppendString, FreeString, MakeString, String,    StringFromMesaString],  Space USING [Interval, Map, ScratchMap, Unmap],  Stream USING [GetPosition, Handle],  TextInput USING [GetDecimal],  TTY USING [Handle];AdobeServerControlC: MONITOR LOCKS data USING data: Data  --Monitor access to the stable boolean.  IMPORTS    AdobeCourier, AdobeServerOps, ByteBlt, Courier, MemoryStream,    NSExec, NSSegment, NSString, Space, Stream, TextInput  EXPORTS AdobeServerOps =  BEGIN  Data: TYPE = AdobeServerOps.Data;  data: AdobeServerOps.Data = @AdobeServerOps.data;  SystemStable: ENTRY PROCEDURE [    data: AdobeServerOps.Data, system: CARDINAL] = {    data.systems[system].stable ¬ TRUE};  SystemUnstable: ENTRY PROCEDURE [    data: AdobeServerOps.Data, system: CARDINAL] = {    data.systems[system].stable ¬ FALSE};  IdleAdobeService: NSExec.ExecProc = {    --This procedure makes the Adobe service inaccessible to RPC    --clients but keeps the global data objects around    };  ChangeFieldList: PUBLIC NSExec.ExecProc = {    systemIndex, fieldIndex: CARDINAL ¬ 0;    arSH: AdobeOps.ARSystemHandle ¬ NIL;    tty: TTY.Handle ¬ NSExec.GetTTY[exec];    changeType: AdobeServer.ChangeType;    newEnumValue: CARDINAL ¬ 1;    changeMade: BOOLEAN ¬ FALSE;    systemIndex ¬ AdobeServerOps.GetDesiredSystem[exec];    arSH ¬ AdobeServerOps.RetrieveSystemDescriptionInternal[      data.systems[systemIndex].dfH, data.z];    newEnumValue ¬ CheckEnumValues[arSH.fieldList];    SystemUnstable[data, systemIndex];    BEGIN    ENABLE {      UNWIND => SystemStable[data, systemIndex];      ABORTED => SystemStable[data, systemIndex]};    NSExec.PutMessage[exec, S["Type of change?"L]];    changeType ¬ GetDesiredChange[exec];    IF changeType # add THEN {      NSExec.PutMessage[exec, S["Which field?"L]];      fieldIndex ¬ GetDesiredField[exec, arSH]};    SELECT changeType FROM      modify =>        [newEnumValue, changeMade] ¬ AdobeServerOps.ModifyField[          exec, arSH, fieldIndex, newEnumValue];      add =>        [newEnumValue, arSH.fieldList, changeMade] ¬          AdobeServerOps.AddField[exec, arSH, newEnumValue];      remove =>        [arSH.fieldList, changeMade] ¬          AdobeServerOps.RemoveField[exec, arSH, fieldIndex];      ENDCASE;    IF changeMade THEN {      arSH.version ¬ arSH.version + 1;      ReplaceSystemDescription[data.systems[systemIndex].dfH, arSH];      AdobeServerOps.PutVersionIDInternal[arSH.name, arSH.version]};    --free arSH    Courier.Free[      [arSH, AdobeCourier.DescribeSystemDescription], data.z];    data.z.FREE[@arSH];    SystemStable[data, systemIndex];    END};  CheckEnumValues: PROCEDURE [fl: AdobeOps.FieldList]    RETURNS [nextAvailEnumValue: CARDINAL ¬ 0] = {    FOR i: CARDINAL IN [0..fl.len) DO      WITH fl[i] SELECT FROM        enumerated =>          FOR j: CARDINAL IN [0..possibilities.len) DO            FOR k: CARDINAL IN [0..possibilities[j].enumRecs.length)              DO              IF possibilities[j].enumRecs[k].value >                nextAvailEnumValue                AND possibilities[j].enumRecs[k].value #                  AdobeOps.nilEnum THEN                nextAvailEnumValue ¬ possibilities[j].enumRecs[                  k].value;              ENDLOOP;            ENDLOOP;        ENDCASE;      ENDLOOP;    RETURN[nextAvailEnumValue + 1]};  GetDesiredChange: PROCEDURE [exec: NSExec.Handle]    RETURNS [changeType: AdobeServer.ChangeType] = {    index: CARDINAL;    string: NSString.String ¬ NSString.MakeString[data.z, 50];    string ¬ NSString.AppendString[string, S["1. Modify"L]];    NSExec.PutIndentedMessage[exec, string];    string.length ¬ 0;    string ¬ NSString.AppendString[string, S["2. Add"L]];    NSExec.PutIndentedMessage[exec, string];    string.length ¬ 0;    string ¬ NSString.AppendString[string, S["3. Remove"L]];    NSExec.PutIndentedMessage[exec, string];    string.length ¬ 0;    index ¬ TextInput.GetDecimal[      tty: NSExec.GetTTY[exec], prompt: S["Enter number"L], min: 1,      max: 3, default: 1];    NSString.FreeString[data.z, string];    RETURN[VAL[index - 1]]};  GetDesiredField: PROCEDURE [    exec: NSExec.Handle, arSH: AdobeOps.ARSystemHandle]    RETURNS [fLIndex: CARDINAL] = {    index: CARDINAL;    s: NSString.String ¬ NSString.MakeString[data.z, 100];    FOR i: CARDINAL IN [0..arSH.fieldList.len) DO      s.length ¬ 0;      s ¬ NSString.AppendNumber[s, i + 1];      s ¬ NSString.AppendString[s, S[". "L]];      s ¬ NSString.AppendString[s, S[arSH.fieldList[i].name]];      NSExec.PutIndentedMessage[exec, s];      s.length ¬ 0;      ENDLOOP;    index ¬ TextInput.GetDecimal[      tty: NSExec.GetTTY[exec], prompt: S["Enter number"L], min: 1,      max: arSH.fieldList.len, default: 0];    NSString.FreeString[data.z, s];      RETURN[index - 1]};  ReplaceSystemDescription: PUBLIC PROCEDURE [    fH: NSFile.Handle, arSH: AdobeOps.ARSystemHandle] = {    lengthInWords: CARDINAL;    origin: NSSegment.Origin;    interval: Space.Interval;    space: LONG POINTER _ Space.ScratchMap[      count: AdobeCourier.maxSDPageSize];    sH: Stream.Handle ¬ MemoryStream.Create[      [space, 0, AdobeCourier.maxSDByteSize]];    Courier.SerializeParameters[      parameters: [      location: arSH,      description: AdobeCourier.DescribeSystemDescription], sH: sH];    lengthInWords _ CARDINAL[(Stream.GetPosition[sH] + 1) / 2];    NSSegment.SetSizeInBytes[      file: fH, bytes: lengthInWords * 2, session: data.fileSession];    origin ¬ [      file: fH, base: 0,      count: (lengthInWords / Environment.wordsPerPage) + 1];    interval ¬ NSSegment.Map[      origin: origin, session: data.fileSession];    NSSegment.MakeWritable[      interval: interval, file: fH, session: data.fileSession];    IF ByteBlt.ByteBlt[      to: [interval.pointer, 0, lengthInWords * 2],      from: [space, 0, lengthInWords * 2]] # lengthInWords * 2 THEN      ERROR AdobeServerOps.Bug;    [] ¬ NSSegment.CopyOut[      pointer: interval.pointer, origin: origin,      session: data.fileSession];    -- cleanup space    interval.pointer ¬ Space.Unmap[interval.pointer];    MemoryStream.Destroy[sH];    space ¬ Space.Unmap[space]};  S: PROC [s: LONG STRING] RETURNS [NSString.String] = INLINE {    RETURN[NSString.StringFromMesaString[s]]};  END.-- RLC		 5-Sep-86 13:19:43 fix NSString leaky sieve-- RLC		 5-Sep-86 14:58:54 Unmap space in ReplaceSystemDescription-- RLC	 5-Sep-86 15:54:40 MemoryStream.Destroy[sH];
-- Copyright (C) 1984, 1985, 1986  by Xerox Corporation. All rights reserved. -- AdobeCourierServerImplB.mesa-- BJD    	18-May-84 11:47:14-- RSF      	15-Apr-86 18:34:49-- JCS  	 3-Mar-86 19:48:29-- RLC		12-Jun-87 13:43:41-- Adobe Accelerator file management/queryingDIRECTORY  AdobeCourier USING [    DescribeGetAcceleratorInfoArguments, DescribeLookupARsArguments,    DescribeSetOfARs, DescribeSystemDescription,    DescribeUpdateAcceleratorFieldArguments, DescribeUpdaterArguments,    GetAcceleratorInfoArguments, LocationOfARs, LookupARsArguments,    sendingInfo, ServiceProc, SetOfARsRecord,    UpdateAcceleratorFieldArguments, UpdaterArguments],  AdobeOps USING [    ARNumber, ARSystemHandle, EnumeratedSequence, FieldItemObject,    FieldList, nilARNumber, nilEnum, RunOfARs, SetOfARs,    SetOfARsObject],  AdobeServer USING [Error, FieldItemValue, Relation, StringArray],  AdobeServerOps USING [    AdobeError, CatchErrors, CloseFile, CreateAcceleratorFile, data,    Data, GetAcceleratorFile, GetAcceleratorsDir,    GetLocationOfARsInternal, OpenAcceleratorFile,    ReadLastARNumberInternal, RetrieveSystemDescription, SetStatus,    SystemEntry, SystemIndex, VerifyVersionInternal],  AdobeSetUpdate USING [CreateStream, GetValueFromTable, ResetStream],  AdobeUpdater USING [AboutToStore, CompletedUpdate, UpdateTheseARs],  ARFileAccess USING [    Create, Destroy, Error, Logon, RetrieveAR, Session],  ByteBlt USING [ByteBlt],  Courier USING [Free],  Date USING [Packed, StringToPacked],  Environment USING [    Block, Byte, bytesPerPage, bytesPerWord, wordsPerPage],  NSExec USING [GetTTY, Handle],  NSFile USING [    AttributesRecord, Error, Handle, Session, String, Time],  NSSegment USING [    CopyIn, CopyOut, GetSizeInPages, Origin, Session, SetSizeInPages],  Stream USING [    Block, Delete, Handle, PutBlock, PutWord, SendNow, SetSST],  String USING [    AppendChar, AppendLongNumber, Copy, Empty, EmptyString, Equal,    Equivalent, EquivalentSubString, MakeString, StringToLongNumber,    SubStringDescriptor],  Space USING [ScratchMap, Unmap],  System USING [GreenwichMeanTime],  TTY USING [Handle, PutLine, PutString],  Time USING [Append, Packed, Unpack];AdobeCourierServerImplB: MONITOR  <<monitor access to Accelerator files on a per system basis>>  IMPORTS    AdobeCourier, AdobeServer, AdobeServerOps, AdobeSetUpdate, AdobeUpdater,    ARFileAccess, ByteBlt, Courier, Date, NSExec, NSFile, NSSegment,    Space, Stream, String, Time, TTY  EXPORTS AdobeServerOps =  BEGIN OPEN AS: AdobeServerOps;  bufPages: CARDINAL = 2;  data: AS.Data = @AS.data;  Bug: PUBLIC ERROR = CODE;  AccessorType: TYPE = {reader, writer};  SequenceOfFileHandlesPtr: TYPE = LONG POINTER TO    SequenceOfFileHandles;  SequenceOfFileHandles: TYPE = RECORD [    list: SEQUENCE length: CARDINAL OF FileHandleItem];  FileHandleItem: TYPE = RECORD [    index: CARDINAL, fileHandle: NSFile.Handle];  AcquireAcceleratorAccess: ENTRY PROCEDURE [    accessDesired: AccessorType,    systemEntry: AdobeServerOps.SystemEntry] =    BEGIN    UNTIL AcquireAcceleratorAccessInternal[accessDesired, systemEntry]      DO WAIT systemEntry.systemCV; ENDLOOP;    END;  AcquireAcceleratorAccessInternal: INTERNAL PROCEDURE [    accessDesired: AccessorType,    systemEntry: AdobeServerOps.SystemEntry]    RETURNS [goAhead: BOOLEAN] =    BEGIN    SELECT accessDesired FROM      reader =>        SELECT systemEntry.status FROM          readerIn, open => {            systemEntry.status ¬ readerIn;            systemEntry.readerCount ¬ systemEntry.readerCount + 1;            goAhead ¬ TRUE};          ENDCASE => goAhead ¬ FALSE;      writer =>        SELECT systemEntry.status FROM          open => {systemEntry.status ¬ writerIn; goAhead ¬ TRUE};          writerWaiting =>            IF systemEntry.readerCount = 0 THEN {              systemEntry.status ¬ writerIn; goAhead ¬ TRUE}            ELSE goAhead ¬ FALSE;          ENDCASE => {            systemEntry.status ¬ writerWaiting; goAhead ¬ FALSE};      ENDCASE;    END;  ReleaseAcceleratorAccess: ENTRY PROCEDURE [    type: AccessorType, systemEntry: AdobeServerOps.SystemEntry] =    BEGIN    SELECT type FROM      reader => {        systemEntry.readerCount ¬ systemEntry.readerCount - 1;        IF systemEntry.readerCount = 0          AND systemEntry.status # writerWaiting          AND systemEntry.status # writerIn THEN          systemEntry.status ¬ open};      writer =>        IF systemEntry.status # writerWaiting THEN          IF systemEntry.readerCount = 0 THEN            systemEntry.status ¬ open          ELSE systemEntry.status ¬ readerIn;      ENDCASE;    BROADCAST systemEntry.systemCV;    END;  LookupARs: PUBLIC AdobeCourier.ServiceProc =    BEGIN    args: AdobeCourier.LookupARsArguments;    proc: PROCEDURE = {      resultRecord: AdobeCourier.SetOfARsRecord;      arguments[[@args, AdobeCourier.DescribeLookupARsArguments]];      IF ~AS.VerifyVersionInternal[args.systemName, args.version] THEN        AS.AdobeError[obsoleteVersion];      IF ~data.systems[AS.SystemIndex[args.systemName]].stable THEN        AS.AdobeError[sysDescChanging];      WITH v: args.value.value SELECT FROM        arId =>          resultRecord.set ¬ LookupARId[            args.systemName, args.fieldName, v.ar,            args.value.relationalOp, args.set];        dateTime =>          resultRecord.set ¬ LookupDateTime[            args.systemName, args.fieldName, v.time,            args.value.relationalOp, args.set];        numeric =>          resultRecord.set ¬ LookupNumeric[            args.systemName, args.fieldName, v.number,            args.value.relationalOp, args.set];        fixedLengthString =>          resultRecord.set ¬ LookupString[            args.systemName, args.fieldName, v.string, v.maxLength,            args.value.relationalOp, args.set];        enumerated =>          resultRecord.set ¬ LookupEnumerated[            args.systemName, args.fieldName, v.enumVal,            args.value.relationalOp, args.set];        ENDCASE;      --an empty set is represented by sequence length 1 with      --startValue and runLength = 0.      resultRecord.length ¬ resultRecord.set.len;      [] ¬ results[[@resultRecord, AdobeCourier.DescribeSetOfARs]];      data.z.FREE[@resultRecord.set]};    AS.CatchErrors[proc];    Courier.Free[      [@args, AdobeCourier.DescribeLookupARsArguments], data.z]    END;  AboutToStore: PUBLIC AdobeCourier.ServiceProc =    BEGIN    args: AdobeCourier.UpdaterArguments;    proc: PROCEDURE = {      arguments[[@args, AdobeCourier.DescribeUpdaterArguments]];      IF ~AS.VerifyVersionInternal[args.systemName, args.version] THEN        AS.AdobeError[obsoleteVersion];      IF ~data.systems[AS.SystemIndex[args.systemName]].stable THEN        AS.AdobeError[sysDescChanging];      AdobeUpdater.AboutToStore[args.systemName, args.arNumber];      [] ¬ results[]};    AS.CatchErrors[proc];    Courier.Free[      [@args, AdobeCourier.DescribeUpdaterArguments], data.z];    END;  CompletedUpdate: PUBLIC AdobeCourier.ServiceProc =    BEGIN    args: AdobeCourier.UpdaterArguments;    proc: PROCEDURE = {      arguments[[@args, AdobeCourier.DescribeUpdaterArguments]];      AdobeUpdater.CompletedUpdate[args.systemName, args.arNumber];      [] ¬ results[]};    AS.CatchErrors[proc];    Courier.Free[      [@args, AdobeCourier.DescribeUpdaterArguments], data.z];    END;  GetAcceleratorInfo: PUBLIC AdobeCourier.ServiceProc =    BEGIN    args: AdobeCourier.GetAcceleratorInfoArguments;    proc: PROCEDURE = {      arguments[        [@args, AdobeCourier.DescribeGetAcceleratorInfoArguments]];      IF ~AS.VerifyVersionInternal[args.systemName, args.version] THEN        AS.AdobeError[obsoleteVersion];      IF ~data.systems[AS.SystemIndex[args.systemName]].stable THEN        AS.AdobeError[sysDescChanging];      BEGIN      accFiles: SequenceOfFileHandlesPtr;      currentStatus: AdobeServerOps.SetStatus;      arId: AdobeOps.ARNumber ¬ AdobeOps.nilARNumber;      string: LONG STRING ¬ NIL;      datetime: System.GreenwichMeanTime;      systemEntry: AdobeServerOps.SystemEntry ¬ data.systems[        AS.SystemIndex[args.systemName]];      arSH: AdobeOps.ARSystemHandle ¬        AdobeServerOps.RetrieveSystemDescription[        args.systemName, data.z];      onePageBuffer: LONG POINTER ¬ Space.ScratchMap[count: 1];      stringBuffer: LONG POINTER ¬ Space.ScratchMap[count: bufPages];      accFiles ¬ MakeAccelFileList[        args.fieldList, args.systemName, arSH];      AcquireAcceleratorAccess[reader, systemEntry];      {ENABLE {UNWIND => ReleaseAcceleratorAccess[reader, systemEntry]};      string ¬ String.MakeString[data.z, Environment.bytesPerPage];      [arId, currentStatus] ¬ GetNextAR[args.ql, currentStatus];      Stream.SetSST[cH.sH, AdobeCourier.sendingInfo];      WHILE arId # AdobeOps.nilARNumber DO        FOR i: CARDINAL IN [0..accFiles.length) DO          string.length ¬ 0;          WITH fieldType: arSH.fieldList[accFiles[i].index] SELECT          FROM            arId => {              GetDoubleWord[                arId, accFiles[i].fileHandle, onePageBuffer, @string];              cH.sH.PutWord[string.length];              cH.sH.PutBlock[StringToEvenBlock[string]]};            dateTime => {              datetime ¬ GetDateTime[                arId, onePageBuffer, accFiles[i].fileHandle];              IF datetime # LONG[0] THEN                Time.Append[                  s: string, unpacked: Time.Unpack[datetime]];              --else leave string to be 0 length              cH.sH.PutWord[string.length];              cH.sH.PutBlock[StringToEvenBlock[string]]};            numeric => {              GetDoubleWord[                arId, accFiles[i].fileHandle, onePageBuffer, @string];              cH.sH.PutWord[string.length];              cH.sH.PutBlock[StringToEvenBlock[string]]};            fixedLengthString => {              IF fieldType.maxLength > Environment.bytesPerPage THEN                ERROR AdobeServer.Error[others];              GetString[                arId, accFiles[i].fileHandle, fieldType.maxLength,                stringBuffer, cH.sH]};            enumerated => {              GetWord[                arId, accFiles[i].fileHandle, @arSH.fieldList[                accFiles[i].index], onePageBuffer, @string];              cH.sH.PutWord[string.length];              cH.sH.PutBlock[StringToEvenBlock[string]]};            ENDCASE => ERROR AdobeServer.Error[parameterInconsistency];          ENDLOOP;        [arId, currentStatus] ¬ GetNextAR[args.ql, currentStatus];        Stream.SendNow[sH: cH.sH, endRecord: FALSE];        ENDLOOP;      Stream.SendNow[sH: cH.sH, endRecord: TRUE]};      ReleaseAcceleratorAccess[reader, systemEntry];      data.z.FREE[@accFiles];      data.z.FREE[@string];      Courier.Free[        [arSH, AdobeCourier.DescribeSystemDescription], data.z];      data.z.FREE[@arSH];      [] ¬ Space.Unmap[onePageBuffer];      [] ¬ Space.Unmap[stringBuffer];      [] ¬ results[];      END};    AS.CatchErrors[proc];    Courier.Free[      [@args, AdobeCourier.DescribeGetAcceleratorInfoArguments],      data.z]    END;  UpdateAcceleratorField: PUBLIC AdobeCourier.ServiceProc =    BEGIN    args: AdobeCourier.UpdateAcceleratorFieldArguments;    proc: PROC = {      arguments[        [        @args, AdobeCourier.DescribeUpdateAcceleratorFieldArguments]];      IF ~AS.VerifyVersionInternal[args.systemName, args.version] THEN        AS.AdobeError[obsoleteVersion];      IF ~data.systems[AS.SystemIndex[args.systemName]].stable THEN        AS.AdobeError[sysDescChanging];      UpdateAcceleratorFieldInternal[        args.systemName, args.arNumber, args.fieldName, args.value];      [] ¬ results[];      };    AS.CatchErrors[proc];    Courier.Free[      [@args, AdobeCourier.DescribeUpdateAcceleratorFieldArguments],      data.z]    END;  UpdateAcceleratorFieldInternal: PUBLIC PROCEDURE [    systemName: LONG STRING, arNumber: LONG CARDINAL,    fieldName: LONG STRING, value: AdobeServer.FieldItemValue] =    BEGIN    systemEntry: AdobeServerOps.SystemEntry ¬ data.systems[      AS.SystemIndex[systemName]];    acc: NSFile.Handle ¬ AS.GetAcceleratorFile[systemName, fieldName];    AcquireAcceleratorAccess[writer, systemEntry];    {ENABLE {UNWIND => ReleaseAcceleratorAccess[writer, systemEntry]};    WITH value SELECT FROM      arId => UpdateDoubleWord[arNumber, acc, ar];      dateTime => UpdateDoubleWord[arNumber, acc, time];      numeric => UpdateDoubleWord[arNumber, acc, number];      fixedLengthString => {        IF maxLength > Environment.bytesPerPage THEN 	  ERROR AdobeServer.Error[others];        UpdateString[arNumber, acc, string, maxLength]};      enumerated => UpdateWord[arNumber, acc, enumVal];      ENDCASE => ERROR AdobeServer.Error[parameterInconsistency]};    ReleaseAcceleratorAccess[writer, systemEntry];    END;  UpdateWord: PROC [    arNumber: LONG CARDINAL, acc: NSFile.Handle, value: UNSPECIFIED] =    BEGIN    Buffer: TYPE = RECORD [SEQUENCE COMPUTED CARDINAL OF UNSPECIFIED];    buffer: LONG POINTER TO Buffer ¬ Space.ScratchMap[count: 1];    offset: CARDINAL ¬ CARDINAL[      (arNumber - 1) MOD Environment.wordsPerPage];    page: LONG CARDINAL ¬ (arNumber - 1) / Environment.wordsPerPage;    origin: NSSegment.Origin;    SeeIfEntryExistsAndGrowIfNecessary[      file: acc, number: arNumber,      entrySizeInBytes: Environment.bytesPerWord];    origin ¬ [file: acc, base: page, count: 1];    [] ¬ NSSegment.CopyIn[      pointer: buffer, origin: origin, session: data.fileSession];    buffer[offset] ¬ value;    [] ¬ NSSegment.CopyOut[      pointer: buffer, origin: origin, session: data.fileSession];    buffer ¬ Space.Unmap[buffer];    END;  UpdateDoubleWord: PROC [    arNumber: LONG CARDINAL, acc: NSFile.Handle,    value: LONG UNSPECIFIED] =    BEGIN    Buffer: TYPE = RECORD [      SEQUENCE COMPUTED CARDINAL OF LONG UNSPECIFIED];    buffer: LONG POINTER TO Buffer ¬ Space.ScratchMap[count: 1];    offset: CARDINAL ¬ CARDINAL[      (arNumber - 1) MOD (Environment.wordsPerPage / 2)];    page: LONG CARDINAL ¬      (arNumber - 1) * 2 / Environment.wordsPerPage;    origin: NSSegment.Origin;    SeeIfEntryExistsAndGrowIfNecessary[      file: acc, number: arNumber,      entrySizeInBytes: 2 * Environment.bytesPerWord];    origin ¬ [file: acc, base: page, count: 1];    [] ¬ NSSegment.CopyIn[      pointer: buffer, origin: origin, session: data.fileSession];    buffer[offset] ¬ value;    [] ¬ NSSegment.CopyOut[      pointer: buffer, origin: origin, session: data.fileSession];    buffer ¬ Space.Unmap[buffer];    END;  UpdateString: PROC [    arNumber: LONG CARDINAL, acc: NSFile.Handle, value: LONG STRING,    maxLength: CARDINAL] =    BEGIN    Buffer: TYPE = PACKED ARRAY INTEGER [0..0) OF Environment.Byte;    buffer: LONG POINTER TO Buffer ¬ Space.ScratchMap[      count: bufPages];    origin: NSSegment.Origin;    offset: CARDINAL ¬ CARDINAL[      ((arNumber - 1) * maxLength) MOD Environment.bytesPerPage];    page: LONG CARDINAL ¬      ((arNumber - 1) * maxLength) / Environment.bytesPerPage;    SeeIfEntryExistsAndGrowIfNecessary[      file: acc, number: arNumber, entrySizeInBytes: maxLength];    origin ¬ [file: acc, base: page, count: bufPages];    [] ¬ NSSegment.CopyIn[      pointer: buffer, origin: origin, session: data.fileSession];    -- rlc 12-Jun-87 13:43:41. just let the string truncate, used to raise Bug    [] ¬ ByteBlt.ByteBlt[      to: [buffer, offset, offset + maxLength],      from: StringToBlock[value]];    IF value.length < maxLength THEN      buffer[offset + value.length] ¬ 0B;    [] ¬ NSSegment.CopyOut[      pointer: buffer, origin: origin, session: data.fileSession];    buffer ¬ Space.Unmap[buffer];    END;  LookupARId: PROCEDURE [    system: LONG STRING, fieldName: LONG STRING,    theARId: AdobeOps.ARNumber, relOp: AdobeServer.Relation,    startSet: AdobeOps.SetOfARs] RETURNS [set: AdobeOps.SetOfARs] =    BEGIN    okToAdd: BOOLEAN;    status: AdobeServerOps.SetStatus ¬ [0, 0];    endARNumber: LONG CARDINAL;    arId: AdobeOps.ARNumber;    setState: CARDINAL ¬ 0;    --set ¬ data.z.NEW[AdobeOps .SetOfARsObject[StartLength[startSet]]];    set ¬ data.z.NEW[AdobeOps.SetOfARsObject[StartLength[startSet]]];    FOR i: CARDINAL IN [0..set.len) DO set[i] ¬ [0, 0]; ENDLOOP;    [arId, endARNumber] ¬ GetARRange[startSet, system];    DO      SELECT relOp FROM        in, notIn => AdobeServer.Error[parameterInconsistency];  --can't have in or notIn for arId.        ENDCASE;  --all ok      okToAdd ¬        SELECT relOp FROM          equal => arId = theARId,          notEqual => arId # theARId,          lessThan => arId < theARId,          lessThanOrEqual => arId <= theARId,          greaterThan => arId > theARId,          greaterThanOrEqual => arId >= theARId,          ENDCASE => FALSE;      IF okToAdd THEN setState ¬ AddToSet[arId, @set, setState];      IF arId >= endARNumber THEN EXIT;      [arId, status] ¬ GetNextAR[startSet, status];      ENDLOOP;    IF setState + 1 # set.len THEN {  --prune off extras at end      temp: AdobeOps.SetOfARs ¬ set;      set ¬ data.z.NEW[AdobeOps .SetOfARsObject[setState + 1]];      FOR i: CARDINAL IN [0..set.len) DO set[i] ¬ temp[i]; ENDLOOP;      data.z.FREE[@temp]};    END;  LookupDateTime: PROCEDURE [    system: LONG STRING, fieldName: LONG STRING,    theTime: System.GreenwichMeanTime, relOp: AdobeServer.Relation,    startSet: AdobeOps.SetOfARs] RETURNS [set: AdobeOps.SetOfARs] =    BEGIN    Buffer: TYPE = RECORD [      SEQUENCE COMPUTED CARDINAL OF System.GreenwichMeanTime];    buffer: LONG POINTER TO Buffer ¬ Space.ScratchMap[count: 1];    fH: NSFile.Handle ¬ AS.GetAcceleratorFile[system, fieldName];    okToAdd: BOOLEAN;    offset: CARDINAL;    page, previousPage: LONG CARDINAL;    origin: NSSegment.Origin;    setState: CARDINAL ¬ 0;    status: AdobeServerOps.SetStatus ¬ [0, 0];    arNumber, endARNumber: LONG CARDINAL;    time: System.GreenwichMeanTime;    systemEntry: AS.SystemEntry ¬ data.systems[      AS.SystemIndex[system]];    [arNumber, endARNumber] ¬ GetARRange[startSet, system];    set ¬ data.z.NEW[AdobeOps .SetOfARsObject[StartLength[startSet]]];    FOR i: CARDINAL IN [0..set.len) DO set[i] ¬ [0, 0]; ENDLOOP;    AcquireAcceleratorAccess[reader, systemEntry];    {ENABLE {UNWIND => ReleaseAcceleratorAccess[reader, systemEntry]};    page ¬ ((arNumber - 1) * 2) / Environment.wordsPerPage;    offset ¬ CARDINAL[      (arNumber - 1) MOD (Environment.wordsPerPage / 2)];    origin ¬ [file: fH, base: page, count: 1];    [] ¬ NSSegment.CopyIn[      pointer: buffer, origin: origin, session: data.fileSession];    DO      time ¬ buffer[offset];      SELECT relOp FROM        in, notIn => AdobeServer.Error[parameterInconsistency];  --can't have in or notIn for dateTime.        ENDCASE;  --all ok      okToAdd ¬        SELECT relOp FROM          equal => time = theTime,          notEqual => time # theTime,          lessThan => time < theTime,          lessThanOrEqual => time <= theTime,          greaterThan => time > theTime,          greaterThanOrEqual => time >= theTime,          ENDCASE => FALSE;      IF okToAdd THEN setState ¬ AddToSet[arNumber, @set, setState];      IF arNumber >= endARNumber THEN EXIT;      [arNumber, status] ¬ GetNextAR[startSet, status];      offset ¬ CARDINAL[        (arNumber - 1) MOD (Environment.wordsPerPage / 2)];      previousPage ¬ page;      IF (page ¬ ((arNumber - 1) * 2) / Environment.wordsPerPage) #        previousPage THEN {        origin ¬ [file: fH, base: page, count: 1];        [] ¬ NSSegment.CopyIn[          pointer: buffer, origin: origin,          session: data.fileSession]};      ENDLOOP};    ReleaseAcceleratorAccess[reader, systemEntry];    buffer ¬ Space.Unmap[buffer];    IF setState + 1 # set.len THEN {  --prune off extras at end      temp: AdobeOps.SetOfARs ¬ set;      set ¬ data.z.NEW[AdobeOps .SetOfARsObject[setState + 1]];      FOR i: CARDINAL IN [0..set.len) DO set[i] ¬ temp[i]; ENDLOOP;      data.z.FREE[@temp]};    END;  LookupNumeric: PROCEDURE [    system: LONG STRING, fieldName: LONG STRING,    theNumber: LONG UNSPECIFIED, relOp: AdobeServer.Relation,    startSet: AdobeOps.SetOfARs] RETURNS [set: AdobeOps.SetOfARs] =    BEGIN    Buffer: TYPE = RECORD [      SEQUENCE COMPUTED CARDINAL OF LONG UNSPECIFIED];    buffer: LONG POINTER TO Buffer ¬ Space.ScratchMap[count: 1];    fH: NSFile.Handle ¬ AS.GetAcceleratorFile[system, fieldName];    offset: CARDINAL;    page, previousPage: LONG CARDINAL;    okToAdd: BOOLEAN;    status: AdobeServerOps.SetStatus ¬ [0, 0];    origin: NSSegment.Origin;    arNumber, endARNumber: LONG CARDINAL;    number: LONG UNSPECIFIED;    setState: CARDINAL ¬ 0;    systemEntry: AS.SystemEntry ¬ data.systems[      AS.SystemIndex[system]];    [arNumber, endARNumber] ¬ GetARRange[startSet, system];    set ¬ data.z.NEW[AdobeOps.SetOfARsObject[StartLength[startSet]]];    FOR i: CARDINAL IN [0..set.len) DO set[i] ¬ [0, 0]; ENDLOOP;    AcquireAcceleratorAccess[reader, systemEntry];    {ENABLE {UNWIND => ReleaseAcceleratorAccess[reader, systemEntry]};    page ¬ ((arNumber - 1) * 2) / Environment.wordsPerPage;    offset ¬ CARDINAL[      (arNumber - 1) MOD (Environment.wordsPerPage / 2)];    origin ¬ [file: fH, base: page, count: 1];    [] ¬ NSSegment.CopyIn[      pointer: buffer, origin: origin, session: data.fileSession];    DO      number ¬ buffer[offset];      SELECT relOp FROM        in, notIn => AdobeServer.Error[parameterInconsistency];  --can't have in or notIn for numeric.        ENDCASE;  --all ok      okToAdd ¬        SELECT relOp FROM          equal => number = theNumber,          notEqual => number # theNumber,          lessThan => number < theNumber,          lessThanOrEqual => number <= theNumber,          greaterThan => number > theNumber,          greaterThanOrEqual => number >= theNumber,          ENDCASE => FALSE;      IF okToAdd THEN setState ¬ AddToSet[arNumber, @set, setState];      IF arNumber >= endARNumber THEN EXIT;      [arNumber, status] ¬ GetNextAR[startSet, status];      offset ¬ CARDINAL[        (arNumber - 1) MOD (Environment.wordsPerPage / 2)];      previousPage ¬ page;      IF (page ¬ ((arNumber - 1) * 2) / Environment.wordsPerPage) #        previousPage THEN {        origin ¬ [file: fH, base: page, count: 1];        [] ¬ NSSegment.CopyIn[          pointer: buffer, origin: origin,          session: data.fileSession]};      ENDLOOP};    ReleaseAcceleratorAccess[reader, systemEntry];    buffer ¬ Space.Unmap[buffer];    IF setState + 1 # set.len THEN {  --prune off extras at end      temp: AdobeOps.SetOfARs ¬ set;      set ¬ data.z.NEW[AdobeOps .SetOfARsObject[setState + 1]];      FOR i: CARDINAL IN [0..set.len) DO set[i] ¬ temp[i]; ENDLOOP;      data.z.FREE[@temp]};    END;  LookupString: PROCEDURE [    system: LONG STRING, fieldName: LONG STRING,    theString: LONG STRING, maxLength: CARDINAL,    relOp: AdobeServer.Relation, startSet: AdobeOps.SetOfARs]    RETURNS [set: AdobeOps.SetOfARs] =    BEGIN    Buffer: TYPE = PACKED ARRAY INTEGER [0..0) OF Environment.Byte;    buffer: LONG POINTER TO Buffer ¬ Space.ScratchMap[      count: bufPages];    fH: NSFile.Handle ¬ AS.GetAcceleratorFile[system, fieldName];    origin: NSSegment.Origin;    offset: CARDINAL;    string: LONG STRING;    okToAdd: BOOLEAN;    arNumber, endARNumber: AdobeOps.ARNumber;    page, previousPage: LONG CARDINAL;    setState: CARDINAL ¬ 0;    status: AdobeServerOps.SetStatus ¬ [0, 0];    systemEntry: AS.SystemEntry ¬ data.systems[      AS.SystemIndex[system]];    [arNumber, endARNumber] ¬ GetARRange[startSet, system];    set ¬ data.z.NEW[AdobeOps.SetOfARsObject[StartLength[startSet]]];    FOR i: CARDINAL IN [0..set.len) DO set[i] ¬ [0, 0]; ENDLOOP;    AcquireAcceleratorAccess[reader, systemEntry];    {ENABLE {UNWIND => ReleaseAcceleratorAccess[reader, systemEntry]};    page ¬ ((arNumber - 1) * maxLength) / Environment.bytesPerPage;    origin ¬ [file: fH, base: page, count: bufPages];    offset ¬ CARDINAL[      ((arNumber - 1) * maxLength) MOD Environment.bytesPerPage];    [] ¬ NSSegment.CopyIn[      pointer: buffer, origin: origin, session: data.fileSession];    DO      string ¬ ObtainString[buffer, offset, maxLength];      SELECT relOp FROM        equal => okToAdd ¬ String.Equal[string, theString];        notEqual => okToAdd ¬ ~String.Equal[string, theString];        in => okToAdd ¬ SubString[string, theString];        notIn => okToAdd ¬ NotSubString[string, theString];        ENDCASE => AdobeServer.Error[parameterInconsistency];  --other invalid for string      data.z.FREE[@string];      IF okToAdd THEN setState ¬ AddToSet[arNumber, @set, setState];      IF arNumber >= endARNumber THEN EXIT;      [arNumber, status] ¬ GetNextAR[startSet, status];      offset ¬ CARDINAL[        ((arNumber - 1) * maxLength) MOD Environment.bytesPerPage];      previousPage ¬ page;      IF        (page ¬          ((arNumber - 1) * maxLength) / Environment.bytesPerPage) #        previousPage THEN {        origin ¬ [file: fH, base: page, count: bufPages];        [] ¬ NSSegment.CopyIn[          pointer: buffer, origin: origin,          session: data.fileSession]};      ENDLOOP};    ReleaseAcceleratorAccess[reader, systemEntry];    buffer ¬ Space.Unmap[buffer];    IF setState + 1 # set.len THEN {  --prune off extras at end      temp: AdobeOps.SetOfARs ¬ set;      set ¬ data.z.NEW[AdobeOps .SetOfARsObject[setState + 1]];      FOR i: CARDINAL IN [0..set.len) DO set[i] ¬ temp[i]; ENDLOOP;      data.z.FREE[@temp]};    END;  LookupEnumerated: PROCEDURE [    system: LONG STRING, fieldName: LONG STRING, theEnumVal: CARDINAL,    relOp: AdobeServer.Relation, startSet: AdobeOps.SetOfARs]    RETURNS [set: AdobeOps.SetOfARs] =    BEGIN    Buffer: TYPE = RECORD [SEQUENCE COMPUTED CARDINAL OF CARDINAL];    buffer: LONG POINTER TO Buffer ¬ Space.ScratchMap[count: 1];    fH: NSFile.Handle ¬ AS.GetAcceleratorFile[system, fieldName];    offset: CARDINAL;    page, previousPage: LONG CARDINAL;    okToAdd: BOOLEAN;    status: AdobeServerOps.SetStatus ¬ [0, 0];    origin: NSSegment.Origin;    arNumber, endARNumber: LONG CARDINAL;    enumVal: CARDINAL;    setState: CARDINAL ¬ 0;    systemEntry: AS.SystemEntry ¬ data.systems[      AS.SystemIndex[system]];    [arNumber, endARNumber] ¬ GetARRange[startSet, system];    set ¬ data.z.NEW[AdobeOps.SetOfARsObject[StartLength[startSet]]];    FOR i: CARDINAL IN [0..set.len) DO set[i] ¬ [0, 0]; ENDLOOP;    AcquireAcceleratorAccess[reader, systemEntry];    {ENABLE {UNWIND => ReleaseAcceleratorAccess[reader, systemEntry]};    page ¬ (arNumber - 1) / Environment.wordsPerPage;    offset ¬ CARDINAL[(arNumber - 1) MOD Environment.wordsPerPage];    origin ¬ [file: fH, base: page, count: 1];    [] ¬ NSSegment.CopyIn[      pointer: buffer, origin: origin, session: data.fileSession];    DO      enumVal ¬ CARDINAL[buffer[offset]];      SELECT relOp FROM        equal => okToAdd ¬ (enumVal = theEnumVal);        notEqual => okToAdd ¬ (enumVal # theEnumVal);        ENDCASE => AdobeServer.Error[parameterInconsistency];  --other operations are invalid for enumerateds      IF okToAdd THEN setState ¬ AddToSet[arNumber, @set, setState];      IF arNumber >= endARNumber THEN EXIT;      [arNumber, status] ¬ GetNextAR[startSet, status];      offset ¬ CARDINAL[(arNumber - 1) MOD Environment.wordsPerPage];      previousPage ¬ page;      IF (page ¬ (arNumber - 1) / Environment.wordsPerPage) #        previousPage THEN {        origin ¬ [file: fH, base: page, count: 1];        [] ¬ NSSegment.CopyIn[          pointer: buffer, origin: origin,          session: data.fileSession]};      ENDLOOP};    ReleaseAcceleratorAccess[reader, systemEntry];    buffer ¬ Space.Unmap[buffer];    IF setState + 1 # set.len THEN {  --prune off extras at end      temp: AdobeOps.SetOfARs ¬ set;      set ¬ data.z.NEW[AdobeOps .SetOfARsObject[setState + 1]];      FOR i: CARDINAL IN [0..set.len) DO set[i] ¬ temp[i]; ENDLOOP;      data.z.FREE[@temp]};    END;  GetWord: PROCEDURE [    arNumber: LONG CARDINAL, fH: NSFile.Handle,    enumField: LONG POINTER TO AdobeOps.FieldItemObject,    buf: LONG POINTER, string: LONG POINTER TO LONG STRING] =    BEGIN    Buffer: TYPE = RECORD [SEQUENCE COMPUTED CARDINAL OF UNSPECIFIED];    buffer: LONG POINTER TO Buffer ¬ buf;    offset: CARDINAL ¬ CARDINAL[      (arNumber - 1) MOD Environment.wordsPerPage];    page: LONG CARDINAL ¬ (arNumber - 1) / Environment.wordsPerPage;    number: CARDINAL;    origin: NSSegment.Origin;    origin ¬ [file: fH, base: page, count: 1];    [] ¬ NSSegment.CopyIn[      pointer: buffer, origin: origin, session: data.fileSession];    number ¬ buffer[offset];    IF number = AdobeOps.nilEnum THEN RETURN;    WITH fieldtype: enumField­ SELECT FROM      enumerated => {        FOR j: CARDINAL IN [0..fieldtype.possibilities.len) DO          FOR k: CARDINAL IN            [0..fieldtype.possibilities[j].enumRecs.length) DO            IF number = fieldtype.possibilities[j].enumRecs[k].value              THEN {              String.Copy[                string­, fieldtype.possibilities[j].enumRecs[                k].string];              EXIT};            ENDLOOP;          ENDLOOP};      ENDCASE => AdobeServer.Error[parameterInconsistency];    END;  --of GetWord  GetDoubleWord: PROCEDURE [    arNumber: LONG CARDINAL, fH: NSFile.Handle, buf: LONG POINTER,    string: LONG POINTER TO LONG STRING] =    BEGIN    Buffer: TYPE = RECORD [      SEQUENCE COMPUTED CARDINAL OF LONG UNSPECIFIED];    buffer: LONG POINTER TO Buffer ¬ buf;    offset: CARDINAL ¬ CARDINAL[      (arNumber - 1) MOD (Environment.wordsPerPage / 2)];    page: LONG CARDINAL ¬      (arNumber - 1) * 2 / Environment.wordsPerPage;    number: AdobeOps.ARNumber;    origin: NSSegment.Origin;    origin ¬ [file: fH, base: page, count: 1];    [] ¬ NSSegment.CopyIn[      pointer: buffer, origin: origin, session: data.fileSession];    number ¬ buffer[offset];    String.AppendLongNumber[string­, number];    END;  --of GetDoubleWord  GetDateTime: PROCEDURE [    arNumber: LONG CARDINAL, buf: LONG POINTER, fH: NSFile.Handle]    RETURNS [dateTime: System.GreenwichMeanTime] =    BEGIN    Buffer: TYPE = RECORD [      SEQUENCE COMPUTED CARDINAL OF LONG UNSPECIFIED];    buffer: LONG POINTER TO Buffer ¬ buf;    offset: CARDINAL ¬ CARDINAL[      (arNumber - 1) MOD (Environment.wordsPerPage / 2)];    page: LONG CARDINAL ¬      (arNumber - 1) * 2 / Environment.wordsPerPage;    origin: NSSegment.Origin;    origin ¬ [file: fH, base: page, count: 1];    [] ¬ NSSegment.CopyIn[      pointer: buffer, origin: origin, session: data.fileSession];    dateTime ¬ [buffer[offset]];    END;  --of GetDateTime  GetString: PROCEDURE [    arNumber: LONG CARDINAL, fH: NSFile.Handle, maxlength: CARDINAL,    buf: LONG POINTER, sH: Stream.Handle] =    BEGIN    Buffer: TYPE = PACKED ARRAY INTEGER [0..0) OF Environment.Byte;    buffer: LONG POINTER TO Buffer ¬ buf;    origin: NSSegment.Origin;    index, entryLength: CARDINAL;    block: Environment.Block;    offset: CARDINAL ¬ CARDINAL[      ((arNumber - 1) * maxlength) MOD Environment.bytesPerPage];    page: LONG CARDINAL ¬      ((arNumber - 1) * maxlength) / Environment.bytesPerPage;    origin ¬ [file: fH, base: page, count: bufPages];    [] ¬ NSSegment.CopyIn[      pointer: buffer, origin: origin, session: data.fileSession];    index ¬ offset;    WHILE buffer[index] # 0B AND index < offset + maxlength DO      index ¬ index + 1; ENDLOOP;    entryLength ¬ index - offset;    sH.PutWord[entryLength];    block ¬ [      buffer + offset / 2, IF offset MOD 2 = 0 THEN 0 ELSE 1,      IF entryLength MOD 2 = 0 THEN entryLength + (offset MOD 2)      ELSE entryLength + 1 + (offset MOD 2)];    sH.PutBlock[block];    END;  --of GetString  UpdateAccelerators: PUBLIC AdobeCourier.ServiceProc =    BEGIN    << not used remotely    args: AdobeCourier.UpdateAcceleratorsArguments;    proc: PROCEDURE = {      run: AdobeOps.RunOfARs;      --systemEntry: AS.SystemEntry;      arguments[        [@args, AdobeCourier.DescribeUpdateAcceleratorsArguments]];      --currently UpdateTheseARs only supports one RunOfARs.  Later we may support a full AdobeOps.RangeOfARs      run ¬ args.ars[0];      --systemEntry ¬ data.systems[AS.SystemIndex[args.systemName]];      UpdateAcceleratorsInternal[args.systemName, run];      <<AcquireAcceleratorAccess[writer, systemEntry];       AdobeUpdater.UpdateTheseARs[args.systemName, run];      ReleaseAcceleratorAccess[writer,systemEntry];>>      [] ¬ results[]};    AS.CatchErrors[proc];    Courier.Free[      [@args, AdobeCourier.DescribeUpdateAcceleratorsArguments],      data.z];    >>    END;  UpdateAcceleratorsInternal: PUBLIC PROCEDURE [    systemName: LONG STRING, run: AdobeOps.RunOfARs] =    BEGIN    systemEntry: AS.SystemEntry;    systemEntry ¬ data.systems[AS.SystemIndex[systemName]];    AcquireAcceleratorAccess[writer, systemEntry];    {ENABLE {UNWIND => ReleaseAcceleratorAccess[writer, systemEntry]};    AdobeUpdater.UpdateTheseARs[systemName, run]};    ReleaseAcceleratorAccess[writer, systemEntry];    END;  --Caller believes that this file doesn't exist or contains bad data; it if does exist, whatever is in it is written over      MakeAcceleratorFileForField: PUBLIC AdobeCourier.ServiceProc = {};  << not to be allowed remotely    args: AdobeCourier.MakeAccelFileForFieldArguments;    proc: PROCEDURE = {      arguments[[        @args, AdobeCourier.DescribeMakeAccelFileForFieldArguments]];      MakeAcceleratorFileForFieldInternal[        args.systemName, args.fieldName, args.fieldList];      [] ¬ results[]};    AdobeServerOps.CatchErrors[proc]};>>  -- this one must go here to use the other accelerator file manipulation procedures here.  MakeAcceleratorFileForFieldInternal: PUBLIC PROCEDURE [    system: LONG STRING, fieldIndex: CARDINAL,    fieldList: AdobeOps.FieldList, exec: NSExec.Handle] = {    accFile: NSFile.Handle;    ar: AdobeOps.ARNumber;    arFieldValue: LONG STRING ¬ NIL;    arLoc: AdobeCourier.LocationOfARs;    arSession: ARFileAccess.Session;    attrRec: NSFile.AttributesRecord;    arStream: Stream.Handle;    lastAR: AdobeOps.ARNumber;    refNum: LONG STRING ¬ "000000"L;    systemEntry: AS.SystemEntry ¬ data.systems[      AS.SystemIndex[system]];    tty: TTY.Handle ¬ NSExec.GetTTY[exec];    BEGIN    ENABLE UNWIND => ReleaseAcceleratorAccess[reader, systemEntry];    AcquireAcceleratorAccess[writer, systemEntry];    --not sure if want enable clause here    accFile ¬ AS.CreateAcceleratorFile[      parent: AS.GetAcceleratorsDir[system],      fieldName: fieldList[fieldIndex].name !      NSFile.Error =>        WITH error SELECT FROM          insertion =>            IF problem = fileNotUnique THEN {              --we're recreating a file that already existed;              --open the old and use it              accFile ¬ AS.OpenAcceleratorFile[                parent: AS.GetAcceleratorsDir[system],                fieldName: fieldList[fieldIndex].name];              CONTINUE};          ENDCASE => REJECT];    arStream ¬ AdobeSetUpdate.CreateStream[fieldList];    arLoc ¬ AdobeServerOps.GetLocationOfARsInternal[system, @attrRec];    arSession ¬ ARFileAccess.Create[data.z, arLoc];    ARFileAccess.Logon[arSession, data.serviceId];    lastAR ¬ AdobeServerOps.ReadLastARNumberInternal[system];    TTY.PutString[tty, "Making Accelerator file for "L];    TTY.PutString[tty, fieldList[fieldIndex].name];    TTY.PutString[tty, ": 1"L];    refNum.length ¬ 0;    FOR ar IN [1..lastAR] DO      ARFileAccess.RetrieveAR[        arSession, ar, arStream !        ARFileAccess.Error =>          SELECT why FROM            invalidARNumber => LOOP;            arNotFound => {              WITH fieldList[fieldIndex] SELECT FROM                arId =>                  UpdateDoubleWord[ar, accFile, AdobeOps.nilARNumber];                dateTime, numeric => UpdateDoubleWord[ar, accFile, 0];                fixedLengthString =>                  UpdateString[ar, accFile, ""L, maxLength];                enumerated =>                  UpdateWord[ar, accFile, AdobeOps.nilEnum];                ENDCASE;              AdobeSetUpdate.ResetStream[arStream];              LOOP};            ENDCASE];      arFieldValue ¬ AdobeSetUpdate.GetValueFromTable[        fieldIndex, arStream, data.z];      WITH fieldList[fieldIndex] SELECT FROM        arId => {          arNum: AdobeOps.ARNumber;          arNum ¬            IF arFieldValue # NIL THEN String.StringToLongNumber[            arFieldValue] ELSE AdobeOps.nilARNumber;          UpdateDoubleWord[ar, accFile, arNum]};        dateTime => {          time: Time.Packed;          time ¬            IF String.EmptyString[arFieldValue] THEN LOOPHOLE[LONG[0],            Date.Packed] ELSE Date.StringToPacked[arFieldValue].dt;          UpdateDoubleWord[ar, accFile, time]};        numeric => {          number: LONG CARDINAL;          number ¬            IF String.Empty[arFieldValue] THEN 0            ELSE String.StringToLongNumber[arFieldValue];          UpdateDoubleWord[ar, accFile, number]};        fixedLengthString => {          IF maxLength > Environment.bytesPerPage THEN 	    ERROR AdobeServer.Error[others];          --Check if AR still has value which exceeds the maxLength          --which is currently a part of the system description.	  IF arFieldValue # NIL THEN { 	    IF arFieldValue.length > maxLength THEN              arFieldValue.length ¬ maxLength;            UpdateString[ar, accFile, arFieldValue, maxLength]}	  ELSE UpdateString[ar, accFile, ""L, maxLength]};        enumerated => {          enumVal: CARDINAL ¬ AdobeOps.nilEnum;          poss: AdobeOps.EnumeratedSequence;          FOR i: CARDINAL IN [0..possibilities.len) DO            poss ¬ possibilities[i].enumRecs;            FOR j: CARDINAL IN [0..poss.length) DO              IF String.Equal[arFieldValue, poss[j].string] THEN {                enumVal ¬ poss[j].value; EXIT};              ENDLOOP;            IF enumVal # AdobeOps.nilEnum THEN EXIT;            ENDLOOP;          UpdateWord[ar, accFile, enumVal]};        ENDCASE => ERROR AdobeServer.Error[parameterInconsistency];      data.z.FREE[@arFieldValue];      AdobeSetUpdate.ResetStream[arStream];      IF ar MOD 20 = 0 THEN {        TTY.PutString[tty, ".."L];        String.AppendLongNumber[refNum, ar];        TTY.PutString[tty, refNum];        refNum.length ¬ 0};      ENDLOOP;    ReleaseAcceleratorAccess[writer, systemEntry];    IF ar MOD 20 # 0 THEN {      TTY.PutString[tty, ".."L];      String.AppendLongNumber[refNum, ar];      TTY.PutLine[tty, refNum]};    ARFileAccess.Destroy[arSession];    Stream.Delete[arStream];    AS.CloseFile[accFile];    END};  -- Utilities  GetARRange: PROCEDURE [set: AdobeOps.SetOfARs, system: LONG STRING]    RETURNS [first, last: AdobeOps.ARNumber] =    BEGIN    first ¬ set[0].startValue;    last ¬      set[set.len - 1].startValue + set[set.len - 1].runLength - 1;    END;  ObtainString: PROCEDURE [    ptr: LONG POINTER TO PACKED ARRAY INTEGER [0..0) OF      Environment.Byte, offset: CARDINAL, maxLen: CARDINAL]    RETURNS [s: LONG STRING] =    BEGIN    c: Environment.Byte;    s ¬ String.MakeString[data.z, maxLen];    c ¬ ptr[offset];    WHILE c # 0B AND s.length # maxLen DO      String.AppendChar[s, LOOPHOLE[c, CHARACTER]];      c ¬ ptr[offset ¬ offset + 1];      ENDLOOP;    END;  SubString: PUBLIC PROCEDURE [    -- TRUE IFF s2 is contained in s1    s1, s2: LONG STRING] RETURNS [BOOLEAN] =    BEGIN OPEN String;    i: CARDINAL;    s1ss, s2ss: SubStringDescriptor;    s2ss ¬ [base: s2, offset: 0, length: s2.length];    s1ss ¬ [base: s1, offset: 0, length: s2.length];    IF s2.length > s1.length THEN RETURN[FALSE];    FOR i IN [0..s1.length - s2.length] DO      s1ss.offset ¬ i;      IF EquivalentSubString[@s1ss, @s2ss] THEN RETURN[TRUE]      ENDLOOP;    RETURN[FALSE]    END;  NotSubString: PUBLIC PROCEDURE [    -- TRUE IFF s2 is not contained in s1    s1, s2: LONG STRING] RETURNS [BOOLEAN] =    BEGIN OPEN String;    i: CARDINAL;    s1ss, s2ss: SubStringDescriptor;    s2ss ¬ [base: s2, offset: 0, length: s2.length];    s1ss ¬ [base: s1, offset: 0, length: s2.length];    IF s2.length > s1.length THEN RETURN[TRUE];    FOR i IN [0..s1.length - s2.length] DO      s1ss.offset ¬ i;      IF EquivalentSubString[@s1ss, @s2ss] THEN RETURN[FALSE]      ENDLOOP;    RETURN[TRUE]    END;  GetNextAR: PROCEDURE [    set: AdobeOps.SetOfARs, current: AdobeServerOps.SetStatus]    RETURNS [      nextAR: AdobeOps.ARNumber,      newStatus: AdobeServerOps.SetStatus] =    --returning AR=0 means set exhausted    BEGIN    newStatus ¬ current;    IF newStatus = [LAST[CARDINAL], LAST[CARDINAL]] THEN      RETURN[set[0].startValue, [0, 0]];    IF set[current.setIndex].runLength <= current.runOffset + 1 THEN {      newStatus.runOffset ¬ 0;      newStatus.setIndex ¬ newStatus.setIndex + 1;      IF newStatus.setIndex >= set.len THEN RETURN[0, newStatus]}    ELSE newStatus.runOffset ¬ newStatus.runOffset + 1;    nextAR ¬ set[newStatus.setIndex].startValue + newStatus.runOffset;    END;  AddToSet: PROCEDURE [    arNum: AdobeOps.ARNumber, set: LONG POINTER TO AdobeOps.SetOfARs,    lastRef: CARDINAL] RETURNS [thisRef: CARDINAL] =    BEGIN    thisRef ¬ lastRef;    IF set[lastRef].startValue = 0 THEN set[lastRef] ¬ [arNum, 1]    ELSE      IF (set[lastRef].startValue + set[lastRef].runLength) = arNum        THEN set[lastRef].runLength ¬ set[lastRef].runLength + 1      ELSE {        thisRef ¬ thisRef + 1;        IF thisRef >= set.len THEN GrowSet[set];        set[thisRef].startValue ¬ arNum;        set[thisRef].runLength ¬ 1};    END;  GrowSet: PROCEDURE [oldSet: LONG POINTER TO AdobeOps.SetOfARs] =    BEGIN    newSet: AdobeOps.SetOfARs ¬ data.z.NEW[      AdobeOps.SetOfARsObject[oldSet.len + ((oldSet.len+1)/2)]];       -- always grow by at least one    FOR i: CARDINAL IN [0..oldSet.len) DO      newSet[i] ¬ oldSet[i]; ENDLOOP;    data.z.FREE[oldSet];    oldSet^ ¬ newSet;    END;      StartLength: PROCEDURE [startSet: AdobeOps.SetOfARs]     RETURNS [CARDINAL] = INLINE {      SELECT startSet.len FROM        --shouldn't happen but if it does, we'll allocate 1        0 => RETURN[1];      --  1 => RETURN[startSet[0].runLength];        ENDCASE => RETURN[startSet.len]};  SeeIfEntryExistsAndGrowIfNecessary: PROC [    file: NSFile.Handle, number: LONG CARDINAL,    entrySizeInBytes: LONG CARDINAL] =    BEGIN    pages: LONG CARDINAL ¬ NSSegment.GetSizeInPages[      file: file, session: data.fileSession];    IF (number * entrySizeInBytes) / Environment.bytesPerPage >= pages      THEN      NSSegment.SetSizeInPages[        file: file, pages: pages + bufPages,        session: data.fileSession];    END;  StringToBlock: PROC [s: LONG STRING] RETURNS [Environment.Block] =    INLINE BEGIN RETURN[[LOOPHOLE[@s.text], 0, s.length]] END;  StringToEvenBlock: PROC [s: LONG STRING]    RETURNS [Environment.Block] = INLINE    BEGIN    RETURN[      [        LOOPHOLE[@s.text], 0,        IF s.length MOD 2 = 0 THEN s.length ELSE s.length + 1]]    END;  MakeAccelFileList: PROCEDURE [    fieldList: LONG POINTER TO AdobeServer.StringArray,    system: LONG STRING, arSH: AdobeOps.ARSystemHandle]    RETURNS [fileHandles: SequenceOfFileHandlesPtr] =    BEGIN    fileHandles ¬ data.z.NEW[      SequenceOfFileHandles [fieldList.length]];    FOR i: CARDINAL IN [0..fieldList.length) DO      fileHandles[i].fileHandle ¬ AdobeServerOps.GetAcceleratorFile[        system, fieldList[i]];      FOR j: CARDINAL IN [0..arSH.fieldList.len) DO        IF String.Equivalent[arSH.fieldList[j].name, fieldList[i]]          THEN {fileHandles[i].index ¬ j; EXIT};        ENDLOOP;      ENDLOOP;    END;  END.-- RLC		28-Jul-86 18:27:37 GrowSet not growing if oldSet.len = 110-Jun-87 16:39:00 - rlc - fix AR 10204. use StringToLongumber rather than StringToDecimal10-Jun-87 17:58:09 - rlc - replace Bug with AdobeServer.Error[parameterInconsistency] in the cases of:1)ENDCASE when an enumerated type is out of the range for that type and 2)in the case where an enumerated type is out of range for a particular query. This patches ar 9575 which occurs when an old tool passes an illegal query value to the server. parameterInconsistency will be translated into some text in the tool like "tool and service are incompatible".12-Jun-87 13:43:41 - rlc - UpdateString no longer will raise Bug if the string is too long. The string will be truncated. Don't call error Bug: it goes uncaught and kills the server. For the cases when the string length is tested against Environment.bytesPerPage, use AdobeServer.Error[others]. This should prevent the server from dying with US Bug.
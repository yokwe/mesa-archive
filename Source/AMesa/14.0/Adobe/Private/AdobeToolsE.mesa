-- File: AdobeToolsE.mesa - created by JCS. Last edit:-- JCS                   2-Mar-86 15:15:08-- RSF      		11-Apr-86 10:27:02-- RLC			 8-Oct-87 10:52:12 -- Copyright (C) 1985, 1986 by Xerox Corporation. All rights reserved. -- ReportDIRECTORY  AdobeCommon USING [    CatchErrors, ColSpace, DataHandle, DisableAdobeAborts, FindThisQL,     FormatType, GetData, GetDataSW, GetNextAR, InitialSetStatus, OrderInfo,    OrderInfoObject, OrderItem, PostMessage, PostNumber, ReportFields,     ReportFieldsSeq, RowBuffer, QLNameHints, SetStatus, StringArray, Template,    TemplateObject],  AdobeCommonInternal USING [    AllocateInstanceData, InstanceDataHandle, reportHeraldName,    SetWindowName],  AdobeOps USING [    ARSystemHandle, ARNumber, FieldItemHandle, FieldList, nilARNumber,    QueryList, UserSpecifiedOrder],  AdobeToolContext,  AdobeServer,  ARAccess USING [ARHandle, Error, ExamineAR, FreeAR, GetAR],  Ascii USING [CR, NUL, SP, TAB],  Date USING [PackedToString, StringToPacked, Unintelligible],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType,    CommandItem, Display, Enumerated, EnumeratedHandle,    EnumeratedItem, FindItem, ItemHandle, line0, line1, MenuProcType,    NotifyProcType, nextLine, ProcType, sameLine, StringItem, TagOnlyItem],  Heap USING [systemZone],  Inline USING [LongNumber],  MFile USING [Acquire, Delete, Error, Handle, ReadOnly, Release],  MsgSW USING [Clear],  MStream USING [Error, Handle, ReadOnly, WriteOnly],  Process USING [Detach, GetCurrent],  String USING [    AppendChar, AppendNumber, AppendString, AppendSubString,    CopyToNewString, Empty, EquivalentSubString, MakeString,    StringBoundsFault, SubStringDescriptor],  Stream USING [    Block, CompletionCode, Delete, EndOfStream, EndRecord, GetChar, Handle,    InputOptions, PutChar, PutString, SSTChange, SubSequenceType, Word],  Space USING [ScratchMap, Unmap],  TajoMisc USING [toolDriverRunning],  Time USING [Current, Unpack, Unpacked],  Tool USING [MakeFormSW],  Window USING [Handle];AdobeToolsE: PROGRAM  IMPORTS    AdobeCommon, AdobeCommonInternal, AdobeServer, AdobeToolContext,    ARAccess, Date, FormSW, Heap, MFile, MsgSW, MStream, Process,    Space, Stream, String, TajoMisc, Time, Tool  EXPORTS AdobeCommonInternal =  BEGIN  --globals for report  reportPos: CARDINAL = 0;  formatPos: CARDINAL = 1;  overwritePos: CARDINAL = 2;  resetPos: CARDINAL = 3;  setFieldsPos: CARDINAL = 4;  rptBkgdPos: CARDINAL = 5;  outFilePos: CARDINAL = 6;  tmpltFilePos: CARDINAL = 7;  rptQlNamePos: CARDINAL = 8;  nReportParams: CARDINAL = 9;    templateProblem: ERROR = CODE;  CreateReportSW: PUBLIC PROCEDURE [    w: Window.Handle, makeCmdSW: BOOLEAN ¬ TRUE]    RETURNS [initialMsg: LONG STRING ¬ NIL] =    BEGIN    data: AdobeCommon.DataHandle ¬ AdobeCommon.GetData[w];    instanceData: AdobeCommonInternal.InstanceDataHandle ¬      data.instanceData;    IF makeCmdSW THEN {  --there will be no instanceData hanging around      instanceData ¬ AdobeCommonInternal.AllocateInstanceData[data];      instanceData.cmdSW ¬ Tool.MakeFormSW[        window: w, formProc: ReportCmdSW, zone: data.heap]};    WITH instanceData SELECT FROM      report =>        IF data.context # NIL THEN          fieldsInReport ¬ data.heap.NEW[            AdobeCommon            .ReportFieldsSeq[data.context.arSH.fieldList.len]];      ENDCASE;    IF data.knownSystems # NIL AND data.context # NIL THEN      instanceData.formSW ¬ Tool.MakeFormSW[        window: w, formProc: MakeFieldsInReportSW, zone: data.heap]    ELSE      instanceData.formSW ¬ Tool.MakeFormSW[        window: w, formProc: NilFormProc];    AdobeCommon.DisableAdobeAborts[w];    AdobeCommonInternal.SetWindowName[      w,      IF data.knownSystems # NIL AND data.context # NIL AND      data.system # LAST[CARDINAL] THEN      data.knownSystems[data.system] ELSE NIL,      AdobeCommonInternal.reportHeraldName];    END;  ReportCmdSW: FormSW.ClientItemsProcType =    BEGIN OPEN FormSW;    formatSeq: TYPE = RECORD [      seq: SEQUENCE length: CARDINAL OF Enumerated];    windowData: AdobeCommon.DataHandle ¬ AdobeCommon.GetDataSW[sw];    instanceData: AdobeCommonInternal.InstanceDataHandle ¬      windowData.instanceData;    formats: LONG POINTER TO formatSeq ¬ windowData.heap.NEW[      formatSeq [AdobeCommon.FormatType.LAST.ORD + 1]];    formats[ORD[AdobeCommon.FormatType.plain]] ¬ [      "plain"L, AdobeCommon.FormatType.plain];    formats[ORD[AdobeCommon.FormatType.columns]] ¬ [      "columns"L, AdobeCommon.FormatType.columns];    formats[ORD[AdobeCommon.FormatType.template]] ¬ [      "template"L, AdobeCommon.FormatType.template];    WITH reportToolData: instanceData SELECT FROM      report => {        items ¬ AllocateItemDescriptor[          nReportParams, windowData.heap];        freeDesc ¬ TRUE;        items[reportPos] ¬ CommandItem[          tag: "Report"L, place: [0, line0], proc: ReportCommandProc,          z: windowData.heap];        items[formatPos] ¬ EnumeratedItem[          tag: "Output format"L, feedback: one, copyChoices: TRUE,          --proc: ??,-- value: @reportToolData.format,          choices: DESCRIPTOR[formats], z: windowData.heap];        items[overwritePos] ¬ BooleanItem[          tag: "Overwrite"L, switch: @reportToolData.overwrite,          z: windowData.heap];        items[resetPos] ¬ CommandItem[          tag: "Reset"L, proc: ReportCommandProc, z: windowData.heap];        items[setFieldsPos] ¬ CommandItem[          tag: "Set Fields"L, proc: ReportCommandProc,          z: windowData.heap];        items[rptBkgdPos] ¬ BooleanItem[          tag: "Use background"L, switch: @reportToolData.background,          z: windowData.heap];        items[outFilePos] ¬ StringItem[          tag: "Output file"L, string: @reportToolData.outputFile,          place: [0, nextLine], z: windowData.heap, inHeap: TRUE];        items[tmpltFilePos] ¬ StringItem[          tag: "Template file"L, string: @reportToolData.templateFile,          place: [225, sameLine], z: windowData.heap, inHeap: TRUE];        items[rptQlNamePos] ¬ StringItem[          tag: "QL to use"L, string: @reportToolData.qlName,          place: [0, nextLine], menuProc: AdobeCommon.QLNameHints,          z: windowData.heap, inHeap: TRUE]};      ENDCASE => ERROR;  --shouldn't happen    END;  MakeFieldsInReportSW: FormSW.ClientItemsProcType = {    OPEN FormSW;    windowData: AdobeCommon.DataHandle ¬ AdobeCommon.GetDataSW[sw];    instanceData: AdobeCommonInternal.InstanceDataHandle ¬      windowData.instanceData;    WITH toolData: instanceData SELECT FROM      report => {        OPEN fl: windowData.context.arSH.fieldList;        items ¬ AllocateItemDescriptor[          toolData.fieldsInReport.length + 1, windowData.heap];        items[0] ¬ TagOnlyItem[          tag: "Fields in the Report"L, place: [100, line0],          z: windowData.heap];        FOR i: CARDINAL IN [0..toolData.fieldsInReport.length) DO          toolData.fieldsInReport[i] ¬ FALSE;          items[i + 1] ¬ BooleanItem[            tag: fl[i].name, place: [175 * (i MOD 2), line1 - i / 2],            switch: @toolData.fieldsInReport[i], proc: CheckField,            z: windowData.heap];          ENDLOOP}      ENDCASE};  backStr: LONG STRING ¬ NIL;  NilFormProc: FormSW.ClientItemsProcType = {    freeDesc ¬ TRUE;    items ¬ FormSW.AllocateItemDescriptor[1];    items[0] ¬ FormSW.StringItem[invisible: TRUE, string: @backStr]};  CheckField: FormSW.NotifyProcType = {    windowData: AdobeCommon.DataHandle ¬ AdobeCommon.GetDataSW[sw];    instanceData: AdobeCommonInternal.InstanceDataHandle ¬      windowData.instanceData;    WITH toolData: instanceData SELECT FROM      report => {        IF toolData.fieldsInReport[index - 1] THEN          --the field has been turned on          WITH fli: windowData.context.arSH.fieldList[index - 1]          SELECT FROM            string => {              AdobeCommon.PostMessage[                windowData.msgSW, FALSE, "A report with "L];              AdobeCommon.PostMessage[                windowData.msgSW, FALSE, fli.name];              AdobeCommon.PostMessage[                windowData.msgSW, TRUE,                " wouldn't use accelerator files!"L]};            ENDCASE};      ENDCASE};  ReportCommandProc: FormSW.ProcType =    BEGIN    windowData: AdobeCommon.DataHandle ¬ AdobeCommon.GetDataSW[sw];    instanceData: AdobeCommonInternal.InstanceDataHandle ¬      windowData.instanceData;    MsgSW.Clear[windowData.msgSW];    IF windowData.system = LAST[CARDINAL] OR windowData.context = NIL OR windowData.knownSystems = NIL OR windowData.knownSystems.next = 0 THEN {      AdobeCommon.PostMessage[        windowData.msgSW, TRUE, "No available systems"L];      RETURN};    IF windowData.isBusy THEN      AdobeCommon.PostMessage[        windowData.msgSW, TRUE,        "Adobe system is Busy.  Please try again later. "L]    ELSE {      windowData.isBusy ¬ TRUE;      IF instanceData.background AND ~TajoMisc.toolDriverRunning THEN        Process.Detach[	  windowData.processID ¬ FORK AdobeCommon.CatchErrors[	    sw, item, index, windowData, ChooseReportCmd]]      ELSE {        windowData.processID ¬ Process.GetCurrent[];        AdobeCommon.CatchErrors[          sw, item, index, windowData, ChooseReportCmd]}};    END;  ChooseReportCmd: FormSW.ProcType =    BEGIN    windowData: AdobeCommon.DataHandle ¬ AdobeCommon.GetDataSW[sw];    BEGIN ENABLE UNWIND => windowData.isBusy ¬ FALSE;    SELECT index FROM      reportPos => ReportProc[windowData];      resetPos => ResetProc[windowData, TRUE];      setFieldsPos => SetProc[windowData];      ENDCASE => ERROR;    windowData.isBusy ¬ FALSE;    windowData.processID ¬ NIL;    END;    END;  SetProc: PROCEDURE [windowData: AdobeCommon.DataHandle] = {    templateList: AdobeCommon.Template;    instanceData: AdobeCommonInternal.InstanceDataHandle ¬      windowData.instanceData;    WITH reportData: instanceData SELECT FROM      report => {        IF reportData.format # template THEN GOTO notTemplate;	SetFormSWFieldInvisible[windowData, instanceData.formSW, TRUE, , TRUE];        ResetProc[windowData, FALSE];        templateList ¬ ParseTemplate[windowData ! templateProblem => GOTO badTemplateFile];        templateList ¬ FreeTemplateList[          templateList, windowData.heap];	SetFormSWFieldInvisible[windowData, instanceData.formSW, FALSE, , TRUE];        FormSW.Display[reportData.formSW]};      ENDCASE;    EXITS      badTemplateFile =>        AdobeCommon.PostMessage[          windowData.msgSW, TRUE,          "Invalid template file specified!"L];      notTemplate => NULL};  ResetProc: PROCEDURE [    windowData: AdobeCommon.DataHandle, redisplay: BOOLEAN] = {    instanceData: AdobeCommonInternal.InstanceDataHandle ¬      windowData.instanceData;    WITH reportData: instanceData SELECT FROM      report => {        SetFormSWFieldInvisible[windowData, instanceData.formSW, TRUE, , TRUE];        FOR i: CARDINAL IN [0..reportData.fieldsInReport.length) DO          reportData.fieldsInReport[i] ¬ FALSE; ENDLOOP;	SetFormSWFieldInvisible[windowData, instanceData.formSW, FALSE, , TRUE];        IF redisplay THEN FormSW.Display[reportData.formSW]};      ENDCASE};  ReportProc: PROCEDURE [windowData: AdobeCommon.DataHandle] = {    outputFH: MFile.Handle ¬ NIL;    sortKeysFileName: LONG STRING ¬ NIL;    reportQL: AdobeOps.QueryList ¬ NIL;    index: CARDINAL ¬ 0;    newReportFile, success: BOOLEAN ¬ TRUE;    useAccels: BOOLEAN ¬ TRUE;    instanceData: AdobeCommonInternal.InstanceDataHandle ¬      windowData.instanceData;    WITH reportData: instanceData SELECT FROM      report => {        BEGIN	ErrorCleanup: PROCEDURE = {	  IF reportData.outSH # NIL THEN {	    Stream.Delete[reportData.outSH];	    IF newReportFile THEN MFile.Delete[	      MFile.Acquire[reportData.outputFile, delete, []] !	      MFile.Error => CONTINUE]};	  IF reportData.sortKeysSH # NIL THEN {	    Stream.Delete[reportData.sortKeysSH];	    IF newReportFile AND ~String.Empty[sortKeysFileName] THEN MFile.Delete[	      MFile.Acquire[sortKeysFileName, delete, []] !	      MFile.Error => CONTINUE]}};       {ENABLE {          UNWIND => ErrorCleanup[];	  templateProblem => {ErrorCleanup[]; GOTO badTemplateFile}};        AdobeCommon.PostMessage[          windowData.msgSW, FALSE, "Reporting..."L];        --verify all parameters        outputFH ¬ MFile.ReadOnly[          reportData.outputFile, [] !          MFile.Error =>            IF code = noSuchFile THEN CONTINUE            ELSE GOTO outputFileProblem];        IF outputFH # NIL THEN {          IF ~reportData.overwrite THEN {            AdobeCommon.PostMessage[              windowData.msgSW, TRUE,              "The output file specified already exists!"L];            MFile.Release[outputFH];            RETURN};	  newReportFile ¬ FALSE;          MFile.Release[outputFH]};        reportQL ¬ AdobeCommon.FindThisQL[          reportData.qlName, windowData.context.arSH];        IF reportQL = NIL OR reportQL.list = NIL	  OR reportQL.list.len = 0 THEN {          AdobeCommon.PostMessage[            windowData.msgSW, TRUE, "Empty QueryList!"L];          RETURN};        reportData.outSH ¬ MStream.WriteOnly[          reportData.outputFile, [], text !          MStream.Error => GOTO outputFileProblem];        sortKeysFileName ¬ String.MakeString[	  windowData.heap, reportData.outputFile.length + 9];	UNTIL index = reportData.outputFile.length OR          reportData.outputFile[index] = '. DO 	  String.AppendChar[sortKeysFileName, reportData.outputFile[index]];	  index ¬ index + 1;	  ENDLOOP;	String.AppendString[sortKeysFileName, ".sortKeys"L];        reportData.sortKeysSH ¬ MStream.WriteOnly[          sortKeysFileName, [], text !          MStream.Error => GOTO sortKeysFileProblem];        success ¬ WriteReport[windowData, reportQL];}        END;  --enable        Stream.Delete[reportData.outSH];        Stream.Delete[reportData.sortKeysSH];	IF ~success THEN {	  MFile.Delete[	    MFile.Acquire[reportData.outputFile, delete, []] !	    MFile.Error => CONTINUE];	  MFile.Delete[	    MFile.Acquire[sortKeysFileName, delete, []] !	    MFile.Error => CONTINUE]};        AdobeCommon.PostMessage[windowData.msgSW, TRUE, "Done."L]};      ENDCASE => ERROR;    EXITS      outputFileProblem =>        AdobeCommon.PostMessage[          windowData.msgSW, TRUE,          "Cannot acquire the output file specified!"L];      sortKeysFileProblem =>        AdobeCommon.PostMessage[          windowData.msgSW, TRUE,          "Cannot acquire sortKeys file for the output file specified!"L];      badTemplateFile =>        AdobeCommon.PostMessage[          windowData.msgSW, TRUE,          "Invalid template file specified!"L]};  WriteReport: PROCEDURE [    data: AdobeCommon.DataHandle, ql: AdobeOps.QueryList]    RETURNS [success: BOOLEAN ¬ TRUE] = {    entryStartPos: LONG CARDINAL ¬ 0;    z: UNCOUNTED ZONE ¬ data.heap;    instanceData: AdobeCommonInternal.InstanceDataHandle ¬      data.instanceData;    qlStatus: AdobeCommon.SetStatus ¬ AdobeCommon.InitialSetStatus;    ar: AdobeOps.ARNumber;    arStream: Stream.Handle ¬ NIL;    fieldCount: CARDINAL ¬ 0;    useAccels: BOOLEAN ¬ TRUE;    template: AdobeCommon.Template ¬ NIL;    valueArray: LONG POINTER TO AdobeCommon.StringArray ¬ NIL;    listOfFields: LONG POINTER TO AdobeCommon.StringArray ¬ NIL;    options: Stream.InputOptions = [      TRUE, FALSE, FALSE, TRUE, TRUE, FALSE, TRUE, TRUE];        GetFromAccels: AdobeServer.StreamCheckoutProcType = {      --set up string space      FOR i: CARDINAL IN [0..valueArray.length) DO	valueArray[i] ¬ LOOPHOLE[Space.ScratchMap[1], LONG STRING];	valueArray[i]­ ¬ [0, 510,];        ENDLOOP;      DO	bytesTransferred: CARDINAL;	why: Stream.CompletionCode;	savedSST: Stream.SubSequenceType;	block: Stream.Block;	stop: BOOLEAN ¬ FALSE;	i: CARDINAL;	FOR i IN [0..valueArray.length) DO	  ENABLE {	    Stream.SSTChange => RETRY;	    Stream.EndOfStream, Stream.EndRecord => {	      why ¬ endRecord; stop ¬ TRUE; EXIT}};	  valueArray[i].length ¬ GetWord[cH.sH, options];	  block ¬ [	    LOOPHOLE[@valueArray[i].text], 0,	    IF valueArray[i].length MOD 2 = 0 THEN	      valueArray[i].length ELSE valueArray[i].length + 1];	  [bytesTransferred, why, savedSST] ¬ cH.sH.get[	    cH.sH, block, options];	  IF bytesTransferred # (IF valueArray[i].length MOD 2 = 0 THEN valueArray[i].length ELSE valueArray[i].length+1) THEN ERROR;	  ENDLOOP;	IF ~stop THEN entryStartPos ¬ PutValues[	  valueArray, data, template, entryStartPos]; 	IF why = endRecord THEN EXIT	ENDLOOP;      --clean up      FOR i: CARDINAL IN [0..valueArray.length) DO        [] ¬ Space.Unmap[LOOPHOLE[valueArray[i], LONG POINTER]];        ENDLOOP};          WITH instanceData SELECT FROM      report => {        entryBytes ¬ 0;	IF format = template THEN {	  SetFormSWFieldInvisible[data, instanceData.formSW, TRUE, , TRUE];          ResetProc[data, FALSE];          template ¬ ParseTemplate[data, TRUE];	  SetFormSWFieldInvisible[data, instanceData.formSW, FALSE, , TRUE];          FormSW.Display[formSW]}	ELSE orderInfo ¬ MakeOrderInfo[	  fieldsInReport, data.context.arSH.fieldList,	  data.context.arSH.formSWOrderArray[report], data.heap];	IF orderInfo.length = 0 THEN {	  success ¬ FALSE; GOTO noFieldsSpecified};        WriteHeader[	  data, data.context.arSH.fieldList, z];	listOfFields ¬ data.heap.NEW[	  AdobeCommon.StringArray[orderInfo.length]];	FOR i: CARDINAL IN [0..orderInfo.length) DO	    WITH data.context.arSH.fieldList[orderInfo[i].flIndex] SELECT FROM	      string => useAccels ¬ FALSE;	      ENDCASE;	    listOfFields[i] ¬ orderInfo[i].flName; 	  ENDLOOP;	valueArray ¬ z.NEW[	  AdobeCommon.StringArray[listOfFields.length]];        WriteSortHeader[data];        entryStartPos ¬ entryBytes;	IF useAccels THEN 	  AdobeServer.GetAcceleratorInfo[	    server: data.context.arSH.service,	    systemName: data.context.arSH.name,             version: data.context.arSH.version,	    ql: ql.list, fieldList: listOfFields,	    streamCheckout: GetFromAccels]	ELSE {	  arStream ¬ AdobeToolContext.CreateStream[            data.context.arSH.fieldList];	  [ar, qlStatus] ¬ AdobeCommon.GetNextAR[ql.list, qlStatus];	  WHILE ar # AdobeOps.nilARNumber DO	    GetARVaues[	      ar, listOfFields, valueArray, orderInfo, arStream,	      data ! ARAccess.Error => {	        SELECT why FROM		  arNotFound => {		    AdobeCommon.PostMessage[		      data.msgSW, FALSE, "AR "L];		    AdobeCommon.PostNumber[data.msgSW, FALSE, ar];		    AdobeCommon.PostMessage[		      data.msgSW, TRUE, " was not found."L];		    [ar, qlStatus] ¬ AdobeCommon.GetNextAR[ql.list, qlStatus]};		  ENDCASE;		  LOOP}];	    entryStartPos ¬ PutValues[valueArray, data, template, entryStartPos];	    [ar, qlStatus] ¬ AdobeCommon.GetNextAR[ql.list, qlStatus];	    ENDLOOP;	  Stream.Delete[arStream]};	IF template # NIL THEN 	  template ¬ FreeTemplateList[template, data.heap];};      ENDCASE;    z.FREE[@valueArray];    EXITS      noFieldsSpecified => {        AdobeCommon.PostMessage[data.msgSW, TRUE, "Select the fields to be included in the report."L];	}};      PutValues: PROCEDURE[    valueArray: LONG POINTER TO AdobeCommon.StringArray,    data: AdobeCommon.DataHandle, template: AdobeCommon.Template,    startPos: LONG CARDINAL]    RETURNS [entryStartPos: LONG CARDINAL] = {    instanceData: AdobeCommonInternal.InstanceDataHandle ¬      data.instanceData;    entryStartPos ¬ startPos;     WITH instanceData SELECT FROM      report => {	entryBytes ¬ 0;	SELECT format FROM	  plain, columns =>	    FOR i: CARDINAL IN [0..orderInfo.length) DO	      SELECT format FROM		plain => WriteReportPair[		  orderInfo[i], valueArray[i], data.instanceData,		  data.context.arSH.fieldList];		columns =>  WriteColumnField[		  orderInfo[i], valueArray[i], data, data.heap];		ENDCASE;	      ENDLOOP;	  template => {	    orderCount: CARDINAL ¬ 0;	    i: CARDINAL;	    templateItem: AdobeCommon.Template ¬ template;	    WHILE templateItem # NIL DO	      WITH templateItem SELECT FROM		fixed => {		  FOR i IN [0..width) DO		    WriteChar[		      outSH,		      IF i < valueArray[orderCount].length THEN			valueArray[orderCount][i]		      ELSE Ascii.SP, @entryBytes];		    ENDLOOP;		  WriteSortEntry[		    valueArray[orderCount],		    @data.context.arSH.fieldList[		      orderInfo[orderCount].flIndex],		    sortKeysSH];		  orderCount ¬ orderCount + 1};		variable => {		  WriteString[		    outSH, valueArray[orderCount], @entryBytes];		  WriteSortEntry[		    valueArray[orderCount],		    @data.context.arSH.fieldList[		      orderInfo[orderCount].flIndex],		    sortKeysSH];		  orderCount ¬ orderCount + 1};		string =>		  IF suppressFieldName THEN {		    FOR i IN [0..nameStart) DO		      WriteChar[outSH, s[i], @entryBytes]; ENDLOOP;		    FOR i IN [nameStart + nameLength..s.length) DO		      WriteChar[outSH, s[i], @entryBytes]; ENDLOOP}		  ELSE WriteString[outSH, s, @entryBytes];		ENDCASE;	      templateItem ¬ templateItem.next;	      ENDLOOP};	  ENDCASE;	IF format = columns THEN ForceOutRow[instanceData];	IF format = plain THEN 	  WriteParagraphMark[outSH, format, @entryBytes];	WriteSortPositions[sortKeysSH, entryStartPos, entryBytes];	entryStartPos ¬ entryStartPos + entryBytes};      ENDCASE};        WriteHeader: PROCEDURE [    data: AdobeCommon.DataHandle,    fl: AdobeOps.FieldList, z: UNCOUNTED ZONE] =    BEGIN    reportData: AdobeCommonInternal.InstanceDataHandle ¬ data.instanceData;    date: LONG STRING ¬ Date.PackedToString[Time.Current[]];    WITH reportData SELECT FROM      report => {        WriteString[outSH, "Report on file: "L, @entryBytes];        WriteString[outSH, outputFile, @entryBytes];        WriteChar[outSH, Ascii.SP, @entryBytes];        WriteLine[outSH, date, @entryBytes];        WriteParagraphMark[outSH, format, @entryBytes];        Heap.systemZone.FREE[@date];        IF format = columns THEN {          InitRowBuf[reportData, z];          FOR i: CARDINAL IN [0..orderInfo.length) DO	    WriteColumnField[	      orderInfo[i], orderInfo[i].flName, data, data.heap, TRUE]; -- oops set bool for coulumn heading           << WriteReportPair[              orderInfo[i], orderInfo[i].flName, reportData, fl];>>            ENDLOOP;          ForceOutRow[reportData];          WriteDelimiter[outSH, format, @entryBytes];          WriteDelimiter[outSH, format, @entryBytes]}};      ENDCASE;    END;  NotDoneYet: PROCEDURE [windowData: AdobeCommon.DataHandle] =    BEGIN    AdobeCommon.PostMessage[      windowData.msgSW, TRUE, "Not Done Yet. "L];    END;  InitRowBuf: PROCEDURE [    reportData: AdobeCommonInternal.InstanceDataHandle,    z: UNCOUNTED ZONE] = {    WITH reportData SELECT FROM      report => {        FOR i: CARDINAL IN [0..orderInfo.length) DO          rowLength ¬            rowLength + orderInfo[i].colWidth + AdobeCommon.ColSpace;          ENDLOOP;        rowBuffer.s ¬ String.MakeString[z, rowLength];        rowBuffer.next ¬ NIL};      ENDCASE};  MakeOrderInfo: PROCEDURE [    fieldsInReport: AdobeCommon.ReportFields, fl: AdobeOps.FieldList,    reportOrderArray: AdobeOps.UserSpecifiedOrder, z: UNCOUNTED ZONE]    RETURNS [orderInfo: AdobeCommon.OrderInfo] = {    itemCount: CARDINAL ¬ 0;    FOR i: CARDINAL IN [0..fieldsInReport.length) DO      IF fieldsInReport[i] THEN itemCount ¬ itemCount + 1; ENDLOOP;    orderInfo ¬ z.NEW[AdobeCommon .OrderInfoObject[itemCount]];    itemCount ¬ 0;    --orderInfo is composed of entries only for those fields which are to appear in the report    FOR i: CARDINAL IN [0..reportOrderArray.length) DO      IF fieldsInReport[reportOrderArray[i]] THEN {        orderInfo[itemCount].flName ¬ String.CopyToNewString[          fl[reportOrderArray[i]].name, z];        orderInfo[itemCount].flIndex ¬ reportOrderArray[i];        IF fl[reportOrderArray[i]].defaultInfo[report].width # 0 THEN          orderInfo[itemCount].colWidth ¬ fl[            reportOrderArray[i]].defaultInfo[report].width        ELSE          orderInfo[itemCount].colWidth ¬            WITH fli: fl[reportOrderArray[i]] SELECT FROM              arId => MAX[5, fli.name.length],              numeric => MAX[10, fli.name.length],              fixedLengthString => MAX[                fli.maxLength / 2, fli.name.length],              string => MAX[40, fli.name.length],              dateTime => MAX[9, fli.name.length],              enumerated => MAX[10, fli.name.length],              ENDCASE => 0;        IF itemCount # 0 THEN          orderInfo[itemCount].colIndex ¬            orderInfo[itemCount - 1].colIndex + orderInfo[              itemCount - 1].colWidth + AdobeCommon.ColSpace        ELSE orderInfo[itemCount].colIndex ¬ 0;        itemCount ¬ itemCount + 1};      ENDLOOP};  GetARVaues: PROCEDURE [    ar: AdobeOps.ARNumber,    fields: LONG POINTER TO AdobeCommon.StringArray,    valueArray: LONG POINTER TO AdobeCommon.StringArray,    orderInfo: AdobeCommon.OrderInfo, arStream: Stream.Handle,     data: AdobeCommon.DataHandle] = {    arH: ARAccess.ARHandle;    --must set the length of value in data table to 0 just in case the AR files don't have all the fields in the system     AdobeToolContext.ResetDataTableValues[arStream];    arH ¬ ARAccess.GetAR[data.accessSession, ar];    ARAccess.ExamineAR[data.accessSession, arH, arStream];    --contents must go into the array in the order they're to be used in the report    FOR i: CARDINAL IN [0..orderInfo.length) DO      valueArray[i] ¬ AdobeToolContext.GetValuePairFromTable[	orderInfo[i].flIndex, arStream];      ENDLOOP;    arH ¬ ARAccess.FreeAR[data.accessSession, arH]};  ParseTemplate: PROCEDURE [    data: AdobeCommon.DataHandle, setOrdering: BOOLEAN ¬ FALSE]    RETURNS [template: AdobeCommon.Template] = {    token: LONG STRING ¬ String.MakeString[data.heap, 200];    sh: Stream.Handle ¬ NIL;    char: CHARACTER ¬ Ascii.NUL;    tail, next: AdobeCommon.Template ¬ NIL;    latestField: CARDINAL ¬ LAST[CARDINAL];    start, length: CARDINAL ¬ 0;    foundField: BOOLEAN ¬ FALSE;    suppress: BOOLEAN ¬ FALSE;    suppressionStart, suppressionEnd: CARDINAL ¬ 0;    orderIndex: CARDINAL ¬ 0;    tempOrder: AdobeCommon.OrderInfo ¬ NIL;    instanceData: AdobeCommonInternal.InstanceDataHandle ¬      data.instanceData;    GetToken: PROCEDURE =      BEGIN OPEN String;      ENABLE Stream.EndOfStream => {char ¬ Ascii.NUL; CONTINUE};      token.length ¬ 0;      suppress ¬ FALSE;      suppressionEnd ¬ 0;      suppressionStart ¬ 0;      DO        ENABLE StringBoundsFault => GOTO Bounds;        SELECT char ¬        (IF char = Ascii.NUL THEN Stream.GetChar[sh] ELSE char) FROM          '' =>  -- Don't interprete next char.            BEGIN            char ¬ Stream.GetChar[sh];            AppendChar[token, char];            END;          '# =>            BEGIN            IF token.length = 0 THEN              WHILE char = '# DO                AppendChar[token, char];                char ¬ Stream.GetChar[sh];                ENDLOOP;            EXIT;            END;          '@ =>            BEGIN            IF token.length = 0 THEN              WHILE char = '@ DO                AppendChar[token, char];                char ¬ Stream.GetChar[sh];                ENDLOOP;            EXIT;            END;          '< =>  --assume start of field name            BEGIN            suppress ¬ TRUE;            suppressionStart ¬ token.length;            END;          '> =>  --assume end of field name            suppressionEnd ¬ token.length;          ENDCASE => AppendChar[token, char];        char ¬ Stream.GetChar[sh];        ENDLOOP;      EXITS        Bounds =>          BEGIN          AdobeCommon.PostMessage[            data.msgSW, TRUE, "String too long in template file!"L];          token.length ¬ 0;          END;      END;    template ¬ NIL;    WITH instanceData SELECT FROM      report =>         sh ¬ MStream.ReadOnly[	  templateFile, [] ! MStream.Error => ERROR templateProblem];      ENDCASE;    IF setOrdering THEN      tempOrder ¬ data.heap.NEW[AdobeCommon .OrderInfoObject[5]];    DO      GetToken[];      IF suppress THEN suppress ¬ suppressionEnd # 0;      IF token.length > 0 THEN        BEGIN        next ¬ data.heap.NEW[AdobeCommon.TemplateObject];        SELECT token[0] FROM          '# =>            next­ ¬ AdobeCommon.TemplateObject[              NIL, fixed[width: token.length]];          '@ => next­ ¬ AdobeCommon.TemplateObject[NIL, variable[]];          ENDCASE =>            next­ ¬ AdobeCommon.TemplateObject[              NIL, string[              s: String.CopyToNewString[s: token, z: data.heap],              suppressFieldName: suppress]];        IF template = NIL THEN template ¬ next        ELSE          BEGIN          FOR tail ¬ template, tail.next UNTIL tail.next = NIL DO            ENDLOOP;          tail.next ¬ next;          END;        WITH next SELECT FROM          string => {            name: String.SubStringDescriptor;            [latestField, start, length] ¬ FindFieldNameInString[              token, data.context.arSH.fieldList];            nameStart ¬ start;            nameLength ¬ length;            IF suppressionStart # nameStart              OR suppressionEnd # nameStart + nameLength THEN              suppressFieldName ¬ FALSE;            IF setOrdering AND latestField # LAST[CARDINAL] THEN {              IF orderIndex = tempOrder.length THEN {                temp: AdobeCommon.OrderInfo ¬ data.heap.NEW[                  AdobeCommon .OrderInfoObject[tempOrder.length + 5]];                FOR i: CARDINAL IN [0..tempOrder.length) DO                  temp[i] ¬ tempOrder[i]; ENDLOOP;                data.heap.FREE[@tempOrder];                tempOrder ¬ temp};              tempOrder[orderIndex].flIndex ¬ latestField;              tempOrder[orderIndex].flName ¬ String.MakeString[                data.heap, length];              name ¬ [token, start, length];              String.AppendSubString[                tempOrder[orderIndex].flName, @name];              orderIndex ¬ orderIndex + 1}};          ENDCASE =>            WITH instanceData SELECT FROM              report =>                IF latestField # LAST[CARDINAL] THEN                  fieldsInReport[latestField] ¬ foundField ¬ TRUE;              ENDCASE;        END      ELSE EXIT;      ENDLOOP;    IF ~foundField THEN      BEGIN      AdobeCommon.PostMessage[        data.msgSW, TRUE,        "No field names recognized in template file!"L];      --template ¬ FreeTemplateList[template, data.heap];      END    ELSE      WITH reportData: instanceData SELECT FROM        report => {          reportData.orderInfo ¬ data.heap.NEW[            AdobeCommon .OrderInfoObject[orderIndex]];          FOR i: CARDINAL IN [0..orderIndex) DO            reportData.orderInfo[i] ¬ tempOrder[i]; ENDLOOP;          data.heap.FREE[@tempOrder]};        ENDCASE;    Stream.Delete[sh]};  FreeTemplateList: PROCEDURE [    template: AdobeCommon.Template, z: UNCOUNTED ZONE]    RETURNS [nilTemplate: AdobeCommon.Template ¬ NIL] = {    Free: PROCEDURE [t: AdobeCommon.Template] = {      IF t.next # NIL THEN Free[t.next];      WITH t SELECT FROM string => z.FREE[@s]; ENDCASE;      z.FREE[@t]};    Free[template]};  FindFieldNameInString: PROCEDURE [    s: LONG STRING, fl: AdobeOps.FieldList]    RETURNS [fli, start, length: CARDINAL] =    BEGIN  -- Find longest field name that can.    i, astart: CARDINAL;    found: BOOLEAN;    fli ¬ LAST[CARDINAL];    length ¬ 0;    FOR i IN [0..fl.len) DO      [found, astart] ¬ SubString[s, fl[i].name];      IF found THEN        SELECT fli FROM          LAST[CARDINAL] => {            fli ¬ i; start ¬ astart; length ¬ fl[fli].name.length};          ENDCASE =>            IF fl[fli].name.length < fl[i].name.length THEN {              fli ¬ i; start ¬ astart; length ¬ fl[fli].name.length};      ENDLOOP;    END;  SubString: PROCEDURE [    -- TRUE IFF s2 is contained in s1    s1, s2: LONG STRING] RETURNS [found: BOOLEAN, start: CARDINAL] =    BEGIN OPEN String;    i: CARDINAL;    s1ss, s2ss: SubStringDescriptor;    s2ss ¬ [base: s2, offset: 0, length: s2.length];    s1ss ¬ [base: s1, offset: 0, length: s2.length];    IF s2.length > s1.length THEN RETURN[FALSE, 0];    FOR i IN [0..s1.length - s2.length] DO      s1ss.offset ¬ i;      IF EquivalentSubString[@s1ss, @s2ss] THEN        RETURN[TRUE, s1ss.offset]      ENDLOOP;    RETURN[FALSE, 0]    END;  --Output Routines  WriteReportPair: PROCEDURE [    orderItem: AdobeCommon.OrderItem, flValue: LONG STRING,    reportData: AdobeCommonInternal.InstanceDataHandle,    fieldList: AdobeOps.FieldList] =    BEGIN    WITH reportData SELECT FROM      report => {        IF flValue = NIL THEN flValue ¬ ""L;        SELECT format FROM          columns => {            --used only for printing column headings.            sp: CARDINAL;            String.AppendString[rowBuffer.s, flValue];            sp ¬              orderItem.colWidth - flValue.length +                AdobeCommon.ColSpace;	    FOR i: CARDINAL IN [rowBuffer.s.length..rowBuffer.s.length + sp) DO              rowBuffer.s[i] ¬ Ascii.SP; ENDLOOP;            rowBuffer.s.length ¬ rowBuffer.s.length + sp};          plain => {            WriteString[outSH, orderItem.flName, @entryBytes];            WriteString[outSH, ": "L, @entryBytes];            WriteLine[outSH, flValue, @entryBytes];            WriteSortEntry[              flValue, @fieldList[orderItem.flIndex], sortKeysSH]};          ENDCASE};      ENDCASE;    END;  Pad: PROCEDURE [sp: CARDINAL, str: LONG STRING] = {    FOR i: CARDINAL IN [str.length..str.length+sp) DO      str[i] ¬ Ascii.SP; ENDLOOP; --avoids overhead of AppendChar call    str.length ¬ str.length+sp};      GetWord: PROCEDURE [    sH: Stream.Handle, options: Stream.InputOptions]     RETURNS [word: Stream.Word] = INLINE {      [] ¬ sH.get[sH, Stream.Block[LOOPHOLE[LONG[@word]], 0, 2], options]};  WriteColumnField: PROCEDURE [    orderItem: AdobeCommon.OrderItem, flValue: LONG STRING,    data: AdobeCommon.DataHandle, z: UNCOUNTED ZONE,    columnHead: BOOLEAN ¬ FALSE] = {    totalSpaces: CARDINAL ¬ orderItem.colWidth + AdobeCommon.ColSpace;    instanceData: AdobeCommonInternal.InstanceDataHandle ¬      data.instanceData;    WITH instanceData SELECT FROM      report => {        IF ~columnHead THEN WriteSortEntry[          flValue, @data.context.arSH.fieldList[orderItem.flIndex],          sortKeysSH];        IF String.Empty[flValue] THEN {	  Pad[totalSpaces, rowBuffer.s]; RETURN};        IF flValue.length <= orderItem.colWidth THEN {          --fits on one line          String.AppendString[rowBuffer.s, flValue];          Pad[totalSpaces - flValue.length, rowBuffer.s]}        ELSE {  --must be broken onto more than one line.          row: LONG POINTER TO AdobeCommon.RowBuffer ¬ @rowBuffer;	  start, index, lastEnd: CARDINAL ¬ 0;	  done: BOOLEAN ¬ FALSE;	  str: String.SubStringDescriptor;	  str.base ¬ flValue;          WHILE ~done DO	    lastEnd ¬ start + orderItem.colWidth - 1;            FOR index IN [start..start+orderItem.colWidth) DO	      SELECT flValue[index] FROM		Ascii.SP, Ascii.TAB => lastEnd ¬ index;	        Ascii.CR => {lastEnd ¬ index;		  IF index = flValue.length - 1 THEN done ¬ TRUE;		  EXIT};		ENDCASE => NULL;	      IF index = flValue.length - 1 THEN {	        done ¬ TRUE; lastEnd ¬ index; EXIT};	      ENDLOOP;	    str.offset ¬ start;	    SELECT flValue[lastEnd] FROM	      Ascii.CR =>  {	        str.length ¬ lastEnd-start;--skip CR		start ¬ start + str.length+1};	      ENDCASE => {	        --add 1 to length so SP break goes on same line unless		-- at end of flValue		IF done THEN str.length ¬ lastEnd-start + 1	        ELSE str.length ¬ MIN[		  lastEnd-start+1, orderItem.colWidth];	        start ¬ start + str.length};            String.AppendSubString[row.s, @str];            Pad[totalSpaces - str.length, row.s];	    IF ~done AND index < flValue.length THEN 	      IF row.next # NIL THEN {                row ¬ row.next;                Pad[orderItem.colIndex - row.s.length, row.s]}	      ELSE {		row.next ¬ z.NEW[		  AdobeCommon.RowBuffer ¬ [		  String.MakeString[z, rowLength], NIL]];		row ¬ row.next;		Pad[orderItem.colIndex, row.s]};            ENDLOOP}};      ENDCASE};  WriteLine: PROCEDURE [    sh: Stream.Handle, s: LONG STRING,    entryBytes: LONG POINTER TO CARDINAL] = {    WriteString[sh, s, entryBytes];    WriteChar[sh, Ascii.CR, entryBytes]};  WriteString: PROCEDURE [    sh: Stream.Handle, s: LONG STRING,    entryBytes: LONG POINTER TO CARDINAL] = {    IF s # NIL THEN {      Stream.PutString[sh, s]; entryBytes­ ¬ entryBytes­ + s.length}};  WriteChar: PROCEDURE [    sh: Stream.Handle, c: CHARACTER,    entryBytes: LONG POINTER TO CARDINAL] = {    Stream.PutChar[sh, c]; entryBytes­ ¬ entryBytes­ + 1};  WriteParagraphMark: PROCEDURE [    sh: Stream.Handle, outType: AdobeCommon.FormatType,    entryBytes: LONG POINTER TO CARDINAL] = {    WriteChar[sh, Ascii.CR, entryBytes]};    <<seems to me that WriteParagraphMark appears in two places and all we want it to do is to output a CR    IF outType = template THEN {      WriteChar[sh, Ascii.ControlZ, entryBytes];      WriteChar[sh, Ascii.CR, entryBytes]}    ELSE WriteDelimiter[sh, outType, entryBytes]};>>  WriteDelimiter: PROCEDURE [    sh: Stream.Handle, outType: AdobeCommon.FormatType,    entryBytes: LONG POINTER TO CARDINAL] = {    IF outType # template THEN WriteChar[sh, Ascii.CR, entryBytes]};  ForceOutRow: PROCEDURE [    reportData: AdobeCommonInternal.InstanceDataHandle] = {    row: AdobeCommon.RowBuffer;    WITH reportData­ SELECT FROM      report => {        row ¬ rowBuffer;        DO          IF row.s.length # 0 THEN            WriteLine[outSH, row.s, @entryBytes];          row.s.length ¬ 0;          IF row.next # NIL THEN row ¬ row.next­ ELSE EXIT;          ENDLOOP};      ENDCASE};  --Sortkeys file routines  WriteSortHeader: PROCEDURE [data: AdobeCommon.DataHandle] = {    instanceData: AdobeCommonInternal.InstanceDataHandle ¬      data.instanceData;    WITH reportData: instanceData SELECT FROM      report => {        FOR i: CARDINAL IN [0..reportData.orderInfo.length) DO          WITH          fli: data.context.arSH.fieldList[            reportData.orderInfo[i].flIndex] SELECT FROM            string => LOOP;            ENDCASE =>              WriteSortString[                reportData.orderInfo[i].flName, TRUE,                reportData.sortKeysSH];          ENDLOOP;        WriteSortEnd[reportData.sortKeysSH]};      ENDCASE};  WriteSortPositions: PROCEDURE [    sortSH: Stream.Handle, start: LONG CARDINAL, length: CARDINAL] = {    ln: Inline.LongNumber;    ln.lc ¬ start;    --copied from old, not sure this is all ok.    WriteSortNumber[ln.highbits --page-- , 0, TRUE, sortSH];    WriteSortNumber[ln.lowbits --byte-- , 0, TRUE, sortSH];    WriteSortNumber[length, 0, TRUE, sortSH];    Stream.PutChar[sortSH, Ascii.CR]};  WriteSortEntry: PROCEDURE [    value: LONG STRING, flItem: AdobeOps.FieldItemHandle,    sortSH: Stream.Handle] =    BEGIN    WITH flItem­ SELECT FROM      arId => WriteARId[value, 5, TRUE, sortSH];       numeric => WriteNumeric[value, TRUE, sortSH];      dateTime =>        BEGIN        u: Time.Unpacked;	u ¬ Time.Unpack[Date.StringToPacked[value 	  ! Date.Unintelligible => {u.year ¬ 0; u.month ¬ 0;	  u.day ¬ 0; u.hour ¬ 0; u.minute ¬ 0;	  u.second ¬ 0; CONTINUE}].dt];        WriteSortNumber[u.year, 4, FALSE, sortSH];        WriteSortNumber[u.month, 2, FALSE, sortSH];        WriteSortNumber[u.day, 2, FALSE, sortSH];        WriteSortNumber[u.hour, 2, FALSE, sortSH];        WriteSortNumber[u.minute, 2, FALSE, sortSH];        WriteSortNumber[u.second, 2, TRUE, sortSH];        END;      string => RETURN;      ENDCASE => WriteSortString[value, TRUE, sortSH];    END;  WriteARId: PROCEDURE [    val: LONG STRING, len: CARDINAL, nulToo: BOOLEAN,    sortSH: Stream.Handle] = {    i: CARDINAL;    str: STRING = [10];    str.length ¬ len;    --this is a workaround if ARIDs in the AR Files are bogus. should take this out eventually. workstation would freeze if val.length > len.    IF val.length <= len THEN {      FOR i IN [0..len - val.length) DO str[i] ¬ '0; ENDLOOP;      FOR i IN [len - val.length..len) DO	str[i] ¬ val[i - (len - val.length)]; ENDLOOP}    ELSE      FOR i IN [0..str.length) DO str[i] ¬ '0; ENDLOOP;          WriteSortString[str, nulToo, sortSH]};  WriteNumeric: PROCEDURE [    val: LONG STRING, nulToo: BOOLEAN, sortSH: Stream.Handle] = {    -- cloned from WriteARId above.    -- all numeric strings in the sortKey file are 10 chars long.    -- enough for string rep of largest LONG CARDINAL (2­32)    maxCharsPerLongCardinal: CARDINAL = 10;    str: STRING = [maxCharsPerLongCardinal];     i: CARDINAL;    str.length ¬ maxCharsPerLongCardinal;    IF val.length <= maxCharsPerLongCardinal THEN {      pad: CARDINAL ¬ maxCharsPerLongCardinal - val.length;      FOR i IN [0..pad) DO         str[i] ¬ '0; ENDLOOP;      FOR i IN [pad..maxCharsPerLongCardinal) DO	str[i] ¬ val[i - pad]; ENDLOOP}    ELSE -- safety valve. should never happen.      FOR i IN [0..str.length) DO str[i] ¬ '0; ENDLOOP;          WriteSortString[str, nulToo, sortSH]};  WriteSortNumber: PROCEDURE [    num: UNSPECIFIED, len: CARDINAL, nulToo: BOOLEAN,    sortSH: Stream.Handle] =    BEGIN  -- Pack num into string of length len and write.    -- If len is zero then don't pad    i: CARDINAL;    str: STRING = [10];    str.length ¬ 0;    String.AppendNumber[str, num, 10];    IF len > 0 AND str.length < len THEN      BEGIN      oldLen: CARDINAL ¬ str.length;      str.length ¬ len;      FOR i IN [0..oldLen) DO        str[len - i - 1] ¬ str[oldLen - i - 1]; ENDLOOP;      FOR i IN [0..len - oldLen) DO str[i] ¬ '0; ENDLOOP;      END;    WriteSortString[str, nulToo, sortSH];    RETURN;    END;  WriteSortString: PROCEDURE [    s: LONG STRING, nulToo: BOOLEAN, sortSH: Stream.Handle] =    BEGIN    i: CARDINAL;    IF s # NIL THEN      FOR i IN [0..s.length) DO        -- ARSortTool can't handle CRs as data in sortkeys file.        Stream.PutChar[          sortSH, IF s[i] = Ascii.CR THEN Ascii.SP ELSE s[i]];        ENDLOOP;    IF nulToo THEN Stream.PutChar[sortSH, Ascii.NUL];    RETURN;    END;  WriteSortEnd: PROCEDURE [sortSH: Stream.Handle] = {    Stream.PutChar[sortSH, Ascii.CR]};      SetFormSWFieldInvisible: PROCEDURE [    data: AdobeCommon.DataHandle, wH: Window.Handle, invisible: BOOLEAN,    index: CARDINAL ¬ 0, all: BOOLEAN ¬ FALSE] =    BEGIN    inst: AdobeCommonInternal.InstanceDataHandle ¬ data.instanceData;    formItem: FormSW.ItemHandle;    IF all THEN {      FOR i: CARDINAL IN         [0..data.context.arSH.formSWOrderArray[data.tool].length) DO	formItem ¬ FormSW.FindItem[inst.formSW, i];	formItem.flags.invisible ¬ invisible;	ENDLOOP}    ELSE {      formItem ¬ FormSW.FindItem[inst.formSW, index];      formItem.flags.invisible ¬ invisible};    END;  END. -- RLC			28-Jul-86  9:23:15 Recompile to make df Consistent. Add {} pair to pass compilation-- RLC			15-Sep-86 15:47:41 Repair damage from coulmn wrapping fix which broke sorting.-- RLC			 8-Oct-87 10:52:12 Add WriteNumeric, a clone of WriteARId using a max string size of 10 instead of 5. (AR12070)
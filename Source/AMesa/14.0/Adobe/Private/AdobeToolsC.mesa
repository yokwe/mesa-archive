-- File: AdobeToolsC.mesa - created by JCS. Last edit:-- JCS                  2-Mar-86 14:58:34-- RSF		        17-Apr-85 13:06:40-- Copyright (C) 1985, 1986 by Xerox Corporation. All rights reserved. -- QueryList  DIRECTORY  AdobeCommon USING [    AddToOtherQLList, AddToSet, CatchErrors, DataHandle, DisableAdobeAborts,     FreeHintStrings, GetData,    GetDataSW, GetNextAR, GrowSet, InitialSetStatus, PostMessage,    SetStatus, StringArray],  AdobeCommonInternal USING [    AllocateInstanceData, InstanceDataHandle, InstanceData,    queryListHeraldName, SetWindowName],  AdobeOps USING [ARNumber, ARSystemHandle, QLHandle, QueryList, QueryListBody,      SetOfARs, SetOfARsObject, z],  AdobeServer USING [ReadLastARNumber],  FormSW USING [AllocateItemDescriptor, ClientItemsProcType, CommandItem,  DisplayItem, FindItem, ItemHandle, line0, line1, line2, MenuProcType, ProcType, StringItem],  MsgSW USING [Clear],  MStream USING [Error, Handle, ReadOnly, ReleaseData, WriteOnly],  Process USING [Detach, GetCurrent],  Stream USING [Delete, EndOfStream, GetChar, Handle, PutChar, PutString],  String USING [AppendChar, AppendLongNumber, AppendStringAndGrow, CopyToNewString, Equivalent,     FreeString, MakeString, StringToLongNumber],  TajoMisc USING [toolDriverRunning],  Tool USING [MakeFormSW],  Window USING [Handle];  AdobeToolsC: PROGRAM  IMPORTS AdobeCommon, AdobeCommonInternal, AdobeOps, AdobeServer, FormSW, MsgSW, MStream, Process, Stream, String, TajoMisc, Tool   EXPORTS AdobeCommonInternal =BEGIN    --globals for queryList  unionPos: CARDINAL = 0;  intsctnPos: CARDINAL = 1;  compPos: CARDINAL = 2;  diffPos: CARDINAL = 3;  xorPos: CARDINAL = 4;  copyToListPos: CARDINAL = 5;  copyToFilePos: CARDINAL =6;  op1Pos: CARDINAL = 7;   op2Pos: CARDINAL = 8;   resultPos: <<PUBLIC>> CARDINAL = 9;--used in QLNameHints in AdobeCommonImplE   nQLParams: CARDINAL = 10;    backStr: LONG STRING ¬ NIL;   NilFormProc: FormSW.ClientItemsProcType = {    freeDesc ¬ TRUE;    items ¬ FormSW.AllocateItemDescriptor[1];    items[0] ¬ FormSW.StringItem[invisible: TRUE, string: @backStr]};    CreateQuerylistSW: PUBLIC PROCEDURE[   w: Window.Handle, makeCmdSW: BOOLEAN ¬ TRUE]   RETURNS[initialMsg: LONG STRING ¬ NIL] =    BEGIN   data: AdobeCommon.DataHandle ¬ AdobeCommon.GetData[w];   instanceData: AdobeCommonInternal.InstanceDataHandle ¬ data.instanceData;   IF makeCmdSW THEN {     instanceData ¬ AdobeCommonInternal.AllocateInstanceData[data];     instanceData.cmdSW ¬ Tool.MakeFormSW[       window: w, formProc: QueryListCmdSW, zone: data.heap]};       instanceData.formSW ¬ Tool.MakeFormSW[     window: w, formProc: QueryListFormSW, zone: data.heap];   AdobeCommon.DisableAdobeAborts[w];   AdobeCommonInternal.SetWindowName[     w, IF data.knownSystems # NIL AND data.context # NIL AND     data.system # LAST[CARDINAL] THEN     data.knownSystems[data.system] ELSE NIL,     AdobeCommonInternal.queryListHeraldName];   END;  QueryListCmdSW: FormSW.ClientItemsProcType = BEGIN OPEN FormSW;   windowData: AdobeCommon.DataHandle ¬ AdobeCommon.GetDataSW[sw];   instanceData: AdobeCommonInternal.InstanceDataHandle ¬     windowData.instanceData;   WITH qLToolData: instanceData SELECT FROM   queryList => {     items ¬ AllocateItemDescriptor[nQLParams, windowData.heap];     freeDesc ¬ TRUE;     items[unionPos] ¬ CommandItem[	tag: "Union"L, place: [0, line0], proc: QLCommandProc,	z: windowData.heap];      items[intsctnPos] ¬ CommandItem[        tag: "Intersection"L, place: [72, line0], 	proc: QLCommandProc, z: windowData.heap];      items[compPos] ¬ CommandItem[        tag: "Complement"L, place: [195, line0], 	proc: QLCommandProc, z: windowData.heap];      items[diffPos] ¬ CommandItem[        tag: "Difference"L, place: [306, line0], 	proc: QLCommandProc, z: windowData.heap];      items[xorPos] ¬ CommandItem[        tag: "XOR"L, place: [408, line0], 	proc: QLCommandProc, z: windowData.heap];      items[copyToListPos] ¬ CommandItem[        tag: "CopyToQueryList"L, place: [0, line1], 	proc: QLCommandProc, z: windowData.heap];      items[copyToFilePos] ¬ CommandItem[        tag: "CopyToFile"L, place: [119, line1], 	proc: QLCommandProc, z: windowData.heap];      items[op1Pos] ¬ StringItem[	tag: "Operand1"L, string: @qLToolData.operand1,	place: [0, line2], menuProc: QLNameHintsForQueryList,        z: windowData.heap, inHeap: TRUE];      items[op2Pos] ¬ StringItem[	tag: "Operand2"L, string: @qLToolData.operand2,	place: [171,line2], menuProc: QLNameHintsForQueryList,        z: windowData.heap, inHeap: TRUE];      items[resultPos] ¬ StringItem[	tag: "Result"L, place: [348,line2],        string: @qLToolData.result, menuProc: QLNameHintsForQueryList,	z: windowData.heap, inHeap: TRUE];};   ENDCASE => ERROR; --shouldn't happen END;  QLNameHintsForQueryList: FormSW.MenuProcType =    BEGIN    arSH: AdobeOps.ARSystemHandle;    data: AdobeCommon.DataHandle ¬ AdobeCommon.GetDataSW[sw];    hintsLength, hintsIndex: CARDINAL ¬ 0;    hintSeq: LONG POINTER TO AdobeCommon.StringArray;    list: AdobeOps.QLHandle;        CountOtherQLs: PROCEDURE RETURNS [count: CARDINAL ¬ 0] =      BEGIN      list: AdobeOps.QLHandle ¬ arSH.otherQLs;      WHILE list # NIL DO        count ¬ count + 1;	list ¬ list.next;	ENDLOOP;      END;          IF data.context = NIL THEN {      hints ¬ NIL; RETURN};    arSH ¬ data.context.arSH;    freeHintsProc ¬ AdobeCommon.FreeHintStrings;    replace ¬ TRUE;     hintsLength ¬ CountOtherQLs[];    hintsLength ¬ hintsLength + 3;    hintsIndex ¬ 3;    hintSeq ¬ AdobeOps.z.NEW[AdobeCommon.StringArray[hintsLength]];    hintSeq[0] ¬ String.CopyToNewString["SysQL"L, AdobeOps.z];    hintSeq[1] ¬ String.CopyToNewString["List"L, AdobeOps.z];    hintSeq[2] ¬ String.CopyToNewString["filename"L, AdobeOps.z];    list ¬ arSH.otherQLs;    WHILE list # NIL DO      hintSeq[hintsIndex] ¬ String.CopyToNewString[        list.qL.name, AdobeOps.z];      hintsIndex ¬ hintsIndex + 1;      list ¬ list.next;      ENDLOOP;    hints ¬ DESCRIPTOR[hintSeq];    END;   QueryListFormSW: FormSW.ClientItemsProcType = BEGIN OPEN FormSW;   windowData: AdobeCommon.DataHandle ¬ AdobeCommon.GetDataSW[sw];   instanceData: AdobeCommonInternal.InstanceDataHandle ¬      windowData.instanceData;   WITH qLToolData: instanceData SELECT FROM   queryList => {     items ¬ AllocateItemDescriptor[1, windowData.heap];     freeDesc ¬ TRUE;     items[0] ¬ StringItem[	tag: "List"L, string: @qLToolData.list,	place: [0, line0], z: windowData.heap, inHeap: TRUE]};   ENDCASE => ERROR; --shouldn't happen END;       QLCommandProc: FormSW.ProcType =    BEGIN   windowData: AdobeCommon.DataHandle ¬ AdobeCommon.GetDataSW[sw];   instanceData: AdobeCommonInternal.InstanceDataHandle ¬      windowData.instanceData;   MsgSW.Clear[windowData.msgSW];   IF windowData.system = LAST[CARDINAL] OR windowData.context = NIL OR windowData.knownSystems = NIL OR windowData.knownSystems.next = 0 THEN {     AdobeCommon.PostMessage[windowData.msgSW, TRUE, "No available systems"L];     RETURN};   IF windowData.isBusy THEN     AdobeCommon.PostMessage[windowData.msgSW, TRUE,       "Adobe system is Busy.  Please try again later. "L]   ELSE {     windowData.isBusy ¬ TRUE;     IF instanceData.background AND ~TajoMisc.toolDriverRunning THEN       Process.Detach[         windowData.processID ¬ FORK AdobeCommon.CatchErrors[	   sw, item, index, windowData, ChooseQLCmd]]     ELSE {       windowData.processID ¬ Process.GetCurrent[];       AdobeCommon.CatchErrors[         sw, item, index, windowData, ChooseQLCmd]}}; END;   ChooseQLCmd: FormSW.ProcType =    BEGIN    windowData: AdobeCommon.DataHandle ¬ AdobeCommon.GetDataSW[sw];    BEGIN ENABLE UNWIND => windowData.isBusy ¬ FALSE;    IF windowData.context # NIL THEN {      SELECT index FROM	unionPos => ORSets[windowData];	intsctnPos => ANDSets[windowData];	copyToListPos => CopySet[windowData, FALSE];	copyToFilePos => CopySet[windowData, TRUE];	compPos => ComplementSet[windowData];	diffPos => DifferenceOfSets[windowData];	xorPos => XORSets[windowData];	ENDCASE => ERROR;      windowData.isBusy ¬ FALSE;      windowData.processID ¬ NIL;      AdobeCommon.PostMessage[windowData.msgSW, TRUE, "Done. "L]}    ELSE AdobeCommon.PostMessage[windowData.msgSW, TRUE, "Adobe is not set to an Adobe system. "L];    END;  END;  NotDoneYet: PROCEDURE [windowData: AdobeCommon.DataHandle] =    BEGIN    AdobeCommon.PostMessage[windowData.msgSW, TRUE, "Not Done Yet. "L];    END;      ORSets: PROCEDURE[data:AdobeCommon.DataHandle] =    BEGIN    set1, set2, resultSet: AdobeOps.SetOfARs ¬ NIL;    AdobeCommon.PostMessage[data.msgSW, FALSE, "Taking Union ... "L];    set1 ¬ GetSetOne[data];    set2 ¬ GetSetTwo[data];    --cannot use AdobeCommon.OrSets because it will free set1 and set2    --resultSet ¬ AdobeCommon.OrSets[set1, set2];    resultSet ¬ OrSetsImplB[set1, set2];    StoreQLinQueryList[data, resultSet];    END; --of ORSets      ANDSets: PROCEDURE[data:AdobeCommon.DataHandle] =    BEGIN    set1, set2, resultSet: AdobeOps.SetOfARs ¬ NIL;    AdobeCommon.PostMessage[      data.msgSW, FALSE, "Taking Intersection ... "L];    set1 ¬ GetSetOne[data];    set2 ¬ GetSetTwo[data];    --cannnot use AdobeCommon.AndSets because it will free set1 and set2    --resultSet ¬ AdobeCommon.AndSets[set1, set2];    resultSet ¬ AndSetsImplB[set1, set2];    StoreQLinQueryList[data, resultSet];    END; --of ANDSets         CopySet: PROCEDURE [data: AdobeCommon.DataHandle, toFile: BOOLEAN] =  --copies a querylist into a file or to list  --the querylist is gotten from operand1  --if the result field is not equal to "list" then, the filename is gotten from   --  the result field    BEGIN    sH: MStream.Handle;    mfRD: MStream.ReleaseData ¬ [NIL, NIL];    set: AdobeOps.SetOfARs ¬ NIL;    instanceData:AdobeCommonInternal.InstanceDataHandle ¬ data.instanceData;    formItem: FormSW.ItemHandle;        --code    AdobeCommon.PostMessage[data.msgSW, FALSE, "Copying ... "L];    set ¬ GetSetOne[data];    WITH queryListData: instanceData SELECT FROM      queryList => {        IF String.Equivalent[queryListData.result, "list"L] THEN {	  formItem ¬ FormSW.FindItem[instanceData.formSW, 0];	  formItem.flags.invisible ¬ TRUE;	  StoreQLinFileOrList[set, NIL, data];	  AdobeCommon.PostMessage[data.msgSW, TRUE, "copying to List. "L];	  formItem.flags.invisible ¬ FALSE;	  FormSW.DisplayItem[queryListData.formSW, 0]}	ELSE IF String.Equivalent[queryListData.result, "sysql"L] THEN {	  AdobeCommon.PostMessage[data.msgSW, TRUE, "copying to SysQL. "L];	  IF data.context.arSH.sysQL = NIL THEN 	    data.context.arSH.sysQL ¬ AdobeOps.z.NEW[AdobeOps.QueryListBody];	  data.context.arSH.sysQL.list ¬ set}	ELSE { 	  IF ~toFile THEN StoreQLinQueryList[data, set] 	  ELSE {	    sH ¬ MStream.WriteOnly[queryListData.result, mfRD, text !	      MStream.Error => {		AdobeCommon.PostMessage[data.msgSW, FALSE, " ERROR--"L];		IF queryListData.result =NIL OR queryListData.result.length = 0 THEN		  AdobeCommon.PostMessage[data.msgSW, FALSE, "no file specified in result field"L]		ELSE {		  AdobeCommon.PostMessage[data.msgSW, FALSE, queryListData.result];		        AdobeCommon.PostMessage[data.msgSW, FALSE, 		    " in result field"L]};		AdobeCommon.PostMessage[data.msgSW, TRUE, " cannot be obtained."L];		ERROR ABORTED}];	      StoreQLinFileOrList[set, sH, data];	      sH ¬ CleanUpStream[sH]}}};        ENDCASE => ERROR;  --shouldn't happen    END; --of CopySet      ComplementSet:  PROCEDURE [data: AdobeCommon.DataHandle] =    BEGIN    setIndex, tempIndex: CARDINAL ¬ 0;    ARNumber, lastAR: AdobeOps.ARNumber ¬ 0;    set, tempSet, resultSet: AdobeOps.SetOfARs ¬ NIL;    system: LONG STRING ¬ data.context.arSH.name;    --AdobeServer.ReadLastARNumber returns the total number of AR in the given    -- system    AdobeCommon.PostMessage[data.msgSW, FALSE, "Complementing sets ..."L];    lastAR ¬ AdobeServer.ReadLastARNumber[data.context.arSH.service, system];        set ¬ GetSetOne[data];        IF set = NIL THEN {      tempSet ¬ AdobeOps.z.NEW[AdobeOps.SetOfARsObject[1]];      tempSet[0] ¬ [1, lastAR];      StoreQLinQueryList[data, tempSet];      RETURN}    ELSE {      tempSet ¬ AdobeOps.z.NEW[AdobeOps.SetOfARsObject[set.len + 1]];      --initialize tempSet      FOR i: CARDINAL IN [0..tempSet.len) DO        tempSet[i] ¬ [0,0];      ENDLOOP};    IF set[setIndex].startValue # 1 THEN {      tempSet[tempIndex].startValue ¬ 1;      IF set[setIndex].startValue <= lastAR THEN         tempSet[tempIndex].runLength ¬ set[setIndex].startValue - 1      ELSE tempSet[tempIndex].runLength ¬ lastAR;      tempIndex ¬ tempIndex + 1};    WHILE setIndex < set.len DO       ARNumber ¬ set[setIndex].startValue + set[setIndex].runLength;      IF ARNumber >= lastAR + 1 THEN EXIT;           tempSet[tempIndex].startValue ¬ ARNumber;      setIndex ¬ setIndex + 1;      IF setIndex < set.len THEN         IF set[setIndex].startValue = lastAR THEN 	  tempSet[tempIndex].runLength ¬ lastAR - tempSet[tempIndex].startValue        ELSE IF set[setIndex].startValue > lastAR THEN 	  tempSet[tempIndex].runLength ¬ lastAR - tempSet[tempIndex].startValue + 1        ELSE tempSet[tempIndex].runLength ¬ set[setIndex].startValue - ARNumber      ELSE  tempSet[tempIndex].runLength ¬ lastAR - ARNumber + 1;      tempIndex ¬ tempIndex + 1;    ENDLOOP;    --prune tempSet    resultSet ¬ PruneQL[tempSet, tempIndex - 1];    StoreQLinQueryList[data, resultSet];        END;--of ComplementSet      DifferenceOfSets: PROCEDURE [data:AdobeCommon.DataHandle]  =    BEGIN    --assume that ARs given are in numeric order    ar1, ar2: AdobeOps.ARNumber ¬ 0;    set1, set2: AdobeOps.SetOfARs ¬ NIL;    set1Status, set2Status: AdobeCommon.SetStatus ¬ AdobeCommon.InitialSetStatus;    resultState: CARDINAL ¬ 0;    resultSet, tempSet: AdobeOps.SetOfARs ¬ NIL;        AdobeCommon.PostMessage[data.msgSW, FALSE, "Taking difference ... "L];    set1 ¬ GetSetOne[data];    set2 ¬ GetSetTwo[data];        IF set1 = NIL THEN {StoreQLinQueryList[data, NIL]; RETURN};     IF set2 = NIL THEN {StoreQLinQueryList[data, set1]; RETURN};     tempSet ¬ AdobeOps.z.NEW[AdobeOps.SetOfARsObject[set1.len]];    [ar1, set1Status] ¬ AdobeCommon.GetNextAR[set1, set1Status];    [ar2, set2Status] ¬ AdobeCommon.GetNextAR[set2, set2Status];    --initialize temp    FOR i: CARDINAL IN [0..tempSet.len) DO      tempSet[i] ¬ [0,0];      ENDLOOP;    --For the difference of two sets, set1-set2, if set1 is exhausted first,    -- we are done or if set2 is exhausted first, append what remains on     -- set1 to the resultset.    WHILE set1Status.setIndex < set1.len AND set2Status.setIndex < set2.len DO      SELECT TRUE FROM	ar1 = ar2 => {	  [ar2, set2Status] ¬ AdobeCommon.GetNextAR[set2, set2Status];	  [ar1, set1Status] ¬ AdobeCommon.GetNextAR[set1, set1Status]};	ar1 > ar2 => 	  [ar2, set2Status] ¬ AdobeCommon.GetNextAR[set2, set2Status];	ar1 < ar2 => {	  resultState ¬ AdobeCommon.AddToSet[ar1, @tempSet, resultState];	  [ar1, set1Status] ¬ AdobeCommon.GetNextAR[set1, set1Status]};	ENDCASE;            ENDLOOP;        --if set2 is exhausted first then append what remains on set1 to resultset.     WHILE set1Status.setIndex < set1.len DO      resultState ¬ AdobeCommon.AddToSet[ar1, @tempSet, resultState];      [ar1, set1Status] ¬ AdobeCommon.GetNextAR[set1, set1Status];    ENDLOOP;          --prune tempSet    resultSet ¬ PruneQL[tempSet, resultState];    StoreQLinQueryList[data, resultSet];          END;  -- of DifferenceOfSets  XORSets: PROCEDURE[data: AdobeCommon.DataHandle]  =    BEGIN  --assume that ARs given are in numeric order    ar1, ar2: AdobeOps.ARNumber ¬ 0;    set1,set2: AdobeOps.SetOfARs ¬ NIL;    set1Status, set2Status: AdobeCommon.SetStatus ¬ AdobeCommon.InitialSetStatus;    resultState: CARDINAL ¬ 0;    resultSet, tempSet: AdobeOps.SetOfARs ¬ NIL;    AdobeCommon.PostMessage[data.msgSW, FALSE, "XORing sets ..."L];    set1 ¬ GetSetOne[data];    set2 ¬ GetSetTwo[data];        IF set1 = NIL THEN {StoreQLinQueryList[data, set2]; RETURN};     IF set2 = NIL THEN {StoreQLinQueryList[data, set1]; RETURN};     tempSet ¬ AdobeOps.z.NEW[AdobeOps.SetOfARsObject[set1.len + set2.len]];    --initialize tempSet    FOR i: CARDINAL IN [0..tempSet.len) DO      tempSet[i] ¬ [0,0];      ENDLOOP;    [ar1, set1Status] ¬ AdobeCommon.GetNextAR[set1, set1Status];    [ar2, set2Status] ¬ AdobeCommon.GetNextAR[set2, set2Status];    WHILE set1Status.setIndex < set1.len AND set2Status.setIndex < set2.len DO      SELECT TRUE FROM	ar1 = ar2 => { 	  [ar2, set2Status] ¬ AdobeCommon.GetNextAR[set2, set2Status];	  [ar1, set1Status] ¬ AdobeCommon.GetNextAR[set1, set1Status]};	ar1 > ar2 => {	  resultState ¬ AdobeCommon.AddToSet[ar2, @tempSet, resultState];	  [ar2, set2Status] ¬ AdobeCommon.GetNextAR[set2, set2Status]};	ar1 < ar2 => {	  resultState ¬ AdobeCommon.AddToSet[ar1, @tempSet, resultState];	  [ar1, set1Status] ¬ AdobeCommon.GetNextAR[set1, set1Status]};	ENDCASE;      ENDLOOP;      WHILE set1Status.setIndex < set1.len DO        resultState ¬ AdobeCommon.AddToSet[ar1, @tempSet, resultState];	[ar1, set1Status] ¬ AdobeCommon.GetNextAR[set1, set1Status];	ENDLOOP;      WHILE set2Status.setIndex < set2.len DO        resultState ¬ AdobeCommon.AddToSet[ar2, @tempSet, resultState];	[ar2, set2Status] ¬ AdobeCommon.GetNextAR[set2, set2Status];	ENDLOOP;	      --prune tempSet      resultSet ¬ PruneQL[tempSet, resultState];      StoreQLinQueryList[data, resultSet];           END;  --of XORSets      GetSetOne: PROCEDURE[data:AdobeCommon.DataHandle] RETURNS[set1: AdobeOps.SetOfARs ¬ NIL] =  BEGIN  qlH: AdobeOps.QLHandle ¬ NIL;  instanceData: AdobeCommonInternal.InstanceDataHandle ¬ data.instanceData;   WITH queryListData: instanceData SELECT FROM    queryList =>       SELECT TRUE FROM      queryListData.operand1 = NIL OR queryListData.operand1.length = 0 => {          AdobeCommon.PostMessage[data.msgSW, TRUE, "sysQL will be used for operand1. "L];          IF data.context.arSH.sysQL = NIL THEN RETURN[NIL]	  ELSE RETURN[data.context.arSH.sysQL.list]};       String.Equivalent[queryListData.operand1, "list"L] => {          set1 ¬ GetList[data];	  RETURN[set1]};      String.Equivalent[queryListData.operand1, "sysQL"L] => {          IF data.context.arSH.sysQL = NIL THEN RETURN[NIL]          ELSE RETURN[data.context.arSH.sysQL.list]};      ENDCASE => {          qlH ¬ data.context.arSH.otherQLs;	  WHILE qlH # NIL DO	    IF String.Equivalent[queryListData.operand1, qlH.qL.name] THEN	      RETURN[qlH.qL.list];	    qlH ¬ qlH.next;	  ENDLOOP;	  --if this code is executed then operand1 is not in otherqls.	  --before returning sysQL, check if operand1 is a filename	  RETURN[RetrieveQL[queryListData.operand1, data]]};         ENDCASE;  --shouldn't happen;  END; --of GetSetOne    GetSetTwo: PROCEDURE [data: AdobeCommon.DataHandle] RETURNS[set2:     AdobeOps.SetOfARs] =    BEGIN    qlH:AdobeOps.QLHandle ¬ NIL;    instanceData: AdobeCommonInternal.InstanceDataHandle ¬ data.instanceData;  WITH queryListData: instanceData SELECT FROM    queryList =>      SELECT TRUE FROM      queryListData.operand2 = NIL OR queryListData.operand2.length = 0 => {          AdobeCommon.PostMessage[	    data.msgSW, TRUE, "sysQL will be used for operand2. "L];          IF data.context.arSH.sysQL = NIL THEN RETURN[NIL]	  ELSE RETURN[data.context.arSH.sysQL.list]};      String.Equivalent[queryListData.operand2, "list"L] => {          set2 ¬ GetList[data];	  RETURN[set2]};      String.Equivalent[queryListData.operand2, "sysQL"L] => {          <<IF data.context.arSH.sysQL = NIL THEN {	    data­.context­.arSH­.sysQL ¬ AdobeOps.z.NEW[AdobeOps.QueryListBody];	    data­.context­.arSH­.sysQL­.list ¬ NIL}>>          IF data.context.arSH.sysQL = NIL THEN RETURN[NIL]	  ELSE RETURN[data.context.arSH.sysQL.list]};      ENDCASE => {          qlH ¬ data.context.arSH.otherQLs;	  WHILE qlH # NIL DO	    IF String.Equivalent[queryListData.operand2, qlH.qL.name] THEN	      RETURN[qlH.qL.list];	    qlH ¬ qlH.next;	  ENDLOOP;	  --if this code is executed then operand2 is not in otherqls.	  --before returning sysQL, check if operand2 is a filename	  RETURN[RetrieveQL[queryListData.operand2, data]]};         ENDCASE;  --shouldn't happen;  END; --of GetSetTwo  GetList: PROCEDURE [data:AdobeCommon.DataHandle]  RETURNS [resultSet: AdobeOps.SetOfARs ¬ NIL] =    BEGIN    qlH:AdobeOps.QLHandle ¬ NIL;    setIndex, listIndex: CARDINAL ¬ 0;    arNumberString: LONG STRING ¬ NIL;    arNumber, prevarNumber: AdobeOps.ARNumber ¬ 0;    set: AdobeOps.SetOfARs ¬ NIL;    instanceData: AdobeCommonInternal.InstanceDataHandle ¬ data.instanceData;        BEGIN ENABLE {      UNWIND => {      IF arNumberString # NIL THEN String.FreeString[data.heap, arNumberString];      IF set # NIL THEN AdobeOps.z.FREE[@set]}};        GetAR: PROCEDURE[list: LONG STRING] =      BEGIN      arNumber ¬ 0;      WHILE listIndex < list.length AND list[listIndex] = '  DO	listIndex ¬ listIndex + 1;      ENDLOOP;      IF listIndex < list.length AND list[listIndex] NOT IN ['0..'9] AND list[listIndex] # '- THEN {        AdobeCommon.PostMessage[data.msgSW, TRUE, "Invalid character entered in List."L];	ERROR ABORTED};      WHILE listIndex < list.length AND list[listIndex] IN ['0..'9] DO        String.AppendChar[arNumberString, list[listIndex]];	listIndex ¬ listIndex + 1;      ENDLOOP;      IF listIndex < list.length AND list[listIndex] # '  AND list[listIndex] # '- THEN {        AdobeCommon.PostMessage[data.msgSW, TRUE, "Invalid character entered in List."L];	ERROR ABORTED};      IF arNumberString.length #0 THEN {        arNumber ¬ String.StringToLongNumber[s: arNumberString];	IF arNumber = 0 THEN {	  AdobeCommon.PostMessage[data.msgSW, TRUE, "AR number 0 is invalid"L];	  ERROR ABORTED}};      arNumberString ¬ ClearString[arNumberString];      WHILE listIndex < list.length AND list[listIndex] = '  DO	listIndex ¬ listIndex + 1;      ENDLOOP;       IF listIndex < list.length AND list[listIndex] NOT IN ['0..'9] AND list[listIndex] # '- THEN {        AdobeCommon.PostMessage[data.msgSW, TRUE, "Invalid character entered in List."L];	ERROR ABORTED};           END;--of GetAR              WITH queryListData: instanceData SELECT FROM      queryList => {        IF queryListData.list = NIL OR queryListData.list.length = 0 THEN RETURN[NIL];	arNumberString ¬ String.MakeString[data.heap, 16];        set ¬ AdobeOps.z.NEW[AdobeOps.SetOfARsObject[10]];        --initialize temp        FOR i: CARDINAL IN [0..set.len) DO          set[i] ¬ [0,0];        ENDLOOP;         WHILE listIndex < queryListData.list.length DO	  GetAR[queryListData.list];	SELECT TRUE FROM	  prevarNumber = 0 AND arNumber = 0 =>  AdobeCommon.PostMessage[data.msgSW, TRUE, "List is empty or invalid list format.  An empty query list has been created"L];	  prevarNumber > arNumber AND arNumber # 0 =>  {	                          AdobeCommon.PostMessage[data.msgSW, TRUE, "The numbers entered in list should be in ascending order."L];	    ERROR ABORTED};	  prevarNumber = arNumber => {	    AdobeCommon.PostMessage[data.msgSW, TRUE, "Duplicate numbers."L];	    ERROR ABORTED};	  ENDCASE;	  prevarNumber ¬ arNumber;	  IF set[setIndex].startValue + set[setIndex].runLength = arNumber THEN	    set[setIndex].runLength ¬ set[setIndex].runLength + 1	  ELSE  {	    IF set[setIndex].startValue # 0 THEN {	      setIndex ¬ setIndex + 1;	      IF setIndex = set.len THEN AdobeCommon.GrowSet[@set]};	    set[setIndex].startValue ¬ arNumber;	    set[setIndex].runLength ¬ 1};	    	  IF listIndex < queryListData.list.length AND queryListData.list[listIndex] = '- THEN {	    listIndex ¬ listIndex + 1;	    GetAR[queryListData.list];	    IF prevarNumber > arNumber AND arNumber # 0 THEN {	                                 AdobeCommon.PostMessage[data.msgSW, TRUE, "The numbers entered in list should be in ascending order."L];	      ERROR ABORTED};	    set[setIndex].runLength ¬ arNumber - set[setIndex].startValue + 1};	ENDLOOP};      ENDCASE;     resultSet ¬ PruneQL[set, setIndex];    END; --enable    END;--of GetList      OrSetsImplB: PROCEDURE [set1, set2: AdobeOps.SetOfARs]    RETURNS [resultSet: AdobeOps.SetOfARs] =    BEGIN    --taken from AdobeToolsB, I thought it would be faster to do this rather that to allocate and deallocate two sets    --assume that ARs given are in numeric order    ar1, ar2: AdobeOps.ARNumber;    set1Status, set2Status: AdobeCommon.SetStatus ¬ [0, 0];    resultState: CARDINAL ¬ 0;    tempSet: AdobeOps.SetOfARs;    IF set1 = NIL THEN RETURN[set2];    IF set2 = NIL THEN RETURN[set1];    tempSet ¬ AdobeOps.z.NEW[      AdobeOps .SetOfARsObject[set1.len + set2.len]];    ar1 ¬ set1[0].startValue;    ar2 ¬ set2[0].startValue;    --initialize temp    FOR i: CARDINAL IN [0..tempSet.len) DO      tempSet[i] ¬ [0, 0]; ENDLOOP;    --For OR, when one set is exhausted, we've got to append what     -- remains of the unexhausted set to the result.    WHILE set1Status.setIndex < set1.len      AND set2Status.setIndex < set2.len DO      SELECT TRUE FROM        ar1 = ar2 => {  --add only once          resultState ¬ AdobeCommon.AddToSet[ar1, @tempSet, resultState];          [ar2, set2Status] ¬ AdobeCommon.GetNextAR[set2, set2Status];          [ar1, set1Status] ¬ AdobeCommon.GetNextAR[            set1, set1Status]};        ar1 > ar2 => {          resultState ¬ AdobeCommon.AddToSet[ar2, @tempSet, resultState];          [ar2, set2Status] ¬ AdobeCommon.GetNextAR[            set2, set2Status]};        ar1 < ar2 => {          resultState ¬ AdobeCommon.AddToSet[ar1, @tempSet, resultState];          [ar1, set1Status] ¬ AdobeCommon.GetNextAR[            set1, set1Status]};        ENDCASE;      ENDLOOP;    IF set1Status.setIndex < set1.len THEN  --add rest of set1      WHILE set1Status.setIndex < set1.len DO        resultState ¬ AdobeCommon.AddToSet[ar1, @tempSet, resultState];        [ar1, set1Status] ¬ AdobeCommon.GetNextAR[set1, set1Status];        ENDLOOP    ELSE  --add rest of set2      WHILE set2Status.setIndex < set2.len DO        resultState ¬ AdobeCommon.AddToSet[ar2, @tempSet, resultState];        [ar2, set2Status] ¬ AdobeCommon.GetNextAR[set2, set2Status];        ENDLOOP;    IF resultState + 1 = (set1.len + set2.len) THEN {      --AdobeOps.z.FREE[@set1]; we don't want to free this      --AdobeOps.z.FREE[@set2]; we don't want to free this      RETURN[tempSet]}    ELSE {      resultSet ¬ AdobeOps.z.NEW[        AdobeOps .SetOfARsObject[resultState + 1]];      FOR i: CARDINAL IN [0..resultSet.len) DO        resultSet[i] ¬ tempSet[i]; ENDLOOP;      AdobeOps.z.FREE[@tempSet]};      --AdobeOps.z.FREE[@set1]; we don't want to free this      --AdobeOps.z.FREE[@set2]; we don't want to free this    END;      AndSetsImplB: PROCEDURE [set1, set2: AdobeOps.SetOfARs]    RETURNS [resultSet: AdobeOps.SetOfARs] =    BEGIN    --taken from AdobeToolsB, thought it would be faster to do this rather than allocating and deallocating space for the two sets    --next time we change AdobeCommon interface add boolean parameter to see if set should be freed    --assume that ARs given are in numeric order    ar1, ar2: AdobeOps.ARNumber;    set1Status, set2Status: AdobeCommon.SetStatus ¬      AdobeCommon.InitialSetStatus;    resultState: CARDINAL ¬ 0;    tempSet: AdobeOps.SetOfARs;    IF set1 = NIL THEN {      IF set2 # NIL THEN AdobeOps.z.FREE[@set2]; RETURN[NIL]}    ELSE IF set2 = NIL THEN {AdobeOps.z.FREE[@set1]; RETURN[NIL]};    tempSet ¬ AdobeOps.z.NEW[      AdobeOps .SetOfARsObject[MAX[set1.len, set2.len]]];    [ar1, set1Status] ¬ AdobeCommon.GetNextAR[set1, set1Status];    [ar2, set2Status] ¬ AdobeCommon.GetNextAR[set2, set2Status];    --initialize temp    FOR i: CARDINAL IN [0..tempSet.len) DO      tempSet[i] ¬ [0, 0]; ENDLOOP;    --For AND, when one set is exhausted, we've got all that are    -- common to both so can just exit knowing we're done    WHILE set1Status.setIndex < set1.len      AND set2Status.setIndex < set2.len DO      SELECT TRUE FROM        ar1 = ar2 => {          resultState ¬ AdobeCommon.AddToSet[ar1, @tempSet, resultState];          [ar2, set2Status] ¬ AdobeCommon.GetNextAR[set2, set2Status];          [ar1, set1Status] ¬ AdobeCommon.GetNextAR[            set1, set1Status]};        ar1 > ar2 =>          [ar2, set2Status] ¬ AdobeCommon.GetNextAR[set2, set2Status];        ar1 < ar2 =>          [ar1, set1Status] ¬ AdobeCommon.GetNextAR[set1, set1Status];        ENDCASE;      ENDLOOP;    IF resultState = 0 AND tempSet[0].startValue = 0 THEN {  --empty set      AdobeOps.z.FREE[@tempSet];      --AdobeOps.z.FREE[@set1];  we don't want to free this      --AdobeOps.z.FREE[@set2];  we don't want to free this      RETURN[NIL]};    --prune to just fit    IF resultState + 1 = MAX[set1.len, set2.len] THEN {      --AdobeOps.z.FREE[@set1]; we don't want to free this      --AdobeOps.z.FREE[@set2]; we don't want to free this      RETURN[tempSet]}    ELSE {      resultSet ¬ AdobeOps.z.NEW[        AdobeOps .SetOfARsObject[resultState + 1]];      FOR i: CARDINAL IN [0..resultSet.len) DO        resultSet[i] ¬ tempSet[i]; ENDLOOP;      AdobeOps.z.FREE[@tempSet]};      --AdobeOps.z.FREE[@set1];  we don't want to free this      --AdobeOps.z.FREE[@set2];  we don't want to free this    END;    RetrieveQL: PROCEDURE[fileName: LONG STRING, data:AdobeCommon.DataHandle] RETURNS [resultSet: AdobeOps.SetOfARs ¬ NIL] =  --reads a file containing ar numbers  BEGIN    --variables    fH: MStream.Handle ¬ NIL;    mfRD: MStream.ReleaseData ¬ [NIL, NIL];    char: CHARACTER ¬ ' ;    prevARNumber, arNumber: AdobeOps.ARNumber ¬ 0;    arNumberString: LONG STRING ¬ NIL;    tempSet: AdobeOps.SetOfARs ¬ NIL;    tempIndex: CARDINAL ¬ 0;    endOfFile: BOOLEAN ¬ FALSE;        BEGIN ENABLE {      UNWIND => {        IF fH # NIL THEN Stream.Delete[fH];	IF arNumberString # NIL THEN String.FreeString[data.heap, arNumberString];	IF tempSet # NIL THEN AdobeOps.z.FREE[@tempSet]}};             GetNextARNumber: PROCEDURE  =      BEGIN      WHILE char = ' DO        char ¬ Stream.GetChar[fH !Stream.EndOfStream => GOTO EOF];	ENDLOOP;      WHILE char IN ['0..'9] AND NOT endOfFile DO        String.AppendChar[arNumberString, char];        char ¬ Stream.GetChar[fH !Stream.EndOfStream => GOTO EOF];      ENDLOOP;      WHILE char = ' DO        char ¬ Stream.GetChar[fH !Stream.EndOfStream => GOTO EOF];	ENDLOOP;      IF char NOT IN ['0..'9] AND  char # '- THEN {        AdobeCommon.PostMessage[data.msgSW, TRUE, "Invalid character in file!  ."L];        ERROR ABORTED};      prevARNumber ¬ arNumber;      IF arNumberString.length = 0 THEN {        AdobeCommon.PostMessage[data.msgSW, TRUE, "Invalid syntax!  ."L];        ERROR ABORTED};      arNumber ¬ String.StringToLongNumber[s: arNumberString];      arNumberString ¬ ClearString[arNumberString];      IF arNumber <= prevARNumber THEN {        AdobeCommon.PostMessage[data.msgSW, TRUE, "AR numbers must be in ascending order!  ."L];        ERROR ABORTED}      EXITS        EOF => {	  IF arNumberString.length # 0 THEN {	    prevARNumber ¬ arNumber;            arNumber ¬ String.StringToLongNumber[s: arNumberString];	    IF arNumber <= prevARNumber THEN {              AdobeCommon.PostMessage[	        data.msgSW, TRUE, "AR numbers must be in ascending order!  ."L];              ERROR ABORTED};            arNumberString ¬ ClearString[arNumberString]};          endOfFile ¬ TRUE;}      END; --of GetNextARNumber                --code    fH ¬ MStream.ReadOnly[fileName, mfRD !MStream.Error =>      {AdobeCommon.PostMessage[data.msgSW, FALSE, fileName];       AdobeCommon.PostMessage[data.msgSW, TRUE, " does not exist as a querylist or file."L];       ERROR ABORTED}];    arNumberString ¬ String.MakeString[data.heap, 16];    tempSet ¬ AdobeOps.z.NEW[AdobeOps.SetOfARsObject[100]];    --initialize temp    FOR i: CARDINAL IN [0..tempSet.len) DO      tempSet[i] ¬ [0,0];    ENDLOOP;        GetNextARNumber[];    tempSet[0].startValue ¬ arNumber;    IF endOfFile OR char IN ['0..'9] THEN      tempSet[0].runLength ¬ 1    ELSE IF NOT endOfFile AND char = '- THEN {      char ¬ Stream.GetChar[fH !Stream.EndOfStream => {        AdobeCommon.PostMessage[data.msgSW, TRUE, "Invalid Syntax!  ."L];        ERROR ABORTED}];      GetNextARNumber[];      tempSet[0].runLength ¬ arNumber - tempSet[0].startValue + 1};    WHILE NOT endOfFile DO      GetNextARNumber[];      IF arNumber # tempSet[tempIndex].startValue + tempSet[tempIndex].runLength         THEN{         tempIndex ¬ tempIndex + 1;	IF tempIndex = tempSet.len THEN AdobeCommon.GrowSet[@tempSet];	tempSet[tempIndex].startValue ¬ arNumber;	IF endOfFile OR char IN ['0..'9]  THEN	  tempSet[tempIndex].runLength ¬ 1	ELSE IF NOT endOfFile AND char = '- THEN {	  char ¬ Stream.GetChar[fH !Stream.EndOfStream => {            AdobeCommon.PostMessage[data.msgSW, TRUE, "Invalid Syntax!  ."L];            ERROR ABORTED}];	  GetNextARNumber[];	  tempSet[tempIndex].runLength ¬ 	    arNumber - tempSet[tempIndex].startValue + 1}}       ELSE {         IF endOfFile OR char IN ['0..'9] THEN	   tempSet[tempIndex].runLength ¬ tempSet[tempIndex].runLength + 1	 ELSE IF NOT endOfFile AND char = '- THEN {	   char ¬ Stream.GetChar[fH !Stream.EndOfStream => {             AdobeCommon.PostMessage[data.msgSW, TRUE, "Invalid Syntax!  ."L];             ERROR ABORTED}];	   GetNextARNumber[];	   tempSet[tempIndex].runLength ¬ 	     arNumber - tempSet[tempIndex].startValue + 1;}}    ENDLOOP;        fH ¬ CleanUpStream[fH];    String.FreeString[data.heap, arNumberString];        --prune tempSet if necessary    resultSet ¬ PruneQL[tempSet, tempIndex]    END;    END; --of RetrieveQLStoreQLinQueryList: PROCEDURE[data: AdobeCommon.DataHandle, set: AdobeOps.SetOfARs] =  BEGIN  found: BOOLEAN ¬ FALSE;  qlH: AdobeOps.QLHandle ¬ NIL;  ql: AdobeOps.QueryList ¬ NIL;  instanceData: AdobeCommonInternal.InstanceDataHandle ¬ data.instanceData;  formItem: FormSW.ItemHandle;  WITH queryListData: instanceData SELECT FROM    queryList => {      IF queryListData.result = NIL OR queryListData.result.length = 0 THEN         AdobeCommon.PostMessage[	  data.msgSW, TRUE, "ERROR--result field not specified."L]      ELSE IF String.Equivalent[queryListData.result, "SysQL"L] THEN {	IF data­.context­.arSH­.sysQL = NIL THEN 	  data­.context­.arSH­.sysQL ¬ AdobeOps.z.NEW[AdobeOps.QueryListBody];	data­.context­.arSH­.sysQL­.list ¬ set}      ELSE IF String.Equivalent[queryListData.result, "List"L] THEN {        formItem ¬ FormSW.FindItem[instanceData.formSW, 0];        formItem.flags.invisible ¬ TRUE;        StoreQLinFileOrList[set, NIL, data];	formItem.flags.invisible ¬ FALSE;	FormSW.DisplayItem[queryListData.formSW, 0]}      ELSE {        qlH ¬ data.context.arSH.otherQLs;        WHILE qlH # NIL AND found = FALSE DO	    IF String.Equivalent[queryListData.result, qlH.qL.name] THEN	      found ¬ TRUE	    ELSE qlH ¬ qlH.next;	ENDLOOP;	IF found THEN qlH.qL.list ¬ set	ELSE {	  ql ¬ AdobeOps.z.NEW[AdobeOps.QueryListBody];	  ql­.name ¬ String.CopyToNewString[s:queryListData.result, z:AdobeOps.z];	  ql­.list ¬ set;	  AdobeCommon.AddToOtherQLList[data.context.arSH, ql]}}};	ENDCASE; --shoud not happen	    END;--of StoreQLinQueryList  StoreQLinFileOrList: PROCEDURE[set: AdobeOps.SetOfARs, fH: MStream.Handle, data: AdobeCommon.DataHandle] =    BEGIN    beginValue, runValue, endValue: AdobeOps.ARNumber ¬ 0;    stringValue: LONG STRING ¬NIL;    hyphen: CHARACTER ¬ '-;    space: CHARACTER ¬ ' ;    copyToList: BOOLEAN ¬ FALSE;    instanceData: AdobeCommonInternal.InstanceDataHandle ¬ data.instanceData;    WITH queryListData: instanceData SELECT FROM      queryList => {        IF fH = NIL THEN {	  copyToList ¬ TRUE; 	  IF queryListData.list = NIL THEN	    queryListData.list ¬ String.MakeString[data.heap,50];	    queryListData.list.length ¬ 0};	IF set # NIL THEN 	  BEGIN	  stringValue ¬ String.MakeString[data.heap,16];	  FOR index:CARDINAL IN [0..set.len) DO	    beginValue ¬ set[index].startValue;	    stringValue ¬ ClearString[stringValue];	    String.AppendLongNumber[stringValue, beginValue];	    IF copyToList THEN String.AppendStringAndGrow[	      @queryListData.list, stringValue, data.heap, 50]	    ELSE Stream.PutString[fH, stringValue];	    runValue ¬ set[index].runLength;	    IF runValue = 1 AND index # set.len - 1 THEN 	      IF copyToList THEN String.AppendChar[queryListData.list, space] 	      ELSE Stream.PutChar[fH, space]	    ELSE IF runValue # 1 THEN {	      IF copyToList THEN String.AppendChar[queryListData.list, hyphen]	      ELSE Stream.PutChar[fH, hyphen];	      endValue ¬ beginValue + runValue -1;	      stringValue ¬ ClearString[stringValue]; 	      String.AppendLongNumber[stringValue, endValue];	      IF copyToList THEN String.AppendStringAndGrow[	        @queryListData.list, stringValue, data.heap, 50]	      ELSE Stream.PutString[fH, stringValue];	      IF index # set.len - 1 THEN 		IF copyToList THEN String.AppendChar[queryListData.list, space]	        ELSE Stream.PutChar[fH,space]};	  ENDLOOP;	  String.FreeString[data.heap, stringValue];	  END	ELSE IF ~copyToList THEN Stream.PutChar[fH,space]};        ENDCASE;    END;  CleanUpStream: PROCEDURE[streamHandle: MStream.Handle] RETURNS [MStream.Handle]=    BEGIN    Stream.Delete[streamHandle];    streamHandle ¬ NIL;    RETURN [streamHandle];    END; --of CleanUpStream           ClearString: PROCEDURE[inString: LONG STRING] RETURNS [LONG STRING ¬ NIL] =    BEGIN    index: CARDINAL ¬ 0;   -- FOR index IN [0..16) DO     -- inString.text[index] ¬ '  ;    FOR index IN [0..inString.length) DO      inString.text[index] ¬ ' ;    ENDLOOP;    inString.length ¬ 0;    RETURN [inString];    END; --of ClearString         PruneQL: PROCEDURE[set:AdobeOps.SetOfARs, index:CARDINAL] RETURNS [AdobeOps.SetOfARs] =    BEGIN    newSet: AdobeOps.SetOfARs ¬ NIL;        IF set[0].startValue = 0 THEN {      AdobeOps.z.FREE[@set];      RETURN[NIL]};    IF index + 1 = set.len THEN RETURN[set]    ELSE {      newSet ¬ AdobeOps.z.NEW[AdobeOps.SetOfARsObject[index + 1]];      FOR i: CARDINAL IN [0..newSet.len) DO        newSet[i] ¬ set[i];      ENDLOOP;      AdobeOps.z.FREE[@set];      RETURN[newSet]};    END; --of PruneQL END. . .
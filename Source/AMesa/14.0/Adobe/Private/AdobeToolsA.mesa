-- File: AdobeToolsA.mesa - created by RSF. Last edit:-- JCS                  24-May-86 17:15:23-- RSF			16-Apr-86 18:13:04-- RLC			24-Feb-88 11:51:10-- Copyright (C) 1985, 1986, 1987, 1988 by Xerox Corporation. All rights reserved. DIRECTORY  AdobeCommon USING [    CatchErrors, DataHandle, DisableAdobeAborts, EnableAdobeAborts,    FindThisQL, GetData, GetDataSW, GetNextAR,    GetPreviousAR, InitialSetStatus, PostMessage, PostNumber,    QLNameHints, SetChoicesForEnumerated],  AdobeCommonInternal USING [    AllocateInstanceData, ClickToConfirm, editCkdOutHeraldName, editHeraldName,    MakeARFormSW, FixOrdering, InstanceDataHandle, SetFieldDirty,    SetReadOnlys, SetTheDefaults, submitHeraldName, SetWindowName],  AdobeOps USING [    ARNumber, ARSystemHandle, FieldItemObject, nilARNumber, nilEnum,    nullDependsOnIndex, SetOfARs],  AdobeServer USING [    AboutToStore, CompletedUpdate, Error, FieldItemValue,    GetNextSubmitNumber, SubmitFailed, UpdateAcceleratorField],  AdobeToolContext USING [    ConvertStreamDataToUserContext, ClearUserContext,    ConvertUserContextToStreamData, CreateStream, EnumError,    FreeUserContext, GetValueFromEnumString, ResetDataTableValues, StreamError,    UserContext, UserContextRec],  ARAccess USING [    AbortCheckOut, ARHandle, CheckInAR, CheckOutAR, Error, ExamineAR,    FreeAR, GetAR, SubmitAR],  Cursor USING [GetInfo, Set, Type],  Date USING [Packed, StringToPacked, Unintelligible],  Environment USING [bytesPerPage],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType,    CommandItem, Display, DisplayItem, FindItem, ItemError,    ItemHandle, LongNumberItem, line0, nextLine, ProcType,    SetModifyNotificationProc, StringItem],  Menu USING [Instantiate, Make, MCRType],  MSegment USING [Address, Create, Handle, Kill],  MsgSW USING [Clear],  MFile USING [Acquire, Error, Handle, SetAccess],  MStream USING [Create, Error, ReadOnly, ReleaseData, WriteOnly],  PrincOps USING [LocalFrameHandle],  Process USING [Detach, GetCurrent],  SpecialRuntime USING [GetCurrentSignal, ReraiseError],  Stream USING [    Block, CompletionCode, defaultInputOptions, Delete, EndOfStream,    Handle, SubSequenceType],  String USING [    AppendLongNumber, CopyToNewString, EmptyString, ExpandString,    InvalidNumber, MakeString, StringToLongNumber],  TajoMisc USING [toolDriverRunning],  Time USING [Current],  Tool USING [MakeFormSW],  UserInput USING [WaitForConfirmation],  Window USING [Handle];AdobeToolsA: MONITOR  IMPORTS    AdobeCommon, AdobeCommonInternal, AdobeServer, AdobeToolContext,    ARAccess, Cursor, Date, FormSW, Menu, MFile, MSegment, MsgSW,    MStream, Process, SpecialRuntime, Stream, String, TajoMisc, Time,    Tool, UserInput  EXPORTS AdobeCommonInternal =  BEGIN  badEnumString: SIGNAL = CODE;  dontUpdate: SIGNAL = CODE;  pleaseAbort: SIGNAL [oldCursor: Cursor.Type] = CODE;  EnumeratedFIH: TYPE = LONG POINTER TO enumerated    AdobeOps.FieldItemObject;  backStr: LONG STRING ¬ NIL;  --globals for edit  examinePos: CARDINAL = 0;  checkInPos: CARDINAL = 1;  checkInOutPos: CARDINAL = 2;  checkInExaminePos: CARDINAL = 3;  checkOutPos: CARDINAL = 4;  abortCheckoutPos: CARDINAL = 5;  nextPos: CARDINAL = 6;  arNumPos: CARDINAL = 7;  previousPos: CARDINAL = 8;  edUseBackgroundPos: CARDINAL = 9;  editFilePos: CARDINAL = 10;  useQLPos: CARDINAL = 11;  useQLNamePos: CARDINAL = 12;  nEditParams: CARDINAL = 13;  --globals for submit  submitPos: CARDINAL = 0;  clearPos: CARDINAL = 1;  sbUseBackgroundPos: CARDINAL = 2;  putPos: CARDINAL = 3;  getPos: CARDINAL = 4;  submitFilePos: CARDINAL = 5;  nSubmitParams: CARDINAL = 6;  --globals for edit menu  defaultsIndex: CARDINAL = 0;  getIndex: CARDINAL = 1;  putIndex: CARDINAL = 2;  maxQLIndex: CARDINAL = 3;  nEditMenuItems: CARDINAL = 4;  --Routine to handle enumerateds  FixNewEnumerateds: PROCEDURE [sw: Window.Handle] =    BEGIN    itemIndex: CARDINAL;    windowData: AdobeCommon.DataHandle ¬ AdobeCommon.GetDataSW[sw];    arSh: AdobeOps.ARSystemHandle ¬ windowData.context.arSH;    FOR i: CARDINAL IN      [0..arSh.formSWOrderArray[windowData.tool].length) DO      itemIndex ¬ windowData.context.arSH.formSWOrderArray[        windowData.tool][i];      WITH f: arSh.fieldList[itemIndex] SELECT FROM        enumerated =>          IF f.field # AdobeOps.nullDependsOnIndex THEN            AdobeCommon.SetChoicesForEnumerated[              sw: sw, windowData: windowData, itemIndex: itemIndex,              fli: f.field, displayIndex: i, reset: FALSE];        ENDCASE;      ENDLOOP;    END;  --common to both edit and submit  PutProc: PROCEDURE [data: AdobeCommon.DataHandle] =    BEGIN    --written to be called either from submit or edit    instData: AdobeCommonInternal.InstanceDataHandle ¬      data.instanceData;    fH, sH: Stream.Handle;    mfH: MFile.Handle ¬ NIL;    errMsg, fileName: LONG STRING ¬ NIL;    couldBeForked: BOOLEAN ¬ TRUE;    BEGIN    ENABLE      MStream.Error, MFile.Error => {        errMsg ¬ "Invalid file name! "L; GOTO errorExit};    mfRD: MStream.ReleaseData ¬ [];    WITH t: instData SELECT FROM      edit => {fileName ¬ t.fileName; couldBeForked ¬ FALSE};      submit => fileName ¬ t.fileName;      ENDCASE;    mfH ¬ MFile.Acquire[      fileName, anchor, [NIL, NIL] !      MFile.Error =>        IF code = noSuchFile THEN  --file not in existance already--          CONTINUE];    AdobeCommon.PostMessage[      data.msgSW, FALSE, "Putting AR to file ... "L];    IF mfH # NIL THEN {  --file exists, may not want to overwrite      AdobeCommon.PostMessage[        data.msgSW, FALSE,        "File already exists! Click to overwrite. "L];      IF ~AdobeCommonInternal.ClickToConfirm[data, couldBeForked] THEN {        AdobeCommon.PostMessage[data.msgSW, TRUE, "Not saved!"L];        RETURN}      ELSE {        MFile.SetAccess[mfH, writeOnly];        fH ¬ MStream.Create[mfH, mfRD]}}    ELSE fH ¬ MStream.WriteOnly[fileName, mfRD, text];    sH ¬ AdobeToolContext.CreateStream[data.context.arSH.fieldList];    AdobeToolContext.ConvertUserContextToStreamData[sH, data.context];    [] ¬ CopyAR[to: fH, from: sH];    Stream.Delete[fH];    --IF mfH # NIL THEN MFile.Release[mfH];    AdobeCommon.PostMessage[data.msgSW, TRUE, "Done."L];    EXITS      errorExit => AdobeCommon.PostMessage[data.msgSW, FALSE, errMsg];    END;    END;  --PutProc  GetProc: PROCEDURE [data: AdobeCommon.DataHandle] =    BEGIN    --written to be called either from submit or edit    instData: AdobeCommonInternal.InstanceDataHandle ¬      data.instanceData;    fH, sH: Stream.Handle;    errMsg, fileName: LONG STRING ¬ NIL;    oldarId: AdobeOps.ARNumber;    arIdIndex: CARDINAL;    savedContext: AdobeToolContext.UserContext;    BEGIN  --for EXITS    mfRD: MStream.ReleaseData ¬ [];    WITH t: instData SELECT FROM      edit => fileName ¬ t.fileName;      submit =>        IF instData.formDirty THEN {          AdobeCommon.PostMessage[            data.msgSW, TRUE,            "Form has been edited!  Click to confirm! "L];          IF ~AdobeCommonInternal.ClickToConfirm[data] THEN RETURN	  ELSE fileName ¬ t.fileName}        ELSE fileName ¬ t.fileName;      ENDCASE;    AdobeCommon.PostMessage[      data.msgSW, FALSE, "Getting AR from file ... "L];    fH ¬ MStream.ReadOnly[      fileName, mfRD !      MStream.Error => {        errMsg ¬ "Invalid file name! "L; GOTO invalidFile}];    WITH editData: instData SELECT FROM      edit => {        IF editData.checkedOut THEN {          [oldarId, arIdIndex] ¬ FindARId[            data.context !            String.InvalidNumber => {              errMsg ¬ "Bad Data in AR!"L; GOTO badAR}; ];          savedContext ¬ SaveOldContext[data.context, data.heap]}};      ENDCASE;    sH ¬ AdobeToolContext.CreateStream[data.context.arSH.fieldList];    [] ¬ CopyAR[      to: sH, from: fH !      AdobeToolContext.StreamError => {        SELECT type FROM          fieldNameNotFound =>            errMsg ¬ "Bad AR file - Unknown field name! "L;          badValueField =>            errMsg ¬ "Bad AR file - Syntax error in value field!"L;          badFieldNameField =>            errMsg ¬ "Bad AR file - Syntax error in field name !"L;          missingFieldNameField =>            errMsg ¬ "Bad AR file - Field name missing!"L;          missingValueField =>            errMsg ¬ "Bad AR file - Value field missing!"L;          ENDCASE => errMsg ¬ "Unknown AdobeToolContext.StreamError"L;        GOTO badAR}];    SetFormSWFieldInvisible[data, instData.formSW, TRUE,  , TRUE];    AdobeToolContext.ConvertStreamDataToUserContext[      sH, data.context, data.heap];    instData.formDirty ¬ TRUE;    WITH instData SELECT FROM      edit =>        IF checkedOut THEN          CompareARNumbers[            oldarId, arIdIndex, data !            pleaseAbort => {              RestoreContext[data, savedContext];              Cursor.Set[oldCursor];              instData.formDirty ¬ FALSE;              GOTO abortedGet}];      ENDCASE;    FOR i: CARDINAL IN [0..data.context.length) DO      data.context[i].dirty ¬ TRUE; ENDLOOP;    FixNewEnumerateds[instData.formSW];    SetFormSWFieldInvisible[data, instData.formSW, FALSE, , TRUE];    FormSW.Display[instData.formSW];    Stream.Delete[fH];    AdobeCommon.PostMessage[data.msgSW, TRUE, "Done."L];    EXITS      badAR => {        AdobeCommon.PostMessage[data.msgSW, FALSE, errMsg];        Stream.Delete[fH]};      invalidFile =>        AdobeCommon.PostMessage[data.msgSW, FALSE, errMsg];      abortedGet => {        SetFormSWFieldInvisible[data, instData.formSW, FALSE, , TRUE];        Stream.Delete[fH];        AdobeCommon.PostMessage[          data.msgSW, FALSE, "not retrieved!"L]};    END;    END;  --GetProc  FindARId: PROCEDURE [uC: AdobeToolContext.UserContext]    RETURNS [arid: AdobeOps.ARNumber, keyIndex: CARDINAL] =    BEGIN    FOR i: CARDINAL IN [0..uC.arSH.fieldList.len) DO      WITH body: uC.arSH.fieldList[i] SELECT FROM        arId => {          WITH c: uC[i] SELECT FROM            nonDisplayedField =>              IF c.readOnlyField = NIL OR c.readOnlyField.length = 0                THEN RETURN[0, i]              ELSE                RETURN[                  String.StringToLongNumber[c.readOnlyField, 10], i];            displayedField =>              WITH c.editableField SELECT FROM                arId => RETURN[arn, i];                ENDCASE;            ENDCASE};        ENDCASE;      ENDLOOP;    ERROR;  --There must be exactly one arId field in the system    END;  --FindARId  SaveOldContext: PROCEDURE [    uC: AdobeToolContext.UserContext, z: UNCOUNTED ZONE]    RETURNS [copyOfContext: AdobeToolContext.UserContext] =    BEGIN    copyOfContext ¬ z.NEW[      AdobeToolContext .UserContextRec[uC.arSH.fieldList.len]];    FOR i: CARDINAL IN [0..uC.arSH.fieldList.len) DO      WITH c: uC[i] SELECT FROM        nonDisplayedField =>          copyOfContext[i] ¬ [            FALSE, nonDisplayedField[            String.CopyToNewString[c.readOnlyField, z]]];        displayedField =>          WITH body: c.editableField SELECT FROM            fixedLengthString =>              copyOfContext[i] ¬ [                FALSE, displayedField[                [                fixedLengthString[                String.CopyToNewString[body.s, z]]]]];            string =>              copyOfContext[i] ¬ [                FALSE, displayedField[                [string[String.CopyToNewString[body.s, z]]]]];            dateTime =>              copyOfContext[i] ¬ [                FALSE, displayedField[                [                dateTime[                String.CopyToNewString[body.temp, z], body.dt]]]];            ENDCASE =>              copyOfContext[i] ¬ [FALSE, displayedField[body]];        ENDCASE;      ENDLOOP;    copyOfContext.arSH ¬ uC.arSH;    END;  --SaveOldContext  RestoreContext: PROCEDURE [    data: AdobeCommon.DataHandle,    savedContext: AdobeToolContext.UserContext] =    BEGIN    instanceData: AdobeCommonInternal.InstanceDataHandle ¬      data.instanceData;    itemIndex: CARDINAL;    itemHandle: FormSW.ItemHandle;    sw: Window.Handle ¬ instanceData.formSW;    AdobeToolContext.FreeUserContext[@data.context, data.heap];    data.context ¬ savedContext;    --fix pointers FormSWs knows about    FOR i: CARDINAL IN      [0..data.context.arSH.formSWOrderArray[data.tool].length) DO      itemIndex ¬ data.context.arSH.formSWOrderArray[data.tool][i];      itemHandle ¬ FormSW.FindItem[sw, i];      WITH c: data.context[itemIndex] SELECT FROM        displayedField =>          WITH c.editableField SELECT FROM            arId =>              WITH h: itemHandle SELECT FROM                longNumber => h.value ¬ @arn;                ENDCASE;            dateTime =>              WITH h: itemHandle SELECT FROM                string => h.string ¬ @temp;                ENDCASE;            numeric =>              WITH h: itemHandle SELECT FROM                longNumber => h.value ¬ @num;                ENDCASE;            fixedLengthString, string =>              WITH h: itemHandle SELECT FROM                string => h.string ¬ @s;                ENDCASE;            enumerated =>              WITH h: itemHandle SELECT FROM                enumerated => h.value ¬ @value;                ENDCASE;            ENDCASE;        ENDCASE;      ENDLOOP;    END;  --RestoreContext  CompareARNumbers: PROCEDURE [    oldKey: AdobeOps.ARNumber, keyIndex: CARDINAL,    data: AdobeCommon.DataHandle] =    BEGIN    oldCursor: Cursor.Type;    WITH c: data.context[keyIndex] SELECT FROM      nonDisplayedField =>        IF String.StringToLongNumber[c.readOnlyField] = oldKey THEN          RETURN;      displayedField =>        WITH c.editableField SELECT FROM          arId => IF arn = oldKey THEN RETURN;          ENDCASE;      ENDCASE;    AdobeCommon.PostMessage[data.msgSW, TRUE, ""L];    AdobeCommon.PostMessage[      data.msgSW, TRUE,      "The AR in the file has a different number than the one you have checked out!  Get it anyway?"L];    --we're in Notifier here so no cursor form control problems    oldCursor ¬ Cursor.GetInfo[].type;    Cursor.Set[mouseRed];    IF UserInput.WaitForConfirmation[].okay THEN      RestoreKey[oldKey, keyIndex, data]    ELSE SIGNAL pleaseAbort[oldCursor];    Cursor.Set[oldCursor];    END;  --CompareARNumbers  RestoreKey: PROCEDURE [    key: AdobeOps.ARNumber, index: CARDINAL,    data: AdobeCommon.DataHandle] = {    WITH c: data.context[index] SELECT FROM      nonDisplayedField => {        data.heap.FREE[@c.readOnlyField];        String.AppendLongNumber[c.readOnlyField, key, 10]};      displayedField =>        WITH c.editableField SELECT FROM arId => arn ¬ key; ENDCASE;      ENDCASE};  bufferPages: CARDINAL = 4;  bufferBytes: CARDINAL = bufferPages * Environment.bytesPerPage;  CopyAR: PROCEDURE [from, to: Stream.Handle]    RETURNS [bytes: LONG CARDINAL] =    BEGIN    buffer: MSegment.Handle ¬ MSegment.Create[      file: NIL, release: [], pages: bufferPages];    bufferPtr: LONG POINTER ¬ MSegment.Address[buffer];    bytes ¬ 0;    DO      bytesTransferred: CARDINAL;      why: Stream.CompletionCode;      savedSST: Stream.SubSequenceType;      block: Stream.Block ¬ [bufferPtr, 0, bufferBytes];      [bytesTransferred, why, savedSST] ¬ from.get[        from, block, Stream.defaultInputOptions !        Stream.EndOfStream => {          why ¬ endOfStream; bytesTransferred ¬ nextIndex; CONTINUE}];      block.stopIndexPlusOne ¬ bytesTransferred;      bytes ¬ bytes + bytesTransferred;      to.put[to, block, FALSE];      IF why = endOfStream THEN EXIT;      ENDLOOP;    MSegment.Kill[buffer];    END;  --CopyAR  BuildFieldItemValue: PROCEDURE [    data: AdobeCommon.DataHandle, index: CARDINAL]    RETURNS [f: AdobeServer.FieldItemValue] =    BEGIN    GetMaxLength: PROCEDURE RETURNS [maxLength: CARDINAL] = {      WITH fLItem: data.context.arSH.fieldList[index] SELECT FROM        fixedLengthString => maxLength ¬ fLItem.maxLength;        ENDCASE};    WITH c: data.context.context[index] SELECT FROM      displayedField =>        WITH item: c.editableField SELECT FROM          arId => f ¬ [arId[item.arn]];          dateTime => {            ENABLE              Date.Unintelligible => {                f ¬ [dateTime[Time.Current[]]]; CONTINUE};	    IF String.EmptyString[item.temp] THEN	      f ¬ [dateTime[LOOPHOLE[LONG[0], Date.Packed]]]            ELSE f ¬ [dateTime[Date.StringToPacked[item.temp].dt]]};          numeric => f ¬ [numeric[item.num]];          fixedLengthString =>            f ¬ [fixedLengthString[item.s, GetMaxLength[]]];          enumerated => f ¬ [enumerated[item.value]];          ENDCASE => SIGNAL dontUpdate;      nonDisplayedField =>        WITH fLItem: data.context.arSH.fieldList[index] SELECT FROM          arId =>  --The arId had better have a valid value.  If it doesn't we want the error to surface.            f ¬ [              arId[              CARDINAL[              String.StringToLongNumber[c.readOnlyField, 10]]]];          dateTime => {            ENABLE              Date.Unintelligible => {                f ¬ [dateTime[Time.Current[]]]; CONTINUE};	    IF String.EmptyString[c.readOnlyField] THEN	      f ¬ [dateTime[LOOPHOLE[LONG[0], Date.Packed]]]            ELSE 	      f ¬ [dateTime[Date.StringToPacked[	        c.readOnlyField].dt]]};          numeric => {            ENABLE              String.InvalidNumber => {f ¬ [numeric[0]]; CONTINUE};            IF c.readOnlyField = NIL THEN f ¬ [numeric[0]]            ELSE              f ¬ [                numeric[                String.StringToLongNumber[c.readOnlyField, 10]]]};          fixedLengthString =>            f ¬ [              fixedLengthString[c.readOnlyField, fLItem.maxLength]];          enumerated => {            ENABLE              AdobeToolContext.EnumError => {                f ¬ [enumerated[AdobeOps.nilEnum]]; CONTINUE};            f ¬ [              enumerated[              AdobeToolContext.GetValueFromEnumString[              c.readOnlyField, data.context, index]]]};          ENDCASE => SIGNAL dontUpdate;      ENDCASE;    END;  --BuildFieldItemValue  SetAllFieldsReadOnly: PROCEDURE [data: AdobeCommon.DataHandle] =    BEGIN    inst: AdobeCommonInternal.InstanceDataHandle ¬ data.instanceData;    formItem: FormSW.ItemHandle;    FOR i: CARDINAL IN      [0..data.context.arSH.formSWOrderArray[data.tool].length) DO      formItem ¬ FormSW.FindItem[inst.formSW, i];      formItem.flags.readOnly ¬ TRUE;      ENDLOOP;    END;  -- Edit routines  CreateEditSW: PUBLIC PROCEDURE [    w: Window.Handle, makeCmdSW: BOOLEAN ¬ TRUE]    RETURNS [initialMsg: LONG STRING ¬ NIL] =    BEGIN    editMenuOptions: ARRAY [0..nEditMenuItems) OF LONG STRING;    data: AdobeCommon.DataHandle ¬ AdobeCommon.GetData[w];    instanceData: AdobeCommonInternal.InstanceDataHandle ¬      data.instanceData;    IF makeCmdSW THEN {  --there is no instanceData hanging around      instanceData ¬ AdobeCommonInternal.AllocateInstanceData[data];      editMenuOptions[defaultsIndex] ¬ "Defaults"L;      editMenuOptions[getIndex] ¬ "Get"L;      editMenuOptions[putIndex] ¬ "Put"L;      editMenuOptions[maxQLIndex] ¬ "Max QL"L;      WITH i: instanceData SELECT FROM        edit => {          i.editMenu ¬ Menu.Make[            name: "Adobe Edit"L, strings: DESCRIPTOR[editMenuOptions],            copyStrings: TRUE, mcrProc: EditMenuCommandRoutine];          Menu.Instantiate[i.editMenu, w]};        ENDCASE;      instanceData.cmdSW ¬ Tool.MakeFormSW[        window: w, formProc: EditCmdSW, zone: data.heap]};    --following IF is checking for whether a valid initialSystem    --was given in the User.cm    IF data.knownSystems # NIL AND data.context # NIL THEN      instanceData.formSW ¬ Tool.MakeFormSW[        window: w, formProc: AdobeCommonInternal.MakeARFormSW,        zone: data.heap !        FormSW.ItemError =>          IF code = illegalCoordinate THEN {            initialMsg ¬ AdobeCommonInternal.FixOrdering[              data, AdobeCommonInternal.MakeARFormSW, w, index];            CONTINUE}]    ELSE      instanceData.formSW ¬ Tool.MakeFormSW[        window: w, formProc: NilFormProc];    AdobeCommon.DisableAdobeAborts[w];    IF data.context # NIL THEN      FormSW.SetModifyNotificationProc[        instanceData.formSW, AdobeCommonInternal.SetFieldDirty];    AdobeCommonInternal.SetWindowName[      w,      IF data.knownSystems # NIL AND data.context # NIL AND data.system # LAST[CARDINAL] THEN      data.knownSystems[data.system] ELSE NIL,      AdobeCommonInternal.editHeraldName]    END;  --CreateEditSW  EditCmdSW: FormSW.ClientItemsProcType =    BEGIN OPEN FormSW;    windowData: AdobeCommon.DataHandle ¬ AdobeCommon.GetDataSW[sw];    instData: AdobeCommonInternal.InstanceDataHandle ¬      windowData.instanceData;    WITH toolData: instData SELECT FROM      edit => {        toolData.arIdNumber ¬ 0;        items ¬ AllocateItemDescriptor[nEditParams, windowData.heap];        freeDesc ¬ TRUE;        items[examinePos] ¬ CommandItem[          tag: "Examine"L, place: [0, line0], proc: EditCommandProc,          z: windowData.heap];        items[checkInPos] ¬ CommandItem[          tag: "Checkin"L, proc: EditCommandProc, z: windowData.heap];        items[checkInOutPos] ¬ CommandItem[          tag: "Checkin&out"L, proc: EditCommandProc,          z: windowData.heap];        items[checkInExaminePos] ¬ CommandItem[          tag: "Checkin&Exam"L, proc: EditCommandProc,          z: windowData.heap];        items[checkOutPos] ¬ CommandItem[          tag: "Checkout"L, proc: EditCommandProc,          z: windowData.heap];        items[abortCheckoutPos] ¬ CommandItem[          tag: "AbortCheckout"L, proc: EditCommandProc,          z: windowData.heap];        items[nextPos] ¬ CommandItem[          tag: "Next"L, proc: EditCommandProc, place: [0, nextLine],          z: windowData.heap];        items[arNumPos] ¬ LongNumberItem[          tag: "Number"L, value: @toolData.arIdNumber,          notNegative: TRUE, signed: FALSE, boxWidth: 48,          z: windowData.heap];        items[previousPos] ¬ CommandItem[          tag: "Previous"L, proc: EditCommandProc,          z: windowData.heap];        items[edUseBackgroundPos] ¬ BooleanItem[          tag: "Use background"L, switch: @toolData.background,          z: windowData.heap];        items[editFilePos] ¬ StringItem[          tag: "File name"L, string: @toolData.fileName,          z: windowData.heap, inHeap: TRUE];        items[useQLPos] ¬ BooleanItem[          tag: "UseQL"L, place: [0, nextLine],          switch: @toolData.useQL, proc: EditCommandProc,          z: windowData.heap];        items[useQLNamePos] ¬ StringItem[          tag: "QL to use"L, string: @toolData.qlName,          z: windowData.heap, menuProc: AdobeCommon.QLNameHints,          inHeap: TRUE]};      ENDCASE => ERROR  --should be impossible;    END;  --EditCmdSW  EditMenuCommandRoutine: Menu.MCRType =    BEGIN    data: AdobeCommon.DataHandle ¬ AdobeCommon.GetData[window];    instData: AdobeCommonInternal.InstanceDataHandle ¬      data.instanceData;    IF data.system = LAST[CARDINAL] OR data.context = NIL OR       data.knownSystems = NIL OR data.knownSystems.next = 0 THEN {      AdobeCommon.PostMessage[        data.msgSW, TRUE, "No available systems"L];      RETURN};    IF data.isBusy THEN {      AdobeCommon.PostMessage[        data.msgSW, TRUE,        "Adobe system is Busy.  Please try again later. "L];      RETURN};    MsgSW.Clear[data.msgSW];    WITH editData: instData SELECT FROM      edit =>        SELECT index FROM          defaultsIndex =>            IF editData.checkedOut THEN              AdobeCommonInternal.SetTheDefaults[data, FALSE]            ELSE              AdobeCommon.PostMessage[                data.msgSW, FALSE, "Do a checkout first! "L];          getIndex => GetProc[data];          putIndex => PutProc[data];          maxQLIndex => MenuItemNotDone[window];          ENDCASE;      ENDCASE;    END;  --EditMenuCommandRoutine  MenuItemNotDone: PROCEDURE [w: Window.Handle] =    BEGIN    windowData: AdobeCommon.DataHandle ¬ AdobeCommon.GetData[w];    AdobeCommon.PostMessage[      windowData.msgSW, TRUE, "Not Done Yet. "L];    END;  EditCommandProc: FormSW.ProcType =    BEGIN    windowData: AdobeCommon.DataHandle ¬ AdobeCommon.GetDataSW[sw];    instanceData: AdobeCommonInternal.InstanceDataHandle ¬      windowData.instanceData;    IF windowData.system = LAST[CARDINAL] OR windowData.knownSystems = NIL OR windowData.knownSystems.next = 0 OR windowData.context = NIL THEN {      AdobeCommon.PostMessage[        windowData.msgSW, TRUE, "No available systems"L];      RETURN};    IF windowData.isBusy THEN {      AdobeCommon.PostMessage[        windowData.msgSW, TRUE,        "Adobe system is Busy.  Please try again later. "L];      RETURN};    MsgSW.Clear[windowData.msgSW];    windowData.isBusy ¬ TRUE;    IF instanceData.background AND ~TajoMisc.toolDriverRunning THEN      Process.Detach[        windowData.processID ¬ FORK AdobeCommon.CatchErrors[	  sw, item, index, windowData, ChooseEditCmd]]    ELSE {      windowData.processID ¬ Process.GetCurrent[];      AdobeCommon.CatchErrors[        sw, item, index, windowData, ChooseEditCmd]};    END;  --EditCommandProc  ChooseEditCmd: FormSW.ProcType =    BEGIN    windowData: AdobeCommon.DataHandle ¬ AdobeCommon.GetDataSW[sw];    BEGIN ENABLE UNWIND => windowData.isBusy ¬ FALSE;    SELECT index FROM      examinePos => ExamineProc[windowData];      checkInPos => CheckInProc[windowData, index];      checkInOutPos => CheckInProc[windowData, index];      checkInExaminePos => CheckInProc[windowData, index];      checkOutPos => CheckOutProc[windowData];      abortCheckoutPos => AbortCheckOut[windowData];      useQLPos => SetUseQL[windowData, index];      nextPos => NextProc[windowData, sw];      previousPos => PreviousProc[windowData, sw];      ENDCASE => ERROR;    windowData.isBusy ¬ FALSE;    windowData.processID ¬ NIL;    END;  --enable    END;  --CatchErrorsForEdit  NotDoneYet: PROCEDURE [windowData: AdobeCommon.DataHandle] =    BEGIN    AdobeCommon.PostMessage[      windowData.msgSW, TRUE, "Not Done Yet. "L];    END;  SetUseQL: PROCEDURE [    windowData: AdobeCommon.DataHandle, index: CARDINAL] =    BEGIN    instData: AdobeCommonInternal.InstanceDataHandle ¬      windowData.instanceData;    formItem: FormSW.ItemHandle ¬ FormSW.FindItem[      instData.cmdSW, useQLNamePos];    useQLformItem: FormSW.ItemHandle ¬ FormSW.FindItem[      instData.cmdSW, useQLPos];    WITH editData: instData SELECT FROM      edit =>        IF editData.useQL THEN {          editData.qlSetStatus ¬ AdobeCommon.InitialSetStatus;          editData.qlHandle ¬ AdobeCommon.FindThisQL[            editData.qlName, windowData.context.arSH];          IF editData.qlHandle = NIL 	    OR editData.qlHandle.list = NIL THEN {            AdobeCommon.PostMessage[              windowData.msgSW, TRUE, "Empty Query List"L];	    useQLformItem.flags.invisible ¬ TRUE;            editData.useQL ¬ FALSE;	    useQLformItem.flags.invisible ¬ FALSE;            FormSW.DisplayItem[editData.cmdSW, index]}          ELSE formItem.flags.readOnly ¬ TRUE}        ELSE formItem.flags.readOnly ¬ FALSE;      ENDCASE;    END;  ExamineProc: PROCEDURE [windowData: AdobeCommon.DataHandle] =    BEGIN    arH: ARAccess.ARHandle ¬ NIL;    instData: AdobeCommonInternal.InstanceDataHandle ¬      windowData.instanceData;    AdobeCommon.PostMessage[      windowData.msgSW, FALSE, "Examining AR... "L];    WITH toolData: instData SELECT FROM      edit => {        ENABLE UNWIND => {IF arH # NIL THEN	  arH ¬ ARAccess.FreeAR[windowData.accessSession, arH];	  SetFormSWFieldInvisible[windowData, instData.formSW, FALSE, , TRUE]};        IF toolData.checkedOut THEN {          AdobeCommon.PostMessage[            windowData.msgSW, TRUE,            "Can't examine while an AR is Checked Out! "L];          RETURN};	SELECT TRUE FROM	  toolData.arIdNumber = 17777777777B => {	    AdobeCommon.PostMessage[              windowData.msgSW, TRUE, "AR number not specified."L];            RETURN};	  toolData.arIdNumber > LAST[CARDINAL] => {	    AdobeCommon.PostMessage[              windowData.msgSW, TRUE, "Invalid AR number."L];            RETURN};	  ENDCASE;        arH ¬ ARAccess.GetAR[          windowData.accessSession, toolData.arIdNumber];        IF toolData.sH = NIL THEN          toolData.sH ¬ AdobeToolContext.CreateStream[            windowData.context.arSH.fieldList]	ELSE AdobeToolContext.ResetDataTableValues[toolData.sH];        ARAccess.ExamineAR[          windowData.accessSession, arH, toolData.sH];        arH ¬ ARAccess.FreeAR[windowData.accessSession, arH];	SetFormSWFieldInvisible[windowData, instData.formSW, TRUE, , TRUE];        AdobeToolContext.ConvertStreamDataToUserContext[          toolData.sH, windowData.context, windowData.heap];        FixNewEnumerateds[toolData.formSW];        SetAllFieldsReadOnly[windowData];	SetFormSWFieldInvisible[windowData, instData.formSW, FALSE, , TRUE];        FormSW.Display[toolData.formSW];        AdobeCommon.PostMessage[windowData.msgSW, TRUE, "Done."L]};      ENDCASE => ERROR;  --should be impossible    END;  --ExamineProc  CheckInProc: PROCEDURE [    windowData: AdobeCommon.DataHandle, index: CARDINAL] =    BEGIN    instData: AdobeCommonInternal.InstanceDataHandle ¬      windowData.instanceData;    AdobeCommon.PostMessage[      windowData.msgSW, FALSE, "Checking in AR ... "L];    WITH toolData: instData SELECT FROM      edit => {        ENABLE {	AdobeServer.Error => {	  SELECT why FROM	    obsoleteVersion, sysDescChanging => {	      IF toolData.checkedOut THEN {		AdobeCommon.PostMessage[		  windowData.msgSW, TRUE, "Aborting checkout."L];		ARAccess.AbortCheckOut[		  session: windowData.accessSession, arH: toolData.arH];		toolData.checkedOut ¬ FALSE;		AdobeCommonInternal.SetWindowName[		  windowData.window,		  IF windowData.knownSystems # NIL		  AND windowData.context # NIL AND 		  windowData.system # LAST[CARDINAL] THEN 		  windowData.knownSystems[windowData.system] ELSE NIL,		  AdobeCommonInternal.editHeraldName];	        REJECT}};	    ENDCASE};	UNWIND => {	  IF ~toolData.checkedOut AND toolData.arH # NIL THEN	    toolData.arH  ¬ ARAccess.FreeAR[	      windowData.accessSession, toolData.arH]}};        IF toolData.checkedOut = FALSE THEN {          AdobeCommon.PostMessage[            windowData.msgSW, TRUE, "Do a CheckOut first! "L];          RETURN};        AdobeCommonInternal.SetTheDefaults[windowData, TRUE];        AdobeToolContext.ConvertUserContextToStreamData[          toolData.sH, windowData.context];        AdobeServer.AboutToStore[          windowData.context.arSH.service, windowData.knownSystems[          windowData.system], windowData.context.arSH.version,	  FindARId[windowData.context].arid];        ARAccess.CheckInAR[          windowData.accessSession, toolData.arH, toolData.sH];        toolData.checkedOut ¬ FALSE;        toolData.arH ¬ ARAccess.FreeAR[          windowData.accessSession, toolData.arH];        -- update accelerator files after checkin	AdobeCommon.PostMessage[	  windowData.msgSW, FALSE, "Updating Accelerator files ... "L];	BEGIN ENABLE AdobeServer.Error => SELECT why FROM	  courierTimedOut => { 	    --Inform user the AR was checked in but all updates not	    --completed at this time.	    AdobeCommon.PostMessage[windowData.msgSW, FALSE, "Update taking too long.  Will be completed later by the Adobe Service. "L];	    CONTINUE};   	    ENDCASE => REJECT;	  FOR i: CARDINAL IN [0..windowData.context.length) DO	    ENABLE	      AdobeServer.Error =>		--CheckIn has occured, reset banner		AdobeCommonInternal.SetWindowName[		  windowData.window,		  IF windowData.knownSystems # NIL		  AND windowData.context # NIL AND		  windowData.system # LAST[CARDINAL] THEN		  windowData.knownSystems[windowData.system] ELSE NIL,		  AdobeCommonInternal.editHeraldName];  	    IF windowData.context[i].dirty THEN	      AdobeServer.UpdateAcceleratorField[		server: windowData.context.arSH.service,		systemName: windowData.knownSystems[windowData.system],		version: windowData.context.arSH.version,		arNumber: FindARId[windowData.context].arid,		fieldName: windowData.context.arSH.fieldList[i].name,		value: BuildFieldItemValue[		windowData, i ! dontUpdate => LOOP]];	    ENDLOOP;	  AdobeServer.CompletedUpdate[	    windowData.context.arSH.service, windowData.knownSystems[	    windowData.system], FindARId[windowData.context].arid !	    <<inability of CompletedUpdate to complete is unimportant	      to the proper functioning of tool.  Getting an error here	      means the server has gone down since update of accelerator	      fields so accelerators and AR have been made consistent	      already.>>	    AdobeServer.Error => CONTINUE];	  END;         AdobeCommonInternal.SetWindowName[          windowData.window,          IF windowData.knownSystems # NIL          AND windowData.context # NIL AND windowData.system # LAST[CARDINAL]	  THEN windowData.knownSystems[          windowData.system] ELSE NIL,          AdobeCommonInternal.editHeraldName];        SELECT index FROM          checkInOutPos => CheckOutProc[windowData];          checkInExaminePos => ExamineProc[windowData];          checkInPos => {            SetAllFieldsReadOnly[windowData];            AdobeCommon.PostMessage[              windowData.msgSW, TRUE, "Done. "L]};          ENDCASE => ERROR;  --shouldn't happen--        };      ENDCASE => ERROR;  --shouldn't be possible    END;  --CheckInProc  CheckOutProc: PROCEDURE [windowData: AdobeCommon.DataHandle] =    BEGIN    instData: AdobeCommonInternal.InstanceDataHandle ¬      windowData.instanceData;    AdobeCommon.PostMessage[      windowData.msgSW, FALSE, "Checking out AR ... "L];    WITH toolData: instData SELECT FROM      edit => {        ENABLE UNWIND => {	  IF toolData.checkedOut THEN	    ARAccess.AbortCheckOut[	      windowData.accessSession, toolData.arH! ARAccess.Error => CONTINUE];	  IF toolData.arH # NIL THEN toolData.arH ¬ ARAccess.FreeAR[	    windowData.accessSession, toolData.arH! ARAccess.Error => CONTINUE];	  SetFormSWFieldInvisible[windowData, instData.formSW, FALSE,  , TRUE]};        IF toolData.checkedOut THEN {          AdobeCommon.PostMessage[            windowData.msgSW, TRUE,            "Can't do another checkout before a checkin! "L];          RETURN};	IF toolData.arIdNumber = 17777777777B THEN {	  AdobeCommon.PostMessage[            windowData.msgSW, TRUE, "AR number not specified."L];          RETURN};        IF toolData.sH = NIL THEN          toolData.sH ¬ AdobeToolContext.CreateStream[            windowData.context.arSH.fieldList]	ELSE AdobeToolContext.ResetDataTableValues[toolData.sH];        toolData.arH ¬ ARAccess.GetAR[          windowData.accessSession, toolData.arIdNumber];        ARAccess.CheckOutAR[          windowData.accessSession, toolData.arH, toolData.sH];        toolData.checkedOut ¬ TRUE;	SetFormSWFieldInvisible[windowData, instData.formSW, TRUE,  , TRUE];        AdobeToolContext.ConvertStreamDataToUserContext[          toolData.sH, windowData.context, windowData.heap];        FixNewEnumerateds[toolData.formSW];        AdobeCommonInternal.SetReadOnlys[windowData];	SetFormSWFieldInvisible[windowData, instData.formSW, FALSE,  , TRUE];        FormSW.Display[toolData.formSW];        AdobeCommonInternal.SetWindowName[          windowData.window,          IF windowData.knownSystems # NIL          AND windowData.context # NIL AND windowData.system # LAST[CARDINAL]	  THEN windowData.knownSystems[          windowData.system] ELSE NIL,          AdobeCommonInternal.editCkdOutHeraldName];        AdobeCommon.PostMessage[windowData.msgSW, TRUE, "Done."L]}      ENDCASE => ERROR;  --shouldn't happen    END;  --CheckOutProc  AbortCheckOut: PROCEDURE [windowData: AdobeCommon.DataHandle] =    BEGIN    instData: AdobeCommonInternal.InstanceDataHandle ¬      windowData.instanceData;    AdobeCommon.PostMessage[      windowData.msgSW, FALSE, "Aborting check out ... "L];    WITH toolData: instData SELECT FROM      edit => {        ENABLE UNWIND => {	  IF ~toolData.checkedOut THEN {	    --we're essentially done already	    AdobeCommonInternal.SetWindowName[	      windowData.window,	      IF windowData.knownSystems # NIL	        AND windowData.context # NIL AND		windowData.system # LAST[CARDINAL] THEN	        windowData.knownSystems[windowData.system] ELSE NIL,	      AdobeCommonInternal.editHeraldName];	    SetAllFieldsReadOnly[windowData];	    IF toolData.arH # NIL THEN toolData.arH ¬ ARAccess.FreeAR[	      windowData.accessSession, toolData.arH]}};        IF ~toolData.checkedOut THEN {          AdobeCommon.PostMessage[            windowData.msgSW, FALSE, "No AR checked out! "L];          RETURN};        ARAccess.AbortCheckOut[          session: windowData.accessSession, arH: toolData.arH];        toolData.checkedOut ¬ FALSE;        toolData.arH ¬ ARAccess.FreeAR[          windowData.accessSession, toolData.arH];        AdobeCommonInternal.SetWindowName[          windowData.window,          IF windowData.knownSystems # NIL          AND windowData.context # NIL AND windowData.system # LAST[CARDINAL]	  THEN windowData.knownSystems[          windowData.system] ELSE NIL,          AdobeCommonInternal.editHeraldName]};      ENDCASE => ERROR;  --shouldn't happen    SetAllFieldsReadOnly[windowData];    AdobeCommon.PostMessage[windowData.msgSW, TRUE, "Done."L]    END;  --AbortCheckOut  NextProc: PROCEDURE [    windowData: AdobeCommon.DataHandle, sw: Window.Handle] =    BEGIN    instData: AdobeCommonInternal.InstanceDataHandle ¬      windowData.instanceData;    ar: AdobeOps.ARNumber;    formItem, formItem2: FormSW.ItemHandle;    WITH toolData: instData SELECT FROM      edit => {        ENABLE UNWIND => NULL; --need anything?        formItem ¬ FormSW.FindItem[sw, arNumPos];	formItem.flags.invisible ¬ TRUE;        IF toolData.useQL THEN {          [ar, toolData.qlSetStatus] ¬ AdobeCommon.GetNextAR[            toolData.qlHandle.list, toolData.qlSetStatus];          IF ar = 0 THEN {  -- Query List Exhausted            AdobeCommon.PostMessage[              windowData.msgSW, TRUE, "Query List Exhausted"L];	    formItem2 ¬ FormSW.FindItem[sw, useQLPos];	    formItem2.flags.invisible ¬ TRUE;            toolData.useQL ¬ FALSE;	    formItem2.flags.invisible ¬ FALSE;            FormSW.DisplayItem[sw, useQLPos];	    formItem2 ¬ FormSW.FindItem[sw, useQLNamePos];            formItem2.flags.readOnly ¬ FALSE}          ELSE toolData.arIdNumber ¬ ar}        ELSE toolData.arIdNumber ¬ toolData.arIdNumber + 1};      ENDCASE => ERROR;  --shouldn't happen    formItem.flags.invisible ¬ FALSE;    FormSW.DisplayItem[sw, arNumPos];    END;  PreviousProc: PROCEDURE [    windowData: AdobeCommon.DataHandle, sw: Window.Handle] =    BEGIN    instData: AdobeCommonInternal.InstanceDataHandle ¬      windowData.instanceData;    ar: AdobeOps.ARNumber;    formItem, ARformItem: FormSW.ItemHandle;    setOfARs: AdobeOps.SetOfARs;    WITH toolData: instData SELECT FROM      edit => {        ENABLE UNWIND => NULL; --need anything?	ARformItem ¬ FormSW.FindItem[sw, arNumPos];	ARformItem.flags.invisible ¬ TRUE;        IF toolData.useQL THEN {          setOfARs ¬ toolData.qlHandle.list;          [ar, toolData.qlSetStatus] ¬ AdobeCommon.GetPreviousAR[            setOfARs, toolData.qlSetStatus];          IF ar = 0 THEN {  -- Query List Exhausted            AdobeCommon.PostMessage[              windowData.msgSW, TRUE, "Query List Exhausted"L];	    formItem ¬ FormSW.FindItem[sw, useQLPos];	    formItem.flags.invisible ¬ TRUE;            toolData.useQL ¬ FALSE;	    formItem.flags.invisible ¬ FALSE;            FormSW.DisplayItem[sw, useQLPos];            formItem ¬ FormSW.FindItem[sw, useQLNamePos];            formItem.flags.readOnly ¬ FALSE}          ELSE toolData.arIdNumber ¬ ar}        ELSE          IF toolData.arIdNumber > 1 THEN            toolData.arIdNumber ¬ toolData.arIdNumber - 1}      ENDCASE => ERROR;  --shouldn't happen    ARformItem.flags.invisible ¬ FALSE;    FormSW.DisplayItem[sw, arNumPos];    END;  --Submit routines  CreateSubmitSW: PUBLIC PROCEDURE [    w: Window.Handle, makeCmdSW: BOOLEAN ¬ TRUE]    RETURNS [initialMsg: LONG STRING ¬ NIL] =    BEGIN    data: AdobeCommon.DataHandle ¬ AdobeCommon.GetData[w];    instanceData: AdobeCommonInternal.InstanceDataHandle ¬      data.instanceData;    IF makeCmdSW THEN {  --there is no instanceData hanging around      instanceData ¬ AdobeCommonInternal.AllocateInstanceData[data];      instanceData.cmdSW ¬ Tool.MakeFormSW[        window: w, formProc: SubmitCmdSW, zone: data.heap]};    --following IF is checking for whether a valid initialSystem    --was given in the User.cm    IF data.knownSystems # NIL AND data.context # NIL THEN      instanceData.formSW ¬ Tool.MakeFormSW[        window: w, formProc: AdobeCommonInternal.MakeARFormSW,        zone: data.heap !        FormSW.ItemError =>          IF code = illegalCoordinate THEN {            initialMsg ¬ AdobeCommonInternal.FixOrdering[              data, AdobeCommonInternal.MakeARFormSW, w, index];            CONTINUE}]    ELSE      instanceData.formSW ¬ Tool.MakeFormSW[        window: w, formProc: NilFormProc];    AdobeCommon.DisableAdobeAborts[w];    IF data.context # NIL THEN {      AdobeCommonInternal.SetTheDefaults[data, FALSE];      AdobeCommonInternal.SetReadOnlys[data];      FormSW.SetModifyNotificationProc[        instanceData.formSW, AdobeCommonInternal.SetFieldDirty]};    AdobeCommonInternal.SetWindowName[      w,      IF data.knownSystems # NIL AND data.context # NIL AND       data.system # LAST[CARDINAL] THEN      data.knownSystems[data.system] ELSE NIL,      AdobeCommonInternal.submitHeraldName];    END;  --CreateSubmitSW  NilFormProc: FormSW.ClientItemsProcType = {    freeDesc ¬ TRUE;    items ¬ FormSW.AllocateItemDescriptor[1];    items[0] ¬ FormSW.StringItem[invisible: TRUE, string: @backStr]};  SubmitCmdSW: FormSW.ClientItemsProcType =    BEGIN OPEN FormSW;    windowData: AdobeCommon.DataHandle ¬ AdobeCommon.GetDataSW[sw];    instanceData: AdobeCommonInternal.InstanceDataHandle ¬      windowData.instanceData;    WITH submitToolData: instanceData SELECT FROM      submit => {        items ¬ AllocateItemDescriptor[          nSubmitParams, windowData.heap];        freeDesc ¬ TRUE;        items[submitPos] ¬ CommandItem[          tag: "Submit"L, place: [0, line0], proc: SubmitCommandProc,          z: windowData.heap];        items[clearPos] ¬ CommandItem[          tag: "Clear"L, proc: SubmitCommandProc, z: windowData.heap];        items[sbUseBackgroundPos] ¬ BooleanItem[          tag: "Use background"L, switch: @submitToolData.background,          z: windowData.heap];        items[putPos] ¬ CommandItem[          tag: "Put"L, proc: SubmitCommandProc, z: windowData.heap];        items[getPos] ¬ CommandItem[          tag: "Get"L, proc: SubmitCommandProc, z: windowData.heap];        items[submitFilePos] ¬ StringItem[          tag: "File"L, string: @submitToolData.fileName,          z: windowData.heap, inHeap: TRUE]};      ENDCASE => ERROR;  --shouldn't happen    END;  --SubmitCmdSW  SubmitCommandProc: FormSW.ProcType =    BEGIN    windowData: AdobeCommon.DataHandle ¬ AdobeCommon.GetDataSW[sw];    instanceData: AdobeCommonInternal.InstanceDataHandle ¬      windowData.instanceData;    IF windowData.system = LAST[CARDINAL] OR windowData.context = NIL OR windowData.knownSystems = NIL OR windowData.knownSystems.next = 0 THEN {      AdobeCommon.PostMessage[        windowData.msgSW, TRUE, "No available systems"L];      RETURN};    IF windowData.isBusy THEN {      AdobeCommon.PostMessage[        windowData.msgSW, TRUE,        "Adobe system is Busy.  Please try again later. "L];      RETURN};    MsgSW.Clear[windowData.msgSW];    windowData.isBusy ¬ TRUE;    --prevent AR from being modified during submit    IF index = submitPos THEN SetAllFieldsReadOnly[windowData];    IF instanceData.background AND ~TajoMisc.toolDriverRunning THEN      Process.Detach[        windowData.processID ¬ FORK AdobeCommon.CatchErrors[	  sw, item, index, windowData, ChooseSubmitCmd]]    ELSE {      windowData.processID ¬ Process.GetCurrent[];      AdobeCommon.CatchErrors[        sw, item, index, windowData, ChooseSubmitCmd]};    END;  --SubmitCommandProc  ChooseSubmitCmd: FormSW.ProcType =    BEGIN    windowData: AdobeCommon.DataHandle ¬ AdobeCommon.GetDataSW[sw];    BEGIN ENABLE UNWIND => windowData.isBusy ¬ FALSE;    SELECT index FROM      submitPos => SubmitProc[windowData];      clearPos => ClearAR[windowData];      putPos => PutProc[windowData];      getPos => GetProc[windowData];      ENDCASE => ERROR;    windowData.isBusy ¬ FALSE;    windowData.processID ¬ NIL;    END;    END;  --CatchErrorsForSubmit  SubmitProc: PROCEDURE [data: AdobeCommon.DataHandle] =    BEGIN    submitARNo: AdobeOps.ARNumber ¬ AdobeOps.nilARNumber;    signal: SIGNAL ¬ NIL;    signalArgs: PrincOps.LocalFrameHandle;    contextIndex: CARDINAL;    instanceData: AdobeCommonInternal.InstanceDataHandle ¬      data.instanceData;    Cleanup: PROCEDURE = {      AdobeServer.SubmitFailed[  	  server: data.context.arSH.service,	  systemName: data.knownSystems[data.system],	  arNumber: submitARNo,	  version: data.context.arSH.version!	  AdobeServer.Error =>	    SELECT why FROM	    sysDescChanging, obsoleteVersion, serverDown => CONTINUE;	    ENDCASE;];      AdobeCommonInternal.SetReadOnlys[data];      FormSW.Display[instanceData.formSW]};          BEGIN ENABLE UNWIND => {      --If an error occurs and we're unwound,       --make sure that the read-only status of the formSW is reset.      AdobeCommonInternal.SetReadOnlys[data];      FormSW.Display[instanceData.formSW]};    WITH submitData: instanceData SELECT FROM      submit => {        IF ~submitData.formDirty THEN {          AdobeCommon.PostMessage[            data.msgSW, TRUE, "Change the form before you submit! "L];          AdobeCommonInternal.SetReadOnlys[data];  --reset the form's readonly status          RETURN};        AdobeCommon.PostMessage[          data.msgSW, FALSE, "Submitting AR ... "L];	--GetNextSubmitNumber must complete uninterrupted else we may	--lose a submit number	AdobeCommon.DisableAdobeAborts[data.window];        submitARNo ¬ AdobeServer.GetNextSubmitNumber[          data.context.arSH.service, data.knownSystems[data.system],	  data.context.arSH.version];	AdobeCommon.EnableAdobeAborts[data.window];	IF submitData.sH = NIL THEN          submitData.sH ¬ AdobeToolContext.CreateStream[             data.context.arSH.fieldList];        --set AR number in AR to be submitted        contextIndex ¬ FindARId[data.context].keyIndex;        WITH c: data.context[contextIndex] SELECT FROM          nonDisplayedField => {            IF c.readOnlyField = NIL THEN              c.readOnlyField ¬ String.MakeString[data.heap, 6]	    ELSE IF c.readOnlyField.maxlength < 6 THEN	      String.ExpandString[	        @c.readOnlyField, 6-c.readOnlyField.length, data.heap];	      --ELSE c.readOnlyField.length ¬ 0;	    c.readOnlyField.length ¬ 0;            String.AppendLongNumber[c.readOnlyField, submitARNo]};          displayedField =>            WITH c.editableField SELECT FROM              arId => arn ¬ submitARNo;               ENDCASE;          ENDCASE;        AdobeCommonInternal.SetTheDefaults[data, TRUE];        AdobeToolContext.ConvertUserContextToStreamData[          sH: submitData.sH, from: data.context];	--notify AS of the AR number we are about to submit        AdobeServer.AboutToStore[          data.context.arSH.service, data.knownSystems[data.system],	  data.context.arSH.version, submitARNo];        ARAccess.SubmitAR[          data.accessSession, submitARNo, submitData.sH !          ANY => {	    -- If anything goes wrong, remember the signal, go off to 	    -- fix up the service info and re-raise after done.	    [signal, signalArgs] ¬ SpecialRuntime.GetCurrentSignal[];	    GOTO submitFailed}];	FormSW.Display[instanceData.formSW];        submitData.formDirty ¬ FALSE;      	AdobeCommon.PostMessage[	  data.msgSW, FALSE, "Updating Accelerator files ... "L];	-- We attempt to explicitly update the accelerator files for	--the AR submitted.  If this operation takes too long, we'll	--return to the user. The AS will finish updating the	--accelerator files for us later.        BEGIN ENABLE AdobeServer.Error =>	  SELECT why FROM	    courierTimedOut => {	    --Inform user the AR was submitted but all updates not	    --completed at this time.	    AdobeCommon.PostMessage[data.msgSW, FALSE, "Update taking too long.  Will be completed later by the Adobe Service. "L];	    CONTINUE};   	    ENDCASE => REJECT;	  FOR i: CARDINAL IN [0..data.context.length) DO	    AdobeServer.UpdateAcceleratorField[	      server: data.context.arSH.service,	      systemName: data.knownSystems[data.system],	      version: data.context.arSH.version,	      arNumber: submitARNo,	      fieldName: data.context.arSH.fieldList[i].name,	      value: BuildFieldItemValue[data, i ! dontUpdate => LOOP]];	    ENDLOOP;	  AdobeServer.CompletedUpdate[	    server: data.context.arSH.service,	    systemName: data.knownSystems[data.system],	    arNumber: submitARNo];	  END};      ENDCASE => ERROR;  --shouldn't be possibile    --At this point, we don't need the window contents anymore;    --lift readonlys to allow editing while accelerators update.    AdobeCommonInternal.SetReadOnlys[data];    AdobeCommon.PostMessage[      data.msgSW, FALSE, "Submitted Action Request "L];    AdobeCommon.PostNumber[data.msgSW, FALSE, submitARNo];    AdobeCommon.PostMessage[data.msgSW, TRUE, "  Done."L];    EXITS submitFailed => {      AdobeCommon.PostMessage[	data.msgSW, FALSE, "Submit failed... "L];      Cleanup[];      IF signal # NIL THEN	SpecialRuntime.ReraiseError[signalArgs, signal]};    END;    END;  --SubmitProc  ClearAR: PROCEDURE [data: AdobeCommon.DataHandle] =    BEGIN    instanceData: AdobeCommonInternal.InstanceDataHandle ¬      data.instanceData;    uC: AdobeToolContext.UserContext ¬ data.context;    WITH instanceData SELECT FROM      submit => {        IF instanceData.formDirty THEN {          AdobeCommon.PostMessage[            data.msgSW, TRUE,            "Form has been edited!  Click to confirm! "L];          IF ~AdobeCommonInternal.ClickToConfirm[data] THEN RETURN};        AdobeCommon.PostMessage[data.msgSW, FALSE, "Clearing ... "L];	SetFormSWFieldInvisible[data, instanceData.formSW, TRUE,  , TRUE];        AdobeToolContext.ClearUserContext[uC];        AdobeCommonInternal.SetTheDefaults[data, FALSE];        instanceData.formDirty ¬ FALSE;	SetFormSWFieldInvisible[data, instanceData.formSW, FALSE,  , TRUE];        FormSW.Display[instanceData.formSW]};      ENDCASE;    AdobeCommon.PostMessage[data.msgSW, TRUE, "Done."L];    END;         SetFormSWFieldInvisible: PROCEDURE [    data: AdobeCommon.DataHandle, wH: Window.Handle, invisible: BOOLEAN,    index: CARDINAL ¬ 0, all: BOOLEAN ¬ FALSE] =    BEGIN    inst: AdobeCommonInternal.InstanceDataHandle ¬ data.instanceData;    formItem: FormSW.ItemHandle;    IF all THEN {      FOR i: CARDINAL IN         [0..data.context.arSH.formSWOrderArray[data.tool].length) DO	formItem ¬ FormSW.FindItem[inst.formSW, i];	formItem.flags.invisible ¬ invisible;	ENDLOOP}    ELSE {      formItem ¬ FormSW.FindItem[inst.formSW, index];      formItem.flags.invisible ¬ invisible};    END;  END. . .  25-Jul-86  9:06:40 RLC fix PreviousProc to be like NextProc. No more uninitialized variables.22-Feb-88 13:42:08 - rlc - CheckOutProc: ARAccess.FreeAR should store results in toolData.arH; catch ARAccess.Error and CONTINUE.24-Feb-88 11:51:10 - rlc - catch error on ARAccess.AbortCheckOut.
-- Copyright (C) 1985  by Xerox Corporation. All rights reserved. -- File:  AdobeUpdaterImpl.mesa-- Last modified by:-- PAD      	 16-Jan-85 16:29:33-- RSF		 25-Sep-85 14:03:06-- RLC		 11-Jun-87 12:42:42DIRECTORY  AdobeCourier USING [DescribeSystemDescription],  AdobeOps USING [    ARNumber, ARSystemHandle, FieldItemObject, FieldList, nilARNumber,    nilEnum],  AdobeQOps USING [FindElementToBeUpdated, StoppingService],  AdobeSetUpdate USING [    ConvertStreamDataToUserContext, CreateStream,    UserContext, UserContextBody, UserContextRec],  AdobeServer USING [FieldItemValue],  AdobeServerOps USING [    Data, data, GetLocationOfARsInternal, RetrieveSystemDescription,    UpdateAcceleratorFieldInternal, VerifyVersionInternal],  AdobeUpdater USING [CompletedUpdate],  ARFileAccess USING [    Create, Destroy, Error, Logon, RetrieveAR, Session],  Courier USING [Free],  NSFile USING [AttributesRecord, String, Time],  NSString USING [AppendToMesaString, LogicalLength, String],  Process USING [EnableAborts, MsecToTicks, SetTimeout],  Stream USING [Delete, Handle],  String USING [MakeString],  Time USING [defaultTime];AdobeUpdaterImpl: MONITOR  IMPORTS    AdobeCourier, AdobeQOps, AdobeSetUpdate, AdobeServerOps,    AdobeUpdater, ARFileAccess, Courier, NSString, Process, Stream,    String  EXPORTS AdobeQOps =  BEGIN  data: AdobeServerOps.Data = @AdobeServerOps.data;  UpdateAccelerators: PROCEDURE [    systemName: LONG STRING, accessSession: ARFileAccess.Session,    arSH: AdobeOps.ARSystemHandle, arNumber: LONG CARDINAL]    RETURNS [newArSH: AdobeOps.ARSystemHandle,     newSession: ARFileAccess.Session] =    BEGIN    sH: Stream.Handle;    attsRec: NSFile.AttributesRecord;    arExists: BOOLEAN ¬ TRUE;    context: AdobeSetUpdate.UserContext;    newArSH ¬ arSH;    newSession ¬ accessSession;    IF ~AdobeServerOps.VerifyVersionInternal[      systemName, arSH.version] THEN {      arSH ¬ FreeSystemDescription[arSH];      newArSH ¬ AdobeServerOps.RetrieveSystemDescription[	system: systemName, z: data.z];      ARFileAccess.Destroy[accessSession];      newSession ¬ ARFileAccess.Create[	data.z, AdobeServerOps.GetLocationOfARsInternal[	systemName, @attsRec]];      ARFileAccess.Logon[newSession, data.serviceId]};    sH ¬ AdobeSetUpdate.CreateStream[newArSH.fieldList];    ARFileAccess.RetrieveAR[newSession, arNumber, sH     	! ARFileAccess.Error => {	   arExists ¬ FALSE;	   SELECT why FROM	     arNotFound => {	       AdobeUpdater.CompletedUpdate[     		 systemName: systemName, arNumber: arNumber] };	   ENDCASE;	   CONTINUE}];    IF arExists THEN {       context ¬ InitializeUserContext[newArSH, data.z];      AdobeSetUpdate.ConvertStreamDataToUserContext[	sH, context, data.z];      FOR i: CARDINAL IN [0..newArSH.fieldList.len) DO	WITH flItem: newArSH.fieldList[i] SELECT FROM	  string => NULL;	  ENDCASE => AdobeServerOps.UpdateAcceleratorFieldInternal[		       systemName: systemName, arNumber: arNumber,		       fieldName: flItem.name,		       value: BuildFieldItemValue[context[i], flItem]];		ENDLOOP;      FreeUserContext[@context, data.z];      AdobeUpdater.CompletedUpdate[       systemName: systemName, arNumber: arNumber]};    Stream.Delete[sH];    END;  FreeSystemDescription: PROCEDURE [    description: AdobeOps.ARSystemHandle]    RETURNS [nil: AdobeOps.ARSystemHandle] =    BEGIN    Courier.Free[[     description, AdobeCourier.DescribeSystemDescription], data.z];    data.z.FREE[@description];    RETURN[NIL];    END;   InitializeUserContext: PROCEDURE [    arSH: AdobeOps.ARSystemHandle, z: UNCOUNTED ZONE]    RETURNS [userContext: AdobeSetUpdate.UserContext] =    BEGIN    --allocate user context with object the size of field list    fL: AdobeOps.FieldList ¬ arSH.fieldList;    userContext ¬ z.NEW[AdobeSetUpdate.UserContextRec[fL.len]];    userContext.arSH ¬ arSH;    FOR i: CARDINAL IN [0..arSH.fieldList.len) DO      WITH body: fL[i] SELECT FROM        arId =>          userContext[i] ¬ [arId[AdobeOps.nilARNumber]];        fixedLengthString =>          userContext[i] ¬ [fixedLengthString[            String.MakeString[z, body.maxLength]]];        string =>          userContext[i] ¬ [string[NIL]];        dateTime =>          userContext[i] ¬ [dateTime[NIL, Time.defaultTime]];        numeric =>          userContext[i] ¬ [numeric[0]];        enumerated =>          userContext[i] ¬ [enumerated[AdobeOps.nilEnum]];        ENDCASE;      ENDLOOP;    END;      FreeUserContext: PROCEDURE [    uCPtr: LONG POINTER TO AdobeSetUpdate.UserContext,    z: UNCOUNTED ZONE] =    BEGIN     uC: AdobeSetUpdate.UserContext ¬ uCPtr­;    FOR i: CARDINAL IN [0..uC.length) DO      WITH body: uC[i] SELECT FROM        dateTime => z.FREE[@body.temp];        fixedLengthString, string => z.FREE[@body.s];        ENDCASE;    ENDLOOP;    z.FREE[uCPtr];    END;  BuildFieldItemValue: PROCEDURE [    body: AdobeSetUpdate.UserContextBody,     fli: AdobeOps.FieldItemObject]    RETURNS [f: AdobeServer.FieldItemValue] =    BEGIN    GetMaxLength: PROCEDURE RETURNS [maxLength: CARDINAL] = {      WITH fLItem: fli SELECT FROM        fixedLengthString => maxLength ¬ fLItem.maxLength;        ENDCASE};      WITH type: body SELECT FROM       arId => f ¬ [arId[type.arn]];       dateTime => f ¬ [dateTime[type.dt]];       numeric => f ¬ [numeric[type.num]];       fixedLengthString =>         f ¬ [fixedLengthString[type.s, GetMaxLength[]]];       enumerated => f ¬ [enumerated[type.value]];      ENDCASE => ERROR;    END;  PutUpdaterToSleep: PUBLIC PROCEDURE [systemIndex: CARDINAL] =    BEGIN data.systems[systemIndex].updaterSleep ¬ TRUE; END;  WakeUpdater: PUBLIC ENTRY PROCEDURE [systemIndex: CARDINAL] =    BEGIN ENABLE UNWIND => NULL;    data.systems[systemIndex].updaterSleep ¬ FALSE;    NOTIFY data.systems[systemIndex].startUpdater;    END;  Updater: PUBLIC PROCEDURE [    systemIndex: CARDINAL, accessSession: ARFileAccess.Session,    arSH: AdobeOps.ARSystemHandle] =    BEGIN    systemName: LONG STRING ¬ GetSystemName[systemIndex];  --freed when server taken down because heap (data.z) destroyed    Wait: ENTRY PROCEDURE = {      ENABLE UNWIND => NULL;  --release monitor lock      WHILE data.systems[systemIndex].updaterSleep DO        WAIT data.systems[systemIndex].startUpdater;        IF NOT AdobeQOps.StoppingService[] THEN	  data.systems[systemIndex].updaterSleep ¬ FALSE;        ENDLOOP;      data.systems[systemIndex].updaterSleep ¬ TRUE};    Process.EnableAborts[@data.systems[systemIndex].startUpdater];    Process.SetTimeout[      @data.systems[systemIndex].startUpdater,      Process.MsecToTicks[1000] * 60 * 5];  --5 min.    DO  <<outer loop - continuous>>      ENABLE ABORTED => { --catch Process.Abort        ARFileAccess.Destroy[accessSession];	arSH ¬ FreeSystemDescription[arSH];        EXIT};       found: BOOLEAN ¬ FALSE;      arNumber: LONG CARDINAL ¬ 0;      [found, arNumber] ¬ AdobeQOps.FindElementToBeUpdated[        systemIndex];      IF found THEN        [arSH, accessSession] ¬ UpdateAccelerators[	  systemName, accessSession, arSH, arNumber];      Wait[];      ENDLOOP;    END;  GetSystemName: PROCEDURE [index: CARDINAL]    RETURNS [system: LONG STRING] =    BEGIN    system ¬ String.MakeString[      data.z, NSString.LogicalLength[data.systems[index].name]];    NSString.AppendToMesaString[system, data.systems[index].name];    END;  END....11-Jun-87 12:42:42 - rlc - AR 10303. shoot calls to AdobeQOps.SetCV. Will use data.updaterSleep instead